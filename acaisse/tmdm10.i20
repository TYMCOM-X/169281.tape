(l,n)
!
(**********************************************************************)
(* **                  PROPRIETARY INFORMATION                     ** *)
(* **                                                              ** *)
(* **  This  source  code  listing  constitutes  the proprietary   ** *)
(* **  property of MDC-TYMNET.  The recipient, by receiving this   ** *)
(* **  program listing, agrees that neither this listing nor the   ** *)
(* **  information disclosed herein nor any part thereof shall be  ** *)
(* **  reproduced or transferred to other documents or used or dis-** *)
(* **  closed to others for manufacturing or for any other purpose ** *)
(* **  except as specifically authorized in writing by MDC-TYMNET. ** *)
(* ****************************************************************** *)
(* **                   PROGRAM IDENTIFICATION                     ** *)
(* **                                                              ** *)
(* **  Version Number     : 10.20         Release Date : 10/31/86  ** *)
(* **                                                              ** *)
(* **  File Name          : TMDM10.I20                             ** *)
(* **                                                              ** *)
(* **  File Description   : Initial part of TMDM 10.20 Source      ** *)
(* **                                                              ** *)
(* **  File Abstract      : The companion files are: 		   ** *)
(* **				TMDM10.R20			   ** *)
(* **				TMDM10.F20			   ** *)
(* **                                                              ** *)
(**********************************************************************)
(************************************************************************)
(*									*)
(*	TCONTS.TDR							*)
(*									*)
(*			 TABLE OF CONTENTS				*)
(*									*)
(*									*)
(*	SOURCE FILE NAME	SYSTEM TYPE				*)
(*	optn.tdr		compiler options			*)
(*	tconts.tdr		table of contents			*)
(*	vers.tdr		version					*)
(*	preflg.tms		preprocessor_defined_flags		*)
(*	config.tdr		configuration definitions		*)
(*	globl.tdr		global definitions			*)
(*	usrdef.tdr		user definitions			*)
(*	devmax.bas		device maximum definitions		*)
(*	devio.def		io definitions				*)
(*	udata.cmn							*)
(*	namefl.cmn							*)
(*	sdata.cmn							*)
(*	greetc.cmn							*)
(*	wblk.cmn							*)
(*	hstatc.cmn							*)
(*	threfl.cmn							*)
(*	condfl.cmn							*)
(*	reldat.cmn							*)
(*	xomhfl.cmn							*)
(*	bjobfl.cmn							*)
(*	clusfl.cmn							*)
(*	fildef.tdr		file system definitions			*)
(*	mutil.tms		misc_utility class			*)
(*	circ.bas		circuit_handler class			*)
(*	date.tms		date_time_converter class		*)
(*	form.bas		internal_to_string class		*)
(*	dskerr.tdr		disk_error class			*)
(*	dsksys.tdr		disk_system class			*)
(*	cmddef.tdr		command scanner definitions		*)
(*	cmds.tdr		command_table class			*)
(*	argscn.bas		argument_scanner class			*)
(*	cmdscn.bas		command_scanner class			*)
(*	cmderr.bas		command_error_message class		*)
(*	glbcmd.tdr		global_commands	class			*)
(*	cmdlp.tdr		command_loop class			*)
(*	filext.tdr		file_extender class			*)
(*	recon1.tdr		reconfigure class			*)
(*	disflg.tdr							*)
(*	newcon.tdr		new_configuration_parameters		*)
(*	local.tdr							*)
(*	recon2.tdr		reconfigure class			*)
(*	elogfl.tdr		event definations			*)
(*	elgdef.tms		erlog file definations			*)
(*	datgen.tdr		data_generate calss			*)
(*	dtinit.tdr		data_generate initializastion		*)
(*	restr1.tdr		restructure class			*)
(*	disflg.tdr							*)
(*	oldcon.tdr		old_configuration_parameters		*)
(*	local.tdr							*)
(*	restr2.tdr		restructure class			*)
(*	profil.tdr		profile class				*)
(*	namefl.tdr		namefile class				*)
(*	probfl.tdr		probe_passwords class			*)
(*	remofl.tdr		remote_down_messages class		*)
(*	btrefl.tdr		b_tree_file class			*)
(*	locbkt.tdr		location_bucket_file class		*)
(*	hststs.tdr		host_status_file class			*)
(*	uresfl.tdr		user_response_buffers class		*)
(*	udisfl.tdr		user_display_buffers class		*)
(*	sendfl.tdr		sendsend_file class			*)
(*	oplgfl.tdr		oplog_file class			*)
(*	threfl.tdr		threshold_condition_file class		*)
(*	condfl.tdr		condition_log class			*)
(*	reldat.tdr		reload_data_file class			*)
(*	xomhfl.tdr		xom_host_file class			*)
(*	bjobfl.tdr		background_job_file class		*)
(*	clusfl.tdr		cluster_name_file class			*)
(*	erlgfl.tdr		erlog_file class			*)
(*	dinit.tdr		disk_initializer class			*)
(*	switch.cpa		disk_switch class			*)
(*	cmdlvl.tdr		command_level process			*)
(*									*)
(************************************************************************)

(************************************************************************)
(*									*)
(*	VERS.TDR							*)
(*									*)
(************************************************************************)

const
  version = 10;
  revision = 20;

  date_of_update = 'Feb 28, 1986, for TMCS version 10.20\ ';

!
(************************************************************************)
(*									*)
(*	PREFLG.TMS Updated 20-Jan-86 at 9:14 by Hueyma			*)
(*									*)
(*			preprocessor_defined_flags			*)
(*									*)
(*	All defining of the conditional compilation "flags" used by	*)
(*	Concurrent Pascal Preprocessor must be done here.  The flags	*)
(*	are used by the preprocessor to either include or exclude	*)
(*	blocks of code from the final source code file.  If a flag	*)
(*	is enabled the code is included, if the flag is disabled the	*)
(*	code is not included in the final source code file.		*)
(*									*)
(*	This code has no operational or functional bearing on the	*)
(*	execution of TMCS but can be used to include/exclude any	*)
(*	features on a user basis.					*)
(*									*)
(*	The following statements preceeded with a "$" will not 		*)
(*	appear in the source code following execution of the		*)
(*	preprocessor, all comments will appear however.			*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	28Jun84	Original  ---  bss					*)
(*									*)
(************************************************************************)


(*									*)
(*  Currently defined preprocessor flags are:				*)
(*									*)
(*     	condition	- threshold_condition tracking code		*)
(*     	alarm		- alarm facility code				*)
(*			  (NOTE: the alarm facility also requires	*)
(*		   	         the condition flag be enabled.)	*)
(*									*)
(*     	elf		- elf interface code				*)
(*     	networkconsole	- network console interface code		*)
(*     	reload		- reload facility code				*)
(*                        (NOTE: the reload facility also requires	*)
(*			         that the elf and networkconsole flags	*)
(*				 also be enabled.)                      *)
(*									*)
(*	background	- if either the alarm or reload flags are on	*)
(*									*)
(*     	debug           - debug new code		 		*)
(*									*)
(*	clusternodes	- node cluster naming convention code		*)
(*									*)
(*	tymnetone	- tymnetI  nodes code				*)
(*									*)
(*	shut_link_table_maintenance	- shut link table maintenance 	*)
(*					  code				*)
(*									*)
(*	old_shut_link_table		- 3 bytes per node pair -- old	*)
(*					  4 bytes per node pair -- new	*)
(*									*)
(*	multiple_shut_link_table_maintenance				*)
(*					- multiple shut_link_maintainer *)
(*									*)
(*	multiple_host_message		- multiple host status messages	*)
(*					  for a given host		*)
(*									*)

$define tymnetone
$define condition
$define alarm
$define elf
$define networkconsole
$define reload
$define background
$define debug
$define clusternodes
$define shut_link_table_maintenance
$define old_shut_link_table
$define multiple_shut_link_table_maintenance
$define multiple_host_message

(*									*)
(*     Initially set all flags to disabled, users configuration         *)
(*     file will enable any that they desire.                           *)
(*									*)

$disable tymnetone
$disable condition
$disable alarm
$disable elf
$disable networkconsole
$disable reload
$disable background
$disable debug
$disable clusternodes
$disable shut_link_table_maintenance
$disable old_shut_link_table
$disable multiple_shut_link_table_maintenance
$disable multiple_host_message
!
(************************************************************************)
(*									*)
(*	CONFIG.TDR							*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	20May83	Original -- rer						*)
(*									*)
(************************************************************************)



(* The number of simultaneous users *)

const
  tdr_user_max = 1	(* users *);

!
(************************************************************************)
(*									*)
(*	GLOBL.TDR							*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Jan82	Original -- jnm						*)
(*									*)
(************************************************************************)

const	(* general purpose constants *)
  max_integer = 2147483647 ;
  min_integer = -max_integer-1;
  seconds_per_day = 86400 ;
  seconds_per_hour = 3600;
  base_year = 1974	(* base year for Engine dates *);

!
(***********************************************************************)
(*                                                                     *)
(*       ascii characters used by system			       *)
(*                                                                     *)
(***********************************************************************)

const
  ascnul = '(:00:)';
  asclf  = '(:10:)';
  asccr  = '(:13:)';
  ascdel = '(:127:)';
  asc_colon = ':';
  asc_comma = ',';
  asc_minus = '-';
  asc_plus = '+';
  asc_period = '.';
  asc_semi_colon = ';';
  asc_slash = '/';
  asc_space  = ' ';
  eom = '\'			(* end of message character *);
!
(************************)
(*			*)
(*	ascii strings	*)
(*			*)
(************************)

const
  nl = '(:13:)(:10:)\ '		(* new line sequence *);
!
(*	A maximum set of integers from 0-255. Other sets are defined	*)
(*	interms of this basic set.					*)

const
  basic_set_max   = 256 (* maximum cardinality *) ;
  basic_set_limit = basic_set_max - 1;
  bytes_per_basic_set = 32;

type
  basic_set_index = 0..basic_set_limit;
  basic_set_size  = 0..basic_set_max;

type
  basic_set = set of basic_set_index;

(*	A subset of node number used to construct a node set.		*)

const
  node_subset_max   = basic_set_max;
  node_subset_limit = basic_set_limit;

type
  node_subset_index = 0..node_subset_limit;

type
  node_subset = set of node_subset_index;

(*	A subset of host numbers used to construct a host_set.	*)

const
  host_subset_max   = basic_set_max;
  host_subset_limit = basic_set_limit;

type
  host_subset_index = 0..host_subset_limit;

type
  host_subset = set of host_subset_index;

(*  mxp index  *)

const
  mxp_max	= 16  (* machines *) ;
  mxp_limit	= mxp_max - 1;
 
type
  mxp_index	= 0..mxp_limit;

(*  slot index  *)

const
  slot_max	= 16 (* slots *) ;
  slot_limit	= slot_max - 1;

type
  slot_index	= 0..slot_limit;


(*  event set definitions  *)

const

  number_of_event_4_subevents  = 51;
  number_of_event_7_subevents  = 21;
  number_of_event_8_subevents  = 256;
  number_of_event_12_subevents = 56;
  number_of_event_19_subevents = 21;
  number_of_event_32_subevents = 31;
  number_of_event_80_subevents = 31;

  number_of_isis_subevents         = 256;

  main_event_max           = basic_set_max;
  main_event_limit         = main_event_max - 1;

  first_event_4_subevent   = main_event_limit + 1;
  last_event_4_subevent    =
        first_event_4_subevent + number_of_event_4_subevents - 1;

  first_event_7_subevent   =  last_event_4_subevent + 1;
  last_event_7_subevent    =
        first_event_7_subevent + number_of_event_7_subevents - 1;

  first_event_8_subevent   = last_event_7_subevent  + 1;
  last_event_8_subevent    =
        first_event_8_subevent + number_of_event_8_subevents - 1;

  first_event_12_subevent  = last_event_8_subevent   + 1;
  last_event_12_subevent   =
        first_event_12_subevent + number_of_event_12_subevents - 1;

  first_event_19_subevent  = last_event_12_subevent  + 1;
  last_event_19_subevent   =
        first_event_19_subevent + number_of_event_19_subevents - 1;

  first_event_32_subevent  = last_event_19_subevent  + 1;
  last_event_32_subevent   =
        first_event_32_subevent + number_of_event_32_subevents - 1;

  first_isis_subevent      = last_event_32_subevent + 1;
  last_isis_subevent       = first_isis_subevent + number_of_isis_subevents - 1;

  first_event_80_subevent  = last_isis_subevent  + 1;
  last_event_80_subevent   =
        first_event_80_subevent + number_of_event_80_subevents - 1;

  last_main_event_subevent = last_event_80_subevent;


  event_max                =
    ((last_isis_subevent + basic_set_limit) div basic_set_max) * basic_set_max;
  event_limit              = event_max - 1;

  event_set_max            = event_max div basic_set_max;
  event_set_limit          = event_set_max - 1;

  event_subset_max         = basic_set_max;
  event_subset_limit       = basic_set_limit;

type

  event_index              = 0..event_limit;
  event_set_index          = 0..event_set_limit;
  event_subset_index       = 0..event_subset_limit;
  main_event_index         = 0..event_subset_limit;

  event_subset      = set of event_subset_index;
  main_event_subset = set of main_event_index;
  event_set         = array [event_set_index] of event_subset;

type clusion_direction = boolean;

const
  exclusion = false;
  inclusion = true;

const
  clusion_list_max   = 30 (* integers *) ;
  clusion_list_limit = clusion_list_max-1;

type clusion_list_index = 0..clusion_list_limit;

type clusion_list_length = 0..clusion_list_max;

type
  clusion_list =
    record
      direction: clusion_direction;
      length: clusion_list_length;
      data: array [clusion_list_index] of integer
    end (* clusion_list *) ;


(*	An identifier used primarily as a file name.			*)

const
  null_identifier = '        ';
  identifier_max   = 8 (* characters *) ;
  identifier_limit = identifier_max - 1;

type
  identifier_index = 0..identifier_limit;
  identifier_size  = 0..identifier_limit;

type
  identifier = array [identifier_index] of char;

(* the unit of disk i/o is the page: *)

const
  page_size = 256 (* bytes *) ;
  page_limit = page_size - 1;

type
  page_index = 0 .. page_limit;
  page = array [page_index] of char;

(* file index block: *)

const
  block_size = 2 (* pages *) ;
  block_limit = block_size - 1;

type
  block_index = 0 .. block_limit;
  block = array [block_index] of page;

(*	This is a string which is ended with an end_of_message		*)
(*	character.							*)
(*	It is used to pass string constants in procedure calls.		*)

const
  end_message_character = eom;

const
  quoted_text_max   = 80 (* characters *) ;
  quoted_text_limit = quoted_text_max-1;

type
  quoted_text_index = 0..quoted_text_limit;

type
  quoted_text = array[quoted_text_index] of char;

type
  node_or_host_set_operation = (profiles_convert, reload_data_file_convert);!
(************************************************************************)
(*									*)
(*	USRDEF.TDR							*)
(*									*)
(*	Some user orientated definitions.				*)
(*	Definitions are here since they need to be referenced through	*)
(*	most of the program. The primary example of this is character	*)
(*	arrays which are referenced in circuit_utility for terminal	*)
(*	input and output.						*)
(*									*)
(************************************************************************)


(* tdr user index *)

const
  tdr_user_limit = tdr_user_max - 1;

type
  tdr_user_index = 0..tdr_user_limit;


(*	Format buffer for internal_to_string output.			*)

const
  format_buffer_text_max   = 160 (* characters *) ;
  format_buffer_text_limit = format_buffer_text_max-1;

type
  format_buffer_text_index = 0..format_buffer_text_limit;
  format_buffer_text_size  = 0..format_buffer_text_max;

type
  format_buffer_text = array [format_buffer_text_index] of char;

type
  format_buffer =
    record
      size: format_buffer_text_size;
      text: format_buffer_text
    end (* format_buffer *) ;

(*	Command line input.						*)
(*	This is the standard command input line, processed by the	*)
(*	the command scanner.						*)

const
  command_line_text_max   = 80 (* characters *) ;
  command_line_text_limit = command_line_text_max-1;

type
  command_line_text_index = 0..command_line_text_limit;
  command_line_text_size  = 0..command_line_text_max;

type
  command_line_text = array [command_line_text_index] of char;

type
  command_line =
    record
      size: command_line_text_size;
      text: command_line_text
    end (* command_line *) ;

(* Definition of prompts for various command classes *)

const
  command_prompt_text_max   = 6 (* characters *) ;
  command_prompt_text_limit = command_prompt_text_max-1;

type
  command_prompt_text_index = 0..command_prompt_text_limit;
  command_prompt_text_size  = 0..command_prompt_text_max;

type
  command_prompt_text = array [command_prompt_text_index] of char;

type
  command_prompt =
    record
      size: command_prompt_text_size;
      text: command_prompt_text
    end (* command_prompt *) ;

(* password string *)

const
  password_string_text_max   = 32 (* characters *) ;
  password_string_text_limit = password_string_text_max - 1;

type
  password_string_text_index = 0..password_string_text_limit;
  password_string_text_size  = 0..password_string_tax;

type
  password_string_text = array[password_string_text_index] of char;

type
  password_string = record
    size : password_string_text_size;
    text : password_string_text
  end (* password_string *) ;

const
  password_string_max = password_string_text_max+4;

(* digit string *)

const
  digit_string_text_max   = 16 (* characters *) ;
  digit_string_text_limit = digit_string_text_max - 1;

type
  digit_string_text_index = 0..digit_string_text_limit;
  digit_string_text_size  = 0..digit_string_text_max;

type
  digit_string_text = array[digit_string_text_index] of char;

type
  digit_string = record
    size : digit_string_text_size;
    text : digit_string_text
  end (* digit_string *) ;

(* quoted string *)

const
  quoted_string_text_max   = 80 (* characters *) ;
  quoted_string_text_limit = quoted_string_text_max - 1;

type
  quoted_string_text_index = 0..quoted_string_text_limit;
  quoted_string_text_size  = 0..quoted_string_text_max;

type
  quoted_string_text = array[quoted_string_text_index] of char;

type
  quoted_string = record
    size : quoted_string_text_size;
    text : quoted_string_text
  end (* quoted_string *) ;

(*	A symbol is text scanned during command input whose value is	*)
(*	itself. It is not converted such as license, to an internal	*)
(*	form.								*)

const
  symbol_text_max   = 16 (* characters *) ;
  symbol_text_limit = symbol_text_max - 1;
  symbol_byte_max   = 4 + symbol_text_max;

type
  symbol_text_index = 0..symbol_text_limit;
  symbol_text_size  = 0..symbol_text_max;

type
  symbol_text = array [symbol_text_index] of char;

type
  symbol = record
    size : symbol_text_size;
    text : symbol_text
  end (* symbol *) ;


(*      text string definitions      *)

const
  description_string_max   = 32 (* chzaracter *);
  description_string_limit = description_string_max - 1;

type
  description_string_index = 0..description_string_limit;

type
  description_string_size  = 0..description_string_max;

type
  description_string_text  = array [description_string_index] of char;

type
  description   =
    record
      size : description_string_size;
      text : description_string_text
    end (* description *) ;

const
  external_recurring_outage_limit       = 25;

type
  external_recurring_outage_index       = 0..external_recurring_outage_limit;

   
type
  external_recurring_outage_variables =
    record
      recurring_outage_maximum     : external_recurring_outage_index;
      recurring_outage_decay       : integer
    end (* recurring_outage_variables *) ;


type
  alarm_level = (alarm_level_a, alarm_level_b, alarm_level_c, alarm_level_o);


(*	This is the text that is stored in a log message.		*)
(*	it is defined here so that is can be displayed on the terminal.	*)
(*	The size is such that the text and other log message data will	*)
(*	fit on a disk page. The definition of this page is in OPDEF	*)

const
  log_message_text_max   = 242;
  log_message_text_limit = log_message_text_max - 1;

type
  log_message_text_index = 0..log_message_text_limit;
  log_message_text_size  = 0..log_message_text_max;

type
  log_message_text = array [log_message_text_index] of char;

type
  log_message =
    record
      size : log_message_text_size;
      text : log_message_text
    end (* log_message *) ;

(*	This is the text for a network username, i.e. a username in the	*)
(*	MUD.								*)

const
  network_username_string_text_max   = 16;
  network_username_string_text_limit = network_username_string_text_max - 1;

type
  network_username_string_text_index = 0..network_username_string_text_limit;
  network_username_string_text_size  = 0..network_username_string_text_max;

type
  network_username_string_text =
    array [network_username_string_text_index] of char;

type
  network_username_string =
    record
      size : network_username_string_text_size;
      text : network_username_string_text
    end (* network_username_string *) ;

(*	This is the text for a network password string.			*)

const
  network_password_string_text_max   = 16;
  network_password_string_text_limit = network_password_string_text_max - 1;

type
  network_password_string_text_index = 0..network_password_string_text_limit;
  network_password_string_text_size  = 0..network_password_string_text_max;

type
  network_password_string_text =
    array [network_password_string_text_index] of char;

type
  network_password_string =
    record
      size : network_password_string_text_size;
      text : network_password_string_text
    end (* network_password_string *) ;

(*	This is the text for a network login string. It will contain	*)
(*	the username, password, host number, control characters etc.	*)

const
  network_login_string_text_max   = 40;
  network_login_string_text_limit = network_login_string_text_max - 1;

type
  network_login_string_text_index = 0..network_login_string_text_limit;
  network_login_string_text_size  = 0..network_login_string_text_max;

type
  network_login_string_text =
    array [network_login_string_text_index] of char;

type
  network_login_string =
    record
      size : network_login_string_text_size;
      text : network_login_string_text
    end (* network_login_string *) ;
!
(*	A set viewed as an array of characters.				*)

const
  SET_CHARS_MAX   = BASIC_SET_MAX div 8;
  SET_CHARS_LIMIT = SET_CHARS_MAX-1;

type
  set_chars_index = 0..SET_CHARS_LIMIT;

type
  set_chars = array[set_chars_index] of char;

(*	An integer viewed as an array of characters.			*)

const
  INTEGER_CHARS_MAX   = 4 (* characters *) ;
  INTEGER_CHARS_LIMIT = INTEGER_CHARS_MAX-1;

type
  integer_chars_index = 0..INTEGER_CHARS_LIMIT;

type
  integer_chars = array[integer_chars_index] of char;

(*	A halfword viewed as an array of characters.			*)

const
  HALFWORD_CHARS_MAX   = INTEGER_CHARS_MAX div 2;
  HALFWORD_CHARS_LIMIT = HALFWORD_CHARS_MAX-1;

type
  halfword_chars_index = 0..HALFWORD_CHARS_LIMIT;

type
  halfword_chars = array[halfword_chars_index] of char;

(*	A set viewed as an array of halfwords.				*)

const
  SET_HALFWORDS_MAX   = BASIC_SET_MAX div 16;
  SET_HALFWORDS_LIMIT = SET_HALFWORDS_MAX-1;

type
  set_halfwords_index = 0..SET_HALFWORDS_LIMIT;

type
  set_halfwords = array[set_halfwords_index] of halfword_chars;

(*	An integer viewed as an array of halfwords.			*)

const
  INTEGER_HALFWORDS_MAX   = 2;
  INTEGER_HALFWORDS_LIMIT = INTEGER_HALFWORDS_MAX-1;

type
  integer_halfwords_index = 0..INTEGER_HALFWORDS_LIMIT;

type
  integer_halfwords = array[integer_halfwords_index] of halfword_chars;

!
(************************************************************************)
(*									*)
(*	DEVMAX.BAS							*)
(*									*)
(*			 Device Maximums				*)
(*									*)
(*	Set the maximum values for device units.			*)
(*									*)
(************************************************************************)
(*									*)
(*			   Revision Record				*)
(*									*)
(*	20Sep83	Original -- rer						*)
(*									*)
(************************************************************************)


const
(* number of units for device disk *)
  disk_unit_max = 1;

(* maximum possible number of units for device tape *)
  tape_unit_max = 1;

(* maximum possible number of units for device printer *)
  printer_unit_max = 1;

(* one terminal for each user *)
  terminal_unit_max = tdr_user_max;

(* one circuit for each concurrent transfer *)
  aux_circuit_unit_max = 1;

(* number of physical units (spindles) *)
  unit_max = 1;

(* possible logical volumes *)
  lv_max = 1;
!
(************************************************************************)
(*									*)
(*	devio.def							*)
(*									*)
(*			 Device I/O Declarations			*)
(*									*)
(*	General device i/o definitions.					*)
(*									*)
(************************************************************************)
(*									*)
(*			   Revision Record				*)
(*									*)
(*	 19Jan82	Original -- jnm (from (PATROL)globl.cmn)	*)
(*									*)
(************************************************************************)


type	(*   Device definition *)
  iodevice = (disk, tape, printer, system, crash, terminal, aux_circuit,
    lvol);


type
  ioresult = (complete, intervention, transmission, failure, end_file,
    end_medium, start_medium, program_error, break_key, orange_ball,
    device_busy, time_out, dummy01);

type
  ioresult_set = set of ioresult;
!
(************************************************************************)
(*			disk devices					*)
(************************************************************************)


const
  disk_unit_limit = disk_unit_max-1;


type
  disk_unit_index = 0..disk_unit_limit;


type	(* disk operation codes: *)
  disk_operation = (disk_read, disk_write, disk_attach, disk_detach,
    disk_info, disk_load_program);


type	(* disk i/o parameter list *)
  disk_param = record
    operation : disk_operation;
    status    : ioresult;
    status2,
    start_addr,
    byte_count: integer
  end (* disk_param *);


type
  disk_tape_information = record
    logical_unit_number,
    device_status,
    protection_mask,
    default_block_size,
    start_cylinder,
    number_of_cylinders,
    sectors_per_track,
    tracks_per_cylinder,
    device_address,
    global_unit_number,
    ascii_name,
    device_type,
    number_of_sectors :	 integer
  end (* disk_tape_information *);
!
(************************************************************************)
(*			tape devices					*)
(************************************************************************)


type
  tape_operation = (tape_read, tape_write, tape_attach, tape_detach,
    tape_info, tape_load_program, tape_action);


const
  tape_unit_limit = tape_unit_max-1;


type
  tape_unit_index = 0..tape_unit_limit;


type
  tape_param = record
    operation : tape_operation;
    status    : ioresult;
    status2,
    arg,
    count      : integer
  end (* tape param *);


const
  tape_back_space = 0;
  tape_forward_file = 1;
  tape_back_file = 2;
  tape_write_eof = 3;
  tape_rewind = 4;
  tape_unload = 5;
  tape_gap = 6;
  tape_set_low_density = 7;
!
(************************************************************************)
(*			printer devices					*)
(************************************************************************)


const
  printer_unit_limit = printer_unit_max - 1;


type
  printer_unit_index = 0..printer_unit_limit;

type
  printer_operation = (printer_raw, printer_text, printer_new_line,
    printer_form_feed, printer_repeat_character, printer_info);


const
  max_lpt_repeat_count = 63;


type
  printer_param = record
    operation : printer_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* printer_param *);


  line_printer_request = record
    prt_op       : printer_operation;
    outline      : format_buffer;
    repeat_char  : char;
    repeat_count : integer
  end (* line_printer_request *);
!
(************************************************************************)
(*			system device					*)
(************************************************************************)


type
  system_operation = (system_up, system_down, system_shut, system_gone,
    system_info, system_core_free, read_constant, system_checksum);


type
  system_param = record
    operation : system_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* system_param *);


type
  system_information = record
    number_of_terminals,		(* NTERM *)
    number_of_aux_circuits,		(* NAUX *)
    host_number,			(* decimal *)
    node_number,			(* octal *)
    slot_number,			(* hexidecimal *)
    kernel_host_number,			(* decimal *)
    isis_version,			(* 100*v+r in decimal *)
    nucleus_version	   : integer (* 256*v+r in octal *)
  end (* system_information *);
!
(************************************************************************)
(*			crash device					*)
(************************************************************************)


type
  crash_operation =
    (crash_wait, crash_signal, crash_restart, crash_halt, crash_kill);

type
  crash_param = record
    operation : crash_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* crash_param *);

type
  process_crash_data =
    record
      error_code: integer;
      process_number: integer;
      line_number: integer
    end (* process_crash_data *) ;
!
(************************************************************************)
(*			 logical volume support 			*)
(************************************************************************)


const
  unit_limit = unit_max - 1;


type
  unit_index = 0 .. unit_limit;


const
  lv_limit = lv_max - 1;

type
  lv_index = 0 .. lv_limit;

  device_def = record
    unit,
    volume,
    incarnation	: integer;
    incarn_pres	: boolean
  end (* device_def *);

  device_rec = array[1..2] of device_def;

  io_unit_mode = (read_unit, write_unit, rw_unit);

  lvol_operation = (lvol_init, lvol_init2, lvol_info, lvol_setop,
    lvol_copy, lvol_read, lvol_write);

  lvol_param = record
    operation : lvol_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2,
    arg3,
    arg4     : integer
  end (* lvol_param *);
!
  lvol_info_rec = record
    read_count,
    write_count,
    last_status,
    error_count,
    logical_volume_number,
    incarnation_number,
    options,
    last_error : integer
  end (* lvol_info_rec *);

const
  lvol_info_size = 12;

type
  lvol_info_buffer = array [lv_index] of lvol_info_rec;
!
(************************************************************************)
(*		terminal and aux_circuit devices			*)
(************************************************************************)


type
  circuit_device = terminal..aux_circuit;


const
  terminal_unit_limit = terminal_unit_max-1;


type
  terminal_unit_index = 0..terminal_unit_limit;

const
  echo_off = 0;
  echo_on  = 1;
  xp_on    = 2;
  xp_off   = 3;
  sys_cons = 4;
  char_del = 5;
  word_del = 6;
  line_del = 7;

type
  iosettrmop = 0..7;

const
   sys_char_del = 0;
   sys_word_del = 1;
   sys_line_del = 2;

const
  aux_circuit_unit_limit = aux_circuit_unit_max-1;


type
  aux_circuit_unit_index = 0..aux_circuit_unit_limit;


type
  circuit_operation = (circuit_receive_character, circuit_receive_line,
    circuit_send, circuit_disconnect, circuit_clear_break, circuit_set_system,
    circuit_set_unit, circuit_yellow_ball, circuit_detect,
    circuit_aux_request, circuit_info, circuit_send_b1, circuit_get_needle,
    circuit_zap, circuit_sup_log_message, circuit_set_alternate_break,
    circuit_set_bell, circuit_normal_request,
    circuit_send_siix, circuit_send_tiix);


  circuit_input_operation = circuit_receive_character.. circuit_receive_line;


type
  circuit_param = record
    operation : circuit_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* circuit_param *);
!
(*   Needle Record   *)

const
  needle_name_max   = 24 (* characters *);
  needle_name_limit = needle_name_max-1;


type
  needle_name_index = 0..needle_name_limit;


type
 needle_name_length = 0..needle_name_max;


type
  needle_name = array[needle_name_index] of char;


type
  needle_record = record
    invoice,
    isis_port,
    host_number,
    node_number,
    origin_host,
    tymsat_port		 : integer;
    number_of_characters : needle_name_length;
    terminal_id		 : char;
    login_name		 : needle_name
  end (* needle_record *);

(*	Process attribute index definitions. Used as argument to calls	*)
(*	system procedure 'attribute'.					*)

type
  attribute_index =
    (attribute_caller, attribute_heap_top, attribute_program_line,
     attribute_program_result, attribute_run_time);
!
(************************************************************************)
(*									*)
(*	UDATA.CMN							*)
(*									*)
(************************************************************************)


(*	This is the user license that is stored in user profile record. *) 
(*	It is defined here so that it can be referred by operator log.  *)

type
  std_license = (
    std_no_license,	std_p00_license,	std_p01_license,
    std_p02_license,	std_p10_license,	std_p20_license,
    std_upd_license,	std_hang_license,	std_who_license,
    std_setn_license,	std_setp_license,	std_inact_license,
    std_dev_license,	std_operator_license,	std_hst_license,
    std_grt_license,
    std_rellst_license,	std_relset_license,	std_relexe_license,
    std_thrlst_license,	std_thrset_license,	
    std_almlst_license,	std_almset_license,	std_almexe_license,
    std_attach_license, std_autolog_license, 	std_shtlnk_license
 );



type terminal_type = (adm1, adm3, hardcopy, hp2621, isc8900,
                      scanset, vt100);

const
  first_terminal_type = adm1;
  last_terminal_type = vt100;

const

  first_zone_bias    = -720;
  last_zone_bias     =  720;


type zone_bias = first_zone_bias..last_zone_bias (* minutes from GMT *) ;


type
  profile_access_header =
    record
      name                : symbol (* user name *) ;
      password            : integer (* password cipher *) ;
      password_changed	  : integer (* password changed date *) ;
      daylight_savings    : boolean               (* user subject to  *) ;
      node_threshold      : external_recurring_outage_index;
      host_threshold      : external_recurring_outage_index;
      line_threshold      : external_recurring_outage_index;
      filler_1		  : array[1..14] of char;
      time_zone           : zone_bias (* minutes from GMT *) ;
      terminal_used       : terminal_type
    end (* profile_access_header *) ;


type event_color = array [main_event_index] of char;

type
  profile_color =
    record
      main_color  : event_color;
      sub_color   : event_color
    end (* profile_color *) ;

const
  profile_color_page_max   = 2 (* pages *) ;


!
(************************************************************************)
(*									*)
(*	NAMEFL.CMN							*)
(*									*)
(************************************************************************)


const
  name_file_name_max   = 10 (* characters *) ;
  name_file_name_limit = name_file_name_max-1;

type name_file_name_index = 0..name_file_name_limit;

type name_file_name =
  record
    text: array[name_file_name_index] of char
  end (* name_file_name *) ;

const
  name_page_max   = page_size div name_file_name_max;
  name_page_limit = name_page_max-1;

type name_page_index = 0..name_page_limit;

const
  name_page_filler_size = page_size-name_file_name_max*name_page_max;

type name_page =
  record
    names: array[name_page_index] of name_file_name;
    filler: array[1..name_page_filler_size] of char
  end (* name_page *) ;
!
(************************************************************************)
(*	Updated 31-Oct-85 at 16:02 by Hueyma				*)
(*									*)
(*	SDATA.CMN							*)
(*									*)
(************************************************************************)

const
  page_password_max   = page_size div password_string_max;
  page_password_limit = page_password_max-1;

type page_password_index = 0..page_password_limit;

const
  filler_size = page_size-page_password_max*password_string_max;

type 
  password_page =
    record
      passwords: array[page_password_index] of password_string;
      filler: array[1..filler_size] of char
    end (* password_page *) ;
!
(************************************************************************)
(*									*)
(*	GREETC.CMN							*)
(*									*)
(************************************************************************)

const
  empty_key = 0 (* for empty remote_greeting_entry *) ;

const
  remote_greeting_page_max   = 64 (* pages in clear_file *) ;
  remote_greeting_page_limit = remote_greeting_page_max-1;

type
  remote_greeting_page_index = 0..remote_greeting_page_limit;
  remote_greeting_page_size  = 0..remote_greeting_page_max;

const
  remote_greeting_entry_max   = 16 (* remote_greeting_entry's in a page *) ;
  remote_greeting_entry_limit = remote_greeting_entry_max-1;

type
  remote_greeting_entry_index = 0..remote_greeting_entry_limit;
  remote_greeting_entry_size  = 0..remote_greeting_entry_max;

const
  remote_greeting_max   = remote_greeting_page_max*remote_greeting_entry_max;
  remote_greeting_limit = remote_greeting_max-1;

type
  remote_greeting_index = 0..remote_greeting_limit;
  remote_greeting_size  = 0..remote_greeting_max;
!
(************************************************************************)
(*									*)
(*	WBLK.CMN							*)
(*									*)
(************************************************************************)


const
  null_word = -1 (* empty word in bucket *) ;

const
  bucket_entry_max   = 16 (* items *) ;
  bucket_entry_limit = bucket_entry_max - 1;
  
type bucket_entry_index = 0..bucket_entry_limit;

  
 !
(************************************************************************)
(*									*)
(*	HSTATC.CMN							*)
(*									*)
(************************************************************************)

const
  empty_host_number = 0 (* for empty host_status_entry *) ;

const
  host_text_max    = page_size;
  host_text_limit  = host_text_max-1;

type
  host_text_size   = 0..host_text_max;

type
  sup_host_status_operation = (set_ok, set_pending, clear, clear_pending);

type
  sup_operation_record	= array[0..7] of sup_host_status_operation;

type
  clear_operation = (clear_delete, clear_save);


!
(************************************************************************)
(*									*)
(*	THREFL.CMN							*)
(*									*)
(************************************************************************)


const
  threshold_condition_byte_max  =
    (symbol_text_max+4) +		(* name *)
    (description_string_max+4) +	(* label *)
    4 +					(* event *)
    2 +					(* alarm_class *)
    4 +					(* maximum *)
    4 +					(* decay *)
    4 +					(* bound *)
    2 +					(* alarm option *)
    4					(* create_time *) ;

const
  condition_filler_max = page_size - threshold_condition_byte_max;

type
  threshold_condition_header =
    record
      name	    : symbol;
      describe_text : description;
      event_or_isis : event_index;
      alarm_class   : alarm_level;
      external_recurring_data : external_recurring_outage_variables;
      bound	    : external_recurring_outage_index;
      alarm	    : boolean;
      create_time   : integer  (* this time is updated only when *)
			       (* name or event is changed	 *)
    end (* threshold_condition_header *) ;

type
  threshold_condition_page =
    record
      condition_head: threshold_condition_header;
      filler	    : array [1..condition_filler_max] of char
    end (* threshold_condition_page *) ;



!
(************************************************************************)
(*									*)
(*	CONDFL.CMN							*)
(*									*)
(************************************************************************)

const
  condition_log_page_item_max   = page_size div 16;
  condition_log_page_item_limit = condition_log_page_item_max-1;



!
(************************************************************************)
(*									*)
(*	RELDAT.CMN							*)
(*									*)
(************************************************************************)

type
  reload_outage_value =
    record
      host_reload_data		: external_recurring_outage_variables;
      host_reload_threshold	: external_recurring_outage_index;
      node_reload_data		: external_recurring_outage_variables;
      node_reload_threshold	: external_recurring_outage_index
    end (* reload_outage_value *) ;


!
(************************************************************************)
(*									*)
(*	XOMHFL.CMN							*)
(*									*)
(************************************************************************)

const
  xom_host_entry_max	= 16;
  xom_host_entry_limit	= xom_host_entry_max - 1;

type
  xom_host_entry_index	= 0..xom_host_entry_limit;

!
(************************************************************************)
(*									*)
(*	BJOBFL.CMN							*)
(*									*)
(************************************************************************)


type
  job_state = (
    JOB_LOGIN		(* Job is waiting for login *) ,
    JOB_COMMAND		(* Job running nondetachable command *) ,
    JOB_ALARM		(* Job is running Start Alarm command *) ,
    JOB_RELOAD		(* Job is running Start Reload command *) ,
    JOB_NEEDLE_TIMEOUT	(* Job ended - needle read timed out *) ,
    JOB_LOGIN_TIMEOUT	(* Job ended - TMCS user name timed out *) ,
    JOB_CIRCUIT_ZAPPED	(* Job ended - circuit lost *) ,
    JOB_QUIT_COMMAND	(* Job ended - Quit command executed *) ,
    JOB_ATTACHING	(* Job ended - port attached to another *) ,
    JOB_HUNG		(* Job ended - detached job hung *) ,
    JOB_NO_USERNAME	(* Job ended - username not defined *)   );

const
  job_descriptor_byte_max = 2 + 4 + symbol_byte_max;


const
  job_descriptor_entry_max   = page_size div job_descriptor_byte_max;
  job_descriptor_entry_limit = job_descriptor_entry_max-1;

type job_descriptor_entry_index = 0..job_descriptor_entry_limit;

!
(************************************************************************)
(*									*)
(*	CLUSFL.CMN							*)
(*									*)
(************************************************************************)


const
  cluster_name_max	= 4 (* characters *) ;
  cluster_name_limit	= cluster_name_max - 1;

type
  cluster_name_index	= 0..cluster_name_limit;

type
  cluster_name		= array [cluster_name_index] of char;

const
  cluster_entry_max	= page_size div cluster_name_max;
  cluster_entry_limit	= cluster_entry_max - 1;

type
  cluster_entry_index	= 0..cluster_entry_limit;

type
  cluster_page 		= array [cluster_entry_index] of cluster_name;

!
(************************************************************************)
(*									*)
(*	FILDEF.TDR							*)
(*									*)
(*	Constants and type definitions for the file system.		*)
(*									*)
(************************************************************************)
(*									*)
(*			  Revision Record				*)
(*									*)
(*	13May83	Original from FILDEF.TMS - rer				*)
(*	11Nov83 Convert to TMDM version 1.00 - ahm			*)
(*	13Mar84 Convert to TMDM version 1.02 for  TMCS version 7.05	*)
(*		by adding oper_log_page_max into config_list - ahm	*)
(*	10Jul84 Convert to TMDM version 1.03 for  TMCS version 8.00	*)
(*		by adding reload_feature, alarm_feature and		*)
(*		threshold_condition_max to config_list - ahm		*)
(*									*)
(************************************************************************)



(*	The Pascal unit used for the file system files   *)

const
  file_system_disk = 0;

(*    File descriptor format:    *)

const
  fd_max   = 16 (* file descriptors per page *) ;
  fd_limit = fd_max-1;

type
  fd_index = 0 .. fd_limit;

type
  file_descriptor =
    record
      file_address,
      file_allocation,
      file_length: integer
    end (* file_descriptor *) ;

type
  vfdd_entry =
    record
      descriptor: file_descriptor;
      creation_date_and_time: integer
    end (* vfdd_entry *) ;

const
  file_max		= 126 (* number of files in vfdd *) ;
  vfdd_start_address	= 1;
  vfdd_allocation	= (file_max+2+fd_limit) div fd_max;

const
  vfdd_max   = vfdd_allocation;
  vfdd_limit = vfdd_max - 1;

type
  vfdd_page_index = 0..vfdd_limit;

type
  vfdd_page = array [fd_index] of vfdd_entry;

const
  vfdd_self_index = 0;


(* System Directory format *)

const
  sys_dir_vfdd_index = 1;

const
  dir_entry_max = 16 (* directory entries per page *) ;
  dir_entry_limit = dir_entry_max-1;

const
  dir_start_address = vfdd_start_address+vfdd_allocation;
  dir_allocation    = (file_max+dir_entry_limit) div dir_entry_max;

type
  dir_entry_index = 0 .. dir_entry_limit;

const
  dir_max   = dir_allocation;
  dir_limit = dir_max - 1;

type
  dir_page_index = 0..dir_limit;

type
  dir_entry =
    record
      name : identifier;
      index: integer;
      pad  : integer
    end (* dir_entry *) ;

type
  dir_page = array [dir_entry_index] of dir_entry;


(*    Volume label format:    *)

const
  unused_volume_label_limit_1020	= 135;
  volume_label_addr			= 0;
  original_incarnation			= 6;
  current_incarnation			= 7;

type
  config_list =
    record
      user_max,
      username_max,
      limit_set_max,
      user_message_max,
      supervisor_max,
      node_configuration_max,
      tymnet_i_node_configuration_max,
      host_configuration_max,
      host_mask,
      links_per_node,
      ports_per_node,
      link_shut_percentage,
      port_out_percentage,
      tymnet_i_tymcom_max,
      tymnet_i_tymsat_max,
      tymnet_ii_node_max,
      host_number_max,
      oper_log_page_max,
      node_mask		: integer;
      reload_feature	: boolean;
      alarm_feature	: boolean;
      threshold_condition_max: integer;
      condition_log_length   : integer;
      shut_link_table_feature: boolean;
      host_status_message_max: integer;
      multiple_host_message_feature	: boolean
    end (* config_list *) ;

type
  volume_label_1020 =
    record
      unused_logical_volume_number,
      incarnation_number,
      label_date_and_time,
      pages_on_this_volume,
      next_page_to_allocate,
      vfdd_pointer  : integer;
      config_params : config_list;
      unused: array [0 .. unused_volume_label_limit_1020] of char
    end (* volume_label_1020 *) ;

type
  new_vat = volume_label_1020;

type
  file_name_set	= (NODESNAM, HOSTSNAM, CLSTRNAM, REMOTEDO, LOCABUCK, 
    HOSTSTAT, XOMHOSTS, PROBENAM);!
(**********************************************************************)
(*                                                                    *)
(*	MUTIL.TMS						      *)
(*                            misc_utility                            *)
(*                                                                    *)
(*    This class handles misc. operations, primarily mathematical.    *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*    24Mar82    Original -- rer                                      *)
(*    12Apr83    Added entry function match  ---  bss                 *)
(*                                                                    *)
(**********************************************************************)



type misc_utility = class



(***************************  misc_utility  ***************************)
(*                                                                    *)
(*                              ceiling                               *)
(*                                                                    *)
(*    The smallest integer greater than or equal to the quotient of   *)
(*    the two arguments. Or, take the quotient and round up.	      *)
(*                                                                    *)
(**********************************************************************)



function entry ceiling(x, y: integer): integer;

begin
  ceiling := (x+y-1) div y
end (* ceiling *) ;



(***************************  misc_utility  ***************************)
(*                                                                    *)
(*                          	 percent			      *)
(*                                                                    *)
(*    The second argument percent of the first argument.	      *)
(*                                                                    *)
(**********************************************************************)



function entry percent(n, p: integer): integer;

begin
  percent := (n*p+99) div 100
end (* percent *) ;



(***************************  misc_utility  ***************************)
(*                                                                    *)
(*                               match                                *)
(*                                                                    *)
(*    Return whether or not two symbols are the same.                 *)
(*                                                                    *)
(**********************************************************************)



function entry match (first, second: symbol): boolean;

var
  i: symbol_text_index;

begin
  match := true;
  if first.size <> second.size then match := false
  else
    for i := 0 to first.size-1 do
      if first.text[i] <> second.text[i] then match := false
end (* match *) ;



(***************************  misc_utility  ***************************)
(**********************************************************************)



begin (* initial statement *)
end (* misc_utility *) ;
!
(************************************************************************)
(*									*)
(*	CIRC.BAS							*)
(*			    circuit_handler				*)
(*									*)
(*	This class handles all direct calls to io for access to the	*)
(*	terminal or aux_circuit.					*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*      needle_record      circuit_device        circuit_param          *)
(*      circuit_operation  ioresult              ioresult_set           *)
(*      needle_name        needle_name_index     basic_set              *)
(*                                                                      *)
(************************************************************************)
(*                                                                      *)
(*			     Revision Record				*)
(*									*)
(*	25May83	Original from CIRC.TMS -- rer				*)
(*									*)
(************************************************************************)



type
  circuit_handler =
    class

var
  device: circuit_device;
  unit: integer;
  accept_status: ioresult_set;
  current_timeout: integer (* current read timeout *) ;
  entry param: circuit_param (* parameter block of last io call *) ;
  entry available: boolean (* whether or not a circuit is built *) ;
  entry break_pending: boolean (* whether or not break was hit *) ;
  entry sendable: boolean (* whether available and not break_pending *) ;
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			   initialize_circuit				*)
(*									*)
(*	Set initial parameters for a just built circuit.		*)
(*									*)
(************************************************************************)



procedure initialize_circuit;

begin
  available := TRUE;
  sendable := TRUE;
  break_pending := FALSE;
  current_timeout := 0
end (* initialize_circuit *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			     reset_circuit				*)
(*									*)
(*	Reset parameters for a just freeed circuit.			*)
(*									*)
(************************************************************************)



procedure reset_circuit;

begin
  available := FALSE;
  sendable := FALSE;
  break_pending := FALSE
end (* reset_circuit *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			      zap_circuit				*)
(*									*)
(*	Zap circuit and set as not available.				*)
(*									*)
(************************************************************************)



procedure zap_circuit;

var
  dummy: char;
  param: circuit_param;

begin
  param.operation := CIRCUIT_DISCONNECT;
  io(dummy, param, device, unit);
  reset_circuit
end (* zap_circuit *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			      status_check				*)
(*									*)
(*	Check if status one of acceptable status. If not, zap circuit.	*)
(*									*)
(************************************************************************)



procedure status_check;

begin
  if param.status in accept_status
  then
    begin
      if param.status = BREAK_KEY
      then
	begin
	  break_pending := TRUE;
	  sendable := FALSE
	end
    end
  else zap_circuit
end (* status_check *) ;
!
(*************************  circuit_handler  ****************************)
(*									*)
(*				 login					*)
(*									*)
(*	Accept a login. 						*)
(*									*)
(************************************************************************)



procedure entry login(
      new_unit		: terminal_unit_index;
      new_accept_status	: ioresult_set;
  var login_info	: needle_record);

begin
  unit := new_unit;
  device := TERMINAL;
  accept_status := new_accept_status;
  repeat
    param.operation := CIRCUIT_GET_NEEDLE;
    param.arg1 := 0 (* no subhosts *) ;
    param.arg2 := 0 (* no time out waiting for needle *) ;
    io(login_info, param, device, unit)
  until param.status = COMPLETE;
  initialize_circuit
end (* login *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			 build_normal_circuit 				*)
(*									*)
(*	Build a normal circuit.						*)
(*									*)
(************************************************************************)



procedure entry build_normal_circuit(
  new_unit		: aux_circuit_unit_index;
  new_accept_status	: ioresult_set;
  build_login_string	: network_login_string;
  build_timeout		: integer);

(*	The login string text is copied since 'io' requires that its	*)
(*	data buffer be writeable incase this is a write call.		*)

var
  io_login_string_text : network_login_string_text;

begin
  unit := new_unit;
  device := AUX_CIRCUIT;
  accept_status := new_accept_status;
  io_login_string_text := build_login_string.text;
  param.arg1 := build_login_string.size;
  param.arg2 := build_timeout;
  param.operation := CIRCUIT_NORMAL_REQUEST;
  io(io_login_string_text, param, device, unit);
  if param.status = COMPLETE
  then initialize_circuit
end (* build_normal_circuit *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			   build_aux_circuit 				*)
(*									*)
(*	Build an auxiliary circuit.					*)
(*									*)
(************************************************************************)



procedure entry build_aux_circuit(
  new_unit		: aux_circuit_unit_index;
  new_accept_status	: ioresult_set;
  build_login_string	: network_login_string;
  build_timeout		: integer);

(*	The login string text is copied since 'io' requires that its	*)
(*	data buffer be writeable incase this is a write call.		*)

var
  io_login_string_text : network_login_string_text;

begin
  unit := new_unit;
  device := AUX_CIRCUIT;
  accept_status := new_accept_status;
  io_login_string_text := build_login_string.text;
  param.arg1 := build_login_string.size;
  param.arg2 := build_timeout;
  param.operation := CIRCUIT_AUX_REQUEST;
  io(io_login_string_text, param, device, unit);
  if param.status = COMPLETE
  then initialize_circuit
end (* build_aux_circuit *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			      use_circuit 				*)
(*									*)
(*	Use an already built circuit.					*)
(*									*)
(************************************************************************)



procedure entry use_circuit(
  new_unit		: aux_circuit_unit_index;
  new_device		: circuit_device;
  new_accept_status	: ioresult_set);

begin
  unit := new_unit;
  device := new_device;
  accept_status := new_accept_status;
  initialize_circuit
end (* use_circuit *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			      free_circuit 				*)
(*									*)
(*	Stop using a circuit without zapping it.			*)
(*									*)
(************************************************************************)



procedure entry free_circuit;

begin
  reset_circuit
end (* free_circuit *) ;
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			   write_quoted_text				*)
(*									*)
(*	Write a string to the terminal. A string is a message without	*)
(*	a newline. The string text is terminated with an		*)
(*	end_message_character.						*)
(*									*)
(************************************************************************)



procedure entry write_quoted_text(string: quoted_text);

var
  io_string: quoted_text;
  count: quoted_text_index;

begin
  count := 0;
  while string[count] <> END_MESSAGE_CHARACTER do
    begin
      io_string[count] := string[count];
      count := count+1
    end (* while *) ;

  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := count;
    param.arg2 := 0 (* no timeout on write *) ;
    io(io_string, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* write_quoted_text *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			     send_newline				*)
(*									*)
(*	Write a newline to the circuit device.				*)
(*									*)
(************************************************************************)



procedure send_newline;

var
  newline: array[1..2] of char;

begin
  newline := '(:13:)(:10:)';
  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := 2;
    param.arg2 := 0 (* no timeout on write *) ;
    io(newline, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* send_newline *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			write_quoted_text_line				*)
(*									*)
(*	Write a message to the terminal. A message is a string		*)
(*	terminated with the end message character. Follow message	*)
(*	with a newline. 						*)
(*									*)
(************************************************************************)



procedure entry write_quoted_text_line(message: quoted_text);

var
  io_message: quoted_text;
  count: quoted_text_index;

begin
  count := 0;
  while message[count] <> END_MESSAGE_CHARACTER do
    begin
      io_message[count] := message[count];
      count := count+1
    end (* while *) ;

  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := count;
    param.arg2 := 0 (* no timeout on write *) ;
    io(io_message, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check;
  if sendable then send_newline
end (* write_quoted_text_line *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			     write_newline				*)
(*									*)
(*	Write carriage return and linefeed to terminal. 		*)
(*									*)
(************************************************************************)



procedure entry write_newline;

begin
  send_newline
end (* write_newline *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_format_buffer				*)
(*									*)
(*	Write a format_buffer to terminal.				*)
(*									*)
(************************************************************************)



procedure entry write_format_buffer(
  data : format_buffer);

var
  io_text: format_buffer_text;

begin
  io_text := data.text;
  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := data.size;
    param.arg2 := 0 (* no timeout on write *) ;
    io(io_text, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* write_format_buffer *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_command_line				*)
(*									*)
(*	Write a command_line to terminal.				*)
(*									*)
(************************************************************************)



procedure entry write_command_line(
  data : command_line);

var
  io_text: command_line_text;

begin
  io_text := data.text;
  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := data.size;
    param.arg2 := 0 (* no timeout on write *) ;
    io(io_text, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* write_command_line *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_command_prompt				*)
(*									*)
(*	Write a command_prompt to terminal.				*)
(*									*)
(************************************************************************)



procedure entry write_command_prompt(
  data : command_prompt);

var
  io_text: command_prompt_text;

begin
  io_text := data.text;
  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := data.size;
    param.arg2 := 0 (* no timeout on write *) ;
    io(io_text, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* write_command_prompt *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_log_message				*)
(*									*)
(*	Write a log_message to terminal.				*)
(*									*)
(************************************************************************)



procedure entry write_log_message(
  data : log_message);

var
  io_text: log_message_text;

begin
  io_text := data.text;
  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := data.size;
    param.arg2 := 0 (* no timeout on write *) ;
    io(io_text, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* write_log_message *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			       write_set				*)
(*									*)
(*	Write a set to the terminal. A set is 32 characters or 256 bits.*)
(*									*)
(************************************************************************)



procedure entry write_set(set_to_write: univ set_chars);

var
  io_set: set_chars;

begin
  io_set := set_to_write;
  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := SET_CHARS_MAX;
    param.arg2 := 0 (* no timeout on write *) ;
    io(io_set, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* write_set *) ;
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			   read_command_line 				*)
(*									*)
(*	Read a line with editting.					*)
(*									*)
(************************************************************************)



procedure entry read_command_line(
  var input_line : command_line);

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_LINE;
    param.arg1 := COMMAND_LINE_TEXT_MAX;
    param.arg2 := current_timeout;
    io(input_line.text, param, device, unit)
  until param.status <> DEVICE_BUSY;

  if param.arg2 > COMMAND_LINE_TEXT_MAX
  then input_line.size := COMMAND_LINE_TEXT_MAX
  else input_line.size := param.arg2;
  status_check
end (* read_command_line *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			      read_symbol 				*)
(*									*)
(*	Read a symbol with editting.					*)
(*									*)
(************************************************************************)



procedure entry read_symbol(
  var input_line : symbol);

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_LINE;
    param.arg1 := SYMBOL_TEXT_MAX;
    param.arg2 := current_timeout;
    io(input_line.text, param, device, unit)
  until param.status <> DEVICE_BUSY;

  if param.arg2 > SYMBOL_TEXT_MAX
  then input_line.size := SYMBOL_TEXT_MAX
  else input_line.size := param.arg2-1;
  status_check
end (* read_symbol *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			 read_password_string 				*)
(*									*)
(*	Read a password string with editting.				*)
(*									*)
(************************************************************************)



procedure entry read_password_string(
  var password : password_string);

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_LINE;
    param.arg1 := PASSWORD_STRING_TEXT_MAX;
    param.arg2 := current_timeout;
    io(password.text, param, device, unit)
  until param.status <> DEVICE_BUSY;

  if param.arg2 > PASSWORD_STRING_TEXT_MAX
  then password.size := PASSWORD_STRING_TEXT_MAX
  else password.size := param.arg2-1 (* remove carriage return *) ;
  status_check
end (* read_password_string *) ;
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			   send_yellow_ball				*)
(*									*)
(*	Send yellow ball requesting orange ball.			*)
(*									*)
(************************************************************************)


procedure entry send_yellow_ball;

var
  dummy: char;

begin
  param.operation := CIRCUIT_YELLOW_BALL;
  io(dummy, param, device, unit);
  status_check
end (* send_yellow_ball *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			   detect_orange_ball				*)
(*									*)
(*	Wait for an orange ball.					*)
(*									*)
(************************************************************************)


procedure entry detect_orange_ball;

var
  dummy: char;

begin
  param.operation := CIRCUIT_DETECT;
  io(dummy, param, device, unit);
  status_check
end (* detect_orange_ball *) ;
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			     clear_circuit				*)
(*									*)
(*	Clear circuit if not allready cleared and return to login ring. *)
(*									*)
(************************************************************************)



procedure entry clear_circuit;

begin
  zap_circuit
end (* clear_circuit *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*				set_echo				*)
(*									*)
(*	Set echo on or off.						*)
(*									*)
(************************************************************************)



procedure entry set_echo(echo_on: boolean);

var
  dummy: char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  if echo_on
  then param.arg1 := 1
  else param.arg1 := 0;
  io(dummy, param, device, unit)
end (* set_echo *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			      set_console				*)
(*									*)
(*	Make this the console terminal for runtime errors.		*)
(*									*)
(************************************************************************)



procedure entry set_console;

var
  dummy: char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  param.arg1 := 4;
  io(dummy, param, device, unit)
end (* set_console *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			  set_alternate_break				*)
(*									*)
(*	Set an alternate character for the break function.		*)
(*									*)
(************************************************************************)



procedure entry set_alternate_break(other: char);

var
  io_other: char;

begin
  io_other := other;
  param.operation := CIRCUIT_SET_ALTERNATE_BREAK;
  io(io_other, param, device, unit)
end (* set_alternate_break *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			     check_circuit				*)
(*									*)
(*	Check if circuit available.					*)
(*									*)
(************************************************************************)



procedure entry check_circuit;

var
  dummy: char;

begin
  param.operation := CIRCUIT_INFO;
  param.arg2 := 0;
  io(dummy, param, device, unit);
  status_check
end (* check_circuit *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			   clear_break_status				*)
(*									*)
(*	Clear the pending break in param so that other operations can	*)
(*	happen. This is the programs acknowledgement of the break.	*)
(*									*)
(************************************************************************)



procedure entry clear_break_status;

var
  dummy: char;

begin
  param.operation := CIRCUIT_CLEAR_BREAK;
  io(dummy, param, device, unit);
  break_pending := FALSE;
  sendable := TRUE;
  status_check
end (* clear_break_status *) ;



(*************************  circuit_handler  ****************************)
(*									*)
(*			      set_timeout				*)
(*									*)
(*	Set timeout to be used on all read operations.			*)
(*									*)
(************************************************************************)



procedure entry set_timeout(new_timeout: integer);

begin
  current_timeout := new_timeout
end (* set_timeout *) ;
!
(*************************  circuit_handler  ****************************)
(************************************************************************)



begin (* initial statement *)
  reset_circuit
end (* circuit_handler *) ;
!
(**********************************************************************)
(*                                                                    *)
(*	DATE.TMS						      *)
(*								      *)
(*                         date_time_converter                        *)
(*                                                                    *)
(*    This class handles all ISIS time calculations.                  *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*    22Aug80    Original -- rer                                      *)
(*                                                                    *)
(**********************************************************************)



type date_time_converter = class

const
  leap_year_seconds = 31622400 (* seconds in leap year *) ;
  non_leap_year_seconds = 31536000 (* seconds in non leap year *) ;



(************************  date_time_converter  ***********************)
(*                                                                    *)
(*                          leap_year_test                            *)
(*                                                                    *)
(*    Return true if year is a leap year.                             *)
(*                                                                    *)
(**********************************************************************)



function leap_year_test(year: integer): boolean;

begin
  leap_year_test := ((year mod 40) <> 0) and ((year mod 4) = 0)
end (* leap_year_test *) ;



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                           days_to_month                            *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    month. LY is true if calculation is for a leap year.            *)
(*                                                                    *)
(**********************************************************************)



function entry days_to_month(month: integer; ly: boolean): integer;

var
  value: integer;

begin
  case month of
    1: value := 0 (* january 0 *) ;
    2: value := 31 (* february 0+31 *) ;
    3: value := 59 (* march 31+28 *) ;
    4: value := 90 (* april 59+31 *) ;
    5: value := 120 (* may 90+30 *) ;
    6: value := 151 (* june 120+31 *) ;
    7: value := 181 (* july 151+30 *) ;
    8: value := 212 (* august 181+31 *) ;
    9: value := 243 (* september 212+31 *) ;
   10: value := 273 (* october 243+30 *) ;
   11: value := 304 (* november 273+31 *) ;
   12: value := 334 (* december 304+30 *)
  end (* case *) ;
  if ly and (month > 2)
  then days_to_month := value+1
  else days_to_month := value
end (* days_to_month *) ;



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                            days_to_year                            *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    year from january 1, 1974.                                      *)
(*                                                                    *)
(**********************************************************************)



function entry days_to_year(year: integer): integer;

var
  next_year: integer;
  days: integer;

begin
  next_year := 1974;
  days := 0;
  while next_year < year do
    begin
      if leap_year_test(next_year)
      then days := days+366
      else days := days+365;
      next_year := next_year+1
    end (* while *) ;
  days_to_year := days
end (* days_to_year *) ;



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                           days_in_month                            *)
(*                                                                    *)
(*    Return the number of days in specified month.                   *)
(*                                                                    *)
(**********************************************************************)



function entry days_in_month(month: integer; ly: boolean): integer;

begin
  case month of
    1,3,5,7,8,10,12: days_in_month := 31;
    4,6,9,11:        days_in_month := 30;
    2: if ly then    days_in_month := 29
             else    days_in_month := 28
  end (* case *)
end (* days_in_month *) ;



(************************  date_time_converter  ***********************)
(*                                                                    *)
(*                             leap_year                              *)
(*                                                                    *)
(*    Return true if year is a leap year.                             *)
(*                                                                    *)
(**********************************************************************)



function entry leap_year(year: integer): boolean;

begin
  leap_year := leap_year_test(year)
end (* leap_year *) ;



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                            compute_year                            *)
(*                                                                    *)
(*    Convert an ISIS time (ie since 1-1-74) in seconds to            *)
(*    seconds since the beginnning of the year. Also return           *)
(*    the year.                                                       *)
(*                                                                    *)
(**********************************************************************)



procedure entry compute_year(var new_time: integer; var year: integer);

var
  year_seconds: integer;

begin
  year := 1974;
  year_seconds := non_leap_year_seconds;
  while new_time >= year_seconds do
    begin
      new_time := new_time-year_seconds;
      year := year+1;
      if leap_year_test(year)
      then year_seconds := leap_year_seconds
      else year_seconds := non_leap_year_seconds
    end (* while *)
end (* compute_year *) ;



(***********************  date_time_converter  ************************)
(**********************************************************************)



begin (* initial statement *)
end (* date_time_converter *) ;
!
(************************************************************************)
(*									*)
(*	FORM.BAS							*)
(*									*)
(*			   internal_to_string				*)
(*									*)
(*    This class converts various internal representations to		*)
(*    strings of type format_buffer.					*)
(*									*)
(*     The following identifiers must be defined externally:		*)
(*	 format_buffer							*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	25May83 Original (from FORM.TMS) -- rer 			*)
(*									*)
(************************************************************************)



type internal_to_string = class

type print_time =
  record
    year: integer;
    month: integer;
    day: integer;
    hour: integer;
    minute: integer;
    second: integer
  end (* print_time *) ;

var
  calandar: date_time_converter;
  entry buffer: format_buffer (* all conversion into here *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*				put_char				*)
(*									*)
(*    Put character in buffer.text[size].				*)
(*									*)
(************************************************************************)



procedure put_char(c: char);

begin
  buffer.text[buffer.size] := c;
  buffer.size := buffer.size+1
end (* put_char *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*			       put_string				*)
(*									*)
(*    Put string into buffer.						*)
(*									*)
(************************************************************************)



procedure put_string(string_to_insert: quoted_text);

var
  i: quoted_text_index;

begin
  i := 0;
  while string_to_insert[i] <> END_MESSAGE_CHARACTER do
    begin
      put_char(string_to_insert[i]);
      i := i+1
    end (* while *)
end (* put_string *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*			       put_number				*)
(*									*)
(*    Convert number to string and store in buffer.			*)
(*									*)
(************************************************************************)



procedure put_number(
  number_to_convert	: integer;
  radix			: integer);

var
  s: array [1..11] of integer;
  positive_number: integer;
  n: integer;
  i: integer;
  negative: boolean;

begin
  positive_number := number_to_convert;
  negative := positive_number < 0;
  if negative
  then
    if (radix = 16) or (radix = 8)
    then positive_number := (positive_number+MAX_INTEGER)+1
    else positive_number := -positive_number;

  n := 0;
  repeat
    n := n+1;
    s[n] := positive_number mod radix;
    positive_number := positive_number div radix
  until positive_number = 0;

  if negative
  then
    if radix = 8
    then
      begin
	for i := n+1 to 11 do s[i] := 0;
	n := 11;
	s[11] := s[11]+2 (* put sign bit back in last character *)
      end
    else if radix = 16
    then
      begin
	for i := n+1 to 8 do s[i] := 0;
	n := 8;
	s[8] := s[8]+8 (* put sign bit back *)
      end
    else put_char('-');

  for i := n downto 1 do
    if s[i] < 10
    then put_char(chr(ord('0')+s[i]))
    else put_char(chr(ord('A')+s[i]-10))
end (* put_number *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*			  date_from_isis_time				*)
(*									*)
(*    Given an ISIS time, return the time for printing. 		*)
(*									*)
(************************************************************************)



procedure date_from_isis_time(
      isis_time	: integer;
  var date_time	: print_time);

var
  ly: boolean (* TRUE if leap year *) ;

begin
  with date_time do
    begin
      second := isis_time;
      calandar.compute_year(second, year)
    end (* with *) ;
  with date_time do
    begin
      minute := second div 60;
      second := second mod 60;

      hour := minute div 60;
      minute := minute mod 60;

      day := (hour div 24)+1;
      hour := hour mod 24;

      ly := calandar.leap_year(year);
      month := 1;
      while day > calandar.days_in_month(month, ly) do
	begin
	  day := day-calandar.days_in_month(month, ly);
	  month := month+1
	end (* while *)
    end (* with *)
end (* date_from_isis_time *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*				  time					*)
(*									*)
(*    Convert ISIS time to character string.				*)
(*									*)
(************************************************************************)



procedure entry time(time_to_convert: integer);

var
  date_time: print_time;

begin
  date_from_isis_time(time_to_convert, date_time);
  with date_time do
    begin
      put_number(month, 10);
      put_char('/');
      put_number(day, 10);
      put_char('/');
      put_number(year mod 100, 10);
      put_char(' ');
      put_number(hour, 10);
      put_char(':');
      if minute < 10 then put_char('0');
      put_number(minute, 10);
      put_char(':');
      if second < 10 then put_char('0');
      put_number(second, 10)
    end (* with *)
end (* time *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*			  disk_operation_name				*)
(*									*)
(*    Print name for disk operation.					*)
(*									*)
(************************************************************************)



procedure entry disk_operation_name(operation: disk_operation);

begin
  case operation of
    DISK_READ:
      put_string('read\ ');
    DISK_WRITE:
      put_string('write\')
  end (* case *)
end (* disk_operation_name *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*			     file_identifier				*)
(*									*)
(*    Put file name identifier to buffer.				*)
(*									*)
(************************************************************************)



procedure entry file_identifier(identifier_string: identifier);

var
  i: identifier_index;

begin
  for i := 0 to IDENTIFIER_LIMIT do
    put_char(identifier_string[i])
end (* file_identifier *) ;



(************************  internal_to_string  **************************)
(*									*)
(*			      status_name				*)
(*									*)
(*    Generate status name string from ioresult.			*)
(*									*)
(************************************************************************)



procedure entry status_name(status: ioresult);

begin
  case status of
    COMPLETE:
      put_string('complete\ ');
    INTERVENTION:
      put_string('intervention\ ');
    TRANSMISSION:
      put_string('transmission\ ');
    FAILURE:
      put_string('failure\');
    END_FILE:
      put_string('end_file\ ');
    END_MEDIUM:
      put_string('end_medium\ ');
    START_MEDIUM:
      put_string('start_medium\ ');
    PROGRAM_ERROR:
      put_string('program_error\');
    BREAK_KEY:
      put_string('break_key\');
    ORANGE_BALL:
      put_string('orange_ball\');
    DEVICE_BUSY:
      put_string('device_busy\');
    TIME_OUT:
      put_string('time_out\ ')
  end (* case *)
end (* status_name *) ;



(************************  internal_to_string  **************************)
(*									*)
(*		       build_error_message				*)
(*									*)
(*    Generate build error message from build error number.		*)
(*									*)
(************************************************************************)



procedure entry build_error_message(message_number: integer);

var
  x: integer;

begin
  x := message_number mod 128 (* remove parity bit *) ;
  if x > 11
  then
    begin
      put_string('Circuit build error: \');
      put_number(x, 10)
    end
  else
    case x of
      0:
	put_string('slot 0 will not honor request...try later\');
      1:
	put_string('format error\ ');
      2:
	put_string('bad user name\');
      3:
	put_string('bad MUD\');
      4:
	put_string('system unavailable\ ');
      5:
	put_string('down-line load request failure\ ');
      6:
	put_string('timeout\');
      7:
	put_string('access not permitted\ ');
      8:
	put_string('out of origination ports\ ');
      9:
	put_string('sup will not honor request...try later\ ');
      10:
	put_string('bad requesting host number\ ');
      11:
	put_string('requesting host not up on requesting node\')
    end (* case *)
end (* build_error_message *) ;



(************************  internal_to_string  **************************)
(*									*)
(*			  login_error_message				*)
(*									*)
(*    Generate login error message from login error number.		*)
(*									*)
(************************************************************************)



procedure entry login_error_message(message_number: integer);

var
  x: integer;

begin
  x := message_number mod 128 (* remove parity bit *) ;
  if ((5 < x) and (x < 8)) or (x > 19)
  then
    begin
      put_string('Login error: \');
      put_number(x, 10)
    end
  else
    case x of
      0:
	put_string('continue\ ');
      1:
	put_string('cannot build circuit\ ');
      2:
	put_string('invalid user name\');
      3:
	put_string('invalid password\ ');
      4:
	put_string('no username\');
      5:
	put_string('no password\');
      8:
	put_string('please see your representative...\');
      9:
	put_string('bad MUD\');
     10:
       put_string('circuits busy\');
     11:
       put_string('host not available thru net\');
     12:
       put_string('host out of ports\');
     13:
       put_string('host down\');
     14:
       put_string('host shut\');
     15:
       put_string('try again in 2 minutes\ ');
     16:
       put_string('access not permitted\ ');
     17:
       put_string('no host specifed\ ');
     18:
       put_string('bad host number\');
     19:
       put_string('MUD error\')
    end (* case *)
end (* login_error_message *) ;



(************************  internal_to_string  **************************)
(*									*)
(*			     symbol_string				*)
(*									*)
(*    Put symbol into buffer.						*)
(*									*)
(************************************************************************)



procedure entry symbol_string(string: symbol);

var
  i: symbol_text_index;

begin
  for i := 0 to string.size-1 do put_char(string.text[i])
end (* symbol_string *) ;



(************************  internal_to_string  **************************)
(*									*)
(*			    network_username				*)
(*									*)
(*	Put a network username in the buffer.				*)
(*									*)
(************************************************************************)



procedure entry network_username(string: network_username_string);

var
  i: network_username_string_text_index;

begin
  for i := 0 to string.size-1 do put_char(string.text[i])
end (* network_username *) ;



(************************  internal_to_string  **************************)
(*									*)
(*			    network_password				*)
(*									*)
(*	Put a network password in the buffer.				*)
(*									*)
(************************************************************************)



procedure entry network_password(string: network_password_string);

var
  i: network_password_string_text_index;

begin
  for i := 0 to string.size-1 do put_char(string.text[i])
end (* network_password *) ;



(************************  internal_to_string  **************************)
(*									*)
(*				 number 				*)
(*									*)
(*    Convert a number in any radix to a string.			*)
(*									*)
(************************************************************************)



procedure entry number(
  number_to_convert	: integer;
  radix			: integer);

begin
  put_number(number_to_convert, radix)
end (* number *) ;



(***********************   internal_to_string	*************************)
(*									*)
(*			     format_number				*)
(*									*)
(*    Convert a number to a string of places_to_print characters.     *)
(*    If 'places_to_print' is negative, display leading zeros.		*)
(*    Otherwise, display leading blanks.				*)
(*									*)
(************************************************************************)


procedure entry format_number(
  number_to_convert	: integer;
  radix 		: integer;
  places_to_print	: integer );

var
  n, comparator : integer;

begin
  if number_to_convert >= 0
  then
    begin
      comparator := 1;
      for n := 1 to abs(places_to_print)-1 do comparator := comparator * radix;
      repeat
	if comparator > number_to_convert
	then
	  if places_to_print < 0
	  then put_char('0')
	  else put_char(' ');
	comparator := comparator div radix
      until comparator = 1
    end;
  put_number( number_to_convert, radix )
end (* format_number *) ;



(************************  internal_to_string  **************************)
(*									*)
(*			      scaled_number				*)
(*									*)
(*    Convert a number to a string with a radix point a given number  *)
(*    of places to the left of the right of the number. I.e, a call   *)
(*    of scaled_number(1234, 10, 1) will produce the number 123.4     *)
(*									*)
(************************************************************************)



procedure entry scaled_number(
  number_to_convert	: integer;
  radix			: integer;
  radix_place		: integer);
var
  fraction: integer;
  scale: integer;
  i: integer;

begin
  scale := 1 (* construct scale factor from radix places *) ;
  for i := 1 to radix_place do scale := scale*radix;
  put_number(number_to_convert div scale, radix);
  put_char('.');
  fraction := abs(number_to_convert mod scale);
  scale := scale div radix;
  while scale > fraction do (* output leading zeros of fraction *)
    begin
      put_char('0');
      scale := scale div radix
    end (* while *) ;
  if fraction > 0 then put_number(fraction, radix)
end (* scaled_number *) ;



(***********************  internal_to_string  *****************************)
(*									*)
(*			   number_range 				*)
(*									*)
(*    convert a number range in any radix to a string.			*)
(*									*)
(**************************************************************************)


procedure entry number_range(
  first_number_to_convert	: integer;	
  last_number_to_convert	: integer;
  radix				: integer);

begin
  put_number(first_number_to_convert, radix);
  if first_number_to_convert <> last_number_to_convert
  then
    begin
      put_char( '-' );
      put_number(last_number_to_convert, radix)
    end
end (* number_range *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*				 string 				*)
(*									*)
(*    Put string into buffer.						*)
(*									*)
(************************************************************************)



procedure entry string(string_to_insert: quoted_text);

begin
  put_string(string_to_insert)
end (* string *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*				 newline				*)
(*									*)
(*    Put carriage return linefeed in buffer.				*)
(*									*)
(************************************************************************)



procedure entry newline;

begin
  put_char('(:13:)');
  put_char('(:10:)')
end (* newline *) ;



(************************  internal_to_string  **************************)
(*									*)
(*				  skip					*)
(*									*)
(*    Skip n blanks in buffer. If n is negative, set buffer size.	*)
(*									*)
(************************************************************************)



procedure entry skip(n: integer);

var
  i: integer;

begin
  if n > 0
  then
    for i := 1 to n do put_char(' ')
  else
    buffer.size := buffer.size+n
end (* skip *) ;



(************************  internal_to_string  **************************)
(*									*)
(*				skip_to 				*)
(*									*)
(*    Skip to position n in buffer.					*)
(*									*)
(************************************************************************)



procedure entry skip_to(n: integer);

var
  i: integer;

begin
  if n > buffer.size
  then
    for i := 1 to n-buffer.size do put_char(' ')
  else
    buffer.size := n
end (* skip_to *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*				character				*)
(*									*)
(*    Put single character in buffer.					*)
(*									*)
(************************************************************************)



procedure entry character(c: char);

begin
  put_char(c)
end (* character *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*				  start 				*)
(*									*)
(*    Start the buffer at the beginning.				*)
(*									*)
(************************************************************************)



procedure entry start;

begin
  buffer.size := 0
end (* start *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*			    simple_message				*)
(*									*)
(*    Start the buffer at the beginning and insert a message.		*)
(*									*)
(************************************************************************)



procedure entry simple_message(message_to_insert: quoted_text);

begin
  buffer.size := 0;
  put_string(message_to_insert)
end (* simple_message *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*			     write_block				*)
(*									*)
(*    Write buffer to given terminal as a block.			*)
(*									*)
(************************************************************************)



procedure entry write_block(circuit: circuit_handler);

begin
  circuit.write_format_buffer(buffer)
end (* write_block *) ;



(***********************  internal_to_string  ***************************)
(*									*)
(*			      write_line				*)
(*									*)
(*    Write current buffer to given circuit as a line.			*)
(*									*)
(************************************************************************)



procedure entry write_line(circuit: circuit_handler);

begin
  put_char('(:13:)');
  put_char('(:10:)');
  circuit.write_format_buffer(buffer)
end (* write_line *) ;
!
(***********************  internal_to_string  ***************************)
(*									*)
(*		       copy_network_login_string			*)
(*									*)
(*	Move the buffer to a network_login_string.			*)
(*									*)
(************************************************************************)


procedure entry copy_network_login_string(
  var string : network_login_string);

var
  i: network_login_string_text_index;

begin
  string.size := buffer.size;
  for i := 0 to NETWORK_LOGIN_STRING_TEXT_LIMIT do
    if i < buffer.size
    then string.text[i] := buffer.text[i]
    else string.text[i] := ' '
end (* copy_network_login_string *) ;



(************************  internal_to_string  **************************)
(************************************************************************)



begin (* initial statement *)
  init calandar
end (* internal_to_string *) ;
!
(************************************************************************)
(*									*)
(*	DSKERR.TDR							*)
(*									*)
(*			       disk_error				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	03Jan84 Original -- ahm						*)
(*									*)
(************************************************************************)


type
  disk_error =
    class(
      user_terminal	: circuit_handler;
      format		: internal_to_string
    );



(***************************  Disk_Error  *****************************)
(*                                                                    *)
(*			    disk_error_check			      *)
(*                                                                    *)
(*	Print the disk error to the terminal.			      *)
(*                                                                    *)
(**********************************************************************)



procedure entry disk_error_check(
  call	: disk_param;
  value	: disk_param);

begin
  if value.status <> COMPLETE
  then
    with format do
      begin
	simple_message('Disk \');
	disk_operation_name(call.operation);
	string(' error at \ ');
	number(call.start_addr, 16);
	string(' for \');
	number(call.byte_count, 10);
	string(' byte\');
	write_line(user_terminal);
	simple_message('TRANSFER: \ ');
	number(value.start_addr, 10);
	skip_to(20);
	string('ISIS: \ ');
	number(value.byte_count, 10);
	skip_to(40);
	string('STATUS2: \');
	number(value.status2, 16);
	write_line(user_terminal)
      end (* with *)
end (* disk_error_check *) ;


(***************************  Disk_Error  *****************************)
(**********************************************************************)


begin
end (* disk_error *) ;
!
(**********************************************************************)
(*                                                                    *)
(*	DSKSYS.TDR						      *)
(*                            Disk_System                             *)
(*                                                                    *)
(*	This class makes the actual io calls for disk access to	      *)
(*	the file system.					      *)
(*                                                                    *)
(*    The following identifiers must be defined externally:           *)
(*      Block                                                         *)
(*      Disk_operation                                                *)
(*      Page                                                          *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          Revision Record                           *)
(*                                                                    *)
(*    14NOV79   Original -- DEG                                       *)
(*    18Aug81    remove unit and logical volume concept rer	      *)
(*     2Sep81    Convert to nucleus 6.0 - RER			      *)
(*    29Oct81	 Pass both param before and after for error - rer     *)
(*                                                                    *)
(**********************************************************************)



type disk_system = class(io_report: disk_error);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			      page_request			      *)
(*                                                                    *)
(*	Do a page read or write.				      *)
(*                                                                    *)
(**********************************************************************)



procedure page_request( page_operation: disk_operation;
			page_address: integer;
			var page_buffer: page;
			var ok: boolean);

var
  call_param : disk_param;
  value_param: disk_param;

begin
  with call_param do
    begin
      operation := page_operation;
      start_addr := page_address;
      byte_count := page_size
    end (* with *) ;
  value_param := call_param;
  io(page_buffer, value_param, disk, file_system_disk);
  ok := value_param.status = complete;
  if not ok
  then io_report.disk_error_check(call_param, value_param)
end (* page_request *) ;



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			     block_request			      *)
(*                                                                    *)
(*	Do a block read or write.				      *)
(*                                                                    *)
(**********************************************************************)



procedure block_request(block_operation: disk_operation;
			block_address: integer;
			var block_buffer: block;
			var ok: boolean);

var
  call_param : disk_param;
  value_param: disk_param;

begin
  with call_param do
    begin
      operation := block_operation;
      start_addr := block_address;
      byte_count := block_size*page_size
    end (* with *) ;
  value_param := call_param;
  io(block_buffer, value_param, disk, file_system_disk);
  ok := value_param.status = complete;
  if not ok
  then io_report.disk_error_check(call_param, value_param)
end (* block_request *) ;



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                             Read_Page                              *)
(*                                                                    *)
(*    Reads a single page.					      *)
(*                                                                    *)
(**********************************************************************)



procedure entry read_page(
  (* input *) page_addr: integer;
  (* output *) var data: univ page;
  (* output *) var success: Boolean);

begin
  page_request(disk_read, page_addr, data, success)
end (* read_page *) ;



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                             Write_Page                             *)
(*                                                                    *)
(*    Writes a single page.					      *)
(*                                                                    *)
(**********************************************************************)



procedure entry write_page(
  (* input *) page_addr: integer;
  (* input *) var data: univ page;
  (* output *) var success: Boolean);

begin
  page_request(disk_write, page_addr, data, success)
end (* write_page *) ;



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                             Read_Block                             *)
(*                                                                    *)
(*    Reads a multi-page block.					      *)
(*                                                                    *)
(**********************************************************************)



procedure entry read_block(
  (* input *) page_addr: integer;
  (* output *) var data: univ block;
  (* output *) var success: Boolean);

begin
  block_request(disk_read, page_addr, data, success)
end (* read_block *) ;



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                            Write_Block                             *)
(*                                                                    *)
(*    Writes a multi-page block.				      *)
(*                                                                    *)
(**********************************************************************)



procedure entry write_block(
  (* input *) page_addr: integer;
  (* input *) var data: univ block;
  (* input *) var success: Boolean);

begin
  block_request(disk_write, page_addr, data, success)
end (* write_block *) ;



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                             get_info                               *)
(*                                                                    *)
(*    Get disk information for file system disk.		      *)
(*                                                                    *)
(**********************************************************************)



procedure entry get_info(
  (* input *) var dinfo: disk_tape_information;
  (* input *) var ok   : boolean);

var
  param : disk_param;

begin
  with param do
    begin
      operation := disk_info;
      io(dinfo, param, disk, file_system_disk)
    end (* with *) ;
  ok := param.status = complete
end (* get_info *) ;



(***************************  Disk_System  ****************************)
(**********************************************************************)



begin (* initial statement *)
  (* empty *)
end (* disk_system *) ;
!
(************************************************************************)
(*									*)
(*	CMDDEF.TDR							*)
(*									*)
(*	Constants and global types for commands.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	31Oct83 Original from CMDDEF.BAS - ahm				*)
(*									*)
(************************************************************************)


(* constants dealing with input errors *)

type
  command_scan_state = (
    CMD_OK, NO_CMD, RUN_ERROR,
    BREAK_ERROR, CMD_ERROR, NO_FREEWORD,
    INV_KEYWORD, AUTH_ERROR, ARG_ERROR, ARG_MISSING,
    ARG_SYSTEM_ERROR,
    TOO_MANY_ARGS, ARG_NUMBER_TOO_LARGE, ARG_ZERO_NOT_ALLOWED,
    ARG_NOT_QUOTED_TEXT, ARG_FREEWORD_MISSING,
    ARG_NULL_QUOTED_TEXT,
    ARG_NOT_FOUR_CHARS, ARG_NOT_HEX_BYTE
    );



type
  command_class_index = (
    START_OF_COMMAND_CLASSES,
      CONTEXT_CLASS	(* Context switching system commands *) ,
      GLOBAL_CLASS	(* Global system level commands *) ,
    END_OF_COMMAND_CLASSES
    );

(* Context switching definitions *)

type
  context_set = set of command_class_index;
!
(* List of internal identifiers for all commands in the system.  These  *)
(* commands will be distributed in various arrays according to what	*)
(* command class they belong to.					*)

type
  command_index = (
    START_OF_COMMANDS,

(* Global commands may be executeted from anywhere: *)

      START_GLOBAL_COMMANDS,
	GLOBAL_DATE	(* current time and date in users time zone *) ,
  	GLOBAL_HELP	(* help as best you can *) ,
	GLOBAL_MESSAGE	(* list operator log *) ,
	GLOBAL_VERSION	(* display version and revision number *) ,
      END_GLOBAL_COMMANDS,

(* context commands change the users context				*)

      START_CONTEXT_COMMANDS,
	CONTEXT_INITIALIZE  (* initialize disk *) ,
	CONTEXT_RECONFIGURE (* reconfigure disk *) ,
	CONTEXT_DUMP	    (* dump vfdd, directory or page in hexadecimal *),
	CONTEXT_DISPLAY     (* display configuration parameters *) ,
	CONTEXT_RESTORE	    (* restore the tmcs files *) ,
	CONTEXT_SAVE	    (* save the tmcs files *) ,
	CONTEXT_ERLOG	    (* display erlog buffer length *),
	CONTEXT_QUIT	    (* leave system *) ,
      END_CONTEXT_COMMANDS,

  END_OF_COMMANDS
  );

type
  global_command_index =
    START_GLOBAL_COMMANDS .. END_GLOBAL_COMMANDS;
  context_command_index =
    START_CONTEXT_COMMANDS .. END_CONTEXT_COMMANDS;
!
(*	The keyword index for GLOBAL commands.				*)

const
  global_offset = 0;

  global_date_keyword_offset = global_offset;
  global_date_keyword_max = 0;
  global_date_subcommand_max = 0;

  global_help_keyword_offset =
    global_date_keyword_offset+global_date_keyword_max;
  global_help_keyword_max = 0;
  global_help_subcommand_max = 0;

  global_message_keyword_offset =
    global_help_keyword_offset+global_help_keyword_max;
  global_message_from_keyword = 0;
  global_message_keyword_max = 1;
  global_message_subcommand_max = 0;

  global_version_keyword_offset =
    global_message_keyword_offset+global_message_keyword_max;
  global_version_keyword_max = 0;
  global_version_subcommand_max = 0;

  global_keyword_max =
    global_version_keyword_offset+global_version_keyword_max-global_offset;
!
(*	The keyword index for SYS CONTEXT commands.			*)

const
  context_offset = global_offset+global_keyword_max;

  context_init_keyword_offset = context_offset;
  context_init_keyword_max = 0;
  context_init_subcommand_max = 0;

  context_reconf_keyword_offset = 
    context_init_keyword_offset+context_init_keyword_max;
  context_reconf_keyword_max = 0;
  context_reconf_subcommand_max = 0;

  context_dump_keyword_offset = 
    context_reconf_keyword_offset+context_reconf_keyword_max;
  context_dump_vfdd_keyword = 0;
  context_dump_dir_keyword = 1;
  context_dump_keyword_max = 2;
  context_dump_subcommand_max = 0;

  context_display_keyword_offset = 
    context_dump_keyword_offset+context_dump_keyword_max;
  context_display_config_keyword = 0;
  context_display_keyword_max = 1;
  context_display_subcommand_max = 0;

  context_restore_keyword_offset = 
    context_display_keyword_offset+context_display_keyword_max;
  context_restore_keyword_max = 0;
  context_restore_subcommand_max = 0;

  context_save_keyword_offset = 
    context_restore_keyword_offset+context_restore_keyword_max;
  context_save_keyword_max = 0;
  context_save_subcommand_max = 0;

  context_erlog_keyword_offset = 
    context_save_keyword_offset+context_save_keyword_max;
  context_erlog_keyword_max = 0;
  context_erlog_subcommand_max = 0;

  context_quit_keyword_offset = 
    context_erlog_keyword_offset+context_erlog_keyword_max;
  context_quit_keyword_max = 0;
  context_quit_subcommand_max = 0;

  context_keyword_max =
    context_quit_keyword_offset+context_quit_keyword_max-context_offset;

const
  keyword_max =
    global_keyword_max+context_keyword_max;
  keyword_limit = keyword_max-1;

type
  keyword_index = 0..keyword_limit;
!
(***********************************************************************)
(*                                                                     *)
(*       command scanner definitions                                   *)
(*                                                                     *)
(***********************************************************************)

(*	The name of the command in the command definition.		*)

const
  command_name_text_max   = 16 (* characters *) ;
  command_name_text_limit = command_name_text_max-1;

type
  command_name_text_index = 0..command_name_text_limit;
  command_name_text_size  = 0..command_name_text_max;

  command_name_text = array [command_name_text_index] of char;

  command_name =
    record
      size: command_name_text_size;
      text: command_name_text
    end (* command_name *) ;


(*	Keyword type definitions.					*)

const
  command_keyword_max   = 10 (* maximum number of keywords/command *) ;
  command_keyword_limit = command_keyword_max-1;

type
  command_keyword_index = 0..command_keyword_limit;
  command_keyword_total = 0..command_keyword_max;

type
  command_keyword_set = set of command_keyword_index;


(*	The name of the keyword in the command definition.		*)

const
  keyword_name_text_max   = 16 (* characters *) ;
  keyword_name_text_limit = keyword_name_text_max-1;

type
  keyword_name_text_index = 0..keyword_name_text_limit;
  keyword_name_text_size  = 0..keyword_name_text_max;

  keyword_name_text = array [keyword_name_text_index] of char;

  keyword_name =
    record
      size: keyword_name_text_size;
      text: keyword_name_text
    end (* keyword_name *) ;


(*	Freeword definitions.						*)

const
  command_freeword_max   = 15 (* maximum number of freewords/command *) ;
  command_freeword_limit = command_freeword_max-1;

type
  command_freeword_index = 0..command_freeword_limit;
  command_freeword_total = 0..command_freeword_max;


(*	Command token definition.					*)
(*	This record points to a command line token.			*)

const
  command_token_max   = command_line_text_limit (* maximum token extent *) ;
  command_token_limit = command_token_max-1;

type
  command_token_index = 0..command_token_limit;
  command_token_size  = 0..command_token_max;

type
  command_token =
    record
      start  : command_token_index;
      finish : command_token_index
    end (* command_token *) ;


(*	Description of a command line after it is scanned.		*)
(*	The feilds of the record have the following meaning.		*)
(*									*)
(*  input_line		the text to be scanned				*)
(*  prompt		the prompt for the current command class	*)
(*  status		the status of the scan i.e. an error code	*)
(*  error_column	where in 'input_line' the error occurred	*)
(*  command_class	the context the command comes from		*)
(*  command		the index of the command scanned		*)
(*  subcommand		the keyword index of the subcommand if one	*)
(*			is required. A subcommand is required if the	*)
(*			'subcommand_count' in the command definition	*)
(*			is greater than zero				*)
(*  keyword_count	the number of keywords in the command		*)
(*  keyword_present	the set of all keywords scanned			*)
(*  keyword_value	the value token if the command requires one	*)
(*  freeword_count	the number of freewords in the command		*)
(*  freeword_value	the token for the freewords entered		*)

type
  scanned_command =
    record
      input_line	: command_line;
      prompt		: command_prompt;
      status		: command_scan_state;
      error_column	: command_line_text_index;
      command_class	: command_class_index;
      command		: command_index;
      subcommand	: command_keyword_index;
      keyword_count	: command_keyword_total;
      keyword_present	: command_keyword_set;
      keyword_value	: array [command_keyword_index] of command_token;
      freeword_count	: command_freeword_total;
      freeword_value	: array [command_freeword_index] of command_token
    end (* scanned_command *) ;
!
(*	A command definition header.					*)
(*	This record defines a command, including its name and allowed	*)
(*	parameters. The fields of the record have the following meaning.*)
(*									*)
(*  name		the text for the command name			*)
(*  abreviation		the minimum number of characters which must be	*)
(*			entered for the command to be recognized	*)
(*  freeword_allowed	true if the command allows freewords		*)
(*  keyword_offset	the start of the keywords for this command in	*)
(*			'keyword_table' which contains all keywords	*)
(*			for all commands				*)
(*  keyword_count	the number of keywords allowed for this command	*)
(*			in 'keyword_table' starting at 'keyword_offset'	*)
(*  subcommand_count	the number of the keywords for this command	*)
(*			which should be treated as subcommands. These	*)
(*			will be the first 'subcommand_total' keywords	*)
(*			of this command					*)

type
  command_definition =
    record
      name		: command_name;
      abreviation	: command_name_text_size;
      freeword_allowed	: boolean;
      keyword_offset	: keyword_index;
      keyword_count	: command_keyword_total;
      subcommand_count	: command_keyword_total
    end (* command_definition *) ;


(*	A keyword definition.						*)
(*	This record defines a keyword, including its name and		*)
(*	properties. The feilds of the record have the folowing meaning.	*)
(*									*)
(*  name		the text for the keyword name			*)
(*  abreviation		the minimum number of characters which must be	*)
(*			entered for the keyword to be recognized	*)
(*  value_required	true if the keyword must be followed by a value	*)

type
  keyword_definition =
    record
      name		: keyword_name;
      abreviation	: keyword_name_text_size;
      value_required	: boolean
    end (* keyword_definition *) ;
!
(************************************************************************)
(*									*)
(*	Updated 29-Oct-85 at 10:50 by Hueyma				*)
(*	CMDS.TDR							*)
(*									*)
(*		            command_table				*)
(*                                                                      *)
(*       This class contains the definition of all commands.		*)
(*       It is accessed by the commandscan class to lookup the		*)
(*       particular command in question and returns the complete	*)
(*       definition record for the command found.			*)
(*									*)
(*	The commands are distributed into command classes. Each class	*)
(*	has an array of command definitions associated with it.		*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_definition	keyword_definition			*)
(*	  scanned_command	command_token				*)
(*	  end_of_(class)	command_class_index			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	20Sep83	Original -- rer						*)
(*	30Oct85 Changed to class -- ahm					*)
(*									*)
(************************************************************************)

type
  command_table = class



var

  (* command class definitions *)

  global_defs	: array [global_command_index]   of command_definition;
  context_defs	: array [context_command_index]  of command_definition;

  (* prompt array definition *)

  class_prompt : array [command_class_index] of command_prompt;

  (* keywords for all commands *)

  keyword_table : array [keyword_index] of keyword_definition;
!
(**************************  command_table  *****************************)
(*									*)
(*			     get_header					*)
(*									*)
(*	Move command header to command definition block.		*)
(*									*)
(************************************************************************)

procedure get_header(
      scanned	: scanned_command;
  var header	: command_definition);

begin
  case scanned.command_class of
    global_class:
      header := global_defs[scanned.command];
    context_class:
      header := context_defs[scanned.command]
  end (* case *)
end (* get_header *) ;



(**************************  command_table  *****************************)
(*									*)
(*			  get_keyword_entry				*)
(*									*)
(*	Move keyword for this command to definition block.		*)
(*									*)
(************************************************************************)

procedure get_keyword_entry(
      header	    : command_definition;
      keyword	    : command_keyword_index;
  var keyword_entry : keyword_definition);

begin
  keyword_entry := keyword_table[header.keyword_offset+keyword]
end (* get_keyword_entry *) ;
!
(***************************  command_table  ****************************)
(*									*)
(*			    get_class_bounds				*)
(*									*)
(*  Routine to set up the start and end of a command class index	*)
(*									*)
(************************************************************************)


procedure get_class_bounds(
  var scanned	: scanned_command;
  var end_class	: command_index);

begin
  case scanned.command_class of

    GLOBAL_CLASS:
      begin
	scanned.command := succ(START_GLOBAL_COMMANDS);	
	end_class       := END_GLOBAL_COMMANDS
      end (* GLOBAL_CLASS *) ;

    CONTEXT_CLASS:
      begin
	scanned.command := succ(START_CONTEXT_COMMANDS);
	end_class       := END_CONTEXT_COMMANDS
      end (* CONTEXT_CLASS *)

  end (* case *)
end (* get_class_bounds *) ;



(**************************   command_table   ***************************)
(*									*)
(*			     find_command				*)
(*									*)
(*       Routine to lookup specified command.				*)
(*									*)
(************************************************************************)


procedure entry find_command(
      command_context	: context_set;
  var scanned		: scanned_command;
  var token		: command_token;
  var header		: command_definition;
  var found		: boolean);

var
  i		: command_name_text_index;
  end_class	: command_index;
  token_size	: command_token_size;

begin
  found := FALSE;
  scanned.command_class := succ(START_OF_COMMAND_CLASSES);
  token_size := token.finish-token.start;
  while (scanned.command_class < END_OF_COMMAND_CLASSES) and not found do
    begin
      get_class_bounds(scanned, end_class);
      if scanned.command_class in command_context
      then
	while (scanned.command < end_class) and not found do
	  begin
	    get_header(scanned, header);
	    if (token_size >= header.abreviation) and
	       (token_size <= header.name.size)
	    then
	      begin
		found := TRUE;
		for i := 0 to token_size-1 do
		  if header.name.text[i] <>
		     scanned.input_line.text[token.start+i]
		  then found := FALSE
	      end (* if (token_size >= ...) then *) ;
	    if not found
	    then scanned.command := succ(scanned.command)
	  end (* while *) ;
      if not found
      then scanned.command_class := succ(scanned.command_class)
    end (* while *)
end (* find_command *) ;



(**************************   command_table   ***************************)
(*									*)
(*			     find_keyword				*)
(*									*)
(*       Routine to lookup a keyword for a command.			*)
(*									*)
(************************************************************************)


procedure entry find_keyword(
      header		: command_definition;
  var scanned		: scanned_command;
  var token		: command_token;
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

var
  i: command_token_index;
  token_size: command_token_size;

begin
  found := FALSE;
  token_size := token.finish-token.start;
  keyword := 0;
  while (keyword < header.keyword_count) and not found do
    begin
      get_keyword_entry(header, keyword, keyword_entry);
      if (keyword_entry.abreviation <= token_size) and
	 (token_size <= keyword_entry.name.size)
      then
	begin
	  found := TRUE;
	  for i := 0 to token_size-1 do
	    if keyword_entry.name.text[i] <>
	       scanned.input_line.text[token.start+i]
	    then found := FALSE;
	end (* if (token_size >= ...) then *) ;
      if not found
      then keyword := succ(keyword)
    end (* while *)
end (* find_keyword *) ;
!
(****************************  command_table  ***************************)
(*									*)
(*				get_prompt				*)
(*									*)
(*  Returns the prompt of the highest priority class			*)
(*									*)
(************************************************************************)

procedure entry get_prompt(
      context	: context_set;
  var scanned	: scanned_command);

var
  command_class : command_class_index;

begin
  command_class := succ(START_OF_COMMAND_CLASSES);
  while not (command_class in context) do
    command_class := succ(command_class);
  scanned.prompt := class_prompt[command_class]
end (* get_prompt *) ;
!
(************************************************************************)
(*									*)
(*	Always define sub-command words as first sub_defs.  Sub_defs	*)
(*	that are options for an argument should be defined sequentially.*)
(*									*)
(************************************************************************)

begin  (* initialize command_table monitor *)

(* global command definitions *)

  with global_defs[global_date] do
    begin
      name.text        := 'DATE            ';
      name.size        := 4;
      abreviation      := 2;
      freeword_allowed := FALSE;
      keyword_offset   := global_date_keyword_offset;
      keyword_count    := global_date_keyword_max;
      subcommand_count := global_date_subcommand_max
    end (* global_date *) ;

  with global_defs[global_help] do
    begin
      name.text        := 'HELP            ';
      name.size        := 4;
      abreviation      := 2;
      freeword_allowed := FALSE;
      keyword_offset   := global_help_keyword_offset;
      keyword_count    := global_help_keyword_max;
      subcommand_count := global_help_subcommand_max
    end (* global_help *) ;

  with global_defs[global_message] do
    begin
      name.text        := 'MESSAGE         ';
      name.size        := 7;
      abreviation      := 4;
      freeword_allowed := TRUE;
      keyword_offset   := global_message_keyword_offset;
      keyword_count    := global_message_keyword_max;
      subcommand_count := global_message_subcommand_max
    end (* global_message *) ;

  with keyword_table[global_message_keyword_offset+global_message_from_keyword] do
    begin
      name.text        := 'FROM            ';
      name.size        := 4;
      abreviation      := 4;
      value_required   := FALSE
    end (* global_message_from_keyword *) ;

  with global_defs[global_version] do
    begin
      name.text        := 'VERSION         ';
      name.size        := 7;
      abreviation      := 3;
      freeword_allowed := FALSE;
      keyword_offset   := global_version_keyword_offset;
      keyword_count    := global_version_keyword_max;
      subcommand_count := global_version_subcommand_max
    end (* global_version *) ;
!
(* context command definitions *)

  with context_defs[context_initialize] do
    begin
      name.text        := 'INITIALIZE      ';
      name.size        := 10;
      abreviation      := 4;
      freeword_allowed := FALSE;
      keyword_offset   := context_init_keyword_offset;
      keyword_count    := context_init_keyword_max;
      subcommand_count := context_init_subcommand_max
    end (* context_initialize *) ;

  with context_defs[context_reconfigure] do
    begin
      name.text        := 'RECONFIGURE     ';
      name.size        := 11;
      abreviation      := 6;
      freeword_allowed := FALSE;
      keyword_offset   := context_reconf_keyword_offset;
      keyword_count    := context_reconf_keyword_max;
      subcommand_count := context_reconf_subcommand_max
    end (* context_reconfigure *) ;

  with context_defs[context_dump] do
    begin
      name.text        := 'DUMP            ';
      name.size        := 4;
      abreviation      := 1;
      freeword_allowed := TRUE;
      keyword_offset   := context_dump_keyword_offset;
      keyword_count    := context_dump_keyword_max;
      subcommand_count := context_dump_subcommand_max
    end (* context_dump *) ;

  with keyword_table[context_dump_keyword_offset+context_dump_vfdd_keyword] do
    begin
      name.text        := 'VFDD            ';
      name.size        := 4;
      abreviation      := 4;
      value_required   := FALSE
    end (* context_dump_vfdd_keyword *) ;

  with keyword_table[context_dump_keyword_offset+context_dump_dir_keyword] do
    begin
      name.text        := 'DIRECTORY       ';
      name.size        := 9;
      abreviation      := 3;
      value_required   := FALSE
    end (* context_dump_dir_keyword *) ;

  with context_defs[context_display] do
    begin
      name.text        := 'DISPLAY         ';
      name.size        := 7;
      abreviation      := 4;
      freeword_allowed := FALSE;
      keyword_offset   := context_display_keyword_offset;
      keyword_count    := context_display_keyword_max;
      subcommand_count := context_display_subcommand_max
    end (* context_display *) ;

  with keyword_table[context_display_keyword_offset+
    context_display_config_keyword] do
    begin
      name.text        := 'CONFIG          ';
      name.size        := 6;
      abreviation      := 4;
      value_required   := FALSE
    end (* context_display_config_keyword *) ;

  with context_defs[context_restore] do
    begin
      name.text        := 'RESTORE	   ';
      name.size        := 7;
      abreviation      := 4;
      freeword_allowed := FALSE;
      keyword_offset   := context_restore_keyword_offset;
      keyword_count    := context_restore_keyword_max;
      subcommand_count := context_restore_subcommand_max   
    end (* context_restore *) ;

  with context_defs[context_save] do
    begin
      name.text        := 'SAVE		   ';
      name.size        := 4;
      abreviation      := 4;
      freeword_allowed := FALSE;
      keyword_offset   := context_save_keyword_offset;
      keyword_count    := context_save_keyword_max;
      subcommand_count := context_save_subcommand_max   
    end (* context_save *) ;

  with context_defs[context_erlog] do
    begin
      name.text        := 'ERLOG	   ';
      name.size        := 5;
      abreviation      := 3;
      freeword_allowed := FALSE;
      keyword_offset   := context_erlog_keyword_offset;
      keyword_count    := context_erlog_keyword_max;
      subcommand_count := context_erlog_subcommand_max
    end (* context_erlog *) ;

  with context_defs[context_quit] do
    begin
      name.text        := 'QUIT            ';
      name.size        := 4;
      abreviation      := 1;
      freeword_allowed := FALSE;
      keyword_offset   := context_quit_keyword_offset;
      keyword_count    := context_quit_keyword_max;
      subcommand_count := context_quit_subcommand_max
    end (* context_quit *) ;

!
  (* class prompt definitions *)
 
  with class_prompt[context_class] do
    begin
      text := '*     ';
      size := 2
    end (* context_class *) ;

  with class_prompt[global_class] do
    begin
      text := '*     ';
      size := 2
    end (* global_class *) ;

end (* command_table *) ;
!
(************************************************************************)
(*									*)
(*	ARGSCN.BAS							*)
(*									*)
(*			   argument_scanner 				*)
(*									*)
(*	Set of routines to convert arguments.				*)
(*									*)
(*	The following identifiers must be identified externally:	*)
(*	  asc_space, asc_minus						*)
(*	  identifier							*)
(*	  symbol							*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	20Sep83	Original -- rer						*)
(*									*)
(************************************************************************)

type
  argument_scanner =
    class

var
  calendar: date_time_converter;

(*	The following set is constructed while a command is scanned.	*)
(*	It will contain all the keywords that a command uses.		*)
(*	The putting of keywords in this set is done in 'check_keyword'.	*)
(*	This routine also checks for keyword presents, so it is used	*)
(*	to both check if a keyword is present and to record its use.	*)
(*	The set is used in 'extra_keyword_check' to determine if any	*)
(*	extra keywords were entered. It is cleared in the entry		*)
(*	'reset_argument_check'.						*)
(*	cleared at the start of each command compile.			*)

  keyword_used: command_keyword_set;

(*	The following counter counts the numbewr of freewords used in a	*)
(*	command. After the command is completely scanned, this number	*)
(*	is compared with FREEWORD_COUNT in SCANNED. If it is less, than	*)
(*	there are							*)
(*	free words in the command which have not been used. If so,	*)
(*	STATUS is set to ARG_ERROR. This is done in check_allowed.	*)

  freeword_used: command_freeword_total;
!
(**************************  argument_scanner  **************************)
(*									*)
(*			 check_freeword_available			*)
(*									*)
(*	Check that freeword is available and remember last used.	*)
(*									*)
(************************************************************************)

procedure check_freeword_available(
      freeword	: command_freeword_index;
  var scanned	: scanned_command);

begin
  if (freeword+1) > scanned.freeword_count
  then scanned.status := ARG_FREEWORD_MISSING
  else if (freeword+1) > freeword_used
  then freeword_used := freeword+1
end (* check_freeword_available *) ;



(**************************  argument_scanner  **************************)
(*									*)
(*			    check_argument_end				*)
(*									*)
(*	Check that all the characters in a token have been scanned.	*)
(*									*)
(************************************************************************)

procedure check_argument_end(
      token	: command_token;
  var scanned	: scanned_command);

begin
  if scanned.status = CMD_OK
  then
    if token.start < token.finish
    then scanned.status := ARG_ERROR
end (* check_argument_end *) ;



(**************************  argument_scanner  **************************)
(*									*)
(*			      alpha_numeric				*)
(*									*)
(*      Return true if c is an alpha-numeric character.			*)
(*									*)
(************************************************************************)

function alpha_numeric(c : char) : boolean;

begin
  alpha_numeric := (('0' <= c) and (c <= '9')) or (('A' <= c) and (c <= 'Z'))
end (* alpha_numeric *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			    argument_symbol				*)
(*									*)
(************************************************************************)


procedure argument_symbol(
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: symbol);

var
  i: symbol_text_index;

begin
  value.size :=0;
  for i := 0 to symbol_text_limit do
    if token.start < token.finish
    then
      begin
	value.text[i] := scanned.input_line.text[token.start];
	if not alpha_numeric(value.text[i])
	then scanned.status := ARG_ERROR;
	value.size := value.size+1;
	token.start := token.start+1
      end
    else value.text[i] := ' ';
  check_argument_end(token, scanned)
end (* argument_symbol *) ;



(*************************  argument_scanner  ***************************)
(*									*)
(*			     keyword_symbol				*)
(*									*)
(************************************************************************)


procedure entry keyword_symbol(
      keyword	: command_keyword_index;
  var scanned	: scanned_command;
  var value	: symbol);

var
  token: command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_symbol(token, scanned, value)
end (* keyword_symbol *) ;



(*************************  argument_scanner  ***************************)
(*									*)
(*			     freeword_symbol				*)
(*									*)
(************************************************************************)


procedure entry freeword_symbol(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var value	: symbol);

var
  token: command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_symbol(token, scanned, value)
    end
end (* freeword_symbol *) ;
!
(**************************  argument_scanner  **************************)
(*									*)
(*			   argument_digit_string			*)
(*									*)
(*	Scan a string of decimal digits and return as a string.		*)
(*									*)
(************************************************************************)


procedure argument_digit_string(
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: digit_string);

var
  i: command_line_text_index;
  size: command_token_size;

begin
  size := token.finish-token.start;
  if size > DIGIT_STRING_TEXT_MAX
  then scanned.status := ARG_ERROR
  else value.size := size;
  if scanned.status = CMD_OK
  then
    for i := 0 to value.size-1 do
      begin
	value.text[i] := scanned.input_line.text[token.start+i];
	if (value.text[i] <'0') or ('9' < value.text[i])
	then scanned.status := ARG_ERROR
      end (* for *)
end (* argument_digit_string *) ;



(**************************  argument_scanner  **************************)
(*									*)
(*			  keyword_digit_string				*)
(*									*)
(*	Convert a keyword value to a digit string.			*)
(*									*)
(************************************************************************)

procedure entry keyword_digit_string(
      keyword	: command_keyword_index;
  var scanned	: scanned_command;
  var value	: digit_string);

var
  token: command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_digit_string(token, scanned, value)
end (* keyword_digit_string *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  freeword_digit_string				*)
(*									*)
(*	Convert a freeword to a digit string.				*)
(*									*)
(************************************************************************)

procedure entry freeword_digit_string(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var value	: digit_string);

var
  token: command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_digit_string(token, scanned, value)
    end
end (* freeword_digit_string *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  argument_quoted_string			*)
(*									*)
(*	Scan for a quoted string and return with quotes removed.	*)
(*									*)
(************************************************************************)


procedure argument_quoted_string(
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: quoted_string);

var
  size: command_token_size;
  i: command_line_text_index;

begin
  size := token.finish-token.start;
  if ((scanned.input_line.text[token.start] <> '"') and
      (scanned.input_line.text[token.start] <> '(:39:)')) or
     (scanned.input_line.text[token.start] <>
      scanned.input_line.text[token.finish-1])
  then scanned.status := ARG_ERROR;
  if scanned.status = CMD_OK
  then
    if (size < 2) or ((quoted_string_text_max+2) < size)
    then scanned.status := ARG_ERROR;
  if scanned.status = CMD_OK
  then
    begin
      value.size := size-2;
      for i := 0 to value.size-1 do
	value.text[i] := scanned.input_line.text[token.start+1+i]
    end
end (* argument_quoted_string *) ;



(**************************  argument_scanner  **************************)
(*									*)
(*			  keyword_quoted_string				*)
(*									*)
(*      Convert a keyword value to a quoted string.			*)
(*									*)
(************************************************************************)

procedure entry keyword_quoted_string(
      keyword	: command_keyword_index;
  var scanned	: scanned_command;
  var value	: quoted_string);

var
  token: command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_quoted_string(token, scanned, value)
end (* keyword_quoted_string *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  freeword_quoted_string			*)
(*									*)
(*      Convert a freeword to a quoted string.				*)
(*									*)
(************************************************************************)

procedure entry freeword_quoted_string(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var value	: quoted_string);

var
  token: command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_quoted_string(token, scanned, value)
    end
end (* freeword_quoted_string *);
!
(**************************  argument_scanner  **************************)
(*									*)
(*			    get_unsigned_number				*)
(*									*)
(*      Convert an argument in value to a integer.			*)
(*									*)
(************************************************************************)


procedure get_unsigned_number(
      base	: integer;
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: integer);

var
  start    : command_token_index;
  scanning : boolean;
  digit    : integer (* the internal value of digit scanned *) ;

begin
  start := token.start;
  scanning := TRUE;
  value := 0;
  while (token.start < token.finish) and scanning do
    begin
      digit := ord(scanned.input_line.text[token.start]);
      if (ord('0') <= digit) and (digit <= ord('9'))
      then digit := digit - ord('0')
      else if (ord('A') <= digit) and (digit <= ord('F'))
      then digit := digit -ord('A') +10
      else scanning := FALSE;
      if scanning
      then scanning := digit < base;
      if scanning
      then
	begin
	  value := value*base + digit;
	  token.start := token.start+1
	end
    end (* while *) ;

  if start = token.start
  then scanned.status := ARG_ERROR
end (* get_unsigned_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			     check_value_sign				*)
(*									*)
(*	Scan for sign on value and remove.				*)
(*									*)
(************************************************************************)

procedure check_value_sign(
  var token	: command_token;
  var scanned	: scanned_command;
  var negative	: boolean);

begin
  negative := FALSE (* assume positive *) ;
  if scanned.input_line.text[token.start] = ASC_MINUS
  then
    begin
      negative := TRUE;
      token.start := token.start+1
    end
  else if scanned.input_line.text[token.start] = ASC_PLUS
  then token.start := token.start+1
end (* check_value_sign *) ;



(**************************  argument_scanner  **************************)
(*									*)
(*			  argument_scaled_number			*)
(*									*)
(*	Convert a number with a sign and decimal point to a scaled	*)
(*	integer. 							*)
(*									*)
(************************************************************************)


procedure argument_scaled_number(
      scale	: integer;
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: integer);

var
  left_value	: integer;
  right_value	: integer;
  right_size	: integer;
  negative	: boolean;
  i		: integer;

begin
  check_value_sign(token, scanned, negative);

  if token.start = token.finish (* no digits in number *)
  then scanned.status := ARG_ERROR
  else if scanned.input_line.text[token.start] = ASC_PERIOD
  then
    if (token.start+1) = token.finish (* no digits after period *)
    then scanned.status := ARG_ERROR
    else left_value := 0
  else get_unsigned_number(10, token, scanned, left_value);

  if scanned.status = CMD_OK
  then
    begin
      right_size := 0 (* assume no right side *) ;
      right_value := 0;
      if token.start < token.finish (* still characters left *)
      then
	if scanned.input_line.text[token.start] = ASC_PERIOD
	then
	  begin
	    token.start := token.start+1 (* skip period *) ;
	    right_size := token.finish-token.start;
	    if token.start < token.finish (* scan fractional part *)
	    then get_unsigned_number(10, token, scanned, right_value)
	  end
    end;

  check_argument_end(token, scanned);

  if scanned.status = CMD_OK
  then
    begin
      for i := 1 to scale do
	begin
	  left_value := left_value*10 (* scale left side *) ;
	  right_size := right_size-1 (* shift decimal point *) ;
	  if right_size < 0
	  then right_value := right_value*10 (* scale up right side *)
	end (* for *) ;
      for i := 1 to right_size do
	right_value := right_value div 10 (* remove extra digits *) ;
      value := left_value+right_value;
      if negative
      then value := -value
    end
end (* argument_scaled_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  keyword_scaled_number				*)
(*									*)
(*      Convert a keyword to an scaled integer.				*)
(*									*)
(************************************************************************)

procedure entry keyword_scaled_number(
      keyword	: command_keyword_index;
      scale	: integer;
  var scanned	: scanned_command;
  var value	: integer);

var
  token: command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_scaled_number(scale, token, scanned, value)
end (* keyword_scaled_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  freeword_scaled_number			*)
(*									*)
(*      Convert a freeword to a scaled integer.				*)
(*									*)
(************************************************************************)

procedure entry freeword_scaled_number(
      freeword	: command_freeword_index;
      scale	: integer;
  var scanned	: scanned_command;
  var value	: integer);

var
  token: command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_scaled_number(scale, token, scanned, value)
    end
end (* freeword_scaled_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      argument_number				*)
(*									*)
(*      Convert a token to a signed integer.				*)
(*									*)
(************************************************************************)

procedure argument_number(
      base	: integer;
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: integer);

var
  negative: boolean;

begin
  check_value_sign(token, scanned, negative);
  get_unsigned_number(base, token, scanned, value);
  check_argument_end(token, scanned);
  if scanned.status = CMD_OK
  then
    if negative
    then value := -value
end (* argument_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      keyword_number				*)
(*									*)
(*      Convert a keyword to an integer.				*)
(*									*)
(************************************************************************)

procedure entry keyword_number(
      keyword	: command_keyword_index;
      base	: integer;
  var scanned	: scanned_command;
  var value	: integer);

var
  token: command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_number(base, token, scanned, value)
end (* keyword_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			     freeword_number				*)
(*									*)
(*      Convert a freeword to an integer.				*)
(*									*)
(************************************************************************)

procedure entry freeword_number(
      freeword	: command_freeword_index;
      base	: integer;
  var scanned	: scanned_command;
  var value	: integer);

var
  token: command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_number(base, token, scanned, value)
    end
end (* freeword_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      argument_pair				*)
(*									*)
(*	Convert a token to a pair of					*)
(*	integers. Pair is separated by a dash.				*)
(*									*)
(************************************************************************)


procedure argument_pair(
      base	: integer;
  var token	: command_token;
  var scanned	: scanned_command;
  var first	: integer;
  var last	: integer);

 begin
  get_unsigned_number(base, token, scanned, first);
  if scanned.status = CMD_OK
  then
    if token.start = token.finish
    then last := first
    else if scanned.input_line.text[token.start] <> ASC_MINUS
    then scanned.status := ARG_ERROR
    else
      begin
	token.start := token.start+1;
	get_unsigned_number(base, token, scanned, last);
	check_argument_end(token, scanned)
      end
end (* argument_pair *);



(**************************  argument_scanner  **************************)
(*									*)
(*			       keyword_pair				*)
(*									*)
(*      Convert a keyword value to two					*)
(*	integers. Pair is separated by a dash.				*)
(*									*)
(************************************************************************)

procedure entry keyword_pair(
      keyword	: command_keyword_index;
      base	: integer;
  var scanned	: scanned_command;
  var first	: integer;
  var last	: integer);

var
  token: command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_pair(base, token, scanned, first, last)
end (* keyword_pair *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      freeword_pair				*)
(*									*)
(*      Convert an freeword token to two				*)
(*	integers. Pair is separated by a dash.				*)
(*									*)
(************************************************************************)

procedure entry freeword_pair(
      freeword	: command_freeword_index;
      base	: integer;
  var scanned	: scanned_command;
  var first	: integer;
  var last	: integer);

var
  token: command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_pair(base, token, scanned, first, last)
    end
end (* freeword_pair *);
!
(*************************  argument_scanner  ***************************)
(*									*)
(*			        get_time				*)
(*									*)
(*      Convert argument in the form HH:MM:SS to a time.		*)
(*									*)
(************************************************************************)

procedure get_time(
  var token	: command_token;
  var scanned	: scanned_command;
  var time	: integer);

var
  hour   : integer;
  minute : integer;
  second : integer;

begin
  get_unsigned_number(10, token, scanned, hour);
  if scanned.status = CMD_OK
  then
    if 23 < hour
    then scanned.status := ARG_ERROR;

  if scanned.status = CMD_OK
  then
    if scanned.input_line.text[token.start] <> ASC_COLON
    then scanned.status := ARG_ERROR
    else
      begin
	token.start := token.start+1;
	get_unsigned_number(10, token, scanned, minute)
      end;
  if scanned.status = CMD_OK
  then
    if 59 < minute
    then scanned.status := ARG_ERROR;

  if scanned.status = CMD_OK
  then
    if token.start = token.finish
    then second := 0
    else if scanned.input_line.text[token.start] <> ASC_COLON
    then scanned.status := ARG_ERROR
    else
      begin
	token.start := token.start+1;
	get_unsigned_number(10, token, scanned, second)
      end;
  if scanned.status = CMD_OK
  then
    if 59 < second
    then scanned.status := ARG_ERROR;

  check_argument_end(token, scanned);
  if scanned.status = CMD_OK
  then time := (hour*60+minute)*60+second
end (* get_time *) ;


(*************************  argument_scanner  ***************************)
(*									*)
(*			      freeword_date				*)
(*									*)
(*      Convert freeword in the form MM/DD/YY HH:MM:SS to a time.	*)
(*	YY and HH:MM are optional and the SS is optional if HH:MM given.*)
(*									*)
(************************************************************************)

procedure entry freeword_date(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var time	: integer);

var
  token	 : command_token;
  month  : integer;
  day    : integer;
  year   : integer;
  leap   : boolean;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      get_unsigned_number(10, token, scanned, month);
    end;

  if scanned.status = CMD_OK
  then
    if (month < 1) or (12 < month)
    then scanned.status := ARG_ERROR;

  if scanned.status = CMD_OK
  then
    if scanned.input_line.text[token.start] <> ASC_SLASH
    then scanned.status := ARG_ERROR
    else
      begin
	token.start := token.start+1;
	get_unsigned_number(10, token, scanned, day)
      end;

  if scanned.status = CMD_OK
  then
    if token.start = token.finish
    then
      begin
	time := realtime;
	calendar.compute_year(time, year)
      end
    else if scanned.input_line.text[token.start] <> ASC_SLASH
    then scanned.status := ARG_ERROR
    else
      begin
	token.start := token.start+1;
	get_unsigned_number(10, token, scanned, year);
	if scanned.status = CMD_OK
	then
	  if year < 100 then year := year+1900
      end;

  if scanned.status = CMD_OK
  then
    if year < 1974 then scanned.status := ARG_ERROR;
  if scanned.status = CMD_OK
  then
    begin
      leap := calendar.leap_year(year);
      if (day < 1) or (calendar.days_in_month(month, leap) < day)
      then scanned.status := ARG_ERROR
    end;
  check_argument_end(token, scanned);

  if scanned.status = CMD_OK
  then
    begin
      check_freeword_available(freeword+1, scanned);
      if scanned.status = CMD_OK
      then
	begin
	  token := scanned.freeword_value[freeword+1];
	  get_time(token, scanned, time)
	end
      else
	begin
	  scanned.status := CMD_OK;
	  time := 0
	end
    end;

  if scanned.status = CMD_OK
  then time :=
	  time+
	  (calendar.days_to_year(year)+
	   calendar.days_to_month(month, leap) + day-1)*24*60*60
end (* freeword_date *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			      argument_time				*)
(*									*)
(*	Convert command token of the form HH:MM to minutes since	*)
(*	midnight.							*)
(*									*)
(************************************************************************)


procedure argument_time(
      argument	: command_token;
  var scanned	: scanned_command;
  var time	: integer);

var
  token  : command_token;

begin
  token := argument;
  get_time(token, scanned, time);
  if scanned.status = CMD_OK
  then time := (time div 60) mod 1440
end (* argument_time *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			      keyword_time			   	*)
(*									*)
(*	Convert keyword value to minutes since midnight.		*)
(*									*)
(************************************************************************)

procedure entry keyword_time(
      keyword	: command_keyword_index;
  var scanned	: scanned_command;
  var time	: integer);

begin
  argument_time(scanned.keyword_value[keyword], scanned, time)
end (* keyword_time *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			      freeword_time			   	*)
(*									*)
(*	Convert freeword to minutes since midnight.			*)
(*									*)
(************************************************************************)

procedure entry freeword_time(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var time	: integer);

var
  token: command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_time(token, scanned, time)
    end
end (* freeword_time *);
!
(**************************  argument_scanner  **************************)
(*									*)
(*			       find_keyword				*)
(*									*)
(*      Given the first and last values of the range of possible key	*)
(*	words, return the one and only one that the user entered.	*)
(*	Set scanned_command status if any error.			*)
(*									*)
(************************************************************************)

procedure entry find_keyword(
      first_keyword	: command_keyword_index;
      last_keyword	: command_keyword_index;
  var scanned		: scanned_command;
  var keyword		: command_keyword_index);

var
  k	: integer;
  found	: boolean;

begin
  found := FALSE;
  for k := first_keyword to last_keyword do
    if k in scanned.keyword_present
    then
      if found
      then scanned.status := ARG_ERROR
      else
        begin
          found := TRUE;
          keyword := k
        end (* for *) ;

  if found
  then keyword_used := keyword_used or [keyword]
  else scanned.status := ARG_MISSING
end (* find_keyword *) ;



(**************************  argument_scanner  **************************)
(*									*)
(*			      check_keyword				*)
(*									*)
(*	Check and return whether a given keyword was entered. If so,	*)
(*	put keyword in 'keyword_used' for check of extra keywords.	*)
(*									*)
(************************************************************************)

function entry check_keyword(
  keyword : command_keyword_index;
  scanned : scanned_command): boolean;

begin
  if keyword in scanned.keyword_present
  then
    begin
      keyword_used := keyword_used or [keyword];
      check_keyword := TRUE
    end
  else check_keyword := FALSE
end (* check_keyword *) ;
!
(**************************  argument_scanner  **************************)
(*									*)
(*			  reset_argument_check				*)
(*									*)
(*	Set up for extra keyword and freeword check.			*)
(*									*)
(************************************************************************)

procedure entry reset_argument_check;

begin
  keyword_used := [];
  freeword_used := 0
end (* reset_argument_check *) ;



(**************************  argument_scanner  **************************)
(*									*)
(*			  extra_argument_check				*)
(*									*)
(*	Check if any extra keywords or freewords entered.		*)
(*									*)
(************************************************************************)

procedure entry extra_argument_check(
  var scanned	: scanned_command);

begin
  if scanned.status = CMD_OK
  then
    if scanned.keyword_present <> keyword_used
    then scanned.status := TOO_MANY_ARGS
    else if scanned.freeword_count <> freeword_used
    then scanned.status := TOO_MANY_ARGS
end (* extra_argument_check *) ;



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init calendar
end (* argument_scanner *);
!
(************************************************************************)
(*									*)
(*	CMDSCN.BAS							*)
(*									*)
(*			command scanner class				*)
(*									*)
(*	This class resides within any process wishing to scan a text	*)
(*	line.  The command definitions reside within the commanddef	*)
(*	monitor, which is called.  					*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scanned, command_definition				*)
(*	  keyword_definition, context_set, asc_space			*) 
(*	  max_key_value_size						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	21Oct82 jnm -- change to be readable, add comments and move	*)
(*			some data_formatter routines to here		*)
(*	01Oct82 rer, jnm -- changes to separate cmddef into header,	*)
(*			keywords					*)
(*	28Feb82 ebs -- mods for context switching			*)
(*	15Jan82	Original -- jnm (from (OSIRIS)cmdsc0.osi)		*)
(*									*)
(************************************************************************)

type command_scanner =
  class(
    def			: command_table;
    argument_scan	: argument_scanner
  );
!
(*****************************  commandscan  ****************************)
(*									*)
(*			      command_break				*)
(*									*)
(*      Determine if a character is a command break character (blank,	*)
(*	or carriage return).						*)
(*									*)
(************************************************************************)


function command_break(test : char) : boolean;

begin
  command_break :=  (test = ASC_SPACE) or (test = ASCCR)
end (* command_break *) ;




(****************************  commandscan  *****************************)
(*									*)
(*				 find_token				*)
(*									*)
(*	Find next separator.  Sets up token.				*)
(*									*)
(************************************************************************)


procedure find_token(
      scanned	: scanned_command;
  var token	: command_token;
  var found	: boolean);

begin
  while scanned.input_line.text[token.finish] = ASC_SPACE do
    token.finish := token.finish+1;
  token.start := token.finish;
  while not command_break(scanned.input_line.text[token.finish]) do
    token.finish := token.finish+1;
  found := token.finish > token.start
end (* find_token *) ;
!
(*****************************  commandscan  ****************************)
(*									*)
(*			   process_keyword_value			*)
(*									*)
(*     Routine to process command keyword value.			*)
(*									*)
(************************************************************************)


procedure process_keyword_value(
  var scanned : scanned_command;
      keyword : command_keyword_index;
  var token   : command_token);

var 
  found : boolean;

begin
  find_token(scanned, token, found);
  if found
  then scanned.keyword_value[keyword] := token
  else
    begin
      scanned.status := INV_KEYWORD;
      scanned.error_column := token.start
    end
end (* process_keyword_value *) ;
!
(*****************************  commandscan  ****************************)
(*									*)
(*			      process_keyword				*)
(*									*)
(*     Routine to process command keyword.				*)
(*									*)
(************************************************************************)

procedure process_keyword(
      keyword	    : command_keyword_index;
      keyword_entry : keyword_definition;
  var scanned	    : scanned_command;
  var token	    : command_token);

begin
  scanned.keyword_present := scanned.keyword_present or [keyword];
  scanned.keyword_count := scanned.keyword_count+1;

  if keyword_entry.value_required
  then process_keyword_value(scanned, keyword, token)
end (* process_keyword *) ;
!
(*****************************  commandscan  ****************************)
(*									*)
(*			     process_freeword				*)
(*									*)
(*      Routine to handle token described by token.			*)
(*	This routine sets up token as freeword if appropriate.		*)
(*									*)
(************************************************************************)

procedure process_freeword(
      header  : command_definition;
  var scanned : scanned_command;
  var token   : command_token);

begin
  if header.freeword_allowed and
     (scanned.freeword_count < COMMAND_FREEWORD_MAX)
  then
    begin	(* freewds allowed and we have room for more *)
      scanned.freeword_value[scanned.freeword_count] := token;
      scanned.freeword_count := scanned.freeword_count + 1
    end
  else
    begin
      scanned.status := NO_FREEWORD (* free word error *) ;
      scanned.error_column := token.start
    end
end (* process_freeword *) ;
!
(*****************************  commandscan  ****************************)
(*									*)
(*			       process_token				*)
(*									*)
(*      Routine to handle token described by token.			*)
(*	This routine decides if it is a keyword or a freeword and sets	*)
(*	up the appropriate values for each.				*)
(*									*)
(************************************************************************)

procedure process_token(
      header  : command_definition;
  var scanned : scanned_command;
  var token   : command_token);

var
  keyword_entry : keyword_definition;
  keyword: command_keyword_index;
  found : boolean;

begin
  def.find_keyword(header, scanned, token,
		   keyword, keyword_entry, found);
  if found
  then process_keyword(keyword, keyword_entry, scanned, token)
  else process_freeword(header, scanned, token)
end (* process_token *) ;



(***************************  commandscan  ******************************)
(*									*)
(*			     check_sub_commands				*)
(*									*)
(*      Check to be sure there is one and only one sub command.		*)
(*									*)
(************************************************************************)

procedure check_sub_commands(
      header	: command_definition;
  var scanned	: scanned_command) ;

begin
  argument_scan.find_keyword(
    0, header.subcommand_count-1, scanned, scanned.subcommand)
end (* check_sub_commands *) ;
!
(*****************************  commandscan  ****************************)
(*									*)
(*			    initialize_scanned_command			*)
(*									*)
(************************************************************************)

procedure initialize_scanned_command(var scanned : scanned_command);

var
  i: command_line_text_index;

begin
  for i := 0 to scanned.input_line.size-1 do
    if ('a' <= scanned.input_line.text[i]) and
       (scanned.input_line.text[i] <= 'z')
    then
      scanned.input_line.text[i] :=
	chr(ord(scanned.input_line.text[i])-32);

  scanned.status := CMD_OK;
  scanned.error_column := 0;
  scanned.keyword_count := 0;
  scanned.keyword_present := [];
  scanned.freeword_count := 0;

  argument_scan.reset_argument_check
end (* initialize_scanned_command *) ;



(*****************************  commandscan  ****************************)
(*									*)
(*			     scan_command_line				*)
(*									*)
(*      Routine to scan input string (inline) in crec and return	*)
(*	command information in crec.					*)
(*									*)
(************************************************************************)

procedure entry scan_command_line(
      command_context	: context_set;
  var scanned		: scanned_command);

var
  found  : boolean;
  header : command_definition;
  token  : command_token;

begin
  initialize_scanned_command(scanned) (* clear values *) ;
  token.finish := 0;

  find_token(scanned, token, found);
  if not found
  then scanned.status := NO_CMD (* no command *) ;

(* Lookup string in command table *)

  if scanned.status = CMD_OK
  then
    begin
      def.find_command(command_context, scanned, token, header, found);
      if not found
      then scanned.status := CMD_ERROR
    end;

(* Pick up each token and call process_token to identify it	*)
(* as a keyword or a freeword.					*)

  if scanned.status = CMD_OK
  then
    repeat
      find_token(scanned, token, found);
      if found
      then process_token(header, scanned, token)
    until (scanned.status <> CMD_OK) or not found;

  if scanned.status = CMD_OK
  then
    if header.subcommand_count > 0
    then check_sub_commands(header, scanned)
end (* scan_command_line *) ;
!
(***************************  commandscan  ******************************)
(*									*)
(*			   scan_help_command				*)
(*									*)
(*	Search for the command that is the first freeword in scanned.	*)
(*	Return classname.						*)
(*									*)
(************************************************************************)

procedure entry scan_help_command(
      command_context	: context_set;
  var scanned		: scanned_command);

var
  header : command_definition;
  token: command_token;
  found: boolean;

begin
  token := scanned.freeword_value[0];
  def.find_command(command_context, scanned, token, header, found);
  if not found
  then scanned.status := ARG_ERROR
end (* scan_help_command *) ;
!
(************************************************************************)
(*									*)
(*			initialize commandscan class			*)
(*									*)
(************************************************************************)

begin
end (* command_scanner *) ;
!
(************************************************************************)
(*									*)
(*	CMDERR.NTC							*)
(*									*)
(*			command_error_message				*)
(*									*)
(*	This class contains all command error message processing.	*)
(*	It will handle all command_scan_state messages except		*)
(*	CMD_OK, NO_CMD and RUN_ERROR. The first two because there is	*)
(*	nothing to print and the last which implies that the message	*)
(*	has already been displayed.					*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scan_state
(*	  scanned_command						*)
(*									*)
(************************************************************************)
(*									*)
(*	                     Revision Record                            *)
(*									*)
(*	20Sep83	Original -- rer						*)
(*									*)
(************************************************************************)


type
  command_error_message =
    class(
      user_terminal		: circuit_handler;
      format			: internal_to_string
    );
!
(************************  command_error_message  ***********************)
(*									*)
(*			   display_command_error			*)
(*									*)
(*	Display the appropriate command scanning error.			*)
(*									*)
(************************************************************************)


procedure entry display_command_error(
  scanned	: scanned_command);

begin
  if scanned.status <> CMD_OK
  then
    begin
      format.start;
      if (scanned.status = NO_FREEWORD) or (scanned.status = INV_KEYWORD)
      then
	begin
	  format.skip_to(scanned.error_column+scanned.prompt.size);
	  format.character('^');
	  format.newline
	end;

      case scanned.status of
	CMD_OK, NO_CMD, RUN_ERROR: (* no message *) ;

	AUTH_ERROR:
	  format.string('do not have proper authorization\ ');
	CMD_ERROR:
	  format.string('invalid command\');
	BREAK_ERROR:
	  format.string('break char missing\ ');
	NO_FREEWORD:
	  format.string('invalid input\');
	INV_KEYWORD:
	  format.string('invalid operand\');
	ARG_ERROR:
	  format.string('invalid argument\ ');
	ARG_MISSING:
	  format.string('argument missing\ ');
	ARG_SYSTEM_ERROR:
	  format.string('Program error scanning command\ ');
	TOO_MANY_ARGS:
	  format.string('Too many command arguments\ ');
	ARG_NUMBER_TOO_LARGE:
	  format.string('Number too large\ ');
	ARG_ZERO_NOT_ALLOWED:
	  format.string('Zero illegal for argument\');
	ARG_NOT_QUOTED_TEXT:
	  format.string('Argument not quote text\');
	ARG_FREEWORD_MISSING:
	  format.string('Parameter missing\');
	ARG_NULL_QUOTED_TEXT:
	  format.string('Empty quoted string not allowed\');
	ARG_NOT_FOUR_CHARS:
	  format.string('Quote string must be four characters\ ');
	ARG_NOT_HEX_BYTE:
	  format.string('Number not hex byte\')
      end (* case *) ;
      format.write_line(user_terminal)
    end
end (* display_command_error *) ;
!
(************************  command_error_message  ***********************)
(************************************************************************)

begin (* initial statement *) 
end (* command_error_message *) ;
  !
(************************************************************************)
(*									*)
(*	GLBCMD.TDR							*)
(*									*)
(*				global_commands 			*)
(*									*)
(*	This class contains the global commands which should be 	*)
(*	accessable from all contexts.					*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  operator_log							*)
(*	  argument_scanner, scanned_command				*)
(*	  command_scanner, operator_messages				*)
(*	  log_message, oper_log_page_index				*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	20Sep83 Original -- rer						*)
(*									*)
(************************************************************************)


type
  global_commands =
    class(
      user		: tdr_user_index;
      user_terminal	: circuit_handler;
      argument_scan	: argument_scanner;
      format		: internal_to_string;
      command_scan	: command_scanner;
      scan_error	: command_error_message
    );
!
(*			LOG command routines				*)



(**************************  global_commands  ***************************)
(*									*)
(*			      scan_command	 			*)
(*									*)
(*	Parse and execute the global command just entered.		*)
(*									*)
(************************************************************************)


procedure entry scan_command(
  var scanned	: scanned_command);

begin
  case scanned.command of

    GLOBAL_DATE:
      begin
	format.start;
	format.time(realtime);
	format.write_line(user_terminal)
      end (* GLOBAL_DATE *) ;

    GLOBAL_HELP:
      scanned.status := CMD_ERROR;

    GLOBAL_MESSAGE:
      scanned.status := CMD_ERROR;

    GLOBAL_VERSION:
      begin
    	format.simple_message('TMDM version \');
	format.scaled_number(version*100+revision, 10, 2);
	format.skip(2);
	format.string(date_of_update);
	format.write_line(user_terminal)
      end (* GLOBAL_VERSION *)

  end (* case *) ;

  scan_error.display_command_error(scanned)

end (* scan_command *) ;



(***************************  global_commands  **************************)
(************************************************************************)

begin (* initial statement *)
end (* global_command *) ;
!
(************************************************************************)
(*									*)
(*	CMDLP.TDR							*)
(*									*)
(*				command_loop				*)
(*									*)
(*	This class is contains the command loop for all command input.	*)
(*	It is called to request a command in the context which it	*)
(*	maintains. It prompts for a command and handles all global	*)
(*	command processing, i.e. commands to be recognized in all	*)
(*	contexts which do not do a context switch. It returns when	*)
(*	either it scans a command not in the global context or when	*)
(*	the circuit is lost. The caller must be able to handle any	*)
(*	command returned. This is accomplished by manipulating the	*)
(*	context.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  user_index, command_table					*)
(*	  scanned_command						*)
(*	  command_scanner						*)
(*									*)
(************************************************************************)
(*									*)
(*	                     Revision Record                            *)
(*									*)
(*	20Sep83	Original -- rer						*)
(*									*)
(************************************************************************)


type
  command_loop =
    class(
      user	 	: tdr_user_index;
      user_terminal	: circuit_handler;
      argument_scan	: argument_scanner;
      format		: internal_to_string;
      command_scan	: command_scanner;
      scan_error	: command_error_message;
      commands		: command_table
    );

var
  context : context_set;
  global  : global_commands;
!
(***************************  command_loop  *****************************)
(*									*)
(*			      	add_class				*)
(*									*)
(*	Add a command class to the 'context' used to determine which	*)
(*	commands are recognized by the command scanned.			*)
(*									*)
(************************************************************************)


procedure entry add_class(command_class : command_class_index);

begin
  context := context or [command_class]
end (* add_class *);



(***************************  command_loop  *****************************)
(*									*)
(*			       remove_class				*)
(*									*)
(*	Remove a command class to the 'context' used to determine which	*)
(*	commands are recognized by the command scanned.			*)
(*									*)
(************************************************************************)


procedure entry remove_class(command_class : command_class_index);

begin
  context := context - [command_class]
end (* remove_class *);
!
(***************************  command_loop  *****************************)
(*									*)
(*			      check_break				*)
(*									*)
(*  Perform break key processing					*)
(*									*)
(************************************************************************)


procedure check_break;

begin
  while user_terminal.break_pending do
    begin
      user_terminal.clear_break_status;
      user_terminal.write_quoted_text_line('<break>\')
    end (* while *)
end (* check_break *);




(***************************  command_loop  *****************************)
(*									*)
(*			      prompt_read				*)
(*									*)
(*  Put a prompt out to the terminal and get input back.		*)
(*									*)
(************************************************************************)

procedure prompt_read(
  var scanned : scanned_command);

begin
  user_terminal.write_newline;
  user_terminal.write_command_prompt(scanned.prompt);
  user_terminal.read_command_line(scanned.input_line)
end (* prompt_read *);



(***************************  command_loop  *****************************)
(*									*)
(*			      get_command				*)
(*									*)
(*	this is where all commands are read. It prompts for a command,	*)
(*	and filters out global commands and only returns with a well	*)
(*	scanned non global command from the cuurent context, or when	*)
(*	the user terminal is lost.					*)
(*									*)
(************************************************************************)


procedure entry get_command(
  var scanned	: scanned_command) ;

var
  found		: boolean (* TRUE if non global command found *) ;

begin
  commands.get_prompt(context, scanned);
  repeat
    repeat
      check_break;
      if user_terminal.sendable
      then prompt_read(scanned)
    until not user_terminal.break_pending;

    found := FALSE;
    if user_terminal.available
    then
      begin
	command_scan.scan_command_line(context, scanned);
	if scanned.status <> CMD_OK
	then scan_error.display_command_error(scanned)
	else
	  if scanned.command_class = GLOBAL_CLASS
	  then global.scan_command(scanned)
	  else found := TRUE
      end (* if available then *)
  until found or not user_terminal.available
end (* get_command *);
!
(****************************  command_level  ***************************)
(************************************************************************)

begin (* initial statement *)
  init global(user, user_terminal, argument_scan, format, command_scan,
	      scan_error);
  context := [GLOBAL_CLASS]
end (* command_loop *) ;
!
(************************************************************************)
(*									*)
(*	FILEXT.TDR							*)
(*									*)
(*			     file_extender				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Nov83	Original -- ahm						*)
(*	 1Mar84 Replace put_703_volume_label with 			*)
(*		put_705_volume_label -- ahm				*)
(*	11Jul84 Replace put_705_volume_label with			*)
(*		put_1000_volume_label -- ahm				*)
(*	15Mar85 Modified restructure_volume_label, made 		*)
(*		current_incarnation to 6, for TMCS 10.01 		*)
(*		Added create -- ahm					*)
(*									*)
(************************************************************************)

const
  empty = 0;
  move_size = 53 (* pages every move *) ;

const
  vfdd_buffer_max   = vfdd_allocation*fd_max;
  vfdd_buffer_limit = vfdd_buffer_max - 1;

type
  vfdd_buffer_index = 0..vfdd_buffer_limit;

const
  dir_buffer_max   = dir_allocation*dir_entry_max; 
  dir_buffer_limit = dir_buffer_max - 1; 
 
type
  dir_buffer_index = 0..dir_buffer_limit;

type
  move_pages = array [1..move_size] of page;
  vfdd_pages = array [vfdd_buffer_index] of vfdd_entry;
  dir_pages = array [dir_buffer_index] of dir_entry;

type
  file_extender = 
    class(
      format		: internal_to_string;
      io_report		: disk_error;
      dsksys		: disk_system;
      user_terminal	: circuit_handler);

var
  entry label         : new_vat;
  vfdd_buffer	      : vfdd_pages;
  dir_buffer 	      : dir_pages;
  current_vfdd_index  : vfdd_buffer_index;
  current_dir_index   : dir_buffer_index;



(***************************  file_extender  ****************************)
(*									*)
(*			      move_request				*)
(*									*)
(*	Do a move_size pages read and then write.			*)
(*									*)
(************************************************************************)



procedure move_request(page_addr  : integer;
		       page_moved : integer;
		       size_varied: integer;
		       var ok     : boolean); 

var
  call_param  : disk_param;
  value_param : disk_param;
  move_buffer : move_pages;

begin
  with call_param do
    begin
      operation := disk_read;
      start_addr := page_addr;
      byte_count := page_moved*page_size
    end (* with *) ;
  value_param := call_param;
  io(move_buffer, value_param, disk, file_system_disk);
  ok := value_param.status = complete;
  if ok
  then
    begin
      with call_param do
      	begin
	  operation := disk_write;
	  start_addr := page_addr+size_varied;
	  byte_count := page_moved*page_size
	end (* with *) ;
      value_param := call_param;
      io(move_buffer, value_param, disk, file_system_disk);
      ok := value_param.status = complete;
      if not ok
      then io_report.disk_error_check(call_param, value_param)
    end
  else io_report.disk_error_check(call_param, value_param)
end (* move_request *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			      vfdd_request				*)
(*									*)
(*	Do a vfdd file read or write.					*)
(*									*)
(************************************************************************)



procedure vfdd_request(vfdd_operation: disk_operation;
		       page_address: integer;
		       var vfdd_data: vfdd_pages;
		       var ok: boolean);
var
  call_param : disk_param;
  value_param: disk_param;

begin
  with call_param do
    begin
      operation := vfdd_operation;
      start_addr := page_address;
      byte_count := vfdd_allocation*page_size
    end (* with *) ;
  value_param := call_param;
  io(vfdd_data, value_param, disk, file_system_disk);
  ok := value_param.status = complete;
  if not ok
  then io_report.disk_error_check(call_param, value_param)
end (* vfdd_request *) ;
  



(***************************  file_extender  ****************************)
(*									*)
(*			      dir_request				*)
(*									*)
(* 	Do a directory file read or write.				*)
(*									*)
(************************************************************************)



procedure dir_request(dir_operation: disk_operation;
		      page_address: integer;
		      var dir_data: dir_pages;
		      var ok: boolean);
var
  call_param : disk_param;
  value_param: disk_param;

begin
  with call_param do
    begin
      operation := dir_operation;
      start_addr := page_address;
      byte_count := dir_allocation*page_size
    end (* with *) ;
  value_param := call_param;
  io(dir_data, value_param, disk, file_system_disk);
  ok := value_param.status = complete;
  if not ok
  then io_report.disk_error_check(call_param, value_param);
end (* dir_request *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			    read_disk_header				*)
(*									*)
(*	Read in the vat, vfdd and directory into memory.		*) 
(*									*)
(************************************************************************)



procedure entry read_disk_header(var incarnation: integer);

var
  ok: boolean;

begin
  dsksys.read_page(VOLUME_LABEL_ADDR, label, ok);
  if ok
  then
    begin
      vfdd_request(disk_read, vfdd_start_address, vfdd_buffer, ok);
      if ok
      then 
	begin
	  dir_request(disk_read, dir_start_address, dir_buffer, ok);
	  if ok
	  then incarnation := label.incarnation_number
	  else user_terminal.write_quoted_text_line('Disk dir read error\')
	end
      else user_terminal.write_quoted_text_line('Disk vfdd read error\ ') 
    end
  else user_terminal.write_quoted_text_line('Disk vat read error\')
end (* read_disk_header *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			    write_disk_header				*)
(*									*)
(*	Write the vat, vfdd and directory to disk.			*)
(*									*)
(************************************************************************)



procedure entry write_disk_header;

var
  ok:boolean;

begin
  dsksys.write_page(volume_label_addr, label, ok);
  if ok
  then
    begin
      vfdd_request(disk_write, vfdd_start_address, vfdd_buffer, ok);
      if ok
      then 
	begin
	  dir_request(disk_write, dir_start_address, dir_buffer, ok);
	  if not ok
	  then user_terminal.write_quoted_text_line('Disk dir write error\ ')
	end
      else user_terminal.write_quoted_text_line('Disk vfdd write error\') 
    end
  else user_terminal.write_quoted_text_line('Disk vat write error\ ')
end (* write_disk_header *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			  restructure_volume_label			*)
(*									*)
(*	Restructure TMCS disk volume label incarnation number to 7.	*)
(*	This restructure is for TMCS 10.20				*)
(*									*)
(************************************************************************)



procedure entry restructure_volume_label(old_config: config_list);
 
begin
  label.incarnation_number      := current_incarnation;

  (* force node_mask and host_mask to be zero *)
  label.config_params.host_mask	:= 0;
  label.config_params.node_mask	:= 0;

  (*  force tymnetone parameters to be zero *)
  label.config_params.tymnet_i_tymcom_max	:= 0;
  label.config_params.tymnet_i_tymsat_max	:= 0;
  label.config_params.tymnet_i_node_configuration_max	:= 0; 

  label.config_params.host_status_message_max := 
    old_config.host_status_message_max;
  label.config_params.multiple_host_message_feature :=
    old_config.multiple_host_message_feature
end (* restructure_volume_label *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			     put_new_config				*)
(*									*)
(*	Put new configuration parameters of TMCS into volume label	*)
(*									*)
(************************************************************************)


procedure entry put_new_config(params: config_list);

begin
  label.config_params := params
end (* put_new_config *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			       update_vat				*)
(*									*)
(*	Update the volume_label.					*)
(*									*)
(************************************************************************)



procedure update_vat(size  : integer);

begin
  label.next_page_to_allocate := label.next_page_to_allocate + size
end (* update_vat *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			   update_vfdd_entries				*)
(*									*)
(*	Update vfdd entries.						*)
(*									*)
(************************************************************************)



procedure update_vfdd_entries(size  : integer;
			      length: integer);

var
  i: integer;

begin
  with vfdd_buffer[current_vfdd_index].descriptor do
    begin
      file_allocation := file_allocation+size;
      file_length := length;

$if debug
      format.simple_message('file_allo \ ');	
      format.number(file_allocation, 10);	
      format.string('file_length \ ');		
      format.number(file_length, 10);		
      format.write_line(user_terminal)		
$endif
    end;

  for i := 0 to vfdd_buffer_limit do
    with vfdd_buffer[i].descriptor do
      if file_address > vfdd_buffer[current_vfdd_index].descriptor.file_address
      then file_address := file_address+size
end (* update_vfdd_entries *) ;				      



(***************************  file_extender  ****************************)
(*									*)
(*			     delete_vfdd_entry				*)
(*									*)
(*	For a given vfdd_entry, set file_address to zero.		*)
(*									*)
(************************************************************************)



procedure delete_vfdd_entry;

begin
  vfdd_buffer[current_vfdd_index].descriptor.file_address := empty
end (* delete_vfdd_entry *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			     delete_dir_entry				*)
(*									*)
(*	For a given vfdd_entry, set nameto null.			*)
(*									*)
(************************************************************************)



procedure delete_dir_entry;

begin
  dir_buffer[current_dir_index].name := null_identifier
end (* delete_vfdd_entry *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			        dir_lookup				*)
(*									*)
(*	Search the directory sequentially for the given fiel name.	*)
(*									*)
(************************************************************************)



procedure dir_lookup(fname: identifier;
		     var found: boolean);

begin
  found := FALSE;
  current_dir_index := 0;
  repeat
    if dir_buffer[current_dir_index].name = fname
    then 
      begin
	current_vfdd_index := dir_buffer[current_dir_index].index;
	found := TRUE
      end
    else current_dir_index := current_dir_index + 1
  until found or (current_dir_index > dir_buffer_limit)
end (* dir_lookup *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			  get_file_information				*)
(*									*)
(*	Return file address and file length of the given file name.	*)
(*									*)
(************************************************************************)


procedure entry get_file_information(
      file_name  : identifier;
  var file_addr  : integer;
  var file_length: integer;
  var ok         : boolean);

begin
  dir_lookup(file_name, ok);
  if ok
  then 
    begin
      file_addr	  := vfdd_buffer[current_vfdd_index].descriptor.file_address;
      file_length := vfdd_buffer[current_vfdd_index].descriptor.file_length
    end
end (* get_file_information *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			    find_free_vfdd_slot				*)
(*									*)
(*	Search vfdd_buffer for a free slot (file_address is 0), if	*)
(*	found, return the index.					*)
(*									*)
(************************************************************************)


procedure find_free_vfdd_slot(
  var index	: vfdd_buffer_index;
  var found	: boolean);

begin
  found := FALSE;
  current_vfdd_index := 0;
  repeat
    if vfdd_buffer[current_vfdd_index].descriptor.file_address = EMPTY
    then
      begin
	index := current_vfdd_index;
	found := TRUE
      end
    else
      current_vfdd_index := current_vfdd_index + 1
  until found or (current_vfdd_index > VFDD_BUFFER_LIMIT);
  if not found
  then user_terminal.write_quoted_text_line('Vfdd allocation limit\')
end (* find_free_vfdd_slot *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			        enter_vat				*)
(*									*)
(*	If has sufficient pages for creating a new file, then return	*)
(*	new file starting address and update disk volume label.		*)
(*									*)
(************************************************************************)


procedure enter_vat(
      count	: integer;
  var first_page: integer;
  var ok	: boolean);

begin
  ok := FALSE;
$if debug
  format.simple_message('erlog file length in pages: \ ');
  format.number(count, 10);
  format.write_line(user_terminal);
  format.simple_message('next page to allocate: \');
  format.number(label.next_page_to_allocate, 10);
  format.write_line(user_terminal);
  format.simple_message('volume pages: \ ');
  format.number(label.pages_on_this_volume, 10);
  format.write_line(user_terminal);
$endif

  if (label.next_page_to_allocate + count) > label.pages_on_this_volume
  then user_terminal.write_quoted_text_line('Vat disk full\')
  else
    begin
      first_page := label.next_page_to_allocate;
      label.next_page_to_allocate := label.next_page_to_allocate + count;
      ok := TRUE
    end
end (* enter_vat *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			       enter_vfdd				*)
(*									*)
(*	If VAT has room then allocate a free vfdd slot and update	*)
(*	this vfdd slot.							*)
(*									*)
(************************************************************************)


procedure enter_vfdd(
      allocation: integer;
  var index	: vfdd_buffer_index;
  var ok	: boolean);

var
  desc	 : file_descriptor;
  address: integer;

begin
  find_free_vfdd_slot(index, ok);
  if ok
  then
    begin
      enter_vat(allocation, address, ok);
      if ok
      then
	begin
	  desc.file_address	:= address;
	  desc.file_allocation	:= allocation;
	  desc.file_length	:= 0;
	  vfdd_buffer[index].descriptor := desc;
	  vfdd_buffer[index].creation_date_and_time := realtime
	end
    end
end (* enter_vfdd *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			     enter_directory				*)
(*									*)
(*	Search a empty directory slot, update this slot with new	*)
(*	file name and it's vfdd index.					*)
(*									*)
(************************************************************************)


procedure enter_directory(
      name   : identifier;
      index  : vfdd_buffer_index;
  var found  : boolean);

begin
  found := FALSE;
  current_dir_index := 0;
  repeat
    if dir_buffer[current_dir_index].name = NULL_IDENTIFIER
    then 
      begin
	dir_buffer[current_dir_index].name  := name;
	dir_buffer[current_dir_index].index := index;
	found := TRUE
      end
    else current_dir_index := current_dir_index + 1
  until found or (current_dir_index > dir_buffer_limit);
  if not found
  then user_terminal.write_quoted_text_line('Directory allocation limit\ ')
end (* enter_directory *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			         create					*)
(*									*)
(*	Create a new file.						*)
(*									*)
(************************************************************************)


procedure entry create(
      name	: identifier;
      allocation: integer;
  var ok	: boolean);

var
  index: vfdd_buffer_index;

begin
  enter_vfdd(allocation, index, ok);
  if ok
  then
    begin 
      enter_directory(name, index, ok);
      if ok 
      then 
	begin
	  format.simple_message('Create file: \');
	  format.file_identifier(name)
	end
    end    
end (* create *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			       expand_loop				*)
(*									*)
(************************************************************************)


procedure expand_loop(
      next_address	: integer;
      end_address	: integer;
      move_pages	: integer;
  var success		: boolean);

var
  size		: integer;
  next_expand	: integer;

begin
  next_expand := next_address;
  while next_expand > end_address do
    begin
      if (next_expand - move_size) < end_address
      then size := next_expand - end_address
      else size := move_size;
      next_expand := next_expand - size;
      move_request(next_expand, size, move_pages, success)
    end
end (* expand_loop *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			          expand				*)
(*									*)
(*	Expand the file allocation on the disk. Relocate the affected	*)
(*	files to the new locations backwards. 				*)
(*									*)
(************************************************************************)



procedure expand(
      changes: integer;
  var success: boolean);

var
  last_address	: integer;
  expand_start	: integer;

begin
  last_address := label.next_page_to_allocate;
  expand_start := vfdd_buffer[current_vfdd_index].descriptor.file_address+
    vfdd_buffer[current_vfdd_index].descriptor.file_allocation;

$if debug
  format.simple_message('expand start \');	
  format.number(expand_start, 10);		
  format.write_line(user_terminal);		
$endif
  expand_loop(last_address, expand_start, changes, success)
end (* expand *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			       shrink_loop				*)
(*									*)
(************************************************************************)


procedure shrink_loop(
      next_address	: integer;
      end_address	: integer;
      move_pages	: integer;
  var success		: boolean);

var
  size		: integer;
  next_shrink	: integer;

begin
  next_shrink := next_address;
  while next_shrink < end_address do
    begin
      if (next_shrink + move_size) > end_address
      then size := end_address - next_shrink
      else size := move_size;
      move_request(next_shrink, size, move_pages, success);
      next_shrink := next_shrink + size
    end
end (* shrink_loop *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			         shrink					*)
(*									*)
(*	Contract the file allocation on the disk. Relocate the affected	*)
(*	files to the new locations. 					*)
(*									*)
(************************************************************************)



procedure shrink(changes: integer;
		 var success: boolean);
		
var
  last_address	: integer;
  shrink_end	: integer;

begin
  last_address := vfdd_buffer[current_vfdd_index].descriptor.file_address +
    vfdd_buffer[current_vfdd_index].descriptor.file_allocation;
  shrink_end := label.next_page_to_allocate;
  shrink_loop(last_address, shrink_end, changes, success)
end (* shrink *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			     move_disk_pages				*)
(*									*)
(*	Move disk pages backwards or forwards.				*)
(*									*)
(************************************************************************)



procedure entry move_disk_pages(
      move_start	: integer;
      move_end		: integer;
      moving_pages	: integer;
  var ok		: boolean);

begin
  if moving_pages > 0
  then expand_loop(move_start, move_end, moving_pages, ok)
  else if moving_pages < 0
  then shrink_loop(move_start, move_end, moving_pages, ok)
end (* move_disk_pages *) ;

 
(***************************  file_extender  ****************************)
(*									*)
(*			      expand_profile				*)
(*									*)
(*	Expand the 'PROFILE' to the new file allocation.		*)
(*									*)
(************************************************************************)



procedure entry expand_profile(size	      : integer;
			       new_file_length: integer);

var
  success: boolean;

begin
  success := FALSE;
  if size+label.next_page_to_allocate <= label.pages_on_this_volume
  then expand(size, success);
  if success
  then
    begin
      update_vat(size);
      update_vfdd_entries(size, new_file_length);

$if debug
      format.simple_message('size \');	
      format.number(size, 10);		
      format.string('new_f_leng \');	
      format.write_line(user_terminal)	
$endif

    end
end (* expand_profile *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			   print_directory_error			*)
(*									*)
(*	File directory does not have this file name, print error.	*)
(*									*)
(************************************************************************)


procedure print_directory_error(name: identifier);

begin
  format.start;
  format.file_identifier(name);
  format.string(' not in File Directory\ ');
  format.write_line(user_terminal)
end (* print_directory_error *) ;



(***************************  file_extender  ****************************)
(*									*)
(*			     move_operation				*)
(*									*)
(*	Move the files on the disk. This routine handles expanding,	*)
(*	contracting and deleting a file. Finally update the vfdd and	*)
(*	vat buffer. Dir buffer will be updated for deleting a file.	*)
(*									*)
(************************************************************************)



procedure entry move_operation(file_name	: identifier;
			       new_allocation	: integer;
			       new_length	: integer;
			       var file_addr	: integer;
			       var ok		: boolean);		

var
  old_allocation: integer;
  size_changed 	: integer;

begin
  dir_lookup(file_name, ok);
  if ok
  then
    begin
      file_addr := vfdd_buffer[current_vfdd_index].descriptor.file_address;

$if debug
      format.simple_message('file_addr \ ');	
      format.number(file_addr, 10);		
      format.write_line(user_terminal);		
      format.simple_message('curr_vfdd_ind \ ');	
      format.number(current_vfdd_index, 10);	
      format.write_line(user_terminal);		
$endif

      old_allocation := vfdd_buffer[current_vfdd_index].descriptor.file_allocation;
      size_changed := new_allocation - old_allocation;
      if (size_changed > 0) and (size_changed+label.next_page_to_allocate <= 
	label.pages_on_this_volume)
      then expand(size_changed, ok)
      else if (size_changed < 0)
      then shrink(size_changed, ok)
      else if (size_changed = 0)
      then ok := TRUE;
      if ok
      then
	begin
	  update_vat(size_changed);
	  update_vfdd_entries(size_changed, new_length);
	  if new_allocation = 0		(* delete a file	   *)
	  then
	    begin
	      delete_dir_entry;
	      delete_vfdd_entry
	    end
	end
    end
  else print_directory_error(file_name)
end (* move_operation *) ;


(***************************  file_extender  ****************************)
(************************************************************************)


begin
  current_vfdd_index := 0;
  current_dir_index := 0
end (* file_extender *) ;
!
(************************************************************************)
(*									*)
(*	RECON1.TDR							*)
(*									*)
(*			      reconfigure				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	31Oct83 Original -- ahm						*)
(*									*)
(************************************************************************)

type
  reconfigure =
    class(
      format		: internal_to_string;
      io_report		: disk_error;
      dsksys		: disk_system;
      user_terminal	: circuit_handler;
      extend_operator	: file_extender;
      misc_operator	: misc_utility);
!
(* new configuration parameters - newcon.tdr *)
!
(************************************************************************)
(*									*)
(*	DISFLG.TDR Updated 22-Jan-86 at 21:38 by Hueyma			*)
(*									*)
(*			     disable_flags				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	11Jul84	Original  ---  ahm					*)
(*									*)
(************************************************************************)


(*									*)
(*     Initially set all flags to disabled, users configuration         *)
(*     file will enable any that they desire.                           *)
(*									*)

$disable alarm
$disable reload
$disable condition
$disable clusternodes
$disable debug
$disable elf
$disable networkconsole
$disable background
$disable shut_link_table_maintenance
$disable old_shut_link_table
$disable multiple_shut_link_table_maintenance
$disable multiple_host_message

    UH