!
(**********************************************************************)
(* **                  PROPRIETARY INFORMATION                     ** *)
(* **                                                              ** *)
(* **  This  source  code  listing  constitutes  the proprietary   ** *)
(* **  property of MDC-TYMNET.  The recipient, by receiving this   ** *)
(* **  program listing, agrees that neither this listing nor the   ** *)
(* **  information disclosed herein nor any part thereof shall be  ** *)
(* **  reproduced or transferred to other documents or used or dis-** *)
(* **  closed to others for manufacturing or for any other purpose ** *)
(* **  except as specifically authorized in writing by MDC-TYMNET. ** *)
(* ****************************************************************** *)
(* **                   PROGRAM IDENTIFICATION                     ** *)
(* **                                                              ** *)
(* **  Version Number     : 10.20         Release Date : 10/31/86  ** *)
(* **                                                              ** *)
(* **  File Name          : TMDM10.R20                             ** *)
(* **                                                              ** *)
(* **  File Description   : Middle part of TMDM 10.20 Source       ** *)
(* **                                                              ** *)
(* **  File Abstract      : The companion files are: 		   ** *)
(* **				TMDM10.I20			   ** *)
(* **				TMDM10.F20			   ** *)
(* **                                                              ** *)
(**********************************************************************)
!
(************************************************************************)
(*									*)
(*	LOCAL.TDR Updated 16-Jan-86 at 17:56 by Hueyma			*)
(*									*)
(*			local tmcs types/definitions			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Nov83	Original -- ahm						*)
(*	11Jul84 Added constant alarm_feature and reload_feature -- ahm	*)
(*	10Jan85 Added constant multiple_host_message_feature -- ahm	*)
(*	16Jan86 Added node_mask, host_mask -- ahm			*)
(*									*)
(************************************************************************)

$if alarm
$enable condition
$endif

$ifnot alarm
$disable condition
$endif

$ifany (alarm, reload)
$enable background
$endif

const
$if alarm alarm_feature      = TRUE;
$ifnot alarm alarm_feature   = FALSE;

const
$if reload reload_feature    = TRUE;
$ifnot reload reload_feature = FALSE;

$ifnot condition
const
  threshold_condition_max    = 0;
  condition_log_length	     = 0;

$endif

$ifnot tymnetone
const
  tymnet_I_tymcom_max		  = 0;
  tymnet_I_tymsat_max		  = 0;
  tymnet_I_node_configuration_max = 0;
$endif not tymnetone


const
$if shut_link_table_maintenance  shut_link_table_feature 	= TRUE;
$ifnot shut_link_table_maintenance  shut_link_table_feature	= FALSE;

const
$if multiple_host_message multiple_host_message_feature		= TRUE;
$ifnot multiple_host_message multiple_host_message_feature	= FALSE;


(*  user parameters  *)

const
  user_limit = user_max - 1;

type user_index = 0..user_limit;

(* supervisor parameters *)

type supervisor_state = (unknown, awake, sleeping, frozen);

const
  supervisor_limit = supervisor_max-1;

type supervisor_index = 0..supervisor_limit;

(* 	The internal index for all node numbers.			*)

const
  node_max   = 1 + tymnet_ii_node_max;
  node_limit = node_max-1;

type
  node_index = 0..node_limit;

(*	The set of all node numbers.				*)

const
  node_set_max   = (node_max+basic_set_limit) div basic_set_max;
  node_set_limit = node_set_max-1;

type
  node_set_index = 0..node_set_limit;

type
  node_set = array[node_set_index] of node_subset;


(*	The internal index for hosts.				*)

const
  host_max   = host_number_max+1;
  host_limit = host_max-1;

type
  host_index = 0..host_limit;


(*	A host set for all host numbers.				*)

const
  host_set_max   = (host_max+basic_set_limit) div basic_set_max;
  host_set_limit = host_set_max-1;

type
  host_set_index = 0..host_set_limit;

type
  host_set = array[host_set_index] of host_subset;


(*	Conversion and range checking constants.			*)

$if tymnetone
const
  first_tymnet_i_tymcom       = 1;
  last_tymnet_i_tymcom        = first_tymnet_i_tymcom+tymnet_i_tymcom_max-1;
  tymnet_i_tymcom_offset      = 0;
  first_tymnet_i_tymcom_index = 1;

const
  first_tymnet_i_tymsat       = 512 (* octal 1000 *) ;
  last_tymnet_i_tymsat        = first_tymnet_i_tymsat+tymnet_i_tymsat_max-1;
  tymnet_i_tymsat_offset      = tymnet_i_tymcom_offset+
			        first_tymnet_i_tymsat-last_tymnet_i_tymcom-1;
  first_tymnet_i_tymsat_index = first_tymnet_i_tymcom_index+
				tymnet_i_tymcom_max;

const
  first_tymnet_ii_node       = 1025 (* octal 2001 *) ;
  last_tymnet_ii_node        = first_tymnet_ii_node+tymnet_ii_node_max-1;
  tymnet_ii_node_offset      = tymnet_i_tymsat_offset+
			       first_tymnet_ii_node-last_tymnet_i_tymsat-1;
  first_tymnet_ii_node_index = first_tymnet_i_tymsat_index+
			       tymnet_i_tymsat_max;
$endif tymnetone
$ifnot tymnetone
const
  first_tymnet_ii_node       = 1025 (* octal 2001 *) ;
  last_tymnet_ii_node        = first_tymnet_ii_node + tymnet_ii_node_max - 1;
  tymnet_ii_node_offset      = first_tymnet_ii_node - 1;
  first_tymnet_ii_node_index = 1;
$endif not tymnetone


(* position of host on base *)

const
  host_position_max   = 8 (* positions *) ;
  host_position_limit = host_position_max-1;

type host_position_index = 0..host_position_limit;

const
  username_limit = username_max-1;

type username_index = 0..username_limit;

const
  node_mask	= 0;
  host_mask	= 0;

!
(************************************************************************)
(*	Updated 9-Jan-86 at 10:39 by Hueyma				*)
(*									*)
(*	RECON2.TDR							*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	31Oct83 Original -- ahm						*)
(*	 1Mar84 Convert to TMDM 1.01 -- ahm				*)
(*		<> added oplog file definations				*)
(*		<> modified procedure fill_new_configuration_params,	*)
(*		   added oper_log_page_max into new config_list		*)
(*		<> added routine initial_oplog_file			*)
(*		<> fixed bug in write_host_status, so the file length	*)
(*		   is equal to file allocation				*)
(*	13Jul84 Convert to TMDM 1.03 to fit TMCS 8.00 -- ahm		*)
(*		<> added put_external_alarm				*)
(*		<> added initial_alarm_threshold			*)
(*		<> added initial_threshold_conditions			*)
(*		<> added write_threshold_conditions			*)
(*		<> added put_threshold_conditions			*)
(*		<> added initial_reload_data				*)
(*		<> added put_reload_hosts, put_reload_nodes		*)
(*		<> added put_reload_value				*)
(*		<> added write_reload_data				*)
(*	10Oct84 <> added initial_xom_host_data				*)
(*		<> added initial_background_job_file			*)
(*	11Oct84 <> added put_xom_host_entry				*)
(*		<> added write_xom_host_file				*)
(*	17Oct84 <> added initial_condition_log				*)
(*	25Oct84 <> added initial_cluster_names				*)
(*		<> added put_cluster_names				*)
(*	10Jun85 <> added put_allowed_events				*)
(*		<> added put_allowed_license				*)
(*	22Sep85 <> host_status_entry_buffer contains only the entries	*)
(*									*)
(************************************************************************)


(* user profile definitions *)

(*	This is the user license that is stored in user profile record. *) 

type
  license = (
    no_license,		p00_license,		p01_license,
    p02_license,	p10_license,		p20_license,
    upd_license,	hang_license,		who_license,
    setn_license,	setp_license,		inact_license,
    dev_license,	operator_license,	hst_license,
    grt_license,	
$if reload
    rellst_license,	relset_license,		relexe_license,
$endif reload
$if condition
    thrlst_license,	thrset_license,
$endif condition
$if alarm
    almlst_license,	almset_license,		almexe_license,
$endif alarm
$if background
    attach_license,
$endif background
$if shut_link_table_maintenance
    autolog_license,	shtlnk_license
$endif shut_link_table_maintenance
$ifnot shut_link_table_maintenance
    autolog_license
$endif
  );

const
  first_license = p00_license;
$if shut_link_table_maintenance
  last_license  = shtlnk_license;
$endif shut_link_table_maintenance
$ifnot shut_link_table_maintenance
  last_license  = autolog_license;
$endif

type license_set = set of license;


(*  Limit set definitions/declarations  *)

const

  limit_set_limit        = limit_set_max - 1;

type limit_set_index     = 0..limit_set_limit;


const
  clusion_byte_max   = 126 (* bytes *) ;
  limit_set_byte_max =
    (event_set_max+node_set_max+host_set_max)*32 +2*clusion_byte_max;
  limit_set_page_max = (limit_set_byte_max + page_limit) div page_size;
  limit_filler_max   = (limit_set_page_max*page_size)-limit_set_byte_max;

type
  limit_set_record    = 
    record
      limit_events    : event_set;
      limit_nodes     : node_set;
      limit_hosts     : host_set;
      limit_links     : clusion_list;
      limit_lines     : clusion_list;
      filler          : array [1..limit_filler_max] of char
    end  (* limit_set_record *) ;


const
  limit_set_page_limit   = limit_set_page_max - 1;

type
  limit_set_page_index   = 0..limit_set_page_limit;
  limit_set_page_buffer  = array [limit_set_page_index] of page;

(*	This is the access rights for a user. All of this		*)
(*	portion of the profile is resident when the user is logged in.	*)


const
  profile_access_byte_max =
    (symbol_text_max+4) +		(* name *)
    4+4+2+4+4+4+			(* password..line_threshold *)
    14+					(* filler_1 *)
    4+2+				(* time_zone..terminal_used *)
    (2*basic_set_max) div 8+		(* allowed_license..allowed_events *)
    limit_set_max*(symbol_text_max+4)+	(* limit_set_names *)
    (symbol_text_max+4)+		(* default_limit_set *)
    (node_set_max+host_set_max)*32	(* allowed_nodes..allowed_hosts *) ;

const
  profile_access_page_max =
    (profile_access_byte_max+page_limit) div page_size;

const
  filler_2_max = profile_access_page_max*page_size-profile_access_byte_max;


type
  profile_access =
    record
      header	  	  : profile_access_header;
      allowed_license	  : license_set;
      allowed_events	  : main_event_subset;
      limit_set_names     : array [limit_set_index] of symbol;
                            (*  name of initial login/default limit set  *)
      default_limit_set   : symbol;
      filler_2            : array[1..filler_2_max] of char;
      allowed_nodes       : node_set (* nodes accessable by user *) ;
      allowed_hosts       : host_set (* hosts accessable by user *)
    end (* profile_access *) ;


(*	These are the ignore files.                                	*)
(*	Each consists of three files, each five pages long.		*)
(*	Each file contains a node_set, host_set, event_set and   	*)
(*	two clusion_list's for lines and links.				*)

type
  profile_ignore =
    record
      limit_sets : array [limit_set_index] of limit_set_record
    end (* profile_ignore *) ;

const
  profile_ignore_page_max   = limit_set_max*limit_set_page_max (* pages *) ;


$if alarm
(*	These are the user alarms.					*)
(*	Each consists of one external_alarm and 			*)
(*	threshold_condition_max number of conditions.			*)

type
  external_alarm_system =
    record
      host		: host_index;
      address		: integer
    end (* external_alarm_system *) ;

const
  profile_alarm_byte_max =
    4 +					(* host number *)
    4 					(* host sub address *) ;

const
  profile_alarm_page_max   =
    (profile_alarm_byte_max + page_limit) div page_size;

  profile_alarm_page_limit = profile_alarm_page_max - 1;

type
  profile_alarm_page_index = 0..profile_alarm_page_limit;

const
  alarm_filler_max =
    profile_alarm_page_max*page_size - profile_alarm_byte_max;

type
  profile_alarm_record =
    record
      alarm_data: external_alarm_system;
      filler	: array [1..alarm_filler_max] of char
    end (* profile_alarm_record *) ;

type
  profile_alarm_page_buffer =
    array [profile_alarm_page_index] of page;
$endif


(*	This is a complete profile record as it appears on the disk.	*)
(*	It must consist of an integral number of disk pages and hence	*)
(*	each field must also be integral.				*)

type
  profile_record_705 =
    record
      access: profile_access;
      colors: profile_color;
      ignore: profile_ignore
    end (* profile_record_705 *) ;

type
  profile_record =
    record
      original_profile_record: profile_record_705
$if alarm
;     alarms		     : profile_alarm_record
$endif
    end (* profile_record *) ;

const
  profile_record_page_max_705   =
    profile_access_page_max+profile_color_page_max+profile_ignore_page_max;
  profile_record_page_limit_705 = profile_record_page_max_705 - 1;

const
  profile_record_page_max   	= profile_record_page_max_705
$if alarm
    +profile_alarm_page_max
$endif
    ;

const
  profile_record_page_limit = profile_record_page_max - 1;

type profile_record_page_index = 0..profile_record_page_limit;

type profile_record_page_buffer = array [profile_record_page_index] of page;



!

(* node_names_file *)

const
  node_name_page_page_max   = (node_max+name_page_limit) div name_page_max;
  node_name_page_page_limit = node_name_page_page_max-1;

type 
  node_name_page_page_index = 0..node_name_page_page_limit;



(* host_names_file *)
 
const
  host_name_page_page_max   = (host_max+name_page_limit) div name_page_max;
  host_name_page_page_limit = host_name_page_page_max-1;

type 
  host_name_page_page_index = 0..host_name_page_page_limit;



(* probe_passwords_file *)

const
  password_page_max   = 
    (supervisor_max+page_password_limit) div page_password_max;
  password_page_limit = password_page_max-1;
    
type password_page_index = 0..password_page_limit;
  

(* remote_down_file *)

type
  remote_greeting_entry =
    record
      key: integer (* node and slot numbers packed *) ;
      kernel_host: host_index;
      start_time: integer (* time entry was set *) ;
      clear_time: integer (* time entry should be cleared *)
    end (* remote_greeting_entry *) ;

type 
  remote_down_page = array[remote_greeting_entry_index] of remote_greeting_entry;


(* host_bucket_file *)

const
  host_bucket_page_max   = host_max div bucket_entry_max;
  host_bucket_page_limit = host_bucket_page_max - 1;
  host_location_max	 = host_bucket_page_max*bucket_entry_max;
  host_location_limit	 = host_location_max - 1;

type
  host_bucket_page_index = 0..host_bucket_page_limit;
  host_location_index	 = 0..host_location_limit;

type 
  bucket_entry	=
    record
      node	: node_index;
      host	: host_index;
      position	: host_position_index;
      time	: integer
    end (* bucket_entry *) ;

type host_bucket_page	= array [bucket_entry_index] of bucket_entry;


(* host_status_file *)

const
$if multiple_host_message
  host_status_entry_max   = 4 (* host_status_entry's in a page *) ;
$endif multiple_host_message
$ifnot multiple_host_message
  host_status_entry_max   = 8 (* host_status_entry's in a page *) ;
$endif not multiple_host_message
  host_status_entry_limit = host_status_entry_max - 1;

  entry_page_max	=
    (host_status_message_max+host_status_entry_limit) div host_status_entry_max;
  entry_page_limit	= entry_page_max - 1;

type
  host_status_entry_index	= 0..host_status_entry_limit;
  entry_page_index		= 0..entry_page_limit;

const
  host_status_text_page_max   = entry_page_max*host_status_entry_max;
  host_status_text_page_limit = host_status_text_page_max-1;

type
  host_status_text_page_index = 0..host_status_text_page_limit;

const
$if multiple_host_message
  filler_limit = 23-(2*supervisor_max);
$endif multiple_host_message
$ifnot multiple_host_message
  filler_limit = 15-(2*supervisor_max);
$endif not multiple_host_message

type
  host_status_entry =
    record
      host_number	: host_index;
      start_time	: integer (* time entry was set *) ;
      clear_time	: integer (* time entry should be cleared *);
      operation		: array[supervisor_index] of sup_host_status_operation;
      size		: host_text_size;
$if multiple_host_message
      msg_active	: boolean;
      msg_name		: symbol;
      clear_state	: clear_operation;
$endif multiple_host_message
      filler		: array [0..filler_limit] of char 
    end (* host_status_entry *) ;

type 
  host_status_page = array[host_status_entry_index] of host_status_entry;


(* oplog_file *)

const
  oper_log_page_limit = oper_log_page_max - 1;

type
  oper_log_page_index = 0..oper_log_page_limit;

type
  oper_log_entry  =
    record
      sequence  : integer;
      time	: integer;
      kind	: license;
      message	: log_message
    end (* oper_log_entry *) ;

$if condition
(* threshold_condition_file *)

const
  threshold_condition_limit = threshold_condition_max - 1;

type
  threshold_condition_index = 0..threshold_condition_limit;
$endif			       


$if reload
(* reload_data_file *) 

const
  bytes_per_reload_data	  = 12 (* 3 integers *);

  reload_node_and_host_set_byte_max =
    (node_set_max + host_set_max) * bytes_per_basic_set;

  reload_outage_value_byte_max	    = 2 * bytes_per_reload_data;

  reload_data_page_max    = 
    (reload_node_and_host_set_byte_max + reload_outage_value_byte_max +
    page_limit) div page_size;
  
  reload_data_page_limit  = reload_data_page_max - 1;

  reload_filler_size	  =
    page_size - ((reload_node_and_host_set_byte_max + 
    reload_outage_value_byte_max) mod page_size);

  reload_filler_limit	  = reload_filler_size - 1;

type
  reload_filler_index	  = 0..reload_filler_limit;

type
  redata_page_index  = 0..reload_data_page_limit;

type
  reload_data_file        = array [reload_data_page_index] of page;


type
  reload_data_record =
    record
      reload_hosts	: host_set;
      reload_nodes	: node_set;
      reload_value	: reload_outage_value;
      filler		: array [reload_filler_index] of char
    end (* reload_data_record *) ;  

$endif

$if reload
(*  xom_host_file  *)

const
  xom_host_page_max	= 
    (HOST_CONFIGURATION_MAX + xom_host_entry_limit) div xom_host_entry_max;
  xom_host_page_limit	= xom_host_page_max - 1;
  xom_entry_max		= xom_host_page_max * xom_host_entry_max;
  xom_entry_limit	= xom_entry_max - 1;

type
  xom_host_page_index	= 0..xom_host_page_limit;
  xom_entry_index	= 0..xom_entry_limit;

type
  xom_host_entry =
    record
      host		: host_index;
      node		: node_index;
      mxp		: mxp_index;
      slot_restore	: integer
    end (* xom_host_entry *) ;

type
  xom_host_page = array [xom_host_entry_index] of xom_host_entry;
$endif


(*  cluster_names_file  *)

const
  cluster_name_page_max		=
    (NODE_MAX + cluster_entry_limit) div cluster_entry_max;
  cluster_name_page_limit	= cluster_name_page_max - 1;

type
  cluster_name_page_index	= 0..cluster_name_page_limit;


$ifany (alarm, reload)
(*  background_job_file  *)

const
  terminal_unit_max   = user_max;
  terminal_unit_limit = terminal_unit_max-1;

const
  no_terminal_unit = -1;

type
  terminal_unit_indicator = no_terminal_unit..terminal_unit_limit;

type
  job_descriptor =
    record
      state	: job_state;
      unit	: terminal_unit_indicator;
      username	: symbol
    end (* job_descriptor *) ;

const
  filler_size = page_size-job_descriptor_entry_max*job_descriptor_byte_max;

type job_descriptor_page =
  record
    data	: array[job_descriptor_entry_index] of job_descriptor;
    filler	: array[1..filler_size] of char
  end (* job_descriptor_page *) ;

const
  job_descriptor_page_max =
    (user_max + job_descriptor_entry_limit) div job_descriptor_entry_max;
  job_descriptor_page_limit = job_descriptor_page_max - 1;

type
  job_descriptor_page_index = 0..job_descriptor_page_limit;

$endif
$if condition
(*  condition_log  *)

const
  condition_log_page_max   =
    (condition_log_length+condition_log_page_item_limit) div
      condition_log_page_item_max;
  condition_log_page_limit = condition_log_page_max-1;

type
  condition_log_page_index = 0..condition_log_page_limit;

$endif

var
  entry config	        	: config_list;
  current_buffer_index 		: integer;
  new_profile_record		: profile_record;
  node_name_page		: name_page;
  host_name_page		: name_page;
  probe_password_page		: password_page;
  remote_page			: remote_down_page;
  bucket_page			: host_bucket_page;
  host_status_entry_page	: host_status_page;
  host_status_text_start	: integer;

$if condition threshold_cond_page: threshold_condition_page;

$if reload 
  reload_data_buffer	: reload_data_record;
  xomhost_page		: xom_host_page;
$endif
  cluster_name_page	: cluster_page;

		     
(****************************  reconfigure  *****************************)
(*									*)
(*			     node_range_check				*)
(*									*)
(*	Check that argument is a legal node number.			*)
(*									*)
(************************************************************************)



function node_range_check(node: integer): boolean;

begin
  if (FIRST_TYMNET_II_NODE <= node) and (node <= LAST_TYMNET_II_NODE)
  then node_range_check := TRUE
  else node_range_check := FALSE
end (* node_range_check *) ;



(***************************  reconfigure  ****************************)
(*                                                                    *)
(*                          host_range_check                          *)
(*                                                                    *)
(*    Check that argument is a legal host_index.                      *)
(*                                                                    *)
(**********************************************************************)



function host_range_check(host: integer): boolean;

begin
  host_range_check := (0 < host) and (host <= HOST_NUMBER_MAX)
end (* host_range_check *) ;



(***************************  reconfigure  ****************************)
(*                                                                    *)
(*                           encode_node                              *)
(*                                                                    *)
(*    Extract a node number from an integer and convert to internal   *)
(*    form. If invalid, return node_index of 0.			      *)
(*                                                                    *)
(**********************************************************************)


function encode_node(node: integer): node_index;

begin
  if (FIRST_TYMNET_II_NODE <= node) and (node <= LAST_TYMNET_II_NODE)
  then encode_node := node-TYMNET_II_NODE_OFFSET
  else encode_node := 0
end (* encode_node *) ;



(***************************  reconfigure  ****************************)
(*                                                                    *)
(*                           decode_node                              *)
(*                                                                    *)
(*    Convert a node_index to external representation.		      *)
(*                                                                    *)
(**********************************************************************)


function decode_node(node: node_index): integer;

begin
  if node >= FIRST_TYMNET_II_NODE_INDEX
  then decode_node := node+TYMNET_II_NODE_OFFSET
  else decode_node := 0
end (* decode_node *) ;



(***************************  reconfigure  ****************************)
(*                                                                    *)
(*                           encode_host                              *)
(*                                                                    *)
(*    Extract a host number from an integer and convert to internal   *)
(*    form. If invalid, return host_index of 0.			      *)
(*                                                                    *)
(**********************************************************************)


function encode_host(host: integer): host_index;

begin
  if host <= HOST_NUMBER_MAX
  then encode_host := host
  else encode_host := 0
end (* encode_host *) ;



(****************************  reconfigure  ***************************)
(*                                                                    *)
(*                              add_node                              *)
(*                                                                    *)
(*    Add node_index to node_set.                                     *)
(*                                                                    *)
(**********************************************************************)



procedure add_node(node: node_index; var new_set: node_set);

var
  i: node_set_index;

begin
  i := node div node_subset_max;
  new_set[i] := new_set[i] or [node mod node_subset_max]
end (* add_node *) ;



(****************************  reconfigure  ***************************)
(*                                                                    *)
(*                              add_host                              *)
(*                                                                    *)
(*    Add host_index to host_set.                                     *)
(*                                                                    *)
(**********************************************************************)



procedure add_host(host: host_index; var new_set: host_set);

var
  i: host_set_index;

begin
  i := host div host_subset_max;
  new_set[i] := new_set[i] or [host mod host_subset_max]
end (* add_host *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*		     fill_new_configuration_params			*)
(*									*)
(*	Put new configuration parameters into a record.			*)
(*									*)
(************************************************************************)


procedure fill_new_configuration_params;

begin
  config.user_max := user_max;
  config.username_max := username_max;
  config.limit_set_max 			 := limit_set_max;
  config.user_message_max 		 := user_message_max;
  config.supervisor_max 		 := supervisor_max;
  config.node_configuration_max 	 := node_configuration_max;
  config.tymnet_i_node_configuration_max := tymnet_i_node_configuration_max;
  config.host_configuration_max 	 := host_configuration_max;
  config.host_mask		 	 := host_mask;
  config.links_per_node 		 := links_per_node;      
  config.ports_per_node 		 := ports_per_node;
  config.link_shut_percentage 		 := link_shut_percentage;
  config.port_out_percentage 		 := port_out_percentage;
  config.tymnet_i_tymcom_max 		 := tymnet_i_tymcom_max;
  config.tymnet_i_tymsat_max 		 := tymnet_i_tymsat_max;
  config.tymnet_ii_node_max 		 := tymnet_ii_node_max;
  config.node_mask		 	 := node_mask;
  config.host_number_max 		 := host_number_max;
  config.oper_log_page_max 		 := oper_log_page_max;
  config.reload_feature 		 := reload_feature;
  config.alarm_feature 			 := alarm_feature;
  config.threshold_condition_max 	 := threshold_condition_max;
  config.condition_log_length 		 := condition_log_length;
  config.shut_link_table_feature 	 := shut_link_table_feature;
  config.host_status_message_max	 := host_status_message_max;
  config.multiple_host_message_feature	 := multiple_host_message_feature
end (* fill_new_configuration_params *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*		     	put_new_label_new_config			*)
(*									*)
(*	Put new configuration parameters in in-core new volume_label.	*)
(*									*)
(************************************************************************)



procedure entry put_new_label_new_config;


begin
  extend_operator.put_new_config(config)
end (* put_new_config_label *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			  write_profile_record				*)
(*									*)
(*	Write profile record to disk.					*)
(*									*)
(************************************************************************)



procedure write_profile_record(address: integer);

var
  call_param  : disk_param;
  value_param : disk_param;
  faddr	      : integer;
  length      : integer;
  ok	      : boolean;

begin

$if debug
  format.simple_message('write_addr \');	
  format.number(address, 10);			
  format.write_line(user_terminal);		
$endif

  extend_operator.get_file_information('PROFILES', faddr, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := faddr+address;
	  byte_count := profile_record_page_max*page_size
	end (* with *) ;
      value_param := call_param;
      io(new_profile_record, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
end (* write_profile_record *) ;




(****************************  reconfigure  *****************************)
(*									*)
(*			      write_profile				*)
(*									*)
(*	Write profile record.						*)
(*									*)
(************************************************************************)



procedure entry write_profile(sequence: username_index);

var
  rec_address: integer;

begin
  rec_address := sequence*PROFILE_RECORD_PAGE_MAX;
  write_profile_record(rec_address)
end (* write_profile *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			get_cleared_profile_record			*)
(*									*)
(*	Put zeros into the profile record.				*)
(*									*)
(************************************************************************)



procedure get_cleared_profile_record(
  var cleared_profile_record: univ profile_record_page_buffer);

var
  p: page_index;
  i: profile_record_page_index;
  buffer: page;
  
begin
  for p := 0 to page_limit do buffer[p] := chr(0);
  for i := 0 to profile_record_page_limit do
    cleared_profile_record[i] := buffer
end (* get_cleared_profile_record *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*		      initial_unused_profile_record			*)
(*									*)
(*	Initial the never used profile records.				*)
(*									*)
(************************************************************************)



procedure entry initial_unused_profile_record(
  first_unused_record: integer);

var
  i: integer;

begin
  get_cleared_profile_record(new_profile_record);
  for i := first_unused_record to username_limit do
    write_profile_record(i*PROFILE_RECORD_PAGE_MAX)
end (* initial_unused_profile_record *) ;  



(****************************  reconfigure  *****************************)
(*									*)
(*			  profile_record_length				*)
(*									*)
(*	Return the profile reord length.				*)
(*									*)
(************************************************************************)



function entry profile_record_length: integer;

begin
  profile_record_length := PROFILE_RECORD_PAGE_MAX
end (* profile_record_length *) ;


(****************************  reconfigure  *****************************)
(*									*)
(*			    put_access_header				*)
(*									*)
(*	Put access header into new profile record.			*)
(*									*)
(************************************************************************)


procedure entry put_access_header(header: profile_access_header);

begin
  get_cleared_profile_record(new_profile_record);
  new_profile_record.original_profile_record.access.header := header
end (* put_access_header *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    put_allowed_events				*)
(*									*)
(*	Put allowed_events field into profile record.			*)
(*									*)
(************************************************************************)



procedure entry put_allowed_events(events: main_event_subset);

begin
  new_profile_record.original_profile_record.access.allowed_events := events
end (* put_allowed_events *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*				force_full				*)
(*									*)
(************************************************************************)


procedure force_full(var new_set: univ basic_set);

var
  i: basic_set_index;

begin
  for i := 0 to BASIC_SET_LIMIT do
    new_set := new_set or [i]
end (* force_full *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			put_master_allowed_license			*)
(*									*)
(*	Give the master user all possible licenses.			*)
(*									*)
(************************************************************************)


procedure entry put_master_allowed_license;

begin
  force_full(new_profile_record.original_profile_record.access.allowed_license)
end (* put_master_allowed_license *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			  put_allowed_license				*)
(*									*)
(*	Put allowed_license into new profile record.			*)
(*									*)
(************************************************************************)



procedure entry put_allowed_license(license_passed_in: std_license);

begin
  with new_profile_record.original_profile_record.access do
    case license_passed_in of
      STD_NO_LICENSE	: 
	allowed_license := allowed_license or [NO_LICENSE];
      STD_P00_LICENSE	: 
	allowed_license := allowed_license or [P00_LICENSE];
      STD_P01_LICENSE	: 
	allowed_license := allowed_license or [P01_LICENSE];
      STD_P02_LICENSE	: 
	allowed_license := allowed_license or [P02_LICENSE];
      STD_P10_LICENSE	: 
	allowed_license := allowed_license or [P10_LICENSE];
      STD_P20_LICENSE	: 
	allowed_license := allowed_license or [P20_LICENSE];
      STD_UPD_LICENSE	: 
	allowed_license := allowed_license or [UPD_LICENSE];
      STD_HANG_LICENSE	: 
	allowed_license := allowed_license or [HANG_LICENSE];
      STD_WHO_LICENSE	: 
	allowed_license := allowed_license or [WHO_LICENSE];
      STD_SETN_LICENSE	: 
	allowed_license := allowed_license or [SETN_LICENSE];
      STD_SETP_LICENSE	: 
	allowed_license := allowed_license or [SETP_LICENSE];
      STD_INACT_LICENSE	: 
	allowed_license := allowed_license or [INACT_LICENSE];
      STD_DEV_LICENSE	: 
	allowed_license := allowed_license or [DEV_LICENSE];
      STD_OPERATOR_LICENSE	: 
	allowed_license := allowed_license or [OPERATOR_LICENSE];
      STD_HST_LICENSE	: 
	allowed_license := allowed_license or [HST_LICENSE];
      STD_GRT_LICENSE	: 
	allowed_license := allowed_license or [GRT_LICENSE];
      STD_RELLST_LICENSE: 
$if reload
	allowed_license := allowed_license or [RELLST_LICENSE];
$endif
$ifnot reload		(* empty *) ;
      STD_RELSET_LICENSE: 
$if reload
	allowed_license := allowed_license or [RELSET_LICENSE];
$endif
$ifnot reload		(* empty *) ;
      STD_RELEXE_LICENSE: 
$if reload
	allowed_license := allowed_license or [RELEXE_LICENSE];
$endif
$ifnot reload		(* empty *) ;
      STD_THRLST_LICENSE: 
$if condition
	allowed_license := allowed_license or [THRLST_LICENSE];
$endif
$ifnot condition	(* empty *) ;
      STD_THRSET_LICENSE: 
$if condition
	allowed_license := allowed_license or [THRSET_LICENSE];
$endif
$ifnot condition	(* empty *) ;
      STD_ALMLST_LICENSE: 
$if alarm
	allowed_license := allowed_license or [ALMLST_LICENSE];
$endif
$ifnot alarm		(* empty *) ;
      STD_ALMSET_LICENSE: 
$if alarm
	allowed_license := allowed_license or [ALMSET_LICENSE];
$endif
$ifnot alarm		(* empty *) ;
      STD_ALMEXE_LICENSE: 
$if alarm
	allowed_license := allowed_license or [ALMEXE_LICENSE];
$endif
$ifnot alarm		(* empty *) ;
      STD_ATTACH_LICENSE: 
$if background
	allowed_license := allowed_license or [ATTACH_LICENSE];
$endif
$ifnot background	(* empty *) ;
      STD_AUTOLOG_LICENSE: 
	allowed_license := allowed_license or [AUTOLOG_LICENSE];
      STD_SHTLNK_LICENSE:
$if shut_link_table_maintenance
	allowed_license := allowed_license or [SHTLNK_LICENSE]
$endif
$ifnot shut_link_table_maintenance	(* empty *)
    end (* case *) 
end (* put_allowed_license *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			  put_limit_set_names				*)
(*									*)
(*	Put limit_set_names into new profile record.			*)
(*									*)
(************************************************************************)



procedure entry put_limit_set_names(name: symbol;
				    i	: integer);

begin
  if (0 <= i) and (i <= limit_set_limit)
  then new_profile_record.original_profile_record.access.limit_set_names[i] := name
end (* put_limit_set_names *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    put_default_limit				*)
(*									*)
(*	Put default_limit_set field into profile record.		*)
(*									*)
(************************************************************************)



procedure entry put_default_limit(name: symbol);

begin
  new_profile_record.original_profile_record.access.default_limit_set := name
end (* put_default_limit *) ;


(****************************  reconfigure  *****************************)
(*									*)
(*			put_master_allowed_nodes			*)
(*									*)
(*	For a master user, set a node_set to full.			*)
(*									*)
(************************************************************************)


procedure entry put_master_allowed_nodes;

var
  i: node_set_index;
  j: node_subset_index;
  full_set: node_subset;

begin
  with new_profile_record.original_profile_record.access do
    begin
      full_set := [];
      for j := 0 to node_subset_limit do full_set := full_set or [j];
      for i := 0 to node_set_limit do allowed_nodes[i] := full_set;
      allowed_nodes[0] := allowed_nodes[0] - [0]   (* take out node 0 *)
    end
end (* put_master_allowed_nodes *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    put_profile_nodes				*)
(*									*)
(*	Put range ok node into node_set of profile record.		*)
(*									*)
(************************************************************************)



procedure entry put_profile_nodes(first    : integer;
				  set_end  : integer;
				  limit_set: integer;
				  full     : boolean);

var
  last	     : integer;
  node_number: integer;

begin
  if full
  then last := last_tymnet_ii_node
		      (* if allowed_nodes is full in old configuration *)
		      (* then it will also be full in new configuration*)
  else last := set_end;
  for node_number := first to last do
    if node_range_check(node_number)
    then 
      with new_profile_record.original_profile_record do
	begin
	  if limit_set = -1
	  then add_node(encode_node(node_number), access.allowed_nodes)
	  else if (0 <= limit_set) and (limit_set <= limit_set_limit)
	  then add_node(encode_node(node_number), 
	    ignore.limit_sets[limit_set].limit_nodes)
	end (* with *)
end (* put_profile_nodes *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    put_profile_hosts				*)
(*									*)
(*	Put range ok host into host_set of profile record.		*)
(*									*)
(************************************************************************)



procedure entry put_profile_hosts(first    : integer;
				  set_end  : integer;
				  limit_set: integer;
				  full     : boolean);


var
  last	     : integer;
  host_number: integer;

begin
  if full
  then last := host_limit
  else last := set_end;
  for host_number := first to last do
    if host_range_check(host_number)
    then 
      with new_profile_record.original_profile_record do
	begin
	  if limit_set = -1
	  then add_host(encode_host(host_number), access.allowed_hosts)
	  else if (0 <= limit_set) and (limit_set <= limit_set_limit)
	  then add_host(encode_host(host_number), 
	    ignore.limit_sets[limit_set].limit_hosts)
	end (* with *)
end (* put_profile_hosts *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    put_profile_color				*)
(*									*)
(*	Put profile color into profile record.				*)
(*									*)
(************************************************************************)



procedure entry put_profile_color(color_field: profile_color);

begin
  new_profile_record.original_profile_record.colors := color_field
end (* put_profile_color *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*		     put_limit_events_links_and_lines			*)
(*									*)
(*	Put limit_events, limit_links and limit_lines into profile 	*)
(*	record.								*)
(*									*)
(************************************************************************)



procedure entry put_limit_events_links_and_lines(events: event_set;
						 links: clusion_list;
					  	 lines: clusion_list;
					  	 set_number: integer);

begin
  if (0 <= set_number) and (set_number <= limit_set_limit)
  then
    with new_profile_record.original_profile_record.ignore.limit_sets[set_number] do
      begin
	limit_events := events;
	limit_links := links;
	limit_lines := lines
      end (* with *)
end (* put_limit_links_and_lines *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    put_external_alarm				*)
(*									*)
(*	Put user's external alarm to profile record, if external	*)
(*	alarm host is out of range then put 0s to external alarm.	*)
(*									*)
(************************************************************************)


procedure entry put_external_alarm(
  host_number: integer;
  subaddress : integer);

var
  ok: boolean;

begin
$if alarm
  ok := host_range_check(host_number);
  if ok
  then
    begin
      new_profile_record.alarms.alarm_data.host := encode_host(host_number);
      new_profile_record.alarms.alarm_data.address := subaddress
    end
  else
    begin
      new_profile_record.alarms.alarm_data.host := 0;
      new_profile_record.alarms.alarm_data.address := 0
    end
$endif
end (* put_external_alarm *) ;


(****************************  reconfigure  *****************************)
(*									*)
(*				clear_page				*)
(*									*)
(************************************************************************)


procedure clear_page(
  filename	: file_name_set);

var
  j	: integer;

begin
  case filename of
    NODESNAM :
      for j := 0 to NAME_PAGE_LIMIT do
	node_name_page.names[j].text[0] := chr(0);

    HOSTSNAM :
      for j := 0 to NAME_PAGE_LIMIT do
	host_name_page.names[j].text[0] := chr(0);

    PROBENAM :
      for j := 0 to PAGE_PASSWORD_LIMIT do
  	probe_password_page.passwords[j].size := 0;

    REMOTEDO :
      for j := 0 to REMOTE_GREETING_ENTRY_LIMIT do
	remote_page[j].key := EMPTY_KEY;

    LOCABUCK :
      for j := 0 to BUCKET_ENTRY_LIMIT do
	bucket_page[j].node := NULL_WORD;	

    HOSTSTAT :
      for j := 0 to HOST_STATUS_ENTRY_LIMIT do
	host_status_entry_page[j].host_number := EMPTY_HOST_NUMBER;

    XOMHOSTS :
$if reload
      for j := 0 to XOM_HOST_ENTRY_LIMIT do
	with xomhost_page[j] do
	  begin
	    host	:= 0;
	    node	:= 0;
	    mxp	:= 0;
	    slot_restore	:= 0
	  end
$endif
  end (* case *) 
end (* clear_page *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			   clear_node_name_file				*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'$$$NODES'. Initialize '$$$NODES' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_node_name_file;

var
  i		: node_name_page_page_index;
  address	: integer;
  ok		: boolean;

begin
  extend_operator.move_operation('$$$NODES', NODE_NAME_PAGE_PAGE_MAX,
    NODE_NAME_PAGE_PAGE_MAX, address, ok);

  clear_page(NODESNAM);

  for i := 0 to NODE_NAME_PAGE_PAGE_LIMIT do
    dsksys.write_page(address+i, node_name_page, ok)
end (* clear_node_name_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			   clear_host_name_file				*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'$$$HOSTS'. Initialize '$$$HOSTS' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_host_name_file;

var
  i		: host_name_page_page_index;
  address	: integer;
  ok		: boolean;

begin
  extend_operator.move_operation('$$$HOSTS', HOST_NAME_PAGE_PAGE_MAX,
    HOST_NAME_PAGE_PAGE_MAX, address, ok);

  clear_page(HOSTSNAM);

  for i := 0 to HOST_NAME_PAGE_PAGE_LIMIT do
    dsksys.write_page(address+i, host_name_page, ok)
end (* clear_host_name_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			 clear_probe_password_file			*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'$$$PROBE'. Initialize '$$$PROBE' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_probe_password_file;

var
  i		: password_page_index;
  address	: integer;
  ok		: boolean;

begin
  extend_operator.move_operation('$$$PROBE', PASSWORD_PAGE_MAX,
    PASSWORD_PAGE_MAX, address, ok);

  clear_page(PROBENAM);

  for i := 0 to PASSWORD_PAGE_LIMIT do
    dsksys.write_page(address+i, probe_password_page, ok)
end (* clear_probe_password_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			  clear_remote_down_file			*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'REMOTEDO'. Initialize 'REMOTEDO' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_remote_down_file;

var
  i		: remote_greeting_page_index;
  address	: integer;
  ok		: boolean;

begin
  extend_operator.move_operation(
    'REMOTEDO', REMOTE_GREETING_PAGE_MAX, 0, address, ok);

  clear_page(REMOTEDO);

  for i := 0 to REMOTE_GREETING_PAGE_LIMIT do
    dsksys.write_page(address+i, remote_page, ok)	
end (* clear_remote_down_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			  clear_host_bucket_file			*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'LOCABUCK'. Initialize 'LOCABUCK' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_host_bucket_file;

var
  i		: host_bucket_page_index;
  address	: integer;
  ok		: boolean;

begin
  extend_operator.move_operation(
    'LOCABUCK', HOST_BUCKET_PAGE_MAX, 0, address, ok);

  clear_page(LOCABUCK);

  for i := 0 to HOST_BUCKET_PAGE_LIMIT do
    dsksys.write_page(address+i, bucket_page, ok)	
end (* clear_host_bucket_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			clear_host_status_entry_file			*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'HOSTSTAT'. Initialize 'HOSTSTAT' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_host_status_entry_file(
      old_host_status_page_max	: integer;
      old_text_top		: integer;
      old_text_bottom		: integer;
      old_host_status_entry_max : integer;
  var entry_page_added		: integer);

var
  temp_new_file_allocation	: integer;
  i				: entry_page_index;
  address			: integer;
  length			: integer;
  ok				: boolean;

begin
  (* relocate files using a temporary 'HOSTSTAT' file which has a new *)
  (* host status entry portion and an old host status text portion    *)
  entry_page_added := ENTRY_PAGE_MAX - old_host_status_page_max;
  temp_new_file_allocation := 
    ENTRY_PAGE_MAX + old_host_status_page_max*old_host_status_entry_max;
  if entry_page_added > 0	(* expand *)
  then
    begin
      extend_operator.move_operation('HOSTSTAT', temp_new_file_allocation,
        temp_new_file_allocation, address, ok);
      if ok
      then extend_operator.move_disk_pages(old_text_bottom, old_text_top,
	entry_page_added, ok)
    end
  else if entry_page_added < 0	(* shrink *)
  then
    begin
      extend_operator.move_disk_pages(old_text_top, old_text_bottom,
	entry_page_added, ok);
      if ok
      then extend_operator.move_operation('HOSTSTAT', temp_new_file_allocation,
        temp_new_file_allocation, address, ok);
    end
  else (* entry_page_added = 0 *)
    extend_operator.get_file_information('HOSTSTAT', address, length, ok);

  (* initial the host_status_entry_page *)
  clear_page(HOSTSTAT);

  (* write to disk the initialized host status entry portion of 'HOSTSTAT' *)
  for i := 0 to ENTRY_PAGE_LIMIT do
    dsksys.write_page(address+i, host_status_entry_page, ok);

  host_status_text_start := old_text_top + entry_page_added
end (* clear_host_status_entry_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    initial_oplog_file				*)
(*									*)
(*	Initialize every oper_log_entry of the '$$$OPLOG' file.		*)
(*									*)
(************************************************************************)


procedure entry initial_oplog_file(file_address: integer;
				   var ok      : boolean);

var
  pi	: oper_log_page_index;
  buffer: oper_log_entry;

begin
  pi := 0;
  ok := TRUE;
  repeat
    buffer.time := MIN_INTEGER;
    buffer.sequence := pi;
    dsksys.write_page(file_address+pi, buffer, ok);
    pi := pi+1
  until (pi >= OPER_LOG_PAGE_MAX) or not ok
end (* initial_oplog_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    initial_condition_log			*)
(*									*)
(*	Initialize every condition_log_entry of the 'CONDLOG ' file.	*)
(*									*)
(************************************************************************)


procedure entry initial_condition_log(file_address: integer;
				      var ok      : boolean);
$if condition
var
  buffer: page;
  i	: integer;
  p	: condition_log_page_index;
$endif

begin
  ok := TRUE;
$if condition
  for i := 0 to PAGE_LIMIT do buffer[i] := chr(0);
  P := 0;
  repeat
    dsksys.write_page(file_address+p, buffer, ok);
    p := p + 1
  until (p >= CONDITION_LOG_PAGE_MAX) or not ok
$endif
end (* initial_condition_log *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*		      clear_threshold_condition_file			*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'THRECOND'. Initialize 'THRECOND' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_threshold_condition_file;

var
$if condition
  i		: threshold_condition_index;
$endif
  address	: integer;
  ok		: boolean;

begin
  extend_operator.move_operation('THRECOND', THRESHOLD_CONDITION_MAX,
    THRESHOLD_CONDITION_MAX, address, ok);
$if condition
  threshold_cond_page.condition_head.name.size := 0;
  for i := 0 to THRESHOLD_CONDITION_LIMIT do
    dsksys.write_page(address+i, threshold_cond_page, ok)	
$endif
end (* clear_threshold_condition_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    initial_reload_data				*)
(*									*)
(*	Initialize RELODATA file.					*)
(*									*)
(************************************************************************)



procedure entry initial_reload_data;

$if reload
var
  h: host_set_index;
  n: node_set_index;
  i: reload_filler_index;
$endif

begin
$if reload
  for h := 0 to HOST_SET_LIMIT do
    reload_data_buffer.reload_hosts[h] := [];

  for n := 0 to NODE_SET_LIMIT do
    reload_data_buffer.reload_nodes[n] := [];

  with reload_data_buffer.reload_value do
    begin
      host_reload_data.recurring_outage_maximum := 25;
      host_reload_data.recurring_outage_decay   := 60;
      host_reload_threshold := 25;
      node_reload_data.recurring_outage_maximum := 25;
      node_reload_data.recurring_outage_decay   := 60;
      node_reload_threshold := 25
    end (* with *) ;

  for i := 0 to RELOAD_FILLER_LIMIT do
    reload_data_buffer.filler[i] := chr(0)  
$endif
end (* initial_reload_data *) ;


(****************************  reconfigure  *****************************)
(*									*)
(*			   clear_xom_host_file				*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'XOMHOSTS'. Initialize 'XOMHOSTS' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_xom_host_file;

$if reload
var
  i		: xom_host_page_index;
  address	: integer;
  ok		: boolean;
$endif

begin
$if reload
  extend_operator.move_operation(
    'XOMHOSTS', XOM_HOST_PAGE_MAX, 0, address, ok);

  clear_page(XOMHOSTS);

  for i := 0 to XOM_HOST_PAGE_LIMIT do
    dsksys.write_page(address+i, xomhost_page, ok)	
$endif
end (* clear_xom_host_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			initial_background_job_file			*)
(*									*)
(*	Set background_job_file to the default background job.		*) 
(*									*)
(************************************************************************)


procedure entry initial_background_job_file(
      file_address: integer;
  var ok	  : boolean);

$ifany (alarm, reload)
var
  p: job_descriptor_page_index;
  i: job_descriptor_entry_index;
  background_job: job_descriptor;
  buffer	: job_descriptor_page;
$endif

begin
  ok:= TRUE;
$ifany (alarm, reload)
  p := 0;
  background_job.state		:= JOB_LOGIN;
  background_job.unit		:= NO_TERMINAL_UNIT;
  background_job.username.size	:= 0;
  repeat
    for i := 0 to JOB_DESCRIPTOR_ENTRY_LIMIT do
      buffer.data[i] := background_job;
    dsksys.write_page(file_address+p, buffer, ok);
    p := p + 1
  until (p >= JOB_DESCRIPTOR_PAGE_MAX) or not ok
$endif
end (* initial_background_job_file *) ;



(****************************   reconfigure  ****************************)
(*									*)
(*			       node_to_name				*)
(*									*)
(*	Convert a node number to a cluster name.			*)
(*									*)
(************************************************************************)


procedure node_to_name (
      node	: node_index;
  var name	: cluster_name);

var
  i	: cluster_name_index;

begin
  format.start;
  format.format_number (decode_node(node), 8, -4);
  
  for i := 0 to cluster_name_limit do
    name[i] := format.buffer.text[i]
end (* node_to_name *) ;


(****************************  reconfigure  *****************************)
(*									*)
(*			    clear_cluster_page				*)
(*									*)
(************************************************************************)


procedure clear_cluster_page(
  i	: cluster_name_page_index);

var
  j	: cluster_entry_index;

begin
  for j := 0 to CLUSTER_ENTRY_LIMIT do
    node_to_name(i*CLUSTER_ENTRY_MAX+j, cluster_name_page[j]);
end (* clear_cluster_page *) ;


(****************************  reconfigure  *****************************)
(*									*)
(*			 clear_cluster_name_file			*)
(*									*)
(*	Relocate following files due to the new allocation of		*)
(*	'CLSTRNAM'. Initialize 'CLSTRNAM' on disk.			*)
(*									*)
(************************************************************************)


procedure entry clear_cluster_name_file;

var
  i		: cluster_name_page_index;
  address	: integer;
  ok		: boolean;

begin
  extend_operator.move_operation('CLSTRNAM', CLUSTER_NAME_PAGE_MAX,
    CLUSTER_NAME_PAGE_MAX, address, ok);

  for i := 0 to CLUSTER_NAME_PAGE_LIMIT do
    begin
      clear_cluster_page(i);
      dsksys.write_page(address+i, cluster_name_page, ok)	
    end
end (* clear_cluster_name_file *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    write_name_page				*)
(*									*)
(*	Write name_page to disk through direct I/O.			*)
(*									*)
(************************************************************************)



procedure write_name_page(
      file_name		: identifier;
      offset		: integer; 
  var page_buffer	: name_page);

var
  address     : integer;
  length      : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;

begin
  extend_operator.get_file_information(file_name, address, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address + offset;
	  byte_count := PAGE_SIZE
	end (* with *) ;
      value_param := call_param;
      io(page_buffer, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
end (* write_name_page *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			write_probe_password_page			*)
(*									*)
(*	Write password_page to disk through direct I/O.			*)
(*									*)
(************************************************************************)



procedure write_probe_password_page(
      offset		: password_page_index);

var
  address     : integer;
  length      : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;

begin
  extend_operator.get_file_information('$$$PROBE', address, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address + offset;
	  byte_count := PAGE_SIZE
	end (* with *) ;
      value_param := call_param;
      io(probe_password_page, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
end (* write_probe_password_page *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    write_remote_page				*)
(*									*)
(*	Write remote_page to disk through direct I/O.			*)
(*									*)
(************************************************************************)



procedure write_remote_page(
      offset		: remote_greeting_page_index);

var
  address     : integer;
  length      : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;

begin
  extend_operator.get_file_information('REMOTEDO', address, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address + offset;
	  byte_count := PAGE_SIZE
	end (* with *) ;
      value_param := call_param;
      io(remote_page, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
end (* write_remote_page *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			     write_bucket_page				*)
(*									*)
(*	Write bucket_page to disk through direct I/O.			*)
(*									*)
(************************************************************************)



procedure write_bucket_page(
      offset		: host_bucket_page_index);

var
  address     : integer;
  length      : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;

begin
  extend_operator.get_file_information('LOCABUCK', address, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address + offset;
	  byte_count := PAGE_SIZE
	end (* with *) ;
      value_param := call_param;
      io(bucket_page, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
end (* write_bucket_page *) ;



$if condition
(****************************  reconfigure  *****************************)
(*									*)
(*		      write_threshold_condition_page			*)
(*									*)
(*	Write threshold_cond_page.					*)
(*									*)
(************************************************************************)



procedure write_threshold_condition_page(
  offset	: threshold_condition_index);

var
  address     : integer;
  length      : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;

begin
  extend_operator.get_file_information('THRECOND', address, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address + offset;
	  byte_count := PAGE_SIZE
	end (* with *) ;
      value_param := call_param;
      io(threshold_cond_page, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
end (* write_threshold_condition_page *) ;
$endif


(****************************  reconfigure  *****************************)
(*									*)
(*			    write_reload_data				*)
(*									*)
(*	Write reload_data_buffer to disk.				*)
(*									*)
(************************************************************************)



procedure entry write_reload_data;

$if reload
var
  address     : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;
$endif

begin
$if reload
  extend_operator.move_operation('RELODATA', RELOAD_DATA_PAGE_MAX, 
    RELOAD_DATA_PAGE_MAX, address, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address;
	  byte_count := RELOAD_DATA_PAGE_MAX*page_size
	end (* with *) ;
      value_param := call_param;
      io(reload_data_buffer, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
$endif
end (* write_reload_data *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			     write_xomhost_page				*)
(*									*)
(*	Write xomhost_page to disk through direct I/O.			*)
(*									*)
(************************************************************************)



procedure write_xomhost_page(
      offset		: integer);

$if reload
var
  address     : integer;
  length      : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;
$endif

begin
$if reload
  extend_operator.get_file_information('XOMHOSTS', address, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address + offset;
	  byte_count := PAGE_SIZE
	end (* with *) ;
      value_param := call_param;
      io(xomhost_page, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
$endif
end (* write_xomhost_page *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			  write_cluster_name_page			*)
(*									*)
(*	Write cluster_name_page to disk through direct I/O.		*)
(*									*)
(************************************************************************)



procedure write_cluster_name_page(
      offset		: cluster_name_page_index);

var
  address     : integer;
  length      : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;

begin
  extend_operator.get_file_information('CLSTRNAM', address, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address + offset;
	  byte_count := PAGE_SIZE
	end (* with *) ;
      value_param := call_param;
      io(cluster_name_page, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
end (* write_cluster_name_page *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			      put_node_names				*)
(*									*)
(*	Put range ok node name to node_name_page.			*)
(*									*)
(************************************************************************)



procedure entry put_node_names(
      node_number	: integer;
      name	 	: name_file_name;
  var current_index	: node_index);

var
  pageno	: node_name_page_page_index;
  i		: name_page_index;

begin
  if node_range_check(node_number)
  then
    begin
      current_index := encode_node(node_number);
      if current_index <= NODE_LIMIT
      then
	begin
	  i := current_index mod NAME_PAGE_MAX;
	  node_name_page.names[i] := name;
	  if i = NAME_PAGE_LIMIT
	  then 
	    begin
	      pageno := current_index div NAME_PAGE_MAX;
	      write_name_page('$$$NODES', pageno, node_name_page);
	      clear_page(NODESNAM)
	    end
	end
      else user_terminal.write_quoted_text_line('too many node names\')
    end
end (* put_node_names *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			      put_host_names				*)
(*									*)
(*	Put range ok host name to host_name_page.			*)
(*									*)
(************************************************************************)



procedure entry put_host_names(
      host_number	: integer;
      name	 	: name_file_name;
  var current_index	: host_index);

var
  pageno	: host_name_page_page_index;
  i		: name_page_index;

begin
  if host_range_check(host_number)
  then
    begin
      current_index := encode_host(host_number);
      if current_index <= HOST_LIMIT
      then
	begin
	  i := current_index mod NAME_PAGE_MAX;
	  host_name_page.names[i] := name;
	  if i = NAME_PAGE_LIMIT
	  then 
	    begin
	      pageno := current_index div NAME_PAGE_MAX;
	      write_name_page('$$$HOSTS', pageno, host_name_page);
	      clear_page(HOSTSNAM)
	    end
	end
      else user_terminal.write_quoted_text_line('too many host names\')
    end
end (* put_host_names *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    put_probe_passwords				*)
(*									*)
(*	put range ok probe password into probe_password_page.		*)
(*									*)
(************************************************************************)


procedure entry put_probe_passwords(
      s	      		: integer;
      password		: password_string);

var
  pageno: password_page_index;
  i	: page_password_index;

begin
  if (0 <= s) and (s <= SUPERVISOR_LIMIT)
  then
    begin
      i := s mod page_password_max;
      probe_password_page.passwords[i] := password;
      if i = PAGE_PASSWORD_LIMIT
      then
	begin
      	  pageno := s div PAGE_PASSWORD_MAX;
	  write_probe_password_page(pageno);
	  clear_page(PROBENAM)
	end
    end
end (* put_probe_passwords *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			     remote_down_key				*)
(*									*)
(*	Return remote_greeting_entry key for given node and slot.	*)
(*									*)
(************************************************************************)



function remote_down_key(node: node_index; slot: slot_index): integer;

begin
  remote_down_key := node*slot_max+slot
end (* remote_down_key *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			 put_remote_down_entries			*)
(*									*)
(*	Put range ok remote down entry to 'REMOTEDO' file.		*)
(*									*)
(************************************************************************)



procedure entry put_remote_down_entries(
      node_number	: integer;
      host_number	: integer;
      slot       	: slot_index;
      start      	: integer;
      clear      	: integer;
  var current_index	: integer);

var
  pageno: remote_greeting_page_index;
  i	: remote_greeting_entry_index;
  node	: node_index;
  host	: host_index;

begin
  if node_range_check(node_number)
  then
    if host_range_check(host_number) 
    then
      begin
	if current_index <= REMOTE_GREETING_LIMIT
	then
	  begin
	    i := current_index mod REMOTE_GREETING_ENTRY_MAX;
	    with remote_page[i] do
  	      begin
	        node := encode_node(node_number);
	        host := encode_host(host_number);
	        key  := remote_down_key(node, slot);
	        kernel_host := host;
	        start_time  := start;
	        clear_time  := clear
	      end;
	    if i = REMOTE_GREETING_ENTRY_LIMIT
	    then
	      begin
		pageno := current_index div REMOTE_GREETING_ENTRY_MAX;
		write_remote_page(pageno);
		clear_page(REMOTEDO)
	      end ;
	    current_index := current_index + 1
	  end
	else user_terminal.write_quoted_text_line('Too many remote down messages\')
      end
end (* put_remote_down_entries *) ;




(****************************  reconfigure  *****************************)
(*									*)
(*			   put_location_buckets				*)
(*									*)
(*	Put range ok host location bucket to 'LOCABUCK' file.		*)
(*									*)
(************************************************************************)



procedure entry put_location_buckets(
      node_number	: integer;
      host_number	: integer;
      position_data	: host_position_index;
      time_data		: integer;
  var current_index	: integer);

var
  pageno	: host_bucket_page_index;
  i		: bucket_entry_index;

begin
  if node_range_check(node_number)
  then
    if host_range_check(host_number)
    then
      begin
	if current_index <= HOST_LOCATION_LIMIT
	then
	  begin
	    i := current_index mod BUCKET_ENTRY_MAX;
	    bucket_page[i].node := encode_node(node_number);
	    bucket_page[i].host := encode_host(host_number);
	    bucket_page[i].position := position_data;
	    bucket_page[i].time := time_data;
	    if i = BUCKET_ENTRY_LIMIT
	    then
	      begin
		pageno := current_index div BUCKET_ENTRY_MAX;
		write_bucket_page(pageno);
		clear_page(LOCABUCK)
	      end ;
	    current_index := current_index + 1
	  end
	else user_terminal.write_quoted_text_line('Too many host location\ ')
      end
end (* put_location_buckets *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			  write_host_status_text			*)
(*									*)
(*	Write host status file text to disk.				*)
(*									*)
(************************************************************************)



procedure write_host_status_text(
  host_status_text	: page;
  addr_write_to		: integer);		

var
  text_buffer : page;
  call_param  : disk_param;
  value_param : disk_param;

begin
  text_buffer := host_status_text;
  with call_param do
    begin
      operation := disk_write;
      start_addr := addr_write_to;
      byte_count := page_size
    end (* with *) ;
  value_param := call_param;
  io(text_buffer, value_param, disk, file_system_disk);
  if value_param.status <> complete
  then io_report.disk_error_check(call_param, value_param)
end (* write_host_status_text *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*		      write_host_status_entry_page			*)
(*									*)
(*	Write host_status_entry_page to disk through direct I/O.	*)
(*									*)
(************************************************************************)



procedure write_host_status_entry_page(
      offset		: entry_page_index);

var
  address     : integer;
  length      : integer;
  call_param  : disk_param;
  value_param : disk_param;
  ok	      : boolean;

begin
  extend_operator.get_file_information('HOSTSTAT', address, length, ok);
  if ok
  then
    begin
      with call_param do
	begin
	  operation := disk_write;
	  start_addr := address + offset;
	  byte_count := PAGE_SIZE
	end (* with *) ;
      value_param := call_param;
      io(host_status_entry_page, value_param, disk, file_system_disk);
      if value_param.status <> complete
      then io_report.disk_error_check(call_param, value_param)
    end
end (* write_host_status_entry_page *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			   put_host_status_entry			*)
(*									*)
(*	Put range ok host_status_entry into host_status_entry_page.	*)
(*	Also write the matched text to disk.				*)
(*	There is no empty entry between two host_status_entry.		*)
(*									*)
(************************************************************************)



procedure entry put_host_status_entry(
      old_sup	   	: integer;
      host_number  	: integer;
      start		: integer;
      stop		: integer;
      sup_status	: sup_operation_record;
      size         	: integer;
      active		: boolean;
      name		: symbol;
      clear_status	: clear_operation;
      text         	: page;
  var current_index	: integer);

var
  i		: host_status_entry_index;
  j		: entry_page_index;
  text_addr	: integer;
  s		: supervisor_index;

begin
  if host_range_check(host_number)
  then
    if current_index <= HOST_STATUS_TEXT_PAGE_LIMIT
    then
      begin
	text_addr := host_status_text_start + current_index;
	i := current_index mod HOST_STATUS_ENTRY_MAX;
	host_status_entry_page[i].host_number := host_number;
	host_status_entry_page[i].start_time  := start;
	host_status_entry_page[i].clear_time  := stop;
        for s := 0 to SUPERVISOR_LIMIT do
	  host_status_entry_page[i].operation[s] := sup_status[s];
	if old_sup < SUPERVISOR_MAX
	then
	  begin
	    for s := old_sup to SUPERVISOR_LIMIT do
	      with host_status_entry_page[i] do
		if (operation[0] = SET_OK) or (operation[0] = SET_PENDING)
		then operation[s] := SET_PENDING
		else operation[s] := CLEAR 
	  end;
	host_status_entry_page[i].size := size;
$if multiple_host_message
	host_status_entry_page[i].msg_active := active;
	host_status_entry_page[i].msg_name   := name;
	host_status_entry_page[i].clear_state:= clear_status;
$endif multiple_host_message
	if i = HOST_STATUS_ENTRY_LIMIT
 	then
	  begin
	    j := current_index div HOST_STATUS_ENTRY_MAX;
	    write_host_status_entry_page(j);
	    clear_page(HOSTSTAT)
	  end;
	write_host_status_text(text, text_addr);
	current_index := current_index + 1
      end
    else user_terminal.write_quoted_text_line('too many host status\ ')
end (* put_host_status_entry *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			put_threshold_conditions			*)
(*									*)
(*	Put threshold condition into threshold_condition_buffer.	*)
(*									*)
(************************************************************************)


procedure entry put_threshold_conditions(
  page_number		: integer;
  cond_name		: symbol;
  cond_describe 	: description;
  cond_event		: event_index;
  cond_alarm_class	: alarm_level;
  cond_external_data	: external_recurring_outage_variables;
  cond_bound		: external_recurring_outage_index;
  cond_alarm		: boolean;
  cond_create_time	: integer);

begin
$if condition
  with threshold_cond_page.condition_head do
    begin
      name		:= cond_name;
      describe_text	:= cond_describe;
      event_or_isis	:= cond_event;
      alarm_class	:= cond_alarm_class;
      external_recurring_data := cond_external_data;
      bound		:= cond_bound;
      alarm		:= cond_alarm;
      create_time	:= cond_create_time
    end;
  write_threshold_condition_page(page_number) 
$endif
end (* put_threshold_conditions *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			    put_reload_nodes				*)
(*									*)
(*	Put range ok node into node_set of reload_data_buffer.		*)
(*									*)
(************************************************************************)



procedure entry put_reload_nodes(first    : integer;
				 set_end  : integer;
				 full     : boolean);

$if reload
var
  last	     : integer;
  node_number: integer;
$endif

begin
$if reload
  if full
  then last := last_tymnet_ii_node
		      (* if allowed_nodes is full in old configuration *)
		      (* then it will also be full in new configuration*)
  else last := set_end;
  for node_number := first to last do
    if node_range_check(node_number)
    then add_node(encode_node(node_number), reload_data_buffer.reload_nodes)
$endif
end (* put_reload_nodes *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			     put_reload_hosts				*)
(*									*)
(*	Put range ok host into host_set of reload_data_buffer.		*)
(*									*)
(************************************************************************)



procedure entry put_reload_hosts(first    : integer;
				 set_end  : integer;
	    		         full     : boolean);

$if reload
var
  last	     : integer;
  host_number: integer;
$endif

begin
$if reload
  if full
  then last := host_limit
		      (* if reload_host is full in old configuration   *)
		      (* then it will also be full in new configuration*)
  else last := set_end;
  for host_number := first to last do
    if host_range_check(host_number)
    then add_host(encode_host(host_number), reload_data_buffer.reload_hosts)
$endif
end (* put_reload_hosts *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			     put_reload_value				*)
(*									*)
(*	Put reload_value to reload_data_buffer.				*)
(*									*)
(************************************************************************)


procedure entry put_reload_value(value: reload_outage_value);

begin
$if reload reload_data_buffer.reload_value := value
end (* put_reload_value *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			   put_xom_host_entries				*)
(*									*)
(*	Put range ok xom host entry to 'XOMHOSTS' file.			*)
(*									*)
(************************************************************************)



procedure entry put_xom_host_entries(
      host_number		: integer;
      node_number		: integer;
      mxp_number 		: mxp_index;
      slot_restore_number	: integer;
  var current_index		: integer);

$if reload
var
  pageno	: xom_host_page_index;
  i		: xom_host_entry_index;
$endif

begin
$if reload
  if host_range_check(host_number)
  then
    if node_range_check(node_number)
    then
      begin
	if current_index <= XOM_ENTRY_LIMIT
	then
	  begin
	    i := current_index mod XOM_HOST_ENTRY_MAX;
	    xomhost_page[i].host := encode_host(host_number);
	    xomhost_page[i].node := encode_node(node_number);
	    xomhost_page[i].mxp  := mxp_number;
	    xomhost_page[i].slot_restore := slot_restore_number;
	    if i = XOM_HOST_ENTRY_LIMIT
	    then
	      begin
		pageno := current_index div XOM_HOST_ENTRY_MAX;
		write_xomhost_page(pageno);
		clear_page(XOMHOSTS)
	      end ;
	    current_index := current_index + 1
	  end
	else user_terminal.write_quoted_text_line('Too many xom host entries\')
      end
$endif
end (* put_xom_host_host_host_entries *) ;




(****************************  reconfigure  *****************************)
(*									*)
(*			    put_cluster_names				*)
(*									*)
(*	Put range ok cluster name to cluster_names_buffer.		*)
(*									*)
(************************************************************************)



procedure entry put_cluster_names(
      node_number	: integer;
      name 	     	: cluster_name;
  var current_index	: node_index);

var
  pageno	: cluster_name_page_index;
  i		: cluster_entry_index;

begin
  if node_range_check(node_number)
  then
    begin
      current_index := encode_node(node_number);
      if current_index <= NODE_LIMIT
      then
	begin
	  i := current_index mod CLUSTER_ENTRY_MAX;
	  cluster_name_page[i] := name;
	  if i = CLUSTER_ENTRY_LIMIT
	  then 
	    begin
	      pageno := current_index div CLUSTER_ENTRY_MAX;
	      write_cluster_name_page(pageno);
	      if pageno < CLUSTER_NAME_PAGE_LIMIT
	      then clear_cluster_page(pageno+1)
	    end 
	end
      else user_terminal.write_quoted_text_line('too many cluster names\ ')
    end
end (* put_cluster_names *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			adjust_host_bucket_file_length			*)
(*									*)
(*	Correct the file length of vfdd.				*)
(*									*)
(************************************************************************)


procedure entry adjust_host_bucket_file_length(
  total_bucket_entries	: host_location_index);

var
  file_length	: host_bucket_page_index;
  address	: integer;
  ok		: boolean;

begin
  file_length := 
    (total_bucket_entries + BUCKET_ENTRY_LIMIT) div BUCKET_ENTRY_MAX;
  extend_operator.move_operation('LOCABUCK', HOST_BUCKET_PAGE_MAX,
    file_length, address, ok)
end (* adjust_host_bucket_file_length *) ;



$if reload
(****************************  reconfigure  *****************************)
(*									*)
(*			adjust_xom_host_file_length			*)
(*									*)
(*	Correct the file length of vfdd.				*)
(*									*)
(************************************************************************)


procedure entry adjust_xom_host_file_length(
  total_xom_host_entries	: xom_entry_index);

var
  file_length	: xom_host_page_index;
  address	: integer;
  ok		: boolean;

begin
  file_length := 
    (total_xom_host_entries + XOM_HOST_ENTRY_LIMIT) div XOM_HOST_ENTRY_MAX;
  extend_operator.move_operation(
    'XOMHOSTS', XOM_HOST_PAGE_MAX, file_length, address, ok)
end (* adjust_xom_host_file_length *) ;
$endif



(****************************  reconfigure  *****************************)
(*									*)
(*		      adjust_remote_down_file_length			*)
(*									*)
(*	Correct the file length of vfdd.				*)
(*									*)
(************************************************************************)


procedure entry adjust_remote_down_file_length(
  total_remote_messages	: remote_greeting_index);

var
  file_length	: remote_greeting_page_index;
  address	: integer;
  ok		: boolean;

begin
  file_length := 
    (total_remote_messages + REMOTE_GREETING_ENTRY_LIMIT) div REMOTE_GREETING_ENTRY_MAX;
  extend_operator.move_operation(
    'REMOTEDO', REMOTE_GREETING_PAGE_MAX, file_length, address, ok)
end (* adjust_remote_down_file_length *) ;



(****************************  reconfigure  *****************************)
(*									*)
(*			   write_file_last_page				*)
(*									*)
(************************************************************************)


procedure entry write_file_last_page(
  file_name		: file_name_set;
  file_last_index	: integer);

var
  write_pageno	: integer;

begin
  write_pageno := -1;
  case file_name of
    NODESNAM, HOSTSNAM :
      if (file_last_index mod NAME_PAGE_MAX) <> NAME_PAGE_LIMIT
      then write_pageno := file_last_index div NAME_PAGE_MAX;

    CLSTRNAM :
      if (file_last_index mod CLUSTER_ENTRY_MAX) <> CLUSTER_ENTRY_LIMIT
      then write_pageno := file_last_index div CLUSTER_ENTRY_MAX;

    REMOTEDO :
      if (file_last_index mod REMOTE_GREETING_ENTRY_MAX) <> REMOTE_GREETING_ENTRY_LIMIT
      then write_pageno := file_last_index div REMOTE_GREETING_ENTRY_MAX;

    LOCABUCK :
      if (file_last_index mod BUCKET_ENTRY_MAX) <> BUCKET_ENTRY_LIMIT
      then write_pageno := file_last_index div BUCKET_ENTRY_MAX;

    HOSTSTAT :
      if (file_last_index mod HOST_STATUS_ENTRY_MAX) <> HOST_STATUS_ENTRY_LIMIT
      then write_pageno := file_last_index div HOST_STATUS_ENTRY_MAX;

    XOMHOSTS :
      if (file_last_index mod XOM_HOST_ENTRY_MAX) <> XOM_HOST_ENTRY_LIMIT
      then write_pageno := file_last_index div XOM_HOST_ENTRY_MAX 

  end (* case *) ;  

  if write_pageno > -1
  then
    case file_name of
      NODESNAM :
        write_name_page('$$$NODES', write_pageno, node_name_page);

      HOSTSNAM :
        write_name_page('$$$HOSTS', write_pageno, host_name_page);

      CLSTRNAM :
        write_cluster_name_page(write_pageno);

      REMOTEDO :
        write_remote_page(write_pageno);

      LOCABUCK :
        write_bucket_page(write_pageno);

      HOSTSTAT :
        write_host_status_entry_page(write_pageno);

      XOMHOSTS :
        write_xomhost_page(write_pageno)

    end (* case *)
end (* write_incomplete_last_page *) ;


(****************************  reconfigure  *****************************)
(************************************************************************)


begin
  fill_new_configuration_params;
  current_buffer_index := 0
end (* reconfigure *) ;
!
(************************************************************************)
(*									*)
(*	ELOGFL.TDR Updated 9-Feb-86 at 18:18 by Hueyma			*)
(*									*)
(*	General definations to be used by erlog buffer.			*)
(*									*)
(************************************************************************)
(*									*)
(*	27Jan86	Removed Tymnetone code   -   ahm			*)
(*	10Feb86 Added event defination to 113, event 4 subevent was	*)
(*		updated to 24   -   ahm					*)
(*									*)
(************************************************************************)

(* define product id *)

const
  xcom_pid	= 51;
  x25_pid	= 129;
  x75_pid	= 130;
  i2is_pid	= 55;
  ontm_pid	= 64;
  val_pid	= 68;
  tmcs_pid	= 80;
  ram_pid	= 66;
  unknown_pid	= 0;


(* event defination *)

const
  first_code	= 1;
  last_code	= 113;

  
(* subevent definations *)
  
const
  first_speed_code =  0;
  last_speed_code  = 30;

const
  product_offset 	= 48 (* 30 hex *) ;
  first_isis_crash_code = 0;
  last_isis_crash_code 	= 21;


(* xcom report subcode *)

const
  first_xcom_link_subcode	= 16;
  middle_xcom_link_subcode	= 35;
  first_xcom_link_fml_subcode	= 36;
  last_xcom_link_subcode	= 57;

const
  first_xcom_line_subcode	= 128;
  last_xcom_line_subcode	= 170;


(* ontyme report subcode *)

const
  first_ontyme_subcode	= 16;
  last_ontyme_subcode	= 20;


(* ram report subcode *)

const
  first_ram_subcode	= 34;
  last_ram_subcode	= 42;

(* netval report subcode *)

const
  first_val_subcode	= 16;
  last_val_subcode	= 16;

  
(* tmcs report subcode *)

const
  first_tmcs_subcode	= 16;
  last_tmcs_subcode	= 16;

  
(* code 4 message subcodes *)

const
  first_code_4_subcode = 0;
  last_code_4_subcode  = 24;


(* code 7 message subcodes *)

const
  first_code_7_subcode = 1;
  last_code_7_subcode = 7;

(* event 8 node report subcode *)

const
  first_event_8_node_subcode = 1;
  last_event_8_node_subcode  = 46;

(* event 8 line error subcode *)

const
  first_event_8_line_subcode = 128;
  last_event_8_line_subcode  = 139;

(* host sadnesses *)

const
  high_940_host = 21;
  first_sadness = 1;
  last_sadness = 16;

type sadness = first_sadness..last_sadness;

(* code 12 message subcodes *)

const
  first_event_12_subcode = 3;
  last_event_12_subcode = 35;

(* code 12 message ISIS subcodes *)

const
  first_isis_subcode = 56;
  last_isis_subcode = 63;

(* code 12 message crash subcode *)

const
  first_crash_subcode = 0;
  last_crash_subcode = 20;

(* code 13 message subcodes *)

const
  first_code_13_subcode = 0;
  last_code_13_subcode  = 14;

(* code 18 message subcodes *)

const
  first_code_18_subcode = 1;
  last_code_18_subcode = 6;

(* code 19 message subcodes *)

const
  first_code_19_subcode = 0;
  last_code_19_subcode  = 6;

(* code 32 message subcodes *)

const
  first_code_32_subcode = 1;
  last_code_32_subcode 	= 9;

(* code 41 message subcode *)

const
  first_code_41_subcode	= 0;
  last_code_41_subcode	= 10;

(* code 80 message subcode *)

const
  first_code_80_subcode = 1;
  last_code_80_subcode  = 14;

(* code 84 message subcode *)

const
  first_code_84_subcode = 0;
  last_code_84_subcode  = 3;

(* code 98 message subcode *) 

const
  first_event_98_isis_code = 0;
  last_event_98_isis_code = 9;
  first_event_98_sup_code = 1;
  last_event_98_sup_code = 6;

(* code 99 message subcode *) 

const
  first_event_99_isis_code = 0;
  last_event_99_isis_code = 10;
  first_event_99_sup_code = 1;
  last_event_99_sup_code = 6;


const
  erlog_data_max   = 25000;
  erlog_data_limit = erlog_data_max - 1;

type
  erlog_data_index = 0..erlog_data_limit;


(*  data types used by case and if  *)

const
  stack_record_max	= 20;
  stack_record_limit	= stack_record_max - 1;

type
  stack_record_index	= 0..stack_record_limit;
  
const
  stack_filler_max	= 12;
  stack_filler_limit	= stack_filler_max - 1;

type
  code_type = (if_type, case_type, loop_type);

type 
  stack_record	=
    record
      kind	: code_type;
      filler	: array [0..stack_filler_limit] of char
    end (* stack_record *) ;

type
  if_stack_record =
    record
      kind	: code_type;
      end_ptr	: integer;
      false_ptr	: integer;
      filler	: integer
    end (* if_stack_record *) ;

type
  case_stack_record =
    record
      kind	: code_type;
      end_ptr	: integer;
      lower	: integer;
      upper	: integer
    end (* case_stack_record *);

type
  loop_stack_record =
    record
      kind	: code_type;
      end_ptr	: integer;
      filler	: array [0..1] of integer
    end (* loop_stack_record *) ;

(*  data types used by subroutine  *)

type
  log_procedure = (print_speed_with_bps, print_speed, print_mxp_and_slot, 
    print_line, print_neighbor_node, print_neighbor_and_occurrency, 
    print_pli, print_unknown_isis_report, print_xcom_report, 
    print_kernel_report, print_ontyme_report, print_ram_report, 
    print_val_report, print_tmcs_report, 
    print_isis_report, print_unknown_event, 
    print_unknown_event_8_node_report, print_unknown_event_8_line_report
    );

const
  first_log_procedure = print_speed_with_bps;
  last_log_procedure  = print_unknown_event_8_line_report;

(* number of procedure argument *)

const
  print_speed_with_bps_args	 		= 1;
  print_speed_args	 			= 1;
  print_mxp_and_slot_args			= 2;
  print_line_args				= 2;
  print_neighbor_node_args			= 1;
  print_neighbor_and_occurrency_args		= 2;
  print_pli_args				= 1;
  print_unknown_isis_report_args		= 3;
  print_xcom_report_args			= 3;
  print_kernel_report_args			= 3;
  print_ontyme_report_args			= 3;
  print_ram_report_args				= 3;
  print_val_report_args				= 3;
  print_tmcs_report_args			= 3;
  print_isis_report_args			= 6;
  print_unknown_event_args			= 0;
  print_unknown_event_8_node_report_args   	= 1;
  print_unknown_event_8_line_report_args   	= 2;

(* number of procedure local variables *)

const
  print_speed_with_bps_locals	 		= 0;
  print_speed_locals	 			= 0;
  print_mxp_and_slot_locals			= 0;
  print_line_locals				= 0;
  print_neighbor_node_locals			= 0;
  print_neighbor_and_occurrency_locals		= 0;
  print_pli_locals				= 0;
  print_unknown_isis_report_locals		= 0;
  print_xcom_report_locals			= 0;
  print_kernel_report_locals			= 0;
  print_ontyme_report_locals			= 0;
  print_ram_report_locals			= 1;
  print_val_report_locals			= 0;
  print_tmcs_report_locals			= 0;
  print_isis_report_locals			= 4;
  print_unknown_event_locals			= 0;
  print_unknown_event_8_node_report_locals   	= 0;
  print_unknown_event_8_line_report_locals   	= 0;

type
  integer_bytes	= array [0..3] of char;!
(************************************************************************)
(*									*)
(*	ELGDEF.TMS							*)
(*									*)
(*	General definations to be used by erlog buffer.			*)
(*									*)
(************************************************************************)

const
  first_special_char	= '(:128:)';

(* ascii characters used by erlog data generator system *)

const
  event_code_symbol		= '(:171:)';
  hw1_symbol			= '(:128:)';
  hw2_symbol			= '(:129:)';
  hw3_symbol			= '(:130:)';
  hw4_symbol			= '(:131:)';
  substr_symbol			= '(:132:)';
  substr_no_shift_symbol	= '(:133:)';
  fullword_symbol		= '(:134:)';
  link_check_symbol		= '(:135:)';
  line_check_symbol		= '(:136:)';
  tymnet_i_check_symbol		= '(:172:)';
  print_node_symbol		= '(:137:)';
  print_host_symbol		= '(:138:)';
  print_octal_symbol		= '(:139:)';
  print_hex_symbol		= '(:140:)';
  print_decimal_symbol		= '(:141:)';
  print_decimal_d_symbol	= '(:142:)';
  print_decimal_scaled_symbol	= '(:173:)';
  print_time_symbol		= '(:143:)';
  print_product_symbol		= '(:144:)';
  print_link_string_symbol	= '(:146:)';
  print_mac_reg_sets_symbol	= '(:182:)';
  print_uun_symbol		= '(:147:)';
  print_ulog_text_symbol	= '(:174:)';
  print_space_symbol		= '(:148:)';
  print_newline_symbol		= '(:149:)';
  constant_symbol		= '(:150:)';
  plus_symbol			= '(:151:)';
  minus_symbol			= '(:152:)';
  multiply_symbol		= '(:153:)';
  divide_symbol			= '(:154:)';
  equal_symbol			= '(:155:)';
  less_than_symbol		= '(:156:)';
  greater_than_symbol		= '(:157:)';
  greater_or_equal_symbol	= '(:158:)';
  less_or_equal_symbol		= '(:159:)';
  range_check_symbol		= '(:160:)';
  andfunc_symbol		= '(:161:)';
  orfunc_symbol			= '(:162:)';
  notfunc_symbol		= '(:163:)';
  end_symbol			= '(:164:)';
  casecall_symbol		= '(:165:)';
  ifcall_symbol			= '(:166:)';
  elseifcall_symbol		= '(:176:)';
  call_proc_symbol		= '(:167:)';
  proc_return_symbol		= '(:168:)';
  define_proc_symbol		= '(:169:)';
  dummy_arg_symbol		= '(:170:)';
  print_string_symbol		= '(:175:)';
  beginloop_symbol		= '(:177:)';
  endloop_symbol		= '(:178:)';
  exitloop_symbol		= '(:179:)';
  store_var_symbol		= '(:180:)';
  local_var_symbol		= '(:181:)';
  mod_symbol			= '(:185:)';
  exit_symbol			= '(:186:)';

!
(************************************************************************)
(*	DATGEN.TDR							*)
(*									*)
(*			    erlog_data_generate				*)
(*									*)
(*	All routines that are needed for generating erlog buffer are 	*)
(*	in this class.  The erlog buffer is filled at initialization	*)
(*	time.  This class has one entry procedure which writes the	*)
(*	permanent ERLOGDAT file from erlog buffer.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Mar85	Original -- ahm						*)
(*									*)
(************************************************************************)

const
  no_top 	= -1;

const
  from_stack		= 0;

type
  erlog_data_generate = 
    class(
      io_report		: disk_error;
      user_terminal	: circuit_handler;
      extend_operator	: file_extender);

var
  format		: internal_to_string;
  erlog_buffer		: array [erlog_data_index] of char;
  current_erlog_index	: erlog_data_index;
  control_stack		: array [stack_record_index] of stack_record;
  top			: stack_record_index;
  log_proc_address	: array [log_procedure] of integer;
  proc_defined		: boolean;
  casecall_count	: integer;
  ifcall_count		: integer;
  loop_count		: integer;


(************************  erlog_data_generate  *************************)
(*									*)
(*			      	generate				*)
(*									*)
(*	Put one character to erlog buffer, update erlog buffer pointer.	*)
(*									*)
(************************************************************************)


procedure generate(character: char);

begin
  erlog_buffer[current_erlog_index] := character;
  current_erlog_index := current_erlog_index + 1
end (* generate *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			      stuff_integer				*)
(*									*)
(*	Stuff an integer into two characters, integer applied here	*)
(*	can't be greater than FFFF.					*)
(*									*)
(************************************************************************)


procedure stuff_integer(
  x         : univ integer_bytes;
  left_byte : integer);

begin
  erlog_buffer[left_byte]  := x[2];
  erlog_buffer[left_byte + 1] := x[3]
end (* stuff_integer *) ;


(************************  erlog_data_generate  *************************)
(*									*)
(*			     generate_pointer				*)
(*									*)
(*	Put pointer to erlog buffer (pointer occupy two bytes), 	*)
(*	update erlog buffer pointer.					*)
(*									*)
(************************************************************************)


procedure generate_pointer(x: integer);

begin
  stuff_integer(x, current_erlog_index);
  current_erlog_index := current_erlog_index + 2
end (* generate_pointer *) ;    



(************************  erlog_data_generate  *************************)
(*									*)
(*			      	  error					*)
(*									*)
(*	Print error message and information pointers out.		*)
(*									*)
(************************************************************************)


procedure error(message: quoted_text);

begin
  user_terminal.write_quoted_text_line(message);
  format.simple_message('Error occurred at \ ');
  format.number(current_erlog_index, 10);
  format.write_line(user_terminal);
  format.simple_message('casecall count = \');
  format.number(casecall_count, 10);
  format.write_line(user_terminal);
  format.simple_message('ifcall count = \');
  format.number(ifcall_count, 10);
  format.write_line(user_terminal)
end (* error *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			   control_stack_check				*)
(*									*)
(*	Check control stack type, if type not match then print error.	*)
(*									*)
(************************************************************************)


function control_stack_check(check_type: code_type): boolean;

begin
  control_stack_check := TRUE;
  if control_stack[top].kind <> check_type
  then
    begin
      case check_type of
	IF_TYPE		: error('Control stack not IF type\');
	CASE_TYPE	: error('Control stack not CASE type\');
	LOOP_TYPE	: error('Control stack not LOOP type\')
      end (* case *);
      control_stack_check := FALSE
    end
end (* control_stack_check *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			    push_stack_record				*)	
(*									*)
(*	Push a stack record to top of control stack.			*)
(*									*)
(************************************************************************)


procedure push_stack_record(new_record: univ stack_record) ;

begin
  if top = STACK_RECORD_LIMIT
  then error('Stack overflow\ ')
  else
    begin
      top := top + 1;
      control_stack[top] := new_record
    end
end (* push_stack_record *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			     pop_stack_record				*)
(*									*)
(*	Pop out top stack record from control stack.			*)
(*									*)
(************************************************************************)


procedure pop_stack_record(var popped_record: univ stack_record);

begin
  if top = NO_TOP
  then error('Stack underflow\')
  else 
    begin
      popped_record := control_stack[top];
      top := top - 1
    end
end (* pop_stack_record *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			  erlog_buffer_length				*)
(*									*)
(*	Return erlog buffer length in pages.				*)
(*									*)
(************************************************************************)


function erlog_buffer_length: erlog_data_index;

begin
  erlog_buffer_length := ((current_erlog_index - 1) + PAGE_LIMIT) div PAGE_SIZE
end (* erlog_buffer_length *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			         put					*)
(*									*)
(*	Make a function work like a procedure.				*)
(*									*)
(************************************************************************)


procedure put(x: integer);

begin
end (* put *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			      event_code				*)
(*									*)
(*	Put event code symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


function event_code: integer;

begin
  generate(EVENT_CODE_SYMBOL);
  event_code := FROM_STACK
end (* event_code *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				  hw1					*)
(*									*)
(*	Put hw1 symbol to erlog buffer.					*)
(*									*)
(************************************************************************)


function hw1: integer;

begin
  generate(HW1_SYMBOL);
  hw1 := FROM_STACK
end (* hw1 *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				   hw2					*)
(*									*)
(*	Put hw2 symbol to erlog buffer.					*)
(*									*)
(************************************************************************)


function hw2: integer;

begin
  generate(HW2_SYMBOL);
  hw2 := FROM_STACK
end (* hw2 *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				   hw3					*)
(*									*)
(*	Put hw3 symbol to erlog buffer.					*)
(*									*)
(************************************************************************)


function hw3: integer; 

begin
  generate(HW3_SYMBOL);
  hw3 := FROM_STACK
end (* hw3 *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				   hw4					*)
(*									*)
(*	Put hw4 symbol to erlog buffer.					*)
(*									*)
(************************************************************************)


function hw4: integer;

begin
  generate(HW4_SYMBOL);
  hw4 := FROM_STACK
end (* hw4 *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 substr					*)
(*									*)
(*	Put substring symbol, number of mask bits and number of shift	*)
(*	bits to erlog buffer.						*)
(*									*)
(************************************************************************)


function substr(dummy, mask, shift: integer): integer;

begin
  generate(SUBSTR_SYMBOL);
  generate(chr(mask));
  generate(chr(shift));
  substr := FROM_STACK
end (* substr *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			     substr_no_shift				*)
(*									*)
(*	Put substring symbol, number of mask bits (the number of bits	*)
(*	which will be taken from a bit string) to erlog buffer.		*)
(*									*)
(************************************************************************)


function substr_no_shift(dummy, mask: integer): integer;

begin
  generate(SUBSTR_NO_SHIFT_SYMBOL);
  generate(chr(mask));
  substr_no_shift := FROM_STACK
end (* substr_no_shift *) ;

 

(************************  erlog_data_generate  *************************)
(*									*)
(*				fullword				*)
(*									*)
(*	Put fullword symbol to erlog buffer.				*)	
(*									*)
(************************************************************************)


function fullword: integer;

begin
  generate(FULLWORD_SYMBOL);
  fullword := FROM_STACK
end (* fullword *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				link_check				*)
(*									*)
(*	Put link check symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure link_check;

begin
  generate(LINK_CHECK_SYMBOL)
end (* link_check *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				line_check				*)
(*									*)
(*	Put line check symbol into erlog buffer.			*)
(*									*)
(************************************************************************)


procedure line_check;

begin
  generate(LINE_CHECK_SYMBOL)
end (* line_check *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				print_node				*)
(*									*)
(*	Put print node symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure print_node(x: integer);

begin
  generate(PRINT_NODE_SYMBOL)
end (* print_node *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				print_host				*)
(*									*)
(*	Put print host symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure print_host(x: integer);

begin
  generate(PRINT_HOST_SYMBOL)
end (* print_host *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				print_octal				*)
(*									*)
(*	Put print octal symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure print_octal(x: integer);

begin
  generate(PRINT_OCTAL_SYMBOL)
end (* print_octal *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				print_hex				*)
(*									*)
(*	Put print hex symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure print_hex(x: integer);

begin
  generate(PRINT_HEX_SYMBOL)
end (* print_hex *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			      print_decimal				*)
(*									*)
(*	Put print decimal symbol to erlog buffer.			*)
(*									*)
(************************************************************************)


procedure print_decimal(x: integer);

begin
  generate(PRINT_DECIMAL_SYMBOL)
end (* print_decimal *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			  print_decimal_with_d				*)
(*									*)
(*	Put print decimal end with "d" command symbol to erlog buffer.	*)
(*									*)
(************************************************************************)


procedure print_decimal_with_d(x: integer);

begin
  generate(PRINT_DECIMAL_D_SYMBOL)
end (* print_decimal_with_d *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			  print_decimal_scaled				*)
(*									*)
(*	Put print decimal number sacled command symbol and scale to	*)
(*	erlog buffer.							*)
(*									*)
(************************************************************************)


procedure print_decimal_scaled(dummy, scale: integer);

begin
  generate(PRINT_DECIMAL_SCALED_SYMBOL);
  generate(chr(scale))
end (* print_decimal_scaled *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				print_time				*)
(*									*)
(*	Put print time symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure print_time(x: integer);

begin
  generate(PRINT_TIME_SYMBOL)
end (* print_time *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			      print_product				*)
(*									*)
(* 	Put print product symbol to erlog buffer.			*)
(*									*)
(************************************************************************)


procedure print_product(x: integer);

begin
  generate(PRINT_PRODUCT_SYMBOL)
end (* print_product *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			    print_link_string				*)
(*									*)
(*	Put print link string command symbol to erlog buffer.		*)
(*									*)
(************************************************************************)


procedure print_link_string;

begin
  generate(PRINT_LINK_STRING_SYMBOL)
end (* print_link_string *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			    print_mac_reg_sets				*)
(*									*)
(*	Put print mac register sets command symbol to erlog buffer.	*)
(*									*)
(************************************************************************)


procedure print_mac_reg_sets(x: integer);

begin
  generate(PRINT_MAC_REG_SETS_SYMBOL)
end (* print_mac_reg_sets *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				print_uun				*)
(*									*)
(*	Put print uun command symbol to erlog buffer.			*)
(*									*)
(************************************************************************)


procedure print_uun;

begin
  generate(PRINT_UUN_SYMBOL)
end (* print_uun *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			     print_ulog_text				*)
(*									*)
(*	Put print ulog text symbol to erlog buffer.			*)
(*									*)
(************************************************************************)


procedure print_ulog_text(x: integer);

begin
  generate(PRINT_ULOG_TEXT_SYMBOL)
end (* print_ulog_text *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			       print_space				*)
(*									*)
(*	Put print space symbol and the number of space to erlog buffer.	*)
(*									*)
(************************************************************************)


procedure print_space(number: integer);

begin
  generate(PRINT_SPACE_SYMBOL);
  generate(chr(number))
end (* print_space *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			      print_newline				*)
(*									*)
(*	Put print new line symbol to erlog buffer.			*)
(*									*)
(************************************************************************)


procedure print_newline;

begin
  generate(PRINT_NEWLINE_SYMBOL)
end (* print_newline *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			        constant				*)
(*									*)
(*	Put constant command symbol and constant to erlog buffer.	*)
(*	the constant can not be greater than 65535 (FFFF), and 		*)
(*	this constant will occupy two bytes.				*)
(*									*)
(************************************************************************)


function constant(number: integer): integer;

begin
  generate(CONSTANT_SYMBOL);
  generate_pointer(number);
  constant := FROM_STACK
end (* constant *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				  sum					*)
(*									*)
(*	Put plus command symbol to erlog buffer.			*)
(*									*)
(************************************************************************)


function sum: integer;

begin
  generate(PLUS_SYMBOL);
  sum := FROM_STACK
end (* sum *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			       difference				*)
(*									*)
(*	Put minus symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


function difference: integer;

begin
  generate(MINUS_SYMBOL);
  difference := FROM_STACK
end (* difference *) ;


  
(************************  erlog_data_generate  *************************)
(*									*)
(*				product					*)
(*									*)
(*	Put multiply symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


function product: integer;

begin
  generate(MULTIPLY_SYMBOL);
  product := FROM_STACK
end (* product *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				  quotient				*)
(*									*)
(*	Put divide symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


function quotient: integer;

begin
  generate(DIVIDE_SYMBOL);
  quotient := FROM_STACK
end (* quotient *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				remainder				*)
(*									*)
(*	Put mod symbol to erlog buffer.					*)
(*									*)
(************************************************************************)


function remainder: integer;

begin
  generate(MOD_SYMBOL);
  remainder := FROM_STACK
end (* remainder *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				  equal					*)
(*									*)
(*	Put equal symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


function equal: integer;

begin
  generate(EQUAL_SYMBOL);
  equal := FROM_STACK
end (* equal *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				less_than				*)
(*									*)
(*	Put less than symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


function less_than: integer;

begin
  generate(LESS_THAN_SYMBOL);
  less_than := FROM_STACK
end (* less_than *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			      greater_than				*)
(*									*)
(*	Put greater than  symbol to erlog buffer.			*)
(*									*)
(************************************************************************)


function greater_than: integer;

begin
  generate(GREATER_THAN_SYMBOL);
  greater_than := FROM_STACK
end (* greater_than *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			    greater_or_equal				*)
(*									*)
(*	Put greater or equal ( >= ) symbol to erlog buffer.		*)
(*									*)
(************************************************************************)


function greater_or_equal: integer;  

begin
  generate(GREATER_OR_EQUAL_SYMBOL);
  greater_or_equal := FROM_STACK
end (* greater_or_equal *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			     less_or_equal				*)
(*									*)
(*	Put less or equal ( <= ) symbol to erlog buffer. 		*)
(*									*)
(************************************************************************)


function less_or_equal: integer;  

begin
  generate(LESS_OR_EQUAL_SYMBOL);
  less_or_equal := FROM_STACK
end (* less_or_equal *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			       range_check				*)
(*									*)
(*	Put range check symbol to erlog buffer.				*)
(*	The lower bound and upper bound in this range check can not 	*)
(*	greater than 255.						*) 
(*									*)
(************************************************************************)


function range_check(lower_bound, upper_bound: integer): integer;

begin
  generate(RANGE_CHECK_SYMBOL);
  generate(chr(lower_bound));
  generate(chr(upper_bound));
  range_check := FROM_STACK
end (* range_check *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 andfunc				*)
(*									*)
(*	Put andfunc symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


function andfunc: integer;

begin
  generate(ANDFUNC_SYMBOL);
  andfunc := FROM_STACK
end (* andfunc *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 orfunc					*)
(*									*)
(*	Put orfunc symbo to erlog buffer.				*)
(*									*)
(************************************************************************)


function orfunc: integer;

begin
  generate(ORFUNC_SYMBOL);
  orfunc := FROM_STACK
end (* orfunc *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 notfunc				*)
(*									*)
(*	Put notfunc symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


function notfunc: integer;

begin
  generate(NOTFUNC_SYMBOL);
  notfunc := FROM_STACK
end (* notfunc *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				call_proc				*)
(*									*)
(*	Put call_proc symbol and the start address of this subroutine	*)
(*	to erlog buffer.  Subroutine start address is two bytes long.	*)
(*									*)
(************************************************************************)


procedure call_proc(name: log_procedure);

begin
  if log_proc_address[name] <> 0
  then
    begin
      generate(CALL_PROC_SYMBOL);
      generate_pointer(log_proc_address[name])
    end
  else
    error('Subroutine not defined\ ')
end (* call_proc *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			       proc_return				*)
(*									*)
(*	Put subrotine return symbol to erlog buffer, and turn off	*)
(*	subroutine defined switch.					*)
(*									*)
(************************************************************************)


procedure proc_return;

begin
  if not proc_defined
  then error('Procedure define_proc missed\ ')
  else
    begin
      generate(PROC_RETURN_SYMBOL);
      proc_defined := FALSE
    end
end (* proc_return *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			       define_proc				*)
(*									*)
(*	Put define_proc symbol and subroutine's number of argument to	*)
(*	erlog buffer. Subroutine argument number need to be less 	*)
(*	than 256.							*)
(*									*)
(************************************************************************)


procedure define_proc(
  name			: log_procedure; 
  number_of_args	: integer;
  number_of_locals	: integer);


begin
  if proc_defined
  then error('Procedure proc_return missed\ ')
  else
    begin
      log_proc_address[name] := current_erlog_index;
      generate(DEFINE_PROC_SYMBOL);
      generate(chr(number_of_args));
      generate(chr(number_of_locals));
      proc_defined := TRUE
    end
end (* define_proc *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				dummy_arg				*)
(*									*)
(*	Put argument symbol and argument number to erlog buffer.	*)
(*									*)
(************************************************************************)


function dummy_arg(argument_number: integer): integer;

begin
  if not proc_defined
  then error('Procedure define_proc missed\ ')
  else
    begin
      generate(DUMMY_ARG_SYMBOL);
      generate(chr(argument_number))
    end;
  dummy_arg := FROM_STACK
end (* dummy_argument *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				store_var				*)
(*									*)
(*	Put store_var symbol and local variable number to erlog buffer.	*)
(*									*)
(************************************************************************)


procedure store_var(var_number, dummy: integer); 

begin
  if not proc_defined
  then error('Procedure define_proc missed\ ')
  else
    begin
      generate(STORE_VAR_SYMBOL);
      generate(chr(var_number))
    end
end (* store_var *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				local_var				*)
(*									*)
(*	Put local_var symbol and local variable number to erlog buffer.	*)
(*									*)
(************************************************************************)


function local_var(var_number: integer): integer;

begin
  if not proc_defined
  then error('Procedure define_proc missed\ ')
  else
    begin
      generate(LOCAL_VAR_SYMBOL);
      generate(chr(var_number))
    end;
  local_var := FROM_STACK
end (* local_var *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 ifcall					*)
(*									*)
(*	This procedure initiates IF statements, it puts if initial	*)
(*	symbol (:166:) to erlog buffer.					*)
(*									*)
(************************************************************************)


procedure ifcall(x: integer);

var
  if_record	: if_stack_record;

begin
  generate(IFCALL_SYMBOL);
  if_record.kind   	:= IF_TYPE;
  if_record.end_ptr    	:= current_erlog_index;
  if_record.false_ptr	:= current_erlog_index+2;
  push_stack_record(if_record);
  current_erlog_index := current_erlog_index+4;
  ifcall_count := ifcall_count + 1	(* for locating error  *)
end (* ifcall *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				elseifcall				*)
(*									*)
(*	Put elseifcall symbol to erlog buffer and change false pointer	*)
(*	on top of control stack to current erlog index.			*)
(*									*)
(************************************************************************)


procedure elseifcall(x: integer);

var
  if_record	: if_stack_record;

begin
  generate(ELSEIFCALL_SYMBOL);
  if control_stack_check(IF_TYPE)
  then
    begin
      pop_stack_record(if_record);
      if_record.false_ptr := current_erlog_index;
      current_erlog_index := current_erlog_index + 2;
      push_stack_record(if_record)
    end
end (* elseifcall *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				endtrue					*)
(*									*)
(*	Put if false pointer to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure endtrue;

var
  if_record	: if_stack_record;

begin
  generate(END_SYMBOL);
  if control_stack_check(IF_TYPE)
  then 
    begin
      pop_stack_record(if_record);
      stuff_integer(current_erlog_index, if_record.false_ptr);
      push_stack_record(if_record)
    end
end (* endtrue *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				endfalse				*)
(*									*)
(*	Put endfalse symbol to erlog buffer.				*)
(*									*)
(************************************************************************)



procedure endfalse;

begin
  if control_stack_check(IF_TYPE)
  then generate(END_SYMBOL)
end (* endfalse *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				  endif					*)
(*									*)
(*	Put end of if pointer to erlog buffer. Also pop top control	*)
(*	stack record off.						*)
(*									*)
(************************************************************************)


procedure endif;

var
  if_record	: if_stack_record;

begin
  if control_stack_check(IF_TYPE)
  then 
    begin
      pop_stack_record(if_record);
      stuff_integer(current_erlog_index, if_record.end_ptr)
    end
end (* endif *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				casecall				*)
(*									*)
(*	Put casecall symbol to erlog buffer, followed by case lower	*)
(*	and upper bound. Also put case pointers to stack.		*)
(*									*)
(************************************************************************)


procedure casecall(
  lower_bound	: integer;
  upper_bound	: integer);

var
  case_record	: case_stack_record;

begin
  generate(CASECALL_SYMBOL);
  generate(chr(lower_bound));
  generate(chr(upper_bound));
  case_record.kind	:= CASE_TYPE;
  case_record.end_ptr 	:= current_erlog_index;
  case_record.lower	:= lower_bound;
  case_record.upper   	:= upper_bound;
  push_stack_record(case_record);
  current_erlog_index := current_erlog_index+2*(upper_bound-lower_bound+2);
  casecall_count := casecall_count + 1 		(* for locating error  *)
end (* casecall *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				nextcase				*)
(*									*)
(*	Put nextcase pointer to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure nextcase(case_number: integer);

var
  case_record	: case_stack_record;

begin
  if control_stack_check(CASE_TYPE)
  then
    begin
      pop_stack_record(case_record);
      if (case_record.lower <= case_number) and 
        (case_number <= case_record.upper) 
      then
  	stuff_integer(current_erlog_index, 
	  case_record.end_ptr+2*(case_number-case_record.lower+1))
      else
	error('CASE out of range\');
      push_stack_record(case_record)
    end
end (* nextcase *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			       endnextcase				*)
(*									*)
(*	Put end next case symbol to erlog buffer.			*)
(*									*)
(************************************************************************)


procedure endnextcase;

begin
  if control_stack_check(CASE_TYPE)
  then generate(END_SYMBOL)
end (* endnextcase *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 endcase				*)
(*									*)
(*	Put end case symbol to erlog buffer and pop off top control	*)
(*	stack.								*)
(*									*)
(************************************************************************)


procedure endcase;

var
  case_record	: case_stack_record;

begin  
  if control_stack_check(CASE_TYPE)
  then 
    begin
      pop_stack_record(case_record);
      stuff_integer(current_erlog_index, case_record.end_ptr)
    end
end (* endcase *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 beginloop				*)
(*									*)
(*	Initiates loop statement, put beginloop symbol to erlog buffer. *)
(*	Also push a loop record to control stack.			*)
(*									*)
(************************************************************************)


procedure beginloop;

var
  loop_record 	: loop_stack_record;

begin
  generate(BEGINLOOP_SYMBOL);
  loop_record.kind	:= LOOP_TYPE;
  loop_record.end_ptr	:= current_erlog_index;
  push_stack_record(loop_record);
  current_erlog_index := current_erlog_index + 2;
  loop_count := loop_count + 1
end (* beginloop *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 exitloop				*)
(*									*)
(*	Put exitloop symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure exitloop(dummy: integer);

begin
  generate(EXITLOOP_SYMBOL)
end (* exitloop *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 endloop				*)
(*									*)
(*	Put endloop symbol and end loop pointer to erlog buffer.	*)
(*									*)
(************************************************************************)


procedure endloop;

var
  loop_record	: loop_stack_record;

begin
  generate(ENDLOOP_SYMBOL);
  if control_stack_check(LOOP_TYPE)
  then 
    begin
      pop_stack_record(loop_record);
      stuff_integer(current_erlog_index, loop_record.end_ptr)
    end
end (* endloop *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*				 exit 					*)
(*									*)
(*	Put exit symbol to erlog buffer.				*)
(*									*)
(************************************************************************)


procedure exit;

begin
  generate(EXIT_SYMBOL)
end (* exit *) ;


(************************  erlog_data_generate  *************************)
(*									*)
(*				 print 					*)
(*									*)
(*	Put characters to erlog buffer.					*)
(*									*)
(************************************************************************)


procedure print(string: quoted_text);

var
  save_string_length_ptr: integer;
  count			: quoted_text_index;

begin
  generate(PRINT_STRING_SYMBOL);
  save_string_length_ptr := current_erlog_index;

  current_erlog_index := current_erlog_index + 1;
  count := 0;
  while string[count] <> END_MESSAGE_CHARACTER do
    begin
      generate(string[count]);
      count := count + 1
    end (* while *) ;

  erlog_buffer[save_string_length_ptr] := chr(count)
end (* print *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			     erlog_byte_size				*)
(*									*)
(*	Return erlog buffer length in bytes.				*)
(*									*)
(************************************************************************)


function entry erlog_byte_size: erlog_data_index;

begin
  erlog_byte_size := current_erlog_index
end (* erlog_byte_size *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			    erlog_page_length				*)
(*									*)
(*	Return erlog buffer length in pages.				*)
(*									*)
(************************************************************************)


function entry erlog_page_length: integer;

begin
  erlog_page_length := erlog_buffer_length
end (* erlog_page_length *) ;



(************************  erlog_data_generate  *************************)
(*									*)
(*			   write_erlog_buffer				*)
(*									*)
(*	Write erlog buffer to ERLOGDAT file. If no ERLOGDAT, then 	*)
(*	create a new ERLOGDAT file before write file.			*)
(*									*)
(************************************************************************)


procedure entry write_erlog_buffer(var ok: boolean);

var
  address	: integer;
  length	: integer;
  call_param	: disk_param;
  value_param	: disk_param;

begin
  extend_operator.get_file_information('ERLOGDAT', address, length, ok); 
  if not ok  (* need to create ERLOGDAT  *)
  then extend_operator.create( 'ERLOGDAT', erlog_buffer_length, ok);
  if ok
  then	     (* write erlog_buffer to ERLOGDAT  *)
    begin
      extend_operator.move_operation( 'ERLOGDAT', erlog_buffer_length,
	erlog_buffer_length, address, ok);
      if ok
      then
	begin
	  with call_param do
	    begin
	      operation		:= DISK_WRITE;
	      start_addr	:= address;
	      byte_count	:= erlog_buffer_length*PAGE_SIZE
	    end (* with *);
	  value_param := call_param;
	  io(erlog_buffer, value_param, disk, file_system_disk);
	  if value_param.status <> complete
	  then io_report.disk_error_check(call_param, value_param)
	end
    end
end (* write_erlog_buffer *) ;   
!
(***************************  data_generate  ****************************)
(*									*)
(*	DTINIT.TDR							*)
(*									*)
(*			    Initialization				*)
(*									*)
(************************************************************************)



procedure initialization;

var
  i: log_procedure;

begin
  top := NO_TOP;
  current_erlog_index := 0;
  casecall_count      := 0;	(* for error message *)
  ifcall_count 	      := 0;	(* for error message *)
  loop_count	      := 0;	(* for error message *)

  for i := FIRST_LOG_PROCEDURE to LAST_LOG_PROCEDURE do
    log_proc_address[i] := 0;	(* initial subroutine address table *)

  proc_defined := FALSE;

  (* reserve first two bytes for pointing to EVENT_POINTER *)
  current_erlog_index := 2;

  (* start entering data *)

  (* SUBROUTINES *)

  (* print_speed_with_bps *)
  (**************************************************************)
  (*  procedure print_speed_with_bps(speed_code: integer);	*)
  (*								*)
  (*  const							*)
  (*  first_speed_code =  0;					*)
  (*  last_speed_code  = 30;					*)
  (*								*)
  (*  begin							*)
  (*    if (speed_code < first_speed_code) or 			*)
  (*	  (speed_code > last_speed_code)			*)
  (*    then							*)
  (*  	  begin							*)
  (*        print_decimal(speed_code);				*)
  (*  	    print( ' invalid\ ')				*)
  (*	  end							*)
  (*    else							*)
  (*  	  case speed_code of 					*)
  (*	    0, 1		: print('2400 bps\ ');		*)
  (*	    2, 3		: print( '4800 bps\ ');		*)
  (*	    4, 5, 6, 7		: print( '9600 bps\ ');		*)
  (*	    8, 9, 10, 11	: print('19200 bps\');		*)
  (*	    12, 13, 14, 15	: print('28800 bps\');		*)
  (*	    16, 17, 18, 19	: print('38400 bps\');		*)
  (*	    20, 21, 22		: print( '48000 bps\');		*)
  (*	    23, 24, 25, 26,					*)
  (*	    27, 28, 29, 30	: print( '56000 bps\')		*)
  (*	  end 							*)
  (*    end;							*)
  (**************************************************************)

  define_proc(PRINT_SPEED_WITH_BPS, PRINT_SPEED_WITH_BPS_ARGS, 
    PRINT_SPEED_WITH_BPS_LOCALS);
    put(dummy_arg(1));
    ifcall(range_check(FIRST_SPEED_CODE, LAST_SPEED_CODE));
      put(dummy_arg(1));
      casecall(FIRST_SPEED_CODE, LAST_SPEED_CODE);
	nextcase(0);
	nextcase(1);
	  print('24\ ');
	endnextcase;

	nextcase(2);
	nextcase(3);
	  print('48\ ');
	endnextcase;

	nextcase(4);
	nextcase(5);
	nextcase(6);
	nextcase(7);
	  print('96\ ');
	endnextcase;

	nextcase(8);
	nextcase(9);
	nextcase(10);
	nextcase(11);
	  print('192\');
	endnextcase;

	nextcase(12);
	nextcase(13);
	nextcase(14);
	nextcase(15);
	  print('288\');
	endnextcase;

	nextcase(16);
	nextcase(17);
	nextcase(18);
	nextcase(19);
	  print('384\');
	endnextcase;

	nextcase(20);
	nextcase(21);
	nextcase(22);
	  print('480\');
	endnextcase;

	nextcase(23);
	nextcase(24);
	nextcase(25);
	nextcase(26);
	nextcase(27);
	nextcase(28);
	nextcase(29);
	nextcase(30);
	  print('560\');
	endnextcase;

      endcase;
      print( '00 bps\ ');
    endtrue;
      print_decimal(dummy_arg(1));
      print(' invalid\ ');
    endfalse; 
    endif;     
  proc_return;


  (*  print_speed *)
  (**************************************************************)
  (*  procedure print_speed(x: integer);			*)
  (*								*)
  (*  begin							*)
  (*    print(', speed \ ');					*)
  (*	if x = 31    						*)
  (*	then print( 'MS\ ')					*)
  (*	else print_speed_with_bps(x);				*)
  (*	print_space(1)						*)
  (*  end ;							*)
  (**************************************************************)

  define_proc(PRINT_SPEED, PRINT_SPEED_ARGS, PRINT_SPEED_LOCALS);
    print(', speed \ ');
    put(dummy_arg(1));
    put(constant(31));
    ifcall(equal);
      print('MS\ ');
    endtrue;
      put(dummy_arg(1));
      call_proc(PRINT_SPEED_WITH_BPS);
    endfalse;
    endif;
  proc_return;

 
  (* print_mxp_and_slot *)
  (**************************************************************)
  (*  procedure print_mxp_and_slot (				*)
  (*    mxp		: integer;				*)
  (*    slot 		: integer  );				*)
  (*								*)
  (*  begin							*)
  (*    if mxp > 0						*)
  (*    then							*)
  (*      begin							*)
  (*  	    print (' mxp \');					*)
  (*	    print_decimal (mxp)					*)
  (*	  end;							*)
  (*								*)
  (*    if (slot > 0) or (mxp > 0)				*)
  (*    then							*)
  (*	  begin							*)
  (*	    print (' slot \ ');					*)
  (*	    print_decimal (slot)				*)
  (*	  end							*)
  (*  end							*)
  (**************************************************************)

  define_proc(PRINT_MXP_AND_SLOT, PRINT_MXP_AND_SLOT_ARGS, 
    PRINT_MXP_AND_SLOT_LOCALS);
    put(dummy_arg(1));
    put(constant(0));
    ifcall(greater_than);
      print(' mxp \');
      print_decimal(dummy_arg(1));
    endtrue;
    endif;

    put(dummy_arg(2));
    put(constant(0));
    put(greater_than);
    put(dummy_arg(1));
    put(constant(0));
    put(greater_than);
    ifcall(orfunc);
      print( ' slot \ ');
      print_decimal(dummy_arg(2));
    endtrue;
    endif;
  proc_return;


  (* print_line *)
  (**************************************************************)
  (*								*)
  (*  procedure print_line(x, l: integer);			*)
  (*								*)
  (*  begin							*)
  (*    line_check(x, l);					*)
  (*    print_node(x);						*)
  (*    format.string( ' line \ ');				*)
  (*    format.number(l, 10)					*)
  (*  end ;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_LINE, PRINT_LINE_ARGS, PRINT_LINE_LOCALS);
    put(dummy_arg(1));
    put(dummy_arg(2));
    line_check;
    print_node(dummy_arg(1));
    print(' line \ ');
    print_decimal(dummy_arg(2));
  proc_return;


  (* print_neighbor_node *)
  (**************************************************************)  
  (*								*)
  (*  procedure print_neighbor_node(x: integer);		*)
  (*								*)
  (*  begin							*)
  (*    print_newline;						*)
  (*    print_space(7);						*)
  (*    print('neighbor \');					*)
  (*    print_node(x)						*)
  (*  end ;							*)
  (*								*)
  (**************************************************************)  

  define_proc(PRINT_NEIGHBOR_NODE, PRINT_NEIGHBOR_NODE_ARGS, 
    PRINT_NEIGHBOR_NODE_LOCALS);
    print_newline;
    print_space(7);
    print('neighbor \');
    print_node(dummy_arg(1));
  proc_return;


  (* print_neighbor_and_occurrency *)
  (**************************************************************)  
  (*								*)
  (*  procedure print_neighbor_and_occurrency(x, y: integer);   *)
  (*								*)
  (*  begin							*)
  (*    if x <= 32768						*)
  (*    then							*)
  (*      print('     an unknown neighbor\ ')			*)
  (*    else							*)
  (*      begin							*)
  (*        print( '     \');					*)
  (*        print_node(x)					*)
  (*      end;							*)
  (*    print(' occurred \ ');					*)
  (*    print_decimal(y);					*)
  (*    print( ' times\ ')					*)
  (*  end ;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_NEIGHBOR_AND_OCCURRENCY, 
    PRINT_NEIGHBOR_AND_OCCURRENCY_ARGS, PRINT_NEIGHBOR_AND_OCCURRENCY_LOCALS);
    put(dummy_arg(1));
    put(constant(32768));
    ifcall(less_or_equal);
      print_space(5);
      print( 'an unknown neighbor\');
    endtrue;
      print_space(5);
      print_node(dummy_arg(1));
    endfalse;
    endif;
      
    print( ' occurred \ ');
    print_decimal(dummy_arg(2));
    print(' times\ ');
  proc_return;


  (* print_pli *)
  (**************************************************************)
  (*								*)
  (*  procedure print_pli(x: integer);				*)
  (*								*)
  (*  begin							*)
  (*    if x > 0						*)
  (*    then							*)
  (*      begin							*)
  (*        format.string(' npli \ ');				*)
  (*	    format.number(x, 10)				*)
  (*  end ;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_PLI, PRINT_PLI_ARGS, PRINT_PLI_LOCALS);
    put(dummy_arg(1));
    put(constant(0));
    ifcall(greater_than);
      print(' npli \ ');
      print_decimal(dummy_arg(1));
    endtrue;
    endif;
  proc_return;


  (* print_unknown_isis_report *)
  (**************************************************************)
  (*								*)
  (*  procedure print_unknown_isis_report(			*)
  (*    typecode: integer;					*)
  (*    data_1  : integer;					*)
  (*	data_2  : integer);					*)
  (*								*)
  (*  begin							*)
  (*    print(' type \ ');					*)
  (*    print_hex(typecode);					*)
  (*    print_space(1);						*)
  (*    print_hex(fullword(data_1, data_2))			*)
  (*  end;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_UNKNOWN_ISIS_REPORT, PRINT_UNKNOWN_ISIS_REPORT_ARGS,
    PRINT_UNKNOWN_ISIS_REPORT_LOCALS);
      print(' type \ ');
      print_hex(dummy_arg(1));
      print_space(1);
      put(dummy_arg(2));
      put(dummy_arg(3));
      print_hex(fullword);
  proc_return;



  (* print_xcom_report *)
  (**************************************************************)
  (*								*)
  (*  print_xcom_report (					*)
  (*    typecode : integer;					*)
  (*    data_1   : integer;					*)
  (*    data_2   : integer);					*)
  (*								*)
  (*								*)
  (*  begin							*)
  (*    print(' line \ ');					*)
  (*    print_decimal(data_1);    				*)
  (*    print(' occurred \ ');					*)
  (*    print_decimal(data_2);					*)
  (*    print(' times\ ');					*)
  (*    print_newline;						*)
  (*    print_space(5);						*)
  (*    if (first_xcom_link_subcode <= typecode) and		*)
  (*      (typecode <= last_xcom_link_subcode)			*)
  (*    then							*)
  (*	  begin							*)
  (*	    if typecode < first_xcom_link_fml_subcode		*)
  (*	    then						*)
  (*	      case typecode of					*)
  (*		16:						*)
  (*		  print('incoming call reqst timer expired\');*)
  (*		17:						*)
  (*		  print('clear confirmation timer expired\');	*)
  (*		18:						*)
  (*		  print('restart confirmation timer expired\'); *)
  (*		19:						*)
  (*		  print('reset confirmation timer expired\');	*)
  (*		20:						*)
  (*		  print('call abnormally cleared at packet level\');	*)
  (*		21:						*)
  (*		  print('call reset at packet level\');		*)
  (*		22:						*)
  (*		  print('incoming call rejected\');		*)
  (*		23:						*)
  (*		  print('call reset pad parameter block unavailable\');	*)
  (*		24:						*)
  (*		  print('buffer zaped\');			*)
  (*		25:						*)
  (*		  print('packet ignored due to bad GFI\');	*)
  (*		26:						*)
  (*		  print('short packet ignored\');		*)
  (*		27:						*)
  (*		  print('sent clear reqst on out of range channel\');	*)
  (*		28:						*)
  (*		  print('recv a not clear confirmation packet on out of range channel\');	*)
  (*		29:						*)
  (*		  print('recv a clear indication on DCE waiting channel\');*)
  (*		30:						*)
  (*		  print('recv a clear indication on DCE clear reqst channel\');	*)
  (*		31:						*)
  (*		  print('recv a clear indication on flow control ready channel\');	*)
  (*		32:						*)
  (*		  print('recv unacceptable packet, ignored it\');	*)
  (*		33:						*)
  (*		  print('recv incorrected Q-bit packet\');	*)
  (*		34:						*)
  (*		  print('error reference or value in Q-bit packet\');	*)
  (*		35:						*)
  (*		  print('recv unknown PAD parameter error message\')	*)
  (*	      end "case"					*)
  (*	    else						*)
  (*	      begin						*)
  (*		print('FML: \');				*)
  (*		case typecode of				*)
  (*		  36:						*)
  (*		    print('all lines detected down due to no clocks or marking state\');	*)
  (*		  37:						*)
  (*		    print('recv a less than 3 bytes frame\');	*)
  (*		  38:						*)
  (*		    print('recv a too much data frame\');	*)
  (*		  39:						*)
  (*		    print('recv a MOD128 that contained M(R)\');*)
  (*		  40:						*)
  (*		    print('recv a MOD64 that contained M(R) or invalid B address field\');	*)
  (*		  41:						*)
  (*		    print('recv reset reqst or confirmation\');	*)
  (*		  42:						*)
  (*		    print('no memory available to recv frame\');*)
  (*		  43:						*)
  (*		    print('recv empty frame with N(S) outside window\');*)
  (*		  44:						*)
  (*		    print('recv frame with N(S) outside window\');	*)
  (*		  45:						*)
  (*		    print('recv frame with bad N(R) queued up reset frame\');*)
  (*		  46:						*)
  (*		    print('reset reqst recv and link down\');	*)
  (*		  47:						*)
  (*		    print('link in reset state recv reset reqst\');	*)
  (*		  48:						*)
  (*		    print('link in send reset confirmation state recv reset reqst\');*)
  (*		  49:						*)
  (*		    print('reset reqst recv but link asleep for FMLTD second\');	*)
  (*		  50:						*)
  (*		    print('reset reqst recv and link asleep on xmit but can recv frames\');*)
  (*		  51:						*)
  (*		    print('reset reqst recv but link in info xfer or rexmit state\');*)
  (*		  52:						*)
  (*		    print('recv reset confirmation but link down\');	*)
  (*		  53:						*)
  (*		    print('link in reset state recv reset confirmation\');*) 
  (*		  54:						*)
  (*		    print('link in reset confirmation state recv reset confirmation\');*)
  (*		  55:						*)
  (*		    print('reset confirmation recv and link asleep for 2*FMLTD seconds\');*)
  (*		  56:						*)
  (*		    print('reset confirmation recv but link in info xfer or rexmit state\');*)
  (*  		  57:						*)
  (*		    print('ignored a too long clear reqst packet\')	*)
  (*		end "case"					*)
  (*	      end						*)
  (*	  end							*)
  (*    else if (first_xcom_line_subcode <= typecode)		*)
  (*	  (typecode <= last_xcom_line_subcode)			*)
  (*	then							*)
  (*	  case typecode of					*)
  (*	    128:						*)
  (*	      print('timeout occurred during frame xmit\');	*)
  (*	    129:						*)
  (*	      print('recv retransmissions\');			*)
  (*	    130:						*)
  (*	      print('line is looping back\');			*)
  (*	    131:						*)
  (*	      print('idle line counts\');			*)
  (*	    132:						*)
  (*	      print('frame ignored due to lack of buffer space\');*)
  (*	    133:						*)
  (*	      print('xmitted reset frame, line in reset state\');*)
  (*	    134:						*)
  (*	      print('invalid N(S) or N(R), reset sent\');	*)
  (*	    135:						*)
  (*	      print('recv disconnect frame error\');		*)
  (*	    136:						*)
  (*	      print('sio missing clocks, link reinitialized\'); *)
  (*	    137:						*)
  (*	      print('sio overrun interrupt occurred\');		*)
  (*	    138:						*)
  (*	      print('HDLC: input frame longer than max frame size, frame ignored\');	*)
  (*	      print('BSC: DLE/EOT abort sequence recv\');	*)
  (*	    139:						*)
  (*	      print('HDLC: input frame too short\');		*)
  (*	      print('BSC: DLE char not following initial sync char\');*)
  (*	    140:						*)
  (*	      print('STX missing after initial DLE char\');	*)
  (*	    141:						*)
  (*	      print('BSC: improper char after a DLE\');		*)
  (*	    142:						*)
  (*	      print('frame has an incorrect address\');		*)
  (*	    143:						*)
  (*	      print('frame missing an end flag\');		*)
  (*	    144:						*)
  (*	      print('frame had bad checksum\');			*)
  (*	    145:						*)
  (*	      print(HDLC: recv FRMR/CMDR with wrong byte count\');*)
  (*	      print(BSC: recv I-FRAME with invalid address\');	*)
  (*	    146:						*)
  (*	      print('LAP/LAPB: response other than CMDR/FRMR recv with wrong byte count\');*)
  (*	      print('FML: secondary recv I-FRAME when not armed\');*)
  (*	    147:						*)
  (*	      print('maximum frame count exceeded\');		*)
  (*	    148:						*)
  (*	      print('sent FRMR or CMDR\');			*)
  (*	    149:						*)
  (*	      print('sent reject frame due to sequence error\');*)
  (*	    150:						*)
  (*	      print('sent reject frame due to frame discarded\');*)
  (*	    151:						*)
  (*	      print('reject frame recv in info xfer state\');	*)
  (*	    152:						*)
  (*	      print('entered timer recovery state\');		*)
  (*	    153:						*)
  (*	      print('entered reset state\');			*)
  (*	    154:						*)
  (*	      print('recv on secondary an invalid command or control field\');*)
  (*	      print('while not armed\');			*)
  (*	    155:						*)
  (*	      print('recv on secondary a SARM in disconnect state\');*)
  (*	    156:						*)
  (*	      print('recv on secondary a I-FRAME in disconnect state\');*)
  (*	    157:						*)
  (*	      print('recv on primary an illegal control field in info xfer state\');*)
  (*	    158:						*)
  (*	      print('recv on primary an I-FRAME error\');	*)
  (*	    159:						*)
  (*	      print('recv RR in timer recovery acked all outstanding frame\');*)
  (*	      print('but F bit not set\');			*)
  (*	    160:						*)
  (*	      print('recv reject in timer recovery not acked all frames\');*)
  (*	      print('and F bit was not set\');			*)
  (*	    161:						*)
  (*	      print('recv reject in timer recovery acked all frames\');*)
  (*	      print('but F bit not set\');			*)
  (*	    162:						*)
  (*	      print('recv reject in timer recovery not acked any outstanding frames\');*)
  (*	    163:						*)
  (*	      print('sent disconnect on primary due to not recv a SARM in return\'); *)
  (*	    164:						*)
  (*	      print('recv no UA after sent max disconnects\');	*)
  (*	    165:						*)
  (*	      print('primary wait secondary to disconnect but never recv disconnect\');*)
  (*	      print('from secondary after sending disconnect max times\');*)
  (*	    166:						*)
  (*	      print('sent a reset (SARM) max times without recv an UA and\');*)
  (*	      print('secondary still armed, a disconnect was sent\');*)
  (*	    167:						*)
  (*	      print('recv on primary an CMDR in info xfer state\');*)
  (*	    168:						*)
  (*	      print('recv on secondary a SARM in info xfer state\');*)
  (*	      print('or in CMDR condition\');			*)
  (*	    169:						*)
  (*	      print('recv an empty I-FRAME\');			*)
  (*	    170:						*)
  (*	      print('sent FRMR/CMDR on secondary\')		*)
  (*	  end "case"						*)
  (*	else							*)
  (*	  print_unknown_isis_report(typecode, data_1, data_2))	*)
  (*  end;							*)
  (**************************************************************)

  define_proc(PRINT_XCOM_REPORT, PRINT_XCOM_REPORT_ARGS,
    PRINT_XCOM_REPORT_LOCALS);
    print(' line \ ');					
    print_decimal(dummy_arg(2));    				
    print(' occurred \ ');					
    print_decimal(dummy_arg(3));					
    print(' times\ ');					
    print_newline;						
    print_space(5);						
    put(dummy_arg(1));
    ifcall(range_check(FIRST_XCOM_LINK_SUBCODE, LAST_XCOM_LINK_SUBCODE));
      put(dummy_arg(1));
      put(constant(FIRST_XCOM_LINK_FML_SUBCODE));
      ifcall(less_than);
	put(dummy_arg(1));
	casecall(FIRST_XCOM_LINK_SUBCODE, MIDDLE_XCOM_LINK_SUBCODE);
  	  nextcase(16);						
    	    print('incoming call reqst timer expired\');
	  endnextcase;

  	  nextcase(17);						
    	    print('clear confirmation timer expired\ ');	
	  endnextcase;

  	  nextcase(18);						
    	    print('restart confirmation timer expired\ '); 
	  endnextcase;

  	  nextcase(19);						
    	    print('reset confirmation timer expired\ ');	
	  endnextcase;

  	  nextcase(20);						
    	    print('call abnormally cleared at packet level\');	
	  endnextcase;

  	  nextcase(21);						
    	    print('call reset at packet level\ ');		
	  endnextcase;

  	  nextcase(22);						
    	    print('incoming call rejected\ ');		
	  endnextcase;

  	  nextcase(23);						
    	    print('call reset pad parameter block unavailable\ ');	
	  endnextcase;

  	  nextcase(24);						
    	    print('buffer zaped\ ');			
	  endnextcase;

  	  nextcase(25);						
    	    print('packet ignored due to bad GFI\');	
	  endnextcase;

  	  nextcase(26);						
    	    print('short packet ignored\ ');		
	  endnextcase;

  	  nextcase(27);						
    	    print('sent clear reqst on out of range channel\ ');	
	  endnextcase;

  	  nextcase(28);						
    	    print('recv a not clear confirmation packet on out of range channel\ ');	
	  endnextcase;

  	  nextcase(29);						
    	    print('recv a clear indication on DCE waiting channel\ ');
	  endnextcase;

  	  nextcase(30);						
    	    print('recv a clear indication on DCE clear reqst channel\ ');	
	  endnextcase;

  	  nextcase(31);						
    	    print('recv a clear indication on flow control ready channel\');	
	  endnextcase;

  	  nextcase(32);						
    	    print('recv unacceptable packet, ignored it\ ');	
	  endnextcase;

  	  nextcase(33);						
    	    print('recv incorrected Q-bit packet\');	
	  endnextcase;

  	  nextcase(34);						
    	    print('error reference or value in Q-bit packet\ ');	
	  endnextcase;

  	  nextcase(35);						
    	    print('recv unknown PAD parameter error message\ ');
	  endnextcase;

        endcase;
      endtrue;
  	print('FML: \');				
	put(dummy_arg(1));
	casecall(FIRST_XCOM_LINK_FML_SUBCODE, LAST_XCOM_LINK_SUBCODE);
    	  nextcase(36);						
      	    print('all lines detected down due to no clocks\ ');
	    print_newline;
	    print_space(5);
	    print('or marking state\ ');	
	  endnextcase;

    	  nextcase(37);						
      	    print('recv a less than 3 bytes frame\ ');	
	  endnextcase;

    	  nextcase(38);						
      	    print('recv a too much data frame\ ');	
	  endnextcase;

    	  nextcase(39);						
      	    print('recv a MOD128 that contained M(R)\');
	  endnextcase;

    	  nextcase(40);						
      	    print('recv a MOD64 that contained M(R) or\');
  	    print_newline;
	    print_space(5);
	    print('invalid B address field\');	
	  endnextcase;

    	  nextcase(41);						
      	    print('recv reset reqst or confirmation\ ');	
	  endnextcase;

    	  nextcase(42);						
      	    print('no memory available to recv frame\');
	  endnextcase;

    	  nextcase(43);						
      	    print('recv empty frame with N(S) outside window\');
	  endnextcase;

    	  nextcase(44);						
      	    print('recv frame with N(S) outside window\');	
	  endnextcase;

    	  nextcase(45);						
      	    print('recv frame with bad N(R) queued up reset frame\ ');
	  endnextcase;

    	  nextcase(46);						
      	    print('reset reqst recv and link down\ ');	
	  endnextcase;

    	  nextcase(47);						
      	    print('link in reset state recv reset reqst\ ');	
	  endnextcase;

    	  nextcase(48);						
      	    print('link in send reset confirmation state\');
	    print_newline;
	    print_space(5);
	    print('recv reset reqst\ ');
	  endnextcase;

    	  nextcase(49);						
      	    print('reset reqst recv but link asleep for FMLTD second\');	
	  endnextcase;

    	  nextcase(50);						
      	    print('reset reqst recv and link asleep on xmit\ ');
	    print_newline;
	    print_space(5);
	    print('but can recv frames\');
	  endnextcase;

    	  nextcase(51);						
      	    print('reset reqst recv but link in info xfer or rexmit state\ ');
	  endnextcase;

    	  nextcase(52);						
      	    print('recv reset confirmation but link down\');	
	  endnextcase;

    	  nextcase(53);						
      	    print('link in reset state recv reset confirmation\'); 
	  endnextcase;

    	  nextcase(54);						
      	    print('link in reset confirmation state recv reset confirmation\ ');
	  endnextcase;

    	  nextcase(55);						
      	    print('reset confirmation recv and link asleep\');
	    print_newline;
	    print_space(5);
	    print('for 2*FMLTD seconds\');
	  endnextcase;

    	  nextcase(56);						
      	    print('reset confirmation recv but link in info xfer\');
	    print_newline;
	    print_space(5);
	    print('or rexmit state\');
	  endnextcase;

    	  nextcase(57);						
      	    print('ignored a too long clear reqst packet\');
	  endnextcase;

        endcase;
      endfalse;
      endif;
    endtrue;

    put(dummy_arg(1));
    elseifcall(range_check(FIRST_XCOM_LINE_SUBCODE, LAST_XCOM_LINE_SUBCODE));
      put(dummy_arg(1));
      casecall(FIRST_XCOM_LINE_SUBCODE, LAST_XCOM_LINE_SUBCODE);
        nextcase(128);						
          print('timeout occurred during frame xmit\ ');	
	endnextcase;

        nextcase(129);						
          print('recv retransmissions\ ');			
	endnextcase;

        nextcase(130);						
          print('line is looping back\ ');			
	endnextcase;

        nextcase(131);						
          print('idle line counts\ ');			
	endnextcase;

        nextcase(132);						
          print('frame ignored due to lack of buffer space\');
	endnextcase;

        nextcase(133);						
          print('xmitted reset frame, line in reset state\ ');
	endnextcase;

        nextcase(134);						
          print('invalid N(S) or N(R), reset sent\ ');	
	endnextcase;

        nextcase(135);						
          print('recv disconnect frame error\');		
	endnextcase;

        nextcase(136);						
          print('sio missing clocks, link reinitialized\ '); 
	endnextcase;

        nextcase(137);						
          print('sio overrun interrupt occurred\ ');		
	endnextcase;

        nextcase(138);						
          print('HDLC: input frame longer than max frame size, frame ignored\');	
	  print_newline;
	  print_space(5);
          print('BSC: DLE/EOT abort sequence recv\ ');	
	endnextcase;

        nextcase(139);						
          print('HDLC: input frame too short\');		
	  print_newline;
	  print_space(5);
          print('BSC: DLE char not following initial sync char\');
	endnextcase;

        nextcase(140);						
          print('STX missing after initial DLE char\ ');	
	endnextcase;

        nextcase(141);						
          print('BSC: improper char after a DLE\ ');		
	endnextcase;

        nextcase(142);						
          print('frame has an incorrect address\ ');
	endnextcase;

        nextcase(143);						
          print('frame missing an end flag\');		
	endnextcase;

        nextcase(144);						
          print('frame had bad checksum\ ');			
	endnextcase;

        nextcase(145);						
          print('HDLC: recv FRMR/CMDR with wrong byte count\ ');
	  print_newline;
  	  print_space(5);
          print('BSC: recv I-FRAME with invalid address\ ');	
	endnextcase;

        nextcase(146);						
          print('LAP/LAPB: response other than CMDR/FRMR recv with wrong byte count\ ');
	  print_newline;
	  print_space(5);
          print('FML: secondary recv I-FRAME when not armed\ ');
	endnextcase;

        nextcase(147);						
          print('maximum frame count exceeded\ ');		
	endnextcase;

        nextcase(148);						
          print('sent FRMR or CMDR\');			
	endnextcase;

        nextcase(149);						
          print('sent reject frame due to sequence error\');
	endnextcase;

        nextcase(150);						
          print('sent reject frame due to frame discarded\ ');
	endnextcase;

        nextcase(151);						
          print('reject frame recv in info xfer state\ ');	
	endnextcase;

        nextcase(152);						
          print('entered timer recovery state\ ');		
	endnextcase;

        nextcase(153);						
          print('entered reset state\');			
	endnextcase;

        nextcase(154);						
          print('recv on secondary an invalid command or control field\');
	  print_newline;
	  print_space(5);
          print('while not armed\');			
	endnextcase;

        nextcase(155);						
          print('recv on secondary a SARM in disconnect state\ ');
	endnextcase;

        nextcase(156);						
          print('recv on secondary a I-FRAME in disconnect state\');
	endnextcase;

        nextcase(157);						
          print('recv on primary an illegal control field in info xfer state\');
	endnextcase;

        nextcase(158);						
          print('recv on primary an I-FRAME error\ ');	
	endnextcase;

        nextcase(159);						
          print('recv RR in timer recovery acked all outstanding frame\');
	  print_newline;
	  print_space(5);
          print('but F bit not set\');			
	endnextcase;

        nextcase(160);						
          print('recv reject in timer recovery not acked all frames\ ');
	  print_newline;
	  print_space(5);
          print('and F bit was not set\');			
	endnextcase;

        nextcase(161);						
          print('recv reject in timer recovery acked all frames\ ');
	  print_newline;
	  print_space(5);
          print('but F bit not set\');			
	endnextcase;

        nextcase(162);						
          print('recv reject in timer recovery not acked any outstanding frames\ ');
	endnextcase;

        nextcase(163);						
          print('sent disconnect on primary due to not recv a SARM in return\'); 
	endnextcase;

        nextcase(164);						
          print('recv no UA after sent max disconnects\');	
	endnextcase;

        nextcase(165);						
          print('primary wait secondary to disconnect but never recv disconnect\ ');
	  print_newline;
	  print_space(5);
          print('from secondary after sending disconnect max times\');
	endnextcase;

        nextcase(166);						
          print('sent a reset (SARM) max times without recv an UA and\ ');
	  print_newline;
	  print_space(5);
          print('secondary still armed, a disconnect was sent\ ');
	endnextcase;

        nextcase(167);						
          print('recv on primary an CMDR in info xfer state\ ');
	endnextcase;

        nextcase(168);						
          print('recv on secondary a SARM in info xfer state\');
	  print_newline;
	  print_space(5);
          print('or in CMDR condition\ ');			
	endnextcase;

        nextcase(169);						
          print('recv an empty I-FRAME\');			
	endnextcase;

        nextcase(170);						
          print('sent FRMR/CMDR on secondary\');
	endnextcase;
      endcase;
    endtrue;

      put(dummy_arg(1));
      put(dummy_arg(2));
      put(dummy_arg(3));
      call_proc(PRINT_UNKNOWN_ISIS_REPORT);
    endfalse;
    endif;
  proc_return;


  (* print_kernel_report *)
  (**************************************************************)
  (*								*)
  (*  procedure print_kernel_report (				*)
  (*    typecode: integer;					*)
  (*    data_1  : integer;					*)
  (*    data_2  : integer);					*)
  (*								*)
  (*  begin							*)
  (*    if typecode = 255					*)
  (*    then							*)
  (*      begin							*)
  (*	    if data_1 = 0					*)
  (*	    then						*)
  (*	      print(', background\ ')				*)
  (*	    else						*)
  (*	      print(', foreground\ ');				*)
  (*	    print_newline;					*)
  (*	    print_space(5);					*)
  (*	    print('overload occurred \ ');			*)
  (*	    print_decimal(data_2);				*)
  (*	    print(' times\')					*)
  (*	  end							*)
  (*	else if typecode = 2					*)
  (*	then							*)
  (*	  begin							*)
  (*	    if data_1 = 0					*)
  (*	    then print(', ISIS kernel crashed\')		*)
  (*	    else						*)
  (*	      begin						*)
  (*		print(', MAC reg. \');				*)
  (*		print_hex(data_1);				*)
  (*		print(' failed\')				*)
  (*	      end;						*)
  (*	    print_newline;					*)
  (*	    print_space(5);					*)
  (*	    print('MAC reg. sets in use: \');			*)
  (*	    print_mac_reg_sets(data_2)				*)
  (*	  end							*)
  (*	else if typecode = 3					*)
  (*	then							*)
  (*	  begin							*)
  (*	    if fullword(data_1, data_2) = 0			*)
  (*	    then print(', bound file missing monitor slot code\')	*)
  (*	    else print_unknown_isis_report(typecode, data_1, data_2) 	*)
  (*	  end							*)
  (*	else							*)
  (*	  print_unknown_isis_report(typecode, data_1, data_2)	*)
  (*  end;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_KERNEL_REPORT, PRINT_KERNEL_REPORT_ARGS,
    PRINT_KERNEL_REPORT_LOCALS);
    print(', \ ');
    put(dummy_arg(1));
    put(constant(255));
    ifcall(equal);
      put(dummy_arg(2));
      put(constant(0));
      ifcall(equal);
	print('background\ ');	
      endtrue;
	print('foreground\ ');
      endfalse;
      endif;
      print_newline;
      print_space(5);
      print('overload occurred \ ');
      print_decimal(dummy_arg(3));
      print(' times\ ');      
    endtrue;

    put(dummy_arg(1));
    put(constant(2));
    elseifcall(equal);
      put(dummy_arg(2));
      put(constant(0));
      ifcall(equal);
        print('ISIS kernel crashed\');
      endtrue;
	print('MAC reg. \');
	print_hex(dummy_arg(2));
	print(' failed\');
      endfalse;
      endif;
      print_newline;
      print_space(5);
      print('MAC reg. sets in use: \ ');
      print_mac_reg_sets(dummy_arg(3));
    endtrue;

    put(dummy_arg(1));
    put(constant(3));
    elseifcall(equal);
      put(dummy_arg(2));
      put(dummy_arg(3));
      put(fullword);
      put(constant(0));
      ifcall(equal);
	print('bound file missing monitor slot code\ ');
      endtrue;
	put(dummy_arg(1));
	put(dummy_arg(2));
	put(dummy_arg(3));
	call_proc(PRINT_UNKNOWN_ISIS_REPORT);
      endfalse;
      endif;
    endtrue;
      
      put(dummy_arg(1));
      put(dummy_arg(2));
      put(dummy_arg(3));
      call_proc(PRINT_UNKNOWN_ISIS_REPORT);
    endfalse;
    endif;
  proc_return;


  (* print_ontyme_report *)
  (**************************************************************)
  (*  procedure print_ontyme_report (				*)
  (*    typecode: integer;					*)
  (*    data_1	: integer;					*)
  (*	data_2	: integer);					*)
  (*								*)
  (*  begin							*)
  (*    if (FIRST_ONTYME_SUBCODE <= typecode) and		*)
  (*	  (typecode <= LAST_ONTYME_SUBCODE)			*)
  (*	then							*)
  (*	  begin							*)
  (*	    print(', \');					*)
  (*	    case typecode of					*)
  (*	    16: 						*)
  (*	      begin						*)
  (*		print('disk \');				*)
  (*		print_decimal(data_2);				*)
  (*		print(' is down\')				*)
  (*	      end;						*)
  (*	    17:							*)
  (*	      print('outdial enable is off\');			*)
  (*	    18: 						*)
  (*	      begin						*)
  (*		print('disk \');				*)
  (*		print_decimal(data_2);				*)
  (*		print(' failed at slot restart\')		*)
  (*	      end;						*)
  (*	    19:							*)
  (*	      print('data integrity error in VAT\');		*)
  (*	    20:							*)
  (*	      print('data integrty error in VFDD\')		*)
  (*	  end "case"						*)
  (*	else							*)
  (*	  print_unknown_isis_report(typecode, data_1, data_2)	*)
  (*  end;							*)
  (**************************************************************)

  define_proc(PRINT_ONTYME_REPORT, PRINT_ONTYME_REPORT_ARGS,
    PRINT_ONTYME_REPORT_LOCALS);
    put(dummy_arg(1));
    ifcall(range_check(FIRST_ONTYME_SUBCODE, LAST_ONTYME_SUBCODE));
      print(', \ ');
      put(dummy_arg(1));
      casecall(FIRST_ONTYME_SUBCODE, LAST_ONTYME_SUBCODE);
	nextcase(16); 						
	  print('disk \');				
	  print_decimal(dummy_arg(3));				
	  print(' is down\ ');
	endnextcase;						

	nextcase(17);							
          print('outdial enable is off\');			
	endnextcase;

	nextcase(18); 						
	  print('disk \');				
	  print_decimal(dummy_arg(3));				
	  print(' failed at slot restart\');
	endnextcase;						

	nextcase(19);							
	  print('data integrity error in VAT\');		
	endnextcase;

	nextcase(20);							
	  print('data integrty error in VFDD\');
	endnextcase;
      endcase;
    endtrue;
      put(dummy_arg(1));
      put(dummy_arg(2));
      put(dummy_arg(3));
      call_proc(PRINT_UNKNOWN_ISIS_REPORT);
    endfalse;
    endif;
  proc_return;


  (* print_ram_report *)
  (**************************************************************)
  (*								*)
  (*  print_ram_report (					*)
  (*    typecode : integer;					*)
  (*    data_1   : integer;					*)
  (*    data_2   : integer);					*)
  (*								*)
  (*  var							*)
  (*    data: integer;						*)
  (*								*)
  (*  begin							*)
  (*    data := fullword(data_1, data_2);			*)
  (*    if (first_ram_subcode <= typecode) and			*)
  (*      (typecode <= last_ram_subcode)			*)
  (*    then							*)
  (*      case typecode of					*)
  (*	    34: print('tape not ready or in use\');		*)
  (*	    35:							*)
  (*	      begin						*)
  (*		print('disk \');				*)
  (*	        case data of					*)
  (*		  1: print('area too small\');			*)
  (*		  2: print('had bad status\');			*)
  (*		  3: print('had checksum error\')		*)
  (*		end "case"					*)
  (*	      end;						*)
  (*	    36: 						*)
  (*	      begin						*)
  (*		print('ignored \');				*)
  (*		print_decimal(data);				*)
  (*		print(' invalid records\')			*)
  (*	      end;						*)
  (*	    37:							*)
  (*	      begin						*)
  (*		print('detected \');				*)
  (*		print_decimal(data);				*)
  (*		print(' bad checksums\')			*)
  (*	      end;						*)
  (*	    38: 						*)
  (*	      print_unknown_isis_report(typecode, data_1, data_2); *)
  (*	    39:							*)
  (*	      begin						*)
  (*		print('primary session pool overflowed\');	*)
  (*		print_newline;					*)
  (*		print_space(5);					*)
  (*		print_decimal(data);				*)
  (*		print(' times\')				*)
  (*	      end;						*)
  (*	    40:							*)
  (*	      begin						*)
  (*		print('discrepancy in session number\');	*)
  (*		print_newline;					*)
  (*		print_space(5);					*)
  (*		print_decimal(data);				*)
  (*		print(' abnormal increments\')			*)
  (*	      end;						*)
  (*	    41:							*)
  (*	      begin						*)
  (*		print('supervisor passed RAM\');		*)
  (*		print_newline;					*)
  (*		print_space(5);					*)
  (*		print('accounting block number \');		*)
  (*		print_decimal(data)				*)
  (*	      end;						*)
  (*	    42:							*)
  (*  	      begin						*)
  (*		print('secondary session pool overflow\');	*)
  (*		print_newline;					*)
  (*		print_space(5);					*)
  (*		print_decimal(data);				*)
  (*		print(' times\')				*)
  (*	      end						*)
  (*      end "case"						*)
  (*    else 							*)
  (*	  print_unknown_isis_report(typecode, data_1, data_2)	*)
  (*  end ;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_RAM_REPORT, PRINT_RAM_REPORT_ARGS, 
    PRINT_RAM_REPORT_LOCALS);
    put(dummy_arg(2));
    put(dummy_arg(3));
    store_var(1, fullword);
    put(dummy_arg(1));
    ifcall(range_check(FIRST_RAM_SUBCODE, LAST_RAM_SUBCODE));
      print(', \ ');
      put(dummy_arg(1));
      casecall(FIRST_RAM_SUBCODE, LAST_RAM_SUBCODE);
        nextcase(34);
	  print('tape not ready or in use\ ');		
	endnextcase;

        nextcase(35);							
  	  print('disk \');				
	  put(local_var(1));
	  casecall(1, 3);
  	    nextcase(1);
	      print('area too small\ ');			
	    endnextcase;

  	    nextcase(2);
	      print('had bad status\ ');			
	    endnextcase;

  	    nextcase(3);
	      print('had checksum error\ ');
	    endnextcase;
	  endcase;
        endnextcase;

        nextcase(36); 						
  	  print('ignored \ ');				
  	  print_decimal(local_var(1));				
  	  print(' invalid records\ ');			
        endnextcase;
						
        nextcase(37);							
  	  print('detected \');				
  	  print_decimal(local_var(1));				
  	  print(' bad checksums\ ');
        endnextcase;
						
        nextcase(38);
	  put(dummy_arg(1));
	  put(dummy_arg(2));
	  put(dummy_arg(3));
	  call_proc(PRINT_UNKNOWN_ISIS_REPORT);	 
	endnextcase;

        nextcase(39);							
  	  print('primary session pool overflowed\');	
  	  print_newline;					
  	  print_space(5);					
  	  print_decimal(local_var(1));				
  	  print(' times\ ');
        endnextcase;
						
        nextcase(40);							
  	  print('discrepancy in session number\');	
  	  print_newline;					
  	  print_space(5);					
  	  print_decimal(local_var(1));				
  	  print(' abnormal increments\ ');
        endnextcase;
						
        nextcase(41);							
  	  print('supervisor passed RAM\');		
  	  print_newline;					
  	  print_space(5);					
  	  print('accounting block number \ ');		
  	  print_decimal(local_var(1));
        endnextcase;
						
        nextcase(42);							
  	  print('secondary session pool overflow\');	
  	  print_newline;					
  	  print_space(5);					
  	  print_decimal(local_var(1));				
  	  print(' times\ ');
        endnextcase;
      endcase;						
    endtrue;
      put(dummy_arg(1));
      put(dummy_arg(2));
      put(dummy_arg(3));
      call_proc(PRINT_UNKNOWN_ISIS_REPORT);
    endfalse;
    endif;
  proc_return;



  (* print_val_report *)
  (**************************************************************)
  (*  procedure print_val_report (				*)
  (*    typecode: integer;					*)
  (*    data_1	: integer;					*)
  (*	data_2	: integer);					*)
  (*								*)
  (*  begin							*)
  (*    if typecode = FIRST_VAL_SUBCODE 			*)
  (*	then							*)
  (*	  begin							*)
  (*	    print(', disk \');					*)
  (*	    print_decimal(data_2);				*)
  (*	    print(' is down or offline\');			*)
  (*	  end							*)
  (*	else							*)
  (*	  print_unknown_isis_report(typecode, data_1, data_2)	*)
  (*  end;							*)
  (**************************************************************)

  define_proc(PRINT_VAL_REPORT, PRINT_VAL_REPORT_ARGS,
    PRINT_VAL_REPORT_LOCALS);
    put(dummy_arg(1));
    put(constant(FIRST_VAL_SUBCODE));
    ifcall(equal);
      print(', disk \');
      print_decimal(dummy_arg(3));
      print(' is down or offline\');
    endtrue;
      put(dummy_arg(1));
      put(dummy_arg(2));
      put(dummy_arg(3));
      call_proc(PRINT_UNKNOWN_ISIS_REPORT);
    endfalse;
    endif;
  proc_return;


  (* print_tmcs_report *)
  (**************************************************************)
  (*  procedure print_tmcs_report (				*)
  (*    typecode: integer;					*)
  (*    data_1	: integer;					*)
  (*	data_2	: integer);					*)
  (*								*)
  (*  begin							*)
  (*    if typecode = FIRST_TMCS_SUBCODE 			*)
  (*	then							*)
  (*	  begin							*)
  (*	    print(', shut link table maintainer of\ ');		*)
  (*  	    print_newline;					*)
  (*        print_space(5);					*)
  (*  	    print_host(data_2);					*)
  (*	    print(' is awake\')					*)
  (*	  end							*)
  (*	else							*)
  (*	  print_unknown_isis_report(typecode, data_1, data_2)	*)
  (*  end;							*)
  (**************************************************************)

  define_proc(PRINT_TMCS_REPORT, PRINT_TMCS_REPORT_ARGS,
    PRINT_TMCS_REPORT_LOCALS);
    put(dummy_arg(1));
    put(constant(FIRST_TMCS_SUBCODE));
    ifcall(equal);
      print(', shut link table maintainer of\');
      print_newline;
      print_space(5);
      print_host(dummy_arg(3));
      print(' is awake\');
    endtrue;
      put(dummy_arg(1));
      put(dummy_arg(2));
      put(dummy_arg(3));
      call_proc(PRINT_UNKNOWN_ISIS_REPORT);
    endfalse;
    endif;
  proc_return;



  (* print_isis_report *)
  (**************************************************************)
  (*								*)
  (*  procedure print_isis_report (				*)
  (*  node		: integer;				*)
  (*  slot		: integer;				*)
  (*  kernel		: boolean;				*)
  (*  hw2		: integer;				*)
  (*  hw3		: integer;				*)
  (*  hw4		: integer);				*)
  (*								*)
  (*  const							*)
  (*    product_offset 	= 48 ;					*)
  (*    first_isis_crash_code = 0;				*)
  (*    last_isis_crash_code 	= 21;				*)
  (*								*)
  (*  var							*)
  (*    subcode	: integer;					*)
  (*    value_1	: integer;					*)
  (*    value_2	: integer;					*)
  (*	product : integer;					*)
  (*								*)
  (*  begin							*)
  (*    subcode := hw2;						*)
  (*    value_1 := hw3;						*)
  (*    value_2 := hw4;						*)
  (*    print_node(node);					*)
  (*    print(' node report from\');				*)
  (*    if kernel						*)
  (*    then print(' kernel\')					*)
  (*    else print_mxp_and_slot (				*)
  (*  	      event_operator.substr(slot, 3, 4),		*)
  (*  	      event_operator.substr(slot, 4, 0));		*)
  (*								*)
  (*    if (not kernel and (hw2 > product_offset)) or 		*)
  (*	  (kernel and (hw2 = I2IS_PID))				*)
  (*    then							*)
  (*  	  begin							*)
  (*        if not kernel					*)
  (*	    then						*)
  (*	      begin						*)
  (*  	        print_space(1);					*)
  (*	        print_product(hw2)				*)
  (*	      end;						*)
  (*	    product := hw2;					*)
  (*	    subcode := substr(hw3, 8, 8);			*)
  (*	    value_1 := substr(hw3, 8, 0);			*)
  (*	    value_2 := hw4					*)
  (*      end							*)
  (*    else if kernel						*)
  (*    then product := I2IS_PID				*)
  (*    else product := UNKNOWN_PID;				*)
  (*								*)
  (*    if subcode < 2						*)
  (*    then							*)
  (*      case subcode of					*)
  (*        0:							*)
  (*  	      begin						*)
  (*  	        print(' buffer zap\');				*)
  (*            print_newline;					*)
  (*            print( '     buffer number: \ ');		*)
  (*            if hw2 > product_offset				*)
  (*            then 						*)
  (*              print_hex(value_2)				*)
  (*            else						*)
  (*              print_hex(value_1);				*)
  (*								*)
  (*    	print(', count: \');				*)
  (*            if hw2 > product_offset				*)
  (*            then 						*)
  (*              print_decimal(value_1*1024)			*)
  (*            else 						*)
  (*              print_decimal(value_2);			*)
  (*								*)
  (*            print( ' characters\')				*)
  (*          end  ;						*)
  (*								*)
  (*        1:							*)
  (*          begin						*)
  (*	        print(' crash, count: \');			*)
  (*	        if hw2 > product_offset				*)
  (*	        then 						*)
  (*	          print_decimal(substr(value_2, 8, 8))		*)
  (*	        else						*)
  (*	          print_decimal(value_2);			*)
  (*								*)
  (*	        print_newline;					*)
  (*	        print( '     type: \');				*)
  (*	        if (first_isis_crash_code <= value_1) and	*)
  (*	        (value_1 <= last_isis_crash_code)		*)
  (*	        then						*)
  (*	          case value_1 of				*)
  (*	            0:  print( 'power failure\');		*)
  (*	            1:  print( 'manual restart\ ');		*)
  (*	            3:  print( 'buffer no. out of range in GCI\ ');	*)
  (*	            4:  print('buffer no. out of range in MCI\ ');	*)
  (*	            5:  print('buffer no. out of range in WCI\ ');	*)
  (*	            6:  print('bufferlets drained\ ');			*)
  (*	            13: print('buffer no. out of range in EMPTY\ ');	*)
  (*	            14: print('parity error\ ');			*)
  (*	            15: print('free list empty in TIMOUT\');		*)
  (*	            16: print( 'dispatcher\ ');				*)
  (*	            17: print( 'illegal instruction\');			*)
  (*	            18: print('illegal SVC\');				*)
  (*	            20: print( 'protection violation\ ');		*)
  (*	            21: print( 'nonrecoverable device check\');		*)
  (*	            2, 7, 8, 9, 10, 11, 12, 19: print_hex(value_1)	*)
  (*	          end  " case "						*)
  (*	        else 							*)
  (*	          print_hex(value_1)					*)
  (*	      end 							*)
  (*      end  " case "							*)
  (*									*)
  (*    else if (product = XCOM_PID) or (product = X25_PID) or		*)
  (*	  (product = X75_PID)						*)
  (*    then print_xcom_report(succode, value_1, value_2)		*)
  (*    else if product = I2IS_PID					*)
  (*    then print_kernel_report(subcode, value_1, value_2)		*)
  (*	else if product = ONTM_PID					*)
  (*    then print_ontyme_report(subcode, value_1, value_2)		*)
  (*	else if product = RAM_PID					*)
  (*	then print_ram_report(subcode, value_1, value_2)		*)
  (*	else if product = VAL_PID					*)
  (*	then print_val_report(subcode, value_1, value_2)		*)
  (*	else if product = TMCS_PID					*)
  (*	then print_tmcs_report(subcode, value_1, value_2)		*)
  (*	else print_unknown_isis_report(subcode, value_1, value_2) 	*)
  (*  end "" print_isis_report "" ;					*)
  (*									*)
  (**********************************************************************)

  define_proc(PRINT_ISIS_REPORT, PRINT_ISIS_REPORT_ARGS, 
    PRINT_ISIS_REPORT_LOCALS);
    store_var(1, dummy_arg(4));
    store_var(2, dummy_arg(5));
    store_var(3, dummy_arg(6));
    print_node(dummy_arg(1));
    print(' node report from\');
    ifcall(dummy_arg(3));
      print(' kernel\');
    endtrue;
      put(substr(dummy_arg(2), 3, 4));
      put(substr_no_shift(dummy_arg(2), 4));
      call_proc(PRINT_MXP_AND_SLOT);
    endfalse;
    endif;

    put(dummy_arg(3));
    put(notfunc);
    put(dummy_arg(4));
    put(constant(PRODUCT_OFFSET));
    put(greater_than);
    put(andfunc);
    put(dummy_arg(3));
    put(dummy_arg(4));
    put(constant(I2IS_PID));
    put(equal);
    put(andfunc);
    ifcall(orfunc);
      put(dummy_arg(3));
      ifcall(notfunc);
        print_space(1);
        print_product(dummy_arg(4));
      endtrue;
      endif;
      store_var(4, dummy_arg(4));
      store_var(1, substr(dummy_arg(5), 8, 8));
      store_var(2, substr_no_shift(dummy_arg(5), 8));
    endtrue;

    elseifcall(dummy_arg(3));
      store_var(4, constant(I2IS_PID));
    endtrue;

      store_var(4, constant(UNKNOWN_PID));
    endfalse;
    endif;

    put(local_var(1));
    put(constant(2));
    ifcall(less_than);
      put(local_var(1));
      casecall(0, 1);
	nextcase(0);
	  print(' buffer zap\');
	  print_newline;
	  print_space(5);
	  print('buffer number: \');
	  put(dummy_arg(4));
	  put(constant(PRODUCT_OFFSET));
	  ifcall(greater_than);
	    print_hex(local_var(3));
	  endtrue;
	    print_hex(local_var(2));
	  endfalse;
	  endif;
	  print(', count: \');
	  put(dummy_arg(4));
	  put(constant(PRODUCT_OFFSET));
	  ifcall(greater_than);
	    put(local_var(2));
	    put(constant(1024));
	    print_decimal(product);
	  endtrue;
	    print_decimal(local_var(3));
	  endfalse;
	  endif;
	  print(' characters\');
	endnextcase (* 0 *) ;

	nextcase(1);
	  print(' crash, count: \');
	  put(dummy_arg(4));
	  put(constant(PRODUCT_OFFSET));
	  ifcall(greater_than);
  	    print_decimal(substr(local_var(3), 8, 8));
	  endtrue;
	    print_decimal(local_var(3));
	  endfalse;
	  endif;
	  print_newline;
	  print_space(5);
	  print('type: \ ');
	  put(local_var(2));
	  ifcall(range_check(FIRST_ISIS_CRASH_CODE, LAST_ISIS_CRASH_CODE));
	    put(local_var(2));
	    casecall(FIRST_ISIS_CRASH_CODE, LAST_ISIS_CRASH_CODE);
	      nextcase(0);  
		print('power failure\');
	      endnextcase;

	      nextcase(1);  
		print('manual restart\ ');
	      endnextcase;

	      nextcase(3);  
		print('buffer no. out of range in GCI\ ');
	      endnextcase;

	      nextcase(4);  
		print('buffer no. out of range in MCI\ ');
	      endnextcase;

	      nextcase(5);  
		print('buffer no. out of range in WCI\ ');
	      endnextcase;

	      nextcase(6);  
		print('bufferlets drained\ ');
	      endnextcase;

	      nextcase(13); 
		print('buffer no. out of range in EMPTY\ ');
	      endnextcase;

	      nextcase(14); 
		print('parity error\ ');
	      endnextcase;

	      nextcase(15); 
		print('free list empty in TIMOUT\');
	      endnextcase;

	      nextcase(16); 
		print('dispatcher\ ');
	      endnextcase;

	      nextcase(17); 
		print('illegal instruction\');
	      endnextcase;

	      nextcase(18); 
		print('illegal SVC\');
	      endnextcase;

	      nextcase(20); 
		print('protection violation\ ');
	      endnextcase;

	      nextcase(21); 
		print('nonrecoverable device check\');
	      endnextcase;

	      nextcase(2);
	      nextcase(7);
	      nextcase(8);
	      nextcase(9);
	      nextcase(10);
	      nextcase(11);	      
	      nextcase(12);
	      nextcase(19);
		print_hex(local_var(2));
	      endnextcase;
	    endcase;
	  endtrue;
	    print_hex(local_var(2));
	  endfalse;
	  endif;
	endnextcase (* 1 *) ;

      endcase;
    endtrue;
    
    put(local_var(4));
    put(constant(XCOM_PID));
    put(equal);
    put(local_var(4));
    put(constant(X25_PID));
    put(equal);
    put(orfunc);
    put(local_var(4));
    put(constant(X75_PID));
    put(equal);
    elseifcall(orfunc);
      put(local_var(1));
      put(local_var(2));
      put(local_var(3));
      call_proc(PRINT_XCOM_REPORT);
    endtrue;

    put(local_var(4));
    put(constant(I2IS_PID));
    elseifcall(equal);
      put(local_var(1));
      put(local_var(2));
      put(local_var(3));
      call_proc(PRINT_KERNEL_REPORT);
    endtrue;

    put(local_var(4));
    put(constant(ONTM_PID));
    elseifcall(equal);
      put(local_var(1));
      put(local_var(2));
      put(local_var(3));
      call_proc(PRINT_ONTYME_REPORT);
    endtrue;

    put(local_var(4));
    put(constant(RAM_PID));
    elseifcall(equal);
      put(local_var(1));
      put(local_var(2));
      put(local_var(3));
      call_proc(PRINT_RAM_REPORT);
    endtrue;

    put(local_var(4));
    put(constant(VAL_PID));
    elseifcall(equal);
      put(local_var(1));
      put(local_var(2));
      put(local_var(3));
      call_proc(PRINT_VAL_REPORT);
    endtrue;

    put(local_var(4));
    put(constant(TMCS_PID));
    elseifcall(equal);
      put(local_var(1));
      put(local_var(2));
      put(local_var(3));
      call_proc(PRINT_TMCS_REPORT);
    endtrue;

      put(local_var(1));
      put(local_var(2));
      put(local_var(3));
      call_proc(PRINT_UNKNOWN_ISIS_REPORT);
    endfalse;
    endif;
  proc_return;


  (* print_unknown_event *)
  (**************************************************************)
  (*								*)
  (*  procedure print_unknown_event;				*)
  (*								*)
  (*  begin							*)
  (*    print( 'unknown message type \');			*)
  (*    print_decimal(event_code);				*)
  (*    print_space(1);						*)
  (*    print_hex(fullword(hw1, hw2));				*)
  (*    print_space(1);						*)
  (*    print_hex(fullword(hw3, hw4))				*)
  (*  end ;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_UNKNOWN_EVENT, PRINT_UNKNOWN_EVENT_ARGS, 
    PRINT_UNKNOWN_EVENT_LOCALS);
    print( 'unknown message type \');
    print_decimal(event_code);
    print_space(1);
    put(hw1);
    put(hw2);
    print_hex(fullword);
    print_space(1);
    put(hw3);
    put(hw4);
    print_hex(fullword);
  proc_return;


  (* print_unknown_event_8_node_report *)
  (**************************************************************)
  (*								*)
  (*  procedure print_unknown_event_8_node_report(		*)
  (*	subcode: integer);					*)
  (*								*)
  (*  begin							*)
  (*    print_node(hw1);					*)
  (*    print(' node report type \ ');				*)
  (*    print_hex(subcode);					*)
  (*    print_space(1);						*)
  (*    print_hex(fullword(hw3, hw4))				*)
  (*  end ;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_UNKNOWN_EVENT_8_NODE_REPORT, 
    PRINT_UNKNOWN_EVENT_8_NODE_REPORT_ARGS, 
    PRINT_UNKNOWN_EVENT_8_NODE_REPORT_LOCALS);
    print_node(hw1);
    print( ' node report type \ ');
    print_hex(dummy_arg(1));
    print_space(1);
    put(hw3);
    put(hw4);
    print_hex(fullword);
  proc_return;


  (* print_unknown_event_8_line_report *)
  (**************************************************************)
  (*								*)
  (*  procedure print_unknown_event_8_line_report(		*)
  (*	right_byte, left_byte : integer);			*)
  (*								*)
  (*  begin							*)
  (*    print_line(hw1, right_byte);				*)
  (*    print( ' node report type \ ');				*)
  (*    print_hex(left_byte);					*)
  (*    print_space(1);						*)
  (*    print_hex(fullword(hw3, hw4))				*)
  (*  end ;							*)
  (*								*)
  (**************************************************************)

  define_proc(PRINT_UNKNOWN_EVENT_8_LINE_REPORT, 
    PRINT_UNKNOWN_EVENT_8_LINE_REPORT_ARGS, 
    PRINT_UNKNOWN_EVENT_8_LINE_REPORT_LOCALS);
    put(hw1);
    put(dummy_arg(1));
    call_proc(PRINT_LINE);
    print( ' node report type \ ');
    print_hex(dummy_arg(2));
    print_space(1);
    put(hw3);
    put(hw4);
    print_hex(fullword);     
  proc_return;




  (* stuff current_erlog_index to the first two bytes of erlog_buffer *)
  stuff_integer(current_erlog_index, 0);


  put(event_code);
  ifcall(range_check(FIRST_CODE, LAST_CODE));
  put(event_code);

  (* EVENTS (case statement) *)
  casecall(FIRST_CODE, LAST_CODE);

    (************************************************************)
    (*								*)
    (*  Shutting all lines on active supervisor.		*)
    (*								*)
    (************************************************************)

    nextcase(1);	(* event_1  *)
      print('shutting all lines on active supervisor\');
    endnextcase (* event_1 *) ;

    (************************************************************)
    (*								*)
    (*  Supervisor crash at location hw1, hw2.			*)
    (*								*)
    (*  procedure event_2;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('supervisor crash \');			*)
    (*        print_hex(fullword(hw1, hw2))			*)
    (*      end  " with "					*)
    (*  end  " event_2 " ;					*)
    (*								*)
    (************************************************************)

    nextcase(2);	(* event_2  *)
      print('supervisor crash \');
      put(hw1);
      put(hw2);
      print_hex(fullword);
    endnextcase (* event_2 *) ;


    (************************************************************)
    (*								*)
    (*  Unexpected takeover response.				*)
    (*								*)
    (*  procedure event_3;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw4);					*)
    (*        print(' unexpected takeover response\')		*)
    (*      end " with "					*)
    (*  end " event_3 " ;					*)
    (*								*)
    (************************************************************)


    nextcase(3);	(* event_3  *)
      print_node(hw4);
      print(' unexpected takeover response\');
    endnextcase (* event_3 *) ;

    (************************************************************)
    (*								*)
    (*  Operator request.					*)
    (*								*)
    (*  procedure event_4;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      if (hw4 < first_code_4_subcode) or 			*)
    (*        (last_code_4_subcode < hw4)			*)
    (*      then print_unknown_event				*)
    (*      else						*)
    (*        case hw4 of					*)
    (*  							*)
    (*  	0:    " bad shut request "			*)
    (*  	  begin						*)
    (*  	    link_check(hw1, hw2);			*)
    (*  	    print('bad shut request \');		*)
    (*  	    print_node(hw1);				*)
    (*  	    print(' -- \ ');				*)
    (*  	    print_node(hw2)				*)
    (*  	  end  " 4-0 " ;				*)
    (*  							*)
    (*  	1:    " retake "				*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' retaken by command\')		*)
    (*  	  end " 4-1 " ;					*)
    (*  							*)
    (*  	2:    " retake failure "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' commanded retake failure\')		*)
    (*  	  end " 4-2 " ;					*)
    (*  							*)
    (*  	3:    " rebori "				*)
    (*  	  begin						*)
    (*  	    print_line(hw2, hw1);			*)
    (*  	    print(' rebori by command\ ')		*)
    (*  	  end " 4-3 " ;					*)
    (*  							*)
    (*  	4:    " rebori failure "			*)
    (*  	  begin						*)
    (*  	    print_line(hw2, hw1);			*)
    (*  	    print(' commanded rebori failure\')		*)
    (*  	  end " 4-4 " ;					*)
    (*  							*)
    (*  	5:    " downline load "				*)
    (*  	  begin						*)
    (*  	    print_line(hw2, hw1);			*)
    (*  	    print(' downline load request\ ')		*)
    (*  	  end " 4-5 " ;					*)
    (*  							*)
    (*  	6:    " downline load request failure "		*)
    (*  	  begin						*)
    (*  	    print_line(hw2, hw1);			*)
    (*  	    print(' downline load request  rejected\ ')	*)
    (*  	  end " 4-6 " ;					*)
    (*  							*)
    (*  	7:    print('sleep command\');			*)
    (*  							*)
    (*  	8:    print('awake command\');			*)
    (*  							*)
    (*  	9:    print('IRC rotation table read\');	*)
    (*  							*)
    (*  	10:   " update request "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' update request\')			*)
    (*  	  end " 4-10 " ;				*)
    (*  							*)
    (*  	11:   " update failure "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' update failure\')			*)
    (*  	  end " 4-11 " ;				*)
    (*  							*)
    (*  	12:   " trace request "				*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' trace request\ ')			*)
    (*  	  end " 4-12 " ;				*)
    (*  							*)
    (*  	13:   " trace request reject "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' trace request rejected\')		*)
    (*  	  end " 4-13 " ;				*)
    (*  							*)
    (*  	14:   " unbori request...TYMNET II "		*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' unbori request\')			*)
    (*  	  end " 4-14 " ;				*)
    (*  							*)
    (*  	15:   " unbori failure "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' unbori failure\')			*)
    (*  	  end " 4-15 " ;				*)
    (*  							*)
    (*  	16:   print('reading group and class defs\ ');	*)
    (*  							*)
    (*  	17:   " request to change a node neighbor "	*)
    (*  	  begin						*)
    (*  	    print_node(hw1);				*)
    (*  	    print(' addr \ ');				*)
    (*  	    print_octal(hw2);				*)
    (*  	    print(' changed to \ ');			*)
    (*  	    print_node(hw3)				*)
    (*  	  end " 4-17 " ;				*)
    (*  							*)
    (*  	18:   " TYMNET II port status "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' TYMNET II port status request\ ')	*)
    (*  	  end " 4-18 " ;				*)
    (*  							*)
    (*  	19:   " TYMNET II port request failure "	*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' TYMNET II port request failure\')	*)
    (*  	  end " 4-19 " ;				*)
    (*  							*)
    (*  	20:   " sync port request "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' sync port request\ ')		*)
    (*  	  end " 4-20 " ;				*)
    (*  							*)
    (*  	21:   " sync port request failure "		*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' sync port request failure\ ')	*)
    (*  	  end " 4-21 " ;				*)
    (*  							*)
    (*  	22:   " link cost request "			*)
    (*  	  begin						*)
    (*  	    link_check(hw1, hw2);			*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' link cost request to \ ');		*)
    (*  	    print_node(hw1)				*)
    (*  	  end " 4-22 " ;				*)
    (*  							*)
    (*  	23:   " link cost request failure "		*)
    (*  	  begin						*)
    (*  	    link_check(hw1, hw2);			*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' link cost request failure to \ ');	*)
    (*  	    print_node(hw1)				*)
    (*  	  end " 4-23 "	;				*)
    (*  							*)
    (*		24:   " needle dump sampling "				*)
    (*		  begin							*)
    (*		    print('sampling of needle dumping - 1 out of \');	*)
    (*		    print_decimal(hw2)					*)
    (*		  end " 4-24 "						*)
    (*        end " case "						*)
    (*  end " event_4 " ;						*)
    (*									*)
    (********************************************************************)

    nextcase(4);	(* event_4  *)
      put(hw4);
      ifcall(range_check(FIRST_CODE_4_SUBCODE, LAST_CODE_4_SUBCODE));
	put(hw4);
	casecall(FIRST_CODE_4_SUBCODE, LAST_CODE_4_SUBCODE);
	  nextcase(0);	(* bad shut request *)
	    put(hw1);
   	    put(hw2);
	    link_check;
	    print('bad shut request \');
	    print_node(hw1);
	    print(' -- \ ');
	    print_node(hw2);
  	  endnextcase;

	  nextcase(1);	(* retake *)
	    print_node(hw2);
	    print(' retaken by command\');
	  endnextcase;

	  nextcase(2);	(* retake failure *)
	    print_node(hw2);
	    print(' commanded retake failure\');
	  endnextcase;

	  nextcase(3);	(* rebori *)
	    put(hw2);
	    put(hw1);
	    call_proc(PRINT_LINE);
	    print(' rebori by command\ ');
	  endnextcase;

	  nextcase(4);	(* rebori failure *)
	    put(hw2);
	    put(hw1);
	    call_proc(PRINT_LINE);
	    print(' commanded rebori failure\');
	  endnextcase;

	  nextcase(5);	(* downline load *)
	    put(hw2);
	    put(hw1);
	    call_proc(PRINT_LINE);
	    print(' downline load request\ ');
	  endnextcase;

	  nextcase(6);	(* downline load request failure *)
	    put(hw2);
	    put(hw1);
	    call_proc(PRINT_LINE);
	    print(' downline load request rejected\');
	  endnextcase;

	  nextcase(7);	
	    print('sleep command\');
	  endnextcase;

	  nextcase(8);
	    print('awake command\');
	  endnextcase;

	  nextcase(9);
	    print('IRC rotation table read\');
	  endnextcase;

	  nextcase(10);	(* update request *)
	    print_node(hw2);
	    print(' update request\');
	  endnextcase;

	  nextcase(11);	(* update failure *)	    
	    print_node(hw2);
	    print(' update failure\');
	  endnextcase;

	  nextcase(12);	(* trace request *)
	    print_node(hw2);
	    print(' trace request\ ');
	  endnextcase;

	  nextcase(13);	(* trace request reject *)
	    print_node(hw2);
	    print(' trace request rejected\');
	  endnextcase;

	  nextcase(14);	(* unbori request...TYMNET II *)
	    print_node(hw2);
	    print(' unbori request\');
	  endnextcase;

	  nextcase(15);	(* unbori failure *)
	    print_node(hw2);
	    print(' unbori failure\');
	  endnextcase;

	  nextcase(16);	
	    print('reading group and class defs\ ');
	  endnextcase;

	  nextcase(17);	(* request to change a node neighbor *)
	    print_node(hw1);
	    print(' addr \ ');
	    print_octal(hw2);
	    print(' changed to \ ');
	    print_node(hw3);
	  endnextcase;

	  nextcase(18);	(* TYMNET II port status *)
	    print_node(hw2);
	    print(' TYMNET II port status request\ ');
	  endnextcase;

	  nextcase(19);	(* TYMNET II port request failure *)
	    print_node(hw2);
	    print(' TYMNET II port request failure\');
	  endnextcase;

	  nextcase(20);	(* sync port request *)
	    print_node(hw2);
	    print(' sync port request\ ');
	  endnextcase;

	  nextcase(21);	(* sync port request failure *)
	    print_node(hw2);
	    print(' sync port request failure\ ');
	  endnextcase;

	  nextcase(22);	(* link cost request *)
	    put(hw1);
	    put(hw2);
	    link_check;
	    print_node(hw2);
	    print(' link cost request to \ ');
	    print_node(hw1);
	  endnextcase;

	  nextcase(23);	(* link cost request failure *)
	    put(hw1);
	    put(hw2);
	    link_check;
	    print_node(hw2);
	    print(' link cost request failure to \ ');
	    print_node(hw1);
	  endnextcase;

	  nextcase(24); (* needle dump sampling *)
	    print('sampling of needle dumping - 1 out of \ ');
	    print_decimal(hw2);
	  endnextcase;
        endcase;
      endtrue;
      	call_proc(PRINT_UNKNOWN_EVENT);
      endfalse;
      endif;
    endnextcase (* event_4 *) ;


    (************************************************************)
    (*								*)
    (*  Supervisor report on available accounting blocks.	*)
    (*								*)
    (*  procedure event_5;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('accounting file blocks left \ ');		*)
    (*        print_decimal(substr(hw2, 15, 0))			*)	
    (*      end " with "					*)
    (*  end  " event_5 " ;					*)
    (*								*)
    (************************************************************)


    nextcase(5);	(* event_5  *)
      print('accounting file blocks left \ ');
      print_decimal(substr_no_shift(hw2, 15));
    endnextcase (* event_5 *) ;


    (************************************************************)
    (*								*)
    (*  Lost node.						*)
    (*								*)
    (*  procedure event_6;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw4);					*)
    (*        print(' lost, upstream was \ ');			*)
    (*        print_node(hw2)					*)
    (*      end " with "					*)
    (*  end  " event_6 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(6);	(* event_6  *)
      print_node(hw4);
      print(' lost, upstream was \ ');
      print_node(hw2);
    endnextcase (* event_6 *) ;


    (************************************************************)
    (*								*)
    (*  Host confusion.						*)
    (*								*)
    (*  procedure event_7;					*)
    (*								*)
    (*  " code 7 message subcodes "				*)
    (*  							*)
    (*  const							*)
    (*    first_code_7_subcode = 1;				*)
    (*    last_code_7_subcode = 7;				*)
    (*  							*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      if (hw4 < first_code_7_subcode) or (last_code_7_subcode < hw4)*)
    (*      then print_unknown_event				*)
    (*      else						*)
    (*        case hw4 of					*)
    (*  							*)
    (*  	1:    " duplicate hosts "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' duplicate hosts,\');		*)
    (*  	    print_host(hw3);				*)
    (*  	    print(' was on \ ');			*)
    (*  	    print_node(hw1)				*)
    (*  	  end " 7-1 " ;					*)
    (*  							*)
    (*  	2:    " up host reporting up on another base "	*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print_host(hw3);				*)
    (*  	    print(' up, and already up on \');		*)
    (*  	    print_node(hw1)				*)
    (*  	  end " 7-2 " ;					*)
    (*  							*)
    (*  	3:    " up host reporting up "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print_host(hw3);				*)
    (*  	    print(' already up, reporting up again\')	*)
    (*  	  end " 7-3 " ;					*)
    (*  							*)
    (*  	4:    " second host reporting up on existing host spot "	*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print_host(hw3);				*)
    (*  	    print(' reporting up, but up host already in that spot\')	*)
    (*  	  end " 7-4 " ;					*)
    (*  							*)
    (*  	5:    " zero host number reporting "		*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' zero host number reported\ ')	*)
    (*  	  end " 7-5 " ;					*)
    (*  							*)
    (*  	6:    " host reports gone but not there "	*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print_host(hw3);				*)
    (*  	    print(' reported gone but not there\ ')	*)
    (*  	  end " 7-6 " ;					*)
    (*  							*)
    (*  	7:    " host number too big "			*)
    (*  	  begin						*)
    (*  	    print_node(hw2);				*)
    (*  	    print(' host number \');			*)
    (*  	    print_decimal(hw3);				*)
    (*  	    print(' too big\ ')				*)
    (*  	  end " 7-7 "					*)
    (*  							*)
    (*        end " case "					*)
    (*  end " event_7 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(7);	(* event_7  *)
      put(hw4);
      ifcall(range_check(FIRST_CODE_7_SUBCODE, LAST_CODE_7_SUBCODE));
	put(hw4);
	casecall(FIRST_CODE_7_SUBCODE, LAST_CODE_7_SUBCODE);
	  nextcase(1);
	    print_node(hw2);
	    print(' duplicate hosts,\');
	    print_host(hw3);
	    print(' was on \ ');
	    print_node(hw1);
	  endnextcase;

	  nextcase(2);
	    print_node(hw2);
	    print_host(hw3);
	    print(' up, and already up on \');
	    print_node(hw1);
	  endnextcase;

	  nextcase(3);
	    print_node(hw2);
	    print_host(hw3);
	    print(' already up, reporting up again\');
	  endnextcase;

	  nextcase(4);
	    print_node(hw2);
	    print_host(hw3);
	    print(' reporting up, but up host already in that spot\');
	  endnextcase;

	  nextcase(5);
	    print_node(hw2);
	    print(' zero host number reported\ ');
	  endnextcase;

	  nextcase(6);
	    print_node(hw2);
	    print_host(hw3);
	    print(' reported gone but not there\ ');
	  endnextcase;

	  nextcase(7);
	    print_node(hw2);
	    print(' host number \');
	    print_decimal(hw3);
	    print(' too big\ ');
	  endnextcase;
	endcase;
      endtrue;
	call_proc(PRINT_UNKNOWN_EVENT);
      endfalse;
      endif;
    endnextcase (* event_7 *) ;


    (************************************************************)
    (*								*)
    (*  Log node error messages which are code type 8.		*)
    (*  procedure event_8;					*)
    (*								*)
    (*  " event 8 node report subcode "				*)
    (*								*)
    (*  const							*)
    (*    first_event_8_node_subcode = 1;			*)
    (*    last_event_8_node_subcode  = 46;			*)
    (*      							*)
    (*  " event 8 line error subcode "				*)
    (*								*)
    (*  const							*)
    (*    first_event_8_line_subcode = 128;			*)
    (*    last_event_8_line_subcode  = 139;			*)
    (*								*)
    (*  var							*)
    (*    left_byte	: integer;				*)
    (*    right_byte	: integer;				*)
    (*    subcode	: integer;				*)
    (*    sub_type	: integer;				*)
    (*    crash_code	: integer;				*)
    (*    speed		: integer;				*)
    (*    degree_in_cel	: integer;				*)
    (*    degree_in_far	: integer;				*)
    (*								*)
    (*  begin							*)
    (*    with current_message do  				*)
    (*      begin						*)
    (*        left_byte  := substr(hw2, 8, 8);			*)
    (*        right_byte := substr(hw2, 8, 0);			*)
    (*        if left_byte = 0					*)
    (*        then						*)
    (*  	begin						*)
    (*  	  if (right_byte < first_event_8_node_subcode) 	*)
    (*  	  or (last_event_8_node_subcode  < right_byte)	*)
    (*  	  then 						*)
    (*  	    print_unknown_event_8_node_report(right_byte)*)
    (*            else						*)
    (*  	    begin					*)
    (*  	      print_node(hw1);				*)
    (*  	      print(' node report,\');			*)
    (*  	      subcode := right_byte;			*)
    (*  	      case subcode of 				*)
    (*        	        1:  " channel in use "			*)
    (*  	          begin					*)
    (*  	            print(' circuit assignment on assigned channel \ ');	*)
    (*  	            print_hex(substr(hw4, 15, 0));	*)
    (*   	            print_neighbor_node(substr(hw3,14,0))	*)
    (*  	          end " 8-1 " ;				*)
    (*  							*)
    (*  	        2:  " data on unassigned channel "	*)
    (*  	          begin					*)
    (*  	            print(' data on unassigned channel \ ');	*)
    (*  	            print_hex(substr(hw4, 15, 0));	*)
    (*  	            print_neigfbor_node(substr(hw3,14,0))	*)
    (*  	          end " 8-2 " ;				*)
    (*  							*)
    (*  	        3:  " buffer zap "			*)
    (*  	          begin					*)
    (*  	            print(' buffer \ ');		*)
    (*  	            print_hex(hw3);			*)
    (*  	            print(' zapped, \');		*)
    (*  	            print_decimal(hw4);			*)
    (*  	            print(' octets lost \')		*)
    (*  	          end " 8-3 " ;				*)
    (*  							*)
    (*  	        4:  " remove neighbor response "	*)
    (*  	          begin					*)
    (*  	            if hw4 = 32897			*)
    (*  	            then 				*)
    (*  		      print(' neighbor removed\') 	*)
    (*  	            else				*)
    (*  		       print(' neighbor not removed, was not found\ ');*)
    (*  	            print_neighbor_node(substr(hw3,14,0))	*)
    (*  	          end " 8-4 " ;				*)
    (*  							*)
    (*  	        5:  " add neighbor response "		*)
    (*  	          begin					*)
    (*  	            if hw4 = 65535			*)
    (*  	            then 				*)
    (*  		      print(' neighbor not added, link space unavailable,\ ') 	*)
    (*  	            else  				*)
    (*  	              begin				*)
    (*  	                if hw3 >= 32768			*)
    (*  	                then				*)
    (*  		          begin 			*)
    (*                              print(' neighbor added, window size \');*)
    (*  		            print_decimal(substr(hw4,12,0))	*)
    (*  		          end   			*)
    (*        	  	        else				*)
    (*  		          begin				*)
    (*                              print( ' neighbor not added, window size mismatch, window size \');*)
    (*  		            print_decimal(substr(hw4,8,0))*)
    (*  		          end				*)
    (*  	              end;				*)
    (*  	            print_neighbor_node(substr(hw3,14,0))	*)
    (*  	          end " 8-5 " ;				*)
    (*  							*)
    (*  	        6:  " link bubble "			*)
    (*  	          begin					*)
    (*  	            print( ' link bubble with \ ');	*)
    (*  	            print_decimal(substr(hw4, 15, 0));	*)
    (*  	            print( ' channels\');		*)
    (*  	            print_neighbor_node(substr(hw3,14,0))	*)
    (*  	          end " 8-6 " ;		        	*)
    (*  							*)
    (*  	        7:  " link shrink "			*)
    (*  	          begin					*)
    (*  	            print(' link shrink with \ ');	*)
    (*  	            print_decimal(substr(hw4, 15, 0));  *)
    (*  	            print(' channels\');		*)
    (*  	            print_neighbor_node(substr(hw3,14,0))	*)
    (*  	          end " 8-7 " ;				*)
    (*  							*)
    (*  	        8:  " out of permuter table space "	*)
    (*  	          begin					*)
    (*  	            print( ' out of permuter table space, line \');	*)
    (*  	            print_decimal(substr(hw4,6,0));	*)
    (*  	            print_neighbor_node(substr(hw3,14,0))	*)
    (*  	          end " 8-8 " ;				*)
    (*   							*)
    (*  		9:  " out of link descriptor space "	*)
    (*  		  begin					*)
    (*  		    print(' out of link descriptor space, line \ ');*)
    (*  		    print_decimal(substr(hw4,6,0));	*)
    (*  		    print_neighbor_node(substr(hw3,14,0))	*)
    (*  		  end " 8-9 " ;				*)
    (*  							*)
    (*  		10:  " circuits being zapped "		*)
    (*  		  begin					*)
    (*  		    print(' link outage, \ ');		*)
    (*  		    print_decimal(substr(hw4, 15, 0));	*)
    (*  		    print(' circuits zapped\ ');	*)
    (*  		    print_neighbor_node(substr(hw3,14,0))	*)
    (*  		  end " 8-10 " ;			*)
    (*  	   						*)
    (*  		11:  " out of dispatcher ports "	*)
    (*  		  begin					*)
    (*  		    print(' out of dispatcher ports, \ ');	*)
    (*  		    print_decimal(hw3);			*)
    (*  		    print( ' assigned\');		*)
    (*  		    print_newline;			*)
    (*  		    print_host(substr(hw4, 15, 0))	*)
    (*  		  end " 8-11 " ;			*)
    (*  							*)
    (*  		12:  " needle rejected, suspicious host "	*)
    (*  		  begin					*)
    (*  		    print(' needle rejected for out of ports with \');	*)
    (*  		    print_decimal(hw3);			*)
    (*  		    print( ' ports available\ ');	*)
    (*  		    print_newline;			*)
    (*  		    print_host(substr(hw4, 15, 0))	*)
    (*  		  end " 8-12 " ;			*)
    (*  							*)
    (*  		13:  " host is impostor "		*)
    (*  		  begin					*)
    (*  		    print_host(substr(hw4, 15, 0));	*)
    (*  		    print( ' on slot \');		*)
    (*  		    print_decimal(substr(hw3, 8, 8));	*)
    (*  		    print( ' claimed by slot \');	*)
    (*  		    print_decimal(substr(hw3, 8, 0))	*)
    (*  		  end " 8-13 " ;			*)
    (*  							*)
    (*  		14:  " circuit lifetime "		*)
    (*  		  begin					*)
    (*  		    print(' circuit lifetime \ ');	*)
    (*  		    print_decimal(hw3);			*)
    (*  		    print( ' seconds on channel \ ');	*)
    (*  		    print_hex(substr(hw4, 15, 0))	*)
    (*  		  end " 8-14 " ;			*)
    (*  							*)
    (*  		15:  " link snip "			*)
    (*  		  begin					*)
    (*  		    print(' link snip, error on channel \');	*)
    (*  		    print_hex(substr(hw4, 15, 0));	*)
    (*  		    print_neighbor_node(substr(hw3,14,0))	*)
    (*  		  end  8-15 " ;				*)
    (*  							*)
    (*  		16:  " diagnostic node report "		*)
    (*  		  begin					*)
    (*  		    sub_type := substr(hw3, 8, 8);	*)
    (*  		    if (sub_type = 1) or (sub_type = 0)	*)
    (*  		    then				*)
    (*  		      begin				*)
    (*  			case sub_type of		*)
    (*  			  0:  " sync scan error "	*)
    (*  			    begin			*)
    (*  			      print(' sync scan error, sync ring index, line \ ');*)
    (*  			      print_hex(hw4)			*)
    (*  			    end;				*)
    (*  			  1:  " bad count detected on sio buffer "*)
    (*  			    begin			*)
    (*  			      print(' bad count of \ ');*)
    (*  			      print_decimal(hw4);	*)
    (*  			      print(' on sio buffer, line \')	*)
    (*  			    end	 			*)
    (*  			end " case "; 			*)
    (*  			print_decimal(substr(hw3, 7, 1))*)
    (*  		      end				*)
    (*  		    else				*)
    (*  		      begin				*)
    (*  			print(' unknown diagnostic report \');	*)
    (*  			print_hex(fullword(hw3, hw4))	*)
    (*  		      end				*)
    (*  		  end " 8-16 " ;			*)
    (*  							*)
    (*  		17:  " next neighbor in needle not found "	*)
    (*  		  begin					*)
    (*  		    print(' next node in needle not found, needle flags \');	*)
    (*  		    print_hex(hw4);			*)
    (*  		    print_neighbor_node(substr(hw3,14,0))	*)
    (*  		  end " 8-17 " ;			*)
    (*  							*)
    (*  		18:  " received message for another node "	*)
    (*  		  begin					*)
    (*  		    print(' invalid command address \');*)
    (*  		    print_hex(substr(hw3, 15, 0));	*)
    (*  		    print(', total \ ');		*)
    (*  		    print_decimal(substr(hw4, 15, 0));	*)
    (*  		    print(' received\')			*)
    (*  		  end " 8-18 " ;			*)
    (*  							*)
    (*  		19:  " received unrecognized command "	*)
    (*  		  begin					*)
    (*  		    print(' unrecognized command \ ');	*)
    (*  		    print_hex(substr(hw3, 15, 0));	*)
    (*  		    print(' total \');			*)
    (*  		    print_decimal(substr(hw4, 15, 0));	*)
    (*  		    print(' received\')			*)
    (*  		  end " 8-19 " ;			*)
    (*  			  				*)
    (*  		20:  " circuit building errors detected "	*)
    (*  		  begin					*)
    (*  		    print(' circuit build errors, lep \');	*)
    (*  		    print_decimal(substr(hw3, 15, 0));	*)
    (*  		    print(', crq \ ');			*)
    (*  		    print_decimal(substr(hw4, 15, 0))	*)
    (*  		  end " 8-20 " ;			*)
    (*  							*)
    (*  		21:  " circuit building inconsistency errors "	*)
    (*  		  begin					*)
    (*  		    print(' circuit build inconsistency, recent \');*)
    (*  		    print_decimal(substr(hw3, 15, 0));	*)
    (*  		    print(', total \ ');		*)
    (*  		    print_decimal(substr(hw4, 15, 0))	*)
    (*  		  end " 8-21 " ;			*)
    (*  							*)
    (*  		22:  " link frozen "			*)
    (*  		  begin					*)
    (*  		    print(' link frozen, no records for \');	*)
    (*  		    print_decimal(substr(hw4, 15, 0));	*)
    (*  		    print(' second\');			*)
    (*  		    print_neighbor_node(substr(hw3,14,0))	*)
    (*  		  end " 8-22 " ;			*)
    (*  							*)
    (*  		23:  " link thawed "			*)
    (*  		  begin					*)
    (*  		    print(' link thawed, \ ');		*)
    (*  		    print_decimal(substr(hw4, 15, 0));	*)
    (*  		    print(' active circuits\ ');	*)
    (*  		    print_neighbor_node(substr(hw3,14,0))	*)
    (*  		  end " 8-23 " ;			*)
    (*  							*)
    (*  		24:  " number of priority circuits zapped "	*)
    (*  		  begin					*)
    (*  		    print(' priority circuits zapped: \');	*)
    (*  		    print_decimal(substr(hw4, 15, 0));	*)
    (*  		    print_neighbor_node(substr(hw3,14,0))	*)
    (*  		  end " 8-24 " ;			*)
    (*  							*)
    (*  		25:  " node crash report "		*)
    (*  		  begin					*)
    (*  		    print(' crash, type: \ ');		*)
    (*  		    crash_code := substr(hw3, 8, 8);	*)
    (*  		    if crash_code = 16			*)
    (*  		    then print(' reload or manual restart \ ');	*)
    (*  		    if crash_code = 17			*)
    (*  		    then print(' power failure \');	*)
    (*  		    if crash_code = 18			*)
    (*  		    then print(' power failure or manual restart \');*)
    (*  		    if crash_code = 32			*)
    (*  		    then print(' parity error at \');	*)
    (*  		    if crash_code = 50			*)
    (*  		    then print(' unexpected interrupt, count \');*)
    (*  		    if crash_code = 65			*)
    (*  		    then print(' illegal instruction at \ ');	*)
    (*  		    if crash_code = 80			*)
    (*  		    then print(' mac error/protection violation at \')*)
    (*  		    if crash_code = 96			*)
    (*  		    then print(' illegal svc at \ ');	*)
    (*  		    if crash_code = 97			*)
    (*  		    then print(' dispatcher at \');	*)
    (*  		    if crash_code = 99			*)
    (*  		    then print(' software consistency error at \');	*)
    (*  		    if crash_code = 145			*)
    (*  		    then print(' device check at \');	*)
    (*  		    if crash_code = 255			*)
    (*  		    then print(' unknown \');		*)
    (*  		    					*)
    (*  		    print_hex(fullword(substr(hw3, 8,0), hw4))	*)
    (*  		  end " 8-25 " ;			*)
    (*  							*)
    (*  							*)
    (*  		26:  " report node resources: lines and links "	*)
    (*  		  begin					*)
    (*  		    print(' configured for \ ');	*)
    (*  		    print_decimal(substr(hw3, 4, 8));	*)
    (*  		    print(' sio lines, \ ');		*)
    (*  		    print_decimal(substr(hw3, 4, 0));	*)
    (*  		    print(' sync lines\');		*)
    (*  		    print_newline;			*)
    (*  		    print_space(7);			*)
    (*  		    print_decimal(substr(hw4, 4, 8));	*)
    (*  		    print( ' xlinks, \');		*)
    (*  		    print_decimal(substr(hw4, 4, 0));	*)
    (*  		    print( ' total links\ ')		*)
    (*  		  end;					*)
    (*  		  					*)
    (*  		27:  " report node resources: ports and passthroughs "	*)
    (*  		  begin					*)
    (*  		    print(' configured for \ ');	*)
    (*  		    print_decimal(substr(hw3, 15, 0));	*)
    (*  		    print(' ports, \ ');		*)
    (*  		    print_decimal(substr(hw4, 15, 0));	*)
    (*  		    print(' passthroughs\')		*)
    (*  		  end " 8-27 " ;			*)
    (*  							*)
    (*  		28:  " report node resources: lines used "	*)
    (*  		  begin					*)
    (*  		    print(' lines unused: \');		*)
    (*  		    print_link_string(hw3, hw4)		*)
    (*  		  end " 8-28 " ;			*)
    (*  							*)
    (*  		29:  " report node resources: links on used lines "	*)
    (*  		  begin					*)
    (*  		    if substr(hw3, 8, 0) = 255		*)
    (*  		    then print(' defined\ ')		*)
    (*  		    else print(' attached\');		*)
    (*  		    if hw3 > 32767   " 7FFF "		*)
    (*  		    then print(' sio\ ')		*)
    (*  		    else print(' sync\');		*)
    (*  		    print(' line \ ');			*)
    (*  		    speed := substr(hw3, 5, 8);		*)
    (*  		    if substr(hw3, 8, 0) = 255		*)
    (*  		    then				*)
    (*  		      begin				*)
    (*  			if speed <> 0			*)
    (*  			then print_speed(speed)		*)
    (*  		      end				*)
    (*  		    else				*)
    (*  		      begin				*)
    (*  			print_decimal(substr(hw3, 7, 0));*)
    (*  			if speed = 0			*)
    (*  			then print(', frozen\ ')	*)
    (*  			else print_speed(speed)		*)
    (*  		      end;				*)
    (*  		    if substr(hw3, 1, 13) = 1		*)
    (*  		    then print('satellite link\ ');	*)
    (*  		    print_neighbor_node(substr(hw4, 15, 0))	*)
    (*  		  end " 8-29 " ;			*)
    (*  							*)
    (*  							*)
    (*  		30:  " slot report limit exceeded "	*)
    (*  		  begin					*)
    (*  		    print(' slot \ ');			*)
    (*  		    print_decimal(substr(hw3, 15, 0));	*)
    (*  		    print(' exceeded report limit of \ ');	*)
    (*  		    print_decimal(hw4)			*)
    (*  		  end " 8-30 " ;			*)
    (*  							*)
    (*  		31:  " restricted host on invalid slot "*)
    (*  		  begin					*)
    (*  		    print(' restricted  \');		*)
    (*  		    print_host(substr(hw4, 15, 0));	*)
    (*  		    print(' on invaild slot \');  	*)
    (*  		    print_decimal(substr(hw3, 15, 0))	*)
    (*  		  end " 8-31 " ;			*)
    (*  							*)
    (*  		32:  " restricted slot/host circuit limit exceeded "	*)
    (*  		  begin						*)
    (*  		    print(' restricted \ ');			*)
    (*			    if substr(hw4, 15, 0) <> 0			*)
    (*  		    then print_host(substr(hw4, 15, 0)) 	*)
    (*			    else print_mxp_and_slot(			*)
    (*			      substr(hw3, 8, 8), subsr(hw3, 8, 0))	*)
    (*			    print_newline;				*)
    (*  		    print('     attempted to exceed circuit limit\ ')	*)
    (*  		  end " 8-32 " ;			*)
    (*  							*)
    (*  		33:  " number of circuits zapped by dload "	*)
    (*  		  begin					*)
    (*  		    print(' circuits zapped by dload, terminating \');	*)
    (*  		    print_decimal(substr(hw3, 15, 0));	*)
    (*  		    print_newline;			*)
    (*  		    print_space(7);			*)
    (*  		    print('passthrough \ ');		*)
    (*  		    print_decimal(substr(hw4, 15, 0))	*)
    (*  		  end " 8-33 " ;			*)
    (*  							*)
    (*  		34:  " invalid 03 character pair on command circuit "		*)
    (*  		  begin					*)
    (*  		    print(' invaild 03 character pair on command circuit\');	*)
    (*  		    print_newline;			*)
    (*  		    print('     second character \ ');	*)
    (*  		    print_hex(substr(hw4, 8, 0))	*)
    (*  		  end " 8-34 " ;			*)
    (*  							*)
    (*  		35:  " recoverable mac error "		*)
    (*  		  begin					*)
    (*  		    print(' recoverable mac error at \ ');	*)
    (*  		    print_hex(fullword(substr(hw3, 8, 0), hw4))	*)
    (*  		  end " 8-35 " ;			*)
    (*  							*)
    (*  		36:  " sio output timeout "		*)
    (*  		  begin					*)
    (*  		    print(' sio output timeout on line \ ');	*)
    (*  		    print_decimal(hw4);			*)
    (*  		    print(' after \');			*)
    (*  		    print_decimal_scaled(hw3, 3);	*)
    (*  		    print(' seconds\ ')			*)
    (*  		end " 8-36 " ;				*)
    (*  							*)
    (*  		37:  " data on disabled async port "	*)
    (*  		  begin					*)
    (*  		    print(' data on disabled async port \');	*)
    (*  		    print_hex(substr(hw4, 15, 0))	*)
    (*  		  end " 8-37 " ;			*)
    (*  							*)
    (*  		38:  " invalid 03 character pair on tymnet I command circuit "	*)
    (*  		  begin					*)
    (*  		    print(' invalid 03 character pair on tymnet I command circuit\ ');	*)
    (*  		    print_neighbor_node(substr(hw3,14,0));	*)
    (*  		    print(' second character \ ');	*)
    (*  		    print_hex(substr(hw4, 8, 0))	*)
    (*  		  end " 8-38 " ;			*)
    (*  							*)
    (*  		39:  " invalid record length on a tymnet I command circuit "*)
    (*  		  begin					*)
    (*  		    print(' invalid record length \');	*)
    (*  		    print_decimal(substr(hw4, 15, 0));	*)
    (*  		    print(' on tymnet I command circuit\ ');	*)
    (*  		    print_neighbor_node(substr(hw3,14,0))	*)
    (*  		  end " 8-39 " ;			*)
    (*  							*)
    (*  		40:  " dma timeout, mac interrupt "	*)
    (*  		  begin					*)
    (*  		    print(' dma timeout, \ ');		*)
    (*  		    print_decimal(substr(hw3, 15, 0));	*)
    (*  		    print(' sio lines, mac interrupt status \');*)
    (*  		    print_hex(hw4)			*)
    (*  		  end " 8-40 " ;	  		*)
    (*  							*)
    (*  		41:  " svc to zap kernel port failed "	*)
    (*  		  print(' svc to zap kernel port failed\ ');	*)
    (*  							*)
    (*  		42:  " first addendum to crash report "	*)
    (*  		  begin					*)
    (*  		    print(' crash report addendum, code \');	*)
    (*  		    print_decimal(substr(hw3, 4, 8));	*)
    (*  		    print(', count \ ');		*)
    (*  		    print_decimal(substr(hw3, 8, 0));	*)
    (*  		    print(', version \ ');		*)
    (*  		    print_decimal(substr(hw4, 4, 8));	*)
    (*  		    print_newline;			*)
    (*  		    print('     crash register reports \ ');	*)
    (*  		    print_decimal(substr(hw4, 8, 0))	*)
    (*  		  end " 8-42 " ;			*)
    (*  							*)
    (*  		43:  " second addendum to crash report "*)
    (*  		  begin					*)
    (*  		    print(' crash register contents \');*)
    (*  		    print_hex(fullword(hw3, hw4))	*)
    (*  		  end " 8-43 " ;			*)
    (*  							*)
    (*  		44:  " report kernel host number and version number "*)
    (*  		  begin					*)
    (*  		    print(' kernel host \');		*)
    (*  		    print_hex(hw3);			*)
    (*  		    print(', version \ ');		*)
    (*  		    print_hex(hw4)			*)
    (*  		  end " 8-44 " ;			*)
    (*  							*)
    (*  		45:  " sequence number fix error "	*)
    (*  		  begin					*)
    (*  		    print(' sequence number fix error for buffer \ ');	*)
    (*  		    print_hex(hw3);			*)
    (*  		    print_newline;			*)
    (*  		    print_space(7);			*)
    (*  		    print('error count \ ');		*)
    (*  		    print_decimal(hw4)			*)
    (*  		  end " 8-45 " ;			*)
    (*  							*)
    (*  		46:  " temperature report "		*)
    (*  		  begin					*)
    (*  		    print(' temperature \');		*)
    (*  		    degree_in_cel := substr(hw4, 8, 0);	*)
    (*  		    print_decimal(degree_in_cel);	*)
    (*  		    print(' deg. C, \');		*)
    (*  		    degree_in_far := 			*)
    (*			      (substr(hw4, 8, 0)*18) + 320;	*)
    (*  		    print_decimal_scaled(		*)
    (*			      degree_in_far, 1);		*)
    (*  		    print(' deg. F\')			*)
    (*  		  end " 8-46 "				*)
    (*  	      end " case "   				*)
    (*  	    end						*)
    (*  	end						*)
    (*        else if left_byte >= first_event_8_line_subcode	*)
    (*        then						*)
    (*          begin						*)
    (*  	  if left_byte > last_event_8_line_subcode	*)
    (*            then print_unknown_event_8_line_report(	*)
    (*      	    right_byte, left_byte)			*)
    (*            else						*)
    (*  	    begin					*)
    (*  	      subcode := left_byte;			*)
    (*  	      print_line(hw1, right_byte);		*)
    (*  	      print( ' node report \');			*)
    (*   	      if subcode = 128  " total packets received and sent "	*)
    (*  	      then                            		*)
    (*  	        begin					*)
    (*                    print('total packets received \');	*)
    (*  	          print_decimal(hw3);			*)
    (*  	          print_newline;			*)
    (*  	          print('	    and sent \ ');	*)
    (*  	          print_decimal(hw4);			*)
    (*  	        end " 8-128 "				*)
    (*       							*)
    (*                else					*)
    (*  	        begin					*)
    (*  	          case subcode of			*)
    (*                      129:    " 8-129 : bad bori "	*)
    (*                        print( 'bad bori from\');		*)
    (*  							*)
    (*  	            130:    " 8-130 : bad ack "		*)
    (*  	              print('bad ack from\ ');		*)
    (*  							*)
    (*  	            131:    " 8-131 : bad record number "	*)
    (*  	              print('bad record number from\ ');*)
    (*  							*)
    (*  	            132:    " 8-132 : bad checksums "	*)
    (*  	              print('bad checksums from\ ');	*)
    (*  							*)
    (*  	            133:    " 8-133 : retransmissions from "	*)
    (*  	              print( 'retransmissions from\ ');	*)
    (*  							*)
    (*  	            134:    " 8-134 : retransmissions to "	*)
    (*  	              print( 'retransmissions to\ ');	*)
    (*  							*)
    (*  	            135:    " 8-135 : no data arrive "	*)
    (*  	              print( '4 seconds of no packet from\');	*)
    (* 								*)
    (*  	            136:    " 8-136 : cross talk "	*)
    (*                        print('cross talk to\');		*)
    (*  							*)
    (*  	            137:    " 8-137 : spacing on line "	*)
    (*  	              print('spacing on line from\ ');	*)
    (*  							*)
    (*  	            138:    " 8-138 : HDLC checksum errors "	*)
    (*                        print('hdlc checksum errors from\');	*)
    (*  							*)
    (*  	            139:    " 8-139 :n HDLC aborts "	*)
    (*                        print( 'hdlc aborts from\ ')      *)
    (*                    end " case " ;			*)
    (*  							*)
    (*                    print_newline;			*)
    (*  	          print_neighbor_and_occurrency		*)
    (*			    (substr(hw3,14,0), hw4)		*)
    (*                  end					*)
    (*  	    end						*)
    (*          end 						*)
    (*  							*)
    (*        else						*)
    (*          print_isis_report (				*)
    (*  	  hw1, left_byte, (left_byte = 63), 		*)
    (*		  right_byte, hw3, hw4)				*)
    (*      end " with "					*)
    (*  end " event_8 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(8);	(* event_8  *)
      put(substr(hw2, 8, 8));
      put(constant(0));
      ifcall(equal);	(* 8.0 - 8.127 *)
	put(substr_no_shift(hw2, 8));
	ifcall(range_check(FIRST_EVENT_8_NODE_SUBCODE, LAST_EVENT_8_NODE_SUBCODE));
	  print_node(hw1);
	  print(' node report,\');
	  put(substr_no_shift(hw2, 8));
	  casecall(FIRST_EVENT_8_NODE_SUBCODE, LAST_EVENT_8_NODE_SUBCODE);
      	    nextcase(1);  (* channel in use *)
	      print(' circuit assignment on assigned channel \ ');
	      print_hex(substr_no_shift(hw4, 15));
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
  	    endnextcase (* 8-1 *) ;

	    nextcase(2);  (* data on unassigned channel *)
	      print(' data on unassigned channel \ ');
	      print_hex(substr_no_shift(hw4, 15));
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase; (* 8-2 *) ;

	    nextcase(3);  (* buffer zap *)
	      print(' buffer \ ');
	      print_hex(hw3);
	      print(' zapped, \');
	      print_decimal(hw4);
	      print(' octets lost \');
	    endnextcase; (* 8-3 *) ;

	    nextcase(4);  (* remove neighbor response *)
	      put(hw4);
	      put(constant(32897));
	      ifcall(equal);
		print(' neighbor removed\') ;
	      endtrue;
		print(' neighbor not removed, was not found\ ');
	      endfalse;
	      endif;
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase; (* 8-4 *) ;
	
	    nextcase(5);  (* add neighbor response *)
	      put(hw4);
	      put(constant(65535));
	      ifcall(equal);
		print(' neighbor not added, link space unavailable,\ ') ;
	      endtrue;
		put(hw3);
		put(constant(32768));
		ifcall(greater_or_equal);
		  print(' neighbor added, window size \');
		  print_decimal(substr_no_shift(hw4, 15));
		endtrue;
		  print( ' neighbor not added, window size mismatch, window size \');
		  print_decimal(substr_no_shift(hw4, 8));;
		endfalse;
		endif;
	      endfalse;
	      endif;
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase; (* 8-5 *) ;			
          
	    nextcase(6);  (* link bubble *)		
	      print( ' link bubble with \ ');
	      print_decimal(substr_no_shift(hw4, 15));
	      print( ' channels\');
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase; (* 8-6 *) ;		        		 

	    nextcase(7);  (* link shrink *)
	      print(' link shrink with \ ');
	      print_decimal(substr_no_shift(hw4, 15));       
	      print(' channels\');
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase; (* 8-7 *) ;

	    nextcase(8);  (* out of permuter table space *)
	      print( ' out of permuter table space, line \');
	      print_decimal(substr_no_shift(hw4, 6));
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase; (* 8-8 *) ;

	    nextcase(9);  (* out of link descriptor space *)
	      print(' out of link descriptor space, line \ ');
	      print_decimal(substr_no_shift(hw4, 6));
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase; (* 8-9 *) ;

	    nextcase(10);  (* circuits being zapped *)
	      print(' link outage, \ ');
	      print_decimal(substr_no_shift(hw4, 15));
	      print(' circuits zapped\ ');
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase; (* 8-10 *) ;

	    nextcase(11);  (* out of dispatcher ports *)
	      print(' out of dispatcher ports, \ ');
	      print_decimal(hw3);
	      print( ' assigned\');
	      print_newline;
	      print_host(substr_no_shift(hw4, 15));
	    endnextcase; (* 8-11 *) ;

	    nextcase(12);  (* needle rejected, suspicious host *)
	      print(' needle rejected for out of ports with \');
	      print_decimal(hw3);
	      print( ' ports available\ ');
	      print_newline;
	      print_host(substr_no_shift(hw4, 15));
	    endnextcase (* 8-12 *) ;

	    nextcase(13);  (* host is impostor *)
	      print_host(substr_no_shift(hw4, 15));
	      print( ' on slot \');
	      print_decimal(substr(hw3, 8, 8));
	      print( ' claimed by slot \');
	      print_decimal(substr_no_shift(hw3, 8));
	    endnextcase (* 8-13 *) ;

	    nextcase(14);  (* circuit lifetime *)
	      print(' circuit lifetime \ ');
	      print_decimal(hw3);
	      print( ' seconds on channel \ ');
	      print_hex(substr_no_shift(hw4, 15));
	    endnextcase (* 8-14 *) ;

	    nextcase(15);  (* link snip *)
	      print(' link snip, error on channel \');
	      print_hex(substr_no_shift(hw4, 15));
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase (* 8-15 *) ;

	    nextcase(16);  (* diagnostic node report *)
	      put(substr(hw3, 8, 8));
	      put(constant(1));
	      put(equal);
	      put(substr(hw3, 8, 8));
	      put(constant(0));
	      put(equal);
	      ifcall(orfunc);
		put(substr(hw3, 8, 8));
		casecall(0, 1);
		  nextcase(0);   (* sync scan error *)
		    print(' sync scan error, sync ring index \ ');
		    print_hex(hw4);
		    print(', line \');
		  endnextcase;

		  nextcase(1);   (* bad count detected on sio buffer *)
		    print(' bad count of \ ');
		    print_decimal(hw4);
		    print(' on sio buffer, line \');
		  endnextcase;
		endcase;	
		print_decimal(substr(hw3, 7, 1));
	      endtrue;
		print(' unknown diagnostic report \');
		put(hw3);
		put(hw4);
		print_hex(fullword);
	      endfalse;
	      endif;
	    endnextcase (* 8-16 *) ;

	    nextcase(17);  (* next neighbor in needle not found *)
	      print(' next node in needle not found, needle flags \');
	      print_hex(hw4);
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase (* 8-17 *) ;

	    nextcase(18);  (* received message for another node *)
	      print(' invalid command address \');
	      print_hex(substr_no_shift(hw3, 15));
	      print(', total \ ');
	      print_decimal(substr_no_shift(hw4, 15));
	      print(' received\');
	    endnextcase (* 8-18 *) ;

	    nextcase(19);  (* received unrecognized command *)
	      print(' unrecognized command \ ');
	      print_hex(substr_no_shift(hw3, 15));
	      print(' total \');
	      print_decimal(substr_no_shift(hw4, 15));
	      print(' received\');
	    endnextcase (* 8-19 *) ;
			  
	    nextcase(20);  (* circuit building errors detected *)
	      print(' circuit build errors, lep \');
	      print_decimal(substr_no_shift(hw3, 15));
	      print(', crq \ ');
	      print_decimal(substr_no_shift(hw4, 15));
	    endnextcase (* 8-20 *) ;

	    nextcase(21);  (* circuit building inconsistency errors *)
	      print(' circuit build inconsistency, recent \');
	      print_decimal(substr_no_shift(hw3, 15));
	      print(', total \ ');
	      print_decimal(substr_no_shift(hw4, 15));
	    endnextcase (* 8-21 *) ;

	    nextcase(22);  (* link frozen *)
	      print(' link frozen, no records for \');
	      print_decimal(substr_no_shift(hw4, 15));
	      print(' seconds\ ');
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase (* 8-22 *) ;

	    nextcase(23);  (* link thawed *)
	      print(' link thawed, \ ');
	      print_decimal(substr_no_shift(hw4, 15));
	      print(' active circuits\ ');
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase (* 8-23 *) ;

	    nextcase(24);  (* number of priority circuits zapped *)
	      print(' priority circuits zapped: \');
	      print_decimal(substr_no_shift(hw4, 15));	     
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase (* 8-24 *) ;

	    nextcase(25);  (* node crash report *)
	      print(' crash, type: \ ');
	      put(substr(hw3, 8, 8));
	      put(constant(16));
	      ifcall(equal);
		print('reload or manual restart \');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(17));
	      elseifcall(equal);
		print('power failure \ ');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(18));
	      elseifcall(equal);
		print('power failure or manual restart \ ');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(32));
	      elseifcall(equal);
		print('parity error at \ ');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(50));
	      elseifcall(equal);
		print('unexpected interrupt, count \ ');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(65));
	      elseifcall(equal);
		print('illegal instruction at \');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(80));
	      elseifcall(equal);
		print('mac error/protection violation at \ ');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(96));
	      elseifcall(equal);
		print('illegal svc at \');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(97));
	      elseifcall(equal);
		print('dispatcher at \ ');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(99));
	      elseifcall(equal);
		print('software consistency error at \ ');
	      endtrue;

	      put(substr(hw3, 8, 8));
	      put(constant(145));
	      elseifcall(equal);
		print('device check at \ ');
	      endtrue;

		print('unknown \ ');

	      endfalse;
	      endif;

	      put(substr_no_shift(hw3, 8));
	      put(hw4);		    
	      print_hex(fullword);
	    endnextcase (* 8-25 *) ;


	    nextcase(26);  (* report node resources: lines and links *)
	      print(' configured for \ ');
	      print_decimal(substr(hw3, 4, 8));
	      print(' sio lines, \ ');
	      print_decimal(substr_no_shift(hw3, 4));
	      print(' sync lines\');
	      print_newline;
	      print_space(7);
	      print_decimal(substr(hw4, 4, 8));
	      print( ' xlinks, \');
	      print_decimal(substr_no_shift(hw4, 4));
	      print( ' total links\ ');
	    endnextcase  (* 8-26 *) ;
		  
	    nextcase(27);  (* report node resources: ports and passthroughs *)
	      print(' configured for \ ');
	      print_decimal(substr_no_shift(hw3, 15));
	      print(' ports, \ ');
	      print_decimal(substr_no_shift(hw4, 15));
	      print(' passthroughs\');
	    endnextcase (* 8-27 *) ;

	    nextcase(28);  (* report node resources: lines used *)
	      print(' lines unused: \');
	      put(hw3);
	      put(hw4);
	      print_link_string;
	    endnextcase (* 8-28 *) ;

	    nextcase(29);  (* report node resources: links on used lines *)
	      put(substr_no_shift(hw3, 8));
	      put(constant(255));
	      ifcall(equal);
		print(' defined\ ');
	      endtrue;
		print(' attached\');
	      endfalse;
	      endif;
	      put(hw3);
	      put(constant(32767));   (* 7FFF *)
	      ifcall(greater_than);
		print(' sio\ ');
	      endtrue;
		print(' sync\');
	      endfalse;
	      endif;
	      print(' line \ ');
	      
	      put(substr_no_shift(hw3, 8));
	      put(constant(255));
	      ifcall(equal);
		put(substr(hw3, 5, 8));
		put(constant(0));
		put(equal);
		ifcall(notfunc);
		  put(substr(hw3, 5, 8));
		  call_proc(PRINT_SPEED);
		endtrue;
		endif;
	      endtrue;
		print_decimal(substr_no_shift(hw3, 7));
		put(substr(hw3, 5, 8));
		put(constant(0));
		ifcall(equal);
		  print(', frozen\ ');
		endtrue;
		  put(substr(hw3, 5, 8));
		  call_proc(PRINT_SPEED);
		endfalse;
		endif;
	      endfalse;
	      endif;

	      put(substr(hw3, 1, 13));
	      put(constant(1));
	      ifcall(equal);
		print('satellite link\ ');
	      endtrue;
	      endif;
	      put(substr_no_shift(hw4, 15));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase (* 8-29 *) ;


	    nextcase(30);  (* slot report limit exceeded *)
	      print(' slot \ ');
	      print_decimal(substr_no_shift(hw3, 15));
	      print(' exceeded report limit of \ ');
	      print_decimal(hw4);
	    endnextcase (* 8-30 *) ;

	    nextcase(31);  (* restricted host on invalid slot *)
	      print(' restricted  \');
	      print_host(substr_no_shift(hw4, 15));
	      print(' on invaild slot \');  
	      print_decimal(substr_no_shift(hw3, 15));
	    endnextcase (* 8-31 *) ;

	    nextcase(32);  (* restricted slot/host circuit limit exceeded *)
	      print(' restricted \ ');
	      put(substr_no_shift(hw4,15));
	      put(constant(0));
	      put(equal);
	      ifcall(notfunc);
	        print_host(substr_no_shift(hw4, 15));
	      endtrue;
		put(substr(hw3, 8, 8));
	        put(substr_no_shift(hw3, 8));
		call_proc(PRINT_MXP_AND_SLOT);
	      endfalse;
	      endif;
	      print_newline;
	      print_space(7);
	      print('attempted to exceed circuit limit\');
	    endnextcase (* 8-32 *) ;

	    nextcase(33);  (* number of circuits zapped by dload *)
	      print(' circuits zapped by dload, terminating \');
	      print_decimal(substr_no_shift(hw3, 15));
	      print_newline;
	      print_space(7);
	      print('passthrough \ ');
	      print_decimal(substr_no_shift(hw4, 15));
	    endnextcase (* 8-33 *) ;

	    nextcase(34);  (* invalid 03 character pair on command circuit *)
	      print(' invaild 03 character pair on command circuit\');
	      print_newline;
	      print_space(7);
	      print('second character \');
	      print_hex(substr_no_shift(hw4, 8));
	    endnextcase (* 8-34 *) ;

	    nextcase(35);  (* recoverable mac error *)
	      print(' recoverable mac error at \ ');
	      put(substr_no_shift(hw3, 8));
	      put(hw4);
	      print_hex(fullword);
	    endnextcase (* 8-35 *) ;

	    nextcase(36);  (* sio output timeout *)
	      print(' sio output timeout on line \ ');
	      print_decimal(hw4);
	      print(' after \');
	      print_decimal_scaled(hw3, 3);
	      print(' seconds\ ');    
	    endnextcase (* 8-36 *) ;

	    nextcase(37);  (* data on disabled async port *)
	      print(' data on disabled async port \');
	      print_hex(substr_no_shift(hw4, 15));
	    endnextcase (* 8-37 *) ;

	    nextcase(38);  (* invalid 03 character pair on tymnet I command circuit *)
	      print(' invalid 03 character pair on tymnet I command circuit\ ');
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	      print(' second character \ ');
	      print_hex(substr_no_shift(hw4, 8));
	    endnextcase (* 8-38 *) ;

	    nextcase(39);  (* invalid record length on a tymnet I command circuit *)
	      print(' invalid record length \');
	      print_decimal(substr_no_shift(hw4, 15));
	      print(' on tymnet I command circuit\ ');
	      put(substr_no_shift(hw3, 14));
	      call_proc(PRINT_NEIGHBOR_NODE);
	    endnextcase (* 8-39 *) ;

	    nextcase(40);  (* dma timeout, mac interrupt *)
	      print(' dma timeout, \ ');
	      print_decimal(substr_no_shift(hw3, 15));
	      print(' sio lines, mac interrupt status \');
	      print_hex(hw4);
	    endnextcase (* 8-40 *) ;	  			   		

	    nextcase(41);  (* svc to zap kernel port failed *)
  	      print(' svc to zap kernel port failed\ ');
	    endnextcase (* 8-41 *) ;

	    nextcase(42);  (* first addendum to crash report *)
	      print(' crash report addendum, code \');
	      print_decimal(substr(hw3, 4, 8));
	      print(', count \ ');
	      print_decimal(substr_no_shift(hw3, 8));
	      print(', version \ ');
	      print_decimal(substr(hw4, 4, 8));
	      print_newline;
	      print_space(7);
	      print('crash register reports \');
	      print_decimal(substr_no_shift(hw4, 8));
	    endnextcase (* 8-42 *) ;

	    nextcase(43);  (* second addendum to crash report *)
	      print(' crash register contents \');
	      put(hw3);
	      put(hw4);
	      print_hex(fullword);
	    endnextcase (* 8-43 *) ;

	    nextcase(44);  (* report kernel host number and version number *)
	      print(' kernel host \');
	      print_hex(hw3);
	      print(', version \ ');
	      print_hex(hw4);
	    endnextcase (* 8-44 *) ;

	    nextcase(45);  (* sequence number fix error *)
	      print(' sequence number fix error for buffer \ ');
	      print_hex(hw3);
	      print_newline;
	      print_space(7);
	      print('error count \ ');
	      print_decimal(hw4);
	    endnextcase (* 8-45 *) ;

	    nextcase(46);  (* temperature report *)
	      print(' temperature \');
	      print_decimal(substr(hw4, 8, 0));
	      print(' deg. C, \');
	      put(substr(hw4, 8, 0));
	      put(constant(18));
	      put(product);
	      put(constant(320));
	      print_decimal_scaled(sum, 1);
	      print(' deg. F\');
    	    endnextcase (* 8-46 *) ;
	  endcase;
	endtrue;
	  put(substr_no_shift(hw2, 8));
	  call_proc(PRINT_UNKNOWN_EVENT_8_NODE_REPORT);
	endfalse;
	endif;
      endtrue;

      put(substr(hw2, 8, 8));
      put(constant(FIRST_EVENT_8_LINE_SUBCODE));
      elseifcall(greater_or_equal);	(* 8.128 - 8.255 *)
	put(substr(hw2, 8, 8));
        put(constant(LAST_EVENT_8_LINE_SUBCODE));
	ifcall(greater_than);
	  put(substr_no_shift(hw2, 8));
	  put(substr(hw2, 8, 8));
	  call_proc(PRINT_UNKNOWN_EVENT_8_LINE_REPORT);
	endtrue;
	  put(hw1);
	  put(substr_no_shift(hw2, 8));
	  call_proc(PRINT_LINE);
	  print(' node report \');
	  put(substr(hw2, 8, 8));
	  put(constant(FIRST_EVENT_8_LINE_SUBCODE));
	  ifcall(equal);
	    print('total packets received \');
	    print_decimal(hw3);
	    print_newline;
	    print_space(10);
	    print('and sent \');
	    print_decimal(hw4);
	  endtrue;
	    put(substr(hw2, 8, 8));
	    casecall(129, LAST_EVENT_8_LINE_SUBCODE);
              nextcase(129);	(* 8-129 : bad bori *)
                print( 'bad bori from\');
	      endnextcase;

	      nextcase(130);    (* 8-130 : bad ack *)
	        print('bad ack from\ ');
	      endnextcase;

	      nextcase(131);    (* 8-131 : bad record number *)
	        print('bad record number from\ ');
	      endnextcase;

	      nextcase(132);    (* 8-132 : bad checksums *)
	        print('bad checksums from\ ');
	      endnextcase;

	      nextcase(133);    (* 8-133 : retransmissions from *)
	        print( 'retransmissions from\ ');
	      endnextcase;

	      nextcase(134);    (* 8-134 : retransmissions to *)
	        print( 'retransmissions to\ ');
	      endnextcase;

	      nextcase(135);    (* 8-135 : no data arrive *)
	        print( '4 seconds of no packet from\');
	      endnextcase;

	      nextcase(136);    (* 8-136 : cross talk *)
                print('cross talk to\');
	      endnextcase;

	      nextcase(137);    (* 8-137 : spacing on line *)
	        print('spacing on line from\ ');
	      endnextcase;

	      nextcase(138);    (* 8-138 : HDLC checksum errors *)
                print('hdlc checksum errors from\');
	      endnextcase;

	      nextcase(139);    (* 8-139 : HDLC aborts *)
                print( 'hdlc aborts from\ ');                           
	      endnextcase;
	      
	    endcase;
	    print_newline;
	    put(substr_no_shift(hw3, 14));
	    put(hw4);
	    call_proc(PRINT_NEIGHBOR_AND_OCCURRENCY);
	  endfalse;
	  endif;
	endfalse;
	endif;
      endtrue;

	put(hw1);
	put(substr(hw2, 8, 8));
	put(substr(hw2, 8, 8));
	put(constant(63));
	put(equal);
	put(substr_no_shift(hw2, 8));
	put(hw3);
	put(hw4);;
	call_proc(PRINT_ISIS_REPORT);
      endfalse;
      endif;
    endnextcase (* event_8 *) ;


    (************************************************************)
    (*								*)
    (*  Illegal record.						*)
    (*								*)
    (*  procedure event_9;					*)
    (*								*)
    (*  begin							*)
    (*    print('bad record \');				*)
    (*    with current_message do				*)
    (*        begin						*)
    (*  	print_node(substr(hw2, 12, 0));			*)
    (*  	print_space(1);					*)
    (*  	print_hex(fullword(hw3, hw4))			*)
    (*        end						*)
    (*  end " event_9 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(9);	(* event_9  *)
      print('bad record \');
	print_node(substr_no_shift(hw2, 12));
	print_space(1);
      	put(hw3);
	put(hw4);
	print_hex(fullword);
    endnextcase (* event_9 *) ;


    (************************************************************)
    (*								*)
    (*  Nonfatal error.						*)
    (*								*)
    (*  procedure event_10;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_line(hw2, hw1);				*)
    (*        print(' nonfatal error: \');			*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end  " event_10 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(10);	(* event_10  *)
      put(hw2);
      put(hw1);
      call_proc(PRINT_LINE);
      print(' nonfatal error: \');
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_10 *) ;


    (************************************************************)
    (*								*)
    (*  Unable to takeover node.				*)
    (*								*)
    (*  procedure event_11;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' unable to take over..\ ');		*)
    (*        if hw4 = 0 then print('no path\')			*)
    (*        else if hw4 = 1 then print('line cost too high\ ')*)
    (*        else						*)
    (*  	begin						*)
    (*  	  print('reason: \ ');				*)
    (*  	  print_octal(hw4)				*)
    (*  	end						*)
    (*      end " with "					*)
    (*  end " event_11 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(11);	(* event_11  *)
      print_node(hw2);
      print(' unable to take over..\ ');
      put(hw4);
      put(constant(0));
      ifcall(equal);
        print('no path\');
      endtrue;
        put(hw4);
        put(constant(1));
        ifcall(equal);
	  print('line cost too high\ ');
	endtrue;
	  print('reason: \ ');
	  print_octal(hw4);
	endfalse;
	endif;
      endfalse;
      endif;
    endnextcase (* event_11 *) ;	


    nextcase(12);	(* event_12  *)
      call_proc(PRINT_UNKNOWN_EVENT);
    endnextcase (* event_12 *) ;


    (************************************************************)
    (*								*)
    (*  IRC rotation problem.					*)
    (*								*)
    (*  procedure event_13;					*)    
    (*								*)
    (*  "code 13 message subcodes "				*)    
    (*								*)
    (*  const							*)    
    (*    first_code_13_subcode = 0;				*)
    (*    last_code_13_subcode  = 14;				*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        link_check(hw3, hw4);				*)
    (*        print_node(hw3);					*)
    (*        print(' and \');					*)
    (*        print_node(hw4);					*)
    (*        print(' rotate problem..\');			*)
    (*        if (hw2 < first_code_13_subcode) or (last_code_13_subcode < hw2)*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print('reason: \ ');				*)
    (*  	  print_decimal(hw2)				*)
    (*  	end						*)
    (*        else						*)
    (*          case hw2 of					*)
    (*  	  0:  print('list3 entry not found\');		*)
    (*  	  1:  print('neighbor mismatch list3\');	*)
    (*  	  2:  print('list1 too long\ ');		*)
    (*  	  3:  print('list2 entry too large\');		*)
    (*  	  4:  print('list2 or list3 too long\');	*)
    (*  	  5:  print('list1 has zero node number\ ');	*)
    (*  	  6:  print('list1a has zero or invalid entry\ ');*)
    (*  	  7:  print('list2 wrong size\ ');		*)
    (*  	  8:  print('list1 has illegal node\ ');	*)
    (*  	  9:  print('list1 has a duplicate link\ ');	*)
    (*  	  10: print('illegal node in rotation group\ ');*)
    (*  	  11: print('duplicated link in rotation groups\ ');*)
    (*  	  12: print('list2 entry for link not at start of rotation group\');*)
    (*  	  13: print('IRC link not in own rotation group\ ');*)
    (*  	  14: print('rotation group entry not on list1\')*)
    (*  	end " case "					*)
    (*      end " with "					*)
    (*  end " event_13 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(13);	(* event_13  *)
      put(hw3);
      put(hw4);
      link_check;
      print_node(hw3);
      print(' and \');
      print_node(hw4);
      print(' rotate problem..\');
      put(hw2);
      ifcall(range_check(FIRST_CODE_13_SUBCODE, LAST_CODE_13_SUBCODE));
	put(hw2);
	casecall(FIRST_CODE_13_SUBCODE, LAST_CODE_13_SUBCODE);
	  nextcase(0);
	    print('list3 entry not found\');
	  endnextcase;

	  nextcase(1);
	    print('neighbor mismatch list3\');
	  endnextcase;

	  nextcase(2);
	    print('list1 too long\ ');
	  endnextcase;

	  nextcase(3);
	    print('list2 entry too large\');		
	  endnextcase;

	  nextcase(4);
	    print('list2 or list3 too long\');		  
	  endnextcase;

	  nextcase(5);
  	    print('list1 has zero node number\ ');	
	  endnextcase;

	  nextcase(6);
	    print('list1a has zero or invalid entry\ ');
	  endnextcase;

	  nextcase(7);
	    print('list2 wrong size\ ');		
	  endnextcase;

	  nextcase(8);
	    print('list1 has illegal node\ ');	
	  endnextcase;

	  nextcase(9);
	    print('list1 has a duplicate link\ ');	
	  endnextcase;

	  nextcase(10);
	    print('illegal node in rotation group\ ');
	  endnextcase;

	  nextcase(11);
	    print('duplicated link in rotation groups\ ');
	  endnextcase;

	  nextcase(12);
	    print('list2 entry for link not at start of rotation group\');
	  endnextcase;

	  nextcase(13);
	    print('IRC link not in own rotation group\ ');
	  endnextcase;

	  nextcase(14);
	    print('rotation group entry not on list1\');
	  endnextcase;
	endcase;
      endtrue;
	print('reason: \ ');
	print_decimal(hw2);
      endfalse;
      endif;
    endnextcase (* event_13 *);


    (************************************************************)
    (*								*)
    (*  Tymnet II message too long.				*)
    (*								*)
    (*  procedure event_14;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('message too long. addr = \');		*)
    (*        print_hex(fullword(hw1, hw2));			*)
    (*        print(' sup pc = \ ');				*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_14 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(14);	(* event_14  *)
      print('message too long. addr = \');
      put(hw1);
      put(hw2);
      print_hex(fullword);
      print(' sup pc = \ ');
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_14 *) ;


    (************************************************************)
    (*								*)
    (*  Bad subtype in Tymnet II message.			*)
    (*								*)
    (*  procedure event_15;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' bad subtype in message..type \ ');	*)
    (*        print_decimal_with_d(hw3);			*)
    (*        print(' sub \');					*)
    (*        print_decimal_with_d(hw4)				*)
    (*      end " with "					*)
    (*  end " event_15 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(15);	(* event_15  *)
      print_node(hw2);
      print(' bad subtype in message..type \ ');
      print_decimal_with_d(hw3);
      print(' sub \');
      print_decimal_with_d(hw4);
    endnextcase (* event_15 *) ;


    (************************************************************)
    (*								*)
    (*  Rebuild error in Tymnet II.				*)
    (*								*)
    (*  procedure event_16;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw1);					*)
    (*        print(' base \ ');				*)
    (*        print_decimal(hw2);				*)
    (*        print(' rebuild error to \ ');			*)
    (*        print_node(hw3);					*)
    (*        print(' out link = \ ');				*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_16 ";					*)
    (*								*)    
    (************************************************************)


    nextcase(16);	(* event_16  *)
      print_node(hw1);
      print(' base \ ');
      print_decimal(hw2);
      print(' rebuild error to \ ');
      print_node(hw3);
      print(' out link = \ ');
      print_node(hw4);
    endnextcase;


    (************************************************************)
    (*								*)
    (*  Rebuild failure in Tymnet II.				*)
    (*								*)
    (*  procedure event_17;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw1);					*)
    (*        print(' base \ ');				*)
    (*        print_decimal(hw2);				*)
    (*        print(' rebuild failure to \ ');			*)
    (*        print_node(hw3);					*)
    (*        print(' out link = \ ');				*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_17 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(17);	(* event_17  *)
      print_node(hw1);
      print(' base \ ');
      print_decimal(hw2);
      print(' rebuild failure to \ ');
      print_node(hw3);
      print(' out link = \ ');
      print_node(hw4);
    endnextcase (* event_17 *) ;


    (************************************************************)
    (*								*)
    (*  Line out in Tymnet I.					*)
    (*								*)
    (*  procedure event_18;					*)
    (*								*)
    (*  " code 18 message subcodes "				*)
    (*  							*)
    (*  const							*)
    (*    first_code_18_subcode = 1;				*)
    (*    last_code_18_subcode = 6;				*)
    (*  							*)
    (*  var							*)
    (*    subcode: integer;					*)
    (*  							*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_line(hw2, hw1);				*)
    (*        print(' out \');					*)
    (*        subcode := substr(hw3, 9, 0);			*)
    (*        if (subcode < first_code_18_subcode) or (last_code_18_subcode < subcode)	*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print('-reason: \');				*)
    (*  	  print_decimal(subcode)			*)
    (*  	end						*)
    (*        else						*)
    (*  	begin						*)
    (*  	  case subcode of				*)
    (*  	    1:  print('-no rec interrupts-\');		*)
    (*  	    2:  print('-see only space(0)-\');		*)
    (*  	    3:  print('-see only mark(1)-\ ');		*)
    (*  	    4:  print('-noise or bori zap-\');		*)
    (*  	    5:  print('-noise-\');			*)
    (*  	    6:  print('-rec noise-no trans clock-\ ')	*)
    (*  	  end " case " ;				*)
    (*  	  print_pli(hw4)				*)
    (*  	end						*)
    (*      end " with "					*)
    (*  end " event_18 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(18);	(* event_18  *)
      put(hw2);
      put(hw1);
      call_proc(PRINT_LINE);
      print(' out \');
      put(substr_no_shift(hw3, 9));
      ifcall(range_check(FIRST_CODE_18_SUBCODE, LAST_CODE_18_SUBCODE));
        put(substr_no_shift(hw3, 9));
	casecall(FIRST_CODE_18_SUBCODE, LAST_CODE_18_SUBCODE);
	  nextcase(1);
	    print('-no rec interrupts-\');
	  endnextcase;

	  nextcase(2);
	    print('-see only space(0)-\');
	  endnextcase;

	  nextcase(3);
	    print('-see only mark(1)-\ ');
	  endnextcase;

	  nextcase(4);
	    print('-noise or bori zap-\');
	  endnextcase;

	  nextcase(5);
	    print('-noise-\');
	  endnextcase;

	  nextcase(6);
	    print('-rec noise-no trans clock-\ ');
	  endnextcase;
	endcase;
        put(hw4);
	call_proc(PRINT_PLI);
      endtrue;
	print('-reason: \');
	print_decimal(substr_no_shift(hw3, 9));
      endfalse;
      endif;
    endnextcase(* event_18 *) ;


    (************************************************************)
    (*								*)
    (*  Link status from Tymnet II node.			*)
    (*								*)
    (*  procedure event_19;					*)
    (*								*)
    (*  " code 19 message subcodes "				*)
    (*  							*)
    (*  const							*)
    (*    first_code_19_subcode = 0;				*)
    (*    last_code_19_subcode  = 6;				*)
    (*  							*)
    (*  var							*)
    (*    subcode	: integer;				*)
    (*    line_number	: port_index;				*)
    (*    speed		: integer;				*)
    (*  							*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        link_check(hw1, hw4);				*)
    (*        if (hw2 < first_code_19_subcode) or (last_code_19_subcode < hw2)	*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print_node(hw1);				*)
    (*  	  print(' link status report..type \ ');	*)
    (*  	  print_decimal(hw2)				*)
    (*  	end						*)
    (*        else						*)
    (*  	begin						*)
    (*  	  line_number := substr(hw3, 8, 0);		*)
    (*  	  case hw2 of					*)
    (*  	    0:   " link overloaded "			*)
    (*  	      begin					*)
    (*  		print_node(hw1);			*)
    (*  		print(' link overloaded\ ')		*)
    (*  	      end " 19-0 " ;				*)
    (*    							*)
    (*  	    1:   " line errors "			*)
    (*  	      begin					*)
    (*  		print_node(hw1);			*)
    (*  		print_decimal(hw3);			*)
    (*  		print(' line errors\ ')			*)
    (*  	      end " 19-1 " ;				*)
    (*    							*)
    (*  	    2:   " line attached "			*)
    (*  	      begin					*)
    (*  		print_line(hw1, line_number);		*)
    (*  		print(' attached..\');			*)
    (*  		speed := substr(hw3, 5, 8);		*)
    (*  		if speed = 0				*)
    (*  		then 					*)
    (*  		  print('frozen\ ')			*)
    (*  		else 					*)
    (*  		  print_speed(speed)			*)
    (*  	      end " 19-2 " ;				*)
    (*    							*)
    (*  	    3:   " new link "				*)
    (*  	      begin					*)
    (*  		print_line(hw1, line_number);		*)
    (*  		print(' new link .. \');		*)
    (*  		speed := substr(hw3, 5, 8);		*)
    (*  		if speed = 0				*)
    (*  		then					*)
    (*  		  print('frozen\ ')			*)
    (*  		else					*)
    (*  		  print_speed(speed)			*)
    (*                end " 19-3 " ;				*)
    (*    							*)
    (*  	    4,   " line detached "			*)
    (*  	    5:   " link out "				*)
    (*  	      begin					*)
    (*  		print_line(hw1, line_number);		*)
    (*  		case hw2 of				*)
    (*  		  4: print(' detached\');		*)
    (*  		  5: print(' link out\')		*)
    (*  		end " case " ;				*)
    (*  		print('..reason: \ ');			*)
    (*  		subcode := substr(hw3, 8, 8);		*)
    (*  		if (subcode < 1) or (4 < subcode)	*)
    (*  		then					*)
    (*  		  print_decimal(subcode)		*)
    (*  		else					*)
    (*  		  case subcode of			*)
    (*  		    1, 2: 				*)
    (*  		      begin				*)
    (*  		        print('no records received\');	*)
    (*  			print_newline;			*)
    (*  		        print('     on link\ ')		*)
    (*  		      end;				*)
    (*  		    3: print('reset received\ ');	*)
    (*  		    4: print('BORI zap occurred\')	*)
    (*  		  end " case "				*)
    (*  	      end " 19-4, 5 " ;				*)
    (*  							*)
    (*  	    6:   " link out of bandwidth "		*)
    (*  	      begin					*)
    (*  		print_node(hw1);			*)
    (*  		print(' link out of bandwidth\ ')	*)
    (*  	      end " 19-7 "				*)
    (*  	  end " case "					*)
    (*  	end;						*)
    (*        print(' to \ ');					*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_19 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(19);	(* event_19  *)
      put(hw1);
      put(hw4);
      link_check;
      put(hw2);
      ifcall(range_check(FIRST_CODE_19_SUBCODE, LAST_CODE_19_SUBCODE));
	put(hw2);
	casecall(FIRST_CODE_19_SUBCODE, LAST_CODE_19_SUBCODE);     
	  nextcase(0);
	    print_node(hw1);
	    print(' link overloaded\ ');
	  endnextcase;

	  nextcase(1);
	    print_node(hw1);
	    print_decimal(hw3);
	    print(' line errors\ ');
	  endnextcase;

	  nextcase(2);
	    put(hw1);
	    put(substr_no_shift(hw3, 8));
	    call_proc(PRINT_LINE);
	    print(' attached..\');
	    put(substr(hw3, 5, 8));
	    put(constant(0));
	    ifcall(equal);
	      print('frozen\ ');
	    endtrue;
	      put(substr(hw3, 5, 8));
	      call_proc(PRINT_SPEED);
	    endfalse;
	    endif;
	  endnextcase;

	  nextcase(3);
	    put(hw1);
	    put(substr_no_shift(hw3, 8));
	    call_proc(PRINT_LINE);
	    print(' new link .. \');
	    put(substr(hw3, 5, 8));
	    put(constant(0));
	    ifcall(equal);
	      print('frozen\ ');
	    endtrue;
	      put(substr(hw3, 5, 8));
	      call_proc(PRINT_SPEED);
	    endfalse;
	    endif;
	  endnextcase;

	  nextcase(4);
	  nextcase(5);
	    put(hw1);
	    put(substr_no_shift(hw3, 8));
	    call_proc(PRINT_LINE);
	    put(hw2);
	    put(constant(4));
	    ifcall(equal);
	      print(' detached\');
	    endtrue;
	    put(hw2);
	    put(constant(5));
	    elseifcall(equal);
	      print(' link out\');
	    endtrue;
	    endfalse;
	    endif;
	    print('..reason: \ ');
	    put(substr(hw3, 8, 8));
	    ifcall(range_check(1, 4));
	      put(substr(hw3, 8, 8));
	      casecall(1, 4);
		nextcase(1);
		nextcase(2);
		  print('no records received\');
		  print_newline;
	   	  print_space(5);
	  	  print('on link\');
		endnextcase;

		nextcase(3);
		  print('reset received\ ');
		endnextcase;

		nextcase(4);
		  print('BORI zap occurred\');
		endnextcase;
	      endcase;
	    endtrue;
	      print_decimal(substr(hw3, 8, 8));
	    endfalse;
	    endif;
	  endnextcase;

	  nextcase(6);
	    print_node(hw1);
	    print(' link out of bandwidth\ ');
	  endnextcase;
	endcase;
      endtrue;
        print_node(hw1);
        print(' link status report..type \ ');
	print_decimal(hw2);
      endfalse;
      endif;
      print(' to \ ');
      print_node(hw4);
    endnextcase (* event_19 *) ;


    (************************************************************)
    (*								*)
    (*    Bad MUD.						*)
    (*								*)
    (*  procedure event_20;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('bad MUD at block \');			*)
    (*        print_hex(fullword(hw1, hw2));			*)
    (*        print(', logid = \ ');				*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*    end " with "						*)
    (*  end " event_20 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(20);	(* event_20  *)
      print('bad MUD at block \');
      put(hw1);
      put(hw2);
      print_hex(fullword);
      print(', logid = \ ');
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_20 *) ;


    (************************************************************)
    (*								*)
    (*  Network character in supervisor message.		*)
    (*								*)
    (*  procedure event_21;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('invalid sup message on port 0 \ ');	*)
    (*        print_hex(fullword(hw1, hw2));			*)
    (*        print_space(1);					*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_21 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(21);	(* event_21  *)
      print('invalid sup message on port 0 \ ');
      put(hw1);
      put(hw2);
      print_hex(fullword);
      print_space(1);
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_21 *) ;


    (************************************************************)
    (*								*)
    (*  Input dispatcher inconsistency.				*)
    (*								*)
    (*  procedure event_22;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        line_check(hw2, hw1);				*)
    (*        print_node(hw2);					*)
    (*        print(' input inconsistency, port \');		*)
    (*        print_hex(hw1);					*)
    (*        print(' type \ ');				*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_22 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(22);	(* event_22  *)
      put(hw2);
      put(hw1);
      line_check;
      print_node(hw2);
      print(' input inconsistency, port \');
      print_hex(hw1);
      print(' type \ ');
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_22 *) ;


    (************************************************************)
    (*								*)
    (*  Invalid port number on supervisor message input.	*)
    (*								*)
    (*  procedure event_23;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' invalid sup msg port \ ');		*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_23 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(23);	(* event_23  *)
      print_node(hw2);
      print(' invalid sup msg port \ ');
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_23 *) ;


    (************************************************************)
    (*								*)
    (*  Pill count.						*)
    (*								*)
    (*  procedure event_24;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('pill received, cnt = \');			*)
    (*        print_decimal(hw2);				*)
    (*        print(' from sup \ ');				*)
    (*        print_octal(hw4)					*)
    (*      end " with "  					*)
    (*  end " event_24 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(24);	(* event_24  *)
      print('pill received, cnt = \');
      print_decimal(hw2);
      print(' from sup \ ');
      print_octal(hw4);
    endnextcase (* event_24 *) ;


    (************************************************************)
    (*								*)
    (*  Invalid supervisor message.				*)
    (*								*)
    (*  procedure event_25;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('invalid sup msg from \');			*)
    (*        print_node(hw2);					*)
    (*        print(' type \ ');				*)
    (*        print_octal(hw4)					*)
    (*      end " with "					*)
    (*  end " event_25 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(25);	(* event_25  *)
      print('invalid sup msg from \');
      print_node(hw2);
      print(' type \ ');
      print_octal(hw4);
    endnextcase (* event_25 *) ;


    (************************************************************)
    (*								*)
    (*  Line overloaded.					*)
    (*								*)
    (*  procedure event_26;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_line(hw2, hw1);				*)
    (*        print(' overloaded\')				*)
    (*      end " with "					*)
    (*  end " event_26 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(26);	(* event_26  *)
      put(hw2);
      put(hw1);
      call_proc(PRINT_LINE);
      print(' overloaded\');
    endnextcase (* event_26 *) ;


    (************************************************************)
    (*								*)
    (*  Line error.						*)
    (*								*)
    (*  procedure event_27;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_line(hw2, hw1);				*)
    (*        print_space(1);					*)
    (*        print_decimal(hw4);				*)
    (*        print(' errors\')					*)
    (*      end " with "					*)
    (*  end " event_27 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(27);	(* event_27  *)
      put(hw2);
      put(hw1);
      call_proc(PRINT_LINE);
      print_space(1);
      print_decimal(hw4);
      print(' errors\');
    endnextcase (* event_27 *) ;


    (************************************************************)
    (*								*)
    (*  Out of channels.					*)
    (*								*)
    (*  procedure event_28;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_line(hw2, hw1);				*)
    (*        print(' out of channels\ ')			*)
    (*      end " with "					*)
    (*  end " event_28 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(28);	(* event_28  *)
      put(hw2);
      put(hw1);
      call_proc(PRINT_LINE);
      print(' out of channels\ ');
    endnextcase (* event_28 *) ;


    (************************************************************)
    (*								*)
    (*  Out of passthroughs.					*)
    (*								*)
    (*  procedure event_29;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' out of passthroughs\ ')			*)
    (*      end " with "					*)
    (*  end " event_29 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(29);	(* event_29  *)
      print_node(hw2);
      print(' out of passthroughs\ ');
    endnextcase (* event_29 *) ;


    (************************************************************)
    (*								*)
    (*  Spewing characters.					*)
    (*								*)
    (*  procedure event_30;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' port \ ');				*)
    (*        print_decimal_with_d(substr(hw4, 15, 1));		*)
    (*        print(' spewing characters\')			*)
    (*      end " with "					*)
    (*  end " event_30 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(30);	(* event_30  *)
      print_node(hw2);
      print(' port \ ');
      print_decimal_with_d(substr(hw4, 15, 1));
      print(' spewing characters\');
    endnextcase (* event_30 *) ;


    (************************************************************)
    (*								*)
    (*  Sup sleep.						*)
    (*								*)    
    (************************************************************)


    nextcase(31);	(* event_31  *)
      print('sup going to sleep...\');
    endnextcase (* event_31 *) ;


    (************************************************************)
    (*								*)
    (*  Host status. Only print if it has changed.		*)
    (*								*)
    (*  procedure event_32;					*)
    (*								*)
    (*  " code 32 message subcodes "				*)
    (*  							*)
    (*  const							*)
    (*    first_code_32_subcode = 1;				*)
    (*    last_code_32_subcode 	= 9;				*)
    (*  							*)
    (*  var							*)
    (*    old_state	: integer;				*)
    (*    right_byte 	: integer;				*)
    (*  							*)
    (*  begin							*)
    (*    " strip off the high-order bits of hw1 which contain the product id "*)
    (*    right_byte := substr(current_message.hw1, 8, 0);	*)
    (*    with current_message do				*)
    (*      if (right_byte < first_code_32_subcode) 		*)
    (*      or (last_code_32_subcode < right_byte)		*)
    (*      then 						*)
    (*        print_unknown_event				*)
    (*  							*)
    (*      else						*)
    (*        case right_byte of				*)
    (*  	1,    " coming up "				*)
    (*  	2,    " down "					*)
    (*  	3,    " answered "				*)
    (*  	4,    " shut "					*)
    (*  	7:    " gone "					*)
    (*  	  if host_limit < hw2				*)
    (*  	  then						*)
    (*  	    begin					*)
    (*  	      print('out of range host number in status message \');*)
    (*  	      print_decimal(hw2)			*)
    (*  	    end						*)
    (*  							*)
    (*  	  else						*)
    (*  	    begin					*)
    (*                print_node(hw4);				*)
    (*                print_host(hw2);				*)
    (*  	      print_mxp_and_slot (			*)
    (*  		event_operator.substr(hw3, 4, 8),	*)
    (*  		event_operator.substr(hw3, 4, 0));	*)
    (*  	      print_space(1);				*)
    (*  	      print_product (event_operator.substr(hw1, 8, 8));*)
    (*                case right_byte of			*)
    (*                  1: print(' up\');			*)
    (*                  2: print(' down\');			*)
    (*                  3: print(' answered\');			*)
    (*                  4: print(' shut\');			*)
    (*                  7: print(' gone\')			*)
    (*                end " case "				*)
    (*  	    end " 32-1, 2, 3, 4, 7 " ;			*)
    (*   							*)
    (*  	5:    " host reports answered or shut but not in host table "	*)
    (*  	  begin						*)
    (*  	    print_node(hw4);				*)
    (*  	    print_host(hw2);				*)
    (*  	    print(' reports answered or shut but not in host table\')	*)
    (*  	  end " 32-5 " ;				*)
    (*  							*)
    (*  	6:    " host reports answered or shut on wrong base "	*)
    (*  	  begin						*)
    (*  	    print_node(hw4);				*)
    (*  	    print_host(hw2);				*)
    (*  	    print(' reports answered or shut on wrong base\')	*)
    (*  	  end " 32-6 " ;				*)
    (*  							*)
    (*  	8:   " host reported down but not on base "	*)
    (*  	  begin						*)
    (*  	    print_node(hw4);				*)
    (*  	    print_host(hw2);				*)
    (*  	    print(' reported down but not on base\ ')	*)
    (*  	  end " 32-8 " ;				*)
    (*  							*)
    (*  	9:   " down host reporting down "		*)
    (*  	  begin						*)
    (*  	    print_node(hw4);				*)
    (*  	    print_host(hw2);				*)
    (*  	    print(' down host reporting down\')		*)
    (*  	  end " 32-9 "					*)
    (*        end " case "					*)
    (*      							*)
    (*  end " event_32 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(32);	(* event_32  *)
      put(substr_no_shift(hw1, 8));
      ifcall(range_check(FIRST_CODE_32_SUBCODE, LAST_CODE_32_SUBCODE));
        put(substr_no_shift(hw1, 8));
	casecall(FIRST_CODE_32_SUBCODE, LAST_CODE_32_SUBCODE);
	  nextcase(1);	(* coming up *)
	  nextcase(2);	(* down *) 
	  nextcase(3);	(* answered *) 
	  nextcase(4);	(* shut *)
	  nextcase(7);	(* gone *)
	    print_node(hw4);
	    print_host(hw2);
	    put(substr(hw3, 4, 8));
	    put(substr_no_shift(hw3, 4));
	    call_proc(PRINT_MXP_AND_SLOT);
	    print_space(1);
	    print_product(substr(hw1, 8, 8));
	    put(substr_no_shift(hw1, 8));
	    put(constant(1));
	    ifcall(equal);
	      print(' up\');
	    endtrue;

	    put(substr_no_shift(hw1, 8));
	    put(constant(2));
	    elseifcall(equal);
	      print(' down\');
	    endtrue;

	    put(substr_no_shift(hw1, 8));
	    put(constant(3));
	    elseifcall(equal);
	      print(' answered\');
	    endtrue;

	    put(substr_no_shift(hw1, 8));
	    put(constant(4));
	    elseifcall(equal);
	      print(' shut\');
	    endtrue;

	    put(substr_no_shift(hw1, 8));
	    put(constant(7));
	    elseifcall(equal);
	      print(' gone\');
	    endtrue;
	    endfalse;
	    endif;
	  endnextcase (* 32-1, 2, 3, 4, 7 *) ;

	  nextcase(5);    (* host reports answered or shut but not in host table *)
	    print_node(hw4);
	    print_host(hw2);
	    print(' reports answered or shut but not in host table\');
	  endnextcase (* 32-5 *) ;

	  nextcase(6);    (* host reports answered or shut on wrong base *)
	    print_node(hw4);
	    print_host(hw2);
	    print(' reports answered or shut on wrong base\');
	  endnextcase (* 32-6 *) ;

	  nextcase(8);   (* host reported down but not on base *)
	    print_node(hw4);
	    print_host(hw2);
	    print(' reported down but not on base\ ');
	  endnextcase (* 32-8 *) ;

	  nextcase(9);   (* down host reporting down *)
	    print_node(hw4);
	    print_host(hw2);
	    print(' down host reporting down\');
	  endnextcase (* 32-9 *) ;

	endcase;
      endtrue;
  	call_proc(PRINT_UNKNOWN_EVENT);
      endfalse;
      endif;      
    endnextcase (* event_32 *) ;


    (************************************************************)
    (*								*)
    (*  Line ok.						*)
    (*								*)
    (*  procedure event_33;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*        begin						*)
    (*  	link_check(hw2, hw1);				*)
    (*  	print_node(hw2);				*)
    (*  	print(' link ok to \ ');			*)
    (*  	print_node(hw1)					*)
    (*        end						*)
    (*  end " event_33 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(33);	(* event_33  *)
      put(hw2);
      put(hw1);
      link_check;
      print_node(hw2);
      print(' link ok to \ ');
      print_node(hw1);
    endnextcase (* event_33 *) ;


    (************************************************************)
    (*								*)
    (*  Class or group too large in Tymnet II.			*)
    (*								*)
    (*  procedure event_34;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        if hw2 = 0					*)
    (*        then print('group\')				*)
    (*        else print('class\');				*)
    (*        print(' too large \');				*)
    (*        print_decimal_with_d(hw4)				*)
    (*      end " with "					*)
    (*  end " event_34 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(34);	(* event_34  *)
      put(hw2);
      put(constant(0));
      ifcall(equal);
      	print('group\');
      endtrue;
	print('class\');
      endfalse;
      endif;
      print(' too large \');
      print_decimal_with_d(hw4);
    endnextcase (* event_34 *) ;


    (************************************************************)
    (*								*)
    (*  Sup taking over.					*)
    (*								*)    
    (************************************************************)


    nextcase(35);	(* event_35  *)
      print('sup taking over\');
    endnextcase (* event_35 *) ;


    (************************************************************)
    (*								*)
    (*  Line reset.						*)
    (*								*)
    (*  procedure event_36;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_line(hw2, hw1);				*)
    (*        print(' reset \');				*)
    (*        print_pli(hw4)					*)
    (*      end " with "					*)
    (*  end " event_36 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(36);	(* event_36 *)
      put(hw2);
      put(hw1);
      call_proc(PRINT_LINE);
      print(' reset \');
      put(hw4);
      call_proc(PRINT_PLI);
    endnextcase (* event_36 *) ;


    (************************************************************)
    (*								*)
    (*  Supervisor takeover states.				*)
    (*								*)
    (*  procedure event_37;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('have \');					*)
    (*        print_decimal(substr(hw1, 8, 8));			*)
    (*        print_space(1);					*)
    (*        print_decimal(substr(hw1, 8, 0));			*)
    (*        print_space(1);					*)
    (*        print_decimal(substr(hw2, 8, 8));			*)
    (*        print_space(1);					*)
    (*        print_decimal(substr(hw2, 8, 0));			*)
    (*        print_space(1);					*)
    (*        print_decimal(substr(hw3, 11, 5));		*)
    (*        print(' ii \ ');					*)
    (*        print_decimal(substr(hw3, 5, 0)*32+substr(hw4, 5, 11));	*)
    (*        print_space(1);					*)
    (*        print_decimal(substr(hw4, 11, 0))			*)
    (*      end " with "					*)
    (*  end " event_37 " ;					*)
    (*  							*)
    (************************************************************)


    nextcase(37);	(* event_37  *)
      print('have \');
      print_decimal(substr(hw1, 8, 8));
      print_space(1);
      print_decimal(substr_no_shift(hw1, 8));
      print_space(1);
      print_decimal(substr(hw2, 8, 8));
      print_space(1);
      print_decimal(substr_no_shift(hw2, 8));
      print_space(1);
      print_decimal(substr(hw3, 11, 5));
      print(' ii \ ');
      put(substr_no_shift(hw3, 5));
      put(constant(32));
      put(product);
      put(substr(hw4, 5, 11));
      print_decimal(sum);
      print_space(1);
      print_decimal(substr_no_shift(hw4, 11));
    endnextcase (* event_37 *) ;


    (************************************************************)
    (*								*)
    (*  Access error.						*)
    (*								*)
    (*  procedure event_38;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('access error for UUN \');			*)
    (*        print_uun(hw1, hw2);				*)
    (*        if substr(hw1, 1, 15) = 0				*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print(' group \');				*)
    (*  	  print_decimal_with_d(hw3);			*)
    (*  	  print_host(hw4)				*)
    (*  	end						*)
    (*        else						*)
    (*  	begin						*)
    (*  	  print(' class \');				*)
    (*  	  print_decimal_with_d(hw3);			*)
    (*  	  print_space(1);				*)
    (*  	  print_node(hw4)				*)
    (*  	end						*)
    (*      end " with "					*)
    (*  end " event_38 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(38);	(* event_38  *)
      print('access error for UUN \');
      put(hw1);
      put(hw2);
      print_uun;
      put(substr(hw1, 1, 15));
      put(constant(0));
      ifcall(equal);
        print(' group \');
        print_decimal_with_d(hw3);
        print_host(hw4);
      endtrue;
        print(' class \');
      	print_decimal_with_d(hw3);
	print_space(1);
	print_node(hw4);
      endfalse;
      endif;
    endnextcase (* event_38 *) ;


    (************************************************************)
    (*								*)
    (*  Rotate read failure.					*)
    (*								*)
    (*  procedure event_39;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('rotate read failure err = \ ');		*)
    (*        print_hex(fullword(hw1, hw2))			*)
    (*      end " with "					*)
    (*  end " event_39 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(39);	(* event_39  *)
      print('rotate read failure err = \ ');
      put(hw1);
      put(hw2);
      print_hex(fullword);
    endnextcase (* event_39 *) ;


    (************************************************************)
    (*								*)
    (*  Node takeover timeout.					*)
    (*								*)
    (*  procedure event_40;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' takeover failure, state = \');		*)
    (*        print_octal(hw4)					*)
    (*      end " with "					*)
    (*  end " event_40 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(40);	(* event_40  *)
      print_node(hw2);
      print(' takeover failure, state = \');
      print_octal(hw4);
    endnextcase (* event_40 *) ;


    (************************************************************)
    (*								*)
    (*  Node error during takeover.				*)
    (*								*)
    (*  procedure event_41;					*)
    (*								*)
    (*  " code 41 message subcodes "				*)
    (*  							*)
    (*  const							*)
    (*    first_code_41_subcode = 0;				*)
    (*    last_code_41_subcode = 10;				*)
    (*  							*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      if (hw4 < first_code_41_subcode) or (last_code_41_subcode < hw4)*)
    (*      then print_unknown_event				*)
    (*      else						*)
    (*        begin						*)
    (*  	if hw4 < 5					*)
    (*  	then print_line(hw2, hw1)			*)
    (*  	else if hw4 = 10				*)
    (*  	then print_line(hw2, substr(hw1, 10, 6))	*)
    (*  	else print_node(hw2);				*)
    (*  	print(' takeover error, \');			*)
    (*  	case hw4 of					*)
    (*  	   0: print('duplicate neighbor\ ');		*)
    (*  	   1: print('node is not known by neighbor\');	*)
    (*  	   2: print('node is own neighbor\ ');		*)
    (*  	   3: print('perm table mismatch\');		*)
    (*  	   4: print('illegal neighbor number\');	*)
    (*  	   5: print('too many groups\');		*)
    (*  	   6: print('too many lines\ ');		*)
    (*  	   7: print('too many hosts\ ');		*)
    (*  	   8: print('illegal node number\');		*)
    (*  	   9: print('wrong sup number returned\');	*)
    (*  	  10:						*)
    (*  	    begin					*)
    (*  	      print('invalid buffer \');		*)
    (*  	      print_hex(hw3);				*)
    (*  	      print(' on channel \ ');			*)
    (*  	      print_hex(substr(hw1, 6, 0))		*)
    (*  	    end						*)
    (*  	end " case hw4 "				*)
    (*      end " with "					*)
    (*  end " event_41 " ;					*)
    (*								*)
    (************************************************************)				

    nextcase(41);	(* event_41  *)
      put(hw4);
      ifcall(range_check(FIRST_CODE_41_SUBCODE, LAST_CODE_41_SUBCODE));
	put(hw4);
	put(constant(5));
	ifcall(less_than);
	  put(hw2);
	  put(hw1);
	  call_proc(PRINT_LINE);
	endtrue;
	  put(hw4);
	  put(constant(10));
	  ifcall(equal);
	    put(hw2);
	    put(substr(hw1, 10, 6));
	    call_proc(PRINT_LINE);
	  endtrue;
	    print_node(hw2);
	  endfalse;
	  endif;
	endfalse;
	endif;
	print(' takeover error, \');
	put(hw4);
	casecall(FIRST_CODE_41_SUBCODE, LAST_CODE_41_SUBCODE);
	  nextcase(0);
	    print('duplicate neighbor\ ');
	  endnextcase;

	  nextcase(1);
	    print('node is not known by neighbor\');
	  endnextcase;

	  nextcase(2);
	    print('node is own neighbor\ ');
	  endnextcase;

	  nextcase(3);
	    print('perm table mismatch\');
	  endnextcase;

	  nextcase(4);
	    print('illegal neighbor number\');
	  endnextcase;

	  nextcase(5);
	    print('too many groups\');
	  endnextcase;

	  nextcase(6);
	    print('too many lines\ ');
	  endnextcase;

	  nextcase(7);
	    print('too many hosts\ ');
	  endnextcase;

	  nextcase(8);
	    print('illegal node number\');
	  endnextcase;

	  nextcase(9);
	    print('wrong sup number returned\');
	  endnextcase;

	  nextcase(10);
	    print('invalid buffer \');
	    print_hex(hw3);
	    print(' on channel \ ');
	    print_hex(substr_no_shift(hw1, 6));
	  endnextcase;
	endcase;
      endtrue;
	call_proc(PRINT_UNKNOWN_EVENT);
      endfalse;
      endif;
    endnextcase (* event_41 *) ;			


    (************************************************************)		
    (*								*)
    (*  Neighbor mismatch on circuit zap.			*)
    (*								*)
    (*  procedure event_42;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        link_check(hw2, hw4);				*)
    (*        print_node(hw2);					*)
    (*        print(' neighbor mismatch on circuit zap to \');	*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_42 " ;					*)
    (*								*)
    (************************************************************)


    nextcase(42);	(* event_42  *)
      put(hw2);
      put(hw4);
      link_check;
      print_node(hw2);
      print(' neighbor mismatch on circuit zap to \');
      print_node(hw4);
    endnextcase (* event_42 *) ;


    (************************************************************)
    (*								*)
    (*  Link shut.						*)
    (*  							*)
    (*  procedure event_43;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        link_check(hw3, hw4);				*)
    (*        print('link shut, \');				*)
    (*        print_node(hw3);					*)
    (*        print(' --\');					*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_43 " ;					*)
    (*								*)
    (************************************************************)		


    nextcase(43);	(* event_43  *)
      put(hw3);
      put(hw4);
      link_check;
      print('link shut, \');
      print_node(hw3);
      print(' --\');
      print_node(hw4);
    endnextcase (* event_43 *) ;


    (************************************************************)
    (*								*)
    (*  Crash report.						*)
    (*								*)
    (*  procedure event_44;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' crash, version \ ');			*)
    (*        print_octal(hw1);					*)
    (*        print(': count=\ ');				*)
    (*        print_decimal(hw4);				*)
    (*        print(', from \');				*)
    (*        print_octal(hw3)					*)
    (*      end " with "					*)
    (*  end " event_44 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(44);	(* event_44  *)
      print_node(hw2);
      print(' crash, version \ ');
      print_octal(hw1);
      print(': count=\ ');
      print_decimal(hw4);
      print(', from \');
      print_octal(hw3);
    endnextcase (* event_44 *) ;


    (************************************************************)
    (*								*)
    (*  Supervisor cannot read disc. 			        *)
    (*								*)
    (*  procedure event_45;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('cannot read class & group defs, disk error \');	*)
    (*        print_hex(hw2)					*)
    (*      end " with "					*)
    (*  end " event_45 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(45);	(* event_45  *)
      print('cannot read class & group defs, disk error \');
      print_hex(hw2);
    endnextcase (* event_45 *) ;


    (************************************************************)
    (*								*)
    (*  Supervisor fight.					*)
    (*								*)
    (*  procedure event_46;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('fighting supervisors \');			*)
    (*        print_octal(substr(hw4, 6, 0));			*)
    (*        print(' at \ ');					*)
    (*        print_node(hw2)					*)
    (*      end " with "					*)
    (*  end " event_46 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(46);	(* event_46  *)
      print('fighting supervisors \');
      print_octal(substr_no_shift(hw4, 6));
      print(' at \ ');
      print_node(hw2);
    endnextcase (* event_46 *) ;


    (************************************************************)
    (*								*)
    (*  Line unshut.						*)
    (*								*)
    (*  procedure event_47;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        link_check(hw3, hw4);				*)
    (*        print('link unshut, \');				*)
    (*        print_node(hw3);					*)
    (*        print(' --\');					*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_47 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(47);	(* event_47  *)
      put(hw3);
      put(hw4);
      link_check;
      print('link unshut, \');
      print_node(hw3);
      print(' --\');
      print_node(hw4);
    endnextcase (* event_47 *) ;


    (************************************************************)
    (*								*)
    (*  Line overloaded.					*)
    (*								*)
    (*  procedure event_48;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*        begin						*)
    (*  	link_check(hw2, hw1);				*)
    (*  	print_node(hw2);				*)
    (*  	print(' unoverloaded to \');			*)
    (*  	print_node(hw1)					*)
    (*        end						*)
    (*  end " event_48 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(48);	(* event_48  *)
	put(hw2);
	put(hw1);
	link_check;
	print_node(hw2);
	print(' unoverloaded to \');
	print_node(hw1);
    endnextcase (* event_48 *) ;


    (************************************************************)
    (*								*)
    (*  MUD error in Tymnet II.					*)
    (*								*)
    (*  procedure event_49;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      if hw4 < 3						*)
    (*      then						*)
    (*        begin						*)
    (*  	print('MUD error UUN = \ ');			*)
    (*  	print_uun(hw1, hw2);				*)
    (*  	print(' vir block \');				*)
    (*  	print_hex(hw3);					*)
    (*  	if hw4 = 0 then print(' neg group as home\ ')	*)
    (*  	else if hw4 = 1 then print(' class num too high\')	*)
    (*  	else print(' group num too high\')		*)
    (*        end						*)
    (*      else if hw4 < 5					*)
    (*      then						*)
    (*        begin						*)
    (*  	print('MUD error vir block = \ ');		*)
    (*  	print_hex(hw3);					*)
    (*  	print(' position \ ');				*)
    (*  	print_hex(fullword(hw1, hw2));			*)
    (*  	if hw4 = 3 then print(' displacement error - past end\ ')*)
    (*  	else print(' zero displacement\ ')		*)
    (*        end						*)
    (*      else print_unknown_event				*)
    (*  end " event_49 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(49);	(* event_49  *)
      put(hw4);
      put(constant(3));
      ifcall(less_than);
	print('MUD error UUN = \ ');
 	put(hw1);
	put(hw2);
	print_uun;
	print(' vir block \');
	print_hex(hw3);
	put(hw4);
	put(constant(0));
	ifcall(equal);
	  print(' neg group as home\ ');
	endtrue;
	  put(hw4);
	  put(constant(1));
	  ifcall(equal);
	    print(' class num too high\');
	  endtrue;
	    print(' group num too high\');
	  endfalse;
	  endif;
	endfalse;
	endif;
      endtrue;
	put(hw4);
	put(constant(5));
	ifcall(less_than);
	  print('MUD error vir block = \ ');
	  print_hex(hw3);
	  print(' position \ ');
	  put(hw1);
	  put(hw2);
	  print_hex(fullword);
	  put(hw4);
	  put(constant(3));
	  ifcall(equal);
	    print(' displacement error - past end\ ');
	  endtrue;
	    print(' zero displacement\ ');
	  endfalse;
	  endif;
	endtrue;
	  call_proc(PRINT_UNKNOWN_EVENT);
	endfalse;
	endif;
      endfalse;
      endif;
    endnextcase (* event_49 *) ;


    (************************************************************)
    (*								*)
    (*  A node is backpreasuring a supervisor message.		*)
    (*								*)
    (*  procedure event_50;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        link_check(hw2, hw4);				*)
    (*        print_line(hw2, hw1);				*)
    (*        print(' sup buffer zap..congestion toward \');	*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_50 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(50);	(* event_50  *)
      put(hw2);
      put(hw4);
      link_check;
      put(hw2);
      put(hw1);
      call_proc(PRINT_LINE);
      print(' sup buffer zap..congestion toward \');
      print_node(hw4);
    endnextcase (* event_50 *) ;


    (************************************************************)
    (*								*)
    (*  Login rate.						*)
    (*								*)
    (*  procedure event_51;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('login rate \');				*)
    (*        print_decimal(hw2);				*)
    (*        if (hw3 > 0) or (hw4 > 0)				*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print(', avg \ ');				*)
    (*  	  print_decimal_scaled(hw4, 2);			*)
    (*  	  print(' sec, peak \');			*)
    (*  	  print_decimal_scaled(hw3, 2);			*)
    (*  	  print(' sec\ ')				*)
    (*  	end;						*)
    (*        if hw1 > 0					*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print_space(1);				*)
    (*  	  print_decimal(hw1);				*)
    (*  	  print(' circuit timeouts\')			*)
    (*  	end						*)
    (*      end " with "					*)
    (*  end " event_51 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(51);	(* event_51  *)
      print('login rate \');
      print_decimal(hw2);
      put(hw3);
      put(constant(0));
      put(greater_than);
      put(hw4);
      put(constant(0));
      put(greater_than);
      ifcall(orfunc);
	print(', avg \ ');
	print_decimal_scaled(hw4, 2);
	print(' sec, peak \');
	print_decimal_scaled(hw3, 2);
	print(' sec\ ');
      endtrue;
      endif;
      put(hw1);
      put(constant(0));
      ifcall(greater_than);
	print_space(1);
	print_decimal(hw1);
	print(' circuit timeouts\');
      endtrue;
      endif;
    endnextcase (* event_51 *) ;


    (************************************************************)
    (*								*)
    (*  Tymnet II circuit too long.				*)
    (*								*)
    (*  procedure event_52;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print('TYMNET II circuit too long to\');		*)
    (*        print_host(hw4)					*)
    (*      end " with "					*)
    (*  end " event_52 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(52);	(* event_52  *)
      print_node(hw2);
      print('TYMNET II circuit too long to\');
      print_host(hw4);
    endnextcase (* event_52 *) ;


    (************************************************************)
    (*								*)
    (*  Start of takeover.					*)
    (*								*)
    (*  procedure event_53;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' start of takeover to \ ');		*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_53 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(53);	(* event_53  *)
      print_node(hw2);
      print(' start of takeover to \ ');
      print_node(hw4);
    endnextcase (* event_53 *) ;


    (************************************************************)
    (*								*)
    (*  End of take over.					*)
    (*								*)
    (*  procedure event_54;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' end of takeover\ ');			*)
    (*        if hw1 > 0					*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print(', cost \');				*)
    (*  	  print_decimal(hw1)				*)
    (*  	end;						*)
    (*        if hw4 > 0					*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print(', upstream \');			*)
    (*  	  print_node(hw4)				*)
    (*  	end;						*)
    (*      end " with "					*)
    (*  end " event_54 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(54);	(* event_54  *)
      print_node(hw2);
      print(' end of takeover\ ');
      put(hw1);
      put(constant(0));
      ifcall(greater_than);
	print(', cost \');
	print_decimal(hw1);
      endtrue;
      endif;
      put(hw4);
      put(constant(0));
      ifcall(greater_than);
	print(', upstream \');
	print_node(hw4);
      endtrue;
      endif;
    endnextcase (* event_54 *) ;


    (************************************************************)
    (*								*)
    (*  Login list too long.					*)
    (*								*)
    (*  procedure event_55;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('TYMNET II msg on port \ ');		*)
    (*        print_hex(fullword(hw1, hw2));			*)
    (*        print(' length = \ ');				*)
    (*        print_decimal(hw4)				*)
    (*      end " with "					*)
    (*  end " event_55 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(55);	(* event_55  *)
      print('TYMNET II msg on port \ ');
      put(hw1);
      put(hw2);
      print_hex(fullword);
      print(' length = \ ');
      print_decimal(hw4);
    endnextcase (* event_55 *) ;


    (************************************************************)
    (*								*)
    (*  Cannot take over node.					*)
    (*								*)
    (*  procedure event_56;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' cannot takeover, upstream \');		*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_56 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(56);	(* event_56  *)
      print_node(hw2);
      print(' cannot takeover, upstream \');
      print_node(hw4);
    endnextcase (* event_56 *) ;


    (************************************************************)
    (*								*)
    (*  Zapper received on command circuit.			*)
    (*								*)
    (*  procedure event_57;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw4);					*)
    (*        print(' zapper received on command circuit\')	*)
    (*      end " with "					*)
    (*  end " event_57 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(57);	(* event_57  *)
      print_node(hw4);
      print(' zapper received on command circuit\');
    endnextcase (* event_57 *) ;


    (************************************************************)
    (*								*)
    (*  Sync port request response.				*)
    (*								*)
    (*  procedure event_58;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        if substr(hw3, 1, 14) = 0 then print('sync\ ')	*)
    (*        else print('sio\');				*)
    (*        print(' port, \');				*)
    (*        print_node(hw2);					*)
    (*        if (substr(hw3, 14, 0) = 0) and (substr(hw3, 1, 15) = 0)	*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print(' port \ ');				*)
    (*  	  print_decimal_with_d(hw4);			*)
    (*  	  print(' is unused\ ')				*)
    (*  	end						*)
    (*        else						*)
    (*  	begin						*)
    (*  	  print(' to neighbor \');			*)
    (*  	  print_node(substr(hw3, 14, 0));		*)
    (*  	  if substr(hw3, 1, 15) = 0 then print(' is down\ ')	*)
    (*  	  else print(' is up\ ');			*)
    (*  	  print(' on port \');				*)
    (*  	  print_decimal_with_d(hw4)			*)
    (*  	end						*)
    (*      end " with "					*)
    (*  end " event_58 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(58);	(* event_58  *)
      put(substr(hw3, 1, 14));
      put(constant(0));
      ifcall(equal);
        print('sync\ ');
      endtrue;
        print('sio\');
      endfalse;
      endif;
      print(' port, \');
      print_node(hw2);
      put(substr_no_shift(hw3, 14));
      put(constant(0));
      put(equal);
      put(substr(hw3, 1, 15));
      put(constant(0));
      put(equal);
      ifcall(andfunc);
	print(' port \ ');
	print_decimal_with_d(hw4);
	print(' is unused\ ');
      endtrue;
	print(' to neighbor \');
	print_node(substr_no_shift(hw3, 14));
     	put(substr(hw3, 1, 15));
	put(constant(0));
	ifcall(equal); 
	  print(' is down\ ');
	endtrue;
 	  print(' is up\ ');
	endfalse;
	endif;
	print(' on port \');
	print_decimal_with_d(hw4);
      endfalse;
      endif;
    endnextcase (* event_58 *) ;


    (************************************************************)
    (*								*)
    (*  procedure event_59;					*)
    (*								*)
    (*  var							*)
    (*    cost: integer;					*)
    (*								*)
    (*  begin							*)
    (*    link_check(hw2, hw3);					*)
    (*    print_node(hw2);					*)
    (*    print( ' link \ ');					*)
    (*    if hw4 = 65535 then print( 'frozen\ ')   		*)
    (*    else							*)
    (*      begin  						*)
    (*        cost := substr(hw4, 5, 0);			*)
    (*        print_speed(cost)					*)
    (*	  end;							*)
    (*    print(' to \ ');					*)
    (*    if hw3 = 65535   					*)
    (*    then print(' an unknown neighbor\ ')			*)
    (*    else							*)
    (*      begin						*)
    (* 	    print( ' neighbor \ ');				*)
    (* 	    print_node(hw3)					*)
    (*	  end							*)
    (*  end " event_59 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(59);	(* event_59  *)
      put(hw2);
      put(hw3);
      link_check;
      print_node(hw2);
      print(' link \ ');
      put(hw4);
      put(constant(65535));
      ifcall(equal);
  	print( 'frozen\ ');
      endtrue;
	put(substr_no_shift(hw4, 5));
	call_proc(PRINT_SPEED);
      endfalse;
      endif;
      print(' to \ ');
      put(hw3);
      put(constant(65535));
      ifcall(equal);
        print(' an unknown neighbor\ ');
      endtrue;
	print( ' neighbor \ ');
	print_node(hw3);
      endfalse;
      endif;
    endnextcase;


    (************************************************************)
    (*								*)
    (*  Zapper received on unused Tymnet I command circuit.	*)
    (*								*)
    (*  procedure event_60;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('zapper received on unused TYMNET I command port \ ');*)
    (*        print_hex(hw4)					*)
    (*      end " with "					*)
    (*  end " event_60 " ;					*)
    (*								*)    
    (************************************************************)



    nextcase(60);	(* event_60  *)
      print('zapper received on unused TYMNET I command port \ ');
      print_hex(hw4);
    endnextcase (* event_60 *) ;


    (************************************************************)
    (*								*)
    (*  Invalid sup message on a Tymnet I port.			*)
    (*								*)
    (*  procedure event_61;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw2);					*)
    (*        print(' invalid sup message on TYMNET I port \ ');*)
    (*        print_hex(hw1);					*)
    (*        print_space(1);					*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_61 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(61);	(* event_61  *)
      print_node(hw2);
      print(' invalid sup message on TYMNET I port \ ');
      print_hex(hw1);
      print_space(1);
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_61 *) ;


    (************************************************************)
    (*								*)
    (*  print unknown event.					*)
    (*								*)    
    (************************************************************)


    nextcase(62);	(* event_62  *)
      call_proc(PRINT_UNKNOWN_EVENT);
    endnextcase (* event_62 *) ;


    (************************************************************)
    (*								*)
    (*  Unable to read supervisor clock.			*)
    (*								*)
    (*  procedure event_63;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      if hw2 > 1						*)
    (*      then						*)
    (*        begin						*)
    (*  	print('unable to read supervisor clock \ ');	*)
    (*  	print_hex(fullword(hw1, hw2));			*)
    (*  	print_char(',');				*)
    (*  	print_hex(fullword(hw3, hw4))			*)
    (*        end						*)
    (*      else						*)
    (*        case hw2 of					*)
    (*  	0: print('superclock not present\ ');		*)
    (*  	1:						*)
    (*  	  begin						*)
    (*  	    print('superclock time out of range \');	*)
    (*  	    print_time(fullword(hw3, hw4))		*)
    (*  	  end " 63-1 "					*)
    (*        end " case "					*)
    (*  end " event_63 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(63);	(* event_63  *)
      put(hw2);
      put(constant(1));
      ifcall(greater_than);
	print('unable to read supervisor clock \ ');
	put(hw1);
	put(hw2);
	print_hex(fullword);
	print(',\');
	put(hw3);
	put(hw4);
	print_hex(fullword);
      endtrue;
	put(hw2);
        casecall(0, 1);
	  nextcase(0); 
	    print('superclock not present\ ');
	  endnextcase;

	  nextcase(1);
	    print('superclock time out of range \');
	    put(hw3);
	    put(hw4);
	    print_time(fullword);
	  endnextcase;
      	endcase;
      endfalse;
      endif;
    endnextcase (* event_63 *) ;


    (************************************************************)
    (*								*)
    (*  Supervisor buffer zap.					*)
    (*								*)
    (*  procedure event_64;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw1);					*)
    (*        print(' sup buffer zap, upstream \ ');		*)
    (*        print_node(hw2);					*)
    (*        print(' buffer \ ');				*)
    (*        print_hex(hw4);					*)
    (*        print(' size \ ');				*)
    (*        print_hex(hw3)					*)
    (*      end " with "					*)
    (*  end " event_64 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(64);	(* event_64  *)
      print_node(hw1);
      print(' sup buffer zap, upstream \ ');
      print_node(hw2);
      print(' buffer \ ');
      print_hex(hw4);
      print(' size \ ');
      print_hex(hw3);
    endnextcase (* event_64 *) ;


    (************************************************************)
    (*								*)
    (*  New link claimed out of bounds.				*)
    (*								*)
    (*  procedure event_65;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        link_check(hw4, hw3);				*)
    (*        print('new link from \ ');			*)
    (*        print_node(hw4);					*)
    (*        print(' claimed out of channels by \ ');		*)
    (*        print_node(hw3)					*)
    (*      end " with "					*)
    (*  end " event_65 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(65);	(* event_65  *)
      put(hw4);
      put(hw3);
      link_check;
      print('new link from \ ');
      print_node(hw4);
      print(' claimed out of channels by \ ');
      print_node(hw3);
    endnextcase (* event_65 *) ;


    (************************************************************)
    (*								*)
    (*  Black ball received on command channel.			*)
    (*								*)
    (*  procedure event_66;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw4);					*)
    (*        print('black ball received on command circuit, port \');	*)
    (*        print_decimal(hw1);				*)
    (*        print_newline;					*)
    (*        print('     lost \ ');				*)
    (*        print_decimal(hw2);				*)
    (*        print(' bytes\ ')					*)
    (*      end " with "					*)
    (*  end " event_66 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(66);	(* event_66  *)
      print_node(hw4);
      print('black ball received on command circuit, port \');
      print_decimal(hw1);
      print_newline;
      print('     lost \ ');
      print_decimal(hw2);
      print(' bytes\ ');
    endnextcase (* event_66 *) ;


    (************************************************************)
    (*								*)
    (*  Black ball received on unassigned tymnet i command port.*)
    (*								*)
    (*  procedure event_67;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('black ball received on unassigned tymnet I command port \ ');	*)
    (*        print_decimal(hw1);				*)
    (*        print_newline;					*)
    (*        print('     lost \ ');				*)
    (*        print_decimal(hw2);				*)
    (*        print(' bytes\ ')					*)
    (*      end " with "					*)
    (*  end " event_67 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(67);	(* event_67  *)
      print('black ball received on unassigned tymnet I command port \ ');
      print_decimal(hw1);
      print_newline;
      print('     lost \ ');
      print_decimal(hw2);
      print(' bytes\ ');
    endnextcase (* event_67 *) ;


    (************************************************************)
    (*								*)
    (*  Gobbler received on command circuit.			*)
    (*								*)
    (*  procedure event_68;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw4);					*)
    (*        print(' gobbler received on command circuit, port \');	*)
    (*        print_decimal(hw1)				*)
    (*      end " with "					*)
    (*  end " event_68 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(68);	(* event_68  *)
      print_node(hw4);
      print(' gobbler received on command circuit, port \');
      print_decimal(hw1);
    endnextcase (* event_68 *) ;


    (************************************************************)
    (*								*)
    (*  Gobbler received on unassigned Tymnet I command channel.*)
    (*								*)
    (*  procedure event_69;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('gobbler received on unassigned tymnet I command port \');	*)
    (*        print_decimal(hw1)				*)
    (*      end " with "					*)
    (*  end " event_69 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(69);	(* event_69  *)
      print('gobbler received on unassigned tymnet I command port \');
      print_decimal(hw1);
    endnextcase (* event_69 *) ;


    (************************************************************)
    (*								*)
    (*  Invalid char pair received on command channel.		*)
    (*								*)
    (*  procedure event_70;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw4);					*)
    (*        print(' invalid char pair received on command circuit port \ ');	*)
    (*        print_decimal(hw1);;				*)
    (*        print_newline;					*)
    (*        print('     char pair \');			*)
    (*        print_hex(hw2)					*)
    (*      end " with "					*)
    (*  end " event_70 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(70);	(* event_70  *)
      print_node(hw4);
      print(' invalid char pair received on command circuit port \ ');
      print_decimal(hw1);;
      print_newline;
      print('     char pair \');
      print_hex(hw2);
    endnextcase (* event_70 *) ;


    (************************************************************)
    (*								*)
    (*  procedure event_71;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('invalid char pair received on unassigned tymnet I command port \');	*)
    (*        print_decimal(hw1);				*)
    (*        print_newline;					*)
    (*        print('     char pair \');			*)
    (*        print_hex(hw2)					*)
    (*      end " with "					*)
    (*  end " event_71 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(71);	(* event_71  *)
      print('invalid char pair received on unassigned tymnet I command port \');
      print_decimal(hw1);
      print_newline;
      print('     char pair \');
      print_hex(hw2);
    endnextcase (* event_71 *) ;


    (************************************************************)
    (*								*)
    (*  Port hang by node.					*)
    (*								*)
    (*  procedure event_72;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw1);					*)
    (*        if hw4 = 2					*)
    (*        then print(' permanent\ ')			*)
    (*        else if hw4 <> 1					*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print(' type \ ');				*)
    (*  	  print_decimal(hw4)				*)
    (*  	end;						*)
    (*        print(' port hang, port \');			*)
    (*        print_decimal(hw2)				*)
    (*      end " with "					*)
    (*  end " event_72 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(72);	(* event_72  *)
      print_node(hw1);
      put(hw4);
      put(constant(2));
      ifcall(equal);
        print(' permanent\ ');
      endtrue;
      	put(hw4);
	put(constant(1));
    	put(equal);
    	ifcall(notfunc);
	  print(' type \ ');
   	  print_decimal(hw4);
	endtrue;
	endif;
      endfalse;
      endif;
      print(' port hang, port \');
      print_decimal(hw2);
    endnextcase (* event_72 *) ;


    (************************************************************)
    (*								*)
    (*  Port hang query response.				*)
    (*								*)
    (*  procedure event_73;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print_node(hw1);					*)
    (*        print(' port hang status, \');			*)
    (*        if hw4 > 1					*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print_hex(hw2);				*)
    (*  	  print_char(',');				*)
    (*  	  print_hex(fullword(hw3, hw4))			*)
    (*  	end						*)
    (*        else						*)
    (*  	case hw4 of					*)
    (*  	  0:						*)
    (*  	    begin					*)
    (*  	      print('port \');				*)
    (*  	      print_decimal(hw2)			*)
    (*  	    end " 73-0 " ;				*)
    (*  	  1: print('complete\ ')			*)
    (*  	end " case "					*)
    (*      end " with "					*)
    (*  end " event_73 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(73);	(* event_73  *)
      print_node(hw1);
      print(' port hang status, \');
      put(hw4);
      put(constant(1));
      ifcall(greater_than);
	print_hex(hw2);
	print(',\');
	put(hw3);
	put(hw4);
	print_hex(fullword);
      endtrue;
	put(hw4);
	casecall(0, 1);
	  nextcase(0);
	    print('port \');
	    print_decimal(hw2);
	  endnextcase (* 73-0 *) ;

	  nextcase(1); 
	    print('complete\ ');
	  endnextcase (* 73-1 *) ;
	endcase;
      endfalse;
      endif;
    endnextcase (* event_73 *) ;


    (************************************************************)
    (*								*)
    (*  Log circuit length message.				*)
    (*								*)
    (*  procedure event_74;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('Circuits avg length \ ');			*)
    (*        print_decimal_scaled(hw3, 1);			*)
    (*        print(', cost \');				*)
    (*        print_decimal_scaled(hw4, 1);			*)
    (*        print('; max length \');				*)
    (*        print_decimal(hw1);				*)
    (*        print(', cost \');				*)
    (*        print_decimal(hw2)				*)
    (*      end " with "					*)
    (*  end " event_74 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(74);	(* event_74  *)
      print('Circuits avg length \ ');
      print_decimal_scaled(hw3, 1);
      print(', cost \');
      print_decimal_scaled(hw4, 1);
      print('; max length \');
      print_decimal(hw1);
      print(', cost \');
      print_decimal(hw2);
    endnextcase (* event_74 *) ;


    (************************************************************)
    (*								*)
    (*  Acess error.						*)
    (*								*)
    (*  procedure event_75;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('access error for UUN \');			*)
    (*        print_uun(hw1, hw2);				*)
    (*        if substr(hw1, 1, 15) = 0				*)
    (*        then print(' group \')				*)
    (*        else print(' class \');				*)
    (*        print_decimal_with_d(hw3);			*)
    (*        print_host(hw4)					*)
    (*      end " with "					*)
    (*  end " event_75 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(75);	(* event_75  *)
      print('access error for UUN \');
      put(hw1);
      put(hw2);
      print_uun;
      put(substr(hw1, 1, 15));
      put(constant(0));
      ifcall(equal);
    	print(' group \');
      endtrue;       
	print(' class \');
      endfalse;
      endif;
      print_decimal_with_d(hw3);
      print_host(hw4);
    endnextcase (* event_75 *) ;


    (************************************************************)
    (*								*)
    (*  Sup time changed by operator.				*)    
    (*								*)
    (*  procedure event_76;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('time changed by operator, old time was \');*)
    (*        print_time(fullword(hw1, hw2))			*)
    (*      end " with "					*)
    (*  end " event_76 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(76);	(* event_76  *)
      print('time changed by operator, old time was \');
      put(hw1);
      put(hw2);
      print_time(fullword);
    endnextcase (* event_76 *) ;


    (************************************************************)
    (*								*)
    (*  Invalid port 1 message.					*)
    (*								*)
    (*  procedure event_77;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('invalid port 1 message, length \');	*)
    (*        print_decimal(hw1);				*)
    (*        print(' contents \ ');				*)
    (*        print_hex(hw2);					*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_77 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(77);	(* event_77  *)
      print('invalid port 1 message, length \');
      print_decimal(hw1);
      print(' contents \ ');
      print_hex(hw2);
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_77 *) ;


    (************************************************************)
    (*								*)
    (*  Disk not ready.						*)
    (*								*)    
    (************************************************************)


    nextcase(78);	(* event_78  *)
      print('disk not ready\ ');
    endnextcase (* event_78 *) ;


    (************************************************************)
    (*								*)
    (*  Disk went ready.					*)
    (*								*)    
    (************************************************************)


    nextcase(79);	(* event_79  *)
      print('disk went ready\');
    endnextcase;


    (************************************************************)
    (*								*)
    (*  Login error.						*)
    (*								*)
    (*  procedure event_80;					*)
    (*								*)
    (*  const							*)
    (*    first_code_80_subcode = 1;				*)
    (*    last_code_80_subcode  = 14;				*)
    (*  							*)
    (*  var							*)
    (*    subcode: integer;					*)
    (*    tid: integer;						*)
    (*  							*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('login error: \');				*)
    (*        subcode := substr(hw1, 8, 8);			*)
    (*        tid := substr(hw1, 8, 0);				*)
    (*        if (subcode < first_code_80_subcode) or (last_code_80_subcode < subcode)	*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print('type \');				*)
    (*  	  print_decimal(subcode)			*)
    (*  	end						*)
    (*        else						*)
    (*  	case subcode of						*)
    (*  	   1: print('invalid tid: \');				*)
    (*  	   2: print('invalid requesting host number\ ');	*)
    (*  	   3: print('requesting host not on node\');		*)
    (*  	   4: print('requesting host down\ ');			*)
    (*  	   5: print('null character string\');			*)
    (*  	   6: print('data during circuit building\ ');		*)
    (*  	   7: print('data during MUD read\ ');			*)
    (*  	   8: print('unterminated login string\');		*)
    (*  	   9: print('user hung due to bad password\');		*)
    (*  	  10: print('user hung due to bad username\');		*)
    (*  	  11: print('aux circuit request with bad username\');	*)
    (*  	  12: print('username too long\');			*)
    (*  	  13: print('user previously hung for bad password was for UUN \ ');	*)
    (*  	  14: print('duplicate login request,\ ')	*)
    (*  	end " case " ;				*)
    (*        if subcode = 13 then print_uun(hw3, hw4)		*)
    (*        else						*)
    (*  	begin						*)
    (*  	  if subcode <> 1 then print(', tid: \');	*)
    (*  	  print_decimal(tid);				*)
    (*  	  print_newline;				*)
    (*  	  print_space(5);				*)
    (*  	  print('requesting host\ ');			*)
    (*  	  print_decimal(hw2);				*)
    (*  	  print(' node \ ');				*)
    (*  	  print_node(hw3);				*)
    (*  	  print(' buffer \ ');				*)
    (*  	  print_decimal(hw4)				*)
    (*  	end						*)
    (*      end " with "					*)
    (*  end " event_80 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(80);	(* event_80  *)
      print('login error: \');
      put(substr(hw1, 8, 8));
      ifcall(range_check(FIRST_CODE_80_SUBCODE, LAST_CODE_80_SUBCODE));
	put(substr(hw1, 8, 8));
	casecall(FIRST_CODE_80_SUBCODE, LAST_CODE_80_SUBCODE);
	  nextcase(1); 
	    print('invalid tid: \');
	  endnextcase;

	  nextcase(2); 
	    print('invalid requesting host number\ ');
	  endnextcase;

	  nextcase(3); 
	    print('requesting host not on node\');
	  endnextcase;

	  nextcase(4); 
	    print('requesting host down\ ');
	  endnextcase;

	  nextcase(5); 
	    print('null character string\');
	  endnextcase;

	  nextcase(6); 
	    print('data during circuit building\ ');
	  endnextcase;

	  nextcase(7); 
	    print('data during MUD read\ ');
	  endnextcase;

	  nextcase(8); 
	    print('unterminated login string\');
	  endnextcase;

	  nextcase(9); 
	    print('user hung due to bad password\'); 
	  endnextcase;

	  nextcase(10); 
	    print('user hung due to bad username\');
	  endnextcase;

	  nextcase(11); 
	    print('aux circuit request with bad username\');
	  endnextcase;

	  nextcase(12); 
	    print('username too long\');
	  endnextcase;

	  nextcase(13); 
	    print('user previously hung for bad password was for UUN \ ');
	  endnextcase;

	  nextcase(14); 
	    print('duplicate login request,\ ');
	  endnextcase;
	endcase;
      endtrue;
	print('type \');
	print_decimal(substr(hw1, 8, 8));
      endfalse;
      endif;
      put(substr(hw1, 8, 8));
      put(constant(13));
      ifcall(equal); 
	put(hw3);
	put(hw4);
	print_uun;
      endtrue;
	put(substr(hw1, 8, 8));
	put(constant(1));
	put(equal);
	ifcall(notfunc); 
	  print(', tid: \');
	endtrue;
	endif;
	print_decimal(substr_no_shift(hw1, 8));
	print_newline;
	print_space(5);
	print('requesting host \ ');
	print_decimal(hw2);
	print(' node \ ');
	print_node(hw3);
	print(' buffer \ ');
	print_decimal(hw4);
      endfalse;
      endif;
    endnextcase (* event_80 *) ;


    (************************************************************)
    (*								*)	
    (*  Data on unassigned port.				*)
    (*								*)	
    (*  procedure event_81;					*)
    (*								*)	
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('data on unassigned port \ ');		*)
    (*        print_decimal(hw1);				*)
    (*        print(' count \');				*)
    (*        print_decimal(hw2);				*)
    (*        print(' data \ ');				*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_81 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(81);	(* event_81  *)
      print('data on unassigned port \ ');
      print_decimal(hw1);
      print(' count \');
      print_decimal(hw2);
      print(' data \ ');
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_81 *) ;


    (************************************************************)
    (*								*)
    (*  Lost sup base.						*)
    (*								*)    
    (************************************************************)


    nextcase(82);	(* event_82  *)
      print('lost supervisors base\');
    endnextcase (* event_82 *) ;


    (************************************************************)
    (*								*)
    (*  Excessive login acknowledgement delay.			*)
    (*								*)
    (*  procedure event_83;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('excessive delay in circuit building of \');*)
    (*        print_decimal_scaled(hw2, 2);			*)
    (*        print(' secs from node \ ');			*)
    (*        print_node(hw3);					*)
    (*      end " with "					*)
    (*  end " event_83 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(83);	(* event_83  *)
      print('excessive delay in circuit building of \');
      print_decimal_scaled(hw2, 2);
      print(' secs from node \ ');
      print_node(hw3);
    endnextcase (* event_83 *) ;


    (************************************************************)
    (*								*)
    (*  Kernael and SIO status from split supervisor.		*)
    (*								*)
    (*  procedure event_84;					*)
    (*								*)
    (*  const							*)
    (*    first_code_84_subcode = 0;				*)
    (*    last_code_84_subcode  = 3;				*)
    (*  							*)
    (*  var							*)
    (*    subcode: integer;					*)
    (*  							*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('kernel crash count \');			*)
    (*        print_decimal(substr(hw1, 12, 4));		*)
    (*        print(' last crash due to \');			*)
    (*        subcode := substr(hw1, 4, 0);			*)
    (*        if subcode > last_code_84_subcode			*)
    (*        then						*)
    (*  	begin						*)
    (*  	  print('reason: \ ');				*)
    (*  	  print_decimal(subcode)			*)
    (*  	end						*)
    (*        else						*)
    (*  	case subcode of					*)
    (*  	   0: print('manual restart\ ');		*)
    (*  	   1: print('power up\ ');			*)
    (*  	   2: print('sio link out\ ');			*)
    (*  	   3: print('ring pair mismatch\ ')		*)
    (*  	end " case " ;					*)
    (*        print_newline;					*)
    (*        print('    sio status \');			*)
    (*        print_hex(substr(hw2, 8, 0));			*)
    (*        print(' after \');				*)
    (*        print_decimal(substr(hw2, 8, 8));			*)
    (*        print(' interrupts\')				*)
    (*      end " with "					*)
    (*  end " event_84 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(84);	(* event_84  *)
      print('kernel crash count \');
      print_decimal(substr(hw1, 12, 4));
      print(' last crash due to \');
      put(substr_no_shift(hw1, 4));
      put(constant(LAST_CODE_84_SUBCODE));
      ifcall(greater_than);
	print('reason: \ ');
	print_decimal(substr_no_shift(hw1, 4));
      endtrue;
	put(substr_no_shift(hw1, 4));
	casecall(FIRST_CODE_84_SUBCODE, LAST_CODE_84_SUBCODE);
	  nextcase(0); 
	    print('manual restart\ ');
	  endnextcase;

	  nextcase(1); 
	    print('power up\ ');
	  endnextcase;

	  nextcase(2); 
	    print('sio link out\ ');
	  endnextcase;

	  nextcase(3); 
	    print('ring pair mismatch\ ');
	  endnextcase;
	endcase;
      endfalse;
      endif;
      print_newline;
      print('    sio staus \ ');
      print_hex(substr_no_shift(hw2, 8));
      print(' after \');
      print_decimal(substr(hw2, 8, 8));
      print(' interrupts\');
    endnextcase (* event_84 *) ;


    (************************************************************)
    (*								*)
    (*  Operator message generated with ULOGA or ULOGH command  *)
    (*  in Probe.						*)
    (*								*)
    (*  procedure event_85;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('user message  hex- \');			*)
    (*        print_hex(hw1);					*)
    (*        print_space(1);					*)
    (*        print_hex(hw2);					*)
    (*        print_space(1);					*)
    (*        print_hex(hw3);					*)
    (*        print_space(1);					*)
    (*        print_hex(hw4);					*)
    (*        print(' ascii- \ ');				*)
    (*        print_ulog_text(hw1);				*)
    (*        print_ulog_text(hw2);				*)
    (*        print_ulog_text(hw3);				*)
    (*        print_ulog_text(hw4)				*)
    (*      end " with "					*)
    (*  end " event_85 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(85);	(* event_85  *)
      print('user message  hex- \');
      print_hex(hw1);
      print_space(1);
      print_hex(hw2);
      print_space(1);
      print_hex(hw3);
      print_space(1);
      print_hex(hw4);
      print(' ascii- \ ');
      print_ulog_text(hw1);
      print_ulog_text(hw2);
      print_ulog_text(hw3);
      print_ulog_text(hw4);
    endnextcase  (* event_85 *) ;


    (************************************************************)
    (*								*)
    (*  Too many invalid user names.				*)
    (*								*)    
    (*  procedure event_86;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('too many invalid usernames, node \');	*)
    (*        print_node(hw1);					*)
    (*        print_space(1);					*)
    (*        print_decimal(hw2);				*)
    (*        print(' out of \ ');				*)
    (*        print_decimal(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_86 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(86);	(* event_86  *)
      print('too many invalid usernames, node \');
      print_node(hw1);
      print_space(1);
      print_decimal(hw2);
      print(' out of \ ');
      put(hw3);
      put(hw4);
      print_decimal(fullword);
    endnextcase (* event_86 *) ;


    (************************************************************)
    (*								*)
    (*  Too many invalid passwords.				*)
    (*								*)
    (*  procedure event_87;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('too many invalid passwords, node \');	*)
    (*        print_node(hw1);					*)
    (*        print_space(1);					*)
    (*        print_decimal(hw2);				*)
    (*        print(' out of \ ');				*)
    (*        print_decimal(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_87 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(87);	(* event_87  *)
      print('too many invalid passwords, node \');
      print_node(hw1);
      print_space(1);
      print_decimal(hw2);
      print(' out of \ ');
      put(hw3);
      put(hw4);
      print_decimal(fullword);
    endnextcase (* event_87 *) ;


    (************************************************************)
    (*								*)
    (*  Too many login session failures.			*)
    (*								*)
    (*  procedure event_88;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('too many login session failures, node \ ');*)
    (*        print_node(hw1);					*)
    (*        print_space(1);					*)
    (*        print_decimal(hw2);				*)
    (*        print(' out of \ ');				*)
    (*        print_decimal(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_88 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(88);	(* event_88  *)
      print('too many login session failures, node \ ');
      print_node(hw1);
      print_space(1);
      print_decimal(hw2);
      print(' out of \ ');
      put(hw3);
      put(hw4);
      print_decimal(fullword);
    endnextcase (* event_88 *) ;


    (************************************************************)
    (*								*)
    (*  Node lost due to invalid trace response size.		*)
    (*								*)
    (*  procedure event_89;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('node \');					*)
    (*        print_node(hw1);					*)
    (*        print(' lost due to invalid trace response size of \ ')	*)
    (*        print_decimal(hw2);				*)
    (*        print(' data \ ');				*)
    (*        print_hex(fullword(hw3, hw4))			*)
    (*      end " with "					*)
    (*  end " event_89 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(89);	(* event_89  *)
      print('node \');
      print_node(hw1);
      print(' lost due to invalid trace response size of \ ');
      print_decimal(hw2);
      print(' data \ ');
      put(hw3);
      put(hw4);
      print_hex(fullword);
    endnextcase (* event_89 *) ;


    (************************************************************)
    (*								*)
    (*  Excessive communication delay to node.			*)
    (*								*)
    (*  procedure event_90;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('excessive delays to date \');		*)
    (*        print_decimal(hw2);				*)
    (*        print(', recently from node \');			*)
    (*        print_node(hw1);					*)
    (*        print_newline;					*)
    (*        print('   round trip delay \ ');			*)
    (*        print_decimal_scaled(hw3, 2);			*)
    (*        print(' sec, adjusted delay of \ ');		*)
    (*        print_decimal_scaled(hw4, 2);			*)
    (*        print(' sec\ ')					*)
    (*      end " with "					*)
    (*  end " event_90 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(90);	(* event_90  *)
      print('excessive delays to date \');
      print_decimal(hw2);
      print(', recently from node \');
      print_node(hw1);
      print_newline;
      print('   round trip delay \ ');
      print_decimal_scaled(hw3, 2);
      print(' sec, adjusted delay of \ ');
      print_decimal_scaled(hw4, 2);
      print(' sec\ ');
    endnextcase (* event_90 *) ;


    (************************************************************)
    (*								*)
    (*  Unexplained execution delay.				*)
    (*								*)
    (*  procedure event_91;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('unexplained execution delay of \');	*)
    (*        print_decimal(fullword(hw3, hw4));		*)
    (*        print(' sec\ ')					*)
    (*      end " with "					*)
    (*  end " event_91 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(91);	(* event_91  *)
      print('unexplained execution delay of \');
      put(hw3);
      put(hw4);
      print_decimal(fullword);
      print(' sec\ ');
    endnextcase (* event_91 *) ;


    (************************************************************)
    (*								*)
    (*  Supervisor activity rates.				*)
    (*								*)
    (*  procedure event_92;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('sup activity per second - \ ');		*)
    (*        print_decimal_scaled(hw1, 1);			*)
    (*        print(' exec loops\');				*)
    (*        print_newline;					*)
    (*        print_space(3);					*)
    (*        print_decimal_scaled(hw2, 1);			*)
    (*        print(' input found \');				*)
    (*        print_decimal_scaled(hw3, 1);			*)
    (*        print(' output inhibited, last by node \ ');	*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_92 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(92);	(* event_92  *)
      print('sup activity per second - \ ');
      print_decimal_scaled(hw1, 1);
      print(' exec loops\');
      print_newline;
      print_space(3);
      print_decimal_scaled(hw2, 1);
      print(' input found \');
      print_decimal_scaled(hw3, 1);
      print(' output inhibited, last by node \ ');
      print_node(hw4);
    endnextcase (* event_92 *) ;


    (************************************************************)
    (*								*)
    (*  Supervisor internal performance times.			*)
    (*								*)
    (*  procedure event_93;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('internal sup activity in seconds - \');	*)
    (*        print_decimal_scaled(hw1, 3);			*)
    (*        print(' per exec loop\ ');			*)
    (*        print_newline;					*)
    (*        print_space(3);					*)
    (*        print_decimal_scaled(hw2, 3);			*)
    (*        print(' per input call \ ');			*)
    (*        print_decimal_scaled(hw3, 3);			*)
    (*        print(' per message to sups node \ ');		*)
    (*        print_decimal_scaled(hw4, 3);			*)
    (*        print(' peak\')					*)
    (*      end " with "					*)
    (*  end " event_93 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(93);	(* event_93  *)
      print('internal sup activity in seconds - \');
      print_decimal_scaled(hw1, 3);
      print(' per exec loop\ ');
      print_newline;
      print_space(3);
      print_decimal_scaled(hw2, 3);
      print(' per input call \ ');
      print_decimal_scaled(hw3, 3);
      print(' per message to sups node \ ');
      print_decimal_scaled(hw4, 3);
      print(' peak\');
    endnextcase (* event_93 *) ;


    (************************************************************)
    (*								*)
    (*  External communication times.				*)
    (*								*)
    (*  procedure event_94;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('external communication times in seconds - \ ');	*)
    (*        print_decimal_scaled(hw1, 2);			*)
    (*        print(' avg\ ');					*)
    (*        print_newline;					*)
    (*        print_space(3);					*)
    (*        print_decimal_scaled(hw2, 2);			*)
    (*        print(' avg adjusted \ ');			*)
    (*        print_decimal_scaled(hw3, 2);			*)
    (*        print(' peak adjusted time, for node \ ');	*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_94 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(94);	(* event_94  *)
      print('external communication times in seconds - \ ');
      print_decimal_scaled(hw1, 2);
      print(' avg\ ');
      print_newline;
      print_space(3);
      print_decimal_scaled(hw2, 2);
      print(' avg adjusted \ ');
      print_decimal_scaled(hw3, 2);
      print(' peak adjusted time, for node \ ');
      print_node(hw4);
    endnextcase (* event_94 *) ;


    (************************************************************)
    (*								*)
    (*  Excessive communication delay to own base node.		*)
    (*								*)
    (*  procedure event_95;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('delay to sups node to date \');		*)
    (*        print_decimal(fullword(hw1, hw2));		*)
    (*        print(' , recently \ ');				*)
    (*        print_decimal_scaled(fullword(hw3, hw4), 2)	*)
    (*      end " with "					*)
    (*  end " event_95 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(95);	(* event_95  *)
      print('delay to sups node to date \');
      put(hw1);
      put(hw2);
      print_decimal(fullword);
      print(' , recently \ ');
      put(hw3);
      put(hw4);
      print_decimal_scaled(fullword, 2);
    endnextcase (* event_95 *) ;


    (************************************************************)
    (*								*)
    (*  Control port backpreasure exceeding 1 minute.		*)
    (*								*)
    (*  procedure event_96;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('excessive flow control on command port \');*)
    (*        print_decimal(hw2);				*)
    (*        print(' for node \ ');				*)
    (*        print_node(hw4)					*)
    (*      end " with "					*)
    (*  end " event_96 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(96);	(* event_96  *)
      print('excessive flow control on command port \');
      print_decimal(hw2);
      print(' for node \ ');
      print_node(hw4);
    endnextcase (* event_96 *) ;


    (************************************************************)
    (*								*)
    (*  report disk errors.					*)
    (*								*)
    (*  procedure event_97;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*        print('disk error \');				*)
    (*        print_hex(hw1);					*)
    (*        print(' for logical unit \ ');			*)
    (*        print_hex(hw2);					*)
    (*        print(' sector \ ');				*)
    (*        print_hex(hw4);					*)
    (*        print(' status \ ');				*)
    (*        print_hex(hw3)					*)
    (*      end " with "					*)
    (*  end " event_97 " ;					*)
    (*								*)    
    (************************************************************)


    nextcase(97);	(* event_97  *)
      print('disk error \');
      print_hex(hw1);
      print(' for logical unit \ ');
      print_hex(hw2);
      print(' sector \ ');
      print_hex(hw4);
      print(' status \ ');
      print_hex(hw3);
    endnextcase (* event_97 *) ;


    (********************************************************************)
    (*									*)
    (*  print reasons for a restart and initialization time. 		*)
    (*									*)
    (*  procedure event_98;						*)
    (*									*)
    (*  const								*)
    (*    first_event_98_isis_code = 0;					*)
    (*    last_event_98_isis_code = 9;					*)
    (*    first_event_98_sup_code = 1;					*)
    (*    last_event_98_sup_code = 6;					*)
    (*  								*)
    (*  var								*)
    (*    isis_code: integer;						*)
    (*    sup_code: integer;						*)
    (*  								*)
    (*  begin								*)
    (*    with current_message do					*)
    (*      begin							*)
    (*        if (hw1<first_event_98_isis_code) or (hw1>last_event_98_isis_code)*)
    (*          or (hw2<first_event_98_sup_code) or (hw2>last_event_98_sup_code)*)
    (*        then print_unknown_event					*)
    (*        else							*)
    (*  	begin							*)
    (*  	  print('last sup restart due to \ ');			*)
    (*  	  isis_code := hw1;					*)
    (*  	  case isis_code of					*)
    (*  	    0:  print('manual restart\ ');			*)
    (*  	    1:  print('power failure\');			*)
    (*  	    2:  print('parity error\ ');			*)
    (*  	    3:  print('dispatcher crash\ ');			*)
    (*  	    4:  print('illegal instruction\');			*)
    (*  	    5:  print('illegal svc\');				*)
    (*  	    6:  print('system parity error\');			*)
    (*  	    7:  print('protection violation\ ');		*)
    (*  	    8:  print('nonrecoverable device check\');		*)
    (*  	    9:  print('***unknown***\')				*)
    (*  	  end " case " ;					*)
    (*  	  print(' at \ ');					*)
    (*  	  print_time(fullword(hw3, hw4));			*)
    (*  	  if (isis_code = 4) or (isis_code = 9)			*)
    (*  	  then							*)
    (*  	    begin						*)
    (*  	      print_newline;					*)
    (*  	      sup_code := hw2;					*)
    (*  	      case sup_code of					*)
    (*  		1:  print('sup out of bufferlets\');		*)
    (*  		2:  print('sup out of node descriptor space\ ');*)
    (*  		3:  print('change in disk status while sleeping\ '); *)
    (*  		4:  print('sup running on incorrect node\');	*)
    (*  		5:  print('sob is too small or damaged\');	*)
    (*  		6:  print('disks came online while executing\')	*)
    (*  	      end " case " 					*)
    (*  	    end							*)
    (*  	end							*)
    (*      end " with "						*)
    (*  end " event_98 " ;						*)
    (*									*)    
    (********************************************************************)


    nextcase(98);	(* event_98  *)
      put(hw1);
      put(range_check(FIRST_EVENT_98_ISIS_CODE, LAST_EVENT_98_ISIS_CODE));
      put(hw2);
      put(range_check(FIRST_EVENT_98_SUP_CODE, LAST_EVENT_98_SUP_CODE));
      ifcall(andfunc);
	print('last sup restart due to \ ');
	put(hw1);
	casecall(FIRST_EVENT_98_ISIS_CODE, LAST_EVENT_98_ISIS_CODE);
	  nextcase(0);  
	    print('manual restart\ ');
	  endnextcase;

	  nextcase(1);  
	    print('power failure\');
	  endnextcase;

	  nextcase(2);  
	    print('parity error\ ');
	  endnextcase;

	  nextcase(3);  
	    print('dispatcher crash\ ');
	  endnextcase;

	  nextcase(4);  
	    print('illegal instruction\');
	  endnextcase;

	  nextcase(5);  
	    print('illegal svc\');
	  endnextcase;

	  nextcase(6);  
	    print('system parity error\');
	  endnextcase;

	  nextcase(7);  
	    print('protection violation\ ');
	  endnextcase;

	  nextcase(8);  
	    print('nonrecoverable device check\');
	  endnextcase;

	  nextcase(9);  
	    print('***unknown***\');
	  endnextcase;
	endcase;
        
	print(' at \ ');
	put(hw3);
	put(hw4);
	print_time(fullword);
	put(hw1);
	put(constant(4));
	put(equal);
	put(hw1);
	put(constant(9));
	put(equal);
	ifcall(orfunc);
	  print_newline;
	  put(hw2);
	  casecall(FIRST_EVENT_98_SUP_CODE, LAST_EVENT_98_SUP_CODE);
	    nextcase(1);  
	      print('sup out of bufferlets\');
	    endnextcase;

	    nextcase(2);  
	      print('sup out of node descriptor space\ ');
	    endnextcase;

	    nextcase(3);  
	      print('change in disk status while sleeping\ ');
	    endnextcase;

	    nextcase(4);  
	      print('sup running on incorrect node\');
	    endnextcase;

	    nextcase(5);  
	      print('sob is too small or damaged\');
	    endnextcase;

	    nextcase(6);  
	      print('disks came online while executing\');
	    endnextcase;
	  endcase;
	endtrue;
	endif;
      endtrue;
	call_proc(PRINT_UNKNOWN_EVENT);
      endfalse;
      endif;
    endnextcase (* event_98 *) ;


    (********************************************************************)
    (*									*)
    (*  Sup halted reasons.						*)	
    (*									*)
    (*  procedure event_99;						*)
    (*									*)
    (*  const								*)
    (*    first_event_99_isis_code = 0;					*)
    (*    last_event_99_isis_code = 10;					*)
    (*    first_event_99_sup_code = 1;					*)
    (*    last_event_99_sup_code = 6;					*)
    (*  								*)
    (*  begin								*)
    (*    with current_message do					*)
    (*      begin							*)
    (*        if (hw1<first_event_99_isis_code) or 			*)
    (*		(hw1>last_event_99_isis_code)				*)
    (*        then print_unknown_event					*)
    (*        else							*)
    (*  	begin							*)
    (*  	  print('sup halted due to\');				*)
    (*		  print_space(1);					*)
    (*  	  case hw1 of						*)
    (*  	    0:  print('manual restart\ ');			*)
    (*  	    1:  print('power failure\');			*)
    (*  	    2:  print('parity error\ ');			*)
    (*  	    3:  print('dispatcher crash\ ');			*)
    (*  	    4:  print('illegal instruction\');			*)
    (*  	    5:  print('illegal svc\');				*)
    (*  	    6:  print('system parity error\');			*)
    (*  	    7:  print('protection violation\ ');		*)
    (*  	    8:  print('nonrecoverable device check\');		*)
    (*		    9:  print('status change\');			*)
    (*  	   10:  print('***unknown***\')				*)
    (*  	  end " case " ;					*)
    (*  	  print(' at \ ');					*)
    (*  	  print_hex(fullword(hw3, hw4));			*)
    (*  	  if hw1 = 4						*)
    (*  	  then							*)
    (*  	    begin						*)
    (*  	      print_newline;					*)
    (*		      if (hw2<first_event_99_sup_code) or		*)
    (*			(hw2>last_event_99_sup_code)			*)
    (*		      then						*)
    (*			begin						*)
    (*			  print('crash type\');				*)
    (*			  print_hex(hw2)				*)
    (*			end						*)
    (*		      else						*)
    (*  	      case hw2 of					*)
    (*  		1:  print('sup out of bufferlets\');		*)
    (*  		2:  print('sup out of node descriptor space\ ');*)
    (*  		3:  print('change in disk status while sleeping\ '); *)
    (*  		4:  print('sup running on incorrect node\');	*)
    (*  		5:  print('sob full on initialization\');	*)
    (*  		6:  print('disks came online while executing\')	*)
    (*  	      end " case " 					*)
    (*  	    end							*)
    (*  	end							*)
    (*      end " with "						*)
    (*  end " event_99 " ;						*)
    (*									*)
    (********************************************************************)

    nextcase(99);	(* event_99 *)
      put(hw1);
      ifcall(range_check(FIRST_EVENT_99_ISIS_CODE, LAST_EVENT_99_ISIS_CODE));
	print('sup halted due to\');
  	print_space(1);
	put(hw1);
	casecall(FIRST_EVENT_99_ISIS_CODE, LAST_EVENT_99_ISIS_CODE);
	  nextcase(0);  
	    print('manual restart\ ');
	  endnextcase;

	  nextcase(1);  
	    print('power failure\');
	  endnextcase;

	  nextcase(2);  
	    print('parity error\ ');
	  endnextcase;

	  nextcase(3);  
	    print('dispatcher crash\ ');
	  endnextcase;

	  nextcase(4);  
	    print('illegal instruction\');
	  endnextcase;

	  nextcase(5);  
	    print('illegal svc\');
	  endnextcase;

	  nextcase(6);  
	    print('system parity error\');
	  endnextcase;

	  nextcase(7);  
	    print('protection violation\ ');
	  endnextcase;

	  nextcase(8);  
	    print('nonrecoverable device check\');
	  endnextcase;

	  nextcase(9);
	    print('status change\');
	  endnextcase;

	  nextcase(10);  
	    print('***unknown***\');
	  endnextcase;
	endcase;
        
	print(' at \ ');
	put(hw3);
	put(hw4);
	print_hex(fullword);

	put(hw1);
	put(constant(4));
	ifcall(equal);
	  print_newline;
	  put(hw2);
	  ifcall(range_check(FIRST_EVENT_99_SUP_CODE, LAST_EVENT_99_SUP_CODE));
	    put(hw2);
	    casecall(FIRST_EVENT_99_SUP_CODE, LAST_EVENT_99_SUP_CODE);
	      nextcase(1);  
		print('sup out of bufferlets\');
	      endnextcase;

	      nextcase(2);  
		print('sup out of node descriptor space\ ');
	      endnextcase;

	      nextcase(3);  
		print('change in disk status while sleeping\ ');
	      endnextcase;

	      nextcase(4);  
		print('sup running on incorrect node\');
	      endnextcase;

	      nextcase(5);  
		print('sob full on initialization\ ');
	      endnextcase;

	      nextcase(6);  
		print('disks came online while executing\');
	      endnextcase;
	    endcase;
	  endtrue;
	    print('crash type\ ');
	    print_space(1);
	    print_hex(hw2);
	  endfalse;
	  endif;
	endtrue;
	endif;
      endtrue;
	call_proc(PRINT_UNKNOWN_EVENT);
      endfalse;
      endif;
    endnextcase (* event_99 *) ;


    (********************************************************************)
    (*									*)
    (*  Critical disk files unavailable.				*)
    (*									*)
    (*  procedure event_100;						*)
    (*									*)
    (*  begin								*)
    (*	  with current_message do					*)
    (*	    begin							*)
    (*	      print('critical disk files unavailable - LU mask =\');	*)
    (*	      print_space(1);						*)
    (*	      print_hex(fullword(hw1, hw2));				*)
    (*	    end								*)
    (*  end " event_100 " ;						*)
    (*									*)
    (********************************************************************)

    nextcase(100);	(* event_100 *) 
      print('critical disk files unavailable - LU mask =\');	
      print_space(1);						
      put(hw1);
      put(hw2);
      print_hex(fullword);
    endnextcase (* event_100 *) ;


    (************************************************************)
    (*								*)
    (*  Critical disk files now available.			*)
    (*								*)
    (*  procedure event_101;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*      begin						*)
    (*	      print('critical disk files now available\');	*)
    (*	      print_space(1);					*)
    (*	      if (hw1 = 0) and (hw2 = 0)			*)
    (*	      then print('no data lost\')			*)
    (*	      else						*)
    (*		begin						*)
    (*		  print('data blocks lost -\');			*)
    (*		  print_space(1);				*)
    (*		  print('accounting\');				*)
    (*		  print_space(1);				*)
    (*		  print_decimal(fullword(hw1, hw2);		*)
    (*		  print(',\');					*)
    (*		  print_space(1);				*)
    (*		  print('errlog\');				*)
    (*		  print_space(1);				*)
    (*		  print_decimal(fullword(hw3, hw4))		*)
    (*		end						*)
    (*      end " with "					*)
    (*  end " event_101 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(101);	(* event_101 *)
      print('critical disk files now available\');	
      print_space(1);					
      put(hw1);
      put(constant(0));
      put(equal);
      put(hw2);
      put(constant(0));
      put(equal);   
      ifcall(andfunc);
        print('no data lost\ ');
      endtrue;
        print('data blocks lost -\ ');			
        print_space(1);				
        print('accounting\ ');				
        print_space(1);				
      	put(hw1);
	put(hw2);
        print_decimal(fullword);		
        print(',\');					
        print_space(1);				
        print('errlog\ ');				
        print_space(1);				
	put(hw3);
	put(hw4);
        print_decimal(fullword);
      endfalse;
      endif;
    endnextcase (* event_101 *) ;


    (************************************************************)
    (*								*)
    (*  Subnet table read error.				*)
    (*								*)
    (*  procedure event_102;					*)
    (*								*)
    (*  begin							*)
    (*    print_unknown_event					*)
    (*  end " event_102 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(102);	(* event_102 *)
      call_proc(PRINT_UNKNOWN_EVENT);
    endnextcase (* event_102 *) ;


    (************************************************************)
    (*								*)
    (*  Target profile read error.				*)
    (*								*)
    (*  procedure event_103;					*)
    (*								*)
    (*  begin							*)
    (*    print_unknown_event					*)
    (*  end " event_103 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(103);	(* event_103 *)
      call_proc(PRINT_UNKNOWN_EVENT);
    endnextcase (* event_103 *) ;


    (************************************************************)
    (*								*)
    (*  MUD block is overflowed.				*)
    (*								*)
    (*  procedure event_104;					*)
    (*								*)
    (*  begin							*)
    (*    print_unknown_event					*)
    (*  end " event_104 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(104);	(* event_104 *)
      call_proc(PRINT_UNKNOWN_EVENT);
    endnextcase (* event_104 *) ;


    (************************************************************)
    (*								*)
    (*  Takeover count.						*)
    (*								*)
    (*  procedure event_105;					*)
    (*								*)
    (*  begin							*)
    (*    print('node takeover occurred on\');			*)
    (*	  print_space(1);					*)
    (*	  print_decimal(hw1);					*)
    (*	  print_space(1);					*)
    (*	  print('nodes,\');					*)
    (*	  print_space(1);					*)
    (*	  print('avg:\');					*)
    (*	  print_space(1);					*)
    (*	  print_decimal_scaled(hw2, 3);				*)
    (*    print_space(1);					*)
    (*    print('sec.\');					*)
    (*	  print_space(2);					*)
    (*	  print('peak:\');					*)
    (*	  print_space(1);					*)
    (*	  print_decimal_scaled(hw4, 3);				*)
    (*	  print_space(1);					*)
    (*	  print('sec.\');					*)
    (*  end " event_105 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(105);	(* event_105 *)
      print('node takeover occurred on\');			
      print_space(1);					
      print_decimal(hw1);					
      print_space(1);					
      print('nodes,\ ');					
      print_space(1);					
      print('avg:\ ');					
      print_space(1);					
      print_decimal_scaled(hw2, 3);				
      print_space(1);					
      print('sec.\ ');					
      print_space(2);					
      print('peak:\');					
      print_space(1);					
      print_decimal_scaled(hw4, 3);				
      print_space(1);					
      print('sec.\ ');					
    endnextcase (* event_105 *) ;


    (************************************************************)
    (*								*)
    (*	Statistics of DIRECT ROUTINE calls.			*)
    (*								*)
    (*  procedure event_106;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*	    begin						*)
    (*	      print('direct routine called\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal(hw2);				*)
    (*	      print_space(1);					*)
    (*	      print('times, avg:\');				*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(hw3, 3);			*)
    (*	      print_space(1);					*)
    (*	      print('sec.\');					*)
    (*	      print_space(2);					*)
    (*	      print('peak:\');					*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(hw4, 3);			*)
    (*	      print_space(1);					*)
    (*	      print('sec.\');					*)
    (*	    end " with "					*)
    (*  end " event_106 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(106);	(* event_106 *)
      print('direct routine called\');			
      print_space(1);					
      print_decimal(hw2);				
      print_space(1);					
      print('times, avg:\');				
      print_space(1);					
      print_decimal_scaled(hw3, 3);			
      print_space(1);					
      print('sec.\ ');					
      print_space(2);					
      print('peak:\');					
      print_space(1);					
      print_decimal_scaled(hw4, 3);			
      print_space(1);					
      print('sec.\ ');					
    endnextcase (* event_106 *) ;


    (************************************************************)
    (*								*)
    (*	Average queue size.					*)
    (*								*)
    (*  procedure event_107;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*	    begin						*)
    (*	      print('average queue size.\');			*)
    (*	      print_space(1);					*)
    (*	      print('input:\');					*)
    (*	      print_space(1);					*)
    (*	      print_decimal(fullword(hw1, hw2));		*)
    (*	      print_space(2);					*)
    (*	      print('output:\');				*)
    (*	      print_space(1);					*)
    (*	      print_decimal(fullword(hw3, hw4));		*)
    (*	    end " with "					*)
    (*  end " event_107 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(107);	(* event_107 *)
      print('average queue size.\');			
      print_space(1);					
      print('input:\ ');					
      print_space(1);					
      put(hw1);
      put(hw2);
      print_decimal(fullword);		
      print_space(2);					
      print('output:\');				
      print_space(1);					
      put(hw3);
      put(hw4);
      print_decimal(fullword);		
    endnextcase (* event_107 *) ;


    (************************************************************)
    (*								*)
    (*	Input msg count.					*)
    (*								*)
    (*  procedure event_108;					*)
    (*								*)
    (*  begin							*)
    (*    with current_message do				*)
    (*	    begin						*)
    (*	      print('input msg count.\');			*)
    (*	      print_space(1);					*)
    (*	      print('msg#:\');					*)
    (*	      print_space(1);					*)
    (*	      print_hex(hw1);					*)
    (*	      print_space(1);					*)
    (*        print('count:\');					*)
    (*	      print_space(1);					*)
    (*	      print_decimal(hw2);				*)
    (*	      print_space(1);					*)
    (*	      print('msg#:\');					*)
    (*	      print_space(1);					*)
    (*	      print_hex(hw3);					*)
    (*	      print_space(1);					*)
    (*	      print('count:\');					*)
    (*	      print_space(1);					*)
    (*	      print_decimal(hw4);				*)
    (*	    end " with "					*)
    (*  end " event_108 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(108);	(* event_108 *)
      print('input msg count.\ ');			
      print_space(1);					
      print('msg#:\');					
      print_space(1);					
      print_hex(hw1);					
      print_space(1);					
      print('count:\ ');					
      print_space(1);					
      print_decimal(hw2);				
      print_space(1);					
      print('msg#:\');					
      print_space(1);					
      print_hex(hw3);					
      print_space(1);					
      print('count:\ ');					
      print_space(1);					
      print_decimal(hw4);				
    endnextcase (* event_108 *) ;


    (************************************************************)
    (*								*)
    (*	Bad node number read from shut line table.		*)
    (*								*)
    (*  procedure event_109;					*)
    (*								*)
    (*  begin							*)
    (*    print('illegal node pair in shut lines table\')	*)
    (*  end " event_109 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(109);	(* event_109 *)
      print('illegal node pair in shut lines table\');
    endnextcase (* event_109 *) ;


    (************************************************************)
    (*								*)
    (*	Bad MUD entry found during UN2 update. 			*)
    (*								*)
    (*  procedure event_110;					*)
    (*								*)
    (*  begin							*)
    (*	  print_unknown_event					*)
    (*  end " event_110 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(110);	(* event_110 *)
      call_proc(PRINT_UNKNOWN_EVENT);
    endnextcase (* event_110 *) ;


    (************************************************************)
    (*								*)
    (*	Normal logins.						*)
    (*								*)
    (*  procedure event_111;					*)
    (*								*)
    (*  begin							*)
    (*	  with current_message do				*)
    (*	    begin						*)
    (*	      print('normal login req\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal(hw1);				*)
    (*	      print_space(1);					*)
    (*	      print('times,\');					*)
    (*	      print_space(1);					*)
    (*	      print('login avg:\');				*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(hw2, 3);			*)
    (*	      print_space(1);					*)
    (*        print('sec, login peak:\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(hw3, 3);			*)
    (*	      print_space(1);					*)
    (*	      print('sec.\');					*)
    (*        print_newline;					*)
    (*        print_space(3);					*)
    (*	      print('path avg:\');				*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(substr(hw4, 7, 9), 3);	*)
    (*	      print_space(1);					*)
    (*	      print('sec, path peak:\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(substr_no_shift(hw4, 9), 3);	*)
    (*	      print_space(1);					*)
    (*	      print('sec.\');					*)
    (*      end " with "					*)
    (*  end " event_111 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(111);	(* event_111 *)
      print('normal login req\ ');			
      print_space(1);					
      print_decimal(hw1);				
      print_space(1);					
      print('times,\ ');					
      print_space(1);					
      print('login avg:\ ');				
      print_space(1);					
      print_decimal_scaled(hw2, 3);			
      print_space(1);					
      print('sec, login peak:\ ');			
      print_space(1);					
      print_decimal_scaled(hw3, 3);			
      print_space(1);					
      print('sec.\ ');					
      print_newline;					
      print_space(3);					
      print('path avg:\');				
      print_space(1);					
      print_decimal_scaled(substr(hw4, 7, 9), 3);	
      print_space(1);					
      print('sec, path peak:\');			
      print_space(1);					
      print_decimal_scaled(substr_no_shift(hw4, 9), 3);	
      print_space(1);					
      print('sec.\ ');					
    endnextcase (* event_111 *) ;


    (************************************************************)
    (*								*)
    (*	AUX circuit building statistics.			*)
    (*								*)
    (*  procedure event_112;					*)
    (*								*)
    (*  begin							*)
    (*	  with current_message do				*)
    (*	    begin						*)
    (*	      print('aux circuit req\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal(hw1);				*)
    (*	      print_space(1);					*)
    (*	      print('times,\');					*)
    (*	      print_space(1);					*)
    (*	      print('login avg:\');				*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(hw2, 3);			*)
    (*	      print_space(1);					*)
    (*        print('sec, login peak:\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(hw3, 3);			*)
    (*	      print_space(1);					*)
    (*	      print('sec.\');					*)
    (*        print_newline;					*)
    (*        print_space(3);					*)
    (*	      print('path avg:\');				*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(substr(hw4, 7, 9), 3);	*)
    (*	      print_space(1);					*)
    (*	      print('sec, path peak:\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(substr_no_shift(hw4, 9), 3);	*)
    (*      end " with "					*)
    (*  end " event_112 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(112);	(* event_112 *)
      print('aux circuit req\');			
      print_space(1);					
      print_decimal(hw1);				
      print_space(1);					
      print('times,\ ');					
      print_space(1);					
      print('login avg:\ ');				
      print_space(1);					
      print_decimal_scaled(hw2, 3);			
      print_space(1);					
      print('sec, login peak:\ ');			
      print_space(1);					
      print_decimal_scaled(hw3, 3);			
      print_space(1);					
      print('sec.\ ');					
      print_newline;					
      print_space(3);					
      print('path avg:\');				
      print_space(1);					
      print_decimal_scaled(substr(hw4, 7, 9), 3);	
      print_space(1);					
      print('sec, path peak:\');			
      print_space(1);					
      print_decimal_scaled(substr_no_shift(hw4, 9), 3);	
      print_space(1);					
      print('sec.\ ');					
    endnextcase  (* event_112 *) ;


    (************************************************************)
    (*								*)
    (*  Circuit rebuild statistics.				*)
    (*								*)
    (*  procedure event_113;					*)
    (*								*)
    (*  begin							*)
    (*	  with current_message do				*)
    (*	    begin						*)
    (*	      print('circuit rebuild req\ ');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal(hw1);				*)
    (*	      print_space(1);					*)
    (*	      print('times,\');					*)
    (*	      print_space(1);					*)
    (*	      print('login avg:\');				*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(hw2, 3);			*)
    (*	      print_space(1);					*)
    (*        print('sec, login peak:\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(hw3, 3);			*)
    (*	      print_space(1);					*)
    (*	      print('sec.\');					*)
    (*        print_newline;					*)
    (*        print_space(3);					*)
    (*	      print('path avg:\');				*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(substr(hw4, 7, 9), 3);	*)
    (*	      print_space(1);					*)
    (*	      print('sec, path peak:\');			*)
    (*	      print_space(1);					*)
    (*	      print_decimal_scaled(substr_no_shift(hw4, 9), 3);	*)
    (*      end " with "					*)
    (*  end " event_113 " ;					*)
    (*								*)    
    (************************************************************)

    nextcase(113);	(* event_113 *)
      print('circuit rebuilds req\ ');			
      print_space(1);					
      print_decimal(hw1);				
      print_space(1);					
      print('times,\ ');					
      print_space(1);					
      print('login avg:\ ');				
      print_space(1);					
      print_decimal_scaled(hw2, 3);			
      print_space(1);					
      print('sec, login peak:\ ');			
      print_space(1);					
      print_decimal_scaled(hw3, 3);			
      print_space(1);					
      print('sec.\ ');					
      print_newline;					
      print_space(3);					
      print('path avg:\');				
      print_space(1);					
      print_decimal_scaled(substr(hw4, 7, 9), 3);	
      print_space(1);					
      print('sec, path peak:\');			
      print_space(1);					
      print_decimal_scaled(substr_no_shift(hw4, 9), 3);	
      print_space(1);					
      print('sec.\ ');					
    endnextcase (* event_113 *) ;



  endcase;
  endtrue;

    call_proc(PRINT_UNKNOWN_EVENT);
  endfalse;
  endif;
  
  exit
end (* initialization *) ; 



(***************************  data_generate  ****************************)
(*									*)
(*			    fill_erlog_buffer				*)
(*									*)
(*	This entry is called by "ERLOG" command to generate a erlog	*)
(*	message text buffer, during the generating process, error	*)
(*	message will be output to user's terminal if there is any	*)
(*	interpretor error such as stack overflow or underflow, or	*)
(*	misuse the erlog message interpretor.				*)
(*									*)
(************************************************************************)


procedure entry fill_erlog_buffer;

begin
  initialization
end (* fill_erlog_buffer *) ;



(***************************  data_generate  ****************************)
(************************************************************************)


begin
  initialization
end (* data_generate *) ;
!
(************************************************************************)
(*									*)
(*	RESTR1.TDR							*)
(*									*)
(*			      restructure				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	31Oct83 Original -- ahm						*)
(*									*)
(************************************************************************)

type
  restructure =
    class(
      format		: internal_to_string;
      io_report		: disk_error;
      dsksys		: disk_system;
      user_terminal	: circuit_handler;
      extend_operator	: file_extender;
      erlog_generator	: erlog_data_generate;
      new		: reconfigure;
      misc_operator	: misc_utility);
!
(* old configuration parameters - oldcon.tdr *)
!
(************************************************************************)
(*									*)
(*	DISFLG.TDR Updated 22-Jan-86 at 21:38 by Hueyma			*)
(*									*)
(*			     disable_flags				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	11Jul84	Original  ---  ahm					*)
(*									*)
(************************************************************************)


(*									*)
(*     Initially set all flags to disabled, users configuration         *)
(*     file will enable any that they desire.                           *)
(*									*)

$disable alarm
$disable reload
$disable condition
$disable clusternodes
$disable debug
$disable elf
$disable networkconsole
$disable background
$disable shut_link_table_maintenance
$disable old_shut_link_table
$disable multiple_shut_link_table_maintenance
$disable multiple_host_message

 ]
C