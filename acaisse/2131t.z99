(n,l)
(* n,x *)
!
(**********************************************************************)
(* **                  PROPRIETARY INFORMATION                     ** *)
(* **                                                              ** *)
(* **  This  source code listing constitutes the proprietary pro-  ** *)
(* **  perty of TYMNET, Incorporated. The recipient, by receiving  ** *)
(* **  this program listing, agrees that neither this listing nor  ** *)
(* **  the   information  disclosed herein nor any  part  thereof  ** *)
(* **  shall be  reproduced or transferred to other documents  or  ** *)
(* **  used  or  disclosed to others for manufacturing or for any  ** *)
(* **  other   purpose except as specifically authorized in  wri-  ** *)
(* **  ting by  TYMNET, Incorporated.                              ** *)
(* ****************************************************************** *)
(* **                   PROGRAM IDENTIFICATION                     ** *)
(* **                                                              ** *)
(* **  Version Number     :  4.05         Release Date :           ** *)
(* **                                                              ** *)
(* **  File Name          : ELF04.I05                              ** *)
(* **                                                              ** *)
(* **  File Description   : Initial part of ELF 4.05 Source        ** *)
(* **                                                              ** *)
(* **  File Abstract      : The companion file is ELF04.R05        ** *)
(* **                                                              ** *)
(**********************************************************************)
!
(************************************************************************)
(*									*)
(*                 ELF version and revision				*)
(*									*)
(************************************************************************)



const
  version = 4;
  revision = 5;

  (* version number and revision number are output to the user on entry	*)
  (* and stored in elf files.						*)

  (* Version 4.05 -- NEH						*)
  (*	- add standard UNIX interface to use standard UNIX files	*)

  (* Version 4.04 -- RER						*)
  (*	- Corrected recognition of MAG TAPES after other slot releases	*)

  (* Version 4.01 -- RER						*)
  (*	- Added Difference command for CMF.				*)

  (* Version 4.00 -- DLP						*)
  (*      Added the Automatic backup feature, enabling multiple ELves   *)
  (*      in a network to keep each other informed of changes to the    *)
  (*      data base.							*)

  (* Version 3.10, 04/17/85 - jrn					*)
  (*	- fixed a bug that caused files to be transferred to the ELF	*)
  (*	  system erroneously; FILES CREATED WITH VERSION 3.09 SHOULD BE	*)
  (*	  DELETED AND RECREATED WITH VERSION 3.10.;the main repeat loop	*)
  (*	  for receiving characters and storing them to the ELF device	*)
  (*	  was modified in version 3.09 to not check for status on each	*)
  (*	  loop; the check for res_in = COMPLETE needed to remain in	*)
  (*	  order to not store an extra byte at the end			*)
  (*	- fixed a bug in the PORTIO routine write_it to set a timeout	*)
  (*	  of zero seconds on terminal writes				*)
  (*	- removed debugging code and command				*)

  (* Version 3.09, 02/14/85 - jrn					*)
  (*	make ELF less piggish and re-work the downline interaction:	*)
  (*	- replace lots of calls (on EVERY character !!!!!) to		*)
  (*	  CHECK_FOR_STOP with use of the variable USER_INTERRUPT	*)
  (*	- replace some calls to ALL_OK with an appropriate one or two	*)
  (*	  boolean checks						*)
  (*	- remove incr_dl_index, sm_dl_rec, same_cmp and fll_cmp_ct	*)
  (*	  routines and code more efficiently inline			*)
  (*	- add time_sent to dl_recs and use to determine if a record	*)
  (*	  has timed out and should be resent				*)
  (*	- replace gt_dl_ans and get_good_dl_answer with real code	*)
  (*	- change "LOST: " to "RESENT: " when reporting on downline	*)
  (*	  records resent, and report "LATE: " if any acknowledgements	*)
  (*	  arrive after a record has been resent				*)
  (*	- use Pascal Nucleus version 10.07				*)

  (* Version 3.08, 08/10/84 - jnm					*)
  (*	- remove the sending of the project code to the TYMCOM-X	*)
  (*	  altogether							*)
  (*	- add patched nucleus to use send siix message as a send LEM	*)
  (*	  message							*)
  (* Version 3.08, 07/18/84 - jnm					*)
  (*	- add X.25 and Nucleus LDEM patch				*)
  (*	- remove timeout loop and yellow/green ball exchange on		*)
  (*	  building circuit to Tymcom-X					*)
  (*	- fix break out of RENAME bug					*)
  (*	- add DUMP flavors to HELP command				*)
  (*	- add LOCATE commnd						*)
  (*	- add option in DIRECTORY command to output the entry for a	*)
  (*	  specific file							*)
  (*	- handle MXP nodes						*)

  (* Version 3.07, 3/29/84 - jnm					*)
  (*    - Fix bug in breaking out of the CREATE command.		*)
  (*	- Fix multiple disk access and circuit lost bug that caused	*)
  (*	  disk corruptions.						*)
  (*    - Fix crash that was caused by an 80 character or greater	*)
  (*	  input line.							*)
  (*	- Fix erroneous error messages on circuit transmission errors.	*)
  (*	- Changed command file to include a configuration file (sample	*)
  (*	  is ELF03.A07) and the compilation of the actual ELF code;	*)
  (*	- use the latest BASELINE release of the Pascal Nucleus and the	*)
  (*	  patch file (BETATEST)ELF03.P07 which fixes a bug in the	*)
  (*	  recovery from the receipt of a BLACK ball and a bug in the	*)
  (*	  checksum routine.						*)
  (*	- add an option to the SKIP command to skip all ELF files on	*)
  (*	  a magnetic tape, leaving the tape in the position to append	*)
  (*	  the next file(s) transferred to the tape.			*)
  (*	- added tape error recovery; read and write errors are retried	*)
  (*	  16 times before reporting a failure.				*)
  (*	- add a new command, COPY.  The COPY command allows the user	*)
  (*	  to duplicate a single file or ALL files from one ELF device	*)
  (*	  to another (to specify that ALL files are to be copied, the	*)
  (*	  command COPY ALL is used).					*)

  (* Version 3.06, 10/31/83 - jnm					*)
  (*	- Allow CREATES through multiple gateways.			*)
  (*	- Crash if end page of file is negative (to help find BUG).	*)

  (* Version 3.05, 8/26/83 - jnm					*)
  (*	Rename command fix - if illegal file address was entered, the	*)
  (*	change was being made anyway!!! Possibly causing a file header	*)
  (*	to be written over data...not a good thing to do.		*)

  (* Version 3.04, 8/10/83 - jnm					*)
  (*    Update to latest Nucleus 8.02:					*)
  (*	  on needle reads,						*)
  (*		- set arg1 := 0 for no sub-host			 	*)
  (*		- set arg2 := 0 for no timeout			 	*)

  (* Version 3.03, 7/28/82 - jnm					*)
  (*	Run ELFSLV from SOURCE directory.				*)

  (* Version 3.02, 7/14/82 - jnm					*)
  (*	Fix DUMP NODE command to resend dump request records if not 	*)
  (*	acknowledged in 20 seconds, and count as lost.			*)

  (* Version 3.01, 6/28/82 - jnm					*)
  (*	Clear arg2 when term_info call to nucleus is done. V7.01 uses	*)
  (*	arg2 as a timeout.						*)

  (* Version 3.00, 4/21/82 :						*)
  (*		1) use call to nucleus checksum to compute checksums 	*)
  (*		2) store nib file creation date and time in header	*)
  (*		   and output on directory command.			*)
  (*		3) decrease global storage in portio and cmn classes	*)
  (*		   (previously monitors!)				*)
  (*		4) rewrite int_to_wd and wd_to_int routines		*)
  (*		5) remove prompt for password if login information	*)
  (*		   matches previous circuit information			*)
  (*		6) allow unrecognizable files to be deleted		*)
  (*		7) fix bug in CONDENSE command				*)
  (*		8) change CONDENSE command to delete unrecognizable	*)
  (*		   files						*)

  (*	     2.0 : add DUMP SLOT and DUMP PARTIAL commands 1/11/82	*)

  (*	     1.2 : update to version 6.0 pascal nucleus			*)
!
(************************************************************************)
(*         FILE:  ELF CONFIGURATION TYM FILE                            *)
(* COMPANY NAME:  TRW                          LOCATION:  ANAHEIM, CA   *)
(*  NODE NUMBER:  2131                                                  *)
(*  KERNEL HOST:  2131                             HOST:  171           *)
(*  SLOT NUMBER:  02                                                    *)
(*      VERSION:  04.05                                                 *)
(*   UPDATED BY:  ROBERT NOWELL                    DATE:  08/25/90      *)
(************************************************************************)
(* >>>>>>>>>>>>>>>>>>>>>>  REVISION HISTORY  <<<<<<<<<<<<<<<<<<<<<<<<<< *)
(* INSTALLED VERSION 04.02 OF ELF CODE.                   03/15/89  rrn *)
(* INSTALLED VERSION 04.03 OF ELF CODE.                   07/25/89  rrn *)
(* ADDED CMF CONNECTIVITY.                                11/28/89  rrn *)
(* Changed number hosts to fix range error.               12/16/89  rrn *)
(* INSTALLED VERSION 04.05 OF ELF CODE & CHANGED DISK_MAX               *)
(*    TO 4 FROM 1 TO SUPPORT 4 ELF LOGICAL DISKS.         08/25/90  RRN *)
(************************************************************************)
(************************************************************************)
(*									*)
(*		Sample ELF Configuration File				*)
(*									*)
(*	This file contains all user-defined options for ELF.		*)
(*									*)
(************************************************************************)
(*									*)
(*	NOTE: 								*)
(*		- All numeric values in this file are DECIMAL,		*)
(*		  unless otherwise specified.				*)
(*									*)
(************************************************************************)

(* $enable elfbackup *)

  netport_login_username = 'netport\    ';   (* 12 chars required *)
  netport_login_password = 'elf elf\';

const
  nusers = 7            (* number of users able to use elf at one *) ;
			(* time; this value MUST match NUSERS in  *)
			(* the slot TYM file.			  *)

const
  time_zone_offset = -8 * 60 ; (*  User time zone offset from GMT,  *)
		  (*  in minutes; program will adjust for seconds.  *)
		  (*  For example, PDT is 7 hours earlier than GMT. *)

const
  disk_max = 4 ;   (* The Number of Disk Drives supported. This     *)
                   (* must be equal to the value of NDISKS in the   *)
		   (* slot parameter file.			    *)


(* The following parameters are only included if elfbackup is enabled. *)

(* const *)
(*  host_max = 2 ;*)   (*  The Number of ELF Hosts on the Network.      *)
                   (*  This value must match NHOSTS in the slot     *)
		   (*  parameter file.				    *)

            (*  The Host Numbers of the Other ELves on the Network.    *)
            (*  Be sure to state them in increasing numerical order.   *)

       (*  It is necessary that all four "Host Number" symbols be defined.  *)
                (*  The unused ones should be at the end, all set to zero.  *)

(* const *)
(*   host_1 = 0171; *)
(*   host_2 = 0172; *)
(*   host_3 = 0000; *)
(*   host_4 = 0000; *)

!
(**********************************************************************)
(* **                  PROPRIETARY INFORMATION                     ** *)
(* **                                                              ** *)
(* **  This  source code listing constitutes the proprietary pro-  ** *)
(* **  perty of TYMNET, Incorporated. The recipient, by receiving  ** *)
(* **  this program listing, agrees that neither this listing nor  ** *)
(* **  the   information  disclosed herein nor any  part  thereof  ** *)
(* **  shall be  reproduced or transferred to other documents  or  ** *)
(* **  used  or  disclosed to others for manufacturing or for any  ** *)
(* **  other   purpose except as specifically authorized in  wri-  ** *)
(* **  ting by  TYMNET, Incorporated.                              ** *)
(* ****************************************************************** *)
(* **                   PROGRAM IDENTIFICATION                     ** *)
(* **                                                              ** *)
(* **  Version Number     :  4.05         Release Date :           ** *)
(* **                                                              ** *)
(* **  File Name          : ELF04.R05                              ** *)
(* **                                                              ** *)
(* **  File Description   : Remainder of ELF 4.05 Source           ** *)
(* **                                                              ** *)
(* **  File Abstract      : The companion file is ELF04.I05        ** *)
(* **                                                              ** *)
(**********************************************************************)
!
(*   CONFIG.EBK Updated 7-Aug-85 at 20:25 by Paktor     *)
(*   ELF v 4.0, (ELF with Backup) Configuration File.   *)

    (*  included only if not elfbackup *)
   Host_Max = 1 ;
    (*  end inclusion if  not elfbackup  *)
!
(*   EBKBGN.ELF Updated 8-Nov-85 at 18:37 by Paktor          *)
(*   ELF v 4.0, (ELF with Backup) Beginning-of-Program File  *)


(*      File names concatenated to create this program:  *)
    (*          vers.ebk          *)
    (*          config.ebk        *)
    (*          ebkbgn.elf        *)
    (*          defs1.elf         *)
    (*          devdef.elf        *)
    (*          globl.elf         *)
    (*          defs2.elf         *)
    (*          datyps.ebk        *)
    (*          dsktyp.ebk        *)
    (*          msgtyp.ebk        *)
    (*          fifo.ebk          *)
    (*          sleep.elf         *)
    (* (elfcode)crash.elf         *)
    (*          portio.elf        *)
    (*          date.elf          *)
    (*          intstr.elf        *)
    (*          cmn.elf           *)
    (*          cmds.elf          *)
    (*          mrkmon.ebk        *)
    (*          dctntm.ebk        *)
    (*          dfnedm.ebk        *)
    (*          dsksys.elf        *)
    (*          dskmon.ebk        *)
    (*          dskutl.elf        *)
    (*          oplog.elf         *)
    (*          oputil.elf        *)
    (*          cnderr.ebk        *)
    (*          cndnsp.ebk        *)
    (*          ppfifo.ebk        *)
    (*          anbufm.ebk        *)
    (*          crcerr.ebk        *)
    (*          crcmon.ebk        *)
    (*          cnfigm.ebk        *)
    (*          crcdrv.ebk        *)
    (*          msgdsp.ebk        *)
    (*          crchdl.ebk        *)
    (*          msgrdr.ebk        *)
    (*          dskver.ebk        *)
    (*		arperr.ebk	  *)
    (*          anrcvp.ebk        *)
    (*          ansndp.ebk        *)
    (*          adjflh.ebk        *)
    (*          dfrcvp.ebk        *)
    (*          dfsndp.ebk        *)
    (*          devio.elf         *)
    (*          talloc.elf        *)
    (*          cntrl1.elf        *)
    (*          devs.elf          *)
    (*          xfr1.elf          *)
    (*          xfr2.elf          *)
    (*          xfr3.elf          *)
    (*          xfr4.elf          *)
    (*          xfr5.elf          *)
    (*          xfr6.elf          *)
    (*          cntrl2.elf        *)
    (*          cntrl3.elf        *)
    (*          cntrl4.elf        *)
    (*          cntrl5.elf        *)
    (*          cntrl6.elf        *)
    (*          cntrl7.elf        *)
    (*          elfvar.elf        *)
    (*          ebkini.ebk        *)
    (*          elfini.elf        *)
    (*     ********************   *)

(*    The following pre-compile-time switches are set as shown:  *)

(*    elfbackup 			         disabled    *)
(*    ebkdebug				         disabled    *)
(*    ebkdebug_Announce_Command		         disabled    *)
(*    ebkdebug_Circ_Kill_Crash		         disabled    *)
(*    ebkdebug_Circ_Report_Errs		         disabled    *)
(*    ebkdebug_Circ_Report_Msgs		         disabled    *)
(*    ebkdebug_List_Internal_Files	         disabled    *)
(*    configuration_management_facility    	  enabled    *)
(*    configuration_management_facility_debug    disabled    *)
(*    create_project_code         	         disabled    *)
!
(************************************************************************)
(*									*)
(*	defs1.elf							*)
(*									*)
(*                 	global declarations				*)
(*									*)
(************************************************************************)

const	 "various constants"
  mx_tt_chs = 82;		"mx. no. of chars in a terminal line"
  mx_elf_crs = 1028;		"mx. length of elf file record"
  mx_elf_data = 1024;		"no. of data chars in elf file record"
  mx_sl_data = 1016;		"mx data in slot record"
  mx_ob_chs = 400;		"mx. number of chars from elfslv"
  mx_ob_data = 388;		"number of chars of data from elfslv"
  mx_dl_chs = 66;		"total number of chars in downline record"
  mx_dl_data = 56;		"data chars in downline record"
  max_slot = 255	(* hex 0ff *);
  max_mxp_machine = 255	(* hex 0ff *);
  max_dl_records = 80	(* maximum number of outstanding downline records *);
  max_slot_load_rec = 514;
				(* Maximum number of bytes in W command in *)
				(* slot load. This is not the number of    *)
				(* engine memory bytes that are loaded in  *)
				(* a single W command. This constant       *)
				(* limits the number of engine memory      *)
				(* bytes to 255*514/2 or 65535 when only   *)
				(* compression is sent. This insures that  *)
				(* a W command will never span more than   *)
				(* two segments.			   *)
  mx_un_sz = 12;		"mx. number of chars in a username"
  mx_fn_sz = 6;			"mx. number of chars in a filename"
  mx_ext_sz = 3;		"mx. number of chars in an extension name"
  "mx_fn_sz = maximum_filename_size - mx_ext_sze - 1;"
  fn_ln = mx_fn_sz + mx_ext_sz - 1;"filename length"
  byts_in_wd = 4;		"number of bytes in a word"
  hex40 = 64;			"for xor'ing escaped chars"
  hex80 = 128;			"to turn on high order bit for dump"
  full_byte = 255;		"all ones"
  shake_to = 60;		"timeout for handshake"
  nd_rp= 40;		"report node recs. xmitted"
  half_m_one = 65535;		"hex 0ffff"

  "following used to isolate and combine individual chars in a word"
  ch1_factor = 16777216;	"hex 1000000"
  ch2_factor = 65536;		"hex 10000"
  ch3_factor = 256;		"hex 100"

  mx_dc_dgts = 12;		"mx. no. of digits for decimal numbers"
  mx_hx_dgts = 8;		"mx. no. hex digits for number output"
  mx_pg_dgts = 7;		"mx no. of digits in a page number + 1"

  "following used in number i/o routines"
  hex = 16;
  decimal = 10;
  octal = 8;

  "following used in slot commands"
  st_seg_0e = 917504;		"address of beginning of seg 0e"
  size_seg_oe = 256;		"size of seg 0e"

  "for portio"
  do_cr = true;			"output cr after message"
  no_cr = false;		"no cr after message"
!
(* The following is the message buffer used in internal_to_string. *)

const
  message_buffer_text_max   = 240;
  message_buffer_text_limit = message_buffer_text_max - 1;

type
  message_buffer_text_index = 0..message_buffer_text_limit;
  message_buffer_text_size  = 0..message_buffer_text_max;

type
  message_buffer_text = array [message_buffer_text_index] of char;

type
  message_buffer =
    record
      size : message_buffer_text_size;
      text : message_buffer_text
    end (* message_buffer *) ;
!
type	"various type definitions"

  elf_chs = array [1..mx_elf_data] of char;
  term_chs = array [1..mx_tt_chs] of char;
  string2 = array [1..2] of char;
  string4 = array [1..4] of char;
  string8 = array [1..8] of char;
  string24 = array [1..24] of char;

  "used to compute xor of 2 integers"
  int_array = array [1..8] of integer;

  uname_sz = 1..mx_un_sz;
  username = array [uname_sz] of char;
  fn_sz = 1..fn_ln;
  filename = array [fn_sz] of char;
  extname = string4;
!

  "various type and record definitions"
  term_sz = 0..mx_tt_chs;

  line_rec = record	 "this record type is used for most string operations"
    length : term_sz;
    chars  : term_chs
  end (* line_rec *);

  elf_sz = 0..mx_elf_crs;

  elf_rec = record	"definition of elf file record"
    length : elf_sz;
    chars  :
      record
	file_data : elf_chs;
	tape_cksm : integer
      end
  end (* elf_rec *);

  login_info = record	"definition of login string information"
    user        : username;	"following used for tymcom-x logins"
    userlen,				"length of username"
    host        : integer;
    hostf       : boolean;		"true if host is not empty"
    g_user      : username;	"following used for gateway login"
    g_userlen,				"length of gateway username"
    g_host      : integer;		"gateway host"
    g_hostf,				"true if gateway host is not empty"
    non_standard,			"TRUE if user wants to supply"
					"  intermediate login"
    g_x75       : boolean;		"true if gateway is an x75"
    g_password	: line_rec;		"gateway password if non_standard"
    tymstar_load,			"TRUE if load is to TYMSTAR machine"
    mxp_load	: boolean;		"TRUE if load is to an MXP machine"
    slot,			"following used for slot or node login"
    target_node,			"Target node number for TYMSTAR"
    mxp_machine,			"MXP number of mxp_load is TRUE"
    neighbor,				"neighbor node number"
    krnl_host,				"neighbor's kernel host"
    line_number : integer;		"neighbor's line number"
    tymneti     : boolean		"true if tymnet-i, else false"
  end (* login_info *);

  login_rec = record
    info	: login_info;
    password    : line_rec	(* password for tymcom-x user name *)
  end (* login_rec *);


  obj_rec = record		"definition of tymcom-x file information"
    user  : username;
    file  : filename;
    ext   : extname
  end (* obj_rec *);

  char_set = set of char;	"used during xor routine"

  cmf_login_rec = record
    cmf_user     : username; 
    cmf_password : line_rec 
  end (* cmf_login_rec *);

  cmf_file_rec = record
    network,
    subnet,
    cluster   : string24;
    processor : string8 ;
    slot      : string24 
  end (* cmf_file_rec *);
!
"
	miscellaneous character definitions
"

const
  asc0 = '0';
  asc9 = '9';
  asca = 'A';
  ascd = 'D';			"used in file id (disk)"
  ascf = 'F';			"used to check mx. hex digit"
  asclca = '(:97:)';		"lowercase a"
  asclcz = '(:122:)';		"lowercase z"
  ascm = 'M';			"used in file id (magnetic tape)"
  ascn = 'N';			"used to answer yes/no question"
  ascy = 'Y';			"used to answer yes/no question"
  ascz = 'Z';
  cmd_prompt = '(:170:)';	" '*' to isis"
  colon = ':';
  comma = ',';
  contrl_d = '(:4:)';		"control-d for building circuits"
  contrl_h = '(:8:)';		"control-h for X circuits"
  cr = '(:13:)';		"carriage return"
  dot = '.';
  dl_sync = '(:50:)';		"hex 32"
  end_m_ch = '\';		"end of message character"
  escape_ch = '(:128:)';	"hex 80"
  flush_char = '(:129:)';	"isis flush char"
  lc_to_uc = 32;		"difference between upper and lower case"
  lf = '(:10:)';		"line feed"
  l_paren = '(';
  minus = '-';
  ons_cmp_ch = '(:133:)';	"hex 85"
  ones = '(:255:)';		"hex 0ff"
  one = '(:1:)';
  r_paren = ')';
  semi_colon = ';';
  sl_prompt = '(:163:)'		(* '#' to ISIS *);
  shaman_prompt = '(:190:)'	(* '>' to SHAMAN *);
  slash = '/';
  space = ' ';
  sync = '(:170:)';		"hex 0aa"
  two = '(:2:)';
  zro_cmp_ch = '(:132:)';	"hex 84"
  zero = '(:0:)';
!
"
		strings
"
  bytes_m = ' BYTES = \';
  dnic = '3106: ';		"dnic for tymnet"
  continue_m = 'CONTINUE\ ';
  elf_p_c = ';;;ELF';		"for proj-code for tymcom-x logins"
  f_addr_m = 'FILE ADDRESS: \ ';
  file_id_m = 'FILE ID:\ ';
  f_file_m = 'FINAL FILE\ ';
  fnf_m = 'FILE NOT FOUND\ ';
  ill_dev_m = 'ILLEGAL DEVICE\ ';
  input_m = 'INPUT\';
  not_nib_m = ' BAD OBJECT FILE FORMAT\';
  not_equiv_m = ' BAD EQUIVALENCE FILE FORMAT\ ';
  null_m = '\ ';
  unix_file_m = 'UNIX FILE TO COPY: \';
  unix_eq_m = 'UNIX EQUIVALENCE FILE TO COPY: \';
  enter_obj_file_m = 'ENTER OBJECT FILE NAME: \ ';
  obj_file_m = 'OBJECT FILE: \';
  output_m = 'OUTPUT\ ';
  prompt_m = ': \ ';
  question_m = '? \ ';
  reentr_msg = 'REENTER: \';
  spaces_m = '    \ ';
  strt_adr_m = 'START ADDRESS: \';
  st_up_msg = 'ENTER START ADDRESS IN HEX (-1 IF NONE): \';
  sys_err_m = ' SYSTEM OR FILE ERROR\';
  two_spaces = '  \ ';
  xfr_comp_m = 'TRANSFER COMPLETE\';
  xfr_starting_m = 'TRANSFER STARTING\';
  unexpected_m = 'UNEXPECTED RESPONSE FROM NETPORT \';
!
"
	elf - elfslv communication
"

  "elfslv to elf"
  file_found = one;
  fl_not_fnd = two;
  unknown_response = '(:3:)'; "slave expected other response from elf"
  common_inquire = '(:3:)'; "CMF name is both directory and UNIX name"
  not_nib = '(:4:)';	"file is not in a nib format"
  sys_err = '(:6:)';	"system or file error"
  not_equiv = '(:8:)';	"not equivalence file"
  mx_slv_err = 8;

  "elf to elfslv"
  common_unix = one;
  common_cmf = two;
  send_node = one;
  send_slot = two;
  send_part = '(:3:)';
  good_blk = one;
  bad_blk = two;
  forget_it = '(:3:)';	  "stop file transfer"
  retry_file = '(:5:)';	  "user wants to try another file"
  exit_slave = '(:6:)';	  "just exit"
  stop = '(:7:)'; 	  "wait 60 seconds, then exit"
  send_filename = '(:8:)';"get object filename for CMF structure"
  unix_capable = '(:8:)'; "code to netport, elf understands UNIX files"
  eng_code = '(:9:)';	  "unix file to copy is engine code"
  pico_code = '(:10:)';	  "unix file to copy is pico code"

  unix_file_length = 100; "number of characters to send for unix file"
!
"
	i/o related definitions
"

  pgs_in_elf = 4;		"number of disk pages in an elf page"
  n_of_shake = 3;		"number of handshake characters"
  shake_sz = 4;			"shake chars+1 to make array size even"
  
type
  shake_inx = 1..shake_sz;
!
(************************************************************************)
(*									*)
(*	DEVDEF.ELF Updated 3-Aug-85 at 3:50 by Paktor			*)
(*									*)
(*                 	device definitions				*)
(*									*)
(************************************************************************)

const
  terminal_unit_max = nusers;
  aux_circuit_unit_max = nusers;
  tape_unit_max = 4;
  disk_unit_max = 8;

type
  ioresult =
    (complete, intervention, transmission, failure, end_file,
     end_medium, start_medium, program_error, break_key, orange_ball,
     device_busy, timed_out,

	"following are user defined"

    unavailable, sync_error, downl_failure,
    obj_error, isis_error, illegal_dev, bad_cksm, end_of_seg,
    bad_disk, bad_tape, disk_full, mx_files, disk_condensing,
    disk_file_header_error, disk_file_mark_error,
    disk_delete_in_progress, disk_condense_needed);

  header_data_result =
    (header_okay, header_sync, header_guage, header_time, header_start);
!
      (*   GLOBL.ELF  Updated 20-Jul-85 at 19:54 by Raffo    *)

(************************************************************************)
(*									*)
(*	GLOBL.ELF							*)
(*									*)
(*			 Global Declarations				*)
(*									*)
(*	General definitions to be used by all programs.			*)
(*									*)
(************************************************************************)
(*									*)
(*			   Revision Record				*)
(*									*)
(*	 3Sep81	Original for nucleus 6.0				*)
(*									*)
(************************************************************************)


const	(*   General purpose constants   *)
  max_integer =  2147483647 (* largest integer *) ;
  min_integer = -2147483647 (* smallest integer *) ;


type	(*   Device definition *)
  iodevice = (disk, tape, printer, system, crash, terminal, aux_circuit,
	illegal_device);


type
  ioresult_set = set of ioresult;


type	(* disk, tape device definitions *)
  disk_tape_operation =
    (input, output, unit_attach, unit_detach, unit_info, load_program,
      tape_action);


const
  disk_unit_limit = disk_unit_max-1;


type
  disk_unit_index = 0..disk_unit_limit;


type
   disk_tape_param = record
    operation : disk_tape_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* disk_param *) ;


type
  disk_tape_information = record
    logical_unit_number,
    device_status,
    protection_mask,
    default_block_size,
    start_cylinder,
    number_of_cylinders,
    sectors_per_track,
    tracks_per_cylinder,
    device_address,
    global_unit_number,
    ascii_name,
    device_type,
    number_of_sectors :	 integer
  end (* disk_tape_information *) ;


const
  tape_unit_limit = tape_unit_max-1;


type
  tape_unit_index = 0..tape_unit_limit;



const
  tape_back_space = 0;
  tape_forward_file = 1;
  tape_back_file = 2;
  tape_write_eof = 3;
  tape_rewind = 4;
  tape_unload = 5;
  tape_gap = 6;
  tape_set_low_density = 7;



(* terminal and aux_circuit devices - combined to circuit_device *)

type
  circuit_device = terminal..aux_circuit;


const
  terminal_unit_limit = terminal_unit_max-1;


type
  terminal_unit_index = 0..terminal_unit_limit;


const
  aux_circuit_unit_limit = aux_circuit_unit_max-1;


type
  aux_circuit_unit_index = 0..aux_circuit_unit_limit;


type
  circuit_operation =
    (circuit_receive_character, circuit_receive_line, circuit_send,
     circuit_disconnect, circuit_clear_break, circuit_set_system,
     circuit_set_unit, circuit_yellow_ball,
     circuit_detect, circuit_aux_request, circuit_info, circuit_send_b1,
     circuit_get_needle, circuit_zap, circuit_sup_log_message,
     circuit_set_alternate_break, circuit_set_bell, circuit_normal_request,
     circuit_send_siix, circuit_send_tiix);


type
  circuit_param = record
    operation : circuit_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* circuit_param *) ;


const
  echo_off = 0;
  echo_on  = 1;
  xp_on    = 2;
  xp_off   = 3;
  sys_cons = 4;
  char_del = 5;
  word_del = 6;
  line_del = 7;
  crt_term = 11;

const
  sys_char_del = 0;
  sys_word_del = 1;
  sys_line_del = 2;


(*   Needle Record   *)

const
  needle_name_max   = 24 (* characters *) ;
  needle_name_limit = needle_name_max-1;


type
  needle_name_index = 0..needle_name_limit;


type
 needle_name_length = 0..needle_name_max;


type
  needle_name = array[needle_name_index] of char;


type
  needle_record = record
    invoice,
    isis_port,
    host_number,
    node_number,
    origin_host,
    tymsat_port		 : integer;
    number_of_characters : needle_name_length;
    terminal_id		 : char;
    login_name		 : needle_name
  end (* needle_record *) ;
!
(************************************************************************)
(*			system device					*)
(************************************************************************)


type
  system_operation = (system_up, system_down, system_shut, system_gone,
    system_info, system_core_free, read_constant, system_checksum);


type
  system_param = record
    operation : system_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* system_param *) ;


type
  system_information = record
    number_of_terminals,		(* NTERM *)
    number_of_aux_circuits,		(* NAUX *)
    host_number,			(* decimal *)
    node_number,			(* octal *)
    slot_number,			(* hexidecimal *)
    kernel_host_number,			(* decimal *)
    isis_version,			(* 100*v+r in decimal *)
    nucleus_version	   : integer (* 256*v+r in octal *)
  end (* system_information *) ;
!
(************************************************************************)
(*			crash device					*)
(************************************************************************)


type
  crash_operation =
    (crash_wait, crash_signal, crash_restart, crash_halt, crash_kill);

type
  crash_param = record
    operation : crash_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* crash_param *);

type
  process_crash_data =
    record
      error_code: integer;
      process_number: integer;
      line_number: integer
    end (* process_crash_data *) ;
!
(************************************************************************)
(*									*)
(*	DEFS2.ELF  Updated 17-Sep-86 at 16:59 by Raffo 			*)
(*									*)
(*                 	global declarations				*)
(*									*)
(************************************************************************)

const
  n_sub_wds = 5;	"mx. no. of possible sub commands for a command"
  mx_cmd_sz = 10;	"mx. length of a command word"
  mx_sub_sz = 8;	"mx. length of a sub command word"

type
  sub_name = (snode, sslot, spart, smxp, stymstar, s_no_sub);

  subdef_rec = record
    sub_word : string8;		"sub command"
    sub_sz,			"sub command length"
    sub_abb  : integer;		"min sub command abbr"
    sub_prg  : sub_name		"sub command name"
  end (* subdef_rec *);

  sub_index = 1..n_sub_wds;
!
  cmd_name =
    (st_cmd_nms,
    ccondense, ccreate, ccopy,
    cdelete, cdevice,
    cdirectory, cdump, cformat, cgateway, chelp,
    chost,
    cload, clocate, cmessage, cquit, crename, crestart, crewind, cskip,
    end_cmd_nms);

  cmddef_rec = record
    command  : array [1..mx_cmd_sz] of char;	"command"
    cmd_sz,					"command length"
    cmd_abb,					"minimum command abbreviation"
    num_sub  : integer;				"number of sub commands"
    prg_name : cmd_name;			"command routine case index"
    sub_defs : array [sub_index] of subdef_rec	"array of sub commands"
  end (* cmddef_rec *);
!

const	"elf file types"
  nd_ld_file = 1;
  sl_ld_file = 2;
  pt_ld_file = 3;
  nd_dp_file = 4;
  sl_dp_file = 5;
  pt_dp_file = 6;
  internal_file = 7;
  empty_file = 8;
  f_file = 9;
  error_file = 10;

type
  special_ch = (zero_cmp, ons_cmp, escaped, nt_special);
!
"
	downline array info
"

const		"indices into downline array for..."
  dl_sync_x = 1;	"sync char"
  dl_dct_x = 3;		"data count"
  dl_addr_x = 4;	"data address"
  dl_data_x = 7;	"start of data"
  dl_vck_x = 63;	"vertical checksum"
  dl_dck_x = 65;	"diagonal checksum"


type	(* info in a single downline record *)
  downline_record = array [1..mx_dl_chs] of char;


const
  max_unused_chars_in_downline_elf_record = mx_elf_crs - mx_dl_chs;

type
  downline_elf_record = record
    dl_data	: downline_record;
    unused	: array [1..max_unused_chars_in_downline_elf_record] of char
  end (* downline_elf_record *);
!
(************************************************************************)
(*									*)
(*			header array info				*)
(*									*)
(*	The indices for the header array ranges from 1 to to 1024...	*)
(*	word references are included to cross-reference to the		*)
(*	documentation.							*)
(*									*)
(************************************************************************)


const		"indices into header array for..."

(* word 1 *)
  hd_sync_x = 1;		"sync bytes"
  hd_type_x = 4;		"file type"

(* word 2 *)
  hd_ver_x = 5;			"version number"
  hd_rev_x = 7;			"revision number"

(* words 3 - 5 *)
  hd_first_file_x = 9;		"ptr to first file address in id block"
  hd_date_x = 9;		"elf file creation date"
	date_sz = 8;			"(number of chars in date string)"
	time_sz = 4;			"(number of chars in time string)"

(* word 6, first byte *)
  hd_image_x = 21;		"zero if image format, else 0ff"

(* word 7 - 9 *)
  hd_nib_date_x = 25;		"nib creation date"
  hd_nib_time_x = 33;		"nib creation time"

(* words 32 - 51 *)
  hd_id_x = 125;		"file id"
	file_id_sz = 80;		"(number of chars in file id)"

(* word 52 *)
  hd_dsk_st_x = 205;		"start page of file (disk only)"


			(*     OR     *)


  hd_dsk_size = 205;		"required disk pages (tape only)"

(* word 53 *)
  hd_dsk_end_x = 209;		"end page of file (disk only)"


			(*     OR     *)


  hd_cksm_size = 209;		"required disk checksum pages (tape only)"
(* words 54 - 56 *)
  hd_u_name_x = 213;		"object file user name"

(* words 57 - 58 *)
  hd_f_name_x = 225;		"object file name"

(* word 59 *)
  hd_e_name_x = 233;		"object file extension"

(* word 60 *)
  hd_st_adr_x = 237;		"start address for node load"

(* word 61 *)
  hd_byte_ct_x = 241;		"data byte count for load node"

(* word 62 *)
  hd_d_add_x = 245;		"address of start of dump data"

(* word 65 *)
  hd_cksm_x = 257;		"checksum of first block (disk only)"
	hd_cksms = 191;			"(no. of cksum words in dir entry)"

(* word 256 *)
  hd_cksm_end_x = 1021;		"zero if no more cksums or -1 (disk only)"
  hd_last_file_x = 1021;	"ptr to last file on disk"
!
"
		elf record info
"

const		"indices into elf record for slot info for..."
  elf_addr_x = 1;		"address of data"
  elf_bct_x = 5;		"data char count"
  elf_data_x = 9;		"start of data"
  elf_cksm_x = 1025;		"checksum"
!
"
		object record info
"

const		"indices into object data (elf_rec used)"
  ob_sync_x = 1;		"sync char"
  ob_dct_x = 3;			"data count"
  ob_ans_x = 4;			"answer"
  ob_addr_x = 5;		"address"
  ob_data_x = 9;		"start of data"
  ob_cksm_x = 397;		"start of checksum"
!
(*   DATYPS.EBK Updated 7-Aug-85 at 17:46 by Paktor       *)
(*   ELF v 4.0, (ELF with Backup) Data Type Declarations  *)
(*            and Constants Computed from Customer Configuration Parameters  *)

(*     Constants Computed from Customer Configuration Parameters  *)
Const
    Host_First       = 0;
    Host_Limit       = Host_Max - 1 ;
    Host_Absent      = Host_First - 1 ; (*  Used for Startup Error Detection *)

    User_Max         = NUsers ;
    User_First       = 0;
    User_Limit       = User_Max - 1;

    Disk_Limit       = Disk_Max - 1;    (*  Limit of Disk Drive Numbers  *)
    Disk_First       = 0;
    Disk_Absent      = Disk_First - 1;

(**)
!
    (*   DATYPS.EBK  *)

    (*  Types used for .....   *)

Type
    Host_Number        =  1 .. 8192 ;              (* The actual Host Number *)
    Host_Index         =  Host_First .. Host_Limit ;   (* Position in arrays *)
				    (*  such as the KnowLev and the SendLev, *)
				    (*  based on position in the Host List.  *)
    Host_Indicator     =  Host_Absent .. Host_Limit ;  (*  Used for Startup  *)

    User_Index         =  User_First .. User_Limit ; (* User Number *)

    Disk_Index         =  Disk_First  .. Disk_Limit ;   (* Disk Drive Number *)
    Disk_Indicator     =  Disk_Absent .. Disk_Limit ;

    (* Types Used for other things ........  *)

    Time_Element = Integer;  (*  Used in File Marks, KnowLev and SendLev
                                  Arrays, and in Last_Activity_Time.  *)

    File_Mark_Element = Record    (*  Also Used for KnowLevs and SendLevs  *)
                           Host : Host_Index ;
                           Time : Time_Element
                        End ;


Const                          (* Lengths in Characters, for I/O purposes.  *)
    Enumeration_Var_Length    = 2 ;
    Integer_Length            = 4 ;
    Time_Element_Length       =     Integer_Length ;
    File_Mark_Element_Length  = 2 * Integer_Length ;

!
(*   DSKTYP.EBK Updated 6-Aug-85 at 10:04 by Paktor                    *)
(*   ELF v 4.0, (ELF with Backup) Disk-related Data Types and Consts.  *)

(*  These are declared to keep track of limits for the Disk System.         *)

Const

                (*  Characters to a Disk Sector *)
    Sector_Length	= 256 ;   (*  Number of characters in a Disk Sector *)
    Sector_Length_First	=   0 ;
    Sector_Length_Limit = Sector_length - 1;

    One_Disk_Block	=   4 ;   (*  Conversion for Sector-Addressing.  *)

                (*  Characters to a Disk Block  *)
    Block_Length	= Sector_Length * One_Disk_Block ;  (* In Characters *)
    Block_Length_First	=   0 ;
    Block_Length_Limit	= Block_Length - 1 ;

                (*  Integers to a Disk Block    *)
    Block_Size_Max	= Block_length div Integer_Length ; (* In Integers *)
    Block_Size_First	=   0 ;
    Block_Size_Limit	= Block_Size_Max - 1 ;

(**)
!
    (*   DSKTYP.EBK  *)

                (*  Files to a Disk Drive       *)
    Disk_File_Max	= 254 ;
    Disk_File_First	=   1 ;
    Disk_File_Limit	= Disk_File_Max ;
    Disk_File_Not_Found	= Disk_File_First - 1 ;

                (*  Sectors to a Disk Drive     *)
    Disk_Sector_Max            = Max_Integer ;
    Disk_Header_Sector_Address =     0 ; (* Sector where Disk Header resides.*)
    Disk_Sector_Address_Absent =     0 ; (*  How Disk Header shows no file.  *)
    Disk_Sector_Address_First  = One_Disk_Block ; (*First usable Disk Sector.*)
    Disk_Sector_Address_Limit  = Disk_Sector_Max - 1 ;

                (*  Blocks to a Disk Drive      *)
    Disk_Block_Max            = Disk_Sector_Max div One_Disk_Block ;
    Disk_Header_Block_Address =     0 ; (*  Block where Disk Header resides. *)
    Disk_Block_Address_Absent =     0 ; (*  How to indicate there's no file. *)
    Disk_Block_Address_First  =     1 ;        (*  First usable Disk Block.  *)
    Disk_Block_Address_Limit  = Disk_Block_Max - 1 ;

                (*  Sectors to an ELF File      *)
    File_Sector_Max    = Max_Integer ;
    File_Header_Sector =    0 ;    (*  Sector where the File Header begins.  *)
    File_Sector_First  = One_Disk_Block ;   (*  First Sector a File can use  *)
    File_Sector_Limit  = File_Sector_Max - 1 ;

                (*  Blocks to an ELF File       *)
    File_Block_Max    = File_Sector_Max div One_Disk_Block ;
    File_Header_Block = 0 ;     (*  Block where the File Header resides.  *)
    File_Block_First  = 1 ;     (*  First Block a File can use  *)
    File_Block_Limit  = File_Block_Max - 1 ;

(**)
!
    (*   DSKTYP.EBK  *)
      (*  Fix the sizes of the Disk File Usage-related Arrays
      (*                                           in the Disk Monitor    *)

    (*  This Max is computed according to the way the Dialogue and User    *)
    (*    Processes which make use of Disk Files happen to be structured.  *)
    (*    It would have to be re-computed in other applications of this    *)
    (*    Disk File System, or if the "One File per Process" rule were     *)
    (*    to be changed.                                                   *)

    (*  included only if not elfbackup *)
	File_User_Max   = User_Max ;
    (*  end inclusion if  not elfbackup  *)

    (*  These are used to size the array of Indices which serve Requests. *)
	File_User_First = 0 ;
	File_User_Limit = File_User_Max - 1 ;

    (* These are used to the number of users of a file resource.	  *)
	File_Usage_Max  = File_User_Max ;
        File_Not_in_Use = 0 ;

    (*  Used for Disk Monitor Access calls which have the option to be     *)
    (*        or not to be, DELAYEd.  That is still a question.            *)
    Wait_For   = True ;
    No_Wait    = False ;

    (*  These are for special purpose Files which are not to be propogated.  *)

  Internal_File_Time = 0  (* File Mark Time for all Internal Files *) ;


  Operator_Log_Disk_Unit = 0; (* Disk Drive where Operator's Log is located. *)

  Operator_Log_File_Host        = Host_Absent - 2 ;
  Operator_Log_File_Time        = Internal_File_Time ;

      (*  By using an "Illegal" Host Number,    *)
      (*  avoid having these Files propogated   *)
      (*  during Getting-Into-the-Know.         *)


(**)
!
    (*   DSKTYP.EBK  *)

Type
                (*  Characters to a Disk Sector *)
    Sector_Index	   = Sector_Length_First .. Sector_Length_Limit ;

                (*  Characters to a Disk Block  *)
    Block_Index            = Block_Length_First .. Block_Length_Limit ;

                (*  Integers to a Disk Block    *)
    Block_Size             = Block_Size_First .. Block_Size_Limit ;

                (*  Files to a Disk Drive       *)
    Disk_File_Index        = Disk_File_First .. Disk_File_Limit ;
    Disk_File_Indicator    = Disk_File_Not_Found .. Disk_File_Limit ;

                (*  Sectors to a Disk Drive     *)
    Disk_Sector_Address    = Disk_Header_Sector_Address
                                                .. Disk_Sector_Max ;
    Disk_Sector_Indicator  = Disk_Sector_Address_Absent
                                                .. Disk_Sector_Max ;

                (*  Blocks to a Disk Drive      *)
    Disk_Block_Address     = Disk_Header_Block_Address
                                                .. Disk_Block_Max ;
    Disk_Block_Indicator   = Disk_Block_Address_Absent
                                                .. Disk_Block_Max ;

                (*  Sectors to an ELF File      *)
    File_Sector_Size       = File_Header_Sector .. File_Sector_Max ;
    File_Sector_Address    = File_Header_Sector .. File_Sector_Limit ;
    File_Sector_Index      = File_Sector_First .. File_Sector_Limit ;

                (*  Blocks to an ELF File       *)
    File_Block_Size       = File_Header_Block .. File_Block_Max ;
    File_Block_Address    = File_Header_Block .. File_Block_Limit ;
    File_Block_Index      = File_Block_First .. File_Block_Limit ;

	  (* Processes that may use Files, to a Disk  *)
    File_User_Index     = File_User_First .. File_User_Limit;
    File_User_Size      = File_User_First .. File_User_Max;

      (* Number of Processes that may use Files, to a Disk  *)
    File_Usage_Index    = File_Not_in_Use .. File_Usage_Max;

(**)
!
    (*   DSKTYP.EBK  *)

    (*  This is for the result of a Disk Space Allocation Request.  *)
    File_Allocation_Status =(F_A_Disk_Failure, Awaiting_Condense, F_A_Complete,
				File_Already_Exists, Available, Needs_Delete,
				  Needs_Condense, Directory_Full, No_Room) ;

    Gap_Search_Status = Available .. No_Room ;

    File_Open_Status = (File_Opened_Okay, Condensing, File_Not_Found,
			F_O_File_Header_Error, File_In_Use ,
			F_O_Disk_Failure, File_Being_Deleted ) ;


    Disk_Sector = Array [ Sector_Index ] of Char ;

    Disk_Block  = Array [ Block_Index  ] of Char ;

    File_Identifier   =  Record
		    File_Mark : File_Mark_Element ;
		    File_Size : File_Sector_Size
			 End ;

Const
  File_Identifier_Length = File_Mark_Element_Length + Integer_Length ; 

(**)
!
    (*   DSKTYP.EBK  *)

Const
  Ver_Rev          = (Version * 256 * 256) + Revision ;

Type

  (*  This is for the existing Data Structures of the Disk and File Headers  *)
    Disk_Header_Record = Record
            Sync          : Array [1 .. 4] of Char;
            Ver_Rev       : Integer ;
            File_Address  : Array [ Disk_File_Index ] of Disk_Sector_Indicator
                         End ;

    Image_Format_Type = Array [ 1 .. 4 ] of Char ;

    File_Header_Date = Array [ 1 .. 12 ] of Char ;

    File_ID_String = Array [ 1 .. File_ID_Sz ] of Char ;

    File_Header_Record = Record
            Sync_1,Sync_2,Sync_3   : Char ;
            File_Type              : Char ;
            Ver_Rev                : Integer ;
            Creation_Date_and_Time : File_Header_Date ;
            Image_Format           : Image_Format_Type ;
            NIB_Crea_Date_and_Time : File_Header_Date ;
            File_Mark              : File_Mark_Element ;
            Data_Guage             : File_Sector_Size ;
            Slosh_Length,
            Slosh_Dest,
            Slosh_End              : Disk_Sector_Indicator ;
            Unused_1               : Array [ 16 .. 31 ] of Integer ;
            File_ID                : File_ID_String ;
            Start_Data_Sector,
            End_Sector             : Disk_Sector_Address ;
	    Object_File		   : Obj_Rec ;
	    Node_Load_Start	   : Integer ;
	    Node_Load_Count	   : Integer ;
	    Dump_Start		   : Integer ;
            File_Type_Dependant    : Array [ 63 .. 64 ] of Integer ;
            Check_Sums             : Array [ 65 .. 255 ] of Integer ;
            More_Checksums         :  -1 .. 0
                         End ;
(**)
!
    (*   DSKTYP.EBK  *)


    (*  This is for reporting the status of the Disk Drive to its Users.  *)
Disk_Drive_Device_Status = (Disk_Inoperative,
			    Disk_Okay,
			    Disk_Header_Read_Error,
			    Disk_Header_Data_Error,
			    Disk_Header_Write_Error,
			    Disk_Duplicate_Condense_Error,
			    Disk_Duplicate_File_Mark_Error,
			    Disk_File_Index_Error,
			    Disk_File_Header_Read_Error,
			    Disk_File_Header_Data_Error,
			    Disk_File_Header_Write_Error,
			    Disk_Read_Error,
			    Disk_Write_Error,
			    Disk_Go_Dancing   ) ;
!
(*   FILHDR.ELF Updated 17-Jul-85 at 13:00 by Raffo   *)


(*	These are the file header definitions which are specific to	*)
(*	different file types or collections of file types. Each		*)
(*	contains the fields common to all file headers plus those	*)
(*	fields specific to the file type or types.			*)


(*	The file header for types ND_LD_FILE, SL_LD_FILE and		*)
(*	PT_LD_FILE. It's only extra field is the object file name.	*)

type
  load_file_header_record =
    record
      sync_1,sync_2,sync_3	: char;
      file_type			: char;
      ver_rev			: integer;
      creation_date_and_time	: file_header_date;
      image_format		: image_format_type;
      nib_crea_date_and_time	: file_header_date;
      file_mark			: file_mark_element;
      data_guage		: file_sector_size;
      slosh_length		: disk_sector_indicator;
      slosh_dest		: disk_sector_indicator;
      slosh_end			: disk_sector_indicator;
      unused_1			: array [16..31] of integer;
      file_id			: file_id_string;
      start_data_sector		: disk_sector_address;
      end_sector		: disk_sector_address;
      object_file		: obj_rec;
      file_type_dependant	: array [60..64] of integer;
      check_sums		: array [65..255] of integer;
      more_checksums		:  -1..0
    end (* load_file_header_record *) ;
!
(*	The file header for types ND_LD_FILE and ND_DP_FILE.		*)
(*	It's only extra fields are the node start address and the	*)
(*	byte count for image files.					*)

type
  node_file_header_record =
    record
      sync_1,sync_2,sync_3	: char;
      file_type			: char;
      ver_rev			: integer;
      creation_date_and_time	: file_header_date;
      image_format		: image_format_type;
      nib_crea_date_and_time	: file_header_date;
      file_mark			: file_mark_element;
      data_guage		: file_sector_size;
      slosh_length		: disk_sector_indicator;
      slosh_dest		: disk_sector_indicator;
      slosh_end			: disk_sector_indicator;
      unused_1			: array [16..31] of integer;
      file_id			: file_id_string;
      start_data_sector		: disk_sector_address;
      end_sector		: disk_sector_address;
      file_type_dependant_1	: array [54..59] of integer;
      node_load_start		: integer;
      node_load_count		: integer;
      file_type_dependant_2	: array [62..64] of integer;
      check_sums		: array [65..255] of integer;
      more_checksums		:  -1..0
    end (* node_file_header_record *) ;
!
(*	The file header for type ND_DP_FILE.				*)
(*	It's only extra fields are the node start address, the		*)
(*	byte count for image files and the dump start address.		*)

type
  node_dump_file_header_record =
    record
      sync_1,sync_2,sync_3	: char;
      file_type			: char;
      ver_rev			: integer;
      creation_date_and_time	: file_header_date;
      image_format		: image_format_type;
      nib_crea_date_and_time	: file_header_date;
      file_mark			: file_mark_element;
      data_guage		: file_sector_size;
      slosh_length		: disk_sector_indicator;
      slosh_dest		: disk_sector_indicator;
      slosh_end			: disk_sector_indicator;
      unused_1			: array [16..31] of integer;
      file_id			: file_id_string;
      start_data_sector		: disk_sector_address;
      end_sector		: disk_sector_address;
      file_type_dependant_1	: array [54..59] of integer;
      node_load_start		: integer;
      node_load_count		: integer;
      dump_start		: integer;
      file_type_dependant_2	: array [63..64] of integer;
      check_sums		: array [65..255] of integer;
      more_checksums		:  -1..0
    end (* node_dump_file_header_record *) ;
!
(*	The file header for types SL_DP_FILE and PT_DP_FILE.		*)
(*	It's only extra field is the dump segment table.		*)

type
  slot_dump_file_header_record =
    record
      sync_1,sync_2,sync_3	: char;
      file_type			: char;
      ver_rev			: integer;
      creation_date_and_time	: file_header_date;
      image_format		: image_format_type;
      nib_crea_date_and_time	: file_header_date;
      file_mark			: file_mark_element;
      data_guage		: file_sector_size;
      slosh_length		: disk_sector_indicator;
      slosh_dest		: disk_sector_indicator;
      slosh_end			: disk_sector_indicator;
      unused_1			: array [16..31] of integer;
      file_id			: file_id_string;
      start_data_sector		: disk_sector_address;
      end_sector		: disk_sector_address;
      segments_dumped		: array [0..15] of char;
      file_type_dependant	: array [58..64] of integer;
      check_sums		: array [65..255] of integer;
      more_checksums		:  -1..0
    end (* slot_dump_file_header_record *) ;
!
(*   FIFO.EBK Updated 11-Jun-85 at 12:21 by Paktor   *)
(*   ELF v 4.0, (ELF with Backup) FIFO Class Definition.  *)

    (*  Right out of Brinch-Hansen, except goes Zero to (Limit-1).  *)
    (*   Also two additions:  (1)  An added Entry, called "Clear",  *)
    (*      to re-set the FIFO, without re-calling the Init Entry,  *)
    (*   and (2)  a Function Entry called "Length" to retrieve the  *)
    (*      current length of the FiFo, without changing anything.  *)

Type  FiFo  = Class(Limit : Integer);

Var Head, Tail, FiFo_Length : Integer ;

Function Entry Arrival : Integer ;
Begin
  Arrival := Tail;
  Tail := (Tail + 1) mod Limit;
  FiFo_Length := FiFo_Length + 1;
  End;

Function Entry Departure : Integer ;
Begin
  Departure := Head;
  Head := (Head + 1) mod Limit;
  FiFo_Length := FiFo_Length - 1;
  End;

Function Entry Length : Integer ;
Begin
  Length := FiFo_Length ;
  End;

Function Entry Empty : Boolean ;
Begin  Empty := (FiFo_Length = 0)
  End;

Function Entry Full : Boolean ;
Begin  Full := (FiFo_Length = Limit)
  End;

Procedure Entry Clear ;
Begin Head := 0; Tail := 0; FiFo_Length := 0;
  End;

(* FIFO Initialization *)
Begin Head := 0; Tail := 0; FiFo_Length := 0;
  End;
!
(*   SLEEP.ELF Updated 30-Jul-85 at 1:48 by Paktor    *)

(**********************************************************************)
(*                                                                    *)
(*                           sleep_utility                            *)
(*                                                                    *)
(*    This class implements a multisecond wait routine.               *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*    22Aug80    Original -- rer                                      *)
(*                                                                    *)
(**********************************************************************)



type sleep_utility = class

procedure entry sleep(interval: integer);

var
  wakeup: integer (* when to wakeup *) ;

begin
  wakeup := realtime+interval;
  repeat wait until wakeup < realtime
end (* sleep *) ;

procedure entry sleep_until(wakeup: integer);

begin
  repeat wait until wakeup < realtime
end (* sleep_until *) ;

begin
end (* sleep_utility *) ;
!
(************************************************************************)
(*									*)
(*	CRASH.ELF							*)
(*									*)
(*			    crash_utility				*)
(*									*)
(*	This class handles all calls to the crash pseudo-device.	*)
(*	It has separate entries corresponding to each crash operation.	*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	31Oct83	Original -- from (PATROL)crash.ntv - jrn		*)
(*									*)
(************************************************************************)


type crash_utility = class
!


(***************************  crash_utility  ****************************)
(*									*)
(*			  signal_process_error				*)
(*									*)
(*	The crash_send operation. Crash the process making the call and *)
(*	signal any awaiting process that the crash occurred.		*)
(*									*)
(************************************************************************)


procedure entry signal_process_error;

var
  param : crash_param;

begin
  param.operation := CRASH_SIGNAL;
  io(param, param, CRASH, 0)
end (* signal_process_error *) ;
!
(************************************************************************)
(************************************************************************)


begin (* initial statement *)
end (* crash_utility *) ;
!
      (*     PORTIO.ELF Updated 17-Sep-86 at 18:22 by Raffo        *)

(************************************************************************)
(*									*)
(*				portio class				*)
(*									*)
(*	This class performs all terminal and circuit io functions.	*)
(*									*)
(************************************************************************)

type portio = class(
	initial_dev_type	: iodevice;
	initial_dev_unit	: integer);


var
  entry param	: circuit_param;
  dev_type	: iodevice;
  dev_unit	: integer;
!
(*****************************  portio  *********************************)
(*									*)
(*			convert_to_upper_case				*)
(*									*)
(*	Converts all characters in "inline" to upper case characters.	*)
(*									*)
(************************************************************************)

procedure convert_to_upper_case (
  var inline : line_rec );

var
  n : integer;

begin
  for n := 1 to inline.length do
    if (inline.chars[n] >= ASCLCA) and (inline.chars[n] <= ASCLCZ)
    then
      inline.chars[n] := chr(ord(inline.chars[n]) - LC_TO_UC)
end (* convert_to_upper_case *) ;



(*****************************  portio  *********************************)
(*									*)
(*			     print_newline				*)
(*									*)
(*	Write a carriage return and linefeed to the circuit.		*)
(*									*)
(************************************************************************)

procedure print_newline (
  var result	: ioresult);

var
  buffer: array [1..2] of char;
  
begin
  buffer[1] := CR;
  buffer[2] := LF;
  param.arg1 := 2;
  param.arg2 := 0 (* no timeout *) ;
  param.operation := CIRCUIT_SEND;
  io(buffer, param, dev_type, dev_unit);
  result := param.status
end (* print_newline *) ;



(*****************************  portio  *********************************)
(*									*)
(*				write_it				*)
(*									*)
(*	Write the line "input" to the device.				*)
(*									*)
(************************************************************************)

procedure write_it(
  var input	: line_rec;
  var result	: ioresult);

begin
  if input.length <= 0
  then result := COMPLETE
  else
    begin
      param.arg1 := input.length;
      param.arg2 := 0 (* no timeout *) ;
      param.operation := CIRCUIT_SEND;
      io(input.chars, param, dev_type, dev_unit);
      result := param.status
    end
end (* write_it *) ;



(*****************************  portio  *********************************)
(*									*)
(*				print					*)
(*									*)
(*	Type a message to the terminal from "in_m" up to a "\"		*)
(*	character.  If crlf_flag is true, append a crlf.		*)
(*									*)
(************************************************************************)

procedure print (
      in_m	: term_chs;
      crlf_flag : boolean;
  var result	: ioresult);

var
  msg : line_rec;

begin
  msg.length := 0;
  msg.chars  := in_m;
  while msg.chars[msg.length+1] <> END_M_CH do msg.length := msg.length + 1;
  write_it(msg, result);
  if crlf_flag and (result = COMPLETE)
  then print_newline(result)
end (* print *) ;
!
(*****************************  portio  *********************************)
(*									*)
(*				set_echo				*)
(*									*)
(*	This routine sets echoing on a device to "set_value".		*)
(*									*)
(************************************************************************)

procedure entry SET_ECHO(
      set_value	: integer);

var
  temp_char : char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  param.arg1 := set_value;
  io(temp_char, param, dev_type, dev_unit)
end (* set_echo *) ;



(*****************************  portio  *********************************)
(*									*)
(*			   set_crt_terminal				*)
(*									*)
(*	Set handling of backspace for CRT terminal.			*)
(*									*)
(************************************************************************)



procedure entry set_crt_terminal;

var
  dummy : char;

begin
  param.operation 	:= CIRCUIT_SET_UNIT;
  param.arg1 		:= CRT_TERM;
  io(dummy, param, dev_type, dev_unit)
end (* set_crt_terminal *) ;



(*****************************  portio  *********************************)
(*									*)
(*			  set_alternate_break				*)
(*									*)
(*	Set an alternate character for the break function.		*)
(*									*)
(************************************************************************)



procedure entry set_alternate_break(other: char);

var
  local_other : char;

begin
  local_other 		:= other;
  param.operation 	:= CIRCUIT_SET_ALTERNATE_BREAK;
  io(local_other, param, dev_type, dev_unit)
end (* set_alternate_break *) ;



(*****************************  portio  *********************************)
(*									*)
(*			 clear_edit_characters				*)
(*									*)
(************************************************************************)

procedure entry CLEAR_EDIT_CHARACTERS;

var
  dummy : char;
  arg1_value : CHAR_DEL..LINE_DEL;

begin
  for arg1_value := CHAR_DEL to LINE_DEL do 
    begin
      param.operation := CIRCUIT_SET_UNIT;
      param.arg1 := arg1_value;
      param.arg2 := 0 (* clear this edit character *);
      io(dummy, param, dev_type, dev_unit)
    end (* for *)
end (* clear_edit_characters *) ;



(*****************************  portio  *********************************)
(*									*)
(*			send_y_get_o_ball				*)
(*									*)
(*	Send a yellow ball and then wait for an orange ball for		*)
(*	10 seconds.  Return if any other unusual condition.		*)
(*									*)
(************************************************************************)

procedure entry SEND_Y_GET_O_BALL(
  var result	: ioresult);

var
  timeup : integer;		"time that timeout expires"
  temp_char : char;

begin
  param.operation := CIRCUIT_YELLOW_BALL;
  io(temp_char, param, dev_type, dev_unit);
  result := param.status;
  if result = COMPLETE
  then
    begin
      timeup := realtime + 10;
      param.operation := CIRCUIT_DETECT;
      repeat
	io(temp_char, param, dev_type, dev_unit);
	result := param.status;
	if result <> ORANGE_BALL
	then
	  if realtime > timeup
	  then result := TIMED_OUT
	  else wait
      until result <> COMPLETE;
      if (result = ORANGE_BALL) or (result = TIMED_OUT)
      then result := COMPLETE
    end
end (* send_y_get_o_ball *) ;



(*****************************  portio  *********************************)
(*									*)
(*				zap_cir					*)
(*									*)
(*	This procedure terminates the connection to the device.		*)
(*									*)
(************************************************************************)

procedure entry ZAP_CIR(
  var result	: ioresult);

var
  temp_char : char;

begin
  param.operation := CIRCUIT_DISCONNECT;
  io(temp_char, param, dev_type, dev_unit);
  result := param.status
end (* zap_cir *) ;



(*****************************  portio  *********************************)
(*									*)
(*				rd_cr_chs				*)
(*									*)
(*	This routine returns "num_to_input" characters from the circuit	*)
(*	into "output".							*)
(*									*)
(************************************************************************)

procedure entry RD_CR_CHS(
      secs_to_wait	: integer;
      num_to_input	: integer;
  var output		: elf_rec;
  var result		: ioresult);

begin
  if result = COMPLETE
  then
    begin
      param.arg1 := num_to_input;
      param.arg2 := secs_to_wait;
      param.operation := CIRCUIT_RECEIVE_CHARACTER;
      if param.arg1 <= 0
      then result := COMPLETE
      else
	begin
	  io(output.chars, param, dev_type, dev_unit);
	  result := param.status;
	  if result = COMPLETE
	  then output.length := param.arg2
	end
    end
end (* rd_cr_chs *) ;



(*****************************  portio  *********************************)
(*									*)
(*			     read_needle				*)
(*									*)
(*	Read a needle from the terminal. Used by login routine.		*)
(*	Also sets console on port.					*)
(*									*)
(************************************************************************)

procedure entry READ_NEEDLE(
  var needle	: needle_record;
      time_out	: integer;
      sub_host	: integer;
  var result	: ioresult);

begin
  param.operation := CIRCUIT_GET_NEEDLE;
  param.arg1 := sub_host;
  param.arg2 := time_out;
  io(needle, param, dev_type, dev_unit);
  result := param.status
end (* read_needle *) ;



(*****************************  portio  *********************************)
(*									*)
(*			       send_siix				*)
(*									*)
(*	Call the patched nucleus send siix to transmit a LEM message.	*)
(*									*)
(************************************************************************)

procedure entry SEND_SIIX;

begin
  param.operation := CIRCUIT_SEND_SIIX;
  io(param, param, dev_type, dev_unit)
end (* send_siix *) ;



(*****************************  portio  *********************************)
(*									*)
(*				clr_brk_st				*)
(*									*)
(*	This routines clears break status.				*)
(*									*)
(************************************************************************)

procedure entry CLR_BRK_ST(
  var result	: ioresult);

var
  temp_char : char;
  t_res     : ioresult;

begin
  if result = BREAK_KEY
  then
    begin
      param.operation := CIRCUIT_CLEAR_BREAK;
      io(temp_char, param, dev_type, dev_unit);
      result := param.status;
      print('(:13:)(:10:)<BREAK>\', TRUE, t_res)
    end
end (* clr_brk_st *) ;



(*****************************  portio  *********************************)
(*									*)
(*			 build_normal_circuit 				*)
(*									*)
(*	Build a normal circuit.						*)
(*									*)
(************************************************************************)


procedure entry build_normal_circuit (
  var login	: line_rec;
  var result	: ioresult);

begin
  param.operation := CIRCUIT_NORMAL_REQUEST;
  param.arg1 := login.length;
  io(login.chars, param, dev_type, dev_unit);
  result := param.status
end (* build_normal_circuit *) ;



(*****************************  portio  *********************************)
(*									*)
(*				build_it				*)
(*									*)
(*	This routine performs a circuit build.  "login" contains	*)
(*	the login string.  If failure, "outmsg" contains the error	*)
(*	message.							*)
(*									*)
(************************************************************************)

procedure entry BUILD_IT(
  var login	: line_rec;
  var result	: ioresult);

begin
  param.operation := CIRCUIT_AUX_REQUEST;
  param.arg1 := login.length;
  io(login.chars, param, dev_type, dev_unit);
  result := param.status
end (* build_it *) ;



(*****************************  portio  *********************************)
(*									*)
(*				read_line				*)
(*									*)
(*	Read a line from the terminal.					*)
(*									*)
(************************************************************************)

procedure entry read_line (
  var output	: line_rec;
  var result	: ioresult );

begin
  if result = COMPLETE
  then
    begin
      repeat
	param.arg1 := MX_TT_CHS;
	param.arg2 := 0;	(* no time out! *)
	param.operation := CIRCUIT_RECEIVE_LINE;
	io(output.chars, param, dev_type, dev_unit);
	result := param.status;
      until result <> DEVICE_BUSY;
      if result = COMPLETE
      then
	begin
	  if param.arg2 >= MX_TT_CHS
	  then output.length := MX_TT_CHS
	  else output.length := param.arg2;
	  if output.chars[output.length] = CR	    (* remove cr from line *)
	  then output.length := output.length - 1;
	  convert_to_upper_case(output)
	end
    end
end (* read_line *) ;



(*****************************  portio  *********************************)
(*									*)
(*				wr_line_rec				*)
(*									*)
(*	Write a line to the device.					*)
(*									*)
(************************************************************************)

procedure entry wr_line_rec (
  var input	: line_rec;
      crf	: boolean;
  var result	: ioresult);

begin
  write_it(input, result);
  if crf and (result = COMPLETE)
  then print_newline(result)
end (* wr_line_rec *) ;



(*****************************  portio  *********************************)
(*									*)
(*			write_message_buffer				*)
(*									*)
(*	Write a message to the device.					*)
(*									*)
(************************************************************************)

procedure entry write_message_buffer (
  var input	: message_buffer;
      crf	: boolean;
  var result	: ioresult);

begin
  if input.size <= 0
  then result := COMPLETE
  else
    begin
      param.arg1 := input.size;
      param.arg2 := 0 (* no timeout *) ;
      param.operation := CIRCUIT_SEND;
      io(input.text, param, dev_type, dev_unit);
      result := param.status
    end;

  if crf and (result = COMPLETE)
  then print_newline(result)
end (* write_message_buffer *) ;



(*****************************  portio  *********************************)
(*									*)
(*			write_message_string				*)
(*									*)
(*	Type "in_m" to terminal up to the ending char "\".		*)
(*									*)
(************************************************************************)

procedure entry write_message_string (
      in_m	: term_chs ;
  var result	: ioresult);

begin
  print(in_m, FALSE, result)
end (* write_message_string *) ;



(*****************************  portio  *********************************)
(*									*)
(*			 write_message_line				*)
(*									*)
(*	Type "in_m" to terminal up to the ending char "\", followed by	*)
(*	a carriage return.						*)
(*									*)
(************************************************************************)

procedure entry write_message_line (
      in_m	: term_chs ;
  var result	: ioresult);

begin
  print(in_m, TRUE, result)
end (* write_message_line *) ;



(*****************************  portio  *********************************)
(*									*)
(*			   write_newline				*)
(*									*)
(*	Type a new line.						*)
(*									*)
(************************************************************************)

procedure entry write_newline (
  var result	: ioresult);

begin
  print_newline(result)
end (* write_newline *) ;



(*****************************  portio  *********************************)
(*									*)
(*				wr_cir_line				*)
(*									*)
(*	Send a circuit line out over the circuit.			*)
(*									*)
(************************************************************************)

procedure entry wr_cir_line (
  var input	: elf_rec;
  var result	: ioresult);

begin
  if input.length < 0
  then result := COMPLETE
  else
    begin
      param.arg1 := input.length;
      param.arg2 := 0 (* no time out *) ;
      param.operation := CIRCUIT_SEND;
      io(input.chars, param, dev_type, dev_unit);
      result := param.status
    end
end (* wr_cir_line *) ;



(*****************************  portio  *********************************)
(*									*)
(*			   write_right_half				*)
(*									*)
(*	Send right two bytes of an integer.				*)
(*									*)
(************************************************************************)

procedure entry write_right_half (
  var input	: univ string4;
  var result	: ioresult);

begin
  param.arg1 := 2;
  param.arg2 := 0 (* no time out *) ;
  param.operation := CIRCUIT_SEND;
  io(input[3], param, dev_type, dev_unit);
  result := param.status
end (* write_right_half *) ;



(*****************************  portio  *********************************)
(*									*)
(*				any_input				*)
(*									*)
(*	Return the number of chars and lines waiting to be input.	*)
(*									*)
(************************************************************************)

procedure entry ANY_INPUT(
      time_out		: integer;
  var number_of_chars	: integer;
  var number_of_lines	: integer;
  var result		: ioresult);

var
  temp_char : char;

begin
  param.operation := CIRCUIT_INFO;
  param.arg2 := time_out;
  io(temp_char, param, dev_type, dev_unit);

  result := param.status;
  number_of_chars := param.arg1;
  number_of_lines := param.arg2
end (* any_input *) ;



(*****************************  portio  *********************************)
(*									*)
(*				set_unit				*)
(*									*)
(*	Set the device and unit for all future circuit operations.	*)
(*									*)
(************************************************************************)

procedure entry set_unit(
  new_dev_type	: iodevice;
  new_dev_unit	: integer);

begin
  dev_type := new_dev_type;
  dev_unit := new_dev_unit
end (* set_unit *) ;
!
(*****************************  portio  *********************************)
(*									*)
(*		portio initial routine					*)
(*									*)
(************************************************************************)

begin
  dev_type := initial_dev_type;
  dev_unit := initial_dev_unit
end (* portio *) ;
!
(**********************************************************************)
(*                                                                    *)
(*	DATE.ELF						      *)
(*								      *)
(*                         date_time_converter                        *)
(*                                                                    *)
(*    This class handles all ISIS time calculations.                  *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*    22Aug80    Original -- rer                                      *)
(*                                                                    *)
(**********************************************************************)



type date_time_converter = class

const
  leap_year_seconds	= 31622400 (* seconds in leap year *) ;
  non_leap_year_seconds = 31536000 (* seconds in non leap year *) ;



(************************  date_time_converter  ***********************)
(*                                                                    *)
(*                          leap_year_test                            *)
(*                                                                    *)
(*    Return true if year is a leap year.                             *)
(*                                                                    *)
(**********************************************************************)



function leap_year_test (year : integer) : boolean;

begin
  leap_year_test := ((year mod 100) <> 0) and ((year mod 4) = 0)
end (* leap_year_test *) ;



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                           days_in_month                            *)
(*                                                                    *)
(*    Return the number of days in specified month.                   *)
(*                                                                    *)
(**********************************************************************)



function entry days_in_month (
      month	: integer;
      ly	: boolean) : integer;

begin
  case month of
    1,3,5,7,8,10,12: days_in_month := 31;
    4,6,9,11:        days_in_month := 30;
    2: if ly then    days_in_month := 29
             else    days_in_month := 28
  end (* case *)
end (* days_in_month *) ;



(************************  date_time_converter  ***********************)
(*                                                                    *)
(*                             leap_year                              *)
(*                                                                    *)
(*    Return true if year is a leap year.                             *)
(*                                                                    *)
(**********************************************************************)



function entry leap_year (year : integer) : boolean;

begin
  leap_year := leap_year_test(year)
end (* leap_year *) ;



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                            compute_year                            *)
(*                                                                    *)
(*    Convert an ISIS time (ie since 1-1-74) in seconds to            *)
(*    seconds since the beginnning of the year. Also return           *)
(*    the year.                                                       *)
(*                                                                    *)
(**********************************************************************)


procedure entry compute_year (
  var new_time	: integer;
  var year	: integer);

var
  year_seconds: integer;

begin
  year := 1974;
  year_seconds := NON_LEAP_YEAR_SECONDS;
  while new_time >= year_seconds do
    begin
      new_time := new_time-year_seconds;
      year := year+1;
      if leap_year_test(year)
      then year_seconds := LEAP_YEAR_SECONDS
      else year_seconds := NON_LEAP_YEAR_SECONDS
    end (* while *)
end (* compute_year *) ;



(***********************  date_time_converter  ************************)
(**********************************************************************)



begin (* initial statement *)
end (* date_time_converter *) ;
!
(*   INTSTR.ELF Updated 3-Aug-85 at 3:53 by Paktor     *)

(************************************************************************)
(*                                                              	*)
(*	INTSTR.ELF							*)
(*									*)
(*                         internal_to_string                   	*)
(*                                                              	*)
(*    This class converts various internal representations to   	*)
(*    strings of type message_buffer.	                          	*)
(*                                                              	*)
(*     The following identifiers must be defined externally:    	*)
(*                                                              	*)
(************************************************************************)
(*                                                              	*)
(*                           Revision Record                    	*)
(*                                                              	*)
(*	22Aug80    Original -- rer                              	*)
(*      18Jun85    Added Unit_Info to Disk_Ops_Name  -- dlp     	*)
(*	 3Jul85	   Added disk_drive_device_status_name entry -- rer	*)
(*              					        	*)
(************************************************************************)



type internal_to_string = class

type print_time =
  record
    year	: integer;
    month	: integer;
    day		: integer;
    hour	: integer;
    minute	: integer;
    second	: integer
  end (* print_time *) ;

var
  calandar	: date_time_converter;

  entry buffer	: message_buffer (* all conversion into here *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                              put_char                        	*)
(*                                                              	*)
(*    Put character in buffer.text[pointer].                    	*)
(*                                                              	*)
(************************************************************************)


procedure put_char(c: char);

begin
  if buffer.size < MESSAGE_BUFFER_TEXT_LIMIT
  then
    begin
      buffer.text [buffer.size] := c;
      buffer.size := buffer.size + 1
    end
end (* put_char *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                             put_string                       	*)
(*                                                              	*)
(*    Put string into buffer.                                   	*)
(*                                                              	*)
(************************************************************************)



procedure put_string(string_to_insert: term_chs);

var
  i: term_sz;

begin
  i := 1;
  while string_to_insert[i] <> END_M_CH do
    begin
      put_char(string_to_insert[i]);
      i := i+1
    end (* while *)
end (* put_string *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                             put_number                       	*)
(*                                                              	*)
(*    Convert number to string and store in buffer.             	*)
(*                                                              	*)
(************************************************************************)



procedure put_number(
  number_to_convert	: integer;
  radix			: integer);

var
  s			: array [1..11] of integer;
  positive_number	: integer;
  n			: integer;
  i			: integer;
  negative		: boolean;

begin
  positive_number := number_to_convert;
  negative := positive_number < 0;
  if negative
  then
    if (radix = 16) or (radix = 8)
    then positive_number := (positive_number+max_integer)+1
    else positive_number := -positive_number;

  n := 0;
  repeat
    n := n+1;
    s[n] := positive_number mod radix;
    positive_number := positive_number div radix
  until positive_number = 0;

  if negative
  then
    if radix = 8
    then
      begin
        for i := n+1 to 11 do s[i] := 0;
        n := 11;
        s[11] := s[11]+2 (* put sign bit back in last character *)
      end
    else if radix = 16
    then
      begin
        for i := n+1 to 8 do s[i] := 0;
        n := 8;
        s[8] := s[8]+8 (* put sign bit back *)
      end
    else put_char('-');

  for i := n downto 1 do
    if s[i] < 10
    then put_char(chr(ord('0')+s[i]))
    else put_char(chr(ord('A')+s[i]-10))
end (* put_number *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                        date_from_isis_time                   	*)
(*                                                              	*)
(*    Given an ISIS time, return the time for printing.         	*)
(*                                                              	*)
(************************************************************************)



procedure date_from_isis_time (
      isis_time		: integer;
  var date_time		: print_time);

var
  ly: boolean (* true if leap year *) ;

begin
  with date_time do
    begin
      second := isis_time;
      calandar.compute_year(second, year)
    end (* with *) ;

  with date_time do
    begin
      minute := second div 60;
      second := second mod 60;

      hour   := minute div 60;
      minute := minute mod 60;

      day    := (hour div 24)+1;
      hour   := hour mod 24;

      ly     := calandar.leap_year(year);
      month  := 1;

      while day > calandar.days_in_month(month, ly) do
        begin
          day    := day-calandar.days_in_month(month, ly);
          month := month+1
        end (* while *)
    end (* with *)
end (* date_from_isis_time *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                          put_two_digits                      	*)
(*                                                              	*)
(*	Put two digit decimal number in buffer with leading zero if	*)
(*	greater than nine.						*)
(*                                                              	*)
(************************************************************************)


procedure put_two_digits (value: integer);

begin
  if value < 10
  then put_char('0');
  put_number (value, 10)
end (* put_two_digits *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                          put_month_name                      	*)
(*                                                              	*)
(*	Put name of month to buffer.					*)
(*                                                              	*)
(************************************************************************)


procedure put_month_name (month: integer);

begin
  case month of
    1:  put_string ('Jan\');
    2:  put_string ('Feb\');
    3:  put_string ('Mar\');
    4:  put_string ('Apr\');
    5:  put_string ('May\');
    6:  put_string ('Jun\');
    7:  put_string ('Jul\');
    8:  put_string ('Aug\');
    9:  put_string ('Sep\');
    10: put_string ('Oct\');
    11: put_string ('Nov\');
    12: put_string ('Dec\')
  end (* case *)
end (* put_month_name *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                                time                          	*)
(*                                                              	*)
(*    Convert ISIS time to character string.                    	*)
(*                                                              	*)
(************************************************************************)



procedure entry time(time_to_convert: integer);

var
  date_time: print_time;

begin
  date_from_isis_time(time_to_convert + 60*TIME_ZONE_OFFSET, date_time);
  put_number (date_time.day, 10);
  put_char('.');
  put_month_name (date_time.month);
  put_char('.');
  put_number (date_time.year mod 100, 10);
  put_char (' ');
  put_number (date_time.hour, 10);
  put_char (':');
  put_two_digits (date_time.minute);
  put_char (':');
  put_two_digits (date_time.second)
end (* time *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                            header_time                          	*)
(*                                                              	*)
(*    Convert ISIS time to file header string.                    	*)
(*                                                              	*)
(************************************************************************)


procedure entry header_time (time_to_convert: integer);

var
  date_time: print_time;

begin
  date_from_isis_time(time_to_convert + 60*TIME_ZONE_OFFSET, date_time);
  put_two_digits (date_time.month);
  put_two_digits (date_time.day);
  put_two_digits (date_time.year mod 100);
  put_char (' ');
  put_char (' ');
  put_two_digits (date_time.hour);
  put_two_digits (date_time.minute)
end (* header_time *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                        disk_operation_name                   	*)
(*                                                              	*)
(*    Print name for disk operation.					*)
(*                                                              	*)
(************************************************************************)



procedure entry disk_operation_name(operation: disk_tape_operation);

begin
  case operation of
    INPUT:     put_string('read\ ');
    OUTPUT:    put_string('write\');
    UNIT_INFO: put_string('unit_information\ ')
  end (* case *)
end (* disk_operation_name *) ;



(************************  internal_to_string  **************************)
(*                                                              	*)
(*                            status_name                       	*)
(*                                                              	*)
(*    Generate status name string from ioresult.                	*)
(*                                                              	*)
(************************************************************************)



procedure entry status_name(status: ioresult);

begin
  case status of
    COMPLETE:		put_string ('OPERATION COMPLETE\ ');
    INTERVENTION:	put_string ('MANUAL INTERVENTION REQUIRED\ ');
    TRANSMISSION:	put_string ('TRANSMISSION ERROR\ ');
    FAILURE:		put_string ('DEVICE FAILURE\ ');
    END_FILE:		put_string ('END OF FILE\');
    END_MEDIUM:		put_string ('END OF MEDIUM\');
    START_MEDIUM:	put_string ('START OF MEDIUM\');
    PROGRAM_ERROR:	put_string ('PROGRAM ERROR\');
    BREAK_KEY:		put_string ('STOPPED BY USER\');
    ORANGE_BALL:	put_string ('ORANGE BALL\');
    DEVICE_BUSY:	put_string ('DEVICE BUSY\');
    TIMED_OUT:		put_string ('TIMED OUT\');
    UNAVAILABLE:	put_string ('UNAVAILABLE\');
    SYNC_ERROR:		put_string ('SYNC ERROR\ ');
    DOWNL_FAILURE:	put_string ('DOWNLINE FAILURE\ ');
    OBJ_ERROR:		put_string ('OBJECT ERROR\ ');
    ISIS_ERROR:		put_string ('ISIS ERROR\ ');
    ILLEGAL_DEV:	put_string (ILL_DEV_M);
    BAD_CKSM:		put_string ('CHECKSUM DOES NOT MATCH\');
    END_OF_SEG:		put_string ('END OF SEGMENT\ ');
    BAD_DISK:		put_string ('BAD DISK\ ');
    BAD_TAPE:		put_string ('BAD TAPE\ ');
    DISK_FULL:		put_string ('DISK IS TOO FULL\ ');
    MX_FILES:		put_string ('TOO MANY FILES ON DISK\ ');
    DISK_CONDENSING:	put_string ('DISK CONDENSE IN PROGRESS\');
    DISK_FILE_HEADER_ERROR:
      put_string ('DATA ERROR WITH FILE HEADER\');
    DISK_FILE_MARK_ERROR:
      put_string ('PROGRAM ERROR WITH FILE MARK\ ');
    DISK_DELETE_IN_PROGRESS:
      put_string ('SPACE AVAILABLE WHEN DELETE COMPLETE\ ');
    DISK_CONDENSE_NEEDED:
      put_string ('CONDENSE NEEDED\')
  end (* case *)
end (* status_name *) ;



(************************  internal_to_string  **************************)
(*                                                              	*)
(*                   disk_drive_device_status_name                    	*)
(*                                                              	*)
(*    Generate status name string from disk_drive_device_status.	*)
(*                                                              	*)
(************************************************************************)



procedure entry disk_drive_device_status_name (
      status: disk_drive_device_status);

begin
  case status of
    DISK_INOPERATIVE:		   put_string('Disk inoperative\ ');
    DISK_OKAY:			   put_string('Disk okay\');
    DISK_HEADER_READ_ERROR:	   put_string('Disk header read error\ ');
    DISK_HEADER_DATA_ERROR:	   put_string('Disk header data error\ ');
    DISK_HEADER_WRITE_ERROR:	   put_string('Disk header write error\');
    DISK_DUPLICATE_CONDENSE_ERROR: put_string('Disk duplicate condense error\');
    DISK_FILE_INDEX_ERROR:	   put_string('Disk file index error\');
    DISK_FILE_HEADER_READ_ERROR:   put_string('Disk file header read error\');
    DISK_FILE_HEADER_DATA_ERROR:   put_string('Disk file header data error\');
    DISK_FILE_HEADER_WRITE_ERROR:  put_string('Disk file header write error\ ');
    DISK_READ_ERROR:		   put_string('Disk read error\');
    DISK_WRITE_ERROR:		   put_string('Disk write error\ ');
    DISK_GO_DANCING:		   put_string('Disk go dancing\')
  end (* case *)
end (* disk_drive_device_status_name *) ;



(*****************************  portio  *********************************)
(*									*)
(*		   unknown_circuit_error_message			*)
(*									*)
(************************************************************************)

procedure unknown_circuit_error_message (error_number : integer);

begin
  put_string ('ERROR \ ');
  put_number (error_number, 10)
end (* unknown_circuit_error_message *) ;



(*****************************  portio  *********************************)
(*									*)
(*		   	 normal_circuit_error				*)
(*									*)
(*	Generates the text for a normal build circuit error.		*)
(*									*)
(************************************************************************)

procedure entry normal_circuit_error (
      param	: circuit_param);

begin
  if param.status = PROGRAM_ERROR
  then put_string ('incomplete login string\')
  else
    if (param.arg1 > 0) and (param.arg1 <= 18)
    then
      case param.arg1 of
	1:
	  put_string ('Please log in\');
	2, 4:
	  put_string ('Error in username\');
	3, 5:
	  put_string ('Error in password\');
	6:
	  unknown_circuit_error_message(param.arg1);
	7:
	  unknown_circuit_error_message(param.arg1);
	8:
	  unknown_circuit_error_message(param.arg1);
	9, 19:
	  put_string ('Bad MUD\');
	10:
	  put_string ('Circuits busy\');
	11, 13, 14:
	  put_string ('SYSTEM UNAVAILABLE\ ');
	12:
	  put_string ('Host out of ports\');
	15:
	  put_string ('Try again in 2 minutes\ ');
	16:
	  put_string ('Access not permitted\ ');
	17:
	  put_string ('No host specified\');
	18:
	  put_string ('Bad host number\')
      end (* case *)
    else unknown_circuit_error_message(param.arg1)
end (* normal_circuit_error *) ;



(*****************************  portio  *********************************)
(*									*)
(*			    aux_circuit_error				*)
(*									*)
(*	Put aux circuit error message in buffer.			*)
(*									*)
(************************************************************************)

procedure entry aux_circuit_error(
      param	: circuit_param);

begin
  if param.status = DEVICE_BUSY
  then put_string ('circuit in use\ ')
  else
    if param.arg2 <= 9
    then
      case param.arg2 of
	0:
	  put_string ('SLOT 0 WILL NOT HONOR REQUEST, TRY LATER\ ');
	1:
	  put_string ('FORMAT ERROR\ ');
	2:
	  put_string ('BAD USER NAME\');
	3:
	  put_string ('BAD MUD\');
	4:
	  put_string ('SYSTEM UNAVAILABLE\ ');
	5:
	  put_string ('DOWN-LINE LOAD REQUEST FAILURE\ ');
	6:
	  put_string ('TIMEOUT ON CIRCUIT BUILD\ ');
	7:
	  put_string ('ACCESS NOT PERMITTED\ ');
	8:
	  put_string ('OUT OF ORIGINATION PORTS\ ');
	9:
	  put_string ('SUP WILL NOT HONOR REQUEST, TRY LATER\')
      end (* case *)
    else unknown_circuit_error_message(param.arg2)
end (* aux_circuit_error *) ;



(************************  internal_to_string  **************************)
(*                                                              	*)
(*                               number                         	*)
(*                                                              	*)
(*    Convert a number in any radix to a string.                	*)
(*                                                              	*)
(************************************************************************)



procedure entry number (
      number_to_convert: integer;
      radix: integer);

begin
  put_number(number_to_convert, radix)
end (* number *) ;



(***********************   internal_to_string	***************************)
(*									*)
(*			     format_number				*)
(*									*)
(*    Convert a number to a string of places_to_print characters. 	*)
(*    If 'places_to_print' is negative, display leading zeros.		*)
(*    Otherwise, display leading blanks.				*)
(*									*)
(**************************************************************************)


procedure entry format_number(
  number_to_convert	: integer;
  radix 		: integer;
  places_to_print	: integer );

var
  n, comparator : integer;
  scanned_number: integer;

begin
  scanned_number := number_to_convert;
  if (scanned_number < 0) and ((radix = 8) or (radix = 16))
  then scanned_number := MAX_INTEGER; (* printed on 8 places *)

  comparator := 1;
  for n := 1 to abs(places_to_print)-1 do comparator := comparator * radix;
  repeat
    if comparator > scanned_number
    then
      if places_to_print < 0
      then put_char('0')
      else put_char(' ');
    comparator := comparator div radix
  until comparator = 1;
  put_number( number_to_convert, radix )
end (* format_number *) ;



(************************  internal_to_string  **************************)
(*                                                              	*)
(*                            scaled_number                     	*)
(*                                                              	*)
(*    Convert a number to a string with a radix point a given number  *)
(*    of places to the left of the right of the number. I.e, a call   *)
(*    of scaled_number(1234, 10, 1) will produce the number 123.4     *)
(*                                                              	*)
(************************************************************************)



procedure entry scaled_number (
      number_to_convert: integer;
      radix: integer;
      radix_place: integer);

var
  fraction: integer;
  scale: integer;
  i: integer;

begin
  scale := 1 (* construct scale factor from radix places *) ;
  for i := 1 to radix_place do scale := scale*radix;
  put_number(number_to_convert div scale, radix);
  put_char('.');
  fraction := abs(number_to_convert mod scale);
  scale := scale div radix;
  while scale > fraction do (* output leading zeros of fraction *)
    begin
      put_char('0');
      scale := scale div radix
    end (* while *) ;
  if fraction > 0 then put_number(fraction, radix)
end (* scaled_number *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                         move_from_elf_chs                         	*)
(*                                                              	*)
(*	Move a string of characters from the middle of an elf_chs var	*)
(*	to the buffer.							*)
(*                                                              	*)
(************************************************************************)


procedure entry move_from_elf_chs (
      count		: integer;
      from_data		: elf_chs;
      from_start	: integer);

var
  i : integer;

begin
  for i := 0 to count-1 do
    put_char (from_data[from_start + i])
end (* move_from_elf_chs *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                               string                         	*)
(*                                                              	*)
(*    Put string into buffer.                                   	*)
(*                                                              	*)
(************************************************************************)



procedure entry string(string_to_insert: term_chs);

begin
  put_string(string_to_insert)
end (* string *) ;



(************************  internal_to_string  **************************)
(*                                                              	*)
(*                                skip                          	*)
(*                                                              	*)
(*    Skip n blanks in buffer.                                  	*)
(*                                                              	*)
(************************************************************************)



procedure entry skip(n: integer);

var
  i: integer;

begin
  if n > 0
  then
    for i := 1 to n do put_char(' ')
  else
    buffer.size := buffer.size + n
end (* skip *) ;



(************************  internal_to_string  **************************)
(*                                                              	*)
(*                              skip_to                         	*)
(*                                                              	*)
(*    Skip to position n in buffer.                             	*)
(*                                                              	*)
(************************************************************************)



procedure entry skip_to(n: integer);

var
  i: integer;

begin
  if n > buffer.size
  then
    for i := 1 to n - buffer.size do put_char(' ')
  else
    buffer.size := n
end (* skip_to *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                            newline		                       	*)
(*                                                              	*)
(*    Put carriage return and linefeed in buffer.                  	*)
(*                                                              	*)
(************************************************************************)



procedure entry newline;

begin
  put_char(CR);
  put_char(LF)
end (* newline *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                          enumeration		                       	*)
(*                                                              	*)
(*    Put numeric value of enumeration value into buffer.               *)
(*                                                              	*)
(************************************************************************)



procedure entry enumeration(
     enum : UNIV string2 ; 
    radix : integer );

begin
  put_number ( (256*ord(enum[1])+ord(enum[2])), radix)
end  (*  enumeration  *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                              character                       	*)
(*                                                              	*)
(*    Put single character in buffer.                           	*)
(*                                                              	*)
(************************************************************************)



procedure entry character(c: char);

begin
  put_char(c)
end (* character *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                                start                         	*)
(*                                                              	*)
(*    Start the buffer at the beginning.                        	*)
(*                                                              	*)
(************************************************************************)



procedure entry start;

begin
  buffer.size := 0
end (* start *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                          simple_message                      	*)
(*                                                              	*)
(*    Start the buffer at the beginning and insert a message.		*)
(*                                                              	*)
(************************************************************************)



procedure entry simple_message(message_to_insert: term_chs);

begin
  buffer.size := 0;
  put_string(message_to_insert)
end (* simple_message *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                          number_message                      	*)
(*                                                              	*)
(*    Start the buffer at the beginning, insert a message and a number.	*)
(*                                                              	*)
(************************************************************************)



procedure entry number_message (
  message_to_insert	: term_chs;
  value			: integer;
  radix			: integer);

begin
  buffer.size := 0;
  put_string(message_to_insert);
  put_number (value, radix)
end (* number_message *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*			     write_string                        	*)
(*                                                              	*)
(*    Write buffer to given terminal as a string with no CR.		*)
(*                                                              	*)
(************************************************************************)



procedure entry write_string (
      circuit	: portio;
  var result	: ioresult);

begin
  circuit.write_message_buffer (buffer, FALSE, result)
end (* write_string *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                            write_line                        	*)
(*                                                              	*)
(*    Write current buffer to given circuit as a line.			*)
(*                                                              	*)
(************************************************************************)



procedure entry write_line (
      circuit	: portio;
  var result	: ioresult);

begin
  circuit.write_message_buffer (buffer, TRUE, result)
end (* write_line *) ;



(***********************  internal_to_string  ***************************)
(*                                                              	*)
(*                         store_to_line_rec                        	*)
(*                                                              	*)
(*    Moves the current buffer to a given variable of type line_rec.	*)
(*                                                              	*)
(************************************************************************)



procedure entry store_to_line_rec (
  var output	: line_rec);

var
  i : term_sz;

begin
  if buffer.size > MX_TT_CHS
  then output.length := MX_TT_CHS
  else output.length := buffer.size;
  for i := 1 to output.length do
    output.chars[i] := buffer.text[i-1]
end (* store_to_line_rec *) ;



(************************  internal_to_string  **************************)
(************************************************************************)



begin (* initial statement *)
  init calandar
end (* internal_to_string *) ;
!
(************************************************************************)
(*									*)
(*	CMN.ELF								*)
(*									*)
(*				commondef class				*)
(*									*)
(*	Some routines used by both the xfr and control processes.	*)
(*									*)
(************************************************************************)

type commondef = class (format : internal_to_string);

var
  n         : integer;
  found     : boolean;
  temp_char : char;
!
"
		internal commondef routines
"



(*****************************  commondef  ******************************)
(*									*)
(*				alpha_numeric				*)
(*									*)
(*	This function returns true if "ch" is an alpha-numeric,		*)
(*	false if not.							*)
(*	Characters excluded are control chars, ":", ";", "(", ")",	*)
(*	"[", and "]".							*)
(*									*)
(************************************************************************)

function alpha_numeric(ch : char) : boolean;

begin
  alpha_numeric := ((ch>=asca) and (ch<=ascz)) or ((ch>=asc0) and (ch<=asc9))
end (* alpha_numeric *);



(*****************************  commondef  ******************************)
(*									*)
(*				username_character			*)
(*									*)
(*	This routine returns true if "ch" is a legal user		*)
(*	name character, false if not.					*)
(*									*)
(************************************************************************)

function username_character(ch : char) : boolean;

begin
  username_character := not ((ch < space) or (ch = colon) or (ch = semi_colon) or
    (ch = '[') or (ch = ']') or (ch = l_paren) or (ch = r_paren))
end (* username_character *);



(*****************************  commondef  ******************************)
(*									*)
(*				get_digit				*)
(*									*)
(*	This routine sets the flag "anumber" according to whether	*)
(*	"inchar" is a legal digit for the "base", and returns the	*)
(*	numeric value in "digit".					*)
(*									*)
(************************************************************************)

procedure get_digit(inchar : char;
		base : integer;
		var digit : integer;
		var anumber : boolean);

begin
  anumber := false;
  digit := base;
  if (inchar >= asc0) and (inchar <= asc9)
  then digit := ord(inchar) - ord (asc0)
  else
    if (inchar >= asca) and (inchar <= ascf)
    then digit := 10 + ord(inchar) - ord(asca);
  if digit <= base-1 then anumber := true
end (* get_digit *);



(*****************************  commondef  ******************************)
(*									*)
(*				xor_it					*)
(*									*)
(*	This routine in effect, does anx eor on the integers stored	*)
(*	in x and y.		Result returned in x.			*)
(*									*)
(************************************************************************)

procedure xor_it(var x : univ char_set;
		y : univ char_set);

begin
  x := (x-y) or (y-x)
end (* xor_it *);



(*****************************  commondef  ******************************)
(*									*)
(*			scan_to_non_alphanumeric			*)
(*									*)
(*	This routine inputs chars from "inl.chars" until a non-		*)
(*	alpha-numeric character is found.  "in_ptr" is updated.		*)
(*									*)
(************************************************************************)

procedure scan_to_non_alphanumeric(inl : line_rec;
		       var in_ptr : term_sz);

begin
  found := false;
  repeat
    in_ptr := in_ptr + 1;
    if not alpha_numeric(inl.chars[in_ptr]) then found := TRUE
  until (found = TRUE) or (in_ptr > inl.length)
end (* scan_to_non_alphanumeric *);



(******************************  commondef  *****************************)
(*									*)
(*				clear_block				*)
(*									*)
(*	Set a block to all zero.					*)
(*									*)
(************************************************************************)

procedure clear_block (var block : univ disk_block);

var
  i : block_index;

begin
  for i := BLOCK_SIZE_FIRST to BLOCK_SIZE_LIMIT do block[i] := ZERO
end (* clear_block *) ;



(******************************  commondef  *****************************)
(*									*)
(*				init_header				*)
(*									*)
(*	Set up sync chars, version and revision and clear rest of h.	*)
(*									*)
(************************************************************************)

procedure init_header (var header : univ file_header_record);

begin
  clear_block (header);
  header.sync_1 := SYNC;
  header.sync_2 := SYNC;
  header.sync_3 := SYNC;
  header.ver_rev := version*65536 + revision
end (* init_header *) ;
!
"
		external commondef routines
"



(**************************  commondef  *********************************)
(*									*)
(*				token_in				*)
(*									*)
(*	This routine returns the next alphanumeric string in "token"	*)
(*	from "inline".  It uses "inptr" to point to the string.		*)
(*	leading spaces are ignored.					*)
(*									*)
(************************************************************************)

procedure entry token_in (inline : line_rec;
		var inptr : term_sz;
		var token : line_rec);

begin
  found := FALSE;
  with token do
    begin
      length := 0;
      "skip any leading spaces"
      repeat
	temp_char := inline.chars[inptr];
	inptr := inptr + 1
      until (temp_char <> space) or (inptr > inline.length);
      inptr := inptr - 1;
      repeat
	temp_char := inline.chars[inptr];
	if not alpha_numeric(temp_char)
	then found := TRUE
	else
	  begin
	    length := length + 1;
	    chars[length] := temp_char;
	    inptr := inptr + 1
	  end
      until found or (inptr > inline.length)
    end (* with *)
end (* token_in *);



(**************************  commondef  *********************************)
(*									*)
(*			skp_to_tok					*)
(*									*)
(*	This routine uses the ptr to scan the input line further.	*)
(*	It stops when an alphanumeric char or end of input is found.	*)
(*									*)
(************************************************************************)

procedure entry skp_to_tok(inline : line_rec;
		var inptr : term_sz;
		var foundtoken : boolean);

begin
  foundtoken := false;
  with inline do
    if inptr < length then
      begin
	inptr := inptr - 1;
	repeat
	  inptr := inptr + 1;
	  if alpha_numeric(chars[inptr]) then foundtoken := TRUE
	until foundtoken or (inptr >= length)
      end
end (* skp_to_tok *);



(*****************************  commondef  ******************************)
(*									*)
(*				input_num				*)
(*									*)
(*	This routine inputs "number" from "inline" in the		*)
(*	"base" specified.  "inptr" points to  beginning of the		*)
(*	string.								*)
(*									*)
(************************************************************************)

procedure entry input_num(base : integer;
		inline : line_rec;
		var inptr : term_sz;
		var number : integer;
		var numfound : boolean);

var
  digits  : array [1..mx_dc_dgts] of integer;
  multi,
  ndigits : integer;
  minus_flg : boolean;

begin
  minus_flg := false;
  numfound := false;
  with inline do
    if length > 0 then
      begin
	number := 0;
	ndigits := 0;
	if chars[inptr] = minus then
	  begin
	    minus_flg := true;
	    inptr := inptr + 1
	  end;
	repeat
	  ndigits := ndigits + 1;
	  get_digit(chars[inptr], base, digits[ndigits], numfound);
	  inptr := inptr + 1
	until not numfound;
	ndigits := ndigits-1;
	numfound := true;
	multi := 1;
	if ndigits > 1
	then
	  for n := 1 to ndigits-1 do multi := multi * base;
	for n := 1 to ndigits do
	  begin
	    number := number + digits[n] * multi;
	    multi := multi div base
	  end;
	if minus_flg then number := - number
    end
end (* input_num *);


(*****************************  commondef  ******************************)
(*									*)
(*				input_user				*)
(*									*)
(*	This routine inputs a legal user name from "inline".		*)
(*									*)
(************************************************************************)

procedure entry input_user(inline : line_rec;
		var in_ptr : term_sz;
		var user : username;
		var ulen : uname_sz);

begin
  found := false;
  ulen := 0;
  for n := 1 to mx_un_sz do user[n] := zero; "clear username"
  with inline do
    begin
      repeat
	temp_char := chars[in_ptr];
	if not username_character(temp_char)
	then found := true
	else
	  begin
	    ulen := ulen + 1;
	    user[ulen] := temp_char;
	    in_ptr := in_ptr + 1
	  end
      until found or (ulen >= mx_un_sz) or (in_ptr > length);
      if not found and (ulen >= mx_un_sz) then 	"> 12 chars!"
	repeat
	  ulen := ulen + 1;
	  if not username_character(chars[in_ptr]) then found := true;
	  in_ptr := in_ptr +1
	until found
    end (* with *)
end (* input_user *);



(*****************************  commondef  ******************************)
(*									*)
(*				input_file				*)
(*									*)
(*	This routine inputs a filename and optional extension from the 	*)
(*	input line.							*)
(*									*)
(************************************************************************)

procedure entry input_file(inline : line_rec;
		var in_ptr : term_sz;
		var fd : obj_rec;
		var gotfile : boolean);

var
  ptr : term_sz;

begin
  gotfile := false;	"say we have no file yet"
  ptr := 0;		"ptr to save file chars"
  found := false;
  with fd, inline do
    begin
      for n := 1 to mx_fn_sz do file[n] := zero;	"clear filename"
      for n := 1 to mx_ext_sz do ext[n] := zero;	"clear extension"
      in_ptr := in_ptr - 1;
      repeat			"save chars until a non-alpha-num found"
	ptr := ptr + 1;		"increment ptr to save next char"
	in_ptr := in_ptr + 1;	 "increment ptr to get next char"
	temp_char := chars[in_ptr]; "pick up next char from input"
	if alpha_numeric(temp_char)
	then file[ptr] := temp_char
	else found := true
      until found or (ptr >= mx_fn_sz) or (in_ptr >= length);
      if inline.length > 0
      then gotfile := true;
      if not found then scan_to_non_alphanumeric(inline, in_ptr);
      if chars[in_ptr] = dot then	"extension coming"
	begin
	  ptr := 0;		"ptr to save ext chars"
	  found := false;
	  repeat
	    ptr := ptr + 1;
	    in_ptr := in_ptr + 1;
	    temp_char := chars[in_ptr];
	    if alpha_numeric(temp_char)
	    then ext[ptr] := temp_char
	    else found := true
	  until found or (ptr >= mx_ext_sz) or (in_ptr >= length);
	  if not found then scan_to_non_alphanumeric(inline, in_ptr)
	end
    end (* with *)
end (* input_file *);



(*****************************  commondef  ******************************)
(*									*)
(*				set_up_id				*)
(*									*)
(*	Set up sync chars, version and revision numbers and clear	*)
(*	rest of "idb".							*)
(*									*)
(************************************************************************)

procedure entry set_up_id(var idb : elf_chs);

begin
  init_header(idb)
end (* set_up_id *);



(*************  commondef  **********************************************)
(*									*)
(*				make_file_hdr				*)
(*									*)
(*	Make a file header record in "hdr"				*)
(*									*)
(************************************************************************)

procedure entry make_file_hdr (
      ft		: integer;
      image_format	: boolean;
      id_line		: line_rec;
  var header		: univ file_header_record );

begin
  init_header(header);
  header.file_type := chr(ft);	"save file type"
  if image_format		"save image flag in 1 byte"
  then header.image_format[1] := ZERO
  else header.image_format[1] := ONES;

  for n := 1 to FILE_ID_SZ do
    if n <= id_line.length
    then header.file_id[n] := id_line.chars[n]
    else header.file_id[n] := SPACE;

  format.start;
  format.header_time (realtime);	"get current time and date in gmt"
  for n := 0 to format.buffer.size - 1 do	"and save time and date"
     header.creation_date_and_time[n + 1] := format.buffer.text[n]
end (* make_file_hdr *);



(*****************************  commondef  ******************************)
(*									*)
(*				xor					*)
(*									*)
(*	This routine in effect, performs an xor on the integers stored	*)
(*	in x and y.		Result returned in x.			*)
(*									*)
(************************************************************************)

procedure entry xor(var x : integer;
		y : integer);

var
  xa,
  ya : int_array;

begin
  xa[1] := x;
  ya[1] := y;
  xor_it(xa, ya);
  x := xa[1]
end (* xor *);
!



(*****************************  commondef  ******************************)
(*									*)
(*		commondef initial routine				*)
(*									*)
(************************************************************************)

begin
end;	"null initial routine"
!
(************************************************************************)
(*									*)
(*	CMDS.ELF Updated 17-Sep-86 at 17:00 by Raffo			*)
(*									*)
(*				commanddefs monitor			*)
(*									*)
(*	This monitor defines all the command entries for elf.		*)
(*	It contains 2 command scanning routines, one for commands	*)
(*	and one for sub commands.  It is accessed by the control	*)
(*	process.							*)
(*									*)
(************************************************************************)

type commanddefs = monitor;

var
  defs : array[cmd_name] of cmddef_rec;	"table of all command info"
!
(***********************   commanddefs   ********************************)
(*									*)
(*				findcmd					*)
(*									*)
(*	The findcmd routine looks up the command in the input		*)
(*	line and returns the command record, if found.			*)
(*									*)
(************************************************************************)

procedure entry findcmd(inline : line_rec;
		var cfound : boolean;
		var crec : cmddef_rec);

var
  flag : boolean;
  ncmd : integer;
  icmd : cmd_name;

begin
  cfound := false;
  icmd := succ(st_cmd_nms);	"start with first real command"
  repeat
    with inline do
      if (length >= defs[icmd].cmd_abb) and (length <= defs[icmd].cmd_sz)
      then
        begin
          flag := true;
          for ncmd := 1 to length do
	    if defs[icmd].command[ncmd] <> chars[ncmd]
	    then flag := false;
          if flag then
	    begin
	      cfound := true;
	      crec := defs[icmd]
	    end
	end;
      icmd := succ(icmd)
  until cfound or (icmd = end_cmd_nms)
end (* findcmd *);
!
(****************************   commanddefs   ***************************)
(*									*)
(*				findsub					*)
(*									*)
(*	this routine uses the input line string to search for		*)
(*	a sub command in the command record already found.		*)
(*									*)
(************************************************************************)

procedure entry findsub(inline : line_rec;
		crec : cmddef_rec;
		var kfound : boolean;
		var subrec : subdef_rec);

var
  flag : boolean;
  ncmd : integer;
  isub : sub_index;

begin
  with crec, inline do
    begin
      kfound := false;
      isub := 1;
      repeat
        with sub_defs[isub] do
	  if (length >= sub_abb) and (length <= sub_sz) then
	    begin
	      flag := true;
	      for ncmd := 1 to length do
		if sub_word[ncmd] <> chars[ncmd] then flag := false;
	      if flag then
	        begin
	          kfound := true;
	          subrec := sub_defs[isub]
	        end
             end;
        isub := isub + 1;
      until kfound or ( isub > num_sub )
    end
end (* findsub *);
!
(****************************   commanddefs   ***************************)
(*									*)
(*		initial routine - define commands			*)
(*									*)
(************************************************************************)

begin


(* define CONDENSE command *)

  with defs[ccondense] do
    begin
      command := 'CONDENSE  ';
      cmd_sz := 8;
      cmd_abb := 3;
      prg_name := ccondense;
      num_sub := 0
    end (* with *);


(* define COPY command *)

  with defs[ccopy] do
    begin
      command := 'COPY      ';
      cmd_sz := 4;
      cmd_abb := 3;
      prg_name := ccopy;
      num_sub := 0
    end (* with *);



(* define CREATE command *)

  with defs[ccreate] do
    begin
      command := 'CREATE    ';
      cmd_sz := 6;
      cmd_abb := 2;
      prg_name := ccreate;
      num_sub := 3;
      with sub_defs[1] do
	begin
	  sub_word := 'NODE    ';
	  sub_sz := 4;
	  sub_abb := 1;
	  sub_prg := snode
	end (* with *);
      with sub_defs[2] do
	begin
          sub_word := 'SLOT    ';
	  sub_sz := 4;
	  sub_abb := 1;
	  sub_prg := sslot
	end (* with *);
      with sub_defs[3] do
	begin
	  sub_word := 'PARTIAL ';
	  sub_sz := 7;
	  sub_abb := 1;
	  sub_prg := spart
	end (* with *)
    end (* with *);


(* define DELETE command *)

  with defs[cdelete] do
    begin
      command := 'DELETE    ';
      cmd_sz := 6;
      cmd_abb := 3;
      prg_name := cdelete;
      num_sub := 0
    end (* with *);


(* define DEVICE command *)

  with defs[cdevice] do
    begin
      command := 'DEVICE    ';
      cmd_sz := 6;
      cmd_abb := 3;
      prg_name := cdevice;
      num_sub := 0
    end (* with *);

(* define DIRECTORY command *)

  with defs[cdirectory] do
    begin
      command := 'DIRECTORY ';
      cmd_sz := 9;
      cmd_abb := 2;
      prg_name := cdirectory;
      num_sub := 0
    end (* with *);


(* define DUMP command *)

  with defs[cdump] do
    begin
      command := 'DUMP      ';
      cmd_sz := 4;
      cmd_abb := 2;
      prg_name := cdump;
      num_sub := 5;
      with sub_defs[1] do
	begin
	  sub_word := 'NODE    ';
	  sub_sz := 4;
	  sub_abb := 1;
	  sub_prg := snode
	end (* with *);
      with sub_defs[2] do
        begin
	  sub_word := 'SLOT    ';
	  sub_sz := 4;
	  sub_abb := 1;
	  sub_prg := sslot
	end (* with *);
      with sub_defs[3] do
        begin
	  sub_word := 'PARTIAL ';
	  sub_sz := 7;
	  sub_abb := 1;
	  sub_prg := spart
	end (* with *) ;
      with sub_defs[4] do
        begin
	  sub_word := 'MXP     ';
	  sub_sz := 3;
	  sub_abb := 1;
	  sub_prg := smxp
	end (* with *) ;
      with sub_defs[5] do
        begin
	  sub_word := 'TYMSTAR ';
	  sub_sz := 7;
	  sub_abb := 1;
	  sub_prg := stymstar
	end (* with *)
    end (* with *);


(* define FORMAT command *)

  with defs[cformat] do
    begin
      command := 'FORMAT    ';
      cmd_sz := 6;
      cmd_abb := 1;
      prg_name := cformat;
      num_sub := 0
    end (* with *);


(* define GATEWAY command *)

  with defs[cgateway] do
    begin
      command := 'GATEWAY   ';
      cmd_sz := 7;
      cmd_abb := 1;
      prg_name := cgateway;
      num_sub := 0
    end (* with *);


(* define HELP command *)

  with defs[chelp] do
    begin
      command := 'HELP      ';
      cmd_sz := 4;
      cmd_abb := 1;
      prg_name := chelp;
      num_sub := 0
    end (* with *);


(* define HOST command *)

  with defs[chost] do
    begin
      command   := 'HOST      ';
      cmd_sz    := 4;
      cmd_abb   := 2;
      prg_name  := chost;
      num_sub   := 0
    end (* with *);


(* define LOAD command *)

  with defs[cload] do
    begin
      command := 'LOAD      ';
      cmd_sz := 4;
      cmd_abb := 3;
      prg_name := cload;
      num_sub := 5;
      with sub_defs[1] do
	begin
	  sub_word := 'NODE    ';
	  sub_sz := 4;
	  sub_abb := 1;
	  sub_prg := snode
	end (* with *);
      with sub_defs[2] do
        begin
	  sub_word := 'SLOT    ';
	  sub_sz := 4;
	  sub_abb := 1;
	  sub_prg := sslot
	end (* with *);
      with sub_defs[3] do
        begin
	  sub_word := 'PARTIAL ';
	  sub_sz := 7;
	  sub_abb := 1;
	  sub_prg := spart
	end (* with *) ;
      with sub_defs[4] do
        begin
	  sub_word := 'MXP     ';
	  sub_sz := 3;
	  sub_abb := 1;
	  sub_prg := smxp
	end (* with *) ;
      with sub_defs[5] do
        begin
	  sub_word := 'TYMSTAR ';
	  sub_sz := 7;
	  sub_abb := 1;
	  sub_prg := stymstar
	end (* with *)
    end (* with *);


(* define LOCATE command *)

  with defs[clocate] do
    begin
      command := 'LOCATE    ';
      cmd_sz := 6;
      cmd_abb := 3;
      prg_name := clocate;
      num_sub := 0
    end (* with *);


(* define MESSAGE command *)

  with defs[cmessage] do
    begin
      command := 'MESSAGE   ';
      cmd_sz := 7;
      cmd_abb := 3;
      prg_name := cmessage;
      num_sub := 0
    end (* with *);


(* define QUIT command *)

  with defs[cquit] do
    begin
      command := 'QUIT      ';
      cmd_sz := 4;
      cmd_abb := 1;
      prg_name := cquit;
      num_sub := 0
    end (* with *);


(* define RENAME command *)

  with defs[crename] do
    begin
      command := 'RENAME    ';
      cmd_sz := 6;
      cmd_abb := 3;
      prg_name := crename;
      num_sub := 0
    end (* with *);


(* define RESTART command *)

  with defs[crestart] do
    begin
      command := 'RESTART   ';
      cmd_sz := 7;
      cmd_abb := 3;
      prg_name := crestart;
      num_sub := 0
    end (* with *);


(* define REWIND command *)

  with defs[crewind] do
    begin
      command := 'REWIND    ';
      cmd_sz := 6;
      cmd_abb := 3;
      prg_name := crewind;
      num_sub := 0
    end (* with *);


(* define SKIP command *)

  with defs[cskip] do
    begin
      command := 'SKIP      ';
      cmd_sz := 4;
      cmd_abb := 2;
      prg_name := cskip;
      num_sub := 0
    end (* with *);
end;
!
(*   CNFIGM.EBK Updated 7-Aug-85 at 17:41 by Paktor      *)
(*   ELF v 4.0, (ELF with Backup) Configuration Monitor  *)


Type Configuration_Monitor = Monitor ;

Var
  The_Host_Number : Host_Number ;
  Host_Position   : Host_Indicator ;
  Crasher         : Crash_Utility ;

    (*  ****************************************************************  *)

Procedure Init_Configuration_Monitor ;

Var
  Sys_Par         : System_Param ;
  Sys_Info        : System_Information ;

Begin


  Sys_Par.Operation := System_Info ;
  IO(Sys_Info, Sys_Par, System, 0) ;
  The_Host_Number  := Sys_Info.Host_Number ;

    (*  included only if not  elfbackup *)
  Host_Position := Host_First
    (*  end inclusion if not  elfbackup  *)
  End ;  (*  Init_Configuration_Monitor  *)

(**)
!
    (*   CNFIGM.EBK  *)

    (*  ****************************************************************  *)

Function Entry My_Host_Number : Host_Number ;
Begin
  My_Host_Number := The_Host_Number ;
  End ;  (*  My_Host_Number  *)

    (*  ****************************************************************  *)

Function Entry My_Host_Position : Host_Index ;
Begin
  My_Host_Position := Host_Position ;
  End ;  (*  My_Host_Position  *)

    (*  ****************************************************************  *)

Begin      (*   Formal Initialization of Configuration_Monitor  *)
  Init Crasher ;
  Init_Configuration_Monitor ;
  End ;    (*   Formal Initialization of Configuration_Monitor  *)

!
!
(*   MRKMON.EBK Updated 4-Jun-85 at 14:42 by Raffo    *)
(*   ELF v 4.0, (ELF with Backup) Mark Monitor *)

       (*       The Mark Monitor, which is replicated only once for   *)
       (*    the entire Engine, is called whenever a new File Mark    *)
       (*    or a new KnowLev Mark is required.  It examines the      *)
       (*    System Clock for the Time value of the Mark, but it      *)
       (*    must make sure that the same Mark will not be assigned   *)
       (*    more than once.                                          *)


Type
    Mark_Monitor        =        Monitor (My_Host_Position : Host_Index) ;

Var
  Last_Mark : Time_Element ;   (*  Internal copy of the Last Assigned Mark. *)

Procedure Entry Assign_Mark ( VAR File_Mark : File_Mark_Element ) ;

Var
  New_Mark :  Time_Element ;
                           (*  If the System Clock is less than or equal to  *)
                           (*   the Last Assigned Mark Time, then assign a   *)
                           (*   Mark Time which is incrementally larger      *)
                           (*   than the Last Assigned Mark.  Otherwise,     *)
                           (*   assign the Time shown by the System Clock.   *)

Begin
  File_Mark.Host := My_Host_Position ;

  New_Mark :=  RealTime ; (*  Call to the System Clock  *)

  If   Last_Mark >= New_Mark
    Then New_Mark := Last_Mark + 1;
  Last_Mark := New_Mark;

  File_Mark.Time := New_Mark;

End;

    (*  ****************************************************************  *)

(* Initialization  *)
Begin
    Last_Mark := 0;
End ;
!
      (*   DSKSYS.ELF Updated 5-Aug-85 at 16:46 by Paktor     *)
(************************************************************************)
(*                                                              	*)
(*                            disk_system                       	*)
(*                                                              	*)
(*	This class makes the actual io calls for disk access.		*)
(*                                                              	*)
(*    The following identifiers must be defined externally:     	*)
(*	disk_sector							*)
(*	disk_sector_address						*)
(*	sector_length							*)
(*      disk_block                                              	*)
(*      block_length                                            	*)
(*                                                              	*)
(************************************************************************)
(*                                                              	*)
(*                          Revision Record                     	*)
(*                                                              	*)
(*    29May85   Original (from dsksys.tms)  -- RER              	*)
(*                                                              	*)
(************************************************************************)


type disk_system = class

var
  unit			: disk_index;

  entry disk_parameter	: disk_tape_param;
!
			 (*   DSKSYS.ELF  *)

(***************************  disk_system  ******************************)
(*                                                              	*)
(*                            clear_block                       	*)
(*                                                              	*)
(*    Clears a data area equivalent to a multi-sector disk block.	*)
(*                                                              	*)
(************************************************************************)

procedure entry clear_block (
  var block : univ disk_block );

var
  i : block_index;

begin
  for i := BLOCK_LENGTH_FIRST to BLOCK_LENGTH_LIMIT do block[i] := chr(0)
end (* clear_block *) ;
!
			 (*   DSKSYS.ELF  *)

(***************************  disk_system  ******************************)
(*                                                              	*)
(*                             read_block                       	*)
(*                                                              	*)
(*    Reads a multi-sector block from disk.				*)
(*                                                              	*)
(************************************************************************)


procedure entry read_block(
      sector_address	: disk_sector_address;
  var data		: univ disk_block;
  var success		: boolean);

begin
  disk_parameter.operation := INPUT;
  disk_parameter.arg1      := sector_address;
  disk_parameter.arg2      := BLOCK_LENGTH;

  io(data, disk_parameter, DISK, unit);

  success := disk_parameter.status = COMPLETE
end (* read_block *) ;
!
			 (*   DSKSYS.ELF  *)

(***************************  disk_system  ******************************)
(*                                                              	*)
(*                            write_block                       	*)
(*                                                              	*)
(*    Writes a multi-sector block to disk.				*)
(*                                                              	*)
(************************************************************************)


procedure entry write_block(
      sector_address	: disk_sector_address;
  var data		: univ disk_block;
  var success		: boolean);

begin
  disk_parameter.operation := OUTPUT;
  disk_parameter.arg1      := sector_address;
  disk_parameter.arg2      := BLOCK_LENGTH;

  io(data, disk_parameter, DISK, unit);

  success := disk_parameter.status = COMPLETE
end (* write_block *) ;
!
			 (*   DSKSYS.ELF  *)

(***************************  disk_system  ******************************)
(*                                                              	*)
(*                            read_sector                       	*)
(*                                                              	*)
(*    Reads a sector buffer from disk.					*)
(*                                                              	*)
(************************************************************************)


procedure entry read_sector(
      sector_address	: disk_sector_address;
  var data		: univ disk_sector;
  var success		: boolean);

begin
  disk_parameter.operation := INPUT;
  disk_parameter.arg1      := sector_address;
  disk_parameter.arg2      := SECTOR_LENGTH;

  io(data, disk_parameter, DISK, unit);

  success := disk_parameter.status = COMPLETE
end (* read_sector *) ;
!
			 (*   DSKSYS.ELF  *)

(***************************  disk_system  ******************************)
(*                                                              	*)
(*                           write_sector                       	*)
(*                                                              	*)
(*    Writes a sector buffer to disk.					*)
(*                                                              	*)
(************************************************************************)



procedure entry write_sector(
      sector_address	: disk_sector_address;
  var data		: univ disk_sector;
  var success		: boolean);

begin
  disk_parameter.operation := OUTPUT;
  disk_parameter.arg1      := sector_address;
  disk_parameter.arg2      := SECTOR_LENGTH;

  io(data, disk_parameter, DISK, unit);

  success := disk_parameter.status = COMPLETE
end (* write_sector *) ;
!
			 (*   DSKSYS.ELF  *)

(***************************  disk_system  ******************************)
(*                                                              	*)
(*                         disk_information                     	*)
(*                                                              	*)
(*    Return disk information record.					*)
(*                                                              	*)
(************************************************************************)



procedure entry disk_information(
  var data		: disk_tape_information;
  var success		: boolean);

begin
  disk_parameter.operation := UNIT_INFO;

  io(data, disk_parameter, DISK, unit);

  success := disk_parameter.status = COMPLETE
end (* disk_information *) ;
!
			 (*   DSKSYS.ELF  *)

(***************************  disk_system  ******************************)
(*                                                              	*)
(*                         	set_unit	                     	*)
(*                                                              	*)
(*    Set the disk_index to be used for all following operation.	*)
(*                                                              	*)
(************************************************************************)



procedure entry set_unit (new_unit : disk_index);

begin
  unit := new_unit
end (* set_unit *) ;



(***************************  disk_system  ******************************)
(************************************************************************)



begin (* initial statement *)
end (* disk_system *) ;
!
(*   DSKMON.EBK Updated 8-Nov-85 at 17:21 by Paktor     *)
(*   ELF v 4.0, (ELF with Backup) Disk Monitor          *)

Type
  Disk_Monitor = Monitor ( Disk_Drive : Disk_Index ;
			   Mark_Mon   : Mark_Monitor ) ;


Type

(*   These are for the In-Memory Disk Directory.     *)

        In_Mem_Disk_Dir_Element =
			    Record
				File_Mark     : File_Mark_Element ;
				Start_Block,
				First_After   : Disk_Sector_Address ;
				Data_Guage    : File_Sector_Size ;
				Read_Users,          (* File_Usage_Index  *)
				Write_Users   : Char; (* File_Usage_Index  *)
				To_Be_Deleted : Boolean
			    End ;

In_Mem_Disk_Directory = Array [Disk_File_Indicator] of In_Mem_Disk_Dir_Element;

(**)
!
    (*   DSKMON.EBK   *)

Var
  Disk_Header       : Disk_Header_Record ;
  Directory         : In_Mem_Disk_Directory ;
  Disk_Sector_Limit_Address,
  Accum_to_be_Del_d,
  Accum_Used_Space  : Disk_Sector_Address ;
  File_User_Queue   : Array [ File_User_Index ] of Queue ;
  Next_File_User_Q  : FiFo ;
  Disk_Status       : Disk_Drive_Device_Status ;
  Disk_Event_Time   : Integer ;
  Disk_Information  : Disk_Tape_Information ;
  Condense_Index,
  Disk_File_Count   : Disk_File_Indicator ;
  Condense_Version  : Integer ;
  Condense_Queue    : Queue ;
  Condense_on_StartUp,
  Condense_in_Progress : Boolean ;
  First_Time_Conversion  : Boolean ;
  Condense_Requestors,
  File_Usage_Count  : File_Usage_Index ;
  Disk_Ops          : Disk_System ;
  Crasher           : Crash_Utility ;

(**)
!
    (*   DSKMON.EBK  *)

Procedure Disk_Event ( Disk_Event_Reason : Disk_Drive_Device_Status ) ;


Begin

  Disk_Status := Disk_Event_Reason ;
  Disk_Event_Time := Realtime
  End ;  (*  Disk_Event  *)

    (*  ****************************************************************  *)

Procedure Entry Disk_Event_Info ( VAR Event_Status : Disk_Drive_Device_Status ;
				  VAR Event_Time   : Integer 		   ) ;

Begin
  Event_Status := Disk_Status ;
  Event_Time   := Disk_Event_Time
  End  (*  Disk_Event_Info  *)  ;

(**)
!
  (*   DSKMON.EBK   *)

Procedure Update_File_Header( The_File      : Disk_File_Index ;
			    VAR File_Header : UNIV File_Header_Record ) ;

Begin
  With Directory[The_File]
    Do Begin
      File_Header.File_Mark    := File_Mark ;
      File_Header.Data_Guage   := Data_Guage ;
      File_Header.End_Sector   := First_After - 1
      End (* With *) ;

  File_Header.Slosh_Dest   := Disk_Sector_Address_Absent ;
  File_Header.Slosh_Length := Disk_Sector_Address_Absent ;
  File_Header.Slosh_End    := Disk_Sector_Address_Absent ;
End ;  (*  Update_File_Header  *)

  (*  ****************************************************************  *)

Procedure OutPut_Disk_Header (VAR OKay : Boolean )  ;



Begin
Disk_Ops.Write_Block(Disk_Header_Sector_Address, Disk_Header, OKay) ;
If Not OKay
  Then
    Disk_Event (Disk_Header_Write_Error) ;
End  (*  OutPut_Disk_Header  *)  ;

(**)
!
  (*   DSKMON.EBK  *)

Procedure Format_Disk_Header (VAR OKay : Boolean ) ;

      (*  Clear the Disk Directory of all Files.  *)
Var
  Per_File : Disk_File_Index ;

Begin
  Condense_Requestors := File_Not_in_Use ;

  Disk_Header.Sync := '(:170:)(:170:)(:170:)(:170:)' ;
  Disk_Header.Ver_Rev := Ver_Rev ;

  For Per_File :=  Disk_File_First to Disk_File_Limit Do
    Disk_Header.File_Address[Per_File] := Disk_Sector_Address_Absent ;

  Accum_Used_Space := One_Disk_Block  ;  (*  The Header Block  *)
  Disk_File_Count := Disk_File_Not_Found ;
  Condense_Index := Disk_File_First ;

  OutPut_Disk_Header (OKay) ;

  End ;  (*  Format_Disk_Header  *)

(**)
!
  (*   DSKMON.EBK   *)

Procedure InPut_Disk_Header ( VAR OKay : Boolean ) ;

Var
  Done         : Boolean ;
  Per_File     : Disk_File_Indicator ;
  Prev_Address : Disk_Sector_Address ;

Begin
  Disk_Ops.Read_Block(Disk_Header_Sector_Address, Disk_Header, OKay) ;

  If Not OKay
    Then Disk_Event (Disk_Header_Read_Error)

    Else Begin
      (*  Disk consistency check.  *)
      OKay := Disk_Header.Sync = '(:170:)(:170:)(:170:)(:170:)' ;
      If OKay
	Then Begin
	  First_Time_Conversion := Disk_Header.Ver_Rev <> Ver_Rev;
	  If First_Time_Conversion
	    Then Disk_Header.Ver_Rev := Ver_Rev ;

	  Prev_Address := Disk_Header_Sector_Address + One_Disk_Block - 1 ;
	  Per_File := Disk_File_First ;
	  Done := False 
	  End ;

      While OKay AND (Per_File <= Disk_File_Limit) AND (Not Done) Do
	If ( Disk_Header.File_Address[Per_File] = Disk_Sector_Address_Absent )
	Then Done := True
	Else Begin
	  OKay := (Abs(Prev_Address) < 
				  Abs(Disk_Header.File_Address[Per_File]))
		    AND ((Abs(Disk_Header.File_Address[Per_File])
						  Mod One_Disk_Block) = 0 )
		    AND (Abs(Disk_Header.File_Address[Per_File]) <
				  Disk_Sector_Limit_Address - One_Disk_Block) ;

	  Prev_Address := Disk_Header.File_Address[Per_File] ;
	  Per_File := Per_File + 1 
	  End ;

      If Not OKay
	Then Disk_Event (Disk_Header_Data_Error) 
      End 
  End  (*  InPut_Disk_Header  *)  ;

(**)
!
  (*   DSKMON.EBK   *)

Procedure Read_File_Header( VAR File_Header : File_Header_Record ;
			      Start_Address : Disk_Sector_Address ;
			      VAR OKay      : Boolean            ) ;

Begin
  Disk_Ops.Read_Block(Start_Address, File_Header, OKay) ;
  If Not OKay
    Then Disk_Event (Disk_File_Header_Read_Error)
    Else Begin
      OKay :=     (File_Header.Sync_1 = Sync)
	      AND (File_Header.Sync_2 = Sync)
	      AND (File_Header.Sync_3 = Sync) ;
      If Not OKay
	Then Disk_Event (Disk_File_Header_Data_Error) 
      End 
  End  (*  Read_File_Header  *) ;

  (*  ****************************************************************  *)

Procedure Write_File_Header( VAR File_Header : File_Header_Record ;
			      Start_Address  : Disk_Sector_Address ;
			      VAR OKay       : Boolean           ) ;

Begin
  Disk_Ops.Write_Block(Start_Address, File_Header, OKay) 
  End  (*  Write_File_Header  *) ;

(**)
!
  (*   DSKMON.EBK  *)

Procedure Init_In_Mem_Disk_Directory( VAR OKay : Boolean ) ;

Var
  Done        : Boolean ;
  File_Header : File_Header_Record ;
  Trickle,
  Per_File    : Disk_File_Indicator ;
  Any_File    : Disk_File_Index ;

Begin
  Accum_Used_Space := One_Disk_Block  (*  The Disk Header Block  *) ;
  Condense_Index   := Disk_File_First ;
  Disk_File_Count  := Disk_File_Not_Found ;

  (*  The "Disk_File_Not_Found'th" Directory entry  *)
  With Directory[Disk_File_Not_Found]
    Do Begin
      Start_Block    := Disk_Sector_Address_First ;
      First_After    := Disk_Sector_Address_First ;
      File_Mark.Host := 0 ;
      File_Mark.Time := 0 ;
      Data_Guage     := 0 ;
      Read_Users     := Chr(File_Not_in_Use) ;
      Write_Users    := Chr(File_Not_in_Use) ;
      To_Be_Deleted  := False ;
      End (* With *) ;

  OKay     := True ;
  Done     := False ;
  Per_File := Disk_File_First ;

  Input_Disk_Header (OKay) ;

		  (*   Continued on next page  *)

(**)
!
  (*  DSKMON.EBK  *)

                (*  Continuation of Init_In_Mem_Disk_Directory  *)

  While  OKay  AND  (Not Done)  AND  (Per_File <= Disk_File_Limit) 
    Do If ( Disk_Header.File_Address[Per_File] = Disk_Sector_Address_Absent )
      Then Done := True
      Else Begin   (*  For/While/If  Per_File  Loop *)
	If            (*  The File is tagged as not having been completed  *)
	   Disk_Header.File_Address[Per_File] < Disk_Sector_Address_Absent
	Then   (*  Nothing.  It will trickle down automatically  *)

	Else Begin  (*  a valid File Start Address  *)
	  Disk_File_Count := Disk_File_Count + 1 ;

	  With Directory[Disk_File_Count]
	    Do Begin
	      Start_Block := Disk_Header.File_Address[Per_File] ;
	      OKay := (Start_Block mod One_Disk_Block) = 0 ;
	      If OKay
		Then Read_File_Header (File_Header, Start_Block, OKay)
		Else Disk_Event (Disk_Header_Data_Error) ;
	      End (* With *) ;

	    (*  One-Time File Conversion   *)

	  If (((File_Header.File_Mark.Time + File_Header.File_Mark.Host) = 0 )
			    OR ( File_Header.File_Mark.Time < 0 )
			    OR ( File_Header.File_Mark.Time > Realtime + 600 )
			    OR ( File_Header.File_Mark.Host > Host_Limit))
			    AND OKay
	    Then If File_Header.Ver_Rev = Ver_Rev
	      Then Begin
		Disk_Event( Disk_File_Header_Data_Error) ;
		OKay := False
		End
	      Else With Directory[Disk_File_Count]
		Do Begin
		  Mark_Mon.Assign_Mark(File_Mark) ;
		  Data_Guage  := 0 ;
		  First_After := File_Header.End_Sector + 1 ;
		  Update_File_Header (Disk_File_Count, File_Header ) ;
		  Write_File_Header (File_Header, Start_Block, OKay ) ;
		  If Not OKay
		    Then Disk_Event (Disk_File_Header_Write_Error) 
		  End (* With *) ;

		(*   Continued on next page  *)

(**)
!
(*  DSKMON.EBK  *)

	      (*  Continuation of Init_In_Mem_Disk_Directory  *)

	If OKay
	  Then With Directory[Disk_File_Count]
	      Do Begin
		File_Mark     := File_Header.File_Mark  ;
		Data_Guage    := File_Header.Data_Guage ;
		First_After   := File_Header.End_Sector + 1 ;
		Read_Users    := Chr(File_Not_in_Use) ;
		Write_Users   := Chr(File_Not_in_Use) ;
		To_Be_Deleted := False ;
		End (* With *) ;

	If OKay
	  Then If File_Header.Slosh_Dest > Disk_Sector_Address_Absent
	    Then Begin
	      If Condense_on_StartUp  (*  There should be no more than     *)
				      (*  one file that was left in the    *)
				      (*  midst of sloshing, upon restart. *)
		Then Begin
		  Disk_Event( Disk_Duplicate_Condense_Error) ;
		  OKay := False
		  End 

		Else Begin
		  Condense_Index      := Per_File ;
		  Condense_Requestors := File_User_First ;
		  Condense_on_StartUp := True 
		  End
	      End ;

	If OKay
	  Then For Any_File := Disk_File_First to Disk_File_Count - 1
	     Do If Directory[Any_File].File_Mark = File_Header.File_Mark
			  (*   Neither should any File Marks be repeated   *)
	       Then Begin
		 Disk_Event( Disk_Duplicate_File_Mark_Error ) ;
		 OKay := False
		 End ;

	If OKay
	  Then Begin
	    Accum_Used_Space := Accum_Used_Space +
			    Directory[Disk_File_Count].First_After -
			      Disk_Header.File_Address[Disk_File_Count] ;

	    Disk_Header.File_Address[Disk_File_Count] :=
			    Disk_Header.File_Address[Per_File] 
	    End

	End (*  valid File Start Address  *) ;

      Per_File := Per_File + 1 ;
      End (*  For/While/If  Per_File  Loop *)  ;

		  (*   Continued on next page  *)

(**)
!
  (*   DSKMON.EBK  *)

                (*  Continuation of Init_In_Mem_Disk_Directory  *)
  If OKay
    Then Begin
      OKay := (Disk_File_Count >= Disk_File_Not_Found)
	      AND (Disk_File_Count <= Disk_File_Limit) ;
      If Not OKay
	Then Disk_Event( Disk_File_Index_Error) 	
      End ;

  If OKay
    Then Begin
      If Per_File > Disk_File_Count + 1
	Then For Trickle := Disk_File_Count+1 to Per_File-1
	  Do Disk_Header.File_Address[Trickle] := Disk_Sector_Address_Absent ;
      If (Per_File > Disk_File_Count + 1) OR First_Time_Conversion
	Then Output_Disk_Header(OKay)
      End 
  End  (*  Init_In_Mem_Disk_Directory  *) ;

(**)
!
    (*   DSKMON.EBK  *)

Procedure Reset_Disk_Monitor ;

Var
  OKay : Boolean ;

Begin

  Next_File_User_Q.Clear ;
  Accum_to_be_Del_d    := 0 ;
  Condense_Version     := 1 ;
  Condense_in_Progress := False ;
  Condense_on_StartUp  := False ;
  Condense_Requestors  := File_Not_in_Use ;
  File_Usage_Count     := File_Not_in_Use ;

  Disk_Ops.Set_Unit (Disk_Drive) ;
  Disk_Ops.Disk_Information(Disk_Information, OKay) ;

  If Not OKay
    Then Begin
      Disk_Event (Disk_Inoperative) ;
      End

    Else Begin
      Disk_Sector_Limit_Address := Disk_Information.Number_of_Sectors ;

      Init_In_Mem_Disk_Directory(OKay) ;

      If OKay
	Then Disk_Event (Disk_OKay) ;

      End ;
  End ;  (*  Reset_Disk_Monitor  *)

(**)
!
    (*   DSKMON.EBK   *)

Function Entry Disk_Size : Disk_Sector_Address ;
Begin
  Disk_Size := Disk_Sector_Limit_Address ;
  End  (*  Disk_Size  *)  ;

    (*  ****************************************************************  *)

Function Entry Disk_Space_Used : Disk_Sector_Address ;
Begin
  Disk_Space_Used := Accum_Used_Space ;
  End  (*  Disk_Space_Used  *)  ;

    (*  ****************************************************************  *)

Function Entry Disk_Start : Disk_Sector_Address ;
Begin
  Disk_Start := Disk_Information.Start_Cylinder 
				 * Disk_Information.Tracks_Per_Cylinder
				 * Disk_Information.Sectors_Per_Track ;
  End  (*  Disk_Start  *) ;

    (*  ****************************************************************  *)

Procedure Entry 
              Disk_Failure_Info ( VAR Event_Status : Disk_Drive_Device_Status ;
				  VAR Event_Time   : Integer                ) ;

Begin
  Event_Status := Disk_Status ;
  Event_Time   := Disk_Event_Time
  End  (*  Disk_Failure_Info  *) ;

    (*  ****************************************************************  *)

Procedure Entry Get_Disk_Info ( Var Disk_Info : Disk_Tape_Information ) ;
Begin
  Disk_Info := Disk_Information ;
  End ;  (*  Get_Disk_Info  *)


(**)
!
    (*   DSKMON.EBK  *)

Procedure Identify_Indexed_File ( File_Index : Disk_File_Index ;
                              VAR File_I_D   : File_Identifier  ) ;
                                
    (*  Given a File's Index, return its File_Mark and Size.   *)
    (*  Used by the Get_First_After Entry, which is called by  *)
    (*          the Getting-Into-the-Know task.                *)

Begin
  With Directory[File_Index]
    Do Begin
      File_I_D.File_Mark := File_Mark ;
      File_I_D.File_Size := First_After - Start_Block
      End (* With *)
  End ;  (*  Identify_Indexed_File  *)

  (*  ****************************************************************  *)

Procedure Entry Write_Disk_Header ;

Var
  OKay : Boolean ;

Begin
  OutPut_Disk_Header(OKay) ;
  End ;

  (*  ****************************************************************  *)

Procedure Condense_Delay ( Wait : Boolean ;
		    VAR Valid : Boolean ) ;

(*  Called by the Entries that must not act while a Condense is in Progress  *)

Begin
If Wait and Condense_in_Progress
  Then Delay ( File_User_Queue[ Next_File_User_Q.Arrival ] );
Valid := NOT Condense_in_Progress ;
End ;  (*  Condense_Delay  *)

  (*  ****************************************************************  *)

Procedure Entry IO_Status (var status : ioresult);

Begin
  status := Disk_Ops.disk_parameter.status
End ;  (*  IO_Status  *)

Function Entry Format : Boolean ;

Var
  OKay : Boolean ;

Begin
  If Disk_Status <> Disk_OKay
    Then Begin
      Format_Disk_Header(OKay) ;
      If OKay Then Reset_Disk_Monitor 
      End;
  Format := Disk_Status = Disk_OKay
  End ;  (*  Format  *)


(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Get_First_After ( From  : File_Mark_Element ;
			      VAR New   : File_Identifier ;
			      VAR Valid : Boolean         ) ;

    (*  Called by the Getting-Into-the-Know task.  *)

Var
  Per_File : Disk_File_Index ;

Begin
  New.File_Mark.Time := Max_Integer ;
  Valid := False ;

  For Per_File := Disk_File_First to Disk_File_Count
    Do With Directory[Per_File]
      Do If File_Mark.Host = From.Host
	  Then If File_Mark.Time > From.Time
	    Then If File_Mark.Time < New.File_Mark.Time
	      Then Begin
		Valid := True ;
		Identify_Indexed_File ( Per_File, New ) ;
		End ;
  End ;  (*  Get_First_After  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Find_File_Mark( File_Mark : File_Mark_Element ;
                      VAR The_File  : Disk_File_Indicator ) ;

    (*  Given a File's File Mark, retrieve the File's Directory Index.    *)
    (*  Used by the Entries called by the Dialogue Processes.             *)

Var
  Found_It : Boolean ;

Begin
  Found_It := False ;
  The_File := Disk_File_First - 1 ;

  If Disk_Status = Disk_OKay
    Then While (Not Found_It) AND (The_File < Disk_File_Count)
      Do Begin
	The_File := The_File + 1 ;
	Found_It := Directory[The_File].File_Mark = File_Mark ;
	End ;

  If NOT Found_It
    Then The_File := Disk_File_Not_Found ;

  End ;  (*  Find_File_Mark  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Find_File_Address ( Start_Address : Disk_Sector_Address ;
                              VAR The_File  : Disk_File_Indicator ) ;

    (*  Given a File's Start Address, retrieve the File's Index.  *)
    (*  Used by the Entries called by the User Process  *)

Var
  Found_It : Boolean ;

Begin
  Found_It := False ;
  The_File := Disk_File_First - 1 ;

  If Disk_Status = Disk_OKay
    Then While (Not Found_It) AND (The_File < Disk_File_Count)
      Do Begin
	The_File := The_File + 1 ;
	Found_It := Directory[The_File].Start_Block = Start_Address ;
	End ;

  If NOT Found_It
    Then The_File := Disk_File_Not_Found ;

  End ;  (*  Find_File_Address  *)


(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Start_Condense (VAR OKay : Boolean );

     (*  Used exclusively by the Condense Process.  *)

Begin

  If (File_Usage_Count > File_Not_in_Use)
                OR (Condense_Requestors = File_Not_in_Use)
    Then Delay ( Condense_Queue ) ;

  Condense_in_Progress := True ;
  OKay := Disk_Status = Disk_OKay
  End  (*  Start_Condense  *) ;

    (*  ****************************************************************  *)

Function Entry Finish_Condense : File_User_Size ;

Begin                    (*  Used solely by the Condense Process.  *)
  Finish_Condense := Next_File_User_Q.Length ;
  Condense_Requestors := File_Not_in_Use ;
  Condense_in_Progress := False ;
  Condense_Version := Condense_Version + 1 ;
  End ;  (*  Finish_Condense  *)

    (*  ****************************************************************  *)

Procedure Entry Continue_File_User ;
  (*  Wake up some-one waiting for Condense to be finished.  *)
  (*  Called in a loop by the Condense Process, until everyone is awakened.  *)
  (*  In case a new Condense is initiated during the loop, the new entries   *)
  (*     will not be awakened too soon...                                    *)

Begin
  If Not Next_File_User_Q.Empty
    Then Continue( File_User_Queue[ Next_File_User_Q.Departure ] );
  End ;  (*  File_User_Continued  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Condense_Next_File( VAR File_to_Slosh  : Boolean ;
                                    VAR Gap_Start      : Disk_Sector_Address ;
                                    VAR Header_Address : Disk_Sector_Address );

            (*  Used solely by the Condense Process.  *)
  (*  File_to_Slosh returns TRUE unless there are no more files to slosh,  *)
  (*                                 or the Condense has been terminated.  *)

Var
  Gap_Size : Disk_Sector_Address ;

Begin

  File_to_Slosh := (Condense_Requestors > File_Not_in_Use) 
                                  AND (Condense_Index <= Disk_File_Count) 
				  AND (Disk_Status = Disk_OKay) ;

  If NOT File_to_Slosh
    Then Condense_Index := Disk_File_First

    Else Begin
      Repeat  (*  Until File_to_Slosh OR (Condense_Index > Disk_File_Count)  *)

	Gap_Start := Directory[Condense_Index - 1 ].First_After ;

	With Directory[Condense_Index]
	  Do Begin
	    Header_Address := Start_Block ;
	    Gap_Size := Header_Address - Gap_Start ;

	    Start_Block := Gap_Start ;
	    First_After := First_After - Gap_Size ;
	    End (* With *) ;

	Disk_Header.File_Address[Condense_Index] :=
		   Disk_Header.File_Address[Condense_Index] - Gap_Size ;

	Condense_Index := Condense_Index + 1 ;

	File_to_Slosh := Condense_on_StartUp OR (Gap_Size > 0) ;

	Until File_to_Slosh OR (Condense_Index > Disk_File_Count) ;

      Condense_on_StartUp := False ;

      End ;
  End ;  (*  Condense_Next_File  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Request_Condense ( VAR Version : Integer ) ;

    (*  Instigate a Request for a Condense to happen.  *)

Begin
  Condense_Requestors := Condense_Requestors + 1 ;
  Version := Condense_Version ;
  If File_Usage_Count = File_Not_in_Use
    Then Continue ( Condense_Queue ) ;
  End;  (*  Request_Condense  *)

    (*  ****************************************************************  *)

Procedure Entry Await_Condense ( Version : Integer ) ;

    (*  Having requested a Condense, Delay until it is completed.  *)

Begin
  If Version = Condense_Version
    Then Delay ( File_User_Queue[ Next_File_User_Q.Arrival ] );

(*  If Version < Condense_Version                  *)
(*    Then the Condense already finished itself ;  *)
(*  If Version > Condense_Version                  *)
(*    Then Programming Error.  Spit ThumbTacks ;   *)

  End ;  (*  Await_Condense  *)


(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Terminate_Condense ( Version : Integer ) ;

    (*  Used by the User Process, after it has Requested a Condense.  *)

Begin
  If Version = Condense_Version
    Then Condense_Requestors := Condense_Requestors - 1 ;
  End ;  (*  Terminate_Condense  *)

    (*  ****************************************************************  *)

Function Entry Test_Condense ( Version : Integer ) : Boolean ;

    (*  Having requested a Condense, see if it is still not completed.  *)

Begin

  Test_Condense := (Version = Condense_Version) ;
    (*  True = Requested Condense is not yet finished.  *)
  End ;  (*  Test_Condense  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Delete_File ( File_Index : Disk_File_Index ) ;

Var
  File_Size : File_Sector_Size ;
  Per_File  : Disk_File_Index ;
  OKay      : Boolean ;

Begin
  With Directory[File_Index]
    Do File_Size := First_After - Start_Block ;

  Accum_to_be_Del_d := Accum_to_be_Del_d - File_Size ;
  Accum_Used_Space  := Accum_Used_Space  - File_Size ;

  For Per_File := File_Index to Disk_File_Count-1
    Do Begin
      Directory[Per_File] := Directory[Per_File+1] ;
      Disk_Header.File_Address[Per_File] := 
                                        Disk_Header.File_Address[Per_File+1] ;
      End ;

  Disk_Header.File_Address[ Disk_File_Count ] := Disk_Sector_Address_Absent ;
  Disk_File_Count  :=  Disk_File_Count - 1 ;
  OutPut_Disk_Header(OKay)
  End  (*  Delete_File  *) ;

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Mark_for_Deletion( File_Mark : File_Mark_Element ) ;

    (*  Called after Opening the File for Write, either way.    *)
    (*  Deletion will take place upon calling Finish_Writing.   *)

Var
  File_Index : Disk_File_Indicator ;
  File_Size  : File_Sector_Size ;

Begin

  Find_File_Mark( File_Mark, File_Index ) ;
  If File_Index <> Disk_File_Not_Found
    Then With Directory[File_Index]
      Do Begin
	If NOT To_Be_Deleted
	  Then Begin

	    File_Size := First_After - Start_Block ;
	    Accum_to_be_Del_d := Accum_to_be_Del_d + File_Size ;
	    To_Be_Deleted := True ;
	    End ;
	End (* With *) ;

  End ;  (*  Mark_for_Deletion  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Open_File ( The_File : Disk_File_Indicator ;
	     VAR Status        : File_Open_Status ;
	     VAR Start_Address : Disk_Sector_Address ;
	     VAR File_Size     : File_Sector_Size ;
	     VAR My_Data_Guage : File_Sector_Size ;
	     VAR User_Counter  : Char                ) ;

Begin
  If Disk_Status <> Disk_OKay
    Then Status := F_O_Disk_Failure

    Else Begin
      If The_File = Disk_File_Not_Found
	Then Status := File_Not_Found
	Else Begin   (*  Found the File  *)
	  With Directory[The_File]
	    Do Begin
	      If To_Be_Deleted
		Then Status := File_Being_Deleted
		Else Status := File_Opened_OKay ;

	      Start_Address := Start_Block ;
	      My_Data_Guage :=  Data_Guage ;
	      File_Size := First_After - Start_Block ;
	      End (* With *) ;
	  User_Counter := Chr(Ord(User_Counter) + 1) ;
	  File_Usage_Count := File_Usage_Count + 1 ;
	  End ;
      End ;
  End ;  (*  Open_File  *)

    (*  ****************************************************************  *)

Procedure Finish_File ( The_File : Disk_File_Indicator ;
               VAR User_Counter  : Char                 ) ;

Begin
  If The_File <> Disk_File_Not_Found
    Then Begin
      User_Counter := Chr(Ord(User_Counter) - 1) ;
      File_Usage_Count := File_Usage_Count - 1 ;

      With Directory[The_File]
	Do If To_Be_Deleted
	  Then If (Ord(Read_Users)  = File_Not_in_Use)  AND  
		  (Ord(Write_Users) = File_Not_in_Use)
	    Then Delete_File ( The_File ) 
      End
  End  (*  Finish_File  *) ;

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Open_Read ( File_Mark : File_Mark_Element ;
			 Wait         : Boolean ;
		    VAR Status        : File_Open_Status ;
		    VAR Start_Address : Disk_Sector_Address ;
		    VAR File_Size     : File_Sector_Size ;
		    VAR Data_Guage    : File_Sector_Size    ) ;

    (*  Called by the Dialogue Processes for Delete and Data Fill Send.  *)

Var
  The_File : Disk_File_Indicator ;
  Valid    : Boolean ;

Begin
  Condense_Delay (Wait, Valid) ;
  If Not Valid
    Then Status := Condensing

    Else Begin
      Find_File_Mark( File_Mark, The_File ) ;
      Open_File(The_File, Status, Start_Address, File_Size, Data_Guage,
                                            Directory[The_File].Read_Users ) ;
      End ;

  End ;  (*  Open_Read  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Open_User_Read ( Start_Address : Disk_Sector_Address ;
				VAR Status     : File_Open_Status ;
				VAR File_Size  : File_Sector_Size ;
				VAR File_Mark  : File_Mark_Element ;
				VAR Data_Guage : File_Sector_Size    ) ;

 (*  Called by the User Process for the Load, Copy, and Delete operations.  *)

Var
  The_File    : Disk_File_Indicator ;
  Valid       : Boolean ;
  Dummy_Start : Disk_Sector_Address ;

Begin
  Condense_Delay (No_Wait, Valid) ;
  If Not Valid
    Then Status := Condensing

    Else Begin
      Find_File_Address (Start_Address, The_File ) ;
      Open_File(The_File, Status, Dummy_Start, File_Size, Data_Guage,
					    Directory[The_File].Read_Users ) ;
      File_Mark := Directory[The_File].File_Mark ;
      End ;
  End ;    (*  Open_User_Read  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Open_User_Write ( Start_Address : Disk_Sector_Address ;
				 VAR Status     : File_Open_Status ;
				 VAR File_Size  : File_Sector_Size ;
				 VAR File_Mark  : File_Mark_Element ;
				 VAR Data_Guage : File_Sector_Size    ) ;

 (*  Called by the User Process for the Rename operation.  *)

Var
  The_File    : Disk_File_Indicator ;
  Valid       : Boolean ;
  Dummy_Start : Disk_Sector_Address ;

Begin
  Condense_Delay (No_Wait, Valid) ;
  If Not Valid
    Then Status := Condensing

    Else Begin
      Find_File_Address (Start_Address, The_File ) ;
      File_Mark := Directory[The_File].File_Mark ;
      If Ord(Directory[The_File].Write_Users) > File_Not_in_Use
        Then Status := File_In_Use
        Else Open_File(The_File, Status, Dummy_Start, File_Size, Data_Guage,
					    Directory[The_File].Write_Users ) 
      End 
  End  (*  Open_User_Write  *) ;

(**)
!
    (*   DSKMON.EBK   *)

Procedure Open_Dir_Read (Prev_File : Disk_File_Indicator ;
			VAR Status : File_Open_Status ;
		VAR Start_Address  : Disk_Sector_Address ;
		VAR File_Mark      : File_Mark_Element ;
		VAR File_Size      : File_Sector_Size ;
		VAR Data_Guage     : File_Sector_Size    ) ;

    (*  Open a File for the User Process Directory display routine.  *)

Var
  Valid     : Boolean ;
  The_File  : Disk_File_Indicator ;

Begin
  The_File := Prev_File + 1 ;

  If The_File > Disk_File_Count
    Then The_File := Disk_File_Not_Found 
    Else File_Mark :=  Directory[The_File].File_Mark ;

  Condense_Delay (No_Wait, Valid) ;
  If Not Valid
    Then Status := Condensing

    Else Open_File(The_File, Status, Start_Address, File_Size, Data_Guage,
					    Directory[The_File].Read_Users ) ;

  End ;   (*  Open_Dir_Read  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Open_Read_First_File (VAR Status : File_Open_Status ;
			      VAR Start_Address  : Disk_Sector_Address ;
			      VAR File_Mark      : File_Mark_Element ;
			      VAR File_Size      : File_Sector_Size ;
			      VAR Data_Guage     : File_Sector_Size    ) ;

(*  Called by the User Process Directory display routine.  *)

Begin
  Open_Dir_Read (Disk_File_First - 1, Status, Start_Address, File_Mark,
                                                      File_Size, Data_Guage) ;

  End ;  (*  Open_Read_First_File  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Open_Read_Next_File ( VAR Status : File_Open_Status ;
			      VAR Start_Address  : Disk_Sector_Address ;
			      VAR File_Mark      : File_Mark_Element ;
			      VAR File_Size      : File_Sector_Size ;
			      VAR Data_Guage     : File_Sector_Size    ) ;

(*  Called by the User Process Directory display routine.  *)

Var
  Valid      : Boolean ;
  The_File   : Disk_File_Indicator ;
  Same_File  : Disk_File_Indicator ;

Begin
  Find_File_Mark( File_Mark, The_File ) ;
  Finish_File(The_File, Directory[The_File].Read_Users ) ;
  Find_File_Mark( File_Mark, Same_File ) ;
  If The_File <> Same_File
    Then The_File := The_File - 1 ;

  Open_Dir_Read(The_File, Status, Start_Address, File_Mark, File_Size,
                                                                Data_Guage) ;
  If Status = File_Not_Found
    Then If (File_Usage_Count = File_Not_in_Use) AND
                                  (Condense_Requestors > File_Not_in_Use)
	  Then Continue ( Condense_Queue ) ;

  End ;  (*  Open_Read_Next_File  *)

    (*  ****************************************************************  *)

Procedure Entry Finish_Reading ( File_Mark : File_Mark_Element ) ;

Var
  The_File : Disk_File_Indicator ;

Begin
  Find_File_Mark( File_Mark, The_File ) ;
  Finish_File(The_File, Directory[The_File].Read_Users ) ;

  If (File_Usage_Count = File_Not_in_Use) AND
                                  (Condense_Requestors > File_Not_in_Use)
    Then Continue ( Condense_Queue ) ;

  End ;  (*  Finish_Reading  *)



(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Open_Write ( File_Mark : File_Mark_Element ;
		     VAR Status        : File_Open_Status ;
		     VAR Start_Address : Disk_Sector_Address ;
		     VAR File_Size     : File_Sector_Size ;
		     VAR Data_Guage    : File_Sector_Size  ) ;

    (*  Called by the Dialogue Data Fill Receiver Process, and by the    *)
    (*      Announcement Receiver Process, for Rename Announcements.     *)
    (*  User Process gets Write Access automatically in Alloc New File.  *)

Var
  Valid : Boolean ;
  The_File : Disk_File_Indicator ;

Begin
  Condense_Delay (WAIT_FOR, Valid) ;
  If Not Valid
    Then Status := Condensing

    Else Begin
      Find_File_Mark( File_Mark, The_File ) ;
      If Ord(Directory[The_File].Write_Users) > File_Not_in_Use
        Then Status := File_In_Use
        Else Open_File(The_File, Status, Start_Address, File_Size, Data_Guage,
                                          Directory[The_File].Write_Users ) ;

      End ;
  End ;  (*  Open_Write  *)


(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Finish_Writing ( File_Mark : File_Mark_Element ;
                                Data_Guage : File_Sector_Size   ) ;

Var
  OKay        : Boolean ;
  The_File    : Disk_File_Indicator ;
  File_Header : File_Header_Record ;

Begin
  Find_File_Mark( File_Mark, The_File ) ;

  If The_File <> Disk_File_Not_Found
    Then Begin
      If NOT Directory[The_File].To_Be_Deleted 
	Then Begin
	  Directory[The_File].Data_Guage := Data_Guage ;

	  Read_File_Header(File_Header, Directory[The_File].Start_Block, OKay);
	  If OKay
	    Then Begin
	      Update_File_Header(The_File, File_Header ) ;
	      Write_File_Header (File_Header, Directory[The_File].Start_Block,
									 OKay )
	      End ;
	  If OKay
	    Then Begin
	      Disk_Header.File_Address[The_File] :=
				    ABS(Disk_Header.File_Address[The_File]) ;
	      (*  De-Negate to indicate that the file is completely filled. *)
	      OutPut_Disk_Header(OKay)
	      End 
	  End ;

      Finish_File(The_File, Directory[The_File].Write_Users ) ;

      If (File_Usage_Count = File_Not_in_Use) AND
				      (Condense_Requestors > File_Not_in_Use)
	Then Continue ( Condense_Queue ) 
      End
  End   (*  Finish_Writing  *) ;

(**)
!
    (*   DSKMON.EBK  *)

Procedure Locate_Gap( File_Size : File_Sector_Size ;
		  VAR Gap_Index : Disk_File_Indicator ;
		  VAR Found_Gap : Boolean            ) ;

Var
  Gap_Start,
  Gap_Size,
  Gap_End : Disk_Sector_Address ;
Begin
  Gap_End := Disk_Sector_Limit_Address ;
  Gap_Index := Disk_File_Count + 1;

  Repeat  (*  Until Found_Gap OR Went through all File entries.*)
    Gap_Index := Gap_Index - 1 ;
    Gap_Start := Directory[Gap_Index].First_After ;
    Gap_Size := Gap_End - Gap_Start ;
    Found_Gap := ( Gap_Size >= File_Size ) ;
    Gap_End := Directory[Gap_Index].Start_Block ;
    Until Found_Gap OR (Gap_Index = Disk_File_Not_Found) ;
  Gap_Index := Gap_Index + 1 

  End   (*  Locate_Gap  *) ;
(**)
!
    (*   DSKMON.EBK  *)

Procedure Find_Gap ( File_Size : File_Sector_Size ;
                 VAR Gap_Index : Disk_File_Indicator ;
                 VAR Status    : Gap_Search_Status ) ;

Var
  Found_Gap   : Boolean ;
  Avail_Space : Disk_Sector_Address ;

Begin
  If Disk_Status <> Disk_OKay
    Then Status := F_A_Disk_Failure

    Else Begin
      If Disk_File_Count = Disk_File_Limit
	Then Status := Directory_Full

	Else Begin

	  Gap_Index := Disk_File_Not_Found ;
	  Avail_Space := Disk_Sector_Limit_Address - Accum_Used_Space ;

	  If File_Size > Avail_Space + Accum_to_be_Del_d
	    Then Status := No_Room

	    Else If File_Size > Avail_Space
	      Then Status := Needs_Delete

	      Else Begin
		Locate_Gap(File_Size, Gap_Index, Found_Gap) ;

		If Found_Gap
		  Then Status := Available
		  Else Status := Needs_Condense 
		End 
	  End 
      End 
  End  (*  Find_Gap  *) ;

(**)
!
    (*   DSKMON.EBK  *)

Procedure New_File_Header ( Gap_Index   : Disk_File_Index ;
			VAR File_Header : File_Header_Record ) ;

Begin
  Disk_Ops.Clear_Block(File_Header) ;

  File_Header.Sync_1  := Sync ;
  File_Header.Sync_2  := Sync ;
  File_Header.Sync_3  := Sync ;

  File_Header.File_Type := Chr(Empty_File) ;

  File_Header.Ver_Rev    := Ver_Rev ;

  File_Header.Start_Data_Sector := Directory[Gap_Index].Start_Block ;

  Update_File_Header(Gap_Index,File_Header) 

  End  (*  New_File_Header  *) ;

(**)
!
    (*   DSKMON.EBK  *)

Procedure Insert_File ( Gap_Index : Disk_File_Index ;
                             File : File_Identifier ;
			 VAR OKay : Boolean          ) ;

Var
  Per_File    : Disk_File_Index ;
  File_Header : File_Header_Record ;

Begin
  Accum_Used_Space := Accum_Used_Space + File.File_Size ;

  For Per_File := Disk_File_Count DownTo Gap_Index Do
    Begin
      Directory[Per_File + 1] := Directory[Per_File] ;
      Disk_Header.File_Address[Per_File + 1] :=
				       Disk_Header.File_Address[Per_File] 
      End ;

  With Directory[Gap_Index]
    Do Begin
      Start_Block   := Directory[Gap_Index-1].First_After ;
      File_Mark     := File.File_Mark  ;
      Data_Guage    := File.File_Size ;
      First_After   := Start_Block + File.File_Size ;
      Read_Users    := Chr(File_Not_in_Use) ;
      Write_Users   := Chr(File_Not_in_Use) ;
      To_Be_Deleted := False 
      End (* With *) ;

  Disk_File_Count := Disk_File_Count + 1 ;

  Disk_Header.File_Address[Gap_Index] := Directory[Gap_Index].Start_Block ;

  New_File_Header(Gap_Index,File_Header) ;

  Write_File_Header (File_Header, Directory[Gap_Index].Start_Block, OKay ) 

  End  (*  Insert_File  *) ;

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Allocate_New_File( File_Size : File_Sector_Size ; 
			       Wait          : Boolean ;
			       File_Mark     : File_Mark_Element ;
			   VAR Status        : File_Allocation_Status ;
			   VAR Start_Address : Disk_Sector_Address ) ;

    (*  Called by the User Process, by the Announcement Buffer Monitor,  *)
    (*                and by the Operator's Log Monitor.                 *)

Var
  File       : File_Identifier ;
  Gap_Index  : Disk_File_Indicator ;
  Data_Guage : File_Sector_Size ;
  F_O_Status : File_Open_Status ;
  Valid      : Boolean ;

Begin
  Condense_Delay (Wait, Valid) ;
  If Not Valid
    Then Status := Awaiting_Condense

    Else Begin
      (*  Check if the File already exists.  *)
      Find_File_Mark( File_Mark, Gap_Index ) ;
      If Gap_Index <> Disk_File_Not_Found
	Then Status := File_Already_Exists

	Else Begin
	  Find_Gap( File_Size, Gap_Index, Status ) ;

	  If Status = Available
	    Then Begin
	      File.File_Size := File_Size ;
	      File.File_Mark := File_Mark ;
	      Insert_File(Gap_Index, File, Valid) ;
	      If Not Valid
		Then Status := F_A_Disk_Failure 

		Else Begin
		  Disk_Header.File_Address[Gap_Index]
				     := - Disk_Header.File_Address[Gap_Index];

	      (*  Negative Address on Disk Header indicates that the file    *)
	      (*  has not had its File Mark assigned.  That will only happen *)
	      (*  after the initial creation of the File, along with its     *)
	      (*  initial Data filling, has been completed.  If the Engine   *)
	      (*  Crashes before the User Process has completely filled the  *)
	      (*  File, the file will be eliminated during initialization.   *)

		  OutPut_Disk_Header(Valid) ;
		  If Not Valid
		    Then Status := F_A_Disk_Failure 

		    Else Begin
		      (*  Claim this newly-Allocated file for Writing  *)
		      Open_File(Gap_Index, F_O_Status, Start_Address,
						File.File_Size, Data_Guage,
					Directory[Gap_Index].Write_Users ) ;
		      If F_O_Status = File_Opened_OKay
			Then Status := F_A_Complete 
			Else Status := F_A_Disk_Failure 
		      End
		  End
	      End 
	  End 
      End 
  End ;  (*  Allocate_New_File  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Adjust_File_ID ( Old_File_Mark : File_Mark_Element ;
                            Adjusted_File_Size : File_Sector_Size ;
			    New_File_Mark      : File_Mark_Element  ) ;

    (*  Called by User Process, after finishing CREATE, upon finding the  *)
    (*  file smaller than originally expected, due to Data Compression.   *)

Var
  The_File    : Disk_File_Indicator ;
  File_Header : File_Header_Record ;
  Adjustment  : Integer ;

Begin
  Find_File_Mark( Old_File_Mark, The_File ) ;
  If The_File <> Disk_File_Not_Found
    Then With Directory[The_File]
	Do Begin
	  Adjustment       := Adjusted_File_Size - (First_After - Start_Block);
	  Accum_Used_Space := Accum_Used_Space + Adjustment ;
	  First_After      := First_After + Adjustment ;
	  Data_Guage       := Data_Guage  + Adjustment ;
	  File_Mark        := New_File_Mark ;

      End (* With *)
  End ;  (*  Adjust_File_I_D  *)

(**)
!
    (*   DSKMON.EBK  *)

Procedure Entry Update_Data_Guage ( File_Mark : File_Mark_Element ;
			       New_Data_Guage : File_Sector_Size ) ;

Var
  The_File    : Disk_File_Indicator ;

Begin
  Find_File_Mark( File_Mark, The_File ) ;
  If The_File <> Disk_File_Not_Found
    Then Directory[The_File].Data_Guage := New_Data_Guage
  End (*  Update_Data_Guage  *) ;

(**)
!
    (*   DSKMON.EBK  *) 

Procedure Entry Adjust_File_Header ( File_Mark  : File_Mark_Element ;
                                VAR File_Header : UNIV File_Header_Record ) ;

Var
  The_File    : Disk_File_Index ;

Begin

  Find_File_Mark( File_Mark, The_File ) ;
  If The_File <> Disk_File_Not_Found
    Then Update_File_Header(The_File, File_Header ) 
  End ;      (*  Adjust_File_Header   *)

    (*  ****************************************************************  *)

(*  Formal Disk Monitor Initialization  *)
Begin
  Init Disk_Ops;
  Init Next_File_User_Q(File_User_Limit) ;
  Init Crasher ;
  Disk_Status := Disk_Inoperative ;
  Reset_Disk_Monitor
  End ;

    (*  ****************************************************************  *)
    (*  ****************************************************************  *)

Type Disk_Monitor_Array =  Array [Disk_Index] of Disk_Monitor ;
!
(************************************************************************)
(*									*)
(*	DSKUTL.ELF Updated 25-Jun-87 at 12:50 by Raffo			*)
(*									*)
(*			    disk_utility				*)
(*									*)
(*	This class provides commmon usage calls to the disk monitor.	*)
(*	It implements how the disk_monitor was intented to be used.	*)
(*	It maintains the data guage while the file is open, and updates	*)
(*	its value for finish_writing based on the the highest sector	*)
(*	written. It calls the correct finish entry in the disk_monitor	*)
(*	when the file is closed. It generates the correct disk address	*)
(*	from the file start address and the address of the block or	*)
(*	sector within the file.						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	31May85	Original -- RER						*)
(*								
(************************************************************************)



type
  disk_utility =
    class (
      disk_mon	: disk_monitor_array);
(**)
!
			 (*   DSKUTL.ELF  *)

type
  file_use_state   = (NOT_OPENED, READING, WRITING);
  file_usage_state = READING .. WRITING ;

var
  disk_access		: disk_system;
  crash_operator	: crash_utility;

  entry status		: file_open_status;
  entry file_size	: file_sector_size;
  entry data_guage	: file_sector_index;
  entry start_address	: disk_sector_address ;
  entry file_mark	: file_mark_element;
  entry disk_parameter	: disk_tape_param;
  entry disk_status     : disk_drive_device_status;
  entry disk_event_time : integer;
  entry opened		: boolean;
  entry fault		: header_data_result;

  state			: file_use_state;
  unit			: disk_index;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			      close_file				*)
(*									*)
(*	Finish reading or writing from file. If file is being written,	*)
(*	update the date guage.						*)
(*									*)
(************************************************************************)

procedure close_file;

begin
  case state of
    NOT_OPENED:
      (* nothing to do *) ;

    READING:
      disk_mon[unit].finish_reading (file_mark);

    WRITING:
      disk_mon[unit].finish_writing (file_mark, data_guage)
  end (* case *) ;

  disk_mon[unit].disk_event_info(disk_status, disk_event_time);

  opened := FALSE;
  state  := NOT_OPENED
end (* close_file *) ;
(**)
!
			 (*   DSKUTL.ELF  *)


(**************************  disk_utility  ******************************)
(*									*)
(*			     file_header_error				*)
(*									*)
(*	Report an error involving reading or checking a file's header. 	*)
(*									*)
(************************************************************************)

procedure file_header_error;

begin
  status := F_O_FILE_HEADER_ERROR;
  disk_status := DISK_FILE_HEADER_DATA_ERROR;
  disk_parameter.status := DISK_FILE_HEADER_ERROR
end (* file_header_error *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			       io_check					*)
(*									*)
(*	Check that address read is within file or that address written	*)
(*	is either within file or immediately after end of data and	*)
(*	within file. Also check that operation is valid for file state.	*)
(*									*)
(************************************************************************)

procedure io_check (
  offset	: file_sector_address	(* Sector offset within file *) ;
  size		: file_sector_size	(* Size of operation *) ;
  state_needed	: file_usage_state);

begin
  if (offset mod size ) <> 0	(* Check that operation on proper boundry *)
  then crash_operator.signal_process_error;

  if state <> state_needed	(* Check that file is properly open *)
  then
    case state_needed of
      WRITING: crash_operator.signal_process_error;

      READING:                    (*  May read from file opened for writing *)
	if state <> WRITING
	then crash_operator.signal_process_error
    end (* case *) ;

  if offset < 0		(* Check that operation is within allocation *)
  then crash_operator.signal_process_error;

  if offset >= file_size
  then crash_operator.signal_process_error;

  if offset > 0
  then
    case state_needed of	(* Check that operation is within data *)
      READING:
	if data_guage > (file_size - (offset + size))
	then crash_operator.signal_process_error;

      WRITING:
	if data_guage  > (file_size - offset )
	then crash_operator.signal_process_error
    end (* case *)
end (* io_check *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			    check_file_header				*)
(*									*)
(*	Verify data correctness for a file header, 			*)
(*	as far as is possible to do so.					*)
(*									*)
(************************************************************************)


procedure check_file_header (
      file_header : univ file_header_record ;
  var okay        : boolean ) ;

begin
  fault := HEADER_START;
  okay :=     (file_header.sync_1 = sync)
          AND (file_header.sync_2 = sync)
	  AND (file_header.sync_3 = sync);
  if not okay
  then fault := HEADER_SYNC
  else
    begin
      okay := (file_header.data_guage >= 0)
	  AND (file_header.data_guage <= file_size);
      if not okay
      then fault := HEADER_GUAGE
      else
	begin
          okay := (file_header.file_mark.time >= 0)
	    AND (file_header.file_mark.time <= (realtime + 600));
			(*  The 600 is to allow for file marks that have   *)
			(*	just been created and are slightly ahead   *)
			(*	of the present time.  The proper solution  *)
			(*	would be to make Mark Monitor accessible   *)
			(*	to this class, and to use it here.	   *)
          if not okay
          then fault := HEADER_TIME
          else
            okay := (file_header.start_data_sector >= start_address)
	      AND ((file_header.start_data_sector mod ONE_DISK_BLOCK) = 0)
	      AND (((file_header.end_sector + 1 ) mod ONE_DISK_BLOCK) = 0)
	      AND (file_header.end_sector > file_header.start_data_sector) ;
	end
    end;
  if not okay 
  then file_header_error
  else fault := HEADER_OKAY
end (* check_file_header *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			      read_sector				*)
(*									*)
(*	Read a single sector from the currently opened file. Crash	*)
(*	if read beyond the data.					*)
(*									*)
(************************************************************************)

procedure entry read_sector (
      sector	: file_sector_address;
  var data	: univ disk_sector;
  var ok	: boolean);

begin
  io_check (sector, 1, READING);

  if sector < FILE_SECTOR_FIRST    (* file header must be read as a block  *)
  then crash_operator.signal_process_error;

  disk_access.read_sector (start_address + sector, data, ok);
  disk_parameter := disk_access.disk_parameter
end (* read_sector *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			     write_sector				*)
(*									*)
(*	Write a sector relative to beginning of the currently open	*)
(*	file. Update the data guage as needed. Crash if write attempted	*)
(*	past the end of the data.					*)
(*									*)
(************************************************************************)

procedure entry write_sector (
      sector	: file_sector_address;
  var data	: univ disk_sector;
  var ok	: boolean);

var
  new_data_guage : file_sector_index;

begin
  io_check (sector, 1, WRITING);

  if sector < FILE_SECTOR_FIRST    (* file header must be written as a block *)
  then crash_operator.signal_process_error;

  disk_access.write_sector (start_address + sector, data, ok);
  disk_parameter := disk_access.disk_parameter;

  new_data_guage := file_size - (sector + 1);
  if ok
  then
    if data_guage > new_data_guage
    then
      begin
        data_guage := new_data_guage;
	disk_mon[unit].update_data_guage (file_mark, data_guage)
      end
end (* write_sector *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			     clear_block				*)
(*									*)
(*	Clear a disk block sized data area.				*)
(*									*)
(************************************************************************)

procedure entry clear_block (
  var data : univ disk_block );

begin
  disk_access.clear_block (data)
end (* clear_block *) ;



(**************************  disk_utility  ******************************)
(*									*)
(*			      read_block				*)
(*									*)
(*	Read a block from the currently opened file. Crash		*)
(*	if read beyond the data.  Offset is given in sectors		*)
(*	from the start of the file.					*)
(*									*)
(************************************************************************)

procedure entry read_block (
      offset    : file_sector_address ;
  var data	: univ disk_block;
  var ok	: boolean);

begin
  io_check (offset, ONE_DISK_BLOCK, READING);

  disk_access.read_block (start_address + offset, data, ok);
  disk_parameter := disk_access.disk_parameter;

  if ok and (offset = FILE_HEADER_BLOCK)
  then check_file_header (data, ok)
end (* read_block *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			     write_block				*)
(*									*)
(*	Write a block relative to beginning of the currently opened	*)
(*	file.  Update the data guage as needed.  Crash if disk write    *)
(*      is attempted beyond the end of the data.			*)
(*	Offset is given in sectors from the start of the file.		*)
(*									*)
(************************************************************************)

procedure entry write_block (
      offset    : file_sector_address ;
  var data	: univ disk_block;
  var ok	: boolean);

var
  new_data_guage : file_sector_size;

begin
  io_check (offset, ONE_DISK_BLOCK, WRITING);

  if offset = FILE_HEADER_BLOCK
  then
    begin
      disk_mon[unit].adjust_file_header (file_mark, data);
      check_file_header (data, ok)
    end
  else ok := TRUE;

  if ok 
  then
    begin 
      disk_access.write_block (start_address + offset, data, ok);
      disk_parameter := disk_access.disk_parameter
    end;

  new_data_guage := file_size - (offset + ONE_DISK_BLOCK);
  if ok
  then
    if data_guage > new_data_guage
    then
      begin
        data_guage := new_data_guage;
	disk_mon[unit].update_data_guage (file_mark, data_guage)
      end
end (* write_block *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			        create					*)
(*									*)
(*	Create a new file with the given file mark and file size.	*)
(*									*)
(************************************************************************)


procedure entry create (
      new_mark		: file_mark_element;
      new_size		: file_sector_size;
      await_condense	: boolean;
  var create_status	: file_allocation_status);

begin
  disk_mon[unit].allocate_new_file (
    new_size, await_condense, new_mark, create_status, start_address);

  if create_status = F_A_COMPLETE
  then
    begin
      opened	 := TRUE;
      state	 := WRITING;
      file_mark	 := new_mark;
      status	 := FILE_OPENED_OKAY;
      file_size	 := new_size;
      data_guage := new_size
    end;
  disk_mon[unit].disk_event_info (disk_status, disk_event_time)
end (* create *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			    adjust_file_id				*)
(*									*)
(*	Change the file size. Used by user process to trim off excess	*)
(*	file blocks which were allocated and not used. Also, set a new	*)
(*	file mark. Used to set the final file mark.			*)
(*									*)
(************************************************************************)


procedure entry adjust_file_id (
      new_size		: file_sector_size;
      new_mark		: file_mark_element );

begin
  if new_size > file_size
  then crash_operator.signal_process_error;

  data_guage := data_guage - (file_size - new_size);
  file_size  := new_size;

  if data_guage < 0
  then crash_operator.signal_process_error;

  with disk_mon[unit] do
    begin
     adjust_file_id(file_mark, new_size, new_mark);
     disk_event_info (disk_status, disk_event_time)
   end (* with *) ;

  file_mark := new_mark
end (* adjust_file_id *) ;


(**************************  disk_utility  ******************************)
(*									*)
(*			     verify_file_header				*)
(*									*)
(*	Force a read and check of a newly-opened file's header. 	*)
(*									*)
(************************************************************************)


procedure verify_file_header ;

var
  file_header : file_header_record ;
  ok          : boolean ;

begin
  disk_access.read_block (start_address + FILE_HEADER_BLOCK, file_header, ok);
  if ok
  then check_file_header (file_header, ok)
  else file_header_error
end (* verify_file_header *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			    open_for_reading				*)
(*									*)
(*	Open the file with the given file mark for reading. Set the	*)
(*	entry variables file_size, status and data_guage.		*)
(*									*)
(************************************************************************)

procedure entry open_for_reading (
      open_mark		: file_mark_element);

begin
  if opened
  then crash_operator.signal_process_error;

  file_mark := open_mark;

  disk_mon[unit].open_read (
    file_mark, WAIT_FOR, status, start_address, file_size, data_guage);

  if (status = FILE_OPENED_OKAY) or (status = FILE_BEING_DELETED)
  then
    begin
      state  := READING;
      opened := TRUE;
      verify_file_header
    end;

  disk_mon[unit].disk_event_info(disk_status, disk_event_time)
end (* open_for_reading *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			    header_data_fault				*)
(*									*)
(************************************************************************)

procedure entry header_data_fault (
  var last_fault	: header_data_result);

begin
  last_fault := fault
end (* header_data_fault *);
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			    open_user_read				*)
(*									*)
(*	Open the file with the given start address for reading.		*)
(*	Set the entry variables file_size, status and			*)
(*	data_guage.							*)
(*									*)
(************************************************************************)

procedure entry open_user_read (
      open_address	: disk_sector_address);

begin
  if opened
  then crash_operator.signal_process_error;

  start_address := open_address;

  disk_mon[unit].open_user_read (
    start_address, status, file_size, file_mark, data_guage);

  if status = FILE_BEING_DELETED
  then
    begin
      disk_mon[unit].finish_reading (file_mark);
      status := FILE_NOT_FOUND
    end;

  if status = FILE_OPENED_OKAY
  then
    begin
      opened := TRUE;
      state  := READING;
      verify_file_header
    end;

  disk_mon[unit].disk_event_info(disk_status, disk_event_time)
end (* open_user_read *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			    open_user_write				*)
(*									*)
(*	Open the file with the given start address for writing		*)
(*	Set the entry variables file_size, status and			*)
(*	data_guage.							*)
(*									*)
(************************************************************************)

procedure entry open_user_write (
      open_address	: disk_sector_address);

begin
  if opened
  then crash_operator.signal_process_error;

  start_address := open_address;

  disk_mon[unit].open_user_write (
    start_address, status, file_size, file_mark, data_guage);

  if status = FILE_BEING_DELETED
  then
    begin
      disk_mon[unit].finish_writing (file_mark, data_guage);
      status := FILE_NOT_FOUND
    end;

  if status = FILE_OPENED_OKAY
  then
    begin
      opened := TRUE;
      state  := WRITING;
      verify_file_header
    end;

  disk_mon[unit].disk_event_info(disk_status, disk_event_time)
end (* open_user_write *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			 open_read_first_file				*)
(*									*)
(*	Open the first file in the directory for reading. Set the	*)
(*	entry variables file_size, status and data_guage.		*)
(*									*)
(************************************************************************)

procedure entry open_read_first_file;

begin
  if opened
  then crash_operator.signal_process_error;

  disk_mon[unit].open_read_first_file (
    status, start_address, file_mark, file_size, data_guage);

  if (status = FILE_OPENED_OKAY) or (status = FILE_BEING_DELETED)
  then
    begin
      opened := TRUE;
      state  := READING;
      verify_file_header
    end;

  disk_mon[unit].disk_event_info (disk_status, disk_event_time)
end (* open_read_first_file *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			 open_read_next_file				*)
(*									*)
(*	Open the next file in the directory for reading. Set the	*)
(*	entry variables file_size, status and data_guage.		*)
(*									*)
(************************************************************************)

procedure entry open_read_next_file;

begin
  if not opened
  then crash_operator.signal_process_error;

  disk_mon[unit].open_read_next_file (
    status, start_address, file_mark, file_size, data_guage);

  if (status = FILE_OPENED_OKAY) or (status = FILE_BEING_DELETED)
  then verify_file_header
  else
    begin
      opened := FALSE;
      state  := NOT_OPENED
    end;

  disk_mon[unit].disk_event_info(disk_status, disk_event_time)
end (* open_read_next_file *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			    open_for_writing				*)
(*									*)
(*	Open the file with the given file mark for writing by either	*)
(*	the User Process for initial file creation, the Announcement	*)
(*	Receiver Process, or the Data-Filling Process.  Set the entry	*)
(*	variables file_size, status, data_guage and opened.  If the	*)
(*	file is in use, it must be by Data Fill.  Inform the calling	*)
(*	process, which will wait a while and try again. 		*)
(*									*)
(************************************************************************)

procedure entry open_for_writing (
      open_mark		: file_mark_element);

begin
  if opened
  then crash_operator.signal_process_error;

  file_mark := open_mark;

  disk_mon[unit].open_write (
      file_mark, status, start_address, file_size, data_guage);

  if (status = FILE_OPENED_OKAY) or (status = FILE_BEING_DELETED)
  then
    begin
      opened := TRUE;
      state  := WRITING;
      verify_file_header
    end;

  disk_mon[unit].disk_event_info(disk_status, disk_event_time)
end (* open_for_writing *) ;

(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			        close					*)
(*									*)
(*	Finish reading or writing from file. If file is being written,	*)
(*	update the date guage.						*)
(*									*)
(************************************************************************)

procedure entry close;

begin
  close_file
end (* close *) ;



(**************************  disk_utility  ******************************)
(*									*)
(*			   cancel_creation				*)
(*									*)
(*	Delete the file open for writing. The delete will occur when	*)
(*	the file is closed.						*)
(*									*)
(************************************************************************)

procedure entry cancel_creation;

begin
  if state <> WRITING
  then crash_operator.signal_process_error;

  with disk_mon[unit] do
    begin
      mark_for_deletion (file_mark);
      finish_writing (file_mark, data_guage);
      disk_event_info(disk_status, disk_event_time)
    end (* with *) ;

  opened := FALSE;
  state  := NOT_OPENED
end (* cancel_creation *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			   delete_open_file				*)
(*									*)
(*	Delete the file open for writing. The delete will occur when	*)
(*	the file is closed.						*)
(*									*)
(************************************************************************)

procedure entry delete_open_file;

begin
  if not opened
  then crash_operator.signal_process_error;

  with disk_mon[unit] do
    begin
      mark_for_deletion (file_mark);
      disk_event_info (disk_status, disk_event_time) 
    end (* with *)
end (* delete_open_file *) ;
(**)
!
			 (*   DSKUTL.ELF  *)

(**************************  disk_utility  ******************************)
(*									*)
(*			       set_unit					*)
(*									*)
(*	Set the disk unit to be used for all following operations,	*)
(*	until changed.							*)
(*									*)
(************************************************************************)

procedure entry set_unit (
  new_unit : disk_index);

begin
  if opened
  then crash_operator.signal_process_error;

  unit := new_unit;
  disk_access.set_unit (unit);
  disk_mon[unit].disk_event_info (disk_status, disk_event_time)
end (* set_unit *) ;


(****************************  disk_utility  ****************************)
(************************************************************************)

begin (* initial statement *) 
  init disk_access, crash_operator;
  opened := FALSE;
  state  := NOT_OPENED
end (* disk_utility *) ;
!
      (*   OPLOG.ELF  Updated 9-Sep-85 at 14:06 by Raffo      *)
(************************************************************************)
(*									*)
(*									*)
(*				operator_log				*)
(*									*)
(*	This monitor maintains the operator log file.  Entries are be	*)
(*	written to the file in a sequential order, writing over old	*)
(*	records when necessary.  Records may be read either in a one	*)
(*	time mode or according to a time specified.			*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	29May85	Original (from OPLOG.TMS) -- RER			*)
(*									*)
(************************************************************************)


(*	Definition of data in each oper_log message *)

const
  filler_size = sector_length - 3 * integer_length - message_buffer_text_max;

type
  oper_log_entry  =
    record
      sequence  : integer;
      time	: integer;
      message	: message_buffer;
      filler	: array [1..filler_size] of char
    end (* oper_log_entry *) ;
!
			 (*   OPLOG.ELF   *)

type
  operator_log =
    monitor(
      disk_mon	: disk_monitor_array);
!
			 (*   OPLOG.ELF   *)

(*	Definitions of the operator's log file. The file consists of	*)
(*	a one block file header, followed by OPER_LOG_SECTOR_MAX 	*)
(*	sectors of messages.						*)

const
  oper_log_message_max   = 100;
  oper_log_message_limit = oper_log_message_max - 1;

type
  oper_log_message_index = 0..oper_log_message_limit;

const
  oper_log_sector_max =
    ((oper_log_message_limit + one_disk_block) div
					    one_disk_block) * one_disk_block ;
  oper_log_file_size = one_disk_block + oper_log_sector_max ;
!
			 (*   OPLOG.ELF   *)

var
  disk_operator		: disk_utility;
  crash_operator	: crash_utility;
  file_mark		: file_mark_element;
  next_write_sequence	: integer (* sequence number of next write *) ;
  first_new_message	: integer (* sequence of first message written *) ;
  user_sequence		: array [user_index] of integer;
!
			 (*   OPLOG.ELF   *)

(***************************  operator_log  *****************************)
(*									*)
(*			      read_message				*)
(*									*)
(*	Read a message from operator log.				*)
(*									*)
(************************************************************************)

procedure read_message (
      i		: oper_log_message_index;
  var buffer	: oper_log_entry);

var
  ok : boolean;

begin
  disk_operator.read_sector (ONE_DISK_BLOCK + i, buffer, ok);
  if not ok
  then buffer.message.size := 0 ;
end (* read_message *) ;



(***************************  operator_log  *****************************)
(*									*)
(*			      write_message				*)
(*									*)
(*	Write a message to operator log.				*)
(*									*)
(************************************************************************)

procedure write_message (
      i		: oper_log_message_index;
  var buffer	: oper_log_entry);

var
  ok : boolean;

begin
  disk_operator.write_sector (ONE_DISK_BLOCK + i, buffer, ok)
end (* write_message *) ;
!
			 (*   OPLOG.ELF   *)

(***************************  operator_log  *****************************)
(*									*)
(*			 check_for_valid_open				*)
(*									*)
(*	Check that file opened okay, and that the size is correct and	*)
(*	that the file is full.						*)
(*									*)
(************************************************************************)

procedure check_for_valid_open ( VAR ok : boolean);

begin
  ok := disk_operator.status = FILE_OPENED_OKAY;

  if ok and (disk_operator.file_size <> OPER_LOG_FILE_SIZE)
  then crash_operator.signal_process_error (* crash this process *)
end (* check_for_valid_open *) ;
!
			 (*   OPLOG.ELF   *)

(***************************  operator_log  *****************************)
(*									*)
(*			     create_oper_log				*)
(*									*)
(*	Create new file if one does not exist. 				*)
(*									*)
(************************************************************************)

procedure create_oper_log( VAR ok : boolean);

var
  i		: oper_log_message_index;
  user		: user_index;
  create_status	: file_allocation_status;
  file_header	: file_header_record;
  buffer	: oper_log_entry;

begin
  disk_operator.create (
    file_mark, OPER_LOG_FILE_SIZE, WAIT_FOR, create_status);
  ok := create_status = F_A_COMPLETE;

  if ok then disk_operator.read_block (FILE_HEADER_SECTOR, file_header, ok);

  if ok
  then begin
    file_header.start_data_sector := 
	disk_operator.start_address + ONE_DISK_BLOCK;
    file_header.file_type := chr (INTERNAL_FILE);
    disk_operator.write_block (FILE_HEADER_SECTOR, file_header, ok)
  end;
  if ok
  then for i := 0 to OPER_LOG_MESSAGE_LIMIT do
    begin
      buffer.time     := MIN_INTEGER;
      buffer.sequence := i;
      write_message (i, buffer)
    end (* for *) ;

  next_write_sequence := OPER_LOG_MESSAGE_MAX;
  first_new_message   := OPER_LOG_MESSAGE_MAX;
  for user := 0 to USER_LIMIT do user_sequence[user] := OPER_LOG_MESSAGE_MAX
end (* create_oper_log *) ;
!
			 (*   OPLOG.ELF   *)

(***************************  operator_log  *****************************)
(*									*)
(*			    find_last_message				*)
(*									*)
(*	Scan file for latest entry and set up next_write_sequence.	*)
(*									*)
(************************************************************************)

procedure find_last_message;

var
  i		: oper_log_message_index;
  buffer	: oper_log_entry;

begin
  next_write_sequence := 0;
  for i := 0 to OPER_LOG_MESSAGE_LIMIT do
    begin
      read_message (i, buffer);
      if buffer.sequence > next_write_sequence
      then next_write_sequence := buffer.sequence
    end (* for *) ;
  next_write_sequence := next_write_sequence + 1;
  first_new_message := next_write_sequence
end (* find_last_message *) ;
!
			 (*   OPLOG.ELF   *)

(***************************  operator_log  *****************************)
(*									*)
(*				initialize				*)
(*									*)
(*	Create new file if one does not exist. 				*)
(*	Scan file for latest entry and set up next_write_sequence.	*)
(*									*)
(************************************************************************)

procedure initialize;

var
  ok : boolean;

begin
  init disk_operator(disk_mon), crash_operator;
  disk_operator.set_unit (OPERATOR_LOG_DISK_UNIT);

  file_mark.host := OPERATOR_LOG_FILE_HOST;
  file_mark.time := OPERATOR_LOG_FILE_TIME;

  disk_operator.open_for_reading (file_mark);

  if disk_operator.status = FILE_NOT_FOUND
  then create_oper_log(ok)
  else
    begin
      check_for_valid_open(ok);
      if ok then find_last_message
    end;

  disk_operator.close
end (* initialize *) ;
!
			 (*   OPLOG.ELF   *)

(***************************  operator_log  *****************************)
(*									*)
(*			     open_oplog_file				*)
(*									*)
(*	Open operator log file for reading or writing. 			*)
(*	Return False if file does not exist. 				*)
(*									*)
(************************************************************************)

procedure open_oplog_file( VAR ok : boolean);

begin
  disk_operator.open_for_writing (file_mark);
  if disk_operator.status = FILE_NOT_FOUND
  then create_oper_log(ok)
  else check_for_valid_open(ok)
end (* open_oplog_file *) ;



(***************************  operator_log  *****************************)
(*									*)
(*			    close_oplog_file				*)
(*									*)
(*	Inform disk monitor that operator_log is finished with file.	*)
(*									*)
(************************************************************************)

procedure close_oplog_file;

begin
  disk_operator.close
end (* close_oplog_file *) ;
!
			 (*   OPLOG.ELF   *)

(****************************  operator_log  ****************************)
(*									*)
(*			    sequence_to_address				*)
(*									*)
(*      This routine converts a message sequence number to a file	*)
(*	address.							*)
(*									*)
(************************************************************************)

function sequence_to_address(sequence: integer) : oper_log_message_index;

begin
  sequence_to_address := sequence mod OPER_LOG_MESSAGE_MAX
end (* sequence_to_address *) ;



(****************************  operator_log  ****************************)
(*									*)
(*			    adjust_read_sequence			*)
(*									*)
(*	This routine insures that a read sequence number refers to a	*)
(*	current message in the operator log.				*)
(*									*)
(************************************************************************)

procedure adjust_read_sequence(var sequence: integer);

begin
  if (next_write_sequence-sequence) > OPER_LOG_MESSAGE_MAX
  then sequence := next_write_sequence-OPER_LOG_MESSAGE_MAX
end (* adjust_read_sequence *) ;
!
			 (*   OPLOG.ELF   *)

(***************************  operator_log  *****************************)
(*									*)
(*				   write				*)
(*									*)
(*      Write a message to the oper log file.  Clear the caught up flag.*)
(*									*)
(************************************************************************)

procedure entry write(
  new_message	   : message_buffer) ;

var
  buffer : oper_log_entry;
  ok     : boolean;

begin
  with buffer do
    begin
      sequence := next_write_sequence;
      time     := realtime;
      message  := new_message
    end (* with *) ;

  open_oplog_file(ok);
  if ok 
  then
    begin
      write_message (sequence_to_address(next_write_sequence), buffer);
      next_write_sequence := next_write_sequence+1
    end;
  close_oplog_file
end (* write *) ;
!
			 (*   OPLOG.ELF   *)

(*****************************  operator_log  ***************************)
(*									*)
(*			     	 set_offset				*)
(*									*)
(*	Set user's next read pointer to first_new_message plus offset.	*)
(*									*)
(************************************************************************)

procedure entry set_offset (
      user	  : user_index;
      count	  : integer);

begin
  user_sequence[user] := first_new_message + count;
  if user_sequence[user] >= next_write_sequence
  then user_sequence[user] := next_write_sequence - 1;
  if user_sequence[user] < OPER_LOG_MESSAGE_MAX
  then user_sequence[user] := OPER_LOG_MESSAGE_MAX
end (* set_new_message *) ;



(*****************************  operator_log  ***************************)
(*									*)
(*			     	   backup				*)
(*									*)
(*	Set user's next read pointer back by argument value.		*)
(*									*)
(************************************************************************)

procedure entry backup (
      user	  : user_index;
      count	  : integer);

begin
  user_sequence[user] := user_sequence[user] - count;
  if user_sequence[user] >= next_write_sequence
  then user_sequence[user] := next_write_sequence - 1;
  if user_sequence[user] < OPER_LOG_MESSAGE_MAX
  then user_sequence[user] := OPER_LOG_MESSAGE_MAX
end (* backup *) ;
!
			 (*   OPLOG.ELF   *)

(*****************************  operator_log  ***************************)
(*									*)
(*			     	   read					*)
(*									*)
(*	Read the message at message_address.  Advance to next message.	*)
(*									*)
(************************************************************************)

procedure entry read (
      user	  : user_index;
  var log_entry   : oper_log_entry;
  var got_message : boolean) ;

var
  ok : boolean;

begin
  open_oplog_file(ok);
  if ok
  then
    begin
      adjust_read_sequence(user_sequence[user]);
      if user_sequence[user] = next_write_sequence
      then got_message := FALSE
      else
	begin
	  read_message (
	    sequence_to_address(user_sequence[user]), log_entry);
	  log_entry.sequence := log_entry.sequence - first_new_message;
	  user_sequence[user] := user_sequence[user] + 1
	end
    end;
  close_oplog_file
end (* read *) ;
!
			 (*   OPLOG.ELF   *)

(*****************************  operator_log  ***************************)
(*									*)
(*			   initial_user_sequence			*)
(*									*)
(*	Initialize the user_sequence.					*)
(*									*)
(************************************************************************)


procedure entry initial_user_sequence(user: user_index);

begin
  user_sequence[user] := next_write_sequence
end (* initial_user_sequence *) ;


(***************************  operator_log  *****************************)
(************************************************************************)

begin (* initial statement *) 
  initialize
end (* operator_log *) ;
!
(************************************************************************)
(*									*)
(*	OPUTIL.ELF Updated 8-Nov-85 at 17:59 by Paktor			*)
(*									*)
(*			  operator_utility				*)
(*									*)
(*	This class is the only write access to the operator's log.	*)
(*	Messages, whether constructed here, or in a separate     	*)
(*	error utility, are sent to the operator log monitor.		*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	 2Jun85	Original -- RER						*)
(*									*)
(************************************************************************)


(*	This is a list of all the possible messages which can be added	*)
(*	to the operator log.						*)

Type

    (*  Simple Messages with No Integer parameter.  *)
  OLM_0_Operator_log_message = (
      OLM_0_They_Should_Be_Like_This   ) ;

(**)
!
     (*   OPUTIL.ELF   *)

    (*  Messages with One Integer parameter.  *)
  OLM_1_Operator_log_message = (
      OLM_1_Host_Absent,

      (*  Announcement Buffer Monitor Related Messages.  *)
      OLM_1_An_Buf_Wr_Hdr,
      OLM_1_An_Buf_Rd_Hdr,
      OLM_1_An_Buf_Open,
      OLM_1_An_Buf_Ini_Crea,
      OLM_1_An_Buf_Ini_Open,
      OLM_1_An_Buf_Rd_Open,
      OLM_1_An_Buf_Wr_Open,
      OLM_1_An_Buf_Blk_Rd,
      OLM_1_An_Buf_Blk_Wrt,
      OLM_1_An_Buf_Display,

      OLM_1_They_Should_Be_Like_This ) ;

(**)
!
     (*   OPUTIL.ELF   *)

    (*  Messages with Two parameters.  *)
  OLM_2_Operator_log_message = (

      OLM_2_They_Should_Be_Like_This ) ;

(**)
!
     (*   OPUTIL.ELF   *)

    (*  Messages with Three parameters.  *)

  OLM_3_Operator_log_message = (

      OLM_3_They_Should_Be_Like_This ) ;

(**)
!
     (*   OPUTIL.ELF   *)

type
  operator_utility = class ( oplog : operator_log ) ;

Var
  Message : Internal_to_String ;
  Crasher : Crash_Utility ;


(***************************  operator_utility  *************************)
(*									*)
(*			    	OLM_0_Write				*)
(*									*)
(*	Write a simple text message without parameters to log.		*)
(*									*)
(************************************************************************)

procedure OLM_0_Write ( message_code : OLM_0_Operator_log_message ) ;

begin
  Message.start ;

  case message_code of
    OLM_0_THEY_SHOULD_BE_LIKE_THIS:
      Message.String ('A text string ending with an \')
  end (* case *) ;

  oplog.write (Message.Buffer)
end (* OLM_0_Write *) ;

(**)
!
     (*   OPUTIL.ELF   *)

(***************************  operator_utility  *************************)
(*									*)
(*			    	OLM_1_AnBuf_Msg				*)
(*									*)
(*		Compose an Announcement Buffer related message,		*)
(*		with one Integer parameter, for OLM_1_Write.		*)
(*									*)
(************************************************************************)


procedure OLM_1_AnBuf_Msg (String_1 : Term_Chs ;
			    Rest    : Term_Chs ;
			Integer_One : Integer     ) ;

begin
  Message.String ('Error on Disk Unit \') ;
  Message.Number (Integer_One,Decimal) ;
  Message.String (String_1) ;
  Message.String (' Announcement Buffer\ ') ;
  Message.String (Rest)
  end  (*  OLM_1_AnBuf_Msg  *) ;


(**)
!
     (*   OPUTIL.ELF   *)

(***************************  operator_utility  *************************)
(*									*)
(*			    	OLM_1_Write				*)
(*									*)
(*	Write a text message with one integer parameter to log.		*)
(*									*)
(************************************************************************)

procedure OLM_1_Write ( message_code : OLM_1_operator_log_message ;
                          Integer_One  : Integer                 ) ;

Begin  (*   OLM_1_Write   *)
  message.start ;

  case message_code of
    OLM_1_Host_Absent : Begin
      Message.String ('The Host Number for this Slot, \') ;
      Message.Number (Integer_One,Decimal) ;
      Message.String (', is not listed in the Config file.\') ;
      Message.String ('  Elf Backup can not be initiated.\ ')
      End  (*  OLM_1_Host_Absent  *) ;

    OLM_1_An_Buf_Wr_Hdr : OLM_1_AnBuf_Msg(' while writing\ ',
                                                ' Header.\ ', Integer_One) ;

    OLM_1_An_Buf_Rd_Hdr : OLM_1_AnBuf_Msg(' while reading\ ',
                                                ' Header.\ ', Integer_One) ;

    OLM_1_An_Buf_Ini_Crea : 
                        OLM_1_AnBuf_Msg(' while attempting to create\',
			                                '.\', Integer_One) ;

    OLM_1_An_Buf_Ini_Open : 
                OLM_1_AnBuf_Msg(' during initial attempt at opening \',
		                                        '.\', Integer_One) ;

    OLM_1_An_Buf_Open    :
                OLM_1_AnBuf_Msg(' while attempting to open \ ',
		                                        '.\', Integer_One) ;

    OLM_1_An_Buf_Rd_Open :
                OLM_1_AnBuf_Msg(' while attempting to open \ ',
					      ' for reading.\',Integer_One) ;

(**)
!
     (*   OPUTIL.ELF   *)

    OLM_1_An_Buf_Wr_Open :
                OLM_1_AnBuf_Msg(' while attempting to open \ ',
						' for writing.\',Integer_One) ;

    OLM_1_An_Buf_Blk_Rd :
                        OLM_1_AnBuf_Msg(' while reading Block from \ ',
			                                '.\', Integer_One) ;

    OLM_1_An_Buf_Blk_Wrt : OLM_1_AnBuf_Msg(' while writing Block to \ ',
                                                        '.\', Integer_One) ;

    OLM_1_An_Buf_Display : OLM_1_AnBuf_Msg(' while displaying from \',
                                                        '.\', Integer_One) ;

    OLM_1_THEY_SHOULD_BE_LIKE_THIS : Begin
      Message.String ('Text string will be followed by the number \') ;
      Message.Number (Integer_One,Decimal) ;
      Message.String (' More text can follow. \')
      End (*  OLM_1_THEY_SHOULD_BE_LIKE_THIS   *)

  end (* case *) ;

  oplog.write (message.Buffer)
end (* OLM_1_Write *) ;

(**)
!
     (*   OPUTIL.ELF   *)

(***************************  operator_utility  *************************)
(*									*)
(*			    	OLM_2_Write				*)
(*									*)
(*	Write a text message with two integer parameters to log.	*)
(*									*)
(************************************************************************)

procedure OLM_2_Write ( message_code : OLM_2_Operator_log_message ;
			Integer_One  : Integer ;
			Integer_Two  : Integer  ) ;

begin
  message.start ;

  case message_code of

    OLM_2_THEY_SHOULD_BE_LIKE_THIS :
      Begin
	Message.String ('Text string to be followed by first number \') ;
	Message.Number (Integer_One, Decimal) ;
	Message.String (', followed by more text, \') ;
	Message.Number (Integer_Two, Decimal) ;
	Message.String (', and still more text. \')
	End (*  OLM_2_THEY_SHOULD_BE_LIKE_THIS   *)

  end (* case *) ;

  oplog.write (message.Buffer)
end (* OLM_2_Write *) ;

(**)
!
     (*   OPUTIL.ELF   *)

(***************************  operator_utility  *************************)
(*									*)
(*			    	OLM_3_Write				*)
(*									*)
(*	Write a text message with three integer parameters to log.	*)
(*									*)
(************************************************************************)

procedure OLM_3_Write ( message_code  : OLM_3_Operator_log_message ;
			Integer_One   : Integer ;
			Integer_Two   : Integer ;
			Integer_Three : Integer  ) ;

begin
  message.start ;

  case message_code of

    OLM_3_THEY_SHOULD_BE_LIKE_THIS :
      Begin
	Message.String ('Text string to be followed by first number \') ;
	Message.Number (Integer_One, Decimal) ;
	Message.String (', followed by more text, \') ;
	Message.Number (Integer_Two, Decimal) ;
	Message.String (', still more text, \') ;
	Message.Number (Integer_Three, Decimal) ;
	Message.String (', and still more text. \')
	End (*  OLM_3_THEY_SHOULD_BE_LIKE_THIS   *)
  end (* case *) ;
  oplog.write (message.Buffer)
end (* OLM_3_Write *) ;

(**)
!
     (*   OPUTIL.ELF   *)

(*************************  operator_utility  ***************************)
(*									*)
(*				Entries					*)
(*		Write_0, Write_1, Write_2, and Write_3			*)
(*				   and					*)
(*		Crash_0, Crash_1, Crash_2, and Crash_3			*)
(*									*)
(*	Take message code and params as indicated, and write to 	*)
(*		the operator log, and crash if indicated.		*)
(*									*)
(************************************************************************)

Procedure entry Crash_0 ( message_code : OLM_0_operator_log_message ) ;
Begin
  OLM_0_Write(message_code ) ;
  Crasher.Signal_Process_Error
  End  (*  Crash_0  *) ;

(************************************************************************)

Procedure entry Crash_1 ( message_code : OLM_1_operator_log_message ;
                          Integer_One  : Integer                 ) ;
Begin
  OLM_1_Write(message_code, Integer_One ) ;
  Crasher.Signal_Process_Error
  End  (*  Crash_1  *) ;

(************************************************************************)

Procedure entry Crash_2 ( message_code : OLM_2_operator_log_message ;
                          Integer_One  : Integer ;
                          Integer_Two  : Integer                 ) ;
Begin
  OLM_2_Write(message_code, Integer_One, Integer_Two ) ;
  Crasher.Signal_Process_Error
  End  (*  Crash_2  *) ;

(************************************************************************)

Procedure entry Crash_3 ( message_code  : OLM_3_operator_log_message ;
                          Integer_One   : Integer ;
                          Integer_Two   : Integer ;
                          Integer_Three : Integer                 ) ;

Begin
  OLM_3_Write(message_code, Integer_One, Integer_Two, Integer_Three ) ;
  Crasher.Signal_Process_Error
  End (*  Crash_3  *) ;

(**)
!
     (*   OPUTIL.ELF   *)

(************************************************************************)

Procedure entry Write_0 ( message_code : OLM_0_operator_log_message ) ;
Begin
OLM_0_Write(message_code)
  End  (*  Write_0  *)  ;

(************************************************************************)

Procedure entry Write_1 ( message_code : OLM_1_operator_log_message ;
                          Integer_One  : Integer                 ) ;
Begin
  OLM_1_Write(message_code, Integer_One )
  End  (*  Write_1  *)  ;

(************************************************************************)

Procedure entry Write_2 ( message_code : OLM_2_operator_log_message ;
                          Integer_One  : Integer ;
                          Integer_Two  : Integer                 ) ;
Begin
  OLM_2_Write(message_code, Integer_One, Integer_Two )
  End  (*  Write_2  *) ;

(************************************************************************)

Procedure entry Write_3 ( message_code  : OLM_3_operator_log_message ;
                          Integer_One   : Integer ;
                          Integer_Two   : Integer ;
                          Integer_Three : Integer                 ) ;

Begin
  OLM_3_Write(message_code, Integer_One, Integer_Two, Integer_Three )
  End  (*  Write_3  *) ;

(**)
!
     (*   OPUTIL.ELF   *)

(*************************  operator_utility  ***************************)
(*									*)
(*		Entries Write and Crash take an Internal_to_String	*)
(*		with an Error Message already formatted.		*)
(*									*)
(************************************************************************)

Procedure Entry Write (Formatter : Internal_to_String ) ;
Begin 
  oplog.write( Formatter.Buffer )
  End ;

    (*  ****************************************************************  *)

Procedure Entry Crash (Formatter : Internal_to_String ) ;
Begin 
  oplog.write( Formatter.Buffer ) ;
  Crasher.Signal_Process_Error
  End ;

(************************************************************************)

Procedure Entry Just_Crash ;
Begin 
  Crasher.Signal_Process_Error
  End ;


(************************************************************************)

(*************************  operator_utility  ***************************)
(************************************************************************)

begin (* initial statement *) 
  init Message ;
  init Crasher 
  end (* operator_utility *) ;
!
(*   CNDERR.EBK Updated 30-Oct-85 at 16:51 by Raffo  *)
(*   ELF v 4.0, (ELF with Backup) Condense Process Error Message Formatter *)

Type Condense_Error_Formatter = Class ( Disk_Drive : Disk_Index ;
					Op_Log     : Operator_Log ) ;

Var
  Message : Internal_to_String ;

    (*  ****************************************************************  *)

Procedure Entry Finished ;

Begin
  Message.Simple_Message ('Condense on Disk Unit \ ') ;
  Message.Number (Disk_Drive,Decimal) ;
  Message.String (' finished.\ ') 
  End  (*   Finished  *) ;

    (*  ****************************************************************  *)

Procedure Entry Error ( String_1 : Term_Chs ;
		  Sector_Address : Disk_Sector_Address ) ;

Begin
  Message.Simple_Message ('Condense Error on Disk Unit \ ') ;
  Message.Number (Disk_Drive, Decimal) ;
  Message.String (' while \') ;
  Message.String (String_1) ;
  Message.String (' sector address \ ') ;
  Message.Number (Sector_Address, Decimal) ;
  Message.String (' (\ ') ;
  Message.Number (Sector_Address, Hex) ;
  Message.String (' hex).\ ') 
  End  (*  Error  *) ;

    (*  ****************************************************************  *)

Procedure Entry Write ;
Begin
  Op_Log.Write (Message.Buffer)
  End  (*  Write  *) ;

    (*  ****************************************************************  *)

Begin    (*  Formal Initialization  *)
  End ;
!
(*   CNDNSP.EBK Updated 3-Aug-85 at 18:05 by Paktor   *)
(*   ELF v 4.0, (ELF with Backup) Condense Process    *)

Type Condense_Process = Process ( Disk_Drive : Disk_Index ;
				  Disk_Mon   : Disk_Monitor ;
				  Oper_Log   : Operator_Log ) ;

Var
  Okay                : Boolean ;
  Message             : Condense_Error_Formatter ;
  File_Header         : File_Header_Record ;
  File_Header_Address : Disk_Block_Address ;
  Disk_Ops            : Disk_System ;

    (*  ****************************************************************  *)

Procedure Write_File_Header ;
Begin
     (*  File_Header_Address has the Disk Sector Address    *)
     (*           where the File Header belongs.            *)
  Disk_Ops.Write_Block(File_Header_Address, File_Header, Okay) ;
  If Not Okay
    Then
      Message.Error('writing file header to\ ', File_Header_Address)

  End ;  (*  Write_File_Header  *)

(**)
!
    (*   CNDNSP.EBK  *)

Procedure Slosh_a_File ( VAR Again : Boolean ) ;

Var
  Gap_Start_Address,
  Disk_Sector_Source,
  Disk_Sector_Limit,
  Disk_Sector_Dest      : Disk_Sector_Address ;
  The_Disk_Block        : Disk_Block ;

Begin
  Disk_Mon.Condense_Next_File( Again, Gap_Start_Address, File_Header_Address) ;

  If Again
    Then Begin
      Disk_Ops.Read_Block(File_Header_Address, File_Header, Okay) ;
      If Not Okay
	Then Message.Error ('reading file header from\ ', File_Header_Address)

	Else Begin  (*  Disk Read was Okay.  *)
	  If File_Header.Slosh_Dest = Disk_Sector_Address_Absent
	    Then Begin  (*  A New File  *)

	      File_Header.Slosh_Length := File_Header_Address - 
	                                                    Gap_Start_Address ;

	      File_Header.Slosh_End    := File_Header.End_Sector ;

	      File_Header.End_Sector   := File_Header.End_Sector -
						     File_Header.Slosh_Length ;

	      File_Header.Start_Data_Sector := File_Header.Start_Data_Sector -
						     File_Header.Slosh_Length ;

	      File_Header.Slosh_Dest   := Gap_Start_Address + One_Disk_Block ;

	      File_Header_Address := Gap_Start_Address ;

	      Write_File_Header;

	      If Okay
		Then Disk_Mon.Write_Disk_Header ;
	      End ;     (*  A New File  *)
	  End ;     (*  Disk Read was Okay.  *)

(**)
!
    (*   CNDNSP.EBK  *)

      If Okay Then
      Repeat  (*  Until  (Disk_Sector_Source > File_Header.Slosh_End)  *)

	Disk_Sector_Source := File_Header.Slosh_Dest+File_Header.Slosh_Length;
	Disk_Sector_Limit  := Disk_Sector_Source ;
	Disk_Sector_Dest   := File_Header.Slosh_Dest ;

	Repeat  (*  Until (Disk_Sector_Dest = Disk_Sector_Limit)
		  OR (Disk_Sector_Source > File_Header.Slosh_End) *)

	  Disk_Ops.Read_Block(Disk_Sector_Source, The_Disk_Block, Okay ) ; 

	  If Not Okay
	    Then Message.Error ('reading block from\ ', Disk_Sector_Source) 

	    Else Disk_Ops.Write_Block(Disk_Sector_Dest, The_Disk_Block, Okay) ;

	  If Not Okay
	    Then Message.Error ('writing block to\ ',Disk_Sector_Dest) 
	    Else Begin
	      Disk_Sector_Source := Disk_Sector_Source + One_Disk_Block ;
	      Disk_Sector_Dest   := Disk_Sector_Dest   + One_Disk_Block 
	      End ;

	  Until (NOT Okay) OR (Disk_Sector_Dest = Disk_Sector_Limit)
			   OR (Disk_Sector_Source > File_Header.Slosh_End);

	If Okay
	  Then Begin
	    File_Header.Slosh_Dest :=  Disk_Sector_Limit ;
	    Write_File_Header
	    End ;

	Until  (Disk_Sector_Source > File_Header.Slosh_End) OR (Not Okay) ;

      If Okay
	Then Begin
	  File_Header.Slosh_Dest   := Disk_Sector_Address_Absent ;
	  File_Header.Slosh_Length := Disk_Sector_Address_Absent ;
	  File_Header.Slosh_End    := Disk_Sector_Address_Absent ;

	  Write_File_Header ;

	  End ;  (*  If Okay  *)

      End ;  (*  If Again  *)

  End ;   (*  Slosh_a_File  *)

(**)
!
    (*   CNDNSP.EBK  *)

Procedure Condense ;
        (*  Main Functional Body of Condense Process  *)
Var
  Again       : Boolean ;
  Per_File_User,
  File_Users  : File_User_Size ;

Begin
  Init Message(Disk_Drive, Oper_Log) ;

  Cycle
    Disk_Mon.Start_Condense(Okay) ;

    If Okay
      Then Repeat  (*  Until Not Again  *)
	Slosh_a_File(Again);
	Until Not Again ;

    File_Users := Disk_Mon.Finish_Condense ;
    For Per_File_User := File_User_First to File_Users
      Do Disk_Mon.Continue_File_User ;

    If Okay Then Message.Finished ;
    Message.Write

    End  (*  Cycle  *)
  End  (*  Condense  *) ;


    (*  ****************************************************************  *)

        (*  Formal Main Body of Condense Process  *)

Begin
  Init Disk_Ops ;
  Disk_Ops.Set_Unit ( Disk_Drive ) ;
  Condense ;
  End ;  (*  Process  *)
!
(*   ADJFLH.EBK Updated 14-Jun-85 at 3:41 by Paktor   *)
(*   ELF v 4.0, (ELF with Backup) Adjust File Header Class   *)

Type File_Header_Adjuster = Class ;


Procedure Entry Relativize( VAR File_Header : UNIV File_Header_Record ;
                              Start_Address : Disk_Sector_Address ) ;

    (*  Adjust the File Header before sending it to the Partner.  *)

Begin
    (*  These Fields are kept as absolute Disk Sector Addresses on Disk,   *)
    (*     and are adjusted, relative to the Start Address, before         *) 
    (*     being sent to the Partner.  Upon being received, they will      *)
    (*     be re-adjusted, relative to the File's Start Address on the     *)
    (*     Partner's Disk arrangement.                                     *)

    (*  Here, make the initial adjustment before sending the File Header.  *)

  File_Header.Start_Data_Sector  :=
                                File_Header.Start_Data_Sector - Start_Address ;

  File_Header.End_Sector         :=
                                File_Header.End_Sector        - Start_Address ;
  End ;   (*  Relativize  *)

    (*  ****************************************************************  *)

Procedure Entry Absolutize( VAR File_Header : UNIV File_Header_Record ;
                              Start_Address : Disk_Sector_Address ) ;

    (*  Re-Adjust the File Header after receiving it from the Partner.  *)

Begin
    (*  These Fields are kept as absolute Disk Sector Addresses on Disk,   *)
    (*     and are adjusted, relative to the File's Start Address, before  *) 
    (*     being sent to the Partner.  Upon being received, they must      *)
    (*     be re-adjusted, relative to the File's Start Address on the     *)
    (*     Partner's Disk arrangement.                                     *)

    (*  Here, make the re-adjustment after receiving the File Header.      *)

  File_Header.Start_Data_Sector  :=
                                File_Header.Start_Data_Sector + Start_Address ;

  File_Header.End_Sector         :=
                                File_Header.End_Sector        + Start_Address ;
  End ;  (*  Absolutize  *)

    (*  ****************************************************************  *)

    (*  Formal Initialization  *)
Begin
  (*  Nothing  *)
  End ;
!
!
      (*     DEVIO.ELF Updated 29-Jul-85 at 14:06 by Paktor    *)

(************************************************************************)
(*                                                                 	*)
(*       DEVIO - DEVICE Handling CLASS                                  *)
(*                                                                      *)
(*       This CLASS contains the various DEVICE Handling functions.     *)
(*									*)
(*                                                                      *)
(************************************************************************)


(*	The following type is used to indicate the state of a device	*)
(*	record. The assign and attach states are only used for tape.	*)
(*	The file open states are only used for disk. The state field	*)
(*	in a device record is only meaningful if the device kind is	*)
(*	either DISK or TAPE.						*)

  type device_or_file_state =
    (device_unused,
     device_assigned, device_assigned_and_attached,
     old_file_opened, new_file_opened);


  dev_rec = record	(* used to transmit device data *)
    unit	  : integer	(* device unit number *) ;
    kind	  : iodevice	(* type of device *) ;
    state	  : device_or_file_state;
    result	  : ioresult	(* result of operation *) ;

    disk_operator : disk_utility;

    page_addr	  : integer	(* data address *) ;

    cksum_page	  : integer	(* address of checksum page *) ;
    cksum_dex	  : integer	(* index into cksum_blk *) ;
    cksum_blk	  : elf_rec	(* checksum data *) ;

    elf_data	  : elf_rec	(* data to be read/written *)
   end (* dev_rec *) ;
!
type devio = class;

const
  maximum_tape_retries = 16;
  controller = 8;


var
  param     : disk_tape_param;
  dummy     : string2;
!
(******************************  devio  *********************************)
(*									*)
(*			       save_result				*)
(*									*)
(************************************************************************)

procedure save_result (
  var result	: ioresult;
  var io_error	: integer;
  var ctr_stat	: integer );

begin
  io_error := 0;
  ctr_stat := 0;
  result := param.status;
  if result <> COMPLETE
  then
    begin
      io_error := param.arg2;
      if io_error = 8
      then ctr_stat := param.status2
    end
end (* save_result *) ;



(******************************  devio  *********************************)
(*									*)
(*			    do_position_drive				*)
(*									*)
(************************************************************************)

procedure do_position_drive(
      pos_op	: integer;
  var c_rec	: dev_rec;
  var io_error	: integer;
  var ctr_stat	: integer);

begin
  param.operation := TAPE_ACTION;
  param.arg1 := pos_op;
  io(dummy, param, c_rec.kind, c_rec.unit);
  if (pos_op = TAPE_REWIND) and (param.status = END_MEDIUM)
  then param.status := COMPLETE;
  save_result(c_rec.result, io_error, ctr_stat)
end (* do_position_drive *) ;

!
      (*     DEVIO.ELF   *)

(******************************  devio  *********************************)
(*									*)
(*				read      				*)
(*									*)
(************************************************************************)


procedure read(
  var c_rec	: dev_rec;
  var io_error	: integer;
  var ctr_stat	: integer);

var
  retry_count : integer (* count of retries on error *) ;
  done : boolean;

begin
  case c_rec.kind of
    DISK:
      begin
	c_rec.disk_operator.read_block (
	  c_rec.page_addr, c_rec.elf_data.chars.file_data, done);
	param := c_rec.disk_operator.disk_parameter
      end (* DISK *) ;

    TAPE:
      begin
	done := FALSE;
	retry_count := 0;
	repeat
	  param.operation := INPUT;
	  param.arg2 := MX_ELF_CRS;
	  io(c_rec.elf_data.chars, param, TAPE, c_rec.unit);
	  c_rec.elf_data.length := param.arg1;
	  if (param.status = TRANSMISSION) and (param.arg2 = CONTROLLER)
	  then
	    begin	(* re-try only if controller error *)
	      do_position_drive(TAPE_BACK_SPACE, c_rec, io_error, ctr_stat);
	      retry_count := retry_count + 1
	    end
	  else done := TRUE
	until (retry_count >= MAXIMUM_TAPE_RETRIES) or done
      end (* TAPE *)
  end (* case *) ;

  save_result(c_rec.result, io_error, ctr_stat)
end (* read *) ;
!
(******************************  devio  *********************************)
(*									*)
(*			drive_status					*)
(*									*)
(************************************************************************)

procedure entry drive_status (
  var c_rec	: dev_rec;
  var info	: disk_tape_information;
  var io_error	: integer;
  var ctr_stat	: integer);

begin
  param.operation := UNIT_INFO;
  io(info, param, c_rec.kind, c_rec.unit);
  save_result(c_rec.result, io_error, ctr_stat)
end (* drive_status *) ;



(******************************  devio  *********************************)
(*									*)
(*			      read_drive				*)
(*									*)
(************************************************************************)

procedure entry read_drive (
  var c_rec	: dev_rec;
  var io_error	: integer;
  var ctr_stat	: integer);

begin
  read(c_rec, io_error, ctr_stat)
end (* read_drive *) ;

!
      (*     DEVIO.ELF   *)

(******************************  devio  *********************************)
(*									*)
(*			    position_drive				*)
(*									*)
(************************************************************************)

procedure entry position_drive(
      pos_op	: integer;
  var c_rec	: dev_rec;
  var io_error	: integer;
  var ctr_stat	: integer);

begin
  do_position_drive(pos_op, c_rec, io_error, ctr_stat)
end (* position_drive *) ;



(******************************  devio  *********************************)
(*									*)
(*				attach					*)
(*									*)
(************************************************************************)

procedure entry attach (
  var c_rec	: dev_rec;
  var io_error	: integer;
  var ctr_stat	: integer);

var
  n : integer;

begin
  param.operation := UNIT_ATTACH;
  io(dummy, param, c_rec.kind, c_rec.unit);
  save_result(c_rec.result, io_error, ctr_stat)
end (* attach *) ;



(******************************  devio  *********************************)
(*									*)
(*				detach					*)
(*									*)
(************************************************************************)

procedure entry detach (
  var c_rec	: dev_rec;
  var io_error	: integer;
  var ctr_stat	: integer);

begin
  param.operation := UNIT_DETACH;
  io(dummy, param, c_rec.kind, c_rec.unit);
  save_result(c_rec.result, io_error, ctr_stat)
end (* detach *) ;

!
      (*     DEVIO.ELF   *)

(******************************  devio  *********************************)
(*									*)
(*				write_drive				*)
(*									*)
(************************************************************************)

procedure entry write_drive(
  var c_rec	: dev_rec;
  var io_error	: integer;
  var ctr_stat	: integer);

var
  gaps_written : integer (* count of erase gaps on errors *) ;
  done : boolean;

begin
  case c_rec.kind of
    DISK:
      begin
	c_rec.disk_operator.write_block (
	  c_rec.page_addr, c_rec.elf_data.chars.file_data, done);
	param := c_rec.disk_operator.disk_parameter
      end (* DISK *) ;

    TAPE:
      begin
	done := FALSE;
	gaps_written := 0;
	repeat
	  param.operation := OUTPUT;
	  param.arg2 := MX_ELF_CRS;
	  io(c_rec.elf_data.chars, param, TAPE, c_rec.unit);
	  if (param.status = TRANSMISSION) and (param.arg2 = CONTROLLER)
	  then
	    begin
	      do_position_drive(TAPE_BACK_SPACE, c_rec, io_error, ctr_stat);
	      do_position_drive(TAPE_GAP, c_rec, io_error, ctr_stat);
	      gaps_written := gaps_written + 1
	    end
	  else done := TRUE
	until done or (gaps_written >= MAXIMUM_TAPE_RETRIES)
      end (* TAPE *)
  end (* case *) ;
  save_result(c_rec.result, io_error, ctr_stat)
end (* write_drive *) ;
!
(******************************  devio  *********************************)
(*									*)
(*			devio initial routine				*)
(*									*)
(************************************************************************)

begin
end (* devio *) ;
!
(************************************************************************)
(*									*)
(*	TALLOC.ELF							*)
(*									*)
(*			     tape_allocater  				*)
(*									*)
(*	This monitor keeps track of tape units assigned to users.	*)
(*									*)
(************************************************************************)

type tape_allocater = monitor;

var
  tape_used : array [tape_unit_index] of boolean;
!
(**************************  tape_allocater  ****************************)
(*									*)
(*				initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  unit		: integer;

begin
  for unit := 0 to TAPE_UNIT_LIMIT do tape_used[unit] := FALSE
end (* initialize *) ;



(**************************  tape_allocater  ****************************)
(*									*)
(*				 legal					*)
(*									*)
(************************************************************************)

function legal (unit : integer) : boolean;

var
  param		: disk_tape_param;
  device_status : disk_tape_information;

begin
  param.operation := UNIT_INFO;
  io(device_status, param, TAPE, unit);
  legal := param.status <> FAILURE
end (* legal *) ;



(**************************  tape_allocater  ****************************)
(*									*)
(*				assign_unit				*)
(*									*)
(************************************************************************)

procedure entry assign_unit(
      unit	: integer;
  var status	: ioresult);

begin
  if not legal (unit)
  then status := ILLEGAL_DEV
  else
    if tape_used[unit]
    then status := UNAVAILABLE
    else
      begin
        tape_used[unit] := TRUE;
        status := COMPLETE
      end
end (* assign_unit *) ;



(**************************  tape_allocater  ****************************)
(*									*)
(*				deassign_unit				*)
(*									*)
(************************************************************************)

procedure entry deassign_unit(unit : integer);

begin
  tape_used[unit] := FALSE
end (* deassign_unit *) ;



(**************************  tape_allocater  ****************************)
(*									*)
(*				legal_unit				*)
(*									*)
(************************************************************************)

function entry legal_unit (unit : integer) : boolean;

begin
  legal_unit := legal (unit)
end (* legal_unit *) ;
!
(**************************  tape_allocater  ****************************)
(*									*)
(*			     initial routine				*)
(*									*)
(************************************************************************)

begin
  initialize
end (* tape_allocater *) ;
!
      (*   CNTRL1.ELF Updated 11-Sep-86 at 9:06 by Raffo   *)

(************************************************************************)
(*									*)
(*				control process				*)
(*									*)
(*	This process is the main controlling routine.			*)
(*									*)
(************************************************************************)

type
  control =
    process(
      elf_user		: user_index;
      term_unit		: integer;
      port_unit		: integer;
      allocate_tape	: tape_allocater;
      cmdmon		: commanddefs;
      disk_mon		: disk_monitor_array;
      mark_mon		: mark_monitor;
      oplog		: operator_log);

const
  resend_startup_rec_count = 6;
  max_seg = 14;

(* ELF is willing to accept a 6 second turnaround time for a single record *)
  downline_timeout = max_dl_records (* seconds *) ;

type
  segs = 0..max_seg;
  seg_set_def = set of segs;
  set_array = array [0..31] of char;

type
  open_option = 
    (do_not_open,
     open_read_do_not_confirm, open_write_do_not_confirm,
     open_read_confirm, open_write_confirm );

const
  use_passw = TRUE;
  no_passw = false;
  mx_dl_ct = 3000;	"mx no of data chars in 1 dl record"

!
      (*   CNTRL1.ELF    *)

var
  term,
  cirio : portio;
  form : internal_to_string;
  cmn : commondef;
  devs       : devio;   "class to perform i/o"
  seg_length : array[0..max_seg] of integer;
  seg_set    : seg_set_def;  "set of segs to dump"
  this_seg   : segs;		"current segment"
  old_circuit,			"using circuit already built"
  gt_aux_cir,		"TRUE if circuit built to obj, dl or slot cir"
  gt_tty_cir,		"TRUE if user is logged in"
  elf_cmp_fl,		"TRUE during elf compression"
  cmp_fl,		"TRUE when object/load compression data coming"
  gotit,		"general boolean variable"
  image_form,		"TRUE if file should be in image format"
  cmf_host,		"true for code mang host, set by host command 1/3/84"
  unix_file,		"true if file specified is a UNIX file"
  found        : boolean;
  token,
  term_line    : line_rec;
  zero_fill_count,	"count of no. of zeros to fill in for image format"
  input_file_ptr,
  output_file_ptr,
  input_start_page,		"start page of current file"
  output_start_page,
  input_end_page,		"end page of current file"
  output_end_page,
  adjusted_file_size,
  mx_out_sz,		"mx. size of slot or node output record"
  chars_left,
  recs_sent,		"total number of:   records sent"
  good_recs,		        "good records sent"
  late_recs,			"dl records received after they timed out"
  resent_recs,		        "dl records resent"
  dl_addr,		"downline address"
  dl_data_start,	"address of beginning of dl record"
  elf_addr,		"address of data for create slot"
  o_elf_addr,		"used to store and restore elf_addr"
  elf_ch_ptr,
  obj_ch_ptr,		"object data char ptr"
  elf_cmp_ct,		"elf data compression count"
  cmp_ct,		"object/load data compression count"
  rec_ch_ct,		"number of chars in a slt rec (actual data chars)"
  seg_ch_ct,		"number of chars in a seg"
  last_addr,		"address of last block input"
  retries,		"retry count for transmissions"
  downline_pointer,	"index into dl_recs to put records sent"
  byte_count,		"no. of elf bytes file will occupy"
  exp_b_ct,		"escape expanded count (for disk byte count)"
  strt_add,		"start address for restart and dump command"
  end_add,		"end address for dump command"
  n,
  input_disk_page,	"page address to read/write disk"
  output_disk_page,
  nxt_file,		"ptr to file page"
  t_index,		"temp index into elf id block"
  io_error,		"i/o error from last failure for disk or tape"
  ctr_stat,		"controller status if io_error is controller error(8)"
  elf_f_type,		"file type"
  vck,			"vertical checksum"
  dck,			"diagonal checksum"
  nblks,		"total number of disk blocks required for a file"
  nchars,
  netport_host,		"netport host number if not home for user"	
  nlines       : integer;
  chio,
  sp_char,		"special character"
  elf_cmp_ch,		"elf data compression character"
  cmp_ch,		"object/load data compression character"
  temp_ch      : char;
  temp_ans,
  res_in,
  res_out,
  aux_ans,			"ioresult used for obj, dl and slot circuits"
  file_ans,			"ioresult used on disk and tape"
  tt_ans       : ioresult;	"ioresult used on terminal i/o"
  ptr          : term_sz;
  file_desc    : obj_rec;	"tymcom-x file description"
  cir_ans,			"for building header, outputting responses
				on create command, and inputting
			 	responses on load command"
  cir_cmd,			"for sending cmd, addr and byte ct on ld slot"
  elf_blk,
  cir          : elf_rec;	"for inputting data records on load command
				 and outputting data records on create cmd"
  this_cmd     : cmddef_rec;
  this_sub     : subdef_rec;
  last_aux,			"login for last circuit build"
  aux          : login_rec;	"current login info"
  cmf_aux      : cmf_login_rec; "cmf login info"
  defaults,                     "cmf user's defaults"
  current_file : cmf_file_rec;  "cmf user's file"
  special      : special_ch;
  special_dl   : char_set;	"set of special downline chars initted by
				init_special_dl_ch_set"
  device_out,
  device_in    : dev_rec;	"contains device and i/o information"
  needle       : needle_record;
  sys_param    : system_param ; "for computing checksums"


(* 	Records sent to the downline loader are saved, (along with the	*)
(*	time to expire, address) in dl_recs indexed by downline_pointer.*)
(*	An empty space in dl_recs is indicated by pending = FALSE.	*)

  dl_recs      : array [1..max_dl_records] of
    record
      pending	: boolean (* TRUE if there is an unanswered record here *) ;
      data	: downline_record (* characters sent in downline record *) ;
      address	: integer (* address of record sent *) ;
      time_expired	: integer (* time data will timeout *)
    end (* dl_recs *) ;


  pending_count : integer (* count of pending downline answers *) ;


(* set to TRUE by check_for_stop and rpt_nd if the user		*)
(* circuit has been zapped or there has been a <break> input	*)
  user_interrupt : boolean;
!
"
		miscellaneous routines
"


(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				output_ioresult				*)
(*									*)
(*	This routine outputs res to the terminal.			*)
(*									*)
(************************************************************************)

procedure output_ioresult(
      res		: ioresult);

begin
  form.start;
  form.status_name (res);
  if res = DISK_FULL
  then
    begin 
      form.string (' FOR A FILE OF \');
      form.number (nblks, DECIMAL);
      form.string (' PAGES\ ')
    end;
  form.write_line (term, temp_ans)
end (* output_ioresult *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				type_error				*)
(*									*)
(*	This routine checks "res" and reports errors to user.		*)
(*									*)
(************************************************************************)

procedure type_error(
      preamble	: term_chs;
      res	: ioresult);

var
  drive_status : ioresult;

begin
  if res <> COMPLETE
  then
    begin
      temp_ans := COMPLETE;
      form.start;
      form.string ('ERROR ON \');
      form.string (preamble);
      form.string (prompt_m);
      form.write_string (term, temp_ans);
      output_ioresult(res)
    end;
    if (res = BAD_DISK) and (this_cmd.prg_name = cload)
    then
      begin
        disk_mon[device_in.unit].io_status(drive_status);
	form.simple_message('DISK INPUT ERROR:  \');
        form.status_name(drive_status);
        form.write_line(term, tt_ans)
      end;
    if (res = BAD_DISK) and (device_out.kind = DISK)
    then
      begin
        disk_mon[device_out.unit].io_status(drive_status);
	form.simple_message('DISK OUTPUT ERROR:  \ ');
        form.status_name(drive_status);
        form.write_line(term, tt_ans)
      end
end (* type_error *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				rpt_dv_err				*)
(*									*)
(*	Report disk or tape i/o error as returned in arg2.		*)
(*									*)
(************************************************************************)

procedure rpt_dv_err (
      preamble	: term_chs;
      res	: ioresult);
 
begin
  type_error(preamble, res);
  if (res <> COMPLETE) and (io_error <= 24)
  then
    begin
      form.start;
      case io_error of
	0:  (* null *) ;
	1:  form.string ('(ISIS) BAD MEMORY ADDRESS\');
	2:  form.string ('(ISIS) NO ACCESS ALLOWED TO THIS UNIT\');
	3:  form.string ('(ISIS) MEMORY READ/WRITE PROTECTION FAILURE\');
	4:  form.string ('(ISIS) VIRTUAL BLOCK OUT OF ALLOWED AREA ON DISK\ ');
	5:  form.string ('(ISIS) KERNEL TABLES VBN PAST EOV\');
	6:  form.string ('(ISIS) KERNEL TABLES CYLINDER OVERFLOW PAST EOV\');
	7:  form.string ('DISK SEEK ERROR\');
	8:
	  begin
	    form.string('CONTROLLER ERROR: \ ');
	    form.number(ctr_stat, HEX)
	  end;
	9:  form.string ('ABORT BY (DDT) QUIT char\ ');
	10: form.string ('ODD BYTE COUNT\ ');
	11: form.string ('INVALID CYLINDER OVERFLOW INDICATION\ ');
	12: form.string ('DEFECTIVE SECTOR IN ALTERNATE CYLINDER\ ');
	13: form.string ('DEFECTIVE SECTOR AND NO ALTERNATES\ ');
	14: form.string ('CYLINDER MAP UNREADABLE\');
	15: form.string ('DEFECTIVE CYLINDER - ALTERNATE ASSIGNED\');
	16: form.string ('END OF FILE DETECTED\ ');
	17: form.string ('END OF VOLUME DETECTED\ ');
	18: form.string ('DEVICE UNAVAILABLE \');
	19: form.string ('WRITE ATTEMPT ON PROTECTED VOLUME\');
	20: form.string ('UNIT ATTACHED BUT IS WRITE-PROTECTED\ ');
	21: form.string ('UNIT ATTACHED TO ANOTHER SLOT\');
	22: form.string ('OPERATION IGNORED FOR THIS TYPE UNIT\ ');
	23: form.string ('SELECTOR OR DEVICE TIMEOUT\ ');
	24: form.string ('RECOVERED ERROR\')
      end (* case *) ;
      form.write_line (term, temp_ans)
    end
end (* rpt_dv_err *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*			rpt_all_errs					*)
(*									*)
(*	Report all errors to user.					*)
(*									*)
(************************************************************************)

procedure rpt_all_errs;

begin
  if file_ans <> COMPLETE
  then rpt_dv_err('DEVICE UNIT\', file_ans); file_ans := COMPLETE;
  if res_in <> COMPLETE
  then type_error('INPUT\', res_in); res_in := COMPLETE;
  if res_out <> COMPLETE
  then type_error('OUTPUT\ ', res_out); res_out := COMPLETE;
  if aux_ans <> COMPLETE
  then type_error('CIRCUIT\', aux_ans); aux_ans := COMPLETE;
  if (tt_ans <> COMPLETE) and (tt_ans <> BREAK_KEY)
  then
    begin
      type_error('TERMINAL\ ', tt_ans);
      tt_ans := COMPLETE
    end
end (* rpt_all_errs *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				all_ok					*)
(*									*)
(*	This is a boolean function that returns TRUE if all ioresults	*)
(*	are complete.							*)
(*									*)
(************************************************************************)

function all_ok : boolean ;

begin
  all_ok := (file_ans=complete) and (aux_ans=complete) and (tt_ans=complete) 
    and (res_in=complete) and (res_out=complete)
end (* all_ok *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				rd_cir					*)
(*									*)
(*	If there is a circuit, read chars.				*)
(*									*)
(************************************************************************)

procedure rd_cir(time_out : integer;
		n_chars : integer;
		var arr : elf_rec;
		var res : ioresult);

begin
  if not gt_aux_cir
  then res := failure
  else
    begin
      cirio.rd_cr_chs(time_out, n_chars, arr, res);
      if res = failure
      then gt_aux_cir := FALSE
    end
end (* rd_cir *) ;




(**********************   control   (miscellaneous routines)*************)
(*									*)
(*				zap_tty_circuit				*)
(*									*)
(*	Zap the specified circuit if there is one.			*)
(*									*)
(************************************************************************)

procedure zap_tty_circuit;

begin
  if gt_tty_cir
  then
    begin
      term.send_y_get_o_ball (tt_ans);
      term.zap_cir(temp_ans)
    end;
  gt_tty_cir := FALSE
end (* zap_tty_circuit *) ;




(**********************   control   (miscellaneous routines)*************)
(*									*)
(*				zap_aux_circuit				*)
(*									*)
(*	Zap the specified circuit if there is one.			*)
(*									*)
(************************************************************************)

procedure zap_aux_circuit;

begin
  if gt_aux_cir then cirio.zap_cir(temp_ans);
  gt_aux_cir := FALSE
end (* zap_aux_circuit *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				snd_cir_ch				*)
(*									*)
(*	Send the char "slv_ch" over the aux circuit.			*)
(*									*)
(************************************************************************)

procedure snd_cir_ch(slv_ch : char);

begin
  term_line.chars[1] := slv_ch;
  term_line.length := 1;
  cirio.wr_line_rec (term_line, NO_CR, aux_ans)
end (* snd_cir_ch *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				find_char				*)
(*									*)
(*	This routine loops on a slot circuit until "ck_char" found;	*)
(*	used to find the  prompt character, etc. in ISIS.		*)
(*									*)
(************************************************************************)

procedure find_char(
      ck_char	: char);

begin
  if aux_ans = COMPLETE
  then
    repeat
      rd_cir(30, 1, cir, aux_ans)
    until (cir.chars.file_data[1] = ck_char) or (aux_ans <> COMPLETE)
end (* find_char *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				reset_all				*)
(*									*)
(*	Reset all variables for new user.				*)
(*									*)
(************************************************************************)

procedure reset_all;

begin
  zap_tty_circuit;
  zap_aux_circuit;
  device_in.kind  := ILLEGAL_DEVICE;
  device_out.kind := ILLEGAL_DEVICE;

  with last_aux.info do
    begin
      userlen := 0;
      g_userlen := 0;
      neighbor := 0;
      krnl_host := 0;
      mxp_load := FALSE
    end;
  with aux.info do
    begin
      userlen := 0;
      g_userlen := 0;
      non_standard := FALSE;
      g_x75 := FALSE;
      neighbor := 0;
      krnl_host := 0;
      mxp_load := FALSE
    end;
  image_form := TRUE;	"default is no compression in elf"
  cmf_host := TRUE;   "if user configured CMF, default is CMF and not TYMCOM-X"
  netport_host := 0;
  file_ans := COMPLETE;
  aux_ans := COMPLETE;
  tt_ans := COMPLETE
end (* reset_all *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*			        input_is_all				*)
(*									*)
(************************************************************************)

function input_is_all(
      start_char : integer) : boolean;

begin
  input_is_all := (term_line.length >= start_char + 2) and
    (term_line.chars[start_char] = 'A') and
    (term_line.chars[start_char + 1] = 'L') and 
    (term_line.chars[start_char + 2] = 'L')
end (* input_is_all *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				input_number				*)
(*									*)
(*	General routine that prompts "num_prompt", and inputs a number	*)
(*	into "value" in base "base".					*)
(*									*)
(************************************************************************)

procedure input_number(
      num_prompt	: term_chs;
      all_allowed	: boolean (* TRUE if 'ALL' is an acceptable input *) ;
      base		: integer;
  var num_input		: integer);

var
  temp : integer;

begin
  if all_ok
  then
    begin
      gotit := FALSE;
      term.write_message_string (NUM_PROMPT, tt_ans);
      repeat
	term.read_line(term_line, tt_ans);
	ptr := 1;
	if tt_ans = COMPLETE
	then
	  if all_allowed and input_is_all(1)
	  then gotit := TRUE
	  else
	    begin
	      cmn.input_num(base, term_line, ptr, num_input, gotit);
	      if not gotit
	      then term.write_message_string ('ERROR, RE-ENTER: \', tt_ans)
	   end
      until gotit or (tt_ans <> COMPLETE)
    end
end (* input_number *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*			   input_number_or_all				*)
(*									*)
(*	General routine that prompts "num_prompt", and inputs a number	*)
(*	into "value" in base "base".  "ALL" is an acceptable input.	*)
(*									*)
(************************************************************************)

procedure input_number_or_all(
      num_prompt	: term_chs;
      base		: integer;
  var all_flag		: boolean;
  var value		: integer);

begin
  input_number(num_prompt, TRUE, base, value);
  all_flag := input_is_all(1)
end (* input_number_or_all *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				store_block				*)
(*									*)
(*	Move a disk block of one type into a disk block of another type.*)
(*									*)
(************************************************************************)

procedure store_block (
      from_block	: univ disk_block;
  var to_block		: univ disk_block);

begin
  to_block := from_block
end (* store_block *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				left_half				*)
(*									*)
(*	This routine returns the left half of an integer as an integer.	*)
(*									*)
(************************************************************************)

function left_half (whole : univ string4) : integer;

begin
  left_half := ord(whole[1])*256 + ord(whole[2])
end (* left_half *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				right_half				*)
(*									*)
(*	This routine returns the right half of an integer as an integer.*)
(*									*)
(************************************************************************)

function right_half (whole : univ string4) : integer;

begin
  right_half := ord(whole[3])*256 + ord(whole[4])
end (* right_half *) ;



(******************************  control  *******************************)
(*									*)
(*				get_integer				*)
(*									*)
(************************************************************************)

procedure get_integer(var int : univ string4;
		from_array : elf_chs;
		temp_index : integer);

begin
  int[1] := from_array[temp_index];
  int[2] := from_array[temp_index+1];
  int[3] := from_array[temp_index+2];
  int[4] := from_array[temp_index+3]
end (* get_integer *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				wd_to_int				*)
(*									*)
(*	This routine returns an integer value of the 4 chars		*)
(*	from "from_array" indexed by "t_index".				*)
(*									*)
(************************************************************************)

function wd_to_int(from_array : elf_chs;
		tmp_index : integer) : integer;

var
  temp_int : integer;

begin
  get_integer(temp_int, from_array, tmp_index);
  wd_to_int := temp_int
end (* wd_to_int *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				int_to_wd				*)
(*									*)
(*	This routine converts "int" into the 4 characters,		*)
(*	"ch1", "ch2", "ch3", "ch4".					*)
(*									*)
(************************************************************************)

procedure int_to_wd(int : univ string4;
		var ch1, ch2, ch3, ch4 : char);

var
  temp : integer;

begin
  ch1 := int[1];
  ch2 := int[2];
  ch3 := int[3];
  ch4 := int[4]
end (* int_to_wd *) ;



(************************   control   (miscellaneous routines)***********)
(*									*)
(*				int_to_chs				*)
(*									*)
(*	This routine converts "elf_int" to a string in "e_blk"		*)
(*	with starting index of "elf_index".				*)
(*									*)
(************************************************************************)

procedure int_to_chs(var e_blk : elf_chs;
		elf_int, elf_index : integer);

begin
  int_to_wd(elf_int, e_blk[elf_index],
    e_blk[elf_index+1], e_blk[elf_index+2], e_blk[elf_index+3])
end (* int_to_chs *) ;



(*****************************  control  ********************************)
(*									*)
(*				get_half				*)
(*									*)
(************************************************************************)

procedure get_half(var int : univ string4;
		from_array : elf_chs;
		tmp_index : integer);

begin
  int[1] := zero;
  int[2] := zero;
  int[3] := from_array[tmp_index];
  int[4] := from_array[tmp_index+1]
end (* get_half *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				make_half				*)
(*									*)
(*	This routine returns the value of a word made up from		*)
(*	two chars.							*)
(*									*)
(************************************************************************)

function make_half(from_array : elf_chs;
		tmp_index : integer) : integer;

var
  temp_int : integer;

begin
  get_half(temp_int, from_array, tmp_index);
  make_half := temp_int
end (* make_half *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				mv_elf_chs				*)
(*									*)
(*	Move "num_to_move" chars from "e_from" indexed by "f_index"	*)
(*	to "e_to" indexed by "to_index".				*)
(*									*)
(************************************************************************)

procedure mv_elf_chs(num_to_move : integer;
		e_from : elf_chs;
		f_index : integer;
		var e_to : elf_chs;
		to_index : integer);

begin
  for n := 0 to num_to_move-1 do
    e_to[to_index+n] := e_from[f_index+n]
end (* mv_elf_chs *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				sv_same_ch				*)
(*									*)
(*	Save "number_to_save" "char_to_save"'s in "e_blk" starting at	*)
(*	"start_index".							*)
(*									*)
(************************************************************************)

procedure sv_same_ch(
  var e_blk		: elf_chs (* array to save character in *) ;
      start_index	: integer (* starting index into e_blk *) ;
      char_to_save	: char (* character to save *) ;
      number_to_save	: integer (* number of charactrs to save *));

var
  temp : integer;

begin
  for temp := start_index to (start_index + number_to_save - 1) do
    e_blk[temp] := char_to_save
end (* sv_same_ch *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				tell_fmt				*)
(*									*)
(*	This routine tells the user the format for the data he has	*)
(*	entered wrong.  "in_chs" describes format.			*)
(*									*)
(************************************************************************)

procedure tell_fmt(in_chs : term_chs;
		var result : ioresult);

begin
  if result = COMPLETE
  then
    begin
      term.write_newline (result);
      term.write_message_line ('FORMAT IS: \', result);
      term.write_message_line (in_chs, result);
      term.write_message_string (reentr_msg, result)
    end
end (* tell_fmt *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				set_file_type				*)
(*									*)
(*	Return file type according to cmd and sub-cmd.			*)
(*									*)
(************************************************************************)

procedure set_file_type;

begin
  elf_f_type := ERROR_FILE;	"in case we don't find a cmd"
  case this_cmd.prg_name of
    CCREATE:
      case this_sub.sub_prg of
	snode: elf_f_type := ND_LD_FILE;
	sslot: elf_f_type := SL_LD_FILE;
	spart: elf_f_type := PT_LD_FILE
      end (* ccreate *) ;
    CDUMP:
      case this_sub.sub_prg of
	snode: elf_f_type := ND_DP_FILE;
	sslot: elf_f_type := SL_DP_FILE;
	spart: elf_f_type := PT_DP_FILE
      end (* cdump *)
  end
end (* set_file_type *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*				file_type				*)
(*									*)
(*	This routine inputs "type_on_device" and outputs "file_type".	*)
(*									*)
(************************************************************************)

function file_type(type_on_device : integer) : integer;

begin
  if (type_on_device < ND_LD_FILE) or (type_on_device > ERROR_FILE)
  then file_type := ERROR_FILE
  else file_type := type_on_device
end (* file_type *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*			 type_file_address				*)
(*									*)
(*	Output "file_address" if non-zero, and device is disk.		*)
(*									*)
(************************************************************************)

procedure type_file_address (
      dev		: dev_rec;
      file_address	: integer);

begin
  if dev.kind = DISK
  then
    if file_address <> 0
    then
      begin
	form.number_message (F_ADDR_M, file_address, DECIMAL);
	form.write_line (term, tt_ans)
      end
end (* type_file_address *) ;



(*******************   control   (miscellaneous routines)****************)
(*									*)
(*			   type_disk_address				*)
(*									*)
(*	Output the "physical_address" and "file_sz" of the file or	*)
(*	device.								*)
(*									*)
(************************************************************************)

procedure type_disk_address (
      dev		: dev_rec;
      physical_address	: integer;
      file_sz		: integer);

begin
  if dev.kind = DISK
  then
    begin
      form.number_message (
	'PHYSICAL SECTOR ADDRESS: \', physical_address, HEX);
      form.string ('    NUMBER OF SECTORS: \');
      form.number (file_sz, DECIMAL);
      form.write_line (term, tt_ans)
    end
end (* type_disk_address *) ;



(************************   control   (miscellaneous routines)***********)
(*									*)
(*				check_for_stop				*)
(*									*)
(*	This function returns TRUE (and sets user_interrupt to TRUE)	*)
(*	if an unusual ioresult is recieved from the terminal		*)
(*	(possible break_key, failure, etc.)				*)
(*									*)
(************************************************************************)

function check_for_stop : boolean;

var
  t1,
  t2 : integer;

begin
  term.any_input(0, t1, t2, tt_ans);
  if tt_ans = COMPLETE
  then check_for_stop := FALSE
  else
    begin
      check_for_stop :=  TRUE;
      user_interrupt := TRUE
    end
end (* check_for_stop *) ;
!
      (*     DEVS.ELF Updated 17-Sep-86 at 12:20 by Raffo    *)

(************************************************************************)
(*									*)
(*									*)
(*									*)
(************************************************************************)


(*****************************  control   (device routines)  ************)
(*									*)
(*				attach_dev				*)
(*									*)
(*	If disk, read first 4 sectors on disk into "elf_blk" .		*)
(*									*)
(************************************************************************)

procedure attach_dev(
  var dev	: dev_rec;
  var res	: ioresult);

begin
  case dev.kind of
    TAPE:
      begin
	allocate_tape.assign_unit(dev.unit, res);
	if res = COMPLETE
	then
	  begin
	    dev.state := DEVICE_ASSIGNED;
	    devs.attach(dev, io_error, ctr_stat);
	    if dev.result = COMPLETE
	    then dev.state := DEVICE_ASSIGNED_AND_ATTACHED;
	    res := dev.result
	  end
      end (* TAPE *) ;

    DISK:
      begin
      if dev.unit > DISK_LIMIT
      then res := ILLEGAL_DEV
      else
	begin
	  dev.disk_operator.set_unit (dev.unit);
	  res := COMPLETE
	end (* DISK *)
      end (* DISK *)
  end (* case *)
end (* attach_dev *) ;

!
      (*     DEVS.ELF   *)

(*****************************  control   (device routines)  ************)
(*									*)
(*				detach_dev				*)
(*									*)
(************************************************************************)

procedure detach_dev(
  var dev	: dev_rec);

begin
  if dev.kind <> ILLEGAL_DEVICE (* already detached *)
  then
    if dev.state <> DEVICE_UNUSED
    then
      case dev.kind of
	TAPE:
	  begin
	    if dev.state = DEVICE_ASSIGNED_AND_ATTACHED
	    then
	      begin
		devs.detach(dev, io_error, ctr_stat);
		dev.state := DEVICE_ASSIGNED
	      end;
	    if dev.state = DEVICE_ASSIGNED
	    then allocate_tape.deassign_unit(dev.unit)
	end (* TAPE *) ;

	DISK:
	  case dev.state of
	    OLD_FILE_OPENED:
	      dev.disk_operator.close;

	    NEW_FILE_OPENED:
	      begin
		dev.disk_operator.adjust_file_id (
		  adjusted_file_size, dev.disk_operator.file_mark);
		dev.disk_operator.close
	      end
	  end (* case *)
      end (* case *) ;

  dev.state := DEVICE_UNUSED;
  dev.kind  := ILLEGAL_DEVICE
end (* detach_dev *) ;

!
      (*     DEVS.ELF   *)

(*****************************  control   (device routines)  ************)
(*									*)
(*			      pos_device				*)
(*									*)
(*	Position tape unit.						*)
(*									*)
(************************************************************************)

procedure pos_device(var dev : dev_rec;
		position_op : integer;
		var res : ioresult);

begin
  with dev do
    if kind = tape then
      begin
	devs.position_drive(position_op, dev, io_error, ctr_stat);
	res := result
      end
end (* pos_device *);


(*****************************  control   (device routines)  ************)
(*									*)
(*			rew_device					*)
(*									*)
(*	Rewind a tape.							*)
(*									*)
(************************************************************************)

procedure rew_device(var dev : dev_rec);

var
  info : disk_tape_information;

begin
  if dev.kind = TAPE
  then
    begin
      pos_device(dev, tape_rewind, file_ans);
      if file_ans = COMPLETE
      then	 "wait until rewind complete"
	begin
	  repeat
	    devs.drive_status(dev, info, io_error, ctr_stat);
	    wait
	   until check_for_stop or (dev.result <> COMPLETE) or
	     ((info.device_status div 2) mod 2 = 1);
	   if (dev.result = END_FILE) or (dev.result = START_MEDIUM)
	   then dev.result := COMPLETE
	 end
    end
end (* rew_device *);

!
      (*     DEVS.ELF   *)

(*****************************  control   (device routines)  ************)
(*									*)
(*				rd_device				*)
(*									*)
(*	Read a file from either disk or tape.				*)
(*									*)
(************************************************************************)

procedure rd_device (
  var dev	: dev_rec;
      page_no	: integer;
  var in_blk	: elf_rec;
  var res	: ioresult);

begin
  if dev.kind = DISK
  then dev.page_addr := page_no - dev.disk_operator.start_address;
  devs.read_drive(dev, io_error, ctr_stat);
  res := dev.result;
  in_blk := dev.elf_data
end (* rd_device *);



(*****************************  control   (device routines)  ************)
(*									*)
(*				wr_device				*)
(*									*)
(*	Write a file to either disk or tape.				*)
(*									*)
(************************************************************************)

procedure wr_device (
  var dev	: dev_rec;
      page_no	: integer;
  var in_blk	: elf_rec;
  var res	: ioresult);

begin
  dev.elf_data := in_blk;
  if dev.kind = DISK
  then dev.page_addr := page_no - dev.disk_operator.start_address;
  devs.write_drive(dev, io_error, ctr_stat);
  res := dev.result
end (* wr_device *) ;
!
      (*     DEVS.ELF   *)

"
		disk routines
"

(***********************  control   (disk routines)  ********************)
(*									*)
(*			allocate					*)
(*									*)
(*	Reserve disk space for a file.  Return address in		*)
(*	output_disk_page.						*)
(*									*)
(************************************************************************)

procedure allocate(
      file_size	: file_sector_size );

var
  file_mark	: file_mark_element ;
  status	: file_allocation_status;

begin
  mark_mon.assign_mark(file_mark);
  device_out.disk_operator.create (file_mark, file_size, NO_WAIT, status);

  case status of
    F_A_DISK_FAILURE:
      file_ans := BAD_DISK;
    AWAITING_CONDENSE:
      file_ans := DISK_CONDENSING;
    FILE_ALREADY_EXISTS:
      file_ans := DISK_FILE_MARK_ERROR;
    DIRECTORY_FULL:
      file_ans := MX_FILES;
    NEEDS_DELETE:
      file_ans := DISK_DELETE_IN_PROGRESS;
    NEEDS_CONDENSE:
      file_ans := DISK_CONDENSE_NEEDED;
    NO_ROOM:
      file_ans := DISK_FULL;
    F_A_COMPLETE:
      begin
	file_ans           := COMPLETE;
	device_out.state   := NEW_FILE_OPENED;
	adjusted_file_size := file_size;
	output_disk_page   := device_out.disk_operator.start_address
      end (* F_A_COMPLETE *)
  end (* case *)
end (* allocate *) ;

!
      (*     DEVS.ELF   *)

(*****************************  control   (disk routines)  **************)
(*									*)
(*			set_up_disk_file				*)
(*									*)
(*	Allocate and set up a disk file of nblks ELF sectors and ncksms	*)
(*	extra checksum sectors.						*)
(*									*)
(************************************************************************)

procedure set_up_disk_file(
      ncksms	: integer;
  var header	: univ file_header_record);

begin
  allocate(nblks);   "allocate total number of sectors"
  if file_ans = COMPLETE
  then 	"set up disk ptrs in file"
    begin
      output_start_page := output_disk_page;     "save start page"
      n := output_disk_page + ncksms;
      header.start_data_sector := n;
      output_end_page := output_disk_page+nblks (* save end block *) ;
      header.end_sector := output_end_page-1;
      wr_device(device_out, output_start_page, cir_ans, file_ans);
      sv_same_ch(
	device_out.elf_data.chars.file_data, 5, zero, MX_ELF_DATA - 4);
      n := output_disk_page + PGS_IN_ELF;
      "clear any additional checksum pages now"
      nblks := ncksms;	"pick up number of checksum blocks"
      while (nblks > PGS_IN_ELF) and (file_ans = COMPLETE) do
	begin
	  wr_device(device_out, n, device_out.elf_data, file_ans);
	  nblks := nblks - PGS_IN_ELF;
	  n := n + PGS_IN_ELF
	end;
      store_block (header, device_out.cksum_blk.chars.file_data);
      device_out.cksum_dex := HD_CKSM_X - BYTS_IN_WD;
      device_out.cksum_page := output_disk_page;
      output_disk_page := output_disk_page + ncksms
    end
end (* set_up_disk_file *) ;

!
      (*     DEVS.ELF   *)

(*****************************  control   (disk routines)  **************)
(*									*)
(*				set_up_file				*)
(*									*)
(************************************************************************)

procedure set_up_file;

var
  ncksms	: integer;

begin
  if all_ok
  then
    begin
      (* First determine number of bytes in an elf block *)
      if image_form
      then nchars := MX_ELF_DATA
      else nchars := MX_SL_DATA;
      (* Compute number of pages required for data *)
      nblks := (exp_b_ct+nchars-1) div nchars;
      (* Compute number of cksum entries not handled by dir block *) 
      n := nblks - HD_CKSMS;
      (* Compute actual disk pages *)
      nblks := nblks * PGS_IN_ELF;
      (* Compute number of checksum blocks required *)
      ncksms := PGS_IN_ELF;
      (* Compute number of cksums in additional blocks. *)
      nchars := (HD_CKSM_END_X-HD_FIRST_FILE_X) div BYTS_IN_WD;
      while n > 0 do
        begin
          ncksms := ncksms + PGS_IN_ELF (* Count page of checksums *) ;
          n := n - nchars
        end (* while *) ;
      nblks := nblks + ncksms;
      case device_out.kind of
	DISK:
	  set_up_disk_file(ncksms, cir_ans.chars.file_data);
	TAPE:
	  (* save no. of pages and checksum pages in tape header *)
	  begin
	    int_to_wd (
	      nblks,
	      cir_ans.chars.file_data[HD_DSK_SIZE],
	      cir_ans.chars.file_data[HD_DSK_SIZE + 1],
	      cir_ans.chars.file_data[HD_DSK_SIZE + 2],
	      cir_ans.chars.file_data[HD_DSK_SIZE + 3]);
	    int_to_wd(ncksms,
	      cir_ans.chars.file_data[HD_CKSM_SIZE],
	      cir_ans.chars.file_data[HD_CKSM_SIZE + 1],
	      cir_ans.chars.file_data[HD_CKSM_SIZE + 2],
	      cir_ans.chars.file_data[HD_CKSM_SIZE + 3]);
	    wr_device(device_out, output_start_page, cir_ans, file_ans);
	  end (* TAPE *)
      end (* case *)
    end
end (* set_up_file *) ;
!
      (*     XFR1.ELF Updated 7-Jun-85 at 10:19 by Raffo    *)

(************************************************************************)
(*									*)
(*									*)
(*									*)
(************************************************************************)



(****************************   xfr   (miscellaneous routines)***********)
(*									*)
(*				rpt_xfr_er				*)
(*									*)
(*	If there has been an error on input or output during the	*)
(*	transfer (create/load) just ended, tell the user what		*)
(*	happened.							*)
(*									*)
(************************************************************************)

procedure rpt_xfr_er;

begin
  with this_cmd do
    begin
      if (prg_name = ccreate) or (prg_name = cdump)
      then type_error(input_m, res_in)
      else rpt_dv_err(input_m, res_in);
      if prg_name = cload
      then type_error(output_m, res_out)
      else rpt_dv_err(output_m, res_out)
    end (* with *)
end (* rpt_xfr_er *);



(****************************   xfr   (miscellaneous routines)***********)
(*									*)
(*			     elf_cksm					*)
(*									*)
(*	This routine returns the vertical checksum for "last_e_addr"	*)
(*	chars in "from_array" in vck, the diagonal checksum in dck.	*)
(*									*)
(************************************************************************)

procedure elf_cksm(var from_array : elf_chs;
		last_e_addr : integer);

begin
  with sys_param do
    begin
      operation := system_checksum;
      arg1 := last_e_addr;
      io(from_array, sys_param, system, 0);
      vck := arg1;
      dck := arg2
    end
end (* elf_cksm *);



(****************************   xfr   (miscellaneous routines)***********)
(*									*)
(*			      rpt_nd					*)
(*									*)
(*	Tell user how many records have been sent, recieved		*)
(*	sucessfully and recieved unsucessfully.				*)
(*									*)
(************************************************************************)

procedure rpt_nd;

begin
  with this_cmd, this_sub do
    if all_ok and (recs_sent > 0) and ((prg_name = CDUMP) or
      (image_form and (prg_name = CCREATE)) or
      ((prg_name = CLOAD) and (sub_prg = SNODE))) then
      begin
	form.simple_message ('SENT:\');
	form.format_number (recs_sent, DECIMAL, 8);
	form.string ('  RECV:\');
	form.format_number (good_recs, DECIMAL, 8);
	form.string ('  RESENT:\');
	form.format_number (resent_recs, DECIMAL, 8);
	if late_recs > 0
	then
	  begin
	    form.string ('  LATE:\');
	    form.format_number (late_recs, DECIMAL, 8)
	  end;
	form.write_line (term, tt_ans);
	if tt_ans <> COMPLETE
	then user_interrupt := TRUE
      end
end (* rpt_nd *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				xor_hx_40				*)
(*									*)
(*	Xor "esc_char" with a hex 40.					*)
(*									*)
(************************************************************************)

procedure xor_hx_40(var esc_char : char);

begin
  n := ord(esc_char);
  cmn.xor(n, hex40);
  esc_char := chr(n)
end (* xor_hx_40 *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				sv_sl_cmd				*)
(*									*)
(*	This routine is used to save byte count for			*)
(*	slot records in "cir_cmd".  Chars should be escaped if	 	*)
(*	necessary.							*)
(*									*)
(************************************************************************)

procedure sv_sl_cmd(numb : integer);

var
  temp : integer;
  chs : string4;

begin
  int_to_wd(numb, chs[1], chs[2], chs[3], chs[4]);
  for temp := 1 to 4 do
    begin
      if chs[temp] in special_dl
      then
        begin
	  cir_cmd.length := cir_cmd.length + 1;
	  cir_cmd.chars.file_data[cir_cmd.length] := ESCAPE_CH;
	  xor_hx_40(chs[temp])
        end;
      "save original char or xor'd char"
      cir_cmd.length := cir_cmd.length + 1;
      cir_cmd.chars.file_data[cir_cmd.length] := chs[temp]
    end
end (* sv_sl_cmd *);



(****************************   xfr   (miscellaneous routines)***********)
(*									*)
(*				set_special				*)
(*									*)
(*	Check "chio" to see if it should be escaped or needs to be	*)
(*	zero or ones cmped.  Return "type_of_special" as type of	*)
(*	special character required, and "sp_ch" as either the		*)
(*	appropriate compression char or the escape char.		*)
(*	Used for both load node and load slot procedures.		*)
(*									*)
(************************************************************************)

procedure set_special(var type_of_special : special_ch;
		var sp_ch : char);

begin
  sp_ch := ones;
  type_of_special := nt_special;
  if chio = ZERO
  then
    begin
      type_of_special := zero_cmp;
      sp_ch := zro_cmp_ch
    end
  else
    if chio = ONES
    then
      begin
        type_of_special := ons_cmp;
	sp_ch := ons_cmp_ch
      end
    else
      if chio in special_dl
      then
        begin
	  type_of_special := escaped;
	  sp_ch := escape_ch
	end
end (* set_special *);



(****************************   xfr   (miscellaneous routines)***********)
(*									*)
(*				rst_org_ch				*)
(*									*)
(*	Restore original character according to "c_char" (compression	*)
(*	character).							*)
(*									*)
(************************************************************************)

function rst_org_ch(c_char : char) : char;

begin
  if c_char = zro_cmp_ch
  then rst_org_ch := zero
  else rst_org_ch := ones
end (* rst_org_ch *);
!
      (*     XFR2.ELF Updated 23-Aug-85 at 16:23 by Raffo    *)

(************************************************************************)
(*									*)
(*	Object File Routines (from TYMCOM-X)				*)
(*									*)
(************************************************************************)




(****************************   xfr   (object file routines)*************)
(*									*)
(*				chk_sp_ch				*)
(*									*)
(*	Return "kind_special" according to the type of character	*)
(*	"chio" is.							*)
(*									*)
(************************************************************************)

function chk_sp_ch : special_ch;

begin
  chk_sp_ch := nt_special;
  if this_cmd.prg_name <> CDUMP
  then
    if chio = ZRO_CMP_CH
    then chk_sp_ch := ZERO_CMP
    else
      if chio = ONS_CMP_CH
      then chk_sp_ch := ONS_CMP
      else
        if chio = ESCAPE_CH
	then chk_sp_ch := ESCAPED
end (* chk_sp_ch *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*				get_nxt_ch				*)
(*									*)
(*	If "zero_fill_count" is zero,					*)
(*	return next char from "c_array" indexed by "a_ptr" in		*)
(*	"r_char".  Increment "a_ptr" and decrement "chars_left".	*)
(*	Otherwise, return a zero in "r_char", decrementing 		*)
(*	"zero_fill_count" until it is zero.				*)
(*									*)
(************************************************************************)

procedure get_nxt_ch(var r_char : char;
		c_array : elf_chs;
		var a_ptr : integer);

begin
  if zero_fill_count = 0
  then
    begin
      r_char := c_array[ a_ptr ];
      a_ptr := a_ptr+ 1;
      chars_left := chars_left - 1
    end
  else
    begin
      r_char := zero;
      zero_fill_count := zero_fill_count - 1
    end
end (* get_nxt_ch *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*			get_nxt_cmp					*)
(*									*)
(*	Return compression char, "c_char" in "r_char",			*)
(*	decrement "c_ct" and reset "c_fl" if" "c_ct" is zero.		*)
(*									*)
(************************************************************************)

procedure get_nxt_cmp(var r_char,
		c_char : char;
		var c_ct : integer;
		var c_fl : boolean);

begin
  r_char := c_char;
  c_ct := c_ct - 1;
  if c_ct <= 0
  then c_fl := FALSE
end (* get_nxt_cmp *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*				set_cmp					*)
(*									*)
(*	This routine sets up variables to process compression data	*)
(*	and returns the appropriate compression char.			*)
(*									*)
(************************************************************************)

procedure set_cmp(var r_char : char;	"compression char to return"
		new_cmp_char : char;	"value of compression char to save"
		c_array : elf_chs;	"array to pickup ct from"
		var a_ptr : integer;	"ptr to c_array"
		var c_ch : char;	"var to save compression char in"
		var c_fl : boolean;	"compression fl"
		var c_ct : integer);	"compression count"

begin
  c_ch := new_cmp_char;		"save compression char"
  c_fl := TRUE;			"set fl"
  get_nxt_ch(temp_ch, c_array, a_ptr);	"get count"
  c_ct := ord(temp_ch);		"and save it"
  get_nxt_cmp(r_char, c_ch, c_ct, c_fl)
end (* set_cmp *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*				ob_rec_ok				*)
(*									*)
(*	This boolean function checks the sync chars from the obj cir	*)
(*	and returns "TRUE" if the next 2 chars are = -1.		*)
(*									*)
(************************************************************************)

function ob_rec_ok : boolean;

begin
  ob_rec_ok :=
    (cir.chars.file_data[OB_SYNC_X] = sync) and
    (cir.chars.file_data[OB_SYNC_X + 1] = sync) and
    (make_half(cir.chars.file_data, 3) = HALF_M_ONE)
end (* ob_rec_ok *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*				ans_elfslv				*)
(*									*)
(*	This routine tells elfslv whether the block it just sent	*)
(*	was acceptable or not.						*)
(*									*)
(************************************************************************)

procedure ans_elfslv(ans : char;
		var result : ioresult);

begin
  with cirio do
    begin
      cir_ans.chars.file_data[OB_SYNC_X] := SYNC;
      cir_ans.chars.file_data[OB_SYNC_X + 1] := SYNC;
      cir_ans.chars.file_data[OB_DCT_X] := ZERO;
      cir_ans.chars.file_data[OB_ANS_X] := ans;
      int_to_chs(cir_ans.chars.file_data, elf_addr, ob_addr_x);
      cir_ans.length := 8;
      wr_cir_line(cir_ans, result);
      if ans = forget_it
      then	 "input any chrs and clear circuit"
	begin
	  found := FALSE;
	  for n := 1 to 10 do wait;	"give chars a chance to come in"
	  repeat
	    rd_cir(20, mx_ob_chs, cir, result);
	    if ob_rec_ok and (result = timed_out) and
	      (make_half(cir.chars.file_data, 5) = 1)
	    then
	      begin
		found := TRUE;
		result := COMPLETE	"so circuit is not zapped"
	      end
	  until found or (result <> COMPLETE)
	end
    end
end (* ans_elfslv *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*				try_ob_blk				*)
(*									*)
(*	This routine tells elfslv to resend block just sent.		*)
(*	It also decrements "retry_count".				*)
(*									*)
(************************************************************************)

procedure try_ob_blk;

begin
  if res_in <> BAD_CKSM
  then retries := -1 (* any other error, do not re-try *)
  else
    begin
      resent_recs := resent_recs + 1;
      retries := retries - 1;
      temp_ans := COMPLETE;
      if retries < 0 			   (* if tried enuf, *)
      then ans_elfslv(forget_it, temp_ans) (* tell ELFSLV to stop *)
      else
        begin
	  term.write_newline (tt_ans);
          term.write_message_line ('BAD CHECKSUM - WILL RETRY\', tt_ans);
	  ans_elfslv(bad_blk, temp_ans) (* tell ELFSLV to resend block *)
	end
    end
end (* try_ob_blk *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*				chk_ob_blk				*)
(*									*)
(*	XFR has just input a block over the circuit...check sync	*)
(*	bytes, pick up data count and check checksum.			*)
(*									*)
(************************************************************************)

procedure chk_ob_blk;

var
  h_val : integer;
  count : integer;

begin
  recs_sent := recs_sent + 1;
  "if sync is ok, compute checksum for record"
  if (cir.chars.file_data[OB_SYNC_X] <> sync) or
     (cir.chars.file_data[OB_SYNC_X + 1] <> sync)
  then res_in := SYNC_ERROR	"bad sync"
  else
    begin
      "save count of data chars"
      chars_left := make_half(cir.chars.file_data, OB_DCT_X);
      elf_addr := wd_to_int(cir.chars.file_data, OB_ADDR_X);
      elf_cksm (
	cir.chars.file_data, OB_CKSM_X-1) (* compute - vertical checksum *);
      if wd_to_int(cir.chars.file_data, OB_CKSM_X) <> vck
      then
	begin
	  term.write_newline (tt_ans);
	  form.number_message ('computed cksum: \ ', vck, HEX);
	  form.string (' PDP-10 cksum: \');
	  form.number (wd_to_int(cir.chars.file_data, OB_CKSM_X), HEX);
	  form.write_line (term, tt_ans);
	  res_in := BAD_CKSM		(* bad checksum *)
	end
      else
	begin		"if checksum matches"
	  gotit := TRUE;
	  ans_elfslv(good_blk, res_in);  "tell slave"
	  good_recs := good_recs + 1;    "and check for end of segment"
	  if (last_addr <> elf_addr) and (last_addr <> -1)
	  then
	    if not image_form
	    then res_in := END_OF_SEG
	    else
	      begin	(* number of zeroes to fill in *)
		zero_fill_count := elf_addr-last_addr;
		elf_addr := last_addr
	      end
	end
    end
end (* chk_ob_blk *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*			chk_ob_err					*)
(*									*)
(*	There has been an error from slave, check for end of file or	*)
(*	TRUE error.							*)
(*									*)
(************************************************************************)

procedure chk_ob_err;

var
  errc : integer;
  h_val : integer;
  count : integer;

begin
  gotit := TRUE;			"probable message from elfslv"
  errc := make_half(cir.chars.file_data, 5);	"pick up error code"
  if ob_rec_ok
  then
    if errc = HALF_M_ONE
    then
      begin
	res_in := END_FILE;
	term_line.length := 1;
	term_line.chars[term_line.length] := ONE;	"ack slave"
	cirio.wr_line_rec(term_line, NO_CR, temp_ans)
      end
    else
      begin
	form.number_message ('ERROR FROM SLAVE: \ ', errc, DECIMAL);
	form.skip (2);
	case errc of
	  3:
	    begin
	      form.string ('UNRECOGNIZED CHARACTER: \ ');
	      form.number (ord(cir.chars.file_data[7]), DECIMAL)
	    end;
	  4: form.string (not_nib_m);
	  5: form.string ('ILLEGAL ADDRESS IN ANSWER\');
	  6: form.string (sys_err_m);
	  7: form.string ('BLOCK IO ERROR\ ');
	  8: form.string (not_equiv_m)
	end (* case *) ;
	form.write_line (term, tt_ans);
	res_in := OBJ_ERROR
      end
   else res_in := SYNC_ERROR;
end (* chk_ob_err *) ;



(****************************   xfr   (object file routines)*************)
(*									*)
(*				get_ob_blk				*)
(*									*)
(*	Input a block of data over the circuit from the tymcom-x.	*)
(*	Compute and check the checksum, return data in "cir",		*)
(*	number of data chars in "chars_left", and ioresult in		*)
(*	"res_in".							*)
(*									*)
(************************************************************************)

procedure get_ob_blk;

begin
  last_addr := elf_addr;	"save address of last data"
  retries := 5;	"if bad checksum, retry this many times"
  gotit := FALSE;
  res_in := COMPLETE;
  repeat
    if res_in = COMPLETE
    then rd_cir(60, MX_OB_CHS, cir, res_in)
    else
      if res_in = BAD_CKSM
      then
        begin	(* go back to bad checksum block *)
          res_in := COMPLETE;
	  o_elf_addr := elf_addr;	"address of block with bad checksum"
	  repeat
	    rd_cir(60, MX_OB_CHS, cir, res_in);
	    elf_addr := wd_to_int(cir.chars.file_data, OB_ADDR_X)
	  until (elf_addr = o_elf_addr) or (res_in <> COMPLETE)
        end;
    if res_in = COMPLETE
    then chk_ob_blk
    else
      if res_in = TIMED_OUT
      then chk_ob_err;
    if not gotit
    then try_ob_blk
  until gotit or (retries < 0) or (tt_ans <> COMPLETE);
  if recs_sent mod nd_rpt_ct = 0 then rpt_nd;
  obj_ch_ptr := ob_data_x;	"point to first data"
  cmp_fl := FALSE
end (* get_ob_blk *);



(****************************   xfr   (object file routines)*************)
(*									*)
(*				special_ob				*)
(*									*)
(*	This routine returns a special char to be used in place of	*)
(*	the char recieved.						*)
(*									*)
(************************************************************************)

procedure special_ob(var r_char :char;	"special char"
		special : special_ch;
		c_array : elf_chs;
		var a_ptr : integer;
		var c_ch : char;
		var c_fl : boolean;
		var c_ct  :integer);

begin
  case special of
    zero_cmp: set_cmp(r_char, zero, c_array, a_ptr, c_ch, c_fl, c_ct);
    ons_cmp: set_cmp(r_char, ones, c_array, a_ptr, c_ch, c_fl, c_ct);
    escaped: get_nxt_ch(r_char, c_array, a_ptr)
  end (* case *)
end (* special_ob *);
!
      (*   XFR3.ELF   Updated 15-Sep-86 at 17:52 by Raffo        *)

(************************************************************************)
(*									*)
(*			ELF output routines				*)
(*									*)
(************************************************************************)


(****************************   xfr   (ELF output routines)**************)
(*									*)
(*				init_elf				*)
(*									*)
(*	Clear "elf_blk", set up initial length of data and set up	*)
(*	address if slot file.						*)
(*									*)
(************************************************************************)

procedure init_elf;

begin
  sv_same_ch(elf_blk.chars.file_data, 1, ZERO, MX_ELF_DATA);
  elf_blk.chars.tape_cksm := 0;
  if not image_form
  then
    begin
      int_to_chs(elf_blk.chars.file_data, elf_addr, elf_addr_x);
      elf_blk.length := elf_data_x-1
    end
  else elf_blk.length := 0
end (* init_elf *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*			nd_to_wr					*)
(*									*)
(*	This function returns "TRUE" if there is data to be written	*)
(*	out in the elf buffer, else it returns "FALSE".			*)
(*									*)
(************************************************************************)

function nd_to_wr : boolean;

begin
  if image_form
  then nd_to_wr := elf_blk.length > 0
  else nd_to_wr := elf_blk.length > elf_data_x-1
end (* nd_to_wr *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*			    save_disk_checksum				*)
(*									*)
(*	Save checksum in checksum block, creating a			*)
(*	new block if necessary.						*)
(*									*)
(************************************************************************)

procedure save_disk_checksum(
      e_cksum		: integer;
  var dev		: dev_rec);

begin
  dev.cksum_dex := dev.cksum_dex + BYTS_IN_WD;
  if dev.cksum_dex >= HD_CKSM_END_X
  then
    begin
      dev.cksum_blk.chars.file_data[HD_CKSM_END_X] := ONES;
      dev.cksum_blk.chars.file_data[HD_CKSM_END_X+1] := ONES;
      dev.cksum_blk.chars.file_data[HD_CKSM_END_X+2] := ONES;
      dev.cksum_blk.chars.file_data[HD_CKSM_END_X+3] := ONES;
      wr_device(dev, dev.cksum_page, dev.cksum_blk, res_out);
      dev.cksum_page := dev.cksum_page + PGS_IN_ELF;
      dev.cksum_blk.chars.file_data[HD_SYNC_X] := SYNC;
      dev.cksum_blk.chars.file_data[HD_SYNC_X + 1] := SYNC;
      dev.cksum_blk.chars.file_data[HD_SYNC_X + 2] := TWO;
      dev.cksum_blk.chars.file_data[HD_SYNC_X + 3] := SYNC;
      dev.cksum_dex := 5;
      sv_same_ch(dev.cksum_blk.chars.file_data, 5, ZERO, HD_CKSM_END_X-5)
    end;
  if res_out = COMPLETE
  then int_to_chs(dev.cksum_blk.chars.file_data, e_cksum, dev.cksum_dex)
end (* save_disk_checksum *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*				output_elf_blk				*)
(*									*)
(*	Save checksum, write out data and increment "output_disk_page".	*)
(*									*)
(************************************************************************)

procedure output_elf_blk(
  var dev	: dev_rec;
  var data	: elf_rec);

begin
  case dev.kind of
    DISK:
      if output_disk_page < output_end_page
      then
	begin
	  save_disk_checksum (vck, dev);
	  wr_device(dev, output_disk_page, data, res_out);
	  output_disk_page := output_disk_page + PGS_IN_ELF
	end
      else res_out := END_FILE;
    TAPE:
      begin
	data.chars.tape_cksm := vck (* save checksum *) ;
	wr_device(dev, 0, data, res_out)
      end
  end (* case *)
end (* output_elf_blk *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*				wr_elf_blk				*)
(*									*)
(*	Save checksum, write out "elf_blk.chars.file_data" and reinit	*)
(*	variables.							*)
(*	If "w_fl" is TRUE, wait for write device to COMPLETE.		*)
(*									*)
(************************************************************************)

procedure wr_elf_blk;

begin
  if nd_to_wr
  then
    begin
      if not image_form
      then
	int_to_chs (
	  elf_blk.chars.file_data, elf_blk.length-(elf_data_x-1), elf_bct_x);
      elf_blk.length := mx_elf_crs;
      elf_cksm(elf_blk.chars.file_data, mx_elf_data)	(* compute vck *) ;
 (* save checksum, write block and increment output_disk_page *)
      output_elf_blk(device_out, elf_blk);
      init_elf
    end
end (* wr_elf_blk *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*				wr_f_file				*)
(*									*)
(*	Write a file header record that is a final file, then write	*)
(*	and end of file mark and backspace over the record just		*)
(*	written.  This is so the tape is positioned properly when	*)
(*	the next file is written.					*)
(*									*)
(************************************************************************)

procedure wr_f_file(
  var final_header	: elf_rec;
  var res		: ioresult);

begin
  if device_out.kind = TAPE
  then
    begin
      "set up file id to be 'final file'"
      form.simple_message (F_FILE_M);
      "set up file header in final_header"
      form.store_to_line_rec (term_line);
      cmn.make_file_hdr (
	f_file, FALSE, term_line, final_header.chars.file_data);
      wr_device(device_out, 0, final_header, res);
      if res = COMPLETE
      then pos_device(device_out, TAPE_WRITE_EOF, res);
      "backspace over e-o-f mark"
      if res = COMPLETE
      then pos_device(device_out, TAPE_BACK_FILE, res);
      "backspace over final file record header"
      if res = COMPLETE
      then pos_device(device_out, TAPE_BACK_FILE, res);
      if res = COMPLETE
      then pos_device(device_out, tape_forward_file, res);
      if res = END_MEDIUM
      then res := COMPLETE
    end
end (* wr_f_file *) ;



(****************************   xfr   (elf output routines)**************)
(*									*)
(*			cancel_file_creation				*)
(*									*)
(*	This routine deletes a partial file written to either		*)
(*	disk or tape.							*)
(*									*)
(************************************************************************)

procedure cancel_file_creation(
  var final_header : elf_rec);

begin
  case device_out.kind of
    TAPE:
      begin		"backspace to last file and move over eof"
	pos_device(device_out, TAPE_BACK_FILE, temp_ans);
	"if tape not at beginning of tape, skip end of file mark"
	if temp_ans = COMPLETE
	then pos_device(device_out, TAPE_FORWARD_FILE, temp_ans);
	wr_f_file(final_header, temp_ans)
      end (* TAPE *) ;

    DISK:
      begin
	device_out.disk_operator.cancel_creation;
	device_out.kind := ILLEGAL_DEVICE (* indicate file already closed *)
      end (* DISK *)
  end (* case *) ;

  rpt_xfr_er
end (* cancel_file_creation *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*			type_new_header_info				*)
(*									*)
(*	Type the file location for a file just created.			*)
(*									*)
(************************************************************************)

procedure type_new_header_info (
  dev		: dev_rec;
  header	: univ file_header_record);

begin
  type_file_address (device_out, output_start_page);
  type_disk_address (
    dev, disk_mon[dev.unit].disk_start + header.start_data_sector,
    header.end_sector - header.start_data_sector + 1)
end (* type_new_header_info *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*			report_new_disk_file				*)
(*									*)
(*	This routine checks for errors after a file has been written	*)
(*	to an elf medium.  If there are errors, the device is back-	*)
(*	spaced.  If no errors, a final file is written and backspaced	*)
(*	over.								*)
(*									*)
(************************************************************************)

procedure report_new_disk_file;

begin
  rd_device(device_out, output_start_page, device_out.elf_data, file_ans);
  type_new_header_info (device_out, device_out.elf_data.chars.file_data)
end (* report_new_disk_file *) ;



(****************************   xfr   (elf output routines)**************)
(*									*)
(*				end_elf					*)
(*									*)
(*	This routine checks for errors after a file has been written	*)
(*	to an elf medium.  If there are errors, the device is back-	*)
(*	spaced.  If no errors, a final file is written and backspaced	*)
(*	over.								*)
(*									*)
(************************************************************************)

procedure end_elf;

begin
  if res_in = END_FILE
  then res_in := COMPLETE;
  if all_ok
  then wr_elf_blk;
  if all_ok
  then	"xfr COMPLETEd successfully"
    begin	"write e-o-f if tape, write cksum blk if disk"
      case device_out.kind of
	TAPE:
	  pos_device(device_out, TAPE_WRITE_EOF, res_out);

	DISK:
	  begin
	    "output this checksum block"
	    wr_device(
	      device_out, device_out.cksum_page,
	      device_out.cksum_blk, res_out);
	    "if current page is less than expected last page, notify"
	    "file header of real last page"
	    adjusted_file_size :=
	      adjusted_file_size - (output_end_page - output_disk_page)
	  end (* DISK *)
      end (* case *) ;
      wr_f_file(elf_blk, res_out);
      term.write_message_line (XFR_COMP_M, tt_ans)
    end
  else cancel_file_creation(elf_blk);
  if recs_sent mod nd_rpt_ct <> 0
  then rpt_nd;
  if all_ok and (device_out.kind = DISK)
  then report_new_disk_file
end (* end_elf *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*			st_elf_ch					*)
(*									*)
(*	Save "ch" in "elf_blk.chars.file_data" indexed by		*)
(*	"elf_blk.length".						*)
(*	increment "elf_blk.length" and write block if full.		*)
(*	Increment elf_addr by "addr_incr".				*)
(*									*)
(************************************************************************)

procedure st_elf_ch(ch : char;
		addr_incr :integer);

begin
  elf_blk.length := elf_blk.length + 1;
  elf_blk.chars.file_data[elf_blk.length] := ch;
  elf_addr := elf_addr + addr_incr;
  res_out := COMPLETE;
  if elf_blk.length >= mx_elf_data then wr_elf_blk
end (* st_elf_ch *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*			sv_elf_cmp					*)
(*									*)
(*	Store the current compression character,"elf_cmp_ch"		*)
(*	followed by the compression count, "elf_cmp_ct".		*)
(*									*)
(************************************************************************)

procedure sv_elf_cmp;

begin
  if elf_cmp_ct = 1
  then st_elf_ch(rst_org_ch(elf_cmp_ch), 1) (* rec is too small for comp *)
  else
    begin (* close out compression record *)
      st_elf_ch(elf_cmp_ch, 0) (* add character to output record *) ;
      st_elf_ch(chr(elf_cmp_ct), elf_cmp_ct) (* add count to toutpu record *)
    end (* close out compression record *) ;
  elf_cmp_fl := FALSE
end (* sv_elf_cmp *) ;



(****************************   xfr   (ELF output routines)**************)
(*									*)
(*			sv_nxt_elf					*)
(*									*)
(*	Save "chio" in "elf_blk", increment "elf_blk.length", and	*)
(*	"elf_addr".  If enough chars are there, write out a block.	*)
(*									*)
(************************************************************************)

procedure sv_nxt_elf;

begin
  if res_in = COMPLETE
  then
    begin
      seg_ch_ct := seg_ch_ct + 1;
      if image_form
      then st_elf_ch(chio, 1)
      else
        begin (* not image_form *)
	  set_special(special, sp_char) (* check for a special character *) ;
	  if elf_cmp_fl
	  then	(* compression is ON *)
	    if sp_char = elf_cmp_ch
	    then
	      begin	(* another compression character found *)
	        if elf_cmp_ct = FULL_BYTE
		then sv_elf_cmp (* record full, close out compression record *)
		else elf_cmp_ct := elf_cmp_ct + 1 (* incr. compression count *)
	      end (* another compression character found *)
	    else sv_elf_cmp (* different char, close out compression record *) ;
	  if not elf_cmp_fl
	  then (* compression is OFF; may have JUST been turned off *)
	    case special of
	      ESCAPED:
	        begin (* store flag and character *)
		  st_elf_ch(ESCAPE_CH, 0);
		  st_elf_ch(chio, 1)
		end (* escaped *) ;
	      ZERO_CMP,
	      ONS_CMP:
	        begin (* initialize compression *)
		  elf_cmp_ct := 1;
		  elf_cmp_ch := sp_char;
		  elf_cmp_fl := TRUE
		end (* ZERO_CMP, ONS_CMP *) ;
	      NT_SPECIAL: st_elf_ch(chio, 1) (* just store character *)
	    end (* CASE *) ;
	  if elf_cmp_fl and not cmp_fl and (chars_left <= 0) (* ?? *)
	  then sv_elf_cmp
	end (* not image_form *)
    end (* res_in = COMPLETE *)
end (* sv_nxt_elf *) ;
!
      (*     XFR4.ELF Updated 17-Sep-86 at 12:10 by Raffo    *)

(************************************************************************)
(*									*)
(*	ELF Input Routines						*)
(*									*)
(************************************************************************)




(****************************   xfr   (elf input routines)***************)
(*									*)
(*				file_cksum				*)
(*									*)
(*	This function returns the checksum stored on tape or disk.	*)
(*									*)
(************************************************************************)

function file_cksum(e_blk :elf_rec) : integer;

begin
  case device_in.kind of
    TAPE:
      file_cksum := e_blk.chars.tape_cksm;
    DISK:
      begin
    	file_cksum := 0;
	device_in.cksum_dex := device_in.cksum_dex + BYTS_IN_WD;
	if device_in.cksum_dex >= HD_CKSM_END_X
	then	"read next checksum block"
	  begin
	    device_in.cksum_page := device_in.cksum_page + PGS_IN_ELF;
	    rd_device(
	      device_in, device_in.cksum_page, device_in.cksum_blk, res_in);
	    if (res_in = COMPLETE) and
	       (device_in.cksum_blk.chars.file_data[HD_SYNC_X    ] = SYNC) and
	       (device_in.cksum_blk.chars.file_data[HD_SYNC_X + 1] = SYNC) and
	       (device_in.cksum_blk.chars.file_data[HD_SYNC_X + 2] = TWO)
	    then device_in.cksum_dex := 5
	    else res_in := BAD_DISK
	  end;
	if res_in = COMPLETE
	then
	  file_cksum :=
	    wd_to_int(device_in.cksum_blk.chars.file_data, device_in.cksum_dex)
      end (* DISK *)
    end (* case *)
end (* file_cksum *);



(****************************   xfr   (elf input routines)***************)
(*									*)
(*				input_elf_blk				*)
(*									*)
(*	This routine inputs a block of elf data, and checks the		*)
(*	checksum computed against the stored checksum.			*)
(*									*)
(************************************************************************)

procedure input_elf_blk(
  var in_result : ioresult;
  var elf_data	: elf_rec);

begin
  rd_device(device_in, input_disk_page, elf_data, in_result);
  input_disk_page := input_disk_page + PGS_IN_ELF;
  if in_result = COMPLETE
  then
    begin
      elf_cksm(
	elf_data.chars.file_data, MX_ELF_DATA) (* get vertical checksum *);
      if vck <> file_cksum(elf_data)
      then in_result := BAD_CKSM
    end
end (* input_elf_blk *);



(****************************   xfr   (elf input routines)***************)
(*									*)
(*				rd_elf_blk				*)
(*									*)
(*	This routine inputs a block of elf data, and checks the		*)
(*	checksum computed against the stored checksum.			*)
(*									*)
(************************************************************************)

procedure rd_elf_blk;

begin
  if check_for_stop
  then
    begin
      elf_ch_ptr :=1;
      chars_left := MX_ELF_DATA
    end
  else
    if (device_in.kind = TAPE) or
      ((device_in.kind = DISK) and (input_disk_page < input_end_page))
    then
      begin
	last_addr := elf_addr;
	input_elf_blk(res_in, elf_blk);
	if res_in = COMPLETE
	then
	  begin
	    if image_form
	    then
	      begin
		chars_left := MX_ELF_DATA;
		elf_ch_ptr := 1
	      end
	    else
	      begin
		chars_left := wd_to_int(elf_blk.chars.file_data, ELF_BCT_X);
		elf_ch_ptr := ELF_DATA_X;
		elf_addr := wd_to_int(elf_blk.chars.file_data, ELF_ADDR_X);
		if (last_addr <> -1) and (last_addr <> elf_addr)
		then res_in := END_OF_SEG
	      end;
	    if chars_left = 0
	    then res_in := END_FILE
          end
      end
    else res_in := END_FILE;
end (* rd_elf_blk *) ;



(****************************   xfr   (elf input routines)***************)
(*									*)
(*				get_next_elf_char			*)
(*									*)
(*	This routine returns next elf char in "chio".  It inputs	*)
(*	a new block from the device if necessary and also checks	*)
(*	to see if a break has been input by the user.			*)
(*									*)
(************************************************************************)

procedure get_next_elf_char;

begin
  tt_ans := COMPLETE;
  res_in := COMPLETE;
  if not elf_cmp_fl and (chars_left <= 0)
  then rd_elf_blk;
  if res_in = COMPLETE
  then
    begin
      if elf_cmp_fl
      then get_nxt_cmp(chio, elf_cmp_ch, elf_cmp_ct, elf_cmp_fl)
      else
	begin
	  get_nxt_ch(chio, elf_blk.chars.file_data, elf_ch_ptr);
	  if not image_form
	  then
	    begin
	      special := chk_sp_ch;
	      if special <> nt_special
	      then
		begin
		  if chars_left <= 0
		  then rd_elf_blk;
		  special_ob(
		    chio,special,elf_blk.chars.file_data,elf_ch_ptr,elf_cmp_ch,
		    elf_cmp_fl, elf_cmp_ct)
	        end (* special <> nt_special *)
	    end (* not image_form *)
	end (* not elf_cmp_fl *);
      elf_addr := elf_addr + 1
    end
end (* get_next_elf_char *);
!
      (*     XFR5.ELF Updated 11-Sep-86 at 9:53 by Raffo    *)

(************************************************************************)
(*									*)
(*	Downline and Slot Routines					*)
(*									*)
(************************************************************************)




(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*			sv_dl_cksm					*)
(*									*)
(*	Compute both vertical and diagonal checksums for the		*)
(*	downline data stored in "cir.chars.file_data".			*)
(*									*)
(************************************************************************)

procedure sv_dl_cksm;

begin
  elf_cksm(cir.chars.file_data, dl_vck_x-1);
  int_to_wd (
    vck, temp_ch, temp_ch,
    cir.chars.file_data[dl_vck_x], cir.chars.file_data[dl_vck_x+1]);
  int_to_wd(dck, temp_ch, temp_ch,
  cir.chars.file_data[dl_dck_x], cir.chars.file_data[dl_dck_x+1])
end (* sv_dl_cksm *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				init_dl					*)
(*									*)
(*	Initialize "cir.chars.file_data", "cir.length", and store	*)
(*	dl_addr" in							*)
(*	"cir.chars.file_data" (if load node or restart) or in		*)
(*	"cir_cmd.chars.file_data"					*)
(*	(if load or dump slot or partial).				*)
(*									*)
(************************************************************************)

procedure init_dl;

begin
  cmp_fl := FALSE;
  sv_same_ch(cir.chars.file_data, 1, ONES, MX_DL_CHS);
  rec_ch_ct := 0;
  if (this_sub.sub_prg = SNODE) or (this_cmd.prg_name = CRESTART)
  then
    begin
      "this call writes over count in cir array, but it will be
       set up when sending the data"
      int_to_chs(cir.chars.file_data, dl_addr, dl_addr_x-1);
      dl_data_start := dl_addr;	"save address of beg. of data for this block"
      cir.length := dl_data_x - 1
    end
  else
    begin
      cir.length := 0;
      cir_cmd.length := 2;		"set up command record to be..."
      if this_cmd.prg_name = CLOAD
      then cir_cmd.chars.file_data[1] := '(:215:)'	"store w for write command"
      else cir_cmd.chars.file_data[1] := '(:210:)';	"or r for read command"
      cir_cmd.chars.file_data[2] := '(:160:)';	"followed by a space"
      sv_sl_cmd(dl_addr);	"followed by address of data"
    end
end (* init_dl *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*			  make_downline_address				*)
(*									*)
(************************************************************************)

procedure make_downline_address(
      chars	: elf_chs;
  var address	: univ string4);

begin
  address[1] := ZERO;
  address[2] := chars[DL_ADDR_X];
  address[3] := chars[DL_ADDR_X + 1];
  address[4] := chars[DL_ADDR_X + 2]
end (* make_downline_address *);



(***************************   xfr   downline/slot routines)*************)
(*									*)
(*			input_waiting_record				*)
(*									*)
(*	This procedure inputs a downline record that is waiting on the	*)
(*	circuit, and, if found in dl_recs, sets pending to FALSE, and	*)
(*	decrements pending_count. If the record is good and not found	*)
(*	in dl_recs, increment late_recs.				*)
(*									*)
(************************************************************************)

procedure input_waiting_record(
  var pointer	: integer);

var
  first_pointer_value : integer;
  answer_address : integer;
  found_record : boolean;

begin
  rd_cir(1, MX_DL_CHS, cir_ans, res_out) (* chars should already be there *);
  if res_out = COMPLETE
  then
    if (cir_ans.chars.file_data[DL_SYNC_X] <> DL_SYNC) or
       (cir_ans.chars.file_data[DL_SYNC_X+1] <> DL_SYNC)
    then res_out := DOWNL_FAILURE
    else
      begin	(* good downline answer, find it in dl_recs *)
	first_pointer_value := pointer (* start w/current pointer *);
	make_downline_address(cir_ans.chars.file_data, answer_address);
	found_record := FALSE;
	repeat
	  if dl_recs[pointer].pending
	  then
	    if answer_address = dl_recs[pointer].address
	    then
	      begin (* answer found in dl_recs *)
		dl_recs[pointer].pending := FALSE;
		pending_count := pending_count - 1;
		found_record := TRUE;
		good_recs := good_recs + 1
	      end (* answer found in dl_recs *);
	  if not found_record
	  then (* keep looking *)
	    if pointer = MAX_DL_RECORDS (* increment pointer *)
	    then pointer := 1
	    else pointer := pointer + 1
	until found_record or (pointer = first_pointer_value);
	if not found_record
	then late_recs := late_recs + 1
      end	(* good downline answer, find it in dl_recs *)
end (* input_waiting_record *);



(***************************   xfr   downline/slot routines)*************)
(*									*)
(*			input_any_downline_answers			*)
(*									*)
(*	This procedure inputs any and all ans<wers waiting on		*)
(*	the circuit.							*)
(*									*)
(************************************************************************)

procedure input_any_downline_answers(
      start_pointer	: integer);

var
  done : boolean;
  temp2,
  chars_waiting : integer (* number of characters waiting to be input *);
  temp_pointer : integer;

begin
  done := FALSE; temp_pointer := start_pointer;
  repeat
    cirio.any_input(0, chars_waiting, temp2, res_out);
    if res_out = COMPLETE
    then
      if chars_waiting < MX_DL_CHS
      then done := TRUE
      else
        repeat	(* input all waiting records *)
	  input_waiting_record(temp_pointer);
	  chars_waiting := chars_waiting - MX_DL_CHS
	until (chars_waiting < MX_DL_CHS) or (res_out <> COMPLETE)
  until done or (res_out <> COMPLETE)
end (* input_any_downline_answers *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*			  resend_record					*)
(*									*)
(************************************************************************)

procedure resend_record(
      downline_pointer	: integer);

begin
  for n := 1 to MX_DL_CHS do
    cir.chars.file_data[n] := dl_recs[downline_pointer].data[n];
  cir.length := MX_DL_CHS;	"number of chars to send"
  dl_recs[downline_pointer].time_expired := REALTIME + DOWNLINE_TIMEOUT;
  cirio.wr_cir_line(cir, res_out);
  resent_recs := resent_recs + 1;
  recs_sent := recs_sent + 1
end (* resend_record *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*			    wait_for_answer				*)
(*									*)
(*	downline_pointer points to an old pending record; input any and	*)
(*	all answers waiting, and find an available slot to store the	*)
(*	next record sent.  Check for records that need to be resent.	*)
(*	Continue until there is a free slot in dl_recs.			*)
(*									*)
(************************************************************************)

procedure wait_for_answer(
  var downline_pointer	: integer);

var
  temp_record : integer;
  now : integer;

begin
  repeat
    input_any_downline_answers(downline_pointer);
    if pending_count < MAX_DL_RECORDS
    then (* find available slot *)
      while dl_recs[downline_pointer].pending do
        if downline_pointer = MAX_DL_RECORDS
	then downline_pointer := 1
	else downline_pointer := downline_pointer + 1
    else (* no available slot as yet *)
      if res_out = COMPLETE
      then
        begin (* resend all timed out records *)
	  now := REALTIME;
	  for temp_record := 1 to MAX_DL_RECORDS do
	    if dl_recs[temp_record].time_expired < now
	    then
	      begin
	        resend_record(temp_record);
	        if recs_sent mod ND_RPT_CT = 0
		then rpt_nd
	      end (* time_expired < REALTIME *);
	  if not check_for_stop (* see if user wants to stop *)
	  then wait
	end (* resend all timed out records *);
  until user_interrupt or (pending_count < MAX_DL_RECORDS) or
    (res_out <> COMPLETE)
end (* wait_for_answer *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*			store_downline_record				*)
(*									*)
(************************************************************************)

procedure store_downline_record(
      chars	: univ downline_elf_record;
  var data	: downline_record);

begin
  data := chars.dl_data
end (* store_downline_record *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				snd_dl_rec				*)
(*									*)
(*	Compute checksum and transmit downline record.	  Save record	*)
(*	in dl_recs and input an answer when necessary.			*)
(*									*)
(************************************************************************)

procedure snd_dl_rec;

var
  found_record : boolean;

begin
  seg_ch_ct := seg_ch_ct + rec_ch_ct;
						"clear syncs for checksum"
  sv_same_ch(cir.chars.file_data, dl_sync_x, zero, 2);
						"save rec length"

  cir.chars.file_data[dl_dct_x] := chr(cir.length - (dl_data_x-1));
  sv_dl_cksm;
  cir.chars.file_data[DL_SYNC_X] := DL_SYNC;	"save syncs"
  cir.chars.file_data[DL_SYNC_X + 1] := DL_SYNC;	"save syncs"
  cir.length := MX_DL_CHS;

(* save time and address in dl_recs *)
  dl_recs[downline_pointer].pending := TRUE;
  pending_count := pending_count + 1;
  dl_recs[downline_pointer].time_expired := REALTIME + DOWNLINE_TIMEOUT;
  make_downline_address (
    cir.chars.file_data, dl_recs[downline_pointer].address);

(* send dl record *)
  cirio.wr_cir_line (cir, res_out);
  recs_sent := recs_sent + 1;

(* save data in dl_recs *)
  store_downline_record (cir.chars, dl_recs[downline_pointer].data);
  if downline_pointer = MAX_DL_RECORDS (* increment downline_pointer *)
  then downline_pointer := 1
  else downline_pointer := downline_pointer + 1;
  if dl_recs[downline_pointer].pending
  then wait_for_answer(downline_pointer) (* get oldest ans/resend *);
  init_dl;
  if recs_sent mod ND_RPT_CT = 0
  then rpt_nd
end (* snd_dl_rec *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*			exp_sl_ch					*)
(*									*)
(*	Tell user error message from ISIS and clear circuit if a	*)
(*	flush char has been encountered.				*)
(*									*)
(************************************************************************)

procedure exp_sl_ch(var ans : elf_rec);

begin
  if res_out = COMPLETE then
    begin
      if ans.chars.file_data[1] = FLUSH_CHAR
      then
	begin
	  term.write_newline (tt_ans);
	  term.write_message_line ('FLUSHING SLOT CIRCUIT\', tt_ans);
	  snd_cir_ch(FLUSH_CHAR)	"return flush char"
	end
      else
	begin
	  n := ord(ans.chars.file_data[1]);
	  form.number_message (UNEXPECTED_M, n, hex);
	  form.write_line (term, tt_ans);
	  if n < 48
	  then
	    case n of
 0: term.write_message_line ('DATA CHAR 80\ ', tt_ans);
 1: term.write_message_line ('DATA CHAR 81\ ', tt_ans);
 2: term.write_message_line ('HANDSHAKE CHAR\ ', tt_ans);
 3: term.write_message_line ('ILLEGAL COMMAND\', tt_ans);
 4: term.write_message_line ('ILLEGAL INSTRUCTION\', tt_ans);
 5: term.write_message_line ('BREAKPOINT ENCOUNTED\ ', tt_ans);
 6: term.write_message_line ('ADDRESS OUT OF RANGE\ ', tt_ans);
 7: term.write_message_line ('BREAKPOINT NUMBER OUT OF RANGE\ ', tt_ans);
 8: term.write_message_line ('NO BREAKPOINT TO PROCEED FROM\', tt_ans);
 9: term.write_message_line ('MEMORY OUT OF BOUNDS\ ', tt_ans);
10: term.write_message_line ('ILLEGAL REGISTER NUMBER\', tt_ans);
11: term.write_message_line ('DISK ERROR\ ', tt_ans);
12: term.write_message_line ('INVALID NUMBER\ ', tt_ans);
13: term.write_message_line ('INCORRECT BOUNDS\ ', tt_ans);
14: term.write_message_line ('BAD SEARCH LENGTH\', tt_ans);
15: term.write_message_line ('BAD SEARCH BOUNDRY\ ', tt_ans);
16: term.write_message_line ('ILLEGAL SVC EXECUTED\ ', tt_ans);
17: term.write_message_line ('ILLEGAL MEMORY REFERENCE BY OUT-SVC\', tt_ans);
18: term.write_message_line ('PARITY ERROR\ ', tt_ans);
19: term.write_message_line ('ILLEGAL MEMORY REFERENCE BY USER\ ', tt_ans);
20: term.write_message_line ('LOGGING OFF?\ ', tt_ans);
21: term.write_message_line ('JUMP OUT OF BOUNDS\ ', tt_ans);
22: term.write_message_line ('SLOT ALREADY CONNECTED\ ', tt_ans);
23: term.write_message_line ('ILLEGAL INSTRUCTION IN CONTROLLED CODE\ ', tt_ans);
24: term.write_message_line ('BREAKPOINT ALREADY EXISTS THERE\', tt_ans);
25: term.write_message_line ('DISPATCHER CRASH\ ', tt_ans);
26: term.write_message_line ('BAD M ARGUMENTS\', tt_ans);
27: term.write_message_line ('ALREADY HAVE USE OF SPY\', tt_ans);
28: term.write_message_line ('ABORTING\ ', tt_ans);
29: term.write_message_line ('INSUFFICIENT LICENSE\ ', tt_ans);
30: term.write_message_line ('FROZEN!\', tt_ans);
31: term.write_message_line ('MAC NOT SET UP CORRECTLY\ ', tt_ans);
32: term.write_message_line ('ABORTING--AVAILABLE SPACE EXCEEDED\ ', tt_ans);
33: term.write_message_line ('DISC AREA SAVE PROTECTED\ ', tt_ans);
34: term.write_message_line ('HALTED\ ', tt_ans);
35: term.write_message_line ('SUSPENDED\', tt_ans);
36: term.write_message_line ('BAD MAC SET UP\ ', tt_ans);
37: term.write_message_line ('SVC\', tt_ans);
38: term.write_message_line ('DDT\', tt_ans);
39: term.write_message_line ('NOT LOADED\ ', tt_ans);
40: term.write_message_line ('SLOT INITIATED\ ', tt_ans);
41: term.write_message_line ('LOADED\ ', tt_ans);
42: term.write_message_line ('CRASHED\', tt_ans);
43: term.write_message_line ('RESTARTED\', tt_ans);
44: term.write_message_line ('SLOT\ ', tt_ans);
45: term.write_message_line ('SLOT SUSPENDED\ ', tt_ans);
46: term.write_message_line ('WATCHFROG TIMEOUT\', tt_ans);
47: term.write_message_line ('OWNER DOWN\ ', tt_ans)
	    end
	  else	"end case"
	    repeat		"show user all chars recieved from ISIS"
	      term_line.length := 1;
	      term_line.chars[1] := ans.chars.file_data[1];
	      term.wr_line_rec(term_line, NO_CR, tt_ans);
	      rd_cir(30, 1, ans, res_out)
	    until not all_ok;
	  res_out := ISIS_ERROR
        end
    end
end (* exp_sl_ch *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				get_sl_shk				*)
(*									*)
(*	Wait for confirmation and tell user if handshake isn't received.*)
(*									*)
(************************************************************************)

procedure get_sl_shk(var temp_result : ioresult;
		var ans : elf_rec);

begin
  rd_cir(30, 1, ans, temp_result);
  if (temp_result = COMPLETE) and (ans.chars.file_data[1] = escape_ch)
  then
    begin
      rd_cir(5, 1, ans, temp_result);
      if ans.chars.file_data[1] <> TWO
      then exp_sl_ch(ans)
    end
  else exp_sl_ch(ans)
end (* get_sl_shk *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				send_isis_rec				*)
(*									*)
(*	Output cir record and wait for confirmation.			*)
(*									*)
(************************************************************************)

procedure send_isis_rec;

begin
  if res_out = COMPLETE
  then
    begin
      cirio.wr_cir_line(cir, res_out);
      get_sl_shk(res_out, cir_ans)
    end
end (* send_isis_rec *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*			   send_slot_start				*)
(*									*)
(*	Send an Execute command to DDT and await response. Accept	*)
(*	either the DDT prompt for SLOT STARTED or return code 23 hex	*)
(*	for SLOT SUSPENDED.						*)
(*									*)
(************************************************************************)

procedure send_slot_start;

begin
  cir.chars.file_data[1] := '(:197:)';	"send 'E' to ISIS"
  cir.length := 1;
  cirio.wr_cir_line(cir, res_out);
  rd_cir(30, 1, cir_ans, res_out);
  if (res_out = COMPLETE) and (cir_ans.chars.file_data[1] = ESCAPE_CH)
  then
    begin
      rd_cir(5, 1, cir_ans, res_out);
      if cir_ans.chars.file_data[1] = '(:2:)'
      then term.write_message_line ('SLOT STARTED\ ', tt_ans)
      else if cir_ans.chars.file_data[1] = '(:45:)' (* slot suspended code *)
      then term.write_message_line ('SLOT SUSPENDED\ ', tt_ans)
      else exp_sl_ch(cir_ans)
    end
  else exp_sl_ch(cir_ans)
end (* send_slot_start *) ;



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				snd_sl_rec				*)
(*									*)
(*	Send a slot record to ISIS.					*)
(*									*)
(************************************************************************)

procedure snd_sl_rec;

begin
  if cir.length > 0 then
    begin
      seg_ch_ct := seg_ch_ct + rec_ch_ct;	"update segment char counter"
      sv_sl_cmd(rec_ch_ct);
      cirio.wr_cir_line(cir_cmd, res_out);
      send_isis_rec
    end;
  init_dl
end (* snd_sl_rec *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*			send_rec					*)
(*									*)
(*	Send downline or slot record.					*)
(*									*)
(************************************************************************)

procedure send_rec;

begin
  if this_sub.sub_prg <> SNODE
  then snd_sl_rec
  else
    if cir.length > dl_data_x - 1
    then snd_dl_rec
end (* send_rec *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				sv_esc_ch				*)
(*									*)
(*	Save escape char and char to be escaped in output record.	*)
(*	If command is load slot xor escpaed char with a hex 40.		*)
(*									*)
(************************************************************************)

procedure sv_esc_ch(var e_char : char);

begin
  if cir.length + 2 > MX_OUT_SZ
  then send_rec;
  cir.length := cir.length + 1;
  cir.chars.file_data[cir.length] := ESCAPE_CH;	"save escape char"
(* if load slot, xor char with hex 40 *)
  if this_sub.sub_prg <> SNODE
  then xor_hx_40(e_char);
  cir.length := cir.length + 1;
  cir.chars.file_data[cir.length] := e_char	"save escaped char"
end (* sv_esc_ch *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				sv_cmp_chs				*)
(*									*)
(*	Store compression character and compression count in output	*)
(*	record.  If command is load slot and the compression count	*)
(*	is a char that needs to be escaped, escape it!  Turn off	*)
(*	compression fl.  If compression count is one, do not		*)
(*	compress.							*)
(*									*)
(************************************************************************)

procedure sv_cmp_chs;

begin
(* if compression count is 1 and cmd is not load node, *)
  if (cmp_ct = 1) and (this_sub.sub_prg <> SNODE)
  then
    begin (* send data byte of zero with no compression *)
      rec_ch_ct := rec_ch_ct + 1;	"incr count of data in record"
      dl_addr := dl_addr + 1;		"incr address of data"
      cir.length := cir.length + 1;
      cir.chars.file_data[cir.length] := rst_org_ch(cmp_ch) "and output it"
    end
  else
    begin (* add compression data to record *)
      "if compression bytes will not fit in this record, send current
        record out and init new record before saving bytes"
      if (cir.length+2 > MX_OUT_SZ) or
        ((this_sub.sub_prg <> snode) and (chr(cmp_ct) in special_dl)
	 and (cir.length+3 > MX_OUT_SZ))
      then send_rec (* if bytes will not fit in this record, send it *);
      cir.length := cir.length + 1;
      cir.chars.file_data[cir.length] := cmp_ch;	"output compression char"
      rec_ch_ct := rec_ch_ct + cmp_ct;	"ct data being added to rec"
      dl_addr := dl_addr + cmp_ct;	"incr address for cmpressed data"
      temp_ch := chr(cmp_ct);	"convrt count"
      if (this_sub.sub_prg <> SNODE) and	"if load slot or partial,"
        (temp_ch in special_dl)		"and count is an escaped char,"
      then sv_esc_ch(temp_ch)	"escape it"
      else
        begin
	  cir.length := cir.length + 1;
	  cir.chars.file_data[cir.length] := temp_ch
	end (* not an escape character *)
    end (* add compression data to record *);
  cmp_fl := FALSE	"turn off compression fl"
end (* sv_cmp_chs *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				init_dl_recs				*)
(*									*)
(*	Fill in first record of each downline_record in dl_recs with	*)
(*	-1, and set downline_pointer to 1.				*)
(*									*)
(************************************************************************)

procedure init_dl_recs;

begin
  for downline_pointer := 1 to MAX_DL_RECORDS do
    dl_recs[downline_pointer].pending := FALSE;	"fl to say empty"
  pending_count := 0;
  downline_pointer := 1
end (* init_dl_recs *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				start_it				*)
(*									*)
(*	This routine sends RESEND_STARTUP_REC_COUNT startup records	*)
(*	to the node, and waits for one acknowledgement.			*)
(*									*)
(************************************************************************)

procedure start_it;

var
  send_record_count : integer;
  ack_timeout	    : integer;

begin
  if strt_add <> -1
  then
    begin
      init_dl_recs;
      recs_sent := 0;	"don't report any records transferred"
      dl_addr := strt_add;
      init_dl;
      for send_record_count := 1 to RESEND_STARTUP_REC_COUNT do
        snd_dl_rec (* send record RESEND_STARTUP_REC_COUNT times *) ;
      ack_timeout := realtime + 60 (* Wait no more than 1 minute for ACK *) ;

      repeat (* wait for 1 acknowledgement *)
        repeat (* find pending record *)
	  if downline_pointer = MAX_DL_RECORDS
	  then downline_pointer := 1
	  else downline_pointer := downline_pointer + 1;
	until dl_recs[downline_pointer].pending;
	input_any_downline_answers(downline_pointer);
	if not check_for_stop
	then
	  if ack_timeout < realtime
	  then res_out := TIMED_OUT
	  else wait
      until user_interrupt or (res_out <> COMPLETE) or
        (pending_count < RESEND_STARTUP_REC_COUNT) "got 1 pending"
    end
  else
    if all_ok
    then term.write_message_line ('NO START ADDRESS\ ', tt_ans)
end (* start_it *);



(**************************   xfr   (downline/slot routines)*************)
(*									*)
(*				sv_nxt_dl				*)
(*									*)
(*	This routine checks "chio" to see if it should be preceeded by	*)
(*	an escape character or should be zero or ones cmprsed.  It	*)
(*	stores the appropriate chars in "cir.chars.file_data".		*)
(*	This routine is							*)
(*	used by both load node and load slot routines.			*)
(*									*)
(************************************************************************)

procedure sv_nxt_dl;

begin
  set_special(special, sp_char) (* check for a special character *);
  if cmp_fl
  then (* compression is ON *)
    if sp_char = cmp_ch
    then
      begin (* another compression character found *)
        if cmp_ct = FULL_BYTE
	then sv_cmp_chs (* record full, close out compression record *);
	cmp_ct := cmp_ct + 1 (* increment compression count *)
      end (* another compression character found *)
    else sv_cmp_chs (* different char, close out compression record *);
  if ((this_sub.sub_prg = SNODE) and (dl_addr-DL_DATA_START > MX_DL_CT)) or
    (cir.length >= MX_OUT_SZ)
  then send_rec (* if chars fill out rec or max amount of data, send record *);
  if not cmp_fl
  then
    begin
      case special of
        ESCAPED: sv_esc_ch(chio) (* save escape and actual character *);
	ZERO_CMP,
	ONS_CMP:
	  if (this_sub.sub_prg = SNODE) and (cir.length + 1 >= MX_OUT_SZ)
	  then
	    begin (* only room for character itself *)
	      cir.length := cir.length + 1;
	      cir.chars.file_data[cir.length] := chio
	    end
	  else
	    begin  (* set up for compression *)
	      cmp_ch := sp_char;
	      cmp_ct := 1;
	      cmp_fl := TRUE
	    end (* ZERO_CMP, ONS_CMP *);
	NT_SPECIAL:
	  begin (* just save actual character *)
	    cir.length := cir.length + 1;
	    cir.chars.file_data[cir.length] := chio
	  end (* NT_SPECIAL *)
      end (* case *);
      if not cmp_fl
      then
        begin
	  dl_addr := dl_addr + 1;	"incr addr to refer to next char"
	  rec_ch_ct := rec_ch_ct + 1	"incr count of data in record"
	end (* not cmp_fl *)
    end (* not cmp_fl *)
end (* sv_nxt_dl *);
!
      (*     XFR6.ELF Updated 1-Nov-85 at 13:08 by Raffo    *)

(************************************************************************)
(*									*)
(*									*)
(*									*)
(************************************************************************)





(*****************************   xfr   **********************************)
(*									*)
(*  			   seg_chars_to_get				*)
(*									*)
(*      Function to return number of chars to ask for from ISIS.  Ask	*)
(*	for mx_ob_chs if we need at leat that much, else ask for what-	*)
(*	ever is left in seg_length of that seg.  Decrement seg_length.	*)
(*									*)
(************************************************************************)

function seg_chars_to_get : integer;

var
  temp : integer;

begin
  if seg_length[this_seg] >= mx_ob_chs
  then temp := mx_ob_chs
  else temp := seg_length[this_seg];
  seg_length[this_seg] := seg_length[this_seg] - temp;
  seg_chars_to_get := temp
end (* seg_chars_to_get *);

 


(****************************   xfr   (control routines)*****************)
(*									*)
(*				get_seg_blk				*)
(*									*)
(*	This procedure inputs info from ISIS for a segment.		*)
(*									*)
(************************************************************************)

procedure get_seg_blk(how_many_chars : integer);

begin
  if how_many_chars <= 0
  then res_in := end_of_seg
  else
    begin
      init_dl;
      sv_sl_cmd(how_many_chars);
      cirio.wr_cir_line(cir_cmd, res_in);
      rd_cir(20, how_many_chars, cir, res_in);
      if res_in = COMPLETE then get_sl_shk(res_in, cir_cmd);
      obj_ch_ptr := 1;
      cmp_fl := FALSE;
      chars_left := cir.length;
      elf_addr := dl_addr;
      dl_addr := dl_addr + chars_left
    end
end (* get_seg_blk *);
!
(****************************   xfr   (object file routines)*************)
(*									*)
(*			nxt_in_ch					*)
(*									*)
(*	Return next char of object or ISIS  data in "chio".  Also check	*)
(*	to see if a break has been entered.  Input a circuit record if	*)
(*	necessary.							*)
(*									*)
(************************************************************************)

procedure nxt_in_ch;

begin
  if res_in = COMPLETE
  then
    begin	 "if no more chars to process, input next block"
      if not cmp_fl and (chars_left <= 0)
      then
	if not check_for_stop
	then
	  if this_cmd.prg_name = ccreate
	  then get_ob_blk	 "input new data block"
	  else get_seg_blk(seg_chars_to_get)
	else
	  if this_cmd.prg_name = ccreate
	  then
	    begin
	      ans_elfslv(forget_it, res_in);
	      res_in := tt_ans;
	      term.clr_brk_st(tt_ans)
	    end;
      if all_ok
      then
	if cmp_fl
	then get_nxt_cmp(chio, cmp_ch, cmp_ct, cmp_fl)
	else
	  begin
	    get_nxt_ch(chio, cir.chars.file_data, obj_ch_ptr);
	    special := chk_sp_ch;
	    if special <> nt_special
	    then
	      special_ob (
		chio, special, cir.chars.file_data, obj_ch_ptr, cmp_ch,
	    	cmp_fl, cmp_ct)
	  end
    end
end (* nxt_in_ch *);
!
(****************************   xfr   (control routines)*****************)
(*									*)
(*				get_seg					*)
(*									*)
(*	This routine inputs all info from the source (either ELFSLV	*)
(*	or ISIS) for 1 seg and saves it in ELF format.			*)
(*									*)
(************************************************************************)

procedure get_seg;

begin
  if chars_left = 0
  then		"force this first time thru"
    if this_cmd.prg_name = ccreate
    then get_ob_blk
    else get_seg_blk(seg_chars_to_get);	"in case no seg 14"
  if all_ok
  then
    begin
      form.number_message ('STORING DATA FROM ADDRESS: \', elf_addr, HEX);
      form.write_string (term, tt_ans);
      seg_ch_ct := 0;
      init_elf;
      repeat
	nxt_in_ch;
	sv_nxt_elf
      until not all_ok;
      if ((res_in=end_of_seg) or (res_in=end_file)) and (res_out=COMPLETE)
      then
	begin
	  if elf_cmp_fl
	  then
	    begin
	      o_elf_addr := elf_addr;		"addr just input from elfslv"
	      sv_elf_cmp;
	      elf_addr := o_elf_addr	"restore from elfslv"
	    end;
	  wr_elf_blk;
	  if res_in = end_of_seg then res_in := COMPLETE;
	  form.number_message (BYTES_M, seg_ch_ct, DECIMAL);
	  form.write_line (term, tt_ans);
	end
    end
end (* get_seg *);



(****************************   xfr   (control routines)*****************)
(*									*)
(*				send_seg				*)
(*									*)
(*	Output all data for a segment.					*)
(*									*)
(************************************************************************)

procedure send_seg;

begin
  if all_ok
  then
    begin
      form.number_message ('SENDING DATA TO ADDRESS: \',elf_addr, HEX);
      form.write_string (term, tt_ans);
      if this_sub.sub_prg = SNODE
      then term.write_newline (tt_ans);
      seg_ch_ct := 0;
      dl_addr := elf_addr;
      init_dl;
      repeat
	get_next_elf_char;
	if res_in = COMPLETE
	then sv_nxt_dl
      until user_interrupt or (res_out <> COMPLETE) or (res_in <> COMPLETE);
      if res_out = COMPLETE
      then
	begin
	  if cmp_fl
	  then sv_cmp_chs;
	  if res_in = END_OF_SEG
	  then res_in := COMPLETE;
	  dl_addr := elf_addr;
	  send_rec;
	  form.number_message (BYTES_M, seg_ch_ct, DECIMAL);
	  form.write_line (term, tt_ans)
	end
    end
end (* send_seg *);



(****************************   xfr   (control routines)*****************)
(*									*)
(*				clear_dl_break				*)
(*									*)
(*	If a break has occurred, set "res_in", clear the break, and	*)
(*	zap the circuit.						*)
(*									*)
(************************************************************************)

procedure clear_dl_break;

begin
  if tt_ans = break_key
  then
    begin
      res_in := tt_ans;
      term.clr_brk_st(tt_ans);
      zap_aux_circuit
    end
end (* clear_dl_break *);



(****************************   xfr   (control routines)*****************)
(*									*)
(*				load_node				*)
(*									*)
(*	This routine reads data from tape or disk and sends		*)
(*	the data to the neighbor of the node to be loaded.		*)
(*									*)
(************************************************************************)

procedure load_node;

begin
  mx_out_sz := mx_dl_data + (dl_data_x - 1);
  recs_sent := 0;
  good_recs := 0;
  resent_recs := 0;
  late_recs := 0;
  dl_addr := 0;
  init_dl_recs;
  init_dl;
  elf_addr := -1;
  chars_left := 0;
  if image_form
  then
    repeat
      get_next_elf_char;
      if res_in = COMPLETE
      then sv_nxt_dl
    until user_interrupt or (res_in <> COMPLETE) or (res_out <> COMPLETE) or
      (dl_addr >= byte_count)
  else
    begin
      rd_elf_blk;
      repeat
        send_seg
      until not all_ok
    end;
  clear_dl_break;
  if res_in = END_FILE
  then res_in := COMPLETE;
  if all_ok
  then
    begin
      send_rec (* output any remaining characters *);
      if recs_sent mod ND_RPT_CT <> 0
      then rpt_nd;
		(* Input all pending answers *)
      while not user_interrupt and (res_out = COMPLETE) and
        (pending_count > 0) do
	begin
	  repeat (* find pending record *)
	    if downline_pointer = MAX_DL_RECORDS
	    then downline_pointer := 1
	    else downline_pointer := downline_pointer + 1;
	  until dl_recs[downline_pointer].pending;
	  input_any_downline_answers(downline_pointer);
	  if dl_recs[downline_pointer].pending
	  then resend_record(downline_pointer)
	  else
	    if pending_count > 0
	    then
	      if not check_for_stop
	      then wait
	end (* while *);
      if all_ok
      then term.write_message_line (XFR_COMP_M, tt_ans);
      if res_out = COMPLETE
      then start_it
    end;
  if all_ok and (strt_add <> -1)
  then term.write_message_line ('NODE STARTED\ ', tt_ans)
end (* load_node *);



(****************************   xfr   (control routines)*****************)
(*									*)
(*				load_slot				*)
(*									*)
(*	This routine reads data from tape or disk and sends the data	*)
(*	over the network to an ISIS slot.				*)
(*									*)
(************************************************************************)

procedure load_slot;

begin
  mx_out_sz := MAX_SLOT_LOAD_REC;
  elf_addr := -1;
  chars_left := 0;
  rd_elf_blk;		"set up first elf block of data"
  if (this_sub.sub_prg=sslot) and (res_in=COMPLETE) and (elf_addr<>st_seg_0e)
  then
    begin
      term.write_message_line ('SEG 0E IS NOT FIRST SEG IN FILE\', tt_ans);
      res_in := obj_error
    end
  else
    begin
      if this_sub.sub_prg = sslot
      then
	begin
	  send_seg;		"transmit data for this segment"
	  "set up string with ?lmac and carriage return"
	  mv_elf_chs(6, '(:191:)(:204:)(:205:)(:193:)(:195:)(:141:)', 1,
	    cir.chars.file_data, 1);
	  cir.length := 6;	"enough for '?lmac' and carriage return"
	  send_isis_rec;	"send cir record and input answer"
	  if res_out = COMPLETE
	  then term.write_message_line ('MAC INITIALIZED\', tt_ans)
	end;
      repeat
        send_seg
      until not all_ok;
      clear_dl_break;
      if res_in = end_file then res_in := COMPLETE;
      if all_ok
      then
	begin
	  term.write_message_line (XFR_COMP_M, tt_ans);
	  send_slot_start (* send an Execute command an await response *)
	end
   end
end (* load_slot *);
!
(****************************   xfr   (dump routine)*********************)
(*									*)
(*				dump_node				*)
(*									*)
(*	This routine requests records from the node from "strt_add"	*)
(*	to "end_add" and stores them on the elf device.			*)
(*									*)
(************************************************************************)

procedure dump_node;

var
  addr_input : integer;

begin
  recs_sent := 0;
  good_recs := 0;
  resent_recs := 0;
  late_recs := 0;
  init_elf;
  dl_addr := strt_add;
  sv_same_ch(cir.chars.file_data, 3, ones, MX_DL_CHS-2);
  repeat
    int_to_chs(cir.chars.file_data, dl_addr, DL_ADDR_X - 1);
    cir.chars.file_data[dl_dct_x] := chr(hex80);	"ask for dump chars"
    cir.length := MX_DL_CHS;
    cir.chars.file_data[DL_SYNC_X] := zero;
    cir.chars.file_data[DL_SYNC_X + 1] := zero;
    sv_dl_cksm;
    cir.chars.file_data[DL_SYNC_X] := dl_sync;
    cir.chars.file_data[DL_SYNC_X + 1] := dl_sync;
    cirio.wr_cir_line(cir, res_in);
    recs_sent := recs_sent + 1;
    if recs_sent mod nd_rpt_ct = 0 then rpt_nd;
    rd_cir(5, MX_DL_CHS, cir_ans, res_in);
    make_downline_address(cir_ans.chars.file_data, addr_input);
    if res_in = timed_out
    then
      begin
        resent_recs := resent_recs + 1;
        res_in := COMPLETE
      end
    else
    if res_in = COMPLETE
    then
      if (cir_ans.chars.file_data[DL_SYNC_X] = DL_SYNC) and
        (cir_ans.chars.file_data[DL_SYNC_X + 1] = DL_SYNC)
      then
	if dl_addr = addr_input
	then
	  begin
	    good_recs := good_recs + 1;
	    chars_left := ord(cir_ans.chars.file_data[dl_dct_x]);
	    dl_addr := dl_addr + chars_left;	"increment address"
	    if dl_addr > end_add
	    then chars_left := chars_left - (dl_addr-end_add) + 1;
	    cir_ans.length := dl_data_x;	"ptr to pick up chars with"
	    if not check_for_stop
	    then
	      repeat
	        chio := cir_ans.chars.file_data[cir_ans.length];
		cir_ans.length := cir_ans.length + 1;
		chars_left := chars_left - 1;
		sv_nxt_elf
	      until user_interrupt or not all_ok or (chars_left <= 0);
	    if dl_addr > end_add
	    then res_in := end_file
	  end
      else res_in := sync_error
  until not all_ok or user_interrupt
end (* dump_node *);



(****************************   xfr   (dump routine)*********************)
(*									*)
(*				dump_isis				*)
(*									*)
(*	This routine dumps segs marked in seg_set in elf format.	*)
(*									*)
(************************************************************************)

procedure dump_isis;

begin
  zero_fill_count := 0;
  elf_cmp_fl := FALSE;
  elf_cmp_ct := 0;
  chars_left := 0;
  if (this_sub.sub_prg = sslot) or (max_seg in seg_set)
  then
    begin
      chars_left := size_seg_oe;
      this_seg := max_seg;
      dl_addr := st_seg_0e;
      seg_length[max_seg] := 0;	(* so we don't get any more *)
      get_seg
    end
  else
    begin
      res_in := COMPLETE;
      res_out := COMPLETE
    end;
  if (res_in = COMPLETE) and (res_out = COMPLETE)
  then
    for this_seg := 0 to max_seg - 1 do
      if all_ok and (this_seg in seg_set) and (seg_length[this_seg] > 0)
      then
	begin
	  dl_addr := this_seg * ch2_factor;	"address of beginning of seg"
	  get_seg
	end
end (* dump_isis *);
!
      (*   CNTRL2.ELF Updated 25-Sep-86 at 14:20 by Raffo     *)

(*************   control   (miscellaneous routines)**********************)
(*									*)
(*			obj_cmd						*)
(*									*)
(*	This function returns the command to the pdp-10 to tell it to	*)
(*	send a node or slot file.					*)
(*									*)
(************************************************************************)

function obj_cmd : char;

begin
  case this_sub.sub_prg of
    snode: obj_cmd := send_node;
    sslot: obj_cmd := send_slot;
    spart: obj_cmd := send_part
  end
end (* obj_cmd *);



(*******************   control   (circuit building routines)*************)
(*									*)
(*			check_circuit_build         			*)
(*									*)
(*	This routine sets up circuit variables if circuit build		*)
(*	was complete.							*)
(*									*)
(************************************************************************)

procedure check_circuit_build;

begin
  if aux_ans = COMPLETE
  then gt_aux_cir := TRUE
  else
    begin
      term.write_message_line ('CIRCUIT NOT BUILT: \', tt_ans);
      form.write_line (term, tt_ans)
    end
end (* check_circuit_build *) ;



(*******************   control   (circuit building routines)*************)
(*									*)
(*				login          				*)
(*									*)
(*	This routine builds an auxilliary circuit with the string	*)
(*	in "term_line".							*)
(*									*)
(************************************************************************)

procedure login;

begin
  form.store_to_line_rec (term_line);
  cirio.build_it (term_line, aux_ans);
  form.start;
  form.aux_circuit_error (cirio.param);
  check_circuit_build
end (* login *) ;



(*******************   control   (circuit building routines)*************)
(*									*)
(*			    normal_login          			*)
(*									*)
(*	This routine builds a normal circuit with the string		*)
(*	in "term_line".							*)
(*									*)
(************************************************************************)

procedure normal_login;

begin
  form.store_to_line_rec (term_line);
  cirio.build_normal_circuit (term_line, aux_ans);
  form.start;
  form.normal_circuit_error (cirio.param);
  check_circuit_build
end (* normal_login *) ;



(**********************   control   *************************************)
(*									*)
(*			add_user_host					*)
(*									*)
(*	Add user and optional colon and host to "term_line".		*)
(*									*)
(************************************************************************)

procedure add_user_host (ls_user : username;
		ls_userlen : integer;
		ls_hostf : boolean;
		ls_host : integer);

begin
  form.move_from_elf_chs (ls_userlen, ls_user, 1);
  if ls_hostf
  then	"if there is a host, save colon plus host"
    begin
      form.character (COLON);
      form.number (ls_host, DECIMAL)
    end
end (* add_user_host *);



(*******************   control   (circuit building routines)*************)
(*									*)
(*				mk_ob_login				*)
(*									*)
(*	This routine converts login info to a login message		*)
(*	in "term_line".  If "ls_passw_fl" is true, also save		*)
(*	"ls_passw.chars" and project code.				*)
(*									*)
(************************************************************************)

procedure mk_ob_login(ls_user : username;
		ls_userlen : integer;
		ls_hostf : boolean;
		ls_host : integer;
		ls_passw_fl : boolean;
		ls_passw : line_rec);

begin
  "first, save user name and length"
  add_user_host(ls_user, ls_userlen, ls_hostf, ls_host);
  form.character (SEMI_COLON);
  "if password required, save it and proj-code next"
  if ls_passw_fl
  then
    begin
      if ls_passw.length > 0
      then form.move_from_elf_chs (ls_passw.length, ls_passw.chars, 1);
      form.character (CR);
      form.character (CR);
      form.character (CR)
    end
end (* mk_ob_login *);



(*******************   control   (circuit building routines)*************)
(*									*)
(*			    make_normal_login				*)
(*									*)
(*	This routine converts login info to a login message		*)
(*	in "term_line".  						*)
(*									*)
(************************************************************************)

procedure MAKE_NORMAL_LOGIN(ls_user : username;
		ls_userlen : integer;
		ls_hostf : boolean;
		ls_host : integer;
		ls_passw : line_rec);

begin
  "first, save user name and length"
  add_user_host(ls_user, ls_userlen, ls_hostf, ls_host);
  form.character (SEMI_COLON);
  if ls_passw.length > 0
  then form.move_from_elf_chs (ls_passw.length, ls_passw.chars, 1);
  form.character (CR)
end (* make_normal_login *) ;



(*******************************xfr**************************************)
(*									*)
(*				show_chars				*)
(*									*)
(*	If unexpected string comes in over object circuit, show		*)
(*	the string to the user in case of bad password, etc.		*)
(*									*)
(************************************************************************)

procedure show_chars;

var
  temp : integer;

begin
  if nchars > 3
  then
    begin
      term.write_message_line ('(:13:)(:10:)UNEXPECTED RESPONSE: \' , tt_ans);
      temp := 3;
      repeat
	form.start;
	repeat
	  form.character (cir.chars.file_data[temp]);
	  temp := temp + 1
	until
	  (form.buffer.size >= MESSAGE_BUFFER_TEXT_LIMIT) or (temp >= nchars);
        form.write_string (term, tt_ans)
      until (temp >= nchars) or (tt_ans <> COMPLETE)
    end
end (* show_chars *);



(*******************************xfr**************************************)
(*									*)
(*				get_cir_char				*)
(*									*)
(*	Input 1 char into "cir.chars" and save in "cir.chars" with	*)
(*	a pointer of "nchars".						*)
(*									*)
(************************************************************************)

procedure get_cir_char;

begin
  rd_cir(20, 1, cir, aux_ans);
  if aux_ans = COMPLETE
  then
    begin
      if nchars < mx_elf_data	"only save mx_elf_data chars in cir"
      then cir.chars.file_data[nchars] := cir.chars.file_data[1];
      nchars := nchars + 1
    end
end (* get_cir_char *) ;



(****************************   control (CMF ROUTINE)********************)
(*									*)
(*			set_to_seven_bits				*)
(*									*)
(*		If one char enters with it's eighth bit set to 1,then	*)
(*		     exits with 0					*)
(*									*)
(************************************************************************)

procedure set_to_seven_bits( var ch : char );

begin
  if ord(ch) >= 128
  then ch := chr(ord(ch) - 128)
end (* set_to_seven_bits *) ;


(****************************   control (CMF ROUTINE)********************)
(*									*)
(*				start_netport				*)
(*									*)
(*	Once UNIX-CMF is reached, sends netport-login			*)
(*									*)
(************************************************************************)

procedure start_netport;

var
  temp   : integer;
  log_in : string24;

begin
  log_in := 'login:    Password:     ';"set up of what we expect"
  temp := 1;
  repeat          	"wait till 'login:' requested"
    get_cir_char;
    if aux_ans = complete
    then
      begin
	"chars sent by tymix have their eighth"
	set_to_seven_bits(cir.chars.file_data[1]);
	"bit either to 1 or 0 (parity)	      "
	if cir.chars.file_data[1] = log_in[temp]
	then temp := temp + 1
	else
	  if cir.chars.file_data[1] = log_in[1]
	  then temp := 2
	  else temp := 1
      end
  until (aux_ans <> complete) or (temp > 6 );
  if (aux_ans = complete)
  then
    begin
    "send cmf login"
    cirio.write_message_line (netport_login_username, aux_ans);
    temp := 11;
    repeat	"wait till 'Password:' requested"
      get_cir_char;
      if aux_ans = complete
      then
	begin
	  set_to_seven_bits(cir.chars.file_data[1]);
	  if cir.chars.file_data[1] = log_in[temp]
	  then temp := temp + 1
	  else
	    if cir.chars.file_data[1] = log_in[11]
	    then temp := 12
	    else temp := 11
	end
    until (aux_ans <> complete) or ( temp > 19 );
    if aux_ans = complete
    then	"send password"
      begin
	cirio.write_message_line (netport_login_password, aux_ans);
	repeat	"wait till login complete"
	  get_cir_char
	until (aux_ans <> complete) or (cir.chars.file_data[1] = '(:41:)')
	"41 is sent by netport to tell it is ready to receive"
      end
    end;
end (* start_netport *) ;



(****************************   control   *******************************)
(*									*)
(*				st_ob_slv				*)
(*									*)
(*	Send the necessary characters to the TYMCOM-X to turn echo	*)
(*	off, set logout, start the slave and perform the handshake.	*)
(*	"nchars" is set up to pt to "cir" which contains any		*)
(*	chars recieved from the circuit.				*)
(*									*)
(************************************************************************)


procedure st_ob_slv;

var
  shake : array [shake_inx] of char;
  temp  : integer;

begin
  if not cmf_host
  then
    cirio.write_newline (aux_ans);	"in case of a detached job"
  if aux_ans = COMPLETE
  then
    begin
      if cmf_host
      then 
	start_netport	"cmf - unix login"
      else			"tymcom-x host"
	begin
	  (* don't allow detach *)
	  cirio.write_message_line ('SET LOGOUT\ ', aux_ans);
	  (* call slave *)
	  cirio.write_message_line ('RUN (SOURCE)ELFSLV\ ', aux_ans);
        end;
      shake[1] := '(:41:)';	"first set up table of handshake chars"
      shake[2] := '(:42:)';
      shake[3] := '(:43:)';
      if aux_ans = COMPLETE
      then
        for temp := 1 to N_OF_SHAKE do	(* send handshake *)
	  snd_cir_ch(shake[temp]);
      temp := 1;		(* get handshake *)
      repeat
        if aux_ans = COMPLETE
        then get_cir_char;
        if aux_ans = COMPLETE
        then
	  if cir.chars.file_data[1] = shake[temp]
	  then temp := temp + 1
	  else temp := 1
      until (aux_ans <> COMPLETE) or (temp > N_OF_SHAKE);
      if aux_ans = COMPLETE
      then
	begin
	  if cmf_host
	  then term.write_message_line ('CIRCUIT BUILT TO CMF HOST\', tt_ans)
	  else
          term.write_message_line ('CIRCUIT BUILT TO TYMCOM-X\', tt_ans)
	end
      else
	begin
	  term.write_message_line ('HANDSHAKE FAILED\ ', tt_ans);
	  if cmf_host
	  then snd_cir_ch(EXIT_SLAVE);
	  zap_aux_circuit
 	end
    end
end (* st_ob_slv *) ;



(****************************   control   *******************************)
(*									*)
(*			    build_non_standard				*)
(*									*)
(*	User has specified that the login to the TYMCOM-X is a		*)
(*	non-standard one.  The circuit is built to the gateway in the	*)
(*	ELF network.  Allow user to continue building the circuit by	*)
(*	entering login characters ahd having them sent out over the	*)
(*	circuit.  Send all circuit characters received to the user's	*)
(*	terminal.							*)
(*									*)
(************************************************************************)

procedure BUILD_NON_STANDARD;

var
  chars_waiting,
  lines_waiting : integer;

begin
  term.write_newline (tt_ans);
  term.write_message_line (
    'PROCEED WITH NON-STANDARD LOGIN TO TYMNET,\ ', tt_ans);
  term.write_message_line ('THEN ENTER <break>:\', tt_ans);
  repeat
    term.any_input(0, chars_waiting, lines_waiting, tt_ans);
    if (chars_waiting > 0) and (tt_ans = COMPLETE)
    then	(* if any characters waiting, input and send to circuit *)
      begin
  	term.read_line(term_line, tt_ans);
	term_line.length := term_line.length + 1;
	term_line.chars[term_line.length] := '(:13:)';
	if tt_ans = COMPLETE
	then cirio.wr_line_rec(term_line, FALSE, aux_ans)
      end;
    cirio.any_input(0, chars_waiting, lines_waiting, aux_ans);
    if chars_waiting > 0
    then
      begin
        if chars_waiting > MX_ELF_CRS	(* only input what we can hold *)
	then chars_waiting := MX_ELF_CRS;
	cirio.rd_cr_chs(0, chars_waiting, cir, aux_ans);
	term.wr_cir_line(cir, tt_ans)
      end
    until (tt_ans <> COMPLETE) or (aux_ans <> COMPLETE);
  term.clr_brk_st(tt_ans)
end (* build_non_standard *);



(****************************   control   *******************************)
(*									*)
(*				build_x75				*)
(*									*)
(*	Build a circuit through an X75 gateway.				*)
(*									*)
(************************************************************************)

procedure BUILD_X75;

begin
  repeat
    get_cir_char
  until (aux_ans <> COMPLETE) or (cir.chars.file_data[1] = semi_colon);
  if (aux_ans = COMPLETE) or (aux_ans = TIMED_OUT)
  then
    with aux, info do
      begin
	form.start;
	form.move_from_elf_chs (5, dnic, 1);
	form.character (CONTRL_D);
	form.character (CONTRL_H);
	add_user_host(user, userlen, hostf, host);
	form.character (CR);
	form.write_string (cirio, aux_ans);
	for n := 1 to 5 do wait;
	form.start;
	form.move_from_elf_chs (password.length, password.chars, 1);
	form.write_string (cirio, aux_ans);
	form.start
      end
end (* build_x75 *);



(****************************   control   *******************************)
(*									*)
(*				build_obj_circuit			*)
(*									*)
(*	Build a circuit to the specified TYMCOM-X thru the		*)
(*	specified gateway.						*)
(*									*)
(************************************************************************)

procedure build_obj_circuit;

begin
  nchars := 3;	"set up to save incoming chars from cir"
  form.character (CONTRL_H) (* make circuit half duplex to avoid echo *);
  with aux, info do
    if g_userlen = 0
    then 	"no gateway, just build to TYMCOM-X"
      begin
	if cmf_host
	then term.write_message_line ('BUILDING CIRCUIT TO CMF HOST\ ', tt_ans)
	else
	  term.write_message_line('BUILDING CIRCUIT TO TYMCOM-X\ ', tt_ans);
	mk_ob_login(user, userlen, hostf, host, no_passw, token);
	login;
      cirio.send_siix
      end
    else
      begin
	if non_standard		"login to gateway"
	then
	  begin
	    make_normal_login (
	      g_user, g_userlen, g_hostf, g_host, g_password);
	    normal_login
	  end
	else
	  begin
	    mk_ob_login(g_user, g_userlen, g_hostf, g_host, no_passw, token);
	    login
	  end;
	if aux_ans = COMPLETE
	then
	  begin
	    term.write_message_line ('CIRCUIT BUILT TO GATEWAY\ ', tt_ans);
	    if non_standard
	    then build_non_standard;
	    if g_x75
	    then build_x75
	    else
	      begin
	        form.start;
		form.character (CONTRL_D);
	        mk_ob_login(user, userlen, hostf, host, use_passw, password)
	      end;
	    if (aux_ans = complete) and (tt_ans <> FAILURE)
	    then form.write_line (cirio, aux_ans);
	    if g_x75
	    then cirio.send_siix
	  end
      end;
   st_ob_slv
end (* build_obj_circuit *);



(*******************   control   (circuit building routines)*************)
(*									*)
(*			mk_aux_log					*)
(*									*)
(*	This routine converts login information from "aux"		*)
(*	to a login message in "term_line".				*)
(*									*)
(************************************************************************)

procedure mk_aux_log;

begin
  with aux, info do
    begin
      if tymneti
      then	"if TYMNET-I, login with neighbornode:199"
	begin
	  form.number (neighbor, DECIMAL);
	  form.string  (':199\ ')
	end
      else

        if mxp_load
	then
	  begin	(* if TYMNET-II, MXP, login with SHAMAN:kernelhost *)
	    form.string ('shaman:\');
	    form.number (krnl_host, decimal)
	  end
	else

	  begin	(* if TYMNET-II, non-MXP, login with DLOAD:kernelhost *)
	    form.string ('dload:\ ');
	    form.number (krnl_host, decimal)
	  end;
      form.character (SEMI_COLON)
    end (* with *)
end (* mk_aux_log *);



(****************************   control   *******************************)
(*									*)
(*			bld_dl_cir					*)
(*									*)
(*	Build downline circuit.						*)
(*									*)
(************************************************************************)

procedure bld_dl_cir;

var
 char_sent : char;

begin
  mk_aux_log;
  login;
  if aux_ans = COMPLETE
  then
    begin
      if aux.info.mxp_load
      then char_sent := chr(aux.info.mxp_machine)
      else char_sent := chr(aux.info.line_number);
      snd_cir_ch(char_sent);
      rd_cir(30, 1, cir, aux_ans);
      if aux.info.tymstar_load
      then char_sent := chr(ord(char_sent) + 64) (* Set 40 hex in line # *) ;
      if (aux_ans = COMPLETE) and (cir.chars.file_data[1] = char_sent)
      then
	begin
	  if aux.info.tymstar_load
	  then cirio.write_right_half (aux.info.target_node, aux_ans);
	  term.write_message_line ('CIRCUIT BUILT TO NEIGHBOR\', tt_ans)
	end
      else
	begin
	  zap_aux_circuit;
	  if aux_ans = COMPLETE
	  then aux_ans := DOWNL_FAILURE
	end
    end
end (* bld_dl_cir *);



(****************************   control   *******************************)
(*									*)
(*				fnd_sl_shk				*)
(*									*)
(*	Output "slot_char" and						*)
(*	search for escape character followed by a "2" from slot.	*)
(*									*)
(************************************************************************)


procedure fnd_sl_shk(slot_char : char);

begin
  snd_cir_ch(slot_char);	"output character"
  find_char(escape_ch);
  find_char(two)
end (* fnd_sl_shk *);



(****************************   control   *******************************)
(*									*)
(*				init_slot				*)
(*									*)
(*	Halt slot and init mac if this is a load slot command.		*)
(*									*)
(************************************************************************)

procedure init_slot;

begin
  snd_cir_ch('(:195:)'); "set binary input"
  fnd_sl_shk('(:194:)');
  fnd_sl_shk('(:200:)');	"halt slot"
  "init mac"
  if (this_cmd.prg_name = cload) and (this_sub.sub_prg = sslot)
  then fnd_sl_shk('(:193:)')	"init mac"
end (* init_slot *);



(****************************   control   *******************************)
(*									*)
(*				bld_sl_cir				*)
(*									*)
(*	Perform the actual slot build.					*)
(*									*)
(************************************************************************)

procedure bld_sl_cir;

begin
  form.string ('gateway:\ ');
  form.number (aux.info.krnl_host, decimal);
  form.character (SEMI_COLON);
  login;
  if aux_ans = COMPLETE
  then
    begin
      find_char(SL_PROMPT);
      snd_cir_ch(chr(aux.info.slot));
      find_char(cmd_prompt);
      init_slot;
      if aux_ans = complete
      then term.write_message_line ('CIRCUIT BUILT TO SLOT\', tt_ans)
      else zap_aux_circuit
    end
end (* bld_sl_cir *);



(******************************   control   *****************************)
(*									*)
(*			    save_segs_in_header				*)
(*									*)
(*      Save segments in header (cir_ans.chars.file_data).		*)
(*									*)
(************************************************************************)

procedure save_segs_in_header;

begin
  for this_seg := 0 to max_seg do
    if this_seg in seg_set
    then cir_ans.chars.file_data[hd_u_name_x + this_seg] := '1'
    else cir_ans.chars.file_data[hd_u_name_x + this_seg] := asc0
end (* save_segs_in_header *);



(****************************   control   *******************************)
(*									*)
(*				get_seg_sizes				*)
(*									*)
(*	This routine reads seg 14. to determine size of segs, and	*)
(*	computes the amount of disk space required to save code.	*)
(*									*)
(************************************************************************)

procedure get_seg_sizes;

var
  temp : integer;

begin
  dl_addr := st_seg_0e;
  get_seg_blk(size_seg_oe);
  if res_in = complete
  then
    begin
      temp := 9;	(* location where memory area requirements are stored *)
      for n := 0 to max_seg-1 do
        begin
          seg_length[n] := wd_to_int(cir.chars.file_data, temp);
          temp := temp + byts_in_wd
        end
    end;
  if this_sub.sub_prg = sslot
  then
    for this_seg := 0 to max_seg - 1 do
      if seg_length[this_seg] <> 0
      then seg_set := seg_set or [this_seg];
  save_segs_in_header;
  exp_b_ct := 0;
  for this_seg := 0 to max_seg do
    if this_seg in seg_set
    then
      begin
        exp_b_ct := exp_b_ct + (seg_length[this_seg] div mx_sl_data);
        temp := seg_length[this_seg] mod mx_sl_data;
        if temp <> 0 then exp_b_ct := exp_b_ct + 1
      end;
  exp_b_ct := exp_b_ct * mx_sl_data
end (* get_seg_sizes *);


(****************************   control   *******************************)
(*									*)
(*				get_cir					*)
(*									*)
(*	Check to see if a circuit is already built.  If it is and	*)
(*	it is the same circuit as the user wants built now, just	*)
(*	tell user already built and return.  Otherwise, zap any		*)
(*	old circuit and build a new one.				*)
(*									*)
(************************************************************************)

procedure get_cir;

var
  temp : integer;

begin
  old_circuit := FALSE;
  if all_ok
  then
    repeat
      if gt_aux_cir and (last_aux.info <> aux.info)
      then
	begin
	  term.write_message_line ('ZAPPING CIRCUIT\', tt_ans);
	  zap_aux_circuit
	end;
      if not gt_aux_cir
      then
	begin
	  form.start;
	  form.character (CONTRL_D);	"start w/control d character"
	  if this_cmd.prg_name = ccreate
	  then build_obj_circuit
	  else
	    if this_sub.sub_prg = snode
	    then bld_dl_cir
	    else bld_sl_cir;
	  if gt_aux_cir and (aux_ans = complete)
	  then last_aux := aux
	end
      else
	begin
	  cirio.any_input(0, nchars, nlines, temp_ans);
	  if temp_ans = FAILURE
	  then
	    begin
	      temp_ans := COMPLETE;
	      repeat
		rd_cir(30, 1, cir, temp_ans)
	      until (temp_ans = FAILURE) or (not all_ok)
	    end;
	  if gt_aux_cir
	  then
	    begin
	      old_circuit := TRUE;
	      term.write_message_line ('CIRCUIT ALREADY BUILT\', tt_ans);
	      if (this_cmd.prg_name = cload) and (this_sub.sub_prg <> snode)
	      then init_slot
	    end
	  else term.write_message_line ('RE-BUILDING CIRCUIT\', tt_ans)
	end;
      if (this_cmd.prg_name = ccreate) and (aux_ans = timed_out)
      then
	begin
	  zap_aux_circuit;
	  show_chars;
	  term.write_newline (tt_ans);
	  term.write_newline (tt_ans);
	  term.write_message_line (
	    'NO RESPONSE, WILL TRY AGAIN IN 30 SEC.\ ', tt_ans);
	  temp := 30;
	  repeat (*wait for 30 seconds or a break *)
	    wait; temp := temp - 1
	  until (temp <= 0) or check_for_stop;
	  aux_ans := complete
	end
    until gt_aux_cir or not all_ok
end (* get_cir *);
!
      (*   CNTRL3.ELF Updated 10-Sep-86 at 11:23 by Raffo    *)

(************************************************************************)
(*									*)
(*	File Routines							*)
(*									*)
(************************************************************************)



(*************   control   (file routine)********************************)
(*									*)
(*				iden_ob_f				*)
(*									*)
(*	Transmit command and file name to the TYMCOM-X and input	*)
(*	the answer.							*)
(*									*)
(************************************************************************)

procedure iden_ob_f;

begin
  found := false;
  snd_cir_ch(obj_cmd);
  form.start;	"send file description"
  form.move_from_elf_chs (MX_UN_SZ, file_desc.user, 1);
  form.move_from_elf_chs (MX_FN_SZ, file_desc.file, 1);
  form.move_from_elf_chs (MX_EXT_SZ, file_desc.ext, 1);
  form.write_string (cirio, aux_ans);
  rd_cir(60, 1, cir, aux_ans);
  if aux_ans = complete
  then
    begin
      temp_ch := cir.chars.file_data[1];
      if temp_ch = FILE_FOUND
      then found := TRUE	"file found"
      else
	if temp_ch = FL_NOT_FND
	then term.write_message_line (FNF_M, tt_ans)
	else
	  if temp_ch = NOT_NIB
	  then term.write_message_line (NOT_NIB_M, tt_ans)
	  else
	    if temp_ch = NOT_EQUIV
	    then term.write_message_line (NOT_EQUIV_M, tt_ans)
	    else
	      if temp_ch = SYS_ERR
	      then term.write_message_line (SYS_ERR_M, tt_ans)
	      else aux_ans := SYNC_ERROR
    end
end (* iden_ob_f *);



(****************************   control   (file routines)****************)
(*									*)
(*			get_obj_file_name				*)
(*									*)
(*	Input object file name from user.				*)
(*									*)
(************************************************************************)

procedure get_obj_file_name;

var
  temp : integer;
  user_length : term_sz;

begin
  if all_ok
  then
    begin
      term.write_message_string (OBJ_FILE_M, tt_ans);
      repeat
	term.read_line (term_line, tt_ans);
	  ptr := 1;
	  if tt_ans = COMPLETE
	  then
	    begin	    "in case of null username"
	      for temp := 1 to MX_UN_SZ do
		file_desc.user[temp] := ZERO;
	      if term_line.chars[ptr] <> L_PAREN
	      then found := TRUE
	      else
		begin
		  ptr := ptr + 1;		"skip left parentheses"
		  cmn.input_user (term_line, ptr, file_desc.user, user_length);
		  if term_line.chars[ptr] <> R_PAREN
		  then found := TRUE
		  else
		    begin
		      ptr := ptr + 1;	"skip right parentheses"
		      found := TRUE
		    end
		end;
	      if found
	      then
		begin
		  cmn.input_file(term_line, ptr, file_desc, found);
		  if not found
		  then tell_fmt('(USER)FILE.EXT\ ', tt_ans)
		end
	    end
	until found or (tt_ans <> COMPLETE)
    end
end (* get_obj_file_name *);



(****************************   control   (file routines)****************)
(*									*)
(*			input_and_locate_file				*)
(*									*)
(*	Input file name from user and locate file on TYMCOM-X.		*)
(*	Continue until error, file found or user inputs "?".		*)
(*									*)
(************************************************************************)

procedure input_and_locate_file;

var
  temp : integer;

begin
  if all_ok then
    with term, cmn, file_desc, term_line do
      begin
	repeat
	  found := false;
	  get_obj_file_name;
	  if found and (tt_ans = COMPLETE)
	  then iden_ob_f
        until found or not all_ok
      end
end (* input_and_locate_file *);



(********************   control   (device routines)**********************)
(*									*)
(*				ask					*)
(*									*)
(*	This function inputs a yes/no answer from the user and returns	*)
(*	true if the user entered yes, false if user entered no.		*)
(*									*)
(************************************************************************)

function ask(prompt : term_chs) : boolean;

begin
  ask := FALSE;
  term.write_message_string (prompt, tt_ans);
  term.write_message_string (QUESTION_M, tt_ans);
  repeat
    found := FALSE;
    term.read_line (term_line, tt_ans);
    if tt_ans = COMPLETE
    then
      if term_line.chars[1] = ASCY
      then
	begin
	  found := TRUE;
	  ask := TRUE
	end
      else
	if term_line.chars[1] = ASCN
	then found := TRUE
	else term.write_message_string ('TYPE Y OR N: \', tt_ans)
  until found or (tt_ans <> COMPLETE)
end (* ask *) ;



(***********   control   (CMF ROUTINE)   ********************************)
(*     									*)
(*			tell_default(path_level)                        *)
(*									*)
(*               Tell user what is it's default for:			*)
(*                'path_level' = 1 : network				*)
(*				 2 : partition				*)
(*                               3 : cluster				*)
(*				 4 : processor				*)
(*                               5 : slot				*)
(*									*)
(************************************************************************)

procedure tell_default(path_level : integer);

var
  n : integer;
  empty8 : string8;
  empty24 : string24;
 
begin
  for n := 1 to 8 do empty8[n] := zero;
  for n := 1 to 24 do empty24[n] := zero;
  form.start;
  with defaults,term do
    case path_level of
     1 :  begin
          form.string ('  NETWORK          : \');
	  if network <> empty24 
          then for n := 1 to 24 do form.character (network[n])
	  else form.string ('NO DEFAULT\ ')
	  end;
     2 :  begin
          form.string ('  PARTITION        : \');
	  if subnet <> empty24 
          then for n := 1 to 24 do form.character (subnet[n])
	  else form.string ('NO DEFAULT\ ')
	  end;
     3 :  begin
          form.string ('  CLUSTER (or NODE): \');
	  if cluster <> empty24 
          then for n := 1 to 24 do form.character (cluster[n])
	  else form.string ('NO DEFAULT\ ')
	  end;
     4 :  begin
          form.string ('  PROCESSOR        : \');
	  if processor <> empty8 
          then for n := 1 to 8 do form.character (processor[n])
	  else form.string ('NO DEFAULT\ ')
	  end;
     5 :  begin
          form.string ('  SLOT             : \');
	  if slot <> empty24 
          then for n := 1 to 24 do form.character (slot[n])
	  else form.string ('NO DEFAULT\ ')
	  end
    end (* end case *);
  form.write_line (term, tt_ans)
end; (* tell_default *)



(************* control  (CMF ROUTINE)   *********************************)
(*									*)
(*			cmf_ask(path_level)   				*)
(*                Ask user to type a name for a                         *)
(*                 (path_level = )  1  :  network			*)    
(*				    2  :  subnetwork			*)
(*                                  3  :  cluster			*)
(*				    4  :  processor			*)
(*				    5  :  slot				*)
(*									*)
(************************************************************************)

procedure cmf_ask(path_level : integer);

var
  n : integer;
  empty8 :string8;
  empty24 : string24;
 
begin
  for n := 1 to 8 do empty8[n] := zero;
  for n := 1 to 24 do empty24[n] := zero;
  form.start;
  with defaults,term_line do
    case path_level of
     1 :  begin
          form.string ('ENTER NETWORK           \ ');
	  if network <> empty24
	  then
	    begin
	      form.string ('( OR (CR) FOR \ ');
	      for n := 1 to 24 do form.character (network[n]);
	      form.character (')')
	    end
	  end;
     2 :  begin
          form.string ('ENTER PARTITION         \ ');
	  if subnet <> empty24
	  then
	    begin
	      form.string ('( OR (CR) FOR \ ');
	      for n := 1 to 24 do form.character (subnet[n]);
	      form.character (')')
	    end
	  end;
     3 :  begin
          form.string ('ENTER CLUSTER (or NODE) \ ');
	  if cluster <> empty24
	  then
	    begin
	      form.string ('( OR (CR) FOR \ ');
	      for n := 1 to 24 do form.character (cluster[n]);
	      form.character (')')
	    end
	  end;
     4 :  begin
          form.string ('ENTER PROCESSOR         \ ');
	  if processor <> empty8
	  then
	    begin
	      form.string ('( OR (CR) FOR \ ');
	      for n := 1 to 8 do form.character (processor[n]);
	      form.character (')')
	    end
	  end;
     5 :  begin
          form.string ('ENTER SLOT              \ ');
	  if slot <> empty24
	  then
	    begin
	      form.string ('( OR (CR) FOR \ ');
	      for n := 1 to 24 do form.character (slot[n]);
	      form.character (')')
	    end
	  end
    end (* end case *) ;
  form.newline;
  form.string('   NAME:  \ ');
  form.write_string (term, tt_ans)
end;



(***********   control   (CMF ROUTINE)    *******************************)
(*									*)
(*                      get_name(path_level)				*)
(*									*)
(*                Get from user a name which will be stored in         	*)
(*       (path_level =)    1 :  current_file.network   			*)
(*                         2 :  current_file.subnet			*)
(*                         3 :  current_file.cluster			*) 
(*                         4 :  current_file.processor			*)
(*                         5 :  current_file.slot			*)
(*									*)
(************************************************************************)

procedure get_name(path_level :integer );

var
  n : integer;
  too_long : boolean;

begin
  repeat
    too_long := false;
    term.read_line(term_line,tt_ans);
    if tt_ans = COMPLETE then
      begin
        ptr := 1;
        if term_line.length > 0 then
	with term_line,current_file do
	    if ((path_level = 4) and (length > 8)) or (length > 24)
	    then
              begin
	        term.write_message_string ('TOO LONG, REENTER: \', tt_ans);
	        too_long := true
	      end
            else
	      begin
		if length < MX_TT_CHS then
	          for n := length+1 to MX_TT_CHS do chars[n] := zero;
       		case path_level of
		     1 :  for n := 1 to 24 do network[n]   := chars[n];
		     2 :  for n := 1 to 24 do subnet[n]    := chars[n];
		     3 :  for n := 1 to 24 do cluster[n]   := chars[n];
		     4 :  for n := 1 to  8 do processor[n] := chars[n];
		     5 :  for n := 1 to 24 do slot[n]      := chars[n]
	        end (* end case *)
	      end
    end (* end if *)
  until not too_long
end;



(****************  control (CMF ROUTINE )      **************************)
(*									*)
(*	          	send(path_level)				*)
(*									*)
(*		send user's choice to netport				*)
(*									*)
(************************************************************************)

procedure send(path_level : integer);

var
  n :integer;

begin 
  form.start;
  with current_file do
    case path_level of
     1 :  for n := 1 to 24 do form.character (network[n]);
     2 :  for n := 1 to 24 do form.character (subnet[n]);
     3 :  for n := 1 to 24 do form.character (cluster[n]);
     4 :  for n := 1 to 8  do form.character (processor[n]);
     5 :  for n := 1 to 24 do form.character (slot[n])
    end;
  form.write_string (cirio, aux_ans)
end;



(**************** control (CMF ROUTINE )   ******************************)
(*									*)
(*			get_answer					*)
(*									*)
(*			get one char from aux_circuit			*)
(*			and save it in netport_ans			*)
(*									*)
(************************************************************************)

procedure get_answer( var netport_ans : char);

begin
  rd_cir(20,1,cir,aux_ans);
  set_to_seven_bits(cir.chars.file_data[1]);
  if aux_ans = COMPLETE then netport_ans := cir.chars.file_data[1]
end;

(************* control  (CMF ROUTINE)    ********************************)
(*									*)
(*			tell_incorrect(path_level)			*)
(*                Tell user that what he wants is incorrect             *)
(*									*)
(************************************************************************)

procedure tell_incorrect(path_level : integer);

begin
  case path_level of
   1 : term.write_message_line ('INCORRECT NETWORK    \', tt_ans);
   2 : term.write_message_line ('INCORRECT PARTITION  \', tt_ans);
   3 : term.write_message_line ('INCORRECT CLUSTER    \', tt_ans);
   4 : term.write_message_line ('INCORRECT PROCESSOR  \', tt_ans);
   5 : term.write_message_line ('INCORRECT SLOT       \', tt_ans)
  end (*  end case *)
end;

(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*			init_defaults					*)
(*									*)
(************************************************************************)

procedure init_defaults;

var
  n : integer;

begin
  with defaults do
    begin
      for n := 1 to 24 do network[n] := zero;
      for n := 1 to 24 do subnet[n]  := zero;
      for n := 1 to 24 do cluster[n] := zero;
      for n := 1 to 8 do processor[n]:= zero;
      for n := 1 to 24 do slot[n]    := zero
    end
end;

(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*			put_in_defaults					*)
(*									*)
(************************************************************************)

procedure put_in_defaults(in_line : elf_rec);

var
  n : integer;

begin
  with in_line,defaults do
    begin
      for n := 1 to 24 do network[n] := chars.file_data[n];
      for n := 1 to 24 do subnet[n]  := chars.file_data[n + 24];
      for n := 1 to 24 do cluster[n] := chars.file_data[n + 48];
      for n := 1 to 8 do processor[n]:= chars.file_data[n + 72];
      for n := 1 to 24 do slot[n]    := chars.file_data[n + 80]
    end
end;

(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*			check_unix					*)
(*									*)
(************************************************************************)

procedure check_unix(var in_line : elf_rec;
		     var unix_file : boolean);

var
  n : integer;
  temp_unix : line_rec;

begin
  form.simple_message('** UNIX ***\');
  form.store_to_line_rec (temp_unix);
  rd_cir(20,11,in_line,aux_ans);
  if aux_ans = COMPLETE 
  then
    for n := 11 downto 1 do
      if unix_file
      then unix_file := in_line.chars.file_data[n] = temp_unix.chars[n];
end;

(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*			get_defaults					*)
(*									*)
(*	Get the default file from netport				*)
(*									*)
(************************************************************************)

procedure get_defaults;

var
  temp_default : elf_rec;
  temp_char : char;
  n         : integer;

begin
  init_defaults;
  "If the first char sent by netport is not 'badcmd' then "
  "  get defaults from cmf,stored in 'defaults' "
  unix_file := FALSE;
  rd_cir(5,1,cir,aux_ans);
  if aux_ans = COMPLETE
  then
    begin
      temp_char := cir.chars.file_data[1];
      if temp_char = UNKNOWN_RESPONSE
      then  "badcmd netport exits I must return to the cmd level"
	begin
	  term.write_message_line (UNEXPECTED_M, tt_ans);
	  snd_cir_ch(EXIT_SLAVE);
	  zap_aux_circuit
	end
      else
	if temp_char <> BAD_BLK
	then
	  begin
	    unix_file := temp_char = '*';
	    check_unix(temp_default, unix_file);
	    if not unix_file and (aux_ans = COMPLETE)
	    then
	      begin
	        rd_cir(20,92,cir,aux_ans);
		(* copy remaining 92 two chars read for total of 104 *)
	        for n := 92 downto 1 do
		  cir.chars.file_data[n+12] := cir.chars.file_data[n];
		(* copy chars 2 to 12 read to check for ** UNIX *** string *)
	        for n := 12 downto 2 do
		  cir.chars.file_data[n] :=
		    temp_default.chars.file_data[n - 1];
		(* copy char 1 read to check answer *)
	        cir.chars.file_data[1] := temp_char;
	        put_in_defaults(cir)
	      end
          end 
    end;
end (* get_defaults *) ;



(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*		       input_unix_file					*)
(*									*)
(*	Get a UNIX file from user,ask netport if exists,returns 'true'	*)
(*		if we got a file					*)
(*									*)
(*									*)
(************************************************************************)

procedure input_unix_file(var gotit : boolean);

var
  netport_ans : char;   "gets netport answers				 "
  n : integer;
  eng_file,
  exit,			"true if user wants to exit from cmf-protocol    "
  def			"true if user wants to work on it's default file "
	    : boolean;
  i : integer;

begin
  gotit := false;
  exit := false;
  while (not exit) and (not gotit) and all_ok do
  begin
    n := 0;
    eng_file := ask('IS FILE ENGINE CODE, ANSWER Y FOR ENGINE, NO FOR PICO\');
    if this_sub.sub_prg = SNODE
    then term.write_message_string (UNIX_EQ_M, tt_ans)
    else term.write_message_string (UNIX_FILE_M, tt_ans);
    repeat
      if eng_file then snd_cir_ch(ENG_CODE)
      else snd_cir_ch(PICO_CODE);
      term.read_line (term_line, tt_ans);
      term_line.chars[term_line.length + 1] := LF;
      term_line.length := term_line.length + 1;
      cirio.wr_line_rec (term_line, NO_CR, aux_ans);
      get_answer(netport_ans);
      if all_ok
      then found := (netport_ans = one );
      n := n + 1;
      if (not found) and (n < 2)
      then term.write_message_string(
	'UNIX FILE NOT FOUND, REENTER: \ ', tt_ans)
    until found or (n = 2) or not all_ok;
    if found and all_ok
    then gotit := true;
    if (not found) and all_ok 
    then
      begin
        term.write_message_string('UNIX FILE NOT FOUND,\ ', tt_ans);
        term.write_message_line (' START AGAIN OR EXIT,\', tt_ans);
        exit := ask('RESPOND YES TO EXIT, NO TO START AGAIN\ ');
        "tell cmf the answer"
        if exit then snd_cir_ch(EXIT_SLAVE)
        else snd_cir_ch(RETRY_FILE)
      end
    end
end (* input_unix_file *);




(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*		       input_cmf_file					*)
(*									*)
(*	Get a CMF file from user,ask netport if exists,returns 'true'	*)
(*		if we got a file					*)
(*									*)
(************************************************************************)

procedure input_cmf_file(var gotit : boolean);

var
  netport_ans : char;   "gets netport answers				 "
  index,k,n : integer;
  exit,			"true if user wants to exit from cmf-protocol    "
  def			"true if user wants to work on it's default file "
	    : boolean;

begin
  gotit := false;
  exit := false;
  while (not exit) and (not gotit) and all_ok do
    begin
      if obj_cmd = SEND_NODE then k := 4 else k := 5;
      def := false;
      " tells user what its defaults are,ask if he wants them"
      term.write_message_line ('YOUR DEFAULT FILE IS  :\', tt_ans);
      for index := 1 to k do tell_default(index);
      "ask user if he wants to work on it"  
      term.write_message_line('DO YOU WANT IT,\', tt_ans);
      def := ask('RESPOND YES FOR DEFAULTS, NO OTHERWISE\ ');
      "starts protocol between cmf and user"
      index := 1;"to know on which level we are"
      while index <= k do
        begin
	  n := 0;   "number of tries"
	  repeat
            current_file := defaults; 
	    if n <> 0 then tell_incorrect(index);
	    if (not def) or (n <> 0) then
	      begin
	        cmf_ask(index);
	        get_name(index)"puts user's will in 'current_file.'index''"
              end;	
	    "send answer (or default) to netport"
	    send(index); "sends 'current_file.'index''"
	    get_answer(netport_ans);
	    if  all_ok then found := (netport_ans = one );
	    n := n + 1;
          until found or (n = 2) or not all_ok;
	  if found and all_ok and (index = k) then gotit := true;
	  if (not found) and  all_ok 
          then
	    begin
	      tell_incorrect(index);
	      term.write_message_line ('START AGAIN OR EXIT,\ ', tt_ans);
	      exit := ask('RESPOND YES TO EXIT, NO TO START AGAIN\ ');
	      "tell cmf the answer"
	      if exit then snd_cir_ch(EXIT_SLAVE)
	      else snd_cir_ch(RETRY_FILE);
	      index :=k"to leave the inner'while',re_start to the beginning "
	    end;
	  index := index + 1
        end (* while index... *)
    end (* while not exit..... *)
end (*input_cmf_file *) ;



(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*		       get_user_file					*)
(*									*)
(*	Get a file from user,ask netport if exists,returns 'true'	*)
(*		if we got a file					*)
(*									*)
(************************************************************************)

function get_user_file : boolean;
  
var
  gotit : boolean;

begin
  if unix_file
  then input_unix_file(gotit)
  else input_cmf_file(gotit);
  if gotit
  then get_user_file := true
  else get_user_file := false
end (*get_user_file *) ;


(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*			input_object_file				*)
(*									*)
(*   get name of object file form user to store in header		*)
(*									*)
(************************************************************************)

procedure input_object_file;

var
  temp : integer;

begin
  file_desc.user := cmf_aux.cmf_user;
  "ask user for object filename"
  if all_ok
  then
    begin
      term.write_message_string (ENTER_OBJ_FILE_M, tt_ans);
      repeat
        ptr := 1;
	term.read_line (term_line, tt_ans);
	if tt_ans = COMPLETE
	then
	  begin
            cmn.input_file(term_line, ptr, file_desc, found);
            if not found
            then tell_fmt('FILE.EXT\ ', tt_ans)
	  end
      until found or (tt_ans <> COMPLETE)
    end
end (* input_object_file *);


(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*			special_filename				*)
(*									*)
(*   Ask netport for the special filename and fill 'file_desc' with it  *)
(*									*)
(************************************************************************)

procedure special_filename;

var
  n : integer;

begin
  file_desc.user := cmf_aux.cmf_user;
  "ask for special filename"
  snd_cir_ch(SEND_FILENAME);
  rd_cir(5,1,cir,aux_ans);
  if aux_ans = COMPLETE
  then
    begin
      if cir.chars.file_data[1] = UNKNOWN_RESPONSE
      then "badcmd2 netport exits I must return to the cmd level"
        begin
	  term.write_message_line (UNEXPECTED_M, tt_ans);
	  snd_cir_ch(EXIT_SLAVE);
	  zap_aux_circuit
	end
      else
        begin
	  form.start;
	  form.character (cir.chars.file_data[1]);
	  rd_cir(20,9,cir,aux_ans);	
	  if aux_ans = COMPLETE
	  then
            begin
	      for n := 1 to 9 do form.character (cir.chars.file_data[n]);
	      form.store_to_line_rec (token);
              ptr := 1;
              cmn.input_file(token,ptr,file_desc,found);
            end
        end
    end
end (* special_filename *) ;



(***********   control   (CMF ROUTINE)  *********************************)
(*									*)
(*                     cmf_inp_and_loc_file				*)
(*									*)
(*      Send command to CMF , get the defaults                          *)
(*      Input file name from user and locate file on CMF 		*)
(*									*)
(************************************************************************)

procedure cmf_inp_and_loc_file;

begin
if all_ok then
  begin
    "Send command to netport"
    snd_cir_ch(obj_cmd);
    get_defaults;
    if not all_ok
    then
      begin
	snd_cir_ch(EXIT_SLAVE);
        zap_aux_circuit
      end
    else
      if not get_user_file
      then "return to the command level"
        begin
	  snd_cir_ch(EXIT_SLAVE);
          zap_aux_circuit
        end
      else "fill 'file_desc'"
        begin
          if not unix_file
          then special_filename
          else input_object_file
        end
  end
end (* end cmf_inp_and_loc_file *) ;



(***********   control   (file routines)*********************************)
(*									*)
(*				add_f_desc				*)
(*									*)
(*	Append file username, filename and ext to header record.	*)
(*									*)
(************************************************************************)

procedure add_f_desc (
      file_desc		: obj_rec;
  var file_header	: univ load_file_header_record); 

begin
  if all_ok
  then
    begin
      file_header.object_file := file_desc;
      (* If null username, save object login username *)
      if file_desc.user[1] = ZERO
      then file_header.object_file.user := aux.info.user
    end
end (* add_f_desc *) ;



(****************************   control   *******************************)
(*									*)
(*				gt_st_add				*)
(*									*)
(*	Input start address from slave.  If = -1, ask user to input	*)
(*	start address.							*)
(*									*)
(************************************************************************)

procedure gt_st_add;

var
  temp : integer;

begin
  if all_ok and (this_sub.sub_prg = snode)
  then
    begin
      rd_cir(60, byts_in_wd, cir, aux_ans);
      mv_elf_chs (
	byts_in_wd, cir.chars.file_data, 1,
	cir_ans.chars.file_data, hd_st_adr_x);
      temp := wd_to_int(cir_ans.chars.file_data, hd_st_adr_x);
      if temp = -1
      then
	begin
	  term.write_message_line ('NO START ADDRESS FOUND IN FILE\ ', tt_ans);
	  input_number(st_up_msg, FALSE, hex, temp);
	  if temp <> -1
	  then int_to_chs(cir_ans.chars.file_data, temp, hd_st_adr_x)
	end
    end
end (* gt_st_add *);



(****************************   control   *******************************)
(*									*)
(*				gt_byte_ct				*)
(*									*)
(*	Input byte count of file from slave.				*)
(*									*)
(************************************************************************)

function gt_byte_ct : integer;

begin
  if all_ok	(* long time out count here in case the file is huge *)
  then rd_cir(600, byts_in_wd, cir, aux_ans);
  if aux_ans = COMPLETE
  then gt_byte_ct := wd_to_int(cir.chars.file_data, 1)
end (* gt_byte_ct *);



(******************************  control  *******************************)
(*									*)
(*				save_digit				*)
(*									*)
(************************************************************************)

procedure save_digit(int : integer;
		var hdr_index : elf_sz);

begin
  cir_ans.chars.file_data[hdr_index] := chr(ord(asc0) + int div 10);
  cir_ans.chars.file_data[hdr_index+1] := chr(ord(asc0) + int mod 10);
  hdr_index := hdr_index + 2
end (* save_digit *);



(******************************  control  *******************************)
(*									*)
(*				get_nib_creation			*)
(*									*)
(************************************************************************)

procedure get_nib_creation ;

var
  ptr : elf_sz;
  count : integer;

begin
  snd_cir_ch('(:4:)');
  rd_cir(60, 5, cir, aux_ans);
  ptr := hd_nib_date_x;
  for count := 1 to 3 do
    save_digit(ord(cir.chars.file_data[count]), ptr);
  cir_ans.chars.file_data[hd_nib_date_x+6] := space;
  cir_ans.chars.file_data[hd_nib_date_x+7] := space;
  ptr := hd_nib_time_x;
  for count := 4 to 5 do
    save_digit(ord(cir.chars.file_data[count]), ptr)
end (* get_nib_creation *);

!
      (*   CNTRL4.ELF Updated 24-Jul-85 at 11:42 by Raffo     *)

(************************************************************************)
(*									*)
(*	Output Routines							*)
(*									*)
(************************************************************************)



(**************   control   (output routines)****************************)
(*									*)
(*				type_bit				*)
(*									*)
(*	This routine outputs the message "bit_m" if the least		*)
(*	significant bit in "word" is on.  "word" is shifted right	*)
(*	"bits_to_skip" bits.						*)
(*									*)
(************************************************************************)

procedure type_bit(bit_m : term_chs;
		var word : integer;
		bits_to_skip : integer);

begin
  if word mod 2 = 1 then term.write_message_line (BIT_M, tt_ans);
  for n := 1 to bits_to_skip do word := word div 2
end (* type_bit *) ;



(****************************   control   *******************************)
(*									*)
(*			typ_hdw_st					*)
(*									*)
(*	Output hardware status of "dev.unit".				*)
(*									*)
(************************************************************************)

procedure typ_hdw_st (device_status : integer);

var
  word : integer;

begin
  term.write_message_line ('HARDWARE STATUS: \', tt_ans);
  word := device_status div 2;
  type_bit('BOT\', word, 1);
  type_bit('WRITE PROTECTED\', word, 1);
  type_bit('HIGH DENSITY\ ', word, 1);
  type_bit('ILLEGAL OPERATION\', word, 3);
  type_bit('PARITY ERROR\ ', word, 1);
  type_bit('DEVICE UNAVAILABLE\ ', word, 5);
  type_bit('BOT OR EOT\ ', word, 1);
  type_bit('EOF DETECTED\ ', word, 1);
  type_bit('READ/WRITE ERROR\ ', word, 1)
end (* typ_hdw_st *) ;




(**************   control   (output routines)****************************)
(*									*)
(*			get_and_type_dev_status				*)
(*									*)
(*	This routine outputs device status to user.			*)
(*									*)
(************************************************************************)

procedure get_and_type_dev_status (var dev : dev_rec);

var
  info		: disk_tape_information;
  word		: integer;
  event_status	: disk_drive_device_status;
  event_time	: integer;

begin
  case dev.kind of
    TAPE:
      devs.drive_status(dev, info, io_error, ctr_stat);
    DISK:
      begin
	disk_mon[dev.unit].disk_failure_info (event_status, event_time);
	if event_status <> DISK_OKAY
	then
	  begin
	    form.simple_message ('Disk system error: \');
	    form.disk_drive_device_status_name (event_status);
	    form.write_line (term, tt_ans);
	    form.simple_message ('Occurred at \ ');
	    form.time (event_time);
	    form.write_line (term, tt_ans);
	    term.write_newline (tt_ans)
	  end;
	disk_mon[dev.unit].get_disk_info (info)
      end
  end (* case *) ;

  "output isis logical unit number"
  term.write_newline (tt_ans);
  form.number_message ('ISIS LU: \', info.logical_unit_number, DECIMAL);
  form.write_line (term, tt_ans);

  "output slot license"
  term.write_message_line ('LICENSE: \', tt_ans);
  word := info.protection_mask;
  type_bit('ATTACH/DETACH\', word,  1);
  type_bit('WRITE\', word, 1);
  type_bit('READ\ ', word, 1);

  "output default block size"
  form.number_message (
    'DEFAULT BLOCK SIZE:\', info.default_block_size, DECIMAL);
  form.write_line (term, tt_ans);

  "output hardware status"
  typ_hdw_st(info.device_status);

  "output additional disk information"
  if dev.kind = DISK
  then
    begin
      type_disk_address (
	dev, disk_mon[dev.unit].disk_start, disk_mon[dev.unit].disk_size);
      form.number_message (
	'SECTORS USED: \ ', disk_mon[dev.unit].disk_space_used, DECIMAL);
      form.write_line (term, tt_ans)
    end
end (* get_and_type_dev_status *) ;



(****************************   control   *******************************)
(*									*)
(*			    output_file_type				*)
(*									*)
(************************************************************************)

procedure output_file_type(
      short_output	: boolean);

begin
  if elf_f_type = PT_LD_FILE
  then
    if short_output
    then term.write_message_string ('P SLOT LOAD \ ', tt_ans)
    else term.write_message_string ('PARTIAL SLOT LOAD \ ', tt_ans)
  else
    if elf_f_type = PT_DP_FILE
    then
      if short_output
      then term.write_message_string ('P SLOT DUMP \ ', tt_ans)
      else term.write_message_string ('PARTIAL SLOT DUMP \ ', tt_ans)
    else
      begin
        case elf_f_type of
	  ND_LD_FILE:    term.write_message_string ('NODE LOAD  \', tt_ans);
	  SL_LD_FILE:    term.write_message_string ('SLOT LOAD  \', tt_ans);
	  ND_DP_FILE:    term.write_message_string ('NODE DUMP  \', tt_ans);
	  SL_DP_FILE:    term.write_message_string ('SLOT DUMP  \', tt_ans);
	  INTERNAL_FILE: term.write_message_string ('INTERNAL   \',tt_ans);
	  EMPTY_FILE:    term.write_message_string ('EMPTY      \',tt_ans);
	  ERROR_FILE:    term.write_message_string (
			'*FILE TYPE NOT RECOGNIZABLE*\ ', tt_ans)
	end (* case *) ;
	if not short_output
	then term.write_message_string ('       \', tt_ans)
      end
end (* output_file_type *) ;


(****************************   control   *******************************)
(*									*)
(*				type_f_t				*)
(*									*)
(*	Output file type to user.					*)
(*									*)
(************************************************************************)

procedure type_f_t;

begin
  if elf_f_type <> F_FILE
  then
    begin
      term.write_message_string ('FILE TYPE: \', tt_ans);
      output_file_type(FALSE);
      term.write_message_string (SPACES_M, tt_ans)
    end
end (* type_f_t *) ;



(****************************   control   *******************************)
(*									*)
(*				type_vers				*)
(*									*)
(*	Output version number and revision number in header.		*)
(*									*)
(************************************************************************)

procedure type_vers (v, r : integer);

begin
  form.number_message ('ELF VERSION \ ', v, DECIMAL);
  form.character (DOT);
  form.format_number (r, DECIMAL, -2);
  form.write_line (term, tt_ans)
end (* type_vers *) ;



(****************************   control   *******************************)
(*									*)
(*				type_date				*)
(*									*)
(*	Output date and time from header record.			*)
(*									*)
(************************************************************************)

procedure type_date (
      msg_to_output	: term_chs;
      date		: file_header_date);

var
  i : integer;

begin
  term.write_message_string (msg_to_output, tt_ans);
  form.start;
  for i := 1 to 2 do form.character (date[i]);
  form.character (SLASH);
  for i := 3 to 4 do form.character (date[i]);
  form.character (SLASH);
  for i := 5 to 10 do form.character (date[i]);
  form.character (COLON);
  for i := 11 to 12 do form.character (date[i]);
  form.write_string (term, tt_ans)
end (* type_date *) ;



(****************************   control   *******************************)
(*									*)
(*			type_object_file_name				*)
(*									*)
(*	Output file description from h_rec.chars.			*)
(*									*)
(************************************************************************)

procedure TYPE_OBJECT_FILE_NAME(
      file_msg	: term_chs;
      header	: univ load_file_header_record;
      crf	: boolean);

var
  temp : integer;

begin
  if elf_f_type <= PT_LD_FILE
  then
    begin
      term.write_message_string (file_msg, tt_ans);
      form.start;
      form.character (L_PAREN);
      form.move_from_elf_chs (MX_UN_SZ, header.object_file.user, 1);
      form.character (R_PAREN);
      for temp := 1 to MX_FN_SZ do
	begin
	  temp_ch := header.object_file.file[temp];
	  if temp_ch <> SPACE
	  then form.character (temp_ch)
	end (* for *) ;
      form.character (DOT);
      for temp := 1 to MX_EXT_SZ do
	begin
	  temp_ch := header.object_file.ext[temp];
	  if temp_ch <> SPACE
	  then form.character (temp_ch)
	end;
      if crf
      then form.newline;
      form.write_string (term, tt_ans)
    end
end (* type_object_file_name *) ;



(****************************   control   *******************************)
(*									*)
(*				typ_f_id				*)
(*									*)
(*	Output file id to user from "elf_file"				*)
(*									*)
(************************************************************************)

procedure typ_f_id (file_id : file_id_string);

var
  i : integer;

begin
  term.write_message_line (FILE_ID_M, tt_ans);
  form.start;
  form.move_from_elf_chs (FILE_ID_SZ, file_id, 1);
  form.write_line (term, tt_ans)
end (* typ_f_id *) ;



(***************************   control   ********************************)
(*									*)
(*			  type_node_start				*)
(*									*)
(************************************************************************)

procedure type_node_start (header : univ node_file_header_record);

begin
  term.write_message_string (STRT_ADR_M, tt_ans);
  if header.node_load_start = -1
  then term.write_message_string ('UNDEF   \ ', tt_ans)
  else
    begin
      form.start;
      form.format_number (header.node_load_start, HEX, MX_HX_DGTS);
      form.write_string (term, tt_ans)
    end;
  if header.image_format[1] = ZERO
  then
    begin
      form.number_message (
	'      DATA BYTE COUNT: \', header.node_load_count, HEX);
      form.write_line (term, tt_ans)
    end
  else term.write_newline (tt_ans)
end (* type_node_start *) ;



(***************************   control   ********************************)
(*									*)
(*			  type_dump_start				*)
(*									*)
(************************************************************************)

procedure type_dump_start (header : univ node_dump_file_header_record);

begin
  form.number_message ('FIRST DATA ADDRESS:\', header.dump_start, HEX);
  form.write_line (term, tt_ans)
end (* type_dump_start *) ;



(***************************   control   ********************************)
(*									*)
(*				type_segs				*)
(*									*)
(************************************************************************)

procedure type_segs (header : univ slot_dump_file_header_record);

begin
  form.simple_message ('SEGMENTS STORED: \');
  for this_seg := 0 to MAX_SEG do
    if header.segments_dumped[this_seg] = '1'
    then
      begin
	form.skip (1);
	form.number (this_seg, DECIMAL)
      end (* for *) ;
  form.write_line (term, tt_ans);
end (* type_segs *) ;



(***************   control   (output routines)***************************)
(*									*)
(*				nib_date_exists				*)
(*									*)
(************************************************************************)

function NIB_DATE_EXISTS(
      file_vers	: integer) : boolean ;

begin (* return TRUE if later than version 2 and proper type *)
  nib_date_exists := (file_vers >= 3) and
    ((elf_f_type = ND_LD_FILE) or (elf_f_type = SL_LD_FILE) or
     (elf_f_type = PT_LD_FILE))
end (* nib_date_exists *) ;



(***************   control   (output routines)***************************)
(*									*)
(*				type_header				*)
(*									*)
(*	This routine outputs header info to the user.			*)
(*									*)
(************************************************************************)

procedure type_header (
      output_file_addr	: boolean;
      header		: univ file_header_record);

begin
  if file_ans = COMPLETE
  then
    begin
      term.write_newline (tt_ans);
      "if disk, output file address and file location and size"
      if output_file_addr
      then type_file_address (device_in, input_disk_page);
      type_disk_address (
	device_in,
        disk_mon[device_in.unit].disk_start + header.start_data_sector,
	header.end_sector - header.start_data_sector + 1);
      "output file type"
      elf_f_type := file_type (ord(header.file_type));
      type_f_t;
      if elf_f_type < INTERNAL_FILE
      then
        begin
	  "output version and revision number"
	  term.write_message_string ('    \ ', tt_ans);
	  type_vers (left_half (header.ver_rev), right_half (header.ver_rev));
	  "output nib creation date and time if later than version 2"
	  if nib_date_exists (left_half (header.ver_rev))
	  then
	    begin
	      type_date('NIB FILE CREATED: \ ', header.nib_crea_date_and_time);
	      term.write_message_line (SPACES_M, tt_ans)
	    end;
	  "output elf creation date and time"
	  type_date('ELF FILE CREATED: \ ', header.creation_date_and_time);
	  term.write_message_string (SPACES_M, tt_ans);
	  "output object file name if there was one"
	  if elf_f_type <= PT_LD_FILE
	  then type_object_file_name(OBJ_FILE_M, header, DO_CR)
	  else term.write_newline (tt_ans);
	  "output format of file"
	  if header.image_format[1] = ZERO
	  then term.write_message_line ('IMAGE FORMAT\ ', tt_ans);
	 "print segments stored if dump slot or dump partial"
	 if (elf_f_type = SL_DP_FILE) or (elf_f_type = PT_DP_FILE)
	 then type_segs(header);
	 "print start address for node load and dump file"
	  if (elf_f_type = ND_LD_FILE) or (elf_f_type = ND_DP_FILE)
	  then type_node_start (header);
	  "output start of data address if dump node data"
	  if elf_f_type = ND_DP_FILE
	  then type_dump_start (header);
	  typ_f_id (header.file_id)	  "output file id"
	end
      else term.write_newline (tt_ans)
    end
end (* type_header *) ;
!
      (*   CNTRL5.ELF Updated 17-Sep-86 at 12:38 by Raffo   *)

(************************************************************************)
(*									*)
(*	Device Routines							*)
(*									*)
(************************************************************************)


(****************************   control   (device routines)**************)
(*									*)
(*			set_up_device_name				*)
(*									*)
(*	Set up "dev.kind" and "dev.unit".				*)
(*									*)
(************************************************************************)

procedure set_up_device_name (
  var dev		: dev_rec;
      kind_of_dev	: char;
      dev_unit_num	: integer;
  var got_the_dev	: boolean);

begin
  dev.kind  := ILLEGAL_DEVICE;
  dev.unit  := dev_unit_num;
  dev.state := DEVICE_UNUSED;

  if dev_unit_num >= 0
  then
    begin
      if kind_of_dev = ASCD
      then
       if dev_unit_num <= DISK_UNIT_LIMIT
       then dev.kind := DISK;

      if kind_of_dev = ASCM
      then
	if dev_unit_num <= TAPE_UNIT_LIMIT
	then dev.kind := TAPE
    end;

  got_the_dev := dev.kind <> ILLEGAL_DEVICE
end (* set_up_device_name *) ;
!
      (*   CNTRL5.ELF   *)

(****************************   control   *******************************)
(*									*)
(*				legal_file				*)
(*									*)
(*	This boolean function returns 'true' if the file type is	*)
(*	legal for the current command and sub command.			*)
(*									*)
(************************************************************************)

function legal_file : boolean;

begin
  if (elf_f_type = ERROR_FILE) or (elf_f_type = F_FILE)
  then legal_file := FALSE
  else
    legal_file :=
      (this_cmd.prg_name = CDELETE) or
      (this_cmd.prg_name = CRENAME) or
      (this_cmd.prg_name = CCOPY) or
      ((this_sub.sub_prg = SNODE) and (elf_f_type = ND_LD_FILE)) or
      ((this_sub.sub_prg = SNODE) and (elf_f_type = ND_DP_FILE)) or
      ((this_sub.sub_prg = SSLOT) and (elf_f_type = SL_LD_FILE)) or
      ((this_sub.sub_prg = SSLOT) and (elf_f_type = SL_DP_FILE)) or
      ((this_sub.sub_prg = SPART) and (elf_f_type = PT_LD_FILE)) or
      ((this_sub.sub_prg = SPART) and (elf_f_type = PT_DP_FILE))
end (* legal_file *) ;

!
      (*   CNTRL5.ELF   *)

(***************************   control   (device routines)***************)
(*									*)
(*			verify_file_header				*)
(*									*)
(*	Checks file block in dev.elf_chars. Checks that file type is	*)
(*	legal and that file block is a file header.			*)
(*									*)
(************************************************************************)

procedure verify_file_header (header : univ file_header_record) ;

begin
  if file_ans = COMPLETE
  then
    begin
      elf_f_type := file_type(ord(header.file_type));
      if legal_file
      then
	begin
	  term.write_newline (tt_ans);
	  image_form := header.image_format[1] <> ONES;
	  if (header.sync_1 = SYNC) and
	     (header.sync_2 = SYNC) and
	     (header.sync_3 = SYNC)
	  then
	    begin
	      found := TRUE;
	      type_object_file_name(OBJ_FILE_M, header, DO_CR);
	      typ_f_id(header.file_id)
	    end
	  else type_f_t
	end
      else
	term.write_message_line (
	  'ILLEGAL FILE OR FILE TYPE FOR COMMAND\', tt_ans)
    end
end (* verify_file_header *) ;

!
      (*   CNTRL5.ELF   *)

(***************************   control   (device routines)***************) 
(*									*)
(*			     check_header				*)
(*									*)
(*	Check if file should be opened by command type.			*)
(*	Only open internal files in the directory command if switch	*)
(*	set. Only open partially copied files in delete, directory,	*)
(*	locate and rename commands. With rename and locate, only	*)
(*	open if the header has been copied.				*)
(*									*)
(************************************************************************)

function check_header (header : univ file_header_record) : boolean;

var
  ok : boolean;

begin
  ok := ord(header.file_type) <> INTERNAL_FILE;

  if ok
  then
    if header.data_guage > 0
    then
      if (this_cmd.prg_name = CCOPY) or (this_cmd.prg_name = CLOAD)
      then ok := FALSE
      else if (this_cmd.prg_name = CLOCATE) or (this_cmd.prg_name = CRENAME)
      then ok := ord(header.file_type) <> EMPTY_FILE;

  check_header := ok
end (* check_header *);

(***************************   control   (device routines)***************)
(*									*)
(*			   	check_fault				*)
(*									*)
(************************************************************************)

procedure check_fault (
  var dev	: dev_rec);

var
  fault : header_data_result;

begin
  dev.disk_operator.header_data_fault(fault);
  if fault <> HEADER_OKAY
  then term.write_message_line('Disk files cannot be read.\ ', tt_ans);
  case fault of
    HEADER_OKAY: (* empty - ok *);
    HEADER_SYNC: term.write_message_line('Header data has invalid sync.\',
			tt_ans);
    HEADER_GUAGE: term.write_message_line('Header data guage invalid size.\',
			tt_ans);
    HEADER_TIME: term.write_message_line(
      'Header data time is greater than supervisor time.\', tt_ans);
    HEADER_START: term.write_message_line(
      'Header data start sector has decreased\ ', tt_ans)
  end (* case *)
end (* check_fault *);

!
      (*   CNTRL5.ELF   *)

(***************************   control   (device routines)***************)
(*									*)
(*			   open_single_file				*)
(*									*)
(*	Open disk file at specified address. Return file_ans		*)
(*	with status of open. If file not found, display message at	*)
(*	terminal.							*)
(*									*)
(************************************************************************)

procedure open_single_file (
      option	: open_option;
      address	: integer;
  var dev	: dev_rec);

begin
  file_ans := COMPLETE;
  found    := FALSE;
  case option of
    OPEN_READ_DO_NOT_CONFIRM,
    OPEN_READ_CONFIRM:
      dev.disk_operator.open_user_read (address);
    OPEN_WRITE_DO_NOT_CONFIRM,
    OPEN_WRITE_CONFIRM:
      dev.disk_operator.open_user_write (address)
  end (* case *) ;
  check_fault(dev);
  case dev.disk_operator.status of
    F_O_DISK_FAILURE:
      file_ans := BAD_DISK;
    F_O_FILE_HEADER_ERROR:
      file_ans := DISK_FILE_HEADER_ERROR;
    CONDENSING:
      file_ans := DISK_CONDENSING;
    FILE_IN_USE :  begin
      file_ans := UNAVAILABLE ;
      term.write_message_line ('File in use.  Try again later.\ ', tt_ans)
      end ;
    FILE_NOT_FOUND,
    FILE_BEING_DELETED:
      (* empty *) ;
    FILE_OPENED_OKAY:
      begin
	dev.state := OLD_FILE_OPENED;
	input_disk_page := dev.disk_operator.start_address;
	rd_device(dev, input_disk_page, dev.elf_data, file_ans);
	found := check_header (dev.elf_data.chars.file_data)
      end
  end (* case *) ;

  if (dev.state = DEVICE_UNUSED) and dev.disk_operator.opened
  then dev.disk_operator.close;

  if not found and (file_ans = COMPLETE)
  then term.write_message_line ('No file at that address\', tt_ans)
end (* open_single_file *);

!
      (*   CNTRL5.ELF   *)

(***************************   control   (device routines)***************)
(*									*)
(*				confirm_fl				*)
(*									*)
(*	Read file header from tape into "dev.elf_data" and ask user	*)
(*	if it is the wanted.  Result in 'found'.			*)
(*									*)
(************************************************************************)

procedure confirm_fl (
      option	: open_option;
  var dev	: dev_rec);

begin
  found := FALSE;
  repeat
    case dev.kind of
      DISK:
	begin
	  input_number(F_ADDR_M, FALSE, DECIMAL, input_disk_page);
	  if tt_ans = COMPLETE
	  then
	    begin
	      open_single_file (option, input_disk_page, dev);
	      if found
	      then verify_file_header (dev.elf_data.chars.file_data)
	    end
	end (* DISK *) ;

      TAPE:
	begin
	  rd_device(dev, 0, dev.elf_data, file_ans);
	  if file_ans = COMPLETE
	  then verify_file_header (dev.elf_data.chars.file_data);
	  if not found and (tt_ans = COMPLETE) and (file_ans = COMPLETE)
	  then
	    begin
	      term.write_message_line ('SKIPPING TO NEXT FILE\', tt_ans);
	      pos_device(dev, TAPE_FORWARD_FILE, file_ans)
	    end
	end (* TAPE *)
    end (* case *)
  until found or (file_ans <> COMPLETE) or (tt_ans <> COMPLETE) or
	(elf_f_type = F_FILE) or (elf_f_type = ERROR_FILE);
 
  if found
  then found := ask('(:13:)(:10:)OKAY\ ')
end (* confirm_fl *);

!
      (*   CNTRL5.ELF   *)

(********************   control   (device routines)**********************)
(*									*)
(*				get_unit				*)
(*									*)
(*	This routine inputs a device unit from the user, and possibly	*)
(*	gets confirmation that we found the correct one.		*)
(*	Device is saved in "dev.unit".					*)
(*									*)
(************************************************************************)

procedure get_unit(
      msg	: term_chs;
      option	: open_option;
  var dev	: dev_rec);

begin
  found := false;
  repeat
    term.write_message_string (msg, tt_ans);
    term.write_message_string ('DEVICE UNIT ID: \ ', tt_ans);
    term.read_line(term_line, tt_ans);
    if tt_ans = COMPLETE
    then
      begin
	set_up_device_name(
	  dev, term_line.chars[1], ord(term_line.chars[2])-ord(ASC0), found);
	if found (* set up kind, unit and set found to FALSE if illegal *)
	then
	  begin
	    attach_dev(dev, file_ans);
	    if file_ans = COMPLETE
	    then
	      case option of
		DO_NOT_OPEN:
		  (* empty *) ;
		OPEN_READ_DO_NOT_CONFIRM,
		OPEN_WRITE_DO_NOT_CONFIRM:
		  case dev.kind of
		    DISK: open_single_file (option, input_disk_page, dev);
		    TAPE: found := TRUE
		  end (* case *) ;
		OPEN_READ_CONFIRM,
		OPEN_WRITE_CONFIRM:
		  begin
		    confirm_fl (option, dev);
		    if not found
		    then detach_dev(dev)
		  end
	      end (* case *)
	  end
	else term.write_message_line (ILL_DEV_M, tt_ans);
      end
  until found or not all_ok
end (* get_unit *) ;

!
      (*   CNTRL5.ELF   *)

(********************   control   (device routines)**********************)
(*									*)
(*				get_disk				*)
(*									*)
(*	This routine inputs a device and makes sure it is a disk.	*)
(*									*)
(************************************************************************)



procedure get_disk(
      option	: open_option;
  var dev	: dev_rec);

begin
  get_unit(NULL_M, option, dev);
  if all_ok
  then
    if dev.kind <> DISK
    then file_ans := ILLEGAL_DEV
end (* get_disk *);



(********************   control   (device routines)**********************)
(*									*)
(*				get_tape				*)
(*									*)
(*	This routine inputs a device and makes sure it is a tape.	*)
(*									*)
(************************************************************************)

procedure get_tape(
      option	: open_option;
  var dev	: dev_rec);

begin
  get_unit(NULL_M, option, dev);
  if all_ok
  then
    if dev.kind <> TAPE
    then file_ans := ILLEGAL_DEV
end (* get_tape *);
!
      (*   CNTRL6.ELF Updated 30-Sep-86 at 13:24 by Raffo    *)

(************************************************************************)
(*									*)
(*	Input Routines							*)
(*									*)
(************************************************************************)



(****************************   control   (input routines)***************)
(*									*)
(*				input_file_id				*)
(*									*)
(*	Input file id into "term_line".					*)
(*									*)
(************************************************************************)

procedure input_file_id;

begin
  if all_ok
  then
    begin
      term.write_message_line (FILE_ID_M, tt_ans);
      term.read_line (term_line, tt_ans);
      if term_line.length > FILE_ID_SZ
      then term_line.length := FILE_ID_SZ
    end
end (* input_file_id *);



(****************************   control   (input routines)***************)
(*									*)
(*				elf_fmt_in				*)
(*									*)
(*	This routine asks the user about the file being in image	*)
(*	format.  It sets "image_form" appropriately.	 		*)
(*									*)
(************************************************************************)

procedure elf_fmt_in;

begin
  if all_ok
  then
    if this_sub.sub_prg = snode	 "only ask if cmd is create node"
    then image_form :=
      ask('SHOULD FILE BE WRITTEN IN IMAGE FORMAT\ ')
    else image_form := false	"otherwise, force compression"
end (* elf_fmt_in *);



(****************************   control   *******************************)
(*									*)
(*				ck_x75					*)
(*									*)
(*	If this is an X75 gateway login, be sure the login string,	*)
(*	including username, colon and host does not exceed 12 chars.	*)
(*									*)
(************************************************************************)

procedure ck_x75(userlen : integer;
		hostf : boolean;
		hostno : integer;
		var flag : boolean);

var
  temp : integer;

begin
  temp := userlen;
  if hostf
  then
    begin
      temp := temp + 2; "count colon and 1 digit host number"
      if hostno > 9 then temp := temp + 1;
      if hostno > 99 then temp := temp + 1
    end;
  if temp > 12
  then	 "dnic login string may not be greater than 12 chars"
    begin
      term.write_message_line (
	'FOR X.25/X.75 GATEWAYS, LOGIN STRINGS MAY NOT EXCEED 12 CHARACTERS,\',
        tt_ans);
      term.write_message_string (REENTR_MSG, tt_ans);
      flag := FALSE
    end
end (* ck_x75 *);




(********************   control   (input routines)***********************)
(*									*)
(*			   get_user_host				*)
(*									*)
(*	This routine inputs a username and host number			*)
(*	from the terminal.						*)
(*									*)
(************************************************************************)

procedure get_user_host(prompt : term_chs;
		var ls_user : username;
		var ls_userlen : integer;
		var ls_hostf : boolean;
		var ls_host : integer);

begin
  found := FALSE;
  ls_host := 0;
  ls_userlen := 0;
  ls_hostf := FALSE;
  term.write_message_string (prompt, tt_ans);
  repeat
    term.read_line(term_line, tt_ans);
    if tt_ans = COMPLETE
    then
      begin
        ptr := 1;
        cmn.input_user(term_line, ptr, ls_user, ls_userlen);
        if ls_userlen > 0
        then
	  if term_line.chars[ptr] = COLON
	  then
	    begin
	      ptr := ptr + 1;		"skip over colon"
	      cmn.input_num(DECIMAL, term_line, ptr, ls_host, found);
	      if found then ls_hostf := TRUE
	    end
	      else
	       if ptr >= term_line.length then found := true;
	if not found then tell_fmt('USER:HOST\', tt_ans)
      end;
    "if x75 gateway, be sure login string is not too long"
    if found and aux.info.g_x75
    then ck_x75(ls_userlen, ls_hostf, ls_host, found)
  until found or (tt_ans <> COMPLETE)
end (* get_user_host *);



(********************   control   (input routines)***********************)
(*									*)
(*			get_krnl_on_node				*)
(*									*)
(*	This routine inputs a kernel number for a specified node.	*)
(*									*)
(************************************************************************)

procedure get_krnl_on_node;

begin
  with aux.info do
    begin
      if all_ok and not tymneti
      then
	begin
	  form.number_message (
	    'KERNEL HOST ON NODE \ ', neighbor, DECIMAL);
	  form.write_string (term, tt_ans);
	  input_number(prompt_m, FALSE, decimal, krnl_host)
	end
    end
end (* get_krnl_on_node *);



(********************   control   (input routines)***********************)
(*									*)
(*				neighbr_in				*)
(*									*)
(*	This routine inputs a neighbor number and sets the TYMNET-I	*)
(*	flag.								*)
(*									*)
(************************************************************************)

procedure neighbr_in;

begin
  if all_ok
  then
    repeat
      input_number('NEIGHBOR NODE: \', FALSE, DECIMAL, aux.info.neighbor);
      aux.info.tymneti := aux.info.neighbor <= 2000
    until (aux.info.neighbor <> 0) or (tt_ans <> COMPLETE)
end (* neighbr_in *);



(********************   control   (input routines)***********************)
(*									*)
(*				line_in					*)
(*									*)
(*	This routine inputs a line number for a node.			*)
(*									*)
(************************************************************************)

procedure line_in;

begin
  if all_ok
  then
    with aux.info do
      begin
	form.number_message ('LINE NUMBER ON NODE \ ', neighbor, DECIMAL);
	form.write_string (term, tt_ans);
	input_number(prompt_m, FALSE, DECIMAL, line_number)
      end
end (* line_in *);



(********************   control   (input routines)***********************)
(*									*)
(*				shaman_in				*)
(*									*)
(*	This routine inputs a shaman host number.			*)
(*									*)
(************************************************************************)

procedure shaman_in;

begin
  if all_ok
  then
    input_number('SHAMAN HOST NUMBER: \ ', FALSE, DECIMAL, aux.info.krnl_host)
end (* shaman_in *);



(********************   control   (input routines)***********************)
(*									*)
(*				mxp_machine_in				*)
(*									*)
(*	This routine inputs a MXP machine number.			*) 
(*									*)
(************************************************************************)

procedure mxp_machine_in;

begin
  if all_ok
  then
    input_number('MXP MACHINE NUMBER: \ ', FALSE, HEX, aux.info.mxp_machine)
end (* mxp_machine_in *);



(********************   control   (input routines)***********************)
(*									*)
(*				target_node_in				*)
(*									*)
(*	This routine inputs a target node number.			*)
(*									*)
(************************************************************************)

procedure target_node_in;

begin
  if all_ok
  then
    input_number('TARGET NODE: \', FALSE, OCTAL, aux.info.target_node)
end (* target_node_in *);



(********************   control   (input routines)***********************)
(*									*)
(*				input_password				*)
(*									*)
(*	This routine inputs a non-echoed password.			*)
(*									*)
(************************************************************************)

procedure INPUT_PASSWORD(
      prompt : term_chs;
  var password : line_rec);

begin
  if all_ok
  then
    begin
      password.length := 0;
      term.set_echo(echo_off);
      term.write_message_line (prompt, tt_ans);
      term.read_line(password, tt_ans);
      term.set_echo(echo_on)
    end
end (* input_password *);



(*********************  control  (CMF routine)***************************)
(*									*)
(*			      put_pass					*)
(*									*)
(*        This routine fills 'aux.password' with 'term_chs'		*)
(*	  It is used when automatic login to CMF-HOST.			*)
(*									*)
(************************************************************************)

procedure  put_pass(pass :term_chs);

begin
  n := 1;
  while pass[n] <> END_M_CH do
    begin
      aux.password.chars[n] := pass[n];
      n := n + 1
    end (* while *) ;
  aux.password.length := n - 1
end (* put_pass *) ;



(********************   control   (CMF ROUTINE ) ***********************)
(*									*)
(*			  remove_ending_spaces				*)
(*									*)
(*		This routine copies the 'inline' to the 'outline',	*)
(*        	   stopping as soon as a 'space' is reached.		*)
(*		Notice that if there is no spaces in 'inline',		*)
(*		it is a mere copy of 'inline' to 'outline'.		*)		(*									*)
(************************************************************************)

procedure remove_ending_spaces (
      inline	: term_chs;
      insize	: term_sz;
  var outline	: line_rec);

var
  n : integer;
  temp_char : char;

begin
  outline.chars := inline;
  n := 1;
  repeat
    temp_char := inline[n];
    n := (n + 1)
  until (temp_char = SPACE) or (n > insize);
  if temp_char = SPACE
  then outline.length := (n - 2)
  else outline.length := (n - 1)
end (* remove_ending_spaces *) ;



(********************   control   (input routines)***********************)
(*									*)
(*			login_to_ob_system				*)
(*									*)
(*	This routine inputs a login string for the TYMCOM-X into "ins"	*)
(*									*)
(************************************************************************)

procedure login_to_ob_system;

begin
  if all_ok
  then
    with aux, info do
      begin
	neighbor := 0;	"clear in case a previous login"
	krnl_host := 0;
	if not cmf_host
	then
	  begin
	    get_user_host (
	      'TYMCOM-X USERNAME ( :HOST ): \', user, userlen, hostf, host);
            password.length := 0;
	    if g_userlen <> 0
	    then
	      if info = last_aux.info
	      then password := last_aux.password
	      else input_password('PASSWORD: \ ', password)
	  end
	else
	  begin
	    get_user_host (
	      'CMF HOST USERNAME ( :HOST ): \', user, userlen, hostf, host);
	    if (netport_host <> 0) and not hostf
	    then
	      begin
		hostf := true;
		host := netport_host
	      end;
	    input_password('PASSWORD: \ ', password)
	  end;
	get_cir
      end
end (* login_to_ob_system *);



(********************   control   (CMF ROUTINE)    **********************)
(*									*)
(*                       try_enter_cmf                     		*)
(*									*)
(*	This routine sends file's username and password to netport,	*)
(*                get the answer and sets 'log_in_cmf'			*)
(*									*)
(************************************************************************)

procedure try_enter_cmf( var log_in_cmf : boolean;
			 var got_unix_common : boolean);

var
  n : integer;
  netport_ans : char;
  common_cmf : boolean;

begin
  "send login info "
  with cirio, cmf_aux do
    begin 
      n := 0;
      while n < MX_UN_SZ do
        begin
          n := n + 1;
	  if cmf_user[n] <> SPACE then snd_cir_ch(cmf_user[n])
	end;
      snd_cir_ch('(:10:)');
      wr_line_rec(cmf_password,NO_CR,aux_ans);
      snd_cir_ch('(:10:)')
    end;
  "get answer from netport"
  get_answer(netport_ans);
  if netport_ans = COMMON_INQUIRE
  then
    begin
      if not got_unix_common
      then
        begin
          term.write_message_line(
	    'USER COMMON IS CMF AND UNIX, SELECT CMF OR UNIX\', tt_ans);
          common_cmf := ask('RESPOND YES TO SELECT CMF, NO FOR UNIX\ ')
        end;
      if got_unix_common "reset if coming in again"
      then got_unix_common := FALSE
      else
        got_unix_common := not common_cmf;"not common_cmf reprompt password"
      if common_cmf
      then snd_cir_ch(TWO) "select cmf common directory"
      else snd_cir_ch(ONE); "select unix user common"
      get_answer(netport_ans)
    end;
  "set log_in_cmf"
  if all_ok then log_in_cmf := (netport_ans = ONE)
end (* try_enter_cmf *) ;



(********************   control   (CMF ROUTINE )  ***********************)
(* 									*)
(*                          enter_cmf                                   *)
(* 									*)
(*      This routine gets user's unix login info , logs in unix         *)
(*        and sets "log_in_cmf" to true if login successful             *)
(*                                                                      *)
(************************************************************************)   

procedure enter_cmf;

var
  i : integer;      "controls how many times you try to 'log in'"
  k : integer;
  log_in_cmf : boolean;"tells if 'login'successful"
  got_user   : boolean;"re-prompt password only if true"
  netport_ans : char;

begin
  if all_ok and not old_circuit
  then
    begin
      "send UNIX capability code"
      snd_cir_ch(UNIX_CAPABLE);
      get_answer(netport_ans)
    end
  else
    if all_ok
    then netport_ans := UNIX_CAPABLE;
  log_in_cmf := false;
  i := 0;
  if all_ok and (netport_ans = UNIX_CAPABLE)
  then
    begin 
      repeat
        i := i+1;
        got_user := FALSE;
        "clear username"
        for k := 1 to MX_UN_SZ do cmf_aux.cmf_user[k] := zero; 
        "get user name and password and send it to netport"
	gotit := got_user;  "no username yet"
        with cmn,term,cmf_aux,token do
	  begin
	    if not got_user
	    then
	      repeat
	        write_message_string ('CMF USERNAME: \ ',tt_ans);
	        read_line(term_line,tt_ans);
	        if tt_ans = COMPLETE
	        then
	          begin
	            ptr := 1;
	            "extract the first 'word' from term.line"
	            token_in(term_line,ptr,token);
	            if length > 0 then gotit := true
                  end
	      until gotit or (tt_ans <> COMPLETE);
	    if gotit and (tt_ans = COMPLETE)
	    then
	      begin
	        "put the 'word' in cmf_aux.user"
	        k := 1;
	        while (k <= length) and (k <= MX_UN_SZ) do
	          begin
  		    cmf_user[k] := chars[k];
		    k := k + 1
                  end  (* end while *); 
	        "get password"
		if got_user
	        then input_password('UNIX COMMON PASSWORD: \ ',cmf_password)
	        else input_password('PASSWORD: \ ',cmf_password);
	        "send the whole stuff to netport....."
	        try_enter_cmf(log_in_cmf, got_user);
	        if all_ok and not log_in_cmf
	        then term.write_message_line ('ERROR\',tt_ans)
	     end (* end if gotit and tt_ans = COMPLETE *)
        end (* end with *)
      until not all_ok or log_in_cmf or (i = 3);
      if (i = 3) and not log_in_cmf
      then "tell netport to exit"
        begin
          term.write_message_line ('NETPORT EXITS\',tt_ans);
          snd_cir_ch(EXIT_SLAVE);
          zap_aux_circuit
        end
    end (* all_ok and netport_ans = UNIX_CAPABLE *)
  else
    begin
      if (aux_ans = TIMED_OUT) or (netport_ans <> UNIX_CAPABLE)
      then term.write_message_line('NETPORT EXITS - NOT UNIX FILES COMPATIBLE\',
	tt_ans);
      snd_cir_ch(EXIT_SLAVE);
      zap_aux_circuit
    end;
end (* enter_cmf *) ;



(********************   control   (input routines)***********************)
(*									*)
(*			login_to_dl_system				*)
(*									*)
(*	This routine inputs all information about the downline	 	*)
(*	circuit.							*)
(*									*)
(************************************************************************)

procedure login_to_dl_system;

begin
  aux.info.userlen := 0;
  if aux.info.mxp_load
  then
    begin
      shaman_in;
      mxp_machine_in
    end
  else
    begin
      neighbr_in;
      get_krnl_on_node;
      line_in;
      if aux.info.tymstar_load
      then target_node_in
    end;
  get_cir
end (* login_to_dl_system *);



(********************   control   (input routines)***********************)
(*									*)
(*			input_dump_addrs				*)
(*									*)
(*	This routine inputs start and end address for node dump and	*)
(*	builds a circuit to the node.					*)
(*									*)
(************************************************************************)

procedure input_dump_addrs;

begin
  with term, cir_ans do
    begin
      input_number(st_up_msg, FALSE, hex, strt_add);
      if strt_add <> -1
      then int_to_chs(chars.file_data, strt_add, hd_st_adr_x)
      else sv_same_ch(chars.file_data, hd_st_adr_x, ones, byts_in_wd);
      login_to_dl_system;
      found := false;
      if all_ok then
	repeat
	  input_number(strt_adr_m, FALSE, hex, strt_add);
	  input_number('END ADDRESS: \', FALSE, hex, end_add);
	  byte_count := end_add - strt_add + 1;
	  int_to_chs(chars.file_data, byte_count, hd_byte_ct_x);
	  int_to_chs(chars.file_data, strt_add, hd_d_add_x);
	  if byte_count > 0
	  then found := TRUE
	  else
	    term.write_message_line (
	      'END ADDRESS MUST BE GREATER THAN START ADDRESS,\', tt_ans)
	until found or (tt_ans <> COMPLETE);
      exp_b_ct := byte_count
    end (* with *)
end (* input_dump_addrs *);



(********************   control   (input routines)***********************)
(*									*)
(*				login_to_slot				*)
(*									*)
(*	This routine inputs all circuit info for a slot.		*)
(*									*)
(************************************************************************)

procedure login_to_slot;

begin
  with aux.info do
    begin
      userlen := 0;	"in case a previous login"
      neighbor := 0;
      input_number('SLOT: \ ', FALSE, HEX, slot);
      if tt_ans = COMPLETE
      then input_number('HOST: \ ', FALSE, decimal, krnl_host);
      if tt_ans = COMPLETE
      then get_cir
    end
end (* login_to_slot *);



(****************************   control   (input routines)***************)
(*									*)
(*				input_segs				*)
(*									*)
(*	Input set representing segments to dump, build circuit, get	*)
(*	segment lengths and compute disk size.				*)
(*									*)
(************************************************************************)

procedure input_segs;

var
  seg_found : boolean;

begin
  found := false;
  if this_sub.sub_prg = sslot (* if slot dump, dump all segs available *)
  then
    seg_set := [max_seg]	(* pick up others when sizes are known *)
  else
    if all_ok
    then
      with cmn, term do
        repeat
	  seg_set := [];	(* set segs to empty set *)
          term.write_message_string ('SEGMENTS TO DUMP: \ ', tt_ans);
          read_line(term_line, tt_ans);
          ptr := 1;
          if tt_ans = complete
          then
            repeat
              input_num(hex, term_line, ptr, this_seg, seg_found);
              if seg_found
              then
		begin
		  if (this_seg <= max_seg) and (this_seg >= 0)
		  then seg_set := seg_set or [this_seg]
		  else seg_found := false;
		  with term_line do
		    if (ptr < length) and (chars[ptr-1] <> comma)
		    then seg_found := false
		end
	    until not seg_found or (ptr > term_line.length);
	  found := seg_found
        until found or (tt_ans <> complete);
  if all_ok then login_to_slot;
  if all_ok then get_seg_sizes
end (* input_segs *);
!
"
		command dispatcher routines
"



(**************   control   (command dispatcher routines)****************)
(*									*)
(*				list_sub				*)
(*									*)
(*	This routine lists all sub definition words in a command	*)
(*	for the user.							*)
(*									*)
(************************************************************************)

procedure list_sub(cmdrec : cmddef_rec);

var
  temp : integer;

begin
  if cmdrec.num_sub > 0
  then
    begin
      for temp := 1 to cmdrec.num_sub do
	begin
	  form.start;
	  for n := 1 to MX_SUB_SZ do
	    begin
	      temp_ch := cmdrec.sub_defs[temp].sub_word[n];
	      if temp_ch <> SPACE
	      then form.character (temp_ch)
	    end (* for *) ;
	  form.write_string (term, tt_ans);
	  if temp = cmdrec.num_sub - 1
	  then term.write_message_string (' OR \ ', tt_ans)
	  else if temp < cmdrec.num_sub - 1
	  then term.write_message_string (', \ ', tt_ans)
	end (* for *) ;
      term.write_message_string (PROMPT_M, tt_ans)
    end
end (* list_sub *);



(**************   control   (command dispatcher routines)****************)
(*									*)
(*				getsub					*)
(*									*)
(*	This routine inputs a token from the input line and finds	*)
(*	the sub word specified in the sub table for the command		*)
(*	already input.							*)
(*									*)
(************************************************************************)

procedure getsub(cmdrec : cmddef_rec;
		var inline : line_rec;
		var inptr : term_sz;
		var subfound : boolean;
		var subrec : subdef_rec);

begin
  subfound := FALSE;
  cmn.skp_to_tok (inline, inptr, found);
  tt_ans := COMPLETE;
  if not found
  then
    begin
      list_sub(cmdrec);
      inptr := 1;
      term.read_line (inline, tt_ans)
    end;
  if tt_ans = COMPLETE
  then
    begin
      cmn.token_in(inline, inptr, token);
      if token.length > 0
      then cmdmon.findsub(token, cmdrec, subfound, subrec)
    end
end (* getsub *) ;



(**************   control   (command dispatcher routines)****************)
(*									*)
(*				getcmd					*)
(*									*)
(*	This routine inputs a command from the user and finds		*)
(*	the command and possible sub command specified in the		*)
(*	command table.							*)
(*									*)
(************************************************************************)

procedure getcmd (
  var cmdfound	: boolean;
  var cmdrec	: cmddef_rec;
  var subrec	: subdef_rec);

begin
  cmdfound := FALSE;
  tt_ans := COMPLETE;
  term.read_line (term_line, tt_ans);
  if (tt_ans = COMPLETE) and (term_line.length > 0)
  then
    begin
      ptr := 1;
      cmn.token_in (term_line, ptr, token);
      if token.length > 0
      then
	begin
	  cmdmon.findcmd (token, cmdfound, cmdrec);
	  if cmdfound and (cmdrec.num_sub > 0)
	  then getsub(cmdrec, term_line, ptr, cmdfound, subrec)
	  else subrec.sub_prg := S_NO_SUB
	end;
      if not cmdfound then term.write_message_line (QUESTION_M, tt_ans)
    end
end (* getcmd *) ;



(**************   control   (command dispatcher routines)****************)
(*									*)
(*			  set_mxp_or_tymstar				*)
(*									*)
(*	This routine changes the subcommand from SMXP or STYMSTAR to	*)
(*	SNODE while saving whether a TYMSTAR or MXP command is being	*)
(*	executed in aux.info.						*)
(*									*)
(************************************************************************)

procedure set_mxp_or_tymstar;

begin
  case this_sub.sub_prg of
    SMXP:	aux.info.mxp_load     := TRUE;
    STYMSTAR:	aux.info.tymstar_load := TRUE
  end (* case *) ;
  this_sub.sub_prg := SNODE
end (* set_mxp_or_tymstar *) ;



(**************   control   (command dispatcher routines)****************)
(*									*)
(*			 check_mxp_or_tymstar				*)
(*									*)
(*	This function determines whether an MXP or TYMSTAR load is to	*)
(*	occur. It check whether the command argument was MXP, TYMSTAR,	*)
(*	or NODE. If NODE, it allows for a second argument which must	*)
(*	either MXP or TYMSTAR.						*)
(*									*)
(************************************************************************)

function check_mxp_or_tymstar: boolean;

begin
  aux.info.mxp_load     := FALSE;
  aux.info.tymstar_load := FALSE;
  found := TRUE;
  case this_sub.sub_prg of
    SMXP,
    STYMSTAR: 
      set_mxp_or_tymstar;
    SSLOT,
    SPART: (* nothing to do *) ;
    SNODE:
      begin
	cmn.token_in (term_line, ptr, token);
	if token.length > 0
	then
	  begin
	    cmdmon.findsub (token, this_cmd, found, this_sub);
	    if found
	    then
	      found :=
		(this_sub.sub_prg = SMXP) or (this_sub.sub_prg = STYMSTAR);
	    if found
	    then set_mxp_or_tymstar
	  end
      end (* SNODE *)
  end (* case *) ;
  if not found
  then term.write_message_line ('Unrecognized command parameter\ ', tt_ans);
  check_mxp_or_tymstar := found
end (* check_mxp_or_tymstar *) ;
!
(************************************************************************)
(*									*)
(*   CNTRL7.ELF Updated 22-Sep-86 at 15:19 by Raffo			*)
(*									*)
(*	Routines common to more than one command.			*)
(*									*)
(************************************************************************)



(**********************   control   *************************************)
(*									*)
(*		    open_next_file_in_directory				*)
(*									*)
(*	Either open the first file in the directory, if called with	*)
(*	zero, otherwise open the next file. In either case, increment	*)
(*	the calling parameter if the file is open. If no more files,	*)
(*	return file_ans set to END_FILE.				*)
(*									*)
(************************************************************************)

procedure open_next_file_in_directory (var files_opened : integer);

var
  found : boolean;

begin
  repeat
    if files_opened < 0
    then
      begin
	files_opened := 0;
	device_in.disk_operator.open_read_first_file
      end
    else device_in.disk_operator.open_read_next_file;

    while device_in.disk_operator.status = FILE_BEING_DELETED do
      device_in.disk_operator.open_read_next_file;

    if device_in.disk_operator.opened
    then
      begin
	found := device_in.disk_operator.status = FILE_OPENED_OKAY;
	if found
	then
	  begin
	    input_disk_page := device_in.disk_operator.start_address;
	    rd_device (
	      device_in, input_disk_page, device_in.elf_data, file_ans);
	    found := check_header (device_in.elf_data.chars.file_data)
	  end
	else file_ans := DISK_FILE_HEADER_ERROR;
	check_fault(device_in);
	if found
	then files_opened := files_opened + 1;
	device_in.state := OLD_FILE_OPENED
      end
    else
      begin
	check_fault(device_in);
	device_in.kind := ILLEGAL_DEVICE;
	case device_in.disk_operator.status of
	  F_O_FILE_HEADER_ERROR:
	    file_ans := DISK_FILE_HEADER_ERROR;
	  F_O_DISK_FAILURE:
	    file_ans := BAD_DISK;
	  CONDENSING:
	    file_ans := DISK_CONDENSING;
	  FILE_IN_USE:
	    file_ans := UNAVAILABLE;
	  FILE_NOT_FOUND:
	    file_ans := END_FILE
	end (* case *)
      end
  until found or (file_ans <> COMPLETE)
end (* open_next_file_in_directory *) ;



(**********************   control   *************************************)
(*									*)
(*		    full_disk_directory					*)
(*									*)
(*	Do a directory for an entire unit. Called by both Directory	*)
(*	and Condense command.						*)
(*									*)
(************************************************************************)

procedure full_disk_directory;

var
  nfiles : integer;

begin
  if all_ok
  then
    begin
      nfiles := -1;	"count number of files"
      "keep track of number of blocks left free...count elf id block"
      term.write_newline (tt_ans);

      repeat
	open_next_file_in_directory (nfiles);
	if file_ans = COMPLETE
	then type_header (TRUE, device_in.elf_data.chars.file_data);
      until not all_ok;

      if file_ans = END_FILE
      then file_ans := COMPLETE;
      term.write_newline (tt_ans);
      form.number_message ('NUMBER OF FILES: \', nfiles, DECIMAL);
      form.string ('    UNUSED SECTORS:\');
      form.number (
	disk_mon[device_in.unit].disk_size
	  - disk_mon[device_in.unit].disk_space_used,
	DECIMAL);
      form.write_line (term, tt_ans)
    end
end (* full_disk_directory *) ;



(****************************   control   *******************************)
(*									*)
(*			set_up_input_device				*)
(*									*)
(*	Called by both Load and Copy commands.				*)
(*									*)
(************************************************************************)

procedure set_up_input_device (
  var device_in		: dev_rec;
  var input_end_page	: integer;
  var input_disk_page	: integer);

begin
(*	Set up max block to read from disk file *)
  input_end_page :=
    wd_to_int(device_in.elf_data.chars.file_data, HD_DSK_END_X);

(*	Save dir block to access checksums for data *)
  device_in.cksum_blk := device_in.elf_data;

(*	Set up cksum_dex to access first checksum when incremented *)
  device_in.cksum_dex := HD_CKSM_X - BYTS_IN_WD;

(*	Save page number of the checksum data *)
  device_in.cksum_page := input_disk_page;

(*	Set up address to read first data in file *)
  input_disk_page := wd_to_int(device_in.elf_data.chars.file_data, HD_DSK_ST_X)
end (* set_up_input_device *) ;



(**************   control   (command execution routines)*****************)
(*									*)
(*			found_final_file				*)
(*									*)
(*	Called by both Copy and Locate commands.			*)
(*									*)
(************************************************************************)

function found_final_file : boolean;

begin
  elf_f_type := file_type(ord(device_in.elf_data.chars.file_data[HD_TYPE_X]));
  found_final_file := elf_f_type = F_FILE
end (* found_final_file *);
!
      (*   CNTRL7.ELF   *)

(***** Condense command ****)



(**************   control   (command execution routines)*****************)
(*									*)
(*				condense				*)
(*									*)
(*	Execute the Condense command.					*)
(*									*)
(************************************************************************)

procedure condense;

var
  condense_version : integer;

begin
  get_disk(DO_NOT_OPEN, device_in);
  if all_ok
  then
    begin
      term.write_message_line (
	'THIS COMMAND WILL PHYSICALLY MOVE DATA ON THE DISK.\', tt_ans);
      if ask(continue_m)
      then
	begin
	  disk_mon[device_in.unit].request_condense (condense_version);
	  repeat
	    wait
	  until not disk_mon[device_in.unit].test_condense (condense_version)
		or check_for_stop;
	  if disk_mon[device_in.unit].test_condense (condense_version)
	  then disk_mon[device_in.unit].terminate_condense (condense_version)
	  else full_disk_directory
	end
    end
end (* condense *) ;
!
      (*   CNTRL7.ELF   *)

(***** Copy command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				copy_a_file				*)
(*									*)
(*      Store the file described by DEVICE_IN to be the file described	*)
(*	by DEVICE_OUT.  The disk unit header for an input is in		*)
(*	ELF_BLK; the disk unit header for output is in CIR_CMD.		*)
(*	DEVICE_IN.ELF_DATA contains the header record for the input	*)
(*	file.								*)
(*									*)
(************************************************************************)

procedure copy_a_file ;

var
  file_start_address,
  ncksms : integer;

begin
  case device_in.kind of
    DISK:
      begin
	file_start_address := input_disk_page;
	set_up_input_device(device_in, input_end_page, input_disk_page);
	input_start_page :=
	  wd_to_int(device_in.elf_data.chars.file_data, HD_DSK_ST_X);
	nblks := input_end_page - file_start_address + 1;
	ncksms := input_start_page - file_start_address
      end (* DISK *) ;

    TAPE:
      begin
	nblks := wd_to_int(device_in.elf_data.chars.file_data, HD_DSK_SIZE);
	ncksms := wd_to_int(device_in.elf_data.chars.file_data, HD_CKSM_SIZE)
      end (* TAPE *)
  end (* case *) ;
  
  cir_ans := device_in.elf_data (* set up header info here *) ;

  case device_out.kind of
    DISK:
      set_up_disk_file(ncksms, cir_ans.chars.file_data);

    TAPE:
      begin
	(* store the number of disk sectors required in the header *)
	int_to_wd(
	  nblks,
	  cir_ans.chars.file_data[HD_DSK_SIZE],
	  cir_ans.chars.file_data[HD_DSK_SIZE + 1],
	  cir_ans.chars.file_data[HD_DSK_SIZE + 2],
	  cir_ans.chars.file_data[HD_DSK_SIZE + 3]);
	int_to_wd(
	  ncksms,
	  cir_ans.chars.file_data[HD_CKSM_SIZE],
	  cir_ans.chars.file_data[HD_CKSM_SIZE + 1],
	  cir_ans.chars.file_data[HD_CKSM_SIZE + 2],
	  cir_ans.chars.file_data[HD_CKSM_SIZE + 3]);
	wr_device(device_out, 0, cir_ans, res_out);
      end (* TAPE *)
  end (* case *) ;

  if all_ok
  then
    begin
      while all_ok and not check_for_stop do
	if (device_in.kind = DISK) and (input_disk_page >= input_end_page)
	then res_in := END_FILE
	else
	  begin
	    input_elf_blk(res_in, cir);
	    if all_ok 	(* store checksum and output to disk *)
	    then output_elf_blk(device_out, cir)
	  end (* while *) ;

      if (res_in = END_FILE) and (res_out = COMPLETE)
      then res_in := COMPLETE;

      if all_ok
      then
	case device_out.kind of
	  DISK:
	    wr_device(
	      device_out, device_out.cksum_page,
	      device_out.cksum_blk, res_out);

	  TAPE:
	    begin
	      pos_device(device_out, TAPE_WRITE_EOF, res_out);
	      wr_f_file(cir, res_out)
	    end (* TAPE *)
	end (* case *)
      else cancel_file_creation(cir)	(* some error *)
    end
end (* copy_a_file *) ;



(**************   control   (command execution routines)*****************)
(*									*)
(*			illegal_tape_copy				*)
(*									*)
(************************************************************************)

function illegal_tape_copy : boolean;

var
  tape_version : integer;

begin
  tape_version := make_half(device_in.elf_data.chars.file_data, HD_VER_X);
  if (tape_version < 3) or
    ((tape_version = 3) and
     (make_half(device_in.elf_data.chars.file_data, HD_REV_X) < 7))
  then
    begin
      illegal_tape_copy := TRUE;
      term.write_message_line (
	'tape files must be version 3.07 or later\ ', tt_ans)
    end
  else illegal_tape_copy := FALSE
end (* illegal_tape_copy *);



(**************   control   (command execution routines)*****************)
(*									*)
(*				copy					*)
(*									*)
(*	Execute the Copy command.					*)
(*									*)
(************************************************************************)

procedure copy;

var
  copy_input_kind	: iodevice;
  copy_output_kind	: iodevice;
  copy_output_unit	: integer;
  files_read		: integer;
  files_copied		: integer;
  cmd_done,
  all_flag		: boolean;

begin
  all_flag := input_is_all(ptr + 1);

(* ask for and input "OUTPUT" device; do not confirm a file *)
  get_unit('OUTPUT \', DO_NOT_OPEN, device_out);
  copy_output_kind := device_out.kind;
  copy_output_unit := device_out.unit;

(*	- ask for and input "INPUT" device			*)
(*	- if device is DISK, read unit header into ELF_BLK	*)
(*	- if device is DISK and a single file is to be copied,	*)
(*		ask for and input the file address,		*)
(*		input_disk_page					*)
(*	- if a single file is to be copied read the file header	*)
(*		into INPUT_DEVICE.ELF_DATA and confirm that the	*)
(*		file is the correct one				*)
(*	- if a single file is to be copied and device is DISK,	*)
(*		set up all file pointers and checksum info	*)

  if all_ok
  then
    if all_flag
    then get_unit('INPUT \ ', DO_NOT_OPEN, device_in)
    else get_unit('INPUT \ ', OPEN_READ_CONFIRM, device_in);

  if all_ok
  then
    if all_flag
    then
      begin
	files_read := -1;
	cmd_done := FALSE;
	files_copied := 0;
	copy_input_kind := device_in.kind;
	repeat
	  res_in := COMPLETE; res_out := COMPLETE;
	  case copy_input_kind of
	    DISK: open_next_file_in_directory (files_read);
	    TAPE: rd_device (device_in, 0, device_in.elf_data, file_ans)
	  end (* case *) ;
	  if file_ans = COMPLETE
	  then
	    begin
	      elf_f_type :=
		file_type(ord(device_in.elf_data.chars.file_data[HD_TYPE_X]));
	      if copy_input_kind = TAPE
	      then
		if illegal_tape_copy
		then cmd_done := TRUE
		else
		  if found_final_file
		  then cmd_done := TRUE
		  else
		    if elf_f_type = ERROR_FILE
		    then
		      begin
			cmd_done := TRUE;
			term.write_message_line (
			  'unrecognized data on tape\', tt_ans)
		      end;
	      if not cmd_done
	      then
		begin
		  device_out.kind := copy_output_kind;
		  device_out.unit := copy_output_unit;
		  copy_a_file;
		  if device_out.kind = DISK
		  then detach_dev (device_out);
		  if all_ok
		  then files_copied := files_copied + 1
		end
	    end
	  else	(* file_ans <> COMPLETE *)
	    if (copy_input_kind = DISK) and (file_ans = END_FILE)
	    then
	      begin
		file_ans := COMPLETE;
		cmd_done := TRUE
	      end
	    else
	      if copy_input_kind = TAPE
	      then
		begin
		  rpt_all_errs;
		  pos_device(device_in, TAPE_FORWARD_FILE, file_ans)
		end
	until cmd_done or check_for_stop or not all_ok;
	if cmd_done and (files_copied > 0)
	then
	  begin
	    form.start;
	    form.number (files_copied, 10);
	    form.string (' FILE(S) COPIED\');
	    form.write_line (term, tt_ans)
	  end
      end  
    else
      begin
	copy_a_file;
	if all_ok
	then
	  if device_out.kind = DISK
	  then report_new_disk_file
	  else term.write_message_line ('COPY COMPLETE\', tt_ans)
      end
end (* copy *) ;
!
      (*   CNTRL7.ELF   *)

(***** Create command ****)

(**********************   control   *************************************)
(*									*)
(*				create 					*)
(*									*)
(************************************************************************)

procedure create;

var
  xfr_startd : boolean;

begin
  elf_cmp_fl := FALSE;
  elf_cmp_ct := 0;
  xfr_startd := FALSE (* Slave not yet told to start transfer *) ;

  set_file_type (* Set elf_f_type to type of file being Created *) ;
  get_unit(NULL_M, DO_NOT_OPEN, device_out) (* Request device from user *) ;
  elf_fmt_in (* Request in Image mode for Create Node *) ;
  input_file_id (* Request File ID from user *) ;

  if tt_ans = COMPLETE
  then
    cmn.make_file_hdr (
      elf_f_type, image_form, term_line, cir_ans.chars.file_data);

  login_to_ob_system (* Request login information and build circuit *) ;

  (* Request file names from user until ELFSLV finds file specified *)
  if cmf_host
  then
    begin
      enter_cmf;
      if gt_aux_cir
      then cmf_inp_and_loc_file
    end
  else
    input_and_locate_file;

  if gt_aux_cir
  then
    begin
      add_f_desc (file_desc, cir_ans.chars.file_data);
      if all_ok
      then get_nib_creation;

      (* If disk, and not image format, ask elfslv to report the	*)
      (* number of bytes in the file, adding 1 for each escape char.	*)
      (* - to be sure enough space is allocated on the disk.		*)
      exp_b_ct := 0;
      if all_ok and not image_form
      then
	begin
	  snd_cir_ch(two);
	  exp_b_ct := gt_byte_ct;
	end;

      if all_ok 	 (* Tell slave to send file *)
      then
	begin
	  snd_cir_ch (ONE);
	  xfr_startd := TRUE
	end;
      gt_st_add;  "input word of start address if load node"
      if all_ok
      then byte_count := gt_byte_ct;	"input word of byte count"
      if exp_b_ct = 0
      then exp_b_ct := byte_count;
      mv_elf_chs (
	BYTS_IN_WD, cir.chars.file_data, 1,
	cir_ans.chars.file_data, HD_BYTE_CT_X);

      if exp_b_ct <= 0
      then
	begin
	  if this_sub.sub_prg = SNODE
	  then term.write_message_line ('INVALID EQUIVALENCE FILE.\', tt_ans);
	  res_in := SYNC_ERROR
	end
      else set_up_file	(* If disk, allocate space			*)
			(* If tape, store amount to be saved on disk	*) ;

      if all_ok
      then
	begin
	  term.write_message_line (XFR_STARTING_M, tt_ans);
	  if image_form
	  then
	    begin
	      recs_sent := 0;
	      good_recs := 0;
	      zero_fill_count := 0;
	      resent_recs := 0;
	      late_recs := 0;
	      init_elf;
	      elf_addr := 0;
	      chars_left := 0;
	      while all_ok do
		begin
		  nxt_in_ch;
		  sv_nxt_elf
		end (* while *);
	    end
	  else
	    begin
	      elf_addr := -1;
	      chars_left := 0;
	      while all_ok do get_seg;
	    end;
	  (* Finish writing file, or backspace over partially written	*)
	  (* file, and append a final file. If disk, report disk	*)
	  (* addresses if sucessful, or delete file if not.		*)
	  end_elf
	end
      else
	if xfr_startd
	then ans_elfslv(forget_it, res_in);
      if cmf_host and not all_ok
      then
	begin
	  snd_cir_ch(EXIT_SLAVE);
	  zap_aux_circuit
	end
    end (* if gt_aux_cir *)
end (* create *) ;
!
      (*   CNTRL7.ELF   *)

(***** Delete command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				delete					*)
(*									*)
(*	Execute the Delete command.					*)
(*									*)
(************************************************************************)

procedure delete;

begin
  get_disk (OPEN_READ_CONFIRM, device_in);
  if all_ok
  then device_in.disk_operator.delete_open_file ;
  if all_ok
  then term.write_message_line ('FILE deleted\ ', tt_ans)
end (* delete *) ;
!
      (*   CNTRL7.ELF   *)

(***** Device command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				device					*)
(*									*)
(*	Execute the Device command.					*)
(*									*)
(************************************************************************)

procedure device;

begin
  get_unit (NULL_M, DO_NOT_OPEN, device_out);
  if all_ok then get_and_type_dev_status(device_out)
end (* device *) ;
!
      (*   CNTRL7.ELF   *)

(***** Directory command ****)

(**********************   control   *************************************)
(*									*)
(*		  single_file_directory					*)
(*									*)
(*	Do a directory for a single file.				*)
(*									*)
(************************************************************************)

procedure single_file_directory;

begin
  if found
  then type_header (FALSE, device_in.elf_data.chars.file_data)
end (* single_file_directory *) ;



(**************   control   (command execution routines)*****************)
(*									*)
(*				directory				*)
(*									*)
(*	Execute the Directory command.					*)
(*									*)
(************************************************************************)

procedure directory;

var
  ok,
  all_flag : boolean;

begin
  all_flag := ptr >= term_line.length;
  if all_flag
  then ok := TRUE
  else
    begin	(* there is more input on command line *)
      ptr := ptr + 1;
      cmn.input_num(decimal, term_line, ptr, input_disk_page, ok);
      if not ok
      then term.write_message_line ('illegal address entered\', temp_ans)
    end;

  if ok
  then
    begin
      if all_flag
      then get_unit(NULL_M, DO_NOT_OPEN, device_in)
      else get_unit(NULL_M, OPEN_READ_DO_NOT_CONFIRM, device_in);
      if all_ok
      then
	case device_in.kind of
	  DISK:
	    if all_flag
	    then full_disk_directory
	    else single_file_directory;

	  TAPE:
	    begin
	      term.write_newline (tt_ans);
	      rew_device(device_in);
	      elf_f_type := ERROR_FILE;
	      repeat
		rd_device(device_in, 0, elf_blk , file_ans);
		type_header(FALSE, elf_blk.chars.file_data);
		if (elf_f_type <> F_FILE) and (file_ans = COMPLETE)
		then pos_device(device_in, TAPE_FORWARD_FILE, file_ans)
	      until not all_ok or
		  (elf_f_type = F_FILE) or (elf_f_type = ERROR_FILE);
	      if all_ok
	      then rew_device(device_in)
	    end (* TAPE *)
	end (* case *)
    end
end (* directory *) ;
!
      (*   CNTRL7.ELF   *)

(***** Dump command ****)

(****************************   control   *******************************)
(*									*)
(*				dump					*)
(*									*)
(************************************************************************)

procedure dump;

begin
  if check_mxp_or_tymstar
  then
    begin
      image_form := this_sub.sub_prg = SNODE;
      set_file_type;
      get_unit(NULL_M, DO_NOT_OPEN, device_out);
      if all_ok
      then
	begin
	  input_file_id;
	  if tt_ans = COMPLETE
	  then
	    cmn.make_file_hdr(
	      elf_f_type, image_form, term_line, cir_ans.chars.file_data);
	  (* Input specs on what to dump and build circuit *)
	  case this_sub.sub_prg of
	    SNODE: input_dump_addrs;
	    SSLOT,
	    SPART: input_segs
	  end (* case *);
	  set_up_file
	end;
      if all_ok
      then 		(* start transfer *)
	begin
	  term.write_message_line (XFR_STARTING_M, tt_ans);
	  case this_sub.sub_prg of
	    SNODE: dump_node;
	    SSLOT,
	    SPART: dump_isis
	  end (* case *) ;
	  end_elf
	end
    end
end (* dump *);
!
      (*   CNTRL7.ELF   *)

(***** Format command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				format					*)
(*									*)
(*	Execute the Formet command.					*)
(*									*)
(************************************************************************)

procedure format;

var
  failure_status : disk_drive_device_status ;
  drive_status	 : ioresult;
  failure_time   : integer ;
  nfiles	 : integer ;

begin
  get_disk (DO_NOT_OPEN, device_in);
  if all_ok
  then
    begin
      term.write_message_line (
	'THIS COMMAND WILL DESTROY ANY CURRENT DISK DATA\', tt_ans);
      if ask(continue_m)
      then
	if disk_mon[device_in.unit].format
	then
	  begin
	    nfiles := -1;
	    repeat
	      open_next_file_in_directory (nfiles);
	      if file_ans = COMPLETE
	      then device_in.disk_operator.delete_open_file
	    until not all_ok;

	    if file_ans = END_FILE
	    then
	      begin
		file_ans := COMPLETE;
		term.write_message_line ('DISK FORMATTED\ ', tt_ans)
	      end
	  end
	else
	  begin
	    disk_mon[device_in.unit].disk_failure_info (
	      failure_status, failure_time) ;
	    form.simple_message ('Cannot format - \ ');
	    form.disk_drive_device_status_name (failure_status);
	    form.write_line (term, tt_ans);
	    disk_mon[device_in.unit].io_status(drive_status);
	    form.simple_message('DISK ERROR:  \');
	    form.status_name (drive_status);
	    form.write_line(term, tt_ans)
	  end
    end
end (* format *) ;
!
      (*   CNTRL7.ELF   *)

(***** Gateway command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				gateway					*)
(*									*)
(*	Execute the Gateway command.					*)
(*									*)
(************************************************************************)

procedure gateway;

begin
  with aux.info do
    begin
      get_user_host('GATEWAY USERNAME ( :HOST ): \ ',
	g_user, g_userlen, g_hostf, g_host);
      if all_ok
      then g_x75 := ask('IS GATEWAY TO TYMNET AN X.25/X.75 GATEWAY\');
      if all_ok
      then non_standard := ask('NON STANDARD LOGIN\ ');
      if all_ok and non_standard
      then input_password('GATEWAY PASSWORD:\', g_password)
    end (* with *)
end (* gateway *) ;
!
      (*   CNTRL7.ELF   *)

(***** Help command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				help					*)
(*									*)
(*	Execute the Help command.					*)
(*									*)
(************************************************************************)

procedure help;

begin
  term.write_newline (tt_ans);
  term.write_message_line ('Valid commands are:\', tt_ans);
  term.write_newline (tt_ans);
  term.write_message_line ('COPy\ ', tt_ans);
  term.write_message_line ('CReate Node\', tt_ans);
  term.write_message_line ('CReate Slot\', tt_ans);
  term.write_message_line ('CReate Partial\ ', tt_ans);
  term.write_message_line ('DEVice\ ', tt_ans);
  term.write_message_line ('DIrectory\', tt_ans);
  term.write_message_line ('DUmp Node\', tt_ans);
  term.write_message_line ('DUmp Slot\', tt_ans);
  term.write_message_line ('DUmp Partial\ ', tt_ans);
  term.write_message_line ('Gateway\', tt_ans);
  term.write_message_line ('Help\ ', tt_ans);
  term.write_message_line ('HOst\ ', tt_ans);
  term.write_message_line ('LOAd Node\', tt_ans);
  term.write_message_line ('LOAd Slot\', tt_ans);
  term.write_message_line ('LOAd Partial\ ', tt_ans);
  term.write_message_line ('LOCate\ ', tt_ans);
  term.write_message_line ('MESsage\', tt_ans);
  term.write_message_line ('Quit\ ', tt_ans);
  term.write_message_line ('REStart\', tt_ans);
  term.write_newline (tt_ans);
  term.write_message_line (
    'The following commands apply to DISK only: \', tt_ans);
  term.write_message_line ('CONdense\ ', tt_ans);
  term.write_message_line ('DELete\ ', tt_ans);
  term.write_message_line ('Format\ ', tt_ans);
  term.write_message_line ('REName\ ', tt_ans);
  term.write_newline (tt_ans);
  term.write_message_line (
    'The following commands apply to TAPE only: \', tt_ans);
  term.write_message_line ('SKip\ ', tt_ans);
  term.write_message_line ('REWind\ ', tt_ans)
end (* help *) ;
!
      (*   CNTRL7.ELF   *)

(***** Host command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				host					*)
(*									*)
(*	Execute the Host command.					*)
(*									*)
(************************************************************************)

procedure host;

begin
  term.write_message_line (
	'ACCESS CMF HOST OR TYMCOM HOST,\', tt_ans);
  cmf_host := ask('RESPOND YES FOR CMF, NO FOR TYMCOM\ ');
  "TRUE for cmf, FALSE for tymcom"
  if cmf_host
  then
    if ask('DO YOU WANT TO ASSIGN A NETPORT HOST NUMBER\')
    then input_number('HOST NUMBER: \', FALSE, DECIMAL, netport_host)
    else netport_host := 0
end (* host *) ;
!
      (*   CNTRL7.ELF   *)

(***** Load command ****)

(****************************   control   *******************************)
(*									*)
(*				load					*)
(*									*)
(************************************************************************)

procedure load;

begin
  if check_mxp_or_tymstar
  then
    begin
      elf_cmp_fl := FALSE;
      get_unit (NULL_M, OPEN_READ_CONFIRM, device_in);
      if all_ok
      then
	case this_sub.sub_prg of
	  SNODE:
	    begin
	      login_to_dl_system;
	      strt_add :=
		wd_to_int(device_in.elf_data.chars.file_data, HD_ST_ADR_X);
	      byte_count :=
		wd_to_int(device_in.elf_data.chars.file_data, HD_BYTE_CT_X)
	    end (* SNODE *) ;
	SSLOT,
	SPART: login_to_slot
      end (* case *) ;
      if all_ok
      then
	begin
	  term.write_message_line (XFR_STARTING_M, tt_ans);
	  set_up_input_device(device_in, input_end_page, input_disk_page);
	  case this_sub.sub_prg of
	    SNODE: load_node;
	    SSLOT,
	    SPART: load_slot
	  end (* case *) ;
	  rpt_xfr_er
	end
    end
end (* load *);
!
      (*   CNTRL7.ELF   *)

(***** Locate command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*			report_elf_device				*)
(*									*)
(************************************************************************)

procedure report_elf_device;

begin
  form.start;
  case device_in.kind of
    DISK: form.character ('D');
    TAPE: form.character ('M')
  end (* case *) ;
  form.number (device_in.unit, DECIMAL);
  form.skip (1);
  form.write_string (term, tt_ans)
end (* report_elf_device *) ;



(**************   control   (command execution routines)*****************)
(*									*)
(*				check_file				*)
(*									*)
(*	Check to see if the object file described by file_desc matches	*)
(*	the file name in device_in.elf_data; if so, if found_file is	*)
(*	FALSE, output the file information and set found_file to TRUE.	*)
(*	If found_file was already TRUE, call report_elf_device before	*)
(*	outputting the file information.				*)
(*									*)
(************************************************************************)

procedure check_file(
      header		: univ file_header_record;
      file_number	: integer;
  var found_file	: boolean);

var
  file_desc_ptr : integer;
  check_done,
  match : boolean;
  
begin
  match := TRUE (* TRUE until a mis-match found *);

(* if no user name was specified, skip username check *)
  if file_desc.user[1] <> ZERO
  then
    begin
      check_done := FALSE;
      file_desc_ptr := 1;
      repeat
        if file_desc.user[file_desc_ptr] <>
	    header.object_file.user[file_desc_ptr]
	then match := FALSE;
	if file_desc_ptr < MX_UN_SZ
	then file_desc_ptr := file_desc_ptr + 1
	else check_done := TRUE
      until check_done or not match
    end;

(* check file name *)
  if match
  then
    begin
      check_done := FALSE;
      file_desc_ptr := 1;
      repeat
        if file_desc.file[file_desc_ptr] <>
	    header.object_file.file[file_desc_ptr]
	then match := FALSE;
	if file_desc_ptr < MX_FN_SZ
	then file_desc_ptr := file_desc_ptr + 1
	else check_done := TRUE
      until check_done or not match
    end;

(* check extension name, if specified *)
  if match and (file_desc.ext[1] <> ZERO)
  then
    begin
      check_done := FALSE;
      file_desc_ptr := 1;
      repeat
        if file_desc.ext[file_desc_ptr] <>
	    header.object_file.ext[file_desc_ptr]
	then match := FALSE;
	if file_desc_ptr < 4
	then file_desc_ptr := file_desc_ptr + 1
	else check_done := TRUE
      until check_done or not match
    end;

  if match
  then
    begin
      if found_file
      then report_elf_device
      else found_file := TRUE;

      form.start;
      case device_in.kind of
	DISK: form.format_number (input_disk_page, DECIMAL, MX_PG_DGTS);
	TAPE: form.format_number (file_number, DECIMAL, MX_PG_DGTS)
      end (* case *) ;
      form.skip (2);
      form.write_string (term, tt_ans);

      output_file_type (TRUE);

      type_date(NULL_M, header.creation_date_and_time);
      term.write_message_string (' \', tt_ans);

      if nib_date_exists (left_half (header.ver_rev))
      then type_date (NULL_M, header.nib_crea_date_and_time)
      else term.write_message_string ('        \ ', tt_ans);

      type_object_file_name(' \', header, DO_CR)
    end (* if match *)
end (* check_file *) ;



(**************   control   (command execution routines)*****************)
(*									*)
(*			 check_file_type				*)
(*									*)
(************************************************************************)

procedure check_file_type (header : univ file_header_record);

begin
  elf_f_type := file_type(ord(header.file_type));
  case device_in.kind of
    DISK:
      if elf_f_type = ERROR_FILE
      then file_ans := BAD_DISK;
    TAPE:
      if elf_f_type = ERROR_FILE
      then file_ans := BAD_TAPE
      else
	if found_final_file
	then file_ans := END_FILE
  end (* case *)
end (* check_file_type *) ;



(**************   control   (command execution routines)*****************)
(*									*)
(*				locate_elf_file				*)
(*									*)
(************************************************************************)

procedure locate_elf_file;

var
  file_found : boolean	(* TRUE when first file found on a device *);
  file_number : integer (* position on tape of file *);

begin
  report_elf_device;
  attach_dev(device_in, file_ans);
  if file_ans <> COMPLETE
  then output_ioresult(file_ans)	(* tell error and return *)
  else		(* device was attached and assigned successfully *)
    begin
      case device_in.kind of
	DISK:
	  (* empty *) ;
	TAPE:
	  rew_device(device_in) (* if tape, rewind to beginning *)
      end (* case *) ;
      file_found := FALSE; file_number := -1;

      repeat
        case device_in.kind of
	  DISK:
	    open_next_file_in_directory (file_number);
	  TAPE:
	    begin
	      rd_device (device_in, 0, device_in.elf_data, file_ans);
	      if file_ans = COMPLETE
	      then file_number := file_number + 1 (* addr of next file *)
	    end (* TAPE *)
	end (* case *) ;

	if file_ans = COMPLETE
	then check_file_type (device_in.elf_data.chars.file_data);

	if file_ans = COMPLETE
	then		(* got a recognizable ELF file *)
	  begin	 (* if match, tell user and set flag *)
	    check_file (
	      device_in.elf_data.chars.file_data, file_number, file_found);
	    if device_in.kind = TAPE
	    then pos_device(device_in, TAPE_FORWARD_FILE, file_ans)
	  end
	else
	  if file_ans <> END_FILE
	  then output_ioresult(file_ans)
      until (file_ans <> COMPLETE) or check_for_stop;

      if file_ans = END_FILE
      then
        begin
	  if device_in.kind = TAPE
	  then rew_device(device_in);
	  file_ans := COMPLETE;
	  if not file_found
	  then term.write_message_line ('NO FILES FOUND\ ', tt_ans)
	end;
      detach_dev(device_in)
    end
end (* locate_elf_file *);



(**************   control   (command execution routines)*****************)
(*									*)
(*			     legal_unit					*)
(*									*)
(*	Return whether or not unit is operative.			*)
(*									*)
(************************************************************************)

function legal_unit (kind : iodevice; unit : integer) : boolean ;

begin
  case kind of
    DISK: legal_unit := unit < DISK_MAX;
    TAPE: legal_unit := allocate_tape.legal_unit (unit)
  end (* case *)
end (* legal_unit *) ;



(**************   control   (command execution routines)*****************)
(*									*)
(*				locate					*)
(*									*)
(*	Execute the Locate command.					*)
(*									*)
(************************************************************************)

procedure locate;

var
  locate_kind	  : iodevice;
  locate_unit	  : integer;
  locate_max_unit : integer;

begin
  get_obj_file_name;
  if all_ok
  then
    begin
      locate_kind := DISK (* search disk first *) ;
      repeat
	locate_unit := 0;
	case locate_kind of
	  DISK: locate_max_unit := DISK_UNIT_LIMIT;
	  TAPE: locate_max_unit := TAPE_UNIT_LIMIT
	end (* case *) ;
	repeat
	  if legal_unit(locate_kind, locate_unit)
	  then
	    begin
	      device_in.unit  := locate_unit;
	      device_in.kind  := locate_kind;
	      device_in.state := DEVICE_UNUSED;
	      file_ans := COMPLETE;
	      locate_elf_file
	    end;
	  locate_unit := locate_unit + 1
	until (locate_unit > locate_max_unit) or check_for_stop;
	locate_kind := succ(locate_kind)
      until (locate_kind > TAPE) or check_for_stop;
      file_ans := COMPLETE
    end
end (* locate *) ;
!
      (*   CNTRL7.ELF   *)

(***** Message command ****)

(**************   control   (command execution routines)*****************)
(*                                                                      *)
(*				message				        *)
(*                                                                      *)
(*	Execute the MESSAGE command.				        *)
(*                                                                      *)
(************************************************************************)


procedure message;

var
  ok		 : boolean;
  count		 : integer;
  next_message	 : oper_log_entry;
  last_time	 : integer;

begin
  if term_line.length > ptr
  then
    begin
      ptr := ptr + 1;
      cmn.input_num (DECIMAL, term_line, ptr, count, ok);
      if ok
      then oplog.set_offset (elf_user, count)
      else term.write_message_line  ('Invalid decimal number\ ', temp_ans)
    end
  else
    begin
      oplog.backup (elf_user, 1);
      ok := TRUE
    end;

  last_time := -1;
  if ok and all_ok
  then
    repeat
      oplog.read (elf_user, next_message, found);
      if found 
      then
	begin
	  if next_message.time <> last_time
	  then
	    begin
	      term.write_newline (tt_ans);
	      form.start;
	      form.time (next_message.time);
	      form.string ('  message \ ');
	      form.number (next_message.sequence, DECIMAL);
	      form.write_line (term, tt_ans);
	      last_time := next_message.time
	    end;

	  term.write_message_buffer (next_message.message, DO_CR, tt_ans)
	end
    until not (all_ok and found)
end (* message *) ;
!
      (*   CNTRL7.ELF   *)

(***** Quit command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				quit					*)
(*									*)
(*	Execute the Quit command.					*)
(*									*)
(************************************************************************)

procedure quit;

begin
  zap_aux_circuit;
  zap_tty_circuit
end (* quit *) ;
!
      (*   CNTRL7.ELF   *)

(***** Rename command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				rename					*)
(*									*)
(*	Execute the Rename command, for Disk files only.		*)
(*									*)
(************************************************************************)

procedure rename;

var
  new_id      : file_id_string ;
  disk_okay   : boolean ;
  file_header : file_header_record ;

begin
  get_disk (OPEN_WRITE_CONFIRM, device_in);
  if found and all_ok
  then
    begin
      term.write_message_string ('NEW \ ', tt_ans);
      input_file_id;
      if all_ok
      then
	begin
	  for n := 1 to term_line.length do
	    new_id[n] := term_line.chars[n];
	  for n := term_line.length + 1 to FILE_ID_SZ do
	    new_id[n] := SPACE;
	  device_in.disk_operator.read_block
		    (FILE_HEADER_BLOCK, file_header, disk_okay);
	  file_header.file_id := new_id ;
	  device_in.disk_operator.write_block
		    (FILE_HEADER_BLOCK, file_header, disk_okay);
	  if all_ok and disk_okay
	  then begin
	    term.write_message_line ('FILE RENAMED\ ', tt_ans)
	  end
	  else
	    term.write_message_line ('FILE RENAME FAILED.  TRY AGAIN.\',tt_ans)
	end (* if all_ok *)
    end
end (* rename *) ;
!
      (*   CNTRL7.ELF   *)

(***** Restart command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				restart					*)
(*									*)
(*	Execute the Restart command.					*)
(*									*)
(************************************************************************)

procedure restart;

begin
  this_sub.sub_prg := snode;
  login_to_dl_system;
  input_number('RESTART ADDRESS (IN HEX): \ ', FALSE, hex, strt_add);
  if all_ok
  then
    begin
      start_it;
      if all_ok
      then term.write_message_line ('NODE RESTARTED\ ', tt_ans)
      else
	if res_out = TIMED_OUT
	then term.write_message_line ('NO START-UP ACK RECEIVED\ ', tt_ans)
    end
end (* restart *) ;
!
      (*   CNTRL7.ELF   *)

(***** Rewind command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				rewind					*)
(*									*)
(*	Execute the Rewind command.					*)
(*									*)
(************************************************************************)

procedure rewind;

begin
  get_tape (DO_NOT_OPEN, device_out);
  if all_ok
  then
    begin
      rew_device(device_out);
      if file_ans = COMPLETE
      then term.write_message_line ('DEVICE REWOUND\ ', tt_ans)
    end
end (* rewind *) ;
!
      (*   CNTRL7.ELF   *)

(***** Skip command ****)

(**************   control   (command execution routines)*****************)
(*									*)
(*				skip					*)
(*									*)
(*	Execute the Skip command.					*)
(*									*)
(************************************************************************)

procedure skip;

var
  files_skipped,
  temp : integer;
  all_flag : boolean;

begin
  files_skipped := 0;
  get_tape (DO_NOT_OPEN, device_in);
  if all_ok
  then
    begin
      temp := 1;
      input_number_or_all (
	'NUMBER OF FILES TO SKIP: \', DECIMAL, all_flag, temp);
      while all_ok and not check_for_stop and (temp > 0) do
	begin
	  if all_flag
	  then
	    begin
	      rd_device(device_in, 0, elf_blk, file_ans);
	      elf_f_type := file_type(ord(elf_blk.chars.file_data[HD_TYPE_X]));
	      if elf_f_type = ERROR_FILE
	      then
		begin
		  temp := 0;
		  term.write_message_line ('BAD FORMAT TAPE\', tt_ans)
		end
	      else
		if elf_f_type = F_FILE
		then
		  begin
		    temp := 0	(* done *);
		    pos_device(device_in, TAPE_BACK_FILE, file_ans);
		    pos_device(device_in, TAPE_FORWARD_FILE, file_ans)
		  end
		else
		  begin
		    files_skipped := files_skipped + 1;
		    pos_device(device_in, TAPE_FORWARD_FILE, file_ans)
		  end
	    end
	  else (* all_flag is FALSE *)
	    begin
	      pos_device(device_in, TAPE_FORWARD_FILE, file_ans);
	      temp := temp - 1
	    end
	end;
      if all_ok
      then
	begin
	  form.start;
	  if all_flag
	  then
	    begin
	      form.number (files_skipped, DECIMAL);
	      form.skip (1)
	    end;
	  form.string ('FILES SKIPPED\');
	  form.write_line (term, tt_ans)
	end
    end
end (* skip *) ;
!
      (*   CNTRL7.ELF   *)

(**************   control   (command execution routines)*****************)
(*									*)
(*				do_cmd					*)
(*									*)
(*	This routine discriminates between the various commands.	*)
(*									*)
(************************************************************************)

procedure do_cmd;

var
  save_io_error,
  save_ctr_stat  : integer;

begin
  res_in := complete;
  res_out := complete;
  user_interrupt := FALSE;

  case this_cmd.prg_name of

    CCONDENSE: condense;

    CCOPY: copy;

    CCREATE: create;

    CDELETE: delete;

    CDEVICE: device;

    CDIRECTORY: directory;

    CDUMP: dump;

    CFORMAT: format;

    CGATEWAY: gateway;

    CHELP: help;

    CHOST: host;

    CLOAD: load;

    CLOCATE: locate;

    CMESSAGE: message;

    CQUIT: quit;

    CRENAME: rename;

    CRESTART: restart;

    CREWIND: rewind;

    CSKIP: skip

  end (* case *) ;

  save_io_error := io_error;
  save_ctr_stat := ctr_stat;
  detach_dev(device_in);
  detach_dev(device_out);
  if (res_in = timed_out)  or (res_out=timed_out) or
    (res_out = sync_error) or (res_in = sync_error) or
    (res_in = obj_error) or (aux_ans = sync_error) or
    (aux_ans = timed_out) or (res_in = transmission) or (tt_ans = failure)
      then zap_aux_circuit;
  if (this_cmd.prg_name = cload) or (this_cmd.prg_name = crestart)
    then zap_aux_circuit;
  if io_error = 0
  then begin
    io_error := save_io_error;
    ctr_stat := save_ctr_stat
  end ;
  rpt_all_errs
end (* do_cmd *) ;
!
      (*   CNTRL7.ELF   *)

(**************   control   (command execution routines)*****************)
(*									*)
(*			control process routine				*)
(*									*)
(*	This is the main procedure that loops on getting input from	*)
(*	the terminal or waits for a login.				*)
(*									*)
(************************************************************************)

begin
  init  term(terminal, term_unit),
	cirio(aux_circuit, port_unit),
	form,
	cmn(form), devs,
	device_in.disk_operator (disk_mon),
	device_out.disk_operator (disk_mon);

  special_dl := ['(:3:)','(:15:)','(:128:)','(:129:)','(:130:)','(:131:)',
    '(:132:)','(:133:)','(:134:)','(:135:)','(:136:)','(:137:)','(:138:)',
    '(:139:)','(:140:)','(:141:)','(:142:)','(:143:)'];

  gt_tty_cir := FALSE;
  gt_aux_cir := FALSE;

  cycle
    if gt_tty_cir
    then
      begin	"if user logged in, get a command and process it"
	term.write_newline (tt_ans);
	term.write_message_string (PROMPT_M, tt_ans);
	getcmd(found, this_cmd, this_sub);
	if tt_ans = FAILURE
	then
	  begin
	    zap_aux_circuit;
	    gt_tty_cir := FALSE
	  end;
	if found then do_cmd;
	term.clr_brk_st(tt_ans)
      end
    else		"no user logged in, go wait for login"
      begin
	reset_all;
	repeat
	  term.read_needle(needle, 0, 0, tt_ans);
	  wait
	until tt_ans = COMPLETE;
	term.set_crt_terminal;
	term.set_alternate_break( '(:27:)');
	oplog.initial_user_sequence (elf_user);
	term.write_newline (tt_ans);
	term.write_newline (tt_ans);
	type_vers (version, revision);
	gt_tty_cir := TRUE
      end
  end "cycle"
end;
!
(*   ELFVAR.ELF Updated 5-Aug-85 at 11:01 by Paktor   *)
(*   ELF v 4.0, ELF User (with or without Backup) Main Process Variables  *)

(************************************************************************)
(*									*)
(*	ELFVAR.ELF							*)
(*									*)
(*	Declaration of Vars for User Process				*)
(*									*)
(************************************************************************)

Var
  Mark_Mon      : Mark_Monitor ;
  Disk_Mon      : Disk_Monitor_Array ;
  Config_Mon    : Configuration_Monitor ;
  Condense      : Array [ Disk_Index ] of Condense_Process ;
  Oper_Log      : Operator_Log ;
  Op_Log        : Operator_Utility ;

  allocate_tape	: tape_allocater;
  tunit		: integer;
  xunit		: integer;
  n		: integer;
  cmdmon	: commanddefs;
  users		: array [user_index] of control;
!
(*   EBKINI.EBK Updated 5-Aug-85 at 11:03 by Paktor         *)
(*   ELF v 4.0, (ELF with Backup) Initialization Procedure  *)

(*  Continuation of the Variable Declaration begun in ELFVAR.  *)


(**)
!
    (*   EBKINI.EBK  *)

Procedure Init_ELF ;

    (*  Init the Disk Monitor and other things used by both the User   *)
    (*                Processes and the ELF Backup Processes.          *)

Var
  Per_Disk            : Disk_Index ;
  My_Host_Position    : Host_Index ;


(**)
!
    (*   EBKINI.EBK  *)

Begin    (*   Init_ELF  *)

  Init Config_Mon ;
  My_Host_Position := Config_Mon.My_Host_Position ;
  Init Mark_Mon(My_Host_Position) ;

  (* Init the Disk Drivers  *)
  For Per_Disk := Disk_First to Disk_Limit Do
    Begin
    Init Disk_Mon   [ Per_Disk ] (Per_Disk,
					            Mark_Mon ) 
    End ;

  Init Oper_Log(Disk_Mon) ;
  Init Op_Log(Oper_Log) ;

  For Per_Disk := Disk_First to Disk_Limit
    Do Begin
      Init Condense   [ Per_Disk ] ( Per_Disk, Disk_Mon[Per_Disk], Oper_Log ) 

      End ;

  End  (*  Init_ELF  *) ;

(**)
!
    (*   EBKINI.EBK  *)

!
(*   ELFINI.ELF Updated 5-Aug-85 at 11:29 by Paktor   *)
(*   ELF v 4.0, (ELF with Backup) Main Process Initialization (Less Vars)  *)

begin
  init cmdmon ;
  init allocate_tape ;

  init_elf ;

  tunit := -1; xunit := -1;
  for n := USER_FIRST to USER_LIMIT do
    begin
      tunit := tunit + 1;
      xunit := xunit + 1;
      init users[n](
	n, tunit, xunit, allocate_tape, cmdmon, disk_mon, mark_mon,
	oper_log)
    end ;
end (* elf *) .
!
    1@\