	SUBTTL	TIIINT

:		***** ***** ***** ***** *   * *****
:		  *     *     *     *   **  *   *
:		  *     *     *     *   * * *   *
:		  *     *     *     *   *  **   *
:		  *   ***** ***** ***** *   *   *


: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source  code  listing  constitutes  the proprietary   **
: **  property of MDC-TYMNET.  The recipient, by receiving this   **
: **  program listing, agrees that neither this listing nor the   **
: **  information disclosed herein nor any part thereof shall be  **
: **  reproduced or transferred to other documents or used or dis-**
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by MDC-TYMNET. **
: ******************************************************************

::#####################################################################
::
::	MODULE:		T I I I N T
::
::	FUNCTION:	TYMNET-II NODE CODE INITIALIZATION FILE
::
::#####################################################################

	RA	0

INITVR  EQ	$8 17		:initialization file version number

:	CONFIGURATION CONSTRAINTS

MAXLNK	EQ	$A 128			: Maximum number of links supported
MAXLIN	EQ	$A 128			: Maximum number of lines supported
	
:	REQUIRED SYMBOLS FOR TYMFILE DECLARATIONS:

SAT	EQ	$0 0A0		:INDICATE 'REAL' SATELLITE LINK
TER	EQ	$0 80		:DEFAULT LINK TYPE IS TERRESTRIAL
MS	EQ	$0 1F		:REPORTING VALUE FOR MEMORY SHUFFLER SPEED
TIWS8	EQ	$0 40		:T-I WSIZ 8 LINK
	GL	PAHPTR,PA1PTR,PHSIZE,PATCH1,PATCH0,PA0PTR,PATHIS,P0SIZE,P1SIZE


IF.	MACRO[ IF ]

::*********************************************************************
::
::	MACRO:		PATCH:/CONPATCH:/ENDPATCH:
::	FUNCTION:
::	This code defines symbols and macros used for patching
::	released code and keeping a history of patches in Engine memory.
::
::	A file containing the actual patches to the code should be
::	assembled as the last file before saving the NIB file.
::
::	Patches are added by ORGing to the area to patch,
::	zeroing memory for the length of the patch, writing new
::	code starting at that area.
::	Three macros have been defined to do this.
::	Each patch should start with a PATCH macro and if the
::	patch is for more than one area it should be continued
::	with a CONPATCH macro.  The patch should be ended with
::	an ENDPATCH macro.
::
::	Using these macros will cause the patch number, author
::	area patched, and reason for patch to be output during assembly.
::	Also, a history table starting at PATHIS will be created with
::	16 (10hex) byte entries.
::	Each entry will contain the date and time of patch and the author
::	and can by displayed using the XRAY 'PQ' command.
::
::	If a patch must be temporarily added by hand, the
::	history area should updated accordingly.
::
::	SEGn,SnSIZE are defined for all node code segments and
::	segment address limit checking is performed for patches.
::
::	The following symbols are used by the patch macros.
::	They may be read by, but should not be modified by, a patch.
::
::	PAHPTR	pointer to the next available entry in PATHIS
::	PA0PTR	This symbol may be used to place a patch at the next
::		available address in the PATCH0 area.  It starts out
::		equal to PATCH0 and is moved up after each patch in
::		the PATCH0 area.  Use of the symbol assumes that all
::		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
::	PA1PTR	This symbol may be used to place a patch at the next
::		available address in the PATCH1 area.  It starts out
::		equal to PATCH1 and is moved up after each patch in
::		the PATCH1 area.  Use of the symbol assumes that all
::		patches from PATCH1 to PATCH1+P1SIZE will be done in order.
::	QPATS	current patch segment number
::	QPATB	starting address of current patch
::	QPATL	length of current patch
::	QPATA	0 IF PATCH IS IN PATCH0 AREA, 1 IF IN PATCH1, ELSE -1
::	PATACT	> 0 if when a patch is active.
::
::	PATCH(yymmdd,hhmm,uname,fba,lba1,len)	grab a patch area
::
::		yymmdd	Date patch written, if patch is modified in ANY
::		way this must be updated.
::		hhmm	Time patch written, current Cupertino time.
::		If patch is modified this also must be updated.
::		uname	ONTYME username of person who authored patch.
::		Personal name, not NETMID or NET3 or such.
::	fba	adress of start of patch
::	lba1	address of next byte after end of patch
::	len	length (default hex) of patch in bytes if lba1 is missing
::
::	CONPATCH(fba,lba1,len)	continue a patch in a new area
::		Similar to PATCH but moves to a new area, must be
::		preceeded by a PATCH statement.
::
::	ENDPATCH(comment)	End a PATCH started with PATCH call.
::
::		comment	Description of patch to be output during
::			assembly.  Commas should be preceeded by `.
::
::	Example:
::	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
::	  IF	HDLC&(LAPB!LAP)
::	PATCH(811009,1422,FRED,XROOM,,2)
::		LIS	R4,7
::	ENDPATCH(fix hdlc room checking routine)
::	  EI
::
::	:	PATCH TO FIX TRANSMITTER BUG
::	PATCH(811009,1630,DDM,XSEND,XSE010)
::	  IF	FINACT	:IF INTERFRAME FILL TIMER ENABLED
::		J	PA1PTR
::	  EI
::	PATRTN	LR	R6,RSIO
::		AHI	R6,OUTSCT,RSIP
::
::	CONPATCH(PA1PTR,,0C)
::		SBT	RL,FRMTMT,,	:INDICATE FRAME TRANSMITTED
::		JNR	R7		:IF ALREADY TRANSMITTED
::		J	PATRTN		:RETURN TO PATCHED AREA
::	ENDPATCH(fix transmitter bug)
::
::*********************************************************************

	GL	PAHPTR,PA0PTR,PA1PTR,QPATS,QPATB,QPATL,QPATA,PATACT
	GL	PATHIS,PATCH0,PATCH1,P0SIZE,P1SIZE,PHSIZE

:	DEFINE SOME MACROS

	GL	.35.
.35.	EQ	$A 35
	KILL	.NE.
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-.35.]
	KILL	.GT.
.GT.	MACRO(P1,P2)[((P2)-(P1))^-.35.]

:	DEFINE SOME SYMBOLS

PATACT	EQ	0	:FLAG NO PATCH ACTIVE
QPATA	EQ	-1	:CLEAR PATCH AREA FLAG
QPATS	EQ	-1
QPATB	EQ	-1
QPATL	EQ	-1

:	>>PATCH MACRO<<

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	0
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	(lba1)-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	(.+1)-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK  overflow <<<<%
  EI
	ORG	QPATB

:	>>CONPAT(fba,lba1,len)<<	CONTINUE A PATCH

	KILL	CONPAT
CONPAT	MACRO(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	(clba1)-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	.-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK overflow <<<<$
  EI
	ORG	QPATB

:	>>ENDPATCH(com)<<  End a patch - does error checking, outputs comment

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD CONPATCH(cfba,clba1,clen) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	1
 REMARK <<< c1````c2````c3````c4````c5 >>>
]
]

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD PATCH(day,tim,usr,fba,lba1,len) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	1
 REMARK <<< c1``c2``c3``c4``c5 >>>
]
]

::*********************************************************************
::
::	MACRO:		XRYMSG(MESSAGE)
::	FUNCTION:	FOR PROVIDING AN XRAY WARNING MESSAGE
::	WHERE:
::
::	MESSAGE IS THE DESIRED XRAY WARNING MESSAGE
::	TO BE DISPLAYED TO NEW XRAY USERS WHEN THEY LOG ON.
::	MESSAGE CANNOT CONTAIN COMMAS, DOUBLE QUOTES OR BACKSLASH
::	( ,  "  / )
::
::*********************************************************************

XRYMSG	MACRO(MESSAGE) [
XRYMES	EQ	1		:INDICATE MESSAGE PROVIDED
XRYMS0	MACRO[
	SC	/"0D"0A MESSAGE/
]
]

::*********************************************************************
::
::	MACRO:		GG(PRIVILEGE,XRY-ISIS FLAG,USERNAME,OVERRIDE)
::	FUNCTION:	FOR DEFINITION OF XRAY GOODGUY LIST
::	WHERE :
::
::	PRIVILEGE IS THE USERS PRIVILEGE CAPABILITY
::	0 = NO PRIVILEGE, 1 = PRIVILEGED, 2 = SUPER PRIVILEGED
::
::	XRY-ISIS FLAG, MUST BE ZERO FOR XRAY GOODGUY LIST ENTRIES
::		       USED FOR ISIS GG MACRO COMPATABILITY
:: 
::	USERNAME IS THE VALIDATED USERNAME (FIRST 12(D) CHARACTERS)
::
::	OVERRIDE IS THE OVERRIDE CAPABILITY LEVEL.
::	THE HIGHER NUMBERS CAN OVERRIDE THE LOWER NUMBERS
::
::	THIS MACRO IS INVOKED IN THE TYMFILE WITH THE XGG
::	MACRO DEFINITION NESTING THE GG CALLS OR IN THE
::	GOODGUY FILE WITH THE XGG MACRO DEFINITION. IN EITHER CASE A
::	GOODGUY LIST MUST BE DEFINED WITHIN THE XGG FORMAT.
::	ADDITIONAL CALLS TO GG CAN BE MADE OUTSIDE OF THE XGG FORMAT.
::
::	UP TO 31(D) USERNAMES CAN BE DEFINED AND BY SPECIFYING
::	NO USERNAME (I.E. GG(0,0,,0)) FURTHER INVOKATIONS OF GG
::	WILL HAVE NO EFFECT.  USERNAMES CANNOT CONTAIN ' OR ".
::
::	###OAS
::
::*********************************************************************

XGGCNT	EQ	0		:TO COUNT XRAY ENTRIES

GG	MACRO(PRIV,XISCHK,NAME,OVER) [
	RA	0
	IF	\XISCHK		:IF XISCHK DEFINED
	IF	XISCHK&7FFFFFFF	:AND

:	DO NOTHING FOR ISIS GOODGUY CALLS

	ELSE	:XISCHK&7FFFFFFF		:ZERO, THEN IT'S AN XRAY ENTRY

	IF	1-\GGXKIL	:CHECK FOR PREVIOUS KILL
Q	EQ	.
	AC	/NAME/		:CHECK TO SEE IF NAME IS PRESENT
	IF	.-Q		:ANY STRING? TRUE IF NON-ZERO
	ORG	Q		:RESET PROGRAM COUNTER
        RE      .-Q             :clear the AC
        BC      0
        ER
        ORG     Q               :AC cleared by ####sdw
	IF	1E-XGGCNT	:CHECK FOR TABLE FULL

XGGX|$0XGGCNT|	MACRO[

	IF	PRIV		:LIMIT PRIV PARAMETER TO 0-2
	IF	PRIV-1
	BC	2		:HIGH LIMIT TO 2
	ELSE	:PRIV-1
	BC	1
	EI	:PRIV-1
	ELSE	:PRIV
	BC	0		:LOW LIMIT TO 0
	EI	:PRIV

	BC	OVER	:SET UP OVERRIDE PARAMETER TABLE ENTRY
Q	AC	'NAME'
	ORG	Q+0C		:LIMIT USERNAME TO 12(D) CHARS
]

XGGCNT	EQ	XGGCNT+1	:COUNT UP NUMBER OF ENTRIES
	ELSE	:1E-XGGCNT
	REMARK	%%**************************************************
	REMARK	%Username--
	REMARK	NAME
	REMARK	--not entered, table full
	REMARK	%**************************************************%%
	EI	:1E-XGGCNT
	ELSE	:.-Q		:NO NAME DEFINED, SET KILL FLAG
GGXKIL	EQ	1
	EI	:.-Q
	ELSE	:1-\GGXKIL	:KILL FLAG PREVIOUSLY SET
	REMARK	%%**************************************************
	REMARK	%Username --
	REMARK	NAME
	REMARK	--not entered into xray goodguy list
	REMARK	%**************************************************%%
	EI	:1-\GGXKIL
 	EI	:XISCHK&7FFFFFFF

	ELSE	:\XISCHK	

:	DO NOTHING FOR ISIS GOODGUY CALLS

	EI	:\XISCHK
]

::*********************************************************************
::
::	MACRO:		.SPED.(MATCH,VAL)
::	FUNCTION:	Internal use macro for defining link speeds
::			(invoked from TIILNK, STRLNK)
::	WHERE:
::
::	MATCH:	the (DECIMAL) number to match against.
::
::	VAL:	The value to set KNSPn to.
::
::	KSP:	The link speed entered (to be matched against).
::
::*********************************************************************
.SPED.	MACRO(MATCH,VAL)[
	IF $A 1-(KSP%MATCH)
KNSP|$A N| EQ  $0 VAL
Q	   EQ 0
	EI
	] 

::*********************************************************************
::
::	MACRO:		TIILNK(NEI[,NGR][,WSZ][,SATL][,SPD])
::	FUNCTION:	FOR EASY DEFINITION OF TYMNET-II LINKS
::	WHERE:
::
::	NBR IS THE NEIGHBOR NUMBER (IN OCTAL). NO DEFAULT.
::
::	NGR IS THE NUMBER OF GROUPS ON THE LINK. DEFAULT IS 8.
::
::	WSZ IS THE LINK'S WINDOW SIZE. DEFAULT IS 8.
::
::	SATL IS THE LINK TYPE, SAT OR TER. DEFAULT IS TER.
::
::	KSP IS THE LINK SPEED TO BE REPORTED.
::
::*********************************************************************

TIILNK	MACRO(NBR,NGR,WSZ,SATL,SPD)	[
	KILL N
:	FIND NEXT UNDEFINED LINK FIELDS
Q	EQ	MAXLNK-1
	RE	MAXLNK
	IF	1-\NEI|$AQ|	:THIS NEIGHBOR DEFINED?
N	EQ	Q
	EI	:1-\NEI|$AQ|
Q	EQ	Q-1		:LOOK AT NEXT LINK FIELDS. N WILL BE
:				 ASSIGNED ALL VALUES FROM MAXLNK-1
:				 DOWN TO THE LOWEST UNDEFINED LINK
:				 FIELDS.
	ER

	IF	1-\N		:NO ROOM FOR THIS ONE
:	ALL LINK FIELDS DEFINED. MUST BE TOO MANY....
	REMARK %TOO MANY LINK DESCRIPTORS!%
	EI	:1-\N

:	NOW SET UP LINK FIELDS
QQ	EQ	$8 NBR

	IF	N
:	THE FOLLOWING EXERCISE IS TO PREVENT NAD PASS-2 PROBLEMS
Q	EQ	0
	RE	N
	IF	\NEI|$AQ|
	IF	1-(QQ%NEI|$AQ|)
QQ	EQ	0	:DUPLICATE NEIGHBOR NUMBER... TIILNK SPECIFIED 
:	TWICE FOR SAME NEIGHBOR OR NAD PASS-2.
	EI	:1-(QQ%NEI|$A|)
	EI	:\NEI|$AQ|
Q	EQ	Q+1
	ER
	EI	:N

	IF	QQ
NEI|$AN| EQ	$8 NBR		:NEIGHBOR NUMBER
	IF	$A NGR
NGRP|$AN| EQ	NGR		:NUMBER OF GROUPS SPECIFIED
	ELSE	:NOT $A NGR
NGRP|$AN| EQ	$A 8		:DEFAULT NUMBER OF GROUPS TO 8
	EI	:$A NGR

	IF	$A WSZ
	IF	$A WSZ&3
	REMARK %WSIZ MUST BE MULTIPLE OF 4 - SETTING TO 8 FOR LINK 
	NUMBER $A N
	REMARK  %
WSIZ|$AN| EQ	$A 8
	ELSE	:NOT $A WSZ&3 (WINDOW SIZE SPECIFIED AND MULT. OF 4)
	IF	$A 128-(WSZ-1)	:WSIZ 128 or less			###wjl
WSIZ|$AN| EQ	$A WSZ		:WINDOW SIZE SPECIFIED
	ELSE	:NOT $A 128-(WSZ-1)	WSIZ .GT. 128			###wjl
	REMARK %WSIZ MUST BE 128 OR LESS - SETTING TO 128 FOR LINK 
	NUMBER $A N
	REMARK	%
WSIZ|$AN| EQ	$A 128		:reduce WSIZ to 128			###wjl
	EI	:$A 128-(WSZ-1)						###wjl
	EI	:$A WSZ&3
	ELSE	:NOT $A WSZ
WSIZ|$AN| EQ	$A 8		:DEFAULT WINDOW SIZE TO 8
	EI	:$A WSZ

XSAT    EQ      SATL
	IF	XSAT
KSAT|$AN| EQ	$0 XSAT
	ELSE	:NOT XSAT (DEFAULT VALUE)
KSAT|$AN| EQ	$0 80
	EI	:XSAT

	IF	$8 2000-NEI|$AN|	:IF T-I NEIGHBOR
	IF	WSIZ|$AN|-7		:AND IF WSIZ 8
KSAT|$AN| EQ	KSAT|$AN|+TIWS8		:SET WS8 BIT
	EI
	 EI


KSP	EQ	$A SPD		:VALUE OF SPD ARGUMENT
	IF	KSP
Q	EQ	1		:RESET TO 0 IF VALID SPEED ENCOUNTERED

	.SPED.(31,1F)		: Memory Shuffler Speed

:	ISIS USES 'MS' VALUE IN ITS INIT FILE, SO 'MS' MAY BE DEFINED
:	TO SOMETHING BESIDES THE 1F WHICH WE DECLARE. IF A USER DEFINES A
:	TIILNK WITH MS DEFINED BY ISIS, THE VALUE WILL BE 200 (512d)...
	.SPED.(512,1F)		: Memory Shuffler Speed Kludge

	.SPED.(56,17)		: 56Kb Speed
	.SPED.(48,14)		: 48Kb speed
	.SPED.(38,10)		: 38.4Kb speed
	.SPED.(28,0C)		: 28.8Kb speed

	IF	Q
:	SPEED PARAMETER NOT HEEDED...REPORT
	REMARK %%***LINK SPEED PARAMETER 
	NUMBER $A KSP
	REMARK ---IGNORED FOR LINK 
	NUMBER $A N
	REMARK ***%%
	EI	:Q

:	ONLY HIGH SPEED SPECIFICATIONS ARE DEFINED SINCE LOW SPEED LINE SPEEDS
:	ARE CALCULATED CORRECTLY.  TYMFILE SPEC AFFECTS PROBE LINK AND LINE
:	REPORTS AND XRAY ND DISPLAY...ONLY IF CALCULATED LINE SPEED IS
:	 > 19.2 KBPS.	###OAS	###wjl
:	.SPED.(19,08)		: 19.2Kb speed
:	.SPED.(9,04)		: 9.6Kb speed
:	.SPED.(4,02)		: 4.8Kb speed
:	.SPED.(2,1)		: 2.4Kb speed
:
:
:	IF	Q
:	SPEED PARAMETER NOT VALID...REPORT
:	REMARK %%***SPEED PARAMETER NOT VALID FOR LINK 
:	NUMBER $A N
:	REMARK ***%%
:	EI	:Q
:

	EI	:KSP

	EI	:QQ
	]


	KILL	TYMNET	:REDEFINE ISIS TYMNET MACRO
			: FOR UPWARD COMPATIBILITY

TYMNET	MACRO(A,B,C,D)	[
E	EQ	D*4	:CONVERT NUMBER LINES TO WSIZ
	TIILNK(B,C,E)
	]

::*********************************************************************
::
::	CREATE SYMBOLS FOR DEFINING DEBUG OPTIONS
::
::*********************************************************************

ALL	EQ	$00FFFF	:ENABLE ALL DEBUGGING AND TEST OPTIONS
TRC	EQ	1	:JUMP TRACE WITH UPSW
CIR	EQ	TRC^1	:XRAY DISPLAYS ALL CIRCUITS BUILT AND ZAPPED
TSN	EQ	CIR^1	:TRACE SYNC LINE OPERATIONS
STP	EQ	TSN^1	:STOP ON CRASH (CRSTOP EQ 1 OPTION)
DBG	EQ	STP^1	:ISIS GENERAL DEBUG OPTION
AHSBG^1	:ISIS OPTION
MHS	EQ	AHS^1	:ISIS OPTION
:	SPARE BIT POSITION RESERVED FOR ISIS FUTURE OPTION
BOT	EQ	MHS^2	:STOP ON CRASH AND DON'T UPDATE WATCHDOG TIMER
:                         (CRSTOP EQ 2 OPTION)

BTR	EQ	BOT^1	:PATACHABLE OPTION FOR BUFFER TRACE
DEB	EQ	BTR^1	:GENERAL NODE CODE DEBUG OPTION
BUB	EQ	DEB^1	:BUBB-NET BUBBLE, SHRINK OPTION

:	THE ABOVE OPTIONS REMAIN DEFINED TO PREVENT ASSEMBLY ERRORS SO
:	THAT OBSOLETE DEFINITIONS WILL BE OVERRIDDEN BY DEFAULTS.

:	NODE OPTIONS ARE SPECIFIED WITH THE OPTION MACRO USING SYMBOLS
:	DEFINED HERE...
:	ALL OPTIONS ARE OR'D INTO SYMBOL 'O.FLAG'

	IF	1-\O.FLAG
O.FLAG	EQ	4	:MAKE TLEV OPTION DEFAULT###OAS ???TZ SEE BELOW
	EI	:1-\O.FLAG

UTRC	EQ	1	:UPSW JUMP TRACE OPTION
CIRD	EQ	TRC^1	:CIRCUIT DISPLAY FOR XRAY
TSN	EQ	CIRD^1	:TRACE SYNC/SIO EVENTS
TLEV	EQ	TSN	:NEW SYMBOL FOR TSN
BFTR	EQ	TLEV^1	:BUFFER TRACE
DBUG	EQ	BFTR^1	:GENERAL DEBUG CONSISTENCY TESTS
BUBB	EQ	DBUG^1	:BUB-NET BUBBLE OPTION
NTLV	EQ	BUBB^1	:DISABLE TLEV TRACE OPTION###OAS ???TZ DOES THIS
			:WORK? HOW?
LOPT	EQ	NTLV	:LAST DEFINED OPTION
OALL	EQ	$0 0FFFF	:SET ALL DEBUGGING-TYPE OPTIONS

:	CRASH STOP/RESTART OPTIONS, USES UPPER 16 BITS OF O.FLAG

NRSH	EQ	10000	:NODE RESTART ON HARDWARE CRASH
NRSS	EQ	NRSH^1	:NODE RESTART ON SOFTWARE CRASH
IRSH	EQ	NRSS^1	:ISIS RESTART ON HARDWARE CRASH
IRSS	EQ	IRSH^1	:ISIS RESTART ON SOFTWARE CRASH
NHTH	EQ	IRSS^1	:NODE HALT ON HARDWARE CRASH
NHTS	EQ	NHTH^1	:NODE HALT ON SOFTWARE CRASH
IHTH	EQ	NHTS^1	:ISIS HALT ON HARDWARE CRASH
IHTS	EQ	IHTH^1	:ISIS HALT ON SOFTWARE CRASH
NBTH	EQ	IHTS^1	:NODE GO TO BOOT ON HARDWARE CRASH
NBTS	EQ	NBTH^1	:NODE GO TO BOOT ON SOFTWARE CRASH
IBTH	EQ	NBTS^1	:ISIS GO TO BOOT ON HARDWARE CRASH
IBTS	EQ	IBTH^1	:ISIS GO TO BOOT ON SOFTWARE CRASH
NSTH	EQ	IBTS^1	:NODE STOP ON HARDWARE CRASH
NSTS	EQ	NSTH^1	:NODE STOP ON SOFTWARE CRASH
REBLD	EQ	NSTS^1

::*********************************************************************
::
::	MACRO:		OPTION
::	FUNCTION:	FOR EASY DEFINITION OF DESIRED DEBUG OPTIONS.
::	OPTION MACRO WILL USE VALUES FROM ABOVE SYMBOLS TO BE OR'D INTO
::	O.FLAG, WHICH DEFINES ALL DEBUGGING AND CRASH ACTION OPTIONS.
::
::*********************************************************************

OPTION	MACRO(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16) [
Q1	EQ	P1
Q2	EQ	P2
Q3	EQ	P3
Q4	EQ	P4
Q5	EQ	P5
Q6	EQ	P6
Q7	EQ	P7
Q8	EQ	P8
Q9	EQ	P9
Q10	EQ	P10
Q11	EQ	P11
Q12	EQ	P12
Q13	EQ	P13
Q14	EQ	P14
Q15	EQ	P15
Q16	EQ	P16
Q	EQ	1
	RE	$A 16
O.FLAG	EQ	O.FLAG!Q|$AQ|
Q	EQ	Q+1
	ER
	]

::*********************************************************************
::
::	MACRO:		MERR
::	FUNCTION:	TO DISPLAY MACRO CALL ERROR
::
::*********************************************************************

MERR	MACRO(P1)	[
	!MACRO ERROR!
	REMARK %% P1 %%
	]

::*********************************************************************
::
::	MACRO:		GGHOST
::	FUNCTION:	DEFINES A LIST OF RESTRICTED HOSTS WHICH MAY
::	RUN ON THIS ISIS NODE. IF GGHOST IS NOT DECLARED, ANY HOST MAY COME
::	UP ON THIS NODE.
::		THE SYMBOL 'RESHST' IS DEFINED BY GGHOST, AND INDICATES THE
::	NUMBER OF RESTRICTED HOSTS DECLARED. GGHOST ACCEPTS A MAXIMUM OF 8
::	HOST NUMBERS (IN DECIMAL), AND MAY BE CALLED MULTIPLE TIMES.
::		EACH RESTRICTED HOST NUMBER IS DEFINED BY A SYMBOL GHSTnn,
::	WHERE nn IS A HEX VALUE FROM 0 TO RESHST.
::
::*********************************************************************

GGHOST	MACRO(P1,P2,P3,P4,P5,P6,P7,P8)	[
	IF	1-\RESHST
RESHST	EQ	0		:IF NOT YET DEFINED, INITIALIZE TO ZERO
	EI	:1-\RESHST
Q1	EQ	$A P1
Q2	EQ	$A P2
Q3	EQ	$A P3
Q4	EQ	$A P4
Q5	EQ	$A P5
Q6	EQ	$A P6
Q7	EQ	$A P7
Q8	EQ	$A P8
Q	EQ	1		:PARAMETER COUNT
	RE	$0 8
	IF	Q|$0Q|
GHST|$0RESHST| EQ Q|$0Q|
GCHS|$0RESHST| EQ -1		:NO RESTRICTION ON CIRCUITS/MINUTE
GMHS|$0RESHST| EQ -1		:NO RESTRICTION ON REPORTS/MINUTE
GSHS|$0RESHST| EQ -1		:HOST MAY COME UP ON ANY SLOT
RESHST	EQ	RESHST+1	:AN ADDITIONAL RESTRICTED HOST DEFINED
	EI	:Q|$0Q|
Q	EQ	Q+1
	ER
	]

::*********************************************************************
::
::	MACRO:		HLIMIT(P1,P2,P3)
::	FUNCTION:	DEFINES CIRCUIT AND SLOT REPORT LIMITS BY HOST NUMBER.
::	WHERE:
::
::	P1 IS THE HOST NUMBER, AND IT MUST HAVE BEEN SPECIFIED IN A
::	GGHOST DECLARATION
::
::	P2 IS THE MAXIMUM NUMBER OF CIRCUITS THIS HOST MAY ORIGINATE IN
::	A ONE-MINUTE PERIOD
::
::	P3 IS THE MAXIMUM NUMBER OF SLOT REPORTS THIS HOST MAY GENERATE IN
::	A ONE-MINUTE PERIOD (DEFINED FOR FUTURE DEVELOPMENT. THE NODE CODE
::	CURRENTLY KNOWS ONLY THE ORIGINATING SLOT FOR A SLOT REPORT, NOT THE
::	HOST NUMBER).
::
:: 	THE SYMBOLS DEFINED ARE GCHSnn FOR MAX NUMBER OF CIRCUITS, AND GMHSnn
::	FOR MAX NUMBER OF SLOT REPORTS WHERE nn CORRESPONDS TO SOME GHSTnn FROM
::	A GGHOST MACRO DECLARATION.
::
::*********************************************************************

HLIMIT	MACRO(P1,P2,P3)	[
	IF	1-\RESHST
	MERR(       HLIMIT ERROR:%GGHOST MACRO NOT SPECIFIED FOR HOST P1)
	ELSE	:NOT 1-\RESHST
	IF	1-RESHST
	MERR(       HLIMIT ERROR:%GGHOST MACRO SPECIFIED WITH NO ARGUMENTS FOR HOST P1)
	ELSE	:NOT 1-RESHST
Q	EQ	0		:FOR REPEAT LOOP COUNT
Q1	EQ	$A P1
Q2	EQ	1		:FLAG TO INDICATE HOST NUMBER FOUND
	RE	$0 RESHST
	IF	1-((GHST|$0Q|)%(Q1))
:	(MATCH ON HOST NUMBER)
GCHS|$0Q| EQ	$A P2		:MAX NUMBER CIRCUITS
GMHS|$0Q| EQ	$A P3		:MAX NUMBER REPORTS
Q2	EQ	0		:HOST NUMBER FOUND
	EI	:1-((GHST|$0Q|)%($A P1))
Q	EQ	Q+1
	ER
	IF	Q2
	MERR(       HLIMIT ERROR:%HOST P1 NOT SPECIFIED IN GGHOST)
	EI	:Q2
	EI	:1-RESHST
	EI	:1-\RESHST
	]

::*********************************************************************
::
::	MACRO:		SLIMIT(P1,P2,P3)
::	FUNCTION:	DEFINES THE MAX NUMBER OF CIRCUITS/MINUTE AND
::			SLOT REPORTS/MINUTE BY SLOT.
::	WHERE:
::
::	P1 IS THE SLOT NUMBER (IN DECIMAL)
::
::	P2 IS THE DECIMAL NUMBER OF CIRCUITS/MINUTE
::
::	P3 IS THE NUMBER OF REPORTS/MINUTE.
::
::	THESE GENERATE SYMBOLS SCLTnn FOR MAX CIRCUITS, AND SMLTnn FOR REPORTS,
::	WHERE nn IS THE HEX SLOT NUMBER.
::
::*********************************************************************

SLIMIT	MACRO(P1,P2,P3)	[
Q1	EQ	$A P1
X2	EQ	1`P2
X3	EQ	1`P3
	IF	2-X2
:	SECOND ARGUMENT NULL
	ELSE	:NOT 2-X2
SCLT|$0Q1| EQ	$A P2		:MAX NUMBER OF CIRCUITS/MINUTE FOR THIS SLOT
	EI	:2-X2
	IF	2-X3
:	THIRD ARGUMENT NULL
	ELSE	:NOT 2-X3
SMLT|$0Q1| EQ	$A P3		:MAX # OF SLOT REPORTS/MINUTE FOR THIS SLOT
	EI	:2-X3
	]

::*********************************************************************
::
::	MACRO:		HSTSLT(P1,P2,P3,P4,P5,P6,P7,P8,P9)
::	FUNCTION:	DEFINES RESTRICTIONS ON WHICH SLOT(S) A
::			RESTRICTED HOST MAY COME UP ON.
::	WHERE:
::
::	P1 IDENTIFIES THE DECIMAL HOST NUMBER
::
::	P2-P9 UP TO EIGHT DECIMAL SLOT NUMBERS MAY BE SPECIFIED.
::
::	THE GGHOST MACRO INITIALIZES THE FIELD 'GSHSnn' TO FFFFFFFF.
::	THE HSTSLT MACRO TURNS OFF ALL BITS IN GSHSnn, THEN TURNS ON THE BITS
::	WHICH CORRESPOND TO THE SLOT NUMBERS SPECIFIED BY P2-P9.
::
::*********************************************************************

HSTSLT	MACRO(P1,P2,P3,P4,P5,P6,P7,P8,P9)	[
	IF	1-\RESHST
	MERR(       HSTSLT ERROR:%GGHOST MACRO NOT SPECIFIED FOR HOST P1)
	ELSE	:NOT 1-\RESHST
	IF	1-RESHST
	MERR(       HSTSLT ERROR:%GGHOST MACRO SPECIFIED WITH NO ARGUMENTS FOR HOST P1)
	ELSE	:NOT 1-RESHST
Q	EQ	0		:FOR REPEAT LOOP COUNT
Q1	EQ	$A P1
Q2	EQ	1		:FLAG TO INDICATE HOST NUMBER FOUND
	RE	$0 RESHST
	IF	1-((GHST|$0Q|)%(Q1))
:	(MATCH ON HOST NUMBER)
Q2	EQ	0		:INDICATE HOST NUMBER FOUND
X2	EQ	$A P2
X3	EQ	$A P3
X4	EQ	$A P4
X5	EQ	$A P5
X6	EQ	$A P6
X7	EQ	$A P7
X8	EQ	$A P8
X9	EQ	$A P9
GSHS|$0Q| EQ	0		:INITIALIZE TO HOST VALID ON NO SLOTS
Q0	EQ	2		:COUNTER FOR SCANNING PARAMETERS
	RE	$0 8
X	EQ	$0 80000000	:BIT POSITION WILL EQUAL SPECIFIED SLOT NUMBER
	IF	X|$0Q0|
	RE	X|$0Q0|
X	EQ	X^-1		:SLIDE BIT OVER TO SLOT NUMBER POSITION
	ER
GSHS|$0Q| EQ	GSHS|$0Q|!X	:TURN ON BIT IN GSHSnn
	EI	:X|$0Q0|
Q0	EQ	Q0+1
	ER
	IF	1-(GSHS|$0Q|)
	MERR(        HSTSLT ERROR:%NO SLOTS SPECIFIED FOR HOST P1)
	EI	:1-(GSHS|$0Q|)
	EI	:1-((GHST|$0Q|)%(Q1))
Q	EQ	Q+1
	ER
	IF	Q2
	MERR(        HSTSLT ERROR:%HOST P1 NOT SPECIFIED IN GGHOST)
	EI	:Q2
	EI	:1-RESHST
	EI	:1-\RESHST
	]

::*********************************************************************
::
::	MACRO:		JALMAC:
::	FUNCTION:	DOES JAL Rx,NAME BASED ON EQUATED VALUE OF Rx
::
::*********************************************************************

JALMAC	MACRO(NAME)	[
:	KEEP THIS LIST IN ALPHABETICAL ORDER TO MAKE DUPLICATES EASY TO 
:	IDENTIFY AND AVOID.
:??	KILL	Q`NAME		:MAKE SURE NOT DEFINED ELSEWHERE
QCPUTCP	EQ	0A
QCPUTIZ	EQ	1
QTYPAS1	EQ	7
QTYPASC	EQ	7
QTYPASI	EQ	7
QTYPCRL	EQ	7

	IF	\Q`NAME		:IF WE HAVE AN ENTRY FOR THIS NAME
JALREG	EQ	Q`NAME
	JAL	JALREG,NAME,,
	ELSE	:NAME NOT IN LIST
	REMARK	%JALMAC ERROR SYMBOL NOT DEFINED%
	EI	:\Q`NAME
	]

::*********************************************************************
::
::	DUMMY DEFINITIONS FOR SYMBOLS AND MACROS LIKELY TO APPEAR IN AN
::	ISIS TYMFILE. PREVENTS ASSEMBLY ERRORS...
::
::*********************************************************************

SYN	EQ	0
ASN	EQ	0
PRN	EQ	0
XSIO	EQ	0
M.CARD	EQ	0
TL.AUX	EQ	80000000
TL.SUS	EQ	1
DK	EQ	0
MT	EQ	0
:MS	EQ	0
RD	EQ	0
WR	EQ	0
AT	EQ	0
SS	EQ	0
S.REF	MACRO(P) [ ]
A.REF	MACRO(P) [ ]
P.REF	MACRO(P) [ ]
T.REF	MACRO(P) [ ]            :###sdw
IP.REF	MACRO(P) [ ]            :###sdw
X.REF	MACRO(P) [ ]
M.REF	MACRO(P) [ ]
SGU.DEF	MACRO(P) [ ]
SGU.REF	MACRO(P) [ ]
BITCH	MACRO(P) [ ]		:###OAS
SYSCHK	MACRO(P) [ ]		:###OAS
DEFEXT	MACRO(P) [ ]		:###OAS

::*********************************************************************
::
::	MACRO:		BAUD
::	FUNCTION:	DEFINE SYMBOL BAUDR FOR CONSAT (ISIS COMPATABLE)###OAS
::
::*********************************************************************

BR1200	EQ	0
BR4800	EQ	2

BAUD	MACRO(RATE) [
BAUDR	EQ	RATE
]

	SUBTTL	TIIINT (MACRO Defintions)

::*********************************************************************
::
::	Macro's are listed in alphabetical order.  Some of them are
::	are redefined (same function) by the CONSAT init file if it is
::	assembled.
::
::*********************************************************************

	KILL	TRUTH0
TRUTH1 EQ 0

.LT0.	MACRO(ARG)[\(TRUTH|((ARG)^(-1F))|)]
.GE0.	MACRO(ARG)[(1-(.LT0.(ARG)))]
.LE0.	MACRO(ARG)[((1-(.GE0.(ARG)))!(1-((ARG)/(ARG))))]
.EQ0.	MACRO(ARG)[(1-((ARG)/(ARG)))]
.GT0.	MACRO(ARG)[(1-(.LE0.(ARG)))]
.NE0.	MACRO(ARG)[((ARG)/(ARG))]
.NOT.	MACRO(ARG)[(.LE0.(ARG))]
.TRU.	MACRO(ARG)[(.GT0.(ARG))]
.OR.	MACRO(ARG1,ARG2)[((.TRU.(ARG1))!(.TRU.(ARG2)))]
.AND.	MACRO(ARG)[!(ARG)]
.XOR.	MACRO(ARG1,ARG2)[((.TRU.(ARG1))%(.TRU.(ARG2)))]
.ABS.	MACRO(ARG)[(((ARG)%((-1)*(.LT0.(ARG))))+(1*(.LT0.(ARG))))]
.EQ.	MACRO(ARG1,ARG2)[((((ARG1)/(ARG2))*((ARG2)/(ARG1)))!(.EQ0.((ARG1)!(ARG2))))]
.NEQ.	MACRO(ARG1,ARG2)[(1-(.EQ.(ARG1,ARG2)))]
.FLS.	MACRO(ARG)[(.LE0.(ARG))]

::*********************************************************************
::
::	MACRO:		KILLER:
::	FUNCTION:	Causes assembly to abort if argument is false
::
::*********************************************************************

KILLER	MACRO(COND)	[
QKILL	EQ	KILLIT		:preserve previous value of KILLIT
	IF	COND		:if CONDition is true, kill assembly
KILLIT	EQ	1
	ELSE	:
KILLIT	EQ	0		:else allow assembly to continue
	EI	:COND
KILLIT	EQ	KILLIT!QKILL	:add previous state of KILLIT
	]

::*********************************************************************
::
::	MACRO:		KILMSG:
::	FUNCTION:	Kill Message
::
::*********************************************************************

KILMSG	MACRO(NAME)	[
 IF	1-(KILLIT%1)		:only if KILLIT=1
	REMARK	
	REMARK	%Assembly killed due to fatal error in 
	REMARK	NAME
	REMARK	%
KILLIT	EQ	KILLIT+1
 EI	:1-(KILLIT%1)
	]

::*********************************************************************
::
::	MACRO:		SETMAC:
::	FUNCTION:	Macro defines MAC registers
::	WHERE:
::		Arg1 ('SEG') = segment number 
::		Arg2 ('PROT') = protection byte
::
::*********************************************************************

SETMAC	MACRO(SEG,PROT)	[
	IF	S|SEG|SZ
AXMAC|SEG| EQ (S|SEG|SZ-100)^0C+S|SEG|PH+PROT
	ELSE	:NOT S|SEG|SZ (NO SEGMENT PRESENT)
AXMAC|SEG| EQ 0
	EI	:S|SEG|SZ
	]

::*********************************************************************
::
::	MACRO:		CS.
::	FUNCTION:	CONSAT MACRO
::
::*********************************************************************

CS.	MACRO(SYMBL)[SYMBL+CSBASE]

::*********************************************************************
::
::	MACRO:		GETPTP
::
::*********************************************************************
GETPTP	MACRO(DESTR,XR1,XR2)[
	LHL	DESTR,.PTP.,XR1,XR2
	AI	DESTR,PTBASE
	]
::*********************************************************************
::
::	MACRO:		SYAD:
::	FUNCTION:	Macro creates a macro to be used in setting up the
::			XRAY symbol table.
::
::*********************************************************************

SYAD	MACRO(P1,TT)	[
	IF	1-\P1		:if symbol not defined, issue warning
	REMARK	%!!! SYAD macro error - undefined symbol = P1 !!!%
	ELSE	:P1 defined, continue
SYAD|$0NSYMBL| MACRO[
QQ	EQ	.
	SC	/P1:/
:QQ	EQ	.-QQ-8 		:COMPUTE SYMBOL NAME LENGTH ##AL ##KOPFJ
:	IF	QQ		
	IF	(.-QQ)%8	:make sure symbol name is legal length
	REMARK	%Illegal symbol name length to SYMADR macro!!!%
	REMARK	Symbol name = P1%
	KILLER(1)
:	ELSE	:-QQ		:IF NAME TOO SHORT
:	RE	-QQ
:	AC	/ /		:PAD OUT WITH SPACE
:	ER
:	EI	:QQ
	EI	:(.-QQ)%8
	WC	P1
	]
NSYMBL	EQ	NSYMBL+1
	EI	:1-\P1
	]

::*********************************************************************
::
::	MACRO:		SETRAD:
::	FUNCTION:	Macro sets radix to specified value, and sets 'CURRAD'
::			to that value.
::
::*********************************************************************

SETRAD	MACRO(RDX)[
CURRAD	EQ	RDX
	RA	$0 RDX
	]

::*********************************************************************
::
::	MACRO:		DEFASC:
::	FUNCTION:	Macro defines an ascii CRYPTO message string. Accepts
::		up to 4 pairs of arguments.
::		Sx = ascii string 
::		Vx = format code (BH=byte hex, BD=byte decimal,	BO=byte octal,
::		     HH=hw hex,	HD=hw decimal, HO=hw octal, O5=five dig octal)
::		Each Sx argument must be followed immediately by a valid
::		Vx argument.  An Sx argument may be omitted (null) to
::		produced concatenated Vx arguments.)
::
::*********************************************************************

DEFASC	MACRO(S1,V1,S2,V2,S3,V3,S4,V4) [
	SC	/S1/
	HC	V1
	SC	/S2/
	HC	V2
	SC	/S3/
	HC	V3
	SC	/S4/
	HC	V4
	]

::*********************************************************************
::
::	MACRO:		CPUTNM:
::	FUNCTION:	MACRO DEFINES A ROUTINE NAME ENTRY IN CPUTLB. DEFINES
::		A HW CONSTANT WHEN CALLED = ROUTINE'S INDEX INTO CPUTTB.
::
::*********************************************************************

CPUTNM	MACRO(NAME)	[
	IF	CPUTMX-CPUTNE	:IF THERE IS ROOM
QPLACE	EQ	.		:NOTE WHERE WE ARE
	ORG	CPUTLB+(7*CPUTNE):GO TO FIRST AVAILABLE TABLE ENTRY - ENTRY
				:LENGTH IS 6 CHARACTERS + 1 BYTE OF LENGTH
	SC	/NAME/
	ORG	QPLACE
	HC	CPUTNE*CPUTSZ	:THIS ROUTINE'S INDEX INTO CPUTTB
CPUTNE	EQ	CPUTNE+1	:WE'VE MADE ANOTHER ENTRYA
	ELSE	:CPUTNE>=CPUTMX
	REMARK	%!!! CPUTNM MACRO ERROR !!!
	REMARK	%NOT ENOUGH ROOM FOR NEXT CPUTLB ENTRY -
	REMARK	%MUST INCREASE CPUTMX%
KILLIT	EQ	1		:KILL ASSEMBLY
	EI	:CPUTMX-CPUTNE
	]

::*********************************************************************
::
::	MACRO:		CODFLT:
::	FUNCTION:	Crash Option DeFauLT macro sets the symbol C.<P1> to 1
::		if the option is true, else sets it to 0.  The mnemonic
::		value 'abbc' of P1 is based on the common crash action
::		definitions, where 'a'  is 'N' for 'Node code'
::				   'bb' is 'RS' for 'ReStart', or
::					   'HT' for 'HalT', or
::					   'BT' for 'BooT', or
::					   'ST' for 'STop'
::				   'c'  is 'S' for 'Software' crash, or
::					   'H' for 'Hardware' crash.
::
::*********************************************************************

CODFLT	MACRO(P1) [
	IF	O.FLAG&P1
C.`P1	EQ	1
	ELSE
C.`P1	EQ	0
	EI	:O.FLAG&P1
	]

::*********************************************************************
::
::	MACRO:		DBOOPS:
::	FUNCTION:	Macro, under the DB.DEB switch, stores all reggies at
::		ERRREG, and sets up an RX3 JAL to OOPSDB, followed by
::		an HC crash code of FE63.  Takes up 12d bytes, so
::		jumping around it means JaaFS .+0E.
::
::*********************************************************************

DBOOPS	MACRO	[
	IF	DB.DEB
	STM	R0,ERRREG
	JAL	R0,OOPS,,
	HC	0		:Debug crash code is first in the list.
	EI
	]

::*********************************************************************
::
::	MACRO:		DEFAULT:
::	FUNCTION:	Macro sets a symbol to a specified value if it has
::		 not already been defined.
::
::*********************************************************************

	KILL DEFAULT	:BECAUSE CONSAT INIT FILE DEFINES IDENTICAL MACRO
DEFAULT	MACRO(ID,V)[
	IF	1-\ID
ID	EQ	V
	EI
]

::*********************************************************************
::
::	MACRO:		USRLOC:
::	FUNCTION:	Macro is handy for pin-pointing macro errors.
::
::*********************************************************************

USRLOC	MACRO	[
	REMARK	user location  
	NUMBER	.
	REMARK	
	]

::*********************************************************************
::
::	MACRO:		CRASH:
::	FUNCTION:	CRASH MACRO
::	CRASH MACRO REQUIRES 2 ARG'S (CRASH CODE AND CRASH CODE SUBTYE) AND
::	WILL ACCEPT UP TO 2 MORE (NUMBERS OF REGISTERS WHOSE CONTENTS ARE
::	TO BE REPORTED IN ADDENDA TO THE CRASH REPORT -- THESE MAY BE LINK
::	REGISTERS OR DATA REGISTERS AS APPROPRIATE).
::	CCODE - MUST BE A VALID COMMON CRASH CODE (SEE BELOW)
::	STYPE - IF CCODE = 42, STYPE MUST BE ONE OF THE FOLLOWING
::		INSTRUCTION MNEMONICS: JFFO, JFFOH, ARAND ...
::		IF CCODE = 67, STYPE MUST BE 2*(SVC NUMBER),
::		WHERE SVC NUMBER IS 1 BYTE (FOR ISIS, TYPE/OP;
::		FOR SOLO, 0n).
::		IF CCODE = 63, STYPE IS AN ARBITRARY EVEN NUMBER
::		WITHIN A RANGE SPECIFIED FOR EACH MODULE AS FOLLOW:
::			EXEC: 02-0E
::			LINKER: 
::
::	CRASH.:	Macro stores all reggies at ERRREG and does a JAL R0,OOPS.
::		Argument CRLBL is required - it is an arbitrary symbol name
::		which must be used in a corresponding DFCRH. macro.  The
::		DFCRH. macro should be invoked at the beginning of the
::		module in which the corresponding CRASH. macro is invoked.
::		The DFCRH. macro must be invoked unconditionally -- i.e.,
::		not under any IF switches (except 1-KILLIT).  The DFCRH.
::		macro equates CRLBL to the index into CRCDTB (CRash CoDe
::		TaBle) for the appropriate crash code.  The CRASH. macro
::		assembles this value as a HC immediately following the
::		JAL R0,OOPS.
::		CRASH.(CRLBL) assembles as:
::			STM	R0,ERRREG
::			JAL	R0,OOPS,,
::			HC	CRLBL
::
::*********************************************************************

CRASH.	MACRO(CRLBL)[
	IF	1-\CRLBL
	REMARK	%!!! CRASH. macro error !!!
	REMARK	%Crash reference lable CRLBL undefined.
	REMARK	%Killing assembly at 
	USRLOC
	KILLER(1)
	ELSE
	STM	R0,ERRREG
	JAL	R0,OOPS,,
	HC	CRLBL
	EI	:1-\CRLBL
	]

::*********************************************************************
::
::	MACRO:		DFCCD.(NAME,CODE,STREQ)
::	FUNCTION:	DeFine Crash CoDe sets up the crash code parameters
::		used by the DFCRH. macro.
::	WHERE:
::		NAME is a mnemonic for a valid crash type.  Only crash types
::		which involve a call to OOPS are defined.
::
::		CODE is the numeric crash code.
::
::		STREQ defines whether a crash subtype is required (STREQ=1)
::		or not (STREQ=0) in the DFCRH. macro.
::
::*********************************************************************

	KILL	CCDER.
::		This MACRO is used exclusively for DFCCD.  It is defined
::	seperately to avoid recurring overhead in NAD which would occur
::	if it were KILL'ed and redeclared at each invocation.
CCDER.	MACRO(TEXT)[
	REMARK	%!!! DFCCD. macro error !!!
	CRLF.
	REMARK	TEXT
	CRLF.
	REMARK	Killing assembly....
	KILLER(1)
	CRLF.
	]

DFCCD.	MACRO(NAME,CODE,STREQ)[
	IF	\NAME
	CCDER.(Mnemonic NAME already defined.)
	ELSE
.NCC|CODE| EQ	0	:Initialize count of subtypes
CST.|CODE| EQ	STREQ	:1 if subtype must be specified, else 0
CT.|CODE| EQ	CODE	:Used by DFCRH macro
NAME	EQ	CODE	:Define a mnemonic
	EI
	]

	DFCCD.(C.INML,42,0)
	DFCCD.(C.ILSV,60,1)
	DFCCD.(C.HWCE,62,0)
	DFCCD.(C.SWCE,63,0)
	DFCCD.(C.GCEB,64,0)
	DFCCD.(C.GCIB,65,0)
	DFCCD.(C.IFLP,66,0)
	DFCCD.(C.SVER,67,1)

ARAND	EQ	2
JFFO	EQ	4
JFFOH	EQ	6

LINE.	MACRO(N)[
	REMARK	%LINE NUMBER 
	NUMBER	N
	REMARK	%
	]


.NCCD	EQ	0

::*********************************************************************
::
::	MACRO:		DFCRH.(CRLBL,CTYPE,STYPE,CRHCOM)
::	FUNCTION:	DeFine Crash Code ?H? verifys the crash code parameters
::	WHERE:
::		CRLBL is a mnemonic for this crash type/subtype.
::
::		CTYPE is the numeric crash code.

::		STYPE is the numeric crash code Subtype.
::
::		CRHCOM is the associated text-string.
::
::*********************************************************************

:	Define a macro CRHER. to display error messages.
::		This MACRO is used exclusively for DFCRH.  It is defined
::	seperately to avoid recurring overhead in NAD which would occur
::	if it were KILL'ed and redeclared at each invocation.
	KILL	CRHER.
CRHER.	MACRO(TYPE,STAT,TEXT)[
.GO	EQ	0
.KILL	EQ	1
	REMARK	%!!! DFCRH. macro error !!!
	REMARK	%At 
	USRLOC
	REMARK	%Crash code TYPE 
	REMARK	%TEXT
	IF	STAT
	REMARK	%Killing assembly....%
	KILLER(1)
.DOIT	EQ	0
	ELSE	
	REMARK	%Assembly continues....%
.DOIT	EQ	1
	EI
	]

DFCRH.	MACRO(CRLBL,CTYPE,STYPE,CRHCOM)[HS	0

:	Define macro's which tell whether arguments were entered.
	KILL	CTDEF.,STDEF.,CTVAL.,STREQ.,STVAL.
STREQ.	MACRO[(CST.|CTYPE|)]	:1 if STYPE required, else 0
CTDEF.	MACRO[(1-\QQQ.)]	:1 if CTYPE entered, else 0
CTVAL.	MACRO[((\CT.|QCT.|)&(CTDEF.))]	:1 if CTYPE valid, else 0
STDEF.	MACRO[(1-\QQ.0)]		:1 if STYPE entered, else 0
:COMDF.	MACRO[(1-\Q.)]		:1 if CRHCOM entered, else 0
STVAL.	MACRO[(STDEF.&(1-(STYPE&1)))]:1 if STYPE given and even

	KILL	Q.,QQ.0,QQQ.,.DOIT
:Q.`CRHCOM EQ	0
:QQ.`STYPE EQ	0
QQ.|STYPE| EQ	0
QQQ.`CTYPE EQ	0


.DOIT	EQ	1

 IF	1-CTDEF.	:No CTYPE provided
	CRHER.(CTYPE,.KILL,must be provided.)
 ELSE	:not 1-CTDEF.
QCT.	EQ	CTYPE
 EI	:(not)1-CTDEF.

 IF	.DOIT
  IF	1-CTVAL.	:Invalid CTYPE
	CRHER.(CTYPE,.KILL,is not valid.)
  EI	:1-CTVAL.
 EI	:.DOIT

 IF	.DOIT
  IF	(STREQ.)&(1-STDEF.) :If subtype required and not provided
	CRHER.(CTYPE,.KILL,requires explicit subtype declaration.)
  EI	:(STREQ.)&(1-STDEF.)
 EI	:.DOIT

 IF	.DOIT
  IF	STDEF.&(1-STREQ.) :If subtype given and not allowed
	CRHER.(CTYPE,.GO,rejects explicit subtype declaration.%Subtype will be computed.)
QQ.0	EQ	0
  EI	:STDEF.&(1-STREQ.)
 EI	:.DOIT

 IF	.DOIT
  IF	(STREQ.&STDEF.)
   IF	STYPE&1
	CRHER.(CTYPE,.KILL,requires even subtype code.)
   ELSE	:not STYPE&1
QST.	EQ	STYPE
   EI	:(not)STYPE&1
  EI	:(STREQ.&STDEF.)
 EI	:.DOIT

 IF	.DOIT
  IF	1-STDEF.	:STYPE computed
.NCC|QCT.| EQ	.NCC|QCT.|+2
QST.	EQ	.NCC|QCT.|
  EI	:1-STDEF.
 EI	:.DOIT

 IF	.DOIT
  IF	\C.|((QST.)^8)+(QCT.)|
	KILL	CRLBL
QN.	EQ	1
	RE	.NCCD
   IF	(((CST.|QN.|)^8)+(CT.|QN.|))%(((QST.)^8)+(QCT.))
CRLBL	EQ	QN.*2
   EI	:(((CST.|QN.|)^8)+(CT.|QN.|))%(((QST.)^8)+(QCT.))
QN.	EQ	QN.+1
	ER
  ELSE	:not \C.|((QST.)^8)+(QCT.)|
.NCCD	EQ	.NCCD+1
CT.|.NCCD| EQ	QCT.
CST.|.NCCD| EQ	QST.
DFC.|.NCCD| MACRO(.T.,.S.)[
	HC	(.S.^8)+(.T.)
   IF	CRHRMK
	REMARK	%Crash code 
	NUMBER	(.S.^8)+(.T.)
	REMARK	%CRHCOM
	REMARK	%
   EI	:CRHRMK
	]
CRLBL	EQ	.NCCD*2
C.|((QST.)^8)+(QCT.)| EQ ((QST.)^8)+(QCT.) 
  EI	:(not) \C.|((QST.)^8)+(QCT.)|
 EI	:.DOIT
	]

::*********************************************************************
::
::	MACRO:		SYMREF:
::	FUNCTION:	Macro makes a REFerence entry in the SYMbol
::		definition table (for ISIS parameter verification).
::		It increments NREF with each call.
::
::*********************************************************************

SYMREF  MACRO(SYM,BITS,MIN,MAX) [
	IF	1-\NREF
NREF	EQ	0		:INITIAL VALUE
	EI	:1-\NREF
Q       HS      0
        AC      /SYM/
        IF      Q+6-.
        RE      Q+6-.
        BC      20
        ER
        ELSE
        ORG     Q+6
        EI
        HC      BITS
        HC      MIN
        HC      MAX
NREF    EQ      NREF+1
]

::*********************************************************************
::
::	MACRO:		SYMDEF:
::	FUNCTION:	Macro DEFines and entry in the SYMbol definition
::		table, and increments NDEF with each call. (For
::		ISIS parameter verification.)
::
::*********************************************************************

SYMDEF  MACRO(SYM) [
	IF	1-\NDEF
NDEF	EQ	0		:INITIAL VALUE
	EI	:1-\NDEF
Q       HS      0
        AC      /SYM/
        IF      Q+6-.
        RE      Q+6-.
        BC      20
        ER
        ELSE
        ORG     Q+6
        EI
        HC      SYM
NDEF    EQ      NDEF+1
]

VS	MACRO(SYMBL)[
	IF	(\SYMBL)
	REMARK	%!!!Duplicate definition for SYMBL at 
	USRLOC
	REMARK	 with value of 
	NUMBER	$0 SYMBL
	REMARK	 hex.%
	ELSE
SYMBL	MACRO[77777]
	KILL SYMBL
	EI	:(\SYMBL)
	]

::*********************************************************************
::
::	MACRO:		GLOBAL:
::	FUNCTION:	Macro globalizes a symbol and sets it to a specified
::			value if it has not already been defined.
::
::*********************************************************************

	KILL GLOBAL	:CONSAT INIT FILE DEFINES IDENTICAL MACRO
GLOBAL	MACRO(ID,V)[
	GL	ID
	DEFAULT(ID,V)
	]

::*********************************************************************
::
::	MACRO:		QUADWD(A1,A2,A3,A4,A5):
::	FUNCTION:	Create a Quad-word ring descriptor
::	Where:
::		A1 -	Command
::		A2 -	Quad-word address
::		A3 -	??? (rel to segment)
::		A4 -	??? (rel to segment)
::		A5 -	Segment #
::
::*********************************************************************

QUADWD	MACRO(A1,A2,A3,A4,A5) [	:CREATE A QUADWORD RING DESCRIPTOR
	HC	A1,A2
	IF	A5-4
:	SEG 5 FIELD
	WC	A3-SEG5+S5PH,A4-SEG5+S5PH,SIRDEN
	ELSE	:NOT A5-4 (SEG 4 FIELD)
	WC	A3-SEG4+S4PH,A4-SEG4+S4PH,SIRDEN
	EI	:A5-4
SIRDEN	EQ	SIRDEN+1
	]

::*********************************************************************
::
::	MACRO:		NEGTST:
::	FUNCTION:	DB.DEB DEBUGGING MACRO TO INSURE NEGATIVE RING POINTER
::	WHERE:		INSTR = INSTRUCTION MNEMONIC
::			MR1 = REGISTER TO BE LOADED
::			LBL = LABEL
::			OFF = CONSTANT OFFSET FROM LABEL
::			MR2 = INDEX REGISTER
::			MR3 = INDEX REGISTER
::
::*********************************************************************

NEGTST	MACRO(INSTR,MR1,LBL,OFF,MR2,MR3)	[
	IF	DB.DEB
	IF	\LBL
	INSTR	MR1,LBL+OFF,MR2,MR3
	JLFS	.+0A
	JAL	R0,OOPS,,
	HC	0FE63
	EI	:\LBL
	EI	:DB.DEB
	]

::*********************************************************************
::
::	MACRO:		CFGRMK:
::	FUNCTION:	Macro invoked by CONFIG module, describes state of
::			specified assembly switch.
::
::*********************************************************************

CFGRMK	MACRO(SYMBOL)	[
 IF	\SYMBOL
  IF	SYMBOL	:true
	REMARK	 true      
  ELSE	:false
	REMARK	 false     
  EI	:SYMBOL
 ELSE	:symbol not defined
	REMARK	 undefined 
 EI	:\SYMBOL
 IF	(NCFRMK&3)-2		:put a cr/lf after every 4
	REMARK	%
 EI	:
NCFRMK	EQ	NCFRMK+1
	]

::*********************************************************************
::
::	MACRO:		NMBR.:
::	FUNCTION:
::		Macro NMBR.(<symbol>,<radix code>,<field width>) displays
::		a number (the value of <symbol>), in the specified radix
::		(valid codes are, a la NAD, 2, 8, A, and 0), right-justified
::		in a field of the specified width (in number of digits),
::		followed by a radix indicator ('b', 'o', 'd', or 'x') and
::		a blank (unless <field width>=0, in which case, this macro
::		does exactly the same thing as NUMBER $<radix code> <symbol>).
::		If the value of <symbol> cannot be displayed in the speci-
::		fied field width, the number is displayed without attempting
::		to right-justify it within a field.
::
::*********************************************************************

NMBR.	MACRO(VAL,RADX,WDTH)[
	KILL	Q.
Q.`WDTH`Q	EQ	0
	IF	\Q.Q
QW	EQ	0
	ELSE	:
QW	EQ	WDTH
	EI	:
BASE0	EQ	10
BASE8	EQ	8
BASEA	EQ	0A
BASE2	EQ	2

QND	EQ	1
QMXN	EQ	BASE`RADX
	RE	QW
	IF	1-(QMXN-VAL)
QND	EQ	QND+1
QMXN	EQ	QMXN*(BASE`RADX)
	EI
	ER
QNB	EQ	QW-QND
QRADX	EQ	0`RADX
	IF	1-QRADX
	IF	((0A^((QND-1)*4))-(VAL))
	ELSE
QNB	EQ	QNB-1
	EI
	EI	:1-QRADX
	IF	QNB
	RE	QNB
	BLANK.
	ER
	EI	:QNB
	NUMBER	$RADX(VAL)
	TAIL`RADX`.
	]
BLANK.	MACRO[REMARK	 ]

TAIL0.	MACRO[REMARK x ]
TAILA.	MACRO[REMARK d ]
TAIL8.	MACRO[REMARK o ]
TAIL2.	MACRO[REMARK b ]

CRLF.	MACRO(COUNT)[
QCT	EQ	0`COUNT
	RE	QCT
	REMARK	%
	ER
	]

TAB.	MACRO(COUNT)[
QCT	EQ	0`COUNT
	RE	QCT
	REMARK		
	ER
	]

::*********************************************************************
::
::	MACRO:		DFST.:	
::	FUNCTION:
::
::*********************************************************************

.BS.	EQ	0
.HS.	EQ	1
.WS.	EQ	3

DFST.	MACRO(OP,VAL,BAS)[EQ (.-BAS+(1*(.`OP`.)))&(0FFFFFFFF-(.`OP`.))
QBASE	EQ	BAS
	IF	(-(.-QBASE))!((.^(-10))%(QBASE^(-10)))
	REMARK	%!!! DFST. macro error at 
	USRLOC 
	REMARK	!!!
	REMARK	%Cannot define SYMBL at 
	USRLOC
	REMARK	%in this segment.  Must be in segment 
	NUMBER	(QBASE^(-10))
	REMARK	.%
	KILLER(1)
	ELSE
	OP	VAL
	EI
	]
	

Q	EQ	0
	RE	10
.SEG|Q|P EQ	Q^10
Q	EQ	Q+1
	ER

BEGMO.	MACRO[
.Q	EQ	0
	RE	10
	IF	\SEG|.Q|
	SEG	.Q
.SEG|.Q|P EQ	.
	EI	:\SEG|.Q|
.Q	EQ	.Q+1
	ER
	]

ENDMO.	MACRO(NAME)[
	IF	MEMRMK-2
	REMARK	%Segment utilization for NAME:
.Q	EQ	0
	RE	10
	IF	\SEG|.Q|
	SEG	.Q
	IF	.-.SEG|.Q|P
	REMARK	%Segment 
	NMBR.(.Q,A,2)
	REMARK	from 
	NMBR.(.SEG|.Q|P,0,6)
	REMARK	to 
	NMBR.(.,0,6)
	REMARK	= 
	NMBR.((.-.SEG|.Q|P),0,6)
	REMARK	bytes.
	EI	:.-.SEG|.Q|P
	EI	:\SEG|.Q|
.Q	EQ	.Q+1
	ER
	CRLF.
	EI	:MEMRMK-2
	]

SEG.	MACRO(ARG)[
	SEG	ARG
	]

CSB.	MACRO(SYMBL)[(SYMBL+CSBASE)]

GL.	MACRO[ GL]
KILL.	MACRO[ KILL]
LO.	MACRO[ LO]

::*	Define and globalize some symbols

	GLOBAL(A.DATA,0A)	:consat wants seg 0 identified this way
	GLOBAL(A.CODE,1)	:consat wants seg 1 identified this way

::*********************************************************************
::
::	MACRO:		HSIZE(REG)
::	FUNCTION:	Calculates history buffer size (7FFF max)
::		based on number of links, CQNLK, and backpressure limit
::		from CIRSPK table.  Limit is thought to be B*(2*N-1)
::	WHERE:		REG is a working register which is set up initially
::		containing needle flags and is destroyed.  R0 is returned
::		with the history buffer size.
::
::*********************************************************************

HSIZE	MACRO(REG)[
	SRHLS	REG,3
	NHI	REG,6
	LHL	R0,CIRSPK,REG
	AR	R0,R0
	MH	R0,CQNLK
	SH	R0,CIRSPK,REG
	LHR	R0,R0
	JGEFS	.+6
	LHI	R0,7FFF]


::*********************************************************************
::
::	MACRO:		DBCRY.(COND,REG1,REG2)
::	FUNCTION:	Debugging CRYPTO option.  If COND true, then
::			genrate call to CRYPTO.
::	WHERE:
::		COND -	If exists, and is TRUE, causes code to be generated
::		REG1 -	specifies register (HW) to pass.
::		REG2 -	specifies second register (HW) to pass.
::
::*********************************************************************

DBCRY.	MACRO(COND,REG1,REG2)	[
	IF	1-\COND
	ELSE
	IF	1-COND
	ELSE
	JFS	.+4
	REMARK	%Crypto wildcard at 
	NUMBER	.
	REMARK	%
	HC	1
	ST	R8,DBCRSV,,
	LHL	R8,.-8
	JE	.+30
	L	R8,DBCRSV,,
	STH	REG1,CRYSBF,,
	STH	REG2,CRYSBF+2,,
	ST	R0,DBCRSV+4,,
	LI	R0,.
	JAL	R8,CRYPTO,,
	HC	CRYE71
	L	R0,DBCRSV+4,,
	L	R8,DBCRSV,,
	EI
	EI
	]

::*********************************************************************
::
::	MACRO:		BFDLY.(RTN,REG)
::	FUNCTION:	Buffer in use by link couting macro.	###JHL
::	Used in WCFRST, WCNXT,	RTDNXT, GCRET, GCLAST, WDNXT, and CBCLR.
::	Adds contents of REG to the counter for the link in the
::	halfword array LKBFLT.  RTN is a three letter label prefix
::	passed to insure unique labels.  It is, for example, the first
::	three letters of the routine in which the macro .BFDLY is invoked.
::	The algorithm for finding the link based on channel number is
::	to step up until a link's CHN0 is less than the channel, and
::	then step up until an active link is found.  If we step to the
::	end of the LKZFKN array without meeting our condition then we
::	step back to the highest active link.  This is based on
::	the assumption that LKZFKN has CHN0's in increasing order, but
::	non-active links have CHN0's entered which are simply the same
::	as the last (or the next) active link's.
::
::*********************************************************************

BFDLY.	MACRO(RTN,REG)	[
	ST	R7,BDLSV2,,
	LHL	R7,BDLYST,,	:are we enabled? (non-zero is enabled)
	JE	RTN`70		:skip if not
	CLHI	R2,HBUFN	:compare against low bnd for history buffers
	JGE	RTN`70		:don't count history buffers
	ST	R6,BDLSV1,,	:save R6 from being clobbered
	LHL	R7,BF,R2,	:destination channel number
	LHI	R6,0
RTN`CC	CLH	R7,LKZFKN,R6,R6
	JLFS	RTN`AA
	CLHI	R6,NLINKS-1
	JEFS	RTN`BB
	AIS	R6,1
	JBS	RTN`CC
RTN`AA	SIS	R6,1		:step down to plateau below
:	step back to highest active link from here
RTN`BB	TBT	R6,ALINKS
	JNFS	RTN`60
	SIS	R6,1
	JBS	RTN`BB
RTN`60	AHM	REG,LKBFLT,R6,R6	:fix up the counter as relevant
	L	R6,BDLSV1,,	:restore R6
RTN`70	HS	0
	L	R7,BDLSV2,,	:restore R7
	]


MAKEBF	MACRO(REG,ARYNAM,RINDEX) [
IREG	EQ	RINDEX 0		:IREG=0 if RINDEX not present
BITOFST	EQ	(ARYNAM-FLAGS)*8
	IF IREG
	 LI	REG,BITOFST,RINDEX
	ELSE
	 LI	REG,BITOFST
	EI
NUMBITS	EQ	BITOFST+NGRP*10
	IF	0FFFF0000&NUMBITS		:has this overflowed?
	 ERROR(BF OVERFLOW AT ARYNAM! DECREASE NUMBER OF PORTS!!)
	 QUIT
	EI
]

::*********************************************************************
::
::	MACROS:		PUSH AND POP
::	FUNCTION:	MACROS TO SAVE A REGISTER ##AL
::	STACK STORAGE AT SEG.C AS STKPTR, SIZE BY STKSZ DEFINED
::!!!	THIS STACK TAKES TIMES BECAUSE OF ALL RX3 INSTRUCTNS.##AL
::
::*********************************************************************

PUSH	MACRO(R)[
	ST	R13,TEMST,,		:SAVE CURRENT R13
	L	R13,STKPTR,,		:LOAD STKPTR
	ST	R,0,R13,		:PUSH TO THE STACK
	AIS	R13,4			:INC PTR
	CLI	R13,4*STKSZ+STKSTR,	:END OF STACK?
	JLEFS	.+0E			:14 BYTES AHEAD, NO CRASH
	CRASH.(.STKOV)
	ST	R13,STKPTR,,		:SAVE NEW STKPTR
	L	R13,TEMST,,		:RESUME CURRENT R13	
	]

POP	MACRO(R)[
	ST	R13,TEMST,,		:SAVE CURRENT R13
	L	R13,STKPTR,,		:LOAD STKPTR
	SIS	R13,4			:DEC PTR
	CLI	R13,STKSTR,		:TOP OF STACK?
	JGEFS	.+0E			:NO CRASH,14 BYTES FORWARD
	CRASH.(.STKUN)
	L	R,0,R13,		:POP OUT TO THE REG.
	ST	R13,STKPTR,,		:SAVE NEW STKPTR
	L	R13,TEMST,,		:RESUME CURRENT R13	
	]

::*********************************************************************
::
::	MACROS:		FCSINI/FCSACC/FCSEND
::	FUNCTION: 	SOFTWARE HDLC-FCS ERROR CHECKING FOR T-II SYNC LINE
::
::*********************************************************************

FCSINI	MACRO(RFCS)[
	LCS	RFCS,1		:INITIALIZE ACCUMULATOR BY ALL 1'S
	]

FCSACC	MACRO(RFCS,RC,RWK)[	:ACCUMULATE FCS, see doc. for fcs theory.
				:RFCS- FCS ACCUMULATOR
				:RC- NEXT CHAR. IN THE STRING
				:RWK- WORK REGISTER
	EXBR	RFCS,RFCS	:SWAP BYTES A & B (RFCS=B/A)
	LBR	RWK,RFCS	:LOAD BYTE A (RFCS=A)
	XR	RFCS,RWK	:ZERO LO BYTE (RFCS=B/0)
	XR	RWK,RC		:COMPUTE TABLE INDEX (RWK=A XOR C)
	XH	RFCS,FCSTBL,RWK,RWK	:ACCUMULATE FCS
	]

FCSEND	MACRO(RFCS)[
	XI	RFCS,-1		:1'S COMPLEMENT THE FINAL VALUE
	]

::	Define Macros for Gateway
::	@.NAME converts .TYM file AC to SC
I.NAME	MACRO(S)[
INX	HC	INL
S	EQ	INX+1
	INAME()
INL	EQ	.-S-1
	]
H.NAME	MACRO(S)[
HNX	HC	HNL
S	EQ	HNX+1
	HNAME()
HNL	EQ	.-S-1
	]
:	DEFINE MACRO FOR TEXT NAME FROM SOURCE(S.S) TO DESTINATN(D.D)
ROUTE	MACRO(S.S,D.D)[
	LA	R4,FROM,,		:FROM S.S TO D.D
	JAL	R9,BUFCAN
	LA	R4,S.S,,
	JAL	R9,BUFCAN
	LA	R4,TO,,
	JAL	R9,BUFCAN
	LA	R4,D.D,,
	JAL	R9,BUFCAN
	]
DROUTE	MACRO(S.S,D.D)[
	LA	R1,FROM,,		:FROM S.S TO D.D
	JAL	R8,DIMMES,,
	LA	R1,S.S,,
	JAL	R8,DIMMES,,
	LA	R1,TO,,
	JAL	R8,DIMMES,,
	LA	R1,D.D,,
	JAL	R8,DIMMES,,
	]

::*********************************************************************
::
::	MACRO:		.DEFSK(LIN,KEY,N)
::	FUNCTION:	Internal -- consistant definition of TYMSTAR keys
::	WHERE:
::	LIN:	TYMSTAR line number ( ABSOLUTE set)
::	KEY:	The TYMSTAR key (in Hexidecimal).  No default.
::	N:	The link number.  No default.
::	NSTR[L] counts number of links for line L (of SIO lines)
::	S.K[L][K] is key for link K of line L
::	K.S[N] is key for link N
::*********************************************************************
.DEFSK	MACRO(LIN,KEY,N)	[
	DEFAULT(NSTR|$A LIN|,0)
STRHUB	EQ	1 			: Switch to activate TYMSTAR
Q	EQ	NSTR|$A LIN|
NSTR|$A LIN|	EQ	Q+1
S.K|$A LIN||$AQ| EQ	$0 KEY
K.S|$A N|	EQ	$0 KEY		: key for link N
Y|$A N|.|$A LIN| EQ	$0 KEY		: key for link N and line LIN	###AL
	]


::*********************************************************************
::
::	MACRO:		STRLNK(LIN,KEY,NBR[,WSZ][,SPD])
::	FUNCTION:	For easy definition of TYMSTAR TYMNET-II virtual links
::	WHERE:
::
::	LIN:	TYMSTAR line number ( ABSOLUTE set)
::
::	KEY:	The TYMSTAR key (in Hexidecimal).  No default.
::
::	NBR:	The neighbor number (in octal).  No default.
::
::	WSZ:	The virtual link's window size.  Default: 12.
::
::	SPD:	The link speed to be reported.  Default: 9.6
::
::	******	Automatically SAT!
::
::*********************************************************************
::	NSTR[L] counts number of links for line L (of SIO lines)
::	S.K[L][K] is key for link K of line L
STRLNK	MACRO(LIN,KEY,NBR,WSZ,SPD)	[
 IF	(LIN-MAXLIN)
	REMARK	%STRLNK line 
	NUMBER	$A LIN
	REMARK	 EXCEEDS MAXIMUM LINE NUMBER ... IGNORED!! ...%
 ELSE
	KILL N
:	Find next undefined link-fields
Q	EQ	MAXLNK
	RE	MAXLNK
Q	EQ	Q-1			: Look at next link fields.  N will be
:					  sucessively assigned all values from
:					  MAXLNK-1 down to the lowest undefined
:					  link fields.
  IF	1-\NEI|$AQ|			: This neighbor defined?
N	EQ	Q
  EI	:1-\NEI|$AQ|
	ER

  IF	1-\N				: no room for one more...all link
:					  fields defined.  Must be too many...
	REMARK	%TOO MANY LINK DESCRIPTORS!%
  ELSE	:1-\N

	KILL	TIILNK		: OK..redefine macros for no reuse
TIILNK	MACRO(NEIGH)[
	REMARK	%%TIILNK may not be used after invoking STRLNK%
	REMARK	%TIILNK to neighbor  
	NUMBER	NEIGH
	REMARK	  will be ignored and not invoked as a TIILNK%%
	]

:	Now set up link fields

	IF	N
:	THE FOLLOWING EXERCISE IS TO PREVENT NAD PASS-2 PROBLEMS
Q	EQ	0
	RE	N
	IF	\NEI|$AQ|
	IF	1-(QQ%NEI|$AQ|)
QQ	EQ	0	:DUPLICATE NEIGHBOR NUMBER... TIILNK SPECIFIED 
:	TWICE FOR SAME NEIGHBOR OR NAD PASS-2.
	EI	:1-(QQ%NEI|$AQ|)
	EI	:\NEI|$AQ|
Q	EQ	Q+1
	ER
	EI	:N


	.DEFSK(LIN,KEY,N)		: define the new key (mandatory)
NEI|$A N| EQ	$8 NBR 0		: neighbor number or wild card
WSIZ|$A N| EQ	$A WSZ 12
   IF	$A WSIZ|N|&3
	REMARK	%WSIZ must be multiple of 4 - rounding up for link 
	NUMBER	$A N
	REMARK	, SIO line 
	NUMBER	$A LIN
	REMARK  %
WSIZ|$A N| EQ	$A (WSIZ|N|+3)&(-4)
   EI	:$A WSIZ|N|&3

KSAT|$A N| EQ	SAT


KSP	EQ	$A SPD 9		: Value of SPD argument, default = 9
   IF	KSP
Q	EQ	1			: reset to 0 if valid speed encountered

	.SPED.(56,17)		: 56Kb speed
	.SPED.(48,14)		: 48Kb speed
	.SPED.(38,10)		: 38.4Kb speed
	.SPED.(28,0C)		: 28.8Kb speed
	.SPED.(19,08)		: 19.2Kb speed
	.SPED.(9,04)		: 9.6Kb speed
	.SPED.(4,02)		: 4.8Kb speed
	.SPED.(2,1)		: 2.4Kb speed
    IF	Q
:	Speed parameter not valid...bitch
	REMARK	%%***Speed Parameter not valid for link 
	NUMBER	$A N
	REMARK	, SIO line 
	NUMBER	$A LIN
	REMARK	***%%
    EI	:Q
   EI	:KSP
  EI	:1-\N
 EI	:(LIN-SILINS+1)
	]
::**********************************************************************
::
::	STRLIN:	MACRO to enable a Starlink line on a Remote Micro
::		Earth Station.	Cannot be invoked simultaneously with
::		the STRLNK Macro or will cause assembly errors.
::
::**********************************************************************
STRLIN	MACRO(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16) [
STRRMT	EQ	1
Q1	EQ	$A P1 -1
Q2	EQ	$A P2 -1
Q3	EQ	$A P3 -1
Q4	EQ	$A P4 -1
Q5	EQ	$A P5 -1
Q6	EQ	$A P6 -1
Q7	EQ	$A P7 -1
Q8	EQ	$A P8 -1
Q9	EQ	$A P9 -1
Q10	EQ	$A P10 -1
Q11	EQ	$A P11 -1
Q12	EQ	$A P12 -1
Q13	EQ	$A P13 -1
Q14	EQ	$A P14 -1
Q15	EQ	$A P15 -1
Q16	EQ	$A P16 -1
Q	EQ	1
	RE	$A 16
	IF	Q|$A Q|+1
	IF	Q|$A Q|-MAXLIN
	REMARK	%LINE NUMBER 
	NUMBER	Q|$A Q|  
	REMARK  EXCEEDS MAXIMUM LINE NUMBER ... IGNORED!! ...%
	ELSE
L	EQ	Q|$A Q|
NSTR|L|	EQ	1
	EI
	EI
Q	EQ	Q+1
	ER
	KILL	STRLNK
STRLNK	MACRO		[
STRHUB	EQ	1
	REMARK	%STRLNK may not be used in the same configuration as STRLIN
	REMARK	%Can NOT be Hub AND Remote  ... CONFIGURATION ERROR ... !!!!%
KILLIT	EQ	1
	]
	]
::**********************************************************************
::
::	STRXKM:	Macro defines the number of star-xlinks and the 
::		window-size for these star-xlinks.
::
::**********************************************************************
STRXKM	MACRO(N,WSZ) [		:###AL
STRXLK	EQ	$A N		:NO OF STAR XLINKS 
	IF	WSZ
STXKWZ	EQ	$A WSZ		:IF WSZ DEFINED IN THE MACRO
	ELSE
STXKWZ	EQ	$A 28		:DEFAULTED
	EI
]

:	***NOTHING  PAST THIS  POINT***
    -1#12