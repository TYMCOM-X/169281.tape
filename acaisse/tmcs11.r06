 = 1 then display_text(' TII \')
        else set_data_error;

      if data[3] = 1 then display_text('-M \')
      else if data[3] = 0 then display_text('   \')
       else set_data_error;

      if not((data[2]=0) and (data[4] <>0)) (* if line <> XLINK not Up *)
      then nodedescriptor_line_up(status)
      else display_text('                \ ');

      read_field(status,data[0], size[0]);
      if data[0] <> 0 
      then display_time(data[0])
      else display_text('               \');

      read_field(status,data[0],size[0]); (* line errate *)
      if (data[0]>=1) and (data[0]<=4)
      then for i:= 1 to data[0] do display_char('*')
  end(* if *)
end(*nodedescriptor_line_status *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*		        nodedescriptor_line_data			*)
(*									*)
(*	Write data concerning lines in nodedescriptor.                  *)
(*									*)
(************************************************************************)


procedure nodedescriptor_line_data(
  var status : transaction_status);

var
  data : integer;
  size : integer;

begin
  display_data( status, decimal_blank_data, 1); (* line no *)

  read_field(status,data, size); (* type *)
  if data = 0 then display_text('Sync \')
  else if data = 1 then display_text('SIO  \')
    else set_data_error;

  read_field(status,data,size);
  if data = 0 then nodedescriptor_line_status(status)
  else if data = 1 then display_text('DWLoad \')
    else if data = 2 then display_text('Unused \')
      else set_data_error;
  display_newline(1)
end (* nodedescriptor_line_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*		        nodedescriptor_neighbors			*)
(*									*)
(*	Display end of Node descriptor response ( T-II neighbors down). *)
(*									*)
(************************************************************************)


procedure nodedescriptor_neighbors(
  var status : transaction_status);

var
  data : integer;
  size : integer;

begin
  read_field( status, data, size);
  if not data_error 
  then
    if data = 0
    then display_text('none\ ')
    else
      begin
        display_integer(data,8,-size);
        display_text(' \');
        while not data_error and scan_ok( status) do
          display_data( status, octal_blank_data, 1)
      end(*else*)
end (* nodedescriptor_neighbors *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			nodestatistics_cps_rate				*)
(*									*)
(*      Display partial response to nodestatistics command .            *)
(*      ( when Async or Printer CPS rate has to be printed.)            *)
(*									*)
(************************************************************************)


procedure nodestatistics_cps_rate(
  var status : transaction_status);

var
  i : integer;

begin
  display_line('CPS rates\');
  display_line('Average Out  Average In   Peak Out     Peak In\ ');
  for i := 1 to 4 do
    display_data( status, decimal_blank_data, 5);
  display_newline(2)
end (* nodestatistics_cps_rate *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			nodestatistics_data				*)
(*									*)
(*	Display partial response to nodestatistics command .            *)
(*									*)
(************************************************************************)


procedure nodestatistics_data(
  var status      : transaction_status);

var
  data : integer;
  size : integer;

begin
  if configuration = SOLO_CONSAT
  then
    begin
      display_text('Async \ ');
      nodestatistics_cps_rate( status);
      read_field(status,data, size);
      if data = 1
      then
        begin
          display_text('Printer \ ');
          nodestatistics_cps_rate( status)
        end
    end
end (* nodestatistics_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			nodestatistics_time				*)
(*									*)
(*      Display Async Time in nodestatistics if solo_consat.            *)
(*									*)
(************************************************************************)


procedure nodestatistics_time(
  var status : transaction_status);

begin
  display_newline(1);
  display_text('Average Async Time (ms) : \ ');
  display_data( status, decimal_blank_data, 5);
  display_text('Max  : \');
  display_data( status, decimal_blank_data, 5);
  display_text('Wrap  : \ ');
  display_simple_data( status, decimal_blank_data);
  display_newline(2)
end (* nodestatistics_time *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			linforeground_data				*)
(*									*)
(*      Display response to 'Display linforeground' command.            *)
(*									*)
(************************************************************************)


procedure linforeground_data(
  var status : transaction_status);

var
  value : integer;
  size  : integer;

begin
  display_line('  Event    Line   Head    Ack    Rec nbr    FASTC (lower 3 bytes)\');
  while not data_error and scan_ok( status) do
    begin
      read_field( status, value, size);
      if (value <0) or (value >8)
      then set_data_error
      else
        case value of
	  0 : display_text('Zero bit    \ ');
	  1 : display_text('Reset       \ ');
	  2 : display_text('Dummy rec   \ ');
	  3 : display_text('Cksm error  \ ');
	  4 : display_text('Bad ack     \ ');
	  5 : display_text('Rexmissn    \ ');
	  6 : display_text('Bad Rec nbr \ ');
	  7 : display_text('Good rec    \ ');
	  8 : display_text('Good data   \ ')
        end(*case*);
      display_data(status, hex_data, 5);
      display_data(status, hex_data, 5);
      display_data(status, hex_data, 8);
      display_data(status, hex_data, 6);
      display_data(status, hex_data, 2);
      display_newline(1)
    end(*while*)
end (* linforeground_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			linbackground_data				*)
(*									*)
(*      Display response to 'Display linbackground'  command.           *)
(*									*)
(************************************************************************)


procedure linbackground_data(
  var status : transaction_status);

var
  value : integer;
  i     : integer;
  size  : integer;

begin
  display_line('  Event       Va1    Va2    Va3    Va4    FASTC ( lower 3 bytes)\ ');
  while not data_error and scan_ok( status) do
    begin
      read_field( status, value, size);
      if (value <0) or (value > 4)
      then set_data_error
      else
        case value of
	  0 : display_text('Packet made   \ ');
	  1 : display_text('Packet torn   \ ');
	  2 : display_text('Detach        \ ');
	  3 : display_text('Attach        \ ')
        end(*case*);
      for i := 1 to 4 do
        display_data(status, hex_data, 5);
      display_data(status, hex_data, 2);
      display_newline(1)
    end(*while*)
end (* linbackground_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				warning_data				*)
(*									*)
(*	Display the response to Display Warning command.                *)
(*									*)
(************************************************************************)


procedure warning_data(
  var status : transaction_status);

 var
  value : integer;
  size  : integer;

begin
  read_field(status,value, size);
  if value <> 0 
  then
    begin
      display_simple_data( status, charact);
      display_newline(2);
      read_field(status, value, size);
      display_text('Message entered : \ ');
      if value = 0
      then display_text('at assembly time\ ')
      else display_time(value)
    end(* then *)
end (* warning_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			sioringstatus_data				*)
(*									*)
(*	Display the response to Display Sioringstatus command.          *)
(*									*)
(************************************************************************)


procedure sioringstatus_data(
  var status :  transaction_status);

var
  value : integer;
  size  : integer;

begin
  read_field( status, value, size);
  if (value <0) or (value  > 3)
  then set_data_error
  else
    case value of
      0 : display_text('SIO Ring down\');
      1 : display_text('SIO Ring up\');
      2 : display_text('SIO Ring awaiting load\ ');
      3 : display_text('SIO Ring loading\ ');
      4 :
        begin
	  display_text('SIO Ring Timed out on \ ');
	  display_data( status, hex_data, 1);
	  display_text('command\')
	end
    end(*case*)
end (* sioringstatus_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				crash_data				*)
(*									*)
(*      Display crash time, type, address, PSW in crashtables.          *)
(*									*)
(************************************************************************)


procedure crash_data(
  var status : transaction_status);

begin
  display_data( status, time_data, 9); (* time *)
  display_data( status, decimal_blank_data, 6); (* crash count *)
  display_data( status, hex_data, 3); (* type *)
  display_data( status, hex_data, 3); (* PSW *)
  display_simple_data( status, hex_data); (* address *)
  display_newline(1)
end (* crash_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			crashsummary_data				*)
(*									*)
(*	Display the response to Display Crashsummary command .          *)
(*									*)
(************************************************************************)


procedure crashsummary_data(
  var status : transaction_status);

var
  value : integer;
  i     : integer;
  size  : integer;

begin
  read_field( status, value, size);
  display_text('Crash summary table\');
  if value =0
  then display_line(' empty\ ')
  else
    begin
      display_newline(1);
      display_line('       Time         Crash count   Type   PSW    Address\');
      for i := 0 to (value -1) do crash_data( status)
    end
end (* crashsummary_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			crashdetail_data				*)
(*									*)
(*	Display the response to the Display Crashdetail command .       *)
(*									*)
(************************************************************************)


procedure crashdetail_data(
  var status : transaction_status);

var
  count : integer;
  i     : integer;
  size  : integer;

begin
  i := 0;
  display_text('Crash detail  table\');
  read_field( status, count, size);
  if count = 0 
  then display_line(' empty\ ');
  if (count <> 1) and (count <> 2) and (count <> 0)
  then count := 2;
  if configuration in [ ISIS, SUP]
  then
    while (i < count) and not data_error do
      begin
        display_newline(1);
        display_line('       Time         Crash count   Type   PSW    Address\');
	crash_data( status);
	display_newline(1);
        display_line('User register set :\');
	display_multiple_data( status, 16, hex_data);
	i := i+1
      end(* while*)
  else
    while (i < count) and not data_error do
      begin
        display_newline(1);
        display_line('       Time         Crash count   Type   PSW    Address\');
	crash_data(status);
	display_newline(1);
	display_line('Register set 0 :\ ');
	display_multiple_data( status, 16, hex_data);
	display_newline(1);
	display_line('User register set :\');
	display_multiple_data( status, 16, hex_data);
	display_newline(1);
	display_line('MAC Registers :\');
	display_multiple_data( status, 24, hex_data);
	i := i+1
      end(* while *)
end (* crashdetail_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				bufferstat_data				*)
(*									*)
(*	Display the response to Display Bufferstatistics command .      *)
(*									*)
(************************************************************************)


procedure bufferstat_data(
  var status : transaction_status);

var
  i               : integer;
  value           : integer;
  mult            : integer;
  size            : integer;
  nsteps	  : integer;
  old_indentation : integer;

begin
  read_field(status, value, size);
  display_line('Buffer status ( in bytes) :\');
  display_line('   Buffers      Total in use  Total Peak \');
  display_text('  \ ');
  for i := 1 to 3 do display_data( status, decimal_blank_data,6);
  display_newline(2);
  if value = 1
  then display_text('History in use  History Peak\ ');
  display_line('  Available  Zaps\');
  if value = 1 
  then
    begin
      display_text('  \ ');
      for i := 1 to 2 do display_data(status, decimal_blank_data,6)
    end;
  for i := 1 to 2 do display_data( status, decimal_blank_data,3);
  display_newline(2);

  read_field( status, value, size);
  read_field(status, nsteps, size); 
  if (value>=0) and (value<=5)
  then
    begin
      mult := 1;
      if value <> 0 then
        for i := 0 to (value-1) do
          mult := mult * 2;
      old_indentation := indentation;
      indentation := 10;
      display_line('          Range     Count(Hex)\ ');
      display_line('   Normal Buffers   \ ');
      display_text('Under  \');
      display_integer( mult, 10,-3);
      display_text('K  \');
      display_simple_data( status, hex_data);
      display_newline(1);
      for i := 1 to (nsteps -1) do
        begin
          display_integer( mult*i, 10,-3);
	  display_text('K - \ ');
	  display_integer( mult*(i+1), 10,-3);
	  display_text('K  \');
	  display_simple_data( status, hex_data);
	  display_newline(1)
	end;
      indentation := old_indentation
    end
end (* bufferstat *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				statistics_data				*)
(*									*)
(*      Display Line data in response to 'Display statistics            *)
(*      command, if node is not an ISIS node.                           *)
(*									*)
(************************************************************************)


procedure statistics_data(
  var status : transaction_status);

var
  data : integer;
  size : integer;
  i    : integer;

begin
  if not (configuration in [ISIS, SUP])
  then
    begin
      display_newline(1);
      display_line('              Marking    ReXmissions    Xmissions\');
      while not data_error and scan_ok(status) do
        begin
	  display_text('Line \');
	  display_data( status, decimal_blank_data,2);
	  display_text(':    \');
	  read_field( status, data, size);
	  if data > 32767 (* hex 7FFF last positive number *)
	  then display_text(' N/A\ ')
	  else display_integer( data, 10, size);
	  display_text('         \');
	  for i := 0 to 1 do
	  display_data( status, decimal_blank_data, 9);
          display_newline(1)
	end (* while *)
    end (* then *)
  else 
    if data <> 0 
    then set_data_error
  end (* statistics_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				portstatus_data				*)
(*									*)
(*	Display portstatus ( in response to Display portstatus command).*)
(*									*)
(************************************************************************)


procedure portstatus_data(
  var status : transaction_status);

var
  i    : integer;
  data : integer;
  size : integer;

begin
  while not data_error and scan_ok( status) do
    begin
      display_data( status, octal_blank_data, 1); (* port *)
      for i := 1 to 5 do
        display_data( status, hex_data, 2); (* RLA,DTR,DSR,RTS,CP *)
      read_field( status, data, size); (* Duplex *)
      if data = 0
      then display_text('FDx  \')
      else display_text('HDx  \');
      display_data( status, hex_data, 2); (* BR *)
      display_data( status, hex_data, 2); (* TY *)
      display_data( status, decimal_blank_data, 4); (* NL *)
      display_data( status, hex_blank_data, 3); (* CHannel *)
      display_data( status, octal_blank_data, 4); (* Link *)
      display_data( status, decimal_blank_data,5); (* Time *)
      display_simple_data(status, decimal_blank_data); (* Up *)
      display_newline(1)
    end (* while *)
end (* portstatus_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			channelstatus_data				*)
(*									*)
(*      Display History buffers in 'Display channelstatus' response     *)
(*      if option REBUILD is enabled.                                   *)
(*									*)
(************************************************************************)


procedure channelstatus_data(
  var status : transaction_status);

var
  data : integer;
  size : integer;
  i   : integer;

begin
  read_field( status, data, size);
  if data = 1 (* rebuild enabled *)
  then
    begin
      display_newline(1);
      display_line('Hist.Buff   Hist.Seq.Nbr   X.Seq.Nbr   V.Seq.Nbr   Rebuild\ ');
      display_text('    \ ');
      for i := 0 to 3 do
        display_data( status, hex_data, 5);
      read_field(status, data, size);
      if data = 0
      then display_text('Off\')
      else
        if data = 1
	then display_text('On \')
	else set_data_error
    end (* then *)
  else 
      if data <> 0
      then set_data_error
end (* channelstatus_data *) ;




(********************** xray_response_conversion  ***********************)
(*									*)
(*			datatrace_display_data				*)
(*									*)
(*	Display data according to the Datatrace command.                *)
(*           - if 'datatrace' escape are not printed (A 00 in data      *)
(*             is not printed twice).                                   *)
(*           - if 'escape datatrace' data is printed as is on the line. *)
(*           -ASCII datatrace' data is printed as ASCII chars      *)
(*             (may produce strange effects on terminal).               *)
(*									*)
(************************************************************************)


procedure datatrace_display_data(
      data       : integer;
  var zero_found : boolean;
      scanned    : scanned_command);

begin
  if xray_list_escape_keyword in scanned.keyword_present
  then
    begin
      display_integer( data, 16, 2);
      display_text('  \ ')
    end
  else
    if xray_list_ascii_keyword in scanned.keyword_present
    then
      begin
        display_char(chr(data));
	display_text('  \ ')
      end
    else
      if data = 0
      then
        if zero_found
        then
	  begin
	    display_integer( data, 16, 2);
	    zero_found := FALSE;
            display_text('  \ ')
          end
        else zero_found := TRUE (* escape not printed *)
      else
        begin
          display_integer( data, 16, 2);
          display_text('  \ ');
	  zero_found := FALSE
        end
end (* datatrace_display_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				datatrace_data				*)
(*									*)
(*	Display response to datatrce commands .                         *)
(*									*)
(************************************************************************)


procedure datatrace_data(
  var status  : transaction_status;
      scanned : scanned_command);

var
  data            : integer;
  data1           : integer;
  size            : integer;
  zero_found      : boolean;
  old_indentation : integer;

begin
  zero_found := FALSE;
  display_line('I/O Chnl Time\');
  display_text('--- ---- ----\');
  read_field( status, data, size);
  read_field( status, data1, size);

  while not data_error and scan_ok( status) do
    begin
      display_newline(1);
      if data = 0 
      then display_text('Out \ ')
      else 
        if data = 1 
	then display_text('In  \ ')
	else set_data_error;
      display_integer(data1,16,xray_data.length(scanned,xray_list_channel_keyword)); (* channel *)
      display_text(' \');
      display_data( status, hex_data, 2); (* time *)
      if scan_ok( status)
      then read_field( status, data, size);
      if scan_ok( status)
      then read_field( status, data1, size);
      old_indentation := indentation;
      indentation := 13;
      
      if (size <>4) and not data_error
      then
        repeat
	  datatrace_display_data( data, zero_found, scanned);
	  data := data1;
	  if scan_ok( status)
	  then read_field( status, data1, size)
        until (size = 4) or data_error or not scan_ok( status);

      indentation := old_indentation
    end (* while *);
  datatrace_display_data( data, zero_found, scanned);
  datatrace_display_data( data1, zero_found, scanned)
end (* datatrace_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			pvcparameter_data				*)
(*									*)
(*	Display the response to 'Display PVCparameter' command.		*)
(*									*)
(************************************************************************)


procedure pvcparameter_data(
  var status : transaction_status);

var
  data : integer;
  data1: integer;
  size : integer;

begin
  while not data_error and scan_ok( status) do
    begin
      display_data( status, octal_blank_data, 2); (* port *)
      read_field(status, data, size);
      data := abs(data);
      if test_data(data, 1) (* AID *)
      then display_integer(data div 16777216 (* 16 pow 6*),8,-2)
      else display_text('No\ ');
      convert_data(data,2,'  ALO \ ','      \ '); (* ALO *)
      if test_data(data,4)  (* PCO/SLO *)
      then display_text('SLO  \')
      else if test_data(data,6)
      then display_text('PCO  \')
      else display_text('     \');
      convert_data(data,3,'No   \','Yes  \'); (* NPI *)
      convert_data(data,5,'Yes  \','No   \'); (* Par *)
      convert_data(data,7,'No   \','Yes  \'); (* Hang *)
      convert_data(data,8,'HDx  \','FDx  \'); (* Duplex *)
      convert_data(data,9,'No   \','Yes  \'); (* CRLF *)
      convert_data(data,10,'No   \','Yes  \'); (* LFCR *) 
      convert_data(data,11,'Yes  \','No   \'); (* TRS *)
      convert_data(data,12,'Yes  \','No   \'); (* RBP *)
      convert_data(data,15,'Yes  \','No   \'); (* MPVC *)
      read_field(status, data1, size);
      if data1 = 1
      then display_text('MPPSD\')
      else
        if data div 16777216 = 31 (* hex 1F *)
        then display_text('TELEX\');
      display_newline(1)
    end (* while *)
end (* pvcparameter_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			product_description				*)
(*									*)
(*	Display product description in hostinfo .                       *)
(*									*)
(************************************************************************)


procedure product_description(
  data : integer);

var
  pid_text   : message_string;
  name	     : symbol;
  i	     : symbol_text_index;

begin
  name_common.get_product_name(data, name);
  for i := 0 to name.size-1 do
    pid_text[i] := name.text[i];
  pid_text[name.size] := EOM;
  display_text(pid_text)
end (* product_description *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				hostinfo_data				*)
(*									*)
(*	Display response to the Display Hostinfo command.               *)
(*									*)
(************************************************************************)


procedure hostinfo_data(
  var status : transaction_status);

var
  data : integer;
  size : integer;

begin
  display_data( status, decimal_blank_data, 4); (* host no *)
  display_data( status, hex_blank_data, 3); (* slot no *)
  read_field( status, data, size);
  display_integer( data, 16, -size);
  display_text('   \');
  product_description( data);
  read_field( status, data, size);
  if data = 0 then display_text('   Up   \ ') 
  else if data = 1 then display_text('  Down  \ ')
    else if data = 2 then display_text('  Shut  \ ')
      else if data = 3 then display_text('  Gone  \ ')
        else set_data_error;
  display_data( status, time_data, 1);
  display_data( status, hex_data, 2);
  read_field( status, data, size);
  if (data > 15)
  then set_data_error
  else
    case data of
      0 : display_text('NNNN\ ');
      1 : display_text('NNNY\ ');
      2 : display_text('NNYN\ ');
      3 : display_text('NNYY\ ');
      4 : display_text('NYNN\ ');
      5 : display_text('NYNY\ ');
      6 : display_text('NYYN\ ');
      7 : display_text('NYYY\ ');
      8 : display_text('YNNN\ ');
      9 : display_text('YNNY\ ');
      10 : display_text('YNYN\ ');
      11 : display_text('YNYY\ ');
      12 : display_text('YYNN\ ');
      13 : display_text('YYNY\ ');
      14 : display_text('YYYN\ ');
      15 : display_text('YYYY\ ')
    end (* case *);
  display_newline(1)
end (* hostinfo_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				linetrace_data				*)
(*									*)
(*	Display the response to the Linetrace commands.                 *)
(*									*)
(************************************************************************)


procedure linetrace_data(
  var status : transaction_status);

var
  data : integer;
  size : integer;

begin
  display_text('Line being traced : \ ');
  read_field( status, data, size);
  if data > 32767 (* hex 7FFF max positive number *)
  then display_integer( data, 16, size)
  else display_integer( data, 10, -size)
end (* linetrace_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				cpu_end_data				*)
(*									*)
(*	Display the end of the response to 'd cpu utilization'		*)
(*									*)
(************************************************************************)


procedure cpu_end_data(
  var status : transaction_status;
      db_clk : integer);

begin
  display_newline(1);
  display_text('Number of dispatches : \');
  display_simple_data( status, hex_blank_data);
  display_newline(1);
  display_text('Top of Exec loop     : \');
  display_simple_data( status, hex_blank_data);
  if db_clk = 1
  then
    begin
      display_newline(1);
      display_text('Exec loop FASTC time : \');
      display_simple_data( status, hex_blank_data);
      if configuration in [ ISIS, SUP]
      then
        begin
	  display_newline(1);
          display_text('SYLVER Forcd         : \');
	  display_simple_data( status, hex_blank_data)
	end
    end
end (* cpu_end_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				cpu_data				*)
(*									*)
(*	Display response to 'Display CPU Utilization' command.		*)
(*									*)
(************************************************************************)


procedure cpu_data(
  var status : transaction_status);

var
  db_clk : integer;
  size   : integer;
  count  : integer;
  i      : integer;

begin
  read_field( status, db_clk, size);
  if (configuration in [ISIS, SUP]) and (db_clk = 1)
  then 
    begin
      display_text('               Slot 0 time : \');
      display_simple_data( status, hex_blank_data);
      display_newline(1)
    end;
  display_newline(1);

  if configuration in [ SUP, SPLIT_SUP]
  then
    begin
      display_text('Supervisor character count : -to sup   : \');
      display_simple_data(status, hex_blank_data);
      display_newline(1);
      display_text('                             -from sup : \');
      display_simple_data(status, hex_blank_data);
      display_newline(1)
    end;

  display_line('Process  Time  Dismiss count\ ');
  display_line('-------  ----  -------------\ ');
  read_field(status, count, size);
  i := 1;
  while (i <= count) and not data_error and scan_ok(status) do
    begin
      display_data( status, charact, 3);
      display_data( status, hex_blank_data, 6); (* time *)
      display_simple_data( status, hex_blank_data); (* count *)
      display_newline(1);
      i := i +1
    end;
  display_text('Totals = \');
  display_data( status, hex_blank_data, 6); (* time *)
  display_simple_data( status, hex_blank_data); (* count *)
  display_newline(2);
  if configuration in [ ISIS, SUP]
  then
    begin
      display_text('SYLVER   \');
      if db_clk = 1
      then display_data( status, hex_blank_data, 6) (* time *)
      else display_text('          \ ');
      display_simple_data( status, hex_blank_data); (* dismiss count *)
      display_newline(2)
    end;

  cpu_end_data( status, db_clk)
end (* cpu_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				busyports_data				*)
(*									*)
(*	Display the response to 'busyports' commands.			*)
(*									*)
(************************************************************************)


procedure busyports_data(
  var status : transaction_status);

var
  data : integer;
  size : integer;
  port : integer;
  bit  : integer;

begin
  port := 0;
  while not data_error and scan_ok( status) do
    begin
      display_text('  \ ');
      read_field(status, data, size);
      display_integer( data, 16, size);
      display_text('         \');
      for bit := 16 downto 1 do
        begin
          if test_data( data, bit)
          then
            begin
              display_integer(port , 8, -2);
              display_text(' \')
            end;
          port := port +1
        end;
      display_newline(1)
    end (* while *)
end (* busyports_data *) ;

!

(************************************************************************)
(*                                                                      *)
(*      The following procdures read xray file .                        *)
(*      ----------------------------------------                        *)
(************************************************************************)

(********************** xray_response_conversion  ***********************)
(*									*)
(*				scan_data				*)
(*									*)
(*	Scan special coded data from XRAY and convert it.               *)
(*                                                                      *)
(*      As soon as the program finds a $0 in file that means            *)
(*      that next piece of data is to be read from the response         *)
(*      and that it has to be analysed in a special way.                *)
(*      This procedure reads the two following digits in file           *)
(*      Thes digits indicate which procedure is to be called in         *)
(*      order to scan next piece of data from the response.             *)
(*									*)
(************************************************************************)


procedure scan_data(
      value  : integer;
  var status : transaction_status);

var
  size        : integer;
  data        : integer;
  i           : integer;

begin
  i := 0;
  if (value <0 ) or (value > MAX_SPECIAL_CODE)
  then xf_status := XRAY_IO_ERROR
  else
    begin
      if scan_ok( status)
      then
        case value of
          0 (* display crashoptions *) :
	    begin
              read_field( status, data, size);
	      if data = 0 then display_text('Restart\')
	      else if data = 1 then display_text('Stop   \')
	        else if data = 2 then display_text('Boot   \')
	          else if data = 3 then display_text ('Halt   \')
		    else set_data_error
            end;

          1 (* display line data in nodedescriptor *) :
	    begin
	      read_field(status, data, size);
	      while not data_error and ( i < data ) do
	        begin
	          nodedescriptor_line_data(status);
	          i := i+1
	        end
             end;

          2 (* display neighbors down in nodedescriptor *) :
	    nodedescriptor_neighbors(status);

          3 (* display async or printer cps rates*) :
	    nodestatistics_data( status);

          4 (* display data in nodestatistics *) :
	    if configuration = SOLO_CONSAT 
	    then display_text('ASYN \');

          5 (* display data in nodestatistics *) :
	    if configuration = SOLO_CONSAT 
	    then display_text('QSEC \');

          6 (* display data in nodestatistics *) :
	    if configuration = SOLO_CONSAT 
	    then
	      for i := 1 to 2 do
	        display_data( status, decimal_blank_data, 3);

          7 (* display data in nodestatistics *) :
	    if configuration = SOLO_CONSAT 
	    then
	      for i := 1 to 2 do
	        display_data( status, decimal_blank_data, 1);

          8 (* display time in nodestatistics *) :
            if configuration = SOLO_CONSAT 
	    then nodestatistics_time( status);

          9 (* display statistics if not ISIS *) :
	    statistics_data(status);

          10 (* display portstatus *) :
	    portstatus_data( status);

          11 (* display channelstatus if rebuild enable *) :
	    channelstatus_data( status);

          12 (* display nodes in delaystatistics *) :
	    begin
	      read_field( status, data, size);
	      for i := 0 to (data -1) do
	        display_data( status, octal_blank_data, 2)
	    end;

          13 (* display data in delaystatistics *) :
	    display_multiple_data( status, 32, decimal_data);

          14 (* display host info *) :
	    while not data_error and scan_ok( status) do
	      hostinfo_data( status);

          15 (* display link speed in link descriptor *) :
	    link_speed( status);

          16 (* display a percentage in link statistics *) :
	    begin
	      read_field( status, data, size);
	      if data = 0
	      then display_integer(100,10,-3)
	      else display_integer(data,10,-3)
	    end;

          17  (* display 'none' if data = 0 in link descriptor *) :
	    begin
	      read_field( status, data, size);
	      if data = 0
	      then display_text('none\ ')
	      else display_integer(data,8,-size)
	    end;

          18 (* display link type in link descriptor *) :
	    begin
	      read_field( status, data, size);
	      if data = 0 
	      then display_text('Terrestrial\')
	      else if data = 1
	      then display_text('Satellite  \')
	      else set_data_error
	    end;

          19 (* display attached lines in link descriptor *) :
	    begin
	      read_field( status, data, size);
	      if data = 255 (* hex FF *)
	      then display_text('none\ ')
	      else
	        begin
		  display_integer( data, 16, -size);
		  display_text('  \ ');
		  while not data_error and scan_ok( status) do
	            display_data( status, hex_blank_data, 2)
		end
	    end;

          20 (* display none if link no < 0 in channelstatus *) :
	    begin
	      read_field( status, data, size);
	      if data > 32767 (* hex 7FFF last pos. number *)
	      then display_text('none\ ')
	      else display_integer(data,8,-size)
	    end;

          21 (* display one HW in octal in CRYPTO message *) :
	    if hw_count < 4
	    then
	      repeat
	        hw_count := hw_count + 1;
		read_field(status, data, size);
		if bit_set
		then
		  begin
		    data := data mod 4096; (* first bits to be ignored*)
		    display_integer(data,8,-2)
		  end
	      until bit_set or data_error or not scan_ok(status) or (hw_count>=4)
	    else set_data_error;

          22 (* display decimal number in CRYPTO message *) :
	    if hw_count < 4
	    then
	      repeat
	        hw_count := hw_count +1;
		read_field( status, data, size);
		if bit_set
		then display_integer( data, 10, -2)
	      until bit_set or data_error or not scan_ok(status) or
		    (hw_count >= 4)
	    else set_data_error;

          23 (* display hex number in CRYPTO message *) :
	    if hw_count < 4
	    then
	      repeat
	        hw_count := hw_count +1;
		read_field( status, data, size);
		if bit_set
		then display_integer(data, 16, -2)
	      until bit_set or data_error or not scan_ok(status) or
		    (hw_count >= 4)
	    else set_data_error;

          24 (* display characters in CRYPTO message *) :
	    if hw_count < 4
	    then
	      repeat
	        hw_count := hw_count +1;
		read_field(status, data, size);
		if bit_set
		then
		  begin
		    display_char(chr((data div 256) mod 256));
		    display_char(chr(data mod 256))
		  end
	      until bit_set or data_error or not scan_ok(status) or
		    (hw_count >= 4)
	    else set_data_error;

          25 (* reads remaining HW's from CRYPTO message *) :
	    while (hw_count < 3) do
	      begin
	        read_field( status, data, size);
		hw_count := hw_count +1
	      end;

          26 (* display response to pvcparameter command *) :
            pvcparameter_data( status);

          27 (* display response to patch command *) :
	    while not data_error and scan_ok( status) do
	      begin
	        for i := 1 to 3 do display_data( status, hex_data, 2);
		display_simple_data( status, charact);
		display_newline(1)
	      end;

          28 (* display response to busyports commands *) :
            busyports_data( status);

          29 (* display partial response to semiconductor error log *) :
	    begin
	      read_field( status, data, size);
	      if data = 0
	      then display_text('Single bit errors on chip\')
	      else
	        if data = 1
		then display_text('Double bit errors on  row\')
		else set_data_error
	    end;

          30 (* display response to display cpu statistics *) :
	    cpu_data( status)

          (* WARNING!!! If new codes are added the value *)
	  (* of MAX_SPECIAL_CODE is to be changed.       *)

        end(*case*)
    end(* else*)
end (* scan_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				read_data				*)
(*									*)
(*	Read in file what type of data is to be read from               *)
(*      the response and display this data.                             *)
(*									*)
(************************************************************************)


procedure read_data(
      line       : xray_line;
  var line_count : xray_line_index;
  var status     : transaction_status);

var
  value : integer;

begin
  if (line[line_count]>= first_data) and (line[line_count]<= last_data)
  then
    if line[line_count] = special_data
    then
      begin
        value := (ord(line[line_count+1])-ord('0')) * 10
                 + (ord(line[line_count +2])-ord('0'));
        scan_data(value,status);
	line_count := line_count + 2
      end(*then*)
    else display_simple_data(status, line[line_count])
  else xf_status := XRAY_IO_ERROR;
  line_count := line_count +1
end (* read_data *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				next_line				*)
(*									*)
(*	Return a new line from the file .                               *)
(*									*)
(************************************************************************)


procedure next_line(
  var line         : xray_line);

const
  EOP = END_OF_PAGE_CHARACTER;

var
  i     : integer;

begin
  i := 0;
  while (xf_status=XRAY_OK) and ( i < xray_line_max) and not (current_page[count] in [EOM,ASCCR]) do
    begin
      while (i < xray_line_max) and not (current_page[count] in [EOM,ASCCR,EOP]) do
        begin
	  line[i] := current_page[ count];
          i := i +1;
	  count := count +1
	end(* while *);
      if current_page[ count] = EOP
      then
        begin
          xray_data.read_page( pageno, current_page, xf_status);
	  count := 0
	end(* if..then*)
    end(*while*);
  if xf_status = XRAY_OK
  then
    if (current_page[ count] in [ ASCCR, EOM])
    then
      begin
        line [i] := current_page[ count];
        count := count +1
      end (* then *)
end (* next_line *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			scan_special_char				*)
(*									*)
(*      Read a special char ( ASCR,$ or \) in file and analyses it      *)
(*									*)
(************************************************************************)


procedure scan_special_char(
      character     : char;
  var line          : xray_line;
  var line_count    : xray_line_index;
  var status        : transaction_status);

begin
  if character <> EOM
  then line_count := line_count+1;(* skip special char*)
  case character of
    ASCCR :
      begin
        display_newline(1);
	next_line(line);
        line_count := 0
      end (* ASCCR *);
    DTA :
      read_data(line,line_count,status); (* read data from XRAY *)
    EOM :
      (* empty reponse complete *)
  end(* case*)
end (* scan_special_char *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				scan_line				*)
(*									*)
(*      Display a line from file on terminal and display data           *)
(*      as soon as a '$' is found in file ( then takes a new            *)
(*      field from response and displays it as an integer.              *)
(*									*)
(************************************************************************)


procedure scan_line(
  var line         : xray_line;
  var status       : transaction_status);

var
  i : integer;

begin
  i := 0;
  while (xf_status = XRAY_OK) and (line[i] <> EOM) and not data_error do
    begin
      while (xf_status=XRAY_OK) and not ( line[i] in [EOM,ASCCR,DTA] ) do
        begin
          while (i <> xray_line_max) and 
                not ( line[i] in [EOM,ASCCR,DTA,NUL]) do
            begin
	      display_char(line[i]);
	      i := i+1
            end(*third while*);
          if i=xray_line_max
	  then
	    begin
	      if not (line[i] in [EOM,ASCCR,DTA,NUL])
	      then display_char(line[i]);
	      line[i] := ASCCR
            end(* then *);
	  if line[i] = NUL(* char to be ignored*)
	  then i:= i+1
        end(*second while*);
      if xf_status = XRAY_OK
      then scan_special_char(line[i],line,i,status)
    end(* first while*)
end (* scan_line *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				display_message				*)
(*									*)
(*	Display one CRYPTO message.					*)
(*									*)
(************************************************************************)


procedure display_message(
  var status	: transaction_status);

var
  line		: xray_line;
  i		: integer;
  value		: integer;
  size		: integer;

begin
  display_simple_data( status, time_data);
  display_data( status, hex_data,1);
  read_field( status, test_byte, size);
  read_field( status, value, size);
  display_integer( value, 16, size);
  if value <= MAX_CRYPTO_MESSAGE
  then
    begin
      xray_data.find_pageno( xray_list_crypto_code, pageno);
      xf_status := XRAY_OK;
      pageno := pageno + value div 4 (* 4 messages/page in file *);
      xray_data.read_page( pageno, current_page, xf_status);
      if xf_status = XRAY_OK
      then
        begin
          for i := 0 to 63 do
            line[i] := current_page[ (value mod 4)*64 + i];
          line[64] := EOM;
          hw_count := -1;
          scan_line( line, status)
        end (* then *)
    end (* then *)
  else set_data_error
end (* display_message *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				read_file				*)
(*									*)
(*      Read in xray_file comments to be displayed with the response    *)
(*      As soon as a 'special char ' is found ( $ ), that means that    *)
(*      data form the response has to be displayed. The program then    *)
(*      reads a field from the response and displys it to the terminal  *)
(*      in the radix specified by the digit following the $ sign in file*)
(*									*)
(************************************************************************)


procedure read_file(
  var status        : transaction_status;
      command_code  : command_code_index);

var
  line         : xray_line;

begin
  count := 0;
  xf_status := XRAY_OK;
  xray_data.find_pageno( command_code, pageno);
  xray_data.read_page(pageno, current_page, xf_status);
  if xf_status = XRAY_OK
  then
    begin
      next_line(line);
      scan_line(line, status)
    end(* if xf_status*)
end (* read_file *) ;
!
(************************************************************************)
(*									*)
(*	The following procedures read the response according to the	*)
(*	command typed by the user.					*)
(*									*)
(************************************************************************)



(********************** xray_response_conversion  ***********************)
(*									*)
(*				display_crypto				*)
(*									*)
(*	Display one CRYPTO message in Autocrypto mode.                  *)
(*									*)
(************************************************************************)


procedure entry display_crypto(
  var scanned : scanned_command;
      data    : transaction_response);

var
  status  : transaction_status;

begin
  scanned.command := XRAY_LIST;
  scanned.subcommand := xray_list_crypto_keyword;
  start_response;
  status := TS_EOT;
  buffer := data;
  display_message(status);
  display_newline(1);
  scanned.command := XRAY_AUTOCRYPTO
end (* display_crypto *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			 display_set_response				*)
(*									*)
(*	Display the response to set commands .                          *)
(*									*)
(************************************************************************)


procedure display_set_response(
  var status : transaction_status;
  var scanned : scanned_command);

begin
  case scanned.subcommand of
    xray_set_linktrace_keyword :
      begin
        display_text('Trace on link to neighbor : \ ');
	display_simple_data( status, octal_blank_data)
      end;

    xray_set_symbol_keyword ,
    xray_set_utilization_keyword :
      (* empty *);

    xray_set_linetrace_keyword :
      linetrace_data( status)

  end (* case *);
  display_newline(1)
end (* display_set_response *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			display_clear_response				*)
(*									*)
(*	Display the correct response according to a given clear command.*)
(*									*)
(************************************************************************)


procedure display_clear_response(
  var status : transaction_status;
  var scanned : scanned_command);

begin
  case scanned.subcommand of
    xray_clear_linktrace_keyword :
      begin
        display_text('Trace on link to neighbor : \ ');
	display_simple_data(status, octal_blank_data)
      end;

    xray_clear_linetrace_keyword :
      linetrace_data( status);

    xray_clear_statistics_keyword :
      begin
        display_text('Statistics cleared on link to neighbor : \');
	display_simple_data( status, octal_blank_data)
      end;

    xray_clear_warning_keyword :
      (* empty *)
  end (* case *);
  display_newline(1)
end (* display_clear_response *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			display_remove_response				*)
(*									*)
(*	Display the response to remove command.                         *)
(*									*)
(************************************************************************)


procedure display_remove_response(
  var status  : transaction_status;
  var scanned : scanned_command);

begin
  case scanned.subcommand of
    xray_remove_datatrace_keyword :
      begin
        display_text('Channels being traced : \ ');
	display_default( status, 'none\ ');
        while not data_error and scan_ok( status) do
	  display_data( status, hex_blank_data, 1)
      end;

    xray_remove_badneighbor_keyword : 
      begin
        display_default( status, 'No more bad neighbor\ ');
        while not data_error and scan_ok( status) do
          display_data( status, octal_blank_data, 1)
      end;
	
    xray_remove_busyports_keyword :
      read_file( status, xray_list_busyports_code);

    xray_remove_crypto_keyword :
      (* empty *)
  end (* case *) ;
  display_newline(1)
end (* display_remove_response *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			display_change_response				*)
(*									*)
(*	Display the response to change commands.                        *)
(*									*)
(************************************************************************)


procedure display_change_response(
  var status  : transaction_status;
  var scanned : scanned_command);

begin
  if scanned.subcommand = xray_change_crashoption_keyword
  then
    begin
      display_text('Hardware : \');
      scan_data( 0, status);
      display_newline(1);
      display_text('Software : \');
      scan_data( 0, status)
    end;
  display_newline(1)
end (* display_change_response *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			display_add_response				*)
(*									*)
(*	Display responses to add commands.                              *)
(*									*)
(************************************************************************)


procedure display_add_response(
  var status  : transaction_status;
  var scanned : scanned_command);

begin
  case scanned.subcommand of
    xray_add_datatrace_keyword :
      begin
        display_text('Channels being traced : \ ');
	display_default( status, 'none\ ');
        while not data_error and scan_ok( status) do
	  display_data( status, hex_blank_data, 1)
      end;

    xray_add_badneighbor_keyword :
        while not data_error and scan_ok( status) do
          display_data( status, octal_blank_data, 1);


    xray_add_busyports_keyword :
      read_file( status, xray_list_busyports_code);
    xray_add_crypto_keyword :
      (*empty*)
  end (* case *);
  display_newline(1)
end (* display_add_response *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*				scanned_test				*)
(*									*)
(*	Test if scanned contains a certain command or subcommand.       *)
(*									*)
(************************************************************************)


function scanned_test(
  command     : command_index;
  subcommands : subcommand_set;
  scanned     : scanned_command): boolean;

begin
  scanned_test := (scanned.command=command) and (scanned.subcommand in subcommands)
end (* scanned_test *) ;


(********************** xray_response_conversion  ***********************)
(*									*)
(*				read_error_code				*)
(*									*)
(*      Read the error code from the response for commands              *)
(*      which have error codes as the first byte of the response.       *)
(*      display an error message if an error occured.                   *)
(*									*)
(************************************************************************)


procedure read_error_code(
  var status       : transaction_status;
  var no_error     : boolean;
  var scanned      : scanned_command);

var
  error_code : integer;
  size       : integer;

begin
  read_field( status, error_code, size);
  no_error := FALSE;
  
  if (error_code < ERROR_CODE_0) or (error_code > ERROR_CODE_F)
  then set_data_error
  else
    case error_code of
      ERROR_CODE_0 :
        no_error := TRUE;

      ERROR_CODE_D :
       if scanned_test(XRAY_START,[xray_start_loopbackbuilding_keyword,
                                   xray_start_delaybuilding_keyword],scanned)
       then display_line('Index in use or Out of int hst chan\')
       else 
         if scanned_test(XRAY_CHANGE,[xray_change_warning_keyword],scanned)
	 then
	   begin
	     display_line('Buffer in use\');
	     no_error := TRUE;
	     scanned.command := XRAY_LIST;
	     scanned.subcommand := xray_list_warning_keyword
           end
          else
	    if scanned_test(XRAY_LIST,[xray_list_absolute_keyword,
	      xray_list_memory_keyword, xray_list_symbol_keyword],scanned)
            then display_line('Out of range or Across segment boundary\')
	    else
	      if scanned_test(XRAY_LIST,[xray_list_performance_keyword],scanned)
	      then display_line('Neighbor is T-I\')
	      else if scanned_test(XRAY_LIST,[xray_list_utilization_keyword],scanned) 
	      then display_line('No Data, please use the Set CPU Utilization command\')
	      else set_data_error;

      ERROR_CODE_E :
        if scanned_test(XRAY_LIST,[xray_list_statistics_keyword],scanned)
	   and (xray_list_neighbor_keyword in scanned.keyword_present)
        then display_line('Statistics busy\')
	else 
	  if scanned_test(XRAY_LIST,[xray_list_memory_keyword,
	                                xray_list_symbol_keyword],scanned)
	    or scanned_test(XRAY_CHANGE,[xray_change_warning_keyword],scanned)
	  then display_line('Command in use\ ')
	  else
	    if scanned_test(XRAY_LIST,[xray_list_performance_keyword],scanned)
	    then display_line('Invalid channel or Timeout\ ')
	    else if scanned_test(XRAY_LIST,[xray_list_utilization_keyword],scanned) or
	            scanned_test(XRAY_SET,[xray_set_utilization_keyword],scanned)
            then display_line('CPU Utilization running\')
	    else set_data_error;

      ERROR_CODE_F :
        if scanned_test(XRAY_LIST,[xray_list_descriptor_keyword,
	   xray_list_statistics_keyword],scanned) and
	   (xray_list_neighbor_keyword in scanned.keyword_present) or
	   scanned_test(XRAY_CLEAR,[xray_clear_statistics_keyword],scanned) or
	   (scanned.command = XRAY_ZAP)
	then display_line('No such neighbor\ ')
	else 
	  if scanned_test(XRAY_LIST,[xray_list_channelstatus_keyword,
	     xray_list_activechannels_keyword,
	     xray_list_channeltraced_keyword],scanned) or
	     scanned_test(XRAY_ADD,[xray_add_datatrace_keyword],scanned) or
	     scanned_test(XRAY_REMOVE,[xray_remove_datatrace_keyword],scanned)
	  then display_line('Invalid channel number\ ')
	  else
	    if scanned_test(XRAY_LIST,[xray_list_portstatus_keyword],scanned) or
	       scanned_test(XRAY_LIST,[xray_list_pvcparameter_keyword],scanned) and
	       (xray_list_port_keyword in scanned.keyword_present) or
	       (scanned.command = XRAY_HANG) or
	       scanned_test(XRAY_ADD,[xray_add_busyports_keyword],scanned) or
	       scanned_test(XRAY_REMOVE,[xray_remove_busyports_keyword],scanned)
	    then display_line('Invalid port number\')
	    else
              if scanned_test(XRAY_LIST,[xray_list_symbol_keyword],scanned)
	      then display_line('Not symbol in table\')
	      else if scanned.command = XRAY_START
	      then display_line('Invalid or T-I Node number entered\ ')
	      else if scanned.command = XRAY_STOP
	      then display_line('Index not in use\ ')
	      else if scanned_test(XRAY_LIST,[xray_list_hostinfo_keyword],scanned)
	      then display_line('Invalid host number\')
	      else if scanned_test(XRAY_LIST,[xray_list_slotinfo_keyword],scanned)
	      then display_line('Invalid slot number\')
	      else if scanned_test(XRAY_LIST,[xray_list_pvcparameter_keyword,
	                xray_list_utilization_keyword],scanned)  or
	              scanned_test(XRAY_SET,[xray_set_utilization_keyword],scanned)
	      then display_line('Command unavailable\')
	      else display_line('Unexpected input or Command unavailable\');

      ERROR_CODE_1, ERROR_CODE_2, ERROR_CODE_3, ERROR_CODE_4,
      ERROR_CODE_5, ERROR_CODE_6, ERROR_CODE_7, ERROR_CODE_8,
      ERROR_CODE_9, ERROR_CODE_A, ERROR_CODE_B, ERROR_CODE_C:
        set_data_error
    end (* case *)
end (* read_error_code *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			read_display_response				*)
(*									*)
(*      Call the correct procedure in order to display the              *)
(*      response to a specified command.                                *)
(*									*)
(************************************************************************)


procedure read_display_response(
  var status       : transaction_status;
  var scanned      : scanned_command;
      command_code : command_code_index);

var
  no_error : boolean;

begin
  no_error := TRUE;
  case scanned.subcommand of
    xray_list_rings_keyword ,
    xray_list_descriptor_keyword ,
    xray_list_portstatus_keyword ,
    xray_list_performance_keyword ,
    xray_list_hostinfo_keyword ,
    xray_list_pvcparameter_keyword ,
    xray_list_patch_keyword ,
    xray_list_busyports_keyword ,
    xray_list_utilization_keyword ,
    xray_list_slotinfo_keyword :
      read_file( status, command_code);

    xray_list_statistics_keyword :
      if xray_list_buffers_keyword in scanned.keyword_present
      then bufferstat_data( status)
      else read_file( status, command_code);

    xray_list_errors_keyword :
      begin
        display_default( status, 'No semiconductor error\ ');
        while not data_error and scan_ok(status) and
	      not user_terminal.break_pending do
          begin
            read_file( status, command_code);
	    display_newline(1)
          end;
        check_break
      end;
    
    xray_list_channelstatus_keyword :
      begin
        while not data_error and scan_ok( status) and
	      not user_terminal.break_pending do
          begin
            read_file( status, command_code);
	    display_newline(2)
          end;
	check_break
      end;

    xray_list_badneighbor_keyword :
      begin
        display_default( status, 'No bad neighbor\');
        while not data_error and scan_ok( status) do
          display_data(status,octal_blank_data, 1)
      end;

    xray_list_linktrace_keyword :
      begin
        display_text('Trace on link to neighbor : \ ');
	display_simple_data( status, octal_blank_data)
      end;

    xray_list_linforeground_keyword :
      linforeground_data(status);

    xray_list_linbackground_keyword :
      linbackground_data(status);

    xray_list_warning_keyword :
      warning_data( status);

    xray_list_sioringstatus_keyword :
      sioringstatus_data(status);

    xray_list_channeltraced_keyword :
      begin
        display_text('Channels being traced : \ ');
	display_default( status, 'none\ ');
        while not data_error and scan_ok( status) do
	  display_data( status, hex_blank_data, 1)
      end;

    xray_list_crash_keyword :
      if xray_list_tables_keyword in scanned.keyword_present
      then
        begin
          crashsummary_data(status);
  	  display_newline(1);
	  crashdetail_data( status)
        end
      else if xray_list_options_keyword in scanned.keyword_present
      then
        begin
	  display_text('Hardware : \');
	  scan_data( 0, status);
	  display_newline(1);
	  display_text('Software : \');
	  scan_data( 0, status)
	end
      else if xray_list_detail_keyword in scanned.keyword_present
      then crashdetail_data( status)
      else crashsummary_data( status);

    xray_list_linetraced_keyword :
      linetrace_data( status);
 
    xray_list_activechannels_keyword :
      begin
        display_text('  \ ');
	display_default( status, 'No active channel\');
        while not data_error and scan_ok( status) do
          display_data( status, hex_data, 1)
        end;

    xray_list_memory_keyword ,
    xray_list_absolute_keyword ,
    xray_list_symbol_keyword :
      while scan_ok( status) and not data_error and no_error do
        begin
          display_data( status, hex_data, 1);
          display_text(': \ ');
          display_multiple_data( status, 8, hex_data);
	  if scan_ok(status) and not data_error
	  then read_error_code(status,no_error,scanned)
	end (* while *) ;

    xray_list_symbols_keyword :
      begin
        display_default( status, 'No symbol\');
        while scan_ok(status) and not data_error do
          begin
	    display_data(status, charact, 1);
	    display_simple_data( status, hex_data);
	    display_newline(1)
	  end;
      end;

    xray_list_datatrace_keyword :
      if scan_ok(status)
      then datatrace_data( status, scanned)
      else display_line('No traced data\ ');

    xray_list_register_keyword :
      display_multiple_data( status, 16, hex_data);

    xray_list_crypto_keyword :
      begin
        display_default( status, 'No message\ ');
        while not data_error and scan_ok( status) and
	      not user_terminal.break_pending do
          begin
            display_message( status);
	    display_newline(1)
	  end;
	check_break
      end

  end(*case*);
  display_newline(1)
end (* read_display_response *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			convert_xray_response				*)
(*									*)
(*	Convert and display the response to XRAY commands.              *)
(*									*)
(************************************************************************)


procedure entry convert_xray_response(
  var scanned      : scanned_command;
  var status       : transaction_status;
      command_code : command_code_index);

var
  no_error : boolean;

begin
  start_response;
  display_newline(1);
  read_error_code(status,no_error, scanned);
  if no_error
  then
    case scanned.command of
      XRAY_LIST :
       read_display_response( status, scanned, command_code);
      XRAY_SET :
        display_set_response( status, scanned);
      XRAY_CLEAR :
        display_clear_response( status, scanned);
      XRAY_REMOVE :
        display_remove_response( status, scanned);
      XRAY_CHANGE :
        display_change_response( status, scanned);
      XRAY_ADD :
        display_add_response( status, scanned);
      XRAY_INITIALIZE ,
      XRAY_HANG ,
      XRAY_ZAP ,
      XRAY_RESTART ,
      XRAY_START ,
      XRAY_STOP ,
      XRAY_WRITE :
        (* empty *);
      XRAY_AUTOCRYPTO ,
      XRAY_HELP ,
      XRAY_POWER :
        scanned.status := RUN_ERROR
    end (* case *)
  else
    scanned.status := RUN_ERROR;
  if data_error
  then status := TS_FAILURE;
  if xf_status <> XRAY_OK 
  then
    begin
      data_error := FALSE;
      format.start;
      display_line('File error, please try again\ ')
    end(* then *)
end (* convert_xray_response *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			display_help_response				*)
(*									*)
(*	Display response to help commands				*)
(*									*)
(************************************************************************)


procedure entry display_help_response(
  command_code : command_code_index);

var
  status : transaction_status;

begin
  start_response;
  status := TS_OK;
  display_newline(1);
  read_file( status, command_code);
  display_newline(1);
  if xf_status <> XRAY_OK 
  then
    begin
      format.start;
      display_line('File error, please try again\ ')
    end(* then *)
end (* display_help_response *) ;



(********************** xray_response_conversion  ***********************)
(*									*)
(*			set_configuration				*)
(*									*)
(************************************************************************)


procedure entry set_configuration(
  new_configuration : configurations);

begin
  configuration := new_configuration
end (* set_configuration *) ;

!
(************************************************************************)
(************************************************************************)


begin (* initial statement *)
  indentation := 0
end (* xray_response_conversion *) ;
$endif
   $if xray
!
(************************************************************************)
(*									*)
(*	XRYCMD.TMS							*)
(*									*)
(*				xray_commands				*)
(*									*)
(*	This class contains the various xray interface commands         *)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Jun84 Original -- foa						*)
(*	20Jan86 Adapted from NTCN into TMCS and modify			*)
(*		entry scan_xray_command -- gde				*)
(*									*)
(************************************************************************)


type
  xray_commands =
    class(
      user              : user_index;
      profile           : user_profile;
      argument_scan     : argument_scanner;
      user_terminal     : circuit_handler;
      format            : internal_to_string;
      logger		: log_command_handler;
      display		: display_execution;
      oper_msgs         : operator_messages;
      command_read      : command_loop;
      scan_error        : command_error_message;
      job_common        : global_job_data;
      name_common	: global_name_data;
      connection        : spc_connect;
      data_transfer     : spc_data_transfer;
      commands          : command_table;
      xray_data         : xray_data_manager;
      node_list		: node_list_manager;
      crypto_log	: xray_crypto);

!
const
  command_parameters_max = transaction_command_text_max -2;
  command_parameters_limit = command_parameters_max -1;

type
  command_parameters_text_index = 0..command_parameters_limit;
  command_parameters_text_size = 0..command_parameters_max;

type
  command_parameters_text = array[command_parameters_text_index] of char;

type
  command_parameters_list =
    record
      size : command_parameters_text_size;
      text : command_parameters_text
    end;


const
  ERROR_CODE_0 = '(:176:)'; (* '0' with first bit set to 1 : hex B0 *)

type
  xray_crypto_status = ( CY_OK, CY_ERROR_CODE, CY_TS_ERROR);

(* a field is a piece of data sent to or received from the node code   *)
(*                                                                      *)
(* A field is a certain number of ASCII characters representnig         *)
(* an integer in hex or a symbol.                                       *)
(* In order to separate two different fields representing two           *)
(* different pieces of data, the first ASCII char of the field          *)
(* has its first bit set to 1.                                          *)
const
  field_text_max = 16;
  field_text_limit = field_text_max -1;

type
  field_text_index = 0..field_text_limit;
  field_size_index = 0..field_text_max;

type
  field =
    record
      size : field_size_index;
      text : array[ field_text_index] of char
    end;

const
  CRYPTO_RESPONSE_TEXT_MAX = 32;(* chars : 1FW,1HW,1Byte,1Byte,4HW *)
!
var
  host_operator      : host_utility;
  host_circuit       : spc_terminal_utility;
  xray_response      : xray_response_conversion;
  password_scanner   : password_reader;

  xray_data_field    : network_console_host_profile;

  command_code       : command_code_index;(* contain command code of command*)
  command_parameters : command_parameters_list;(*parameters sent with command*)
  configuration      : configurations;(* node configuration *)
  current_license    : license;(* a user is non privileged until he gets power*)
  host		     : integer;
!




(**********************      xray_commands        ***********************)
(*									*)
(*		   increment_command_code				*)
(*									*)
(*	Increment command code                           		*)
(*									*)
(************************************************************************)


procedure increment_command_code(
  increment : integer);

begin
  if ((command_code + increment) < command_code_max)
  then command_code := command_code +increment
end (* increment_command_code *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				set_first_bit				*)
(*									*)
(*	Set first bit of char to 1 . When a field of data is sent to	*)
(*	XRAYthe first bit of the first char is set to 1 so that the Node*)
(*	can recognize this character as the beginning of a new piece	*)
(*	of data..							*)
(*									*)
(************************************************************************)


procedure set_first_bit(
  var byte : char);

begin
  byte := chr(ord(byte) + 128)
end (* set_first_bit *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				convert_number				*)
(*									*)
(*	Convert an integer to an array of ASCII characters representing	*)
(*	this number in hex.             				*)
(*									*)
(************************************************************************)


procedure convert_number(
      value        : integer;
  var data_to_send : field);

var
  number : integer;
  n      : integer;
  data   : integer;

begin
  for n := 0 to field_text_limit do data_to_send.text[n] := '0';
  n := -1;
  number := value;
  repeat
    n := n+1;
    data := number mod 16;
    if data < 10 
    then data_to_send.text[field_text_limit-n] := chr(ord('0') + data)
    else data_to_send.text[field_text_limit-n] := chr(ord('A') + data-10);
    number := number div 16;
  until number = 0;
  data_to_send.size := n+1
end (* convert_number *) ;



(***************************   xray_commands  ***************************)
(*									*)
(*			generate_command_begin				*)
(*									*)
(*	Begin a command by initializing everything.                     *)
(*									*)
(************************************************************************)


procedure generate_command_begin;

begin
  command_code := 0;
  command_parameters.size := 0;
  format.start
end (* generate_command_begin *) ;



(************************** xray_commands *******************************)
(*									*)
(*				copy_buffer				*)
(*									*)
(*	Copy command code and parameters into format buffer             *)
(*									*)
(************************************************************************)


procedure copy_buffer;

var
  i     : integer;
  data  : field;

begin
  convert_number( command_code, data);
  set_first_bit(data.text[field_text_max-2]);
  for i := (field_text_max - 2) to (field_text_limit) do
    format.character(data.text[i]);
  if command_parameters.size > 0
  then
    for i:= 0 to (command_parameters.size-1) do
      format.character(command_parameters.text[i])
end (* copy_buffer *) ;



(****************************  xray_commands  ***************************)
(*									*)
(*			generate_command_end				*)
(*									*)
(*	Add command code in the buffer. Add also command parameters.	*)
(*									*)
(************************************************************************)


procedure generate_command_end(
  var scanned : scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then copy_buffer
end (* generate_command_end *) ;
!



(**********************      xray_commands        ***********************)
(*									*)
(*				add_byte				*)
(*									*)
(*	Add a byte to command_parameters.                               *)
(*									*)
(************************************************************************)


procedure add_byte(
  byte : char);

begin
  command_parameters.text[ command_parameters.size] := byte;
  command_parameters.size := command_parameters.size + 1
end (* add_byte *) ;



(***************************  xray_commands  ****************************)
(*									*)
(*				add_integer				*)
(*									*)
(*	Insert an integer in command parameters.                        *)
(*									*)
(************************************************************************)


procedure add_integer(
  var scanned : scanned_command;
      value   : integer;
      length  : integer;
      limit   : integer);

var
  data : field;
  start: integer;
  i    : integer;

begin
  if (limit <> MAX_INTEGER) and ((value < 0) or (limit+1 <= value))
  then scanned.status := ARG_NUMBER_TOO_LARGE
  else
    begin
      convert_number( value,data);
      start := field_text_max -  length;
      set_first_bit(data.text[ start]);
      for i := start to field_text_limit do
        add_byte(data.text[i])
    end (* else *)
end (* add_integer *) ;



(*************************** xray_commands ******************************)
(*									*)
(*				generate_number				*)
(*									*)
(*      Insert the hex for the specified integer in command             *)
(*      parameters. Must be positive and not too large.                 *)
(*									*)
(************************************************************************)


procedure generate_number(
  var scanned  :scanned_command;
      keyword  : command_keyword_index;
      value    : integer);

var
  length, limit : integer;

begin
  limit := xray_data.max( scanned, keyword);
  length := xray_data.length( scanned, keyword);
  add_integer( scanned, value, length, limit)
end (* generate_number *) ;



(**********************      xray_commands        ***********************)
(*									*)
(*			generate_keyword_value				*)
(*									*)
(*	Scan the specified keyword value and add it to the command      *)
(*      if present. Generate an ARG_KEYWORD_MISSING if                  *)
(*      required and not present. Modify command_code if the            *)
(*      keyword is present :                                            *)
(*            - no modification if the keyword is required              *)
(*            - add 1 to command_code if not required and present       *)
(*            - no modification if not required and not present         *)
(*									*)
(************************************************************************)


procedure generate_keyword_value(
  var scanned    : scanned_command;
      keyword    : command_keyword_index;
      required   : boolean;
  var present    : boolean;
  var value      : integer);

begin
  value := 0;
  present := FALSE;
  if argument_scan.check_keyword(keyword,scanned)
  then
    begin
      argument_scan.keyword_number(keyword,xray_data.radix(scanned,keyword),scanned,value);
      present := TRUE
    end(*if argument..then*)
  else
    begin
      if required
      then scanned.status := ARG_KEYWORD_MISSING;
      present := FALSE
    end(* else *);
  if present and (scanned.status = CMD_OK)
  then
    begin
      generate_number(scanned,keyword,value);
      if not required
      then increment_command_code(1)
    end(* if present then*)
end (* generate_keyword_value *) ;


(****************************  xray_commands  ***************************)
(*									*)
(*				generate_range				*)
(*									*)
(*	Scan the specified keyword and look for one argument            *)
(*	or two arguments separated by a dash '-'.Add parameters         *)
(*	in command_parameters and modify command code by incrementing it*)
(*	if one of the 2 arg is present and not required.                *)
(*									*)
(************************************************************************)


procedure generate_range(
  var scanned        : scanned_command;
      keyword        : command_keyword_index;
      required       : boolean;
      range_required : boolean;
      count          : boolean);

var
  first,last : integer;
  min        : integer;

begin
  if argument_scan.check_keyword(keyword,scanned)
  then
    begin
      argument_scan.keyword_pair(keyword,xray_data.radix(scanned,keyword),scanned,first,last);
      if first > last
      then
        begin
          min := last;
          last := first;
          first := min
        end;
      if scanned.status = CMD_OK
      then
        if (first = last)
        then
          if range_required
          then scanned.status := ARG_MISSING
          else
            begin
              generate_number(scanned,keyword,first);
              if not required
              then increment_command_code(1)
            end (* then *)
	else
          begin
	    generate_number( scanned, keyword, first);
	    if count
  	    then generate_number(scanned, xray_list_range_keyword,last - first)
            else generate_number(scanned,keyword,last);
	    if not required
	    then increment_command_code(1);
	    if not range_required
	    then increment_command_code(1)
          end (* if first *)
    end (* if argument_scan...then *)
  else
    if required then scanned.status := ARG_KEYWORD_MISSING
end (* generate_range *) ;



(**************************     xray_commands  **************************)
(*									*)
(*			generate_keyword_text				*)
(*									*)
(*	Check an argument for a quoted string and insert it in          *)
(*	command parameters, in upper case if specified.                 *)
(*									*)
(************************************************************************)


procedure generate_keyword_text(
  var scanned    : scanned_command;
      keyword    : command_keyword_index;
      length     : integer;
      upper_case : boolean);

var
  input_line : quoted_string;
  i          : integer;

begin
  argument_scan.keyword_quoted_string(keyword,scanned,input_line);
  if scanned.status = CMD_OK
  then
    if input_line.size > length
    then scanned.status := ARG_TEXT_TOO_LONG
    else
      begin
        if upper_case
        then
          for i := 0 to (input_line.size -2) do
            if (input_line.text[i] >= 'a') and (input_line.text[i] <= 'z')
	    then input_line.text[i] := chr(ord(input_line.text[i])-ord('a')+ord('A'))
	    else
	      if (input_line.text[i]<='(:31:)') or (input_line.text[i]>='(:127:)')
	      then input_line.text[i] := ' ';
          set_first_bit(input_line.text[0]);
          for i := 0 to (input_line.size - 1) do
            add_byte( input_line.text[i]);
          add_byte('(:13:)')
      end
end (* generate_keyword_text *) ;

!

(****************************  xray_commands  ***************************)
(*									*)
(*				generate_option				*)
(*									*)
(*	Scan the specified keyword index for an option                  *)
(*      If required check if option present. If present,                *)
(*      add increment to command_code.                                  *)
(*									*)
(************************************************************************)


procedure generate_option(
  var scanned  : scanned_command;
      keyword  : command_keyword_index;
      required : boolean;
  var present  : boolean;
      increment: integer);


begin
  if not((keyword >= first_xray_list_option_subcommand) and
     (last_xray_list_option_subcommand >= keyword) or
     (keyword = xray_start_backforth_keyword))
  then
    begin
      oper_msgs.operator_message('XRAY option error\');
      scanned.status := ARG_SYSTEM_ERROR;
      present := FALSE
    end
  else
    begin
      present := FALSE;
      if argument_scan.check_keyword(keyword,scanned)
      then
        begin
          if (scanned.status=CMD_OK) then
	    increment_command_code(increment);
          present := TRUE
        end (*then *);
      if required and not present
      then scanned.status := ARG_MISSING
    end (* else *)
end (* generate_option *) ;
!



(**********************      xray_commands        ***********************)
(*									*)
(*				generate_symbol				*)
(*									*)
(*	Scan the specified symbol and add it to the command.            *)
(*									*)
(************************************************************************)


procedure generate_symbol(
  var scanned  : scanned_command;
      required : boolean;
      quoted   : boolean;
      size_max : integer);

var
  i     : integer;
  value : quoted_string;
  aux   : symbol;

begin
  if scanned.freeword_count > 0
  then
    begin
      if quoted
      then argument_scan.freeword_quoted_string(0,scanned,value)
      else
        begin
	  argument_scan.freeword_symbol(0,scanned,aux);
	  for i := 0 to (aux.size-1) do
	    value.text[i] := aux.text[i];
	  value.size := aux.size
	end; (* else *)
      if (value.size>size_max) and (scanned.status = CMD_OK)
      then scanned.status := ARG_SYMBOL_TOO_LONG;
      if scanned.status = CMD_OK
      then
        begin
	  set_first_bit(value.text[0]);
          for i := 0 to (value.size-1) do add_byte(value.text[i]);
          if value.size < size_max
	  then for i:=1 to (size_max - value.size) do add_byte(' ')
        end(* if scanned...then *)
    end (* then *)
  else
    if required
    then scanned.status := ARG_FREEWORD_MISSING
end (* generate_symbol *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				find_token				*)
(*									*)
(*	Find next separator and set up token.                           *)
(*									*)
(************************************************************************)


procedure find_token(
      input_line : command_line;
  var token      : command_token;
  var found      : boolean);

begin
  while input_line.text[token.finish] = ASC_SPACE do
    token.finish := token.finish +1;
  token.start := token.finish;
  while (input_line.text[token.finish] <> ASC_SPACE) and
        (input_line.text[token.finish] <> ASCCR) do
    token.finish := token.finish +1;
  found := token.finish > token.start
end (* find_token *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				scan_integer				*)
(*									*)
(*	Look for an integer in input line.                              *)
(*									*)
(************************************************************************)


procedure scan_integer(
  var scanned	 	: scanned_command;
      input_line	: command_line;
      radix		: integer;
  var value		: integer;
  var token		: command_token;
  var found		: boolean);

var
  scanned_line : command_line;

begin
  value := 0;
  scanned_line := scanned.input_line;
  scanned.input_line := input_line;
  find_token( input_line, token, found);
  if found
  then argument_scan.get_number( radix, token, scanned, value);
  scanned.input_line := scanned_line
end (* scan_integer *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				read_integer				*)
(*									*)
(*	Prompt the user for an integer list. If more than 1 integer,	*)
(*	add the number of integers  in command parameters, then add	*)
(* 	integers in parameters.						*)
(*									*)
(************************************************************************)


procedure read_integer(
  var scanned     : scanned_command;
      output_line : message_string;
      limit       : integer;  (* max value *)
      radix	  : integer;  (* radix *)
      list_max    : integer;  (* max list length *)
      default     : integer); (* default if not present *)

var
  input_line : command_line;
  max        : integer;
  token      : command_token;
  found	     : boolean;
  value	     : integer;
  i	     : integer;

begin
  if user_terminal.sendable and ( scanned.status = CMD_OK)
  then
    begin
      user_terminal.write_newline;
      user_terminal.write_string(output_line);
      user_terminal.read_command_line(input_line);

      if limit > 65535 (* hex FFFF *)
      then max := 8
      else if limit > 255 (* hex FF *)
      then max := 4
      else max := 2;
          
      if input_line.size > 1
      then
        begin
          for i := 0 to (input_line.size-1) do
            if (input_line.text[i]>='a') and (input_line.text[i]<='f')
            then input_line.text[i]:=chr(ord(input_line.text[i])-ord('a')+ord('A'));

	  token.finish := 0;
	  i := 0;
	  repeat
	    find_token(input_line,token,found);
	    if found 
	    then i := i+1
	  until not found;
	  if list_max > 1
	  then add_integer(scanned,i,2,255);
	  if i > list_max
	  then scanned.status := TOO_MANY_ARGS;

          token.finish := 0;
          i := 0;
          repeat
            i := i +1;
            scan_integer( scanned,input_line,radix,value,token,found);
            if (scanned.status = CMD_OK) and found
            then add_integer( scanned, value, max, limit)
          until not found or (scanned.status <> CMD_OK) or (i >= list_max);
          if (i = 1) and not found
          then scanned.status := ARG_MISSING
        end (* if input_line.size..then *)
      else
        if default <> MAX_INTEGER
	then add_integer(scanned,default,max,limit)
	else scanned.status := ARG_MISSING
    end (* then *)
end (* read_integer *) ;
!




(****************************  xray_commands  ***************************)
(*									*)
(*				run_command				*)
(*									*)
(*	Send compiled command to XRAY and interpret response            *)
(*									*)
(************************************************************************)


procedure run_command(
  var scanned   : scanned_command;
  var status    : transaction_status);

var
  command : transaction_command;

begin
  format.copy_transaction_command(command);
  host_circuit.start_transaction(status);
  if status = TS_OK
  then host_circuit.send(command,status);
  if status = TS_OK
  then xray_response.convert_xray_response(scanned,status,command_code);
  host_circuit.finish_transaction
end (* run_command *) ;
!



(************************** xray_commands *******************************)
(*									*)
(*				send_command				*)
(*									*)
(*	Send an Autocrypto command                                      *)
(*									*)
(************************************************************************)


procedure send_command(
  var status        : transaction_status;
  var crypto_status : xray_crypto_status);

var
  command : transaction_command;
  buffer  : transaction_response;
  
begin
  copy_buffer;
  format.copy_transaction_command( command);
  host_circuit.start_transaction( status);
  if status = TS_OK
  then host_circuit.send( command, status)
  else crypto_status := CY_TS_ERROR;
  if status = TS_OK
  then
    begin
      buffer.size := 1; (* error_code only *)
      host_circuit.receive( buffer, status);
      if (status = TS_OK) or (status = TS_EOT)
      then
        if buffer.text[0] <> ERROR_CODE_0
	then crypto_status := CY_ERROR_CODE
    end (* then *)
end (* send_command *) ;



(************************** xray_commands *******************************)
(*									*)
(*				disconnect				*)
(*									*)
(*	Stop autocrypto mode. Called by receive_crypto.                 *)
(*									*)
(************************************************************************)


procedure disconnect(
  var crypto_status : xray_crypto_status;
  var status        : transaction_status);

begin
  host_circuit.finish_transaction;
  generate_command_begin;
  command_code := xray_autocrypto_off_code;
  send_command( status, crypto_status);
  if (crypto_status <> CY_OK) and user_terminal.available
  then
    case crypto_status of
      CY_ERROR_CODE :
        user_terminal.write_string('(:13:)(:10:)Unexpected input(:13:)(:10:)\ ');
      CY_TS_ERROR :
        user_terminal.write_string('(:13:)(:10:)Transaction error(:13:)(:10:)\')
    end (* case *);
  host_circuit.finish_transaction
end (* disconnect *) ;



(*************************   xray_commands    ***************************)
(*									*)
(*				connect					*)
(*									*)
(*	Send the autocrypto command to XRAY.                            *)
(*									*)
(************************************************************************)


procedure connect(
  var crypto_status : xray_crypto_status;
  var status        : transaction_status);

begin
  crypto_status := CY_OK;
  generate_command_begin;
  command_code := xray_autocrypto_on_code;
  send_command( status, crypto_status);
  crypto_log.connect_error( user, crypto_status=CY_OK )
end (* connect *) ;



(************************** xray_commands *******************************)
(*									*)
(*				receive_crypto				*)
(*									*)
(*	Wait for CRYPTO messages, send them to crypto manager           *)
(*	and display them to the terminal. Called only if no             *)
(* 	other user in autocrypto mode on the current node               *)
(*									*)
(************************************************************************)


procedure receive_crypto(
  var scanned        : scanned_command;
  var status         : transaction_status;
  var crypto_status  : xray_crypto_status);

var
  buffer         : transaction_response;

begin
  if (crypto_status = CY_OK) and ( status = TS_OK)
  then
    repeat
      buffer.size := CRYPTO_RESPONSE_TEXT_MAX;
      host_circuit.receive( buffer, status);
      if status = TS_OK
      then
        begin
          crypto_log.add_message( buffer, user);
	  xray_response.display_crypto( scanned, buffer)
        end (* then *);
      user_terminal.check_circuit
    until not user_terminal.available or
          user_terminal.break_pending or (status <> TS_OK) ;
  crypto_log.disconnect( user);
  if (status = TS_OK)
  then disconnect( crypto_status, status)
  else host_circuit.finish_transaction
end (* receive_crypto *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				read_crypto				*)
(*									*)
(*      Wait for new crypto messages and display them                   *)
(*									*)
(************************************************************************)


procedure read_crypto(
  var scanned : scanned_command);

var
  next_message : transaction_response;
  found        : boolean;

begin
  repeat
    crypto_log.read_message( next_message, found, user);
    if found
    then xray_response.display_crypto( scanned, next_message)
    else user_terminal.check_circuit
  until not user_terminal.available or
        user_terminal.break_pending or
	crypto_log.transaction_lost(user)
end (* read_crypto *) ;



(**********************      xray_commands        ***********************)
(*									*)
(*			starting_message				*)
(*									*)
(*	Print a message at the beginning of an Autocrypto session.	*)
(*									*)
(************************************************************************)


procedure starting_message(
  starting : boolean);

begin
  format.start;
  if user_terminal.available and not user_terminal.break_pending
  then
    if starting
    then
      begin
        format.string('Starting Autocrypto  \');
	format.time(profile.time(realtime));
	format.write_line(user_terminal)
      end
    else
      begin
        format.string('Autocrypto stopped   \');
	format.time(profile.time(realtime));
	format.newline;
	format.string('Restarting Autocrypto\');
	format.write_line(user_terminal)
      end;
  format.start
end (* starting_message *) ;



(************************** xray_commands *******************************)
(*									*)
(*				run_autocrypto				*)
(*									*)
(*	Set or clear Autocrypto mode                                    *)
(*									*)
(************************************************************************)


procedure run_autocrypto(
  var scanned       : scanned_command;
  var status        : transaction_status;
  var crypto_status : xray_crypto_status);

var
  connected   : boolean;

begin
  crypto_log.set_autocrypto( user, host, connected);

  if connected
  then
    begin
      starting_message(TRUE);
      read_crypto( scanned);
      crypto_log.clear_autocrypto( user)
    end (* then *)
  else
    begin
      connect( crypto_status, status);
      if status = TS_OK
      then starting_message(TRUE);
      receive_crypto( scanned, status, crypto_status)
    end (* else *)
 end (* run_autocrypto *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				scan_autocrypto				*)
(*									*)
(*      Set autocrypto mode by calling crypto_log. Clear it when break. *)
(*									*)
(************************************************************************)


procedure scan_autocrypto(
  var scanned : scanned_command;
  var status  : transaction_status);

var
  crypto_status : xray_crypto_status;

begin
  crypto_status := CY_OK;
  argument_scan.extra_argument_check( scanned);
  if scanned.status = CMD_OK
  then
    begin
      repeat
        run_autocrypto( scanned, status, crypto_status);
	if status = TS_OK
	then starting_message(FALSE)
      until not user_terminal.available or
            user_terminal.break_pending or (status <> TS_OK) or
	    (crypto_status <> CY_OK);
      if user_terminal.break_pending
      then
        begin
          user_terminal.clear_break_status;
          user_terminal.write_string('<break>(:13:)(:10:)\')
        end (* then *)
    end (* then *)
end (* scan_autocrypto *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				scan_getpower				*)
(*									*)
(*	Allow the user to change current_license to his best license.   *)
(*									*)
(************************************************************************)


procedure scan_getpower(
  var scanned : scanned_command);

var
  password : integer;

begin
  argument_scan.extra_argument_check( scanned);
  if scanned.status = CMD_OK
  then
    begin
      profile.password(password);
      if password_scanner.cipher_check('password: \ ',password)
      then
        begin
          current_license := XRAY_LICENSE;
          while (current_license < XRAY_HYPER_PRIVILEGED_LICENSE)
                 and profile.license_check(current_license) do
          current_license := succ(current_license)
        end (* then *)
      else scanned.status := RUN_ERROR
    end (* then *)
end (* scan_getpower *) ;
!



(**********************       xray_commands       ***********************)
(*									*)
(*			generate_start_command				*)
(*									*)
(*	Insert command_code and command_parameters for the start command *)
(*									*)
(************************************************************************)


procedure generate_start_command(
  var scanned : scanned_command);

var
  value   : integer;
  present : boolean;

begin
  case scanned.subcommand of
    xray_start_delaybuilding_keyword :
      begin
        command_code := xray_start_delaybuilding_code;
	generate_option(scanned,xray_start_backforth_keyword,FALSE,present,2);
        generate_keyword_value(scanned,xray_start_index_keyword,FALSE,present,value);
	if present
	then
	  begin
	    read_integer(scanned,'Priority (0 or 1) : \ ',1,10,1,0);
	    read_integer(scanned,'Tp Class (0....3) : \ ',3,10,1,3);
	    read_integer(scanned,'Byte fill (< FFFF): \ ',65535,16,1,0);
	    read_integer(scanned,'Rate     (0....7) : \ ',7,8,1,3)
          end;
	if xray_start_backforth_keyword in scanned.keyword_present
	then read_integer(scanned,'T-II Node         : \ ',NODE_NUMBER_MAX,8,1,MAX_INTEGER)
	else read_integer(scanned,'T-II Node list    : \ ',NODE_NUMBER_MAX,8,8,MAX_INTEGER)
      end;

    xray_start_loopbackbuilding_keyword :
      begin
        command_code := xray_start_loopbackbuilding_code;
	generate_option(scanned,xray_start_backforth_keyword,FALSE,present,22);
        generate_keyword_value(scanned,xray_start_index_keyword,FALSE,present,value);
	if present
	then
	  begin
	    read_integer(scanned,'Priority (0 or 1) : \ ',1,10,1,0);
	    read_integer(scanned,'Tp Class (0....3) : \ ',3,10,1,3);
	    read_integer(scanned,'Byte Fill (< FFFF): \ ',65535,16,1,0)
	  end;
        if xray_start_backforth_keyword in scanned.keyword_present
	then read_integer(scanned,'T-II Node         : \ ',NODE_NUMBER_MAX,8,1,MAX_INTEGER)
	else read_integer(scanned,'T-II Node list    : \ ',NODE_NUMBER_MAX,8,8,MAX_INTEGER)
      end

  end (* case *)
end (* generate_start_command *) ;



(**********************     xray_commands         ***********************)
(*									*)
(*			generate_memory_count				*)
(*									*)
(*	Generate the count in memory commands ( feeword).               *)
(*									*)
(************************************************************************)


procedure generate_memory_count(
  var scanned : scanned_command;
  var aux_code: integer;
  var value   : integer);

var
  command  : command_index;
  fullword : boolean;

begin
  fullword := (scanned.command = XRAY_WRITE) and ((xray_write_fullword_keyword
              in scanned.keyword_present) or (scanned.subcommand =
	      xray_write_absolute_keyword));
  value := 1;
  if scanned.freeword_count > argument_scan.freeword_used
  then
    begin
      command := scanned.command;
      scanned.command := XRAY_LIST;
      argument_scan.freeword_number(argument_scan.freeword_used,
        xray_data.radix(scanned,xray_list_range_keyword),scanned,value);
      scanned.command := command;
      if (value > 44) and (scanned.command = XRAY_WRITE)
      (* 44 bytes is 88 chars and command string has to be < 100 chars *)
      then scanned.status := ARG_NUMBER_TOO_LARGE
      else
        begin
	  if fullword
	  then if (value mod 4 <> 0)
	  then value := (value div 4 +1) *4
	  else (* empty *)
	  else if (value mod 2 <> 0)
	  then value := (value div 2 +1) *2;
	  generate_number(scanned,xray_list_range_keyword,value)
	end;
      aux_code := aux_code +1;
      increment_command_code(1)
    end
end (* generate_memory_count *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				read_data				*)
(*									*)
(*      Prompt the user for fullwords and halfwords and read them.      *)
(*									*)
(************************************************************************)


procedure read_data(
  var scanned : scanned_command;
  var value   : integer);

var
  i          : integer;

begin
  i := 0;
  if (xray_write_fullword_keyword in scanned.keyword_present) or
     (scanned.subcommand = xray_write_absolute_keyword)
  then value := value div 4
  else value := value div 2;
  if value <= 0
  then scanned.status := ARG_ERROR
  else
    while (i < value) and (scanned.status = CMD_OK)  do
      begin
	if ((scanned.subcommand = xray_write_memory_keyword) and
	   (xray_write_fullword_keyword in scanned.keyword_present)) or
	   (scanned.subcommand = xray_write_absolute_keyword)
        then read_integer(scanned,'Enter 1 Fullword : \', MAX_INTEGER,16,1,MAX_INTEGER)
	else read_integer(scanned,'Enter 1 Halfword : \', 65535,16,1,MAX_INTEGER);
	i := i +1
      end (* while *)
end (* read_data *) ;



(************************** xray_commands *******************************)
(*									*)
(*				read_memory				*)
(*									*)
(*	Display memory before allowing to write in it.                  *)
(*									*)
(************************************************************************)


procedure read_memory(
  var status   : transaction_status;
      aux_code : command_code_index;
      address  : integer;
      count    : integer;
  var error    : boolean);

var
  i         : integer;
  aux_param : command_parameters_list;
  scanned   : scanned_command;
  code      : integer;

begin
  aux_param := command_parameters;
  command_parameters.size := 0;
  code := command_code;
  command_code := aux_code;
  scanned.command := XRAY_LIST;
  scanned.subcommand := xray_list_memory_keyword;
  scanned.status := CMD_OK;
  generate_number( scanned, xray_list_memory_keyword, address);
  if count <> 0
  then generate_number( scanned, xray_list_range_keyword, count);
  copy_buffer;
  run_command( scanned, status);
  error := scanned.status <> CMD_OK;
  format.start;
  command_parameters := aux_param;
  command_code := code
end (* read_memory *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*			generate_write_command				*)
(*									*)
(*	Insert command_code and command parameters .                    *)
(*									*)
(************************************************************************)


procedure generate_write_command(
  var scanned : scanned_command;
  var status  : transaction_status);

var
  address   : integer;
  count     : integer;
  present   : boolean;
  error     : boolean;
  aux_code  : command_code_index;

begin
  address := 4;
  count := 0;
  present := FALSE;

  case scanned.subcommand of
    xray_write_absolute_keyword :
      begin
        command_code := xray_write_absolutememory_code;
	aux_code := xray_list_absolutememory_code;
	generate_keyword_value(scanned,xray_write_absolute_keyword,TRUE,present,address)
      end;
    xray_write_memory_keyword :
      begin
	aux_code := xray_list_memory_code;
	generate_keyword_value(scanned,xray_write_memory_keyword,TRUE,present,address);
        if not argument_scan.check_keyword(xray_write_fullword_keyword,scanned)
        then
  	  if argument_scan.check_keyword(xray_write_halfword_keyword,scanned)
	  then command_code := xray_write_halfword_code
	  else command_code := xray_write_halfword_code
        else command_code := xray_write_fullword_code
      end
  end (* case *) ;

  if (address mod 2 <> 0)
  then scanned.status := ARG_ADDRESS_NOT_EVEN;

  if command_code = xray_write_absolutememory_code
  then
    if (configuration in [ SOLO, SOLO_CONSAT, SPLIT_SUP])
    then
      begin
        count := 4;
        argument_scan.extra_argument_check(scanned)
      end
    else scanned.status := BAD_CONFIGURATION
  else generate_memory_count(scanned,aux_code,count);

  if scanned.status = CMD_OK
  then
    begin
      if count = 0
      then count := 4;
      read_memory( status, aux_code, address, count, error);
      if error
      then scanned.status := RUN_ERROR
    end;

  if (scanned.status = CMD_OK) 
  then read_data( scanned, count)
end (* generate_write_command *) ;

!





(**********************       xray_commands       ***********************)
(*									*)
(*			generate_clear_command				*)
(*									*)
(*	Insert command code and command parameters .                    *)
(*									*)
(************************************************************************)


procedure generate_clear_command(
  var scanned : scanned_command);

var
  value   : integer;
  present : boolean;

begin
  value := 0;
  present := FALSE;

  case scanned.subcommand of
    xray_clear_linktrace_keyword :
      command_code := xray_clear_linktrace_code;

    xray_clear_linetrace_keyword :
      command_code := xray_clear_linetrace_code;

    xray_clear_warning_keyword :
      command_code := xray_clear_warning_code;

    xray_clear_statistics_keyword :
      begin
        command_code := xray_clear_statistics_code;
	generate_keyword_value(scanned,xray_clear_neighbor_keyword,TRUE,present,value)
      end

  end (* case *)

end (* generate_clear_command *) ;

!



(**********************       xray_commands       ***********************)
(*									*)
(*			scan_crashoption				*)
(*									*)
(*	Look for a crashoption .                                        *)
(*									*)
(************************************************************************)


procedure scan_crashoption(
  var scanned : scanned_command);

var
  keyword : command_keyword_index;

begin
  argument_scan.find_keyword(xray_change_hardware_keyword,
    xray_change_software_keyword, scanned, keyword);
  if keyword = xray_change_software_keyword
  then increment_command_code(1);
  argument_scan.find_keyword(xray_change_restart_keyword,
    xray_change_halt_keyword, scanned, keyword);
  add_byte(chr(ord('0') + 128));
  if scanned.status = CMD_OK
  then
    case keyword of
      xray_change_restart_keyword : add_byte('0');
      xray_change_stop_keyword    : add_byte('1');
      xray_change_boot_keyword    : add_byte('2');
      xray_change_halt_keyword    : add_byte('3')
    end (* case *)
end (* scan_crashoption *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*			generate_set_command				*)
(*									*)
(*	Insert command code and command parameters.                     *)
(*									*)
(************************************************************************)


procedure generate_set_command(
  var scanned : scanned_command);

var
  keyword : command_keyword_index;
  value   : integer;
  present : boolean;

begin
  value := 0;
  present := FALSE;
  case scanned.subcommand of
    xray_set_linktrace_keyword :
      begin
        command_code := xray_set_linktrace_code;
	generate_keyword_value(scanned,xray_set_neighbor_keyword,TRUE,present,value)
      end ;

    xray_set_symbol_keyword :
      begin
        command_code := xray_set_symbol_code;
	argument_scan.find_keyword(xray_set_crydis_keyword,
	  xray_set_rebdis_keyword,scanned,keyword);
	add_byte(chr(ord('0')+128));
	if scanned.status = CMD_OK
	then
	  case keyword of
	    xray_set_crydis_keyword : add_byte('1');
	    xray_set_rebdis_keyword : add_byte('3');
	    xray_set_asydis_keyword :
	      if configuration <> SOLO_CONSAT
	      then scanned.status := BAD_CONFIGURATION
	      else add_byte('2')
	  end (* case *);
	argument_scan.find_keyword(xray_set_on_keyword,
	  xray_set_off_keyword,scanned,keyword);
	add_byte(chr(ord('0')+128));
	if scanned.status = CMD_OK
	then
	  case keyword of
	    xray_set_off_keyword : add_byte('0');
	    xray_set_on_keyword  : add_byte('1')
	  end (* case *)
      end;

    xray_set_utilization_keyword :
      if argument_scan.check_keyword(xray_set_cpu_keyword,scanned)
      then
        begin
	  command_code := xray_set_cpu_code;
	  argument_scan.keyword_number(xray_set_utilization_keyword,8,scanned,value);
	  add_integer(scanned,value,2,7)
	end
      else scanned.status := ARG_MISSING;

    xray_set_linetrace_keyword :
      begin
        command_code := xray_set_linetrace_code;
	generate_keyword_value(scanned,xray_set_line_keyword,TRUE,present,value)
      end

  end (* case *)
end (* generate_set_command *) ;


(**********************    xray_commands     ****************************)
(*									*)
(*			generate_remove_command				*)
(*									*)
(*	Insert command code and command parameters.                     *)
(*									*)
(************************************************************************)


procedure generate_remove_command(
  var scanned : scanned_command);

var
  present : boolean;
  value   : integer;

begin
  value := 0;
  present := FALSE;
  case scanned.subcommand of
    xray_remove_datatrace_keyword :
      begin
        command_code := xray_remove_datatrace_code;
	generate_keyword_value(scanned,xray_remove_channel_keyword,TRUE,present,value)
      end;

    xray_remove_crypto_keyword :
      begin
        command_code := xray_remove_crypto_code;
        generate_keyword_value(scanned,xray_remove_type_keyword,TRUE,present,value)
      end;

    xray_remove_badneighbor_keyword :
      begin
        command_code := xray_remove_badneighbor_code;
	generate_keyword_value(scanned,xray_remove_neighbor_keyword,TRUE,present,value)
      end;

    xray_remove_busyports_keyword :
      begin
        command_code := xray_remove_busyports_code;
        generate_keyword_value(scanned,xray_remove_port_keyword,TRUE,present,value)
      end

  end (* case *)
end (* generate_remove_command *) ;



(*************************     xray_commands  ***************************)
(*									*)
(*			generate_add_command				*)
(*									*)
(*	Insert command code and command parameters.                     *)
(*									*)
(************************************************************************)


procedure generate_add_command(
  var scanned : scanned_command);

var
  present : boolean;
  value   : integer;

begin
  value := 0;
  present := FALSE;
  case scanned.subcommand of
    xray_add_datatrace_keyword :
      begin
        command_code := xray_add_datatrace_code;
	generate_keyword_value(scanned,xray_add_channel_keyword,TRUE,present,value)
      end;

    xray_add_crypto_keyword :
      if argument_scan.check_keyword(xray_add_all_keyword,scanned)
      then command_code := xray_add_all_crypto_code
      else
        begin
          command_code := xray_add_crypto_code ;
	  generate_keyword_value(scanned,xray_add_type_keyword,TRUE,present,value)
        end;

    xray_add_badneighbor_keyword :
      begin
        command_code := xray_add_badneighbor_code;
        generate_keyword_value(scanned,xray_add_neighbor_keyword,TRUE,present,value)
      end;

    xray_add_busyports_keyword :
      begin
        command_code := xray_add_busyports_code;
        generate_keyword_value(scanned, xray_add_port_keyword,TRUE,present,value)
      end

  end (* case *)
end (* generate_add_command *) ;



(**************************    xray_commands  ***************************)
(*									*)
(*			generate_change_command				*)
(*									*)
(*	Insert command code and command parameters                      *)
(*									*)
(************************************************************************)


procedure generate_change_command(
  var scanned : scanned_command);

var
  present : boolean;
  value   : integer;

begin
  value := 0;
  present := FALSE;
  case scanned.subcommand of
    xray_change_crashoption_keyword :
      begin
        command_code := xray_change_crashoption_code;
	scan_crashoption( scanned)
      end;

    xray_change_warning_keyword :
      begin
        command_code := xray_change_warning_code;
        generate_keyword_text(scanned,xray_change_warning_keyword,64,FALSE)
      end

  end (* case *) 
end (* generate_change_command *) ;


(**********************       xray_commands       ***********************)
(*									*)
(*		        generate_init_command				*)
(*									*)
(*      Insert command code and command parameters .                    *)
(*									*)
(************************************************************************)


procedure generate_init_command(
  var scanned  : scanned_command);

begin
  case scanned.subcommand of
    xray_init_ring_keyword :
      if argument_scan.check_keyword(xray_init_async_keyword,scanned)
      then
        if configuration = SOLO_CONSAT
	then command_code := xray_init_asyring_code
	else scanned.status := BAD_CONFIGURATION
      else if argument_scan.check_keyword(xray_init_sio_keyword,scanned)
      then
        if configuration = SPLIT_SUP
        then command_code := xray_init_sioring_code
        else scanned.status := BAD_CONFIGURATION
      else scanned.status := ARG_MISSING;
    xray_init_interface_keyword :
      if argument_scan.check_keyword(xray_init_sio_keyword,scanned)
      then 
        if configuration = SPLIT_SUP
        then command_code := xray_init_siointerface_code
        else scanned.status := BAD_CONFIGURATION
      else scanned.status := ARG_MISSING;
    xray_init_statistics_keyword :
      if argument_scan.check_keyword(xray_init_buffer_keyword,scanned)
      then command_code := xray_init_bufferstatistics_code
      else if argument_scan.check_keyword(xray_init_port_keyword,scanned)
      then command_code := xray_init_portstatistics_code
      else scanned.status := ARG_MISSING
  end (* case *)
end (* generate_init_command *) ;



(*************************    xray_commands     *************************)
(*									*)
(*			display_statistics				*)
(*									*)
(*	Send mutiple commands in order to display multiple link statis. *)
(*									*)
(************************************************************************)


procedure display_statistics(
  var scanned : scanned_command;
  var status  : transaction_status);

var
  present    : boolean;
  node       : integer;
  i          : integer;


begin
  generate_keyword_value(scanned,xray_list_neighbor_keyword,TRUE,present,node);
  i := 0;
  if scanned.status = CMD_OK
  then
    begin
      copy_buffer;
      run_command( scanned, status);
      while (i<=scanned.freeword_count-1) and (i <= 32) and (scanned.status=CMD_OK)  and ((status = TS_OK) or (status = TS_EOT)) do
        begin
          generate_command_begin;
          command_code := xray_list_statistics_code;
          argument_scan.freeword_number(i,xray_data.radix(scanned,xray_list_neighbor_keyword),scanned,node);
	  generate_number(scanned,xray_list_neighbor_keyword,node);
          copy_buffer;
          run_command( scanned, status);
          i := i +1
        end (*while*)
      end (* then *);
  if scanned.status = CMD_OK
  then scanned.status := RUN_ERROR (* no more command to send *)
end (* display_statistics *) ;



(****************************  xray_commands  ***************************)
(*									*)
(*			generate_display_command			*)
(*									*)
(*	Put the XRAY command code for the Display subcommand            *)
(*      into command_code. Insure that the command has only             *)
(*	allowed keywords and all keywords required. If ok,add           *)
(*	parameters to command parameters.                               *)
(*									*)
(************************************************************************)


procedure generate_display_command(
  var scanned   : scanned_command;
  var status    : transaction_status);

var
  value    : integer;
  present  : boolean;
  aux_code : integer;

begin
  value:= 0;
  aux_code := 0;
  present := FALSE;
  case scanned.subcommand of
    xray_list_descriptor_keyword :
      if argument_scan.check_keyword(xray_list_node_keyword,scanned)
      then command_code := xray_list_nodedescriptor_code
      else if argument_scan.check_keyword(xray_list_neighbor_keyword,scanned)
      then
        begin
	  command_code := xray_list_descriptor_code;
          generate_keyword_value(scanned,xray_list_neighbor_keyword,TRUE,present,value)
        end
      else scanned.status := ARG_MISSING;

    xray_list_statistics_keyword :
      if argument_scan.check_keyword(xray_list_node_keyword,scanned)
      then 
        if argument_scan.check_keyword(xray_list_reset_keyword,scanned)
	then command_code := xray_list_noderesetstat_code
	else command_code := xray_list_nodestatistics_code
      else if argument_scan.check_keyword(xray_list_neighbor_keyword,scanned)
      then
        begin
	  command_code := xray_list_statistics_code;
	  display_statistics( scanned, status)
	end
      else if argument_scan.check_keyword(xray_list_delay_keyword,scanned)
           or argument_scan.check_keyword(xray_list_loopback_keyword,scanned)
      then
        begin
	  command_code := xray_list_delaystatistics_code;
          generate_keyword_value(scanned,xray_list_index_keyword,FALSE,present,value)
	end
      else if argument_scan.check_keyword(xray_list_buffers_keyword,scanned)
      then command_code := xray_list_bufferstatistics_code
      else if argument_scan.check_keyword(xray_list_isis_keyword,scanned)
      then
        if configuration in [ ISIS, SUP]
        then command_code := xray_list_isisstatistics_code
        else scanned.status := BAD_CONFIGURATION
      else scanned.status := ARG_MISSING;

    xray_list_badneighbor_keyword :
      command_code := xray_list_badneighbor_code;

    xray_list_utilization_keyword :
      if argument_scan.check_keyword(xray_list_cpu_keyword, scanned)
      then command_code := xray_list_cpu_code
      else scanned.status := ARG_MISSING;
  
    xray_list_busyports_keyword :
      if configuration = SOLO_CONSAT
      then command_code := xray_list_busyports_code
      else scanned.status := BAD_CONFIGURATION;

    xray_list_linktrace_keyword :
      command_code := xray_list_linktrace_code;

    xray_list_linforeground_keyword :
      command_code := xray_list_linforeground_code;

    xray_list_linbackground_keyword :
      command_code := xray_list_linbackground_code;

    xray_list_warning_keyword :
      command_code := xray_list_warning_code;

    xray_list_patch_keyword :
      command_code := xray_list_patch_code;

    xray_list_errors_keyword :
      if argument_scan.check_keyword(xray_list_semiconductor_keyword,scanned)
      then command_code := xray_list_semiconductor_code
      else scanned.status := ARG_MISSING;

    xray_list_sioringstatus_keyword :
      if configuration = SPLIT_SUP
      then command_code := xray_list_sioringstatus_code
      else scanned.status := BAD_CONFIGURATION;

    xray_list_rings_keyword :
      if configuration in [ ISIS, SUP]
      then
        if argument_scan.check_keyword(xray_list_isis_keyword,scanned)
        then command_code := xray_list_isisrings_code
        else scanned.status := ARG_MISSING
      else scanned.status := BAD_CONFIGURATION;

    xray_list_channeltraced_keyword :
      command_code := xray_list_channeltraced_code;

    xray_list_crash_keyword :
      if argument_scan.check_keyword(xray_list_tables_keyword,scanned)
      then command_code := xray_list_crashtables_code
      else if argument_scan.check_keyword(xray_list_options_keyword,scanned)
      then command_code := xray_list_crashoptions_code
      else if argument_scan.check_keyword(xray_list_detail_keyword,scanned)
      then command_code := xray_list_crashdetail_code
      else if argument_scan.check_keyword(xray_list_summary_keyword,scanned)
      then command_code := xray_list_crashsummary_code
      else scanned.status := ARG_MISSING;
      
    xray_list_linetraced_keyword :
      command_code := xray_list_linetraced_code;

    xray_list_portstatus_keyword :
      if (configuration = SOLO_CONSAT)
      then
        begin
	  command_code := xray_list_portstatus_code;
	  generate_range(scanned,xray_list_port_keyword,FALSE,FALSE,FALSE);
          generate_option(scanned,xray_list_active_keyword,FALSE,present,3)
        end
      else scanned.status := BAD_CONFIGURATION;

    xray_list_activechannels_keyword :
      begin
        command_code := xray_list_activechannels_code;
        generate_range(scanned,xray_list_channel_keyword,TRUE,TRUE,TRUE)
      end;

    xray_list_channelstatus_keyword :
      begin
        command_code := xray_list_channelstatus_code;
        generate_range(scanned,xray_list_channel_keyword,TRUE,FALSE,FALSE);
        generate_option(scanned,xray_list_active_keyword,FALSE,present,2)
      end;

    xray_list_performance_keyword :
      begin
        command_code := xray_list_performance_code;
        generate_keyword_value(scanned,xray_list_channel_keyword,TRUE,present,value)
      end;

    xray_list_memory_keyword :
      begin
        command_code := xray_list_memory_code;
        generate_keyword_value(scanned,xray_list_memory_keyword,TRUE,present,value);
        if (value mod 2) <> 0
        then scanned.status := ARG_ADDRESS_NOT_EVEN
        else generate_memory_count(scanned,aux_code,value)
      end;

    xray_list_absolute_keyword :
      if configuration in [SOLO, SOLO_CONSAT, SPLIT_SUP]
      then
        begin
          command_code := xray_list_absolutememory_code;
          generate_keyword_value(scanned,xray_list_absolute_keyword,TRUE,present,value);
         if ((value mod 2 ) <> 0)
         then scanned.status := ARG_ADDRESS_NOT_EVEN
         else generate_memory_count(scanned,aux_code,value)
        end
      else scanned.status := BAD_CONFIGURATION;

    xray_list_symbol_keyword :
      begin
        command_code := xray_list_memorysymbol_code;
        generate_symbol(scanned,TRUE,FALSE,6);
        generate_memory_count(scanned,aux_code,value)
      end;

    xray_list_symbols_keyword :
      begin
        command_code := xray_list_symbols_code;
	if argument_scan.check_keyword(xray_list_all_keyword,scanned)
	then add_byte(chr(ord('*') + 128))
	else generate_symbol(scanned,TRUE,TRUE,1)
      end;

    xray_list_datatrace_keyword :
      begin
        command_code := xray_list_datatrace_code;
        generate_keyword_value(scanned,xray_list_last_keyword,FALSE,present,value);
        generate_option(scanned,xray_list_input_keyword,FALSE,present,2);
 	if not present 
	then generate_option(scanned,xray_list_output_keyword,FALSE,present,4);
	if ((argument_scan.check_keyword(xray_list_ascii_keyword,scanned))
	    and (xray_list_escape_keyword in scanned.keyword_present)) or
	   ((argument_scan.check_keyword(xray_list_escape_keyword,scanned))
	    and (xray_list_ascii_keyword in scanned.keyword_present))
        then scanned.status := TOO_MANY_ARGS
      end;

    xray_list_crypto_keyword :
      if argument_scan.check_keyword(xray_list_type_keyword,scanned)
      then
        begin
	  command_code := xray_list_chosencrypto_code;
          generate_keyword_value(scanned,xray_list_type_keyword,TRUE,present,value);
	  generate_option(scanned,xray_list_hours_keyword,FALSE,present,52);
	  if present
	  then generate_keyword_value(scanned,xray_list_last_keyword,TRUE,present,value)
	  else
	    begin
	      generate_option(scanned,xray_list_minutes_keyword,FALSE,present,53);
	      if present
	      then generate_keyword_value(scanned,xray_list_last_keyword,TRUE,present,value)
	    end
        end
      else
        begin
	  command_code := xray_list_crypto_code;
          generate_keyword_value(scanned,xray_list_last_keyword,FALSE,present,value);
	  if present
	  then
	    begin
              generate_option(scanned,xray_list_hours_keyword,FALSE,present,1);
	      if not present 
	      then generate_option(scanned,xray_list_minutes_keyword,FALSE,present,2)
	    end
	end;

    xray_list_pvcparameter_keyword :
      if (configuration = SOLO_CONSAT)
      then
        begin
	  command_code := xray_list_pvcparameter_code;
          generate_keyword_value(scanned,xray_list_port_keyword,FALSE,present,value)
	end
      else scanned.status := BAD_CONFIGURATION;

    xray_list_register_keyword :
      if (configuration in [ SOLO, SOLO_CONSAT,SPLIT_SUP])
      then
        begin
	  command_code := xray_list_register_code;
          generate_keyword_value(scanned,xray_list_set_keyword,TRUE,present,value)
	end
      else scanned.status := BAD_CONFIGURATION;

    xray_list_hostinfo_keyword :
      begin
        command_code := xray_list_hostinfo_code;
        generate_keyword_value(scanned,xray_list_host_keyword,FALSE,present,value);
        if not present 
	then generate_option(scanned,xray_list_uporshut_keyword,FALSE,present,2)
      end;

    xray_list_slotinfo_keyword :
      begin
        command_code := xray_list_slotinfo_code;
	generate_keyword_value(scanned,xray_list_slot_keyword,TRUE,present,value)
      end

  end (* case scanned.subcommand *) ;  

end (* generate_display_command *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				scan_command				*)
(*									*)
(*	Scan and execute the various commands                           *)
(*									*)
(************************************************************************)


procedure scan_command(
  var scanned  : scanned_command;
  var status   : transaction_status);

begin
  generate_command_begin;

  case scanned.command of
    XRAY_LIST :
      generate_display_command(scanned,status);
    XRAY_INITIALIZE :
      generate_init_command(scanned);
    XRAY_SET :
      generate_set_command(scanned);
    XRAY_CLEAR :
      generate_clear_command(scanned);
    XRAY_REMOVE :
      generate_remove_command(scanned);
    XRAY_CHANGE :
      generate_change_command(scanned);
    XRAY_ADD :
      generate_add_command( scanned);
    XRAY_START :
      generate_start_command(scanned);
    XRAY_WRITE :
      generate_write_command(scanned,status)
  end (* case *);

  if scanned.status = CMD_OK
  then generate_command_end(scanned);

  if scanned.status = CMD_OK
  then run_command( scanned, status)
end (* scan_command *) ;




(**********************       xray_commands       ***********************)
(*									*)
(*			    scan_miscellaneous				*)
(*									*)
(*	Scan and execute the XRAY hang, restart and zap commands.       *)
(*									*)
(************************************************************************)


procedure scan_miscellaneous(
  var scanned : scanned_command;
  var status  : transaction_status);

var
  value   : integer;
  present : boolean;

begin
  value := 0;
  present := FALSE;

  generate_command_begin;

  case scanned.command of
    XRAY_HANG :
      if configuration = SOLO_CONSAT
      then
        begin
	  command_code := xray_hang_port_code;
	  generate_keyword_value( scanned, xray_hang_port_keyword, TRUE, present, value)
        end
      else scanned.status := BAD_CONFIGURATION;

    XRAY_ZAP :
      begin
	command_code:= xray_zap_link_code;
	generate_keyword_value( scanned, xray_zap_link_keyword, TRUE, present, value)
      end;

    XRAY_STOP :
      begin
        command_code := xray_stop_delay_code;
	generate_keyword_value(scanned,xray_stop_index_keyword,FALSE,present,value)
      end;

    XRAY_RESTART :
      if argument_scan.check_keyword(xray_restart_node_keyword, scanned)
      then
        if (configuration in [ SOLO, SOLO_CONSAT, SPLIT_SUP])
        then command_code := xray_restart_node_code
        else scanned.status := BAD_CONFIGURATION
      else scanned.status := ARG_KEYWORD_MISSING
  end (* case *);

  if scanned.status = CMD_OK
  then generate_command_end( scanned);

  if scanned.status = CMD_OK
  then run_command( scanned, status)
end (* scan_miscellaneous *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*				scan_help				*)
(*									*)
(*	Display information about XRAY commands.			*)
(*									*)
(************************************************************************)


procedure scan_help(
  var scanned : scanned_command);

begin
  if argument_scan.check_keyword(xray_help_list_keyword,scanned) or
     argument_scan.check_keyword(xray_help_query_keyword,scanned)
  then command_code := xray_help_list_code
  else if argument_scan.check_keyword(xray_help_initialize_keyword,scanned)
  then command_code := xray_help_init_code
  else if argument_scan.check_keyword(xray_help_autocrypto_keyword,scanned) or
          argument_scan.check_keyword(xray_help_hang_keyword,scanned) or
	  argument_scan.check_keyword(xray_help_zap_keyword,scanned) or
	  argument_scan.check_keyword(xray_help_restart_keyword,scanned) or
	  argument_scan.check_keyword(xray_help_power_keyword,scanned)
  then command_code := xray_help_autocrypto_code
  else if argument_scan.check_keyword(xray_help_add_keyword,scanned) or
          argument_scan.check_keyword(xray_help_remove_keyword,scanned)
  then command_code := xray_help_add_code
  else if argument_scan.check_keyword(xray_help_set_keyword,scanned) or
          argument_scan.check_keyword(xray_help_clear_keyword,scanned)
  then command_code := xray_help_set_code
  else if argument_scan.check_keyword(xray_help_start_keyword,scanned) or
          argument_scan.check_keyword(xray_help_stop_keyword,scanned)
  then command_code := xray_help_start_code
  else if argument_scan.check_keyword(xray_help_write_keyword,scanned) or
          argument_scan.check_keyword(xray_help_change_keyword,scanned)
  then command_code := xray_help_write_code
  else command_code := xray_help_help_code;
  
  argument_scan.extra_argument_check(scanned);
  
  if scanned.status = CMD_OK
  then xray_response.display_help_response(command_code)
end (* scan_help *) ;

!



(************************** xray_commands  ******************************)
(*									*)
(*			    warning_message				*)
(*									*)
(*	Display XRAY warning message at the beginning of session.       *)
(*									*)
(************************************************************************)


procedure warning_message(
  var scanned: scanned_command;
  var status : transaction_status);

begin
  generate_command_begin;
  command_code := xray_list_warning_code;
  scanned.command := XRAY_LIST;
  scanned.subcommand := xray_list_warning_keyword;
  scanned.status := CMD_OK;
  copy_buffer;
  run_command( scanned, status)
end (* warning_message *) ;



(**********************       xray_commands       ***********************)
(*									*)
(*			set_configuration				*)
(*									*)
(*	Search node configuration and set ' configuration'.             *)
(*									*)
(************************************************************************)


procedure set_configuration(
  host_id : iix_host_identifier);

var
  value : integer;

begin
  if host_id.product = TII_NODE_PRODUCT_ID 
  then configuration := SOLO
  else 
    if (host_id.product = ISIS_PRODUCT_ID) 
    then configuration := ISIS
    else
      if (host_id.product = SUPERVISOR_PRODUCT_ID)
      then configuration := SUP
      else 
        if host_id.product = SPLIT_PRODUCT_ID 
        then configuration := SPLIT_SUP;

  value := ord(host_id.version[0])*256 + ord(host_id.version[1]);
  if value >= 8192 (* oct 20000 *)
  then configuration := SOLO_CONSAT;
  xray_response.set_configuration(configuration)
end (* set_configuration *) ;

!


(****************************  xray_commands  ***************************)
(*									*)
(*		           execute_xray_command				*)
(*									*)
(*	Call an xray command procedure                                  *)
(*									*)
(************************************************************************)


procedure execute_xray_command(
  var scanned  :scanned_command);

var
  status       : transaction_status;

begin
  command_read.add_context(XRAY_CONTEXT);
  current_license := XRAY_LICENSE;
  warning_message (scanned, status);

  repeat
    command_read.get_command(scanned);
    status := TS_OK;

    if not (scanned.command in [ XRAY_RETURN, XRAY_AUTOCRYPTO, XRAY_HELP])
    then
      if commands.privilege(scanned.command,scanned.subcommand) >current_license
      then scanned.status := NO_PRIV
      else
        case scanned.command of
          XRAY_QUERY :
	    begin
	      scanned.command := XRAY_LIST;
	      scan_command(scanned, status)
	    end;
          XRAY_LIST ,
          XRAY_ADD ,
          XRAY_CHANGE ,
          XRAY_SET ,
	  XRAY_CLEAR ,
	  XRAY_REMOVE ,
	  XRAY_WRITE ,
	  XRAY_START ,
          XRAY_INITIALIZE :
	    scan_command(scanned,status);
          XRAY_HANG ,
	  XRAY_ZAP ,
	  XRAY_STOP ,
	  XRAY_RESTART :
	    scan_miscellaneous( scanned, status);
          XRAY_POWER :
	    case scanned.subcommand of
	      xray_power_on_keyword :
	        scan_getpower( scanned);
              xray_power_off_keyword :
	        current_license := XRAY_LICENSE
            end (* case scanned.subcommand *)
        end (*case scanned.command*) 
    else
      if scanned.command = XRAY_AUTOCRYPTO
      then scan_autocrypto( scanned, status)
      else if scanned.command = XRAY_HELP
      then scan_help(scanned);

    if status = TS_FAILURE
    then scanned.status := RUN_ERROR;

    scan_error.display_command_error(scanned)

  until (status = TS_LOST)  or
        (scanned.command = XRAY_RETURN) or
        not user_terminal.available;

  command_read.remove_context(XRAY_CONTEXT)
		    
end (* execute_xray_command *) ;
!





(****************************  xray_commands  ***************************)
(*									*)
(*	                  scan_xray_command                             *) 
(*									*)
(*	Build a circuit to an xray interface                            *)
(*									*)
(************************************************************************)


procedure entry scan_xray_command(
  var scanned  : scanned_command);

var
  host_id      : host_protocol_identifier;
  node_number  : integer;
  status       : connect_status;


begin
  node_number := 0;

  if argument_scan.check_keyword(MAIN_XRAY_HOST_KEYWORD, scanned)
  then argument_scan.keyword_host(MAIN_XRAY_HOST_KEYWORD, scanned ,host)
  else 
    begin
      argument_scan.freeword_tymnet_II_node(0, scanned ,node_number); 
      if scanned.status = CMD_OK
      then node_list.find_host(host, node_number, scanned)
    end;

  if scanned.status = CMD_OK
  then
    if not profile.host_access_check(host)
    then scanned.status := HOST_ACCESS_ERROR;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      host_id.protocol := IIX_PROTOCOL;
      host_circuit.start_session(host, host_id, xray_data_field, status);

      if status <> CS_OK
      then scanned.status := RUN_ERROR
      else
        if not ((host_id.iix.product = TII_NODE_PRODUCT_ID) or
	        (host_id.iix.product = ISIS_PRODUCT_ID) or
	        (host_id.iix.product = SUPERVISOR_PRODUCT_ID) or
	        (host_id.iix.product = SPLIT_PRODUCT_ID))
        then scanned.status := ARG_HOST_NOT_XRAY
        else
	  begin
	    set_configuration( host_id.iix);
	    job_common.set_host(user, host, XRAY_HOST_INTERFACE);
            execute_xray_command(scanned);
            job_common.set_host(user, NO_HOST, NO_HOST_INTERFACE)
	  end (* else *);

      host_circuit.finish_session
    end (* if scanned.status *)
end (* scan_xray_command *);
!



(****************************  xray_commands  ***************************)
(*									*)
(*				initialize				*)
(*									*)
(************************************************************************)


procedure initialize;

begin
  init host_operator;
  init host_circuit(
    user_terminal,format, oper_msgs, connection, data_transfer);
  init password_scanner(user_terminal);
  init xray_response(
    profile, user_terminal, format, host_circuit, name_common, xray_data)
end (* initialize *) ;

    

  
(************************** xray_commands *******************************)
(************************************************************************)


begin (* initial statement *)
  initialize
end (* xray_commands *) ;


$endif
!
(************************************************************************)
(*                                                              	*)
(*	PGATH.TMS Updated 25-Sep-87 at 14:14 by Raffo			*)
(*                                                              	*)
(*                            probe_gather                      	*)
(*                                                              	*)
(*    This process handles all gathering of network state data  	*)
(*    from the active supervisors probe.                        	*)
(*                                                              	*)
(*     The following identifiers must be defined externally:    	*)
(*       node_index                                             	*)
(*                                                              	*)
(************************************************************************)
(*                                                              	*)
(*                           Revision Record                    	*)
(*                                                              	*)
(*    14Feb81    Original -- rer                                	*)
(*    23Jun81    Ignore time in count command				*)
(*    27Jul81    Remove host command					*)
(*     9Sep81    Convert to 6.0 - rer					*)
(*    19Jan86	 Remove Tymnetone -- ahm				*)
(*    20Jan86    Adapt to new command scanner -- gde			*)
(*    18Nov86	 Change to not clear btree files when sup changes	*)
(*                                                              	*)
(************************************************************************)



type
  probe_gather =
    process(
      statistics	: statistics_gatherer;
      supervisor_common	: global_supervisor_data;
      multiplexer	: probe_multiplexer;
      consumer		: network_state_description;
      license_operator  : license_utility;
      def               : command_table
    );

var
  user_terminal	: circuit_handler;
  format	: internal_to_string;
  node_operator	: node_utility;
  argument_scan	: argument_scanner;
  keyword_util	: keyword_utility;
  command_scan	: command_scanner;
  scanned	: scanned_command;



(***************************  probe_gather  *****************************)
(*                                                              	*)
(*                             initialize                       	*)
(*                                                              	*)
(*    Initialize gather variables. In particular, set the gather	*)
(*    interval for each probe command.                          	*)
(*                                                              	*)
(************************************************************************)



procedure initialize;

begin
  init user_terminal, format, node_operator;
  init argument_scan(supervisor_common, license_operator);
  init keyword_util(format, user_terminal, def, argument_scan);
  init command_scan(user_terminal, def, argument_scan, keyword_util)
end (* initialize *) ;



(***************************  probe_gather  *****************************)
(*                                                              	*)
(*                           scan_response                      	*)
(*                                                              	*)
(*    Get the response from probe_multiplexer and tokenize it.  	*)
(*                                                              	*)
(************************************************************************)


procedure scan_response(
	probe_user    : probe_user_index;
    var state         : probe_user_state);

var 
  response: format_buffer;
  i       : command_line_text_index;

begin
  multiplexer.get_response(probe_user, response.text, response.pointer, state);
  if state = PM_AVAILABLE
  then
    begin
      if response.pointer <= COMMAND_LINE_TEXT_MAX
      then scanned.input_line.size := response.pointer
      else scanned.input_line.size := COMMAND_LINE_TEXT_MAX;
      for i := 0 to scanned.input_line.size - 1 do
  	scanned.input_line.text[i] := response.text[i];
      command_scan.scan_response_line(scanned)
    end
end (* scan_response *) ;


(***************************  probe_gather  *****************************)
(*                                                              	*)
(*                             string_match                     	*)
(*                                                              	*)
(*    Check if freeword 0 is a certain string.                  	*)
(*                                                              	*)
(************************************************************************)



function string_match(string: message_string): boolean;

var
  matches: integer;

begin
  argument_scan.freeword_message_string(string, 0, scanned, matches);
  string_match := matches <> 0
end (* string_match *) ;


(***************************  probe_gather  *****************************)
(*                                                              	*)
(*                            gather_acct                       	*)
(*                                                              	*)
(*    Get information for ACCT command.                         	*)
(*                                                              	*)
(************************************************************************)



procedure gather_acct;

var
  accounting_blocks: integer (* account blocks left reported by ACCT *) ;
  state: probe_user_state (* state of probe response *) ;
  supervisor: supervisor_index;
  ok: boolean;

begin
  for supervisor := 0 to SUPERVISOR_LIMIT do
    if multiplexer.send_command(PROBE_GATHER_USER, supervisor, 'ACCT', 4)
    then
      begin
	scan_response(PROBE_GATHER_USER, state);
        case state of
          PM_RESPONSE_END: ok := FALSE;

          PM_ABORT: ok := TRUE;

          PM_AVAILABLE:
            begin
	      ok := TRUE;
	      if scanned.status = CMD_OK
	      then argument_scan.freeword_number(
		3, 10, scanned,accounting_blocks);
	      (* ignore 'ACCOUNTING BLOCKS LEFT ' *)
              if scanned.status = CMD_OK
	      then
		consumer.report_account_blocks(supervisor, accounting_blocks);
              multiplexer.ignore_response(PROBE_GATHER_USER)
            end (* pm_available *)
        end (* case *) ;
        if not (ok and (scanned.status = CMD_OK))
	then
	  statistics.report_probe_error_counter(
	    ACCT_RESPONSE_ERROR, supervisor)
      end (* for *)
end (* gather_acct *) ;



(************************************************************************)
(*									*)
(*                             gather_au                        	*)
(*                                                              	*)
(*    Get information for AU command.                           	*)
(*                                                              	*)
(************************************************************************)


procedure gather_au(supervisor: supervisor_index);

var
  up_nodes: node_set (* nodes reported up by AU *) ;
  node_number: integer (* current node number scanned *) ;
  state: probe_user_state (* state of probe response *) ;

begin
  node_operator.clear(up_nodes);
  if multiplexer.send_command(PROBE_GATHER_USER, supervisor, 'AU', 2)
  then
    repeat
      scan_response(PROBE_GATHER_USER, state);
      case state of
	PM_RESPONSE_END:
	  begin
	    for node_number := 1 to NODE_LIMIT do
	      if node_operator.check(node_number, up_nodes)
	      then consumer.report_au_node_up(supervisor, node_number)
	      else consumer.report_au_node_down(supervisor, node_number);
	    consumer.report_au_succeed(supervisor)
	  end (* PM_RESPONSE_END *) ;

	PM_ABORT: consumer.report_au_fail(supervisor);

	PM_AVAILABLE:
	  begin
	    if scanned.status = CMD_OK
	    then argument_scan.freeword_node(0, scanned, node_number);
	    if scanned.status = CMD_OK
	    then node_operator.add_node(node_number, up_nodes);
	    if scanned.status <> CMD_OK
	    then
	      begin
		multiplexer.ignore_response(PROBE_GATHER_USER);
		state := PM_ABORT;
		consumer.report_au_fail(supervisor);
		statistics.report_probe_error_counter(
		  AU_RESPONSE_ERROR, supervisor)
	      end
	  end (* PM_AVAILABLE *)
      end (* case *)
    until state <> PM_AVAILABLE
  else consumer.report_au_fail(supervisor)
end (* gather_au *) ;



(***************************  probe_gather  *****************************)
(*                                                              	*)
(*                            gather_stat                       	*)
(*                                                              	*)
(*    Get information for STAT command. Collects                	*)
(*      takeover - current takeover state                       	*)
(*      disk_error - last disk error                            	*)
(*      drowsiness_factor - drowsiness factor for active supervisor	*)
(*      rejects - number of logins rejected                     	*)
(*      from_node - from node of last rejected login            	*)
(*      to_node - to node of last rejected login                	*)
(*                                                              	*)
(************************************************************************)



procedure gather_stat(supervisor: supervisor_index);

var
  takeover: takeover_state (* takeover states reported by STAT *) ;
  disk_error: integer (* disk error reported by STAT *) ;
  drowsiness_factor: integer (* drowsiness reported by STAT *) ;
  rejects: integer (* rejects on login reported by STAT *) ;
  from_node: integer (* last rejected login fron node reported by STAT *) ;
  to_node: integer (* last rejected login to node reported by STAT *) ;
  state: probe_user_state (* state of probe response *) ;
  ok: boolean (* used for scanning response *) ;
  i: takeover_state_index;
  freeword_offset: command_freeword_index;

begin
  ok := TRUE;
  with multiplexer do
    if send_command(PROBE_GATHER_USER, supervisor, 'STAT', 4)
    then
      begin
	scan_response(PROBE_GATHER_USER, state);
        case state of
          PM_RESPONSE_END: ok := FALSE;

          PM_ABORT: ok := TRUE;

          PM_AVAILABLE:
            begin
	      if string_match ('GOT\')
	      then freeword_offset := 1 (* skip GOT *)
	      else freeword_offset := 5 (* skip TYMNET I states *) ;

              for i := 0 to TAKEOVER_STATE_LIMIT do
		if scanned.status = CMD_OK
		then 
		  argument_scan.freeword_number(
		    i + freeword_offset, 10, scanned, takeover[i]);

              if scanned.status = CMD_OK
              then
                begin
		  scan_response(PROBE_GATHER_USER, state);
                  case state of
                    PM_RESPONSE_END: ok := FALSE;

                    PM_ABORT: ok := TRUE;

                    PM_AVAILABLE:
                      begin
			if scanned.status = CMD_OK
			then 
			  if string_match('DISK\ ')
			  then (* ignore 'DISK ERROR ' *) 
			    begin
			      argument_scan.freeword_number(
			        2, 16, scanned, disk_error);
			      freeword_offset := 3
			    end
			  else 
			    begin
			      disk_error := 0;
			      freeword_offset := 0
			    end;

                        if scanned.status = CMD_OK
                        then (* ignore 'DF ' *)
			  argument_scan.freeword_number(                       
			    freeword_offset+1, 10, scanned, drowsiness_factor);

                        if scanned.status = CMD_OK
                        then (* ignore 'REJECTS ' *)
			  argument_scan.freeword_number(
			    freeword_offset+3, 10, scanned, rejects);

                        if (scanned.status = CMD_OK) and (rejects > 0)
                        then
                          begin
			    argument_scan.freeword_node(
			      freeword_offset+4, scanned, from_node);
			    if scanned.status = CMD_OK
			    then
			      argument_scan.freeword_node(
				freeword_offset+5, scanned, to_node)
                          end
                        else
                          begin
                            from_node := 0;
                            to_node := 0
                          end;

                        if scanned.status = CMD_OK
                        then
			  consumer.report_stat(
			    takeover, disk_error, drowsiness_factor,
			    rejects, from_node, to_node);
                        ignore_response(PROBE_GATHER_USER)
                      end (* pm_available *)
                  end (* case *)
                end
	      else ignore_response(PROBE_GATHER_USER)
            end (* pm_available *)
        end (* case *) ;
        if not ((scanned.status = CMD_OK) and ok)
	then statistics.report_probe_error_counter(
	  STAT_RESPONSE_ERROR, supervisor)
      end
end (* gather_stat *) ;



(***************************  probe_gather  *****************************)
(*                                                              	*)
(*                            next_gather                       	*)
(*                                                              	*)
(*    Get next probe command to do and do it.                   	*)
(*                                                              	*)
(************************************************************************)



procedure next_gather;

var
  supervisor: supervisor_index (* active supervisor *) ;
  command: probe_gather_command (* which gather is occurring *) ;

begin
  consumer.next_probe_command(supervisor, command);
  case command of
    acct_probe_gather:    gather_acct;
    au_probe_gather:      gather_au(supervisor);
    stat_probe_gather:    gather_stat(supervisor)
  end (* case *)
end (* next_gather *) ;



(***************************  probe_gather  *****************************)
(************************************************************************)



begin (* initial statement *)
  initialize;

  cycle
    next_gather;
    wait
  end (* cycle *)
end (* probe_gather *) ;
 !
(**********************************************************************)
(*                                                                    *)
(*	NGATH.TMS						      *)
(*                            node_gather                             *)
(*                                                                    *)
(*    This process handles all gathering of network state data        *)
(*    about nodes from the active supervisor probe.                   *)
(*                                                                    *)
(*     The following identifiers must be defined externally:          *)
(*     operator_log       global_supervisor_data     port_state       *)
(*     probe_multiplexer  network_state_descriptor   node_line_state  *)
(*     string_to_internal internal_to_string         node_utility     *)
(*     host_utility       supervisor_index           node_index       *)
(*     message=string     message_string_index       format_buffer    *)
(*     probe_user_state   terminal_buffer_index      host_state       *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*    14Feb81    Original -- rer                                      *)
(*    20Jan86    Remove Tymnetone -- ahm			      *)
(*    20Jan86    Adapt to new command scanner -- gde		      *)
(*                                                                    *)
(**********************************************************************)



type
  node_gather =
    process(
      statistics	: statistics_gatherer;
      supervisor_common	: global_supervisor_data;
      multiplexer	: probe_multiplexer;
      network_common	: network_state_description;
      name_common	: global_name_data;
      license_operator  : license_utility; 
      def               : command_table
   );

type snap_state =
  (snap_success, snap_abort,
   scanning_version, ignore_ports, ignore_host_header, scanning_host_status,
   ignore_passthrough, scanning_lines);

var
  format	: internal_to_string;
  user_terminal	: circuit_handler;
  node_operator	: node_utility;
  host_operator	: host_utility;
  argument_scan	: argument_scanner;
  keyword_util	: keyword_utility;
  command_scan	: command_scanner;
  supervisor	: supervisor_index (* supervisor to do snap to *) ;
  node		: node_index (* node to do snap for *) ;
  snap_condition: snap_state (* condition of snap *) ;
  node_version	: integer (* version from node snap mod 10000 *) ;
  newly_taken	: boolean (* TRUE if takeover report from erlog *) ;
  freeword_offset: command_freeword_index (* points to next freeword *) ;
  scanned	: scanned_command;


(****************************  node_gather  ***************************)
(*                                                                    *)
(*                             initialize                             *)
(*                                                                    *)
(*    Initialize gather variables.                                    *)
(*                                                                    *)
(**********************************************************************)



procedure initialize;

begin
  init format, user_terminal, node_operator, host_operator;
  init argument_scan(supervisor_common, license_operator);
  init keyword_util(format, user_terminal, def, argument_scan);
  init command_scan(user_terminal, def, argument_scan, keyword_util)
end (* initialize *) ;


(***************************  node_gather  ****************************)
(*                                                                    *)
(*                           scan_response                            *)
(*                                                                    *)
(*    Get the response from probe_multiplexer and tokenize it.        *)
(*                                                                    *)
(**********************************************************************)


procedure scan_response(
	probe_user    : probe_user_index;
    var state         : probe_user_state);

var 
  response: format_buffer;
  i       : command_line_text_index;

begin
  multiplexer.get_response(probe_user, response.text, response.pointer, state);
  if state = PM_AVAILABLE
  then
    begin
      if response.pointer <= COMMAND_LINE_TEXT_MAX
      then scanned.input_line.size := response.pointer
      else scanned.input_line.size := COMMAND_LINE_TEXT_MAX;
      for i := 0 to scanned.input_line.size - 1 do
  	scanned.input_line.text[i] := response.text[i];
      command_scan.scan_response_line(scanned);
      freeword_offset := 0
    end
end (* scan_response *) ;


(***************************  node_gather  ****************************)
(*                                                                    *)
(*                           scan_number                              *)
(*                                                                    *)
(*    Get the number pointed by freeword_offset and if the scanning   *)
(*    is correct, update freeword_offset.			      *)
(*                                                                    *)
(**********************************************************************)


procedure scan_number(
	radix: integer;
    var value: integer);

begin
  argument_scan.freeword_number(freeword_offset, radix, scanned, value);
  if scanned.status = CMD_OK
  then freeword_offset := freeword_offset + 1
end (* scan_number *) ;


(****************************  node_gather  ***************************)
(*                                                                    *)
(*                         node_command_error                         *)
(*                                                                    *)
(*    Report an error while scanning a node command. Give indication  *)
(*    where the failure occurred.                                     *)
(*                                                                    *)
(**********************************************************************)



procedure node_command_error;

begin
  statistics.report_node_sup_error_counter(NODE_COMMAND, supervisor, node);
  snap_condition := snap_abort
end (* node_command_error *) ;



(****************************  node_gather  ***************************)
(*                                                                    *)
(*                        synprt_command_error                        *)
(*                                                                    *)
(*    Report error from synprt command.                               *)
(*                                                                    *)
(**********************************************************************)



procedure synprt_command_error;

begin
  statistics.report_node_sup_error_counter(SYNPRT_COMMAND, supervisor, node);
  snap_condition := snap_abort
end (* synprt_command_error *) ;



(****************************  node_gather  ***************************)
(*                                                                    *)
(*                          construct_command                         *)
(*                                                                    *)
(*    Construct Probe command for current node.                       *)
(*                                                                    *)
(**********************************************************************)



procedure construct_command(
      command_name	: message_string;
  var command		: format_buffer);

begin
  with format do
    begin
      start;
      string(command_name);
      node_number(node);
      command := buffer
    end (* with *)
end (* construct_command *) ;



(****************************  node_gather  ***************************)
(*                                                                    *)
(*                             string_match                           *)
(*                                                                    *)
(*   	Check if freeword_offset points to this string and update     *)
(*   	freeword_offset.                                              *)
(*								      *)
(**********************************************************************)


function string_match(string: message_string): boolean;

var
  matches: integer;

begin
  argument_scan.freeword_message_string(string, freeword_offset, scanned,
    matches);
  if matches <> 0
  then freeword_offset := freeword_offset + matches;
  string_match := matches <> 0
end (* string_match *) ;


(****************************  node_gather  ***************************)
(*                                                                    *)
(*                             find_string                            *)
(*                                                                    *)
(*    Find string starting at freeword_offset.                        *)
(*                                                                    *)
(**********************************************************************)


function find_string(string: message_string): boolean;


var
  freeword_start: command_freeword_index;
  matches	: integer;

begin
  freeword_start := freeword_offset;
  matches := 0;
  while (freeword_offset < scanned.freeword_count) and (matches = 0) do
    begin
      argument_scan.freeword_message_string(
	string, freeword_offset, scanned, matches);
      freeword_offset := freeword_offset + 1
    end;
  if matches = 0
  then freeword_offset := freeword_start
  else freeword_offset := freeword_offset + matches - 1;
  find_string := matches <> 0
end (* find_string *) ;



(****************************  node_gather  ***************************)
(*								      *)
(*			extract_reload_information		      *)
(*								      *)
(*	Extract the mxp, slot and pid for the reload facility.	      *)
(*								      *)
(**********************************************************************)


procedure extract_reload_information (
  var pid		: product_index;
  var mxp		: mxp_index;
  var slot		: slot_index
);

var
  scanned_mxp	: integer;
  scanned_slot	: integer;
  product_name	: symbol;
  ok		: boolean;

begin
  mxp  := 0;
  slot := 0;
  pid := 0;
  product_name.size := 0;

  freeword_offset := freeword_offset + 1 (* skip host cost *) ;

  freeword_offset := freeword_offset + 1 (* skip IIX *) ;

  ok := TRUE;

  while ok and (scanned.status = CMD_OK) and 
    (freeword_offset < scanned.freeword_count) do
    if string_match('MXP#\ ')
    then 
      begin
	scan_number(10, scanned_mxp);
	if (0 < scanned_mxp) and (scanned_mxp <= MXP_LIMIT)
	then mxp := scanned_mxp 
      end
    else
    if string_match('SLOT#\')
    then 
      begin
	scan_number(10, scanned_slot);
	if (0 < scanned_slot) and (scanned_slot <= SLOT_LIMIT)
	then slot := scanned_slot;
      end

    else
    if product_name.size <> 0
    then 
      ok := FALSE

    else (* must be the product id *)
      begin
        argument_scan.freeword_symbol(freeword_offset, scanned, product_name);
	if scanned.status = CMD_OK
	then freeword_offset := freeword_offset + 1
      end;

  if product_name.size > 0
  then pid := name_common.get_product_id (product_name)
end (* extract_reload_information *) ;



(****************************  node_gather  ***************************)
(*                                                                    *)
(*                             get_version                            *)
(*                                                                    *)
(*    Scan version line in node snap.				      *)
(*                                                                    *)
(**********************************************************************)



procedure get_version;

begin
  freeword_offset := freeword_offset + 1 (* ignore 'VERSION ' *) ;
  scan_number(10, node_version);
  if scanned.status = CMD_OK
  then
    begin
      node_version := node_version mod 10000;
      snap_condition := ignore_ports
    end
  else node_command_error
end (* get_version *) ;



(****************************  node_gather  ***************************)
(*                                                                    *)
(*                          get_host_status                           *)
(*                                                                    *)
(*    Scan host status line in node snap.                             *)
(*                                                                    *)
(**********************************************************************)



procedure get_host_status;

var
  new_host_status: host_state;
  host_number: integer;
  pid: product_index;
  mxp: mxp_index;
  slot: slot_index;
  ok: boolean;

begin
  argument_scan.freeword_host(freeword_offset, scanned, host_number);
  if scanned.status = CMD_OK
  then
    begin
      freeword_offset := freeword_offset + 1;
      ok := TRUE;
      if string_match('SHUT\ ')
      then new_host_status := HOST_SHUT
      else if string_match('DOWN\ ')
      then new_host_status := HOST_DOWN
      else if string_match('ANSWERED\ ')
      then new_host_status := HOST_ANSWERED
      else if string_match('NO PORTS\ ')
      then new_host_status := HOST_ANSWERED
      else ok := FALSE;
      if ok
      then 
	begin
	  extract_reload_information(pid, mxp, slot);
          if not network_common.report_node_snap_host_status(
	    host_number, pid, mxp, slot, new_host_status)
          then snap_condition := snap_abort
        end
      else snap_condition := snap_abort
    end
  else
    begin
      scanned.status := CMD_OK;
      if string_match('LINK\ ')
      then snap_condition := scanning_lines
      else snap_condition := ignore_passthrough
    end
end (* get_host_status *) ;



(****************************  node_gather  ***************************)
(*                                                                    *)
(*                          get_port_status                           *)
(*                                                                    *)
(*    Scan line status line in node snap.                             *)
(*                                                                    *)
(**********************************************************************)



procedure get_port_status;

var
  new_link_state: node_link_state;
  port_number: integer;
  neigh_number: integer;

begin
  scan_number(10, port_number);
  argument_scan.freeword_node(freeword_offset, scanned, neigh_number);
  if (scanned.status = CMD_OK) and
     (0 <= port_number) and (port_number <= port_limit)
  then
    begin
      new_link_state := link_up;

      if snap_condition <> snap_abort
      then
        begin
          if find_string('SHUT\ ')
          then new_link_state := succ(new_link_state);
          if not network_common.report_node_snap_link_state(
	    neigh_number, new_link_state)
          then snap_condition := snap_abort
        end
    end
  else node_command_error
end (* get_port_status *) ;



(****************************  node_gather  ***************************)
(*                                                                    *)
(*                             node_snap                              *)
(*                                                                    *)
(*    Do a node snap for given node.                                  *)
(*                                                                    *)
(**********************************************************************)



procedure node_snap;

var
  command_sent: format_buffer (* command sent to probe *) ;
  state: probe_user_state (* state of probe response *) ;
  
begin
  construct_command('NODE \', command_sent);
  snap_condition := scanning_version;
  with multiplexer do
    if send_command (
      node_gather_user, supervisor, command_sent.text, command_sent.pointer)
    then
      repeat
        scan_response(node_gather_user, state);
        case state of
          PM_RESPONSE_END:
            if snap_condition = scanning_lines
            then snap_condition := snap_success
            else node_command_error;

          PM_ABORT: snap_condition := snap_abort;

          PM_AVAILABLE:
            begin
              case snap_condition of
                scanning_version:
		  if string_match('NO SUCH NODE\ ')
		  then snap_condition := snap_abort
		  else get_version;
                ignore_ports: snap_condition := ignore_host_header;
                ignore_host_header:
                  if string_match('HOST\ ')
                  then snap_condition := scanning_host_status
                  else if string_match('LINK\ ')
                  then snap_condition := scanning_lines
                  else snap_condition := ignore_passthrough;
                scanning_host_status: get_host_status;
                ignore_passthrough: snap_condition := scanning_lines;
                scanning_lines: get_port_status
              end (* case *) ;
              if snap_condition = snap_abort
              then
                begin
                  ignore_response(node_gather_user);
                  state := PM_ABORT
                end
            end (* pm_available *)
        end (* case *)
      until state <> pm_available
    else snap_condition := snap_abort
end (* node_snap *) ;



(****************************  node_gather  ***************************)
(*                                                                    *)
(*                               synprt                               *)
(*                                                                    *)
(*    Do a synprt for current node.                                   *)
(*                                                                    *)
(**********************************************************************)



procedure synprt;

var
  command_sent: format_buffer (* command to be sent *) ;
  state: probe_user_state (* state of probe response *) ;

begin
  construct_command('SYNPRT \', command_sent);
  with multiplexer do
    if send_command (
      node_gather_user, supervisor, command_sent.text, command_sent.pointer)
    then
      begin
        scan_response(node_gather_user, state);
        case state of
          PM_ABORT: snap_condition := snap_abort;

          PM_RESPONSE_END: (* empty *) ;

          PM_AVAILABLE:
            begin
              ignore_response(node_gather_user);
              synprt_command_error
            end (* pm_available *)
        end (* case *)
      end
    else snap_condition := snap_abort
end (* synprt *) ;



(****************************  node_gather  ***************************)
(**********************************************************************)



begin (* initial statement *)
  initialize;

  cycle
    network_common.next_node_snap_request(supervisor, node, newly_taken);
    node_snap;
    if snap_condition = snap_success
    then
      if (node_version < 400) or not newly_taken
      then synprt;
    network_common.report_node_snap_status(snap_condition = snap_success);
    wait
  end (* cycle *)
end (* node_gather *) ;
   $if alarm
!
(************************************************************************)
(*									*)
(*      ALMSUB.TMS  Updated 2-Oct-87 at 4:55 by Raffo			*)
(*									*)
(*		    alarm_subsystem_command_handler			*)
(*									*)
(*	This class handles the commands which access and modify the     *)
(*	alarm definitions in alarm_data.				*)
(*									*)
(*        The following identifiers must be defined externally:		*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	16Jun86 Original -- ahm						*)
(*									*)
(************************************************************************)



type
  alarm_subsystem_command_handler =
    class(
      user		: user_index;
      user_terminal	: circuit_handler;
      argument_scan	: argument_scanner;
      format		: internal_to_string;
      command_read	: command_loop;
      scan_error	: command_error_message;
      printer		: set_printer;
      response_buffer	: text_buffer;
      alarm_common	: alarm_data);
!
(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*			     report_status				*)
(*									*)
(*    Report to user why alarm_data call failed.			*)
(*									*)
(************************************************************************)


procedure report_status(
      search_status : alarm_search_status);

begin
  case search_status of
    ALARM_DOES_NOT_EXIST :
	user_terminal.write_quoted_text_line(
	  'alarm does not exist\ ');
    ALARM_NO_MORE_ROOM :
	user_terminal.write_quoted_text_line(
	  'no more room for new alarms\') ;
    ALARM_ALREADY_EXISTS :
	user_terminal.write_quoted_text_line(
	  'alarm already exists\ ');
    ALARM_BUSY :
	user_terminal.write_quoted_text_line(
	  'alarm being modified\ ');
    ALARM_MODIFY_ARGUMENT_WRONG :
	user_terminal.write_quoted_text_line(
	  'invalid modify field\ ')
  end (* case *)
end (* report_status *) ;



(*****************  alarm_subsystem_command_handler  ********************)
(*									*)
(*			  check_search_status				*)
(*									*)
(*	Check is alarm_search_status indicates failure. If so, report	*)
(*	error and set scanned status to RUN_ERROR.			*)
(*									*)
(************************************************************************)


procedure check_search_status(
      search_status : alarm_search_status;
  var scanned	    : scanned_command);

begin
  if search_status <> ALARM_OK
  then
    begin
      scanned.status := RUN_ERROR;
      report_status(search_status)
    end
end (* check_search_status *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*			scan_modify_list_command			*)
(*									*)
(*	Scan and execute the list command in modify mode.		*)
(*									*)
(************************************************************************)


procedure scan_modify_list_command(
      alarm_name	: symbol;
  var scanned		: scanned_command);

var
  search_status	: alarm_search_status;

begin
  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
(*      response_buffer.start_put; *)
      format.start;
      alarm_common.list_alarm_by_name (
	alarm_name, user_terminal, format, printer, search_status);
      check_search_status(search_status, scanned)
(*      response_buffer.print(user_terminal) *)
    end
end (* scan_modify_list_command *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*		      scan_change_description_command			*)
(*									*)
(*	Scan the change description command.				*)
(*	  CHANGE DESCRIPTION <text>					*)
(*									*)
(************************************************************************)


procedure scan_change_description_command (
  var scanned	: scanned_command;
      token	: alarm_token);

var
  text	: description;

begin
  argument_scan.freeword_condition_description (0, scanned, text);

  argument_scan.extra_argument_check (scanned);

  if scanned.status = CMD_OK
  then alarm_common.update_alarm_rec_description (token, text)
end (* scan_change_description_command *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*		        scan_change_level_command			*)
(*									*)
(*	Scan the change level command.					*)
(*	  CHANGE LEVEL {a|b|c|o}					*)
(*									*)
(************************************************************************)


procedure scan_change_level_command(
  var scanned	: scanned_command;
      token	: alarm_token);

var
  level	: alarm_level;

begin
  argument_scan.keyword_condition_class (
    MODALM_CHANGE_LEVEL_KEYWORD, scanned, level);

  argument_scan.extra_argument_check (scanned);

  if scanned.status = CMD_OK
  then alarm_common.update_alarm_rec_alarm_level (token, level)
end (* scan_change_level_command *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*		    scan_change_add_remove_nodes_command		*)
(*									*)
(*	Scan the change, add and reomve nodes command.			*)
(*	  CHANGE NODE <node#> ...					*)
(*	  ADD NODE <node#> ...						*)
(*	  REMOVE NODE <node#> ...					*)
(*									*)
(************************************************************************)


procedure scan_change_add_remove_nodes_command(
  var scanned	: scanned_command;
      token	: alarm_token);

var
  nodes_scanned	: node_set;

begin
  if token.kind = NODE_ALARM
  then
    begin
      argument_scan.freeword_node_set(0, scanned, nodes_scanned);

      argument_scan.extra_argument_check(scanned);  

      if scanned.status = CMD_OK
      then 
	case scanned.command of
	  MODALM_CHANGE:
	    alarm_common.set_nodes_to_node_alarm(token, nodes_scanned);
	  MODALM_ADD:
	    alarm_common.add_nodes_to_node_alarm(token, nodes_scanned);
	  MODALM_REMOVE:
	    alarm_common.remove_nodes_from_node_alarm(token, nodes_scanned)
	end (* case *) ;
    end
  else report_status(ALARM_MODIFY_ARGUMENT_WRONG)
end (* scan_change_add_remove_nodes_command *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*		   scan_change_add_remove_hosts_command			*)
(*									*)
(*	Scan the change, add and reomve hosts command.			*)
(*	  CHANGE HOST <host#> ...					*)
(*	  ADD HOST <host#> ...						*)
(*	  REMOVE HOST <host#> ...					*)
(*									*)
(************************************************************************)


procedure scan_change_add_remove_hosts_command(
  var scanned	: scanned_command;
      token	: alarm_token);

var
  hosts_scanned	: host_set;

begin
  if token.kind = HOST_ALARM
  then
    begin
      argument_scan.freeword_host_set(0, scanned, hosts_scanned);

      argument_scan.extra_argument_check(scanned);  

      if scanned.status = CMD_OK
      then 
	case scanned.command of
	  MODALM_CHANGE:
	    alarm_common.set_hosts_to_host_alarm(token, hosts_scanned);
	  MODALM_ADD:
	    alarm_common.add_hosts_to_host_alarm(token, hosts_scanned);
	  MODALM_REMOVE:
	    alarm_common.remove_hosts_from_host_alarm(token, hosts_scanned)
	end (* case *) ;
    end
  else report_status(ALARM_MODIFY_ARGUMENT_WRONG)
end (* scan_change_add_remove_hosts_command *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*		   scan_change_add_remove_links_command			*)
(*									*)
(*	Scan the change, add or remove links command.			*)
(*	  CHANGE LINK <node#:node#> ...					*)
(*	  ADD LINK <node#:node#> ...					*)
(*	  REMOVE LINK <node#:node#> ...					*)
(*									*)
(************************************************************************)


procedure scan_change_add_remove_links_command(
  var scanned	: scanned_command;
      token	: alarm_token);

var
  links_scanned	: clusion_list;

begin
  if token.kind = LINK_ALARM
  then
    begin
      argument_scan.freeword_link_set(0, scanned, links_scanned);

      argument_scan.extra_argument_check(scanned);  

      if scanned.status = CMD_OK
      then 
	case scanned.command of
	  MODALM_CHANGE:
	    alarm_common.set_links_to_link_alarm(token, links_scanned);
	  MODALM_ADD:
	    alarm_common.add_links_to_link_alarm(token, links_scanned);
	  MODALM_REMOVE:
	    alarm_common.remove_links_from_link_alarm(token, links_scanned)
	end (* case *) 
    end
  else report_status(ALARM_MODIFY_ARGUMENT_WRONG)
end (* scan_change_add_remove_links_command *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*		   scan_change_add_remove_slots_command			*)
(*									*)
(*	Scan the change, add and remove slots command.			*)
(*	  CHANGE SLOT <node#:slot#[:mxp#]> ...				*)
(*	  ADD SLOT <node#:slot#[:mxp#]> ...				*)
(*	  REMOVE SLOT <node#:slot#[:mxp#]> ...				*)
(*									*)
(************************************************************************)


procedure scan_change_add_remove_slots_command(
  var scanned	: scanned_command;
      token	: alarm_token);

var
  slots_scanned	: clusion_list;

begin
  if token.kind = SLOT_ALARM
  then
    begin
      argument_scan.freeword_slot_set(0, scanned, slots_scanned);

      argument_scan.extra_argument_check(scanned);  

      if scanned.status = CMD_OK
      then 
	case scanned.command of
	  MODALM_CHANGE:
	    alarm_common.set_slots_to_slot_alarm(token, slots_scanned);
	  MODALM_ADD:
	    alarm_common.add_slots_to_slot_alarm(token, slots_scanned);
	  MODALM_REMOVE:
	    alarm_common.remove_slots_from_slot_alarm(token, slots_scanned)
	end (* case *) 
    end
  else report_status(ALARM_MODIFY_ARGUMENT_WRONG)
end (* scan_change_add_remove_slots_command *) ;



(*****************  alarm_subsystem_command_handler  ********************)
(*									*)
(*			      modify_mode				*)
(*									*)
(*    This is the command level when modifying or creating a alarm def.	*)
(*    It assumes that the alarm definition has been locked by either a	*)
(*    create or modify call to alarm_data. It insures that the alarm	*)
(*    definition is unlocked before exiting by doing either a cancel	*)
(*    or a write to alarm_data.						*)
(*									*)
(************************************************************************)



procedure modify_mode(
  var scanned		: scanned_command;
      alarm_name	: symbol;
      token		: alarm_token);

begin
  command_read.add_context(MODALM_CONTEXT);

  repeat
    command_read.get_command(scanned);

    if user_terminal.available
    then
      begin
	case scanned.command of
	  MODALM_LIST:
	    scan_modify_list_command(alarm_name, scanned);

	  MODALM_CHANGE:
	    case scanned.subcommand of
	      MODALM_CHANGE_NODES_KEYWORD:
		scan_change_add_remove_nodes_command(scanned, token);

	      MODALM_CHANGE_HOSTS_KEYWORD:
		scan_change_add_remove_hosts_command(scanned, token);

	      MODALM_CHANGE_LINKS_KEYWORD:
		scan_change_add_remove_links_command(scanned, token);

	      MODALM_CHANGE_SLOTS_KEYWORD:
		scan_change_add_remove_slots_command(scanned, token);

	      MODALM_CHANGE_LEVEL_KEYWORD:
		scan_change_level_command(scanned, token);

	      MODALM_CHANGE_DESCRIPTION_KEYWORD:
		scan_change_description_command(scanned, token)
	    end (* MODALM_CHANGE *) ;

	  MODALM_ADD,
	  MODALM_REMOVE:
	    case scanned.subcommand of
	      MODALM_CHANGE_NODES_KEYWORD:
		scan_change_add_remove_nodes_command(scanned, token);

	      MODALM_CHANGE_HOSTS_KEYWORD:
		scan_change_add_remove_hosts_command(scanned, token);

	      MODALM_CHANGE_LINKS_KEYWORD:
		scan_change_add_remove_links_command(scanned, token);

	      MODALM_CHANGE_SLOTS_KEYWORD:
		scan_change_add_remove_slots_command(scanned, token)
	    end (* case *) ;

	  MODALM_RETURN:
	    argument_scan.extra_argument_check (scanned)

	end (* case *) ;

	scan_error.display_command_error(scanned)

      end

  until (scanned.command = MODALM_RETURN) or not user_terminal.available;

  alarm_common.write(user, token);

  command_read.remove_context(MODALM_CONTEXT)
end (* modify_mode *) ;



(*****************  alarm_subsystem_command_handler  ********************)
(*									*)
(*			  keyword_to_alarm_type				*)
(*									*)
(*    Scan the keyword in the inline, convert to corresponding alarm	*)
(*    type.								*)
(*									*)
(************************************************************************)


function keyword_to_alarm_type (keyword : command_keyword_index) : alarm_type;

begin
  case keyword of
    ALARM_CREATE_NODE_KEYWORD:
      keyword_to_alarm_type := NODE_ALARM;

    ALARM_CREATE_HOST_KEYWORD:
      keyword_to_alarm_type := HOST_ALARM;

    ALARM_CREATE_LINK_KEYWORD,
    ALARM_CREATE_LINE_KEYWORD:
      keyword_to_alarm_type := LINK_ALARM;

    ALARM_CREATE_SLOT_KEYWORD:
      keyword_to_alarm_type := SLOT_ALARM;

    ALARM_CREATE_GENERAL_KEYWORD:
      keyword_to_alarm_type := GENERAL_ALARM
  end (* case *)
end (* scan_alarm_type *) ;



(*****************  alarm_subsystem_command_handler  ********************)
(*									*)
(*			  scan_list_command				*)
(*									*)
(*    Scan the list command.						*)
(*	LIST [<alarm name>|NODE [ALARM]|HOST [ALARM]|LINK [ALARM]|	*)
(*	GENERAL [ALARM]]						*)
(*									*)
(************************************************************************)


procedure scan_list_command(
  var scanned	: scanned_command);

var
  list_state	: (list_all, list_by_name, list_by_type);
  alarm_name	: symbol;
  keyword	: command_keyword_index;
  search_status	: alarm_search_status;

begin
  argument_scan.find_keyword (
    ALARM_CREATE_NODE_KEYWORD, ALARM_CREATE_GENERAL_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then list_state := LIST_BY_TYPE 
  else if scanned.status = ARG_MISSING
  then
    begin
      scanned.status := CMD_OK;
      if scanned.freeword_count > 0
      then
	begin
	  argument_scan.freeword_symbol(0, scanned, alarm_name);
	  list_state := LIST_BY_NAME
	end
      else list_state := LIST_ALL
    end;

  argument_scan.ignore_keyword (ALARM_CREATE_ALARM_KEYWORD, scanned);

  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then 
    begin
(*      response_buffer.start_put; *)
	format.start;
	case list_state of
	  LIST_ALL:
      	    alarm_common.list_all_alarms(user_terminal, format, printer);

	  LIST_BY_NAME:
	    begin
	      alarm_common.list_alarm_by_name(
		alarm_name, user_terminal, format, printer, search_status);
	      check_search_status(search_status, scanned)
	    end;

	  LIST_BY_TYPE:
	    alarm_common.list_alarm_by_type(
	      keyword_to_alarm_type (keyword),
	      user_terminal, format, printer)
	end (* case *) 
(*      response_buffer.print(user_terminal) *)
    end
end (* scan_list_command *) ;



(*****************  alarm_subsystem_command_handler  ********************)
(*									*)
(*		        scan_delete_command				*)
(*									*)
(*    Scan the delete  command.						*)
(*    DELETE <alarm name>						*)
(*									*)
(************************************************************************)


procedure scan_delete_command(
  var scanned	: scanned_command);

var
  alarm_name	: symbol;
  search_status	: alarm_search_status;

begin
  argument_scan.freeword_symbol(0, scanned, alarm_name);

  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
      alarm_common.delete(user, alarm_name, search_status);
      check_search_status(search_status, scanned)
    end
end (* scan_delete_command *) ;



(*****************  alarm_subsystem_command_handler  ********************)
(*									*)
(*		        scan_modify_command				*)
(*									*)
(*    Scan the modify command.						*)
(*    MODIFY <alarm name>						*)
(*									*)
(************************************************************************)


procedure scan_modify_command(
  var scanned	: scanned_command);

var
  alarm_name	: symbol;
  token		: alarm_token;
  search_status	: alarm_search_status;

begin
  argument_scan.freeword_symbol(0, scanned, alarm_name);

  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
      alarm_common.modify(
	user, alarm_name, token, search_status);
      check_search_status(search_status, scanned);
    
      if scanned.status = CMD_OK
      then 
	begin
	  command_read.remove_context(ALARM_CONTEXT);
	  modify_mode(scanned, alarm_name, token);
	  command_read.add_context(ALARM_CONTEXT)
	end
    end
end (* scan_modify_command *) ;



(*****************  alarm_subsystem_command_handler  ********************)
(*									*)
(*		        scan_create_command				*)
(*									*)
(*    Scan the create command.						*)
(*  CREATE <alarm name> {NODE|HOST|LINK|SLOT|GENERAL}<condition>[ALARM]	*)
(*									*)
(************************************************************************)


procedure scan_create_command(
  var scanned	: scanned_command);

var
  alarm_name	: symbol;
  token		: alarm_token;
  keyword	: command_keyword_index;
  cond_kind	: condition_log_entry_kind;
  search_status	: alarm_search_status;

begin
  argument_scan.freeword_symbol(0, scanned, alarm_name);

  if scanned.status = CMD_OK
  then token.kind := keyword_to_alarm_type (scanned.subcommand);

  if scanned.status = CMD_OK
  then
$if    reload
    argument_scan.find_keyword (
      ALARM_CREATE_THRESHOLD_KEYWORD, ALARM_CREATE_RELOADING_KEYWORD,
      scanned, keyword);
$endif reload
$ifnot reload
    argument_scan.find_keyword (
      ALARM_CREATE_THRESHOLD_KEYWORD, ALARM_CREATE_OUT_KEYWORD,
      scanned, keyword);
$endif reload

  if scanned.status = CMD_OK
  then
    case scanned.subcommand of
      ALARM_CREATE_NODE_KEYWORD:
        if keyword = ALARM_CREATE_CRASH_KEYWORD
	then cond_kind := NODE_LOST_CONDITION
$if reload
	else if keyword = ALARM_CREATE_RELOADING_KEYWORD
	then
	  if argument_scan.check_keyword(ALARM_CREATE_FAILURE_KEYWORD, scanned)
	  then cond_kind := NODE_RELOAD_FAIL_CONDITION
	  else cond_kind := RELOADING_NODE_CONDITION
$endif reload
	else scanned.status := ARG_ERROR;

      ALARM_CREATE_SLOT_KEYWORD:
	if keyword = ALARM_CREATE_CRASH_KEYWORD
	then cond_kind := SLOT_HALTED_CONDITION
$if reload
	else if keyword = ALARM_CREATE_RELOADING_KEYWORD
	then
	  if argument_scan.check_keyword(ALARM_CREATE_FAILURE_KEYWORD, scanned)
	  then cond_kind := SLOT_RELOAD_FAIL_CONDITION
	  else cond_kind := RELOADING_SLOT_CONDITION
$endif reload
	else if keyword = ALARM_CREATE_SUSPENDED_KEYWORD
	then cond_kind := SLOT_SUSPENDED_CONDITION
	else scanned.status := ARG_ERROR;

      ALARM_CREATE_HOST_KEYWORD:
	if keyword = ALARM_CREATE_GONE_KEYWORD
	then cond_kind := HOST_GONE_CONDITION
	else if keyword = ALARM_CREATE_DOWN_KEYWORD
	then cond_kind := HOST_DOWN_CONDITION
	else if keyword = ALARM_CREATE_SHUT_KEYWORD
	then cond_kind := HOST_SHUT_CONDITION
	else scanned.status := ARG_ERROR;

      ALARM_CREATE_LINK_KEYWORD:
	if keyword = ALARM_CREATE_SHUT_KEYWORD
	then cond_kind := LINK_SHUT_CONDITION
	else scanned.status := ARG_ERROR;

      ALARM_CREATE_LINE_KEYWORD:
	if keyword = ALARM_CREATE_OUT_KEYWORD
	then cond_kind := LINE_OUT_CONDITION
	else scanned.status := ARG_ERROR;

      ALARM_CREATE_GENERAL_KEYWORD:
	if keyword = ALARM_CREATE_THRESHOLD_KEYWORD
	then cond_kind := THRESHOLD_CONDITION
	else scanned.status := ARG_ERROR

  end (* case *) ;

  argument_scan.ignore_keyword (ALARM_CREATE_ALARM_KEYWORD, scanned);

  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
      alarm_common.create(
	user, alarm_name, cond_kind, token, search_status);
      check_search_status(search_status, scanned);
    
      if scanned.status = CMD_OK
      then 
	begin
	  command_read.remove_context(ALARM_CONTEXT);
	  modify_mode(scanned, alarm_name, token);
	  command_read.add_context(ALARM_CONTEXT)
	end
    end
end (* scan_create_command *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*			 execute_alarm_command	 			*)
(*									*)
(*	This is the command loop for alarm commands.			*)
(*									*)
(************************************************************************)



procedure execute_alarm_command(
  var scanned	: scanned_command);

begin
  command_read.add_context(ALARM_CONTEXT);

  repeat
    command_read.get_command(scanned);
    if user_terminal.available
    then
      begin
	case scanned.command of
	  ALARM_DELETE:
	    scan_delete_command(scanned);

	  ALARM_MODIFY:
	    scan_modify_command(scanned);

	  ALARM_LIST:
	    scan_list_command(scanned);

	  ALARM_CREATE:
	    scan_create_command(scanned);

	  ALARM_RETURN:
	    argument_scan.extra_argument_check (scanned)
	end (* case *) ;

	scan_error.display_command_error(scanned)
      end
  until (scanned.command = ALARM_RETURN) or
	not user_terminal.available;

  command_read.remove_context(ALARM_CONTEXT)
end (* execute_alarm_command *) ;



(*******************  alarm_subsystem_command_handler  ******************)
(*									*)
(*			   scan_alarm_command				*)
(*									*)
(*	Scan the alarm command for switching to alarm_context.		*)
(*									*)
(************************************************************************)



procedure entry scan_alarm_command(
  var scanned	: scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then execute_alarm_command(scanned)
end (* scan_alarm_command *) ;



(******************  alarm_subsystem_command_handler  *****************)
(**********************************************************************)


begin
end (* alarm_subsystem_command_handler *) ;
$endif alarm

  !
(************************************************************************)
(*									*)
(*      PROSUB.TMS  Updated 15-Dec-86 at 17:01 by Raffo 		*)
(*									*)
(*		profile_subsystem_command_handler			*)
(*									*)
(*	This class handles the commands which access and modify the     *)
(*	user data base in user_common and which can be accessed only    *)
(*	from the profile subsystem.					*)
(*									*)
(*        The following identifiers must be defined externally:		*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	20Jan86 Original (from (patrol)usrmnt.tms) -- gde		*)
(*	05May86 Adapt for Auto Backup	-- dlp				*)
(*									*)
(************************************************************************)



type
  profile_subsystem_command_handler =
    class(
      user		: user_index;
      user_terminal	: circuit_handler;
      argument_scan	: argument_scanner;
      format		: internal_to_string;
      command_read	: command_loop;
      scan_error	: command_error_message;
      profile		: user_profile;
      user_common	: global_user_data;
      printer		: set_printer;
      maintain_users	: userdata_maintenance);

var
  password_scanner	: password_reader;
  terminal_operator	: terminal_utility;
  color_operator	: color_utility;
  host_operator 	: host_utility;
  node_operator         : node_utility;
  event_operator        : event_utility;

  profile_username	: symbol;
!
(****************  profile_subsystem_command_handler  *****************)
(*                                                                    *)
(*                             initialize                             *)
(*                                                                    *)
(*    Monitor initialization.					      *)
(*                                                                    *)
(**********************************************************************)


procedure initialize;

begin
  init password_scanner (user_terminal);
  init node_operator, host_operator, event_operator;
  init terminal_operator, color_operator
end (* initialize *) ;



(****************  profile_subsystemaintenance	*************************)
(*									*)
(*			     time_zone_name				*)
(*									*)
(*    Convert time zone bias to a readable message.			*)
(*									*)
(************************************************************************)



procedure time_zone_name(time_zone: zone_bias);

var
  x: zone_bias;

begin
  format.string('GMT\');
  if time_zone <> 0
  then
    begin
      x := time_zone;
      if x > 0
      then format.string(' + \')
      else
	begin
	  x := -time_zone;
	  format.string(' - \')
	end;
      format.number(x div 60, 10);
      format.string(' hours \');
      if (x mod 60) <> 0
      then
	begin
	  format.number(x mod 60, 10);
	  format.string('minutes\')
	end
    end
end (* time_zone_name *) ;



(****************  profile_subsystemaintenance	*************************)
(*									*)
(*			daylight_savings_setting			*)
(*									*)
(*    Convert daylight savings to readable message.			*)
(*									*)
(************************************************************************)



procedure daylight_savings_setting(setting: boolean);

begin
  if not setting
  then format.string('not \ ');
  format.string('subject to daylight savings\')
end (* daylight_savings_setting *) ;


(****************  profile_subsystem_command_handler  *****************)
(*                                                                    *)
(*                       	list_color	                      *)
(*                                                                    *)
(*    List a single color code.					      *)
(*                                                                    *)
(**********************************************************************)



procedure list_color (color_code : char);

var
  color		: standard_color;
  flashing	: boolean;
  separate	: boolean;
  color_symbol	: symbol;

begin
  color_operator.unpack_event_color(color_code, color, flashing, separate);
  color_operator.color_to_symbol(color, color_symbol);
  format.symbol_string(color_symbol);

  if flashing
  then format.string(' FLASHING\');

  if separate
  then format.string(' SEPARATE\');
end (* list_color *) ;



(****************  profile_subsystem_command_handler  *****************)
(*                                                                    *)
(*                          list_event_color                          *)
(*                                                                    *)
(*    List the colors for an event_color set.			      *)
(*                                                                    *)
(**********************************************************************)



procedure list_event_color (colors_to_list : profile_color);

var
                           (* no. of events whose color hasn't been printed *)
  remaining             : integer ;
                           (* events which have had colors printed *) 
  events_printed        : main_event_subset ;
  e                     : main_event_index;
                           (* lowest event whose color not printed *)
  next_event            : main_event_index ;
  			   (* color value of current events, color_events *)
  color_code            : char ;
                           (* events of same color, color_code *) 
  color_events          : main_event_subset ;
  first_position        : integer;

begin
  first_position := format.buffer.pointer;
  next_event     := 1;
  remaining      := main_event_max - next_event;
  events_printed := [];

  while remaining > 0 do
    begin
      while next_event in events_printed do
        next_event := next_event + 1;
      color_code   := colors_to_list.main_color[next_event];
      color_events := [];

      for e := next_event to main_event_limit do
	if color_code = colors_to_list.main_color[e]
	then
	  begin
	    remaining    := remaining-1;
	    color_events := color_events or [e];
	    if e = next_event 
	    then
	      next_event := next_event+1
	  end (* for *) ;

      events_printed := events_printed or color_events;
      list_color(color_code);
      format.skip(1);
      printer.print_event_subset (color_events);

      if remaining > 0
      then
	begin
	  format.write_line(user_terminal);
	  format.start;
	  format.skip_to(first_position)
	end
    end (* while *)
end (* list_event_color *) ;




(****************  profile_subsystem_command_handler  *****************)
(*                                                                    *)
(*                            list_profile                           *)
(*                                                                    *)
(*    List a profile, listing only those sets that are not empty.     *)
(*                                                                    *)
(**********************************************************************)



procedure list_profile (profile_to_list : profile_header);

begin
  format.start;
  format.symbol_string(profile_to_list.access.name);
  format.skip_to(symbol_text_max+2);
  maintain_users.terminal_name(profile_to_list.access.terminal_used);
  format.skip(1);
  time_zone_name(profile_to_list.access.time_zone);
  format.skip(1);
  daylight_savings_setting(profile_to_list.access.daylight_savings);
  format.write_line (user_terminal);
  format.start;
  format.string('Password last changed: \');
  format.time(profile.time(profile_to_list.access.password_changed));
  format.write_line(user_terminal);
  format.start;
  format.string('license: \');
  printer.print_license_set(profile_to_list.access.allowed_license);
  format.write_line(user_terminal);
  format.start;
  format.string('nodes: \');
  printer.print_node_set(profile_to_list.access.allowed_nodes);
  format.write_line(user_terminal);
  format.start;
  format.string('hosts: \');
  printer.print_host_set(profile_to_list.access.allowed_hosts);
  format.write_line(user_terminal);
  format.start;
  format.string('events: \ ');
  printer.print_event_subset (profile_to_list.access.allowed_events);
  format.write_line(user_terminal);
  format.start;
  format.string('color: \');
  list_event_color(profile_to_list.colors);
  format.write_line(user_terminal)
end (* list_profile *) ;
 


(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		      scan_modify_list_command 				*)
(*									*)
(*    Scan and execute the list command in modify mode. 		*)
(*									*)
(************************************************************************)



procedure scan_modify_list_command(
      profile_to_list	: profile_header;
  var scanned			: scanned_command);

var
  keyword: command_keyword_index;

begin
  if scanned.keyword_count = 0
  then
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then list_profile(profile_to_list)
    end
  else
    begin
      argument_scan.find_keyword(
	MODIFY_LIST_DAYLIGHTSAVINGS_KEYWORD,
	MODIFY_LIST_COLOR_KEYWORD,
	scanned,
	keyword);
      argument_scan.extra_argument_check(scanned);

      if scanned.status = CMD_OK
      then
	begin
	  format.start;
	  case keyword of
	    MODIFY_LIST_TERMINAL_KEYWORD:
	      maintain_users.terminal_name(
		profile_to_list.access.terminal_used);

	    MODIFY_LIST_ZONE_KEYWORD:
	      time_zone_name(profile_to_list.access.time_zone);

	    MODIFY_LIST_DAYLIGHTSAVINGS_KEYWORD:
	      daylight_savings_setting(
		profile_to_list.access.daylight_savings);

	    MODIFY_LIST_LICENSES_KEYWORD:
	      printer.print_license_set(
		profile_to_list.access.allowed_license);

	    MODIFY_LIST_NODES_KEYWORD:
              printer.print_node_set(
	        profile_to_list.access.allowed_nodes);

	    MODIFY_LIST_HOSTS_KEYWORD:
	      printer.print_host_set(
		profile_to_list.access.allowed_hosts);

	    MODIFY_LIST_EVENTS_KEYWORD:
	      printer.print_event_subset(
	        profile_to_list.access.allowed_events);

	    MODIFY_LIST_COLOR_KEYWORD:
	      list_event_color(profile_to_list.colors)

 	  end (* case *) ;
	  format.write_line(user_terminal)
	end
    end
end (* scan_modify_list_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		 scan_modify_change_password_command			*)
(*									*)
(*    Scan the password command in modify mode. Set new password in	*)
(*    profile.								*)
(*									*)
(************************************************************************)



procedure scan_modify_change_password_command(
  var scanned		: scanned_command;
  var modify_profile	: profile_header);

var
  new_password: integer;
  ok: boolean;

begin
  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
      password_scanner.get_new_cipher(
	'(:13:)(:10:)Password: \ ', new_password, ok);
      if ok
      then
	begin
	  if new_password <> modify_profile.access.password
	  then modify_profile.access.password_changed := realtime;
	  modify_profile.access.password := new_password
	end
    end
end (* scan_modify_change_password_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		    scan_modify_change_zone_command 			*)
(*									*)
(*    Scan and execute the zone command in modify mode for setting	*)
(*    time zone bias.							*)
(*									*)
(************************************************************************)



procedure scan_modify_change_zone_command(
  var scanned		: scanned_command;
  var modify_profile	: profile_header);

var
  zone: integer;

begin
  argument_scan.freeword_number(0, 10, scanned, zone);
  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    if abs(zone) > 720
    then scanned.status := ARG_ZONE_ERROR
    else modify_profile.access.time_zone := zone
end (* scan_modify_change_zone_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*	          scan_modify_change_daylight_command			*)
(*									*)
(*	Scan the daylightsavings command.  Format is:			*)
(*	   CHANGE DAYLIGHTSAVINGS {OFF | ON}				*)
(*									*)
(************************************************************************)



procedure scan_modify_change_daylight_command(
  var scanned		: scanned_command;
  var modify_profile	: profile_header);

var
  keyword	: command_keyword_index;

begin
  argument_scan.find_keyword(
    MODIFY_CHANGE_OFF_KEYWORD, MODIFY_CHANGE_ON_KEYWORD, scanned, keyword);
  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    modify_profile.access.daylight_savings := 
      keyword = MODIFY_CHANGE_ON_KEYWORD
end (* scan_modify_change_daylight_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		    scan_modify_change_terminal_command			*)
(*									*)
(*    Scan and execute the terminal command. Set new terminal           *)
(*    type in profile.                                                  *)
(*									*)
(************************************************************************)


procedure scan_modify_change_terminal_command(
	var scanned             : scanned_command;
	var modify_profile      : profile_header);

var
  keyword    : command_keyword_index;

begin
  argument_scan.find_keyword(
    FIRST_MODIFY_CHANGE_TERMINAL_KEYWORD, LAST_MODIFY_CHANGE_TERMINAL_KEYWORD,
    scanned, keyword);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    modify_profile.access.terminal_used := 
      terminal_operator.index_to_terminal(
  	keyword - FIRST_MODIFY_CHANGE_TERMINAL_KEYWORD)
end (* scan_modify_change_terminal_command *) ;


 
(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		    scan_modify_change_color_command			*)
(*									*)
(*    Scan and execute the color command. Set new colors in profile     *)
(*									*)
(************************************************************************)


procedure scan_modify_change_color_command(
   var scanned            : scanned_command;
   var modify_profile     : profile_header);

var
  color_events            : main_event_subset;
  color                   : standard_color;
  flashing                : boolean;
  separate                : boolean;
  keyword                 : command_keyword_index;
  color_code              : char;
  e                       : main_event_index;

begin
  argument_scan.freeword_main_event_set(0, scanned, color_events);

  if scanned.status = CMD_OK
  then
    begin
      argument_scan.find_keyword(FIRST_MODIFY_CHANGE_COLOR_KEYWORD,
        LAST_MODIFY_CHANGE_COLOR_KEYWORD, scanned, keyword);

      if scanned.status = CMD_OK
      then color := keyword - FIRST_MODIFY_CHANGE_COLOR_KEYWORD
      else if scanned.status = ARG_MISSING
      then
	begin
	  scanned.status := CMD_OK;
	  color := WHITE
	end;

      if scanned.status = CMD_OK
      then
	begin
	  flashing :=
	    argument_scan.check_keyword(
              MODIFY_CHANGE_FLASHING_KEYWORD, scanned);
	  separate :=
	    argument_scan.check_keyword(
	      MODIFY_CHANGE_SEPARATE_KEYWORD, scanned)
	end
    end;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then 
    begin
      color_operator.pack_event_color(color, flashing, separate, color_code);
      for e := 1 to MAIN_EVENT_LIMIT do
	if e in color_events
	then modify_profile.colors.main_color[e] := color_code
    end
end (* scan_modify_change_color_command *) ;


 
(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		    scan_add_remove_licenses_command			*)
(*									*)
(*    Scan and execute the add and remove command in modify mode.	*)
(*									*)
(************************************************************************)


procedure scan_add_remove_licenses_command(
  var scanned		: scanned_command;
  var modify_profile	: profile_header);

var
  new_license_set	: license_set;

begin
  argument_scan.keyword_license_set(
    FIRST_MODIFY_ADD_LICENSE_KEYWORD, LAST_MODIFY_ADD_LICENSE_KEYWORD,
    scanned, new_license_set);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_common.restrict_license_set(user, new_license_set);
      case scanned.command of
	MODIFY_ADD:
	  modify_profile.access.allowed_license :=
	    modify_profile.access.allowed_license or new_license_set;

	MODIFY_REMOVE:
	  modify_profile.access.allowed_license :=
	    modify_profile.access.allowed_license - new_license_set
      end (* case *)
    end
end (* scan_add_remove_licenses_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		  scan_modify_add_remove_hosts_command 			*)
(*									*)
(*    Scan and execute the add and remove hosts command in modify mode.	*)
(*									*)
(************************************************************************)


procedure scan_add_remove_hosts_command(
  var scanned		: scanned_command;
  var modify_profile	: profile_header);

var
  new_host_set	: host_set;

begin
  argument_scan.freeword_host_set(0, scanned, new_host_set);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_common.restrict_host_set(user, new_host_set);
      case scanned.command of
	MODIFY_ADD:
	  host_operator.add_host_set(
	    new_host_set, modify_profile.access.allowed_hosts);

	MODIFY_REMOVE:
	  host_operator.remove_host_set(
	    new_host_set, modify_profile.access.allowed_hosts)
      end (* case *)
    end
end (* scan_add_remove_hosts_command *) ;


(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		  scan_add_remove_nodes_command 			*)
(*									*)
(*    Scan and execute the add and remove nodes command in modify mode.	*)
(*									*)
(************************************************************************)


procedure scan_add_remove_nodes_command(
	var scanned         : scanned_command;
	var modify_profile  : profile_header);

var
  new_node_set : node_set;

begin
  argument_scan.freeword_node_set(0, scanned, new_node_set);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_common.restrict_node_set(user, new_node_set);
      case scanned.command of
 	MODIFY_ADD:
	  node_operator.add_node_set(
	    new_node_set, modify_profile.access.allowed_nodes);

	MODIFY_REMOVE:
	  node_operator.remove_node_set(
	    new_node_set, modify_profile.access.allowed_nodes)
      end (* case *) 
    end
end (* scan_add_remove_nodes_command *) ;


(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		  scan_add_remove_events_command			*)
(*									*)
(*   Scan and execute the add and remove events command in modify mode.	*)
(*									*)
(************************************************************************)



procedure scan_add_remove_events_command(
	var scanned         : scanned_command;
	var modify_profile  : profile_header);
 
var
  new_events : main_event_subset;

begin
  argument_scan.freeword_main_event_set(0, scanned, new_events);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_common.restrict_event_set(user, new_events);
      case scanned.command of
	MODIFY_ADD:
	  event_operator.add_main_event_subset(
	    new_events, modify_profile.access.allowed_events);
	
	MODIFY_REMOVE:
	  event_operator.remove_main_event_subset(
	    new_events, modify_profile.access.allowed_events)
      end (* case *) 
    end
end (* scan_add_remove_events_command *) ;

!
(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*			      modify_mode				*)
(*									*)
(*    This is the command level when modifying or creating a profile.	*)
(*    It assumes that the profile has been locked by either a		*)
(*    create or modify call to user_common. It insures that the 	*)
(*    profile is unlocked before exiting by doing either a cancel	*)
(*    or a write to user_common.					*)
(*									*)
(************************************************************************)



procedure modify_mode(
$if    auto_backup
      backup_file	: backup_profile_file_transaction_index;
$endif auto_backup
  var scanned		: scanned_command;
  var modify_profile	: profile_header);

var
  state: (MODIFYING, ABORTING, UPDATING);
  search_status: user_search_status;

begin
  command_read.add_context(MODIFY_CONTEXT);

  state := MODIFYING;

  repeat
    command_read.get_command(scanned);

    if user_terminal.available 
    then
      begin
	case scanned.command of
	  MODIFY_LIST:
	    scan_modify_list_command(modify_profile, scanned);

	  MODIFY_CHANGE:
	    case scanned.subcommand of
	      MODIFY_CHANGE_PASSWORD_KEYWORD:
		scan_modify_change_password_command(scanned, modify_profile);
	      MODIFY_CHANGE_ZONE_KEYWORD:
		scan_modify_change_zone_command(scanned, modify_profile);
	      MODIFY_CHANGE_DAYLIGHTSAVINGS_KEYWORD:
		scan_modify_change_daylight_command(scanned, modify_profile);
	      MODIFY_CHANGE_TERMINAL_KEYWORD:
		scan_modify_change_terminal_command(scanned, modify_profile);
	      MODIFY_CHANGE_COLOR_KEYWORD:
		scan_modify_change_color_command(scanned, modify_profile)
	    end (* MODIFY_CHANGE *) ;

	  MODIFY_ADD,
	  MODIFY_REMOVE:
	    begin
	      if user_common.check_username(modify_profile.access.name)
	      then maintain_users.external_report_status(USER_CANNOT_MODIFY)
	      else
          	case scanned.subcommand of
	          MODIFY_ADD_HOSTS_KEYWORD:
		    scan_add_remove_hosts_command(scanned, modify_profile);
	          MODIFY_ADD_LICENSES_KEYWORD:
		    scan_add_remove_licenses_command(scanned, modify_profile);
	          MODIFY_ADD_NODES_KEYWORD:
		    scan_add_remove_nodes_command(scanned, modify_profile);
                  MODIFY_ADD_EVENTS_KEYWORD:
		    scan_add_remove_events_command(scanned, modify_profile)
	        end (* case *)
	    end (* MODIFY_ADD *) ;


	  MODIFY_ABORT:
	    state := ABORTING;

	  MODIFY_RETURN,
	  MODIFY_UPDATE:
	    state := UPDATING

	end (* case *) ;

	scan_error.display_command_error(scanned)

      end;

    if not user_terminal.available
    then state := ABORTING

  until state <> MODIFYING;

  case state of
    ABORTING:
      user_common.cancel(user, search_status);
    UPDATING:
$if    auto_backup
      user_common.write (user, backup_file, modify_profile, search_status)
$endif auto_backup
$ifnot auto_backup
      user_common.write (user, modify_profile, search_status)
$endif not auto_backup
  end (* case *) ;

  maintain_users.external_check_search_status(search_status, scanned);

  command_read.remove_context(MODIFY_CONTEXT)
end (* modify_mode *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*			      create_mode				*)
(*									*)
(*    Called to create a new profile with initial profile_header and	*)
(*    username to create. Gets password and enters modify mode. 	*)
(*									*)
(************************************************************************)



procedure create_mode(
      username	  : symbol;
  var scanned	  : scanned_command;
  var new_profile : profile_header);

var
  search_status: user_search_status;
  ok: boolean;

begin
  new_profile.access.name := username;
  user_common.create(user, username, search_status);
  maintain_users.external_check_search_status(search_status, scanned);
  if scanned.status = CMD_OK
  then
    begin
      password_scanner.get_new_cipher(
	'(:13:)(:10:)Password: \ ', new_profile.access.password, ok);
      new_profile.access.password_changed := realtime;
      if ok
$if    auto_backup
      then modify_mode (BACKUP_PROFILE_NEW_USER_FILE, scanned, new_profile)
$endif auto_backup
$ifnot auto_backup
      then modify_mode (scanned, new_profile)
$endif not auto_backup
      else
	begin
	  user_common.cancel(user, search_status);
	  maintain_users.external_check_search_status(search_status, scanned)
	end
    end
end (* create_mode *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*			  scan_create_command				*)
(*									*)
(*    Scan the create command.						*)
(*									*)
(************************************************************************)


procedure scan_create_command(
  var scanned	: scanned_command);

var
  username: symbol;
  as_username: symbol;
  new_profile	: profile_header;
  limit : limit_set_index;

begin
  argument_scan.freeword_symbol(0, scanned, username);

  if scanned.status = CMD_OK
  then
    if argument_scan.check_keyword(PROFILE_CREATE_AS_KEYWORD, scanned)
    then 
      argument_scan.keyword_symbol(
	PROFILE_CREATE_AS_KEYWORD, scanned, as_username)
    else as_username := profile_username;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then maintain_users.get_profile(as_username, scanned, new_profile);
  if scanned.status = CMD_OK
  then
    begin
      (* set default limit set to null *)
      new_profile.access.default_limit_set.size := 0;

      (* set limit sets initially to null *)
      for limit := 0 to limit_set_limit do
        new_profile.access.limit_set_names[limit].size := 0;

      user_common.restrict_node_set(
	user, new_profile.access.allowed_nodes);
      user_common.restrict_event_set(
	user, new_profile.access.allowed_events);
      user_common.restrict_license_set(
	user, new_profile.access.allowed_license);
      user_common.restrict_host_set(
	user, new_profile.access.allowed_hosts);

      command_read.remove_context(PROFILE_CONTEXT);
      create_mode(username, scanned, new_profile);
      command_read.add_context(PROFILE_CONTEXT)

    end
end (* scan_create_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*			  scan_modify_command				*)
(*									*)
(*    Scan the modify command.						*)
(*									*)
(************************************************************************)



procedure scan_modify_command(
  var scanned	: scanned_command);

var
  username: symbol;
  modify_profile: profile_header;
  search_status: user_search_status;

begin
  if scanned.freeword_count = 0
  then username := profile_username
  else if not profile.license_check (UPD_LICENSE)
  then scanned.status := AUTH_ERROR
  else argument_scan.freeword_symbol(0, scanned, username);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_common.modify(user, username, modify_profile, search_status);
      maintain_users.external_check_search_status(search_status, scanned);
      if scanned.status = CMD_OK
      then
	begin
	  command_read.remove_context(PROFILE_CONTEXT);
$if    auto_backup
	  modify_mode (BACKUP_PROFILE_MOD_USER_FILE, scanned, modify_profile);
$endif auto_backup
$ifnot auto_backup
	  modify_mode (scanned, modify_profile);
$endif not auto_backup
	  command_read.add_context(PROFILE_CONTEXT)
	end
    end
end (* scan_modify_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*			  scan_delete_command				*)
(*									*)
(*    Scan the delete command.						*)
(*									*)
(************************************************************************)


procedure scan_delete_command(
  var scanned	: scanned_command);

var
  username: symbol;
  search_status: user_search_status;

begin
  argument_scan.freeword_symbol(0, scanned, username);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_common.delete(username, search_status);
      maintain_users.external_check_search_status(search_status, scanned)
    end
end (* scan_delete_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*			scan_list_all_command				*)
(*									*)
(*    Scan the list profile command for all profiles.			*)
(*									*)
(************************************************************************)


procedure scan_list_all_command(
  var scanned	: scanned_command);

var
  search_status: user_search_status;
  profile_to_list: profile_header;

begin
  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
      user_common.examine_start(user);
      repeat
	user_common.examine_next(user, profile_to_list, search_status);
	if search_status = USER_OK
	then list_profile(profile_to_list)
      until (search_status = USER_DOES_NOT_EXIST) or
	    not user_terminal.sendable
    end
end (* scan_list_all_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*		      scan_list_profile_command				*)
(*									*)
(*    Scan the list profile command for an individual profile.		*)
(*									*)
(************************************************************************)


procedure scan_list_profile_command(
  var scanned	: scanned_command);

var
  username: symbol;
  profile_to_list: profile_header;

begin
  if argument_scan.check_keyword(PROFILE_LIST_PROFILE_KEYWORD, scanned)
  then
    argument_scan.keyword_symbol(
      PROFILE_LIST_PROFILE_KEYWORD, scanned, username)
  else username := profile_username;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then maintain_users.get_profile(username, scanned, profile_to_list);
  if scanned.status = CMD_OK
  then list_profile(profile_to_list)
end (* scan_list_profile_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*			execute_profile_command	 			*)
(*									*)
(*	This is the command loop for profile commands.			*)
(*									*)
(************************************************************************)



procedure execute_profile_command(
  var scanned	: scanned_command);

begin
  command_read.add_context(PROFILE_CONTEXT);

  repeat
    command_read.get_command(scanned);
    if user_terminal.available
    then
      begin
	case scanned.command of
	  PROFILE_DELETE:
	    scan_delete_command(scanned);

	  PROFILE_LIST:
	    if argument_scan.check_keyword(
		 PROFILE_LIST_ALL_KEYWORD, scanned)
	    then scan_list_all_command(scanned)
	    else scan_list_profile_command(scanned);

	  PROFILE_MODIFY:
	    scan_modify_command(scanned);

	  PROFILE_CREATE:
	    scan_create_command(scanned);

	  PROFILE_RETURN:
	    (* empty *)
	end (* case *) ;

	scan_error.display_command_error(scanned)
      end
  until (scanned.command = PROFILE_RETURN) or
	not user_terminal.available;

  command_read.remove_context(PROFILE_CONTEXT)
end (* execute_profile_command *) ;



(****************  profile_subsystem_command_handler  *******************)
(*									*)
(*			  scan_profile_command	 			*)
(*									*)
(*	Scan the profile command for switching to profile_context.	*)
(*									*)
(************************************************************************)



procedure entry scan_profile_command(
  var scanned	: scanned_command);

begin
  if scanned.freeword_count = 0
  then profile.name (profile_username)
  else if not profile.license_check (UPD_LICENSE)
  then scanned.status := AUTH_ERROR
  else argument_scan.freeword_symbol(0, scanned, profile_username);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then execute_profile_command(scanned)
end (* scan_profile_command *) ;




(****************  profile_subsystem_command_handler  *******************)
(************************************************************************)



begin (* initial statement *)
  initialize
end (* profile_subsystem_command_handler *) ;
    $if probe
!
(************************************************************************)
(*                                                              	*)
(*      PROBE.TMS Updated 28-Sep-87 at 9:24 by Raffo             	*)
(*                          probe_execution                     	*)
(*                                                              	*)
(*    This class handles the execution of all probe commands.   	*)
(*                                                              	*)
(*                                                              	*)
(************************************************************************)
(*                                                              	*)
(*                           Revision Record                    	*)
(*                                                              	*)
(*    22Aug80 Original -- rer                                   	*)
(*    25Jun81 Removed response buffer init to execution -- rer  	*)
(*    10Dec81 Added FRONT_END interface	-- ebs				*)
(*    22Jun82 Add ULOGA, ULOGH, OV, LACCT commands - rer		*)
(*    20Jan86 Adapt to new command scanner -- gde			*)
(*                                                              	*)
(************************************************************************)



type
  probe_execution =
    class (
      multiplexer	: probe_multiplexer;
      commands          : command_table;
      user_terminal	: circuit_handler;
      supervisor_common	: global_supervisor_data;
      profile		: user_profile;
      user		: user_index;
      format		: internal_to_string;
      message_operator	: message_utility;
      argument_scan     : argument_scanner;
      command_read      : command_loop;
      scan_error	: command_error_message;
      command_scan      : command_scanner;
      response_buffer	: text_buffer;
      logger		: log_command_handler;
      display		: display_execution
    );

var
  node_operator: node_utility;
  host_operator: host_utility;
  password_scanner: password_reader;
  access_check	: user_access_checker;
  current_supervisor: supervisor_indicator (* supervisor next command will go to *) ;
  current_line: format_buffer (* next command or response line *) ;
  response_line_number: integer (* line number of current response *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                          append_password                     	*)
(*                                                              	*)
(*    Append password to current_line along with a carriage return	*)
(*    so that password will be sent to probe.                   	*)
(*                                                              	*)
(************************************************************************)



procedure append_password(password: password_string);

var
  i: password_text_index;

begin
  current_line.text[current_line.pointer] := '(:13:)';
  current_line.pointer := current_line.pointer+1;
  for i := 0 to password.size-1 do
    current_line.text[current_line.pointer+i] := password.text[i];
  current_line.pointer := current_line.pointer+password.size
end (* append_password *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                          verify_password                     	*)
(*                                                              	*)
(*    Request current password from user and append to current_line.	*)
(*                                                              	*)
(************************************************************************)



function verify_password(message: message_string): boolean;

var
  old_password: password_string;

begin
  supervisor_common.password(current_supervisor, old_password);
  verify_password := password_scanner.check(message, old_password);
  append_password(old_password)
end (* verify_password *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                            new_password                      	*)
(*                                                              	*)
(*    Get a new password and append two copies to command.      	*)
(*                                                              	*)
(************************************************************************)



procedure new_password(message: message_string;
                       var password: password_string;
                       var ok: boolean);

begin
  password_scanner.get_new_password(message, password, ok);
  append_password(password);
  append_password(password)
end (* new_password *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                         tokenize_response                    	*)
(*                                                              	*)
(*    tokenize the response from the multiplexer.			*)
(*                                                              	*)
(************************************************************************)



procedure tokenize_response (var scanned: scanned_command);

var
  i: command_line_text_index;

begin
  if current_line.pointer <= COMMAND_LINE_TEXT_MAX
  then scanned.input_line.size := current_line.pointer
  else scanned.input_line.size := COMMAND_LINE_TEXT_MAX;

  for i := 0 to scanned.input_line.size-1 do
    scanned.input_line.text[i] := current_line.text[i];

  command_scan.scan_response_line(scanned)
end (* tokenize_response *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                           check_command                      	*)
(*                                                              	*)
(*    Check if command just read is a valid command.            	*)
(*    Check if command is a probe command, that user is allowed to	*)
(*    give command and that the arguments are valid.            	*)
(*                                                              	*)
(************************************************************************)



procedure check_command(var scanned: scanned_command);

var
  ok: boolean;
  password: password_string;
  header: command_definition;
  i: command_token_index;
  j: command_freeword_total;
  k: command_name_text_size;
  node,node1,node2,host: integer;

begin
  commands.get_command_header(
    scanned.command_context, scanned.command, header);

  (* Put the command line in a buffer which will be send	*)
  (* later to Probe.                                  		*)

  for k := 0 to header.name.size-1 do
     current_line.text[k] := header.name.text[k];
  current_line.pointer := header.name.size;

  for j := 0 to scanned.freeword_count-1 do
    begin
      if current_line.pointer < TERMINAL_BUFFER_MAX
      then
 	begin
   	  current_line.text[current_line.pointer] := ASC_SPACE;
	  current_line.pointer := current_line.pointer + 1
	end;

      for i := scanned.freeword_value[j].start to
			       scanned.freeword_value[j].finish-1 do
	if current_line.pointer < TERMINAL_BUFFER_MAX
	then
	  begin
	    current_line.text[current_line.pointer] := 
	      scanned.input_line.text[i];
	    current_line.pointer := current_line.pointer + 1
	  end
    end;

  if (profile.required_license <> PROBE_00_LICENSE) and 
               	(profile.required_license <> NO_LICENSE)
  then 
    message_operator.report_audit_message(
      profile.required_license, scanned.input_line);

  (*  Commands with no argument or arguments that are not checked *)
 
  if (FIRST_PROBE_NO_ARGUMENT  <= scanned.command) and
			(scanned.command <= LAST_PROBE_NO_ARGUMENT)
  then ok := TRUE 

  (* Commands where the first argument is a node number *) 

  else if (FIRST_PROBE_NODE_NUMBER  <= scanned.command) and
			(scanned.command <= LAST_PROBE_NODE_NUMBER)
  then 
    begin
      argument_scan.freeword_node(0, scanned, node);
      if scanned.status = CMD_OK
      then ok := access_check.node_access_check(node)
      else ok := FALSE
    end

  (* Commands with two node numbers to check *)

  else if (FIRST_PROBE_TWO_NODE <= scanned.command) and
		(scanned.command <= LAST_PROBE_TWO_NODE)
  then
    begin
      argument_scan.freeword_node(0, scanned, node1);
      if scanned.status = CMD_OK
      then argument_scan.freeword_node(1, scanned, node2);
      if scanned.status = CMD_OK
      then ok := access_check.node_access_check(node1) or
		 access_check.node_access_check(node2)
      else ok := FALSE
    end (* probe_eshut&rshut_command *)

  (* Command with node number to check *)

  else if scanned.command = PROBE_COST
  then
    begin
      ok := TRUE;
      if scanned.freeword_count > 0
      then
	begin
	  argument_scan.freeword_node(0, scanned, node);
	  if scanned.status = CMD_OK
	  then ok := access_check.node_access_check(node)
	  else ok := FALSE
	end
   end (* probe_cost_command *)

  (* Command with host number to check *)

  else if scanned.command = PROBE_HOST
  then
    begin
      ok := TRUE;
      if scanned.freeword_count > 0
      then
	begin
	  argument_scan.freeword_host(0, scanned, host);
	  if scanned.status = CMD_OK
	  then ok := access_check.host_access_check(host)
	  else ok := FALSE
	end
     end (* probe_host_command *)

  (*  Commands requiring a password to be sent *)

  else if (FIRST_PROBE_REQUIRING_PASSWORD  <= scanned.command) and
			(scanned.command <= LAST_PROBE_REQUIRING_PASSWORD)
  then
    begin
      ok := verify_password('Password: \ ');
      if ok and ((scanned.command = PROBE_NETINC) or 
		  (scanned.command = PROBE_NETEXC))
      then
	if scanned.freeword_count > 0
	then 
	  begin
	    argument_scan.freeword_node(0, scanned, node1);
	    if (scanned.status = CMD_OK) and (scanned.freeword_count > 1)
	    then argument_scan.freeword_node(2, scanned, node2);
	    if scanned.status = CMD_OK
	    then ok := profile.node_access_check(node1) or
		       profile.node_access_check(node2)
	    else ok := FALSE
	  end
    end

  (* Commands requiring two passwords (both the same to be sent) *)

  else if scanned.command = PROBE_PSWD
  then
    begin
      new_password('Password: \ ', password, ok);
      user_terminal.write_newline
    end (* probe_pswd_command *)

  (* Command requiring three passwords to be sent *)

  else if scanned.command = PROBE_CHANGE
  then
    begin
      ok := verify_password('Old password: \ ');
      if ok
      then
	begin
	  user_terminal.write_newline;
	  new_password('Password: \ ', password, ok)
	end;
      if ok
      then supervisor_common.set_password (current_supervisor, password)
    end (* probe_change_command *) ;

  if ok 
  then scanned.status := CMD_OK
  else scanned.status := RUN_ERROR
end (* check_command *) ;




(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                           check_response                     	*)
(*                                                              	*)
(*    Eliminate any response lines which contain information that	*)
(*    user is not permitted to see.                             	*)
(*                                                              	*)
(************************************************************************)

 

procedure check_response(var scanned: scanned_command);

var
  ok: boolean;
  host, node, node1, node2: integer;

begin
  if (FIRST_PROBE_AU_AN <= scanned.command) and
			  (scanned.command <= LAST_PROBE_AU_AN)
  then
    begin
      tokenize_response(scanned);
      if scanned.status = CMD_OK
      then argument_scan.freeword_node(0, scanned, node);
      if scanned.status = CMD_OK
      then ok := profile.node_list_check(node)
      else ok := TRUE;
    end (* probe_an_command, probe_au_command *) 

  else if scanned.command = PROBE_HOST
  then
    begin
      tokenize_response(scanned);
      if scanned.status = CMD_OK
      then argument_scan.freeword_host(0, scanned, host);
      if scanned.status = CMD_OK
      then ok := profile.host_list_check(host)
      else ok := TRUE	
    end (* probe_host_command *) 

  else if (FIRST_PROBE_OV <= scanned.command) and
		      (scanned.command <= LAST_PROBE_LSHUT)
  then
    begin
      tokenize_response(scanned);
      if scanned.status = CMD_OK
      then argument_scan.freeword_node(0, scanned, node1);
      if scanned.status = CMD_OK
      then argument_scan.freeword_node(1, scanned, node2);
      if scanned.status = CMD_OK 
      then ok := profile.link_list_check(node1, node2)
      else ok := TRUE
    end (* probe_lshut_command, probe_ov_command *) 

  else if scanned.command = PROBE_EXC
  then
    begin
      tokenize_response(scanned);
      if scanned.status = CMD_OK
      then argument_scan.freeword_node(0, scanned, node1);
      if scanned.status = CMD_OK 
      then argument_scan.freeword_node(2, scanned, node2);
      if scanned.status = CMD_OK
      then ok := profile.link_list_check(node1, node2)
      else ok := TRUE
    end (* probe_exc_command *) 

  else if scanned.command = PROBE_CHANGE
  then
    ok := response_line_number > 4

  else if (FIRST_PROBE_MORE_TWO <= scanned.command) and
	      (scanned.command <= LAST_PROBE_MORE_TWO)
  then    
    ok := response_line_number > 2

  else if (FIRST_PROBE_CONTROL_RESPONSE <= scanned.command) and
	      (scanned.command <= LAST_PROBE_CONTROL_RESPONSE)
  then
    ok := response_line_number > 1

  else if (FIRST_PROBE_RESPONSE_NO_PROBLEM <= scanned.command) and
	      (scanned.command <= LAST_PROBE_RESPONSE_NO_PROBLEM)
  then
    ok := TRUE;

  if ok 
  then scanned.status := CMD_OK
  else scanned.status := RUN_ERROR
end (* check_response *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                       send_command_to_probe                  	*)
(*                                                              	*)
(*    Read and scan next probe command from user_terminal.      	*)
(*    Return false if probe circuit lost, user terminal lost or if	*)
(*    next command is an EXIT or RETURN command. All of these		*)
(*    conditions terminate the probe access by this user.       	*)
(*                                                              	*)
(************************************************************************)


procedure send_command_to_probe (
  var scanned		: scanned_command;
  var probe_available	: boolean);


var
  state: probe_user_state;

begin
  response_line_number := 0 (* no response lines yet *) ;
  response_buffer.start_put (* clear buffer for response *) ;

  check_command(scanned);

  if scanned.status = CMD_OK
  then
    if multiplexer.send_command (
	 user, current_supervisor, current_line.text, current_line.pointer)
    then
      repeat
	multiplexer.get_response (
	  user, current_line.text, current_line.pointer, state);
	response_line_number := response_line_number+1;
	case state of

	  PM_AVAILABLE:
	    begin
	      check_response(scanned);
	      if scanned.status = CMD_OK
	      then
		begin
		  current_line.text[current_line.pointer] := '(:13:)';
		  current_line.text[current_line.pointer+1] := '(:10:)';
		  current_line.pointer := current_line.pointer+2;
		  response_buffer.put (
		    current_line.text, current_line.pointer)
		end
	    end (* pm_available *);

	  PM_ABORT: probe_available := FALSE;

	  PM_RESPONSE_END: response_buffer.print(user_terminal)

	end (* case *)
      until state <> PM_AVAILABLE
    else probe_available := FALSE
end (* send_command_to_probe *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                              command                         	*)
(*                                                              	*)
(*    Read and scan next probe command from user_terminal.      	*)
(*    Return false if probe circuit lost, user terminal lost or if	*)
(*    next command is an EXIT or RETURN command. All of these		*)
(*    conditions terminate the probe access by this user.       	*)
(*                                                              	*)
(************************************************************************)



procedure command (
  var scanned	: scanned_command;
  var ok	: boolean);

var
  probe_available: boolean;

begin
  probe_available := TRUE;
  ok := TRUE;

  command_read.get_command(scanned);

  if scanned.status = CMD_OK
  then
    if (scanned.command = PROBE_EXIT) or (scanned.command = PROBE_RETURN)
    then
      begin
	argument_scan.extra_argument_check (scanned);
	ok := scanned.status <> CMD_OK
      end
    else if scanned.command = PROBE_LOG
    then logger.scan_command (scanned)
    else if scanned.command = PROBE_DISPLAY
    then display.scan_command (scanned)
    else send_command_to_probe (scanned, probe_available);

  scan_error.display_command_error (scanned);

  if not user_terminal.available
  then ok := FALSE
  else if not probe_available
  then
    begin
      user_terminal.write_message ('***probe circuit lost***\ ');
      ok := FALSE
    end
end (* command *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                           run_supervisor                     	*)
(*                                                              	*)
(*    Run the probe access to a specified supervisor.           	*)
(*    This is for the PROBE command whith no argument if AWAKE is	*)
(*    TRUE and which specifies a supervisor if AWAKE is FALSE.  	*)
(*    Return when command fails or , when trying to awake ,there is	*)
(*    no awake supervisor.                                      	*)
(*                                                              	*)
(************************************************************************)



procedure run_supervisor (
      supervisor: supervisor_indicator;
  var scanned	: scanned_command);

var
  ok: boolean;

begin
  current_supervisor := supervisor;

  command_read.add_context(PROBE_CONTEXT);

  repeat
    if current_supervisor = NO_SUPERVISOR
    then
      begin
	current_supervisor := supervisor_common.awake_supervisor;
	ok := current_supervisor <> NO_SUPERVISOR;
	if ok 
	then command (scanned, ok)
	else user_terminal.write_message('no circuit to awake supervisor\ ')
      end
    else command (scanned, ok)
  until not ok;

  command_read.remove_context(PROBE_CONTEXT)
end (* run_supervisor *) ;




(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                            scan_probe_command                	*)
(*                                                              	*)
(*    Scan PROBE command arguments. With no arguments, access awake	*)
(*    supervisor. Otherwise accept a supervisor number to access.	*)
(*                                                              	*)
(************************************************************************)



procedure entry scan_probe_command(var scanned: scanned_command); 

var
  probe_supervisor: supervisor_index;

begin
  if scanned.freeword_count > 0
  then
    begin
      if not profile.license_check(INACT_LICENSE)
      then scanned.status := AUTH_ERROR;

      if scanned.status = CMD_OK
      then
   	argument_scan.freeword_supervisor_number( 
	  0, scanned, probe_supervisor);

      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
         if supervisor_common.current_state(probe_supervisor) = UNKNOWN
	 then user_terminal.write_message('probe not available\')
	 else run_supervisor(probe_supervisor, scanned)
    end
  else
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then run_supervisor(NO_SUPERVISOR, scanned)
    end
end (* scan_probe_command *) ;
    
	

(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                       scan_set_probe_command                 	*)
(*                                                              	*)
(*    Scan the set  probe command.			      		*)
(*    Format is:   SET PROBE [<supervisor_number>]			*)
(*                                                              	*)
(************************************************************************)



procedure entry scan_set_probe_command(var scanned: scanned_command);

var
  ok: boolean;
  supervisor: supervisor_indicator;
  probe_password: password_string;

begin
  if scanned.freeword_count > 0
  then argument_scan.freeword_supervisor_number(0, scanned, supervisor)
  else supervisor := NO_SUPERVISOR;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      password_scanner.get_new_password(
	'Password: \ ', probe_password, ok);
      if ok
      then
	if supervisor = NO_SUPERVISOR
	then
	  for supervisor := 0 to SUPERVISOR_LIMIT do
	    supervisor_common.set_password(supervisor, probe_password)
	else supervisor_common.set_password(supervisor, probe_password)
    end
end (* scan_set_probe_command *) ;



(*************************  probe_execution  ****************************)
(*                                                              	*)
(*                     scan_clear_probe_command                 	*)
(*                                                              	*)
(*    Scan the clear  probe command.			      		*)
(*    Format is:   CLEAR PROBE [<supervisor_number>]			*)
(*                                                              	*)
(************************************************************************)



procedure entry scan_clear_probe_command(var scanned: scanned_command);

var
  supervisor: supervisor_indicator;

begin
  if scanned.freeword_count > 0
  then argument_scan.freeword_supervisor_number(0, scanned, supervisor)
  else supervisor := NO_SUPERVISOR;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    if supervisor = NO_SUPERVISOR
    then
      for supervisor := 0 to SUPERVISOR_LIMIT do
	multiplexer.clear(supervisor)
    else multiplexer.clear(supervisor)
end (* scan_clear_probe_command *) ;




(*************************  probe_execution  ****************************)
(************************************************************************)



begin (* initial statement *)
  init password_scanner(user_terminal);
  init node_operator, host_operator;
  init access_check (format, profile, user_terminal)
end (* probe_execution *) ;
$endif probe
 $if elf
!
(************************************************************************)
(*									*)
(*	ELF.TMS  Updated 30-Sep-87 at 8:04 by Raffo			*)
(*									*)
(*			    elf_execution				*)
(*									*)
(*	This class handles all ELF communication.			*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	circuit_handler	     			statistics_gatherer	*)
(*	internal_to_string   sleeper		system_error_type	*)
(*	needle_name          needle_name_index  terminal_buffer		*)
(*	terminal_buffer_limit						*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Jun84 Original --- bss					*)
(*	20Jan86 Adapt to new circuit_handler and use a Scanned_command  *)
(*		record instead of a Terminal_buffer record  -- gde	*)
(*	27Mar86 Adapt to circuit_handler modifications for Automatic	*)
(*		Backup facility -- dlp 					*)
(*									*)
(************************************************************************)

(* ELF circuit read status codes	*)

type
  elf_read_status		= (
    ELF_CIRCUIT_ZAPPED,	ELF_COMMAND_COMPLETE, ELF_RESPONSE_COMPLETE );



type
  elf_execution = class (
    aux_circuit_handler		: circuit_handler;
    reload_unit			: aux_circuit_unit_index;
    statistics			: statistics_gatherer
  );


const
  max_seconds_to_read_prompt	=  60;
  max_seconds_for_io		= 600;



(***************************  elf_execution  ****************************)
(*									*)
(*			clear_circuit_and_report			*)
(*									*)
(*	Clear the circuit and report error that caused clearing.	*)
(*									*)
(************************************************************************)


procedure clear_circuit_and_report (error : system_error_type);

begin
  statistics.report_system_error_counter (error);
  aux_circuit_handler.clear_circuit
end (* clear_circuit_and_report *) ;



(***************************  elf_execution  ****************************)
(*									*)
(*			      circuit_built				*)
(*									*)
(*	Build aux circuit to ELF.					*)
(*									*)
(************************************************************************)


function entry circuit_built : boolean;

var
  character		: char;
  read_timer		: integer;
  login_string		: network_login_string;

begin
  login_string.text := 
    'NETELF;                                 ';
  login_string.size := 7;

  (*  build circuit  *)  
  aux_circuit_handler.build_aux_circuit (
    reload_unit,
    [complete],
    login_string);
  
  if not aux_circuit_handler.available
  then
    statistics.report_system_error_counter (elf_build_failed)

  else
    begin
      read_timer := realtime + MAX_SECONDS_TO_READ_PROMPT;

      (*  set the timeout period for reading first prompt *)
      aux_circuit_handler.set_read_timeout (MAX_SECONDS_TO_READ_PROMPT);

      repeat
        aux_circuit_handler.read_one_character (character);
      until (character = ':') or (not aux_circuit_handler.available)
        or (realtime > read_timer);
      
      (*  set the timeout period for all io operations  *)
      aux_circuit_handler.set_read_timeout (MAX_SECONDS_FOR_IO);
      aux_circuit_handler.set_send_timeout (MAX_SECONDS_FOR_IO);
      
      if character <> ':'
      then
	clear_circuit_and_report (cannot_read_elf_prompt)
      else
	(* read in the space that follows the prompt and ignore it *)
	aux_circuit_handler.read_one_character (character)

    end (* if not aux_circuit_handler.available *)  ;

  circuit_built := aux_circuit_handler.available
end (* circuit_built *) ;



(***************************  elf_execution  ****************************)
(*									*)
(*			    read_response_line				*)
(*									*)
(*	Read a line of data from the ELF host one character at a time	*)
(*	until either an ELF command prompt (:) or carriage return	*)
(*	linefeed is received.						*)
(*									*)
(************************************************************************)



procedure entry read_response_line (
  var scanned		: scanned_command;
  var status		: elf_read_status
);

begin
  status := ELF_RESPONSE_COMPLETE;

  with scanned.input_line do
    begin
      aux_circuit_handler.read_one_character (text[0]);
      size := 1;
      if not aux_circuit_handler.available
      then
	status := ELF_CIRCUIT_ZAPPED;
    
      if (status <> ELF_CIRCUIT_ZAPPED) and (text[0] = ':')
      then
	(* line contains only elf command prompt *)
	begin
	  status := ELF_COMMAND_COMPLETE;
    
	  (* read in the space that follows the prompt and ignore it *)
	  aux_circuit_handler.read_one_character (text[1]);
	  if not aux_circuit_handler.available
	  then
	    status := ELF_CIRCUIT_ZAPPED
	end ;
	    
      if status = ELF_RESPONSE_COMPLETE
      then
	begin
	  repeat
	    if size > COMMAND_LINE_TEXT_LIMIT
	    then
	      status := ELF_CIRCUIT_ZAPPED
	    else
	      begin
		aux_circuit_handler.read_one_character (text[size]);
		if not aux_circuit_handler.available
		then
		  status := ELF_CIRCUIT_ZAPPED
		else if text[size] <> '(:00:)'
		then size := size + 1
	      end
	  until (status = ELF_CIRCUIT_ZAPPED) or (text[size-1] = '(:10:)') ;
    
	  if status = ELF_RESPONSE_COMPLETE
	  then size := size - 2
	end (* if status = ELF_RESPONSE_COMPLETE *) 
    end (* with *)
end (* read_response_line *) ;



(***************************  elf_execution  ****************************)
(*									*)
(*			    read_command_line				*)
(*									*)
(*	Read an ELF prompt ending with the given termination		*)
(*	character.							*)
(*									*)
(************************************************************************)


procedure entry read_command_line (
      termination_char		: char;
  var scanned			: scanned_command;
  var status			: elf_read_status
);

begin
  status := ELF_RESPONSE_COMPLETE;
  with scanned.input_line do
    begin
      size   := 0;
    
      repeat
	if size > COMMAND_LINE_TEXT_LIMIT
	then
	  status := ELF_CIRCUIT_ZAPPED
	else
	  begin
	    aux_circuit_handler.read_one_character (text[size]);
	    if not aux_circuit_handler.available
	    then
	      status := ELF_CIRCUIT_ZAPPED
	    else
	      size := size + 1
	  end
      until (status = ELF_CIRCUIT_ZAPPED) or (text[size-1] = termination_char);
    
      if status = ELF_RESPONSE_COMPLETE
      then
	begin
	  aux_circuit_handler.read_one_character (text[size]);
	  size := size - 1 (* strip off termin char + trailing blank *) ;
	  if not aux_circuit_handler.available
	  then
	    status := ELF_CIRCUIT_ZAPPED
	end
    end (* with *)
end (* read_command_line *) ;



(***************************  elf_execution  ****************************)
(*									*)
(*				  logout				*)
(*									*)
(*	Clear circuit to ELF effecting a logout.			*)
(*									*)
(************************************************************************)


procedure entry logout;

begin
  aux_circuit_handler.clear_circuit
end (* logout *) ;




(***************************  elf_execution  ****************************)
(************************************************************************)


begin (* initial statement *)
end (* reload_elf *) ;
$endif
  $if reload
!
(************************************************************************)
(*									*)
(*	RELELF.TMS  Updated 29-Sep-87 at 12:11 by Raffo			*)
(*									*)
(*			      reload_elf				*)
(*									*)
(*	This class handles all of ELF reload protocol.  All node	*)
(*	and slot reloads must be performed through here.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	circuit_handler	    host_buffer		statistics_gatherer	*)
(*	internal_to_string  elf_execution	sleeper			*)
(*	format_buffer	    string_to_internal	terminal_buffer_index	*)
(*	node_index	    slot_index		elf_node_designator	*)
(*	reload_results	    host_index		elf_slot_designator 	*)
(*	port_index	    mxp_index					*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Jun84 Original --- bss					*)
(*	20Jan86 Made following changes:  -- gde				*)
(*		  <> Define elf_load_type				*)
(*		  <> Use Scanned_command record instead of 		*)
(*		     Format_buffer record				*)
(*		  <> Adapt to new command scanner			*)
(*	27Mar86 Adapt to new circuit_handler for Automatic Backup. - dlp*)
(*									*)
(************************************************************************)



type
  reload_elf = class (
    user_terminal		: circuit_handler;
    profile			: user_profile;
    job_status			: job_status_control;
    aux_circuit_handler		: circuit_handler;
    reload_unit			: aux_circuit_unit_index;
    argument_scan		: argument_scanner;
    command_scan		: command_scanner;
    oplog			: operator_log;
    statistics			: statistics_gatherer;
$ifnot clusternodes
    format			: internal_to_string
$endif
$if clusternodes
    format			: internal_to_string;
    cluster_common		: global_cluster_data
$endif
  );


(*  ELF node/slot loading constants used to check that data is being	*)
(*  accurately sent across the line.					*)

const
  load_sent_minimum		= 500 ;

const
  load_receive_factor		=   3 ;

type 
  elf_load_type = (LOAD_NODE, LOAD_SLOT, LOAD_MXP);

var
  elf_exec			: elf_execution;
  oper_messages			: operator_messages;

  (*  the proceed boolean indicates if the current step (reading elf	*)
  (*  prompt, checking the prompt received for the one that was		*)
  (*  anticpated, or if the write line) has been successful.		*)	

  proceed			: boolean ;

  (*  return status from any elf read command.				*)
  
  status			: elf_read_status ;

  (*  the printing boolean indicates if user wants to see all of the	*)
  (*  command interactions between tmcs and elf (ie: sending of		*)
  (*  commands and receiving elf status lines.				*)
  
  printing			: boolean;
  scanned			: scanned_command;
  next_freeword			: command_freeword_index;

(****************************  reload_elf  ******************************)
(*									*)
(*		       	       initialize				*)
(*									*)
(*	Class initialization.						*)
(*									*)
(************************************************************************)


procedure initialize;

begin
  init elf_exec (aux_circuit_handler, reload_unit, statistics);
  init oper_messages (oplog, format)
end (* initialize *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			     string_match				*)
(*									*)
(*     Check if the next freewords form a certain string and 		*)
(*     update next_freeword if found.					*)
(*									*)
(************************************************************************)



function string_match(string: message_string): boolean;

var 
  matches: integer;

begin
  argument_scan.freeword_message_string(
    string, next_freeword, scanned, matches);
  if matches <> 0
  then next_freeword := next_freeword + matches;
  string_match := matches <> 0
end (* string_match *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			     scan_number				*)
(*									*)
(*	Scan for a decimal number and update next_freeword		*)
(*									*)
(************************************************************************)



procedure scan_number(var value: integer);

begin
  argument_scan.freeword_number(next_freeword, 10, scanned, value);
  if scanned.status = CMD_OK
  then next_freeword := next_freeword + 1
end (* scan_number *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			     format_message				*)
(*									*)
(*	Format the standard results message.				*)
(*									*)
(************************************************************************)


procedure format_message (
  node		: node_index;
  mxp		: mxp_index;
  slot		: slot_index
);

begin
  if job_status.ok
  then
    begin
      format.simple_message ('NODE \');
      format.node_number (node);
    
      if mxp <> 0
      then
        begin
          format.string (' MXP \');
          format.number (mxp, 10)
        end;
  
      if (mxp <> 0) or (slot <> 0)
      then
        begin
          format.string (' SLOT \ ');
          format.number (slot, 10)
        end;
    end (* if job_status.ok *)
end (* format_message *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			      report_oplog				*)
(*									*)
(*	Format and send a message to the operator_log.			*)
(*									*)
(************************************************************************)


procedure report_oplog (
  node		: node_index;
  mxp		: mxp_index;
  slot		: slot_index
);

begin
  if job_status.ok
  then
    begin
      format_message (node, mxp, slot);
      format.string (' RELOAD \ ');
      if proceed
      then
        format.string ('SUCCESSFUL\ ')
      else
        begin
          format.string ('FAILED - \');
          format.command_line_string(scanned.input_line)
        end;
  
      oper_messages.save_message (RELEXE_LICENSE)
    end (* job_status.ok *)
end (* report_oplog *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			report_circuit_failure				*)
(*									*)
(*	Report failure to build aux circuit.				*)
(*									*)
(************************************************************************)


procedure report_circuit_failure (
  node		: node_index;
  mxp		: mxp_index;
  slot		: slot_index
);

begin
  if job_status.ok
  then
    begin
      format_message (node, mxp, slot);
      format.string (' RELOAD FAILED - UNABLE TO BUILD CIRCUIT TO ELF\');
      format.command_line_string(scanned.input_line);
      oper_messages.save_message (RELEXE_LICENSE)
    end (* if job_status.ok *)
  
end (* report_circuit_failure *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			   report_dump_failure				*)
(*									*)
(*	Report a failure of the dump command.				*)
(*									*)
(************************************************************************)


procedure report_dump_failure (
  node		: node_index;
  mxp		: mxp_index;
  slot		: slot_index
);

begin  
  (* do not halt the reload if a dump failure occurs *)
  proceed := TRUE;
  
  if job_status.ok
  then
    begin
      format_message (node, mxp, slot);
      format.string (' DUMP FAILED - \  ');
      format.command_line_string(scanned.input_line);
      oper_messages.save_message (RELEXE_LICENSE)
    end (* if job_status.ok *)
end (* report_dump_failure *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			     build_filename				*)
(*									*)
(*	Returns the object file name stored in elf.			*)
(*      Files must be named in the following formats:			*)
(*									*)
(*		xxxxxx.BND	Node bound file				*)
(*		xxxxxx.Nss     	Slot file				*)
(*									*)
(*		where							*)
$if clusternodes
(*		    xxxxxx is ccccmm for MXP processor			*)
$endif
(*		    xxxxxx is zznnnn for single processor		*)
(*									*)
$if clusternodes
(*			mm = MXP machine number file belongs to		*)
(*		      cccc = cluster name				*)
$endif
(*			zz = zz file designator for configuration file	*)
(*		      nnnn = Node number file belongs to		*)
(*                     BND = Designation for node bound file		*)
(*									*)
(*                       N = Designation for Slot file			*)
(*		        ss = Slot number file belongs to		*)
(*									*)
(************************************************************************)


procedure build_filename (
      node		: node_index;
      mxp		: mxp_index;
      slot		: slot_index;
      node_reload	: boolean;
  var elf_filename	: message_string  
);

var
  i		: message_string_index;
$if clusternodes
  name		: cluster_name;
$endif

begin
  format.start;
$if clusternodes

  if cluster_common.node_cluster (node)
  then
    begin
      cluster_common.get_cluster (node, name);
      format.cluster_string (name);
      format.format_number (mxp, 16, -2)
    end
  else
    begin
      format.string (ELF_NODE_DESIGNATOR);
      format.node_number (node)
    end;
$endif clusternodes
$ifnot clusternodes
  format.string (ELF_NODE_DESIGNATOR);
  format.node_number (node);
$endif clusternodes

  format.character ('.');

  if node_reload
  then
    format.string ('BND\')
  else
    begin
      format.character ('N');
      format.format_number (slot, 10, -2);
    end ;

  (* string terminator character *)
  format.character ('\');

  for i := 0 to format.buffer.pointer - 1 do
    elf_filename[i] := format.buffer.text[i]
end (* build_filename *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			      check_status				*)
(*									*)
(*	Check the elf read status and set proceed accordingly.		*)
(*									*)
(************************************************************************)


procedure check_status ;

begin
  proceed := (status <> ELF_CIRCUIT_ZAPPED) and job_status.ok and
    (scanned.status = CMD_OK)
end (* check_status *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			   get_response_line				*)
(*									*)
(*	Get a response line from ELF.					*)
(*									*)
(************************************************************************)


procedure get_response_line ;

begin
  elf_exec.read_response_line (scanned, status);
  command_scan.scan_response_line (scanned);
  next_freeword := 0;
  if printing
  then
    user_terminal.write_command_line_and_end (scanned.input_line);
  check_status
end (* get_response_line *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			   get_command_line				*)
(*									*)
(*	Get a command line from ELF.					*)
(*									*)
(************************************************************************)


procedure get_command_line (termination_character : char) ;

begin
  elf_exec.read_command_line (
    termination_character, scanned, status);
  command_scan.scan_response_line(scanned);
  next_freeword := 0;
  if printing
  then
    user_terminal.write_command_line_and_end (scanned.input_line);
  check_status
end (* get_command_line *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			    send_command_line				*)
(*									*)
(*	Sends ELF command.						*)
(*									*)
(************************************************************************)


procedure send_command_line;

begin
  (* add a carraige return on for line termination *)
  format.character ('(:13:)');
  format.write_block (aux_circuit_handler);
  if printing
  then
    format.write_line (user_terminal);
  proceed := aux_circuit_handler.available and job_status.ok
end (* send_command_line *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			check_blank_response_line			*)
(*									*)
(*	Return if next line read is a blank line.			*)
(*									*)
(************************************************************************)


procedure check_blank_response_line;

begin
  get_response_line;
  if proceed
  then
    begin
      argument_scan.extra_argument_check(scanned);
      proceed := scanned.status = CMD_OK
    end
end (* check_blank_response_line *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			   check_response_line				*)
(*									*)
(*	Return if next line read contains the expected response.	*)
(*									*)
(************************************************************************)


procedure check_response_line (expected_response : message_string);

begin
  get_response_line;
  if proceed
  then
    proceed := string_match (expected_response)
end (* check_response_line *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			   check_command_line				*)
(*									*)
(*	Return if next line read contains the expected response,	*)
(*	and is terminated with the expected termination character.	*)
(*									*)
(************************************************************************)


procedure check_command_line (
  termination_character		: char;
  expected_response 		: message_string );

begin
  get_command_line (termination_character);
  if proceed
  then
    proceed := string_match (expected_response)
end (* check_command_line *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*		  	  check_timed_response				*)
(*									*)
(*	Wait specific time for a response, if found, check if response	*)
(*	was response expected, if not found, return if time waited	*)
(*	exceeds maximum (insures that timeout will occur.)		*)
(*									*)
(************************************************************************)


procedure check_timed_response (
  expected_response 	: message_string;
  read_time_limit	: integer
);

begin
  aux_circuit_handler.set_read_timeout (read_time_limit);
  get_response_line;
  if proceed
  then
    proceed := string_match (expected_response);
  aux_circuit_handler.set_read_timeout (0)
end (* check_timed_response *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			 skip_to_command_prompt				*)
(*									*)
(*	Skip any ELF output until a ':' command prompt is received.	*)
(*									*)
(************************************************************************)


procedure skip_to_command_prompt;

begin
  repeat
    get_response_line
  until not proceed or (status = ELF_COMMAND_COMPLETE)
end (* skip_to_command_prompt *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			check_send_receive_count			*)
(*									*)
(*	Returns if the send and received values are reasonable.		*)
(*									*)
(************************************************************************)


function check_send_receive_count : boolean;

var
  sent		: integer;
  recv		: integer;

begin
  scan_number(sent);

  if scanned.status = CMD_OK
  then
    next_freeword := next_freeword + 1 (* skip over the RECV: *) ;

  if scanned.status = CMD_OK
  then
    scan_number(recv);
  
  (* check that the number sent exceeds the minimum value for checking	*)
  (* and that the number received times the receive factor is greater	*)
  (* than the number sent.						*)

  if scanned.status = CMD_OK
  then
    check_send_receive_count :=
      ((LOAD_RECEIVE_FACTOR * recv) > sent) or (sent < LOAD_SENT_MINIMUM)
  else
    check_send_receive_count := FALSE
end (* check_send_receive_count *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*		    check_node_sending_or_transfer			*)
(*									*)
(*	Returns after TRANSFER COMPLETE or ERROR			*)
(*									*)
(************************************************************************)


procedure check_node_sending_or_transfer;

var
  continue	: boolean;

begin
  continue := TRUE;
  
  repeat
    get_response_line;
    if proceed
    then
      if string_match ('SENDING\')
      then
        continue := TRUE

      else
      if string_match ('SENT:\')
      then
        if check_send_receive_count
	then
	  continue := TRUE
	else
          proceed := FALSE

      else
      if string_match ('BYTES\')
      then
        continue := TRUE

      else
      if string_match ('TRANSFER COMPLETE\')
      then
        continue := FALSE

      else (* unexpected response *)
        proceed := FALSE
  until not (continue and proceed )
end (* check_node_sending_or_transfer *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*		    check_slot_sending_or_transfer			*)
(*									*)
(*	Returns after TRANSFER COMPLETE or ERROR			*)
(*									*)
(************************************************************************)


procedure check_slot_sending_or_transfer;

var
  continue	: boolean;

begin
  continue := TRUE;
  
  repeat
    get_response_line;
    if proceed
    then
      if string_match ('SENDING\')
      then
        continue := TRUE

      else
      if string_match ('TRANSFER COMPLETE\')
      then
        continue := FALSE

      else (* unexpected response *)
        proceed := FALSE
  until not (continue  and proceed)
end (* check_slot_sending_or_transfer *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*		    check_dump_sending_or_transfer			*)
(*									*)
(*	Returns after TRANSFER COMPLETE or ERROR			*)
(*									*)
(************************************************************************)


procedure check_dump_sending_or_transfer;

var
  continue	: boolean;

begin
  continue := TRUE;
  
  repeat
    get_response_line;
    if proceed
    then
      if string_match ('STORING\')
      then
        continue := TRUE

      else
      if string_match ('TRANSFER COMPLETE\')
      then
        continue := FALSE

      else (* unexpected response *)
        proceed := FALSE
  until not (continue and proceed)
end (* check_dump_sending_or_transfer *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*		       check_circuit_built_message			*)
(*									*)
(*	Scan for the CIRCUIT BUILT message from ELF.			*)
(*									*)
(************************************************************************)


procedure check_circuit_built_message;

begin

  (* If the LOAD command immediately follows the DUMP command		*)
  (* ELF may zap the circuit used for dumping and rebuild another	*)
  (* circuit.  If the LOAD does not follow a DUMP command, then only	*)
  (* the circuit built message is scanned for.				*)

  get_response_line;
  if proceed
  then
    if string_match ('ZAPPING\')
    then
      get_response_line;

  if proceed
  then
    proceed :=  string_match ('CIRCUIT\')
end (* check_circuit_built_message *) ;

  

(****************************  reload_elf  ******************************)
(*									*)
(*			   check_load_results				*)
(*									*)
(*	Check the results from load command.				*)
(*									*)
(************************************************************************)


procedure check_load_results (load_type : elf_load_type);

begin
  check_circuit_built_message;

  if proceed
  then check_timed_response ('TRANSFER STARTING\', 60);

  if proceed and (load_type = LOAD_SLOT)
  then
    begin
      check_timed_response ('SENDING\', 120);
      check_timed_response ('MAC\', 120)
    end ;

  if proceed
  then
    case load_type of
      LOAD_NODE,LOAD_MXP:
        check_node_sending_or_transfer;
      LOAD_SLOT:
        check_slot_sending_or_transfer
    end (* case *)
end (* check_load_results *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			   check_dump_results				*)
(*									*)
(*	Scan the results from the preceeding DUMP command.		*)
(*									*)
(************************************************************************)


procedure check_dump_results;

begin
  check_timed_response ('TRANSFER STARTING\', 60);

  if proceed
  then
    check_dump_sending_or_transfer;

  if proceed
  then
    skip_to_command_prompt
end (* check_dump_results *) ;

  

(****************************  reload_elf  ******************************)
(*									*)
(*		      check_started_or_suspended			*)
(*									*)
(*	Check if slot started or suspended.				*)
(*									*)
(************************************************************************)


procedure check_started_or_suspended (var suspended : boolean);

begin
  check_timed_response ('SLOT\ ', 120);

  if proceed
  then
    if string_match ('STARTED\')
    then
      suspended := FALSE
    else if string_match ('SUSPENDED\')
    then
      suspended := TRUE
    else
      proceed := FALSE
end (* check_started_or_suspended *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			  check_file_id_prompt				*)
(*									*)
(*	Check for and reply to FILE ID prompt.				*)
(*									*)
(************************************************************************)


procedure check_file_id_prompt ;

begin
  check_blank_response_line;
  
  if proceed
  then
    check_response_line ('OBJECT FILE:\ ');

  if proceed
  then
    check_response_line ('FILE ID:\ ');

  (* read in rest of line, ignoring it *)
  if proceed
  then
    get_response_line;

  if proceed
  then
    check_blank_response_line;

  if proceed
  then
    begin
      check_command_line ('?', 'OKAY\ ');
      if proceed
      then
        begin
	  format.simple_message ('Y\');
          send_command_line
        end
    end
end (* check_file_id_prompt *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			    send_load_request				*)
(*									*)
(*	Send LOAD <TYPE> command to ELF.				*)
(*									*)
(************************************************************************)


procedure send_load_request (load_type : elf_load_type);

begin
  format.start;
  format.string ('LOAD \  ');
  case load_type of
    LOAD_SLOT:
      format.string ('SLOT\ ');
    LOAD_NODE:
      format.string ('NODE\ ');
    LOAD_MXP:
      format.string ('NODE MXP\ ')
  end (* case *) ;
  send_command_line
end (* send_load_request *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			  send_device_address				*)
(*									*)
(*	Scan the device prompt and send the address.			*)
(*									*)
(************************************************************************)


procedure send_device_address (
  device_type		: char;
  device_unit		: integer
);

begin
  check_command_line (':', 'DEVICE UNIT ID\ ');
  if proceed
  then
    begin
      format.start;
      format.character (device_type);
      format.number (device_unit, 10);
      send_command_line
    end
end (* send_device_address *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			      send_file_id				*)
(*									*)
(*	Scan the FILE ID: prompt and send the id.			*)
(*									*)
(************************************************************************)


procedure send_file_id (
  node			: node_index;
  mxp			: mxp_index;
  slot			: slot_index);
$if clusternodes

var
  name		: cluster_name;
$endif

begin
  check_response_line ('FILE ID:\ ');
  if proceed
  then
    begin
      format.simple_message ('TMCS reload dump of\');

$ifnot clusternodes
      format.string (' node \ ');
      format.node_number (node);
$endif
$if clusternodes
      if mxp = 0
      then
	begin
	  format.string (' node \ ');
	  format.node_number (node)
	end
      else
	begin
	  format.string (' cluster \');
	  cluster_common.get_cluster (node, name);
	  format.cluster_string (name);
	  format.string (' mxp \');
	  format.number (mxp, 16)
	end;
$endif

      if slot > 0
      then
	begin
	  format.string (' slot \ ');
          format.number (slot, 10)
	end;
	
      send_command_line
    end
end (* send_file_id *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			       send_host				*)
(*									*)
(*	Scan the <HOST> prompt and send the kernel/shaman host.		*)
(*									*)
(************************************************************************)


procedure send_host (
  host_prompt		: message_string;
  host 			: host_index  );

begin
  check_command_line (':', host_prompt);
  if proceed
  then
    begin
      format.start;
      format.host_number (host);
      send_command_line
    end
end (* send_host *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			       send_node				*)
(*									*)
(*	Scan the <NODE> prompt and send the node number.		*)
(*									*)
(************************************************************************)


procedure send_node (
  node_prompt		: message_string;
  node 			: node_index  );

begin
  check_command_line (':', node_prompt);
  if proceed
  then
    begin
      format.start;
      format.node_number (node);
      send_command_line
    end
end (* send_node *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			       send_line				*)
(*									*)
(*	Scan the <LINE> prompt and send the line number.		*)
(*									*)
(************************************************************************)


procedure send_line (
  line_prompt		: message_string;
  line 			: port_index  );

begin
  check_command_line (':', line_prompt);
  if proceed
  then
    begin
      format.start;
      format.number (line, 10);
      send_command_line
    end
end (* send_line *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			       send_misc				*)
(*									*)
(*	Scan the <MISCELLANEOUS>: prompt and send the line.		*)
(*									*)
(************************************************************************)


procedure send_misc (
  misc_prompt		: message_string;
  misc_number		: integer  );

begin
  check_command_line (':',  misc_prompt);
  if proceed
  then
    begin
      format.start;
      format.number (misc_number, 10);
      send_command_line
    end
end (* send_misc *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*		     send_starting_ending_address			*)
(*									*)
(*	Send the START and END ADDRESS in dump command.			*)
(*									*)
(************************************************************************)


procedure send_starting_ending_address (
  expected_response	: message_string;
  send_address		: integer  );

begin
  check_command_line (':', expected_response);
  if proceed
  then
    begin
      format.start;
      format.number (send_address, 16);
      send_command_line
    end
end (* send_starting_ending_address *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			send_dump_slot_command				*)
(*									*)
(*	Send the DUMP SLOT command.					*)
(*									*)
(************************************************************************)


procedure send_dump_slot_command (
  node			: node_index;
  slot			: slot_index;
  host			: host_index
);

begin
  format.simple_message ('DUMP SLOT\');
  send_command_line;

  if proceed
  then
    send_device_address (elf_device_for_dumping, elf_unit_for_dumping);

  if proceed
  then
     send_file_id (node, 0, slot);

  if proceed
  then
    send_misc ('SLOT\ ', slot);

  if proceed
  then
    send_host ('HOST\ ', host);

  if proceed
  then
    check_timed_response ('CIRCUIT\', 60);

  if proceed
  then
    check_dump_results;

  if not proceed
  then
    report_dump_failure (node, 0, slot)
end (* send_dump_slot_command *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			send_dump_node_command				*)
(*									*)
(*	Send the DUMP NODE command.					*)
(*									*)
(************************************************************************)


procedure send_dump_node_command (
  node			: node_index;
  neigh_node		: node_index;
  neigh_line		: port_index;
  host			: host_index
);

begin
  format.simple_message ('DUMP NODE\');
  send_command_line;

  if proceed
  then
    send_device_address (elf_device_for_dumping, elf_unit_for_dumping);

  if proceed
  then
    send_file_id (node, 0, 0);

  if proceed
  then
    check_timed_response ('DUMP OF\', 60);

  if proceed
  then
    send_misc ('ENTER START\', -1);

  if proceed
  then
    send_node ('NEIGHBOR NODE\', neigh_node);

  if proceed
  then
    send_host ('KERNEL HOST\', host);

  if proceed
  then
    send_misc ('LINE NUMBER\', neigh_line);

  if proceed
  then
    check_timed_response ('CIRCUIT\', 60);

  if proceed
  then
    send_starting_ending_address ('START\', 0);

  if proceed
  then
    send_starting_ending_address ('END\', 1);

  if proceed
  then
    check_dump_results;

  if not proceed
  then
    report_dump_failure (node, 0, 0)
end (* send_dump_node_command *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			send_dump_mxp_command				*)
(*									*)
(*	Send the DUMP MXP command.					*)
(*									*)
(************************************************************************)


procedure send_dump_mxp_command (
  node			: node_index;
  mxp			: mxp_index;
  shaman_host		: host_index
);

begin
  format.simple_message ('DUMP NODE\');
  send_command_line;

  if proceed
  then
    send_device_address (elf_device_for_dumping, elf_unit_for_dumping);

  if proceed
  then
    send_file_id (node, mxp, 0);

  if proceed
  then
    check_timed_response ('DUMP OF\', 60);

  if proceed
  then
    send_misc ('ENTER START\', -1);

  if proceed
  then
    send_host ('SHAMAN HOST NUMBER\ ', shaman_host);
  
  if proceed
  then
    send_misc ('MXP MACHINE NUMBER\ ', mxp);

  if proceed
  then
    check_timed_response ('CIRCUIT\', 60);

  if proceed
  then
    send_starting_ending_address ('START\', 0);

  if proceed
  then
    send_starting_ending_address ('END\', 1);

  if proceed
  then
    check_dump_results;

  if not proceed
  then
    report_dump_failure (node, mxp, 0)
end (* send_dump_mxp_command *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*		      extract_elf_file_parameters			*)
(*									*)
(*	Returns the device and file addresses.				*)
(*									*)
(************************************************************************)


procedure extract_elf_file_parameters (
  var device_type		: char;
  var device_unit		: integer;
  var file_address		: integer;
  var elf_creation_date		: integer;
  var found			: boolean
);

begin
  argument_scan.freeword_elf_device(
    next_freeword, scanned, device_type, device_unit);

  next_freeword := next_freeword + 1;
  found := (scanned.status = CMD_OK) and (device_type = 'D');

  if found
  then 
    begin
      scan_number(file_address);
      found := scanned.status = CMD_OK
    end;

  (* elf creation date *)
  if found
  then
    begin
      (*  skip over the FILE TYPE field:		*)
      next_freeword := next_freeword + 2;
	
      (* read the date into an integer field *)
      argument_scan.freeword_date(
	next_freeword, profile, scanned, elf_creation_date);
      found := scanned.status = CMD_OK

      (* WARNING: next_freeword is not update *)

    end (* elf creation date *) 
end (* extract_elf_file_parameters *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			  scan_locate_responses				*)
(*									*)
(*	Scans the responses from the ELF LOCATE command.		*)
(*									*)
(************************************************************************)


procedure scan_locate_responses (
  var device_type	: char;
  var device_unit	: integer;
  var file_address	: integer 
);  

var
  elf_creation_date	: integer;
  creation_date		: integer;
  dev_type		: char;
  dev_unit		: integer;
  file_addr		: integer;
  file_found		: boolean;

begin
  elf_creation_date  	:= 0;
  file_address		:= 0;
  
  repeat
    get_response_line;
    if proceed and (status = ELF_RESPONSE_COMPLETE)
    then
      begin
        extract_elf_file_parameters (
	  dev_type, dev_unit, file_addr, creation_date, file_found);
	    
	if file_found and (creation_date > elf_creation_date)
	then
	  begin
	    device_type	   	:= dev_type;
	    device_unit	   	:= dev_unit;
  	    file_address	:= file_addr;
	    elf_creation_date  	:= creation_date
          end (* if file_found *)
      end (* if proceed and status = ELF_RESPONSE_COMPLETE *)
  until not proceed or (status = ELF_COMMAND_COMPLETE) ;

  proceed := file_address <> 0
end (* scan_locate_responses *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			    locate_elf_file				*)
(*									*)
(*	Returns the ELF device and file address for a give name.	*)
(*	Issues the ELF  "LOCATE <name>"  command.			*)
(*									*)
(************************************************************************)


procedure locate_elf_file (
      elf_filename	: message_string;
  var device_type	: char;
  var device_unit	: integer;
  var file_address	: integer
);

begin
  format.simple_message ('LOCATE\ ');
  send_command_line;

  if proceed
  then
    check_command_line (':', 'OBJECT FILE\');

  if proceed
  then
    begin
      format.simple_message (elf_filename);
      send_command_line;
	  
      if proceed
      then
	scan_locate_responses (device_type, device_unit, file_address)
    end (* if proceed *) 
end (* locate_elf_file *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			send_load_node_command				*)
(*									*)
(*	Send the LOAD NODE command to ELF.				*)
(*									*)
(************************************************************************)


procedure send_load_node_command (
      node		: node_index;
      kernel_host	: host_index;
      neigh_node	: node_index;
      neigh_line	: port_index;
      dump_node		: boolean;
      device_type	: char;
      device_unit	: integer;
      file_address	: integer;
      elf_filename	: message_string
);

begin
  if dump_node
  then
    send_dump_node_command (node, neigh_node, neigh_line, kernel_host);
  
  if proceed
  then
    send_load_request (LOAD_NODE);
  
  if proceed
  then
    send_device_address (device_type, device_unit);
  
  if proceed
  then
    send_misc ('FILE ADDRESS\ ', file_address);
  
  if proceed
  then
    check_file_id_prompt;
  
  if proceed
  then
    send_node ('NEIGHBOR NODE\', neigh_node);
  
  if proceed
  then
    send_host ('KERNEL HOST\', kernel_host);
  
  if proceed
  then
    send_line ('LINE NUMBER\', neigh_line);
  
  if proceed
  then
    check_load_results (LOAD_NODE);

  if proceed
  then
    check_timed_response ('NODE STARTED\ ', 120)
end (* send_load_node_command *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*		     send_load_mxp_command				*)
(*									*)
(*	Send the LOAD NODE MXP command to ELF.				*)
(*									*)
(************************************************************************)


procedure send_load_mxp_command (
      node		: node_index;
      mxp		: mxp_index;
      shaman_host	: host_index;
      dump_node		: boolean;
      device_type	: char;
      device_unit	: integer;
      file_address	: integer;
      elf_filename	: message_string
);

begin
  if dump_node
  then
    send_dump_mxp_command (node, mxp, shaman_host);
  
  if proceed
  then
    send_load_request (LOAD_MXP);
  
  if proceed
  then
    send_device_address (device_type, device_unit);
  
  if proceed
  then
    send_misc ('FILE ADDRESS\ ', file_address);
  
  if proceed
  then
    check_file_id_prompt;

  if proceed
  then
    send_host ('SHAMAN HOST NUMBER\ ', shaman_host);
  
  if proceed
  then
    send_misc ('MXP MACHINE NUMBER\ ', mxp);
  
  if proceed
  then
    check_load_results (LOAD_MXP);

  if proceed
  then
    check_timed_response ('NODE STARTED\ ', 120)
end (* send_load_mxp_command *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			send_load_slot_command				*)
(*									*)
(*	Send the LOAD SLOT command to ELF.				*)
(*									*)
(************************************************************************)


procedure send_load_slot_command (
      slot		: slot_index;
      node		: node_index;
      kernel_host	: host_index;
      dump_slot		: boolean;
      device_type	: char;
      device_unit	: integer;
      file_address	: integer;
      elf_filename	: message_string;
  var suspended		: boolean
);

begin
  if dump_slot
  then 
    send_dump_slot_command (node, slot, kernel_host);

  if proceed
  then
    send_load_request (LOAD_SLOT);

  if proceed
  then
    send_device_address (device_type, device_unit);

  if proceed
  then
    send_misc ('FILE ADDRESS\ ', file_address);

  if proceed
  then
    check_file_id_prompt;

  if proceed
  then
    send_misc ('SLOT\ ', slot);

  if proceed
  then
    send_host ('HOST\ ', kernel_host);

  if proceed
  then
    check_load_results (LOAD_SLOT);

  if proceed
  then
    check_started_or_suspended (suspended)
end (* send_load_slot_command *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			    start_node_reload				*)
(*									*)
(*	Begin the ELF node reload process.				*)
(*									*)
(************************************************************************)


procedure entry start_node_reload (
      node		: node_index;
      neigh_node	: node_index;
      neigh_line	: port_index;
      kernel_host	: host_index;
      dump_node		: boolean;
      print_io		: boolean;
  var results		: reload_results
);

var
  elf_filename		: message_string;
  device_type		: char;
  device_unit		: integer;
  file_address		: integer;

begin
  printing := print_io;
  proceed  := elf_exec.circuit_built;

  if not proceed
  then
    report_circuit_failure (node, 0, 0)
  else
    begin
      build_filename (node, 0, 0, TRUE, elf_filename);
      locate_elf_file (
        elf_filename, device_type, device_unit, file_address);
    
      if proceed
      then
        send_load_node_command (
          node, kernel_host, neigh_node, neigh_line, FALSE, 
          device_type, device_unit, file_address, elf_filename);

      elf_exec.logout;
      report_oplog (node, 0, 0)
    end (* if not proceed *) ;

  if proceed
  then
    results := RELOAD_SUCCESSFUL
  else
    results := RELOAD_FAILED_ELF_ERROR
end (* start_node_reload *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			    start_mxp_reload				*)
(*									*)
(*	Begin the ELF mxp reload process.				*)
(*									*)
(************************************************************************)


procedure entry start_mxp_reload (
      node		: node_index;
      mxp		: mxp_index;
      shaman_host	: host_index;
      dump_node		: boolean;
      print_io		: boolean;
  var results		: reload_results
);

var
  elf_filename		: message_string;
  device_type		: char;
  device_unit		: integer;
  file_address		: integer;

begin
  printing := print_io;
  proceed  := elf_exec.circuit_built;

  if not proceed
  then
    report_circuit_failure (node, mxp, 0)
  else
    begin
      build_filename (node, mxp, 0, TRUE, elf_filename);
      locate_elf_file (
        elf_filename, device_type, device_unit, file_address);
    
      if proceed
      then
        send_load_mxp_command (
    	  node, mxp, shaman_host, FALSE,
          device_type, device_unit, file_address, elf_filename);

      elf_exec.logout;
      report_oplog (node, mxp, 0)
    end (* else .. if not proceed *) ;

  if proceed
  then
    results := RELOAD_SUCCESSFUL
  else
    results := RELOAD_FAILED_ELF_ERROR
end (* start_mxp_reload *) ;



(****************************  reload_elf  ******************************)
(*									*)
(*			    start_slot_reload				*)
(*									*)
(*	Begin the ELF slot reload process.				*)
(*									*)
(************************************************************************)


procedure entry start_slot_reload (
      slot		: slot_index;
      node		: node_index;
      mxp		: mxp_index;
      kernel_host	: host_index;
      dump_slot		: boolean;
      print_io		: boolean;
  var results		: reload_results
);

var
  elf_filename		: message_string;
  device_type		: char;
  device_unit		: integer;
  file_address		: integer;
  suspended		: boolean;

begin
  printing     := print_io;
  proceed      := elf_exec.circuit_built;

  if not proceed
  then
    report_circuit_failure (node, mxp, slot)
  else
    begin
      build_filename (node, mxp, slot, FALSE, elf_filename);
      locate_elf_file (
        elf_filename, device_type, device_unit, file_address);

      if proceed
      then
        send_load_slot_command (
          slot, node, kernel_host, dump_slot, device_type,
          device_unit, file_address, elf_filename, suspended);

      elf_exec.logout;
      report_oplog (node, mxp, slot)
    end (* else .. if not proceed *) ;

  if proceed
  then
    if suspended
    then
      results := RELOAD_SUCCESSFUL_SLOT_SUSPENDED
    else
      results := RELOAD_SUCCESSFUL
  else
    results := RELOAD_FAILED_ELF_ERROR
end (* start_slot_reload *) ;



(****************************  reload_elf  ******************************)
(************************************************************************)


begin (* initial statement *)
  initialize
end (* reload_elf *) ;
$endif
   $ifany (reload, xcom)
!
(************************************************************************)
(*									*)
(*	RELEXE.TMS Updated 1-Oct-87 at 16:49 by Raffo			*)
(*									*)
(*			  reload_execution				*)
(*									*)
(*	This class handles all of reload execution control 		*)
(*	sequences.  There is one class per TMCS user and is		*)
(*	executed from the execution process.				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	circuit_handler	    keyword_table     	user_profile		*)
(*	node_buffer	    host_buffer		port_buffer		*)
(*	operator_log	    internal_to_string	set_printer		*)
(*	host_index	    node_index		node_utility		*)
(*	host_utility        slot_buffer		command_line_scanner	*)
(*      reload_control	    sleeper		statistics_gatherer	*)
(*      reload_elf	    reload_netcon	miscellaneous_data	*)
(*      slot_index	    keyword_index       host_set		*)
(*	node_set	    network_state_description			*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Jun84 Original --- bss					*)
(*	20Jan86 Adapt to new Command_scanner and scan all commands 	*)
(*		of the Reload facility inside this class -- gde		*)
(*	24Apr86 Add set/clear xom pending commands, changes as follows: *)
(*		- modified entries scan_clear_xom_command		*)
(*				   scan_set_xom_command			*)
(*		- added routines clear_xom_pending			*)
(*				 clear_xom_host				*)
(*				 scan_set_xom_mxp_slot_command		*)
(*				 scan_set_xom_pending_command		*)
(*		- added routine scan_list_xom_pending			*)
(*		- added scan_list_suspended_slot_command		*)
(*	25Nov86 This class is used by both reload feature and xcom	*)
(*		feature -- ahm						*)
(*									*)
(************************************************************************)




type
  reload_execution = class  (
    aux_circuit_handler		: circuit_handler;
    reload_unit			: aux_circuit_unit_index;
    user_terminal		: circuit_handler;
$if reload
    job_status			: job_status_control;
$endif reload
    user			: user_index;
    multiplexer			: probe_multiplexer;
    supervisor_common		: global_supervisor_data;
    profile			: user_profile;
    node_file			: node_buffer;
    host_file			: host_buffer;
    port_file			: port_buffer;
$if reload
    kernel_file			: kernel_buffer;
    host_slot_file		: host_slot_buffer;
$endif reload
    slot_file			: slot_buffer;
    oplog			: operator_log;
    network_common		: network_state_description;
    format			: internal_to_string;
    argument_scan		: argument_scanner;
    command_scan		: command_scanner;
$if reload
    reload_file		        : reload_control;
$endif reload
    response_buffer		: text_buffer;
    name_common			: global_name_data;
    printer			: set_printer;
    statistics			: statistics_gatherer;
$ifnot clusternodes
    xom_common			: global_xom_data
$endif
$if clusternodes
    xom_common			: global_xom_data;
    cluster_common		: global_cluster_data
$endif
  );

type 
  node_or_host = (RELOAD_HOST,RELOAD_NODE);

var
  host_operator		: host_utility;
  node_operator		: node_utility;
  name_format		: name_printer;
$if reload
  elf_reloader		: reload_elf;
$endif reload


(*************************  reload_execution  ***************************)
(*									*)
(*		       	       initialize				*)
(*									*)
(*	Class initialization.						*)
(*									*)
(************************************************************************)


procedure initialize;

begin
  init host_operator, node_operator;
$if reload
  init elf_reloader (
    user_terminal, profile, job_status, aux_circuit_handler, reload_unit, 
    argument_scan, command_scan,
$ifnot clusternodes
    oplog, statistics, format);
$endif
$if clusternodes
    oplog, statistics, format, cluster_common);
$endif
$endif reload
  init name_format(name_common)
 end (* initialize *) ;


$if reload
(*************************  reload_execution  ***************************)
(*									*)
(*			   print_not_message				*)
(*									*)
(*	Print message informing user that node:host is not active	*)
(*	in the reload facility.						*)
(*									*)
(************************************************************************)


procedure print_not_message (reload_type : node_or_host);

begin
  format.start;

  case reload_type of
    RELOAD_HOST:
      format.string ('host or its node\ ');
    RELOAD_NODE:
      format.string ('node\ ')
  end (* case *) ;

  format.string (' is not active in the reload facility\');
  format.write_line (user_terminal)
end (* print_not_message *) ;


(*************************  reload_execution  ***************************)
(*									*)
(*			   print_access_message				*)
(*									*)
(*	Print message informing user that node:host can not be accessed	*)
(*	by the suser.							*)
(*									*)
(************************************************************************)

procedure print_access_message (reload_type : node_or_host);

begin
  format.start;
  format.string('Access not allowed to \ ');

  case reload_type of
    RELOAD_HOST:
      format.string ('host or its node\ ');
    RELOAD_NODE:
      format.string ('node\ ')
  end (* case *) ;

  format.write_line (user_terminal)
end (* print_access_message *) ;


(*************************  reload_execution  ***************************)
(*									*)
(*			  print_dload_message				*)
(*									*)
(*	Send a message informing user of DLOAD issuance.		*)
(*									*)
(************************************************************************)


procedure print_dload_message (node: node_index);

begin
  if not job_status.detached
  then
    begin
      format.simple_message ('    probe dload issued for node \ ');
      format.node_number (node);
      format.write_line (user_terminal)
    end
end (* print_dload_message *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			     format_message				*)
(*									*)
(*	Format the standard results message.				*)
(*									*)
(************************************************************************)


procedure format_message (
  mxp		: mxp_index;
  node		: node_index;
  kernel	: host_index;
  slot		: slot_index;
  host		: host_index
 );

begin
  if not job_status.detached
  then
    begin
      format.start;
      format.newline;
      format.skip_to (6);
      format.string ('node \');
      format.node_number (node);

      if mxp > 0
      then
        begin
	  format.string (' mxp \  ');
	  format.number (mxp, 16)
	end;

      if kernel > 0
      then
	begin
	  format.string (' kernel/shaman \');
	  format.host_number (kernel)
	end;
      
      if slot <> 0
      then
        begin
	  format.string (' slot \ ');
	  format.number (slot, 10)
	end (* slot *) ;

      if host <> 0
      then
        begin
	  format.string (' host \ ');
	  format.host_number (host)
	end (* host *) 
    end (* if not detached *)
end (* format_message *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			      print_results				*)
(*									*)
(*	Print results of reload.					*)
(*									*)
(************************************************************************)


procedure print_results (
  mxp		: mxp_index;
  node		: node_index;
  kernel	: host_index;
  slot		: slot_index;
  host		: host_index;
  results 	: reload_results );

begin
  if not job_status.detached
  then
    begin
      format_message (mxp, node, kernel, slot, host);
      format.skip (1);
      format.build_reload_message (results);

      if format.buffer.pointer > 80
      then
        begin
	  format_message (mxp, node, kernel, slot, host);
          format.newline;
          format.skip_to (6);
          format.build_reload_message (results);
	end ;

      format.newline;
      format.write_line (user_terminal)
    end (* if not detached *)
end (* print_results *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			      print_header				*)
(*									*)
(*	Print header for phases of automatic reload process.		*)
(*									*)
(************************************************************************)


procedure print_header (text : message_string);

begin
  if not job_status.detached
  then
    begin
      format.start;
      format.string ('... processing \');
      format.string (text);
      format.skip_to (32);
      format.mini_time ( profile.time(realtime) );
      format.write_line (user_terminal)
    end
end (* print_header *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			    start_xom_restore				*)
(*									*)
(*	Begin the xom configuration parameter restoration.		*)
(*									*)
(************************************************************************)


procedure start_xom_restore (
      node		: node_index;
      mxp		: mxp_index;
      first_slot	: slot_index;
      last_slot		: slot_index
);

var
  slot		: slot_index;
  
begin
  for slot := first_slot to last_slot do
    xom_common.set_xom_restore (node, mxp, slot)
end (* start_xom_restore *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			    start_slot_reload				*)
(*									*)
(*	Begin slot reload steps.					*)
(*									*)
(************************************************************************)


procedure start_slot_reload (
      node		: node_index;
      mxp		: mxp_index;
      slot		: slot_index;
      perform_dump	: boolean;
      print		: boolean
);

var
  ddt_host	: host_index;
  kernel_mxp	: mxp_index;
  kernel_pid	: product_index;
  ok		: boolean;
  results	: reload_results;


begin
  if mxp = 0
  then kernel_file.get_kernel_host (node, kernel_mxp, ddt_host, kernel_pid, ok)
  else kernel_file.get_shaman_host (node, mxp, ddt_host, ok);

  if not ok
  then
    print_results (mxp, node, 0, slot, 0, RELOAD_FAILED_UNKNOWN_KERNEL)
  else
    begin
      elf_reloader.start_slot_reload (
	slot, node, mxp, ddt_host, perform_dump, print, results);

      print_results (mxp, node, ddt_host, slot, 0, results);

      if results = RELOAD_SUCCESSFUL_SLOT_SUSPENDED
      then
	slot_file.set_slot_suspended (node, mxp, slot);

      if (results = RELOAD_SUCCESSFUL) or
	 (results = RELOAD_SUCCESSFUL_SLOT_SUSPENDED)
      then
	(* check all HOSTS on the slot for xom hosts *)
	start_xom_restore (node, mxp, slot, slot)
    end
end (* start_slot_reload *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			    start_mxp_reload				*)
(*									*)
(*	Begin mxp reload steps.						*)
(*									*)
(************************************************************************)


procedure start_mxp_reload (
      node		: node_index;
      mxp		: mxp_index;
      perform_dump	: boolean;
      print		: boolean
);

var
  shaman_found	: boolean;
  shaman_mxp	: mxp_index;
  shaman_host	: host_index;
  ok		: boolean;
  results	: reload_results;

begin
  shaman_found	:= FALSE;
  shaman_mxp	:= 1;
  ok		:= FALSE;

  while (shaman_mxp < MXP_MAX) and not ok do
    begin
      if shaman_mxp <> mxp
      then
        begin
          kernel_file.get_shaman_host (node, shaman_mxp, shaman_host, ok);
          if ok
	  then
  	    begin
	      shaman_found := TRUE;
              elf_reloader.start_mxp_reload (
	        node, mxp, shaman_host, perform_dump, print, results);
              if results = RELOAD_SUCCESSFUL
	      then start_xom_restore (node, mxp, 0, SLOT_LIMIT)
	      else ok := FALSE;
	      print_results (mxp, node, 0, 0, 0, results);
  	    end  (* if ok *)
        end (* else ... if shaman_host = mxp *) ;

      shaman_mxp := shaman_mxp + 1  (* try next mxp *)
    end (* while *) ;

  (* print results *)
  if not shaman_found
  then print_results (mxp, node, 0, 0, 0, RELOAD_FAILED_UNKNOWN_KERNEL)
end (* start_mxp_reload *) ;




(*************************  reload_execution  ***************************)
(*									*)
(*			    start_node_reload				*)
(*									*)
(*	Begin node reload steps.					*)
(*									*)
(************************************************************************)


procedure start_node_reload (
      node		: node_index;
      perform_dump	: boolean;
      print		: boolean
);

var
  neighbors	: neighbor_list;
  i		: neighbor_list_index;
  neigh_found	: boolean;
  kernel_host	: host_index;
  kernel_mxp	: mxp_index;
  kernel_pid	: product_index;
  ok		: boolean;
  results 	: reload_results;

begin
  port_file.get_neighbor_information (node, neighbors);
  neigh_found := FALSE;
  ok := FALSE;

  i := 0;
  while (i < neighbors.size) and not ok do
    begin
      kernel_file.get_kernel_host (
	neighbors.node[i], kernel_mxp, kernel_host, kernel_pid, ok);
      if ok
      then
	begin
	  neigh_found := TRUE;
	  elf_reloader.start_node_reload (
	    node, neighbors.node[i], neighbors.line[i],
	    kernel_host, perform_dump, print, results);
	  if results = RELOAD_SUCCESSFUL
	  then start_xom_restore (node, 0, 0, SLOT_LIMIT)
	  else ok := FALSE;
	  print_results (0, node, 0, 0, 0, results);
	end;
      i:= i+1
    end (* while *) ;

  if not neigh_found
  then print_results (0, node, 0, 0, 0, RELOAD_FAILED_UNKNOWN_NEIGHBOR);
end (* start_node_reload *) ;




(*************************  reload_execution  ***************************)
(*									*)
(*		        scan_reload_host_command			*)
(*									*)
(*	Scan the reload host command.  					*)
(*  	Scan command in form:  						*)
(*	  RELOAD HOST <host> NODE <node> [DUMP]	[PRINT]  		*)
(*									*)
(************************************************************************)


procedure scan_reload_host_command(var scanned: scanned_command);


var
  host		: host_index;
  node		: node_index;
  mxp		: mxp_index;
  pid		: product_index;
  print		: boolean;
  ok		: boolean;
  perform_dump	: boolean;
  slot		: slot_index;

begin
  job_status.setup (FALSE);
  perform_dump := FALSE;
  print        := FALSE;

  argument_scan.keyword_host(MAIN_RELOAD_HOST_KEYWORD, scanned, host);

  if scanned.status = CMD_OK
  then
    if not argument_scan.check_keyword(MAIN_RELOAD_NODE_KEYWORD, scanned)
    then scanned.status := ARG_MISSING;

  if scanned.status = CMD_OK
  then argument_scan.keyword_node(MAIN_RELOAD_NODE_KEYWORD, scanned, node);

  if scanned.status = CMD_OK
  then
    if argument_scan.check_keyword(MAIN_RELOAD_DUMP_KEYWORD, scanned)
    then perform_dump := TRUE;

  if scanned.status = CMD_OK
  then
    if argument_scan.check_keyword(MAIN_RELOAD_PRINT_KEYWORD, scanned)
    then print := TRUE;

  argument_scan.extra_argument_check(scanned);
  ok := scanned.status = CMD_OK;

  if ok
  then
    begin
      ok := profile.host_node_list_check(host, node);
      if not ok 
      then print_access_message(RELOAD_HOST)
    end;

  (* check that host is active in reload facility *)
  if ok
  then
    begin
      ok := reload_file.check_reload_host_node (host, node);
      if not ok
      then
        print_not_message (RELOAD_HOST)
    end;

  if ok
  then
    host_slot_file.get_host_information (host, node, slot, mxp, pid, ok);

  if ok 
  then
    if (slot > 0) or ((mxp > 0) and (pid <> SHAMAN_PID))
    then
      start_slot_reload (node, mxp, slot, perform_dump, print)
    else (* can't find slot for this host *)
      print_results (mxp, node, 0, 0, host, RELOAD_FAILED_UNKNOWN_SLOT)
end (* scan_reload_host_command *) ;




(*************************  reload_execution  ***************************)
(*									*)
(*		        scan_reload_node_command			*)
(*									*)
(*	Scan the reload node command.  					*)
(*	Format is:							*)
(*	  RELOAD NODE <node> [MXP <mxp>] [DUMP]	[PRINT]			*)
(*									*)
(************************************************************************)


procedure scan_reload_node_command(var scanned: scanned_command);

var
  node			: node_index;
  mxp			: mxp_index;
  ok			: boolean;
  print			: boolean;
  perform_dump		: boolean;

begin
  job_status.setup (FALSE);
  perform_dump := FALSE;
  print        := FALSE;
  mxp	       := 0;

  argument_scan.keyword_node(MAIN_RELOAD_NODE_KEYWORD, scanned, node);

  if scanned.status = CMD_OK
  then
    if argument_scan.check_keyword(MAIN_RELOAD_MXP_KEYWORD, scanned)
    then argument_scan.keyword_mxp(MAIN_RELOAD_MXP_KEYWORD, scanned, mxp);

  if scanned.status = CMD_OK
  then
    if argument_scan.check_keyword(MAIN_RELOAD_PRINT_KEYWORD, scanned)
    then print := TRUE;

  if scanned.status = CMD_OK
  then
    if argument_scan.check_keyword(MAIN_RELOAD_DUMP_KEYWORD, scanned)
    then perform_dump := TRUE;

  argument_scan.extra_argument_check(scanned);
  ok := scanned.status = CMD_OK;

(*  check that node can be access for user's profile and limits *)

  if ok
  then 
    begin
      ok := profile.node_list_check(node);
      if not ok
      then print_access_message(RELOAD_NODE)
    end;

  (* check that node is active in the reload facility *)
  if ok
  then
    begin
      ok := reload_file.check_reload_node (node);
      if not ok
      then
        print_not_message (RELOAD_NODE)
    end;
  
  if ok
  then
    if mxp = 0
    then
      start_node_reload (node, perform_dump, print)
    else
      start_mxp_reload (node, mxp, perform_dump, print)
end (* scan_reload_node_command *) ;
$endif reload



(************************  reload_execution  ****************************)
(*									*)
(*		     scan_set_xom_mxp_slot_command			*)
(*									*)
(*	Scan the set xom command.					*)
(*      Format is:   SET XOM <host> <node> MXP <mxp> SLOT <slot>	*)
(*									*)
(************************************************************************)



procedure scan_set_xom_mxp_slot_command(
  var scanned	: scanned_command;
      host	: host_index;
      node	: node_index);

var
  mxp : mxp_index;
  slot: slot_index;
  ok  : boolean;

begin
  if argument_scan.check_keyword(MAIN_SET_MXP_KEYWORD, scanned)
  then argument_scan.keyword_mxp(MAIN_SET_MXP_KEYWORD, scanned, mxp)
  else mxp := 0;

  if scanned.status = CMD_OK
  then
    if argument_scan.check_keyword(MAIN_SET_SLOT_KEYWORD, scanned)
    then argument_scan.keyword_slot(MAIN_SET_SLOT_KEYWORD, scanned, slot)
    else scanned.status := ARG_MISSING;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      xom_common.set_entry(host, node, mxp, slot, ok);
      if not ok
      then
    	begin
	  user_terminal.write_message('No room for xom host entry\ ');
	  scanned.status := RUN_ERROR
	end
    end
end (* scan_set_xom_mxp_slot_command *) ;


$if reload
(************************  reload_execution  ****************************)
(*									*)
(*		     scan_set_xom_pending_command			*)
(*									*)
(*	Scan the set xom command.					*)
(*      Format is:   SET XOM <host> PENDING				*)
(*									*)
(************************************************************************)



procedure scan_set_xom_pending_command(
  var scanned	: scanned_command;
      host	: host_index);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then xom_common.force_xom_restore(host)
end (* scan_set_xom_pending_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		  scan_activate_deactivate_host_command			*)
(*									*)
(*	Scan the activate/deactivate host command.  			*)
(*									*)
(************************************************************************)


procedure scan_activate_deactivate_host_command (
    var scanned: scanned_command);

var
  hosts_scanned	: host_set;

begin
  argument_scan.freeword_host_set(0, scanned, hosts_scanned);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case scanned.command of

      MAIN_ACTIVATE:
	reload_file.activate_hosts(hosts_scanned);

      MAIN_DEACTIVATE:
	reload_file.deactivate_hosts(hosts_scanned)

    end (* case *)
end (* scan_activate_deactivate_host_command *) ;




(*************************  reload_execution  ***************************)
(*									*)
(*		  scan_activate_deactivate_node_command			*)
(*									*)
(*	Scan the activate/deactivate node command.  			*)
(*									*)
(************************************************************************)


procedure scan_activate_deactivate_node_command (
    var scanned: scanned_command);

var
  nodes_scanned	: node_set;

begin
  argument_scan.freeword_node_set(0, scanned, nodes_scanned);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case scanned.command of

      MAIN_ACTIVATE:
  	reload_file.activate_nodes(nodes_scanned);

      MAIN_DEACTIVATE:
	reload_file.deactivate_nodes(nodes_scanned)

    end (* case *)
end (* scan_activate_deactivate_node_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		    scan_activate_deactivate_command			*)
(*									*)
(*	Scan the activate and deactivate commands.  Format are:		*)
(*	  ACTIVATE HOST <host range>					*)
(*	  ACTIVATE NODE <node range>					*)
(*	  DEACTIVATE HOST <host range>					*)
(*	  DEACTIVATE NODE <node range>					*)
(*									*)
(************************************************************************)


procedure entry scan_activate_deactivate_command (
    var scanned: scanned_command);


begin
  case scanned.subcommand of
    MAIN_ACTIVATE_HOST_KEYWORD:
      scan_activate_deactivate_host_command(scanned);
    MAIN_ACTIVATE_NODE_KEYWORD:
      scan_activate_deactivate_node_command(scanned)
  end (* case *) 
end (* scan_activate_deactivate_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			  scan_reload_command				*)
(*									*)
(*	Scan the reload command.  Format is:				*)
(*	  RELOAD HOST <host> NODE <node>				*)
(*	  RELOAD NODE <node>						*)
(*									*)
(************************************************************************)


procedure entry scan_reload_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_RELOAD_HOST_KEYWORD, scanned)
  then scan_reload_host_command(scanned)
  else if argument_scan.check_keyword(MAIN_RELOAD_NODE_KEYWORD, scanned)
  then scan_reload_node_command(scanned)
  else scanned.status := ARG_MISSING
end (* scan_reload_command *) ;
$endif reload


(************************  reload_execution  ****************************)
(*									*)
(*			   scan_set_xom_command				*)
(*									*)
(*	Scan the set xom command. Format are: 				*)
(*        SET XOM <host> <node> MXP <mxp> SLOT <slot>			*)
(*	  SET XOM <host> PENDING					*)
(*									*)
(************************************************************************)



procedure entry scan_set_xom_command(var scanned: scanned_command);

var
  host: host_index;
  node: node_index;

begin
  argument_scan.freeword_host(0, scanned, host);

  if scanned.status = CMD_OK
  then 
$if reload
    if argument_scan.check_keyword(MAIN_SET_PENDING_KEYWORD, scanned)
    then scan_set_xom_pending_command(scanned, host)
    else 
$endif reload
      begin
	argument_scan.freeword_node(1, scanned, node);

	if scanned.status = CMD_OK
    	then scan_set_xom_mxp_slot_command(scanned, host, node)
      end
end (* scan_set_xom_command *) ;



$if reload
(************************  reload_execution  ****************************)
(*									*)
(*		      scan_set_reload_threshold				*)
(*									*)
(*	Scan the set reload threshold command.				*)
(*      Format is:    SET RELOAD {NODE|HOST} THRESHOLD <threshold>      *)
(*									*)
(************************************************************************)


procedure entry scan_set_reload_threshold(
    var scanned: scanned_command;
	threshold: external_recurring_outage_index); 

var
  keyword: command_keyword_index;

begin
  if not profile.license_check(RELSET_LICENSE)
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then argument_scan.find_keyword(MAIN_SET_NODE_KEYWORD,
    MAIN_SET_HOST_KEYWORD, scanned, keyword);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case keyword of
      
      MAIN_SET_NODE_KEYWORD:
	reload_file.set_node_reload_threshold(threshold);

      MAIN_SET_HOST_KEYWORD:
	reload_file.set_host_reload_threshold(threshold)

      end (* case *)
end (* scan_set_reload_threshold *) ;



(************************  reload_execution  ****************************)
(*									*)
(*		      scan_set_reload_recurring				*)
(*									*)
(*	Scan the set reload recurring command.				*)
(*      Format is: SET RELOAD {NODE|HOST} RECURRINGOUTAGE <max><decay>  *)
(*									*)
(************************************************************************)



procedure entry scan_set_reload_recurring(
    var scanned  : scanned_command;
    var maximum  : external_recurring_outage_index;
    var decay    : integer);

var
  keyword: command_keyword_index;

begin
  if not profile.license_check(RELSET_LICENSE)
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then
    argument_scan.find_keyword(
      MAIN_SET_NODE_KEYWORD,
      MAIN_SET_HOST_KEYWORD,
      scanned,
      keyword);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case keyword of
      
      MAIN_SET_NODE_KEYWORD:
  	reload_file.set_node_reload_recurring_outage_variables(
		  maximum, decay);
	
      MAIN_SET_HOST_KEYWORD:
	reload_file.set_host_reload_recurring_outage_variables(
	  maximum, decay)

      end (* case *)
end (* scan_set_reload_recurring *) ;
$endif reload


(************************  reload_execution  ****************************)
(*									*)
(*		            clear_xom_host				*)
(*									*)
(*	Scan the clear xom  command.					*)
(*      Format is: CLEAR XOM <host>					*) 
(*									*)
(************************************************************************)



procedure clear_xom_host(
  var scanned	: scanned_command;
      host	: host_index);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then xom_common.clear_entry(host)
end (* clear_xom_host *) ;


$if reload
(************************  reload_execution  ****************************)
(*									*)
(*		      	  clear_xom_pending				*)
(*									*)
(*	Scan the clear xom pending command.				*)
(*      Format is: CLEAR XOM <host> PENDING				*) 
(*									*)
(************************************************************************)



procedure clear_xom_pending(
  var scanned	: scanned_command;
      host	: host_index);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then xom_common.reset_xom_restore(host)
end (* clear_xom_pending *) ;
$endif reload



(************************  reload_execution  ****************************)
(*									*)
(*		        scan_clear_xom_command				*)
(*									*)
(*	Scan the clear xom  command. Format are:			*)
(*        CLEAR XOM <host>						*) 
(*	  CLEAR XOM <host> PENDING					*)
(*									*)
(************************************************************************)



procedure entry scan_clear_xom_command(var scanned: scanned_command);

var 
  host: host_index;

begin
  argument_scan.freeword_host(0, scanned, host);

  if scanned.status = CMD_OK
  then
$if reload
    if argument_scan.check_keyword(MAIN_CLEAR_PENDING_KEYWORD, scanned)
    then 
      clear_xom_pending(scanned, host)
    else 
$endif reload
      clear_xom_host(scanned, host)
end (* scan_clear_xom_command *) ;


$if reload
(************************  reload_execution  ****************************)
(*									*)
(*		      scan_clear_reload_threshold			*)
(*									*)
(*	Scan the clear reload threshold command.			*)
(*      Format is: CLEAR RELOAD {NODE|HOST} THRESHOLD			*)
(*									*)
(************************************************************************)



procedure entry scan_clear_reload_threshold(var scanned: scanned_command);

var
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_CLEAR_NODE_KEYWORD, 
    MAIN_CLEAR_HOST_KEYWORD, scanned, keyword);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case keyword of

      MAIN_CLEAR_NODE_KEYWORD:
	reload_file.set_node_reload_threshold(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT);

      MAIN_CLEAR_HOST_KEYWORD:
	reload_file.set_host_reload_threshold(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT)

    end (* case *)
end (* scan_clear_reload_threshold *) ;



(************************  reload_execution  ****************************)
(*									*)
(*		      scan_clear_reload_recurring			*)
(*									*)
(*	Scan the clear reload recurring command.			*)
(*      Format is: CLEAR RELOAD {NODE|HOST} RECURRINGOUTAGE	        *)
(*									*)
(************************************************************************)



procedure entry scan_clear_reload_recurring(var scanned: scanned_command);

var
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_CLEAR_NODE_KEYWORD,
    MAIN_CLEAR_HOST_KEYWORD, scanned, keyword);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case keyword of
      
      MAIN_CLEAR_NODE_KEYWORD:
	reload_file.set_node_reload_recurring_outage_variables(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT,
	  DEFAULT_RECURRING_DECAY);

      MAIN_CLEAR_HOST_KEYWORD:
	reload_file.set_host_reload_recurring_outage_variables(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT,
	  DEFAULT_RECURRING_DECAY)

    end (* case *)
end (* scan_clear_reload_recurring *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		    scan_list_suspended_slot_command			*)
(*									*)
(*      Scan the list suspended slot command. Format is:		*)
(*         LIST SUSPENDED SLOT						*)
(*									*)
(************************************************************************)



procedure entry scan_list_suspended_slot_command(var scanned: scanned_command);

begin
  if not argument_scan.check_keyword(MAIN_LIST_SLOT_KEYWORD, scanned)
  then scanned.status := CMD_ERROR;

  if scanned.status = CMD_OK
  then argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    if not profile.license_check(RELLST_LICENSE)
    then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then
    begin
      response_buffer.start_put;
      slot_file.dump_suspended_slots(profile, response_buffer, format);
      response_buffer.print(user_terminal)
    end
end (* scan_list_suspended_slot_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			  scan_list_xom_pending				*)
(*									*)
(*      Scan the list xom command. Format is:				*)
(*         LIST XOM PENDING						*)
(*									*)
(************************************************************************)



procedure entry scan_list_xom_pending(var scanned: scanned_command);

var
  hosts : host_set;

begin
  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
      xom_common.get_xom_hosts(hosts);
      format.start;
      printer.print_host_set(hosts);
      format.write_line(user_terminal)
    end
end (* scan_list_xom_pending *) ;
$endif reload


(*************************  reload_execution  ***************************)
(*									*)
(*			     scan_list_xom				*)
(*									*)
(*      Scan the list xom command. Format is:				*)
(*         LIST XOM [<host_index>]					*)
(*									*)
(************************************************************************)



procedure entry scan_list_xom(var scanned: scanned_command);

var
  host: host_index;

begin
$if reload
  if not profile.license_check(RELLST_LICENSE)
  then scanned.status := AUTH_ERROR;
$endif reload

  response_buffer.start_put;

  if scanned.status = CMD_OK
  then
    if scanned.freeword_count > 0
    then 
      begin
	argument_scan.freeword_host(0, scanned, host);
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then xom_common.list_entry(host, response_buffer, format, profile)
      end 
    else
      begin
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then xom_common.list_all_entries(response_buffer, format, profile)
      end;
  
  if scanned.status = CMD_OK
  then response_buffer.print(user_terminal)
end (* scan_list_xom *) ;


$if reload
(*************************  reload_execution  ***************************)
(*									*)
(*			scan_list_reload_threshold			*)
(*									*)
(*      Scan the list reload threshold command.				*)
(*      Format is:  LIST RELOAD THRESHOLD				*)
(*									*)
(************************************************************************)


procedure entry scan_list_reload_threshold(var scanned: scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then 
    begin
      format.simple_message('host reload threshold: \');
      format.number(reload_file.get_host_reload_threshold, 10);
      format.newline;
      format.string('node reload threshold: \');
      format.number(reload_file.get_node_reload_threshold, 10);
      format.write_line(user_terminal)
    end 
end (* scan_list_reload_threshold *) ;

    

(*************************  reload_execution  ***************************)
(*									*)
(*			scan_list_reload_recurring			*)
(*									*)
(*      Scan the list reload recurring command.				*)
(*      Format is: LIST RELOAD RECURRINGOUTAGE				*)
(*									*)
(************************************************************************)



procedure entry scan_list_reload_recurring(var scanned: scanned_command);

var 
  reload_variables: external_recurring_outage_variables;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      format.simple_message('reload recurring system variables:\ ');
      reload_file.get_host_reload_recurring_outage_variables(reload_variables);
      format.newline;
      format.skip(5);
      format.string('host\ ');
      format.skip(5);
      format.string('maximum: \');
      format.number(reload_variables.recurring_outage_maximum, 10);
      format.skip(5);
      format.string('decay: \');
      format.number(reload_variables.recurring_outage_decay, 10);
      reload_file.get_node_reload_recurring_outage_variables(reload_variables);
      format.newline;
      format.skip(5);
      format.string('node\ ');
      format.skip(5);
      format.string('maximum: \');
      format.number(reload_variables.recurring_outage_maximum, 10);
      format.skip(5);
      format.string('decay: \');
      format.number(reload_variables.recurring_outage_decay, 10);
      format.write_line(user_terminal)
    end 
end (* scan_list_reload_recurring *) ;
 


(*************************  reload_execution  ***************************)
(*									*)
(*		   run_list_configuration_host_command			*)
(*									*)
(*	Run the LIST CONFIGURATION HOST <host> command.			*)
(*									*)
(************************************************************************)


procedure run_list_configuration_host_command (host : host_index);

var
  pid		: product_index;
  node		: node_index;
  mxp		: mxp_index;
  kernel_host	: host_index;
  kernel_mxp	: mxp_index;
  kernel_slot	: slot_index;
  slot		: slot_index;
  ok		: boolean;
  found		: boolean;
  printed	: boolean;

begin
  printed := FALSE;
  node := 0; mxp := 0; slot := 0;

  repeat
    host_slot_file.get_next_host_slot (host, node, mxp, slot, pid, ok);

    if ok
    then
      if profile.host_node_list_check (host, node)
      then
	begin
	  printed       := TRUE;
  
	  format.start;
	  format.string ('host: \ ');
	  name_format.host_name (host, format);

	  format.skip (5);
	  format.string ('product id: \ ');
	  name_format.product_name (pid, format);
    
	  format.newline;

	  format.string('node: \ ');
	  name_format.node_name (node, format);
	  format.skip (5);
	  format.string ('slot: \ ');
	  format.number (slot, 10);

	  if mxp = 0
	  then
	    kernel_file.get_kernel_host (
	      node, kernel_mxp, kernel_host, pid, found)
	  else
	    kernel_file.get_shaman_host (node, mxp, kernel_host, found);

	  if found
	  then
	    begin
	      format.skip (5);
	      if mxp = 0
	      then
		format.string ('kernel host: \')
	      else
		begin
		  format.string ('mxp: \');
		  format.number (mxp, 16);
		  format.skip (5);
		  format.string ('shaman host: \')
		end;
	      name_format.host_name (kernel_host, format)
	    end ;
	   format.write_line (user_terminal)
	end  (* if found *)
  until not ok;

  if not printed
  then
    user_terminal.write_message (
      'no host information found in reload facility with that number\')
end (* run_list_configuration_host_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		       scan_list_configuration_host			*)
(*									*)
(*      Scan the list configuration host command.			*)
(*      Format is: LIST CONFIGURATION HOST <host>			*)
(*									*)
(************************************************************************)



procedure scan_list_configuration_host(var scanned: scanned_command);

var
  host: host_index;

begin
  argument_scan.freeword_host(0, scanned, host);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    if profile.host_access_check(host)
    then run_list_configuration_host_command(host)
    else scanned.status := HOST_ACCESS_ERROR
end (* scan_list_configuration_host *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		   run_list_configuration_node_command			*)
(*									*)
(*	Run the LIST CONFIGURATION NODE <node> command.			*)
(*									*)
(************************************************************************)


procedure run_list_configuration_node_command (node : node_index);

var
  mxp		: mxp_index;
  kernel_host	: host_index;
  pid		: product_index;
  neighbors	: neighbor_list;
  i		: neighbor_list_index;
  found		: boolean;

begin
  (* get all pertinent information *)
  kernel_file.get_kernel_host (node, mxp, kernel_host, pid, found);

  if found
  then
    begin
      port_file.get_neighbor_information (node, neighbors);

      format.start;
      format.string ('node: \ ');
      name_format.node_name (node, format);
      format.skip (12);
      format.string ('kernel host: \');
      name_format.host_name (kernel_host, format);

      if mxp > 0
      then
	begin
	  format.string (' on MP: \ ');
	  format.number (mxp, 10)
	end;
      format.string (' product id: \');
      name_format.product_name (pid, format);

      format.write_line (user_terminal);

      for i := 0 to neighbors.size-1 do
	begin
	  format.start;
	  format.skip(2);
	  format.string ('neighbor node and line:  \');
	  name_format.node_name (neighbors.node[i], format);
	  format.character (':');
	  format.number (neighbors.line[i], 10);
	  format.write_line (user_terminal)
	end (* for *) ;

      for mxp := 1 to MXP_LIMIT do
	begin
	  kernel_file.get_shaman_host (node, mxp, kernel_host, found);
	  if found
	  then
	    begin
	      format.start;
	      format.skip_to(5);
	      format.string ( 'mxp: \');
	      format.number (mxp, 16);
	      format.skip_to (15);
	      format.string ('shaman host: \');
	      name_format.host_name (kernel_host, format);
	      format.write_line (user_terminal)
	    end
        end (* for *)
    end  (* if node found *)

  else
    user_terminal.write_message (
      'No node information found in reload facility with that number\')
end (* run_list_configuration_node_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		       scan_list_configuration_node			*)
(*									*)
(*      Scan the list configuration node command.			*)
(*      Format is: LIST CONFIGURATION NODE <node>			*)
(*									*)
(************************************************************************)



procedure scan_list_configuration_node(var scanned: scanned_command);

var
  node: node_index;

begin
  argument_scan.freeword_node(0, scanned, node);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    if profile.node_access_check(node)
    then run_list_configuration_node_command(node)
    else scanned.status := NODE_ACCESS_ERROR
end (* scan_list_configuration_node *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		   scan_list_configuration_command			*)
(*									*)
(*      Scan the list confuguration command.				*)
(*									*)
(************************************************************************)



procedure entry scan_list_configuration_command(
    var scanned: scanned_command);

var 
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_LIST_NODE_KEYWORD,
    MAIN_LIST_HOST_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then
    case keyword of

      MAIN_LIST_NODE_KEYWORD:
        scan_list_configuration_node(scanned);

      MAIN_LIST_HOST_KEYWORD:
	scan_list_configuration_host(scanned)

    end (* case *)
end (* scan_list_configuration_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		  	run_list_active_host_command			*)
(*									*)
(*	Run  the LIST ACTIVE HOST command.				*)
(*									*)
(************************************************************************)


procedure run_list_active_host_command ;

var
  active_hosts		: host_set;

begin
  reload_file.get_active_hosts (active_hosts);
  
  format.start;
  format.string ('hosts \ ');
  format.string ('active in the reload facility:\ ');
  format.write_line(user_terminal);
  format.start;
  format.skip_to (2);
  
  printer.print_host_set (active_hosts);

  format.write_line (user_terminal)
end (* run_list_active_host_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		 	run_list_active_node_command			*)
(*									*)
(*	Run  the LIST ACTIVE NODE command.				*)
(*									*)
(************************************************************************)


procedure run_list_active_node_command;

var
  active_nodes		: node_set;

begin
  reload_file.get_active_nodes (active_nodes);
  
  format.start;
  format.string ('nodes \ ');
  format.string ('active in the reload facility:\ ');
  format.write_line(user_terminal);
  format.start;
  format.skip_to (2);
  
  printer.print_node_set (active_nodes);

  format.write_line (user_terminal)
end (* run_list_active_node_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		  	scan_list_active_command			*)
(*									*)
(*      Scan the list active command. Format are:			*)
(*        	LIST ACTIVE						*)
(*	        LIST ACTIVE HOST					*)
(*		LIST ACTIVE NODE					*)
(*									*)
(************************************************************************)



procedure entry scan_list_active_command(var scanned: scanned_command);

var 
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_LIST_NODE_KEYWORD,
    MAIN_LIST_HOST_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	case keyword of

	  MAIN_LIST_NODE_KEYWORD:
	    run_list_active_node_command;

	  MAIN_LIST_HOST_KEYWORD:
	    run_list_active_host_command

        end (* case *)
    end
  else if scanned.status = ARG_MISSING
  then
    begin
      scanned.status := CMD_OK;
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  run_list_active_node_command;
	  run_list_active_host_command
	end
    end
end (* scan_list_active_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		    run_list_deactive_host_command			*)
(*									*)
(*	Run  the  DEACTIVE HOST command.				*)
(*									*)
(************************************************************************)


procedure run_list_deactive_host_command;

var
  active_hosts		: host_set;

begin
  reload_file.get_active_hosts (active_hosts);
  
  format.start;
  format.string ('hosts \ ');
  format.string ('not \ ');
  format.string ('active in the reload facility:\ ');
  format.write_line(user_terminal);
  format.start;
  format.skip_to (2);
  
  printer.print_not_host_set (active_hosts);

  format.write_line (user_terminal)
end (* run_list_deactive_host_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		      run_list_deactive_node_command			*)
(*									*)
(*	Run the DEACTIVE NODE command.					*)
(*									*)
(************************************************************************)


procedure run_list_deactive_node_command;

var
  active_nodes		: node_set;

begin
  reload_file.get_active_nodes (active_nodes);
  
  format.start;
  format.string ('nodes \ ');
  format.string ('not \ ');
  format.string ('active in the reload facility:\ ');
  format.write_line(user_terminal);
  format.start;
  format.skip_to (2);

  printer.print_not_node_set (active_nodes);

  format.write_line (user_terminal)
end (* run_list_deactive_node_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		  	scan_list_deactive_command			*)
(*									*)
(*      Scan the list deactive command. Format are:			*)
(*        	LIST DEACTIVE						*)
(*	        LIST DEACTIVE HOST					*)
(*		LIST DEACTIVE NODE					*)
(*									*)
(************************************************************************)



procedure entry scan_list_deactive_command(var scanned: scanned_command);

var 
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_LIST_NODE_KEYWORD,
    MAIN_LIST_HOST_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	case keyword of

	  MAIN_LIST_NODE_KEYWORD:
	    run_list_deactive_node_command;

	  MAIN_LIST_HOST_KEYWORD:
	    run_list_deactive_host_command

        end (* case *)
    end
  else if scanned.status = ARG_MISSING
  then
    begin
      scanned.status := CMD_OK;
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  run_list_deactive_node_command;
	  run_list_deactive_host_command
	end
    end
end (* scan_list_deactive_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		     run_list_node_host_reload_outage			*)
(*									*)
(*      Run the LIST NODE RELOAD STATUS					*)
(*		LIST HOST RELOAD STATUS					*)
(*									*)
(************************************************************************)


procedure run_list_node_host_reload_outage(keyword: command_keyword_index);

begin
  response_buffer.start_put;
  case keyword of
    MAIN_LIST_NODE_KEYWORD:
      reload_file.dump_node_reload_outages(profile, response_buffer, format);

    MAIN_LIST_HOST_KEYWORD:
      reload_file.dump_host_reload_outages(profile, response_buffer, format)
  end (* case *) ;

  response_buffer.print(user_terminal)
end (* run_list_node_host_reload_outage *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		      scan_list_reload_status_command			*)
(*									*)
(*      Scan the list reload status commands. Format are:		*)
(*	        LIST HOST RELOAD STATUS					*)
(*		LIST NODE RELOAD STATUS					*)
(*									*)
(************************************************************************)



procedure entry scan_list_reload_status_command(var scanned: scanned_command);

var 
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_LIST_NODE_KEYWORD,
    MAIN_LIST_HOST_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    if not profile.license_check(RELLST_LICENSE)
    then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then run_list_node_host_reload_outage(keyword)
end (* scan_list_reload_status_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		     run_list_node_host_reload_failure			*)
(*									*)
(*      Run the LIST NODE RELOAD STATUS					*)
(*		LIST HOST RELOAD STATUS					*)
(*									*)
(************************************************************************)


procedure run_list_node_host_reload_failure(keyword: command_keyword_index);

begin
  response_buffer.start_put;
  case keyword of
    MAIN_LIST_NODE_KEYWORD:
      reload_file.dump_reload_node_failure(profile, response_buffer, format);

    MAIN_LIST_HOST_KEYWORD:
      reload_file.dump_reload_host_failure(profile, response_buffer, format)
  end (* case *) ;

  response_buffer.print(user_terminal)
end (* run_list_node_host_reload_outage *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*		      scan_list_reload_failure_command			*)
(*									*)
(*      Scan the list reload failure commands. Format are:		*)
(*	        LIST RELOAD FAILURE HOST				*)
(*		LIST RELOAD FAILURE NODE				*)
(*									*)
(************************************************************************)



procedure entry scan_list_reload_failure_command(var scanned: scanned_command);

var 
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_LIST_NODE_KEYWORD,
    MAIN_LIST_HOST_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    if not profile.license_check(RELLST_LICENSE)
    then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then run_list_node_host_reload_failure(keyword)
end (* scan_list_reload_failure_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			send_probe_dload_command			*)
(*									*)
(*	Send the PROBE DLOAD <node> command to put node in boot.	*)
(*									*)
(************************************************************************)


procedure send_probe_dload_command (
	node 		: node_index;
  var	ok		: boolean
);

var
  current_supervisor	: supervisor_index;

begin
  ok := FALSE;
  current_supervisor := supervisor_common.awake_supervisor;
  if current_supervisor <> no_supervisor
  then
    begin
      format.simple_message ('DLOAD \ ');
      format.node_number (node);
      ok := multiplexer.send_command (
        user, current_supervisor, format.buffer.text, format.buffer.pointer);
      if ok
      then
        multiplexer.ignore_response (user)
    end
  else
    user_terminal.write_message ('** no circuit to awake supervisor **\ ')
end (* send_probe_dload_command *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			     reload_slot				*)
(*									*)
(*	Check that kernel or shaman host for node the slot resides on	*)
(*	is answered and reload the slot or mxp.				*)
(*									*)
(************************************************************************)


procedure reload_slot (
	node		: node_index;
	mxp		: mxp_index;
	slot		: slot_index;
	slot_reload	: boolean;
	perform_dump	: boolean;
	print		: boolean
);

begin
  if slot_reload
  then
    begin
      start_slot_reload (node, mxp, slot, perform_dump, print);
      reload_file.reset_slot_reloading_state (node, mxp, slot)
    end
  else
    begin
      start_mxp_reload (node, mxp, perform_dump, print);
      reload_file.reset_mxp_reloading_state (node, mxp)
    end;

  job_status.delay_processing (RELOAD_SLEEP_INTERVAL)
end (* reload_slot *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			      process_nodes				*)
(*									*)
(*	Search for nodes to reload.					*)
(*									*)
(************************************************************************)


procedure process_nodes (print : boolean);

var
  found		: boolean;
  node		: node_index;
  perform_dump	: boolean;

begin
  (*  Begin searching for all nodes that require reloading.  A node	*)
  (*  is reloaded when it is in a node_lost state for more that 60	*)
  (*  seconds.  When a node is reloaded, all slots must be checked  	*)
  (*  to insure that  every  xom hosts on the slot has its		*)
  (*  configuration parameters restored through network console/xom.	*)

  print_header ('nodes\');

  found := TRUE;
  while job_status.ok and found do
    begin
      reload_file.get_node_to_reload (profile, node, perform_dump, found);
      if found
      then
        begin
          start_node_reload (node, perform_dump, print);

          reload_file.reset_node_reloading_state (node);

          job_status.delay_processing (RELOAD_SLEEP_INTERVAL)
        end
    end (* while *) ;

  job_status.delay_processing (RELOAD_SLEEP_INTERVAL)
end (* process_nodes *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			      process_slots				*)
(*									*)
(*	Search for slots to reload.					*)
(*									*)
(************************************************************************)


procedure process_slots (print : boolean);

var
  found		: boolean;
  perform_dump	: boolean;
  slot_reload	: boolean;
  node		: node_index;
  mxp		: mxp_index;
  slot		: slot_index;

begin
  (*  Begin searching for slots that require reloading.  A slot 	*)
  (*  is reloaded only when all hosts on it are in a host_gone state. 	*)
  (*  When a slot is reloaded, all hosts must be checked to insure 	*)
  (*  that every  xom hosts on the slot have the configuration 	  	*)
  (*  parameters restored through network console/xom.		  	*)

  print_header ('slots\');
  node := 0 (* set to 0 in case none are found *);
  mxp  := 0 (* set to 0 in case none are found *);
  slot := 0 (* set to 0 in case none are found *);

  found := TRUE;
  while job_status.ok and found do
    begin
      reload_file.get_slot_to_reload (
        profile, node, mxp, slot, slot_reload, perform_dump, found);

      if found
      then
        reload_slot (node, mxp, slot, slot_reload, perform_dump, print)
    end (* while *) ;

  job_status.delay_processing (RELOAD_SLEEP_INTERVAL)
end (* process_slots *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			process_recurring_nodes				*)
(*									*)
(*	Search for nodes in a recurring outage state to reload.		*)
(*									*)
(************************************************************************)


procedure process_recurring_nodes;

var
  found		: boolean;
  node		: node_index;

begin
  (*  Begin searching for nodes that are in a recurring outage state	*)
  (*  and the current node outage value is greater than the user 	*)
  (*  recurring outage threshold.  When a node is found that is also	*)
  (*  in active the reload facility and the user has access to it in	*)
  (*  their profile, the node is reloaded.				*)

  print_header ('recurring nodes\');

  found := TRUE;
  while job_status.ok and found do
    begin
      reload_file.get_recurring_node (profile, node, found);
      if found 
      then
        send_probe_dload_command (node, found);
      if found
      then
        print_dload_message (node)
    end (* while *) ;
  
  job_status.delay_processing (RELOAD_SLEEP_INTERVAL)
end (* process_recurring_nodes *) ;



(*************************  reload_execution  ***************************)
(*									*)
(*			process_recurring_hosts				*)
(*									*)
(*	Search for hosts in a recurring outage state to reload.		*)
(*									*)
(************************************************************************)


procedure process_recurring_hosts (print : boolean);

var
  found		: boolean;
  perform_dump	: boolean;
  slot_reload	: boolean;
  node		: node_index;
  mxp		: mxp_index;
  slot		: slot_index;
  host		: host_index;

begin
  (*  Begin searching for hosts that are in a recurring outage state	*)
  (*  and the current host outage value is greater than the user 	*)
  (*  recurring outage threshold.  When a host is found that is also	*)
  (*  in active the reload facility and the user has access to it in	*)
  (*  their profile, the slot the host resides on is reloaded.		*)

  print_header ('recurring hosts\');

  host  := 0;
  node  := 0;
  found := TRUE;
  while job_status.ok and found do
    begin
      reload_file.get_recurring_host_slot (
        profile, node, mxp, slot, host, slot_reload, perform_dump, found);
      if found 
      then
        reload_slot (node, mxp, slot, slot_reload, perform_dump, print)
    end (* while *) ;

  job_status.delay_processing (RELOAD_SLEEP_INTERVAL)
end (* process_recurring_hosts *) ;




(*************************  reload_execution  ***************************)
(*									*)
(*			      start_reload				*)
(*									*)
(*	Begin automatic reloading.					*)
(*									*)
(************************************************************************)


procedure entry start_reload (print : boolean);

begin
  while job_status.ok do
    begin
      if not job_status.detached
      then user_terminal.write_newline;

      process_nodes (print);

      process_slots (print);
      
      process_recurring_nodes;

      process_recurring_hosts (print)
      
    end (* while *)
end (* start_reload *) ;
$endif reload



(************************************************************************)
(************************************************************************)


begin (* initial statement *)
  initialize
end (* reload_execution *) ;
$endif any reload xcom
 $if networkconsole
!
(************************************************************************)
(*									*)
(*	NETCON.TMS  Updated 31-Mar-86 at 16:48 by Paktor		*)
(*									*)
(*			 netcon_execution				*)
(*									*)
(*	This class handles all Network Console protocol.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	circuit_handler	    host_buffer		statistics_gathere	*)
(*	internal_to_string  sleeper		system_error_type	*)
(*	needle_name_index   needle_name		host_index		*)
(*	terminal_buffer	    terminal_buffer_limit			*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Jun84 Original --- bss					*)
(*      20Jan86 Adapt to new circuit handler and use a scanned_command  *)
(*		record instead of a terminal_buffer record -- gde	*)
(*	31Mar86 Adapt to circuit handler for automatic backup -- dlp	*)
(*									*)
(************************************************************************)



type
  ntcn_read_status		= (
    NTCN_CIRCUIT_ZAPPED, NTCN_COMMAND_COMPLETE, NTCN_RESPONSE_COMPLETE);


type
  netcon_execution = class (
    aux_circuit_handler		: circuit_handler;
    xom_restore_unit		: aux_circuit_unit_index;
    statistics			: statistics_gatherer
  );

const
  network_console_prompt	= '*';
  max_seconds_to_read_prompt	= 180;


(*************************  netcon_execution  ***************************)
(*									*)
(*			clear_circuit_and_report			*)
(*									*)
(*	Clear the circuit and report error that caused clearing.	*)
(*									*)
(************************************************************************)


procedure clear_circuit_and_report (error : system_error_type);

begin
  statistics.report_system_error_counter (error);
  aux_circuit_handler.clear_circuit
end (* clear_circuit_and_report *) ;



(*************************  netcon_execution  ***************************)
(*									*)
(*			      circuit_built				*)
(*									*)
(*	Build aux circuit to network console.				*)
(*									*)
(************************************************************************)


function entry circuit_built : boolean;

var
  character		: char;
  read_timer		: integer;
  login_string		: network_login_string;

begin
  login_string.text :=
    'NETNTCN;                                ';
  login_string.size := 8;

  (*  build circuit  *)  
  aux_circuit_handler.build_aux_circuit (
    xom_restore_unit,
    [complete],
    login_string);
  
  if not aux_circuit_handler.available
  then
    statistics.report_system_error_counter (netcon_build_failed)

  else
    begin
      read_timer := realtime + MAX_SECONDS_TO_READ_PROMPT;
      
      (*  set the timeout period for all io operations  *)
      aux_circuit_handler.set_read_timeout (MAX_SECONDS_TO_READ_PROMPT);

      (* secondary login to network console *)
      aux_circuit_handler.write_string (network_console_user_name);
      aux_circuit_handler.write_one_character ('(:13:)');
      aux_circuit_handler.write_string (network_console_password);
      aux_circuit_handler.write_one_character ('(:13:)');

      repeat
        aux_circuit_handler.read_one_character (character);
      until (character = NETWORK_CONSOLE_PROMPT)
	or (not aux_circuit_handler.available)
        or (realtime > read_timer) ;

      if character <> NETWORK_CONSOLE_PROMPT
      then
	clear_circuit_and_report (cannot_read_netcon_prompt)
      else
      if aux_circuit_handler.available
      then
	(* read in the space that follows the prompt and ignore it *)
	aux_circuit_handler.read_one_character (character)

    end (* if not aux_circuit_handler.available *)  ;

  circuit_built := aux_circuit_handler.available
end (* circuit_built *) ;



(*************************  netcon_execution  ***************************)
(*									*)
(*			   read_response_line				*)
(*									*)
(*	Read a line of data from the NTCN host one character at a time	*)
(*	until either an NTCN command prompt or carriage return		*)
(*	linefeed is received.						*)
(*									*)
(************************************************************************)


procedure entry read_response_line (
  var scanned		: scanned_command;
  var status		: ntcn_read_status
);

begin
  status := NTCN_RESPONSE_COMPLETE;

  with scanned.input_line do
    begin
      aux_circuit_handler.read_one_character (text[0]);
      size := 1;
      if not aux_circuit_handler.available
      then
	status := NTCN_CIRCUIT_ZAPPED;
    
      if (status <> NTCN_CIRCUIT_ZAPPED) and 
		(text[0] = NETWORK_CONSOLE_PROMPT)
      then
	(* line contains only ntcn command prompt *)
	begin
	  status := NTCN_COMMAND_COMPLETE;
    
	  (* read in the space that follows the prompt and ignore it *)
	  aux_circuit_handler.read_one_character (text[1]);
	  if not aux_circuit_handler.available
	  then
	    status := NTCN_CIRCUIT_ZAPPED
	end ;
	    
      if status = NTCN_RESPONSE_COMPLETE
      then
	begin
	  repeat
	    if size > COMMAND_LINE_TEXT_LIMIT
	    then
	      status := NTCN_CIRCUIT_ZAPPED
	    else
	      begin
		aux_circuit_handler.read_one_character (text[size]);
		if not aux_circuit_handler.available
		then
		  status := NTCN_CIRCUIT_ZAPPED
		else
		  size := size + 1
	      end
	  until (status = NTCN_CIRCUIT_ZAPPED) or
		 (text[size-1] = '(:10:)') ;
    
	  if status = NTCN_RESPONSE_COMPLETE
	  then
	    size := size - 2
	end (* if status = NTCN_RESPONSE_COMPLETE *) 
    end (* with *)
end (* read_response_line *) ;



(***************************  ntcn_execution  ***************************)
(*									*)
(*			    read_command_line				*)
(*									*)
(*	Read an NTCN prompt ending with the given termination		*)
(*	character.							*)
(*									*)
(************************************************************************)


procedure entry read_command_line (
      termination_char		: char;
  var scanned			: scanned_command;
  var status			: ntcn_read_status
);

begin
  status := NTCN_RESPONSE_COMPLETE;

  with scanned.input_line do
    begin
      size := 0;
      repeat
	if size > COMMAND_LINE_TEXT_LIMIT
	then
	  status := NTCN_CIRCUIT_ZAPPED
	else
	  begin
	    aux_circuit_handler.read_one_character (text[size]);
	    if not aux_circuit_handler.available
	    then
	      status := NTCN_CIRCUIT_ZAPPED
	    else
	      size := size + 1
	  end
      until (status = NTCN_CIRCUIT_ZAPPED) 
	or (text[size-1] = termination_char);
    
      if status = NTCN_RESPONSE_COMPLETE
      then
	begin
	  (* read and ignore trailing blank *)
	  aux_circuit_handler.read_one_character (text[size]);
	  size := size - 1 (* strip off termin char + trailing blank *) ;
	  if not aux_circuit_handler.available
	  then
	    status := NTCN_CIRCUIT_ZAPPED
	end
    end (* with *)
end (* read_command_line *) ;



(*************************  netcon_execution  ***************************)
(*									*)
(*				  logout				*)
(*									*)
(*	Clear circuit.							*)
(*									*)
(************************************************************************)


procedure entry logout;

begin
  aux_circuit_handler.clear_circuit
end (* logout *) ;



(*************************  netcon_execution  ***************************)
(************************************************************************)


begin (* initial statement *)
end (* reload_execution *) ;
$endif
 $if reload
!
(************************************************************************)
(*									*)
(*	RELNET.TMS							*)
(*									*)
(*			    reload_netcon				*)
(*									*)
(*	All XOM host configuration parameter restoration must be 	*)
(*	performed through here.						*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	circuit_handler	    host_buffer		statistics_gatherer	*)
(*	internal_to_string  netcon_execution	sleeper			*)
(*	format_buffer	    string_to_internal  terminal_buffer_index	*)
(*	reload_results	    node_index		slot_index		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Jun84 Original --- bss					*)
(*	20Jan86 Made following changes: -- gde				*)
(*		  <> Use Scanned_command record instead of 		*)
(*		     Format_buffer record				*)
(*		  <> Adapt to new Command_scanner			*)
(*									*)
(************************************************************************)


type
  reload_netcon = class (
    aux_circuit_handler		: circuit_handler;
    xom_restore_unit		: aux_circuit_unit_index;
    def				: command_table;
    license_operator		: license_utility;
    supervisor_common		: global_supervisor_data;
    oplog			: operator_log;
    statistics			: statistics_gatherer;
    user_terminal		: circuit_handler;
    format			: internal_to_string
  );


var
  netcon_exec		: netcon_execution;
  oper_messages		: operator_messages;
  argument_scan		: argument_scanner;  
  keyword_util		: keyword_utility;
  command_scan		: command_scanner;

  (*  the proceed boolean indicates if the current step (reading elf	*)
  (*  prompt, checking the prompt received for the one that was		*)
  (*  anticpated, or if the write line) has been successful.		*)	

  proceed		: boolean ;
  status		: ntcn_read_status;
  scanned		: scanned_command;
  next_freeword		: command_freeword_index;


(***************************  reload_netcon  ****************************)
(*									*)
(*			       initialize				*)
(*									*)
(*	Class initialization.						*)
(*									*)
(************************************************************************)


procedure initialize;

begin
  init netcon_exec (aux_circuit_handler, xom_restore_unit, statistics);
  init oper_messages (oplog, format);
  init argument_scan(supervisor_common, license_operator);
  init keyword_util(format, user_terminal, def, argument_scan);
  init command_scan(user_terminal, def, argument_scan, keyword_util)
end (* initialize *) ;



(****************************  reload_netcon  ***************************)
(*									*)
(*			     string_match				*)
(*									*)
(*     Check if the next freewords form a certain string and 		*)
(*     update next_freeword if found.					*)
(*									*)
(************************************************************************)



function string_match(string: message_string): boolean;

var 
  matches: integer;

begin
  argument_scan.freeword_message_string(
    string, next_freeword, scanned, matches);
  if matches <> 0
  then next_freeword := next_freeword + matches;
  string_match := matches <> 0
end (* string_match *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			     format_message				*)
(*									*)
(*	Format standard results message.				*)
(*									*)
(************************************************************************)


procedure format_message (host : host_index);

begin
  format.simple_message ('HOST \');
  format.host_number (host);
  format.string (' XOM RESTORE \')
end (* format_message *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			      report_oplog				*)
(*									*)
(*	Format and send a message to the operator_log.			*)
(*									*)
(************************************************************************)


procedure report_oplog (host : host_index);

begin
  format_message (host);
  if proceed
  then
    format.string ('SUCCESSFUL\ ')
  else
    begin
      format.string ('FAILED - \');
      format.command_line_string (scanned.input_line)
    end;
  
  oper_messages.save_message (RELEXE_LICENSE)
end (* report_oplog *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			 report_circuit_failure				*)
(*									*)
(*	Report error in building circuit.				*)
(*									*)
(************************************************************************)


procedure report_circuit_failure (host : host_index);

begin
  format_message (host);
  format.string ('FAILED - UNABLE TO BUILD CIRCUIT TO NTCN HOST\  ');
  oper_messages.save_message (RELEXE_LICENSE)
end (* report_circuit_failure *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			      check_status				*)
(*									*)
(*	Check the netcon read status and set proceed accordingly.	*)
(*									*)
(************************************************************************)


procedure check_status ;

begin
  proceed := (status <> NTCN_CIRCUIT_ZAPPED) and (scanned.status = CMD_OK)
end (* check_status *) ;



(****************************  reload_netcon  ***************************)
(*									*)
(*			   get_response_line				*)
(*									*)
(*	Get a response line from NETCON.				*)
(*									*)
(************************************************************************)


procedure get_response_line ;

begin
  netcon_exec.read_response_line(scanned, status);
  command_scan.scan_response_line(scanned);
  next_freeword := 0;
  check_status
end (* get_response_line *) ;



(****************************  reload_netcon  ***************************)
(*									*)
(*			   get_command_line				*)
(*									*)
(*	Get a command line from NETCON.					*)
(*									*)
(************************************************************************)


procedure get_command_line (termination_character : char) ;

begin
  netcon_exec.read_command_line (
    termination_character, scanned, status);
  command_scan.scan_response_line(scanned);
  next_freeword := 0;
  check_status
end (* get_command_line *) ;



(****************************  reload_netcon  ***************************)
(*									*)
(*			    send_command_line				*)
(*									*)
(*	Sends NETCON command.						*)
(*									*)
(************************************************************************)


procedure send_command_line;

begin
  (* add a carraige return on for line termination *)
  format.character ('(:13:)');
  format.write_block (aux_circuit_handler);
  proceed := aux_circuit_handler.available 
end (* send_command_line *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			    send_xom_command				*)
(*									*)
(*	Send the XOM command to enter the current XOM host.		*)
(*									*)
(************************************************************************)


procedure send_xom_command (host : host_index);

begin
  format.simple_message('XOM \ ');
  format.host_number(host);

  send_command_line
end (* send_xom_command *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			   send_restore_command				*)
(*									*)
(*	Send the XOM RESTORE command to restore the host config.	*)
(*									*)
(************************************************************************)


procedure send_restore_command;

begin
  get_command_line('>');
  if proceed
  then
    begin
      format.simple_message('RESTORE\');
      send_command_line
    end
end (* send_restore_command *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			 check_restore_results				*)
(*									*)
(*	Check the results from the XOM restore command.			*)
(*									*)
(************************************************************************)


procedure check_restore_results ;

var
  continue	: boolean;

begin
  continue := TRUE;

  repeat
    get_response_line;
    if proceed
    then
      if string_match('Restore Complete\ ')
      then
	continue := FALSE

      else
      if string_match('Option(s)\')
      then
        begin
	  get_response_line (* read in at least one failed options line *) ;
          proceed := FALSE
        end
  until not (continue and proceed)
end (* check_restore_results *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			send_xom_restore_command			*)
(*									*)
(*	Send the XOM <host>  command.					*)
(*									*)
(************************************************************************)


procedure send_xom_restore_command (host : host_index);

begin
  send_xom_command (host);
  if proceed
  then
    send_restore_command;

  if proceed
  then
    check_restore_results
end (* send_xom_restore_command *) ;



(***************************  reload_netcon  ****************************)
(*									*)
(*			      start_restore				*)
(*									*)
(*	Begin XOM configuration parameter restoration.			*)
(*									*)
(************************************************************************)


function entry start_restore (host : host_index) : boolean;

begin
  proceed := netcon_exec.circuit_built;

  if not proceed
  then
    report_circuit_failure (host)
  else
    begin
      send_xom_restore_command (host);

      netcon_exec.logout;
      report_oplog (host)
    end;

  start_restore := proceed
end (* start_restore *) ;




(***************************  reload_netcon  ****************************)
(************************************************************************)


begin (* initial statement *)
  initialize
end (* reload_netcon *) ;
$endif
$if reload
!
(************************************************************************)
(*                                                                    	*)
(*     XGATH.TMS Updated 28-Mar-86 at 16:43 by Hueyma			*)
(*                                                                    	*)
(*                         xom_gather                             	*)
(*                                                                    	*)
(*    This process handles the gathering of host_up messages and	*)
(*    the restoring of xom configuration parameters for any valid	*)
(*    hosts that are xom hosts.						*)
(*									*)
(*     The following identifiers must be defined externally:          	*)
(*       node_index         host_index          event_reader_time       *)
(*       node_utility       host_utility        event_utility         	*)
(*       event_reader       sleeper             internal_to_string     	*)
(*       operator_log       message_string      global_xom_data         *)
(*	 host_buffer	    operator_messages	statistics_gatherer	*)
(*	 circuit_handler    event_record_time  	aux_circuit_unit_index	*)
(*	 event_set	    event_index		global_supervisor_data	*)
(*	 reload_results     reload_netcon	expanded_erlog_message	*)
(*                                                                    	*)
(************************************************************************)
(*                                                                    	*)
(*                           Revision Record                          	*)
(*                                                                    	*)
(*    14Feb81    Original -- bss                                      	*)
(*    20Jan86    Adapt to new Circuit_handler -- gde			*)
(*                                                                    	*)
(************************************************************************)



type
  xom_gather =  process (
    oplog		: operator_log;
    statistics		: statistics_gatherer;
    nem_reader_unit	: aux_circuit_unit_index;
    xom_restore_unit	: aux_circuit_unit_index;
    supervisor_common	: global_supervisor_data;
    license_operator	: license_utility;
    def			: command_table;
    xom_common		: global_xom_data
   );


const
  backup_interval               = 300 (* seconds *) ;
  initial_build_interval        =  60 (* seconds *) ;
  additional_build_interval     = 180 (* seconds *) ;
  maximum_build_interval        = 960 (* seconds *) ;

var
  format                        : internal_to_string;
  user_terminal			: circuit_handler;
  node_operator                 : node_utility;
  event_operator                : event_utility;
  host_operator                 : host_utility;
  oper_messages			: operator_messages;
  nem_circuit_handler		: circuit_handler;
  event_machine                 : event_reader;
  xom_circuit_handler		: circuit_handler;
  netcon_reloader		: reload_netcon;
  alarm                         : sleeper;
  build_interval                : integer;
  first_time                    : event_record_time (* time of last message *);
                                  (* where message from logger is put *)
  message                       : expanded_erlog_message ;
  events_of_interest    	: event_set;



(*****************************  xom_gather  ***************************)
(*                                                                    *)
(*                             initialize                             *)
(*                                                                    *)
(*    Initialize gather variables.                                    *)
(*                                                                    *)
(**********************************************************************)



procedure initialize;

begin
  init format, user_terminal, node_operator, event_operator, host_operator;
  init oper_messages (oplog, format);
  init nem_circuit_handler;
  init
    event_machine (nem_circuit_handler, nem_reader_unit, statistics, format);
  init xom_circuit_handler;
  init netcon_reloader (
	 xom_circuit_handler, xom_restore_unit, def, license_operator,
	 supervisor_common, oplog, statistics, user_terminal, format);
  init alarm;
  build_interval := initial_build_interval;

  (*									*)
  (*      set up events_of_interest event_set  				*)
  (*									*)
  (*    event 32.1     host up events					*)
  (*									*)

  event_operator.clear (events_of_interest);

  event_operator.add_event (32, events_of_interest);
  event_operator.add_event (first_event_32_subevent + 1, events_of_interest);

  with first_time do
    begin
      seconds := realtime-backup_interval;
      offset  := -1
    end (* with *)
end (* initialize *) ;



(*****************************  xom_gather  ***************************)
(*                                                                    *)
(*                            report_error                            *)
(*                                                                    *)
(*    Report invalid logger messages received.                        *)
(*                                                                    *)
(**********************************************************************)



procedure report_error ;

begin
  with format, message, oper_messages do
    begin
      start;
      string('invalid erlog message in xom gather\');
      string(', supervisor: \ ');
      number(supervisor_common.host(event_supervisor), 10);
      skip(1);
      number(event_code, 10);
      skip(1);
      number(hw1, 16);
      skip(1);
      number(hw2, 16);
      skip(1);
      number(hw3, 16);
      skip(1);
      number(hw4, 16);
      save_message(DEV_LICENSE)
    end (* with *)
end (* report_error *) ;



(*****************************  xom_gather  *****************************)
(*									*)
(*			      report_oplog				*)
(*									*)
(*	Report message to operator_log that restore failure reached	*)
(*	thre maximum number of retrys.					*)
(*									*)
(************************************************************************)


procedure report_oplog (host : host_index);

begin
  format.simple_message ('HOST \');
  format.host_number (host);
  format.string (' XOM RESTORE FAILURES EXCEEDED MAXIMUM RETRIES\ ');
  oper_messages.save_message (RELEXE_LICENSE)
end (* report_oplog *) ;



(*****************************  xom_gather  *****************************)
(*									*)
(*				 restore				*)
(*									*)
(*	Perform steps necessary to restore xom config. parameters.	*)
(*									*)
(************************************************************************)


procedure restore (host	: host_index);

var
  retry		: integer;
  success	: boolean;

begin
  retry := 1;
      
  repeat
    success := netcon_reloader.start_restore (host);

    if not success
    then retry := retry + 1

  until success or (retry > MAX_XOM_RESTORE_ATTEMPTS) ;
	
  if not success
  then report_oplog (host)
  else xom_common.reset_xom_restore (host);
end (* restore *) ;



(*****************************  xom_gather  *****************************)
(*									*)
(*			      process_host				*)
(*									*)
(*	Check if host in question is an xom host, if so, check if	*)
(*	host requires that configuration parameters be restored, and	*)
(*	proceed accordingly.						*)
(*									*)
(************************************************************************)


procedure process_host (host : host_index);

begin
  if xom_common.restore_xom_host (host)
  then
    restore (host)
end (* process_host *) ;



(*****************************  xom_gather  *****************************)
(*                                                                    	*)
(*                             read_logger                            	*)
(*                                                                    	*)
(*    Read logger, extract messages of interest until circuit lost    	*)
(*    and start xom restore steps if necessary.				*)
(*                                                                    	*)
(************************************************************************)



procedure read_logger;

var
  state			: event_reader_state;

begin
  repeat
    event_machine.read(message, state);
    case state of
      event_reader_lost, event_reader_end:
	statistics.report_system_error_counter(EVENT_READ_LOST);

      event_reader_empty:
        wait;

      event_reader_ok:
        with message do
          begin
            first_time := event_time;
	    
	    (* insure that host and node are valid numbers *)

	    if not host_operator.range_check (hw2)
	    or not node_operator.range_check (hw4)
	    then
	      report_error

	    else
	    
	      (* insure that only event 32.1 - host up are used *)

	      if  (event_code = 32)
	      and (event_operator.substr (hw1, 8, 0) = 1)
	      then
	        process_host (host_operator.encode(hw2))
              else
	        report_error
          end (* event_reader_ok  *)
    end (* case *) ;

  until (state = event_reader_lost) or (state = event_reader_end)
end (* read_logger *) ;



(****************************  xom_gather  ******************************)
(*									*)
(*			   start_xom_gather				*)
(*									*)
(*	Log gathering execution.					*)
(*									*)
(************************************************************************)


procedure start_xom_gather;

begin
  with event_machine do
    cycle
      if create
      then
        begin
          build_interval := initial_build_interval;
	  start_time (first_time);
	  access_events (events_of_interest);
	  start_sending;
          read_logger
        end

      else
        if build_interval < maximum_build_interval
        then
	  build_interval := build_interval + additional_build_interval;

      alarm.sleep (build_interval);
      
    end (* cycle *)
end (* start_xom_gather *) ;



(*****************************  xom_gather  ***************************)
(**********************************************************************)



begin (* initial statement *)
  initialize;
  start_xom_gather
end (* xom_gather *) ;
$endif
    !
(**********************************************************************)
(*                                                                    *)
(*      GREEXE.TMS                                                    *)
(*                                                                    *)
(*		main_remote_greting_command_handler		      *)
(*                                                                    *)
(*	This class handles the scanning of all commands related	      *)
(*	with remote greeting messages.				      *)
(*                                                                    *)
(*	The following identifiers must be defined externally:	      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                         Revision Record			      *)
(*                                                                    *)
(*	20Jan86 Original -- gde					      *)
(*                                                                    *)
(**********************************************************************)


type
  main_remote_greeting_command_handler =
    class (
      format		     : internal_to_string;
      user_terminal	     : circuit_handler;
      profile		     : user_profile;
      command_read	     : command_loop;
      command_scan	     : command_scanner;
      argument_scan	     : argument_scanner;
      remote_greeting_common : global_remote_greeting_data;
      response_buffer	     : text_buffer
    );

var
  node_operator	     	     : node_utility;
  exec_front_end	     : front_end;
  access_check	     	     : user_access_checker;
  remote_greeting_circuit    : remote_greeting_utility;




(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*			 initialize				      *)
(*                                                                    *)
(*                                                                    *)
(**********************************************************************)


procedure initialize;

begin
  init node_operator;
  init exec_front_end(user_terminal);
  init access_check(format, profile, user_terminal);
  init remote_greeting_circuit(format)
end (* initialize *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*			 remote_greeting_host			      *)
(*                                                                    *)
(*	Prompt for kernel host if node is a tymnet ii node.	      *)
(*                                                                    *)
(**********************************************************************)



procedure remote_greeting_host(
      node		: node_index;
  var kernel_host	: host_index;
  var ok		: boolean);

var
  scanned    : scanned_command;
  host	     : integer;

begin
  format.start;
  format.string('For node \');
  format.node_number(node);
  format.skip(1);
  format.write_block(user_terminal);
  repeat
    command_read.prompt_and_read(
      'Enter kernel host: \', scanned.input_line, ok);
    if ok
    then
      begin
	command_scan.scan_response_line(scanned);
	if scanned.status = CMD_OK
	then argument_scan.freeword_host(0, scanned, host);
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then kernel_host := host
      end
  until (scanned.status = CMD_OK) or not ok
end (* remote_greeting_host *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*			run_set_greeting_message		      *)
(*                                                                    *)
(*	Set a remote greeting message for each node listed.	      *)
(*	If the setting is succesful, make entry in remote greeting    *)
(*	common.							      *)
(*                                                                    *)
(**********************************************************************)



procedure run_set_greeting_message(
      list_scanned	: node_slot_list;
      clear_time	: integer);

const
  greeting_prompt =  'Enter message:(:13:)(:10:)\ ';

var
  unit		: aux_circuit_unit_index;
  kernel_host	: host_index;
  i		: node_slot_list_index;
  message	: format_buffer;
  accepted	: boolean;
  ok		: boolean;

begin
  remote_greeting_common.request_user_circuit(unit, ok);
  if not ok
  then user_terminal.write_message('Remote greeting circuit busy\ ')
  else
    begin
      exec_front_end.prompt_read_format_buffer(greeting_prompt, message, ok);
      if ok
      then
	begin
	  remote_greeting_circuit.format_text(message, ok);
	  if not ok
	  then format.write_line(user_terminal)
	end;
      i := 0;
      while ok and (i < list_scanned.count) do
	begin
	  if access_check.node_access_check(list_scanned.node[i])
	  then
	    begin
	      remote_greeting_host(list_scanned.node[i], kernel_host, ok);
	      if ok
	      then
		begin
		  remote_greeting_circuit.set_message(
		    unit, list_scanned.node[i],
		    kernel_host, list_scanned.slot[i],
		    message, accepted);
		  if accepted
		  then
		    remote_greeting_common.set_entry(
		      list_scanned.node[i], list_scanned.slot[i],
		      kernel_host, clear_time, format, accepted)
		  else format.write_line(user_terminal)
		end
	    end;
	  i := i+1
	end (* while *) ;
      remote_greeting_common.release_user_circuit
    end
end (* run_set_greeting_message *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*			 run_set_greeting_entry			      *)
(*                                                                    *)
(*	Make an entry in the remote_greeting_common for all nodes     *)
(*	scanned. This does not set message remotely, just internally. *)
(*                                                                    *)
(**********************************************************************)



procedure run_set_greeting_entry(
      list_scanned	: node_slot_list;
      clear_time	: integer);

var
  kernel_host	: host_index;
  i		: node_slot_list_index;
  accepted	: boolean;
  ok		: boolean;

begin
  ok := TRUE;
  i := 0;
  while ok and (i < list_scanned.count) do
    begin
      if access_check.node_access_check(list_scanned.node[i])
      then
	begin
	  remote_greeting_host(list_scanned.node[i], kernel_host, ok);
	  if ok
	  then
	    begin
	      remote_greeting_common.set_entry(
		list_scanned.node[i], list_scanned.slot[i],
		kernel_host, clear_time, format, accepted);
	      if not accepted
	      then format.write_line(user_terminal)
	    end
	end;
      i := i+1
    end (* while *)
end (* run_set_greeting_entry *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*		      run_clear_greeting_message		      *)
(*                                                                    *)
(*	Clear a remote greeting message for each node listed.	      *)
(*	If the clear is successfull,clear entry in remote greeting    *)
(*	common.							      *)
(*                                                                    *)
(**********************************************************************)



procedure run_clear_greeting_message(
      list_scanned: node_slot_list);

var
  unit		: aux_circuit_unit_index;
  kernel_host	: host_index;
  i		: node_slot_list_index;
  accepted	: boolean;
  ok		: boolean;

begin
  remote_greeting_common.request_user_circuit(unit, ok);
  if not ok
  then user_terminal.write_message('Remote greeting circuit busy\ ')
  else
    begin
      i := 0;
      while ok and (i < list_scanned.count) do
	begin
	  if access_check.node_access_check(list_scanned.node[i])
	  then
	    begin
	      remote_greeting_host(list_scanned.node[i], kernel_host, ok);
	      if ok
	      then
		begin
		  remote_greeting_circuit.clear_message(
		    unit, list_scanned.node[i], kernel_host,
		    list_scanned.slot[i], accepted);
		  if accepted
		  then 
		    remote_greeting_common.clear_entry(
		      list_scanned.node[i], list_scanned.slot[i])
		  else format.write_line(user_terminal)
		end
	    end;
	  i := i+1
	end (* while *) ;
      remote_greeting_common.release_user_circuit
    end
end (* run_clear_greeting_message *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*			run_clear_greeting_entry		      *)
(*                                                                    *)
(*	Clear entry in the remote_greeting_common for all nodes	      *)
(*	scanned. This does not clear message remotely.		      *)
(*                                                                    *)
(**********************************************************************)



procedure run_clear_greeting_entry(
      list_scanned: node_slot_list);

var
  i	: node_slot_list_index;

begin
  for i := 0 to list_scanned.count-1 do
    if access_check.node_access_check(list_scanned.node[i])
    then
      remote_greeting_common.clear_entry(
	list_scanned.node[i], list_scanned.slot[i])
end (* run_clear_greeting_entry *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*                     scan_time_and_node_slot_list                   *)
(*                                                                    *)
(*   	Scan the time if there is one and the node_slot_list.         *)
(*                                                                    *)
(**********************************************************************)



procedure scan_time_and_node_slot_list(
    var scanned: scanned_command;
    var list_scanned: node_slot_list;
    var clear_time: integer);

var 
  freeword_offset: command_freeword_index;

begin
  freeword_offset := 0;

  if argument_scan.check_keyword(MAIN_SET_TO_KEYWORD, scanned)
  then
    begin
      argument_scan.freeword_date(0, profile, scanned, clear_time);
      freeword_offset := 2;
      if scanned.status = CMD_OK
      then
      	if clear_time <= realtime
  	then scanned.status := DATE_IN_PAST
    end
  else clear_time := MAX_INTEGER;

  if scanned.status = CMD_OK
  then argument_scan.freeword_node_slot_list(
    freeword_offset, scanned, list_scanned);

  argument_scan.extra_argument_check(scanned)
end (* scan_time_and_node_slot_list *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*                        scan_set_host_entry                         *)
(*                                                                    *)
(*   	Scan the set entry command.		                      *)
(*      Format is:  SET GREETING ENTRY [TO <time>] <node_slot_list>   *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_set_host_entry(var scanned: scanned_command);

var
  clear_time   : integer;
  list_scanned : node_slot_list;

begin
  if scanned.status = CMD_OK
  then scan_time_and_node_slot_list(scanned, list_scanned, clear_time);

  if scanned.status = CMD_OK
  then run_set_greeting_entry(list_scanned, clear_time)
end (* scan_set_host_entry *) ;


(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*                     scan_set_greeting_message                      *)
(*                                                                    *)
(*   	Scan the set greeting message. 			              *)
(*      Format is:  SET GREETING MESSAGE [TO <time>] <node_slot_list> *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_set_greeting_message(var scanned: scanned_command);

var
  clear_time: integer;
  list_scanned: node_slot_list;

begin
  if scanned.status = CMD_OK
  then scan_time_and_node_slot_list(scanned, list_scanned, clear_time);

  if scanned.status = CMD_OK
  then run_set_greeting_message(list_scanned, clear_time)
end (* scan_set_greeting_message *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*                   scan_clear_greeting_message                      *)
(*                                                                    *)
(*   	Scan the clear greeting message. 			      *)
(*      Format is:  CLEAR GREETING MESSAGE <node_slot_list> 	      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_clear_greeting_message(var scanned: scanned_command);

var
  list_scanned: node_slot_list;

begin
  argument_scan.freeword_node_slot_list(0, scanned, list_scanned);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then run_clear_greeting_message(list_scanned)
end (* scan_clear_greeting_message *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*                   scan_clear_greeting_entry                        *)
(*                                                                    *)
(*   	Scan the clear greeting entry.	 			      *)
(*      Format is:  CLEAR GREETING ENTRY <node_slot_list> 	      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_clear_greeting_entry(var scanned: scanned_command);

var
  list_scanned: node_slot_list;

begin
  argument_scan.freeword_node_slot_list(0, scanned, list_scanned);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then run_clear_greeting_entry(list_scanned)
end (* scan_clear_greeting_entry *) ;


(*************  main_remote_greeting_commands_handler  ****************)
(*                                                                    *)
(*		     scan_list_greeting_entry			      *)
(*                                                                    *)
(*      Scan the list greeting entry command.Format is:		      *)
(*	  LIST GREETING ENTRY [<node_slot_list>]		      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_list_greeting_entry(
    var scanned: scanned_command);

var
  list_scanned: node_slot_list;

begin
  response_buffer.start_put;

  if scanned.freeword_count > 0
  then
    begin
      argument_scan.freeword_node_slot_list(0, scanned, list_scanned);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	remote_greeting_common.list_entries(
	  list_scanned, response_buffer, format, profile)
    end
  else
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	remote_greeting_common.list_all_entries(
	  response_buffer, format, profile)
    end;

  if scanned.status = CMD_OK
  then response_buffer.print(user_terminal)
end (* scan_list_greeting_entry *) ;



(*************  main_remote_greeting_commands_handler  ****************)
(**********************************************************************)

begin (* initial statement *)
  initialize
end   (* main_remote_greeting_command_handler *) ;
!
(**********************************************************************)
(*                                                                    *)
(*      RECEXE.TMS                                                    *)
(*                                                                    *)
(*		main_recurring_command_handler		              *)
(*                                                                    *)
(*	This class handles the scanning of all commands that	      *)
(*	monitors the recurring outages and the thresholds.	      *)
(*                                                                    *)
(*	The following identifiers must be defined externally:	      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                         Revision Record			      *)
(*                                                                    *)
(*	20Jan86 Original -- gde					      *)
(*                                                                    *)
(**********************************************************************)


type
  main_recurring_command_handler =
    class (
      user_terminal	    : circuit_handler;
      format		    : internal_to_string;
      argument_scan	    : argument_scanner;
      profile	    	    : user_profile;
      node_file	    	    : node_buffer;	
      host_file		    : host_buffer;
      port_file		    : port_buffer;
      main_profile_commands : main_profile_command_handler
    );


(*******************  main_recurring_command_handler  *****************)
(*                                                                    *)
(*                           scan_set_threshold                       *)
(*                                                                    *)
(*   	Scan the set threshold command. Format is:                    *)
(*	SET {NODE|HOST|LINES} THRESHOLD <threshold>	              *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_set_threshold(
    var scanned: scanned_command;
        threshold: external_recurring_outage_index);

var 
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_SET_LINES_KEYWORD,
    MAIN_SET_HOST_KEYWORD, scanned, keyword);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case keyword of
    
      MAIN_SET_NODE_KEYWORD:
	main_profile_commands.set_node_threshold(threshold);

      MAIN_SET_HOST_KEYWORD:
	main_profile_commands.set_host_threshold(threshold);
 
      MAIN_SET_LINES_KEYWORD:
	main_profile_commands.set_line_threshold(threshold)

    end (* case *)
end (* scan_set_threshold *) ;


(*******************  main_recurring_command_handler  *****************)
(*                                                                    *)
(*                           scan_set_recurring                       *)
(*                                                                    *)
(*   	Scan the set recurring command. Format is:                    *)
(*	SET {NODE|HOST|LINES} RECURRINGOUTAGE <Maximum> <Decay>       *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_set_recurring(
    var scanned: scanned_command;
        maximum: external_recurring_outage_index;
        decay  : integer);

var 
  keyword: command_keyword_index;

begin
  if not profile.license_check(OPERATOR_LICENSE)
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then
    argument_scan.find_keyword(
      MAIN_SET_LINES_KEYWORD, MAIN_SET_HOST_KEYWORD, scanned, keyword);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case keyword of
  
      MAIN_SET_NODE_KEYWORD:
	node_file.set_recurring_outage_variables(maximum, decay);

      MAIN_SET_HOST_KEYWORD:
	host_file.set_recurring_outage_variables(maximum, decay);

      MAIN_SET_LINES_KEYWORD:
	port_file.set_recurring_outage_variables(maximum, decay)

    end (* case *)
end (* scan_set_recurring *) ;



(*******************  main_recurring_command_handler  *****************)
(*                                                                    *)
(*                           scan_clear_threshold                     *)
(*                                                                    *)
(*   	Scan the clear threshold command. Format is:                  *)
(*	CLEAR {NODE|HOST|LINES} THRESHOLD			      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_clear_threshold(var scanned: scanned_command);

var 
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_CLEAR_LINES_KEYWORD,
    MAIN_CLEAR_HOST_KEYWORD, scanned, keyword);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case keyword of

      MAIN_CLEAR_NODE_KEYWORD:
	main_profile_commands.set_node_threshold(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT);

      MAIN_CLEAR_HOST_KEYWORD:
	main_profile_commands.set_host_threshold(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT);

      MAIN_CLEAR_LINES_KEYWORD:
	main_profile_commands.set_line_threshold(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT)

    end (* case *)
end (* scan_clear_threshold *) ;



(*******************  main_recurring_command_handler  *****************)
(*                                                                    *)
(*                         scan_clear_recurring                       *)
(*                                                                    *)
(*   	Scan the clear recurring command. Format is:                  *)
(*	CLEAR {NODE|HOST|LINES} RECURRINGOUTAGE		              *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_clear_recurring(var scanned: scanned_command);

var
  keyword: command_keyword_index;

begin
  if not profile.license_check(OPERATOR_LICENSE)
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then
    argument_scan.find_keyword(MAIN_CLEAR_LINES_KEYWORD,
      MAIN_CLEAR_HOST_KEYWORD, scanned, keyword); 
    
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    case keyword of
    
      MAIN_CLEAR_NODE_KEYWORD:
	node_file.set_recurring_outage_variables(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT,
	  DEFAULT_RECURRING_DECAY);

      MAIN_CLEAR_HOST_KEYWORD:
	host_file.set_recurring_outage_variables(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT,
	  DEFAULT_RECURRING_DECAY);

      MAIN_CLEAR_LINES_KEYWORD:
	port_file.set_recurring_outage_variables(
	  EXTERNAL_RECURRING_OUTAGE_LIMIT,
	  DEFAULT_RECURRING_DECAY)

    end (* case *)
end (* scan_clear_recurring *) ;


(*******************  main_recurring_command_handler  *****************)
(*								      *)
(*                    run_list_recurring_threshold                    *)
(*								      *)
(*     Run LIST { NODE/HOST/LINE } THRESHOLD                          *)
(*     Format is: 						      *)
(*     { NODE / HOST / LINE } RECURRING OUTAGE THRESHOLD: <threshold> *)
(*							      	      *)
(**********************************************************************)



procedure run_list_recurring_threshold(
      keyword_scanned : command_keyword_index);

begin
  format.start;

  case keyword_scanned of
    MAIN_LIST_LINE_KEYWORD:  format.string ('line \');
    MAIN_LIST_NODE_KEYWORD:  format.string ('node \');
    MAIN_LIST_HOST_KEYWORD:  format.string ('host \')
  end (* case *) ;

  format.string ('recurring outage threshold: \ ');

  case keyword_scanned of
    MAIN_LIST_LINE_KEYWORD:  format.number (profile.line_threshold, 10);
    MAIN_LIST_HOST_KEYWORD:  format.number (profile.host_threshold, 10);
    MAIN_LIST_NODE_KEYWORD:  format.number (profile.node_threshold, 10)
  end (* case *);

  format.write_line(user_terminal)
end (* run_list_recurring_threshold *) ;


(*******************  main_recurring_command_handler  *****************)
(*								      *)
(*		      run_list_recurring_outage			      *)
(*								      *)
(*     Run LIST { NODE/HOST/LINE } RECURRINGOUTAGE                    *)
(*     Format is: 						      *)
(*     { NODE / HOST / LINE } RECURRING OUTAGE SYSTEM VARIABLES:      *)
(*     MAXIMUM: <maximum>     DECAY: <decay>                          *)
(*							      	      *)
(**********************************************************************)



procedure run_list_recurring_outage( 
      keyword_scanned : command_keyword_index);

var
  maximum   : external_recurring_outage_index;
  decay     : integer;

begin
  format.start;

  case keyword_scanned of
    MAIN_LIST_LINE_KEYWORD:
      begin
        port_file.get_recurring_outage_variables (maximum, decay);
        format.string ('line \')
      end ;

    MAIN_LIST_HOST_KEYWORD:
      begin
        host_file.get_recurring_outage_variables (maximum, decay);
        format.string ('host \')
      end ;
 
    MAIN_LIST_NODE_KEYWORD:
      begin
        node_file.get_recurring_outage_variables (maximum, decay);
        format.string ('node \')
      end 
  
  end (* case *) ;
  format.string ('recurring outage system variables: \  ');
  format.newline;

  format.skip (5);
  format.string ( 'maximum: \');
  format.number(maximum, 10);

  format.skip (5);
  format.string ('decay: \');
  format.number(decay, 10);

  format.write_line(user_terminal)
end (* run_list_recurring_outage *) ;



(*******************  main_recurring_command_handler  *****************)
(*								      *)
(*		        scan_list_threshold			      *)
(*								      *)
(*      Scan the list threshold. Format are:			      *)
(*        LIST [NODE|HOST|LINE] THRESHOLD			      *)
(*							      	      *)
(**********************************************************************)



procedure entry scan_list_threshold(var scanned: scanned_command);

var
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_LIST_NODE_KEYWORD,
    MAIN_LIST_LINE_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then run_list_recurring_threshold(keyword)
    end
  else if scanned.status = ARG_MISSING
  then
    begin
      scanned.status := CMD_OK;
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  run_list_recurring_threshold(MAIN_LIST_NODE_KEYWORD);
	  run_list_recurring_threshold(MAIN_LIST_HOST_KEYWORD);
	  run_list_recurring_threshold(MAIN_LIST_LINE_KEYWORD)
	end 
    end
end (* scan_list_threshold *) ;



(*******************  main_recurring_command_handler  *****************)
(*								      *)
(*		        scan_list_recurring			      *)
(*								      *)
(*      Scan the list recurring. Format are:			      *)
(*        LIST [NODE|HOST|LINE] RECURRING			      *)
(*							      	      *)
(**********************************************************************)



procedure entry scan_list_recurring(var scanned: scanned_command);

var
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_LIST_NODE_KEYWORD,
    MAIN_LIST_LINE_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then run_list_recurring_outage(keyword)
    end
  else if scanned.status = ARG_MISSING
  then
    begin
      scanned.status := CMD_OK;
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  run_list_recurring_outage(MAIN_LIST_NODE_KEYWORD);
	  run_list_recurring_outage(MAIN_LIST_HOST_KEYWORD);
	  run_list_recurring_outage(MAIN_LIST_LINE_KEYWORD)
	end 
    end
end (* scan_list_recurring *) ;



(*******************  main_recurring_command_handler  *****************)
(**********************************************************************)


begin (* initial statement *)
end   (* main_recurring_command_handler *) ;
!
(************************************************************************)
(*                                                                      *)
(*      MESEXE.TMS Updated 3-Oct-87 at 10:29 by Raffo			*)
(*                                                                      *)
(*		   main_host_message_command_handler		        *)
(*                                                                      *)
(*	This class handles the scanning of all commands related	        *)
(*	with host messages.				      	        *)
(*                                                                      *)
(*	The following identifiers must be defined externally:	        *)
(*                                                                      *)
(************************************************************************)
(*                                                                      *)
(*                         Revision Record			        *)
(*                                                                      *)
(*	20Jan86 Original -- gde					        *)
(*                                                                      *)
(************************************************************************)


type
  main_host_message_command_handler =
    class (
      user		 : user_index;
      user_terminal	 : circuit_handler;
      format		 : internal_to_string;
      profile		 : user_profile;
      response_buffer	 : text_buffer;
      host_status_common : global_host_status_data;
      supervisor_common  : global_supervisor_data;
      argument_scan	 : argument_scanner;
      command_scan	 : command_scanner;
      oper_messages	 : operator_messages;
      sysmsg1_access	 : sysmsg1_access_manager;
      aux_circuit_handler: circuit_handler;
      logger_unit	 : aux_circuit_unit_index
    );

var
  exec_front_end 	: front_end;
  access_check		: user_access_checker;
  sysmsg1_operator	: sysmsg1_utility;
  standard		: symbol;


(****************  main_host_message_commands_handler  ******************)
(*                                                                      *)
(*				initialize			        *)
(*                                                                      *)
(************************************************************************)


procedure initialize;
  
begin
  init exec_front_end(user_terminal);
  init access_check(format, profile, user_terminal);
  init sysmsg1_operator(
         supervisor_common, format, oper_messages, sysmsg1_access,
	 aux_circuit_handler, logger_unit);

  standard.size := 8;
  standard.text := 'STANDARD        '
end (* initialize *) ;



(****************  main_host_message_commands_handler  ******************)
(*                                                              	*)
(*			    find_host_entry				*)
(*                                                              	*)
(*	Search the b_tree file for a given host entry.			*)
(*                                                              	*)
(************************************************************************)


procedure find_host_entry(
      message_name	: symbol;
      host		: host_index;
  var entry_page	: entry_page_index;
  var entry_index	: host_status_entry_index;
  var found		: boolean);

begin  
  host_status_common.search_entry(
    user, message_name, host, format, entry_page, entry_index, found)
end (* find_host_entry *) ;



(*****************  main_host_message_commands_handler  *****************)
(*									*)
(*		            set_host_entry				*)
(*									*)
(*	Set entry in the house keeping file for the specified host.	*)
(*									*)
(************************************************************************)


procedure set_host_entry(
      name	: symbol;
      host	: host_index);

const
  host_message_prompt = 'Enter message:(:13:)(:10:)\ ';

var
  message	: format_buffer;
  ok		: boolean;

begin
  exec_front_end.prompt_read_format_buffer(HOST_MESSAGE_PROMPT, message, ok);
  if ok
  then sysmsg1_operator.format_text(user_terminal, message, ok);
  if ok
  then
    begin
      host_status_common.update_entry(user, name, host, message, format, ok);
      if not ok
      then format.write_line(user_terminal)
      else host_status_common.release(user)
    end
end (* set_host_entry *) ;



(*****************  main_host_message_commands_handler  *****************)
(*                                                              	*)
(*			  run_set_host_message				*)
(*                                                              	*)
(*	For the listed host, set a  host status message to all  	*)
(*	Supervisors. Make entry in house keeping file if the 		*)
(*	message is set successfully to at least one Supervisor.		*)
(*                                                              	*)
(************************************************************************)



procedure run_set_host_message(
  name		: symbol;
  host		: host_index;
  clear_time	: integer);

var
  entry_page	: entry_page_index;
  entry_index	: host_status_entry_index;	
  s		: supervisor_index;
  message	: format_buffer;
  status	: sysmsg1_status;
  ok		: boolean;

begin
  if profile.license_check(MLTHST_LICENSE)
  then
    begin
      find_host_entry(name, host, entry_page, entry_index, ok);
      if not ok
      then 
	begin
	  set_host_entry(name, host);
	  find_host_entry(name, host, entry_page, entry_index, ok)
	end
    end
  else
    begin
      set_host_entry(STANDARD, host);
      find_host_entry(STANDARD, host, entry_page, entry_index, ok)
    end;

  if ok
  then
    begin
      if profile.license_check(MLTHST_LICENSE)
      then
	repeat
	  wait
	until host_status_common.cleared_host_msg_active(user, host, format);

      host_status_common.set_host_message(user, entry_page, entry_index,
	 clear_time, format, message, ok);
      if ok
      then
	for s := 0 to SUPERVISOR_LIMIT do
	  begin
	    sysmsg1_operator.send_host_status_message(
	      host, clear_time, s, message, status);
	    if status <> SYSMSG1_SUCCESSFUL
	    then format.string( ' TMCS will try again.\')
	    else
	      begin
		format.simple_message('Supervisor \');
		format.number(supervisor_common.host(s), 10);
		format.string( ' host message set\');
		host_status_common.set_set_state(
		  entry_page, entry_index, s)
	      end;
	    format.write_line(user_terminal)
	  end (* for *) ;
      host_status_common.release(user)
    end
end (* run_set_host_message *) ;

	

(****************  main_host_message_commands_handler  ******************)
(*									*)
(*			  run_set_host_timeout 				*)
(*									*)
(*	Change the clar time in the house keeping file.			*)
(*	This does not set message.     					*)
(*									*)
(************************************************************************)



procedure run_set_host_timeout(
  name		: symbol;
  host		: host_index;
  clear_time	: integer);

var
  entry_page	: entry_page_index;
  entry_index	: host_status_entry_index;
  ok		: boolean;

begin
  host_status_common.search_entry(
    user, name, host, format, entry_page, entry_index, ok);
  if not ok
  then format.write_line(user_terminal)
  else
    begin
      host_status_common.set_timeout(entry_page, entry_index, clear_time);
      host_status_common.release(user)
    end
end (* run_set_host_timeout *) ;



(****************  main_host_message_commands_handler  ******************)
(*									*)
(*		          clear_host_message 	                	*)
(*									*)
(*	Clear host status message for the host listed.			*)
(* 	After the host status message is successfully cleared from    	*)
(*	all supervisors of the network, clear entry in house keeping  	*)
(*	file.								*)
(*									*)
(************************************************************************)


procedure clear_host_message(
  operation	: clear_operation;
  host		: host_index;
  entry_page	: entry_page_index;
  entry_index	: host_status_entry_index);

var
  clear_time	: integer;
  clear_count	: integer;
  status	: sysmsg1_status;
  s		: supervisor_index;

begin
  clear_time  := realtime;
  clear_count := 0;
  host_status_common.set_timeout(entry_page, entry_index, clear_time);
  host_status_common.set_to_clearing(entry_page, entry_index);
  host_status_common.set_clear_state(entry_page, entry_index, operation);

  for s := 0 to SUPERVISOR_LIMIT do
    if host_status_common.clear_needed(entry_page, entry_index, s)
    then 
      begin
	sysmsg1_operator.clear_host_status_message(host, s, status);
	if status = SYSMSG1_SUCCESSFUL
	then
	  begin
	    host_status_common.set_operation_clear(entry_page, entry_index, s);
	    clear_count := clear_count+1;
	    format.simple_message('Supervisor \');
	    format.number(supervisor_common.host(s), 10);
	    format.string( ' host message cleared\')
	  end
	else format.string (' TMCS will try again.\');
	format.write_line(user_terminal)
      end
    else clear_count := clear_count+1;

  if clear_count = SUPERVISOR_MAX
  then 
    if operation = CLEAR_DELETE
    then host_status_common.delete_entry(host, entry_page, entry_index)
    else host_status_common.set_msg_inactive(entry_page, entry_index);

  host_status_common.release(user)
end (* clear_host_message *) ;



(****************  main_host_message_commands_handler  ******************)
(*									*)
(*		        run_clear_host_message 	                	*)
(*									*)
(*	Clear host status message for the host listed.			*)
(*									*)
(************************************************************************)



procedure run_clear_host_message(host : host_index);

const
  clear_host_message_prompt = 'Do you want message saved \ ';

var
  operation	: clear_operation;
  save_message	: boolean;
  entry_name	: symbol;
  entry_page	: entry_page_index;
  entry_index	: host_status_entry_index;	
  found		: boolean;

begin
  operation := CLEAR_DELETE;

  if profile.license_check(MLTHST_LICENSE)
  then
    begin
      save_message := 
	command_scan.input_answer(profile, CLEAR_HOST_MESSAGE_PROMPT);
      if save_message
      then operation := CLEAR_SAVE
      else operation := CLEAR_DELETE
    end;

  host_status_common.search_active_entry(
    user, host, format, entry_name, entry_page, entry_index, found);

  if found 
  then
    if (profile.license_check(HST_LICENSE) and (entry_name = STANDARD))
      or profile.license_check(MLTHST_LICENSE)
    then clear_host_message(operation, host, entry_page, entry_index)
end (* run_clear_host_message *) ;



(*****************  main_host_message_commands_handler  *****************)
(*									*)
(*		         run_clear_host_entry				*)
(*									*)
(*	Clear entry in the house keeping file for the host		*)
(*	scanned.							*)
(*									*)
(************************************************************************)



procedure run_clear_host_entry(
  name	: symbol;
  host	: host_index);

var
  entry_page	: entry_page_index;
  entry_index	: host_status_entry_index;	
  ok		: boolean;

begin
  find_host_entry(name, host, entry_page, entry_index, ok);
  if ok
  then
    begin
      host_status_common.delete_entry(host, entry_page, entry_index);
      host_status_common.release(user)
    end
  else format.write_line(user_terminal)
end (* run_clear_host_entry *) ;



(****************  main_host_message_commands_handler  ******************)
(*                                                                    	*)
(*		        scan_identifier_and_name		    	*)
(*                                                                   	*)
(*      Scan the message identifier.	      	      		    	*)
(*                                                                      *)
(************************************************************************)



procedure scan_identifier_and_name(
        keyword: command_keyword_index;
    var scanned: scanned_command;
    var name   : symbol);

begin
  if argument_scan.check_keyword(keyword, scanned)
  then argument_scan.keyword_symbol(keyword, scanned, name)
  else scanned.status := ARG_MISSING
end (* scan_identifier_and_name *) ;


(****************  main_host_message_commands_handler  ****************)
(*                                                                    *)
(*		        scan_set_host_entry			      *)
(*                                                                    *)
(*      Scan the set host entry command.			      *)
(*      Format is:  SET HOST ENTRY <host_index> IDENTIFIER <name>     *)
(*                                                                    *)
(**********************************************************************)


procedure entry scan_set_host_entry(var scanned: scanned_command);

var
  message_name	: symbol;
  host      	: host_index;

begin
  if not profile.license_check(MLTHST_LICENSE)
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then argument_scan.freeword_host(0, scanned, host);

  if scanned.status = CMD_OK
  then scan_identifier_and_name(
    MAIN_SET_IDENTIFIER_KEYWORD, scanned, message_name);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then 
    if access_check.host_access_check(host)
    then set_host_entry(message_name, host)
end (* scan_set_host_entry *) ;



(****************  main_host_message_commands_handler  ****************)
(*                                                                    *)
(*		       scan_time_and_host_index			      *)
(*                                                                    *)
(*      Scan the time if there is one and the host_index.	      *)
(*                                                                    *)
(**********************************************************************)



procedure scan_time_and_host_index(
    var scanned: scanned_command;
    var host   : host_index;
    var time   : integer);

var
  freeword_offset: command_freeword_index;

begin
  freeword_offset := 0;

  if argument_scan.check_keyword(MAIN_SET_TO_KEYWORD, scanned)
  then
    begin
      argument_scan.freeword_date_and_time(0, profile, scanned, time);
      freeword_offset := 2;
      if scanned.status = CMD_OK
      then
	if time <= realtime
	then scanned.status := DATE_IN_PAST
    end
  else time := MAX_INTEGER;
      
  if scanned.status = CMD_OK
  then argument_scan.freeword_host(freeword_offset, scanned, host)
end (* scan_time_and_host_index *) ;



(****************  main_host_message_commands_handler  ******************)
(*                                                                    	*)
(*		       scan_set_host_message			      	*)
(*                                                                    	*)
(*      Scan the set host message command.			      	*)
(*      User with HST license, format is:  				*)
(*	  SET HOST MESSAGE [TO <time>] <host_index>	      		*)
(*	User with MLTHST license, format is:				*)
(*        SET HOST MESSAGE [TO <time>] <host_index> 			*)
(*	  IDENTIFIER <message_name>					*)
(*									*)
(************************************************************************)



procedure entry scan_set_host_message(var scanned: scanned_command);

var
  clear_time	: integer;
  host	        : host_index;
  message_name	: symbol;

begin
  if scanned.status = CMD_OK
  then scan_time_and_host_index(scanned, host, clear_time);

  if scanned.status = CMD_OK
  then 
    if profile.license_check(MLTHST_LICENSE)
    then scan_identifier_and_name(
      MAIN_SET_IDENTIFIER_KEYWORD, scanned, message_name)
    else if profile.license_check(HST_LICENSE)
    then message_name := standard
    else scanned.status := AUTH_ERROR;

  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    if access_check.host_access_check(host)
    then run_set_host_message(message_name, host, clear_time)
end (* scan_set_host_message *) ;



(****************  main_host_message_commands_handler  ******************)
(*                                                                      *)
(*		       scan_set_timeout_command			        *)
(*                                                                      *)
(*      Scan the set timeout command.				        *)
(*      For the user has HST license, format is:  			*)
(*	  SET HOST TIMEOUT [TO <time>] <host_index>	        	*)
(*	For the user has MLTMSG license, format is:			*)
(*	  SET HOST TIMEOUT [TO <time>] <host_index> 			*)
(*	  IDENTIFIER <message_name>					*)
(*                                                                      *)
(************************************************************************)


procedure entry scan_set_timeout_command(var scanned: scanned_command);

var 
  clear_time	: integer;
  host      	: host_index;
  message_name	: symbol;

begin
  argument_scan.require_keyword(MAIN_SET_HOST_KEYWORD, scanned);

  if scanned.status = CMD_OK
  then scan_time_and_host_index(scanned, host, clear_time);

  if scanned.status = CMD_OK
  then
    if profile.license_check(MLTHST_LICENSE)
    then scan_identifier_and_name(
      MAIN_SET_IDENTIFIER_KEYWORD, scanned, message_name)
    else if profile.license_check(HST_LICENSE)
    then message_name := standard
    else scanned.status := AUTH_ERROR;

  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    if access_check.host_access_check(host)
    then run_set_host_timeout(message_name, host, clear_time)
end (* scan_set_timeout_command *) ;



(****************  main_host_message_commands_handler  ****************)
(*                                                                    *)
(*		       scan_clear_host_message			      *)
(*                                                                    *)
(*      Scan the clear host message.				      *)
(*      Format is:  CLEAR HOST MESSAGE <host_index>	              *)
(*                                                                    *)
(**********************************************************************)


procedure entry scan_clear_host_message(var scanned: scanned_command);

var
  host: host_index;

begin
  if not (profile.license_check(HST_LICENSE) or profile.license_check(MLTHST_LICENSE))
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then argument_scan.freeword_host(0, scanned, host);

  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then 
    if access_check.host_access_check(host)
    then run_clear_host_message(host)
end (* scan_clear_host_message *) ;



(*****************  main_host_message_commands_handler  *****************)
(*                                                                      *)
(*		       scan_clear_host_entry			        *)
(*                                                                      *)
(*      Scan the clear host entry.				        *)
(*      User has only HST license, command format is			*)
(*	  CLEAR HOST ENTRY <host_index>	      	        		*)
(*	User has MLTHST lisense, command format is			*)
(*	  CLEAR HOST ENTRY <host_index> IDENTIFIER <message_name>	*)
(*                                                                      *)
(************************************************************************)



procedure entry scan_clear_host_entry(var scanned: scanned_command);

var
  host		: host_index;
  message_name	: symbol;

begin
  if profile.license_check(MLTHST_LICENSE)
  then scan_identifier_and_name(
    MAIN_CLEAR_IDENTIFIER_KEYWORD, scanned, message_name)
  else if profile.license_check(HST_LICENSE)
  then message_name := standard
  else scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then argument_scan.freeword_host(0, scanned, host);

  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    if access_check.host_access_check(host)
    then run_clear_host_entry(message_name, host)
end (* scan_clear_host_entry *) ;



(****************  main_host_message_commands_handler  ****************)
(*								      *)
(*			run_list_host_message			      *)
(*								      *)
(*	Display the listed host status message from supervisor.	      *)
(*								      *)
(**********************************************************************)



procedure run_list_host_message(
      host	: host_index; 
  var s		: supervisor_index);

begin
  sysmsg1_operator.list_host_status_message(user_terminal, host, s)
end (* run_list_host_message *) ;



(****************  main_host_message_commands_handler  ****************)
(*								      *)
(*   		        scan_list_message_command	 	      *)
(*								      *)
(*    Scan LIST HOST MESSAGE SUPERVISOR <sup#> <host_index>	      *)
(*								      *)
(**********************************************************************)


procedure entry scan_list_message_command(var scanned: scanned_command);

var
  sup : supervisor_index;
  host: host_index;

begin
  argument_scan.require_keyword(MAIN_LIST_SUPERVISOR_KEYWORD, scanned);

  argument_scan.require_keyword(MAIN_LIST_HOST_KEYWORD, scanned);

  if scanned.status = CMD_OK
  then argument_scan.freeword_supervisor_number(0, scanned, sup);
  
  if scanned.status = CMD_OK
  then argument_scan.freeword_host(1, scanned, host);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    if access_check.host_access_check(host)
    then run_list_host_message(host, sup)
end (* scan_list_message_command *) ;



(****************  main_host_message_commands_handler  ******************)
(*									*)
(*			  run_list_host_entry				*)
(*									*)
(************************************************************************)	


procedure run_list_host_entry(
  var scanned	: scanned_command);

var
  name		: symbol;
  host		: host_index;
  display_text	: boolean;
  mult_message	: boolean;
  ok		: boolean;

begin
  argument_scan.freeword_host(0, scanned, host);

  if access_check.host_access_check(host)
  then
    begin
      display_text := argument_scan.check_keyword(
	MAIN_LIST_TEXT_KEYWORD, scanned);
      mult_message := FALSE;

      if profile.license_check(MLTHST_LICENSE)
      then
	if argument_scan.check_keyword (MAIN_LIST_IDENTIFIER_KEYWORD, scanned)
	then
	  scan_identifier_and_name(MAIN_LIST_IDENTIFIER_KEYWORD, scanned, name)
	else mult_message := TRUE
      else name := standard;

      argument_scan.extra_argument_check(scanned);

      if scanned.status = CMD_OK
      then 
	begin
	  if mult_message
	  then host_status_common.list_host_entries(
	    host, profile, response_buffer, format, display_text, ok)
	  else host_status_common.list_entry(
	    name, host, profile, response_buffer, format, display_text, ok);
	  if not ok
	  then format.write_line(user_terminal)
	end
    end
end (* run_list_host_entry *) ;



(****************  main_host_message_commands_handler  ******************)
(*                                                                      *)
(*			scan_list_host_entry			        *)
(*                                                                      *)
(*    Scan LIST HOST ENTRY [<host_index>][IDENTIFIER <message_name>]	*)
(*	   [TEXT]							*)
(*                                                                      *)
(************************************************************************)


procedure entry scan_list_host_entry(var scanned: scanned_command);

var
  host		: host_index;
  display_text	: boolean;
  ok		: boolean;

begin
  response_buffer.start_put;
  if scanned.freeword_count > 0
  then run_list_host_entry(scanned)
  else
    begin
      display_text := argument_scan.check_keyword(
	MAIN_LIST_TEXT_KEYWORD, scanned);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then host_status_common.list_sorted_entries(
	profile, response_buffer, format, display_text)
    end;

  if user_terminal.sendable
  then response_buffer.print(user_terminal)
end (* scan_list_host_entry *) ;




(****************  main_host_message_commands_handler  ****************)
(**********************************************************************)


begin (* initial statement *)
  initialize
end   (* main_host_message_commands_handler *) ;
    !
(************************************************************************)
(*                                                              	*)
(*      NAMEXE.TMS Updated 29-Jul-87 at 3:50 by Raffo			*)
(*                                                              	*)
(*			main_name_command_handler			*)
(*                                                              	*)
(*	This class handles all commands monitoring the data base	*)
(*	in name_common.							*)
(*                                                              	*)
(*	The following identifiers must be defined externally:		*)
(*                                                              	*)
(************************************************************************)
(*                                                              	*)
(*                         Revision Record				*)
(*                                                              	*)
(*	20Jan86 Original -- gde						*)
(*                                                              	*)
(************************************************************************)


type
  main_name_command_handler =
    class (
      user_terminal	   : circuit_handler;
      format		   : internal_to_string;
      profile		   : user_profile;
      argument_scan	   : argument_scanner;
      host_location_common : global_host_location_data;
      name_common	   : global_name_data;
      node_file	   	   : node_buffer;
$ifany (xray, ddt)
      node_list		   : node_list_manager;
$endif
      response_buffer	   : text_buffer
    );

var
  access_check		   : user_access_checker;
  host_operator		   : host_utility;
  node_operator		   : node_utility;

(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		          initialize					*)
(*									*)
(*									*)
(************************************************************************)


procedure initialize;

begin
  init access_check(format, profile, user_terminal);
  init host_operator, node_operator
end (* initialize *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_set_location_command				*)
(*									*)
(*      Scan the set location command.					*)
(*      Format is:   							*)
(*        SET HOST LOCATION <host_index> <node_index> [<position>]	*)
(*									*)
(************************************************************************)



procedure entry scan_set_location_command(var scanned: scanned_command);

var
  host    : host_index;
  node    : node_index;
  position: integer;

begin
  if not argument_scan.check_keyword(MAIN_SET_HOST_KEYWORD, scanned)
  then scanned.status := ARG_MISSING;

  if scanned.status = CMD_OK
  then argument_scan.freeword_host(0, scanned, host);
  
  if scanned.status = CMD_OK
  then argument_scan.freeword_node(1, scanned, node);

  if scanned.status = CMD_OK
  then
    if scanned.freeword_count > 2
    then argument_scan.freeword_host_position (2, scanned, position)
    else position := 0;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    if access_check.node_access_check(node)
    then 
      if access_check.host_access_check(host)
      then host_location_common.set_host_location (host, node, position)
end (* scan_set_location_command *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_name_and_name				*)
(*									*)
(*      Scan the set name command.					*)
(*									*)
(************************************************************************)

procedure scan_name_and_name(
      keyword	: command_keyword_index;
  var scanned	: scanned_command;
  var name	: symbol);

begin
  if argument_scan.check_keyword(keyword, scanned)
  then argument_scan.keyword_symbol(keyword, scanned, name)
  else scanned.status := ARG_MISSING
end (* scan_name_and_name *) ;


(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_set_node_name				*)
(*									*)
(*      Scan the set node name command.					*)
(*      Format is:   SET NODE <node#> NAME <node_name>			*)
(*									*)
(************************************************************************)



procedure scan_set_node_name(var scanned: scanned_command);

var
  node       : node_index;
  node_symbol: symbol;

begin
  if scanned.status = CMD_OK
  then argument_scan.freeword_node(0, scanned, node);

  if scanned.status = CMD_OK
  then scan_name_and_name(MAIN_SET_NAME_KEYWORD, scanned, node_symbol);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then 
    if access_check.node_access_check(node)
    then 
      if name_common.set_node_name(node, node_symbol)
      then node_file.name_change(node)
      else user_terminal.write_message('Node name table full\ ')
end (* scan_set_node_name *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_set_host_name				*)
(*									*)
(*      Scan the set host name command.					*)
(*      Format is:   SET HOST <host#> NAME <host_name>			*)
(*									*)
(************************************************************************)



procedure scan_set_host_name(var scanned: scanned_command);

var
  host       : host_index;
  host_symbol: symbol;

begin
  if scanned.status = CMD_OK
  then argument_scan.freeword_host(0, scanned, host);

  if scanned.status = CMD_OK
  then scan_name_and_name(MAIN_SET_NAME_KEYWORD, scanned, host_symbol);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then 
    if access_check.host_access_check(host)
    then 
      if not name_common.set_host_name(host, host_symbol)
      then user_terminal.write_message('Host name table full\ ')
end (* scan_set_host_name *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_set_product_name				*)
(*									*)
(*      Scan the set product name command.				*)
(*      Format is:   SET PRODUCT <product_index> NAME <product_name>	*)
(*									*)
(************************************************************************)



procedure scan_set_product_name(var scanned: scanned_command);

var
  product       : product_index;
  product_symbol: symbol;

begin
  if scanned.status = CMD_OK
  then argument_scan.freeword_product(0, scanned, product);

  if scanned.status = CMD_OK
  then scan_name_and_name(MAIN_SET_NAME_KEYWORD, scanned, product_symbol);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then name_common.set_product_name(product, product_symbol)
end (* scan_set_product_name *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		             scan_set_name				*)
(*									*)
(*      Scan the set name command.			      		*)
(*									*)
(************************************************************************)



procedure entry scan_set_name(var scanned: scanned_command);

var 
  keyword: command_keyword_index;

begin
  if not profile.license_check(SETN_LICENSE)
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then
    argument_scan.find_keyword (
      MAIN_SET_NODE_KEYWORD, MAIN_SET_PRODUCT_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then
    case keyword of

      MAIN_SET_NODE_KEYWORD:
	scan_set_node_name(scanned);

      MAIN_SET_HOST_KEYWORD:
	scan_set_host_name(scanned);

      MAIN_SET_PRODUCT_KEYWORD:
	scan_set_product_name(scanned)

    end (* case *)
end (* scan_set_name *) ;

  

(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		     scan_clear_location_command			*)
(*									*)
(*      Scan the clear location command.				*)
(*      Format is:							*)
(*         CLEAR HOST LOCATION <host_index><node_index>			*)
(*									*)
(************************************************************************)



procedure entry scan_clear_location_command(var scanned: scanned_command);

var
  host    : host_index;
  node    : node_index;

begin
  if not argument_scan.check_keyword(MAIN_CLEAR_HOST_KEYWORD, scanned)
  then scanned.status := ARG_MISSING;

  if scanned.status = CMD_OK
  then argument_scan.freeword_host(0, scanned, host);
  
  if scanned.status = CMD_OK
  then argument_scan.freeword_node(1, scanned, node);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    if access_check.node_access_check(node)
    then 
      if access_check.host_access_check(host)
      then
	begin
  	  response_buffer.start_put;
	  host_location_common.clear_host_location (
	    host, node, response_buffer);
	  response_buffer.print(user_terminal)
	end
end (* scan_clear_location_command *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_clear_node_name				*)
(*									*)
(*      Scan the clear node name command.				*)
(*      Format is:   CLEAR NODE NAME <node#>        			*)
(*									*)
(************************************************************************)



procedure scan_clear_node_name(var scanned: scanned_command);

var
  node       : node_index;
  node_symbol: symbol;

begin
  argument_scan.freeword_node(0, scanned, node);

  node_symbol.size := 0;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then 
    if access_check.node_access_check(node)
    then 
      if name_common.set_node_name(node, node_symbol)
      then node_file.name_change(node)
      else user_terminal.write_message('Node name table full\ ')
end (* scan_clear_node_name *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_clear_host_name				*)
(*									*)
(*      Scan the clear host name command.				*)
(*      Format is:   CLEAR HOST NAME <host#> 				*)
(*									*)
(************************************************************************)


procedure scan_clear_host_name(var scanned: scanned_command);

var
  host       : host_index;
  host_symbol: symbol;

begin
  argument_scan.freeword_host(0, scanned, host);

  host_symbol.size := 0;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then 
    if access_check.host_access_check(host)
    then 
      if not name_common.set_host_name(host, host_symbol)
      then user_terminal.write_message('Host name table full\ ')
end (* scan_clear_host_name *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_clear_product_name				*)
(*									*)
(*      Scan the clear product name command.				*)
(*      Format is:   CLEAR PRODUCT NAME <product_index> 		*)
(*									*)
(************************************************************************)



procedure scan_clear_product_name(var scanned: scanned_command);

var
  product       : product_index;
  product_symbol: symbol;

begin
  argument_scan.freeword_product(0, scanned, product);

  product_symbol.size := 0;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then name_common.set_product_name(product, product_symbol)
end (* scan_clear_product_name *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		             scan_clear_name				*)
(*									*)
(*      Scan the clear name command.			      		*)
(*									*)
(************************************************************************)



procedure entry scan_clear_name(var scanned: scanned_command);

var 
  keyword: command_keyword_index;

begin
  if not profile.license_check(SETN_LICENSE)
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then
    argument_scan.find_keyword(MAIN_CLEAR_NODE_KEYWORD, 
      MAIN_CLEAR_PRODUCT_KEYWORD, scanned, keyword);

  if scanned.status = CMD_OK
  then
    case keyword of

      MAIN_CLEAR_NODE_KEYWORD:
	scan_clear_node_name(scanned);

      MAIN_CLEAR_HOST_KEYWORD:
	scan_clear_host_name(scanned);

      MAIN_CLEAR_PRODUCT_KEYWORD:
	scan_clear_product_name(scanned)

    end (* case *)
end (* scan_clear_name *) ;

  
(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_list_location_command			*)
(*									*)
(*      Scan the list location command.					*)
(*      Format is:							*)
(*         LIST HOST LOCATION [<host_range_list>]			*)
(*									*)
(************************************************************************)



procedure entry scan_list_location_command(
    var scanned: scanned_command);

var
  hosts_to_list: host_set;

begin
  if not argument_scan.check_keyword(MAIN_LIST_HOST_KEYWORD, scanned)
  then scanned.status := ARG_MISSING;

  response_buffer.start_put;

  if scanned.freeword_count > 0
  then
    begin
      argument_scan.freeword_host_set(0, scanned, hosts_to_list);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	host_location_common.put_host_location(
	  hosts_to_list, profile, response_buffer)
    end
  else
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	host_location_common.put_all_host_location(response_buffer)
    end;

  if scanned.status = CMD_OK
  then response_buffer.print(user_terminal)
end (* scan_list_location_command *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      	 scan_list_host_name				*)
(*									*)
(*      Scan the list host name command.				*)
(*      Format is:							*)
(*         LIST HOST NAME [<host_range_list>]				*)
(*									*)
(************************************************************************)



procedure scan_list_host_name(var scanned: scanned_command);

var
  hosts_to_list	: host_set;
  host		: host_index;
  name		: symbol;
  found		: boolean;

begin
  found := FALSE;
  if scanned.freeword_count > 0
  then argument_scan.freeword_host_set(0, scanned, hosts_to_list)
  else host_operator.set_full(hosts_to_list);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    for host := 0 to HOST_LIMIT do
      if host_operator.check(host, hosts_to_list)
      then
	if profile.host_access_check(host)
	then
	  begin
	    name_common.get_host_name(host, name);
	    if name.size > 0
	    then
	      begin
		if not found
		then
		  begin
		    format.simple_message ('Host  Name\ ');
		    format.newline;
		    format.string ('----  ----\ ');
		    format.write_line(user_terminal);
		    found := TRUE
		  end;
		format.start;
		format.host_number(host);
		format.skip_to(6);
		format.symbol_string(name);
		format.write_line(user_terminal)
	      end
	  end (* for *)
end (* scan_list_host_name *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      	 scan_list_node_name				*)
(*									*)
(*      Scan the list node name command.				*)
(*      Format is:							*)
(*         LIST NODE NAME [<node_range_list>]				*)
(*									*)
(************************************************************************)



procedure scan_list_node_name(var scanned: scanned_command);

var
  nodes_to_list	: node_set;
  node	        : node_index;
  name		: symbol;
  found		: boolean;

begin
  found := FALSE;
  if scanned.freeword_count > 0
  then argument_scan.freeword_node_set(0, scanned, nodes_to_list)
  else node_operator.set_full(nodes_to_list);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    for node := 0 to NODE_LIMIT do
      if node_operator.check(node, nodes_to_list)
      then
	if profile.node_access_check(node)
	then
	  begin
	    name_common.get_node_name(node, name);
	    if name.size > 0
	    then
	      begin
		if not found
		then
		  begin
		    format.simple_message ('Node  Name\ ');
		    format.newline;
		    format.string ('----  ----\ ');
		    format.write_line(user_terminal);
		    found := TRUE
		  end;
		format.start;
		format.node_number(node);
		format.skip_to(6);
		format.symbol_string(name);
		format.write_line(user_terminal)
	      end
	  end (* for *)
end (* scan_list_node_name *) ;




(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      	 scan_list_product_name				*)
(*									*)
(*      Scan the list product name command.				*)
(*      Format is:							*)
(*         LIST PRODUCT NAME [<product_range_list>]			*)
(*									*)
(************************************************************************)



procedure scan_list_product_name(var scanned: scanned_command);

var
  products_to_list	: product_set;
  product		: product_index;
  name			: symbol;
  found			: boolean;

begin
  found := FALSE;
  products_to_list := [];
  
  if scanned.freeword_count > 0
  then argument_scan.freeword_product_set(0, scanned, products_to_list)
  else 
    for product := 0 to PRODUCT_LIMIT do
      products_to_list := products_to_list or [product];

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    for product := 0 to PRODUCT_LIMIT do
      if product in products_to_list
      then
	begin
	  name_common.get_product_name(product, name);
	  if name.size > 0
	  then
	    begin
	      if not found
	      then
		begin
		  format.simple_message ('Id  Name\ ');
		  format.newline;
		  format.string ('--  ----\ ');
		  format.write_line (user_terminal);
		  found:= TRUE
		end;
	      format.start;
	      format.number(product, 16);
	      format.skip_to(4);
	      format.symbol_string(name);
	      format.write_line(user_terminal)
	    end
      	end (* for *)
end (* scan_list_product_name *) ;



(************************************************************************)
(*									*)
(*		      scan_list_name_command				*)
(*									*)
(*      Scan the list name command.					*)
(*									*)
(************************************************************************)



procedure entry scan_list_name_command(var scanned: scanned_command);

var
  keyword: command_keyword_index;

begin
  argument_scan.find_keyword(MAIN_LIST_PRODUCT_KEYWORD,
    MAIN_LIST_HOST_KEYWORD, scanned, keyword);
  if scanned.status = CMD_OK
  then
    case keyword of 

      MAIN_LIST_PRODUCT_KEYWORD:
	scan_list_product_name(scanned);      

      MAIN_LIST_NODE_KEYWORD:
	scan_list_node_name(scanned);      

      MAIN_LIST_HOST_KEYWORD:
	scan_list_host_name(scanned)

    end (* case *)
end (* scan_list_name_command *) ;


$ifany (xray, ddt)
(*******************  main_name_commands_handler  *************************)
(*									*)
(*				new_node				*)
(*									*)
(*	Display node ranges of available nodes ( host <> NO_HOST)	*)
(*									*)
(**************************************************************************)


procedure new_node(
      node         : integer;
  var first_node   : integer;
  var found        : boolean;
      no_host_node : boolean);

begin
  if no_host_node
  then
    begin
      found := FALSE;
      if format.buffer.pointer > 63 (* line must not be too long *)
      then
        begin
	  if user_terminal.sendable
	  then format.write_line(user_terminal);
	  format.start
	end;
      format.skip(1);
      format.number_range(node_operator.decode(first_node),
	node_operator.decode(node-1), 8)
    end
  else
    if not found
    then
      begin
        found := TRUE;
	first_node := node
      end
end (* new_node *) ;



(*******************  main_name_commands_handler  *************************)
(*									*)
(*				display_node				*)
(*									*)
(*	Display a node and hst number to the terminal.            	*)
(*									*)
(**************************************************************************)


procedure display_node(
  node : integer;
  host : integer);

begin
  format.start;
  if host <> NO_HOST
  then
    begin
      format.string('Kernel of node \');
      format.format_number(node_operator.decode(node), 8, 4);
      format.string(' is host \');
      format.number(host, 10);
    end
  else 
    begin
      format.format_number(node_operator.decode(node), 8, 4);
      format.string(' is not a node\ ');
    end;
  if user_terminal.sendable
  then format.write_line(user_terminal);
  format.start
end (* display_node *) ;



(*******************  main_name_commands_handler  *************************)
(*									*)
(*			display_all_nodes				*)
(*									*)
(*	Display all nodes in XRAY data base with host number.		*)
(*									*)
(**************************************************************************)


procedure display_all_nodes(numbers: boolean);

var
  host_page : integer_page;
  xf_status : xray_status;
  i,j       : integer;
  found,last: boolean;
  first_node: integer;

begin  
  found := FALSE;
  format.start;
  i := 0;
  xf_status := XRAY_OK;

  while (i < HOST_ALLOCATION) and (xf_status = XRAY_OK)  
      				and not user_terminal.break_pending do
    begin
      node_list.find_host_page(i, xf_status, host_page);
      if xf_status = XRAY_OK
      then
        for j := 0 to INTEGER_PAGE_LIMIT do
	  if host_page[j] <> NO_HOST
	  then
	    if numbers
	    then new_node(i*INTEGER_PAGE_MAX+j, first_node, found, FALSE)
	    else display_node(i*INTEGER_PAGE_MAX+j, host_page[j])
          else
	    if numbers and found
	    then new_node(i*INTEGER_PAGE_MAX+j, first_node, found, TRUE)
	    else (* empty *)
      else
       if user_terminal.sendable
       then user_terminal.write_string('File error(:13:)(:10:)\ ');
      i := i +1
    end;

  if user_terminal.sendable
  then format.write_line(user_terminal)
end (* display_all_nodes *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_list_kernel_node				*)
(*									*)
(*      Scan the list kernel node.					*)
(*									*)
(************************************************************************)



procedure scan_list_kernel_node(var scanned: scanned_command);


var
  nodes  : node_set;
  node   : node_index;
  host   : host_index;


begin
  argument_scan.freeword_node_set(0, scanned, nodes);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    for node := 0 to NODE_LIMIT do
      if node_operator.check(node, nodes)
      then
	begin
	  node_list.find_host(host, node, scanned);
	  display_node(node, host)
	end
end (* scan_list_kernel_node *) ;


(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_list_kernel					*)
(*									*)
(*      Scan the list kernel.						*)
(*									*)
(************************************************************************)



procedure scan_list_kernel(var scanned: scanned_command);


var
  numbers: boolean;

begin
  numbers := argument_scan.check_keyword(MAIN_LIST_NUMBERS_KEYWORD, scanned);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then display_all_nodes(numbers)
end (* scan_list_kernel *) ;




(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_list_kernel_command				*)
(*									*)
(*      Scan the list kernel command. Format are:			*)
(*            LIST KERNEL NODE <node_set>				*)
(*	      LIST KERNEL  [NUMBERS]					*)
(*									*)
(************************************************************************)



procedure entry scan_list_kernel_command(var scanned: scanned_command);


begin
  if argument_scan.check_keyword(MAIN_LIST_NODE_KEYWORD, scanned)
  then scan_list_kernel_node(scanned)
  else scan_list_kernel(scanned)
end (* scan_list_kernel_command *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_set_kernel_command				*)
(*									*)
(*      Scan the set kernel command. Format is:				*)
(*        SET KERNEL <host> NODE <node_set>				*)
(*									*)
(************************************************************************)



procedure entry scan_set_kernel_command(var scanned: scanned_command);

var
  host: host_index;
  node: node_index;
  first_node: node_index;
  last_node : node_index;

begin
  argument_scan.keyword_host(MAIN_SET_KERNEL_KEYWORD, scanned, host);

  if scanned.status = CMD_OK
  then
    if not argument_scan.check_keyword(MAIN_SET_NODE_KEYWORD, scanned)
    then scanned.status := ARG_KEYWORD_MISSING;

  if scanned.status = CMD_OK
  then argument_scan.freeword_node_pair(0, scanned, first_node, last_node);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    for node := first_node to last_node do 
      node_list.modify_host(host+node-first_node, node)
end (* scan_set_kernel_command *) ;



(*******************  main_name_commands_handler  ***********************)
(*									*)
(*		      scan_clear_kernel_command				*)
(*									*)
(*      Scan the clear kernel command. Format is:			*)
(*        CLEAR KERNEL NODE <node_set>			      		*)
(*									*)
(************************************************************************)


procedure entry scan_clear_kernel_command(var scanned: scanned_command);

var
  node: node_index;
  nodes: node_set;

begin
  if not argument_scan.check_keyword(MAIN_CLEAR_NODE_KEYWORD, scanned)
  then scanned.status := ARG_KEYWORD_MISSING;

  if scanned.status = CMD_OK
  then argument_scan.freeword_node_set(0, scanned, nodes);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    for node := 0 to NODE_LIMIT do
      if node_operator.check(node, nodes)
      then node_list.modify_host(NO_HOST, node)
end (* scan_clear_kernel_command *) ;
$endif any xray ddt



(*******************  main_name_commands_handler  ***********************)
(************************************************************************)


begin (* initial statement *)
  initialize
end (* main_name_command_handler *) ;
!
(**********************************************************************)
(*                                                                    *)
(*     OPEEXE.TMS                                                     *)
(*                                                                    *)
(*		main_operator_command_handler			      *)
(*                                                                    *)
(*	This class handles all operator's commands		      *)
(*                                                                    *)
(*	The following identifiers must be defined externally:	      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                         Revision Record			      *)
(*                                                                    *)
(*	20Jan86 Original -- gde					      *)
(*                                                                    *)
(**********************************************************************)



type
  main_operator_command_handler =
    class (
      user		: user_index;
      statistics	: statistics_gatherer;
      node_file		: node_buffer;
      host_file		: host_buffer;
      link_file		: link_buffer;
      port_file		: port_buffer;
      host_location_common: global_host_location_data;
      argument_scan	: argument_scanner;
$if alarm
      alarmer		: alarm_execution;
$endif alarm
$if reload
      reloader		: reload_execution;
      reload_file	: reload_control;
      host_slot_file	: host_slot_buffer;
      kernel_file	: kernel_buffer;
$endif reload
$ifany (reload, xcom)
      slot_file		: slot_buffer;
$endif any reload xcom
$if background
      job_status	: job_status_control;
      job_common	: global_job_data;
      response_buffer	: text_buffer;
$endif background
      misc_common	: miscellaneous_data;
      network_common	: network_state_description;
      host_status_common: global_host_status_data;
      user_terminal	: circuit_handler;
      format		: internal_to_string
  );



$if background
(******************  main_operator_command_handler  *******************)
(*                                                                    *)
(*        	     scan_set_background_command                      *)
(*                                                                    *)
(*    Scan the set background command.Format is:		      *)
$if alarm
(*	SET BACKGROUND <user_index> <username> ALARM    	      *)
$endif alarm
$if reload
(*      SET BACKGROUND <user_index> <username> RELOAD		      *)
$endif reload
(*                                                                    *)
(**********************************************************************)



procedure entry scan_set_background_command(var scanned: scanned_command);

var
  background_user: user_index;
  background_job : job_descriptor;

begin
  argument_scan.freeword_background_user(0, scanned, background_user);

  if scanned.status = CMD_OK
  then argument_scan.freeword_symbol(1, scanned, background_job.username);

  if scanned.status = CMD_OK
  then 
$if alarm
    if argument_scan.check_keyword(MAIN_SET_ALARM_KEYWORD, scanned)
    then background_job.state := JOB_ALARM
    else
$endif alarm
$if reload
      if argument_scan.check_keyword(MAIN_SET_RELOAD_KEYWORD, scanned)
      then background_job.state := JOB_RELOAD
      else
$endif reload
	scanned.status := ARG_MISSING;

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then job_common.set_background(background_user, background_job)
end (* scan_set_background_command *) ;
$endif background



(*********************  main_operator_command_handler  ****************)
(*                                                                    *)
(*                scan_set_clear_daylightsavings_command	      *)
(*                                                                    *)
(*     Scan the set and clear daylightsavings command.		      *)
(*        SET DAYLIGHTSAVINGS					      *)
(*   	  CLEAR DAYLIGHTSAVINGS					      *)
(*                                                                    *)
(**********************************************************************)


procedure entry scan_set_clear_daylightsavings_command(
    var scanned: scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then misc_common.set_daylight_savings(scanned.command = MAIN_SET)
end (* scan_set_clear_daylightsavings_command *) ;



(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                    scan_set_display_command			      *)
(*                                                                    *)
(*      Scan the set display  command. Format is:		      *)
(*	SET DISPLAY <display_interval>				      *)
(*                                                                    *)
(**********************************************************************)


procedure entry scan_set_display_command(var scanned: scanned_command); 
  
var
  rate: integer;

begin
  argument_scan.keyword_number(MAIN_SET_DISPLAY_KEYWORD, 10, scanned, rate);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then network_common.set_display_interval(rate)
end (* scan_set_display_command *) ;


$if background
(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                    scan_clear_background_command		      *)
(*                                                                    *)
(*      Scan the clear background  command. Format is:		      *)
(*	CLEAR BACKGROUND <Background_user>			      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_clear_background_command(var scanned: scanned_command);

var
  background_user: user_index;

begin
  argument_scan.freeword_background_user(0, scanned, background_user);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then job_common.clear_background(background_user)
end (* scan_clear_background_command *) ;
$endif background



(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                     scan_clear_display_command		      *)
(*                                                                    *)
(*      Scan the clear display  command. Format is:		      *)
(*	CLEAR DISPLAY						      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_clear_display_command(var scanned: scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then network_common.clear_display_interval
end (* scan_clear_display_command *) ;



$if background
(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                    scan_list_background_command		      *)
(*                                                                    *)
(*      Scan the list background  command. Format is:		      *)
(*	LIST BACKGROUND 					      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_list_background_command(
    var scanned: scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      response_buffer.start_put;
      job_common.list_background(response_buffer, format);
      response_buffer.print(user_terminal)
    end
end (* scan_list_background_command *) ;
$endif 

(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                  scan_list_daylightsavings_command		      *)
(*                                                                    *)
(*      Scan the list daylightsavings command. Format is:	      *)
(*	LIST DAYLIGHTSAVINGS 					      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_list_daylightsavings_command(
    var scanned: scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then 
    if misc_common.check_daylight_savings
    then user_terminal.write_message('Daylight savings in effect\ ')
    else user_terminal.write_message('Daylight savings not in effect\ ')
end (* scan_list_daylightsavings_command *) ;



(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                      scan_list_display_command		      *)
(*                                                                    *)
(*      Scan the list display command. Format is:		      *)
(*	LIST DISPLAY    					      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_list_display_command(var scanned: scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      format.start;
      format.number(network_common.display_interval, 10);
      format.string(' seconds\ ');
      format.write_line(user_terminal)
    end 
end (* scan_list_display_command *) ;


$if alarm
(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                      scan_start_alarm			      *)
(*                                                                    *)
(*      Scan the start alarm  command. Format is:		      *)
(*        START ALARM [DETACH]					      *)
(*                                                                    *)
(**********************************************************************)



procedure scan_start_alarm (var scanned: scanned_command);

var 
  detached: boolean;

begin
  detached := argument_scan.check_keyword(MAIN_START_DETACH_KEYWORD, scanned);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      job_status.setup(detached);
      job_common.set_state (user, JOB_ALARM);
      if detached
      then
	begin
	  user_terminal.clear_circuit;
	  job_common.detach (user)
	end;
      alarmer.start_alarm;
      if job_status.ok
      then
	if job_status.detached
	then job_common.set_state (user, JOB_HUNG)
	else job_common.set_state (user, JOB_COMMAND)
    end
end (* scan_start_alarm *) ;
$endif alarm



$if reload
(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                      scan_start_reload			      *)
(*                                                                    *)
(*      Scan the start reload  command. Format is:		      *)
(*  	START RELOAD [DETACH | PRINT]				      *)
(*                                                                    *)
(**********************************************************************)




procedure scan_start_reload (var scanned: scanned_command);

var 
  detached: boolean;
  print   : boolean;

begin
  detached := argument_scan.check_keyword(MAIN_START_DETACH_KEYWORD, scanned);
  if not detached
  then 
    print := argument_scan.check_keyword (MAIN_START_PRINT_KEYWORD, scanned);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      job_status.setup(detached);
      job_common.set_state (user, JOB_RELOAD);
      if detached
      then
	begin
	  user_terminal.clear_circuit;
	  job_common.detach (user)
	end;
      reloader.start_reload (print);
      if job_status.ok
      then
	begin
	  if job_status.detached
	  then job_common.set_state (user, JOB_HUNG)
	end
      else job_common.set_state (user, JOB_COMMAND)
    end
end (* scan_start_alarm *) ;
$endif reload


$if background
(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                      scan_start_command			      *)
(*                                                                    *)
(*      Scan the start command.					      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_start_command (var scanned: scanned_command);

begin
$if alarm
  if argument_scan.check_keyword (MAIN_START_ALARM_KEYWORD, scanned)
  then scan_start_alarm (scanned)
  else
$endif alarm
$if reload
    if argument_scan.check_keyword (MAIN_START_RELOAD_KEYWORD, scanned)
    then scan_start_reload (scanned)
    else
$endif reload
      scanned.status := ARG_MISSING
end (* scan_start_command *) ;



(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                      scan_attach_command			      *)
(*                                                                    *)
(*      Scan the attach command.				      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_attach_command (var scanned: scanned_command);

var
  attach_user: user_index;
  ok	     : boolean;

begin
  argument_scan.freeword_user_number (0, scanned, attach_user);
  
  argument_scan.extra_argument_check (scanned);
  if scanned.status = CMD_OK
  then
    begin
      job_common.attach (user, attach_user, ok);
      if ok
      then
	user_terminal.free_circuit
      else
	user_terminal.write_message (
	  'Cannot attach to job. Job must be detached\ ')
    end
end (* scan_attach_command *) ;
$endif background



(*******************  main_operator_command_handler *******************)
(*                                                                    *)
(*                      scan_statistics_command			      *)
(*                                                                    *)
(*      Scan the statistics command.				      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_statistics_command (var scanned: scanned_command);

begin
  argument_scan.extra_argument_check (scanned);
  if scanned.status = CMD_OK
  then
    begin
      statistics.print_statistics(format, user_terminal);
      user_terminal.write_newline;
      node_file.dump_btree_statistics(user_terminal, format);
      host_file.dump_btree_statistics(user_terminal, format);
      link_file.dump_btree_statistics(user_terminal, format);
      port_file.dump_btree_statistics(user_terminal, format);
      host_location_common.dump_btree_statistics(user_terminal, format);
$if reload
      reload_file.dump_btree_statistics(user_terminal, format);
      kernel_file.dump_btree_statistics(user_terminal, format);
      host_slot_file.dump_btree_statistics(user_terminal, format);
$endif reload
$ifany (reload, xcom)
      slot_file.dump_btree_statistics(user_terminal, format);
$endif any reload xcom
      host_status_common.dump_btree_statistics(user_terminal, format);
      user_terminal.write_newline;
      network_common.display_check_statistics(user_terminal, format)
    end
end (* scan_statistics_command *) ;



(*******************  main_operator_command_handler *******************)
(**********************************************************************)


begin (* initial statement *)
end   (* main_operator_command_handler *) ;
    $if clusternodes
!
(**********************************************************************)
(*                                                                    *)
(*      CLUEXE.TMS                                                    *)
(*                                                                    *)
(*		main_cluster_command_handler			      *)
(*                                                                    *)
(*	This class handles all commands monitoring the data base      *)
(*	in cluster_common.				              *)
(*                                                                    *)
(*	The following identifiers must be defined externally:	      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                         Revision Record			      *)
(*                                                                    *)
(*	20Jan86 Original -- gde					      *)
(*                                                                    *)
(**********************************************************************)



type 
  main_cluster_command_handler =
    class (
      user_terminal	: circuit_handler;
      format		: internal_to_string;
      response_buffer	: text_buffer;
      printer		: set_printer;
      cluster_common	: global_cluster_data;
      argument_scan	: argument_scanner;
      profile		: user_profile);



(********************  main_cluster_command_handler  ******************)
(*                                                                    *)
(*                            initialize			      *)
(*                                                                    *)
(*                                                                    *)
(**********************************************************************)


procedure initialize;

begin
end (* initialize *) ;



(********************  main_cluster_command_handler  ******************)
(*                                                                    *)
(*                      scan_set_cluster_command		      *)
(*                                                                    *)
(*      Scan  the set cluster command. Format is:		      *)
(*	     SET NODE CLUSTER <node> <clustername>		      *)
(*                                                                    *)
(**********************************************************************)


procedure entry scan_set_cluster_command(var scanned: scanned_command);

var
  node: node_index;
  cluster: cluster_name;

begin
  if not argument_scan.check_keyword(MAIN_SET_NODE_KEYWORD, scanned)
  then scanned.status := ARG_MISSING;

  if scanned.status = CMD_OK
  then argument_scan.freeword_node(0, scanned, node);

  if scanned.status = CMD_OK
  then argument_scan.freeword_cluster_name(1, scanned, cluster);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then cluster_common.set_entry(node, cluster)
end (* scan_set_cluster_command *) ;



(********************  main_cluster_command_handler  ******************)
(*                                                                    *)
(*                      scan_clear_node_cluster  		      *)
(*                                                                    *)
(*      Scan  the clear node cluster. Format is:		      *)
(*	     CLEAR NODE CLUSTER <node>				      *)
(*                                                                    *)
(**********************************************************************)



procedure scan_clear_node_cluster(var scanned: scanned_command);

var
  node: node_index;

begin
  if not profile.license_check(SETN_LICENSE)
  then scanned.status := AUTH_ERROR;
  
  if scanned.status = CMD_OK
  then argument_scan.freeword_node(0, scanned, node);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then cluster_common.clear_entry(node)
end (* scan_clear_node_cluster *) ;



(********************  main_cluster_command_handler  ******************)
(*                                                                    *)
(*                      scan_clear_cluster			      *)
(*                                                                    *)
(*      Scan  the clear cluster. Format is:		      	      *)
(*	     CLEAR CLUSTER <clustername>		      	      *)
(*                                                                    *)
(**********************************************************************)



procedure scan_clear_cluster(var scanned: scanned_command);

var
  cluster: cluster_name;

begin
  if not profile.license_check(OPERATOR_LICENSE)
  then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then argument_scan.freeword_cluster_name(0, scanned, cluster);

  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then cluster_common.clear_cluster(cluster)
end (* scan_clear_cluster *) ;



(********************  main_cluster_command_handler  ******************)
(*                                                                    *)
(*                      scan_clear_cluster_command		      *)
(*                                                                    *)
(*      Scan  the clear cluster command. 			      *)
(*                                                                    *)
(**********************************************************************)


procedure entry scan_clear_cluster_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_CLEAR_NODE_KEYWORD, scanned)
  then scan_clear_node_cluster(scanned)
  else scan_clear_cluster(scanned)
end (* scan_clear_cluster_command *) ;



(********************  main_cluster_command_handler  ******************)
(*                                                                    *)
(*                      scan_list_cluster_node		      	      *)
(*                                                                    *)
(*      Scan  the list cluster node command.Format is: 		      *)
(*         LIST CLUSTER NODE [<node_index>]			      *)
(*                                                                    *)
(**********************************************************************)



procedure scan_list_cluster_node(var scanned: scanned_command);

var
  node: node_index;

begin
  response_buffer.start_put;

  if scanned.freeword_count > 0
  then
    begin
      argument_scan.freeword_node(0, scanned, node);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then 
	cluster_common.list_entry(
	  node, response_buffer, format, profile)
    end
  else
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	cluster_common.list_all_entries(
	  response_buffer, format, profile)
    end;

  if scanned.status = CMD_OK
  then response_buffer.print(user_terminal)
end (* scan_list_cluster_node *) ;



(********************  main_cluster_command_handler  ******************)
(*                                                                    *)
(*                           scan_list_cluster		      	      *)
(*                                                                    *)
(*      Scan  the list cluster  command.Format is: 		      *)
(*         LIST CLUSTER  [<clustername>]			      *)
(*                                                                    *)
(**********************************************************************)



procedure scan_list_cluster(var scanned: scanned_command);

var
  cluster: cluster_name;

begin
  response_buffer.start_put;

  if scanned.freeword_count > 0
  then
    begin
      argument_scan.freeword_cluster_name(0, scanned, cluster);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	cluster_common.list_cluster(
	  cluster, response_buffer, format, profile, printer)
    end
  else
    begin
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
  	cluster_common.list_all_clusters(
	  response_buffer, format, profile, printer)
    end;

  if scanned.status = CMD_OK
  then response_buffer.print(user_terminal)
end (* scan_list_cluster *) ;



(********************  main_cluster_command_handler  ******************)
(*                                                                    *)
(*                      scan_list_cluster_command		      *)
(*                                                                    *)
(*      Scan  the list cluster command. 			      *)
(*                                                                    *)
(**********************************************************************)



procedure entry scan_list_cluster_command(
    var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_LIST_NODE_KEYWORD, scanned)
  then scan_list_cluster_node(scanned)
  else scan_list_cluster(scanned)
end (* scan_list_cluster_command *) ;


(********************  main_cluster_command_handler  ******************)
(**********************************************************************)


begin (* initial statement *)
  initialize
end   (* main_cluster_command_handler *) ;
$endif clusternodes
!
(**********************************************************************)
(*                                                                    *)
(*      DEBEXE.TMS                                                    *)
(*                                                                    *)
(*		main_debug_command_handler			      *)
(*                                                                    *)
(*	This class handles all debugging commands		      *)
(*                                                                    *)
(*	The following identifiers must be defined externally:	      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                         Revision Record			      *)
(*                                                                    *)
(*	20Jan86 Original -- gde					      *)
(*                                                                    *)
(**********************************************************************)


type
  main_debug_command_handler =
    class (
      user_terminal		: circuit_handler;
      format			: internal_to_string;
      profile			: user_profile;
      printer			: set_printer;
      argument_scan		: argument_scanner;
$if debug
      node_file			: node_buffer;
      host_file			: host_buffer;
      link_file			: link_buffer;
      port_file			: port_buffer;
$if reload
      reload_file		: reload_control;
      host_slot_file		: host_slot_buffer;
      kernel_file		: kernel_buffer;
$endif reload
$ifany (reload, xcom)
      slot_file			: slot_buffer;
$endif any reload xcom
$endif debug
      network_common		: network_state_description
    );

$if debug
(*******************  main_debug_command_handler  *********************)
(*                                                                    *) 
(*                       scan_nsd_with_keyword			      *)
(*                                                                    *)
(*      Scan the nsd command which can have keyword.		      *)
(*                                                                    *)
(**********************************************************************)
 


procedure scan_nsd_with_keyword (var scanned: scanned_command);

var
  keyword: command_keyword_index;

begin
  if scanned.keyword_present <> []
  then
    begin
      argument_scan.find_keyword (
      	MAIN_NSD_NODE_KEYWORD, MAIN_NSD_LINK_KEYWORD, 
  	scanned, keyword);

      argument_scan.extra_argument_check (scanned);
      if scanned.status = CMD_OK
      then
	begin
	  network_common.dump_nsd (profile, user_terminal, format, printer);
	  case keyword of
$if reload
	    MAIN_NSD_RELOAD_KEYWORD:
	      reload_file.dump_file (profile, user_terminal, format);

$endif reload
$ifany (reload, xcom)
	    MAIN_NSD_SLOT_KEYWORD:
	      begin
		slot_file.dump_file (profile, user_terminal, format)
$if reload
		;
		host_slot_file.dump_file(profile, user_terminal, format);
		kernel_file.dump_file(profile, user_terminal, format)
$endif reload
	      end (* MAIN_NSD_SLOT_KEYWORD *) ;
$endif any reload xcom

	    MAIN_NSD_NODE_KEYWORD:
	      node_file.dump_file (profile, user_terminal, format);

	    MAIN_NSD_HOST_KEYWORD:
	      host_file.dump_file (profile, user_terminal, format);

	    MAIN_NSD_LINK_KEYWORD:
	      link_file.dump_file (profile, user_terminal, format);

	    MAIN_NSD_LINE_KEYWORD:
	      port_file.dump_file (profile, user_terminal, format)
	  end (* case *) 
        end
    end
  else
    begin
      argument_scan.extra_argument_check (scanned);
      if scanned.status = CMD_OK
      then network_common.dump_nsd (profile, user_terminal, format, printer)
    end
end (* scan_nsd_with_command *) ;
$endif debug



(*******************  main_debug_command_handler  *********************)
(*                                                                    *) 
(*                       scan_nsd_command			      *)
(*                                                                    *)
(*      Scan the nsd command.					      *)
(*                                                                    *)
(**********************************************************************)
 


procedure entry scan_nsd_command (var scanned: scanned_command);

begin
$ifnot debug
  argument_scan.extra_argument_check (scanned);
  if scanned.status = CMD_OK
  then network_common.dump_nsd (profile, user_terminal, format, printer)
$endif not debug
$if debug
  scan_nsd_with_keyword (scanned)
$endif debug
end (* scan_nsd_command *) ;



(*******************  main_debug_command_handler  *********************)
(**********************************************************************)


begin (* initial statement *)
end   (* main_debug_command_handler *) ;
 $if    auto_backup
!
(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*	GIKDCV.TMS  Updated 4-Jan-87 at 9:06 by Raffo	  		*)
(*									*)
(*	Data Type Converter for Getting-in-the-Know for			*)
(*			TMCS/NTCN Automatic Backup			*)
(*									*)
(*	Interface with the various permanent files to construct		*)
(*	or utilize the data recovery transactions used during		*)
(*	recovery from extreme data loss (getting_in_the_know),		*)
(*	by the Transaction Sender and Receiver Processes.		*)
(*									*)
(************************************************************************)


type
  getting_in_the_know_data_converter =
    class (
      circuit			: backup_circuit_handler ;
      oper_msgs			: operator_messages ;
      profile_file		: global_user_data ;
      name_file			: global_name_data ;
      host_location_file	: global_host_location_data;
      host_status_file		: global_host_status_data;
      probe_password_file	: global_supervisor_data;
$if reload
      xom_host_file		: global_xom_data;
$endif reload
$if ddt
      host_number_file		: node_list_manager;
$endif ddt
$if    clusternodes
      cluster_file		: global_cluster_data;
$endif clusternodes
$if    background
      job_file			: global_job_data;
$endif background
$if    xom_restore
      xom_backup		: xom_backup_operator;
$endif xom_restore
      misc_file			: miscellaneous_data ) ;

var
  sizer : transaction_log_data_sizer;
!
$if    reload
(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		    supply_xom_host_file_recovery_info		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)


procedure supply_xom_host_file_recovery_info( 
	new_index   :      host_index ;
    var transaction : UNIV transaction_log_xom_host_file_max_entry);

begin
  xom_host_file.supply_item_info (new_index, transaction );
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_xom_host_file_recovery_info *) ;
$endif reload
!
$if ddt
(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		    supply_host_number_file_recovery_info	 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)


procedure supply_host_number_file_recovery_info( 
	kernel_item    :  univ node_index ;
    var transaction    : UNIV transaction_log_host_number_file_max_entry);

begin
  transaction.head.file_id := BACKUP_HOST_NUMBER_FILE_CHANGE;
  transaction.key.node := kernel_item;
  host_number_file.modify_host (transaction.data.host, kernel_item );
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_host_number_file_recovery_info *) ;
$endif ddt
!
$if    clusternodes
(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		    supply_cluster_file_recovery_info		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)


procedure supply_cluster_file_recovery_info( 
      cluster_item	: univ node_index;
  var transaction	: univ transaction_log_cluster_file_max_entry ) ;

begin
  transaction.head.file_id   := BACKUP_CLUSTER_FILE_CHANGE ;
  transaction.key.node  :=  cluster_item ;
  cluster_file.get_cluster( cluster_item, transaction.data.name);
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_cluster_file_recovery_info *) ;
$endif clusternodes
$if    background



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		    supply_job_file_recovery_info		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)


procedure supply_job_file_recovery_info( 
      job_item		: univ user_index;
  var transaction	: univ transaction_log_job_file_max_entry ) ;

begin
  transaction.head.file_id   := BACKUP_JOB_FILE_CHANGE ;
  transaction.key.user  :=  job_item ;
  job_file.supply_job_file_item_data (
    job_item, transaction.data.background_job);
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_job_file_recovery_info *) ;
$endif background



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*			supply_misc_file_recovery_info		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)


procedure supply_misc_file_recovery_info( 
      misc_item	: backup_misc_data_item_index;
  var transaction	: univ transaction_log_misc_file_max_entry ) ;

begin
  transaction.head.file_id   := BACKUP_MISC_FILE_CHANGE ;
  transaction.key.misc_item  :=  misc_item ;

  case misc_item of
    backup_misc_node_recurring :
      misc_file.get_node_recurring_outage_variables (
	transaction.data.new_recurring_variables) ;

    backup_misc_host_recurring :
      misc_file.get_host_recurring_outage_variables (
	transaction.data.new_recurring_variables) ;

    backup_misc_line_recurring :
      misc_file.get_line_recurring_outage_variables (
	transaction.data.new_recurring_variables)
  end (* cases of  misc_item *) ;

  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_misc_file_recovery_info *) ;



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*			supply_name_file_recovery_info		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)


procedure supply_name_file_recovery_info( 
      name_file_id	: backup_name_file_index;
      name_item		: backup_TS_index;
  var transaction	: univ transaction_log_name_file_max_entry ) ;

begin
  transaction.key  :=  name_item ;

  case name_file_id of
    backup_host_name_file :
      begin
	transaction.head.file_id   := BACKUP_HOST_NAME_FILE_CHANGE ;
	name_file.get_host_name(name_item, transaction.data.name) 
      end ;

    backup_node_name_file :
      begin
	transaction.head.file_id   := BACKUP_NODE_NAME_FILE_CHANGE ;
	name_file.get_node_name(name_item, transaction.data.name) 
      end ;

    backup_product_name_file :
      begin
	transaction.head.file_id   := BACKUP_PRODUCT_NAME_FILE_CHANGE ;
	name_file.get_product_name(name_item, transaction.data.name) 
      end
  end (* cases of  name_item *) ;

  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_name_file_recovery_info *) ;



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		 supply_probe_password_file_recovery_info	 	*)
(*									*)
(*	used by the Transaction Sender Process.			*)
(*									*)
(************************************************************************)


procedure supply_probe_password_file_recovery_info(
      supervisor	: univ supervisor_index;
  var transaction	: univ transaction_log_probe_password_file_max_entry );

begin
  transaction.head.file_id := BACKUP_PROBE_PASSWORD_FILE_CHANGE  ;
  probe_password_file.password(supervisor, transaction.data.new_password);
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_probe_password_file_recovery_info *) ;



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*				profile_file_key		 	*)
(*									*)
(*	Place a profile file key where it is needed...  		*)
(*									*)
(************************************************************************)

procedure profile_file_key(
      user		: univ username_index;
  var user_data 	:      backup_profile_header;
  var transaction	: univ transaction_log_profile_user_file_max_entry ) ;

begin
  profile_file.supply_user_profile_info(user, user_data);
  transaction.key.name := user_data.access.name
end (* profile_file_key *) ;


(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*			 profile_threshold_info 		 	*)
(*									*)
(*	used by the Transaction Sender Process.			*)
(*									*)
(************************************************************************)


procedure profile_threshold_info(
      file_id     :      backup_profile_threshold_file_index ;
  var transaction : univ transaction_log_profile_threshold_file_max_entry;
      user_data   :      backup_profile_header);

begin
  case file_id of
    backup_user_node_threshold_file:
      begin
	transaction.head.file_id := BACKUP_PROFILE_NODE_THRESHOLD_FILE;
	transaction.data.threshold := user_data.access.node_threshold 
      end;

    backup_user_host_threshold_file:
      begin
	transaction.head.file_id := BACKUP_PROFILE_HOST_THRESHOLD_FILE;
  	transaction.data.threshold := user_data.access.host_threshold
      end;

    backup_user_line_threshold_file:
      begin
	transaction.head.file_id := BACKUP_PROFILE_LINE_THRESHOLD_FILE;
	transaction.data.threshold := user_data.access.line_threshold
      end

    end (* cases of file_id *)
end (* profile_threshold_info *) ;


(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*			profile_default_limit_info 		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)


procedure profile_default_limit_info(
  var transaction : univ transaction_log_profile_default_limit_file_max_entry;
      user_data   :      backup_profile_header);

begin
  transaction.head.file_id := BACKUP_PROFILE_DEFAULT_LIMIT_FILE;
  transaction.data.default_limit_set := user_data.access.default_limit_set
end (*	profile_default_limit_info *) ;



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		    supply_profile_file_recovery_info		 	*)
(*									*)
(*	used by GIK Sender.						*)
(*									*)
(************************************************************************)


procedure supply_profile_file_recovery_info( 
      file_id	 	:      backup_user_profile_item_index ;
      user		: univ username_index;
  var transaction	: univ transaction_log_profile_user_file_max_entry ) ;

var
  user_data : backup_profile_header;

begin
  profile_file_key(user, user_data, transaction ) ;

  case file_id of
    backup_user_profile_file :
      begin
	transaction.head.file_id := BACKUP_PROFILE_NEW_USER_FILE ;
	transaction.data.part_1 := user_data.access.part_1;
	transaction.data.part_2 := user_data.access.part_2;
	transaction.data.part_3 := user_data.access.part_3;
	transaction.data.colors := user_data.colors
      end;

    backup_user_node_threshold_file,
    backup_user_host_threshold_file,
    backup_user_line_threshold_file : 
      profile_threshold_info( file_id, transaction, user_data ) ;

    backup_user_default_limit_file	:
      profile_default_limit_info( transaction, user_data ) 
  end (* cases of file_id *) ;

  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_profile_file_recovery_info *) ;
$if    alarm



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		  supply_profile_alarm_file_recovery_info	 	*)
(*									*)
(*	used by GIK Sender.						*)
(*									*)
(************************************************************************)


procedure supply_profile_alarm_file_recovery_info(
      user		:      username_index ;
  var transaction	: univ transaction_log_profile_alarm_file_max_entry );

var
  status    : user_search_status;
  user_data : backup_profile_header;

begin
  profile_file_key(user, user_data, transaction ) ;
  transaction.head.file_id := BACKUP_PROFILE_ALARM_FILE;
  profile_file.read_alarm(user, transaction.data.user_alarm, status);
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_profile_alarm_file_recovery_info *) ;
$endif alarm



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		supply_profile_limit_set_file_recovery_info	 	*)
(*									*)
(*	used by GIK Sender.						*)
(*									*)
(************************************************************************)


procedure supply_profile_limit_set_file_recovery_info( 
      item_position :      backup_TS_index;
  var transaction   : univ transaction_log_profile_limit_set_file_max_entry);

var
  user_position : username_index;
  limit_position : limit_set_index;
  user_data : backup_profile_header;

begin
  user_position := item_position div LIMIT_SET_MAX;
  limit_position := item_position mod LIMIT_SET_MAX;
  profile_file_key(user_position, user_data, transaction ) ;
  transaction.head.file_id := BACKUP_PROFILE_LIMIT_SET_FILE;
  transaction.key.part_2.limit_set_name := 
    user_data.access.limit_set_names[limit_position];
  profile_file.supply_limit_set_info (
    user_position, limit_position, transaction.data);
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_profile_limit_set_file_recovery_info *) ;



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		      supply_host_location_item_info		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)

procedure supply_host_location_item_info(
      item_index	: backup_TS_index;
  var transaction	: univ transaction_log_host_location_file_max_entry );

begin
  transaction.head.file_id := BACKUP_HOST_LOCATION_FILE_CHANGE ;
  host_location_file.supply_item_info ( item_index, transaction.body );
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_host_location_item_info *) ;



(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		      supply_host_status_item_info		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)

procedure supply_host_status_item_info(
      item_index	: univ entry_page_index;
  var transaction	: univ transaction_log_host_status_file_max_entry );

begin
  host_status_file.supply_host_status_info(item_index, transaction);
  transaction.head.file_id := BACKUP_HOST_STATUS_FILE_CHANGE ;
  circuit.send_transaction_message (FILE_RECOVERY_TRANSACTION, transaction)
end (* supply_host_status_item_info *) ;
$if    xom_restore
!
(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*		    supply_xom_data_file_recovery_info		 	*)
(*									*)
(*									*)
(************************************************************************)


procedure supply_xom_data_file_recovery_info(
      index		:          integer;
  var transaction	: univ transaction_log_xom_data_item_max_entry );

begin
  xom_backup.supply_xom_data_recovery_info (circuit, index, transaction)
end (* supply_xom_data_file_recovery_info *) ;
$endif xom_restore
!
(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*			    supply_recovery_data		 	*)
(*									*)
(*	used by the Transaction Sender Process.				*)
(*									*)
(************************************************************************)


procedure entry supply_recovery_data  (
      file_id	 	:      backup_file_index;
      item_index	:      backup_TS_index;
  var transaction	: univ transaction_log_max_entry   ) ;

begin
  case file_id of
    backup_user_limit_set_file: 
      supply_profile_limit_set_file_recovery_info (item_index, transaction ) ;

    backup_user_profile_file,
    backup_user_node_threshold_file,
    backup_user_host_threshold_file,
    backup_user_line_threshold_file,
    backup_user_default_limit_file:
      supply_profile_file_recovery_info (file_id, item_index, transaction);

$if    alarm
    backup_user_alarm_file:
      supply_profile_alarm_file_recovery_info (item_index, transaction) ;
$endif alarm
$ifnot alarm
    backup_user_alarm_file:
      oper_msgs.crash_process (CRASH_INVALID_BACKUP_FILE_INDEX);
$endif alarm

    backup_host_name_file,
    backup_node_name_file,
    backup_product_name_file:
      supply_name_file_recovery_info (file_id, item_index, transaction ) ;

    backup_host_location_file: 
      supply_host_location_item_info (item_index, transaction );

    backup_host_status_file: 
      supply_host_status_item_info (item_index, transaction );

    backup_probe_password_file: 
      supply_probe_password_file_recovery_info (item_index, transaction );

$if reload
    backup_xom_host_file:
      supply_xom_host_file_recovery_info ( item_index, transaction ) ;
$endif reload
$ifnot reload
    backup_xom_host_file:
      oper_msgs.crash_process (CRASH_INVALID_BACKUP_FILE_INDEX);
$endif reload

$if ddt
    backup_host_number_file:
      supply_host_number_file_recovery_info ( item_index, transaction ) ;
$endif ddt
$ifnot ddt
    backup_host_number_file:
      oper_msgs.crash_process (CRASH_INVALID_BACKUP_FILE_INDEX);
$endif not ddt 

$if    clusternodes
    backup_cluster_file:
      supply_cluster_file_recovery_info ( item_index, transaction ) ;
$endif clusternodes
$ifnot clusternodes
    backup_cluster_file:
      oper_msgs.crash_process (CRASH_INVALID_BACKUP_FILE_INDEX);
$endif clusternodes

$if background
    backup_job_file:
      supply_job_file_recovery_info ( item_index, transaction ) ;
$endif background
$ifnot background
    backup_job_file:
      oper_msgs.crash_process (CRASH_INVALID_BACKUP_FILE_INDEX);
$endif background

$if    xom_restore
    backup_xom_data_first_file:
      supply_xom_data_file_recovery_info (item_index, transaction) ;

    backup_xom_data_last_file:
      oper_msgs.crash_process (CRASH_INVALID_BACKUP_FILE_INDEX);
$endif xom_restore
$ifnot xom_restore
    backup_xom_data_first_file,
    backup_xom_data_last_file:
      oper_msgs.crash_process (CRASH_INVALID_BACKUP_FILE_INDEX);
$endif xom_restore

    backup_misc_file:
      supply_misc_file_recovery_info( item_index, transaction )
  end (* cases of file_id *)
end (* supply_recovery_data *) ;
!
(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*			    recover_data_item			 	*)
(*									*)
(*	Used by the Transaction Receiver Process.  Returns an Index	*)
(*	for placement of Time Stamp purposes.				*)
(*									*)
(************************************************************************)


procedure entry recover_data_item(
      transaction : univ transaction_log_key_index_max_entry
			 (* for files whose key is same as item index *) ;
  var the_index   : backup_TS_indicator ) ;

begin
  the_index := BACKUP_TS_INDEX_ABSENT;
  case sizer.file_of(transaction.head.file_id) of
    backup_user_profile_file:
      profile_file.recover_user_profile (transaction, the_index) ;

    backup_user_node_threshold_file,
    backup_user_host_threshold_file,
    backup_user_line_threshold_file:
      profile_file.recover_threshold (transaction, the_index) ;

    backup_user_limit_set_file:
      profile_file.recover_limit_set ( transaction, the_index) ;

    backup_user_default_limit_file:
      profile_file.recover_default_limit ( transaction, the_index) ;

$if    alarm
    backup_user_alarm_file:
      profile_file.recover_alarm (transaction, the_index) ;
$endif alarm
$ifnot alarm
    backup_user_alarm_file:
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX);
$endif alarm

    backup_host_name_file,
    backup_node_name_file,
    backup_product_name_file:
      begin
	the_index := transaction.key  (* key is same as item index *) ;
	name_file.recover_backup_name_file_item( transaction ) 
      end ;

    backup_host_location_file: 
      host_location_file.recover_backup_item ( transaction, the_index ) ;

    backup_host_status_file: 
      host_status_file.recover_backup_item ( transaction, the_index ) ;

    backup_probe_password_file	:
      begin
	the_index := transaction.key  (* key is same as item index *) ;
	probe_password_file.recover_probe_password_file_item(transaction ) 
      end;

$if reload
    backup_xom_host_file:
      xom_host_file.recover_backup_item( transaction, the_index) ;
$endif reload
$ifnot reload
    backup_xom_host_file:
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX);
$endif not reload

$if ddt
  backup_host_number_file:
    begin
      the_index := transaction.key ;
      host_number_file.recover_backup_host_file_item (transaction)
    end;
$endif ddt
$ifnot ddt
    backup_host_number_file:
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX);
$endif not ddt

$if    clusternodes
    backup_cluster_file:
      begin
	the_index := transaction.key  (* key is same as item index *) ;
	cluster_file.recover_backup_cluster_file_item (transaction)
      end ;
$endif clusternodes
$ifnot clusternodes
    backup_cluster_file:
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX) ;
$endif not clusternodes

$if    background
    backup_job_file:
      begin
	the_index := transaction.key  (* key is same as item index *) ;
	job_file.recover_backup_job_file_item (transaction)
      end;
$endif background
$ifnot background
    backup_job_file:
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX) ;
$endif not background

$if    xom_restore
    backup_xom_data_first_file:
      xom_backup.recover_backup_item(transaction, the_index) ;

    backup_xom_data_last_file:
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX) ;
$endif xom_restore
$ifnot xom_restore
    backup_xom_data_first_file,
    backup_xom_data_last_file:
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX) ;
$endif not xom_restore

    backup_misc_file:
      begin
	the_index := transaction.key  (* key is same as item index *) ;
	misc_file.recover_backup_misc_item(transaction)
      end
  end (* cases of sizer.file_of(transaction.head.file_id) *)
end (* recover_data_item *) ;
!
(****************** getting_in_the_know_data_converter ******************)
(*									*)
(*			    delete_file_item	 			*)
(*									*)
(*	For a clearable file, delete one item that was detected as	*)
(*	having been deleted, presumably by the Partner, while the	*)
(*	present Site was down.						*)
(*	used by the Transaction Receiver Process.			*)
(*									*)
(************************************************************************)


procedure entry delete_file_item( 
      file_id : backup_file_index ;
      index   : backup_ts_index ) ;

begin
  case file_id of
$if    alarm
    backup_user_alarm_file,
$endif alarm
    backup_user_profile_file: 
      profile_file.delete_backup_user_profile(index);

$ifnot     alarm
    backup_user_alarm_file  :
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX);
$endif not alarm

    backup_user_node_threshold_file,
    backup_user_host_threshold_file,
    backup_user_line_threshold_file,
    backup_user_default_limit_file:
      profile_file.delete_backup_item(file_id, index) ;

    backup_user_limit_set_file :
      profile_file.delete_backup_limit_set (index) ;

$if    reload
    backup_xom_host_file :
      xom_host_file.delete_backup_item(index) ;
$endif reload
$ifnot reload
    backup_xom_host_file :
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX);
$endif not reload

$if    xom_restore
    backup_xom_data_first_file :
      xom_backup.delete_backup_item(index);

    backup_xom_data_last_file :
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX) ;
$endif xom_restore
$ifnot xom_restore
    backup_xom_data_first_file ,
    backup_xom_data_last_file :
      oper_msgs.crash_process (CRASH_INVALID_TRANSACTION_FILE_INDEX) ;
$endif not xom_restore

    backup_host_status_file :
      host_status_file.delete_backup_item(index) ;

    backup_host_location_file :
      host_location_file.delete_backup_item(index) 
  end (* cases of file_id *)
end (* delete_file_item *) ;




(****************** getting_in_the_know_data_converter ******************)
(************************************************************************)


begin
  init sizer
end (* getting_in_the_know_data_converter *) ;
$endif auto_backup
$if    auto_backup
!
(********************* transaction_receiver_process *********************)
(*									*)
(*	TXRCVP.TMB  Updated 4-Jan-87 at 12:36 by Raffo	 		*)
(*									*)
(*			transaction_receiver_process		 	*)
(*									*)
(*	Receive and Process Transaction Notification Messages for	*)
(*	Automatic Backup.  Perform Getting-in-the-Know, as well.	*)
(*									*)
(************************************************************************)




type
  transaction_receiver_process =
    process (
      partner_host_number	: host_number ;
      my_proc_id,
      partner_proc_id     	: dialogue_process_identifier ;
      partner 			: partner_index ;
      time_stamps		: backup_time_stamp_file ;
      circ_mon 			: circuit_monitor ;
      backup  			: transaction_log_file ;
      op_log			: operator_log ;
      profile_file		: global_user_data ;
      name_file			: global_name_data ;
      host_location_file	: global_host_location_data;
      host_status_file		: global_host_status_data;
      probe_password_file	: global_supervisor_data;
$if reload
      xom_host_file		: global_xom_data;
$endif reload
$if ddt
      host_number_file		: node_list_manager;
$endif ddt 
$if    clusternodes
      cluster_file		: global_cluster_data;
$endif clusternodes
$if    background
      job_file			: global_job_data;
$endif background
$if   xom_restore
      xom_file_mng		: xom_file_manager;
$endif xom_restore
      misc_file			: miscellaneous_data ) ;

const
  (* If a User is busy when a transaction comes in, wait and retry. *)
  BACKUP_RETRY_DELAY = 3 * 60 (* number of seconds to wait before retry *) ;


var
  sleepy			: sleeper;
  format			: internal_to_string;
  oper_msgs			: operator_messages;
$if    xom_restore
  xom_file_operator		: xom_file_utility;
  xom_backup			: xom_backup_operator;
$endif xom_restore
  halfword_operator		: halfword_utility;
  circ_hdl			: circuit_handler ;
  circuit			: backup_circuit_handler ;
  reader			:  message_reader;
  GIK_data			: getting_in_the_know_data_converter;
  sizer				: transaction_log_data_sizer;
  the_message			: backup_message_type;
  transaction			: transaction_log_max_entry;
!
(********************* transaction_receiver_process *********************)
(*									*)
(*				initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

begin
  init sleepy;
  init sizer;
  init format;
  init oper_msgs(op_log, format);
$if    xom_restore
  init xom_file_operator (oper_msgs, format, backup, xom_file_mng);
  init xom_backup (format, oper_msgs, backup, xom_file_operator);
$endif xom_restore
  init halfword_operator;
  init circ_hdl;
  init
    circuit(
      partner_host_number, my_proc_id, partner_proc_id, circ_mon,
	circ_hdl, op_log);
  init reader(circuit);
  init
    GIK_data(
      circuit,
      oper_msgs,
      profile_file,
      name_file,
      host_location_file,
      host_status_file,
      probe_password_file,
$if reload
      xom_host_file,
$endif reload
$if ddt
      host_number_file,
$endif ddt 
$if    clusternodes
      cluster_file,
$endif clusternodes
$if    background
      job_file,
$endif background
$if    xom_restore
      xom_backup,
$endif xom_restore
      misc_file ) ;

  circuit.identify_process('Transaction Receiver\ ')

end (* intialize *) ;
!
(********************* transaction_receiver_process *********************)
(*									*)
(*		     GIK_receive_simple_file_updates		 	*)
(*									*)
(*	Process simple change transactions affecting a non-clearable	*)
(*	file for purposes of Getting-Into-the-Know.			*)
(*									*)
(************************************************************************)


procedure GIK_receive_simple_file_updates;

var
  the_index   : backup_ts_indicator ;

begin
  repeat
    reader.either_message_type (
      FILE_RECOVERY_TRANSACTION, END_OF_FILE_RECOVERY, the_message);
    if reader.okay and (the_message = FILE_RECOVERY_TRANSACTION)
    then
      begin
	circuit.read_transaction_message_body (transaction);
	if backup.new_transaction (transaction.head)
	then
	  begin
	    GIK_data.recover_data_item (transaction, the_index ) ;
	    if circuit.built and (the_index > BACKUP_TS_INDEX_ABSENT)
	    then
	      time_stamps.put_time_stamp (
		sizer.file_of(transaction.head.file_id),
		the_index, transaction.head.stamp)
	  end
      end
  until (the_message = END_OF_FILE_RECOVERY) or not circuit.built
end (* GIK_receive_simple_file_updates *) ;
!
(********************* transaction_receiver_process *********************)
(*									*)
(*				delete_between			 	*)
(*									*)
(*	For clearable files, when getting into the know, delete items	*)
(*	that were not sent by the Partner, presumably because they	*)
(*	were deleted while the present Site was down.			*)
(*									*)
(************************************************************************)


procedure delete_between(
      this_file		: backup_file_index;
      from_stamp	: transaction_stamp_element;
      to_time		: time_element)  ;

var
  first_stamp	: transaction_stamp_element ;
  last_stamp	: transaction_stamp_element ;
  the_index	: backup_ts_indicator ;

begin
  first_stamp := from_stamp;
  repeat 
    time_stamps.next_item_after (
      this_file, first_stamp, last_stamp, the_index);

    if the_index <> BACKUP_TS_INDEX_ABSENT
    then
      if first_stamp.time < to_time
      then
	begin
	  GIK_data.delete_file_item (this_file, the_index);
	  time_stamps.clear_time_stamp (this_file, the_index)
	end
  until (the_index = BACKUP_TS_INDEX_ABSENT) or
	(first_stamp.time >= to_time)
end (* delete_between *) ;



(********************* transaction_receiver_process *********************)
(*									*)
(*		    GIK_receive_clearable_file_updates  	 	*)
(*									*)
(*	Getting-in-the-Know Receiver for Clearable Files.		*)
(*									*)
(************************************************************************)


procedure GIK_receive_clearable_file_updates(
      this_file		: backup_file_index ;
      my_knowlev	: level_site_array;
      partners_sendlev	: level_site_array);

var
  per_site   : site_index;
  from_stamp : transaction_stamp_element ;
  file_stamp : transaction_stamp_element ;

begin
  for per_site := SITE_FIRST to SITE_LAST do
    begin
      from_stamp.time := my_knowlev[per_site];
      from_stamp.site := per_site;
      repeat
	reader.either_message_type (
	  CLEARABLE_FILE_RECOVERY_LIST_ITEM,
	  END_OF_CLEARABLE_FILE_RECOVERY_LIST, the_message);

	if reader.okay and (the_message = CLEARABLE_FILE_RECOVERY_LIST_ITEM)
	then
	  begin
	    circuit.read_clearable_file_recovery_message_body (file_stamp);
	    if circuit.built
	    then
	      begin
		delete_between (this_file, from_stamp, file_stamp.time);
		from_stamp := file_stamp
	      end
	  end
      until (the_message = END_OF_CLEARABLE_FILE_RECOVERY_LIST) or
	    not circuit.built;
      if circuit.built
      then delete_between (this_file, from_stamp, partners_sendlev[per_site])
    end (* for *)
end (* GIK_receive_clearable_file_updates *) ;



(********************* transaction_receiver_process *********************)
(*									*)
(*			  GIK_receive_file_updates		 	*)
(*									*)
(*	Handle Getting-in-the-Know for one file's worth of data. 	*)
(*									*)
(************************************************************************)


procedure GIK_receive_file_updates (
  var this_file		: backup_file_index ;
      my_knowlev	: level_array;
      partners_sendlev	: level_array);

begin
  if not time_stamps.file_grabbed_for_update (this_file)
  then
    begin
      circuit.send_file_needs_recovery_message (this_file);
      if sizer.clearable (this_file)
      then
	GIK_receive_clearable_file_updates (
	  this_file, my_knowlev[this_file], partners_sendlev[this_file]);

      GIK_receive_simple_file_updates;
      time_stamps.relinquish_file_for_update (this_file)
    end
end (* GIK_receive_file_updates *) ;
!
(********************* transaction_receiver_process *********************)
(*									*)
(*			getting_in_the_know_receiver		 	*)
(*									*)
(*	This is the executive procedure for the receiving side of the	*)
(*	G-I-K operation.						*)
(*									*)
(************************************************************************)


procedure getting_in_the_know_receiver;

var
  partners_sendlev	: level_array;
  my_knowlev		: level_array;
  file_needs_updating	: boolean;
  this_file		: backup_file_index;
  per_site		: site_index;

begin
  circuit.send_message_type (REQUEST_FOR_SENDLEV_ARRAY);
  reader.level_array_message (partners_sendlev);

  backup.get_knowlev (my_knowlev);
  reader.one_message_type (REQUEST_FOR_KNOWLEV_ARRAY);
  circuit.send_level_array_message (my_knowlev);

  for this_file := BACKUP_FILE_INDEX_FIRST to BACKUP_FILE_INDEX_LAST do
    if circuit.built
    then
      begin
	file_needs_updating := FALSE;
	for per_site := SITE_FIRST to SITE_LAST do
	  file_needs_updating :=
	    file_needs_updating or
	    (partners_sendlev[this_file, per_site] >
	     my_knowlev[this_file, per_site]);
	if file_needs_updating
	then
	  GIK_receive_file_updates (this_file, my_knowlev, partners_sendlev)
      end (* for *) ;

  circuit.send_message_type (DONE_WITH_GIK_SCAN)
end (* getting_in_the_know_receiver *) ;
!
(********************* transaction_receiver_process *********************)
(*									*)
(*			    dispatch_transaction		 	*)
(*									*)
(*	Given a Transaction, send it off to its proper processor...	*)
(*									*)
(************************************************************************)


procedure dispatch_transaction ;

var
  busy : boolean;

begin
  busy := FALSE;
  repeat
    case transaction.head.file_id of
      backup_profile_new_user_file :
	profile_file.propogate_new_profile_user ( transaction , busy) ;

      backup_profile_mod_user_file :
	profile_file.propogate_modified_profile_user  ( transaction , busy) ;

      backup_profile_user_clear :
	profile_file.propogate_user_deletion ( transaction, busy);

      backup_profile_node_threshold_file,
      backup_profile_host_threshold_file,
      backup_profile_line_threshold_file :
	profile_file.propogate_threshold (transaction);

      backup_profile_limit_set_file :
	profile_file.propogate_limit_set (transaction);

      backup_profile_limit_clear :
	profile_file.propogate_limit_set_clear (transaction);

      backup_profile_default_limit_clear,
      backup_profile_default_limit_file :  
	profile_file.propogate_default_limit_set (transaction);

$if    alarm
      backup_profile_alarm_file : 
	profile_file.propogate_alarm (transaction);
$endif alarm
$ifnot     alarm
      backup_profile_alarm_file :  
	backup.propogate_change_transaction (
	  transaction, BACKUP_TS_INDEX_ABSENT);
$endif not alarm

      backup_host_name_file_change:
	name_file.propogate_host_name (transaction);

      backup_node_name_file_change:
	name_file.propogate_node_name (transaction);

      backup_product_name_file_change :
	name_file.propogate_product_name (transaction);

      backup_host_location_file_change :
	 host_location_file.propogate_host_location_set (transaction);

      backup_host_location_clear :
	 host_location_file.propogate_host_location_clear (transaction);

      backup_host_status_file_change :
	 host_status_file.propogate_host_status_entry (transaction);

      backup_host_status_clear :
	 host_status_file.propogate_host_status_clear (transaction);

      backup_probe_password_file_change :  
	probe_password_file.propogate_password (transaction);

$if    reload
      backup_xom_host_file_change :
	 xom_host_file.propogate_xom_host_entry (transaction);

      backup_xom_host_clear :
	xom_host_file.propogate_xom_clear(transaction);
$endif reload
$ifnot     reload
      backup_xom_host_file_change,
      backup_xom_host_clear :
	backup.propogate_change_transaction (
	  transaction, BACKUP_TS_INDEX_ABSENT);
$endif not reload

$if ddt
      backup_host_number_file_change:
	host_number_file.propogate_entry(transaction);
$endif ddt 
$ifnot ddt
      backup_host_number_file_change:
	backup.propogate_change_transaction (
	  transaction, BACKUP_TS_INDEX_ABSENT);
$endif not ddt 
$if    clusternodes
      backup_cluster_file_change:
	cluster_file.propogate_entry (transaction);
$endif clusternodes
$ifnot     clusternodes
      backup_cluster_file_change:
	backup.propogate_change_transaction (
	  transaction, BACKUP_TS_INDEX_ABSENT);
$endif not clusternodes

$if    background
      backup_job_file_change :
	job_file.propogate_set_background (transaction);
$endif background
$ifnot background
      backup_job_file_change:
	backup.propogate_change_transaction (
	  transaction, BACKUP_TS_INDEX_ABSENT);
$endif background

$if    xom_restore
      backup_xom_data_file_change :
	xom_backup.propogate_xom_data_file_change (transaction, busy) ;

      backup_xom_data_item :
	xom_backup.propogate_xom_data_item (transaction, busy) ;

      backup_xom_data_item_end :
	xom_backup.propogate_xom_data_item_end (transaction, busy) ;

      backup_xom_data_clear :
	xom_backup.propogate_xom_data_clear (transaction, busy);
$endif xom_restore
$ifnot     xom_restore
      backup_xom_data_file_change,
      backup_xom_data_item,
      backup_xom_data_item_end,
      backup_xom_data_clear	:
	backup.propogate_change_transaction( 
	  transaction, BACKUP_TS_INDEX_ABSENT);
$endif not xom_restore

      backup_misc_file_change :
	misc_file.propogate_miscellaneous_data_item (transaction )
    end (* cases *) ;
    if busy then sleepy.sleep(BACKUP_RETRY_DELAY)
  until not busy;
end (* dispatch_transaction *) ;



(********************* transaction_receiver_process *********************)
(************************************************************************)

begin
  initialize;
  cycle
    circuit.init_circuit;
    getting_in_the_know_receiver;
    while circuit.built do
      begin
	reader.transaction_message (transaction);
	if circuit.built
	then
	  begin
	    if backup.new_transaction (transaction.head)
	    then dispatch_transaction;
	    circuit.send_message_type (TRANSACTION_NOTIFICATION_ACKNOWLEDGE)
	  end
      end (* while circuit.built *)
  end (* cycle *)
end (* transaction_receiver_process *) ;
$endif auto_backup
    $if    auto_backup
!
(*********************  transaction_sender_process  *********************)
(*									*)
(*	TXSNDP.TMB  Updated 4-Jan-87 at 10:57 by Raffo	 		*)
(*									*)
(*			transaction_sender_process 		 	*)
(*									*)
(*	Prepare and Send Transaction Notification Messages for  	*)
(*	Automatic Backup.  Perform Getting-in-the-Know, as well.	*)
(*									*)
(************************************************************************)


type
  transaction_sender_process =
    process (
      partner_host_number 	: host_number ;
      my_proc_id,
      partner_proc_id     	: dialogue_process_identifier ;
      my_site 			: site_index ;
      partner 			: partner_index ;
      time_stamps		: backup_time_stamp_file ;
      circ_mon 			: circuit_monitor ;
      backup  			: transaction_log_file ;
      op_log			: operator_log ;
      profile_file		: global_user_data ;
      name_file			: global_name_data ;
      host_location_file	: global_host_location_data;
      host_status_file		: global_host_status_data;
      probe_password_file	: global_supervisor_data;
$if reload
      xom_host_file		: global_xom_data;
$endif reload
$if ddt
      host_number_file		: node_list_manager;
$endif ddt
$if    clusternodes
      cluster_file		: global_cluster_data;
$endif clusternodes
$if    background
      job_file			: global_job_data;
$endif background
$if    xom_restore
      xom_file_mng		: xom_file_manager;
$endif xom_restore
      misc_file			: miscellaneous_data ) ;


var
  sleepy			: sleeper;
  format			: internal_to_string;
  oper_msgs			: operator_messages;
$if    xom_restore
  xom_file_operator		: xom_file_utility;
  xom_backup			: xom_backup_operator;
$endif xom_restore
  next_file_needing_update	: fifo ;
  circ_hdl     			: circuit_handler ;
  circuit			: backup_circuit_handler ;
  reader			:  message_reader;
  GIK_data			: getting_in_the_know_data_converter;
  sizer				: transaction_log_data_sizer;
  the_message			: backup_message_type;
  transaction			: transaction_log_max_entry;
  break_it			: boolean ;
!
(********************** transaction_sender_process **********************)
(*									*)
(*				initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

begin
  init sleepy;
  init sizer;
  init format;
  init oper_msgs(op_log, format);
$if    xom_restore
  init xom_file_operator (oper_msgs, format, backup, xom_file_mng);
  init xom_backup (format, oper_msgs, backup, xom_file_operator);
$endif xom_restore
  init circ_hdl;
  init
      circuit(
	partner_host_number, my_proc_id, partner_proc_id, circ_mon,
	circ_hdl, op_log);
  init reader(circuit);
  init next_file_needing_update(backup_file_index_max);
  init
    GIK_data(
      circuit,
      oper_msgs,
      profile_file,
      name_file,
      host_location_file,
      host_status_file,
      probe_password_file,
$if reload
      xom_host_file,
$endif reload
$if ddt
      host_number_file,
$endif ddt 
$if    clusternodes
      cluster_file,
$endif clusternodes
$if    background
      job_file,
$endif background
$if    xom_restore
      xom_backup,
$endif xom_restore
      misc_file ) ;

  circuit.identify_process('Transaction Sender\ ')

end (* intialize  *) ;
!
(********************** transaction_sender_process **********************)
(*									*)
(*			GIK_send_simple_file_updates			*)
(*									*)
(************************************************************************)



procedure GIK_send_simple_file_updates(
      this_file		: backup_file_index ;
      my_sendlev	: level_site_array ;
      partner_knowlev	: level_site_array );

var
  per_site	: site_index;
  first_stamp	: transaction_stamp_element ;
  last_stamp	: transaction_stamp_element ;
  the_index	: backup_ts_indicator ;

begin
  for per_site := SITE_FIRST to SITE_LAST do
    begin
      first_stamp.time := 0;
      first_stamp.site := per_site;
      repeat
	time_stamps.next_item_after (
	  this_file, first_stamp, last_stamp, the_index);

	if (the_index <> BACKUP_TS_INDEX_ABSENT) and
	   (first_stamp.time <= my_sendlev[per_site]) and
	   (last_stamp.time > partner_knowlev[per_site])
	then
	  begin
	    transaction.head.stamp := first_stamp;
	    GIK_data.supply_recovery_data (this_file, the_index, transaction)
	  end
      until (the_index = BACKUP_TS_INDEX_ABSENT) or
	    (first_stamp.time >= my_sendlev[per_site]) or
	    not circuit.built
    end (* for *) ;

  circuit.send_message_type (END_OF_FILE_RECOVERY)
end (* GIK_send_simple_file_updates *) ;
!
(********************** transaction_sender_process **********************)
(*									*)
(*		     GIK_send_clearable_file_updates		 	*)
(*									*)
(*	Getting-in-the-Know Sender for Clearable Files. 		*)
(*									*)
(************************************************************************)


procedure GIK_send_clearable_file_updates(
      this_file		: backup_file_index;
      my_sendlev	: level_site_array;
      partners_knowlev	: level_site_array);

var
  per_site	: site_index;
  first_stamp	: transaction_stamp_element ;
  last_stamp	: transaction_stamp_element ;
  the_index	: backup_ts_indicator ;

begin
  for per_site := SITE_FIRST to SITE_LAST do
    begin
      first_stamp.time := 0;
      first_stamp.site := per_site;
      repeat 
	time_stamps.next_item_after (
	  this_file, first_stamp, last_stamp, the_index);

	if (the_index <> BACKUP_TS_INDEX_ABSENT) and
	   (first_stamp.time <= my_sendlev[per_site]) and
	   (last_stamp.time > partners_knowlev[per_site])
	then circuit.send_clearable_file_recovery_message (first_stamp )

      until (the_index = BACKUP_TS_INDEX_ABSENT) or
	    (first_stamp.time >= my_sendlev[per_site]) or
	    not circuit.built;

      circuit.send_message_type (END_OF_CLEARABLE_FILE_RECOVERY_LIST)
    end (* for *)
end (* GIK_send_clearable_file_updates *) ;
!
(********************** transaction_sender_process **********************)
(*									*)
(*			GIK_send_file_updates			 	*)
(*									*)
(*	offer file to the data to the partner, and initiate sending	*)
(*	if accepted.							*)
(*									*)
(************************************************************************)


procedure GIK_send_file_updates(
      this_file		: backup_file_index ;
      my_sendlev	: level_array;
      partners_knowlev	: level_array) ;

begin
  if sizer.clearable (this_file)
  then
    GIK_send_clearable_file_updates (
      this_file, my_sendlev[this_file], partners_knowlev[this_file]);

  GIK_send_simple_file_updates (
      this_file, my_sendlev[this_file], partners_knowlev[this_file])
end (* GIK_send_file_updates *) ;
!
(********************** transaction_sender_process **********************)
(*									*)
(*			getting_in_the_know_sender		 	*)
(*									*)
(*	This is the executive procedure for the sending side of the	*)
(*	G-I-K operation.						*)
(*									*)
(************************************************************************)


procedure getting_in_the_know_sender;

var
  my_sendlev		: level_array;
  partners_knowlev	: level_array;
  this_file		: backup_file_index;

begin
  backup.get_sendlev(my_sendlev);
  reader.one_message_type (REQUEST_FOR_SENDLEV_ARRAY);
  circuit.send_level_array_message (my_sendlev);

  circuit.send_message_type (REQUEST_FOR_KNOWLEV_ARRAY);
  reader.level_array_message (partners_knowlev);

  repeat
    reader.either_message_type (
      FILE_NEEDS_RECOVERY, DONE_WITH_GIK_SCAN, the_message );
    if reader.okay and (the_message = FILE_NEEDS_RECOVERY)
    then
      begin
	circuit.read_file_needs_recovery_message_body (this_file);
	GIK_send_file_updates (this_file, my_sendlev, partners_knowlev);
      end
  until (not circuit.built) or (the_message = DONE_WITH_GIK_SCAN)
end (* getting_in_the_know_sender *) ;
!
(********************** transaction_sender_process **********************)
(************************************************************************)

begin
  initialize;
  cycle
    circuit.init_circuit;
    getting_in_the_know_sender;
    while circuit.built do
      begin
	backup.get_transaction(partner, transaction, break_it);
	if break_it
	then circuit.zap (TRANSACTION_LOG_HICCUPPED);
	if circuit.built
	then
	  begin
	    circuit.send_transaction_message (
	      TRANSACTION_NOTIFICATION, transaction);
	    reader.one_message_type (TRANSACTION_NOTIFICATION_ACKNOWLEDGE);
	    if reader.okay
	    then backup.remove_transaction (partner, transaction.head);
	  end
      end (* while circuit.built *)
  end (* cycle *)
end (* transaction_sender_process *) ;
$endif auto_backup
 !
(************************************************************************)
(*                                                                      *)
(*      XCUTE.TMS Updated 28-Sep-87 at 17:37 by Raffo			*)
(*                                                                      *)
(*				execution 				*)
(*                                                                      *)
(*	This process handles all interaction with one user		*)
(*                                                                    	*)
(*	The following identifiers must be defined externally:	      	*)
(*                                                                    	*)
(************************************************************************)
(*                                                                    	*)
(*                         Revision Record			      	*)
(*                                                                    	*)
(*	20Jan86 Original (from (tmcssource)XCUTE.TMS) -- gde		*)
(*                                                                    	*)
(************************************************************************)


type
  execution =
    process(
      user			: user_index;
      job_common		: global_job_data;
$if alarm
      condition_log		: condition_log_manager;
$endif
      misc_common	     	: miscellaneous_data;
      user_common            	: global_user_data;
      user_message           	: user_communications;
      network_common         	: network_state_description;
      host_location_common   	: global_host_location_data;
      name_common            	: global_name_data;
      supervisor_common      	: global_supervisor_data;
      node_file              	: node_buffer;
      host_file              	: host_buffer;
      link_file              	: link_buffer;
      port_file              	: port_buffer;
      buffer_pool		: shared_buffer_pool;
$if    clusternodes
      cluster_common		: global_cluster_data;
$endif clusternodes     
$if    reload
      kernel_file		: kernel_buffer;
      host_slot_file		: host_slot_buffer;
$endif reload
$ifany (reload, xcom)
      slot_file              	: slot_buffer;
$endif any reload xcom
$if reload
      reload_file	     	: reload_control;
$endif reload
$ifany (reload, xcom)
      xom_common		: global_xom_data;
$endif any reload xcom
      statistics             	: statistics_gatherer;
      vat                    	: vat_manager;
      vfdd                   	: vfdd_manager;
      dir                    	: directory;
      oplog                  	: operator_log;
$if   auto_backup
      time_stamps		: backup_time_stamp_file;
      backup			: transaction_log_file;
$endif auto_backup
      commands			: command_table;
      license_operator		: license_utility;
      multiplexer            	: probe_multiplexer;
      logger_unit            	: aux_circuit_unit_index;
      remote_greeting_common 	: global_remote_greeting_data;
      host_status_common     	: global_host_status_data;
      sysmsg1_access		: sysmsg1_access_manager;
$if condition
      condition_common       	: threshold_condition_data;
$endif      
$if alarm
      alarm_common		: alarm_data;
$endif alarm
$if archive
      tape_attacher          	: tape_allocater;
$endif archive
$ifany (xom, xom_restore)
      xom_misc_data             : xom_miscellaneous_data;
$endif any xom xom_restore
$if xom_restore
      xom_file_mng              : xom_file_manager;
      xom_restore_file_mng      : xom_restore_file_manager;
$endif xom_restore
$ifany (xray,ddt)
      node_list			: node_list_manager;
$endif
$if xray
      xray_data                 : xray_data_manager;
      crypto_log		: xray_crypto;
$endif xray
$if spc
      connection		: spc_connect;
      data_transfer		: spc_data_transfer;
$endif spc
      log_message_common	: log_message_interpret
  );

var
  user_terminal			: circuit_handler;
  aux_circuit_handler		: circuit_handler;
  format			: internal_to_string;
$if background
  job_status			: job_status_control;
$endif background
  response_buffer		: text_buffer;
  profile			: user_profile;
  oper_messages			: operator_messages;
  message_operator		: message_utility;
  printer			: set_printer;
  display_screen		: screen;
  displayer			: display_formatter;
  display			: display_execution;
  
  argument_scan			: argument_scanner;
  keyword_util			: keyword_utility;
  command_scan			: command_scanner;
  scan_error			: command_error_message;
  command_read			: command_loop;
$ifany (reload, xcom)
  reloader			: reload_execution;
$endif any reload xcom
$if alarm
  alarmer			: alarm_execution;
$endif alarm
$if probe
  probe				: probe_execution;
$endif probe
$if ddt
  ddt				: ddt_communication;
$endif
$if    xom
  xom				: xom_commands;
$endif xom
$if xray
  xray          	        : xray_commands;
$endif xray
$if archive
  archivist			: archive_commands;
$endif archive

  logger			: log_command_handler;
  maintain_users		: userdata_maintenance;
  profile_subsystem_commands	: profile_subsystem_command_handler;
  main_profile_commands		: main_profile_command_handler;
$if alarm
  alarm_subsystem_commands	: alarm_subsystem_command_handler;
$endif alarm
  main_recurring_commands	: main_recurring_command_handler;
  main_remote_greeting_commands	: main_remote_greeting_command_handler;
  main_host_message_commands	: main_host_message_command_handler;
$if clusternodes
  main_cluster_commands		: main_cluster_command_handler;
$endif clusternodes
  main_operator_commands	: main_operator_command_handler;
  main_name_commands		: main_name_command_handler;
  main_debug_commands		: main_debug_command_handler;
  global_select_commands	: global_select_command_handler;


(****************************  execution  *******************************)
(*									*)
(*		     	      initialize				*)
(*									*)
(*									*)
(************************************************************************)



procedure initialize;

begin
  init
    user_terminal,
    aux_circuit_handler;

  init
    format,
$if background
    job_status(user, user_terminal, job_common),
$endif background
    response_buffer(user, oplog, format, buffer_pool),
    profile(user, misc_common, user_common, response_buffer),
    oper_messages(oplog, format),
    message_operator(oper_messages, user_terminal, profile, format),
    printer(user_terminal, license_operator, format),

    display_screen (user, user_terminal, profile, response_buffer,
      oplog, format, statistics, vat, vfdd, dir),

    displayer (user_terminal, name_common, supervisor_common, profile,    
      format, display_screen),
$if    alarm

    alarmer (user, aux_circuit_handler, logger_unit, user_terminal, job_status,
      condition_log, network_common, condition_common, alarm_common,
      node_file, host_file,
$if    reload
      slot_file,
$endif reload
      profile, statistics, format, oper_messages, response_buffer, displayer,
      argument_scan),
$endif alarm

    display (
      user_terminal, argument_scan,
$if    alarm
      alarmer,
$endif alarm
      network_common, node_file, host_file,
      link_file, port_file, profile, format, displayer),

    argument_scan (supervisor_common, license_operator),
    keyword_util(format, user_terminal, commands, argument_scan),
    command_scan(user_terminal, commands, argument_scan, keyword_util),
    scan_error (user_terminal, format, profile, message_operator),

    logger (
$if    condition
      name_common, condition_common, condition_log,
$if    reload
      slot_file,
$endif reload
$endif condition
      user_terminal, aux_circuit_handler, logger_unit, supervisor_common,
      statistics, format, log_message_common, argument_scan, profile),

    maintain_users (user, user_terminal, user_common, profile, user_message,
      format),

    main_profile_commands (user, user_terminal, command_scan, argument_scan, 
      format, profile, user_common, printer, maintain_users),

    command_read (user, job_common, user_terminal, response_buffer,
      argument_scan, format, command_scan, oplog, oper_messages,
      user_common, profile, user_message, scan_error, commands,
      printer, main_profile_commands),

  
$ifany (reload, xcom)
    reloader
      (aux_circuit_handler, logger_unit, user_terminal, 
$if reload
      job_status, 
$endif reload
      user, multiplexer, supervisor_common, profile, node_file, host_file,
      port_file, 
$if reload
      kernel_file, host_slot_file, 
$endif reload
      slot_file, oplog,
      network_common, format, argument_scan,
      command_scan, 
$if reload
      reload_file, 
$endif reload
      response_buffer, name_common, printer,
$if clusternodes
      statistics, xom_common, cluster_common),
$endif clusternodes
$ifnot clusternodes
      statistics, xom_common),
$endif not clusternodes
$endif any reload xcom

$if probe
    probe (multiplexer, commands, user_terminal, supervisor_common, profile,
      user, format, message_operator, argument_scan, command_read, scan_error,
      command_scan, response_buffer, logger, display),
$endif probe

$if    xom
    xom(
      user, profile, argument_scan, user_terminal, format, printer,
      logger, display, oplog, oper_messages, command_read, scan_error,
      job_common, connection, data_transfer,
$if    xcom
      slot_file, xom_common,
$endif xcom
$if    xom_restore
      statistics, vat, vfdd, dir,
$if    auto_backup
      backup,
$endif auto_backup
      xom_file_mng, xom_restore_file_mng,
$endif xom_restore
      xom_misc_data),
$endif xom
$if xray

    xray(
      user, profile, argument_scan, user_terminal, format, logger, display,
      oper_messages, command_read, scan_error, job_common, name_common,
      connection, data_transfer, commands, xray_data,node_list, crypto_log),
$endif xray


$if ddt
    ddt(
      user,profile, argument_scan, user_terminal, format, oper_messages,
      command_read, job_common, connection, data_transfer, 
      node_list),
$endif

$if archive

    archivist(
      user_terminal, argument_scan,
      format, command_read, scan_error,
      tape_attacher, oper_messages,
      user_common,
      name_common, host_location_common, 
      host_status_common, remote_greeting_common,
$if condition
      condition_common,
$endif condition
$if reload
      reload_file, xom_common,
$endif reload
$if background
      job_common,
$endif background
$if probe
      supervisor_common,
$endif probe
$if clusternodes
      cluster_common,
$endif clusternodes
$if xom_restore
      xom,
$endif xom_restore
$ifany (xray,ddt)
      node_list,
$endif any xray ddt
$if auto_backup
      time_stamps,
      backup,
$endif auto_backup
$if alarm
      alarm_common,
$endif alarm
      misc_common),
$endif archive

    profile_subsystem_commands (user, user_terminal, argument_scan, 
      format, command_read, scan_error, profile,
      user_common, printer, maintain_users),

$if alarm
    alarm_subsystem_commands (user, user_terminal, argument_scan, format,
      command_read, scan_error, printer, response_buffer, alarm_common),

$endif alarm
    main_recurring_commands (user_terminal, format, argument_scan, profile,
      node_file, host_file, port_file, main_profile_commands),

    main_remote_greeting_commands (format, user_terminal, profile,
      command_read, command_scan, argument_scan, remote_greeting_common,
      response_buffer),

    main_host_message_commands (user, user_terminal, format, profile,
      response_buffer, host_status_common, supervisor_common, 
      argument_scan, command_scan, oper_messages, sysmsg1_access, 
      aux_circuit_handler, logger_unit),

$if clusternodes
    main_cluster_commands (user_terminal, format, response_buffer, printer,
      cluster_common, argument_scan, profile),
$endif clusternodes

    main_operator_commands (user, statistics, node_file, host_file,
      link_file, port_file,
      host_location_common, argument_scan,
$if alarm
      alarmer,
$endif alarm
$if reload
      reloader, reload_file, host_slot_file, kernel_file, 
$endif reload
$ifany (reload, xcom)
      slot_file,
$endif any reload xcom
$if background
      job_status, job_common, response_buffer,
$endif background
      misc_common, network_common, host_status_common, user_terminal, format),

    main_name_commands (user_terminal, format, profile, argument_scan,
      host_location_common, name_common, node_file, 
$ifany (xray, ddt)
      node_list,
$endif 
      response_buffer),
    
    main_debug_commands (user_terminal, format, profile, printer, 
      argument_scan,
$if debug
      node_file, host_file, link_file, port_file,
$if reload
      reload_file, host_slot_file, kernel_file, 
$endif reload
$ifany (reload, xcom)
      slot_file,
$endif any reload xcom
$endif debug
      network_common),

    global_select_commands (user_terminal, format, profile, printer,
      argument_scan, main_profile_commands)

end (* initialize *) ;



(****************************  execution  *******************************)
(*									*)
(*		     scan_set_name_command				*)
(*									*)
(*	Scan the set name command.					*)
(*									*)
(************************************************************************)


procedure scan_set_name_command(var scanned: scanned_command);

begin
$if alarm
  if argument_scan.check_keyword(MAIN_SET_CONDITION_KEYWORD, scanned)
  then alarmer.scan_set_boundry_condition_name(scanned)
  else main_name_commands.scan_set_name(scanned)
$endif alarm
$ifnot alarm
  main_name_commands.scan_set_name(scanned)
$endif alarm
end (* scan_set_name_command *) ;



(****************************  execution  *******************************)
(*									*)
(*		        scan_set_entry_command				*)
(*									*)
(*	Scan the set entry command.					*)
(*									*)
(************************************************************************)


procedure scan_set_entry_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_SET_GREETING_KEYWORD, scanned)
  then main_remote_greeting_commands.scan_set_host_entry(scanned)
  else
    if argument_scan.check_keyword(MAIN_SET_HOST_KEYWORD, scanned)
    then main_host_message_commands.scan_set_host_entry(scanned)
    else scanned.status := ARG_MISSING
end (* scan_set_entry_command *) ;




(****************************  execution  *******************************)
(*									*)
(*		     scan_set_message_command				*)
(*									*)
(*	Scan the set message command.					*)
(*									*)
(************************************************************************)


procedure scan_set_message_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_SET_HOST_KEYWORD, scanned)
  then main_host_message_commands.scan_set_host_message(scanned)
  else if argument_scan.check_keyword(MAIN_SET_GREETING_KEYWORD, scanned)
  then main_remote_greeting_commands.scan_set_greeting_message(scanned)
  else scanned.status := ARG_MISSING
end (* scan_set_message_command *) ;



(****************************  execution  *******************************)
(*									*)
(*		     scan_set_recurring_command				*)
(*									*)
(*	Scan the set recurring command.					*)
(*									*)
(************************************************************************)



procedure scan_set_recurring_command(var scanned: scanned_command);

var
  maximum: external_recurring_outage_index;
  decay  : integer;

begin
  argument_scan.freeword_recurring(0, scanned, maximum);

  if scanned.status = CMD_OK
  then argument_scan.freeword_number(1, 10, scanned, decay);

  if scanned.status = CMD_OK
  then
$if reload
    if argument_scan.check_keyword(MAIN_SET_RELOAD_KEYWORD, scanned)
    then reloader.scan_set_reload_recurring(scanned, maximum, decay)
    else main_recurring_commands.scan_set_recurring(scanned, maximum, decay)
$endif reload
$ifnot reload
    main_recurring_commands.scan_set_recurring(scanned, maximum, decay)
$endif not reload

end (* scan_set_recurring_command *) ;




(****************************  execution  *******************************)
(*									*)
(*			scan_set_threshold_command			*)
(*									*)
(*	Scan the set threshold command.					*)
(*									*)
(************************************************************************)



procedure scan_set_threshold_command(var scanned: scanned_command);

var
  threshold: external_recurring_outage_index;

begin
  argument_scan.keyword_recurring(MAIN_SET_THRESHOLD_KEYWORD,
    scanned, threshold);

  if scanned.status = CMD_OK
  then
$if alarm
    if argument_scan.check_keyword(MAIN_SET_CONDITION_KEYWORD, scanned)
    then alarmer.scan_set_boundry_condition_threshold(threshold, scanned)
    else
$endif alarm
$if reload
      if argument_scan.check_keyword(MAIN_SET_RELOAD_KEYWORD, scanned)
      then reloader.scan_set_reload_threshold(scanned, threshold)
      else main_recurring_commands.scan_set_threshold(scanned, threshold)
$endif reload 
$ifnot reload
      main_recurring_commands.scan_set_threshold(scanned, threshold)
$endif not reload
end (* scan_set_threshold_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			    scan_set_command				*)
(*									*)
(*	Scan the set command.						*)
(*									*)
(************************************************************************)



procedure scan_set_command(var scanned: scanned_command);

begin
  case scanned.subcommand of

$if alarm
    MAIN_SET_DESCRIPTION_KEYWORD:
      alarmer.scan_set_boundry_condition_description(scanned);

    MAIN_SET_EVENT_KEYWORD:
      alarmer.scan_set_boundry_condition_event(scanned);

    MAIN_SET_ISIS_KEYWORD:
      alarmer.scan_set_boundry_condition_isis(scanned);

    MAIN_SET_MAXIMUM_KEYWORD:
      alarmer.scan_set_boundry_condition_maximum(scanned);

    MAIN_SET_DECAY_KEYWORD:
      alarmer.scan_set_boundry_condition_decay(scanned);

    MAIN_SET_ACCESS_KEYWORD:
      alarmer.scan_set_alarm_access(scanned);
$endif alarm

$ifany (reload, xcom)
    MAIN_SET_XOM_KEYWORD:
      reloader.scan_set_xom_command(scanned);
$endif any reload xcom

    MAIN_SET_THRESHOLD_KEYWORD:
      scan_set_threshold_command(scanned);

$if probe
    MAIN_SET_PROBE_KEYWORD:
      probe.scan_set_probe_command(scanned);
$endif probe

    MAIN_SET_ENTRY_KEYWORD:
      scan_set_entry_command(scanned);

    MAIN_SET_MESSAGE_KEYWORD:
      scan_set_message_command(scanned);

    MAIN_SET_TIMEOUT_KEYWORD:
      main_host_message_commands.scan_set_timeout_command(scanned);

    MAIN_SET_LOCATION_KEYWORD:
      main_name_commands.scan_set_location_command(scanned);

$ifany (xray, ddt)
    MAIN_SET_KERNEL_KEYWORD:
      main_name_commands.scan_set_kernel_command(scanned);
$endif

    MAIN_SET_NAME_KEYWORD:
      scan_set_name_command(scanned);

$if clusternodes
    MAIN_SET_CLUSTER_KEYWORD:
      main_cluster_commands.scan_set_cluster_command(scanned);
$endif clusternodes

$if background
    MAIN_SET_BACKGROUND_KEYWORD:
      main_operator_commands.scan_set_background_command(scanned);
$endif background

    MAIN_SET_DAYLIGHTSAVINGS_KEYWORD:
      main_operator_commands.scan_set_clear_daylightsavings_command(scanned);

    MAIN_SET_DISPLAY_KEYWORD:
      main_operator_commands.scan_set_display_command(scanned);

    MAIN_SET_DEFAULT_KEYWORD:
      main_profile_commands.scan_set_default_command (scanned);

    MAIN_SET_RECURRINGOUTAGE_KEYWORD:
      scan_set_recurring_command(scanned)
  end (* case *)
end  (* scan_set_command *) ;




(****************************  execution  *******************************)
(*									*)
(*			scan_clear_threshold_command			*)
(*									*)
(*	Scan the clear threshold command.				*)
(*									*)
(************************************************************************)


procedure scan_clear_threshold_command(var scanned: scanned_command);

begin
$if alarm
  if argument_scan.check_keyword(MAIN_CLEAR_CONDITION_KEYWORD, scanned)
  then alarmer.scan_clear_boundry_condition(scanned)
  else
$endif alarm
$if reload
    if argument_scan.check_keyword(MAIN_CLEAR_RELOAD_KEYWORD, scanned)
    then reloader.scan_clear_reload_threshold(scanned)
    else main_recurring_commands.scan_clear_threshold(scanned)
$endif reload
$ifnot reload
    main_recurring_commands.scan_clear_threshold(scanned)
$endif not reload
end (* scan_clear_threshold_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			scan_clear_recurring_command			*)
(*									*)
(*	Scan the clear recurring command.				*)
(*									*)
(************************************************************************)


procedure scan_clear_recurring_command(var scanned: scanned_command);

begin
$if reload
  if argument_scan.check_keyword(MAIN_CLEAR_RELOAD_KEYWORD, scanned)
  then reloader.scan_clear_reload_recurring(scanned)
  else main_recurring_commands.scan_clear_recurring(scanned)
$endif reload
$ifnot reload
  main_recurring_commands.scan_clear_recurring(scanned)
$endif not reload
end (* scan_clear_recurring_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			scan_clear_name_command				*)
(*									*)
(*	Scan the clear name command.					*)
(*									*)
(************************************************************************)


procedure scan_clear_name_command(var scanned: scanned_command);

begin
$if alarm
  if argument_scan.check_keyword(MAIN_CLEAR_CONDITION_KEYWORD, scanned)
  then alarmer.scan_clear_boundry_condition(scanned)
  else main_name_commands.scan_clear_name(scanned)
$endif alarm
$ifnot alarm
  main_name_commands.scan_clear_name(scanned)
$endif not alarm
end (* scan_clear_name_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			scan_clear_message_command			*)
(*									*)
(*	Scan the clear message command.					*)
(*									*)
(************************************************************************)


procedure scan_clear_message_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_CLEAR_HOST_KEYWORD, scanned)
  then main_host_message_commands.scan_clear_host_message(scanned)
  else if argument_scan.check_keyword(MAIN_CLEAR_GREETING_KEYWORD, scanned)
  then main_remote_greeting_commands.scan_clear_greeting_message(scanned)
  else scanned.status := ARG_MISSING
end (* scan_clear_message_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			scan_clear_entry_command			*)
(*									*)
(*	Scan the clear entry command.					*)
(*									*)
(************************************************************************)



procedure scan_clear_entry_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_CLEAR_HOST_KEYWORD, scanned)
  then  main_host_message_commands.scan_clear_host_entry(scanned)
  else if argument_scan.check_keyword(MAIN_CLEAR_GREETING_KEYWORD, scanned)
  then main_remote_greeting_commands.scan_clear_greeting_entry(scanned)
  else scanned.status := ARG_MISSING
end (* scan_clear_entry_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			    scan_clear_command				*)
(*									*)
(*	Scan the clear command.						*)
(*									*)
(************************************************************************)



procedure scan_clear_command(var scanned: scanned_command);

begin
  case scanned.subcommand of

    MAIN_CLEAR_DEFAULT_KEYWORD:
      main_profile_commands.scan_clear_default_command (scanned);

    MAIN_CLEAR_THRESHOLD_KEYWORD:
      scan_clear_threshold_command(scanned);

    MAIN_CLEAR_RECURRINGOUTAGE_KEYWORD:
      scan_clear_recurring_command(scanned);

$if alarm
    MAIN_CLEAR_ACCESS_KEYWORD:
      alarmer.scan_clear_alarm_access(scanned);
$endif alarm

$ifany (reload, xcom)
    MAIN_CLEAR_XOM_KEYWORD:
      reloader.scan_clear_xom_command(scanned);
$endif any reload xcom

$if probe
    MAIN_CLEAR_PROBE_KEYWORD:
      probe.scan_clear_probe_command(scanned);
$endif probe

$ifany (xray, ddt)
    MAIN_CLEAR_KERNEL_KEYWORD:
      main_name_commands.scan_clear_kernel_command(scanned);
$endif

    MAIN_CLEAR_NAME_KEYWORD:
      scan_clear_name_command(scanned);

$if clusternodes
    MAIN_CLEAR_CLUSTER_KEYWORD:
      main_cluster_commands.scan_clear_cluster_command(scanned);
$endif clusternodes

    MAIN_CLEAR_MESSAGE_KEYWORD:
      scan_clear_message_command(scanned);

    MAIN_CLEAR_LOCATION_KEYWORD:
      main_name_commands.scan_clear_location_command(scanned);

    MAIN_CLEAR_ENTRY_KEYWORD:
      scan_clear_entry_command(scanned);

$if background
    MAIN_CLEAR_BACKGROUND_KEYWORD:
      main_operator_commands.scan_clear_background_command(scanned);
$endif background

    MAIN_CLEAR_DAYLIGHTSAVINGS_KEYWORD:
      main_operator_commands.scan_set_clear_daylightsavings_command(scanned);

    MAIN_CLEAR_DISPLAY_KEYWORD:
      main_operator_commands.scan_clear_display_command(scanned)

  end (* case *) 
end (* scan_clear_command *) ;




(****************************  execution  *******************************)
(*									*)
(*			scan_list_threshold_command			*)
(*									*)
(*      Scan the list threshold command.				*)
(*									*)
(************************************************************************)


procedure scan_list_threshold_command(var scanned: scanned_command);

begin
$if reload
  if argument_scan.check_keyword(MAIN_LIST_RELOAD_KEYWORD, scanned)
  then reloader.scan_list_reload_threshold(scanned)
  else main_recurring_commands.scan_list_threshold(scanned)
$endif reload
$ifnot reload
  main_recurring_commands.scan_list_threshold(scanned)
$endif not reload
end (* scan_list_threshold_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			scan_list_recurring_command			*)
(*									*)
(*      Scan the list recurring command.				*)
(*									*)
(************************************************************************)



procedure scan_list_recurring_command(var scanned: scanned_command);

begin
$if reload
  if argument_scan.check_keyword(MAIN_LIST_RELOAD_KEYWORD, scanned)
  then reloader.scan_list_reload_recurring(scanned)
  else main_recurring_commands.scan_list_recurring(scanned)
$endif reload
$ifnot reload
  main_recurring_commands.scan_list_recurring(scanned)
$endif not reload
end (* scan_list_recurring_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			 scan_list_entry_command			*)
(*									*)
(*      Scan the list entry command. 					*)
(*									*)
(************************************************************************)



procedure scan_list_entry_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_LIST_HOST_KEYWORD, scanned)
  then main_host_message_commands.scan_list_host_entry(scanned)
  else if argument_scan.check_keyword(MAIN_LIST_GREETING_KEYWORD, scanned)
  then main_remote_greeting_commands.scan_list_greeting_entry(scanned)
  else scanned.status := ARG_MISSING
end (* scan_list_entry_command *) ;



$ifany (reload, xom_restore, xcom)
(****************************  execution  *******************************)
(*									*)
(*			 scan_list_xom_command   			*)
(*									*)
(*      Scan the list xom command. 					*)
(*									*)
(************************************************************************)


procedure scan_list_xom_command(var scanned: scanned_command);

begin
$if xom_restore
  if argument_scan.check_keyword(MAIN_LIST_DIRECTORY_KEYWORD, scanned)
  then xom.scan_list_xom_directory(scanned)
$ifany (reload, xcom)
$if reload
  else 
    if argument_scan.check_keyword(MAIN_LIST_PENDING_KEYWORD, scanned)
    then reloader.scan_list_xom_pending(scanned)
$endif reload
    else reloader.scan_list_xom(scanned)
$endif any reload xcom
$ifnotany (reload, xcom)
  else scanned.status := ARG_KEYWORD_MISSING
$endif not any reload xcom
$endif xom_restore
$ifnot xom_restore
$if reload
  if argument_scan.check_keyword(MAIN_LIST_PENDING_KEYWORD, scanned)
  then reloader.scan_list_xom_pending(scanned)
  else 
$endif reload
    reloader.scan_list_xom(scanned)
$endif not xom_restore
end (* scan_list_xom_command *) ;
$endif any reload xom_restore xcom



$if reload
(****************************  execution  *******************************)
(*									*)
(*			 scan_list_status_command   			*)
(*									*)
(*      Scan the list reload outage command.				*)
(*									*)
(************************************************************************)


procedure scan_list_status_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_LIST_RELOAD_KEYWORD, scanned)
  then reloader.scan_list_reload_status_command(scanned)
  else scanned.status := CMD_ERROR
end (* scan_list_status_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			scan_list_failure_command   			*)
(*									*)
(*      Scan the list reload failure command.				*)
(*									*)
(************************************************************************)


procedure scan_list_failure_command(var scanned: scanned_command);

begin
  if argument_scan.check_keyword(MAIN_LIST_RELOAD_KEYWORD, scanned)
  then reloader.scan_list_reload_failure_command(scanned)
  else scanned.status := CMD_ERROR
end (* scan_list_failure_command *) ;
$endif reload


(****************************  execution  *******************************)
(*									*)
(*			    scan_list_command				*)
(*									*)
(*      Scan the list command.						*)
(*									*)
(************************************************************************)



procedure scan_list_command(var scanned: scanned_command);

begin
  case scanned.subcommand of

    MAIN_LIST_LIMIT_KEYWORD:
      main_profile_commands.scan_list_limit_command (scanned);

    MAIN_LIST_IGNORE_KEYWORD,
    MAIN_LIST_SELECT_KEYWORD:
      global_select_commands.scan_list_ignore_or_select_command (scanned);

$if alarm
    MAIN_LIST_ACCESS_KEYWORD:
      alarmer.scan_list_access_command(scanned);
$endif alarm

    MAIN_LIST_TERMINAL_KEYWORD:
      main_profile_commands.scan_list_terminal_command(scanned);

    MAIN_LIST_THRESHOLD_KEYWORD:
      scan_list_threshold_command(scanned);

    MAIN_LIST_RECURRINGOUTAGE_KEYWORD:
      scan_list_recurring_command(scanned);

$ifany (xray, ddt)
    MAIN_LIST_KERNEL_KEYWORD:
      main_name_commands.scan_list_kernel_command(scanned);
$endif

    MAIN_LIST_NAME_KEYWORD:
      main_name_commands.scan_list_name_command(scanned);

$if clusternodes
    MAIN_LIST_CLUSTER_KEYWORD:
      main_cluster_commands.scan_list_cluster_command(scanned);
$endif clusternodes

$if condition
    MAIN_LIST_BOUNDRY_KEYWORD:
      alarmer.scan_list_boundry_command(scanned);
$endif condition

    MAIN_LIST_LOCATION_KEYWORD:
      main_name_commands.scan_list_location_command(scanned);

    MAIN_LIST_ENTRY_KEYWORD:
      scan_list_entry_command(scanned);

    MAIN_LIST_MESSAGE_KEYWORD:
      main_host_message_commands.scan_list_message_command(scanned);

$if reload
    MAIN_LIST_CONFIGURATION_KEYWORD:
      reloader.scan_list_configuration_command(scanned);

    MAIN_LIST_ACTIVE_KEYWORD:
      reloader.scan_list_active_command(scanned);

    MAIN_LIST_DEACTIVE_KEYWORD:
      reloader.scan_list_deactive_command(scanned);

    MAIN_LIST_STATUS_KEYWORD:
      scan_list_status_command(scanned);

    MAIN_LIST_SUSPENDED_KEYWORD:
      reloader.scan_list_suspended_slot_command(scanned);

    MAIN_LIST_FAILURE_KEYWORD:
      scan_list_failure_command(scanned);
$endif reload

$ifany (reload, xom_restore, xcom)
    MAIN_LIST_XOM_KEYWORD:
      scan_list_xom_command(scanned);
$endif any reload xom_restore xcom

    MAIN_LIST_DAYLIGHTSAVINGS_KEYWORD:
      main_operator_commands.scan_list_daylightsavings_command(scanned);

$if background
    MAIN_LIST_BACKGROUND_KEYWORD:
      main_operator_commands.scan_list_background_command(scanned);
$endif background

    MAIN_LIST_DISPLAY_KEYWORD:
      main_operator_commands.scan_list_display_command(scanned)

  end (* case *)
end (* scan_list_command *) ;



(*****************************  execution  ******************************)
(*									*)
(*			   scan_discard_command				*)
(*									*)
(*	Scan the Discard XOM and Limit commands.			*)
(*									*)
(************************************************************************)


procedure scan_discard_command (var scanned: scanned_command);

begin
  case scanned.subcommand of
$if xom_restore
    MAIN_DISCARD_XOM_KEYWORD:
      xom.scan_discard_xom_command (scanned);
$endif xom_restore
    MAIN_DISCARD_LIMIT_KEYWORD:
      main_profile_commands.scan_discard_command (scanned)
  end (* case *)
end (* scan_discard_command *) ;



(*****************************  execution  ******************************)
(*									*)
(*			    scan_quit_command				*)
(*									*)
(*	Scan the Quit command, and if valid, zap user circuit.		*)
(*									*)
(************************************************************************)

procedure scan_quit_command(var scanned: scanned_command);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      format.start;
      format.newline;
      format.string('Logging out at \');
      format.time(profile.time(realtime));
      format.write_line(user_terminal);

      user_terminal.send_yellow_ball;
      repeat
	user_terminal.detect_orange_ball; wait
      until (user_terminal.param.status = ORANGE_BALL) or
	not user_terminal.available;

      user_terminal.clear_circuit;
      job_common.set_state(user, JOB_QUIT_COMMAND)
    end
end (* scan_quit_command *) ;



(****************************  execution  *******************************)
(*									*)
(*			    scan_command				*)
(*									*)
(*	This is the main scanning routine.				*)
(*      It reads main commands and eventually changes context.		*)
(*									*)
(************************************************************************)


procedure scan_command;

var
  scanned: scanned_command;

begin
  command_read.add_context(MAIN_CONTEXT);

  repeat
    command_read.get_command(scanned);
    if user_terminal.available
    then
      begin
	command_read.remove_context(MAIN_CONTEXT);
	
	case scanned.command of
	  MAIN_SET:
	    scan_set_command(scanned);

    	  MAIN_CLEAR:
	    scan_clear_command(scanned);

	  MAIN_LIST:
	    scan_list_command(scanned);

	  MAIN_SAVE:
      	    main_profile_commands.scan_save_command (scanned);

    	  MAIN_DISCARD,
	  MAIN_DELETE:
	    scan_discard_command (scanned);

	  MAIN_LOG:
	    logger.scan_command (scanned);

	  MAIN_DISPLAY:
	    display.scan_command (scanned);

$if xom_restore
	  MAIN_COPY:
	    xom.scan_copy_xom_command (scanned);

$endif xom_restore
$if background
	  MAIN_ATTACH:
	    main_operator_commands.scan_attach_command(scanned);

	  MAIN_START:
	    main_operator_commands.scan_start_command(scanned);
$endif background

	  MAIN_STATISTICS:
	    main_operator_commands.scan_statistics_command(scanned);

	  MAIN_TERMINAL:
	    main_profile_commands.scan_terminal_command(scanned);

	  MAIN_NSD:
	    main_debug_commands.scan_nsd_command (scanned);

$if reload
	  MAIN_RELOAD:
	    reloader.scan_reload_command(scanned);

	  MAIN_ACTIVATE,
	  MAIN_DEACTIVATE:
	    reloader.scan_activate_deactivate_command(scanned);
$endif reload

	  MAIN_PROFILE:
	    profile_subsystem_commands.scan_profile_command(scanned);

$if alarm
	  MAIN_ALARM:
	    alarm_subsystem_commands.scan_alarm_command(scanned);
$endif alarm
$if xray
	  MAIN_XRAY:
	    xray.scan_xray_command(scanned);
$endif

$ifany (xom, xom_restore)
	  MAIN_XOM:
	    xom.scan_xom_command(scanned);

$endif any xom xom_restore
$if    xcom
	  MAIN_XCOM:
	    xom.scan_xcom_command(scanned);

$endif xcom

$if ddt
          MAIN_DDT:
	    ddt.scan_ddt_command(scanned);
$endif

$if probe
	  MAIN_PROBE:
	    probe.scan_probe_command(scanned);
$endif probe

$if archive
	  MAIN_ARCHIVE:
	    archivist.scan_archive_command(scanned);
$endif archive

	  MAIN_QUIT:
	    scan_quit_command(scanned)

	end (* case *) ;

	command_read.add_context(MAIN_CONTEXT);

	scan_error.display_command_error(scanned)
      end (* if user_terminal.available *)
  until not user_terminal.available;
  
  job_common.set_state(user, JOB_CIRCUIT_ZAPPED)
end (* scan_command *) ;




(****************************  execution  *******************************)
(*									*)
(*				login					*)
(*									*)
(*	Login the user process. Either by requesting a user name from	*)
(*	terminal, using an attaching user name or run a background	*)
(*	job with specified username.					*)
(*									*)
(************************************************************************)


function login : job_state;

const
$if background
  NEEDLE_READ_TIMEOUT = 60 (* seconds *) ;
$endif
$ifnot background
  NEEDLE_READ_TIMEOUT = 0 (* seconds *) ;
$endif

var
  job_data   : job_descriptor;

begin
  oplog.initial_user_sequence (user);
  job_common.start (user, job_data);
  case job_data.state of
$if background
    JOB_COMMAND:
      begin
	user_terminal.use_circuit (
	  job_data.unit, terminal, [complete, break_key]);
	user_terminal.write_message ('Job ended before successful attach\ ');
	if not maintain_users.set_username (job_data.username)
	then job_common.set_state (user, JOB_NO_USERNAME)
      end (* JOB_COMMAND *) ;

$endif background
$ifany (alarm,reload)
    JOB_ALARM,
    JOB_RELOAD:
      if maintain_users.set_username (job_data.username)
      then
	job_status.setup (TRUE)
      else
	begin
	  job_common.set_state (user, JOB_NO_USERNAME);
	  job_common.clear_background (user);
	  format.start;
	  format.string ('No profile for user name \');
	  format.symbol_string (job_data.username);
	  format.string (' clearing background job \');
	  format.number (user, 10);
	  oper_messages.save_message (OPERATOR_LICENSE)
	end (* JOB_ALARM, JOB_RELOAD *) ;

$endif any (alarm,reload)
    JOB_LOGIN:
      begin
	user_terminal.login ( job_data.unit, 0,
	  [complete, break_key], NEEDLE_READ_TIMEOUT);
	if not user_terminal.available
	then job_common.set_state (user, JOB_NEEDLE_TIMEOUT)
	else
	  begin
	    user_terminal.set_alternate_break( '(:27:)');
	    user_terminal.write_message (banner_title);
	    user_terminal.write_newline;
	    if not maintain_users.login
	    then job_common.set_state (user, JOB_LOGIN_TIMEOUT)
	    else
	      begin
		job_common.set_username (user, profile);
		job_common.set_state (user, JOB_COMMAND);
		format.start;
		format.newline;
		format.string ('host: \ ');
		format.number (user_terminal.login_info.host_number, 10);
		format.skip (3);
		format.time (profile.time(realtime));
		format.write_line (user_terminal)
	      end
	  end
      end (* JOB_LOGIN *) 
  end (* case *) ;

  if job_common.check_status (user)
  then login := job_data.state
  else login := JOB_LOGIN
end (* login *) ;



(****************************  execution  *****************************)
(**********************************************************************)



begin (* initial statement *)
  initialize;

  cycle
    case login of
$if alarm
      JOB_ALARM:
	begin
	  alarmer.start_alarm;
	  if job_status.detached and job_common.check_status (user)
	  then job_common.set_state (user, JOB_HUNG)
	end (* JOB_ALARM *) ;
$endif
$if reload
      JOB_RELOAD:
	begin
	  reloader.start_reload (FALSE);
	  if job_status.detached and job_common.check_status (user)
	  then job_common.set_state (user, JOB_HUNG)
	end (* JOB_RELOAD *) ;
$endif
      JOB_LOGIN,
      JOB_COMMAND: (* empty *)
  
    end (* case *) ;

    if job_common.check_status (user)
    then
     begin
       job_common.set_state (user, JOB_COMMAND);
       scan_command
     end;

    maintain_users.logout

  end (* cycle *)
end (* execution *) ;
!
(**********************************************************************)
(*                                                                    *)
(*	CLOCK.TMS						      *)
(*                           general_clock                            *)
(*                                                                    *)
(*    This process is the clock used by all of TMCS. It is given      *)
(*    access to all monitors that want to be ticked.                  *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*    16Sep81    Original -- rer                                      *)
(*                                                                    *)
(**********************************************************************)



type general_clock = process(network_common: network_state_description);

begin
  cycle
    network_common.tick;
    wait
  end (* cycle *)
end (* general_clock *) ;
   !
(**********************************************************************)
(*						      		      *)
(*	INIT.TMS  Updated 25-Sep-87 at 16:14 by Raffo		      *)
(*                                                                    *)
(*                          initial process                           *)
(*                                                                    *)
(*     Initializes the entire TMCS system.                            *)
(*                                                                    *)
(*     The following identifiers must be defined externally:          *)
(*       terminal_unit_index    aux_circuit_unit_index                *)
(*       general_clock          operator_log                          *)
(*       circuit_handler        global_user_data                      *)
(*       node_buffer            network_state_decription              *)
(*       host_buffer            global_host_location_data             *)
(*       link_buffer            port_buffer                           *)
(*       neighbor_buffer        global_name_data                      *)
(*       user_index             global_supervisor_data                *)
(*       execution              main_command_table                    *)
(*       keyword_table          probe_command_table                   *)
(*       user_command_table     probe_multiplexer                     *)
(*       supervisor_index       probe_reader                          *)
(*       probe_demon            probe_gather                          *)
(*       log_gather             node_gather                           *)
(*       host_gather            vat_manager                           *)
(*       vfdd_manager           directory                             *)
(*       statistics_gatherer    global_remote_greeting_data           *)
(*       tape_allocator         remote_greeting_clear                 *)
(*       user_communications    message_string                        *)
(*	 miscellaneous_data     shut_link_table_maintenance	      *)
(*	 sysmsg1_access_manager	   configuration_monitor    	      *)
(*       backup_time_stamp_file 	mark_monitor                  *)
(*       discontent_monitor	transaction_log_file                  *)
(*       circuit_monitor 	message_dispatcher                    *)
(*       host_number		site_index                            *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*    02jul80    Original -- rer                                      *)
(*    22Jun81    add tape_allocater -- jnm			      *)
(*    25Jun81    don't init initialize terminal if no errors -- rer   *)
(*    18Aug81    remove unit and logical volume concept - rer	      *)
(*    10Dec81	 Add USER_COMMUNICATIONS monitor for SEND             *)
(*               command  ---  ebs                                    *)
(*    29Mar83    Changed startup_error procedure to repeat printing   *)
(*               of startup errors so each user who logs in           *)
(*               following a startup error will receive the message   *)
(*               (to insure that appropriate message will print       *)
(*               to terminal of all interested parties.) .            *)
(*    11Apr83    Added call to vat_manager procedure update to        *)
(*               modify the volumn_label incarnation_number to be     *)
(*               equal to the current_incarnation number constant     *)
(*               signifying version change  ---  bss                  *)
(*     5May83    Added initializing of misc_data_file --- rer	      *)
(*    16Jun83    Added misc_common to calling sequence of node_file   *)
(*               (node_buffer)  ---  bss                              *)
(*    02Dec83    Added misc_common to calling sequence of host_file   *)
(*		 (host_buffer) and port_file (port_buffer)  ---  bss  *)
(*    29Dec83    Added procedure verify_volume_label_data (called by  *)
(*		 reset_disk_system), to check that all volume label   *)
(*		 fields are as they should be   ---   bss	      *)
(*     2Jul84    Added reload_control and threshold_condition 	      *)
(*               monitors and passing access of them to the           *)
(*		 execution process   ---   bss                        *)
(*    17Apr85	 Added log_message_interpret monitor - ahm	      *)
$if    shut_link_table_maintenance
(*    15Aug85	 Added shut_link_table_maintainer process  -  ahm     *)
$endif shut_link_table_maintenance
(*    15Aug85    Added sysmsg1_access_manager monitor  -  ahm	      *)
(*    20Jan86	 Removed tymnetone  -  ahm			      *)
(*    20Jan86    Convert to version 11.0 -- gde			      *)
(*    01Apr86   Added support for Automatic Backup -- dlp		*)
(*                                                                    *)
(**********************************************************************)


(*  status code for verifying of volume label data  *)
type
  volume_label_verify_status = (
    no_error, incarnation_error, configuration_error );
    
const
  incarnation_error_text   = 'disk incarnation number error\';
  configuration_error_text = 'disk configuration error\ ';


var
  next_aux_circuit              : aux_circuit_unit_index;
  ticker                        : general_clock;
  oplog                         : operator_log;
  error_terminal                : circuit_handler;
  misc_common			: miscellaneous_data;
  user_common                   : global_user_data;
  network_common                : network_state_description;
  host_location_common          : global_host_location_data;
  node_file                     : node_buffer;
  host_file                     : host_buffer;
  link_file                     : link_buffer;
  port_file                     : port_buffer;
  buffer_pool			: shared_buffer_pool;
$if    clusternodes
  cluster_common		: global_cluster_data;
$endif clusternodes
$if    reload
  kernel_file			: kernel_buffer;
  host_slot_file		: host_slot_buffer;
$endif reload
$ifany (reload, xcom)
  slot_file			: slot_buffer;
$endif any reload xcom
  name_common                   : global_name_data;
  supervisor_common             : global_supervisor_data;
  job_common			: global_job_data;
  user                          : array [user_index] of execution;
  commands			: command_table;
  license_operator		: license_utility;
  multiplex                     : probe_multiplexer;
  probe_access                  : array [supervisor_index] of probe_reader;
  probe_tickler                 : probe_demon;
  probe_gatherer                : probe_gather;
  log_gatherer                  : log_gather;
  node_gatherer                 : node_gather;
$if    condition
  condition_common		: threshold_condition_data;
  condition_log			: condition_log_manager;
$endif condition
$if alarm
  alarm_common			: alarm_data;
$endif alarm
$ifany (reload, xcom)
  xom_common			: global_xom_data;
$endif any reload xcom
$if    reload
  xom_gatherer			: xom_gather;
  reload_file			: reload_control;
$endif reload
  vat                           : vat_manager;
  vfdd                          : vfdd_manager;
  dir                           : directory;
  statistics                    : statistics_gatherer;
  remote_greeting_common        : global_remote_greeting_data;
  greeting_clearer              : remote_greeting_clear;
  host_status_common		: global_host_status_data;
  host_status_house_keeper	: host_status_house_keeping;
  user_message                  : user_communications;
  log_message_common		: log_message_interpret;	
$if    shut_link_table_maintenance
  shut_link_table_maintainer	: shut_link_table_maintenance;
$endif shut_link_table_maintenance
  sysmsg1_access		: sysmsg1_access_manager;

$ifany (xray,ddt)
  node_list			: node_list_manager;
$endif any xray ddt
$if    xray
  xray_data             	: xray_data_manager;
  crypto_log			: xray_crypto;
$endif xray
$if    archive
  tape_attacher 		: tape_allocater;
$endif archive
$if    spc
  connection			: spc_connect;
  data_transfer			: spc_data_transfer;
  port_handler			: array [spc_port_index] of spc_port_handler;
$endif spc
$if    xom
  xom_misc_data         	: xom_miscellaneous_data;
$endif xom
$if    xom_restore
  xom_file_mng          	: xom_file_manager;
  xom_restore_file_mng  	: xom_restore_file_manager;
$endif xom_restore
$if    auto_backup
  config_mon			: configuration_monitor;
  mark_mon			: mark_monitor;
  time_stamps			: backup_time_stamp_file;
  griper			: discontent_monitor;
  txn_log			: transaction_log_file;
  backup_circuit		: array [partner_index] of circuit_monitor;
  dispatcher			: array [partner_index] of message_dispatcher;
  txn_sender		: array [partner_index] of transaction_sender_process;
  txn_receiver         : array [partner_index] of transaction_receiver_process;
$endif auto_backup

(*************************  initial process  **************************)
(*                                                                    *)
(*                           startup_error                            *)
(*                                                                    *)
(*    Initialize error_terminal to print error message                *)
(*    if not already done. This insures that error terminal is only   *)
(*    needed if there is an error.  Continues to cycle through        *)
(*    login - message printing - logout    as long as error 	      *)
(*    condition persists.					      *)
(*                                                                    *)
(**********************************************************************)



procedure startup_error (message : message_string);

begin
  (* get a terminal to print then *) 
  init error_terminal;

  cycle
    error_terminal.login (0, 0, [complete], 0) 
    		(* get someone to see messages *) ;
    error_terminal.write_message ('system initialization errors\ ');
    error_terminal.write_message (message) ;
    error_terminal.clear_circuit;
  end (* cycle *)

end (* startup_error *) ;



(*************************  initial process  ****************************)
(*									*)
(*		       verify_volume_label_data	     			*)
(*									*)
(*	Read and verify that disk and code constant values for the	*)
(*	incarnation number/configuration parameters agree.		*)
(*									*)
(************************************************************************)


procedure verify_volume_label_data (
  var verify_status	: volume_label_verify_status );

var
  label	: volume_label;
  
begin
  verify_status :=  NO_ERROR;
  
  (*  get the current volume label from the disk  *)
  vat.lookup_volume_label (label);
  
  (*  verify incarnation number on disk is not greater than constant  *)
  if label.incarnation_number <> CURRENT_INCARNATION
  then
    verify_status := INCARNATION_ERROR;
    
  (*  verify configuration parameters  *)
  if verify_status = NO_ERROR
  then
    if (label.configuration.user_max      	    <> USER_MAX) 
    or (label.configuration.username_max  	    <> USERNAME_MAX) 
    or (label.configuration.limit_set_max 	    <> LIMIT_SET_MAX) 
    or (label.configuration.user_message_max        <> USER_MESSAGE_MAX) 
    or (label.configuration.supervisor_max          <> SUPERVISOR_MAX) 

    or (label.configuration.node_configuration_max          <> 
    		NODE_CONFIGURATION_MAX)
    or (label.configuration.host_configuration_max          <>
	        HOST_CONFIGURATION_MAX) 

    or (label.configuration.links_per_node          <> LINKS_PER_NODE) 
    or (label.configuration.ports_per_node          <> PORTS_PER_NODE) 
    or (label.configuration.link_shut_percentage    <> LINK_SHUT_PERCENTAGE) 
    or (label.configuration.port_out_percentage     <> PORT_OUT_PERCENTAGE) 
    or (label.configuration.tymnet_ii_node_max      <> TYMNET_II_NODE_MAX)
    or (label.configuration.host_number_max         <> HOST_NUMBER_MAX)
    or (label.configuration.oper_log_page_max	    <> OPER_LOG_PAGE_MAX)
    or (label.configuration.reload_feature	    <> RELOAD_FEATURE)
    or (label.configuration.alarm_feature	    <> ALARM_FEATURE)
    or (label.configuration.threshold_condition_max <> THRESHOLD_CONDITION_MAX)
    or (label.configuration.condition_log_length    <> CONDITION_LOG_LENGTH)
    or (label.configuration.host_status_message_max <> HOST_STATUS_MESSAGE_MAX)
    or (label.configuration.xom_host_max	    <> XOM_HOST_MAX)
    or (label.configuration.pages_per_xomhost	    <> PAGES_PER_XOMHOST)
    or (label.configuration.probe_feature	    <> PROBE_FEATURE)
    or (label.configuration.background_feature	    <> BACKGROUND_FEATURE)
    or (label.configuration.xom_feature		    <> XOM_FEATURE)
    or (label.configuration.xom_restore_feature     <> XOM_RESTORE_FEATURE)
    or (label.configuration.xray_feature	    <> XRAY_FEATURE)
    or (label.configuration.ddt_feature		    <> DDT_FEATURE) 
    or (label.configuration.number_of_node_alarms   <> NUMBER_OF_NODE_ALARMS)
    or (label.configuration.number_of_host_alarms   <> NUMBER_OF_HOST_ALARMS)
    or (label.configuration.number_of_link_alarms   <> NUMBER_OF_LINK_ALARMS)
    or (label.configuration.number_of_slot_alarms   <> NUMBER_OF_SLOT_ALARMS)
    or (label.configuration.number_of_general_alarms<> NUMBER_OF_GENERAL_ALARMS)
    then
      verify_status := CONFIGURATION_ERROR

end (* verify_volume_label_data *) ;



(**************************  initial process  ***************************)
(*									*)
(*			   label_read_failed			 	*)
(*									*)
(*	One of a series of breakups to  disclose the nature of the	*)
(*	disk startup error.						*)
(*									*)
(************************************************************************)


procedure label_read_failed;

begin
  startup_error ('volume label read failed\ ')
end  (*  label_read_failed  *) ;




(**************************  initial process  ***************************)
(*									*)
(*			     vfdd_open_error			 	*)
(*									*)
(*	One of a series of breakups to  disclose the nature of the	*)
(*	disk startup error.						*)
(*									*)
(************************************************************************)


procedure vfdd_open_error;

begin
  startup_error ('vfdd open error\')
end  (*  vfdd_open_error  *) ;




(**************************  initial process  ***************************)
(*									*)
(*			disk_incarnation_error			 	*)
(*									*)
(*	One of a series of breakups to  disclose the nature of the	*)
(*	disk startup error.						*)
(*									*)
(************************************************************************)


procedure disk_incarnation_error;

begin
  startup_error (incarnation_error_text)
end  (*  disk_incarnation_error  *) ;




(**************************  initial process  ***************************)
(*									*)
(*			disk_configuration_error		 	*)
(*									*)
(*	One of a series of breakups to  disclose the nature of the	*)
(*	disk startup error.						*)
(*									*)
(************************************************************************)



procedure disk_configuration_error;

begin
  startup_error (configuration_error_text)
end  (*  disk_configuration_error  *) ;





(*************************  initial process  **************************)
(*                                                                    *)
(*                         reset_disk_system                          *)
(*                                                                    *)
(*    Reset the disk file system. Read volume label and open VFDD.    *)
(*                                                                    *)
(**********************************************************************)



procedure reset_disk_system;

var
  vfdd_pointer	: integer;
  ok		: boolean;
  verify_status : volume_label_verify_status;

begin
  init vat  (statistics);
  init vfdd (statistics, vat);
  init dir  (statistics, vat, vfdd);

  vat.reset(vfdd_pointer, ok);
  if not ok 
  then
    label_read_failed
  else
    begin
      vfdd.reset (vfdd_pointer, ok);
      if not ok 
      then
        vfdd_open_error
    end;

  verify_volume_label_data (verify_status);
  case verify_status of
    no_error            : (* nothing *) ;
    incarnation_error   : disk_incarnation_error;
    configuration_error : disk_configuration_error
  end (* case  *) 
end (* reset_disk_system *) ;



(*************************  initial process  **************************)
(*                                                                    *)
(*                         initialize_probe                           *)
(*                                                                    *)
(*    Initialize the probe multiplexer.                               *)
(*                                                                    *)
(**********************************************************************)



procedure initialize_probe;

var
  s	: supervisor_index;

begin
  init multiplex (next_aux_circuit, oplog);

  for s := 0 to SUPERVISOR_LIMIT do
    init probe_access [s] (
	s, next_aux_circuit+s, multiplex, supervisor_common, 
	oplog, statistics);

  next_aux_circuit := next_aux_circuit + SUPERVISOR_MAX;

  init probe_tickler (multiplex, supervisor_common);

  init probe_gatherer (
    statistics, supervisor_common, multiplex, network_common,
    license_operator, commands);

  init node_gatherer (
    statistics, supervisor_common, multiplex, network_common, name_common,
    license_operator, commands);

  init log_gatherer (
    oplog, statistics, supervisor_common, next_aux_circuit, 
$if    alarm
    condition_common, 
$endif alarm
     network_common);
$if    reload

  (* add two to the next_aux_circuit variable for nem and ntcn aux circs *)
  next_aux_circuit := next_aux_circuit + 2;

  init xom_gatherer (
    oplog, statistics, next_aux_circuit-1, next_aux_circuit,
    supervisor_common, license_operator, commands, xom_common);
$endif reload

  next_aux_circuit := next_aux_circuit + 1
end (* initialize_probe *) ;




$if    spc
(******************************  initial  *******************************)
(*									*)
(*			      initialize_spc				*)
(*									*)
(*	Initialize the monitors and processes to run SPC.		*)
(*									*)
(************************************************************************)


procedure initialize_spc;

var
  p: spc_port_index;

begin
  init data_transfer(buffer_pool, oplog);
  init connection(
    data_transfer, oplog);

  for p := 0 to	SPC_PORT_LIMIT do
    init port_handler[p]( p, connection, data_transfer, oplog);

  (***WARNING: The spc_ports must be the first aux circuits initialized *)

  next_aux_circuit := next_aux_circuit + SPC_PORT_MAX
end (* initialize_spc *) ;
$endif spc


(*************************  initial process  **************************)
(*                                                                    *)
(*                         initialize_users                           *)
(*                                                                    *)
(*    Initialize the user execution processes.                        *)
(*                                                                    *)
(**********************************************************************)


procedure initialize_users;

var
  u	: user_index;

begin
  for u := 0 to USER_LIMIT do
    init
      user[u](
	u, 
	job_common, 
$if    condition
	condition_log,
$endif condition
	misc_common, user_common, user_message, network_common,
	host_location_common, name_common, supervisor_common,
	node_file, host_file, link_file, port_file, buffer_pool,
$if    clusternodes
	cluster_common,
$endif clusternodes
$if    reload
	kernel_file, host_slot_file,
$endif reload
$ifany (reload, xcom)
	slot_file, 
$endif any reload xcom
$if reload
	reload_file, 
$endif reload
$ifany (reload, xcom)
	xom_common,
$endif any reload xcom
	statistics, vat, vfdd, dir, oplog,
$if    auto_backup
	time_stamps,
	txn_log,
$endif auto_backup
	commands, license_operator,
	multiplex, next_aux_circuit+u, remote_greeting_common,
	host_status_common, sysmsg1_access,
$if    condition
	condition_common, 
$endif condition
$if alarm
        alarm_common,
$endif alarm
$if    archive
	tape_attacher,
$endif archive
$if    xom
	xom_misc_data,
$endif xom
$if    xom_restore
	xom_file_mng, xom_restore_file_mng,
$endif xom_restore
$ifany (xray,ddt)
	node_list,
$endif any - xray,ddt
$if    xray
	xray_data, crypto_log,
$endif xray
$if    spc
	connection, data_transfer,
$endif spc
	log_message_common);

  next_aux_circuit := next_aux_circuit + USER_MAX
end (* initialize_users *) ;



(*************************  initial process  **************************)
(*                                                                    *)
(*                   update_vat_incarnation_number                    *)
(*                                                                    *)
(*      Update the incarnation number in the volumn label record.     *)
(*                                                                    *)
(**********************************************************************)


procedure update_vat_incarnation_number;

var
  ok : boolean;

begin
  vat.update (ok);
  if not ok 
  then
    startup_error ('volumn label write error\ ')
end (* update_vat_incarnation_number *) ;



(*************************  initial process  ****************************)
(*									*)
(*			      initialize				*)
(*									*)
(*	Process initialization.						*)
(*									*)
(************************************************************************)


procedure initialize;
$if    auto_backup

var
  per_partner			: partner_index;
  partner_host			: host_number;
  my_site_pos			: site_index;

$endif auto_backup
begin
  next_aux_circuit := 0;
  init statistics;

  reset_disk_system (* will never return if error reseting disk *) ;

  init oplog (statistics, vat, vfdd, dir);
$if    auto_backup
  init config_mon;
  my_site_pos := config_mon.my_site_position;
  init mark_mon (my_site_pos);
  init time_stamps (oplog, statistics, vat, vfdd, dir, mark_mon, my_site_pos);
  init griper;
  init txn_log (
    oplog, statistics, vat, vfdd, dir, mark_mon, time_stamps, griper);
$endif auto_backup

  init user_message  (oplog, statistics, vat, vfdd, dir);

  init misc_common   (oplog,
$if    auto_backup
			      txn_log,
$endif auto_backup
				 statistics, vat, vfdd, dir);

  init user_common   (oplog,
$if    auto_backup
			      txn_log,
$endif auto_backup
				 statistics, vat, vfdd, dir);

  init name_common   (oplog,
$if    auto_backup
			      txn_log,
$endif auto_backup
				 statistics, vat, vfdd, dir);

  init buffer_pool   (oplog, statistics, vat, vfdd, dir);

  init supervisor_common (oplog,
$if    auto_backup
			      txn_log,
$endif auto_backup
				 statistics, vat, vfdd, dir);

$if    spc
  initialize_spc;
$endif spc

$if    condition
  
  init condition_log    ( statistics, vat, vfdd, dir, oplog);
  init condition_common ( statistics, vat, vfdd, dir, condition_log, oplog);
$endif condition

  init node_file  (
       oplog, statistics, vat, vfdd, dir, 
$if    condition
       condition_log,
$endif contition
       name_common,
$if    clusternodes
       cluster_common,
$endif clusternodes
       misc_common);

  init host_file  (
       oplog, statistics, vat, vfdd, dir,
$if    condition
       condition_log,
$endif condition
$if    reload
      host_slot_file,
$endif reload
       name_common,
$if    clusternodes
       cluster_common,
$endif clusternodes
       misc_common);

  init link_file  (
$if    alarm
       condition_log,
$endif alarm
       oplog, statistics, vat, vfdd, dir);

  init port_file  (
$ifnot     alarm
       oplog, statistics, vat, vfdd, dir, misc_common);
$endif not alarm
$if    alarm
       oplog, statistics, vat, vfdd, dir, condition_log, misc_common);
$endif alarm
$if    clusternodes

  init cluster_common (statistics, vat, vfdd, dir, 
$if    auto_backup
						txn_log,
$endif auto_backup
							oplog);
$endif clusternodes

  init host_location_common (oplog,
$if    auto_backup
			      txn_log,
$endif auto_backup
				 host_file, statistics, vat, vfdd, dir);
$ifany (reload, xcom)

  init slot_file (
$if    clusternodes
    cluster_common,
$endif clusternodes
    oplog, statistics, vat, vfdd, dir, name_common);

$endif any reload xcom
$if    reload

  init kernel_file (oplog, statistics, vat, vfdd, dir);

  init host_slot_file (oplog, statistics, vat, vfdd, dir);

  init reload_file (
    oplog, statistics, vat, vfdd, dir, 
$if    alarm
    condition_log,
$endif alarm
    slot_file, node_file, host_file, host_slot_file, kernel_file, name_common);
$endif reload
$ifany (reload, xcom)

  init xom_common (
    statistics, vat, vfdd, dir,
$if    clusternodes
    cluster_common,
$endif clusternodes
$if    auto_backup
    txn_log,
$endif auto_backup
    oplog);
$endif any reload xcom

$if alarm
  init alarm_common ( statistics, vat, vfdd, dir, condition_log, 
    condition_common, node_file, host_file, port_file, link_file, 
$if reload
    reload_file,
$endif reload
    oplog);
$endif alarm

  init network_common (
$ifnot     alarm
       host_location_common, 
$endif not alarm
$if    alarm
       host_location_common, condition_log,
$endif alarm
       node_file, host_file, link_file, port_file,
$if    reload
       kernel_file, host_slot_file,
$endif reload
$ifany (reload, xcom)
       slot_file, 
$endif any reload xcom
$if    reload
       reload_file,
$endif reload
       statistics, vat, vfdd, dir, supervisor_common);
 
  init remote_greeting_common (
       statistics, vat, vfdd, dir, oplog, next_aux_circuit);
  next_aux_circuit := next_aux_circuit+1;

  init log_message_common (				
       name_common, statistics, vat, vfdd, dir, oplog);	
  
  init greeting_clearer (statistics, remote_greeting_common, next_aux_circuit);
  next_aux_circuit := next_aux_circuit+1;

  init sysmsg1_access;

  init host_status_common (
       statistics, vat, vfdd, dir, oplog, 
$if auto_backup
					 txn_log,
$endif auto_backup
						supervisor_common);

  init host_status_house_keeper (
       statistics, oplog, supervisor_common, host_status_common,  
       sysmsg1_access, next_aux_circuit);
$ifnot     shut_link_table_maintenance
  next_aux_circuit := next_aux_circuit + 1;
$endif not shut_link_table_maintenance

$if shut_link_table_maintenance
  init shut_link_table_maintainer (
    supervisor_common, statistics, oplog, sysmsg1_access, 
$if    multiple_shut_link_table_maintenance
    next_aux_circuit+1,
$endif multiple_shut_link_table_maintenance
    next_aux_circuit);
$if    multiple_shut_link_table_maintenance
  next_aux_circuit := next_aux_circuit+2;
$endif multiple_shut_link_table_maintenance
$ifnot     multiple_shut_link_table_maintenance
  next_aux_circuit := next_aux_circuit+1;
$endif not multiple_shut_link_table_maintenance
$endif shut_link_table_maintenance

$if    background
  init job_common (oplog,
$if    auto_backup
			      txn_log,
$endif auto_backup
				 statistics, vat, vfdd, dir);
$endif background
$ifnot     background
  init job_common;
$endif not background

$if archive
  init tape_attacher;
$endif archive

$if    xom
  init  xom_misc_data;
$endif xom
$if    xom_restore
  init xom_file_mng (
$if    auto_backup
	txn_log,
$endif auto_backup
	oplog, statistics, vat, vfdd, dir);
  init xom_restore_file_mng;
$endif xom_restore
$if    xray
  init xray_data(oplog, statistics, vat, vfdd, dir);
  init node_list(oplog, statistics, vat, vfdd, dir);
  init crypto_log(oplog);
$endif xray
$ifnot     xray
$if    ddt
  init node_list(oplog, statistics, vat, vfdd, 
$if auto_backup					       txn_log, 
						   dir);
$endif ddt
$endif not xray

$if    auto_backup
  for per_partner := partner_first to partner_last do
    begin
      init backup_circuit[per_partner](oplog);
      partner_host := config_mon.partner_host_number(per_partner);

      init dispatcher[per_partner](
	   partner_host, config_mon, backup_circuit[per_partner],
	   USER_MAX+per_partner-PARTNER_FIRST, next_aux_circuit,
	   per_partner, griper, oplog, txn_log);
      next_aux_circuit := next_aux_circuit + 1;

      init txn_sender[per_partner](partner_host, 1,0, my_site_pos, per_partner,
		      time_stamps, backup_circuit[per_partner], txn_log, 
		      oplog, user_common, name_common, host_location_common,
		      host_status_common, supervisor_common, 
$if reload
			xom_common,
$endif reload
$if ddt
			node_list,
$endif ddt 
$if    clusternodes
			cluster_common,
$endif clusternodes
$if    background
			job_common,
$endif background
$if    xom_restore
			xom_file_mng,
$endif xom_restore
			misc_common);
      init txn_receiver[per_partner](partner_host, 0, 1, per_partner,
		      time_stamps, backup_circuit[per_partner], txn_log,
		      oplog, user_common,name_common, host_location_common,
		      host_status_common, supervisor_common, 
$if reload
			xom_common,
$endif reload
$if ddt
			node_list,
$endif ddt 
$if    clusternodes
			cluster_common,
$endif clusternodes
$if    background
			job_common,
$endif background
$if    xom_restore
			xom_file_mng,
$endif xom_restore
			misc_common)
    end;
$endif auto_backup

  init commands, license_operator;

  initialize_probe;

  initialize_users;

  init ticker (network_common) ;

  (*  update the volumn_label incarnation_number = current_incarnation  *)
  update_vat_incarnation_number

end (* initialize *) ;



(*************************  initial process  **************************)
(**********************************************************************)



begin (* initial process *)
  initialize
end   (* initial process *) .
    7 S