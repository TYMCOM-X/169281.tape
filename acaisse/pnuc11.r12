: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other   purpose except as specifically authorized in  wri-  **
: **  ting by  TYMNET, Incorporated.                              **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     :  11.12    				  **
: **  Release Date 	 :  Oct. 28, 1985			  **
: **                                                              **
: **  File Name          :  PNUC11.R12                            **
: **                                                              **
: **  File Description   :                                        **
: **                                                              **
: **  File Abstract      :                                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
        subttl                                          nuclus.gen
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								     :
:	   PASCAL NUCLEUS COMMON EQUATES AND DATA STRUCTURES	     :
:								     :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


        REMARK  %Concurrent PASCAL Nucleus 10/28/85

	MO	.,COMFIL
	RA	0		:Back to hex
	GL	IRSIZE,ORSIZE,CNTRL,HPRT0,NPORT,MAXCHAR,NGRP,IOMXRT
	GL	NBFLET,NBUF,NTOUT,MAXERR,USRBOT,STKBOT
        gl      a.buff,a.bdat,patch2
	GL	ECHO,ENGINE,NDIAL,A.RING,VERSIO,REVLEV
	GL	MAXPRT,MAXHST,CRSTOP,BUFTRC,MINPRO,TRATE,DTRATE,LPROMP
	GL	NTERM,NOESC0,BBMSG,AUXTIM,LIMITA,LIMITB,LIMITC
	GL	MXTRYS,DTRACE,NDTRB,CLRCOR,ECOUNT,MAXTRY,XLOOK,NLOOK
	GL	NUMPRI,CPUPRI,NORPRI,DSKPRI,MONPRI,DMNPRI
	GL	HID0,HIQ0,INECHO,DCTFLG,UMTOSS
	GL	NMICRO,NCRSAV,NPIPE,XPIPE,XTRACE
	GL	GATRAC

:	Following globals needed: FRING.LIB being after GCI/WCI & FRONT.LIB
:
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR,OCS

:
: DEFAULT - Macro to define default values for TYM file parameters
:

DEFAULT	MACRO(ID,VAL)[
	IF	\ID
	ELSE
ID	EQ	VAL
	EI]



        DEFAUL(PRODID,HID0)
        DEFAUL(LPROMP,0)
        DEFAUL(MINPRO,32)
        DEFAUL(CRERR,0)
        DEFAUL(CRSTOP,0)
        DEFAUL(NCRSAV,1)
        DEFAUL(NPIPE,0)
        DEFAUL(XPIPE,0)
        DEFAUL(NVADIC,0)
        DEFAUL(N801,0)
        DEFAUL(XMEMRY,0)
        DEFAUL(NMACSS,0)
        DEFAUL(EMEMR0,0)
        DEFAUL(EMEMR3,0)
        DEFAUL(XTRACE,0)

ENGINE	EQ	1		:USING TYMNET ENGINE
USRBOT	EQ	20000		:WHERE TO START PASCAL AREA
STKBOT  EQ      0A0000          :WHERE TO START PASCAL STACK IN EXMEMY
NPORT	EQ	NTERM+NAUX+1	:TOTAL NUMBER OF PORTS
MAXPRT	EQ	NPORT-1 	:MAX PORT FOR ISIS2
HPRT0	EQ	MAXPRT		:NUMBER OF PORTS FOR ISIS2
MAXHST	EQ	1		:MAX HOSTS FOR ISIS2
: NDISK, NTAPE, AND NPRNTR ARE DEFINED IN THE INI FILE!
    IF \NAUX
    ELSE
	REMARK	%NAUX must be defined in your TYM file!!%
    EI
NDIAL	EQ	N801+NVADIC	:NUMBER OF DIALERS SUPPORTED
MXDIAL	EQ	$A 16		:Max possible dialers
NCRSH   EQ      1               :NUMBER OF CRASH PSEUDO DEVICES
NSYSTM  EQ      1               :NUMBER OF SYSTEM PSEUDO DEVICES
NLVOL   EQ      2               :NUMBER OF LOGICAL VOLUMES
NSPDEV  EQ      0               :NUMBER OF UNUSED PSEUDO DEVICES
:NNTERM  EQ      MXDIAL+NDISK+NTAPE+NPRNTR+NCRSH+NSYSTM+NLVOL+NSPDEV
:NDEVIC	EQ	NNTERM+2*(NPORT-1) :NO. OF DEVICES DEFINED
NGRP	EQ	(NPORT+0F)/10	:# OF PORT GROUPS
:NDGRP	EQ	(NDEVIC+0F)/10	:# OF DEVICE GROUPS
:MXDEV	EQ	0		:MAX # OF AUX DEVICES
IRSIZE	EQ	(NGRP*200)-4		:SIZE OF ISIS INPUT RING (BYTES)
ORSIZE	EQ	(NGRP*200)-4		:ISIS OUTPUT RING SIZE
NOESC0	EQ	0		:Causes Front.Lib to escape data nulls
CNTRL	EQ	80		:ISIS STATE WORD - Want zappers acknowledged
ECHO	EQ	1		:SET TYMSAT ECHO MODE
DCTFLG	EQ	1		:SET DCT OPTION
UMTOSS	EQ	1		:SET UMTOSS OPTION

	DEFAULT(BFLT.P,8)
NBFLET	EQ	NPORT*BFLT.P	:NO. OF BUFFERLETS DEFINED
NBUF	EQ	NPORT*2 	:NO. OF BUFFERS
NTOUT	EQ	5		:NO. OF TIMEOUT ENTRIES MAX
	DEFAULT(MAXCHAR,100)

	DEFAULT(ECOUNT,0)

	DEFAULT(CLRCOR,1)

	DEFAULT(BBMSG,0)

	DEFAULT(NMICRO,0)

	DEFAULT(HIQ0,0)

:	DEFAULT(HID0,0)
	DEFAULT(INECHO,0)	:Initial No-Echo state is false

	DEFAULT(AUXTIM,$A200)

LIMITA	EQ	$A 120		:Output threshhold for class A circuits
LIMITB	EQ	$A 320		:Output threshhold for class B circuits
LIMITC	EQ	$A 1000		:Output threshhold for class C circuits

	DEFAULT(NDTRB,NDISK+NTAPE)	:Default NDISK+NTAPE req. blocks
	DEFAULT(MXTRYS,1)	:Default one try per disk operation
        DEFAULT(MAXTRY,12)      :DEFAULT 12 TRIES PER DISK INITIALIZATION
	DEFAULT(DTRACE,1)	:Default disk completion trace
	DEFAULT(GATRAC,0)
	DEFAULT(BUFTRC,0)	:Default buffer trace is off

        DEFAULT(XLOOK,1)        :DEFAULT LOOK OPTION ON
        DEFAULT(NLOOK,0)        :DEFAULT LOOK ONLY ONE FULL IRSIZE

MAXERR	EQ	$A 15		:HIGHEST ALLOWED PASCAL ERROR
:
NUMPRI	EQ	5		:NUMBER OF PRIORITY LEVELS (0..NUMPRI-1)
CPUPRI	EQ	4		:CPU BOUND PROCESS PRIORITY (WORST)
NORPRI	EQ	3		:NORMAL PRIORITY
DSKPRI	EQ	2		:DISK I/O COMPLETION PRIORITY
MONPRI	EQ	1		:MONITOR PRIORITY
DMNPRI	EQ	0		:DISK COMPLETION IN MONITOR PRIORITY
:
A.RING	EQ	0		:ALLOCATE RINGS IN SEGMENT 0
a.buff  eq      0               :buffers in seg 0
patch2  eq      0
a.bdat  eq      0               :base data in seg 0
TRATE	EQ	8		:SCALE FOR MONITORING TERM I/O RATE
DTRATE	EQ	2		:SCALE FOR MONITORING DISK-TAPE ACCESS RATE

        DEFAULT(LVNQUE,0)
        DEFAULT(LVDSK0,0)
        DEFAULT(LVNDSK,0)
        DEFAULT(LVPDK0,4)


:  provide dialer port definitions if not already given

	RA	$0 0A

	GL	D1PRT
   IF \D1PRT
   ELSE
D1PRT	EQ	4	:Assume 1st sync board, port for dialer 1
   EI

K	EQ	2

   RE MXDIAL-1
	GL	D|K|PRT
   IF \D|K|PRT
   ELSE
D|K|PRT	EQ	D|K-1|PRT+5
   EI

K	EQ	K+1

   ER

:   end of dialer definitions

	GL	HSTATE,ACECHO
	IF \HSTATE
	ELSE
	REMARK	%*** HSTATE assumed to be UP
HSTATE	EQ	UP
	EI

	IF \ACECHO
	ELSE
	REMARK	%*** ACECHO assumed to be 0 (no echoing on aux ckts)
ACECHO	EQ	0
	EI

VERSIO  EQ      $A 9            :NUCLEUS VERSION NUMBER
REVLEV	EQ	$A 12		:Revision of version
:
:	Dump out assembly time remarks on configuration

        REMARK %%HOST NUMBER -
        NUMBER  HOST0

	REMARK %%Port configuration - 
	NUMBER NTERM
	REMARK  terminal devices, 
	NUMBER NAUX
	REMARK  circuit devices.

	RA	$0 08
	REMARK %%This is version 
	NUMBER VERSIO
	REMARK .
        NUMBER $A REVLEV
	REMARK %
	RA	0

	KILL	DEFAULT		:FRONT.LIB also likes this name...

	EM
	SUBTTL	NUCLEUS MACROS                                  macros.nad
	RA	0	:RADIX IS HEX


   IF	BBMSG
	GL	BBCT,BBCNTR,BLKMSG
   EI

:	MACRO TO BRING UP A HOST UNDER ISIS-II
:
:	ARGUMENT:	INDEX REGISTER FOR HOST POINTER (HOST # * 4)
:			[OR ZERO]
:
HOSTUP	MACRO(REG) 
	[LIS	R0,0B
	LIS	R1,0
	LIS	R2,4
	JAL	R4,SLOR
	LIS	R0,0
	JAL	R4,PUTCH
	LHL	R0,HOSTS,,REG
	JAL	R4,PUTH
	LHL	R0,PORTS,,REG
	JAL	R4,PUTH
 IF	REG
	LR	R0,REG
	SRHLS	R0,2
 ELSE
	LIS	R0,0
 EI
	JAL	R4,PUTH
	JAL	R4,PUTCH
	JAL	R4,ELOR	]

	SUBTTL	HOST DOWN MACRO
	RA	0	:RADIX IS HEX

:	MACRO TO BRING DOWN A HOST UNDER ISIS-II
:
:	ARGUMENT:	INDEX REGISTER FOR HOST POINTER (HOST # * 4)
:			[OR ZERO]
:
HOSTDN	MACRO(REG) 
	[LIS	R0,0B
	LIS	R1,0
	LIS	R2,4
	JAL	R4,SLOR
	LIS	R0,0
	JAL	R4,PUTCH
	LHL	R0,HOSTS,,REG
	JAL	R4,PUTH
	LHL	R0,PORTS,,REG
	JAL	R4,PUTH
 IF	REG
	LR	R0,REG
	SRHLS	R0,2
 ELSE
	LIS	R0,0
 EI
	JAL	R4,PUTH
	LIS	R0,1
	JAL	R4,PUTCH
	JAL	R4,ELOR	]

:
:	MACRO TO CHANGE THE STATE OF HOST 0
:
:	ARGUMENT:	REGISTER CONTAINING NEW STATE (0 - 3)
:			[OR ZERO]
:
SETHST	MACRO(REG1,REG2,REG3)[
	LIS	R0,$0 0E	:# of chars of space required
	LIS	R1,0		:Port #
	LHI	R2,$0 10 	:Msg code
        JAL     R4,SLOR,,
	LIS	R0,0
        JAL     R4,PUTCH,,      :Key
	LHI	R0,HOST0
        JAL     R4,PUTH,,       :Host #
	LHL	R0,PORTS,,
        JAL     R4,PUTH,,       :#/ports
	LIS	R0,0
        JAL     R4,PUTH,,       :RH #
	LR	R0,REG1
        JAL     R4,PUTCH,,      :Status
	LIS	R0,0
        JAL     R4,PUTCH,,      :H key
	LR	R0,REG2
        JAL     R4,PUTCH,,      :HIQ
	LR	R0,REG3
        JAL     R4,PUTCH,,      :HID
        JAL     R4,ELOR,, ]
:
:	macro to handle buffer zaps in GCI buffer lib if user
:	wants us to handle black balls & transmission erros
:
ZAPBUF	MACRO	[.

   IF	BBMSG

:	note - input buffer index is of form  PORT# * 8
:	      output buffer index is of form (PORT# * 4) + 4

	THI	R1,4	:Input or output ?
	JE	ZAPIBF	:jump if input

ZAPOBF
	LIS	R0,3	:black ball length
	SRLS	R1,3	:port #
	LHI	R2,BLKMSG
	JAL	R4,SLOR,,	:emit BB
	JAL	R4,ELOR,,
	J	ZAPEND

ZAPIBF
	SRLS	R1,3	:port #
	LIS	R0,0	:(simulate black ball activation routine)
	STH	R0,BBCT,R1,R1	:no chars ahead of BB
	LIS	R0,1
	AHM	R0,BBCNTR,R1,R1	:bump BB counter

ZAPEND
   EI
	]



:
: SAVLIN - Macro to save the line number in the process header
:	Argument: Temp. register to use
:

:SAVLIN	MACRO(REG)[
:	LH	REG,2,B		:Get line number
:	ST	REG,LINE1,HD	:Save in process header]

:
: SETPSW - Macro to save the return PSW in the process header
:	Argument: Temp. register to use
:

SETPSW	MACRO(REG)[
	LH	REG,PSWWD,,	:Get first word of PSW
	ST	REG,PRSPSW-HEAD0,HD	:Put in header
	ST	QR,PRSPSW-HEAD0+4,HD	:Save return address in second word]

:
: SETSTA - Macro to change the process state in the process header
:	Arguments: Temp. register to use, new state
:

SETSTA	MACRO(REG,STATE)[
	LIS	REG,STATE	:Get new state
	STH	REG,STATE1,HD	:Put in process header]

:
: QUEINI - Macro to intialize a process queue element, the predecessor
:      and sucessor fields of the element are set to point to self.
:      REG is expected to have the pointer to the element.
:

QUEINI	MACRO(REG)[
	STH	REG,SUCC,REG
	STH	REG,PRED,REG]
:
: ENTRCT - Macro to use bit array PCNTFL to determine for which process
:	to count nuclus entries.  The entry counter will be incremented each
:	time an indicated process enters the corresponding nuclus entry.
:
ENTRCT	MACRO(REG1,REG2)[
	IF	ECOUNT
	L	REG2,INDEX1,HD	:Get the process #
	TBT	REG2,PCNTFL,,	:Test the corresponding bit
	JE	.+$A12		:Skip if bit = 0
	LIS	REG2,1		:Otherwise,
	AM	REG2,ENTRTB,REG1,	:Increment the entry couter
	EI  ]

    
	SUBTTL	ISIS Assembly Switch Definitions	- START.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	05;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision levr slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
           SUBTTL  CONCURRENT PASCAL TRANSFER VECTOR TABLE
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                  :
:       CURRENT PASCAL TRANSFER VECTOR TABLE                       :
:                                                                  :
:       THIS TABLE ESTABLISHES LINKAGE BETWEEN COMPILED PASCAL     :
:       CODE AND THE NUCLEUS.                                      :
:                                                                  :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
: V 0.2  04-02-82, RNP
:       Added range check subroutine jump to vector table
: V 0.1  03-19-82, SCY
:	Changed the linkage to RX3 format.

OFFST	 EQ  $0 1FA
:
:
:	GLOBAL REFERENCES
:
	GL   RNSYSE,GATENT,GATLEA,GATDEL,GATCON,GATINT
	GL   NUCIO,RNSTOP,CLKWAI,RNINPR,RNENDP
	GL   RNCONS,RNTIM
        GL      RANGEC
:
:	LOCATION OF TABLE IS AT X'10200' AND MUST NEVER CHANGE
:
	SEG  1
	ORG  SEG1+OFFST
:
:	THE FIRST ENTRY IS LOCATED BEFORE THE ACTUAL VETOR TABLE
:	AND IS AN INTERMEDIATE TRANSFER VECTOR FOR PROCESS ERROR
:	REPORTING
:
:
GRNSYE	J	RNSYSE,,	:NUCLEUS ERROR REPORT ROUTINE
	LIS	R6,0		:TERMINATED ERROR CODE
	J	GRNSYE
	LIS	R6,1		:OVERFLOW ERROR CODE
	J	GRNSYE
	LIS	R6,2		:POINTERROR ERROR CODE
	J	GRNSYE
	LIS	R6,3		:RANGE ERROR CODE
	J	GRNSYE
	LIS	R6,4		:VARIANT ERROR CODE
	J	GRNSYE
	LIS	R6,5		:HEAP LIMIT ERROR CODE
	J	GRNSYE
	LIS	R6,6		:STACK LIMIT ERROR CODE
	J	GRNSYE
	LIS	R6,7		:CODE LIMIT ERROR CODE
	J	GRNSYE
	LIS	R6,8		:TIME LIMIT ERROR CODE
	J	GRNSYE
	LIS	R6,9		:CALL ERROR CODE
	J	GRNSYE
:
:	NUCLEUS LINKAGE
:
	J   GATDEL,,		:GATE DELAY ROUTINE
	J   GATCON,,		:GATE CONTINUE ROUTINE
	J   NUCIO,,		:NUCLEUS I/O
	J   RNSTOP,,		:PROCESS PREEMPTION
	J   CLKWAI,,		:1 SECOND WAIT ROUTINE
	J   RNTIM,,		:FETCH REAL-TIME
	J   RNCONS,,		:FETCH ADR OF CONSTANTS
	J   GATINT,,		:INTIALIZE GATE
	J   GATENT,,		:ENTER GATE
	J   GATLEA,,		:LEAVE GATE
	J   RNINPR,,		:INIT CHILD PROCESS
	J   RNENDP,,		:EXIT PROCESS
        J       RANGEC,,        :Peform range check
:	J	x2,,
:	J	x3,,

   	SUBTTL	Engine hardware trace trapping routine
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TRACE.LIB

:	This file provides the necessary backbone for using the TYMNET-ENGINE
:	harware-trace feature.  It should be assembled IMMEDIATELY AFTER the
:	START.LIB file.  The file may be assembled directly from the library
:	version, in which case it is necessary to patch the appropriate test
:	into the assembled code, OR it may be copied and the test hard-coded.

	GL	ENTRY,CRASH	:TWO LIKELY CANDIDATES FOR SYMBOLS REQUIRED

	MO	.,TRACE
	SEG	0		:IN SEGMENT 0
	ORG	10		:AT LOCATION 10
TRPSD	WC	1000,ENTRY	:FORCE A TRANSFER TO "ENTRY"
	WC	TRACE		:ON TRAP, GO TO "TRACE"
TRSAVE	HS	22		:USEFUL AREA TO SAVE REGS, ETC

	SEG	A.CODE		:IN CODE AREA
TRACE	HS	0		:ENTRY TO TRACE LOGIC
	ST	R15,TRSAVE+4	:SAVE A REGISTER
	L	R15,TRPSD+4	:GET ADDRESS WE JUST JUMPED TO
	ST	R15,TRSAVE
	L	R15,TRSAVE+4	:RESTORE REGISTER
	UPSW	TRPSD		:INSTRUCTION TO RE-ENABLE TRACE
	HS	40		:ADDITIONAL AREA TO PATCH IN REQUIRED TEST

:	TRANSFER TO HERE TO TURN ON TRACE INITIALLY
TRBGN	UPSW	IPSD		:THIS WILL TAKE US TO "ENTRY" WITH TRACE ON
IPSD	WC	1000,ENTRY	:TRACE BIT ON, GO TO "ENTRY"
	EM

 	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
        REMARK  %CRASH.LIB    11-15-84 AWT
	REMARK	%THIS VERSION HAS AN OPTION FOR EXTENDED CRASH PROCESSING.

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME,EXCRSH
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRXREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:	The symbol EXCRSH, if set to 1, allows a JAL to label
:	CRSH.P out of the crash routine for extended crash processing.
:	The link is R5.  EXCRSH is defaulted to 0.
:
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF	\EXCRSH			:DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH	EQ	0
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HS	2		:WHERE CRASH OCCURED
CFROM	HS	2    		:WHERE CRASH WAS CALLED FROM
CRXREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK
	BC	16	:WATCH FROG TIMER - - TIME OUT

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF          :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF          :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2 :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
  IF	CRSTOP
  ELSE
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
  EI	CRSTOP
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1      :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1
        LM      R6,CRAT+CRTLEN/2,R1
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
	EM

    	SUBTTL	Library Package for BID and BIDH	- BID.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	BID.LIB
:	Library package for BID, BIDH

:	either routine called with bit pattern in R1, link on R3
:	returns number of a non-zero bit in R2
	GL	BID,BIDH
	SEG	A.CODE		:PLACE IN CODE AREA
	MO	.,BID
:

:	HALFWORD Bit identifier
:	left half of R1 must be zero if bit 16 is zero
:	returns original word in R1
:	number of leftmost bit of right half or R1 in R2
  IF	ENGINE
BIDH	JFFOH	R1,BIDH1	:FIND FIRST NON-ZERO BIT
	LHI	R2,10	:RETURN 10 IF NO BIT IS FOUND
BIDH1	JR	R3	:AND RETURN
  ELSE
BIDH1	LB	R2,BIDTAB,R1	:LEFT HALF IS EMPTY
	JR	R3		:GET ID OF FIRST BIT IN RIGHT HALF
BIDH	THI	R1,0FF00	:TEST IF FIRST BIT IS IN LEFT OR RIGHT BYTE OF HALFWORD
	JEBS	BIDH1		:RIGHT HALF
	EXBR	R2,R1		:LEFT HALF
	LBR	R2,R2		:COPY LEFT BYTE
	LB	R2,BIDTAB,R2	:USE IT TO INDEX INTO ID TABLE
	SIS	R2,8		:ADJUST NUMBER TO CORRESPOND TO LEFT BYTE
	JR	R3		:AND RETURN
  EI	ENGINE

:	FULLWORD Bit identifier
:	returns original word in R1
:	number of leftmost non-zero bit in R2
  IF	ENGINE
BID	JFFO	R1,BID1		:TEST FULLWORD FOR FIRST NON-ZERO BIT
	LHI	R2,20		:RETURN 20 IF NO BIT FOUND
BID1	JR	R3		:AND RETURN
  ELSE
BID1	LB	R2,BIDTAB,R1	:IN BYTE 4
	AHI	R2,10		:GET BIT ID FOR BYTE AND ADJUST FOR BYTE 4
	JR	R3
BID2	THI	R1,0FF00	:BYTE 1 AND 2 = 0
	JEBS	BID1		:IF BYTE 3 IS 0, LOOK UP BYTE 4
	EXBR	R2,R1		:ELSE COPY OUT BYTE 3
	LBR	R2,R2
	LB	R2,BIDTAB,R2	:PICK UP INDEX FOR THAT BYTE
	AIS	R2,8		:ADJUST FOR BYTE 3
	JR	R3
BID	THI	R1,8000		:TEST IF IN LEFT 17 BITS
	JEBS	BID2		:IF NOT, MUST BE IN BYTE 3 OR 4
	EXHR	R2,R1		:BIT IS IN BYTE 1 OR 2 (OR BIT 16)
	TI	R2,0FF00	:TEST IF BYTE 1
	JEFS	BID3		:SKIP IF NOT
	EXBR	R2,R2		:BIT IS IN BYTE 1, SO COPY BYTE 1
	LBR	R2,R2		:TO USE AS INDEX
	LB	R2,BIDTAB,R2	:LOOK UP ID WITHIN THIS BYTE
	SIS	R2,8		:ADJUST FOR REALLY BEING IN BYTE 1
	JR	R3
BID3	LBR	R2,R2		:HERE WITH BIT IN BYTE 2 (OR BIT 16)
	LB	R2,BIDTAB,R2	:LOOK UP ID WITHIN THIS BYTE
	JR	R3		:IF FIRST BIT WAS BIT 16, USE ENTRY 0 IN TABLE
BIDTAB	HS	0		:TABLE OF BIT NUMBERS IN A BYTE, BIASED BY 8
	NOLIST
	XC	100F0E0E0D0D0D0D0C0C0C0C0C0C0C0C0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B
	XC	0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A
	RE	2
	XC	0909090909090909090909090909090909090909090909090909090909090909
	ER
	RE	4
	XC	0808080808080808080808080808080808080808080808080808080808080808
	ER
	LIST
  EI	ENGINE
	EM
  	SUBTTL	Standard Timeout Routine Library	- TIMOUT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TIMOUT.LIB

:	This package contains the standard timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:		R1 = current fast-clock time.
:	TORET	routines called by TIMOUT should exit to here
:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5...R6--R15 preserved
:		R0 = address to transfer to
:		R1 = next time to call routine
:	TOGET	called to delete an entry already on timout list
:		link on R5...R6--R15 preserved
:		R0 = routine address...entry with this address will be deleted
:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5...NO registers preserved! NOW!
:		routine address in R0
:	NOTE...when a routine is called from timeout list, it is removed from list,
:	and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 10		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH,,	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,0F	:FLAG--LINK R5, TYPE 15d CRASH
TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4
	ST	R1,TLIST+6,R4
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
  	SUBTTL	ISIS Ring Handling Routines	- FRING.LIB
        REMARK  %FRING V 0.01  06-06-84 AWT
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRING.LIB

:  
:       V 0.01  02-14-84, AWT
:               THE LOOK AND ELIR ROUTINES ARE MODIFIED FOR ISIS MULTIPLE
:               EXTENDED PROCESSOR. THE ROUTINE LOOK WILL RETURN AS IF
:               THE INPUT RING WERE EMPTY AFTER A SPECIFIED AMOUNT OF
:               DATA HAS BEEN PROCESSED, EVEN THOUGH THERE IS DATA LEFT
:               IN THE RING. THIS IS TO PREVENT THE SLOT FROM CONTINUALLY
:               PROCESSING ISIS INPUT DATA AS IT COMES IN FROM THE XPI AND
:               NEVER DOING ANYTHING ELSE. XLOOK AND NLOOK CAN BE SPECIFIED
:               IN TYMFILE WITH LOOKOP MACRO. DEFAULT XLOOK TO BE 1 (OPTION
:               IS ON) AND NLOOK TO BE IRSIZE.
:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS,XLOOK,NLOOK
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

        IF      \XLOOK
        ELSE
XLOOK   EQ      1
        EI

        IF      XLOOK
        IF      NLOOK
        ELSE
NLOOK   EQ      IRSIZE
        EI      :NLOOK
        EI      :XLOOK


:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING
        IF      XLOOK
LOOKCT  WC      0               :BYTE COUNTER FOR ELIR ROUTINE
XR1SAV  WS      1               :
XR2SAV  WS      1               :
OVERUN  HC      0               :USED BY LOOK ROUTINE
        EI      :XLOOK

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
        IF      XLOOK
        LHL     R1,OVERUN,,     :SHALL WE STOP NOW?
        JN      LKSTOP          :YES, STOP FOR NOW
        EI      :XLOOK
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN
        IF      XLOOK
LKSTOP  LIS     R1,0
        STH     R1,OVERUN,,     :RESET THE FLAG
        JR      R4              :MAKE IT LOOK LIKE EMPTY
        EI      :XLOOK

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX

        IF      XLOOK
        ST      R1,XR1SAV,,
        ST      R2,XR2SAV,,
        CLH     R14,CEI+IRING,,  :HAS R14 BEEN FOLD?
        JG      XLOOK1           :NO, SKIP
        LHI     R1,IRSIZE
        SH      R1,CEI+IRING,,
        AR      R1,R14
        JFS     XLOOK2
XLOOK1  LR      R1,R14
        SH      R1,CEI+IRING,,
XLOOK2  L       R2,LOOKCT,,      :
        AR      R2,R1
        ST      R2,LOOKCT,,      :UPDATE THE BYTE COUNTER
        CI      R2,NLOOK         :
        JL      XLOOK3
        LIS     R1,1
        STH     R1,OVERUN,,      :TELL LOOK ROUTINE TO STOP
        LIS     R1,0
        ST      R1,LOOKCT,,      :RESET BYTE COUNTER
XLOOK3  L       R1,XR1SAV,,
        L       R2,XR2SAV,,
        EI      :XLOOK

	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
	SUBTTL	OUTPUT NUMBER		
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	GL	OUTNUM
	SEG	A.CODE			:SWITCH TO CODE SEGMENT

	MO	.,OUTNUM
:	This subroutine expects the user to provide the following:
:	R0	control information...format:
:	  - - -.- - f f.f f f f.s z b r.r r r r
:		where:
:		-	unused
:		f	output field width
:		s	signed output
:		z	zero field fill
:		b	blank field fill
:		r	Radix
:	R1	pointer to buffer area
:	R2	binary number to be output
:	R6	link register

OUTNUM	NHI	R0,3FFF			:CHECK FOR NULL FIELD-WIDTH
	SHI	R0,100
	JLR	R6			:EXCUSE TO DO NOTHING
	LR	R3,R0			:EXTRACT RADIX
	NHI	R3,1F
	STH	R3,RADIX+2		:HIGH BITS MUST = 0!
	SIS	R3,1
	JLER	R6			:RADIX .LE. 1 IS TO BE IGNORED
	SIS	R3,0F
	JGR	R6			:RADIX .GT. 16d TO BE IGNORED
	LCS	R3,1			:DIGIT INDEX		R3=DIGIT INDEX
	LR	R5,R2			:COPY VALUE		R4,R5=NUMBER
	THI	R0,80			:DO WE WANT SIGNED OUTPUT?
	JEFS	ONUM1			:NO
	LR	R5,R5			:YES
	JGEFS	ONUM1			:NOT NEGATIVE, SO PROCEED
	LIS	R5,0			:ELSE COMPUTE COMPLEMENT
	SR	R5,R2
	SHI	R0,100			:REDUCE FIELD WIDTH FOR THIS
	JGEFS	ONUM1			:AND SKIP IF FIELD REMAINS
	LHI	R5,0BC			:"<"
	J	ONUM6			:SAVE ONLY THIS

:		    MAKE A (REVERSED) DIGIT STRING
ONUM1	LIS	R4,0			:MAKE DOUBLE-PRECISION NUMBER
	D	R4,RADIX		:EXTRACT A DIGIT
	LB	R4,ONUMD,R4		:TRANSLATE TO ASCII
	AIS	R3,1			:ADVANCE CHAR INDEX
	STB	R4,ONUMB,R3		:AND SAVE IT
	SHI	R0,100			:COUNT ANOTHER CHAR IN PLACE
	JL	ONUM4			:QUIT IF FIELD IS EXHAUSTED
	LR	R5,R5			:CHECK QUOTIENT
	JNBS	ONUM1			:REPEAT IF MORE DIGITS EXIST
:		    ADD SIGN ("-") TO STRING IF REQUIRED
	THI	R0,80			:TEST AGAIN FOR SIGNED NUMBER
	JEFS	ONUM2			:NO...SKIP
	LR	R2,R2			:IS IT NEGATIVE?
	JGEFS	ONUM2			:NO
	LHI	R5,0AD			:"-"
	STB	R5,ONUMB,R3		:YES...SIGNED OUTPUT
	AIS	R3,1			:PLACE INTO BUFFER
:		    ADD LEADING FILL CHARS, IF ANY
ONUM2	THI	R0,60			:CHECK FOR ANY FILL
	JE	ONUM5			:SKIP IF NOT
	LHI	R5,0A0			:" " FILL
	THI	R0,40			:TEST IF ZERO FILL INSTEAD
	JEFS	ONUM3			:SKIP IF NOT
	LHI	R5,0B0			:"0"
ONUM3	STB	R5,0,R1			:PLACE CHAR
	AIS	R1,1			:AND BUMP CURSOR
	SHI	R0,100			:TEST FILL INDEX
	JGEBS	ONUM3			:CONTINUE IF POSSIBLE
:		    FIELD IS FULL
ONUM4	THI	R0,80			:SIGNED NUMBER?
	JEFS	ONUM5			:NO...JUST SKIP, IGNOR POSIBLE TRUNCATION
	LR	R5,R5			:SIGNED...MORE DIGITS?
	JEFS	ONUM5			:NO...OK
	LHI	R5,0BE			:">"
	JFS	ONUM6			:AND SKIP
:		    NOW TRANSFER (REVERSE) DIGIT STRING TO BUFFER
ONUM5	LB	R5,ONUMB,R3		:NOW OUTPUT CHARS
ONUM6	STB	R5,0,R1			:PLACE THE CHAR
	AIS	R1,1			:AND ADVANCE CURSOR
	SIS	R3,1
	JGEBS	ONUM5			:REPEAT AS NECESSARY
	JR	R6			:THEN EXIT

ONUMD	AC	'0123456789ABCDEF'	:DIGITS
	SEG	A.DATA
RADIX	HC	0,0			:SAVE RADIX HERE FOR DIVIDE
ONUMB	BS	24			:BUFFER FOR CHARACTER CONVERSION
	EM
   	SUBTTL	Data Conversion Routines	- CONVRT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
:
	RA	0
:
	MO	.,CONVRT
:
	GL	BINDEC,BINHEX
:
:*****************************************************************
:
:	BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII DECIMAL CHARACTERS.
:
:	ARGUMENTS: R9 CONTAINS THE BINARY NUMBER
:	           R10 CONTAINS NUMBER OF DIGITS OF OUTPUT
:	           R11 POINTS TO OUTPUT AREA
:	LINK ON R4
:
:****************************************************************
:
	SEG	A.DATA
:
RSAVE	HS	10	:REGISTER SAVE AREA
:
	SEG	A.CODE
:
DIGIT	AC	/0123456789ABCDEF/
:
:	FIRST CHECK FOR A NEGATIVE NUMBER
:		IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
BINDEC	STM	R8,RSAVE	:PRESERVE REGISTERS
	LR	R9,R9		: TEST FOR NEGATIVE NUMBER
	JGEFS	NOTNEG		:JUMP IF NOT NEGATIVE
	LHI	R12,$0 00AD	:'ASCII '-'
	STB	R12,0,R11
	SIS	R10,1		: ROOM FOR ONE LESS DIGIT
	AIS	R11,1		: DITTO
	JLE	RTRN		:NO ROOM FOR DIGIT AFTER MINUS SINE
:	COMPLEMENT THE NUMBER TO POSITIVE
	XI	R9,-1
	AIS	R9,1
NOTNEG	SIS	R11,1
	LIS	R12,$A 10	: DIVISOR
DIVIDE	SR	R8,R8		: CLEAR HI ORDER BITS OF DIVIDEND
	DR	R8,R12		:GET LOW DIGIT IN R9
	LB	R13,DIGIT,R8	:GET ASCII EQUIVALENT OF DEC NUMBER
	STB	R13,0,R10,R11	:STORE IN REVERSE ORDER
	SIS	R10,1		:DECREMENT COUNTER
	JGBS	DIVIDE		: KEEP LOOPING
RTRN	LM	R8,RSAVE	:RESTORE THE REGISTERS
	JR	R4		:AND RETURN
:
:******************************************************************
:
:	BINHEX IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII HEX CHARACTERS. A SPACE CHARACTER IS APPENDED ON THE
:	END OF THE HEX CHARACTER STRING.
:	ARGUMENTS: R8 - ADDRESS OF WHERE TO PUT ASCII CHARACTERS
:			   THIS REGISTER IS RETURNED UPDATED TO NEXT AVAIL
:				LOCATION
:	           R9 - BYTE COUNT
:		   R10 - START ADDRESS OF MEMORY TO BE PROCESSED
:	LINKS R4
:
:******************************************************************
BINHEX	STM	R9,RSAVE	:PRESERVE REGISTERS
LOOP	LB	R11,0,R10	:LOAD BYTE
	LBR	R12,R11		:COPY THE BYTE
	SRHLS	R12,4		:GET FIRST DIGIT
	LB	R13,DIGIT,R12	:GET ASCII CHARACTER
	STB	R13,0,R8	:STORE THE CHARACTER
	LIS	R12,0F		:LOAD MASK
	NR	R12,R11		:MASK OFF HIGH DIGIT
	LB	R13,DIGIT,R12	:GET ASCII CHAR
	STB	R13,1,R8	:STORE THE CHARACTER
	SIS	R9,1		:DECREMENT LOOP COUNT
	JGFS	REPEAT		:MORE TO DO?
	LHI	R13,$0 0A0	:LOAD SPACE CHARACTER
	STB	R13,2,R8	:STORE IT
	AIS	R8,3		:INCREMENT STRING POINTER
	LM	R9,RSAVE	:RESTORE THE REGISTERS
	JR	R4		:AND RETURN
:
REPEAT	AIS	R8,2		:INCREMENT STRING POINTER
	AIS	R10,1		:INCREMENT BYTE ADDRESS
	J	LOOP		:REPEAT

	EM
:
  	SUBTTL	GCI/WCI Buffer Package - Microcode version
        REMARK %MBUFER 08-23-84, AWT
:************************************************************************
:
:	This program is the sole property and confidential
:	information of TYMSHARE, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of TYMSHARE.
:
:************************************************************************
	RA	0		:	MBUFER.LIB
:
:	Version 0.02 Changed the supervisor's log message to report 
:		the PRODID.  Sep 20 '82 SCY
:	Version 0.01 Delete WCD routine as suggested by J Kopf and
:		M Rude. In general this cannot work with the microcode
:		bufferlets. Jan 21 '81 M D Stimac

:	Note that due to register usage, this library package is
:	incompatible with the CBCT machine instruction. This is not
:	a problem, though, because it is not necessary to use CBCT
:	if you are using MBUFER.LIB .

:	This package contains all code and storage allocation needed for
:	bufferlet usage.
:	If the symbol BUFTRC is defined and has a value greater than 0,
:	then a trace of all GCI and WCI calls will be included and
:	HISX will be a halfword pointer into a table HISTAB.
:	HISTAB will contain 100 one word entries.  Each entry contains
:	a one byte character, one byte of buffer number, and a halfword
:	address of the caller of GCI/WCI.  The table is circular.

:	the following parameters MUST be defined before assembly:
:	NBUF	the number of buffers to create
:	NBFLET	the number of bufferlets to create
:
:	The following symbol may be defined. If it is not defined the
:	default is FALSE.
:		UABUFF  If TRUE (>0) then the user will allocate the
:			bufferlet pool.

:	uses routines in TIMOUT.LIB - - - requires one timeout list entry

:	may JAL R10,CRASH on certain conditions

:	Each routine is called with:
:	Link on R4
:	R0 = argument
:	R1 = buffer index (buffer number*4)

:	routines:
:	IZBF	link on R5, used to initialize buffers
:	GCI	get a character from buffer
:	WCI	write a character into buffer
:	EMPTY	empty (flush) buffer

:	buffer index may be used to index into the following fullword arrays
:	from external routines:
:	BF	buffer flags
:	BB	buffer start address
:	BE	buffer end address
:	BCT	buffer counts

:	Note: The BCT array consists of halfwords stored on
:		fullword boundaries.  (This was done because
:		halfword instructions are faster.)

:	the following should also be defined externally:
:	FLAGS	a bit array of length corresponding to max buffer flag value
:
:	If the macro ZAPBUF is defined then the code in the macro will
:	be executed whenever CKBZ is forced to zap a buffer. The code
:	will be executed immediately following the call to EMPTY
:	(R1 will contain the buffer index).  The first line of the macro
:	must be "ZAPBUF MACRO [.X" (where X may be a carriage return
:	or semicolon).


	GL	NBUF,NBFLET,BUFTRC,UABUFF
  IF	\BUFTRC
  ELSE
BUFTRC	EQ	0
	REMARK	%*** Define BUFTRC EQ 1 if debug trace desired
  EI

 IF	\UABUFF
 ELSE
UABUFF	EQ	0	:BUFFERLET POOL IS NOT USER ALLOCATED
 EI

	MO	.,BUFFER
	GL	FASTC,TORET,TOPUT,RATE,FLAGS,CRASH
	IF	\DCTFLG
	GL	DCT
	EI
	GL	BF,BCT,BB,BE,REBL
	GL	IZBF,GCI,WCI,EMPTY,GCPEEK,GCSCAN,MCI
	GL	MBUFER

MBUFER	EQ	1		:FULLWORD ADDRESSING FLAG FOR OTHER MODULES

:	THE DATA FOR THESE ROUTINES
	SEG	A.DATA		:PLACE IN DATA AREA
REBL	HC	0		:FREE LIST POINTER FOR RESERVE STORAGE LIST
REBC1	HC	0		:COUNTS TIMES BUFFER STORAGE WAS MOVED TO MAIN FREE LIST
REBC2	HC	0		:COUNTS TOTAL NUMBER OF BUFFER ZAPS
BFZ	HC	-1		:LAST BUFFER ZAPPED

BF	WS	NBUF		:BUFFER FLAGS
BCT	WS	NBUF		:BUFFER COUNTS
BB	WS	NBUF		:BUFFER START ADDRESS
BE	WS	NBUF		:BUFFER END ADDRESS

  IF	BUFTRC
	GL	HISX,HISTAB
HISX	HC	0		:INDEX FOR HISTORY
HISTAB	HS	200		:HISTORY DATA...400 BYTES...100 HISTORY ENTRIES
  EI



:	CODE SECTION
	SEG	A.CODE		:PLACE IN CODE ARAEA

:	INITIALIZE BUFFERS
IZBF	LIS	R0,0		:SET A CONSTANT
	LHI	R1,NBUF*4-4	:FOR ALL BUFFERS
IZBF1	ST	R0,BCT,R1	:SET EMPTY
	IF	\DCTFLG
        ST      R0,DCT,R1,      :set DCT empty
	EI
	ST	R0,BB,R1	:CLEAR START POINTER
	ST	R0,BE,R1	:CLEAR END POINTER
	L	R2,BF,R1
        RBT     R2,FLAGS,,      :TURN OFF FLAG BIT
	SIS	R1,4
	JGEBS	IZBF1
	LHI	R2,NBFLET	:FOR ALL BUFFERLETS
	LHI	R1,NBFLET*10	:BUFFERLET POINTER ADDRESS
	STH	R0,BUFERS,R1,	:TERMINATE LIST
IZBF2	STH	R2,BUFERS-10,R1,	:LINK LAST TO THIS
	ST	R0,BUFERS-0E,R1,	:CLEAR DATA AREA
	ST	R0,BUFERS-0A,R1,
	ST	R0,BUFERS-06,R1,
	STH	R0,BUFERS-02,R1,
	SHI	R1,10
	SIS	R2,1		:DECREMENT BUFFER #
	JG	IZBF2		:REPEAT FOR ALL BUFFERLETS
	STH	R0,REBL		:SET SPARE TANK EMPTY
	L	R1,FASTC,,
	LHI	R1,RATE/$A25,R1	:CALL EVERY 40 MS.
	LA	R0,CKBZ		:PUT BUFFER CHECKING LOGIN ON QUEUE
	J	TOPUT		:EXIT VIA TIMEOUT LIST ENTRY
:	CHARACTER HANDLERS. THESE ROUTINES PASS BFR CHR IN R0,
:	R1 FOR TWICE THE BUFFER NUMBER, R2,R3 FOR WORKING REGISTERS,
:	R4 IS LINK REGISTER.

:	GET CHAR FROM BUFFER AND INCREMENT FORWARD THRU THE BUFFER.

GCI     LHL     R3,BCT,R1
        SIS     R3,1            :REDUCE COUNT OF CHARS IN  BUFFER
        STH     R3,BCT,R1

GCI1	HC	3801		:**GCI R0,R1
	HC	BE-BB		:SIZE OF BB STORAGE
	HC	GCICRA-GCI1	:ERROR ROUTINE OFFSET
	HC	BB/4		:ADDRESS OF BB STORAGE
	HC	GCINXT-GCI1	:GET NEXT BUFFERLET ROUTINE OFFSET
	HC	GCILAS-GCI1	:BUFFER EMPTY ROUTINE OFFSET

  IF	BUFTRC
	J	HIST		:AND RETURN WITH THE CHAR
  ELSE
	JR	R4		:AND RETURN WITH THE CHAR
  EI

GCINXT	LHL	R2,0,R3		:BUFFERLET EXHAUSTED - GET NEXT BFLT #
	SLLS	R2,4		:CONVERT TO BUFFERLET POINTER
	AI	R2,BUFERS-0E	:GET ADDRESS OF FIRST CHARACTER
	ST	R2,BB,R1	:SET BB TO START OF NEXT BUFFERLET
	LHL	R2,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R2,0,R3		:LINK LAST BUFFERLET TO FREE LIST
	SI	R3,BUFERS	:COMPUTE OFFSET FROM BUFERS
	SRLS	R3,4		:CONVERT TO BUFFER NUMBER (DIV BY 16)
	STH	R3,BUFERS,,	:AND PUT AT THE HEAD OF THE FREE LIST
  IF	BUFTRC
	J	HIST		:THEN EXIT
  ELSE
	JR	R4		:THEN EXIT
  EI

GCILAS	L	R2,BF,R1	:OK...GET POINTER TO FLAG BIT
        RBT     R2,FLAGS,,      :RESET ATTENTION FLAG
	AIS	R3,0E		:BUMP CHARACTER POINTER PAST END OF BUFFERLET
	NHI	R3,-10		:MAKE CHAIN A MULTIPLE OF 16
	LHL	R2,BUFERS,,
	STH	R2,0,R3
	SI	R3,BUFERS	:CONVERT TO OFFSET FROM BUFERS
	SRLS	R3,4		:CONVERT TO BUFFER NUMBER
	STH	R3,BUFERS,,	:UPDATE FREE LIST
	LIS	R2,0
	ST	R2,BB,R1	:CLEAR BB
	ST	R2,BE,R1	:AND BE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

GCICRA	JAL	R10,CRASH;	BC	0,0,4*R4,3	:FLAG--LINK R4, TYPE 3
:	PUT A CHARACTER INTO THE BUFFER
WCI	HC	3901		:**WCI R0,R1
	HC	BE-BB		:SIZE OF BB STORAGE
	HC	WCICRA-WCI	:ERROR ROUTINE OFFSET 
	HC	BE/4		:ADDRESS OF BE STORAGE
	HC	WCINXT-WCI	:GET NEXT BUFFERLET ROUTINE
	HC	WCIFRS-WCI	:GET FIRST BUFFERLET ROUTINE

        LHL     R2,BCT,R1
        AIS     R2,1
        STH     R2,BCT,R1
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCICRA	JAL	R10,CRASH	:ELSE CRASH
	BC	0,0,4*R4,5	:FLAG--LINK R4, TYPE 5 CRASH

WCINXT	LHL	R3,BUFERS,,	:NEED A NEW BUFFERLET
	JNFS	WCINXC		:SKIP IF THERE IS ANOTHER
	JAL	R2,WRE		:(OPEN THE RESERVE TANK)
WCINXC	L	R2,BE,R1	:GET END POINTER
	AIS	R2,1		:POINT TO LINK FIELD
	STH	R3,0,R2		:LINK NEW BUFFERLET TO LAST ONE
	SLLS	R3,4		:CONVERT TO BUFFER POINTER
	AI	R3,BUFERS	:MAKE ABSOLUTE ADDRESS
	LHL	R2,0,R3		:REMOVE FROM FREE LIST
	STH	R2,BUFERS,,
	SIS	R3,0E		:BACK UP NEW BUFFERLET
	ST	R3,BE,R1	:SAVE AS NEW BE
	STB	R0,0,R3		:PUT THE CHARACTER THERE
        LHL     R2,BCT,R1
        AIS     R2,1
        STH     R2,BCT,R1
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCIFRS	L	R2,BF,R1	:THE BUFFER WAS EMPTY
  IF	BUFTRC
	JE	HIST		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  ELSE
	JER	R4		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  EI
        SBT     R2,FLAGS,,      :ATTENTION BIT ON, DATA WAITING
	LIS	R2,1
	STH	R2,BCT,R1	:SET COUNT = 1
	LHL	R3,BUFERS,,	:POP A BUFFERLET OFF FREE LIST
	JGFS	WCIFR1		:SKIP IF THERE WAS ONE
	JAL	R2,WRE		:ELSE OPEN THE RESERVE TANK
WCIFR1	SLLS	R3,4		:CONVERT TO BUFFERLET POINTER
	AI	R3,BUFERS	:COMPUTE ABSOLUTE ADDRESS
	LHL	R2,0,R3		:GET ITS SUCCESSOR
	STH	R2,BUFERS,,	:UPDATE FREE LIST
	SIS	R3,0E		:POINT IT AT FIRST CHARACTER
	ST	R3,BB,R1	:SET UP BB
	ST	R3,BE,R1	:AND BE
	STB	R0,0,R3		:PUT THE CHARACTER THERE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

:	MOVE RESERVE STORAGE SUPPLY TO MAIN FREE LIST
WRE	LHL	R3,REBL		:GET POINTER TO RESERVE BUFFERLETS
	EXHR	R3,R3
	STH	R3,REBL		:SET RESERVE BUFFERLETS EMPTY (=0)
	EXHR	R3,R3
	JNR	R2		:IF IT WASN'T EMPTY, RETURN
	JAL	R10,CRASH	:BUG, UNREASONABLY FAST STORAGE DRAIN
	BC	0,0,4*R4,6	:FLAG--LINK R4, TYPE 6

  IF	BUFTRC
:	UPDATE HISTORY (TRACE) AFTER EVERY BUFFER OPERATION
HIST	LH	R3,HISX		:GET HISTORY RING INDEX
	AIS	R3,4		:BUMP TO NEXT ENTRY
	NHI	R3,3FF		:ACCOUNT FOR FOLDING
	STH	R3,HISX		:SAVE IT AGAIN
	STB	R0,HISTAB,R3	:ENTRY (0) = CHARACTER
	LR	R2,R1
	SRHLS	R2,2		:COMPUTE BUFFER #
	STB	R2,HISTAB+1,R3	:ENTRY (1) = PORT #
	STH	R4,HISTAB+2,R3	:ENTRY (2, 3) = LOCATION WHERE CHAR PLACED
	JR	R4
  EI	(BUFTRC)
:	PEEK AT FIRST CHAR OF BUFFER
GCPCRA	JAL	R10,CRASH;	BC	0,0,4*R4,6	:CRASH TYPE 6
GCPEEK	CLHI	R1,4*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
	L	R2,BB,R1	:GET POINTER TO START OF BUFFER DATA
	LHL	R3,BCT,R1	:GET COUNT OF CHARS THERE
	JFS	GCS		:AND SKIP

:	SCAN SUCESSIVE CHARACTERS IN BUFFER
GCSCAN	CLHI	R1,4*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
GCS	SIS	R3,1
	JL	GCPCRA		:CRASH IF NO MORE CHARACTERS THERE
	LB	R0,0,R2		:ELSE GET CHAR
	AIS	R2,1		:BUMP POINTER FOR NEXT TIME
	THI	R2,0F
	JNR	R4		:EXIT IF NOT AT END OF BUFFERLET
	LHL	R2,0,R2		:ELSE ADVANCE TO NEXT BUFFERLET
	SLLS	R2,4		:CONVERT TO POINTER
	AI	R2,BUFERS-0E	:COMPUTE ABSOLUTE ADDRESS OF START
	JR	R4
:	MCI - MOVE ALL CHARACTERS FROM SOURCE TO DESTINATION BUFFER
:	R5 = SOURCE BUFFER INDEX
:	R6 = DESTINATION BUFFER INDEX
:	R7 = LINK
MCICRA	JAL	R10,CRASH
	BC	0,0,4*R7,4	:FLAG--LINK R7, TYPE 4
MCI	CLHI	R5,4*NBUF
	JGBS	MCICRA		:RANGE CHECK ON SOURCE
	CLHI	R6,4*NBUF
	JGBS	MCICRA		:RANGE CHECK ON DESTINATION
	LHL	R0,BCT,R5	:CHECK SOURCE
	JER	R7		:EXIT IF EMPTY
	L	R1,BF,R6	:SET DESTINATION FLAG
	JNFS	MCI1		:FLAG = 0 IS BIT BUCKET
	LR	R1,R5		:THEN JUST EMPTY BUFFERS
	LR	R4,R7
	J	EMPTY
MCI1    SBT     R1,FLAGS,,
	JNFS	MCI2		:NOT EMPTY...GO APPEND
	L	R0,BB,R5	:EMPTY...COPY BUFFER START
	ST	R0,BB,R6
	J	MCI4		:AND SKIP TO FINISH TRANSFER OF DATA
MCI2	L	R1,BE,R6	:CHECK DESTINATION
	AIS	R1,1		:IS IT AT END OF BUFFERLET?
	THI	R1,0F
	JNFS	MCI3		:SKIP IF NOT
	L	R2,BB,R5	:YES...IS SOURCE ON BUFFERLET BOUNDARY?
	AIS	R2,0E
	THI	R2,0F
	JNFS	MCI3		:SKIP IF NOT
	SI	R2,BUFERS	:CONVERT TO RELATIVE POINTER
	SRLS	R2,4		:CONVERT TO BUFFERLET NUMBER
	STH	R2,0,R1		:APPEND SOURCE TO DESTINATION
	JFS	MCI4		:AND SKIP
MCI3	LR	R1,R5		:MOVE A CHAR
	JAL	R4,GCI
	LR	R1,R6
	JAL	R4,WCI
	LHL	R0,BCT,R5	:CHECK SOURCE
	JG	MCI2		:LOOP IF NOT EMPTY
	JR	R7		:ELSE RETURN
MCI4	L	R0,BE,R5
	ST	R0,BE,R6	:UPDATE BUFFER END
	LHL	R0,BCT,R5
        LHL     R1,BCT,R6
        AR      R0,R1
        STH     R0,BCT,R6
	LIS	R0,0
	STH	R0,BCT,R5	:CLEAR SOURCE BUFFER
	ST	R0,BB,R5
	ST	R0,BE,R5
	L	R1,BF,R5
        RBT     R1,FLAGS,,      :TURN OFF SOURCE FLAG
	JR	R7		:AND EXIT
:	RETURN ALL THE SPACE USED BY THE BUFFER
EMPTY	CLHI	R1,4*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JLFS	C1		:BFR ARGUMENT ACCEPTED
	JAL	R10,CRASH	:BFR ARG OUT OF RANGE
	BC	0,0,4*R4,0D	:FLAG--LINK R4, TYPE 13d

C1	LHL	R2,BCT,R1	:CHECK CONTENTS
	JER	R4		:EXIT...BUFFER EMPTY
	L	R2,BB,R1	:POINTER TO FIRST CHAR IN BUFFER
	SI	R2,BUFERS-0E	:GET RELATIVE ADDR, INSURE ROUNDING UP
	SRLS	R2,4		:CONVERT TO BUFFER #
	LHL	R3,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R2,BUFERS,,	:PUT THE BUFFERS BUFFERLETS ONTO FREE LIST
	L	R2,BE,R1	:GET POINTER TO LAST CHARACTER IN BUFFER
	AIS	R2,0E		:LOCATE THE POINTER IN THIS BUFFERLET
	NHI	R2,-10
	STH	R3,0,R2		:CHAIN PREVIOUS FREE LIST TO THIS BUFFERLET
	L	R2,BF,R1
        RBT     R2,FLAGS,,      :SET FLAGS TO EMPTY BUFFER
	LIS	R2,0
	STH	R2,BCT,R1	:SET COUNT = 0
	IF	\DCTFLG
        STH     R2,DCT,R1,
	EI
	ST	R2,BB,R1	:CLEAR BB
	ST	R2,BE,R1	:AND BE
	JR	R4		:AND RETURN
:	SEE IF WE MUST ZAP BFRS BECAUSE BFR STORAGE RUNNING LOW
CKBZ	LHI	R1,RATE/$A25,R1	:SET TIMER FOR NEXT CALL
	JAL	R5,TOPUT	:RUN 25 TIMES PER SECOND
	LH	R1,REBL		:ARE WE ON THE RESERVE TANK?
	JN	TORET		:PLENTY OF BFR STORAGE. DONT ZAP BFRS

:	WCI GRABBED RESERVE BFR FREE LIST AND MOVED IT TO MAIN FREE LIST.
:	REFILL FREE LIST WITH 1/8 OF TOTAL BFR STORAGE. ZAP BFRS IF NECESSARY.
	LIS	R0,1
	AHM	R0,REBC1	:STATISTIC
REB1	LIS	R2,0		:INITIAL POINTER IS TO START OF FREE LIST
	LHI	R1,NBFLET/8	:SCAN MAIN FREE LIST FOR 1/8 FREE STORAGE

REB2	LHL	R2,BUFERS,R2,	:GET NEXT BUFFER ON FREE LIST
	JE	REBZ		:NOT ENOUGH SPARE SPACE. ZAP A BFR
	SLLS	R2,4		:CONVERT BUFFER # TO POINTER
	SIS	R1,1		:GOT ANOTHER...COUNT IT
	JGBS	REB2		:GO UNTIL WE'VE GOT ENOUGH
	LHL	R3,BUFERS,,	:DONE...SEPERATE FREE LIST INTO TWO PARTS
	STH	R3,REBL		:BEGINNING OF THE RESERVE LIST
	LHL	R4,BUFERS,R2,,
	STH	R4,BUFERS,,	:BEGINNING OF MAIN LIST
	STH	R1,BUFERS,R2,,	:DEATH'S BRIGHT ANGEL AT END OF SPARE LIST (=0)
	J	TORET

:	ZAP A BFR IN ORDER TO GET RESERVE TANK UP TO 1/8 OF TOTAL BFR STORAGE
REBZ	LHI	R1,NBUF*4-4	:BCT INDEX
	LIS	R7,0		:R7 WILL CONTAIN SIZE OF LARGEST BUFER
REBZ1	LHL	R0,BCT,R1	:R0 - SIZE OF THIS BUFER
	CLR	R7,R0		:COMPARE BIGGEST SO FAR TO THIS ONE
	JGEFS	.+6
	LR	R7,R0		:MAKE R7 CONTAIN THE BIGGEST
	LR	R8,R1		:R8 WILL REMEMBER WHICH BUFFER IS BIGGEST
	SIS	R1,4		:POINT TO NEXT BUFFER ENTRY IN BCT TABLE
	CLHI	R1,8
	JGEBS	REBZ1		:DO NEXT BCT ENTRY
	LIS	R0,1
	AHM	R0,REBC2	:INCREMENT COUNTER
	STH	R8,BFZ		:STATISTICS
	LR	R1,R8		:ZAP BIGGEST BUFFER FOUND
	JAL	R4,EMPTY	:RETRIEVE STORAGE
  IF	\ZAPBUF : ZAPBUF WILL EXPAND INTO MACRO CALL IF DEFINED,
  EI		:ELSE THIS IS A NOOP
	LIS	R0,9
	JAL	R4,ROOM,,	:WE WANT TO SEND A 9-BYTE MESSAGE
	LHI	R0,0300		:SPECIAL MESSAGE TYPE 3...
	JAL	R4,PUTW,,	:SEND DIAGNOSTIC TO SUP
	LR	R0,R8
	JAL	R4,PUTH,,	:HW4 = BUFFER NUMBER
	LIS	R0,0
	JAL	R4,PUTCH,,	:REPORT TYPE = 0
	LR	R0,R7		:LOAD CHAR COUNT
	SRHLS	R0,0A		:DIVIDED BY 1024
	JAL	R4,PUTCH,,	:HW3 HIGH = CHAR COUNT
	LHI	R0,PRODID	:GET PRODUCT ID
	JAL	R4,PUTCH,,	:HW2 LOW = PRODID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
	J	REB1		:TRY AGAIN TO FILL RESERVE STORAGE LIST

 IF	UABUFF
 ELSE
:	BUFFER SEGMENT
	SEG	A.BUFF		:BUFFERLETS IN BUFFER AREA
	BND	10		:Must start on a multiple of 16d bytes.
BUFERS	HS	1		:Free list pointer
	HS	8*NBFLET	:STORAGE FOR THE BUFFERLETS (16 bytes each.)
 EI
	EM
  	SUBTTL	ISIS Front-end Package
	REMARK %FrontLib V 0.16 06-06-84 AWT
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRONT.LIB

: V 0.16 06-06-84 AWT
:       IN ADDITION TO THE USE OF FRISIS BIT ARRAY, NUCLEUS ALSO SENDS
:       THE A0 AND A1 MESSAGES BY ITSELF.(TO ANTICIPATE THE FUTURE
:       DISCONTINUE OF USE THE FRISIS AND TOISIS BIT ARRAYS BY ISIS
:       AND MAY ALSO HELP IN PREVENTING CRASH 6 CONDITION)
: V 0.15 04-05-82 SCY
:	Added DCTFLG to make use of DCT optional
: V 0.14 03-18-82 SCY
:	Added DCT to count real data characters count
: V 0.13 03-15-82 MDS
:	Add code to handle port starting in No-Echo mode
: V 0,12 11-19-81 SCY
:	Send bell for read_line @ that column
: V 0.11 09-01-81 SMF
:	Added condtional flag 'MBUFER' to allow usage with MBUFER.LIB.
:	Added PTTOUT entry to set port timeout.
:	Added ZAPPRT entry to zap port bypassing buffers.
:	Added CHRLIM array of input limits by port.
:	User routine is now given a chance to empty buffer before
:	backpressure is sent.
: V 0.10 06-01-81 SMF
:	Force the WAITZA option on so that zapper ack's will be handled
:	correctly.
: V 0.9 05-22-81 SMF
:	Force the CNTRL bit on to get zapper acknowledgements.  This
:	ensures that the buffers for the port will get cleared after the
:	circuit is torn down.
: V 0.8 04-03-81 MDS
:	Needle activations now set the ACP bit before activating the user
:	code. This gives the host the opportunity to reset ACP, thereby
:	notifying FrontLib that this circuit is rejected.
: V 0.7 03-31-81 MDS
:	Added routines to handle messages BA, BB, BC, BD, BE.
:	Permit user to select clearing port after zapper acknowledgement
:	   arrives (set WAITZA EQ 1) as an option.
:	Made use of UMTOSS table optional.
: V 0.6 02-20-81 MDS
:	Made outgoing zappers reset same bits as incoming zappers.
: V 0.5 02-06-81 MDS
:	Fixed handling of Red Balls, to flush a pending Green Ball, rather
:	than to force the return of it.
: V 0.4 01-17-81 MDS
:	Fixed Setting port flags, moved from B2 routine to B6 routine,
:	note that B2 does not necessarily imply a circuit is built.
:	B2 messages are now tossed.
: V 0.3 11-24-80 MDS
:	Added use of NOESC0 flag to suppress putting escape char ahead of
:	data nulls, and the table UMTOSS to indicate that a break message
:	handled by the user should not be put in the input buffer.
: V 0.2 11-19-80  MDS
:	Added bit array OUTCRT, bit set to indicate this port has
:	aux. circuit built "out" and we need to act like a remote
:	with regard to B1 messages.
: V 0.1 11-17-80  MDS
:	Added ECHOFF variable, and handling of B1 (echo control) messages
:	per PASCAL nucleus usage.


:		This package is the ISIS front end...used to service the
:	ISIS input and output rings, and to activate user code
:	whenever a break (user defined) is encountered.
:	It also activates user code when a user-processable
:	(also user defined) non-data message is encountered,
:	if excessive data is input without a break, or if a timeout
:	occurs for a port.

:			CONVENTIONS

:		Each of NPORT ports has a buffer-pair associated with it.
:	Even numbered buffers are input buffers...the corresponding
:	odd numbered buffer is that port's output buffer.  The user-
:	provided code should intialize these buffers.

:	A 0-byte in the buffer is an escape...it is followed by a
:	data-0, or by an ISIS message code and the appropriate
:	character stream following. (But note NOESC0 flag and UMTOSS
:	bit table added V 0.3 can change this escape convention.)
:	This does NOT apply to needles,
:	and thus unassigned ports should be connected to an appropriate
:	process.  Needles are parsed, and the following usage applies on
:	activation <Needles ALWAYS activate>:
:		R5	Invoice number,
:		R6	Destination Host number,
:		R7	Originating Node number,
:		R8	Originating Host Number
:		R9	Originating Port number,
:		R10	Dialect Code
:		R11	TID
:		R12	number of characters in user name,
:			The username is placed into the port's buffer.)

:	Data breaks on C/R if no break array is specified.

:	Activation always occurs after the breaking data character
:	is placed into the buffer, or after a complete MESSAGE is
:	placed in the buffer.

:	Break is activated with the buffer index in R1, and links on R15.
:	R0 contains an activation key, and condition codes are set appropriately:
:	>0	R0 is message type
:	=0	data break...R2 contains the activation char
:	=-1	needle
:	=-2	too many chars
:	=-3	flushing...next will not necessarily be data
:	=-4	timout
:	=-5	port 0 message

:	All registers are available for use while in the user code, and
:	on return, R0 is to contain a number N.  If N>0, it is default timeout
:	(in seconds) until the next activation, if N=0, timeout is disabled,
:	and if N<0, timeout retains its previous status.
:	All data characters are automatically placed in the input buffer,
:	as are any control messages specified for user-handling.

:	ALL ISIS special messages are placed in the buffer for port 0,
:	and each breaks automatically.

:	For non-text messages, the escape convention applies ONLY to the
:	message type...the body of the message is unescaped.  ALL such
:	messages handled by the user cause a break.

:	The following WORD arrays (length NPORT words), and are to be initalized
:	by the user program:

:	BREAK	a pointer to the bit array of characters to break upon.
:	MBREAK	a pointer to the bit array of message types to break on.
:	PROCESS	a pointer to the process to be activated upon a break condition.

:	The following items are to be provided by the user:

:	A bit array TISIS of length NPORT, to signal output data.
:	A symbol MAXCHAR...default limit for buffer count
:	A symbol ECHO...causes tymsat echoing for terminals if >0.
:	A 256 bit table UMTOSS...indicates break messages not put in buffer.

:	the following routines should be called by the user (link R0):

:	IZFRONT	at initialization time, after calling IZT.
:	INPUT	from exec loop, to process input from ISIS.
:	OUTPUT	from exec loop, to process output to ISIS.

:	These routines are also available:

:	PTTOUT - Set timeout time for port
:		(R0 = # seconds, R1 = input buffer pointer, link on R4)
:	ZAPPRT - Send zapper to ring for port (R1 = port #, link on R5)

:	The halfword array CHRLIM (by port) holds the input limits for
:	each port.  When IZBF is called, each entry is initialized to
:	MAXCHAR, but individual input limits may be changed afterwards.
:	When an input limit activation occurs, the user is given a chance
:	to empty the buffer.  If the buffer is still over the input limit
:	when the user code returns, backpressure is applied on that port.

:	In addition, if the symbol MBUFER is defined and positive,
:	FRONT.LIB will be assembled to work with the microcode buffer
:	library.  The library MBUFER.LIB defines this symbol, so if it
:	is assembled before FRONT.LIB, the user will not have to define
:	it.  Note that the use of this library changes the buffer pointers
:	to be fullword rather than halfword pointers.

	GL	NPORT,MAXCHAR,ECHO,TISIS,BREAK,MBREAK,PROCESS,ACP,CHRLIM
	GL	IZFRONT,INPUT,OUTPUT,ECHOFF,UMTOSS,PTTOUT,ZAPPRT,UMTOTB
	GL	TOPUT,TORET
	GL	GCI,WCI,BCT,BBELL,BELCOL,DCT

	MO	.,FRONT

	SEG	A.DATA

	GL	CNTRL
	IF	\CNTRL
CNTRL	EQ	CNTRL!280	:Make sure zappers get acknowledged
	ELSE
CNTRL	EQ	80		:Zapper ack's on
	EI

WAITZA	EQ	1		:Clean up on Zapper ack's

BREAK	HS	2*NPORT		:pointer to data break array
MBREAK	HS	2*NPORT		:pointer to message break array
PROCESS HS      2*NPORT         :-> user supplied process data routine
ATIME	HS	2*NPORT		:next time to activate user.
CHRLIM	HS	NPORT		:Input char limit before backpressuring
XLIMIT	BS	NPORT		:max number of data characters we can send at one time.
PORT	HS	1		:CURRENT PORT WE ARE PROCESSING
BUFFER	HS	1		:CURRENT BUFFER INDEX WE ARE PROCESSING.
SAVE	HS	20		:save registers here
RETP	HS	2		:save return here.

NGRP	EQ	(NPORT+0F)/10	:number of port groups to process.
ACP	HS	NGRP		:active ports.
PTIME	HS	NGRP		:ports on activate timeout.
TOISIS	HS	NGRP		:ports we can send data on.
FRISIS	HS	NGRP		:ports we have NOT backpressured.
DEM	HS	NGRP		:ports in defered echo mode.
ECHOFF	HS	NGRP		:Ports in no-echo mode
OUTCRT	HS	NGRP		:Port has 'outbuilt' aux. circuit
GBALL	HS	NGRP		:HAVE A GREEN-BALL FOR THESE PORTS
WTZA	HS	NGRP		:Expecting Zapper Ack to arrive
PRTSVC	HS	1		:PORT ELIGIBLE FOR SERVICE INDICATOR
	IF	\DCTFLG
DCT	WS	NBUF		:DATA COUNTS
	EI

	SEG	A.CODE		:THE CODE AND DATA AREA.
 
:	HANDY INDEXABLE HALFWORD BIT MASKS
HMASK	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1


:	DEFAULT BREAK ARRAY (CARRIAGE RETURN ONLY)
DEFAULT	HC	4,0,0		:C/R ONLY
	HC	0,0,0
	HC	0,0,4		:C/R ONLY
	HC	0,0,0
	HC	0,0,0
	HC	0

:	-----	ISIS INTERFACE	-----

:	BIT ARRAY TO IDENTIFY DATA MESSAGES
BDATA	HC	07FFF,-1,-1	:00
	HC	-1,-1,-1	:30
	HC	-1,-1,-1	:60
	HC	0FFFC,0,0	:90
	HC	0,0,0		:C0
	HC	0		:F0

BCTL	HC	0,0,0		:00	BIT ARRAY TO IDENTIFY CONTROL MESSAGES REQUIRING SPECIAL HANDLING
	HC	0,0,0		:30
	HC	0,0,0		:60
	HC	3,0F000,3740	:90  9E 9F A0 A1 A2 A3 B2 B3 B6 B7 B9
	HC	0,0,0		:C0
	HC	0		:F0


	IF	\WAITZA
	ELSE
WAITZA	EQ	0
	EI

	IF	\NOESC0
	ELSE
NOESC0	EQ	0
	EI

	IF	\MBUFER
	ELSE
MBUFER	EQ	0		:Default MBUFER to off.
	EI


LENGTH	BC	0		:MESSAGE LENGTH TABLE
	RE	9D;	BC	.-LENGTH+1;	NOLIST;	ER;	LIST	:DATA TEXT STRINGS
	BC	1		: 9E	DETACH
	BC	1		: 9F	DISCONNECT
	BC	1		: A0	APPLY BACKPRESSURE
	BC	1		: A1	RELEASE BACKPRESSURE
	BC	1		: A2	FLUSH FORWARD
	BC	1		: A3	FLUSH BACKWARD
	BC	1		: A4	BLACK BALL
	BC	1		: A5	GREY BALL
	BC	1		: A6	ENTER "DEM"
	BC	1		: A7	LEAVE "DEM"
	BC	1		: A8	ENTER "TRANSPARENCY"
	BC	1		: A9	LEAVE "TRANSPARENCY"
	BC	1		: AA	GREEN BALL
	BC	1		: AB	RED BALL
	BC	1		: AC	YELLOW BALL
	BC	1		: AD	ORANGE BALL
	BC	1		: AE	"BREAK" DETECTED
	BC	1		: AF	"HANG UP"
	BC	2		: B0	QUERY TERMINAL PARAMETER
	BC	3		: B1	SET TERMINAL PARAMETER
	BC	4		: B2	PSEUDO-NEEDLE
	BC	2		: B3	LOGON CHARACTER
	BC	2		: B4	NORMAL LOGON STATUS
	BC	2		: B5	LOGON FAILURE
	BC	8		: B6	SUCCESSFUL LOGON FROM THIS PORT
	BC	6		: B7	ADDENDUM TO ACCOUNTING
	BC	1		: B8	SUPER-"HANG UP"
	BC	2		: B9	TRANSMIT LIMIT
	BC	1		: BA	Break end
	BC	1		: BB	Zapper acknowledgement
	BC	1		: BC	ENTER Alternate Output Device Mode
	BC	1		: BD	LEAVE     "        "      "     "
	BC	2		: BE	Zapper with Reason Code
	BC	1		: BF	SIIX Comand
	BC	1		: C0	TIIX Command


:		**INTERFACE DATA TYPES**


NEDMSG	EQ	0		:NEEDLE
FIRST	EQ	9E		:FIRST MESSAGE IN LIST
DETMSG	EQ	9E		:DETACH MESSAGE
ZAPMSG	EQ	9F		:DISCONNECT MESSAGE
NOSMSG	EQ	0A0		:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1		:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2		:FLUSH OUTPUT
BKGMSG	EQ	0A3		:FLUSH INPUT
BLKMSG	EQ	0A4		:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5		:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6		:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7		:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8		:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9		:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA		:GREEN BALL
RBMSG	EQ	0AB		:RED BALL
YBMSG	EQ	0AC		:YELLOW BALL
OBMSG	EQ	0AD		:ORANGE BALL
BRKMSG	EQ	0AE		:BREAK DETECTED
HNGMSG	EQ	0AF		:HANG UP
QTPMSG	EQ	0B0		:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1		:SET TERMINAL PARAMETER
PNDMSG	EQ	0B2		:PSEUDO NEEDLE
NLOGCH	EQ	0B3		:NORMAL LOGON CHAR
NLOGST	EQ	0B4		:NORMAL LOGON STATUS
LOGFAL	EQ	0B5		:NORMAL LOGON STATUS
LOGOK	EQ	0B6		:SUCCESSFUL NORMAL LOGON
ADACTG	EQ	0B7		:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8		:SUPER-HANG UP
XMTLIM	EQ	0B9		:Transmit Limit
BRKEND	EQ	0BA		:Break End
ZAPACK	EQ	0BB		:Zapper Acknowledgement
EAODM	EQ	0BC		:ENTER Alternate Output Device Mode
LAODM	EQ	0BD		:LEAVE     "        "      "     "
ZAPREA	EQ	0BE		:Zapper with Reason Code
SIIX	EQ	0BF		:SIIX Command
TIIX	EQ	0C0		:TIIX Command
MAXTYP	EQ	0C0		:MAXIMUM TYPE DEFINED

:	INPUT FROM ISIS
INPUT   ST      R0,RETP,,       :Save return
INPUT1	JAL	R4,LOOK,,	:IS THERE ANYTHING THERE?
	J	RET		:NORMAL RETURN...JUST EXIT
	LR	R12,R1		:SET BREAK # 0, EXCEPT FOR PORT 0
	JN	INPUT2		:SKIP IF NOT PORT 0
	JAL	R4,GETH,,	:PORT 0---SPECIAL
	EXBR	R5,R0		:GET CODE
	LBR	R5,R5
	LR	R5,R5		:CHECK FOR MESSAGE 0
	JE	SPEC4		:IGNOR IF SO
	LB	R7,SPECL,R5	:GET MESSAGE REMAINDER LENGTH
	THI	R7,80		:80 FLAG MEANS WE HAVE NO BUSINESS GETTING THESE...
	JEFS	SPEC0
	JAL	R10,CRASH	:CRASH IF WE DO

SPEC0	LR	R5,R0		:COPY MESSAGE
	JAL	R6,PAIR		:ELSE PLACE MESSAGE TYPE IN BUFFER 0
SPEC1	SIS	R7,1		:ANY MORE
	JLEFS	SPEC3
	JAL	R4,GETCH,,	:YES
	JNFS	SPEC2		:TEST IF CHARACTER SHOULD BE ESCAPED
	JAL	R4,WCI		:ESCAPE IT
SPEC2	JAL	R4,WCI
	JBS	SPEC1
SPEC3	LCS	R0,5		:DONE...SET PORT 0 MESSAGE CODE
	JAL	R4,ACTIV
SPEC4	JAL	R4,ELIR,,	:DONE...END LOGICAL INPUT RECORD
	J	INPUT1		:AND CONTINUE

SPECL	BC	0,0,1,86,88,85,5,88	:LENGTH OF SPECIAL (PORT 0) MESSAGES
	BC	88,4,87,4,87,80,80,80	:"80" MEANS TO CRASH

INPUT2  STH     R1,PORT,,       :Save ISIS port number
	LR	R9,R1		:And copy out of the way
	SLLS	R1,2		:Convert to fullword pointer
	LR	R8,R1		:Copy
    IF MBUFER
	SLLS	R1,1		:CONVERT TO BUFFER NUMBER
    ELSE			:(Coincidence - FW pointer = buffer #)
    EI
        STH     R1,BUFFER,,
	JAL	R4,GETCH,,	:SKIP OVER MESSAGE TYPE
	TBT	R0,BDATA	:IS THIS DATA MESSAGE?
	JE	INCONT		:NO...SKIP TO PROCESS CONTROL

:	TEXT MESSAGE...PASS TO BUFFER, ACTIVATE IF TOO MANY CHARS, BREAK CHAR
	LR	R5,R0		:YES...SAVE COUNT OF CHARS
        L       R10,BREAK,R8,   :GET POINTER TO PORT'S BREAK TABLE
	JNFS	INDAT1		:SKIP IF NOT NULL
	LA	R10,DEFAULT	:ELSE SET DEFAULT
	ST	R10,BREAK,R8,

INDAT1	JAL	R4,GETCH,,
	LR	R0,R0		:GET AND TEST A CHAR
	JNFS	INDAT2		:SKIP IF NOT NULL
	IF NOESC0
	ELSE
	JAL	R4,WCI		:ESCAPE ALL ZEROS
	EI
INDAT2	JAL	R4,WCI		:COPY THE CHAR TO BUFFER
	IF	\DCTFLG
	LIS	R2,1
        AHM     R2,DCT,R1,      :Update data counter
	EI

        TBT     R9,ECHOFF,,     :No echo mode?
	JNFS	INDAT4		:Yes, never echo

        TBT     R9,DEM,,        :Are we to do echoing?
	JEFS	INDAT4		:SKIP IF NOT
    IF MBUFER
	AIS	R1,4		:SET OUTPUT BUFFER
    ELSE
	AIS	R1,2		:SET OUTPUT BUFFER
    EI
	JAL	R4,WCI
	LR	R0,R0		:IS THE ECHOED CHAR TO BE ESCAPED?
	JNFS	INDAT3		:SKIP IF NOT
	JAL	R4,WCI		:ELSE DO SO
INDAT3
    IF MBUFER
	SIS	R1,4		:REVERT TO INPUT BUFFER INDEX
    ELSE
	SIS	R1,2		:REVERT TO INPUT BUFFER INDEX
    EI
INDAT4	TBT	R0,0,R10	:CHECK IF BREAK CHAR
	JEFS	INDAT5
	LR	R2,R0		:OK...WE'VE GOT A BREAK CHAR...PASS IT ON IN R2
	LIS	R0,0		:SET BREAK ACTIVATION CODE
	JAL	R4,ACTIV	:GO ACTIVATE JOB
INDAT5	SIS	R5,1
	JG	INDAT1		:REPEAT FOR ALL CHARS
	JAL	R4,ELIR,,	:END LOGICAL INPUT RECORD
	IF	\DCTFLG
        LHL     R0,DCT,R1,      :Check Buffer size
	ELSE
	LHL	R0,BCT,R1
	EI
	LHL	R4,BELCOL,R9,R9	:Check bell column #
	JE	INDAT6		:Skip if bell column hasn't been set
	CR	R0,R4		:Compare the dct with bell column #
	JL	INDAT6
	LR	R2,R0		:Save BCT/DCT
    IF MBUFER
	AIS	R1,4		:Point to output buffer
    ELSE
	AIS	R1,2
    EI
	LHI	R0,BBELL
	JAL	R4,WCI		:Send it
    IF MBUFER
	SIS	R1,4		:Point back to input buffer
    ELSE
	SIS	R1,2
    EI
	LIS	R0,0
	STH	R0,BELCOL,R9,R9
	LR	R0,R2		:Copy counter back
INDAT6	CLH	R0,CHRLIM,R9,R9	:AGAINST LIMIT FOR PORT
	JL	INPUT1		:CONTINUE IF FULL
	LCS	R0,2		:IF EXCEEDED, BREAK NOW
	JAL	R4,ACTIV	:ACTIVATE PORT PROCESS..CODE -2
	IF	\DCTFLG
        LHL     R0,DCT,R1,      :Get data count
	ELSE
	LHL	R0,BCT,R1	:Now get buffer count
	EI
	CLH	R0,CHRLIM,R9,R9	:Still full?
	JL	INPUT1		:No, don't backpressure
        RBT     R9,FRISIS,,     :Set backpressure indicator
        LIS     R0,3
        LR      R1,R9
        LHI     R2,NOSMSG       :APPLY BACKPRESSURE OURSELVES
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
	J	INPUT1		:THEN PROCESS ANOTHER RECORD

:	NOT DATA...PROCESS IT
INCONT	LR	R3,R0		:COPY MESSAGE TYPE
	JN	INCON		:SKIP IF NOT NEEDLE

:	Handle needle that has arrived
        SBT     R9,ACP,,        :Set now, host may reset to reject needle
	JEFS	NEED2
	JAL	R10,CRASH	:It was already set, impossible
NEED2
	JAL	R4,GETCH,,	:NEEDLE...SKIP LENGTH
	JAL	R4,GETW,,;	LR	R5,R0		:INVOICE NUMBER
	JAL	R4,GETH,,;	LR	R6,R0		:DESTINATION HOST
	JAL	R4,GETH,,;	LR	R7,R0		:SOURCE NODE
	JAL	R4,GETH,,;	LR	R8,R0		:SOURCE HOST
	JAL	R4,GETH,,;	LR	R9,R0		:SOURCE PORT
	JAL	R4,GETW,,	:EXPANSION
	JAL	R4,GETH,,;	LR	R10,R0		:DIALECT
	JAL	R4,GETCH,,;	LR	R11,R0		:TID
	JAL	R4,GETCH,,;	LR	R12,R0		:CHARACTERS IN USER NAME
	LR	R13,R0		:SAVE A COPY FOR US TO COUNT WITH
NEEDLE	JAL	R4,GETCH,,
	JAL	R4,WCI		:MOVE A CHARACTER
	SIS	R13,1
	JGBS	NEEDLE		:REPEAT UNTIL DONE
	JAL	R4,ELIR,,	:END LOGICAL INPUT RECORD
	LCS	R0,1		:SET NEEDLE CODE..-1
	JAL	R4,ACTIV	:ACTIVATE USER CODE
:	host wants circuit?
        LHL     R1,PORT,,
        TBT     R1,ACP,,        :Still set?
	JE	NEDZAP		:no, zap

   IF	ECHO
:		TYMSAT SHOULD ECHO
	THI	R11,1F		:CHECK FOR TERMINAL
	JE	NEED1		:SKIP IF NOT
	THI	R11,20		:CHECK IF HALF DUPLEX TID
	JNFS	NEED0		:DON'T SET DEM IF SO
        SBT     R1,DEM,,
NEED0   RBT     R1,GBALL,,      :Set to correct initial state
	LIS	R0,5
	LHI	R2,STPMSG
	JAL	R4,SLOR,,	:SET ECHO ON/OFF
	LIS	R0,0
	JAL	R4,PUTCH,,

  IF	INECHO			:Initial state should be No-Echo
	LIS	R0,0		:Echo Off
  ELSE
	LIS	R0,1		:Echo On
  EI	: INECHO

	JAL	R4,PUTCH,,
	JAL	R4,ELOR,,
   EI	:ECHO

NEED1	LHI	R0,FIRST-1	:SET UP TRANSMIT LIMIT FOR PORT
        STB     R0,XLIMIT,R1,
        SBT     R1,TOISIS,,     :Clear backpressures
        SBT     R1,FRISIS,,
	J	INPUT1		:GO BACK FOR MORE INPUT

NEDZAP	LIS	R0,3		:zap length
	LHI	R2,ZAPMSG
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
	J	INPUT1

:	NOT A NEEDLE...DOES USER WANT TO PROCESS MESSAGE?
INCON
        L       R10,MBREAK,R8,  :R10 -> Message Break table
	JE	INCTL		:IGNORE IF NULL
	TBT	R0,0,R10	:DOES HE WANT TO HANDLE IT?
	JE	INCTL		:NO...WE'LL DO IT
	LR	R5,R0		:HE WANTS TO
	LHL	R4,BCT,R1	:CHECK IF BUFFER IS EMPTY
	JEFS	INCON1		:SKIP IF SO
	LCS	R0,3		:ELSE GIVE A CHANCE TO FLUSH IT
	JAL	R4,ACTIV
INCON1
   IF   \UMTOSS
	LA	R10,UMTOTB,,
	TBT	R5,0,R10	:should we put message in buffer?
	JN	INCON5		:Nope
   EI
	JAL	R6,PAIR		:FIRST PLACE ESCAPED MESSAGE TYPE
	LB	R7,LENGTH,R5
INCON2	SIS	R7,1
	JLEFS	INCON3		:SKIP WHEN DONE
	JAL	R4,GETCH,,
	JAL	R4,WCI		:COPY A CHAR
	JBS	INCON2		:MOVE AS MANY AS NECESSARY
INCON3	LR	R0,R5		:SET MESSAGE TYPE (CODE>0)
	JAL	R4,ACTIV	:ACTIVATE USER
	TBT	R5,BCTL		:DO WE WANT TO PROCESS THIS TOO?
	JNFS	INCON4		:SKIP IF SO
	JAL	R4,ELIR,,	:ELSE END LOGICAL INPUT RECORD
	J	INPUT1		:THEN GO BACK FOR ANOTHER RECORD

INCON4	JAL	R4,LOOK,,	:WE WANT TO LOOK TOO...BACK UP
	JAL	R10,CRASH	:ERROR IF WE TAKE THIS RETURN
	JAL	R4,GETCH,,	:GET THE MESSAGE AGAIN
	LR	R3,R0		:COPY IT
	JFS	INCTL

INCON5	LB	R7,LENGTH,R5
INCON6	SIS	R7,1
	JLE	INCON3
	JAL	R4,GETCH,,
	JBS	INCON6



:	PROCESS THE MESSAGE OURSELF
INCTL	SLHLS	R3,2		:MAKE A WORD INDEX
	J	IFAN-(4*FIRST),R3	:AND GO PROCESS MESSAGE

:	INPUT FANOUT FOR SPECIAL PROCESSING
IFAN	J	ZAP		:9E - ZAPPER
	J	ZAP		:9F - DISCONNECT
	J	NOSEND		:A0 - APPLY BACK-PRESSURE
	J	RESEND		:A1 - RELEASE BACK-PRESSURE
	J	GOBBLE		:A2 - FLUSH FORWARD
	J	FLBACK		:A3 - FLUSH BACKWARD
	J	OB		:A4 - DATA LOST IN THIS DIRECTION
	J	TOSS		:A5 - DATA LOST IN OTHER DIRECTION
	J	EDEM		:A6 - ENTER DEFERED ECHO MODE
	J	LDEM		:A7 - LEAVE DEFERED ECHO MODE
	J	TOSS		:A8 - ENTER TRANSPARENCY
	J	TOSS		:A9 - LEAVE TRANSPARENCY
	J	GB		:AA - GREEN BALL
	J	RB		:AB - RED BALL
	J	OB		:AC - YELLOW BALL
	J	TOSS		:AD - ORANGE BALL
	J	TOSS		:AE - BREAK DETECTED
	J	TOSS		:AF - HANG UP
	J	TOSS		:B0 - QUERY TERMINAL PARAMETER
	J	SETTP		:B1 - SET TERMINAL PARAMETER
	J	TOSS		:B2 - PSEUDO NEEDLE
	JAL	R10,CRASH	:B3 - LOGON CHAR---WE SHOULDN'T GET THESE!
	J	TOSS		:B4 - NORMAL LOGON STATUS
	J	TOSS		:B5 - LOGON FAILURE
	J	B6MSG		:B6 - Succesful circuit build
	JAL	R10,CRASH	:B7 - ADDENDUM TO ACCOUNTING---WE SHOULDN'T GET THESE
	J	TOSS		:B8 - SUPER-HANG UP
	J	XLIM		:B9 - TRANSMIT LIMIT
	J	TOSS		:BA - Break End
	J	ZA		:BB - Zapper Ack
	J	TOSS		:BC - Enter Alternate Output Device Mode
	J	TOSS		:BD - Leave     "        "      "     "
	J	ZR		:BE - Zapper with Reason Code



:	TOSS A MESSAGE
TOSS	LB	R0,LENGTH,R2	:PICK UP MESSAGE LENGTH
	SIS	R0,1		:WE'VE ALREADY GOTTEN MESSAGE TYPE
	JAL	R4,FLUSH,,	:DELETE REMAINDER OF MESSAGE
	J	INPUT1		:AND CONTINUE

:	DISCONNECT
ZAP	JAL	R4,ELIR,,	:END LOGICAL INPUT RECORD
        LHL     R1,BUFFER,,     :Get buffer number
	JAL	R4,EMPTY	:EMPTY INPUT BUFFER
    IF MBUFER
	AIS	R1,4
    ELSE
	AIS	R1,2
    EI
	JAL	R4,EMPTY	:EMPTY OUTPUT BUFFER
        RBT     R9,ACP,,        :Set port not active
        RBT     R9,DEM,,        :Not in DEM
        RBT     R9,OUTCRT,,     :No longer 'outbuilt'
        RBT     R9,WTZA,,       :Not waiting for Zap Ack
        RBT     R9,GBALL,,      :No green balls
        RBT     R9,PTIME,,      :Turn off timeout
        SBT     R9,TOISIS,,     :Clear backpressure
        SBT     R9,FRISIS,,
	J	INPUT1

: Zapper Acknowledgement
ZA
        RBT     R9,WTZA,,       :Reset ZapAck wait bit
	JN	ZA1		:We were expecting it
	J	TOSS		:Could crash here
ZA1
	J	ZAP		:Do Zap stuff now

:	APPLY BACKPRESSURE
NOSEND	JAL	R4,ELIR,,	:END LOGICAL INPUT RECORD
        RBT     R9,TOISIS,,
	J	INPUT1		:AND CONTINUE

:	RELEASE BACKPRESSURE
RESEND	JAL	R4,ELIR,,	:END LOGICAL INPUT RECORD
        SBT     R9,TOISIS,,     :Turn it on for port
	J	INPUT1

:	GOBBLER
GOBBLE	JAL	R4,ELIR,,	:END LOGICAL INPUT RECORD
        LHL     R1,BUFFER,,
	JAL	R4,EMPTY	:EMPTY INPUT BUFFER
        SBT     R9,FRISIS,,     :Check if we've applied backpressure
	J	INPUT1		:AND CONTINUE

:	FLUSH BACKWARD
FLBACK	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
        LHL     R1,BUFFER,,
    IF MBUFER
	AIS	R1,4		:COMPUTE OUTPUT BUFFER
    ELSE
	AIS	R1,2		:COMPUTE OUTPUT BUFFER
    EI
	JAL	R4,EMPTY	:EMPTY IT
	LIS	R0,3
	LR	R1,R9		:Port #
	LHI	R2,GOBMSG	:SEND GOBBLER IN OTHER DIRECTION
	JAL	R4,SLOR,,	:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
	J	INPUT1		:DO ANOTHER MESSAGE

:	ENTER DEM
EDEM	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
        TBT     R9,OUTCRT,,     :Acting as remote?
	JN	INPUT1		:YES, SHOULDN'T GET EDEM
        SBT     R9,DEM,,        :Set DEM
	J	INPUT1		:AND DO ANOTHER

:	LEAVE DEM
LDEM	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
        RBT     R9,DEM,,        :Clear DEM
	J	INPUT1		:AND DO ANOTHER

:	GREEN BALL
GB	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LR	R1,R9		:GET PORT NUMBER
        LHL     R2,BUFFER,,     :Get buffer number
    IF MBUFER
	LHL	R0,BCT+4,R2	:CHECK IF OUTPUT BUFFER IS EMPTY
    ELSE
	LHL	R0,BCT+2,R2	:CHECK IF OUTPUT BUFFER IS EMPTY
    EI
	JEFS	GB1		:SKIP IF SO
        SBT     R1,GBALL,,      :Not empty ... set flag
	J	INPUT1
GB1	LIS	R0,3		:EMPTY...RETURN GREEN BALL
	LHI	R2,GBMSG
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,	:SEND GREEN BALL BACK
	J	INPUT1

:	RED BALL
RB	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LR	R1,R9		:GET PORT NUMBER
        RBT     R1,GBALL,,      :Flush any pending Green Ball
	LIS	R0,3
	JAL	R4,SLOR,,	:Reflect Red Ball
	JAL	R4,ELOR,,
	J	INPUT1		:AND PROCESS NEXT MESSAGE

:	ORANGE (OR BLACK) BALL
OB	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LIS	R0,3
	LR	R1,R9		:GET PORT NUMBER
	AIS	R2,1		:SET OTHER BALL OF PAIR
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,	:SEND IT BACK
	J	INPUT1		:AND CONTINUE

:	TRANSMIT LIMIT
XLIM	JAL	R4,GETCH		:GET RESTRICTION
	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LBR	R0,R0		:EXTRACT VALUE
	CLHI	R0,FIRST-1	:RANGE CHECK
	JLFS	XLIM1
	LHI	R0,FIRST-1
XLIM1   STB     R0,XLIMIT,R9,   :Set up restriction
	J	INPUT1

:	Set Terminal Parameters
SETTP	LR	R1,R9		:Get port #
        TBT     R1,OUTCRT,,     :Should we act like a remote ?
	JN	SETTP3		:Yes, go bounce the B1 back
	JAL	R4,GETCH	:Get B1 use code
	LR	R2,R0		:save it
	JAL	R4,GETCH	:get "value"
	JAL	R4,ELIR		:End input record
	LR	R2,R2		:This is echo control msg ?
	JN	INPUT1		:No, do nothing
	LR	R0,R0		:echo OFF ?
	JEFS	SETTP1		:OFF, jump
        SBT     R1,DEM,,        :echo ON starts in DEM by convention
        RBT     R1,ECHOFF,,
	J	INPUT1
SETTP1  RBT     R1,DEM,,
        SBT     R1,ECHOFF,,     :echo OFF
	J	INPUT1

SETTP3	LIS	R0,5		:length of B1
	LHI	R2,STPMSG	:B1 code
	JAL	R4,SLOR
	JAL	R4,GETCH
	JAL	R4,PUTCH	:type code
	JAL	R4,GETCH
	JAL	R4,ELIR
	JAL	R4,PUTCH	: "value"
	JAL	R4,ELOR,,	: reflect the B1
	J	INPUT1

:	B6 message - mark this as circuit built out
B6MSG   SBT     R9,OUTCRT,,
        SBT     R9,ECHOFF,,     :Enforce no echoing
        RBT     R9,DEM,,
        SBT     R9,TOISIS,,     :Clear back-pressures
        SBT     R9,FRISIS,,
	LHI	R0,FIRST-1	:port Xmit limit
        STB     R0,XLIMIT,R9,
        SBT     R9,ACP,,        :Set, test port active
	JE	TOSS
	JAL	R10,CRASH	:Port already active - gross error


:		Zapper with Reason Code - treat same as zapper except eat extra byte
ZR
	JAL	R4,GETCH	:Pick up reason code
	J	ZAP		:treat as zapper

:	OUTPUT TO ISIS

OUTPUT  ST      R0,RETP,,
	LHI	R12,(NGRP-1)*2
OUT0	LCS	R1,1		:SET UP MASK OF SERVICED PORTS
        STH     R1,PRTSVC,,     :Save PORT serviced mask
OUT1    LHL     R1,ACP,R12,     :Active port
        NH      R1,TISIS,R12,   :WITH DATA PRESENT
        NH      R1,TOISIS,R12,  :And not backpressured
        NH      R1,PRTSVC,,     :And not already serviced
	JNFS	OUT2		:SERVICE IF ANYTHING TO DO
	SIS	R12,2		:REPEAT FOR ALL GROUPS
        JGE     OUT0
	J	RET		:THEN EXIT
OUT2	JAL	R3,BIDH
	LR	R1,R12		:CONSTRUCT INTERNAL PORT NUMBER
	SLHLS	R1,3
	AR	R1,R2
        RBT     R2,PRTSVC,,     :Clear port to be serviced bit
        STH     R1,PORT,,
    IF MBUFER
	SLLS	R1,3		:MAKE BUFFER NUMBER
	AIS	R1,4
    ELSE
	SLLS	R1,2		:MAKE BUFFER NUMBER
	AIS	R1,2
    EI
        STH     R1,BUFFER,,
	JAL	R4,GCI		:PEEK AT NEXT CHAR
	LR	R5,R0
	JNFS	OUT3		:SKIP IF NOT AN ESCAPE
	JAL	R4,GCI		:ELSE GET ESCAPED CHAR
	LR	R5,R0		:SAVE COPY
	JN	OUT7		:SKIP IF NOT A "0"

:	WE HAVE DATA...CONSTRUCT A DATA MESSAGE
OUT3    LHL     R1,PORT,,
        LB      R6,XLIMIT,R1,   :Limit of chars we can send at once
	LHI	R0,3,R6		:HOW BIG THE RECORD WILL BE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	LR	R0,R5		:SEND FIRST CHAR
OUT4	JAL	R4,PUTCH	:SEND CHAR
        LHL     R1,BUFFER,,     :Get any further chars from BUFFER
	SIS	R6,1
	JGFS	OUT6		:DON'T MAKE MESSAGE TOO BIG
OUT5	JAL	R4,ELODR	:BIG ENOUGH...STOP NOW
        LHL     R1,BUFFER,,     :Get buffer number
	J	OUT10
OUT6	LH	R0,BCT,R1	:CHECK STATE OF BUFFER
	JLEBS	OUT5		:QUIT NOW IF BUFFER IS EMPTY
	JAL	R4,GCI		:OK...LOOK AT NEXT CHAR
	LR	R5,R0
	JN	OUT4		:NOT ESCAPED, SO SEND IT ON
	JAL	R4,GCI		:ESCAPED...LOOK AT NEXT
	LR	R5,R0		:COPY IT
	JE	OUT4		:PASS IF DATA
	JAL	R4,ELODR	:END LOGICAL OUTPUT DATA RECORD

:	WE GOT A CONTROL MESSAGE
OUT7	LB	R6,LENGTH,R5	:COPY IT
	LHI	R0,2,R6		:...TO THE ISIS BUFFER TOO
        LHL     R1,PORT,,
	LR	R2,R5
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
        LHL     R1,BUFFER,,     :Get any subsequent chars from buffer
OUT8	SIS	R6,1		:COPY THE WHOLE MESSAGE
	JLEFS	OUT9		:NO MORE...SKIP
	JAL	R4,GCI		:COPY ANOTHER CHAR OF MESSAGE
	JAL	R4,PUTCH
	JBS	OUT8		:AND GO BACK FOR ANY MORE
OUT9	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	SHI	R5,DETMSG	:CHECK IF CIRCUIT ZAPPER
	JLFS	OUT10		:SKIP IF NOT
	SIS	R5,ZAPMSG-DETMSG
	JGFS	OUT10
        LHL     R5,PORT,,       :Yes, get port #
: See if we should clean up now, or wait for zapper Ack
   IF   WAITZA
        SBT     R5,WTZA,,       :Tell ourselves to clean up when zap ack comes
   ELSE
        RBT     R5,ACP,,        :Clean up now
        RBT     R5,DEM,,
        RBT     R5,OUTCRT,,
        RBT     R5,GBALL,,
   EI
	J	OUT1

OUT10	LHL	R0,BCT,R1	:CHECK FOR EMPTY BUFFER
	JN	OUT1		:GO ON TO NEXT PORT IF NOT
        LHL     R1,PORT,,
        RBT     R1,GBALL,,      :Are we holding a green ball?
	JE	OUT1		:NO...GO ON
	LIS	R0,3
	LHI	R2,GBMSG
	JAL	R4,SLOR
	JAL	R4,ELOR		:BUFFER IS NOW EMPTY...RETURN GREEN BALL
	J	OUT1		:REPEAT FOR NEXT PORT

:	SEND A CHAR PAIR
:	R5 = CHAR PAIR
:	R6 = LINK
PAIR	EXBR	R0,R5		:FIRST CHAR
	JAL	R4,WCI
	LBR	R0,R5		:SECOND CHAR
	JAL	R4,WCI
	JR	R6		:AND RETURN


:	GENERAL RETURN ROUTINE
RET     L       R0,RETP,,       :Exit for several routines
	JR	R0


:	GENERAL ROUTINE TO ACTIVATE A PROCESS
:	LINK ON R4
ACTIV   STM     R1,SAVE,,
    IF MBUFER
	LR	R15,R1		:COPY BUFFER #
	SRLS	R15,1		:CONVERT TO FULLLWORD PONTER
        L       R15,PROCESS,R15,        :Locate process
    ELSE
        L       R15,PROCESS,R1,         :Locate process
    EI
	JNFS	ACTIV1
	JAL	R10,CRASH	:NONE...CRASH
	BC	0,0,4*R4,10	:CRASH TYPE 10
ACTIV1	LR	R0,R0		:OK...SET CONDITION CODES
	JALR	R15,R15		:NOW GO THERE
        LM      R1,SAVE,,       :Restore regs
	LR	R0,R0
	JLR	R4		:Return if timeout to be left alone
	JGFS	ACTIV2		:SKIP IF TO ACTIVATE ON TIMEOUT
        LHL     R0,PORT,,       :Else turn off activation on timeout
        RBT     R0,PTIME,,
	JR	R4		:AND RETURN
ACTIV2	A	R0,SLOWC,,	:SET UP TIMEOUT
    IF MBUFER
	SRLS	R1,1		:CONVERT TO FULLWORD POINTER
    EI
        ST      R0,ATIME,R1,
    IF MBUFER
	SLLS	R1,1		:CONVERT TO BUFFER #
    EI
        LHL     R0,PORT,,
        SBT     R0,PTIME,,
	JR	R4		:AND RETURN


:	INITIALIZE
IZFRONT ST      R0,RETP,,       :Save return
	LHI	R1,NPORT-1
	LHI	R2,MAXCHAR
IZF1    RBT     R1,PTIME,,      :Cancel outstanding timeouts
        SBT     R1,TOISIS,,     :Cancel all back-pressure
        SBT     R1,FRISIS,,
        RBT     R1,ACP,,        :Port not active
        RBT     R1,WTZA,,       :Reset Zap Ack expected bit
        RBT     R1,OUTCRT,,     :Port not 'outbuilt'
	STH	R2,CHRLIM,R1,R1	:Initialize input limits to MAXCHAR chars
	SIS	R1,1
	JGE	IZF1		:DO FOR ALL
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,HS		:PUT HALFSECOND LOGIC ON TIMEOUT
	LHI	R1,RATE/2,R7
	JAL	R5,TOPUT
	LA	R0,ONESEC	:PUT ONE SECOND LOGIC ON TIMEOUT
	LHI	R1,RATE,R7
	AHI	R1,RATE		:START ONE SECOND FROM NOW
	JAL	R5,TOPUT
	J	RET		:AND EXIT
:
: PTTOUT - Set timeout activation time for port
:	R0 = # of seconds from now to activate (0 = cancel)
:	R1 = buffer # on port (input side!)
:	Destroys R2
:	Link on R4
:

PTTOUT	LR	R2,R1		:Copy buffer #
	LR	R0,R0		:Check time
	JGFS	PTTSET		:Skip if positive
	IF	MBUFER
	SRLS	R2,3		:Convert to port #
	ELSE
	SRLS	R2,2		:Convert to port #
	EI
        RBT     R2,PTIME,,      :Cancel timeout
	JR	R4		:Return

PTTSET	A	R0,SLOWC,,	:Compute activation time
	IF	MBUFER
	SRLS	R2,1		:Convert to fullword pointer
	EI
        ST      R0,ATIME,R2,    :Save activation time
	SRLS	R2,2		:Convert to port #
        SBT     R2,PTIME,,      :Set timeout request bit
	JR	R4
:
: ZAPPRT - Send a zapper directly to the ring, bypassing the bufferlets.
:	This is the only way to disconnect a backpressured circuit
:	without having to wait for the backpressure to clear up.
:
:	Expects R1 = Port number, link on R5
:

ZAPPRT	LHI	R2,ZAPMSG	:A zapper
	LIS	R0,3		:Length of zap msg
	JAL	R4,SLOR		:Start message
	JAL	R4,ELOR		:End message
  IF WAITZA
        SBT     R1,WTZA,,       :Set waiting for zapper ack
  ELSE
        RBT     R1,ACP,,        :Clean up now
        RBT     R1,DEM,,
        RBT     R1,OUTCRT,,
        RBT     R1,GBALL,,
  EI
	JR	R5
:	HALF SECOND PROCESSERS
HS	AHI	R1,RATE/2
	JAL	R5,TOPUT	:RUN AGAIN IN ABOUT A HALF SECOND

:	CHECK ALL BUFFERS FOR BACKPRESSURE APPLIED, RELEASE WHERE POSSIBLE
	LHI	R5,(NGRP-1)*2
	LHI	R6,(NGRP-1)*10
HS1	LCS	R7,1
        XH      R7,FRISIS,R5,   :Backpressure applied
        NH      R7,ACP,R5,      :And port active
HS2	LR	R1,R7
	JNFS	HS3		:SOMETHING TO DO
	SIS	R5,2		:END OF A RING GROUP
	SHI	R6,10
	JGEBS	HS1		:NEXT RING GROUP
	J	TORET

HS3	JAL	R3,BIDH		:DETERMINE WHICH PORT ON GROUP MAY NEED SERVICE
	XH	R7,HMASK,R2,R2	:MARK PORT AS SERVICED
	AR	R2,R6
	LR	R1,R2		:SAVE COPY OF PORT #
    IF MBUFER
	SLLS	R2,3		:BUFFER NUMBER
    ELSE
	SLLS	R2,2		:BUFFER NUMBER
    EI
	IF	\DCTFLG
        LH      R0,DCT,R2,      :Contents of DCT
	ELSE
	LH	R0,BCT,R2	:CONTENTS OF INCOMING BUFFER
	EI
	SH	R0,CHRLIM,R1,R1	:Below limit?
	JG	HS2		:NOT YET
        SBT     R1,FRISIS,,
        LIS     R0,3
        LHI     R2,SNDMSG
        JAL     R4,SLOR,,       :RELEASE BACKPRESSURE
        JAL     R4,ELOR,,
	J	HS2		:AND PROCEED


:	ONE SECOND LOGIC
ONESEC	AHI	R1,RATE
	JAL	R5,TOPUT	:DO AGAIN IN ANOTHER SECOND
	LHI	R15,(NGRP-1)*2	:SEARCH BY GROUPS
OS1     LH      R14,ACP,R15,    :Active port
        NH      R14,PTIME,R15,
	JNFS	OS3		:SKIP IF ANY TO DO
OS2	SIS	R15,2
	JGEBS	OS1		:REPEAT FOR ALL GROUPS
	J	TORET		:THEN EXIT

OS3	LR	R1,R14		:COPY MASK OF PORTS TO PROCESS
	JEBS	OS2		:NONE...GO ON TO NEXT GROUP
	JAL	R3,BIDH
	XH	R14,HMASK,R2,R2	:SET IT EXAMINED
	LR	R1,R15
	SLHLS	R1,3		:MAKE PORT # (ALLOW FOR COUNT BY 2'S)
	AR	R1,R2
        STH     R1,PORT,,
	SLHLS	R1,2		:MAKE BUFFER NUMBER
        L       R0,ATIME,R1,    :Check if timeout has expired
    IF MBUFER
	SLLS	R1,1		:CONVERT TO BUFFER #
    EI
        STH     R1,BUFFER,,
	S	R0,SLOWC,,
	JG	OS3		:NO...IGNOR FOR NOW
        LHL     R0,PORT,,       :Get port #
        RBT     R0,PTIME,,      :Clear timeout for port
	LCS	R0,4		:YES...SET ACTIVATION DUE TO TIMEOUT
	JAL	R4,ACTIV	:AND ACTIVATE PORT
	J	OS3		:AND GO DO ANOTHER


	EM
   	SUBTTL	Nucleus Debugging Macros                        ndbmac.nad
	RA	0

	IF	\NUCDB
	ELSE
NUCDB	EQ	0	:DEFAULT IS NO DEBUG
	EI

:	Macros to put debugging messages into rings.  Should be called only
:	from background or race conditions may occur.  Macros are of
:	the form:
:
:		NDBn(DEBUGTYPE,REG1,REG2,MESSAGE,ARG1,...,ARGn)
:
:	where DEBUGTYPE is the message type,
:	n is the number of arguments, REG1 and REG2 are the registers to
:	be used (they will be destroyed), MESSAGE is the message number
:	which corresponds to a message defined in NUCDB.NAD, and ARG1
:	through ARGn are the registers containing the arguments.

NDB0	MACRO(DBTYP,REG1,REG2,MSG)[
	IF	DBTYP&NUCDB
	LH	REG1,NDBWT
	LHI	REG2,MSG
	NDBPUT(REG1,REG2)
	STH	REG1,NDBWT
	EI]

NDB1	MACRO(DBTYP,REG1,REG2,MSG,ARG1)[
	IF	DBTYP&NUCDB
	LH	REG1,NDBWT
	LHI	REG2,MSG
	NDBPUT(REG1,REG2)
	NDBPUT(REG1,ARG1)
	STH	REG1,NDBWT
	EI]

NDB2	MACRO(DBTYP,REG1,REG2,MSG,ARG1,ARG2)[
	IF	DBTYP&NUCDB
	LH	REG1,NDBWT
	LHI	REG2,MSG
	NDBPUT(REG1,REG2)
	NDBPUT(REG1,ARG1)
	NDBPUT(REG1,ARG2)
	STH	REG1,NDBWT
	EI]

NDBPUT	MACRO(REG,ARG)[
	STH	ARG,NDBBUF,REG
	AIS	REG,2
	JLFS	.+6
	LHI	REG,-NDBSIZ]

NDBINI	MACRO(REG)[
	IF	NUCDB
	LHI	REG,-NDBSIZ
	STH	REG,NDBWT
	EI]
        SUBTTL  EQUATES AND DATA STRUCTURES                common.nad
        REMARK %COMMON  V 1.9, 10-06-72, RNP
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::         PASCAL NUCLEUS COMMON EQUATES AND DATA STRUCTURES         ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
: See the file (ISIS2)NUCLUS.INF for more revision information.
:
: V 1.9, 10-06-82, RNP
:       Changes for Extended Memory Option
: V 1.8, 11-06-81, SCY
:	1) Global variable pointer added to header
:	2) ENTR1 & ENTRFG added to header for retrieving process name
:	    if current running process is under init routine
:	3) Line option flag is added to code prefix
: V 1.7, 05-09-81, SMF
:	1) Printer command structure added to DPB structure, and operation
:	    symbols defined.
:	2) Added new terminal operation to send a B1 message to the
:	    port, with user-supplied arguments.
:	3) Added crash code for re-used delay queue variable.
: (No history available for versions 1.2 - 1.6)
:
: V 1.1, 07-15-80, SMF
:	PROCESS STATE FIELD ADDED TO HEADER
: V 1.0, 07-15-80, SMF
:	1) Major restructuring to allow easier structure modifications
:	2) Minor bug fixes
: V 0.8, 05-30-80, RNP
:       NEW CRASH CODE FOR AUX CIR TIMEOUT ERROR
: V 0.7, 02-25-80, RNP
:       MADE STU'S CHANGES IN OUTDIAL EQUATES
: V 0.6, 02-08-80, RNP
:       1) ADDED APROT DEFINITIONS FOR ISIS2 PROTECTION
:       2) CRSH18 NO LONGER USED
:       3) DEFINED BLDAUX (ISIS-2 MSG CODE)
:       4) ADDED MINPRO FOR MINIMUM NUMBER OF PROCS AND GATES
:       5) MOVED ADDSIZ TO COM FILE
:       6) ADDED STU'S OUTDIAL STUFF FOR ISIS2
:
        MO      .,COMMON
:
        GL      IRSIZE,ORSIZE,CNTRL,NPORT,MAXCHAR,NGRP,ECHO
        GL      NBFLET,NBUF,NTOUT
        GL      APROT0,APROT1,APROT2,APROT3,APROT4,APROT5,APROT6
        GL      APROT7,APROT8,APROT9,APROTA,APROTB,APROTC,APROTD
        GL      SEG0LO,SEG0HI,S0HORG
:
	 RA   $0 0A		SET RADIX DECIMAL
:
ADC	 EQ   4
LADC	 EQ   2
ON	 EQ   1
OFF	 EQ   0

:  The symbols seg0lo and seg0hi are defined to partition segment 0 into
:  two parts. the low part can be addressed by rx1 type instructions. The
:  purpose of this is to put the former seg2 stuff into the high part of
:  seg0, permitting the old seg0 stuff to remain rx1 addressable.

	IF	\S0HORG
	ELSE
S0HORG	EQ	$00000	:where to put high part seg 0
	EI
SEG0HI  EQ      S0HORG          : beginning of non-rx1 space

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								      :
:	 REGISTER EQUATES					      :
:								      :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	USED BY NUCLEUS
:
RA	 EQ   10		:NUCLEUS STACK POINTER
HD	 EQ   11		:PROCESS HDR RECORD POINTER
XS	 EQ   12		:STACK POINTER
G	 EQ   13		:GLOBAL VARIABLE POINTER
B	 EQ   14		:BASE REGISTER POINTER
QR	 EQ   15		:LINKAGE REGISTER
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:        PASCAL SYSGEN PARAMETERS                                     :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
PROCS   EQ      NDIAL*3+NPORT*2+MINPRO  :MAX NUMBER OF PROCESSES
GATES   EQ      NDIAL*3+NPORT*2+MINPRO  :MAX NUMBER OF PROCESSES
TIMSLI  EQ      ON              :TURN OFF TIME SLICE?
DEBUG   EQ      OFF             :ASSEMBLE DEBUGGING AIDS
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								      :
:	 LENGTHS OF PASCAL PRIMITIVE DATA TYPES 		      :
:								      :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
XINTEG	 EQ   2 		  BYTES
XFWINT   EQ   4
XREAL	 EQ   8 		  BYTES
XBOOLE	 EQ   2 		  BYTES
XCHAR	 EQ   2 		  BYTES
XADDRE	 EQ   2 		  BYTES
XREG	 EQ   ADC
XTS	 EQ   ADC*2
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								      :
:	 PROCESS STATES						      :
:								      :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
ST.RUN	EQ	1	:RUNNING
ST.RDY	EQ	2	:READY QUEUE
ST.IO	EQ	3	:IO WAIT
ST.GAT	EQ	4	:GATE QUEUE
ST.DLY	EQ	5	:DELAYED
ST.WAI	EQ	6	:1 SEC WAIT QUEUE
ST.END	EQ	7	:ENDED
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       soloaddr - virtual disc segment solo system RESIDES           :
:       SEG0SV   - DISK ADR FOR SEG 0 SAVE                            :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:SOLOAD  EQ      $A 24*2
:SEG0SV  EQ      $A 8800+SLOT*100
:
:
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:	TIMER MANAGEMENT                                              :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
LARGIN  EQ      $A 600
SMALLI  EQ      1
WAITTI  EQ      1
MAXSLI  EQ      $A 600
TMEINT  EQ      LARGIN/10               : = 100
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:				  :				      :
:	 STRUCTURES		  :				      :
:	 THE FOLLOWING SECTION CONTAINS ALL ADDRESS STRUCTURES	      :
:				  :				      :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       CLOCK AND TIMER MANAGEMENT DATA STRUCTURE                     :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
TIM	 EQ   .
	 ORG  0
SEC	 BS   2*XINTEG		:CPAS OBJECT CODE EXPECTS FULLWORD!
FRAC	 BS   XINTEG
XTIM     EQ   .                 :SIZE OF STRUCTURE
	 ORG  TIM
:
:
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       HEADTYPE DATA STRUCTURE                                       :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:                               :type Headtype =
HEADTY  EQ      .               :
        ORG     0               :     Record
INDEX1  WS      1               :       Index: integer
HEAPT1  WS      1               :       Heaptop: integer
LINE1   WS      1               :       Line: integer
RESUL1  WS      1               :       Result: integer
RNTI1   BS      XTIM            :       Rntim: tim
SLICE1  HS      1               :       Slice: halfword
NESTI1  HS      1               :       Nesting: halfword
PRIOR1  HS      1               :       Priority: halfword
STATE1  HS      1               :       Process_state: halfword
JOB1    HS      1               :       Job: boolean
CONTI1  HS      1               :       Continue: boolean
ENTRFG  HS      1               :       Entry: boolean
VARPTR  WS      1               :       Global_var_ptr: integer
ENTR1   WS      1               :       Process_entry_adr: integer
XMPSET  HS      1               :       Xtended_memory_mac_set: halfword
XHEADT  WS      0               :     End
        ORG     HEADTY          
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									 :
:	REGTYPE DATA STRUCTURE						 :
:									 :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:				  : TYPE REGTYPE =
REGTYP	 EQ   . 		  :	 RECORD
	 ORG  0 		  :	 RECORD
RG0	 BS   XREG		  :	     0: REG 
RG1	 BS   XREG		  :	     1: REG
RG2      BS   XREG		  :	     2: REG
RG3	 BS   XREG		  :	     3: REG
RG4      BS   XREG		  :	     4: REG
RG5	 BS   XREG 		  :          5: REG
RG6	 BS   XREG		  :	     6: REG
RG7	 BS   XREG		  :	     7: REG 
RG8	 BS   XREG		  :	     8: REG
RG9	 BS   XREG		  :	     9: REG 
RGRA	 BS   XREG		  :	     RA: REG 
RGHD	 BS   XREG		  :          HD: REG
RGS	 BS   XREG		  :	     S : REG
RGG	 BS   XREG		  :	     G : REG
RGB	 BS   XREG		  :	     B : REG
RGQ	 BS   XREG		  :	     Q : REG
XREGTY	EQ	.
	 ORG  REGTYP		  :	 END 
:				  :
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                       :
:	QUEUE TYPE DATA STRUCTURE                                       :
:                                                                       :
:       NOTE: THE ROUTINE'RDYENT' IN NUCLUS.NAD MUST BE CHANGED         :
:            IF THE QUEUE STRUCTURE IS ALTERED!                         :
:                                                                       :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
QUETY	 EQ   .
	 ORG  0
SUCC	 BS   XADDRE
PRED	 BS   XADDRE
XQUEUE	EQ	.
	 ORG  QUETY
:
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       PROCESS DATA STRUCTURE                                        :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:				  : TYPE PROCESS =
PROCE1	 EQ   . 		  :	 RECORD
	 ORG  0 		  :	 RECORD
LINK0	 BS   XQUEUE		  :	     "QUEUE LINK"
HEAD0	 BS   XHEADT		  :	     HEAD: HEADTYPE
REG0	 BS   XREGTY		  :	     REG: REGTYPE 
PRSPSW   BS   XTS		  :	     PRSPSW:PROCESS_PSW
XPROCE	EQ	.
	 ORG  PROCE1		  :	 END;
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                        :
:       DEFINE MEMORY ACCESS CONTROL (FOR ISIS2)                         :
:                                                                        :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
APREOK  EQ      0001            :MAC BIT: EXECUTION OK
APRWOK  EQ      0002            :MAC BIT: WRITE OK
APRROK  EQ      0004            :MAC BIT: READ OK
:
APROT0  EQ      APRWOK+APRROK   :SLOT 0 READABLE, WRITABLE
APROT1  EQ      APREOK+APRROK   :SLOT 1 READABLE, EXECUTION OK
APROT2  EQ      APREOK+APRWOK+APRROK    :full access
APROT3  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROT4  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROT5  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROT6  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROT7  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROT8  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROT9  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROTA  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROTB  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROTC  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
APROTD  EQ      APREOK+APRWOK+APRROK    :FULL ACCESS
:
:
:
:
:
:       ISIS PORT 0 MESSAGE CODES
:
SRESTA  EQ      0               :RESTART REQUEST
RRESTA  EQ      1               :RESTART RESPONSE
NODETA  EQ      2               :NODE HAS BEEN TAKEN OVER
REPSUP  EQ      3               :REPORT TO SUPERVISOR LOG
HOSTST  EQ      4               :REPORT HOST STATUS
REPACC  EQ      5               :REPORT ACCOUNTING
HOSTTI  EQ      6               :TELL HOST TIME
BLDCIR  EQ      7               :REQUEST TO BUILD NORMAL CIRCUIT
BLDAUX  EQ      8               :REQUEST TO BUILD AUXILIARY CIRCUIT
AUXERR  EQ      9               :UNABLE TO BUILD AUXILIARY CIRCUIT
HOSTAV  EQ      $A 10           :REPORT HOST AVAILABLE
HOSTUN  EQ      $A 11           :HOST UNACCEPTABLE
HOSTCO  EQ      $A 12           :REPORT HOST COST
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                       :
:       CODE PREFIX DATA STRUCTURE                                      :
:                                                                       :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
CODPRE	 EQ   .
	 ORG  0
PROGL	 BS   2*XINTEG			:program length
CODEL	 BS   2*XINTEG			:code length
STACKL	 BS   2*XINTEG			:stack length
VARL	 BS   2*XINTEG			:variable length
LINEON	 BS   XBOOLE			:line option flag
	 BS   XINTEG			:reserved for later expension
	 HS   3*XINTEG			:   "
PREFIX	 EQ   .
	 ORG  CODPRE
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       MONITOR GATE DATA STRUCTURE                                   :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
GATE	 EQ   .
	 ORG  0
OPEN	 BS   2
WAITG	 BS   XQUEUE
XGATE	EQ	.
	 ORG  GATE
:
NLEV    EQ      16                      :NO. OF LEVELS ON KERNEL STACK
MAX     EQ      100                     :MAX NO. OF PARAMETERS

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       PROCSP - SPACE FOR MAX NO OF "PROCESS DATA STRUCTURES"        :
:       GATESP - SPACE ALLOCATED FOR MAX NO OF MONITOR "GATES"        :
:       SYSPACE- TOTAL SYSTEM SPACE FOR THE ABOVE DATA STRUCTURES     :
:       DEVSPACE-SPACE FOR TOTAL NUMBER OF DEVICE PARAMETER BLOCKS    :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
PROCSP	 EQ   PROCS*XPROCE
GATESP	 EQ   GATES*XGATE
SYSPAC	 EQ   PROCSP+GATESP
:
:
:
:	 IORESULT
:
COMPLE	EQ	0	:OPERATION COMPLETE
INTERV	EQ	1	:OPERATION FAILED- OPERATOR INTERVENTION REQUIRED
TRANS	EQ	2	:OPERATION FAILED DUE TO TRANSMISSION ERROR
FAIL	EQ	3	:OPERATION FAILURE- CANNOT REPEAT OPERATION
ENDF	EQ	4	:END OF FILE DETECTED ON TAPE
ENDM	EQ	5	:END OF VOLUME DETECTED ON TAPE
STARTM	EQ	6	:START OF VOLUME DETECTED ON TAPE (LOAD-POINT)
PRGERR	EQ	7	:SOURCE PROGRAM ERROR
BKSTAT	EQ	8	:BREAK KEY DETECTED ON TERMINAL INPUT
OBSTAT	EQ	9	:ORANGE BALL DETECTED BY TERMINAL
BUSY	EQ	10	:Device in use
TIMEOU	EQ	11	:Timeout (request cancelled)
:
TIMAUX	EQ	6	:Aux circuit request timeout
:
XIOOPE	EQ	XINTEG
XIORES	 EQ   XINTEG
:
:        PASCAL I/O PARAMETER BLOCK DEFINITIONS
:
IOPARA	 EQ   .
	 ORG  0
OPER	 BS   XIOOPE		:IOOPERATION CODE 
STATUS	 BS   XIORES		:I/O STATUS CODE (SEE IORESULT ABOVE)
STATS2	BS	XFWINT		:Extended status code (controller status)
ARG1	 BS   XFWINT		:START SECT(D)/TAPEOP CODE/INP LNGTH(TRM)
ARG2	 BS   XFWINT		:XFER LNGTH IN BLKS(D/TP)/# CHARS INPUT (TRM)
	 ORG  IOPARA
:
LF	 EQ   10		:ASCII LINE FEED CODE
CR	 EQ   13		:ASCII CARRIAGE RETURN CODE
DELETE	EQ	$0 7F		:ASCII delete char
BLANK    EQ   $0 20             :ASCII BLANK SPACE CODE
BACKSP   EQ   $0 08             :ASCII BACK SPACE CHAR

CHDEL	 EQ	$0 5E		:CANNED CONTROL CHARC FOR CHARC DEL
WDDEL	 EQ   $0 5C		:CANNED CNTRL CHARC FOR WORD DELETE
BBELL	EQ	$0 07		:CANNED CNTRL CHAR FOR BREAKKEY 
:
: Data structure definition for disk/tape request parameter block
:	Note: This block is used internally to transmit information
:	to the low level of the disk/tape driver from both the high
:	level of the disk/tape driver and the logical volume driver.
:

DPBLK	EQ	.
	ORG	0
DPADDR	WS	1		:Data block address
DPTYPE	HS	1		:Device type #
DPUNIT	HS	1		:Device unit #
DPSECT	WS	1		:Sector # or tape sub-operation
DPLEN	WS	1		:Length of transfer (bytes)
DPACT	WS	1		:Activation routine address
DPOPER	HS	1		:Operation to be performed
DPSTAT	HS	1		:SVC status return
DPCNST	HS	1		:Controller status
DPTRYS	HS	1		:Number of tries for request
	WS	0		:Word align end of block
DPSIZ	EQ	.		:Size of block
	ORG	DPBLK
:	adjustment to get rings in higher part of seg 0
:
	SEG	0
SEG0LO	EQ	.
	ORG	SEG0LO	: Leave at high part of seg 0 for FRING.LIB
        SEG     1
         EM
   	SUBTTL	STATUS.LIB . . . .DRIVER TO PROCESS ARBITRARY COMMANDS UNDER "?STAT"
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

  IF	1-\DB.STA			:DEFAULT DEBUG/STATUS TO ON
DB.STA	EQ	1
  EI

  IF	DB.STA				:ASSEMBLE ONLY WITH DEBUG STATUS ON

	SEG	A.CODE
	MO	.,STATUS
	RA	$00
	GL	DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM,DTGO,DTCHK
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL
	GL	DDLA2,DDLA4,DDLANP,DTINIT

:	STATUS - User Command Handler
:
:	Version history:
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimeter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:		The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).

:		Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:	C/R	L/F	H/T	","	and BLANK.

:		Entry Points:
:	DSTART	Place to exit on completion of command.
:	DNEXTK  Get next token with out prompt.
:	DS.ILL	Place to exit on illegal command -- types "Illegal command"
:	DS.ERR	Place to exit on command error -- types "type '\' "
:	DS.EXI	Place to exit machine.
:	DS.QUI	Place to exit back to DDT.
:	DS.GCH	Get a character...Link on R1, char (with high-order bit forced)
:			in R0...normal return if detected ^W, skip-4 if detect
:			~A, aborts back to DSTART if detects ESC.
:	DS.DEL	Check for delimiter...Link on R2, Character in R0.  Skip-4
:			return unless this is a delimiter, then normal return.
:	DS.CUC	Convert to upper case...Link on R1, Character in R0.
:	DS.TOK	Get a string token...Link on R4, TOKEN returned in R3...
:			inputs up to 4 characters, returns them (in uppercase)
:			left justified, 0 fill
:	DS.NUM	Get a number...Link on R5, expects Radix in R4...
:			number returned in R0.  May ABORT if any character is
:			input other than valid digit or delimiter.
:	DS.DLM  Location of last delimeter entered (1 byte)

:		There are two built-in commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.

:		additional commands may be defined via the DS.CMD macro:
:	 DS.CMD(TEXT,ADDR)
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	DS.CMD generates a 12-byte discriptor for this command, at the point
:	assembly where it is invoked.  This discriptor is on a WORD boundary.



OUT	EQ	0B			:OUTPUT SVC
IN	EQ	0A			:INPUT SVC

DS.ELL	EQ	0			:NULL POINTER FOR END OF LINKED LIST

	SEG	A.DATA
DS.DLM	BS	1			:LAST DELIMETER ENCOUNTERED
R4SAV	WS	1			:SAVE AREA FOR R4 IN DS.TOK
BADSTR	SC	/'xxxx'"8D"8A/		:PLACE TO PUT BAD COMMAND
	SEG	A.CODE

:	DEFINE ELEMENTS FOR COMMAND BLOCK
C.NEXT	EQ	0			:POINTER TO NEXT ENTRY
C.ADDR	EQ	C.NEXT+4		:POINTER TO COMMAND HANDLER
C.STR	EQ	C.ADDR+4		:RELATIVE POSITION OF STRING

:	DEFINE MACRO TO GENERATE THIS COMMAND BLOCK
DS.CMD	MACRO(STR,ADDR)[
   IF	DS.ELL
Q	WS	0
	ORG	DS.ELL
	WC	Q
	ORG	Q
   EI
DS.ELL	WC	0,ADDR
	AC	/STR/
	BND	4
]


:	TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST	WS	0			:FORCE TO WORD BOUNDARY
	DS.CMD(Q,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(QUIT,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(EXIT,DS.EXI)		:EXIT 
	DS.CMD(EXI,DS.EXI)		:EXIT 




:	DIAGNOSTIC MESSAGES
TERR	SC	/Illegal command /
TTERR	SC	/type '\'"8D"8A/
PROMPT	SC	/"8D"8A:>/		:"CR|LF:>"
BKSPAC	SC	/"88 "88/		:BACK SPACE
	SUBTTL	COMMAND SCANNER, VERIFIER, AND BITCHER

:	COMMAND INPUT HANDLER
DOIT	L	R0,C.ADDR,R1		:GO SERVICE THIS COMMAND
	JALR	R0,R0

:	NEXT COMMAND
DSTART	SVC	OUT,PROMPT		:ISSUE PROMPT
DNEXTK	JAL	R4,DS.TOK		:GET COMMAND TOKEN
	LA	R1,CMDLST		:SEARCH FOR STRING MATCH
DSTAR1	CL	R3,C.STR,R1
	JE	DOIT			:PROCEED IF FIND A MATCH
	L	R1,C.NEXT,R1		:ELSE CONTINUE SCAN
	JGBS	DSTAR1
DS.ILL	SVC	OUT,TERR		:"ILLEGAL COMMAND"
DS.ERR	SVC	OUT,TTERR		:TELL USER TO TYPE FLUSH CHAR
BITCH	JAL	R1,DS.GCH		:FLUSH INPUT
	JBS	BITCH;	 NOPR	0			:^W...IGNOR
	JBS	BITCH;	 NOPR	0			:^A...IGNOR
	CLHI	R0,0DC			:READ UNTIL "\" IS FOUND
	JNBS	BITCH
	J	DSTART			:THEN EXIT


:	BUILT-IN COMMANDS

:		Command EXIt
:		===========-
DS.EXI	SVC	KIO,0			:DISCONNECT


:		Command Quit (exit back to DDT)
:		=========---
DS.QUI	SVC	KIO,1			:RETURN TO DDT
	J	DSTART			:IF OPERATOR TYPED "P", GET NEXT COMMAND
	SUBTTL	U T I L I T I E S

:	GET A COMMAND TOKEN...UP TO 4 CHARS LONG
:		SKIPS OVER EXTRA CHARACTERS TO NEXT DELIMITER
:	LINK ON R4
:	TOKEN RETURNED IN R3, LEFT JUSTIFIED
DS.TOK	HS	0
        ST      R4,R4SAV,,              :SAVE R4
TOKEN0	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	TOKEN0;	 NOPR	0			:^W...IGNORE
	JBS	TOKEN0;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:SKIP OVER DELIMITERS
	J	TOKEN0
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	CHI	R0,00DC			:= "\" ?
	JE	DSTART			:YES, PRINT PROMPT, GET NEXT COMMAND
	LBR	R3,R0			:SET UP STRING ACCUMULATOR (000000CC)
	LIS	R4,1			:1 CHAR. FOUND SO FAR
TOKEN	JAL	R1,DS.GCH		:GET ANOTHER CHAR
	J	TOKEN0			:^W...START OVER
	J	TOKEN3			:^A...TOSS LAST CHAR
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	J	TOKEN1			:GOT ONE...SKIP TO LEFT JUSTIFY IT
	CHI	R0,00DC			:= "\" ?
	JE	DS.ILL			:YES, TREAT AS ILLEGAL
	AIS	R4,1			:ONE MORE CHARACTER
	CHI	R4,4			:IF => 4 CHARS, DO NOT USE THIS ONE
	JG	TOKEN			:YES...SCAN FOR DELIMITER
	SLLS	R3,8			:NO...ACCUMULATE CHARS
	STBR	R0,R3
	J	TOKEN			:AND GET ANOTHER CHAR
TOKEN1	HS	0
        L       R4,R4SAV,,              :RESTORE R4
TOKEN2	TI	R3,0FF000000		:HAVE WE 4 CHARS ALREADY?
	JNR	R4			:YES...RETURN TOKEN IN R3
	SLLS	R3,8			:NO...JUSTIFY IT
	JBS	TOKEN2			:AND REPEAT

TOKEN3	HS	0			:HANDLE BACKSPACE IN TOKEN
	SIS	R4,1			:ONE LESS CHAR
	CHI	R4,4			:IF AFTER BACKSPACE TOKEN IS => 4
	JGE	TOKEN			: JUST DECRIMENT COUNTER
	SRLS	R3,8			:ELSE... DROP 1 CHARACTER
	J	TOKEN			:AND GET NEXT CHAR.

:	UTILITY ROUTINE TO READ A NUMBER
:	USES R0-R3
:	EXPECTS RADIX IN R4
:	LINK ON R5
:	ABORTS IF FIRST NON-DELIMITER IS NOT DIGIT
:	ELSE RETURNS NUMBER IN R0
DS.NUM	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	DS.NUM;	 NOPR	0			:^W...IGNORE
	JBS	DS.NUM;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER CHAR
	J	DS.NUM
	JAL	R2,DS.DIG		:TEST IF CHAR IS DIGIT
	J	DS.ILL			:NOT A DIGIT - GIVE ERROR MESSAGE
	CLR	R0,R4
	JGE	DS.ILL			:DIGIT IS BIGGER THAN RADIX...ABORT
	LR	R3,R0			:PUT FIRST DIGIT INTO ACCUMULATOR
NUMBER	JAL	R1,DS.GCH		:READ NEXT CHAR
	J	DS.NUM			:^W...START OVER
	J	DIVIDE			:^A...TOSS LAST DIGIT
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	LR	R0,R3;	 JR	R5	  :YES
	JAL	R2,DS.DIG		:SKIP IF DIGIT
	J	DS.ILL			:NO...ABORT
	CLR	R0,R4
	JGE	DS.ILL			:RADIX ERROR...BITCH
	MR	R2,R4			:BUILD NUMBER
	AR	R3,R0			:ADD NEW DIGIT
	J	NUMBER			:GET NEXT DIGIT
DIVIDE	LIS	R2,0			:GOT A ^A...MAKE DOUBLE-PRECISION ARG.
	DR	R2,R4			:QUOTENT INTO R3, WHERE WE WANT IT
	J	NUMBER			:NOW GO BACK FOR MORE DIGITS

:	DIGIT TEST
:	CHECK CHARACTER READ...SKIP RETURN IF DIGIT
:	THEN R0=BINARY VALUE OF HEX DIGIT
:	USES R1, LINK ON R2
DS.DIG	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	LR	R1,R0			:COPY CHAR
	SHI	R1,0B0			:IS IT "0"?
	JLR	R2			:RETURN IF LESS THAN "0"
	SIS	R1,0B9-0B0		:IS IF "9"
	JLEFS	DIGIT			:LESS THAN "9" THEN A GOOD DIGIT
	SIS	R1,0C1-0B9		:IS IT "A"?
	JLR	R2			:RETURN IF LESS THAN "A"
	SIS	R1,0C6-0C1		:IS IF "F"?
	JGR	R2			:RETURN IF GREATER THAN "F"
	SIS	R0,7			:0A - "A" (PARTIAL CONVERSION)
DIGIT	SHI	R0,0B0			:"0"
	J	4,R2			:SKIP RETURN

:	CHECK FOR DELIMITER
:	LINK	R2
:	USES	R0,R1
:	SKIP-4 RETURN UNLESS (R0) IS A DELIMITER CHARACTER
DS.DEL	LHI	R1,DLEN-1		:NUMBER OF DELIMITER CHARS
        STB     R0,DS.DLM,,             :SAVE DELIMITER
DELIM	CLB	R0,DLIST,R1		:COMPARE TO A DELIMITER
	JER	R2			:RETURN IF DELIMITER
	SIS	R1,1			:CHECK NEXT DELIMITER
	JGEBS	DELIM			:LOOP IF ANY MORE DELIMITERS
	J	4,R2			:SKIP RETURN
:	LIST OF DELIMITER CHARS
DLIST	AC	' ,'			:BLANK,","
	BC	8D,8A,89		:CR,LF,HT
DLEN	EQ	.-DLIST			:NUMBER OF DELIMITER CHARS

:	INPUT A CHARACTER
:	LINK	R1
:	NORMAL RETURN:  ^W INPUT...FLUSH ENTRY
:	SKIP-4 RETURN:  ^A or ^H INPUT...FLUSH LAST CHAR
:	SKIP-8 RETURN: CHAR IN R0 (HIGH-BIT ON)
:	ABORTS TO COMMAND SCANNER ON "ESC"
DS.GCH	SVC	IN,0F			:GET THE CHAR
	J	DS.GCH
	OHI	R0,80			:SET HIGH-ORDER BIT
	CLHI	R0,9B			:CHECK FOR ESCAPE
	 JE	DSTART			:ABORT, PROCEED WITH PROMPT IF SO
	CLHI	R0,97			:CHECK FOR ^W
	 JER	R1			:NORMAL RETURN
	CLHI	R0,81			:CHECK FOR ^A
	 JE	4,R1			:SKIP-4 RETURN
	CLHI	R0,88			:CHECK FOR ^H
	 JN	8,R1			:NO, SKIP-8 RETURN, CHAR IN R0

	SVC	OUT,BKSPAC		:BACK SPACE
	J	4,R1			:SKIP-4 RETURN FOR ^H

:	CONVERT CHAR IN (R0) TO UPPER CASE
:	LINK ON R1
DS.CUC	CLHI	R0,0E1			:COMPARE WITH "a"
	JLR	R1			:EXIT IF IT CAN'T BE LOWERCASE
	CLHI	R0,0FA			:COMPARE WITH "z"
	JGR	R1			:NOT LOWER CASE...JUST RETURN
	SHI	R0,20			:LOWER CASE...CONVERT TO UPPER
	JR	R1			:AND RETURN

	EM

  EI	:(DB.STA)
        subttl                                                  nucdb.nad
        REMARK %NUCDB  V 0.3, 04-22-83, RNP
:
: V 0.3, 02-11-83, RNP
:       Addition for Extended Memory
: V 0.2, 03-18-82, SCY
:	Fixed bugs in getting the procedure name.
: V 0.1, 01-26-82, SCY
:	Added some routines to handle subcommands under ?STAT.
:	Added routine to display process's status one at a time and
:	  also back track and print original caller of this process.
:
	RA	0

	MO	.,NUCDB
	LO	COMMON

	GL	DSTR1,PASNIN,PASPRC,LINFLG
       IF       XMEMRY
        GL      XMCUR0
       EI       :XMEMRY

	SEG	1

:::::::::::::::::::::::::::::::::::::::::::::::::::::
:	ALL - Print status of all processes
::::::::::::::::::::::::::::::::::::::::::::::::::::
	DS.CMD(ALL,DSTR1)

:::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	PR - Print the status for the selected precess only
:::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
	DS.CMD(PR,DSTR2)

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	 '\'
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	DS.CMD(\,DDTNOP)
DDTNOP	J	DSTART,,	:Print prompt, look for next token

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	HELP and '?'
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	DS.CMD(HELP,DDTHLP)
	DS.CMD(?,DDTHLP)

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	Load Pascal code into second meg
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	DS.CMD(LP,DDLDCD)		:load from disc
:
	DS.CMD(LD,DDLDAC)		:LOAD FROM DISC,GIVE CODE SIZE
:
	DS.CMD(LC,DDLDCC)		:load from 1st meg
:
:	LOAD FROM DISC, FIRST GET CODE SIZE
:
DDLDAC	HS	0
	LHI	R4,10
	JAL	R5,DS.NUM
	ST	R0,DDLDSZ,,
	J	DDLD.C

:
:	load from 1st meg setup
:
DDLDCC	HS	0
        SVC     SYS,$A32
        j       .+4
	LHI	R4,10
	JAL	R5,DS.NUM
	ST	R0,DDLDSZ,,
	J	DDLD.2

:
:	routine to setup PBLOCK and read disc
:
:	link - R4 input - R2: byte count
:
DDLD.S	HS	0
	ST	R4,DDLDRT,,
	ST	R2,DDLDBK+DPLEN,,	:# OF PAGES TO READ  
	LB	R1,DDLDNM,,	:SET LUN
	STB	R1,DDLDBK+DPUNIT,,
	LA	R1,20000,,		:SET VMA
	ST	R1,ddldbk+DPADDR,,
	L	R1,DDLDPG,,	:SET SECTOR ADR
	ST	R1,ddldbk+DPSECT,,
	LHI	R1,0		:SETUP FOR READ OPER
	STH	R1,ddldbk+DPOPER,,
	LA	R1,DDLD.N
	ST	R1,ddldbk+DPACT,,
        LA      R1,DDLDBK,,
	JAL	R4,DTGO
	CLHI	R0,0
	JN	DDLD.E
DDLD.T	HS	0
	JAL	R2,DTCHK
	JBS	DDLD.T
DDLD.N	HS	0
	LH	R0,DDLDBK+DPSTAT,,
	JNFS	DDLD.E
	L	R4,DDLDRT,,
	JR	R4
:
DDLD.E	HS	0
	SVC	0B,DSKER
	J	DS.ERR
DSKER	SC	/DISK ERROR "8A"8D/


:
:	MAIN ROUTINE FOR 2MG LOAD
:
DDLDCD	HS	0
	LHI	R0,0		:INIT BYTE SIZE
	ST	R0,DDLDSZ,,
DDLD.C	HS	0
	LHI	R4,$A16		:SET RADIX TO HEX
	JAL	R5,DS.NUM	:GET LUN
	NHI	R0,1		:ONLY ALLOW 0 OR 1
	CLHI	R0,1
	JLE	DDLD.0
	SVC	0B,LERR
	J	DS.ERR
LERR	SC	/LUN 0 OR 1 "8A"8D/
DDLD.0	HS	0
	STB	R0,DDLDNM,,	:SAVE LUN
	JAL	R5,DS.NUM	:GET SECTOR ADR
	ST	R0,DDLDPG,,	:SAVE SECTOR ADR
        SVC     SYS,$A32
        j       .+4
	JAL	R2,DTINIT	:INIT DSIK DRIVER
	L	R2,DDLDSZ,,	:SKIP AHEAD IF BYTE SIZE ALREADY ENTERED
	JNFS	DDLD.1
	LHI	R2,100		:READ IN FIRST PAGE OF CODE
	JAL	R4,DDLD.S	:SETUP PARAM BLOCK
	L	R2,20000,,		:GET CODE SIZE
	ST	R2,DDLDSZ,,	:SAVE FOR LATER
DDLD.1	HS	0
	JAL	R4,DDLD.S	:SETUP param block TO READ IN THIS CODE
DDLD.2	HS	0
	LHI	R10,NMACSS	:SWITCH TO FIRST NEW MAC SET
	SVC	5,0,R10
DDLD.3	HS	0
	L	R1,DDLDSZ,,	:GET CODE SIZE
	CI	R1,60000	:ONLY ALLOW 6 SEG WORTH
	JLE	DDLD.4
	LI	R1,60000
DDLD.4	HS	0
	LA	R3,SEG2,,
	LA	R4,SEG8,,
DDLD.5	HS	0
	L	R2,0,R3
	ST	R2,0,R4
	AIS	R3,4
	AIS	R4,4
	SIS	R1,4
	JGBS	DDLD.5
	L	R1,DDLDSZ,,	:FINISHED?
	SI	R1,60000
	JLE	DDLD.8
	LHI	R10,NMACSS+1	:SWITCH TO SECOND NEW MAC SET
	SVC	5,0,R10
DDLD.6	HS	0
	LA	R3,20000,,
	LA	R4,80000,,
DDLD.7	HS	0
	L	R2,0,R3
	ST	R2,0,R4
	AIS	R3,4
	AIS	R4,4
	SIS	R1,4
	JGBS	DDLD.7
DDLD.8	HS	0
	LHI	R10,NMACSS+2
	SVC	5,0,R10
	J	DDTNOP
DDLA2	WC	0
	WC	DDLD.3
DDLA4	WC	0
	WC	DDLD.6
DDLANP	WC	0
	WC	DDTNOP
:
:
:
DDTHLP	HS	0
	LA	R1,HLPLST
DDTHL1	HS	0
	LB	R0,0,R1	:Test for done
	JE	DDTHL2	:Zero = done
	SVC	K.OUT,0,R1	:PRINT
	AR	R1,R0		:Get next one
	AIS	R1,1		:+ 1 byte for the length
	JBS	DDTHL1		:Till done

DDTHL2	J	DDTNOP	:Wait for next command

HLPLST	EQ	.
	SC	/        Extended DDT help list:"8D"8A/
	SC	/ALL	Print the status for all the processes"8D"8A/
	SC	/PR N	Print the status for process n only"8D"8A/
	SC	/EXIT	Log off"8D"8A/
	SC	/QUIT	Back to DDT"8D"8A/
	SC	/HELP or ?"8D"8A/
	SC	/LP LUN,SECTOR  Load from LUN at SECTOR, pascal code to 2nd Mg "8D"8A/
	SC	/LC SIZE Move code from seg 2 to beg of 2nd Meg"8A"8D/
	SC	/LD SIZE,LUN,SECTOR Load code of SIZE from LUN to 2nd Meg"8A"8D/

	BC	0

	SEG	0
ddldbk	BS	DPSIZ		: paramter block for disk load
ddldnm	BS	1		:lun of slot save area
ddldrt	WS	1		:RET ADR FOR DDLD ROUTINE
ddldsz	WS	1		:size of pascal code in bytes
ddldpg	WS	1		:sector adr of code in LUN
RETSAV	WS	1
MAXLEN	EQ	$0 14		:Max length of procedure name
DPMS6	BS	15		:Storage for procedure name
DPMS61	BS	14
	SEG	1

NAMMSG  ST      R6,RETSAV,,
	CLHI	R5,1		:Under init routine?
	JE	NAM0		:Yes, skip
	CI	R0,USRBOT	:Running under user code
	JL	UNKNOW
	LR	R1,R0		:R0 CONTAIN THE RETURN ADDR STORED IN STACK
	SIS	R1,4		:MAKE R1 CONTAIN THE ADDR OF JAL INSTRUCTION
	LB	R5,0,R1		:Get the 1st byte of instr.
	CLHI	R5,41		:Is JAL instr ?
	JN	UNKNOW		:No, print unknow proc name
	LB	R5,1,R1		:Get the 2nd byte of instr
	CLHI	R5,0F0
	JE	NAM1
	CLHI	R5,0FF
	JE	NAMGO
UNKNOW	SVC	K.OUT,DSTMSG	:Print ???
	LIS	R0,2
	SBT	R0,LINFLG,,	:Set flag
	JR	R6		:Return
NAMGO	LR	R5,R1
	SIS	R1,4
	L	R0,0,R1
	AR	R0,R5
	J	NAM0
NAM1	LH	R5,2,R1
	AR	R0,R5		:GET DISPLACEMENT OF JAL INSTRUCTION
NAM0	LR	R5,R0
	LIS	R6,0	:R6 IS A COUNTER TO COUNT THE LENGTH OF PROC NAME
	LIS	R0,0		:R0 IS USED TO TEST THE SIGN BIT
NAM2	SIS	R5,2	:BUMP THE PTR SO POINT TO THE LAST CHAR OF PROC NAME
	TBT	R0,0,R5		:TEST THE SIGN BIT
	JNFS	NAM3	:IF SIGN BIT IS 1 THEN MEET 1ST CHAR OF PROC NAME
	AIS	R6,2	:INCREMENT COUNTER BY 2 BYTES
	J	NAM2	:CONTINUE UNTIL FIND THE SIGN BIT
NAM3	AIS	R6,2
	CLHI	R6,MAXLEN
	JLEFS	NAM4
	LHI	R6,MAXLEN
NAM4	LIS	R1,0
        STB     R6,DPMS6,R1,    :Store the length
NAM5	AIS	R1,1
	LB	R0,0,R5
        STB     R0,DPMS6,R1,
	AIS	R5,1
	SIS	R6,1
	JG	NAM5
        SVC     K.OUT,DPMS6,,
NAM6    L       R6,RETSAV,,
	JR	R6
:

DSTR1	LIS	R5,1
	RBT	R5,LINFLG,,	:Reset bit 1 to disable tracing for a process
	LIS	R5,2
	RBT	R5,LINFLG,,	:Clear the bit initially.
	LH	R2,PASNIN,,	:SIZE OF PROCESS DESCRIPTOR TABLE
	SRLS	R2,1		:NUMBER OF ENTRIES
	LIS	R3,0		:INIT COUNTER
DLOOP	CR	R3,R2		:DONE?

	IF	NUCDB
	JGE	DRRING
	ELSE
	JGE	DEXIT
	EI

	LR	R0,R3		:COPY PROCESS NUMBER
	AIS	R0,1
DL0	SVC	K.OUT,DPMS1	:Print 'process '
	LHI	R1,32A		:3 DIGITS, BLANK FILL, DECIMAL
	SVC	KIO,0A		:PRINT PROCESS NUMBER
	SVC	K.OUT,DPMS2	:Print 'state = '
       IF       XMEMRY
        LHL     R10,PASPRC,R3,R3 :R10 -> Process Header
        LH      R10,XMPSET+4,R10 :R10 = XM window number
        JAL     R4,XMCUR0        :Make window current
       EI       :XMEMRY
        LHL     R4,PASPRC,R3,R3 :PROCESS DESCRIPTOR ADDR
	LH	R5,STATE1+4,R4	:STATE
	SLLS	R5,2		:INDEX TO STATE MSG TABLE
	SVC	K.OUT,DSTMSG,R5	:PRINT STATE
	SVC	K.OUT,DPMS3	:Print 'priority = '
	LH	R0,PRIOR1+4,R4	:PRIORITY
	LHI	R1,14A		:1 DIGIT, 0 FILL, DECIMAL
	SVC	KIO,0A		:PRINT IT
	LHI	R5,0
	TBT	R5,LINFLG,,	:If line option flag is off, go to print the
	JE	DL1		: core address & proc name
	SVC	K.OUT,DPMS4	:Print 'line = '
	L	R0,LINE1+4,R4	:LINE NUMBER(AT LAST NUCLEUS ENTRY)
	LHI	R1,54A		:5 DIGITS, 0 FILL, DECIMAL
	SVC	KIO,0A		:PRINT IT
	J	DL4
DL1	SVC	K.OUT,DPMS5	:Print 'addr = '
	L	R0,PRSPSW-HEAD0+4+4,R4	:Load core address
	LHI	R1,630		:6 digits, blank fill, hex
	SVC	KIO,0A		:Print it
	LHL	R5,ENTRFG+4,R4	:A flag to tell if current running process
	CLHI	R5,1		: is under init routine
	JEFS	DL2
	SVC	K.OUT,DPMS8	:Print 'in procedure '
	L	R1,REG0-HEAD0+RGB+4,R4	:The addr where to get proc name
	L	R0,0C,R1
	JFS	DL3
DL2	SVC	K.OUT,DPMS7	:Print 'in process '
	L	R0,ENTR1+4,R4	:The adr to get process name
DL3	JAL	R6,NAMMSG	:Print the name
DL4	SVC	K.OUT,DBCRLF
	LIS	R5,1
	TBT	R5,LINFLG,,
	JN	DTRAC0
	AIS	R3,1		:INCREMENT COUNTER
	J	DLOOP		:LOOP

DEXIT	J	DSTART
:

DSTR2	LHI	R4,$A10
	JAL	R5,DS.NUM	:Get process #
	LIS	R5,1
	SBT	R5,LINFLG,,	:Set bit 1 to enable traceback of proc name
	LIS	R5,2
	RBT	R5,LINFLG,,
	LR	R3,R0		:Save the process # to R3
	SIS	R3,1
	JL	ILLNO		:Illegal if process # < 0
	LH	R2,PASNIN,,	:Size of process descriptor table
	SRLS	R2,1		:Number of entries
	CR	R0,R2
	JLE	DL0
ILLNO	SVC	0B,ERRNO
	J	DS.ERR

ERRNO	SC	/Illegal process number "8D"8A/

DTRAC0
	LIS	R5,2
	RBT	R5,LINFLG,,
	JN	DSTART
	LHL	R5,ENTRFG+4,R4	:A flag to tell if current running process is
	CLHI	R5,1		:  under init routine
	JE	DSTART
	SVC	K.OUT,DBCRLF
	SVC	K.OUT,DPMSA	:Print "Called from: "
	LIS	R5,0
	TBT	R5,LINFLG,,
	JE	DTRAP
	SVC	K.OUT,DPMSL
	J	DTRAN
DTRAP	SVC	K.OUT,DPMSD	:Print 'at addr:'
DTRAN	L	R3,REG0-HEAD0+RGB+4,R4	:Get Reg B from header
DTRA1	L	R2,8,R3		:Get old Reg B from stack pointed by Reg B
	LR	R0,R3
	SIS	R0,4
	CR	R0,R2
	JE	DTRA2		:Skip if meet the end of tracing
	L	R0,0C,R2	:Get return addr from stack
	JAL	R6,NAMMSG	:Get the procedure name
	JAL	R6,DTRA3	:Fill the blank in the name string
	LR	R3,R2
	J	DTRA1		:Trace back until the end

DTRA2
	LIS	R5,1
	L	R0,ENTR1+4,R4
	JAL	R6,NAMMSG	:Print the process name
	JAL	R6,DTRA3	:Fill blank in name string & print core addr
	J	DSTART

DTRA3
	LIS	R5,2
	RBT	R5,LINFLG,,
	JN	DSTART
	LIS	R1,0
        LB      R0,DPMS6,R1,
	LHI	R1,$0 17
	SR	R1,R0
        STB     R1,DPMS61,,     :Store the length of filling blank
	LHI	R0,0A0		:Load the blank
DTRA4   STB     R0,DPMS61,R1,   :Store into the name string
	SIS	R1,1
	JG	DTRA4
        SVC     K.OUT,DPMS61,,  :Print the blank line
	LIS	R1,0
	TBT	R1,LINFLG,,
	JE	DTRA5
	LHL	R0,2,R2
	LHI	R1,54A
	J	DTRA7
DTRA5	L	R1,0C,R3	:Get return addr from stack
	SIS	R1,4		:Point to previous entry
	LB	R0,0,R1
	CLHI	R0,41		:Compare with JAL instr
	JE	DTRA6
	SIS	R1,2
DTRA6	LR	R0,R1
	LHI	R1,630		:6 digits,blank fill,hex
DTRA7	SVC	KIO,0A
	SVC	K.OUT,DBCRLF
	JR	R6
:
: QLDAV - Print load average
:	Called by DDT '?LDAV' command
:

	GL	AVG		:The load average

QLDAV	SVC	K.OUT,LDAVMS	:Load average message
	L	R3,AVG,,		:Get load average
	AHI	R3,147		:Add .005 (approx.) for rounding
	EXHR	R0,R3		:Swap integer part to bottom
	NI	R0,0FFFF	:Get rid of fractional part
	LHI	R1,22A		:2 digits, blank fill, decimal
	SVC	KIO,0A		:Print it
	LHI	R0,2E		:ASCII period
	SVC	KIO,0E		:Print it
	NI	R3,0FFFF	:Get rid of integer part of avg
	LHI	R2,$A 100
	MHR	R3,R2		:Multiply by 100
	EXHR	R0,R3		:Swap integer, fraction parts
	NHI	R0,0FF		:Get rid of fraction part
	LHI	R1,24A		:2 digits, zero fill, decimal
	SVC	KIO,0A		:Print it
	SVC	K.OUT,DBCRLF	:New line
	SVC	KIO,1		:Exit

LDAVMS	SC	'Load average: '
:
: Optional trace ring code
:
	IF	NUCDB
	GL	NDBWT,NDBSIZ,NDBBUF

NDBSIZ	EQ	100		:SIZE OF RING BUFFER

	SEG	0
NDBWT	HS	1		:WRITE POINTER
	BS	NDBSIZ		:ALLOCATE SPACE
NDBBUF	EQ	.		:REFERENCE FROM END

	SEG	1


DRRING	SVC	K.OUT,DBMSG
	LH	R6,NDBWT	:START AT CURRENT WRITE POINTER
NDBLP	CH	R6,NDBWT	:BUFFER EMPTY?
	JN	NDBPR		:NO, GO PRINT MESSAGES
	SVC	DISMISS,0
	SVC	K.IN,0		:CHAR INPUT?
	J	NDBLP		:NO, LOOP
	SVC	KIO,1		:YES, QUIT TO DDT

NDBPR	JAL	R4,NDBRH	:GET MSG NUMBER
	SLHLS	R2,2		:CONVERT TO FULLWORD INDEX
	J	NDBVEC,R2	:JUMP TO APPROPRIATE ROUTINE

NDBRH	EQ	.		:ROUTINE TO GET HALFWORD FROM RING
	LH	R2,NDBBUF,R6	:READ HALFWORD
	AIS	R6,2		:INCREMENT POINTER
	JLR	R4		:RETURN IF NO WRAP
	LHI	R6,-NDBSIZ	:WRAP
	JR	R4		:RETURN

	HS	0

NDBVEC	EQ	.	:VECTOR OF JUMPS TO MESSAGE PRINTING ROUTINES
	J	PMSG0		:ONE-SECOND TICK
	J	PMSG1		:PUT ON PROCESS QUEUE
	J	PMSG2		:GET FROM PROCESS QUEUE
	J	PMSG3		:NEEDLE
	J	PMSG4		:ORANGE BALL
	J	PMSG5		:BREAK
	J	PMSG6		:ENTER DEM
	J	PMSG7		:LEAVE DEM
	J	PMSG8		:PSEUDO NEEDLE
	J	PMSG9		:SUCCESSFUL LOGON
	J	PMSG10		:LOGON FAILURE
	J	PMSG11		:ZAPPER


PRTNUM	MACRO(FORMAT)[
	JAL	R4,NDBRH
	LR	R0,R2
	LHI	R1,FORMAT
	SVC	KIO,0A]

PMSG0	SVC	K.OUT,DMS00
	J	NDBLP

PMSG1	SVC	K.OUT,DMS10
	PRTNUM(450)
	SVC	K.OUT,DMS11
	PRTNUM(450)
	SVC	K.OUT,DBCRLF
	J	NDBLP

PMSG2	SVC	K.OUT,DMS20
	PRTNUM(450)
	SVC	K.OUT,DMS21
	PRTNUM(450)
	SVC	K.OUT,DBCRLF
	J	NDBLP

PMSG3	SVC	K.OUT,DMS30
PMSG3C	SVC	K.OUT,DMS31
	JAL	R4,NDBRH
	LR	R0,R2
	SRHLS	R0,2		:CONVERT TO PORT NO.
	LHI	R1,250
	SVC	KIO,0A
	SVC	K.OUT,DBCRLF
	J	NDBLP

PMSG4	SVC	K.OUT,DMS40
	J	PMSG3C

PMSG5	SVC	K.OUT,DMS50
	J	PMSG3C

PMSG6	SVC	K.OUT,DMS60
	J	PMSG3C

PMSG7	SVC	K.OUT,DMS70
	J	PMSG3C

PMSG8	SVC	K.OUT,DMS80
	J	PMSG3C

PMSG9	SVC	K.OUT,DMS90
	J	PMSG3C

PMSG10	SVC	K.OUT,DMS100
	J	PMSG3C

PMSG11	SVC	K.OUT,DMS110
	J	PMSG3C

DBMSG	SC	'   Debug message ring:"8D"8A'
DMS00	SC	'One-second"8D"8A'
DMS10	SC	'Put '
DMS11	SC	' on queue @'
DMS20	SC	'Got '
DMS21	SC	' from queue @'
DMS30	SC	'Needle'
DMS31	SC	' received from port '
DMS40	SC	'Orange ball'
DMS50	SC	'Break'
DMS60	SC	'Enter DEM'
DMS70	SC	'Leave DEM'
DMS80	SC	'Pseudo-needle'
DMS90	SC	'Successful logon'
DMS100	SC	'Logon failure'
DMS110	SC	'Zapper'
	EI
DBCRLF	SC	'"8D"8A'
DPMS1	SC	'Process '
DPMS2	SC	':  state='
DPMS3	SC	' priority='
DPMS4	SC	' line='
DPMS5	SC	' addr='
DPMS7	SC	' in process   '
DPMS8	SC	' in procedure '
DPMSA	SC	/Called from:           /
DPMSD	SC	/At addr:"8d"8a/
DPMSL	SC	/At line:"8d"8a/
DSTMSG	SC	'???'
	SC	'RUN'
	SC	'RDY'
	SC	'IO '
	SC	'GAT'
	SC	'DLY'
	SC	'WAI'
	SC	'END'
:
: QENTRY - Macro to generate query table entry
:	Arguments:
:		Command length (1-4)
:		Command string (upper case ASCII)
:		Routine address
:

QENTRY	MACRO(N,STR,LOC)[
	BND	2
	BS	4-N
	AC	/STR/
	WC	LOC]

	GL	QSTART		:Global so FINISH.LIB can see it
QSTART	WC	NENTRY		:Number of commands
	QENTRY(4,LDAV,QLDAV)
NENTRY	EQ	(.-QSTART-4)/8

	EM
           SUBTTL  Foreground routines                     forgnd.nad
        REMARK %FORGND  V 1.0, 04-22-83, RNP
:
: See the file (ISIS2)NUCLUS.INF for more revision information.
:
:
: V 0.9, 01-26-82, SCY
:	Used R9 as link reg. instead of PUSHR4 & POPR4 when call STATDI
: V 0.8, 01-02-80, MDS
:	Foreground now uses fast dismiss, generally cleaned-up
: V 0.7, 08-25-80, SMF
:	PERCENT CPU USAGE IS NOW DISPLAYED IN FPANEL
: V0.6, 08-15-80, SMF
:	Reset radix to decimal, as it should be.
: V0.5, 07-18-80, SMF
:	Foreground now handles timeslicing correctly
: V0.4, 01-02-80, RNP
:       CHANGED REFERENCE TO FPANEL TO RX3
: 0.3,10-3-79 MODS(SLC)
: 1)FOREGROUND CALLS DIAL-OUT FOREGROUND
: 2) STAT ANALYZER NOW RUNS IN BACKGROUND FROM CLKINC
: 0.1,7-30-79 MODS(SLC)
: 1)RUN NUCLEUS RUN TIME CLOCK OFF FOREGROUND CYCLE
: 2)RUN CONTEXT SWITCH OFF FOREGROUND
: 0.2,9-12-79,MODS(SLC)
: 1)SWITCH RUN TIME CLOCK TO RUN OFF FASTC
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                        :
:       STATISTIC ANAL RUNTIME ROUTINE                                   :
:                                                                        :
:       FRONT PANEL DISPLAY OF PASCAL NUCLEUS RUNTIME STATISTICS:        :
:                                                                        :
:       IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII         :
:       I CHARC  I DISK-TAPE     I              I              I         :
:       I XFER   I ACCESS        I           CPU USAGE         I         :
:       I RATE   I RATE          I          (IN PERCENT)       I         :
:       I        I               I              I              I         :
:       IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII         :
:                                                                        :
:                                                                        :
:       THE UNITS FOR EACH INDEX ARE:                                    :
:                                                                        :
:       CHARC XFER      -       INDEX*256/SECOND (HEX DIGIT)             :
:       DISK-TAPE ACESS -       INDEX*04/SECOND (HEX DIGIT)              :
:       CPU USAGES      -       PERCENT (2 DECIMAL DIGITS)               :
:                                                                        :
:  THE CPU USAGE FIGURE IS APPROXIMATELY THE TOTAL OF THE BKG AND SYS    :
:  RESULTS OF THE '?CPU' COMMAND FOR THE SLOT.                           :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
	RA	0A
:
:	MACRO TO COMPUTE STATISTICS
:
	 
COMPUTE  MACRO(ADR,NUMB,RATE)[
        LH      R4,ADR,,        :Retrieve sum
	 SRL  R4,RATE		:COMPUTE AVERAGE
	 SLL  R4,NUMB		:ORIENTATE FOR DISPLAY
	 OR   R1,R4		:ADD TO DISPLAY
	]
:
:	MACRO TO SIMULATE PUSH INSTR
:
PUSHR4	MACRO[
	L    RA,PASKST,,
	ST   R4,0,RA
	AIS  RA,4
	ST   RA,PASKST,,	]
:
:	MACRO TO SIMULATE POP INSTR
:
POPR4	MACRO[
	L    RA,PASKST,,
	SIS  RA,4
	L    R4,0,RA
	ST   RA,PASKST,,	]
:
	 LO   COMMON
	 GL   FPANEL,PASCLK,DKTPAC,TERXFR,PASSWI,PASPSW,STATDI,PASKST
	 GL   TRATE,FORGND,DTRATE,LASTLC,LASTFC,LASTSC,LCKOFF
	GL	QCOUNT
	GL	USRBOT,CLKINT
	 IF   NDIAL
	 GL   QBEG
	 EI


	 SEG  0

DKTPAC  HC      0       :Disk-Tape access rate
TERXFR  HC      0       :terminal I/O xfer rate
QCOUNT  HS      1       :Quantum counter for foreground

	 SEG  1
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	PASCAL FOREGROUND
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
FORGND  WS      0
	SVC	FASTD		:fast dismiss --> no regs saved

   IF NDIAL
	JAL	R0,QBEG	:out-dial foreground
   EI

        LHL     R1,QCOUNT,,     :R1 = quantum timer value
	JEBS	FORGND		:Already zero, no decrement
	SIS	R1,1			:DECREMENT
        STH     R1,QCOUNT,,
	JGBS	FORGND		:time not up yet

	LIS	R0,0
	SBT	R0,PASSWI,,		:SET FLAG TO TELL BACKGROUND
	LIS	R0,1
	SVC	SYS,RBPSD.		:READ BACKGROUND PSD WORD 1 (PC)
	CI	R0,USRBOT		:RUNNING IN USER CODE?
	JL	FORGND		:In exec, handle at exit
	ST	R0,PASPSW+4,,		:SAVE PSW FOR BACKGROUND
	LIS	R0,0
	SVC	SYS,RBPSD.		:OTHER HALF OF PSD, TOO
	ST	R0,PASPSW,,
	LA	R0,CLKINT		:SIMULATE INTERRUPT IN BACKGROUND
	SVC	SYS,SETBE.	:Background begins executing at "CLKINT"

	J	FORGND
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	THIS ROUTINE IS CALLED EACH SEC BY CLKINC TO DISPLAY
:	STATISTICS OF PASCAL NUCLEUS
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
STATDI
:	COMPUTE CHARC XFER RATE
	 LIS  R1,0
	 COMPUTE(TERXFR,12,TRATE)
:	 COMPUTE DISK-TAPE ACESS RATE
	 COMPUTE(DKTPAC,8,DTRATE)
:	 COMPUTE IDLE TIME
	LH	R4,LCKOFF,,	:LOCALCLOCK OFFSET FOR SLOT
	LHL	R7,NRATE+2,R4,	:SYSTEM LOCALCLOCK
	LHL	R4,NRATE,R4,	:LOCAL CLOCK
	LR	R2,R4		:COPY
	SH	R4,LASTLC,,	:SUBRTRACT LAST VALUE
	NHI	R4,$0 7FF	:IGNORE HIGH ORDER BITS
	STH	R2,LASTLC,,	:SAVE LOCAL CLOCK
	LR	R2,R7		:COPY
	SH	R7,LASTSC,,	:SUBRTRACT LAST VALUE
	NHI	R7,$0 7FF	:IGNORE HIGH ORDER BITS
	STH	R2,LASTSC,,	:SAVE SYSTEM LOCAL CLOCK
	AR	R4,R7		:ADD TIMES
	LHI	R2,100		:SCALE FOR PERCENT
	MR	R3,R2		:R4 := LOCALCLOCK * 100
	L	R7,FASTC,,	:THE FASTCLOCK
	LR	R2,R7		:COPY
	S	R7,LASTFC,,	:SUBTRACT LAST VALUE
	ST	R2,LASTFC,,	:STORE NEW VALUE
	DR	R3,R7		:COMPUTE RATIO IN PERCENT
	LIS	R2,10
	DHR	R4,R2		:SEPARATE INTO DIGITS
	SLLS	R5,4		:SHIFT HIGH ORDER DIGIT INTO PLACE
	OR	R4,R5		:OR THE DIGITS TOGETHER
	OR	R1,R4		:OR INTO DISPLAY
FMON    J       .+4             :Patch to monitor core
        STH     R1,FPANEL,,     :DISPLAY RESULTS
        LIS     R1,0            :Reset counters
        STH     R1,DKTPAC,,
        STH     R1,TERXFR,,
        JR      R9
    	SUBTTL	Printer driver					lprdrv.nad
        REMARK  %LPRDRV  V 1.5 05-11-83, RNP

: See the file (ISIS2)NUCLUS.MEM for more revision information.

: V 1.0, 08-19-81, SMF
:	Initial version
: V 1.1, 01-26-82, SCY
:	Changed link register R4 to R9 when call RDYENT
: V 1.2, 05-20-82, SCY
:	Added a unit_info operation for printer device.
: V 1.3, 11-18-82, SCY
:	Bug fix in the REPEAT_CHAR operation on printer device.
: V 1.4, 01-25-83, RNP
:       Addition for Extended Memory Option
: V 1.5, 05-11-83, RNP
:       Changed RX2 to RX3 instructions where necessary
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								:
:	Lineprinter device driver module			:
:								:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	IF	NPRINT
	MO	.,LPRDRV

	RA	0

	LO	COMMON			:Get common symbols

	GL	PRSTRT,PRCHK,PRINIT	:Module entry points

	GL	IOEXIT,RDYENT		:External routines called
	GL	DVREQ			:External variable used
       IF       XMEMRY
        GL      XMCURR
       EI       :XMEMRY
:
: Constant definitions
:

LPRDEV	EQ	$A 2		:Device type of printer

LPRPRI	EQ	0		:Extra priority for printer operations
:
: Data structures
:

PITENT	EQ	.		:Printer info table entry
	ORG	0
PITCMD	HS	1		:Lineprinter command
PITCNT	HS	1		:Character count
PITADR	WS	1		:Address of buffer (PITBUF)
PITSTP	WS	2		:Lineprinter 'stop' command
PITHDR	WS	1		:Process header addr
PITPRM	WS	1		:Parameter block addr
PITLUN	HS	1		:Logical unit number of printer
PITSTA	HS	1		:Status returned
PITBUF	BS	$A 256		:Print buffer
	WS	0
PITSIZ	EQ	.		:Size of table entry
	ORG	PITENT
:
: Storage for the driver
:

	SEG	A.DATA

	IF	MXPRNT-15	:If MXPRINT > 15
	REMARK	%***Highest printer number may not exceed 15
	EI

PRREQ	HS	1		:Printer request pending bits
PRTMP	HS	1		:Temporary storage for PRREQ

	RA	0A
	WS	0
Q	EQ	0
	RE	MXPRNT+1
	IF	\PLUN|Q|
PTAB|Q|	BS	PITSIZ		:Allocate table entry for printer
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST
:
: In-core constants
:

	SEG	A.CODE		:Code segement

PRTBL	HS	0		:Index printer # to table entry addr
Q	EQ	0
	RE	MXPRNT+1
	IF	\PTAB|Q|
	HC	PTAB|Q|
	ELSE
	HC	0
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST

	RA	0
:
: PRSTRT - Start an I/O operation on a printer device.
:	Called by NUCIO in module NUCIO:
:		R1 = Address of Pascal Data Buffer
:		R2 = Address of Pascal I/O Parameter Block
:		R3 = Device type #
:		R5 = Device unit #
:		R8 = Calling process header addr.
:	Return by jumping to IOEXIT in module NUCLUS
:

PRSTRT  SBT     R3,DVREQ,,      :Set request bit for device
	LR	R11,R2		:Copy param addr
	LR	R12,R5		:Copy printer #
	CLHI	R12,MXPRNT	:Check printer #
	JG	PRBDUN		:Failure if too high
	LHL	R13,PRTBL,R12,R12	:Get printer info table entry addr
	JE	PRBDUN		:Failure if device not allocated
	TBT	R12,PRREQ	:Test request bit for printer
	JN	PRBUSY		:Return busy status if in use
	ST	R8,PITHDR,R13	:Save process header addr
	ST	R2,PITPRM,R13	:Save parameter addr
	LHL	R2,OPER,R11	:Get operation code
	CLHI	R2,5		:Too high?
	JG	PRPRGE		:Yes, program error
	L	R3,ARG1,R11	:Get ARG1 from parameter block
	LH	R2,PRTTBL,R2,R2	:Get routine offset for operation
	J	PRTTBL,R2	:Jump to routine

PRTTBL	EQ	.
	HC	PRTRAW-PRTTBL	:Print raw buffer
	HC	PRTTXT-PRTTBL	:Print ASCII text
	HC	PRTNL-PRTTBL	:Newline (skip lines)
	HC	PRTFF-PRTTBL	:Formfeed (skip to channel)
	HC	PRTRPT-PRTTBL	:Repeat character
	HC	PRTUNI-PRTTBL	:Unit info

:
:	Raw - send buffer directly to ISIS
:		R3 = number of chars to send
:
PRTRAW	LR	R4,R3		:Copy # of chars
	JL	PRPRGE		:Program error if negative
	CLHI	R4,$A 256	:Or if too large
	JG	PRPRGE
	AIS	R4,1		:Round up
	NHI	R4,0FFFE	:  to multiple of 2
	AR	R1,R4		:Point beyond end of buffer
	SIS	R1,2		:Point to last halfword
	LA	R2,PITBUF-2,R13,R4	:Last halfword in print buffer
	SLLS	R4,3		:Multiply by 8 for copy instruction
	COPY	R1,R4		:Copy Pascal buffer to print buffer
	J	PRTGO		:Go print

:
:	Text - Turn on high-order bit for all characters,
:		then send to ISIS
:		R3 = number of chars to print
:
PRTTXT	LR	R4,R3		:# of chars in buffer
	JL	PRPRGE		:Program error if negative
	CLHI	R4,$A 256	:Or if too large
	JG	PRPRGE
PRTTX1	SIS	R4,1		:Decrement char counter
	JL	PRTGO		:Go print if done
	LB	R0,0,R1,R4	:Get character
	OHI	R0,80		:Turn on high-order bit
	STB	R0,PITBUF,R4,R13	:Put in print buffer
	JBS	PRTTX1		:Loop until done

:
:	Newline - end line and skip some lines
:		R3 = number of lines to skip
:
PRTNL	LIS	R0,0		:End-of-line printer code
	STB	R0,PITBUF,R13	:Put in print buffer
	LR	R0,R3		:Number of lines to skip
	JL	PRPRGE		:Program error if negative
	CLHI	R0,$A 59	:Too large? (Max = 59)
	JG	PRPRGE		:Yes, program error
	AHI	R0,84		:Convert to skip code
	STB	R0,PITBUF+1,R13	:Put in print buffer
	LIS	R3,2		:Two characters for printer
	J	PRTGO		:Send them

:
:	Formfeed - end line and skip to channel or top of form
:		R3 = channel number (or 0 for TOF)
:
PRTFF	LIS	R0,0		:End-of-line printer code
	STB	R0,PITBUF,R13	:Put in print buffer
	LR	R0,R3		:Channel number
	JL	PRPRGE		:Program error if negative
	CLHI	R0,$A 12	:Too large? (Max = 12)
	JG	PRPRGE		:Yes, program error
	AHI	R0,0A0		:Convert to channel code
	STB	R0,PITBUF+1,R13	:Put in print buffer
	LIS	R3,2		:Two characters for printer
	J	PRTGO		:Send them

:
:	Repeat - print a character multiple times
:		(Compressed character expansion)
:		R3 = # times to print character
:		Character is first in Pascal buffer
:
PRTRPT	LB	R0,0,R1		:Get character to repeat
	OHI	R0,80		:Make sure high-order bit is on
	STB	R0,PITBUF,R13	:Put in print buffer
	LR	R0,R3		:# times to print char
	JLE	PRPRGE		:Program error if not positive
	CLHI	R0,$A 63	:Or if too high (Max = 63)
	JG	PRPRGE
	CLHI	R0,1		:Repeat only one time?
	JE	PRTGO		:Yes, go print it
	AHI	R0,40-1		:Convert to repeat code
	STB	R0,PITBUF+1,R13	:Put in print buffer
	LIS	R3,2		:Two characters to print
	J	PRTGO		:Go print them

:
:	Unit_info operation
:

PRTUNI
	LIS	R0,0		:Command to do stop
	STH	R0,PITCMD,R13	:Put in command block
	LCS	R0,1
	STH	R0,PITSTA,R13	:Set status = -1 initially
	LHL	R1,PITLUN,R13	:Get logical unit for printer
	LR	R2,R13		:Address of command structure
	LA	R3,PITSTA,R13	:Address to put status
	SVC	IO,FPRT.*10+R1	:Force printer
	J	PRNOTA		:Normal return = failure, Device not assigned
	SBT	R12,PRREQ	:Set request bit for printer
	J	IOEXIT		:Skip return = operation started

:
:	Send the print buffer to the printer
:
PRTGO	LIS	R0,1		:Command to do output
	STH	R0,PITCMD,R13	:Put in command block
	STH	R3,PITCNT,R13	:Put char count in block
	LA	R0,PITBUF,R13	:Get buffer address
	ST	R0,PITADR,R13	:Put in block
	LHL	R1,PITLUN,R13	:Get logical unit for printer
	LR	R2,R13		:Address of command structure
	LA	R3,PITSTA,R13	:Address to put status
	SVC	IO,CPRT.*10+R1	:Connect printer
	J	PRNOTA		:Normal return = Failure
	SBT	R12,PRREQ	:Set request bit for printer
	J	IOEXIT		:Skip return = operation started


:
:	Error returns - set status and return from I/O call
:

PRPRGE	LIS	R0,PRGERR	:'Program error' status
	JFS	PRRET

PRBUSY	LIS	R0,BUSY		:'Busy' status
	JFS	PRRET

PRNOTA
	LCS	R0,2		:Device not assigned code
	ST	R0,STATS2,R11	:Save in status2
	JFS	PRFAIL

PRBDUN	LCS	R0,1		:Bad unit # code
	ST	R0,STATS2,R11	:Save in STATUS2
PRFAIL	LIS	R0,FAIL		:'Failure' status

PRRET	STH	R0,STATUS,R11	:Save status in parameter block
	JAL	R9,RDYENT	:Place process on ready queue
	J	IOEXIT		:Exit Nucleus
:
: PRCHK - Check for I/O completion
:	Called by NIOCP in module NUCIO
:	Link on R2
:

PRCHK	LHL	R3,PRREQ	:Get request bits
	JN	PRCHK1		:Jump if any requests
	LIS	R0,LPRDEV	:Get device type #
        RBT     R0,DVREQ,,      :Stop I/O system from polling

PRCHK1	JFFOH	R3,PRCHK2	:Jump if any requests left
	JR	R2		:None, return

PRCHK2	STH	R3,PRTMP	:Save bits
	RBT	R4,PRTMP	:Clear this one
	LHL	R13,PRTBL,R4,R4	:Get Printer info table entry addr
       IF       XMEMRY
        L       R10,PITHDR,R13  :R10 -> Process Header Record
        LH      R10,XMPSET+4,R10        :R10 = XM MAC Set
        JAL     R4,XMCURR       :Make this Proc's set current
       EI       :XMEMRY
	L	R11,PITPRM,R13	:Get param. addr
	LHL	R0,OPER,R11	:Get operation
	CLHI	R0,5		:Is unit_info?
	JE	PRCHK3		:Skip if yes
	LH	R5,PITCMD,R13	:Else get command from command block
	JN	PRCHK3		:Skip if operation not done
	LIS	R0,COMPLE
	J	PRCHKA
PRCHK3	LH	R6,PITSTA,R13	:Get status from command block
	JL	PRCHKB		:Skip if no status return yet
	JG	PRCHK4		:Skip to check the error status
	CLHI	R0,5		:Is unit_op?
	JN	PRCHKB		:Skip if not
	LIS	R0,COMPLE	:Else get 'complete' status
	J	PRCHKA
PRCHK4	LIS	R5,0F
	TBT	R5,PITSTA,R13	:Test bit 15
	JN	PRCHK7		:Skip if printer is not ready
	LIS	R5,0C
	TBT	R5,PITSTA,R13	:Test bit 12
	JN	PRCHKB		:Skip if printer is busy
	NHI	R6,044
	CLHI	R6,044		:Test bit 9 & 13
	JE	PRCHK5		:Skip if printer is out of paper
	JAL	R10,CRASH,,	:Else crash with unknown status
	BC	0,0,4*R2,$033
PRCHK5	LIS	R5,2		:Set 'printer is out of paper' status
	J	PRCHK8
PRCHK6	LIS	R0,BUSY
	JFS	PRCHKA
PRCHK7
	LIS	R5,1		:Set 'printer is not ready' status
PRCHK8	LIS	R0,INTERV	:Set 'intervention' status
	ST	R5,STATS2,R11
PRCHKA	RBT	R4,PRREQ	:Done - clear request bit
	STH	R0,STATUS,R11
	L	R8,PITHDR,R13	:Get process header
	JAL	R9,RDYENT	:Put process on ready queue
PRCHKB	LH	R3,PRTMP	:Get request bits not looked yet
	J	PRCHK1		:Loop
:
: PRINIT - Initialize the I/O driver
:	Link on R2
:

PRINIT	LIS	R0,0
	STH	R0,PRREQ	:No printer requests pending

	RA	0A
Q	EQ	0
	RE	MXPRNT+1	:For each printer
	IF	\PLUN|Q|	:If printer defined
	LIS	R0,PLUN|Q|	:Get logical unit #
	LHL	R13,PRTBL+2*Q	:Get table entry addr
	STH	R0,PITLUN,R13	:Store LUN in table
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST
	RA	0

	LIS	R0,0
	LHI	R1,2*MXPRNT	:Get 2*highest printer number
PRINI1	LHL	R13,PRTBL,R1	:Get table entry addr
	JEFS	PRINI2		:Skip if not used
	ST	R0,PITSTP,R13	:Set stop command in table
	ST	R0,PITSTP+2,R13
PRINI2	SIS	R1,2		:Decrement counter
	JGEBS	PRINI1		:Loop until done
	JR	R2		:Return
:
: Entry point definitions for NUCIO
:

	GL	STRT|LPRDEV|,COMP|LPRDEV|,INIT|LPRDEV|,DPRI|LPRDEV|


STRT|LPRDEV|	EQ	PRSTRT		:Start requests
COMP|LPRDEV|	EQ	PRCHK		:Check completion
INIT|LPRDEV|	EQ	PRINIT		:Initialize driver

DPRI|LPRDEV|	EQ	LPRPRI		:Priority

	EM
	EI	:NPRINT
   	SUBTTL	Pseudo device driver				pseudo.nad
        REMARK  %PSEUDO  V 1.23 12-04-84, AWT

: See the file (ISIS2)NUCLUS.MEM for more revision information.

: V 1.0, 09-01-81, SMF
:	Initial version
: V 1.1, 11-06-81, SCY
:       Add a new operation GET_CKSUM on SYS device
: V 1.3, 12-09-81, RNP
:       Added Logical Volume support.
: V 1.5, 01-18-82, RNP
:       Added write count to lvol info, cleaned up counts.  
:	01-26-82, SCY
:	Changed to use R9 instead of R4 as link register when call RDYENT.
: V 1.6, 02-03-82, RNP
:       Fixed bug in LVOL SETOP, and added error check
: V 1.7, 03-07-82, RNP
:       Fixed bug in handling volume down
: V 1.8, 03-10-82, SCY
:	Changed routine SYHOST to report host status using 
:	  ISIS msg 10 rather than 4.
:	Added a new operation PROGRAM_STATUS_INFO on SYS device.
:V 1.9, 05-20-82, SCY
:	Added vertical cksum value return in arg1 and diagonal cksum
:	value return in arg2 for GET_CKSUM operation on SYS device.
: V 1.10, 06-07-82, RNP
:       Fixed bug in LVOL (volume down code)
: V 1.11, 06-30-82, RNP
:       Reordered LVOL vol down calls
: V 1.12, 07-21-82, RNP
:       Fixed LVOL init initialization problem
: V 1.13, 07-27-82, SCY
:	Added a new function of HALT operation for crash device to allow 
:	program gives test for inclusion in slot history.
: V 1.14, 09-20-82, SCY
:	Adds support of version 18 u-code for GET_CKSUM operation on 
:	SYS device.
: V 1.15, 11-26-82, RNP
:       Fixed LVOL init problems.
: V 1.16, 01-03-83, RNP
:       Treat disk error 24 as no error.
: V 1.17, 04-01-83, RNP
:       Changes for Extended Memory Option
:       Fixed bug in LVOL disk down cleanup
: V 1.18, 05-11-83, RNP
:       Added code to handle error on disk start request in LVOL
: V 1.19, 12-19-83, AWT
:       Fixed bug in LVOL COPY operation, using FIFO wherever there is
:       a copy request on LRE queue to prevent some write operations'
:       interference.
: V 1.20, 03-22-84, AWT
:       Fixed bug in System Device's checksum operation which caused
:       the address of Pascal data buffer to be changed --- save R1
:       before CKSUM instruction.
:       Added checking point for extended memory configuration --- crash
:       14 will occur if Pascal data buffer address is less than 0A0000.
: V 1.21, 04-14-84, AWT
:       Added PIPE device.
: V 1.22, 07-10-84, AWT
:       Change the number of disk tries from 16 to 25 when error on
:       request (LVFERB routine).
:       Bug fixed in ERRHND for crash device -- check MAC set #.
:       
: V 1.23, 09-15-84, AWT
:       Bug fixed in LVOL - check copy request location on LRE queue
:       when PV is down to prevent system hung
:	11-28-84, MKS
:	Change the op code from STH into ST in the two instructions
:	labelled  SYOUT1.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								:
:	Pseudo device driver module				:
:								:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	MO	.,PSEUDO

	RA	0

	LO	COMMON			:Get common symbols

	GL	SYSTRT,CRSTRT,ERRHND	:Module entry points

	GL	IOEXIT,RDYENT,RNSYSE	:External routines called
        GL      CONMSG,STKBOT
	GL	PASERR,ERRPRC,ERRLIN	:External variables used
	GL	PASCFR,PORTCT
        GL      LVSTRT
        GL      LVNQUE,LVNDSK
        IF      LVNDSK
Q       EQ      0
        RE      LVNDSK
        GL      LVDSK|Q|, LVPDK|Q|
Q       EQ      Q+1
        ER
        EI      :LVNDSK
        GL      DSKDEV

       IF       XMEMRY
        GL      XMCURR,XMLEFT,XMLFT0,XMPCUR,NMACSS,EMMAC0
       EI       :XMEMRY

       GL       XPIPE,NPIPE,DVREQ
       IF       XPIPE
        GL      PIPTBL,PIPCHK,PPSIZE
       EI       :XPIPE
:
: Constant definitions
:

DSKDEV	EQ	$A 0		:Device type of disk device
SYSDEV	EQ	$A 3		:Device type of system device
CRADEV	EQ	$A 4		:Device type of crash device
LVODEV  EQ      $A 7            :Device type of LVOL device
PIPDEV  EQ      $A 8            :DEVICE TYPE OF PIPE DEVICE

SYSPRI	EQ	0		:Extra priority for system operations
CRAPRI	EQ	0		:Extra priority for crash operations
LVOPRI  EQ      0               :Extra priority for LVOL operations
PIPPRI  EQ      0               :EXTRA PRIORITY FOR PIPE OPERATIONS
:
: Data structures
:

CRAREC	EQ	.		:Crash device return record
	ORG	0
CRAERR	WS	1		:Pascal error code
CRAPRC	WS	1		:Process number
CRALIN	WS	1		:Line number
CRALEN	EQ	.		:Length of record
	ORG	CRAREC
:
:       Physical Device Table (for LVOL)
:
PVTREC  WS      0               :allignment
        ORG     0
PVTDP   BS      DPSIZ           :Disk Parameter Block
PVTINC  BS      1               :Incarnation Number
PVTLOG  BS      1               :Logical Volume Number
PVTFLG  BS      1               :Flag byte (bits as follows)
PVTDOW  EQ      0               : bit 0 - This volume physically down
PVTSDO  EQ      1               : bit 1 - This volume declared down
PVTRO   EQ      2               : bit 2 - This volume is read only
PVTWO   EQ      3               : bit 3 - This volume is write only
PVTBUS  EQ      4               : bit 4 - This volume busy
PVTGOD  EQ      5               : bit 5 - The volume going down
PVTERR  BS      1               :Last Error
PVTLUN  BS      1               :ISIS Logical Unit Number
PVTNUM  BS      1               :PVT index
PVTLER  BS      1               :Local Error Count (per request)
        BS      1               :Unused
PVTERS  HS      1               :Error Count
PVTSTA  HS      1               :Status on last error
PVTNRD  WS      1               :Count of reads
PVTNWT  WS      1               :Count of writes
PVTLRE  WS      1               :Current Request's LRE
PVTSAV  WS      $A 16           :Save area
PVTLEN  WS      0               :Length of Record
        ORG     PVTREC


:
:       LVOL Request Element
:
LREREQ  WS      0               
        ORG     0
LRENXT  WS      1               :Ptr to next LRE in chain
LREFLG  BS      1               :LVOL REQ Flag
LREUSE  EQ      0               : bit 0 - this LRE in use
LREANY  EQ      1               : bit 1 - any one PVT can satisfy req
LRECOP  EQ      2               : bit 2 - COPY type request
LREINI  EQ      3               : bit 3 - INIT type request
LRE1OK  EQ      4               : bit 4 - One request has no errors
LREDOP  BS      1               :Disk operation code
LRERNO  BS      1               :Number of requests in progress
LREPAS  BS      1               :Passed over count
LREPVT  WS      1               :bit map of PVs for this request
LREPHP  WS      1               :Process Header ptr
LREPDB  WS      1               :Pascal Data Buffer
LREPPB  WS      1               :Pascal Parm Block
LRELEN  WS      0               :Length of LVOL Request Element
        ORG     LREREQ

:
:       PIPE INFORMATION TABLE
:
PIPENT  WS      0
        ORG     0
PIPNUM  HS      1                :PIPE NUMBER OR STATE
PIPOP   HS      1                :PIPE OPERATION (-1 = NONE, 0 = SEND START,
                                 :  1 = RECEIVE START, 2 = SEND STOP,
                                 :  3 = RECEIVE STOP)
PPSPTR  WS      1                :SEND BUFFER POINTER
PPSPRM  WS      1                :SEND PARAMETER BLOCK ADDRESS
PPSPHD  WS      1                :SEND PROCESS HEADER ADDRESS
PPSLFT  WS      1                :NUMBER OF CHARS LEFT TO SEND
PPRPTR  WS      1                :RECEIVE BUFFER POINTER
PPRPRM  WS      1                :RECEIVE PARAMETER BLOCK ADDRESS
PPRPHD  WS      1                :RECEIVE PROCESS HEADER ADDRESS
PPRLFT  WS      1                :NUMBER OF CHARS LEFT TO READ
PPSIZE  WS      0                :SIZE OF PIPE INFO TABLE
        ORG     PIPENT

:
: Storage for the driver
:

	SEG	A.DATA

CRWHDR	WS	1		:Process header waiting for error
CRWPRM	WS	1		:Parameter block addr
CRWPDB	WS	1		:Pascal data buffer

CRARET	WS	1		:Return address storage

SAVXMC  HC      0               :USED IN PIPE MAC SETS SWITCHING
PPMAC2  WS      1               :PIPE MAC SET SEG2 BASE PAGE VALUE
CPRSAV  WS      10              :TEMPORARY REGESTERS STORAGE DURING
                                :OUTPUT COPY FAIL CONSOLE MESSAGE

ERRFLG	HS	1		:Process waiting flag
MAXBYT  EQ      $0 80           :Max byte count for cksum operation
HLTMSG	SC	/Program Requested halt/
CPERR1  SC      /LVOL FAIL - PHYSICAL VOLUMN DOWN"8D"8A/
CPERR2  SC      /LVOL FAIL - DISK VOLUMN DOWN"8D"8A/
CPERR3  SC      /LVOL FAIL - CANNOT START DISK REQUEST"8D"8A/

:
:       Generate Pool of LVOL Request Elements
:
LRES    WS      0
        IF      LVNQUE
        RE      LVNQUE
        BS      LRELEN
        ER
        EI      :LVNQUE
ENDLRE  EQ      .
:
:       Generate LVOL Physical Volume Tables
:
NPVTS   EQ      0               :Count of PVTs
PVTS    WS      0               :Start of PVTs
        IF      LVNDSK
Q       EQ      0
        RE      LVNDSK
NPVTS   EQ      NPVTS+LVDSK|Q|
Q       EQ      Q+1
        ER      :LVNDSK
        RE      NPVTS
        BS      PVTLEN
        ER      :NPVTS
        EI      :LVNDSK
ENDPVT  EQ      .               :End of PVTs

LREQUE  WS      1               :LRE Queue
COPOUT  WS      1               :FLAG USED FOR PV DOWN ROUTINE LVFN88
LVPASS  WS      1               :LRE queue re-ordered count
SIZPVT  HC      PVTLEN          :Size of PVT (for MH)
NUMPVT  HC      NPVTS           :Number of Physical Volume Tables
CTCOPY  WS      1               :# OF COPY REQUESTS ON LRE QUEUE
LREPOS  WS      1               :POSITION COUNTER OF LRE IN QUEUE
COPYLC  WS      1               :THE POSITION OF COPY REQUEST ON LRE
LVFLAG  HS      1               :Global LVOL flag
LVINIC  EQ      0               : bit 0 - INIT function completed
LVCOPI  EQ      1               : bit 1 - In middle of COPY
LVINII  EQ      2               : bit 2 - In middle of INIT
LVINIS  EQ      3               : bit 3 - INIT just started


        IF      XPIPE
PPGRP   EQ      (NPIPE+0F)/10   :# OF HALFWORDS IN DEVICE BIT ARRAY
PIPCHW  HS      1               :TEMP STORAGE FOR PIPCHK
PIPESD  HS      PPGRP           :BIT ARRAY FOR PIPE SEND REQUESTS
PIPERC  HS      PPGRP           :BIT ARRAY FOR PIPE RECEIVE REQUESTS
PPENT   HS      NPIPE           :PIPE TABLE ADDRESSES
        EI      :XPIPE
:
: In-core constants
:

	SEG	A.CODE		:Code segment

	RA	0A
CNSTAB	HC	NCONST		:CNSTAB[0] := Number of constants
	IF	NCONST
Q	EQ	1
	RE	NCONST
	HC	CNST|Q|		:CNSTAB[Q] := CNST|Q|
Q	EQ	Q+1
	NOLIST
	ER
	EI	:NCONST
        LIST
	RA	0
:
: SYSTRT - Start an I/O operation on the system device.
:	Called by NUCIO in module NUCIO:
:		R1 = Address of Pascal Data Buffer
:		R2 = Address of Pascal I/O Parameter Block
:		R3 = Device type #
:		R5 = Device unit #
:		R8 = Calling process header addr.
:	Return by jumping to IOEXIT in module NUCLUS
:

SYSTRT	LR	R11,R2		:Move parameter block addr
	LHL	R6,OPER,R11	:Get operation
	CLHI	R6,8		:Too high?
	JG	PSPRGE		:Yes, program error return
	LH	R7,SYRTB,R6,R6	:Get appropriate routine offset
	J	SYRTB,R7	:Jump to routine

SYRTB	EQ	.
	HC	SYHOST-SYRTB	:Operation 0 - Set host up
	HC	SYHOST-SYRTB	:Operation 1 - Set host down
	HC	SYHOST-SYRTB	:Operation 2 - Set host shut
	HC	SYHOST-SYRTB	:Operation 3 - Set host gone
	HC	SYINFO-SYRTB	:Operation 4 - Sys_info
	HC	SYFREE-SYRTB	:Operation 5 - Free core left
	HC	SYCNST-SYRTB	:Operation 6 - Read constants
	HC	SYCKSM-SYRTB	:Operation 7 - Get chksum
	HC	SYSTAT-SYRTB	:Operation 8 - Program status info

SYHOST	LHI	R5,HIQ0		:Load host intelligent flag 
	SLHLS	R5,7
	LHI	R7,HID0		:Load host ID
	SETHST(R6,R5,R7)
	J	PSCOMP		:Completion return

SYINFO	LHI	R0,NTERM	:Number of terminal devices
	ST	R0,0,R1		:Save in buffer[1]
	LHI	R0,NAUX		:Number of aux ckt devices
	ST	R0,4,R1		:Save in buffer[2]
	LHI	R0,HOST0	:Host number
	ST	R0,8,R1		:Save in buffer[3]
	LHL	R0,NODEX,,	:Node number
	ST	R0,0C,R1	:Save in buffer[4]
	LHL	R0,SLOTNO,,	:Slot number
	ST	R0,10,R1	:Save in buffer[5]
	LHL	R0,HOSTX,,	:Kernel host number
	ST	R0,14,R1	:Save in buffer[6]
	LHL	R0,VERNO,,	:ISIS version
	ST	R0,18,R1	:Save in buffer[7]
	LHL	R0,VERREV,,	:Slot (Nucleus) version
	ST	R0,1C,R1	:Save in buffer[8]
	J	PSCOMP		:Request complete

SYFREE  HS      0
       IF       XMEMRY
        LHL     R0,XMLFT0,,     :R0 = Pages left
        SLL     R0,8            :Shift to bytes
        A       R0,XMLEFT,,     :Plus left in current window
       ELSE
        L       R0,PASCFR,,     :R0 = free space
       EI       :XMEMRY
	ST	R0,ARG1,R11	:Save in ARG1
	J	PSCOMP		:Request complete

SYCNST	L	R4,ARG1,R11	:Get constant number
        JGE     SYCNS1
        J       PSFAIL
SYCNS1  CLHI    R4,NCONST       :TOO HIGH?
        JLE     SYCNS2
        J       PSFAIL
SYCNS2  LHL     R0,CNSTAB,R4,R4 :GET CONSTANT
	ST	R0,ARG2,R11	:Return in ARG2
	J	PSCOMP

SYCKSM
	L	R2,ARG1,R11	:R2 contain the byte count
	JL	PSPRGE
	LIS	R4,0		:R4 & R5 are used to store cksum value
	LIS	R5,0
	IF	NMICRO
	CI	R2,$0 10000	:Compare with the maximum allowable
	JG	PSPRGE
	LIS	R0,0
	SR	R0,R2		:R0 contain negative byte count
	CKSUM	R4,R1
	J	SYOUT1

	ELSE
SYLOOP
	LIS	R0,0
	CLHI	R2,MAXBYT
	JLE	SYOUT
	SHI	R0,MAXBYT	:R0 contain the negative byte count
        LR      R6,R1           :SAVE R1
	CKSUM	R4,R1		:Return the vertical cksum in R4
        LR      R1,R6           :RESTORE R1
	XR	R5,R4
	RRL	R5,1
	LR	R6,R5
	SRL	R5,10		:Move 1st halfword to sec'd halfword
	OR	R5,R6
	NI	R5,0FFFF
	AHI	R1,MAXBYT	:Update the addr of pascal data buffer
	SHI	R2,MAXBYT	:Get the rest of byte count
	J	SYLOOP

SYOUT
	SR	R0,R2		:R0 contain negative byte count
	CKSUM	R4,R1
        EI
SYOUT1	ST	R4,ARG1,R11	:Save vertical cksum in arg1
	ST	R5,ARG2,R11	:Save diagonal in arg2
	J	PSCOMP

SYSTAT	LHI	R0,PORTCT	:Counts of ports available for log in
	ST	R0,0,R1		:Save in buffer[1]
	LIS	R0,0
	LIS	R4,0F		:15 reserved words
SYSTA1	AIS	R1,4
	ST	R0,0,R1		:Save in buffer[2] and beyond
	SIS	R4,1
	JG	SYSTA1
	J	PSCOMP
:
: CRSTRT - Start an I/O operation on the crash device.
:	Called by NUCIO in module NUCIO:
:		R1 = Address of Pascal Data Buffer
:		R2 = Address of Pascal I/O Parameter Block
:		R3 = Device type #
:		R5 = Device unit #
:		R8 = Calling process header addr.
:	Return by jumping to IOEXIT in module NUCLUS
:

CRSTRT	LR	R11,R2		:Copy Parameter block addr
	LH	R6,OPER,R11	:Get operation
	CLHI	R6,4		:Too high?
	JG	PSPRGE		:Yes, program error return
	LH	R6,CRRTB,R6,R6	:Get appropriate routine offset
	J	CRRTB,R6	:Jump to routine

CRRTB	EQ	.
	HC	CRR0-CRRTB	:Operation 0 - Wait for Pascal error
	HC	CRR1-CRRTB	:Operation 1 - Simulate Pascal error
	HC	CRR2-CRRTB	:Operation 2 - Restart slot
	HC	CRR3-CRRTB	:Operation 3 - Halt slot
	HC	CRR4-CRRTB	:Operation 4 - Kill process

CRR0    TS      ERRFLG,,        :Set error wait flag
	JN	PSBUSY		:Return 'busy' if someone already waiting
        ST      R8,CRWHDR,,     :Save process header addr
        ST      R1,CRWPDB,,     :Save Pascal data buffer address
        ST      R11,CRWPRM,,    :Save parameter block address
	J	IOEXIT

CRR1	LA	HD,4,R8		:Restore process header pointer
	LHI	R6,$A14		:Simulated error
	J	RNSYSE

CRR2	SVC	DISMISS,10	:Give output ring time to empty
	JAL	R10,CRASH	:Simulate manual restart for slot
	BC	0,0,4*R8,1

CRR3	SVC	DISMISS,10	:Give output ring time to empty
	L	R6,ARG1,R11	:Get msg length
	JLE	CRR3A		
	SIS	R1,1
	STB	R6,0,R1		:Store the msg length
	LR	R0,R1		:Save to R0
CRLOOP	LB	R2,1,R1
	OHI	R2,80		:Set the parity bit on
	STB	R2,1,R1
	AIS	R1,1		:Update the pascal data buffer pointer
	SIS	R6,1		:Decrement the msg length
	JG	CRLOOP
	SVC	SYS,SUDIA.
CRR3A   LA      R0,HLTMSG,,
	SVC	SYS,SUDIA.	:Set user diagnostic msg
	SVC	SYS,HALT.	:Halt the slot

CRR4	L	R6,ARG1,R11	:Get process # to kill
	LHL	R6,PASPRC-2,R6,R6	:Get process header for proc
        JG      CRR4A
	J	PSFAIL		:Failure if no such process
CRR4A	LHL	R0,STATE1+HEAD0,R6	:Get process state
        JG      CRR4B
	J	PSFAIL		:Failure if unknown state
CRR4B	LIS	R4,ST.END	:Get 'Ended' state
	CLR	R0,R4		:Process already ended?
        JN      CRR4C
	J	PSFAIL		:Failure if so
CRR4C	STH	R4,STATE1+HEAD0,R6	:Set state to ended
	JFS	PSCOMP		:Request complete
:
: Set status in parameter block and return from I/O call
:

PSFAIL	LIS	R0,FAIL		:'Failure' status
	JFS	PSRET

PSPRGE	LIS	R0,PRGERR	:'Program error' status
	JFS	PSRET

PSBUSY	LIS	R0,BUSY		:'Busy' status
	JFS	PSRET

PSCOMP	LIS	R0,COMPLE	:'Complete' status

PSRET	STH	R0,STATUS,R11	:Save status in parameter block
	JAL	R9,RDYENT	:Place process back on ready queue
	J	IOEXIT		:Exit Nucleus

PPBDUN  LCS     R0,1            :'PIPE DOES NOT EXIST' CODE (-1)
        ST      R0,STATS2,R11   :SAVE IN STATUS2
        J       PSFAIL
:
: ERRHND - Completion for crash wait
:
:	This routine is called on any Pascal error.  It checks to see
:	if any process was waiting on the crash device, and if so,
:	finishes up the I/O request on that process.
:
:	Called from RNSYSE in module NUCLUS
:	Link on R4
:
:	Changed to use R9 rather than R4 when called RDYENT
:

ERRHND  ST      R4,CRARET,,     :Save return address
	LIS	R0,0		:Get zero
        LH      R1,ERRFLG,,     :Anyone waiting?
        STH     R0,ERRFLG,,     :Clear flag regardless
	JER	R4		:Nobody waiting, return

       IF       XMEMRY
        LH      R1,XMPCUR,,
        L       R10,CRWHDR,,
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
       EI       :XMERY
        L       R10,CRWPDB,,    :R10-> Pascal data buffer
	LHL	R0,PASERR,,	:Get error code
	ST	R0,CRAERR,R10	:Put in Pascal data buffer
	LHL	R0,ERRPRC,,	:Get process number
	ST	R0,CRAPRC,R10	:Put in Pascal data buffer
	LHL	R0,ERRLIN,,	:Get line number
	ST	R0,CRALIN,R10	:Put in Pascal data buffer

        L       R11,CRWPRM,,    :R11 -> parameter block
	LIS	R0,COMPLE	:Complete status
	STH	R0,STATUS,R11	:Return in parameter block

        L       R8,CRWHDR,,     :R8 -> process header
	JAL	R9,RDYENT	:Put in ready queue
       IF       XMEMRY
        LR      R10,R1
        JAL     R4,XMCURR
       EI       :XMEMRY
        L       R4,CRARET,,     :Restore return address
	JR	R4		:Return
:
: LVSTRT - Start an I/O operation on the LVOL device.
:       Called by NUCIO:
:               R1 -> Pascal Data Buffer
:               R2 -> Pascal Parm Block
:               R3 = Device type number
:               R5 = Device unit number
:               R8 -> Calling process header

LVSTRT  HS      0
        IF      LVNDSK
        LR      R10,R1          :R10 -> PASCAL data buffer
        LR      R11,R2          :R11 -> PASCAL parm block
        LHL     R6,OPER,R11     :R6 = operation code
        CLHI    R6,6            :7 operations are defined
        JG      PSPRGE          :too high, program error
        LH      R6,LVRTB,R6,R6  :Get routine offset
        J       LVRTB,R6        :handle LVOL operation

LVRTB   HS      0
        HC      LVINI-LVRTB     :Operation 0 - Initialize
        HC      LVITWO-LVRTB    :Operation 1 - Simulate Init
        HC      LVINFO-LVRTB    :Operation 2 - Info
        HC      LVSETO-LVRTB    :Operation 3 - Set Options
        HC      LVCOPY-LVRTB    :Operation 4 - Copy
        HC      LVREAD-LVRTB    :Operation 5 - Read
        HC      LVWRIT-LVRTB    :Operation 6 - Write
:
:       LVOL Initialize
:
LVINI   HS      0
        LIS     R0,LVINII       :LVOL init in progress
        SBT     R0,LVFLAG,,     :Set it
        JN      PSBUSY          :Init already in progress
        LIS     R0,LVINIS       :Init just started flag
        SBT     R0,LVFLAG,,     :Set it
        JAL     R4,GETLRE       :Allocate an LVOL Request Element
        JAL     R4,LVSETB       :Set PASCAL ptrs into LRE
        LIS     R0,LREINI       :Indicate Initialize
        SBT     R0,LREFLG,R6    :Initialize request
        LIS     R0,0            :Indicate read operation
        ST      R0,ARG2,R11     :Clear volume up count
        STB     R0,LREDOP,R6    :Set disk operation into LRE
        LA      R7,PVTS,,       :R7 -> PVTs
        LIS     R4,0            :PVT index
LVINLP  SBT     R4,LREPVT,R6    :Include this PVT in request
        AIS     R4,1            :Bump PVT index
        AHI     R7,PVTLEN       :Bump PVT Ptr
        CLI     R7,ENDPVT       :At end of PVTs?
        JLBS    LVINLP          :No, loop back
        JAL     R4,QUELRE       :Queue request
        J       LVEXIT          :Good Return
:
:       LVOL Simulated Initialize
:
LVITWO  HS      0
        LA      R1,PVTS,,       :R1 -> PVTS
LVI2LP  LIS     R0,PVTDOW       :Indicate PV down
        SBT     R0,PVTFLG,R1    :...
        AHI     R1,PVTLEN       :On to next PVT
        CLI     R1,ENDPVT       :At end of PVTs?
        JLBS    LVI2LP          :No, loop
        L       R0,ARG1,R11     :Get number of entries
LVI2L2  L       R1,0,R10        :R1 = PV index
        MH      R1,SIZPVT,,     :R1 = PVT displacement
        LA      R1,PVTS,R1,     :R1 -> PVT
        L       R2,4,R10        :R2 = logical volume number
        STB     R2,PVTLOG,R1    :Set LVN
        L       R2,8,R10        :R2 = Incarnation number
        STB     R2,PVTINC,R1    :Set Incarnation
        LIS     R2,0            :R2 = zero
        STB     R2,PVTFLG,R1    :Clear flag
        AIS     R10,0c          :Bump data area ptr
        SIS     R0,1            :Drop entry count
        JG      LVI2L2          :Loop till zero
        LIS     R0,LVINIC       :LVOL INIT complete flag
        SBT     R0,LVFLAG,,     :Set it
        J       PSCOMP          :Good Return
:
:       LVOL Info
:
LVINFO  HS      0
        L       R0,ARG1,R11     :get max buffer size
        CLHI    R0,$A32*NPVTS   :big enough?
        JGE     LVLOP0
        J       PSFAIL          :too small, FAILURE
LVLOP0  LHL     R0,NUMPVT,,     :R0 = number of PVTs in system
        ST      R0,ARG2,R11     :Set for caller
        LA      R3,PVTS,,       :R3 -> PVTs
LVLOP1  L       R4,PVTNRD,R3    :R4 = read count
        ST      R4,0,R1         :Set for caller
        L       R4,PVTNWT,R3    :r4 = write count
        ST      R4,4,R1         :Set into info buffer
        LHL     R4,PVTSTA,R3    :R4 = last status
        ST      R4,8,R1         :Set for caller
        LHL     R4,PVTERS,R3    :R4 = number of errors
        ST      R4,$A12,R1      :Set for caller
        LB      R4,PVTLOG,R3    :R4 = Logical Volume Number
        ST      R4,$A16,R1      :Set for caller
        LB      R4,PVTINC,R3    :R4= Incarnation Number
        ST      R4,$A20,R1      :Set for caller
        LB      R4,PVTERR,R3    :R4 = last error code
        ST      R4,$A24,R1      :Set for caller
        LIS     R4,0            :Assume volume down
        LIS     R2,PVTDOW       
        TBT     R2,PVTFLG,R3    :Is Physical Volume down?
        JG      LVLPE1          :Yes, report volume down?
        LIS     R4,4            :Assume volume set to unavailable
        LIS     R2,PVTSDO
        TBT     R2,PVTFLG,R3    :Is Physical Volume unavailable?
        JGFS    LVLPE1          :Yes, report volume unavailable
        LIS     R4,3            :Assume volume set to write only
        LIS     R2,PVTWO        
        TBT     R2,PVTFLG,R3    :Is Physical Volume write only?
        JGFS    LVLPE1          :Yes, skip
        LIS     R4,2            :Assume volume set to read only
        LIS     R2,PVTRO        
        TBT     R2,PVTFLG,R3    :Is Physical Volume read only?
        JGFS    LVLPE1          :Yes, skip
        LIS     R4,1            :Physical volume just up
LVLPE1  ST      R4,$A28,R1      :Set option into PASCAL buffer
        AHI     R1,$A32         :Bump PASCAL BUFFER ptr
        AHI     R3,PVTLEN       :Bump PVT ptr
        SIS     R0,1            :drop count
        JG      LVLOP1          :loop through PVTs
        J       PSCOMP          :Good Return
:
:       LVOL Set Options
:
LVSETO  HS      0
        L       R6,ARG2,R11     :R6 = Option byte
        CLHI    R6,3            :Within valid range?
        JLE     LVSET8
        J       PSFAIL          :Too large, FAILURE
LVSET8  L       R7,ARG1,R11     :R7 = Physical Volume index
        CLH     R7,NUMPVT,,     :Valid PV index?
        JL      LVSET9
        J       PSFAIL          :No, FAILURE
LVSET9  MH      R7,SIZPVT,,     :R7 = PV displacement
        LA      R7,PVTS,R7,     :R7 -> PV displacement
        LH      R6,LVSETT,R6,R6 :R6 -> option handler
        J       LVSETT,R6       :handle option

LVSETT  HS      0
        HC      LVCLR-LVSETT    :Clear previous options
        HC      LVSRO-LVSETT    :Set read only
        HC      LVSWO-LVSETT    :Set write only
        HC      LVSUN-LVSETT    :Set unavailable

LVCLR   LIS     R0,PVTSDO
        RBT     R0,PVTFLG,R7    :Reset unavailable
        LIS     R0,PVTRO
        RBT     R0,PVTFLG,R7    :Reset read only
        LIS     R0,PVTWO
        RBT     R0,PVTFLG,R7    :Reset write only
        J       PSCOMP          :Good return
LVSRO   LIS     R0,PVTRO        :Set read only
        JFS     LVSETC
LVSWO   LIS     R0,PVTWO        :Set write only
        JFS     LVSETC
LVSUN   LIS     R0,PVTSDO       :Set unavailable
LVSETC  SBT     R0,PVTFLG,R7
        J       PSCOMP          :Good return
:
:       LVOL Copy
:
LVCOPY  HS      0
        JAL     R4,LVCHKI       :Verify that Init is complete
        JAL     R4,GETLRE       :Allocate an LRE
        JAL     R4,LVSETB       :Set PASCAL ptrs into LRE
        LIS     R0,LRECOP       :Indicate COPY operation
        SBT     R0,LREFLG,R6    :...
        L       R0,$A16,R11     :R0 = "from" physical device
        CLH     R0,NUMPVT,,     :Valid PV index?
        JL      LVCOPZ
        J       LVNONE          :No, error
LVCOPZ  SBT     R0,LREPVT,R6    :Indicate PV for read req
        LIS     R0,0            :Indicate read operation first
        STB     R0,LREDOP,R6    :Set disk op code for later
        JAL     R4,QUELRE       :Queue request for processing
        LIS     R4,1
        AM      R4,CTCOPY,,     :INCREMENT # OF COPY LRE COUNT
        J       LVEXIT          :Good Return
:
:       LVOL Read
:
LVREAD  HS      0
        JAL     R4,LVCHKI       :Verify Init complete
        JAL     R3,SETLRE       :Set up R6 -> LRE
        LIS     R0,0            :Indicate read operation
        STB     R0,LREDOP,R6    :Set disk op code into LRE
        LIS     R0,LREANY       :Any PV can handle request
        SBT     R0,LREFLG,R6    :Set bit
        LIS     R0,PVTWO        :Write only flag
        JFS     LVWRI2          :Join common
:
:       LVOL Write
:
LVWRIT  HS      0
        JAL     R4,LVCHKI       :Verify that init is complete
        JAL     R3,SETLRE       :Set up LRE and PVTs
        LIS     R0,1            :Indicate write operation
        STB     R0,LREDOP,R6    :Set disk op code into LRE
        LIS     R0,PVTRO        :Read only flag
LVWRI2  JAL     R4,PVTEXC       :Exclude read only volumes
        L       R4,LREPVT,R6    :R4 = drives to write?
        JN      LVWRI3
        J       LVNONE          :None for this request
LVWRI3  JAL     R4,QUELRE       :Queue request for processing
:       J       LVEXIT          :Good Return

:
:       LVEXIT - Start Requests (if any) and exit nucleus
:
LVEXIT  HS      0
        JAL     R3,LVFIND       :Find and start any requests
        J       IOEXIT          :Exit nucleus
:
:       LVNONE - No drives up for a request
:
LVNONE  HS      0
        JAL     R4,FRELRE       :Free up LRE
        J       PSFAIL          :indicate FAILURE to PASCAL
:
:       LVOL Subroutines
:


:
:       SETLRE - Set up LVOL Request Element
:               R0, R1, R4 and R7 are destroyed
:               R3 -> Return Address
:               R5 = Logical Volume Number on entry
:               R6 -> LRE on return
:               R8 -> Process Header
:               R10 -> PASCAL Data Buffer
:               R11 -> PASCAL Parm Block
:
SETLRE  HS      0
        JAL     R4,GETLRE       :Allocate an LRE
        JAL     R4,LVSETB       :Set ptrs into LRE
        LR      R1,R5           :R1 = Logical Volume Number
        LA      R7,PVTS-PVTLEN,, :Setup PVT ptr
SETLRL  JAL     R4,FNDPVT       :Find first/next PVT
        LR      R7,R7           :End of PVTs?
        JER     R3              :yes, done
        LB      R0,PVTNUM,R7    :R0 = PVT index
        SBT     R0,LREPVT,R6    :Indicate PVT in LRE
        JBS     SETLRL          :Loop for next PVT

:
:       LVFIND - Find requests that can be started
:               R0, R1, R2, R4, R5 and R9 are work registers
:               R3 -> Return Address
:               R6 -> LRE (internally)
:               R7 -> PVT (internally)
:               R8 -> Process header (internally)
:               R11 -> Pascal Parm block (internally)
:
LVFIND  HS      0
        LIS     R0,LVINIS       :LVOL init just started?
        TBT     R0,LVFLAG,,     :Test global flag
        JE      LVFIN0          :No, skip to normal search
        LA      R7,PVTS,,       :R7 -> PVT
        LIS     R1,PVTBUS       :PVT busy flag
        LIS     R4,0            :R4 = 0
LVFI01  TBT     R1,PVTFLG,R7    :Is this Physical Volume in use?
        JNR     R3              :Yes, return, wait to complete
        STB     R4,PVTFLG,R7    :Clear PVT flag
        AHI     R7,PVTLEN       :R7 -> next PVT
        CLI     R7,ENDPVT       :End of PVTs?
        JLBS    LVFI01          :No, loop through all PVTs
        RBT     R0,LVFLAG,,     :Clear LVINIS (INIT just started flag)
:
:       Main Physical Volume search loop
:
LVFIN0  LIS     R0,0            :PVT index
        ST      R0,COPOUT,,     :INIT THIS FLAG FOR PV DOWN ROUTINE
        LA      R7,PVTS,,       :R7 -> PVT in question

LVFIN1  L       R6,CTCOPY,,     :ANY COPY REQUEST ON LRE QUEUE?
        JE      LVFINE          :NO, SKIP TO TEST LVOL INIT
        LIS     R6,0
        ST      R6,COPYLC,,     :CLEAR COPY REQUEST LOCATION POINTER
        LIS     R4,LRECOP       :COPY REQUEST BIT
        LA      R1,LREQUE-LRENXT,,  :R1 = NEXT NEXT LRE
FINDCP  L       R1,LRENXT,R1    :R1 = NEXT LRE
        JNFS    FINDC1          :
        JAL     R10,CRASH       :END OF QUEUE, SHOULD NOT GET THERE
        BC      0,0,4*R3,31     :
FINDC1  AIS     R6,1            :UPDATE LRE POSITION POINTER
        TBT     R4,LREFLG,R1    :COPY TYPE REQUEST?
        JE      FINDCP          :NO, LOOK THE NEXT LRE
        ST      R6,COPYLC,,     :YES, STORE THE LOCATION OF THIS COPY LRE

LVFINE  LIS     R1,PVTBUS       :PVT busy flag
        TBT     R1,PVTFLG,R7    :Is this Physical Volume in use?
        JN      LVFIN8          :In use, skip it for now
        LIS     R1,PVTGOD       :PV going down?
        TBT     R1,PVTFLG,R7    :Is this Physical Volume going down?
        JE      LVFGOD          :No, skip
        L       R6,CTCOPY,,     :FIFO?
        JN      LVFN89          :YES, TAKE IT OUT RIGHT AWAY
:
:       Handle Physical Volumes going down cleanup
:
        RBT     R1,PVTFLG,R7    :Only handle once
LVFGOS  LA      R6,LREQUE-LRENXT,,      :R6 -> LRE Queue
LVFGOL  L       R6,LRENXT,R6    :R6 -> first/next LRE
        JE      LVFIN8          :Handle rest of PVTs
        TBT     R0,LREPVT,R6    :Is this PV in request?
        JEBS    LVFGOL          :No, on to next LRE
        RBT     R0,LREPVT,R6    :Take out of request
        LB      R1,LRERNO,R6    :Another request in progress?
        JNBS    LVFGOL          :Yes, on to next LRE
        L       R1,LREPVT,R6    :Any other requests to start?
        JNBS    LVFGOL          :Yes, on to next LRE
LVFBAD  LIS     R0,LRE1OK       :At least one good request?
        TBT     R0,LREFLG,R6    :prior to disk going down?
        JN      LVFGOK          :Yes, skip
        LIS     R1,FAIL         :No, setup for FAILURE status
LVFGOK  L       R11,LREPPB,R6   :R11 -> Pascal parm block
       IF       XMEMRY
        L       R10,LREPHP,R6   :R10 -> PHR for this request
        LHL     R10,XMPSET+4,R10        :R10 -> XM MAC Set
        JAL     R4,XMCURR       :Make this Process's MAC set current
       EI       :XMEMRY
        LIS     R4,LRECOP       :COPY REQUEST BIT
        TBT     R4,LREFLG,R6    :COPY TYPE REQUEST?
        JE      LVFGOM          :NO, SKIP
        LCS     R4,1            :
        AM      R4,CTCOPY,,     :DECREMENT # OF COPY LRE COUNT
LVFGOM  STM     R0,CPRSAV,,     :SAVE REGISTERS
        LA      R3,CPERR1,,     :ERROR MSG FOR PV DOWN
        JAL     R6,CONMSG       :PRINT IT
        LM      R0,CPRSAV,,     :RESTORE REGISTERS

        STH     R1,STATUS,R11   :Set status for PASCAL
        L       R8,LREPHP,R6    :R8 -> process header block
        JAL     R4,DEQLRE       :Take LRE off chain
        JAL     R4,FRELRE       :Give back LRE
        LR      R11,R7          :Save R7
        JAL     R9,RDYENT       :Startup process
        LR      R7,R11          :Restore R7 -> PVT
        LB      R0,PVTNUM,R7    :Restore PVT index
        L       R6,COPOUT,,     :COME FROM LVFN88?
        JE      LVFGOS          :NO, Loop to check all LREs
        LIS     R6,0
        ST      R6,COPOUT,,     :RESTORE THE INIT VALUE
        J       LVFIN8          :GET OTHER PV
:
:       Scan LRE Queue for request to start
:
LVFGOD  LIS     R1,PVTDOW       :PV down
        TBT     R1,PVTFLG,R7    :Is PV down?
        JN      LVFN88          :Yes, CHECK FOR COPY REQUEST
        LA      R1,LREQUE-LRENXT,,      :R1 -> LRE Queue
        LIS     R6,0            :R6 -> best LRE if any
        ST      R6,LREPOS,,     :CLEAR LRE POSITION POINTER
:
:       Select the best LRE to start (if any)
:
LVFIN2  L       R1,LRENXT,R1    :R1 -> next LRE
        JE      LVFIN7          :End of Queue, skip
        LIS     R4,1            :
        AM      R4,LREPOS,,     :UPDATE THE LRE POSITION IN QUEUE
        TBT     R0,LREPVT,R1    :Is this PVT in request?
        JEBS    LVFIN2          :no, check next LRE
        LIS     R4,LVINII       :LVOL init in progress?
        TBT     R4,LVFLAG,,     :Test global flag
        JEFS    LVFI25          :No, skip
        LIS     R4,LREINI       :LRE init flag
        TBT     R4,LREFLG,R1    :Is this request an init?
        JE      LVFIN2          :No, ignore for now
LVFI25  LB      R4,LRERNO,R1    :At least one request started?
        JEFS    LVFIN3          :No, skip
        LIS     R4,LREINI       :INIT type request?
        TBT     R4,LREFLG,R1
        JN      LVFIN2          :Yes, one INIT type at a time
        LIS     R4,LREANY       :ANY type request (eg READ)?
        TBT     R4,LREFLG,R1    
        JN      LVFIN2          :Yes, one ANY may be enough
LVFIN3  L       R4,CTCOPY,,     :ANY COPY REQUEST ON LRE QUEUE?
        JE      LVFI3A          :NO, GO ON AS IN THE OLD DAYS
        L       R4,LREPOS,,     :THIS LRE'S POSITION ON QUEUE
        L       R6,COPYLC,,     :THE FIRST COPY LRE POSITION ON QUEUE
        CR      R4,R6           :IS THIS LRE AFTER THE COPY LRE
        JG      LVFIN8          :YES, SO SKIP TO NEXT PTV
LVFI37  LR      R6,R1           :R6 HAS THE NEW LRE
        J       LVFIN7          :GO TO START THE REQUEST
LVFI3A  LR      R6,R6           :Did we have a previous LRE
        JE      LVFIN6          :No, choice is easy
:
:       Compare Arm movements (between two requests)
:
       IF       XMEMRY
        L       R10,LREPHP,R1   :R10 -> PHR for this request
        LHL     R10,XMPSET+4,R10        :R10 = XM MAC set
        JAL     R4,XMCURR       :Make this processes MAC set current
       EI       :XMEMRY
        L       R4,LREPPB,R1    :R4 -> PASCAL Parms
        L       R4,ARG1,R4      :R4 = sector number
        S       R4,DPSECT,R7    :minus current
        JGFS    LVFIN4          :Skip if positive
        LR      R2,R4           :R2 = difference
        LIS     R4,0            :Get a zero
        SR      R4,R2           :R4 = positive difference
LVFIN4  HS      0
       IF       XMEMRY
        L       R10,LREPHP,R6   :R10 -> PHR for this request
        LHL     R10,XMPSET+4,R10        :R10 = XM MAC set
        JAL     R4,XMCURR       :Make this processes MAC set current
       EI       :XMEMRY
        L       R5,LREPPB,R6    :R6 -> Previous req Parms
        L       R5,ARG1,R5      :R5 = sector number
        S       R5,DPSECT,R7    :minus current
        JGFS    LVFIN5          :Skip if positive
        LR      R2,R5           :R2 = difference
        LIS     R5,0            :Get a zero
        SR      R5,R2           :R5 = positive difference
LVFIN5  CLR     R4,R5           :New vs Old difference
        JGE     LVFIN2          :Old difference better
        LB      R4,LREPAS,R6    :Previous Passed over count
        AIS     R4,1            :Bump
        CLHI    R4, $A 10       :Passed over ten times?
        JGE     LVFIN2          :Yes, thats enough
        STB     R4,LREPAS,R6    :Restore bumped passed over
        LIS     R4,1            :Get a one
        AM      R4,LVPASS,,     :Bump global count
LVFIN6  LR      R6,R1           :R6 -> new best LRE
        J       LVFIN2          :Loop to find better LRE
:
:       Start Request if found
:
LVFIN7  LR      R6,R6           :Did we find a request?
        JEFS    LVFIN8          :No, skip
        RBT     R0,LREPVT,R6    :Indicate PV no longer part of request
        LIS     R1,0            :Get a zero
        STB     R1,PVTLER,R7    :Clear errs per request count
        ST      R6,PVTLRE,R7    :PVT -> LRE
        JAL     R4,LVSTAR       :Start request
        JFS     LVFIN9          :Error return from LVSTAR
:
:       On to Next PVT (or return if at end of PVTs)
:
LVFIN8  AIS     R0,1            :Incriment PVT index
        AHI     R7,PVTLEN       :R7 -> next PVT
        CLI     R7,ENDPVT       :End of PVTs for this request?
        JL      LVFIN1          :Check out next PVT
        JR      R3              :Return
:
:       Error in Starting Disk Request
LVFIN9  HS      0
        L       R11,LREPPB,R6   :R11 -> Pascal Parameter Block
        STM     R0,CPRSAV,,     :SAVE REGISTERS CONTENT
        LA      R3,CPERR3,,     :ADDRESS OF ERROR MSG
        JAL     R6,CONMSG       :PRINT IT
        LM      R0,CPRSAV,,     :RESTORE REGISTERS CONTENT
        LIS     R4,LRECOP       :COPY REQUEST BIT
        TBT     R4,LREFLG,R6    :COPY TYPE REQUEST?
        JE      LVFINZ          :NO, SKIP
        LCS     R4,1            :
        AM      R4,CTCOPY,,     :DECREMENT # OF COPY LRE COUNT
LVFINZ  LIS     R4,PRGERR       :R4 = code for Program Error
        STH     R4,STATUS,R11   :Indicate Program error to Pascal
        L       R8,LREPHP,R6    :R8 -> Process Header Record
        JAL     R4,DEQLRE       :Pull LRE off chain
        JAL     R4,FRELRE       :Free up LRE
        JAL     R9,RDYENT       :Put Process back on queue
        J       LVFIND          :Go look for more to do
LVFN88  L       R6,CTCOPY,,     :ANY COPY REQUEST ON LRE QUEUE?
        JE      LVFIN8          :NO, ON TO NEXT PV
LVFN89  LA      R6,LREQUE-LRENXT,,   :R6 -> LRE QUEUE
        L       R6,LRENXT,R6    :R6 -> FIRST/NEXT LRE
        LIS     R4,LRECOP       :COPY REQUEST?
        TBT     R4,LREFLG,R6
        JE      LVFN91          :NO, SKIP
        LIS     R4,LVCOPI
        TBT     R4,LVFLAG,,     :COPY IN PROGRESS?
        JN      LVFIN8          :WAIT TIL IT COMES BACK
        LIS     R4,1
        ST      R4,COPOUT,,            :FIFO QUEUE
        LIS     R1,FAIL
        J       LVFGOK
LVFN91  RBT     R0,LREPVT,R6    :TAKE OUT OF REQUEST
        LB      R1,LRERNO,R6    :ANOTHER REQUEST IN PROGRESS?
        JN      LVFIN8
        L       R1,LREPVT,R6    :ANY OTHER REQUEST TO START?
        JN      LVFIN8          :YES, GO TO NEXT PVT
        LIS     R4,1
        ST      R4,COPOUT,,     :TO INDICATE A FIFO QUEUE
        J       LVFBAD
:
:       LVSETU - Set up common disk parameters
:               R0, R1 and R2 are work registers
:               R4 -> Return address
:               R6 -> LRE (internally)
:               R7 -> PVT (with Disk Parameter Block in front)
:
LVSETU  HS      0
        L       R6,PVTLRE,R7    :R6 -> LRE
        L       R0,LREPDB,R6    :PASCAL Data Buffer
        ST      R0,DPADDR,R7    :Set data buffer pointer
        LB      R0,LREDOP,R6    :R0 = disk operation code
        STH     R0,DPOPER,R7    :Store operation code
        LA      R0,LVFINI       :LVOL I/O completion routine
        ST      R0,DPACT,R7     :Set for driver to call later
        L       R1,LREPPB,R6    :R1 -> PASCAL Parm Block
        L       R2,ARG1,R1      :R2 = starting sector number
        L       R1,ARG2,R1      :R1 = transfer length
        LIS     R0,LREINI       :INIT function flag
        TBT     R0,LREFLG,R6    :INIT operation?
        JE      LVSET2          :Skip if not INIT
        LHI     R1,$A 256       :INIT transfer length
        LIS     R2,0            :INIT -> Sector zero
LVSET2  ST      R2,DPSECT,R7    :Set sector number
        ST      R1,DPLEN,R7     :Set transfer length
        LIS     R0,DSKDEV       :Disk device type
        STH     R0,DPTYPE,R7    :Set into parameter block
        JR      R4              :Return

:
:       FNDPVT - Scan PVTs for candidate
:               R0 is a work register
:               R1 = Logical Volume Number
:               R4 -> Return Address
:               R7 -> Previous PVT
:
FNDPVT  HS      0
        AHI     R7,PVTLEN       :R7 -> Current PVT
        CLI     R7,ENDPVT       :At end of PVTs?
        JLFS    PVTOK           :R7 pointing at good PVT
        LIS     R7,0            :indicate end
        JR      R4              :Return
PVTOK   CLB     R1,PVTLOG,R7    :Logical Volume Number match?
        JNBS    FNDPVT          :No, continue search?
        LIS     R0,PVTDOW       :Volume down bit
        TBT     R0,PVTFLG,R7    :Is this physical volume down?
        JGBS    FNDPVT          :Down, on to next PVT
        LIS     R0,PVTSDO       :Unavailable bit
        TBT     R0,PVTFLG,R7    :Has this PVT been set to down?
        JG      FNDPVT          :Set to unavailable, on to next
        JR      R4              :Return

:
:       LVCHKI - Check if Initialization already performed
:               R0 is a work register
:               R4 -> Return Adress
:
LVCHKI  HS      0
        LIS     R0,LVINIC       :Initialization performed flag
        TBT     R0,LVFLAG,,     :Check global flag
        JNR     R4              :Init complete -> Good Return
        J       PSBUSY          :No, BUSY


:
:       LVSETB - Set up Block ptrs in LRE
:               R6 -> LRE (on entry)
:               R8 -> PASCAL Process Header Block
:               R10 -> PASCAL Data Buffer (on entry)
:               R11 -> PASCAL Parm Block (on entry)
:
LVSETB  HS      0
        ST      R8,LREPHP,R6    :PASCAL Process Header ptr
        ST      R10,LREPDB,R6   :PASCAL Data Buffer
        ST      R11,LREPPB,R6   :PASCAL Parm Block
        JR      R4              :Return
:
:       GETLRE - allocate an LVOL Request Element
:               R0 is a work register
:               R4 -> Return address
:               R6 -> Allocated LRE (on return)
:
GETLRE  HS      0
        LA      R6,LRES,,       :R6 -> LRE pool
GETLR1  LIS     R0,LREUSE       :R0 = LRE in use flag
        TBT     R0,LREFLG,R6    :Is LRE in use?
        JEFS    GOTLRE          :Got one
        AHI     R6,LRELEN       :R6 -> next LRE
        CLI     R6,ENDLRE       :At end of LREs?
        JLBS    GETLR1          :No, look at this LRE
        JAL     R10,CRASH       :No more LREs, crash
        BC      0,0,0,31
GOTLRE  LIS     R0,0            :Get a zero
        ST      R0,LREPVT,R6    :Clear PVT area
        ST      R0,LRENXT,R6    :Clear ptr
        STB     R0,LRERNO,R6    :Clear request outstanding count
        STB     R0,LREPAS,R6    :Clear request passed over count
        STB     R0,LREFLG,R6    :Clear flag byte
        LIS     R0,LREUSE       :LRE in use flag
        SBT     R0,LREFLG,R6    :Indicate LRE in use
        JR      R4              :Return with LRE
:
:       FRELRE - free up an LVOL Request Element
:               R0 is work register
:               R4 -> Return address
:               R6 -> LRE to be freed
:
FRELRE  HS      0
        LIS     R0,LREUSE       :LRE in use flag
        RBT     R0,LREFLG,R6    :Clear in use flag
        JR      R4              :Return
:
:       PVTEXC - Exclude a physical volume from request
:               R0 = bit which if on causes exclusion
:               R4 -> Return address
:               R6 -> LRE to be processed
:
PVTEXC  HS      0
        LIS     R1,0            :PVT number
        LA      R7,PVTS,,       :R7 -> PVT being processed
PVTEX1  TBT     R1,LREPVT,R6    :Has this PVT been selected?
        JEFS    PVTEX2          :No, skip
        TBT     R0,PVTFLG,R7    :Should we exclude this PVT?
        JEFS    PVTEX2          :No, skip
        RBT     R1,LREPVT,R6    :Exclude this PVT from request
PVTEX2  AIS     R1,1            :Bump PVT number
        AHI     R7,PVTLEN       :Bump PVT ptr
        CLI     R7,ENDPVT       :At end of PVTs?
        JLBS    PVTEX1          :No, loop back
        JR      R4              :Return
:
:       QUELRE - Put LRE on end of LRE queue
:               R1 and R2 are work registers
:               R4 -> Return Address
:               R6 -> LRE to be queued
:
QUELRE  HS      0
        LA      R1,LREQUE-LRENXT,,   :R1 -> LRE queue
QUELR1  L       R2,LRENXT,R1    :R2 -> first/next LRE
        JEFS    QUELR2          :Skip if at end
        LR      R1,R2           :R1 -> previous LRE
        JBS     QUELR1          :Loop back for next LRE
QUELR2  ST      R6,LRENXT,R1    :Chain LRE as last
        JR      R4              :Return

:
:       DEQLRE - Take an LRE off LRE queue
:               R1 and R2 are work registers
:               R4 -> Return Address
:               R6 -> LRE to be de-queued
:
DEQLRE  HS      0
        LA      R1,LREQUE-LRENXT,,      :R1 -> LRE queue
DEQLR1  L       R2,LRENXT,R1    :R2 -> first/next LRE
        CR      R2,R6           :Is this the LRE being dequeued?
        JEFS    DEQLR2          :Skip if yes
        LR      R1,R2           :R1 -> previous LRE
        JNBS    DEQLR1          :Loop back till we find the LRE
        JAL     R10,CRASH       :Something screwed up
        BC      0,0,0,31
DEQLR2  L       R2,LRENXT,R6    :Get next LRE
        ST      R2,LRENXT,R1    :Unchain LRE
        JR      R4              :Return
:
:       LVSTAR - Start a Disk Request (to driver)
:               R4 -> Return Address
:               R6 -> LRE (internally)
:               R7 -> PVT (on entry)
:
LVSTAR  HS      0
        STM     R0,PVTSAV,R7    :Save all GPRs
        LIS     R0,PVTBUS       :PVT busy flag
        SBT     R0,PVTFLG,R7    :Set PVT to busy status
        L       R6,PVTLRE,R7    :R6 -> LRE
       IF       XMEMRY
        L       R10,LREPHP,R6   :R10 -> PHR for this request
        LHL     R10,XMPSET+4,R10        :R10 = XM MAC set
        JAL     R4,XMCURR       :Make this processes MAC set current
       EI       :XMEMRY
        LA      R4,PVTNRD,R7    :R4 -> read count
        LB      R0,LREDOP,R6    :Driver op code
        JEFS    LVSTA0          :Skip if read
        LA      R4,PVTNWT,R7    :R4 -> write count
LVSTA0  LIS     R0,1            :R0 = 1
        AM      R0,0,R4         :Bump read or write count
        LIS     R0,LRECOP       :Request is copy flag
        TBT     R0,LREFLG,R6    :Is request a COPY?
        JEFS    LVSTA1          :No, skip
        LIS     R0,LVCOPI       :Copy in progress flag
        SBT     R0,LVFLAG,,     :Set it
LVSTA1  HS      0
        LB      R0,LRERNO,R6    :R0 = requests outstanding
        AIS     R0,1            :Now one more
        STB     R0,LRERNO,R6    :Restore
        LB      R0,LREDOP,R6    :R0 = Driver Op Code
        JAL     R4,LVSETU       :Set up Disk Driver parms
        LR      R1,R7           :R1 -> Parms for DTGO
        JAL     R4,DTGO         :Start Disk Driver
        JNFS    LVSTA2          :Some error
        LM      R0,PVTSAV,R1    :Restore GPRs
        J       2,R4            :Return
:
:       Error on Start of Disk Request
:
LVSTA2  LIS     R2,PVTBUS       :PVT Busy flag
        RBT     R2,PVTFLG,R1    :PVT is not busy
        LB      R2,LRERNO,R6    :R2 = requests outstanding
        SIS     R2,1            :Drop count
        STB     R2,LRERNO,R6    :Re-store
        LIS     R0,LRECOP
        TBT     R0,LREFLG,R6
        JEFS    LVSTA3
        LIS     R0,LVCOPI
        RBT     R0,LVFLAG,,
LVSTA3  LM      R0,PVTSAV,R1    :Restore GPRs
        JR      R4              :Return (error)
:
:       LVFINI - Called from Disk Driver when request finished
:               R1 -> PVT (and disk driver parm block) on entry
:               R3 is a work register
:               R6 -> LRE (internally)
:               R7 -> PVT (internally)
:               R11 -> PASCAL parm block (internally)
:               R15 -> Return Address (in Disk Driver)
:
LVFINI  HS      0
        LR      R7,R1           :R7 -> PVT
        L       R6,PVTLRE,R7    :R6 -> LRE
       IF       XMEMRY
        L       R10,LREPHP,R6   :R10 -> PHR for this request
        LHL     R10,XMPSET+4,R10        :R10 -> XM MAC Set
        JAL     R4,XMCURR       :Make this Process's MAC set current
       EI       :XMEMRY
        L       R11,LREPPB,R6   :R11 -> PASCAL Parm Block
        LIS     R3,PVTBUS       :PVT busy flag
        RBT     R3,PVTFLG,R7    :PV is no longer busy
        LB      R3,LRERNO,R6    :Requests outstanding
        SIS     R3,1            :Drop count
        STB     R3,LRERNO,R6    :Restore
        LIS     R3,LRECOP       :Copy request bit
        TBT     R3,LREFLG,R6    :Copy type request?
        JE      LVFNOC          :No, skip
:
:       COPY Complete
:
        JAL     R3,LVFERC       :Check for disk error
        LIS     R0,0
        LB      R3,LREDOP,R6    :R3 = op code
        JNFS    LVFCOW          :Skip if write part
        LIS     R3,1            :Indicate write operation
        STB     R3,LREDOP,R6    :Second half of copy
        L       R3,$A20,R11     :R3 = "to" PV index
        SBT     R3,LREPVT,R6    :Set for request
        LIS     R3,LVCOPI       :COPY IN PROGRESS FLAG
        RBT     R3,LVFLAG,,     :CLEAR IT
        J       LVFEND          :That's all
LVFCOW  LIS     R3,LVCOPI       :COPY in progress flag
        RBT     R3,LVFLAG,,     :Clear it
        LCS     R3,1
        AM      R3,CTCOPY,,     :DECREMENT # OF COPY LRE COUNT
        J       LVFSST          :Set STATUS and complete
:
:       INIT Request Complete
:
LVFNOC  HS      0
        LIS     R3,LREINI       :INIT request bit
        TBT     R3,LREFLG,R6    :Is this an INIT?
        JE      LVFNOI          :No skip
        JAL     R3,LVFERC       :Check for disk errors
        LIS     R0,0
        STB     R0,PVTFLG,R7    :Clear random flags
        L       R3,LREPDB,R6    :R3 -> PASCAL data buffer
        L       R4,0,R3         :R4 = Logical Volume Number
        STB     R4,PVTLOG,R7    :Setup PVT
        L       R4,4,R3         :R4 = Incarnation Number
        STB     R4,PVTINC,R7    :Setup PVT
        LIS     R4,1            :Get a one
        AM      R4,ARG2,R11     :Bump PV count
        L       R3,LREPVT,R6    :R3 = PVs still to go
        JN      LVFEND          :More to handle
        LIS     R3,LVINIC       :INIT complete flag
        SBT     R3,LVFLAG,,     :Indicate INIT complete
        LIS     R3,LVINII       :INIT in progress flag
        RBT     R3,LVFLAG,,     :Clear, INIT no longer in progress
:
:       Normal Request Complete
:
LVFNOI  HS      0
        JAL     R3,LVFERC       :Check for disk errors
        LIS     R0,0
        LIS     R3,LRE1OK       :At least one good request flag
        SBT     R3,LREFLG,R6    :Set it for later
        LB      R3,LRERNO,R6    :Any operations already started?
        JN      LVFEND          :Yes, defer completion
        L       R3,LREPVT,R6    :More PVs for request?
        JEFS    LVFSST          :No, just set STATUS and complete
        LIS     R3,LREANY       :Any-one type request?
        TBT     R3,LREFLG,R6    :...
        JEFS    LVFEND          :No, start others
LVFSST  STH     R0,STATUS,R11   :Set good status for PASCAL
        L       R8,LREPHP,R6    :R8 -> Process Header
        JAL     R4,DEQLRE       :Dequeue LRE
        JAL     R4,FRELRE       :Free up LRE
        JAL     R9,RDYENT       :Put process back on run queue
LVFEND  JAL     R3,LVFIND       :Start up another request if any
        JR      R15             :Return to Disk Driver
:
:       Check for disk error
:
LVFERC  LHL     R0,DPSTAT,R7    :R0 = ISIS status
        JER     R3              :If ISIS status zero -> no error
        CHI     R0,$a24         :Recoverable error?
        JER     R3              :Return
:
:       Error on Request
:
        STH     R0,PVTSTA,R7    :Save last error status
LVFERB  LIS     R3,1            :Get a one
        AHM     R3,PVTERS,R7    :Bump error count
        LB      R3,PVTLER,R7    :R3 = errors from this request
        AIS     R3,1            :Bump
        STB     R3,PVTLER,R7    :Restore bumped count
        CLHI    R3,$A 25        :Exceeded limit?
        JGFS    LVDOWN          :Declare this volume down
        JAL     R4,LVSTAR       :Re-start next try
        JBS     LVFERB          :Error on start of request
        JR      R15             :Return to Disk Driver
:
:       Disk Volume Down
:
LVDOWN  HS      0
        LIS     R4,PVTDOW       :Physical volume down
        SBT     R4,PVTFLG,R7    :Indicate
        LIS     R4,PVTGOD       :Indicate going down
        SBT     R4,PVTFLG,R7    :to scan other LREs once
        LB      R0,LRERNO,R6    :Any other outstanding reqs?
        JN      LVFEND          :Wait for them to complete
        L       R0,LREPVT,R6    :Any more operations?
        JN      LVFEND          :Yes, try one of them
        LIS     R0,LRECOP       :COPY REQUEST BIT
        TBT     R0,LREFLG,R6    :COPY TYPE REQUEST?
        JE      LVDOWZ          :NO , SKIP
        LCS     R0,1
        AM      R0,CTCOPY,,     :DECREMENT # OF COPY LRE COUNT
LVDOWZ  STM     R0,CPRSAV,,     :SAVE REGISTERS CONTENT
        LA      R3,CPERR2,,     :ADDRESS OF DISK ERROR MSG
        JAL     R6,CONMSG       :PRINT IT
        LM      R0,CPRSAV,,     :RESTORE REGISTERS CONTENT

        LIS     R0,0            :indicate good return
        LIS     R4,LREINI       :An initialize
        TBT     R4,LREFLG,R6    :?
        JEFS    LVDOW2          :no, skip
        LIS     R4,LVINIC       :Init now complete
        SBT     R4,LVFLAG,,     :Set flag
        LIS     R4,LVINII       :INIT in progress flag
        RBT     R4,LVFLAG,,     :Clear, INIT no longer in progress
        J       LVFSST          :Set Init complete
LVDOW2  LIS     R4,LRE1OK       :At least 1 good operation
        TBT     R4,LREFLG,R6    :?
        JN      LVFSST          :Yes, still good complete
        ST      R0,ARG2,R11     :Set ISIS status
        LHL     R0,DPCNST,R7    :Controller status
        ST      R0,STATS2,R11   :Set for PASCAL
        LIS     R0,FAIL         :INDICATE FAILURE
        J       LVFSST          :Complete failure

        EI      :LVNDSK
:
: CRINIT - Initialize the crash device driver
:	Link on R2
:

CRINIT	LIS	R0,0
        STH     R0,ERRFLG,,     :Clear error wait flag
	JR	R2		:Return


: LVINIT - Initialize the LVOL device driver
:

LVINIT  HS      0
        IF      LVNDSK
        LIS     R0,0            :Get a zero
        ST      R0,LREQUE,,     :Clear LRE queue
        ST      R0,LVPASS,,     :Clear passed over count
        ST      R0,CTCOPY,,     :CLEAR # OF COPY REQUEST COUNT
        STH     R0,LVFLAG,,     :Clear global LVOL flag
        LA      R1,PVTS,,       :R1 -> Physical Volume Tables
        LIS     R3,0            :R3 = PVT index
LVINI1  STB     R3,PVTNUM,R1    :init PVT index
        AIS     R3,LVPDK0       :Plus disk device number
        STH     R3,DPUNIT,R1    :Set as unit number
        STH     R0,DPTYPE,R1    :Set for disk device
        STB     R0,PVTFLG,R1    :init PVT flag
        STH     R0,PVTERS,R1    :init PVT error count
        ST      R0,PVTNRD,R1    :init PVT read count
        ST      R0,PVTNWT,R1    :init PVT write count
        SIS     R3,3            :BUMP index
        AHI     R1,PVTLEN       :bump ptr
        CLI     R1,ENDPVT       :at end of PVTs?
        JL      LVINI1          :clear all PVTs
        LA      R3,LRES,,       :R3 -> LRE area
LVINI2  STH     R0,0,R3         :Clear a half word
        AIS     R3,2            :Bump ptr
        CLI     R3,ENDLRE       :End of LRE area?
        JLBS    LVINI2          :No, loop back
        EI      :LVNDSK
        JR      R2              :Return

PPINIT  HS      0               
        IF      XPIPE

        IF      XMEMRY
        LHI     R1,4C           :THE STORAGE SIZE OF A MAC SET
        LHI     R3,NMACSS       :THE # OF MAC SETS USER WANTS
        AIS     R3,3            :EXTRA MAC SETS FOR DISK LOAD
        MHR     R1,R3           :GET THE OFFSET TO PIPE MAC SET
        LA      R3,EMMAC0,,     :GET THE START OF MAC SETS IN SEG E
        AR      R1,R3
        AIS     R1,8            :NOW WE GET THE ADDRESS OF PIPE
                                :MAC SET SEG 2
        L       R1,0,R1         :GET THIS SEGMENT CONTENT
        SRL     R1,8
        NHI     R1,0FFF         :NOW R1 HAS THE BASE PAGE VALUE
        ST      R1,PPMAC2,,     :SAVE IT
        EI      :XMEMRY

        LHI     R1,NPIPE-1      :NUMBER OF PIPES
        LA      R3,PIPTBL+(NPIPE-1)*PPSIZE,,
                                :ADDRESS OF PIPE INFO TABLE END
        LIS     R0,0            :GET 0
        LCS     R4,1            :GET -1
PPINT1  STH     R3,PPENT,R1,R1  :SAVE PIPE TABLE ADDRESS
        STH     R0,PIPNUM,R3    :SET PIPE TO ZERO (UNUSED)
        STH     R4,PIPOP,R3     :SET NO PIPE OPERATION PENDING
        RBT     R1,PIPESD,,     :SET NO SEND OPERATION PENDING
        RBT     R1,PIPERC,,     :SET NO RECEIVE OPERATION PENDING
        ST      R0,PPSLFT,R3    :SET NO CHARS TO SEND
        ST      R0,PPRLFT,R3    :SET NO CHARS TO READ
        SHI     R3,PPSIZE       :POINT TO PREVIOUS ENTRY
        SIS     R1,1            :DECREMENT PIPE COUNTER
        JGE     PPINT1          :LOOP FOR ALL PIPES
        LIS     R0,PIPDEV       :PIPE DEVICE #
        SBT     R0,DVREQ,,      :TELL NUCIO WE WANT TO BE PULLED
        EI      :XPIPE
        JR      R2

PPSTRT  HS      0
        IF      XPIPE
        LR      R10,R1          :COPY PASCAL BUFFER ADDRESS
        LR      R11,R2          :COPY PASCAL PARAM BLOCK ADDRESS
        LHL     R6,OPER,R11     :GET OPERATION NUMBER
        CLHI    R6,3            :4 OPERATIONS ARE DEFINED
        JG      PSPRGE          :TOO HIGH, PROGRAM ERROR
        CLHI    R5,NPIPE        :PIPE NUMBER OUT OF RANGE?
        JGE     PPBDUN          :OUT OF RANGE -- PIPE NUMBER DOES NOT EXIST
        LHL     R13,PPENT,R5,R5 :GET PIPE TABLE ENTRY ADDRESS
        LH      R6,PIPETB,R6,R6 :GET ROUTINE OFFSET
        J       PIPETB,R6       :HANDLE PIPE OPERATION 

PIPETB  HS      0
        HC      PPSEND-PIPETB   :OPERATION 0 - SEND START
        HC      PPRECV-PIPETB   :OPERATION 1 - RECEIVE START
        HC      PPDONS-PIPETB   :OPERATION 2 - DONE SEND
        HC      PPDONR-PIPETB   :OPERATION 3 - DONE RECEIVE


PPSEND  HS      0
        SBT     R5,PIPESD,,     :SET SEND REQUEST BIT FOR PIPE
        JE      PPSDOK          :OK IF NO SEND IN PROGRESS
        L       R0,PPSPHD,R13   :OTHERWISE CHECK IF THE SAME PROCESS
        CR      R0,R8           :ARE THE TWO PHDS SAME?
        JN      PSBUSY          :NO, RETURN BUSY

PPSDOK  HS      0
        
        IF      XMEMRY
        LR      R6,R1
        JAL     R4,PIPCOV
        LR      R1,R6
        LR      R6,R2
        JAL     R4,PIPCOV
        LR      R2,R6
        EI      :XMEMRY

        ST      R1,PPSPTR,R13   :SAVE SEND BUFFER POINTER
        ST      R2,PPSPRM,R13   :SAVE SEND PARAM ADDRESS
        ST      R8,PPSPHD,R13   :SAVE SEND PROCESS PHD
        L       R0,ARG1,R11     :GET # OF CHARS TO SEND
        ST      R0,PPSLFT,R13   :SAVE IT
        J       IOEXIT          :RETURN

PPRECV  HS      0
        SBT     R5,PIPERC,,     :SET RECEIVE REQUEST BIT FOR PIPE
        JE      PPRCOK          :OK IF NO READ IN PROGRESS
        L       R0,PPRPHD,R13   :OTHERWISE CHECK IF THE SAME PROCESS
        CR      R0,R8           :ARE THE TWO PHDS SAME?
        JN      PSBUSY          :NO, RETURN BUSY

PPRCOK  HS      0
      
        IF      XMEMRY
        LR      R6,R1
        JAL     R4,PIPCOV
        LR      R1,R6
        LR      R6,R2
        JAL     R4,PIPCOV
        LR      R2,R6
        EI      :XMEMRY

        ST      R1,PPRPTR,R13   :SAVE RECEIVE BUFFER POINTER
        ST      R2,PPRPRM,R13   :SAVE RECEIVE PARAM ADDRESS
        ST      R8,PPRPHD,R13   :SAVE RECEIVE PROCESS HDR
        L       R0,ARG1,R11     :GET # OF CHARS TO RECEIVE
        ST      R0,PPRLFT,R13   :SAVE IT
        J       IOEXIT          :RETURN

PPDONS  HS      0
        RBT     R5,PIPESD,,     :CLEAR SEND BIT FOR PIPE
        J       PSCOMP

PPDONR  HS      0
        RBT     R5,PIPERC,,     :CLEAR RECEIVE BIT FOR PIPE
        J       PSCOMP          :RETURN 'COMPLETE' STATUS

PIPCOV  HS      0
        
        IF      XMEMRY
        LHL       R10,XMPSET+4,R8  :MAC SET # FOR THIS PROCESS
        LHI     R9,4C            :
        MHR     R9,R10
        LA      R10,EMMAC0,,     :START OF MAC SETS AREA
        AR      R9,R10
        LR      R10,R6           :
        SRL     R10,10
        SLL     R10,2            :OFFSET INTO THIS MAC SET
        AR      R9,R10
        L       R9,0,R9          :GET CONTENT OF THE MAC SEGMENT
        SRL     R9,8
        NHI     R9,0FFF          :GET BASE PAGE
        LR      R10,R6
        SRL     R10,8
        NHI     R10,0FF          :GET RELATIVE PAGE
        AR      R9,R10           :CALCULATE THE REAL PAGE
        LIS     R5,2            :START AT PIPE MAC SET SEG 2
        L       R10,PPMAC2,,     :ITS BASE PAGE
        SR      R9,R10           :
PCCHCK  CI      R9,100           :GREATER THAN ONE SEGMENT
        JL      PCDONE           :NO, STAY IN SEG 2
        AIS     R5,1            :INCREMENT SEGMENT NUMBER
        SI      R9,100           :MINUS 1 SEG PAGES
        JBS     PCCHCK           :GO BACK TO CHECK
PCDONE  SLL     R5,10           :CONVERT TO SEG POSITION
        SLL     R9,8             :CONVERT TO PAGE POSITION
        AR      R9,R5           :GET TOGETHER
        NHI     R6,0FF           :ONLY WANT BYTE NMBER
        AR      R6,R9            :FINALLY, THE CORRECT REF ADDRESS FOR
                                 :PIPE MAC
        JR      R4

        EI      :XMEMRY
        EI      :XPIPE

PIPCHK  HS      0
        IF      XPIPE

        IF      XMEMRY
        LH      R5,XMPCUR,,     :GET THE CURRENT MAC SET
        STH     R5,SAVXMC,,     :SAVE IT FOR LATER USE
        EI      :XMEMRY

        LHI     R6,(PPGRP-1)*2  :LAST HW IN SEND REQUEST BIT ARRAY
        LHI     R7,(PPGRP-1)*10 :PIPE # OF LEFTMOST BIT
PIPCH1  LHL     R11,PIPESD,R6,  :GET HALFWORD OF BIT ARRAY
PIPCH2  JFFOH   R11,CHKPIP      :SEE IF BIT SET
        SHI     R7,10           :DECREMENT PIPE #
        SIS     R6,2            :DECREMENT BIT ARRAY POINTER
        JGEBS   PIPCH1          :LOOP UNTIL ALL CHECKED

        IF      XMEMRY
        LH      R10,SAVXMC,,
        EI      :XMEMRY

        JR      R2              :RETURN

CHKPIP  STH     R11,PIPCHW,,    :SAVE CURRENT HALFWORD
        RBT     R12,PIPCHW,,    :CLEAR THIS BIT
        LHL     R13,PPENT,R12,R12
                                :GET PIPE TABLE ENTRY
        L       R10,PPSLFT,R13  :# OF CHARS LEFT TO SEND
        JLE     PPCONT          :NONE -- GO ON WITH SEARCH
        L       R12,PPRLFT,R13  :# OF CHARS LEFT TO READ
        JLE     PPCONT          :NONE -- GO ON WITH SEARCH

        IF      XMEMRY
        LR      R5,R10          :SAVE R10
        LHI     R10,NMACSS+3    :SWITCH TO PIPE MAC SET
        JAL     R4,XMCURR       :MAKE THIS MAC SET CURRENT
        LR      R10,R5          :RESTORE R10
        EI      :XMEMRY

        L       R5,PPSPTR,R13   :SEND BUFFER POINTER
        L       R4,PPRPTR,R13   :RECEIVE BUFFER POINTER
PIPCH3  HS      0
        SIS     R10,1           :DECREMENT # CHARS TO SEND
        JL      PIPCHS          :EXIT LOOP IF DONE SENDING
        SIS     R12,1           :DECREMENT # CHARS TO RECEIVE
        JL      PIPCHR          :EXIT LOOP IF DONE RECEIVING
        LB      R0,0,R5         :GET CHAR TO SEND
        STB     R0,0,R4         :GIVE IT TO RECEIVER
        AIS     R5,1            :INCREMENT BUFFER POINTERS
        AIS     R4,1            :
        J       PIPCH3          :LOOP

PIPCHS  AIS     R10,1           :ADD ONE BACK
        JFS     PIPCH4
PIPCHR  AIS     R10,1           :ADD ONE BACK
        AIS     R12,1

PIPCH4  ST      R5,PPSPTR,R13   :SAVE NEW BUFFER POINTERS
        ST      R4,PPRPTR,R13   :
        ST      R10,PPSLFT,R13  :SAVE # CHARS TO SEND
        ST      R12,PPRLFT,R13  :SAVE # CHARS TO RECEIVE
        LR      R10,R10         :SEND REQUEST COMPLETE?
        JLE     PPSACT          :YES, RETURN 'COMPLETE' STATUS

PIPCH5  LR      R12,R12         :RECEIVE REQUEST COMPLETE??
        JLE     PPRACT          :YES, RETURN 'COMPLETE' STATUS

PPCONT  LHL     R11,PIPCHW,,    :R11 = CURRENT BIT ARRAY HW
        J       PIPCH2          :LOOP

PPSACT  L       R11,PPSPRM,R13  :GET SENDER PARAM BLOCK ADDRESS
        LIS     R0,COMPLE       :GET 'COMPLETE' STATUS
        STH     R0,STATUS,R11   :SAVE RETURN STATUS
        L       R8,PPSPHD,R13   :GET SENDER PHD
        LR      R1,R6           :SAVE R6,R7 COUNTERS
        LR      R3,R7           :(THEY ARE DESTROYED BY RDYENT)
        JAL     R9,RDYENT       :ENTER PROCESS IN READY QUEUE
        LR      R6,R1           :RESTORE R6,R7
        LR      R7,R3
        J       PIPCH5          :GO TO CHECK IF RECEIVER IS COMPLETE

PPRACT  L       R11,PPRPRM,R13  :GET RECEIVER PARAM BLOCK ADDRESS
        LIS     R0,COMPLE       :GET 'COMPLETE' STATUS
        STH     R0,STATUS,R11   :SAVE RETURN STATUS
        L       R8,PPRPHD,R13   :GET RECEIVER PHD
        LR      R1,R6           :SAVE R6,R7 COUNTERS
        LR      R3,R7           :(THEY ARE DESTROYED BY RDYENT)
        JAL     R9,RDYENT       :ENTER PROCESS IN READY QUEUE
        LR      R6,R1           :RESTORE R6,R7
        LR      R7,R3           :
        J       PPCONT          :CONTINUE SEARCH
        EI      :XPIPE
        JR      R2


:
: Entry point definitions for NUCIO
:

	GL	STRT|SYSDEV|,DPRI|SYSDEV|
	GL	STRT|CRADEV|,INIT|CRADEV|,DPRI|CRADEV|
        GL      STRT|LVODEV|,INIT|LVODEV|,DPRI|LVODEV|
        IF      XPIPE
         GL     STRT|PIPDEV|,INIT|PIPDEV|,DPRI|PIPDEV|,COMP|PIPDEV|
        EI      :XPIPE

STRT|SYSDEV|	EQ	SYSTRT		:Start requests
STRT|CRADEV|	EQ	CRSTRT		:Start requests
STRT|LVODEV|    EQ      LVSTRT          :Start requests

INIT|CRADEV|	EQ	CRINIT		:Initialize driver
INIT|LVODEV|    EQ      LVINIT          :Initialize driver

DPRI|SYSDEV|	EQ	SYSPRI		:Priority
DPRI|CRADEV|	EQ	CRAPRI		:Priority
DPRI|LVODEV|    EQ      LVOPRI          :Priority

        IF      XPIPE
STRT|PIPDEV|    EQ      PPSTRT          :START PIPE REQUESTS
COMP|PIPDEV|    EQ      PIPCHK          :CHECK COMPLETION
INIT|PIPDEV|    EQ      PPINIT          :INITIALIZE PIPE DRIVER
DPRI|PIPDEV|    EQ      PIPPRI          :PIPE PRIORITY
        EI      :XPIPE

	EM
   	SUBTTL	Disk/Tape driver				dskdrv.nad
        REMARK  %DSKDRV  V 1.10 07-03-85, MKS

: See the file (ISIS2)NUCLUS.MEM for more revision information.
: V 1.10 07-03-85, MKS
:	MODIFY DISK TRACE TABLE TO SHARE THE TABLE AREA WITH 
:	MOTITOR TRACE ROUTINE
:
: V 1.9 12-19-83, AWT
:       ADDED A CHECKING ROUTINE FOR "SLOW" DISK DURING DISK INITIALI-
:       ZATION.
:       ADD A CONSOL MESSAGE FOR SYSTEM FAULT WITH BYTE 0 OF VMA
: V 1.8 01-25-83, RNP
:       Addition for Extended Memory option
: V 1.7 05-20-82, SCY
:	Change the disk error msg format to include the sector address
:	 and the disk operation.
: V 1.6 04-16-82, SCY
:	Bug fixed which caused fail on disk retry operation.
: V 1.5 01-26-82, SCY
:	Changed link register R4 to R9 when call RDYENT
: V 1.4 11-17-81, MDS
:	Changed QUEINI to in-line macro instead of sub-routine call.
: V 1.3, 11-17-81, RNP 
:	Added GL for DSKDEV
: V 1.1, 10-14-81, SCY
:	Change the print format of error msg
: V 1.0, 08-19-81, SMF
:	Initial version
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								:
:	Disk/tape device driver module				:
:								:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	IF	NDISK+NTAPE
	MO	.,DSKDRV

	RA	0

	LO	COMMON			:Get common symbols

	GL	DTSTRT,DTGO,DTCHK,DTINIT	:Module entry points
	IF	DTRACE
	IF	GATRAC
	GL	DTRCTB
	EI
	EI
	GL	IOEXIT,RDYENT,CONMSG	:External routines called
	GL	QUEPUT,QUEGET
	GL	DVREQ,DSKDEV		:External variable used
        GL      MAXTRY,STKBOT
       IF       XMEMRY
        GL      XMCURR
       EI       :XMEMRY
:
: Constant definitions
:

DSKDEV	EQ	$A 0		:Device type of disk devices
TAPDEV	EQ	$A 1		:Device type of tape devices
  
        IF      \MAXTRY
        ELSE
MAXTRY  EQ      $A 12           :FOR DISK INITIALIZATION
        EI

DSKPRI	EQ	1		:Extra priority for disk operations
TAPPRI	EQ	1		:Extra priority for tape operations

NSVC	EQ	NDTRB		:NSVC = Number of requests possible
				:  at once.  This should be changed
				:  to include requests made by LVOL
				:  devices when the driver is ready.

	IF	NSVC-$A32
	REMARK	%*** NSVC (NDTRB) may not be higher than 32!
	EI

Q	EQ	80000000	:Bit 0 on
SBBITS	EQ	0		:Initialize SVC block bits
	RE	NSVC
SBBITS	EQ	SBBITS!Q	:Or in this bit
Q	EQ	Q^(-1)		:Shift bit right
	NOLIST
	ER
	LIST
:
: Data structures
:

SVCBLK	EQ	.		:SVC block
	ORG	0
SVCPRM	WS	1		:Address of parameter block
SVCRS	BS	1		:Request/Status
SVCLUN	BS	1		:Logical unit #
SVCSTA	HS	1		:Controller status
SVCADR	WS	1		:Data buffer address
SVCLEN	WS	1		:Transfer length
SVCPOS	WS	1		:Sector number
	WS	1		:Pad to same length as info block
SVCSIZ	EQ	.		:Size of SVC block
	ORG	SVCBLK


INFBLK	EQ	.		:Info block (SVC block after unitinfo)
	ORG	0
	WS	1		:Space for SVCPRM
	BS	1		:Space for SVCRS
INFLUN	BS	1		:Logical unit #
INFSTA	HS	1		:Status
INFPM	BS	1		:Protection mask
INFGU	BS	1		:Global unit #
INFNAM	HS	1		:Unit type name ('DK', 'MT', or 'MS')
INFTYP	BS	1		:Device type (0, 1, or 2)
INFCTR	BS	1		:Device address on controller
INFDBS	HS	1		:Default block size
INFBTK	HS	1		:Number of blocks per track
INFTCY	HS	1		:Number of tracks per cylinder
INFSTR	HS	1		:Start cylinder #
INFNUM	HS	1		:Number of cylinders
INFSIZ	EQ	.		:Size of info block
	ORG	INFBLK

	IF	(SVCSIZ-INFSIZ)&07FFFFFFF
	REMARK	%***Internal error-- SVC block and info block different sizes!
	EI


DTIBLK	EQ	.		:Disk device type info block
	ORG	0
DTMAXU	HS	1		:Maximum unit number in type
DTUBLK	HS	0		:Start of unit info table addresses
	ORG	DTIBLK


DTUNBK	EQ	.		:Device unit info block
	ORG	0
DUSIZE	WS	1		:Size of device (disk only)
DUDLUN	BS	1		:Logical unit number
DUDTYP	BS	1		:ISIS disk type
	BS	2		:Fill to fullword boundary
	ORG	DTUNBK


REQBLK	EQ	.		:Request block
	ORG	0
	BS	DPSIZ		:Space for parameters to request
DPLPRM	WS	1		:Address of Pascal parameter block
DPLPHD	HS	1		:Process header addr
DPLBNO	HS	1		:Request block number
RBSIZE	EQ	.
	ORG	REQBLK
:
: Storage for the driver
:

	SEG	A.DATA

SBUSED	WS	1		:Bit array of used SVC blocks
DTREQ	WS	1		:Temporary bit array storage
DTCRET	WS	1		:Return address storage
DACTRT	WS	1		:Return address storage for DTACT
RBFREE	WS	1		:Bit array of free request blocks
 
DSKTRY  HC      0               :

DWAITQ	BS	XQUEUE		:Queue of processes waiting for request block

DTERHD	SC	/xxx ISIS STA=xx CONTRL STA=xxxx: /
DTERH1	SC	/    Sector addr=xxxxxxxx OP= /
DTERH2  SC      /    SYSTEM FAULT. BYTE 0 OF VMA = XX /

	IF	DTRACE		:If tracing requested
DTRCPT	HS	1		:Trace table pointer
DTRCTB	BS	$A 4098		:Trace table
	EI	:DTRACE

	WS	0		:Word align
	RA	0A
Q	EQ	0
	RE	NSVC
SVCB|Q|	BS	SVCSIZ		:Allocate an SVC block
Q	EQ	Q+1
	NOLIST
	ER
	LIST

Q	EQ	0
	RE	NDTRB
RBBK|Q|	BS	RBSIZE		:Allocate a request block
Q	EQ	Q+1
	NOLIST
	ER
	LIST

Q	EQ	0
	RE	MXDISK+1
	IF	\DLUN|Q|
DINF|Q|	WC	DSIZ|Q|		:Specified disk size
	BC	DLUN|Q|,0,0,0	:Logical unit number, unknown type
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST

Q	EQ	0
	RE	MXTAPE+1
	IF	\TLUN|Q|
TINF|Q|	WC	0		:Tapes don't have sizes
	BC	TLUN|Q|,1,0,0	:Logical unit number, type=tape
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST

	RA	0
:
: In-core constants
:

	SEG	A.CODE		:Code segement

	RA	0A
SVCTAB	HS	0		:Table of SVC block addresses
Q	EQ	0
	RE	NSVC
	HC	SVCB|Q|
Q	EQ	Q+1
	NOLIST
	ER
	LIST

RBENT	HS	0		:Table of request block addresses
Q	EQ	0
	RE	NDTRB
	HC	RBBK|Q|
Q	EQ	Q+1
	NOLIST
	ER
	LIST
	RA	0

TAPEOP	BC	4,5,6,7,8,9,0B,0C	:Map Pascal tape ops to ISIS codes

DTERCD	BC	COMPLE,PRGERR,PRGERR	:Status 0,1,2
	BC	PRGERR,PRGERR,FAIL	:Status 3,4,5
	BC	FAIL,TRANS,TRANS	:Status 6,7,8
	BC	TRANS,PRGERR,FAIL	:Status 9,10,11
	BC	FAIL,FAIL,FAIL		:Status 12,13,14
	BC	FAIL,ENDF,ENDM		:Status 15,16,17
	BC	INTERV,INTERV,COMPLE	:Status 18,19,20
	BC	FAIL,PRGERR,FAIL	:Status 21,22,23
	BC	COMPLE			:Status 24

DTINFO	HS	0		:Disk/Tape device type info entries
	ORG	DTINFO+2*DSKDEV
	HC	DSKINF-DTINFO	:Entry for disk type
	ORG	DTINFO+2*TAPDEV
	HC	TAPINF-DTINFO	:Entry for tape type

	IF	DSKDEV-TAPDEV	:If disk device has higher number
	ORG	DTINFO+2*DSKDEV+2
	EI

	RA	0A
DSKINF	HC	MXDISK		:Highest disk device number
Q	EQ	0
	RE	MXDISK+1
	IF	\DLUN|Q|
	HC	DINF|Q|		:Address of unit info entry
	ELSE
	HC	0
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST

TAPINF	HC	MXTAPE		:Highest tape device number
Q	EQ	0
	RE	MXTAPE+1
	IF	\TLUN|Q|
	HC	TINF|Q|		:Address of unit info entry
	ELSE
	HC	0
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST

	RA	0
:
: Error messages
:

DTERTL	SC	/"8D"8A/	:End of error msg
TYPCHR	AC	/DT/		:Device type labels

DTMSGS	EQ	.		:Use as offset

DTER1	SC	/BAD MEM ACCESS/
DTER2	SC	/NO ACCESS ALLOWED/
DTER3	SC	'R/W/A PROT FAILURE'
DTER4	SC	/SECTOR# OUT OF RANGE/
DTER5	SC	/BAD CYL ADDR/
DTER6	SC	/BAD CYL ADDR AFTER TRANS/
DTER7	SC	/DISK SEEK ERR/
DTER8	SC	/CONTROLLER ERR/
DTER9	SC	/ABORTED/
DTER10	SC	/ODD BYTE CNT/
DTER11	SC	/INVALID CYL OVERFLOW INDICATION/
DTER12	SC	/BAD SEC IN ALT CYL/
DTER13	SC	/BAD SEC - NO ALT CYL/
DTER14	SC	/CYL MAP UNREADABLE/
DTER15	SC	/BAD SEC - ALT CYL ASSIGNED/
DTER16	SC	/END OF FILE/
DTER17	SC	/END OF TAPE/
DTER18	SC	/DEV UNAVAIL/
DTER19	SC	/WRITE PROT/
DTER20	SC	/UNIT ATT BUT WRITE PROT/
DTER21	SC	/UNIT ALREADY ATT/
DTER22	SC	/REQ IGNORED/
DTER23	SC	/ESELCH TIMEOUT/
DTER24	SC	/RECOVERED ERR/

DTMSGP	HC	0		:Pointers to messages
	RA	0A
Q	EQ	1
	RE	24
	HC	DTER|Q|-DTMSGS
Q	EQ	Q+1
	NOLIST
	ER
	LIST
	RA	0

DTMSOP	EQ	.
DTOP0	SC	/Read/
DTOP1	SC	/Write/
DTOP2	SC	/Attach/
DTOP3	SC	/Detach/
DTOP4	SC	/Unitinfo/

DTMSGO	EQ	.
	RA	0A
Q	EQ	0
	RE	5
	HC	DTOP|Q|-DTMSOP
Q	EQ	Q+1
	NOLIST
	ER
	LIST	
	RA	0
:
: DTSTRT - Start an I/O operation on a disk or tape device.
:	Called by NUCIO in module NUCIO:
:		R1 = Address of Pascal Data Buffer
:		R2 = Address of Pascal I/O Parameter Block
:		R3 = Device type #
:		R5 = Device unit #
:		R8 = Calling process header addr.
:	Return by jumping to IOEXIT in module NUCLUS
:

DTSTRT  L       R6,RBFREE,,     :R6 -> bitmap of free request blocks
	JFFO	R6,DTST1	:Jump if any available
        LA      R6,DWAITQ,,     :Else, R6 -> disk/tape wait queue
	LM	HD,REG0+4*HD,R8	:Get process pointers
	STM	R0,REG0,R8	:Save all registers in proc hdr
	JAL	R4,QUEPUT	:Put calling process on queue
	J	IOEXIT		:Return

DTST1   RBT     R7,RBFREE,,     :Block isn't free anymore
	JAL	R14,DSETUP	:Set up request
	J	IOEXIT		:Return

:
: DSETUP - Put info into request block and start operation
:	Link on R14
:

DSETUP	LHL	R13,RBENT,R7,R7	:Get request block addr
	STH	R7,DPLBNO,R13	:Save block number
	ST	R1,DPADDR,R13	:Save Pascal data buffer addr
	STH	R3,DPTYPE,R13	:Save device type #
	STH	R5,DPUNIT,R13	:Save device unit #
	LHL	R0,OPER,R2	:Get operation code
	STH	R0,DPOPER,R13	:Save in request block
	L	R0,ARG1,R2	:Get ARG1 (sector #/tape sub-op)
	ST	R0,DPSECT,R13	:Save in request block
	L	R0,ARG2,R2	:Get ARG2 (transfer length)
	ST	R0,DPLEN,R13	:Save in request block
	LA	R0,DTACT	:Activation address for completion
	ST	R0,DPACT,R13	:Save in request block
	ST	R2,DPLPRM,R13	:Save Pascal param addr
	STH	R8,DPLPHD,R13	:Save process header addr
	LR	R1,R13		:Move request block addr
	JAL	R4,DTGO		:Start request
	JER	R14		:Return if request started
	CLHI	R0,BUSY		:Driver busy?
	JE	DTSCRA		:Crash if so.
	LHL	R7,DPLBNO,R1	:Get request block number
        SBT     R7,RBFREE,,     :Mark the block free
	L	R2,DPLPRM,R1	:Restore param addr
	LHL	R8,DPLPHD,R1	:Restore process header
	CLHI	R0,FAIL		:Failure (bad unit #)?
	JNFS	DTSRET		:No, skip
	LCS	R4,1		:Bad unit # error code
	ST	R4,STATS2,R2	:Return in STATUS2
DTSRET	STH	R0,STATUS,R2	:Save return code
	JAL	R9,RDYENT	:Put in ready queue
	JR	R14		:Return

DTSCRA	JAL	R10,CRASH	:No SVC blocks-- fatal error
	BC	0,0,0,31
:
: DTACT - Called when disk/tape request is done
:	Link on R15
:	Request block addr in R1
:

DTACT	L	R3,DPLPRM,R1	:Get parameter block address
       IF       XMEMRY
        LHL     R10,DPLPHD,R1   :R10 -> PHR for this request
        LH      R10,XMPSET+4,R10        :R10 -> XM MAC Set
        JAL     R4,XMCURR       :Make this Process's MAC set current
       EI       :XMEMRY
	LHL	R2,DPSTAT,R1	:Get ISIS status
	JEFS	DTACT2		:Skip if zero
	ST	R2,ARG2,R3	:Save ISIS error code in ARG2
	LB	R2,DTERCD,R2	:And get corresponding Pascal code
DTACT2	STH	R2,STATUS,R3	:Save return code
	LHL	R0,DPCNST,R1	:Get controller status
	ST	R0,STATS2,R3	:Save in Pascal parameter block
	L	R0,DPLEN,R1	:Get actual transfer length
	ST	R0,ARG1,R3	:Save in Pascal param block
	LHL	R8,DPLPHD,R1	:Get process header addr
	JAL	R9,RDYENT	:Put process in ready queue
        LA      R6,DWAITQ,,     :R6 -> wait queue
        CLH     R6,DWAITQ,,     :Queue empty?
	JE	DEMPTY		:Yes, finish up
        ST      R15,DACTRT,,    :Save return address
	JAL	R4,QUEGET	:Get first process
	LHL	R7,DPLBNO,R1	:Recover request block number
	ST	R7,REG0+4*R7,R8	:Save in process's reg. set
	LM	R0,REG0,R8	:Restore registers
	JAL	R14,DSETUP	:Set up request
        L       R15,DACTRT,,    :Restore return address
	JR	R15		:Return

DEMPTY	LHL	R0,DPLBNO,R1	:Get request block number
        SBT     R0,RBFREE,,     :Mark block free
	JR	R15		:Return
:
: DTCHK - Check for Disk/Tape completion
:	Called by NIOCP in module NUCIO
:	Link on R2
:

DTCHK   ST      R2,DTCRET,,     :Save return address
        L       R10,SBUSED,,    :R10 = SVC block bit array
	JN	DTCHK1		:Skip if any requests pending
	LIS	R0,DSKDEV	:Disk device type #
	RBT	R0,DVREQ,,	:Stop polling for completion
	JR	R2		:return

DTCHK1	JFFO	R10,DTCHK2	:Jump if any requests left to look at
        L       R2,DTCRET,,     :Else get return address
	JR	R2		:Return

DTCHK2  ST      R10,DTREQ,,     :Save bit array
        RBT     R11,DTREQ,,     :Clear bit for this SVC block
	LHL	R10,SVCTAB,R11,R11	:Get SVC block addr
	LIS	R0,0
	TBT	R0,SVCRS,R10	:Check overlap bit
	JEFS	DTDONE		:If off, request is done
DTCHLP  L       R10,DTREQ,,     :Get partially processed bit array
	J	DTCHK1		:Loop

DTDONE	L	R1,SVCPRM,R10	:Get parameter block address
	LHL	R2,DPTYPE,R1	:Get device type
	IF	DTRACE		:If tracing wanted
	JAL	R4,DTTRC	:    Trace
	EI
	LHL	R5,DPOPER,R1	:Get operation
	JNFS	DTNOTT		:Skip if not input
	CLHI	R2,TAPDEV	:Tape device?
	JNFS	DTNOTT		:No, skip
	L	R0,SVCLEN,R10	:Get # bytes read from tape
	ST	R0,DPLEN,R1	:Put in parameter block

DTNOTT	LHL	R7,SVCSTA,R10	:Get controller status halfword
	STH	R7,DPCNST,R1	:Save in param block
	LB	R6,SVCRS,R10	:Get status of operation
	STH	R6,DPSTAT,R1	:Save in param block
	JN	DTERR		:Jump if error
	CLHI	R5,4		:Unitinfo operation?
	JN	DACTIV		:No, go activate

       IF       XMEMRY
        LR      R9,R10          :Save R10
        LHL     R10,DPLPHD,R1   :R10 -> PHR for this request
        LH      R10,XMPSET+4,R10        :R10 -> XM MAC Set
        JAL     R4,XMCURR       :Make this Process's MAC set current
        LR      R10,R9          :Restore R10
       EI       :XMEMRY
	L	R9,DPADDR,R1	:Get data buffer address
	LHL	R0,INFLUN,R10	:Get logical unit number
	ST	R0,0,R9		:Put in buffer[1]
	LHL	R0,INFSTA,R10	:Get device status
	ST	R0,4,R9		:Put in buffer[2]
	LB	R0,INFPM,R10	:Get protection mask
	SRLS	R0,5		:Move bits to bottom of word
	ST	R0,8,R9		:Put in buffer[3]
	LHL	R0,INFDBS,R10	:Get default block size
	ST	R0,0C,R9	:Put in buffer[4]
	LHL	R0,INFSTR,R10	:Get start cylinder #
	ST	R0,10,R9	:Put in buffer[5]
	LHL	R0,INFNUM,R10	:Get # of cylinders
	ST	R0,14,R9	:Put in buffer[6]
	LHL	R0,INFBTK,R10	:Get # sectors per track
	ST	R0,18,R9	:Put in buffer[7]
	LHL	R0,INFTCY,R10	:Get # tracks per cylinder
	ST	R0,1C,R9	:Put in buffer[8]
	LB	R0,INFCTR,R10	:Get device address on controller
	ST	R0,20,R9	:Put in buffer[9]
	LB	R0,INFGU,R10	:Get global unit number
	ST	R0,24,R9	:Put in buffer[10]
	LHL	R0,INFNAM,R10	:Get ASCII device name
	ST	R0,28,R9	:Put in buffer[11]
	LB	R0,INFTYP,R10	:Get device type
	ST	R0,2C,R9	:Put in buffer[12]

	LHL	R12,DTINFO,R2,R2	:Get offset of info for type
	AI	R12,DTINFO	:Convert to address
	LHL	R3,DPUNIT,R1	:Get unit number
	SLLS	R3,1		:Convert to halfword pointer
	LHL	R13,DTUBLK,R12,R3	:Get Disk/Tape info block for unit
	L	R0,DUSIZE,R13	:Get actual device size (in sectors)
	ST	R0,30,R9	:Put in buffer[13]

DACTIV  RBT     R11,SBUSED,,    :Release SVC block
	L	R15,DPACT,R1	:Get activation address
	JALR	R15,R15		:Call activation routine
	J	DTCHLP		:Reenter polling loop

:
:	Process an error
:
DTERR	EQ	.
	LR	R8,R6		:Copy status to a safe place
	LR	R9,R1		:Ditto for req block ptr.

	LB	R2,TYPCHR,R2	:Get char describing dev type
        STB     R2,DTERHD+1,,   :Put in msg

	LHI	R0,24A		:2 digits, zero fill, decimal
        LA      R1,DTERHD+2,,   :Address to put unit #
	LHL	R2,DPUNIT,R9	:Get unit #
	JAL	R6,OUTNUM	:Convert

	LHI	R0,250		:2 digits, zero fill, hex
        LA      R1,DTERHD+$a14,,        :Where to put status
	LR	R2,R8		:Get status
	JAL	R6,OUTNUM	:Convert

	LHI	R0,450		:4 digits, zero fill, hex
        LA      R1,DTERHD+$a28,,        :Where to put cont. stat.
	LR	R2,R7		:Get controller status
	JAL	R6,OUTNUM	:Convert

        LA      R3,DTERHD,,     :Start of error msg
	JAL	R6,CONMSG	:Print it
	LHL	R3,DTMSGP,R8,R8	:Get offset of correct msg
	LA	R3,DTMSGS,R3	:Get absolute addr of msg
	JAL	R6,CONMSG	:Print it
	LA	R3,DTERTL	:Get end of msg
	JAL	R6,CONMSG	:Print it
        CLHI    R8,8            :CONTROLLER ERROR?
        JN      DTERR8          :NO, SKIP
        LHI     R3,8000         :MASK FOR SYSTEM FAULT BIT
        LR      R6,R7           :GET CONTROLLER STATUS
        NR      R6,R3           :SYSTEM FAULT?
        JE      DTERR8          :NO, SKIP
        LHI     R0,250          :2 DIGITS, ZERO FILL, HEX
        LA      R1,DTERH2+$A35,,   :WHERE TO PUT BYTE 0 OF VMA
        LB      R2,SVCADR,R10   :GET BYTE 0 OF VMA
        JAL     R6,OUTNUM       :CONVERT
        LA      R3,DTERH2,,     :START OF MSG
        JAL     R6,CONMSG       :PRINT IT
        LA      R3,DTERTL       :GET END OF MSG
        JAL     R6,CONMSG       :PRINT IT
DTERR8	LR	R1,R9
	LHL	R2,DPTYPE,R9	:Get dev type
	CLHI	R2,DSKDEV	:Disk device?
	JN	DACTIV		:No, just activate normally
	LHI	R0,850		:8 digits,zero fill,hex
        LA      R1,DTERH1+$a17,,        :Where to put sector address
	L	R2,DPSECT,R9	:Get sector addr
	JAL	R6,OUTNUM	:Convert
        LA      R3,DTERH1,,     :Start of msg
	JAL	R6,CONMSG	:Print it
	LHL	R2,DPOPER,R9	:Get operation type
	LHL	R3,DTMSGO,R2,R2	:Get offset of correct msg
	LA	R3,DTMSOP,R3	:Get absolute addr of msg
	JAL	R6,CONMSG	:Print it
	LA	R3,DTERTL	:Get end of msg
	JAL	R6,CONMSG	:Print it
	LR	R1,R9		:Restore req. block ptr
	LHL	R2,DPTYPE,R1	:Get device type
	LHL	R5,DPOPER,R1	:Get operation
	CLHI	R5,1		:Read or write?
	JG	DACTIV		:No, activate
	CLHI	R8,18		:Status 18 is recovered error
	JE	DACTIV		:Just activate normally
	LHL	R0,DPTRYS,R1	:Get number of tries so far
	CLHI	R0,MXTRYS	:At maximum?
	JGE	DACTIV		:Yes, give up
	AIS	R0,1		:Increment retry count
	STH	R0,DPTRYS,R1	:And save it
	LHL	R12,DTINFO,R2,R2	:Get offset of info for type
	AI	R12,DTINFO	:Convert to address
	LHL	R3,DPUNIT,R1	:Get unit number
	SLLS	R3,1		:Convert to halfward pointer
	LHL	R13,DTUBLK,R12,R3	:Get disk/tape info block for unit
	JAL	R4,DTGOP	:Restart the request
	J	DTCHLP		:Reenter polling loop
:
: DTINIT - Initialize the driver
:	Link on R2
:

DTINIT  LA      R6,DWAITQ,,     :R6 -> disk wait queue
	QUEINI(R6)		:Initialize the queue

	LI	R1,SBBITS
        ST      R1,RBFREE,,     :Start with all request blocks free
	LIS	R0,0
        ST      R0,SBUSED,,     :And with all SVC blocks not used

	IF	DTRACE		:If tracing,
        STH     R0,DTRCPT,,     :Initialize pointer
	IF	GATRAC
	LI	R1,$A2048	
	STH	R0,DTRCPT,R1,
	EI	:GATRAC
	EI	:DTRACE

	IF	NDISK
        LA      R10,SVCB0,,     :R10 -> first SVC block
	LHI	R3,2*MXDISK	:Halfword pointer for last disk
	LA	R4,DSKINF	:Address of disk information
DTIN1	LHL	R5,DTUBLK,R3,R4	:Get unit info block addr (if any)
	JE	DTIN2		:None, skip
DTINA	LB	R0,DUDLUN,R5	:Get logical unit number
	STB	R0,SVCLUN,R10	:Put in SVC block
	LIS	R0,0A		:Unitinfo operation
	STB	R0,SVCRS,R10	:Put in SVC block
	SVC	SHARE,SVCRS,R10	:Do operation
        LHL     R0,INFSTA,R10   :GET DEVICE STATUS
        LIS     R7,2            :MASKING FOR NRY BIT
        NR      R0,R7           :IS THE DRIVE READY?
        JE      DTINB           :YES, GO TO SAVE DISK INFO
        LHL     R0,DSKTRY,,     :GET NUMBER OF TRIES SO FAR
        CLHI    R0,MAXTRY       :AT MAXIMUM?
        JGE     DTINB           :YES, GIVE UP
        AIS     R0,1            :INCREMENT RETRY COUNT
        STH     R0,DSKTRY,,     :AND SAVE IT
        SVC     DISMISS,20      :
        J       DTINA           :TRY AGAIN
DTINB	LB	R0,INFTYP,R10	:Device type (0=small, 2=big)
	STB	R0,DUDTYP,R5	:Save in unit info block
	L	R0,DUSIZE,R5	:Get size of disk
	JG	DTIN2		:Skip if one already given
	LHL	R7,INFBTK,R10	:Get # blocks per track
	MH	R7,INFTCY,R10	:Times # tracks per cyl
	LH	R8,INFNUM,R10
	MR	R6,R8		:Times # of cylinders
	ST	R7,DUSIZE,R5	:Equals size in blocks
DTIN2	SIS	R3,2		:Decrement unit counter
	JGE	DTIN1		:Loop until all checked
	EI	:NDISK

	JR	R2
:
: DTGO - internal routine to start a disk/tape operation
:	Link on R4
:	Expects address of paramater block in R1
:	Return code in R0
:

DTGO	LHL	R2,DPTYPE,R1	:Get device type
	LHL	R12,DTINFO,R2,R2	:Get offset of info for type
	AI	R12,DTINFO	:Convert to address
	LHL	R3,DPUNIT,R1	:Get unit number
	
	CLH	R3,DTMAXU,R12	:Unit number in range?
	JG	DTGFAI		:No, failure
	LR	R5,R3		:Copy unit number
	SLLS	R5,1		:Convert to halfword pointer
	LHL	R13,DTUBLK,R12,R5	:Get Disk/Tape info block for unit
	JE	DTGFAI		:Unit does not exist, failure

	LHL	R5,DPOPER,R1	:Get operation requested
	CLHI	R5,6		:Compare with maximum allowable
	JG	DTGPGE		:Program error if too high
	JAL	R15,GETSVC	:Get an SVC block for request
	J	DTGBSY		:Normal return-- none available
	LIS	R0,1
	STH	R0,DPTRYS,R1	:This is the first try
	LHL	R6,DTGTBL,R5,R5	:Get routine offset for operation
	J	DTGTBL,R6	:Jump to routine

DTGTBL	EQ	.
	HC	DTGIO-DTGTBL	:Read
	HC	DTGIO-DTGTBL	:Write
	HC	DTGOP-DTGTBL	:Attach
	HC	DTGOP-DTGTBL	:Detach
	HC	DTGINF-DTGTBL	:Unitinfo
	HC	DTGPGE-DTGTBL	:Loadprog - Not implemented
	HC	DTGTOP-DTGTBL	:Tape operation

:
:	Set up for unitinfo operation
:
DTGINF	LIS	R5,0A		:Operation code for status
	J	DTGOP		:Go do operation


:
:	Set up for tape operation
:
DTGTOP	L	R6,DPSECT,R1	:Get tape sub-operation
	JL	DTGPGE		:Program error if negative
	CLHI	R6,7		:Too high?
	JG	DTGPGE		:Program error if too high
	LB	R5,TAPEOP,R6	:Get ISIS operation number
	J	DTGOP		:Go do operation



:
:	Set up for input or output operation
:
DTGIO	CLHI	R2,DSKDEV	:Is this a disk device?
	JNFS	DTGIO1		:No, ignore sector number
	L	R6,DPSECT,R1	:Get sector number
	JL	DTGPGE		:Program error if negative
	CL	R6,DUSIZE,R13	:Too high?
	JGE	DTGPGE		:If so, program error
	ST	R6,SVCPOS,R10	:Save in SVC block
DTGIO1	L	R6,DPADDR,R1	:Get data block addr
	ST	R6,SVCADR,R10	:Save in SVC block
	L	R6,DPLEN,R1	:Get length of transfer
	ST	R6,SVCLEN,R10	:Save in SVC block
	LIS	R0,1
        AHM     R0,DKTPAC,,     :Increment disk access counter
				:Fall through to DTGOP



:
:	Start operation
:
:		Note: This is also used as the entry point to a
:		routine to restart a disk operation.  It assumes
:		the registers and SVC block are set up correctly.
:

DTGOP	LB	R0,DUDTYP,R13	:Get shared device type
	JEFS	DTGOP1		:Skip if cartridge disk
	OHI	R5,80		:Turn on overlap I/O bit
DTGOP1	STB	R5,SVCRS,R10	:Save operation in SVC block
	LB	R0,DUDLUN,R13	:Get logical unit number
	STB	R0,SVCLUN,R10	:Put in SVC block
	SVC	SHARE,SVCRS,R10	:Start operation
	ST	R1,SVCPRM,R10	:Save parameter addr in SVC block
        SBT     R11,SBUSED,,    :Set SVC block in use
	LIS	R0,DSKDEV	:Disk device type #
	SBT	R0,DVREQ,,	:Start polling for completion
	LIS	R0,0		:Operation started code
	JR	R4		:Return


:
: Error conditions
:

DTGFAI	LIS	R0,FAIL		:Failure status (illegal device)
	JR	R4		:Return

DTGBSY	LIS	R0,BUSY		:Busy status (no SVC blocks left)
	JR	R4		:Return

DTGPGE	LIS	R0,PRGERR	:Program error (illegal specification)
	JR	R4
:
: GETSVC - Get a free SVC block
:	Link on R15
:	Normal return if no blocks free
:	Skip return if successfull:
:		R10 = SVC block address
:		R11 = SVC block number
:	Destroys R14
:

GETSVC  L       R10,SBUSED,,    :R10 = bit table of used blocks
	XI	R10,SBBITS	:Complement all the bits
	JFFO	R10,GOTSVC	:Find first free block
	JR	R15		:None found-- normal return

GOTSVC	LHL	R10,SVCTAB,R11,R11	:Get address of block
	J	4,R15		:Skip return
:
: DTTRC - Optional routine to trace disk/tape completions
:
:	Called from DTCHK, Link on R4, Expects:
:		R1 = Parameter block address
:		R2 = Device type
:		R10 = SVC block address
:
:	Destroys R0,R3
:

	IF	DTRACE		:Include only if wanted

DTTRC   LHL     R3,DTRCPT,,     :R3 -> trace table
        STB     R2,DTRCTB,R3,   :Save device type
	LHL	R0,DPUNIT,R1	:Get unit #
        STB     R0,DTRCTB+1,R3,
	LHL	R0,SVCSTA,R10	:Get controller status
        STH     R0,DTRCTB+2,R3,
	L	R0,DPADDR,R1	:Get Pascal data buffer addr
        ST      R0,DTRCTB+4,R3,
	LB	R0,SVCRS,R10	:Get ISIS return status
        STB     R0,DTRCTB+4,R3, :Overwrite 1st byte of address
	L	R0,DPLEN,R1	:Get length
        ST      R0,DTRCTB+8,R3,
	LHL	R0,DPOPER,R1	:Get operation
        STB     R0,DTRCTB+8,R3, :Overwrite 1st byte of length
	L	R0,DPSECT,R1	:Get sector #
        ST      R0,DTRCTB+0C,R3,

	AHI	R3,10		:Increment pointer
	IF	GATRAC
	NHI	R3,07FF
	ELSE
	NHI	R3,0FFF		:Modulo 256
 	EI
        STH     R3,DTRCPT,,     :Save new value
	JR	R4		:Return

	EI	:DTRACE
:
: Entry point definitions for NUCIO
:

	GL	STRT|DSKDEV|,COMP|DSKDEV|,INIT|DSKDEV|,DPRI|DSKDEV|
p	GL	STRT|TAPDEV|,DPRI|TAPDEV|


STRT|DSKDEV|	EQ	DTSTRT		:Start requests
STRT|TAPDEV|	EQ	DTSTRT		:Start requests
COMP|DSKDEV|	EQ	DTCHK		:Check completion
INIT|DSKDEV|	EQ	DTINIT		:Initialize driver

DPRI|DSKDEV|	EQ	DSKPRI		:Priority
DPRI|TAPDEV|	EQ	TAPPRI		:Priority


	EM
	EI	:NDISK+NTAPE
         SUBTTL  Port device driver                       ttydrv.nad
        REMARK  %TTYDRV  V 1.18 02-13-85 AWT

: See the file (ISIS2)NUCLUS.MEM for more revision information.

:
: V 1.18, 12-11-84, AWT
:       Fixed the problem of response message when subhost out of ports.
:
:       Bug fixed in STLWID (set input char width) -- LHL changed to LHI
:
: V 1.17, 07-10-84, AWT
:       Bug fixed in ACTPRT for bell -- initialize BELCOL.
:
:       Bug fixed in FILBUF for TBREAK -- change RBT to TBT.
:
:       Bug fixed in FBCHR6's black balls handling where R4 were changed
:       to R9 (port number).
:
:       Change made in Line Delete operation so it will be carried out
:       "locally" -- use backspaces instead of carriage return -- and
:       therefore control Q will work properly for CRT terminal.
:
:       Change made in Normal Circuit operation so in case of failure
:       the ISIS error code will return to ARG 2 as specified in User's
:       Guide (not to ARG 1 as before).
:
: V 1.16, 01-03-84, AWT
:       Changes made to solve the echo problem when MUX users try
:       to build an aux circuit to host in BUBB-NET.
:
:       Bug fixed in the Readline operation to avoid a crash (14)
:       condition by limiting the maximum number of chars exceeding
:       pascal buffer size to be 0fff (hex).
:
: V 1.15, 09-30-83, AWT
:       Improve the efficiency of data flow by putting data 
:       directly onto ORING, bypassing output buffer.
:  
: V 1.14, 07-25-83, AWT
:       A bug is fixed for line review (crash 6) so only the actual number
:       of characters stored in pascal data buffer are displayed. In addi-
:       tion, port backpressured, reserved bufferlet pool usage and output
:       threshhold for port are all considered in deciding whether line
:       review is allowed to use or not.
: V 1.13, 05-23-83, RNP
:       Bug fixes for line review (crash 3) and bad store
: V 1.12, 05-09-83, AWT
:       A bug is fixed so the alternate break character can be
:       recognized with echo off.
: V 1.11, 03-10-83, AWT
:       Subhost Option support
: V 1.10, 01-26-83, RNP
:       Extended Memory Option support
: V 1.9, 11-15-82, SCY
:	Added a new system default editing character Control-R to
:	be able to review the current line during the read.
:	Added option for user to set up the terminal type -
:	(hard-copy or CRT)
: V 1.8, 09-10-82, SCY
:	Added a time-out option for the get_needle operation.
: V 1.7, 05-19-82, SCY
:	Added a wait option for the TERM_INFO operation.
: V 1.6, 04-05-82, SCY
:	Bugs fixed for handling incoming data in FILBUF.
:	Added a new crash code (32) in FILBUF to crash the slot if
:	 there is a unknown data in the input buffer.
: V 1.5, 03-18-82, SCY
:	Added two new I/O opreation - SEND_SIIX $ SEND_TIIX.
:	Added two new ioresult retruned of read operations which are
:	 start_medium and end_medium for SIIX and TIIX detect in the 
:	 input buffer.
:	Added an host intelligent flag in STATUS2 for successful
:	 get_needle and circuit_built operations.
: V 1.4, 03-15-82, MDS
:	Added code in PTNED3 for port to start in No-Echo mode
: V 1.3, 01-26-82, SCY
:	Changed link register R4 to R9 when called RDYENT
: V 1.2, 12-10-81, SCY
:	Added new I/O operation - Normal circuit request.
:	Added two new i/o operations - set alternate char as breakkey
:	 and Set Bell 
: V 1.1, 10-14-81, SCY
:	Expand sys console operation so that multiple ports can be sys console
: V 1.0, 09-01-81, SMF
:	Initial version
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								:
:	Port device driver module				:
:								:
:	Note: This module assumes that the microcode		:
:	      bufferlet library 'MBUFER.LIB' is being used.	:
:								:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	MO	.,TTYDRV
	RA	0

	LO	COMMON			:Get common symbols
	LO	FRONT			:Use FRONT.LIB symbols

	GL	TSTART,TCHECK,TINIT	:Module entry points
	GL	CONMSG
	GL	TRMDEV,AUXDEV		:Symbols visible outside
	GL	TTYTBL			:Table defined elsewhere

	GL	IOEXIT,RDYENT		:External routines called
	GL	DVREQ			:External variable used
       IF       XMEMRY
        GL      XMCURR,XMPCUR
       EI       :XMEMRY

	IF	\MBUFER
	ELSE				:If MBUFER.LIB is not being used
	REMARK	%%Error - MBUFER.LIB is not being used!
	EI
:
: Constant definitions
:

TRMDEV	EQ	$A 5		:Device type of terminal devices
AUXDEV	EQ	$A 6		:Device type of aux circuit devices

COLON   EQ      $0 3A           :ASCII colon
PERIOD  EQ      $0 2E           :ASCII period
ZERO    EQ      $0 30           :ASCII zero
NINE    EQ      $0 39           :ASCII nine

TRMPRI	EQ	0		:Extra priority for terminal operations
AUXPRI	EQ	0		:Extra priority for aux operations

:
: 	Valid port operations:
:
:		 0 = Read characters
:		 1 = Read line
:		 2 = Send
:		 3 = Disconnect
:		 4 = Clear "Break" status
:		 5 = Set system editing characters
:		 6 = Set terminal information
:		 7 = Send "Yellow Ball"
:		 8 = Detect "Orange Ball"
:		 9 = Aux Circuit Request
:		10 = Get terminal information
:		11 = Send "B1" message
:		12 = Read needle
:		13 = Zap
:		14 = Send supervisor log message
:		15 = Set alternate char as breakkey
:		16 = Set bell column
:		17 = Normal circuit request
:		18 = Send_siix
:		19 = Send_tiix
:
:	Note: There may not be more than 32 operations defined on a
:	    port device.  This is due only to the size of NCBITS (which
:	    is currently a fullword).  If more than 32 operations are
:	    wanted, it will be necessary to make NCBITS and NCFAIL larger.

NTTYOP	EQ	$A 20		:Number of valid operations
MTTYOP	EQ	NTTYOP-1	:Highest legal operation number

NCBITS	EQ	$2 00000100010010100100000000000000
					:Bit array of operations legal when
					:there is no circuit on that device.
					:There must be 16 bits.

NTGRP	EQ	(NTERM+NAUX+0F)/10	:# of halfwords in device bit array
:
: Port driver data structures
:

TTYENT	EQ	.		:TTY info table entry
	ORG	0
TTPORT	HS	1		:Port number or state
TTLNES	HS	1		:Number of lines waiting to be read
TTRPTR	WS	1		:Read buffer pointer
TTRPRM	WS	1		:Read parameter block address
TTRPHD	WS	1		:Read process header
TTRFCT	HS	1		:Number of characters read into buffer
TTRLFT	HS	1		:Space left in read buffer
TTROP	HS	1		:Read operation (-1=None, 0=Char, 1=Line
				:		 10=Term_info)
TTWLFT	HS	1		:Number of characters left to send
TTWPTR	WS	1		:Write buffer pointer
TTWPRM	WS	1		:Write parameter block address
TTWPHD	WS	1		:Write process header address
TTWTIM	WS	1		:SLOWC time to timeout operation

TTEDIT	WS	1		:Editing characters
TTBRK	BS	$A 256/8	:Input break char bit array
TTFLAG	BS	1		:BIT0 =1 ->NORMAL_CIR_REQ, =0 ->AUX_CIR_REQ
				:Bit1 = data buffer empty flag
TBRKEY	BS	1		:Storage for the alternate breakkey
TTEDAK	BS	1		:Bit array for edit chars to acknowledge
TTRMSK	BS	1		:Mask for stripping parity if wanted
TTSHST  HS      1               :Subhost number
	WS	0		:Make sure it ends on word boundary
TTSIZE	EQ	.		:Size of table entry
	ORG	TTYENT

NEDREC	EQ	.		:Needle record
	ORG	0
NEDINV	WS	1		:Invoice number
NEDPRT	WS	1		:Local port #
NEDHST	WS	1		:Local host #
NEDNOD	WS	1		:Originating node #
NEDOHO	WS	1		:Originating host #
NEDOPO	WS	1		:Originating port #
NEDNUM	WS	1		:Number of characters in username
NEDTID	BS	1		:Terminal id
	BS	1		:*Unused*
NEDNAM	BS	$A 24		:Username
NEDSIZ	EQ	.		:Size of needle record
	ORG	NEDREC
:
: Storage for the port driver
:

	SEG	A.DATA

TCRET	WS	1		:Return address for TCHECK
OTCHW	HS	1		:Temp storage for OUTCHK
OCRET	WS	1		:Return address for OUTCHK
TIRET	WS	1		:Return address for TINIT
DEFEDI	WS	1		:Default editing characters
DEFBRK	BS	$A256/8		:Default char break table
TOTAB	WS	NTERM+NAUX	:Timeout table for needle and aux requests
OUTREQ	HS	NTGRP		:Bit array for output requests
TFLSHO	HS	NGRP		:Bit array for flushing output
DEVSEQ	HS	NAUX		:Array of AC request keys
OTHRSH	HS	NPORT		:Output threshhold array
LATEB4	WS	1		:Number of late B4's seen
LATEB6	WS	1		:Number of late B6's seen
LATEB5	WS	1		:Number of late B5's seen
LATE09	WS	1		:Number of late 09's seen
ORBALL	HS	NGRP		:Orange ball bit array
ACSEQ	HS	1		:Last AC sequence number used
TTENT	HS	NTERM+NAUX	:TTY table addresses
TBREAK	HS	NGRP		:Break bit array
PORTDF	HS	NPORT		:Port to device mapping
FLAGS	HS	1		:Waste an HW so first bit won't be #0
FISIS	HS	NGRP		:Flags for buffer input started
TISIS	HS	NGRP		:Flags for buffer output started

	IF	BBMSG
BBTOT	WS	1		:Total number of black balls received
BBCNTR	HS	NPORT		:# black balls not processed yet
BBCT	HS	NPORT		:# chars until first black ball
	EI

NAMBUF  BS      $A 24           :Temp. buffer for username

XBUFR   HS      1

R6SAV   WS      1
REGSAV	WS	1
MSGADR	WS	1
RREGSV	WS	1		:Storage for register
PORTCT	HS	1		:Count of ports available for login
PTSHST  HS      1               :Storage for subhost # request

DEFACK	BS	1		:Default TTEDAK array (on HW bound!)
SYSCON	HS	NGRP		:Bit array of system console port
SYSREQ	HS	NGRP		:Temporary bit array of system console port
COLUMN	HS	NPORT		:The bell column # for each port
BELCOL	HS	NPORT
TRMTYP	HS	NGRP		:Bit array of terminal type (0=hard copy,1=CRT)
SBFLAG  WS      1               :Used for subhost out of ports
SUBSAV  WS      10              :Save registers before output SUBMSG
SUBMSG  SC      /"8D"8ASubhost out of ports"8D"8A/

:
: In-core constants
:

	SEG	A.CODE		:Code segement

NCFAIL	WC	NCBITS		:Storage for NCBITS (see above)

MSGTAB	HS	0		:Table of ISIS messages to break on
	HC	0,0,0		:00-2F
	HC	0,0,0		:30-5F
	HC	0,0,0		:60-8F
	HC	3,806,2E01	:90-BF	  9E,9F,A4,AD,AE,B2,B4,B5,B6,BF
	HC	8000,0,0	:C0-EF    C0
	HC	0		:F0-FF

UMTOTB	HS	0		:Table of ISIS messages not to put in buffer
	HC	0,0,0		:00-2F
	HC	0,0,0		:30-5F
	HC	0,0,0		:60-8F
	HC	0,806,0		:90-BF	  A4,AD,AE (blk ball, org ball, brk)
	HC	0,0,0		:C0-EF
	HC	0		:F0-FF

THRMAP	BC	2,0,0,0,0,0,0,0	:TID -> Threshhold class map
	BC	0,0,0,0,1,1,2,0	:  0=class A, 1=class B, 2=class C
	BC	1,2,2,0,0,0,0,0
	BC	0,0,0,0,0,0,0,0


TEN     HC      $A 10                   :Used in process needle (for MH)

THRTBL	HC	LIMITA,LIMITB,LIMITC	:Threshhold table
:
: TSTART - Start an I/O operation on a port device.
:	Called by NUCIO in module NUCIO:
:		R1 = Address of Pascal Data Buffer
:		R2 = Address of Pascal I/O Parameter Block
:		R3 = Device type # (Terminal or Aux Ckt)
:		R5 = Terminal or Aux Ckt #
:		R8 = Calling process header addr.
:	Return by jumping to IOEXIT in module NUCLUS
:

TSTART	LR	R10,R1		:Copy Pascal buffer addr
      	LR	R11,R2		:Copy parameter block address
	CLHI	R3,AUXDEV	:Aux device?
	JEFS	TSTRT1		:Yes, skip
	LIS	R12,0		:Table offset for terminal devices
	CLHI	R5,NTERM	:Terminal number out of range?
	JFS	TSTRT2		:Skip to test
TSTRT1	LHI	R12,NTERM	:Table offset for aux ckt devices
	CLHI	R5,NAUX		:Circuit number out of range?
TSTRT2	JGE	TSBDUN		:Out of range -- Unit does not exist

	AR	R12,R5		:Internal device number
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
	LHL	R7,OPER,R11	:Get operation number
	CLHI	R7,MTTYOP	:Compare with maximum allowable
	JG	TSPRGE		:Return "Program Error" status if too high
	LH	R9,TTPORT,R13	:Get port number
	JG	TSTRT3		:Skip ahead if device connected
	TBT	R7,NCFAIL	:Check if valid on unconnected device
        JE      TSFAIL

TSTRT3	LR	R4,R7		:Copy operation number
	SLLS	R4,1		:Make halfword offset
	LH	R4,TSTTAB,R4	:Get routine offset for operation
	J	TSTTAB,R4	:Branch to routine
:
:       Terminal Operation Table
:
TSTTAB	EQ	.
	HC	TRMRDC-TSTTAB	:Read characters
	HC	TRMRDL-TSTTAB	:Read line
	HC	TRMSND-TSTTAB	:Send
	HC	TRMDIS-TSTTAB	:Disconnect
	HC	TRMCLB-TSTTAB	:Clear Break
	HC	TRMSS-TSTTAB	:Set system
	HC	TRMST-TSTTAB	:Set terminal
	HC	TRMYEL-TSTTAB	:Send yellow ball
	HC	TRMDET-TSTTAB	:Detect orange ball
	HC	TRMCRQ-TSTTAB	:Request Aux Circuit
	HC	TRMINF-TSTTAB	:Terminal info
	HC	TRMSB1-TSTTAB	:Send B1 message
	HC	TRMNED-TSTTAB	:Read needle
	HC	TRMZAP-TSTTAB	:Zap circuit
	HC	TRMSUP-TSTTAB	:Send supervisor log message
	HC	TRMBRK-TSTTAB	:Set a char as a breakkey
	HC	TRMBEL-TSTTAB	:Set bell
	HC	TRMCRQ-TSTTAB	:Normal circuit request
	HC	TRMSIX-TSTTAB	:Send SIIX cmd
	HC	TRMTIX-TSTTAB	:Send TIIX cmd
:
: Routines to start or perform specific port operations
:	Upon entry:
:		R3 = Device type (terminal or aux)
:		R7 = Operation number
:		R8 = Calling process header
:		R9 = Port number field from term. info table
:		R10 = Pascal data buffer address
:		R11 = Pascal parameter block address
:		R12 = Internal device # (0 - NTERM+NAUX-1)
:		R13 = Terminal information table entry pointer
:

:
: Read character
:

TRMRDC	LH	R0,TTROP,R13	:Any input operation pending?
	JGE	TSBUSY		:Yes, return busy status
	L	R0,ARG1,R11	:Get ARG1 (number of characters to read)
	LR	R1,R0		:Assume we want all at once
	CLHI	R0,MAXCHAR	:Want more than MAXCHAR?
	JLEFS	TRMRC1		:No, skip
	LHI	R1,MAXCHAR	:Else get MAXCHAR at a time
TRMRC1	STH	R1,CHRLIM,R9,R9	:Ask to be awakened in (R1) chars
	J	TRMRD2		:Else get all characters

:
: Read line
:

TRMRDL	LH	R0,TTROP,R13	:Any input operation pending?
	JGE	TSBUSY		:Yes, return busy status
	LHL	R1,COLUMN,R9,R9	:Get bell column #
	STH	R1,BELCOL,R9,R9	:Save for front.lib
	LHI	R1,MAXCHAR	:
	STH	R1,CHRLIM,R9,R9	:Reset CHRLIM to MAXCHAR
	L	R0,ARG1,R11	:Get ARG1 (max # of characters to store)
TRMRD2	STH	R0,TTRLFT,R13	:Save ARG1 as # chars left in buffer
	ST	R10,TTRPTR,R13	:Save Pascal buffer pointer
	ST	R11,TTRPRM,R13	:Save parameter address
	STH	R7,TTROP,R13	:Save operation type
	ST	R8,TTRPHD,R13	:Save requesting process header addr.
	LIS	R0,0
	STH	R0,TTRFCT,R13	:Set # chars read to zero
	LR	R1,R9		:Copy port number
	SLLS	R1,3		:Convert to input buffer pointer
	L	R0,ARG2,R11	:Get # seconds to timeout
	JLEFS	TRMRD3		:None wanted--skip
	JAL	R4,PTTOUT	:Set timeout on port
TRMRD3	JAL	R14,FILBUF	:Try to do the request now
	J	IOEXIT		:Return

:
: Send
:

TRMSND  SBT     R12,OUTREQ,,    :Set output request bit for device
	JN	TSBUSY		:Return busy if output in progress
	ST	R1,TTWPTR,R13	:Save Pascal buffer pointer
	ST	R2,TTWPRM,R13	:Save parameter address
	ST	R8,TTWPHD,R13	:Save requesting process header addr.
	L	R0,ARG1,R11	:Get ARG1 (number of characters to send)
	STH	R0,TTWLFT,R13	:Save as # chars left to send
	L	R0,ARG2,R11	:Get ARG2 (seconds until timeout)
	JLEFS	TRMSN2		:Skip if no timeout wanted
	A	R0,SLOWC,,	:Timeout time
TRMSN2	ST	R0,TTWTIM,R13	:Save timeout time
	J	IOEXIT		:Return

:
: Disconnect
:

TRMDIS	LR	R14,R8		:Copy proc hdr out of the way
	JAL	R4,ZCLEAN	:Clean up tables for port and device
	LR	R1,R9		:Copy port number
	SLLS	R1,3		:Convert to input buffer pointer for port
	JAL	R4,EMPTY	:Empty the input buffer
	AIS	R1,4		:Point to output buffer
	LIS	R0,0		:
	JAL	R4,WCI		:Send special message escape
	LHI	R0,DETMSG	:
	JAL	R4,WCI		:Send Detach message
	LR	R8,R14		:Restore proc hdr
	J	TSCOMP		:Return 'Complete' status

:
: Clear Break status
:

TRMCLB  RBT     R9,TBREAK,,     :Clear break received bit 
        RBT     R9,TFLSHO,,     :Clear flush output bit
	J	TSCOMP		:Return 'Complete' status

:
: Set system parameters
:

TRMSS	L	R1,ARG1,R11	:Get sub-operation
	JL	TSPRGE		:Program error if negative
	CLHI	R1,5		:Too high?
	JG	TSPRGE		:Program error if too high
	JE	TRMSC		:Skip if sub-op = set CRT type terminal
	CLHI	R1,4		:Set hard-copy type terminal's operation?
	JE	TRMSH		:Skip if yes
				:Otherwise, set system editing character
        LA      R2,DEFEDI,,     :R2 -> default edit char table
        LA      R3,DEFBRK,,     :R3 -> default char bit tables
        LA      R5,DEFACK,,     :R5 -> default ack table
	JAL	R4,SETEDI	:Set new default character
	J	TSCOMP		:Return 'Complete' status

TRMSC
	LHI	R2,NPORT-1	:Port # of last port
TRMSC1  SBT     R2,TRMTYP,,     :Set to CRT type
	SIS	R2,1
	JGEBS	TRMSC1
	J	TSCOMP

TRMSH
	LHI	R2,NPORT-1	:Port # of last port
TRMSH1  RBT     R2,TRMTYP,,     :Set to hard-copy type
	SIS	R2,1
	JGEBS	TRMSH1
	J	TSCOMP


:
: Set terminal parameters
:

TRMST	L	R1,ARG1,R11	:Get sub-operation
	JL	TSPRGE		:Program error if negative
	CLHI	R1,$A 11	:Too high?
	JG	TSPRGE		:Program error if so
	LHL	R2,STTBL,R1,R1	:Get sub-operation routine offset
	J	STTBL,R2	:And go to the routine

STTBL	EQ	.
	HC	STECHO-STTBL	:Echo off
	HC	STECHO-STTBL	:Echo on
	HC	STETM-STTBL	:Enter transparency mode
	HC	STLTM-STTBL	:Leave transparency mode
	HC	STNCN-STTBL	:New system console
	HC	STEDIT-STTBL	:Set backspace char
	HC	STEDIT-STTBL	:Set word delete char
	HC	STEDIT-STTBL	:Set line delete char
	HC	STLWID-STTBL	:Set line input char width
	HC	STEDIT-STTBL	:Set line review char
	HC	STTYPH-STTBL	:Set terminal to be hard-copy type
	HC	STTYPC-STTBL	:Set terminal to be CRT type

:
: Echo off/on - These send the appropriate B1 message to ISIS.
:	The Tymsat will (should!) reflect the message, and FRONT.LIB
:	will catch the echo and set its flags accordingly.
:

STECHO	LR	R1,R9		:Copy port number
	SLLS	R1,3		:Make input buffer index
	AIS	R1,4		:Make output buffer index
	LIS	R0,0		:Escape code
	JAL	R4,WCI
	LHI	R0,0B1		:B1 message (set terminal param)
	JAL	R4,WCI
	LIS	R0,0		:N = 0 (echo control)
	JAL	R4,WCI
	L	R0,ARG1,R11	:Value (0=off, 1=on)
	JAL	R4,WCI
	J	TSCOMP		:Operation 'complete'

:
: Enter/Leave transparency mode
:	Sends the appropriate message to ISIS
:

STETM	LR	R1,R9		:Copy port number
	SLLS	R1,3		:Make input buffer index
	AIS	R1,4		:Make output buffer index
	LIS	R0,0		:Escape code
	JAL	R4,WCI
	LHI	R0,0A8		:A8 message (Enter transparency mode)
	JAL	R4,WCI
	J	TSCOMP		:Operation 'complete'

STLTM	LR	R1,R9		:Copy port number
	SLLS	R1,3		:Make input buffer index
	AIS	R1,4		:Make output buffer index
	LIS	R0,0		:Escape code
	JAL	R4,WCI
	LHI	R0,0A9		:A9 message (Leave transparency mode)
	JAL	R4,WCI
	J	TSCOMP		:Operation 'complete'

:
: Set new system console
:

STNCN   TBT     R9,SYSCON,,     :Test the current console port #
	JN	TSFAIL		:Failure if there already is one
        SBT     R9,SYSCON,,     :Else set new one
	J	TSCOMP		:And return 'complete'

:
: Set new editing character
:

STEDIT	CLHI	R1,9		:Set line_review sub-op?
	JNFS	STEDIA		:Skip if not
	SIS	R1,6		:Convert sub-op to edit function #
	JFS	STEDIB
STEDIA	SIS	R1,5		:Convert sub-op to edit function #
STEDIB	LA	R2,TTEDIT,R13	:Address of edit chars
	LA	R3,TTBRK,R13	:Address of break table
	LA	R5,TTEDAK,r13	:Address of ack bit table
	JAL	R4,SETEDI	:Set edit char
	J	TSCOMP		:Operation 'Complete'

:
: Set line input width
:	0 = strip parity, non-zero = keep parity
:

STLWID	LHI	R0,0FF		:Assume we'll want all 8 bits
	L	R1,ARG2,R11	:Get ARG2
	JNFS	STLW2		:Non-zero, skip
	LHI	R0,7F		:Else only want 7 bits
STLW2	STB	R0,TTRMSK,R13	:Set input mask
	J	TSCOMP		:Operation 'Complete'

:
:  Set the terminal type  (0 -> hard copy  1 -> CRT)
:

STTYPH  RBT     R9,TRMTYP,,     :Set the port to be hard-copy type
	J	TSCOMP

STTYPC  SBT     R9,TRMTYP,,     :Set the port to be CRT type
	J	TSCOMP

:
: Send Yellow Ball
:

TRMYEL  RBT     R9,ORBALL,,     :Clear orange-ball-received bit for port
	LR	R1,R9		:Copy port number
	SLLS	R1,3		:Make input buffer index
	AIS	R1,4		:Make output buffer index
	LIS	R0,0		:Escape code
	JAL	R4,WCI
	LHI	R0,YBMSG	:Yellow ball
	JAL	R4,WCI
	J	TSCOMP		:Return 'Complete' status
	
:
: Detect Orange Ball
:

TRMDET  RBT     R9,ORBALL,,     :Has an orange ball come in?
	JE	TSCOMP		:Return 'Complete' if not
	J	TSORBL		:Else return 'Orange-Ball' status

:
: Request Aux/Normal Circuit
:

TRMCRQ	LIS	R0,0
	CLHI	R7,9		:Is this an aux_cir_req ?
	JNFS	TRMCN		:No , skip
	RBT	R0,TTFLAG,R13	:Yes, reset the bit
	J	TRMCA		:Do the aux_cir_req
TRMCN	SBT	R0,TTFLAG,R13	:Set the bit, indicate this is a nor_cir_req
	ST	R10,TTRPTR,R13	:Save pascal data buffer pointer
	ST	R11,TTRPRM,R13	:Save pascal param. block addr
TRMCA	CLHI	R3,AUXDEV	:Is this an Aux Ckt device?
	JN	TSPRGE		:No, do program error return.
	LR	R9,R9		:Test port #/status field
	JN	TSBUSY		:Busy return if device already in use
	LCS	R9,2		:State for building circuit
	STH	R9,TTPORT,R13	:Put in TTY info table
	LHI	R5,-NTERM,R12	:Compute aux device number
	TBT	R0,TTFLAG,R13	:Test the bit if this is nor/aux_cir_req?
	JN	TRMCN0
	LIS	R0,$A 11	:Length of aux ckt request msg
	L	R6,ARG1,R11	:Get length of username string
	AR	R0,R6		:Add to total msg length
	LIS	R1,0		:Message is meant for port 0
	LIS	R2,BLDAUX	:Aux-Circuit-Request message
	J	TRMCA1
TRMCN0	L	R6,ARG1,R11	:GET LOGON STRING'S LENGTH FROM ARG1
	LB	R0,0,R10
	CLHI	R0,0D		:COMPARE WITH CR
	JE	TRMCN1
	SIS	R6,1
	JL	TSPRGE
	AIS	R10,1
	J	TRMCN0
TRMCN1	LIS	R0,$A 11
	LIS	R1,0
	LIS	R2,07		:Pseudo needle req msg code
TRMCA1  JAL     R4,SLOR,,       :Start message directly to output ring
	LIS	R0,0		:External key (meaningless)
	JAL	R4,PUTCH
        LHL     R0,ACSEQ,,      :R0 = previous sequence number
	AIS	R0,1		:Increment
	NHI	R0,$07FFF	:Wrap at 32767 (never becomes negative)
        STH     R0,ACSEQ,,      :Save new sequence number
	STH	R0,DEVSEQ,R5,R5	:Put in table for device
	JAL	R4,PUTH
	LHI	R0,HIQ0		:Load host intelligent flag
	SLHLS	R0,0F
	OHI	R0,$04000	:Set the extended login status return
	JAL	R4,PUTH
	LHI	R0,HOST0	:Originating host number
	JAL	R4,PUTH
	LIS	R0,0
	TBT	R0,TTFLAG,R13
	JN	TRMCN2
	LR	R0,R6		:Size of login string
	JAL	R4,PUTCH
TRMCR1	SIS	R6,1		:Decrement counter
	JLFS	TRMCR2		:Exit loop if negative
	LB	R0,0,R10	:Get character from Pascal buffer
	JAL	R4,PUTCH	:Put in ring
	AIS	R10,1		:Increment buffer pointer
	JBS	TRMCR1		:Loop

TRMCN2	LHI	R0,0CC		:Get TID
	JAL	R4,PUTCH

TRMCR2	JAL	R4,ELOR		:End message
	LIS	R0,1
	SBT	R0,TTFLAG,R13	:Set data buffer is not empty flag
	SLLS	R12,2		:Make fullword pointer for device
	L	R0,SLOWC,,	:Get the current time
	AHI	R0,AUXTIM	:Calculate wakeup time
        ST      R0,TOTAB,R12,   :Put in timeout table
	ST	R8,TTRPHD,R13	:Save process header address
	ST	R11,TTRPRM,R13	:Save parameter block address
	J	IOEXIT		:Exit Nucleus

:
: Get terminal info
:

TRMINF
	LH	R0,TTROP,R13	:Any input operation pending
	JGE	TSBUSY		:Yes, return busy status
	LR	R1,R9		:Copy port number
	SLLS	R1,3		:Make input buffer index
	L	R0,ARG2,R11	:Any timeout value set
	JE	TRMIN1		:No, skip
	JL	TSPRGE
	LHL	R0,BCT,R1	:Any data in bufferlets
	JG	TRMIN1		:Yes, skip
        TBT     R9,TFLSHO,,
	JN	TRMIN1
	LIS	R0,1
	STH	R0,CHRLIM,R9,R9	:Set chrlim to 1
	ST	R11,TTRPRM,R13	:Save pascal param. block addr
	STH	R7,TTROP,R13	:Save operation type
	ST	R8,TTRPHD,R13	:Save requesting proecss header addr
	L	R0,ARG2,R11	:Get # seconds to timeout
	JAL	R4,PTTOUT
	J	IOEXIT
TRMIN1
        LHL     R0,DCT,R1,      :R0 = # of DATA characters in bufferlets
:	LH	R2,TTROP,R13	:Read operation pending?
:	JLFS	TRMIF1		:Skip if not
:	AH	R0,TTRFCT,R13	:Add number of chars in Pascal buffer
TRMIF1	ST	R0,ARG1,R11	:Return in ARG1
	LH	R0,TTLNES,R13	:Get number of lines to be read
	ST	R0,ARG2,R11	:Return in ARG2

	IF	BBMSG		:If black ball option set
	LHL	R0,BBCNTR,R9,R9	:Any black balls?
	JE	TRMIF2		:No, skip
	LH	R0,BBCT,R9,R9	:Number of characters preceding BB
	ST	R0,ARG1,R11	:Use as # chars available
	J	TSTRAN		:Transmission error status
	EI	:BBMSG

TRMIF2  TBT     R9,TFLSHO,,     :Flushing output?
	JN	TSBRK		:Yes, return 'Break' status
	J	TSCOMP		:Else return 'Complete' status

:
: Send B1 message
:

TRMSB1	LR	R1,R9		:Copy port number
	SLLS	R1,3		:Make input buffer index
	AIS	R1,4		:Make output buffer index
	LIS	R0,0		:Escape code
	JAL	R4,WCI
	LHI	R0,0B1		:B1 message
	JAL	R4,WCI
	L	R0,ARG1,R11	:First byte of argument
	JAL	R4,WCI
	L	R0,ARG2,R11	:Second byte of argument
	JAL	R4,WCI
	J	TSCOMP		:Return 'Complete' status

:
: Read needle
:

TRMNED	CLHI	R3,TRMDEV	:Terminal device?
	JN	TSPRGE		:No, return prog. err.
	LR	R9,R9		:Check port #/status
	JN	TSBUSY		:Busy status if port is in use
	LCS	R9,1		:Code for needle wait status
	STH	R9,TTPORT,R13	:Save in TTY information table
        L       R0,ARG1,R11     :Get subhost # from Port_Param record
        JL      TSPRGE          :If less than 0, return prog. err.
        CLHI    R0,$A 9999      :If greater than 9999,
        JG      TSPRGE          :Return prog. error
        STH     R0,TTSHST,R13   :Save subhost # in TTY inform. table
	ST	R8,TTRPHD,R13	:Save calling process header
	ST	R10,TTRPTR,R13	:Save Pascal buffer address
	ST	R11,TTRPRM,R13	:Save parameter block address
	L	R0,ARG2,R11	:Get # seconds to timeout
	JLE	TRMND1		:Skip if no timeout wanted
	SLLS	R12,2		:Compute fullword ptr for device
	A	R0,SLOWC,,
        ST      R0,TOTAB,R12,   :Put in timeout table
TRMND1  LHL     R1,PORTCT,,     :R1 = port count
	AIS	R1,1		:Increment
        STH     R1,PORTCT,,     :Save new port count
	CLHI	R1,1		:Was it zero before?
	JG	IOEXIT		:No, exit
	JAL	R5,REPPRT	:Yes, report to network
	J	IOEXIT		:Exit Nucleus


:
: Send zapper
:

TRMZAP
	LR	R14,R8		:Copy process header addr
	JAL	R4,ZCLEAN	:Clean up
	LR	R1,R9		:Copy port number
	JAL	R5,ZAPPRT	:Call FRONT.LIB routine to zap
	SLLS	R1,3		:Convert to input buffer pointer
	JAL	R4,EMPTY	:Empty input buffer
	LR	R8,R14		:Restore process header
	J	TSCOMP		:Operation complete


:
: Send supervisor log message
:

TRMSUP	LIS	R1,0		:Message for port zero
	LIS	R2,REPSUP	:Message type
	LIS	R0,9		:Message length
        JAL     R4,SLOR,,       :Start message to output ring
	LHL	R0,SLOTNO,,	:Get slot number
	JAL	R4,PUTCH	:Put in message
	L	R0,0,R10	:Get first 4 bytes of msg
	JAL	R4,PUTW		:Put in ring
	LB	R0,4,R10	:Get 5th byte
	JAL	R4,PUTCH	:Put in ring
	JAL	R4,ELOR		:End message
	J	TSCOMP		:Operation complete

:
:  SET A CHARACTER AS A BREAKKEY
:

TRMBRK	LB	R0,0,R10	:Get the new char from pascal data buffer
	LB	R1,TBRKEY,R13	:Get the old break char
	CR	R0,R1		:Compare
	JE	TSCOMP		:Return if they are the same
        LA      R3,DEFBRK,,     :R3 -> default break char bit table
	TBT	R0,0,R3		:Chk if the char had been used as system break
	JN	TSPRGE		:Program error if so
	LA	R3,TTBRK,R13	:Get port break char table
	TBT	R0,0,R3		:Chk if the char'd been used as port edit char
	JN	TSPRGE		:Prog. err if so
	CLHI	R1,0		:Has ever set the break key?
	JE	TRMBR1		:Skip if no
	RBT	R1,0,R3	:Otherwise, reset the old breakkey from break table
	RBT	R1,10,R3
TRMBR1	STB	R0,TBRKEY,R13	:Save the breakkey
	SBT	R0,0,R3		:Break on this char
	SBT	R0,10,R3	:Break on this char with parity
	J	TSCOMP

:
:  SET BELL
:

TRMBEL	L	R1,ARG1,R11	:Get bell column #
	JL	TSPRGE
	STH	R1,COLUMN,R9,R9	:Store in column table
	J	TSCOMP

:
:  Send SIIX
: 

TRMSIX	LIS	R0,3		:Msg length
	LR	R1,R9		:Load port #
	LHI	R2,0BF		:SIIX Cmd
        JAL     R4,SLOR,,
	JAL	R4,ELOR
	J	TSCOMP

:
:  Send TIIX
:

TRMTIX	LIS	R0,3		:Msg length
	LR	R1,R9		:Load port #
	LHI	R2,0C0		:TIIX Cmd
        JAL     R4,SLOR,,
	JAL	R4,ELOR
	J	TSCOMP
:
: Set return status in parameter block and return
:

TSBUSY	LIS	R0,BUSY		:'Busy' status
	J	TSRET

TSBDUN	LCS	R0,1		:'Unit does not exist' code (-1)
	ST	R0,STATS2,R11	:Save in STATUS2
TSFAIL	LIS	R0,FAIL		:'Failure' status
	JFS	TSRET

TSPRGE	LIS	R0,PRGERR	:'Program error' status
	JFS	TSRET

TSBRK	LIS	R0,BKSTAT	:'Break' status
	JFS	TSRET

TSTRAN	LIS	R0,TRANS	:'Transmission error' status
	JFS	TSRET

TSCOMP	LIS	R0,COMPLE	:'Complete' status
	JFS	TSRET

TSORBL	LIS	R0,OBSTAT	:'Orange Ball' status

TSRET	STH	R0,STATUS,R11	:Save status in parameter block
	JAL	R9,RDYENT	:Place calling process in ready queue
	J	IOEXIT		:Exit Nucleus
:
: TCHECK - Check for port I/O
:	Called by NIOCP in module NUCIO
:

TCHECK  ST      R2,TCRET,,      :Save return address
	JAL	R0,INPUT	:Check rings for input
	JAL	R0,OUTCHK	:Check on pending output operations
	JAL	R0,OUTPUT	:Check buffers for output to ISIS
	JAL	R0,ACTOUT	:Check for Aux Ckt request timeouts
        L       R2,TCRET,,      :Restore return address
	JR	R2		:Return

:
: P0PROC - Activation routine for messages on port 0
:	Called by FRONT.LIB:
:		R1 = Port 0 input buffer index
:		R15 = Return address
:	Return through R15 with R0 set to -1.
:

P0PROC	JAL	R4,GCI		:Get message type
	CLHI	R0,AUXERR	:Aux circuit request failure?
	JN	PTFLSH		:No, flush buffer and exit

	JAL	R4,GCI		:Toss external key
	JAL	R4,GCI		:Get local key - high byte
	LIS	R6,0		:Clear register for key
	EXBR	R6,R0		:Put byte in high part of key register
	JAL	R4,GCI		:Get low byte of key
	OR	R6,R0		:Assemble key
	LHI	R5,NAUX	:Get number of aux devices
PT0A	SIS	R5,1		:Decrement counter
	JL	PT0IGN		:Flush message if key not in table
	CH	R6,DEVSEQ,R5,R5	:Is this it?
	JNBS	PT0A		:No, keep trying

	LCS	R0,1
	STH	R0,DEVSEQ,R5,R5	:Clear key entry
	LR	R12,R5		:Copy aux device number
	AHI	R12,NTERM	:Convert to port device number
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
       IF       XMEMRY
        L       R10,TTRPHD,R13  :R10 -> Process Header Record
        LH      R10,XMPSET+4,R10        :R10 = XM Mac set
        JAL     R4,XMCURR       :Make this Proc's Mac set current
       EI       :XMEMRY
	LH	R0,TTPORT,R13	:Get state
	CLHI	R0,-2		:Waiting for aux ckt?
	JL	PT0IGN		:No, ignore msg
	L	R11,TTRPRM,R13	:Get Pascal parameter block address
	JAL	R4,GCI		:Get error code
	ST	R0,ARG2,R11	:Save in ARG2
	LIS	R0,0		:Zero
	STH	R0,TTPORT,R13	:Clear state of device
	SLLS	R12,2		:Convert aux # to fullword pointer
        ST      R0,TOTAB,R12,   :Clear timeout entry
	J	PTFAIL		:Failure return to process

PT0IGN	LIS	R0,1		:Request had already timed out...
        AM      R0,LATE09,,     :Increment late '09' msg counter
	J	PTFLSH		:Flush the rest of the message
:
: PTPROC - Activation routine for messages on user ports
:	Called by FRONT.LIB:
:		R0 = Activation reason
:			(0 = data, -1 = needle, -2 = too many chars,
:			 -3 = flush, -4 = timeout,
:			 otherwise ISIS message type)
:		R1 = Port input buffer index
:		R2 = Activation char (if data)
:		R5 = Invoice number (if needle)
:		R6 = Destination Host # (if needle)
:		R7 = Originating Node # (if needle)
:		R8 = Originating Host # (if needle)
:		R9 = Originating Port # (if needle)
:		R10 = Dialect code (if needle)
:		R11 = TID (if needle)
:		R12 = Number of characters in username (if needle)
:		R15 = Return address
:		In addition, the condition codes will be set for R0.
:	Return through R15 with R0 set to -1.
:

PTPROC	JG	PTMSG		:If R0 > 0, go handle ISIS message
	JE	PTDATA		:If R0 = 0, go handle data
				:It must be some weird FRONT.LIB code.

	CLHI	R0,-4		:Input timeout?
	JE	PTIMOT		:Yes, go handle it

	CLHI	R0,-2		:Too much data?
	JE	PTDATA		:Yes, it counts as as normal data.
	JG	PTNEDL		:If needle, process it
	J	PTEXIT		:Otherwise ignore it.

:
: Process a needle
:

PTNEDL  LHL     R4,PORT,,       :Get port number
	LH	R2,PORTDF,R4,R4	:Get Device number for port
	JGE	PTERR		:Error if already assigned to device!

:
: Get the subhost number, if any, and store it in PTSHST. PTSHST will
: have a value of zero by default.
:
        LIS     R14,0           :New username length
        STH     R14,PTSHST,,    :Also clear PTSHST to zero
        LA      R13,NAMBUF,,    :Get address of username buffer

:
: get the real username first, a colon indicating the end of this name,
: and store it in NAMBUF buffer. R14 now has the true length of this
: username. If no colon is found, subhost number is 0 by default.
:
PTNEDM  JAL     R4,GCI          :Get username character
        NHI     R0,7F           :Mask any high bit
        CLHI    R0,COLON        :Is it a colon?
        JEFS    CHKPRD          :Yes, check if a period followed
        STB     R0,0,R13        :No, put it in username buffer
        AIS     R14,1           :Update the length of username
        AIS     R13,1           :Point at next place in NAMBUF
        SIS     R12,1           :Decrement length count
        JGBS    PTNEDM          :Loop until whole name read
        J       PTNEDN          :If gets here, subhost is 0 by default

:
: Search for a period, which must exist if there is a subhost # 
: other than a zero (which is the value by default).
:
CHKPRD  SIS     R12,1           :Decrement length count
NEXTPD  JAL     R4,GCI          :Get next character
        NHI     R0,7F           :Mask any high bit
        CLHI    R0,PERIOD       :Is it a period?
        JEFS    CHKDIG          :Yes, check if a digit followed
        SIS     R12,1           :Decrement length count
        JGBS    NEXTPD          :Keep checking for a period
        J       SAVECR          :If gets here, subhost is 0 by default
                                :and also go to save the last char CR 

:
: Immediately after a period there can be up to 4 digits (in decimal)
: to represent a subhost number. A nondigit character right after a
: period means a zero for subhost number by default.
:
CHKDIG  SIS     R12,1           :Decrement length count
        LIS     R13,4           :Max. number of subhost digits
NEXTDG  JAL     R4,GCI          :Get next character
        NHI     R0,7F           :Mask any high bit
        CLHI    R0,ZERO         :Is it less than a zero?
        JL      CHECK           :If < 0, is it first char after the . ?
        CLHI    R0,NINE         :Is it greater than a nine?
        JG      CHECK           :If > 9, is it first char after the . ?
        SI      R0,30           :Convert ASCII to decimal
        LHL     R4,PTSHST,,     :Get last decimal number
        MH      R4,TEN          :Multiply by 10
        AR      R4,R0           :Add on the value of last digit
        STH     R4,PTSHST,,     :Save the total as subhost number
        SIS     R12,1           :Decrement length count
        JE      SAVECR          :If it is 0, then end of reading username
                                :and save the last char CR.
        SIS     R13,1           :If not, decrement subhost digits count
        JG      NEXTDG          :If count is not 0, look for next digit
        JFS     NEXTCH          :If it is 0, scan the rest chars in buffer

CHECK   SIS     R12,1           :Decrement length count
        JEFS    SAVECR          :If count is 0, save the last char CR.

:
: Scan the rest of characters in buffer
:
NEXTCH  JAL     R4,GCI          :Scan the rest of chars in input buffer
        SIS     R12,1           :Decrement length count        
        JGBS    NEXTCH          :If count > 0, continue to scan
SAVECR  NHI     R0,7F           :Otherwise, mask any high bit and 
        STB     R0,0,R13        :save the last char CR in NAMBUF.
        AIS     R14,1           :Update the username length


:
: Get the device which has a needle wait and also a subhost number
: matched with the port's. If none is found, ignore the needle.   
:
PTNEDN  LR      R12,R14         :Save the new username length
        LHL     R4,PORT,,       :Restore R4
	LIS	R2,0		:Start with device number zero
        ST      R2,SBFLAG,,     :Clear Subhost flag
	LA	R13,TTYTBL,,	:Get address of first table entry
	LHI	R3,NTERM	:Number of terminals
     
PTNED0  SIS     R3,1            :Decrement terminals count
        JL      SUBOUT          :Ignore needle if no available terminal
	LH	R0,TTPORT,R13	:Get port # for device
	CLHI	R0,-1		:Needle wait?
        JEFS    PTNED1          :Yes, go to check subhost number
        LR      R0,R0
        JLE     NEXTDV
        LIS     R0,1
        ST      R0,SBFLAG,,
NEXTDV  AIS     R2,1            :Increment device number
	AHI	R13,TTSIZE	:Point to next table entry
	J  	PTNED0		:Loop

PTNED1  LIS     R0,1
        ST      R0,SBFLAG,,     :Setthe flag
        LH      R0,TTSHST,R13   :Get that device's subhost number
        CLH     R0,PTSHST,,     :Is it matched with user's subhost # ?
        JNBS    NEXTDV          :No, try next device

:
: Bind the device to port and continue to process the needle
:
PTNED2  STH     R2,PORTDF,R4,R4 :Bind device to port
	SLLS	R2,2		:Convert to fullword ptr
	LIS	R0,0
        ST      R0,TOTAB,R2,    :Clear timeout table entry for this device
	STH	R4,TTPORT,R13	:And vice-versa
       IF       XMEMRY
        LR      R3,R10          :Save R10
        L       R10,TTRPHD,R13  :R10 -> Process Header Record
        LH      R10,XMPSET+4,R10        :R10 = XM Mac set
        JAL     R4,XMCURR       :Make this Proc's Mac set current
        LR      R10,R3          :Restore R10
        LHL     R4,TTPORT,R13   :Restore R4
       EI       :XMEMRY
	L	R3,TTRPTR,R13	:Get data address
	ST	R4,NEDPRT,R3	:Save destination port # in data block
	ST	R5,NEDINV,R3	:Save invoice number
	ST	R6,NEDHST,R3	:Save destination host #
	ST	R7,NEDNOD,R3	:Save originating node #
	ST	R8,NEDOHO,R3	:Save originating host #
	ST	R9,NEDOPO,R3	:Save originating port #
	L	R2,TTRPRM,R13	:Get addr of pascal param. block
	SRHLS	R10,0F
	ST	R10,STATS2,R2	:Save the source intelligent flag
	STB	R11,NEDTID,R3	:Save terminal identifier
	ST	R12,NEDNUM,R3	:Save length of username
	LR	R9,R4		:Copy port number
	LA	R10,NEDNAM,R3	:Point R10 at where username goes

PTNED3  LA      R14,NAMBUF,,    :Get address of username buffer

NEXTC   LB      R0,0,R14        :Get username character
        STB     R0,0,R10        :Put in data block
        AIS     R14,1           :Point to next char in NAMBUF
        AIS     R10,1           :Point to next position in NEDNAM
        SIS     R12,1           :Decrement username length count
        JGBS    NEXTC           :Loop until whole name read


  IF	INECHO			:Initial No-echo state?
        SBT     R9,ECHOFF,,     :Yes, set off
  ELSE
        RBT     R9,ECHOFF,,     :Clear echo off bit for port
  EI

	NHI	R11,1F		:Mask status bits off TID
	LB	R2,THRMAP,R11	:Get circuit class for this TID
	LHL	R2,THRTBL,R2,R2	:Get output threshhold for this class
	STH	R2,OTHRSH,R9,R9	:Put in table for prt

	IF	ACECHO		:If aux ckt echo wanted
	LR	R11,R11
	JEFS	PTNED4		:Jump if aux ckt
	CLHI	R11,$A 14	:Aux ckt through gateway?
	JNFS	PTNED5		:No, skip
PTNED4  SBT     R9,DEM,,        :Start port in deferred echo mode
PTNED5
	EI	:ACECHO

	IF	LPROMP		:If login prompt wanted
	AIS	R1,4		:Point at output buffer
	LHI	R0,20		:Space
	JAL	R4,WCI
	LHI	R0,0A		:Linefeed
	JAL	R4,WCI
	LHI	R0,0D		:Carriage return
	JAL	R4,WCI
	LHI	R0,3E		:'>'
	JAL	R4,WCI
	EI	:LPROMP

	LCS	R1,1		:Get -1
        AHM     R1,PORTCT,,     :Decrement PORTCT
	JGFS	ACTPRT		:Skip if ports still available
        ST      R15,RREGSV,,    :Save return address
	JAL	R5,REPPRT	:Report no ports available
        L       R15,RREGSV,,    :Restore return address
:
: Common code to activate the port
:

ACTPRT
	LIS	R0,0
	STB	R0,TBRKEY,R13	:No breakkey set initially
        L       R0,DEFEDI,,     :R0 = default editing characters
	ST	R0,TTEDIT,R13	:Save in table for device
        LB      R0,DEFACK,,     :Editing chars to acknowledge
	STB	R0,TTEDAK,R13	:Put in TTY table
	LA	R2,TTBRK,R13	:Get address of device break table
	LR	R4,R9		:Copy port number
	SLLS	R4,2		:Convert to fullword pointer
        ST      R2,BREAK,R4,    :MAKE THIS THE PORT'S BREAK TABLE
        LA      R1,DEFBRK+1E,,  :Last halfword of default break table
	AHI	R2,1E		:Last halfword of device break table
	LHI	R3,0F0		:Move 16 halfwords [10x * (n - 1)]
	COPY	R1,R3		:Copy default break table to device's table
	LHI	R0,7F		:Init mask to strip parity
	STB	R0,TTRMSK,R13	:Save in TTY table

	LIS	R0,0
	STH	R0,TTLNES,R13	:Initialize to no lines in buffer
        RBT     R9,TBREAK,,     :Clear break detect
        RBT     R9,TFLSHO,,     :Clear flush output
        RBT     R9,ORBALL,,     :Clear orange ball
	STH	R0,COLUMN,R9,R9	:Initialize to no bell at column #
        STH     R0,BELCOL,R9,R9 :Clear out the leftover from last connection.

	IF	BBMSG
	STH	R0,BBCT,R9,R9	:Start with no black balls
	STH	R0,BBCNTR,R9,R9
	EI

	J	PTCOMP		:Activate process with 'Complete' status

SUBOUT  L       R0,SBFLAG,,     :See if it is due to subhost out of ports
        JE      PTINED          :No, use zapper
        RBT     R4,ACP,,
        STM     R0,SUBSAV,,
        LHL     R2,PORT,,
        LA      R3,SUBMSG,,
        JAL     R5,OCS,,
        LM      R0,SUBSAV,,
        JAL     R4,EMPTY,,      :Clear the input buffer
        AIS     R1,4            :Point to output buffer
        JAL     R4,EMPTY        :Clear it too
        LIS     R0,3            :detach message length
        LHL     R1,PORT,,
        LHI     R2,DETMSG
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
        J       INPUT1

:
: We don't want the circuit!
:

PTINED  RBT     R4,ACP,,        :Tell FRONT.LIB to make it go away
	JAL	R4,EMPTY	:Clear the input buffer
	AIS	R1,4		:Point to output buffer
	JAL	R4,EMPTY	:Clear it, too
	J	PTEXIT		:Ignore needle
:
: Process an ISIS mesage
:	R0 = Message type
:
:	Note that Orange Balls, Breaks, and Black Balls are not put
:	into the input buffer by FRONT.LIB.
:

PTMSG	CLHI	R0,OBMSG	:Orange ball?
	JN	PTMSG1		:No, try another

        LHL     R9,PORT,,       :Get port number
        SBT     R9,ORBALL,,     :Set Orange-Ball-Received for port
	J	PTEXIT		:Done processing message



PTMSG1	CLHI	R0,BRKMSG	:Break detect?
	JN	PTMSG2		:No, try another

PTMSGB	LH	R12,PORTDF,R9,R9	:Get device number for prt
	JL	PTEXIT		:Ignore if port not assigned
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
       IF       XMEMRY
        L       R10,TTRPHD,R13  :R10 -> Process Header Record
        LH      R10,XMPSET+4,R10        :R10 = XM Mac set
        JAL     R4,XMCURR       :Make this Proc's Mac set current
       EI       :XMEMRY
	JAL	R4,EMPTY	:Empty input buffer
	AIS	R1,4		:Point to output buffer
	JAL	R4,EMPTY	:Empty output buffer
        LHL     R9,PORT,,       :Get port number
        SBT     R9,TFLSHO,,     :Set Flush-Output for port
	LIS	R0,0
        STH     R0,TTLNES,R13   :No lines in buffer

	IF	BBMSG		:If we want black ball info
	STH	R0,BBCT,R9,R9	:Cancel any black balls which came in
	STH	R0,BBCNTR,R9,R9
	EI	:BBMSG

	JAL	R4,WCI		:Send escape code
	LHI	R0,GOBMSG	:Send gobbler
	JAL	R4,WCI
	LHI	R0,BBELL	:Send bell
	JAL	R4,WCI

        SBT     R9,TBREAK,,     :Set Break Received 
	SIS	R1,4		:Back to input buffer
	J	PTDCHK		:See if input operation pending
PTMSG2	CLHI	R0,PNDMSG	:Pseudo needle?
	JN	PTMSG3		:No, try another
	JAL	R4,GCI		:Skip over escape code
	JAL	R4,GCI		:Skip msg type (B2)
	JAL	R4,GCI		:Skip external key
	JAL	R4,GCI		:Get local key - high byte
	LIS	R6,0		:Clear register for key
	EXBR	R6,R0		:Put byte in high part of key register
	JAL	R4,GCI		:Get low byte of key
	OR	R6,R0		:Assemble key
	LHI	R5,NAUX	:Get number of aux devices
PT2A	SIS	R5,1		:Decrement counter
	JL	PTEXIT		:Ignore message if key not in table
	CH	R6,DEVSEQ,R5,R5	:Is this it?
	JNBS	PT2A		:No, keep trying

	LCS	R0,1
	STH	R6,DEVSEQ,R5,R5	:Remove key entry
	LR	R12,R5		:Copy aux device number
	AHI	R12,NTERM	:Convert to port device number
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
	LH	R0,TTPORT,R13	:Get state
	CLHI	R0,-2		:Waiting for aux ckt?
	JN	PTEXIT		:No, ignore msg
        LHL     R9,PORT,,       :Get port number
	STH	R12,PORTDF,R9,R9	:Save device number for port
	LIS	R0,0
	TBT	R0,TTFLAG,R13	:Check if this is an nor_cir_req ?
	JN	PT2N1		:Yes, go to handle the sent of logon string
	J	PTEXIT		:Done processing message

PT2N1	ST	R15,RREGSV,,	:Store the link reg15
	L	R12,TTRPTR,R13	:Get the pascal data buffer addr
       IF      XMEMRY
        LR      R9,R10
        L       R10,TTRPHD,R13
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
        LR      R10,R9
       EI       :XMEMRY
	LIS	R9,1		:R9 is a counter
PT2N2	LB	R0,0,R12
	CLHI	R0,3B		:Compare with semi_column
	JE	SEM1
	CLHI	R0,0D		:Compare with carrage_return
	JE	SEM1
	AIS	R9,1		:Incre. counter
	AIS	R12,1		:Update buffer addr
	J	PT2N2

SEM1	L	R12,TTRPTR,R13	:Get the pascal data buffer addr
        LHL     R1,PORT,,
	LHI	R2,NLOGCH	:Load char B3
SEMLOP	LIS	R0,$A 4		:4 Byte length
        JAL     R4,SLOR,,
	LB	R0,0,R12
	OHI	R0,80		:Force high order bit on
	JAL	R4,PUTCH
	JAL	R4,ELOR
	AIS	R12,1
	SIS	R9,1
	JG	SEMLOP
	L	R15,RREGSV,,
	J	PTEXIT
:
:       Circuit Build Message
:
PTMSG3	CLHI	R0,LOGOK	:Circuit built message?
	JN	PTMSG4		:No, try another

        LHL     R9,PORT,,       :Get port number
	LH	R12,PORTDF,R9,R9	:Get device number
	JL	PT3IGN		:Ignore message if port not assigned
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
	STH	R9,TTPORT,R13	:Bind port to device
       IF       XMEMRY
        LR      R2,R10
        L       R10,TTRPHD,R13
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
        LR      R10,R2
       EI
	LR	R2,R12		:Copy it
	SLLS	R2,2		:Convert to fullword pointer
	LIS	R0,0		:Get zero
        ST      R0,TOTAB,R2,    :Clear timeout entry
	LHI	R0,LIMITC	:Class C output threshhold
	STH	R0,OTHRSH,R9,R9	:Put in table for port

	JAL	R4,GCI		:Pass over all chars in B6
	JAL	R4,GCI		:(B6)
	JAL	R4,GCI		:(IIX)
	NHI	R0,1
	L	R4,TTRPRM,R13
	ST	R0,STATS2,R4
	JAL	R4,GCI		:(Invoice # - 4 bytes)
	JAL	R4,GCI
	JAL	R4,GCI
	JAL	R4,GCI
	JAL	R4,GCI		:(Orig. host - 2 bytes)
	JAL	R4,GCI
	J	ACTPRT		:Finish activation for port

PT3IGN	LIS	R0,1		:Request had already timed out...
        AM      R0,LATEB6,,     :Increment late 'B6' msg counter
	AIS	R1,4		:Point at output buffer
	LIS	R0,0		:Escape code
	JAL	R4,WCI
	LHI	R0,DETMSG	:Detach message
	JAL	R4,WCI
	SIS	R1,4		:Point back to input buffer
	J	PTFLSH		:Flush message
PTMSG4	CLHI	R0,LOGFAL	:Logon failure?
	JN	PTMSG5		:No, try another

        LHL     R9,PORT,,       :Get port number
	LH	R12,PORTDF,R9,R9	:Get device #
	JL	PT4IGN		:Ignore message if port not assigned
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
       IF       XMEMRY
        LR      R2,R10
        L       R10,TTRPHD,R13
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
        LR      R10,R2
       EI       :XMEMRY
	LR	R2,R12		:Copy it
	SLLS	R2,2		:Convert to fullword pointer
	LIS	R0,0		:Get zero
        ST      R0,TOTAB,R2,    :Clear timeout entry
	STH	R0,TTPORT,R13	:Clear state of device
	LCS	R2,1		:Get -1
	STH	R2,PORTDF,R9,R9	:Unbind port
	L	R11,TTRPRM,R13	:Get parameter block address
	JAL	R4,GCI		:Skip escape code
	JAL	R4,GCI		:Skip B5 code
	JAL	R4,GCI		:Get reason
	ST	R0,ARG2,R11	:Return in ARG2
	J	PTFAIL		:Failure return to process

PT4IGN	LIS	R0,1		:Request had already timed out...
        AM      R0,LATEB5,,     :increment late 'B5' msg counter
	J	PTFLSH		:Flush the message
PTMSG5	CLHI	R0,ZAPMSG	:Zapper or detach?
	JG	PTMSG6		:No, try something else

	JAL	R4,GCI		:Clear from buffer
	JAL	R4,GCI
        LHL     R9,PORT,,       :Get port number
	LH	R12,PORTDF,R9,R9	:Get device #
	JL	PTEXIT		:Ignore if device not connected
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
       
       IF       XMEMRY
        LR      R1,R10
        L       R10,TTRPHD,R13
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
        LR      R10,R1
       EI       :XMEMRY
	JAL	R4,ZCLEAN	:Clean up tables for port and device
	J	PTEXIT		:Done processing msg



PTMSG6	CLHI	R0,BLKMSG	:Black ball?
	JN	PTMSG7		:No, try something else

	IF	BBMSG		:Process only if we want to see them
        LHL     R9,PORT,,       :Get port #
	LH	R12,PORTDF,R9,R9	:Get device number for prt
	JL	PTEXIT		:Ignore if port not assigned
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
       IF       XMEMRY
        LR      R3,R10
        L       R10,TTRPHD,R13
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
        LR      R10,R3
       EI       :XMEMRY
	LHL	R3,BBCNTR,R9,R9	:Get number of black balls waiting
	JNFS	PTMS61		:Skip if not first black ball
        LHL     R0,DCT,R1,      :Get input char count (ahead of black ball)
	STH	R0,BBCT,R9,R9	:Save # chars ahead of BB

PTMS61	LIS	R0,1
	AHM	R0,BBCNTR,R9,R9	:Increment # of black balls seen
        AM      R0,BBTOT,,      :AND TOTAL # FOR SLOT
	J	PTDCHK		:Go check for read on port
	ELSE
	J	PTEXIT		:Ignore msg
	EI	:BBMSG


PTMSG7	CLHI	R0,NLOGST	:Normal logon status
	JN	PTMSG8		:No, try something else
        LHL     R9,PORT,,
	LH	R12,PORTDF,R9,R9	:Get device #
	JL	PT7IGN		:Ignore if port not assigened
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
       IF       XMEMRY
        LR      R12,R10
        L       R10,TTRPHD,R13
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
        LR      R10,R12
       EI       :XMEMRY
	L	R12,TTRPTR,R13	:Get pascal data buffer addr
	ST	R15,RREGSV,,
	L	R11,TTRPRM,R13	:Get pascal param. block addr
PT7G0	JAL	R4,GCI
	LR	R0,R0		:
	JNBS	PT7G0		:Loop until skip the escape code
	JAL	R4,GCI
	LR	R0,R0
	JE	PT7G0		:Loop until skip the B4 code
	JAL	R4,GCI		:Get status
	NHI	R0,$001F
	ST	R0,ARG2,R11	:Save the B4 status in ARG1
	CLHI	R0,0		:Continue status ?
	JN	ZB2CIR		:Jump to zap the pseudo circuit

PT7A
	LIS	R0,1
	RBT	R0,TTFLAG,R13	:Reset the data buffer empty flag
	JE	PTEXIT		:Ignore if data buffer is empty
PT7A0	LB	R0,0,R12
	CLHI	R0,3B		:Is the semi column?
	JE	PT7A1
	CLHI	R0,0D		:Is the CR?
	JE	PT7A1
	AIS	R12,1		:Update the data buffer addr
	J	PT7A0		:Loop until find the semi_column or CR
PT7A1   LHL     R1,PORT,,
	LHI	R2,NLOGCH	:Get B3
PT7A2	LIS	R0,$A 4
        JAL     R4,SLOR,,
	AIS	R12,1
	LB	R0,0,R12
	OHI	R0,80		:Force the high order bit on
	JAL	R4,PUTCH
	JAL	R4,ELOR
	CLHI	R0,08D		:Is CR?
	JN	PT7A2
	L	R15,RREGSV,,
	J	PTEXIT

PT7IGN	LIS	R0,1		:Request had already timed out
        AM      R0,LATEB4,,     :Increment late 'B4' msg counter
	J	PTFLSH		:Flush the msg

PTMSG8
	CLHI	R0,SIIX
	JN	PTMSG9
	LH	R12,PORTDF,R9,R9	:GET DEVICE # FOR PORT
	JL	PTEXIT		:IGNORE IF NOT ASSIGNED
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
	LIS	R2,1
        AHM     R2,DCT,R1,      :Increment DCT
	J	PTDCHK		:GO HANDLE IT


PTMSG9
	CLHI	R0,TIIX
	JN	PTFLSH
	LH	R12,PORTDF,R9,R9	:GET DEVICE # FOR PORT
	JL	PTEXIT
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
	LIS	R2,1
        AHM     R2,DCT,R1,
	J	PTDCHK
:
: Data message on port
:	R2 = Activation character
:

PTDATA  LHL     R9,PORT,,       :Get port number
	LH	R12,PORTDF,R9,R9	:Get device #
	JL	PTFLSH		:Not connected to device, flush message
	LHL	R13,TTENT,R12,R12	:Get TTY table entry addr
       IF       XMEMRY
        L       R10,TTRPHD,R13  :R10 -> Process Header Record
        LH      R10,XMPSET+4,R10        :R10 = XM Mac set
        JAL     R4,XMCURR       :Make this Proc's Mac set current
       EI       :XMEMRY
	LR	R0,R0		:Was this a data activation?
	JL	PTDCHK		:No, go try to put in Pascal buffer
	NHI	R2,7F		:Remove parity bit from activation char
	CLHI	R2,0D		:Carriage return?
	JNFS	PTD1		:No, try something else
	LIS	R0,1
	AHM	R0,TTLNES,R13	:Increment line count
        TBT     R9,DEM,,        :Deferred echo mode?
	JNFS	PTD2		:Yes, echo a linefeed
	J	PTDCHK		:Else try to put in Pascal buffer

PTD1	CLHI	R2,0A		:Linefeed?
	JN	PTD3		:No, must be an edit character.
        TBT     R9,DEM,,        :Deferred echo mode?
	JE	PTDCHK		:No, try to put in Pascal buffer

PTD2    TBT     R9,ECHOFF,,     :Echoing off on this port?
	JN	PTDCHK		:Yes, don't echo
	LR	R0,R2		:Activation character (CR or LF)
	XHI	R0,0D%0A	:Convert to the other
	AIS	R1,4		:Point to output buffer
	JAL	R4,WCI		:Output char
	SIS	R1,4		:Point back to input buffer
	J	PTDCHK		:Go try to fill Pascal buffer


PTD3    CLB     R2,TTEDIT,R13   :Backspace character?
	JN	PTD4		:No, try another
        TBT     R9,ECHOFF,,     :Echoing off on this port?
        JN      PTDCHK          :Yes, don't echo
	LIS	R0,0		:Position of BS bit
	TBT	R0,TTEDAK,R13	:Acknowledge BS?
	JE	PTDCHK		:No, go try to read data
	AIS	R1,4		:Point to output buffer
        TBT     R9,TRMTYP,,     :Test the terminal type bit
	JE	PTD3B		:Skip if it is hard-copy terminal
	CLHI	R2,BACKSP	:Is backspace char?
	JE	PTD3A		:Skip if yes
	LHI	R0,BACKSP	:Echo backspace character
	JAL	R4,WCI		:Send it
PTD3A	LHI	R0,BLANK
	JAL	R4,WCI
	LHI	R0,BACKSP
	J	PTD6
PTD3B	LHI	R0,CHDEL	:Echo character delete symbol
	J	PTD6		:Go send it

PTD4	CLB	R2,TTEDIT+1,R13	:Word delete character?
        JN      PTD5            :no, try another
        TBT     R9,ECHOFF,,     :Echoing off on this port?
        JN      PTDCHK          :Yes, don't echo
	LIS	R0,1		:Position of WD bit
	TBT	R0,TTEDAK,R13	:Acknowledge WD?
	JE	PTDCHK		:No, go try to read data
        TBT     R9,TRMTYP,,     :Check what type of terminal?
	JN	PTDCHK		:Skip if CRT type
	LHI	R0,WDDEL	:Echo word delete character
	AIS	R1,4		:Point to output buffer
	J	PTD6		:Go send it

PTD5	CLB	R2,TTEDIT+2,R13	:Line delete char
	JN	PTD7		:No, try another
        TBT     R9,ECHOFF,,     :Echoing off on this port?
        JN      PTDCHK          :Yes, don't echo
	LIS	R0,2		:Position of LD bit
	TBT	R0,TTEDAK,R13	:Acknowledge LD?
	JE	PTDCHK		:No, go try to read data
        TBT     R9,TRMTYP,,     :Check what type of terminal?
	JNFS	PTDCHK		:Skip if CRT type
	LIS	R0,0D		:Carriage return
	AIS	R1,4		:Point to output buffer
	JAL	R4,WCI		:Send it
	LIS	R0,0A		:Linefeed

PTD6	JAL	R4,WCI		:Send it
	SIS	R1,4		:Point back to input buffer

PTDCHK	JAL	R14,FILBUF	:Try to fill Pascal buffer
	J	PTEXIT		:Done with msg

PTD7
	CLB	R2,TTEDIT+3,R13	:Line review key?
	JN	PTMSGB		:No, must be break char. go handle it.
	J	PTDCHK		:Go try to handle the line review

:
: Timeout on port
:

PTIMOT  LHL     R9,PORT,,       :Get port number
	LH	R12,PORTDF,R9,R9	:Get device # for port
	JL	PTEXIT		:Ignore if not attached
	LHL	R13,TTENT,R12,R12	:Get TTY info block addr
       IF       XMEMRY
        L       R10,TTRPHD,R13  :R10 -> Process Header Record
        LH      R10,XMPSET+4,R10        :R10 = XM Mac set
        JAL     R4,XMCURR       :Make this Proc's Mac set current
       EI       :XMEMRY
	LH	R0,TTROP,R13	:Get read operation
	JL	PTEXIT		:Ignore if no read pending
	CLHI	R0,$A 10	:Is term_info operation
	JN	PTIMO1
	L	R11,TTRPRM,R13	:Get pascal param. block addr
	LIS	R0,0
	ST	R0,ARG1,R11
	ST	R0,ARG2,R11
	LHI	R0,MAXCHAR
	STH	R0,CHRLIM,R9,R9	:Set limit
	J	PTIMO2
PTIMO1
	JAL	R14,FILBUF	:Get rest of input
	LH	R0,TTROP,R13	:Get operation
	JL	PTEXIT		:Exit if op finished
	LHL	R0,TTRFCT,R13	:Get # of chars in Pascal buffer
	ST	R0,ARG2,R11	:Save in ARG2
PTIMO2
	LCS	R0,1	
	STH	R0,TTROP,R13	:Clear read/term_info operation
	LIS	R0,TIMEOU	:Timeout status
	J	PTACT		:Go activate process
:
: ZAP THE PSEUDO NEEDLE CIRCUIT BECAUSE OF THE INCORRECT LOGON STRING
:
ZB2CIR	LIS	R0,0
	LCS	R1,1
	STH	R0,TTPORT,R13
	STH	R1,PORTDF,R9,R9
        LHL     R1,PORT,,       :Copy port #
	JAL	R5,ZAPPRT	:Call Front.lib routine to zap
	SLLS	R1,3		:Convert to input buffer pointer
	JAL	R4,EMPTY	:Empty input buffer
	L	R15,RREGSV,,

:
: Return 'failure' status to process
:

PTFAIL	LIS	R0,FAIL		:Failure status
	JFS	PTACT		:Activate process	
:
: Return 'completion' status to process
:

PTCOMP	LIS	R0,COMPLE	:Complete status

PTACT	L	R11,TTRPRM,R13	:Get addr of Pascal parameter block
	STH	R0,STATUS,R11	:Save return status
PTACT1	L	R8,TTRPHD,R13	:Get process header addr
	JAL	R9,RDYENT	:Put process on ready queue
	J	PTEXIT		:Return

:
: Flush the input buffer, then return
:

PTFLSH	JAL	R4,EMPTY	:Empty input buffer

PTEXIT	LCS	R0,1		:Don't change timeout status
	JR	R15		:Return to FRONT.LIB

:
: Fatal error!!!
:

PTERR	JAL	R10,CRASH,,	:Kill the slot
	BC	0,0,0,30
:
: FILBUF - Routine to try to move characters from input bufferlets to the
:		Pascal data buffer.
:	Expects:
:		R1 = Input buffer pointer
:		R9 = Port number
:		R13 = TTY table entry pointer
:		Link on R14
:

FILBUF
	LH	R2,TTROP,R13	:Get read operation for device
	JLR	R14		:Return if none pending
       IF       XMEMRY
        LR      R11,R10
        L       R10,TTRPHD,R13
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
        LR      R10,R11
       EI       :XMEMRY
	L	R11,TTRPRM,R13	:Get Pascal parameter block address
        TBT     R9,TBREAK,,     :Break detected on this port?
	JN	FBBRK		:Yes, abort read operation
	CLHI	R2,$A 10	:Is term_info operation?
	JN	FILBU1		:Skip if not
        LHL     R0,DCT,R1,      :Get # of data characters in bufferlets
	ST	R0,ARG1,R11	:Return in arg1
	LH	R0,TTLNES,R13	:Get # of lines to be read
	ST	R0,ARG2,R11	:Return in arg2
	LHI	R0,MAXCHAR	:
	STH	R0,CHRLIM,R9,R9	:Set limit
	LIS	R8,COMPLE
	J	FBACT
FILBU1

	LR	R2,R2		:Check operation type
	JG	FBLIN		:Jump if read line

	LIS	R8,COMPLE	:Assume complete status
	LHL	R5,TTRLFT,R13	:Get number of characters left to read

	IF	BBMSG		:If we are handling black balls
	LH	R3,BBCNTR,R9,R9	:Any black balls?
	JLE	FBCHR		:No, normal
	LH	R2,BBCT,R9,R9	:Get # chars ahead of BB
	SR	R2,R5		:Subtract # chars left in request
	STH	R2,BBCT,R9,R9	:Save new BBCT
	JGE	FBCHR		:Finish request if possible
	LIS	R8,TRANS	:Transmission error code
	LIS	R3,0		:Clear char count
	STH	R3,BBCT,R9,R9	:Save it
	AR	R5,R2		:Shorten request to BBCT chars
	JG	FBCHR		:Finish request if any chars
	STH	R3,BBCNTR,R9,R9	:Otherwise clear BB count
	ST	R3,ARG2,R11	:Returning no characters
	J	FBACT		:Request finished
	EI	:BBMSG

FBCHR
:	LR	R6,R5		:Assume we'll finish request
:       CLH     R6,DCT,R1,      :Is that much in the bufferlets?
:	CLH	R6,BCT,R1
:	JLFS	FBCHR1		:Yes, skip
	LHL	R6,BCT,R1	:Else use the lesser amount

FBCHR1
	L	R10,TTRPTR,R13	:Get Pascal buffer pointer
	LHL	R7,TTRFCT,R13	:Get count of chars in buffer
FBCHR2
	SIS	R6,1		:Decrement counter
	JL	FBCHR4		:Exit loop if done
	JAL	R4,GCI		:Get character
	LR	R0,R0		:Is escape char?
	JN	FBCH2A		:Skip if not
	SIS	R6,1		:Decrement counter
	JAL	R4,GCI		:Get msg code
	LR	R0,R0		:Is null data?
	JE	FBCH2A		:Skip if yes
	ST	R7,ARG2,R11	:Store # chars read in arg2
	CLHI	R0,0BF		:Is SIIX command code?
	JE	FBSIX		:Yes, return the startmedium status
	CLHI	R0,0C0		:Is TIIX command code?
	JE	FBTIX		:Yes, return end medium status
	JAL	R10,CRASH,,	:Crash with unknown data
	BC	0,0,4*R14,$032
FBCH2A	LCS	R3,1
        AHM     R3,DCT,R1,      :Decrement the data counts
	STB	R0,0,R10	:Store in Pascal data buffer
	NHI	R0,7F		:Strip parity
	CLHI	R0,0D		:Carriage return?
	JNFS	FBCHR3		:No, skip
	LCS	R0,1		:Get a -1
	AHM	R0,TTLNES,R13	:Decrement line count
FBCHR3
	AIS	R7,1		:Increment # in buffer
	AIS	R10,1		:Increment PDB pointer
	SIS	R5,1		:Decrement # left to completion
	JG	FBCHR2		:Loop
	J	FBCHR6		:Operation done

FBCHR4	STH	R5,TTRLFT,R13	:Store number of chars left to be read
	STH	R7,TTRFCT,R13	:Store number of chars read
	ST	R10,TTRPTR,R13	:Store buffer pointer
	LR	R5,R5		:Operation done?
	JEFS	FBCHR6		:Yes, go finish up

	CLHI	R5,MAXCHAR	:More than MAXCHAR characters left?
	JLEFS	FBCHR5		:No, skip
	LHI	R5,MAXCHAR	:Only get MAXCHAR at a time
FBCHR5	STH	R5,CHRLIM,R9,R9	:Set limit
	JR	R14		:Return

FBCHR6	LHI	R5,MAXCHAR	:Finish up read char request
	STH	R5,CHRLIM,R9,R9	:Reset input limit to MAXCHAR
	ST	R7,ARG2,R11	:Return # chars read in ARG2

	IF	BBMSG		:If handling Black Balls
	CLHI	R8,TRANS	:Working on a black ball?
	JN	FBACT		:No, finish request
	LCS	R3,1		:Get -1
	AHM	R3,BBCNTR,R9,R9	:Decrement BB count
	JE	FBACT		:Finish request if none left
	LIS	R3,0
	STH	R3,BBCNTR,R9,R9	:Clear BB count
	STH	R3,TTLNES,R13	:No lines in buffer
	JAL	R4,EMPTY	:Remove garbage from input buffer
	EI	:BBMSG

	J	FBACT		:Go finish request
:
: Read line
:

FBLIN
	IF	BBMSG		:If we are handling black balls
	LH	R3,BBCNTR,R9,R9	:Get # of BB's
	JLE	FBLIN1		:None, go on with request
	LIS	R3,0
	STH	R3,BBCNTR,R9,R9	:Clear BB count
	STH	R3,BBCT,R9,R9	:Clear BB character count
	STH	R3,TTLNES,R13	:Clear line count
	STH	R3,ARG2,R11	:Return no characters
	JAL	R4,EMPTY	:Clear input buffer
	LIS	R8,TRANS	:Return 'Transmission error' status
	J	FBACT		:Finish I/O operation
	EI

FBLIN1	L	R10,TTRPTR,R13	:Get Pascal buffer pointer
	LH	R5,TTRLFT,R13	:Get # chars empty in buffer
        LIS     R6,0
        LHI     R7,0FFF
        SR      R6,R7
        CR      R5,R6           :IF IT HAS OVERREAD THAT MUCH CHARS
        JLE     FBCOMX          :IF YES, GO TO COMPLETION ANYWAY
	LHL	R7,TTRFCT,R13	:Get line length (so far)
	LHL	R6,BCT,R1	:Get # chars in bufferlets
	LB	R8,TTRMSK,R13	:Character mask

FBLIN2	SIS	R6,1		:Any chars left to read?
	JL	FBLIN5		:No, exit loop
	JAL	R4,GCI		:Read character
	LR	R0,R0		:Is escape char?
	JN	FBLINA
	SIS	R6,1		:Decrement counter
	JAL	R4,GCI		:Get msg code
	LR	R0,R0
	JE	FBLINA		:Skip if data null char
	ST	R7,ARG2,R11	:Store # chars read in arg2
	CLHI	R0,0BF		:Is SIIX?
	JE	FBSIX		:Go return the start_medium status
	CLHI	R0,0C0		:Is TIIX?
	JE	FBTIX		:Yes, go return the end_medium status
	JAL	R10,CRASH,,	:Otherwise, crash the slot with unknown data
	BC	0,0,4*R14,$032
FBLINA	LCS	R3,1
        AHM     R3,DCT,R1,
	TBT	R0,TTBRK,R13	:Is this a special character?
	JN	FBSPCL		:Yes, go see what kind.
FBLIN3	SIS	R5,1		:Decrement space left
	JLFS	FBLIN4		:Skip if buffer filled
	NR	R0,R8		:Remove unwanted bits (if any)
	STB	R0,0,R10	:Put character in buffer
FBLIN4	AIS	R7,1		:Increment line length
	AIS	R10,1		:Increment pointer (maybe beyond buffer)
	J	FBLIN2

FBLIN5	STH	R5,TTRLFT,R13	:Store number of chars left to be read
	STH	R7,TTRFCT,R13	:Store number of chars read
	ST	R10,TTRPTR,R13	:Store buffer pointer
	JR	R14		:Return

FBSPCL	LR	R2,R0		:Copy special character
	NHI	R2,7F		:Remove parity bit
	CLHI	R2,0D		:Carriage return?
	JNFS	FBSPC2		:No, try another
	SIS	R5,1		:Decrement space left
	JLFS	FBCR1		:Skip if buffer filled
	NR	R0,R8		:Remove unwanted bits (if any)
	STB	R0,0,R10	:Put CR in buffer
FBCR1	AIS	R7,1		:Increment line length
	ST	R7,ARG2,R11	:Return length in ARG2
	LCS	R0,1		:Get -1
	AHM	R0,TTLNES,R13	:Decrement line count
	J	FBCOMP		:Request complete

FBSPC2	CLB	R2,TTEDIT,R13	:Backspace?
	JNFS	FBSPC3		:No, try another
	LR	R7,R7		:Anything in buffer?
	JE	FBLIN2		:No, ignore
	SIS	R10,1		:Decrement pointer
	SIS	R7,1		:Decrement char count
	AIS	R5,1		:Increment space left
	J	FBLIN2		:Done with backspace

FBSPC3	CLB	R2,TTEDIT+1,R13	:Word delete?
	JN	FBSPC4		:No, try another
	LR	R7,R7		:Is buffer empty?
	JE	FBLIN2		:Yes, ignore
	LR	R5,R5		:Is buffer full?
	JL	FBLIN2		:Yes, ignore
	LIS	R9,0		:R9 is a counter
FBWD1	SIS	R10,1		:Back up a character
	AIS	R9,1		:Increment the counter
	AIS	R5,1		:Increment space left
	SIS	R7,1		:Decrement char count
	JE	FBWD4		:Stop if buffer empty
	LB	R0,0,R10	:Get character
	NHI	R0,7F		:Strip parity
	CLHI	R0,20		:Space?
	JEBS	FBWD1		:Yes, back up more
	CLHI	R0,09		:Tab?
	JEBS	FBWD1		:Yes, back up more
				:Else must be end of word
FBWD2	SIS	R10,1		:Back up a character
	AIS	R9,1		:Increment the counter
	AIS	R5,1		:Increment space left
	SIS	R7,1		:Decrement char count
	JE	FBWD4		:Stop if buffer empty
	LB	R0,0,R10	:Get character
	NHI	R0,7F		:Strip parity
	CLHI	R0,20		:Space?
	JEFS	FBWD3		:Yes, done backspacing
	CLHI	R0,09		:Tab?
	JNBS	FBWD2		:No, back up more
				:Else must be start of word
FBWD3	AIS	R10,1		:Put the space or tab back
	SIS	R9,1
	AIS	R7,1
	SIS	R5,1

FBWD4   LHL     R4,PORT,,
        TBT     R4,TRMTYP,,     :Check what kind of terminal type
        JE      FBWD8           :Skip if hard copy type
	AIS	R1,4		:Point to output buffer
        ST      R9,REGSAV,,
FBWD5	LHI	R0,BACKSP
	JAL	R4,WCI,,
	SIS	R9,1
	JNBS	FBWD5		:Back up # of chars
        L       R9,REGSAV,,
FBWD6	LHI	R0,BLANK
	JAL	R4,WCI,,
	SIS	R9,1
	JNBS	FBWD6		:Rub out # of chars
        L       R9,REGSAV,,
FBWD7	LHI	R0,BACKSP
	JAL	R4,WCI,,
	SIS	R9,1
	JNBS	FBWD7		:Back up # of chars
	SIS	R1,4		:Point to input buffer
FBWD8   LHL     R9,PORT,,       :Restore R9 = port
	J	FBLIN2		:Done with CRT type's word delete
FBSPC4	CLB	R2,TTEDIT+2,R13	:Line delete?
	JN	FBSPC5		:No, try another
	SR	R10,R7		:Back to beginning of buffer
	AR	R5,R7		:All the space is left
        TBT     R9,TRMTYP,,     :Check what kind of terminal
	JN	FBLD1		:Skip if it is CRT type
	LIS	R7,0		:None filled
	J	FBLIN2		:Done processing hard-copy line delete

FBLD1	LR	R7,R7		:Is buffer empty?
	JE	FBLIN2		:Yes, ignore
	AIS	R1,4		:Point to output buffer
        ST      R7,REGSAV,,
FBLD0   LHI     R0,BACKSP
        JAL     R4,WCI,,
        SIS     R7,1
        JNBS    FBLD0
        L       R7,REGSAV,,
FBLD2	LHI	R0,BLANK	:Echo blank
	JAL	R4,WCI,,
	SIS	R7,1
	JGBS	FBLD2		:Back up # of length of blanks
        L       R7,REGSAV,,
FBLD3   LHI     R0,BACKSP
        JAL     R4,WCI,,
        SIS     R7,1
        JGBS    FBLD3
	SIS	R1,4		:Point to input buffer
	J	FBLIN2		:Done processing CRT type line delete

FBSPC5
	CLB	R2,TTEDIT+3,R13	:Line review key?
	JN	FBLIN3		:No, must be a linefeed--put in buffer
        LHL     R9,PORT,,
        TBT     R9,TOISIS,,     :Port backpressured?
        JE      FBLIN2          :Yes, ignore
        LHL     R0,REBL         :Reserve bufferlet pool in use?
        JE      FBLIN2          :Yes,ignore
	AIS	R1,4		:Point to output buffer
        LHL     R4,OTHRSH,R9,R9 :Output threshhold for port
        SH      R4,BCT,R1       :# of chars which will fit
        JLE     FBREV4          :None will, ignore
	LIS	R0,0D		:Echo carriage return
	JAL	R4,WCI,,
	LIS	R0,0A
	JAL	R4,WCI,,		:Echo linefeed
	LR	R7,R7		:Is buffer empty?
	JE	FBREV4		:Yes, ignore
	LR	R9,R10		:Copy pascal data buffer pointer to R9
	LR	R4,R7		:Copy linelength to R4
FBREV1	SIS	R9,1		:Decrement buffer pointer
	SIS	R4,1		:Decrement linelength
	JNBS	FBREV1		:Loop till the start of word
        ST      R7,REGSAV,,
        LR      R5,R5           :Is buffer full?
        JGEFS   FBREV2          :No, skip to use actual R7
        L       R7,ARG1,R11     :Buffer full, so use real linelength
FBREV2	LB	R0,0,R9		:Get content of data buffer
        JNFS    FBREV3          :Skip if not null
        JAL     R4,WCI,,        :Escape nulls
FBREV3  JAL     R4,WCI,,        :Output data character
	AIS	R9,1		:Increment data buffer pointer
	SIS	R7,1		:Decrement linelength
	JGBS	FBREV2
        L       R7,REGSAV,,
FBREV4  SIS     R1,4            :Back to input buffer
        LHL     R9,PORT,,       :Restore R9 = port
	J	FBLIN2		:Done processing line review
:
: Return 'Break' status to the calling program
:

FBBRK	LIS	R8,BKSTAT	:Break status
	J	FBACT		:Reactivate caller


:
:  Return 'STARTMEDIUM' status to calling process
:

FBSIX	LIS	R8,STARTM
	JFS	FBTI1

:
:  Return 'ENDMEDIUM' status to caling process
:

FBTIX	LIS	R8,ENDM
FBTI1
	LCS	R3,1
        AHM     R3,DCT,R1,      :Decrement DCT counter
	J	FBACT

:
: Return 'Complete' status to the calling program
:

FBCOMX  LHL     R7,TTRFCT,R13
        ST      R7,ARG2,R11
        LCS     R0,1
        AHM     R0,TTLNES,R13
FBCOMP	LIS	R8,COMPLE

FBACT	STH	R8,STATUS,R11	:Save return status
	LIS	R0,0
	JAL	R4,PTTOUT	:Cancel any timeouts
	LCS	R0,1		:Get -1
	STH	R0,TTROP,R13	:Set no read operation pending
	L	R8,TTRPHD,R13	:Get header of calling process
	JAL	R9,RDYENT	:Put in ready queue
	JR	R14		:Return	
:
: OUTCHK - See if there is any output ready to be sent
:

OUTCHK  ST      R0,OCRET,,      :Save return address
	LHI	R6,(NTGRP-1)*2	:Last HW in output request bit array
	LHI	R7,(NTGRP-1)*10	:Device # of leftmost bit
OUTCH1  LHL     R11,OUTREQ,R6,  :Get halfword of bit array
OUTCH2	JFFOH	R11,CHKDEV	:See if bit set
	SHI	R7,10		:Decrement device #
	SIS	R6,2		:Decrement bit array pointer
	JGEBS	OUTCH1		:Loop until all checked
        L       R0,OCRET,,      :R0 -> return
	JR	R0		:Return

CHKDEV  STH     R11,OTCHW,,     :Save current halfword
        RBT     R12,OTCHW,,     :Clear this bit
	AR	R12,R7		:Compute device number
	LHL	R13,TTENT,R12,R12	:Get TTY table entry for device
       IF       XMEMRY
        L       R10,TTWPHD,R13  :R10 -> Process Header Record
        LH      R10,XMPSET+4,R10        :R10 = XM Mac set
        JAL     R4,XMCURR       :Make this Proc's Mac set current
       EI       :XMEMRY
	LHL	R9,TTPORT,R13	:Get port for device
	JLE	OTFAIL		:Failure if port not active
	L	R0,TTWTIM,R13	:Get timeout time
	JLEFS	CHKDV0		:Skip if not set
	CL	R0,SLOWC,,	:Time up?
	JLE	OTTOUT		:Yes, give up on send

CHKDV0  TBT     R9,TFLSHO,,     :Flushing output?
	JN	OTBRK		:Yes, return 'breakey' status
        TBT     R9,TOISIS,,     :Port backpressured?
	JE	OTCONT		:Yes, don't send yet
        ST      R6,R6SAV,,      :Save bit array pointer
	LR	R1,R9		:Copy port number
        SLLS    R1,3            :Make input buffer index
        AIS     R1,4            :Output buffer index
        STH     R1,XBUFR,,      :Save it
        LHL     R5,BCT,R1       :Check for empty buffer
        JE      CHKDVA          :If empty, do the send operation now
XOUT2   JAL     R4,GCI,,        :Peek at next char
        LR      R5,R0           :
        JNFS    XOUT3           :Skip if not an escape
        JAL     R4,GCI,,        :Else get escaped char
        LR      R5,R0           :Save copy
        JN      XOUT7           :Skip if not a "0"
XOUT3   LR      R1,R9           :Copy port number
        LB      R6,XLIMIT,R1,   :Limit of chars we can send at once
        LHI     R0,3,R6         :How big the record will be
        JAL     R4,SLOR,,       :Start logical output record
        LR      R0,R5           :Send first char
XOUT4   JAL     R4,PUTCH,,      :Send char
        LHL     R1,XBUFR,,      :Get any further chars from buffer
        SIS     R6,1
        JGFS    XOUT6           :Don't make message too big
XOUT5   JAL     R4,ELODR,,      :Big enough...stop now
        L       R6,R6SAV,,      :Restore bit array pointer
        LHL     R1,XBUFR,,      :Get buffer number
        J       XOUT10
XOUT6   LHL     R0,BCT,R1       :Check state of buffer
        JLEBS   XOUT5           :Quit now if buffer is empty
        JAL     R4,GCI,,        :OK...look at next char
        LR      R5,R0
        JN      XOUT4           :Not Escaped, so send it now
        JAL     R4,GCI,,        :Escaped...look at next char
        LR      R5,R0           :Copy it
        JE      XOUT4           :Pass if data
        JAL     R4,ELODR,,      :End logical output data record

:       WE GOT A CONTROL MESSAGE
XOUT7   LB      R6,LENGTH,R5    :Copy it
        LHI     R0,2,R6         :...to the ISIS buffer too
        LR      R1,R9           :Copy port number
        LR      R2,R5
        JAL     R4,SLOR,,
        LHL     R1,XBUFR,,      :Get any subsequent chars from buffer
XOUT8   SIS     R6,1            :Copy the whole message
        JLEFS   XOUT9           :No more...skip
        JAL     R4,GCI,,          :Copy another char of message
        JAL     R4,PUTCH,,
        JBS     XOUT8           :And go back for more
XOUT9   JAL     R4,ELOR,,       :End logical output record
        L       R6,R6SAV,,      :Restore bit array pointer
        SHI     R5,DETMSG       :Check if circuit zapper
        JLFS    XOUT10          :Skip if not
        SIS     R5,ZAPMSG-DETMSG
        JGFS    XOUT10
        LR      R5,R9           :Yes, get port number
  IF    WAITZA
        SBT     R5,WTZA,,       :Remember to clean up when zapack comes
  ELSE
        RBT     R5,ACP,,        :Clean up now
        RBT     R5,DEM,,
        RBT     R5,OUTCRT,,
        RBT     R5,GBALL,,
       
  EI
        J       OTCONT          :Repeat for next port

XOUT10  LHL     R0,BCT,R1       :Check for empty buffer
        JN      XOUT11          :
        LR      R1,R9
        RBT     R1,GBALL,,
        JE      XOUT12          :
        LIS     R0,3
        LHI     R2,GBMSG
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
        J       XOUT12
XOUT11  TBT     R9,TOISIS,,     :
        JE      OTCONT          :
        J       XOUT2           :
XOUT12  TBT     R9,TOISIS,,     :
        JE      OTCONT          :

CHKDVA  LHL     R5,OTHRSH,R9,R9 :Output threshhold for port
	L	R10,TTWPTR,R13	:Pascal data buffer pointer
	LHL	R8,TTWLFT,R13	:# of chars left to be sent
        LR      R1,R9
        LB      R6,XLIMIT,R9,   :Limit of chars we can send at once
        LHI     R0,3,R6         :How big the record will be
        JAL     R4,SLOR,,       :Start logical output record
CHKDV1	SIS	R5,1		:Decrement # chars which fit
	JLFS	CHKDV2		:Exit loop if threshhold reached
        SIS     R6,1
        JLFS    CHKDV2          :Record big enough...stop now
	SIS	R8,1		:Decrement # chars left
	JLFS	CHKDV2		:Exit loop if done sending
	LB	R0,0,R10	:Get char to send
        JAL     R4,PUTCH,,      :Send it
	AIS	R10,1		:Increment pointer
	JBS	CHKDV1		:Loop
CHKDV2  JAL     R4,ELODR,,      :End of logical data record
        L       R6,R6SAV,,      :Restore R6
CHKDV3	ST	R10,TTWPTR,R13	:Save new pointer
	STH	R8,TTWLFT,R13	:Save # left to send
	LR	R8,R8		:Request complete?
	JLE	OTCOMP		:Yes, return 'complete' status

OTCONT  LHL     R11,OTCHW,,     :R11 = current bit array HW
	J	OUTCH2		:Loop
:
: Output request finished
:

OTBRK	LIS	R0,BKSTAT	:Get 'Breakey' status
	JFS	OTACT		:Finish request

OTFAIL	LIS	R0,FAIL		:Get 'Failure' status
	JFS	OTACT		:Finish request

OTTOUT	LIS	R0,TIMEOU	:Get 'Timeout' status
	JFS	OTACT		:Finish request

OTCOMP	LIS	R0,COMPLE	:Get 'Complete' status

OTACT	L	R11,TTWPRM,R13	:Get parameter block address
	STH	R0,STATUS,R11	:Save return status
        RBT     R12,OUTREQ,,    :Clear request bit for device
	L	R8,TTWPHD,R13	:Get process header addr
	LR	R1,R6		:Save counters
	LR	R2,R7		:  (R6, R7 destroyed by RDYENT)
	JAL	R9,RDYENT	:Enter process in ready queue
	LR	R6,R1		:Restore counters
	LR	R7,R2		:  (destroyed by RDYENT)
	J	OTCONT		:Continue searching
:
: ZCLEAN - Clean up after a zapper (incoming or outgoing)
:	Link on R4
:

ZCLEAN	LIS	R0,0
	LCS	R1,1
        TBT     R9,SYSCON,,     :Test if the console bit on?
	JE	ZCLN2		:No, skip
        RBT     R9,SYSCON,,     :Else clear console bit

ZCLN2	STH	R0,TTPORT,R13	:Clear device state
	STH	R1,PORTDF,R9,R9	:Unbind device from port

	LH	R2,TTROP,R13	:Get pending read operation
	JLR	R4		:Return if none
	STH	R1,TTROP,R13	:Clear pending request
       IF       XMEMRY
        LR      R0,R4
        LR      R11,R10
        L       R10,TTRPHD,R13
        LH      R10,XMPSET+4,R10
        JAL     R4,XMCURR
        LR      R4,R0
        LR      R10,R11
       EI       :XMEMRY
	L	R11,TTRPRM,R13	:Get read parameter address
	LHI	R0,MAXCHAR
	STH	R0,CHRLIM,R9,R9	:Reset input limit to MAXCHAR
        LIS     R0,FAIL         :'FAILURE' CODE
	STH	R0,STATUS,R11	:Return to process
	L	R8,TTRPHD,R13	:Process header
	LR	R0,R4		:Save return address
	LR	R3,R9		:Save port #
	JAL	R9,RDYENT	:Reactivate process
	LR	R9,R3		:Restore R9
	JR	R0		:Return
:
: SETEDI - Set editing character
:	Link on R4
:	Expects:
:		R1 = Index of char to change (0, 1, 2, or 3)
:		R2 = Address of edit char table to change
:		R3 = Address of break table
:		R5 = Address of acknowledgment bit table
:		R10 = Address of Pascal data buffer
:		R11 = Address of Pascal parameter block
:

SETEDI	LB	R0,0,R2,R1	:Get old editing char
	RBT	R0,0,R3		:Clear char in break table
	RBT	R0,10,R3	:Clear char with parity in break table
	LB	R0,0,R10	:Get new editing char
	NHI	R0,7F		:Strip parity
	STB	R0,0,R2,R1	:Put in port control char table
	SBT	R0,0,R3		:Break on this char
	SBT	R0,10,R3	:Break on this char with parity
	L	R3,ARG2,R11	:Get ARG2
	JEFS	STEDNK		:No acknowledgment if = 0
	JGFS	STEDAK		:Acknowlege if > 0
	CLHI	R0,20		:Else is char printable?
	JGEFS	STEDNK		:Don't ack if so

STEDAK	SBT	R1,0,R5		:Set to acknowledge char
	JR	R4		:Return

STEDNK	RBT	R1,0,R5		:Set not to acknowledge char
	JR	R4		:Return
:
: ACTOUT - Needle and Aux Circuit request timeout checker
:	Link on R0
:

ACTOUT	LHI	R1,4*(NTERM+NAUX)	:Index after last entry
ACLOOP	SIS	R1,4		:Decrement
	JLR	R0		:Return if done
        L       R3,TOTAB,R1,    :R3 = timeout entry
	JLEBS	ACLOOP		:Loop if entry not set
	CL	R3,SLOWC,,	:Compare with current time
	JGBS	ACLOOP		:Loop if before wakeup time

	LIS	R2,0		:Get a zero
        ST      R2,TOTAB,R1,    :Clear timeout entry
	LR	R5,R1		:Copy index
	SRLS	R5,2		:Convert to internal device #
	LR	R12,R5		:Copy it
	LHL	R13,TTENT,R12,R12	:Get TTY info table entry addr
       IF       XMEMRY
        L       R10,TTRPHD,R13  :R10 -> Process Header Record
        LH      R10,XMPSET+4,R10        :R10 = XM Mac set
        JAL     R4,XMCURR       :Make this Proc's Mac set current
       EI       :XMEMRY
	LH	R9,TTPORT,R13	:Get port # or state
	CLHI	R9,-2		:Circuit building state?
	JE	ACTO1
	CLHI	R9,-1		:NEEDLE REQUEST STATE
	JN	ACLOOP		:NO, IGNORE
	L	R11,TTRPRM,R13	:Get pascal parameter addr
	LIS	R4,TIMEOU	:'TIMEOUT' return code
	J	ACTO11
ACTO1	LHI	R5,-NTERM,R12	:GET DEVICE #
	LCS	R3,1		:Get -1
	STH	R3,DEVSEQ,R5,R5	:Clear sequence number
	L	R11,TTRPRM,R13	:Get Pascal parameter addr
	LIS	R4,TIMAUX	:Timeout error code
	ST	R4,ARG2,R11	:Return in ARG2
        LIS     R4,FAIL         :'FAILURE' RETURN CODE
ACTO11	STH	R4,STATUS,R11	:Put in parameter block

	LHI	R6,2*NPORT-2	:Index to last PORTDF entry
ACTO2   CLH     R12,PORTDF,R6,  :Is port bound to this dev?
	JEFS	ACTO3		:Yes, exit loop
	SIS	R6,2		:Decrement counter
	JGBS	ACTO2		:Loop through all ports
	JFS	ACTO4		:Skip if done

ACTO3   STH     R3,PORTDF,R6,   :Unbind port
ACTO4	STH	R2,TTPORT,R13	:Clear device state
	L	R8,TTRPHD,R13	:Get process header addr
	JAL	R9,RDYENT	:Put process in ready queue
	J	ACLOOP		:Rejoin loop
:
: REPPRT - Send port availability message to port 0
:	Gets port count from PORTCT
:	Link on R5
:	Destroys registers R1 - R4, R14, R15
:

REPPRT	LIS	R0,$A 10	:10 byte message
	LIS	R1,0		:Send to port 0
	LIS	R2,0A		:Report port availability msg
        JAL     R4,SLOR,,       :Send msg to ring
	LIS	R0,0		:Key
	JAL	R4,PUTCH,,
	LHI	R0,HOST0	:Host number
	JAL	R4,PUTH,,
        LHL     R0,PORTCT,,     :R0 = number of free ports
	JAL	R4,PUTH,,
	LIS	R0,0		:Relative host #0
	JAL	R4,PUTH,,
	JAL	R4,ELOR,,		:End msg
	JR	R5		:Return
:
: CONMSG - Print console message
:
:	Used by other Nucleus modules for error reporting.
:	Expects:
:		R3 = Message address
:		Link on R6
:
:	Message must be in SC format.
:

CONMSG  ST      R7,REGSAV,,
        ST      R3,MSGADR,,
	LHI	R7,(NGRP-1)*2
CONMS0  LHL     R1,SYSCON,R7,   :R1 -> console port bit array
	JE	CONMS3
        STH     R1,SYSREQ,R7,   :Save bit array
CONMS1  LHL     R1,SYSREQ,R7,   :Get processed bit array
	JFFO	R1,CONMS2	:Jump if any requests left to look at
	J	CONMS3
CONMS2	SHI	R2,10
        RBT     R2,SYSREQ,R7,   :Clear bit for this system console port
        TBT     R2,ACP,R7,      :Port active ?
	JE	CONMS1		:Loop if port is not active
	SLLS	R7,3
	AR	R2,R7		:GET PORT #
	SRLS	R7,3
	JAL	R5,OCS,,		:Send msg to console port
        L       R3,MSGADR,,
	J	CONMS1		:LOOP
CONMS3	SIS	R7,2
	JGE	CONMS0
        L       R7,REGSAV,,
	JR	R6
:
: TINIT - Initialize the port I/O driver
:	Link on R2
:

TINIT   ST      R2,TIRET,,      :Save return address
	LHI	R1,NTERM+NAUX-1	:Number of devices
	LA	R3,TTYTBL+(NTERM+NAUX-1)*TTSIZE,,
				:Address of TTY info table end
	LIS	R0,0		:Get 0
	LCS	R4,1		:Get -1

TINIT1	STH	R3,TTENT,R1,R1	:Save TTY table address
	STH	R0,TTPORT,R3	:Set port to zero (unused)
	STH	R4,TTROP,R3	:Set no read operation pending
	STB	R0,TTFLAG,R3	:Init. set to aux req. & data buffer empty
        RBT     R1,OUTREQ,,     :Set no send operation pending
	STH	R0,TTWLFT,R3	:Set no characters to send
	SHI	R3,TTSIZE	:Point at previous entry
	SIS	R1,1		:Decrement device counter
	JGE	TINIT1		:Loop for all devices

	LHI	R1,NPORT-1	:Port # of last port
	LHI	R2,(FISIS-FLAGS)*8+NPORT-1	:FISIS bit index
	LHI	R3,(TISIS-FLAGS)*8+NPORT-1	:TISIS bit index
	LHI	R5,(NBUF-2)*4	:Index into BF
	LA	R6,PTPROC	:Address of port activation routine
	LA	R7,MSGTAB	:Address of message break array
	LHI	R8,(NPORT-1)*4	:Index to port word tables

TINIT2	STH	R4,PORTDF,R1,R1	:Port not connected
	ST	R2,BF,R5	:Set input BF for port
	ST	R3,BF+4,R5	:Set output BF for port
        ST      R6,PROCESS,R8,  :Set activation routine
        ST      R7,MBREAK,R8,   :Set message break table
        ST      R0,BREAK,R8,    :USE DEFAULT CHAR BREAK TABLE (FOR NOW)
        RBT     R1,SYSCON,,     :Set no system console
        RBT     R1,TRMTYP,,     :Set to hard-copy type of terminal
	SIS	R8,4		:Decrement word index
	SIS	R5,8		:Decrement BF index
	SIS	R3,1		:Decrement TISIS index
	SIS	R2,1		:Decrement FISIS index
	SIS	R1,1		:Decrement port counter
	JGE	TINIT2		:Loop for all ports (even port 0)

	IF	NAUX
	LHI	R1,(NAUX-1)*2	:2 * last aux ckt #
TINIT3  STH     R4,DEVSEQ,R1,   :Set invalid sequence #
	:ST	R0,TOTAB,R1,R1	:Set no timeout
	SIS	R1,2		:Previous device
	JGEBS	TINIT3
	EI

	LHI	R1,(NTERM+NAUX-1)*2
TINI3A	ST	R0,TOTAB,R1,R1	:Set no timeout
	SIS	R1,2
	JGEBS	TINI3A


	LA	R6,P0PROC	:Port 0 msg handler
        ST      R6,PROCESS,,    :Set as port 0 activation routine
        STH     R0,ACSEQ,,      :Initialize AC sequence number
	LI	R1,08171112	:ASCII ^H, ^W, ^Q, ^R (edit chars)
        ST      R1,DEFEDI,,     :Put in default edit char table
	LHI	R1,0E0		:Acknowledge all three chars
        STB     R1,DEFACK,,
	LI	R1,00A46100	:Bit table for CR,LF,^H,^Q,^W,^R
        ST      R1,DEFBRK,,     :Put in default break table
        ST      R1,DEFBRK+10,,  :Ditto for chars with parity
        ST      R0,DEFBRK+4,,   :Zero out the rest
        ST      R0,DEFBRK+8,,
        ST      R0,DEFBRK+0C,,
        ST      R0,DEFBRK+14,,
        ST      R0,DEFBRK+18,,
        ST      R0,DEFBRK+1C,,
	
	JAL	R5,IZBF,,		:Initialize bufferlet library
	JAL	R0,IZFRONT	:Initialize FRONT.LIB
	LIS	R0,TRMDEV	:Terminal device #
	SBT	R0,DVREQ,,	:Tell NUCIO we want to be polled

TINIT4	LHI	R6,HIQ0
	SLHLS	R6,7
	LHI	R7,HID0
	L	R0,GMT,,	:Get GMT clock
	JG	TINIT5		:Jump if valid
	LIS	R5,SHUT		:Set host "Shut"
	SETHST(R5,R6,R7)
	SVC	DISMISS,5	:Wait 5 seconds
	LIS	R5,DOWN		:Set host "Down"
	SETHST(R5,R6,R7)
	SVC	DISMISS,$A 10	:Wait 10 seconds
	J	TINIT4		:Try the clock again

TINIT5	LIS	R5,HSTATE	:Set initial host state
	SETHST(R5,R6,R7)
	LIS	R0,0
        STH     R0,PORTCT,,     :Start with no available ports
	JAL	R5,REPPRT	:Report this to the network
        L       R2,TIRET,,      :R2 -> return
	JR	R2		:Return

         
:
: Entry point definitions for NUCIO
:

	GL	STRT|TRMDEV|,COMP|TRMDEV|,INIT|TRMDEV|,DPRI|TRMDEV|
	GL	STRT|AUXDEV|,DPRI|AUXDEV|


STRT|TRMDEV|	EQ	TSTART		:Start terminal requests
STRT|AUXDEV|	EQ	TSTART		:Start aux requests
COMP|TRMDEV|	EQ	TCHECK		:Check completion
INIT|TRMDEV|	EQ	TINIT		:Initialize driver

DPRI|TRMDEV|	EQ	TRMPRI		:Priority
DPRI|AUXDEV|	EQ	AUXPRI

	EM
  	SUBTTL	Nucleus I/O module				nucio.nad
	REMARK	%NUCIO	V 1.4 05-05-82, SCY

: See the file (ISIS2)NUCLUS.MEM for more revision information.

: V 1.4, 05-05-82, SCY
:	Bug fixed which caused nuke crash with range error when user 
:	use an i/o device which not defined in the tymfile.
: V 1,3, 01-26-82, SCY
:	Changed JAL R4,RDYENT to JAL R9,RDYENT
: V 1.1, 12-08-81, MDS
:	Correct init of IO check clock(IONXTM) to allow for it
:	wrapping to negative values
: V 1.1, 12-07-81, MDS
:	Added timing check for IO completion handling to prevent
:	wasting CPU cycles in IO checking
: V 1.0, 08-19-81, SMF
:	Initial version
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								:
:	Nucleus I/O module					:
:								:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	MO	.,NUCIO
	RA	0

	LO	COMMON			:Access common symbols

	GL	NUCIO,NIOCP,INITIO	:Module entry points
	GL	DVREQ			:Global variable

	GL	RNPREM,SAVLIN		:External routine used
	GL	PSWWD,PCNTFL,ENTRTB	:External variable used
:
: Data declarations
:

	SEG	A.DATA

IORET	WS	1		:Return address storage
DVREQ	WS	1		:Bit map for devices wanting service
REQTMP	WS	1		:Temporary for DVREQ being worked on

	IF	\IOMXRT
	ELSE
IOMXRT	EQ	60		:IO checks/second control (1-600 range)
	EI

IOCINT	HC	RATE/IOMXRT	:IO check interval, 1/600 sec. ticks
IONXTM	WC	0		:Next time to run IO check (per FASTC)
:
: In-core constant tables
:

	SEG	A.CODE
	RA	0A

DVSTRT	WS	0
Q	EQ	0
	RE	32
	IF	\STRT|Q|
	WC	STRT|Q|
	ELSE
	WC	0
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST

DVCOMP	EQ	.
Q	EQ	0
	RE	32
	IF	\COMP|Q|
	WC	COMP|Q|
	ELSE
	WC	0
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST

DVPRI	EQ	.
Q	EQ	0
	RE	32
	IF	\DPRI|Q|
	HC	DPRI|Q|
	ELSE
	HC	0
	EI
Q	EQ	Q+1
	NOLIST
	ER
	LIST

	RA	0
:
: NUCIO - Request initialization routine
:	Called from Pascal code
:		R1 = address of Pascal Data Buffer
:		R2 = address of Pascal I/O Parameter Block
:		R3 = global device index #
:		R11-R15 = Pascal registers
:	Exits by jumping to appropriate device driver routine (if any)
:		R1 = unchanged
:		R2 = unchanged
:		R3 = device type #
:		R5 = device unit #
:		R8 = process header addr for calling process (preempted)
:

NUCIO	EQ	.
	LR	R0,R4		:SAVE DEVICE #
	LIS	R4,8		:Index # for nucioc in ENTRTB
	ENTRCT(R4,R5)
	JAL	R4,SAVLIN
	LR	R4,R0		:RESTORE
	SETPSW(R0)		:Set up return PSW in process header
	SETSTA(R0,ST.IO)	:Set process state to "I/O wait"
	LR	R0,R4		:Move device unit # out of the way
	LHL	R4,NESTI1,HD	:Get monitor nesting level
	JEFS	NUCIO1		:Skip if not in monitor
	LIS	R4,MONPRI	:Set monitor priority
	JFS	NUCIO2		:Skip
NUCIO1	LIS	R4,NORPRI	:Set normal priority
NUCIO2	SH	R4,DVPRI,R3,R3	:Add extra priority level for device (if any)
	STH	R4,PRIOR1,HD	:Save new priority in process header
	JAL	R4,RNPREM	:Preempt process
	LR	R5,R0		:Move device number
	LR	R4,R3		:Copy device type
	SLLS	R4,2		:Make fullword index
	L	R4,DVSTRT,R4	:Get address of device start routine
	JNR	R4		:And branch to it (if it exists!)
	LIS	R0,FAIL		:If not, get failure code
	STH	R0,STATUS,R2	:Put in Pascal Param block
	LCS	R0,2		:Dev type not assigned code (-2)
	ST	R0,STATS2,R2	:Put in Pascal Param block
	JAL	R9,RDYENT	:Put process back on ready queue
	J	IOEXIT		:And return
:
: NIOCP - Nucleus I/O completion handler
:

NIOCP	L	R0,IONXTM,,	:IO check time
	C	R0,FASTC,,	:Yet?
	JGR	R4		:No, return

	ST	R4,IORET,,	:Save return address
	L	R0,DVREQ,,	:Get device request bit array
NIOCP1	JFFO	R0,NIOCP2	:Skip if request pending, put first in R1

	L	R4,FASTC,,
	AH	R4,IOCINT,,	:Next time to check IO
	ST	R4,IONXTM,,
	L	R4,IORET,,	:Restore return address
	JR	R4		:Otherwise return

NIOCP2	ST	R0,REQTMP,,	:Temporary storage
	RBT	R1,REQTMP,,	:Clear the bit for this time around
	LR	R2,R1		:Copy device #
	SLLS	R2,2		:Make fullword pointer
	L	R2,DVCOMP,R2	:Get completion routine addr for device
	JALR	R2,R2		:Call completion routine

NIOCPR	L	R0,REQTMP,,	:Get partially processed bit array
	J	NIOCP1		:Check for more requests
:
: INITIO - Initialize the I/O system.
:

INITIO	ST	R4,IORET,,	:Save return address
	L	R0,FASTC,,
	ST	R0,IONXTM,,	:Init IO check timing

	LIS	R0,0
	ST	R0,DVREQ,,	:Start with no devices active

	RA	0A		:Count in decimal
Q	EQ	0		:Init device counter
	RE	32		:For each possible device
	IF	\INIT|Q|	:If device has an init routine
	JAL	R2,INIT|Q|	:Call it
	EI
Q	EQ	Q+1		:Next device
	ER			:Loop
	L	R4,IORET,,	:Restore return address
	JR	R4		:Return

	RA	0
	EM
            SUBTTL  Nucleus Routines                           nuclus.nad
        REMARK %NUCLUS  V 0.114  07-03-85, MKS
:
:
: See the file (ISIS2)NUCLUS.INF for more revision information.
:
: V 0.114, 06-28-85, MKS
:	ADD AN OPTIONAL ROUTINE TO DUMP CERTAIN VALUES ON THE
:	ENTRIES OF "GATENT" AND "GATLEA"	 
:
:V  0.113, 09-15-84, AWT
:       ADD ROUTINE TO SAVE XMWORK VALUES IN XMSAVE AREA FOR LATER RELOAD
:       CRASH CODE USE
:
: V 0.112, 01-23-84, AWT
:       MAKE XMCURP AS A GLOBAL VARIABLE FOR PIPE MAC SET USE IN
:       FINISH.N90
:
: V 0.111, 09-22-83, AWT
:       ADD CRASH CODE 37 IN GATENT TO CRASH SLOT IF THE GATE ADDRESS
:       IS ZERO (WHICH MAY BE CAUSED BY NOT-INITIALIZING A MONITOR).
:       ADD XMSSFF VARIABLE TO ALLOCATE SEGMENT F SIZE AT RUN TIME.
:       REPLACED CHL INSTRUCTION BY LHL AND CR INSTRUCTIONS TO ELIMINATE
:       THE POSSIBILITY FOR BAD CRASH WHEN USING QUEUES WITH ADDRESS
:       > 8000.
: V 0.110, 03-04-83, RNP
:       Changes for Extended Memory Option
: V 0.109, 05-18-82, RNP
:       Added RANGEC subroutine for range checking.
: V 0.108, 03-17-82, SCY
:	Fixed bug causing a cpu_bound monitor to keep other process from
:	 being running.
:	Changed to give double quantum value when starting process with
:	 monitor priority.
: V 0.107, 02-12-82, SCY
:	Stored some important regs to process header in 'RNSYSE' to eliminate
:	the bug which caused the wrong procedure name to be printed out when
:	doing ?stat
: V 0.106, 01-26-82, SCY
:	Changed to use a proper link register instead of always 
:	PUSHR4 & POPR4 for more efficiency.
: V 0.105, 11-17-81, MDS
:	Change QUEINI to macro instead of subroutine.
: V 0.104, 11-06-81, SCY
:	Some changes to work with new line option
: V 0.103, 09-01-81, SMF
:	Numerous changes to work with new IO system
:	Renumbered crash codes to avoid redundancy
:	Added load average facility
: V 0.102, 08-10-81, SMF
:	Lowered quantum value to 1 foreground cycle (25 msec)
:	Crash in RDYENT (code BE) if R8 = 0
: V 0.101, 06-18-81, SMF/MFR
:	Fixed local clock offset initialization to work with ISIS
:	version 4.
:	Added code to crash if monitor nesting level for a process
:	ever goes negative (codes CC, CD)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								      :
:	ORIGINAL DESIGN OF THE NUCLEUS FOR CONCURRENT PASCAL BY       :
:								      :
:		       PER BRINCH HANSEN			      :
:								      :
:								      :
:								      :
:	DESIGN AND IMPLEMENTATION OF THE CONCURRENT PASCAL NUCLEUS    :
:	AND INTERPRETER FOR THE INTERDATA OS/32-MT IS BY	      :
:								      :
:			 DAVID NEAL				      :
:								      :
:	DESIGN AND IMPLEMENTATION OF THE CONCURRENT PASCAL NUCLEUS    :
:	FOR THE TYMNET ENGINE IS BY				      :
:								      :
:	       STUART CAIN AND ELLIOT SCHNEIDER 		      :
:								      :
:								      :
:	THE OSIRIS PROJECT, TYMSHARE, INC.			      :
:	ORIGINAL VERSION IS JANUARY 1, 1979.			      :
:								      :
:								      :
:								      :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	MO   .,NUCLUS
	LO   COMMON
:
:	 GLOBAL SYMBOLS REFERENCED BY NUCLEUS
:
:	GL	COUNTR
	GL	ACP,SEG3,SEG4,CRSHCT,PASRSV,ORING
	GL	PSWWD,CRAT,S2SIZE,SEG2,STATDI
	GL	PASCLK,PASNIN,PASPRC,PASERR,ERRPRC,ERRLIN
	GL	PCASIZ,PCAEND
        GL      SEG0LO,SEG0HI,TIMOUT,S0HORG,LINFLG,ENTRTB
        GL      RANGEC,STKBOT
       IF       XMEMRY
        GL      XMSP00,XMSA00,XMSS00,XMSP01,XMSA01,XMSS01
        GL      XMSP0E,XMSP0F,XMSS0E,XMSS0F,XMSA0E,XMSA0F
        GL      XMPSD,XMSP02,XMSA02,XMSS02,XMSPPV,XMSAPV
        GL      XMCURR,XMCURP,NMACSS
       EI       :XMEMRY
	 IF   NDIAL
	 GL   DIAL0,MODTBL
	 EI
	IF	GATRAC
	GL	dtrctb
	EI
	 RA   $0 0A		SET RADIX DECIMAL
:
:	 TITLE ADDRESS SPACE DECLARATION
:
:
:
:
:	SEG 0			::::::::::::::::::::::::::::::::::::::::
:				:
:				:	DEVICE PARAMETER BLOCKS
:				:
:				::::::::::::::::::::::::::::::::::::::::
:				:
:				:	I/O ERROR MESSAGES
:				:
:				::::::::::::::::::::::::::::::::::::::::
:				:
:				:	PASXXX
:				:
:				::::::::::::::::::::::::::::::::::::::::
:				:
:				:	SYSTEM ERROR MESSAGES
:				:
:	BEGSTR			::::::::::::::::::::::::::::::::::::::::
:	PASTOP(UPON INIT)	:
:				:	SYSPACE
:				:
:				::::::::::::::::::::::::::::::::::::::::

:	     			::::::::::::::::::::::::::::::::::::::::
:				:
:				:	PORT BUFFERLETS SPACE
:				:
:				::::::::::::::::::::::::::::::::::::::::

:	SEG 1			::::::::::::::::::::::::::::::::::::::::
:				:
:				:	VECTOR.LIB
:				:
:				::::::::::::::::::::::::::::::::::::::::
:				:
:				:	LIBRARY ROUTINES
:				:
:				::::::::::::::::::::::::::::::::::::::::
:				:
:				:	TERMINAL I/O ROUTINES
:				:
:				::::::::::::::::::::::::::::::::::::::::
:				:
:				:	NUCLEUS
:				:
:				::::::::::::::::::::::::::::::::::::::::

:	SEG 2			::::::::::::::::::::::::::::::::::::::::
:				:
:				:	
:				:
:	USRBOT			:
:	PASCTO(UPON INIT)	:
:				:	FREE USER SPACE
:				:
:				::::::::::::::::::::::::::::::::::::::::
:	PASINT(UPON INIT)	:
:				:	FREE USER SPACE
:				:
:	PASEND			::::::::::::::::::::::::::::::::::::::::
:
:	SEGMENT 0 DATA DECLARATION
:
	 SEG   0
:
.IOFLN	 EQ   NGRP+1		  I/O FLAG HW LENGTHS
:
PSWWD	HC	$0 65F0 	:HIGH STUFF FOR PSW SETTERS
PASKST	WC	.+4		:NUCLEUS STACK, 1ST WORD STACK PTR
	WS	NLEV
PASINT	WC	USRBOT		:LOW ADDRESS OF INITIAL PROCESS SPACE
PASTOP	WC	BEGSTR		:SYSTEM PROCESS DATA STRUCTURES ADDR
PASFRE	WC	SYSPAC
PASPCD	WC	USRBOT		:USER AREA (UNCHANGED)
PASCTO	WC	USRBOT		:USER PROCESS AREA ADDR
PASCFR	WC	0		:FREE USER SPACE
QUANTM	HC	$A1		:QUANTUM = .025 SEC (UNITS OF 25 MSEC)
LCKOFF	HS	1		:LOCALCLOCK OFFSET INTO SEGMENT F
XMSSFF  HS      1               :PAGE SIZE FOR SEGMENT F AT RUN TIME
HDSAV	WS	1		:Temp storage for process header addr
LCONST	WC	$A 59299	:Decay constant = 65536*exp(-1/10)
       IF       XMEMRY
XMPSD   WC      0               :Extended Memory start PSD
        WC      XMSTAR          :...
       EI       :XMEMRY
PASNEX	HS	2		:1 second wait queue
LINFLG	HS	1		:Bit0- line option flag,  Bit1- trace back flag
				:Bit2- unknow instr or < usrbot flag
LINRET	WS	1		:Save return addr
RGSAV	WS	1		:Register save area
READYQ	BS	NUMPRI*XQUEUE	:The ready queues
	HC	0
:
:	AREA INITIALIZED TO ZERO
:
PASCLR	HS	0
PASPAR	BS	XINTEG*MAX*2	:PARENT PROCESS PARAMETERS
PASNIN	HC	0		:NEXT PROCESS INDEX
PASNGT	HC	0		:NEXT GATE INDEX
PASIDL	HC	0		:IDLE FLAG
PASRSV	WS	$A 16		:NUCLEUS REGISTER SAVE AREA
PERRSV	WS	$A 16		:PASCAL ERROR REGISTER SAVE AREA
PASSLI	BS	6
PASPRC	 BS   XADDRE*PROCS	  SEQUENCE OF PROCESS REFERENCES
PASGAT	 BS   XADDRE*GATES	SEQUENCE OF GATE REFERENCES
PASCLK	WC	0		:ISIS COUNTER, INCR = 1.6 MILLISEC
CPUCLK	HC	0		:CPU CLOCK, INCR = 1.6 MSEC
PASSWI	HC	0		:BIT 0 = 1: TIME LIMIT EXCEEDED
PASCAD	WS	1		:ADDRESS OF LARGEST CONSTANT FOR CP
PASHEP	WS	1		:PARENT PROCESS HEAP TOP
PASNOW	BS	XTIM		   :CURRENT CLOCK TIME
PASERR	HS	1		:SYSTEM ERROR INDEX
ERRPRC	HS	1		:PROCESS NUMBER IN WHICH ERROR OCCURRED
ERRLIN	WS	1		:LINE NUMBER OF ERROR
PASPSW	WS	2		:PSW OF INTERRUPTED PROCESS
LASTFC	WS	1		:SAVED FASTCLOCK
LASTLC	HS	1		:SAVED LOCALCLOCK
LASTSC	HS	1		:SAVED SYSTEM LOCALCLOCK
NUMRDY	HS	1		:Number of processes on ready queue
AVG	WS	1		:Load average
XMRG4S  WS      1
XMRG4T  WS      1
XMRG10  WS      1

BEGSTR	WS	0
	BS	SYSPAC		:Area for process and gate headers
ENDSTR	WS	0
ENTRTB	EQ	.
DELAYC	WC	0
CONTNC	WC	0
NUCIOC	WC	0
PREEMC	WC	0
WAITC	WC	0
REALTC	WC	0
CONSTC	WC	0
GTINIC	WC	0
GTENTC	WC	0
GTLEAC	WC	0
INITPC	WC	0
ENDPC	WC	0
RANGEN  WC      0
RANGES  WS      1
XMLFT0  HS      1               :Pages left in area zero
XMBAS0  HS      1               :Base of unallocatesd area zero
XMLEFT  WS      1               :Space left in current XM window
XMBASE  WS      1               :Base of current window unallocated
XMWORK  HS      $a 35           :Extended Memory work area
XMPCUR  HS      1               :Current MAC set number
XMSETN  HS      1               :Extended Memory next MAC set
XMVSEG  HS      1               :Extended Memory Perm vars seg
XMVSIZ  HS      1               :Extended Memory Number of var segs
XMSSEG  HS      1               :Extended Memory start of stack
XMSSIZ  HS      1               :Extended Memory window size (in segments)
       IF       XMEMRY
XMSVPT  HS      1
XMSAVE  WS      $A 19*NMACSS
       EI       :XMEMRY
PASCLX	HS	0		:END OF AREA TO ZERO
:
PASMSG	SC	'  PROCESS ...   LINE ........"8D"8A'
:
:	TABLE OF NUCLEUS ERROR MESSAGES
:
MSGS	HS	0
NUCMSG	HS	0
	HC	MSGTER-MSGS		: 0
	HC	MSGOVF-MSGS		: 1
	HC	MSGPTE-MSGS		: 2
	HC	MSGRAN-MSGS		: 3
	HC	MSGVAR-MSGS		: 4
	HC	MSGHEA-MSGS		: 5
	HC	MSGSTA-MSGS		: 6
	HC	MSGCOD-MSGS		: 7
	HC	MSGTIM-MSGS		: 8
	HC	MSGCAL-MSGS		: 9
	HC	SPCLIM-MSGS		: 10
	HC	CORLIM-MSGS		: 11
	HC	PARLIM-MSGS		: 12
	HC	VIRLIM-MSGS		: 13
	HC	MSGSIM-MSGS		: 14
	HC	MSGHLT-MSGS		: 15
:
:	NUCLEUS ERROR MESSAGES
:
MSGTER	SC	'TERMINATED'
MSGOVF	SC	'OVERFLOW ERROR'
MSGPTE	SC	'POINTER ERROR'
MSGRAN	SC	'RANGE ERROR'
MSGVAR	SC	'VARIANT ERROR'
MSGHEA	SC	'HEAP LIMIT'
MSGSTA	SC	'STACK LIMIT'
MSGCOD	SC	'CODE LIMIT'
MSGTIM	SC	'TIME LIMIT'
MSGCAL	SC	'CALL ERROR'
SPCLIM	SC	'SPACE LIMIT'
CORLIM	SC	'CORE LIMIT'
PARLIM	SC	'PARAMETER LIMIT'
VIRLIM	SC	'VIRTUAL LIMIT'
MSGSIM	SC	'SOFTWARE SIMULATED ERROR'
MSGHLT	SC	'KILLED'

	WS	0
PCNTFL	EQ	.		:PROCESS COUNT BIT ARRAY
	RE	PROCS/8+1
	BC	0
	ER

	IF	GATRAC
TMPMRK	EQ	.
	ORG	DTRCTB+$A2048
GATCPT	HS	1
GATCTB	BS	$A2048
	ORG	TMPMRK
	EI	:GATRAC			
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								     :
:	USER PROCESS DATA STRUCTURE SPACE			     :
:								     :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:

:
:	THIS MACRO TESTS THE RETURN ADR SENT TO NUCLEUS FROM COMPILED CODE
:
RABUG	 MACRO[
	 IF   DEBUG
	CI	QR,USRBOT
	JG	.+$A12
        JAL     R10,CRASH,,
	BC	0,0,4*R4,$020
	 EI]
:
:	THIS MACRO MONITORS THE PROCESS HDR RECORD PTR
:
HDBUG	MACRO(RX)[
	IF	DEBUG
	STM	R0,PASRSV,,
	LR	R1,RX
	IF	RX-R8
	SIS	R1,4
	EI
	LH	R2,PASNIN,,
	CLH	R1,PASPRC,R2,
	JE	.+$A22
	SIS	R2,2
	CHI	R2,0
	JGE	.-$A14
        JAL     R10,CRASH,,
	BC	0,0,4*R4,$021
	LM	R0,PASRSV,,
	EI]
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								      :
:								      :
:	 NUCLEUS ENTRY POINTS					      :
:								      :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								      :
:								      :
	 GL   RNTIM
	 GL   RNCONS
	 GL   GATENT
	 GL   GATLEA
	 GL   GATDEL
	 GL   GATCON
	 GL   GATINT
	 GL   RNENDP
	 GL   RNINPR
	 GL   RNSTOP
	 GL   RNSYSE
	 GL   CLKWAI
	 GL   CLKINC
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								      :
:	SEGMENT 1 DECLARATION					      :
:								      :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
	SEG 1
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:								      :
:								      :
:	CLASS:NEWCORE						      :
:								      :
:	ALLOCATES SPACE FOR NUCLEUS DATA STRUCTURES,IN PARTICULAR     :
:	PROCESS RECORDS AND MONITOR GATES.  SPACE IS RESERVED IN      :
:	LOW MEMORY FOR THESE AREAS(BEGSTR AND UP).		      :
:								      :
:	INPUT: R8 - AMOUNT OF SPACE TO ALLOCATE 		      :
:	OUTPUT:R8 - ADDRESS OF BLOCK				      :
:								      :
:	ACCESSING MODULE: RNINTP,RNINTC,GATINT			      :
:								      :
:	ACCESSED MODULE:  RNSYSE				      :
:								      :
:	POINT: ADDRESS SPACE STRUCTURE VARIABLES PASTOP AND PASFRE    :
:	       ARE ADJUSTED FOR NEW DATA BLOCK.IF THERE IS NO ROOM,   :
:	       RNSYSE IS CALLED.				      :
:								      :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
NEWCOR	HS	0
	C	R8,PASFRE,,	:HDR REC SIZE VS SPACE LEFT
	JLE	NEWC1		:ENOUGH ROOM, AHEAD WE GO
        JAL     R10,CRASH,,     :Not enough PHR space
	BC	0,0,0,$022
NEWC1	L	R5,PASFRE,,	:SIZE LEFT
	SR	R5,R8		:DECREMENT BY SIZE FOR HDR REC
	ST	R5,PASFRE,,	:SAVE RESULTS
	L	R5,PASTOP,,	:ADR OF NEW HDR RECORD
	AR	R8,R5		:BUMP POINTER
	ST	R8,PASTOP,,	:SAVE RESULT
	LR	R8,R5		:RETURN ADR IN R8
	JR	R4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	CLASS:QUEUE
:
:	NEXT THREE ROUTINES HANDLE DOUBLY LINKED LISTS ADDRESSED
:	AS QUEUES.  ELEMENTS ARE ADDED TO BOTTOM AND REMOVED FROM
:	THE TOP OF THESE LISTS.
:
:	INPUT:	R6(ALL) - ADRESS OF LIST
:		R8(GET) - ELEMENT REMOVED FROM LIST
:	OUTPUT: R8(PUT) - ELEMENT ADD TO LIST
:
:	ACCESSING MODULE: SIGNAL,READY,GATE
:
:	ACCESSED MODULE: NONE
:
:	POINT: LISTS USING THESE ROUTINES ARE 3 PRIORITY LISTS,
:	       SIGNAL QUEUES,AND THE MONITOR GATE QUEUES.
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	THIS ROUTINE REMOVES A PROCESS POINTER FROM A PROCESS QUEUE
:	(LIST). THE SUCESSOR OF THE ELEMENT POINTED TO BY
:	R6 IS REMOVED FROM THE LIST AND RETURNED IN R8.
:
QUEGET	 EQ   .
	 LHL  R8,SUCC,R6	:GET ^R6.SUCC
	 LHL  R7,SUCC,R8	:GET ^R6.SUCC.SUCC
	 STH  R7,SUCC,R6	:^R6.SUCC:=^R6.SUCC.SUCC
	 LHL  R5,PRED,R8	:GET ^R6.SUCC.PRED
	 STH  R5,PRED,R7	:^R6.SUCC.SUCC.PRED:=^R6.SUCC.PRED
	LIS	R5,0		:get zero
	ST	R5,0,R8		:zero out the pointers
	 JR   R4
:
:
:	THIS ROUTINE ADDS A PROCESS POINTER TO THE END OF A PROCESS
:	QUEUE(LIST).  THE ELEMENT IN R8 IS LINKED AS THE PRED.
:	OF THE ELEMENT IN R6.
:
QUEPUT	 EQ   .
	L	R5,0,R8		:Get pointers
	JEFS	QUEPT1		:Jump ahead if zeros
        JAL     R10,CRASH,,     :Else crash!!!
	BC	0,0,4*R5,$023

QUEPT1	 LHL  R7,PRED,R6	:GET ^R6.PRED
	 STH  R8,PRED,R6	:^R6.PRED:=^R8
	 STH  R7,PRED,R8	:^R8.PRED:=^R6.PRED
	 LHL  R5,SUCC,R7	:GET ^R6.PRED.SUCC
	 STH  R5,SUCC,R8	:^R8.SUCC:=^R6.PRED.SUCC
	 STH  R8,SUCC,R7	:^R6.PRED:=^R8
	 JR   R4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	CLASS:SIGNAL
:
:	THE FOLLOWING ROUTINES MAINTAINS(USING QUEUETYPES) A QUEUE OF PROCESSES
:	AWAITING THE OCURRENCES OF A SIGNAL (EVENT).  THE AWAT (AWAIT) ENTRY
:	ROUTINE CAUSES THE CURRENTLY ACTIVE(RUNNING) PROCESS TO BE DEACTIVATED
:	AND ENQUEUED ON THE LIST. THE SEND ENTRY ROUTINE CAUSES ALL ENQUEUED
:	PROCESSES TO BE TRANSFERRRED TO THE READY LIST.
:
:	INPUT:	R6 - GLOBAL SIGNAL QUEUE VARIABLE
:		HD(AWAT) - CURRENT RUNNING PROCESS
:
:	ACCESSING MODULE: CLOCK,CONSOLE
:
:	ACCESSED MODULE: RNPREM,QUEUE,RDYENT
:
:	POINT: INSTANCES OF THE SIGNAL CONSIST OF THE REALTIME CLOCK(WAIT
:		FOR 1 SECOND TO PASS).
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	FIRST CHECK QUEUE LOCATED IN R6(SAME AS ABOVE) IS EMPTY. IF SO RETURN,
:	OTHERWISE EMPTY THIS QUEUE,ADDING EACH ELEMENT TO THE APPROPIATE
:	READY QUEUE. THEN ACTIVATE HIGHEST PRIORITY WAITING PROCESS.
:
SIGSEN	 EQ   .
	 LA   R5,SUCC,R6	:CHECK QUEUE
         LHL  R9,SUCC,R6        :SEE IF EMPTY
         CR   R5,R9
	 JER  R4		:RETURN IF SO
	 PUSHR4			:SAVE RETURN ADR
DELNX	 JAL  R4,QUEGET		:FETCH PROCESS FROM QUEUE
	LH	R9,NESTI1+4,R8		:IN MONITOR?
	JGFS	SS2		:YES, SKIP
	LIS	R9,NORPRI	:NORMAL PRIORITY
	STH	R9,PRIOR1+4,R8		:SAVE
SS2     ST      R6,RGSAV,,      :Save address of queue
	 HDBUG(R8)
	 JAL  R9,RDYENT		:ENTER PROCESS ON READY QUEUE
        L       R6,RGSAV,,      :Restore address of queue
	 LA   R5,SUCC,R6	:RE-CHECK QUEUE
         LHL  R9,SUCC,R6        :SEE IF EMPTY
         CR   R5,R9
	 JN   DELNX		:IF NOT,KEEP GRABBING NEXT PROCESS
	 POPR4			:RECEIVE RETURN ADR
	 JR   R4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	CLASS:TIME
:
:	THE TIME ROUTINES IMPLEMENTS THE TIMING OF SYSTEM FUNCTIONS,IN
:	PARTICULAR THE SYSTEM CLOCK AND PROCESS RUNTIMES. A TIMING VARIABE
:	IS A STRUCTURE CONSISTING OF SECONDS AND MILLISECONDS.
:	
:	INPUT: R8(ADD) - AMOUNT OF TIME IN MILLISEC. TO ADD
:	OUTPUT:R6(ALL) - TIMING VARIABLE
:
:	ACCESSING MODULE: CLOCK,RNUPDT
:
:	ACCESSED MODULE: NONE
:
:	POINT: EACH PROCESS CONTAINS A TIMING VARIABLE AS PART OF ITS
:	PROCESS HEAD WHICH IS USED TO MEASURE PROCESS RUNTIME. A SYSTEM
:	WIDE TIMING VARIABLE IS MAINTAINED(PASNOW) BY THE CLOCK ROUTINES.
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	ADD THE TIME INCREMENT IN R8 TO THE TIME VARIABLE POINTED TO BY R6.
:	IF FRAC > 1 SEC,INCREMENT SEC BY 1.
:	WHEN R6=PASNOW,R8=LARGINC
:	     R6=RNTI1,HD , R8=SLICE1,HD
:	Link on R9
:
TIMADD	 EQ   .
	 LH   R5,FRAC,R6	:FRACTIONS OF A SEC(600/SECOND)
	 AR   R5,R8		:ADD INCREMENT
	 CHI  R5,MAXSLI		:OVERFLOW 1 SEC?
	 JL   ADDEND		:NO,SKIP AHEAD
	 SHI  R5,MAXSLI		:DECREMENT BY MAX VALUE
	 STH  R5,FRAC,R6	:REPLACE VALUE
	 LIS  R5,1
	 AM  R5,SEC,R6		:INCREMENT SEC VALUE
	 JR   R9
ADDEND	 STH  R5,FRAC,R6	:RETURN FRAC VALUE
	 JR   R9
:
:
:
:	intermediate NUCLEUS initailization routine. clear real time
:	clock parameter. R6 = pas.now
:
TIMINT	 EQ   .
	 XR   R5,R5
	 ST  R5,SEC,R6
	 STH  R5,FRAC,R6
	 JR   R4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	CLASS:CLOCK
:
:	MAINTAIN A SOFTWARE CLOCK FOR THE SYSTEM. THE WAIT ENTRY POINT
:	ALLOWS A PROCESS TO WAIT FOR NEXT ONE SECOND INCREMENT OF THE CLOCK.
:
:	INPUT: HD(WAIT) - RUNNING PROCESS
:
:	ACCESSING MODULE: COMPILED CODE,TIMRT
:
:	ACCESSED MODULE:SIGNAL,TIME
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	INCREMENT THE SYSTEM CLOCK VARIABLE(PASNOW) BY ONE PERIOD OF
:	REALTIME CLOCK.  IF 1 SEC HAS PASSED,EMPTY WAIT QUEUE(PASNEX),ELSE
:	RETURN.
CLKINC	 EQ   .
	 PUSHR4
	 L    R8,FASTC,,	:RUNTIME CLOCK FROM ISIS
	 LR   R5,R8		:SAVE FOR REPLACEMENT
	 S    R8,PASCLK,,		:SUBTRACT OLD VALUE
	 ST   R5,PASCLK,,		:REPLACE OLD VALUE
	 LA   R6,PASNOW,,		:ADR OF TIMER VARIABLE
	 L   R7,SEC,R6		:REMEMBER SECONDS
	 JAL  R9,TIMADD		:UPDATE SLOT TIME
	 AIS  R7,WAITTI		:INCREMENT SAVED SECONDS
	 C   R7,SEC,R6		:1 SECOND PASSED?
	 JG   RETCLK		:NO,RETURN
	NDB0(1,R5,R6,0)
	 JAL  R9,STATDI		:DISPLAY STATISTICS ON FRONT PANEL
	JAL	R4,LOADAV	:Compute load average
	 LA   R6,PASNEX,,		:PICK UP ADR OF WAIT QUEUE
	 JAL  R4,SIGSEN		:EMPTY 1 SECOND WAIT QUEUE
RETCLK	 POPR4
	 JR   R4
:
:	SETUP THE PSW OF CURRENT RUNNING PROCESS TO LINK TO COMPILED CODE
:	PREEMPT THIS PROCESS AND PLACE IT ON 1 SEC WAIT QUEUE POINTED TO 
:	BY R6.  R6 CONTAINS ADR OF 1 SEC WAIT QUEUE.
:
:
CLKWAI	 EQ   .
	LHI	R5,$010		:Index # for waitc in ENTRTB
	ENTRCT(R5,R4)
	JAL	R4,SAVLIN
	SETPSW(R5)
	SETSTA(R4,ST.WAI)
	JAL	R4,RNPREM
	LA	R6,PASNEX,,
	JAL	R4,QUEPUT
	 J    NUEXI
:
:
:	intermediate NUCLEUS initialization routine. clear clock ticks
:	and empty process queue.
:	PASNOW = SYSTEM REALTIME CLOCK VARIABLE
:	PASNEX = 1 SEC WAIT QUEUE
:
CLKINI	 EQ   .
	:PUSHR4
	 LA   R6,PASNOW,,
	 JAL  R4,TIMINT
	 LA   R6,PASNEX,,
	 QUEINI(R6)
	 :POPR4
	 JR   R0
:
:
:
SAVLIN	EQ	.
	ST	R4,LINRET,,	:Store the return addr
	LIS	R4,0
	TBT	R4,LINFLG,,	:Test if line option flag is on, 1=ON,0=OFF
	JE	SAV1		:No, skip
	LH	R4,2,B		:Otherwise, load the line #
	ST	R4,LINE1,HD	:Store the line # in header
SAV1	LR	R4,B		:Save reg B
	AIS	R4,4		:Test if current running process is under 
	CR	XS,R4		: init routine or subroutine call
	JE	SAV2		:Skip if under init routine
	LIS	R4,0		:Reset the ENTRFG
	STH	R4,ENTRFG,HD
	J	SAV3		:Return
SAV2	LIS	R4,1		:Under init routine, then set ENTRFG in header
	STH	R4,ENTRFG,HD
SAV3	L	R4,LINRET,,	:Restore return addr
	JR	R4
:
: LOADAV - Routine to compute the load averages
:	Link on R4
:

LOADAV	LHL	R7,NUMRDY,,	:Get number of ready processes
	LR	HD,HD		:Is a process running?
	JEFS	LODAV1		:No, skip
	AIS	R7,1		:Yes, count running process, too.
LODAV1	L	R6,AVG,,		:Get old load average
	EXHR	R8,R7		:Shift # ready left a halfword
	SR	R6,R8		:Subtract from old average
	JGEFS	LODAV2		:Skip if positive
	XI	R6,-1		:Make it positive
	AIS	R6,1		:  (Two's complement)
	LCS	R8,1		:Set a flag saying we did this
LODAV2	M	R5,LCONST,,	:Multiply by decay constant
	LR	R8,R8		:Check negative flag
	JGEFS	LODAV3		:Skip if not set
	XI	R6,-1		:Two's complement doubleword
	XI	R5,-1
	AIS	R6,1
	JNCFS	LODAV3		:Skip if carry not needed
	AIS	R5,1		:Do carry
LODAV3	AR	R5,R7		:Add # ready
	STH	R5,AVG,,		:Store first HW of new average
	EXHR	R6,R6		:Move 2nd HW to bottom of word
	STH	R6,AVG+2,,	:Store 2nd HW
	JR	R4
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	CLASS:TIMERTRAP
:
:	THIS ROUTINE IMPLEMENTS THE REQUIRED CLOCK AND TIMER UPDATES UPON
:	EACH INSTANCE OF TIME SLICE SWITCH. THE READY LIST IS RE-SCHEDULED
:	FOR NEXT PROCESS ON READY QUEUES. ALSO AN EXAMINATION OF ANY OUSTANDING
:	I/O IS DONE AND I/O COMPLETION IS CALLED IF NEEDED.
:
:
:
:	ACCESSING MODULE:NUCTGT
:
:	ACCESSED MODULE:CLKINT,RDYRES
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
TIMRT
:	LH	R4,NESTI1,HD	:MONITOR NESTING
:	JG	TIMRT1		:JUMP IF IN MONITOR

	LIS	R4,CPUPRI	:SET PRIORITY := CPU BOUND
	STH	R4,PRIOR1,HD
	JAL	R4,RNPREM		:PREEMPT PROCESS
	JAL	R9,RDYENT		:PUT ON READY QUEUE
	JFS	TIMRT2		:SKIP

:TIMRT1	JAL	R7,RNUPDT	:DO PROCESS TIMING
				:  (CAN'T LET LOCALCLOCK OVERFLOW)
TIMRT2  HS      0
:       JAL     R0,BMEXEC       :CHECK FOR I/O COMPLETES
	LR	HD,HD		:WAS THE PROCESS PREEMPTED?
	JEFS	TIMRT3		:YES, SKIP AHEAD
	JAL	R4,QTSTRT	:RESET QUANTUM TIMER (SINCE RNSERV CAN'T!)
TIMRT3
:	LIS     R9,COMPIO       :CHECK FOR ANY I/O COMPETION
:       TBT     R9,PASFLG,,     :OUTSTANDING I/O?
:       JN      IOROUT          :YES,PROCESS REQUEST
        J       NUEXI           :LET NEXT PROCESS RUN
:
:
:
TIMRIN
	 L    R0,FASTC,,	:INIT LOCAL SLOT TIMER
	 ST   R0,PASCLK,,		:SAVED VALUE
	LH	R1,LCKOFF,,	:LOCALCLOCK OFFSET
	LHL	R0,NRATE,R1,	:LOCAL CLOCK
	STH	R0,CPUCLK,,	:INITIALIZE CPU CLOCK
	 JR   R4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
: CLKINT - Clock pseudo-interrupt handler
:
:	The currently running process has been selected to be pre-empted
:	by the foreground task. The background task is forced to this
:	entry point with the 'real' PSW saved in PASPSW. We put his
:	PSW in his header and then jump to put him on bottom of ready Q.
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
CLKINT
	STM	R0,REG0-HEAD0,HD	:SAVE REGISTERS
	LIS	R0,0
	RBT	R0,PASSWI,,	:CLEAR FLAG
	L	R0,PASPSW,,	:WORD 0 OF INTERRUPTED PSW
	ST	R0,PRSPSW-HEAD0,HD	:SAVE IN PROCESS HEADER
	L	R0,PASPSW+4,,		:WORD 1
	ST	R0,PRSPSW-HEAD0+4,HD	:SAVE
	J	TIMRT		:GO TO OVERTIME HANDLER
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       CORALO                                                        :
:                                                                     :
:       This routine allocates memory for the stack spaces            :
:       of the Initial (parent) Process and all other processes.      :
:       If memory os overallocated the nucleus is crashed.            :
:                                                                     :
:       Output: R9 -> allocated storage                               :
:                                                                     :
:       Input: R8 = number of bytes to allocate                       :
:                                                                     :
:       Accessing modules: RNINTC, RNINTP                             :
:                                                                     :
:       Accessed module: RNSYSE                                       :
:                                                                     :
:       PASCTO -> current top of unallocated memory                   :
:       PASCFR = number of bytes left                                 :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
CORALO  HS      0
        AHI     R8,7            :Round up to next doubleword
        NI      R8,$0 0FFFFFFF8 :Mask off 3 low bits
       IF       XMEMRY
        L       R5,XMLEFT,,     :R5 = Number bytes left in current
        SR      R5,R8           :Minus the size of this request
        JGE     ALOK            :Skip if doable in this window
        LR      R9,R4           :R9 -> return point
        JAL     R4,XMSETK       :Build a new XM window
        JAL     R4,XMSETC       :Tell ISIS about it
        LR      R4,R9           :Restore R4
        L       R5,XMLEFT,,     :R5 = Number of bytes in current
        SR      R5,R8           :Minus this request
        JGEFS   ALOK            :Skip if ok
        JAL     R10,CRASH,,
        BC      0,0,0,$024
ALOK    ST      R5,XMLEFT,,     :Reset number of bytes left
        L       R9,XMBASE,,     :R9 -> space allocated
        AM      R8,XMBASE,,     :Advance unallocated pointer
       ELSE
        L       R5,PASCFR,,     :R5 = Number of bytes left
        SR      R5,R8           :Minus the size of this request
        JGEFS   ALOK            :Skip, if request doable
        JAL     R10,CRASH,,     :Not enough stack space
        BC      0,0,0,$024
ALOK    ST      R5,PASCFR,,     :Space left after request
        L       R9,PASCTO,,     :R9 -> space allocated
        AM      R8,PASCTO,,     :Update unallocated pointer
       EI       :XMEMRY
        JR      R4              :Return to caller
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       RNSERV - Setup Process for running                            :
:                                                                     :
:       This routine restores the process registers from the PHR.     :
:                                                                     :
:       Input: R8 -> Process Header Record                            :
:                                                                     :
:       Accessing: RDYSEL                                             :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
RNSERV  HS      0
        HDBUG(R8)
        ST      R8,REG0+RGHD,R8 :Set PHR pointer into PHR
        JAL     R4,QTSTRT       :Start Quantum Timer for process
        LM      HD,REG0+RGHD,R8 :Restore important registers
        AIS     HD,4            :Setup PHR pointer
        LH      R0,PRIOR1,HD    :R0 = process priority
        CLHI    R0,MONPRI       :Monitor priority?
        JNFS    RNSRV2          :No, skip
        LHL     R0,QUANTM,,     :R0 = quantum
        AHM     R0,QCOUNT,,     :Double QCOUNT for monitors
RNSRV2  LHL     R0,STATE1,HD    :R0 = process state
        CLHI    R0,ST.END       :Ended process?
        JEFS    RNSRV1          :Yes, skip
        SETSTA(R4,ST.RUN)       :Run state
        J       NUEXI3          :Start process execution
:
:       Ended Process
:
RNSRV1  LIS     R6,$A 15        :Error 15 - "Halted"
        J       RNSYSE          :Stop the process
:
:       Start Quantum Timer
:
QTSTRT  HS      0
        LIS     R0,0            :R0 = 0
        STH     R0,QCOUNT,,     :Stop timer
        RBT     R0,PASSWI,,     :Clear overtime flag
        LHL     R0,QUANTM,,     :R0 = QUANTUM
        STH     R0,QCOUNT,,     :Start timer
        JR      R4              :Return
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:RUNNING		MODULE:RNPREM
:
:	THIS ROUTINE PREEMPTS THE CURRENT RUNNING PROCESS BY SAVING ITS
:	REGISTERS IN THE PROCESS HEADER RECORD AND PURGING THE CURRENT
:	PROCESS POINTER (HD).
:
:	OUTPUT:	R8 - POINTER TO PREVIOUS ACTIVE PROCESS HEADER RECORD
:
:	ACCESSING MODULE:IO,SIGAWA,RNINPR,RNENDP,RDYRES,GATENT,GATDEL
:
:	ACCESSED MODULE: RNUPDT
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
RNPREM	 EQ   .
	 JAL  R7,RNUPDT		:UPDATE PROCESS RUN TIME
	 LR   R8,HD		:SAVE HDR REC POINTER
	 SIS  R8,4		:POINT TO LINK VARIABLE
	 STM  HD,REG0+RGHD,R8	:SAVE IMPORTANT REGISTERS
	 LIS  HD,0		:CLEAR HDR REC POINTER
	 JR  R4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:RUNNING		MODULE:RNUPDT
:
:	UPDATE THE TOTAL RUNTIME FOR THE CURRENT PROCESS.
:
:	INPUT: NONE
:
:	ACCESSING MODULE:RDYRES,RNPREM
:
:	ACCESSED MODULE:TIMADD
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:
RNUPDT
	LH	R5,LCKOFF,,	:LOCALCLOCK OFFSET
	LHL	R5,NRATE,R5,	:LOCAL CLOCK
	LR	R8,R5
	 SH    R8,CPUCLK,,	:This process run time
	NHI	R8,$0 7FF	:REMOVE HIGH ORDER BITS
	 STH   R5,CPUCLK,,		:REPLACE OLD VALUE
	LA	R6,RNTI1,HD	:ADDR OF TOTAL RUNTIME
	JAL	R9,TIMADD	:UPDATE RUNTIME
	 JR   R7
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       RNPOP  - Move Parent Process parameters to intermediate stack :
:                                                                     :
:       Move parameters from Parent Process's stack to temporary      :
:       storage so they can later be passed to child process.         :
:                                                                     :
:       Input:  R8 = Number of parameters                             :
:               XS -> Parent's stack                                  :
:                                                                     :
:       Accessed by: RNINPR                                           :
:                                                                     :
:       Accesses: RNSYSE                                              :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
RNPOP   HS      0
        CHI     R8,MAX*4        :Will arguments fit in temp store
        JLEFS   POPR41          :Yes, skip
        LIS     R6,12           :Argument Overflow error code
        JAL     R4,RNSYSE,,     :Report error
POPR41  CLHI    R8,0            :At least 1 argument?
        JEFS    POPR43          :No, skip
        LA      R6,PASPAR,,     :R6 -> intermediate stack
POPR42  HS      0
        SIS     XS,4            :Decrement stack pointer
        L       R5,0,XS         :R5 = next argument
        ST      R5,0,R6         :Put into temp storage
        AIS     R6,4            :Increment intermediate stack pointer
        SIS     R8,4            :Decrement size
        JGBS    POPR42          :Move all args
POPR43  SIS     XS,4
        JR      R4              :Return
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       RNINTC - Subroutine for Initialize a Child Process            :
:                                                                     :
:       This routine initializes a child process by:                  :
:        1. Allocating space for header record                        :
:        2. Placing PHR on list of running processes (PASPRC)         :
:        3. Configure child process parameter space                   :
:        4. Setup pointers to stack and common data space             :
:        5. Reset runtime parameters in PHR                           :
:        6. Set to lowest priority (normal process queue)             :
:           and reset continue flag                                   :
:        7. Put child paameters in global parameter list              :
:        8. Have PSW link to compiled code                            :
:        9. Enter process on READY QUEUE                              :
:                                                                     :
:       Input: R0 -> Entry                                            :
:              R1 = parameter length                                  :
:              R2 = variable length                                   :
:              R3 = stack length                                      :
:                                                                     :
:       Accessing module: RNINPR                                      :
:                                                                     :
:       Accessed modules: NEWCOR, CORALO, RNSYSE                      :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
RNINTC  HS      0
        PUSHR4
        LHI     R8,XPROCE       :R8 = size of child process PHR
        JAL     R4,NEWCOR       :Allocate PHR
        LH      R4,PASNIN,,     :R4 -> list of active procs
        STH     R8,PASPRC,R4,   :Put new PHR into list
        AIS     R4,XADDRE       :R4 -> next pointer slot
        STH     R4,PASNIN,,     :Reset for next
        SRLS    R4,1            :Convert to process number
        LA      HD,4,R8         :HD -> PHR
        ST      R4,INDEX1,HD    :Process number to PHR
        ST      R0,ENTR1,HD     :Setup ptr to process name
        LR      R8,R1           :R8 = argument size
        AR      R8,R2           :Plus variable size
        AR      R8,R3           :Plus stack size
        AIS     R8,4            :Plus word size
        JAL     R4,CORALO       :Allocate space for child process
       IF       XMEMRY
        LH      R10,XMSETN,,    :R4 = This process's window
        STH     R10,XMPSET,HD   :Set in PHR
        JAL     R4,XMCURR       :Make child's window current
        LR      R6,R9           :R6 -> new stack
        LR      R4,R8           :R4 = byte count
        LIS     R10,0           :R10 = 0
RNINC0  STH     R10,0,R6        :Clear two bytes
        AIS     R6,2            :Bump pointer
        SIS     R4,2            :drop count
        JGBS    RNINC0          :Loop through new stack
       EI       :XMEMRY
:
        LA      R6,RNTI1,HD     :R6 -> Process timer variable
        JAL     R4,TIMINT       :Initialize timer variable
        LIS     R4,0            :Setup to init PHR variables
        STH     R4,NESTI1,HD    :Clear nesting level
        STH     R4,SLICE1,HD    :Clear time slice
        STH     R4,JOB1,HD      :Clear job number
        LIS     R4,NORPRI       :Normal priority
        STH     R4,PRIOR1,HD    :Set normal priority
        LIS     R4,1            :1 = Continue mode
        STH     R4,CONTI1,HD    :Set for normal execution
        STH     R4,ENTRFG,HD
:
        LA      XS,0,R8,R9      :XS -> Top of stack
        ST      XS,HEAPT1,HD    :Set Heap top
        AIS     XS,4            :Advance a word
        SR      XS,R3           :XS -> bottom of stack
        LR      R14,XS          :R14 -> stack bottom
        SIS     R14,4           :Backup 1 word
        LR      R13,R14         :R13 -> Global Variables
        SR      R13,R2          :R13 = space for variables
        SIS     R13,4
        LA      R6,PASPAR,,     :R6 -> stack of arguments
PULOOP  L       R5,0,R6         :R5 = argument
        ST      R5,0,R13        :Set into global variables
        AIS     R6,4            :R6 -> next argument
        SIS     R13,4           :R13 -> next global variable slot
        SIS     R1,4            :drop count
        JGBS    PULOOP          :Move all global variables
:
        ST      R13,VARPTR,HD   :PHR -> global variable ptr
        LH      R4,PSWWD,,      :R4 = standard part of PSW
        ST      R4,PRSPSW-HEAD0,HD      :Set into PHR
        ST      R0,PRSPSW-HEAD0+4,HD    :Set IC into PHR
        JAL     R0,RDYRES       :Put new process on ready queue
        POPR4
        JR      R4              :Return
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       RNINTP - Initialize Parent Process                            :
:                                                                     :
:       This routine initializes a PARENT Process by:                 :
:        1. Allocating space (in SYSPAC) for Process Header Record    :
:        2. Placing PHR on list of running processes (PASPRC)         :
:        3. Set HEAPT1 to top of stack frame                          :
:        4. Allocate space for process parameters                     :
:        5. Initialize runtime parameters                             :
:           (RNTI1, SLICE1, NESTI1, JOB1)                             :
:        6. Set to lowest priority (normal process queue)             :
:        7. Set continue flag                                         :
:        8. Setup pointers to stack, code and heap                    :
:        9. Have PSW link to compiled code                            :
:                                                                     :
:       Input: R8 -> Beginning of code                                :
:                                                                     :
:       Accessing module: NUCINT                                      :
:                                                                     :
:       Accessed modules: NEWCOR, CORALO                              :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
RNINTP  HS      0
        LR      R7,R8           :R7 -> Beginning of code
        LR      R1,R4           :R1 -> Return
        LHI     R8,XPROCE       :R8 = size of PHR
        JAL     R4,NEWCOR       :Allocate a PHR
        LH      R4,PASNIN,,     :R4 -> Active processes
        STH     R8,PASPRC,R4,   :Put PHR into list
        LA      HD,4,R8         :HD -> PHR
        AIS     R4,XADDRE       :Bump list ptr
        STH     R4,PASNIN,,     :Reset for next
        SRLS    R4,1            :R4 = Process Number
        ST      R4,INDEX1,HD    :Put Process Number into PHR
        LA      R6,RNTI1,HD     :R6 -> Time r variable into PHR
        JAL     R4,TIMINT       :initialize timer variable
:
        LHL     R4,LINEON,R7    :R4 = line option flag
        STH     R4,LINFLG,,     :Set flag globally
       IF       XMEMRY
       ELSE
        L       R8,STACKL,R7    :R8 = size of stack
        A       R8,VARL,R7      :Plus variable length
        AIS     R8,4            :Plus 1 word
        A       R8,PROGL,R7     :Plus process code length and constants
        JAL     R4,CORALO       :Allocate space in user area
       EI       :XMEMRY
:
        LIS     R4,0            :Get a zero
        STH     R4,SLICE1,HD    :Initialize time slice
        STH     R4,NESTI1,HD    :Initialize nest level
        STH     R4,JOB1,HD      :Initialize job number
        LIS     R4,1            :1 = continue flag
        STH     R4,CONTI1,HD    :Set process to continue
        STH     R4,ENTRFG,HD
        STH     R4,XMPSET,HD    :Setup XM initial window
        LIS     R4,NORPRI       :Start process at normal priority
        STH     R4,PRIOR1,HD    :Set priority in PHR
       IF       XMEMRY
        LIS     R4,0            :R4 = 0
        LH      XS,XMVSEG,,     :XS = perm variable segment
        SLL     XS,$a16         :XS -> perm variable space
RNINP0  STH     R4,0,XS         :Clear two bytes
        AIS     XS,2            :Bump pointer
        C       XS,PASHEP,,     :At top of space?
        JLBS    RNINP0          :No, loop through space
        AIS     XS,4            :Top of process space plus one word
       ELSE
        L       R4,PASCTO,,     :R4 -> HEAP top
        ST      R4,PASHEP,,     :Set globally
        LA      XS,0,R8         :XS -> top of process space
        AIS     XS,4            :Plus one word
        A       XS,PASINT,,     :Plus beginning of user space
       EI       :XMEMRY
        ST      XS,HEAPT1,HD    :Set top of heap
        S       XS,STACKL,R7    :XS -> Stack
        LR      R14,XS          :R14 -> stack
        SIS     R14,4           :Minus 4
        LR      R13,R14         :R13 -> Stack - 4
        S       R13,VARL,R7     :R13 -> Global Variables
        SIS     R13,4           :Minus 4
        ST      R14,VARPTR,HD   :Set Global Variable ptr in PHR
        SETSTA(R4,ST.RUN)       :Run state
        LH      R4,PSWWD,,      :R4 = standard part of PSW
        ST      R4,PRSPSW-HEAD0,HD      :Set into PHR
        LA      R4,PREFIX,R7    :R4 -> Beginning of code
        ST      R4,PRSPSW-HEAD0+4,HD    :Into PHR
        L       R5,2,R4         :R5 = 1st instruction of code
	LA	R6,PREFIX+6,R7
        AR      R5,R6           :R5 -> main process
        ST      R5,ENTR1,HD     :Put into PHR
        A       R4,CODEL,R7     :R4 -> Constants area
        ST      R4,PASCAD,,     :Set pointer to Constants area
        JR      R1              :Return
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       RNINPR - Initialize a Child Process                           :
:                                                                     :
:       The compiled Pascal code branches here via the VECTOR table   :
:       to initialize a child process.  Parameters are moved to       :
:       system storage from the parent.  The current process is       :
:       preempted and reentered on the ready queue.  The child        :
:       process is then initialized.                                  :
:                                                                     :
:       Input:  R0 -> Entry of child process                          :
:               R1 = parameter length                                 :
:               R2 = variable length                                  :
:               R3 = stack size                                       :
:                                                                     :
:       Accessed via: VECTOR table                                    :
:                                                                     :
:       Accesses: RNPOP, RNPREM, RDYENT, RNINTC                       :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
RNINPR  HS      0
        LHI     R8,$028         :Index for init child process in ENTRTB
        ENTRCT(R8,R4)
        LIS     R4,0
        TBT     R4,LINFLG,,
        JEFS    RNINP1
        LH      R4,2,R14
        ST      R4,LINE1,HD
RNINP1  LIS     R4,1
        STH     R4,ENTRFG,HD
        SETPSW(R8)
        LH      R8,NESTI1,HD    :In monitor?
        JGFS    RNINP2          :Yes, skip
        LIS     R8,NORPRI       :Set for normal priority
        STH     R8,PRIOR1,HD    :Set priority
RNINP2  LR      R8,R1           :R8 = parameter length
        JAL     R4,RNPOP        :Move parameters to intermediate stack
        JAL     R4,RNPREM       :Preempt this process
        JAL     R9,RDYENT       :Put the process on ready queue
        JAL     R4,RNINTC       :Initialize child process
        J       NUEXI           :Begin execution of child process
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       XMINIK - Initialize Extended Memory variables                 :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
XMINIK  HS      0
       IF       XMEMRY
        LHI     R8,(EMEMR3+$a63)/$a64   :Segs of Pascal code
        AIS     R8,2            :R8 = beginning segment for perm vars
        STH     R8,XMVSEG,,     :Save for later
        SLL     R8,$a16         :Form byte address
        L       R10,PASINT,,    :Beginning of Pascal code
        L       R7,STACKL,R10   :Parent stack size
        A       R7,VARL,R10     :Plus permanent variables
        AIS     R7,4            :Plus one extra word
        AR      R8,R7           :R8 -> Heap Top
        ST      R8,PASHEP,,     :Set top of heap
        AHI     R7,$a255        :Round up to page
        SRL     R7,8            :Number of pages of perm vars
        STH     R7,XMVSIZ,,     :Save for later
:
:       Setup Stack Space Allocation Variables
:
        AHI     R7,$a255        :Round up to segment
        SRL     R7,8            :Number of segments of perm vars
        AH      R7,XMVSEG,,     :Plus start of perm vars
        STH     R7,XMSSEG,,     :Start of stack area
        LIS     R10,$00E        :Window size
        SR      R10,R7          :...
        STH     R10,XMSSIZ,,    :Set stack window size
:
:       Setup Area 0 Allocation Variables
:
        LHI     R7,XMSS00+1     :R7 = seg 0 pages, area 0 used
        AHI     R7,XMSS01+1     :Plus seg 1 pages
        AH      R7,XMVSIZ,,     :Plus reserved for Perm variables
        STH     R7,XMBAS0,,     :Save base for later
        LHI     R10,EMEMR0*4    :Area 0 size in pages
        SR      R10,R7          :Compute area 0 left
        STH     R10,XMLFT0,,    :Save for later
:
        JR      R4              :Return
       EI       :XMEMRY
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       XMCURR - Make a MAC register set number the current           :
:                                                                     :
:       On Entry:  R10 = MAC Register Set                             :
:                  R4 -> Return address                               :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
XMCURR  HS      0
       IF       XMEMRY
        CLH     R10,XMPCUR,,    :Is new MAC set already current?
        JER     R4              :Already current, nothing to do
        ST      R4,XMRG4S,,
        LR      R10,R10         :Is MAC set valid?
        JLEFS   XMCURP          :Invalid set, crash
        STH     R10,XMPCUR,,    :Set new MAC register set number
XMCUR0  HS      0               :Entry used by DDT
        ST      R4,XMRG4T,,
        ST      R10,XMRG10,,
        SVC     5,0,R10         :Switch to MAC set in R10
XMCUR1  HS      0
        JR      R4              :Return

XMCURP  WC      0               :Restart PSW for switches
        WC      XMCUR1          :...
       EI       :XMEMRY


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                    :
:       XMSETC - Tell ISIS about a new Extended Memory Register set  :
:                                                                    :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

XMSETC  HS      0
       IF       XMEMRY
        LR      R6,R0           :Save R0
        LH      R0,XMSETN,,     :Get old MAC set number
        AIS     R0,1            :Bump to new
        STH     R0,XMSETN,,     :Reset
        LR      R10,R1          :Save R1
        LA      R1,XMWORK,,     :R1 -> XM MAC set
        SVC     SYS,$a42        :Tell ISIS about Reg set
        HC      0               :Crash if error
        HC      0
        LR      R1,R10          :Restore R1
        LR      R0,R6           :Restore R0
        JR      R4              :Return
       EI       ::XMEMRY
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       XMSETK - Build an Extended Memory MAC                         :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
XMSETK  HS      0
       IF       XMEMRY
        LHI     R10,XMSP00      :Segment 0 protect/area
        STB     R10,XMWORK,,    :Set Protect/Area for MAC reg 0
        LHI     R10,XMSS00      :Segment 0 size
        STB     R10,XMWORK+1,,  :Set size of segment 0
        LHI     R10,XMSA00      :Base of segment 0
        STH     R10,XMWORK+2,,  :Set base of segment 0
:
        LHI     R10,XMSP01      :Segment 1 protect/area
        STB     R10,XMWORK+4,,  :Set Protect/Area for MAC reg 1
        LHI     R10,XMSS01      :Segment 1 size
        STB     R10,XMWORK+5,,  :Set into segment 1
        LHI     R10,XMSA01      :Base of segment 1
        STH     R10,XMWORK+6,,  :Set segment 1 size
:
:       Setup the Pascal code area
:
        LIS     R5,0            :Displacement of start of segment
        LA      R6,XMWORK+8,,   :R6 -> MAC register 2
        LHI     R7,EMEMR3*4     :Pages of Pascal code
XMSET1  HS      0
        LHI     R10,XMSP02      :R10 = segment 2 protection/area
        STB     R10,0,R6        :Set into MAC register
        STH     R5,2,R6         :Set starting displacement
        LHI     R10,$a255       :R10 = full segment
        CR      R10,R7          :Is current segment full?
        JLFS    XMSET2          :No, skip
        LR      R10,R7          :R10 = partial segment
        SIS     R10,1           :Page count - one
XMSET2  STB     R10,1,R6        :Set segment size
        AIS     R6,4            :R6 -> next MAC register
        AHI     R5,$a256        :Bump starting displacement
        SHI     R7,$a 256       :Drop by segment size
        JG      XMSET1          :Loop till all code segments
:
:       Setup the Permanent Variable Segments
:
        LH      R6,XMVSEG,,     :R6 = Starting segment
        SLL     R6,2            :Starting Segment * 4
        LA      R6,XMWORK,R6,   :R6 -> first Perm Var seg register
        LH      R5,XMVSIZ,,     :R5 = number of pages
        LHI     R7,XMSAPV       :R7 = displacement in area 0
XMSET3  HS      0
        LHI     R10,XMSPPV      :R10 = perm var protect/area
        STB     R10,0,R6        :Set into MAC register
        LHI     R10,$a255       :Assume full segment
        CR      R10,R5          :Do we have a least 1 segment?
        JLFS    XMSET4          :Yes, skip
        LR      R10,R5          :R10 = pages left
        SIS     R10,1           :Minus one
XMSET4  STB     R10,1,R6        :Set size-1
        STH     R7,2,R6         :Set displacement
        AIS     R6,4            :R6 -> next MAC register
        AHI     R7,$a256        :Bump displacement
        SHI     R5,$a256        :Drop count
        JG      XMSET3          :Setup all perm var registers
:
:       Set up Stack space Segments
:
        LH      R6,XMSSEG,,     :R6 = Starting Stack Segment
        LR      R7,R6           :R7 = Starting Stack Segment
        SLL     R7,$a16         :R7 = address of stack
        ST      R7,XMBASE,,     :Set base for stack allocation
        LIS     R7,$a14         :R7 = number of segments in window
        SR      R7,R6   
        JGFS    XMSET5          :Skip if at least one
        JAL     R10,CRASH,,
        BC      0,0,0,$a69
XMSET5  LIS     R10,0           :R10 = zero
        ST      R10,XMLEFT,,    :Clear bytes left in stack
        SLL     R6,2            :R6 = first segment * 4
:
XMSET6  LH      R5,XMLFT0,,     :R5 = pages left in area 0
        CHI     R5,$a256        :Enough left for a full segment?
        JLFS    XMSET7          :No, skip
        LHI     R5,$a256        :Max of 256 pages per segment
XMSET7  SIS     R5,1            :Minus one
        STB     R5,XMWORK+1,R6, :Set size-1 in pages
        LH      R10,XMBAS0,,    :R10 = area 0 displacement
        AIS     R5,1            :Restore R5 = pages
        JGFS    XMSET8          :Skip if segment defined
        STB     R5,XMWORK+1,R6, :Clear for undefined segment
        LIS     R10,0           :...
XMSET8  STH     R10,XMWORK+2,R6,        :Set base in register
        LIS     R10,0           :R10 = zero
        SR      R10,R5          :R10 = -pages
        JEFS    XMSET9          :If pages = 0 skip
        AHM     R10,XMLFT0,,    :Drop pages left in area 0
        AHM     R5,XMBAS0,,     :Bump displacement in area 0
        SLL     R5,8            :R5 = bytes
        AM      R5,XMLEFT,,     :Add to size of this window
        LHI     R10,XMSPPV      :R10 = protection/area byte
XMSET9  STB     R10,XMWORK,R6,  :Set into register
        AIS     R6,4            :Advance segment index
        SIS     R7,1            :Drop count
        JG      XMSET6          :Loop till all segments handled
:
        LHI     R10,XMSP0E      :Segment E protection/area
        STB     R10,XMWORK+$a56,,
        LHI     R10,XMSS0E      :Segment E size
        STB     R10,XMWORK+$a57,,
        LHI     R10,XMSA0E      :Segment E base
        STH     R10,XMWORK+$a58,,
:
        LHI     R10,XMSP0F      :Segment F protection/area
        STB     R10,XMWORK+$a60,,
        LH      R10,XMSSFF,,    :Segment F size
        STB     R10,XMWORK+$a61,,
        LHI     R10,XMSA0F      :Segment F base
        STH     R10,XMWORK+$a62,,
:
        LA      R10,XMCURP      :R10 -> Restart PSW for XM
        ST      R10,XMWORK+$a64,,

:  SAVE MACSET VALUES FOR LATER RELOAD CRASH CODE USE

        LIS     R5,0
        LIS     R6,0
        LHL     R7,XMSVPT,,
XSLOOP  L       R10,XMWORK,R6,
        ST      R10,XMSAVE,R7,
        AIS     R7,4
        AIS     R6,4
        CHI     R6,$A 68
        JL      XSLOOP
        AIS     R7,8
        STH     R7,XMSVPT,,

        JR      R4              :Return
       EI       :XMEMRY
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:RUNNING			MODULE:RNTIM
:
:	RETURN TO COMPILED CODE SLOT'S REATIME CLOCK
:
:	OUTPUT: R0 - SLOT'S TIME
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
RNTIM	 EQ   .
        ST      R4,RGSAV,,
	LHI	R4,$014		:Index # for realtc in ENTRTB
	ENTRCT(R4,R0)
	JAL	R4,SAVLIN
        L       R4,RGSAV,,
	L	R0,GMT,,	:RETRIEVE TIME
	STM	R0,REG0-HEAD0,HD	:SAVE REGISTERS FOR NUEXI
	SETPSW(R6)
	J	NUEXI		:EXIT
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:RUNNING			MODULE:RNCONS
:
:	RETURN TO COMPILED CODE CONSTANT ADR
:
:	OUTPUT: R0 - ADR OF CONSTANTS
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
RNCONS	 EQ   .
        ST      R4,RGSAV,,
	LHI	R4,$018		:Index # for constc in ENTRTB
	ENTRCT(R4,R0)
	JAL	R4,SAVLIN
        L       R4,RGSAV,,
	 L    R0,PASCAD,,		:ADR OF CONSTANTS
	STM	R0,REG0-HEAD0,HD	:SAVE REGISTERS FOR NUEXI
	SETPSW(R6)
	J	NUEXI		:EXIT
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:RUNNING		MODULE:RNENDP
:
:	END CURRENT RUNNING PROCESS
:
:	INPUT:NONE
:
:	ACCESSING MODULE:INTERPRETER
:
:	ACCESSED MODULE:RNPREM
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
RNENDP	 EQ   .
	LHI	R4,$02C		:Index # for endpc in ENTRTB
	ENTRCT(R4,R5)
	JAL	R4,SAVLIN
	ST	QR,PRSPSW-HEAD0+4,HD
	SETSTA(R4,ST.END)	:End state
	 JAL  R4,RNPREM		:PREEMPT PRESENT PROCESS
	 J    NUEXI		:LET NEXT PROCESS RUN
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:RUNNING		MODULE:RNSTOP
:
:	PLACE RESULT IN PROCESS HEADER RECORD AND TERMINATE PROCESS EXECUTION.
:
:	INPUT: R1 - PROCESS TO BE STOPPED
:	       R2- RESULT SAVED
:
:	ACCESSING MODULE:COMPILED CODE
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:
RNSTOP	 EQ   .
	LIS	R8,$00C		:Index # for preemc in ENTRTB
	ENTRCT(R8,R5)
	JAL	R4,SAVLIN
	SETPSW(R8)
	 LHL  R8,PASPRC,R1,		:PROC HDR REC ADR TO TERMINATE
	 AIS  R8,4			:BUMP POINTER TO THIS HDR RECORD
	 ST   R2,RESUL1,R8		:SAVE TERMINATION INDEX IN RECORD
	 LIS  R5,0			:DISCONTINUE FLAG
	 STH  R5,CONTI1,R8		:FLAG PROCESS TERMINATED
	 J    NUEXI			:LET PROCESS CONTINUE
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       RANGEC - Range Check Subroutine                               :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

RANGEC  HS      0
        ST      R6,RANGES,,
        LHL     R6,0,R15        :R15 = Upper bound
        CR      R10,R6
        JCFS    RANGE1          :Range Error, skip
        L       R6,RANGES,,
        J       2,R15           :Return
RANGE1  LIS     R6,3            :Indicate Range Error
:       J       RNSYSE          :Handle Pascal errors
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       RNSYSE - Handle PASCAL errors                                 :
:                                                                     :
:       Output error message to Console (if there is one) and halt    :
:       current process (the one that generated the error).           :
:                                                                     :
:       Input: R6 = Error code                                        :
:              R4 -> Return                                           :
:                                                                     :
:       Accessed by: Vector.LIB                                       :
:                                                                     :
:       Accesses: NUCREI                                              :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
RNSYSE  HS      0
	CLHI	R6,0		:Is terminated code?
        JNFS    RNSYS0          :Skip if not
        LIS     R6,1            :R6 = 1
        CH      R6,JOB1,HD      :In sequential code?
        JNFS    RNSY00          :No, handle error code
:
:       Terminate Sequential Code
:
        STH     R0,CONTI1,HD    :Yes, set continue flag on
        LR      XS,B
        LM      G,4,XS
        JR      QR

RNSY00  LIS     R6,0            :R6 = 0
RNSYS0  HS      0
        STH     R6,PASERR,,     :Save system error index
        ST      R6,RESUL1,HD    :Save result in Process Hdr Record
        STM     R0,PERRSV,,     :Save process registers

        L       R2,INDEX1,HD    :R2 = process index
        STH     R2,ERRPRC,,     :Save
	SETPSW(R0)
	JAL	R4,SAVLIN
	STM	HD,REG0-HEAD0+RGHD,HD
       IF       CRERR           :Crash if CRERR=1
       ELSE
        CHI     R6,MAXERR+1     :Compare to max
        JLFS    NUCERR         :If ok, skip
       EI       :CRERR
RNSYS1  JAL     R10,CRASH,,     :otherwise cause a crash
	BC	0,0,4*R6,$026
:
NUCERR  HS      0
	:SAVLIN(R8)
	:ST	R8,LINE1,HD
        SLLS    R6,1            :R6 = error code * 2
        LH      R4,NUCMSG,R6,   :R4 = error message displacement
        LA      R3,MSGS,R4,     :R3 -> error message
        LR      R0,R3           :R0 -> error message
        SVC     SYS,$a 29       :ISIS diagnostic msg
        JAL     R6,CONMSG       :Print message on console

	LHI	R0,$034A	:3 digits, zero fill, decimal
	LA	R1,PASMSG+11,,	:Address where proc number goes
	LH	R2,ERRPRC,,	:Get process number
	JAL	R6,OUTNUM,,	:Do binary-ASCII conversion

        LIS     R0,0            :R0 = 0
	TBT	R0,LINFLG,,
	JEFS	NUC0
	LHI	R0,$054A	:5 digits, zero fill, decimal
        LHL     R2,2,B          :R2 = line number
	JFS	NUC1
NUC0	LHI	R0,$0830	:8 digits, blank fill, hex
	L	R2,PRSPSW-HEAD0+4,HD
NUC1	LA	R1,PASMSG+22,,	:Address where line number goes
	JAL	R6,OUTNUM,,	:Convert

        LA      R3,PASMSG,,     :R3 -> message
	JAL	R6,CONMSG	:Print rest of message

       IF       ERRHND          :If CRASH device error handler defined
        JAL     R4,ERRHND       :Call it
       EI       :ERRHND
        LM      R0,PERRSV,,     :Restore registers
        LIS     R6,1            :R6 = 1
        CH      R6,JOB1,HD      :In sequential code?
        JE      NUEXI           :Yes, return to caller
        J       RNENDP          :no, terminate process
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:READY		MODULE:RDYENT
:
:	DETERMINE PRIORITY OF PROCESS HEADER RECORD AND PLACE PROCESS
:	ON APPROPIATE READY QUEUE.
:
:	INPUT: R8 - PROCESS RECORD POINTER
:
:	ACCESSING MODULE: IOROUT,SIGSEN,RNINPR,RDYRES,GATLEA,GATDEL,GATCON
:
:	ACCESSED MODULE: QUEPUT
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:
	 BND  4
RDYENT
	LR	R8,R8		:Check process hdr addr
	JGFS	RDYEN1		:Skip if > 0
	JAL	R10,CRASH,,	:Else crash
	BC	0,0,4*R4,$027

RDYEN1	LH	R5,4+PRIOR1,R8	:GET PROCESS PRIORITY
	SLLS	R5,2		:CONVERT TO QUEUE INDEX (ASSUMES XQUEUE=4!!)
	LA	R6,READYQ,R5,		:GET ADDRESS OF APPROPRIATE QUEUE
	NDB2(2,R4,R5,1,R8,R6)
	LHL	R4,STATE1+4,R8	:Get state
	CLHI	R4,ST.END	:Process ended?
	JEFS	RDYEN2		:Yes, don't change state!
	LIS	R4,ST.RDY	:Ready state
	STH	R4,STATE1+4,R8
RDYEN2	JAL	R4,QUEPUT		:ENTER ITEM IN QUEUE
	LIS	R4,1
	AHM	R4,NUMRDY,,	:Increment ready queue count
	JR	R9
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       RDYSEL - Select highest priority process to run state         :
:                                                                     :
:       Note: This routine is also called IOEXIT (from I/O system)    :
:                                                                     :
:       The highest priority ready process is set to running state:   :
:                                                                     :
:               1. If the system is in idle state, go to 3.           :
:               2. Check the 3 queues for highest priority process    :
:                  Take process off queue and activate.               :
:                  If 3 queues are empty, set idle flag and suspend   :
:                  nucleus until an interrupt.                        :
:               3. Clear idle flag.  If PHR is cleared, goto 2.       :
:                  otherwise begin execution of present process.      :
:               4. During the idle loop, monitor terminal I/O and     :
:                  update runtime clock.                              :
:                                                                     :
:       Output: R8 -> PHR for highest ready process                   :
:                                                                     :
:       Accessing: NUEXI                                              :
:                                                                     :
:       Accessed by: QUEGET, RNSERV                                   :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
IOEXIT  HS      0               :entry point from I/O system
RDYSEL  HS      0
        LH      R5,PASIDL,,     :Slot in idle state?
        JN      IDLRET          :Yes, skip
SEL1    LIS     R5,0            :R5 = ready queue offset
SELOOP  LA      R6,READYQ,R5,   :R6 -> queue
        LHL     R4,READYQ,R5,   :IS QUEUE EMPTY?
        CR      R6,R4
        JN      SEL2            :No, skip
        AIS     R5,XQUEUE       :On to next queue
        CLHI    R5,NUMPRI*XQUEUE        :Done with queues?
        JLBS    SELOOP          :No, try next queue
:
:       Slot idle
:
        JAL     R4,CLKINC       :Update runtime clock
        LIS     R6,1            :R6 = slot idle flag
        STH     R6,PASIDL,,     :Signal slot idle
        SVC     DISMISS         :Return to ISIS
IDLRET  LIS     R6,0            :R6 = 0
        STH     R6,PASIDL,,     :Slot no longer idle
        JAL     R4,NIOCP        :Check for I/O completions
        JAL     R0,TIMOUT,,     :Check for timeouts
        J       SEL1            :Loop for ready processes
:
:       Activate a process
:
SEL2    JAL     R4,QUEGET       :Retrieve item from ready queue
        NDB2(2,R4,R5,2,R8,R6)
        LCS     R4,1            :R4 = -1
        AHM     R4,NUMRDY,,     :Decrement ready counter
        J       RNSERV          :Activate process
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:READY		MODULE:RDYRES
:
:	IF PRESENT PROCESS IS IN
:	MONITOR,ALLOW IT TO KEEP GOING. IF THERE IS A PROCESS IN MONITOR QUEUE,
:	BUMP THIS GUY FOR THE HIGHER PROCESS.
:	IF PROCESS IS IN AN I/O
:	ROUTINE ALLOW HIM TO KEEP GOING.  ELSE CHECK THE I/O QUEUE AND BUMP
:	PRESENT PROCESS IF LIST IS NOT EMPTY.
:
:	ACCESSING MODULE:IOROUT,SIGSEN,TIMRT,RNINTC,GATLEA,GATCON
:
:	ACCESSED MODULE:RNUPDT,RNPREM,RDYENT
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
RDYRES	 EQ   .
	 LR   HD,HD		:PROCESS RUNNING?
	 JER  R0		:NO,RETURN
	LH	R4,NESTI1,HD	:GET MONITOR NESTING
	JG	RESC2		:DON'T STOP PROCESS IF IN MONITOR
	 JAL  R4,RNPREM		:PREEMPT RUNNING PROCESS
	 JAL  R9,RDYENT		:RE-ENTER HIM ON READY QUEUE
RESC2	 JR   R0
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	CLASS:READY		MODULE:RDYINI
:
:	INITIALIZE THREE READY QUEUES(MONITOR,I/O, & NORMAL PROCESS).
:	CLEAR SYSTEM IDLE FLAG(PASIDL).
:
:	ACCESSING MODULE:(NOT ACCESSED - CODE IS REPRESENTATION OF IPL ACTION)
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
RDYINI	 EQ   .
	 :PUSHR4
	LHI	R5,(NUMPRI-1)*XQUEUE	:QUEUE OFFSET
RDYINL	LA	R6,READYQ,R5,	:ADDR OF A READY QUEUE
	QUEINI(R6)		:INIT THE QUEUE
	SIS	R5,XQUEUE	:MORE QUEUES?
	JGEBS	RDYINL		:YES, LOOP
	LIS	R4,0
	 STH  R4,PASIDL,,
	STH	R4,NUMRDY,,	:Start with none on queue
	 :POPR4
	 JR   R0
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	GATE ENTRY AND LEAVING DUMP ROUTINE
:	CALLED FROM GATENT AND GATLEA
:	BEFORE CALLING,
:	 THE R0 SHOULD BE SET TO 0, IF CALLING FROM GATENT
:	 R0 SET TO 1, IF CALLING FROM GATLEA
:	LINKAGE REG = R4
:	DESTROYS R5 AND R9
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	IF	GATRAC		:OPTION FOR ASSEMBLING
:
GATTRC	LHL	R5,GATCPT,, 	:GET THE POINTER TO THE TRACE TABLE
	ST	HD,GATCTB,R5,	:SAVE THE PROCESS HEADER POINTER
	L	R9,INDEX1,HD	:GET THE PROCESS INDEX
	STH	R9,GATCTB,R5,	:OVERWRITE TO THE FIRST HALF WORD
	LHL	R9,XMPSET,HD	:GET PROCESS MAC SET
	STH	R9,GATCTB+4,R5,	:SAVE IT
	LHL	R9,XMPCUR,,	:GET CURRENT MAC SET
	STB	R9,GATCTB+4,R5,	:OVERWRITE IT
	STH	G,GATCTB+6,R5,	:SAVE THE GATE ADDR 
	ST	R14,GATCTB+8,R5,	:SAVE R14
	ST	R15,GATCTB+$A12,R5,	:SAVE R15	  
	STB	R0,GATCTB+8,R5,	:OVERWRITE THE ENTRY TYPE 
				:BYTE TO 3RD WORD
	AHI	R5,$0 10		:BUMP POINTER
	NHI	R5,$0 7FF	:MODULO WHATEVER
	STH	R5,GATCPT,,	:SAVE NEW VALUE
	JR	R4

	EI	:GATRAC


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:GATE  		MODULE:GATENT
:
:	THIS ROUTINE IS CALLED BY THE COMP. CODE WHEN A PROCESS ENTERS A
:	MONITOR.  THE DEPTH OF MONITOR CALLS FOR THIS PROCESS IS INCREMENTED
:	BY 1. PROCESS PRIORITY IS SET TO HIGHEST LEVEL(MONITOR PROCESS QUEUE).
:	THE PSW IS SET TO START EXECUTION ON THIS MONITOR.  IF THE GATE IS
:	OPEN, EXECUTION BEGINS.  OTHERWISE THE PRESENT PROCESS IS TERMINATED
:	AND PLACED ON THE MONITOR WAIT QUEUE.
:
:	INPUT: G - GATE TO BE ENTERED
:	       HD -PROCESS RECORD POINTER
:
:	ACCESSING MODULE:COMPILED CODE
:
:	ACCESSED MODULE:RNPREM,QUEPUT
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
GATENT	 EQ   .
	IF	GATRAC
	LIS	R0,0
	JAL	R4,GATTRC
	EI		
	LHI	R5,$020		:Index # for gtentc in ENTRTB
	ENTRCT(R5,R9)
	JAL	R4,SAVLIN
	SETPSW(R5)
	 LIS  R5,1		:INCREMENT LEVEL OF NESTING
	 AHM  R5,NESTI1,HD
	 LIS	R5,MONPRI	:MONITOR PRIORITY
	 STH  R5,PRIOR1,HD
	 L    R9,0,G		:RETRIEVE GATE ADR
         LR   R9,R9             :CHECK GATE ADDRESS
         JGFS GATEN0            :SKIP IF > 0
         JAL  R10,CRASH,,       :ELSE CRASH
         BC   0,0,0,$037
GATEN0   LHL  R5,OPEN,R9        :GET GATE STATUS
	JNFS	GATEN1		:skip forward if closed
	STH	HD,OPEN,R9	:close gate with process header addr!!
	J	NUEXI		:continue running process
:	 TS   OPEN,R9		:GATE TO MONITOR OPEN?
:	 JE   NUEXI		:YES,ALLOW PROCESS TO ENTER MONITOR
GATEN1	SETSTA(R4,ST.GAT)	:Gate wait state
	LR	R0,R9		:SAVE R9
	 JAL  R4,RNPREM		:NO,PREEMPT PROCESS
	LR	R9,R0		:RESTORE R9
	 LA   R6,WAITG,R9	:ADR OF GATE
	 JAL  R4,QUEPUT		:PLACE PROCESS IN Q WAITING FOR GATE TO OPEN
	 J    NUEXI		:LET NEXT PROCESS RUN
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:GATE		MODULE:GATLEA
:
:	THIS ROUTINE IS ENTERED BY THE COMP.CODE WHEN A PROCESS IS READY
:	TO LEAVE A MONITOR. THE RETURN ADR OF THE PSW IS SETUP TO COMPILED
:	CODE AFTER CALL TO GATLEA.  IF THE WAIT QUEUE FOR THIS MONITOR IS
:	NOT EMPTY,RETRIEVE NEXT PROCESS ON QUEUE AND ENTER ON READY QUEUE.
:	ELSE OPEN THE GATE. FINALLY DECREMENT THE LEVEL OF MONITOR NESTING.
:	IF LEVEL = 0,SET PRIORITY OF PRESENT PROCESS TO 2(NORMAL QUEUE). LET
:	HIGHEST PRIORITY PROCESS BEGIN EXECUTION.
:
:
:	INPUT:	G - GATE TO BE LEFT
:		HD- CURRENT RUNNING PROCESS POINTER
:
:	ACCESSING MODULE:COMPILED CODE
:
:	ACCESSED MODULE:QUEGET,RDYENT,RDYRES
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
GATLEA	 EQ   .
	IF	GATRAC
	LIS	R0,1
	JAL	R4,GATTRC
	EI
	LHI	R6,$024
	ENTRCT(R6,R9)
	JAL	R4,SAVLIN
	SETPSW(R6)
	 RABUG
	 L    R9,0,G		:RETRIEVE GATE ADR
	 LA   R6,WAITG,R9	:ADR OF MONITOR GATE
         LHL  R4,WAITG,R9       :ANYONE ELSE WAITING TO COME INTO MONITOR?
         CR   R6,R4
	 JN   LEAV1		:YES,GET NEXT GUY
	 XR   R4,R4		:NO,SET GATE OPEN
	 STH  R4,OPEN,R9
	 J    LEAV2		:SKIP AHEAD
LEAV1	 JAL  R4,QUEGET		:GET NEXT GUY WAITING
	 HDBUG(R8)
	STH	R8,OPEN,R9	:store header addr in gate
	 JAL  R9,RDYENT		:ENTER HIM ON READY QUEUE
LEAV2	 LH   R4,NESTI1,HD	:DECREMENT LEVEL OF MONITOR NESTING
	 SIS  R4,1
	 STH  R4,NESTI1,HD
	JL	LEAVCR		:Go crash if count becomes negative!
	 JN   NUEXI		:STILL NESTED,KEEP RUNNING THIS PROCESS
	 LIS  R4,NORPRI		:SET PRIORITY TO NORMAL
	 STH  R4,PRIOR1,HD
	 JAL  R0,RDYRES		:RE-ENTER PROCESS AT LOWER PRIORITY ON READY Q.
	 J    NUEXI		:LET NEXT HIGHEST PROCESS RUN

LEAVCR	JAL	R10,CRASH,,	:Crash
	BC	0,0,0,$028
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:GATE		MODULE:GATDEL
:
:	THIS ROUTINE IS ENTERED BY THE COMP. CODE TO SUPPORT THE DELAY
:	FUNCTION OF A MONITOR.	THE CURRENT PROCESS IS PREEMPTED AND THE
:	PSW IS SET TO EXECUTION IN COMP. CODE. QUEUE VARIABLE SET "DELAY".
:	 IF THE MONITOR WAIT QUEUE IS EMPTY,THEN OPEN THE GATE AND CONTINUE.
:	ELSE GET NEXT PROCESS WAITING TO COME IN,ENTER HIM ON READY QUEUE,
:	AND LET HIGHEST PRIORITY PROCESS RUN.
:
:	INPUT:	G  - GATE
:		R1  - QUEUE VARIABLE
:		HD - PROCESS HEADER POINTER
:
:	ACCESSING MODULE:COMPILED CODE
:
:	ACCESSED MODULE: RNPREM,QUEGET,RDYENT
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
GATDEL	 EQ   .
	LIS	R4,0
	ENTRCT(R4,R9)
	JAL	R4,SAVLIN
	LHL	R4,0,R1		:GET QUEUE VALUE
	JEFS	GATDL1		:SKIP IF NOT ALREADY IN USE
	IF	CLRCOR
	JAL	R10,CRASH,,	:CRASH IF IN USE
	BC	0,0,0,$029
	EI

GATDL1	SETSTA(R4,ST.DLY)	:Delay state
	SETPSW(R4)
	 JAL  R4,RNPREM		:PREEMPT PROCESS
	 RABUG
	 STH  R8,0,R1		:PLACE PROC HDR REC PTR IN DELAY QUEUE
	 L    R9,0,G		:RETRIEVE ADR OF GATE
	 LA   R6,WAITG,R9	:ANYBODY ELSE WAITING TO COME IN TO MONITOR?
         LHL  R4,WAITG,R9
         CR   R6,R4
	 JN   DELAY1		:YES,GET NEXT GUY
	 XR   R6,R6		:SET GATE OPEN
	 STH  R6,OPEN,R9
	 J    NUEXI		:LET NEXT PROCESS RUN
DELAY1	 JAL  R4,QUEGET		:RETIEVE NEXT PROCESS TO ENTER MONITOR
	 HDBUG(R8)
	STH	R8,OPEN,R9	:store header addr in gate
	 JAL  R9,RDYENT		:ENTER ON READY QUEUE
	 J    NUEXI		:LET NEXT PROCESS RUN
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:GATE		MODULE:GATCONT
:
:	THIS ROUTINE IS ENTERED BY THE COMP. CODE TO CONTINUE A PROCESS WAITING
:	FOR A SIGNAL.AN IMPLICIT RETURN THROUGH ROUTINE GATLEA ALLOWS THE
:	CONTINUED PROCESS TO BE ENTERED ON THE READY LIST WITHOUT PREEMPTING
:	THE CURRENT PROCESS. OTHERWISE,RESET THE QUEUE VARIABLE. ENTER THE
:	"CONTINUED PROCESS" ON THE READY LIST. DECREMENT MONITOR NESTING OF
:	CURRENT RUNNING PROCESS. IF THE PROCESS IS STILL NESTED,CONTINUE
:	RUNNING. ELSE SET PRIORITY TO NORMAL PROCESSING(2) AND ALLOW THE
:	HIGHEST PRIORITY PROCESS TO CONTINUE RUNNING.
:
:	INPUT: G - GATE
:	       R1 - QUEUE VARIABLE
:
:	ACCESSING MODULE:COMPILED CODE
:
:	ACCESSED MODULE:GATLEA,RDYRES,RDYENT
:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
GATCON	 EQ   .
	 LHL  R8,0,R1		:DELAY QUEUE SET TO CONTINUE ALREADY?
	 JE   GATLEA		:YES,EXIT MONITOR
	LIS	R5,4
	ENTRCT(R5,R9)
	JAL	R4,SAVLIN
	SETPSW(R5)
	 RABUG
	 HDBUG(R8)
	 XR   R5,R5		:ALLOW PROCESS IN DELAY QUEUE TO CONTINUE
	 STH  R5,0,R1
	L	R9,0,G		:get gate address
	STH	R8,OPEN,R9	:store header addr in gate
	 JAL  R9,RDYENT		:ENTER DELAYED PROCESS ON READY QUEUE
	 LH   R5,NESTI1,HD	:DECREMENT MONITOR NESTING
	 SIS  R5,1
	 STH  R5,NESTI1,HD
	JL	CONTCR		:Crash if count goes negative!
	 JN   NUEXI		:IF STILL NESTED, LET PROCESS RUN
	 LIS  R5,NORPRI		:OTHERWISE, BUMP PRIORITY BACK TO NORMAL
	 STH  R5,PRIOR1,HD
	 JAL  R0,RDYRES		:ENTER ON READY QUEUE AT LOWER PRIORITY
	 J    NUEXI		:ACTIVATE HIGHEST PRIOR PROCESS

CONTCR	JAL	R10,CRASH,,	:Crash
	BC	0,0,0,$02A
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:GATE			:MODULE:GATINT
:
:     THE INITIALIZE GATE ROUTINE IS USED TO SUPPORT THE
:    'MAIN GATE' OF A MONITOR. THIS ROUTINE SEEMS TO BE INVOKED
:     AS PART OF THE BEGIN MONITOR FUNCTION
:     MEMORY IS OBTAINED FOR THE GATE, AND THE ADDRESS
:     OF THE GATE IS STORED IN THE MONITOR'S GLOBAL SPACE IN
:     THE 1ST WORD.
:
:	ACESSING MODULE:PROCESS COMPILED CODE
:
:	ACESSED MODULE:GATINI
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
GATINT	 EQ   .
	LHI	R6,$01C
	ENTRCT(R6,R5)
	JAL	R4,SAVLIN
	SETPSW(R6)
	 RABUG
	 LHI  R8,XGATE		:SIZE OF GATE
	 JAL  R4,NEWCOR		:ALLOCATE SPACE FOR GATE
	 ST   R8,0,G		:PLACE ADR IN STACK FRAME
	 LH   R5,PASNGT,,		:NEXT GATE INDEX
	 STH  R8,PASGAT,R5,	:SAVE ADR OF GATE
	 AIS  R5,2		:INCREMENT INDEX
	 STH  R5,PASNGT,,		:SAVE INDEX
	 JAL  R4,GATINI		:INTERMEDIATE GATE INIT ROUTINE
	 J    NUEXI		:RETURN TO NEXT PROCESS
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:	CLASS:GATE			MODULE:GATINI
:
:
:     THIS ROUTINE IS A  SUB-ROUTINE OF THE INITIALIZAION ROUTINE
:     ABOVE.  IT MAKES THE PROCESS LOOK LIKE IT'S IN A MONITOR,
:     BUMPING 'NEST1', PRIORITY=0, AND CLOSING THE GATE. ALSO,
:     SINCE THE GATE IS BRAND SPANKING NEW, WE MAKE IT EMPTY.
:
:	INPUT: R8 - ADR OF GATE
:
:	ACESSING MODULE:GATINT
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
GATINI	 EQ   .
	LIS  R5,1		:INCREMENT LEVEL OF MONITOR NESTING
	AHM  R5,NESTI1,HD
	LIS	R5,MONPRI	:SET PROCESS PRIORITY = INSIDE MONITOR
	STH  R5,PRIOR1,HD
	TS   OPEN,R8		:IS GATE OPEN?,SET GATE CLOSED
	LA   R6,WAITG,R8	:ADDRESS OF EVENT QUEUE FOR THIS GATE
 	QUEINI(R6)		:INITALIZE QUEUE
	JR   R4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                                                     :
:       NUEXI - Exit the Nucleus                                      :
:                                                                     :
:                                                                     :
:       NUEXI is used to leave any Nucleus routine when any           :
:       necessary staticizing has been completed and we are           :
:       ready to return to the process.                               :
:                                                                     :
:       The exit is made by loading a new program status word         :
:       which contains the program counter and condition codes for    :
:       the current process.  If no process has yet been selected     :
:       to run (HD=0) then we split for the selection routine.        :
:                                                                     :
:       Input: HD -> Process Header Record                            :
:                                                                     :
:       Acessed by: Almost all nucleus routines                       :
:                                                                     :
:       Acesses: RNSERV                                               :
:                                                                     :
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
NUEXI   HS      0
        LR      HD,HD           :Running a process?
        JE      RDYSEL          :No, select a process to run
NUEXI3  HS      0
        LIS     R6,0            :R6 = bit offset
        RBT     R6,PASSWI,,     :Test and reset time limit flag
        JN      TIMRT           :Switch process
        JAL     R4,CLKINC       :Update runtime clock
        LIS     R6,0            :R6 = bit offset
:       TBT     R6,PASFLG,,     :Any I/O complete?
:       JN      IOROUT          :Yes, go to completion routine
        STM     HD,REG0-HEAD0+RGHD,HD   :Save key registers
        ST      HD,HDSAV,,      :Save process header address
        JAL     R0,TIMOUT,,     :Check for timeouts
        JAL     R4,NIOCP        :Check for I/O completion
        L       HD,HDSAV,,      :Restore process header address
       IF      XMEMRY
        LH      R10,XMPSET,HD   :R10 = process MAC Register set
        JAL     R4,XMCURR       :Make Mac set current
       EI      :XMEMRY
        LM      R0,REG0-HEAD0,HD        :Restore obj code environment
        UPSW    PRSPSW-HEAD0,HD
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
:	NUCLEUS intialization routine
:
:
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
START	 HS   0
	NDBINI(R0)
	SVC	DISMISS,0	:(IN CASE I WANT TO PATCH IN A PAUSE)
	LH	R0,LCX,,	:Offset of local clocks from NRATE
	LH	R1,SLOTNO,,	:Slot number
	SLLS	R1,2		:Convert to fullword index
	AR	R0,R1		:Make slot's offset in local clocks
	STH	R0,LCKOFF,,	:SAVE OFFSET
        SRL     R0,8            :NUMBER OF PAGES OF SEGMENT F
        STH     R0,XMSSFF,,     :SAVE FOR LATER
	LA	R0,PASKST+4,,	:INIT STACK POINTER
	ST	R0,PASKST,,
	LA	R0,BEGSTR,,	:INIT PHR AREA
	ST	R0,PASTOP,,
	LI	R0,SYSPAC	:SYSTEM SPACE
	ST	R0,PASFRE,,
	L	R0,PASINT,,	:BEGINNING OF USER AREA
	ST	R0,PASCTO,,
	L	R0,PCASIZ	:SIZE OF USER AREA
	ST	R0,PASCFR,,
	LA	R6,PASNEX,,	:ADDR OF 1-SEC WAIT QUEUE
	QUEINI(R6)		:INITIALIZE QUEUE
	:JAL	R4,RDYINI	:INIT READY QUEUE(S)
	JAL	R0,RDYINI	:INIT READY QUEUE(S)
:

	LA	R0,FORGND,,	:Address of foreground process
	SVC	SYS,CFGND.	:Start foreground process
	JAL	R0,IZT,,	:Initialize timeout checker
	JAL	R4,INITIO	:Initialize the I/O system
	LIS	R0,0		:GET A ZERO
	LA	R1,PASCLR,,	:START OF ZERO AREA
	LA	R2,PASCLX,,	:END
CLRLP0	STH	R0,0,R1 	:ZERO A HALF WORD
	AIS	R1,2		:BUMP POINTER
	CR	R1,R2		:AT END?
	JLBS	CLRLP0		:ZERO OUT AREA
:
:	COMPUTE END OF PROGRAM LENGTH FOR PARENT PROCESS. CLEAR OUT
:	CORE RESIDING BEYOND PARENT PROCESS.
:
        IF      XMEMRY
        LIS     R4,0            :R4 = 0
        SVC     5,0,R4          :Start execution in Set 0
XMSTAR  HS      0               :Startup address
        JAL     R4,XMINIK       :Init Extended Memory
        JAL     R4,XMSETK       :Build XM Set 1
        JAL     R4,XMSETC       :Tell ISIS about set 1
        LIS     R10,1           :R10 = MAC reg set
        JAL     R4,XMCURR       :Make Reg set 1 current
        ELSE
	IF	CLRCOR
	 L    R8,PASINT,,		:ADR OF BEGINNING OF USER SPACE
	 L    R6,PROGL,R8	:END OF PROGRAM FOR PARENT PROCESS
	 AR   R6,R8		:COMPUTE THIS ADR
	A	R8,PCASIZ	:COMPUTE END OF PASCAL AREA
CLRSP	STH	R0,0,R6 	:ZERO OUT A HALFWORD
	AIS	R6,2		:BUMP POINTER
	CR	R6,R8		:AT END OF PASCAL AREA?
	JLBS	CLRSP
        EI      :CLRCOR
        EI      :XMEMRY
:
:	INITIALIZE PARENT PROCESS
:
        L       R8,PASINT,,     :ADR OF START OF PARENT PROCESS
        JAL     R4,RNINTP       :INITIALIZE THE PROCESS
:
:
:	clear process queue and realtime clock parameter.
:	ACTIVATE FOREGROUND CLOCK
:
	 :JAL  R4,CLKINI	:INIT CLOCK PARMETERS
	 JAL  R0,CLKINI		:INIT CLOCK PARMETERS
	 IF   TIMSLI
	LIS	R0,0
        STH     R0,QCOUNT,,     :Make sure quantum timer starts inactive
	 JAL  R4,TIMRIN		:INIT FOREGROUND
	 EI
	JAL	R4,QTSTRT	:START QUANTUM TIMER FOR PARENT PROCESS
:
:	LINK TO PARENT PROCESS
:
	 J   NUEXI3
:
:	Special Seg 0 stuff, historical
:
:	Note presence here of ring buffers for dial driver if needed

        SEG     0
:
:	STORAGE FOR RING BUFFERS
:
	IF NDIAL

QB	BS	NAPORT*QBSIZ-1
	BS	1
BQ	BS	NAPORT*BQSIZ-1
	BS	1
	EI

	IF 0
	REMARK %Segment 0, low part 0-
	NUMBER SEG0LO
	REMARK x, high part 
	NUMBER S0HORG
	REMARK -
	NUMBER SEG0HI
	REMARK x
	EI

	SEG 1
	 EM
	 FO  COMMON
	WS	0
    :
: TTY driver storage - high part
:
:	The purpose of this file is to allocate space for the
:	TTY info table beyond the Nucleus storage areas.  This
:	is to prevent the use of RX3 instructions in some of
:	the more frequently used sections of code, which would
:	otherwise be necessary if a large number of PORTS were
:	defined.
:

	MO	.,TTYDRV
	SEG	A.DATA
	RA	0
	HS	0
TTYTBL  BS      (NTERM+NAUX)*TTSIZE     :TTY INFO TABLE
        EM
 :
: Pseudo device driver storage - high part
:
:	The purpose of this file is to allocate space for the
:	PIPE info table beyond the Nucleus storage areas.  This
:	is to prevent the use of RX3 instructions in some of
:	the more frequently used sections of code, which would
:	otherwise be necessary if a large number of pipes were
:	defined.
:

	MO	.,PSEUDO
        GL      XPIPE,NPIPE
        IF      XPIPE
         GL     PIPTBL,PPSIZE
        EI      :XPIPE
	SEG	A.DATA
        IF      XPIPE
	RA	0
	HS	0
PIPTBL	BS	NPIPE*PPSIZE	:PIPE info table
        EI
	EM
         SUBTTL  PASCAL CODE AREA ALLOCATION             palloc.nad
        REMARK  %PALLOC  02-15-85  AWT
:       CHANGE  XMSS0F FROM 1 TO 4
	LO	COMFIL
:
:	This file contains the definitions to set up the Pascal Code area.
:

	RA	0			:HEXADECIMAL

	SEG	1
PCASIZ	WC	PCASI1			:WORD TO CONTAIN PASCAL AREA SIZE
PCAEND	WC	PASEND			:WORD TO CONTAIN ADDRESS OF END OF AREA

  IF    1-(\PATCH0)
        SEG     0
PATCH0  WS      20                      :SEGMENT ZERO PATCH AREA
  EI
  IF    1-(\PATCH1)
        SEG     1
PATCH1  WS      20                      :SEGMENT ONE PATCH AREA
  EI
  IF    1-(\PATCH2)
        SEG     2
PATCH2  EQ      1
  EI

  IF  \SLOTSZ

	SEG	0
S0USE   EQ      ((.+2)+0FF)&(@0FF)         :MEMORY USED IN SEGMENT 0

	SEG	1
S1USE   EQ      ((.-10000)+0FF)&(@0FF)     :MEMORY USED IN SEGMENT 1

        IF      XMEMRY
        IF      XPIPE
SEUSE   EQ      (0DC+2*(MAXPRT+1)+4*$A19*(NMACSS+4)+$00FF)&(@0FF)
        ELSE
SEUSE   EQ      (0DC+2*(MAXPRT+1)+4*$A19*(NMACSS+3)+$00FF)&(@0FF)
        EI      :XPIPE
        ELSE
        IF      XPIPE
SEUSE   EQ      ((0D4+(2*(MAXPRT+1)))+4*$A19*4+$00FF)&(@0FF)
        ELSE
SEUSE   EQ      ((0D4+(2*(MAXPRT+1)))+4*$A19*3+$00FF)&(@0FF)
        EI      :XPIPE

        EI      :XMEMRY
PLEFT	EQ	SLOTSZ*400-(S0USE+S1USE+SEUSE)  :MEMORY LEFT FOR PASCAL AREA
	REMARK	%%
	RA	$0 0A
	NUMBER	PLEFT/1024
	RA	0
	REMARK	K-bytes left for Pascal Code Area

    IF  \PASSIZ
      IF PASSIZ*400-PLEFT
	REMARK	%Memory space exceeded by 
	NUMBER	PASSIZ*400-PLEFT
	REMARK	x bytes!
	REMARK	%Using available memory.
ADDSIZ	EQ	PLEFT
      ELSE
	RA	$0 0A
	REMARK	%Allocating 
	NUMBER	PASSIZ
	REMARK	K-bytes.
	RA	0
ADDSIZ	EQ	PASSIZ*400
      EI
    ELSE
ADDSIZ	EQ	PLEFT
    EI :PASSIZ
  ELSE
ADDSIZ	EQ	PASSIZ*400
  EI :SLOTSZ

  IF ADDSIZ-$A768*1024
ADDSIZ	EQ	$A768*1024
	REMARK	%Maximum Pascal area is 768K.
  EI

PCASI1	EQ	ADDSIZ
:
: Now allocate the space for the Pascal code
:
	SEG	USRBOT/10000	:SEGMENT WHERE CODE STARTS
PASEND	EQ	USRBOT+ADDSIZ	:END OF AREA
:
QNUM	EQ	2		:SEGMENT COUNTER
QSIZE	EQ	ADDSIZ		:SPACE LEFT TO ALLOCATE
:
	RE	0C
	SEG	QNUM
  IF QSIZE-10000		:ALLOCATE THE WHOLE SEGMENT?
	BS	10000		:YES, THEN DO SO.
QSIZE	EQ	QSIZE-10000	:LESS SPACE LEFT
  ELSE
	BS	QSIZE		:ALLOCATE REMAINING AMOUNT
QSIZE	EQ	0		:NOTHING LEFT TO DO
  EI
QNUM	EQ	QNUM+1		:NEXT SEGMENT
	ER

        IF      XMEMRY
XMSP00  EQ      $0 60
XMSP01  EQ      $0 50
XMSP02  EQ      $0 53
XMSP03  EQ      $0 70
XMSP04  EQ      $0 70
XMSP05  EQ      $0 70
XMSP06  EQ      $0 70
XMSP07  EQ      $0 70
XMSP08  EQ      $0 70
XMSP09  EQ      $0 70
XMSP0A  EQ      $0 70
XMSP0B  EQ      $0 70
XMSP0C  EQ      $0 70
XMSP0D  EQ      $0 70
XMSP0E  EQ      $0 41
XMSP0F  EQ      $0 42

	SEG	0
XMSS00  EQ      (S0USE^-8)-1
	SEG	1
XMSS01  EQ      (S1USE^-8)-1
XMSS02  EQ      0
XMSS03  EQ      0
XMSS04  EQ      0
XMSS05  EQ      0
XMSS06  EQ      0
XMSS07  EQ      0
XMSS08  EQ      0
XMSS09  EQ      0
XMSS0A  EQ      0
XMSS0B  EQ      0
XMSS0C  EQ      0
XMSS0D  EQ      0
XMSS0E  EQ      (SEUSE^-8)-1
XMSS0F  EQ      $0 04

XMSA00  EQ      $0 0
XMSA01  EQ      XMSS00+1
XMSA02  EQ      0
XMSA03  EQ      0
XMSA04  EQ      0
XMSA05  EQ      0
XMSA06  EQ      0
XMSA07  EQ      0
XMSA08  EQ      0
XMSA09  EQ      0
XMSA0A  EQ      0
XMSA0B  EQ      0
XMSA0C  EQ      0
XMSA0D  EQ      0
XMSA0E  EQ      $0 0
XMSA0F  EQ      $0 0

XMSPPV  EQ      $0 70
XMSAPV  EQ      XMSA01+XMSS01+1

QNUM    EQ      2
QSIZE   EQ      EMEMR3
QQSIZ   EQ      0
        RE      0C
       IF       QSIZE
XMSA0|QNUM| EQ  QQSIZ
XMSP0|QNUM| EQ  $0 53
      IF        QSIZE-$040
XMSS0|QNUM| EQ  $0 0FF
QQSIZ   EQ      QQSIZ+$0100
QSIZE   EQ      QSIZE-$040
      ELSE      :QSIZE-$040
XMSS0|QNUM| EQ  QSIZE*4-1
QQSIZ   EQ      XMSA01+XMSS01+1
QSIZE   EQ      0
      EI        :QSIZE-$040
       ELSE     :QSIZE
XMSA0|QNUM| EQ  QQSIZ
QQSIZ   EQ      QQSIZ+1
       EI       :QSIZE
QNUM    EQ      QNUM+1
        ER      :0C

EXPMAC  MACRO[
        BC      XMSP00,XMSS00        :MAC Set 0, Seg 0
        HC      XMSA00
        BC      XMSP01,XMSS01 
        HC      XMSA01
        BC      XMSP02,XMSS02        :MAC Set 0, Seg 2
        HC      XMSA02
        BC      XMSP03,XMSS03        :MAC Set 0, Seg 3
        HC      XMSA03
        BC      XMSP04,XMSS04        :MAC Set 0, Seg 4
        HC      XMSA04
        BC      XMSP05,XMSS05        :MAC Set 0, Seg 5
        HC      XMSA05
        BC      XMSP06,XMSS06        :MAC Set 0, Seg 6
        HC      XMSA06
        BC      XMSP07,XMSS07        :MAC Set 0, Seg 7
        HC      XMSA07
        BC      XMSP08,XMSS08        :MAC Set 0, Seg 8
        HC      XMSA08
        BC      XMSP09,XMSS09        :MAC Set 0, Seg 9
        HC      XMSA09
        BC      XMSP0A,XMSS0A        :MAC Set 0, Seg A
        HC      XMSA0A
        BC      XMSP0B,XMSS0B        :MAC Set 0, Seg B
        HC      XMSA0B
        BC      XMSP0C,XMSS0C        :MAC Set 0, Seg C
        HC      XMSA0C
        BC      XMSP0D,XMSS0D        :MAC Set 0, Seg D
        HC      XMSA0D
        BC      XMSP0E,XMSS0E        :MAC Set 0, Seg E
        HC      XMSA0E
        BC      XMSP0F,XMSS0F        :MAC Set 0, Seg F
        HC      XMSA0F
        WC      XMPSD           :-> PSD
        WS      2               :for Dan

        WS      $a19*(NMACSS-1)
        ]
        EI      :XMEMRY

	FO	COMFIL
         SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:                                                                     *
:       This program is the sole property and confidential            *
:       information of Tymshare, Inc., and may not be copied          *
:       in whole or in part or disclosed to any third party           *
:       without the prior written consent of Tymshare.                *
:                                                                     *
:**********************************************************************

	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	$A ($0S|Q|SIZE-10000);	REMARK	d bytes;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
    IF	\APROT0
	BC	APROT0	:SET AREA 0 PROTECTION
    ELSE
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	BC	6	:EXECUTION PROTECTED
    EI
    IF	\APROT1
	BC	APROT1	:SET AREA ONE PROTECTION
    ELSE
	BC	5	:WRITE PROTECTED
    EI
Q	EQ	2
	RE	0C
    IF	\APROT|Q|
	BC	APROT|Q|
    ELSE
	BC	6	:EXECUTION PROTECTED
    EI
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
      IF  XPIPE
        HC      NMACSS+4        :NUMBER OF MAC SETS
      ELSE
        HC      NMACSS+3        :Number of MAC Register Sets
      EI  :XPIPE
    ELSE
      IF  XPIPE
        HC      4
      ELSE
        HC      3
      EI  :XPIPE
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
Q      	EQ	3
MG0SG2	EQ	((S0SIZE+0FF)/(100))+((S1SIZE+0FF)/(100))
	RE	0B
MG0SG|Q| EQ	MG0SG|Q-1|+((S|Q-1|SIZE+0FF)/(100))
Q	EQ	Q+1
	ER	:0B
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
:
:	MAC SETS FOR PASCAL CODE LOAD
:
:	LOAD 1ST HALF
PASLD   HS      0
	BC	XMSP00,XMSS00	:SEG 0 MG 0
	HC	XMSA00
	BC	XMSP01,XMSS01	:SEG 1 MG 0
	HC	XMSA01	
	BC	XMSP01,XMSS02	:SEG 2 MG 0
	HC	MG0SG2
	BC	XMSP01,XMSS03	:SEG 3 MG 0
	HC	MG0SG3
	BC	XMSP01,XMSS04	:SEG 4 MG 0
	HC	MG0SG4	
	BC	XMSP01,XMSS05	:SEG 5 MG 0
	HC	MG0SG5
	BC	XMSP01,XMSS06	:SEG 6 MG 0
	HC	MG0SG6
	BC	XMSP01,XMSS07	:SEG 7 MG 0
	HC	MG0SG7
	BC	XMSPPV+3,XMSS02	:SEG 0 MG 1
	HC	XMSA02
	BC	XMSPPV+3,XMSS03	:SEG 1 MG 1
	HC	XMSA03
	BC	XMSPPV+3,XMSS04	:SEG 2 MG 1
	HC	XMSA04
	BC	XMSPPV+3,XMSS05	:SEG 3 MG 1
	HC	XMSA05
	BC	XMSPPV+3,XMSS06	:SEG 4 MG 1
	HC	XMSA06
	BC	XMSPPV+3,XMSS07	:SEG 5 MG 1
	HC	XMSA07
	BC	XMSP0E,XMSS0E	:SEG E MG 0
	HC	XMSA0E
	BC	XMSP0F,XMSS0F	:SEG F MG 0
	HC	XMSA0F
	WC	DDLA2
	WS	2
	
:	LOAD 2ND HALF
	BC	XMSP00,XMSS00	:SEG 0 MG 0
	HC	XMSA00
	BC	XMSP01,XMSS01	:SEG 1 MG 0
	HC	XMSA01	
	BC	XMSP01,XMSS08	:SEG 7 MG 0
	HC	MG0SG8
	BC	XMSP01,XMSS09	:SEG 9 MG 0
	HC	MG0SG9
	BC	XMSP01,XMSS0A	:SEG A MG 0
	HC	MG0SGA	
	BC	XMSP01,XMSS0B	:SEG B MG 0
	HC	MG0SGB
	BC	XMSP01,XMSS0C	:SEG C MG 0
	HC	MG0SGC
	BC	XMSP01,XMSS0D	:SEG D MG 0
	HC	MG0SGD
	BC	XMSPPV+3,XMSS08	:SEG 6 MG 1
	HC	XMSA08
	BC	XMSPPV+3,XMSS09	:SEG 7 MG 1
	HC	XMSA09
	BC	XMSPPV+3,XMSS0A	:SEG 8 MG 1
	HC	XMSA0A
	BC	XMSPPV+3,XMSS0B	:SEG 9 MG 1
	HC	XMSA0B
	BC	XMSPPV+3,XMSS0C	:SEG A MG 1
	HC	XMSA0C
	BC	XMSPPV+3,XMSS0D	:SEG C MG 1
	HC	XMSA0D
	BC	XMSP0E,XMSS0E	:SEG E MG 0
	HC	XMSA0E
	BC	XMSP0F,XMSS0F	:SEG F MG 0
	HC	XMSA0F
	WC	DDLA4
	WS	2
	
:	RETURN TO MACSET 0
	BC	XMSP00,XMSS00	:SEG 0 MG 0
	HC	XMSA00
	BC	XMSP01,XMSS01	:SEG 1 MG 0
	HC	XMSA01	
	BC	XMSPPV,XMSS02	:SEG 2 MG 0
	HC	MG0SG2
	BC	XMSPPV,XMSS03	:SEG 3 MG 0
	HC	MG0SG3
	BC	XMSPPV,XMSS04	:SEG 4 MG 0
	HC	MG0SG4	
	BC	XMSPPV,XMSS05	:SEG 5 MG 0
	HC	MG0SG5
	BC	XMSPPV,XMSS06	:SEG 6 MG 0
	HC	MG0SG6
	BC	XMSPPV,XMSS07	:SEG 7 MG 0
	HC	MG0SG7
	BC	XMSPPV,XMSS08	:SEG 8 MG 0
	HC	MG0SG8
	BC	XMSPPV,XMSS09	:SEG 9 MG 0
	HC	MG0SG9
	BC	XMSPPV,XMSS0A	:SEG A MG 0
	HC	MG0SGA
	BC	XMSPPV,XMSS0B	:SEG B MG 0
	HC	MG0SGB
	BC	XMSPPV,XMSS0C	:SEG C MG 0
	HC	MG0SGC
	BC	XMSPPV,XMSS0D	:SEG D MG 0
	HC	MG0SGD
	BC	XMSP0E,XMSS0E	:SEG E MG 0
	HC	XMSA0E
	BC	XMSP0F,XMSS0F	:SEG F MG 0
	HC	XMSA0F
	WC	DDLANP
	WS	2

        IF      XPIPE
:
:       MAC SET FOR PIPE
:
        BC      XMSP00,XMSS00
        HC      XMSA00
        BC      XMSP01,XMSS01
        HC      XMSA01
        BC      XMSPPV,XMSS02
        HC      MG0SG2
        BC      XMSPPV,XMSS03
        HC      MG0SG3
        BC      XMSPPV,XMSS04
        HC      MG0SG4
        BC      XMSPPV,XMSS05
        HC      MG0SG5
        BC      XMSPPV,XMSS06
        HC      MG0SG6
        BC      XMSPPV,XMSS07
        HC      MG0SG7
        BC      XMSPPV,XMSS08
        HC      MG0SG8
        BC      XMSPPV,XMSS09
        HC      MG0SG9
        BC      XMSPPV,XMSS0A
        HC      MG0SGA
        BC      XMSPPV,XMSS0B
        HC      MG0SGB
        BC      XMSPPV,XMSS0C
        HC      MG0SGC
        BC      XMSPPV,XMSS0D
        HC      MG0SGD
        BC      XMSP0E,XMSS0E
        HC      XMSA0E
        BC      XMSP0F,XMSS0F
        HC      XMSA0F
        WC      XMCURP
        WS      2

        EI      :XPIPE
	
    EI          :XMEMRY
	
CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols
X@'