(n,l,b)
(* n,x,b *)
(**********************************************************************)
(* **                  PROPRIETARY INFORMATION                     ** *)
(* **                                                              ** *)
(* **  This  source code listing constitutes the proprietary pro-  ** *)
(* **  perty of TYMNET.  The recipient, by receiving this program  ** *)
(* **  listing, agrees that neither this listing nor the informa-  ** *)
(* **  tion disclosed herein nor any part thereof shall be repro-  ** *)
(* **  duced or transferred to other documents or used or dis-     ** *)
(* **  closed to others for manufacturing or for any other purpose ** *)
(* **  except as specifically authorized in writing by TYMNET.     ** *)
(**********************************************************************)
!
(************************************************************************)
(*									*)
(*	TCONTS.NTV							*)
(*									*)
(*			      TABLE OF CONTENTS				*)
(*									*)
(*									*)
(*    SOURCE FILE NAME			SYSTEM TYPE			*)
(*									*)
(*	tconts.ntv		table of contents			*)
(*	flags.ntv	Definitions:	conditional compilation flags	*)
(*	vers.ntv		version					*)
(*	NVALvv.Arr		configuration definitions		*)
(*	globl.ntv		global definitions			*)
(*	devmax.ntv		device maximum definitions		*)
(*	devdef.ntv		device and I/O definitions		*)
(*	lvdef.ntv		logical volume definitions		*)
(*	cgdef.ntv		Class/group defintions			*)
(*	cuddef.ntv		CUD defintions				*)
(*	prmdef.ntv		CUD parameter definitions		*)
(*	fildef.ntv		file system definitions			*)
(*	mchdef.ntv		MUD change definitions			*)
(*	arcdef.ntv		archive definitions			*)
(*	cmddef.ntv		command definitions			*)
(*	sysio.ntv	Miscellaneous:	system_handler Class		*)
(*	mutil.ntv		misc_utility Class			*)
(*	delutl.ntv		delay_utility Class			*)
(*	crash.ntv		crash_utility Class			*)
(*	cipher.ntv		password_cipher_utility Class		*)
(*	fifo.ntv		fifo Class				*)
(*	date.ntv		date_time_converter Class		*)
(*	circio.ntv	Circuit devices: circuit_handler Class		*)
(*	form.ntv		internal_to_string Class		*)
(*	pass.ntv		password_reader Class			*)
(*	lvutil.ntv		lvol_utility Class			*)
(*	stat.ntv		statistics_gatherer Monitor		*)
(*	profil.ntv		validator_profile Class			*)
(*	dsksys.ntv	File system:	disk_handler Class		*)
(*	filsys.ntv		file_system_manager Monitor		*)
(*	bscfl.ntv		basic_file Class			*)
(*	opdef.ntv		operator_log definitions		*)
(*	oplog.ntv		operator_log Monitor			*)
(*	opmsgs.ntv		operator_messages Class			*)
(*	futil.ntv		file_utility Class			*)
(*	cbutil.ntv		cud_block_utility Class			*)
(*	logonm.ntv		logon_distributer Monitor		*)
(*	mudutl.ntv	MUD change: mudupd_utility Class		*)
(*	mudchg.ntv		mud_change_handler Monitor		*)
(*	tick.ntv		mud_change_tick Process			*)
(*	un2acc.ntv		un2_access Monitor			*)
(*	cirutl.ntv		circuit_utility Class			*)
(*	un2utl.ntv		un2_utility Class			*)
(*	cudacc.ntv	CUD:	cud_access_controller Monitor		*)
(*	cudblk.ntv		cud_block_updater Class			*)
(*	cenutl.ntv		cud_entry_utility Class			*)
(*	consis.ntv		consistency Class			*)
(*	prmutl.ntv		cud_parameter_file_utility Class	*)
(*	cudprm.ntv		cud_parameter_controller Monitor	*)
(*	adduun.ntv		uun_supplier Class			*)
(*	17buun.ntv		bit17_supplier Process			*)
(*	18buun.ntv		bit18_supplier Process			*)
(*	retuun.ntv		return_uun Process			*)
(*	meruun.ntv		merge_uunfile Process			*)
(*	covcon.ntv		cud_overflow_controller Monitor		*)
(*	namacc.ntv		cud_name_controller Monitor		*)
(*	cudent.ntv		cud_entry_updater Class			*)
(*	cuputl.ntv		cud_updater_utility Class		*)
(*	mudupd.ntv		mud_updater Process			*)
(*	cgcont.ntv	Class/group: Class_group_handler Monitor	*)
(*	lisacc.ntv		node_host_list_access Monitor		*)
(*	lioutl.ntv		node_host_list_io_utility Class		*)
(*	lisall.ntv		node_host_list_allocater Monitor	*)
(*	lisutl.ntv		node_host_list_utility Class		*)
(*	symacc.ntv		sysmsg1_access Monitor			*)
(*	symutl.ntv		sysmsg1_utility Class			*)
(*	cgupd.ntv		Class_group_updater Process		*)
(*	logutl.ntv		logon_utility Class			*)
(*	logonp.ntv		accept_logon Process			*)
(*	conutl.ntv		configuration_utility			*)
(*	cmdtab.ntv	Commands:	command_table Monitor		*)
(*	argscn.ntv		argument_scanner Class			*)
(*	keyutl.ntv		keyword_utility Class			*)
(*	inpscn.ntv		terminal_input_scanner Class		*)
(*	cmderr.ntv		command_error_message Class		*)
(*	frutil.ntv		freeword_response_utility Class		*)
(*	keyscn.ntv		keyword_scanner Class			*)
(*	glbcmd.ntv		global_commands Class			*)
(*	cmdlp.ntv		command_loop Class			*)
(*	lvstat.ntv	Logical volumes: lvol_status_manager Monitor	*)
(*	lvdlg.ntv		lvol_dialogue Class			*)
(*	lvcopy.ntv		lvol_copy Class				*)
(*	lvrpt.ntv		lvol_reporter Process			*)
(*	lvstmp.ntv		lvol_time_stamp Process			*)
(*	lvdmt.ntv		lvol_disk_maintenance Process		*)
(*	cmdutl.ntv		command_level_utility Class		*)
(*	oprrpt.ntv		oplog_reporter Process			*)
(*	tapeio.ntv	Tape devices: tape_handler Class		*)
(*	talloc.ntv		tape_allocater Monitor			*)
(*	taputl.ntv	Validators:	tape_utility Class		*)
(*      filter.ntv              filter_utility Class                    *)
(*	arccmd.ntv		archive_commands Class			*)
(*	pswcmd.ntv		password_command_utility Class		*)
(*	pswlvl.ntv		password_command_level Process		*)
(*	cmdlvl.ntv		command_level Process			*)
(*	mstlvl.ntv		master_command_level Process		*)
(*	init.ntv	initial Process					*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	flags.ntv							*)
(*									*)
(*		Define all conditional assembly parameters.		*)
(*									*)
(*	BE SURE TO ADD A REFERENCE TO NEW PARAMETERS IN GLOBL.NTV.	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	08Jul86 - jrn							*)
(*	      - add SPECIAL flag					*)
(*	15Jul86 - jrn							*)
(*	      - add NETVAL_IS_BOTH for BUBBnet				*)
(*	13May86 - neh							*)
(*	       - add INCLUDE_DUMP flag					*)
(*	26Feb86 - jrn							*)
(*	      - add DISK_LOAD_TEST and NO_SUP_UPDATES flags		*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	09Oct85 - jrn							*)
(*	      - add VALIDATE_X25_NAMES					*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)




(************************************************************************)
(*									*)
(*	ALLOW_HOSTS_ON_NO_PASSWORD allows validators to set		*)
(*	up a user with the no password option and also have the ignore	*)
(*	host option off, i.e., the no password option does not force	*)
(*	not force the ignore host option.  It is NOT RECOMMENDED, for	*)
(*	security purposes, that this flag be enabled.			*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If CHANGES_TO_OPER_LOG is ENABLED, information about all CUD    *)
(*	changes is recorded in the OPER log file.			*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	The following is used to generate NVDM code to perform the	*)
(*	proper disk conversion (via the CONVERT command).		*)
(*									*)
(************************************************************************)
(*									*)
(*	These flag(s) may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If disk_maintenance_code is ENABLED, the code for the NETVAL	*)
(*	disk maintenance program will be generated.			*)
(*									*)
(************************************************************************)
(*									*)
(*	THIS PARAMETER IS NOT USER SETTABLE.				*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If INCLUDE_DUMP is ENABLED, NETVAL has the DUMP command		*)
(*	in the ARCHIVE sub-system to dump the CUD to tape in ascii.	*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If INCLUDE_LIST_DESCRIPTIONS is ENABLED, NETVAL handles node	*)
(*	and host list descriptions as well as node and host list names.	*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If LOGICAL_VOLUMES is ENABLED, NETVAL attempts to maintain	*)
(*	duplicate copies of each NETVAL file.  All disk writes go to	*)
(*	both copies; all disk reads come from the most efficient copy.	*)
(*	The disk units are defined in the NETVAL TYM file.  		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If NAME_LEGAL_PASSWORD is ENABLED, users are allowed to have	*)
(*	a password that is their username.				*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*  If NETVAL_IS_A_SLAVE is ENABLED, the concept of a NETVAL user is    *)
(*  changed. There may be no password only or account supervisor 	*)
(*  validators and only programmer validators may perform CUD changes.	*)
(*  All other CUD changes are requested from an auxilliary circuit with *)
(*  the username specified by MASTER_VALIDATOR_NAME, defined in the	*)
(*  configuration file.						        *)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file AND SHOULD ONLY	*)
(*	BE USED IF THE CUSTOMER MAINTAINS THEIR OWN VALIDATION PROGRAM.	*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*  If NETVAL_IS_BOTH is ENABLED, the concept of a NETVAL user may be	*)
(*  either a slave or an interactive user.				*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file AND SHOULD ONLY	*)
(*	BE USED IF THE CUSTOMER MAINTAINS THEIR OWN VALIDATION PROGRAM.	*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If NO_PASSWORD_ONLY_VALIDATORS is ENABLED, no users of password *)
(*	only level are allowed to login to NETVAL.			*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If OVERFLOW_CUD_ENTRIES is ENABLED, CUD entries overflow into   *)
(*	succeeding CUD blocks if there is no room in the hashed block.	*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If REUSE_UUNS is ENABLED a file of UUN's is maintained and old	*)
(*	UUN's are reassigned to new users.  This flag must not be used	*)
(*	with the UUNS_ASSIGNABLE flag.					*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If TYMSHARE_CUD_FORMAT is ENABLED, the CUD is in the Tymshare   *)
(*	format, rather than independant network format (IRC and		*)
(*	Tymshare CPARW bits are included).				*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file AND SHOULD ONLY	*)
(*	BE USED FOR TYMNET.						*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	UUNSassignable allows users to input the UUN on a NEW USER	*)
(*	command, rather than assigning the next sequential number	*)
(*	from the file.  This is not recommended except in special	*)
(*	circumstances (using UUN for purposes other than accounting).	*)
(*	NETVAL MAKES NO CHECKS FOR DUPLICATE UUN ASSIGNMENTS.  In	*)
(*	addition to assigning UUNS in the NEW USER command, the		*)
(*	command CHANGE UUN is made available.  This flag must not be	*)
(*	used with the REUSE_UUNS flag.					*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If VALIDATE_X25_NAMES is ENABLED, NETVAL handles the validation	*)
(*	of X.25 interface generated usernames with null passwords.	*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If PACK_CLASS_AND_GROUP_TABLE is ENABLED, NETVAL will include	*)
(*	extra code to attempt to store the Supervisor class and group	*)
(*	Table in a more compact form than usual.			*)
(*									*)
(************************************************************************)
(*									*)
(*	This flag may be enabled in the NVAL##.A## file.		*)
(*									*)
(************************************************************************)



(************************************************************************)
(*									*)
(*	NETVAL Version ?? and later allow for reconfigurations of	*)
(*	the NODE_HOST file from one set of configuration definitions	*)
(*	(the old NVAL##.A##) to another (the current, or new		*)
(*	NVAL##.A##).							*)
(*	The following 2 flags are used to generate code for the		*)
(*	new and old node host list file respectively.			*)
(*									*)
(************************************************************************)
(*									*)
(*	THESE PARAMETERS ARE NOT USER SETTABLE.				*)
(*									*)
(************************************************************************)




(************************************************************************)
(*									*)
(*	If DISK_LOAD_TEST is enabled, the master command level		*)
(*	processes will continually put CUD chanes into the mud change	*)
(*	file.  NETVAL_IS_A_SLAVE must be enabled; DISK_LOAD_TEST	*)
(*	causes extra code in CUDENT.NTV and modifies code in MSTLVL.NTV	*)
(*									*)
(************************************************************************)




(************************************************************************)
(*									*)
(*	If NO_SUP_UPDATES is enabled, no actual Supervisor updates will	*)
(*	be performed by the MUD updater process or the Class/group	*)
(*	updater process.  Code is modified in MUDUPD.NTV and CGUPD.NTV.	*)
(*									*)
(************************************************************************)





(************************************************************************)
(*									*)
(*	If SPECIAL is enabled:						*)
(*	      - the OLDPASS command is available			*)
(*	      - the CLEAN command is available				*)
(*									*)
(************************************************************************)

!
(************************************************************************)
(*									*)
(*	VERS.NTV							*)
(*									*)
(*	NOTE: All changes should be noted both in this file and in the	*)
(*		specific file changed under penalty of being drown in	*)
(*		a lot of wet MUD.					*)
(*									*)
(************************************************************************)

const

  version = 3;
  revision = 11;


!
(************************************************************************)
(*									*)
(*	Version 3.11	neh						*)
(*	ange make_new_file in MUDCHG.NTV to set sups	*)
(*		  greater than MAXIMUM_EXPECTED_SUPERVISORS to		*)
(*		  OFF, in order to correct bug for initializing		*)
(*		  MUDUPD in networks with less than 7 supervisors.	*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 3.10	neh						*)
(*	      - Correct bug in SET_CUD_ERROR in MASTER_level_utility;	*)
(*		added all cud errors to case statement.			*)
(*	      - Remove Change UUN command in master level conditional	*)
(*		on UUNSassignable being enabled.			*)
(*	      - Add VALIDATOR_OPLOG_MSG parameter to report_login	*)
(*		and report_logout calls in password level.		*)
(*	      - Add check for legal name in check_for_name_in_cud	*)
(*		in CUD entry updator.					*)
(*	      - Change compare username in FILTER utility to use	*)
(*		misc_utility.username_match.				*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 3.07	neh						*)
(*	      - Add Filter messages command with Display Filter command	*)
(*		to display the message types which are filtered.	*)
(*	      - Remove message command from global commands, include as	*)
(*		a primary command.					*)
(*	      - Change Oper_log_entry definition to include modify_kind,*)
(*		cud name, validator name, number and sup_number to	*)
(*		filter out messages with these references.		*)
(*	Version 3.06    jrn - rsb					*)
(*	      - fix USN/older Netval code anamolies in handling Sups	*)
(*		being turned ON and OFF and MUD updates and		*)
(*		consistencies, both automatic, initializing and manual	*)
(*		(MCHDEF.NTV, MUDCHG.NTV, MUDUPD.NTV, CONSIS.NTV,	*)
(*		CMDLVL.NTV)						*)
(*	      - allow SET GFD ONLY and CHANGE UUN AND GAN CUD changes	*)
(*		available if not Tymshare CUD format, mainly for	*)
(*		BUBBNET (CUDDEF.NTV, FORM.NTV, CUDENT.NTV, MSTLVL.NTV)	*)
(*	      - add the REMARK command (GLOBL.NTV, CMDDEF.NTV,		*)
(*		CUDENT.NTV, CMDTAB.NTV, CMDLVL.NTV, MSTLVL.NTV)		*)
(*	      - modify and simplify the UN2 access scheme (UN2ACC.NTV,	*)
(*		UN2UTL.NTV, CONSIS.NTV)					*)
(*	      - add DELETE CLASS, DELETE GROUP for clearing classes	*)
(*		and groups after a configuration change (CMDDEF.NTV,	*)
(*		CMDTAB.NTV, CMDLVL.NTV)					*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 3.05    neh - jrn - rsb					*)
(*	      - if TYMSHARE_CUD_FORMAT is ENabled, change the license	*)
(*		required for the COMPARE, DISPLAY CUD/MUD, GET, and	*)
(*		READ CUD/MUD commands to NETWORK ADMINISTRATOR; the	*)
(*		READ CUD LOCK command still requires PROGRAMMER		*)
(*		license (CMDTAB.NTV)					*)
(*	      - add "FAILED" comments to help catch the operators	*)
(*		attention when a STORE or RESTORE aborts (ARCCMD.NTV)	*)
(*	      - add the SPECIAL conditional compilation flag: makes the	*)
(*		OLDPASS and CLEAN commands available (FLAGS.NTV,	*)
(*		GLOBL.NTV, CMDDEF.NTV, CUDENT.NTV, CMDTAB.NTV,		*)
(*		CMDUTL.NTV, CMDLVL.NTV)					*)
(*	      - add GFDONLY to SELECT PASSWORDDATE command (CMDDEF.NTV,	*)
(*		CMDTAB.NTV, CMDUTL.NTV)					*)
(*	      - if an automatic initializing consistency loses its	*)
(*		circuit, restart the consistency where it left off	*)
(*		(MUDCHG.NTV)						*)
(*	      - add the conditional compilation flag, NETVAL_IS_BOTH,	*)
(*		which allows both interactive CUD changes and Netval	*)
(*		as a slave CUD updater; this flag was added primarily	*)
(*		for Bill Soley's use in Bubbnet, for access to CUD	*)
(*		information						*)
(*	      - if user is logging in with an auxilliary circuit,	*)
(*		prompt and check for password (LOGONP.NTV, CUDENT.NTV)	*)
(*	      - fix bug where password change date was not being	*)
(*		included in the MUD change data on a change to the no	*)
(*		password option (CUDENT.NTV, MSTLVL.NTV)		*)
(*	      - add DUMP command to ARCHIVE sub-system if INCLUDE_DUMP	*)
(*		flag is enabled in config file (FLAGS.NTV, NVAL03.A05,	*)
(*		GLOBL.NTV, ARCDEF.NTV, CMDDEF.NTV, CMDTAB.NTV, 		*)
(*		CMDUTL.NTV, TAPEIO.NTV, ARCCMD.NTV, CMDLVL.NTV)		*)
(*	      - fix bug that caused defining the consistency period	*)
(*		across the end of day boundry not to work (MUDCHG.NTV)	*)
(*	      - remove the check for legal username characters from	*)
(*		master circuits, since Tymnet front ends do their own	*)
(*		checking, and use some non Netval defined username	*)
(*		characters (MSTLVL.NTV)					*)
(*	      - add the count of UUNs merged to the operator log	*)
(*		message reporting the end of the merge			*)
(*	      - fix bug in GET_NAME routine that caused a range error	*)
(*		if a name longer than 20 characters is sent; and add a	*)
(*		check for legal username characters (MSTLVL.NTV)	*)
(*	      - add the validator index to the operator log change	*)
(*		CUD messages (CUDENT.NTV)				*)
(*	      - remove separate handling of delete user and remove user	*)
(*		(CUDENT.NTV, MSTLVL.NTV)				*)
(*	      - fix bug when changing password to a NULL password	*)
(*		(MSTLVL.NTV)						*)
(*	      - in the WRITE_UUN_PAGE routine, change uun_data not	*)
(*		to be a variable, so that the checksum that has been	*)
(*		set to all ones does not get cleared out on calls	*)
(*		from UUN_SUPPLIER (PRMUTL.NTV)				*)
(*	      - clear the UUN on the NEW USER command (MSTLVL.NTV)	*)
(*	      - change DISPLAY NEXT to DISPLAY PARAMETERS		*)
(*	      - fix bug that caused SYSMSG1 ACCESS CONTROLLER to crash	*)
(*		with a range error					*)
(*	      - fix timing for reading large Class/group Tables from	*)
(*		Supervisors						*)
(*	      - add CLASS and GROUP keywords to READ TABLE Command,	*)
(*		and output table creation time				*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 3.00    neb - pgl - jrn - rsb				*)
(*	      - added operlog_reporter for Tymnet to periodically	*)
(*		send status messages to the operator operator log	*)
(*		(MUDCHG.NTV, CMDUTL.NTV, OPRRPT.NTV, CMDLVL.NTV		*)
(*		INIT.NTV)						*)
(*	      - Sup numbers may range from 121 to 127 regardless of	*)
(*		MAXIMUM_EXPECTED_SUPERVISOR (MCHDEF.NTV, MUTIL.NTV,	*)
(*		FORM.NTV, MUDCHG.NTV, UN2ACC.NTV, UN2UTL.NTV		*)
(*		CONSIS.NTV, MUDUPD.NTV, SYMUTL.NTV, CGUPD.NTV,		*)
(*		CMDLVL.NTV, INIT.NTV, MERUUN.NTV)			*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list (the	*)
(*		changes will not take care of assigning greater than	*)
(*		18 bit UUNS, but will leave things open for that later	*)
(*		development						*)
(*	      - add PACK_CLASS_AND_GROUP_TABLE parameter		*)
(*	      - add warning to TYMNET operator if disk drive is more	*)
(*		than 1 hour old on initial bring up			*)
(*	      - add host status from Nucleus to HOST STATUS command	*)
(*	      - change classes that perform Nuclus I/O to have general	*)
(*		routines that pass single characters, the first of an	*)
(*		array to save code (CIRCIO.NTV, DSKSYS.NTV, TAPEIO.NTV)	*)
(*	      - for Tymnet only, check archive tapes to be sure they	*)
(*		are greater than 24 hours old (ARCCMD.NTV)		*)
(*	      - add the HOST (SHUT, STATUS, or UP) command (CMDDEF.NTV,	*)
(*		CMDTAB.NTV, CMDLVL.NTV)					*)
(*	      - remove abbreviations and sizes in command and keyword	*)
(*		definitions; handle in code; use procedures to build	*)
(*		the commands and keyword tables; generally clean up all	*)
(*		command and keyword handling code (CMDDEF.NTV,		*)
(*		CMDTAB.NTV, ARGSCN.NTV, KEYUTL.NTV, INPSCN.NTV,		*)
(*		CMDERR.NTV, FRUTIL.NTV, KEYSCN.NTV, GLBCMD.NTV,		*)
(*		CMDLP.NTV)						*)
(*	      - modify disk error operlog messages to include physical	*)
(*		address (FORM.NTV, FUTIL.NTV)				*)
(*	      - use control-I in login strings (UN2UTL.NTV, SYMUTL.NTV)	*)
(*	      - change DISPLAY LVOL to DISPLAY VOLUME for both Netval	*)
(*		and NVDM (CMDDEF.NTV, CMDTAB.NTV, CMDLVL.NTV)		*)
(*	      - perform a time validity check (MUDCHG.NTV)		*)
(*	      - add the FROM SUPERVISOR keywords to the WRITE CUD	*)
(*		command (CMDDEF.NTV, CMDTAB.NTV, CMDLVL.NTV)		*)
(*	      - remove the 3 functions, TYM_FILE_TERMINAL_COUNT, 	*)
(*		TYM_FILE_AUX_CIRCUIT_COUNT, KERNEL_HOST; replace with	*)
(*		a single sysio call in the initial statement, and the	*)
(*		entry variable sys_info (SYSIO.NTV, MUTIL.NTV,		*)
(*		CONUTL.NTV)						*)
(*	      - for Account Supervisor and Password Only validators,	*)
(*		add AUDITOR and OPERATOR control option message to	*)
(*		REPORT_LOGIN procedure (OPMSGS.NTV)			*)
(*	      - change NEW USER AS command, so that it blocks account	*)
(*		supervisor users from validating new users with class 0	*)
(*		or group 0 if CLASS_0_GROUP_0_ASSIGNABLE is FALSE	*)
(*		(CMDLVL.NTV)						*)
(*	      - change the license required for the CHECK command, so	*)
(*		that operators may use it to check for usernames when	*)
(*		there has been a disk problem (CMDTAB.NTV)		*)
(*	      - send a message to the supervisor ERLOG when a Supervisor*)
(*		is turned ON or OFF (DEVDEF.NTV, CIRCIO.NTV, LVRPT.NTV, *)
(*		CMDLVL.NTV)						*)
(*	      - add a REPEAT keyword to the DISPLAY UPDATES command	*)
(*		(CMDDEF.NTV, CMDTAB.NTV, CMDLVL.NTV)			*)
(*	      - add the conditional parameter VALIDATE_X25_NAMES	*)
(*		(CMDDEF.NTV, CMDTAB.NTV, FRUTIL.NTV, CMDLVL.NTV)	*)
(*	      - add the conditional parameters (almost EVERYwhere!):	*)
(*			TYMSHARE_CUD_FORMAT				*)
(*			NETVAL_IS_A_SLAVE				*)
(*			REUSE_UUNS					*)
(*			CHANGES_TO_OPERLOG				*)
(*			OVERFLOW_CUD_ENTRIES				*)
(*			NO_PASSWORD_ONLY_VALIDATORS			*)
(*			INCLUDE_LIST_DESCRIPTIONS			*)
(*			LOGICAL_VOLUMES					*)
(*	      - remove the keyword UNIT from ARCHIVE commands		*)
(*		(CMDDEF.NTV, CMDTAB.NTV, FRUTIL.NTV, ARCCMD.NTV,	*)
(*		CMDLVL.NTV)						*)
(*	      - increase incarnation to 1; 				*)
(*		new format node_host file; treat CUD PARAMETER file	*)
(*		as a separate file; add checksums to operlog and	*)
(*		node_host file entries (FILDEF.NTV			*)
(*	      - added checksums to operator log records (OPDEF.NTV,	*)
(*		OPLOG.NTV)						*)
(*	      - add node_host list configuration information, list	*)
(*		descriptions and checksums to the node_host file;	*)
(*		use global_access definition for both classes and	*)
(*		groups; use the NODE_HOST_LIST_ALLOCATER Monitor	*)
(*		to allocate and deallocate lists (FILDEF.NTV,CMDDEF.NTV,*)
(*		CMDTAB.NTV, LISALL.NTV, LISACC.NTV, LIOUTL.NTV,		*)
(*		LISUTL.NTV, CIRCIO.NTV, INPSCN.NTV, CMDLVL.NTV)		*)
(*	      - use Engine checksum (SYSIO.NTV, CUDBLK.NTV, MUDUPD.NTV)	*)
(*	      - changed MAXIMUM_CONSISTENCY_RETRIES to			*)
(*		MAXIMUM_UN2_RETRIES, and it is now used for both	*)
(*		consistency and MUD change updates (NVAL02.A03,		*)
(*		UN2UTL.NTV)						*)
(*	      - change disk_system to perform I/O on lists, classes	*)
(*		and groups and use basic_file only to caluclate		*)
(*		addresses (DSKSYS.NTV, BSCFL.NTV, OPLOG.NTV, FUTIL.NTV,	*)
(*		MUDCHG.NTV, CMDLVL.NTV, INIT.NTV)			*)
(*	      - change archive to read and write ANSII standard		*)
(*		format tapes (ARCDEF.NTV, TAPEIO.NTV, ARCCMD.NTV)	*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 2.04							*)
(*									*)
(*	25Mar85 - jrn							*)
(*	      - add allow_hosts_on_no_pasword flag (CMDLVL.NTV)		*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 2.03							*)
(*									*)
(*	      - fixed a bug that caused the wrong block number to be	*)
(*		displayed to the validator when an error is		*)
(*		detected in the CUD (CUDENT.NTV, CMDLVL.NTV)		*)
(*	      - fixed a bug that allowed a format error in a CUD block	*)
(*		to crash NETVAL; if an odd size is picked up, the total	*)
(*		size of the data in the CUD block is then odd, and the	*)
(*		Nucleus checksum call causes an illegal instruction	*)
(*		(CBUTIL.NTV)						*)
(*	      - change the format of CUD error message in DISPLAY	*)
(*		DIRECTORY command (CMDLVL.NTV)				*)
(*	      - fix leading comma in write_table_classes (CMDLVL.NTV)	*)
(*	      - allow READ CUD to retain the data in its buffer if it	*)
(*		encounters a checksum error on the disk (CMDLVL.NTV)	*)
(*	      - do not allow the CHANGE DISTRICT command if		*)
(*		INCLUDE_DISTRICT is FALSE (CMDLVL.NTV)			*)
(*	      - fixed a bug that prevented access of Class 30		*)
(*		(LISUTL.NTV)						*)
(*	      - improve format of CUD error message during store and	*)
(*		restore (ARCCMD.NTV)					*)
(*	      - fixed bug that caused NETVAL to crash when simlutaneous	*)
(*		users accessed the file (LISACC.NTV)			*)
(*	      - consistencies are slightly faster due to reworking of	*)
(*		code (CONSIS.NTV)					*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 2.02							*)
(*									*)
(*	16Aug84 - jrn							*)
(*	      - fix bug in store_profile procedure: if the entry ended	*)
(*		with a full word of 0FFFF FFFF, and the entry was	*)
(*		getting smaller in size, the last half word of 0FFFF	*)
(*		was not being cleared in the MUD (change_size was not	*)
(*		computed properly) (CUDENT.NTV)				*)
(*	02Aug84 - jrn							*)
(*	      - fix bug in CHANGE CONTROL command; when user entry has	*)
(*		a full word of 0FFFF FFFF terminating the CUD entry	*)
(*		and control options, password and access profile are	*)
(*		changed, the parameters for the MUD change were not	*)
(*		computed correctly (CUDENT.NTV)				*)
(*	      - fix bug in read table (leading commas), and add a comma	*)
(*		to the last value in a list that continues on the next	*)
(*		line (CMDLVL.NTV)					*)
(*	      - change function netval_host_number to kernel_host to	*)
(*		return the kernel host number (SYSIO.NTV)		*)
(*	      - fix bug in LEGAL_CONSISTENCY function - compare		*)
(*		supervisor_index + PRINT_SUPERVISOR_OFFSET against	*)
(*		sysio.kernel_host (MUTIL.NTV)				*)
(*	      - fix bug in breaking out of change access command	*)
(*		(CMDLVL.NTV)						*)
(*	June 8, 1984 - jrn - pgl					*)
(*	      - add PROGRAMMER_ENTRY_CHANGEABLE (NVAL02.A02,		*)
(*		CMDLVL.NTV)						*)
(*	      - add SYSMSG1_UNEXPECTED_INPUT to sysmsg1_status		*)
(*		(CGDEF.NTV, FORM.NTV, SYMUTL.NTV)			*)
(*	      - make use of disk_maintenance_code flag - almost		*)
(*		EVERYWHERE						*)
(*	      - move RESTORE and add other utility ARCHIVE commands	*)
(*		out of NETVAL and into NVDM				*)
(*	      - removed DISPLAY SCHEDULE and DISPLAY SUPERVISORS	*)
(*		commands, since they are redundant (CMDDEF.NTV,		*)
(*		CMDTAB.NTV, MUDCHG.NTV, CMDLVL.NTV)			*)
(*	      - fix bug on CUD error in running consistency (CONSIS.NTV)*)
(*	      - fix bug in second argument to initialize FIFO (STAT.NTV)*)
(*	      - add ability to assign UUNs if configuration		*)
(*		parameter UUNSassignable is enabled; also add CHANGE	*)
(*		UUN and DISPLAY UUN commands (CONFIG.NTV, GLOBL.NTV,	*)
(*		CMDDEF.NTV, FRUTIL.NTV, CUDENT.NTV, CMDTAB.NTV,		*)
(*		CMDLVL.NTV, INIT.NTV)					*)
(*	      - remove extraneous arguments and variables (UN2ACC.NTV,	*)
(*		UN2UTL.NTV, MUDUPD.NTV, LISACC.NTV, LISUTL.NTV,		*)
(*		SYMACC.NTV, SYMUTL.NTV, ARCCMD.NTV, CMDLVL.NTV		*)
(*	      - remove more single use routines (CIRCUI.NTV, 		*)
(*		CBUTIL.NTV, MUDUTL.NTV, MUDCHG.NTV, TAPUTL.NTV,		*)
(*		MUDUPD.NTV, CONSIS.NTV, CUDACC.NTV, CUDENT.NTV,		*)
(*		INPSCN.NTV,						*)
(*		LOGONP.NTV, PSWLVL.NTV, CMDLVL.NTV, INIT.NTV)		*)
(*	      - combine extract_cud_block, extract_cud_offset and	*)
(*		extract_cud_size into extract_cud_value and include	*)
(*		report_header_error (MUDUTL.NTV)			*)
(*	      - combine modify_node_list and modify_host_list into	*)
(*		modify_list (LISUTL.NTV, CMDLVL.NTV)			*)
(*	      - change flag specifying type of list from node to host	*)
(*		(LISACC.NTV, LISUTL.NTV, CMDLVL.NTV)			*)
(*	      - append "? " to questions in keyscn.ntv instead of at	*)
(*		every call to input_answer (GLOBL.NTV, KEYSCN.NTV,	*)
(*		ARCCMD.NTV, PSWLVL.NTV, CMDLVL.NTV)			*)
(*	      - change command authorization structure to use licenses	*)
(*		instead of validator level only (GLOBL.NTV, CMDDEF.NTV,	*)
(*		PROFIL.NTV, CMDTAB.NTV, KEYUTL.NTV, INPSCN.NTV,		*)
(*		GLBCMD.NTV, LOGONM.NTV, LOGONP.NTV, CMDLVL.NTV)		*)
(*	      - strip out routines from cud_entry_utility (CEUTIL.NTV,	*)
(*		PSWLVL.NTV, CMDLVL.NTV)					*)
(*	      - add circuit_utility routines (CIRUTL.NTV, UN2UTL.NTV,	*)
(*		SYMUTL.NTV)						*)
(*	      - consolidated common message strings (FORM.NTV)		*)
(*	      - add AUDITOR license and control bit (GLOBL.NTV,		*)
(*		CUDDEF.NTV, FORM.NTV, PROFIL.NTV, CUDENT.NTV,		*)
(*		CMDTAB.NTV, LOGONM.NTV, CMDLVL.NTV)			*)
(*	      - change display_gan_or_all to continue on a CUD error	*)
(*		(CMDLVL.NTV)						*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 2.01  May 1, 1984 - jrn - neb				*)
(*	      - fix range error bug in use_circuit (CIRCIO.NTV)		*)
(*	      - fix bug in NEW USER AS if old user has NO_PASSWORD set	*)
(*		(CMDLVL.NTV)						*)
(*	      - remove duplicate code in CHANGE NAME (CMDLVL.NTV)	*)
(*		(CMDLVL.NTV)						*)
(*	      - fix NEW ACCESS to check for maximum number of entries	*)
(*	      - do not allow district zero (FRUTIL.NTV)			*)
(*	      - fix display of percent full of MUD_UPDATE_FILE		*)
(*		(MUDCHG.NTV)						*)
(*	      - fix formatting of nodes and hosts in in-place origin	*)
(*		(CMDLVL.NTV)						*)
(*	      - remove percent routine (MUTIL.NTV)			*)
(*	      - fix bug in not allowing new user to have a null pass-	*)
(*		word (CMDLVL.NTV)					*)
(*	      - fix bug in displaying in-place origin nodes (CMDLVL.NTV)*)
(*	      - re-use circuit on consecutive MUD changes (UN2UTL.NTV)	*)
(*	      - modify size of host list to match actual size		*)
(*		in version 1.14 (CGDEF.NTV)				*)
(*	      - modify length of node host file to match actual size	*)
(*		in version 1.14 (FILDEF.NTV)				*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*		(CMDDEF.NTV)						*)
(*	      - added the CLEAR_PAGE and CLEAR_BLOCK routines		*)
(*		(MUTIL.NTV)						*)
(*	      - on all routines that repeatedly call a routine to read	*)
(*		or write a page, check for error conditions before	*)
(*		going thru the loop again (CIRCIO.NTV)			*)
(*	      - removed sequential procedures (FUTIL.NTV)		*)
(*	      - use CLEAR_PAGE (MUDUTL.NTV)				*)
(*	      - do not attempt a MUD update or automatic consistency if	*)
(*		a manual consistency is running (MUDCHG.NTV)		*)
(*	      - set all Supervisors to OFF and the last_cg_creation to	*)
(*		zero on ARCHIVE store and restore (MUDCHG.NTV)		*)
(*	      - set a timeout of 30 seconds on circuits built		*)
(*		(UN2UTL.NTV)						*)
(*	      - change the error reporting to eliminate multiple	*)
(*		reports and report ranges of blocks transmitted in	*)
(*		consistencies (UN2UTL.NTV)				*)
(*	      - added the NO_CHANGE option (CONSIS.NTV)			*)
(*	      - removed unused variables (CUDENT.NTV)			*)
(*	      - fixed a bug in setting the new value of HIGHEST_ASSIGNED*)
(*		when the last list is deleted (LISUTL.NTV)		*)
(*	      - NEXT_HOST_LIST and NEXT_NODE_LIST were combined into	*)
(*		the single procedure NEXT_LIST (LISUTL.NTV)		*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*		(CMDTAB.NTV)						*)
(*	      - fixed bug in reporting status after retry logic		*)
(*		(TAPEIO.NTV)						*)
(*	      - added flag in the DEASSIGN_TAPE routine that makes it	*)
(*		optional to output the deassign message (TAPUTL.NTV)	*)
(*	      - more descriptive procedure names, shorter procedure	*)
(*		names where possible, single-use procedures combined,	*)
(*		various other efficiencies (ARCCMD.NTV)			*)
(*	      - get_unit remembers if the unit specified has been pre-	*)
(*		viously assigned, and if so, does not deassign it when	*)
(*		done (ARCCMD.NTV)					*)
(*	      - fix bug in display buffer unformatted for a full buffer	*)
(*		(CMDLVL.NTV)						*)
(*	      - when setting the home bit as a pre-determine value,	*)
(*		report that fact to the validator (CMDLVL.NTV)		*)
(*	      - change the format of DISPLAY UPDATES to type historical	*)
(*		consistency information before current information	*)
(*	 	(CMDLVL.NTV)						*)
(*	      - fixed bug on calling SORT in the NEW NODELIST command	*)
(*	 	(CMDLVL.NTV)						*)
(*	      - report if consistency already running on the CONSISTENCY*)
(*		command (CMDLVL.NTV)					*)
(*	      - on STOP command, if consistency is manual, report that	*)
(*		fact to the validator (manual consistencies cannot be	*)
(*		stopped) (CMDLVL.NTV)					*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*		(CMDLVL.NTV)						*)
(*									*)
(************************************************************************)
!
(************************************************************************)
(*									*)
(*	Version 2.0  February 14, 1984 - jrn - neb - pgl		*)
(*	      - MULTIPLE users; many COMMAND CHANGES; "?" is no longer	*)
(*		used as an escape character; spaces are not allowed in	*)
(*		list names; there are many new monitors to handle	*)
(*		multiple access to data structures			*)
(*	      - PASSWORD ONLY users see their password change date	*)
(*	      - ACCOUNT SUPERVISORS may see class, group, nodelist and	*)
(*		hostlist information; more values may be entered as	*)
(*		lists; new user command includes option to validate a	*)
(*		user with the same parameters as an old user		*)
(*	      - NETWORK ADMINISTRATORS have access to more information	*)
(*		about MUD, class/group updates and consistencies	*)
(*	      - ARCHIVE commands are in a separate sub-system; tape	*)
(*		units may be assigned and/or attached independately	*)
(*	      - PROGRAMMER commands are less prompting oriented; the	*)
(*		MUD buffer may be displayed in hexadecimal		*)
(*	      - CONFIGURATION parameters include:			*)
(*		minimum length password; non-alphanumeric character in	*)
(*		password; circuit delays; consistency retry count;	*)
(*		consistency report interval; terminal time out; option	*)
(*		to perform an automatic consistency when a supervisor	*)
(*		made legal						*)
(*									*)
(************************************************************************)
!
!
(************************************************************************)
(*          FILE:  NETVAL/NVDM CONFIGURATION FILE                       *)
(*  COMPANY NAME:  TRW                     Location:  Anaheim, CA       *)
(*   NODE NUMBER:  2131                                                 *)
(*   KERNAL HOST:  2131                        Host:  731               *)
(*   SLOT NUMBER:  01                                                   *)
(*       VERSION:  03.11                                                *)
(*    UPDATED BY:  Robert Nowell               Date:  01/23/91          *)
(************************************************************************)
(* >>>>>>>>>>>>>>>>>>>>>>  REVISION HISTORY  <<<<<<<<<<<<<<<<<<<<<<<<<< *)
(* SET CONSISTENCY_RESTARTABLE AND RUN_AUTO_CONSISTENCY_ON_SUP_INIT     *)
(* TO TRUE AND ENABLE UUNSASSIGNABLE.                     03/02/88  AMZ *)
(* DISABLE UUNSASSIGNABLE PARAMETER.                      03/09/88  AMZ *)
(* SHRUNK LU 1 TO 133560 SECTORS TO MAKE ROOM FOR ELF,                  *)
(*    AND CHANGED CLASSES & GROUPS TO 64 & 30 EACH W/6                  *)
(*    SECTORS EACH, AND DECREASED USERS TO 6 TOTAL.       01/09/89  RRN *)
(* INSTALLED VERSION 03.11 OF NETVAL CODE.                03/29/89  RRN *)
(* INCLUDE_DISTRICT=TRUE, TAPE_BLOCKING_FACTOR=1, AND                   *)
(*    DISABLED CONVERT_0_TO_1.                            05/03/89  RRN *)
(* Cosmetics.                                             05/03/90  RRN *)
(* * Enable allow_hosts_on_no_password.                   01/23/91  RRN *)
(************************************************************************)
(************************************************************************)
(*									*)
(*	NVAL03.A10	Sample Netval Configuration File		*)
(*									*)
(*	This file contains all user-defined options for Netval.		*)
(*									*)
(************************************************************************)
(*									*)
(*	NOTE:								*)
(*		- if any entry marked:					*)
				(***)
(*		  is changed, the Netval Disk Maintanance program	*)
(*		  must be run to reset the parameter on the disk	*)
(*		  configuration file					*)
(*		- All numeric values in this file are DECIMAL,		*)
(*		  unless otherwise specified.				*)
(*		- Supervisor referencs are for Version 41 and later,	*)
(*		  and refer to macros in the Tym file.  For versions	*)
(*		  prior to Version 41, the appropriate Supervisor	*)
(*		  value must correspond to the Netval value.		*)
(*									*)
(************************************************************************)



(********************************************************)
(*							*)
(*	Define the size of disk Unit zero.		*)
(*							*)
(********************************************************)

const
(***) DISK_UNIT_ZERO_SIZE = 19080 (* in sectors *);



(********************************************************)
(*							*)
(*	Define the size of disk Unit one, so that the	*)
(*	maximum size MUD change file may be used.	*)
(*							*)
(********************************************************)

(***) DISK_UNIT_ONE_SIZE = 133560 (* in sectors *);



(************************************************************************)
(*									*)
(*	Define the size of the OPER log file.				*)
(*									*)
(*	Disk unit one requires room for the following files:		*)
(*									*)
(*	     FILE			REQUIRED SIZE IN SECTORS	*)
(*	Configuration				1			*)
(*	Node host lists			installation dependant		*)
(*	Class group			installation dependant		*)
(*			(see below, total of MAXIMUM_CLASS_TABLE_SIZE	*)
(*			 and MAXIMUM_GROUP_TABLE_SIZE)			*)
(*	CUD buffer			installation dependant		*)
(*			(see below, MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS)	*)
(*	MUD buffer			installation dependant		*)
(*			(see below, MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS)	*)
(*	OPER log			   variable			*)
(*	MUD change			   variable			*)
(*									*)
(*									*)
(*				OPER LOG File				*)
(*									*)
(*	The minimum size recommended for the OPER log file is 3		*)
(*	sectors; however, since there is only one message written	*)
(*	per sector, this is not very useful; reports of logins,		*)
(*	logouts, consistency differences and error conditions are	*)
(*	reported to the OPER log; if the parameter CHANGES_TO_OPER_LOG	*)
(*	is ENabled, information about ALL CUD changes will be recorded	*)
(*	in the file, so it will be very useful to have a fairly large	*)
(*	OPER log file.							*)
(*									*)
(*									*)
(*				MUD CHANGE File				*)
(*									*)
(*	There must be enough room left on disk unit one for the MUD	*)
(*	change file; all CUD changes are recorded in the MUD change	*)
(*	file and a process notifies all Supervisors to make the		*)
(*	change to its MUD.  When all changes have been sent to all	*)
(*	Supervisors, the file is deleted.				*)
(*									*)
(*	If there is a Supervisor defined by Netval, but not available	*)
(*	for updates, and many changes are accumulating in the file,	*)
(*	the Supervisor may be turned "off" as far as Netval is		*)
(*	concerned with the SET SUPERVISOR command.  As the file		*)
(*	becomes full, messages are written to the OPER log (at		*)
(*	approximately 50% full, 75% full, etc.).			*)
(*									*)
(*	IF THERE IS NOT ROOM IN THE MUD CHANGE FILE TO RECORD THE	*)
(*	INFORMATION ABOUT A CUD CHANGE, THE CHANGE TO THE CUD MAY	*)
(*	NOT BE MADE.  Many changes (change control, change district,	*)
(*	change password, change gan) require only about 24 bytes.	*)
(*	Other changes (change access, delete access, delete user,	*)
(*	new access, new user) are larger, and the size of the change	*)
(*	depends both on the change itself and possible other		*)
(*	information in the CUD block.  A CHANGE NAME command, since it	*)
(*	involves changes to 2 different CUD blocks, requires room for	*)
(*	2 entire CUD blocks (2 * MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS).	*)
(*									*)
(*	With a CUD of 10223 blocks and 8 sectors per block, the maximum	*)
(*	size operator log can be about 71,000 sectors; this is so that	*)
(*	all the Netval data fits on a single backup tape with		*)
(*	TAPE_BLOCKING_FACTOR as 8.					*)
(*									*)
(************************************************************************)

(***) OPERLOG_FILE_LENGTH = 40000 (* sectors *);




(*************     CUD FILE PARAMETERS     **************)


(********************************************************)
(*							*)
(*	The maximum number of expected Supervisors:	*)
(* Must be greater than or equal to 1, less than or	*)
(* equal to 7.						*)
(* This is the number of Pascal processes and auxilliary*)
(* circuits that will be allocated for the Supervisors.	*)
(* The ACTUAL Supervisors used by Netval are defined	*)
(* with the SET command; only those Supervisors defined	*)
(* with the SET command will be updated or accessed by	*)
(* Netval.						*)
(*							*)
(********************************************************)
(*							*)
(*	THIS NUMBER MUST AGREE WITH "NSUP" DEFINED	*)
(*	IN THE Netval SLOT TYM FILE.			*)
(*							*)
(********************************************************)

(***) MAXIMUM_EXPECTED_SUPERVISORS = 4;


(********************************************************)
(*							*)
(*	  The number of blocks in the CUD file:		*)
(* The size described by MAXIMUM_NORMAL_CUD_BLOCK is    *)
(* the number of blocks in the CUD file; the divisor is *)
(* used in the hashing algorithm.			*)
(*							*)
(********************************************************)
(*							*)
(* THIS VALUE MUST AGREE WITH THE SUPERVISOR VALUE.	*)
(*	(The fourth argument of DEFMUD; the default	*)
(*	 value is 2039.)				*)
(*							*)
(********************************************************)

(***) MAXIMUM_NORMAL_CUD_BLOCK = 2039;



(********************************************************)
(*							*)
(*	The number of sectors in a CUD block:		*)
(* Current possible values are 2, 4 or 8.		*)
(*							*)
(********************************************************)
(*							*)
(* THIS VALUE MUST AGREE WITH THE SUPERVISOR VALUE.	*)
(*	(The decimal value of the second argument	*)
(*	 of DEFMUD.)					*)
(*							*)
(********************************************************)

(***) MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS = 8;



(****************************************************************)
(*								*)
(* If Netval CUD is also a Supervisor MUD, Netval will not	*)
(* perform a consistency check on its own Supervisor.		*)
(* However, the Class/group table will be transmitted to all	*)
(* Supervisors.  Also, CUD changes currently MUST BE SENT TO	*)
(* THE UN2 slave in order to update the Supervisor's cache.     *)
(*								*)
(****************************************************************)

(***) NETVAL_CUD_IS_A_MUD = FALSE (* TRUE or FALSE *);



(****************************************************************)
(*								*)
(* THE FOLLOWING SHOULD ONLY BE TRUE IF ALL SUPERVISORS IN THE	*)
(* NETWORK ARE V41 OR LATER AND ALL HAVE UN2, VERSION 5.0	*)
(* OR LATER.							*)
(*								*)
(****************************************************************)
(*								*)
(* If CONSISTENCY_RESTARTABLE is TRUE, automatic consistencies	*)
(* attempt to restart at the block last processed if the circuit*)
(* is lost during the scheduled time period, and validators	*)
(* running a consistency may specify a start block.		*)
(*								*)
(****************************************************************)

  CONSISTENCY_RESTARTABLE = TRUE  (* TRUE or FALSE *);



(****************************************************************)
(*								*)
(* If the following is TRUE, when a supervisor is set to "ON"	*)
(* with the SET SUPERVISOR command, an automatic consistency	*)
(* will be run EVEN IF IT IS NOT DURING THE SCHEDULED		*)
(* CONSISTENCY PERIOD.  This initializing consistency will do	*)
(* its best to run to completion, i.e., the STOP command may	*)
(* halt it momentarily, but it will be persistent in trying	*)
(* to run again until complete.					*)
(*								*)
(****************************************************************)

  RUN_AUTO_CONSISTENCY_ON_SUP_INIT = TRUE  (* TRUE or FALSE *);




(*************     CUD ENTRY PARAMETERS     *************)



(********************************************************)
(*							*)
(* If INCLUDE_GAN is TRUE, the Global Account Number,	*)
(* and Account Supervisor control option is included	*)
(* in all CUD entries:					*)
(*							*)
(********************************************************)

(***) INCLUDE_GAN = TRUE (* TRUE or FALSE *);



(********************************************************)
(*							*)
(* If INCLUDE_DISTRICT is TRUE, the DISTRICT is		*)
(* included in all CUD entries:				*)
(*							*)
(********************************************************)

(***) INCLUDE_DISTRICT = TRUE  (* TRUE or FALSE *);



(********************************************************)
(*							*)
(*		Password parameters			*)
(*							*)
(********************************************************)

(***) MINIMUM_PASSWORD_SIZE = 0 (* if zero, no minimum size *);

(***) REQUIRE_NONALPHANUMERIC = FALSE (* TRUE or FALSE *);


(************************************************************************)
(*									*)
(*	If NAME_LEGAL_PASSWORD is ENABLED, users are allowed to have	*)
(*	a password that is their username.				*)
(*									*)
(************************************************************************)



(********************************************************)
(*							*)
(*	Restrict Account Supervisors from assigning	*)
(* Class 0, Group 0 to a user's access profile:		*)
(* If CLASS_0_GROUP_0_ASSIGNABLE is TRUE, Account	*)
(* Supervisor's MAY assign Class 0 and Group 0.		*)
(*							*)
(********************************************************)

(***) CLASS_0_GROUP_0_ASSIGNABLE = TRUE;



(************************************************************************)
(*									*)
(*	allow_hosts_on_no_password allows validators to set		*)
(*	up a user with the no password option and also have the ignore	*)
(*	host option off, i.e., if enabled, the no password option does	*)
(*	not force the ignore host option.  It is NOT RECOMMENDED, for	*)
(*	security purposes, that this flag be enabled.			*)
(*									*)
(************************************************************************)




(************************************************************************)
(*									*)
(*	If VALIDATE_x25_NAMES is ENABLED, Netval handles the validation	*)
(*	of X.25 interface generated usernames with null passwords.	*)
(*									*)
(************************************************************************)




(********************************************************)
(*							*)
(*		Define PROGRAMMER name:			*)
(* programmer name must be a legal name in the CUD.	*)
(*							*)
(********************************************************)

(***) PROGRAMMER_NAME_SIZE = 7 (* acTUal no. of characters in name *);


(* The username must be in UPPER case, and filled	*)
(* out to 20 characters.  (USERNAME_TEXT_MAX)		*)

(***) PROGRAMMER_NAME = 'NETPRIV             ';



(********************************************************)
(*							*)
(* If PROGRAMMER_ENTRY_CHANGEABLE is TRUE, the CUD	*)
(* entry for the name defined above may be changed	*)
(* as any other Netval name (by the user himself, by	*)
(* any Account Supervisor in his GAN, and by any	*)
(* Network Administrator).				*)
(*							*)
(* If PROGRAMMER_ENTRY_CHANGEABLE is FALSE, the CUD	*)
(* entry for the PROGRAMMER_NAME may ONLY be changed	*)
(* by a user logged in as the programmer.  Setting	*)
(* PROGRAMMER_ENTRY_CHANGEABLE to FALSE insures that	*)
(* the programmer's password, name and/or access	*)
(* profile will not be changed inadvertently by another	*)
(* validator.						*)
(* This implies that if the programmer password is	*)
(* "lost" (i.e., forgotten), in order to change the	*)
(* programmer's password, PROGRAMMER_ENTRY_CHANGEABLE	*)
(* must be set to TRUE, and Netval re-compiled and	*)
(* re-loaded.						*)
(*							*)
(********************************************************)

  PROGRAMMER_ENTRY_CHANGEABLE = TRUE;



(********************************************************)
(*							*)
(*	Define OPERATOR name:				*)
(* The name must be a legal name in the CUD; only the	*)
(* programmer and the operator may log into the	NVDM	*)
(* program to reconfigure or initialize the Netval	*)
(* disk, or to restore files from an Netval ARCHIVE	*)
(* backup tape.  In addition, if logical volumes are	*)
(* configured, at start-up time, if logical volumes may	*)
(* not be initialized automatically, only the PROGRAMMER*)
(* or the operator may login to initialize the system.	*)
(*							*)
(********************************************************)

  NVDM_OPERATOR_NAME_SIZE = 8 (* acutal no. of characters in name *);

(* The username must be in UPPER case, and filled	*)
(* out to 20 characters.  (USERNAME_TEXT_MAX)		*)

  NVDM_OPERATOR_NAME = 'NVDMOPER            ';




(************************************************************************)
(*									*)
(*	If LOGICAL_VOLUMES is ENABLED, Netval attempts to maintain	*)
(*	duplicate copies of each Netval file.  All disk writes go to	*)
(*	both copies; all disk reads come from the most efficient copy.	*)
(*	The disk units are defined in the Netval TYM file.		*)
(*									*)
(************************************************************************)




(************************************************************************)
(*									*)
(*	If NO_PASSWORD_ONLY_VALIDATORS is ENABLED, no users of password *)
(*	only level are allowed to login to Netval.			*)
(*									*)
(************************************************************************)



(************************************************************************)
(*									*)
(*	If CHANGES_TO_OPER_LOG is ENABLED, information about all CUD    *)
(*	changes is recorded in the OPER log file.			*)
(*									*)
(************************************************************************)




(************************************************************************)
(*									*)
(*	UUNSassignable allows users to input the UUN on a NEW USER	*)
(*	command, rather than assigning the next sequential number	*)
(*	from the file.  This is not recommended except in special	*)
(*	circumstances (using UUN for purposes other than accounting).	*)
(*	Netval MAKES NO CHECKS FOR DUPLICATE UUN ASSIGNMENTS.  In	*)
(*	addition to assigning UUNS in the NEW USER command, the		*)
(*	command CHANGE UUN is made available.				*)
(*									*)
(************************************************************************)


(********************************************************)
(*							*)
(*	If UUNSassignable is ENabled, ASSIGN_UUN_RADIX, *)
(*	ASSIGN_MINIMUM_UUN, ASSIGN_MAXIMUM_UUN and	*)
(*	ASSIGN_UUN_ON_NEW_USER_AS must be defined	*)
(*	appropriately.					*)
(*							*)
(*	If UUNSassignable is DISabled, ASSIGN_UUN_RADIX,*)
(*	ASSIGN_MINIMUM_UUN, ASSIGN_MAXIMUM_UUN and	*)
(*	ASSIGN_UUN_ON_NEW_USER_AS are meaningless.	*)
(*							*)
(********************************************************)




(********************************************************)
(*							*)
(*	ASSIGN_UUN_RADIX is the radix of the UUN that	*)
(*	is to be entered by the validator and displayed	*)
(*	by Netval.  The default is 8 (octal); other	*)
(*	possible values are 10 (decimal) and 16		*)
(*	(hexidecimal).					*)
(*							*)
(********************************************************)

  ASSIGN_UUN_RADIX = 8;



(********************************************************)
(*							*)
(*	ASSIGN_MINIMUM_UUN is the lowest numeric value	*)
(*	that Netval will accept when the validator	*)
(*	enters the UUN.  The default is 1.		*)
(*							*)
(********************************************************)

  ASSIGN_MINIMUM_UUN = 1;



(********************************************************)
(*							*)
(*	ASSIGN_MAXIMUM_UUN is the greatest numeric	*)
(*	value that Netval will accept when the		*)
(*	validator enters the UUN.  The default is	*)
(*	18 bits (maximum value of 262143).  Note that	*)
(*	the network accounting will handle UUNs of up	*)
(*	to only 24 bits (maximum value of 16777215).	*)
(*							*)
(********************************************************)

  ASSIGN_MAXIMUM_UUN = 262143;



(********************************************************)
(*							*)
(*	If ASSIGN_UUN_ON_NEW_USER_AS is TRUE, the	*)
(*	validator will be able to input the UUN on a	*)
(*	NEW USER AS "old-user" command, rather than	*)
(*	having the UUN be the same as the "old- user";	*)
(*	if ASSIGN_UUN_ON_NEW_USER is FALSE, the UUN of	*)
(*	the "old-user" will be used for the new user.	*)
(*							*)
(********************************************************)

  ASSIGN_UUN_ON_NEW_USER_AS = FALSE;




(************     Class/Group PARAMETERS     ************)



(************************************************************************)
(*									*)
(*	First the values that must agree with Supervisor values:	*)
(*									*)
(************************************************************************)



(********************************************************)
(*							*)
(*	The maximum host number in the network, i.e.,	*)
(*	the largest value that Netval will accept for	*)
(*	a host value:					*)
(*							*)
(********************************************************)
(*							*)
(* THIS VALUE MUST AGREE WITH THE SUPERVISOR VALUE.	*)
(*	(The DEFHST argument.)				*)
(*							*)
(********************************************************)

(***) MAXIMUM_HOST = 2277;



(********************************************************)
(*							*)
(* MAXIMUM_ORIGIN_HOST is the maximum value that may	*)
(* be input for a host in a user's access profile	*)
(* origin.						*)
(*							*)
(********************************************************)
(*							*)
(* For networks that use a separate range of origin	*)
(* hosts for accounting purposes (16384. = 4000x):	*)
(*	MAXIMUM_ORIGIN_HOST = maximum_host + 16384;	*)
(*							*)
(* For networks that DO NOT require a separate range	*)
(* of origin hosts for accounting purposes:		*)
(*	MAXIMUM_ORIGIN_HOST = maximum_host;		*)
(*							*)
(********************************************************)

  MAXIMUM_ORIGIN_HOST = maximum_host + 16384;



(********************************************************)
(*							*)
(*	The maximum node number in the network, i.e.,	*)
(*	the largest numerical value that Netval will	*)
(*	accept for a node number.			*)
(*							*)
(********************************************************)
(*							*)
(* THIS VALUE MUST AGREE WITH THE SUPERVISOR VALUE.	*)
(*  (The decimal value of the maximum node number for	*)
(*   Tymnet-II nodes, specified in the DEFNOD macro.)	*)
(*							*)
(********************************************************)

(***) MAXIMUM_NODE = 2277;



(********************************************************)
(*							*)
(*	The number of classes.				*)
(*							*)
(********************************************************)
(*							*)
(* THIS VALUE MUST AGREE WITH THE SUPERVISOR VALUE.	*)
(*	(The first argument of FENCE.)			*)
(*							*)
(********************************************************)
(*							*)
(*	When converting from incarnation 0 (Netval	*)
(*	version 2.xx) to incarnation 1 (Netval version	*)
(*	3.xx) MAXIMUM_CLASS MUST BE the same value as	*)
(*	for Netval version 2.xx (ENable CONVERT_0_TO_1).*)
(*							*)
(********************************************************)

(***) MAXIMUM_CLASS = 64;



(********************************************************)
(*							*)
(*	The total class table size IN BYTES:		*)
(*							*)
(********************************************************)
(*							*)
(* THIS VALUE MUST AGREE WITH THE SUPERVISOR VALUE.	*)
(*	(The second argument of FENCE * 256; the	*)
(*	 default value is 6 * 256. bytes)		*)
(*							*)
(********************************************************)

(***) MAXIMUM_CLASS_TABLE_SIZE = 6 * 256;



(********************************************************)
(*							*)
(*	The number of groups.				*)
(*							*)
(********************************************************)
(*							*)
(* THIS VALUE MUST AGREE WITH THE SUPERVISOR VALUE.	*)
(*	(The third argument of FENCE.)			*)
(*							*)
(********************************************************)
(*							*)
(*	When converting from incarnation 0 (Netval	*)
(*	version 2.xx) to incarnation 1 (Netval version	*)
(*	3.xx) MAXIMUM_GROUP MUST BE the same value as	*)
(*	for Netval version 2.xx (ENable CONVERT_0_TO_1).*)
(*							*)
(********************************************************)

(***) MAXIMUM_GROUP = 30;



(********************************************************)
(*							*)
(*	The total group table size IN BYTES:		*)
(*							*)
(********************************************************)
(*							*)
(* THIS VALUE MUST AGREE WITH THE SUPERVISOR VALUE.	*)
(*	(The fourth argument of FENCE * 256; the	*)
(*	 default value is 6 * 256. bytes)		*)
(*							*)
(********************************************************)

(***) MAXIMUM_GROUP_TABLE_SIZE = 6 * 256;



(************************************************************************)
(*									*)
(*	If PACK_CLASS_AND_GROUP_TABLE is ENABLED, Netval will include	*)
(*	extra code to attempt to store the Supervisor class and group	*)
(*	Table in a more compact form than usual.			*)
(*									*)
(************************************************************************)
(*									*)
(*	If PACK_CLASS_AND_GROUP_TABLE is ENABLED, Netval will build	*)
(*	a conversion table to attempt to determine classes and groups	*)
(*	that are sub-sets of other classes and groups.			*)
(*									*)
(*	MAXIMUM_GLOBAL_ACCESS must be defined as MAXIMUM_CLASS or	*)
(*	MAXIMUM_GROUP, whichever is GREATER.				*)
(*									*)
(*	MAXIMUM_LIST_INSTANCES_IN_GLOBAL_ACCESS must be defined as the	*)
(*	greatest number of lists in the definition of all classes OR	*)
(*	all groups.  The maximum value is:				*)
(*	    MAXIMUM_GLOBAL_ACCESS * MAXIMUM_LISTS_IN_GLOBAL_ACCESS	*)
(*	Netval displays a warning message on the SEND command when the	*)
(*	actual number of instances of lists is approaching this defined	*)
(*	value.								*)
(*	This value adds:						*)
(*		(MAXIMUM_LIST_INSTANCES_IN_GLOBAL_ACCESS * 6) +		*)
(*		 (MAXIMUM_GLOBAL_ACCESS * 10)				*)
(*	to Netval memory requirements.					*)
(*									*)
(*	If PACK_CLASS_AND_GROUP_TABLE is DISABLED, then			*)
(*	MAXIMUM_GLOBAL_ACCESS and					*)
(*	MAXIMUM_LIST_INSTANCES_IN_GLOBAL_ACCESS are meaningless.	*)
(*									*)
(************************************************************************)


  MAXIMUM_GLOBAL_ACCESS = MAXIMUM_CLASS;

  MAXIMUM_LIST_INSTANCES_IN_GLOBAL_ACCESS = 4096;



(************************************************************************)
(*									*)
(*	The following definitions affect the amouNt of disk to be	*)
(*	allocated for class, group, nodelist and hostlist information.	*)
(*	Changes to the values require a re-configruation of the disk	*)
(*	via the NVDM program.						*)
(*									*)
(************************************************************************)



(********************************************************)
(*							*)
(*	MAXIMUM_LIST is the total number EACH of	*)
(*	nodelists and hostlists allocated, i.e., there	*)
(*	are MAXIMUM_LIST nodelists available for	*)
(*	definition and MAXIMUM_LIST hostlists available	*)
(*	for definition.					*)
(*							*)
(********************************************************)
(*							*)
(*	The size of a single named list, in sectors, on	*)
(*	the disk, is determined by the following (refer	*)
(*	to definitions below):				*)
(*							*)
(* (MAXIMUM_NAMED_LIST_NAME_SIZE + 4 +			*)
(*  MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE + 4 + 4 +	*)
(*  (MAXIMUM_NAMED_LIST_ENTRY * 4) + 4 + 255) div 256	*)
(*							*)
(* Note: if INCLUDE_LIST_DESCRIPTIONS is not enabled,	*)
(*	MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE is zero,	*)
(*	and decrease the above by 4			*)
(*							*)
(********************************************************)
(*							*)
(*	When converting from incarnation 0 (Netval	*)
(*	version 2.xx) to incarnation 1 (Netval version	*)
(*	3.xx) MAXIMUM_LIST MUST BE 66 (ENable		*)
(*	CONVERT_0_TO_1).				*)
(*							*)
(********************************************************)

(***) MAXIMUM_LIST = 66;



(********************************************************)
(*							*)
(*	MAXIMUM_NAMED_LIST_NAME_SIZE is the maximum	*)
(*	number of characters allocated for the NAME of	*)
(*	a nodelist or hostlist.  Lists are identified	*)
(*	by their unique NAME, i.e., the entire name	*)
(*	must be entered and matched when identifying a	*)
(*	list; a longer list description (see next def-	*)
(*	inition) may be stored with the list and output	*)
(*	when information about the list is displayed.	*)
(*	The name may be shorter than in previous	*)
(*	versions (abbreviations, perhaps), for		*)
(*	ease of input.					*)
(*							*)
(********************************************************)
(*							*)
(*	This value must be EVEN and greater than zero;	*)
(*	the recommended range is 4 through 28.		*)
(*							*)
(********************************************************)
(*							*)
(*	When converting from incarnation 0 (Netval	*)
(*	version 2.xx) to incarnation 1 (Netval version	*)
(*	3.xx) MAXIMUM_NAMED_LIST_NAME_SIZE MUST BE 28	*)
(*	(ENable CONVERT_0_TO_1).			*)
(*							*)
(********************************************************)

(***) MAXIMUM_NAMED_LIST_NAME_SIZE = 28;


(************************************************************************)
(*									*)
(*	If INCLUDE_LIST_DESCRIPTIONS is ENABLED, Netval handles node	*)
(*	and host list DESCRIPTIONS as well as node and host list NAMES.	*)
(*									*)
(*	INCLUDE_LIST_DESCRIPTIONS may not be enabled when converting	*)
(*	from incarnation 0 to incarnation 1 of the Netval disk; unless	*)
(*	all list and Class/Group information is re-entered.		*)
(*									*)
(************************************************************************)




(********************************************************)
(*							*)
(*	MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE is the	*)
(*	maximum number of characters allocated for	*)
(*	the DESCRIPTION of a nodelist or hostlist if	*)
(*	INCLUDE_LIST_DESCRIPTIONS is enabled.  A list	*)
(*	description is used to provide additional infor-*)
(*	mation about a list; it is displayed with the	*)
(*	list definition and may be changed independantly*)
(*	of the other list information.			*)
(*							*)
(********************************************************)
(*							*)
(*	If INCLUDE_LIST_DESCRIPTIONS is ENABLED, this	*)
(*	value must be EVEN and greater than zero; the	*)
(*	total of MAXIMUM_NAMED_LIST_NAME_SIZE and	*)
(*	MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE must not be	*)
(*	greater than 72.				*)
(*							*)
(*	If INCLUDE_LIST_DESCRIPTIONS is DISABLED,	*)
(*	MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE		*)
(*	is meaningless.					*)
(*							*)
(********************************************************)

(***) MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE = 0;



(********************************************************)
(*							*)
(*	MAXIMUM_NAMED_LIST_ENTRY is the maximum number	*)
(*	of entries possible in a nodelist or hostlist,	*)
(*	i.e., it is the maximum number of nodes used to	*)
(*	define a nodelist and the maximum number of	*)
(*	hosts unsed to define a hostlist.		*)
(*							*)
(********************************************************)
(*							*)
(*	The recommended MINIMUM value (to fill out	*)
(*	a single disk sector) is:			*)
(*	(256 -						*)
(*	 (MAXIMUM_NAMED_LIST_NAME_SIZE + 16 +		*)
(*	  MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE))/4	*)
(*							*)
(* Note: if INCLUDE_LIST_DESCRIPTIONS is not enabled,	*)
(*	MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE is zero,	*)
(*	and change the "16" to a 12			*)
(*							*)
(********************************************************)
(*							*)
(*	When converting from incarnation 0 (Netval	*)
(*	version 2.xx) to incarnation 1 (Netval version	*)
(*	3.xx) MAXIMUM_NAMED_LIST_ENTRY MUST BE 114	*)
(*	(ENable CONVERT_0_TO_1).			*)
(*							*)
(********************************************************)

(***) MAXIMUM_NAMED_LIST_ENTRY = 114;



(********************************************************)
(*							*)
(*	MAXIMUM_LISTS_IN_GLOBAL_ACCESS is the maximum	*)
(*	number of nodelists and/or hostlists used to	*)
(*	define a "global_access"; a global_access is a	*)
(*	collection of named lists; also referred to as:	*)
(*							*)
(*	    CLASS - a collection of nodelists and/or	*)
(*		     hostlists				*)
(*	    GROUP - a collection of hostlists		*)
(*							*)
(********************************************************)
(*							*)
(*	When converting from incarnation 0 (Netval	*)
(*	version 2.xx) to incarnation 1 (Netval version	*)
(*	3.xx) MAXIMUM_LISTS_IN_GLOBAL_ACCESS MUST BE 8	*)
(*	(ENable CONVERT_0_TO_1).			*)
(*							*)
(********************************************************)

(***) MAXIMUM_LISTS_IN_GLOBAL_ACCESS = 8;


(************************************************************************)
(*									*)
(*	The total size of the NODE HOST LIST FILE is the size of all	*)
(*	lists plus the size of all global accesses.			*)
(*									*)
(************************************************************************)
(*									*)
(*		the size of all lists:					*)
(*									*)
(* - the size of a single list, to an integral number of disk sectors	*)
(*   (256 bytes), computed by the sum of (values are given in BYTES):	*)
(*	name:			MAXIMUM_NAMED_LIST_NAME_SIZE + 4	*)
	(* The following is included if		*)
	(* INCLUDE_LIST_DESCRIPTIONS is ENABLED:	*)
(*	description:		MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE + 4	*)
(*	count of values:	4					*)
(*	list of values:		MAXIMUM_NAMED_LIST_ENTRY * 4		*)
(*	checksum:		4					*)
(*									*)
(* - multiplied by the total number of lists (nodelists and hostlists):	*)
(*	MAXIMUM_LIST * 2						*)
(*									*)
(************************************************************************)
(*									*)
(*		the size of all global accesses:			*)
(*									*)
(* - the size of a single global access, computed by the sum of:	*)
(*	exception flag:		2					*)
(*	count of lists:		4					*)
(*	list representations:	MAXIMUM_LISTS_IN_GLOBAL_ACCESS * 6	*)
(*									*)
(* - multiplied by the number of global accesses:			*)
(*	MAXIMUM_CLASS + MAXIMUM_GROUP					*)
(*									*)
(* - plus:								*)
(*	checksum:		4					*)
(*									*)
(* - to an integral number of disk sectors				*)
(*									*)
(************************************************************************)




(*************     VALIDATOR DEFINITIONS     ************)


(****************************************************************)
(*								*)
(*	Validators who may only change their own password:	*)
(* This is the number of processes that will be set aside for	*)
(* password only validators, i.e., this number of validators	*)
(* who may only change their own password may log in at a time.	*)
(* If NO_PASSWORD_ONLY_VALIDATORS is ENABLED, this is forced	*)
(* to zero.							*)
(*								*)
(****************************************************************)

  NUMBER_OF_PASSWORD_ONLY_VALIDATORS = 1;



(****************************************************************)
(*								*)
(*	This is the maximum number of all other types of	*)
(* validators, logged in at a time, i.e.:			*)
(*		ACCOUNT SUPERVISORS				*)
(*		NETWORK ADMINISTRATORS				*)
(*		PROGRAMMERS					*)
(* Netval will always guarantee that there is at least ONE	*)
(* privileged validator (NETWORK ADMINISTRATOR or PROGRAMMER)	*)
(* either currently logged in or able to be logged in.  In	*)
(* other words, if there is no privileged validator logged in,	*)
(* Netval will save the last available login for a privileged	*)
(* validator.  This implies that if MAXIMUM_LICENSED_VALIDATORS	*)
(* is equal to 1, no ACCOUNT SUPERVISORS may ever log in.	*)
(*								*)
(* Note also that only one programmer may log in at a time.	*)
(*								*)
(****************************************************************)

  MAXIMUM_LICENSED_VALIDATORS = 3;


(********************************************************)
(*							*)
(* NOTE: the total number of possible validators	*)
(* defines the total number of terminal circuits	*)
(* required by the Pascal NUCLEUS, and MUST AGREE	*)
(* WITH THE Netval SLOT TYM FILE VALUE NUSERS:		*)
(*							*)
(* MAXIMUM_VALIDATOR = maximum_licensed_validators +	*)
(*	number_of_password_only_validators		*)
(*							*)
(********************************************************)




(* Re-try, Timeout and Reporting Interval Definitions *)



(********************************************************)
(*							*)
(* For processes that build automatic circuits		*)
(* (automatic consistency, MUD updates, and class/group	*)
(* updates), if the circuit build fails, re-try the	*)
(* build in FIRST_CIRCUIT_RETRY_DELAY seconds.		*)
(*							*)
(********************************************************)

  FIRST_CIRCUIT_RETRY_DELAY = 60 (* in seconds *);


(********************************************************)
(*							*)
(* For the automatic consistency and MUD updates	*)
(* automatic processes, when circuit building is not	*)
(* successful, double the retry time (starting with	*)
(* FIRST_CIRCUIT_RETRY_DELAY) on each failure, up to a	*)
(* maximum of MAXIMUM_CIRCUIT_RETRY_DELAY.		*)
(*							*)
(********************************************************)

  MAXIMUM_CIRCUIT_RETRY_DELAY = (32 * 60) (* in seconds *);



(********************************************************)
(*							*)
(* The maximum number of times to retry to send a block	*)
(* of data if the Supervisor reports that the checksum	*)
(* received did not match the one it computed (on a	*)
(* consistency or a MUD block update).			*)
(*							*)
(********************************************************)

  MAXIMUM_UN2_RETRIES = 4;



(********************************************************)
(*							*)
(* Interval to report consistency data (update and	*)
(* retry totals) in blocks.				*)
(*							*)
(********************************************************)

  CONSISTENCY_REPORT_INTERVAL = 32 (* report every 32 blocks *);



(********************************************************)
(*							*)
(* Interval to delay before checking to see if		*)
(* Class/group Table should be sent to any Supervisors.	*)
(*							*)
(* This is also the maximum time of delay if a circuit	*)
(* fails when trying to send a Class/group Table to a	*)
(* Supervisor.						*)
(* Also, for the automatic Class/group Table update	*)
(* process, when circuit building is not successful	*)
(* double the retry time (starting with			*)
(* FIRST_CIRCUIT_RETRY_DELAY) on each failure, up to a	*)
(* maximum of SEND_TABLE_DELAY.				*)
(*							*)
(********************************************************)

  SEND_TABLE_DELAY = 60 (* seconds *);


(********************************************************)
(*							*)
(* Number of times to retry on TAPE errors.		*)
(*							*)
(********************************************************)

  MAXIMUM_TAPE_RETRIES = 16;


(************************************************************************)
(*									*)
(*	The size of the TAPE_BLOCKING_FACTOR determines the size of the *)
(*	tape blocks written to tape for the CUD file, the OPER_LOG	*)
(*	file.								*)
(*									*)
(************************************************************************)

  TAPE_BLOCKING_FACTOR = 1 (* in CUD blocks *);



(************************************************************************)
(*									*)
(*	The following flag should be enabled if the DUMP command	*)
(*	is to be included in the ARCHIVE sub-system commands, otherwise *)
(*	it should be disabled.						*)
(*									*)
(************************************************************************)




(************************************************************************)
(*									*)
(*	If the INCLUDE_DUMP flag is enabled, the size of 		*)
(*	ASCII_DUMP_BLOCKING_FACTOR will determine the number of 80	*)
(*	byte records written per block by the DUMP tape command. 	*)
(*	There are a minimum of 16 of the 80 byte records per		*)
(*	block. The blocking factor selected is the multiple of 16	*)
(*	records per block. 						*)
(*									*)
(************************************************************************)

  ASCII_DUMP_BLOCKING_FACTOR = 12;



(********************************************************)
(*							*)
(* The number of minutes that is allowed to pass	*)
(* with no activity on a user's terminal.  After	*)
(* TERMINAL_TIMEOUT minutes, the circuit is zapped.	*)
(* A zero value signifies no time out.			*)
(*							*)
(* (Timeout does not apply to programmer validators.)	*)
(*							*)
(********************************************************)

  TERMINAL_TIMEOUT = 10 (* in minutes *);




(************************************************************************)
(*									*)
(*	The following flag should be enabled if code is being generated	*)
(*	to convert from a version 2.## Netval disk to a 3.## Netval	*)
(*	disk.  OTHERWISE, IT SHOULD BE DISABLED.			*)
(*									*)
(************************************************************************)



(************************************************************************)
(*									*)
(*	The following is a discussion of disk conversion for Network	*)
(*	validation programs.						*)
(*									*)
(*	The CONVERT command is used to convert a Netval disk from one	*)
(*	"incarnation," or version, to another.  The incarnation number	*)
(*	is recorded on the disk in the configuration file starting with	*)
(*	version 2; Netval will not run if its in-core incarnation	*)
(*	number differs from the one recorded on the disk.		*)
(*									*)
(************************************************************************)


(************************************************************************)
(*									*)
(*	The following explains the various network validation program	*)
(*	versions, disk and file information and conversions required:	*)
(*									*)
(************************************************************************)

(************************************************************************)
(*									*)
(*		Network Validation Programs and disk descriptions:	*)
(*									*)
(*	VAL:								*)
(*		- disk consists of:					*)
(*		  CUD, CUD parameter and MUD change files		*)
(*									*)
(*	Netval Version 1.xx:						*)
(*		- disk consists of:					*)
(*		  CUD, CUD parameter, (node/host list) Class/group	*)
(*		  definition, Class/group table and MUD change file	*)
(*									*)
(*	Netval Version 2.xx:						*)
(*		- disk "incarnation 0"					*)
(*		- disk consists of:					*)
(*		  CUD, CUD parameter, (node/host list) Class/group	*)
(*		  definition, Class/group table, MUD change,		*)
(*		  configuration, and operator log files			*)
(*									*)
(*	Netval Version 3.xx:						*)
(*		- disk "incarnation 1"					*)
(*		- disk consists of:					*)
(*		  CUD, CUD parameter, (node/host list) Class/group	*)
(*		  definition, Class/group table, MUD change,		*)
(*		  configuration, and operator log files			*)
(*		- differences from version 2 disk format:		*)
(*		  - the configuration file:				*)
(*		      additional fields are defined			*)
(*		  - MUD change file:					*)
(*		      additional fields are defined			*)
(*		  - (node/host list) Class/group definition file:	*)
(*		      fields are expanded, so file is larger; if the	*)
(*		      INCLUDE_LIST_DESCRIPTIONS parameter is enabled,	*)
(*		      list descriptions are stored			*)
(*									*)
(************************************************************************)


(************************************************************************)
(*									*)
(*	In order to use version 3.xx of Netval, successive conversions	*)
(*	must be made, i.e., to convert from Netval, version 1.xx, first	*)
(*	NVDM version 1.xx must be used to convert the Netval disk to	*)
(*	incarnation 0, then NVDM version 2.xx must be used to convert	*)
(*	the disk from incarnation 0 to incarnation 1.			*)
(*									*)
(************************************************************************)

(************************************************************************)
(*									*)
(*	To convert from VAL to version 3.xx...				*)
(*									*)
(*	The disk must first be converted to incarnation 0, then to	*)
(*	incarnation 1 as follows:					*)
(*									*)
(*	1. The CONVERT command in NVDM, version 1.xx, is used to	*)
(*	   convert a VAL disk to a Netval disk, incarnation 0; when	*)
(*	   the user is asked:						*)
(*									*)
(*				CONVERT FROM VAL?			*)
(*									*)
(*	   The answer should be "Yes".  In this case, the command does	*)
(*	   the following:						*)
(*		- the entire CUD is scanned, and dates are converted to	*)
(*		  Netval format dates					*)
(*		- the checksum is recomputed for the CUD parameter file	*)
(*		- new configuration, operator log, node_host files	*)
(*		  are written						*)
(*		- the MUD change file is cleared			*)
(*									*)
(*	2. The CONVERT command in NVDM, version 2.xx, is used to	*)
(*	   convert an incarnation 0 disk to an incarnation 1 disk; it	*)
(*	   does the following:						*)
(*		- the entire CUD is scanned, checksums are recomputed	*)
(*		  to use the faster, more efficient engine checksum	*)
(*		- new configuration file is written			*)
(*		- new operator log file is written at its re-computed	*)
(*		  location, with checksums added to each record		*)
(*		- the node_host file is converted to include a header	*)
(*		  list descriptions (if INCLUDE_LIST_DESCRIPTIONS is	*)
(*		  enabled), counts of pertinent information, full word	*)
(*		  values, and checksums					*)
(*									*)
(************************************************************************)

(************************************************************************)
(*									*)
(*	To convert from Netval version 1.xx to version 3.xx...		*)
(*									*)
(*	The disk must first be converted to incarnation 0, then to	*)
(*	incarnation 1 as follows:					*)
(*									*)
(*	1. The CONVERT command in NVDM, version 1.xx, is used to	*)
(*	   convert a VAL disk to a Netval disk, incarnation 0; when	*)
(*	   the user is asked:						*)
(*									*)
(*				CONVERT FROM VAL?			*)
(*									*)
(*	   The answer should be "No".  In this case, the command does	*)
(*	   the following:						*)
(*		- the checksum is recomputed for the CUD parameter file	*)
(*		- new configuration, operator log files are written	*)
(*		- the node_host file is checked and names are converted	*)
(*		- the MUD change file is cleared			*)
(*									*)
(*	2. The CONVERT command in NVDM, version 2.xx, is used to	*)
(*	   convert an incarnation 0 disk to an incarnation 1 disk;	*)
(*	   refer to step 2. in previous section for details.		*)
(*									*)
(************************************************************************)

(************************************************************************)
(*									*)
(*	To convert from Netval version 2.xx to version 3.xx...		*)
(*									*)
(*	1. The CONVERT command in NVDM, version 2.xx, is used to	*)
(*	   convert an incarnation 0 disk to an incarnation 1 disk;	*)
(*	   refer to step 2. in previous section for details.		*)
(*									*)
(************************************************************************)


(************************************************************************)
(*									*)
(*			      NOTES					*)
(*									*)
(*    - after a CONVERT command, the Netval SEND command should be used	*)
(*	to regenerate a new Class/group table				*)
(*									*)
(*    - the clearing of the MUD change file consists of clearing the	*)
(*	"MUD update EOF," "Class and Group table last created," and	*)
(*	"Scheduled consistency period;" in addition, for each		*)
(*	previously defined Supervisor, the "pointer" is set to zero,	*)
(*	the "MUD updated", "Class and Group update" and historical	*)
(*	consistency information are cleared.				*)
(*									*)
(************************************************************************)

(**********************************************************************)
(* **                  PROPRIETARY INFORMATION                     ** *)
(* **                                                              ** *)
(* **  This  source code listing constitutes the proprietary pro-  ** *)
(* **  perty of TYMNET.  The recipient, by receiving this program  ** *)
(* **  listing, agrees that neither this listing nor the informa-  ** *)
(* **  tion disclosed herein nor any part thereof shall be repro-  ** *)
(* **  duced or transferred to other documents or used or dis-     ** *)
(* **  closed to others for manufacturing or for any other purpose ** *)
(* **  except as specifically authorized in writing by TYMNET.     ** *)
(**********************************************************************)
!
(************************************************************************)
(*									*)
(*	GLOBL.NTV							*)
(*									*)
(*	Global NETVAL definitions.					*)
(*									*)
(************************************************************************)
(*									*)
(*				revision record				*)
(*									*)
(*	02Sep86 - neh							*)
(*	      - Change LOG_MESSAGE_TEXT_MAX to be equal to a value	*)
(*		of 180.  This will make the number of characters in	*)
(*		LOG_MESSAGE for the operator log file equal to 180.	*)
(*	      - If CHANGES_TO_OPER_LOG is enabled, add enumeration	*)
(*		type modify_type, the constants first_modify_type and	*)
(*		last_modify_type and the type modify_index equal to	*)
(*		the range of FIRST_MODIFY_TYPE to LAST_MODIFY_TYPE.	*)
(*	      - Move the enumeration type OPER_LOG_MESSAGE_KIND to	*)
(*		global definitions to be used by internal_to_string.	*)
(*	08Jul86 - jrn							*)
(*	      - add oplog_remark_message				*)
(*	      - add SPECIAL flag					*)
(*	13May86 - neh							*)
(*	      - add INCLUDE_DUMP flag					*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	26Feb86 - jrn							*)
(*	      - add DISK_LOAD_TEST and NO_SUP_UPDATES flags		*)
(*	27Jan86 - jrn							*)
(*	      - change NULL_PROMPT to NULL_STRING			*)
(*	22Jan86 - jrn							*)
(*	      - add master_validator_count,				*)
(*		password_only_validator_count and			*)
(*		licensed_validator_count				*)
(*	10Jan84 - neb							*)
(*	      - add MASTER_VALIDATOR, MAXIMUM_IRC, MASK_0F and		*)
(*	      	conditional assembly parameters 			*)
(*		NO_PASSWORD_ONLY_VALIDATORS and NETVAL_IS_A_SLAVE	*)	
(*	15Aug84 - jrn							*)
(*	      - add conditional assembly parameter			*)
(*		old_list_configuration					*)
(*	      - adjust LOG_MESSAGE_TEXT_MAX for checksum		*)
(*	14Jun84	version 2.02	jrn					*)
(*	      - added UUNSassignable values				*)
(*	      - added UUN_PROMPT					*)
(*	      - added licenses, AUDITOR_LICENSE, OPERATOR_LICENSE,	*)
(*		and DISPLAY_CUD_LICENSE					*)
(*	      - added control bit name messages and OKAY_QUERY		*)
(*	13Jun84 version 2.02	pgl					*)
(*	      - added ASCII_FORM_FEED and minimum constants for HOST,	*)
(*		NODE, DISTRICT and GAN					*)
(*	      - added RANGE						*)
(*	29SEP83 - original from (patrol)globl.ntc and elsewhere - jnm	*)
(*									*)
(************************************************************************)
!


	(****************************************************************)
	(*								*)
	(*	SUMMARY OF THE SETTING OF ALL CONDITIONAL PARAMETERS.	*)
	(*								*)
	(****************************************************************)




	(****************************************************************)
	(*								*)
	(*	ALLOW_HOSTS_ON_NO_PASSWORD:   enabled.			*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	CHANGES_TO_OPER_LOG:   enabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	CONVERT_0_TO_1:   disabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	DISK_MAINTENANCE_CODE:   disabled.			*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	INCLUDE_DUMP:   enabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	LOGICAL_VOLUMES:   disabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	INCLUDE_LIST_DESCRIPTIONS:   disabled.			*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	NAME_LEGAL_PASSWORD:   enabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	NETVAL_IS_A_SLAVE:   disabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	NETVAL_IS_BOTH:   disabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	NEW_LIST_CONFIGURATION:   disabled.			*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	NO_PASSWORD_ONLY_VALIDATORS:   disabled.		*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	OLD_LIST_CONFIGURATION:   disabled.			*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	OVERFLOW_CUD_ENTRIES:   disabled.			*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	REUSE_UUNS:   disabled.					*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	TYMSHARE_CUD_FORMAT:   disabled.			*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	UUNSassignable:   disabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	VALIDATE_X25_NAMES:   disabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	DISK_LOAD_TEST:   disabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	NO_SUP_UPDATES:   disabled.				*)
	(*								*)
	(****************************************************************)


	(****************************************************************)
	(*								*)
	(*	SPECIAL:   disabled.					*)
	(*								*)
	(****************************************************************)

!
const
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  MAX_INTEGER = 2147483647;
  MIN_INTEGER = -max_integer - 1;

  SECONDS_PER_HOUR = 3600;
  MINUTES_PER_DAY = 1440;
  SECONDS_PER_DAY = 86400;

  BASE_YEAR = 1974 (* base year for Engine dates *);
!
  BIT0 = -1 - max_integer	(* DECIMAL VALUE OF WORD WITH BIT 0 ON *);
  BIT1 = 1073741824	(* DECIMAL VALUE OF WORD WITH BIT 1 ON *);
  BIT2 = 536870912	(* DECIMAL VALUE OF WORD WITH BIT 2 ON *);
  BIT3 = 268435456	(* DECIMAL VALUE OF WORD WITH BIT 3 ON *);
  BIT4 = 134217728	(* DECIMAL VALUE OF WORD WITH BIT 4 ON *);
  BIT5 = 67108864	(* DECIMAL VALUE OF WORD WITH BIT 5 ON *);
  BIT6 = 33554432	(* DECIMAL VALUE OF WORD WITH BIT 6 ON *);
  BIT7 = 16777216	(* DECIMAL VALUE OF WORD WITH BIT 7 ON *);
  BIT8 = 8388608	(* DECIMAL VALUE OF WORD WITH BIT 8 ON *);
  BIT9 = 4194304	(* DECIMAL VALUE OF WORD WITH BIT 9 ON *);
  BIT10 = 2097152	(* DECIMAL VALUE OF WORD WITH BIT 10 ON *);
  BIT11 = 1048576	(* DECIMAL VALUE OF WORD WITH BIT 11 ON *);
  BIT12 = 524288	(* DECIMAL VALUE OF WORD WITH BIT 12 ON *);
  BIT13 = 262144	(* DECIMAL VALUE OF WORD WITH BIT 13 ON *);
  BIT14 = 131072	(* DECIMAL VALUE OF WORD WITH BIT 14 ON *);
  BIT15 = 65536		(* DECIMAL VALUE OF WORD WITH BIT 15 ON *);
  BIT16 = 32768	(* DECIMAL VALUE OF WORD WITH BIT 16 ON *);
  BIT17 = 16384	(* DECIMAL VALUE OF WORD WITH BIT 17 ON *);
  BIT18 = 8192	(* DECIMAL VALUE OF WORD WITH BIT 18 ON *);
  BIT19 = 4096	(* DECIMAL VALUE OF WORD WITH BIT 19 ON *);
  BIT20 = 2048	(* DECIMAL VALUE OF WORD WITH BIT 20 ON *);
  BIT21 = 1024 	(* DECIMAL VALUE OF WORD WITH BIT 21 ON *);
  BIT22 = 512	(* DECIMAL VALUE OF WORD WITH BIT 22 ON *);
  BIT23 = 256	(* DECIMAL VALUE OF WORD WITH BIT 23 ON *);
  BIT24 = 128	(* DECIMAL VALUE OF WORD WITH BIT 24 ON *);
  BIT25 = 64	(* DECIMAL VALUE OF WORD WITH BIT 25 ON *);
  BIT26 = 32	(* DECIMAL VALUE OF WORD WITH BIT 26 ON *);
  BIT27 = 16	(* DECIMAL VALUE OF WORD WITH BIT 27 ON *);
  BIT28 = 8	(* DECIMAL VALUE OF WORD WITH BIT 28 ON *);
  BIT29 = 4	(* DECIMAL VALUE OF WORD WITH BIT 29 ON *);
  BIT30 = 2	(* DECIMAL VALUE OF WORD WITH BIT 29 ON *);
  BIT31 = 1	(* DECIMAL VALUE OF WORD WITH BIT 31 ON *);
!
  MASK_0F = 15				(* right-most 4 bits only *);
  MASK_3F = 63				(* right-most 6 bits only *);
  MASK_7F = 127				(* right-most 7 bits only *);
  MASK_0F0 = 240;
  MASK_0FF = 255			(* right most 8 bits only *);
  MASK_3FF = 1023			(* right-most 10 bits only *);
  MASK_0FFF = 4095			(* right-most 12 bits only *);
  MASK_0FF_FFFF = 16777215		(* right-most 24 bits only *);
  MASK_0FF00_0000 = -1 - mask_0ff_ffff	(* left-most 8 bits only *);
  MASK_0FFFF_F000 = -1 - mask_0fff	(* left-most 20 bits only *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ZERO = '(:0:)';
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(***********************************************************************)
(*                                                                     *)
(*       ascii characters used by system			       *)
(*                                                                     *)
(***********************************************************************)

const
  ASCII_FORM_FEED = '(:12:)';
  ASCII_LINE_FEED = '(:10:)';
  ASCII_CARRIAGE_RETURN = '(:13:)';

  ASCII_ZERO = '0';
  ASCII_NINE = '9';

  ASCII_A = 'A';
  ASCII_F = 'F';
  ASCII_Z = 'Z';

  ASCII_AMPERSAND = '&';
  ASCII_COLON = ':';
  ASCII_COMMA = ',';
  ASCII_DOT = '.';
  ASCII_LEFT_PARENS = '(';
  ASCII_MINUS = '-';
  ASCII_PLUS = '+';
  ASCII_RIGHT_PARENS = ')';
  ASCII_SEMI_COLON = ';';
  ASCII_SINGLE_QUOTE = '(:39:)';
  ASCII_SLASH = '/';
  ASCII_SPACE = ' ';

  END_MESSAGE_CHARACTER = '\'		(* end of message character *);
  ESCAPE = '(:27:)';

  LOWER_CASE_A = 'a';
  LOWER_CASE_S = 's';
  LOWER_CASE_Z = 'z';
!
(*	Global ASCII strings	*)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ACCOUNT_SUPERVISOR_MESSAGE = 'account supervisor\ ';
  AUDITOR_MESSAGE = 'auditor\';
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  BY_MESSAGE = ' by \ ';
  CHECKSUM_ERROR = 'checksum error\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  CLASS_MESSAGE = 'class \ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  COMMA_SPACE = ', \ ';
  COMPLETE_MESSAGE = 'complete\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  CONTINUE_MESSAGE = 'continue\ ';
  CUD_FILE_MESSAGE = 'CUD\';
  CUD_FILE_BUSY = 'CUD file busy\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ENTRY_BUSY = 'entry is being modified\';
  ENTRY_COMPLETED = 'entry completed\';
  FORMAT_ERROR = 'format error\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  GAN_PROMPT = 'GAN: \';
  GROUP_MESSAGE = 'group \ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  GMT_MESSAGE = ' GMT\ ';
  HANDSHAKE_ERROR = 'handshake failed\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  HOST_MESSAGE = 'host\ ';
  IGNORE_HOST_MESSAGE = 'ignore host\';
  LICENSED_MESSAGE = 'licensed\ ';
  LIST_MESSAGE = 'list\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  MANUAL_MESSAGE = 'manual \';
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
  MUD_FILE_MESSAGE = 'MUD\';
  NETVAL_WELCOME_MESSAGE = 'NETVAL - Version \';
  NETWORK_ADMINISTRATOR_MESSAGE = 'network administrator\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  NO_MESSAGE = 'no\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  NODE_MESSAGE = 'node\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  NULL_STRING = '\ ';
  OKAY_QUERY = 'okay\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  OPERATOR_MESSAGE = 'operator\ ';
  PASSWORD_ONLY_MESSAGE = 'password only\';
  PROGRAMMER_MESSAGE = 'programmer\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PASSWORD_ERROR = 'password error\ ';
  READING_MESSAGE = 'reading\';
SHUT_OVERRIDE_MESSAGE = 'shut override\';
  SUPERVISOR_MESSAGE = 'Supervisor \';
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  TRANSPARENT_LOGIN_MESSAGE = 'transparent login\';
  USERNAME_QUERY = 'username: \ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  UUN_PROMPT = 'UUN: \';
  UNKNOWN_MESSAGE = 'unknown      \';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  WRITE_PROTECTED_MESSAGE = 'unit is write protected\';
  WRITING_MESSAGE = 'writing\';
  YES_MESSAGE = 'yes\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	A maximum set of integers from 0-255. Other sets are defined	*)
(*	in terms of this basic set.					*)

const
  BASIC_SET_MAX = 256 (* maximum cardinality *);
  BASIC_SET_LIMIT = basic_set_max - 1;

type
  BASIC_SET_INDEX = 0..basic_set_limit;
  BASIC_SET_SIZE = 0..basic_set_max;

type
  BASIC_SET = set of basic_set_index;

const
  BASIC_SET_SIZE_IN_BYTES = basic_set_max div 8;



(**** A halfword viewed as an array of characters. ****)
const
  MAXIMUM_CHARS_IN_HALFWORD = 2;
  HALFWORD_CHARS_LIMIT = maximum_chars_in_halfword - 1;

type
  HALFWORD_INDEX = 0..halfword_chars_limit;

  HALFWORD = array [halfword_index] of char;



(**** A word viewed as an array of charaters. ****)
const
  MAXIMUM_BYTES_IN_WORD = 4;
  WORD_IN_BYTES_LIMIT = maximum_bytes_in_word - 1;

type
  WORD_IN_BYTES_INDEX = 0..word_in_bytes_limit;

  WORD_IN_BYTES = array [word_in_bytes_index] of char;



(**** A word viewed as an array of halfwords. ****)
const
  MAXIMUM_HALFWORDS_IN_WORD = 2;
  WORD_IN_HALFWORDS_LIMIT = maximum_halfwords_in_word - 1;

type
  WORD_IN_HALFWORDS_INDEX = 0..word_in_halfwords_limit;

  WORD_IN_HALFWORDS = array [word_in_halfwords_index] of halfword;

const
  ZERO_HALFWORD = '(:0:)(:0:)';
!
(*    The unit of disk i/o is the page:    *)

const
  PAGE_SIZE = 256 (* bytes *);
  PAGE_LIMIT = page_size - 1;


type
  PAGE_LENGTH = 0..page_size;
  PAGE_INDEX = 0..page_limit;

  PAGE = array [page_index] of char;


const
  PG_DATA_LIMIT = page_size - maximum_bytes_in_word - 1;

type
  PG_DATA_INDEX = 0..pg_data_limit;

  PAGE_RECORD = record
    data	: array [pg_data_index] of char;
    checksum	: integer
  end (* page_record *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* A range of integers; can be used as a single value if first=last *)
type
  RANGE = record
    first,
    last : integer
  end (* range *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(* Define various network values *)

const
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  uun_radix = 8;
  minimum_uun = 1;
  maximum_uun = BIT7 - 1 (* 24 bits only *);


  MINIMUM_GAN = 1;
  MAXIMUM_GAN = BIT7 - 1 (* 24 bits only *);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  MINIMUM_DISTRICT = 1 (* max in config file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


  MINIMUM_NODE = 1 (* maximum defined in configuration file *);
  MINIMUM_HOST = 1 (* maximum defined in configuration file *);
  MAXIMUM_IRC = 15;
!
(*	Define Validator Values and Licenses.*)

type	(* define all possible types of validators *)
  VALIDATOR_TYPE = (
	password_only_validator		(* can change password only *),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	account_supervisor_validator	(* can affect users in own GAN *),
	network_administrator_validator	(* can affect all users	*),
	programmer_validator		(* can do ANYTHING *));


  COMMAND_LICENSE = (
	no_license		(* anyone can execute command *),
	auditor_license		(* can display ANYTHING *),
	display_cud_license	(* can access CUD display commands *),
	account_supervisor_license	(* can modify other users in GAN *),
	network_administrator_license	(* can do any validation *),
	operator_license		(* can do operational things *),
	programmer_license		(* can do ANYTHING *));


const
  FIRST_VALIDATOR_LICENSE = auditor_license;
  LAST_VALIDATOR_LICENSE =  programmer_license;


type
  VALIDATOR_LICENSE = FIRST_VALIDATOR_LICENSE..LAST_VALIDATOR_LICENSE;

  VALIDATOR_LICENSE_SET = set of validator_license;
!
(****************************************************************)
(*								*)
(* Define the number and indices for each type of validator.	*)
(* The order of the validator definitions are:			*)
(*		password only validators, if any		*)
(*		master validators, if any			*)
(*		interactive licensed validators			*)
(*								*)
(****************************************************************)

const	 (* Validators who may change their own password only: *)
  FIRST_PASSWORD_ONLY_VALIDATOR = 0;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  MAXIMUM_PASSWORD_ONLY_VALIDATORS = NUMBER_OF_PASSWORD_ONLY_VALIDATORS;
  PASSWORD_ONLY_VALIDATOR_LIMIT = maximum_password_only_validators - 1;


type
  PASSWORD_ONLY_VALIDATOR_COUNT = 0..NUMBER_OF_PASSWORD_ONLY_VALIDATORS;
  PASSWORD_ONLY_VALIDATOR_INDEX =
	first_password_only_validator..password_only_validator_limit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	Some general validator definitions.	*)

const
  FIRST_VALIDATOR = first_password_only_validator;


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  MAXIMUM_MASTER_VALIDATORS = 0;
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)

  MAXIMUM_VALIDATOR =
    maximum_password_only_validators + maximum_master_validators
      + maximum_licensed_validators;

  VALIDATOR_LIMIT = maximum_validator - 1;


(* define indices for all types of validator *)

type
  VALIDATOR_INDEX = first_validator..validator_limit;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
const
  FIRST_LICENSED_VALIDATOR =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    maximum_password_only_validators;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  LICENSED_VALIDATOR_LIMIT = validator_limit;

type
  LICENSED_VALIDATOR_COUNT = 0..MAXIMUM_LICENSED_VALIDATORS;
  LICENSED_VALIDATOR_INDEX =
    first_licensed_validator..licensed_validator_limit;


const
  MAXIMUM_NON_PASSWORD_ONLY_VALIDATORS =
    maximum_validator - maximum_password_only_validators;

  FIRST_NON_PASSWORD_ONLY_VALIDATOR = maximum_password_only_validators;
  LAST_NON_PASSWORD_ONLY_VALIDATOR = validator_limit;

type
  NON_PASSWORD_ONLY_VALIDATOR_INDEX =
    first_non_password_only_validator..last_non_password_only_validator;
!
(* the following are used to perform boolean operations    *)
(* on integer values...the integers to be operated on      *)
(* are stored in an integer_array, a procedure is called   *)
(* that treats the array as a a character_set and performs *)
(* the boolean operation on the set, then the integers     *)
(* are extracted from the resulting integer_array.         *)

type
  INTEGER_ARRAY = array [0..7] of integer;

  CHARACTER_SET = set of char;
!
(* This is a string which is ended with an end_message_character	*)
(* character...used to pass string constants in procedure calls.	*)

const
  QUOTED_TEXT_MAX = 80 (* characters *);
  QUOTED_TEXT_LIMIT = quoted_text_max - 1;

type
  QUOTED_TEXT_INDEX = 0..quoted_text_limit;

  QUOTED_TEXT = array [quoted_text_index] of char;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	Format buffer for internal_to_string output.	*)

const
  FORMAT_BUFFER_TEXT_MAX = 160 (* characters *);
  FORMAT_BUFFER_TEXT_LIMIT = format_buffer_text_max - 1;

type
  FORMAT_BUFFER_TEXT_INDEX = 0..format_buffer_text_limit;
  FORMAT_BUFFER_TEXT_SIZE = 0..format_buffer_text_max;

  FORMAT_BUFFER_TEXT = array [format_buffer_text_index] of char;

  FORMAT_BUFFER = record
    size: format_buffer_text_size;
    text: format_buffer_text
  end (* format_buffer *);
!
(*	Command line input.		*)
(*	This is the standard command input line, processed by the	*)
(*	the command scanner.						*)

const
  COMMAND_LINE_TEXT_MAX = 80 (* characters *);
  COMMAND_LINE_TEXT_LIMIT = command_line_text_max - 1;

type
  COMMAND_LINE_TEXT_INDEX = 0..command_line_text_limit;
  COMMAND_LINE_TEXT_SIZE = 0..command_line_text_max;

  COMMAND_LINE_TEXT = array [command_line_text_index] of char;

  COMMAND_LINE = record
    size: command_line_text_size;
    text: command_line_text
  end (* command_line *);
!
(* Definition of prompts for various command classes *)

const
  COMMAND_PROMPT_TEXT_MAX = 8 (* characters *);
  COMMAND_PROMPT_TEXT_LIMIT = command_prompt_text_max - 1;

type
  COMMAND_PROMPT_TEXT_INDEX = 0..command_prompt_text_limit;
  COMMAND_PROMPT_TEXT_SIZE = 0..command_prompt_text_max;

  COMMAND_PROMPT = array [command_prompt_text_index] of char;
!
(*	Define an all purpose list to perform I/O	*)

const
(* max is greatest number of "number," strings to fit on an input line *)
  MAXIMUM_GENERAL_NUMBER_LIST_SIZE = 20 (* number of command freewords *);
  GENERAL_NUMBER_LIST_SIZE_LIMIT = maximum_general_number_list_size - 1;

type
  GENERAL_NUMBER_LIST_SIZE = 0..maximum_general_number_list_size;
  GENERAL_NUMBER_LIST_INDEX = 0..general_number_list_size_limit;

  GENERAL_NUMBER_LIST = record
    size : general_number_list_size;
    list : array [general_number_list_index] of integer
  end (* general_number_list *);
!
(*	This is the text for a network username,*)
(*	i.e., a username in the MUD.		*)

const
  USERNAME_TEXT_MAX = 20;
  USERNAME_TEXT_LIMIT = username_text_max - 1;



type
  USERNAME_TEXT_INDEX = 0..username_text_limit;
  USERNAME_TEXT_SIZE = 0..username_text_max;

  USERNAME_TEXT = array [username_text_index] of char;

  USERNAME_STRING = record
    size : username_text_size;
    text : username_text
  end (* username_string *);


(*	This is the text for a network password string.			*)

const
  PASSWORD_TEXT_MAX = 30;
  PASSWORD_TEXT_LIMIT = password_text_max - 1;


type
  PASSWORD_TEXT_INDEX = 0..password_text_limit;
  PASSWORD_TEXT_SIZE = 0..password_text_max;

  PASSWORD_TEXT = array [password_text_index] of char;

  PASSWORD_STRING = record
    size : password_text_size;
    text : password_text
  end (* password_string *);


(*	This is the text for a network login string. It will contain	*)
(*	the username, password, host number, control characters etc.	*)

const
  LOGIN_TEXT_MAX = 58;
  LOGIN_TEXT_LIMIT = login_text_max - 1;


type
  LOGIN_TEXT_INDEX = 0..login_text_limit;
  LOGIN_TEXT_SIZE = 0..login_text_max;

  LOGIN_TEXT = array [login_text_index] of char;

  LOGIN_STRING = record
    size : login_text_size;
    text : login_text
  end (* login_string *);



(* the following definitions are here because thy are used in the	*)
(* internal_to_string class:						*)

(*	This is the text that is stored in a log message.		*)
(*	The size is such that the text and other log message data will	*)
(*	fit on a disk page.						*)

const
  LOG_MESSAGE_TEXT_MAX = 180;
  LOG_MESSAGE_TEXT_LIMIT = log_message_text_max - 1;

type
  LOG_MESSAGE_TEXT_INDEX = 0..log_message_text_limit;
  LOG_MESSAGE_TEXT_SIZE = 0..log_message_text_max;

  LOG_MESSAGE_TEXT = array [log_message_text_index] of char;

 LOG_MESSAGE = record
    size : log_message_text_size;
    text : log_message_text
  end (* log_message *);

(****************************************************************)
(*								*)
(*	Message kinds are defined so that users may select out	*)
(*	only messages that they are interested in seeing.	*)
(*								*)
(*	Note: do not change the order of these messages, i.e.	*)
(*	append new ones to end of list as they are recorded	*)
(*	on disk.						*)
(*								*)
(****************************************************************)

type
  OPER_LOG_MESSAGE_KIND = (
    DEBUGGING_OPLOG_MSG		(* miscellaneous *),
    VALIDATOR_OPLOG_MSG		(* general validator message *),
    FILE_OPLOG_MSG		(* file messages *),
    CUD_OPLOG_MSG		(* CUD error *),
    MUDUPD_OPLOG_MSG		(* MUD_UPDATE_FILE *),
    UN2_OPLOG_MSG		(* UN2 message *),
    CONSISTENCY_OPLOG_MSG	(* consistency message *),
    SYSMSG1_OPLOG_MSG		(* SYSMSG1 message *),
    ARCHIVE_OPLOG_MSG		(* ARCHIVE message *),
    UNUSED1_OPLOG_MSG		(* obsolete: TYMCOM message *),
    CUD_PARAM_OPLOG_MSG		(* CUD PARAMETER file error *),
    LV_OPLOG_MSG		(* logical volume message *),
    MASTER_OPLOG_MSG		(* MASTER valiator message *),
    OPERLOG_REPORT_MSG		(* operator report messgaes *),
    MERGE_UUN_OPLOG_MSG	(* Tymnet only; REUSE_UUNS merger report *),
    MODIFY_CUD_OPLOG_MSG (* changes to cud report *));

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
const
  oplog_remark_length = 30 (* characters *);
  oplog_remark_limit = oplog_remark_length - 1;

type
  oplog_remark_index = 0..oplog_remark_limit;
  oplog_remark_size = 0..oplog_remark_length;


  oplog_remark_message = record
    size	: oplog_remark_size;
    chars	: array [oplog_remark_index] of char
  end (* oplog_remark_message *);

(* Modify_type values are used in operator log messages to identify *)
(* the type of cud change being reported. *)

  modify_type = (ACCESS, CONTROL, DISTRICT, GAN, CHANGENAME,
  PASSWORD, UUN, OVERFLOW, GFD, IRC, DELETE, NEW);

const
  FIRST_MODIFY_TYPE = access;
  LAST_MODIFY_TYPE = new;

type
  modify_index = first_modify_type..last_modify_type;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

!
(************************************************************************)
(*									*)
(*	DEVMAX.NTV							*)
(*									*)
(*			 Device Maximums				*)
(*									*)
(*	Set the maximum values for device units.			*)
(*									*)
(************************************************************************)
(*									*)
(*			   Revision Record				*)
(*									*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	 21Jul84 Version 3.00 - jnm/pgl					*)
(*	       - added one to AUX_CIRCUIT_UNIT_MAX for 			*)
(*		 TYMCOM_IX_circuit_maintainer process			*)
(*	 29SEP83	Original -- jnm (from (PATROL)devmax.bas)	*)
(*									*)
(************************************************************************)


const
  disk_unit_max = 2 (* number of units for device disk *);

  tape_unit_max = 4 (* maximum possible number of units for device tape *);

  printer_unit_max = 1 (* max. possible number of units for device printer *);

  terminal_unit_max =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    MAXIMUM_VALIDATOR (* one terminal for each user *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(* one circuit for each Supervisor MUD update,	*)
(* plus one for the Class/group Table update	*)

  aux_circuit_unit_max = MAXIMUM_EXPECTED_SUPERVISORS + 1;


  lv_max = 1 (* possible logical volumes *);
!
(************************************************************************)
(*									*)
(*	DEVDEF.NTV							*)
(*									*)
(*			 Device I/O Declarations			*)
(*									*)
(*	General (nucleus) device I/O definitions.			*)
(*									*)
(************************************************************************)
(*									*)
(*			   Revision Record				*)
(*									*)
(*	07Mar86 - jrn							*)
(*	      - add get_host_state to system_operation definition	*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	01Nov85 - JRN							*)
(*	      - add Supervisor err log definitions (ERRLOG_MESSAGE,	*)
(*		etc.)							*)
(*	23May85 - jrn							*)
(*	      - add get_940_checksum to system device			*)
(*	20Dec84 - jrn							*)
(*	      - add lvol_io_param					*)
(*	 21Jul84 Version 3.00 - jrn/pgl					*)
(*	       - added tymcom_circuit def				*)
(*									*)
(*	 29SEP82	Original -- jnm (from (PATROL)devio.def)	*)
(*									*)
(************************************************************************)


type	(*   Device definition *)
  iodevice = (disk, tape, printer, system, crash, terminal, aux_circuit,
    lvol);


type
  ioresult = (complete, intervention, transmission, failure, end_file,
    end_medium, start_medium, program_error, break_key, orange_ball,
    device_busy, time_out);

type
  ioresult_set = set of ioresult;
!
(************************************************************************)
(*			disk devices					*)
(************************************************************************)


const
  disk_unit_limit = disk_unit_max - 1;



type
  disk_unit_index = 0..disk_unit_limit;


type	(* disk operation codes: *)
  disk_operation = (disk_read, disk_write, disk_attach, disk_detach,
    disk_info, disk_load_program);


type	(* disk i/o parameter list *)
  disk_param = record
    operation : disk_operation;
    status    : ioresult;
    status2,
    start_addr,
    byte_count: integer
  end (* disk_param *);


type
  disk_tape_information = record
    logical_unit_number,
    device_status,
    protection_mask,
    default_block_size,
    start_cylinder,
    number_of_cylinders,
    sectors_per_track,
    tracks_per_cylinder,
    device_address,
    global_unit_number,
    ascii_name,
    device_type,
    number_of_sectors :	 integer
  end (* disk_tape_information *);
!
(************************************************************************)
(*			tape devices					*)
(************************************************************************)


type
  tape_operation = (tape_read, tape_write, tape_attach, tape_detach,
    tape_info, tape_load_program, tape_action);


const
  tape_unit_limit = tape_unit_max - 1;


type
  tape_unit_index = 0..tape_unit_limit;


type
  tape_param = record
    operation : tape_operation;
    status    : ioresult;
    status2,
    arg,
    count      : integer
  end (* tape param *);


const
  tape_back_space = 0;
  tape_forward_file = 1;
  tape_back_file = 2;
  tape_write_eof = 3;
  tape_rewind = 4;
  tape_unload = 5;
  tape_gap = 6;
  tape_set_low_density = 7;
!
(************************************************************************)
(*			printer devices					*)
(************************************************************************)


const
  printer_unit_limit = printer_unit_max - 1;


type
  printer_unit_index = 0..printer_unit_limit;

type
  printer_operation = (printer_raw, printer_text, printer_new_line,
    printer_form_feed, printer_repeat_character, printer_info);


const
  max_lpt_repeat_count = 63;


type
  printer_param = record
    operation : printer_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* printer_param *);


  line_printer_request = record
    prt_op       : printer_operation;
    outline      : format_buffer;
    repeat_char  : char;
    repeat_count : integer
  end (* line_printer_request *);
!
(************************************************************************)
(*			system device					*)
(************************************************************************)


type
  system_operation = (set_system_up, set_system_down, set_system_shut,
    set_system_gone, system_info, system_core_free, read_constant,
    system_checksum, program_status_info, get_940_checksum, get_host_state);


type
  system_param = record
    operation : system_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* system_param *);


type
  system_information = record
    number_of_terminals,		(* NTERM *)
    number_of_aux_circuits,		(* NAUX *)
    host_number,			(* decimal *)
    node_number,			(* octal *)
    slot_number,			(* hexidecimal *)
    kernel_host_number,			(* decimal *)
    isis_version,			(* 100*v+r in decimal *)
    nucleus_version	   : integer (* 256*v+r in octal *)
  end (* system_information *);



(* Netval definition of host state, used in call *)
(* to system_handler procedure SET_HOST_STATE *)

type
  HOST_STATE = (UP_STATE, DOWN_STATE, SHUT_STATE, GONE_STATE);
!
(************************************************************************)
(*			crash device					*)
(************************************************************************)


type
  crash_operation =
    (crash_wait, crash_signal, crash_restart, crash_halt, crash_kill);

type
  crash_param = record
    operation : crash_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* crash_param *);

type
  process_crash_data =
    record
      error_code: integer;
      process_number: integer;
      line_number: integer
    end (* process_crash_data *);
!
(************************************************************************)
(*			 logical volume support 			*)
(************************************************************************)


type
  LVOL_OPERATION = (lvol_init, lvol_soft_init, lvol_info, lvol_setop,
    lvol_copy, lvol_read, lvol_write, lvol_setop_init, lvol_soft_setop_init);


const
  (* LVOL initialization (both LVOL_INIT and LVOL_SOFT_INIT) brings	*)
  (* both incarnations up as read/write; this does not give Netval the	*)
  (* chance to determine which is the proper disk to use as the master.	*)
  (* Netval uses the LVOL_SOFT_SETOP_INIT operation so that it can	*)
  (* bring the master disk up as read/write, and the other disk up as	*)
  (* write only. The following flags are used to specify, when the	*)
  (* LVOL_SOFT_SETOP_INIT is called, if other logical volume operations	*)
  (* may take place (UNLOCK_FOR_INIT) or not (LOCK_FOR_INIT).		*)

  UNLOCK_FOR_INIT = 0;
  LOCK_FOR_INIT = 1;


type
(* used for LVOL_SOFT_SETOP_INIT,  LVOL_SETOP, LVOL_INFO operations *)
  LVOL_PARAM = record
    operation : lvol_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* lvol_param *);


  LVOL_IO_PARAM = record (* used for read and write operations only *)
    operation : lvol_read..lvol_write;
    status    : ioresult;
    status2,
    start_addr,
    byte_count: integer
  end (* lvol_io_param *);


  LVOL_COPY_PARAM = record (* used for LVOL_COPY operation *)
    operation : lvol_copy..lvol_copy;
    status    : ioresult;
    status2,
    start_addr,	(* returns the num bytes transferred *)
    byte_count,
    from_disk,
    to_disk     : integer
  end (* lvol_copy_param *);


(* If logical_volumes is enabled, Netval uses one logical volume. It is *)
(* made up of two incarnations, one on each physical drive; each drive	*)
(* has 2 ISIS logical disk units, a CUD unit and a file_system unit.	*)

const
  LVOL_UNIT = lv_max - 1;


type
  LVOL_UNIT_INDEX = lvol_unit..lvol_unit;


const
  INCARNATION_MAX = 2 (* number of copies within LVOL *);
  INCARNATION_LIMIT = incarnation_max - 1;


type
  incarnation_index = 0..incarnation_limit;


const
  lvol_disk_unit = 4 (* 2 CUDS, 2 file system *);
  lvol_disk_unit_limit = lvol_disk_unit - 1;


type (* see also fildef.ntv, CUD_DISK_UNIT..FILE_SYSTEM_DISK2 *)
  lvol_disk_unit_index = 0..lvol_disk_unit_limit;


  soft_init_rec = record (* used in soft initialization operation *)
    pv_unit	: lvol_disk_unit_index;
    lv_unit	: lvol_unit_index;
    inc_number  : incarnation_index
  end (* soft_init_rec *);


  LVOL_SOFT_INIT_BUFFER = array [lvol_disk_unit_index] of soft_init_rec;


  LVOL_INFO_REC = record (* used for lvol_info operation *)
    read_count,
    write_count,
    last_status,
    error_count,
    logical_volume_number,
    incarnation_number,
    last_error,
    disk_states : integer
  end (* lvol_info_rec *);


  LVOL_INFO_BUFFER = array [lvol_disk_unit_index] of lvol_info_rec;


const
  lvol_info_rec_size = 32;
  lvol_info_buffer_size = lvol_disk_unit * LVOL_INFO_REC_SIZE;



(* If the nucleus is unable to complete an I/O request to a unit 	*)
(* after the standard (256) trys, it sets the unit to "down". The	*)
(* nucleus will not access that unit for lvol_read or lvol_write	*)
(* operations until the unit is restored to "read_write".  This is	*)
(* accomplished in netval by a COPY command.				*)
const
  (* define logical volume I/O states that are returned by the nucleus	*)
  INCARNATION_DOWN = 0		(* down *);
  INCARNATION_READ_WRITE = 1	(* up and read/write *);
  INCARNATION_READ_ONLY = 2	(* up and read only *);
  INCARNATION_WRITE_ONLY = 3	(* up and write only *);
  INCARNATION_OFFLINE = 4	(* up and unavailable *);
  INCARNATION_UNKNOWN = 5	(* when Netval comes up, state is unknown *);


type
  LVOL_STATES = incarnation_down..incarnation_unknown;


const
  (* flags which are sent to the nucleus to set an lvol state *)
  SET_LVOL_CLEAR = 0	(* clears write only, read only or unavailable *);
  SET_LVOL_READ_ONLY = 1;
  SET_LVOL_WRITE_ONLY = 2;
  SET_LVOL_UNAVAILABLE = 3;


type
  LVOL_SET_STATE_FLAGS = set_lvol_clear..set_lvol_unavailable;
!
(************************************************************************)
(*		terminal and aux_circuit devices			*)
(************************************************************************)


type
  circuit_device = terminal..aux_circuit;


const
  terminal_unit_limit = terminal_unit_max - 1;


type
  terminal_unit_index = 0..terminal_unit_limit;

const
  echo_off = 0;
  echo_on  = 1;
  xp_on    = 2;
  xp_off   = 3;
  sys_cons = 4;
  char_del = 5;
  word_del = 6;
  line_del = 7;
  set_crt = 11;

const
   sys_char_del = 0;
   sys_word_del = 1;
   sys_line_del = 2;



const
  sysmsg_circuit = 0;

  aux_circuit_unit_limit = aux_circuit_unit_max - 1;


type
  aux_circuit_unit_index = 0..aux_circuit_unit_limit;


type
  circuit_operation = (circuit_receive_character, circuit_receive_line,
    circuit_send, circuit_disconnect, circuit_clear_break, circuit_set_system,
    circuit_set_unit, circuit_yellow_ball, circuit_detect,
    circuit_aux_request, circuit_info, circuit_send_b1, circuit_get_needle,
    circuit_zap, circuit_sup_log_message, circuit_set_alternate_break,
    circuit_set_bell, circuit_normal_request,
    circuit_send_siix, circuit_send_tiix);



type
  circuit_param = record
    operation : circuit_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* circuit_param *);
!
(*   Needle Record   *)

const
  needle_name_max   = 24 (* characters *);
  needle_name_limit = needle_name_max - 1;


type
  needle_name_index = 0..needle_name_limit;


type
 needle_name_length = 0..needle_name_max;


type
  needle_name = array [needle_name_index] of char;


type
  needle_record = record
    invoice		: integer;
    isis_port		: integer;
    destination_host	: integer;
    origin_node		: integer;
    origin_host		: integer;
    origin_port		: integer;
    number_of_characters: needle_name_length;
    terminal_id		: char;
    login_name		: needle_name
  end (* needle_record *);
!
(* Supervisor ERR log definition. *)

const
  NETVAL_PRODUCT_ID = '(:68:)' (* hex 44 *);
  ERRLOG_DRIVE_DOWN_MESSAGE_TYPE = '(:16:)' (* hex 10 *);
  ERRLOG_SET_SUPERVISOR_MESSAGE_TYPE = '(:17:)' (* hex 11 *);

type
  errlog_message = record (* fields are ISIS message labels *)
    data2	: halfword;
    kind	: char (* type of message *);
    data1	: char;
    pid		: char (* NETVAL_PRODUCT_ID *)
  end (* errlog_message *);
!
(************************************************************************)
(*									*)
(*	LVDEF.NTV							*)
(*									*)
(*			 Logical Volume Definitions			*)
(*									*)
(************************************************************************)


(* Messages are sent to operator log and Supervisors when an	*)
(* incarnation goes down or offline and at LVOL_REPORT_INTERVAL	*)
(* second intervals until it changes to up.			*)
const
  LVOL_REPORT_INTERVAL = 15 * 60 (* fifteen minutes *);


  LVOL_TIME_STAMP_INTERVAL = 60 (* write time stamps every 60 seconds *);


type
  drive_disk_state = record
    legal_disk 	: boolean (* TRUE if config file ok on disk *);
    time_stamp	: integer (* last_pvol_time_stamp from disk *)
  end (* drive_disk_state *);


  lvol_disk_state = array [incarnation_index] of drive_disk_state;
!
(************************************************************************)
(*									*)
(*	CGDEF.NTV							*)
(*									*)
(*      This file contains various NETVAL defintions, including:	*)
(*	Class/group, NODELIST, HOSTLIST definitions.			*)
(*									*)
(************************************************************************)
(*									*)
(*	15Aug84 - jrn							*)
(*	      - add conditional assembly parameter			*)
(*		OLD_LIST_CONFIGURATION					*)
(*	24Jul84 - jrn							*)
(*	      - redefine classes, groups, node and host lists as to	*)
(*		be more user configurable; add checksums to disk files	*)
(*	      - add list descriptions (if INCLUDE_LIST_DESCRIPTIONS is	*)
(*		enabled							*)
(*	06Jul84 Version 2.02 - jrn					*)
(*	      - add SYSMSG1_UNEXPECTED_INPUT to sysmsg1_status		*)
(*	14Mar84	Version 2.01 modified by jrn				*)
(*	      - modify size of host list to match actual size		*)
(*		in version 1.14						*)
(*									*)
(************************************************************************)


const
  FIRST_CLASS = 1;
  FIRST_GROUP = 1;



type
  CLASS_INDEX = first_class..maximum_class;
  GROUP_INDEX = first_group..maximum_group;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

   (* define total size of Class/group Table *)
const
  TABLE_LENGTH = maximum_class_table_size + maximum_group_table_size;

  TABLE_LIMIT =  table_length - 1;



type
  TABLE_INDEX = 0..table_limit;



(* Used to talk to SYSMSG1 - should be the	*)
(* same size as table_contents, below:	*)

  TABLE_IN_BYTES = array [table_index] of char;

   

(* Used to read (and write) the Table from	*)
(* (to) the disk; the file should always be	*)
(* an even number of pages on the disk...	*)

const
  PAGES_IN_TABLE = table_length div page_size;

  TABLE_PAGE_LIMIT = pages_in_table - 1;



type
  TABLE_PAGE_INDEX = 0..table_page_limit;

  TABLE_IN_PAGES = array [table_page_index] of page;



   (* define class and group parameters *)


const
    (* size of class list in bytes: 520, 1256 or 2176 *)

  MAXIMUM_TABLE_CLASS_LIST_SIZE =
    maximum_class_table_size - (maximum_class * 4);



	(* size of class list in halfwords: 260, 628 or 1088 *)

  MAXIMUM_TABLE_CLASS_LIST_HALFWORD_SIZE =
    maximum_table_class_list_size div 2;



  TABLE_CLASS_LIST_HALFWORD_LIMIT =
    maximum_table_class_list_halfword_size - 1;

   

    (* size of group list in bytes: 344, 1436 or 3392 *)

  MAXIMUM_TABLE_GROUP_LIST_SIZE =
    maximum_group_table_size - (maximum_group * 4);



    (* size of group list in halfwords: 172, 718 or 1696 *)

  MAXIMUM_TABLE_GROUP_LIST_HALFWORD_SIZE =
    maximum_table_group_list_size div 2;



  TABLE_GROUP_LIST_HALFWORD_LIMIT =
    maximum_table_group_list_halfword_size - 1;

   

(* The following all refer to the description of	*)
(* the CLASS_GROUP_FILE, or TABLE, which exactly	*)
(* matches the table on the Supervisors.		*)

type
  TABLE_CLASS_LIST_INDEX = 0..table_class_list_halfword_limit;


  TABLE_GROUP_LIST_INDEX = 0..table_group_list_halfword_limit;



   (* CLASS_GROUP entries *)

  TABLE_ENTRY_DEFINITION = record
    index,
    count  : halfword (* high order bit on if exception *)
  end (* table_entry_definition *);



   (* pointers and sizes for all CLASSES *)

  TABLE_CLASS_DEFINITIONS = array [class_index] of table_entry_definition;
   


(* The list of CLASS values; the high order	*)
(* bit is on if the halfword is a HOST;		*)
(* otherwise, it is a NODE.			*)

  TABLE_CLASS_LIST = array [table_class_list_index] of halfword;



   (* pointers and sizes for all GROUPS *)

  TABLE_GROUP_DEFINITIONS = array [group_index] of table_entry_definition;



   (* The list of GROUP values (hosts) *)

  TABLE_GROUP_LIST = array [table_group_list_index] of halfword;



   (* The CLASS_GROUP_FILE *)
type	
  CLASS_GROUP_TABLE = record
    class_defs   : table_class_definitions;
    class_values : table_class_list;
    group_defs   : table_group_definitions;
    group_values : table_group_list
  end (* class_group_table *);



(* The following are used in the Supervisor Class/group	*)
(* Table; the actual values in table.class_defs.index,	*)
(* and table.class_defs.size				*)

const	(* actual pointer to first value *)
  FIRST_TABLE_CLASS_VALUE_POINTER = maximum_class * maximum_bytes_in_word;


(* actual pointer to last value *)
  TABLE_CLASS_VALUE_POINTER_LIMIT = maximum_class_table_size - 1;


type
  TABLE_CLASS_VALUE_POINTER_INDEX =
    first_table_class_value_pointer..table_class_value_pointer_limit;


  TABLE_CLASS_VALUE_POINTER_SIZE = 0..maximum_table_class_list_size;



(* The following are used in the Supervisor Class/group	*)
(* Table; the actual values in table.group_defs.index,	*)
(* and table.group_defs.count				*)

const	(* actual pointer to first value *)
  FIRST_TABLE_GROUP_VALUE_POINTER = maximum_group * maximum_bytes_in_word;


  TABLE_GROUP_VALUE_POINTER_LIMIT = maximum_group_table_size - 1;



type
  TABLE_GROUP_VALUE_POINER_INDEX =
    first_table_group_value_pointer..table_group_value_pointer_limit;


  TABLE_GROUP_VALUE_POINTER_SIZE = 0..maximum_table_group_list_size;


(*	Status of Class/group update:	*)

type
  CLASS_GROUP_STATUS = (
    CLASS_GROUP_NOT_TRIED	(* no update attempted *),
    CLASS_GROUP_FAILED		(* failure *),
    CLASS_GROUP_UPDATED		(* successful *));
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************)
(*						*)
(* Description of a node OR host list.		*)
(*						*)
(************************************************)

const
  NAMED_LIST_NAME_SIZE_LIMIT = maximum_named_list_name_size - 1;


type
  NAMED_LIST_NAME_INDEX = 0..named_list_name_size_limit;
  NAMED_LIST_NAME_SIZE = 0..maximum_named_list_name_size;

  NAMED_LIST_NAME_TEXT = array [named_list_name_index] of char;

  NAMED_LIST_NAME = record
    text	: named_list_name_text;
    size	: named_list_name_size
  end (* named_list_name *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* Description of the list of nodes OR hosts *)
const
  NAMED_LIST_ENTRY_LIMIT = maximum_named_list_entry - 1;


type
  NAMED_LIST_SIZE = 0..maximum_named_list_entry;
  NAMED_LIST_INDEX = 0..named_list_entry_limit;

  NAMED_LIST_ENTRIES = array [named_list_index] of integer;

(* the named node OR host list *)

  NAMED_LIST_DEFINITION = record
    name	: named_list_name (* size = 0, if none *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    count	: named_list_size	(* count of values *);
    values	: named_list_entries	(* nodes or hosts *);
    checksum	: integer
  end (* named_list_definition *);



(********************************************************)
(*							*)
(* Description of a list index.  Classes and groups are *)
(* defined by the list_indices that represent a node-	*)
(* list or hostlist.  Node and host lists use the	*)
(* same index...this will make it easier to use common	*)
(* code and conversions to a different configuration	*)
(* will not have to modify the data, just the		*)
(* arrangement of it on the disk.			*)
(*							*)
(********************************************************)

const
  LIST_LIMIT = maximum_list - 1;


type
  LIST_INDEX = 0..list_limit;


  LIST_DESCRIPTOR = record
    list_ptr 	: list_index;
    host_flag	: boolean
  end (* list_descriptor *);


(********************************************************)
(*							*)
(* Description of a nodelist or hostlist file entry.	*)
(*							*)
(********************************************************)

const
  MAXIMUM_BYTES_IN_NAMED_LIST =
    (maximum_named_list_name_size + 4) +	(* list name *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    ((maximum_named_list_entry + 1) * 4) +	(* entries + count *)
    4						(* checksum *);

  BYTES_IN_NAMED_LIST_LIMIT = MAXIMUM_BYTES_IN_NAMED_LIST - 1;

  MAXIMUM_PAGES_IN_NAMED_LIST =
    (maximum_bytes_in_named_list + page_limit) div page_size;


type
  DISK_NAMED_LIST_DEFINITION = array [0..BYTES_IN_NAMED_LIST_LIMIT] of char;


(********************************************************)
(*							*)
(* Description of a "global access".  A global_access	*)
(* is a collection of lists - also referred to as:  	*)
(*    CLASS - a collection of nodelists and/or hostlists*)
(*    GROUP - a collection of hostlists			*)
(*							*)
(********************************************************)

const
  GLOBAL_ACCESS_LIST_ENTRY_LIMIT = maximum_lists_in_global_access - 1;


type
  GLOBAL_ACCESS_LIST_ENTRY_SIZE = 0..maximum_lists_in_global_access;
  GLOBAL_ACCESS_LIST_ENTRY_INDEX = 0..global_access_list_entry_limit;

  GLOBAL_ACCESS_LIST =
    array [global_access_list_entry_index] of list_descriptor;


  GLOBAL_ACCESS_DESCRIPTION = record
    exception	: boolean	(* TRUE if exception class *);
    count	: global_access_list_entry_size;
    lists	: global_access_list;
    checksum	: integer
  end (* global_access_description *);


const
  MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION = 
    10 + (6 * maximum_lists_in_global_access);
  BYTES_IN_GLOBAL_ACCESS_DESCRIPTION_LIMIT =
    MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION - 1;


  MAXIMUM_PAGES_IN_GLOBAL_ACCESS =
    (maximum_bytes_in_global_access_description + page_limit) div page_size;

type
  DISK_GLOBAL_ACCESS_DESCRIPTION =
    array [0..BYTES_IN_GLOBAL_ACCESS_DESCRIPTION_LIMIT] of char;



(********************************************************)
(*							*)
(* Description of classes in the file.			*)
(*							*)
(********************************************************)

const
  MAXIMUM_PAGES_IN_CLASS_DEFINITIONS =
    maximum_class * maximum_pages_in_global_access;



(********************************************************)
(*							*)
(* Description of groups in the file.			*)
(*							*)
(********************************************************)

const
  MAXIMUM_PAGES_IN_GROUP_DEFINITIONS =
    maximum_group * maximum_pages_in_global_access;



(********************************************************)
(*							*)
(* Description of THE file.				*)
(*							*)
(********************************************************)

const
  FIRST_LIST_DATA_PAGE = 2 (* first page on disk that contains a list *);
  FIRST_NODE_LIST_PAGE = FIRST_LIST_DATA_PAGE;
  LAST_NODE_LIST_PAGE =
    first_node_list_page + (maximum_pages_in_named_list * maximum_list) - 1;


  FIRST_HOST_LIST_PAGE = last_node_list_page + 1;
  LAST_HOST_LIST_PAGE =
    first_host_list_page + (maximum_pages_in_named_list * maximum_list) - 1;


  FIRST_CLASS_DEFINITION_PAGE = last_host_list_page + 1;
  LAST_CLASS_DEFINITION_PAGE = 
    first_class_definition_page + maximum_pages_in_class_definitions - 1;


  FIRST_GROUP_DEFINITION_PAGE = last_class_definition_page + 1;
  LAST_GROUP_DEFINITION_PAGE = 
    first_group_definition_page + maximum_pages_in_group_definitions - 1;


(********************************************************)
(*							*)
(* Description of the file header.			*)
(*							*)
(********************************************************)

const
  NODE_HOST_CLASS_GROUP_ID = 'NHCG';

  LIST_HEADER_DATA_SIZE = 64;

  UNUSED_BYTES_IN_NHCG_HEADER =
    page_size - (list_header_data_size + maximum_bytes_in_word);

  UNUSED_BYTES_IN_NHCG_HEADER_LIMIT = unused_bytes_in_nhcg_header - 1;


type
  UNUSED_BYTES_IN_NHCG_HEADER_INDEX = 
    0..unused_bytes_in_nhcg_header_limit;

  NODE_HOST_FILE_HEADER = record
    id : array [0..3] of char	(* NHCG: Node Host Class Group *);
    max_list			(* MAXIMUM_LIST *),
    max_named_list_size		(* MAXIMUM_NAMED_LIST_NAME_SIZE *),
    max_named_list_description	(* MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE *),
    max_named_list_entry	(* MAXIMUM_NAMED_LIST_ENTRY *),
    max_pages_in_list		(* MAXIMUM_PAGES_IN_NAMED_LIST *),
    max_lists_in_global_access	(* MAXIMUM_LISTS_IN_GLOBAL_ACCESS *),
    max_pages_in_global_access	(* MAXIMUM_PAGES_IN_GLOBAL_ACCESS *),
    first_node_page		(* FIRST_NODE_LIST_PAGE *),
    last_node_page		(* LAST_NODE_LIST_PAGE *),
    first_host_page		(* FIRST_HOST_LIST_PAGE	*),
    last_host_page		(* LAST_HOST_LIST_PAGE *),
    first_class_page		(* FIRST_CLASS_DEFINITION_PAGE *),
    last_class_page		(* LAST_CLASS_DEFINITION_PAGE *),
    first_group_page		(* FIRST_GROUP_DEFINITION_PAGE *),
    last_group_page : integer	(* LAST_GROUP_DEFINITION_PAGE *);
    unused_bytes    : array [unused_bytes_in_nhcg_header_index] of char;
    checksum	    : integer
  end (* node_host_file_header *);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(* The following is used to return status from the *)
(* node_host_list_utility			*)
type
  NODE_HOST_UTILITY_STATUS = (
    NODE_HOST_OK		(* a-ok *),
    NODE_HOST_LIST_NOT_FOUND	(* no list located *),
    NODE_HOST_LIST_FOUND	(* already there *),
    NODE_HOST_BEING_UPDATED	(* being modified *),
    NODE_HOST_LIST_IN_USE	(* cannot delete list *),
    NODE_HOST_IO_ERROR		(* file error *),
    NODE_HOST_BAD_CHECKSUM	(* checksum does not match *),
    NODE_HOST_FULL		(* no room left *));



(* Description of lists for validators.  This 	*)
(* is used to return (and define new) list	*)
(* descriptions to validators.			*)


(* the named node OR host list *)

  VALIDATOR_NAMED_LIST_DEFINITION = record
    named_list	: named_list_definition;
    host_flag	: boolean (* TRUE if a HOSTlist *);
    sorted	: boolean (* TRUE if sorted when coming from disk *)
  end (* validator_named_list_definition *);



(* SYSMSG1 is the Supervisor slave used to update *)
(* the Class/group Table.			  *)

type
  SYSMSG1_STATUS = (
	SYSMSG1_SUCCESSFUl	(* operation complete *),
	SYSMSG1_BUILD_FAILURE	(* SYSMSG1 unavailable *),
	SYSMSG1_HANDSHAKE_ERROR	(* handshake failed *),
	SYSMSG1_CIRCUIT_ERROR	(* lost circuit/circuit zapped *),
	SYSMSG1_UNEXPECTED_INPUT);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	CUDDEF.NTV							*)
(*									*)
(*      This file contains all CUD file and entry defintions.		*)
(*									*)
(************************************************************************)
(*									*)
(*			revision record					*)
(*									*)
(*	03Spe86 - jrn							*)
(*	      - allow SET GFD ONLY and CHANGE UUN AND GAN CUD changes	*)
(*		available if not Tymshare CUD format (for BUBBNET)	*)
(*	18Jul86 - jrn							*)
(*	      - add CUD_ENTRY_IN_WRONG_BLOCK to CUD_ENTRY_RESULT	*)
(*	18Jun86 - neh							*)
(*	      - add type FIELDS for select, display and dump commands	*)
(*	07Oct85 - jrn							*)
(*	      - add MAX_X25_PREFIX_SIZE, MAX_X25_HOST_PLACES		*)
(*	15Feb85 - jrn							*)
(*	     - add CUD_ENTRY_ILLEGAL_NAME to cud_entry_result	 	*)
(*	30Jan85 - jrn							*)
(*	      - added OLD_LIST_CONFIGURATION				*)
(*	      - added MUD_VERSION_NUMBER, MUD_REVISION_NUMBER		*)
(*	15Nov84 version 3.00 pgl					*)
(*	      - moved CUD_PARAMETER_FILE definitions to PRMDEF.NTV	*)
(*	30Sep84 version 3.00    neb					*)
(*	      - added CUD block and CUD entry definitions for		*)
(*		conditional parameters					*)
(*		OVERFLOW_CUD_ENTRIES and TYMSHARE_CUD_FORMAT		*)
(*	14Jun84	version 2.02	jrn					*)
(*	      - added AUDITOR_LICENSE, OPERATOR_LICENSE			*)
(*	15Jun84 version 2.02	pgl					*)
(*	      - changed CONTROL_BITS to CUD_CONTROL_OPTIONS and added	*)
(*		LICENSED and PASSWORD_ONLY to CONTROL_OPTIONS		*)
(*	      - added the constants, FIRST_CUD_CONTROL_OPTION and	*)
(*		LAST_CUD_CONTROL_OPTION					*)
(*	      - added CRITERIA_TYPE					*)
(*									*)
(************************************************************************)


(* first, CUD file defintions *)

const
  MUD_VERSION_NUMBER = 1 (* major change level, field size, etc. *);
  MUD_REVISION_NUMBER = 0 (* minor change level, new option, etc. *);

(* bytes in a CUD block *)
  MAXIMUM_CUD_BLOCK_SIZE = maximum_cud_block_size_in_sectors * page_size;
  NORMAL_CUD_BLOCK_LIMIT = maximum_normal_cud_block - 1;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  MAXIMUM_CUD_BLOCK = maximum_normal_cud_block;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  CUD_BLOCK_LIMIT = maximum_cud_block - 1;


type
  CUD_BLOCK_INDEX = 0..cud_block_limit;

  NORMAL_CUD_BLOCK_INDEX = 0..normal_cud_block_limit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(* The following definition describes a type of CUD change: *)

  CUD_CHANGE_INDICATOR = (
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    NEW_USER_CUD_CHANGE,
    CHANGE_GAN_CUD_CHANGE,
    CHANGE_PASSWORD_CUD_CHANGE,
    RENAME_DELETE_USER_CUD_CHANGE,
    RENAME_RESTORE_OLD_NAME,
    RENAME_NEW_USER_CUD_CHANGE,
    DELETE_USER_CUD_CHANGE,
    CHANGE_OPTIONS_CUD_CHANGE,
    CHANGE_DISTRICT_CUD_CHANGE,
    CHANGE_UUN_CUD_CHANGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CHANGE_ACCESS_CUD_CHANGE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* CUD block defintions *)


(* a CUD block in pages *)

const
  CUD_BLOCK_IN_PAGES_LIMIT = maximum_cud_block_size_in_sectors - 1;


type
  CUD_BLOCK_IN_PAGES_INDEX = 0..cud_block_in_pages_limit;
  CUD_BLOCK_IN_PAGES = array [cud_block_in_pages_index] of page;



(* a CUD block *)
const (* a CUD block consists of data and one word of checksum *)
  MAXIMUM_CUD_DATA = maximum_cud_block_size - maximum_bytes_in_word;
  CUD_DATA_LIMIT = maximum_cud_data - 1;

type
  CUD_DATA_INDEX = 0..cud_data_limit;
  CUD_DATA_SIZE = 0..maximum_cud_data;
  CUD_DATA = array [cud_data_index] of char;



(* an entire CUD block *)
  CUD_DISK_BLOCK = record
    data     : cud_data;
    checksum : integer
  end (* cud_disk_block *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* The following are used for displaying CUD data *)
const
  MAXIMUM_CUD_BYTES_IN_LINE = 16;

  MAXIMUM_CUD_WORDS_IN_LINE =
    maximum_cud_bytes_in_line div maximum_bytes_in_word;
  CUD_WORDS_IN_LINE_LIMIT = maximum_cud_words_in_line - 1;



(* Describe size of parts of CUD entry in bytes *)

const
  ENTRY_SIZE_BYTES = 4;
  PASSWORD_BYTES = 4;
  ENTRY_CHANGE_DATE_BYTES = 4;
  GAN_BYTES = 4;
  UUN_BYTES = 4;
  OPTIONS_DISTRICT_BYTES = 4;
  PASSWORD_CHANGE_DATE_BYTES = 4;
  END_FLAG_BYTES = 2;



(* gfd only values *)
const
  GFD_ONLY_PASSWORD = '(:251:)(:239:)(:190:)(:251:)';
  GFD_ONLY_PASSWORD_DATE = BIT7 - 1;



(* Some offsets of CUD values. *)
  USERNAME_OFFSET = entry_size_bytes;

(* To get the exact offset for the following values, *)
(* the size of the user name must be taken into account *)
  PASSWORD_OFFSET = entry_size_bytes;
  ENTRY_CHANGE_DATE_OFFSET = entry_size_bytes + password_bytes;
  GAN_OFFSET = entry_size_bytes + password_bytes + entry_change_date_bytes;
  UUN_OFFSET = entry_size_bytes + password_bytes + entry_change_date_bytes +
    gan_bytes;
  OPTIONS_OFFSET = entry_size_bytes + password_bytes +
    entry_change_date_bytes + gan_bytes + uun_bytes;
  DISTRICT_OFFSET = options_offset;
  PASSWORD_CHANGE_DATE_OFFSET = entry_size_bytes + password_bytes +
    entry_change_date_bytes + gan_bytes + uun_bytes + options_district_bytes;
  IRC_OFFSET = password_change_date_offset;
  PROFILE_OFFSET = entry_size_bytes + password_bytes +
    entry_change_date_bytes + gan_bytes + uun_bytes + options_district_bytes +
    password_change_date_bytes;



(* the sizes of some cud changes... *)

const
  PASSWORD_CHANGE_SIZE = password_bytes + entry_change_date_bytes + gan_bytes +
    uun_bytes + options_district_bytes + password_change_date_bytes;
  IRC_CHANGE_SIZE = entry_change_date_bytes + gan_bytes + uun_bytes +
    options_district_bytes + password_change_date_bytes;
  GAN_CHANGE_SIZE = entry_change_date_bytes + gan_bytes;
  UUN_CHANGE_SIZE = entry_change_date_bytes + gan_bytes + uun_bytes;



(*	Some change option commands also change:	*)
(*		- password				*)
(*	  	- profile access (homes)		*)
(*	  	- password & profile access (homes)	*)
  OPTIONS_CHANGE_SIZE = entry_change_date_bytes +
    gan_bytes + uun_bytes + options_district_bytes;
  DISTRICT_CHANGE_SIZE = options_change_size;



(* This is the minimum change size for a profile change *)
(* when the new profile is the same size as the old pro-*)
(* file - the actual size of the profile must be added  *)
(* to compute the actual profile size change             *)
  MINIMUM_PROFILE_CHANGE_SIZE = entry_change_date_bytes +
    gan_bytes + uun_bytes + options_district_bytes +
    password_change_date_bytes;



(* The number of fixed characters in a CUD entry.		*)
(* Includes: size-of-entry word (4), password cipher (4),	*)
(*    entry change date (4), GAN (4), UUN (4), control		*)
(*    word (4), password change date (4), 0FFFF flag (2).	*)
(* In addition, the total size includes the variable values	*)
(* of user name and access profile information.			*)
  FIXED_CUD_ENTRY_SIZE = entry_size_bytes + password_bytes +
    entry_change_date_bytes + gan_bytes + uun_bytes + options_district_bytes +
    password_change_date_bytes + end_flag_bytes;



(* mask used with district word *)
  DISTRICT_MASK = mask_0FFF;
  TYMSHARE_OPTIONS_MASK = mask_0F0;
  TYMSHARE_CPARW_MASK = 65520 (* hex 0FFF0 *);
  CONTROL_OPTIONS_MASK = mask_0FFFF_F000;



(* define all CUD control options *)
  SHUT_OVERRIDE_BIT = bit3;
  TRANSPARENT_LOGIN_BIT = bit10;
  IGNORE_HOST_BIT = bit13;
  NEW_PASSWORD_BIT = bit14;
  NO_PASSWORD_BIT = bit15;
  PRIORITY_CIRCUIT_BIT = bit16;
  NETWORK_ADMINISTRATOR_BIT = bit17;
  AUDITOR_BIT = bit19;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ACCOUNT_SUPERVISOR_BIT = bit18;
  OPERATOR_BIT = bit4;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* define all control options *)
(* Licensed and password_only do not have a one to one ratio with	*)
(* control bits in the cud.  Licensed means the account_supervisor bit	*)
(* is on or the network_administrator bit is on.  Password_only means	*)
(* the account_supervisor bit is off and the network_administrator bit	*)
(* is off.								*)

type
  CONTROL_OPTIONS = (LICENSED, PASSWORD_ONLY, (* not bits in CUD *)
    ACCOUNT_SUPERVISOR, IGNORE_HOST, NETWORK_ADMINISTRATOR, NO_PASSWORD,
    SHUT_OVERRIDE, AUDITOR, OPERATOR, TRANSPARENT_LOGIN, NEW_PASSWORD_OPTION
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
);

const
  FIRST_CUD_CONTROL_OPTION  = account_supervisor;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  LAST_CUD_CONTROL_OPTION =  new_password_option;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  FIRST_CUD_CONTROL_OPTION_TO_PRINT = account_supervisor;
  LAST_CUD_CONTROL_OPTION_TO_PRINT = transparent_login;



type
(* cud_control_options - previously called control bits *)
(* this is a subset of control options *)
  CUD_CONTROL_OPTIONS = first_cud_control_option..last_cud_control_option;
  USER_OPTIONS = set of cud_control_options;



const
  MAXIMUM_DISTRICT = 4095;

type
  DISTRICT_NUMBER = 0..maximum_district;



(* define some access entry definitions *)
(* Always consider the halfwords from the CUD access *)
(* entry to be in the right half of an integer.      *)
(* When converting from cud_data characters to a     *)
(* cud_user_entry, the two bytes will be picked up   *)
(* into the right half of a word (the left half is   *)
(* zeroed by pick_up_two_cud_bytes).                 *)

const
  ACCESS_ENTRY_SIZE_LOCATION = bit19;
  IN_PLACE_BIT = bit20;
  EXCEPTION_BIT = bit21;
  HOME_BIT = bit16;
  ORIGIN_HOST_BIT = bit16;
  GROUP_BIT = bit17;
  IN_PLACE_ORIGIN_SIZE_MASK = mask_3FF;
  USER_CLASS_MASK = mask_3FF;



(* in-place origin definitions *)
  MAXIMUM_IN_PLACE_ORIGIN = 5 (* max no. of in-place origins *);
  IN_PLACE_ORIGIN_LIMIT = maximum_in_place_origin - 1;



type
  IN_PLACE_ORIGIN_INDEX = 0..in_place_origin_limit;
  IN_PLACE_ORIGIN_SIZE = 0..maximum_in_place_origin;

  IN_PLACE_ORIGIN_ENTRY = record
    value     : integer (* host or node *);
    host_flag : boolean (* TRUE if value is a host *)
                        (* FALSE if value is a node *)
  end (* in_place_origin_entry *);


  IN_PLACE_ORIGIN_DESCRIPTION = record
    size : in_place_origin_size;
    list : array [in_place_origin_index] of in_place_origin_entry
  end (* in_place_origin_description *);



(* destination definitions *)
const
  MAXIMUM_DESTINATION = 6 (* if system defined class *);
            (* otherwise, if in-place origin, maximum is 5 *)
  DESTINATION_LIMIT = maximum_destination - 1;


type
  DESTINATION_INDEX = 0..destination_limit;
  DESTINATION_SIZE = 0..maximum_destination;

  DESTINATION_ENTRY = record
    value     : integer (* host or group *);
    group_flag: boolean (* TRUE if value is group, FALSE if value is host *);
    home_flag : boolean (* TRUE if value is home, else FALSW *)
  end (* destination_entry *);

  DESTINATION_DESCRIPTION = record
    size : destination_size;
    list : array [destination_index] of destination_entry
  end (* destination_description *);


(* a single access entry *)
  ACCESS_ENTRY_DESCRIPTION = record
    in_place_origin: boolean	(* TRUE if origin is in-place *);
    exception   : boolean	(* TRUE if in-place is exception *);
    class_no    : class_index	(* if not in-place origin, CLASS number *);
    origin      : in_place_origin_description;
    destination : destination_description
  end (* access_entry_description *);


(* an entire access profile *)
const
  MAXIMUM_ACCESS_ENTRY = 11;
  ACCESS_ENTRY_LIMIT = maximum_access_entry - 1;


type
  ACCESS_ENTRY_INDEX = 0..access_entry_limit;
  ACCESS_ENTRY_SIZE = 0..maximum_access_entry;

  ACCESS_PROFILE_DESCRIPTION = record
    count   : access_entry_size;
    entries : array [access_entry_index] of access_entry_description
  end (* access_profile_description *);


(* flag that ends a user CUD entry *)
const
  CUD_ENTRY_TERMINATOR = 65535 (* a half-word of all one's *);


(* an entire user CUD entry *)
type
  CUD_USER_ENTRY = record
    name		: username_string;
    password		: integer (* cipher of password *);
    entry_change_date	: integer (* seconds since 1/1/72 *);
    gan			: integer;
    uun			: integer;
    password_change_date: integer (* days since 1/1/72 *);
    district		: district_number;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    options		: user_options;
    access_profile	: access_profile_description
  end (* cud_user_entry *);


(* used by DISPLAY_DIRECTORY, SELECT and ARCHIVE_DUMP Command *)
  CRITERIA_TYPE = (ALL_CRITERIA, ACCESS_CRITERION, GAN_CRITERION,
    DISTRICT_CRITERION, UUN_CRITERION, CONTROL_CRITERION,
    ENTRYDATE_CRITERION, PASSWORDDATE_CRITERION);

  FIELDS = (ALL_FIELDS, UUN_FIELD, GAN_FIELD, DISTRICT_FIELD,
    CONTROL_FIELD, PASSWORDDATE_FIELD, ENTRYDATE_FIELD, ACCESS_FIELD);
!
(* Results from CUD block operations:	*)

type
  CUD_OPERATION_RESULT = (
    CUD_OPERATION_OK		(* successful *),
    CUD_FILE_LOCKED		(* CUD file is read only *),
				(* busy doing STORE in ARCHIVE *)
    CUD_BLOCK_MANUALLY_LOCKED	(* locked manually *),
    CUD_CHECKSUM_ERROR		(* bad checksum read *),
    CUD_OPERATION_FAILED	(* read/write failed *));


(*	Results from CUD ACCESS operations:	*)

type
  CUD_ACCESS_STATUS = (
    CUD_ACCESS_OK		(* block locked successfully *),
    CUD_ACCESS_FILE_LOCKED	(* file locked for ARCHIVE against writing *),
    CUD_ACCESS_BLOCK_SHUT	(* programmer has block *));



(*	Results from CUD update operations:	*)

type
  CUD_ENTRY_RESULT = (
    CUD_ENTRY_OK,			(* complete *)
    CUD_ENTRY_FILE_LOCKED,		(* locked (archive) against writing *)
    CUD_ENTRY_LOCKED,			(* entry busy *)
    CUD_ENTRY_BLOCK_LOCKED,		(* programmer has block locked! *)
    CUD_ENTRY_DOES_NOT_FIT,		(* CUD block full *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CUD_ENTRY_NOT_FOUND,		(* name not found *)
    CUD_NAME_TAKEN,         		(* name requested already used *)
    CUD_FORMAT_ERROR,       		(* error in CUD format *)
    CUD_ENTRY_BAD_CHECKSUM,		(* bad checksum on CUD block *)
    CUD_ENTRY_MUD_CHANGE_FILE_FULL,	(* MUDUPD full *)
    CUD_ENTRY_MUD_CHANGE_FILE_ERROR,	(* MUDUPD I/O error *)
    CUD_ENTRY_LUD_CHANGE_FILE_ERROR,	(* LUD file error *)
    CUD_ENTRY_OPERATION_FAILED,		(* I/O failed *)
    CUD_ENTRY_IN_WRONG_BLOCK,		(* entry is not in correct block *)
    CUD_ENTRY_ILLEGAL_NAME		(* not a valid username *));




(* CUD change information is described by the following types;	*)
(* they are used to pass information about changes to the	*)
(* MUD_CHANGE_HANDLER Monitor.					*)


(* the size of a CUD change in words...as it is *)
(* stored in the MUD_UPDATE_FILE and sent to UN2 *)

const
  CUD_DATA_WORD_MAXIMUM = maximum_cud_data div maximum_bytes_in_word;
  CUD_DATA_WORD_LIMIT = cud_data_word_maximum - 1;


type
  CUD_DATA_WORD_SIZE = 0..cud_data_word_maximum;
  CUD_DATA_WORD_INDEX = 0..cud_data_word_limit;


(* the header for CUD changes *)
(* as it appears everywhere but on the DISK *)

type
  CUD_CHANGE_HEADER = record
    block  : cud_block_index		(* block of change *);
    offset : cud_data_word_index	(* word index into CUD block *);
    size   : cud_data_word_size		(* words in change *)
  end (* cud_change_header *);



(* the header for CUD changes *)
(* as it appears on the DISK *)
const
  CUD_CHANGE_HEADER_SIZE = 8 (* bytes *);


(***** CUD change information *****)

type
  CUD_CHANGE_INFORMATION = record
    header : cud_change_header;
    data   : cud_data
  end (* cud_change_information *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	PRMDEF.NTV							*)
(*									*)
(*	Constants and type definitions for the cud parameter file.	*)
(*									*)
(************************************************************************)
(*									*)
(*			  Revision Record				*)
(*									*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - the changes will not take care of assigning greater	*)
(*		than 18 bit UUNS, but will leave things open for that	*)
(*		later development					*)
(*	15Nov84		Original - pgl - neb				*)
(*									*)
(************************************************************************)



(************************************************************************)
(*									*)
(* The last CUD block is followed by an empty (unused) block.		*)
(* The cud parameter file follows the empty block.			*)
(*									*)
(* The format for the first page, or header, of the CUD parameter file	*)
(* depends on the conditional flag, reuse_uuns.				*)
(*									*)
(* If reuse_uuns is DISABLED, then the first page contains the next	*)
(* GAN and UUN to be assigned and a checksum; the file is one page long.*)
(*									*)
(************************************************************************)

const
  CUD_PARAMETER_HEADER_PAGE = 0 (* first page of CUD_PARAMETER file *);


type
  UUN_INDEX = 1..MAX_INTEGER (* possible legal uuns *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

const
  LAST_PARAM_PAGE = 0 (* file is only a header page *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


type
(* to refer to any PAGE in the file *)
  CUD_PARAMETER_PAGE_INDEX = cud_parameter_header_page..last_param_page;



  CUD_PARAMETER_STATUS = (
    CUD_PARAMETER_OK,
    CUD_PARAMETER_BAD_CHECKSUM,
    CUD_PARAMETER_IO_ERROR);



(* unused bytes in the header page *)
const
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  CUD_PARAMETER_HEADER_UNUSED_BYTES = page_size - (3 * maximum_bytes_in_word);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


const
  CUD_PARAMETER_HEADER_UNUSED_LIMIT = cud_parameter_header_unused_bytes - 1;

type
  CUD_PARAMETER_HEADER = record
    next_gan		: integer (* next GAN to be assigned *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    next_uun	: uun_index (* next UUN to be assigned *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    unused   : array [0..cud_parameter_header_unused_limit] of char;
    checksum : integer
  end (* cud_parameter_header *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	FILDEF.NTV							*)
(*									*)
(*	Constants and type definitions for the file system.		*)
(*									*)
(************************************************************************)
(*									*)
(*			  Revision Record				*)
(*									*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	14Jun85 - jrn							*)
(*	      - define file_utility_status				*)
(*	      - in CONFIGURATION_INFORMATION record, changed		*)
(*		pages_on_this_disk to pages_on_disk_one, and added	*)
(*		pages_on_disk_zero					*)
(*	11Dec84 - jrn							*)
(*	      - added ID and LAST_PVOL_TIME_STAMP to			*)
(*		configuration_information				*)
(*	15Nov84 - pgl							*)
(*	      - added conditional assembly flag, REUSE_UUNS,	 	*)
(*		to computation of CUD_PARAMETER_FILE_LENGTH 		*)
(*	31Jul84 - jrn							*)
(*	      - increase incarnation to 1; add node_host list		*)
(*		configuration information to the node_host file;	*)
(*		new format node_host file; treat CUD PARAMETER file	*)
(*		as a separate file; add checksums to operlog and	*)
(*		node_host file entries					*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - modify length of node host file to match actual size	*)
(*		in version 1.14						*)
(*	29SEP83 Original from (patrol)fildef.ntc - jrn			*)
(*									*)
(************************************************************************)



(*	Define the disk units:   *)

const
  CUD_DISK_UNIT = 0;
  FILE_SYSTEM_DISK = cud_disk_unit + 1;

(* for logical volumes, add: *)
  CUD_DISK_UNIT2 = file_system_disk + 1;
  FILE_SYSTEM_DISK2 = cud_disk_unit2 + 1;



type
  FILE_DESCRIPTOR = record
      unit        : disk_unit_index;
      address		(* first physical page number in file *),
      length		(* number of pages in file *),
      creation_date : integer
  end (* file_descriptor *);



  FILE_INDEX = (
    CONFIGURATION_FILE	(* NETVAL configuration dependant value defs *),
    NODE_HOST_FILE	(* NETVAL format Class/group information *),
    CLASS_GROUP_FILE	(* Supervisor format Class/group table *),
    OPERLOG_FILE	(* NETVAL happenings *),
    MUD_UPDATE_FILE	(* Misc. NETVAL info and MUD change records *),
    CUD_FILE		(* user information *),
    CUD_PARAMETER_FILE	(* next gan, uun to be assigned *)	);


const
  FIRST_FILE = CONFIGURATION_FILE;
  LAST_FILE = CUD_PARAMETER_FILE;

(* all file descriptors *)
type
  FILE_SYSTEM_DESCRIPTOR = array [file_index] of file_descriptor;


const
  FIRST_ARCHIVE_FILE = CONFIGURATION_FILE;
  LAST_ARCHIVE_FILE = CUD_PARAMETER_FILE;

type
  ARCHIVE_FILE_INDEX = first_archive_file..last_archive_file;
!
(**************     DISK CONFIGURATION     **************)


(* Define file lengths in pages of 256 bytes. *)



(********************************************************)
(*							*)
(*			Unit 0				*)
(*							*)
(********************************************************)



(*	The maximum possible size of the CUD file in pages:	*)

const
  CUD_FILE_LENGTH = (maximum_cud_block * maximum_cud_block_size) div page_size;



(* The start page of CUD file, beginning of disk unit:	*)

  CUD_FILE_START = 0;


(* The start and length of the CUD parameter file:	*)

  CUD_PARAMETER_FILE_START = CUD_FILE_LENGTH + 1;

CUD_PARAMETER_FILE_LENGTH = last_param_page + 1;
!
(********************************************************)
(*							*)
(*			Unit 1				*)
(*							*)
(********************************************************)

  CONFIGURATION_FILE_START = 0;
  CONFIGURATION_FILE_LENGTH = 1;

  NODE_HOST_FILE_START = configuration_file_start + configuration_file_length;
  NODE_HOST_FILE_LENGTH = LAST_GROUP_DEFINITION_PAGE;

  CLASS_GROUP_FILE_START = node_host_file_start + node_host_file_length;
  CLASS_GROUP_FILE_LENGTH =
    (maximum_class_table_size + maximum_group_table_size) div 256;


(********************************************************)
(*							*)
(*	Define 2 buffers to hold CUD blocks on the	*)
(*	disk.  These are used for programmers to	*)
(*	store their CUD and MUD buffers, rather than	*)
(*	declaring them as permanent variables.		*)
(*	Since I/O is done in the DISK_SYSTEM (via	*)
(*	read_cud_block and write_cud_block) the		*)
(*	buffer locations must be in terms of BLOCKS,	*)
(*	not PAGES.  3 Blocks are allocated, since	*)
(*	CUD_BUFFER_START may not be on a block boundry.	*)
(*							*)
(********************************************************)

(* in pages: *)
  CUD_BUFFER_START = class_group_file_start + class_group_file_length;
  CUD_BUFFER_LENGTH = 3 * MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS;

(* in CUD blocks: *)
  CUD_BUFFER_LOCATION = (MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS + cud_buffer_start)
    div MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS;
  MUD_BUFFER_LOCATION = cud_buffer_location + 1;

  OPERLOG_FILE_START = cud_buffer_start + cud_buffer_length;

(* The MUDUPD file should be the maximum size possible, i.e.,	*)
(* the size of the entire disk less:				*)
(*	- all preceeding files					*)
(*	- CUD/MUD ("programmer") buffers; since buffers are	*)
(*	  defined in terms of blocks, room is kept for 3 full	*)
(*	  buffers in case the first does not start on a CUD	*)
(*	  block boundry						*)
(*	- operlog						*)

  MUD_UPDATE_FILE_START = operlog_file_start + operlog_file_length;
  MUD_UPDATE_FILE_LENGTH = disk_unit_one_size - mud_update_file_start;



(*    Configuration file format:    *)

const
  NETVAL_ID = 'NETVAL';
  UNUSED_CONFIGURATION_BYTES = 40;
  UNUSED_CONFIGURATION_LIMIT = unused_configuration_bytes - 1;
  ORIGINAL_INCARNATION		= 0;
  CURRENT_INCARNATION		= 1;



(* Other values may be added to the CONFIGURATION_FILE	*)
(* at a later time.  UNUSED_CONFIGURATION_BYES must	*)
(* then be updated.					*)
(* The information in configuration_information from the*)
(* disk is compared against NETVAL parameters at	*)
(* start-up time, and NETVAL crashes if any differences.*)

type
  CONFIGURATION_INFORMATION = record
    id			: array [0..5] of char (* NETVAL_ID *);
    incarnation_number,
    label_date_and_time,
    pages_on_disk_one	: integer (* DISK_UNIT_ONE_SIZE *);
    files		: file_system_descriptor;
    cud_block_size_in_sectors	(* MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS *),
    supervisors				(* MAXIMUM_EXPECTED_SUPERVISORS *),
    cud_blocks		: integer	(* MAXIMUM_CUD_BLOCK *);
    gans				(* INCLUDE_GAN *),
    districts		: boolean	(* INCLUDE_DISTRICT *);
    password_size	: integer	(* MINIMUM_PASSWORD_SIZE *);
    non_alpha_password			(* REQUIRE_NONALPHANUMERIC *),
    zero_class_group_assignable		(* CLASS_0_GROUP_0_ASSIGNABLE *),
    cud_is_mud		: boolean	(* NETVAL_CUD_IS_A_MUD *);
    programmer_size	: integer	(* PROGRAMMER_NAME_SIZE *);
    programmer		: username_text (* PROGRAMMER_NAME *);
    hosts				(* MAXIMUM_HOST *),
    nodes				(* MAXIMUM_NODE *),
    classes				(* MAXIMUM_CLASS *),
    class_table_size			(* MAXIMUM_CLASS_TABLE_SIZE *),
    groups				(* MAXIMUM_GROUP *),
    group_table_size	: integer	(* MAXIMUM_GROUP_TABLE_SIZE *);
    last_pvol_time_stamp: integer (* if LVOL are used, last time *);
				  (* a write was known successful *)
    pages_on_disk_zero	: integer (* DISK_UNIT_ZERO_SIZE *);
    unused		: array [0..unused_configuration_limit] of char;
    checksum		: integer
  end (* configuration_information *);



(*	The following is used to describe the access state	*)
(*	of a file; access to files are handled in a Monitor	*)
(*	for each file, since access is specific to the file	*)
(*	and how it is used.					*)

type
  FILE_ACCESS_STATE = (
    FILE_AVAILABLE	(* usable *),
    FILE_READABLE	(* read-only *),
    FILE_LOCKED		(* not accessable *));


  FILE_UTILITY_STATUS = (FU_SUCCESS, FU_IO_ERROR, FU_CHECKSUM_ERROR);
!
(************************************************************************)
(*									*)
(*	MCHDEF.NTV							*)
(*									*)
(*      This file contains all MUD change file defintions.		*)
(*									*)
(************************************************************************)
(*									*)
(*			revision record					*)
(*      								*)
(*	31Jul86 - rsb							*)
(*		- add CURRENT_UN2_ACTIVITY enumeration type as a direct *)
(*		  way of knowing what is going on in relation to a Sup, *)
(*		  instead of inferring it from examining mud_updater_	*)
(*		  delay_que and consistency_start_date			*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - change merge_month to last_merge			*)
(*	20Jan86 - jrn							*)
(*	        - modify USN code for NVDM				*)
(*	23Dec85 - rsb							*)
(*		- change definition of MAXIMUM_MUDUPD_SUPERVISOR AND	*)
(*		  MUDUPD_SUPERVISOR_INDEX for USN: 			*)
(*                change "MUDUPD" into "REAL"				*)
(*		- redefine SUPERVISOR_INDICATOR because of above	*)
(*		- added definitions for:				*)
(*                     PSEUDO_SUPERVISOR_INDEX  			*)
(*                     EMPTY_ENTRY 					*)
(*                     ps_table_search_range 				*)
(*		- SET_SUPERVISOR_STATUS add USN-related errors		*)
(*									*)
(************************************************************************)


(* Define bytes and pages in the MUD_UPDATE_FILE: *)

const
  PAGES_IN_MUDUPD_HEADER = 1;
  MUDUPD_HEADER_ADDRESS = 0;



(* Define the address of a byte of data in the		*)
(* MUD_UPDATE_FILE in terms of a specific page		*)
(* and byte in the page.  This is used internally	*)
(* to help in accessing the file.			*)

  MUDUPD_PAGE_LIMIT = mud_update_file_length - 1;


type
  MUDUPD_PAGE_INDEX = 0..mudupd_page_limit;

  MUDUPD_ADDRESS = record
    page_offset : mudupd_page_index;
    byte_offset : page_index
  end (* mudupd_address *);



(*	Define the address of a byte of data		*)
(* (MUDUPD_DATA_INDEX) in the MUD_UPDATE_FILE. This	*)
(* is the actual "address" recorded for last_record	*)
(* and disk_eof.					*)

(* MUD_UPDATE_FILE_LENGTH is defined in fildef.ntv *)

const
  MUDUPD_DATA_MAX =
    (mud_update_file_length - pages_in_mudupd_header) * page_size;
  MUDUPD_DATA_LIMIT = mudupd_data_max - 1;


type
  MUDUPD_DATA_INDEX = 0..mudupd_data_limit;



(* Define Supervisors values. *)

const
  FIRST_SUPERVISOR = 1;


const (* for printing only *)
  PRINT_SUPERVISOR_OFFSET = 120;






(**** all possible Supervisors ****)

const
  MAXIMUM_REAL_SUPERVISOR = 7;


type
  REAL_SUPERVISOR_INDEX = FIRST_SUPERVISOR..MAXIMUM_REAL_SUPERVISOR;


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PSEUDO_SUPERVISOR_INDEX = FIRST_SUPERVISOR..MAXIMUM_EXPECTED_SUPERVISORS;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

const
  EMPTY_ENTRY = 0;

type
  ps_table_search_range = EMPTY_ENTRY..MAXIMUM_REAL_SUPERVISOR;




(*	The following describes Supervisor information	*)
(*	in the MUD_UPDATE_FILE header:			*)

type		(* consistency run information *)
  CONSISTENCY_INFO = record
    start_date	: integer		(* start of run *);
    block	: cud_block_index	(* last processed *);
    manual	: boolean		(* run started manually *);
    stopped	: boolean		(* run stopped by command *)
  end (* consistency_info *);


  CONSISTENCY_HISTORY_INFO = record
    consistency : consistency_info;
    stop_date   : integer   	(* run stopped *)
  end (* consistency_history_info *);


(*	The following describes Supervisor information: *)

const
  SUPERVISOR_OFF = 0;


type
  SUPERVISOR_INDICATOR = supervisor_off..maximum_real_supervisor;

  SUPERVISOR_DISK_INFORMATION = record
    state           : supervisor_indicator;
    pointer         : mudupd_data_index (* next record *);
    last_mud_update,          (* date of last MUD update *)
    last_cg_update  : integer (* Class/group update date *);
    history         : consistency_history_info
  end (* supervisor_disk_information *);


  HEADER_SUPERVISOR_INFORMATION =
    array [real_supervisor_index] of supervisor_disk_information;



(*	The record to describe the first block	*)
(*	Of the MUD_UPDATE_FILE is:		*)

const
  MUDUPD_ID = 1515847745 (* hex 5A5A0041 *);



(*	The disk_eof is a pointer to the actual physical end of data	*)
(*	in the MUD_UPDATE_FILE, i.e., the pointer to where to store	*)
(*	the next CUD change record.  "last_record" points to the	*)
(*	beginning of data in the last record stored in the file.	*)

(*	"last_record" is used to determine if the last CUD change	*)
(*	was totally completed; when a CUD change is made:		*)
(*		- the MUD_UPDATE_FILE is notified that a		*)
(*		  change is pending and the change is			*)
(*		  recorded in the MUD_UPDATE_FILE			*)
(*		- the changed CUD block is written out			*)
(*		  to the disk						*)
(*		- the change is confirmed to the			*)
(*		  MUD_CHANGE_HANDLER					*)

(*	When a change is appended to the file, last_record is set to	*)
(*	disk_eof; when the system is initialized, the information in	*)
(*	the record pointed to by "last_record" is compared against	*)
(*	the actual data in the CUD; if the data does NOT match, the	*)
(*	data in the last record is thrown away (disk_eof is set to	*)
(*	last_record) and the MUDs are not notified of that change.	*)
(*	This should only be possible if NETVAL crashes between the	*)
(*	MUD_UPDATE_FILE's notification of a CUD change and the		*)
(*	confirmation of the CUD change.					*)

type
  MUDUPD_DISK_HEADER = record
    file_id          : integer  (* should be MUDUPD_ID *);
    disk_eof         : mudupd_data_index (* see comments above *);
    last_cg_creation,   (* date of last Class/group creation *)
    consistency_start,  (* time to start trying consis. *)
    consistency_stop : integer (* time to stop trying consis. *);
    last_record      : mudupd_data_index (* see comments above *);
    last_merge	     : integer (* time UUN, add_back files were last merged *);
    unused	     : array [0..3] of char;
    sup_disc_info    : header_supervisor_information
  end (* mudupd_disk_header *);



(*	The following definition is used to pass MUD	*)
(*	changes between MUD_UPDATER Processes and	*)
(*	validator Processes and the UN2_UTILITY Class	*)

type
  MUD_CHANGE_INFORMATION = record
    cud_info : cud_change_information;
    checksum : integer
  end (* mud_change_information *);



type
  UN2_STATUS = (
	UN2_SUCCESSFUL		(* operation complete *),
	UN2_BUSY		(* circuit in use by consistency *),
	UN2_BUILD_FAILURE	(* Sup unavailable *),
	UN2_UNEXPECTED_INPUT	(* char received not in protocol *),
        UN2_TOO_MANY_RETRIES	(* resent block too many times *),
	UN2_HANDSHAKE_ERROR	(* handshake failed *),
	UN2_CIRCUIT_ERROR	(* lost circuit/circuit zapped *));


type
  CONSISTENCY_STATUS = (
    CONSISTENCY_OK	(* all is good *),
    UN2_ERROR		(* some problem on circuit *),
    CUD_ERROR		(* some problem on file *),
    CONSISTENCY_STOPPED	(* stopped by cmd or time *),
    CONSISTENCY_DONE);



  SET_SUPERVISOR_STATUS = (
    SET_SUP_SUCCESSFULL,
    SET_SUP_AUTO_CONSISTENCY_HALTED,
    SET_SUP_NO_ROOM_IN_PSEUDO_SUP_TABLE,
    SET_SUP_ALREADY_IN_PSEUDO_SUP_TABLE,
    SET_SUP_MANUAL_CONSISTENCY_IN_PROGRESS,
    SET_SUP_ALREADY_ON,
    SET_SUP_ALREADY_OFF,
    SET_SUP_OFF_ALREADY_IN_PROGRESS);


(* Current Netval-to-Sup communications activity *)
type
  CURRENT_COMM_ACTIVITY = (
	NOT_BUSY,	
	AUTO_CONSISTENCY, 
	MANUAL_CONSISTENCY,
	MUD_UPDATING);

(************************************************************************)
(*									*)
(*	ARCDEF.NTV							*)
(*									*)
(************************************************************************)
(*									*)
(*			    Revision Record				*)
(*									*)
(*	13May86 - neh							*)
(*	      - if INCLUDE_DUMP is enabled add ascii_dump parameters	*)
(*	31Jul84 - jrn							*)
(*	      - standard ANSII format tapes				*)
(*									*)
(************************************************************************)


type
  TAPE_ASSIGN_STATUS = (ASSIGN_OK, ALREADY_ASSIGNED, ATTACH_FAILED);


(************************************************************************)
(*									*)
(*	ALL LABELS USE ANSII_TAPE_LABEL for manipulating data, due	*)
(*	to the painful fact that character strings must start on	*)
(*	a halfword boundry; also, note that there are some odd		*)
(*	length strings in the record definitions, due to odd length	*)
(*	fields in the ANSII standard.					*)
(*									*)
(************************************************************************)

const
  max_ansii_tape_label_size = 80 (* the size of ALL ANSII standard labels *);
  ansii_tape_label_limit = max_ansii_tape_label_size - 1;

type
  ansii_tape_label_size = 0..max_ansii_tape_label_size;
  ansii_tape_label_index = 0..ansii_tape_label_limit;

  ansii_tape_label = array [ansii_tape_label_index] of char;


(************************************************************************)
(*                                                                      *)
(*  Global label definitions for ANSII Magnetic tape standard.		*)
(*                                                                      *)
(************************************************************************)

const
  label_owner_id = 'NETVAL \';

  label_id_offset = 0;
  label_id_size = 4;

  label_file_name_offset = 4;
  label_file_name_size = 17;

  label_set_id_offset = 21;
  label_set_id_size = 6;

(* The "section" of a file is incremented by one	*)
(* on each subsequent volume of the file.		*)
  label_file_section = 1 (* first section for each file *);
  label_file_section_offset = 27;
  label_file_section_size = 4;

  label_file_sequence_offset = 31;
  label_file_sequence_size = 4;

  label_generation_number_offset = 35;
  label_generation_number_size = 4;

  label_generation_version_number_offset = 39;
  label_generation_version_number_size = 2;

  label_creation_date_offset = 42;
  label_expiration_date_offset = 48;
  label_date_size = 5;

  label_block_count_offset = 54;
  label_block_count_size = 6;
!
(************************************************************************)
(*                                                                      *)
(*  Volume label definitions for ANSII Magnetic tape standard:		*)
(*	bytes 0 - 39:	"VOL1ddmmyy                           NET"	*)
(*	bytes 40 - 79:	"VAL vv.rr                              1"	*)
(*                                                                      *)
(************************************************************************)

const
  vol1_id = 'VOL1\ '	(* use label_id_offset *);

  vol1_date_day_offset = 4;
  vol1_date_month_offset = 6;
  vol1_date_year_offset = 8;

  vol1_owner_offset = 37;
  vol1_owner_size = 7;

  vol1_version_offset = 44;
  vol1_version_size = 5;

  vol1_standard_level_offset = 79;
  vol1_standard_level = '1';


(* The entire VOL1 label description, for information only;		*)
(* ALL LABELS USE LABEL_IN_BYTES for manipulating data, (see above).	*)
"type
    vol1_label = record
    label_id		: array [0..3] of char  (* VOL1_ID *);
    serial_number	: array [0..5] of char  (* 'DDMMYY' *);
    accessibility	: char			(* ' ' (unlimited) *);
    reserved1		: array [0..25] of char (* must be ' ' *);
    owner_id		: array [0..6] of char  (* LABEL_OWNER_ID *);
    version_id		: array [0..4]	  	(* 'VV.RR' *);
    reserved2		: array [0..29] of char (* must be ' ' *);
    label_level		: char			(* VOL1_STANDARD_LEVEL *)
  end (* vol1_label *);"
!
(************************************************************************)
(*                                                                      *)
(*  File header 1 label definitions for ANSII Magnetic tape standard:	*)
(*	bytes 0 - 39:	"HDR1file identifier  NETVALssssnnnn00010"	*)
(*	bytes 40 - 79:	"0 yyddd yyddd 000000                    "	*)
(*                                                                      *)
(************************************************************************)

const 
  hdr1_id = 'HDR1\ '	(* use label_id_offset *);

(* The entire HDR1 label description, for information only;		*)
(* ALL LABELS USE LABEL_IN_BYTES for manipulating data, (see above).	*)
"type
  hdr1_label = record
    label_id		: array [0..3] of char  (* HDR1_ID *);
    file_identifier	: array [0..16] of char (* NETVAL file name *);
    set_identifier	: array [0..5] of char  (* 'NETVAL' *);
    file_section	: array [0..3] of char  (* 0001, 0002, etc. *);
    file_sequence	: array [0..3] of char  (* sequential file number *);
    generation		: array [0..3] of char  (* 0001 *);
    version		: array [0..1] of char  (* 00 *);
    creation_date	: array [0..5] of char  (* ' YYDDD' *);
    expiration_date	: array [0..5] of char  (* ' YYDDD' *);
    accessibility	: char			(* ' ' (unlimited) *);
    block_count		: array [0..5] of char  (* '000000' *);
    reserved		: array [0..19] of char (* ' ' *)
  end (* hdr1_label *);"
!
(************************************************************************)
(*                                                                      *)
(*  File header 2 label definitions for ANSII Magnetic tape standard:	*)
(*	bytes 0 - 39:	"HDR2Fbbbbbrrrrr                         "	*)
(*	bytes 40 - 79:	"          00                            "	*)
(*                                                                      *)
(************************************************************************)

const 
  hdr2_id = 'HDR2\ ';

  hdr2_format = 'F' 		(* size is in first 4 bytes of each record *);
				(* in binary, USUALLY followed by checksum *)
  hdr2_format_offset = 4;

  hdr2_block_length_offset = 5;
  hdr2_block_length_size = 5;

  hdr2_record_length_offset = 10;
  hdr2_record_length_size = 5;

  hdr2_buffer_offset = 50;
  hdr2_buffer_offset_size = 2;


(* The entire HDR2 label description, for information only;		*)
(* ALL LABELS USE LABEL_IN_BYTES for manipulating data, (see above).	*)
"type
  hdr2_label = record
    label_id		: array [0..3] of char	(* HDR2_ID *);
    record_format	: char			(* HDR2_FORMAT *);
    block_length	: array [0..4] of char	(* max. block length *);
    record_length	: array [0..4] of char	(* record length *);
    reserved1		: array [0..34] of char	(* ' ' *);
    buffer_offset	: array [0..1] of char	(* 00 *);
    reserved2		: array [0..27] of char	(* ' ' *)
  end (* hdr2_label *);"
!
(************************************************************************)
(*                                                                      *)
(* End-of-file label definitions for ANSII Magnetic tape standard.	*)
(* EOF1 fields are the same as corresponding fields in the first file	*)
(* header EXCEPT for the id and block_count.				*)
(*                                                                      *)
(************************************************************************)

const 
  eof1_id = 'EOF1\ ';
!
(****************************************************************)
(*								*)
(*	Files which use the blocking factor to write to tape	*)
(*	(CUD, OPERLOG and, if REUSE_UUNS is enabled, the CUD	*)
(*	PARAMETER file) use the following data structures:	*)
(*								*)
(****************************************************************)


(****************************************************************)
(*								*)
(*	The CUD tape block is composed of CUD blocks and 	*)
(*	their block number; the other files use tape blocks	*)
(*	which are composed of page numbers and page data	*)
(*								*)
(****************************************************************)

const
  (* Size of one CUD tape block in bytes: *)

  TAPE_CUD_BLOCK_SIZE = (MAXIMUM_CUD_BLOCK_SIZE + 4) * TAPE_BLOCKING_FACTOR;
  TAPE_CUD_BLOCK_BYTE_LIMIT = TAPE_CUD_BLOCK_SIZE - 1;

  TAPE_CUD_BLOCK_LIMIT = tape_blocking_factor - 1;

type
  TAPE_CUD_BLOCK_IN_BYTES = array [0..TAPE_CUD_BLOCK_BYTE_LIMIT] of char;
  TAPE_CUD_BLOCK_INDEX = 0..tape_cud_block_limit;
  
  TAPE_CUD_RECORD = record
    block	: cud_block_index;
    cud_data	: cud_disk_block
  end (* tape_cud_record *);

  TAPE_CUD_BLOCK = array [tape_cud_block_index] of tape_cud_record;


const
  (* The TAPE_PAGE_BLOCK and the TAPE_CUD_BLOCK are approximately the	*)
  (* same size, but the factored_tape_page_block will be		*)
  (* MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS - 1 * tape_blocking_factor	*)
  (* words larger.							*)

  TAPE_PAGE_BLOCKING_FACTOR =
    MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS * TAPE_BLOCKING_FACTOR;
    
  (* Size of one factored tape page block in bytes *)
  TAPE_PAGE_BLOCK_SIZE =  (page_size + 4) * tape_page_blocking_factor;
  TAPE_PAGE_BLOCK_BYTE_LIMIT =  TAPE_PAGE_BLOCK_SIZE - 1;

  TAPE_PAGE_BLOCK_LIMIT = tape_page_blocking_factor - 1;

type
  TAPE_PAGE_BLOCK_IN_BYTES = array [0..TAPE_PAGE_BLOCK_BYTE_LIMIT] of char;
  TAPE_PAGE_BLOCK_INDEX = 0..tape_page_block_limit;

  (* Used by OPERLOG and, if REUSE_UUNS is enabled, CUD_PARAMETER file *)

  TAPE_PAGE_RECORD = record
    page_offset	: integer;
    page_data	: page_record
  end (* tape_page_record *);

  TAPE_PAGE_BLOCK = array [tape_page_block_index] of tape_page_record;
    
  BLOCKED_PAGE_CHECKSUMS = array [tape_page_block_index] of boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	The following constants and types are used by the dump tape	*)
(*	command if INCLUDE_DUMP is enabled.				*)
(*									*)
(************************************************************************)

const
(* DUMP tape record size is string size of ascii formatted CUD data *)
(* Formatted data is half the size of format buffer text *)

  ASCII_DUMP_DATA_SIZE = 80;

(* Chars in min pages per block of 80 byte ascii strings, total 1280 bytes *)
  ASCII_DUMP_CHARS_IN_PAGES = ascii_dump_data_size * 16;

(* the constant value of an ascii block size in bytes *)
  ASCII_DUMP_BLOCK_SIZE = ascii_dump_blocking_factor *
    ascii_dump_chars_in_pages;
  ASCII_DUMP_BLOCK_BYTE_LIMIT = ascii_dump_block_size - 1;

  ASCII_DUMP_BLOCK_STRING_LIMIT = (ascii_dump_block_size
    div format_buffer_text_max) - 1;

type
  ASCII_DUMP_BLOCK_IN_BYTES = array [0..ascii_dump_block_byte_limit] of char;
  ASCII_DUMP_TAPE_BLOCK_INDEX = 0..ascii_dump_block_string_limit;
  ASCII_DUMP_TAPE_BLOCK = array [ascii_dump_tape_block_index]
    of format_buffer_text;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	The tape_named_list_definition record, used for hostlists	*)
(*	and nodelists.  Empty lists are not stored.  Lists are		*)
(*	uniquely identified by their list_descriptor.			*)
(*									*)
(************************************************************************)
(*									*)
(*	the maximum size of tape_named_list_definition is the size of:	*)
(*	    list_ptr (4)						*)
(*	    named_list (MAXIMUM_BYTES_IN_NAMED_LIST)			*)
(*									*)
(************************************************************************)

const
  TAPE_NAMED_LIST_DEFINITION_SIZE = maximum_bytes_in_named_list + 4;
  TAPE_NAMED_LIST_DEFINITION_LIMIT = TAPE_NAMED_LIST_DEFINITION_SIZE - 1;

type
  TAPE_NAMED_LIST_DEFINITION_IN_BYTES =
    array [0..TAPE_NAMED_LIST_DEFINITION_LIMIT] of char;
  TAPE_NAMED_LIST_DEFINITION = record
    list_ptr	: list_index;
    named_list	: named_list_definition
  end (* tape_named_list_definition *);
!
(************************************************************************)
(*									*)
(*	The tape_global_access_definition record, used for classes and	*)
(*	groups.  Undefined global accesses are not stored.		*)
(*									*)
(************************************************************************)
(*									*)
(*	the size of tape_global_access_definition is the size of:	*)
(*	    global value (4) 						*)
(*	    global_access_descriptor					*)
(*		(MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION)		*)
(*									*)
(************************************************************************)

const
  MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE =
    MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION + 4;
  TAPE_GLOBAL_ACCESS_DEFINITION_SIZE_LIMIT =
    MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE - 1;

type
  TAPE_GLOBAL_ACCESS_DEFINITION_IN_BYTES =
   array [0..TAPE_GLOBAL_ACCESS_DEFINITION_SIZE_LIMIT] of char;
  TAPE_GLOBAL_ACCESS_DEFINITION = record
    global_value	: integer;
    global_access	: global_access_description
  end (* tape_global_access_definition *);

!
(************************************************************************)
(*									*)
(*	The tape_mudupd_header_definition				*)
(*									*)
(************************************************************************)

const
  MAXIMUM_TAPE_MUDUPD_HEADER_SIZE = page_size + 4;
  TAPE_MUDUPD_HEADER_SIZE_LIMIT = MAXIMUM_TAPE_MUDUPD_HEADER_SIZE - 1;

type
  TAPE_MUDUPD_HEADER_IN_BYTES =
    array [0..TAPE_MUDUPD_HEADER_SIZE_LIMIT] of char;

  TAPE_MUDUPD_HEADER_DEFINITION = record
    mudupd_info	: mudupd_disk_header;
    checksum	: integer
  end (* tape_mudupd_header_definition *);

!
(************************************************************************)
(*									*)
(*	CMDDEF.NTV							*)
(*									*)
(*	Constants and global types for commands.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	02Sep86 - neh							*)
(*	      - Change GLOBAL_MESSAGE to PRIMARY_MESSAGE to make	*)
(*		MESSAGE_COMMAND a primary command.			*)
(*	      - Change GLOBAL_MESSAGE_KEYWORD_OFFSETs to		*)
(*		PRIMARY_MESSAGE_KEYWORD_OFFSETs.			*)
(*	      - Add PRIMARY_DISPLAY_FILTER_KEYWORD_OFFSET and		*)
(*		PRIMARY_FILTER_KEYWORD_OFFSET.				*)
(*	14Aug86 - jrn							*)
(*	      - add DELETE CLASS, DELETE GROUP for clearing classes	*)
(*		and groups after a configuration change			*)
(*	08Jul86 - jrn							*)
(*	      - add REMARK command					*)
(*	      - add SPECIAL flag (CLEAN and OLDPASS commands)		*)
(*	06Aug86 - jrn							*)
(*	      - add GFDONLY to SELECT PASSWORDDATE command		*)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGES FROM command to NVDM			*)
(*	13May86 - neh							*)
(*	      - if INCLUDE_DUMP add ARCHIVE_DUMP to archive commands	*)
(*		and PARAMETERS keyword to NETVAL archive command	*)
(*	30Apr86 - jrn							*)
(*	      - remove RESET command					*)
(*	28Apr86 - jrn							*)
(*	      - make REGENERATE PARAMETERS and RECOLLECT commands	*)
(*		restartable at a CUD block				*)
(*	24Apr86 - jrn							*)
(*	      - if REUSE_UUNS, add PARAMETERS keyword to NVDM		*)
(*		CHECK command						*)
(*	15Apr86 - jrn							*)
(*	      - add ADDBACK keyword to the INITIALIZE PARAMETERS	*)
(*		command							*)
(*	      - add ADDBACK keyword to the REGENERATE PARAMETERS	*)
(*		command							*)
(*	      - change DISPLAY NEXT to DISPLAY PARAMETERS		*)
(*	08Mar86 - jrn							*)
(*	      - add COPY command to Tymnet's NVDM			*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - add APPEND keyword to REGENERATE command, and		*)
(*		add RECOLLECT command					*)
(*	22Jan86 - jrn							*)
(*	      - change the UP and SHUT commands to HOST UP and HOST	*)
(*		SHUT, and add the HOST STATUS command			*)
(*	      - remove abbreviations and sizes in command and keyword	*)
(*	        definitions (handle in code)				*)
(*	14Jan85 -  jrn							*)
(*	      - change DISPLAY LVOL to DISPLAY VOLUME for both Netval	*)
(*		and NVDM						*)
(*	20Dec85 - jrn							*)
(*	      - add the FROM SUPERVISOR keywords to the			*)
(*		WRITE CUD command					*)
(*	01Nov85 - jrn							*)
(*	      - add the REPEAT keyword for DISPLAY UPDATES, and the	*)
(*		SHUT and UP commands; increase COMMAND_KEYWORD_MAX	*)
(*		to 25							*)
(*	07Oct85 - jrn							*)
(*	      - add the X25 keyword for the NEW USER command if		*)
(*		VALIDATE_X25_NAMES is enabled				*)
(*	17Jul85 - jrn							*)
(*	     - add NVDM COMPARE command					*)
(*	09Jan85 - jrn							*)
(*	      - remove UNIT keyword from Archive commands		*)
(*	08Jan85 - jrn							*)
(*	      - use INCLUDE_LIST_DESCRIPTIONS				*)
(*	14Dec84 - pgl							*)
(*	      - if logical_volumes, keywords for COPY, DISPLAY LVOL,	*)
(*		and SET DRIVE OFFLINE commands				*)
(*	24Jul84 - jrn							*)
(*	      - added PRIMARY_CHANGE_LIST_DESCRIPTION_KEYWORD		*)
(*	08Jun84 Version 2.02	jrn - pgl				*)
(*	      - added code for NVDM					*)
(*	      - added FROM keyword to CONSISTENCY			*)
(*	      - removed DISPLAY SCHEDULE and DISPLY SUPERVISORS commands*)
(*	      - added SELECT, DISPLAY DIRECTORY and DISPLAY SELECT	*)
(*		commands						*)
(*	      - added CHANGE UUN command				*)
(*	      - changed required_level to required_license		*)
(*	14Mar84	Version 2.01	jrn					*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*	29SEP83  original from (PATROL)cmddef.bas - jrn		        *)
(*									*)
(************************************************************************)


(* constants dealing with input errors *)

type
  COMMAND_SCAN_STATE = (
    CMD_OK, RUN_ERROR, NO_CMD, SUBCOMMAND_MISSING,
    CMD_ERROR, ILLEGAL_CHAR, DUPLICATE_KEYWORDS, BREAK_ERROR,
    INV_KEYWORD, AUTH_ERROR, ARG_ERROR, ARG_MISSING,
    TOO_MANY_ARGS, ARG_TOO_MANY_CHARS, ARG_NUMBER_OUT_OF_BOUNDS,
    ARG_FREEWORD_MISSING);



type
  COMMAND_CLASS_INDEX = (
    START_OF_COMMAND_CLASSES,
      ARCHIVE_CLASS   (* Archive Sub-system commands *),
      PRIMARY_CLASS   (* Non-global system level commands *),
      GLOBAL_CLASS    (* Global system level commands *),
    END_OF_COMMAND_CLASSES);

(* Context switching definitions *)

type
  CONTEXT_SET = set of command_class_index;
!
(* List of internal identifiers for all commands in the system.  These  *)
(* commands will be distributed in various arrays according to what	*)
(* command class they belong to.					*)

type
  COMMAND_INDEX = (
    START_OF_COMMANDS,

(* Global commands may be executed from anywhere: *)

      START_GLOBAL_COMMANDS,
        GLOBAL_DATE     (* current time and date in GMT *),
  	GLOBAL_HELP	(* help as best you can *),
	GLOBAL_STATISTICS (* print disk stats *),
	GLOBAL_VERSION	(* display version and revision number *),
      END_GLOBAL_COMMANDS,

(* ARCHIVE commands  *)

      START_ARCHIVE_COMMANDS,
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        ARCHIVE_ASSIGN   (* reserve tape unit for validator *),
	ARCHIVE_ATTACH	 (* reserve tape unit for NETVAL slot *),
	ARCHIVE_DEASSIGN (* free tape unit from validator *),
	ARCHIVE_DETACH	 (* free tape unit from slot *),
	ARCHIVE_DISPLAY	 (* type type id *),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
ARCHIVE_DUMP  (* dump CUD to tape in ascii format *),
	ARCHIVE_RETURN	 (* return to system command level *),
	ARCHIVE_REWIND	 (* return mag tape to beginning *),
	ARCHIVE_STORE	 (* copy files form disk to tape *),
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      END_ARCHIVE_COMMANDS,

(* Primary commands  *)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      START_PRIMARY_COMMANDS,
	PRIMARY_ARCHIVE		(* enter ARCHIVE sub-system *),
	PRIMARY_CHANGE		(* change a validation value *),
	PRIMARY_CHECK		(* check on existence of a user name *),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PRIMARY_CLEAR		(* turn off automatic consistency *),
	PRIMARY_COMPARE		(* compare CUD and MUD buffer *),
	PRIMARY_CONSISTENCY	(* perform manual consistency *),
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PRIMARY_DELETE		(* delete a validation value *),
	PRIMARY_DISPLAY		(* display a validation value *),
	PRIMARY_FILTER		(* filter out operator log messages *),
	PRIMARY_GET		(* type block number for a user *),
	PRIMARY_HOST		(* retrieve or set host information *),
	PRIMARY_MESSAGE		(* list operator log *),
	PRIMARY_NEW		(* add a validation value *),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PRIMARY_QUIT	 	(* leave system *),
	PRIMARY_READ		(* read a validation value *),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PRIMARY_REMARK		(* append a remark to the oper log *),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PRIMARY_SELECT		(* choose users to be displayed *),
	PRIMARY_SEND		(* send Sup Class/group table *),
	PRIMARY_SET		(* set up schedule or legal Supervisors *),
	PRIMARY_STOP		(* halt a running consistency *),
	PRIMARY_UNLOCK		(* unlock a locked CUD block *),
	PRIMARY_WRITE		(* write a CUD/MUD block *),
      END_PRIMARY_COMMANDS,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


  END_OF_COMMANDS);

type
  GLOBAL_COMMAND_INDEX =
    start_global_commands .. end_global_commands;

  ARCHIVE_COMMAND_INDEX =
    start_archive_commands .. end_archive_commands;

  PRIMARY_COMMAND_INDEX =
    start_primary_commands .. end_primary_commands;
!
(*	The keyword index for GLOBAL commands.				*)

const
  GLOBAL_OFFSET = 0;

  GLOBAL_DATE_KEYWORD_OFFSET = global_offset;
  GLOBAL_DATE_KEYWORD_MAX = 0;
  GLOBAL_DATE_SUBCOMMAND_MAX = 0;

  GLOBAL_HELP_KEYWORD_OFFSET =
    global_date_keyword_offset + global_date_keyword_max;
  GLOBAL_HELP_KEYWORD_MAX = 0;
  GLOBAL_HELP_SUBCOMMAND_MAX = 0;

  GLOBAL_STATISTICS_KEYWORD_OFFSET =
    global_help_keyword_offset + global_help_keyword_max;
  GLOBAL_STATISTICS_KEYWORD_MAX = 0;
  GLOBAL_STATISTICS_SUBCOMMAND_MAX = 0;

  GLOBAL_VERSION_KEYWORD_OFFSET =
    global_statistics_keyword_offset + global_statistics_keyword_max;
  GLOBAL_VERSION_KEYWORD_MAX = 0;
  GLOBAL_VERSION_SUBCOMMAND_MAX = 0;


  GLOBAL_KEYWORD_MAX =
    global_version_keyword_offset + global_version_keyword_max - global_offset;
!
(*	The keyword index for ARCHIVE commands.			*)

const
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ARCHIVE_OFFSET = global_offset + global_keyword_max;

  ARCHIVE_ASSIGN_KEYWORD_OFFSET = archive_offset;
  ARCHIVE_ASSIGN_KEYWORD_MAX = 0;
  ARCHIVE_ASSIGN_SUBCOMMAND_MAX = 0;

  ARCHIVE_ATTACH_KEYWORD_OFFSET =
    archive_assign_keyword_offset + archive_assign_keyword_max;
  ARCHIVE_ATTACH_KEYWORD_MAX = 0;
  ARCHIVE_ATTACH_SUBCOMMAND_MAX = 0;

  ARCHIVE_DEASSIGN_KEYWORD_OFFSET =
    archive_attach_keyword_offset + archive_attach_keyword_max;
  ARCHIVE_DEASSIGN_KEYWORD_MAX = 0;
  ARCHIVE_DEASSIGN_SUBCOMMAND_MAX = 0;

  ARCHIVE_DETACH_KEYWORD_OFFSET =
    archive_deassign_keyword_offset + archive_deassign_keyword_max;
  ARCHIVE_DETACH_KEYWORD_MAX = 0;
  ARCHIVE_DETACH_SUBCOMMAND_MAX = 0;

  ARCHIVE_DISPLAY_KEYWORD_OFFSET =
    archive_deassign_keyword_offset + archive_deassign_keyword_max;
  ARCHIVE_DISPLAY_ID_KEYWORD = 0;
  ARCHIVE_DISPLAY_STATUS_KEYWORD = archive_display_id_keyword + 1;
  ARCHIVE_DISPLAY_KEYWORD_MAX = 2;
  ARCHIVE_DISPLAY_SUBCOMMAND_MAX = 2;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ARCHIVE_DUMP_KEYWORD_OFFSET =
    archive_display_keyword_offset + archive_display_keyword_max;
  ARCHIVE_DUMP_FROM_KEYWORD = 0;
  ARCHIVE_DUMP_KEYWORD_MAX = 1;
  ARCHIVE_DUMP_SUBCOMMAND_MAX = 0;

  ARCHIVE_RETURN_KEYWORD_OFFSET =
    archive_dump_keyword_offset +  archive_dump_keyword_max;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ARCHIVE_RETURN_KEYWORD_MAX = 0;
  ARCHIVE_RETURN_SUBCOMMAND_MAX = 0;

  ARCHIVE_REWIND_KEYWORD_OFFSET =
    archive_return_keyword_offset + archive_return_keyword_max;
  ARCHIVE_REWIND_KEYWORD_MAX = 0;
  ARCHIVE_REWIND_SUBCOMMAND_MAX = 0;

  ARCHIVE_STORE_KEYWORD_OFFSET =
    archive_rewind_keyword_offset + archive_rewind_keyword_max;
  ARCHIVE_STORE_KEYWORD_MAX = 0;
  ARCHIVE_STORE_SUBCOMMAND_MAX = 0;

  ARCHIVE_KEYWORD_MAX =
    archive_return_keyword_offset + archive_return_keyword_max-archive_offset;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(* The keyword index for primary commands. *)

const
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_OFFSET = archive_offset + archive_keyword_max;

  PRIMARY_ARCHIVE_KEYWORD_OFFSET = primary_offset;
  PRIMARY_ARCHIVE_KEYWORD_MAX = 0;
  PRIMARY_ARCHIVE_SUBCOMMAND_MAX = 0;

  PRIMARY_CHANGE_KEYWORD_OFFSET =
    primary_archive_keyword_offset + primary_archive_keyword_max;
  PRIMARY_CHANGE_ACCESS_KEYWORD = 0;
  PRIMARY_CHANGE_CLASS_KEYWORD = primary_change_access_keyword + 1;
  PRIMARY_CHANGE_CONTROL_KEYWORD = primary_change_class_keyword + 1;
  PRIMARY_CHANGE_CUD_KEYWORD = primary_change_control_keyword + 1;
  PRIMARY_CHANGE_DISTRICT_KEYWORD = primary_change_cud_keyword + 1;
  PRIMARY_CHANGE_GAN_KEYWORD = primary_change_district_keyword + 1;
  PRIMARY_CHANGE_GROUP_KEYWORD = primary_change_gan_keyword + 1;
  PRIMARY_CHANGE_HOSTLIST_KEYWORD = primary_change_group_keyword + 1;
  PRIMARY_CHANGE_NAME_KEYWORD = primary_change_hostlist_keyword + 1;
  PRIMARY_CHANGE_NODELIST_KEYWORD = primary_change_name_keyword + 1;
  PRIMARY_CHANGE_PASSWORD_KEYWORD = primary_change_nodelist_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_CHANGE_OFFSET_KEYWORD = primary_change_password_keyword + 1;
  PRIMARY_CHANGE_KEYWORD_MAX = 12;
  PRIMARY_CHANGE_SUBCOMMAND_MAX = 11;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  PRIMARY_CHECK_KEYWORD_OFFSET =
    primary_change_keyword_offset + primary_change_keyword_max;
  PRIMARY_CHECK_KEYWORD_MAX = 0;
  PRIMARY_CHECK_SUBCOMMAND_MAX = 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  PRIMARY_CLEAR_KEYWORD_OFFSET =
    primary_check_keyword_offset + primary_check_keyword_max;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_CLEAR_KEYWORD_MAX = 0;
  PRIMARY_CLEAR_SUBCOMMAND_MAX = 0;

  PRIMARY_COMPARE_KEYWORD_OFFSET =
    primary_clear_keyword_offset + primary_clear_keyword_max;
  PRIMARY_COMPARE_KEYWORD_MAX = 0;
  PRIMARY_COMPARE_SUBCOMMAND_MAX = 0;

  PRIMARY_CONSISTENCY_KEYWORD_OFFSET =
    primary_compare_keyword_offset + primary_compare_keyword_max;
  PRIMARY_CONSISTENCY_NOCHANGE_KEYWORD = 0;
  PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD =
    primary_consistency_nochange_keyword + 1;
  PRIMARY_CONSISTENCY_FROM_KEYWORD =
    primary_consistency_supervisor_keyword + 1;
  PRIMARY_CONSISTENCY_KEYWORD_MAX = 3;
  PRIMARY_CONSISTENCY_SUBCOMMAND_MAX = 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  PRIMARY_DELETE_KEYWORD_OFFSET =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    primary_consistency_keyword_offset + primary_consistency_keyword_max;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_DELETE_ACCESS_KEYWORD = 0;
  PRIMARY_DELETE_CLASS_KEYWORD = primary_delete_access_keyword + 1;
  PRIMARY_DELETE_GROUP_KEYWORD = primary_delete_class_keyword + 1;
  PRIMARY_DELETE_HOSTLIST_KEYWORD = primary_delete_group_keyword + 1;
  PRIMARY_DELETE_NODELIST_KEYWORD = primary_delete_hostlist_keyword + 1;
  PRIMARY_DELETE_USER_KEYWORD = primary_delete_nodelist_keyword + 1;
  PRIMARY_DELETE_KEYWORD_MAX = 6;
  PRIMARY_DELETE_SUBCOMMAND_MAX = 6;

  PRIMARY_DISPLAY_KEYWORD_OFFSET =
    primary_delete_keyword_offset + primary_delete_keyword_max;
  PRIMARY_DISPLAY_CLASS_KEYWORD = 0;
  PRIMARY_DISPLAY_CUD_KEYWORD = primary_display_class_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_KEYWORD = primary_display_cud_keyword + 1;
  PRIMARY_DISPLAY_FILTER_KEYWORD = primary_display_directory_keyword + 1;
  PRIMARY_DISPLAY_GROUP_KEYWORD = primary_display_filter_keyword + 1;
  PRIMARY_DISPLAY_HOSTLIST_KEYWORD = primary_display_group_keyword + 1;
  PRIMARY_DISPLAY_MUD_KEYWORD = primary_display_hostlist_keyword + 1;
  PRIMARY_DISPLAY_NODELIST_KEYWORD = primary_display_mud_keyword + 1;
  PRIMARY_DISPLAY_PARAMETERS_KEYWORD = primary_display_nodelist_keyword + 1;
  PRIMARY_DISPLAY_SELECT_KEYWORD = primary_display_parameters_keyword + 1;
  PRIMARY_DISPLAY_UPDATES_KEYWORD = primary_display_select_keyword + 1;
  PRIMARY_DISPLAY_USER_KEYWORD = primary_display_updates_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_DISPLAY_CUD_ALL_KEYWORD =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        primary_display_user_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_DISPLAY_CUD_FORMATTED_KEYWORD = primary_display_cud_all_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_DISPLAY_LIST_NAMES_KEYWORD =
    primary_display_cud_formatted_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* keywords associated with the display_directory keyword *)
  PRIMARY_DISPLAY_DIRECTORY_UUN_KEYWORD = 
    primary_display_list_names_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_GAN_KEYWORD = 
    primary_display_directory_uun_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_DISTRICT_KEYWORD = 
    primary_display_directory_gan_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_CONTROL_KEYWORD = 
    primary_display_directory_district_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_PASSWORDDATE_KEYWORD =
    primary_display_directory_control_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_ENTRYDATE_KEYWORD = 
    primary_display_directory_passworddate_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_ACCESS_KEYWORD =
    primary_display_directory_entrydate_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD = 
    primary_display_directory_access_keyword + 1;
  PRIMARY_DISPLAY_UPDATES_REPEAT_KEYWORD =
    primary_display_directory_lines_keyword + 1;
(* 	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 PRIMARY_DISPLAY_KEYWORD_MAX = 24;
  PRIMARY_DISPLAY_SUBCOMMAND_MAX = 12;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(* PRIMARY_FILTER_KEYWORD_OFFSETS for all FILTER keywords *)
  PRIMARY_FILTER_KEYWORD_OFFSET =
    primary_display_keyword_offset + primary_display_keyword_max;
  PRIMARY_FILTER_ALL_KEYWORD = 0;
  PRIMARY_FILTER_ARCHIVE_KEYWORD = primary_filter_all_keyword + 1;
  PRIMARY_FILTER_CONSISTENCY_KEYWORD = primary_filter_archive_keyword + 1;
  PRIMARY_FILTER_CUDERROR_KEYWORD = primary_filter_consistency_keyword + 1;
  PRIMARY_FILTER_DEBUG_KEYWORD = primary_filter_cuderror_keyword + 1;
  PRIMARY_FILTER_FILE_KEYWORD = primary_filter_debug_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_FILTER_MODIFY_KEYWORD
= primary_filter_file_keyword + 1;
  PRIMARY_FILTER_MUDUPDATE_KEYWORD =
primary_filter_modify_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_FILTER_OPERATOR_KEYWORD = primary_filter_mudupdate_keyword + 1;
  PRIMARY_FILTER_PARAMETER_KEYWORD = primary_filter_operator_keyword + 1;
  PRIMARY_FILTER_SUPERVISOR_KEYWORD = primary_filter_parameter_keyword  + 1;
  PRIMARY_FILTER_SYSMSG1_KEYWORD = primary_filter_supervisor_keyword + 1;
  PRIMARY_FILTER_UN2_KEYWORD = primary_filter_sysmsg1_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_FILTER_VALIDATOR_KEYWORD =
primary_filter_un2_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
primary_filter_validator_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_FILTER_VALIDATOR_USER_KEYWORD =
    primary_filter_validator_number_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD =
    primary_filter_validator_user_keyword + 1;
  PRIMARY_FILTER_MODIFY_CONTROL_KEYWORD =
    primary_filter_modify_access_keyword + 1;
  PRIMARY_FILTER_MODIFY_DISTRICT_KEYWORD =
    primary_filter_modify_control_keyword + 1;
  PRIMARY_FILTER_MODIFY_GAN_KEYWORD =
    primary_filter_modify_district_keyword + 1;
  PRIMARY_FILTER_MODIFY_NAME_KEYWORD =
    primary_filter_modify_gan_keyword + 1;
  
  PRIMARY_FILTER_MODIFY_PASSWORD_KEYWORD =
    primary_filter_modify_name_keyword + 1;
  PRIMARY_FILTER_MODIFY_UUN_KEYWORD =
    primary_filter_modify_password_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_FILTER_MODIFY_DELETE_KEYWORD =
primary_filter_modify_uun_keyword + 1;
  PRIMARY_FILTER_MODIFY_NEW_KEYWORD = primary_filter_modify_delete_keyword + 1;
  PRIMARY_FILTER_KEYWORD_MAX = 15
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
+ 10
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;
PRIMARY_FILTER_SUBCOMMAND_MAX = 0;

  PRIMARY_GET_KEYWORD_OFFSET =
    primary_filter_keyword_offset + primary_filter_keyword_max;
  PRIMARY_GET_KEYWORD_MAX = 0;
  PRIMARY_GET_SUBCOMMAND_MAX = 0;

  PRIMARY_HOST_KEYWORD_OFFSET =
    primary_get_keyword_offset + primary_get_keyword_max;
  PRIMARY_HOST_SHUT_KEYWORD = 0;
  PRIMARY_HOST_STATUS_KEYWORD = primary_host_shut_keyword + 1;
  PRIMARY_HOST_UP_KEYWORD = primary_host_status_keyword + 1;
  PRIMARY_HOST_KEYWORD_MAX = 3;
  PRIMARY_HOST_SUBCOMMAND_MAX = 3;

  PRIMARY_MESSAGE_KEYWORD_OFFSET =
   primary_host_keyword_offset + primary_host_keyword_max;
  PRIMARY_MESSAGE_FROM_KEYWORD = 0;
  PRIMARY_MESSAGE_KEYWORD_MAX = 1;
  PRIMARY_MESSAGE_SUBCOMMAND_MAX = 0;

  PRIMARY_NEW_KEYWORD_OFFSET =
    primary_message_keyword_offset + primary_message_keyword_max;
  PRIMARY_NEW_ACCESS_KEYWORD = 0;
  PRIMARY_NEW_HOSTLIST_KEYWORD = primary_new_access_keyword + 1;
  PRIMARY_NEW_NODELIST_KEYWORD = primary_new_hostlist_keyword + 1;
  PRIMARY_NEW_USER_KEYWORD = primary_new_nodelist_keyword + 1;
  PRIMARY_NEW_USER_AS_KEYWORD = primary_new_user_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_NEW_KEYWORD_MAX = 5;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_NEW_SUBCOMMAND_MAX = 4;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  PRIMARY_QUIT_KEYWORD_OFFSET =
    primary_new_keyword_offset + primary_new_keyword_max;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_QUIT_KEYWORD_MAX = 0;
  PRIMARY_QUIT_SUBCOMMAND_MAX = 0;

  PRIMARY_READ_KEYWORD_OFFSET =
    primary_quit_keyword_offset + primary_quit_keyword_max;
  PRIMARY_READ_CUD_KEYWORD = 0;
  PRIMARY_READ_MUD_KEYWORD = primary_read_cud_keyword + 1;
  PRIMARY_READ_TABLE_KEYWORD = primary_read_mud_keyword + 1;
  PRIMARY_READ_BLOCK_KEYWORD = primary_read_table_keyword + 1;
  PRIMARY_READ_LOCK_KEYWORD = primary_read_block_keyword + 1;
  PRIMARY_READ_TABLE_SUPERVISOR_KEYWORD = primary_read_lock_keyword + 1;
  PRIMARY_READ_TABLE_CLASS_KEYWORD = primary_read_table_supervisor_keyword + 1;
  PRIMARY_READ_TABLE_GROUP_KEYWORD = primary_read_table_class_keyword + 1;
  PRIMARY_READ_KEYWORD_MAX = 8;
  PRIMARY_READ_SUBCOMMAND_MAX = 3;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 
  PRIMARY_REMARK_KEYWORD_OFFSET =
    primary_read_keyword_offset + primary_read_keyword_max;
  PRIMARY_REMARK_KEYWORD_MAX = 0;
  PRIMARY_REMARK_SUBCOMMAND_MAX = 0;

  PRIMARY_SELECT_KEYWORD_OFFSET =
    primary_remark_keyword_offset + primary_remark_keyword_max;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_SELECT_ALL_KEYWORD = 0;
  PRIMARY_SELECT_ACCESS_KEYWORD = primary_select_all_keyword + 1;
  PRIMARY_SELECT_GAN_KEYWORD = primary_select_access_keyword + 1;
  PRIMARY_SELECT_DISTRICT_KEYWORD = primary_select_gan_keyword + 1;
  PRIMARY_SELECT_UUN_KEYWORD = primary_select_district_keyword + 1;
  PRIMARY_SELECT_CONTROL_KEYWORD = primary_select_uun_keyword + 1;
  PRIMARY_SELECT_ENTRYDATE_KEYWORD = primary_select_control_keyword + 1;
  PRIMARY_SELECT_PASSWORDDATE_KEYWORD = primary_select_entrydate_keyword + 1;
(* keywords associated with the select_access *)
  PRIMARY_SELECT_CLASS_ACCESS_KEYWORD = 
    primary_select_passworddate_keyword + 1;
  PRIMARY_SELECT_GROUP_ACCESS_KEYWORD = 
    primary_select_class_access_keyword + 1;
  PRIMARY_SELECT_HOST_ACCESS_KEYWORD = primary_select_group_access_keyword + 1;
  PRIMARY_SELECT_NODE_ACCESS_KEYWORD = primary_select_host_access_keyword + 1;
(* keywords associated with select_passworddate and select_entrydate *)
  PRIMARY_SELECT_AFTER_DATE_KEYWORD =
    primary_select_node_access_keyword + 1;
  PRIMARY_SELECT_BEFORE_DATE_KEYWORD =
    primary_select_after_date_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* keywords associated with the select_control *)
  PRIMARY_SELECT_CONTROL_LICENSED_KEYWORD =
    primary_select_before_date_keyword + 1;  
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_SELECT_CONTROL_PASSWORD_ONLY_KEYWORD = 
    primary_select_control_licensed_keyword + 1;
  PRIMARY_SELECT_CONTROL_ACCOUNT_SUPERVISOR_KEYWORD =
    primary_select_control_password_only_keyword + 1;
  PRIMARY_SELECT_CONTROL_IGNORE_HOST_KEYWORD = 
    primary_select_control_account_supervisor_keyword + 1;
  PRIMARY_SELECT_CONTROL_NETWORK_ADMINISTRATOR_KEYWORD = 
    primary_select_control_ignore_host_keyword + 1;
  PRIMARY_SELECT_CONTROL_NO_PASSWORD_KEYWORD = 
    primary_select_control_network_administrator_keyword + 1;
  PRIMARY_SELECT_CONTROL_SHUT_OVERRIDE_KEYWORD =
    primary_select_control_no_password_keyword + 1;
  PRIMARY_SELECT_CONTROL_AUDITOR_KEYWORD =
    primary_select_control_shut_override_keyword + 1;
  PRIMARY_SELECT_CONTROL_OPERATOR_KEYWORD =
    primary_select_control_auditor_keyword + 1;
  PRIMARY_SELECT_CONTROL_TRANSPARENT_LOGIN_KEYWORD = 
    primary_select_control_operator_keyword + 1;
  PRIMARY_SELECT_KEYWORD_MAX = 24;
  PRIMARY_SELECT_SUBCOMMAND_MAX = 0;

  PRIMARY_SEND_KEYWORD_OFFSET =
    primary_select_keyword_offset + primary_select_keyword_max;
  PRIMARY_SEND_WAIT_KEYWORD = 0;
  PRIMARY_SEND_KEYWORD_MAX = 1;
  PRIMARY_SEND_SUBCOMMAND_MAX = 0;

  PRIMARY_SET_KEYWORD_OFFSET =
    primary_send_keyword_offset + primary_send_keyword_max;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_SET_SCHEDULE_KEYWORD = 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_SET_SUPERVISOR_KEYWORD = primary_set_schedule_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_SET_SUPERVISOR_ON_KEYWORD = primary_set_supervisor_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_SET_SUPERVISOR_OFF_KEYWORD = primary_set_supervisor_on_keyword + 1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_SET_KEYWORD_MAX = 4;
  PRIMARY_SET_SUBCOMMAND_MAX = 2;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  PRIMARY_STOP_KEYWORD_OFFSET =
    primary_set_keyword_offset + primary_set_keyword_max;
  PRIMARY_STOP_SUPERVISOR_KEYWORD = 0;
  PRIMARY_STOP_KEYWORD_MAX = 1;
  PRIMARY_STOP_SUBCOMMAND_MAX = 0;

  PRIMARY_UNLOCK_KEYWORD_OFFSET =
    primary_stop_keyword_offset + primary_stop_keyword_max;
  PRIMARY_UNLOCK_KEYWORD_MAX = 0;
  PRIMARY_UNLOCK_SUBCOMMAND_MAX = 0;

  PRIMARY_WRITE_KEYWORD_OFFSET =
    primary_unlock_keyword_offset + primary_unlock_keyword_max;
  PRIMARY_WRITE_CUD_KEYWORD = 0;
  PRIMARY_WRITE_MUD_KEYWORD = primary_write_cud_keyword + 1;
  PRIMARY_WRITE_CUD_FROM_KEYWORD = primary_write_mud_keyword + 1;
  PRIMARY_WRITE_CUD_FROM_SUPERVISOR_KEYWORD =
    primary_write_cud_from_keyword + 1;
  PRIMARY_WRITE_KEYWORD_MAX = 4;
  PRIMARY_WRITE_SUBCOMMAND_MAX = 2;

  PRIMARY_KEYWORD_MAX =
    primary_write_keyword_offset + primary_write_keyword_max - primary_offset;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	The following keywords are referred to only	*)
(*	by tokenized lines, not by a command line.	*)

const
  LINE_OFFSET = primary_offset + primary_keyword_max;

  LINE_KEYWORD_OFFSET = line_offset;

  LINE_YES_KEYWORD = 0;
  LINE_NO_KEYWORD = line_yes_keyword + 1;
  LINE_NODE_KEYWORD = line_no_keyword + 1;
  LINE_HOST_KEYWORD = line_node_keyword + 1;
  LINE_GROUP_KEYWORD = line_host_keyword + 1;
  LINE_HOSTLIST_KEYWORD = line_group_keyword + 1;
  LINE_NODELIST_KEYWORD = line_hostlist_keyword + 1;
  LINE_ADD_KEYWORD = line_nodelist_keyword + 1;
  LINE_DELETE_KEYWORD = line_add_keyword + 1;
  LINE_REPLACE_KEYWORD =line_delete_keyword + 1;
  LINE_END_KEYWORD = line_replace_keyword + 1;
  LINE_COMPLETE_KEYWORD = line_end_keyword + 1;
  LINE_KEYWORD_COUNT = 12;

  LINE_KEYWORD_LIMIT = line_keyword_count - 1;

type
  LINE_KEYWORD_INDEX = 0..line_keyword_limit;

  KEYWORD_CHOICE_SET = set of line_keyword_index;



(* keyword totals *)
const
  KEYWORD_MAX = global_keyword_max +
    primary_keyword_max + archive_keyword_max + line_keyword_count;
  KEYWORD_LIMIT = keyword_max - 1;

type
  KEYWORD_INDEX = 0..keyword_limit;
!
(***********************************************************************)
(*                                                                     *)
(*       command scanner definitions                                   *)
(*                                                                     *)
(***********************************************************************)



(* The name of the command in the command definition. *)

const
  COMMAND_NAME_MAX = 12 (* characters *);
  COMMAND_NAME_LIMIT = command_name_max - 1;

type
  COMMAND_NAME_INDEX = 0..command_name_limit;
  COMMAND_NAME_SIZE = 0..command_name_max;

  COMMAND_NAME = array [command_name_index] of char;



(* Keyword type definitions. *)

const
  COMMAND_KEYWORD_MAX = 35 (* maximum number of keywords/command *);
  COMMAND_KEYWORD_LIMIT = command_keyword_max - 1;

type
  COMMAND_KEYWORD_INDEX = 0..command_keyword_limit;
  COMMAND_KEYWORD_TOTAL = 0..command_keyword_max;

type
  COMMAND_KEYWORD_SET = set of command_keyword_index;



(* The name of the keyword in the command definition. *)

const
  KEYWORD_NAME_MAX = 12 (* characters *);
  KEYWORD_NAME_LIMIT = keyword_name_max - 1;

type
  KEYWORD_NAME_INDEX = 0..keyword_name_limit;
  KEYWORD_NAME_SIZE = 0..keyword_name_max;

  KEYWORD_NAME = array [keyword_name_index] of char;



(* Define HELP text...text to be stored with commands and keywords to	*)
(* be output on the HELP command according to the validators license	*)
(* and current context.							*)

const (* size of tty line minus possible command and spaces *)
  HELP_TEXT_MAX = command_line_text_max - (command_name_max + 6);
  HELP_TEXT_LIMIT = help_text_max - 1;

type
  HELP_TEXT_INDEX = 0..help_text_limit;
  HELP_TEXT_SIZE = 0..help_text_max;

  HELP_STRING = array [help_text_index] of char;



(* Freeword definitions. *)

const
  COMMAND_FREEWORD_MAX = 20 (* maximum number of freewords/command *);
  COMMAND_FREEWORD_LIMIT = command_freeword_max - 1;

type
  COMMAND_FREEWORD_INDEX = 0..command_freeword_limit;
  COMMAND_FREEWORD_TOTAL = 0..command_freeword_max;



(* Command token definition.  This record points to a command line token. *)

const
  COMMAND_TOKEN_MAX = command_line_text_limit (* maximum token extent *);
  COMMAND_TOKEN_LIMIT = command_token_max - 1;

type
  COMMAND_TOKEN_INDEX = 0..command_token_limit;
  COMMAND_TOKEN_SIZE = 0..command_token_max;

type
  COMMAND_TOKEN = record
    start  : command_token_index;
    finish : command_token_index
  end (* command_token *);



(* Description of a command line after it is scanned.			*)
(* The fields of the record have the following meaning.			*)
(*									*)
(*  input_line		the text to be scanned				*)
(*  prompt		the prompt for the current command class	*)
(*  status		the status of the scan i.e. an error code	*)
(*  command_class	the context the command comes from		*)
(*  command		the index of the command scanned		*)
(*  subcommand		the keyword index of the subcommand if one	*)
(*			is required. A subcommand is required if the	*)
(*			'subcommand_count' in the command definition	*)
(*			is greater than zero				*)
(*  keyword_count	the number of keywords in the command		*)
(*  keyword_present	the set of all keywords scanned			*)
(*  keyword_value	the value token if the command requires one	*)
(*  freeword_count	the number of freewords in the command		*)
(*  freeword_value	the token for the freewords entered		*)

type
  SCANNED_COMMAND = record
    input_line		: command_line;
    prompt		: command_prompt;
    status		: command_scan_state;
    command_class	: command_class_index;
    command		: command_index;
    subcommand		: command_keyword_index;
    keyword_count	: command_keyword_total;
    keyword_present	: command_keyword_set;
    keyword_value	: array [command_keyword_index] of command_token;
    freeword_count	: command_freeword_total;
    freeword_value	: array [command_freeword_index] of command_token
  end (* scanned_command *);
!
(* A command definition header.						*)
(* This record defines a command, including its name and allowed	*)
(* parameters. The fields of the record have the following meaning.	*)
(*									*)
(*  name		the text for the command name			*)
(*  required_license	the command_license the validator must have     *)
(*                      for the command to be executed.			*)
(*			Keywords may have further requirements.		*)
(*  freeword_allowed	true if the command allows freewords		*)
(*  keyword_offset	the start of the keywords for this command in	*)
(*			'keyword_table' which contains all keywords	*)
(*			for all commands				*)
(*  keyword_count	the number of keywords allowed for this command	*)
(*			in 'keyword_table' starting at 'keyword_offset'	*)
(*  subcommand_count	the number of the keywords for this command	*)
(*			which should be treated as subcommands. These	*)
(*			will be the first 'subcommand_total' keywords	*)
(*			of this command					*)
(*  explanation         string for HELP command 			*)

type
  COMMAND_DEFINITION = record
    name		: command_name;
    required_license	: command_license;
    freeword_allowed	: boolean;
    keyword_offset	: keyword_index;
    keyword_count	: command_keyword_total;
    subcommand_count	: command_keyword_total;
    explanation		: help_string
  end (* command_definition *);



(* A keyword definition.						*)
(* This record defines a keyword, including its name and		*)
(* properties. The fields of the record have the folowing meaning.	*)
(*									*)
(*  name		the text for the keyword name			*)
(*  required_license	the command_license the validator must have     *)
(*                      for the command with this keyword to be		*)
(*			executed. The command and other keywords may 	*)
(*			have further level requirements			*)
(*  value_required	true if the keyword must be followed by a value	*)
(*  explanation         string for HELP command 			*)

type
  KEYWORD_DEFINITION = record
    name		: keyword_name;
    required_license	: command_license;
    value_required	: boolean;
    explanation		: help_string
  end (* keyword_definition *);
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(************************************************************************)
(*									*)
(*	sysio.ntv							*)
(*									*)
(*			    system_handler				*)
(*									*)
(*	This class contains system I/O calls.				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  system_operation, systam_param, system_information		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	07Mar86 - jrn							*)
(*	      - add CURRENT_HOST_STATE procedure			*)
(*	19Dec85 - jrn							*)
(*	      - remove the 3 functions, TYM_FILE_TERMINAL_COUNT, 	*)
(*		TYM_FILE_AUX_CIRCUIT_COUNT, KERNEL_HOST; replace with	*)
(*		a single sysio call in the initial statement, and the	*)
(*		entry variable sys_info					*)
(*	01Nov85 - jrn							*)
(*	      - add SET_HOST_STATE procedure				*)
(*	23May85 - jrn							*)
(*	      - change functions to procedures to pass variable		*)
(*		arguments, so that I/O calls do not require an		*)
(*		additional stack variable (to save space)		*)
(*	      - add supervisor_checksum routine				*)
(*	23Mar85 - pgl							*)
(*	      - delete all functions referring to tape checksums	*)
(*	07Aug84 - jrn							*)
(*	      - add various checksum computations, internal		*)
(*		"engine_checksum" routine, and remove entry variable	*)
(*		"param"							*)
(*	01Aug84 - jrn							*)
(*	      - change function netval_host_number to kernel_host to	*)
(*		return the kernel host number to check to see if the	*)
(*		NETVAL kernel host is the same as a Supervisor (check	*)
(*		is in MISC_UTILITY routine LEGAL_CONSISTENCY)		*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type SYSTEM_HANDLER = class;


var
  entry sys_info : system_information;



(**************************  system_handler  ****************************)
(*									*)
(*			       initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  param : system_param;

begin
  param.operation := SYSTEM_INFO;
  io(sys_info, param, SYSTEM, 0)
end (* initialize *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  system_handler  ****************************)
(*									*)
(*			   supervisor_checksum				*)
(*									*)
(*      Return the supervisor (940) checksum.				*)
(*									*)
(************************************************************************)

procedure entry SUPERVISOR_CHECKSUM(
      size	: cud_data_size;
  var data	: cud_data;
  var checksum	: integer);

var
  param : system_param;

begin
  param.operation := GET_940_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := param.arg2
end (* supervisor_checksum *);



(**************************  system_handler  ****************************)
(*									*)
(*			     engine_checksum				*)
(*									*)
(*      Return the engine vertical checksum in the left half and	*)
(*	the diagonal checksum in the right half.			*)
(*									*)
(************************************************************************)

function engine_checksum(
      param : system_param) : integer;

begin
  engine_checksum := (param.arg1 * BIT15) + param.arg2
end (* engine_checksum *);



(**************************  system_handler  ****************************)
(*									*)
(*			   page_checksum				*)
(*									*)
(*      Return the system checksum for the page data.			*)
(*									*)
(************************************************************************)

procedure 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
PAGE_CHECKSUM(
      size	: page_length;
  var data	: univ page;
  var checksum	: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* page_checksum *);



(**************************  system_handler  ****************************)
(*									*)
(*			   named_list_checksum				*)
(*									*)
(*      Return the system checksum for the named_list_definition.	*)
(*									*)
(************************************************************************)

procedure 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
NAMED_LIST_CHECKSUM(
  var named_list	: named_list_definition;
  var checksum		: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := MAXIMUM_BYTES_IN_NAMED_LIST - MAXIMUM_BYTES_IN_WORD;
  io(named_list, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* named_list_checksum *);



(**************************  system_handler  ****************************)
(*									*)
(*			 global_access_checksum				*)
(*									*)
(*      Return the system checksum for a global_access.			*)
(*									*)
(************************************************************************)

procedure 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
GLOBAL_ACCESS_CHECKSUM(
  var global_access	: global_access_description;
  var checksum		: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION -
    MAXIMUM_BYTES_IN_WORD;
  io(global_access, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* global_access_checksum *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  system_handler  ****************************)
(*									*)
(*			     cud_checksum				*)
(*									*)
(*      Return the system checksum for the cud data.			*)
(*									*)
(************************************************************************)

procedure entry CUD_CHECKSUM(
      size	: cud_data_size;
  var data	: univ cud_data;
  var checksum	: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* cud_checksum *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(**************************  system_handler  ****************************)
(*									*)
(*			     set_host_state				*)
(*									*)
(************************************************************************)

procedure entry SET_HOST_STATE(
      state_to_set	: host_state);

var
  param : system_param;
  dummy : integer;

begin
  case state_to_set of
    UP_STATE:	param.operation := SET_SYSTEM_UP;
    DOWN_STATE:	param.operation := SET_SYSTEM_DOWN;
    SHUT_STATE:	param.operation := SET_SYSTEM_SHUT;
    GONE_STATE:	param.operation := SET_SYSTEM_GONE
  end (* case *);
  io(dummy, param, SYSTEM, 0)
end (* set_host_state *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  system_handler  ****************************)
(*									*)
(*			   current_host_state				*)
(*									*)
(************************************************************************)

function entry CURRENT_HOST_STATE : host_state;

var
  param : system_param;
  dummy : integer;
  state : host_state;

begin
  param.operation := GET_HOST_STATE;
  param.arg1 := 0;
  io(dummy, param, SYSTEM, 0);
  state := UP_STATE; dummy := 0;
  while dummy < param.arg1 do
    begin
      state := succ(state);
      dummy := dummy + 1
    end (* while *);
  current_host_state := state
end (* current_host_state *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  initialize
end (* system_handler *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*								      	*)
(*	MUTIL.NTV							*)
(*								      	*)
(*				misc_utility			      	*)
(*								      	*)
(*    This class handles miscellaneous operations.			*)
(*        							      	*)
(************************************************************************)
(*								      	*)
(*			   Revision Record		    		*)
(*							      		*)
(*	02Jun86 - jrn							*)
(*	      - add legal_username_character function			*)
(*	05Mar86 - jrn							*)
(*	      - add same_name procedure with different arguments than	*)
(*		username_match, and use new do_username_match function	*)
(*	23Dec85	- rsb							*)
(*		  change def of "sup" in legal_consistency to		*)
(*		real_sup	  : real_supervisor_index;		*)
(*	19Dec85 - jrn							*)
(*	      - change sys_io.kernel_host to				*)
(*		sys_io.sys_info.kernel_host_number			*)
(*	19Feb85 - jrn							*)
(*	      - add decimal_digit function				*)
(*	01Aug84 - jrn							*)
(*	      - fix bug in LEGAL_CONSISTENCY function (compare  	*)
(*		supervisor_index + PRINT_SUPERVISOR_OFFSET against	*)
(*		sysio.kernel_host)					*)
(*	Version 2.01 May 1, 1984 - jrn					*)
(*	      - remove percent routine					*)
(*	14Mar84	Version 2.01 neb					*)
(*	      - added the CLEAR_PAGE and CLEAR_BLOCK routines		*)
(*	29SEP83    Original -- from (patrol)mutil.tms - jrn     	*)
(*							      		*)
(************************************************************************)


type MISC_UTILITY = class;


var
  sys_io : system_handler;
"

(****************************  misc_utility  ****************************)
(*								      	*)
(*			  	 percent				*)
(*								      	*)
(*    The second argument percent of the first argument.		*)
(*								      	*)
(************************************************************************)

function entry PERCENT(
      n	: integer;
      p : integer) : integer;

begin
  percent := (n*p+99) div 100
end (* percent *);
"



(****************************  misc_utility  ****************************)
(*									*)
(*			     do_username_match				*)
(*									*)
(*      Return TRUE if usernames match.					*)
(*									*)
(************************************************************************)

function do_username_match(
      first_name	: username_string;
      second_name	: username_string) : boolean;

var
  i : username_text_index;

begin
  do_username_match := TRUE;
  if first_name.size <> second_name.size
  then do_username_match := FALSE
  else
    for i := 0 to first_name.size - 1 do
      if first_name.text[i] <> second_name.text[i]
      then do_username_match := FALSE
end (* do_username_match *);



(****************************  misc_utility  ****************************)
(*									*)
(*			      username_match				*)
(*									*)
(*      Return TRUE if usernames match.					*)
(*									*)
(************************************************************************)

function entry USERNAME_MATCH(
      first_name	: username_string;
      second_name	: username_string) : boolean;

begin
  username_match := do_username_match(first_name, second_name);
end (* username_match *);



(****************************  misc_utility  ****************************)
(*									*)
(*				same_name				*)
(*									*)
(*      Return TRUE if second_name matches the name described by	*)
(*	first_name_text and first_name_size.				*)
(*									*)
(************************************************************************)

function entry SAME_NAME(
      first_name_text	: username_text;
      first_name_size	: username_text_size;
      second_name	: username_string) : boolean;

var
  first_name : username_string;

begin
  first_name.text := first_name_text;
  first_name.size := first_name_size;
  same_name := do_username_match(second_name, first_name)
end (* same_name *);



(***************************  misc_utility  *****************************)
(*									*)
(*				odd_value				*)
(*									*)
(*	Return true if test word has rightmost bit set. 		*)
(*									*)
(************************************************************************)

function odd_value(
      test_word	: integer) : boolean;

var
  x : integer;

begin
  x := test_word;
  if x < 0
  then x := x + BIT0;
  odd_value := (x mod 2) <> 0
end (* odd_value *);



(***************************  misc_utility  *****************************)
(*									*)
(*				 odd					*)
(*									*)
(*	Return true if test word has rightmost bit set. 		*)
(*									*)
(************************************************************************)

function entry ODD(
      test_word	: integer) : boolean;

begin
  odd := odd_value(test_word)
end (* odd *);



(***************************  misc_utility  *****************************)
(*									*)
(*				maximum					*)
(*									*)
(*	Return the greater of the two integers.				*)
(*									*)
(************************************************************************)

function entry MAXIMUM(
      number1	: integer;
      number2	: integer) : integer;

begin
  if number1 > number2
  then maximum := number1
  else maximum := number2
end (* maximum *);



(***************************  misc_utility  *****************************)
(*									*)
(*				minimum					*)
(*									*)
(*	Return the lesser of the two integers.				*)
(*									*)
(************************************************************************)

function entry MINIMUM(
      number1	: integer;
      number2	: integer) : integer;

begin
  if number1 < number2
  then minimum := number1
  else minimum := number2
end (* minimum *);



(***************************  misc_utility  *****************************)
(*									*)
(*			      do_test_bit				*)
(*									*)
(*    Test if given bit is on in test word.				*)
(*									*)
(************************************************************************)

function do_test_bit(
      bit	: integer;
      test_word	: univ integer) : boolean;

var
  x : integer;

begin
  x := test_word;
  if bit < 0
  then do_test_bit := x < 0
  else
    begin
      if x < 0
      then x := x + BIT0;
      do_test_bit := odd_value(x div bit)
    end
end (* do_test_bit *);



(***************************  misc_utility  *****************************)
(*									*)
(*				test_bit				*)
(*									*)
(*    Test if given bit is on in test word.				*)
(*									*)
(************************************************************************)

function entry TEST_BIT(
      bit	: integer;
      test_word : univ integer) : boolean;

begin
  test_bit := do_test_bit(bit, test_word);
end (* test_bit *);



(***************************  misc_utility  *****************************)
(*									*)
(*				 set_bit				*)
(*									*)
(*    Be sure bit is on in word.					*)
(*									*)
(************************************************************************)

procedure entry SET_BIT(
      bit	: integer;
  var word	: univ integer);

begin
  if not do_test_bit(bit, word)
  then word := word + bit
end (* set_bit *);



(***************************  misc_utility  *****************************)
(*									*)
(*				clear_bit				*)
(*									*)
(*    Be sure bit is off in word.					*)
(*									*)
(************************************************************************)

procedure entry CLEAR_BIT(
      bit	: integer;
  var word	: univ integer);

begin
  if do_test_bit(bit, word)
  then word := word - bit
end (* clear_bit *);


(****************************  misc_utility  ****************************)
(*									*)
(*				left_shift				*)
(*									*)
(*	Return integer shifted left such that the rightmost bit of the	*)
(*	original integer has shifted to the position occupied by the	*)
(*	given bit.							*)
(*									*)
(*	   1111111111222222222233	     1111111111222222222233	*)
(* 01234567890123456789012345678901   01234567890123456789012345678901	*)
(* ................................   ............00000000000000000000	*)
(*	    ^								*)
(*	   bit								*)
(*									*)
(************************************************************************)

function entry LEFT_SHIFT(
      bit		: integer;
      shift_word	: integer) : integer;

begin
  if bit = BIT0
  then
    if odd_value(shift_word)
    then left_shift := BIT0
    else left_shift := 0
  else
    if shift_word < 0
    then left_shift := (shift_word + BIT0) * bit
    else left_shift := shift_word * bit
end (* left_shift *);



(****************************  misc_utility  ****************************)
(*									*)
(*			      right_shift				*)
(*									*)
(*									*)
(*	Return integer shifted right such that the bit in the original	*)
(*	word in the same position as the given bit is moved to the	*)
(*	rightmost bit position. 					*)
(*									*)
(*	   1111111111222222222233	     1111111111222222222233	*)
(* 01234567890123456789012345678901   01234567890123456789012345678901	*)
(* ................................   00000000000000000000............	*)
(*	    ^								*)
(*	   bit								*)
(************************************************************************)

function entry RIGHT_SHIFT(
      bit		: integer;
      shift_word	: integer) : integer;

begin
  if bit = BIT0
  then
    if shift_word < 0
    then right_shift := 1
    else right_shift := 0
  else
    if shift_word < 0
    then right_shift := (shift_word + BIT0) div bit + (BIT1 div (bit div 2))
    else right_shift := shift_word div BIT
end (* right_shift *);



(****************************  misc_utility  ****************************)
(*									*)
(*				   xor					*)
(*									*)
(*	return the exclusive OR of the two sets.			*)
(*									*)
(************************************************************************)

procedure xor(
  var x	: univ character_set;
      y	: univ character_set);

begin
  x := (x-y) or (y-x)
end (* xor *);



(****************************  misc_utility  ****************************)
(*									*)
(*			     exclusive_or				*)
(*									*)
(*	return the exclusive OR of the two integers.			*)
(*									*)
(************************************************************************)

function entry EXCLUSIVE_OR(
      x	: integer;
      y : integer) : integer;

var
  xarray : integer_array;
  yarray : integer_array;

begin
  xarray[0] := x;
  yarray[0] := y;
  xor(xarray, yarray);
  exclusive_or := xarray[0]
end (* exclusive_or *);



(****************************  misc_utility  ****************************)
(*									*)
(*				mask_sets				*)
(*									*)
(*	return the AND of the two sets.					*)
(*									*)
(************************************************************************)

procedure mask_sets(
  var x	: univ character_set;
      y	: univ character_set);

begin
  x := x & y (* x AND y *)
end (* mask_sets *);



(****************************  misc_utility  ****************************)
(*									*)
(*				  mask					*)
(*									*)
(*	return the AND of the two integers.				*)
(*									*)
(************************************************************************)

function entry MASK(
      x	: integer;
      y : integer) : integer;

var
  xarray : integer_array;
  yarray : integer_array;

begin
  xarray[0] := x;
  yarray[0] := y;
  mask_sets(xarray, yarray);
  mask := xarray[0]
end (* mask *);



(***************************  misc_utility  *****************************)
(*								      	*)
(*			       word_count				*)
(*								      	*)
(*	Compute the number of whole words required to store		*)
(*	byte_count bytes.						*)
(*								      	*)
(************************************************************************)

function entry WORD_COUNT(
      byte_count	: univ integer) : integer;

begin
  word_count := (byte_count + WORD_IN_BYTES_LIMIT) div MAXIMUM_BYTES_IN_WORD
end (* word_count *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			   save_halfword_in_word		  	*)
(*								      	*)
(*    Store the  halfword_to_save in the right half of target_word.	*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_HALFWORD_IN_WORD(
      halfword_to_save	: halfword;
  var target_word	: univ word_in_halfwords);
begin
  target_word[0] := ZERO_HALFWORD;
  target_word[1] := halfword_to_save
end (* save_halfword_in_word *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  misc_utility  ****************************)
(*								      	*)
(*			   save_word_in_halfword		  	*)
(*								      	*)
(*    Store the rightmost half of word_to_save in target_halfword.	*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_WORD_IN_HALFWORD(
      word_to_save	: univ word_in_halfwords;
  var target_halfword	: halfword);

begin
  target_halfword := word_to_save[1]
end (* save_word_in_halfword *);



(***************************  misc_utility  *****************************)
(*									*)
(*			make_character_upper_case			*)
(*									*)
(************************************************************************)

procedure entry MAKE_CHARACTER_UPPER_CASE(
  var c	: char);

begin
  if (lower_case_a <= c) and (c <= lower_case_z)
  then c := chr(ord(c) - 32)
end (* make_character_upper_case *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)




(****************************  misc_utility  ****************************)
(*								      	*)
(*			  save_characters_in_word			*)
(*								      	*)
(*    Store the four characters, ch1, ch2, ch3, ch4 in word.		*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_CHARACTERS_IN_WORD(
      ch1	: char;
      ch2	: char;
      ch3	: char;
      ch4 	: char;
  var word	: univ word_in_bytes);

begin
  word[0] := ch1;
  word[1] := ch2;
  word[2] := ch3;
  word[3] := ch4;
end (* save_characters_in_word *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			  save_word_in_characters			*)
(*								      	*)
(*    Store the word in the 4 characters.				*)
(*							      		*)
(************************************************************************)

procedure entry SAVE_WORD_IN_CHARACTERS(
      word	: univ word_in_bytes;
  var ch1	: char;
  var ch2	: char;
  var ch3	: char;
  var ch4	: char);

begin
  ch1 := word[0];
  ch2 := word[1];
  ch3 := word[2];
  ch4 := word[3]
end (* save_word_in_characters *);




(****************************  misc_utility  ****************************)
(*								      	*)
(*			     quoted_text_size		    		*)
(*								      	*)
(*    Return the size of the quoted text.				*)
(*							      		*)
(************************************************************************)

function entry QUOTED_TEXT_SIZE(
      text : quoted_text) : integer;

var
  count : quoted_text_index;

begin
  count := 0;
  while text[count] <> END_MESSAGE_CHARACTER do
    count := count + 1;
  quoted_text_size := count
end (* quoted_text_size *);



(***************************  misc_utility  *****************************)
(*									*)
(*				negative				*)
(*									*)
(*	Return true if integer value is negative.			*)
(*									*)
(************************************************************************)

function negative(
      test_value	: univ integer) : boolean;

begin
  negative := test_value < 0
end (* negative *);



(***************************  misc_utility  *****************************)
(*									*)
(*			     negative_byte				*)
(*									*)
(*	Return true if byte is negative.				*)
(*									*)
(************************************************************************)

function entry NEGATIVE_BYTE(
      byte	: char) : boolean;

var
  test_word : word_in_bytes;

begin
  test_word[0] := byte;
  negative_byte := negative(test_word)
end (* negative_byte *);



(***************************  misc_utility  *****************************)
(*									*)
(*			     a_decimal_digit				*)
(*									*)
(************************************************************************)

function a_decimal_digit(
      c	: char) : boolean;

begin
  a_decimal_digit := (ASCII_ZERO <= c) and (c <= ASCII_NINE)
end (* a_decimal_digit *);



(***************************  misc_utility  *****************************)
(*									*)
(*			  an_alpha_numeric_character			*)
(*									*)
(************************************************************************)

function an_alpha_numeric_character(
      c	: char) : boolean;

begin
  an_alpha_numeric_character := a_decimal_digit(c) or
    ((c >= ascii_a) and (c <= ascii_z))
end (* an_alpha_numeric_character *);



(***************************  misc_utility  *****************************)
(*									*)
(*			     alpha_numeric				*)
(*									*)
(************************************************************************)

function entry ALPHA_NUMERIC(
      c	: char) : boolean;

begin
  alpha_numeric := an_alpha_numeric_character(c)
end (* alpha_numeric *);



(***************************  misc_utility  *****************************)
(*									*)
(*			 legal_username_character			*)
(*									*)
(************************************************************************)

function entry LEGAL_USERNAME_CHARACTER(
      c	: char) : boolean;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  legal_username_character := an_alpha_numeric_character(c) or
    (c in  [ASCII_SPACE, '#', '$', '*', ASCII_AMPERSAND, ASCII_COMMA,
     ASCII_DOT, ASCII_MINUS, ASCII_SLASH])
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* legal_username_character *);


(***************************  misc_utility  *****************************)
(*									*)
(*			     decimal_digit				*)
(*									*)
(************************************************************************)

function entry DECIMAL_DIGIT(
      c	: char) : boolean;

begin
  decimal_digit := a_decimal_digit(c)
end (* decimal_digit *);



(****************************  misc_utility  ****************************)
(*									*)
(*				clear_block			       	*)
(*									*)
(************************************************************************)

procedure entry CLEAR_BLOCK(
  var block_data : univ cud_data);

var
  count : cud_data_index;

begin
  for count := 0 to CUD_DATA_LIMIT do
    block_data[count] := ZERO
end (* clear_block *);


(****************************  misc_utility  ****************************)
(*									*)
(*				clear_page				*)
(*									*)
(************************************************************************)

procedure entry CLEAR_PAGE(
  var page_data : univ page);

var
  count : page_index;

begin
  for count := 0 to PAGE_LIMIT do
    page_data[count] := ZERO
end (* clear_page *);



(****************************  misc_utility  ****************************)
(*									*)
(*			    legal_consistency				*)
(*									*)
(*      Check to be sure a consistency can be done on the sup.		*)
(*									*)
(************************************************************************)

function entry LEGAL_CONSISTENCY(
      real_sup	: real_supervisor_index) : boolean;

begin (* legal_consistency *)
  legal_consistency := not (NETVAL_CUD_IS_A_MUD and
    ((real_sup + PRINT_SUPERVISOR_OFFSET) =
		   sys_io.sys_info.kernel_host_number))
end (* legal_consistency *);
	 


(**********************************************************************)
(**********************************************************************)

begin (* initial statement *)
  init sys_io
end (* misc_utility *);

!
(**********************************************************************)
(*                                                                    *)
(*	DELUTL.NTV						      *)
(*                       circuit_delay_utility                        *)
(*                                                                    *)
(*    This class handles circuit delay operations.		      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*	14Feb86 - rsb						      *)
(*		  add a line of code to DELAY so delay_period will    *)
(*		  never exceed maximum_delay			      *)	
(*    21Jul84 Version 3.00 - jrn/pgl				      *)
(*	    - added the class parameters, first_retry and 	      *)
(*	      maximum_retry					      *)
(*	    - changed FIRST_CIRCUIT_RETRY_DELAY to first_retry	      *)
(*	      and MAXIMUM_CIRCUIT_RETRY_DELAY to maximum_retry	      *)
(*                                                                    *)
(*    29NOV83    Original - jrn				              *)
(*                                                                    *)
(**********************************************************************)


type CIRCUIT_DELAY_UTILITY = class(
	first_retry	: integer;
	maximum_retry	: integer);


var
  delay_period : integer;
!
(**********************  circuit_delay_utility  *************************)
(*									*)
(*			    initialize_delay				*)
(*									*)
(*      Reset delay_period.						*)
(*									*)
(************************************************************************)

procedure INITIALIZE_DELAY;

begin
  delay_period := first_retry
end (* initialize_delay *);



(**********************  circuit_delay_utility  *************************)
(*									*)
(*			      reset_delay				*)
(*									*)
(*      Reset delay_period.						*)
(*									*)
(************************************************************************)

procedure entry RESET_DELAY;

begin
  initialize_delay
end (* reset_delay *);



(**********************  circuit_delay_utility  *************************)
(*									*)
(*				 delay					*)
(*									*)
(*      Delay before attempting to build another circuit.		*)
(*									*)
(************************************************************************)

procedure entry DELAY;

var
  restart_time : integer;

begin (* delay *)
  restart_time := delay_period + REALTIME (* compute time to return *);
  while REALTIME < restart_time do (* perform actual delay *)
    wait;
  if delay_period < maximum_retry	(* if necessary... *)
  then delay_period := delay_period * 2 (* increment delay *);
  if delay_period > maximum_retry
  then delay_period := maximum_retry
end (* delay *);



(***********************  circuit_delay_utility  ***********************)
(***********************************************************************)

begin (* initial statement *)
  initialize_delay
end (* circuit_delay_utility *);
!
(************************************************************************)
(*									*)
(*	CRASH.NTV							*)
(*									*)
(*			    crash_utility				*)
(*									*)
(*	This class handles all calls to the crash pseudo-device.	*)
(*	It has separate entries corresponding to each crash operation.	*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	20Oct83	Original -- from (PATROL)crash.ntv - jrn		*)
(*									*)
(************************************************************************)


type CRASH_UTILITY = class
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  crash_utility  ****************************)
(*									*)
(*			  signal_process_error				*)
(*									*)
(*	The crash_send operation. Crash the process making the call and *)
(*	signal any awaiting process that the crash occurred.		*)
(*									*)
(************************************************************************)

procedure entry SIGNAL_PROCESS_ERROR;

var
  param : crash_param;

begin
  param.operation := CRASH_SIGNAL;
  io(param, param, CRASH, 0)
end (* signal_process_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  crash_utility  ****************************)
(*									*)
(*				halt_slot				*)
(*									*)
(*	The crash_halt operation. Halt the slot.			*)
(*									*)
(************************************************************************)

procedure entry HALT_SLOT;

var
  param : crash_param;

begin
  param.operation := CRASH_HALT;
  io(param, param, CRASH, 0)
end (* halt_slot *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* crash_utility *);
!
(************************************************************************)
(*									*)
(*	CIPHER.NTV							*)
(*			 password_cipher_utility			*)
(*									*)
(*    This class handles the conversion of a password string to a	*)
(*    password cipher.							*)
(*									*)
(*     The following identifiers must be defined externally:		*)
(*	 password_string, password_text_index				*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	04Mar85 - jrn							*)
(*	      - added function ciphered_name				*)
(*	27jul84 Version 3.00 - jrn/pgl					*)
(*	      - added function illegal_alpha_password			*)
(*	20jul83 original from (patrol)cipher.tms -- jrn			*)
(*									*)
(************************************************************************)



type password_cipher_utility = class(
	mutil	: misc_utility);



(************************  password_cipher_utility  *********************)
(*									*)
(*			   illegal_alpha_password			*)
(*									*)
(*      TRUE if password requires a non-alpha numeric, and there 	*)
(*	is none in the password.					*)
(*									*)
(************************************************************************)

function entry ILLEGAL_ALPHA_PASSWORD(
	password	: password_string) : boolean;

var
  index : password_text_index;
  done  : boolean;

begin
  illegal_alpha_password := FALSE;
  index := 0;
  done := FALSE;
  if REQUIRE_NONALPHANUMERIC
  then
    repeat
      if not mutil.alpha_numeric(password.text[index])
      then done := TRUE
      else
        if index < password.size - 1
	then index := index + 1
	else
	  begin
	    done := TRUE;
	    illegal_alpha_password := TRUE
	  end
    until done
end (* ILLEGAL_ALPHA_PASSWORD *);



(*********************  password_cipher_utility  ************************)
(*									*)
(*			    password_cipher 				*)
(*									*)
(*	Convert a password string into a cipher.			*)
(*									*)
(************************************************************************)

function password_cipher(
      password	: password_string) : integer;

var
  cipher: integer;
  j: password_text_index;
  i: integer;
  x: integer;

begin
  cipher := 0;
  x := 0;
  for j := 0 to password.size-1 do
    for i := 1 to 7 do
      begin
	cipher := cipher + x + ord(password.text[j]);
	x := x + cipher;
	if mutil.test_bit(BIT25, x)
	then x := x + ord(password.text[j]);
	x := mutil.left_shift(BIT28, x) + mutil.right_shift(BIT2, x)
      end (* for *);
  password_cipher := mutil.exclusive_or(cipher, x)
end (* password_cipher *);



(*********************  password_cipher_utility  ************************)
(*									*)
(*				convert 				*)
(*									*)
(*	Convert a password string into a cipher.			*)
(*									*)
(************************************************************************)

function entry CONVERT(
      password	: password_string) : integer;

begin
  convert := password_cipher(password)
end (* CONVERT *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  password_cipher_utility  ************************)
(************************************************************************)

begin
end (* password_cipher_utility *);
!
(**********************************************************************)
(*								      *)
(*	FIFO.NTV						      *)
(*                                                                    *)
(*                                Fifo                                *)
(*                                                                    *)
(*    This is a first-in-first-out index manager.		      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          Revision Record                           *)
(*                                                                    *)
(*    29SEP83   Original -- from ((Osiris)fifoz.cmn)                  *)
(*                                                                    *)
(**********************************************************************)



type FIFO = class(
	origin	: integer;
	limit	: integer);


var
  head : integer;
  tail : integer;
  length : integer;



(*******************************  Fifo  *******************************)
(*                                                                    *)
(*                              Arrival                               *)
(*                                                                    *)
(**********************************************************************)

function entry ARRIVAL : integer;

begin
  arrival := tail;
  if tail = limit
  then tail := origin
  else tail := tail + 1;
  length := length + 1
end (* arrival *);



(*******************************  Fifo  *******************************)
(*                                                                    *)
(*                             Departure                              *)
(*                                                                    *)
(**********************************************************************)

function entry DEPARTURE : integer;

begin
  departure := head;
  if head = limit
  then head := origin
  else head := head + 1;
  length := length - 1
end (* departure *);



(*******************************  Fifo  *******************************)
(*                                                                    *)
(*                               Empty                                *)
(*                                                                    *)
(**********************************************************************)

function entry EMPTY : Boolean;

begin
  empty := length = origin
end (* empty *);



(*******************************  Fifo  *******************************)
(*                                                                    *)
(*                                Full                                *)
(*                                                                    *)
(**********************************************************************)

function entry FULL : Boolean;

begin
  full := length < limit
end (* full *);



(*******************************  Fifo  *******************************)
(**********************************************************************)

begin (* initial statement *)
  head := origin;
  tail := origin;
  length := origin
end (* fifo *);
!
(**********************************************************************)
(*                                                                    *)
(*	DATE.NTV						      *)
(*                                                                    *)
(*                         date_time_converter                        *)
(*                                                                    *)
(*    This class handles all ISIS time calculations.		      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*	05Aug86 - jrn						      *)
(*	      - add COMPUTE_YEAR for NVDM MESSGAES FROM command	      *)
(*	10Mar86 - jrn						      *)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS *)
(*		and change the add back scheme to be a dated list     *)
(*		(add function ISIS_TIME)			      *)
(*	09May85 - add Tymshare format date conversions - jrn	      *)
(*	29SEP83  original from (patrol)date.tms - jrn		      *)
(*                                                                    *)
(**********************************************************************)


type
  PRINT_TIME = record
    year,	 (* 19xx *)
    month,
    day,
    hour,
    minute,
    second : integer
  end (* PRINT_TIME *);



type DATE_TIME_CONVERTER = class;


const
  leap_year_seconds = 31622400 (* seconds in leap year *);
  non_leap_year_seconds = 31536000 (* seconds in non leap year *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
var
  mutil	: misc_utility;



(************************  date_time_converter  ***********************)
(*                                                                    *)
(*                          leap_year_test                            *)
(*                                                                    *)
(*    Return true if year is a leap year.                             *)
(*                                                                    *)
(**********************************************************************)

function leap_year_test(
      year	: integer) : boolean;

begin
  leap_year_test := ((year mod 40) <> 0) and ((year mod 4) = 0)
end (* leap_year_test *);



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                         do_days_to_month                           *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    month. LY is true if calculation is for a leap year.            *)
(*                                                                    *)
(**********************************************************************)

function do_days_to_month(
      month	: integer;
      ly	: boolean) : integer;

var
  value : integer;

begin
  case month of
    1: value := 0   (* january 0 *);
    2: value := 31  (* february 0 + 31 *);
    3: value := 59  (* march 31 + 28 *);
    4: value := 90  (* april 59 + 31 *);
    5: value := 120 (* may 90 + 30 *);
    6: value := 151 (* june 120 + 31 *);
    7: value := 181 (* july 151 + 30 *);
    8: value := 212 (* august 181 + 31 *);
    9: value := 243 (* september 212 + 31 *);
   10: value := 273 (* october 243 + 30 *);
   11: value := 304 (* november 273 + 31 *);
   12: value := 334 (* december 304 + 30 *)
  end (* case *);
  if ly and (month > 2)
  then do_days_to_month := value + 1
  else do_days_to_month := value
end (* do_days_to_month *);



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                           days_to_month                            *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    month. LY is true if calculation is for a leap year.            *)
(*                                                                    *)
(**********************************************************************)

function entry DAYS_TO_MONTH(
      month	: integer;
      ly	: boolean) : integer;

begin
  days_to_month := do_days_to_month(month, ly)
end (* days_to_month *);



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                         do_days_to_year                            *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    year from 1/1/74.		                                      *)
(*                                                                    *)
(**********************************************************************)

function do_days_to_year(
      year	: integer) : integer;

var
  next_year : integer;
  days : integer;

begin
  next_year := BASE_YEAR;
  days := 0;
  while next_year < year do
    begin
      if leap_year_test(next_year)
      then days := days + 366
      else days := days + 365;
      next_year := next_year + 1
    end (* while *);
  do_days_to_year := days
end (* do_days_to_year *);



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                            days_to_year                            *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    year from 1/1/74.		                                      *)
(*                                                                    *)
(**********************************************************************)

function entry DAYS_TO_YEAR(
      year	: integer) : integer;

begin
  days_to_year := do_days_to_year(year)
end (* days_to_year *);



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                      compute_days_in_month                         *)
(*                                                                    *)
(*    Return the number of days in specified month.                   *)
(*                                                                    *)
(**********************************************************************)

function compute_days_in_month(
      month	: integer;
      ly	: boolean) : integer;

begin
  case month of
    1,3,5,7,8,10,12: compute_days_in_month := 31;
    4,6,9,11:        compute_days_in_month := 30;
    2: if ly
       then compute_days_in_month := 29
       else compute_days_in_month := 28
  end (* case *)
end (* compute_days_in_month *);



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                          days_in_month                             *)
(*                                                                    *)
(*    Return the number of days in specified month.                   *)
(*                                                                    *)
(**********************************************************************)

function entry DAYS_IN_MONTH(
      month	: integer;
      ly	: boolean): integer;

begin
  days_in_month := compute_days_in_month(month, ly)
end (* days_in_month *);



(************************  date_time_converter  ***********************)
(*                                                                    *)
(*                             leap_year                              *)
(*                                                                    *)
(*    Return true if year is a leap year.                             *)
(*                                                                    *)
(**********************************************************************)

function entry LEAP_YEAR(
      year	: integer) : boolean;

begin
  leap_year := leap_year_test(year)
end (* leap_year *);



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                         do_compute_year                            *)
(*                                                                    *)
(*    Convert an ISIS time (i.e., since 1/1/74) in seconds to         *)
(*    seconds since the beginnning of the year. Also return           *)
(*    the year.                                                       *)
(*                                                                    *)
(**********************************************************************)

procedure do_compute_year(
  var new_time	: integer;
  var year	: integer);

var
  year_seconds: integer;

begin
  year := BASE_YEAR;
  year_seconds := non_leap_year_seconds;
  while new_time >= year_seconds do
    begin
      new_time := new_time - year_seconds;
      year := year + 1;
      if leap_year_test(year)
      then year_seconds := leap_year_seconds
      else year_seconds := non_leap_year_seconds
    end (* while *)
end (* do_compute_year *);



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                            compute_year                            *)
(*                                                                    *)
(*    Convert an ISIS time (i.e., since 1/1/74) in seconds to         *)
(*    seconds since the beginnning of the year. Also return           *)
(*    the year.                                                       *)
(*                                                                    *)
(**********************************************************************)

procedure entry COMPUTE_YEAR(
  var new_time	: integer;
  var year	: integer);

begin
  do_compute_year(new_time, year)
end (* compute_year *);



(************************  date_time_converter  *************************)
(*									*)
(*			  do_date_from_isis_time			*)
(*									*)
(*    Given an ISIS time, return the time for printing. 		*)
(*									*)
(************************************************************************)

procedure do_date_from_isis_time(
      isis_time	: integer;
  var date_time	: print_time);

var
  ly : boolean (* TRUE if leap year *);

begin
  with date_time do
    begin
      second := isis_time;
      do_compute_year(second, year)
    end (* with *);
  with date_time do
    begin
      minute := second div 60;
      second := second mod 60;

      hour := minute div 60;
      minute := minute mod 60;

      day := (hour div 24)+1;
      hour := hour mod 24;

      ly := leap_year_test(year);
      month := 1;
      while day > compute_days_in_month(month, ly) do
	begin
	  day := day - compute_days_in_month(month, ly);
	  month := month+1
	end (* while *)
    end (* with *)
end (* do_date_from_isis_time *);



(************************  date_time_converter  *************************)
(*									*)
(*			   date_from_isis_time				*)
(*									*)
(*    Given an ISIS time, return the time for printing. 		*)
(*									*)
(************************************************************************)

procedure entry DATE_FROM_ISIS_TIME(
      isis_time	: integer;
  var date_time	: print_time);

begin
  do_date_from_isis_time(isis_time, date_time)
end (* date_from_isis_time *);



(************************  date_time_converter  *************************)
(*									*)
(*			    do_seconds_in_time				*)
(*									*)
(************************************************************************)

function do_seconds_in_time(
      hour	: integer;
      minute	: integer;
      second	: integer) : integer;

begin
  do_seconds_in_time := (hour * 60 + minute) * 60 + second
end (* do_seconds_in_time *);



(************************  date_time_converter  *************************)
(*									*)
(*			     seconds_in_time				*)
(*									*)
(************************************************************************)

function entry SECONDS_IN_TIME(
      hour	: integer;
      minute	: integer;
      second	: integer) : integer;

begin
  seconds_in_time := do_seconds_in_time(hour, minute, second)
end (* seconds_in_date *);



(************************  date_time_converter  *************************)
(*									*)
(*			    do_seconds_in_date				*)
(*									*)
(************************************************************************)

function do_seconds_in_date(
      month	: integer;
      day	: integer;
      year	: integer;
      leap	: boolean) : integer;

begin
  do_seconds_in_date := (do_days_to_year(year) +
    do_days_to_month(month, leap) + day - 1) * SECONDS_PER_DAY
end (* do_seconds_in_date *);



(************************  date_time_converter  *************************)
(*									*)
(*			     seconds_in_date				*)
(*									*)
(************************************************************************)

function entry SECONDS_IN_DATE(
      month	: integer;
      day	: integer;
      year	: integer;
      leap	: boolean) : integer;

begin
  seconds_in_date := do_seconds_in_date(month, day, year, leap)
end (* seconds_in_date *);



(************************  date_time_converter  *************************)
(*									*)
(*				ISIS_TIME				*)
(*									*)
(*    Given a time, return the ISIS time.		 		*)
(*									*)
(************************************************************************)

function entry ISIS_TIME(
      date_time	: print_time) : integer;

begin
  with date_time do
    isis_time := do_seconds_in_date(month, day, year, leap_year_test(year)) +
      do_seconds_in_time(hour, minute, second)
end (* isis_time *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)



(************************  date_time_converter  *************************)
(*									*)
(*			    do_password_date				*)
(*									*)
(************************************************************************)

function do_password_date(
      password_change_date : integer) : integer;

begin
  do_password_date := password_change_date * SECONDS_PER_DAY
end (* do_password_date *);



(************************  date_time_converter  *************************)
(*									*)
(*			  password_date					*)
(*									*)
(************************************************************************)

function entry PASSWORD_DATE(
      password_change_date : integer) : integer;

var
  temp_date : integer;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  password_date := do_password_date(password_change_date)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* password_date *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  date_time_converter  ************************)
(**********************************************************************)


begin (* initial statement *)
  init mutil
end (* date_time_converter *);
!
(************************************************************************)
(*									*)
(*	CIRCIO.NTV							*)
(*			    circuit_handler				*)
(*									*)
(*	This class handles all direct calls to io for access to the	*)
(*	terminal or aux_circuit.					*)
(*									*)
(*	Procedures are organized as follows:				*)
(*	General initializing routines:					*)
(*		initialize_circuit, reset_circuit, zap_circuit,		*)
(*		status_check, LOGIN, BUILD_NORMAL_CIRCUIT,		*)
(*		BUILD_AUX_CIRCUIT, USE_CIRCUIT				*)
(*	Output routines: SEND,						*)
(*		SEND_QUOTED_TEXT, SEND_NEWLINE, WRITE_QUOTED_TEXT,	*)
(*		WRITE_QUOTED_TEXT_LINE, WRITE_LINE_AND_QUOTED_TEXT,	*)
(*		WRITE_LINE_AND_QUOTED_TEXT_LINE, WRITE_NEWLINE,		*)
(*		WRITE_FORMAT_BUFFER, WRITE_COMMAND_PROMPT,		*)
(*		WRITE_LOG_MESSAGE, WRITE_ONE_CHARACTER, 		*)
(*		WRITE_TWO_CHARACTERS, WRITE_THREE_CHARACTERS,		*)
(*		WRITE_WORD, WRITE_MUD_DATA, WRITE_CLASS_GROUP_TABLE,	*)
(*	Input routines: RECEIVE_LINE, RECEIVE_CHARACTERS,		*)
(*		READ_COMMAND_LINE, READ_LINE_DESCRIPTION,		*)
(*		READ_PASSWORD_STRING, READ_ONE_CHARACTER,		*)
(*		READ_TWO_CHARACTERS, READ_THREE_CHARACTERS, READ_WORD,	*)
(*		READ_PAGE, READ_MUD_DATA, READ_CLASS_GROUP_TABLE,	*)
(*	Checking and setting status routines:				*)
(*		WAIT_FOR_INPUT, WAIT_FOR_OUTPUT, CLEAR_CIRCUIT,		*)
(*		SET_ECHO, CLEAR_EDIT_CHARACTERS, SET_ALTERNATE_BREAK,	*)
(*		CHECK_CIRCUIT, CLEAR_BREAK_STATUS, SET_TIMEOUT		*)
(*                                                                      *)
(************************************************************************)
(*                                                                      *)
(*			     Revision Record				*)
(*									*)
(*	08Aug86 - jrn							*)
(*	      - add read_remark routine					*)
(*	31Jul86 - jrn							*)
(*	      - make WRITE_LOG_MESSAGE routine available to NVDM	*)
(*	03Feb86 - jrn							*)
(*	      - add general procedcures SEND, RECEIVE_LINE and		*)
(*		RECEIVE_CHARACTERS					*)
(*	27Jan86 - jrn							*)
(*	      - move write_command_prompt procedure to			*)
(*		internal_to_sting					*)
(*	01Nov85 - jrn							*)
(*	      - add send_errlog_message procedure			*)
(*	20Jul84 Version 3.0 - jrn/pgl					*)
(*	      - added procedures write_word, read_two_characters,	*)
(*		read_word						*)
(*	14Nov84 Version 2.02 - jrn					*)
(*	      - add read_list_description				*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - fix range error bug in use_circuit			*)
(*	      - on all routines that repeatedly call a routine to read	*)
(*		or write a page, check for error conditions before	*)
(*		going thru the loop again				*)
(*	29SEP83	Original from CIRC.BAS -- jrn				*)
(*									*)
(************************************************************************)


type
  logout_cause = (GENERAL_LOGOUT, TIMEDOUT_LOGOUT, LOST_CIRCUIT_LOGOUT);


type CIRCUIT_HANDLER = class(
	mutil	: misc_utility);

var
  device : circuit_device (* type of device, TERMINAL/AUX_CIRCUIT *);
  accept_status : ioresult_set (* acceptable results; otherwise, zap cir. *);

  entry current_timeout	: integer (* current read timeout *);
  entry unit		: integer (* specific circuit device being used *);
  entry param		: circuit_param (* parameter block of last io call *);
  entry available	: boolean (* whether or not a circuit is built *);
  entry break_pending	: boolean (* whether or not break was hit *);
  entry sendable	: boolean (* whether available & not break_pending *);
  entry logout_reason	: logout_cause;
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			   initialize_circuit				*)
(*									*)
(*	Set initial parameters for a just built circuit.		*)
(*									*)
(************************************************************************)

procedure initialize_circuit;

begin
  logout_reason := GENERAL_LOGOUT;
  available := TRUE;
  sendable := TRUE;
  break_pending := FALSE;
  current_timeout := 0
end (* initialize_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     reset_circuit				*)
(*									*)
(*	Reset parameters for a just freeed circuit.			*)
(*									*)
(************************************************************************)

procedure reset_circuit;

begin
  available := FALSE;
  sendable := FALSE;
  break_pending := FALSE
end (* reset_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			      zap_circuit				*)
(*									*)
(*	Zap circuit and set as not available.				*)
(*									*)
(************************************************************************)

procedure zap_circuit;

var
  dummy : char;
  param : circuit_param;

begin
  param.operation := CIRCUIT_DISCONNECT;
  io(dummy, param, device, unit);
  reset_circuit
end (* zap_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			      status_check				*)
(*									*)
(*	Check if status one of acceptable status. If not, zap circuit.	*)
(*									*)
(************************************************************************)

procedure status_check;

begin
  if param.status in accept_status
  then
    begin
      if param.status = BREAK_KEY
      then
	begin
	  break_pending := TRUE;
	  sendable := FALSE
	end (* param.status = BREAK_KEY *)
    end (* param.status in accept_status *)
  else
    begin (* unacceptable status received, zap this circuit *)
      if param.status = TIME_OUT
      then logout_reason := TIMEDOUT_LOGOUT
      else
        if param.status = FAILURE
	then logout_reason := LOST_CIRCUIT_LOGOUT;
      zap_circuit
    end
end (* status_check *);
!
(*************************  circuit_handler  ****************************)
(*									*)
(*				 login					*)
(*									*)
(*	Accept a login. 						*)
(*									*)
(************************************************************************)

procedure entry LOGIN(
      new_unit		: terminal_unit_index;
      new_accept_status	: ioresult_set;
  var login_info	: needle_record);

begin
  unit := new_unit;
  device := TERMINAL;
  accept_status := new_accept_status;
  repeat
    param.operation := CIRCUIT_GET_NEEDLE;
    param.arg1 := 0 (* no subhosts *);
    param.arg2 := 0 (* no time out waiting for needle *);
    io(login_info, param, device, unit)
  until param.status = COMPLETE;
  initialize_circuit
end (* login *);
"


(*************************  circuit_handler  ****************************)
(*									*)
(*			 build_normal_circuit 				*)
(*									*)
(*	Build a normal circuit.						*)
(*									*)
(************************************************************************)

procedure entry BUILD_NORMAL_CIRCUIT(
      new_unit			: aux_circuit_unit_index;
      new_accept_status		: ioresult_set;
      build_login_string	: login_string;
      build_timeout		: integer);

(*	The login string text is copied since 'io' requires that its	*)
(*	data buffer be writeable incase this is a write call.		*)

var
  io_login_text : login_text;

begin
  unit := new_unit;
  device := AUX_CIRCUIT;
  accept_status := new_accept_status;
  io_login_text := build_login_string.text;
  param.arg1 := build_login_string.size;
  param.arg2 := build_timeout;
  param.operation := CIRCUIT_NORMAL_REQUEST;
  io(io_login_text, param, device, unit);
  if param.status = COMPLETE
  then initialize_circuit
end (* build_normal_circuit *);
"


(*************************  circuit_handler  ****************************)
(*									*)
(*			   build_aux_circuit 				*)
(*									*)
(*	Build an auxiliary circuit.					*)
(*									*)
(************************************************************************)

procedure entry BUILD_AUX_CIRCUIT(
      new_unit			: aux_circuit_unit_index;
      new_accept_status		: ioresult_set;
      build_timeout		: integer;
  var build_login_string	: login_string);

begin
  unit := new_unit;
  device := AUX_CIRCUIT;
  accept_status := new_accept_status;
  param.arg1 := build_login_string.size;
  param.arg2 := build_timeout;
  param.operation := CIRCUIT_AUX_REQUEST;
  io(build_login_string.text, param, device, unit);
  if param.status = COMPLETE
  then initialize_circuit
end (* build_aux_circuit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*			      use_circuit 				*)
(*									*)
(*	Use an already built circuit.					*)
(*									*)
(************************************************************************)

procedure entry USE_CIRCUIT(
      new_unit		: univ integer;
      new_device	: circuit_device;
      new_accept_status	: ioresult_set);

begin
  unit := new_unit;
  device := new_device;
  accept_status := new_accept_status;
  initialize_circuit
end (* use_circuit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(*************************  circuit_handler  ****************************)
(*									*)
(*				send					*)
(*									*)
(*	Write to the circuit.						*)
(*									*)
(************************************************************************)

procedure send(
      length		: integer;
  var first_char	: char);

begin
  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := length;
    param.arg2 := 0 (* no timeout on write *);
    io(first_char, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* send *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   send_quoted_text				*)
(*									*)
(*	Write a string to the terminal. A string is a message without	*)
(*	a newline. The string text is terminated with an		*)
(*	end_message_character.						*)
(*									*)
(************************************************************************)

procedure send_quoted_text(
      string	: quoted_text);

var
  io_string : quoted_text;

begin
  io_string := string;
  send(mutil.quoted_text_size(string), io_string[0])
end (* send_quoted_text *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     send_newline				*)
(*									*)
(*	Write a newline to the circuit device.				*)
(*									*)
(************************************************************************)

procedure send_newline;

var
  newline : array [ 0..1 ] of char;

begin
  newline[0] := ASCII_CARRIAGE_RETURN;
  newline[1] := ASCII_LINE_FEED;
  send(2, newline[0])
end (* send_newline *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   write_quoted_text				*)
(*									*)
(*	Write a string to the terminal. A string is a message without	*)
(*	a newline. The string text is terminated with an		*)
(*	end_message_character.						*)
(*									*)
(************************************************************************)

procedure entry WRITE_QUOTED_TEXT(
      string	: quoted_text);

begin
  send_quoted_text(string)
end (* write_quoted_text *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			write_quoted_text_line				*)
(*									*)
(*	Write a message to the terminal. A message is a string		*)
(*	terminated with the end message character. Follow message	*)
(*	with a newline. 						*)
(*									*)
(************************************************************************)

procedure entry WRITE_QUOTED_TEXT_LINE(
      message	: quoted_text);

begin
  send_quoted_text(message);
  if sendable
  then send_newline
end (* write_quoted_text_line *);



(*************************  circuit_handler  ****************************)
(*									*)
(*		      write_line_and_quoted_text			*)
(*									*)
(*	Write a newline and a string to the terminal. A string is a	*)
(*	message without a newline following. The string text is		*)
(*	terminated with an end_message_character.			*)
(*									*)
(************************************************************************)


procedure entry WRITE_LINE_AND_QUOTED_TEXT(
      string	: quoted_text);

begin
  send_newline;
  if sendable
  then send_quoted_text(string)
end (* write_line_and_quoted_text *);



(*************************  circuit_handler  ****************************)
(*									*)
(*		     write_line_and_quoted_text_line			*)
(*									*)
(*	Write a newline and a message to the terminal. A message is a	*)
(*	string terminated with the end message character. Follow	*)
(*	message with a newline.						*)
(*									*)
(************************************************************************)

procedure entry WRITE_LINE_AND_QUOTED_TEXT_LINE(
      message	: quoted_text);

begin
  send_newline;
  if sendable
  then send_quoted_text(message);
  if sendable
  then send_newline
end (* write_line_and_quoted_text_line *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     write_newline				*)
(*									*)
(*	Write carriage return and linefeed to terminal. 		*)
(*									*)
(************************************************************************)

procedure entry WRITE_NEWLINE;

begin
  send_newline
end (* write_newline *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_format_buffer				*)
(*									*)
(*	Write a format_buffer to terminal.				*)
(*									*)
(************************************************************************)

procedure entry WRITE_FORMAT_BUFFER(
      data	: format_buffer);

var
  io_data : format_buffer;

begin
  io_data := data;
  send(io_data.size, io_data.text[0])
end (* write_format_buffer *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_one_character				*)
(*									*)
(*	Write a single character to the circuit.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_ONE_CHARACTER(
      byte	: char);

var
  io_byte : char;

begin
  io_byte := byte;
  send(1, io_byte)
end (* write_one_character *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_two_characters				*)
(*									*)
(*	Write the right half of the word to the circuit.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_TWO_CHARACTERS(
      word	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  io_word[0] := word[2];
  io_word[1] := word[3];
  send(2, io_word[0])
end (* write_two_characters *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			 write_three_characters				*)
(*									*)
(*	Write the three rightmost characters to the circuit.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_THREE_CHARACTERS(
      characters	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  io_word[0] := characters[1];
  io_word[1] := characters[2];
  io_word[2] := characters[3];
  send(3, io_word[0])
end (* write_three_characters *);



(*************************  circuit_handler  ****************************)
(*									*)
(*				write_word				*)
(*									*)
(*      Output 4 bytes							*)
(*									*)
(************************************************************************)

procedure entry WRITE_WORD(
      word	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  io_word := word;
  send(MAXIMUM_BYTES_IN_WORD, io_word[0])
end (* write_word *);


  
(*************************  circuit_handler  ****************************)
(*									*)
(*			     write_mud_data				*)
(*									*)
(*	Write bytes_to_write from the MUD block to the circuit.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_MUD_DATA(
      bytes_to_write	: cud_data_size;
  var data		: cud_data);

begin
  send(bytes_to_write, data[0])
end (* write_mud_data *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_log_message				*)
(*									*)
(*	Write a log_message to terminal.				*)
(*									*)
(************************************************************************)

procedure entry WRITE_LOG_MESSAGE(
  var data	: log_message);

begin
  send(data.size, data.text[0])
end (* write_log_message *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*		 	write_class_group_table				*)
(*									*)
(*	Write class/group table to the circuit by pages.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_CLASS_GROUP_TABLE(
  var data	: univ table_in_bytes);

begin
  send(TABLE_LENGTH, data[0])
end (* write_class_group_table *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  send_errlog_message				*)
(*									*)
(*      Send a message to the Supervisor error log.			*)
(*									*)
(************************************************************************)

procedure entry SEND_ERRLOG_MESSAGE(
      kind	: char;
      data1	: char;
      data2	: halfword);

var  
  msg : errlog_message;
  param : circuit_param;

begin
  msg.data2 := data2;
  msg.kind := kind;
  msg.data1 := data1;
  msg.pid := NETVAL_PRODUCT_ID;
  param.operation := CIRCUIT_SUP_LOG_MESSAGE;
  io(msg, param, AUX_CIRCUIT, 0)
end (* send_errlog_message *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(*************************  circuit_handler  ****************************)
(*									*)
(*			     receive_line 				*)
(*									*)
(*	Read a line with editting.					*)
(*									*)
(************************************************************************)

procedure receive_line(
      max_length	: integer;
  var first_char	: char);

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_LINE;
    param.arg1 := max_length;
    param.arg2 := current_timeout;
    io(first_char, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* receive_line *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   read_command_line 				*)
(*									*)
(*	Read a line with editting.					*)
(*									*)
(************************************************************************)

procedure entry READ_COMMAND_LINE(
  var input_line	: command_line);

begin
  receive_line(COMMAND_LINE_TEXT_MAX, input_line.text[0]);
  if param.arg2 > COMMAND_LINE_TEXT_MAX
  then
    begin (* guarantee that the line terminates with a carriage return *)
      input_line.size := COMMAND_LINE_TEXT_MAX;
      input_line.text[COMMAND_LINE_TEXT_LIMIT] := ASCII_CARRIAGE_RETURN
    end
  else input_line.size := param.arg2
end (* read_command_line *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   receive_characters 				*)
(*									*)
(*	Read into an array of characters.				*)
(*									*)
(************************************************************************)

procedure receive_characters(
      max_length	: integer;
  var first_char	: char);

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_CHARACTER;
    param.arg1 := max_length;
    param.arg2 := current_timeout;
    io(first_char, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* receive_characters *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   read_one_character 				*)
(*									*)
(*	Read a single character.					*)
(*									*)
(************************************************************************)

procedure entry READ_ONE_CHARACTER(
  var byte	: char);

begin
  receive_characters(1, byte)
end (* read_one_character *);


 
(*************************  circuit_handler  ****************************)
(*									*)
(*			 read_three_characters 				*)
(*									*)
(*	Read three characters and store them right justified.		*)
(*									*)
(************************************************************************)

procedure entry READ_THREE_CHARACTERS(
  var characters	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  receive_characters(3, io_word[0]);
  characters[0] := ZERO;
  characters[1] := io_word[0];
  characters[2] := io_word[1];
  characters[3] := io_word[2]
end (* read_three_characters *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     read_mud_data 				*)
(*									*)
(*	Read a MUD block.						*)
(*									*)
(************************************************************************)

procedure entry READ_MUD_DATA(
  var buffer	: cud_disk_block);

begin
  receive_characters(MAXIMUM_CUD_DATA, buffer.data[0])
end (* read_mud_data *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*			 read_password_string 				*)
(*									*)
(*	Read a password string with editting.				*)
(*									*)
(************************************************************************)

procedure entry READ_PASSWORD_STRING(
  var password : password_string);

begin
  receive_line(PASSWORD_TEXT_MAX, password.text[0]);
  if param.arg2 > PASSWORD_TEXT_MAX
  then password.size := PASSWORD_TEXT_MAX
  else password.size := param.arg2 - 1 (* remove carriage return *)
end (* read_password_string *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*************************  circuit_handler  ****************************)
(*									*)
(*			     read_remark 				*)
(*									*)
(*	Read a remark with editting.					*)
(*									*)
(************************************************************************)

procedure entry READ_REMARK(
  var remark : oplog_remark_message);

begin
  receive_line(OPLOG_REMARK_LENGTH, remark.chars[0]);
  if param.arg2 > OPLOG_REMARK_LENGTH
  then remark.size := OPLOG_REMARK_LENGTH
  else remark.size := param.arg2 - 1 (* remove carriage return *)
end (* read_remark *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*			 read_two_characters 				*)
(*									*)
(*	Read two characters and store them right justified.		*)
(*									*)
(************************************************************************)

procedure entry READ_TWO_CHARACTERS(
  var characters	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  receive_characters(2, io_word[0]);
  characters[0] := ZERO;
  characters[1] := ZERO;
  characters[2] := io_word[0];
  characters[3] := io_word[1]
end (* read_two_characters *);


 
(*************************  circuit_handler  ****************************)
(*									*)
(*				read_word 				*)
(*									*)
(*	Input 4 bytes.							*)
(*									*)
(************************************************************************)

procedure entry READ_WORD(
  var word	: univ word_in_bytes);

begin
  receive_characters(MAXIMUM_BYTES_IN_WORD, word[0])
end (* read_word *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			read_class_group_table 				*)
(*									*)
(*	Read a Supervisor Class/group table.				*)
(*									*)
(************************************************************************)

procedure entry READ_CLASS_GROUP_TABLE(
  var data	: univ table_in_pages);

var
  page_index : table_page_index;

begin
  for page_index := 0 to TABLE_PAGE_LIMIT do
    receive_characters(PAGE_SIZE, data[page_index][0])
end (* read_class_group_table *);
!



(*************************  circuit_handler  ****************************)
(*									*)
(*			     wait_for_input 				*)
(*									*)
(*	Return when user has typed any characters and carriage return	*)
(*	or a <break>.							*)
(*									*)
(************************************************************************)

procedure entry WAIT_FOR_INPUT;

var
  dummy : char;

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_LINE;
    param.arg1 := 1;
    param.arg2 := current_timeout;
    io(dummy, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* wait_for_input *);



(*************************  circuit_handler  ****************************)
(*									*)
(*				set_echo				*)
(*									*)
(*	Set echo on or off.						*)
(*									*)
(************************************************************************)

procedure entry SET_ECHO(
      echo_on	: boolean);

var
  dummy: char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  if echo_on
  then param.arg1 := 1
  else param.arg1 := 0;
  io(dummy, param, device, unit)
end (* set_echo *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*			    wait_for_output				*)
(*									*)
(*	Send a yellow ball out over the circuit and wait for the	*)
(*	return of an orange ball.					*)
(*									*)
(************************************************************************)

procedure entry WAIT_FOR_OUTPUT;

var
  dummy: char;

begin
(* first send a yellow ball... *)
  param.operation := CIRCUIT_YELLOW_BALL;
  io(dummy, param, device, unit);
  status_check;

  repeat
    param.operation := CIRCUIT_DETECT (* detect ORANGE ball *);
    io(dummy, param, device, unit);
    status_check;
    wait
  until (param.status = ORANGE_BALL) or not available
end (* wait_for_output *);
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			     clear_circuit				*)
(*									*)
(*	Clear circuit if not allready cleared and return to login ring. *)
(*									*)
(************************************************************************)

procedure entry CLEAR_CIRCUIT;

begin
  zap_circuit
end (* clear_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			      set_console				*)
(*									*)
(*	Make this the console terminal for runtime errors.		*)
(*									*)
(************************************************************************)

procedure entry SET_CONSOLE;

var
  dummy : char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  param.arg1 := SYS_CONS;
  io(dummy, param, device, unit)
end (* set_console *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   set_crt_terminal				*)
(*									*)
(*	Set handling of backspace for CRT terminal.			*)
(*									*)
(************************************************************************)

procedure entry SET_CRT_TERMINAL;

var
  dummy : char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  param.arg1 := SET_CRT;
  io(dummy, param, device, unit)
end (* set_crt_terminal *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*			 clear_edit_characters				*)
(*									*)
(*	Used for I/O over auxilliary circuits.				*)
(*									*)
(************************************************************************)

procedure entry CLEAR_EDIT_CHARACTERS;

var
  dummy : char;
  arg1_value : CHAR_DEL..LINE_DEL;

begin
  for arg1_value := CHAR_DEL to LINE_DEL do 
    begin
      param.operation := CIRCUIT_SET_UNIT;
      param.arg1 := arg1_value;
      param.arg2 := 0 (* clear this edit character *);
      io(dummy, param, device, unit)
    end (* for *)
end (* clear_edit_characters *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*			  set_alternate_break				*)
(*									*)
(*	Set an alternate character for the break function.		*)
(*									*)
(************************************************************************)

procedure entry SET_ALTERNATE_BREAK(
      other	: char);

var
  io_other : char;

begin
  io_other := other;
  param.operation := CIRCUIT_SET_ALTERNATE_BREAK;
  io(io_other, param, device, unit)
end (* set_alternate_break *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     check_circuit				*)
(*									*)
(*	Check if circuit available.					*)
(*									*)
(************************************************************************)

procedure entry CHECK_CIRCUIT;

var
  dummy: char;

begin
  param.operation := CIRCUIT_INFO;
  param.arg2 := 0;
  io(dummy, param, device, unit);
  status_check
end (* check_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   clear_break_status				*)
(*									*)
(*	Clear the pending break in param so that other operations can	*)
(*	happen. This is the programs acknowledgement of the break.	*)
(*									*)
(************************************************************************)

procedure entry CLEAR_BREAK_STATUS;

var
  dummy: char;

begin
  param.operation := CIRCUIT_CLEAR_BREAK;
  io(dummy, param, device, unit);
  break_pending := FALSE;
  sendable := TRUE;
  status_check
end (* clear_break_status *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			      set_timeout				*)
(*									*)
(*	Set timeout to be used on all read operations.			*)
(*									*)
(************************************************************************)

procedure entry SET_TIMEOUT(
      new_timeout	: integer);

begin
  current_timeout := new_timeout
end (* set_timeout *);
!
(*************************  circuit_handler  ****************************)
(************************************************************************)

begin (* initial statement *)
  reset_circuit
end (* circuit_handler *);
!
(************************************************************************)
(*									*)
(*	FORM.NTV							*)
(*									*)
(*			   internal_to_string				*)
(*									*)
(*    This class converts various internal representations to		*)
(*    strings of type format_buffer.					*)
(*									*)
(***** BE AWARE OF FORMAT_BUFFER_TEXT_MAX, DEFINED IN GLOBL.NTV;    *****)
(***** THIS IS THE MAXIMUM NUMBER OF CHARACTERS THAT CAN BE ADDED   *****)
(***** TO THE BUFFER; A RANGE ERROR WILL OCCUR IF THIS IS EXCEEDED. *****)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	03Sep86 - neh							*)
(*	      - Add the procedures PUT_MESSAGE_KIND, to output the	*)
(*		operator message type description and			*)
(*		PUT_MODIFY_DESCRIPTION, to output the description of	*)
(*		of the cud change modifcation type from the operator	*)
(*		log messages.						*)
(*	      - Change UN2_SUP_ERROR to remove the addition of       	*)
(*		of "UN2 error on Supervisor" and the supervisor number 	*)
(*     	      - Change SYSMSG1_ERROR to remove the addition of	 	*)
(*		"SYSMSG1 error on Supervisor" and the supervisor number *)
(*	      - Change CONSISTENCY_ERROR to remove the addition of 	*)
(*		the string "Supervisor" and the supervisor number 	*)
(*      03Sep86 - jrn                                                   *)
(*            - allow SET GFD ONLY and CHANGE UUN AND GAN CUD changes   *)
(*              available if not Tymshare CUD format (for BUBBNET)      *)
(*	18Jul86 - jrn							*)
(*	      - add CUD_ENTRY_IN_WRONG_BLOCK to cud_entry_status	*)
(*		procedure						*)
(*	24Jan86 - jrn							*)
(*	      - add PROMPT procedure					*)
(*	      - add COMMAND_STRING and KEYWORD_STRING procedures	*)
(*	      - change HELP_TEXT_STRING to accomodate removal of help	*)
(*		text size						*)
(*	23Jan86	- rsb							*)
(*		- un2_sup_error:  add "un2_supervisor_not_in_		*)
(*		  pseudo_sup_table" to case statement:			*)  
(*		  put_string an error message, then 			*)
(*		  crash_utility.halt_slot				*)
(*	21Jan86 - jrn							*)
(*	      - add BY_VALIDATOR procedure				*)
(*	      - add put_unit_and_sector and UNIT_AND_SECTOR procedures	*)
(*		and make use of put_unit_and_sector in CUD_BLOCK_ERROR	*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	23Dec85	- change every "sup : supervisor_index" to		*)
(*                 "real_sup          : real_supervisor_index;"		*)
(*		  and every "sup" to "real_sup" for USN.		*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	13Nov85 - jrn							*)
(*	      - add host_state_name procedure				*)
(*	15Feb85 - jrn							*)
(*	      - add CUD_ENTRY_ILLEGAL_NAME to cud_entry_status routine 	*)
(*	22Jan85 - version 3.00 pgl					*)
(*	      - if LOGICAL_VOLUMES, add lvol_state			*)
(*	      - added put_basic_time and no_sec_time			*)
(*	27Nov84 - version 3.00 pgl					*)
(*	      - add procedure cud_parameter_file_status			*)
(*	02Oct84 - version 3.00	neb					*)
(*	      - add conditional change types to CUD_CHANGE_DESCRIPTION  *)
(*		for netval_is_a_slave and tymshare_cud_format		*)
(*	27Nov84 - jrn							*)
(*	      - change message for type node_host_utility_status, value	*)
(*		NODE_HOST_BEING_UPDATED in routine named_list_status	*)
(*	01Aug84 - jrn							*)
(*	      - add CUD_PARAMETER_FILE to put_file_name routine		*)
(*	      - add ansii_tape_label_chars and ansii_tape_label_date	*)
(*		routines						*)
(*	      - add list_description					*)
(*	      - list_name reflects change made to named_list_name	*)
(*	      - add NODE_HOST_BAD_CHECKSUM and delete 			*)
(*	        NODE_HOST_HEADER_ERROR and NODE_HOST_FORMAT_ERROR	*)
(*		to named_list_status					*)
(*	20Jul84 Version 3.0     jrn/pgl					*)
(*	      - added MASTER_VALIDATOR to validator_type_name		*)
(*	      - added procedures tymcom_ix_slave_error,	 		*)
(*		cud_change_description and build_error			*)
(*	10Jul84 Version 2.02	jrn					*)
(*	      - add report_file_error for NVDM				*)
(*	      - fixed format_number routine bug				*)
(*	      - added AUDITOR_LICENSE, OPERATOR_LICENSE			*)
(*	      - consolidated common string messages			*)
(*	      - added procedure criteria_name 				*)
(*	      - renamed procedures short_control_bit_name and		*)
(*	    	control_bit_name to short_control_option_name and	*)
(*		control_option_name 					*)
(*	      - added LICENSED and PASSWORD_ONLY control_options	*)
(*	      - added CUD_ENTRY_OVERFLOW_FOUND to cud_entry_status 	*)
(*									*)
(*	29SEP83 Original (from form.bas) -- jrn 			*)
(*									*)
(************************************************************************)



type INTERNAL_TO_STRING = class


const
  DIGITS_IN_MAX_DECIMAL_INTEGER = 10;
  DIGITS_IN_MAX_HEX_INTEGER = 8;
  DIGITS_IN_MAX_OCTAL_INTEGER = 10;


  circuit_build_error = 'circuit build error: \';
  circuit_error = 'circuit error: \';
  cud_block_shut = 'programmer has block locked\';
  file_busy = 'file busy\';
  io_failure = 'I/O operation failed\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  lost_circuit = 'lost circuit\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  system_unavailable = 'system unavailable\ ';
  timed_out = 'timed out\';
  unrecognized_input = 'unrecognized input\ ';
  user_not_found = 'user not found\ ';


var
  calendar : date_time_converter;

  entry buffer : format_buffer (* all conversion into here *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			    put_character				*)
(*									*)
(*    Put character in buffer.text[size].				*)
(*									*)
(************************************************************************)

procedure put_character(
      c	: char);

begin
  buffer.text[buffer.size] := c;
  buffer.size := buffer.size + 1
end (* put_character *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			       put_string				*)
(*									*)
(*    Put string into buffer.						*)
(*									*)
(************************************************************************)

procedure put_string(
      string_to_insert	: quoted_text);

var
  i: quoted_text_index;

begin
  i := 0;
  while string_to_insert[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(string_to_insert[i]);
      i := i + 1
    end (* while *)
end (* put_string *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			       put_number				*)
(*									*)
(*    Convert number to string and store in buffer.			*)
(*									*)
(************************************************************************)

procedure put_number(
      number_to_convert	: integer;
      radix		: integer);

var
  s : array [1..11] of integer;
  positive_number : integer;
  n : integer;
  i : integer;
  negative : boolean;

begin
  positive_number := number_to_convert;
  negative := positive_number < 0;
  if negative
  then
    if (radix = 16) or (radix = 8)
    then positive_number := (positive_number + MAX_INTEGER) + 1
    else positive_number := -positive_number;

  n := 0;
  repeat
    n := n + 1;
    s[n] := positive_number mod radix;
    positive_number := positive_number div radix
  until positive_number = 0;

  if negative
  then
    if radix = 8
    then
      begin
	for i := n + 1 to 11 do
	  s[i] := 0;
	n := 11;
	s[11] := s[11] + 2 (* put sign bit back in last character *)
      end
    else if radix = 16
    then
      begin
	for i := n + 1 to 8 do
	  s[i] := 0;
	n := 8;
	s[8] := s[8] + 8 (* put sign bit back *)
      end
    else put_character(ASCII_MINUS);

  for i := n downto 1 do
    if s[i] < 10
    then put_character(chr(ord(ASCII_ZERO) + s[i]))
    else put_character(chr(ord(ASCII_A) + s[i] - 10))
end (* put_number *);



(************************  internal_to_string  **************************)
(*									*)
(*			    put_scaled_number				*)
(*									*)
(*    Convert a number to a string with a radix point a given number	*)
(*    of places to the left of the right of the number. I.e, a call	*)
(*    of scaled_number(1234, 10, 1) will produce the number 123.4	*)
(*									*)
(************************************************************************)

procedure put_scaled_number(
      number_to_convert	: integer;
      radix		: integer;
      radix_place	: integer);

var
  fraction : integer;
  scale : integer;
  i : integer;

begin
  scale := 1 (* construct scale factor from radix places *);
  for i := 1 to radix_place do
    scale := scale*radix;
  put_number(number_to_convert div scale, radix);
  put_character(ASCII_DOT);
  fraction := abs(number_to_convert mod scale);
  scale := scale div radix;
  while scale > fraction do (* output leading zeros of fraction *)
    begin
      put_character(ASCII_ZERO);
      scale := scale div radix
    end (* while *);
  if fraction > 0
  then put_number(fraction, radix)
end (* put_scaled_number *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			   put_colon_space				*)
(*									*)
(*    Put colon, space in buffer.					*)
(*									*)
(************************************************************************)

procedure put_colon_space;

begin
  put_character(ASCII_COLON);
  put_character(ASCII_SPACE)
end (* put_colon_space *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			     put_newline				*)
(*									*)
(*    Put carriage return linefeed in buffer.				*)
(*									*)
(************************************************************************)

procedure put_newline;

begin
  put_character(ASCII_CARRIAGE_RETURN);
  put_character(ASCII_LINE_FEED)
end (* put_newline *);



(************************  internal_to_string  **************************)
(*									*)
(*			       put_supervisor 				*)
(*									*)
(*    Convert a supervisor_index to a string.				*)
(*									*)
(************************************************************************)

procedure put_supervisor(
  real_sup          : real_supervisor_index);

begin
  put_number(real_sup + PRINT_SUPERVISOR_OFFSET, 10)
end (* put_supervisor *);



(***********************   internal_to_string	*************************)
(*									*)
(*			     put_format_number				*)
(*									*)
(*    Convert a number to a string of max_places characters.		*)
(*    If number_to_print is negative or too bit, output *'s.		*)
(*    If max_places is negative, display leading zeros.			*)
(*    Otherwise, display leading blanks.				*)
(*									*)
(************************************************************************)

procedure put_format_number(
      number_to_print	: integer;
      radix 		: integer;
      max_places	: integer);

var
  zero_fill : boolean (* TRUE if field should be zero filled *);
  number_fits : boolean (* TRUE if number_to_print fits in max_places *);
  places_to_print,
  length_required,	(* places required to output number_to_print *)
  n : integer;

begin
  zero_fill := max_places < 0;
  places_to_print := abs(max_places);
  if number_to_print < 0
  then number_fits := FALSE
  else
    begin
      number_fits := TRUE; length_required := 1; n := radix;
      while number_fits and (n <= number_to_print) do
        begin
	  length_required := length_required + 1;
	  number_fits := length_required <= places_to_print;
	  n := n * radix
	end (* while *);
      if number_fits
      then
        for n := 1 to (places_to_print - length_required) do
	  if zero_fill
	  then put_character(ASCII_ZERO)
	  else put_character(ASCII_SPACE)
    end (* number_to_print >= 0 *);
  if number_fits
  then put_number(number_to_print, radix)
  else
    for n := 1 to places_to_print do
      put_character('*')
end (* put_format_number *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			    put_basic_time				*)
(*									*)
(*    Convert ISIS time to character string - MM/DD/YY HH:MM		*)
(*									*)
(************************************************************************)

procedure put_basic_time(
      time_to_convert	: integer;
  var date_time		: print_time);

begin
  calendar.date_from_isis_time(time_to_convert, date_time);
  with date_time do
    begin
      put_format_number(month, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(day, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(year mod 100, 10, -2);
      put_character(ASCII_SPACE);
      put_format_number(hour, 10, -2);
      put_character(ASCII_COLON);
      put_format_number(minute, 10, -2)
    end
end (* put_basic_time *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			      put_time					*)
(*									*)
(*    Convert ISIS time to character string - MM/DD/YY HH:MM		*)
(*									*)
(************************************************************************)

procedure put_time(
      time_to_convert	: integer);

var
  date_time: print_time;

begin
  put_basic_time(time_to_convert, date_time);
  with date_time do
    begin
      put_character(ASCII_COLON);
      put_format_number(second, 10, -2)
    end (* with *)
end (* put_time *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			      put_isis_error				*)
(*									*)
(************************************************************************)

procedure put_isis_error(
      error	: integer);

begin
  if (error <= 0) or (error > 24)
  then
    begin
      put_string('undefined error: \');
      put_number(error, 10)
    end
  else
    case error of
      1:  put_string('bad memory address\ ');
      2:  put_string('no access allowed to unit\');
      3:  put_string('read/write/attach protection failure\ ');
      4:  put_string('virtual block out of allocated area on disk\');
      5:  put_string('kernel tables VBN past EOV\ ');
      6:  put_string('kernel tables cyliner overflow past EOV\');
      7:  put_string('error return from unit\ ');
      8:  put_string('error return from controller\ ');
      9:  put_string('operation aborted\');
      10: put_string('requested byte count 0 or odd\');
      11: put_string('invalid cylinder overflow indication\ ');
      12: put_string('defective sector in alternate cylinder\ ');
      13: put_string('defective sector, and no alternate cylinders\ ');
      14: put_string('cylinder map not readable\');
      15: put_string('defective cylinder; alternate assigned\ ');
      16: put_string('end of file detected\ ');
      17: put_string('end of volume detected\ ');
      18: put_string('device unavailable\ ');
      19: put_string(WRITE_PROTECTED_MESSAGE);
      20: put_string('unit attached, but it is write protected\ ');
      21: put_string('unit attached to another slot\');
      22: put_string('operation ignored for this unit\');
      23: put_string(TIMED_OUT);
      24: put_string('recovered error correcting code error\')
    end (* case *)
end (* put_isis_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  internal_to_string  ***************************)
(*									*)
(*		              put_date					*)
(*									*)
(*    Convert ISIS time to character string.				*)
(*									*)
(************************************************************************)

procedure put_date(
      date_time	: print_time);

begin
  with date_time do
    begin
      put_format_number(month, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(day, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(year mod 100, 10, -2);
    end (* with *)
end (* put_date *);


(************************  internal_to_string  **************************)
(*									*)
(*				  date     				*)
(*									*)
(*      convert ISIS time to character string w/o min and sec		*)
(*									*)
(************************************************************************)

procedure entry DATE(
      time_to_convert	: integer);

var
 date_time : print_time;

begin
  calendar.date_from_isis_time(time_to_convert, date_time);
  put_date(date_time);
end (* date *);



(************************  internal_to_string  **************************)
(*									*)
(*			  ansii_tape_label_date				*)
(*									*)
(*      Convert supplied ISIS time to "YYDDD" for ANSII standard tape	*)
(*	HDR1 label.							*)
(*									*)
(************************************************************************)

procedure entry ANSII_TAPE_LABEL_DATE(
      time_to_convert	: integer);

var
 date_time : print_time;

begin
  calendar.date_from_isis_time(time_to_convert, date_time);
  with calendar, date_time do
    begin
      put_format_number(year mod 100, 10, -2);
      day := days_to_month(month, leap_year(year)) + day;
      put_format_number(date_time.day, 10, -3)
    end
end (* ansii_tape_label_date *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			      short_time				*)
(*									*)
(*    Convert ISIS time to character string - MM/DD HH:MM		*)
(*									*)
(************************************************************************)

procedure entry SHORT_TIME(
      time_to_convert	: integer);

var
  date_time: print_time;

begin
  calendar.date_from_isis_time(time_to_convert, date_time);
  with date_time do
    begin
      put_format_number(month, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(day, 10, -2);
      put_character(ASCII_SPACE);
      put_format_number(hour, 10, -2);
      put_character(ASCII_COLON);
      put_format_number(minute, 10, -2)
    end (* with *)
end (* short_time *);



(***********************  internal_to_string ****************************)
(*									*)
(*			 cud_change_description				*)
(*									*)
(*      Add the description of the CUD change to the buffer		*)
(*									*)
(************************************************************************)

procedure entry CUD_CHANGE_DESCRIPTION(
      change	: cud_change_indicator);

begin
  case change of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    NEW_USER_CUD_CHANGE:		put_string('new user\ ');
    CHANGE_GAN_CUD_CHANGE:		put_string('change GAN\ ');
    CHANGE_PASSWORD_CUD_CHANGE:		put_string('change password\');
    RENAME_DELETE_USER_CUD_CHANGE:	put_string('rename user (delete)\ ');
    RENAME_RESTORE_OLD_NAME:	    put_string('restore old name (rename)\');
    RENAME_NEW_USER_CUD_CHANGE:		put_string('rename user (add)\');
    DELETE_USER_CUD_CHANGE:		put_string('delete user\');
    CHANGE_OPTIONS_CUD_CHANGE:		put_string('change options\ ');
    CHANGE_DISTRICT_CUD_CHANGE:		put_string('change district\');
    CHANGE_UUN_CUD_CHANGE:		put_string('change UUN\ ');
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CHANGE_ACCESS_CUD_CHANGE:		put_string('change access\')
  end (* case *)
end (* cud_change_description *);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)



(************************  internal_to_string  **************************)
(*									*)
(*			   validator_type_name 				*)
(*									*)
(************************************************************************)

procedure entry VALIDATOR_TYPE_NAME(
      validator_level	: validator_type);

begin
  case validator_level of
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
    PASSWORD_ONLY_VALIDATOR: put_string(PASSWORD_ONLY_MESSAGE);
    ACCOUNT_SUPERVISOR_VALIDATOR: put_string(ACCOUNT_SUPERVISOR_MESSAGE);
    NETWORK_ADMINISTRATOR_VALIDATOR: put_string(NETWORK_ADMINISTRATOR_MESSAGE);
    PROGRAMMER_VALIDATOR: put_string(PROGRAMMER_MESSAGE)
  end (* case *)
end (* validator_type_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			 short_control_option_name			*)
(*									*)
(*    Generate short name string from control_options.			*)
(*									*)
(************************************************************************)

procedure entry SHORT_CONTROL_OPTION_NAME(
      option	: control_options);

begin
  case option of
    ACCOUNT_SUPERVISOR:		put_string('as\ ');
    IGNORE_HOST:		put_string('ih\ ');
    NETWORK_ADMINISTRATOR:	put_string('na\ ');
    NO_PASSWORD:		put_string('np\ ');
    SHUT_OVERRIDE:		put_string('so\ ');
    AUDITOR:			put_string('au\ ');
    OPERATOR:			put_string('op\ ');
    TRANSPARENT_LOGIN:		put_string('tl\ ')
  end (* case *)
end (* short_control_option_name *);



(*************************  internal_to_string  *************************)
(*									*)
(*				criteria_name				*)
(*									*)
(*      Generates name string from criteria_type.			*)
(*									*)
(************************************************************************)

procedure entry CRITERIA_NAME(
      criteria_index	: criteria_type);

begin
  case criteria_index of
    ALL_CRITERIA:		(* null *);
    ACCESS_CRITERION:		put_string('access\ ');
    GAN_CRITERION:		put_string('GAN\');
    DISTRICT_CRITERION:		put_string('district\ ');
    UUN_CRITERION:		put_string('UUN\');
    CONTROL_CRITERION:		put_string('control\');
    ENTRYDATE_CRITERION:	put_string('entrydate\');
    PASSWORDDATE_CRITERION:	put_string('passworddate\ ')
  end (* case *)
end (* criteria_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			     control_option_name			*)
(*									*)
(*    Generate name string from control_options.			*)
(*									*)
(************************************************************************)

procedure entry CONTROL_OPTION_NAME(
      option_index	: control_options);

begin
  case option_index of
    LICENSED:			put_string(LICENSED_MESSAGE);
    PASSWORD_ONLY:		put_string(PASSWORD_ONLY_MESSAGE);
    ACCOUNT_SUPERVISOR:		put_string(ACCOUNT_SUPERVISOR_MESSAGE);
    IGNORE_HOST:		put_string(IGNORE_HOST_MESSAGE);
    NETWORK_ADMINISTRATOR:	put_string(NETWORK_ADMINISTRATOR_MESSAGE);
    NO_PASSWORD:		put_string('no password\');
    SHUT_OVERRIDE:		put_string(SHUT_OVERRIDE_MESSAGE);
    AUDITOR:			put_string(AUDITOR_MESSAGE);
    OPERATOR:			put_string(OPERATOR_MESSAGE);
    TRANSPARENT_LOGIN:		put_string(TRANSPARENT_LOGIN_MESSAGE)
  end (* case *)
end (* control_option_name *);



(************************  internal_to_string  **************************)
(*									*)
(*				listname        			*)
(*									*)
(*      put listname into buffer                                        *)
(*									*)
(************************************************************************)

procedure entry LISTNAME(
      name	: named_list_name);

var
  i : named_list_name_index;

begin
  for i := 0 to name.size - 1 do
    put_character(name.text[i])
end (* listname *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*                                                                      *)
(*                          put_message_kind                            *)
(*                                                                      *)
(*      This procedure outputs the message type description for the     *)
(*      message kind passed to it.                                      *)
(*                                                                      *)
(************************************************************************)

procedure entry PUT_MESSAGE_KIND(
        kind    : oper_log_message_kind);

begin
  case kind of
    DEBUGGING_OPLOG_MSG:         put_string('debug\');
    VALIDATOR_OPLOG_MSG:         put_string('validator\');
    FILE_OPLOG_MSG:              put_string('file\ ');
    CUD_OPLOG_MSG:               put_string('CUD error\');
    MUDUPD_OPLOG_MSG:            put_string('mudupdate\');
    UN2_OPLOG_MSG:               put_string('UN2\');
    CONSISTENCY_OPLOG_MSG:       put_string('consistency\');
    SYSMSG1_OPLOG_MSG:           put_string('SYSMSG1\');
    ARCHIVE_OPLOG_MSG:           put_string('archive\');
    UNUSED1_OPLOG_MSG:           (* null statement *);

    CUD_PARAM_OPLOG_MSG:         put_string('PARAMETER\');
    LV_OPLOG_MSG:                put_string('volumes\');
    MASTER_OPLOG_MSG:            put_string('MASTER\ ');
    OPERLOG_REPORT_MSG:          put_string('operator\ ');
    MERGE_UUN_OPLOG_MSG:         put_string('merge uun\')
 ; MODIFY_CUD_OPLOG_MSG:        put_string('modify\ ')
  end  (* case *)
end (* put_message_kind *);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)



(************************  internal_to_string  **************************)
(*                                                                      *) 
(*                      put_modify_description                          *)
(*                                                                      *) 
(*      This procedure outputs the description of the modify type       *)
(*      corresponding to the modify_index.                              *)
(*                                                                      *)
(************************************************************************)

procedure entry PUT_MODIFY_DESCRIPTION(
        modify  : modify_type);
  
begin
  case modify of
    ACCESS:              put_string('access\ ');
    CONTROL:             put_string('control\');
    DISTRICT:            put_string('district\ ');
    GAN:                 put_string('gan\');
    CHANGENAME:          put_string('name\ ');
    PASSWORD:            put_string('password\ ');
    UUN:                 put_string('UUN\');
    DELETE:              put_string('delete user\');
    NEW:                 put_string('new user\ ')
  end (* case *)
end (* put_modify_description *);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)



(***********************  internal_to_string  ***************************)
(*									*)
(*				  time					*)
(*									*)
(*    Convert ISIS time to character string.				*)
(*									*)
(************************************************************************)

procedure entry TIME(
      time_to_convert	: integer);

begin
  put_time(time_to_convert)
end (* time *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			  disk_operation_name				*)
(*									*)
(*    Print name for disk operation.					*)
(*									*)
(************************************************************************)

procedure entry DISK_OPERATION_NAME(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      operation	: disk_operation);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  case operation of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  DISK_READ:  put_string('read\ ');
  DISK_WRITE: put_string('write\')
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  end (* case *)
end (* disk_operation_name *);



(***********************   internal_to_string	*************************)
(*									*)
(*			     welcome_message				*)
(*									*)
(************************************************************************)

procedure entry WELCOME_MESSAGE(
      welcome_string	: quoted_text);

begin
  put_newline; put_newline;
  put_string(welcome_string);
  put_scaled_number(version*100+revision, 10, 2);
  put_string(' at \ ');
  put_time(REALTIME)
end (* welcome_message *);



(************************  internal_to_string  **************************)
(*									*)
(*			     put_file_name				*)
(*									*)
(*      Add file name to buffer.					*)
(*									*)
(************************************************************************)

procedure put_file_name(
      file	: file_index);

begin
  case file of
    CUD_FILE:		put_string(CUD_FILE_MESSAGE);
    CUD_PARAMETER_FILE:	put_string('CUD_PARAMETER\');
    CONFIGURATION_FILE:	put_string('configuration\');
    NODE_HOST_FILE:	put_string('node_host\');
    CLASS_GROUP_FILE:	put_string('class_group\');
    OPERLOG_FILE:	put_string('oper_log\ ');
    MUD_UPDATE_FILE:	put_string('mud_update\ ')
  end (* case *)
end (* put_file_name *);



(************************  internal_to_string  **************************)
(*									*)
(*				file_name				*)
(*									*)
(*      Add file name to buffer.					*)
(*									*)
(************************************************************************)

procedure entry FILE_NAME(
      file	: file_index);

begin
  put_file_name(file)
end (* file_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			     ioresult_name				*)
(*									*)
(*    Generate status name string from ioresult.			*)
(*									*)
(************************************************************************)

procedure ioresult_name(
      status	: ioresult);

begin
  case status of
    COMPLETE:      put_string(COMPLETE_MESSAGE);
    INTERVENTION:  put_string('intervention required\');
    TRANSMISSION:  put_string('transmission error\ ');
    FAILURE:       put_string('device failure\ ');
    END_FILE:      put_string('end of file detected\ ');
    END_MEDIUM:    put_string('end of volume detected\ ');
    START_MEDIUM:  put_string('start medium\ ');
    PROGRAM_ERROR: put_string('program error\');
    BREAK_KEY:     put_string('break key\');
    ORANGE_BALL:   put_string('orange ball\');
    DEVICE_BUSY:   put_string('device busy\');
    TIME_OUT:      put_string(TIMED_OUT)
  end (* case *)
end (* ioresult_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			      status_name				*)
(*									*)
(*    Generate status name string from ioresult.			*)
(*									*)
(************************************************************************)

procedure entry STATUS_NAME(
      status	: ioresult);
      
begin
  ioresult_name(status)
end (* status_name *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*			    controller_status				*)
(*									*)
(*    Generate controller status message.				*)
(*									*)
(************************************************************************)

procedure entry CONTROLLER_STATUS(
      status		: ioresult;
      status2		: integer;
      isis_value	: integer);

begin
  put_string('controller status: \');
  put_number(status2, 16);
  put_character(ASCII_SPACE);
  case status of
    COMPLETE,
    END_FILE,
    END_MEDIUM,
    START_MEDIUM,
    BREAK_KEY,
    ORANGE_BALL,
    DEVICE_BUSY,
    TIME_OUT: (* NULL *);
    FAILURE,
    TRANSMISSION,
    INTERVENTION,
    PROGRAM_ERROR: put_isis_error(isis_value)
  end (* case *)
end (* controller_status *);



(************************  internal_to_string  **************************)
(*									*)
(*		             put_build_error				*)
(*									*)
(*    Generate build error message from build error number.		*)
(*									*)
(************************************************************************)

procedure put_build_error(
      message_number	: integer);

var
  x : integer;

begin
  put_string(CIRCUIT_BUILD_ERROR);
  x := message_number mod 128 (* remove parity bit *);
  if x > 11
  then put_number(x, 10)
  else
    case x of
      0: put_string('slot 0 will not honor request...try later\');
      1: put_string(FORMAT_ERROR);
      2: put_string(USER_NOT_FOUND);
      3: put_string('bad MUD\');
      4: put_string(SYSTEM_UNAVAILABLE);
      5: put_string('downline load request failure\');
      6: put_string(TIMED_OUT);
      7: put_string('access not permitted\ ');
      8: put_string('out of origination ports\ ');
      9: put_string('sup will not honor request...try later\ ');
      10: put_string('bad requesting host number\ ');
      11: put_string('requesting host not up on requesting node\')
    end (* case *)
end (* put_build_error *);



(************************  internal_to_string  **************************)
(*									*)
(*		             put_on_block				*)
(*									*)
(************************************************************************)

procedure put_on_block(
      block	: univ integer);

begin
  if block >= 0
  then
    begin
      put_string(' on block \ ');
      put_number(block, 10)
    end
end (* put_on_block *);



(************************  internal_to_string  **************************)
(*									*)
(*		               on_block					*)
(*									*)
(************************************************************************)

procedure entry ON_BLOCK(
      block	: univ integer);

begin
  put_on_block(block)
end (* put_on_block *);



(************************  internal_to_string  **************************)
(*									*)
(*		               un2_sup_error				*)
(*									*)
(*    Generate a UN2 error message for supervisor.			*)
(*									*)
(************************************************************************)

procedure entry UN2_SUP_ERROR(
      status	: un2_status;
      result	: ioresult;
      io_error	: integer;
      block	: cud_block_index);

begin
  case status of
    UN2_SUCCESSFUL:       put_string(COMPLETE_MESSAGE);
    UN2_BUSY:		  put_string('circuit in use\ ');
    UN2_BUILD_FAILURE:	  put_build_error(io_error);
    UN2_UNEXPECTED_INPUT: put_string(UNRECOGNIZED_INPUT);
    UN2_TOO_MANY_RETRIES: put_string('too many resends\ ');
    UN2_HANDSHAKE_ERROR:  put_string(HANDSHAKE_ERROR);
    UN2_CIRCUIT_ERROR:
      begin (* un2_circuit_error *)
        put_string(CIRCUIT_ERROR);
        ioresult_name(result)
      end (* un2_circuit_error *)
  end (* case *);
  if (status = UN2_UNEXPECTED_INPUT) or (status = UN2_TOO_MANY_RETRIES) 
          or (status = UN2_CIRCUIT_ERROR)
  then put_on_block(block)
end (* un2_sup_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*		             sysmsg1_error				*)
(*									*)
(*    Generate a SYSMSG1 error message.					*)
(*									*)
(************************************************************************)

procedure entry SYSMSG1_ERROR(
      status	: sysmsg1_status;
      result	: ioresult;
      io_error	: integer);

begin
  case status of
    SYSMSG1_SUCCESSFUL:       put_string(COMPLETE_MESSAGE);
    SYSMSG1_BUILD_FAILURE:    put_build_error(io_error);
    SYSMSG1_HANDSHAKE_ERROR:  put_string(HANDSHAKE_ERROR);
    SYSMSG1_CIRCUIT_ERROR:
      begin
        put_string(CIRCUIT_ERROR);
        ioresult_name(result)
      end;
    SYSMSG1_UNEXPECTED_INPUT: put_string(UNRECOGNIZED_INPUT)
  end (* case *)
end (* sysmsg1_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*		           consistency_error				*)
(*									*)
(*    Generate a consistency error message.				*)
(*									*)
(************************************************************************)

procedure entry CONSISTENCY_ERROR(
      block	: cud_block_index;
      status	: consistency_status);

begin
  put_string('Consistency: \');
  case status of
    CONSISTENCY_OK:	put_string('ok\ ');
    UN2_ERROR:		put_string('error on UN2\ ');
    CUD_ERROR:
      begin
        put_string('CUD error\');
	put_on_block(block)
      end (* CUD_ERROR *);
    CONSISTENCY_STOPPED: put_string('halted\ ');
    CONSISTENCY_DONE: put_string(COMPLETE_MESSAGE)
  end (* case *)
end (* consistency_error *);



(************************  internal_to_string  **************************)
(*									*)
(*		       put_checksum_error_on_block			*)
(*									*)
(************************************************************************)

procedure put_checksum_error_on_block(
      block	: univ integer);

begin
  put_string(CHECKSUM_ERROR);
  put_on_block(block)
end (* put_checksum_error_on_block *);



(************************  internal_to_string  **************************)
(*									*)
(*			   put_unit_and_sector				*)
(*									*)
(************************************************************************)

procedure put_unit_and_sector(
      unit	: disk_unit_index;
      address	: integer);

begin
  put_string(' (unit: \ '); put_number(unit, 10);
  put_string(' sector \ '); put_number(address, 10);
  put_character(')')
end (* put_unit_and_sector *);



(************************  internal_to_string  **************************)
(*									*)
(*		            cud_block_error				*)
(*									*)
(*    Generate CUD block error message from cud_operation_result.	*)
(*									*)
(************************************************************************)

procedure entry CUD_BLOCK_ERROR(
      block	: univ integer;
      result	: cud_operation_result);

begin
  buffer.size := 0;
  if result = CUD_OPERATION_OK
  then put_string(COMPLETE_MESSAGE)
  else
    begin
      put_string(CUD_FILE_MESSAGE);
      put_character(ASCII_SPACE);
      case result of
        CUD_FILE_LOCKED:		put_string(FILE_BUSY);
        CUD_BLOCK_MANUALLY_LOCKED:	put_string('block locked\ ');
        CUD_CHECKSUM_ERROR:		put_checksum_error_on_block(block);
        CUD_OPERATION_FAILED: 		put_string(IO_FAILURE)
      end (* case *);
      if (result <> CUD_FILE_LOCKED) and (result <> CUD_CHECKSUM_ERROR)
      then
        begin
	  put_on_block(block);
	  put_unit_and_sector(0, MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS * block)
	end (* (result<>CUD_FILE_LOCKED) and (result<>CUD_CHECKSUM_ERROR) *)
    end (* result <> CUD_OPERATION_OK *)
end (* cud_block_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(************************  internal_to_string  **************************)
(*									*)
(*		            cud_access_error				*)
(*									*)
(*    Generate CUD access error message from cud_access_status.		*)
(*									*)
(************************************************************************)

procedure entry CUD_ACCESS_ERROR(
      status	: cud_access_status);

begin
  case status of
    CUD_ACCESS_OK:		put_string('block locked successfully\');
    CUD_ACCESS_FILE_LOCKED:	put_string(CUD_FILE_BUSY);
    CUD_ACCESS_BLOCK_SHUT:	put_string(CUD_BLOCK_SHUT)
  end (* case *)
end (* cud_access_error *);



(************************  internal_to_string  **************************)
(*									*)
(*		          named_list_status      			*)
(*									*)
(*      generate message from node_host_utility_status             	*)
(*									*)
(************************************************************************)

procedure entry NAMED_LIST_STATUS(
      last_status	: node_host_utility_status);

begin
  case last_status of
    NODE_HOST_OK:		put_string(ENTRY_COMPLETED);
    NODE_HOST_LIST_NOT_FOUND:	put_string('list not found\ ');
    NODE_HOST_LIST_FOUND:	put_string('list already defined\ ');
    NODE_HOST_BEING_UPDATED:	put_string(ENTRY_BUSY);
    NODE_HOST_LIST_IN_USE:	put_string('\ ') (* not used *);
    NODE_HOST_IO_ERROR:		put_string(IO_FAILURE);
    NODE_HOST_BAD_CHECKSUM:	put_string(CHECKSUM_ERROR);
    NODE_HOST_FULL:		put_string('file full\')
  end
end (* named_list_status *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*		             cud_entry_status				*)
(*									*)
(*    Generate CUD entry message from cud_entry_result.			*)
(*									*)
(************************************************************************)

procedure entry CUD_ENTRY_STATUS(
      status	: cud_entry_result);

begin
  case status of
    CUD_ENTRY_OK:		put_string(ENTRY_COMPLETED);
    CUD_ENTRY_FILE_LOCKED:	put_string(CUD_FILE_BUSY);
    CUD_ENTRY_LOCKED:       	put_string(ENTRY_BUSY);
    CUD_ENTRY_BLOCK_LOCKED:	put_string(CUD_BLOCK_SHUT);
    CUD_ENTRY_DOES_NOT_FIT: 	put_string('CUD block full\ ');
    CUD_ENTRY_NOT_FOUND:	put_string(USER_NOT_FOUND);
    CUD_NAME_TAKEN:         	put_string('user already exists\');
    CUD_FORMAT_ERROR:       	put_string(FORMAT_ERROR);
    CUD_ENTRY_BAD_CHECKSUM:	put_string(CHECKSUM_ERROR);
    CUD_ENTRY_MUD_CHANGE_FILE_FULL: put_string('MUD_UPDATE full\');
    CUD_ENTRY_MUD_CHANGE_FILE_ERROR:
      put_string('MUD_UPDATE file or disk error\');
    CUD_ENTRY_OPERATION_FAILED: put_string(IO_FAILURE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CUD_ENTRY_IN_WRONG_BLOCK:	put_string('entry in wrong block\ ');
    CUD_ENTRY_ILLEGAL_NAME:	put_string('illegal username\ ')
  end (* case *)
end (* cud_entry_status *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*			   logout_explanation				*)
(*									*)
(************************************************************************)

procedure entry LOGOUT_EXPLANATION(
      logout_reason	: logout_cause);

begin
  put_string('validator \ ');
  case logout_reason of
    GENERAL_LOGOUT:	put_string('logged out\ ');
    TIMEDOUT_LOGOUT:	put_string(TIMED_OUT);
    LOST_CIRCUIT_LOGOUT:put_string(LOST_CIRCUIT)
  end (* case *);
  put_colon_space
end (* logout_explanation *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*			       put_username   				*)
(*									*)
(*	Put a network username in the buffer.				*)
(*									*)
(************************************************************************)

procedure put_username(
      user	: username_string);

var
  i : username_text_index;

begin
  for i := 0 to user.size - 1 do
    put_character(user.text[i])
end (* put_username *);



(************************  internal_to_string  **************************)
(*									*)
(*			       username   				*)
(*									*)
(*	Put a network username in the buffer.				*)
(*									*)
(************************************************************************)

procedure entry USERNAME(
      user	: username_string);

begin
  put_username(user)
end (* username *);



(************************  internal_to_string  **************************)
(*									*)
(*				 number 				*)
(*									*)
(*    Convert a number in any radix to a string.			*)
(*									*)
(************************************************************************)

procedure entry NUMBER(
      number_to_convert	: integer;
      radix		: integer);

begin
  put_number(number_to_convert, radix)
end (* number *);



(*************************  internal_to_string  *************************)
(*									*)
(*				format_number				*)
(*									*)
(*    Convert a number to a string of places_to_print characters.	*)
(*    If 'places_to_print' is negative, display leading zeros.		*)
(*    Otherwise, display leading blanks.				*)
(*									*)
(************************************************************************)

procedure entry FORMAT_NUMBER(
      number_to_convert	: integer;
      radix		: integer;
      places_to_print	: integer);

begin
  put_format_number(number_to_convert, radix, places_to_print)
end (* format_number *);



(************************  internal_to_string  **************************)
(*									*)
(*			       sup_number 				*)
(*									*)
(*    Convert a supervisor_index to a string.				*)
(*									*)
(************************************************************************)

procedure entry SUP_NUMBER(
  real_sup          : real_supervisor_index);

begin
  put_supervisor(real_sup)
end (* sup_number *);



(************************  internal_to_string  **************************)
(*									*)
(*			      scaled_number				*)
(*									*)
(*    Convert a number to a string with a radix point a given number	*)
(*    of places to the left of the right of the number. I.e, a call	*)
(*    of scaled_number(1234, 10, 1) will produce the number 123.4	*)
(*									*)
(************************************************************************)

procedure entry SCALED_NUMBER(
      number_to_convert	: integer;
      radix		: integer;
      radix_place	: integer);

begin
  put_scaled_number(number_to_convert, radix, radix_place)
end (* scaled_number *);



(************************  internal_to_string  **************************)
(*									*)
(*			   number_range 				*)
(*									*)
(*    convert a number range in any radix to a string.			*)
(*									*)
(**************************************************************************)

procedure entry NUMBER_RANGE(
      first_number_to_convert	: integer;	
      last_number_to_convert	: integer;
      radix			: integer);

begin
  put_number(first_number_to_convert, radix);
  if first_number_to_convert <> last_number_to_convert
  then
    begin
      put_character(ASCII_MINUS);
      put_number(last_number_to_convert, radix)
    end
end (* number_range *);



(************************  internal_to_string  **************************)
(*									*)
(*			    report_progress				*)
(*									*)
(*      Report progress to validator and clear counts.			*)
(*									*)
(************************************************************************)

procedure entry REPORT_PROGRESS(
      user_terminal	: circuit_handler;
      block		: univ integer;
      blocks_sent	: integer;
      retries		: integer;
  var line_length	: integer);

begin
  buffer.size := 0;
  put_number(block, 10);
  if (retries <> 0) or (blocks_sent <> 0)
  then
    begin
      put_character(ASCII_COLON);
      put_number(blocks_sent, 10);
      put_character('/');
      put_number(retries, 10)
    end (* (retries <> 0) or (blocks_sent <> 0) *);
  put_character(ASCII_SPACE);
  if (line_length + buffer.size) >= COMMAND_LINE_TEXT_LIMIT
  then
    begin
      user_terminal.write_newline;
      line_length := 0
    end;
  user_terminal.write_format_buffer(buffer);
  line_length := line_length + buffer.size
end (* report_progress *);



(************************  internal_to_string  **************************)
(*									*)
(*			ansii_tape_label_chars  			*)
(*									*)
(************************************************************************)

procedure entry ANSII_TAPE_LABEL_CHARS(
      label		: ansii_tape_label;
      first_char	: ansii_tape_label_index;
      number_of_chars	: ansii_tape_label_size);

var
  label_index : ansii_tape_label_index;

begin
  for label_index := first_char to (first_char + number_of_chars - 1) do
    put_character(label[label_index])
end (* ansii_tape_label_chars *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*			     host_state_name	  			*)
(*									*)
(************************************************************************)

procedure entry HOST_STATE_NAME(
      state_to_add	: host_state);

begin
  case state_to_add of
    UP_STATE:	put_string('UP\ ');
    DOWN_STATE:	put_string('DOWN\ ');
    SHUT_STATE:	put_string('SHUT\ ');
    GONE_STATE:	put_string('GONE\ ')
  end (* case *)
end (* host_state_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			     unit_and_sector				*)
(*									*)
(************************************************************************)

procedure entry UNIT_AND_SECTOR(
      unit	: disk_unit_index;
      address	: integer);

begin
  put_unit_and_sector(unit, address)
end (* unit_and_sector *);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)



(************************  internal_to_string  **************************)
(*									*)
(*			      by_validator				*)
(*									*)
(************************************************************************)

procedure entry BY_VALIDATOR(
      user	: username_string);

begin
  put_string(BY_MESSAGE);
  put_username(user)
end (* by_validator *);



(************************  internal_to_string  **************************)
(*									*)
(*			    command_string				*)
(*									*)
(************************************************************************)

procedure entry COMMAND_STRING(
      name	: command_name);

var
  i : command_name_index;

begin
  i := 0;
  while name[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(name[i]);
      i := i + 1
    end (* while *)
end (* command_string *);



(************************  internal_to_string  **************************)
(*									*)
(*			    keyword_string				*)
(*									*)
(************************************************************************)

procedure entry KEYWORD_STRING(
      name	: keyword_name);

var
  i : keyword_name_index;

begin
  i := 0;
  while name[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(name[i]);
      i := i + 1
    end (* while *)
end (* keyword_string *);



(************************  internal_to_string  **************************)
(*									*)
(*				prompt	  				*)
(*									*)
(************************************************************************)

procedure entry PROMPT(
  var string_to_insert	: command_prompt);

var
  i : command_prompt_text_index;

begin
  i := 0;
  while string_to_insert[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(string_to_insert[i]);
      i := i + 1
    end (* while *)
end (* prompt *);



(***********************  internal_to_string  ***************************)
(*									*)
(*				 string 				*)
(*									*)
(*    Put string into buffer.						*)
(*									*)
(************************************************************************)

procedure entry STRING(
      string_to_insert	: quoted_text);

begin
  put_string(string_to_insert)
end (* string *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			   help_text_string 				*)
(*									*)
(*    Put help_text into buffer.					*)
(*									*)
(************************************************************************)

procedure entry HELP_TEXT_STRING(
      string_to_insert	: help_string);

var
  i : help_text_index;

begin
  i := 0;
  while string_to_insert[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(string_to_insert[i]);
      i := i + 1
    end (* while *)
end (* help_text_string *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			     colon_space				*)
(*									*)
(*    Put colon, space in buffer.					*)
(*									*)
(************************************************************************)

procedure entry COLON_SPACE;

begin
  put_colon_space
end (* colon_space *);



(***********************  internal_to_string  ***************************)
(*									*)
(*				 newline				*)
(*									*)
(*    Put carriage return linefeed in buffer.				*)
(*									*)
(************************************************************************)

procedure entry NEWLINE;

begin
  put_newline
end (* newline *);



(************************  internal_to_string  **************************)
(*									*)
(*				  skip					*)
(*									*)
(*    Skip n blanks in buffer. If n is negative, set buffer size.	*)
(*									*)
(************************************************************************)

procedure entry SKIP(
      n	: integer);

var
  i : integer;

begin
  if n > 0
  then
    for i := 1 to n do
      put_character(ASCII_SPACE)
  else buffer.size := buffer.size+n
end (* skip *);



(************************  internal_to_string  **************************)
(*									*)
(*				skip_to 				*)
(*									*)
(*    Skip to position n in buffer.					*)
(*									*)
(************************************************************************)

procedure entry SKIP_TO(
      n	: integer);

var
  i : integer;

begin
  if n > buffer.size
  then
    for i := 1 to n - buffer.size do
      put_character(ASCII_SPACE)
  else buffer.size := n
end (* skip_to *);



(***********************  internal_to_string  ***************************)
(*									*)
(*				character				*)
(*									*)
(*    Put single character in buffer.					*)
(*									*)
(************************************************************************)

procedure entry CHARACTER(
      c	: char);

begin
  put_character(c)
end (* character *);



(***********************  internal_to_string  ***************************)
(*									*)
(*				  start 				*)
(*									*)
(*    Start the buffer at the beginning.				*)
(*									*)
(************************************************************************)

procedure entry START;

begin
  buffer.size := 0
end (* start *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			    start_message				*)
(*									*)
(*    Start the buffer at the beginning and insert a message.		*)
(*									*)
(************************************************************************)

procedure entry START_MESSAGE(
      message_to_insert	: quoted_text);

begin
  buffer.size := 0;
  put_string(message_to_insert)
end (* start_message *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			 do_start_and_newline				*)
(*									*)
(*    Start the buffer at the beginning and insert a newline.		*)
(*									*)
(************************************************************************)

procedure do_start_and_newline;

begin
  buffer.size := 0;
  put_newline
end (* do_start_and_newline *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			  start_and_newline				*)
(*									*)
(*    Start the buffer at the beginning and insert a newline.		*)
(*									*)
(************************************************************************)

procedure entry START_AND_NEWLINE;

begin
  do_start_and_newline
end (* start_and_newline *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			  start_line_message				*)
(*									*)
(*    Start the buffer at the beginning and insert a newline and	*)
(*    a message.							*)
(*									*)
(************************************************************************)

procedure entry START_LINE_MESSAGE(
      message_to_insert	: quoted_text);

begin
  do_start_and_newline;
  put_string(message_to_insert)
end (* start_line_message *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			     write_block				*)
(*									*)
(*    Write buffer to given terminal as a block.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_BLOCK(
      circuit	: circuit_handler);

begin
  circuit.write_format_buffer(buffer)
end (* write_block *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			      write_line				*)
(*									*)
(*    Write current buffer to given circuit as a line.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_LINE(
      circuit	: circuit_handler);

begin
  put_newline;
  circuit.write_format_buffer(buffer)
end (* write_line *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(************************************************************************)

begin (* initial statement *)
  init calendar
end (* internal_to_string *);
!
(************************************************************************)
(*									*)
(*	PASS.NTV							*)
(*			    password_reader				*)
(*									*)
(*    This class handles the reading and checking of a password text,	*)
(*    and the optional conversion to a cipher.				*)
(*									*)
(*     The following identifiers must be defined externally:		*)
(*	 password_string, password_text_index				*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	04Mar85 - jrn							*)
(*	      - add name argument to get_new_cipher routine if		*)
(*		name_legal_password is disabled				*)
(*	07aug84 Version 3.00						*)
(*	      - changed function legal_password to call 		*)
(*		password_cipher_utility routine, illegal_alpha_password *)
(*	06jul93 Original -- from (patrol)pass.ntc - jrn			*)
(*									*)
(************************************************************************)



type PASSWORD_READER = class(
	mutil		: misc_utility;
	format		: internal_to_string;
	user_terminal	: circuit_handler);


var
  cipher_password: password_cipher_utility;



(*************************  password_reader  ****************************)
(*									*)
(*				 match					*)
(*									*)
(*    Test if two password strings are the same.			*)
(*									*)
(************************************************************************)

function match(
      first	: password_string;
      second	: password_string) : boolean;

var
  i: password_text_index;

begin
  match := TRUE;
  if first.size <> second.size then match := FALSE
  else
    for i := 0 to first.size - 1 do
      if first.text[i] <> second.text[i] then match := FALSE
end (* match *);



(*************************  password_reader  ****************************)
(*									*)
(*			    legal_password				*)
(*									*)
(************************************************************************)

function legal_password(
      new_password	: password_string) : boolean;

var
  index : password_text_index;
  illegal : boolean;

begin
  legal_password := FALSE;
  if (MINIMUM_PASSWORD_SIZE>0) and (new_password.size<MINIMUM_PASSWORD_SIZE)
  then
    begin
      format.start_line_message('passwords must be a minimum of \');
      format.number(MINIMUM_PASSWORD_SIZE, 10);
      format.string(' characters\');
      format.write_line(user_terminal)
    end
  else
    begin (* password is legal length *)
      illegal := FALSE;
      for index := 0 to new_password.size - 1 do
        if new_password.text[index] = ASCII_SEMI_COLON
	then
	  begin
	    illegal := TRUE;
	    user_terminal.write_line_and_quoted_text_line(
'semicolon is an illegal password character\ ')
	  end (* for *);
      if not illegal
      then
        if cipher_password.illegal_alpha_password(new_password)
	then user_terminal.write_line_and_quoted_text_line(
'password must contain at least one nonalphanumeric character\ ')
	else legal_password := TRUE (* all chars check out ok *)
    end (* password is legal length *)
end (* legal_password *);



(*************************  password_reader  ****************************)
(*									*)
(*			     read_password				*)
(*									*)
(*    Read password from terminal turning echo off during read. 	*)
(*									*)
(************************************************************************)

procedure read_password(
      first_cipher	: boolean;
      prompt		: quoted_text;
  var new_cipher	: integer);

var
  done : boolean;
  password : password_string;
  i : password_text_index;

begin
  done := FALSE;
  repeat
    user_terminal.set_echo(FALSE);
    user_terminal.write_quoted_text(prompt);
    user_terminal.read_password_string(password);
    user_terminal.write_newline;
    user_terminal.set_echo(TRUE);
    for i := 0 to password.size - 1 do
      mutil.make_character_upper_case(password.text[i]);
    new_cipher := cipher_password.convert(password);
    if not first_cipher
    then done := TRUE
    else
      if legal_password(password)
      then done := TRUE
  until done or not user_terminal.sendable
end (* read_password *);



(*************************  password_reader  ****************************)
(*									*)
(*			    get_new_cipher				*)
(*									*)
(*    Read a new password from terminal and do it twice to insure	*)
(*    it is the same. Return the new password cipher if successful.	*)
(*									*)
(************************************************************************)

procedure entry GET_NEW_CIPHER(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      old_cipher	: integer;
  var new_cipher	: integer);

var
  retry : integer;

begin
  repeat
    read_password(TRUE, 'password:\', new_cipher);
    if user_terminal.sendable
    then
      if new_cipher = old_cipher
      then user_terminal.write_line_and_quoted_text_line(
        'new password is identical to old password,\ ')
      else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          begin
	    read_password(FALSE, 'enter it again:\', retry);
	    if user_terminal.sendable and (new_cipher <> retry)
	    then user_terminal.write_line_and_quoted_text_line(
	      'passwords do not match,\')
	  end
  until (new_cipher = retry) or not user_terminal.sendable
end (* get_new_cipher *);



(*************************  password_reader  ****************************)
(*									*)
(*			      ciphered_password				*)
(*									*)
(*	Read a password from the terminal and return the cipher.	*)
(*	Used for programmer WRITE commands and programmer logging in	*)
(*	through auxilliary circuits.					*)
(*									*)
(************************************************************************)

function entry CIPHERED_PASSWORD : integer;

var
  new_cipher : integer;

begin
  read_password(FALSE, 'enter password:\', new_cipher);
  ciphered_password := new_cipher
end (* ciphered_password *);



(*************************  password_reader  ****************************)
(************************************************************************)


begin (* initial statement *)
  init cipher_password(mutil)
end (* password_reader *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(**********************************************************************)
(*                                                                    *)
(*	STAT.NTV						      *)
(*                        statistics_gatherer                         *)
(*                                                                    *)
(*    This monitor gathers and prints program running statistics.     *)
(*    This includes disk read/write statistics.                       *)
(*                                                                    *)
(*     The following identifiers must be defined externally:          *)
(*       disk_param                                                   *)
(*       page_size                                                    *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*	14Oct84 Version 3.00 - pgl				      *)
(*	      - add conditional assembly parameter logical_volumes    *)
(*	21May84	2.02 - jrn					      *)
(*	      - fix bug in second argument to initialize FIFO	      *)
(*     29SEP83    Original from (patrol)stat.tms - jrn                *)
(*                                                                    *)
(**********************************************************************)


type STATISTICS_GATHERER = monitor;


const
  histogram_interval = 300 (* seconds *);

  bar_max = 12 (* bars in a histogram *);
  bar_limit = bar_max - 1;

type
  bar_index = 0..bar_max;

  histogram = array [bar_index] of integer;

  disk_statistic_operation =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    disk_read..disk_write;
const
  save_error_max = 4 (* disk errors *);
  save_error_limit = save_error_max - 1;

type
  save_error_index = 0..save_error_limit;

var
  next_error: fifo;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  current_bar : integer;
  current_time : integer;
  start_time : integer;
  disk_statistic:
    array [disk_statistic_operation] of
      record
	count		: integer (* number of operations *);
	page_access	: integer (* number of pages operated on *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	errors		: integer (* no. of disk errors *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	history		: histogram
      end (* disk_statistic *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  error : array [save_error_index] of
    record
      when  : integer (* when error occurred *);
      call  : disk_param (* param of io call *);
      value : disk_param (* param set by io call *)
    end (* errors *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                             initialize                             *)
(*                                                                    *)
(*    Initialize all statistics to zero and set start time to now.    *)
(*                                                                    *)
(**********************************************************************)

procedure initialize;

var
  i : bar_index;
  j : disk_statistic_operation;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init next_error(0, SAVE_ERROR_LIMIT);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  current_bar := 0;
  current_time := REALTIME;
  start_time := current_time;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  for j := DISK_READ to DISK_WRITE do
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    with disk_statistic[j] do
      begin
	count := 0;
	page_access := 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
       	errors := 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	for i := 0 to BAR_LIMIT do
	  history[i] := 0
      end (* with *)
end (* initialize *);



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                          print_histogram                           *)
(*                                                                    *)
(*    Print the given histogram on one line allowing six positions    *)
(*    for each number.                                                *)
(*                                                                    *)
(**********************************************************************)

procedure print_histogram(
      history		: histogram;
      format		: internal_to_string;
      user_terminal	: circuit_handler);

var
  i : bar_index;

begin
  format.start;
  for i := 0 to BAR_LIMIT do
    begin
      format.skip_to(i*6);
      format.number(history[(current_bar+1+i) mod BAR_MAX], 10)
    end (* for *);
  format.write_line(user_terminal)
end (* print_histogram *);



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                          set_current_bar                           *)
(*                                                                    *)
(*    Set the current_time for histograms and move bar to this time.  *)
(*                                                                    *)
(**********************************************************************)

procedure set_current_bar;

var
  i : disk_statistic_operation;
  j,
  n,
  new_bar: integer;

begin
  current_time := REALTIME;
  new_bar := (current_time-start_time) div HISTOGRAM_INTERVAL;
  n := new_bar-current_bar;
  if n > 0
  then
    begin
      if n > BAR_MAX
      then n := BAR_MAX;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      for i := DISK_READ to DISK_WRITE do  
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	with disk_statistic[i] do
	  for j := 1 to n do
	    history[(current_bar+j) mod BAR_MAX] := 0;
      current_bar := new_bar
    end
end (* set_current_bar *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                           report_disk_io                           *)
(*                                                                    *)
(*    This entry is called whenever a disk io is done. The parameter  *)
(*    of the actual operation is passed.                              *)
(*                                                                    *)
(**********************************************************************)

procedure entry REPORT_DISK_IO(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      call_param	: disk_param;
      value_param	: disk_param);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

var
  j	  : bar_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 discard : save_error_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  set_current_bar;
  with call_param, disk_statistic[operation] do
    begin
      count := count+1;
      page_access := page_access+(byte_count div PAGE_SIZE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if value_param.status <> COMPLETE
      then errors := errors+1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      j := current_bar mod BAR_MAX;
      history[j] := history[j]+1
    end (* with *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if value_param.status <> COMPLETE
  then
    begin
      if next_error.full
      then discard := next_error.departure;
      with error[next_error.arrival] do
	begin
	  when := REALTIME;
	  call := call_param;
	  value := value_param
	end (* with *)
    end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* report_disk_io *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  statistics_gatherer  *************************)
(*									*)
(*			     write_first_line				*)
(*									*)
(************************************************************************)

procedure write_first_line(
      format		: internal_to_string;
      i			: disk_statistic_operation;
      user_terminal	: circuit_handler);

begin
  with disk_statistic[i], format do
    begin
      start_and_newline;
      disk_operation_name(i);
      string('   total: \ ');
      number(count, 10);
      string('   pages: \ ');
      number(page_access, 10);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      string('   errors: \');
      number(errors, 10);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      write_line(user_terminal)
   end
end (* write_first_line *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  statistics_gatherer  *************************)
(*									*)
(*			     format_error_line				*)
(*									*)
(************************************************************************)

procedure format_error_line(
      format		: internal_to_string;
      user_terminal	: circuit_handler);

const
  operation_column = 18;
  status_column    = operation_column+10;
  address_column   = status_column+13;
  count_column	   = address_column+8;
  transfer_column  = count_column+6;
  isis_column	   = transfer_column+9;
  status2_column   = isis_column+5;

begin
  if not next_error.empty
  then
    begin
      with format do
        begin
	  start_line_message('when\ ');
	  skip_to(operation_column);
	  string('operation\');
	  skip_to(status_column);
	  string('status\ ');
	  skip_to(address_column);
	  string('address\');
	  skip_to(count_column);
	  string('count\');
	  skip_to(transfer_column);
	  string('transfer\ ');
	  skip_to(isis_column);
	  string('isis\ ');
	  skip_to(status2_column);
	  string('status2\');
	  write_line(user_terminal)
	end (* with *);
      repeat
	with error[next_error.departure], format do
	  begin
	    start;
	    time(when);
	    skip_to(operation_column);
	    disk_operation_name(call.operation);
	    skip_to(status_column);
	    status_name(value.status);
	    skip_to(address_column);
	    number(call.start_addr, 16);
	    skip_to(count_column);
	    number(call.byte_count, 10);
	    skip_to(transfer_column);
	    number(value.start_addr, 10);
	    skip_to(isis_column);
	    number(value.byte_count, 10);
	    skip_to(status2_column);
	    number(value.status2, 16);
	    write_line(user_terminal)
	  end (* with *)
      until next_error.empty
    end
end (* format_error_line *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                          print_statistics                          *)
(*                                                                    *)
(*    Print the statistics currently gathered to the given terminal.  *)
(*                                                                    *)
(**********************************************************************)

procedure entry PRINT_STATISTICS(
      format		: internal_to_string;
      user_terminal	: circuit_handler);
          
var
  i : disk_statistic_operation;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  set_current_bar;
  with format do
    begin
      start_message('since \ ');
      time(start_time);
      string(GMT_MESSAGE);
      write_line(user_terminal)
    end (* with *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  for i := DISK_READ to DISK_WRITE do
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    begin
      write_first_line(format, i, user_terminal);
      print_histogram(disk_statistic[i].history, format, user_terminal);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      format_error_line(format, user_terminal)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* for *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* print_statistics *);



(***********************  statistics_gatherer  ************************)
(**********************************************************************)

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  initialize
end (* statistics_gatherer *);
!
(**********************************************************************)
(*                                                                    *)
(*	profil.ntv						      *)
(*                        validator_profile			      *)
(*                                                                    *)
(*    This class contains validator information for currently logged  *)
(*    in validators.						      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          revision record                           *)
(*                                                                    *)
(*	14Jun84	Version 2.02	jrn				      *)
(*	      - added licenses, AUDITOR_LICENSE, OPERATOR_LICENSE     *)
(*		and DISPLAY_CUD_LICENSE				      *)
(*    05Dec83    original - jnm					      *)
(*								      *)
(**********************************************************************)


type (* information about each validator *)
  validator_login_information = record
    level	: validator_type (* kind of validator *);
    needle	: needle_record;
    unit	: terminal_unit_index (* terminal device *);
    name	: username_string;
    gan		: integer;
    options	: user_options
  end (* validator_login_information *);


type VALIDATOR_PROFILE = class(
	this_validator : validator_index);

var
  entry needle : needle_record;
  entry level : validator_type;
  entry gan : integer;
  entry name : username_string;
  entry licenses : validator_license_set;



(*************************  validator_profile  ************************)
(*                                                                    *)
(*                            set_validator			      *)
(*                                                                    *)
(*    Set up the validator.					      *)
(*                                                                    *)
(**********************************************************************)

procedure entry SET_VALIDATOR(
      new_info	: validator_login_information);

begin
  needle := new_info.needle;
  gan := new_info.gan;
  name := new_info.name;
  level := new_info.level;

  licenses := [];
  if AUDITOR in new_info.options
  then licenses := licenses or [AUDITOR_LICENSE]; 
  if OPERATOR in new_info.options
  then licenses := licenses or [OPERATOR_LICENSE]; 

  if level >= ACCOUNT_SUPERVISOR_VALIDATOR
  then licenses := licenses or [ACCOUNT_SUPERVISOR_LICENSE];
  if level >= NETWORK_ADMINISTRATOR_VALIDATOR
  then licenses := licenses or
    [NETWORK_ADMINISTRATOR_LICENSE, AUDITOR_LICENSE, OPERATOR_LICENSE];
  if level = PROGRAMMER_VALIDATOR
  then licenses := licenses or [PROGRAMMER_LICENSE];

  if (AUDITOR_LICENSE in licenses) or (ACCOUNT_SUPERVISOR_LICENSE in licenses)
  then licenses := licenses or [DISPLAY_CUD_LICENSE]
end (* set_validator *);



(*************************  validator_profile  ************************)
(*                                                                    *)
(*                              validator                             *)
(*                                                                    *)
(*    Return the validator's index.				      *)
(*                                                                    *)
(**********************************************************************)

function entry VALIDATOR : validator_index;

begin
  validator := this_validator
end (* validator *);



(*************************  validator_profile  ************************)
(*                                                                    *)
(*                            access_to_gan                           *)
(*                                                                    *)
(*    - if validator is programmer or network administrator, they may *)
(*	do anything to anyone, so return TRUE			      *)
(*    - if write_access is TRUE, return TRUE if the validator is an   *)
(*	ACCOUNT SUPERVISOR and the gan_to_check matches and GANS      *)
(*	are included in the system, otherwise return FALSE	      *)
(*    - if write_access is FALSE (caller is checking READ access),    *)
(*	return TRUE if:						      *)
(*		- the validator is an AUDITOR			      *)
(*				OR				      *)
(*		- the validator is an ACCOUNT SUPERVISOR AND the      *)
(*		  gan_to_check matehs AND GANS are included	      *)
(*		  in the system					      *)
(*	otherwise, return FALSE					      *)
(*                                                                    *)
(**********************************************************************)

function entry ACCESS_TO_GAN(
      gan_to_check 	: integer;
      write_access	: boolean) : boolean;

begin
  if level > ACCOUNT_SUPERVISOR_VALIDATOR
  then access_to_gan := TRUE		(* N.A. and PROG. can do anything *)
  else
    if write_access	(* checking a write command *)
    then access_to_gan := INCLUDE_GAN and 
        (level = ACCOUNT_SUPERVISOR_VALIDATOR) and (gan = gan_to_check)
    else	(* checking a read command *)
      access_to_gan := (AUDITOR_LICENSE in licenses) or
        (INCLUDE_GAN and 
	  (level = ACCOUNT_SUPERVISOR_VALIDATOR) and (gan = gan_to_check))
end (* access_to_gan *);



(*************************  validator_profile  ************************)
(*                                                                    *)
(*                          access_to_command                         *)
(*                                                                    *)
(*	Return TRUE if the required license for  the command or	      *)
(*	subcommand is NO_LICENSE or the validator has the	      *)
(*	required license.				      	      *)
(*                                                                    *)
(**********************************************************************)

function entry ACCESS_TO_COMMAND(
      required_license 	: command_license) : boolean;

begin
  access_to_command := (required_license = NO_LICENSE) or
    (required_license in licenses)
end (* access_to_command *);


(************************  validator_profile  *************************)
(**********************************************************************)


begin (* initial statement *)
end (* validator_profile *);
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(**********************************************************************)
(*                                                                    *)
(*	DSKSYS.NTV						      *)
(*                            Disk_System                             *)
(*                                                                    *)
(*	This class makes the actual I/O calls for disk access to      *)
(*	the file system. It handles page and CUD block I/O.  All      *)
(*	other data types use a multiple of pages.		      *)
(*                                                                    *)
(*    The following identifiers must be defined externally:           *)
(*	disk_unit_index				                      *)
(*      cud_disk_block                                                *)
(*      Disk_operation                                                *)
(*      Page                                                          *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          Revision Record                           *)
(*                                                                    *)
(*	03Feb86 - jrn						      *)
(*	      - add general procedcure IO_REQUEST		      *)
(*	13Dec84 - pgl						      *)
(*	      - add disk_io_page_request for logical_volumes	      *)
(*	14Oct84 - pgl						      *)
(*	      - add conditional assembly parameter 		      *)
(*		logical_volumes					      *)
(*	21Aug84 - jrn						      *)
(*	      - add conditional assembly parameter 		      *)
(*		OLD_LIST_CONFIGURATION to use code from here in the   *)
(*		old_node_host_list_utility class in NVDM	      *)
(*	20Jul84	- jrn						      *)
(*	      - change disk_system to perform I/O on lists and	      *)
(*		global_access					      *)
(*    29SEP83    original from (patrol)dsksys.tms - jrn		      *)
(*                                                                    *)
(**********************************************************************)



type DISK_SYSTEM = class(
	statistics	: statistics_gatherer);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			      io_request			      *)
(*                                                                    *)
(*	Do a character array read or write.			      *)
(*                                                                    *)
(**********************************************************************)

procedure io_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      unit_num		: disk_unit_index;
      io_operation	: disk_operation;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      io_address	: integer;
      io_length		: integer;
  var first_char	: char;
  var ok		: boolean);

var
  call_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 value_param : disk_param;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  with call_param do
    begin
      operation := io_operation;
      start_addr := io_address;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      byte_count := io_length
    end (* with *);
  value_param := call_param;
  io(first_char, value_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   DISK, unit_num);
  statistics.report_disk_io(call_param, value_param);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ok := value_param.status = COMPLETE
end (* io_request *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			      page_request			      *)
(*                                                                    *)
(*	Do a page read or write.				      *)
(*                                                                    *)
(**********************************************************************)

procedure
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
PAGE_REQUEST(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      unit_num		: disk_unit_index;
      page_operation	: disk_operation;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      address		: integer;
  var buffer		: univ page;
  var ok		: boolean);

begin
  io_request(unit_num, page_operation, address, PAGE_SIZE, buffer[0], ok)
end (* page_request *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			  named_list_request			      *)
(*                                                                    *)
(*	Do a named_list read or write.				      *)
(*                                                                    *)
(**********************************************************************)

procedure
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
entry
NAMED_LIST_REQUEST(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      unit_num		: disk_unit_index;
      list_operation	: disk_operation;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      address		: integer;
  var buffer		: univ disk_named_list_definition;
  var ok		: boolean);

begin
  io_request(unit_num, list_operation, address, MAXIMUM_BYTES_IN_NAMED_LIST,
    buffer[0], ok)
end (* named_list_request *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			  global_access_request			      *)
(*                                                                    *)
(*	Do a global_access read or write.			      *)
(*                                                                    *)
(**********************************************************************)

procedure
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
GLOBAL_ACCESS_REQUEST(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      unit_num		: disk_unit_index;
      io_operation	: disk_operation;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      page_address	: integer;
  var buffer		: univ disk_global_access_description;
  var ok		: boolean);

begin
  io_request(unit_num, io_operation, page_address,
    MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION, buffer[0], ok)
end (* global_access_request *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			      block_request			      *)
(*                                                                    *)
(*	Do a CUD block read or write.				      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure block_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      unit_num		: disk_unit_index;
      block_operation	: disk_operation;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var buffer		: cud_disk_block;
  var ok		: boolean);

var
  call_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 value_param : disk_param;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  with call_param do
    begin
      operation := block_operation;
      start_addr := block_address * MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      byte_count := MAXIMUM_CUD_BLOCK_SIZE
    end (* with *);
  value_param := call_param;
  io(buffer, value_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   DISK, unit_num);
  statistics.report_disk_io(call_param, value_param);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ok := value_param.status = COMPLETE
end (* block_request *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                          Read_CUD_Block                            *)
(*                                                                    *)
(*	Reads a cud_disk_block.					      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_CUD_BLOCK(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      unit_num		: disk_unit_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var cud_buffer	: univ cud_disk_block;
  var success		: Boolean);

begin
  block_request(unit_num,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   DISK_READ,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block_address, cud_buffer, success)
end (* READ_CUD_BLOCK *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                          Write_CUD_Block                           *)
(*                                                                    *)
(*	Writes a cud_disk_block.				      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_CUD_BLOCK(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      unit_num		: disk_unit_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var cud_buffer	: univ cud_disk_block;
  var success		: boolean);

begin
  block_request(unit_num,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   DISK_WRITE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block_address, cud_buffer, success)
end (* WRITE_CUD_BLOCK *);



(***************************  Disk_System  ****************************)
(**********************************************************************)



begin (* initial statement *)
end (* disk_system *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

!
(**********************************************************************)
(*                                                                    *)
(*	FILSYS.NTV						      *)
(*                        file_system_manager			      *)
(*                                                                    *)
(*    This monitor manages the files descriptors (from both the disk  *)
(*    and the config.ntv file.					      *)
(*                                                                    *)
(*    The following identifiers must be defined externally:           *)
(*      file_index		                                      *)
(*      file_descriptor                                               *)
(*      file_system_descriptor                                        *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          revision record                           *)
(*                                                                    *)
(*    29SEP83    original - jnm					      *)
(*								      *)
(**********************************************************************)


type FILE_SYSTEM_MANAGER = monitor;

var
  files : file_system_descriptor;
!
(************************  file_system_manager  ***********************)
(*                                                                    *)
(*                               lookup                               *)
(*                                                                    *)
(*    Translates a file_index into a file descriptor.                 *)
(*                                                                    *)
(**********************************************************************)

procedure entry lookup(
      index	: univ file_index;
  var desc	: file_descriptor);

begin
  desc := files[index]
end (* lookup *) ;
!
(************************  file_system_manager  ***********************)
(*                                                                    *)
(*                                reset                               *)
(*                                                                    *)
(*     Set up files.				                      *)
(*                                                                    *)
(**********************************************************************)


procedure entry RESET(
      new_files	: file_system_descriptor);

begin
  files := new_files
end (* RESET *) ;



(************************  file_system_manager  ***********************)
(**********************************************************************)


begin (* initial statement *)
end (* file_system_manager *) ;
!
(**********************************************************************)
(*                                                                    *)
(*	BSCFL.NTV						      *)
(*                             basic_file                             *)
(*                                                                    *)
(*    This class implements page-addressable random-access files      *)
(*    identified by file_id.  It assumes that higher levels will      *)
(*    use it properly.						      *)
(*                                                                    *)
(*    the following identifiers must be defined externally:           *)
(*      file_index	                                              *)
(*      file_descriptor                                               *)
(*      page                                                          *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          revision record                           *)
(*                                                                    *)
(*	26Nov84	 - pgl						      *)
(*	      - added function unit				      *)
(*	20Jul84	 - jrn						      *)
(*	      - change to only compute address and crash if outside   *)
(*		limit of file					      *)
(*    29SEP83    original from (patrol)bscfl.tms - jrn		      *)
(*								      *)
(**********************************************************************)


type BASIC_FILE = class(
	this_file	: file_index;
	file_system	: file_system_manager);

var
  crash_util : crash_utility;

  desc : file_descriptor;



(****************************  basic_file  ****************************)
(*                                                                    *)
(*                             initialize                             *)
(*                                                                    *)
(**********************************************************************)


procedure initialize;

begin
  init crash_util;
  file_system.lookup(this_file, desc)
end (* initialize *) ;



(****************************  basic_file  ****************************)
(*                                                                    *)
(*                               length                               *)
(*                                                                    *)
(**********************************************************************)


function entry LENGTH : integer;

begin
  length := desc.length
end (* LENGTH *) ;

(****************************  basic_file  ****************************)
(*                                                                    *)
(*                               unit                                 *)
(*                                                                    *)
(**********************************************************************)


function entry UNIT : integer;

begin
  unit := desc.unit
end (* UNIT *) ;


(****************************  basic_file  ****************************)
(*                                                                    *)
(*                            disk_address                            *)
(*                                                                    *)
(**********************************************************************)


function entry DISK_ADDRESS(
      pageno	: integer) : integer;

var
  physical_address : integer;

begin
  physical_address := desc.address + pageno;
  if pageno < desc.length
  then disk_address := physical_address
  else crash_util.signal_process_error
end (* disk_address *) ;



(****************************  basic_file  ****************************)
(**********************************************************************)


begin (* initial statement *)
  initialize
end (* basic_file *) ;

!
(************************************************************************)
(*									*)
(*	OPDEF.NTV							*)
(*									*)
(************************************************************************)

const
  OPER_LOG_HEADER_PAGE = operlog_file_length - 1  (* header page number *);

  OPER_LOG_DATA_LENGTH = operlog_file_length - 1 (* length of data *);
  OPER_LOG_PAGE_LIMIT = oper_log_data_length - 1;

type
  OPER_LOG_PAGE_INDEX = 0..oper_log_page_limit;
  OPER_LOG_ARCHIVE_PAGE_INDEX = 0..oper_log_header_page;

(* The last page of the operator log file is a header containing infor- *)
(* mation about what has been read from the file.  The rest of the pages*)
(* are log entries of 1 page each.					*)

type
  OPER_LOG_HEADER = record
    last_read_sequence	: integer;
    filler		: array [1..248] of char;
    checksum		: integer
  end (* oper_log_header *);

(*	Definition of data in each oper_log page *)

  OPER_LOG_ENTRY = record
    sequence	: integer;
    time	: integer;
    kind	: oper_log_message_kind;
    modify	: modify_type;
    cud_name	: username_string;
    login_number: validator_index;
    login_name	: username_string;
    sup_number	: integer;
    message     : log_message (* defined in globl.ntv *);
    checksum	: integer
  end (* oper_log_entry *);

const

(* These constants are used to index the oper_log_message_kind *)
  FIRST_MESSAGE_KIND = debugging_oplog_msg;
  LAST_MESSAGE_KIND =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
modify_cud_oplog_msg;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

type
  MESSAGE_KIND_INDEX = first_message_kind..last_message_kind;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	OPLOG.NTV							*)
(*									*)
(*				operator_log				*)
(*									*)
(*	This monitor maintains the operator log file.  Entries are be	*)
(*	written to the file in a sequential order, writing over old	*)
(*	records when necessary.  Records may be read either in a one	*)
(*	time mode or according to a time specified.			*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  statistics_gatherer, file_system_manager, identifier,		*)
(*	  oper_log_page_index, basic_file, validator_index,		*)
(*	  oper_log_header, oper_log_entry, log_message,			*)
(*	  oper_log_message_kind						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	03Sep86 - neh							*)
(*	      - Change WRITE procedure to be passed oper_log_entry	*)
(*		instead of message_kind and message.			*)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGES FROM command to NVDM			*)
(*	29Jul85 - jrn							*)
(*	      - change searches thru file to binary searches to		*)
(*		handle bigger files					*)
(*	18Dec84 - jrn							*)
(*	      - change to a class for NVDM and add			*)
(*		logical_volume_directory				*)
(*	14Oct84 - pgl						        *)
(*	      - add conditional assembly parameter		        *)
(*		logical_volumes					        *)
(*	20Jul84 - jrn							*)
(*	      - add checksum to each page				*)
(*	      - use new disk_system and basic_file			*)
(*	20Jun84 - jrn							*)
(*	      - use disk_maintenance_code parameter			*)
(*	29SEP83	Original from (patrol)oplog.nc2 -- jrn			*)
(*									*)
(************************************************************************)



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
type OPERATOR_LOG = monitor(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager);


var
  sys_io : system_handler;
  dsksys : disk_system;
  oplog_file : basic_file;

  validator_sequence : array [licensed_validator_index] of integer;
  next_read_sequence : integer (* sequence number of next read *);
  next_write_sequence : integer (* sequence number of next write *);
!



(***************************  operator_log  *****************************)
(*									*)
(*			       read_page				*)
(*									*)
(*      Read a page from the oper log file.				*)
(*									*)
(************************************************************************)

procedure read_page(
      addr	: integer;
  var buffer	: univ oper_log_entry;
  var success	: boolean);

var
  checksum : integer;

begin
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    FILE_SYSTEM_DISK, 
    DISK_READ,
     oplog_file.disk_address(addr),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    buffer, success);
  if success
  then
    begin
      sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD, buffer,
        checksum);
      success := buffer.checksum = checksum;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* read_page *);



(***************************  operator_log  *****************************)
(*									*)
(*			       write_page				*)
(*									*)
(*      Write a page to the oper log file.				*)
(*									*)
(************************************************************************)

procedure write_page(
      addr	: univ oper_log_archive_page_index;
  var buffer	: univ oper_log_entry;
  var success	: boolean);

begin
  sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD, buffer,
    buffer.checksum);
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    FILE_SYSTEM_DISK,
    DISK_WRITE,
    oplog_file.disk_address(addr),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    buffer, success);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* write_page *);



(****************************  operator_log  ****************************)
(*									*)
(*			    sequence_to_address				*)
(*									*)
(*      This routine converts a message sequence number to a file	*)
(*	address.							*)
(*									*)
(************************************************************************)

function sequence_to_address(
      sequence	: integer) : oper_log_page_index;

begin
  sequence_to_address := sequence mod OPER_LOG_DATA_LENGTH
end (* sequence_to_address *);



(***************************  operator_log  *****************************)
(*									*)
(*			set_next_write_sequence				*)
(*									*)
(*	Perform a searcyh for last entry written to set up		*)
(*	next_write_sequence.						*)
(*									*)
(************************************************************************)

procedure set_next_write_sequence;

var
  pi : oper_log_page_index;
  success : boolean;
  done : boolean;
  header : oper_log_header;
  log_entry : oper_log_entry;

begin
  next_write_sequence := next_read_sequence (* in case of disk errors *);
(* start with next record to be read and find oldest sequence... *)
(* that will be the place to write the next record *)
  pi := next_read_sequence; done := FALSE;
  repeat
    read_page(sequence_to_address(pi), log_entry, success);
    if success
    then
      if log_entry.sequence < pi
      then
        begin
	  done := TRUE;
	  next_write_sequence := pi
	end
      else
        if pi < (next_read_sequence + OPER_LOG_DATA_LENGTH)
	then pi := pi + 1
	else done := TRUE
  until not success or done
end (* set_next_write_sequence *);



(****************************  operator_log  ****************************)
(*									*)
(*			    adjust_read_sequence			*)
(*									*)
(*	This routine insures that a read sequence number refers to a	*)
(*	current message in the operator log.				*)
(*									*)
(************************************************************************)

procedure adjust_read_sequence(
  var sequence	: integer);

begin
  if (next_write_sequence - sequence) > OPER_LOG_DATA_LENGTH
  then sequence := next_write_sequence - OPER_LOG_DATA_LENGTH
end (* adjust_read_sequence *);



(*****************************  operator_log  ***************************)
(*									*)
(*			     do_find_timed_message			*)
(*									*)
(************************************************************************)

procedure do_find_timed_message(
      start_time	: integer;
  var this_sequence	: integer;
  var got_message	: boolean);

var
  oldest_sequence : integer;
  newest_sequence : integer;
  buffer  : oper_log_entry;
  success : boolean;

begin
  oldest_sequence := next_write_sequence - OPER_LOG_DATA_LENGTH;
  newest_sequence := next_write_sequence - 1;
  got_message := FALSE;
  repeat
    this_sequence := (oldest_sequence + newest_sequence) div 2;
    read_page(sequence_to_address(this_sequence), buffer, success);
    if success
    then
      begin
        if start_time <= buffer.time
	then newest_sequence := this_sequence - 1;
	if start_time >= buffer.time
	then oldest_sequence := this_sequence + 1
      end (* success *)
  until not success or (newest_sequence < oldest_sequence);
  if success and ((oldest_sequence - newest_sequence) >= 1)
  then got_message := TRUE
end (* do_find_timed_message *);



(*****************************  operator_log  ***************************)
(*									*)
(*			    do_read_timed_message			*)
(*									*)
(*	Read the message stored at validator_sequence in log_entry.	*)
(*	Advance to next message.					*)
(*									*)
(************************************************************************)

procedure do_read_timed_message(
  var this_sequence	: integer;
  var log_entry		: oper_log_entry;
  var got_message	: boolean);

begin
  adjust_read_sequence(this_sequence);
  if this_sequence = next_write_sequence
  then got_message := FALSE
  else
    begin (* this_sequence <> next_write_sequence *)
      read_page(sequence_to_address(this_sequence), log_entry, got_message);
      this_sequence := this_sequence + 1
    end (* this_sequence <> next_write_sequence *)
end (* do_read_timed_message *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  operator_log  *****************************)
(*									*)
(*				initialize				*)
(*									*)
(*	Set up next_read_sequence to be equal to last_read_sequence	*)
(*	from header of file; scan file for latest entry and set up	*)
(*	next_write_sequence.						*)
(*									*)
(************************************************************************)

procedure initialize;

var
  header : oper_log_header;
  success : boolean;

begin
  init oplog_file(OPERLOG_FILE, file_system);
  read_page(OPER_LOG_HEADER_PAGE, header, success);
  next_read_sequence := header.last_read_sequence;
  set_next_write_sequence
end (* initialize *);



(*****************************  operator_log  ***************************)
(*									*)
(*			     read_timed_message				*)
(*									*)
(*	Read the message stored at validator_sequence in log_entry.	*)
(*	Advance to next message.					*)
(*									*)
(************************************************************************)

procedure entry READ_TIMED_MESSAGE(
      validator	  : licensed_validator_index;
  var log_entry   : oper_log_entry;
  var got_message : boolean);

begin
  do_read_timed_message(validator_sequence[validator], log_entry, got_message)
end (* read_timed_message *);



(*****************************  operator_log  ***************************)
(*									*)
(*			     find_timed_message				*)
(*									*)
(************************************************************************)

procedure entry FIND_TIMED_MESSAGE(
      validator		: licensed_validator_index;
      start_time	: integer;
  var got_message	: boolean);

begin
  do_find_timed_message(start_time, validator_sequence[validator],
    got_message)
end (* find_timed_message *);



(***************************  operator_log  *****************************)
(*									*)
(*				   write				*)
(*									*)
(*      Write a message to the oper log file.				*)
(*									*)
(************************************************************************)

procedure entry WRITE(
  var new_log_entry : oper_log_entry);

var
  success : boolean;

begin
  with new_log_entry do
    begin
      sequence := next_write_sequence;
      time := REALTIME
    end (* with *);
  write_page(sequence_to_address(next_write_sequence), new_log_entry, success);
  next_write_sequence := next_write_sequence + 1
end (* write *);



(***************************  operator_log  *****************************)
(*                                                                      *)
(*                          read_operlog_page                           *)
(*                                                                      *)
(************************************************************************)

procedure entry READ_OPERLOG_PAGE(
      addr      : integer;
  var buffer    : univ oper_log_entry;
  var success   : boolean);

begin
  read_page(addr, buffer, success)
end (* read_operlog_page *);



(***************************  operator_log  *****************************)
(*									*)
(*				  read					*)
(*									*)
(*      Read the next sequential message from the operator log file.	*)
(*									*)
(************************************************************************)

procedure entry READ(
  var log_entry   : oper_log_entry;
  var got_message : boolean);

begin
  adjust_read_sequence(next_read_sequence);
  got_message := next_read_sequence < next_write_sequence;
  if got_message
  then read_page(sequence_to_address(next_read_sequence), log_entry,
    got_message)
end (* read *);



(***************************  operator_log  *****************************)
(*                                                                      *)
(*                          advance_address                             *)
(*                                                                      *)
(*      Validator is done with the record just read...advance the       *)
(*      address.  Record the address to the file                        *)
(*      header if the reader has caught up to the writer.               *)
(*                                                                      *)
(************************************************************************)

procedure entry ADVANCE_ADDRESS;

var
  header : oper_log_header;
  success : boolean;


begin
  next_read_sequence := next_read_sequence + 1;
  if next_read_sequence = next_write_sequence
  then
    begin
       header.last_read_sequence := next_read_sequence;
       write_page(OPER_LOG_HEADER_PAGE, header, success)
    end
end (* advance_address *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(***************************  operator_log  *****************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init sys_io, dsksys(statistics);
  initialize
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* operator_log *);
!
(************************************************************************)
(*									*)
(*	OPMSGS.NTV							*)
(*									*)
(*			operator_messages				*)
(*									*)
(*	Formats and outputs operator log messages.			*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  log_message, log_message_text_index, operator_log		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	03Sep86 - neh							*)
(*	      - Add permanent variable next_log_entry. Change procedure *)
(*		SAVE_MESSAGE to pass next_log_entry to oplog.write.	*)
(* 	      - Change procedure REPORT_MESSAGE to set modify, cud_name,*)
(*		login_number, login_name and sup_number.		*)
(*	      - Change REPORT_NUMBER_AND_NAME to assign validator name	*)
(*		to next_log_entry.login_name and validator number to	*)
(*		next_log_entry.login_number.				*)
(*	      - Add procedures REPORT_VALIDATOR_ENTRY,			*)
(*		REPORT_MODIFY_MESSAGE, REPORT_VALIDATOR_SUP_MESSAGE,	*)
(*		REPORT_MASTER_MESSAGE and REPORT_SUPERVISOR_MESSAGE.    *)
(*	14Nov85 - jrn							*)
(*	      - for Account Supervisor and Password Only validators,	*)
(*		add AUDITOR and OPERATOR control option message to	*)
(*		REPORT_LOGIN procedure					*)
(*	31Jul85 - jrn							*)
(*	      - add report_logout routine				*)
(*	08Mar85 - jrn							*)
(*	      - removed extra line at end of report_login		*)
(*	29SEP83	Original from (patrol)opmsgs.bas -- jrn			*)
(*									*)
(************************************************************************)

type OPERATOR_MESSAGES = class(
	oplog  : operator_log;
	format : internal_to_string);

var
  mutil : misc_utility;
  next_log_entry : oper_log_entry;

!
(*************************  operator_messages  **************************)
(*									*)
(*				save_message				*)
(*									*)
(************************************************************************)
procedure save_message(
      save_kind	: oper_log_message_kind);

var
  i	  : log_message_text_index;

begin
  with next_log_entry do
    begin
      kind := save_kind;
      if format.buffer.size > log_message_text_max
      then message.size := log_message_text_max
      else message.size := format.buffer.size;
      for i := 0 to message.size-1 do
        message.text[i] := format.buffer.text[i]
    end (* with *);
  oplog.write(next_log_entry)
end (* save_message *);



(*************************  operator_messages  **************************)
(*									*)
(*			      report_license				*)
(*									*)
(************************************************************************)

procedure report_license(
      license_to_check	: validator_license;
      option		: control_options;
      licenses		: validator_license_set;
  var first_license	: boolean);

begin
  if license_to_check in licenses (* if user has this license *)
  then
    begin (* display the option *)
      if first_license
      then
        begin
	  first_license := FALSE;
	  format.character(ASCII_COLON)
	end (* first_license *);
      format.character(ASCII_SPACE);
      format.short_control_option_name(option)
    end (* display the option *)
end (* report_license *);



(****************************  operator_messages  ***********************)
(*								        *) 
(*			do_report_validator_message			*) 
(*									*) 
(*	The procedure report_validator_message will add validator	*)
(*	type messages to the operator including the validator login	*)
(*	number and name.						*) 
(*									*) 
(************************************************************************) 

procedure do_report_validator_message(
      kind	: oper_log_message_kind;
      name	: username_string);

begin
  with next_log_entry do
    begin
      modify := FIRST_MODIFY_TYPE;
      cud_name.size := 0;
      login_name := name
    end (* with *);
  save_message(kind)
end (* do_report_validator_message *);



(*************************  operator_messages  **************************)
(*									*)
(*			       report_login				*)
(*									*)
(************************************************************************)

procedure entry REPORT_LOGIN(
      kind	: oper_log_message_kind;
      profile	: validator_profile);

var
  temp : integer;
  first_license : boolean;

begin
  with profile.needle do
    begin
      format.start_message('From host: \');
      temp := origin_host;
      mutil.clear_bit(BIT16, temp);
      format.number(temp, 10);
      format.string(' node: \');
      format.number(origin_node, 8);
      format.string(' port: \');
      temp := origin_port;
      mutil.clear_bit(BIT16, temp);
      format.number(temp, 10);
      format.string('d   invoice: \');
      format.number(invoice, 10)
    end (* with *);
  format.newline;
  format.string('validator login: \');
  format.validator_type_name(profile.level);
  format.skip(1);
  if profile.level <= ACCOUNT_SUPERVISOR_VALIDATOR
  then
    begin
      first_license := TRUE;
      report_license(AUDITOR_LICENSE, AUDITOR, profile.licenses,
        first_license);
      report_license(OPERATOR_LICENSE, OPERATOR, profile.licenses,
        first_license)
    end (* profile.level <= ACCOUNT_SUPERVISOR_VALIDATOR *);
  next_log_entry.sup_number := 0;
  next_log_entry.login_number := profile.validator;
  do_report_validator_message(kind, profile.name)
end (* report_login *);



(*************************  operator_messages  **************************)
(*									*)
(*			       report_logout				*)
(*									*)
(************************************************************************)

procedure entry REPORT_LOGOUT(
      kind	: oper_log_message_kind;
      profile		: validator_profile;
      logout_reason	: logout_cause);

begin
  format.start;
  format.logout_explanation(logout_reason);
  next_log_entry.sup_number := 0;
  next_log_entry.login_number := profile.validator;
  do_report_validator_message(kind, profile.name)
end (* report_logout *);



(************************  operator_messages  ***************************)
(*									*)
(*			    report_message				*)
(*									*)
(*	Report message of kind already set up in format.		*)
(*									*)
(************************************************************************)

procedure entry REPORT_MESSAGE(
      kind	: oper_log_message_kind);

begin
  with next_log_entry do
    begin
      modify := FIRST_MODIFY_TYPE;
      cud_name.size := 0;
      login_number := 0;
      login_name.size := 0;
      sup_number := 0
    end (* with *);
  save_message(kind)
end (* report_message *);



(***************************  operator_messages *************************) 
(*									*) 
(*		 	    report_validator_message			*)
(*									*) 
(*	Set next_log_entry.sup_number to zero and report validator	*)
(*	entry.								*)
(*									*) 
(************************************************************************) 

procedure entry REPORT_VALIDATOR_MESSAGE(
      profile	: validator_profile);

begin
  next_log_entry.sup_number := 0;
  next_log_entry.login_number := profile.validator;
  do_report_validator_message(VALIDATOR_OPLOG_MSG, profile.name)
end (* report_validator_message *);



(***************************  operator_messages *************************) 
(*									*) 
(*		 	 report_by_validator_message			*)
(*									*) 
(*	Set next_log_entry.sup_number to the sup which is passed and    *)
(*	report validator entry.						*)
(*									*) 
(************************************************************************) 

procedure entry REPORT_BY_VALIDATOR_MESSAGE(
      name	: username_string;
      kind	: oper_log_message_kind);

begin
  next_log_entry.login_number := 0;
  next_log_entry.sup_number := 0;
  do_report_validator_message(kind, name)
end (* report_by_validator_message *);



(***************************  operator_messages *************************) 
(*									*) 
(*		 	 report_validator_sup_message			*)
(*									*) 
(*	Set next_log_entry.sup_number to the sup which is passed and    *)
(*	report validator entry.						*)
(*									*) 
(************************************************************************) 

procedure entry REPORT_VALIDATOR_SUP_MESSAGE(
      profile	: validator_profile;
      sup	: real_supervisor_index;
      kind	: oper_log_message_kind);

begin
  next_log_entry.sup_number := sup;
  next_log_entry.login_number := profile.validator;
  do_report_validator_message(kind, profile.name)
end (* report_validator_sup_message *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(**************************  operator_messages  *************************) 
(*									*) 
(*			  report_modify_message				*) 
(*									*) 
(*	The procedure report_modify_message will add modify type	*) 
(*	messages to the operator log.					*) 
(*									*) 
(************************************************************************) 

procedure entry REPORT_MODIFY_MESSAGE(
	name		: username_string;
	number		: validator_index;
	cud_change 	: cud_change_indicator;
	cud_name_change	: username_string;
	oplog_remark	: oplog_remark_message);

var
  oplog_remark_ptr : oplog_remark_index;

begin
  format.start;
  if oplog_remark.size > 0
  then
    begin
      for oplog_remark_ptr := 0 to oplog_remark.size - 1 do
	format.character(oplog_remark.chars[oplog_remark_ptr]);
      format.newline
    end (* oplog_remark.size > 0 *);
  format.cud_change_description(cud_change);
  format.colon_space;
  with next_log_entry do
    begin
      login_name := name;
      login_number := number;
      case cud_change of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        NEW_USER_CUD_CHANGE: modify := NEW;
        CHANGE_GAN_CUD_CHANGE: modify := GAN;
        CHANGE_PASSWORD_CUD_CHANGE: modify := PASSWORD;
        RENAME_DELETE_USER_CUD_CHANGE,
        RENAME_RESTORE_OLD_NAME,
        RENAME_NEW_USER_CUD_CHANGE: modify := CHANGENAME;
        DELETE_USER_CUD_CHANGE: modify := DELETE;
        CHANGE_OPTIONS_CUD_CHANGE: modify := CONTROL;
        CHANGE_DISTRICT_CUD_CHANGE: modify := DISTRICT;
        CHANGE_UUN_CUD_CHANGE: modify := UUN;
        CHANGE_ACCESS_CUD_CHANGE: modify := ACCESS
      end (* case *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_name := cud_name_change;
      sup_number := 0
    end (* with *);
  save_message(MODIFY_CUD_OPLOG_MSG)
end (* report_modify_message *);



(************************  operator_messages  ***************************) 
(*									*) 
(*			report_supervisor_message			*) 
(*									*) 
(*	The procedure report_supervisor_message will add supervisor	*) 
(*	type messages to the operator log.				*) 
(*									*) 
(************************************************************************) 

procedure entry REPORT_SUPERVISOR_MESSAGE(
	sup		: real_supervisor_index;
	kind		: oper_log_message_kind);

begin
  with next_log_entry do
    begin
      sup_number := sup;
      modify := FIRST_MODIFY_TYPE;
      cud_name.size := 0;
      login_name.size := 0;
      login_number := 0
    end (* with *);
  save_message(kind)
end (* report_supervisor_message *);


(*************************  operator_messages  **************************)
(************************************************************************)

begin (* initial statement *) 
  init mutil
end (* operator_messages *);
!
(**********************************************************************)
(*								      *)
(*	FUTIL.NTV						      *)
(*                                                                    *)
(*			     file_utility			      *)
(*                                                                    *)
(*    This class handles the reporting of errors to the		      *)
(*    OPERATOR_LOG.						      *)
(*                                                                    *)
(*     The following identifiers must be defined externally:          *)
(*	 operator_messages, file_index, page,			      *)
(*	 basic_file						      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*	21Jan86 - jrn						      *)
(*	      - modify disk error operlog messages to include	      *)
(*		physical address				      *)
(*	19Jun85 - jrn						      *)
(*		- add parameter check_checksum to all read routines   *)
(*		- add parameter do_checksunm to all write routines    *)
(*	        - expand use of report_error			      *)
(*	26Nov84 - Version 3.00 - pgl				      *)
(*	      - calls to dsksys.page_request use function,	      *)
(*		bfile.unit	    				      *)
(*	      - add conditional assembly parameter LOGICAL_VOLUMES    *)
(*	20Jul84 - jrn						      *)
(*	      - use new disk_system, basic_file and global_access     *)
(*	20Jun84 - jrn						      *)
(*	      - use READING_MESSAGE and WRITING_MESSAGE		      *)
(*	14Mar84	Version 2.01 - jrn				      *)
(*	      - removed sequential procedures			      *)
(*	29SEP83    Original -- jnm (from (basicws)futil.bes)	      *)
(*                                                                    *)
(**********************************************************************)

type
  FILE_UTILITY_OPERATION = (FU_READ, FU_WRITE);


type FILE_UTILITY = class(
	this_file	: file_index;
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oper_messages	: operator_messages;
	format		: internal_to_string);

var
  dsksys	: disk_system;
  bfile		: basic_file;
  sys_io	: system_handler;
!
(**************************  file_utility  ******************************)
(*									*)
(*			     report_error				*)
(*									*)
(*    Report file error in file.					*)
(*									*)
(************************************************************************)

procedure report_error(
      checksum_error	: boolean;
      file_operation	: file_utility_operation;
      location		: univ integer);

var
  desc : file_descriptor;

begin
  format.start_message('error \ ');
  case file_operation of
    FU_READ:
      begin
        if checksum_error
	then format.string('in checksum while \ ');
        format.string(READING_MESSAGE);
      end (* FU_READ *);
    FU_WRITE: format.string(WRITING_MESSAGE)
  end (* case *);
  format.string(' file: \');
  format.file_name(this_file);
  format.string(' at \ ');
  format.number(location, 10);
  file_system.lookup(this_file, desc);
  format.unit_and_sector(desc.unit, desc.address+location);
  oper_messages.report_message(FILE_OPLOG_MSG)
end (* report_error *);
!



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			         length				      *)
(*                                                                    *)
(*    Return length of file in pages.				      *)
(*                                                                    *)
(**********************************************************************)

function entry LENGTH : integer;

begin
  length := bfile.length
end (* LENGTH *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			       read_random			      *)
(*                                                                    *)
(*    Read the given page from the file.			      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_RANDOM(
      check_checksum	: boolean;
      location		: integer;
  var page_buffer	: univ page_record;
  var io_status		: file_utility_status);

var
  success : boolean;
  computed_checksum : integer;

begin
  io_status := FU_SUCCESS;
  dsksys.page_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_READ,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), page_buffer, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_READ, location)
    end
  else
    if check_checksum
    then
      begin
        sys_io.page_checksum(PAGE_SIZE-MAXIMUM_BYTES_IN_WORD, page_buffer,
	  computed_checksum);
	if computed_checksum <> page_buffer.checksum
	then
	  begin
	    io_status := FU_CHECKSUM_ERROR;
	    report_error(TRUE, FU_READ, location)
	  end
      end (* read was a success *)
end (* read_random *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			      write_random			      *)
(*                                                                    *)
(*    Write the page at the given location.			      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_RANDOM(
      do_checksum	: boolean;
      location		: integer;
  var page_buffer	: univ page_record;
  var io_status		: file_utility_status);

var
  success : boolean;

begin
  io_status := FU_SUCCESS;
  if do_checksum
  then sys_io.page_checksum(PAGE_SIZE-MAXIMUM_BYTES_IN_WORD, page_buffer,
    page_buffer.checksum);
  dsksys.page_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   DISK_WRITE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), page_buffer, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_WRITE, location)
    end
end (* write_random *);
!



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			    read_named_list			      *)
(*                                                                    *)
(*    Read the given named_list from the file.			      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_NAMED_LIST(
      location		: integer;
  var named_list	: named_list_definition;
  var io_status		: file_utility_status);

var
  success : boolean;
  computed_checksum : integer;

begin
  io_status := FU_SUCCESS;
  dsksys.named_list_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   DISK_READ,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), named_list, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_READ, location)
    end
  else
    begin
      sys_io.named_list_checksum(named_list, computed_checksum);
      if computed_checksum <> named_list.checksum
      then
        begin
	  io_status := FU_CHECKSUM_ERROR;
	  report_error(FALSE, FU_READ, location)
	end
      end (* read was a success *)
end (* read_named_list *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			     write_named_list			      *)
(*                                                                    *)
(*    Write the named_list at the given location.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_NAMED_LIST(
      location		: integer;
  var named_list	: named_list_definition;
  var io_status		: file_utility_status);

var
  success : boolean;

begin
  io_status := FU_SUCCESS;
  sys_io.named_list_checksum(named_list, named_list.checksum);
  dsksys.named_list_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_WRITE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), named_list, success);
  if not success
  then report_error(FALSE, FU_WRITE, location)
end (* WRITE_NAMED_LIST *);
!



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			    read_global_access			      *)
(*                                                                    *)
(*    Read the given global_access from the file.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_GLOBAL_ACCESS(
      location		: integer;
  var global_access	: global_access_description;
  var io_status		: file_utility_status);

var
  success : boolean;
  computed_checksum  : integer;

begin
  io_status := FU_SUCCESS;
  dsksys.global_access_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_READ,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), global_access, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_READ, location)
    end
  else
    begin
      sys_io.global_access_checksum(global_access, computed_checksum);
      if computed_checksum <> global_access.checksum
      then
        begin
	  io_status := FU_CHECKSUM_ERROR;
	  report_error(TRUE, FU_READ, location)
	end
      end (* read was a success *)
end (* read_global_access *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			   write_global_access			      *)
(*                                                                    *)
(*    Write the global_access the given location.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_GLOBAL_ACCESS(
      location		: integer;
  var global_access	: global_access_description;
  var io_status		: file_utility_status);

var
  success : boolean;

begin
  io_status := FU_SUCCESS;
  sys_io.global_access_checksum(global_access, global_access.checksum);
  dsksys.global_access_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_WRITE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), global_access, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_WRITE, location)
    end
end (* write_global_access *);


(***************************  file_utility  ***************************)
(**********************************************************************)

begin (* initial statement *)
  init dsksys(statistics), bfile(this_file, file_system)
end (* FILE_UTILITY *);
!
(************************************************************************)
(*									*)
(*	CBUTIL.NTV							*)
(*									*)
(*			    cud_block_utility				*)
(*									*)
(*	The cud_block_utility class includes routines to compute	*)
(*	the CUD block checksum and record CUD block errors to the	*)
(*	operator log (unless disk_maintenance_code is ENABLED).		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18Dec84 - jrn, pgl - Version 3.00				*)
(*	      - moved cud_block_byte_count to cud_entry_utility		*)
(*	      - add logical_volume_directory				*)
(*	      - add conditional assembly parameter LOGICAL_VOLUMES	*)
(*	      - use engine checksum for disk				*)
(*	08Mar85 - jrn - Version 2.03					*)
(*	      - fixed a bug that allowed a format error in a CUD block	*)
(*		to crash NETVAL; if an odd size is picked up, the total	*)
(*		size of the data in the CUD block is then odd, and the	*)
(*		Nucleus checksum call causes an illegal instruction.	*)
(*	15Jun84	jrn							*)
(*	      - add disk_maintenance_code assembly parameter		*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

type CUD_BLOCK_UTILITY = class(
	mutil		: misc_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 	oper_messages		: operator_messages;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	format		: internal_to_string;
	dsksys		: disk_system);


var
  sys_io : system_handler;
!
(*************************  cud_block_utility  **************************)
(*									*)
(*				report_error				*)
(*									*)
(*      Report CUD block error to operator_log or terminal.		*)
(*									*)
(************************************************************************)

procedure entry REPORT_ERROR(
      result	: cud_operation_result;
      block	: univ integer);

begin
  format.cud_block_error(block, result);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
oper_messages.report_message(CUD_OPLOG_MSG)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* report_error *);



(*************************  cud_block_utility  **************************)
(*									*)
(*			     read_cud_block				*)
(*									*)
(*      Input the CUD block into cud_buffer.				*)
(*									*)
(************************************************************************)

procedure entry READ_CUD_BLOCK(
      block		: univ cud_block_index;
  var result		: cud_operation_result;
  var cud_buffer	: univ cud_disk_block); 

var
  computed_checksum : integer;
  success : boolean;

begin
  dsksys.read_cud_block(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CUD_DISK_UNIT,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block, cud_buffer, success);
  if not success
  then result := CUD_OPERATION_FAILED
  else
    begin
      sys_io.cud_checksum(MAXIMUM_CUD_DATA,cud_buffer.data,computed_checksum);
      if computed_checksum <> cud_buffer.checksum
      then result := CUD_CHECKSUM_ERROR
      else result := CUD_OPERATION_OK
    end
end (* read_cud_block *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init sys_io
end (* cud_block_utility *);
!
(************************************************************************)
(*									*)
(*	LOGONM.NTV							*)
(*									*)
(*			  login_distributer				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  validator_type, validator_index, username_string,		*)
(*	  terminal_unit_index						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	22Jan86 - jrn							*)
(*	      - add VALIDATOR_COUNT procedure				*)
(*	02Jul85 jrn							*)
(*	      - change for logical volumes to deal with one less	*)
(*		terminal						*)
(*	07Aug84 Version 3.00 - jrn/pgl					*)
(*	      - procedure login_validator changed to handle 		*)
(*		MASTER_VALIDATOR, if NETVAL_IS_A_SLAVE			*)
(*		is enabled						*)
(*	14Jun84 Version 2.02	jrn					*)
(*	      - added licenses, AUDITOR_LICENSE and OPERATOR_LICENSE	*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type LOGIN_DISTRIBUTER = monitor;



type (* information about each validator process *)
  validator_pool_information = record
    login_waiter	: queue (* wait for login here *);
(* in the following record, "level" is only meaningful *)
(* if login_waiter is empty *)
    info	: validator_login_information
  end (* validator_pool_information *);


var
  AVAILABLE_UNITS : array [terminal_unit_index] of boolean;

  WAITING_FOR_UNIT : queue;

  VALIDATOR_SINK : array [validator_index] of validator_pool_information;
!
(*************************  login_distributer  **************************)
(*									*)
(*			   	initialize				*)
(*									*)
(*	Set all terminal units to available.				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  unit : terminal_unit_index;

begin
  for unit := 0 to TERMINAL_UNIT_LIMIT do
    available_units[unit] := TRUE
end (* initialize *);



(*************************  login_distributer  **************************)
(*									*)
(*			   	find_free				*)
(*									*)
(*	Find an available validator process in the range specified	*)
(*	(first through last); success is TRUE if one was found,		*)
(*	the one found is specified in validator_found.			*)
(*									*)
(************************************************************************)

procedure find_free(
      first		: validator_index;
      last		: validator_index;
  var success		: boolean;
  var validator_found	: validator_index);

var
  validator : validator_index;

begin
  success := FALSE;
  for validator := first to last do
    if not empty(validator_sink[validator].login_waiter)
    then
      begin
        success := TRUE;
	validator_found := validator
      end
end (* find_free *);



(*************************  login_distributer  **************************)
(*									*)
(*		       another_validator_available			*)
(*									*)
(*	Return TRUE if there is another available licensed validator	*)
(*	login.								*)
(*									*)
(************************************************************************)

function ANOTHER_VALIDATOR_AVAILABLE : boolean;

var
  validator : validator_index;
  available : integer;

begin
  available := MAXIMUM_LICENSED_VALIDATORS;
  for validator := FIRST_LICENSED_VALIDATOR to VALIDATOR_LIMIT do
    if empty(validator_sink[validator].login_waiter)
    then available := available - 1;
  another_validator_available := available > 1
end (* another_validator_available *);



(*************************  login_distributer  **************************)
(*									*)
(*		      		logged_in				*)
(*									*)
(*	Return TRUE if there is a validator of the type specified	*)
(*	already logged in.						*)
(*									*)
(************************************************************************)

function logged_in(
      level_to_check	: validator_type) : boolean;

var
  validator : validator_index;

begin
  logged_in := FALSE;
  for validator := FIRST_LICENSED_VALIDATOR to VALIDATOR_LIMIT do
    if empty(validator_sink[validator].login_waiter) and
      (validator_sink[validator].info.level = level_to_check)
    then logged_in := TRUE
end (* logged_in *);



(*************************  login_distributer  **************************)
(*									*)
(*			     login_validator				*)
(*									*)
(*	Login the user on the port.  If not successful, there is no	*)
(*	validator process of the type required.  This routine is	*)
(*	called by ACCEPT_LOGIN Processes when a needle is detected.	*)
(*									*)
(************************************************************************)

procedure entry LOGIN_VALIDATOR(
      new_info	: validator_login_information;
  var success	: boolean);

var
  validator : validator_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if (new_info.level = PASSWORD_ONLY_VALIDATOR) and
    not (AUDITOR in new_info.options) and not (OPERATOR in new_info.options)
  then find_free(FIRST_PASSWORD_ONLY_VALIDATOR, PASSWORD_ONLY_VALIDATOR_LIMIT,
    success, validator)
  else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    if (new_info.level = PROGRAMMER_VALIDATOR) and
      logged_in(PROGRAMMER_VALIDATOR)
    then success := FALSE	(* only allow one PROGRAMMER *)
    else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      begin
        find_free(FIRST_LICENSED_VALIDATOR, LICENSED_VALIDATOR_LIMIT, success,
          validator);
        if success and
	  ((new_info.level = ACCOUNT_SUPERVISOR_VALIDATOR) or
	   (new_info.level = PASSWORD_ONLY_VALIDATOR))
        then success :=
          another_validator_available or 
	  (logged_in(PROGRAMMER_VALIDATOR) or
	   logged_in(NETWORK_ADMINISTRATOR_VALIDATOR))
      end;
  if success
  then
    begin
      validator_sink[validator].info :=  new_info;
      continue(validator_sink[validator].login_waiter)
    end
end (* login_validator *);
!
(*************************  login_distributer  **************************)
(*									*)
(*			     release_unit				*)
(*									*)
(*	Relase the terminal unit and continue the waiting login		*)
(*	process.							*)
(*									*)
(************************************************************************)

procedure entry RELEASE_UNIT(
      unit	: terminal_unit_index);

begin
  available_units[unit] := TRUE;
  continue(waiting_for_unit)
end (* release_unit *);



(*************************  login_distributer  **************************)
(*									*)
(*			     wait_for_login				*)
(*									*)
(*	Wait for a login for this type validator.		        *)
(*									*)
(************************************************************************)

procedure entry WAIT_FOR_LOGIN(
      profile	: validator_profile;
  var unit	: terminal_unit_index);

begin
  delay(validator_sink[profile.validator].login_waiter)	(* wait here *);

  profile.set_validator(validator_sink[profile.validator].info);
  unit := validator_sink[profile.validator].info.unit
end (* wait_for_login *);
!
(*************************  login_distributer  **************************)
(*									*)
(*			    get_available_unit				*)
(*									*)
(************************************************************************)

procedure entry GET_AVAILABLE_UNIT(
  var unit	: terminal_unit_index);

var
  done,
  found_unit : boolean;

begin
  done := FALSE;
  repeat
    found_unit := FALSE;
    unit := 0;
    repeat
      if available_units[unit]
      then
        begin
	  done := TRUE;
	  found_unit := TRUE;
	  available_units[unit] := FALSE
	end
      else
        if unit = TERMINAL_UNIT_LIMIT
	then done := TRUE
	else unit := unit + 1
    until done;
    if not found_unit
    then
      begin
        delay(waiting_for_unit);
	done := FALSE
      end
  until done and found_unit
end (* get_available_unit *);
!
(*************************  login_distributer  **************************)
(*									*)
(*			     validator_name				*)
(*									*)
(************************************************************************)

procedure entry VALIDATOR_NAME(
      validator	: validator_index;
  var name	: username_string);

begin
  name := validator_sink[validator].info.name
end (* validator_name *);



(*************************  login_distributer  **************************)
(*									*)
(*			     validator_count				*)
(*									*)
(************************************************************************)

procedure entry VALIDATOR_COUNT(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var password_only_count	: password_only_validator_count;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var licensed_count		: licensed_validator_count;
  var programmer_count	: integer);

var
  validator : validator_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  password_only_count := 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  licensed_count := 0; programmer_count := 0;
  for validator := FIRST_VALIDATOR to VALIDATOR_LIMIT do
    if empty(validator_sink[validator].login_waiter)
    then
      case validator_sink[validator].info.level of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PASSWORD_ONLY_VALIDATOR: password_only_count := password_only_count+1;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	ACCOUNT_SUPERVISOR_VALIDATOR,
	NETWORK_ADMINISTRATOR_VALIDATOR: licensed_count := licensed_count + 1;
	PROGRAMMER_VALIDATOR: programmer_count := programmer_count + 1
      end (* case *)
end (* validator_count *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  initialize
end (* login_distributer *);
!
(************************************************************************)
(*									*)
(*	MUDUTL.NTV							*)
(*									*)
(*			    mudupd_utility				*)
(*									*)
(*	This Class contains various general mud_update file routines.	*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  mudupd_address, page, word_in_bytes, cud_change_header,	*)
(*	  mudupd_data_index, cud_change_information, file_utility	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - use CLEAR_PAGE						*)
(*	10/20/83 Original -- jrn					*)
(*									*)
(************************************************************************)

type MUDUPD_UTILITY = class(
	mutil		: misc_utility;
	format		: internal_to_string;
	oper_messages	: operator_messages;
	mud_update	: file_utility);
!



(***************************  mudupd_utility  ***************************)
(*									*)
(*			        do_write_page				*)
(*									*)
(************************************************************************)

procedure do_write_page(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

var
  io_status : file_utility_status;

begin
  mud_update.write_random(FALSE, location, buffer, io_status);
  success := io_status = FU_SUCCESS
end (* do_write_page *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			      do_read_page				*)
(*									*)
(************************************************************************)

procedure do_read_page(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

var
  io_status : file_utility_status;

begin
  mud_update.read_random(FALSE, location, buffer, io_status);
  success := io_status = FU_SUCCESS
end (* read_page *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*				get_byte				*)
(*									*)
(*      Return the next character, increment file_address		*)
(*	by one and read in a new page if necessary.			*)
(*									*)
(************************************************************************)

procedure GET_BYTE(
  var file_address	: mudupd_address;
  var data		: page;
  var success		: boolean;
  var byte		: char);

begin
  success := TRUE;
  byte := data[file_address.byte_offset];
  if file_address.byte_offset < PAGE_LIMIT
  then file_address.byte_offset := file_address.byte_offset + 1
  else
    if file_address.page_offset < MUDUPD_PAGE_LIMIT
    then
      begin (* input next page of data *)
        file_address.page_offset := file_address.page_offset + 1;
	do_read_page(file_address.page_offset, data, success);
	file_address.byte_offset := 0
      end
    else success := FALSE (* END OF FILE *)
end (* get_byte *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			   next_two_mudupd_bytes			*)
(*									*)
(*      Return the next two bytes in data pointed to by file_address	*)
(*	in a word; increment file_address past the bytes.		*)
(*									*)
(************************************************************************)

procedure NEXT_TWO_MUDUPD_BYTES(
  var file_address	: mudupd_address;
  var data		: page;
  var success		: boolean;
  var two_bytes		: univ word_in_bytes);

begin
  two_bytes[0] := ZERO;
  two_bytes[1] := ZERO;
  get_byte(file_address, data, success, two_bytes[2]);
  if success
  then get_byte(file_address, data, success, two_bytes[3])
end (* next_two_mudupd_bytes *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			   extract_header_value				*)
(*									*)
(************************************************************************)

procedure EXTRACT_HEADER_VALUE(
      value_limit	: integer;
      value_error	: quoted_text;
  var file_address	: mudupd_address;
  var success		: boolean;
  var header_value	: univ integer;
  var data		: page);

begin
  next_two_mudupd_bytes(file_address, data, success, header_value);
  if success
  then
    if header_value >= value_limit
    then
      begin
        success := FALSE;
	format.start_message('Format error in mud_update file in block \');
	format.number(file_address.page_offset, 10);
	format.string(' at \ ');
	format.number(file_address.byte_offset, 10);
	format.colon_space;
	format.string(' illegal \');
	format.string(value_error);
	oper_messages.report_message(MUDUPD_OPLOG_MSG)
      end
end (* extract_header_value *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			  compute_mudupd_address			*)
(*									*)
(*      Translate disk_pointer that describes the location		*)
(*	of the data into a page and byte offset.			*)
(*									*)
(************************************************************************)

procedure entry COMPUTE_MUDUPD_ADDRESS(
      disk_pointer	: mudupd_data_index;
  var file_address	: mudupd_address);

begin
  file_address.page_offset :=
    PAGES_IN_MUDUPD_HEADER + (disk_pointer div PAGE_SIZE);
  file_address.byte_offset := disk_pointer mod PAGE_SIZE
end (* compute_mudupd_address *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			    disk_byte_address				*)
(*									*)
(*      Translate file_address into a disk byte address.		*)
(*									*)
(************************************************************************)

function entry DISK_BYTE_ADDRESS(
	file_address : mudupd_address) : mudupd_data_index;

begin
  disk_byte_address :=
    ((file_address.page_offset - PAGES_IN_MUDUPD_HEADER) * PAGE_SIZE) +
      file_address.byte_offset
end (* disk_byte_address *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			     put_mudupd_byte				*)
(*									*)
(*      Save character, increment file_address by one and write		*)
(*	out the page if necessary.					*)
(*									*)
(************************************************************************)

procedure entry PUT_MUDUPD_BYTE(
      byte		: char;
  var file_address	: mudupd_address;
  var data		: page;
  var success		: boolean);

begin
  success := TRUE;
  data[file_address.byte_offset] := byte;
  if file_address.byte_offset < PAGE_LIMIT
  then file_address.byte_offset := file_address.byte_offset + 1
  else
    if file_address.page_offset = MUDUPD_PAGE_LIMIT
    then success := FALSE
    else
      begin
        do_write_page(file_address.page_offset, data, success);
	file_address.page_offset := file_address.page_offset + 1;
	file_address.byte_offset := 0;
	mutil.clear_page(data)
      end
end (* put_mudupd_byte *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			    extract_cud_change				*)
(*									*)
(*      Return the CUD change stored in the MUD_UPDATE_FILE at		*)
(*	file_address; increment file_address past change.		*)
(*									*)
(************************************************************************)

procedure entry EXTRACT_CUD_CHANGE(
  var file_address	: mudupd_address;
  var success		: boolean;
  var change		: cud_change_information);

var
  data : page;
  pointer : cud_data_index;
  filler : integer;

begin
  do_read_page(file_address.page_offset, data, success);

  if success
  then extract_header_value(MAXIMUM_CUD_BLOCK, 'CUD_BLOCK_INDEX\',
    file_address, success, change.header.block, data);

  if success
  then extract_header_value(CUD_DATA_WORD_MAXIMUM, 'CUD_DATA_WORD_INDEX\',
    file_address, success, change.header.offset, data);

  if success
  then extract_header_value(CUD_DATA_WORD_MAXIMUM + 1, 'CUD_DATA_WORD_SIZE\ ',
    file_address, success, change.header.size, data);
  if success (* pick up 2 bytes to fill out header word *)
  then next_two_mudupd_bytes(file_address, data, success, filler);
  if success
  then
    begin	(* extract the CUD data *)
      for pointer := 0 to CUD_DATA_LIMIT do
        change.data[pointer] := ZERO;
      for pointer := 0 to (change.header.size * MAXIMUM_BYTES_IN_WORD) - 1 do
        if success
        then get_byte(file_address, data, success, change.data[pointer])
    end
end (* extract_cud_change *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			        write_page				*)
(*									*)
(************************************************************************)

procedure entry WRITE_PAGE(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

begin
  do_write_page(location, buffer, success)
end (* write_page *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			      read_page					*)
(*									*)
(************************************************************************)

procedure entry READ_PAGE(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

begin
  do_read_page(location, buffer, success)
end (* read_page *);




(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* mudupd_utility *);
!
(************************************************************************)
(*									*)
(*	MUDCHG.NTV							*)
(*									*)
(*			    mud_change_handler				*)
(*									*)
(*	This Monitor controls the updating of the Supervisor MUDs	*)
(*	and Class/group Table.  Pertinent information is maintained	*)
(*	on the disk in the MUD_UPDATE file, and the monitor controls	*)
(*	the access and updating of the file.				*)
(*									*)
(*      The routines are organized as follows:				*)
(*		initialization routines					*)
(*		merge UUN routines					*)
(*		legal Supervisor routines				*)
(*		consistency schedule routines				*)
(*		class/group routines					*)
(*		cud_entry_updater routines				*)
(*		mud_updater routines					*)
(*		consistency routines					*)
(*		tick routines						*)
(*		validator command routines				*)
(*		archive routines					*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  class_group_status, consistency_info, mudupd_address, page,	*)
(*	  mudupd_disk_header, mudupd_data_index, validator_index,	*)
(*	  cud_data, cud_change_information, supervisor_index,		*)
(*	  word_in_bytes, cud_block_index, in_core_supervisor_info	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18May87 - neh							*)
(*		- change make_new_file to turn off supervisors		*)
(*		  greater than MAXIMUM_EXPECTED_SUPERVISORS		*)
(*	31Jul86 - rsb							*)
(*		- add "current_un2_activity" of type 			*)
(*		  "current_comm_activity" to IN_CORE_INFO		*)
(*		  use it insetad of checking for consistency start_time *)
(*		  not being 0 as an indicator of what Netval is doing   *)
(*		- modify SET_SUPERVISOR to use 				*)
(*		  sup_core_info.current_un2_activity			*)
(*		  which involves rewriting SET_SUP:OFF into a four-way  *)
(*		  case statement.					*)
(*		- change name of REPORT_CONSISTENCY_START to		*)
(*		  RECORD_CONSISTENCY_STARTED.				*)
(*		  SET_SUP:ON at start set current_un2_activity to	*)
(*		  NOT_BUSY.  Also set it to AUTO_CONSISTENCY if that	*)
(*		  flag is true.						*)
(*		- add setting of CURRENT_UN2_ACTIVITY := NOT_BUSY to	*)
(*		  REPORT_CONSISTENCY_OVER				*)
(*		- change name of DO_CLEAR_SUP_INFO to 			*)
(*		  INIT_SUP_INFO						*)
(*		- change name of CLEAR_CURRENT_CONSISTENCY_SUP_INFO to	*)
(*		  CLEAR_CURRENT_CONSISTENCY_SUP_SINK_INFO		*)
(*		- change name of CLEAR_CURRENT_SUP_INFO to		*)
(*		  INIT_SUP_CORE_INFO					*)
(*		- change SUP_INFO into SUP_DISC_INFO			*)
(*		- change SUP_SINK into SUP_CORE_INFO			*)
(*		- change name of set_to_be_stopped_true into		*)
(*		  SET_TO_BE_STOPPED_TRUE				*)
(*		- change name of 					*)
(*		  supervisor_in_core_information.INITIALIZING to	*)
(*		  ....RUN_INIT_AUTO_CONSISTENCY				*)
(*		- change name of SET_SUPERVISOR_OFF to			*)
(*		  SET_SUP_OFF in order to create an entry point		*)
(*		  called SET_SUPERVISOR_OFF for calling by MUDUPDATER	*)
(*		- create entry point CONTINUE_WAIT_FOR_STOP_QUE so	*)
(*		  mudupdater can continue a set_sup:off.		*)
(*	25Apr86 - jrn							*)
(*	      - fix bug that caused defining the consistency period	*)
(*		across the end of day boundry not to work		*)
(*	01Apr86 - jrn							*)
(*	      - if Tymnet, add a delay queue for the oplog_reporter	*)
(*		process							*)
(*	10Mar86 - jrn							*)
(*	      - redo reuse_uuns to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - change merge_month_changed to delay_uun_merger;		*)
(*		the merge_uun process will be delayed in the uun_merger	*)
(*		queue until it is time to perform the merge; it is	*)
(*		continued by the check_time procedure			*)
(*	      - change merge_month to last_merge			*)
(*	13Feb86 - rsb							*)
(*		- create WAIT_FOR_STOP_IS_EMPTY for mud_updater_delay	*)
(*	23Jan86	- rsb							*)
(*		- Create WRITE_HEADER_TO_DISC				*)
(*		  crash_utility.halt_slot if disc write fails		*)
(*		- Initialize						*)
(*		  set_merge_date					*)
(*		  set_supervisor					*)
(*		  set_schedule						*)
(*		  set_table_date					*)
(*		  cud_change_in_progress				*)
(*		  set_sup_table_status					*)
(*		  abort_cud_change					*)
(*		  mud_update_complete					*)
(*		  report_consistency_error				*)
(*		  - call write_header to write header to disc		*)
(*		- Set_Supervisor: remove possibility of setting		*)
(*		  success = set_sup_disc_error, since 			*)
(*		  write_header_to_disc will crash if an error occurs.	*)
(*		- read_eof_buffer					*)
(*		  - change "success" into local variable "read_ok"	*)
(*		  - crash_utility.halt_slot if read_ok = FALSE		*)
(*		- change every "success: boolean" into either		*)
(*		  "write_ok" or "read_ok" as appropriate.		*)
(*		- Set_Merge_date: remove "success" as call parameter	*)
(*	13Jan86	- rsb							*)
(*		- Set_Supervisor: add messages in case Supervisor	*)
(*		  status changes between Command Level and Mud Change 	*)
(*		  Handler  - i.e. 2 validators setting same sup off 	*)
(*		  simultaneously.					*)
(*		- rename SUP_DELAY_QUE as MUD_UPDATER_DELAY_QUE in order*)
(*		  to make name more related to function			*)
(*		- Create WAIT_FOR_STOP_QUE in case setting a Supervisor *)
(*		  Off and need to wait for a mud update or 		*)
(*		  automatic consistency block to finish movement to sup	*)
(*		- Mud_Update_Complete and Report_Consistency_Over: 	*)
(*		  add attempt to continue procedure in wait_for_stop_que*)
(*		  if real_sup not in pseudo_sup_table then		*)
(*		  crash_utility.halt_slot				*)
(*	02Jan86 - rsb							*)
(*		- Eliminate SUPERVISOR_SINK_INFORMATION.		*)
(*		- Redefine SUP_SINK as just supervisor_in_core_infor-	*)
(*		  mation						*)
(*		- rewrite find_update_waiter for USN enhancement	*)
(*		- rewrite find_consistency_to_run for USN		*)
(*		- change rewrite check_time for USN			*)
(*		- add init of "aux_io(mutil)" to initialization		*)
(*	23Dec85	- rsb							*)
(*		- Sup_Sink: remove ".waiter" from "supervisor_sink	*)
(*		  information."						*)
(*		-  Sup_Delay_Que: create to replace ".waiter."		*)
(*		-  Circuit_Handler: include an instance and init it.	*)
(*		-  Pseudo_Sup_Table: create and initialize		*)
(*		-  any_mud_updates,  stop_consistency,:			*)
(*		-  change to "real_sup : real_sup_index."		*)
(*		-  re: Mudupd_disc_header:  "sup_info[sup]" becomes	*)
(* 		   "sup_info[real_sup]."				*)
(*		-  stop_consistency:  use "real_supervisor_index."	*)
(*		-  All above for USN.					*)
(*	10Jan85 - jrn							*)
(*	      - perform a time validity check				*)
(*	      - write a message to the operator log when the MUD	*)
(*		change file is caught up				*)
(*	18Dec84 - jrn							*)
(*	      - add all logical volume code				*)
(*	13Dec84 - neb							*)
(*	      - add merge_month_changed and set_merge_date for 		*)
(*		conditional assembly parameter reuse_uuns		*)
(*	16Aug84 - jrn							*)
(*	      - change calls to dsksys for NVDM				*)
(*	20Jun84 - jrn							*)
(*	      - removed get_schedule routine				*)
(*	      - add NVDM code (including removal of archive restore	*)
(*		handling)						*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - do not attempt a MUD update or automatic consistency if	*)
(*		a manual consistency is running				*)
(*	      - set all Supervisors to OFF and the last_cg_creation to	*)
(*		zero on ARCHIVE store and restore			*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type
  SUPERVISOR_IN_CORE_INFORMATION = record
    consistency			: consistency_info;
    nochange			: boolean (* TRUE if no change consistency *);
    run_init_auto_consistency	: boolean (* run consis after set_sup:on *);
    to_be_stopped		: boolean (* abort current auto consistency *);
    last_cg_status		: class_group_status;
    current_un2_activity	: current_comm_activity
  end (* supervisor_in_core_information *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
type MUD_CHANGE_HANDLER =  monitor(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oplog		: operator_log);


const
  ACCEPTABLE_TIME_DIFFERENCE = 10 * 60 (* seconds *);



(*	The following describes the in-core buffer	*)
(*	from the MUD_UPDATE file.			*)

type
  in_core_buffer = record
    data    : page		(* page from file *);
    address : mudupd_address	(* points to eof byte, page *)
  end (* in_core_buffer *);



(* This record helps in computing all sorts of consistency/time		*)
(* relationships, and was added to deal with schedules across midnight.	*)

  current_consistency_information = record
    this_time		: integer;
    start_time		: integer;
    stop_time		: integer;
    during_period	: boolean
  end (* current_consistency_information *);



var
  mutil            : misc_utility;
  crash_util       : crash_utility;
  next             : fifo;
  calendar         : date_time_converter;
  format           : internal_to_string;
  oper_messages    : operator_messages;
  mud_update       : file_utility;
  mud_utility      : mudupd_utility;
  dsksys           : disk_system;
  cud_block_reader : cud_block_utility;
  aux_io           : circuit_handler;


  current_consistency : current_consistency_information;

(* compare the time with last_time to check for	*)
(* valid time received from the node.		*)

  last_time : integer;



(* the last page and its address from the file. *)
(* used to update file, so that it  *)
(* does not have to be read in all  *)
(* the time when updating.          *)

  eof_buffer : in_core_buffer;



(* mud_updater processes are delayed here until either:		*)
(* 1)  a Mud change is pending for the Mud_Updater's Supervisor *)
(* 2)  it is time to start an Automatic Consistency on the Sup	*)

  mud_updater_delay_que : array [pseudo_supervisor_index] of queue;



(* Mud_change.set_supervisor waits here if it is trying 	*)
(* to set a Supervisor OFF and the Supervisor is currently	*)
(* in the process of receiving either: 1) Mud change block	*)
(* or 2) Automatic Consistency mud block.  Setting the Sup	*)
(* OFF will be done after block transmission completes.		*)

  wait_for_stop_que : array [pseudo_supervisor_index] of queue;



(* in core data for all Supervisors *)
(* includes current consistency information, *)
(* a delay queue and Class/group status.     *)

  sup_core_info : array [real_supervisor_index] of
					supervisor_in_core_information;



(* 	The file pointer to the byte following the last good 	*)
(* data to be distributed to MUDs.  This should match the	*)
(* disk pointer (header_info.disk_eof) EXCEPT during the time that	*)
(* CUD_CHANGE_PENDING in TRUE (after cud_change_in_progress	*)
(* is called and before abort_cud_change or confirm_cud_change	*)
(* is called).							*)

  updater_eof : mudupd_data_index;



(* TRUE if file is locked during a CUD update (it is	*)
(* locked to other CUD updates only).  This is set to   *)
(* TRUE in the cud_change_in_progress routine and set	*)
(* to FALSE in either the confirm_cud_change or the	*)
(* abort_cud_change routine.		                *)

  cud_change_pending : boolean;



(*	This is where validators are delayed while	*)
(* cud_change_pending is TRUE. Validators are delayed	*)
(* in a queue in the cud_change_in_progress routine	*)
(* and continued in either the abort_cud_change or	*)
(* confirm_cud_change routine.  Validators are delayed	*)
(* in their validator_index entry.			*)

  waiting_for_mud_change : array [validator_index] of queue;



(*	This is the ordered list of validators waiting	*)
(* to add CUD changes to the MUD_UPDATE file. It is	*)
(* controlled by the FIFO Class, which is set up for	*)
(* MAXIMUM_VALIDATOR entries. Validators are added to	*)
(* the list indexed by fifo.arrival and are removed	*)
(* from the list at fifo.departure.			*)

  mud_change_waiting_list : array [validator_index] of validator_index;



(*	This is the value that is checked (when a new record	*)
(* is written to the file) to see if the operator_log should	*)
(* be notified that the file is getting "full".  It is		*)
(* initialized to halfway between the current size and the	*)
(* end-of-file and is updated when the operator_log message is	*)
(* sent or when the disk_eof is reset to zero.			*)

  getting_full_mark : mudupd_data_index;



(* the disk header...to be read at initialization, and written when *)
(* appropriate; should always match the values on the disk.         *)

  header : mudupd_disk_header;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* table to maintain correlation between a Supervisor's number	*)
(* (real_supervisor_index) and MUD_UPDATER			*)
(* process number (pseudo_sup_index).				*)

  pseudo_sup_table : array [pseudo_supervisor_index] of ps_table_search_range;



(************************  Mud_Change_Handler  **************************)
(*									*)
(*			    search_ps_table				*)
(*									*)
(************************************************************************)

procedure search_ps_table(
      search_value           : ps_table_search_range;
  var pseudo_sup_table_entry : pseudo_supervisor_index;
  var found                  : boolean);

var
  done : boolean;

begin (* search_ps_table *)
  pseudo_sup_table_entry := FIRST_SUPERVISOR;
  done := FALSE;
  found := FALSE;
  repeat
   If Pseudo_sup_Table[pseudo_sup_table_entry] = search_value
   then found := TRUE
   else
     if pseudo_sup_table_entry = MAXIMUM_EXPECTED_SUPERVISORS
     then done := TRUE
     else pseudo_sup_table_entry := pseudo_sup_table_entry + 1;
  until found or done;
end (* search_ps_table *);



(**************************  Mud_Change_Handler  ************************)
(*									*)
(*				xlate_ps_to_rs				*)
(*									*)
(* 	Given pseudo_sup_number return real_sup_number.			*)
(*									*)
(************************************************************************)

procedure xlate_ps_to_rs(
      pseudo_sup : pseudo_supervisor_index;
  var real_sup   : real_supervisor_index;
  var found	 : boolean);

begin (* xlate_ps_to_rs *)
  found := FALSE;
  real_sup := pseudo_sup_table[pseudo_sup];
  if real_sup <> EMPTY_ENTRY
  then found := TRUE
end (* xlate_ps_to_rs *);



(*************************  Mud_Change_Handler  *************************)
(*									*)
(*                       translate_rs_to_ps				*)
(*									*)
(*   Find a Supervisor's entry in the pseudo_sup_table for an external  *)
(*   procedure.								*)
(*									*)
(************************************************************************)

procedure entry TRANSLATE_RS_TO_PS(
      real_sup		: real_supervisor_index;
  var pseudo_sup	: pseudo_supervisor_index);

var
  found : boolean;

begin (* translate_rs_to_ps *)
  search_ps_table(real_sup, pseudo_sup, found);
  if not found
  then crash_util.halt_slot
end (* translate_rs_to_ps *);



(******************  Mud_Change_Handler  ********************************)
(*									*)
(*			write_header_to_disc				*)
(*									*)
(*	write disc header for Supervisor.  Crash on a disc error	*)
(*									*)
(************************************************************************)

procedure write_header_to_disc;

var
  write_ok : boolean;

begin (* write_header_to_disc *)
  mud_utility.write_page(MUDUPD_HEADER_ADDRESS, header, write_ok);
  if not write_ok
  then crash_util.halt_slot
end (* write_header_to_disc *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		Routines common to NVAL and NVDM
"



(************************  mud_change_handler  **************************)
(*									*)
(*			   init_sup_disc_info				*)
(*									*)
(*	initialize mud_update_file header, which is disc-resident	*)
(*									*)
(************************************************************************)

procedure init_sup_disc_info(
      real_sup	    : real_supervisor_index;
  var sup_disc_info : supervisor_disk_information);

begin (* init_sup_disc_info *)
  with sup_disc_info do
    begin
      state := real_sup;
      pointer := 0;
      last_mud_update := 0;
      last_cg_update := 0;
      with history.consistency do
	begin
	  start_date := 0;
	  block := 0;
	  manual := FALSE;
	  stopped := FALSE
	end;
      history.stop_date := 0
    end
end (* init_sup_disc_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			   set_sup_off					*)
(*									*)
(************************************************************************)

procedure set_sup_off(
      real_sup  	: real_supervisor_index;
  var header_info  	: mudupd_disk_header);

begin
  header_info.sup_disc_info[real_sup].state := SUPERVISOR_OFF;
  header_info.sup_disc_info[real_sup].pointer := 0;
end (* set_sup_off *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  mud_change_handler  *************************)
(*									*)
(*			   continue_wait_for_stop_que			*)
(*									*)
(*	Entry point so mud_updater can continue a delayed set_sup:off	*)
(*	command.							*)
(*									*)
(************************************************************************)

procedure entry CONTINUE_WAIT_FOR_STOP_QUE(
      pseudo_sup  	: pseudo_supervisor_index);

begin (* continue_wait_for_stop_que *)
  continue(wait_for_stop_que[pseudo_sup])
end (* continue_wait_for_stop_que *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  mud_change_handler  *************************)
(*									*)
(*			    clear_mudupd_header				*)
(*									*)
(*      Clear the end-of-file pointer and set all Supervisors to OFF	*)
(*	for an ARCHIVE operation.					*)
(*	This forces the validator to turn Supervisors ON after a	*)
(*	RESTORE.							*)
(*									*)
(************************************************************************)

procedure clear_mudupd_header(
  var header : univ mudupd_disk_header);

var
  real_sup : real_supervisor_index;

begin
  header.disk_eof := 0;
  header.last_record := 0;
  header.last_cg_creation := 0;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    set_sup_off(real_sup, header)
end (* clear_mudupd_header *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		Initialization Routines
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			    reset_getting_full				*)
(*									*)
(*      Set getting_full_mark to halfway between the logical		*)
(*	end-of-file (header.disk_eof) and the physical end-of-file	*)
(*	(MUDUPD_DATA_MAX).						*)
(*									*)
(************************************************************************)

procedure reset_getting_full;

begin
  getting_full_mark := header.disk_eof +
    ((MUDUPD_DATA_MAX - header.disk_eof) div 2)
end (* reset_getting_full *);



(*************************  mud_change_handler  *************************)
(*									*)
(*		    clear_current_consistency_sup_core_info		*)
(*									*)
(*      Clear current consistency Supervisor info in sup_core_info.	*)
(*									*)
(************************************************************************)

procedure clear_current_consistency_sup_core_info(
      real_sup	: real_supervisor_index);

begin
  sup_core_info[real_sup].consistency.start_date := 0;
  sup_core_info[real_sup].consistency.block := 0;
  sup_core_info[real_sup].consistency.manual := FALSE;
  sup_core_info[real_sup].consistency.stopped := FALSE
end (* clear_current_consistency_sup_core_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  init_sup_core_info				*)
(*									*)
(*      Clear current Supervisor info in sup_core_info.			*)
(*									*)
(************************************************************************)

procedure init_sup_core_info(
      real_sup	: real_supervisor_index);

begin
  clear_current_consistency_sup_core_info(real_sup);
  sup_core_info[real_sup].run_init_auto_consistency := FALSE;
  sup_core_info[real_sup].to_be_stopped := FALSE;
  sup_core_info[real_sup].last_cg_status := CLASS_GROUP_NOT_TRIED;
  sup_core_info[real_sup].current_un2_activity := NOT_BUSY
end (* init_sup_core_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      read_eof_buffer				*)
(*									*)
(*      Read in the page pointed to by eof_pointer from the		*)
(*	MUD_UPDATE file and set up eof_buffer.				*)
(*									*)
(************************************************************************)

procedure read_eof_buffer;

var
  read_ok : boolean;

begin
  mud_utility.compute_mudupd_address(header.disk_eof, eof_buffer.address);
  mud_utility.read_page(eof_buffer.address.page_offset, eof_buffer.data,
    read_ok);
  if not read_ok
  then crash_util.halt_slot
end (* read_eof_buffer *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			       legal_sup				*)
(*									*)
(*      Return TRUE if Supervisor is in-use.				*)
(*									*)
(************************************************************************)

function legal_sup(
      real_sup	: real_supervisor_index) : boolean;

begin
  legal_sup := header.sup_disc_info[real_sup].state = real_sup
end (* legal_sup *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  mud_change_handler  *************************)
(*									*)
(*				initialize				*)
(*									*)
(*      Check the data in the last change in the MUD_UPDATE file	*)
(*	against the CUD data (and remove it if it is not valid) and	*)
(*	initialize permanent variables.					*)
(*									*)
(************************************************************************)

procedure initialize;

var
  real_sup : real_supervisor_index;
  cud_pointer : cud_data_index;
  mudchg_pointer : cud_data_index;
  change : cud_change_information;
  file_address : mudupd_address;
  cud_buffer : cud_disk_block;
  result : cud_operation_result;
  legal_sup_count : ps_table_search_range;
  pseudo_sup : pseudo_supervisor_index;
  match : boolean;
  read_ok : boolean;

begin
  last_time := REALTIME;
  mud_utility.read_page(MUDUPD_HEADER_ADDRESS, header, read_ok);
  if not read_ok or (header.file_id <> MUDUPD_ID)
  then crash_util.halt_slot;
  if header.disk_eof > header.last_record
  then
    begin (* correct Mud_Update_file *)
(*      If data in the record pointed to by the last record pointer	*)
(*	does not match the actual CUD data, remove the record from	*)
(*	the MUD_UPDATE file.						*)

      mud_utility.compute_mudupd_address(header.last_record, file_address);
      mud_utility.extract_cud_change(file_address, read_ok, change);
      if not read_ok
      then crash_util.halt_slot;
      cud_block_reader.read_cud_block(change.header.block, result, cud_buffer);
      if result <> CUD_OPERATION_OK
      then crash_util.halt_slot;
      match := TRUE (* check to see if change is in CUD *);
      cud_pointer := change.header.offset * MAXIMUM_BYTES_IN_WORD;
      with change do
        for mudchg_pointer := 0 to (header.size * MAXIMUM_BYTES_IN_WORD)-1 do
          begin
            if cud_buffer.data[cud_pointer] <> data[mudchg_pointer]
            then match := FALSE;
            cud_pointer := cud_pointer + 1
          end;
      if not match
      then
        begin (* remove last mud change file record *)
          header.disk_eof := header.last_record;
          write_header_to_disc
        end (* remove last mud change file record *)
    end (* correct mud_update_file *);

  read_eof_buffer;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    init_sup_core_info(real_sup);
  cud_change_pending := FALSE;
  reset_getting_full;
  updater_eof := header.disk_eof;

(* initialize Pseudo_Sup_Table *)
  for pseudo_sup := FIRST_SUPERVISOR to MAXIMUM_EXPECTED_SUPERVISORS do
    pseudo_sup_table[pseudo_sup] := EMPTY_ENTRY;
  legal_sup_count := 0;
  pseudo_sup := FIRST_SUPERVISOR;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    If legal_sup(real_sup)
    then
      begin (* MUF Header thinks Sup is legal *)
 	legal_sup_count := legal_sup_count + 1;
        if legal_sup_count > MAXIMUM_EXPECTED_SUPERVISORS
        then crash_util.halt_slot;
 	Pseudo_Sup_Table[pseudo_sup] := real_sup;
 	pseudo_sup := pseudo_sup + 1
      end (* MUF Header thinks Sup is legal *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* initialize *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		legal Supervisor routines

    The following calls to MUD_CHANGE_HANDLER allow access
to the list of legal Supervisors stored in the MUD_UPDATE file
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			     legal_supervisor				*)
(*									*)
(*      Return TRUE if Supervisor is in-use.				*)
(*									*)
(************************************************************************)

function entry LEGAL_SUPERVISOR(
      real_sup	: real_supervisor_index) : boolean;

begin
  legal_supervisor := legal_sup(real_sup)
end (* legal_supervisor *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 check_all_sups_caught_up			*)
(*									*)
(*      If all legal Supervisor pointers match disk_eof reset all	*)
(*	MUD_UPDATE data pointers.					*)
(*									*)
(************************************************************************)

procedure check_all_sups_caught_up;

var
  real_sup : real_supervisor_index;
  all_sups_caught_up : boolean;

begin
  if header.disk_eof <> 0
  then
    begin (* there is data in the file *)
      all_sups_caught_up := TRUE;
      for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
        if legal_sup(real_sup) 
	   and (header.sup_disc_info[real_sup].pointer <> header.disk_eof)
	then all_sups_caught_up := FALSE;
      if all_sups_caught_up
      then
        begin (* clear all waiting changes *)
	  updater_eof := 0;
	  eof_buffer.address.page_offset := PAGES_IN_MUDUPD_HEADER;
	  eof_buffer.address.byte_offset := 0;
	  header.disk_eof := 0;
	  header.last_record := 0;
	  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
	    header.sup_disc_info[real_sup].pointer := 0;
	  reset_getting_full;
	  format.start_message('MUD updates caught up\');
	  oper_messages.report_message(MUDUPD_OPLOG_MSG)
	end (* clear all waiting changes *)
    end (* there is data in the file *)
end (* check_all_sups_caught_up *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  wait_for_stop_is_empty			*)
(*									*)
(************************************************************************)

function entry WAIT_FOR_STOP_IS_EMPTY(
      pseudo_sup	: pseudo_supervisor_index) : boolean;

begin (* wait_for_stop_is_empty *)
  wait_for_stop_is_empty := empty(wait_for_stop_que[pseudo_sup])
end (* wait_for_stop_is_empty *);



(*************************  mud_change_handler  *************************)
(*									*)
(*                         start_sup_shutdown				*)
(*									*)
(************************************************************************)

procedure start_sup_shutdown(
      real_sup       : real_supervisor_index;
      pseudo_sup     : pseudo_supervisor_index);

begin (* start_sup_shutdown *)
  set_sup_off(real_sup, header);
  sup_core_info[real_sup].run_init_auto_consistency := FALSE;
(* clear file eof's if all sups are now caught up *)
  check_all_sups_caught_up;
  aux_io.use_circuit(pseudo_sup, AUX_CIRCUIT, [COMPLETE]);
  aux_io.clear_circuit;
  sup_core_info[real_sup].current_un2_activity := NOT_BUSY
end (* start_sup_shutdown *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      set_supervisor				*)
(*									*)
(*      Turn the Supervisor REAL_SUP on or off.				*)
(*									*)
(************************************************************************)

procedure entry SET_SUPERVISOR(
      real_sup          : real_supervisor_index;
      make_legal	: boolean;
  var success      	: set_supervisor_status);

var
  pseudo_sup	  : pseudo_supervisor_index;
  found,
  write_ok,
  currently_legal : boolean;

begin (* mud_change.set_supervisor *)
  success := SET_SUP_SUCCESSFULL;
  write_ok := FALSE;
  currently_legal := header.sup_disc_info[real_sup].state <> SUPERVISOR_OFF;

  if not make_legal and not currently_legal
  then success := SET_SUP_ALREADY_OFF;

  if make_legal and currently_legal
  then success := SET_SUP_ALREADY_ON;

  if make_legal and not currently_legal
  then
    begin (* attempt to turn supervisor on *)
      search_ps_table(real_sup, pseudo_sup, found);
      if found
      then success := SET_SUP_ALREADY_IN_PSEUDO_SUP_TABLE
      else
	begin (* can turn sup on *)
          search_ps_table(EMPTY_ENTRY, pseudo_sup, found);
          if found
          then
            begin (* initialize Netval for supervisor wake-up *)
	      pseudo_sup_table[pseudo_sup] := real_sup;
              init_sup_disc_info(real_sup, header.sup_disc_info[real_sup]);
              init_sup_core_info(real_sup);
              if RUN_AUTO_CONSISTENCY_ON_SUP_INIT and
	                                   mutil.legal_consistency(real_sup)
              then
                begin (* set run_init_auto_consistency flag *)
	          sup_core_info[real_sup].run_init_auto_consistency := TRUE;
                  header.sup_disc_info[real_sup].pointer := updater_eof
                end (* set run_init_auto_consistency flag *)
            end (* initialize Netval for supervisor wake-up *)
          else success := SET_SUP_NO_ROOM_IN_PSEUDO_SUP_TABLE
	end (* can turn sup on *)
    end (* attempt to turn supervisor on *);

  if not make_legal and currently_legal
  then
    begin (* attempt to make Supervisor not legal *)
      search_ps_table(real_sup, pseudo_sup, found);
      if found
      then
        begin (* turn off Supervisor is in pseudo_sup_table *)
          If not empty(wait_for_stop_que[pseudo_sup])
          then success := SET_SUP_OFF_ALREADY_IN_PROGRESS
          else
            begin (* no other turn offs got here first; what's happening? *)
	      case sup_core_info[real_sup].current_un2_activity of
	        NOT_BUSY:	
		  start_sup_shutdown(real_sup, pseudo_sup);
		AUTO_CONSISTENCY:
                  begin (* shut down after auto consistency is stopped *)
                    sup_core_info[real_sup].to_be_stopped := TRUE;
                    delay(wait_for_stop_que[pseudo_sup]);
                    start_sup_shutdown(real_sup, pseudo_sup);
		    success := SET_SUP_AUTO_CONSISTENCY_HALTED
                  end  (* shut down after auto consistency is stopped *);
		MANUAL_CONSISTENCY:
                  success := SET_SUP_MANUAL_CONSISTENCY_IN_PROGRESS;
		MUD_UPDATING:
                  begin (* shut down after current update block is sent *)
                    delay(wait_for_stop_que[pseudo_sup]);
                    start_sup_shutdown(real_sup, pseudo_sup)
                  end (* shut down after current update block is sent *)
	      end (* case of current_un2_activity *)
            end (* no other turn offs got here first; what's happening? *)
        end (* turn off Supervisor is in pseudo_sup_table *)
      else crash_util.halt_slot
    end (* attempt to make Supervisor not legal *);

  if (success = SET_SUP_SUCCESSFULL)
     or (success = SET_SUP_AUTO_CONSISTENCY_HALTED)
  then
    begin (* disc writing and pseudo_sup_table updating *)
      write_header_to_disc;
      if make_legal
      then pseudo_sup_table[pseudo_sup] := real_sup
      else pseudo_sup_table[pseudo_sup] := EMPTY_ENTRY
    end (* disc writing and pseudo_sup_table updating *)
end (* set_supervisor *);
!
"
	Consistency Schedule Routines

    The following calls to MUD_CHANGE_HANDLER allow access to the
consistency schedule
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			      set_schedule				*)
(*									*)
(*      Update the consistency schedule to new_start_time and		*)
(*	new_stop_time.							*)
(*									*)
(************************************************************************)

procedure entry SET_SCHEDULE(
      new_start_time	: integer;
      new_stop_time	: integer);

begin
  header.consistency_start := new_start_time;
  header.consistency_stop := new_stop_time;
  write_header_to_disc
end (* set_schedule *);
!
"
		Class group Routines

    The following routines are called by the CLASS_GROUP_UPDATER Process
and the CLASS_GROUP_HANDLER Monitor.
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			     set_table_date				*)
(*									*)
(*      Set the NETVAL Class/group Table updated date to the		*)
(*	present and all Supervisor last_class_group_status to		*)
(*	CLASS_GROUP_NOT_TRIED.						*)
(*									*)
(************************************************************************)

procedure entry SET_TABLE_DATE;

var
  real_sup : real_supervisor_index;

begin (* set_table_date *)
  header.last_cg_creation := REALTIME;
  write_header_to_disc;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    sup_core_info[real_sup].last_cg_status := CLASS_GROUP_NOT_TRIED
end (* set_table_date *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  set_sup_table_status				*)
(*									*)
(*      Update the Supervisor Class/group update status and/or date.	*)
(*									*)
(************************************************************************)

procedure entry SET_SUP_TABLE_STATUS(
      real_sup          : real_supervisor_index;
      new_status	: class_group_status);

begin
  sup_core_info[real_sup].last_cg_status := new_status;
  if new_status = CLASS_GROUP_UPDATED
  then
    begin (* write new time *)
      header.sup_disc_info[real_sup].last_cg_update := REALTIME;
      write_header_to_disc
    end (* write new time *)
end (* set_sup_table_status *);



(*************************  mud_change_handler  *************************)
(*									*)
(*				table_date				*)
(*									*)
(*      Return the NETVAL Class/group Table updated date.		*)
(*									*)
(************************************************************************)

function entry TABLE_DATE : integer;

begin
  table_date := header.last_cg_creation
end (* table_date *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     sup_table_status				*)
(*									*)
(*      Return the Class/group Table status for the supervisor.		*)
(*									*)
(************************************************************************)

function entry SUP_TABLE_STATUS(
      real_sup	: real_supervisor_index) : class_group_status;

begin (* sup_table_status *)
  sup_table_status := sup_core_info[real_sup].last_cg_status
end (* sup_table_status *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     table_to_send				*)
(*									*)
(*      Return TRUE if the sup should be sent the Class/group Table.	*)
(*									*)
(************************************************************************)

function entry TABLE_TO_SEND(
      real_sup	: real_supervisor_index) : boolean;

begin
  table_to_send := legal_sup(real_sup) and
    (header.last_cg_creation > header.sup_disc_info[real_sup].last_cg_update)
end (* table_to_send *);
!
"
		CUD_ENTRY_UPDATER Routines
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			      save_two_bytes				*)
(*									*)
(*      Save the rightmost two bytes in value in eof_buffer, adjusting	*)
(*	the eof_buffer.address.						*)
(*									*)
(************************************************************************)

procedure save_two_bytes(
      value    : univ word_in_bytes;
  var write_ok : boolean);

begin
  mud_utility.put_mudupd_byte(value[2], eof_buffer.address, eof_buffer.data,
    write_ok);
  if write_ok
  then mud_utility.put_mudupd_byte(value[3], eof_buffer.address,
    eof_buffer.data, write_ok)
end (* save_two_bytes *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  cud_change_in_progress			*)
(*									*)
(*      Append the change to the MUD_UPDATE file and leave it		*)
(*	locked against other updates until the change is		*)
(*	confirmed or aborted.						*)
(*									*)
(************************************************************************)

procedure entry CUD_CHANGE_IN_PROGRESS(
      caller   : validator_index;
      change   : cud_change_information;
  var write_ok : boolean);

var
  count : cud_data_size;
  cud_pointer : cud_data_index;
  filler : integer;

begin
  if cud_change_pending
  then
    begin
      mud_change_waiting_list[next.arrival] := caller;
      delay(waiting_for_mud_change[caller])
    end (* cud_change_pending *);

(*	Write the CUD change to the MUD_UPDATE file.			*)
(* first save header information (block, offset, size and filler)	*)
  save_two_bytes(change.header.block, write_ok);
  if write_ok
  then save_two_bytes(change.header.offset, write_ok);
  if write_ok
  then save_two_bytes(change.header.size, write_ok);
  filler := 0;
  if write_ok
  then save_two_bytes(filler, write_ok);

  if write_ok
  then
    begin (* save data to mud change file *)
      count := change.header.size * MAXIMUM_BYTES_IN_WORD;
      cud_pointer := 0;
      repeat
        mud_utility.put_mudupd_byte(change.data[cud_pointer],
  	  eof_buffer.address, eof_buffer.data, write_ok);
	count := count - 1;
	if count > 0
	then cud_pointer := cud_pointer + 1
      until not write_ok or (count = 0);
      if eof_buffer.address.byte_offset <> 0
      then mud_utility.write_page(eof_buffer.address.page_offset,
        eof_buffer.data, write_ok)
    end (* save data to mud change file *);

  if write_ok
  then
    begin
      header.disk_eof := mud_utility.disk_byte_address(eof_buffer.address);
      header.last_record := updater_eof;
      write_header_to_disc
    end;

  if write_ok
  then cud_change_pending := TRUE
end (* cud_change_in_progress *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			    confirm_cud_change				*)
(*									*)
(*      The CUD change was successful, allow MUD_UPDATER readers to	*)
(*	recognize it, unlock updates and continue any validators	*)
(*	waiting and check for MUD_UPDATE file getting full.		*)
(*									*)
(************************************************************************)

procedure entry CONFIRM_CUD_CHANGE;

begin
  updater_eof := header.disk_eof;
  cud_change_pending := FALSE;
  if header.disk_eof >= getting_full_mark (* see if file is getting full *)
  then
    begin
      format.start_message('MUD_UPDATE file is \');
      format.number((header.disk_eof * 100) div MUDUPD_DATA_MAX, 10);
      format.string(' percent full\');
      oper_messages.report_message(MUDUPD_OPLOG_MSG);
      reset_getting_full
    end;
  if not next.empty
  then
    continue(waiting_for_mud_change[mud_change_waiting_list[next.departure]])
end (* confirm_cud_change *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     abort_cud_change				*)
(*									*)
(*      The CUD change was NOT successful, discount the change,		*)
(*	unlock updates and continue a waiting validator.		*)
(*									*)
(************************************************************************)

procedure entry ABORT_CUD_CHANGE;

begin
  header.disk_eof := updater_eof;
  write_header_to_disc;
  read_eof_buffer;
  cud_change_pending := FALSE;
  if not next.empty
  then
    continue(waiting_for_mud_change[mud_change_waiting_list[next.departure]])
end (* abort_cud_change *);

!
"
	MUD_UPDATER Process Routines
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			      update_waiting				*)
(*									*)
(*      Return TRUE if sup is a legal supervisor			*)
(*		       and it is not running an initial auto consistency*)
(*	               and there is a pending CUD change for the Sup	*)
(*									*)
(************************************************************************)

function update_waiting(
      real_sup	: real_supervisor_index) : boolean;

begin (* update waiting *)
  update_waiting := legal_sup(real_sup) 
    	    	    and not sup_core_info[real_sup].run_init_auto_consistency 
    		    and (header.sup_disc_info[real_sup].pointer < updater_eof)
end (* update_waiting *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 in_current_consistency_period			*)
(*									*)
(*      Return TRUE if TIME_TO_CHECK is during the CURRENT		*)
(*	consistency period.  Called by WAITING_FOR_CONSISTENCY routine	*)
(*	only if the current time is during a consistency period.	*)
(*	This is required since just checking DURING_CONSISTENCY_PERIOD	*)
(*	does not reflect the possibility of 2 periods during one day	*)
(*	if the schedule runs across midnight.  There is an assumption	*)
(*	made that time_to_check will always be less than REALTIME.	*)
(*	      - to see if a consistency has been stopped during this	*)
(*		period							*)
(*	      - to see if a consistency has run during this period	*)
(*									*)
(************************************************************************)

function in_current_consistency_period(
      time_to_check		: integer) : boolean;

begin
  in_current_consistency_period :=
    (time_to_check >= current_consistency.start_time) and
    (time_to_check <= current_consistency.stop_time)
end (* in_current_consistency_period *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      get_mud_change				*)
(*									*)
(*      Retrieve information about the next change to be made		*)
(*	to the Supervisor.						*)
(*									*)
(************************************************************************)

procedure entry GET_MUD_CHANGE(
      pseudo_sup	: pseudo_supervisor_index;
  var run_consistency	: boolean;
  var block		: cud_block_index;
  var change_pointer	: mudupd_address;
  var real_sup		: real_supervisor_index);

var
  need_to_delay : boolean;
  found : boolean;

begin (* get_mud_change *)
  run_consistency:= FALSE;
  need_to_delay := FALSE;
  block := 0;
  xlate_ps_to_rs(pseudo_sup, real_sup, found);
  if found
  then
    if update_waiting(real_sup)
       and ((sup_core_info[real_sup].current_un2_activity = NOT_BUSY)
	    or (sup_core_info[real_sup].current_un2_activity = MUD_UPDATING))
    then mud_utility.compute_mudupd_address(
      			header.sup_disc_info[real_sup].pointer, change_pointer)
    else need_to_delay := TRUE
  else need_to_delay := TRUE;

  If need_to_delay
  then delay(mud_updater_delay_que[pseudo_sup]);

  xlate_ps_to_rs(pseudo_sup, real_sup, found);
  if found
  then
    begin (* delay ended for mud update or start auto consistency? *)
      if update_waiting(real_sup)
      then 
	begin (* send a mud update block to the Sup *)
	  sup_core_info[real_sup].current_un2_activity := MUD_UPDATING;
	  mud_utility.compute_mudupd_address(
                              header.sup_disc_info[real_sup].pointer, 
			      change_pointer)
	end (* send a mud update block to the Sup *)
      else
        begin (* start a consistency *)
	  run_consistency := TRUE;
          with header.sup_disc_info[real_sup].history do
            if consistency_restartable 
	       and (in_current_consistency_period(stop_date)
	            or sup_core_info[real_sup].run_init_auto_consistency)
            then block := consistency.block
        end (* start a consistency *)
    end (* delay ended for mud update or start auto consistency? *)
  else crash_util.halt_slot
end (* get_mud_change *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			    mud_update_complete				*)
(*									*)
(*      Update the MUD pointer for the Supervisor to new_pointer,	*)
(*	and if all Supervisors are up-to-date, reset disk_eof.		*)
(*									*)
(************************************************************************)

procedure entry MUD_UPDATE_COMPLETE(
      real_sup		: real_supervisor_index;
      new_pointer	: mudupd_address);

var
  pseudo_sup : pseudo_supervisor_index;
  found : boolean;

begin (* mud_update_complete *)
  header.sup_disc_info[real_sup].pointer :=
    mud_utility.disk_byte_address(new_pointer);
  header.sup_disc_info[real_sup].last_mud_update := REALTIME;
  check_all_sups_caught_up;
  write_header_to_disc
end (* mud_update_complete *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			    any_mud_updates				*)
(*									*)
(*      Return TRUE if there are any outstanding MUD updates for	*)
(*	this supervisor.						*)
(*									*)
(************************************************************************)

function entry ANY_MUD_UPDATES(
      real_sup	: real_supervisor_index) : boolean;

begin
  any_mud_updates := header.sup_disc_info[real_sup].pointer < updater_eof
end (* any_mud_updaters *);
!
"
		Consistency Routines
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			 record_consistency_started			*)
(*									*)
(*      Record start of transmission of consistency blocks.		*)
(*	This record is kept in core until the consistency completes,	*)
(*	at which time it is written to disc.				*)
(*	This is only called after a UN2 Circuit has been established.	*)
(*									*)
(************************************************************************)

procedure entry RECORD_CONSISTENCY_STARTED(
      real_sup		: real_supervisor_index;
      block		: cud_block_index;
      run_manual	: boolean;
      nochange      	: boolean);

begin (* record_consistency_started *);
  sup_core_info[real_sup].consistency.start_date := REALTIME;
  sup_core_info[real_sup].consistency.block := block;
  sup_core_info[real_sup].consistency.stopped := FALSE;
  sup_core_info[real_sup].consistency.manual := run_manual;
  sup_core_info[real_sup].nochange := nochange;
  if run_manual
  then sup_core_info[real_sup].current_un2_activity := MANUAL_CONSISTENCY
  else sup_core_info[real_sup].current_un2_activity := AUTO_CONSISTENCY
end (* record_consistency_started *);




(*************************  mud_change_handler  *************************)
(*									*)
(*			 set_un2_activity_not_busy			*)
(*									*)
(*									*)
(************************************************************************)

procedure entry SET_UN2_ACTIVITY_NOT_BUSY(
      real_sup	: real_supervisor_index);

begin (* set_un2_activity_not_busy *)
  sup_core_info[real_sup].current_un2_activity := NOT_BUSY
end (* set_un2_activity_not_busy *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 report_consistency_block			*)
(*									*)
(*      Report that next_block has been processed.			*)
(*									*)
(************************************************************************)

procedure entry REPORT_CONSISTENCY_BLOCK(
      real_sup		: real_supervisor_index;
      next_block	: cud_block_index);

begin
  sup_core_info[real_sup].consistency.block := next_block
end (* report_consistency_block *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  check_consistency_stop			*)
(*									*)
(*      Return TRUE if consistency should be stopped (from the STOP	*)
(*	command OR time running out during the consistency period).	*)
(*									*)
(************************************************************************)

function entry CHECK_CONSISTENCY_STOP(
      real_sup	: real_supervisor_index) : boolean;

begin
  check_consistency_stop := sup_core_info[real_sup].to_be_stopped
end (* check_consistency_stop *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  report_consistency_over			*)
(*									*)
(*      Report that the consistency run is over; stopped is TRUE if the	*)
(*	consistency was stopped by force; if nochange is TRUE, do not	*)
(*	update any header information.	 				*)
(*									*)
(************************************************************************)

procedure entry REPORT_CONSISTENCY_OVER(
      real_sup	: real_supervisor_index;
      stopped	: boolean);

var
  pseudo_sup : pseudo_supervisor_index;
  found      : boolean;

begin (* report_consistency_over *)
  sup_core_info[real_sup].consistency.stopped := STOPPED;
  sup_core_info[real_sup].to_be_stopped := FALSE;
  sup_core_info[real_sup].current_un2_activity := NOT_BUSY;
  if not sup_core_info[real_sup].nochange
  then
    with header.sup_disc_info[real_sup].history do
      begin (* update disc header for sup *)
        consistency := sup_core_info[real_sup].consistency;
	stop_date := REALTIME;
	write_header_to_disc
      end (* update disc header for sup *);
  
  with sup_core_info[real_sup] do
    if run_init_auto_consistency
    then
      if not consistency.stopped 
	 and (consistency.block = CUD_BLOCK_LIMIT)
      then run_init_auto_consistency := FALSE;
  clear_current_consistency_sup_core_info(real_sup);
  search_ps_table(real_sup, pseudo_sup, found);
  if found
  then continue(wait_for_stop_que[pseudo_sup])
  else crash_util.halt_slot
end (* report_consistency_over *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		TICK Process Routines

    The following contains the routines called by the TICK Process (and
the internal routines used by it) which performs all the
continuing of updaters in queues.
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			  find_mud_update_waiter			*)
(*									*)
(*      Find a supervisor delayed in a waiter queue that has		*)
(*	outstanding mud updates to perform and does not have a manual	*)
(*	consistency running (since only delayed supervisor updaters	*)
(*	are checked, an automatic consistency could not be running).	*)
(*									*)
(************************************************************************)

procedure find_mud_update_waiter(
  var pseudo_sup	: pseudo_supervisor_index;
  var found		: boolean);

var
  done : boolean;
  real_sup : real_supervisor_index;

begin (* find_mud_update_waiter *)
  pseudo_sup := FIRST_SUPERVISOR; 
  found := FALSE; 
  done := FALSE;
  
  repeat
    real_sup := Pseudo_Sup_Table[pseudo_sup];
    if real_sup <> EMPTY_ENTRY
    then (* mud update waiting for a delayed Sup not doing consistency? *)
      if not empty(mud_updater_delay_que[pseudo_sup])
         and update_waiting(real_sup)
	 and (sup_core_info[real_sup].current_un2_activity <> 
							MANUAL_CONSISTENCY)
      then
        begin (* found one with an update *)
	  found := TRUE;
	  done := TRUE
	end (* found one with an update *);
    if not done
    then
      if pseudo_sup = MAXIMUM_EXPECTED_SUPERVISORS
      then done := TRUE
      else pseudo_sup := pseudo_sup + 1
  until done
end (* find_mud_update_waiter *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 waiting_for_consistency			*)
(*									*)
(*      Return TRUE if Supervisor updater could run a consistency,	*)
(*	i.e., consistency has not completed today and consistency has	*)
(*	not been stopped today.						*)
(*									*)
(************************************************************************)

function waiting_for_consistency(
      real_sup	: real_supervisor_index) : boolean;

begin
    with header.sup_disc_info[real_sup].history do
    waiting_for_consistency :=
(* consistency has not been completed during this period: *)
      ((consistency.block <> CUD_BLOCK_LIMIT) 
       or not in_current_consistency_period(stop_date))
      and
(* consistency has not been stopped during this period: *)
       (not in_current_consistency_period(consistency.start_date)
        or not consistency.stopped)
end (* waiting_for_consistency *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 find_consistency_to_run			*)
(*									*)
(*      Find a Supervisor delayed in a waiter queue to run a		*)
(*	consistency, i.e., a mud_updater that is delayed and has not	*)
(*	completed a consistency during today's consistency period OR	*)
(*	a mud_updater that is delayed and run_init_auto_consistency 	*)
(*	is TRUE.							*)
(*									*)
(************************************************************************)

procedure find_consistency_to_run(
  var pseudo_sup		: pseudo_supervisor_index;
  var found			: boolean);

var
  done : boolean;
  real_sup : real_supervisor_index;

begin (* find_consistency_to_run *)
  pseudo_sup := FIRST_SUPERVISOR; 
  found := FALSE; 
  done := FALSE;
  repeat
    real_sup := Pseudo_Sup_Table[pseudo_sup];
    if real_sup <> EMPTY_ENTRY
    then (* is it consistency time for the Supervisor? *)
      if legal_sup(real_sup) 
	 and mutil.legal_consistency(real_sup)
         and not empty(mud_updater_delay_que[pseudo_sup])
      then
        if (sup_core_info[real_sup].run_init_auto_consistency 
	   or (current_consistency.during_period
	       and waiting_for_consistency(real_sup))) 
	   and (sup_core_info[real_sup].current_un2_activity <> 
							MANUAL_CONSISTENCY)
	then
	  begin (* found one to start consistency on *)
	    found := TRUE;
	    done := TRUE
	  end (* found one to start consistency on *);
	
     if not done
     then
       if pseudo_sup = MAXIMUM_EXPECTED_SUPERVISORS
       then done := TRUE
       else pseudo_sup := pseudo_sup + 1
  until done
end (* find_consistency_to_run *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  set_up_for_consistency			*)
(*									*)
(*	compute current_consistency.during_period			*)
(*									*)
(************************************************************************)

procedure set_up_for_consistency;

var
  now_print_time : print_time;
  temp_print_time : print_time;
  previous_midnight : integer;

begin
  current_consistency.this_time := REALTIME;

  calendar.date_from_isis_time(current_consistency.this_time, now_print_time);
  temp_print_time := now_print_time;
  temp_print_time.hour := 0;
  temp_print_time.minute := 0;
  temp_print_time.second := 0;
  previous_midnight := calendar.isis_time(temp_print_time);

  current_consistency.start_time := previous_midnight +
    (header.consistency_start * 60);
  current_consistency.stop_time := previous_midnight +
    (header.consistency_stop * 60);

  if header.consistency_start > header.consistency_stop (* across midnight *)
  then
    if (now_print_time.minute + (now_print_time.hour * 60)) <
      header.consistency_stop
    then current_consistency.start_time :=
      current_consistency.start_time - SECONDS_PER_DAY
    else current_consistency.stop_time :=
      current_consistency.stop_time + SECONDS_PER_DAY;

  current_consistency.during_period :=
    (current_consistency.this_time >= current_consistency.start_time) and
    (current_consistency.this_time <= current_consistency.stop_time)
end (* set_up_for_consistency *);



(*************************  mud_change_handler  *************************)
(*									*)
(*				check_time				*)
(*									*)
(*   1. Check to see if Netval's time has changed more than the defined	*)
(*	ACCEPTABLE_TIME_DIFFERENCE, and crash if it has (otherwise,	*)
(*	scheduling goes haywire).					*)
(*   2. If there is a MUD_UPDATER Process delayed that has a MUD	*)
(*	change waiting to be sent, and there is not a consistency	*)
(*	running, continue that process.					*)
(*   3. If no process was found in step 2, then if it is not during the	*)
(*	scheduled consistency period, stop any running automatic	*)
(*	consistencies.							*)
(*   4. If any automatic consistencies can run, start one.		*)
(*   5. If Tymshare, continue operlog_reporter if time.			*)
(*   6. If reuse_uuns is enabled, and it is time to start a		*)
(*	UUN ADD_BACK merge, continue uun_merger_queue.			*)
(*									*)
(************************************************************************)

procedure entry CHECK_TIME;

var
  real_sup : real_supervisor_index;
  pseudo_sup : pseudo_supervisor_index;
  found : boolean;
  this_time : integer;

begin
  this_time := REALTIME;
  if ((last_time - this_time) > ACCEPTABLE_TIME_DIFFERENCE)
     or ((this_time - last_time) > ACCEPTABLE_TIME_DIFFERENCE)
  then crash_util.halt_slot
  else last_time := this_time;

  find_mud_update_waiter(pseudo_sup, found);
  
  if not found
  then
    begin (* stop consistencies and/or find one to start *)
      set_up_for_consistency; 
      if not current_consistency.during_period
      then (* stop scheduled automatic consistencies *)
        for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
          with sup_core_info[real_sup] do
	    if (current_un2_activity = AUTO_CONSISTENCY) 
	       and not run_init_auto_consistency
	    then to_be_stopped := TRUE;

      find_consistency_to_run(pseudo_sup, found)      
    end (* stop consistencies and/or find one to start *);
   
  if found
  then continue(mud_updater_delay_que[pseudo_sup])

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* check_time *);
!
"
		Validator Command Routines

    The following routines are called by various validator routines
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			    get_sup_update_info				*)
(*									*)
(*      Return MUD_CHANGE_HANDLER info for the Supervisor.		*)
(*									*)
(************************************************************************)

procedure entry GET_SUP_UPDATE_INFO(
      real_sup		: real_supervisor_index;
  var in_core_info	: supervisor_in_core_information);

begin (* get_sup_update_info *)
  in_core_info := sup_core_info[real_sup]
end (* get_sup_update_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     get_header					*)
(*									*)
(*      Return MUD_CHANGE_HANDLER header.				*)
(*									*)
(************************************************************************)

procedure entry GET_HEADER_INFO(
  var header_info	: mudupd_disk_header);

begin
  header_info := header
end (* get_header_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      mud_change_eof				*)
(*									*)
(*      Return the EOF pointer from MUD_UPDATE file.			*)
(*									*)
(************************************************************************)

function entry MUD_CHANGE_EOF : mudupd_data_index;

begin
  mud_change_eof := header.disk_eof
end (* mud_change_eof *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     set_to_be_stopped_true				*)
(*									*)
(*      Set the flag to say consistency should be stopped.		*)
(*									*)
(************************************************************************)

procedure entry set_to_be_stopped_true(
      real_sup	: real_supervisor_index);

begin
  sup_core_info[real_sup].to_be_stopped := TRUE
end (* set_to_be_stopped_true *);
!
"
		Archive Routines

    The MUD_UPDATE file header ONLY is written to tape during a STORE,
and the end-of-file pointer is cleared; when the MUD_UPDATE file is
restored from tape to disk, the end-of-file pointer is also cleared.
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			    read_mudupd_header				*)
(*									*)
(*      Return the header for the MUD_UPDATE file with the		*)
(*	end-of-file pointer cleared and all Supervisors set to OFF.	*)
(*	This forces the validator to turn Supervisors ON after a	*)
(*	RESTORE.							*)
(*									*)
(************************************************************************)

procedure entry READ_MUDUPD_HEADER(
  var header_info : univ mudupd_disk_header);

begin
  header_info := header;
  clear_mudupd_header(header_info)
end (* read_mudupd_header *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, crash_util, next(0, VALIDATOR_LIMIT), calendar, format,
    oper_messages(oplog, format),
    mud_update(MUD_UPDATE_FILE, statistics, file_system, oper_messages,
      format),
    mud_utility(mutil, format, oper_messages, mud_update),
    aux_io(mutil),
    dsksys(statistics),
    cud_block_reader(mutil, oper_messages, format, dsksys);
  initialize
end (* mud_change_handler *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	tick.ntv							*)
(*									*)
(*				mud_change_tick				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

type MUD_CHANGE_TICK = process(
      mud_change	: mud_change_handler);



begin (* initial statement *)
  cycle
    mud_change.check_time;
    wait
  end (* cycle *)
end (* mud_change_tick *);
!
(************************************************************************)
(*									*)
(*	UN2ACC.NTV							*)
(*									*)
(*			    un2_access_controller			*)
(*									*)
(*	The un2_access_controller Monitor is used to gain access	*)
(*	to a circuit to the Supervisor UN2 slave.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18Aug86 - jrn							*)
(*	      - modify and simplify the UN2 access scheme		*)
(*	03Jan86	- rsb							*)
(*	      - change un2_access_manager array declaration to		*)
(*		use "real_supervisor_index"				*)
(*	19Jun85 - jrn							*)
(*		- add circuit_busy function				*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type UN2_ACCESS_CONTROLLER = monitor;


var
  un2_circuit_available : boolean (* the current circuit access *);



(************************  un2_access_controller  ***********************)
(*									*)
(*			      access_circuit				*)
(*									*)
(*	Access the UN2 circuit.						*)
(*									*)
(************************************************************************)

function entry ACCESS_CIRCUIT : boolean;

begin (* access_circuit *)
  if un2_circuit_available
  then
    begin
      access_circuit := TRUE;
      un2_circuit_available := FALSE
    end
  else access_circuit := FALSE
end (* access_circuit *);



(***********************  un2_access_controller  ************************)
(*									*)
(*			     release_circuit				*)
(*									*)
(*      Release the circuit.						*)
(*									*)
(************************************************************************)

procedure entry RELEASE_CIRCUIT;

begin (* release_circuit *)
  un2_circuit_available := TRUE
end (* release_circuit *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  un2_circuit_available := TRUE
end (* un2_access_controller *);
!


(*	An access manager for each Supervisor.		*)

type
  un2_access_manager =
    array [pseudo_supervisor_index] of un2_access_controller;
!
(************************************************************************)
(*									*)
(*	CIRUTL.NTV							*)
(*									*)
(*				circuit_utility				*)
(*									*)
(*	The circuit_utility Class performs general circuit functions.	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	11/10/83	Original -- jrn					*)
(*									*)
(************************************************************************)


const
  HANDSHAKE_CHARACTERS_MAXIMUM = 4;
  HANDSHAKE_CHARACTERS_LIMIT = handshake_characters_maximum - 1;


type
  HANDSHAKE_CHARACTER_INDEX = 0..handshake_characters_limit;
  HANDSHAKE_CHARACTERS = array [HANDSHAKE_CHARACTER_INDEX] of char;


const
  STANDARD_HANDSHAKE = '(:1:)(:2:)(:3:)(:4:)' (* not very secure!! *);



type CIRCUIT_UTILITY = class(
	aux_io		: circuit_handler);



(**************************  circuit_utility  ***************************)
(*									*)
(*			    exchange_handshake				*)
(*									*)
(*      Exchange the supplied handshake.				*)
(*									*)
(************************************************************************)

procedure entry EXCHANGE_HANDSHAKE(
      handshake	: handshake_characters);

var
  receive_buffer : char;
  index : handshake_character_index;
  done : boolean;

begin	(* send the handshake first *)
  aux_io.write_word(handshake);
  if aux_io.available
  then
    begin	(* get the handshake *)
      index := 0; done := FALSE;
      while (aux_io.available) and not done do
        begin
          aux_io.read_one_character(receive_buffer);
          if aux_io.available
	  then
	    if receive_buffer <> handshake[index]
	    then index := 0
	    else
	      if index = HANDSHAKE_CHARACTERS_LIMIT
	      then done := TRUE
	      else index := index + 1
	end
    end
end (* exchange_handshake *);


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* circuit_utility *);
!
(************************************************************************)
(*									*)
(*	UN2UTL.NTV							*)
(*									*)
(*				un2_utility				*)
(*									*)
(*	The un2_utility class performs un2 slave functions.		*)
(*									*)
(*	The routines are organized as follows:				*)
(*		Miscellaneous Routines					*)
(*		Circuit Routines					*)
(*		MUD Change Routines					*)
(*		CONSISTENCY Routines					*)
(*		Programmer Process Routines				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  circuit_handler, internal_to_string, operator_messages,	*)
(*	  un2_access_manager, login_string, un2_status, cud_block_index,*)
(*	  supervisor_index, cud_change_information, un2_user_index,	*)
(*	  character_set, cud_data_word_size, cud_data, cud_disk_block	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	09Sep86 - neh							*) 
(*	       - Change report_message to report_supervisor_message.	*)
(*	18Aug86 - jrn							*)
(*	      - modify and simplify the UN2 access scheme		*)
(*	21Jan86 - jrn							*)
(*	      - use control-I in login string				*)
(*	20Jan86 - jrn							*)
(*	      - modify USN code for NVDM				*)
(*	03Jan86	- rsb							*)
(*	      - expand "sup: Supervisor_index" in "var' list		*)
(*		into "pseudo_sup" and "real_sup".			*)
(*	      - Report_error: add call to translate_ps_to_rs to insure	*)
(*		proper Supervisor is specified in the error message.	*)
(*	      - Send_mud_changes:					*)
(*		Read_mud_block:						*)
(*		Write_mud_block:					*)
(*		Initialize_consistency:					*)
(*		Add call to translate_rs_to_ps to start of procedure	*)
(*		so correct instance of circuit_handler can be called.	*)
(*	      - send_consistency_block: change "supervisor" 		*)
(*		into "real_sup".					*)
(*	23May85 - jrn							*)
(*	      -	call system_handler routine supervisor_checksum to	*)
(*		compute the Tymcom-IX checksum for UN2			*)
(*	12Apr85 jrn							*)
(*	      - fix Supervisor checksum					*)
(*	09Aug84 jrn							*)
(*	      - when building a circuit, if one is already built,	*)
(*		zap it							*)
(*	      - use engine checksum for disk, so move supervisor	*)
(*		checksum here						*)
(*	      - use MAXIMUM_UN2_RETRIES for both consistency and MUD	*)
(*		change updates						*)
(*	15Jun84	jrn							*)
(*	      - add consistency restart capability			*)
(*	      - add disk_maintenance_code assembly parameter		*)
(*	26Apr84 Version 2.02 - jrn					*)
(*	      - re-use circuit on consecutive MUD changes		*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - set a timeout of 30 seconds on circuits built		*)
(*	      - change the error reporting to eliminate multiple	*)
(*		reports and report ranges of blocks transmitted in	*)
(*		consistencies						*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type UN2_UTILITY = class(
	aux_io		: circuit_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	oper_messages	: operator_messages;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	format		: internal_to_string;
	circuit_access	: un2_access_manager
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;
	mud_change	: mud_change_handler);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

const		(* UN2 login string information *)
  LOGIN_STRING_SIZE = 10;
  LOGIN_STRING_SUP_CHAR = 8 (* place to store sup no. *);
  LOGIN_STRING_TEXT =
    '(:9:)(:4:)UN2:12x;                                                ';



(* UN2 commands *)
  UN2_CONSISTENCY_COMMAND = '(:1:)';
  UN2_WRITE_MUD_COMMAND = '(:2:)';
  UN2_READ_MUD_COMMAND = '(:3:)';
  UN2_CONSISTENCY_RESTART_COMMAND = '(:4:)';



(* UN2 consistency codes *)
  UN2_COMMAND_ACCEPTED = '(:1:)' (* used for all commands *);
  UN2_CONSISTENCY_CHECKSUM_OK = '(:1:)';
  UN2_CONSISTENCY_MISMATCH = '(:2:)';
  UN2_DATA_CHECKSUM_OK = '(:1:)' (* also used for write MUD *);
  UN2_CONSISTENCY_BAD_DATA_CHECKSUM = '(:3:)';



(* UN2 write MUD codes *)
  UN2_BLOCK_FOLLOWS = '(:1:)' (* also used for read MUD *);
  UN2_BAD_DATA_CHECKSUM = '(:2:)';


var
  sys_io : system_handler;
  cir_utility : circuit_utility;
  mutil	: misc_utility;

(* current supervisor *)
  pseudo_sup : pseudo_supervisor_index;
  real_sup : real_supervisor_index;

!
"
		Miscellaneous Routines
"



(****************************  un2_utility  *****************************)
(*									*)
(*			      report_error				*)
(*									*)
(*      Report the status to the operator_log.				*)
(*									*)
(************************************************************************)

procedure report_error(
      status	: un2_status;
      block	: cud_block_index);

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  format.start;
  with aux_io do
    format.un2_sup_error(status, param.status, param.arg2, block);
  oper_messages.report_supervisor_message(real_sup, UN2_OPLOG_MSG)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* report_error *);
"


(****************************  un2_utility  *****************************)
(*									*)
(*			  do_supervisor_checksum			*)
(*									*)
(*      Return the checksum for the CUD data; code in-line for speed.	*)
(*	The checksum is rotated 7 bits to the left; this is the		*)
(*	TYMCOM-IX left cycle instruction.				*)
(*									*)
(************************************************************************)

procedure do_supervisor_checksum(
      size	: cud_data_size;
  var data	: cud_data;
  var checksum	: integer);

var
  cksum : integer;
  index : cud_data_index;

begin
  cksum := 0;
  for index := 0 to size - 1 do
    begin
      cksum := (cksum * BIT24) + (cksum div BIT14) + ord(data[index]);
      if cksum < 0
      then cksum := cksum - BIT0;
      cksum := cksum mod BIT7
    end (* for *);
  do_supervisor_checksum := cksum
end (* do_supervisor_checksum *);"



(****************************  un2_utility  *****************************)
(*									*)
(*			   check_circuit_status				*)
(*									*)
(*      Set un2_status if there is a circuit problem and report.	*)
(*									*)
(************************************************************************)

procedure check_circuit_status(
      error_status	: un2_status;
      block		: cud_block_index;
  var status		: un2_status);

begin
  if not aux_io.available
  then
    begin
      status := error_status;
      report_error(status, block)
    end
end (* check_circuit_status *);
!
"
		Circuit Routines
"


(****************************  un2_utility  *****************************)
(*									*)
(*			    get_sup_character				*)
(*									*)
(*      Input a character and check the circuit; if circuit error or	*)
(*	byte_input is not in acceptable_chars, set status,		*)
(*	zap the circuit and report the error.				*)
(*									*)
(************************************************************************)

procedure get_sup_character(
      acceptable_chars	: character_set;
      block		: cud_block_index;
  var byte_input	: char;
  var status		: un2_status);

begin
  aux_io.read_one_character(byte_input);
  check_circuit_status(UN2_CIRCUIT_ERROR, block, status);
  if status = UN2_SUCCESSFUL
  then
    if not (byte_input in acceptable_chars)
    then
      begin
        status := UN2_UNEXPECTED_INPUT;
	aux_io.clear_circuit;
	report_error(status, block)
      end
end (* get_sup_character *);



(****************************  un2_utility  *****************************)
(*									*)
(*			   build_un2_circuit				*)
(*									*)
(*      Be sure there is a circuit in tact for the sup.			*)
(*									*)
(************************************************************************)

procedure build_un2_circuit(
    var status	: un2_status);

var
  login : login_string;

begin
  if aux_io.available
  then aux_io.clear_circuit;
  status := UN2_SUCCESSFUL;
  login.size := LOGIN_STRING_SIZE;
  login.text := LOGIN_STRING_TEXT;
  login.text[LOGIN_STRING_SUP_CHAR] := chr(ord('0') + real_sup);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  aux_io.build_aux_circuit(pseudo_sup, [COMPLETE], 60, login);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  aux_io.set_timeout(30);
  check_circuit_status(UN2_BUILD_FAILURE, 0, status);
  if status = UN2_SUCCESSFUL
  then
    begin
      cir_utility.exchange_handshake(STANDARD_HANDSHAKE);
      check_circuit_status(UN2_HANDSHAKE_ERROR, 0, status)
    end
end (* build_un2_circuit *);



(****************************  un2_utility  *****************************)
(*									*)
(*				send_command				*)
(*									*)
(*      Send a UN2 command and receive confirmation.			*)
(*									*)
(************************************************************************)

procedure send_command(
      un2_cmd	: char;
  var status	: un2_status);

var
  input_char : char;

begin
  aux_io.write_one_character(un2_cmd);
  get_sup_character([UN2_COMMAND_ACCEPTED], 0, input_char, status)
end (* send_command *);


(****************************  un2_utility  *****************************)
(*									*)
(*				send_data				*)
(*									*)
(*      Send word_count (in 2 bytes), data and checksum to UN2		*)
(*	(called by send_block and send_consistency_block routines).	*)
(*									*)
(************************************************************************)

procedure send_data(
      word_count	: cud_data_word_size;
      block		: cud_block_index;
      checksum		: integer;
  var data		: cud_data;
  var status		: un2_status);

begin
  aux_io.write_two_characters(word_count);
  aux_io.write_mud_data((word_count * MAXIMUM_BYTES_IN_WORD), data);
  aux_io.write_three_characters(checksum);
  check_circuit_status(UN2_CIRCUIT_ERROR, block, status)
end (* send_data *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  un2_utility  *****************************)
(*									*)
(*				send_block				*)
(*									*)
(*      Send a MUD block to UN2 (called by send_mud_change		*)
(*	and write_mud_block routines).					*)
(*									*)
(************************************************************************)

procedure send_block(
  var change_info	: mud_change_information;
  var status		: un2_status);

var
  done : boolean;
  retries : integer;
  byte_input : char;

begin
  aux_io.write_one_character(UN2_BLOCK_FOLLOWS);
  if status <> UN2_SUCCESSFUL
  then report_error(status, change_info.cud_info.header.block)
  else
    begin (* status = UN2_SUCCESSFUL *)
      done := FALSE;
      retries := 0;
      with change_info, cud_info, header do
        begin
	  sys_io.supervisor_checksum(size * 4, data, checksum);
	  repeat
            aux_io.write_two_characters(block);
	    aux_io.write_two_characters(offset);
	    send_data(size, block, checksum, data, status);
	    get_sup_character([UN2_DATA_CHECKSUM_OK, UN2_BAD_DATA_CHECKSUM],
	      block, byte_input, status);
            if status <> UN2_SUCCESSFUL
	    then done := TRUE
	    else
              if byte_input = UN2_DATA_CHECKSUM_OK
	      then done := TRUE
	      else
	        if retries = MAXIMUM_UN2_RETRIES
		then
		  begin
		    status := UN2_TOO_MANY_RETRIES;
		    report_error(status, change_info.cud_info.header.block)
		  end (* retries = MAXIMUM_UN2_RETRIES *)
		else retries := retries + 1
          until done
        end (* with *)
    end (* status = UN2_SUCCESSFUL *)
end (* send_block *);
!
"
		MUD Change Routine

	The following is used by the MUD_UPDATER process when
sending mud updates to the Supervisors.
"



(****************************  un2_utility  *****************************)
(*									*)
(*			    send_mud_change				*)
(*									*)
(*      Update the MUD block with the information described by		*)
(*	change_info.							*)
(*									*)
(************************************************************************)

procedure entry SEND_MUD_CHANGE(
      sup               : real_supervisor_index;
  var change_info	: mud_change_information;
  var status		: un2_status);

begin (* send_mud_change *)
  real_sup := sup;
  mud_change.translate_rs_to_ps(real_sup, pseudo_sup);
  if circuit_access[pseudo_sup].access_circuit 
  then
    begin (* actually send a mud change *)
      status := UN2_SUCCESSFUL;
      aux_io.use_circuit(pseudo_sup, AUX_CIRCUIT, [COMPLETE]);
      aux_io.check_circuit;
(* if circuit is already built, the last command must have also been *)
(* a "send_mud_change", so just continue with sending the block data *)
      if aux_io.available
      then aux_io.set_timeout(30)
      else
        begin (* obtain a circuit *)
          build_un2_circuit(status);
   	  if aux_io.available
	  then send_command(UN2_WRITE_MUD_COMMAND, status)
  	end (* obtain a circuit *);
      if aux_io.available
      then send_block(change_info, status);
      circuit_access[pseudo_sup].release_circuit
    end (* actually send a mud change *)
  else status := UN2_BUSY
end (* send_mud_change *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"

		Consistency Routines
The following routines are used to perform a consistency check.
They are called by the CONSISTENCY Class from both the MUD_UPDATER
Processes and the privileged validator Processes.
"



(****************************  un2_utility  *****************************)
(*									*)
(*			initialize_consistency				*)
(*									*)
(*      Lock the Monitor for the consistency and be sure there is	*)
(*	a circuit built.						*)
(*									*)
(************************************************************************)

procedure entry INITIALIZE_CONSISTENCY(
      sup               : real_supervisor_index;
      start_block	: cud_block_index;
  var status		: un2_status);

var
  input_char : char;

begin (* initialize_consistency *)
  real_sup := sup;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  mud_change.translate_rs_to_ps(real_sup, pseudo_sup);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if circuit_access[pseudo_sup].access_circuit
  then
    begin (* obtain and use a circuit *)
      build_un2_circuit(status);
      if status = UN2_SUCCESSFUL
      then
	if CONSISTENCY_RESTARTABLE and (start_block <> 0)
	then
          begin (* send some consistency data *)
	    aux_io.write_one_character(UN2_CONSISTENCY_RESTART_COMMAND);
	    aux_io.write_two_characters(start_block);
	    get_sup_character([UN2_COMMAND_ACCEPTED], 0, input_char,
	         status)
	  end (* send some consistency data *)
 	else send_command(UN2_CONSISTENCY_COMMAND, status);
          if status <> UN2_SUCCESSFUL
          then circuit_access[pseudo_sup].release_circuit
        end (* obtain and use a circuit *)
      else  
        begin (* cannot use circuit for consistency now *)
          status := UN2_BUSY;
          report_error(status, 0)
        end (* cannot use circuit for consistency now *)
end (* initialize_consistency *);



(****************************  un2_utility  *****************************)
(*									*)
(*			    get_mud_checksum				*)
(*									*)
(*      Input 3 bytes of checksum for the next MUD block.		*)
(*									*)
(************************************************************************)

procedure entry GET_MUD_CHECKSUM(
  var checksum	: integer;
  var status	: un2_status);

begin
  aux_io.read_three_characters(checksum);
  check_circuit_status(UN2_CIRCUIT_ERROR, 0, status)
end (* get_mud_checksum *);



(****************************  un2_utility  *****************************)
(*									*)
(*			    checksum_matched				*)
(*									*)
(*      Tell UN2 that checksums matched.				*)
(*									*)
(************************************************************************)

procedure entry CHECKSUM_MATCHED(
  var status	: un2_status);

begin
  aux_io.write_one_character(UN2_CONSISTENCY_CHECKSUM_OK);
  check_circuit_status(UN2_CIRCUIT_ERROR, 0, status)
end (* checksum_matched *);



(****************************  un2_utility  *****************************)
(*									*)
(*			send_consistency_block				*)
(*									*)
(*      Consistency block checksums did not match, tell UN2; send CUD	*)
(*	information; keep track of retries and report any to operator	*)
(*	log.								*)
(*									*)
(************************************************************************)

procedure entry SEND_CONSISTENCY_BLOCK(
      block		: cud_block_index;
      word_count	: cud_data_size;
  var cud_buffer	: cud_disk_block;
  var retries		: integer;
  var status		: un2_status);

var
  success : boolean;
  byte_input : char;

begin
  aux_io.write_one_character(UN2_CONSISTENCY_MISMATCH);
  retries := 0;
  repeat	(* send the consistency block data *)
    with cud_buffer do
      if status = UN2_SUCCESSFUL
      then send_data(word_count, block, checksum, data, status);
    if status = UN2_SUCCESSFUL
    then get_sup_character(
      [UN2_CONSISTENCY_CHECKSUM_OK, UN2_CONSISTENCY_BAD_DATA_CHECKSUM],
        block, byte_input, status);
    if status = UN2_SUCCESSFUL
    then success :=  byte_input = UN2_CONSISTENCY_CHECKSUM_OK;
    if not success
    then
      if retries = MAXIMUM_UN2_RETRIES
      then
        begin
	  status := UN2_TOO_MANY_RETRIES;
	  report_error(status, block)
	end
      else retries := retries + 1
  until success or (status <> UN2_SUCCESSFUL);
  if not success
  then aux_io.clear_circuit
  else
    if retries > 0
    then
      begin
        format.start_message('UN2 report: \ ');
	format.string(' resent block \ ');
	format.number(block, 10);
	format.character(ASCII_SPACE);
	format.number(retries + 1, 10);
	format.string(' times\ ');
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
       oper_messages.report_supervisor_message(real_sup, UN2_OPLOG_MSG)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      end (* retries > 0 *)
end (* send_consistency_block *);
!
"
		Programmer Process Routines

The following calls to the UN2_UTILITY Class allows access to the
Supervisor UN2 slave to read and write a MUD block.
"



(****************************  un2_utility  *****************************)
(*									*)
(*			      read_mud_block				*)
(*									*)
(*      Read the specified MUD block; if called by the NETVAL READ MUD	*)
(*	command, zap the circuit; if NVDM, keep the circuit.		*)
(*									*)
(************************************************************************)

procedure entry READ_MUD_BLOCK(
      sup               : real_supervisor_index;
      block		: cud_block_index;
  var status		: un2_status;
  var mud_buffer	: cud_disk_block);

begin (* read_mud_block *)
  real_sup := sup;
  status := UN2_SUCCESSFUL;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  mud_change.translate_rs_to_ps(real_sup, pseudo_sup);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if circuit_access[pseudo_sup].access_circuit
  then
    begin (* block moving *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  build_un2_circuit(status);
	  if status = UN2_SUCCESSFUL
	  then send_command(UN2_READ_MUD_COMMAND, status);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          if status = UN2_SUCCESSFUL
          then
            begin (* actually read a mud block *)
	      aux_io.write_one_character(UN2_BLOCK_FOLLOWS);
	      aux_io.write_two_characters(block);
	      aux_io.read_mud_data(mud_buffer);
	      check_circuit_status(UN2_CIRCUIT_ERROR, 0, status)
	    end (* actually read a mud block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
     aux_io.clear_circuit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          circuit_access[pseudo_sup].release_circuit
        end (* block moving *)
      else status := UN2_BUSY
end (* read_mud_block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  un2_utility  *****************************)
(*									*)
(*			     write_mud_block				*)
(*									*)
(*      Write the specified MUD block.  Only called by the programmer	*)
(*	WRITE command.							*)
(*									*)
(************************************************************************)

procedure entry WRITE_MUD_BLOCK(
      sup               : real_supervisor_index;
      block		: cud_block_index;
      mud_buffer	: cud_disk_block;
  var status		: un2_status);

var
  change_info : mud_change_information;

begin (* write_mud_block *)
  real_sup := sup;
  status := UN2_SUCCESSFUL;
  mud_change.translate_rs_to_ps(real_sup, pseudo_sup);
  if circuit_access[pseudo_sup].access_circuit
  then
    begin (* block moving *)
      build_un2_circuit(status);
      if status = UN2_SUCCESSFUL
      then send_command(UN2_WRITE_MUD_COMMAND, status);
      if status = UN2_SUCCESSFUL
      then
        begin (* actually send block *)
	  change_info.cud_info.header.block := block;
	  change_info.cud_info.header.offset := 0;
	  change_info.cud_info.header.size := CUD_DATA_WORD_MAXIMUM;
	  change_info.cud_info.data := mud_buffer.data;
	  send_block(change_info, status);
	  aux_io.clear_circuit
	end (* actually send block *);
      circuit_access[pseudo_sup].release_circuit
    end (* block moving *)
  else status := UN2_BUSY
end (* write_mud_block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init sys_io, cir_utility(aux_io), mutil
end (* un2_utility *);
!
(************************************************************************)
(*									*)
(*	CUDACC.NTV							*)
(*									*)
(*			cud_access_controller				*)
(*									*)
(*	This monitor controls access to the CUD file and CUD blocks.	*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  maximum_validator, maximum_password_only_validators,		*)
(* 	  cud_block_index						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	19Jul85 - jrn							*)
(*	      - add missing initialization!!!				*)
(*	08Feb85 - jrn							*)
(*	      - change definition of block_access_index to include	*)
(*		master users if netval_is_a_slave (use			*)
(*		maximum_non_password_only_validators)			*) 
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type CUD_ACCESS_CONTROLLER = monitor;


(* Each non password only validator may access two blocks at	*)
(* once...when doing a rename both the old and new block need	*)
(* to be locked for writing at the same time.  password_only	*)
(* validators may only lock  one block at a time.		*)

const
  MAXIMUM_BLOCK_ACCESSES = (maximum_non_password_only_validators * 2) +
    maximum_password_only_validators;

  BLOCK_ACCESS_LIMIT = maximum_block_accesses - 1;



type
  BLOCK_ACCESS_INDEX = 0..block_access_limit;



const
  NO_WAITER = -1 (* end of list of waiters *);



(* Each validator may only be waiting once! *)

type
  WAITER_INDEX = no_waiter..validator_limit;



(* The various states a BLOCK can be in: *)
  BLOCK_STATE = (
    INACTIVE		(* not an active block *),
    LOCKED		(* block is being written *),
    SHUT		(* block is being manually written *));


  BLOCK_STATE_SET = set of block_state;



(* The various states a WAITER can be in: *)
  DELAY_STATE = (
    NO_DELAY		(* no waiter here *),
    DELAYED_FOR_LOCK	(* waiting for write *),
    DELAYED_FOR_SHUT	(* waiting for manual write *));


  DELAY_STATE_SET = set of delay_state;



(* Permanent variables maintained by the monitor*)
(* are described by the following:		*)

  BLOCK_ACCESS_INFORMATION = record
    block		: cud_block_index (* block_number *);
    current_state	: block_state;
    first_waiter	: waiter_index
  end (* block_access_information *);



  DELAYED_VALIDATOR_INFORMATION = record
    state	: delay_state;
    waiter	: queue;
    next_waiter	: waiter_index
  end (* delayed_validator_information *);



var
(* the CUD file access *)
(* initialized to file_access = FILE_AVAILABLE *)

  file_access : file_access_state;


(* Delay validator wishing to lock the file in this	*)
(* queue until there are no more blocks locked or	*)
(* shut.  If a second validator tries to lock the	*)
(* file, return CUD_ACCESS_FILE_LOCKED.			*)

  waiting_for_file : queue;


(*		Block access information:		*)
(* Initialized to current_state = INACTIVE,		*)
(* first_waiter = NO_WAITER.  When a file lock is	*)
(* requested, the caller is delayed until all block	*)
(* waits are satisfied and all blocks freed up.		*)

  block_access : array [block_access_index] of block_access_information;


(*		Delayed validator information:		*)
(* Validators are delayed here when waiting for a	*)
(* block to write or shut.  Initialized to		*)
(* state = NO_DELAY, next_waiter = NO_WAITER.		*)

  delay_list : array [validator_index] of delayed_validator_information;
!
(***********************  cud_access_controller  ************************)
(*									*)
(*				initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  init_pointer : block_access_index;
  init_index : validator_index;

begin
  file_access := FILE_AVAILABLE;
  for init_pointer := 0 to BLOCK_ACCESS_LIMIT do
    with block_access[init_pointer] do
      begin
        current_state := INACTIVE;
	first_waiter := NO_WAITER
      end (* with *);
  for init_index := 0 to VALIDATOR_LIMIT do
    with delay_list[init_index] do
      begin
        state := NO_DELAY;
	next_waiter := NO_WAITER
      end (* with *)
end (* initialize *);



(***********************  cud_access_controller  ************************)
(*									*)
(*				any_blocks				*)
(*									*)
(*      Return TRUE if there are any blocks with one of the		*)
(*	requested block states.						*)
(*									*)
(************************************************************************)

function ANY_BLOCKS(
      requested_states	: block_state_set) : boolean;

var
  done : boolean;
  scan_pointer : block_access_index;

begin
  any_blocks := FALSE; done := FALSE;
  scan_pointer := 0;
  repeat
    if block_access[scan_pointer].current_state in requested_states
    then
      begin
        any_blocks := TRUE;
	done := TRUE
      end (* current_state in requested_states *)
    else (* current_state is NOT in requested_states *)
      if scan_pointer < BLOCK_ACCESS_LIMIT
      then scan_pointer := scan_pointer + 1
      else done := TRUE
  until done
end (* any_blocks *);



(***********************  cud_access_controller  ************************)
(*									*)
(*				any_waiter				*)
(*									*)
(*      Return TRUE if there are any waiters with one of		*)
(*	the reqested delay states.					*)
(*									*)
(************************************************************************)

function ANY_WAITER(
      requested_states	: delay_state_set) : boolean;

var
  done : boolean;
  validator : validator_index;

begin
  any_waiter := FALSE; done := FALSE;
  validator := FIRST_VALIDATOR;
  repeat
    if delay_list[validator].state in requested_states
    then
      begin
        any_waiter := TRUE;
	done := TRUE
      end (* state is in requested_states *)
    else (* state is NOT in requested_states *)
      if validator < VALIDATOR_LIMIT
      then validator := validator + 1
      else done := TRUE
  until done
end (* any_waiter *);



(***********************  cud_access_controller  ************************)
(*									*)
(*			    find_block_access 				*)
(*									*)
(*	Scan block_access and return block_pointer, which points	*)
(*	to the block_access entry that currently has the block if	*)
(*	it is found, or to an empty slot if the block is not found.	*)
(*									*)
(************************************************************************)

procedure find_block_access(
      block		: cud_block_index;
  var found		: boolean;
  var block_pointer	: block_access_index);

var
  done : boolean;
  scan_pointer : block_access_index;

begin
  found := FALSE; done := FALSE;
  scan_pointer := 0;
  repeat
    if block_access[scan_pointer].current_state = INACTIVE
    then block_pointer := scan_pointer
    else (* current_state is NOT INACTIVE *)
      if block_access[scan_pointer].block = block
      then
        begin
	  block_pointer := scan_pointer;
	  found := TRUE; done := TRUE
	end (* block is the one being searched for *);
    if not found
    then
      if scan_pointer < BLOCK_ACCESS_LIMIT
      then scan_pointer := scan_pointer + 1
      else done := TRUE
  until done
end (* find_block_access *);



(***********************  cud_access_controller  ************************)
(*									*)
(*				lock_it					*)
(*									*)
(*      Lock the given block_access.					*)
(*									*)
(************************************************************************)

procedure lock_it(
      block		: cud_block_index;
      block_pointer	: block_access_index;
      manual		: boolean;
      new_first_waiter	: waiter_index);

begin
  block_access[block_pointer].block := block;
  block_access[block_pointer].first_waiter := new_first_waiter;
  if manual
  then block_access[block_pointer].current_state := SHUT
  else block_access[block_pointer].current_state := LOCKED
end (* lock_it *);



(***********************  cud_access_controller  ************************)
(*									*)
(*			    waiting_for_shut				*)
(*									*)
(*      Return TRUE if there is a caller waiting for a SHUT at the	*)
(*	end of the chain of waiters; block_pointer points to the	*)
(*	beginning of the chain.						*)
(*									*)
(************************************************************************)

function WAITING_FOR_SHUT(
      block_pointer	: block_access_index) : boolean;

var
  waiter_pointer : waiter_index;
  done : boolean;

begin
  waiting_for_shut := FALSE;
  waiter_pointer := block_access[block_pointer].first_waiter;
  repeat
    if waiter_pointer = NO_WAITER
    then done := TRUE
    else
      if delay_list[waiter_pointer].state = DELAYED_FOR_SHUT
      then 
        begin
          waiting_for_shut := TRUE;
	  done := TRUE
	end
      else waiter_pointer := delay_list[waiter_pointer].next_waiter
  until done
end (* waiting_for_shut *);
!
"
		External Routines
"


(***********************  cud_access_controller  ************************)
(*									*)
(*			      lock_cud_file				*)
(*									*)
(*      Lock the CUD file from writing; called by ARCHIVE STORE command	*)
(*	only.								*)
(*									*)
(************************************************************************)

procedure entry LOCK_CUD_FILE(
  var status		: cud_access_status);

begin
  if (file_access <> FILE_AVAILABLE) or not empty(waiting_for_file)
  then status := CUD_ACCESS_FILE_LOCKED
  else
    if any_blocks([SHUT]) or any_waiter([DELAYED_FOR_SHUT])
    then status := CUD_ACCESS_BLOCK_SHUT (* another process was first *)
    else
      begin
        status := CUD_ACCESS_OK;
        if any_blocks([LOCKED])
        then delay(waiting_for_file);

        file_access := FILE_READABLE (* continued here *)
      end
end (* lock_cud_file *);



(***********************  cud_access_controller  ************************)
(*									*)
(*			     unlock_cud_file				*)
(*									*)
(*      Make the CUD file available to all.				*)
(*									*)
(************************************************************************)

procedure entry UNLOCK_CUD_FILE;

begin
  file_access := FILE_AVAILABLE
end (* unlock_cud_file *);



(***********************  cud_access_controller  ************************)
(*									*)
(*			  current_access_state				*)
(*									*)
(*      Return the current access state of the CUD file.		*)
(*									*)
(************************************************************************)

function entry CURRENT_ACCESS_STATE : file_access_state;

begin
  current_access_state := file_access
end (* current_access_state *);




(***********************  cud_access_controller  ************************)
(*									*)
(*			     lock_cud_block				*)
(*									*)
(*      Lock the block for the caller.					*)
(*									*)
(************************************************************************)

procedure entry LOCK_CUD_BLOCK(
      validator	: validator_index;
      block	: cud_block_index;
      manual	: boolean (* TRUE if (programmer lock *);
  var status	: cud_access_status);

var
  waiter_pointer : waiter_index;
  block_pointer : block_access_index;
  found : boolean;

begin
  status := CUD_ACCESS_OK;
  if (file_access <> FILE_AVAILABLE) or not empty(waiting_for_file)
  then status := CUD_ACCESS_FILE_LOCKED
  else
    begin (* file is available *)
      find_block_access(block, found, block_pointer);
      if not found
      then lock_it(block, block_pointer, manual, NO_WAITER) (* its available *)
      else (* this block is being accessed *)
        if (block_access[block_pointer].current_state = SHUT) or
	  waiting_for_shut(block_pointer)
	then status := CUD_ACCESS_BLOCK_SHUT (* block is shut, forget it *)
	else
	  begin (* block is locked by another user, wait for it *)
	    (* Set up the delay information to delay the validator; *)
	    (* block_pointer points to the block's entry in block_access. *)
	    if manual
	    then delay_list[validator].state := DELAYED_FOR_SHUT
	    else delay_list[validator].state := DELAYED_FOR_LOCK;
	    delay_list[validator].next_waiter := NO_WAITER;
	    if block_access[block_pointer].first_waiter = NO_WAITER
	    then block_access[block_pointer].first_waiter := validator
	    else
	      begin (* not the first waiter, add to list *)
	        waiter_pointer := block_access[block_pointer].first_waiter;
		while delay_list[waiter_pointer].next_waiter <> NO_WAITER do
		  waiter_pointer := delay_list[waiter_pointer].next_waiter;
		delay_list[waiter_pointer].next_waiter := validator
	      end (* not the first waiter, add to list *);
	    delay(delay_list[validator].waiter);

	    lock_it(block, block_pointer, manual, (* continued here *)
	      delay_list[validator].next_waiter)
	  end (* block is locked by another user, wait for it *)
    end (* file is available *)
end (* lock_cud_block *);



(***********************  cud_access_controller  ************************)
(*									*)
(*			     unlock_cud_block				*)
(*									*)
(*      Make a locked block available and continue the next		*)
(*	the next validator waiting for the block or file.		*)
(*									*)
(************************************************************************)

procedure entry UNLOCK_CUD_BLOCK(
      block	: cud_block_index);

var
  block_pointer : block_access_index;
  found : boolean;

begin
  find_block_access(block, found, block_pointer);
  if found
  then
    begin
      block_access[block_pointer].current_state := INACTIVE;
      if block_access[block_pointer].first_waiter <> NO_WAITER
      then (* there is a waiter for the block *)
        continue(delay_list[block_access[block_pointer].first_waiter].waiter)
      else (* no waiter for this block, check file waiter *)
	if not empty(waiting_for_file) and not any_blocks([LOCKED])
	then continue(waiting_for_file)
    end
end (* unlock_cud_block *);
!
(**********************************************************************)
(**********************************************************************)

begin (* initial statement *)
  initialize
end (* cud_access_controller *);
!
(************************************************************************)
(*									*)
(*	CUDBLK.NTV							*)
(*									*)
(*				cud_block_updater			*)
(*									*)
(*	This Class performs all CUD block I/O functions.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  cud_data, cud_block_index, cud_disk_block, cud_data_size,	*)
(*	  validator_index						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18Dec84 - jrn							*)
(*	      - add logical_volume_directory				*)
(*	14Oct84 - Version 3.00 - pgl				        *)
(*	      - add conditional assembly parameter		        *)
(*		logical_volumes					        *)
(*	09Aug84 jrn							*)
(*	      - use engine checksum for disk				*)
(*	15Jun84	removed oper_messages - jrn				*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type CUD_BLOCK_UPDATER = class(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	mutil		: misc_utility;
	statistics	: statistics_gatherer;
	dsksys		: disk_system;
	cud_access	: cud_access_controller;
	block_utility	: cud_block_utility;
	format		: internal_to_string);


var
  sys_io : system_handler;



(*************************  cud_block_updater  **************************)
(*									*)
(*			     read_cud_block				*)
(*									*)
(*      Read the CUD block; if it is locked, it can only be locked	*)
(*	against writing.						*)
(*									*)
(************************************************************************)

procedure entry READ_CUD_BLOCK(
      block	: cud_block_index;
  var result	: cud_operation_result;
  var buffer	: cud_disk_block);

begin
  block_utility.read_cud_block(block, result, buffer);
  if result <> CUD_OPERATION_OK
  then block_utility.report_error(result, block)
end (* read_cud_block *);



(*************************  cud_block_updater  **************************)
(*									*)
(*			    modify_cud_block				*)
(*									*)
(*      Lock the CUD block, and read the block into data.		*)
(*									*)
(************************************************************************)

procedure entry MODIFY_CUD_BLOCK(
      validator	: validator_index;
      block	: cud_block_index;
  var result	: cud_operation_result;
  var buffer	: cud_disk_block);

var
  status : cud_access_status;

begin
(* first lock the CUD block *)
  cud_access.lock_cud_block(validator, block, FALSE, status);
  case status of
    CUD_ACCESS_OK:		result := CUD_OPERATION_OK;
    CUD_ACCESS_FILE_LOCKED:	result := CUD_FILE_LOCKED;
    CUD_ACCESS_BLOCK_SHUT:	result := CUD_BLOCK_MANUALLY_LOCKED
  end (* case *);
  if result = CUD_OPERATION_OK
  then
    begin    
      block_utility.read_cud_block(block, result, buffer);
      if result <> CUD_OPERATION_OK
      then cud_access.unlock_cud_block(block)
    end;
  if result <> CUD_OPERATION_OK
  then block_utility.report_error(result, block)
end (* modify_cud_block *);



(*************************  cud_block_updater  **************************)
(*									*)
(*			    update_cud_block				*)
(*									*)
(*      Compute the checksum for the data, and write it to block;	*)
(*	a modify_cud_block must have been called previously.		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_CUD_BLOCK(
      block	: cud_block_index;
  var buffer	: cud_disk_block;
  var result	: cud_operation_result);

var
  success : boolean;

begin
  result := CUD_OPERATION_OK;
  sys_io.cud_checksum(MAXIMUM_CUD_DATA, buffer.data, buffer.checksum);
  dsksys.write_cud_block(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CUD_DISK_UNIT,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
     block, buffer, success);
  if not success
  then
    begin
      result := CUD_OPERATION_FAILED;
      block_utility.report_error(result, block)
    end
end (* update_cud_block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init sys_io
end (* cud_block_updater *);
!
(************************************************************************)
(*									*)
(*	CENUTL.NTV							*)
(*									*)
(*				cud_entry_utility			*)
(*									*)
(*      The CUD_ENTRY_UTILITY Class includes common routines for CUD	*)
(*      entry manipulation, including some packing and unpacking.	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	8/2/84	Original -- neb						*)
(*									*)
(************************************************************************)

type CUD_ENTRY_UTILITY = class(
	mutil		: misc_utility;
	format	 	: internal_to_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	oper_messages	: operator_messages);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		Internal Routines
"



(*************************  cud_entry_utility  **************************)
(*									*)
(*			  do_clear_access_entry				*)
(*									*)
(*     Clear an access entry.					        *)
(*									*)
(************************************************************************)

procedure do_clear_access_entry(
  var access_entry	: access_entry_description);

var
  in_place_index : in_place_origin_index;
  dest_index : destination_index;

begin
  access_entry.in_place_origin := FALSE;
  access_entry.exception := FALSE;
  access_entry.class_no := 0;
  access_entry.origin.size := 0;
  access_entry.destination.size := 0;
  for in_place_index := 0 to IN_PLACE_ORIGIN_LIMIT do
    with access_entry.origin.list[in_place_index] do
     begin
	value := 0;
	host_flag := FALSE
     end;
  for dest_index := 0 to DESTINATION_LIMIT do
    with access_entry.destination.list[dest_index] do
      begin
        value := 0;
	group_flag := FALSE;
	home_flag := FALSE
      end
end (* do_clear_access_entry *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			   option_bit_location				*)
(*									*)
(*     Return the bit location in the CUD control word of the given	*)
(*     option (previously option_bit in cud_entry_updater).	        *)
(*									*)
(************************************************************************)

function option_bit_location(
      option    : control_options) : integer;

begin
  case option of
    ACCOUNT_SUPERVISOR:  option_bit_location := ACCOUNT_SUPERVISOR_BIT;
    IGNORE_HOST:	 option_bit_location := IGNORE_HOST_BIT;
    NETWORK_ADMINISTRATOR:
      option_bit_location := NETWORK_ADMINISTRATOR_BIT;
    NO_PASSWORD:	 option_bit_location := NO_PASSWORD_BIT;
    SHUT_OVERRIDE:	 option_bit_location := SHUT_OVERRIDE_BIT;
    AUDITOR: 		 option_bit_location := AUDITOR_BIT;
    OPERATOR:		 option_bit_location := OPERATOR_BIT (* NETVAL oper *);
    TRANSPARENT_LOGIN:	 option_bit_location := TRANSPARENT_LOGIN_BIT;
    NEW_PASSWORD_OPTION: option_bit_location := NEW_PASSWORD_BIT
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  end (* case *)
end (* option_bit_location *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			   do_set_format_error				*)
(*									*)
(*     Set status to format error and output a message to the operator  *)
(*     log.								*)
(*									*)
(************************************************************************)

procedure do_set_format_error(
      block	 	: cud_block_index;
      pointer		: cud_data_index;
  var cud_status	: cud_entry_result);

begin
  cud_status := CUD_FORMAT_ERROR;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      format.start_message(CUD_FILE_MESSAGE);
      format.character(ASCII_SPACE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  format.string(FORMAT_ERROR);
  format.on_block(block);
  format.string(' at \ ');
  format.number(pointer, 10);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  oper_messages.report_message(CUD_OPLOG_MSG)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* do_set_format_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_utility  **************************)
(*									*)
(*			    do_set_entry_size				*)
(*									*)
(*	Return the entry size of the entry in data pointed to by	*)
(*	entry_pointer and set cud_status; if entry points to an		*)
(*	overflow indicator, set status to CUD_ENTRY_OVERFLOW_FOUND.	*)
(*									*)
(************************************************************************)

procedure do_set_entry_size(
      data		: cud_data;
      entry_pointer	: cud_data_index;
      block		: cud_block_index;
  var cud_status	: cud_entry_result;
  var entry_size	: cud_data_size);

begin
  entry_size := ord(data[entry_pointer]);
  if entry_size = 0
  then cud_status := CUD_ENTRY_NOT_FOUND
  else
    begin	(* entry_size <> 0 *)
      if (data[entry_pointer + 1] <> ZERO) or
        (data[entry_pointer + 2] <> ZERO) or
	(data[entry_pointer + 3] <> ZERO) or
	((entry_pointer + entry_size) > CUD_DATA_LIMIT)
      then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	do_set_format_error(block, entry_pointer, cud_status);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if cud_status = CUD_ENTRY_OK
      then
        if mutil.odd(entry_size)
	then do_set_format_error(block, entry_pointer, cud_status)
    end	(* entry_size <> 0 *)
end (* do_set_entry_size *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			do_increment_entry_pointer			*)
(*									*)
(*     Return the incremented pointer and set cud_status (entry_size	*)
(*     is size of current entry pointed to by entry_pointer).	        *)
(*									*)
(************************************************************************)

procedure do_increment_entry_pointer(
      block		: cud_block_index;
      entry_size	: cud_data_size;
  var cud_status	: cud_entry_result;
  var entry_pointer	: cud_data_index);

begin
  if (entry_size + entry_pointer) > CUD_DATA_LIMIT
  then do_set_format_error(block, entry_pointer, cud_status)
  else entry_pointer := entry_size + entry_pointer
end (* do_increment_entry_pointer *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			 do_find_end_of_entries				*)
(*									*)
(*	Return the pointer to the end of the data in data and set	*)
(*	cud_status.  If end of data is successfully found, cud_status	*)
(*	is set to CUD_ENTRY_NOT_FOUND.					*)
(*									*)
(************************************************************************)

procedure do_find_end_of_entries(
      data		: cud_data;
      block		: cud_block_index;
  var cud_status	: cud_entry_result;
  var entry_pointer	: cud_data_index);

var
  entry_size : cud_data_size;

begin
  entry_pointer := 0;
  repeat
    do_set_entry_size(data, entry_pointer, block, cud_status, entry_size);
    if cud_status = CUD_ENTRY_OK
    then do_increment_entry_pointer(block, entry_size, cud_status,
      entry_pointer)
  until cud_status <> CUD_ENTRY_OK
end (* do_find_end_of_entries *);
!
"
		External Routines
"
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_utility  **************************)
(*									*)
(*			   remove_access_entry				*)
(*									*)
(*     Remove the access entry specified by position from the		*)
(*     access_profile; code in command_level, delete_access procedure,  *)
(*     should be replaced by this routine (also called by 		*)
(*     master_command_level).						*)
(*									*)
(************************************************************************)

procedure entry REMOVE_ACCESS_ENTRY(
      position		: access_entry_index;
  var access_profile	: access_profile_description);

var
  index : access_entry_index;

begin
  for index := position to access_profile.count - 2 do
    access_profile.entries[index] := access_profile.entries[index + 1];
  access_profile.count := access_profile.count - 1
end (* remove_access_entry *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			    clear_access_entry				*)
(*									*)
(*     Clear an access entry.					        *)
(*									*)
(************************************************************************)

procedure entry CLEAR_ACCESS_ENTRY(
  var access_entry	: access_entry_description);

begin
  do_clear_access_entry(access_entry)
end (* clear_access_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_utility  **************************)
(*									*)
(*			      pack_options				*)
(*									*)
(*     Pack the user_options from options into packed_word.	        *)
(*									*)
(************************************************************************)

procedure entry PACK_OPTIONS(
      options		: user_options;
  var packed_word	: univ integer);

var
  next_option : cud_control_options;

begin
  packed_word := mutil.mask(packed_word, DISTRICT_MASK);
  for next_option := FIRST_CUD_CONTROL_OPTION to LAST_CUD_CONTROL_OPTION do
    if next_option in options
    then mutil.set_bit(option_bit_location(next_option), packed_word)
end (* pack_options *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			      unpack_options				*)
(*									*)
(*     Unpack options from the packed word to the set of user_options.	*)
(*									*)
(************************************************************************)

procedure entry UNPACK_OPTIONS(
      packed_word	: univ integer;
  var options		: user_options);

var
  next_option : cud_control_options;

begin
  options := [];
  for next_option := FIRST_CUD_CONTROL_OPTION to LAST_CUD_CONTROL_OPTION do
    if mutil.test_bit(option_bit_location(next_option), packed_word)
    then options := options or [next_option]
end (* unpack_options *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*				option_bit				*)
(*									*)
(*     Return the bit location in the CUD control word of the given     *)
(*     option.								*)
(*									*)
(************************************************************************)

function entry OPTION_BIT(
      option	: control_options) : integer;

begin
  option_bit := option_bit_location(option)
end (* option_bit *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			  clear_access_profile				*)
(*									*)
(*     Clear an access profile; change cud_entry_updater routine	*)
(*     initialize_access_profile to call this routine.		        *)
(*									*)
(************************************************************************)

procedure entry CLEAR_ACCESS_PROFILE(
  var access_profile	: access_profile_description);

var
  index : access_entry_index;

begin
  access_profile.count := 0;
  for index := 0 to ACCESS_ENTRY_LIMIT do
    do_clear_access_entry(access_profile.entries[index])
end (* clear_access_profile *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			      set_entry_size				*)
(*									*)
(*     Return the entry SIZE of the entry in data pointed to by		*)
(*     entry_pointer and set cud_status.			        *)
(*									*)
(************************************************************************)

procedure entry SET_ENTRY_SIZE(
      data		: cud_data;
      entry_pointer	: cud_data_index;
      block		: cud_block_index;
  var cud_status	: cud_entry_result;
  var entry_size	: cud_data_size);

begin
  do_set_entry_size(data, entry_pointer, block, cud_status, entry_size)
end (* set_entry_size *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			 increment_entry_pointer			*)
(*									*)
(*     Return the incremented pointer and set cud_status (entry_size	*)
(*     is size of current entry pointed to by entry_pointer).	        *)
(*									*)
(************************************************************************)

procedure entry INCREMENT_ENTRY_POINTER(
      block		: cud_block_index;
      entry_size	: cud_data_size;
  var cud_status	: cud_entry_result;
  var entry_pointer	: cud_data_index);

begin
  do_increment_entry_pointer(block, entry_size, cud_status, entry_pointer)
end (* increment_entry_pointer *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			   find_end_of_entries				*)
(*									*)
(*	Return the pointer to the end of the data in data and set	*)
(*	cud_status.  If end of data is successfully found, cud_status	*)
(*	is set to CUD_ENTRY_NOT_FOUND.					*)
(*									*)
(************************************************************************)

procedure entry FIND_END_OF_ENTRIES(
      data		: cud_data;
      block		: cud_block_index;
  var cud_status	: cud_entry_result;
  var entry_pointer	: cud_data_index);

begin
  do_find_end_of_entries(data, block, cud_status, entry_pointer)
end (* find_end_of_entries *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			  cud_block_byte_count				*)
(*									*)
(*     Return the number of bytes of data in the cud_data, and set	*)
(*     cud_status (called by archive, consisteny and master routines).	*)
(*									*)
(************************************************************************)

procedure entry CUD_BLOCK_BYTE_COUNT(
      data		: cud_data;
      block		: cud_block_index;
  var cud_status	: cud_entry_result;
  var bytes_used	: cud_data_size);

var
  entry_pointer : cud_data_index;

begin
  do_find_end_of_entries(data, block, cud_status, entry_pointer);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if cud_status = CUD_FORMAT_ERROR
  then bytes_used := MAXIMUM_CUD_DATA - MAXIMUM_BYTES_IN_WORD
  else bytes_used := entry_pointer
end (* cud_block_byte_count *);



(*************************  cud_entry_utility  **************************)
(*									*)
(*			    set_format_error				*)
(*									*)
(*     Set status to format error and output a message to the operator  *)
(*     log.							        *)
(*									*)
(************************************************************************)

procedure entry SET_FORMAT_ERROR(
      block	 	: cud_block_index;
      pointer		: cud_data_index;
  var cud_status	: cud_entry_result);

begin
  do_set_format_error(block, pointer, cud_status)
end (* set_format_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* cud_entry_utility *);
!
(************************************************************************)
(*									*)
(*	CONSIS.NTV							*)
(*									*)
(*			    consistency_handler				*)
(*									*)
(*	The CONSISTENCY_HANDLER Class performs the CUD-MUD		*)
(*	consistency check.						*)
(*									*)
(*      The routines are organized as follows:				*)
(*		Internal Routines					*)
(*	  	Validator Routines					*)
(*		Automatic consistency Routines				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  un2_status, real_supervisor_index, cud_block_index,		*)
(*	  circuit_handler, pseudo_sup_index				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18Aug86 - jrn							*)
(*	      - modify and simplify the UN2 access scheme		*)
(*	07Aug86 - rsb							*)
(*	      - remove call to mud_change.report_consistency_error	*)
(*		from next_consistency_block if a read error occurred	*)
(*		as the read procedure already reports an error.		*)
(*	21Jan86 - jrn							*)
(*	      - use internal_to_string BY_VALIDATOR procedure		*)
(*	20Jan86 - jrn							*)
(*	      - modify USN code for NVDM				*)
(*	07Jan86 - rsb							*)
(*              - Stop_Consistency					*)
(*		  - add "var pseudo_sup : pseudo_sup_index"		*)
(*		  - call TRANSLATE_RS_TO_PS before call to 		*)
(*		    un2_access[pseudo_sup].unlock_from_consistency	*)
(*		- Rest of Consistency_Handler:				*)
(*		  - Every "sup : supervisor_index" becomes		*)
(*		          "real_sup : real_supervisor_index;"		*)
(*		  - Every "sup" becomes "real_sup"			*)
(*	23May85 - jrn							*)
(*	      - modify report_to_validator routine to output block	*)
(*		number instead of "."					*)
(*	06Nov84 jrn							*)
(*	      - modify output format of consistency if there is textual	*)
(*		output between reports					*)
(*	21Aug84 jrn							*)
(*	      - make consistency faster by removing some single use	*)
(*		routines						*)
(*	15Jun84	jrn							*)
(*	      - add consistency restart capability			*)
(*	      - add disk_maintenance_code assembly parameter		*)
(*	08Jun84 Version 2.02 - jrn					*)
(*	      - fix bug on CUD error in running consistency		*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - added the NO_CHANGE option				*)
(*	31Oct83	Original -- jrn						*)
(*									*)
(************************************************************************)


type CONSISTENCY_HANDLER = class(
	mutil		: misc_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	mud_change	: mud_change_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	un2_util	: un2_utility;
	un2_access	: un2_access_manager;
	block_updater	: cud_block_updater;
	cud_utility	: cud_entry_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	oper_messages	: operator_messages;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	format		: internal_to_string;
	aux_io		: circuit_handler);



const
  CONSISTENCY_STARTED_MESSAGE = 'consistency started\';
  NO_MISMATCH = -1;


var
  sys_io : system_handler;
  entry LAST_UN2_STATUS : un2_status;
!
"
		Internal Routines
"



(************************  consistency_handler  *************************)
(*									*)
(*			    start_consistency				*)
(*									*)
(*      Start up a consistency.						*)
(*									*)
(************************************************************************)

procedure start_consistency(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      no_change		: boolean;
      run_manual	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      real_sup          : real_supervisor_index;
      start_block	: cud_block_index);


begin (* start_consistency *)
  un2_util.initialize_consistency(real_sup, start_block, last_un2_status);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if last_un2_status = UN2_SUCCESSFUL
  then
    begin (* last_un2_status = UN2_SUCCESSFUL *)
      mud_change.record_consistency_started(real_sup, start_block, run_manual,
        no_change);
      if run_manual
      then format.start_message(MANUAL_MESSAGE)
      else format.start;
      format.string(CONSISTENCY_STARTED_MESSAGE);
      if start_block <> 0
      then format.on_block(start_block);
      if no_change
      then format.string(' (no change)\ ')
    end (* last_un2_status = UN2_SUCCESSFUL *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* start_consistency *);



(************************  consistency_handler  *************************)
(*									*)
(*			    report_mismatch				*)
(*									*)
(************************************************************************)

procedure report_mismatch(
      real_sup          : real_supervisor_index;
      first_block	: univ integer;
      last_block	: univ integer;
      no_change		: boolean
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
);

begin
  if first_block <> NO_MISMATCH
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
     format.start_message('Consistency checksum mismatch, \');
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      format.string(' on block\');
      if first_block = last_block
      then
        begin
          format.character(ASCII_SPACE);
          format.number(first_block, 10)
        end
      else
        begin
          format.string('s \ ');
          format.number_range(first_block, last_block, 10)
        end;
      if no_change
      then
        begin
	  format.newline;
	  format.string('no update performed\')
	end;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        oper_messages.report_supervisor_message(real_sup, UN2_OPLOG_MSG)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
end (* report_mismatch *);



(************************  consistency_handler  *************************)
(*									*)
(*			 report_consistency_error			*)
(*									*)
(*	Report a consistency error to the operator log.			*)
(*									*)
(************************************************************************)

procedure report_consistency_error(
      real_sup		: real_supervisor_index;
      block		: cud_block_index;
      status		: consistency_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
);

begin
  format.start;
  format.consistency_error(block, status);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  oper_messages.report_supervisor_message(real_sup, UN2_OPLOG_MSG)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* report_consistency_error *);



(************************  consistency_handler  *************************)
(*									*)
(*			  next_consistency_block			*)
(*									*)
(*      Perform the consistency on the next CUD block; report block	*)
(*	and check for stop_pending (via mud_change_handler).  If	*)
(*	no_change is TRUE, everything should work exactly as usual,	*)
(*	except:								*)
(*	      - when checksums do not match, the CUD block		*)
(*		will not be transmitted (UN2 is told that the		*)
(*		checksums matched).					*)
(*									*)
(************************************************************************)

procedure next_consistency_block(
      real_sup          : real_supervisor_index;
      block		: cud_block_index;
      no_change		: boolean (* if TRUE, don't change MUD *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var first_mismatch	: integer;
  var status		: consistency_status;
  var updated_block	: boolean (* TRUE if CUD block was transmitted *);
  var retries		: integer);

var
  mud_checksum	: integer;
  cud_buffer 	: cud_disk_block;
  word_count 	: cud_data_size;
  result 	: cud_operation_result;
  cud_status 	: cud_entry_result;
  bytes_used 	: cud_data_size;

begin (* next_consistency_block *)
  status := CONSISTENCY_OK; 
  updated_block := FALSE;
  un2_util.get_mud_checksum(mud_checksum, last_un2_status);
  
  if last_un2_status <> UN2_SUCCESSFUL
  then status := UN2_ERROR
  else
    begin (* last_un2_status = UN2_SUCCESSFUL *)
      block_updater.read_cud_block(block, result, cud_buffer);
      if result = CUD_OPERATION_OK
      then sys_io.supervisor_checksum(MAXIMUM_CUD_DATA, cud_buffer.data,
        cud_buffer.checksum) (* compute 940/sup checksum *)
(* NOTE:  when the Supervisor checksum changes to be the engine	*)
(* checksum, check for the following effect:			*)
(*	Some private networks use the NETVAL_CUD_IS_A_MUD	*)
(*	option, and have multiple netvals in the network.	*)
(*	When a MUD is updated, no checksum is written to	*)
(*	the disk, and when that MUD becomes a CUD, Netval	*)
(*	uses the zero checksum from the disk, so will not	*)
(*	update an empty block in the MUD during a consistency!	*)
      else (* result <> CUD_OPERATION_OK *)
        begin
	  status := CUD_ERROR (* bad CUD read, fake good blk to Supervisor *);
	  cud_buffer.checksum := mud_checksum;
	  status := CONSISTENCY_OK
	end (* result <> CUD_OPERATION_OK *)
    end (* last_un2_status = UN2_SUCCESSFUL *);

  if status = CONSISTENCY_OK
  then
    if mud_checksum = cud_buffer.checksum
    then
      begin (* checksum matched - tell UN2 *)
        un2_util.checksum_matched(last_un2_status);
	if last_un2_status <> UN2_SUCCESSFUL
	then status := UN2_ERROR;
	if first_mismatch <> NO_MISMATCH
	then
	  begin
	    report_mismatch(real_sup, first_mismatch, block - 1, no_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
);
	    first_mismatch := NO_MISMATCH
	  end (* first_mismatch <> NO_MISMATCH *)
      end (* checksum matched - tell UN2 *)
    else
      begin (* checksum does NOT match *)
        updated_block := TRUE	(* say we sent block *);
	if no_change
	then un2_util.checksum_matched(last_un2_status) (* fake a match *)
	else
	  begin	(* send CUD block to MUD *)
	    cud_status := CUD_ENTRY_OK;
	    cud_utility.cud_block_byte_count(cud_buffer.data, block,
	      cud_status, bytes_used);
	    (* include word of ZERO at end *)
	    word_count := mutil.word_count(bytes_used + MAXIMUM_BYTES_IN_WORD);
	    un2_util.send_consistency_block(block, word_count, cud_buffer,
	      retries, last_un2_status)
	  end (* send CUD block to MUD *);
	if last_un2_status <> UN2_SUCCESSFUL
	then status := UN2_ERROR;
	if first_mismatch = NO_MISMATCH (* is this first mismatch? *)
	then first_mismatch := block	(* yes, remember block *)
      end (* checksum does NOT match *);
  if status = CONSISTENCY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      mud_change.report_consistency_block(real_sup, block);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if block = CUD_BLOCK_LIMIT
      then
        begin
	  status := CONSISTENCY_DONE;
	  if first_mismatch <> NO_MISMATCH
	  then report_mismatch(real_sup, first_mismatch, CUD_BLOCK_LIMIT, no_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
)
	end
    end
  else
    if status <> UN2_ERROR
    then report_consistency_error(real_sup, block, status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
)
end (* next_consistency_block *);



(************************  consistency_handler  *************************)
(*									*)
(*			     stop_consistency				*)
(*									*)
(*     	Stop the consistency run.					*)
(*									*)
(************************************************************************)

procedure stop_consistency(
      real_sup  : real_supervisor_index;
      status	: consistency_status);

var
  pseudo_sup : pseudo_supervisor_index;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  stopped : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin (* stop_consistency *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  mud_change.translate_rs_to_ps(real_sup, pseudo_sup);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  aux_io.clear_circuit;
  un2_access[pseudo_sup].release_circuit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  stopped := status = CONSISTENCY_STOPPED;
  mud_change.report_consistency_over(real_sup, stopped);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* stop_consistency *);



(************************  consistency_handler  *************************)
(*									*)
(*			make_end_of_consistency_message			*)
(*									*)
(************************************************************************)

procedure make_end_of_consistency_message(
      block	: cud_block_index;
      status	: consistency_status);

begin
  format.start;
  if status = UN2_ERROR
  then
    with aux_io.param do
      format.un2_sup_error(last_un2_status, status, arg2, block)
  else format.consistency_error(block, status)
end (* make_end_of_consistency_message *);
!		
"
		Validator Routines
"



(************************  consistency_handler  *************************)
(*									*)
(*			  validator_consistency				*)
(*									*)
(*      Perform a consistency initiated by a validator at a		*)
(*	user_terminal (from a the validation_commands Class); check	*)
(*	the terminal after each block and stop if sendable is		*)
(*	FALSE; report summary of errors to the user_terminal.		*)
(*									*)
(************************************************************************)

procedure entry VALIDATOR_CONSISTENCY(
      real_sup          : real_supervisor_index;
      start_block	: cud_block_index;
     this_user		: validator_profile;
      user_terminal	: circuit_handler;
      no_change		: boolean);

var
  status         : consistency_status;
  block          : cud_block_index;
  first_mismatch : integer;
  retries        : integer;
  blocks_sent    : integer;
  line_length    : integer;
  updated_block  : boolean;

begin (* validator_consistency *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if not mutil.legal_consistency(real_sup)
  then user_terminal.write_quoted_text(
    'cannot run consistency on NETVAL system\')
  else
    begin (* legal validator consistency *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block := 0 (* in case START fails, no block number will be reported *);
      start_consistency(
       no_change, TRUE,
        real_sup, start_block);
      if last_un2_status <> UN2_SUCCESSFUL
      then status := UN2_ERROR
      else
	begin (* move consistency blocks *)
          oper_messages.report_validator_sup_message(this_user, real_sup,
	    CONSISTENCY_OPLOG_MSG);
          block := start_block; retries := 0; blocks_sent := 0;
	  first_mismatch := NO_MISMATCH;
	  line_length := 0;
	  user_terminal.write_quoted_text_line(CONSISTENCY_STARTED_MESSAGE);
	  repeat
	    next_consistency_block(real_sup, block, no_change,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    first_mismatch, status, updated_block, retries);
	    user_terminal.check_circuit;
	    if status = CONSISTENCY_OK
	    then
	      if not user_terminal.sendable
	      then status := CONSISTENCY_STOPPED
	      else
	        begin (* status ok and terminal sendable *)
	          if updated_block
		  then blocks_sent := blocks_sent + 1;
		  if ((block-start_block+1) mod CONSISTENCY_REPORT_INTERVAL)
		    = 0
		  then
		    begin (* time to send a user report *)
		      format.report_progress(user_terminal, block,
		        		blocks_sent, retries, line_length);
		      retries := 0;
		      blocks_sent := 0
		    end (* time to send a user report *);
		  block := block + 1 (* next block to work on *)
		end (* status ok and terminal sendable *)
	  until (status <> CONSISTENCY_OK) or not user_terminal.sendable;
	  if ((block-start_block+1) mod CONSISTENCY_REPORT_INTERVAL) <> 0
	  then format.report_progress(user_terminal, block, blocks_sent,
	      retries, line_length);
	  stop_consistency(real_sup, status);
	end (* move consistency blocks *);
      user_terminal.write_newline;
      make_end_of_consistency_message(block, status);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      oper_messages.report_supervisor_message(real_sup, CONSISTENCY_OPLOG_MSG);
      format.string(SUPERVISOR_MESSAGE);
      format.sup_number(real_sup);
      format.write_line(user_terminal)
      end (* legal validator consistency *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* validator_consistency *);
!
"
		Automatic Consistency Routines
"



(************************  consistency_handler  *************************)
(*									*)
(*			automatic_consistency				*)
(*									*)
(*      Perform an automatic consistency.				*)
(*									*)
(************************************************************************)

procedure entry AUTOMATIC_CONSISTENCY(
      real_sup          : real_supervisor_index;
      start_block	: cud_block_index);

var
  block : cud_block_index;
  first_mismatch : integer;
  retries : integer;
  updated_block : boolean;
  status : consistency_status;
  
begin
  block := start_block;
  last_un2_status := UN2_SUCCESSFUL;
  start_consistency(FALSE, FALSE, real_sup, block);
  if last_un2_status = UN2_SUCCESSFUL
  then
    begin (* last_un2_status = successfull *)
      oper_messages.report_supervisor_message(real_sup,
	CONSISTENCY_OPLOG_MSG);
      retries := 0; first_mismatch := NO_MISMATCH;
      repeat
        next_consistency_block(real_sup, block, FALSE, first_mismatch, status,
	  updated_block, retries);
	if status = CONSISTENCY_OK
	then
	  if mud_change.check_consistency_stop(real_sup)
	  then status := CONSISTENCY_STOPPED
	  else block := block + 1 (* block to be working on *)
      until status <> CONSISTENCY_OK;
      stop_consistency(real_sup, status);
      make_end_of_consistency_message(block, status);
      oper_messages.report_supervisor_message(real_sup, CONSISTENCY_OPLOG_MSG)
    end  (* last_un2_status = successfull *)
end (* automatic_consistency *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init sys_io
end (* consistency_handler *);
!
(************************************************************************)
(*									*)
(*	PRMUTL.NTV							*)
(*									*)
(*		       cud_parameter_file_utility			*)
(*									*)
(*    This class does conversions between UUNS and their bit map	*)
(*    locations and all reads and writes of the CUD_PARAMETER_FILE.	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	13Dec84 - Version 3.00 - neb - pgl				*)
(*		Original -- pgl						*)
(*									*)
(************************************************************************)


type CUD_PARAMETER_FILE_UTILITY = class(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oper_messages	: operator_messages;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	sys_io		: system_handler;
	format		: internal_to_string);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
var
  uun_file : file_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  cud_parameter_file_utility  *******************)
(*									*)
(*				do_read_page				*)
(*									*)
(*	Reads a page from the cud_parameter file (UUN, add_back or temp	*)
(*	part of the file) and outputs cud_parameter status to user or	*)
(*	oplog, if error.						*)	
(*									*)
(************************************************************************)

procedure do_read_page(
      page_no	: univ cud_parameter_page_index;
  var data	: univ page_record;
  var success	: boolean);

var
  status : cud_parameter_status;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  io_status : file_utility_status;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  status := CUD_PARAMETER_OK;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  uun_file.read_random(TRUE, page_no, data, io_status);
  case io_status of
    FU_SUCCESS: (* null *);
    FU_IO_ERROR: status := CUD_PARAMETER_IO_ERROR;
    FU_CHECKSUM_ERROR: status := CUD_PARAMETER_BAD_CHECKSUM
  end (* case *);
  success := io_status = FU_SUCCESS;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* do_read_page *);



(*********************  cud_parameter_file_utility  *********************)
(*									*)
(*			      read_header				*)
(*									*)
(*      Reads header page and prints cud_parameter status to user	*)
(*	or oplog, if error.						*)
(*									*)
(************************************************************************)

procedure entry READ_HEADER(
  var header_data	: univ cud_parameter_header;
  var success		: boolean);

begin
  do_read_page(CUD_PARAMETER_HEADER_PAGE, header_data, success)
end (* read_header *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(***********************  cud_parameter_file_utility  *******************)
(*									*)
(*				do_write_page				*)
(*									*)
(*	Writes a page to the cud_parameter file (UUN, add_back or temp	*)
(*	part of the file) and outputs cud_parameter_status to user or	*)
(*	oplog, if error.						*)
(*									*)
(************************************************************************)

procedure do_write_page(
      page_no	: univ cud_parameter_page_index;
  var data	: univ page_record;
  var success	: boolean);

var
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  io_status : file_utility_status;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  uun_file.write_random(TRUE, page_no, data, io_status);
  success := io_status = FU_SUCCESS;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* do_write_page *);



(*********************  cud_parameter_file_utility  *********************)
(*									*)
(*			      write_header				*)
(*									*)
(*      Writes header page and prints cud_parameter status to user or	*)
(*	oplog, if error.						*)
(*									*)
(************************************************************************)

procedure entry WRITE_HEADER(
  var header_data	: univ cud_parameter_header;
  var success		: boolean);

begin
  do_write_page(CUD_PARAMETER_HEADER_PAGE, header_data, success)
end (* write_header *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init uun_file(CUD_PARAMETER_FILE, statistics, file_system,
    oper_messages, format)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* cud_parameter_file_utility *);
!
(************************************************************************)
(*									*)
(*	cudprm.ntv							*)
(*									*)
(*			cud_parameter_controller			*)
(*									*)
(*	This monitor controls the assignment of GANs and UUNs.		*)
(*									*)
(************************************************************************)
(*									*)
(*                         Revision Record                              *)
(*									*)
(*	10Mar86 - jrn							*)
(*	      - add regen_add_back_file procedure			*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	28Nov84 - Version 3.00 - neb					*)
(*	      - add conditional code reuse_uuns to maintain uun_cache	*)
(*		of available UUNs which are added to the uun_cache	*)
(*		by the UUN_SUPPLIER process				*)
(*	26Nov84 - Version 3.00 - pgl				        *)
(*	      - add conditional assembly parameter reuse_uuns	        *)
(*		to set_parameters				        *)
(*	      - add init_uun_file					*)
(*	14Oct84 - Version 3.00 - pgl				        *)
(*	      - add conditional assembly parameter LOGICAL_VOLUMES	*)
(*	09Aug84 jrn							*)
(*	      - add disk_maintenance routines from INIT.NTI		*)
(*	      - use engine checksum for disk				*)
(*	20Jun84 - jrn							*)
(*	      - add disk_maintenance_code assembly parameter		*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
type CUD_PARAMETER_CONTROLLER = monitor(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oplog		: operator_log;
	cud_access	: cud_access_controller);



(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



var
  crash_util : crash_utility;
  sys_io : system_handler;
  format : internal_to_string;
  param_file : cud_parameter_file_utility;
  oper_messages : operator_messages;

(* the next GAN and UUN to be assigned *)
(* should always match the disk        *)

  next_gan : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  next_uun : uun_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  cud_parameter_controller  ***********************)
(*									*)
(*				initialize				*)
(*									*)
(*      Read the cud_parameter_block_number to retrieve the current	*)
(*	values of the permanent variables (called at initialization	*)
(*	time and when CUD file is restored from disk).			*)
(*									*)
(************************************************************************)

procedure initialize;

var
  success : boolean;
  header : cud_parameter_header;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  param_file.read_header(header, success);
  if success
  then
    begin
      next_gan := header.next_gan;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      next_uun := header.next_uun
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
  else crash_util.halt_slot
end (* initialize *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  cud_parameter_controller  *********************)
(*									*)
(*				write_parameters			*)
(*									*)
(*	Write cud_parameter_header to disk.			        *)
(*									*)
(************************************************************************)

procedure write_parameters;

var
  header : cud_parameter_header;
  success : boolean;

begin
  header.next_gan := next_gan;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  header.next_uun := next_uun;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  param_file.write_header(header, success);
  if not success
  then crash_util.halt_slot
end (* write_parameters *);



(*********************  cud_parameter_controller  ***********************)
(*									*)
(*				assign_one				*)
(*									*)
(*      If the value is zero, set it to next_value, increment		*)
(*	next_value by one, and set assigned_value to TRUE.		*)
(*									*)
(************************************************************************)

procedure assign_one(
  var value		: univ integer;
  var next_value	: univ integer;
  var assigned_value	: boolean);

begin
  if value = 0
  then
    begin
      assigned_value := TRUE;
      value := next_value;
      next_value := next_value + 1
    end
end (* assign_one *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  cud_parameter_controller  ***********************)
(*									*)
(*			    assign_user_numbers				*)
(*									*)
(*      Assign and return the next GAN and/or UUN.			*)
(*									*)
(************************************************************************)

procedure entry ASSIGN_USER_NUMBERS(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var gan	: integer;
  var uun	: uun_index;
  var result	: cud_operation_result);

var
  assigned_value : boolean;

begin
  if cud_access.current_access_state = FILE_LOCKED
  then result := CUD_FILE_LOCKED
  else
    begin
      result := CUD_OPERATION_OK;
      assigned_value := FALSE;
      assign_one(gan, next_gan, assigned_value);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      assign_one(uun, next_uun, assigned_value);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if assigned_value
      then write_parameters
    end
end (* assign_user_numbers *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    *)



(*********************  cud_parameter_controller  ***********************)
(*									*)
(*			     next_gan_and_uun				*)
(*									*)
(*      Return the current values of the next GAN and UUN to be		*)
(*	assigned from the variables next_gan and next_uun.		*)
(*									*)
(************************************************************************)

procedure entry NEXT_GAN_AND_UUN(
  var gan			: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   var uun			: uun_index);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  gan := next_gan;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  uun := next_uun
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* next_gan_and_uun *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init crash_util, sys_io, format, oper_messages(oplog, format),
    param_file(statistics, file_system, oper_messages, sys_io, format);

  initialize
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* cud_parameter_controller *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

!
(************************************************************************)
(*									*)
(*	NAMACC.NTV							*)
(*									*)
(*			cud_name_controller				*)
(*									*)
(*	This monitor controls access to specific CUD names.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  username_string, password_only_validator_index,		*)
(*	  licensed_validator_index					*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	08Feb85 - jrn							*)
(*	      - change index for entry_access to include master users	*)
(*		if netval_is_a_slave (non_password_only_validator_index)*) 
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type CUD_NAME_CONTROLLER = monitor;


type
  entry_access_information = record
    current_entry,
    new_entry : username_string
  end (* entry_access_information *);


var
  mutil : misc_utility;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* entry access information for password only users *)
(* if no entry is locked, size of string is zero *)

  password_only_entry_access : array [password_only_validator_index] of
    username_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(* entry access information *)
(* if no entry is locked, current_entry.size *)
(* and new_entry.size are zero *)

  entry_access : array [non_password_only_validator_index] of
    entry_access_information;
!
(************************  cud_name_controller  *************************)
(*									*)
(*			      initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 pi : password_only_validator_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  npi : non_password_only_validator_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  for pi := FIRST_PASSWORD_ONLY_VALIDATOR to PASSWORD_ONLY_VALIDATOR_LIMIT do
    password_only_entry_access[pi].size := 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  for npi := FIRST_NON_PASSWORD_ONLY_VALIDATOR to
    LAST_NON_PASSWORD_ONLY_VALIDATOR do
    begin
      entry_access[npi].current_entry.size := 0;
      entry_access[npi].new_entry.size := 0
    end
end (* initialize *);
!
(************************  cud_name_controller  *************************)
(*									*)
(*				  locked				*)
(*									*)
(*      Return TRUE if name_to_check is already locked.			*)
(*									*)
(************************************************************************)

function LOCKED(
      name_to_check	: username_string) : boolean;

var
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  pi : password_only_validator_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  npi : licensed_validator_index;
  match_found : boolean;

begin
  match_found := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  for pi := FIRST_PASSWORD_ONLY_VALIDATOR to PASSWORD_ONLY_VALIDATOR_LIMIT do
    if mutil.username_match(password_only_entry_access[pi], name_to_check)
    then match_found := TRUE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if not match_found
  then
    for npi := FIRST_NON_PASSWORD_ONLY_VALIDATOR to
      LAST_NON_PASSWORD_ONLY_VALIDATOR do
      if mutil.username_match(entry_access[npi].current_entry,name_to_check) or
         mutil.username_match(entry_access[npi].new_entry, name_to_check) 
      then match_found := TRUE;
  locked := match_found
end (* locked *);
!
"
		External Routines
"


(************************  cud_name_controller  *************************)
(*									*)
(*				lock_cud_entry				*)
(*									*)
(*      Lock the username; if entry_is_new, lock new_entry, else	*)
(*	lock current_entry.						*)
(*									*)
(************************************************************************)

procedure entry LOCK_CUD_ENTRY(
      caller		: validator_index;
      entry_to_lock	: username_string;
      entry_is_new	: boolean;
  var success		: boolean);

begin
  success := not locked(entry_to_lock);
  if success
  then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    if caller <= PASSWORD_ONLY_VALIDATOR_LIMIT
    then password_only_entry_access[caller] := entry_to_lock
    else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if entry_is_new
      then entry_access[caller].new_entry := entry_to_lock
      else entry_access[caller].current_entry := entry_to_lock
end (* lock_cud_entry *);



(************************  cud_name_controller  *************************)
(*									*)
(*			    unlock_cud_entry				*)
(*									*)
(*      Make locked entry available.					*)
(*									*)
(************************************************************************)

procedure entry UNLOCK_CUD_ENTRY(
      caller		: validator_index;
      entry_to_unlock	: username_string);

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if caller <= PASSWORD_ONLY_VALIDATOR_LIMIT
  then password_only_entry_access[caller].size := 0
  else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    if mutil.username_match(entry_access[caller].current_entry,
         entry_to_unlock)
    then entry_access[caller].current_entry.size := 0
    else entry_access[caller].new_entry.size := 0
end (* unlock_cud_entry *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil;

  initialize
end (* cud_name_controller *);
!
(************************************************************************)
(*									*)
(*	CUDENT.NTV							*)
(*									*)
(*			    cud_entry_updater				*)
(*									*)
(*	This Class performs all CUD entry functions.			*)
(*									*)
(*      The routines are organized as follows:				*)
(*		miscellaneous internal routines				*)
(*		CUD value location functions				*)
(*		CUD block routines					*)
(*		general value retrieval routines			*)
(*		CUD value retrieval routines				*)
(*		CUD entry location routines				*)
(*		general value storage routines				*)
(*		CUD entry storage routines				*)
(*		external routines					*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  username_string, username_text_size, cud_block_index,		*)
(*	  cud_data_size, cud_user_entry					*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	05Nov86 - neh							*)
(*	      - Add check for legal_name in check_for_name_in_cud	*)
(*	09Sep86 - neh							*) 
(*	      - Change update_block to not format the operator log	*)
(*		message and to call oper_messages.report_modify_message.*)
(*	03Spe86 - jrn							*)
(*	      - allow SET GFD ONLY and CHANGE UUN AND GAN CUD changes	*)
(*		available if not Tymshare CUD format (for BUBBNET)	*)
(*	08Jul86 - jrn							*)
(*	      - add oplog_remark					*)
(*	      - add SPECIAL flag (CLEAN (mudslide) command; add a	*)
(*		message to the operator log specifying the block that	*)
(*		the user is being deleted from and add			*)
(*		DELETE_MUD_SLIDE_ENTRY routine)				*)
(*	21Jul86 - jrn							*)
(*	      - add CUD_PASSWORD routine to check for programmer's	*)
(*		passwords when logging in thru auxilliary circuits	*)
(*	18Jul86 - jrn							*)
(*	      - add CUD_ENTRY_IN_WRONG_BLOCK error return in		*)
(*		NEXT_CUD_LIST routine					*)
(*	18Jul86 - neh							*)
(*	      - correct calculation of change_size in update_options    *)
(*		if password_changed					*)
(*	08May86 - jrn							*)
(*	      - remove separate handling of delete user and remove user	*)
(*	30Apr86 - jrn							*)
(*	      - remove reset_tymnet_cud routine				*)
(*	26Feb86 - jrn							*)
(*	      - add DISK_LOAD_TEST flags				*)
(*	21Jan86 - jrn							*)
(*	      - use internal_to_string BY_VALIDATOR procedure		*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	13Nov84 - jrn							*)
(*	      - change VALID_CUD_NAME function to CHECK_FOR_NAME_IN_CUD	*)
(*		procedure						*)
(*	17Jul85 - jrn							*)
(*	     - add NVDM COMPARE code					*)
(*	11Dec84 - neb							*)
(*	      - Add bit17_flag to add_new_entry and new_cud_entry	*)
(*		for call to assign_user_number.				*)
(*	      - change call to assign_user_number.			*)
(*	      - make changes for TYMCOM_IX slave and updating the 	*)
(*		TYMCOM luds if update_tymcom_luds and change format 	*)
(*		the CUD for TYMSHARE_CUD_FORMAT.			*)
(*	08Mar85 - jrn - Version 2.03					*)
(*	      - fixed a bug that caused the wrong block number to be	*)
(*		displayed to the validator when an error is		*)
(*		detected in the CUD					*)
(*	16Aug84 - jrn							*)
(*	      - fix bug in store_profile procedure: if the entry ended	*)
(*		with a full word of 0FFFFFFFF, and the entry was	*)
(*		getting smaller in size, the last half word of 0FFFF	*)
(*		was not being cleared in the MUD (change_size was not	*)
(*		computed properly)					*)
(*	02Aug84 - jrn							*)
(*	      - fix bug in change control command			*)
(*	15Jun84	jrn							*)
(*	      - add disk_maintenance_code assembly parameter		*)
(*	      - remove stuff for RESTORE				*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added AUDITOR, OPERATOR control bits			*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - removed unused variables				*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


const
(* CUD users are VALIDATORS (identified by their validator_index),	*)
(* who may read and update CUD entries, or various other processes	*)
(* which may only read CUD entries, and therefore do not have to lock	*)
(* blocks.  The "other processes" currently consists of the accept_login*)
(* process.								*)

  CUD_READER = first_validator - 1;

type
  CUD_USER_INDEX = cud_reader..validator_limit;


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



type
 CUD_ENTRY_UPDATER = class(
	cud_user	: cud_user_index;
	mutil		: misc_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	format		: internal_to_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	login_pool	: login_distributer;
	mud_change	: mud_change_handler;
	oper_messages	: operator_messages;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	cud_utility	: cud_entry_utility;
	cud_access	: cud_access_controller;
	block_updater	: cud_block_updater;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	param_manager	: cud_parameter_controller;
	name_access	: cud_name_controller);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


type
  NAME_DESCRIPTOR = record
    name		: username_string;
    name_locked		: boolean (* TRUE if name is locked *);
    packed_name_size	: username_text_size;
    block		: cud_block_index
  end (* name_descriptor *);


  CUD_ENTRY_DESCRIPTOR = record
    user	    	: name_descriptor (* name, name size and block no. *);
    block_locked	: boolean	(* TRUE if block is locked *);
    pointer		: cud_data_index(* ptr. to entry in CUD block *);
    size		: cud_data_size	(* packed entry size (bytes) *)
  end (* cud_entry_descriptor *);


var
  calendar : date_time_converter;


(*	The user being modified:		 *)
(* The class assumes that higher levels will     *)
(* always call MODIFY_CUD_ENTRY, then an update, *)
(* delete, rename or abort routine.              *)

  modify_user : name_descriptor;


(* 	The new name (used in new user and rename):	*)
(* The class assumes that higher levels will always	*)
(* call RESERVE_CUD_NAME, then a rename, new or abort	*)
(* routine.						*)

  new_user : name_descriptor;


(* The next pointer and block to be used for	*)
(* listing purposes; start_cud_list must be	*)
(* called to initialize these values.		*)

  listing_pointer : cud_data_index;

  listing_block   : cud_block_index;


(*	The status of the last operation:	*)

  entry LAST_STATUS : cud_entry_result;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(* Set up when entering an external CUD change routine. RENAME_CUD_ENTRY*)
(* first sets it to RENAME_DELETE_USER_CUD_CHANGE until after the old	*)
(* name is deleted, then sets it to RENAME_NEW_USER_CUD_CHANGE; if the	*)
(* old name must be returned, it is set to RENAME_RESTORE_OLD_NAME.	*)

  cud_change_type : cud_change_indicator;


(* message to be appended to operlog change cud messages...set by	*)
(* SET_OPLOG_REMARK if netval_is_a_slave, and the REMARK command	*)

  oplog_remark : oplog_remark_message;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		Miscellaneous Internal Routines
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			  get_next_name_character			*)
(*									*)
(*      Return the next name character, incrementing name_pointer.	*)
(*									*)
(************************************************************************)

procedure get_next_name_character(
      name		: username_string;
  var name_pointer	: username_text_index;
  var name_char		: char);

begin
  if name_pointer < name.size
  then
    begin
      name_char := name.text[name_pointer];
      name_pointer := name_pointer + 1
    end
end (* get_next_name_character *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				next_name_word				*)
(*									*)
(*      Return the next three characters from the user name,		*)
(*	right justified in a word; increment name_pointer		*)
(*	as appropriate.							*)
(*									*)
(************************************************************************)

procedure next_name_word(
      name		: username_string;
  var name_pointer	: username_text_index;
  var name_word		: univ word_in_bytes);

begin
  get_next_name_character(name, name_pointer, name_word[1]);
  get_next_name_character(name, name_pointer, name_word[2]);
  get_next_name_character(name, name_pointer, name_word[3])
end (* next_name_word *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			target_profile_format				*)
(*									*)
(*	Return TRUE if name may be target profile format string, i.e.,	*)
(*	is at least 5 characters long, and starts with Gnnnn, where	*)
(*	n = a digit.							*)
(*									*)
(************************************************************************)

function target_profile_format(
      name	: username_string) : boolean;

var
  index : username_text_index;

begin
  target_profile_format := TRUE;
  if name.size < 5
  then target_profile_format := FALSE
  else
    if name.text[0] <> 'G'
    then target_profile_format := FALSE
    else
      for index := 1 to 4 do
        if not mutil.decimal_digit(name.text[index])
	then target_profile_format := FALSE
end (* target_profile_format *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				legal_name				*)
(*									*)
(*	Return TRUE if name is of the format Gnnnn or GnnnnT<anything>,	*)
(*	where n = a digit						*)
(*									*)
(************************************************************************)

function legal_name(
      name	: username_string) : boolean;

begin
  legal_name := TRUE;
  if target_profile_format(name)
  then
    if name.size = 5
    then legal_name := FALSE (* name is of form Gnnnn *)
    else
      if name.text[5] = 'T'
      then legal_name := FALSE (* name is GnnnnT... *)
end (* legal_name *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      hashed_block				*)
(*									*)
(*      Return the hashed CUD block number for the name.		*)
(*									*)
(************************************************************************)

function hashed_block(
      name	: username_string) : normal_cud_block_index;

var
  name_pointer : username_text_index;
  name_word,
  sum : integer;

begin
  name_pointer := 0; sum := 0;
  repeat
    name_word := 0;
    next_name_word(name, name_pointer, name_word);
    sum := sum + name_word
  until name_pointer >= name.size;
  hashed_block := (sum mod BIT7) mod MAXIMUM_NORMAL_CUD_BLOCK
end (* hashed_block *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			 set_up_mud_change_header			*)
(*									*)
(*      Save change information in change_header to be used to		*)
(*	write the current CUD change to the MUD_CHANGE_HANDLER.		*)
(*									*)
(************************************************************************)

procedure set_up_mud_change_header(
      change_block	: cud_block_index;
      change_offset	: cud_data_index;
      change_size	: cud_data_size;
  var change_header	: cud_change_header);

begin
  change_header.block := change_block;
  if (change_offset mod MAXIMUM_BYTES_IN_WORD) = 0
  then
    begin (* change is on a word boundry *)
      change_header.size := mutil.word_count(change_size);
      change_header.offset := change_offset div MAXIMUM_BYTES_IN_WORD
    end
  else
    begin (* adjust to word boundry *)
      change_header.size := mutil.word_count(change_size + 2);
      change_header.offset := (change_offset - 2) div MAXIMUM_BYTES_IN_WORD
    end
end (* set_up_mud_change_header *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   todays_password_date				*)
(*									*)
(*      Return the password change date for now.			*)
(*									*)
(************************************************************************)

function todays_password_date : integer;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  todays_password_date := REALTIME div SECONDS_PER_DAY
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* todays_password_date *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*************************  cud_entry_updater  **************************)
(*									*)
(*			    unlock_username				*)
(*									*)
(*      If the username described by name_info is locked, unlock it.	*)
(*									*)
(************************************************************************)

procedure unlock_username(
  var name_info	: name_descriptor);

begin
  if name_info.name_locked
  then
    begin
      name_access.unlock_cud_entry(cud_user, name_info.name);
      name_info.name_locked := FALSE
    end
end (* unlock_username *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      unlock_block				*)
(*									*)
(*      If the block described by entry_info is locked, unlock it.	*)
(*									*)
(************************************************************************)

procedure unlock_block(
  var entry_info	: cud_entry_descriptor);

begin
  if entry_info.block_locked
  then
    begin
      cud_access.unlock_cud_block(entry_info.user.block);
      entry_info.block_locked := FALSE
    end
end (* unlock_block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"	CUD Value Location Functions

    The following functions return locations in data of a CUD value,
    given entry_info [cud_entry_descriptor]; the location is computed from:
	- entry_info.pointer, which points to the beginning of the user entry
	- entry_info.user.packed_name_size, the size of the packed (stored)
	  username in the user entry
	- 'value OFFSET', the offset for the specific value desired
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      name_location				*)
(*									*)
(*      Return the location of the name in the entry described		*)
(*	by entry_info.							*)
(*									*)
(************************************************************************)

function name_location(
	entry_info : cud_entry_descriptor) : cud_data_index;

begin
  name_location := entry_info.pointer + USERNAME_OFFSET
end (* name_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    password_location				*)
(*									*)
(*	Return the location of the password in the entry described	*)
(*	by entry_info.							*)
(*									*)
(************************************************************************)

function password_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  password_location :=
    entry_info.pointer + entry_info.user.packed_name_size + PASSWORD_OFFSET
end (* password_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			entry_change_date_location			*)
(*									*)
(*      Return the location of the entry change date in the entry	*)
(*	described by entry_info.					*)
(*									*)
(************************************************************************)

function entry_change_date_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  entry_change_date_location := entry_info.pointer +
    entry_info.user.packed_name_size + ENTRY_CHANGE_DATE_OFFSET
end (* entry_change_date_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      gan_location				*)
(*									*)
(*      Return the location of the gan in the entry described		*)
(*	by entry_info.							*)
(*									*)
(************************************************************************)

function gan_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  gan_location :=
    entry_info.pointer + entry_info.user.packed_name_size + GAN_OFFSET
end (* gan_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      uun_location				*)
(*									*)
(*      Return the location of the uun in the entry described		*)
(*	by entry_info.							*)
(*									*)
(************************************************************************)

function uun_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  uun_location :=
    entry_info.pointer + entry_info.user.packed_name_size + UUN_OFFSET
end (* uun_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    options_location				*)
(*									*)
(*      Return the location of the option word  in the entry		*)
(*	described by entry_info.					*)
(*									*)
(************************************************************************)

function options_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  options_location :=
    entry_info.pointer + entry_info.user.packed_name_size + OPTIONS_OFFSET
end (* options_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    district_location				*)
(*									*)
(*      Return the location of the district in the entry described	*)
(*	by entry_info.							*)
(*									*)
(************************************************************************)

function district_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  district_location :=
    entry_info.pointer + entry_info.user.packed_name_size + DISTRICT_OFFSET
end (* district_location *);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*************************  cud_entry_updater  **************************)
(*									*)
(*			password_change_date_location			*)
(*									*)
(*      Return the location of the password change date in the		*)
(*	entry described by entry_info.					*)
(*									*)
(************************************************************************)

function password_change_date_location(
	entry_info : cud_entry_descriptor) : cud_data_index;

begin
  password_change_date_location := entry_info.pointer +
    entry_info.user.packed_name_size + PASSWORD_CHANGE_DATE_OFFSET
end (* password_change_date_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     profile_location				*)
(*									*)
(*      Return the location of the access profile in the entry		*)
(*	described by entry_info.					*)
(*									*)
(************************************************************************)

function profile_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  profile_location := entry_info.pointer +
    entry_info.user.packed_name_size + PROFILE_OFFSET
end (* profile_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			  last_halfword_location			*)
(*									*)
(*      Return the location of the last halfword of 0FFFF		*)
(*	described by entry_info.					*)
(*									*)
(************************************************************************)

function last_halfword_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  last_halfword_location := entry_info.pointer + entry_info.size - 2
end (* last_halfword_location *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			zero_terminator_location			*)
(*									*)
(*      Return the location of the zero word after the entry.		*)
(*									*)
(************************************************************************)

function zero_terminator_location(
      entry_info	: cud_entry_descriptor) : cud_data_index;

begin
  zero_terminator_location := entry_info.pointer + entry_info.size
end (* zero_terminator_location *);
!
"
		CUD Block Routines
"
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    set_access_status				*)
(*									*)
(*      Set last_status according to cud_access_status.			*)
(*									*)
(************************************************************************)

procedure set_access_status(
      result	: cud_access_status);

begin
  if result <> CUD_ACCESS_OK
  then
   if result = CUD_ACCESS_FILE_LOCKED
   then last_status := CUD_ENTRY_FILE_LOCKED
   else last_status := CUD_ENTRY_BLOCK_LOCKED
end (* set_access_status *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			  set_status_from_cud_io			*)
(*									*)
(*      Set last_status according to cud_operation_result.		*)
(*									*)
(************************************************************************)

procedure set_status_from_cud_io(
      result	: cud_operation_result);

begin
  if result <> CUD_OPERATION_OK
  then
    case result of
      CUD_FILE_LOCKED:		last_status := CUD_ENTRY_FILE_LOCKED;
      CUD_BLOCK_MANUALLY_LOCKED:last_status := CUD_ENTRY_BLOCK_LOCKED;
      CUD_CHECKSUM_ERROR:	last_status := CUD_ENTRY_BAD_CHECKSUM;
      CUD_OPERATION_FAILED:	last_status := CUD_ENTRY_OPERATION_FAILED
    end
end (* set_status_from_cud_io *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     read_cud_block				*)
(*									*)
(*      Input CUD data from the disk into data - do not lock the block.	*)
(*									*)
(************************************************************************)

procedure read_cud_block(
      block_number	: cud_block_index;
  var buffer		: cud_disk_block);

var
  result : cud_operation_result;

begin
  block_updater.read_cud_block(block_number, result, buffer);
  set_status_from_cud_io(result)
end (* read_cud_block *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				read_block				*)
(*									*)
(*      Input CUD data from the disk into buffer; if lock_block is	*)
(*	TRUE, and the block is not locked according to			*)
(*	entry_info.block_locked, lock the block before reading it;	*)
(*	if lock_block is FALSE, the block is already locked.		*)
(*									*)
(************************************************************************)

procedure read_block(
      lock_block	: boolean (* lock block *);
  var entry_info	: cud_entry_descriptor;
  var buffer		: cud_disk_block);

var
  result : cud_operation_result;

begin
  if lock_block and not entry_info.block_locked
  then
    begin
      block_updater.modify_cud_block(cud_user, entry_info.user.block,
        result, buffer);
      if result = CUD_OPERATION_OK
      then entry_info.block_locked := TRUE
      else set_status_from_cud_io(result)
    end
  else read_cud_block(entry_info.user.block, buffer)
end (* read_block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    notify_mud_change				*)
(*									*)
(*      Notify mud_change_handler of the CUD change to be made.		*)
(*									*)
(************************************************************************)

procedure notify_mud_change(
      change_header	: cud_change_header;
      data		: cud_data);

var
  cud_change : cud_change_information;
  bytes_to_save : cud_data_size;
  get_pointer,
  put_pointer : cud_data_index;
  done : boolean;
  ok : boolean;

begin
  cud_change.header := change_header;

(* Store the actual bytes of the CUD change into the change data. *)
  done := FALSE;
  bytes_to_save := (change_header.size * MAXIMUM_BYTES_IN_WORD);
  get_pointer := change_header.offset * MAXIMUM_BYTES_IN_WORD;
  put_pointer := 0;
  repeat
    cud_change.data[put_pointer] := data[get_pointer];
    if put_pointer = bytes_to_save - 1
    then done := TRUE
    else
      begin
        put_pointer := put_pointer + 1;
	get_pointer := get_pointer + 1
      end
   until done;
  mud_change.cud_change_in_progress(cud_user, cud_change, ok);
  if not ok
  then last_status := CUD_ENTRY_MUD_CHANGE_FILE_ERROR
end (* notify_mud_change *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      update_block				*)
(*									*)
(*      Notify mud_change_handler of the impending change, write the	*)
(*	CUD data to the disk; if the MUD change notification fails,	*)
(*	do not update the CUD.						*)
(*									*)
(************************************************************************)

procedure update_block(
      entry_info	: cud_entry_descriptor;
      change_header	: cud_change_header;
  var buffer		: cud_disk_block);

var
  result : cud_operation_result;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  change_name : username_string;
  this_user_name : username_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  notify_mud_change(change_header, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if last_status = CUD_ENTRY_OK
  then
    begin
      block_updater.update_cud_block(entry_info.user.block, buffer, result);
      set_status_from_cud_io(result) (* set last_status *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  if last_status = CUD_ENTRY_OK
	  then mud_change.confirm_cud_change
	  else mud_change.abort_cud_change;
      if last_status = CUD_ENTRY_OK
      then
        begin
	  if (cud_change_type = NEW_USER_CUD_CHANGE) or
	    (cud_change_type = RENAME_NEW_USER_CUD_CHANGE)
          then change_name := new_user.name
          else change_name := modify_user.name;
          login_pool.validator_name(cud_user, this_user_name);
          oper_messages.report_modify_message(this_user_name, cud_user,
      	    cud_change_type, change_name,
  	    oplog_remark)
        end (* last_status = CUD_ENTRY_OK *)
(*	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* last_status = CUD_ENTRY_OK *)
end (* update_block *);
!
"	General Value Retrieval Routines

    The routines in this Section are used to retrieve words, integers
and bytes from cud_data (a character array).
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    get_two_cud_bytes				*)
(*									*)
(*      Return the next two characters from data pointed to by		*)
(*	byte_pointer in cud_bytes.					*)
(*									*)
(************************************************************************)

procedure get_two_cud_bytes(
      data		: cud_data;
      byte_pointer	: cud_data_index;
  var cud_bytes		: univ word_in_bytes);

begin
  cud_bytes[0] := ZERO;
  cud_bytes[1] := ZERO;
  cud_bytes[2] := data[byte_pointer];
  cud_bytes[3] := data[byte_pointer + 1];
end (* get_two_cud_bytes *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			  pick_up_two_cud_bytes				*)
(*									*)
(*      Pick up the next two characters from data pointed to by		*)
(*	byte_pointer and increment byte_pointer past the bytes.		*)
(*									*)
(************************************************************************)

procedure pick_up_two_cud_bytes(
      data		: cud_data;
  var byte_pointer	: cud_data_index;
  var cud_bytes		: univ integer);

begin
  get_two_cud_bytes(data, byte_pointer, cud_bytes);
  byte_pointer := byte_pointer + 2
end (* pick_up_two_cud_bytes *);
!
"	CUD Value Retrieval Routines

    The routines in this Section are used to retrieve and unpack parts of a
cud_user_entry (name, password, dates, access profile, etc.).  Routines
from previous sections are used; entry_info describes the location of the
CUD entry in data being processed.
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    unpack_entry_name				*)
(*									*)
(*      Return the name from the CUD entry described by entry_info	*)
(*	in data.  This routine should be as fast as possible, since	*)
(*	it is called in searching CUD blocks.				*)
(*									*)
(************************************************************************)

procedure unpack_entry_name(
      entry_info	: cud_entry_descriptor;
      data		: cud_data;
  var name		: username_string);

var
  cud_pointer : cud_data_index;
  name_pointer : username_text_index;
  first_byte : char;
  count : integer;
  done : boolean;

begin
  cud_pointer := name_location(entry_info);
  name.size := 0;
  name_pointer := 0;
  done := FALSE;
  repeat
    first_byte := data[cud_pointer] (* get first byte of name word *);
    cud_pointer := cud_pointer + 1 (* and increment pointer *);
    if mutil.negative_byte(first_byte)
    then
      begin
        done := TRUE;
        name.text[name_pointer] := chr(ord(first_byte) - BIT24)
      end (* high order bit is ON in the byte *)
    else name.text[name_pointer] := first_byte;
    if name_pointer = USERNAME_TEXT_LIMIT
    then last_status := CUD_FORMAT_ERROR
    else name_pointer := name_pointer + 1;
    name.size := name.size + 1;
    for count := 1 to 3 do (* save rest of name word *)
      begin
        name.text[name_pointer] := data[cud_pointer] (* save next byte *);
        cud_pointer := cud_pointer + 1 (* and increment pointer *);
	if name.text[name_pointer] <> ZERO
	then (* if byte is non-zero, increment size and pointer *)
	  begin
	    name_pointer := name_pointer + 1;
	    name.size := name.size + 1;
	  end
      end (* for *);
    if not done
    then
      if (cud_pointer >= (CUD_DATA_LIMIT - MAXIMUM_BYTES_IN_WORD)) or
        (name.size >= USERNAME_TEXT_MAX) or (first_byte = ZERO)
      then
        begin
          cud_utility.set_format_error(entry_info.user.block,
	    entry_info.pointer, last_status);
	  done := TRUE
        end
  until done
end (* unpack_entry_name *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      unpack_origin				*)
(*									*)
(*      Pick up information about the in-place origin for the		*)
(*	access_entry; the number of bytes in the origin from data	*)
(*	is contained in size_word; increment profile_pointer as		*)
(*	bytes are picked up; decrement access_entry_bytes_left as	*)
(*	bytes are used; store origin hosts and nodes in origin.list	*)
(*	and count of entries in origin.size.				*)
(*									*)
(************************************************************************)

procedure unpack_origin(
      block_number		: cud_block_index;
      size_word			: integer;
      data			: cud_data;
  var profile_pointer		: cud_data_index;
  var access_entry_bytes_left	: cud_data_size;
  var origin			: in_place_origin_description);

var
  temp_word : integer;
  list_pointer : in_place_origin_index;

begin
  temp_word := (mutil.mask(size_word, IN_PLACE_ORIGIN_SIZE_MASK)) div 2;
  if temp_word <= MAXIMUM_IN_PLACE_ORIGIN
  then origin.size := temp_word
  else cud_utility.set_format_error(block_number, profile_pointer,last_status);
  if last_status = CUD_ENTRY_OK
  then
    begin
      for list_pointer := 0 to origin.size - 1 do
        with origin.list[list_pointer] do
    	  begin
	    pick_up_two_cud_bytes(data, profile_pointer, value);
	    if mutil.test_bit(ORIGIN_HOST_BIT, value)
	    then
	      begin
	        host_flag  := TRUE;
	        mutil.clear_bit(ORIGIN_HOST_BIT, value)
	      end (* for *);
	    access_entry_bytes_left := access_entry_bytes_left - 2
	  end (* for *)
    end (* last_status = CUD_ENTRY_OK *)
end (* unpack_origin *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   unpack_destination				*)
(*									*)
(*      Pick up information about the access entry destination;		*)
(*	increment profile_pointer as bytes are picked up; decrement	*)
(*	access_entry_bytes_left as bytes are used; store destination	*)
(*	hosts and groups in destination.list and count of entries	*)
(*	in destination.size; continue until access_entry_bytes_left	*)
(*	is zero.							*)
(*									*)
(************************************************************************)

procedure unpack_destination(
      block_number		: cud_block_index;
      data			: cud_data;
  var profile_pointer		: cud_data_index;
  var access_entry_bytes_left	: cud_data_size;
  var destination		: destination_description);

var
  list_pointer : destination_index;
  done : boolean;

begin
  list_pointer := 0;
  done := FALSE;
  repeat
    pick_up_two_cud_bytes(data, profile_pointer,
      destination.list[list_pointer].value);
    if mutil.test_bit(GROUP_BIT, destination.list[list_pointer].value)
    then
      begin
        destination.list[list_pointer].group_flag := TRUE;
        mutil.clear_bit(GROUP_BIT, destination.list[list_pointer].value)
      end (* value is a GROUP *);
    if mutil.test_bit(HOME_BIT, destination.list[list_pointer].value)
    then
      begin
        destination.list[list_pointer].home_flag := TRUE;
        mutil.clear_bit(HOME_BIT, destination.list[list_pointer].value)
      end (* value is a HOME *);
    destination.size := destination.size + 1;
    access_entry_bytes_left := access_entry_bytes_left - 2;
    if access_entry_bytes_left = 0
    then done := TRUE
    else
      if list_pointer < DESTINATION_LIMIT
      then list_pointer := list_pointer + 1
      else
        begin
	  done := TRUE;
	  cud_utility.set_format_error(block_number, profile_pointer,
	    last_status)
	end
  until done
end (* unpack_destination *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   unpack_access_entry				*)
(*									*)
(*      Return the next access entry from data pointed to by		*)
(*	profile_pointer, and increment profile_pointer over it.		*)
(*									*)
(************************************************************************)

procedure unpack_access_entry(
      block_number	: cud_block_index;
      data		: cud_data;
  var profile_pointer	: cud_data_index;
  var access_entry	: access_entry_description);

var
  two_bytes : integer;
  temp_word : integer;
  class_word : integer;
  access_entry_bytes : cud_data_size;

begin
(* get size of access entry *)
  pick_up_two_cud_bytes(data, profile_pointer, two_bytes);
  temp_word := mutil.right_shift(ACCESS_ENTRY_SIZE_LOCATION, two_bytes);
  if (temp_word < MAXIMUM_CUD_DATA) and ((temp_word mod 2) = 0)
  then access_entry_bytes := temp_word - 2
  else cud_utility.set_format_error(block_number, profile_pointer,last_status);
  if last_status = CUD_ENTRY_OK
  then
    begin
      if mutil.test_bit(EXCEPTION_BIT, two_bytes)
      then access_entry.exception := TRUE;
      if mutil.test_bit(IN_PLACE_BIT, two_bytes)
      then
        begin
	   access_entry.in_place_origin := TRUE;
	   unpack_origin(block_number, two_bytes, data, profile_pointer,
	     access_entry_bytes, access_entry.origin)
	end (* origin is IN-PLACE *)
      else
        begin (* origin is a CLASS *)
	  class_word := mutil.mask(two_bytes, USER_CLASS_MASK);
	  if class_word <= MAXIMUM_CLASS
	  then access_entry.class_no := class_word
	  else cud_utility.set_format_error(block_number, profile_pointer,
	    last_status)
	end (* origin is a CLASS *);
      unpack_destination(block_number, data, profile_pointer,
        access_entry_bytes, access_entry.destination)
    end (* last_status = CUD_ENTRY_OK *)
end (* unpack_access_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    unpack_options				*)
(*									*)
(************************************************************************)

procedure unpack_options(
      entry_info	: cud_entry_descriptor;
      data		: cud_data;
  var options		: user_options);

var
  save_ptr : cud_data_index;
  temp_word : integer (* word from user entry *);

begin
  save_ptr := options_location(entry_info);
  mutil.save_characters_in_word(data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], temp_word);
  cud_utility.unpack_options(temp_word, options)
end (* unpack_options *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			  unpack_password_date				*)
(*									*)
(************************************************************************)

procedure unpack_password_date(
      entry_info	: cud_entry_descriptor;
      data		: cud_data;
  var password_date	: integer);

var
  save_ptr : cud_data_index;

begin
  save_ptr := password_change_date_location(entry_info);
  mutil.save_characters_in_word(ZERO, data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], password_date)
end (* unpack_password_date *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    unpack_change_date				*)
(*									*)
(************************************************************************)

procedure unpack_change_date(
      entry_info	: cud_entry_descriptor;
      data		: cud_data;
  var entry_date	: integer);

var
  save_ptr : cud_data_index;

begin
  save_ptr := entry_change_date_location(entry_info);
  mutil.save_characters_in_word(data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], entry_date)
end (* unpack_change_date *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    unpack_cud_cipher				*)
(*									*)
(*      Unpack the entry in data described by entry_pointer		*)
(*	into cud_entry.							*)
(*									*)
(************************************************************************)

procedure unpack_cud_cipher(
      entry_info	: cud_entry_descriptor;
      data		: cud_data;
  var old_cipher	: integer);

var
  save_ptr : cud_data_index;

begin
  save_ptr := password_location(entry_info);
  mutil.save_characters_in_word(data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], old_cipher)
end (* unpack_cud_cipher *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			       unpack_gan				*)
(*									*)
(************************************************************************)

procedure unpack_gan(
      entry_info	: cud_entry_descriptor;
      data		: cud_data;
  var gan		: integer);

var
  save_ptr : cud_data_index;

begin
  save_ptr := gan_location(entry_info);
  mutil.save_characters_in_word(data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], gan)
end (* unpack_gan *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    unpack_cud_entry				*)
(*									*)
(*      Unpack the entry in data described by entry_pointer		*)
(*	into cud_entry.							*)
(*									*)
(************************************************************************)

procedure unpack_cud_entry(
      entry_info	: cud_entry_descriptor;
      data		: cud_data;
  var cud_entry		: cud_user_entry);

var
  save_ptr : cud_data_index;
  temp_word : integer (* word from user entry *);
  access_profile_index : access_entry_index;
  done : boolean;

begin
(* unpack password *)
  unpack_cud_cipher(entry_info, data, cud_entry.password);

(* unpack entry change date *)
  unpack_change_date(entry_info, data, cud_entry.entry_change_date);

(* unpack gan *)
  unpack_gan(entry_info, data, cud_entry.gan);

(* unpack uun *)
  save_ptr := uun_location(entry_info);
  mutil.save_characters_in_word(data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], cud_entry.uun);

(* unpack options *)
  unpack_options(entry_info, data, cud_entry.options);

(* unpack district *)
  save_ptr := district_location(entry_info);
  mutil.save_characters_in_word(data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], temp_word);
  cud_entry.district := mutil.mask(temp_word, DISTRICT_MASK);

(* unpack password change date *)
  unpack_password_date(entry_info, data, cud_entry.password_change_date);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(* unpack access profile *)
  save_ptr := profile_location(entry_info);
  cud_utility.clear_access_profile(cud_entry.access_profile);
  access_profile_index := 0;
  done := FALSE;
  repeat
    get_two_cud_bytes(data, save_ptr, temp_word);
    if temp_word <> CUD_ENTRY_TERMINATOR
    then
      begin
        unpack_access_entry(entry_info.user.block, data, save_ptr,
          cud_entry.access_profile.entries[access_profile_index]);
        if last_status = CUD_ENTRY_OK
        then
          begin
	    access_profile_index := access_profile_index + 1;
	    cud_entry.access_profile.count :=
	      cud_entry.access_profile.count + 1
	  end
	else done := TRUE
      end
    else done := TRUE
  until done;
  if (last_status = CUD_ENTRY_OK) and (cud_entry.access_profile.count = 0)
  then cud_utility.set_format_error(entry_info.user.block,save_ptr,last_status)
end (* unpack_cud_entry *);
!
"	CUD Entry Location Routines

    The routines in this Section are used to locate entries in a CUD
block, find the end of data in a CUD block, and return a CUD user entry.
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   packed_size_of_name				*)
(*									*)
(*      Return the size of the name packed into words.			*)
(*									*)
(************************************************************************)

function packed_size_of_name(
     entry_name	: username_string) : username_text_size;

begin
  packed_size_of_name :=
    mutil.word_count(entry_name.size) * MAXIMUM_BYTES_IN_WORD
end (* packed_size_of_name *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     next_cud_entry				*)
(*									*)
(*      Return the entry_name, entry_info.size and			*)
(*	entry_info.user.packed_name_size of the entry in data		*)
(*	pointed to by entry_info.pointer; set entry_found to		*)
(*	FALSE if the end of the CUD information is found.		*)
(*									*)
(************************************************************************)

procedure next_cud_entry(
      data		: cud_data;
  var entry_name	: username_string;
  var entry_info	: cud_entry_descriptor);

begin
  cud_utility.set_entry_size(data, entry_info.pointer, entry_info.user.block,
    last_status, entry_info.size);
  if last_status = CUD_ENTRY_OK
  then unpack_entry_name(entry_info, data, entry_name);
  if last_status = CUD_ENTRY_OK
  then entry_info.user.packed_name_size := packed_size_of_name(entry_name)
end (* next_cud_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     find_user_entry				*)
(*									*)
(*      Find a user's CUD entry, given entry_info.user information.	*)
(*	If lock_block is TRUE, lock the block.				*)
(*	This routine is separate from locate_name because the hash	*)
(*	should not be repeated unless necessary (used by locate_name,	*)
(*	delete_entry, all external update_x routines).			*)
(*									*)
(************************************************************************)

procedure find_user_entry(
      lock_block	: boolean (* lock block and leave it locked *);
  var buffer		: cud_disk_block;
  var entry_info	: cud_entry_descriptor);

var
  name_found : boolean;
  entry_name : username_string;

begin
  read_block(lock_block, entry_info, buffer);
  if last_status = CUD_ENTRY_OK
  then
    begin

(*      Scan buffer.data for entry_info.user.name; if not found, set	*)
(*	name_found to FALSE; otherwise, set name_found to TRUE,		*)
(*	and set up the rest of the entry_info information (size,	*)
(*	pointer and user.packed_name_size).				*)

      entry_info.pointer := 0;
      name_found := FALSE;
      repeat
        next_cud_entry(buffer.data, entry_name, entry_info);
        if last_status = CUD_ENTRY_OK
	then
	  if mutil.username_match(entry_name, entry_info.user.name)
	  then name_found := TRUE
	  else cud_utility.increment_entry_pointer(entry_info.user.block,
	    entry_info.size, last_status, entry_info.pointer);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
      until (last_status <> CUD_ENTRY_OK) or name_found
    end
end (* find_user_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				locate_name				*)
(*									*)
(*      Locate a user's CUD entry; set up entry_info (used by		*)
(*	get_name_entry, valid_cud_name and reserve_name routines).	*)
(*									*)
(************************************************************************)

procedure locate_name(
  var buffer		: cud_disk_block;
  var entry_info	: cud_entry_descriptor);

begin
  entry_info.user.block := hashed_block(entry_info.user.name);
  find_user_entry(FALSE, buffer, entry_info)
end (* locate_name *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     get_name_entry				*)
(*									*)
(*      Find and return a user's CUD entry (used by read_cud_entry	*)
(*	and modify_cud_entry routines).					*)
(*									*)
(************************************************************************)

procedure get_name_entry(
  var buffer		: cud_disk_block;
  var entry_info	: cud_entry_descriptor;
  var cud_entry		: cud_user_entry);

begin
  locate_name(buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      cud_entry.name := entry_info.user.name;
      unpack_cud_entry(entry_info, buffer.data, cud_entry)
    end
end (* get_name_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	General Value Storage Routines
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   store_two_cud_bytes				*)
(*									*)
(*      Save the rightmost two bytes in word_to_save			*)
(*	in data indexed by save_location.				*)
(*									*)
(************************************************************************)

procedure store_two_cud_bytes(
      word_to_save	: univ word_in_bytes;
      save_location	: cud_data_index;
  var data		: cud_data);

begin
  data[save_location] := word_to_save[2];
  data[save_location + 1] := word_to_save[3]
end (* store_two_cud_bytes *);
!
"	CUD Entry Storage Routines

    The routines in this Section are used to create, modify (from unpacked
information) or delete a CUD entry in cud_data.
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      remove_entry				*)
(*									*)
(*      Remove the cud entry in data described by entry_info; move	*)
(*	any following entries up to the deleted space, zero any		*)
(*	vacated words and return the total size of the modification	*)
(*	in change_size.							*)
(*									*)
(************************************************************************)

procedure remove_entry(
      entry_info	: cud_entry_descriptor;
  var data		: cud_data;
  var change_size	: cud_data_size);

var
  to_pointer : cud_data_index;
  from_pointer : cud_data_index;
  end_pointer : cud_data_index;
  count,
  bytes_to_move : cud_data_size (* not used, except in routine call *);

begin
  to_pointer := entry_info.pointer;
  from_pointer := entry_info.pointer + entry_info.size;
  cud_utility.find_end_of_entries(data, entry_info.user.block, last_status,
    end_pointer);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  if last_status = CUD_ENTRY_NOT_FOUND
  then
    begin (* move enough to insure a zero word at end *)
      last_status := CUD_ENTRY_OK;
      bytes_to_move := (end_pointer - from_pointer) + MAXIMUM_BYTES_IN_WORD;
      change_size := entry_info.size + bytes_to_move;
      for count := 0 to bytes_to_move - 1 do (* move entries up *)
        begin
          data[to_pointer] := data[from_pointer];
	  from_pointer := from_pointer + 1;
	  to_pointer := to_pointer + 1
        end (* for *);
      for end_pointer := to_pointer to (from_pointer - 1) do
        data[end_pointer] := ZERO
    end (* move enough to insure a zero word at end *)
end (* remove_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			 packed_access_entry_size			*)
(*									*)
(*      Return the number of bytes required to store an			*)
(*	access_entry_description.					*)
(*									*)
(************************************************************************)

function packed_access_entry_size(
	access_entry : access_entry_description) : cud_data_size;

begin
  packed_access_entry_size :=
    2 + (2 * access_entry.origin.size) + (2 * access_entry.destination.size)
end (* packed_access_entry_size *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			packed_access_profile_size			*)
(*									*)
(*      Return the number of bytes required to store the access profile.*)
(*									*)
(************************************************************************)

function packed_access_profile_size(
    access_profile : access_profile_description) : cud_data_size;

var
  entry_index : access_entry_index;
  profile_size : cud_data_size;

begin
  profile_size := 0;
  for entry_index := 0 to access_profile.count - 1 do
    profile_size := profile_size +
      packed_access_entry_size(access_profile.entries[entry_index]);
  packed_access_profile_size := profile_size
end (* packed_access_profile_size *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    packed_entry_size				*)
(*									*)
(*      Return the number of bytes required to store the entry.		*)
(*									*)
(************************************************************************)

function packed_entry_size(
      entry_info	: cud_entry_descriptor;
      access_profile	: access_profile_description) : cud_data_size;

begin
  packed_entry_size := FIXED_CUD_ENTRY_SIZE + entry_info.user.packed_name_size+
    packed_access_profile_size(access_profile)
end (* packed_entry_size *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				store_gan				*)
(*									*)
(*     Store the GAN in data in the entry described by entry_info       *)
(*									*)
(************************************************************************)

procedure store_gan(
      new_gan		: integer;
      entry_info	: cud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : cud_data_index;

begin
  save_ptr := gan_location(entry_info);
  mutil.save_word_in_characters(new_gan, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* store_gan *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				store_uun				*)
(*									*)
(*     Store the UUN in data in the entry described by entry_info       *)
(*									*)
(************************************************************************)

procedure store_uun(
      new_uun		: univ integer;
      entry_info	: cud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : cud_data_index;

begin
  save_ptr := uun_location(entry_info);
  mutil.save_word_in_characters(new_uun, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* store_uun *);


(*************************  cud_entry_updater  **************************)
(*									*)
(*			      store_options				*)
(*									*)
(*      Save new_options in data in the entry described by entry_info.	*)
(*									*)
(************************************************************************)

procedure store_options(
      new_options	: user_options;
      entry_info	: cud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : cud_data_index;
  temp_word : integer;

begin
  save_ptr := options_location(entry_info);
  mutil.save_characters_in_word(data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], temp_word);
  cud_utility.pack_options(new_options, temp_word);
  mutil.save_word_in_characters(temp_word, data[save_ptr],
    data[save_ptr + 1], data[save_ptr + 2], data[save_ptr + 3])
end (* store_options *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     store_district				*)
(*									*)
(*      Save new_district in data in the entry described by entry_info. *)
(*									*)
(************************************************************************)

procedure store_district(
      new_district	: district_number;
      entry_info	: cud_entry_descriptor;
  var data		: cud_data);

var
  district_word : integer;
  save_ptr : cud_data_index;

begin
  save_ptr := district_location(entry_info);
  mutil.save_characters_in_word(data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3], district_word);
  district_word := mutil.mask(district_word, CONTROL_OPTIONS_MASK) +
    new_district;
  mutil.save_word_in_characters(district_word, data[save_ptr],
    data[save_ptr + 1], data[save_ptr + 2], data[save_ptr + 3])
end (* store_district *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   store_change_date				*)
(*									*)
(*      Store the entry change date.					*)
(*									*)
(************************************************************************)

procedure store_change_date(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      entry_info	: cud_entry_descriptor;
  var data		: cud_data);

var
  temp_date : integer;
  save_ptr : cud_data_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    temp_date := REALTIME;
  save_ptr := entry_change_date_location(entry_info);
  mutil.save_word_in_characters(temp_date, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* store_change_date *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   store_password_date				*)
(*									*)
(*      Save new_date in data in the entry described by entry_info.	*)
(*									*)
(************************************************************************)

procedure store_password_date(
      new_date		: integer;
      entry_info	: cud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : cud_data_index;
  temp_date : integer;
  original_first_byte : char;

begin
  save_ptr := password_change_date_location(entry_info);
  original_first_byte := data[save_ptr];
  temp_date := new_date;
  mutil.save_word_in_characters(temp_date, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3]);
  data[save_ptr] := original_first_byte
end (* store_password_date *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     store_password				*)
(*									*)
(************************************************************************)

procedure store_password(
      new_password	: univ word_in_bytes;
      entry_info	: cud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : cud_data_index;

begin
  save_ptr := password_location(entry_info);
  data[save_ptr] := new_password[0];
  data[save_ptr + 1] := new_password[1];
  data[save_ptr + 2] := new_password[2];
  data[save_ptr + 3] := new_password[3]
end (* store_password *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			 pack_next_access_entry				*)
(*									*)
(*      Save the access entry information in data indexed by		*)
(*	profile_pointer.						*)
(*									*)
(************************************************************************)

procedure pack_next_access_entry(
      access_entry	: access_entry_description;
  var profile_pointer	: cud_data_index;
  var data		: cud_data);

var
  size_word : integer;
  origin_index : in_place_origin_index;
  cud_bytes : integer;
  dest_index : destination_index;

begin
  size_word := mutil.left_shift(ACCESS_ENTRY_SIZE_LOCATION,
    packed_access_entry_size(access_entry));
  if access_entry.exception
  then mutil.set_bit(EXCEPTION_BIT, size_word);
  if access_entry.in_place_origin
  then
    begin

(*      Save the in-place origin in data indexed by profile_pointer	*)
(*	and increment profile pointer; size_word contains the first	*)
(*	two bytes of the access entry without the in-place origin size. *)

      mutil.set_bit(IN_PLACE_BIT, size_word);
      size_word := size_word + (2 * access_entry.origin.size);
      store_two_cud_bytes(size_word, profile_pointer, data);
      profile_pointer := profile_pointer + 2;
      for origin_index := 0 to access_entry.origin.size - 1 do
        with access_entry.origin.list[origin_index] do
          begin
            cud_bytes := value;
            if host_flag
            then mutil.set_bit(ORIGIN_HOST_BIT, cud_bytes);
            store_two_cud_bytes(cud_bytes, profile_pointer, data);
            profile_pointer := profile_pointer + 2
          end (* for *)
    end (* origin is IN-PLACE *)
  else
    begin (* origin is CLASS *)
      size_word := size_word + access_entry.class_no;
      store_two_cud_bytes(size_word, profile_pointer, data);
      profile_pointer:= profile_pointer + 2
    end (* origin is CLASS *);

(*      Save the destination in data indexed by profile_pointer		*)
(*	and increment profile_pointer.					*)

  for dest_index := 0 to access_entry.destination.size - 1 do
    with access_entry.destination.list[dest_index] do
      begin
        cud_bytes := value;
        if home_flag
        then mutil.set_bit(HOME_BIT, cud_bytes);
        if group_flag
        then mutil.set_bit(GROUP_BIT, cud_bytes);
        store_two_cud_bytes(cud_bytes, profile_pointer, data);
        profile_pointer := profile_pointer + 2
      end (* for *)
end (* pack_next_access_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   pack_access_profile				*)
(*									*)
(*      Save new_profile in data in the entry described by entry_info.	*)
(*									*)
(************************************************************************)

procedure pack_access_profile(
      new_profile	: access_profile_description;
      entry_info	: cud_entry_descriptor;
  var data		: cud_data);

var
  profile_pointer : cud_data_index;
  profile_index : access_entry_index;

begin
  profile_pointer := profile_location(entry_info);
  for profile_index := 0 to new_profile.count-1 do
    pack_next_access_entry(new_profile.entries[profile_index],
     profile_pointer, data)
end (* pack_access_profile *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   pack_cud_entry_bytes				*)
(*									*)
(*      Save user_entry in data indexed by entry_info.pointer.		*)
(*									*)
(************************************************************************)

procedure pack_cud_entry_bytes(
      entry_info	: cud_entry_descriptor;
      user_entry	: cud_user_entry;
  var data		: cud_data);

var
  temp_word : integer;
  get_pointer : username_text_index (* used to pick up chars from name *);
  save_ptr : cud_data_index;

begin
(*	store size of entry and three filler bytes of zero	*)
  data[entry_info.pointer] := chr(entry_info.size);
  data[entry_info.pointer + 1] := ZERO;
  data[entry_info.pointer + 2] := ZERO;
  data[entry_info.pointer + 3] := ZERO;

(*	store entry name	*)
  save_ptr := name_location(entry_info);
  for get_pointer := 0 to entry_info.user.name.size - 1 do
    begin
      data[save_ptr] := entry_info.user.name.text[get_pointer];
      save_ptr := save_ptr + 1
    end (* for *);
  for get_pointer := entry_info.user.name.size to
    entry_info.user.packed_name_size - 1 do
    begin
      data[save_ptr] := ZERO;
      save_ptr := save_ptr + 1
    end (* for *);
(* turn on sign bit in last name word *)
  data[save_ptr - MAXIMUM_BYTES_IN_WORD] :=
    chr(ord(data[save_ptr - MAXIMUM_BYTES_IN_WORD]) + BIT24);

(*	save password	*)
  store_password(user_entry.password, entry_info, data);

(*	save GAN	*)
  store_gan(user_entry.gan, entry_info, data);

(*	save UUN	*)
  store_uun(user_entry.uun, entry_info, data);

(*	save password date	*)
  store_password_date(user_entry.password_change_date, entry_info, data);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	save options	*)
  store_options(user_entry.options, entry_info, data);

(*	save district	*)
  store_district(user_entry.district, entry_info, data);

(*	save access profile	*)
  pack_access_profile(user_entry.access_profile, entry_info, data);

(*	save entry change date	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  store_change_date(entry_info, data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(*	save  FFFF at end of entry	*)
  temp_word := CUD_ENTRY_TERMINATOR;
  store_two_cud_bytes(temp_word, last_halfword_location(entry_info), data)
end (* pack_cud_entry_bytes *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    pack_cud_entry				*)
(*									*)
(*      Save user_entry in data indexed by entry_info.pointer.		*)
(*									*)
(************************************************************************)

procedure pack_cud_entry(
      entry_info	: cud_entry_descriptor;
      user_entry	: cud_user_entry;
  var data		: cud_data);

var
  save_ptr : cud_data_index;

begin
  pack_cud_entry_bytes(entry_info, user_entry, data);

(* save terminating word of zeroes *)
  save_ptr := zero_terminator_location(entry_info);
  data[save_ptr] :=  ZERO;
  data[save_ptr + 1] := ZERO;
  data[save_ptr + 2] := ZERO;
  data[save_ptr + 3] := ZERO
end (* pack_cud_entry *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			   find_room_for_entry				*)
(*									*)
(*      Find room for the entry described in entry_info.		*)
(*									*)
(************************************************************************)

procedure find_room_for_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var buffer		: cud_disk_block;
  var entry_info	: cud_entry_descriptor);

var
  room_found : boolean;

begin
  room_found := FALSE;
  repeat
    cud_utility.find_end_of_entries(buffer.data, entry_info.user.block,
      last_status, entry_info.pointer);
    if last_status = CUD_FORMAT_ERROR
    then cud_utility.set_format_error(entry_info.user.block,
      entry_info.pointer, last_status)
    else
      with entry_info do
        if (last_status = CUD_ENTRY_NOT_FOUND) and
	  ((MAXIMUM_CUD_DATA-(2*MAXIMUM_BYTES_IN_WORD)-pointer) > size)
	then
	  begin
	    room_found := TRUE;
	    last_status := CUD_ENTRY_OK
	  end;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    if last_status = CUD_ENTRY_NOT_FOUND
    then last_status := CUD_ENTRY_DOES_NOT_FIT;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
  until (last_status <> CUD_ENTRY_OK) or room_found
end (* find_room_for_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      add_new_entry				*)
(*									*)
(*      Set up new_entry in the appropriate CUD block; used by		*)
(*	new_cud_entry and rename routines (restore_old_name and		*)
(*	rename_cud_entry).						*)
(*									*)
(************************************************************************)

procedure add_new_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var new_info		: cud_entry_descriptor;
  var new_entry		: cud_user_entry);

var
  buffer : cud_disk_block;
  change_header : cud_change_header;
  result : cud_operation_result;

begin
  new_info.size := packed_entry_size(new_info, new_entry.access_profile);
  read_block(TRUE, new_info, buffer);
  if last_status = CUD_ENTRY_OK
  then find_room_for_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    buffer, new_info);

(*      Assign new parameters (GAN and/or UUN), if needed,		*)
(*	for the cud entry.						*)
(*	If used by NVDM - GAN and UUN must be assigned by user.		*)

  if last_status = CUD_ENTRY_OK
  then
    begin
      param_manager.assign_user_numbers(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  new_entry.gan, new_entry.uun, result);
      set_status_from_cud_io(result)
    end (* last_status = CUD_ENTRY_OK *);
  if last_status = CUD_ENTRY_OK
  then
    begin
      pack_cud_entry(new_info, new_entry, buffer.data);
      set_up_mud_change_header(new_info.user.block, new_info.pointer,
        new_info.size + MAXIMUM_BYTES_IN_WORD, change_header);
      update_block(new_info, change_header, buffer)
    end (* last_status = CUD_ENTRY_OK *)
end (* add_new_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      store_profile				*)
(*									*)
(*      Save new_profile in data in the entry described by entry_info;	*)
(*	set change_offset to the beginning of the change and		*)
(*	change_size to the size of the change; if the old and new	*)
(*	profile are the same size, store the new one over the old one;	*)
(*	otherwise, move the entry to the end of the block if there is	*)
(*	room; update entry_info if the entry is moved.			*)
(*									*)
(************************************************************************)

procedure store_profile(
      new_profile	: access_profile_description;
  var user_entry	: cud_user_entry;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var entry_info	: cud_entry_descriptor;
  var buffer		: cud_disk_block;
  var change_offset	: cud_data_index;
  var change_size	: cud_data_size);

var
  new_access_size : cud_data_size;
  old_entry_size : cud_data_size;
  old_location : cud_data_index;

begin
  unpack_cud_entry(entry_info, buffer.data, user_entry);
  new_access_size := packed_access_profile_size(new_profile);
  if new_access_size = packed_access_profile_size(user_entry.access_profile)
  then
    begin
      pack_access_profile(new_profile, entry_info, buffer.data);
      change_offset := entry_change_date_location(entry_info);
      change_size := MINIMUM_PROFILE_CHANGE_SIZE + new_access_size
    end
  else
    begin (* old and new entries differ in size *)
      old_entry_size := entry_info.size;
      old_location := entry_info.pointer;
      remove_entry(entry_info, buffer.data, change_size);
      if last_status = CUD_ENTRY_OK
      then
        begin
	  user_entry.access_profile := new_profile (* save new profile *);
	  entry_info.size := packed_entry_size(entry_info,
	    user_entry.access_profile);
	  find_room_for_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    buffer, entry_info);
	  if last_status = CUD_ENTRY_OK
	  then
	    begin
	      pack_cud_entry(entry_info, user_entry, buffer.data);
	      change_offset := old_location;
	      if entry_info.size > old_entry_size
	      then change_size := change_size-old_entry_size+entry_info.size
	    end (* last_status = CUD_ENTRY_OK *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-	*)
	end
    end
end (* store_profile *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      delete_entry				*)
(*									*)
(*      Delete an entry.						*)
(*									*)
(************************************************************************)

procedure delete_entry(
  var entry_info	: cud_entry_descriptor);

var
  buffer : cud_disk_block;
  change_header : cud_change_header;
  change_size : cud_data_size;

begin
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      remove_entry(entry_info, buffer.data, change_size);
      if last_status = CUD_ENTRY_OK
      then
        begin
          set_up_mud_change_header(entry_info.user.block, entry_info.pointer,
	    change_size, change_header);
          update_block(entry_info, change_header, buffer)
        end
    end
end (* delete_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	External Routines
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    hashed_cud_block				*)
(*									*)
(*      Return the hashed CUD block number for the name. 		*)
(*									*)
(************************************************************************)

function entry HASHED_CUD_BLOCK(
      name	: username_string) : normal_cud_block_index;

begin
  last_status := CUD_ENTRY_OK;
  hashed_cud_block := hashed_block(name)
end (* hashed_cud_block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			  check_for_name_in_cud				*)
(*									*)
(*      Set last_status according to whether or not name is in CUD;	*)
(*	use CUD_ENTRY_NOT_FOUND, CUD_NAME_TAKEN, or other error code.	*)
(*	Only used by the CHECk command.					*)
(*									*)
(************************************************************************)

procedure entry CHECK_FOR_NAME_IN_CUD(
      name	: username_string);

var
  check_entry : cud_entry_descriptor;
  buffer : cud_disk_block;

begin
  if not legal_name(name)
  then last_status := CUD_ENTRY_ILLEGAL_NAME
  else
    begin
      last_status := CUD_ENTRY_OK;
      check_entry.user.name := name;
      locate_name(buffer, check_entry);
      if last_status = CUD_ENTRY_OK
      then last_status := CUD_NAME_TAKEN
    end (* legal_name *)
end (* check_for_name_in_cud *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      reserve_name				*)
(*									*)
(*	Reserve name for future use; if it already exists, return FALSE.*)
(*	If the name is of the format Gnnnn or GnnnnT<anything>,		*)
(*	where n = a digit, return CUD_ENTRY_ILLEGAL_NAME because of	*)
(*	conflicts with target profile names.				*)
(*									*)
(************************************************************************)

function entry RESERVE_NAME(
      name	: username_string) : boolean;

var
  new_entry : cud_entry_descriptor;
  buffer : cud_disk_block;

begin
  last_status := CUD_ENTRY_OK;
  reserve_name := FALSE;
  if not legal_name(name)
  then last_status := CUD_ENTRY_ILLEGAL_NAME
  else
    begin
      new_entry.user.name := name;
      name_access.lock_cud_entry(cud_user, new_entry.user.name, TRUE,
        new_entry.user.name_locked);
      if not new_entry.user.name_locked
      then last_status := CUD_ENTRY_LOCKED
      else
        begin (* name locked successfully *)
	  locate_name(buffer, new_entry);
	  if last_status = CUD_ENTRY_NOT_FOUND
	  then
	    begin (* name is not currently being used *)
	      reserve_name := TRUE;
	      new_user := new_entry.user;
	      new_user.packed_name_size := packed_size_of_name(name)
	    end (* name is not currently being used *)
	  else
	    begin (* name is already used *)
	      if last_status = CUD_ENTRY_OK
	      then last_status := CUD_NAME_TAKEN;
	      unlock_username(new_entry.user)
	    end (* name is already used *)
	end (* name locked successfully *)
    end (* legal_name *)
end (* reserve_name *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     read_cud_entry				*)
(*									*)
(*      Find and return the cud_entry for name.				*)
(*									*)
(************************************************************************)

procedure entry READ_CUD_ENTRY(
  var cud_entry	: cud_user_entry);

var
  buffer : cud_disk_block;
  entry_info : cud_entry_descriptor;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.name := cud_entry.name;
  get_name_entry(buffer, entry_info, cud_entry)
end (* read_cud_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      cud_password				*)
(*									*)
(*      Find and return the password cipher for the user name.		*)
(*									*)
(************************************************************************)

function entry CUD_PASSWORD(
      name	: username_string) : integer;

var
  buffer : cud_disk_block;
  entry_info : cud_entry_descriptor;
  temp_password : integer;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.name := name;
  locate_name(buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then unpack_cud_cipher(entry_info, buffer.data, temp_password);
  cud_password := temp_password
end (* cud_password *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			  read_small_cud_entry				*)
(*									*)
(*      Find and return cud info for name.				*)
(*									*)
(************************************************************************)

procedure entry READ_SMALL_CUD_ENTRY(
      name	: username_string;
  var gan	: integer;
  var options	: user_options);

var
  buffer : cud_disk_block;
  entry_info : cud_entry_descriptor;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.name := name;
  locate_name(buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      unpack_gan(entry_info, buffer.data, gan);
      unpack_options(entry_info, buffer.data, options)
    end
end (* read_small_cud_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    modify_cud_entry				*)
(*									*)
(*      Lock the name, then find and return the cud_entry; if found,	*)
(*	leave the name locked, otherwise, unlock it.			*)
(*									*)
(************************************************************************)

procedure entry MODIFY_CUD_ENTRY(
  var cud_entry	: cud_user_entry);

var
  modify_entry : cud_entry_descriptor;
  buffer : cud_disk_block;

begin
  last_status := CUD_ENTRY_OK;
  modify_entry.user.name := cud_entry.name;
  name_access.lock_cud_entry(cud_user, modify_entry.user.name, FALSE,
    modify_entry.user.name_locked);
  if modify_entry.user.name_locked
  then
    begin
      get_name_entry(buffer, modify_entry, cud_entry);
      if last_status = CUD_ENTRY_OK
      then modify_user := modify_entry.user (* save for future update *)
      else unlock_username(modify_entry.user)
    end
  else last_status := CUD_ENTRY_LOCKED
end (* modify_cud_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    modify_cud_password				*)
(*									*)
(*      Lock the name, then find it in the CUD; if found,		*)
(*	leave the name locked, otherwise, unlock it; this routine	*)
(*	is used for those processes that never need to have an entire	*)
(*	unpacked cud_user_entry (password_command_level).		*)
(*									*)
(************************************************************************)

procedure entry MODIFY_CUD_PASSWORD(
      name		: username_string;
  var password_date	: integer;
  var old_cipher	: integer;
  var options		: user_options);

var
  modify_entry : cud_entry_descriptor;
  buffer : cud_disk_block;

begin
  last_status := CUD_ENTRY_OK;
  modify_entry.user.name := name;
  name_access.lock_cud_entry(cud_user, modify_entry.user.name, FALSE,
    modify_entry.user.name_locked);
  if modify_entry.user.name_locked
  then
    begin
      locate_name(buffer, modify_entry);
      if last_status = CUD_ENTRY_OK
      then
        begin
	  modify_user := modify_entry.user (* save for future update *);
	  unpack_password_date(modify_entry, buffer.data, password_date);
	  unpack_cud_cipher(modify_entry, buffer.data, old_cipher);
	  unpack_options(modify_entry, buffer.data, options)
	end
      else unlock_username(modify_entry.user)
    end
  else last_status := CUD_ENTRY_LOCKED
end (* modify_cud_password *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*************************  cud_entry_updater  **************************)
(*									*)
(*			    abort_cud_change				*)
(*									*)
(*      Unlock names.							*)
(*									*)
(************************************************************************)

procedure entry ABORT_CUD_CHANGE;

begin
  last_status := CUD_ENTRY_OK;
  unlock_username(modify_user);
  unlock_username(new_user)
end (* abort_cud_change *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     do_update_password				*)
(*									*)
(*      Update modify_user's CUD entry with a new password		*)
(*	(modify_cud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure do_update_password(
      new_password	: univ word_in_bytes;
      new_date		: integer);

var
  entry_info : cud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : cud_change_header;
  options : user_options;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  if last_status = CUD_ENTRY_OK
  then find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      store_password(new_password, entry_info, buffer.data);
      store_password_date(new_date, entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      set_up_mud_change_header(entry_info.user.block,
        password_location(entry_info), PASSWORD_CHANGE_SIZE, change_header);
      update_block(entry_info, change_header, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* do_update_password *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				update_cud_password			*)
(*									*)
(*     Update the cud password.					        *)
(*									*)
(************************************************************************)

procedure entry UPDATE_CUD_PASSWORD(
      password	: univ integer);

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  cud_change_type := CHANGE_PASSWORD_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  do_update_password(password, todays_password_date)
end (* update_cud_password *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*				update_gan				*)
(*									*)
(*      Update modify_user's CUD entry with a new GAN			*)
(*	(modify_cud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_GAN(
      new_gan	: integer);

var
  entry_info : cud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : cud_change_header;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_gan(new_gan, entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_change_date(entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      set_up_mud_change_header(entry_info.user.block,
        entry_change_date_location(entry_info), GAN_CHANGE_SIZE,
	change_header);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_change_type := CHANGE_GAN_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      update_block(entry_info, change_header, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_gan *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				update_uun				*)
(*									*)
(*      Update modify_user's CUD entry with a new UUN			*)
(*	(modify_cud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_UUN(
      new_uun	: univ word_in_bytes);

var
  entry_info : cud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : cud_change_header;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_uun(new_uun, entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_change_date(entry_info, buffer.data);
      set_up_mud_change_header(entry_info.user.block,
        entry_change_date_location(entry_info), UUN_CHANGE_SIZE,change_header);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_change_type := CHANGE_UUN_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      update_block(entry_info, change_header, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_uun *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     update_options				*)
(*									*)
(*      Update modify_user's CUD entry with new_options			*)
(*	(modify_cud_entry must have been previously called).		*)
(*	If password_changed is TRUE, the CHANGE CONTROL command caused	*)
(*	the password to be changed; if profile_changed is TRUE, the	*)
(*	CHANGE CONTROL command caused the access profile to be changed. *)
(*      If the access_profile was changed, the change was to set all	*)
(*	the destinations to home, so the size of the entry will not	*)
(*	have changed.							*)
(*									*)
(************************************************************************)

procedure entry UPDATE_OPTIONS(
      password_changed	: boolean;
      profile_changed	: boolean;
  var new_entry		: cud_user_entry);

var
  entry_info : cud_entry_descriptor;
  buffer : cud_disk_block;
  change_offset : cud_data_index;
  change_size : cud_data_size;
  change_header : cud_change_header;
  new_profile	: access_profile_description;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  last_status := CUD_ENTRY_OK;
  new_profile := new_entry.access_profile;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* store options and entry change date *)
      store_options(new_entry.options, entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_change_date(entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      change_offset := entry_change_date_location(entry_info);
      change_size := OPTIONS_CHANGE_SIZE;

(* store changed profile if necessary - change_offset and	*)
(* change_size are reset by store_profile routine.		*)
      if profile_changed
      then store_profile(new_profile, new_entry,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	entry_info, buffer, change_offset, change_size);

(* store password and password change date if necessary *)
      if password_changed
      then
        begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  store_password(new_entry.password, entry_info, buffer.data);
	  store_password_date(todays_password_date, entry_info,
	    buffer.data);
	  if change_offset > 0
	  then (* if entire entry is not being changed, *)
	    begin (* adjust change_offset and change_size *)
	      change_offset := change_offset - PASSWORD_BYTES;
	      change_size := change_size + PASSWORD_BYTES +
		PASSWORD_CHANGE_DATE_BYTES
	    end (* adjust change_offset and change_size *)
	end (* password_changed *);

      set_up_mud_change_header(entry_info.user.block, change_offset,
        change_size, change_header);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_change_type := CHANGE_OPTIONS_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      update_block(entry_info, change_header, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_options *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				update_district				*)
(*									*)
(*      Update modify_user's CUD entry with new_district		*)
(*	(modify_cud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_DISTRICT(
      new_district	: integer);

var
  entry_info : cud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : cud_change_header;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_district(new_district, entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_change_date(entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      set_up_mud_change_header(entry_info.user.block,
        entry_change_date_location(entry_info), DISTRICT_CHANGE_SIZE,
	change_header);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_change_type := CHANGE_DISTRICT_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      update_block(entry_info, change_header, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_district *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     update_profile				*)
(*									*)
(*      Update modify_user's CUD entry with new_profile			*)
(*	(modify_cud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_PROFILE(
  var user_entry	: cud_user_entry);

var
  entry_info : cud_entry_descriptor;
  new_profile : access_profile_description;
  buffer : cud_disk_block;
  change_offset : cud_data_index;
  change_size : cud_data_size;
  change_header : cud_change_header;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  last_status := CUD_ENTRY_OK;
  new_profile := user_entry.access_profile;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_profile(new_profile, user_entry,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      entry_info, buffer, change_offset, change_size)
    end (* last_status = CUD_ENTRY_OK *);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_change_date(entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      set_up_mud_change_header(entry_info.user.block,
        change_offset, change_size, change_header);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_change_type := CHANGE_ACCESS_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      update_block(entry_info, change_header, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_profile *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*				new_cud_entry				*)
(*									*)
(*      Write the new_entry into the appropriate block			*)
(*	(reserve_cud_name must have already been called to		*)
(*	set up new_user.name).						*)
(*									*)
(************************************************************************)

procedure entry NEW_CUD_ENTRY(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var new_entry		: cud_user_entry);

var
  new_info : cud_entry_descriptor;

begin
  last_status := CUD_ENTRY_OK;
  new_info.block_locked := FALSE;
  new_info.user := new_user;
  new_entry.options := new_entry.options or [NEW_PASSWORD_OPTION];
  new_entry.password_change_date := todays_password_date;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  cud_change_type := NEW_USER_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  add_new_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    new_info, new_entry);
  unlock_block(new_info);
  unlock_username(new_user)
end (* new_cud_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    do_delete_cud_entry				*)
(*									*)
(*      Remove modify_user.name from the CUD (modify_cud_entry		*)
(*	must have previously been called).				*)
(*									*)
(************************************************************************)

procedure do_delete_cud_entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;

var
  entry_info : cud_entry_descriptor;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  delete_entry(entry_info);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* do_delete_cud_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    delete_cud_entry				*)
(*									*)
(*	Delete the name from the CUD.				        *)
(*									*)
(************************************************************************)

procedure entry DELETE_CUD_ENTRY
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  cud_change_type := DELETE_USER_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  do_delete_cud_entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* delete_cud_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		CUD LIST Routines
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     start_cud_list				*)
(*									*)
(*      Initialize a sequential list of the CUD; the cud_data is	*)
(*	passed so that a disk read does not have to be done for		*)
(*	each individual CUD entry.					*)
(*									*)
(************************************************************************)

procedure entry START_CUD_LIST(
      initial_block	: cud_block_index;
  var buffer		: cud_disk_block);

begin
  last_status := CUD_ENTRY_OK;
  listing_pointer := 0;
  listing_block := initial_block;
  read_cud_block(listing_block, buffer)
end (* start_cud_list *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			     next_list_entry				*)
(*									*)
(*      Return the next sequential CUD entry.				*)
(*									*)
(************************************************************************)

procedure next_list_entry(
      data		: cud_data;
  var entry_found	: boolean;
  var entry_info	: cud_entry_descriptor;
  var cud_entry		: cud_user_entry);

var
  entry_name : username_string;

begin
  next_cud_entry(data, entry_name, entry_info);
  entry_found := (last_status = CUD_ENTRY_OK);
  if entry_found
  then
    begin
      cud_entry.name := entry_name;
      unpack_cud_entry(entry_info, data, cud_entry);
      entry_found := last_status = CUD_ENTRY_OK
    end (* entry found *)
  else (* entry not found *)
   if last_status = CUD_ENTRY_NOT_FOUND
   then last_status := CUD_ENTRY_OK
end (* next_list_entry *);



(*************************  cud_entry_updater  **************************)
(*									*)
(*			      next_cud_list				*)
(*									*)
(*      Return the next sequential CUD entry; called by			*)
(*	command_level_utility routine display_directory.		*)
(*									*)
(************************************************************************)

procedure entry NEXT_CUD_LIST(
  var buffer	: cud_disk_block;
  var block	: cud_block_index;
  var cud_entry	: cud_user_entry);

var
  entry_found : boolean;
  entry_info : cud_entry_descriptor;

begin
  last_status := CUD_ENTRY_OK;
  repeat
    entry_info.user.block := listing_block;
    entry_info.pointer := listing_pointer;
    next_list_entry(buffer.data, entry_found, entry_info, cud_entry);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    if last_status = CUD_ENTRY_OK
    then
      begin
        if not entry_found
	then
	  if listing_block = CUD_BLOCK_LIMIT
	  then last_status := CUD_ENTRY_NOT_FOUND (* end of users *)
	  else
	    begin (* get next block *)
	      listing_block := listing_block + 1;
	      listing_pointer := 0;
	      read_cud_block(listing_block, buffer)
	    end (* get next block *)
      end (* last_status = CUD_ENTRY_OK *);
    if last_status <> CUD_ENTRY_OK
    then
      begin
        listing_pointer := 0 (* so next block will be read on next call *);
	mutil.clear_block(buffer.data)
      end (* last_status <> CUD_ENTRY_OK *)
  until entry_found or (last_status <> CUD_ENTRY_OK);
  if entry_found
  then
    begin
      listing_pointer := listing_pointer + ord(buffer.data[listing_pointer]);
      if hashed_block(cud_entry.name) <> listing_block
      then last_status := CUD_ENTRY_IN_WRONG_BLOCK
    end (* entry found *);
  block := listing_block
end (* next_cud_list *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	Rename Routine
"



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    rename_cud_entry				*)
(*									*)
(*      Rename the CUD entry for modify_user.name to new_user.name	*)
(*	by first deleting the old entry, then adding the new entry	*)
(*	(modify_cud_entry must have been previously called with the	*)
(*	old name, and reserve_cud_name must have been previously	*)
(*	called with the new name).					*)
(*									*)
(************************************************************************)

procedure entry RENAME_CUD_ENTRY(
  var user_entry	: cud_user_entry);

var
  new_user_info : cud_entry_descriptor;
  old_user_info : cud_entry_descriptor;
  result : cud_access_status;
  save_status : cud_entry_result;

begin
  if (MUDUPD_DATA_MAX - mud_change.mud_change_eof) >
    (2 * MAXIMUM_VALIDATOR * (MAXIMUM_CUD_DATA + CUD_CHANGE_HEADER_SIZE))
  then
    begin (* there is room in the mudupd file for the rename chages *)
      last_status := CUD_ENTRY_OK;
      new_user_info.block_locked := FALSE;
      new_user_info.user := new_user;
      old_user_info.block_locked := FALSE;
      old_user_info.user := modify_user;

(* lock the rename blocks *)
      cud_access.lock_cud_block(cud_user, old_user_info.user.block, FALSE,
        result);
      set_access_status(result);
      if last_status = CUD_ENTRY_OK
      then
        begin
          old_user_info.block_locked := TRUE;
          if new_user_info.user.block = old_user_info.user.block
          then old_user_info.block_locked := TRUE
          else cud_access.lock_cud_block(cud_user, new_user_info.user.block,
            FALSE, result);
          set_access_status(result);
          if last_status = CUD_ENTRY_OK
          then new_user_info.block_locked := TRUE
          else
            begin
	      new_user_info.block_locked := FALSE;
	      unlock_block(old_user_info)
	    end
        end
      else old_user_info.block_locked := FALSE;

      if last_status = CUD_ENTRY_OK
      then
        begin (* blocks locked successfully *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  cud_change_type := RENAME_DELETE_USER_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  delete_entry(old_user_info);
	  new_user_info.user := new_user;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  cud_change_type :=RENAME_NEW_USER_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  if last_status = CUD_ENTRY_OK
	  then add_new_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    new_user_info, user_entry);
	  if last_status <> CUD_ENTRY_OK
	  then
	    begin (* attempt to restore the old username to the CUD. *)
	      save_status := last_status;
	      last_status := CUD_ENTRY_OK;
	      user_entry.name := modify_user.name;
	      old_user_info.user := modify_user;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      cud_change_type := RENAME_RESTORE_OLD_NAME;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      add_new_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	        old_user_info, user_entry)
	    end (* last_status <> CUD_ENTRY_OK *);

(*      Unlock both the old and new rename blocks.			*)

	  unlock_block(new_user_info);
	  if new_user_info.user.block <> old_user_info.user.block
	  then unlock_block(old_user_info)
	end (* last_status = CUD_ENTRY_OK *);
    end
  else last_status := CUD_ENTRY_MUD_CHANGE_FILE_FULL;
  unlock_username(modify_user);
  unlock_username(new_user)
end (* rename_cud_entry *);
!
(*	The following routine(s) are here because all		*)
(*	the CUD entry logic is here.				*)

(*	The following routine returns consecutive		*)
(*	entries from a CUD/MUD buffer to a programmer performing*)
(*	a DISPLAY FORMATTED command.				*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*			    unpack_next_entry				*)
(*									*)
(*      Return the next cud_user_entry.					*)
(*									*)
(************************************************************************)

procedure entry UNPACK_NEXT_ENTRY(
      data		: cud_data;
      block		: cud_block_index;
  var pointer		: cud_data_index;
  var cud_entry		: cud_user_entry);

var
  entry_info : cud_entry_descriptor;
  found: boolean;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.block := block;
  entry_info.pointer := pointer;
  next_list_entry(data, found, entry_info, cud_entry);
  if not found and (last_status = CUD_ENTRY_OK)
  then last_status := CUD_ENTRY_NOT_FOUND
end (* unpack_next_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  cud_entry_updater  **************************)
(*									*)
(*				set_remark				*)
(*									*)
(************************************************************************)

procedure entry SET_REMARK(
      new_remark	: oplog_remark_message);

begin
  oplog_remark := new_remark
end (* set_remark *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init calendar;

  modify_user.name_locked := FALSE;
  new_user.name_locked := FALSE
end (* cud_entry_updater *);
!
(************************************************************************)
(*									*)
(*	CUPUTL.NTV							*)
(*									*)
(*			   cud_updater_utility				*)
(*									*)
(*	This class performs CUD functions and types error explanations.	*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  username_string, cud_user_entry, user_options, access_profile	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type CUD_UPDATER_UTILITY = class(
	format		: internal_to_string;
	cud_updater	: cud_entry_updater;
	user_terminal	: circuit_handler);
!
(************************  cud_updater_utility  *************************)
(*									*)
(*			 do_print_cud_entry_message			*)
(*									*)
(*      Print message from last_status.					*)
(*									*)
(************************************************************************)

procedure do_print_cud_entry_message;

begin
  format.start_and_newline;
  format.cud_entry_status(cud_updater.last_status);
  format.write_line(user_terminal)
end (* do_print_cud_entry_message *);



(************************  cud_updater_utility  *************************)
(*									*)
(*			 print_cud_entry_message			*)
(*									*)
(*      Print message from last_status.					*)
(*									*)
(************************************************************************)

procedure entry PRINT_CUD_ENTRY_MESSAGE;

begin
  do_print_cud_entry_message
end (* print_cud_entry_message *);



(************************  cud_updater_utility  *************************)
(*									*)
(*			  print_cud_entry_error				*)
(*									*)
(*      Print any error from last_status.				*)
(*									*)
(************************************************************************)

procedure entry PRINT_CUD_ENTRY_ERROR;

begin
  if cud_updater.last_status <> CUD_ENTRY_OK
  then do_print_cud_entry_message
end (* print_cud_entry_error *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* cud_updater_utility *);
!
(************************************************************************)
(*									*)
(*	MUDUPD.NTV							*)
(*									*)
(*				mud_updater				*)
(*									*)
(*	The MUD_UPDATER Process controls all MUD updates.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  mudupd_address						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18Aug86 - jrn							*)
(*	      - modify and simplify the UN2 access scheme		*)
(*	07Aug86 - rsb							*)
(*		  add call to MUD_CHANGE.SET_UN2_ACTIVITY_NOT_BUSY after*)
(*		  mud update circuit is zapped.				*)
(*	03Mar86 - rsb							*)
(*		- add NO_SUP_UPDATES flag				*)
(*	02Feb86	- rsb							*)
(*		- create MUD_UPDATER_DELAY so a Set_sup:off command	*)
(*		  doesn't get hung up waiting for delay_util to come	*)
(*		  back if a mud update is pending and a sup is unable	*)
(*		  to receive data.					*)
(*		- Update_mud:  change delay call from delay_util.delay	*)
(*		  to mud_updater_delay.					*)
(*		  delete "or not mud_change.legal_supervisor(real_sup)"	*)
(*		  from repeat loop until statement.  Update_mud will	*)
(*		  now have done returned as TRUE from mud_updater_delay *)
(*		  if the sup is no longer legal, it will then procede	*)
(*		  to be delayed in get_mud_change.			*)
(*	        - change parameter values of FIRST_CIRCUIT_RETRY_DELAY	*)
(*		  and MAXIMUM_CIRCUIT_RETRY_DELAY to	 		*)
(*		  WAIT_FOR_STOP_QUE_CHECK_DELAY				*)
(*		  in call to init delay_utility so delay_util always 	*)
(*		  waits same amount of time				*)	
(*	03Jan86 - rsb							*)
(*		- in "type" statement change "sup : supervisor_index;"	*)
(*		  "pseudo_sup : pseudo_supervisor_index;"		*)
(*		-  add "real_sup : real_supervisor_index;" to var list	*)
(*	09Aug84 jrn							*)
(*	      - use engine checksum for disk				*)
(*	02Aug84 Version 3.00 - jrn/pgl					*)
(*	      - added parameter values of FIRST_CIRCUIT_RETRY_DELAY	*)
(*		and MAXIMUM_CIRCUIT_RETRY_DELAY to init of 		*)
(*		delay_utility						*)
(*	28Jun84 jrn							*)
(*	      - add restart for consistency				*)
(*	15Jun84 jrn							*)
(*	      - removed oper_messages from initialization of		*)
(*		cud_block_updater					*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

type MUD_UPDATER = process(
        pseudo_sup      : pseudo_supervisor_index;
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oplog		: operator_log;
	cud_access	: cud_access_controller;
	mud_change	: mud_change_handler;
	circuit_access	: un2_access_manager);

const
  MUD_UPDATER_DELAY_INTERVAL = 5;

var
  mud_utility   : mudupd_utility;
  mutil         : misc_utility;
  delay_utility : circuit_delay_utility;
  crash_util    : crash_utility;
  format        : internal_to_string;
  oper_messages : operator_messages;
  aux_io        : circuit_handler;
  dsksys        : disk_system;
  mud_update    : file_utility;
  block_updater : cud_block_updater;
  cud_utility	: cud_entry_utility;
  block_utility : cud_block_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  un2_util : un2_utility;
  consistency : consistency_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)  
  major_delay_period : integer;
!



(************************  mud_updater  *********************************)
(*									*)
(*			mud_updater_delay				*)
(*									*)
(************************************************************************)

procedure mud_updater_delay(
  var done : boolean);

var
  restart_time : integer;

begin (* mud_updater_delay *)
  restart_time := major_delay_period + REALTIME;
  while (REALTIME < restart_time) and not done do 
    begin (* check wait_for_stop_que while in comm delay state *)
      if mud_change.wait_for_stop_is_empty(pseudo_sup)
      then delay_utility.delay
      else done := TRUE
    end (* check wait_for_stop_que while in comm delay state *);

  if not done
  then 
    begin (* increase delay period, if possible *)
      if major_delay_period < MAXIMUM_CIRCUIT_RETRY_DELAY
      then major_delay_period := major_delay_period * 2;
      if major_delay_period > MAXIMUM_CIRCUIT_RETRY_DELAY
      then major_delay_period := MAXIMUM_CIRCUIT_RETRY_DELAY
    end (* increase delay period, if possible *);
end (* mud_updater_delay *);




(****************************  mud_updater  *****************************)
(*									*)
(*				update_mud				*)
(*									*)
(*      This is the main loop in the process.  Perform a MUD change	*)
(*	or run a consistency.						*)
(*	If a mud change is to be sent it will loop until either the 	*)
(*	change is sent or the Sup becomes not legal.  If the Sup becomes*)
(*	not legal mud_updater_delay will set "done" to TRUE, which will *)
(*	terminate the mud change send attempt upon the next return from *)
(*	mud_updater_delay to update_mud.				*)
(************************************************************************)

procedure update_mud;

var
  consistency_start_block : cud_block_index;
  change_pointer 	  : mudupd_address;
  change 		  : mud_change_information;
  status 		  : un2_status;
  real_sup                : real_supervisor_index;
  run_consistency,
  done,
  success 		  : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin (* update_mud *)
  mud_change.get_mud_change(pseudo_sup, run_consistency, 
                            consistency_start_block, change_pointer, real_sup);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  done := FALSE;	
  If run_consistency
  then
    begin (* start an automatic consistency *)
      consistency.automatic_consistency(real_sup, consistency_start_block);
      if consistency.last_un2_status <> UN2_SUCCESSFUL
      then mud_updater_delay(done)
      else major_delay_period := FIRST_CIRCUIT_RETRY_DELAY
    end (* start an automatic consistency *)
  else
    begin (* change mud *)
      mud_utility.extract_cud_change(change_pointer, success, change.cud_info);
      if not success
      then crash_util.signal_process_error; 
      while not done and mud_change.wait_for_stop_is_empty(pseudo_sup) do
      	begin (* loop until either mud change sent or sup not legal *)
          un2_util.send_mud_change(real_sup, change, status);
          if status <> UN2_SUCCESSFUL
          then mud_updater_delay(done)
          else 
	    begin (* status = UN2_SUCCESSFUL *)
	      mud_change.mud_update_complete(real_sup, change_pointer);
	      done := TRUE;
	      major_delay_period := FIRST_CIRCUIT_RETRY_DELAY;
	      if not mud_change.any_mud_updates(real_sup)
	      then
	        begin (* release control of the circuit *)
		  aux_io.clear_circuit;
		  circuit_access[pseudo_sup].release_circuit;
		  mud_change.set_un2_activity_not_busy(real_sup)
	        end (* release control of the circuit *)
	    end (* status = UN2_SUCCESSFUL *)
	end (* loop until either mud change sent or sup not legal *);
    end (* change mud *);
  mud_change.continue_wait_for_stop_que(pseudo_sup)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* update mud *);


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, aux_io(mutil),
    delay_utility(MUD_UPDATER_DELAY_INTERVAL, MUD_UPDATER_DELAY_INTERVAL),
    format, oper_messages(oplog, format),
    mud_update(MUD_UPDATE_FILE, statistics, file_system, oper_messages,
      format),
    mud_utility(mutil, format, oper_messages, mud_update),
    dsksys(statistics),
    cud_utility(mutil, format, oper_messages),
    block_utility(mutil, oper_messages, format, dsksys),
    block_updater(mutil, statistics, dsksys, cud_access, block_utility,
      format)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
,
    un2_util(aux_io, oper_messages, format, circuit_access, mud_change),
    consistency(mutil, mud_change, un2_util, circuit_access,
      block_updater, cud_utility, oper_messages, format, aux_io);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    major_delay_period := FIRST_CIRCUIT_RETRY_DELAY;

  cycle
    update_mud
  end (* cycle *)
end (* mud_updater *);
!
(************************************************************************)
(*									*)
(*	CGCONT.NTV							*)
(*									*)
(*			class_group_handler				*)
(*									*)
(*	This monitor controls access to the Class group file.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  table_in_pages, file_utility					*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	23Jan86 - jrn							*)
(*	      - remove argument from set_table_date, as mud_change	*)
(*		routine will no crash if the write to disk fails	*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
type CLASS_GROUP_HANDLER = monitor(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oplog		: operator_log;
	mud_change	: mud_change_handler);


var
  format 	: internal_to_string;
  oper_msgs	: operator_messages;
  class_group	: file_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  class_group_handler  **************************)
(*									*)
(*			      do_write_table				*)
(*									*)
(*	Write the CLASS_GROUP_FILE.					*)
(*									*)
(************************************************************************)

procedure do_write_table(
  var table	: univ table_in_pages;
  var success	: boolean);

var
  page_no : table_page_index;
  done : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  io_status : file_utility_status;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  page_no := 0; done := FALSE;
  repeat
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    class_group.write_random(FALSE, page_no, table[page_no], io_status);
    success := io_status = FU_SUCCESS;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    if success
    then
      if page_no = TABLE_PAGE_LIMIT
      then done := TRUE
      else page_no := page_no + 1
  until not success or done
end (* do_write_table *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  class_group_handler  **************************)
(*									*)
(*			      write_table				*)
(*									*)
(*      Write an updated CLASS_GROUP_FILE.				*)
(*									*)
(************************************************************************)

procedure entry WRITE_TABLE(
  var table	: univ table_in_pages;
  var success	: boolean);

begin
  do_write_table(table, success);
  if success
  then mud_change.set_table_date
end (* write_table *);



(***********************  class_group_handler  **************************)
(*									*)
(*				read_table				*)
(*									*)
(*      Return the class/group table.					*)
(*									*)
(************************************************************************)

procedure entry READ_TABLE(
  var table	: univ table_in_pages;
  var success	: boolean);


var
  page_no : table_page_index;
  done : boolean;
  io_status : file_utility_status;

begin
  page_no := 0; done := FALSE;
  repeat
    class_group.read_random(FALSE, page_no, table[page_no], io_status);
    success := io_status = FU_SUCCESS;
    if page_no < TABLE_PAGE_LIMIT
    then page_no := page_no + 1
    else done := TRUE
  until not success or done
end (* read_table *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init format,
    oper_msgs(oplog, format),
    class_group(CLASS_GROUP_FILE, statistics, file_system, oper_msgs, format)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* class_group_handler *);
!
(************************************************************************)
(*									*)
(*	LISACC.NTV							*)
(*									*)
(*			node_host_list_access				*)
(*									*)
(*	This monitor controls access to the NODE_HOST_FILE.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  named_list_nmame, class_index, group_index, file_access_state,*)
(*	  licensed_validator_index					*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	19Feb86 - jrn							*)
(*		- initialize file_access to FILE_AVAILABLE!		*)
(*	31Aug84 - Version 3.00 - jrn					*)
(*	      - use global_access for class and group references	*)
(*	25Jul84 - jrn							*)
(*	      - change routines to set node_host_utility_status		*)
(*	11Mar85 - jrn - Version 2.03					*)
(*	      - fixed bug in initializing fifo that caused NETVAL to	*)
(*		crash when simlutaneous users accessed the file		*)
(*	25OCT83	Original -- jrn						*)
(*									*)
(************************************************************************)


type NODE_HOST_LIST_ACCESS = monitor;



(* The following is used to lock NODE_HOST_LIST		*)
(* entries while the entry is begin created or		*)
(* updated.  An "entry" is a CLASS, GROUP, NODE		*)
(* LIST or HOST LIST.  The validator calls either a	*)
(* CREATE or MODIFY NODE_HOST_LIST_UTILITY routine	*)
(* to "lock" the entry, then an UPDATE, WRITE or	*)
(* DELETE NODE_HOST_LIST_UTILITY routine to record	*)
(* the change and "unlock" the entry.  If the oper-	*)
(* ation does not go to completion, the ABORT		*)
(* NODE_HOST_LIST_UTILITY routine must be called to	*)
(* unlock the locked entry.				*)

type
  KIND_OF_UPDATE = (NO_UPDATE, HOST_LIST_UPDATE,
    NODE_LIST_UPDATE, CLASS_UPDATE, GROUP_UPDATE);


  ENTRY_INFORMATION = record
    kind      		: kind_of_update  (* = NO_UPDATE if not in use *);
    list_name		: named_list_name (* the LIST NAME locked *);
    global_access_no	: integer	  (* the CLASS or GROUP locked *)
  end (* entry_information *);



var
  next : fifo;



(* Current state of file;		*)
(* initialized to FILE_AVAILABLE.	*)

  file_access : file_access_state;



(* information about locked items *)
(* initialized to all NO_UPDATE *)

  entry_access : array [licensed_validator_index] of entry_information;



(* This is where validators are delayed while		*)
(* waiting to access the file.  Validators are		*)
(* delayed in a queue in the LOCK_FILE routine and	*)
(* continued in the unlock_file routine.  Validators	*)
(* are added to the list indexed by fifo.arrival and	*)
(* are removed from the list at fifo.departure.		*)

  waiting_for_file : array [licensed_validator_index] of queue;
!



(***********************  node_host_list_access  ************************)
(*									*)
(*				initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  index : licensed_validator_index;

begin
  for index := FIRST_LICENSED_VALIDATOR to LICENSED_VALIDATOR_LIMIT do
    entry_access[index].kind := NO_UPDATE;

  file_access := FILE_AVAILABLE
end (* initialize *);



(***********************  node_host_list_access  ************************)
(*									*)
(*				lock_file				*)
(*									*)
(*      Lock the NODE_HOST_FILE.					*)
(*									*)
(************************************************************************)

procedure entry LOCK_FILE;

begin
  if file_access <> FILE_AVAILABLE
  then delay(waiting_for_file[next.arrival]);

  file_access := FILE_LOCKED
end (* lock_file *);



(***********************  node_host_list_access  ************************)
(*									*)
(*				unlock_file				*)
(*									*)
(*      Make the file available again and continue any			*)
(*	validators waiting for it.					*)
(*									*)
(************************************************************************)

procedure entry UNLOCK_FILE;

begin
  file_access := FILE_AVAILABLE;
  if not next.empty
  then continue(waiting_for_file[next.departure])
end (* unlock_file *);



(***********************  node_host_list_access  ************************)
(*									*)
(*			    lock_named_list				*)
(*									*)
(*      Lock the NAMED LIST for the caller.				*)
(*									*)
(************************************************************************)

procedure entry LOCK_NAMED_LIST(
      caller		: licensed_validator_index;
      host_flag		: boolean (* TRUE if host list update *);
      list_name		: named_list_name;
  var status		: node_host_utility_status);

var
  kind : kind_of_update;
  updater : licensed_validator_index;
  done : boolean;

begin
  if host_flag
  then kind := HOST_LIST_UPDATE
  else kind := NODE_LIST_UPDATE;

(* set status to NODE_HOST_BEING_UPDATED if list is already locked *)
  done := FALSE;
  updater := FIRST_LICENSED_VALIDATOR;
  repeat
    if ((entry_access[updater].kind = kind) and
      (entry_access[updater].list_name = list_name))
    then
      begin
        status := NODE_HOST_BEING_UPDATED;
	done := TRUE
      end
    else
      if updater < VALIDATOR_LIMIT
      then updater := updater + 1
      else
        begin
	  done := TRUE;
          entry_access[caller].kind := kind;
          entry_access[caller].list_name := list_name
	end
  until done
end (* lock_named_list *);




(***********************  node_host_list_access  ************************)
(*									*)
(*			    lock_global_access				*)
(*									*)
(*      Lock the global_access for the caller.				*)
(*									*)
(************************************************************************)

procedure entry LOCK_GLOBAL_ACCESS(
      caller	: licensed_validator_index;
      class_flag: boolean;
      value	: univ integer;
  var status	: node_host_utility_status);

var
  updater : licensed_validator_index;
  done : boolean;
  kind : kind_of_update;

begin
  if class_flag
  then kind := CLASS_UPDATE
  else kind := GROUP_UPDATE;

  done := FALSE;
  updater := FIRST_LICENSED_VALIDATOR;
  repeat
    if (entry_access[updater].kind = kind) and
      (entry_access[updater].global_access_no = value)
    then
      begin
        status := NODE_HOST_BEING_UPDATED;
	done := TRUE
      end
    else
      if updater < VALIDATOR_LIMIT
      then updater := updater + 1
      else
        begin
	  done := TRUE;
          entry_access[caller].kind := kind;
          entry_access[caller].global_access_no := value
	end
  until done
end (* lock_global_access *);




(***********************  node_host_list_access  ************************)
(*									*)
(*				unlock_entry				*)
(*									*)
(*      Unlock the entry the caller has locked.				*)
(*									*)
(************************************************************************)

procedure entry UNLOCK_ENTRY(
      caller : licensed_validator_index);

begin
  entry_access[caller].kind := NO_UPDATE
end (* unlock_entry *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init next(FIRST_LICENSED_VALIDATOR, LICENSED_VALIDATOR_LIMIT);
  initialize
end (* node_host_list_access *);
!
(************************************************************************)
(*									*)
(*	LIOUTL.NTV							*)
(*									*)
(*			node_host_list_io_utility			*)
(*									*)
(*	The node_host_list_io_utility class performs all actual		*)
(*	reading and writing of the NODE_HOST_FILE.  The file can	*)
(*	always be read without locking.					*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	20Jul84 - jrn - original					*)
(*									*)
(************************************************************************)

type node_host_list_io_utility = class(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oper_messages	: operator_messages;
	format		: internal_to_string;
	list_access	: node_host_list_access);

var
  node_host_list : file_utility;



(********************  node_host_list_io_utility  ***********************)
(*									*)
(*			       set_status				*)
(*									*)
(************************************************************************)

procedure set_status(
      io_status : file_utility_status;
  var status	: node_host_utility_status);

begin
  case io_status of
    FU_SUCCESS:	       status := NODE_HOST_OK;
    FU_IO_ERROR:       status := NODE_HOST_IO_ERROR;
    FU_CHECKSUM_ERROR: status := NODE_HOST_BAD_CHECKSUM
  end (* case *)
end (* set_status *);



(********************  node_host_list_io_utility  ***********************)
(*									*)
(*			 global_access_offset				*)
(*									*)
(*	Return offset into file; I/O is done via a file_utility that	*)
(*	takes into account the address of the beginning of the file.	*)
(*									*)
(************************************************************************)

function global_access_offset(
	class_flag	: boolean;
	global_value	: univ integer) : integer;

var
  offset : integer;

begin (* global accesses handled here start at 1 *)
  offset := ((global_value - 1) * MAXIMUM_PAGES_IN_GLOBAL_ACCESS) -
    NODE_HOST_FILE_START;
  if class_flag
  then global_access_offset := FIRST_CLASS_DEFINITION_PAGE + offset
  else global_access_offset := FIRST_GROUP_DEFINITION_PAGE + offset
end (* global_access_offset *);



(********************  node_host_list_io_utility  ***********************)
(*									*)
(*			    read_global_access				*)
(*									*)
(*      Read a global access from the file.				*)
(*									*)
(************************************************************************)

procedure entry READ_GLOBAL_ACCESS(
      class_flag	: boolean;
      global_value	: univ integer;
  var global_access	: global_access_description;
  var status		: node_host_utility_status);

var
  io_status : file_utility_status;

begin
  node_host_list.read_global_access(
    global_access_offset(class_flag, global_value), global_access, io_status);
  set_status(io_status, status)
end (* read_global_access *);



(********************  node_host_list_io_utility  ***********************)
(*									*)
(*			  write_global_access				*)
(*									*)
(*      Write a global access to disk.					*)
(*									*)
(************************************************************************)

procedure entry WRITE_GLOBAL_ACCESS(
      locked		: boolean	(* TRUE if file already locked *);
      class_flag	: boolean	(* TRUE if a CLASS *);
      global_value	: univ integer;
  var global_access	: global_access_description;
  var status		: node_host_utility_status);

var
  io_status : file_utility_status;

begin
  if not locked
  then list_access.lock_file;
  node_host_list.write_global_access(
    global_access_offset(class_flag, global_value), global_access, io_status);
  set_status(io_status, status);
  if not locked
  then list_access.unlock_file
end (* write_global_access *);



(********************  node_host_list_io_utility  ***********************)
(*									*)
(*			     list_offset				*)
(*									*)
(*	Return offset into file; I/O is done via a file_utility that	*)
(*	takes into account the address of the beginning of the file.	*)
(*									*)
(************************************************************************)

function list_offset(
      list_desc	: list_descriptor) : integer;

var
  offset : integer;

begin (* list pointers start at 0 *)
  offset := list_desc.list_ptr * MAXIMUM_PAGES_IN_NAMED_LIST -
    NODE_HOST_FILE_START;
  if list_desc.host_flag
  then list_offset := FIRST_HOST_LIST_PAGE + offset
  else list_offset := FIRST_NODE_LIST_PAGE + offset
end (* list_offset *);



(********************  node_host_list_io_utility  ***********************)
(*									*)
(*			     read_list					*)
(*									*)
(*      Read a list from the NODE_HOST_FILE.				*)
(*									*)
(************************************************************************)

procedure entry READ_LIST(
      list_desc		: list_descriptor;
  var named_list	: named_list_definition;
  var status		: node_host_utility_status);
var
  io_status : file_utility_status;

begin
  node_host_list.read_named_list(list_offset(list_desc), named_list,
    io_status);
  set_status(io_status, status)
end (* read_list *);



(********************  node_host_list_io_utility  ***********************)
(*									*)
(*			     write_list					*)
(*									*)
(*      Write a list to the NODE_HOST_FILE.				*)
(*									*)
(************************************************************************)

procedure entry WRITE_LIST(
      list_desc		: list_descriptor;
  var named_list	: named_list_definition;
  var status		: node_host_utility_status);

var
  io_status : file_utility_status;

begin
  list_access.lock_file;
  node_host_list.write_named_list(list_offset(list_desc), named_list,
    io_status);
  set_status(io_status, status);
  list_access.unlock_file
end (* write_list *);



(********************  node_host_list_io_utility  ***********************)
(*									*)
(*			     read_header				*)
(*									*)
(************************************************************************)

procedure entry READ_HEADER(
  var header	: univ node_host_file_header;
  var status	: node_host_utility_status);

var
  io_status : file_utility_status;

begin
  node_host_list.read_random(TRUE, 0, header, io_status);
  set_status(io_status, status)
end (* read_header *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init node_host_list(NODE_HOST_FILE, statistics, file_system, oper_messages,
    format)
end (* node_host_list_io_utility *);
!
(************************************************************************)
(*									*)
(*	LISALL.NTV							*)
(*									*)
(*			node_host_list_allocater			*)
(*									*)
(*	This monitor controls allocation of lists and global_accesses	*)
(*	in the NODE_HOST_FILE.  At start-up time, build a table to	*)
(*	represent each possible list and global access; mark the	*)
(*	existing lists and global accesses.				*)
(*									*)
(*	Calls to this monitor include:					*)
(*		GLOBAL_ACCESS_DEFINED: say if global access is defined	*)
(*		DEFINE_GLOBAL_ACCESS: set up global access as defined	*)
(*		CLEAR_GLOBAL_ACCESS: undefine a global access		*)
(*		START_LIST, NEXT_LIST: do a sequential scan of lists	*)
(*		DEALLOCATE: remove a list				*)
(*		ALLOCATE: set up a new list				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	23Jul84	Original -- jrn						*)
(*									*)
(************************************************************************)

type node_host_list_allocater = monitor(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oplog		: operator_log;
	list_access	: node_host_list_access);



(* The set of all lists *)
const
  list_set_max = (MAXIMUM_LIST + BASIC_SET_LIMIT) div BASIC_SET_MAX;
  list_set_limit = list_set_max - 1;


type
  list_set_index = 0..LIST_SET_LIMIT;
  list_set = array [list_set_index] of basic_set;


  list_scan_info = record
    list_ptr	: -1..list_limit;
    host_flag	: boolean	(* TRUE if host list scan *)
  end (* list_scan_info *);



(* The set of all classes *)
const
  class_set_max = (MAXIMUM_CLASS + BASIC_SET_LIMIT) div BASIC_SET_MAX;
  class_set_limit = class_set_max - 1;


type
  class_set_index = 0..class_set_limit;
  class_set_definition = array [class_set_index] of basic_set;


(* The set of all groups *)
const
  group_set_max = (MAXIMUM_GROUP + BASIC_SET_LIMIT) div BASIC_SET_MAX;
  group_set_limit = group_set_max - 1;


type
  group_set_index = 0..group_set_limit;
  group_set_definition = array [group_set_index] of basic_set;



var
  crash_util 	: crash_utility;
  format	: internal_to_string;
  oper_messages	: operator_messages;
  list_io	: node_host_list_io_utility;


(* the in-core info about existing sets *)
  node_set	: list_set;
  host_set	: list_set;
  defined_classes	: class_set_definition;
  defined_groups	: group_set_definition;

  scanning	: array [licensed_validator_index] of list_scan_info;
!
(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			        add_list				*)
(*									*)
(************************************************************************)

procedure add_list(
      list	: list_index;
  var new_set	: list_set);

var
  set_index : list_set_index;

begin
  set_index := list div BASIC_SET_MAX;
  new_set[set_index] := new_set[set_index] or [list mod BASIC_SET_MAX]
end (* add_list *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			        remove_list				*)
(*									*)
(************************************************************************)

procedure remove_list(
      list	: list_index;
  var new_set	: list_set);

var
  set_index : list_set_index;

begin
  set_index := list div BASIC_SET_MAX;
  new_set[set_index] := new_set[set_index] - [list mod BASIC_SET_MAX]
end (* remove_list *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			    initialize_list_set				*)
(*									*)
(************************************************************************)

procedure initialize_list_set(
      host_flag		: boolean	(* TRUE if initting hostlist set *);
  var init_set		: list_set);

var
  next_list : list_index;
  list_to_read : list_descriptor;
  named_list : named_list_definition;
  set_index : list_set_index;
  status : node_host_utility_status;

begin
  for set_index := 0 to LIST_SET_LIMIT do
    init_set[set_index] := []	(* say no lists to start with *);
  list_to_read.host_flag := host_flag;
  for next_list := 0 to LIST_LIMIT do
    begin
      status := NODE_HOST_OK;
      list_to_read.list_ptr := next_list;
      list_io.read_list(list_to_read, named_list, status);
      if (named_list.name.size <> 0) or (status <> NODE_HOST_OK)
      then add_list(next_list, init_set)
    end
end (* initialize_list_set *);
!
(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			        add_class				*)
(*									*)
(************************************************************************)

procedure add_class(
      class_no	: class_index);

var
  set_index : class_set_index;

begin
  set_index := class_no div BASIC_SET_MAX;
  defined_classes[set_index] :=
    defined_classes[set_index] or [class_no mod BASIC_SET_MAX]
end (* add_class *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			        remove_class				*)
(*									*)
(************************************************************************)

procedure remove_class(
      class_no	: class_index);

var
  set_index : class_set_index;

begin
  set_index := class_no div BASIC_SET_MAX;
  defined_classes[set_index] := 
    defined_classes[set_index] - [class_no mod BASIC_SET_MAX]
end (* remove_class *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			 initialize_class_set				*)
(*									*)
(************************************************************************)

procedure initialize_class_set;

var
  next_class : class_index;
  global_access : global_access_description;
  set_index : class_set_index;
  status : node_host_utility_status;

begin
  for set_index := 0 to CLASS_SET_LIMIT do
    defined_classes[set_index] := []	(* say all undefined to start with *);
  for next_class := FIRST_CLASS to MAXIMUM_CLASS do
    begin
      status := NODE_HOST_OK;
      list_io.read_global_access(TRUE, next_class, global_access, status);
      if (global_access.count <> 0) or (status <> NODE_HOST_OK)
      then add_class(next_class)
    end
end (* initialize_class_set *);
!
(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			        add_group				*)
(*									*)
(************************************************************************)

procedure add_group(
      group_no	: group_index);

var
  set_index : group_set_index;

begin
  set_index := group_no div BASIC_SET_MAX;
  defined_groups[set_index] :=
    defined_groups[set_index] or [group_no mod BASIC_SET_MAX]
end (* add_group *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			        remove_group				*)
(*									*)
(************************************************************************)

procedure remove_group(
      group_no	: group_index);

var
  set_index : group_set_index;

begin
  set_index := group_no div BASIC_SET_MAX;
  defined_groups[set_index] :=
    defined_groups[set_index] - [group_no mod BASIC_SET_MAX]
end (* remove_group *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			 initialize_group_set				*)
(*									*)
(************************************************************************)

procedure initialize_group_set;

var
  next_group : group_index;
  global_access : global_access_description;
  set_index : group_set_index;
  status : node_host_utility_status;

begin
  for set_index := 0 to GROUP_SET_LIMIT do
    defined_groups[set_index] := []	(* say all undefined to start with *);
  for next_group := FIRST_GROUP to MAXIMUM_GROUP do
    begin
      status := NODE_HOST_OK;
      list_io.read_global_access(FALSE, next_group, global_access, status);
      if (global_access.count <> 0) or (status <> NODE_HOST_OK)
      then add_group(next_group)
    end
end (* initialize_group_set *);




(*********************  node_host_list_allocater  ***********************)
(*									*)
(*				initialize				*)
(*									*)
(* Read through all lists, setting the bit appropriately in the set.	*)
(*									*)
(************************************************************************)

procedure initialize;

var
  header : node_host_file_header;
  status : node_host_utility_status;

begin
  status := NODE_HOST_OK;
  list_io.read_header(header, status);
  if status <> NODE_HOST_OK
  then crash_util.halt_slot
  else
    with header do
      if (id <> NODE_HOST_CLASS_GROUP_ID) or
        (max_list <> MAXIMUM_LIST) or
        (max_named_list_size <> MAXIMUM_NAMED_LIST_NAME_SIZE) or
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        (max_named_list_entry <> MAXIMUM_NAMED_LIST_ENTRY) or
        (max_lists_in_global_access <> MAX_LISTS_IN_GLOBAL_ACCESS) or
        (first_node_page <> FIRST_NODE_LIST_PAGE) or
        (last_node_page <> LAST_NODE_LIST_PAGE) or
        (first_host_page <> FIRST_HOST_LIST_PAGE) or
        (last_host_page <> LAST_HOST_LIST_PAGE) or
        (first_class_page <> FIRST_CLASS_DEFINITION_PAGE) or
        (last_class_page <> LAST_CLASS_DEFINITION_PAGE) or
        (first_group_page <> FIRST_GROUP_DEFINITION_PAGE) or
        (last_group_page <> LAST_GROUP_DEFINITION_PAGE)
      then crash_util.halt_slot;

  initialize_list_set(TRUE, host_set);
  initialize_list_set(FALSE, node_set);
  initialize_class_set;
  initialize_group_set
end (* initialize *);
!
(*********************  node_host_list_allocater  ***********************)
(*									*)
(*				do_allocate				*)
(*									*)
(************************************************************************)

procedure DO_ALLOCATE(
  var new_list	: list_index;
  var new_set	: list_set;
  var status	: node_host_utility_status);

var
  done : boolean;
  set_index : list_set_index;

begin
  done := FALSE;
  new_list := 0;
  repeat
    set_index := new_list div BASIC_SET_MAX;
    if (new_list mod BASIC_SET_MAX) in new_set[set_index]
    then
      if new_list < LIST_LIMIT
      then new_list := new_list + 1
      else status := NODE_HOST_FULL
    else
      begin
        done := TRUE;
	add_list(new_list, new_set)
      end
  until done or (status <> NODE_HOST_OK)
end (* do_allocate *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*				allocate				*)
(*									*)
(************************************************************************)

procedure entry ALLOCATE(
  var new_desc	: list_descriptor;
  var status	: node_host_utility_status);

begin
  if new_desc.host_flag
  then do_allocate(new_desc.list_ptr, host_set, status)
  else do_allocate(new_desc.list_ptr, node_set, status)
end (* allocate *);
!
(*********************  node_host_list_allocater  ***********************)
(*									*)
(*				deallocate				*)
(*									*)
(************************************************************************)

procedure entry DEALLOCATE(
      list_desc	: list_descriptor);

begin
  if list_desc.host_flag
  then remove_list(list_desc.list_ptr, host_set)
  else remove_list(list_desc.list_ptr, node_set)
end (* deallocate *);
!
(*********************  node_host_list_allocater  ***********************)
(*									*)
(*				start_list				*)
(*									*)
(************************************************************************)

procedure entry START_LIST(
      validator	: licensed_validator_index;
      host_flag	: boolean);

begin
  scanning[validator].list_ptr := -1;
  scanning[validator].host_flag := host_flag
end (* start_list *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			    next_scan_list				*)
(*									*)
(************************************************************************)

procedure next_scan_list(
      validator	: licensed_validator_index;
      scan_set	: list_set;
  var next	: list_index;
  var done	: boolean);

var
  found : boolean;

begin
  done := FALSE; found := FALSE;
  repeat
    if scanning[validator].list_ptr = LIST_LIMIT
    then done := TRUE
    else
      begin
        scanning[validator].list_ptr :=
	  scanning[validator].list_ptr + 1;
	if (scanning[validator].list_ptr mod BASIC_SET_MAX) in
	  scan_set[scanning[validator].list_ptr div BASIC_SET_MAX]
	then
	  begin
	    next := scanning[validator].list_ptr;
	    found := TRUE
	  end
      end
  until done or found
end (* next_scan_list *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*				next_list				*)
(*									*)
(************************************************************************)

procedure entry NEXT_LIST(
      validator	: licensed_validator_index;
  var next	: list_index;
  var done	: boolean);

begin
  if scanning[validator].host_flag
  then next_scan_list(validator, host_set, next, done)
  else next_scan_list(validator, node_set, next, done)
end (* next_list *);
!
(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			 clear_global_access				*)
(*									*)
(************************************************************************)

procedure entry CLEAR_GLOBAL_ACCESS(
      class_flag	: boolean (* TRUE if class *);
      global_value	: univ integer);

begin
  if class_flag
  then remove_class(global_value)
  else remove_group(global_value)
end (* clear_global_access *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			 define_global_access				*)
(*									*)
(************************************************************************)

procedure entry DEFINE_GLOBAL_ACCESS(
      class_flag	: boolean (* TRUE if class *);
      global_value	: univ integer);

begin
  if class_flag
  then add_class(global_value)
  else add_group(global_value)
end (* define_global_access *);



(*********************  node_host_list_allocater  ***********************)
(*									*)
(*			 global_access_defined				*)
(*									*)
(************************************************************************)

function entry GLOBAL_ACCESS_DEFINED(
      class_flag	: boolean (* TRUE if class *);
      global_value	: univ integer) : boolean;

var
  set_index : integer;

begin
  set_index := global_value div BASIC_SET_MAX;
  if class_flag
  then global_access_defined :=
    (global_value mod BASIC_SET_MAX) in defined_classes[set_index]
  else global_access_defined := 
    (global_value mod BASIC_SET_MAX) in defined_groups[set_index]
end (* global_access_defined *);


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init crash_util,
    format,
    oper_messages(oplog, format),
    list_io(statistics, file_system, oper_messages, format, list_access);
  initialize
end (* node_host_list_allocater *);
!
(************************************************************************)
(*									*)
(*	LISUTL.NTV							*)
(*									*)
(*			node_host_list_utility				*)
(*									*)
(*	The node_host_list_utility class performs all manipulations	*)
(*	of data in the NODE_HOST_FILE.					*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	17Feb86 - jrn							*)
(*	      - add the configuration parameter (and old conversion	*)
(*		code) PACK_CLASS_AND_GROUP_TABLE			*)
(*	24Jul85 - jrn							*)
(*	      - fix bug in check_list_reference that checks empty	*)
(*		global accesses						*)
(*	03Jun85 - jrn							*)
(*	      - remove validator_global_access, etc. due to size.	*)
(*	24Jul84 - jrn							*)
(*	      - new format class/group file				*)
(*	      - add list descriptions					*)
(*	      - remove fancy conversion for Class/group table		*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - fixed a bug in setting the new value of			*)
(*		HIGHEST_ASSIGNED when the last list is deleted		*)
(*	      - NEXT_HOST_LIST and NEXT_NODE_LIST were combined into	*)
(*		the single procedure NEXT_LIST				*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type NODE_HOST_LIST_UTILITY = class(
	validator	: licensed_validator_index;
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	format		: internal_to_string;
	list_io		: node_host_list_io_utility;
	list_allocater	: node_host_list_allocater;
	list_access	: node_host_list_access);


const
  HALFWORD_EXCEPTION_BIT = BIT16;
  HALFWORD_HOST_BIT = BIT16;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
var
  mutil 	: misc_utility;

  list_locked	: list_descriptor (* the list being modified *);
  creating_list : boolean (* TRUE if nodelist or hostlist is being created *);

  entry last_status : node_host_utility_status (* last operation status *);
!
"
 	     Retrieval Routines
"



(**********************  node_host_list_utility  ************************)
(*									*)
(*			    get_global_access				*)
(*									*)
(*      Return a global_access.						*)
(*									*)
(************************************************************************)

procedure get_global_access(
      class_flag	: boolean;
      global_value	: univ integer;
  var global_access	: global_access_description);

begin
  if list_allocater.global_access_defined(class_flag, global_value)
  then list_io.read_global_access(class_flag, global_value, global_access,
    last_status)
  else global_access.count := 0
end (* get_global_access *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			    do_find_list				*)
(*									*)
(*      Locate the LIST described by list_to_find.name			*)
(*	and list_desc.host_flag and return list_desc.list_ptr and the	*)
(*	rest of the named_list_definition.				*)
(*									*)
(************************************************************************)

procedure do_find_list(
  var list_to_find	: named_list_definition;
  var list_desc		: list_descriptor);

var
  name_match,
  done : boolean;
  list_to_check : named_list_definition;
  text_ptr : named_list_name_index;

begin
  name_match := FALSE;
  list_allocater.start_list(validator, list_desc.host_flag);
  repeat
    list_allocater.next_list(validator, list_desc.list_ptr, done);
    if done
    then last_status := NODE_HOST_LIST_NOT_FOUND
    else
      begin (* check next list *)
        list_io.read_list(list_desc, list_to_check, last_status);
	if last_status = NODE_HOST_OK
	then
	  if list_to_find.name.size = list_to_check.name.size
	  then
	    begin (* size matches, check text *)
	      name_match := TRUE;
	      text_ptr := 0;
	      repeat
	        if list_to_find.name.text[text_ptr] <>
		  list_to_check.name.text[text_ptr]
		then name_match := FALSE
		else
		  if text_ptr <> list_to_find.name.size - 1
		  then text_ptr := text_ptr + 1
		  else done := TRUE
	      until not name_match or done
	    end (* size matches, check text *)
      end (* check next list *)
  until done or (last_status <> NODE_HOST_OK);
  if name_match
  then list_to_find := list_to_check
end (* do_find_list *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			 set_sorted_flag				*)
(*									*)
(************************************************************************)

procedure set_sorted_flag(
  var validator_list	: validator_named_list_definition);

var
  index : named_list_index;

begin
  validator_list.sorted := TRUE;
  if last_status = NODE_HOST_OK
  then
    for index := 0 to validator_list.named_list.count - 2 do
      if validator_list.named_list.values[index] >
        validator_list.named_list.values[index + 1]
      then validator_list.sorted := FALSE
end (* set_sorted_flag *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			 do_find_validator_list				*)
(*									*)
(************************************************************************)

procedure do_find_validator_list(
  var validator_list	: validator_named_list_definition;
  var list_desc		: list_descriptor);

begin
  validator_list.host_flag := list_desc.host_flag;
  do_find_list(validator_list.named_list, list_desc);
  set_sorted_flag(validator_list)
end (* do_find_validator_list *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			  check_list_reference				*)
(*									*)
(*      Check all the global accesses for a reference to the list.	*)
(*									*)
(************************************************************************)

procedure check_list_reference(
      class_flag	: boolean (* TRUE if class *);
      first_value	: integer;
      last_value	: integer;
  var global_value	: univ integer);

var
  checked_all_global_accesses : boolean;
  global_access : global_access_description;
  next_list_ptr : global_access_list_entry_index;
  checked_all_lists : boolean;

begin
  global_value := first_value; checked_all_global_accesses := FALSE;
  repeat
    if list_allocater.global_access_defined(class_flag, global_value)
    then
      begin
        list_io.read_global_access(class_flag, global_value, global_access,
	  last_status);
	next_list_ptr := 0; checked_all_lists := FALSE;
	if last_status = NODE_HOST_OK
	then (* Scan the global access for a list = list_locked *)
	  repeat (* there is at least one list in the global access... *)
	    if list_locked = global_access.lists[next_list_ptr]
	    then last_status := NODE_HOST_LIST_IN_USE
	    else
	      if next_list_ptr < global_access.count - 1
	      then next_list_ptr := next_list_ptr + 1
	      else checked_all_lists := TRUE
	   until checked_all_lists or (last_status <> NODE_HOST_OK)
      end (* global access is defined *);
    if last_status = NODE_HOST_OK
    then
      if global_value < last_value
      then global_value := global_value + 1
      else checked_all_global_accesses := TRUE
  until checked_all_global_accesses or (last_status <> NODE_HOST_OK) 
end (* check_list_reference *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			    read_global_access				*)
(*									*)
(*      Return the description of a global_access.			*)
(*									*)
(************************************************************************)

procedure entry READ_GLOBAL_ACCESS(
      class_flag	: boolean;
      global_value	: univ integer;
  var global_access	: global_access_description);

begin
  last_status := NODE_HOST_OK;
  get_global_access(class_flag, global_value, global_access)
end (* read_global_access *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			  modify_global_access				*)
(*									*)
(*      Set up to change a global_access.				*)
(*									*)
(************************************************************************)

procedure entry MODIFY_GLOBAL_ACCESS(
      class_flag	: boolean;
      global_value	: univ integer;
  var global_access	: global_access_description);

begin
  last_status := NODE_HOST_OK;
  list_access.lock_global_access(validator, class_flag, global_value,
    last_status);
  if last_status = NODE_HOST_OK
  then
    begin
      get_global_access(class_flag, global_value, global_access);
      if last_status <> NODE_HOST_OK
      then list_access.unlock_entry(validator)
    end
end (* modify_global_access *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			   update_global_access				*)
(*									*)
(*      Write the new global_access; MODIFY_GLOBAL_ACCESS must have	*)
(*	been called previously.						*)
(*									*)
(************************************************************************)

procedure entry UPDATE_GLOBAL_ACCESS(
      class_flag	: boolean;
      global_value	: univ integer;
  var global_access	: global_access_description);

begin
  last_status := NODE_HOST_OK;
  if global_access.count = 0
  then list_allocater.clear_global_access(class_flag, global_value)
  else list_allocater.define_global_access(class_flag, global_value);
  list_io.write_global_access(FALSE, class_flag, global_value, global_access,
    last_status);
  list_access.unlock_entry(validator)
end (* update_global_access *);




(**********************  node_host_list_utility  ************************)
(*									*)
(*			     read_next_list				*)
(*									*)
(*      Return the description of a LIST given its list_descriptor.	*)
(*									*)
(************************************************************************)

procedure entry READ_NEXT_LIST(
      list_desc		: list_descriptor;
  var validator_list	: validator_named_list_definition);

begin
  last_status := NODE_HOST_OK;
  list_io.read_list(list_desc, validator_list.named_list, last_status);
  set_sorted_flag(validator_list)
end (* read_next_list *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			     read_list					*)
(*									*)
(*      Return the description of a LIST.				*)
(*									*)
(************************************************************************)

procedure entry READ_LIST(
  var list_desc		: list_descriptor;
  var validator_list	: validator_named_list_definition);

begin
  last_status := NODE_HOST_OK;
  do_find_validator_list(validator_list, list_desc);
end (* read_list *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			    find_list					*)
(*									*)
(*      Locate the LIST described by list_to_find and			*)
(*	list_desc.host_flag and return list_desc.list_ptr.		*)
(*									*)
(************************************************************************)

procedure entry FIND_LIST(
      list_name	: named_list_name;
  var list_desc	: list_descriptor);

var
  list_to_find : named_list_definition;

begin
  last_status := NODE_HOST_OK;
  list_to_find.name := list_name;
  do_find_list(list_to_find, list_desc);
end (* find_list *);
!
(**********************  node_host_list_utility  ************************)
(*									*)
(*			     create_list				*)
(*									*)
(************************************************************************)

procedure entry CREATE_LIST(
  var validator_list	: validator_named_list_definition);

begin
  last_status := NODE_HOST_OK;
  list_locked.host_flag := validator_list.host_flag;
  list_access.lock_named_list(validator, validator_list.host_flag,
    validator_list.named_list.name, last_status);
  if last_status = NODE_HOST_OK
  then
    begin
      do_find_validator_list(validator_list, list_locked);
      if last_status = NODE_HOST_OK
      then last_status := NODE_HOST_LIST_FOUND
      else
        if last_status = NODE_HOST_LIST_NOT_FOUND
	then
	  begin
	    last_status := NODE_HOST_OK;
	    list_allocater.allocate(list_locked, last_status)
          end;
      if last_status = NODE_HOST_OK
      then creating_list := TRUE
      else list_access.unlock_entry(validator)
    end
end (* create_list *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			      modify_list				*)
(*									*)
(*      Set up to change an existing HOST or NODE LIST.			*)
(*									*)
(************************************************************************)

procedure entry MODIFY_LIST(
  var this_list	: validator_named_list_definition);

begin
  last_status := NODE_HOST_OK;
  list_locked.host_flag := this_list.host_flag;
  list_access.lock_named_list(validator, list_locked.host_flag,
    this_list.named_list.name, last_status);
  if last_status = NODE_HOST_OK
  then
    begin
      do_find_validator_list(this_list, list_locked);
      if last_status <> NODE_HOST_OK
      then list_access.unlock_entry(validator)
    end
end (* modify_list *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*				update_list				*)
(*									*)
(*      Change the NODE or HOST LIST description; MODIFY_LIST or	*)
(*	CREATE_LIST must have been called previously.			*)
(*									*)
(************************************************************************)

procedure entry UPDATE_LIST(
  var validator_list	: validator_named_list_definition);

begin
  last_status := NODE_HOST_OK;
  list_io.write_list(list_locked, validator_list.named_list, last_status);
  list_access.unlock_entry(validator);
  creating_list := FALSE
end (* update_list *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			     delete_list				*)
(*									*)
(*      Delete the LIST; modify_list must have previously		*)
(*	been called.							*)
(*									*)
(************************************************************************)

procedure entry DELETE_LIST(
  var found_group	: boolean;
  var group_no		: group_index;
  var class_no		: class_index);

var
  temp_list : named_list_definition;

begin
  last_status := NODE_HOST_OK;
  found_group := FALSE; class_no := FIRST_CLASS;

  if list_locked.host_flag
  then check_list_reference(FALSE, FIRST_GROUP, MAXIMUM_GROUP, group_no);

  if last_status = NODE_HOST_LIST_IN_USE
  then found_group := TRUE
  else check_list_reference(TRUE, FIRST_CLASS, MAXIMUM_CLASS, class_no);

  if last_status = NODE_HOST_OK
  then
    begin
      list_allocater.deallocate(list_locked);
      temp_list.name.size := 0;
      if last_status = NODE_HOST_OK
      then list_io.write_list(list_locked, temp_list, last_status)
    end;
  list_access.unlock_entry(validator)
end (* delete_list *);
!


(**********************  node_host_list_utility  ************************)
(*									*)
(*			     defined_group				*)
(*									*)
(*	Set defined to TRUE if group is defined or zero;		*)
(*      Set allowed_to_be_home TRUE if this group is allowed to be	*)
(*	a home in an access profile (it must be a non-negative group	*)
(*	and not zero).							*)
(*									*)
(************************************************************************)

procedure entry DEFINED_GROUP(
      group_no			: univ integer;
  var defined			: boolean;
  var allowed_to_be_home	: boolean);

var
  group_desc : global_access_description;

begin
  last_status := NODE_HOST_OK;
  allowed_to_be_home := FALSE;
  defined := TRUE;
  if group_no <> 0
  then
    if not list_allocater.global_access_defined(FALSE, group_no)
    then defined := FALSE
    else
      begin
        list_io.read_global_access(FALSE, group_no, group_desc, last_status);
	allowed_to_be_home := not group_desc.exception
      end
end (* defined_group *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			   defined_class				*)
(*									*)
(*      Return TRUE if this class is zero or defined.			*)
(*									*)
(************************************************************************)

function entry DEFINED_CLASS(
      class_no	: univ integer) : boolean;

begin
  last_status := NODE_HOST_OK;
  if class_no = 0
  then defined_class := TRUE
  else defined_class := list_allocater.global_access_defined(TRUE, class_no)
end (* defined_class *);
!



(**********************  node_host_list_utility  ************************)
(*									*)
(*			    do_report_status				*)
(*									*)
(************************************************************************)

procedure do_report_status(
      user_terminal	: circuit_handler;
      specify_list	: boolean (* TRUE if list is to be specified *);
      list_desc		: list_descriptor;
      status		: node_host_utility_status);

begin
  if specify_list
  then
    begin
      format.start_message('error on \');
      if list_desc.host_flag
      then format.string(HOST_MESSAGE)
      else format.string(NODE_MESSAGE);
      format.string(LIST_MESSAGE);
      format.character(ASCII_SPACE);
      format.number(list_desc.list_ptr, 10);
      format.colon_space
    end
  else format.start;
  format.named_list_status(status);
  format.write_line(user_terminal)
end (* do_report_status *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			     report_status				*)
(*									*)
(************************************************************************)

procedure entry REPORT_STATUS(
      user_terminal	: circuit_handler;
      specify_list	: boolean (* TRUE if list is to be specified *);
      list_desc		: list_descriptor;
      status		: node_host_utility_status);

begin
  do_report_status(user_terminal, specify_list, list_desc, status)
end (* report_status *);
!
"
		Table Conversion Routines
"



(**********************  node_host_list_utility  ************************)
(*									*)
(*			    set_halfword_bit				*)
(*									*)
(*      Set bit on in halfword.						*)
(*									*)
(************************************************************************)

procedure set_halfword_bit(
      bit	: integer;
  var value	: halfword);

var
  word_value : integer;

begin
  mutil.save_halfword_in_word(value, word_value);
  mutil.set_bit(bit, word_value);
  mutil.save_word_in_halfword(word_value, value)
end (* set_halfword_bit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**********************  node_host_list_utility  ************************)
(*									*)
(*			 read_global_access_list			*)
(*									*)
(************************************************************************)

procedure read_global_access_list(
      user_terminal	: circuit_handler;
      class_flag	: boolean (* TRUE if CLASS *);
      global_value	: univ integer;
      list_desc		: list_descriptor;
  var named_list	: named_list_definition);

begin
  list_io.read_list(list_desc, named_list, last_status); 
  if named_list.name.size = 0
  then last_status := NODE_HOST_LIST_NOT_FOUND;
  if last_status <> NODE_HOST_OK
  then
    begin
      if class_flag
      then format.start_message(CLASS_MESSAGE)
      else format.start_message(GROUP_MESSAGE);
      format.number(global_value, 10);
      format.colon_space;
      format.write_block(user_terminal);
      do_report_status(user_terminal, TRUE, list_desc, last_status);
      user_terminal.write_quoted_text_line('list will not be in table\')
    end
end (* read_global_access_list *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			   init_table_entry				*)
(*									*)
(*	Read the definition of the global access described by		*)
(*	class_flag and global_value, and set up initial values for	*)
(*	the table.							*)
(*									*)
(************************************************************************)

procedure init_table_entry(
      class_flag	: boolean (* TRUE if a CLASS *);
      global_value	: univ integer;
      table_location	: integer (* ptr to beg of this definition *);
  var global_access	: global_access_description;
  var index		: halfword;
  var count		: halfword);

begin
  if list_allocater.global_access_defined(class_flag, global_value)
  then
    begin (* global accessis defined *)
      list_io.read_global_access(class_flag, global_value, global_access,
        last_status);
      if last_status <> NODE_HOST_OK
      then global_access.count := 0
    end (* global accessis defined *)
  else global_access.count := 0;
  if global_access.count = 0
  then
    begin (* empty or error in global access...store table index and count *)
      index := ZERO_HALFWORD;
      count := ZERO_HALFWORD
    end (* empty or error in global access...store table index and count *)
(* if non-empty, store pointer to first table list value *)
  else mutil.save_word_in_halfword(table_location, index)
end (* init_table_entry *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			 save_next_table_entry				*)
(*									*)
(************************************************************************)

procedure save_next_table_entry(
      host_flag		: boolean;
      class_flag	: boolean;
      value		: integer;
  var table_count	: integer;
  var table_location	: integer (* ptr to beg of global access definition *);
  var table_entry	: halfword);

begin
  mutil.save_word_in_halfword(value, table_entry);
  if host_flag and class_flag
  then set_halfword_bit(HALFWORD_HOST_BIT, table_entry);
  table_count := table_count + 2;
  table_location := table_location + 2
end (* save_next_table_entry *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			   store_table_count				*)
(*									*)
(************************************************************************)

procedure store_table_count(
      table_count	: integer;
      exception		: boolean;
  var count		: halfword);

begin
  mutil.save_word_in_halfword(table_count, count);
  if exception
  then set_halfword_bit(HALFWORD_EXCEPTION_BIT, count)
end (* store_table_count *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			   create_class_table				*)
(*									*)
(************************************************************************)

procedure create_class_table(
      user_terminal	: circuit_handler;
  var class_defs	: table_class_definitions;
  var class_values	: table_class_list);

var
  class_list_index : table_class_list_index;
  class_no	: class_index;
  global_access	: global_access_description;
  global_index	: global_access_list_entry_index;
  named_list	: named_list_definition;
  value_index	: named_list_index;
  table_count	: integer;
  table_location: integer (* ptr to beginning of global access definition *);
  done : boolean;

begin
  (* set all class values in TABLE list to zero *)
  for class_list_index := 0 to TABLE_CLASS_LIST_HALFWORD_LIMIT do
    class_values[class_list_index] := ZERO_HALFWORD;

  class_list_index := 0 (* place to put next value in SUPERVISOR table *);
  table_location := FIRST_TABLE_CLASS_VALUE_POINTER (* ptr to SUP table *);
  
(* For each class, store pointer to beginning of list of values, read	*)
(* each list referred to, store list values from named list(s) and	*)
(* store count of list values.						*)
  for class_no := FIRST_CLASS to MAXIMUM_CLASS do
    begin
      init_table_entry(TRUE, class_no, table_location, global_access,
        class_defs[class_no].index, class_defs[class_no].count);
      table_count := 0 (* initialize count of entries in this list *);
      if global_access.count <> 0
      then
        begin (* For each list, read the list and store each value *)
	  for global_index := 0 to global_access.count - 1 do
	    begin
	      read_global_access_list(user_terminal, TRUE, class_no,
	        global_access.lists[global_index], named_list);
	      value_index := 0; done := FALSE;
	      if last_status <> NODE_HOST_OK
	      then last_status := NODE_HOST_OK (* already put err., cont. *)
	      else (* save values for list in table *)
	        while not done and (last_status = NODE_HOST_OK) do
		  begin
		    save_next_table_entry(
		      global_access.lists[global_index].host_flag,
		      TRUE, named_list.values[value_index], table_count,
		      table_location, class_values[class_list_index]);
		    if value_index = named_list.count - 1
		    then done := TRUE
		    else value_index := value_index + 1;
		    if class_list_index = TABLE_CLASS_LIST_HALFWORD_LIMIT
		    then last_status := NODE_HOST_FULL
		    else class_list_index := class_list_index + 1
		  end (* while *)
	    end (* for global_index *);
	  store_table_count(table_count, global_access.exception,
	    class_defs[class_no].count);
	end (* For each list, read the list and store each value *)
    end (* for class_no *)
end (* create_class_table *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*			   create_group_table				*)
(*									*)
(************************************************************************)

procedure create_group_table(
      user_terminal	: circuit_handler;
  var group_defs	: table_group_definitions;
  var group_values	: table_group_list);

var
  group_list_index	: table_group_list_index;
  group_no	: group_index;
  global_access	: global_access_description;

  global_index	: global_access_list_entry_index;
  named_list	: named_list_definition;
  value_index	: named_list_index;
  table_count	: integer;
  table_location: integer (* ptr to beginning of global access definition *);
  done : boolean;

begin
  (* set all group values in TABLE list to zero *)
  for group_list_index := 0 to TABLE_GROUP_LIST_HALFWORD_LIMIT do
    group_values[group_list_index] := ZERO_HALFWORD;
  group_list_index := 0 (* place to put next value *);
  table_location := FIRST_TABLE_GROUP_VALUE_POINTER;

(* For each group, store pointer to beginning of list of values, read	*)
(* each list referred to, store list values from named list(s) and	*)
(* store count of list values.						*)
  for group_no := FIRST_GROUP to MAXIMUM_GROUP do
    begin
      init_table_entry(FALSE, group_no, table_location, global_access,
        group_defs[group_no].index, group_defs[group_no].count);
      table_count := 0 (* initialize count of entries in this list *);
      if global_access.count <> 0
      then
        begin (* For each list, read the list and store each value *)
	  for global_index := 0 to global_access.count - 1 do
	    begin
	      read_global_access_list(user_terminal, FALSE, group_no,
	        global_access.lists[global_index], named_list);
	      value_index := 0; done := FALSE;
	      if last_status <> NODE_HOST_OK
	      then last_status := NODE_HOST_OK (* already put err., cont. *)
	      else (* save values for list in table *)
	        while not done and (last_status = NODE_HOST_OK) do
	          begin
		    save_next_table_entry(
		      global_access.lists[global_index].host_flag,
		      FALSE, named_list.values[value_index], table_count,
		      table_location, group_values[group_list_index]);
		    if value_index = named_list.count - 1
		    then done := TRUE
		    else value_index := value_index + 1;
		    if group_list_index = TABLE_GROUP_LIST_HALFWORD_LIMIT
		    then last_status := NODE_HOST_FULL
		    else group_list_index := group_list_index + 1
		  end (* while *)
	    end (* for global_index *);
	  store_table_count(table_count, global_access.exception,
	    group_defs[group_no].count);
	end (* For each list, read the list and store each value *)
    end (* for group_no *)
end (* create_group_table *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**********************  node_host_list_utility  ************************)
(*									*)
(*			      create_table				*)
(*									*)
(*      This is the biggie!! Create the Supervisor Class/group Table	*)
(*	from the descriptions in the NODE_HOST_FILE.			*)
(*									*)
(************************************************************************)

procedure entry CREATE_TABLE(
      user_terminal	: circuit_handler;
  var class_group	: class_group_table);

begin
  last_status := NODE_HOST_OK;
  with class_group do
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      create_class_table(user_terminal, class_defs, class_values);
      if last_status = NODE_HOST_OK
      then create_group_table(user_terminal, group_defs, group_values)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* with *)
end (* create_table *);



(**********************  node_host_list_utility  ************************)
(*									*)
(*				abort					*)
(*									*)
(*      Unlock the locked entity.					*)
(*									*)
(************************************************************************)

procedure entry ABORT;

begin
  list_access.unlock_entry(validator);
  if creating_list
  then list_allocater.deallocate(list_locked)
end (* abort *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil;

  creating_list := FALSE
end (* node_host_list_utility *);
!
(************************************************************************)
(*									*)
(*	SYMACC.NTV							*)
(*									*)
(*			 sysmsg1_access_manager				*)
(*									*)
(*	The sysmsg1_access_manager Monitor controls access to the	*)
(*	SYSMSG circuit.							*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*	24APR86 - rsb							*)
(*		- remove "+1" from after subtraction operation in 	*)
(*		  definition of MAXIMUM_SYSMSG1_USERS			*)
(*	10Oct83	Original -- jrn						*)
(*									*)
(************************************************************************)

type SYSMSG1_ACCESS_MANAGER = monitor;


(*	The following describes users of SYSMSG1.		*)
(*	Privileged validators and the CLASS_GROUP_UPDATER	*)
(*	Process are the only users.  The FIFO Class, NEXT,	*)
(*	which controls the ordered list of waiters for the	*)
(*	circuit is initialized with ORIGIN as			*)
(*	FIRST_SYSMSG1_USER, limit as MAXIMUM_SYSMSG1_USERS.	*)

const
  FIRST_SYSMSG1_USER = first_licensed_validator;
  TABLE_UPDATER_USER = validator_limit + 1;
  LAST_SYSMSG1_USER = table_updater_user;

  MAXIMUM_SYSMSG1_USERS = last_sysmsg1_user - first_sysmsg1_user;


type
  SYSMSG1_USER_INDEX = first_sysmsg1_user..last_sysmsg1_user;


var
  next : fifo;


(* The current circuit access: *)
  sysmsg1_available : boolean;



(* The following is the ordered list of waiters for the	*)
(* circuit.  Users are added to the list at fifo.arrival*)
(* and removed at fifo.departure.			*)

  waiting_for_circuit : array [sysmsg1_user_index] of queue;
!



(**********************  sysmsg1_access_manager  ************************)
(*									*)
(*			     access_circuit				*)
(*									*)
(*      Access the SYSMSG1 circuit.					*)
(*									*)
(************************************************************************)

procedure entry ACCESS_CIRCUIT;

begin
  if not sysmsg1_available
  then delay(waiting_for_circuit[next.arrival]) (* delay caller *);

  sysmsg1_available := FALSE (* user got the circuit *)
end (* access_circuit *);



(**********************  sysmsg1_access_manager  ************************)
(*									*)
(*			     release_circuit				*)
(*									*)
(*      Release the circuit.						*)
(*									*)
(************************************************************************)

procedure entry RELEASE_CIRCUIT;

begin
  sysmsg1_available := TRUE;
  if not next.empty
  then continue(waiting_for_circuit[next.departure])
end (* release_circuit *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init next(FIRST_SYSMSG1_USER, MAXIMUM_SYSMSG1_USERS);

  sysmsg1_available := TRUE
end (* sysmsg1_access_manager *);
!
(************************************************************************)
(*									*)
(*	SYMUTL.NTV							*)
(*									*)
(*				sysmsg1_utility				*)
(*									*)
(*	The SYSMSG1_UTILITY Class communicates with the Supervisor	*)
(*	slave SYSMSG1 in order to transmit and recieve copies of the	*)
(*	Supervisor Class/group Table.					*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  real_supervisor_index, login_string, sysmsg1_user_index,	*)
(*	  table_in_chars						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	23Oct86 - neh							*) 
(*	      - Change report_message to report_supervisor_message	*)
(*	21Jan86 - jrn							*)
(*	      - use control-I in login string				*)
(*	03Jan86	- rsb
(*		- every "sup : supervisor_index" changes into
(*                      "real_sup : real_supervisor_index"
(*		- every "sup" changes into "real_sup"
(*	06Jul84	Version 2.02 - jrn					*)
(*	      - add SYSMSG1_UNEXPECTED_INPUT to sysmsg1_status		*)
(*	11/10/83	Original -- jrn					*)
(*									*)
(************************************************************************)


type SYSMSG1_UTILITY = class(
	aux_io		: circuit_handler;
	format		: internal_to_string;
	oper_messages	: operator_messages;
	sysmsg1_access	: sysmsg1_access_manager);


const (* SYSMSG1 login string information: *)
  SYSMSG1_LOGIN_STRING_SIZE = 14 (* total size of string *);
  SYSMSG1_LOGIN_STRING_SUP_CHAR = 12 (* place to store sup no. *);

  SYSMSG1_LOGIN_STRING_TEXT =
    '(:9:)(:4:)SYSMSG1:12x;                                            ';


(* SYSMSG1 commands: *)
  SYSMSG1_RECEIVE_TABLE = '(:10:)';
  SYSMSG1_TRANSMIT_TABLE = '(:11:)';


(* SYSMSG1 answer code: *)
  SYSMSG1_RECEIVED_TABLE = '(:6:)';


var
  circuit_util : circuit_utility;
!



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			      report_error				*)
(*									*)
(*      Report the status to the operator_log; if status is		*)
(*	SYSMSG1_CIRUIT_ERROR or SYSMSG1_BUILD_FAILURE, report		*)
(*	port_handler.param.status.					*)
(*									*)
(************************************************************************)

procedure report_error(
      real_sup	: real_supervisor_index;
      status	:  sysmsg1_status);

begin
  format.start;
  format.sysmsg1_error(status, aux_io.param.status,
    aux_io.param.arg2);
  oper_messages.report_supervisor_message(real_sup, SYSMSG1_OPLOG_MSG)
end (* report_error *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			   check_circuit_status				*)
(*									*)
(*      Set sysmsg_status if there is a circuit problem.		*)
(*									*)
(************************************************************************)

procedure check_circuit_status(
      real_sup          : real_supervisor_index;
      error_status	: sysmsg1_status;
  var status		: sysmsg1_status);

begin
  if not aux_io.available
  then
    begin
      status := error_status;
      report_error(real_sup, status)
    end
end (* check_circuit_status *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			  build_sysmsg1_circuit				*)
(*									*)
(*      Build a circuit to SYSMSG1 for the supervisor.			*)
(*									*)
(************************************************************************)

procedure build_sysmsg1_circuit(
      real_sup  : real_supervisor_index;
  var status	: sysmsg1_status);

var
  login : login_string;
  receive_buffer : char;

begin
  status := SYSMSG1_SUCCESSFUL;
  sysmsg1_access.access_circuit;
  login.size := SYSMSG1_LOGIN_STRING_SIZE;
  login.text := SYSMSG1_LOGIN_STRING_TEXT;
  login.text[SYSMSG1_LOGIN_STRING_SUP_CHAR] := chr(ord('0') + real_sup);
  aux_io.build_aux_circuit(SYSMSG_CIRCUIT, [COMPLETE], 60, login);
  aux_io.set_timeout(300);
  check_circuit_status(real_sup, SYSMSG1_BUILD_FAILURE, status);
  if status = SYSMSG1_SUCCESSFUL
  then
    begin
      circuit_util.exchange_handshake(STANDARD_HANDSHAKE);
      check_circuit_status(real_sup, SYSMSG1_HANDSHAKE_ERROR, status);
      if status = SYSMSG1_SUCCESSFUL
      then
        begin
	  aux_io.read_one_character(receive_buffer);
	  check_circuit_status(real_sup, SYSMSG1_HANDSHAKE_ERROR, status);
	  if ord(receive_buffer) <> (real_sup + PRINT_SUPERVISOR_OFFSET)
	  then status := SYSMSG1_HANDSHAKE_ERROR
	end
    end;
  if status <> SYSMSG1_SUCCESSFUL
  then sysmsg1_access.release_circuit
end (* build_sysmsg1_circuit *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			    send_table_to_sup				*)
(*									*)
(*      Transmit a new Class/group table to a Supervisor.		*)
(*									*)
(************************************************************************)

procedure entry SEND_TABLE_TO_SUP(
      real_sup	: real_supervisor_index;
  var new_table	: univ table_in_bytes;
  var status	: sysmsg1_status);

var
  byte_input : char;

begin 
  build_sysmsg1_circuit(real_sup, status);
  if status = SYSMSG1_SUCCESSFUL
  then
    begin
      aux_io.write_one_character(SYSMSG1_TRANSMIT_TABLE);
      check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
      if status = SYSMSG1_SUCCESSFUL
      then
        begin
          aux_io.write_class_group_table(new_table);
          check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status)
        end;
      if status = SYSMSG1_SUCCESSFUL
      then

(*      Input a character, check the circuit and be sure character	*)
(*	is SYSMSG1_RECEIVED_TABLE; if error, set status and report	*)
(*	the error.							*)

        begin
	  aux_io.read_one_character(byte_input);
	  check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
	  if (status = SYSMSG1_SUCCESSFUL) and
	    (byte_input <> SYSMSG1_RECEIVED_TABLE)
	  then
	    begin
	      status := SYSMSG1_UNEXPECTED_INPUT;
	      report_error(real_sup, status)
	    end
	end;

      aux_io.clear_circuit;
      sysmsg1_access.release_circuit
    end
end (* send_table_to_sup *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			     read_sup_table				*)
(*									*)
(*      Return the Class/group table for a Supervisor.			*)
(*									*)
(************************************************************************)

procedure entry READ_SUP_TABLE(
      real_sup  : real_supervisor_index;
  var table	: univ table_in_bytes;
  var status	: sysmsg1_status);

begin
  build_sysmsg1_circuit(real_sup, status);
  if status = SYSMSG1_SUCCESSFUL
  then
    begin
      aux_io.write_one_character(SYSMSG1_RECEIVE_TABLE);
      check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
      if status = SYSMSG1_SUCCESSFUL
      then
        begin
          aux_io.read_class_group_table(table);
          check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status)
        end;
      aux_io.clear_circuit;
      sysmsg1_access.release_circuit
    end
end (* read_sup_table *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init circuit_util(aux_io)
end (* sysmsg1_utility *);
!
(************************************************************************)
(*									*)
(*	CGUPD.NTV							*)
(*									*)
(*			    class_group_updater				*)
(*									*)
(*	The class_group_updater Process is responsible for updating	*)
(*	the Supervisor Class/group tables.				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  supervisor_index, table_in_bytes, sysmsg1_status		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	06Jan86	- rsb							*)
(*		- every "sup : supervisor_index" changes into		*)
(*                      "real_sup : real_supervisor_index"		*)
(*		- every "sup" changes into "real_sup"			*)
(*		- Loop counter changes from MAXIMUM_EXPECTED_SUPERVISOR	*)
(*		  to MAXIMUM_REAL_SUPERVISOR.				*)
(*	21Jul84 Version 3.00 - jrn/pgl					*)
(*	      - added parameter values of FIRST_CIRCUIT_RETRY_DELAY	*)
(*		and MAXIMUM_CIRCUIT_RETRY_DELAY to init of 		*)
(*		delay_utility						*)
(*	11Oct83	Original -- jrn						*)
(*									*)
(************************************************************************)

type CLASS_GROUP_UPDATER = process(
	oplog		: operator_log;
	mud_change	: mud_change_handler;
	sysmsg1_access	: sysmsg1_access_manager;
	table_access	: class_group_handler);


var
  mutil         : misc_utility;
  delay_utility : circuit_delay_utility;
  aux_io        : circuit_handler;
  format        : internal_to_string;
  oper_messages : operator_messages;
  sysmsg1_util  : sysmsg1_utility;
!
(************************  class_group_updater  *************************)
(*									*)
(*			  update_class_group_table			*)
(*									*)
(*      This is the main control loop.  The mud_change_handler is	*)
(*	checked for legal supervisors and out-of-date tables.		*)
(*									*)
(************************************************************************)

procedure update_class_group_table;

var
  real_sup : real_supervisor_index;
  table : table_in_bytes;
  no_failure, (* TRUE if no updates necessary or all were successful *)
  success : boolean;
  status : sysmsg1_status;

begin
  cycle
    no_failure := TRUE;
    for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
      begin
        success := TRUE;
        if mud_change.table_to_send(real_sup)
        then
          begin (* get and send table to Supervisor *)
	    table_access.read_table(table, success);
	    if success
	    then

(*      Transmit the table to the supervisor, and notify the		*)
(*	mud_change_handler of the result.  Set success to FALSE		*)
(*	if failure.							*)

	      begin (* got table, send it *)
		sysmsg1_util.send_table_to_sup(real_sup, table, status);
		success := status = SYSMSG1_SUCCESSFUL;
		if success
		then mud_change.set_sup_table_status(
                                             real_sup, CLASS_GROUP_UPDATED)
		else mud_change.set_sup_table_status(
                                             real_sup, CLASS_GROUP_FAILED)
	      end (* got table, send it *)
	  end (* get and send table to Supervisor *);
	if not success
	then no_failure := FALSE
      end (* for *);

    if no_failure
    then delay_utility.reset_delay;
    delay_utility.delay
  end (* cycle *)
end (* update_class_group_table *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, delay_utility(FIRST_CIRCUIT_RETRY_DELAY, SEND_TABLE_DELAY),
    aux_io(mutil), format, oper_messages(oplog, format),
    sysmsg1_util(aux_io, format, oper_messages, sysmsg1_access);

  update_class_group_table
end (* class_group_updater *);
!
(************************************************************************)
(*									*)
(*	logutl.ntv							*)
(*									*)
(*				LOGIN_UTILITY				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	Original - jrn							*)
(*									*)
(************************************************************************)

type login_utility = class(
	mutil		: misc_utility;
	user_terminal	: circuit_handler;
	format		: internal_to_string
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;
	login_pool	: login_distributer);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


var
  entry unit : terminal_unit_index;



(**************************  login_utility  *****************************)
(*									*)
(*			       access_denied				*)
(*									*)
(************************************************************************)

procedure entry ACCESS_DENIED(
      deny_message	: quoted_text);

begin
  user_terminal.write_line_and_quoted_text_line(DENY_MESSAGE);
  user_terminal.wait_for_output;
  user_terminal.clear_circuit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  login_pool.release_unit(unit)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* access_denied *);



(**************************  login_utility  *****************************)
(*									*)
(*				get_login				*)
(*									*)
(************************************************************************)

procedure entry GET_LOGIN(
  var name	: username_string;
  var needle	: needle_record);

var
  name_pointer : username_text_index;
  needle_pointer : needle_name_index;
  first_needle_char : needle_name_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  login_pool.get_available_unit(unit);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  user_terminal.login(unit, [COMPLETE, BREAK_KEY, ORANGE_BALL], needle);

(*	Translate the needle name (already in UPPER case) to a		*)
(*	username_string.  The needle.number_of_characters includes	*)
(*	a carriage-return character at the end; if the user has "login	*)
(*	over shut", there will be a leading "!" character in the name,	*)
(*	so ignore it.							*)

  if needle.login_name[0] = '!'
  then first_needle_char := 1 (* user has login over shut option *)
  else first_needle_char := 0;
  name.size := needle.number_of_characters - first_needle_char - 1;
  name_pointer := 0;
  for needle_pointer := first_needle_char to
    needle.number_of_characters - 2 do
    begin
      name.text[name_pointer] := needle.login_name[needle_pointer];
      name_pointer := name_pointer + 1
    end
end (* get_login *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* login_utility *);
!
(************************************************************************)
(*									*)
(*	LOGONP.NTV							*)
(*									*)
(*				ACCEPT_LOGIN				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  terminal_unit_index, username_string, validator_index,	*)
(*	  validator_type, circuit_handler				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	21Jul86 - jrn							*)
(*	      - if user is logging in with an auxilliary circuit,	*)
(*		prompt and check for password				*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	11Dec84 - jrn							*)
(*	      - move code to login_utility for use by initial process	*)
(*		for logical volumes					*)
(*	04Aug84 jrn/pgl							*)
(*	      - removed functions, user_is_operator and 		*)
(*		user_is_programmer					*)
(*	      - added function name_match				*)
(*	      - changed procedure process_validator_login to handle	*)
(*		MASTER_VALIDATOR					*)
(*	15Jun84 jrn							*)
(*	      - removed oper_messages from initialization of		*)
(*		cud_block_updater					*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added licenses (passes options to login monitor)	*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
type ACCEPT_LOGIN = process(
	statistics	: statistics_gatherer;
	oplog		: operator_log;
	mud_change	: mud_change_handler;
	cud_access	: cud_access_controller;
	cud_parameter	: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	name_access	: cud_name_controller;
	login_pool	: login_distributer);


var
  mutil		: misc_utility;
  user_terminal : circuit_handler;
  format	: internal_to_string;
  log_util	: login_utility;
  oper_messages	: operator_messages;

  dsksys	: disk_system;
  block_updater : cud_block_updater;
  block_utility : cud_block_utility;
  cud_utility	: cud_entry_utility;
  cud_updater	: cud_entry_updater;
  password_read	: password_reader;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  accept_login  *****************************)
(*									*)
(*			process_validator_login				*)
(*									*)
(************************************************************************)

procedure process_validator_login;

var
  login_info : validator_login_information;
  found_in_cud,
  valid_netval_user : boolean;
  bad_password : boolean;
  success : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  valid_netval_user := FALSE; bad_password := FALSE;
  log_util.get_login(login_info.name, login_info.needle);
  login_info.unit := log_util.unit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    if (ord(login_info.needle.terminal_id) mod 64) = 0
    then (* logging in on AUX CIRCUIT *)
      if password_read.ciphered_password <>
        cud_updater.cud_password(login_info.name)
      then
        begin (* illegal password entered *)
	  log_util.access_denied(PASSWORD_ERROR);
	  found_in_cud := FALSE;
	  bad_password := TRUE
	end (* illegal password entered *);
  if not bad_password
  then
    if mutil.same_name(PROGRAMMER_NAME, PROGRAMMER_NAME_SIZE, login_info.name)
    then
      begin (* programmer logging in *)
        login_info.level := PROGRAMMER_VALIDATOR;
	login_info.gan := 0;
	login_info.options := [];
	valid_netval_user := TRUE
      end (* programmer logging in *)
    else
      begin (* non-programmer logging in, check CUD info *)
        cud_updater.read_small_cud_entry(login_info.name, login_info.gan,
	  login_info.options);
	found_in_cud := cud_updater.last_status = CUD_ENTRY_OK;
	if not found_in_cud
	then
	  if cud_updater.last_status = CUD_ENTRY_NOT_FOUND
	  then log_util.access_denied('your username is not in the CUD\')
	  else
	    begin (* cud_updater.last_status <> CUD_ENTRY_NOT_FOUND *)
	      format.start;
	      format.cud_entry_status(cud_updater.last_status);
	      format.write_line(user_terminal)
	    end (* cud_updater.last_status <> CUD_ENTRY_NOT_FOUND *);
	if found_in_cud
	then
	  begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      begin (* process any other type of user logging in *)
	        valid_netval_user := TRUE;
		if NETWORK_ADMINISTRATOR in login_info.options
		then login_info.level := NETWORK_ADMINISTRATOR_VALIDATOR
		else
		  if ACCOUNT_SUPERVISOR in login_info.options
		  then login_info.level := ACCOUNT_SUPERVISOR_VALIDATOR
		  else
		    if not (NO_PASSWORD in login_info.options)
		    then login_info.level := PASSWORD_ONLY_VALIDATOR
		    else valid_netval_user := FALSE
	      end (* process any other type of user logging in *)
	  end (* name found in CUD *)
    end (* non-programmer logging in, check CUD info *);
  if valid_netval_user
  then
    begin
      login_pool.login_validator(login_info, success);
      if not success
      then log_util.access_denied('no port available\')
    end (* valid_netval_user *)
  else
    if found_in_cud
    then log_util.access_denied('you are not valid to use NETVAL\')
end (* process_validator_login *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init mutil, user_terminal(mutil), format,
    log_util(mutil, user_terminal, format, login_pool),
    oper_messages(oplog, format),
    dsksys(statistics),
    block_utility(mutil, oper_messages, format, dsksys),
    block_updater(mutil, statistics, dsksys, cud_access, block_utility,
      format),
    cud_utility(mutil, format, oper_messages),
    cud_updater(CUD_READER, mutil, format, login_pool, mud_change,
      oper_messages,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_utility, cud_access, block_updater, cud_parameter, name_access),
    password_read(mutil, format, user_terminal);

  cycle
    process_validator_login
  end (* cycle *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* accept_login *);
!
(************************************************************************)
(*									*)
(*	CONUTL.NTV							*)
(*									*)
(*		    configuration_utility class				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	19Dec85 - jrn							*)
(*	      - change sys_io.tym_file_terminal_count to		*)
(*		sys_io.sys_info.number_of_terminals, and		*)
(*		sys_io.tym_file_aux_circuit_count to			*)
(*		sys_io.sys_info.number_of_aux_circuits			*)
(*	04Jan85 - jrn							*)
(*	      - add all common configuration checking code here for use	*)
(*		in both NETVAL and NVDM					*)
(*	      - add logical_volume_directory				*)
(*	13Aug84 - jrn							*)
(*	      - handle all configuration file operations here		*)
(*	      - make configuration comparasion routines available	*)
(*		to archive class					*)
(*									*)
(************************************************************************)


type configuration_utility = class(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		dsksys		: disk_system;
		sys_io		: system_handler);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


var
  dummy : integer (* to make conditional compliation flags correct *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  crash_util : crash_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(**********************  configuration_utility  *************************)
(*									*)
(*		     	    file_checksum				*)
(*									*)
(************************************************************************)

procedure file_checksum(
  var configuration	: univ configuration_information;
  var computed_checksum	: integer);

begin
  sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD, configuration,
    computed_checksum)
end (* file_checksum *);



(**********************  configuration_utility  *************************)
(*									*)
(*		     	    do_read_file				*)
(*									*)
(************************************************************************)

procedure do_read_file(
  var configuration	: univ configuration_information;
  var status		: file_utility_status);

var
  computed_checksum : integer;
  success : boolean;

begin
  status := FU_SUCCESS;
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    FILE_SYSTEM_DISK,
    DISK_READ,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CONFIGURATION_FILE_START, configuration, success);
  if success
  then
    begin
      file_checksum(configuration, computed_checksum);
      success := computed_checksum = configuration.checksum;
      if not success
      then
        begin
	  status := FU_CHECKSUM_ERROR;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	end
    end
  else
    begin
      status := FU_IO_ERROR;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* do_read_file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**********************  configuration_utility  *************************)
(*									*)
(*		     	     read_file					*)
(*									*)
(************************************************************************)

procedure entry READ_FILE(
  var configuration	: univ configuration_information;
  var status		: file_utility_status);

begin
  do_read_file(configuration, status)
end (* read_file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**********************  configuration_utility  *************************)
(*									*)
(*		     do_get_program_file_definition			*)
(*									*)
(************************************************************************)

procedure do_get_program_file_definition(
      index		: file_index;
  var defined_desc	: file_descriptor);

begin
  case index of
    CONFIGURATION_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := CONFIGURATION_FILE_START;
	defined_desc.length := CONFIGURATION_FILE_LENGTH
      end (* CONFIGURATION_FILE *);
    CUD_FILE:
      begin
        defined_desc.unit := CUD_DISK_UNIT;
	defined_desc.address := CUD_FILE_START;
	defined_desc.length := CUD_FILE_LENGTH
      end (* CUD_FILE *);
    CUD_PARAMETER_FILE:
      begin
        defined_desc.unit := CUD_DISK_UNIT;
	defined_desc.address := CUD_PARAMETER_FILE_START;
	defined_desc.length := CUD_PARAMETER_FILE_LENGTH
      end (* CUD_PARAMETER_FILE *);
    NODE_HOST_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := NODE_HOST_FILE_START;
	defined_desc.length := NODE_HOST_FILE_LENGTH
      end (* NODE_HOST_FILE *);
    MUD_UPDATE_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := MUD_UPDATE_FILE_START;
	defined_desc.length := MUD_UPDATE_FILE_LENGTH
      end (* MUD_UPDATE_FILE *);
    CLASS_GROUP_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := CLASS_GROUP_FILE_START;
	defined_desc.length := CLASS_GROUP_FILE_LENGTH
      end (* CLASS_GROUP_FILE *);
    OPERLOG_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := OPERLOG_FILE_START;
	defined_desc.length := OPERLOG_FILE_LENGTH
      end (* OPERLOG_FILE *)
  end (* case *)
end (* do_get_program_file_definition *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  configuration_utility  ************************)
(*									*)
(*			do_check_integer_mismatch			*)
(*									*)
(************************************************************************)

procedure do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      program_value	: univ integer;
      file_value	: univ integer;
  var all_match		: boolean);

begin
  if program_value <> file_value
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
end (* do_check_integer_mismatch *);



(***********************  configuration_utility  ************************)
(*									*)
(*			check_file_configuration_value			*)
(*									*)
(************************************************************************)

procedure check_file_configuration_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      program_value	: univ integer;
      file_value	: univ integer;
  var all_match 	: boolean);

begin
  if program_value <> file_value
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
end (* check_file_configuration_value *);



(***********************  configuration_utility  ************************)
(*									*)
(*			 check_file_descriptions			*)
(*									*)
(************************************************************************)

procedure check_file_descriptions(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      config_file	: file_system_descriptor;
  var all_match		: boolean);

var
  index : file_index;
  program_def : file_descriptor;

begin
  for index := FIRST_FILE to LAST_FILE do
    begin
      do_get_program_file_definition(index, program_def);

      check_file_configuration_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	program_def.unit, config_file[index].unit, all_match);

      check_file_configuration_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	program_def.address, config_file[index].address, all_match);

      check_file_configuration_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	program_def.length, config_file[index].length, all_match)
    end
end (* check_file_descriptions *);



(***********************  configuration_utility  ************************)
(*									*)
(*		          do_check_configuration			*)
(*									*)
(*	Check configuration against constants defined in NVALvv.Arr.	*)
(*									*)
(************************************************************************)

procedure do_check_configuration(
      print_results	: boolean;
      configuration	: univ configuration_information;
  var all_match		: boolean);

begin
  with configuration do
    begin
      if id <> NETVAL_ID
      then
        begin
	  all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	end (* id <> NETVAL_ID *);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	CURRENT_INCARNATION, incarnation_number, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	DISK_UNIT_ONE_SIZE, pages_on_disk_one, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	DISK_UNIT_ZERO_SIZE, pages_on_disk_zero, all_match);

      check_file_descriptions(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	files, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS, cud_block_size_in_sectors,
	all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_EXPECTED_SUPERVISORS, supervisors, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_CUD_BLOCK, cud_blocks, all_match);

      if INCLUDE_GAN <> gans
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      then all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if INCLUDE_DISTRICT <> districts
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
     then all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MINIMUM_PASSWORD_SIZE, password_size, all_match);

      if REQUIRE_NONALPHANUMERIC <> non_alpha_password
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      then all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if CLASS_0_GROUP_0_ASSIGNABLE <> zero_class_group_assignable
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      then all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if NETVAL_CUD_IS_A_MUD <> cud_is_mud
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      then all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PROGRAMMER_NAME_SIZE, programmer_size, all_match);

      if PROGRAMMER_NAME <> programmer
      then
        begin
	  all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	end;

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_HOST, hosts, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_NODE, nodes, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_CLASS, classes, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_CLASS_TABLE_SIZE, class_table_size, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_GROUP, groups, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_GROUP_TABLE_SIZE, group_table_size, all_match)
    end
end (* do_check_configuration *);



(***********************  configuration_utility  ************************)
(*									*)
(*			   check_tym_file_value				*)
(*									*)
(************************************************************************)

procedure check_tym_file_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      tym_file_value	: univ integer;
      program_value	: univ integer;
  var all_match		: boolean);

begin
  if program_value <> tym_file_value
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
end (* check_tym_file_value *);



(***********************  configuration_utility  ************************)
(*									*)
(*			     check_disk_sizes	 			*)
(*									*)
(************************************************************************)

procedure check_disk_sizes(
      first_unit	: integer;
      config_value	: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var disk_tape_info	: disk_tape_information;
  var all_match		: boolean);

var
  param : disk_param;

begin
  disk_tape_info.number_of_sectors := 0 (* in case of failure *);
  param.operation := DISK_INFO (* get size of unit from NUCLEUS *);
  io(disk_tape_info, param, DISK, first_unit);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if config_value <> disk_tape_info.number_of_sectors
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* config_value <> disk_tape_info.number_of_sectors *)
end (* check_disk_sizes *);



(***********************  configuration_utility  ************************)
(*									*)
(*			      check_tym_file	 			*)
(*									*)
(*	Check all TYM file values against NETVAL values.		*)
(*									*)
(************************************************************************)

procedure check_tym_file(
  var all_match	: boolean);

var
  disk_tape_info : disk_tape_information;
  required_unit_zero_size : integer;

begin
  required_unit_zero_size := CUD_FILE_LENGTH + CUD_PARAMETER_FILE_LENGTH;
  check_disk_sizes(0, DISK_UNIT_ZERO_SIZE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    disk_tape_info, all_match);

  if required_unit_zero_size > disk_tape_info.number_of_sectors
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* required_unit_zero_size > disk_tape_info.number_of_sectors *);

(* check the size of disk unit 1, NUCLEUS vs. NVALvv.Arr. *)
  check_disk_sizes(1, DISK_UNIT_ONE_SIZE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    disk_tape_info, all_match);

  check_tym_file_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    sys_io.sys_info.number_of_terminals,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    MAXIMUM_VALIDATOR, all_match);

  check_tym_file_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    sys_io.sys_info.number_of_aux_circuits-1, MAXIMUM_EXPECTED_SUPERVISORS,
    all_match)
end (* check_tym_file *);



(***********************  configuration_utility  ************************)
(*									*)
(*		             do_write_file				*)
(*									*)
(************************************************************************)

procedure do_write_file(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var configuration	: configuration_information;
  var ok		: boolean);

begin
  file_checksum(configuration, configuration.checksum);
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    FILE_SYSTEM_DISK,
    DISK_WRITE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CONFIGURATION_FILE_START, configuration, ok);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* do_write_file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  configuration_utility  ************************)
(*									*)
(*			 check_drive_configuration			*)
(*									*)
(*	For the givin unit, read and check the configuration file;	*)
(*	used at NETVAL initialization check the disk.  Crash if not ok.	*)
(*									*)
(************************************************************************)

procedure entry CHECK_DRIVE_CONFIGURATION(
      unit		: integer;
  var configuration	: configuration_information);

var
  status : file_utility_status;
  success : boolean;

begin
  success := TRUE;
  check_tym_file(success);
  if not success
  then crash_util.halt_slot;
  do_read_file(configuration, status);
  if status = FU_SUCCESS
  then do_check_configuration(FALSE, configuration, success);
  if not success
  then crash_util.halt_slot
end (* check_drive_configuration *);




(***********************  configuration_utility  ************************)
(*									*)
(*			  report_error_to_oplog				*)
(*									*)
(************************************************************************)

procedure entry REPORT_ERROR_TO_OPLOG(
      format		: internal_to_string;
      oper_messages	: operator_messages);

begin
  format.start_message('error on CONFIGURATION file\');
  oper_messages.report_message(FILE_OPLOG_MSG)
end (* report_error_to_oplog *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init crash_util;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* configuration_utility *);
!
(************************************************************************)
(*									*)
(*	CMDTAB.NTV							*)
(*									*)
(*			   command_table monitor			*)
(*									*)
(*	 This monitor contains the definition of all commands.	  	*)
(*	 It is accessed by terminal_input_scanner to lookup the	 	*)
(*	 particular command in question and returns the complete	*)
(*	 definition record for the command found.			*)
(*									*)
(*	The commands are distributed into command classes. Each class	*)
(*	has an array of command definitions associated with it.		*)
(*									*)
(*	The following identifiers must be defined externally:	   	*)
(*	  command_definition    keyword_definition			*)
(*	  scanned_command       command_token				*)
(*	  end_of_(class)	command_class_index			*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	22oCT86 - neh							*)
(*	      - Change license for new user, change user, new access,	*)
(*		delete user and delete access to NETWORK ADMINISTRATOR	*)
(*		if NETVAL_IS_A_SLAVE is enabled.			*)
(*	03Sep86 - neh							*) 
(*	      - Changes made to add FILTER commands			*)
(*	      - Add string constants FILTER_KEYWORD_STRING,		*) 
(*		PASSWORD_KEYWORD_STRING, 				*)
(*		DELETE_KEYWORD_STRING and NEW_KEYWORD_STRING.		*) 
(*	      - Change MESSAGE command to primary from global.		*) 
(*	      - Add command definitions for DISPLAY FILTER and		*) 
(*		FILTER commands.					*)
(*	14Aug86 - jrn							*)
(*	      - add DELETE CLASS, DELETE GROUP for clearing classes	*)
(*		and groups after a configuration change			*)
(*	08Jul86 - jrn							*)
(*	      - add REMARK command					*)
(*	      - add SPECIAL flag (CLEAN and OLDPASS commands)		*)
(*	      - if TYMSHARE_CUD_FORMAT, change license for COMPARE,	*)
(*		GET, DISPLAY CUD/MUD and READ CUD/MUD commands		*)
(*	06Aug86 - jrn							*)
(*	      - add GFDONLY to SELECT PASSWORDDATE command		*)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGE FROM command to NVDM			*)
(*	13May86 - neh							*)
(*	      - if INCLUDE_DUMP, add DUMP keyword to INITIALIZE 	*)
(*		PARAMETERS command					*)
(*	30Apr86 - jrn							*)
(*	      - remove RESET command					*)
(*	28Apr86 - jrn							*)
(*	      - make REGENERATE PARAMETERS and RECOLLECT commands	*)
(*		restartable at a CUD block				*)
(*	24Apr86 - jrn							*)
(*	      - if REUSE_UUNS, add PARAMETERS keyword to NVDM		*)
(*		CHECK command						*)
(*	15Apr86 - jrn							*)
(*	      - add ADDBACK keyword to the INITIALIZE PARAMETERS	*)
(*		command							*)
(*	      - change DISPLAY NEXT to DISPLAY PARAMETERS		*)
(*	08Mar86 - jrn							*)
(*	      - add COPY command to Tymnet's NVDM			*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - add APPEND keyword to REGENERATE command, and		*)
(*		COLLECT command						*)
(*	22Jan86 - jrn							*)
(*	      - add add_to_prompts procedure				*)
(*	      - create command and keyword table with procedures	*)
(*	      - remove abbreviations and sizes in command and keyword	*)
(*	        definitions (handle in code)				*)
(*	      - change the UP and SHUT commands to HOST UP and HOST	*)
(*		SHUT, and add the HOST STATUS command			*)
(*	14Jan85 -  jrn							*)
(*	      - change DISPLAY LVOL to DISPLAY VOLUME for both Netval	*)
(*		and NVDM						*)
(*	20Dec85 - jrn							*)
(*	      - add the FROM SUPERVISOR keywords to the WRITE CUD	*)
(*		command							*)
(*	01Nov85 - jrn							*)
(*	      - add the REPEAT keyword for DISPLAY UPDATES, and the	*)
(*		SHUT and UP commands					*)
(*	29Oct84 - jrn							*)
(*	      - change the license required for the NETVAL CHECK	*)
(*		command, so that operators may use it to check for	*)
(*		usernames when there has been a disk problem		*)
(*	07Oct85 - jrn							*)
(*	      - add the X25 keyword for the NEW USER command if		*)
(*		VALIDATE_X25_NAMES is enabled				*)
(*	17Jul85 -	 jrn						*)
(*	     - add NVDM COMPARE command					*)
(*	31Jan85 - jrn							*)
(*	      - if NETVAL_IS_A_SLAVE, only allow programmer to perform	*)
(*		CUD update commands					*)
(*	16Jan85 - pgl							*)
(*	      - if LOGICAL_VOLUMES, add COPY, DISPLAY LVOL and		*)
(*		SET DRIVE OFFLINE commands				*)
(*	09Jan85 - jrn							*)
(*	      - remove UNIT keyword from Archive commands		*)
(*	08Jan85 - jrn							*)
(*	      - use INCLUDE_LIST_DESCRIPTIONS				*)
(*	14Apr84 Version 2.02    jrn - pgl				*)
(*	      - removed DISPLAY SCHEDULE and DISPLAY SUPERVISORS	*)
(*		commands						*)
(*	      - added DISPLAY DIRECTORY, DISPLAY SELECT and		*)
(*		SELECT commands						*)
(*	      - consolidated command and keyword strings		*)
(*	      - added licenses, AUDITOR_LICENSE, OPERATOR_LICENSE	*)
(*		and DISPLAY_CUD_LICENSE					*)
(*	14Mar84 Version 2.01 - jrn					*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*	29SEP83  Original from (patrol)cmds.bas				*)
(*		 Add HELP message routines - jrn			*)
(*									*)
(************************************************************************)


type COMMAND_TABLE = monitor;


const
  display_command_string = 'DISPLAY\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  all_keyword_string = 'ALL\';
  class_keyword_string = 'CLASS\';
  control_keyword_string = 'CONTROL\';
  delete_keyword_string = 'DELETE\ ';
  filter_keyword_string = 'FILTER\ ';
  name_keyword_string = 'NAME\ ';
  new_keyword_string = 'NEW\';
  password_keyword_string = 'PASSWORD\ ';
  access_keyword_string = 'ACCESS\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
description_keyword_string = 'DESCRIPTION\';
  district_keyword_string = 'DISTRICT\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
entrydate_keyword_string = 'ENTRYDATE\';
  gan_keyword_string = 'GAN\';
  from_keyword_string = 'FROM\ ';
  group_keyword_string = 'GROUP\';
  host_keyword_string = 'HOST\ ';
  hostlist_keyword_string = 'HOSTLIST\ ';
  node_keyword_string = 'NODE\ ';
  nodelist_keyword_string = 'NODELIST\ ';
  parameters_keyword_string = 'PARAMETERS\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
passworddate_keyword_string = 'PASSWORDDAT\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  user_keyword_string = 'USER\ ';
  uun_keyword_string = 'UUN\';
  supervisor_keyword_string = 'SUPERVISOR\ ';

  global_prompt_string = '* \ ';



type
  HELP_COMMAND_INFORMATION = record
    current_command_class	: command_class_index;
    current_command		: command_index;
    last_command_in_class	: command_index
  end (* help_command_information *);



var

(* command class definitions *)

  global_defs : array [global_command_index]  of command_definition;
  archive_defs : array [archive_command_index] of command_definition;
  primary_defs : array [primary_command_index] of command_definition;


(* prompt array definition *)

  class_prompt : array [command_class_index] of command_prompt;



(* keywords for all commands *)

  keyword_table : array [keyword_index] of keyword_definition;



(* Help command and sub-command pointers for all validator that *)
(* may access the HELP command.  This array is accessed by a	*)
(* call to START_HELP, then successive calls to			*)
(* NEXT_HELP_COMMAND_INFO AND NEXT_HELP_SUBCOMMAND_INFO		*)

  help_info : array [licensed_validator_index] of help_command_information;

(* The last keyword offset added tocommand table during initialization	*)

  last_keyword_offset : keyword_index;
!
(*************************  command_table  ******************************)
(*									*)
(*			     get_header					*)
(*									*)
(*	Move command header to command definition block.		*)
(*									*)
(************************************************************************)

procedure get_header(
      command_class	: command_class_index;
      command		: command_index;
  var header		: command_definition);

begin
  case command_class of
    global_class: header := global_defs[command];
    archive_class: header := archive_defs[command];
    primary_class: header := primary_defs[command]
  end (* case *)
end (* get_header *);



(*************************  command_table  ******************************)
(*									*)
(*			  get_keyword_entry				*)
(*									*)
(*	Move keyword for this command to definition block.		*)
(*									*)
(************************************************************************)

procedure get_keyword_entry(
      keyword_offset	: keyword_index;
      keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition);

begin
  keyword_entry := keyword_table[keyword_offset+keyword]
end (* get_keyword_entry *);
!
(**************************  command_table  *****************************)
(*									*)
(*			    get_class_bounds				*)
(*									*)
(*  Routine to set up the start and end of a command class index	*)
(*									*)
(************************************************************************)

procedure get_class_bounds(
      command_class	: command_class_index;
  var start_class	: command_index;
  var end_class		: command_index);

begin
  case command_class of

    GLOBAL_CLASS:
      begin
	start_class := START_GLOBAL_COMMANDS;
	end_class   := END_GLOBAL_COMMANDS
      end (* GLOBAL_CLASS *);

    ARCHIVE_CLASS:
      begin
	start_class := START_ARCHIVE_COMMANDS;
	end_class   := END_ARCHIVE_COMMANDS
      end (* ARCHIVE_CLASS *);

    PRIMARY_CLASS:
      begin
	start_class := START_PRIMARY_COMMANDS;
	end_class   := END_PRIMARY_COMMANDS
      end (* PRIMARY_CLASS *)

  end (* case *)
end (* get_class_bounds *);



(**************************  command_table  *****************************)
(*									*)
(*			     find_command				*)
(*									*)
(*	 Routine to lookup specified command.				*)
(*									*)
(************************************************************************)

procedure entry FIND_COMMAND(
      command_context	: context_set;
      token		: command_token;
  var scanned		: scanned_command;
  var header		: command_definition;
  var found		: boolean);

var
  i			: command_name_index;
  token_size		: command_token_size;
  match			: boolean;
  exact			: boolean;
  count			: integer;
  last_command		: command_index;
  test_command		: command_index;
  test_class		: command_class_index;

begin
  exact := FALSE; count := 0; test_class := succ(START_OF_COMMAND_CLASSES);
  token_size := token.finish - token.start;

  while (test_class < END_OF_COMMAND_CLASSES) and not exact do
    begin
      if test_class in command_context
      then
	begin
	  get_class_bounds(test_class, test_command, last_command);

	  while (test_command < last_command) and (count <= 1) do
	    begin
	      get_header(test_class, test_command, header);

	      i := 0;
	      repeat
		match := (header.name[i] <> END_MESSAGE_CHARACTER) and
		  (header.name[i] = scanned.input_line.text[token.start + i]);
		i := i + 1
	      until (i >= token_size) or not match;

	      if match
	      then
	        begin
		  exact := header.name[i] = END_MESSAGE_CHARACTER;
		  scanned.command := test_command;
		  scanned.command_class := test_class;
		  count := count + 1
		end (* if match *);
	      test_command := succ(test_command)
	    end (* while *)
	end (* if test_class in command_context *);
      test_class := succ(test_class)
    end (* while *);

  found := (count = 1) or exact;
  if found
  then get_header(scanned.command_class, scanned.command, header)
end (* find_command *);



(**************************  command_table  *****************************)
(*									*)
(*			check_next_keyword_entry			*)
(*									*)
(************************************************************************)

procedure check_next_keyword_entry(
      keyword_offset	: keyword_index;
      scanned		: scanned_command;
      token		: command_token;
      token_size	: command_token_size;
  var test_keyword	: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var keyword		: command_keyword_index;
  var exact		: boolean;
  var count		: integer);

var
  i			: command_token_index;
  match			: boolean;

begin
  get_keyword_entry(keyword_offset, test_keyword, keyword_entry);
  i := 0;
  repeat
    match := (keyword_entry.name[i] <> END_MESSAGE_CHARACTER) and
      (keyword_entry.name[i] = scanned.input_line.text[token.start + i]);
    i := i + 1
  until (i >= token_size) or not match;
  if match
  then
    begin
      exact := keyword_entry.name[i] = END_MESSAGE_CHARACTER;
      count := count + 1;
      keyword := test_keyword
    end (* match *)
end (* check_next_keyword_entry *);



(**************************  command_table  *****************************)
(*									*)
(*			      find_keyword				*)
(*									*)
(*	 Routine to lookup a keyword for a command (subcommand or not).	*)
(*									*)
(************************************************************************)

procedure find_keyword(
      first_keyword	: command_keyword_index (* one to start with *);
      keyword_offset	: keyword_index	(* offset for this command *);
      keyword_count	: command_keyword_total (* number to check *);
      scanned		: scanned_command;
      token		: command_token (* token to match *);
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

var
  token_size		: command_token_size;
  test_keyword		: command_keyword_index;
  exact			: boolean;
  count			: integer;

begin
  exact := FALSE; count := 0; test_keyword := first_keyword;
  token_size := token.finish - token.start;
  while (test_keyword < keyword_count) and not exact do
    begin
      check_next_keyword_entry(keyword_offset, scanned, token,
        token_size, test_keyword, keyword_entry, keyword, exact, count);
      test_keyword := succ(test_keyword)
    end (* while *);
  found := (count = 1) or exact;
  if found
  then get_keyword_entry(keyword_offset, keyword, keyword_entry)
end (* find_keyword *);



(**************************  command_table  *****************************)
(*									*)
(*			 find_subcommand_keyword			*)
(*									*)
(*	 Routine to lookup a sub-command for a command.			*)
(*									*)
(************************************************************************)

procedure entry FIND_SUBCOMMAND_KEYWORD(
      header		: command_definition;
      scanned		: scanned_command;
      token		: command_token;
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

begin
  find_keyword(0, header.keyword_offset, header.subcommand_count, scanned,
    token, keyword, keyword_entry, found)
end (* find_subcommand_keyword *);



(**************************  command_table  *****************************)
(*									*)
(*			  find_command_keyword				*)
(*									*)
(*	 Routine to lookup a keyword for a command.			*)
(*									*)
(************************************************************************)

procedure entry FIND_COMMAND_KEYWORD(
      header		: command_definition;
      scanned		: scanned_command;
      token		: command_token;
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

begin
  find_keyword(header.subcommand_count, header.keyword_offset,
    header.keyword_count, scanned, token, keyword, keyword_entry, found)
end (* find_command_keyword *);



(**************************  command_table  *****************************)
(*									*)
(*			  find_line_keyword				*)
(*									*)
(*	 Routine to lookup a keyword for an input line.			*)
(*									*)
(************************************************************************)

procedure entry FIND_LINE_KEYWORD(
      keyword_choices	: keyword_choice_set;
      scanned		: scanned_command;
      token		: command_token;
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

var
  token_size		: command_token_size;
  test_keyword		: command_keyword_index;
  exact			: boolean;
  count			: integer;

begin
  exact := FALSE; count := 0; test_keyword := 0;
  token_size := token.finish - token.start;
  while (test_keyword < LINE_KEYWORD_COUNT) and not exact do
    begin
      if test_keyword in keyword_choices
      then check_next_keyword_entry(LINE_KEYWORD_OFFSET, scanned, token,
        token_size, test_keyword, keyword_entry, keyword, exact, count);
      test_keyword := succ(test_keyword)
    end (* while *);
  found := (count = 1) or exact;
  if found
  then get_keyword_entry(LINE_KEYWORD_OFFSET, keyword, keyword_entry)
end (* find_line_keyword *);
!
(*************************  command_table  ******************************)
(*									*)
(*			     get_keyword				*)
(*									*)
(*	Return the keyword_definition for the specified command		*)
(*	and keyword.							*)
(*									*)
(************************************************************************)

procedure entry GET_KEYWORD(
      keyword_offset	: keyword_index;
      keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition);

begin
  get_keyword_entry(keyword_offset, keyword, keyword_entry)
end (* get_keyword *);
!
(***************************  command_table  ****************************)
(*									*)
(*				get_prompt				*)
(*									*)
(*  Returns the prompt of the highest priority class			*)
(*									*)
(************************************************************************)

procedure entry GET_PROMPT(
      context : context_set;
  var scanned : scanned_command);

var
  command_class : command_class_index;

begin
  command_class := succ(START_OF_COMMAND_CLASSES);
  while not (command_class in context) do
    command_class := succ(command_class);
  scanned.prompt := class_prompt[command_class]
end (* get_prompt *);
!
"
		HELP command routines
"



(***************************  command_table  ****************************)
(*									*)
(*			 next_help_command_class			*)
(*									*)
(*	Increment the current_command_class for the validator.  If at	*)
(*	the end of the list, set done to TRUE, otherwise, set up	*)
(*	current_command to be the start of the command class, and	*)
(*	last_command_in_class to be the end of the command class.	*)
(*									*)
(************************************************************************)

procedure next_help_command_class(
      validator		: licensed_validator_index;
      command_context	: context_set;
  var done		: boolean);

begin
  done := FALSE;
  with help_info[validator] do
    begin
      repeat
	current_command_class := succ(current_command_class);
	if current_command_class = END_OF_COMMAND_CLASSES
	then done := TRUE
      until done or (current_command_class in command_context);
      if not done
      then get_class_bounds(current_command_class, current_command,
	    last_command_in_class)
    end
end (* next_help_command_class *);



(***************************  command_table  ****************************)
(*									*)
(*				start_help				*)
(*									*)
(*	Initialize the help_info for the validator.  Use		*)
(*	command_context to set up the first legal command_class.	*)
(*									*)
(************************************************************************)

procedure entry START_HELP(
      validator		: licensed_validator_index;
      command_context	: context_set);

var
  done : boolean;

begin
  with help_info[validator] do
    begin
      current_command_class := START_OF_COMMAND_CLASSES;
      next_help_command_class(validator, command_context, done)
    end
end (* start_help *);



(***************************  command_table  ****************************)
(*									*)
(*			  next_help_command_info			*)
(*									*)
(*	Increment current_command, and return the header		*)
(*	(command_definition) for the next legal command			*)
(*	for the validator, validator_type, and command_context.		*)
(*	Set done to TRUE if there are no more legal commands		*)
(*	for the validator.						*)
(*									*)
(************************************************************************)

procedure entry NEXT_HELP_COMMAND_INFO(
      profile		: validator_profile;
      command_context	: context_set;
  var done		: boolean;
  var header		: command_definition);

begin
  done := FALSE;
  with help_info[profile.validator] do
    repeat
      repeat
	current_command := succ(current_command);
	if current_command = last_command_in_class
	then
	  begin
	    next_help_command_class(profile.validator, command_context, done);
	    if not done
	    then current_command := succ(current_command)
	  end
      until done or (current_command <> last_command_in_class);
      if not done
      then get_header(current_command_class, current_command, header)
    until done or profile.access_to_command(header.required_license)
end (* next_help_command_info *);
!
"
		Initialization routines
"


(***************************  command_table  ****************************)
(*									*)
(*			       add_command				*)
(*									*)
(************************************************************************)

procedure add_command(
      name		: command_name;
      required_license	: command_license;
      freeword_allowed	: boolean;
      keyword_offset	: keyword_index;
      keyword_count	: command_keyword_total;
      subcommand_count	: command_keyword_total;
      explanation	: help_string;
  var header		: command_definition);

begin
  header.name := name;
  header.required_license := required_license;
  header.freeword_allowed := freeword_allowed;
  header.keyword_offset := keyword_offset;
  header.keyword_count := keyword_count;
  header.subcommand_count := subcommand_count;
  header.explanation := explanation;
  last_keyword_offset := keyword_offset
end (* add_command *);




(***************************  command_table  ****************************)
(*									*)
(*				add_keyword				*)
(*									*)
(************************************************************************)

procedure add_keyword(
      name		: keyword_name;
      required_license	: command_license;
      explanation	: help_string;
      index		: keyword_index);

begin
  keyword_table[last_keyword_offset + index].name := name;
  keyword_table[last_keyword_offset+index].required_license:=required_license;
  keyword_table[last_keyword_offset + index].value_required := FALSE;
  keyword_table[last_keyword_offset + index].explanation := explanation
end (* add_keyword *);




(***************************  command_table  ****************************)
(*									*)
(*			add_non_subcommand_keyword			*)
(*									*)
(************************************************************************)

procedure add_non_subcommand_keyword(
      name	: keyword_name;
      index	: keyword_index);

begin
  add_keyword(name, NO_LICENSE, NULL_STRING, index)
end (* add_non_subcommand_keyword *);



(***************************  command_table  ****************************)
(*									*)
(*			    add_value_required				*)
(*									*)
(************************************************************************)

procedure add_value_required(
      index	: keyword_index);

begin
  keyword_table[last_keyword_offset + index].value_required := TRUE
end (* add_value_required *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  command_table  ****************************)
(*									*)
(*			   add_required_license				*)
(*									*)
(************************************************************************)

procedure add_required_license(
      required_license	: command_license;
      index		: keyword_index);

begin
  keyword_table[last_keyword_offset + index].required_license :=
    required_license
end (* add_required_license *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)




(***************************  command_table  ****************************)
(*									*)
(*			     add_to_prompts				*)
(*									*)
(************************************************************************)

procedure add_to_prompts(
      index	: command_class_index;
      prompt	: command_prompt);

begin
  class_prompt[index] := prompt
end (* add_to_prompts *);



(***************************  command_table  ****************************)
(*									*)
(*	Always define sub-command words as first sub_defs.  Sub_defs	*)
(*	that are options for an argument should be defined sequentially.*)
(*									*)
(************************************************************************)


begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- *)
(* global command definitions *)


(* Netval DATE Command *)

  add_command('DATE\ ', NO_LICENSE, FALSE, GLOBAL_DATE_KEYWORD_OFFSET,
    GLOBAL_DATE_KEYWORD_MAX, GLOBAL_DATE_SUBCOMMAND_MAX,
    'Type current GMT date and time\ ', global_defs[GLOBAL_DATE]);


(* Netval HELP Command *)

  add_command('HELP\ ', NO_LICENSE, FALSE, GLOBAL_HELP_KEYWORD_OFFSET,
     GLOBAL_HELP_KEYWORD_MAX, GLOBAL_HELP_SUBCOMMAND_MAX,
     'Type legal commands\', global_defs[GLOBAL_HELP]);


(* Netval STATISTICS Command *)

  add_command('STATISTICS\ ', OPERATOR_LICENSE, FALSE,
    GLOBAL_STATISTICS_KEYWORD_OFFSET, GLOBAL_STATISTICS_KEYWORD_MAX,
    GLOBAL_STATISTICS_SUBCOMMAND_MAX,
    'Print collected disk I/O information\ ', global_defs[GLOBAL_STATISTICS]);


(* Netval VERSION Command *)

  add_command('VERSION\', NO_LICENSE, FALSE,
    GLOBAL_VERSION_KEYWORD_OFFSET, GLOBAL_VERSION_KEYWORD_MAX,
    GLOBAL_VERSION_SUBCOMMAND_MAX,
    'Type current NETVAL version number\ ', global_defs[GLOBAL_VERSION]);
!
(* archive command definitions *)


(* Netval ASSIGN Command *)

  add_command('ASSIGN\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_ASSIGN_KEYWORD_OFFSET, ARCHIVE_ASSIGN_KEYWORD_MAX,
    ARCHIVE_ASSIGN_SUBCOMMAND_MAX,
    'Reserve tape unit for validator\', archive_defs[ARCHIVE_ASSIGN]);


(* Netval ATTACH Command *)

  add_command('ATTACH\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_ATTACH_KEYWORD_OFFSET, ARCHIVE_ATTACH_KEYWORD_MAX,
    ARCHIVE_ATTACH_SUBCOMMAND_MAX,
    'Reserve tape unit for NETVAL slot\', archive_defs[ARCHIVE_ATTACH]);


(* Netval DEASSIGN Command *)

  add_command('DEASSIGN\ ', OPERATOR_LICENSE, FALSE,
    ARCHIVE_DEASSIGN_KEYWORD_OFFSET, ARCHIVE_DEASSIGN_KEYWORD_MAX,
    ARCHIVE_DEASSIGN_SUBCOMMAND_MAX,
    'Free tape unit from validator\', archive_defs[ARCHIVE_DEASSIGN]);


(* Netval DETACH Command *)

  add_command('DETACH\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_DETACH_KEYWORD_OFFSET, ARCHIVE_DETACH_KEYWORD_MAX,
    ARCHIVE_DETACH_SUBCOMMAND_MAX,
    'Free tape unit from slot\ ', archive_defs[ARCHIVE_DETACH]);


(* Netval DISPLAY Command *)

  add_command(DISPLAY_COMMAND_STRING, OPERATOR_LICENSE, TRUE,
    ARCHIVE_DISPLAY_KEYWORD_OFFSET, ARCHIVE_DISPLAY_KEYWORD_MAX,
    ARCHIVE_DISPLAY_SUBCOMMAND_MAX,
    'Type Archive tape information\', archive_defs[ARCHIVE_DISPLAY]);

  add_keyword('ID\ ', OPERATOR_LICENSE,
    'Display Archive tape ID\', ARCHIVE_DISPLAY_ID_KEYWORD);

  add_keyword('STATUS\ ', OPERATOR_LICENSE,
    'Display status of all tape units\ ', ARCHIVE_DISPLAY_STATUS_KEYWORD);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* Netval DUMP command *)

  add_command('DUMP\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_DUMP_KEYWORD_OFFSET, ARCHIVE_DUMP_KEYWORD_MAX,
    ARCHIVE_DUMP_SUBCOMMAND_MAX,
    'Dump CUD to tape in ASCII format\ ', archive_defs[ARCHIVE_DUMP]);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING, ARCHIVE_DUMP_FROM_KEYWORD);
  add_value_required(ARCHIVE_DUMP_FROM_KEYWORD);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(* Netval RETURN Command *)

  add_command('RETURN\ ', OPERATOR_LICENSE, FALSE,
    ARCHIVE_RETURN_KEYWORD_OFFSET, ARCHIVE_RETURN_KEYWORD_MAX,
    ARCHIVE_RETURN_SUBCOMMAND_MAX,
    'Return to system level\ ', archive_defs[ARCHIVE_RETURN]);


(* Netval REWIND Command *)

  add_command('REWIND\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_REWIND_KEYWORD_OFFSET, ARCHIVE_REWIND_KEYWORD_MAX,
    ARCHIVE_REWIND_SUBCOMMAND_MAX,
    'Return tape to beginning of reel\ ', archive_defs[ARCHIVE_REWIND]);


(* Netval STORE Command *)

  add_command('STORE\', OPERATOR_LICENSE, TRUE,
    ARCHIVE_STORE_KEYWORD_OFFSET, ARCHIVE_STORE_KEYWORD_MAX,
    ARCHIVE_STORE_SUBCOMMAND_MAX,
    'Copy files from disk to tape\ ', archive_defs[ARCHIVE_STORE]);
!
(* validation command definitions *)


(* Netval ARCHIVE Command *)

  add_command('ARCHIVE\', OPERATOR_LICENSE, FALSE,
    PRIMARY_ARCHIVE_KEYWORD_OFFSET, PRIMARY_ARCHIVE_KEYWORD_MAX,
    PRIMARY_ARCHIVE_SUBCOMMAND_MAX,
    'Enter the Archive sub-system\ ', primary_defs[PRIMARY_ARCHIVE]);


(* Netval CHANGE Command *)

  add_command('CHANGE\ ',
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    NO_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    TRUE, PRIMARY_CHANGE_KEYWORD_OFFSET, PRIMARY_CHANGE_KEYWORD_MAX,
    PRIMARY_CHANGE_SUBCOMMAND_MAX,
    'Modify an existing value\ ', primary_defs[PRIMARY_CHANGE]);

  add_keyword(ACCESS_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    ACCOUNT_SUPERVISOR_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Modify an access profile for a user\', PRIMARY_CHANGE_ACCESS_KEYWORD);

  add_keyword(CLASS_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the definition of a class\ ', PRIMARY_CHANGE_CLASS_KEYWORD);

  add_keyword(CONTROL_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    ACCOUNT_SUPERVISOR_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Modify the control options for a user\', PRIMARY_CHANGE_CONTROL_KEYWORD);

  add_keyword(CUD_FILE_MESSAGE, PROGRAMMER_LICENSE,
    'Modify the in-core CUD buffer\', PRIMARY_CHANGE_CUD_KEYWORD);

  add_keyword(DISTRICT_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    ACCOUNT_SUPERVISOR_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Modify the district for a user\ ',PRIMARY_CHANGE_DISTRICT_KEYWORD);

  add_keyword(GAN_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the GAN for a user\', PRIMARY_CHANGE_GAN_KEYWORD);

  add_keyword(GROUP_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the definition of a group\ ', PRIMARY_CHANGE_GROUP_KEYWORD);

  add_keyword(HOSTLIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the definition of a hostlist\', PRIMARY_CHANGE_HOSTLIST_KEYWORD);

  add_keyword(NAME_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    ACCOUNT_SUPERVISOR_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Modify the name for a user\ ', PRIMARY_CHANGE_NAME_KEYWORD);

  add_keyword(NODELIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the definition a nodelist\ ', PRIMARY_CHANGE_NODELIST_KEYWORD);

  add_keyword(PASSWORD_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    NO_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Modify the password for a user\ ', PRIMARY_CHANGE_PASSWORD_KEYWORD);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-      *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)

  add_non_subcommand_keyword('OFFSET\ ', PRIMARY_CHANGE_OFFSET_KEYWORD);
  add_value_required(PRIMARY_CHANGE_OFFSET_KEYWORD) (* buffer word offset *);



(* Netval CHECK Command *)

  add_command('CHECK\', NO_LICENSE, TRUE,
    PRIMARY_CHECK_KEYWORD_OFFSET, PRIMARY_CHECK_KEYWORD_MAX,
    PRIMARY_CHECK_SUBCOMMAND_MAX,
    'Report on the existence of a username\', primary_defs[PRIMARY_CHECK]);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(* Netval CLEAR Command *)

  add_command('CLEAR\', OPERATOR_LICENSE, FALSE,
    PRIMARY_CLEAR_KEYWORD_OFFSET, PRIMARY_CLEAR_KEYWORD_MAX,
    PRIMARY_CLEAR_SUBCOMMAND_MAX,
    'Turn off schedule for the automatic consistency\',
    primary_defs[PRIMARY_CLEAR]);


(* Netval COMPARE Command *)

  add_command('COMPARE\',
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   PROGRAMMER_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    FALSE, PRIMARY_COMPARE_KEYWORD_OFFSET, PRIMARY_COMPARE_KEYWORD_MAX,
    primary_compare_subcommand_max,
    'Display differences between CUD and MUD buffer\ ',
    primary_defs[PRIMARY_COMPARE]);


(* Netval CONSISTENCY Command *)

  add_command('CONSISTENCY\', OPERATOR_LICENSE, FALSE,
    PRIMARY_CONSISTENCY_KEYWORD_OFFSET, PRIMARY_CONSISTENCY_KEYWORD_MAX,
    PRIMARY_CONSISTENCY_SUBCOMMAND_MAX,
    'Perform a manual consistency\ ', primary_defs[PRIMARY_CONSISTENCY]);

  add_non_subcommand_keyword('NOCHANGE\ ',
    PRIMARY_CONSISTENCY_NOCHANGE_KEYWORD);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD) (* Sup number *);
  
  add_non_subcommand_keyword(FROM_KEYWORD_STRING,
    PRIMARY_CONSISTENCY_FROM_KEYWORD);
  add_value_required(PRIMARY_CONSISTENCY_FROM_KEYWORD) (* Block number *);
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- *)
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- *)


(* Netval DELETE Command *)

  add_command(DELETE_KEYWORD_STRING, ACCOUNT_SUPERVISOR_LICENSE, TRUE,
    PRIMARY_DELETE_KEYWORD_OFFSET, PRIMARY_DELETE_KEYWORD_MAX,
    PRIMARY_DELETE_SUBCOMMAND_MAX,
    'Remove an existing value\ ', primary_defs[PRIMARY_DELETE]);

  add_keyword(ACCESS_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    NO_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Remove an access profile for a user\', PRIMARY_DELETE_ACCESS_KEYWORD);

  add_keyword(CLASS_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Clear a class definition\ ', PRIMARY_DELETE_CLASS_KEYWORD);

  add_keyword(GROUP_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Clear a group definition\ ', PRIMARY_DELETE_GROUP_KEYWORD);

  add_keyword(HOSTLIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Remove a hostlist definition\ ', PRIMARY_DELETE_HOSTLIST_KEYWORD);

  add_keyword(NODELIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Remove a nodelist definition\ ', PRIMARY_DELETE_NODELIST_KEYWORD);

  add_keyword(USER_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    NO_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Invalidate a user\', PRIMARY_DELETE_USER_KEYWORD);


(* Netval DISPLAY Command *)

  add_command(DISPLAY_COMMAND_STRING, NO_LICENSE, TRUE,
    PRIMARY_DISPLAY_KEYWORD_OFFSET, PRIMARY_DISPLAY_KEYWORD_MAX,
    PRIMARY_DISPLAY_SUBCOMMAND_MAX,
    'Type Netval information\', primary_defs[PRIMARY_DISPLAY]);

  add_keyword(CLASS_KEYWORD_STRING, NO_LICENSE,
    'Type a class or all classes\', PRIMARY_DISPLAY_CLASS_KEYWORD);

  add_keyword(CUD_FILE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   PROGRAMMER_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    'Type contents of the CUD buffer\', PRIMARY_DISPLAY_CUD_KEYWORD);

  add_keyword('DIRECTORY\', DISPLAY_CUD_LICENSE,
    'Type specified fields of selected users\',
    PRIMARY_DISPLAY_DIRECTORY_KEYWORD);

  add_keyword(FILTER_KEYWORD_STRING, OPERATOR_LICENSE,
    'Type current filter selections\ ', PRIMARY_DISPLAY_FILTER_KEYWORD);

  add_keyword(GROUP_KEYWORD_STRING, NO_LICENSE,
    'Type a group or all groups\ ', PRIMARY_DISPLAY_GROUP_KEYWORD);

  add_keyword(HOSTLIST_KEYWORD_STRING, NO_LICENSE,
    'Type hostlist information\', PRIMARY_DISPLAY_HOSTLIST_KEYWORD);

  add_keyword(MUD_FILE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   PROGRAMMER_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    'Type the contents of the MUD buffer\', PRIMARY_DISPLAY_MUD_KEYWORD);

  add_keyword(NODELIST_KEYWORD_STRING, NO_LICENSE,
    'Type nodelist information\', PRIMARY_DISPLAY_NODELIST_KEYWORD);

  add_keyword(PARAMETERS_KEYWORD_STRING, OPERATOR_LICENSE,
    'Type the next GAN and UUN to be assigned\ ',
    PRIMARY_DISPLAY_PARAMETERS_KEYWORD);

  add_keyword('SELECT\ ', DISPLAY_CUD_LICENSE,
    'Type criteria created by Select Command\',PRIMARY_DISPLAY_SELECT_KEYWORD);

  add_keyword('UPDATES\', OPERATOR_LICENSE,
    'Type Supervisor update information\ ', PRIMARY_DISPLAY_UPDATES_KEYWORD);

  add_keyword(USER_KEYWORD_STRING, DISPLAY_CUD_LICENSE,
    'Type the user entry for the specified name\ ',
    PRIMARY_DISPLAY_USER_KEYWORD);
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- *)
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- *)

  add_non_subcommand_keyword(ALL_KEYWORD_STRING,
    PRIMARY_DISPLAY_CUD_ALL_KEYWORD);

  add_non_subcommand_keyword('FORMATTED\',
    PRIMARY_DISPLAY_CUD_FORMATTED_KEYWORD);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  add_non_subcommand_keyword('NAMES\', PRIMARY_DISPLAY_LIST_NAMES_KEYWORD);

  add_non_subcommand_keyword(UUN_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_UUN_KEYWORD);

  add_non_subcommand_keyword(GAN_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_GAN_KEYWORD);
  add_required_license(AUDITOR_LICENSE, PRIMARY_DISPLAY_DIRECTORY_GAN_KEYWORD);

  add_non_subcommand_keyword(DISTRICT_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_DISTRICT_KEYWORD);

  add_non_subcommand_keyword(CONTROL_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_CONTROL_KEYWORD);

  add_non_subcommand_keyword(PASSWORDDATE_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_PASSWORDDATE_KEYWORD);

  add_non_subcommand_keyword(ENTRYDATE_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_ENTRYDATE_KEYWORD);

  add_non_subcommand_keyword(ACCESS_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_ACCESS_KEYWORD);

  add_non_subcommand_keyword('LINES\',PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD);
  add_value_required(PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD) (* page size *);

  add_non_subcommand_keyword('REPEAT\ ',
    PRIMARY_DISPLAY_UPDATES_REPEAT_KEYWORD);


(* Netval FILTER Command *)

  add_command(FILTER_KEYWORD_STRING, OPERATOR_LICENSE, TRUE,
    PRIMARY_FILTER_KEYWORD_OFFSET, PRIMARY_FILTER_KEYWORD_MAX,
    PRIMARY_FILTER_SUBCOMMAND_MAX,
    'Selects filter for Message Command display\ ',
    primary_defs[PRIMARY_FILTER]);

  add_non_subcommand_keyword(ALL_KEYWORD_STRING, PRIMARY_FILTER_ALL_KEYWORD);

  add_non_subcommand_keyword('ARCHIVE\', PRIMARY_FILTER_ARCHIVE_KEYWORD);

  add_non_subcommand_keyword('CONSISTENCY\',
    PRIMARY_FILTER_CONSISTENCY_KEYWORD);

  add_non_subcommand_keyword('CUDERROR\ ', PRIMARY_FILTER_CUDERROR_KEYWORD);

  add_non_subcommand_keyword('DEBUG\', PRIMARY_FILTER_DEBUG_KEYWORD);

  add_non_subcommand_keyword('FILE\ ', PRIMARY_FILTER_FILE_KEYWORD);


  add_non_subcommand_keyword('MUDUPDATE\', PRIMARY_FILTER_MUDUPDATE_KEYWORD);

  add_non_subcommand_keyword('OPERATOR\ ', PRIMARY_FILTER_OPERATOR_KEYWORD);

  add_non_subcommand_keyword('PARAMETER\', PRIMARY_FILTER_PARAMETER_KEYWORD);

  add_non_subcommand_keyword('SYSMSG1\', PRIMARY_FILTER_SYSMSG1_KEYWORD);

  add_non_subcommand_keyword('UN2\', PRIMARY_FILTER_UN2_KEYWORD);


  add_non_subcommand_keyword('VALIDATOR\', PRIMARY_FILTER_VALIDATOR_KEYWORD);


  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_FILTER_SUPERVISOR_KEYWORD);

  add_non_subcommand_keyword('NUMBER\ ',
    PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD);
  add_value_required(PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD);
  
  add_non_subcommand_keyword(USER_KEYWORD_STRING,
    PRIMARY_FILTER_VALIDATOR_USER_KEYWORD);
  add_value_required(PRIMARY_FILTER_VALIDATOR_USER_KEYWORD);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  add_non_subcommand_keyword('MODIFY\ ', PRIMARY_FILTER_MODIFY_KEYWORD);

  add_non_subcommand_keyword(ACCESS_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD);

  add_non_subcommand_keyword(CONTROL_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_CONTROL_KEYWORD);

  add_non_subcommand_keyword(DISTRICT_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_DISTRICT_KEYWORD);

  add_non_subcommand_keyword(GAN_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_GAN_KEYWORD);

  add_non_subcommand_keyword(NAME_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_NAME_KEYWORD);

  add_non_subcommand_keyword(PASSWORD_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_PASSWORD_KEYWORD);

  add_non_subcommand_keyword(UUN_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_UUN_KEYWORD);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  add_non_subcommand_keyword(DELETE_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_DELETE_KEYWORD);

  add_non_subcommand_keyword(NEW_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_NEW_KEYWORD);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(* Netval GET Command *)

  add_command('GET\',
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   PROGRAMMER_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    TRUE, PRIMARY_GET_KEYWORD_OFFSET, PRIMARY_GET_KEYWORD_MAX,
    PRIMARY_GET_SUBCOMMAND_MAX,
    'Type the CUD block number of a username\', primary_defs[PRIMARY_GET]);


(* Netval HOST Command *)

  add_command('HOST\ ', OPERATOR_LICENSE, FALSE,
    PRIMARY_HOST_KEYWORD_OFFSET, PRIMARY_HOST_KEYWORD_MAX,
    PRIMARY_HOST_SUBCOMMAND_MAX,
    'Display host information or set host state\ ',primary_defs[PRIMARY_HOST]);

  add_keyword('SHUT\ ', NO_LICENSE,
    'Set Netval to be accessible only by shut override users\',
    PRIMARY_HOST_SHUT_KEYWORD);

  add_keyword('STATUS\ ', NO_LICENSE,
    'Display current host information\ ', PRIMARY_HOST_STATUS_KEYWORD);

  add_keyword('UP\ ', NO_LICENSE,
    'Allow all users access to Netval\ ', PRIMARY_HOST_UP_KEYWORD);


(* Netval MESSAGE Command *)

  add_command('MESSAGE\', OPERATOR_LICENSE, TRUE,
    PRIMARY_MESSAGE_KEYWORD_OFFSET, PRIMARY_MESSAGE_KEYWORD_MAX,
    PRIMARY_MESSAGE_SUBCOMMAND_MAX,
    'Display information from the Operator log\',
    primary_defs[PRIMARY_MESSAGE]);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING, PRIMARY_MESSAGE_FROM_KEYWORD);

(* Netval NEW Command *)

  add_command(NEW_KEYWORD_STRING, ACCOUNT_SUPERVISOR_LICENSE, TRUE,
    PRIMARY_NEW_KEYWORD_OFFSET, PRIMARY_NEW_KEYWORD_MAX,
    PRIMARY_NEW_SUBCOMMAND_MAX,
    'Validate a new value\ ', primary_defs[PRIMARY_NEW]);

  add_keyword(ACCESS_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    NO_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Add an access entry to a user\', PRIMARY_NEW_ACCESS_KEYWORD);

  add_keyword(HOSTLIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Define a new hostlist\', PRIMARY_NEW_HOSTLIST_KEYWORD);

  add_keyword(NODELIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Define a new nodelist\', PRIMARY_NEW_NODELIST_KEYWORD);

  add_keyword(USER_KEYWORD_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    NO_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    'Add a new user\ ', PRIMARY_NEW_USER_KEYWORD);

  add_non_subcommand_keyword('AS\ ', PRIMARY_NEW_USER_AS_KEYWORD);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(* Netval QUIT Command *)

  add_command('QUIT\ ', NO_LICENSE, FALSE,
    PRIMARY_QUIT_KEYWORD_OFFSET, PRIMARY_QUIT_KEYWORD_MAX,
    PRIMARY_QUIT_SUBCOMMAND_MAX,
    'Exit from NETVAL\ ', primary_defs[PRIMARY_QUIT]);


(* Netval READ Command *)

  add_command('READ\ ', NETWORK_ADMINISTRATOR_LICENSE, FALSE,
    PRIMARY_READ_KEYWORD_OFFSET, PRIMARY_READ_KEYWORD_MAX,
    PRIMARY_READ_SUBCOMMAND_MAX,
    'Read Supervisor or NETVAL information\', primary_defs[PRIMARY_READ]);

  add_keyword(CUD_FILE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   PROGRAMMER_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    'Input a block of the CUD into the CUD buffer\ ',PRIMARY_READ_CUD_KEYWORD);

  add_keyword(MUD_FILE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   PROGRAMMER_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    'Input a block of MUD into the MUD buffer\ ', PRIMARY_READ_MUD_KEYWORD);
  add_value_required(PRIMARY_READ_MUD_KEYWORD) (* Supervisor number *);

  add_keyword('TABLE\', NETWORK_ADMINISTRATOR_LICENSE,
    'Type Supervisor or NETVAL Class/group table\',PRIMARY_READ_TABLE_KEYWORD);

  add_non_subcommand_keyword('BLOCK\', PRIMARY_READ_BLOCK_KEYWORD);
  add_value_required(PRIMARY_READ_BLOCK_KEYWORD) (* CUD/MUD block number *);

  add_non_subcommand_keyword('LOCK\ ', PRIMARY_READ_LOCK_KEYWORD);
  add_required_license(PROGRAMMER_LICENSE, PRIMARY_READ_LOCK_KEYWORD);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_READ_TABLE_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_READ_TABLE_SUPERVISOR_KEYWORD) (* Sup number *);

  add_non_subcommand_keyword(CLASS_KEYWORD_STRING, 
				PRIMARY_READ_TABLE_CLASS_KEYWORD);
  add_value_required(PRIMARY_READ_TABLE_CLASS_KEYWORD);

  add_non_subcommand_keyword(GROUP_KEYWORD_STRING, 
				PRIMARY_READ_TABLE_GROUP_KEYWORD);
  add_value_required(PRIMARY_READ_TABLE_GROUP_KEYWORD);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* Netval REMARK Command *)

  add_command('REMARK\ ',
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    ACCOUNT_SUPERVISOR_LICENSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    FALSE, PRIMARY_REMARK_KEYWORD_OFFSET, PRIMARY_REMARK_KEYWORD_MAX,
    PRIMARY_REMARK_SUBCOMMAND_MAX,
    'Enter a string to be added to CHANGE CUD oper log messages\ ',
    primary_defs[PRIMARY_REMARK]);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* Netval SELECT Command *)

  add_command('SELECT\ ', DISPLAY_CUD_LICENSE, TRUE,
    PRIMARY_SELECT_KEYWORD_OFFSET, PRIMARY_SELECT_KEYWORD_MAX,
    PRIMARY_SELECT_SUBCOMMAND_MAX,
    'Designate criteria for Display Directory Command selections\',
    primary_defs[PRIMARY_SELECT]);

  add_non_subcommand_keyword(ALL_KEYWORD_STRING, PRIMARY_SELECT_ALL_KEYWORD);

  add_non_subcommand_keyword(ACCESS_KEYWORD_STRING,
    PRIMARY_SELECT_ACCESS_KEYWORD);

  add_non_subcommand_keyword(GAN_KEYWORD_STRING, PRIMARY_SELECT_GAN_KEYWORD);
  add_required_license(AUDITOR_LICENSE, PRIMARY_SELECT_GAN_KEYWORD);

  add_non_subcommand_keyword(DISTRICT_KEYWORD_STRING,
    PRIMARY_SELECT_DISTRICT_KEYWORD);

  add_non_subcommand_keyword(UUN_KEYWORD_STRING, PRIMARY_SELECT_UUN_KEYWORD);

  add_non_subcommand_keyword(CONTROL_KEYWORD_STRING,
    PRIMARY_SELECT_CONTROL_KEYWORD);

  add_non_subcommand_keyword(ENTRYDATE_KEYWORD_STRING,
    PRIMARY_SELECT_ENTRYDATE_KEYWORD);

  add_non_subcommand_keyword(PASSWORDDATE_KEYWORD_STRING,
    PRIMARY_SELECT_PASSWORDDATE_KEYWORD);

  add_non_subcommand_keyword(CLASS_KEYWORD_STRING,
    PRIMARY_SELECT_CLASS_ACCESS_KEYWORD);

  add_non_subcommand_keyword(GROUP_KEYWORD_STRING,
    PRIMARY_SELECT_GROUP_ACCESS_KEYWORD);

  add_non_subcommand_keyword(HOST_KEYWORD_STRING,
    PRIMARY_SELECT_HOST_ACCESS_KEYWORD);

  add_non_subcommand_keyword(NODE_KEYWORD_STRING,
    PRIMARY_SELECT_NODE_ACCESS_KEYWORD);

  add_non_subcommand_keyword('AFTER\', PRIMARY_SELECT_AFTER_DATE_KEYWORD);

  add_non_subcommand_keyword('BEFORE\ ', PRIMARY_SELECT_BEFORE_DATE_KEYWORD);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  add_non_subcommand_keyword('LI\ ', PRIMARY_SELECT_CONTROL_LICENSED_KEYWORD);

  add_non_subcommand_keyword('PO\ ',
    PRIMARY_SELECT_CONTROL_PASSWORD_ONLY_KEYWORD);

  add_non_subcommand_keyword('AS\ ',
    PRIMARY_SELECT_CONTROL_ACCOUNT_SUPERVISOR_KEYWORD);

  add_non_subcommand_keyword('IH\ ',
    PRIMARY_SELECT_CONTROL_IGNORE_HOST_KEYWORD);

  add_non_subcommand_keyword('NA\ ',
    PRIMARY_SELECT_CONTROL_NETWORK_ADMINISTRATOR_KEYWORD);

  add_non_subcommand_keyword('NP\ ',
    PRIMARY_SELECT_CONTROL_NO_PASSWORD_KEYWORD);

  add_non_subcommand_keyword('SO\ ',
    PRIMARY_SELECT_CONTROL_SHUT_OVERRIDE_KEYWORD);

  add_non_subcommand_keyword('AU\ ', PRIMARY_SELECT_CONTROL_AUDITOR_KEYWORD);

  add_non_subcommand_keyword('OP\ ', PRIMARY_SELECT_CONTROL_OPERATOR_KEYWORD);

  add_non_subcommand_keyword('TL\ ',
    PRIMARY_SELECT_CONTROL_TRANSPARENT_LOGIN_KEYWORD);


(* Netval SEND Command *)

  add_command('SEND\ ', NETWORK_ADMINISTRATOR_LICENSE, FALSE,
    PRIMARY_SEND_KEYWORD_OFFSET, PRIMARY_SEND_KEYWORD_MAX,
    PRIMARY_SEND_SUBCOMMAND_MAX,
    'Initiate transmission of Class/group table\ ',
    primary_defs[PRIMARY_SEND]);

  add_non_subcommand_keyword('WAIT\ ', PRIMARY_SEND_WAIT_KEYWORD);


(* Netval SET Command *)

  add_command('SET\', OPERATOR_LICENSE, FALSE,
    PRIMARY_SET_KEYWORD_OFFSET, PRIMARY_SET_KEYWORD_MAX,
    PRIMARY_SET_SUBCOMMAND_MAX,
    'Define a system value\', primary_defs[PRIMARY_SET]);
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- *)
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- *)

  add_keyword('SCHEDULE\ ', NO_LICENSE,
    'Define the automatic consistency period\',PRIMARY_SET_SCHEDULE_KEYWORD);

  add_keyword(SUPERVISOR_KEYWORD_STRING, NO_LICENSE,
    'Define the legal Netval Supervisors\', PRIMARY_SET_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_SET_SUPERVISOR_KEYWORD) (* Supervisor number *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  add_non_subcommand_keyword('ON\ ', PRIMARY_SET_SUPERVISOR_ON_KEYWORD);

  add_non_subcommand_keyword('OFF\', PRIMARY_SET_SUPERVISOR_OFF_KEYWORD);


(* Netval STOP Command *)

  add_command('STOP\ ', OPERATOR_LICENSE, FALSE,
    PRIMARY_STOP_KEYWORD_OFFSET, PRIMARY_STOP_KEYWORD_MAX,
    PRIMARY_STOP_SUBCOMMAND_MAX,
    'Halt a running automatic consistency\ ', primary_defs[PRIMARY_STOP]);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_STOP_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_STOP_SUPERVISOR_KEYWORD) (* Supervisor number *);


(* Netval UNLOCK Command *)

  add_command('UNLOCK\ ', PROGRAMMER_LICENSE, FALSE,
    PRIMARY_UNLOCK_KEYWORD_OFFSET, PRIMARY_UNLOCK_KEYWORD_MAX,
    PRIMARY_UNLOCK_SUBCOMMAND_MAX,
    'Unlock a locked CUD block\', primary_defs[PRIMARY_UNLOCK]);


(* Netval WRITE Command *)

  add_command('WRITE\', PROGRAMMER_LICENSE, FALSE,
    PRIMARY_WRITE_KEYWORD_OFFSET, PRIMARY_WRITE_KEYWORD_MAX,
    PRIMARY_WRITE_SUBCOMMAND_MAX,
    'Record CUD or MUD buffer\ ', primary_defs[PRIMARY_WRITE]);

  add_keyword(CUD_FILE_MESSAGE, PROGRAMMER_LICENSE,
    'Record CUD buffer\', PRIMARY_WRITE_CUD_KEYWORD);

  add_keyword(MUD_FILE_MESSAGE, PROGRAMMER_LICENSE,
    'Record MUD buffer to specified Supervisor\', PRIMARY_WRITE_MUD_KEYWORD);
  add_value_required(PRIMARY_WRITE_MUD_KEYWORD) (* Supervisor number *);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,
    PRIMARY_WRITE_CUD_FROM_KEYWORD);
  add_required_license(PROGRAMMER_LICENSE, PRIMARY_WRITE_CUD_FROM_KEYWORD);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_WRITE_CUD_FROM_SUPERVISOR_KEYWORD);
  add_required_license(PROGRAMMER_LICENSE,
    PRIMARY_WRITE_CUD_FROM_SUPERVISOR_KEYWORD);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- *)
!
(* the following keywords only apply to parsed lines, not commands *)

  last_keyword_offset := LINE_KEYWORD_OFFSET;

  add_non_subcommand_keyword('YES\', LINE_YES_KEYWORD);

  add_non_subcommand_keyword('NO\ ', LINE_NO_KEYWORD);

  add_non_subcommand_keyword(NODE_KEYWORD_STRING, LINE_NODE_KEYWORD);

  add_non_subcommand_keyword(HOST_KEYWORD_STRING, LINE_HOST_KEYWORD);

  add_non_subcommand_keyword('COMPLETE\ ', LINE_COMPLETE_KEYWORD);

  add_non_subcommand_keyword(GROUP_KEYWORD_STRING, LINE_GROUP_KEYWORD);

  add_non_subcommand_keyword(HOSTLIST_KEYWORD_STRING, LINE_HOSTLIST_KEYWORD);

  add_non_subcommand_keyword(NODELIST_KEYWORD_STRING, LINE_NODELIST_KEYWORD);

  add_non_subcommand_keyword('ADD\', LINE_ADD_KEYWORD);

  add_non_subcommand_keyword(DELETE_KEYWORD_STRING, LINE_DELETE_KEYWORD);

  add_non_subcommand_keyword('REPLACE\', LINE_REPLACE_KEYWORD);

  add_non_subcommand_keyword('END\', LINE_END_KEYWORD);



(* set up class prompt definitions *)
  add_to_prompts(ARCHIVE_CLASS, 'arch> \ ');
  add_to_prompts(PRIMARY_CLASS, GLOBAL_PROMPT_STRING);
  add_to_prompts(GLOBAL_CLASS, GLOBAL_PROMPT_STRING)
end (* command_table *);
!
(************************************************************************)
(*									*)
(*	ARGSCN.NTV							*)
(*									*)
(*			   argument_scanner 				*)
(*									*)
(*	Set of routines to convert arguments.				*)
(*									*)
(*	The following identifiers must be identified externally:	*)
(*	  ascii_space, ascii_minus					*)
(*									*)
(************************************************************************)
(*									*)
(*			Revision Record					*)
(*									*)
(*	01Oct86 - neh							*)
(*	      - Remove conditional ifnone disk_maintenance for 		*)
(*		argument_username.					*)
(*	      - Add keyword_username.					*)
(*	      - Add freeword_list procedure.				*)
(*	02Jun86 - jrn							*)
(*	      - use new mutil.legal_username_character function		*)
(*	28Feb86 - jrn							*)
(*	      - clean up and modify freeword_date to use default date	*)
(*		of today.						*)
(*	31AUG84 Version 2.03 - jrn					*)
(*	      - changed format of listname				*)
(*	16Jun84 Version 2.02	pgl					*)
(*	      - added freeword_range, get_freeword_date, 		*)
(*		and freeword_date_only					*)
(*	29SEP83 original from (patrol)argscn.bas - jrn			*)
(*									*)
(************************************************************************)


type ARGUMENT_SCANNER = class(
	mutil	: misc_utility);



var
  calendar: date_time_converter;



(*	The following set is constructed while a command is scanned.    *)
(*	It will contain all the keywords that a command uses.		*)
(*	The putting of keywords in this set is done in 'check_keyword'.	*)
(*	This routine also checks for keyword presents, so it is used	*)
(*	to both check if a keyword is present and to record its use.	*)
(*	The set is used in 'extra_keyword_check' to determine if any	*)
(*	extra keywords were entered. It is cleared in the entry		*)
(*	'reset_argument_check'.						*)
(*	cleared at the start of each command compile.			*)

  keyword_used : command_keyword_set;

(*	The following counter counts the number of freewords used in a	*)
(*	command. After the command is completely scanned, this number	*)
(*	is compared with FREEWORD_COUNT in SCANNED. If it is less, than	*)
(*	there are							*)
(*	free words in the command which have not been used. If so,	*)
(*	STATUS is set to ARG_ERROR. This is done in check_allowed.	*)

  freeword_used : command_freeword_total;



(**************************  argument_scanner  **************************)
(*									*)
(*			 check_freeword_available			*)
(*									*)
(*	Check that freeword is available and remember last used.	*)
(*									*)
(************************************************************************)

procedure check_freeword_available(
      freeword	: command_freeword_index;
  var scanned	: scanned_command);

begin
  if (freeword + 1) > scanned.freeword_count
  then scanned.status := ARG_FREEWORD_MISSING
  else
    if (freeword + 1) > freeword_used
    then freeword_used := freeword + 1
end (* check_freeword_available *);



(**************************  argument_scanner  **************************)
(*									*)
(*			    check_argument_end				*)
(*									*)
(*	Check that all the characters in a token have been scanned.	*)
(*									*)
(************************************************************************)

procedure check_argument_end(
      token	: command_token;
  var scanned	: scanned_command);

begin
  if scanned.status = CMD_OK
  then
    if token.start < token.finish
    then scanned.status := ARG_ERROR
end (* check_argument_end *);



(**************************  argument_scanner  **************************)
(*									*)
(*			    get_unsigned_number				*)
(*									*)
(*	Convert an argument in value to a integer.			*)
(*									*)
(************************************************************************)

procedure get_unsigned_number(
      base	: integer;
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: integer);

var
  start    : command_token_index;
  scanning : boolean;
  next_char : char;
  digit    : integer (* the internal value of digit scanned *);

begin
  start := token.start;
  scanning := TRUE;
  value := 0;
  while (token.start < token.finish) and scanning do
    begin
      next_char := scanned.input_line.text[token.start];
      if mutil.decimal_digit(next_char)
      then digit := ord(next_char) - ord(ASCII_ZERO)
      else
        if (ASCII_A <= next_char) and (next_char <= ASCII_F)
	then digit := ord(next_char) - ord(ASCII_A) + 10
	else scanning := FALSE;
      if scanning
      then scanning := digit < base;
      if scanning
      then
	begin
	  value := value*base + digit;
	  token.start := token.start + 1
	end
    end (* while *);

  if start = token.start
  then scanned.status := ARG_ERROR
end (* get_unsigned_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      argument_number				*)
(*									*)
(*	Convert a token to a signed integer.				*)
(*									*)
(************************************************************************)

procedure argument_number(
      base	: integer;
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: integer);

var
  negative: boolean;

begin
(* Scan for sign on value and remove. *)
  negative := FALSE (* assume positive *);
  if scanned.input_line.text[token.start] = ASCII_MINUS
  then
    begin
      negative := TRUE;
      token.start := token.start + 1
    end
  else
    if scanned.input_line.text[token.start] = ASCII_PLUS
    then token.start := token.start + 1;

  get_unsigned_number(base, token, scanned, value);
  check_argument_end(token, scanned);
  if scanned.status = CMD_OK
  then
    if negative
    then value := -value
end (* argument_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      keyword_number				*)
(*									*)
(*	Convert a keyword to an integer.				*)
(*									*)
(************************************************************************)

procedure entry KEYWORD_NUMBER(
      keyword	: command_keyword_index;
      base	: integer;
  var scanned	: scanned_command;
  var value	: integer);

var
  token: command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_number(base, token, scanned, value)
end (* keyword_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			     freeword_number				*)
(*									*)
(*	Convert a freeword to an integer.				*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_NUMBER(
      freeword	: command_freeword_index;
      base	: integer;
  var scanned	: scanned_command;
  var value	: integer);

var
  token : command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_number(base, token, scanned, value)
    end
end (* freeword_number *);
!
"
		date and time routines
"



(*************************  argument_scanner  ***************************)
(*									*)
(*			      argument_value				*)
(*									*)
(*	Convert argument in the form NN<delimiter> to an integer value.	*)
(*									*)
(************************************************************************)

procedure argument_value(
      min_value			: integer (* minimum acceptable value *);
      max_value			: integer (* maximum acceptable value *);
      radix			: integer (* radix of value *);
      delimiter_required	: boolean (* TRUE if there must be a del. *);
      delimiter			: char (* acceptble delimiter *);
  var token			: command_token;
  var delimiter_found		: boolean (* TRUE if a delimiter was found *);
  var scanned			: scanned_command;
  var value			: integer);

begin
  get_unsigned_number(radix, token, scanned, value);
  if scanned.status = CMD_OK
  then
    if (value < min_value) or (value > max_value)
    then scanned.status := ARG_NUMBER_OUT_OF_BOUNDS
    else
      if scanned.input_line.text[token.start] = delimiter
      then
        begin (* delimiter was entered *)
	  delimiter_found := TRUE;
	  token.start := token.start + 1 (* skip delimiter *)
	end (* delimiter was entered *)
      else
        begin (* no delimiter found *)
	  delimiter_found := FALSE;
	  if delimiter_required
	  then scanned.status := ARG_ERROR 
	end (* no delimiter found *)
end (* argument_value *);



(****************************  argument_scan  ***************************)
(*									*)
(*		 	       freeword_list				*)
(*									*)
(*	 Return value in a list seperated by commas.			*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_LIST(
      freeword	: command_freeword_index;
      min_value : integer;
      max_value : integer;
      base	: integer;
  var scanned	: scanned_command;
  var value	: univ integer);

var
  token : command_token;
  delimiter_found : boolean;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_value(min_value, max_value, base, FALSE, ASCII_COMMA, token,
        delimiter_found, scanned, value)
    end (* if CMD_OK *)
end (* freeword_list *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			      argument_time				*)
(*									*)
(*	Convert argument in the form HH:MM<:SS> to a time.		*)
(*									*)
(************************************************************************)

procedure argument_time(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var time	: integer);

var
  token : command_token;
  hour : integer;
  minute : integer;
  second : integer;
  delimiter_found : boolean;

begin
  check_freeword_available(freeword, scanned);

  if scanned.status = CMD_OK
  then
    begin (* get hour *)
      token := scanned.freeword_value[freeword];
      argument_value(0, 23, 10, TRUE, ASCII_COLON, token, delimiter_found,
        scanned, hour)
    end (* get hour *);

  if scanned.status = CMD_OK
  then(* get minutes *)
    argument_value(0, 59, 10, FALSE, ASCII_COLON, token, delimiter_found,
      scanned, minute);

  if scanned.status = CMD_OK
  then
    if token.start = token.finish
    then (* no more characters to parse *)
      if delimiter_found
      then scanned.status := ARG_ERROR (* user entered trailing delimiter *)
      else second := 0 (* use default *)
    else (* more characters left *)
      if delimiter_found
      then (* get seconds *)
        argument_value(0, 59, 10, FALSE, ASCII_COLON, token, delimiter_found,
	  scanned, second)
      else scanned.status := ARG_ERROR (* no delimiter found *);

  check_argument_end(token, scanned);
  time := calendar.seconds_in_time(hour, minute, second)
end (* argument_time *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			     argument_date				*)
(*									*)
(*	Convert freeword in the form MM/DD</YY> to an ISIS time.	*)
(*									*)
(************************************************************************)

procedure argument_date(
  var token	: command_token;
  var scanned	: scanned_command;
  var time	: integer);

var
  month : integer;
  day : integer;
  year : integer;
  current_year : integer;
  leap : boolean;
  delimiter_found : boolean;

begin
(* set year for default use or checking input value*)
  time := REALTIME (* default is current year *);
  calendar.compute_year(time, current_year);

(* get month *)
  argument_value(1, 12, 10, TRUE, ASCII_SLASH, token, delimiter_found,
    scanned, month);

(* get day *)
  if scanned.status = CMD_OK
  then argument_value(1, 31, 10, FALSE, ASCII_SLASH, token, delimiter_found,
    scanned, day);

(* get year *)
  if scanned.status = CMD_OK
  then
    if token.start = token.finish
    then (* no more characters to parse *)
      if delimiter_found
      then scanned.status := ARG_ERROR (* user entered trailing delimiter *)
      else year := current_year (* use default *)
    else (* more characters left *)
      if delimiter_found
      then
        begin (* get year *)
	  get_unsigned_number(10, token, scanned, year);
	  if scanned.status = CMD_OK
	  then
	    begin
	      if year < 100
	      then year := year + 1900;
	      if (year < BASE_YEAR) or (year > current_year)
	      then scanned.status := ARG_ERROR
	    end
        end (* get year *)
      else scanned.status := ARG_ERROR (* no delimiter found *);

  if scanned.status = CMD_OK
  then
    begin (* determine if year is a leap year and check month value *)
      leap := calendar.leap_year(year);
      if calendar.days_in_month(month, leap) < day
      then scanned.status := ARG_ERROR
    end (* determine if year is a leap year and check month value *);

  check_argument_end(token, scanned);
  if scanned.status = CMD_OK
  then time := calendar.seconds_in_date(month, day, year, leap)
end (* argument_date *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			  freeword_date_and_time			*)
(*									*)
(*	Convert freeword in the form MM/DD/YY HH:MM:SS to an ISIS time.	*)
(*	If entire date is omitted, day will be set to today; if YY is	*)
(*	omitted, current year will be set; if HH:MM is omitted, 00:00	*)
(*	is used; if SS is omitted, 0 is used.				*)
(*	This procedure is only used by the MESSAGES command.		*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_DATE_AND_TIME(
      freeword	: command_freeword_index;
      max_time	: integer;
  var scanned	: scanned_command;
  var time	: integer);

var
  date : integer;
  date_time : print_time;
  time_freeword : command_freeword_index;
  token : command_token;
  first_token_is_date : boolean;
  first_token_is_time : boolean;
  next_char : char;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword] (* get first token to scan *);
      first_token_is_date := FALSE; first_token_is_time := FALSE;
      repeat
        next_char := scanned.input_line.text[token.start];
	if next_char = ASCII_SLASH
	then first_token_is_date := TRUE
	else
	  if next_char = ASCII_COLON
	  then first_token_is_time := TRUE
	  else token.start := token.start + 1
      until first_token_is_date or first_token_is_time or
        (token.start = token.finish);
      token := scanned.freeword_value[freeword] (* restore first token *);
      if first_token_is_date
      then
        begin (* pick up date from first token *)
	  argument_date(token, scanned, date);
	  time_freeword := freeword + 1 (* next freeword would be time *)
	end (* pick up date from first token *)
      else
        begin (* first token is not date, compute time of start of today *)
	  calendar.date_from_isis_time(REALTIME, date_time);
	  date := calendar.seconds_in_date(date_time.month, date_time.day,
	    date_time.year, calendar.leap_year(date_time.year));
	  if first_token_is_time
	  then time_freeword := freeword (* first freeword was time *)
	  else scanned.status := ARG_FREEWORD_MISSING
	end (* first token is not date, compute time of start of today *)
    end (* scanned.status = CMD_OK *);

  if scanned.status = CMD_OK
  then
    begin (* get time of day *)
      check_freeword_available(time_freeword, scanned) (* time entered? *);
      if scanned.status = CMD_OK
      then argument_time(time_freeword, scanned, time)
      else
        if scanned.status = ARG_FREEWORD_MISSING
	then
	  begin (* no time entered *)
	    time := 0 (* set default *);
	    scanned.status := CMD_OK
	  end (* no time entered *)
    end (* get time of day *);

(* add time of year and time of day *)
  if scanned.status = CMD_OK
  then
    begin
      time := date + time;
      if time > max_time
      then scanned.status := ARG_ERROR
    end;
end (* freeword_date_and_time *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  argument_scanner  *************************)
(*									*)
(*			       freeword_date				*)
(*									*)
(*      Picks up MM/DD/YY only.						*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_DATE(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var time	: integer);

var
  token : command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token :=  scanned.freeword_value[freeword];
      argument_date(token, scanned, time)
    end
end (* freeword_date *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			 freeword_time_in_minutes		   	*)
(*									*)
(*	Convert freeword to minutes since midnight.			*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_TIME_IN_MINUTES(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var time	: integer);

begin
  argument_time(freeword, scanned, time);
  time := (time div 60) mod MINUTES_PER_DAY
end (* freeword_time_in_minutes *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  argument_scanner  *************************)
(*									*)
(*				freeword_range				*)
(*									*)
(* Convert token to a pair of integers; the pair is separated by a dash.*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_RANGE(
      freeword		: command_freeword_index;
      min_value		: integer;
      max_value		: integer;
      radix		: integer;
  var scanned		: scanned_command;
  var number_range	: range);

var
  token	: command_token;
  delimiter_found : boolean;

begin
  check_freeword_available(freeword, scanned);

  if scanned.status = CMD_OK
  then
    begin (* input first value *)
      token := scanned.freeword_value[freeword];
      argument_value(min_value, max_value, radix, FALSE, ASCII_MINUS, token,
        delimiter_found, scanned, number_range.first)
    end (* input first value *);

  if scanned.status = CMD_OK
  then (* input optional second value *)
    if token.start = token.finish (* single integer found *)
    then (* no more characters to parse *)
      if delimiter_found
      then scanned.status := ARG_ERROR (* user entered trailing delimiter *)
      else number_range.last := number_range.first
    else argument_value(number_range.first + 1, max_value, radix, FALSE,
      ASCII_MINUS, token, delimiter_found, scanned, number_range.last);

  check_argument_end(token, scanned)
end (* freeword_range *);



(*************************  argument_scanner  ***************************)
(*                                                                      *)
(*                          argument_username                           *)
(*                                                                      *)
(************************************************************************)

procedure argument_username(
  var token     : command_token;
  var scanned   : scanned_command;
  var username  : username_string);

var
  finished : boolean;
  x : username_text_index;

begin
  if scanned.input_line.text[token.start] = ASCII_SINGLE_QUOTE
  then
    begin
      token.start := token.start + 1;
      token.finish := token.finish - 1;
      if token.start = token.finish
      then scanned.status := ARG_ERROR
    end;

  for x := 0 to USERNAME_TEXT_LIMIT do
    username.text[x] := ZERO;
  x := 0;
  if scanned.status = CMD_OK
  then finished := FALSE
  else finished  := TRUE;

  with scanned.input_line do
    while not finished and (scanned.status = CMD_OK) do
      if mutil.legal_username_character(text[token.start])
      then
        begin
          username.text[x] := text[token.start];
          if token.start = token.finish - 1
          then finished := TRUE
          else
            begin
              token.start := token.start + 1;
              if x = USERNAME_TEXT_LIMIT
              then scanned.status := ARG_TOO_MANY_CHARS
              else x := x + 1
            end
          end
      else scanned.status := ILLEGAL_CHAR;
  if scanned.status = CMD_OK
  then username.size := x + 1
end (* argument_username *);



(*************************  argument_scanner  ***************************)
(*                                                                      *)
(*                          freeword_username                           *)
(*                                                                      *)
(************************************************************************)

procedure entry FREEWORD_USERNAME(
      freeword  : command_freeword_index;
  var scanned   : scanned_command;
  var username  : username_string);

var
  token : command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_username(token, scanned, username)
    end
end (* freeword_username *);

(*************************  argument_scanner  ***************************)
(*                                                                      *)
(*                          keyword_username                            *)
(*                                                                      *)
(************************************************************************)

procedure entry KEYWORD_USERNAME(
      keyword   : command_keyword_index;
  var scanned   : scanned_command;
  var username  : username_string);

var
  token : command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_username(token, scanned, username)
end (* keyword_username *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  argument_scanner  ***************************)
(*									*)
(*			    freeword_listname				*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_LISTNAME(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var name	: named_list_name);

var
  token : command_token;
  index : named_list_name_index;
  done : boolean;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      done := FALSE;
      for index := 0 to NAMED_LIST_NAME_SIZE_LIMIT do
        name.text[index] := ASCII_SPACE;
      index := 0;
      with scanned.input_line do
        while not done and (scanned.status = CMD_OK) do
	  if mutil.alpha_numeric(text[token.start]) or
	    (text[token.start] = '_') or
	    (text[token.start] = ASCII_AMPERSAND)
	  then
	    begin
	      name.text[index] := text[token.start];
	      if token.start = token.finish - 1
	      then
	        begin
		  done := TRUE;
		  name.size := index + 1
		end
	      else
	        begin
	          token.start := token.start + 1;
		  if index = NAMED_LIST_NAME_SIZE_LIMIT
		  then scanned.status := ARG_TOO_MANY_CHARS
		  else index := index + 1
	        end
	    end
          else scanned.status := ILLEGAL_CHAR
    end
end (* freeword_listname *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  argument_scanner  **************************)
(*                                                                      *)
(*                             find_keyword                             *)
(*                                                                      *)
(*      Given the first and last values of the range of possible key    *)
(*      words, return the one and only one that the user entered.       *)
(*      Set scanned_command status if any error.                        *)
(*                                                                      *)
(************************************************************************)

procedure entry FIND_KEYWORD(
      first_keyword     : command_keyword_index;
      last_keyword      : command_keyword_index;
  var scanned           : scanned_command;
  var keyword           : command_keyword_index);

var
  k     : integer;
  found : boolean;

begin
  found := FALSE;
  for k := first_keyword to last_keyword do
    if k in scanned.keyword_present
    then
      if found
      then scanned.status := ARG_ERROR
      else
        begin
          found := TRUE;
          keyword := k
        end (* for *);

  if found
  then keyword_used := keyword_used or [keyword]
  else scanned.status := ARG_MISSING
end (* find_keyword *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      check_keyword				*)
(*									*)
(*	Check and return whether a given keyword was entered. If so,	*)
(*	put keyword in 'keyword_used' for check of extra keywords.	*)
(*									*)
(************************************************************************)

function entry CHECK_KEYWORD(
      keyword : command_keyword_index;
      scanned : scanned_command) : boolean;

begin
  if keyword in scanned.keyword_present
  then
    begin
      keyword_used := keyword_used or [keyword];
      check_keyword := TRUE
    end
  else check_keyword := FALSE
end (* check_keyword *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  reset_argument_check				*)
(*									*)
(*	Set up for extra keyword and freeword check.			*)
(*									*)
(************************************************************************)

procedure entry RESET_ARGUMENT_CHECK;

begin
  keyword_used := [];
  freeword_used := 0
end (* reset_argument_check *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  extra_argument_check				*)
(*									*)
(*	Check if any extra keywords or freewords entered.		*)
(*									*)
(************************************************************************)

procedure entry EXTRA_ARGUMENT_CHECK(
  var scanned	: scanned_command);

begin
  if scanned.status = CMD_OK
  then
    if scanned.keyword_present <> keyword_used
    then scanned.status := TOO_MANY_ARGS
    else
      if scanned.freeword_count <> freeword_used
      then scanned.status := TOO_MANY_ARGS
end (* extra_argument_check *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init calendar
end (* argument_scanner *);
!
(************************************************************************)
(*									*)
(*	KEYUTL.NTV							*)
(*									*)
(*			keyword utility class				*)
(*									*)
(*	This class resides within any process wishing to process	*)
(*	keywords.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scanned, command_definition,				*)
(*	  keyword_definition, ascii_space, max_key_value_size		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added licenses						*)
(*	29SEP83  original from (patrol)cmdscn.bas - jnm			*)
(*									*)
(************************************************************************)



type KEYWORD_UTILITY = class(
	profile		: validator_profile;
	format		: internal_to_string;
	user_terminal	: circuit_handler;
	commands	: command_table;
	argument_scan	: argument_scanner);



(**************************  keyword_utility  ***************************)
(*									*)
(*			    add_last_keyword				*)
(*									*)
(************************************************************************)

procedure add_last_keyword(
      keyword	: keyword_name);

begin
  if format.buffer.size> 0
  then format.character(ASCII_SPACE);
  format.string('or \');
  format.keyword_string(keyword)
end (* add_last_keyword *);



(*************************  keyword_utility  ****************************)
(*									*)
(*		          output_next_keyword				*)
(*									*)
(************************************************************************)

procedure add_next_keyword(
      offset    	: keyword_index;
      keyword		: command_keyword_index;
      check_access	: boolean (* if TRUE, check keyword license *);
      subcommand_count	: command_keyword_total (* subcommands found *);
  var found_one		: boolean (* TRUE if keyword added *);
  var last_keyword	: keyword_name);

var
  keyword_entry : keyword_definition;

begin
  commands.get_keyword(offset, keyword, keyword_entry);
  if check_access and
    not profile.access_to_command(keyword_entry.required_license)
  then found_one := FALSE
  else
    begin (* validator has access to subcommand *)
      found_one := TRUE;
      if subcommand_count > 0
      then
        begin (* first one was previously found *)
	  if format.buffer.size > 0
	  then format.string(COMMA_SPACE);
	  format.keyword_string(last_keyword);
	  if format.buffer.size >=
	    (COMMAND_LINE_TEXT_MAX - (KEYWORD_NAME_MAX + 4))
	  then (* in case buffer overflows! *)
	    begin
	      format.string(COMMA_SPACE);
	      format.write_line(user_terminal);
	      format.start
	    end
	end (* first one was previously found *);
      last_keyword := keyword_entry.name
    end (* validator has access to subcommand *)
end (* add_next_keyword *);



(*************************  keyword_utility  ****************************)
(*									*)
(*		       output_or_set_command_keywords			*)
(*									*)
(*      For the command_definition, and validator license, either	*)
(*	output all keywords and prompt for the new sub-command or	*)
(*	return the one and only sub-command possible.			*)
(*									*)
(************************************************************************)

procedure entry OUTPUT_OR_SET_COMMAND_KEYWORDS(
      header    	: command_definition;
  var subcommand_count	: command_keyword_total (* subcommands found *);
  var only_subcommand	: command_keyword_index);

var
  keyword : command_keyword_index;
  found_one : boolean;
  last_keyword : keyword_name;

begin
  format.start; subcommand_count := 0;
  for keyword := 0 to header.subcommand_count - 1 do
    begin
      add_next_keyword(header.keyword_offset, keyword, TRUE, subcommand_count,
        found_one, last_keyword);
      if found_one
      then
        begin
	  subcommand_count := subcommand_count + 1 (* count it *);
	  only_subcommand := keyword
	end (* found_one *);
    end (* for *);
 if subcommand_count > 1
 then
   begin
     add_last_keyword(last_keyword);
     format.write_line(user_terminal) (* output all possible options *)
   end (* subcommand_count > 1 *)
end (* output_or_set_command_keywords *);
!



(*************************  keyword_utility  ****************************)
(*									*)
(*		         output_line_keywords				*)
(*									*)
(*      For the keywords_choices, output the keyword strings.		*)
(*									*)
(************************************************************************)

procedure entry OUTPUT_LINE_KEYWORDS(
      keyword_choices	: keyword_choice_set);

var
  keyword : line_keyword_index;
  found_one : boolean;
  subcommand_count : command_keyword_total;
  last_keyword : keyword_name;

begin
  format.start; subcommand_count := 0;
  for keyword := 0 to LINE_KEYWORD_LIMIT do
    if keyword in keyword_choices
    then
      begin
        add_next_keyword(LINE_KEYWORD_OFFSET, keyword, FALSE,
	  subcommand_count, found_one, last_keyword);
	if found_one
	then subcommand_count := subcommand_count + 1
      end (* keyword in keyword_choices *);
  add_last_keyword(last_keyword);
  format.write_block(user_terminal) (* output options *)
end (* output_line_keywords *);



(*************************  keyword_utility  ****************************)
(*									*)
(*		       get_numeric_keyword_value			*)
(*									*)
(************************************************************************)

procedure entry GET_NUMERIC_KEYWORD_VALUE(
      keyword		: command_keyword_index;
      base		: integer;
      lower_limit	: integer;
      upper_limit	: integer;
  var scanned		: scanned_command;
  var value		: univ integer);

var
  temp : integer;

begin
  if argument_scan.check_keyword(keyword, scanned)
  then 
    begin
      argument_scan.keyword_number(keyword, base, scanned, temp);
      if scanned.status = CMD_OK
      then
        if (temp >= lower_limit) and (temp <= upper_limit)
        then value := temp
	else scanned.status := ARG_NUMBER_OUT_OF_BOUNDS
    end
  else scanned.status := ARG_MISSING
end (* get_numeric_keyword_value *);



(*************************  keyword_utility  ****************************)
(************************************************************************)

begin
end (* keyword_utility *);
!
(************************************************************************)
(*									*)
(*	INPSCN.NTV							*)
(*									*)
(*			terminal input scanner class			*)
(*									*)
(*	This class resides within any process wishing to scan a text	*)
(*	line.  It handles scanning both command lines (the command	*)
(*	definitions reside within command_table monitor) and non-command*)
(*	text lines.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scanned, command_definition,				*)
(*	  keyword_definition, context_set, ascii_space,			*) 
(*	  max_key_value_size						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	27Jan86 - jrn							*)
(*	      - remove the use of size from COMMAND_PROMPT, and get rid	*)
(*		of scanned.error_column					*)
(*	14Nov84 Version 2.03 jrn					*)
(*	      - add input_list_description				*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added licenses						*)
(*	29SEP83  original from (patrol)cmdscn.bas - jnm			*)
(*									*)
(************************************************************************)



type TERMINAL_INPUT_SCANNER = class(
	profile		: validator_profile;
	mutil		: misc_utility;
	format		: internal_to_string;
	user_terminal	: circuit_handler;
	commands	: command_table;
	argument_scan	: argument_scanner;
	keyword_util	: keyword_utility);



const
  NULL_PROMPT = '\       ';
  KEYWORD_PROMPT = 'enter one: \';



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*				skip_spaces				*)
(*									*)
(*      Skip past all spaces.						*)
(*									*)
(************************************************************************)

procedure SKIP_SPACES(
      scanned	: scanned_command;
  var token	: command_token);

begin
  while scanned.input_line.text[token.finish] = ASCII_SPACE do
    token.finish := token.finish + 1
end (* skip_spaces *);



(**********************  terminal_input_scanner  ************************)
(*									*)
(*			      command_break				*)
(*									*)
(*	Determine if character is a command break character.		*)
(*									*)
(************************************************************************)

function command_break(
      test	: char) : boolean;

begin
  command_break := (test = ASCII_SPACE) or
    (test = ASCII_COMMA) or (test = ASCII_CARRIAGE_RETURN)
end (* command_break *);



(**********************  terminal_input_scanner  ************************)
(*									*)
(*				quote_break				*)
(*									*)
(*	Determine if character is the end of quoted text.		*)
(*									*)
(************************************************************************)

function quote_break(
      test	: char) : boolean;

begin
  quote_break := (test = ASCII_SINGLE_QUOTE) or (test = ASCII_CARRIAGE_RETURN)
end (* quote_break *);



(**********************  terminal_input_scanner  ************************)
(*									*)
(*				find_token				*)
(*									*)
(*	Find next separator.  Sets up token.				*)
(*									*)
(************************************************************************)

procedure find_token(
  var scanned	: scanned_command;
  var token	: command_token;
  var found	: boolean);

var
  skipped_comma : boolean;

begin
  skipped_comma := FALSE;
  skip_spaces(scanned, token);
  if token.finish > 0
  then
    if scanned.input_line.text[token.finish] = ASCII_COMMA
    then
      begin
        token.finish := token.finish + 1;
	skipped_comma := TRUE;
        skip_spaces(scanned, token)
      end;
  token.start := token.finish;

  if scanned.input_line.text[token.start] = ASCII_SINGLE_QUOTE
  then
    begin
      repeat
	token.finish := token.finish+1
      until quote_break(scanned.input_line.text[token.finish]);
      if scanned.input_line.text[token.finish] <> ASCII_SINGLE_QUOTE
      then scanned.status := BREAK_ERROR
      else
	begin
	  token.finish := token.finish+1;
	  if not command_break(scanned.input_line.text[token.finish])
	  then scanned.status := BREAK_ERROR
	end
    end
      else
	while not command_break(scanned.input_line.text[token.finish]) do
	  token.finish := token.finish + 1;
  if scanned.status = CMD_OK
  then
    if token.finish > token.start
    then found := TRUE
    else (* empty token *)
      if token.finish <> scanned.input_line.size - 1
      then scanned.status := ARG_ERROR (* error if not at end of line *)
      else
        if skipped_comma
        then scanned.status := ARG_ERROR (* trailing comma found *)
        else found := FALSE
end (* find_token *);
!
(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			      process_keyword				*)
(*									*)
(*     Routine to process command keyword.				*)
(*									*)
(************************************************************************)

procedure process_keyword(
      keyword	    : command_keyword_index;
      keyword_entry : keyword_definition;
  var scanned	    : scanned_command;
  var token	    : command_token);

var 
  found : boolean;

begin
  if not profile.access_to_command(keyword_entry.required_license)
  then scanned.status := AUTH_ERROR (* authorization error for keyword *)
  else
    if keyword in scanned.keyword_present
    then scanned.status := DUPLICATE_KEYWORDS
    else
      begin
        scanned.keyword_present := scanned.keyword_present or [keyword];
        scanned.keyword_count := scanned.keyword_count + 1;
        if keyword_entry.value_required
        then
          begin (* process command keyword value *)
	    find_token(scanned, token, found);
	    if found
	    then scanned.keyword_value[keyword] := token
	    else scanned.status := INV_KEYWORD
	  end (* process command keyword value *)
      end
end (* process_keyword *);
!
(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			     process_freeword				*)
(*									*)
(*      Routine to handle token described by token.			*)
(*	This routine sets up token as freeword if appropriate.		*)
(*									*)
(************************************************************************)

procedure process_freeword(
  var scanned : scanned_command;
  var token   : command_token);

begin
  if scanned.freeword_count < COMMAND_FREEWORD_MAX
  then
    begin (* freewords allowed and we have room for more *)
      scanned.freeword_value[scanned.freeword_count] := token;
      scanned.freeword_count := scanned.freeword_count + 1
    end (* freewords allowed and we have room for more *)
  else scanned.status := TOO_MANY_ARGS
end (* process_freeword *);
!
(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			    initialize_scanned				*)
(*									*)
(************************************************************************)

procedure initialize_scanned(
  var scanned	: scanned_command);

var
  i : command_line_text_index;

begin
  for i := 0 to scanned.input_line.size - 1 do
    if (LOWER_CASE_A <= scanned.input_line.text[i]) and
       (scanned.input_line.text[i] <= LOWER_CASE_Z)
    then scanned.input_line.text[i] :=
      chr(ord(scanned.input_line.text[i]) - 32);

  scanned.status := CMD_OK;
  scanned.keyword_count := 0;
  scanned.keyword_present := [];
  scanned.freeword_count := 0;

  argument_scan.reset_argument_check
end (* initialize_scanned *);



(**********************  terminal_input_scanner  ************************)
(*									*)
(*			    tokenize_command				*)
(*									*)
(*      Tokenize command line.						*)
(*									*)
(************************************************************************)

procedure tokenize_command(
      header	: command_definition;
  var scanned	: scanned_command;
  var token	: command_token);

var
  found_token : boolean;
  subcommand_satisfied : boolean;
  keyword_entry : keyword_definition;
  keyword : command_keyword_index;
  found_keyword : boolean;

begin
  subcommand_satisfied := header.subcommand_count = 0;

(* Pick up each token and call process_token to identify it	*)
(* as a subcommand, keyword or a freeword.			*)
  repeat
    find_token(scanned, token, found_token);
    if found_token
    then
      begin (* found a token *)
        if subcommand_satisfied (* check for a keyword *)
	then commands.find_command_keyword(header, scanned, token,
	  keyword, keyword_entry, found_keyword)
	else (* check for a subcommand *)
	  commands.find_subcommand_keyword(header, scanned, token,
	    keyword, keyword_entry, found_keyword);
	if found_keyword
	then
	  begin (* found subcommand or keyword, process it *)
	    process_keyword(keyword, keyword_entry, scanned, token);
	    if not subcommand_satisfied
	    then
	      if argument_scan.check_keyword(keyword, scanned)
	      then
	        begin (* got the required subcmd, save it *)
		  subcommand_satisfied := TRUE;
		  scanned.subcommand := keyword
		end (* got the required subcmd, save it *)
	  end (* found subcommand or keyword, process it *)
	else (* no subcommand or keyword identified *)
	  if not subcommand_satisfied
	  then scanned.status := SUBCOMMAND_MISSING
	  else (* check for possible freeword *)
	    if header.freeword_allowed
	    then process_freeword(scanned, token)
	    else scanned.status := ARG_ERROR
      end (* found token, identify it as a subcommand *)
    else
      if not subcommand_satisfied
      then scanned.status := SUBCOMMAND_MISSING (* no token available *)
  until not found_token or (scanned.status <> CMD_OK)
end (* tokenize_command *);

        

(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			      process_command				*)
(*									*)
(*      Routine to scan input string (inline) in scanned and return	*)
(*	command information in scanned.					*)
(*									*)
(************************************************************************)

procedure process_command(
      context	: context_set;
  var header    : command_definition;
  var scanned	: scanned_command);

var
  found  : boolean;
  token  : command_token;

begin
  initialize_scanned(scanned) (* clear values *);
  token.finish := 0;

  find_token(scanned, token, found);
  if not found
  then scanned.status := NO_CMD (* no command *);

  if scanned.status = CMD_OK
  then
    begin (* Lookup string in command table *)
      commands.find_command(context, token, scanned, header, found);
      if not found
      then scanned.status := CMD_ERROR
    end (* Lookup string in command table *);

  if scanned.status = CMD_OK
  then (* Check validator_type requirements for command *)
    if not profile.access_to_command(header.required_license)
    then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then tokenize_command(header, scanned, token)
end (* process_command *);



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			  input_and_scan_command			*)
(*									*)
(*      Routine to output the appropriate prompt, input a line		*)
(*	(scanned.input_line), scan the line, and return command		*)
(*	information in scanned.						*)
(*									*)
(************************************************************************)

procedure entry INPUT_AND_SCAN_COMMAND(
      command_context	: context_set;
  var scanned    	: scanned_command);

var
  header : command_definition;
  token  : command_token;
  subcommand_count : command_keyword_total;

begin
  commands.get_prompt(command_context, scanned);
  repeat

(* clear break status and tell user *)
    while user_terminal.break_pending do
      begin
        user_terminal.clear_break_status;
        user_terminal.write_quoted_text_line('<break>\')
      end (* while *);

    if user_terminal.sendable
    then
      begin (* prompt and read command *)
        format.start_and_newline;
	format.prompt(scanned.prompt);
	format.write_block(user_terminal);
	user_terminal.read_command_line(scanned.input_line)
      end (* prompt and read command *)
  until not user_terminal.break_pending;

  if user_terminal.sendable
  then
    begin
      process_command(command_context, header, scanned);

(*      The validator has entered a command without a required		*)
(*	subcommand.  If there is more than one choice, output all the	*)
(*	possible choices, and pretend it is a prompt.  Input the new	*)
(*	line into scanned.  Scan input_line and return command		*)
(*	information or error.  If there is a single subcommand choice,	*)
(*	set it as the subcommand entered.				*)

      while user_terminal.sendable and (scanned.status=SUBCOMMAND_MISSING) do
	begin
	  keyword_util.output_or_set_command_keywords(header, subcommand_count,
	    scanned.subcommand);
	  if subcommand_count = 0
	  then scanned.status := AUTH_ERROR (* no choices found for user! *)
	  else
	    if subcommand_count = 1
	    then scanned.status := CMD_OK (* only one choice found *)
	    else
	      begin (* re-prompt and re-process input line *)
	        user_terminal.write_line_and_quoted_text(KEYWORD_PROMPT);
		scanned.prompt := NULL_PROMPT;
		if user_terminal.sendable
		then user_terminal.read_command_line(scanned.input_line);
		if user_terminal.sendable
		then
		  begin
		    initialize_scanned(scanned) (* clear values *);
		    token.finish := 0 (* process all tokens *);
		    tokenize_command(header, scanned, token)
		  end (* user_terminal.sendable *)
	      end (* re-prompt and re-process input line *)
	end (* while *)
    end (* user_terminal.sendable *)
end (* input_and_scan_command *);



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			     scan_line_keyword				*)
(*									*)
(************************************************************************)

procedure scan_line_keyword(
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index);

var
  found : boolean;
  scanned : scanned_command;
  token : command_token;
  keyword_entry	: keyword_definition;

begin
  repeat
    found := FALSE;
    user_terminal.read_command_line(scanned.input_line);
    if user_terminal.sendable
    then
      begin
        initialize_scanned(scanned);
        token.finish := 0;
	find_token(scanned, token, found);
        if found
        then commands.find_line_keyword(keyword_choices, scanned, token,
	  keyword, keyword_entry, found);
      end (* sendable *);
    if user_terminal.sendable and not found
    then
      begin (* re-prompt *)
	keyword_util.output_line_keywords(keyword_choices);
	user_terminal.write_line_and_quoted_text(KEYWORD_PROMPT)
      end (* re-prompt *)
  until found or not user_terminal.sendable
end (* scan_line_keyword *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			    input_and_scan_line				*)
(*									*)
(*      Routine to output the supplied prompt, input a line		*)
(*	(scanned.input_line) and tokenize the line in scanned.		*)
(*									*)
(************************************************************************)

procedure entry INPUT_AND_SCAN_LINE(
      line_prompt	: quoted_text;
  var scanned    	: scanned_command);

var
  found  : boolean;
  token  : command_token;

begin
  user_terminal.write_quoted_text(line_prompt);
  user_terminal.read_command_line(scanned.input_line);
  if user_terminal.sendable
  then
    begin (* scan scanned.inline and return token info in scanned *)
      initialize_scanned(scanned) (* clear values *);
      scanned.prompt := NULL_PROMPT;
      token.finish := 0;

      repeat
        find_token(scanned, token, found);
        if found
        then process_freeword(scanned, token)
      until not found or (scanned.status <> CMD_OK);
      if (scanned.status = CMD_OK) and (scanned.freeword_count = 0)
      then scanned.status := NO_CMD
    end
end (* input_and_scan_line *);



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			  prompt_and_scan_keyword			*)
(*									*)
(*      Routine to output the supplied prompt, input a line		*)
(*	(scanned.input_line), tokenize the line and return		*)
(*	one of a number of keywords.					*)
(*									*)
(************************************************************************)

procedure entry PROMPT_AND_SCAN_KEYWORD(
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index);

begin
  keyword_util.output_line_keywords(keyword_choices);
  user_terminal.write_quoted_text('? \ ');
  scan_line_keyword(keyword_choices, keyword)
end (* prompt_and_scan_keyword *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			  input_and_scan_keyword			*)
(*									*)
(*      Routine to input a line (scanned.input_line), tokenize the line	*)
(*	and return one of a number of keywords.				*)
(*									*)
(************************************************************************)

procedure entry INPUT_AND_SCAN_KEYWORD(
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index);

begin
  scan_line_keyword(keyword_choices, keyword)
end (* input_and_scan_keyword *);


(************************************************************************)
(************************************************************************)

begin
end (* terminal_input_scanner *);
!
(************************************************************************)
(*									*)
(*	CMDERR.NTV							*)
(*									*)
(*			command_error_message				*)
(*									*)
(*	This class contains all command error message processing.	*)
(*	It will handle all command_scan_state messages except		*)
(*	CMD_OK, RUN_ERROR and NO_CMD. (Because there is nothing to	*)
(*	print.								*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scan_state						*)
(*	  scanned_command						*)
(*									*)
(************************************************************************)
(*									*)
(*	                     Revision Record                            *)
(*									*)
(*	29SEP83 original from (patrol)cmderr.bas - jrn			*)
(*									*)
(************************************************************************)


type COMMAND_ERROR_MESSAGE = class(
	user_terminal	: circuit_handler;
	format		: internal_to_string);



(************************  command_error_message  ***********************)
(*									*)
(*			   display_command_error			*)
(*									*)
(*	Display the appropriate command scanning error.			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_COMMAND_ERROR(
      scanned	: scanned_command);

begin
  with user_terminal, scanned do
    if (status <> CMD_OK) and (status <> RUN_ERROR)
    then
      case status of
        CMD_OK,
	RUN_ERROR,
	NO_CMD: (* no message *);
	CMD_ERROR:	write_quoted_text_line('invalid command\');
	ILLEGAL_CHAR:	write_quoted_text_line('illegal character entered\');
	BREAK_ERROR:	write_quoted_text_line('break char missing\ ');
	DUPLICATE_KEYWORDS:
	  write_quoted_text_line('duplicate keyword entered\');
	INV_KEYWORD:	write_quoted_text_line('illegal value\');
	AUTH_ERROR:
	  write_quoted_text_line('do not have proper authorization\ ');
	ARG_ERROR:	write_quoted_text_line('invalid argument\ ');
	ARG_MISSING:	write_quoted_text_line('argument missing\ ');
	TOO_MANY_ARGS:	write_quoted_text_line('too many arguments\ ');
	ARG_TOO_MANY_CHARS:	write_quoted_text_line('argument too long\');
	ARG_NUMBER_OUT_OF_BOUNDS:
	  write_quoted_text_line('number out of bounds\ ');
	ARG_FREEWORD_MISSING:	write_quoted_text_line('parameter missing\')
      end (* case *)
end (* display_command_error *);



(************************  command_error_message  ***********************)
(************************************************************************)

begin (* initial statement *) 
end (* command_error_message *);
!
(************************************************************************)
(*									*)
(*	FRUTIL.NTV							*)
(*			           					*)
(*			freeword_response_utility			*)
(*									*)
(*	This Class handles freeword values, both in scanned command	*)
(*	lines and as "prompted" for values.  Common routines are used	*)
(*	to re-prompt for errors.					*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	27Jan86 - jrn							*)
(*	      - change NULL_PROMPT to NULL_STRING			*)
(*	07Oct85 - jrn							*)
(*	      - add prompt_link_host (for VALIDATE_X25_NAMES flag)	*)
(*	10Jan85 - jrn							*)
(*	      - add get_numeric_freeword_value				*)
(*	31May84	Version 2.02 - jrn					*)
(*	      - add prompt_uun routine					*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type FREEWORD_RESPONSE_UTILITY = class(
	user_terminal	: circuit_handler;
	format		: internal_to_string;
	argument_scan	: argument_scanner;
	input_scanner	: terminal_input_scanner;
	scan_error	: command_error_message);




(*********************  freeword_response_utility  **********************)
(*									*)
(*			     input_number				*)
(*									*)
(************************************************************************)

procedure input_number(
      freeword	: command_freeword_index;
      base	: integer;
      min_value	: integer;
      max_value	: integer;
  var scanned   : scanned_command;
  var value	: univ integer);

var
  temp : integer;
  ptr : command_line_text_index;

begin
  argument_scan.freeword_number(freeword, base, scanned, temp);
  if scanned.status = CMD_OK
  then
    if (temp >= min_value) and (temp <= max_value)
    then value := temp
    else scanned.status := ARG_NUMBER_OUT_OF_BOUNDS;
  if scanned.status <> CMD_OK
  then
    begin	(* output command error *)
      scan_error.display_command_error(scanned);
      if scanned.status = ARG_NUMBER_OUT_OF_BOUNDS
      then
        if min_value = max_value
	then
	  begin
	    format.start_message('number should be the value: \ ');
	    format.number(min_value, base);
	    format.write_line(user_terminal)
	  end
	else
          begin
            format.start_message('"\');
	    for ptr := scanned.freeword_value[freeword].start to
	      scanned.freeword_value[freeword].finish - 1 do
	        format.character(scanned.input_line.text[ptr]);
	    format.string('" should be a\');
            if base = 10
            then format.string(' decimal\ ')
            else
              if base = 8
	      then format.string('n octal\')
	      else format.string(' hex\ ');
	    format.string(' number between \ ');
	    format.number(min_value, base);
	    format.string(' and \');
	    format.number(max_value, base);
	    format.write_line(user_terminal)
          end
    end
end (* input_number *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  freeword_response_utility  **********************)
(*									*)
(*			   get_freeword_number				*)
(*									*)
(************************************************************************)

procedure get_freeword_number(
      freeword		: command_freeword_index;
      base		: integer;
      min_value		: integer;
      max_value		: integer;
      was_prompted	: boolean (* TRUE if  prompted for freeword *);
			(* FALSE if user entered info on command line *)
  var scanned		: scanned_command;
  var value		: univ integer);

var
  prompted : boolean;
  done : boolean;
  this_freeword : command_freeword_index;

begin
  prompted := was_prompted;
  done := FALSE;
  this_freeword := freeword;
  while user_terminal.sendable and not done do
    begin
      if prompted and (scanned.freeword_count > 1)
      then scanned.status := TOO_MANY_ARGS;
      prompted := TRUE;
      if scanned.status = CMD_OK
      then input_number(this_freeword, base, min_value, max_value, scanned,
        value)
      else scan_error.display_command_error(scanned);
      if scanned.status = CMD_OK
      then done := TRUE
      else input_scanner.input_and_scan_line('reenter value: \', scanned)
    end
end (* get_freeword_number *);




(*********************  freeword_response_utility  **********************)
(*									*)
(*			    reset_number_list				*)
(*									*)
(************************************************************************)

procedure reset_number_list(
      max_entries	: general_number_list_size;
  var index		: general_number_list_index;
  var freeword		: command_freeword_index;
  var size		: general_number_list_size;
  var scanned		: scanned_command);

begin
  index := 0;
  freeword := 0;
  size := 0;
  if scanned.freeword_count > max_entries
  then scanned.status := TOO_MANY_ARGS
end (* reset_number_list *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_number_list				*)
(*									*)
(*      Input and validate a list of numbers.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_NUMBER_LIST(
      max_entries	: general_number_list_size;
      base		: integer;
      min_value		: integer;
      max_value		: integer;
  var numbers		: general_number_list);

var
  scanned : scanned_command;
  done : boolean;
  freeword : command_freeword_index;
  index : general_number_list_index;

begin
  done := FALSE;
  input_scanner.input_and_scan_line('\ ', scanned);
  reset_number_list(max_entries, index, freeword, numbers.size, scanned);
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then input_number(freeword, base, min_value, max_value,
        scanned, numbers.list[index])
      else
        if scanned.status = TOO_MANY_ARGS
	then
	  begin	(* report list too long *)
	    format.start_message('there may be a maximum of \ ');
	    format.number(max_entries, 10);
	    format.string(' entries in the list entered\ ');
	    format.write_line(user_terminal)
  	  end
	else scan_error.display_command_error(scanned);
      if scanned.status = CMD_OK
      then numbers.size := numbers.size + 1;
      if (scanned.status = CMD_OK) or
        (scanned.status = ARG_NUMBER_OUT_OF_BOUNDS)
      then
        if freeword + 1 >= scanned.freeword_count (* used all freewords *)
        then
	  if numbers.size > 0 (* any entries good? *)
	  then done := TRUE
	  else done := FALSE
        else
	  begin
	    freeword := freeword + 1	(* proceed to next freeword *);
	    if scanned.status = CMD_OK
	    then index := index + 1		(* increment numbers index *)
	    else scanned.status := CMD_OK
	  end;
      if not done and (scanned.status <> CMD_OK)
      then
        begin
	  input_scanner.input_and_scan_line('reenter list: \ ', scanned);
	  reset_number_list(max_entries, index, freeword, numbers.size,
	    scanned)
        end
    end
end (* prompt_number_list *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			     do_prompt_class				*)
(*									*)
(*      Ask for, input and validate class number.			*)
(*									*)
(************************************************************************)

procedure do_prompt_class(
      min_class		: integer;
  var scanned		: scanned_command;
  var class_number	: class_index);

begin
  input_scanner.input_and_scan_line('class: \', scanned);
  get_freeword_number(0, 10, min_class, MAXIMUM_CLASS, TRUE, scanned,
    class_number)
end (* do_prompt_class *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_class				*)
(*									*)
(*      Ask for, input and validate class number.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_CLASS(
      min_class		: integer;
  var scanned		: scanned_command;
  var class_number	: class_index);

begin
  do_prompt_class(min_class, scanned, class_number)
end (* prompt_class *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			       get_class				*)
(*									*)
(*      Get a class number from the freeword specified, and reprompt	*)
(*	if any error.							*)
(*									*)
(************************************************************************)

procedure entry GET_CLASS(
      freeword   : command_freeword_index;
  var scanned	 : scanned_command;
  var class_num	 : class_index);

begin
  if scanned.freeword_count = 0
  then do_prompt_class(FIRST_CLASS, scanned, class_num)
  else get_freeword_number(freeword, 10, FIRST_CLASS, MAXIMUM_CLASS, FALSE,
    scanned, class_num)
end (* get_class *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			      get_group					*)
(*									*)
(*      Get a group number from the freeword specified, and reprompt	*)
(*	if any error.							*)
(*									*)
(************************************************************************)

procedure entry GET_GROUP(
      freeword   : command_freeword_index;
  var scanned	 : scanned_command;
  var group_num	 : group_index);

begin
  if scanned.freeword_count = 0
  then
    begin
      input_scanner.input_and_scan_line('group: \', scanned);
      get_freeword_number(0, 10, FIRST_GROUP, MAXIMUM_GROUP, TRUE, scanned,
        group_num)
    end
  else get_freeword_number(freeword, 10, FIRST_GROUP, MAXIMUM_GROUP, FALSE,
    scanned, group_num)
end (* get_group *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			      prompt_host				*)
(*									*)
(*      Ask for, input and validate host number.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_HOST(
      host_prompt	: quoted_text;
  var scanned		: scanned_command;
  var host		: integer);

begin
  input_scanner.input_and_scan_line(host_prompt, scanned);
  get_freeword_number(0, 10, MINIMUM_HOST, MAXIMUM_HOST, TRUE, scanned, host)
end (* prompt_host *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			      prompt_node				*)
(*									*)
(*      Ask for, input and validate node number.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_NODE(
      node_prompt	: quoted_text;
  var scanned		: scanned_command;
  var node		: integer);

begin
  input_scanner.input_and_scan_line(node_prompt, scanned);
  get_freeword_number(0, 8, MINIMUM_NODE, MAXIMUM_NODE, TRUE, scanned, node)
end (* prompt_node *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			    prompt_district				*)
(*									*)
(*      Ask for, input and validate district number.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_DISTRICT(
  var scanned	: scanned_command;
  var district	: district_number);

begin
  input_scanner.input_and_scan_line('district: \ ', scanned);
  get_freeword_number(0, 10, MINIMUM_DISTRICT, MAXIMUM_DISTRICT,
    TRUE, scanned, district)
end (* prompt_district *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			      prompt_gan				*)
(*									*)
(*      Ask for, input and validate a gan.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_GAN(
      maximum_gan	: integer;
  var scanned		: scanned_command;
  var gan	 	: integer);

begin
  input_scanner.input_and_scan_line(GAN_PROMPT, scanned);
  get_freeword_number(0, 8, MINIMUM_GAN, maximum_gan, TRUE, scanned, gan)
end (* prompt_gan_number *);
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!


(*********************  freeword_response_utility  **********************)
(*									*)
(*		      prompt_access_entry_position			*)
(*									*)
(*      Ask for, input and validate an access entry position.		*)
(*									*)
(************************************************************************)

procedure entry prompt_access_entry_position(
      prompt		: quoted_text;
      max_position	: access_entry_size;
  var scanned		: scanned_command;
  var access_entry	: access_entry_index);

var
  temp : integer;

begin
  input_scanner.input_and_scan_line(prompt, scanned);
  get_freeword_number(0, 10, 1, max_position, TRUE, scanned, temp);
  if user_terminal.sendable
  then access_entry := temp - 1
end (* prompt_access_entry_position *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			    prompt_cud_word				*)
(*									*)
(************************************************************************)

procedure entry prompt_cud_word(
  var scanned	: scanned_command;
  var value	: univ integer);

begin
  input_scanner.input_and_scan_line(NULL_STRING, scanned);
  get_freeword_number(0, 16, MIN_INTEGER, MAX_INTEGER, TRUE, scanned, value)
end (* prompt_cud_word *);
!


(************************  freeword_response_utility  *******************)
(*									*)
(*			  get_freeword_username				*)
(*									*)
(************************************************************************)

procedure get_freeword_username(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var username	: username_string);

var
  done : boolean;
  this_freeword : command_freeword_index;

begin
  done := FALSE;
  this_freeword := freeword;
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then argument_scan.freeword_username(this_freeword, scanned, username);
      if scanned.status = CMD_OK
      then done := TRUE
      else
        begin
	  if scanned.status <> ARG_FREEWORD_MISSING
	  then scan_error.display_command_error(scanned);
	  input_scanner.input_and_scan_line(USERNAME_QUERY, scanned)
        end
    end
end (* get_freeword_username *);



(**********************  freeword_response_utility  *********************)
(*									*)
(*			     prompt_username				*)
(*									*)
(*      Ask for and input a legal username.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_USERNAME(
      username_prompt	: quoted_text;
  var username		: username_string);

var
  scanned : scanned_command;

begin
  input_scanner.input_and_scan_line(username_prompt, scanned);
  get_freeword_username(0, scanned, username)
end (* prompt_username *);



(**********************  freeword_response_utility  *********************)
(*									*)
(*				get_username				*)
(*									*)
(*      Input a legal username; if one is not already on the input	*)
(*	line in scanned, prompt for one.				*)
(*									*)
(************************************************************************)

procedure entry get_username(
      freeword		: command_freeword_index;
  var scanned		: scanned_command;
  var username		: username_string);

begin
  get_freeword_username(freeword, scanned, username)
end (* get_username *);
!
(**********************  freeword_response_utility  *********************)
(*									*)
(*			   get_freeword_listname			*)
(*									*)
(************************************************************************)

procedure get_freeword_listname(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var listname	: named_list_name);

var
  done : boolean;
  this_freeword : command_freeword_index;

begin
  done := FALSE;
  this_freeword := freeword;
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then argument_scan.freeword_listname(this_freeword, scanned, listname);
      if scanned.status = CMD_OK
      then done := TRUE
      else
        begin
          if scanned.status <> ARG_FREEWORD_MISSING
	  then scan_error.display_command_error(scanned);
	  input_scanner.input_and_scan_line('listname: \ ', scanned)
        end
    end
end (* get_freeword_listname *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_listname				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_LISTNAME(
      list_prompt	: quoted_text;
  var listname		: named_list_name);

var
  scanned : scanned_command; 

begin
  input_scanner.input_and_scan_line(list_prompt, scanned);
  get_freeword_listname(0, scanned, listname)
end (* prompt_listname *);




(***********************  freeword_response_utility  ********************)
(*									*)
(*		              get_listname                              *)
(*									*)
(************************************************************************)

procedure entry GET_LISTNAME(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var listname	: named_list_name);

begin
  get_freeword_listname(freeword, scanned, listname)
end (* get_freeword_listname *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			  prompt_time_in_minutes			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_TIME_IN_MINUTES(
      list_prompt	: quoted_text;
  var time		: integer);

var
  scanned : scanned_command; 
  done : boolean;

begin
  input_scanner.input_and_scan_line(list_prompt, scanned);
  done := FALSE;
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then argument_scan.freeword_time_in_minutes(0, scanned, time);
      if scanned.status = CMD_OK
      then done := TRUE
      else
        begin
          scan_error.display_command_error(scanned);
	  input_scanner.input_and_scan_line('reenter time: \ ', scanned)
        end
    end
end (* prompt_time_in_minutes *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  freeword_response_utility  ********************)
(*									*)
(*			  get_numeric_freeword_value			*)
(*									*)
(************************************************************************)

procedure entry GET_NUMERIC_FREEWORD_VALUE(
      freeword	: command_freeword_index;
      base	: integer;
      min_value	: integer;
      max_value	: integer;
  var scanned	: scanned_command;
  var number	: integer);

begin
  input_number(freeword, base, min_value, max_value, scanned, number);
  if scanned.status <> CMD_OK
  then scanned.status := RUN_ERROR
end (* get_numeric_freeword_value *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* freeword_response_utility *);
!
(************************************************************************)
(*									*)
(*	KEYSCN.NTV							*)
(*									*)
(*			keyword scanner class				*)
(*									*)
(*	This class resides within any process wishing to process	*)
(*	keywords.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scanned, command_definition,				*)
(*	  keyword_definition, context_set, ascii_space,			*) 
(*	  max_key_value_size						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	03Apr84	Version 2.02 0- jrn					*)
(*	      - append "? " to questions here				*)
(*	29SEP83  original from (patrol)cmdscn.bas - jnm			*)
(*									*)
(************************************************************************)

type KEYWORD_SCANNER = class(
	user_terminal	: circuit_handler;
	input_scanner	: terminal_input_scanner);

!



(***************************  keyword_scanner  **************************)
(*									*)
(*			    input_answer				*)
(*									*)
(*      Routine to output the supplied prompt, input a line		*)
(*	(scanned.input_line) and return TRUE if a yes was entered.	*)
(*									*)
(************************************************************************)

function entry INPUT_ANSWER(
      line_prompt	: quoted_text) : boolean;

var
  keyword : line_keyword_index;

begin
  user_terminal.write_quoted_text(line_prompt);
  user_terminal.write_quoted_text('? \ ');
  input_scanner.input_and_scan_keyword([LINE_YES_KEYWORD, LINE_NO_KEYWORD],
    keyword);
  if user_terminal.sendable
  then input_answer := keyword = LINE_YES_KEYWORD
  else input_answer := FALSE
end (* input_answer *) ;



(************************************************************************)
(************************************************************************)

begin
end (* keyword_scanner *) ;
!
(************************************************************************)
(*									*)
(*	GLBCMD.NTV							*)
(*									*)
(*				global_commands 			*)
(*									*)
(*	This class contains the global commands which should be 	*)
(*	accessable from all contexts.					*)
(*									*)
(*	The routines are organized as follows:				*)
(*		HELP Command						*)
(*		MESSAGE Command						*)
(*		General scan_command					*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  operator_log							*)
(*	  argument_scanner, scanned_command				*)
(*	  terminal_input_scanner, operator_messages			*)
(*	  log_message, oper_log_page_index				*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	03Sep 86- neh							*) 
(*	      - Move PRINT_LOG_MESSAGE and SCAN_MESSAGE_COMMAND		*)
(*		to command_level_utility.				*)
(*	      - Remove GLOBAL_MESSAGE in scan_command.			*)
(*            - Remove the parameter for operator_log.                  *)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGES FROM command to NVDM			*)
(*	24JAN86 - jrn							*)
(*	      - use format COMMAND_STRING and KEYWORD_STRING routines	*)
(*	      - change processing of HELP command to accomodate the	*)
(*		removal of command and keyword sizes			*)
(*	29Jul85 - jrn							*)
(*	      - move find_timed_message from oplog; add <break>		*)
(*		handling; change search to handle bigger files		*)
(*	21Jun84 - jrn							*)
(*	      - add disk_maintenenace_code				*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added licenses						*)
(*	29SEP83 original - from (patrol)glbcmd.bas - jrn		*)
(*									*)
(************************************************************************)


type GLOBAL_COMMANDS = class(
      validator		: licensed_validator_index;
      profile		: validator_profile;
      statistics	: statistics_gatherer;
      user_terminal	: circuit_handler;
      argument_scan	: argument_scanner;
      format		: internal_to_string;
      input_scanner	: terminal_input_scanner;
      scan_error	: command_error_message;
      commands		: command_table);


const
  HELP_COLUMN_START = KEYWORD_NAME_MAX + 1;
!
"
		HELP command
"


(**************************  global_commands  ***************************)
(*									*)
(*		              help_command	           		*)
(*									*)
(************************************************************************)

procedure help_command(
      context	: context_set;
  var scanned	: scanned_command);

var
  done : boolean;
  header : command_definition;
  subcommands_done : boolean;
  keyword : command_keyword_index;
  keyword_entry : keyword_definition;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      commands.start_help(validator, context);
      repeat
	user_terminal.write_newline;
        commands.next_help_command_info(profile, context, done, header);
	if not done
	then
	  begin
	    format.start;
	    format.command_string(header.name);
	    format.skip_to(HELP_COLUMN_START);
	    format.help_text_string(header.explanation);
	    format.write_line(user_terminal);
	    if header.subcommand_count > 0
	    then
	      begin (* output all appropriate subcommands *)
	        subcommands_done := FALSE; keyword := 0;
	        repeat
	          commands.get_keyword(header.keyword_offset, keyword,
		    keyword_entry);
	          if profile.access_to_command(keyword_entry.required_license)
	          then
	            begin
		      format.start_message(' \') (* output subcommand line *);
		      format.keyword_string(keyword_entry.name);
		      format.skip_to(HELP_COLUMN_START);
		      format.help_text_string(keyword_entry.explanation);
		      format.write_line(user_terminal)
	            end;
	          if keyword = header.subcommand_count - 1
	          then subcommands_done := TRUE
	          else keyword := keyword + 1
	        until subcommands_done or not user_terminal.sendable
	      end
	  end
      until done or not user_terminal.sendable;
      user_terminal.write_newline
    end
end (* help_command *);
!


(**************************  global_commands  ***************************)
(*									*)
(*			      scan_command	 			*)
(*									*)
(*	Parse and execute the global command just entered.		*)
(*									*)
(************************************************************************)


procedure entry SCAN_COMMAND(
      context	: context_set;
  var scanned	: scanned_command);

begin
  case scanned.command of

    GLOBAL_DATE:
      begin
	format.start;
	format.time(realtime);
	format.string('  GMT\');
	format.write_line(user_terminal)
      end (* global_date *);

    GLOBAL_HELP: help_command(context, scanned);

    GLOBAL_VERSION:
      begin
	format.start;
	format.scaled_number(version*100+revision, 10, 2);
	format.write_line(user_terminal)
      end (* global_version *);

      GLOBAL_STATISTICS: statistics.print_statistics(format, user_terminal)

  end (* case *);

  scan_error.display_command_error(scanned)

end (* scan_command *);

(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* global_command *);
!
(************************************************************************)
(*									*)
(*	CMDLP.NTV							*)
(*									*)
(*				command_loop				*)
(*									*)
(*	This class contains the command loop for all command input.	*)
(*	It is called to request a command in the context which it	*)
(*	maintains. It handles all global command processing,		*)
(*	i.e., commands to be recognized in all contexts which do not	*)
(*	do a context switch. It returns when either it scans a		*)
(*	command not in the global context or when the circuit is	*)
(*	lost. The caller must be able to handle any command returned.	*)
(*	This is accomplished by manipulating the context.		*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  validator_index, command_table				*)
(*	  scanned_command						*)
(*	  terminal_input_scanner					*)
(*									*)
(************************************************************************)
(*									*)
(*	                     Revision Record                            *)
(*									*)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGES FROM command to NVDM			*)
(*	29SEP83	Original from (patrol)cmdlp.bas - jrn			*)
(*									*)
(************************************************************************)


type COMMAND_LOOP = class(
      validator  	: validator_index;
      profile		: validator_profile;
      statistics	: statistics_gatherer;
      user_terminal	: circuit_handler;
      argument_scan	: argument_scanner;
      format		: internal_to_string;
      input_scanner	: terminal_input_scanner;
      scan_error	: command_error_message;
      commands		: command_table);

var
  global  : global_commands;

  entry context : context_set (* validator's current context set *);
!
(***************************  command_loop  *****************************)
(*									*)
(*			      	add_class				*)
(*									*)
(*	Add a command class to the 'context' used to determine which	*)
(*	commands are recognized by the command scanned.			*)
(*									*)
(************************************************************************)

procedure entry ADD_CLASS(
      command_class	: command_class_index);

begin
  context := context or [command_class]
end (* add_class *);



(***************************  command_loop  *****************************)
(*									*)
(*			       remove_class				*)
(*									*)
(*	Remove a command class from the 'context' used to determine	*)
(*	which commands are recognized by the command scanned.		*)
(*									*)
(************************************************************************)

procedure entry REMOVE_CLASS(
      command_class	: command_class_index);

begin
  context := context - [command_class]
end (* remove_class *);



(***************************  command_loop  *****************************)
(*									*)
(*			      get_command				*)
(*									*)
(*	This is where all commands are read. It calls input_scanner	*)
(*	to retrieve a command line that has been input and parsed,	*)
(*	filters out global command and only returns with a well		*)
(*	scanned non global command from the current context, or when	*)
(*	the user terminal is lost.					*)
(*									*)
(************************************************************************)

procedure entry GET_COMMAND(
  var scanned	: scanned_command);

var
  found : boolean (* TRUE if non global command found *);

begin
  repeat
    found := FALSE;
    input_scanner.input_and_scan_command(context, scanned);
    if user_terminal.available
    then
      begin
        if scanned.status <> CMD_OK
	then scan_error.display_command_error(scanned)
	else
	  if scanned.command_class = GLOBAL_CLASS
	  then global.scan_command(context, scanned)
	  else found := TRUE
      end (* if available then *)
  until found or not user_terminal.available
end (* get_command *);


(*****************************  command_loop  ***************************)
(************************************************************************)

begin (* initial statement *)
  init global(validator, profile, statistics, user_terminal, argument_scan,
    format, input_scanner, scan_error, commands);

  context := [GLOBAL_CLASS]
end (* command_loop *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	cmdutl.ntv							*)
(*									*)
(*			command_level_utility				*)
(*									*)
(*	This class performs routines common to command_level and other	*)
(*	processes.							*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	12Sep86 - neh							*) 
(*	      - Changed report_block_written to call			*)
(*		report_validator_sup_message.				*)
(*	28Aug86 - jrn							*)
(*	      - mark all Tymshare "old" password code with:		*)
		(*******...  old password code  ...*******)
(*	08Jul86 - jrn							*)
(*	      - add SPECIAL flag (CLEAN and OLDPASS commands)		*)
(*	06Aug86 - jrn							*)
(*	      - add GFDONLY to SELECT PASSWORDDATE command		*)
(*	18Jul86 - jrn							*)
(*	      - handle CUD_ENTRY_IN_WRONG_BLOCK in DISPLAY DIRECTORY	*)
(*		command							*)
(*      12May86 - neh							*)
(*	      - Move all procedures in command_level process which      *)
(*    	        are used to display the cud to command_level_utility    *)
(*		to be used by other processes. Add the following.	*)
(*		  clear_criteria					*)
(*		  Input Routines					*)
(*		    (get_radix_criteria_values)				*)
(*		  Output Routines					*)
(*    	 	    (check_line_length_and_write, format_origins,	*)
(* 		     write_access_profile)		 		*)
(*	  	  Miscellaneous Programmer routines (CUD/MUD handling)	*)
(*		  Command Routines					*)
(*		    (CHANGE CUD, DISPLAY_SELECT, DISPLAY_BLOCK,		*)
(*		     DISPLAY_DIRECTORY, READ CUD/MUD, SELECT,		*)
(*		     WRITE CUD/MUD)					*)
(*	31Mar86	Original - jrn						*)
(*									*)
(************************************************************************)


const
  DISK_READ_ERROR_MESSAGE = 'disk read error\';
  DISK_WRITE_ERROR_MESSAGE = 'disk write error\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  NO_GANS_MESSAGE = 'GANs are not included in CUD entries\ ';
  NO_DISTRICTS_MESSAGE = 'Districts are not included in CUD entries\';

  MAX_HOST_OUTPUT = 5;

(* used by the DISPLAY_DIRECTORY_COMMAND and DUMP command *)
type
  DESIGNATED_FIELDS = array [fields] of boolean;


type COMMAND_LEVEL_UTILITY = class(
      validator		: validator_index;
      sys_io		: system_handler;
      mutil		: misc_utility;
      calendar		: date_time_converter;
      format		: internal_to_string;
      profile		: validator_profile;
      oper_messages	: operator_messages;
      aux_io		: circuit_handler;
      user_terminal	: circuit_handler;
      cud_access	: cud_access_controller;
      block_utility	: cud_block_utility;
      block_updater	: cud_block_updater;
      cud_entry_util	: cud_entry_utility;
      cud_updater     	: cud_entry_updater;
      cud_utility	: cud_updater_utility;
      un2_util		: un2_utility;
      login_pool	: login_distributer;
      argument_scan	: argument_scanner;
      keyword_util	: keyword_utility;
      input_scanner	: terminal_input_scanner;
      freeword_utility	: freeword_response_utility;
      keyword_scan	: keyword_scanner;
      dsksys		: disk_system);



const
(* Following constant and type definitions are used to display the CUD. *)

  NO_PAGINATION = -1 (* pagination constant *);


(* Maximum lengths of various outputs *)

  MAX_OUTPUT_LINE = COMMAND_LINE_TEXT_MAX;

  MAX_GAN_OUTPUT = 11;

  MAX_UUN_OUTPUT = 11;

  MAX_DISTRICT_OUTPUT = 4;

  MAX_CONTROL_OUTPUT = 21;

  MAX_USERNAME_OUTPUT = 20;

(* count characters in ", (host), " *)
  MAX_ACCESS_ENTRY_DESTINATION_OUTPUT = max_host_output + 10;

  BLOCK_READ = 'block read\ ';
  BLOCK_WRITTEN = 'block written\';

(* Criteria_control_options are only used in conjunction *)
(* with the permanent variable, criteria. *)

  FIRST_CRITERIA_CONTROL_OPTION = licensed;
  LAST_CRITERIA_CONTROL_OPTION = transparent_login;

type
  CRITERIA_CONTROL_OPTIONS =
    first_criteria_control_option..last_criteria_control_option;


  BUFFER_DESCRIPTION = record
    empty	: boolean (* TRUE if no data here *);
    block	: cud_block_index
  end (* buffer_description *);


(* The following data structures are used to describe *)
(* the criteria created with the SELECT command. *)

  RANGE_CRITERIA_INDEX = ACCESS_CRITERION..UUN_CRITERION;

  DATE_CRITERIA_INDEX = ENTRYDATE_CRITERION..PASSWORDDATE_CRITERION;

  ACCESS_VALUE_TYPES = (HOST_ACCESS, NODE_ACCESS, CLASS_ACCESS, GROUP_ACCESS);

  DATE_CRITERIA_QUALIFIER = (
    NO_DATE_QUALIFIER,
    AFTER_DATE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    BEFORE_DATE);

  DATE = record
    time      : integer;
    qualifier : date_criteria_qualifier
  end (* date *);

  USER_CRITERIA_SELECTIONS = record
    used		: array [criteria_type] of boolean;
    range_criteria	: array [range_criteria_index] of range;
    access_type		: access_value_types;
    date_criteria	: array [date_criteria_index] of date;
    control		: array [criteria_control_options] of boolean
  end (* user_criteria_selections *);


		(* permanent variables *)

var
  cud_info		: buffer_description;

  mud_info		: buffer_description;

  criteria		: user_criteria_selections;

!
"
	HOST Info Routines
"


(***********************  command_level_utility  ************************)
(*									*)
(*			  make_first_host_info_message			*)
(*									*)
(************************************************************************)

procedure make_first_host_info_message;

begin
  format.string('Host \');
  format.number(sys_io.sys_info.host_number, 10);
  format.string(' is \ ');
  format.host_state_name(sys_io.current_host_state)
end (* make_first_host_info_message *);



(***********************  command_level_utility  ************************)
(*									*)
(*			  make_second_host_info_message			*)
(*									*)
(************************************************************************)

procedure make_second_host_info_message;

begin
  format.newline; format.string('This hardware is identified by:\');
  format.newline; format.string('   node: \');
  format.number(sys_io.sys_info.node_number, 8);
  format.newline; format.string('   kernel host: \ ');
  format.number(sys_io.sys_info.kernel_host_number, 10)
end (* make_second_host_info_message *);



(***********************  command_level_utility  ************************)
(*									*)
(*			   do_display_host_info				*)
(*									*)
(************************************************************************)

procedure do_display_host_info;

begin
  format.start; make_first_host_info_message;
  format.write_line(user_terminal);

  format.start; make_second_host_info_message;
  format.write_line(user_terminal);
  user_terminal.write_newline
end (* do_display_host_info *);



(***********************  command_level_utility  ************************)
(*									*)
(*			    display_host_info				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_HOST_INFO;

begin
  do_display_host_info
end (* display_host_info *);



(***********************  command_level_utility  ************************)
(*									*)
(*			report_logged_in_validators			*)
(*									*)
(************************************************************************)

procedure report_logged_in_validators(
      count		: univ integer;
      validator_message	: quoted_text);

begin
  if count <> 0
  then
    begin
      format.format_number(count, 10, 4);
      format.character(ASCII_SPACE);
      format.string(validator_message);
      format.string(' validator\ ');
      if count > 1
      then format.character(LOWER_CASE_S);
      format.newline
    end (* count <> 0 *)
end (* report_logged_in_validators *);



(***********************  command_level_utility  ************************)
(*									*)
(*			make_validator_report_message			*)
(*									*)
(************************************************************************)

procedure make_validator_report_message;

var
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  password_only_count : password_only_validator_count;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  licensed_count : licensed_validator_count;
  programmer_count : integer (* should only be 0 or 1! *);
  total_count : integer;

begin
  total_count := 0;
  login_pool.validator_count(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    password_only_count,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    licensed_count, programmer_count);
  format.start_message('logged in:\ ');
  format.newline;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  report_logged_in_validators(password_only_count, PASSWORD_ONLY_MESSAGE);
  total_count := total_count + password_only_count;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  report_logged_in_validators(licensed_count, LICENSED_MESSAGE);
  total_count := total_count + licensed_count;
  report_logged_in_validators(programmer_count, PROGRAMMER_MESSAGE);
  total_count := total_count + programmer_count;
  if total_count = 0
  then format.string('   none\')
end (* make_validator_report_message *);



(***********************  command_level_utility  ************************)
(*									*)
(*			   host_status_command				*)
(*									*)
(************************************************************************)

procedure entry HOST_STATUS_COMMAND;

begin
  do_display_host_info;

  make_validator_report_message;
  format.write_block(user_terminal)
end (* host_status_command *);



(***********************  command_level_utility  ************************)
(*									*)
(*			    get_host_info				*)
(*									*)
(*	Add the host info data to format for writing to the		*)
(*	operator log.							*)
(*									*)
(************************************************************************)

procedure entry GET_HOST_INFO;

begin
  make_first_host_info_message;
  format.newline;
  make_second_host_info_message
end (* get_host_info *);



(***********************  command_level_utility  ************************)
(*									*)
(*			    get_validator_info				*)
(*									*)
(*	Add validator info to format for writing to the operator log.	*)
(*									*)
(************************************************************************)

procedure entry GET_VALIDATOR_INFO;

begin
  make_validator_report_message 
end (* get_validator_info *);
!
"
	Clear Criteria for DISPLAY CUD Data
"



(************************  command_level_utility  ***********************)
(*									*)
(*			   do_clear_criteria				*)
(*									*)
(*	Clears all criteria or a specified criteria.			*)
(*									*)
(************************************************************************)

procedure do_clear_criteria(
      criteria_to_clear	: criteria_type);

var
  index : criteria_type;
  no_criteria_used : boolean;

begin
  if criteria_to_clear = ALL_CRITERIA
  then
    begin (* clear all criteria *)
      for index := ALL_CRITERIA to PASSWORDDATE_CRITERION do
	criteria.used[index] := FALSE;
      if (ACCOUNT_SUPERVISOR_LICENSE in profile.licenses) and
        not (AUDITOR_LICENSE in profile.licenses)
      then
	begin (* without proper license, sel. is limited to validator's GAN *)
	  criteria.used[GAN_CRITERION] := TRUE;
	  criteria.range_criteria[GAN_CRITERION].first := profile.gan;
	  criteria.range_criteria[GAN_CRITERION].last := profile.gan
	end (* without proper license, sel. is limited to validator's GAN *)
      else criteria.used[ALL_CRITERIA] := TRUE
    end (* clear all criteria *)
  else
    begin (* clear single specified criteria *)
      criteria.used[criteria_to_clear] := FALSE;
      no_criteria_used := TRUE;
      for index := ACCESS_CRITERION to PASSWORDDATE_CRITERION do
	if criteria.used[index]
	then no_criteria_used := FALSE;
      if no_criteria_used
      then criteria.used[ALL_CRITERIA] := TRUE
    end (* clear single specified criteria *)
end (* do_clear_criteria *);



(************************  command_level_utility  ***********************)
(*									*)
(*			 clear_criteria_and_buffer			*)
(*									*)
(************************************************************************)

procedure entry CLEAR_CRITERIA_AND_BUFFER(
      criteria_to_clear	: criteria_type);

begin
  do_clear_criteria(criteria_to_clear);
  cud_info.empty := TRUE;
  mud_info.empty := TRUE
end (* clear_criteria_and_buffer *);
!
"
	Input Routines
"


(************************  command_level_utility  ***********************)
(*									*)
(*			  criteria_value_radix				*)
(*									*)
(*	Set radix for criteria_index - ACCESS_CRITERION's radix is	*)
(*	based on access_type						*)
(*									*)
(************************************************************************)

function criteria_value_radix(
      criteria_index	: criteria_type;
      access_index	: access_value_types) : integer;

begin
  case criteria_index of
    GAN_CRITERION: criteria_value_radix := 8;
    UUN_CRITERION: criteria_value_radix := UUN_RADIX;
    DISTRICT_CRITERION: criteria_value_radix := 10;
    ACCESS_CRITERION:
      case access_index of
        HOST_ACCESS,
	CLASS_ACCESS,
	GROUP_ACCESS: criteria_value_radix := 10;
	NODE_ACCESS: criteria_value_radix := 8
      end (* case criteria_index *)
  end (* case access_index *)
end (* criteria_value_radix *);



(************************  command_level_utility  ***********************)
(*									*)
(*			 do_clear_designated_fields			*)
(*									*)
(*	Clear fields.							*)
(*									*)
(************************************************************************)

procedure do_clear_designated_fields(
  var selected_fields	: designated_fields);

var
  field_index : fields;

begin
  for field_index := ALL_FIELDS to ACCESS_FIELD do
    selected_fields[field_index] := FALSE
end (* do_clear_designated_fields *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  command_level_utility  ***********************)
(*									*)
(*			  clear_designated_fields			*)
(*									*)
(*	Clear fields.							*)
(*									*)
(************************************************************************)

procedure entry CLEAR_DESIGNATED_FIELDS(
  var selected_fields	: designated_fields);

begin
  do_clear_designated_fields(selected_fields)
end (* clear_designated_fields *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	Output Routines
"
(*				CAUTION					*)
(* The following output routines are used by both display directory 	*)
(* and the Archive dump command. Do not make changes to these routines 	*)
(* without checking that the change will work for both display		*)
(* directory and the dump command.					*)



(************************  command_level_utility  ***********************)
(*									*)
(*	 	     do_check_line_length_and_write    			*)
(*									*)
(*	If not at start_line, output delimiter; if too close to end	*)
(*	of line, output current line and start next; a value should	*)
(*	always be output after this call; max_size should be large 	*)
(*	enuf to accomodate "delimiter value delimiter," i.e.,		*)
(*			, value,					*)
(*									*)
(************************************************************************)

procedure do_check_line_length_and_write(
      max_size		: integer (* max spaces for an entry *);
      start_line	: format_buffer_text_index;
      delimiter		: quoted_text);

begin
  if format.buffer.size + max_size > MAX_OUTPUT_LINE
  then
    begin (* entry will not fit on current line, add delimiter and output *)
      format.string(delimiter);
      format.write_line(user_terminal);
      format.start;
      format.skip_to(start_line);
    end (* entry will not fit on current line, add delimiter and output *)
  else
   if format.buffer.size <> start_line
   then format.string(delimiter) (* entry will fit, output delimiter *)
end (* do_check_line_length_and_write *);



(*********************  command_level_utilty  ***************************)
(*									*)
(*	             check_line_length_and_write			*)
(*									*)
(************************************************************************)

procedure entry CHECK_LINE_LENGTH_AND_WRITE(
      max_size		: integer (* max spaces for an entry *);
      start_line	: format_buffer_text_index;
      delimiter		: quoted_text);

begin
  do_check_line_length_and_write(max_size, start_line, delimiter)  
end (* check_line_length_and_write *);



(********************  command_level_utility  ***************************)
(*									*)
(*			  format_origins				*)
(*									*)
(************************************************************************)

procedure format_origins(
      access_entry	: access_entry_description;
      host_origin	: boolean;
      short_display	: boolean;
      tape_display	: boolean;
  var index		: in_place_origin_index;
  var finished		: boolean);

var
  first_index : boolean;
  not_origin : boolean;
  radix : integer;

begin
  first_index := TRUE;
  if not short_display
  then
    begin
      format.newline;
      format.skip(3)
    end (* not short_display *);
  if access_entry.exception
  then
    begin
      not_origin := TRUE;
      if (not short_display or host_origin) and not tape_display
      then
	begin
	  format.string(' (not)\ ');
	  if not short_display
	  then format.skip(1);
	end
    end
  else
    begin
      not_origin := FALSE;
      if not short_display
      then format.skip(7)
    end;

  if host_origin
  then radix := 10
  else radix := 8;
  while (access_entry.origin.list[index].host_flag = host_origin) and
    not finished do
    begin
      if short_display
      then
        begin
	  format.skip(1);
          if tape_display
          then
	    if not_origin
	    then format.character('N')
	    else format.character('O');
          if access_entry.origin.list[index].host_flag
          then format.character('H')
          else format.character('N')
        end
      else
	if first_index
	then
	  begin
	    first_index := FALSE;
	    if host_origin
	    then format.string(HOST_MESSAGE)
	    else format.string(NODE_MESSAGE);
	    format.string('s: \')
	  end
	else format.string(COMMA_SPACE);
      format.number(access_entry.origin.list[index].value, radix);
      if index = access_entry.origin.size - 1
      then finished := TRUE
      else index := index + 1
    end
end (* format_origins *);



(*******************  command_level_utility  ****************************)
(*									*)
(*			write_access_entry				*)
(*									*)
(*	Writes out a single access profile entry.		   	*)
(*									*)
(************************************************************************)

procedure write_access_entry(
      index		: access_entry_index;
      access_entry	: access_entry_description;
      short_display	: boolean;
      tape_display	: boolean);

var
  origin_index : in_place_origin_index;
  dest_index : destination_index;
  printing_groups : boolean (* TRUE if last destination written was group *);
  finished : boolean;
  start_line : format_buffer_text_index;

begin
  finished := FALSE;
  if not tape_display
  then
    begin
      if short_display
      then format.skip_to(2);
      format.character(ASCII_LEFT_PARENS)
    end (* not tape_display *);
  format.number(index + 1, 10);
  if not tape_display
  then
    begin
      format.string(') Origin\ ');
      if short_display
      then format.character(ASCII_COLON)
      else
        begin
          format.string('     \');
          format.colon_space
        end (* short_display *)
    end (* not tape_display *);
  origin_index := 0;
  if access_entry.in_place_origin
  then
    begin
      if access_entry.origin.list[origin_index].host_flag
      then format_origins(access_entry, TRUE, short_display, tape_display,
	origin_index, finished);
      if not finished
      then format_origins(access_entry, FALSE, short_display, tape_display,
	origin_index, finished)
    end (* in place origin *)
  else
    begin (* class origin *)
      if short_display
      then format.string(' C\ ')
      else format.string('class: \');
      format.number(access_entry.class_no, 10)
    end (* class origin *);
  if not short_display
  then
    begin
      format.write_line(user_terminal);
      format.start;
      format.skip(2)
    end (* not short_display *);

(* write destination *)
  if not tape_display then format.string('  Destination:\ ');
(* the following insures the printing of the first header, i.e., *)
(* it will not match the first time thru... *)
  printing_groups := not access_entry.destination.list[0].group_flag;
  for dest_index := 0 to access_entry.destination.size - 1 do
    begin
      if not short_display
      then
        if access_entry.destination.list[dest_index].group_flag =
	  printing_groups (* same as last value? *)
	then do_check_line_length_and_write(
	  MAX_ACCESS_ENTRY_DESTINATION_OUTPUT, start_line, COMMA_SPACE)
	else
	  begin (* this value is different from last, output header *)
	    format.write_line(user_terminal);
	    if printing_groups
	    then format.start_message('          hosts: \')
	    else format.start_message('         groups: \');
	    start_line := format.buffer.size;
	    printing_groups := not printing_groups (* reset *)
	  end (* this value is different from last, output header *)
      else
        begin (* short_display *)
	  format.skip(1);
	  if access_entry.destination.list[dest_index].home_flag
	  then format.character('H');
	  if access_entry.destination.list[dest_index].group_flag
	  then format.character('G')
	  else format.character('H')
	end (* short_display *);
      format.number(access_entry.destination.list[dest_index].value, 10);
      if not short_display
      then
        if access_entry.destination.list[dest_index].home_flag
	then format.string(' (home)\')
    end (* for *)
end (* write_access_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*******************  command_level_utility  ****************************)
(*									*)
(*			write_access_entry_to_tape			*)
(*									*)
(*	Writes out a single access profile entry to tape (short display)*)
(*									*)
(************************************************************************)

procedure entry WRITE_ACCESS_ENTRY_TO_TAPE(
      index		: access_entry_index;
      access_entry	: access_entry_description);

begin
  write_access_entry(index, access_entry, TRUE, TRUE)
end (* write_access_entry_to_tape *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  command_level_utility  ***********************)
(*									*)
(*			  do_write_access_profile			*)
(*									*)
(*	Writes out access profile in user's cud entry		   	*)
(*									*)
(************************************************************************)

procedure do_write_access_profile(
      access_profile	: access_profile_description;
      short_display	: boolean);

var
  index : access_entry_index;

begin
  for index := 0 to access_profile.count - 1 do
    begin
      format.start;
      write_access_entry(index, access_profile.entries[index], short_display,
        FALSE);
      format.write_line(user_terminal)
    end
end (* do_write_access_profile *);



(**********************  command_level_utility  *************************)
(*									*)
(*		      	 write_access_profile				*)
(*									*)
(*	External procedure to output access_profile in ASCII string.	*)
(*									*)
(************************************************************************)

procedure entry WRITE_ACCESS_PROFILE(
      access_profile	: access_profile_description;
      short_display	: boolean);

begin
  do_write_access_profile(access_profile, short_display)
end (* write_access_profile *);



(*************************  command_level_utility  **********************)
(*									*)
(*			    do_format_change_dates			*)
(*									*)
(*	Format password change date and entry change date to ASCII	*)
(*	string.								*)
(*									*)
(************************************************************************)

procedure do_format_change_dates(
      selected_fields	: designated_fields;
      cud_entry		: cud_user_entry);

begin
  if selected_fields[PASSWORDDATE_FIELD] or selected_fields[ALL_FIELDS]
  then
    begin (* PASSWORD DATE is selected *)
      format.skip(1);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	if cud_entry.password_change_date <> 0
	then format.date(calendar.password_date(
	  cud_entry.password_change_date))
	else format.skip(9)
    end (* PASSWORD DATE is selected *);
  if selected_fields[ENTRYDATE_FIELD] or selected_fields[ALL_FIELDS]
  then
    begin (* ENTRY DATE is selected *)
      format.skip(1);
      if (cud_entry.entry_change_date = 0)
(*******...  old password code  ...*******)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*******...  old password code  ...*******)
      then format.skip(9)
      else
        begin (* non-zero date, output it *)
          format.skip(1);
	  format.date(cud_entry.entry_change_date)
        end (* non-zero date, output it *)
    end (* ENTRY DATE is selected *)
end (* do_format_change_dates *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  command_level_utility  **********************)
(*									*)
(*			     format_change_dates			*)
(*									*)
(*	Format password change date and entry change date to ASCII	*)
(*	string.								*)
(*									*)
(************************************************************************)

procedure entry FORMAT_CHANGE_DATES(
      selected_fields	: designated_fields;
      cud_entry		: cud_user_entry);

begin
  do_format_change_dates(selected_fields, cud_entry)
end (* format_change_dates *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  command_level_utilty  ************************)
(*									*)
(*			    do_format_user_data				*)
(*									*)
(*	Format CUD user data to ASCII string. User data formatted is    *)
(*	name, gan, uun, district and control options.			*)
(*									*)
(************************************************************************)

procedure do_format_user_data(
      selected_fields	: designated_fields;
      cud_entry		: cud_user_entry);

var
  field_index : fields;
  option_index : cud_control_options;
  start_of_name : format_buffer_text_size;
  start_of_control : format_buffer_text_size;

begin
  start_of_name := format.buffer.size;
  format.username(cud_entry.name);
  format.skip_to(MAX_USERNAME_OUTPUT + start_of_name);
  for field_index := UUN_FIELD to CONTROL_FIELD do
    if selected_fields[field_index] or selected_fields[ALL_FIELDS]
    then
      begin (* field is selected *)
	format.skip(1);
	case field_index of
	  UUN_FIELD: format.format_number(cud_entry.uun, UUN_RADIX,
	    MAX_UUN_OUTPUT);
	  GAN_FIELD: if INCLUDE_GAN
	    then format.format_number(cud_entry.gan, 8, MAX_GAN_OUTPUT);
	  DISTRICT_FIELD: if INCLUDE_DISTRICT
	    then format.format_number(cud_entry.district, 10,
	      MAX_DISTRICT_OUTPUT);
	  CONTROL_FIELD:
	    begin
	      start_of_control := format.buffer.size;
	      for option_index := FIRST_CUD_CONTROL_OPTION_TO_PRINT to
	        LAST_CUD_CONTROL_OPTION_TO_PRINT do
		if option_index in cud_entry.options
		then
		  begin (* option applies, output it *)
		    format.skip(1);
		    format.short_control_option_name(option_index)
		  end (* option applies, output it *);
		format.skip_to(start_of_control + MAX_CONTROL_OUTPUT)
	      end (* CONTROL_FIELD *)
	end (* case *)
      end (* field is selected *);
end (* do_format_user_data *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  command_level_utilty  ************************)
(*									*)
(*			     format_user_data				*)
(*									*)
(*	Format CUD user data to ASCII string. User data formatted is    *)
(*	name, gan, uun, district and control options.			*)
(*									*)
(************************************************************************)

procedure entry FORMAT_USER_DATA(
      selected_fields	: designated_fields;
      cud_entry		: cud_user_entry);

begin
  do_format_user_data(selected_fields, cud_entry)
end (* format_user_data *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	Miscellaneous Programmer Routines
"



(***********************  command_level_utility  ************************)
(*									*)
(*			     empty_buffer 				*)
(*									*)
(*	Check for buffer empty, and report to validator if it is.	*)
(*									*)
(************************************************************************)

function empty_buffer(
      buffer_desc	: buffer_description;
      empty_message	: quoted_text) : boolean;

begin
  empty_buffer := buffer_desc.empty;
  if buffer_desc.empty
  then
    begin
      format.start_message(empty_message);
      format.string(' buffer empty\');
      format.write_line(user_terminal)
    end
end (* empty_buffer *);



(***********************  command_level_utility  ************************)
(*									*)
(*				buffer_is_empty				*)
(*									*)
(*      Return TRUE if selected buffer is empty.			*)
(*									*)
(************************************************************************)

function entry BUFFER_IS_EMPTY(
      writing_from_cud	: boolean) : boolean;

begin
  if writing_from_cud
  then buffer_is_empty := empty_buffer(cud_info, CUD_FILE_MESSAGE)
  else buffer_is_empty := empty_buffer(mud_info, MUD_FILE_MESSAGE)  
end (* buffer_is_empty *);



(***********************  command_level_utility  ************************)
(*									*)
(*			    restore_buffer 				*)
(*									*)
(************************************************************************)

procedure restore_buffer(
      buffer_is_cud	: boolean;
  var disk_block	: cud_disk_block;
  var success		: boolean);

var
  computed_checksum : integer;

begin
  if buffer_is_cud
  then success := not empty_buffer(cud_info, CUD_FILE_MESSAGE)
  else success := not empty_buffer(mud_info, MUD_FILE_MESSAGE);
  if success
  then
    begin
      if buffer_is_cud
      then dsksys.read_cud_block(FILE_SYSTEM_DISK, CUD_BUFFER_LOCATION,
        disk_block, success)
      else dsksys.read_cud_block(FILE_SYSTEM_DISK, MUD_BUFFER_LOCATION,
        disk_block, success);
      if not success
      then user_terminal.write_quoted_text_line(DISK_READ_ERROR_MESSAGE)
      else
        begin
	  sys_io.cud_checksum(MAXIMUM_CUD_DATA, disk_block.data,
	    computed_checksum);
	  if computed_checksum <> disk_block.checksum
	  then
	    begin
	      success := FALSE;
	      user_terminal.write_quoted_text_line('buffer checksum error\')
	    end
	end
    end
end (* restore_buffer *);



(***********************  command_level_utility  *************************)
(*									*)
(*			    store_buffer 				*)
(*									*)
(************************************************************************)

procedure store_buffer(
      buffer_location	: integer;
      block_number	: cud_block_index;
  var disk_block	: cud_disk_block (* VAR so checksum can be set *);
  var buffer_desc	: buffer_description;
  var success		: boolean);

begin
  sys_io.cud_checksum(MAXIMUM_CUD_DATA, disk_block.data, disk_block.checksum);
  dsksys.write_cud_block(FILE_SYSTEM_DISK, buffer_location, disk_block,
    success);
  if success
  then
    begin
      buffer_desc.empty := FALSE;
      buffer_desc.block := block_number
    end
  else user_terminal.write_line_and_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
end (* store_buffer *);
!
"
		CHANGE CUD Command
"



(***********************  command_level_utility  ************************)
(*									*)
(*			  start_line_with_index				*)
(*									*)
(************************************************************************)

procedure start_line_with_index(
      byte_index	: cud_data_index);

begin
  format.start;
  format.format_number(byte_index, 16, -MAXIMUM_BYTES_IN_WORD);
  format.skip(2)
end (* start_line_with_index *);



(***********************  command_level_utility  ************************)
(*									*)
(*			     add_next_word 				*)
(*									*)
(************************************************************************)

procedure add_next_word(
      index	: cud_data_index;
      data	: cud_data);

var
  number : integer;

begin
  mutil.save_characters_in_word(ZERO, ZERO, data[index],
    data[index + 1], number);
  format.format_number(number, 16, -MAXIMUM_BYTES_IN_WORD);
  format.skip(2);
  mutil.save_characters_in_word(ZERO, ZERO, data[index + 2],
    data[index + 3], number);
  format.format_number(number, 16, -MAXIMUM_BYTES_IN_WORD)
end (* add_next_word *);



(***********************  command_level_utility  ************************)
(*									*)
(*			      change_cud				*)
(*									*)
(************************************************************************)

procedure entry CHANGE_CUD(
  var scanned	: scanned_command);

var
  success : boolean;
  start_offset : cud_data_index;
  disk_block : cud_disk_block;
  done : boolean;
  offset : cud_data_index;
  value : word_in_bytes;

begin
  keyword_util.get_numeric_keyword_value(PRIMARY_CHANGE_OFFSET_KEYWORD, 16, 0,
    CUD_DATA_LIMIT, scanned, start_offset);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      if (start_offset mod 4) <> 0 (* make offset a word boundry *)
      then start_offset := start_offset - (start_offset mod 4);
      restore_buffer(TRUE, disk_block, success);
      if success
      then (* change the CUD buffer *)
	begin
	  user_terminal.write_quoted_text_line(
	    'byte   contents    new value\ ');
	  offset := start_offset;
	  done := FALSE;
	  repeat
	(* display the current value *)
	    start_line_with_index(offset);
	    add_next_word(offset, disk_block.data);
	    format.skip(3);
	    user_terminal.write_format_buffer(format.buffer);
	(* change the value *)
	    freeword_utility.prompt_cud_word(scanned, value);
	    if user_terminal.sendable
	    then
	      begin
		disk_block.data[offset] := value[0];
		disk_block.data[offset + 1] := value[1];
		disk_block.data[offset + 2] := value[2];
		disk_block.data[offset + 3] := value[3];
		if offset < (MAXIMUM_CUD_DATA - MAXIMUM_BYTES_IN_WORD)
		then offset := offset + MAXIMUM_BYTES_IN_WORD
		else done := TRUE
	      end
	    else done := TRUE
	  until done;
	  store_buffer(CUD_BUFFER_LOCATION, cud_info.block, disk_block,
	    cud_info, success)
	end
    end
end (* change_cud *);
!
"
		COMPARE Command
"


(***********************  command_level_utility  ************************)
(*									*)
(*				compare 				*)
(*									*)
(************************************************************************)

procedure entry COMPARE(
  var scanned	: scanned_command);

var
  cud_buffer,
  mud_buffer : cud_disk_block;
  success : boolean;
  done,
  match : boolean;
  index : cud_data_index;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      restore_buffer(TRUE, cud_buffer, success);
      if success
      then restore_buffer(FALSE, mud_buffer, success);
      if success
      then
	begin
	  match := TRUE; done := FALSE;
	  index := 0;
	  repeat (* compare buffer words *)
	    if (cud_buffer.data[index] <> mud_buffer.data[index]) or
	       (cud_buffer.data[index+1] <> mud_buffer.data[index+1]) or
	       (cud_buffer.data[index+2] <> mud_buffer.data[index+2]) or
	       (cud_buffer.data[index+3] <> mud_buffer.data[index+3])
	    then
	      begin
		if match
		then
		  begin
		    user_terminal.write_quoted_text_line(
		      'byte      CUD         MUD\');
		    match := FALSE
		  end (* first mismatch found *);
	(* type out the buffer difference *)
		start_line_with_index(index);
		add_next_word(index, cud_buffer.data);
		format.skip(3);
		add_next_word(index, mud_buffer.data);
		format.write_line(user_terminal)
	      end (* mismatch found *);
	    if index < (MAXIMUM_CUD_DATA - MAXIMUM_BYTES_IN_WORD)
	    then index := index + MAXIMUM_BYTES_IN_WORD
	    else done := TRUE
	  until not user_terminal.sendable or done;
	  if match
	  then user_terminal.write_quoted_text_line('no differences\ ')
	end (* success *)
    end (* scanned.status = CMD_OK *)
end (* compare *);
!
"
		DISPLAY SELECT Command
"

(************************  command_level_utility  ***********************)
(*									*)
(*			  do_display_select				*)
(*									*)
(*	Displays current criteria to calling process.			*)
(*									*)
(************************************************************************)

procedure do_display_select;

var
  criteria_index 	: criteria_type;
  option_index		: criteria_control_options;
  first_option  	: boolean;

begin
  if criteria.used[all_criteria]
  then user_terminal.write_quoted_text_line('All users are selected\ ')
  else
    begin
      user_terminal.write_quoted_text_line(
        'User selection is based on the following: \ ');
      for criteria_index := ACCESS_CRITERION to PASSWORDDATE_CRITERION do
	if criteria.used[criteria_index]
	then
	  begin
	    format.start;
	    format.criteria_name(criteria_index);
	    format.skip_to(14);
	    case criteria_index of
	      ACCESS_CRITERION,
	      GAN_CRITERION,
	      DISTRICT_CRITERION,
	      UUN_CRITERION:
	        begin
		  if criteria_index = ACCESS_CRITERION
		  then
		    case criteria.access_type of
		      HOST_ACCESS:
		        begin
			  format.string(HOST_MESSAGE);
			  format.character(ASCII_SPACE)
			end (* HOST_ACCESS *);
		      NODE_ACCESS:
		        begin
			  format.string(NODE_MESSAGE);
			  format.character(ASCII_SPACE)
			end (* NODE_ACCESS *);
		      CLASS_ACCESS: format.string(CLASS_MESSAGE);
		      GROUP_ACCESS: format.string(GROUP_MESSAGE)
		    end (* case *);
		  format.number_range(
		    criteria.range_criteria[criteria_index].first,
		    criteria.range_criteria[criteria_index].last,
		    criteria_value_radix(criteria_index, criteria.access_type))
		end (* ACCESS, GAN, DISTRICT, UUN *);
	      CONTROL_CRITERION:
	        begin
		  first_option := TRUE;
		  for option_index := FIRST_CRITERIA_CONTROL_OPTION to
		    LAST_CRITERIA_CONTROL_OPTION do
		  if criteria.control[option_index]
		  then
		    begin
		      if first_option
		      then first_option := FALSE
		      else
		        begin
			  format.write_line(user_terminal);
			  format.start;
			  format.skip_to(14)
			end (* not first_option *);
		      format.control_option_name(option_index)
		    end (* criteria.control[option_index] *)
		end (* CONTROL_CRITERION *);
	      ENTRYDATE_CRITERION,
	      PASSWORDDATE_CRITERION:
	        with criteria.date_criteria[criteria_index] do
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		    begin
		      if qualifier = BEFORE_DATE
		      then format.string('before \')
		      else
		        if qualifier = AFTER_DATE
			then format.string('after \ ');
		      if criteria_index = PASSWORDDATE_CRITERION
		      then format.date(calendar.password_date(time))
		      else format.date(time)
		    end (* not GFD_ONLY_DATE *)
	      end (* case *);
	    format.write_line(user_terminal)
	  end (* criteria.used *)
    end (* not selecting all users *)
end (* do_display_select *);



(***********************  command_level_utility  ************************)
(*									*)
(*			     display_select				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_SELECT;

begin
  do_display_select  
end (* display_select *);
!
"
		DISPLAY DIRECTORY Command
"



(************************  command_level_utility  ***********************)
(*									*)
(*				control_check				*)
(*									*)
(*	if options do not match the control_criterion,			*)
(*	select_user is set to FALSE					*)
(*									*)
(************************************************************************)

procedure control_check(
      options		: user_options;
  var select_user	: boolean);

var
  option_index	: cud_control_options;
  licensed_user	: boolean;
  done		: boolean;

begin
  done := FALSE;
  option_index := FIRST_CUD_CONTROL_OPTION_TO_PRINT;
  repeat
    if criteria.control[option_index]
    then
      if not (option_index in options)
      then select_user := FALSE;
    if option_index = LAST_CUD_CONTROL_OPTION_TO_PRINT
    then done := TRUE
    else option_index := succ(option_index)
  until done or not (select_user);
  if select_user
  then
    begin
      licensed_user := (ACCOUNT_SUPERVISOR in options) or
       (NETWORK_ADMINISTRATOR in options);
      if criteria.control[LICENSED] = TRUE
      then select_user := licensed_user
      else
	if criteria.control[PASSWORD_ONLY]
	then select_user := not licensed_user
    end (* select_user *)
end (* control_check *);



(************************  command_level_utility  ***********************)
(*									*)
(*				date_check				*)
(*									*)
(*	if a match does not occur between the cud_value and the 	*)
(*	  criteria date value, select_user returns FALSE		*)
(*									*)
(************************************************************************)

procedure date_check(
      date_index	: date_criteria_index;
      cud_entry		: cud_user_entry;
  var select_user	: boolean);

var
  cud_value	: integer;

begin
  if date_index = PASSWORDDATE_CRITERION
  then cud_value := cud_entry.password_change_date
(*******...  old password code  ...*******)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*******...  old password code  ...*******)
  else cud_value := cud_entry.entry_change_date;

  with criteria.date_criteria[date_index] do
    case qualifier of
      AFTER_DATE:
	if cud_value <= time
	then select_user := FALSE;
      BEFORE_DATE:
	if cud_value >= time
	then select_user := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      NO_DATE_QUALIFIER:
	if cud_value <> time
	then select_user := FALSE
    end (* case *)
end (* date_check *);



(************************  command_level_utility  ***********************)
(*									*)
(*				range_check				*)
(*									*)
(*	If a match occurs between the cud_value and the criteria	*)
(*	match returns TRUE						*)
(*									*)
(************************************************************************)

procedure range_check(
      range_index	: range_criteria_index;
      cud_value		: integer;
  var match		: boolean);

begin
  if criteria.range_criteria[range_index].first =
    criteria.range_criteria[range_index].last
  then (* test cud value against a single number *)
    match := criteria.range_criteria[range_index].first = cud_value
  else (* test cud value against a range *)
    match := (criteria.range_criteria[range_index].first <= cud_value) and
       (criteria.range_criteria[range_index].last  >= cud_value)
end (* range_check *);



(************************  command_level_utility  ***********************)
(*									*)
(*			     destination_check				*)
(*									*)
(*	searchs user's destination list for criteria value		*)
(*									*)
(************************************************************************)

procedure destination_check(
      destination_to_check	: destination_description;
  var access_match		: boolean);

var
  end_of_list 	: boolean;
  index		: destination_index;

begin
  end_of_list := FALSE;
  index := 0;
  repeat (* cycle thru list within entry *)
    with destination_to_check, list[index] do
      begin
	if (group_flag and (criteria.access_type = GROUP_ACCESS)) or
	   (not group_flag and (criteria.access_type = HOST_ACCESS))
	then range_check(ACCESS_CRITERION, value, access_match);
	if index = size - 1
	then end_of_list := TRUE
	else index := index + 1
      end (* with *)
  until access_match or end_of_list
end (* destination_check *);



(************************  command_level_utility  ***********************)
(*									*)
(*				access_search				*)
(*									*)
(*	select_user returns TRUE if access_profile contains an		*)
(*	occurrence of the value specified by access profile criterion 	*)
(*									*)
(************************************************************************)

procedure access_search(
      user_access	: access_profile_description;
  var select_user	: boolean);

var
  profile_index		: access_entry_index;
  access_match		: boolean;
  end_of_profile	: boolean;
  origin_list_index	: in_place_origin_index;
  end_of_list		: boolean;
  host_value_criterion	: boolean;

begin
  profile_index := 0; end_of_profile := FALSE;
  access_match := FALSE;
  host_value_criterion := criteria.access_type = HOST_ACCESS;
  repeat (* search profile entries *)
    case criteria.access_type of
      CLASS_ACCESS:
	with user_access.entries[profile_index] do
	  if not in_place_origin
 	  then range_check(ACCESS_CRITERION, class_no, access_match);

		    (* cycle thru destination list within entry *)
      GROUP_ACCESS: destination_check(
	user_access.entries[profile_index].destination, access_match);

      NODE_ACCESS,
      HOST_ACCESS:
        begin
	  origin_list_index := 0; end_of_list := FALSE;
	  if user_access.entries[profile_index].in_place_origin
	  then
	    repeat (* search thru origin list within entry *)
	      with user_access.entries[profile_index].origin,
	        list[origin_list_index] do
	        begin
		  if (host_flag and host_value_criterion) or
		    (not host_flag and not host_value_criterion)
		  then range_check(ACCESS_CRITERION, value, access_match);
		  if origin_list_index = size - 1
		  then end_of_list := TRUE
		  else origin_list_index := origin_list_index + 1
		end (* with *)
	    until access_match or end_of_list;

	  if host_value_criterion and not access_match (* host_access only *)
	  then destination_check( (* search thru dest list within entry *)
	    user_access.entries[profile_index].destination, access_match)
        end (* node, host_access *)
    end (* case *);
    if profile_index = user_access.count - 1
    then end_of_profile := TRUE
    else profile_index := profile_index + 1
  until access_match or end_of_profile;
  select_user := access_match
end (* access_search *);



(************************  command_level_utility  ***********************)
(*									*)
(*			  user_passes_criteria 				*)
(*									*)
(*	Returns TRUE if user passes all used criteria			*)
(*									*)
(************************************************************************)

function user_passes_criteria(
	cud_entry	: cud_user_entry): boolean;

var
  select_user,
  end_of_criteria	: boolean;
  cud_value		: integer;
  criteria_index	: criteria_type;

begin
  select_user := TRUE;
  end_of_criteria :=  FALSE;
  criteria_index := ACCESS_CRITERION;
  if not criteria.used[ALL_CRITERIA]
  then
    repeat
      if criteria.used[criteria_index]
      then
	begin
	  if (criteria_index <= UUN_CRITERION) and
	     (criteria_index >= GAN_CRITERION)
	  then
	    begin
	      case criteria_index of
		GAN_CRITERION: cud_value := cud_entry.gan;
		UUN_CRITERION: cud_value := cud_entry.uun;
		DISTRICT_CRITERION: cud_value := cud_entry.district
	      end (* case *);
	      range_check(criteria_index,cud_value,select_user)
	    end (* (criteria_index <= UUN) and (criteria_index >= GAN) *)
	  else
	    case criteria_index of
	      ACCESS_CRITERION: access_search(cud_entry.access_profile,
	        select_user);
	      CONTROL_CRITERION: control_check(cud_entry.options,select_user);
	      PASSWORDDATE_CRITERION,
	      ENTRYDATE_CRITERION: date_check(criteria_index,cud_entry,
	        select_user)
	    end (* case *)
	end (* (criteria_index <= UUN) and (criteria_index >= GAN) *);
      if criteria_index = PASSWORDDATE_CRITERION
      then end_of_criteria := TRUE
      else criteria_index := succ(criteria_index)
    until not select_user or end_of_criteria;
  user_passes_criteria := select_user
end (* user_passes_criteria *);



(************************  command_level_utility  ***********************)
(*									*)
(*				display_fields				*)
(*									*)
(*	Writes out selected cud entry fields				*)
(*									*)
(************************************************************************)

procedure display_fields(
      selected_fields	: designated_fields;
      cud_entry		: cud_user_entry);

begin
  do_format_user_data(selected_fields, cud_entry);
  if selected_fields[ALL_FIELDS]
  then
    begin
      format.write_line(user_terminal);
      format.start
    end (* selected_fields[ALL_FIELDS] *);
  do_format_change_dates(selected_fields, cud_entry);
  format.write_line(user_terminal);
  if selected_fields[ACCESS_FIELD] or selected_fields[ALL_FIELDS]
  then do_write_access_profile(cud_entry.access_profile, TRUE)
end (* display_fields *);



(*********************  command_level_utility  **************************)
(*									*)
(*			     write_cud_header				*)
(*									*)
(*	Write the CUD header for all fields or specified fields		*)
(*									*)
(************************************************************************)

procedure write_cud_header(
      selected_fields	: designated_fields);

var
  field_index : fields;

begin
  format.start_message('USERNAME            \ ');
  for field_index := UUN_FIELD to ACCESS_FIELD do
    if selected_fields[field_index] or selected_fields[ALL_FIELDS]
    then
      case field_index of
	UUN_FIELD: format.string('        UUN \ ');
	GAN_FIELD: if INCLUDE_GAN
		   then format.string('        GAN \ ');
	DISTRICT_FIELD: if INCLUDE_DISTRICT
			then format.string(' DIST\');
	CONTROL_FIELD: format.string('  CONTROL          \');
	PASSWORDDATE_FIELD:
	  begin
	    if selected_fields[ALL_FIELDS]
	    then format.write_line(user_terminal)
	    else format.character(ASCII_SPACE);
	    format.start_message('PASSWORD\ ')
	  end (* PASSWORDDATE_FIELD *);
	ENTRYDATE_FIELD: format.string('  ENTRY  \');
	ACCESS_FIELD: format.string('(:13:)(:10:)   ACCESS\')
      end (* case *);
  format.write_line(user_terminal);
  user_terminal.write_newline
end (* write_cud_header *);



(************************  command_level_utility  ***********************)
(*									*)
(*			      get_next_page				*)
(*									*)
(*									*)
(************************************************************************)

procedure get_next_page(
  var page_count	: integer);

begin
  page_count := page_count + 1;
  format.character(ASCII_FORM_FEED);
  format.newline;
  format.skip_to(70);
  format.string('Page \');
  format.number(page_count,10);
  format.write_line(user_terminal)
end (* get_next_page *);



(************************  command_level_utility  ***********************)
(*									*)
(*				next_page				*)
(*									*)
(*	formats formfeed and page number				*)
(*									*)
(************************************************************************)

procedure next_page(
      selected_fields	: designated_fields;
  var page_count 	: integer);

begin
  get_next_page(page_count);
  write_cud_header(selected_fields);
  format.start
end (* next_page *);



(************************  command_level_utility  ***********************)
(*									*)
(*			display_directory				*)
(*									*)
(*	 Selects cud_entries by criteria and displays specified fields	*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_DIRECTORY(
  var scanned	: scanned_command);

var
  buffer		: cud_disk_block;
  block			: cud_block_index;
  cud_entry		: cud_user_entry;
  criteria_index	: criteria_type;
  selected_fields	: designated_fields;
  users_selected	: integer;

(* used for pagination feature *)
  lines_per_page	: integer;
  line_count		: integer;
  page_count		: integer;
  next_users_lines	: integer;
  count			: integer;
  field_index		: fields;
  field_keyword		: command_keyword_index;

begin
  page_count := 1; users_selected := 0; line_count := 0;
(* get designated fields *)
  do_clear_designated_fields(selected_fields);
  count := 0;
  if not argument_scan.check_keyword(PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD,
    scanned)
  then lines_per_page := NO_PAGINATION
  else keyword_util.get_numeric_keyword_value(
    PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD, 10, 25, MAX_INTEGER, scanned,
    lines_per_page);
  if scanned.status = CMD_OK
  then
    begin
      if ((lines_per_page <> NO_PAGINATION) and
	 (scanned.keyword_count = 2)) or (scanned.keyword_count = 1)
      then selected_fields[ALL_FIELDS] := TRUE
      else
	begin
	  selected_fields[ACCESS_FIELD] := argument_scan.check_keyword(
	      PRIMARY_DISPLAY_DIRECTORY_ACCESS_KEYWORD, scanned);

	  for field_keyword := PRIMARY_DISPLAY_DIRECTORY_UUN_KEYWORD
			to PRIMARY_DISPLAY_DIRECTORY_ENTRYDATE_KEYWORD do
  	    if argument_scan.check_keyword(field_keyword, scanned)
	    then
	      begin
		case field_keyword of
		  PRIMARY_DISPLAY_DIRECTORY_UUN_KEYWORD:
		    field_index := UUN_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_GAN_KEYWORD:
		    field_index := GAN_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_DISTRICT_KEYWORD:
		    field_index := DISTRICT_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_CONTROL_KEYWORD:
		    field_index := CONTROL_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_PASSWORDDATE_KEYWORD:
		    field_index := PASSWORDDATE_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_ENTRYDATE_KEYWORD:
		    field_index := ENTRYDATE_FIELD
		end (* case *);
		selected_fields[field_index] := TRUE;
		count := count + 1
	      end (* check_keyword *);
	    if not INCLUDE_GAN and (selected_fields[GAN_FIELD])
	    then
	      begin
		scanned.status := ARG_ERROR;
		user_terminal.write_quoted_text_line(NO_GANS_MESSAGE)
	      end (* not INCLUDE_GAN and (selected_fields[GAN_FIELD]) *);
	    if not INCLUDE_DISTRICT and (selected_fields[DISTRICT_FIELD])
	    then
	      begin
		scanned.status := ARG_ERROR;
		user_terminal.write_quoted_text_line(NO_DISTRICTS_MESSAGE)
	      end;
	    if count > 4 (* max fields not including access *)
	    then scanned.status := TOO_MANY_ARGS
	end (* else *);
      argument_scan.extra_argument_check(scanned)
    end;

  if scanned.status = CMD_OK
  then
    begin
      cud_updater.start_cud_list(0, buffer);
      cud_utility.print_cud_entry_error;

      do_display_select (* write out criteria information *);
      user_terminal.write_newline;
      if lines_per_page <> NO_PAGINATION
      then
	begin
	  (* display_select outputs at least one line and  *)
	  (* both types of header add four *)
	  line_count := 5;
	  for criteria_index := ACCESS_CRITERION to PASSWORDDATE_CRITERION do
	    if criteria.used[criteria_index]
	    then line_count := line_count + 1
	end (* lines_per_page <> NO_PAGINATION *);
      write_cud_header(selected_fields);

      repeat
	user_terminal.check_circuit;
	cud_updater.next_cud_list(buffer, block, cud_entry);
	if (cud_updater.last_status = CUD_ENTRY_OK) or
	  (cud_updater.last_status = CUD_ENTRY_IN_WRONG_BLOCK)
	then
	  begin
	    if user_passes_criteria(cud_entry)
	    then
	      begin
		format.start;
	        if cud_updater.last_status = CUD_ENTRY_IN_WRONG_BLOCK
		then
		  begin
		    format.cud_entry_status(cud_updater.last_status);
		    format.newline
		  end;
		users_selected := users_selected + 1;
		if lines_per_page <> NO_PAGINATION
		then
		  begin
		    if selected_fields[ALL_FIELDS]
		    then next_users_lines := cud_entry.access_profile.count + 2
		    else
		      if selected_fields[ACCESS_FIELD]
		      then next_users_lines :=cud_entry.access_profile.count+1
		      else next_users_lines := 1;
		    if next_users_lines + line_count <= lines_per_page
		    then line_count := line_count + next_users_lines
		    else
		      begin (* go to next page *)
			line_count := next_users_lines + 7;
			next_page(selected_fields, page_count)
		      end (* go to next page *)
		  end (* if <> NO_PAGINATION *);
		display_fields(selected_fields, cud_entry)
	      end (* if user_passes_criteria *)
	    end (* cud_updater.last_status = CUD_ENTRY_OK *)
	  else
	    if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
	    then
	      begin
	        format.start_message('block \ ');
	        format.number(block, 10);
		format.colon_space;
		format.cud_entry_status(cud_updater.last_status);
		format.write_line(user_terminal)
	      end (* cud_updater.last_status <> CUD_ENTRY_NOT_FOUND *)
      until (cud_updater.last_status = CUD_ENTRY_NOT_FOUND) or
        not user_terminal.sendable;
      if lines_per_page <> NO_PAGINATION
      then
        if line_count + 1 > lines_per_page
	then get_next_page(page_count);
      format.start_line_message('Number of users selected: \ ');
      format.number(users_selected, 10);
      format.write_line(user_terminal)
    end (* if CMD_OK *)
end (* display_directory *);
!
"
		DISPLAY CUD and MUD Commands
"


(***********************  command_level_utility  ************************)
(*									*)
(*			     display_block 				*)
(*									*)
(*	Display contents of the CUD or MUD buffer.			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_BLOCK(
      cud_flag	: boolean (* TRUE if displaying CUD buffer *);
  var scanned	: scanned_command);

var
  cud_status : cud_entry_result;
  output_all,	(* TRUE if ALL keyword was entered *)
  format_output : boolean;
  disk_block : cud_disk_block;
  success : boolean;
  start_line_ptr : cud_data_index;
  record_size : cud_data_size;
  next_record_ptr : cud_data_index;
  done : boolean;
  start_word,
  end_word,
  word_index : cud_data_index;
  cud_entry : cud_user_entry;
  selected_fields : designated_fields;
  block : cud_block_index;

begin
  format_output := argument_scan.check_keyword(
    PRIMARY_DISPLAY_CUD_FORMATTED_KEYWORD, scanned);
  if not format_output
  then output_all :=
    argument_scan.check_keyword(PRIMARY_DISPLAY_CUD_ALL_KEYWORD, scanned);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      restore_buffer(cud_flag, disk_block, success);
      if success
      then
        if format_output
	then
	  begin (* display buffer formatted *)
	    if cud_flag
	    then block := cud_info.block
	    else block := mud_info.block;
	    do_clear_designated_fields(selected_fields);
	    selected_fields[ALL_FIELDS] := TRUE;
	    write_cud_header(selected_fields);
	    next_record_ptr := 0;
	    repeat
	      cud_updater.unpack_next_entry(disk_block.data, block,
	        next_record_ptr, cud_entry);
	      if cud_updater.last_status = CUD_ENTRY_OK
	      then
	        begin
		  format.start;
		  display_fields(selected_fields, cud_entry);
		  next_record_ptr := next_record_ptr +
		    ord(disk_block.data[next_record_ptr]);
	        end (* status = CUD_ENTRY_OK *)
	      else
	        if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
	        then cud_utility.print_cud_entry_message
	   until not user_terminal.sendable or
	     (cud_updater.last_status <> CUD_ENTRY_OK)
	  end (* display buffer formatted *)
	else
	  begin (* display buffer unformatted *)
	    user_terminal.write_quoted_text_line('byte\ ');
	    start_line_ptr := 0; next_record_ptr := 0; done := FALSE;
	    repeat
	      if output_all
	      then record_size := CUD_DATA_LIMIT
	      else record_size := ord(disk_block.data[next_record_ptr]);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	        begin
		  if record_size = 0
		  then done := TRUE
		  else
		    begin (* record_size > 0 *)
		      next_record_ptr := next_record_ptr + record_size;
		      if next_record_ptr > CUD_DATA_LIMIT
		      then
		        begin
		          done := TRUE;
			  user_terminal.write_line_and_quoted_text_line(
			    format_error);
			  next_record_ptr := CUD_DATA_LIMIT (* output anyway *)
			end (* next_record_ptr > CUD_DATA_LIMIT *);
		      repeat
		        start_line_with_index(start_line_ptr);
			start_word := start_line_ptr div MAXIMUM_BYTES_IN_WORD;
			end_word := start_word + CUD_WORDS_IN_LINE_LIMIT;
			if end_word >= CUD_DATA_WORD_MAXIMUM
			then end_word := end_word - 1;
			for word_index := start_word to end_word do
			  begin
			    add_next_word(word_index * MAXIMUM_BYTES_IN_WORD,
			    disk_block.data);
			    format.skip(2)
			  end (* for *);
			format.write_line(user_terminal) (* write out line *);
			if (start_line_ptr + MAXIMUM_CUD_BYTES_IN_LINE) >=
			  CUD_DATA_LIMIT
			then done := TRUE
			else start_line_ptr := start_line_ptr
			  + MAXIMUM_CUD_BYTES_IN_LINE
		      until done or not user_terminal.sendable or
		        (start_line_ptr >= next_record_ptr);
		      if output_all
		      then done := TRUE
	            end (* record_size > 0 *)
		end
	    until done or not user_terminal.sendable
	  end (* display buffer unformatted *)
    end (* scanned.status = CMD_OK *)
end (* display_block *);
"
		READ Command
"


(***********************  command_level_utility  *************************)
(*									*)
(*			    write_un2_error				*)
(*									*)
(************************************************************************)

procedure write_un2_error(
      real_sup  : real_supervisor_index;
      status	: un2_status;
      block	: cud_block_index);

begin (* write_un2_error *)
  format.start_and_newline;
  with aux_io do
    format.un2_sup_error(status, param.status, param.arg2, block);
  format.write_line(user_terminal)
end (* write_un2_error *);



(***********************  command_level_utility  *************************)
(*									*)
(*			       read_cud 				*)
(*									*)
(************************************************************************)

procedure entry READ_CUD(
      lock_block	: boolean (* TRUE if programmer is locking block *);
      block_number	: cud_block_index;
  var block_is_locked	: boolean;
  var shut_block	: cud_block_index);

var
  status : cud_access_status;
  result : cud_operation_result;
  disk_block : cud_disk_block;
  success : boolean;

begin
  status := CUD_ACCESS_OK;
  if lock_block
  then
    if block_is_locked
    then
      begin (* report that the block is locked *)
        status := CUD_ACCESS_BLOCK_SHUT;
	format.start_message('You already have block \');
	format.number(shut_block, 10);
	format.string(' locked\');
	format.write_line(user_terminal)
      end (* report that the block is locked *)
    else
      begin (* block_is_locked is FALSE *)
        cud_access.lock_cud_block(validator, block_number, TRUE, status);
	if status = CUD_ACCESS_OK
	then
	  begin
	    shut_block := block_number;
	    block_is_locked := TRUE
	  end (* status = CUD_ACCESS_OK *)
        else
          begin (* status <> CUD_ACCESS_OK *)
            format.start;
	    format.cud_access_error(status);
	    format.write_line(user_terminal)
	  end (* status <> CUD_ACCESS_OK *)
	end (* block_is_locked is FALSE *);

  if status = CUD_ACCESS_OK
  then
    begin
      block_updater.read_cud_block(block_number, result, disk_block);
      if result <> CUD_OPERATION_OK
      then
        begin
	  format.cud_block_error(block_number, result);
	  format.write_line(user_terminal)
	end (* result <> CUD_OPERATION_OK *);
      if (result = CUD_OPERATION_OK) or (result = CUD_CHECKSUM_ERROR)
      then
        begin
	  store_buffer(CUD_BUFFER_LOCATION, block_number, disk_block,
	    cud_info, success);
	  if success
	  then user_terminal.write_quoted_text_line(block_read)
	end (* result = CUD_OPERATION_OK or CUD_CHECKSUM_ERROR *)
    end (* status = CUD_ACCESS_OK *)
end (* read_cud *);



(***********************  command_level_utility  ************************)
(*									*)
(*			       read_mud					*)
(*									*)
(************************************************************************)

procedure entry READ_MUD(
      real_sup  : real_supervisor_index;
      block	: cud_block_index);

var
  status     : un2_status;
  disk_block : cud_disk_block;
  write_ok   : boolean;

begin
  un2_util.read_mud_block(real_sup, block, status, disk_block);
  if status <> UN2_SUCCESSFUL
  then write_un2_error(real_sup, status, block)
  else
    begin (* status = UN2_SUCCESSFUL *)
      store_buffer(MUD_BUFFER_LOCATION, block, disk_block, mud_info, write_ok);
      if write_ok
      then user_terminal.write_quoted_text_line(block_read)
    end (* status = UN2_SUCCESSFUL *)
end (* read_mud *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(******...  old password code  ...*******)
!
"
	SELECT Command
"



(************************  command_level_utility  ***********************)
(*									*)
(*			    get_date_selection				*)
(*									*)
(************************************************************************)

procedure get_date_selection(
  var temp_criteria	: user_criteria_selections;
  var criteria_index	: criteria_type;
  var scanned		: scanned_command);

var
  today_in_GMT_days	: integer;
  time_in_days		: integer;

begin
  with temp_criteria.date_criteria[criteria_index] do
    begin
      if qualifier = NO_DATE_QUALIFIER
      then
        begin (* get date with correct syntax and no earlier than 1/1/74 *)
	  if argument_scan.check_keyword(PRIMARY_SELECT_BEFORE_DATE_KEYWORD,
	    scanned)
	  then qualifier := BEFORE_DATE
	  else
	    if argument_scan.check_keyword(PRIMARY_SELECT_AFTER_DATE_KEYWORD,
	      scanned)
	    then qualifier := AFTER_DATE;
	  argument_scan.freeword_date(0, scanned, time);
	  today_in_GMT_days := REALTIME div SECONDS_PER_DAY;
	  time_in_days := time div SECONDS_PER_DAY;
	  if time_in_days > today_in_GMT_days
	  then scanned.status := ARG_NUMBER_OUT_OF_BOUNDS
	end (* get date with correct syntax and no earlier than 1/1/74 *);
      if scanned.status = CMD_OK
      then
        begin
	  if (qualifier = BEFORE_DATE) and (time = 0)
	  then scanned.status := ARG_ERROR
	  else
	    if (qualifier = AFTER_DATE) and (time_in_days = today_in_GMT_days)
	    then scanned.status := ARG_ERROR;
	  if criteria_index = PASSWORDDATE_CRITERION
	  then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    time := time_in_days
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      end (* if CMD_OK *)
    end (* with *)
end (* get_date_selection *);



(************************  command_level_utility  ***********************)
(*									*)
(*				select					*)
(*									*)
(*	Sets or clears specified criterion or clears all criteria	*)
(*									*)
(************************************************************************)

procedure entry SELECT(
  var scanned	: scanned_command);

var
  temp_criteria		: user_criteria_selections;
  all			: boolean;
  criteria_keyword	: command_keyword_index;
  criteria_index	: criteria_type;
  option_index		: criteria_control_options;
  select_keyword	: command_keyword_index;

begin
  temp_criteria := criteria;
  all := argument_scan.check_keyword(PRIMARY_SELECT_ALL_KEYWORD, scanned);
  argument_scan.find_keyword(PRIMARY_SELECT_ACCESS_KEYWORD,
    PRIMARY_SELECT_PASSWORDDATE_KEYWORD, scanned, criteria_keyword);

  if all and (scanned.status = ARG_MISSING)
  then
    begin (* "ALL" is the only keyword entered - clear all criteria *)
      criteria_index := ALL_CRITERIA;
      scanned.status := CMD_OK
    end (* "ALL" is the only keyword entered - clear all criteria *)
  else
    if scanned.status = CMD_OK
    then
      begin
        case criteria_keyword of
	  PRIMARY_SELECT_ALL_KEYWORD: criteria_index := ALL_CRITERIA;
	  PRIMARY_SELECT_ACCESS_KEYWORD: criteria_index := ACCESS_CRITERION;
	  PRIMARY_SELECT_GAN_KEYWORD: criteria_index := GAN_CRITERION;
	  PRIMARY_SELECT_DISTRICT_KEYWORD: criteria_index :=DISTRICT_CRITERION;
	  PRIMARY_SELECT_UUN_KEYWORD: criteria_index := UUN_CRITERION;
	  PRIMARY_SELECT_CONTROL_KEYWORD: criteria_index := CONTROL_CRITERION;
	  PRIMARY_SELECT_ENTRYDATE_KEYWORD:
	    criteria_index:=ENTRYDATE_CRITERION;
	  PRIMARY_SELECT_PASSWORDDATE_KEYWORD:
	    criteria_index := PASSWORDDATE_CRITERION 
	end (* case criteria_keyword *);
	if not all
	then
	  begin (* set specific criteria *)
	    temp_criteria.used[ALL_CRITERIA] := FALSE;
	    temp_criteria.used[criteria_index] := TRUE;
	    case criteria_index of
	      ALL_CRITERIA: (* null *);
	      ACCESS_CRITERION:
	        begin
		  argument_scan.find_keyword(
		    PRIMARY_SELECT_CLASS_ACCESS_KEYWORD,
		    PRIMARY_SELECT_NODE_ACCESS_KEYWORD, scanned,
		    select_keyword);
		  if scanned.status = CMD_OK
		  then
		    case select_keyword of
		      PRIMARY_SELECT_CLASS_ACCESS_KEYWORD:
		        begin
			  temp_criteria.access_type := CLASS_ACCESS;
			  argument_scan.freeword_range(0, 0, MAXIMUM_CLASS,
			    criteria_value_radix(criteria_index,
			    temp_criteria.access_type), scanned,
			    temp_criteria.range_criteria[criteria_index])
			end (* PRIMARY_SELECT_CLASS_ACCESS_KEYWORD *);
		      PRIMARY_SELECT_GROUP_ACCESS_KEYWORD:
		        begin
			  temp_criteria.access_type := GROUP_ACCESS;
			  argument_scan.freeword_range(0, 0, MAXIMUM_GROUP,
			    criteria_value_radix(criteria_index,
			    temp_criteria.access_type), scanned,
			    temp_criteria.range_criteria[criteria_index])
			end (* PRIMARY_SELECT_GROUP_ACCESS_KEYWORD *);
		      PRIMARY_SELECT_HOST_ACCESS_KEYWORD:
		        begin
			  temp_criteria.access_type := HOST_ACCESS;
			  argument_scan.freeword_range(0, MINIMUM_HOST,
			    MAXIMUM_HOST, criteria_value_radix(criteria_index,
			    temp_criteria.access_type), scanned,
			    temp_criteria.range_criteria[criteria_index])
			end (* PRIMARY_SELECT_HOST_ACCESS_KEYWORD *);
		      PRIMARY_SELECT_NODE_ACCESS_KEYWORD:
		        begin
			  temp_criteria.access_type := NODE_ACCESS;
			  argument_scan.freeword_range(0, MINIMUM_NODE,
			    MAXIMUM_NODE, criteria_value_radix(criteria_index,
			    temp_criteria.access_type), scanned,
			    temp_criteria.range_criteria[criteria_index])
			end (* PRIMARY_SELECT_NODE_ACCESS_KEYWORD *)
		    end (* case select_keyword *)
	        end (* ACCESS_CRITERION *);
	      GAN_CRITERION:
	        if INCLUDE_GAN
		then argument_scan.freeword_range(0, MINIMUM_GAN, MAXIMUM_GAN,
		  criteria_value_radix(criteria_index,
		  temp_criteria.access_type), scanned,
		  temp_criteria.range_criteria[criteria_index])
		else
	          begin (* not INCLUDE_GAN *)
		    scanned.status := ARG_ERROR;
		    user_terminal.write_quoted_text_line(NO_GANS_MESSAGE)
		  end (* not INCLUDE_GAN *);
	      DISTRICT_CRITERION:
	        if INCLUDE_DISTRICT
		then argument_scan.freeword_range(0, MINIMUM_DISTRICT,
		  MAXIMUM_DISTRICT,
		  criteria_value_radix(criteria_index,
		  temp_criteria.access_type), scanned,
		  temp_criteria.range_criteria[criteria_index])
		else
	          begin (* not INCLUDE_DISTRICT *)
		    scanned.status := ARG_ERROR;
		    user_terminal.write_quoted_text_line(NO_DISTRICTS_MESSAGE)
		  end (* not INCLUDE_DISTRICT *);
	      UUN_CRITERION: argument_scan.freeword_range(0, MINIMUM_UUN,
	        MAXIMUM_UUN, criteria_value_radix(criteria_index,
		temp_criteria.access_type), scanned,
		temp_criteria.range_criteria[criteria_index]);
	      CONTROL_CRITERION:
	        if scanned.keyword_count = 1
		then scanned.status := ARG_MISSING
		else
		  begin (* scanned.keyword_count <> 1 *)
		    for option_index := FIRST_CRITERIA_CONTROL_OPTION to
		      LAST_CRITERIA_CONTROL_OPTION do
		      begin
		        case option_index of
			  LICENSED: select_keyword :=
			    PRIMARY_SELECT_CONTROL_LICENSED_KEYWORD;
			  PASSWORD_ONLY: select_keyword :=
			    PRIMARY_SELECT_CONTROL_PASSWORD_ONLY_KEYWORD;
			  ACCOUNT_SUPERVISOR: select_keyword :=
			    PRIMARY_SELECT_CONTROL_ACCOUNT_SUPERVISOR_KEYWORD;
			  IGNORE_HOST: select_keyword :=
			    PRIMARY_SELECT_CONTROL_IGNORE_HOST_KEYWORD;
			  NETWORK_ADMINISTRATOR: select_keyword :=
			  PRIMARY_SELECT_CONTROL_NETWORK_ADMINISTRATOR_KEYWORD;
			  NO_PASSWORD: select_keyword :=
			    PRIMARY_SELECT_CONTROL_NO_PASSWORD_KEYWORD;
			  SHUT_OVERRIDE: select_keyword :=
			    PRIMARY_SELECT_CONTROL_SHUT_OVERRIDE_KEYWORD;
			  AUDITOR: select_keyword :=
			    PRIMARY_SELECT_CONTROL_AUDITOR_KEYWORD;
			  OPERATOR: select_keyword :=
			    PRIMARY_SELECT_CONTROL_OPERATOR_KEYWORD;
			  TRANSPARENT_LOGIN: select_keyword :=
			    PRIMARY_SELECT_CONTROL_TRANSPARENT_LOGIN_KEYWORD
		        end (* case option_index *);
			temp_criteria.control[option_index] :=
		          argument_scan.check_keyword(select_keyword, scanned)
		      end (* for *);
(* check for mutually exclusive criteria control options *)
		    if (temp_criteria.control[LICENSED] and
		       temp_criteria.control[PASSWORD_ONLY]) or
		      (temp_criteria.control[PASSWORD_ONLY] and
		       temp_criteria.control[ACCOUNT_SUPERVISOR]) or
		      (temp_criteria.control[PASSWORD_ONLY] and
		       temp_criteria.control[NETWORK_ADMINISTRATOR]) or
		      (temp_criteria.control[ACCOUNT_SUPERVISOR] and
		       temp_criteria.control[NETWORK_ADMINISTRATOR])
		    then
		      begin
		        scanned.status := RUN_ERROR;
			user_terminal.write_quoted_text_line(
			  'mutually exclusive parameters\')
		      end
		  end (* scanned.keyword_count <> 1 *);
	      PASSWORDDATE_CRITERION:
	        with temp_criteria.date_criteria[criteria_index] do
		  begin
		    qualifier := NO_DATE_QUALIFIER;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		    get_date_selection(temp_criteria, criteria_index, scanned)
		end (* PASSWORDDATE_CRITERION *);
	      ENTRYDATE_CRITERION:
	        with temp_criteria.date_criteria[criteria_index] do
		  begin
		    qualifier := NO_DATE_QUALIFIER;
		    get_date_selection(temp_criteria, criteria_index, scanned)
		  end (* ENTRYDATE_CRITERION *)
	    end (* case criteria_index *)
	  end (* set specific criteria *)
      end (* scanned.status = CMD_OK *);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_terminal.write_quoted_text_line('selection accepted\ ');
      if all
      then do_clear_criteria(criteria_index)
      else criteria := temp_criteria
    end (* scanned.status = CMD_OK *)
end (* select *);
!
"
		WRITE Command
"



(***********************  command_level_utility  ************************)
(*									*)
(*			  report_block_written				*)
(*									*)
(*      Notify operator log that a CUD/MUD block was written.		*)
(*									*)
(************************************************************************)

procedure report_block_written(
      cud_flag		: boolean;
      writing_from_cud	: boolean;
      real_sup		: real_supervisor_index;
      block		: cud_block_index);

begin
  user_terminal.write_line_and_quoted_text_line(BLOCK_WRITTEN);
  format.start_message('block \ ');
  format.number(block, 10);
  format.string(' written to \ ');
  if cud_flag
  then
    begin
      format.string(CUD_FILE_MESSAGE);
      if not writing_from_cud
      then format.string(' (from MUD buffer)\ ');
      oper_messages.report_validator_message(profile)
    end (* cud_flag *)
  else
    oper_messages.report_validator_sup_message(profile, real_sup,
      VALIDATOR_OPLOG_MSG)
end (* report_block_written *);



(*************************  command_level_utility  **********************)
(*									*)
(*			     write_cud_buffer				*)
(*									*)
(*      Write disk_block to CUD.					*)
(*									*)
(************************************************************************)

procedure entry WRITE_CUD_BUFFER(
      writing_from_cud	: boolean);

var
  block_to_write : cud_block_index;
  result : cud_operation_result;
  disk_block : cud_disk_block;
  success : boolean;

begin
  restore_buffer(writing_from_cud, disk_block, success);
  if success
  then
    begin
      if writing_from_cud
      then block_to_write := cud_info.block (* from CUD *)
      else block_to_write := mud_info.block (* from SUPERVISOR *);
      block_updater.update_cud_block(block_to_write, disk_block, result);
      if result = CUD_OPERATION_OK
      then report_block_written(TRUE, writing_from_cud, FIRST_SUPERVISOR,
        block_to_write)
      else
        begin
          user_terminal.write_newline;
          format.cud_block_error(cud_info.block, result);
          format.write_line(user_terminal)
        end (* result <> CUD_OPERATION_OK *)
    end (* success *)
end (* write_cud_buffer *);



(**************************  command_level_utility  *********************)
(*									*)
(*			      write_mud_buffer				*)
(*									*)
(*      Write cud_info to selected supervisor. 				*)
(*									*)
(************************************************************************)

procedure entry WRITE_MUD_BUFFER(
      writing_from_cud	: boolean;
      real_sup		: real_supervisor_index);

var
  status : un2_status;
  disk_block : cud_disk_block;
  success : boolean;

begin
  restore_buffer(writing_from_cud, disk_block, success);
  if success
  then
    begin
      un2_util.write_mud_block(real_sup, cud_info.block, disk_block, status);
      if status = UN2_SUCCESSFUL
      then report_block_written(FALSE, writing_from_cud, real_sup,
        cud_info.block)
      else write_un2_error(real_sup, status, cud_info.block)
    end
end (* write_mud_buffer *);



(************************************************************************)
(************************************************************************)

begin (* null statement *)
end (* command_level_utility *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*                                                              	*)
(*	TAPEIO.NTV							*)
(*                                                                 	*)
(*  			       tape_handler				*)
(*                                                                      *)
(*      This CLASS contains the various tape handling functions.	*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  tape_unit_index, disk_tape_information, ioresult, tape_param	*)
(*	  page, page_index, cud_tape_block				*)
(*                                                                      *)
(************************************************************************)
(*									*)
(*			Revision History:				*)
(*									*)
(*	13May86 - neh							*)
(*	      - add BACK_TAPE procedure if include_dump is enabled	*)
(*	      - if include_dump is enabled, add write_ascii_dump_block	*)
(*	03Feb86 - jrn							*)
(*	      - add general procedures READ and WRITE			*)
(*	27Jul84 - jrn							*)
(*	      - new format tape - standard ANSII labels, list records	*)
(*		  rather than all page I/O				*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - fixed bug in reporting status after retry logic		*)
(*	07jul83 - original - from (basicws)tapeio.bes - jrn		*)
(*									*)
(************************************************************************)



type tape_handler = class;


const
  CONTROLLER = 8 (* for ISIS error codes checked for error recovery *);


var
  entry PARAM : tape_param;
!
(***************************  tape_handler  *****************************)
(*									*)
(*			       drive_status				*)
(*									*)
(************************************************************************)

procedure entry DRIVE_STATUS(
      unit	: tape_unit_index;
  var dev_stat	: disk_tape_information);


begin
  param.operation := TAPE_INFO;
  io(dev_stat, param, TAPE, unit)
end (* drive_status *);
!
(*****************************  tape_handler  ***************************)
(*									*)
(*				detach_unit				*)
(*									*)
(*	DETACH the tape unit specified from the slot.			*)
(*									*)
(************************************************************************)

procedure entry DETACH_UNIT(
      unit	: tape_unit_index);

var
  buffer : char;

begin
  param.operation := TAPE_DETACH;
  io(buffer, param, TAPE, unit)
end (* detach_unit *);
!
(*****************************  tape_handler  ***************************)
(*									*)
(*				attach_unit				*)
(*									*)
(*	ATTACH the tape unit specified to the slot.			*)
(*									*)
(************************************************************************)

procedure entry ATTACH_UNIT(
      unit	: tape_unit_index);

var
  buffer : char;

begin
  param.operation := TAPE_ATTACH;
  io(buffer, param, TAPE, unit)
end (* attach_unit *);
!
(***************************  tape_handler  *****************************)
(*									*)
(*			      do_position_drive				*)
(*									*)
(************************************************************************)

procedure do_position_drive(
      unit	: tape_unit_index;
      pos_op	: integer);

var
  dummy : integer;

begin
  param.operation := TAPE_ACTION;
  param.arg := pos_op;
  io(dummy, param, TAPE, unit)
end (* do_position_drive *);



(***************************  tape_handler  *****************************)
(*									*)
(*			     position_drive				*)
(*									*)
(************************************************************************)

procedure entry POSITION_DRIVE(
      unit	: tape_unit_index;
      pos_op	: integer);

begin
  do_position_drive(unit, pos_op)
end (* position_drive *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_handler  *****************************)
(*									*)
(*			     back_tape					*)
(*									*)
(************************************************************************)

procedure entry BACK_TAPE(
      unit	: tape_unit_index;
  var ok	: boolean);

begin
  do_position_drive(unit, TAPE_BACK_SPACE);
  ok := param.status = COMPLETE
end (* back_tape *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!


(***************************  tape_handler  *****************************)
(*									*)
(*			         read     				*)
(*									*)
(************************************************************************)

procedure read(
      unit		: tape_unit_index;
      io_length		: integer;
  var first_char	: char;
  var ok		: boolean);

var
  retry_count : integer (* count of retries on error *);
  done : boolean (* error, but no re-try *);

begin
  done := FALSE;
  retry_count := 0;
  repeat
    param.operation := TAPE_READ;
    param.count := io_length;
    io(first_char, param, TAPE, unit);
    ok := (param.status = COMPLETE) and (param.arg = io_length);
(*	If there was a controller transmission error, and retry_count	*)
(*	is not MAXIMUM_TAPE_RETRIES, back space tape and try again.	*)
(*	Otherwise, set done to TRUE.					*)
    if (param.status = TRANSMISSION) and (param.count = CONTROLLER) and
      (retry_count < MAXIMUM_TAPE_RETRIES)
    then
      begin (* re-try only if controller error *)
        do_position_drive(unit, TAPE_BACK_SPACE);
	retry_count := succ(retry_count)
      end (* re-try only if controller error *)
    else done := TRUE
  until ok or done
end (* read *);



(***************************  tape_handler  *****************************)
(*									*)
(*			       read_label     				*)
(*									*)
(************************************************************************)

procedure entry READ_LABEL(
      unit	: tape_unit_index;
  var buffer	: ansii_tape_label;
  var ok	: boolean);

begin
  read(unit, MAX_ANSII_TAPE_LABEL_SIZE, buffer[0], ok)
end (* read_label *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(***************************  tape_handler  *****************************)
(*									*)
(*			         write					*)
(*									*)
(*	Write out an array of characters.				*)
(*									*)
(************************************************************************)

procedure write(
      unit		: tape_unit_index;
      io_length		: integer;
  var first_char	: char;
  var ok		: boolean);

var
  gaps_written : integer (* count of erase gaps on errors *);
  done : boolean;

begin
  done := FALSE;
  gaps_written := 0;
  repeat
    param.operation := TAPE_WRITE;
    param.count := io_length;
    io(first_char, param, TAPE, unit);
    ok := param.status = COMPLETE;
(*      There has been a write controller error.  Prepare to try the	*)
(*	write again:  backspace, write a gap and increment gaps_written.*)
    if (param.status = TRANSMISSION) and (param.count = CONTROLLER) and
      (gaps_written < MAXIMUM_TAPE_RETRIES)
    then
      begin
        do_position_drive(unit, TAPE_BACK_SPACE);
	do_position_drive(unit, TAPE_GAP);
	gaps_written := succ(gaps_written)
      end
    else done := TRUE
  until ok or done
end (* write *);



(***************************  tape_handler  *****************************)
(*									*)
(*			      write_label				*)
(*									*)
(*	Write out an ANSII standard tape label from buffer to unit.	*)
(*	If it fails, backspace over the record and			*)
(*	write an erase gap. Re-try MAXIMUM_TAPE_RETRIES times.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_LABEL(
      unit	: tape_unit_index;
  var buffer	: ansii_tape_label;
  var ok	: boolean);

begin
  write(unit, MAX_ANSII_TAPE_LABEL_SIZE, buffer[0], ok)
end (* write_label *);



(***************************  tape_handler  *****************************)
(*									*)
(*			     write_tape_page 				*)
(*									*)
(*	Write out a NETVAL page from buffer to unit.			*)
(*	If it fails, backspace over the record and			*)
(*	write an erase gap. Re-try MAXIMUM_TAPE_RETRIES times.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_TAPE_PAGE(
      unit	: tape_unit_index;
  var buffer	: page;
  var ok	: boolean);

begin
  write(unit, PAGE_SIZE, buffer[0], ok)
end (* write_tape_page *);



(***************************  tape_handler  *****************************)
(*									*)
(*			write_blocked_tape_page				*)
(*									*)
(*	Write out a NETVAL blocked page from buffer to unit.		*)
(*	If it fails, backspace over the record and			*)
(*	write an erase gap. Re-try MAXIMUM_TAPE_RETRIES times.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_BLOCKED_TAPE_PAGE(
      unit	: tape_unit_index;
  var buffer	: univ tape_page_block_in_bytes;
  var ok	: boolean);

begin
  write(unit, TAPE_PAGE_BLOCK_SIZE, buffer[0], ok)
end (* write_blocked_tape_page *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(******************************  tape_handler  **************************)
(*									*)
(*			write_ascii_dump_tape_block			*)
(*									*)
(* 	Write out a block of ascii formatted CUD data from buffer to    *)
(*	unit. Set end_tape to param.status = END_MEDIUM.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_ASCII_DUMP_TAPE_BLOCK(
      unit	: tape_unit_index;
  var buffer	: univ ascii_dump_block_in_bytes;
  var ok	: boolean;
  var end_tape	: boolean);

begin
  write(unit, ASCII_DUMP_BLOCK_SIZE, buffer[0], ok);
  end_tape := param.status = END_MEDIUM
end (* write_ascii_dump_tape_block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_handler  *****************************)
(*									*)
(*			     write_cud_block 				*)
(*									*)
(*	Write out a NETVAL tape_cud_block from buffer to unit.		*)
(*	If it fails, backspace over the record and			*)
(*	write an erase gap. Re-try MAXIMUM_TAPE_RETRIES times.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_CUD_BLOCK(
      unit	: tape_unit_index;
  var buffer	: univ tape_cud_block_in_bytes;
  var ok	: boolean);

begin
  write(unit, TAPE_CUD_BLOCK_SIZE, buffer[0], ok)
end (* write_cud_block *);





(***************************  tape_handler  *****************************)
(*									*)
(*			     write_mud_change  				*)
(*									*)
(************************************************************************)

procedure entry WRITE_MUD_CHANGE(
      unit	: tape_unit_index;
  var buffer	: univ tape_mudupd_header_in_bytes;
  var ok	: boolean);

begin
  write(unit, MAXIMUM_TAPE_MUDUPD_HEADER_SIZE, buffer[0], ok)
end (* write_mud_change *);



(***************************  tape_handler  *****************************)
(*									*)
(*			     write_named_list				*)
(*									*)
(*	Write out a tape_named_list_definition to unit.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_NAMED_LIST(
      unit	: tape_unit_index;
  var buffer	: univ tape_named_list_definition_in_bytes;
  var ok	: boolean);

begin
  write(unit, TAPE_NAMED_LIST_DEFINITION_SIZE, buffer[0], ok)
end (* write_named_list *);



(***************************  tape_handler  *****************************)
(*									*)
(*			   write_global_access				*)
(*									*)
(*	Write out a tape_global_access_definition to unit.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_GLOBAL_ACCESS(
      unit	: tape_unit_index;
  var buffer	: univ tape_global_access_definition_in_bytes;
  var ok	: boolean);

begin
  write(unit, MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE, buffer[0], ok)
end (* write_global_access *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_handler  *****************************)
(************************************************************************)

begin
end (* tape_handler *);
!
(************************************************************************)
(*									*)
(*	TALLOC.NTV							*)
(*									*)
(*			     tape_allocater  				*)
(*									*)
(*	This monitor keeps track of tape units attached and assigned. 	*)
(*								 	*)
(*	The following identifiers must be defined externally:      	*)
(*	  tape_unit_index, tape_param, iodevice, disk_tape_information	*)
(*									*)
(************************************************************************)
(*									*)
(*				Revision Record				*)
(*									*)
(*	21Nov83	Original -- jrn						*)
(*									*)
(************************************************************************)



type
  TAPE_ATTACH_STATE = (UNCOMMITTED, IMPLIED, EXPLICIT);



type
  TAPE_DESCRIPTOR = record
    legal	 : boolean;
    attach_state : tape_attach_state;
    assigned	 : boolean;
    assigned_by	 : licensed_validator_index
  end (* TAPE_DESCRIPTOR *);



type TAPE_ALLOCATER = monitor;



var
  tape_io : tape_handler;


  tape_pool : array [tape_unit_index] of tape_descriptor;
!
(***************************  tape_allocater  ***************************)
(*									*)
(*				initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  unit : tape_unit_index;
  dev_stat : disk_tape_information;

begin
  for unit := 0 to TAPE_UNIT_LIMIT do
    begin
      tape_pool[unit].attach_state := UNCOMMITTED;
      tape_pool[unit].assigned := FALSE;
      tape_io.drive_status(unit, dev_stat);
      tape_pool[unit].legal :=
        not ((tape_io.param.status = FAILURE) and (tape_io.param.status2 < 0))
    end (* with *)
end (* initialize *);
!



(***************************  tape_allocater  ***************************)
(*									*)
(*			      do_detach_unit				*)
(*									*)
(*	DETACH the tape unit specified from the slot; set ATTACH_STATE	*)
(*	to UNCOMMITTED.							*)
(*									*)
(************************************************************************)

procedure do_detach_unit(
      unit	: tape_unit_index;
  var param	: tape_param);

begin
  tape_io.detach_unit(unit);
  param := tape_io.param;
  if (param.status = COMPLETE) or (param.status = INTERVENTION)
  then tape_pool[unit].attach_state := UNCOMMITTED
end (* do_detach_unit *);



(***************************  tape_allocater  ***************************)
(*									*)
(*			      do_attach_unit				*)
(*									*)
(*	ATTACH the tape unit specified to the slot; set ATTACH_STATE	*)
(*	to EXPLICIT if attach_explilcitly is TRUE, otherwise, set	*)
(*	ATTACH_STATE to IMPLIED.  UNIT MUST BE A LEGAL TAPE_UNIT_INDEX. *)
(*									*)
(*					attach_explicitly	    	*)
(*				    TRUE		FALSE	    	*)
(*					    			    	*)
(*   current  < UNCOMMITTED	>EXPLICIT	     >IMPLIED		*)
(*    state  <  IMPLIED		>EXPLICIT	     return success	*)
(*	      < EXPLICIT	return success	     return success	*)
(*									*)
(************************************************************************)

procedure do_attach_unit(
      unit		: tape_unit_index;
      attach_explicitly	: boolean;
  var success		: boolean;
  var param		: tape_param);

begin
  success := TRUE;
  with tape_pool[unit] do
    if attach_state = UNCOMMITTED
    then
      begin
	tape_io.attach_unit(unit);
	param := tape_io.param;
	if (param.status <> COMPLETE) and (param.status <> INTERVENTION)
	then success := FALSE
	else
	  if attach_explicitly
	  then attach_state := EXPLICIT
	  else attach_state := IMPLIED
      end
    else
      if attach_explicitly and (attach_state = IMPLIED)
      then attach_state := EXPLICIT
end (* do_attach_unit *);



(***************************  tape_allocater  ***************************)
(*									*)
(*				attach_unit				*)
(*									*)
(*	ATTACH the tape unit specified to the slot:			*)
(*	UNIT MUST BE A LEGAL TAPE_UNIT_INDEX.				*)
(*									*)
(************************************************************************)

procedure entry ATTACH_UNIT(
      unit	: tape_unit_index;
  var success	: boolean;
  var param	: tape_param);

begin
  param.status := COMPLETE;
  do_attach_unit(unit, TRUE, success, param)
end (* attach_unit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(***************************  tape_allocater  ***************************)
(*									*)
(*				assign_unit				*)
(*									*)
(*	ASSIGN the tape unit specified to the validator.		*)
(*	Set ASSIGNED to TRUE, and if unit is not attached, set		*)
(*	attach_state to IMPLIED.					*)
(*									*)
(*					assigned			*)
(*		   FALSE     to validator     to other validator	*)
(*  UNCOMMITTED   ass + att      					*)
(*  IMPLIED			success		  failure		*)
(*  EXPLICIT	  assign	success		  failure		*)
(*									*)
(************************************************************************)

procedure entry ASSIGN_UNIT(
      unit	: tape_unit_index;
      validator	: licensed_validator_index;
  var status	: tape_assign_status;
  var param	: tape_param);

var
  success : boolean;

begin
  param.status := COMPLETE;
  if tape_pool[unit].assigned
  then
    if tape_pool[unit].assigned_by = validator
    then status := ASSIGN_OK
    else status := ALREADY_ASSIGNED
  else
    begin
      do_attach_unit(unit, FALSE, success, param);
      if success
      then
        begin
	  status := ASSIGN_OK;
          tape_pool[unit].assigned := TRUE;
          tape_pool[unit].assigned_by := validator
        end
      else status := ATTACH_FAILED
    end
end (* assign_unit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(***************************  tape_allocater  ***************************)
(*									*)
(*				detach_unit				*)
(*									*)
(*	DETACH the tape unit specified from the slot.			*)
(*	THE UNIT MUST NOT BE ASSIGNED TO ANY OTHER VALIDATOR.		*)
(*									*)
(*					assigned			*)
(*		   FALSE     to validator     to other validator	*)
(*  UNCOMMITTED   success 	     					*)
(*  IMPLIED		     det + deas		  failure		*)
(*  EXPLICIT	  detach     det + deas		  failure		*)
(*									*)
(************************************************************************)

procedure entry DETACH_UNIT(
      unit	: tape_unit_index;
      validator	: licensed_validator_index;
  var param	: tape_param);

begin
  param.status := COMPLETE;
  with tape_pool[unit] do
    if not assigned or (assigned_by = validator)
    then
      begin
        tape_pool[unit].assigned := FALSE;
        do_detach_unit(unit, param)
      end
end (* detach_unit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(***************************  tape_allocater  ***************************)
(*									*)
(*			      deassign_unit				*)
(*									*)
(*	DEASSIGN the tape unit that belongs to the validator.		*)
(*	Set ASSIGNED to FALSE;  if attach_state is IMPLIED,		*)
(*	detach unit.							*)
(*									*)
(*					assigned			*)
(*		   FALSE     to validator     to other validator	*)
(*  UNCOMMITTED     n/a 	     					*)
(*  IMPLIED		     deas + det		     nothing		*)
(*  EXPLICIT	 nothing        deas		     nothing		*)
(*									*)
(************************************************************************)

procedure entry DEASSIGN_UNIT(
      unit	: tape_unit_index;
      validator	: licensed_validator_index;
  var param	: tape_param);

begin
  param.status := COMPLETE;
  with tape_pool[unit] do
    if assigned and (assigned_by = validator)
    then
      begin
        assigned := FALSE;
        if attach_state = IMPLIED
        then do_detach_unit(unit, param)
      end
end (* deassign_unit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(**************************  tape_allocater  ****************************)
(*									*)
(*			      legal_tape				*)
(*									*)
(*	This function returns true if the tape unit is legal.		*)
(*									*)
(************************************************************************)

function entry LEGAL_TAPE(
      unit	: tape_unit_index) : boolean;

begin
  legal_tape := tape_pool[unit].legal
end (* legal_tape *);



(**************************  tape_allocater  ****************************)
(*									*)
(*			    tape_information				*)
(*									*)
(*	Return the tape_descriptor for the specified tape unit.		*)
(*									*)
(************************************************************************)

procedure entry TAPE_INFORMATION(
      unit	: tape_unit_index;
  var info	: tape_descriptor);

begin
  info := tape_pool[unit]
end (* tape_information *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  tape_allocater  ****************************)
(*									*)
(*			    validator_tape				*)
(*									*)
(*	Return the unit that the validator has assigned.		*)
(*									*)
(************************************************************************)

procedure entry validator_tape(
      validator	: validator_index;
  var found	: boolean;
  var unit	: tape_unit_index);

var
  unit_index : tape_unit_index;

begin
  found := FALSE;
  for unit_index := 0 to TAPE_UNIT_LIMIT do
    with tape_pool[unit_index] do
    if assigned and (assigned_by = validator)
    then
      begin
        found := TRUE;
	unit := unit_index
      end
end (* validator_tape *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_allocater  ***************************)
(************************************************************************)

begin
  initialize
end (* tape_allocater *);
!
(************************************************************************)
(*									*)
(*	taputl.ntv							*)
(*									*)
(*				tape_utility				*)
(*									*)
(*	This class handles the DISPLAY STATUS and DEASSIGN routines.	*)
(*	It is called both from the archive_commands class and at	*)
(*	logout time for privileged validators.				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  tape_attach_state, tape_descriptor, tape_unit_index,		*)
(*	  validator_index						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	08Jan85 - jrn							*)
(*	      - do not output ANY message in deassign_tape routine	*)
(*		if output_message is FALSE				*)
(*	21Jun84	- jrn							*)
(*	      - use disk_maintenance_code				*)
(*	14Mar84	Version 2.01 modified by jrn				*)
(*	      - added flag in the DEASSIGN_TAPE routine that makes it	*)
(*		optional to output the deassign message			*)
(*	Original -- jrn							*)
(*									*)
(************************************************************************)

type TAPE_UTILITY = class(
	validator	: licensed_validator_index;
	login_pool	: login_distributer;
	tape_pool	: tape_allocater;
	format		: internal_to_string;
	user_terminal	: circuit_handler);



!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(***************************  tape_utility  *****************************)
(*									*)
(*			     display_status				*)
(*									*)
(*      Type the status of all in use tape devices.			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_STATUS(
  var displayed : boolean);

var
  unit : tape_unit_index;
  name : username_string;
  info : tape_descriptor;

begin
  displayed := FALSE;
  for unit := 0 to TAPE_UNIT_LIMIT do
    begin
      tape_pool.tape_information(unit, info);
      if info.legal and (info.assigned or (info.attach_state <> UNCOMMITTED))
      then
	begin
          if not displayed
          then
            begin
	      user_terminal.write_quoted_text_line('unit\ ');
	      displayed := TRUE
	    end (* not displayed *);
          format.start;
	  format.format_number(unit, 10, 3);
	  format.skip_to(8);
	  if info.attach_state = EXPLICIT
	  then format.string('ATTACHED    \ ')
	  else format.skip(12);
	  if info.assigned
	  then
	    begin
	      format.string('ASSIGNED to \ ');
	      login_pool.validator_name(info.assigned_by, name);
	      format.username(name)
	    end;
	  format.write_line(user_terminal)
        end (* if info.legal... *)
    end (* for *)
end (* display_status *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)




(****************************  tape_utility  ****************************)
(*									*)
(*			  do_display_tape_error				*)
(*									*)
(************************************************************************)

procedure do_display_tape_error(
      tape_unit	: tape_unit_index;
      param	: tape_param);

begin
  format.start_line_message('Error on tape unit \');
  format.number(tape_unit, 10);
  format.colon_space;
  format.status_name(param.status);
  format.newline;
  format.controller_status(param.status, param.status2, param.count);
  format.write_line(user_terminal)
end (* do_display_tape_error *);
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_utility  *****************************)
(*									*)
(*			     deassigned_tape				*)
(*									*)
(************************************************************************)

procedure entry DEASSIGN_TAPE(
      unit		: tape_unit_index;
      output_message	: boolean);

var
  param : tape_param;

begin
  tape_pool.deassign_unit(unit, validator, param);
  if output_message
  then
    if param.status <> COMPLETE
    then do_display_tape_error(unit, param)
    else
      begin
        format.start_message('tape unit \ ');
        format.number(unit, 10);
        format.string(' deassigned\');
        format.write_line(user_terminal)
      end
end (* deassign_tape *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  tape_utility  ****************************)
(*									*)
(*			    display_tape_error				*)
(*									*)
(************************************************************************)

procedure entry display_tape_error(
      tape_unit	: tape_unit_index;
      param	: tape_param);

begin
  do_display_tape_error(tape_unit, param)
end (* display_tape_error *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* tape_utility *);
!
(************************************************************************)
(*									*)
(*	FILTER.NTV							*)
(*									*)
(*				filter_utility				*)
(*									*)
(*	This class handles all filter message and print message		*)
(*	routines.							*)
(*									*)
(*      The routines are organized as follows:				*)
(*		clear_filter routine					*)
(*	        DISPLAY FILTER routines					*)
(*              FILTER COMMAND routines					*)
(*		MESSAGE command routines				*)
(*									*) 
(*      The following identifiers must be defined externally:		*)
(*	 	validator_index, username_string, modify_index,		*)
(*	 	message_kind_index, real_supervisor_index		*)
(*									*)
(*									*)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	10Nov86 - neh							*)
(*	       - Add misc_utility and username_match			*)
(*	12Sep86 - neh							*) 
(*	      - Move MESSAGE command procedures print_log_message and   *)
(*		scan_message_command from globl_commands with changes   *)
(*		include check_validator, check_modify, check_master	*)
(*		and check_entry functions.				*)
(*	      - Change print_log_message to output modify_type,		*)
(*		supervisor number, cud name change and validator info.	*)
(*	      - Changed scan_message_command to call do_display_filter  *)
(*		and to only print messages if the message type is	*)
(*		selected.						*)
(*		Original -- neh						*)
(*									*)
(************************************************************************) 

type filter_utility = class(
validator	: univ licensed_validator_index;
      format		: internal_to_string;
      argument_scan	: argument_scanner;
      keyword_util	: keyword_utility;
      mutil		: misc_utility;
      user_terminal	: circuit_handler;
      oplog		: operator_log);



type

  MODIFY_SELECTION = array [modify_index] of boolean;

  FILTER_CRITERIA_SELECTION = record
    all_select 			: boolean;
    sup_to_match 		: array [real_supervisor_index] of boolean;
    message_type 		: array [message_kind_index] of boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    modify_all 			: boolean;
    modify_type 		: modify_selection;
    cud_name_to_match 		: username_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    validator_number_select 	: boolean;
    validator_number_to_match 	: validator_index;
    validator_name_to_match 	: username_string
  end (* filter_criteria_selection *);


(* Permanent Variables *)

var
  filter_selection	: filter_criteria_selection;
!
"
	Clear FILTER selections
"
(***************************  filter_utility  ***************************) 
(*									*) 
(*		 	     do_clear_filter				*) 
(*									*) 
(*	This procedure will clear the values in the filter_selection	*)
(*	record in order to remove previously selected filters.		*) 
(*	This procedure is called by the validator login procedure 	*) 
(*	and by the FILTER ALL command.					*) 
(*									*) 
(************************************************************************) 

procedure do_clear_filter;

var
  sup_index : real_supervisor_index;
  message_index : message_kind_index;
 index : modify_index;

begin
  with filter_selection do
    begin
      for sup_index  := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
        sup_to_match[sup_index] := FALSE;
      for message_index := FIRST_MESSAGE_KIND to LAST_MESSAGE_KIND do
        message_type[message_index] := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      modify_all := FALSE;
      for index := FIRST_MODIFY_TYPE to LAST_MODIFY_TYPE do
        modify_type[index] := FALSE;
      cud_name_to_match.size := 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      validator_number_select := FALSE;
      validator_number_to_match := 0;
      validator_name_to_match.size := 0
    end (* with *)
end (* do_clear_filter *);



(****************************  filter_utility  **************************) 
(*									*) 
(*		 	        clear_filter				*)
(*									*) 
(*	Set all filter selections to FALSE and values to 0.		*)
(*	Set all_select to TRUE.						*)
(*									*) 
(************************************************************************) 

procedure entry CLEAR_FILTER;

begin
  do_clear_filter;
  filter_selection.all_select := TRUE
end (* clear_filter *);
!
"
		Display Filter Selection Routines
"


(***************************  filter_utility  ***************************) 
(*									*) 
(*		 	    display_supervisor				*) 
(*									*) 
(*	Display supervisor numbers which are on in filter_selection.	*)
(*									*) 
(************************************************************************) 

procedure display_supervisor; 

var
  sup_found : boolean;
  sup_index : real_supervisor_index;

begin
  sup_found := FALSE;
  with filter_selection do
    for sup_index := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
      if sup_to_match[sup_index]
      then
	begin
	  if sup_found
	  then
	    begin
	      format.character(ASCII_COMMA);
	      format.skip (1)
	    end
	  else
            begin
              sup_found := TRUE;
              format.start_message('Supervisor \');
            end (* not sup_found *);
          format.sup_number(sup_index)
        end (* if sup_to_match *);
  if sup_found then format.write_line(user_terminal)
end (* display_supervisor *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*****************************  filter_utility  *************************) 
(*									*)
(*		 	        display_modify				*)
(*									*)
(************************************************************************)

procedure display_modify(
       cud_name	: username_string);

var
  i : modify_index;

begin
  i := FIRST_MODIFY_TYPE;
  while not filter_selection.modify_type[i] and (i < LAST_MODIFY_TYPE) do
    i := succ(i);
  if filter_selection.modify_type[i]
  then
    begin
      format.put_modify_description(i);
      for i := succ(i) to LAST_MODIFY_TYPE do
        if filter_selection.modify_type[i]
        then
          begin
	    format.write_line(user_terminal);
	    format.start_message('modify \');
            format.put_modify_description(i)
          end (* if modify_type[i] *);
	  if cud_name.size > 0
	  then
	    begin
	      format.write_line(user_terminal);
	      format.start_message('modify \')
	    end
    end (* if modify_type[i] *);
  if cud_name.size > 0
  then
    begin
      format.string('user \');
      format.username(cud_name)
    end (* if cud_name.size > 0 *)
end (* display_modify *); 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*) 



(***************************  filter_utility  ***************************) 
(*									*) 
(*		 	    do_display_filters				*)
(*									*) 
(*	This procedure is called by the DISPLAY FILTER and MESSAGE	*)
(*	commands to scan the filter_selection record for the filter	*)
(*	types which are selected.					*)
(*									*) 
(************************************************************************) 

procedure do_display_filters;

var
  sup_index : real_supervisor_index;
  message_index : message_kind_index;
 index : modify_index;

begin
  with filter_selection do
    begin
      if all_select
      then format.start_message('ALL \ ')
      else format.start;
      format.string('Messages currently filtered\');
      format.write_line(user_terminal);
      if not all_select
      then
        begin
          display_supervisor;
	  for message_index := FIRST_MESSAGE_KIND to LAST_MESSAGE_KIND do
	    if message_type[message_index]
	    then
	      begin
    	        format.start;
	        format.put_message_kind(message_index);
	        format.skip(1);
	        if message_index = VALIDATOR_OPLOG_MSG
		then
		  begin
		    if validator_number_select
	            then
		      begin
		        format.string('number \');
		        format.number(validator_number_to_match, 10)
		      end
	            else
		      if validator_name_to_match.size > 0
	              then
		        begin
		          format.string('username \');
		          format.username(validator_name_to_match);
		        end
		  end (* VALIDATOR_OPLOG_MSG *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	        if message_index = MODIFY_CUD_OPLOG_MSG
		then
		  begin
		    if filter_selection.modify_all
		    then format.string('ALL\')
	            else display_modify(cud_name_to_match)
		  end (* MODIFY_CUD_OPLOG_MSG *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
                format.write_line(user_terminal)
	      end (* if message_type *)
        end (* not all_select *)
    end (* with filter_selection *)
end (* do_display_filters *);
!
"
		DISPLAY FILTER Command
"


(****************************  filter_utility  **************************) 
(*									*) 
(*		 	       display_filters				*)
(*									*) 
(*	Command to output current filter selectio.			*)
(*									*) 
(************************************************************************) 

procedure entry DISPLAY_FILTERS;

begin
  do_display_filters
end (* display_filters *);
"
		FILTER Command
"


(****************************  filter_utility  **************************) 
(*									*) 
(*		 	      get_sup_to_match				*) 
(*									*) 
(*	Return real_superviosr_index of sup  number in command string.	*)
(*									*) 
(************************************************************************) 

procedure get_sup_to_match(
  var scanned	: scanned_command);

var
  index : real_supervisor_index;
  freeword : command_freeword_index;
  temp : integer;

begin
  if scanned.freeword_count = 0
  then
    for index := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
      filter_selection.sup_to_match[index] := TRUE
  else
    for freeword := 0 to scanned.freeword_count - 1 do
      begin
        argument_scan.freeword_list(freeword,
          FIRST_SUPERVISOR + PRINT_SUPERVISOR_OFFSET,
	  MAXIMUM_REAL_SUPERVISOR + PRINT_SUPERVISOR_OFFSET, 10,
	  scanned, temp);
        if scanned.status = CMD_OK
        then filter_selection.sup_to_match[temp - PRINT_SUPERVISOR_OFFSET] := TRUE
      end (* for *)
end (* get_sup_to_match *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*****************************  filter_utility  *************************) 
(*									*) 
(*		 	       scan_modify_type				*) 
(*									*) 
(*	 This procedure will check for a modify_type in the command.	*)
(*									*) 
(************************************************************************) 

procedure scan_modify_type(
  var scanned	: scanned_command);

var
  count : integer;
  change_keyword : command_keyword_index;
  cud_name : username_string;
  temp_modify : modify_selection;

begin
  temp_modify := filter_selection.modify_type;
  count := 0;
  if argument_scan.check_keyword(PRIMARY_FILTER_VALIDATOR_USER_KEYWORD, scanned)
  then
    begin
      argument_scan.keyword_username(
        PRIMARY_FILTER_VALIDATOR_USER_KEYWORD, scanned, cud_name);
      if scanned.status = CMD_OK
      then filter_selection.cud_name_to_match := cud_name
    end (* PRIMARY_FILTER_VALIDATOR_USER_KEYWORD *)
  else
    for change_keyword := PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD to
      PRIMARY_FILTER_MODIFY_NEW_KEYWORD do
      if argument_scan.check_keyword(change_keyword, scanned)
      then
        begin
          case change_keyword of
            PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD: temp_modify[ACCESS] := TRUE;
            PRIMARY_FILTER_MODIFY_CONTROL_KEYWORD: temp_modify[CONTROL] := TRUE;
            PRIMARY_FILTER_MODIFY_DISTRICT_KEYWORD: temp_modify[DISTRICT] := TRUE;
            PRIMARY_FILTER_MODIFY_GAN_KEYWORD: temp_modify[GAN] := TRUE;
            PRIMARY_FILTER_MODIFY_NAME_KEYWORD: temp_modify[CHANGENAME] := TRUE;
            PRIMARY_FILTER_MODIFY_PASSWORD_KEYWORD: temp_modify[PASSWORD] := TRUE;
            PRIMARY_FILTER_MODIFY_UUN_KEYWORD: temp_modify[UUN] := TRUE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
            PRIMARY_FILTER_MODIFY_DELETE_KEYWORD: temp_modify[DELETE] := TRUE;
            PRIMARY_FILTER_MODIFY_NEW_KEYWORD: temp_modify[NEW] := TRUE
        end (* case *);
      count := count + 1
    end (* if argument_scan.check_keyword *);
  if count > 5
  then scanned.status := TOO_MANY_ARGS;
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      filter_selection.modify_all := FALSE;
      filter_selection.modify_type := temp_modify
    end
end (* scan_modify_type *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*) 



(****************************  filter_utility  **************************) 
(*									*) 
(*		 	     scan_filter_command			*) 
(*									*) 
(*	This procedure is called by the FILTER command to scan the	*)
(*	command line and turn the selected filter on.			*)
(*									*) 
(************************************************************************) 

procedure entry SCAN_FILTER_COMMAND(
  var scanned	: scanned_command);

var
  filter_keyword : command_keyword_index;
  val_keyword : command_keyword_index;
  message_index : message_kind_index;
  index : modify_index;
  username : username_string;
  temp : validator_index;

begin
  with filter_selection do
    begin
      argument_scan.find_keyword(PRIMARY_FILTER_ALL_KEYWORD,
PRIMARY_FILTER_VALIDATOR_KEYWORD,
 	  scanned, filter_keyword);
      if scanned.status = CMD_OK
      then
        case filter_keyword of
          PRIMARY_FILTER_ALL_KEYWORD: do_clear_filter;
	  PRIMARY_FILTER_ARCHIVE_KEYWORD: message_index := ARCHIVE_OPLOG_MSG;
	  PRIMARY_FILTER_CONSISTENCY_KEYWORD: message_index := CONSISTENCY_OPLOG_MSG;
	  PRIMARY_FILTER_CUDERROR_KEYWORD: message_index := CUD_OPLOG_MSG;
	  PRIMARY_FILTER_DEBUG_KEYWORD: message_index := DEBUGGING_OPLOG_MSG;
	  PRIMARY_FILTER_FILE_KEYWORD: message_index := FILE_OPLOG_MSG;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  PRIMARY_FILTER_MODIFY_KEYWORD:
	    begin
	      message_index := MODIFY_CUD_OPLOG_MSG;
	      if scanned.keyword_count > 1
	      then scan_modify_type(scanned)
	      else
		begin
		  for index := FIRST_MODIFY_TYPE to LAST_MODIFY_TYPE do
		    modify_type[index] := FALSE;
		  cud_name_to_match.size := 0;
		  modify_all := TRUE
		end
	    end (* PRIMARY_FILTER_MODIFY_KEYWORD *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  PRIMARY_FILTER_MUDUPDATE_KEYWORD: message_index := MUDUPD_OPLOG_MSG;
	  PRIMARY_FILTER_OPERATOR_KEYWORD: message_index := OPERLOG_REPORT_MSG;
	  PRIMARY_FILTER_PARAMETER_KEYWORD: message_index := CUD_PARAM_OPLOG_MSG;
	  PRIMARY_FILTER_SUPERVISOR_KEYWORD: get_sup_to_match(scanned);
	  PRIMARY_FILTER_SYSMSG1_KEYWORD: message_index := SYSMSG1_OPLOG_MSG;
	  PRIMARY_FILTER_UN2_KEYWORD: message_index := UN2_OPLOG_MSG;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  PRIMARY_FILTER_VALIDATOR_KEYWORD:
	    begin
	      message_index := VALIDATOR_OPLOG_MSG;
	      if scanned.keyword_count > 1
	      then
		begin
	          argument_scan.find_keyword(
		    PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD,
		    PRIMARY_FILTER_VALIDATOR_USER_KEYWORD,
		    scanned, val_keyword);
		  if (val_keyword = PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD)
		    and (scanned.status = CMD_OK)
	          then
		    begin
		      keyword_util.get_numeric_keyword_value(
	                PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD, 10,
		        FIRST_VALIDATOR, MAXIMUM_VALIDATOR,
	                scanned, temp);
  	              if scanned.status = CMD_OK
                      then
			begin
			  validator_name_to_match.size := 0;
			  validator_number_select := TRUE;
			  validator_number_to_match := temp
			end
		    end
		  else
	            if (val_keyword = PRIMARY_FILTER_VALIDATOR_USER_KEYWORD) and
		      (scanned.status = CMD_OK)
		    then
		      begin
		        argument_scan.keyword_username(
		          PRIMARY_FILTER_VALIDATOR_USER_KEYWORD,
                          scanned, username);
		        if scanned.status = CMD_OK
		        then
			  begin
		    	    validator_number_select := FALSE;
			    validator_name_to_match := username
			 end
		       end
		end (* if keyword_count > 1 *)
	      else
		begin
		  validator_name_to_match.size := 0;
		  validator_number_select := FALSE
		end
	    end (* PRIMARY_FILTER_VALIDATOR_KEYWORD *)
        end (* case *);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  if filter_keyword = PRIMARY_FILTER_ALL_KEYWORD
	  then all_select := TRUE
	  else all_select := FALSE;
          if (filter_keyword <> PRIMARY_FILTER_SUPERVISOR_KEYWORD) and
	    (filter_keyword <> PRIMARY_FILTER_ALL_KEYWORD)
          then message_type[message_index] := TRUE;
	  user_terminal.write_quoted_text_line('message filter accepted\')
	end (* status = CMD_OK *)
    end (* with *)
end (* scan_filter_command *);
"
		MESSAGE command routines
"




(****************************  filter_utility ***************************) 
(*									*) 
(*		 	         sup_selected				*) 
(*									*) 
(*	 Return true if all sups are selected are sup_number is TRUE	*)
(*	 in sup_to_match.						*)
(*									*)
(************************************************************************)

function sup_selected : boolean;

var
  done : boolean;
  temp : boolean;
  sup_index : real_supervisor_index;

begin
  sup_index := FIRST_SUPERVISOR;
(* check if any sups were selected *)
  done := FALSE;
  repeat
    temp := filter_selection.sup_to_match[sup_index];
    if sup_index < MAXIMUM_REAL_SUPERVISOR
    then sup_index := sup_index + 1
    else done := TRUE
  until done or temp (* either found sup on or checked all sups *);
  sup_selected := temp
end (* sup_selected *); 



(****************************  filter_utility  **************************) 
(*									*) 
(*		 	      check_validator				*) 
(*									*) 
(*	Return TRUE is validator name or number in message matches	*)
(*	validator name or number in filter selection.			*)
(*									*) 
(************************************************************************) 

function check_validator(
      sup_number: integer;
      number	: validator_index;
      name	: username_string) : boolean;

var
  temp : boolean;

begin
  with filter_selection do
    begin
      if validator_number_select
      then temp := number = validator_number_to_match
      else
        if validator_name_to_match.size > 0
        then temp := mutil.username_match(validator_name_to_match, name)
        else temp := TRUE;
      if sup_selected 
      then
        if ((sup_number >= FIRST_SUPERVISOR)
	  and (sup_number <= MAXIMUM_REAL_SUPERVISOR))
        then temp := sup_to_match[sup_number] and temp
        else temp := FALSE
    end (* with *);
  check_validator := temp
end (* check_validator *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(****************************  filter_utility  **************************) 
(*									*) 
(*		 	        check_modify				*)
(*									*) 
(*	Return TRUE if modify_all is TRUE or if modify_type[index]	*)
(*	is TRUE or is cud_name matches cud_name_to_match.		*)
(*									*) 
(************************************************************************) 

function check_modify(
      cud_name	: username_string;
      index	: modify_index) : boolean;

var
  temp : boolean;
  i : modify_index;

begin
  with filter_selection do
    if not modify_all
    then
      begin
	i := FIRST_MODIFY_TYPE;
	while not modify_type[i] and (i < LAST_MODIFY_TYPE) do
	    i := succ(i);
	if modify_type[i]
	then
	  begin
	    if (index >= FIRST_MODIFY_TYPE) and (index <= LAST_MODIFY_TYPE)
	    then 
	      begin
	        if cud_name_to_match.size > 0
	        then temp := mutil.username_match(cud_name_to_match, cud_name)
		  and modify_type[index]
	        else temp := modify_type[index]
	      end
	    else temp := FALSE
	  end (* if modify_type[i] *)
	else temp := cud_name_to_match = cud_name
      end (* if not modify_all *)
    else temp := TRUE;
  check_modify := temp
end (* check_modify *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  filter_utility  **************************) 
(*									*) 
(*		 	       check_entry			 	*) 
(*									*) 
(*	Function to check if a log_entry is of the type selected	*)
(*	by filter_criteria.						*)
(*									*) 
(************************************************************************) 

function check_entry(
      next_message	: oper_log_entry) : boolean;

var
  temp : boolean;

begin
  with filter_selection do
    begin
      temp := all_select;
      if not temp
      then
        with next_message do
	  begin
	    if (kind >= first_message_kind) and
              (kind <= last_message_kind)
            then temp := message_type[kind]
	    else temp := FALSE;
	    if temp
	    then
              begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      	        if kind = MODIFY_CUD_OPLOG_MSG
      	        then temp := check_modify(cud_name, modify)
	        else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
                if kind = VALIDATOR_OPLOG_MSG
                then temp := check_validator(sup_number, login_number,
		  login_name)
		else
	          if (kind = CONSISTENCY_OPLOG_MSG) or (
		    (kind = SYSMSG1_OPLOG_MSG) or (kind = UN2_OPLOG_MSG))
	          then
                    if sup_selected
		    then
		      if ((sup_number >= FIRST_SUPERVISOR)
	                and (sup_number <= MAXIMUM_REAL_SUPERVISOR))
                      then temp := sup_to_match[sup_number]
		      else temp := FALSE
          end (* if temp *)
        else
          if sup_selected
	  then
            if ((sup_number >= FIRST_SUPERVISOR)
	      and (sup_number <= MAXIMUM_REAL_SUPERVISOR))
            then temp := sup_to_match[sup_number] and
	      ((not message_type[CONSISTENCY_OPLOG_MSG]) and
	      (not message_type[SYSMSG1_OPLOG_MSG])) and
	      ((not message_type[UN2_OPLOG_MSG]) and
	      (not message_type[VALIDATOR_OPLOG_MSG]))
	    else temp := FALSE
      end (* with next_message *)
    end (* with filter_selection *);
  check_entry := temp
end (* check_entry *);



(**************************  filter_utility  ****************************)
(*									*)
(*			   print_log_messages				*)
(*									*)
(*	Print operator_log message information in oper_log_entry to	*)
(*	user's terminal.						*)
(*									*) 
(************************************************************************)

procedure print_log_message(
  var next_message 	: oper_log_entry;
  var last_time		: integer);

begin
  if check_entry(next_message)
  then
    with next_message do
      begin
        if time <> last_time
        then
          begin
            format.start_and_newline;
            format.time(time);
            format.write_line(user_terminal);
            last_time := time
          end (* not last_time *);
        format.start;
        if (kind = SYSMSG1_OPLOG_MSG) or (kind = UN2_OPLOG_MSG)
        then
	  begin
	    format.put_message_kind(kind);
	    format.string(' error on \ ')
          end;
        if (sup_number > 0) and (kind <> VALIDATOR_OPLOG_MSG)
        then 
	  begin
	    format.string(SUPERVISOR_MESSAGE);
	    format.sup_number(sup_number);
	    format.write_line(user_terminal)
	  end;
          user_terminal.write_log_message(message);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        if kind = MODIFY_CUD_OPLOG_MSG
        then
          begin
	    format.start;
	    format.username(cud_name);
	    format.by_validator(login_name);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    format.write_line(user_terminal)
          end (* MODIFY_CUD_OPLOG_MSG *)
        else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          if (login_name.size > 0) and (kind <> MODIFY_CUD_OPLOG_MSG)
	  then
            begin
	      format.start;
	      if sup_number > 0
	      then
		begin
		  format.string(SUPERVISOR_MESSAGE);
		  format.sup_number(sup_number);
		  format.by_validator(login_name)
		end
	      else
		begin
	          format.number(login_number, 10);
	          format.skip(3);
                  format.username(login_name)
		end (* else *);
              format.write_line(user_terminal)
	    end (* if login_name.size *)
          else user_terminal.write_newline
      end (* with *)
end (* print_log_message *);



(***************************  filter_utility  ***************************)
(*									*)
(*			   scan_message_command				*)
(*									*)
(*	Output selected filters, output each message which is of the    *)
(*	type selected in filter_selection.				*)
(*									*) 
(************************************************************************)

procedure entry SCAN_MESSAGE_COMMAND(
  var scanned	: scanned_command);

var
  start_time : integer (* start time if specified *);
  last_time : integer;
  next_message : oper_log_entry;
  got_message : boolean;

begin
  last_time := -1 (* set previous message time to impossible time *);
  if argument_scan.check_keyword(PRIMARY_MESSAGE_FROM_KEYWORD, scanned)
  then argument_scan.freeword_date_and_time(0, REALTIME, scanned, start_time)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if scanned.status = CMD_OK
  then argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
      do_display_filters;
      if PRIMARY_MESSAGE_FROM_KEYWORD in scanned.keyword_present
      then
        begin
(* Find the first message of a time greater than or equal to the time	*)
(* requested and set up validator_sequence with that sequence.		*)
(* NOTE: between the time of finding the first record and reading it,	*)
(* another process may write over the record desired			*)
	  oplog.find_timed_message(
	validator,
            start_time, got_message);
	  while got_message and user_terminal.sendable do
	    begin
              oplog.read_timed_message(
	validator,
                next_message, got_message);
  	      if got_message
  	      then print_log_message(next_message, last_time)
            end (* while *)
        end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      else
        repeat
          oplog.read(next_message, got_message);
	  if got_message
	  then
	    begin
	      print_log_message(next_message, last_time);
	      if not user_terminal.break_pending
	      then oplog.advance_address (* advances "last read record" *)
	    end
          else
            begin
              wait;
	      user_terminal.check_circuit
	    end
        until not user_terminal.sendable
    end (* if status = CMD_OK *)
end (* scan_message_command *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* filter_utility *);
!
!
(************************************************************************)
(*									*)
(*	arccmd.ntv							*)
(*									*)
(*			archive_commands				*)
(*									*)
(*	This class handles all the ARCHIVE sub-system commands.		*)
(*									*)
(*	The routines are organized as follows:				*)
(*		reporting routines					*)
(*		utility routines					*)
(*		label character manipulation routines			*)
(*		commands (RESTORE, STORE, others)			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	09Sep86 - neh							*) 
(*	      - Change oper_log_message kind from FILE_OPLOG_MSG to	*)
(*		ARCHIVE_OPLOG_MSG in DUMP, STORE and RESTORE.		*)
(*	12Aug86 - jrn							*)
(*	      - add lots of "FAILED" comments to help catch the		*)
(*		operators attention when a STORE or RESTORE aborts	*)
(*	14May86 - neh							*)
(*	      - add DUMP command to dump CUD in ascii format to tape	*)
(*	      - add reporting routines					*)
(*		 (REPORT_FULL_ON_BLOCK, REPORT_CUD_ENTRY_ERROR)		*)
(*	      - add get_cud_locked					*)
(*	      - add output_storing to be used by initialize_file_store  *)
(*		and initilize_dump					*)
(*	      - add write_eof_label to be used by complete_store and	*)
(*		complete_dump						*)
(*	10Mar86 - jrn							*)
(*	      - redo reuse_uuns to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	27Jan86 - jrn							*)
(*	      - change NULL_PROMPT to NULL_STRING			*)
(*	10Jan85 - jrn - version 3.00					*)
(*	      - do not require "UNIT" keyword to be entered		*)
(*	      - store different format CUD_PARAMETER_FILE if reuse_uuns	*)
(*		is enabled						*)
(*	      - add logical_volume_directory				*)
(*	      - new format tape - ANSII format labels and records;	*)
(*		named_lists, classes and groups rather than pages	*)
(*	12Mar85 - jrn - Version 2.03					*)
(*	      - do not put out a newline between each CUD error message	*)
(*		during store and restore				*)
(*	21Jun84	- jrn							*)
(*	      - use disk_maintenace_code; move RESTORE to NVDM and	*)
(*		allow:							*)
(*			RESTORE CUD BLOCK range				*)
(*	03Apr84 Version 2.02 - jrn					*)
(*	      - consolidate OKAY message				*)
(*	14Mar84	Version 2.01 - jrn neb					*)
(*	      - more descriptive procedure names, shorter procedure	*)
(*		names where possible, single-use procedures combined,	*)
(*		various other efficiencies				*)
(*	      - get_unit remembers if the unit specified has been pre-	*)
(*		viously assigned, and if so, does not deassign it when	*)
(*		done							*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

type ARCHIVE_COMMANDS = class(
	validator	: licensed_validator_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	login_pool	: login_distributer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	tape_pool	: tape_allocater;
	mud_change	: mud_change_handler;
	sys_io		: system_handler;
	mutil		: misc_utility;
	statistics	: statistics_gatherer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	file_system	: file_system_manager;
	param_manager	: cud_parameter_controller;
        cmd_utility	: command_level_utility;
	cud_update_util	: cud_updater_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        cud_access	: cud_access_controller;
	block_updater	: cud_block_updater;
	block_utility	: cud_block_utility;
	cud_utility	: cud_entry_utility;
        cud_updater     : cud_entry_updater;
	dsksys          : disk_system;
	tape_io		: tape_handler;
	tape_util	: tape_utility;
	user_terminal	: circuit_handler;
	command_read	: command_loop;
	argument_scan	: argument_scanner;
	freeword_utility: freeword_response_utility;
	keyword_util	: keyword_utility;
	keyword_scan	: keyword_scanner;
	scan_error	: command_error_message;
	format		: internal_to_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	oplog		: operator_log;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	oper_messages	: operator_messages;
	list_io		: node_host_list_io_utility;
	list_allocater	: node_host_list_allocater;
	list_access	: node_host_list_access;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 	calendar	: date_time_converter;
	list_utility	: node_host_list_utility);



const
  error_offset_message = ' error, offset: \ ';
  file_header_message = '(header)\ ';
  file_nodelists_message = '(nodelists)\';
  file_hostlists_message = '(hostlists)\';
  file_classes_message = '(classes)\';
  file_groups_message = '(groups)\ ';

(*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  not_assigned = 'no tape unit assigned\';
  storing_message = 'storing \ ';
  USER_COUNT_SIZE = 6	(* number of places in ascii string *);
  ACCESS_COUNT_SIZE = 4;
  ASCII_DUMP = ' ASCII dump\';
  ASCII_PROFILE_FLAG = 'P';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



var
  param_file : cud_parameter_file_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  config_utility : configuration_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		reporting routines
"


(**************************  archive_commands  **************************)
(*									*)
(*			    report_tape_error				*)
(*									*)
(************************************************************************)

procedure report_tape_error(
      unit	: tape_unit_index);

begin
  if tape_io.param.status = COMPLETE
  then user_terminal.write_quoted_text_line(
    'size does not match tape record\')
  else tape_util.display_tape_error(unit, tape_io.param)
end (* report_tape_error *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                        report_tape_label_error	                *)
(*                                                                      *)
(************************************************************************)

procedure report_tape_label_error(
      unit	: tape_unit_index;
      label_id	: quoted_text);

begin
  format.start_message('Error on label: \ ');
  format.string(label_id);
  format.write_line(user_terminal);
  report_tape_error(unit)
end (* report_tape_label_error *);



(**************************  archive_commands  **************************)
(*									*)
(*			   report_attach_status				*)
(*									*)
(************************************************************************)

procedure report_attach_status(
      unit	: tape_unit_index;
      param	: tape_param);

begin
  if (param.status = COMPLETE) and (param.count = 20)
  then user_terminal.write_quoted_text_line(WRITE_PROTECTED_MESSAGE)
  else
    if param.status <> COMPLETE
    then
      begin
        if param.status <> INTERVENTION
        then user_terminal.write_quoted_text_line('tape unit attach failed\');
        tape_util.display_tape_error(unit, param)
      end
end (* report_attach_status *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*									*)
(*			  report_already_assigned			*)
(*									*)
(************************************************************************)

procedure report_already_assigned(
      unit	: tape_unit_index);

var
  info : tape_descriptor;
  tape_user : username_string;

begin
  tape_pool.tape_information(unit, info);
  format.start_message('tape unit assigned to \ ');
  login_pool.validator_name(info.assigned_by, tape_user);
  format.username(tape_user);
  format.write_line(user_terminal)
end (* report_already_assigned *);



(**************************  archive_commands  **************************)
(*									*)
(*			  report_assign_failure				*)
(*									*)
(************************************************************************)

procedure report_assign_failure(
      unit	: tape_unit_index;
      status	: tape_assign_status;
      param	: tape_param);

begin
  if status = ALREADY_ASSIGNED
  then report_already_assigned(unit)
  else report_attach_status(unit, param)
end (* report_assign_failure *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  archive_commands  ****************************)
(*									*)
(*			 report_full_on_block				*)
(*									*)
(*      Report tape full at CUD block number				*)
(*									*)
(************************************************************************)

procedure report_full_on_block(
      unit	: tape_unit_index;
      block_no	: cud_block_index;
  var ok	: boolean);

begin
  format.start_line_message('Tape full\');
  format.on_block(block_no); 
  format.write_line(user_terminal);
  tape_io.back_tape(unit, ok)
end (* report_full_on_block *);



(**************************  archive_commands  **************************)
(*									*)
(*			  report_cud_entry_error			*)
(*									*)
(*									*)
(************************************************************************)

procedure report_cud_entry_error(
      status	: cud_entry_result;
      block	: cud_block_index);

begin
  if status <> CUD_ENTRY_OK
  then
    begin
      format.start_and_newline;
      format.cud_entry_status(status);
      format.on_block(block);
      format.write_line(user_terminal)
    end
end (* report_cud_entry_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                        report_tape_file_error	                *)
(*                                                                      *)
(************************************************************************)

procedure report_tape_file_error(
      unit	: tape_unit_index;
      offset    : univ integer);

begin
  format.start_line_message('tape\ ');
  format.string(ERROR_OFFSET_MESSAGE);
  format.number(offset, 10);
  format.write_line(user_terminal);
  report_tape_error(unit)
end (* report_tape_file_error *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           report_cud_error				*)
(*                                                                      *)
(************************************************************************)

procedure report_cud_error(
      result    : cud_operation_result;
      block     : cud_block_index);

begin
  format.start;
  format.cud_block_error(block, result);
  format.write_line(user_terminal)
end (* report_cud_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         report_checksum_error			*)
(*                                                                      *)
(************************************************************************)

procedure report_checksum_error(
      offset     : univ integer);

begin
  format.start_message(CHECKSUM_ERROR);
  format.string(' offset: \');
  format.number(offset, 10);
  format.write_line(user_terminal)
end (* report_checksum_error *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           report_disk_error				*)
(*                                                                      *)
(************************************************************************)

procedure report_disk_error(
      offset	: univ integer);

begin
  format.start_line_message('Disk\ ');
  format.string(ERROR_OFFSET_MESSAGE);
  format.number(offset, 10);
  format.write_line(user_terminal)
end (* report_disk_error *);
!
"
		utility routines
"



(**************************  archive_commands  **************************)
(*									*)
(*			     get_command_unit				*)
(*									*)
(*      Return the legal tape unit requested in the command line;	*)
(*	the validator must not have another unit assigned.		*)
(*									*)
(************************************************************************)

procedure get_command_unit(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var already_assigned	: boolean;
  var old_unit		: tape_unit_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var unit		: tape_unit_index;
  var scanned		: scanned_command);

begin
  freeword_utility.get_numeric_freeword_value(0, 10, 0, TAPE_UNIT_LIMIT,
    scanned, unit);
  if scanned.status = CMD_OK
  then
    if not tape_pool.legal_tape(unit)
    then
      begin (* not a legal tape unit *)
        scanned.status := RUN_ERROR;
	user_terminal.write_quoted_text_line('illegal tape unit\')
      end (* not a legal tape unit *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    else
      begin (* this unit is legal, be sure no other unit is assigned *)
        tape_pool.validator_tape(validator, already_assigned, old_unit);
        if already_assigned and (old_unit <> unit)
        then
          begin
	    scanned.status := RUN_ERROR;
	    format.start_message('tape unit \ ');
	    format.number(old_unit, 10);
	    format.string(' already assigned\');
	    format.write_line(user_terminal)
	  end
      end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* get_command_unit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*									*)
(*			         get_unit				*)
(*									*)
(*      If there is a tape unit included in the command line, pick up	*)
(*	the argument and assign it implicitly; otherwise, return the	*)
(*	unit already assigned to the validator.				*)
(*									*)
(************************************************************************)

procedure get_unit(
  var unit		: tape_unit_index;
  var scanned           : scanned_command;
  var unit_assigned     : boolean (* TRUE if assigned here *));

var
  status : tape_assign_status;
  already_assigned : boolean;
  old_unit : tape_unit_index;
  param : tape_param;

begin
  if scanned.freeword_count > 0
  then
    begin (* validator entered UNIT number *)
      get_command_unit(already_assigned, old_unit, unit, scanned);
      if scanned.status = CMD_OK
      then
        begin
          tape_pool.assign_unit(unit, validator, status, param);
          if status = ASSIGN_OK
          then unit_assigned := not already_assigned or
	    (already_assigned and (unit <> old_unit))
          else
            begin
              report_assign_failure(unit, status, param);
              scanned.status := RUN_ERROR
            end
        end
    end
  else
    begin (* no unit entered, get current unit assigned, if any *)
      tape_pool.validator_tape(validator, already_assigned, old_unit);
      if already_assigned
      then unit := old_unit
      else
        begin
          user_terminal.write_quoted_text_line(NOT_ASSIGNED);
	  scanned.status := RUN_ERROR
	end
    end (* get_current unit assinged, if any *)
end (* get_unit *);



(**************************  archive commands  **************************)
(*									*)
(*			      get_cud_locked				*)
(*									*)
(*      Return cud_locked TRUE is able to lock CUD			*)
(*									*)
(************************************************************************)

procedure get_cud_locked(
  var cud_locked	: boolean);

var
  status : cud_access_status;  

begin
  cud_locked := FALSE;
  repeat
    cud_access.lock_cud_file(status) (* for read-only access *);
    if status = CUD_ACCESS_OK
    then cud_locked := TRUE
    else
      begin (* status <> CUD_ACCESS_OK *)
        user_terminal.write_quoted_text_line(CUD_FILE_BUSY);
	wait
      end (* status <> CUD_ACCESS_OK *)
  until not user_terminal.sendable or cud_locked
end (* get_cud_locked *);



(**************************  archive_commands  **************************)
(*									*)
(*			      output_storing				*)
(*									*)
(*	Output to user_terminal, file is being stored output filename   *)
(*	passed and file message passed.					*)
(*									*)
(************************************************************************)

procedure output_storing(
      file	: archive_file_index;
      file_msg	: quoted_text);

begin
  format.start_message(STORING_MESSAGE);
  format.file_name(file);
  format.string(file_msg);
  format.colon_space;
  user_terminal.write_format_buffer(format.buffer)  
end (* output_storing *);



(**************************  archive_commands  **************************)
(*									*)
(*			     rewind_tape				*)
(*									*)
(************************************************************************)

procedure rewind_tape(
      display_message	: boolean;
      unit		: tape_unit_index;
  var ok		: boolean);

var
  disk_tape_info : disk_tape_information;

begin
  if display_message
  then user_terminal.write_quoted_text_line('tape rewinding\ ');
  tape_io.position_drive(unit, TAPE_REWIND);
  repeat (* wait for completion of rewind *)
    tape_io.drive_status(unit, disk_tape_info);
    wait;
    user_terminal.check_circuit
  until not user_terminal.sendable or (tape_io.param.status <> COMPLETE) or
    ((disk_tape_info.device_status div 2) mod 2 = 1) (* BOT *);
  ok := tape_io.param.status = COMPLETE;
  if not ok
  then tape_util.display_tape_error(unit, tape_io.param)
end (* rewind_tape *);

!
"
		general label character manipulation routines
"



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           label_chars_match				*)
(*                                                                      *)
(*	Return TRUE if the characters in the label match the		*)
(*	given quoted_text.						*)
(*                                                                      *)
(************************************************************************)

function label_chars_match(
      text_to_check	: quoted_text;
      label		: ansii_tape_label;
      first_label_char	: ansii_tape_label_index;
      chars_to_check	: ansii_tape_label_size) : boolean;

var
  label_index : ansii_tape_label_index;

begin
  label_chars_match := TRUE;
  for label_index := first_label_char to (first_label_char+chars_to_check-1) do
    if label[label_index] <> text_to_check[label_index - first_label_char]
    then label_chars_match := FALSE
end (* label_chars_match *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                              read_label				*)
(*                                                                      *)
(*	Read the label from the tape and be sure it is the		*)
(*	kind expected.							*)
(*                                                                      *)
(************************************************************************)

procedure read_label(
      unit		: tape_unit_index;
      print_label_error	: boolean;
      label_id		: quoted_text;
  var label		: ansii_tape_label;
  var ok        	: boolean);

begin
  tape_io.read_label(unit, label, ok);
  if ok
  then
    begin
      ok := label_chars_match(label_id, label, LABEL_ID_OFFSET, LABEL_ID_SIZE);
      if not ok and print_label_error
      then
        begin
	  format.start_message('label missing from tape: \');
	  format.string(label_id);
	  format.write_line(user_terminal)
	end (* not ok and print_label_error *)
    end (* ok *)
  else (* not ok *)
    if print_label_error
    then report_tape_label_error(unit, label_id)
end (* read_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           read_volume_label                          *)
(*                                                                      *)
(************************************************************************)

procedure read_volume_label(
      unit		: tape_unit_index;
      print_label_error	: boolean;
  var label		: ansii_tape_label;
  var ok        	: boolean);

begin
  read_label(unit, print_label_error, VOL1_ID, label, ok);
  if ok
  then
    if not label_chars_match(LABEL_OWNER_ID, label, VOL1_OWNER_OFFSET,
      VOL1_OWNER_SIZE)
    then
      begin
        ok := FALSE;
	if print_label_error
	then user_terminal.write_quoted_text_line('mta is not a NETVAL tape\ ')
      end
end (* read_volume_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          display_label_date				*)
(*                                                                      *)
(************************************************************************)

procedure display_label_date(
      label	: ansii_tape_label);

begin
  format.ansii_tape_label_chars(label, VOL1_DATE_MONTH_OFFSET, 2);
  format.character(ASCII_SLASH);
  format.ansii_tape_label_chars(label, VOL1_DATE_DAY_OFFSET, 2);
  format.character(ASCII_SLASH);
  format.ansii_tape_label_chars(label, VOL1_DATE_YEAR_OFFSET, 2);
  format.write_line(user_terminal)
end (* display_label_date *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         display_volume_label                         *)
(*                                                                      *)
(************************************************************************)

procedure display_volume_label(
      unit	: tape_unit_index;
  var label	: ansii_tape_label;
  var ok        : boolean);

begin
  read_volume_label(unit, TRUE, label, ok);
  if ok
  then
    begin
      format.start_message('NETVAL tape (Version \');
      format.ansii_tape_label_chars(label, VOL1_VERSION_OFFSET,
        VOL1_VERSION_SIZE);
      format.string(') created on: \ ');
      display_label_date(label)
    end
end (* display_volume_label *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          copy_label_chars				*)
(*                                                                      *)
(************************************************************************)

procedure copy_label_chars(
      first_buffer_char	: format_buffer_text_index;
      first_label_char	: ansii_tape_label_index;
      copy_count	: ansii_tape_label_size;
  var label		: ansii_tape_label);

var
  buffer_ptr : format_buffer_text_index;

begin
  for buffer_ptr := first_buffer_char to (first_buffer_char+copy_count-1) do
    label[first_label_char + buffer_ptr - first_buffer_char] :=
      format.buffer.text[buffer_ptr]
end (* copy_label_chars *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          store_label_string				*)
(*                                                                      *)
(************************************************************************)

procedure store_label_string(
      label_id	: quoted_text;
      offset	: ansii_tape_label_index;
      size	: ansii_tape_label_size;
  var label	: ansii_tape_label);

begin
  format.start_message(label_id);
  copy_label_chars(0, offset, size, label)
end (* store_label_string *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                             init_label				*)
(*                                                                      *)
(************************************************************************)

procedure init_label(
      label_id	: quoted_text;
  var label	: ansii_tape_label);

var
  label_index : ansii_tape_label_index;

begin
  for label_index := 0 to ANSII_TAPE_LABEL_LIMIT do
    label[label_index] := ASCII_SPACE;

  store_label_string(label_id, LABEL_ID_OFFSET, LABEL_ID_SIZE, label)
end (* init_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                             write_label				*)
(*                                                                      *)
(************************************************************************)

procedure write_label(
      unit	: tape_unit_index;
      label_id	: quoted_text;
  var label	: ansii_tape_label;
  var ok	: boolean);

begin
  tape_io.write_label(unit, label, ok);
  if not ok
  then report_tape_label_error(unit, label_id)
end (* write_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          store_label_number				*)
(*                                                                      *)
(************************************************************************)

procedure store_label_number(
      number_to_store	: univ integer;
      label_offset	: ansii_tape_label_index;
      places_to_store	: ansii_tape_label_size;
  var label		: ansii_tape_label);

begin
  format.start;
  format.format_number(number_to_store, 10, -places_to_store);
  copy_label_chars(0, label_offset, places_to_store, label)
end (* store_label_number *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          write_vol1_label				*)
(*                                                                      *)
(************************************************************************)

procedure write_vol1_label(
      unit	: tape_unit_index;
  var ok	: boolean);

var
  label : ansii_tape_label;

begin
  init_label(VOL1_ID, label);

  format.start;
  format.date(REALTIME) (* make MM/DD/YY string *);
  copy_label_chars(0, VOL1_DATE_MONTH_OFFSET, 2, label);
  copy_label_chars(3, VOL1_DATE_DAY_OFFSET, 2, label);
  copy_label_chars(6, VOL1_DATE_YEAR_OFFSET, 2, label);

  store_label_string(LABEL_OWNER_ID, VOL1_OWNER_OFFSET, VOL1_OWNER_SIZE,
    label);

  format.start;
  if version < 10
  then format.number(0,10);
  format.scaled_number(version*100 + revision, 10, 2) (* make VV.RR string *);
  copy_label_chars(0, VOL1_VERSION_OFFSET, VOL1_VERSION_SIZE, label);

  label[VOL1_STANDARD_LEVEL_OFFSET] := VOL1_STANDARD_LEVEL;

  write_label(unit, VOL1_ID, label, ok)
end (* write_vol1_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           make_hdr1_label				*)
(*                                                                      *)
(*	Set up most of the HDR1 label - also used for the EOF1 label.	*)
(*                                                                      *)
(************************************************************************)

procedure make_hdr1_label(
      file_sequence	: integer;
  var label		: ansii_tape_label);

begin
  copy_label_chars(0, LABEL_FILE_NAME_OFFSET, format.buffer.size, label);

  store_label_string(LABEL_OWNER_ID, LABEL_SET_ID_OFFSET, LABEL_SET_ID_SIZE,
    label);

  store_label_number(LABEL_FILE_SECTION, LABEL_FILE_SECTION_OFFSET,
    LABEL_FILE_SECTION_SIZE, label);

  store_label_number(file_sequence, LABEL_FILE_SEQUENCE_OFFSET,
    LABEL_FILE_SEQUENCE_SIZE, label);

  store_label_number(1, LABEL_GENERATION_NUMBER_OFFSET,
    LABEL_GENERATION_NUMBER_SIZE, label);

  store_label_number(0, LABEL_GENERATION_VERSION_NUMBER_OFFSET,
    LABEL_GENERATION_VERSION_NUMBER_SIZE, label);

  format.start;
  format.ansii_tape_label_date(REALTIME);
  copy_label_chars(0, LABEL_CREATION_DATE_OFFSET, LABEL_DATE_SIZE, label);

  copy_label_chars(0, LABEL_EXPIRATION_DATE_OFFSET, LABEL_DATE_SIZE, label)
end (* make_hdr1_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           write_hdr1_label				*)
(*                                                                      *)
(************************************************************************)

procedure write_hdr1_label(
      unit		: tape_unit_index;
      file		: archive_file_index;
      file_sequence	: integer;
  var ok		: boolean);

var
  label : ansii_tape_label;

begin
  init_label(HDR1_ID, label);
  format.start;
  format.file_name(file) (* put file name in format buffer *);
  make_hdr1_label(file_sequence, label);
  store_label_number(0, LABEL_BLOCK_COUNT_OFFSET, LABEL_BLOCK_COUNT_SIZE,
    label);
  write_label(unit, HDR1_ID, label, ok)
end (* write_hdr1_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          write_hdr2_label				*)
(*                                                                      *)
(************************************************************************)

procedure write_hdr2_label(
      unit		: tape_unit_index;
      block_length	: integer;
      record_length	: integer;
  var ok		: boolean);

var
  label : ansii_tape_label;

begin
  init_label(HDR2_ID, label);

  label[HDR2_FORMAT_OFFSET] := HDR2_FORMAT;

  store_label_number(block_length, HDR2_BLOCK_LENGTH_OFFSET,
    HDR2_BLOCK_LENGTH_SIZE, label);

  store_label_number(record_length, HDR2_RECORD_LENGTH_OFFSET,
    HDR2_RECORD_LENGTH_SIZE, label);

  store_label_number(0, HDR2_BUFFER_OFFSET, HDR2_BUFFER_OFFSET_SIZE, label);

  write_label(unit, HDR2_ID, label, ok)
end (* write_hdr2_label *);



(**************************  archive_commands  **************************)
(*									*)
(*			    write_eof_label				*)
(*									*)
(*  	Write out EOF label to tape				        *)
(*									*)
(************************************************************************)

procedure write_eof_label(
      unit		: tape_unit_index;
      file_sequence	: integer;
      block_count	: integer;
  var label		: ansii_tape_label;
  var ok		: boolean);

begin
  make_hdr1_label(file_sequence, label) (* mostly same as HDR1 *);

  store_label_number(block_count, LABEL_BLOCK_COUNT_OFFSET,
    LABEL_BLOCK_COUNT_SIZE, label);

  write_label(unit, EOF1_ID, label, ok);
  if ok
  then
    begin
      tape_io.position_drive(unit, TAPE_WRITE_EOF);
      format.start;
      format.number(block_count, 10);
      format.string(' records written\ ');
      format.write_line(user_terminal)
    end
end (* write_eof_label *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*									*)
(*				clear_page				*)
(*									*)
(************************************************************************)

procedure clear_page(
  var page_data	: page_record);

begin
  mutil.clear_page(page_data);
  sys_io.page_checksum(PAGE_SIZE, page_data, page_data.checksum)
end (* clear_page *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		DUMP Command
"



(***************************  archive_commands  *************************)
(*									*)
(*			  store_ascii_dump_block  			*)
(*									*)
(*	Used by the DUMP command to output a block of formatted CUD     *)
(*	data.								*)
(*									*)
(************************************************************************)

procedure store_ascii_dump_block(
      unit		: tape_unit_index;
  var ascii_tape_index	: ascii_dump_tape_block_index;
  var count		: integer;
  var ok		: boolean;
  var end_tape		: boolean);

var
  ascii_tape_buffer : ascii_dump_tape_block;

begin
  if not end_tape
  then
    if format.buffer.size > ASCII_DUMP_DATA_SIZE
    then
      begin
        format.skip_to(FORMAT_BUFFER_TEXT_MAX);
        ascii_tape_buffer[ascii_tape_index] := format.buffer.text;
        format.start;
	if ascii_tape_index < ASCII_DUMP_BLOCK_STRING_LIMIT
        then ascii_tape_index := ascii_tape_index + 1
        else
          begin
	    ascii_tape_index := 0;
  	    tape_io.write_ascii_dump_tape_block(unit, ascii_tape_buffer,
       	      ok, end_tape);
  	    if ok
  	    then count := count + 1
	    else report_tape_error(unit)	
	  end
      end
    else format.skip_to(ASCII_DUMP_DATA_SIZE)
end (* store_ascii_dump_block *);



(*************************  archive_commands  ***************************)
(*									*)
(*			    initialize_dump				*)
(*									*)
(*	Clear block_ccount, set file_sequence, output storing dump,     *)
(*	write HDR1, HDR2 and end-of-file mark.				*)
(*									*)
(************************************************************************)

procedure initialize_dump(
      unit		: tape_unit_index;
      file		: archive_file_index;
      block_length	: integer;
      record_length	: integer;
  var block_count	: integer;
  var file_sequence	: integer;
  var ok		: boolean);

var
  label : ansii_tape_label;

begin
  block_count := 0;
  file_sequence := file_sequence + 1;
  output_storing(file, ASCII_DUMP);
  init_label(HDR1_ID, label);
  format.start_message(ASCII_DUMP); 
  make_hdr1_label(file_sequence, label);
  store_label_number(0, LABEL_BLOCK_COUNT_OFFSET, LABEL_BLOCK_COUNT_SIZE,
    label);
  write_label(unit, HDR1_ID, label, ok);
  if ok
  then write_hdr2_label(unit, block_length, record_length, ok);
  if ok
  then tape_io.position_drive(unit, TAPE_WRITE_EOF)
end (* initialize_dump *);



(***************************  archive_commands  *************************)
(*									*)
(*			       complete_dump				*)
(*									*)
(*  	Write ASCII Dump EOF tape label				        *)
(*									*)
(************************************************************************)

procedure complete_dump(
      unit		: tape_unit_index;
      file_sequence	: integer;
      block_count	: integer;
  var ok		: boolean);

var
  label : ansii_tape_label;

begin
  tape_io.position_drive(unit, TAPE_WRITE_EOF);

  init_label(EOF1_ID, label);
  format.start_message(ASCII_DUMP);
  write_eof_label(unit, file_sequence, block_count, label, ok)
end (* complete_dump *);



(**************************  archive_commands  **************************)
(*									*)
(*			     write_ascii_data				*)
(*									*)
(*	Format CUD data to text string. Write full buffer to tape.      *)
(*									*)
(************************************************************************)

procedure write_ascii_data(
      unit		: tape_unit_index;
      cud_entry		: cud_user_entry;
      selected_fields	: designated_fields;
  var user_count	: integer;
  var ascii_tape_index	: ascii_dump_tape_block_index;
  var block_count	: integer;
  var ok		: boolean;
  var end_tape		: boolean);

var
  index : access_entry_index;

begin
  user_count := user_count + 1; 
  format.skip(1);
  format.format_number(user_count, 10, USER_COUNT_SIZE);
  format.skip(1);
  cmd_utility.format_user_data(selected_fields, cud_entry);
  store_ascii_dump_block(unit, ascii_tape_index, block_count, ok, end_tape);
  cmd_utility.format_change_dates(selected_fields, cud_entry);
  with cud_entry do
    begin
      format.format_number(access_profile.count, 10, ACCESS_COUNT_SIZE);
      for index := 0 to (access_profile.count - 1) do
        begin
	  format.skip(1);
	  format.character(ASCII_PROFILE_FLAG);
 	  cmd_utility.write_access_entry_to_tape(index,
	    access_profile.entries[index]);
          store_ascii_dump_block(unit, ascii_tape_index, block_count, ok,
	    end_tape)
        end (* for *)
    end (* with cud_entry *)
end (* write_ascii_data *);



(**************************  archive_commands  **************************)
(*								        *)
(*			     format_cud_tape			        *)
(*								        *)
(*	Read CUD data and convert to ASCII string format	        *)
(*								        *)
(************************************************************************)

procedure format_cud_tape(
      unit	 	: tape_unit_index;
  var block_no  	: cud_block_index;
  var block_count 	: integer;
  var ok		: boolean);

var
  list_block_no : cud_block_index;
  user_count : integer;
  cud_entry : cud_user_entry;
  disk_block : cud_disk_block;
  ascii_tape_index : ascii_dump_tape_block_index;
  selected_fields : designated_fields;
  end_tape :  boolean;

begin
  end_tape := FALSE;
  ascii_tape_index := 0;
  user_count := 0;
  format.start;
  cmd_utility.clear_designated_fields(selected_fields);
  selected_fields[ALL_FIELDS] := TRUE;
  cud_updater.start_cud_list(block_no, disk_block);
  report_cud_entry_error(cud_updater.last_status, block_no);
  repeat
    cud_updater.next_cud_list(disk_block, list_block_no, cud_entry);
    if cud_updater.last_status = CUD_ENTRY_OK
    then 
      begin
	write_ascii_data(unit, cud_entry, selected_fields,
	  user_count, ascii_tape_index, block_count, ok, end_tape);
        if not end_tape and (ascii_tape_index = 0)
	then block_no := list_block_no - 1
      end
    else
      if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
      then report_cud_entry_error(cud_updater.last_status, list_block_no);
    user_terminal.check_circuit
  until (not user_terminal.sendable or end_tape) or
    (cud_updater.last_status = CUD_ENTRY_NOT_FOUND);
  if (list_block_no = CUD_BLOCK_LIMIT) and ((ascii_tape_index > 0) or
    (format.buffer.size > 0))
  then
    repeat
      format.skip_to(FORMAT_BUFFER_TEXT_MAX);
      store_ascii_dump_block(unit, ascii_tape_index, block_count,
	ok, end_tape)
    until ascii_tape_index = 0;
  if end_tape
  then report_full_on_block(unit, block_no, ok)
end (* format_cud_tape *);



(**************************  archive_commands  **************************)
(*									*)
(*				dump_command				*)
(*									*)
(*	Copy CUD to tape in ascii format			        *)
(*									*)
(************************************************************************)

procedure dump_command(
      unit	: tape_unit_index;
  var block_no	: cud_block_index);

var
  file_sequence : integer;
  block_count : integer;
  cud_locked : boolean;
  user : username_string;
  ok : boolean;

begin
  file_sequence := 0;
  get_cud_locked(cud_locked);
  if cud_locked
  then
    begin
      rewind_tape(TRUE, unit, ok);
      if ok
      then write_vol1_label(unit, ok);
      if ok and user_terminal.sendable
      then
        begin
	  login_pool.validator_name(validator, user);
	  format.start_message('ASCII dump begun\ ');
	  format.by_validator(user);
	  oper_messages.report_message(ARCHIVE_OPLOG_MSG);
	  format.newline;
	  initialize_dump(unit, CUD_FILE, ASCII_DUMP_BLOCK_SIZE,
  	    ASCII_DUMP_DATA_SIZE, block_count, file_sequence, ok);
  	  if ok
  	  then format_cud_tape(unit, block_no, block_count, ok);
          if ok
	  then complete_dump(unit, file_sequence, block_count, ok);
          if ok and user_terminal.sendable
	  then
	    begin
	      tape_io.position_drive(unit, TAPE_WRITE_EOF) (* second mark *);
	      format.start_message('ASCII dump completed\ ');
	      oper_messages.report_message(ARCHIVE_OPLOG_MSG);
    	      format.start_line_message('dump completed\ ');
	      format.write_line(user_terminal)
	    end (* ok and sendable *)
	  else
	    begin
              format.start_message('ASCII dump aborted\ ');
	      oper_messages.report_message(ARCHIVE_OPLOG_MSG)
	    end (* not ok or not sendable *);
          rewind_tape(TRUE, unit, ok)
        end (* ok and sendable *);
      cud_access.unlock_cud_file
    end (* cud_locked *)
end (* dump_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		 STORE Command
"



(**************************  archive_commands  **************************)
(*                                                                      *)
(*				store_page				*)
(*                                                                      *)
(*	This routine is only used for single page files (config, list	*)
(*	header, if reuse_uuns is DISABLED, cud_parameter).		*)
(*                                                                      *)
(************************************************************************)

procedure store_page(
      unit		: tape_unit_index;
  var buffer		: univ page;
  var block_count	: integer;
  var ok		: boolean);

begin
  tape_io.write_tape_page(unit, buffer, ok);
  if ok
  then block_count := block_count + 1
  else report_tape_error(unit)
end (* store_page *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*			    store_blocked_page				*)
(*                                                                      *)
(*	This routine is used for blocked page files (oper file and,	*)
(*	if reuse_uuns ENABLED, cud_parameter).				*)
(*                                                                      *)
(************************************************************************)

procedure store_blocked_page(
      unit		: tape_unit_index;
  var buffer		: tape_page_block;
  var block_count	: integer;
  var ok		: boolean);

begin
  tape_io.write_blocked_tape_page(unit, buffer, ok);
  if ok
  then block_count := block_count + 1
  else report_tape_error(unit)
end (* store_blocked_page *);



(**************************  archive_commands  **************************)
(*									*)
(*			  initialize_file_store				*)
(*									*)
(*	Clear block_count, increment file_sequence, output "storing	*)
(*	file message", write HDR1, HDR2 and and end-of-file mark.	*)
(*									*)
(************************************************************************)

procedure initialize_file_store(
      unit		: tape_unit_index;
      file		: archive_file_index;
      file_msg		: quoted_text;
      block_length	: integer;
      record_length	: integer;
  var block_count	: integer (* number of records in file *);
  var file_sequence	: integer (* sequence of file on tape *);
  var ok		: boolean);

begin
  block_count := 0;
  file_sequence := file_sequence + 1 (* increment for file *);
  output_storing(file, file_msg);
  write_hdr1_label(unit, file, file_sequence, ok);
  if ok
  then write_hdr2_label(unit, block_length, record_length, ok);
  if ok
  then tape_io.position_drive(unit, TAPE_WRITE_EOF)
end (* initialize_file_store *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          complete_file_store				*)
(*                                                                      *)
(************************************************************************)

procedure complete_file_store(
      unit		: tape_unit_index;
      file		: archive_file_index;
      file_sequence	: integer;
      block_count	: integer;
  var ok		: boolean);

var
  label : ansii_tape_label;

begin
  tape_io.position_drive(unit, TAPE_WRITE_EOF);

  init_label(EOF1_ID, label);
  format.start;
  format.file_name(file);
  write_eof_label(unit, file_sequence, block_count, label, ok)
end (* complete_file_store *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         store_configuration				*)
(*                                                                      *)
(************************************************************************)

procedure store_configuration(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  buffer : configuration_information;
  status : file_utility_status;
  block_count : integer;

begin
  initialize_file_store(unit, CONFIGURATION_FILE, NULL_STRING,
    PAGE_SIZE, PAGE_SIZE, block_count, file_sequence, ok);
  if ok
  then
    begin
      config_utility.read_file(buffer, status);
      if status = FU_SUCCESS
      then
        begin
          store_page(unit, buffer, block_count, ok);
          if ok
          then complete_file_store(unit, CONFIGURATION_FILE, file_sequence,
            block_count, ok)
	end
      else
        begin
	  ok := FALSE;
	  if status = FU_CHECKSUM_ERROR
	  then report_checksum_error(0)
	  else report_disk_error(0);
          config_utility.report_error_to_oplog(format, oper_messages)
        end
    end
end (* store_configuration *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                            store_cud                                 *)
(*                                                                      *)
(************************************************************************)

procedure store_cud(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  result : cud_operation_result;
  block_no : cud_block_index;
  tape_buffer : tape_cud_block;
  block_count : integer;
  done : boolean;
  tape_index : tape_cud_block_index;
  tape_blk_done : boolean;

begin
  initialize_file_store(unit, CUD_FILE, NULL_STRING, TAPE_CUD_BLOCK_SIZE,
    TAPE_BLOCKING_FACTOR, block_count, file_sequence, ok);
  done := not ok; block_no := 0;
    while not done and user_terminal.sendable do
      begin
        tape_index := 0; tape_blk_done := FALSE;
	repeat
          with tape_buffer[tape_index] do
	    begin
              block_utility.read_cud_block(block_no, result, cud_data);
	      if result <> CUD_OPERATION_OK
	      then
	        begin
		  mutil.clear_block(cud_data.data);
		  sys_io.cud_checksum(MAXIMUM_CUD_DATA, cud_data.data,
		    cud_data.checksum);
		  report_cud_error(result, block_no)
	        end
   	      else
	        begin
	          block := block_no;
		  if tape_index < TAPE_CUD_BLOCK_LIMIT
		  then tape_index := tape_index + 1
		  else tape_blk_done := TRUE
		end;
	      if block_no = CUD_BLOCK_LIMIT
	      then done := TRUE
	      else block_no := block_no + 1;
              user_terminal.check_circuit
	    end (* with *)
	until not user_terminal.sendable or done or tape_blk_done;
(* write the block to tape *)
      if ok
      then
        begin
	  tape_io.write_cud_block(unit, tape_buffer, ok);
	  if not ok
	  then report_tape_file_error(unit, block_no-1)
	  else block_count := block_count + 1
	end
    end (* while *);
  if ok
  then complete_file_store(unit, CUD_FILE, file_sequence, block_count, ok)
end (* store_cud *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           store_parameter				*)
(*                                                                      *)
(************************************************************************)

procedure store_parameter(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  block_count : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    tape_buffer : page_record;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  initialize_file_store(unit, CUD_PARAMETER_FILE, NULL_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   PAGE_SIZE, PAGE_SIZE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block_count, file_sequence, ok);
  if ok
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      param_file.read_header(tape_buffer, ok);
      if ok
      then
        begin
	  store_page(unit, tape_buffer, block_count, ok);
	  if ok
	  then complete_file_store(unit, CUD_PARAMETER_FILE, file_sequence,
	    block_count, ok)
        end
      else format.write_block(user_terminal)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* if ok *)
end (* store_parameter *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           store_list_header				*)
(*                                                                      *)
(************************************************************************)

procedure store_list_header(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  buffer : page_record;
  status : node_host_utility_status;
  block_count : integer;

begin
  initialize_file_store(unit, NODE_HOST_FILE, FILE_HEADER_MESSAGE,
    PAGE_SIZE, PAGE_SIZE, block_count, file_sequence, ok);
  if ok
  then
    begin
      list_io.read_header(buffer, status);
      if status <> NODE_HOST_OK
      then
        begin
	  ok := FALSE;
	  format.write_block(user_terminal)
	end
      else
        begin
	  store_page(unit, buffer, block_count, ok);
	  if ok
	  then complete_file_store(unit, NODE_HOST_FILE, file_sequence,
	    block_count, ok)
	end
    end
end (* store_list_header *);



(**************************  archive_commands  **************************)
(*									*)
(*			        store_lists				*)
(*									*)
(************************************************************************)

procedure store_lists(
      unit		: tape_unit_index;
      host_flag		: boolean;
      file_message	: quoted_text;
  var file_sequence	: integer;
  var ok		: boolean);

var
  tape_buffer : tape_named_list_definition;
  status : node_host_utility_status;
  block_count : integer;
  list_desc : list_descriptor;
  done : boolean;

begin
  initialize_file_store(unit, NODE_HOST_FILE, file_message,
    TAPE_NAMED_LIST_DEFINITION_SIZE, TAPE_NAMED_LIST_DEFINITION_SIZE,
    block_count, file_sequence, ok);
  done := not ok;
  list_allocater.start_list(validator, host_flag);
  while user_terminal.sendable and not done do
    begin
      list_allocater.next_list(validator, tape_buffer.list_ptr, done);
      if not done
      then
        begin
	  status := NODE_HOST_OK;
	  list_desc.list_ptr := tape_buffer.list_ptr;
	  list_desc.host_flag := host_flag;
	  list_io.read_list(list_desc, tape_buffer.named_list, status);
	  if status <> NODE_HOST_OK
	  then
	    begin
	      format.write_block(user_terminal);
	      user_terminal.write_quoted_text_line(
	        'list will not be stored to tape\')
	    end
	  else
	    begin (* status = NODE_HOST_OK *)
	      tape_io.write_named_list(unit, tape_buffer, ok);
	      if ok
	      then block_count := block_count + 1
	      else report_tape_file_error(unit, list_desc.list_ptr);
	      user_terminal.check_circuit
	    end (* status = NODE_HOST_OK *)
        end (* if not done *)
    end (* while *);
  if ok
  then complete_file_store(unit, NODE_HOST_FILE, file_sequence, block_count,
    ok)
end (* store_lists *);



(**************************  archive_commands  **************************)
(*									*)
(*			  store_global_accesses				*)
(*									*)
(************************************************************************)

procedure store_global_accesses(
      unit		: tape_unit_index;
      class_flag	: boolean;
      file_message	: quoted_text;
      first_value	: integer;
      last_value	: integer;
  var file_sequence	: integer;
  var ok		: boolean);

var
  block_count : integer;
  global_value : integer;
  status : node_host_utility_status;
  tape_buffer : tape_global_access_definition;

begin
  initialize_file_store(unit, NODE_HOST_FILE, file_message,
    MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE,
    MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE, block_count, file_sequence,
    ok);
  if ok
  then
    begin
      for global_value := first_value to last_value do
        if list_allocater.global_access_defined(class_flag, global_value)
	then
	  begin
	    status := NODE_HOST_OK;
	    list_io.read_global_access(class_flag, global_value,
	      tape_buffer.global_access, status);
	    if (status = NODE_HOST_BAD_CHECKSUM) or
	      (status = NODE_HOST_IO_ERROR)
	    then format.write_block(user_terminal)
	    else
	      if status = NODE_HOST_OK
	      then
	        begin (* store the global access to tape *)
		  tape_buffer.global_value := global_value;
		  tape_io.write_global_access(unit, tape_buffer, ok);
		  if ok
		  then block_count := block_count + 1
		  else report_tape_file_error(unit, global_value)
		end (* store the global access to tape *)
	  end (* if defined *)
    end (* if ok *);
  if ok
  then complete_file_store(unit, NODE_HOST_FILE, file_sequence, block_count,
    ok)
end (* store_global_accesses *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         store_mud_change_file                        *)
(*                                                                      *)
(************************************************************************)

procedure store_mud_change_file(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  buffer : tape_mudupd_header_definition;
  block_count : integer;

begin
  initialize_file_store(unit, MUD_UPDATE_FILE, NULL_STRING,
    MAXIMUM_TAPE_MUDUPD_HEADER_SIZE, MAXIMUM_TAPE_MUDUPD_HEADER_SIZE,
    block_count, file_sequence, ok);
  if ok
  then
    begin (* no errors possible *)
      mud_change.read_mudupd_header(buffer.mudupd_info);
      sys_io.page_checksum(PAGE_SIZE, buffer.mudupd_info, buffer.checksum);
      tape_io.write_mud_change(unit, buffer, ok)
    end;
  if ok
  then
    begin
      block_count := block_count + 1;
      complete_file_store(unit, MUD_UPDATE_FILE, file_sequence, block_count,
        ok)
    end
end (* store_mud_change_file *);



(**************************  archive_commands  **************************)
(*									*)
(*			    store_operlog_file				*)
(*									*)
(************************************************************************)

procedure store_operlog_file(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  page_no	: oper_log_archive_page_index;
  tape_buffer	: tape_page_block;
  tape_index	: tape_page_block_index;
  tape_blk_done,
  done		: boolean;
  block_count	: integer;

begin
  initialize_file_store(unit, OPERLOG_FILE, NULL_STRING, TAPE_PAGE_BLOCK_SIZE,
    TAPE_PAGE_BLOCKING_FACTOR, block_count, file_sequence, ok);
  done := not ok; page_no := 0;
  while user_terminal.sendable and not done do
    begin
      tape_blk_done := FALSE; tape_index:= 0;
      repeat
        oplog.read_operlog_page(page_no, tape_buffer[tape_index].page_data,
	  ok);
	if not ok
	then
	  begin
	    report_disk_error(page_no);
	    clear_page(tape_buffer[tape_index].page_data)
	  end;
	tape_buffer[tape_index].page_offset := page_no;
	if tape_index = TAPE_PAGE_BLOCK_LIMIT
	then tape_blk_done := TRUE
	else tape_index := tape_index + 1;
	if page_no = OPER_LOG_HEADER_PAGE
	then done := TRUE
	else page_no := page_no + 1;
	user_terminal.check_circuit
      until not user_terminal.sendable or tape_blk_done or done;
      if user_terminal.sendable and ok
      then store_blocked_page(unit, tape_buffer, block_count, ok)
    end (* while *);
  if ok
  then complete_file_store(unit, OPERLOG_FILE, file_sequence, block_count,
    ok)
end (* store_operlog_file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*									*)
(*			      store_command				*)
(*									*)
(************************************************************************)

procedure store_command(
      unit	: tape_unit_index);

var
  cud_locked,
  store_begun,
  ok : boolean;
  file : archive_file_index;
  file_sequence : integer (* sequence of file on tape *);
  user : username_string;

begin
  store_begun := FALSE; file_sequence := 0;
  rewind_tape(TRUE, unit, ok);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if ok
  then write_vol1_label(unit, ok);
  for file := FIRST_ARCHIVE_FILE to LAST_ARCHIVE_FILE do
    if ok and user_terminal.sendable
    then
      case file of
        CONFIGURATION_FILE:
	  begin
	    login_pool.validator_name(validator, user);
	    format.start_message('store begun\');
	    format.by_validator(user);
	    oper_messages.report_message(ARCHIVE_OPLOG_MSG);
	    store_configuration(unit, file_sequence, ok);
	    store_begun := TRUE
	  end (* CONFIGURATION_FILE *);
	CUD_FILE:
	  begin
	    get_cud_locked(cud_locked);
	    if cud_locked
	    then store_cud(unit, file_sequence, ok)
	  end (* CUD_FILE *);
	CUD_PARAMETER_FILE:
	  begin
	    store_parameter(unit, file_sequence, ok);
	    cud_access.unlock_cud_file;
	    cud_locked := FALSE
	  end (* CUD_PARAMETER_FILE *);
	CLASS_GROUP_FILE: (* null - do not store *);
	OPERLOG_FILE: store_operlog_file(unit, file_sequence, ok);
	NODE_HOST_FILE:
	  begin
	    store_list_header(unit, file_sequence, ok);
	    if ok
	    then store_lists(unit, TRUE, file_hostlists_message,
	      file_sequence, ok);
	    if ok
	    then store_lists(unit, FALSE, file_nodelists_message,
	      file_sequence, ok);
	    if ok
	    then store_global_accesses(unit, TRUE, file_classes_message,
	      FIRST_CLASS, MAXIMUM_CLASS, file_sequence, ok);
	    if ok
	    then store_global_accesses(unit, FALSE, file_groups_message,
	      FIRST_GROUP, MAXIMUM_GROUP, file_sequence, ok)
	  end (* NODE_HOST_FILE *);
	MUD_UPDATE_FILE: store_mud_change_file(unit, file_sequence, ok)
      end (* case *);
  if cud_locked
  then cud_access.unlock_cud_file;
  if store_begun
  then
    if ok and user_terminal.sendable
    then
      begin
        tape_io.position_drive(unit, TAPE_WRITE_EOF) (* 2nd eof at end *);
	format.start_message('store completed\');
	oper_messages.report_message(ARCHIVE_OPLOG_MSG)
      end (* ok and user_terminal.sendable *)
    else
      begin (* not ok or not user_terminal.sendable *)
        format.start_message('STORE FAILED: aborted\');
	oper_messages.report_message(ARCHIVE_OPLOG_MSG)
      end (* not ok or not user_terminal.sendable *);
  rewind_tape(TRUE, unit, ok)
end (* store_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*									*)
(*			     archive_command				*)
(*									*)
(*	The ARCHIVE command causes this routine to be called from	*)
(*	COMMAND_LEVEL; the validator's context has the ARCHIVE_CLASS	*)
(*	added to it, COMMAND_LOOP is called to retrieve archive		*)
(*	commands which are executed here.				*)
(*									*)
(************************************************************************)

procedure entry ARCHIVE_COMMAND(
  var scanned	: scanned_command);

var
  ok : boolean;
  param : tape_param;
  info : tape_descriptor;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  already_assigned : boolean;
  displayed : boolean;
  status : tape_assign_status;
  old_unit : tape_unit_index;
  block_no : cud_block_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  unit : tape_unit_index;
  unit_implicitly_assigned : boolean;
  label : ansii_tape_label;

begin
  command_read.add_class(ARCHIVE_CLASS);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 tape_util.display_status(displayed);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  repeat
    unit_implicitly_assigned := FALSE;
    command_read.get_command(scanned);
    if user_terminal.available
    then
      begin
        user_terminal.write_newline;
	case scanned.command of

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          ARCHIVE_ASSIGN:
	    begin
	      get_command_unit(already_assigned, old_unit, unit, scanned);
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
                begin
                  tape_pool.assign_unit(unit, validator, status, param);
                  if status = ASSIGN_OK
                  then
                    begin
                      user_terminal.write_quoted_text_line(
                        'tape unit assigned\ ');
                      report_attach_status(unit, param)
                    end
                  else report_assign_failure(unit, status, param)
                end
	    end (* ARCHIVE_ASSIGN *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  ARCHIVE_ATTACH:
	    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      get_command_unit(already_assigned, old_unit, unit, scanned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
                begin
                  tape_pool.attach_unit(unit, ok, param);
                  if ok
                  then user_terminal.write_quoted_text_line(
                    'tape unit attached\ ');
                  report_attach_status(unit, param)
                end
	    end (* ARCHIVE_ATTACH *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  ARCHIVE_DEASSIGN:
	    begin
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
                begin
                  tape_pool.validator_tape(validator, ok, unit);
                  if ok
                  then tape_util.deassign_tape(unit, TRUE)
                  else user_terminal.write_quoted_text_line(NOT_ASSIGNED)
                end
	    end (* ARCHIVE_DEASSIGN *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  ARCHIVE_DETACH:
	    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      get_command_unit(already_assigned, old_unit, unit, scanned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
                begin
                  tape_pool.tape_information(unit, info);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
                  if info.assigned and (info.assigned_by <> validator)
                  then report_already_assigned(unit)
                  else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
                    if info.attach_state = UNCOMMITTED
                    then user_terminal.write_quoted_text_line(
                      'unit is not attached\ ')
                    else
                      begin
                        tape_pool.detach_unit(unit, validator, param);
                        if (param.status = COMPLETE) or
                          (param.status = INTERVENTION)
                        then user_terminal.write_quoted_text_line(
                          'tape unit detached\ ')
                        else tape_util.display_tape_error(unit, param)
                      end
                end
	    end (* ARCHIVE_DETACH *);

	  ARCHIVE_DISPLAY:
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    case scanned.subcommand of

	      ARCHIVE_DISPLAY_ID_KEYWORD:
	        begin
		  get_unit(unit, scanned, unit_implicitly_assigned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		  argument_scan.extra_argument_check(scanned);
		  if scanned.status = CMD_OK
		  then
		    begin
		      rewind_tape(TRUE, unit, ok);
		      if ok
		      then display_volume_label(unit, label, ok);
		      rewind_tape(TRUE, unit, ok)
		    end
		end (* DISPLAY_ID_COMMAND *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      ARCHIVE_DISPLAY_STATUS_KEYWORD:
	        begin
	          argument_scan.extra_argument_check(scanned);
	          if scanned.status = CMD_OK
	          then
		    begin
		       tape_util.display_status(displayed);
		       if not displayed
		       then user_terminal.write_quoted_text_line(
		         'no tape units are ATTACHED or ASSIGNED\ ')
		    end
		end (* ARCHIVE_DISPLAY_STATUS_KEYWORD *)

	    end (* case *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

	  ARCHIVE_DUMP:
	    begin
	      if argument_scan.check_keyword(ARCHIVE_DUMP_FROM_KEYWORD,
	        scanned)
	      then keyword_util.get_numeric_keyword_value(
	        ARCHIVE_DUMP_FROM_KEYWORD, 10, 0, CUD_BLOCK_LIMIT,
		scanned, block_no)
	      else block_no := 0;
	      if scanned.status = CMD_OK
	      then
		begin
    	          get_unit(unit, scanned, unit_implicitly_assigned);
	          argument_scan.extra_argument_check(scanned);
		  if scanned.status = CMD_OK
		  then dump_command(unit, block_no)
		end
	    end (* ARCHIVE_COMMAND *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  ARCHIVE_RETURN:
	    begin
	      argument_scan.extra_argument_check(scanned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      if scanned.status = CMD_OK
	      then tape_util.display_status(displayed)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    end (* ARCHIVE_RETURN *);

	  ARCHIVE_REWIND:
	    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      get_unit(unit, scanned, unit_implicitly_assigned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
	        begin
		  rewind_tape(TRUE, unit, ok);
		  if ok
		  then user_terminal.write_quoted_text_line('tape rewound\ ')
		end
	    end (* ARCHIVE_REWIND *)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;

	  ARCHIVE_STORE:
	    begin
	      get_unit(unit, scanned, unit_implicitly_assigned);
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then store_command(unit)
	    end (* ARCHIVE_STORE *)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	end (* case *);
	scan_error.display_command_error(scanned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	if unit_implicitly_assigned
	then tape_util.deassign_tape(unit, FALSE)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      end
  until not user_terminal.available or (scanned.command = ARCHIVE_RETURN);
  command_read.remove_class(ARCHIVE_CLASS)
end (* archive_command *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init param_file(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    statistics, file_system, oper_messages,
    sys_io, format)
    , config_utility(dsksys, sys_io)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* archive *);
!
(************************************************************************)
(*									*)
(*	pswcmd.ntv							*)
(*									*)
(*			    password_command_utility			*)
(*									*)
(*	This Class handles the change password command.			*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  password_read							*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	17Jan85 - jrn							*)
(*	19Jun84 - jrn							*)
(*	      - add cud_entry_utility, and call print_cud_entry_message	*)
(*		after changing the password				*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type PASSWORD_COMMAND_UTILITY = class(
	mutil		: misc_utility;
	user_terminal	: circuit_handler;
	format		: internal_to_string;
	password_read	: password_reader;
	cud_updater	: cud_entry_updater;
	cud_utility	: cud_updater_utility);
!



(*********************  password_command_utility  ***********************)
(*									*)
(*			  change_user_password				*)
(*									*)
(************************************************************************)

procedure entry CHANGE_USER_PASSWORD(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      options		: user_options;
      old_cipher	: integer);

var
  new_cipher : integer;

begin
  if NO_PASSWORD in options
  then
    begin
      user_terminal.write_quoted_text_line(
'user has the NO PASSWORD option and cannot have his password changed\ ');
	cud_updater.abort_cud_change
    end
  else
    begin 	(* password can be changed *)
      password_read.get_new_cipher(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	old_cipher, new_cipher);
      if user_terminal.sendable
      then
        begin
	  cud_updater.update_cud_password(new_cipher);
	  cud_utility.print_cud_entry_message
	end
      else cud_updater.abort_cud_change
    end
end (* change_user_password *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* password_command_utility *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	pswlvl.ntv							*)
(*									*)
(*			    password_command_level			*)
(*									*)
(*	This process is the main process that accepts password-		*)
(*	only validator logins and proccesses a change password.		*)
(*	There is one for each possible password-only validator		*)
(*	in the system.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  validator_index, terminal_unit_index,	command_table,		*)
(*	  operator_log,							*)
(*	  argument_scanner, scanned_command,				*)
(*	  terminal_input_scanner, operator_messages, ioresult		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	09Jan87 - neh							*)
(*	      - add VALIDATOR_OPLOG_MSG to calls to report_login and	*)
(*		report_logout						*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	04Oct84 neg							*)
(*	      - change cud_entry_utility to cud_updater_utility		*)
(*	15Jun84 jrn							*)
(*	      - added cud_utility to init of password_command		*)
(*	      - removed oper_messages from initialization of		*)
(*		cud_block_updater					*)
(*	Version 2.02	April 14, 1984 - jrn				*)
(*	      - remove "? " from question prompts			*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type PASSWORD_COMMAND_LEVEL = process(
	validator	: validator_index;
	login_pool	: login_distributer;
	commands	: command_table;
	statistics	: statistics_gatherer;
	oplog	 	: operator_log;
	mud_change	: mud_change_handler;
	cud_access	: cud_access_controller;
	param_manager	: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	name_access	: cud_name_controller);


var
  mutil			: misc_utility;
  calendar		: date_time_converter;
  profile		: validator_profile;
  format		: internal_to_string;
  user_terminal		: circuit_handler;

  cud			: disk_system;
  block_utility		: cud_block_utility;
  block_updater		: cud_block_updater;
  cud_entry_util	: cud_entry_utility;
  cud_updater		: cud_entry_updater;
  cud_utility		: cud_updater_utility;
  password_read		: password_reader;
  password_command	: password_command_utility;

  argument_scan		: argument_scanner;
  keyword_util		: keyword_utility;
  input_scanner		: terminal_input_scanner;
  keyword_scan		: keyword_scanner;
  oper_messages		: operator_messages;
!



(************************  password_command_level  **********************)
(*									*)
(*				 login					*)
(*									*)
(************************************************************************)

procedure login;

var
  terminal_unit : terminal_unit_index;

begin
  login_pool.wait_for_login(profile, terminal_unit);
  user_terminal.use_circuit(terminal_unit, TERMINAL,
    [COMPLETE, BREAK_KEY, ORANGE_BALL]);
  user_terminal.set_alternate_break(ESCAPE);
  user_terminal.set_timeout(TERMINAL_TIMEOUT * 60);

  format.start;
  format.welcome_message(NETVAL_WELCOME_MESSAGE);
  format.write_line(user_terminal);
  oper_messages.report_login(VALIDATOR_OPLOG_MSG, profile)
end (* login *);




(************************  password_command_level  **********************)
(*									*)
(*			 process_password_change			*)
(*									*)
(*	This is the main processing routine.  				*)
(*									*)
(************************************************************************)

procedure process_password_change;

var
  options : user_options;
  old_cipher,
  password_date : integer;

begin
  cud_updater.modify_cud_password(profile.name, password_date, old_cipher,
    options);
  cud_utility.print_cud_entry_error;
  if cud_updater.last_status = CUD_ENTRY_OK
  then
    begin
      format.start_line_message('password last changed on \');
      format.date(calendar.password_date(password_date));
      format.character(ASCII_COMMA);
      format.newline;
      format.write_line(user_terminal);
      if not keyword_scan.input_answer('do you wish to change your password\')
      then cud_updater.abort_cud_change
      else
        begin
	  user_terminal.write_newline;
	  password_command.change_user_password(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    options, old_cipher)
	end (* not input_answer *)
    end (* cud_updater.last_status = CUD_ENTRY_OK *)
end (* process_password_change *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init calendar, mutil, profile(validator), user_terminal(mutil), format,
    argument_scan(mutil),
    keyword_util(profile, format, user_terminal, commands, argument_scan),
    input_scanner(profile, mutil, format, user_terminal, commands,
      argument_scan, keyword_util),
    keyword_scan(user_terminal, input_scanner),
    oper_messages(oplog, format),
    cud(statistics),
    block_utility(mutil, oper_messages, format, cud),
    block_updater(mutil, statistics, cud, cud_access, block_utility, format),
    cud_entry_util(mutil, format, oper_messages),
    cud_updater(validator, mutil, format, login_pool, mud_change,
      oper_messages,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_entry_util, cud_access, block_updater, param_manager, name_access),
    cud_utility(format, cud_updater, user_terminal),
    password_read(mutil, format, user_terminal),
    password_command(mutil, user_terminal, format, password_read,
      cud_updater, cud_utility);


  cycle
    login;
    process_password_change;
    user_terminal.wait_for_output;
    user_terminal.clear_circuit;
    login_pool.release_unit(user_terminal.unit);
    oper_messages.report_logout(VALIDATOR_OPLOG_MSG, profile,
      user_terminal.logout_reason)
  end (* cycle *)
end (* password_command_level *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	cmdlvl.ntv							*)
(*									*)
(*				command_level				*)
(*									*)
(*	This process is the main process that accepts validator		*)
(*	logins and interprets commands for all validators EXCEPT	*)
(*	password_only validators.  There is one for each possible	*)
(*	licensed validator in the system.				*)
(*									*)
(*	The routines are organized as follows:				*)
(*	  login routine							*)
(*	  Error reporting routines					*)
(*		(report_list_status, report_named_list_value_error)	*)
(*	  Prompt routines						*)
(*		(output_prompt, output_new_prompt)			*)
(*	  Input routines						*)
(*		(get_numbers_list, get_supervisor, get_legal_supervisor,*)
(*		 get_cud_block, get_and_reserve_name, get_username,	*)
(*		 get_and_access_name, get_gan_number,			*)
(*		 get_origin_list, get_origin,				*)
(*		 get_destination, get_access_profile,			*)
(*		 get_options, get_list_description, entries_correct)	*)
(*	  Output Routines						*)
(*	 	(write_named_list, write_list_name_and_descr,		*)
(*		 write_global_access_header, write_global_access, 	*)
(*		 write_single_global_access,				*)
(*		 write_undefined, write_user_entry, write_cud_entry)	*)
(*	  sort_list Routine						*)
(*	  Miscellaneous Programmer routines (CUD/MUD buffer handling)	*)
(*	  CHANGE Commands						*)
(*		(ACCESS, CONTROL, CUD, DISTRICT, GAN, GLOBAL (Class or	*)
(*		 Group), LIST (Node or Host), NAME, PASSWORD)		*)
(*	  COMPARE Command						*)
(*	  CONSISTENCY Command						*)
(*	  DELETE Commands						*)
(*		(ACCESS, LIST (Node or Host), USER)			*)
(*	  DISPLAY Commands						*)
(*		(GLOBAL (Class or Group), SELECT, DIRECTORY, LIST (Node	*)
(*		 or Host), UPDATES, USER, CUD, MUD)			*)
(*	  GET Command							*)
(*	  NEW Commands (ACCESS, HOSTLIST, NODELIST, USER)		*)
(*	  READ Commands (CUD, MUD, TABLE)				*)
(*	  SEND Command							*)
(*	  SET Commands (SCHEDULE, SUPERVISOR)				*)
(*	  STOP Command							*)
(*	  WRITE Commands (CUD, MUD)					*)
(*	  QUIT Command							*)
(*	  UNLOCK Command						*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  validator_index, terminal_unit_index, command_table,		*)
(*	  operator_log, filter_utility, command_level_utility           *)
(*	  argument_scanner, scanned_command,				*)
(*	  terminal_input_scanner, operator_messages,			*)
(*	  needle_record, ioresult, pseudo_sup_index, real_sup_index	*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	09Jan87 - neh							*)
(*	      - add mutil to init filter_utility			*)
(*	09Sep86 - neh							*) 
(*	      - Add DISPLAY_FILTER, FILTER and MESSAGE commands.	*)
(*            - Add filter_utility variable.                            *)
(*            - Remove operator_log from init command_loop parameters.  *)
(*	28Aug86 - jrn							*)
(*	      - mark all Tymshare "old" password code with:		*)
		(*******...  old password code  ...*******)
(*	14Aug86 - jrn							*)
(*	      - add DELETE CLASS, DELETE GROUP for clearing classes	*)
(*		and groups after a configuration change			*)
(*	04Aug86 - rsb							*)
(*		- in RUN_CONSISTENCY and STOP_COMMAND use 	        *)
(*		  un2_activity instead of checking for start_date = 0	*)
(*	08Jul86 - jrn							*)
(*	      - add REMARK command					*)
(*	      - add SPECIAL flag (CLEAN and OLDPASS commands)		*)
(*	13May86 - neh							*)
(*	      - Move all procedures used to display the CUD to		*)
(*		command_level_utility including the following		*)
(*		  clear_criteria in login				*)
(*		  Input Routines					*)
(*		    (get_radix_criteria_values)				*)
(*		  Output Routines					*)
(*    	 	    (check_line_length_and_write,			*)
(*		     format_origins,					*)
(* 		     write_access_profile)		 		*)
(*	  	  Miscellaneous Programmer routines (CUD/MUD handling)	*)
(*		  Command Routines					*)
(*		    (CHANGE CUD, DISPLAY_SELECT, DISPLAY_BLOCK,		*)
(*		     DISPLAY_DIRECTORY, READ CUD/MUD, SELECT,		*)
(*		     WRITE CUD/MUD)					*)
(*	15Apr86 - jrn							*)
(*	      - change DISPLAY NEXT to DISPLAY PARAMETERS		*)
(*	14Apr86 - rsb							*)
(*		- PRIMARY_READ_TABLE_KEYWORD,				*)
(*		  DISPLAY_TABLE,					*)
(*		  READ_NETVAL_TABLE,					*)
(*		  READ_SUPERVISOR_TABLE - modify to allow display of a  *)
(*		  single class or group.				*)
(*	10Mar86 - jrn							*)
(*	      - redo reuse_uuns to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - add the displaying of available add back slots to	*)
(*		the DISPLAY NEXT command				*)
(*	03Mar86 - rsb							*)
(*		- declare user_terminal.set_crt_terminal		*)
(*	18Feb86 - rsb							*)
(*		- PRIMARY_READ_MUD_KEYWORD				*)
(*		  PRIMARY_READ_TABLE_KEYWORD				*)
(*		  PRIMARY_WRITE:  change call to get_supervisor		*)
(*		  into a call to get_LEGAL_supervisor			*)
(*	11feb86 - rsb							*)
(*		- Get_supervisor: change MAXIMUM_EXPECTED_SUPERVISORS	*)
(*		  to MAXIMUM_REAL_SUPERVISOR 				*)
(*	04Feb86	- rsb							*)
(*		- add crash_utility for Set_Supervisor command		*)
(*	03Feb86	- rsb							*)
(*		- set_schedule						*)
(*		  scan.primary_clear:					*)
(*		  - remove "sucess" variable because of 		*)
(*		  creation of mud_change.write_header_to_disc		*)
(*	27Jan86 - jrn							*)
(*	      - change NULL_PROMPT to NULL_STRING			*)
(*	23Jan86	- rsb							*)
(*		- Set_Supervisor: remove check for disc_write_error	*)
(*		  because write_muf_header will not return if error	*)
(*	      - change the UP and SHUT commands to HOST UP and HOST	*)
(*		SHUT, and add the HOST STATUS command			*)
(*	      - use internal_to_string BY_VALIDATOR procedure		*)
(*	14Jan85 -  jrn							*)
(*	      - add username to operator log report_logout message	*)
(*	      - change DISPLAY LVOL to DISPLAY VOLUME			*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	03Jan86 - rsb							*)
(*		- every "sup : supervisor_index" becomes		*)
(*		        "real_sup : real_supervisor_index;"		*)
(*		- every "sup" becomes "real_sup"			*)
(*	20Dec85 - jrn							*)
(*	      - add the FROM SUPERVISOR keywords to the WRITE CUD	*)
(*		command							*)
(*	13Nov84 - jrn							*)
(*	      - use cud_entry_udpater CHECK_FOR_NAME_IN_CUD procedure	*)
(*		instead of the old VALID_CUD_NAME function		*)
(*	01Nov85 - jrn							*)
(*	      - add the REPEAT keyword to the DISPLAY UPDATES command	*)
(*	      - add the SHUT and UP commands				*)
(*	      - send a message to the Supervisor err log whenever a	*)
(*		Supervisor is turned ON or OFF				*)
(*	29Oct85 - jrn							*)
(*	      - change SEND procedure to save status in current_status	*)
(*		so that multiple changes to the monitor do not have to	*)
(*		be made							*)
(*	      - change NEW USER AS command, so that it blocks account	*)
(*		supervisor users from validating new users with class 0	*)
(*		or group 0 if CLASS_0_GROUP_0_ASSIGNABLE is FALSE	*)
(*	07Oct85 - jrn							*)
(*	      - add the VALIDATE_X25_NAMES code				*)
(*	06Aug85 - jrn							*)
(*	      - make programmer enter password on the WRITE commands	*)
(*	12Dec84 - Version 3.00 - neb - pgl - jrn			*)
(*	      - use CUBS for Tymshare CUD format password dates		*)
(*	      - change call to new_cud_entry and add conditional	*)
(*		assembly parameter reuse_uuns				*)
(*	      - add conditional assembly parameter LOGICAL_VOLUMES	*)
(*	      - procedure write_cud_entry handles 			*)
(*		GFD_ONLY_PASSWORD_DATE, if TYMSHARE_CUD_FORMAT		*)
(*		is enabled						*)
(*	      - use engine checksum for disk				*)
(*	      - handle sorted flag better for list modification		*)
(*	      - allow username, class and listname to be entered on	*)
(*		command line whenever possible				*)
(*	      - add descriptions to lists				*)
(*	      - handle new format node-host file			*)
(*	25Mar85 - jrn - version 2.04					*)
(*	      - add allow_hosts_on_no_pasword flag			*)
(*	11Mar85 - jrn - version 2.03					*)
(*	      - fixed a bug that caused the wrong block number to be	*)
(*		displayed to the validator when an error is		*)
(*		detected in the CUD					*)
(*	      - change the format of error message in DISPLAY DIRECTORY	*)
(*		when a checksum or CUD format error occurs		*)
(*	      - fix leading comma in write_table_classes		*)
(*	      - allow READ CUD to retain the data in its buffer if it	*)
(*		encounters a checksum error on the disk			*)
(*	      - do not allow the CHANGE DISTRICT command if		*)
(*		INCLUDE_DISTRICT is FALSE (CMDLVL.NTV)			*)
(*	01Aug84 - pgl							*)
(*	      - fix leading comma in write_table_classes and 		*)
(*		write_table_groups					*)
(*	      - fix lack of comma before carriage return in		*)
(*		check_line_length_and_write				*)
(*	25Jul84 - jrn							*)
(*	      - fix bug in breaking out of change access command	*)
(*	28Jun84 Version 2.02	jrn					*)
(*	      - add PROGRAMMER_PASSWORD_CHANGEABLE			*)
(*	      - added restart capability to consistency			*)
(*	      - added cud_utility to password_command			*)
(*	      - removed oper_messages from initialization of		*)
(*		cud_block_updater					*)
(*	      - added option to assign UUNs if UUNSassignable is TRUE,	*)
(*		including adding CHANGE UUN command			*)
(*	      - added licenses, AUDITOR_LICENSE, OPERATOR_LICENSE	*)
(*		and DISPLAY_CUD_LICENSE					*)
(*	      - remove "? " from question prompts			*)
(*	      - change display_gan_or_all to continue on a CUD error	*)
(*	01May84	Version 2.01 - jrn					*)
(*	      - fix bug in NEW USER AS if old user has NO_PASSWORD set	*)
(*	      - remove duplicate code in CHANGE NAME			*)
(*	      - fix NEW ACCESS to check for maximum number of entries	*)
(*	      - fix formatting of nodes and hosts in origin		*)
(*	      - fix bug in not allowing new user to have a null pass-	*)
(*		word							*)
(*	      - fix bug in displaying in-place origin nodes		*)
(*	      - when setting the home bit as a pre-determine value,	*)
(*		report that fact to the validator			*)
(*	      - change the format of DISPLAY UPDATES to type historical	*)
(*		consistency information before current information	*)
(*	      - fixed bug on calling SORT in the NEW NODELIST command	*)
(*	      - report if consistency already running on the CONSISTENCY*)
(*		command							*)
(*	      - on STOP command, if consistency is manual, report that	*)
(*		fact to the validator (manual consistencies cannot be	*)
(*		stopped)						*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*	12Jun84 Version 2.02  pgl					*)
(*	      - deleted DISPLAY_ALL and DISPLAY_GAN commands		*)
(*		and display_gan_or_all and get_gan_number procedures	*)
(*	      - added DISPLAY_SELECT, DISPLAY_DIRECTORY and SELECT	*)
(*		commands						*)
(*	      - added permanent variable, criteria 			*)
(*	      - added FIELDS and DESIGNATED_FIELDS			*)
(*	      - added constants relating to output lengths		*)
(*	      - added NO_PAGINATION and NO_DISTRICT_MESSAGE		*)
(*	29Sep83	Original from cmdlvl.bas - jrn				*)
(*									*)
(************************************************************************)


type COMMAND_LEVEL = process(
      validator	 		: validator_index;
      login_pool		: login_distributer;
      tape_pool			: tape_allocater;
      commands			: command_table;
      statistics		: statistics_gatherer;
      file_system		: file_system_manager;
      oplog	 		: operator_log;
      mud_change		: mud_change_handler;
      cud_access		: cud_access_controller;
      param_manager		: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      name_access		: cud_name_controller;
      list_access		: node_host_list_access;
      list_allocater		: node_host_list_allocater;
      table_access		: class_group_handler;
      un2_access		: un2_access_manager;
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      sysmsg1_access		: sysmsg1_access_manager);


const
  A_HOME_MESSAGE = ' a home\';
  ADD_PROMPT = 'added\';
  CONSISTENCY_DEACTIVATED_MESSAGE = 'consistency deactivated\';
  CONSISTENCY_STOPPED_MESSAGE = 'automatic consistency stopped \ ';
  CONSISTENCY_START_TIME_MESSAGE = 'start time of consistency period: \ ';
  CONSISTENCY_STOP_TIME_MESSAGE = 'stop time of consistency period: \';
  CONSISTENCY_UNSTOPPABLE_MSG = 'consistency is manual and cannot be stopped\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  DELETE_PROMPT = 'deleted\';
  ENTRIES_CORRECT_QUERY = 'all entries correct\';
  EXCEPTION_MESSAGE = '(not) \ ';
  LIST_NOT_FOUND_MESSAGE = 'list not found in \ ';
  LIST_USED_MESSAGE = 'list name is already entered\ ';
  NO_ACCESS_TO_USER = 'you cannot access that username\';
  NO_LEGAL_SUPS_MESSAGE = 'there are no legal supervisors \';
  NO_LISTS_MESSAGE = 'no lists to modify\ ';
  REPLACE_PROMPT = 'replaced\ ';
  SORT_ALL_QUERY = 'do you want the lists sorted\ ';
  SORT_QUERY = 'do you want the list sorted\';
  STARS_MESSAGE = ' *** \';

type
  PROMPT_TYPE = (node_prompt, host_prompt, group_prompt);

type
  CLASS_GROUP_TABLE_DISPLAY_TYPE = (
	entire_table,
	only_one_class,
	only_one_group);



var		(* system type declarations *)
  sys_io		: system_handler;
  mutil			: misc_utility;
  calendar		: date_time_converter;
  profile		: validator_profile;
  format		: internal_to_string;
  user_terminal		: circuit_handler;
  oper_messages		: operator_messages;
  aux_io		: circuit_handler;
  crash_util		: crash_utility;

(* command handlers *)
  argument_scan		: argument_scanner;
  keyword_util		: keyword_utility;
  input_scanner		: terminal_input_scanner;
  freeword_utility	: freeword_response_utility;
  keyword_scan		: keyword_scanner;
  scan_error		: command_error_message;
  command_read		: command_loop;

  dsksys		: disk_system;

(* CUD handlers *)
  block_utility		: cud_block_utility;
  block_updater		: cud_block_updater;
  cud_entry_util	: cud_entry_utility;
  cud_updater		: cud_entry_updater;
  cud_utility		: cud_updater_utility;
  password_read		: password_reader;
  password_command	: password_command_utility;
  un2_util		: un2_utility;
  consistency		: consistency_handler;

(* list handlers (class, group, node and host) *)
  list_io		: node_host_list_io_utility;
  list_utility		: node_host_list_utility;
  sysmsg1_util		: sysmsg1_utility;

(* tape and archive handlers *)
  tape_io		: tape_handler;
  tape_util		: tape_utility;
  archive		: archive_commands;

  filter_util           : filter_utility;
  cmd_utility		: command_level_utility;
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* logical volume handler *)
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

		(* permanent variables *)

  shut_block		: cud_block_index (* block that is locked *);

  block_is_locked	: boolean;

  scanned		: scanned_command;

!


(***************************  command_level  ****************************)
(*									*)
(*			    	login					*)
(*									*)
(************************************************************************)

procedure login;

var
  terminal_unit : terminal_unit_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  remark : oplog_remark_message;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  login_pool.wait_for_login(profile, terminal_unit);
  user_terminal.use_circuit(terminal_unit, TERMINAL,
    [COMPLETE, BREAK_KEY, ORANGE_BALL]);
  user_terminal.set_alternate_break(ESCAPE);
  user_terminal.set_crt_terminal;
  if profile.level <> PROGRAMMER_VALIDATOR
  then user_terminal.set_timeout(TERMINAL_TIMEOUT * 60);
  format.start;
  format.welcome_message(NETVAL_WELCOME_MESSAGE);
  format.write_line(user_terminal);
  oper_messages.report_login(VALIDATOR_OPLOG_MSG, profile);

  filter_util.clear_filter;
  cmd_utility.clear_criteria_and_buffer(ALL_CRITERIA);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  remark.size := 0;
  cud_updater.set_remark(remark)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* login *);
!
"
	Error Reporting Routines
"



(***************************  command_level  ****************************)
(*									*)
(*			   report_list_status      			*)
(*									*)
(************************************************************************)

procedure report_list_status;

begin
  format.start_and_newline;
  format.named_list_status(list_utility.last_status);
  format.write_line(user_terminal)
end (* report_list_status *);



(**************************  command_level  *****************************)
(*									*)
(*		      report_named_list_value_error			*)
(*									*)
(*	If IN_USE is TRUE, error is that list is already used, else it	*)
(*	is not found							*)
(*									*)
(************************************************************************)

procedure report_named_list_value_error(
      in_use	: boolean;
      host_flag	: boolean;
      number	: integer);

begin
  if host_flag
  then
    begin
      format.start_message(HOST_MESSAGE);
      format.character(ASCII_SPACE);
      format.number(number, 10);
    end (* host_flag *)
  else
    begin
      format.start_message(NODE_MESSAGE);
      format.character(ASCII_SPACE);
      format.number(number, 8)
    end (* not host_flag *);
  if in_use
  then format.string(' is already in list\')
  else format.string(' not found in list\ ');
  format.write_line(user_terminal)
end (* report_named_list_value_error *);
!
"
	Prompt Routines
"



(**************************  command_level  *****************************)
(*									*)
(*			output_node_or_host_prompt			*)
(*									*)
(************************************************************************)

procedure output_node_or_host_prompt(
      host_flag		: boolean (* TRUE if "host", else "node" *);
      list_prompt	: boolean (* TRUE if prompting for a list *));

begin
  if host_flag
  then format.string(HOST_MESSAGE)
  else format.string(NODE_MESSAGE);
  if list_prompt
  then format.string(LIST_MESSAGE)
end (* output_node_or_host_prompt *);



(**************************  command_level  *****************************)
(*									*)
(*			     output_prompt				*)
(*									*)
(************************************************************************)

procedure output_prompt(
      host_flag		: boolean (* TRUE if changing hostlists *);
      list_prompt	: boolean (* TRUE if prompting for a list *);
      op_msg		: quoted_text);

begin
  format.start_and_newline;
  output_node_or_host_prompt(host_flag, list_prompt);
  format.string(' to be \');
  format.string(op_msg);
  format.colon_space;
  format.write_block(user_terminal)
end (* output_prompt *);



(**************************  command_level  *****************************)
(*									*)
(*			   output_new_prompt				*)
(*									*)
(************************************************************************)

procedure output_new_prompt(
      host_flag		: boolean (* TRUE if changing hostlists *);
      list_prompt	: boolean (* TRUE if prompting for a list *));

begin
  format.start_message('new \ ');
  output_node_or_host_prompt(host_flag, list_prompt);
  format.colon_space;
  format.write_block(user_terminal)
end (* output_new_prompt *);
!
"
	Input Routines
"



(****************************  command_level  ***************************)
(*									*)
(*			     get_numbers_list				*)
(*									*)
(*	This routine inputs a list of numbers into an array to be used	*)
(*	for various purposes.						*)
(*									*)
(************************************************************************)

procedure get_numbers_list(
      exception		: boolean;
      prompt		: prompt_type;
      max_entries	: general_number_list_size;
      radix		: integer;
      min_value		: integer;
      max_value		: integer;
  var numbers		: general_number_list);

begin
  format.start_line_message('enter list of \ ');
  if exception
  then format.string('exception \ ');
  case prompt of
    HOST_PROMPT:	format.string(HOST_MESSAGE);
    NODE_PROMPT:	format.string(NODE_MESSAGE);
    GROUP_PROMPT:	format.string('group\')
  end (* case *);
  format.string('s: \');
  format.write_block(user_terminal);
  freeword_utility.prompt_number_list(max_entries, radix, min_value,
    max_value, numbers)
end (* get_numbers_list *);



(**************************  command_level  *****************************)
(*									*)
(*			    get_supervisor 				*)
(*									*)
(************************************************************************)

procedure get_supervisor(
      keyword	: command_keyword_index;
  var real_sup  : real_supervisor_index);

var
  temp : integer;

begin
  keyword_util.get_numeric_keyword_value(keyword, 10,
    FIRST_SUPERVISOR + PRINT_SUPERVISOR_OFFSET,
    MAXIMUM_REAL_SUPERVISOR + PRINT_SUPERVISOR_OFFSET, scanned, temp);
  if scanned.status = CMD_OK
  then real_sup := temp - PRINT_SUPERVISOR_OFFSET
end (* get_supervisor *);



(**************************  command_level  *****************************)
(*									*)
(*			 get_legal_supervisor 				*)
(*									*)
(************************************************************************)

procedure get_legal_supervisor(
      keyword  : command_keyword_index;
  var real_sup : real_supervisor_index);

begin
  get_supervisor(keyword, real_sup);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    if not mud_change.legal_supervisor(real_sup)
    then
      begin
	user_terminal.write_quoted_text_line('Supervisor is not legal\');
	scanned.status := RUN_ERROR
    end
end (* get_legal_supervisor *);



(**************************  command_level  *****************************)
(*									*)
(*			   get_cud_block 				*)
(*									*)
(************************************************************************)

procedure get_cud_block(
      keyword		: command_keyword_index;
  var block_number	: cud_block_index);

var
  temp : integer;

begin
  keyword_util.get_numeric_keyword_value(keyword, 10, 0, CUD_BLOCK_LIMIT,
    scanned, temp);
  if scanned.status = CMD_OK
  then block_number := temp
end (* get_cud_block *);



(****************************  command_level  ***************************)
(*									*)
(*			       reserve_name				*)
(*									*)
(************************************************************************)

function reserve_name(
      name	: username_string) : boolean;

begin
  reserve_name := cud_updater.reserve_name(name);
  if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
  then cud_utility.print_cud_entry_error
end (* reserve_name *);



(****************************  command_level  ***************************)
(*									*)
(*			    get_and_reserve_name			*)
(*									*)
(************************************************************************)

procedure get_and_reserve_name(
      name_prompt	: quoted_text;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var name		: username_string;
  var success		: boolean);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  success := FALSE;
  repeat
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    freeword_utility.prompt_username(name_prompt, name);
    if user_terminal.sendable
    then success := reserve_name(name)
  until success or not user_terminal.sendable
end (* get_and_reserve_name *);



(****************************  command_level  ***************************)
(*									*)
(*			       get_username				*)
(*									*)
(*	If there is a freeword username, return it, otherwise, prompt	*)
(*	for a username.  Success is TRUE if no <break> has been entered	*)
(*	and there are no extraneous arguemnts left on the line.		*)
(*									*)
(************************************************************************)

procedure get_username(
  var username	: username_string;
  var success	: boolean);

begin
  freeword_utility.get_username(0, scanned, username);
  argument_scan.extra_argument_check(scanned);
  success := user_terminal.sendable and (scanned.status = CMD_OK)
end (* get_username *);



(****************************  command_level  ***************************)
(*									*)
(*			    modify_user_entry				*)
(*									*)
(************************************************************************)

procedure modify_user_entry(
  var cud_entry		: cud_user_entry);

begin
  cud_updater.modify_cud_entry(cud_entry);
  cud_utility.print_cud_entry_error
end (* modify_user_entry *);



(**************************  command_level  *****************************)
(*									*)
(*			 read_user_entry	    			*)
(*									*)
(************************************************************************)

procedure read_user_entry(
  var cud_entry	: cud_user_entry);

begin
  cud_updater.read_cud_entry(cud_entry);
  cud_utility.print_cud_entry_error
end (* read_user_entry *);


(****************************  command_level  ***************************)
(*									*)
(*			    get_and_access_name				*)
(*									*)
(************************************************************************)

procedure get_and_access_name(
      modify_access	: boolean (* TRUE if name is to be changed *);
  var cud_entry		: cud_user_entry;
  var success		: boolean);

var
  check_programmer_name : username_string;
  first_time,
  needs_newline,
  name_accessable : boolean;

begin
  check_programmer_name.size := PROGRAMMER_NAME_SIZE;
  check_programmer_name.text := PROGRAMMER_NAME;
  first_time := TRUE; needs_newline := scanned.freeword_count = 0;
  repeat
    name_accessable := TRUE;
    get_username(cud_entry.name, success);
    if success
    then
      begin
        if not modify_access
	then read_user_entry(cud_entry)
	else
	  if not PROGRAMMER_ENTRY_CHANGEABLE and
	    mutil.username_match(cud_entry.name, check_programmer_name) and
	    (profile.level <> PROGRAMMER_VALIDATOR)
	  then name_accessable := FALSE
	  else modify_user_entry(cud_entry);
	if name_accessable
	then
	  if cud_updater.last_status <> CUD_ENTRY_OK
	  then success := FALSE
	  else
	    if not profile.access_to_gan(cud_entry.gan, modify_access)
	    then
	      begin
	        name_accessable := FALSE;
		cud_updater.abort_cud_change
	      end (* no access to gan *);
	if not name_accessable
	then
	  begin
	    success := FALSE;
	    user_terminal.write_quoted_text_line(NO_ACCESS_TO_USER)
	  end (* not name_accessable *)
      end (* success *);
    if not success
    then
      begin
        scanned.freeword_count := 0;
	first_time := FALSE
      end (* not success *)
  until not user_terminal.sendable or success;
  if first_time and needs_newline
  then user_terminal.write_newline
end (* get_and_access_name *);



(****************************  command_level  ***************************)
(*									*)
(*			      get_origin_list				*)
(*									*)
(************************************************************************)

procedure get_origin_list(
      host_flag		: boolean;
  var access_entry	: access_entry_description);

var
  numbers : general_number_list;
  numbers_index : general_number_list_index;
  origin_index : in_place_origin_index;

begin
  if host_flag
  then get_numbers_list(access_entry.exception, HOST_PROMPT,
    MAXIMUM_IN_PLACE_ORIGIN - access_entry.origin.size, 10, 1,
      MAXIMUM_ORIGIN_HOST, numbers)
  else get_numbers_list(access_entry.exception, NODE_PROMPT,
    MAXIMUM_IN_PLACE_ORIGIN-access_entry.origin.size, 8, 1, MAXIMUM_NODE,
    numbers);
  if user_terminal.sendable
  then
    begin (* move numbers values to origin *)
      origin_index := access_entry.origin.size;
      for numbers_index := 0 to numbers.size - 1 do
        begin
	  access_entry.origin.list[origin_index].value :=
	   numbers.list[numbers_index];
	  access_entry.origin.list[origin_index].host_flag := host_flag;
	  origin_index := origin_index + 1
	end (* for *);
      access_entry.origin.size := access_entry.origin.size + numbers.size
    end (* move numbers values to origin *)
end (* get_origin_list *);



(****************************  command_level  ***************************)
(*									*)
(*				save_origin				*)
(*									*)
(************************************************************************)

procedure save_origin(
      temp_list	: in_place_origin_entry;
  var index	: in_place_origin_index;
  var origin	: in_place_origin_description);

begin
  origin.list[index] := temp_list;
  index := index + 1
end (* save_origin *);



(****************************  command_level  ***************************)
(*									*)
(*			    add_to_origin_list				*)
(*									*)
(************************************************************************)

procedure add_to_origin_list(
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index;
  var access_entry	: access_entry_description);

begin
  input_scanner.prompt_and_scan_keyword(keyword_choices, keyword);
  if user_terminal.sendable
  then
    if keyword = LINE_HOST_KEYWORD
    then get_origin_list(TRUE, access_entry)
    else
      if keyword = LINE_NODE_KEYWORD
      then get_origin_list(FALSE, access_entry)
end (* add_to_origin_list *);



(****************************  command_level  ***************************)
(*									*)
(*			  minimum_assignable_value			*)
(*									*)
(*	This function returns the minimum value for either Class or	*)
(*	Group that a validator may enter; if CLASS_0_GROUP_0_ASSIGNABLE	*)
(*	is TRUE, minimum_assignable_value is zero; otherwise, if	*)
(*	validator is an account_supervisor, minimum_assignable_value	*)
(*	is 1.								*)
(*									*)
(************************************************************************)

function minimum_assignable_value : integer;

begin
  if not CLASS_0_GROUP_0_ASSIGNABLE and
    (profile.level = ACCOUNT_SUPERVISOR_VALIDATOR)
  then minimum_assignable_value := 1
  else minimum_assignable_value := 0
end (* minimum_assignable_value *);



(****************************  command_level  ***************************)
(*									*)
(*			       get_origin				*)
(*									*)
(************************************************************************)

procedure get_origin(
  var access_entry	: access_entry_description);

var
  keyword : line_keyword_index;
  done : boolean;
  temp_origin : in_place_origin_description;
  temp_index,
  index : in_place_origin_index;

begin
  access_entry.origin.size := 0;
  access_entry.in_place_origin := not keyword_scan.input_answer(
    'is the origin a system defined class\ ');
  if user_terminal.sendable
  then
    if access_entry.in_place_origin
    then
      begin
	access_entry.exception := keyword_scan.input_answer(
	  'is origin an exception list\');
	if user_terminal.sendable
	then

	(* get in-place origins *)
	  begin
	    add_to_origin_list([LINE_NODE_KEYWORD, LINE_HOST_KEYWORD],
	      keyword, access_entry);
	    done := FALSE;
	    while user_terminal.sendable and not done do
	      if access_entry.origin.size = MAXIMUM_IN_PLACE_ORIGIN
	      then done := TRUE
	      else
		begin
		  add_to_origin_list(
[LINE_NODE_KEYWORD, LINE_HOST_KEYWORD, LINE_COMPLETE_KEYWORD],
		    keyword, access_entry);
		  if keyword = LINE_COMPLETE_KEYWORD
		  then done := TRUE
	        end (* while *);

	    (* force origin hosts first *)
	    temp_origin := access_entry.origin;
(* run thru temp_origin, storing first hosts then nodes back in origin *)
	    index := 0;
	    for temp_index := 0 to access_entry.origin.size - 1 do
	      if temp_origin.list[temp_index].host_flag
	      then save_origin(temp_origin.list[temp_index], index,
	        access_entry.origin);
	    for temp_index := 0 to access_entry.origin.size - 1 do
	    if not temp_origin.list[temp_index].host_flag
	    then save_origin(temp_origin.list[temp_index], index,
	      access_entry.origin)
	  end
      end
    else
      begin
	access_entry.exception := FALSE;
	done := FALSE;
	repeat 	(* set the CLASS origin *)
	 freeword_utility.prompt_class(minimum_assignable_value, scanned,
	   access_entry.class_no);
	  if user_terminal.sendable
	  then
	    if list_utility.defined_class(access_entry.class_no)
	    then done := TRUE
	    else user_terminal.write_line_and_quoted_text_line(
	      'class is not defined\ ')
	  else done := TRUE (* terminal not sendable *)
	until done
      end
end (* get_origin *);



(****************************  command_level  ***************************)
(*									*)
(*			   destination_entries_left			*)
(*									*)
(************************************************************************)

function destination_entries_left(
      access_entry	: access_entry_description) : integer;

begin
  destination_entries_left := MAXIMUM_DESTINATION -
    access_entry.destination.size - access_entry.origin.size
end (* destination_entries_left *);



(****************************  command_level  ***************************)
(*									*)
(*			      force_home_value				*)
(*									*)
(************************************************************************)

procedure force_home_value(
      home_value	: boolean;
  var dest_entry	: destination_entry);

begin
  dest_entry.home_flag := home_value;
  format.start;
  if dest_entry.group_flag
  then format.string(GROUP_MESSAGE)
  else
    begin
      format.string(HOST_MESSAGE);
      format.character(ASCII_SPACE);
    end;
  format.number(dest_entry.value, 10);
  format.string(' is\');
  if not home_value
  then format.string(' not\ ');
  format.string(A_HOME_MESSAGE);
  format.write_line(user_terminal)
end (* force_home_value *);



(****************************  command_level  ***************************)
(*									*)
(*			  store_destination_list			*)
(*									*)
(*	Scan the list of destinations for the user.  If user has the	*)
(*	IGNORE_HOST option, do not allow negative groups or group zero,	*)
(*	and force destination to be a HOME; otherwise, ask if each	*)
(*	destination should be a home or not.				*)
(*									*)
(************************************************************************)

procedure store_destination_list(
      options		: user_options;
      group_flag	: boolean;
      numbers		: general_number_list;
  var access_entry	: access_entry_description);

var
  numbers_index : general_number_list_index;
  dest_index : destination_index;
  defined : boolean;
  home_allowed : boolean;
  ok : boolean;

begin
  dest_index := access_entry.destination.size;
  with access_entry.destination do
    for numbers_index := 0 to numbers.size - 1 do
      if user_terminal.sendable
      then
	begin
	  ok := TRUE; home_allowed := TRUE;
	  if group_flag
	  then
(*	Check to be sure the group is legal, and if user has the	*)
(*	IGNORE_HOST option and the group cannot be a home, say the	*)
(*	group is not acceptable.					*)
	    begin
	      format.start_message(GROUP_MESSAGE);
	      format.number(numbers.list[numbers_index], 10);
	      list_utility.defined_group(numbers.list[numbers_index],
		defined, home_allowed);
	      if not defined
	      then
		begin
		  ok := FALSE;
		  format.string(' is not defined\')
		end
	      else
		if (IGNORE_HOST in options) and not home_allowed
		then
		  begin
		    ok := FALSE;
		    format.string(' cannot be used as a destination\ ')
		  end (* (IGNORE_HOST in options) and not home_allowed *);
	      if not ok
	      then format.write_line(user_terminal)
	    end (* group_flag *);

	  if ok
	  then
	    begin
	      list[dest_index].value := numbers.list[numbers_index];
	      list[dest_index].group_flag := group_flag;
	      if IGNORE_HOST in options (* force all homes if IGNORE_HOST *)
	      then force_home_value(TRUE, list[dest_index])
	      else
		if home_allowed
		then (* ask user if destination is a home *)
		  begin
		    format.start_message('is \');
		    if list[dest_index].group_flag
		    then format.string(GROUP_MESSAGE)
		    else
		      begin
		        format.string(HOST_MESSAGE);
			format.character(ASCII_SPACE);
		      end;
		    format.number(list[dest_index].value, 10);
		    format.write_block(user_terminal);
		    list[dest_index].home_flag :=
		      keyword_scan.input_answer(A_HOME_MESSAGE)
		  end
		else force_home_value(FALSE, list[dest_index]);
	      if dest_index < DESTINATION_LIMIT
	      then dest_index := dest_index + 1;
	      size := size + 1
	    end
	end
end (* store_destination_list *);



(****************************  command_level  ***************************)
(*									*)
(*			   add_to_destination_list			*)
(*									*)
(************************************************************************)

procedure add_to_destination_list(
      options		: user_options;
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index;
  var access_entry	: access_entry_description);

var
  numbers : general_number_list;

begin
  input_scanner.prompt_and_scan_keyword(keyword_choices, keyword);
  if user_terminal.sendable
  then
    if keyword = LINE_HOST_KEYWORD
    then
      begin
	get_numbers_list(FALSE, HOST_PROMPT,
	  destination_entries_left(access_entry), 10, 1, MAXIMUM_HOST,
	  numbers);
	if user_terminal.sendable
	then store_destination_list(options, FALSE, numbers, access_entry)
      end
    else
      if keyword = LINE_GROUP_KEYWORD
      then
	begin
	   get_numbers_list(FALSE, GROUP_PROMPT,
	     destination_entries_left(access_entry), 10,
	       minimum_assignable_value, MAXIMUM_GROUP, numbers);
	   if user_terminal.sendable
	   then store_destination_list(options, TRUE, numbers, access_entry)
	end
end (* add_to_destination_list *);



(****************************  command_level  ***************************)
(*									*)
(*			      get_destination				*)
(*									*)
(************************************************************************)

procedure get_destination(
      options		: user_options;
  var access_entry	: access_entry_description);

var
  done : boolean;
  keyword : line_keyword_index;

begin
  user_terminal.write_line_and_quoted_text_line('defining destination,\');
  access_entry.destination.size := 0;
  repeat
    add_to_destination_list(options, [LINE_GROUP_KEYWORD, LINE_HOST_KEYWORD],
      keyword, access_entry)
  until not user_terminal.sendable or (access_entry.destination.size <> 0);
  done := FALSE;
  while user_terminal.sendable and not done do
    if destination_entries_left(access_entry) = 0
    then done := TRUE
    else
      begin
	add_to_destination_list(options,
	  [LINE_GROUP_KEYWORD, LINE_HOST_KEYWORD, LINE_COMPLETE_KEYWORD],
	  keyword, access_entry);
	if keyword = LINE_COMPLETE_KEYWORD
	then done := TRUE
      end (* while *)
end (* get_destination *);



(****************************  command_level  ***************************)
(*									*)
(*			    get_access_profile_entry			*)
(*									*)
(************************************************************************)

procedure get_access_profile_entry(
      index		: access_entry_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      options		: user_options;
  var access_profile	: access_profile_description);

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    get_origin(access_profile.entries[index]);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if user_terminal.sendable
  then get_destination(options, access_profile.entries[index])
end (* get_access_profile_entry *);



(****************************  command_level  ***************************)
(*									*)
(*			     get_access_profile				*)
(*									*)
(************************************************************************)

procedure get_access_profile(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      options		: user_options;
  var access_profile	: access_profile_description);

var
  done : boolean;
  index : access_entry_index;

begin
  done := FALSE; index := access_profile.count;
  repeat
    get_access_profile_entry(access_profile.count,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      options, access_profile);
    if user_terminal.sendable
    then
      begin
        access_profile.count := access_profile.count + 1;
	if access_profile.count = MAXIMUM_ACCESS_ENTRY
	then done := TRUE
	else
	  begin
	    index := index + 1;
	    user_terminal.write_newline;
	    done := not keyword_scan.input_answer('another access entry\ ')
	  end
      end (* user_terminal.sendable *)
  until done or not user_terminal.sendable
end (* get_access_profile *);



(****************************  command_level  ***************************)
(*									*)
(*			       get_options				*)
(*									*)
(************************************************************************)

procedure get_options(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var options	: user_options);

begin
  options := [];
  if keyword_scan.input_answer(SHUT_OVERRIDE_MESSAGE)
  then options := options or [SHUT_OVERRIDE];
  if user_terminal.sendable
  then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if not keyword_scan.input_answer('password required\')
      then options := options or [NO_PASSWORD];
  if user_terminal.sendable
  then
    if keyword_scan.input_answer(TRANSPARENT_LOGIN_MESSAGE)
    then options := options or [TRANSPARENT_LOGIN];
  if user_terminal.sendable
  then
    if (TRANSPARENT_LOGIN in options)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    then
      begin
	user_terminal.write_quoted_text_line(
	  'assigning "IGNORE HOST" option\ ');
	options := options or [IGNORE_HOST]
      end
    else
      if keyword_scan.input_answer(IGNORE_HOST_MESSAGE)
      then options := options or [IGNORE_HOST];
  if user_terminal.sendable
  then
    if not (TRANSPARENT_LOGIN in options) and not (NO_PASSWORD in options) and
      not (IGNORE_HOST in options)
    then
      begin
	if keyword_scan.input_answer(ACCOUNT_SUPERVISOR_MESSAGE)
	then options := options or [ACCOUNT_SUPERVISOR]
	else
	  if profile.level <> ACCOUNT_SUPERVISOR_VALIDATOR
	  then
	    if keyword_scan.input_answer(NETWORK_ADMINISTRATOR_MESSAGE)
	    then options := options or [NETWORK_ADMINISTRATOR];
	if not (NETWORK_ADMINISTRATOR in options) and
	  (profile.level <> ACCOUNT_SUPERVISOR_VALIDATOR)
	then
	  begin
	    if keyword_scan.input_answer(AUDITOR_MESSAGE)
	    then options := options or [AUDITOR];
	    if keyword_scan.input_answer(OPERATOR_MESSAGE)
	    then options := options or [OPERATOR]
	  end
      end
end (* get_options *);



(****************************  command_level  ***************************)
(*									*)
(*			      entries_correct				*)
(*									*)
(************************************************************************)

function entries_correct(
      output_newline	: boolean) : boolean;

begin
  entries_correct := FALSE;
  if output_newline
  then user_terminal.write_newline;
  if user_terminal.sendable
  then entries_correct := keyword_scan.input_answer(ENTRIES_CORRECT_QUERY)
end (* entries_correct *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	Output Routines
"



(***************************  command_level  ****************************)
(*									*)
(*			 write_list_name_and_descr    			*)
(*									*)
(*	write out list name and description				*)
(*									*)
(************************************************************************)

procedure write_list_name_and_descr(
      named_list	: named_list_definition);

begin
  format.start;
  format.listname(named_list.name);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  format.write_line(user_terminal)
end (* write_list_name_and_descr *);



(***************************  command_level  ****************************)
(*									*)
(*			     write_named_list    			*)
(*									*)
(*	Called by nodelist and hostlist subcommand routines; writes out *)
(*	list name, description and host or node numbers.		*)
(*									*)
(************************************************************************)

procedure write_named_list(
      list_to_write	: validator_named_list_definition);

var
  radix : integer;
  finished : boolean;
  start_line : format_buffer_text_index;
  index : named_list_index;

begin
  user_terminal.write_newline;
  write_list_name_and_descr(list_to_write.named_list);
  if list_to_write.host_flag
  then radix := 10
  else radix := 8;
  format.start;
  finished := FALSE;
  start_line := format.buffer.size;
  for index := 0 to list_to_write.named_list.count - 1 do
    begin
      cmd_utility.check_line_length_and_write(MAX_HOST_OUTPUT+4,
	start_line, COMMA_SPACE);
      format.number(list_to_write.named_list.values[index], radix)
    end (* for *);
  format.write_line(user_terminal)
end (* write_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			write_global_access_header			*)
(*									*)
(************************************************************************)

procedure write_global_access_header(
      class_flag	: boolean	(* TRUE if a CLASS header *);
      first_value	: univ integer;
      last_value	: univ integer);

begin
  if class_flag
  then format.start_message(CLASS_MESSAGE)
  else format.start_message(GROUP_MESSAGE);
  format.number(first_value, 10);
  if first_value <> last_value
  then
    begin
      format.string(' - \');
      format.number(last_value, 10)
    end (* first_value <> last_value *);
  format.colon_space;
  format.write_block(user_terminal)
end (* write_global_access_header *);



(*************************  command_level  ******************************)
(*									*)
(*			  write_global_access				*)
(*									*)
(* Writes out global_access header, number and all its named lists.	*)
(*									*)
(************************************************************************)

procedure write_global_access(
      class_flag	: boolean;
      global_access 	: global_access_description;
      global_access_no	: univ integer);

var
  index : global_access_list_entry_index;
  list : validator_named_list_definition;

begin
  write_global_access_header(class_flag, global_access_no, global_access_no);
  user_terminal.write_newline;
  for index := 0 to global_access.count - 1 do
    begin
      if global_access.exception
      then user_terminal.write_quoted_text(EXCEPTION_MESSAGE);
      list_utility.read_next_list(global_access.lists[index], list);
      write_list_name_and_descr(list.named_list)
    end (* for *);
  user_terminal.write_newline;
end (* write_global_access *);



(*************************  command_level  ******************************)
(*									*)
(*			   write_undefined				*)
(*									*)
(* Writes out class header and number range or number and ': undefined' *)
(*									*)
(************************************************************************)

procedure write_undefined(
      class_flag	: boolean;
      last_undefined,
      first_undefined	: univ integer);

begin
  write_global_access_header(class_flag, first_undefined, last_undefined);
  user_terminal.write_quoted_text_line('undefined(:13:)(:10:)\')
end (* write_undefined *);



(*************************  command_level  ******************************)
(*									*)
(*		     write_undefined_or_global_access			*)
(*									*)
(* Writes out global_access or number and ': undefined'.		*)
(*									*)
(************************************************************************)

procedure write_undefined_or_global_access(
      class_flag	: boolean;
      global_access	: global_access_description;
      global_access_no	: univ integer);

begin
  if global_access.count = 0
  then write_undefined(class_flag, global_access_no, global_access_no)
  else write_global_access(class_flag, global_access, global_access_no)
end (* write_undefined_or_global_access *);



(***********************  command_level  ********************************)
(*									*)
(*			 write_cud_entry				*)
(*									*)
(************************************************************************)

procedure write_cud_entry(
      cud_entry : cud_user_entry);

var
  i : cud_control_options;

begin
  if INCLUDE_GAN and (cud_entry.gan <> 0)
  then
    begin
      format.start_message(GAN_PROMPT);
      format.number(cud_entry.gan, 8);
      format.write_line(user_terminal)
    end (* INCLUDE_GAN and (cud_entry.gan <> 0) *);

  if cud_entry.uun <> 0
  then
    begin
      format.start_message(UUN_PROMPT);
      format.number(cud_entry.uun, UUN_RADIX);
      format.write_line(user_terminal)
    end (* cud_entry.uun <> 0 *);

  for i := FIRST_CUD_CONTROL_OPTION_TO_PRINT to
    LAST_CUD_CONTROL_OPTION_TO_PRINT do
    if i in cud_entry.options
    then
      begin
	format.start;
	format.control_option_name(i);
	format.write_line(user_terminal)
      end (* i in cud_entry.options *);

  if INCLUDE_DISTRICT
  then
    begin
      format.start_message('district: \ ');
      format.number(cud_entry.district, 10);
      format.write_line(user_terminal)
    end (* INCLUDE_DISTRICT *);

  if (cud_entry.entry_change_date <> 0)
(*******...  old password code  ...*******)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*******...  old password code  ...*******)
  then
    begin
      format.start_message('entry changed: \');
      format.time(cud_entry.entry_change_date);
      format.write_line(user_terminal)
    end (* output entry change date *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
    if cud_entry.password_change_date <> 0
    then
      begin
        format.start_message('password changed: \ ');
	format.date(calendar.password_date(cud_entry.password_change_date));
	format.write_line(user_terminal)
      end (* output password change date *);
  cmd_utility.write_access_profile(cud_entry.access_profile, FALSE)
end (* write_cud_entry *);
!
"
	Sorting Routines
"



(****************************  command_level  ***************************)
(*									*)
(*			      sort_named_list				*)
(*									*)
(************************************************************************)

procedure sort_named_list(
      ask_about_sort	: boolean;
      sort_flag		: boolean (* if ask_about_sort is FALSE, use this *);
				  (* value to determine sorting *)
  var list_to_sort	: validator_named_list_definition);

var
  temp : integer;
  switch_index,
  scan_index,
  index : named_list_index;
  do_sort : boolean;

begin
  if ((list_to_sort.named_list.count > 1) and not list_to_sort.sorted) and
    ask_about_sort and user_terminal.sendable
  then do_sort := keyword_scan.input_answer(SORT_QUERY)
  else do_sort := sort_flag;
  if do_sort
  then
    for scan_index := 0 to list_to_sort.named_list.count - 2 do
      begin
	switch_index := scan_index;
	for index := scan_index + 1 to list_to_sort.named_list.count - 1 do
	  if list_to_sort.named_list.values[index] <
	    list_to_sort.named_list.values[switch_index]
	  then switch_index := index;
	temp := list_to_sort.named_list.values[scan_index];
	list_to_sort.named_list.values[scan_index] :=
	  list_to_sort.named_list.values[switch_index];
	list_to_sort.named_list.values[switch_index] := temp
      end (* for *)
end (* sort_named_list *);
!
!
"
		CHANGE ACCESS Command
"
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  command_level  *****************************)
(*									*)
(*			  change_user_access 				*)
(*									*)
(************************************************************************)

procedure change_user_access(
  var cud_entry	: cud_user_entry);

begin
  cud_updater.update_profile(cud_entry);
  cud_utility.print_cud_entry_message
end (* change_user_access *);



(**************************  command_level  *****************************)
(*									*)
(*			     change_access 				*)
(*									*)
(************************************************************************)

procedure change_access;

var
  cud_entry : cud_user_entry;
  success : boolean;
  index : access_entry_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  get_and_access_name(TRUE, cud_entry, success);
  if success
  then
    begin
      cmd_utility.write_access_profile(cud_entry.access_profile, FALSE);
      user_terminal.write_newline;
      if cud_entry.access_profile.count = 1
      then index := 0
      else freeword_utility.prompt_access_entry_position(
        'access position to change: \', cud_entry.access_profile.count,
	scanned, index);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if user_terminal.sendable
      then get_access_profile_entry(index,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        cud_entry.options, cud_entry.access_profile);
      user_terminal.write_newline;
      if user_terminal.sendable
      then cmd_utility.write_access_profile(cud_entry.access_profile, FALSE);
      if entries_correct(TRUE)
      then change_user_access(cud_entry)
      else cud_updater.abort_cud_change
    end
end (* change_access *);
!
"
		CHANGE CONTROL Command
"



(**************************  command_level  *****************************)
(*									*)
(*			    change_control				*)
(*									*)
(************************************************************************)

procedure CHANGE_CONTROL;

var
  cud_entry : cud_user_entry;
  password_changed,	(* TRUE if user's password was forced to change  *)
  profile_changed,	(* TRUE if homes in profile changed *)
  command_aborted,	(* TRUE if cmd stopped due to non home destinations *)
  defined,		(* TRUE if group is defined *)
  allowed_to_be_home,	(* TRUE if group is allowed to be home destination *)
  any_non_homed_destinations,
  success : boolean;
  old_password : integer;
  old_options : user_options;
  profile_index : access_entry_index;
  dest_index : destination_index;

begin
  get_and_access_name(TRUE, cud_entry, success);
  if success
  then
    begin
      old_options := cud_entry.options;
      get_options(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        cud_entry.options);
      if NEW_PASSWORD_OPTION in old_options
      then cud_entry.options := cud_entry.options or [NEW_PASSWORD_OPTION];

(*	If the NO_PASSWORD bit is to be different than it was before	*)
(*	the CHANGE CONTROL command information was input, set the new	*)
(*	value for cud_entry.password, i.e., if bit was turned ON, set	*)
(*	password to -1, if bit was turned OFF, prompt for and set the	*)
(*	validator supplied password.					*)

      password_changed := (NO_PASSWORD in old_options) <>
        (NO_PASSWORD in cud_entry.options);
      if user_terminal.sendable and password_changed
      then
        if NO_PASSWORD in cud_entry.options
	then cud_entry.password := -1 (* change from password to NO password *)
	else
	  begin (* change from NO password to password *)
	    old_password := -1;
	    password_read.get_new_cipher(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      old_password, cud_entry.password)
	    end (* change from NO password to password *);

      command_aborted := FALSE;
      if user_terminal.sendable
      then
	begin

(* determine if the user has any destinations that are not homed *)
	  any_non_homed_destinations := FALSE;
	  for profile_index := 0 to cud_entry.access_profile.count - 1 do
	    with cud_entry.access_profile.entries[profile_index] do
	      for dest_index := 0 to destination.size - 1 do
		if not destination.list[dest_index].home_flag
		then any_non_homed_destinations := TRUE;

	  profile_changed := ((IGNORE_HOST in cud_entry.options) or
	    (TRANSPARENT_LOGIN in cud_entry.options) or
	    (NO_PASSWORD in cud_entry.options)) and
	    any_non_homed_destinations;

	  if profile_changed
	  then 	(* set all destinations to homes if possible *)
	    begin
	      user_terminal.write_quoted_text_line(
		'setting all destinations to homes,\ ');
	      if not keyword_scan.input_answer(OKAY_QUERY)
	      then command_aborted := TRUE
	      else
		for profile_index:=0 to cud_entry.access_profile.count - 1 do
		  with cud_entry.access_profile.entries[profile_index] do
		    for dest_index := 0 to destination.size - 1 do
		      with destination.list[dest_index] do
			if not command_aborted
			then
			  begin
			    home_flag := TRUE;

			  (* if destionation is a group, check to be *)
			  (* user it can be a home		     *)
			    if group_flag
			    then
			      begin
				list_utility.defined_group(value, defined,
				  allowed_to_be_home);
				if not allowed_to_be_home
				then
				  begin
				    command_aborted := TRUE;
				    format.start_message('group \ ');
				    format.number(value, 10);
				    format.string(
				      ' cannot be assigned home status\');
				    format.write_line(user_terminal)
				  end (* not allowed_to_be_home *)
			      end (* if group_flag *)
			end (* not command_aborted *);
	      if command_aborted
	      then user_terminal.write_line_and_quoted_text_line(
		'command cancelled\')
	    end (* profile changed *)
	end (* user_terminal.sendable *);
      if command_aborted
      then cud_updater.abort_cud_change
      else
	if not entries_correct(TRUE)
	then cud_updater.abort_cud_change
	else
	  begin (* entries_correct *)
	    cud_updater.update_options(password_changed, profile_changed,
	      cud_entry);
	    cud_utility.print_cud_entry_message
	  end (* entries_correct *)
    end
end (* change_control *);
!
"
		CHANGE DISTRICT Command
"



(**************************  command_level  *****************************)
(*									*)
(*			    change_district 				*)
(*									*)
(************************************************************************)

procedure change_district;

var
  cud_entry : cud_user_entry;
  success : boolean;

begin
  if not INCLUDE_DISTRICT
  then user_terminal.write_quoted_text_line(NO_DISTRICTS_MESSAGE)
  else
    begin
      get_and_access_name(TRUE, cud_entry, success);
      if success
      then
        begin
	  freeword_utility.prompt_district(scanned, cud_entry.district);
	  if user_terminal.sendable
	  then
	    begin
	      cud_updater.update_district(cud_entry.district);
	      cud_utility.print_cud_entry_message
	    end (* user_terminal.sendable *)
	  else cud_updater.abort_cud_change
	end (* success *)
    end (* INCLUDE_DISTRICT *)
end (* change_district *);
!
"
		CHANGE GAN Command
"


(**************************  command_level  *****************************)
(*									*)
(*			      change_gan 				*)
(*									*)
(************************************************************************)

procedure change_gan;

var
  cud_entry : cud_user_entry;
  success : boolean;
  gan_tba : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  uun_tba : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  if not INCLUDE_GAN
  then user_terminal.write_quoted_text_line(NO_GANS_MESSAGE)
  else
    begin
      get_and_access_name(TRUE, cud_entry, success);
      if success
      then
        begin
	  param_manager.next_gan_and_uun(gan_tba,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    uun_tba);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  freeword_utility.prompt_gan(gan_tba - 1, scanned, cud_entry.gan);
	  if not entries_correct(TRUE)
	  then cud_updater.abort_cud_change
	  else
	    begin (* entries_correct *)
	      cud_updater.update_gan(cud_entry.gan);
	      cud_utility.print_cud_entry_message
	    end (* entries_correct *)
	end (* success *)
    end (* INCLUDE_GAN *)
end (* change_gan *);
!
"
		CHANGE GLOBAL (Class or Group) Command
"



(**************************  command_level  *****************************)
(*									*)
(*			  get_and_locate_list				*)
(*									*)
(*	Input a listname and return success as TRUE if it exists.	*)
(*	This routine is used for updating Classes and Groups.		*)
(*									*)
(************************************************************************)

procedure get_and_locate_list(
      host_flag	: boolean;
  var success	: boolean;
  var list_desc	: list_descriptor);

var
  temp_list : named_list_name;

begin
  success := FALSE; list_desc.list_ptr := 0; list_desc.host_flag := host_flag;
  freeword_utility.prompt_listname(NULL_STRING, temp_list);
  if user_terminal.sendable
  then
    begin
      list_utility.find_list(temp_list, list_desc);
      if list_utility.last_status <> NODE_HOST_OK
      then list_utility.report_status(user_terminal, FALSE, list_desc,
        list_utility.last_status)
      else success := TRUE
    end (* sendable *)
end (* get_and_locate_list *);



(**************************  command_level  *****************************)
(*									*)
(*			find_list_in_global_access			*)
(*									*)
(************************************************************************)

procedure find_list_in_global_access(
      global_access	: global_access_description;
      list_to_find	: list_descriptor (* list to find *);
  var success		: boolean;
  var access_index	: global_access_list_entry_index);

var
  done : boolean;

begin
  success := FALSE; done := FALSE;
  access_index := 0;
  if global_access.count > 0
  then
    while not success and not done do
      if global_access.lists[access_index] = list_to_find
      then success := TRUE
      else
        if access_index = global_access.count - 1
	then done := TRUE
	else access_index := access_index + 1
end (* find_list_in_global_access *);



(**************************  command_level  *****************************)
(*									*)
(*			add_entry_to_global_access			*)
(*									*)
(************************************************************************)

procedure add_entry_to_global_access(
      class_flag	: boolean (* TRUE if changing CLASS *);
      host_flag		: boolean (* TRUE if changing hostlists *);
  var global_access	: global_access_description);

var
  list : list_descriptor;
  success : boolean;
  access_index : global_access_list_entry_index;

begin
  if global_access.count = MAXIMUM_LISTS_IN_GLOBAL_ACCESS
  then
    if class_flag
    then user_terminal.write_quoted_text_line('class is full\')
    else user_terminal.write_quoted_text_line('group is full\')
  else
    begin
      output_prompt(host_flag, TRUE, ADD_PROMPT);
      get_and_locate_list(host_flag, success, list);
      if success (* got a legal listname *)
      then
	begin (* check to see if list_ptr is already in class *)
	  find_list_in_global_access(global_access,list,success,access_index);
	  if success
	  then user_terminal.write_quoted_text_line(LIST_USED_MESSAGE)
	  else
	    begin (* list not already in class, add it *)
	      if not class_flag or not host_flag
	      then access_index := global_access.count (* put list at end *)
	      else
	        begin (* EXCEPT, store a HOSTLIST in a CLASS at beginning *)
		  for access_index := global_access.count - 1 downto 0 do
		    global_access.lists[access_index + 1] :=
		      global_access.lists[access_index];
		  access_index := 0 (* put new hostlist in front *)
		end (* store hostlist in class at beginning *);
	      global_access.lists[access_index] := list (* store list *);
	      global_access.count := global_access.count + 1 (* incr. count *)
	    end (* list not already in class *)
	end (* check to see if list_ptr is already in class *)
    end (* global access is not full *)
end (* add_entry_to_global_access *);



(**************************  command_level  *****************************)
(*									*)
(*		    delete_entry_from_global_access			*)
(*									*)
(************************************************************************)

procedure delete_entry_from_global_access(
      class_flag	: boolean (* TRUE if changing class *);
      host_flag		: boolean (* TRUE if changing hostlists *);
  var global_access	: global_access_description);

var
  success : boolean;
  list : list_descriptor;
  index,
  access_index : global_access_list_entry_index;

begin
  if global_access.count = 0
  then user_terminal.write_quoted_text_line(NO_LISTS_MESSAGE)
  else
    begin
      output_prompt(host_flag, TRUE, DELETE_PROMPT);
      get_and_locate_list(host_flag, success, list);
      if success
      then
	begin (* list exists *)
	  find_list_in_global_access(global_access,list,success,access_index);
	  if not success
	  then
	    begin
	      format.start_message(LIST_NOT_FOUND_MESSAGE);
	      if class_flag
	      then format.string(CLASS_MESSAGE)
	      else format.string(GROUP_MESSAGE);
	      format.write_line(user_terminal)
	    end (* not success *)
	  else
	    begin (* list is in the class, delete the list *)
	      global_access.count := global_access.count - 1;
	      for index := access_index to global_access.count - 1 do
		global_access.lists[index] := global_access.lists[index + 1]
	    end (* list is in the class, delete the list *)
	end (* list exists *)
    end (* global_access.count > 0 *)
end (* delete_entry_from_global_access *);



(**************************  command_level  *****************************)
(*									*)
(*			replace_global_access_entry			*)
(*									*)
(************************************************************************)

procedure replace_global_access_entry(
      host_flag		: boolean (* TRUE if changing hostlists *);
  var global_access	: global_access_description);

var
  list : list_descriptor;
  success : boolean;
  old_list_index,
  new_list_index : global_access_list_entry_index;

begin
  if global_access.count = 0
  then user_terminal.write_quoted_text_line(NO_LISTS_MESSAGE)
  else
    begin
      output_prompt(host_flag, TRUE, REPLACE_PROMPT);
      get_and_locate_list(host_flag, success, list);
      if success
      then
	begin (* list to be replaced exists *)
	  find_list_in_global_access(global_access, list, success,
	    old_list_index);
	  if success
	  then
	    begin (* list to be replaced exists in global access *)
	      output_new_prompt(host_flag, TRUE);
	      get_and_locate_list(host_flag, success, list);
	      if success
	      then
	        begin (* replacement list exists *)
		  find_list_in_global_access(global_access, list, success,
		    new_list_index);
		  if success
		  then user_terminal.write_quoted_text_line(LIST_USED_MESSAGE)
		  else global_access.lists[old_list_index] := list
		end (* replacement list exists *)
	    end (* list to be replaced exists in global access *)
	end (* list to be replaced exists *)
    end (* global_access.count > 0 *)
end (* replace_global_access_entry *);



(**************************  command_level  *****************************)
(*									*)
(*			  change_global_access				*)
(*									*)
(************************************************************************)

procedure change_global_access(
      class_flag	: boolean);

var
  global_value : integer;
  global_access : global_access_description;
  keyword : line_keyword_index;
  host_flag : boolean (* TRUE if changing hostlists *);
  done : boolean;

begin
  if class_flag
  then freeword_utility.get_class(0, scanned, global_value)
  else freeword_utility.get_group(0, scanned, global_value);
  if user_terminal.sendable
  then
    begin
      list_utility.modify_global_access(class_flag,global_value,global_access);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
	begin
	  user_terminal.write_newline;
      	  write_undefined_or_global_access(class_flag, global_access,
	    global_value);
(* modify entries *)
	  global_access.exception := keyword_scan.input_answer(
	    'should this be an exception definition\ ');
	  if class_flag
	  then
	    begin
	      user_terminal.write_quoted_text('change \');
	      if user_terminal.sendable
	      then input_scanner.prompt_and_scan_keyword(
		[LINE_HOSTLIST_KEYWORD, LINE_NODELIST_KEYWORD], keyword);
	      host_flag := keyword = LINE_HOSTLIST_KEYWORD
	    end
	  else host_flag := TRUE;

	  done := FALSE;
	  while user_terminal.sendable and not done do
	    begin
	      input_scanner.prompt_and_scan_keyword(
	        [LINE_ADD_KEYWORD, LINE_DELETE_KEYWORD, LINE_REPLACE_KEYWORD,
		LINE_END_KEYWORD], keyword);
	      if user_terminal.sendable
	      then
	        if keyword = LINE_ADD_KEYWORD
		then add_entry_to_global_access(class_flag, host_flag,
		  global_access)
		else
		  if keyword = LINE_DELETE_KEYWORD
		  then delete_entry_from_global_access(class_flag, host_flag,
		    global_access)
		  else
		    if keyword = LINE_REPLACE_KEYWORD
		    then replace_global_access_entry(host_flag, global_access)
		    else done := TRUE
	    end (* while *);

	  user_terminal.write_newline;
      	  write_undefined_or_global_access(class_flag, global_access,
	    global_value);
	  if not entries_correct(FALSE)
	  then list_utility.abort
	  else
	    begin (* entries correct *)
	      list_utility.update_global_access(class_flag, global_value,
		global_access);
	      report_list_status
	    end (* entries correct *)
	end
    end
end (* change_global_access *);
!
"
		CHANGE LIST (Host or Node) Routines
"



(**************************  command_level  *****************************)
(*									*)
(*			find_value_in_named_list			*)
(*									*)
(************************************************************************)

procedure find_value_in_named_list(
      value		: integer;
      list_to_search	: validator_named_list_definition;
  var found		: boolean;
  var index_found	: named_list_index);

var
  done : boolean;

begin
  found := FALSE; done := FALSE;
  index_found := 0;
  if list_to_search.named_list.count > 0
  then
    while not done and not found do
      if value = list_to_search.named_list.values[index_found]
      then found := TRUE
      else
	if index_found = list_to_search.named_list.count - 1
	then done := TRUE
	else index_found := index_found + 1
end (* find_value_in_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			   add_to_named_list				*)
(*									*)
(************************************************************************)

procedure add_to_named_list(
  var this_list	: validator_named_list_definition);

var
  numbers : general_number_list;
  count_to_input : general_number_list_size;
  numbers_index : general_number_list_index;
  temp_index,
  value_index : named_list_index;
  found : boolean;

begin
  if this_list.named_list.count = MAXIMUM_NAMED_LIST_ENTRY
  then user_terminal.write_quoted_text_line('list is full\ ')
  else
    begin
      if (MAXIMUM_NAMED_LIST_ENTRY - this_list.named_list.count) <
	MAXIMUM_GENERAL_NUMBER_LIST_SIZE
      then count_to_input := (MAXIMUM_NAMED_LIST_ENTRY -
	this_list.named_list.count)
      else count_to_input := MAXIMUM_GENERAL_NUMBER_LIST_SIZE;
      if this_list.host_flag
      then get_numbers_list(FALSE, HOST_PROMPT, count_to_input, 10,
	1, MAXIMUM_HOST, numbers)
      else get_numbers_list(FALSE, NODE_PROMPT, count_to_input, 8,
	1, MAXIMUM_NODE, numbers);

      if user_terminal.sendable
      then (* add the values to the list *)
	begin
	  value_index := this_list.named_list.count;
	  for numbers_index := 0 to numbers.size - 1 do
	    begin
	      find_value_in_named_list(numbers.list[numbers_index], this_list,
		found, temp_index);
	      if found
	      then report_named_list_value_error(TRUE, this_list.host_flag,
		numbers.list[numbers_index])
	      else
		with this_list, named_list do
		  begin (* add value to list *)
		    values[value_index] := numbers.list[numbers_index];
		    if sorted and (value_index > 0)
		    then sorted :=
		      values[value_index] > values[value_index - 1];
		    if value_index < NAMED_LIST_ENTRY_LIMIT
		    then value_index := value_index + 1;
		    count := count + 1
		  end (* with *)		  
	    end (* for *)
	end (* user_terminal.sendable *)
    end (* list is not full *)
end (* add_to_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			 delete_from_named_list				*)
(*									*)
(************************************************************************)

procedure delete_from_named_list(
  var this_list	: validator_named_list_definition);

var
  numbers : general_number_list;
  count_to_input : general_number_list_size;
  numbers_index : general_number_list_index;
  temp_index,
  value_index : named_list_index;
  found : boolean;

begin
  if this_list.named_list.count = 0
  then user_terminal.write_quoted_text_line('no entries to delete\ ')
  else
    begin
      if this_list.named_list.count < MAXIMUM_GENERAL_NUMBER_LIST_SIZE
      then count_to_input := this_list.named_list.count
      else count_to_input := MAXIMUM_GENERAL_NUMBER_LIST_SIZE;
      if this_list.host_flag
      then get_numbers_list(FALSE, HOST_PROMPT, count_to_input, 10,
	1, MAXIMUM_HOST, numbers)
      else get_numbers_list(FALSE, NODE_PROMPT, count_to_input, 8,
	1, MAXIMUM_NODE, numbers);

(* delete values from the named list *)
      if user_terminal.sendable
      then
        for numbers_index := 0 to numbers.size - 1 do
	  begin
	    find_value_in_named_list(numbers.list[numbers_index], this_list,
	      found, value_index);
	    if not found
	    then report_named_list_value_error(FALSE, this_list.host_flag,
	      numbers.list[numbers_index])
	    else
    	      begin (* value found *)
	        this_list.named_list.count := this_list.named_list.count - 1;
		for temp_index:=value_index to this_list.named_list.count-1 do
		  this_list.named_list.values[temp_index] :=
		    this_list.named_list.values[temp_index + 1];
		  this_list.named_list.values[this_list.named_list.count] := 0
		end (* value found *)
	  end (* for *)
    end (* this_list.named_list.count <> 0 *)
end (* delete_from_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			   replace_named_list				*)
(*									*)
(************************************************************************)

procedure replace_named_list(
  var this_list	: validator_named_list_definition);

var
  value : integer;
  found : boolean;
  temp_index,
  replace_index : named_list_index;

begin
  if this_list.named_list.count = 0
  then user_terminal.write_quoted_text_line(NO_LISTS_MESSAGE)
  else
    begin
      output_prompt(this_list.host_flag, FALSE, REPLACE_PROMPT);
      if this_list.host_flag
      then freeword_utility.prompt_host(NULL_STRING, scanned, value)
      else freeword_utility.prompt_node(NULL_STRING, scanned, value);
      if user_terminal.sendable
      then
	begin
	  find_value_in_named_list(value, this_list, found, replace_index);
	  if not found
	  then report_named_list_value_error(FALSE, this_list.host_flag, value)
	  else
	    begin (* list to replace has been located in global access *)
	      output_new_prompt(this_list.host_flag, FALSE);
	      if this_list.host_flag
	      then freeword_utility.prompt_host(NULL_STRING, scanned, value)
	      else freeword_utility.prompt_node(NULL_STRING, scanned, value);
	      if user_terminal.sendable
	      then
		begin
		  find_value_in_named_list(value, this_list, found,
		    temp_index);
		  if found
		  then report_named_list_value_error(TRUE, this_list.host_flag,
		    value)
		  else
		    with this_list, named_list do
		      begin
		        values[replace_index] := value;
			if sorted
			then
			  if (replace_index > 0) and
			    (replace_index < NAMED_LIST_ENTRY_LIMIT)
			  then
			    if replace_index < count - 1
			    then sorted :=
			      (values[replace_index] > 
			        values[replace_index-1]) and
			      (values[replace_index] < values[replace_index+1])
			    else sorted := 
			      (values[replace_index] > values[replace_index-1])
			  else
			    if replace_index = NAMED_LIST_ENTRY_LIMIT
			    then sorted :=
			      values[replace_index] > values[replace_index-1]
			    else
			      if (replace_index = 0) and (count > 1)
			      then sorted :=
			        values[replace_index] < values[replace_index+1]
		      end (* with *)
		end (* user_terminal.sendable *)
	    end (* list to replace has been located in global access *)
	end (* user_terminal.sendable *)
    end (* this_list.named_list.count <> 0 *)
end (* replace_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			      update_list				*)
(*									*)
(************************************************************************)

procedure update_list(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var this_list	: validator_named_list_definition);

var
  keyword : line_keyword_index;
  done : boolean;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    begin
      done := FALSE;
      while user_terminal.sendable and not done do
        begin
	  input_scanner.prompt_and_scan_keyword(
	    [LINE_ADD_KEYWORD, LINE_DELETE_KEYWORD, LINE_REPLACE_KEYWORD,
	     LINE_END_KEYWORD], keyword);
	  if user_terminal.sendable
	  then
	    if keyword = LINE_ADD_KEYWORD
	    then add_to_named_list(this_list)
	    else
	      if keyword = LINE_DELETE_KEYWORD
	      then delete_from_named_list(this_list)
	      else
	        if keyword = LINE_REPLACE_KEYWORD
		then replace_named_list(this_list)
		else done := TRUE
	end (* while *);
      sort_named_list(TRUE, FALSE, this_list)
    end;
  write_named_list(this_list);
  if not entries_correct(TRUE)
  then list_utility.abort
  else
    begin (* entries_correect *)
      list_utility.update_list(this_list);
      report_list_status
    end (* entries_correect *)
end (* update_list *);



(**************************  command_level  *****************************)
(*									*)
(*			      change_list				*)
(*									*)
(************************************************************************)

procedure change_list(
      host_flag	: boolean (* TRUE if changing a HOST list *));

var
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  this_list : validator_named_list_definition;

begin
  this_list.host_flag := host_flag;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  freeword_utility.get_listname(0, scanned, this_list.named_list.name);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    begin
      list_utility.modify_list(this_list);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
        begin
	  write_named_list(this_list);
	  user_terminal.write_newline;
	  update_list(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    this_list)
	end (* list_utility.last_status = NODE_HOST_OK *)
    end (* user_terminal.sendable and (scanned.status = CMD_OK) *)
end (* change_list *);
!
"
		CHANGE NAME Command
"



(**************************  command_level  *****************************)
(*									*)
(*			     change_name 				*)
(*									*)
(************************************************************************)

procedure change_name;

var
  cud_entry : cud_user_entry;
  old_name : username_string;
  success : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  get_and_access_name(TRUE, cud_entry, success);
  old_name := cud_entry.name;
  if success
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      success := FALSE;
      repeat
        freeword_utility.prompt_username('new username: \ ', cud_entry.name);
	if user_terminal.sendable
	then
	  if cud_entry.name = old_name
	  then user_terminal.write_quoted_text_line(
	    'old and new name may not be the same\ ')
	  else success := reserve_name(cud_entry.name)
      until success or not user_terminal.sendable;
      if not user_terminal.sendable
      then cud_updater.abort_cud_change
      else
        if not entries_correct(TRUE)
	then cud_updater.abort_cud_change
	else
	  begin (* entries_correct *)
	    cud_updater.rename_cud_entry(cud_entry);
	    cud_utility.print_cud_entry_message
	  end (* entries_correct *)
    end
end (* change_name *);
!
"
		CHANGE PASSWORD
"



(**************************  command_level  *****************************)
(*									*)
(*			    change_password 				*)
(*									*)
(************************************************************************)

procedure change_password;

var
  cud_entry : cud_user_entry;
  success : boolean;

begin
  if profile.level = PASSWORD_ONLY_VALIDATOR
  then
    begin
      cud_entry.name := profile.name;
      modify_user_entry(cud_entry);
      success := cud_updater.last_status = CUD_ENTRY_OK
    end (* password only validator *)
  else get_and_access_name(TRUE, cud_entry, success);
  if success
  then password_command.change_user_password(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    cud_entry.options, cud_entry.password)
end (* change_password *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
!
"
		CONSISTENCY Command
"


(**************************  command_level  *****************************)
(*									*)
(*			    run_consistency				*)
(*									*)
(************************************************************************)

procedure run_consistency(
      real_sup	: real_supervisor_index;
      block	: cud_block_index;
      nochange	: boolean (* TRUE if no changes should be made *));

var
  in_core_info : supervisor_in_core_information;

begin
  mud_change.get_sup_update_info(real_sup, in_core_info);
  if (in_core_info.current_un2_activity = MANUAL_CONSISTENCY) 
     or (in_core_info.current_un2_activity = AUTO_CONSISTENCY)
  then user_terminal.write_quoted_text_line('consistency is already running\ ')
  else consistency.validator_consistency(real_sup, block, profile,
					   user_terminal, nochange)
end (* run_consistency *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		DELETE Command
"


(***************************  command_level  ****************************)
(*									*)
(*			      delete_access				*)
(*									*)
(*	prompts for username, deletes an access from that cud entry	*)
(*									*)
(************************************************************************)

procedure delete_access;

var
  cud_entry : cud_user_entry;
  success : boolean;
  position : access_entry_index;

begin
  get_and_access_name(TRUE, cud_entry, success);
  if success
  then
    if cud_entry.access_profile.count = 1
    then
      begin
	cud_updater.abort_cud_change;
	user_terminal.write_quoted_text_line('cannot delete last entry\ ')
      end (* count = 1 *)
    else
      begin (* user has more than 1 entry *)
	cmd_utility.write_access_profile(cud_entry.access_profile, FALSE);
	user_terminal.write_newline;
	freeword_utility.prompt_access_entry_position(
	  'access position to delete: \', cud_entry.access_profile.count,
	  scanned, position);
	if not entries_correct(TRUE)
	then cud_updater.abort_cud_change
	else
	  begin
	    cud_entry_util.remove_access_entry(position,
	      cud_entry.access_profile);
	    change_user_access(cud_entry)
	  end (* entries_correct *)
      end (* user has more than 1 entry *)
end (* delete_access *);
!



(**************************  command_level  *****************************)
(*									*)
(*			  delete_global_access				*)
(*									*)
(************************************************************************)

procedure delete_global_access(
      class_flag	: boolean);

var
  global_value : integer;
  global_access : global_access_description;
  abort_command : boolean;

begin
  if class_flag
  then freeword_utility.get_class(0, scanned, global_value)
  else freeword_utility.get_group(0, scanned, global_value);
  if user_terminal.sendable
  then
    begin
      list_utility.modify_global_access(class_flag,global_value,global_access);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
	begin (* list_utility.last_status = NODE_HOST_OK *)
	  user_terminal.write_newline;
      	  write_undefined_or_global_access(class_flag, global_access,
	    global_value);
	  if class_flag
	  then abort_command := not keyword_scan.input_answer(
	    'clear entire class\ ')
	  else abort_command := not keyword_scan.input_answer(
	    'clear entire group\ ');
	  if abort_command
	  then list_utility.abort
	  else
	    begin (* clear entries *)
	      global_access.exception := FALSE;
	      global_access.count := 0;
	      user_terminal.write_newline;
	      write_undefined_or_global_access(class_flag, global_access,
	        global_value);
	      if not entries_correct(FALSE)
	      then list_utility.abort
	      else
	        begin (* entries correct *)
		  list_utility.update_global_access(class_flag, global_value,
		    global_access);
		  report_list_status
		end (* entries correct *)
	    end (* clear entries *)
	end (* list_utility.last_status = NODE_HOST_OK *)
    end (* user_terminal.sendable *)
end (* delete_global_access *);
!
(***************************  command_level  ****************************)
(*									*)
(*			       DELETE_LIST				*)
(*									*)
(*	prompt for name and delete list if not used by a class or group *)
(*									*)
(************************************************************************)

procedure delete_list(
      host_flag	: boolean);

var
  this_list	: validator_named_list_definition;
  class_no	: class_index;
  group_no	: group_index;
  found_grp	: boolean;

begin
  this_list.host_flag := host_flag;
  freeword_utility.get_listname(0, scanned, this_list.named_list.name);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    begin
      list_utility.modify_list(this_list);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
	begin (* list_utility.last_status = NODE_HOST_OK *)
	  write_named_list(this_list);
	  if not entries_correct(TRUE)
	  then list_utility.abort
	  else
	    begin (* entries_correct *)
	      list_utility.delete_list(found_grp, group_no, class_no);
	      if list_utility.last_status <> NODE_HOST_LIST_IN_USE
	      then report_list_status
	      else
		begin (* list_utility.last_status = NODE_HOST_LIST_IN_USE *)
		  format.start;
		  format.newline;
		  format.listname(this_list.named_list.name);
		  format.string(' is referred to in the definition of\ ');
		  format.string(STARS_MESSAGE);
		  if found_grp
		  then
		    begin
		      format.string(GROUP_MESSAGE);
		      format.number(group_no, 10)
		    end (* found_grp *)
		  else
		    begin (* found_grp false *)
		      format.string(CLASS_MESSAGE);
		      format.number(class_no, 10)
		    end (* found_grp false *);
		  format.string(STARS_MESSAGE);
		  format.newline;
		  format.string('and may not be deleted\ ');
		  format.write_line(user_terminal)
		end
	    end (* entries_correct *)
	end (* if NODE_HOST_OK *)
    end (* user_terminal.sendable and (scanned.status = CMD_OK) *)
end (* delete_list *);
!
(***************************  command_level  ****************************)
(*									*)
(*			     DELETE_USER				*)
(*									*)
(*	prompts for username and deletes that entry from cud		*)
(*									*)
(************************************************************************)

procedure delete_user;

var
  cud_entry : cud_user_entry;
  success : boolean;

begin
  get_and_access_name(TRUE, cud_entry, success);
  if success
  then
    begin
      if not user_terminal.sendable
      then cud_updater.abort_cud_change
      else
	if not entries_correct(FALSE)
	then cud_updater.abort_cud_change
	else
	  begin (* delete the user *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    cud_updater.delete_cud_entry;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    cud_utility.print_cud_entry_message
	  end (* delete the user *)
    end (* success *)
end (* delete_user *);
!
"
		DISPLAY GLOBAL (CLASS or GROUP) command
"



(**************************  command_level  *****************************)
(*									*)
(*			display_single_global_access			*)
(*									*)
(************************************************************************)

procedure display_single_global_access(
      class_flag	: boolean;
      global_value	: univ integer);

var
  global_access : global_access_description;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      list_utility.read_global_access(class_flag, global_value, global_access);
      if list_utility.last_status = NODE_HOST_OK
      then write_undefined_or_global_access(class_flag, global_access,
        global_value)
      else report_list_status
    end (* scanned.status = CMD_OK *)
end (* display_single_global_access *);



(**************************  command_level  *****************************)
(*									*)
(*			  display_global_access				*)
(*									*)
(************************************************************************)

procedure display_global_access(
      first_value	: integer;
      last_value	: integer;
      class_flag	: boolean (* TRUE if displaying CLASSES *));

var
  first_undefined,
  value : integer;
  global_access : global_access_description;
  undefined : boolean (* TRUE if undefined global accesses to be printed *);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      undefined := FALSE;
      for value := first_value to last_value do
        begin
	  list_utility.read_global_access(class_flag, value, global_access);
	  if list_utility.last_status <> NODE_HOST_OK
	  then
	    begin
	      write_global_access_header(class_flag, value, value);
	      report_list_status
	    end (* list_utility.last_status <> NODE_HOST_OK *)
	  else (* list_utility.last_status = NODE_HOST_OK *)
	    if global_access.count <> 0
	    then
	      begin (* found a defined global_access *)
	        if undefined
		then write_undefined(class_flag, value - 1, first_undefined);
		write_global_access(class_flag, global_access, value);
		undefined := FALSE
	      end (* found a defined global_access *)
	    else (* count = 0, found an undefined global_access *)
	      if not undefined
	      then
	        begin (* first undefined global_access found *)
		  first_undefined := value;
		  undefined := TRUE
		end (* first undefined global_access found *)
	end (* for *);
      if undefined (* if last ones were undefined, output them *)
      then write_undefined(class_flag, last_value, first_undefined)
    end (* scanned.status = CMD_OK *)
end (* display_global_access *);
!

"
		DISPLAY HOSTLIST or NODELIST Command
"



(**************************  command_level  *****************************)
(*									*)
(*			     DISPLAY_LIST				*)
(*									*)
(************************************************************************)

procedure display_list;

var
  keyword : command_keyword_index;
  list_desc : list_descriptor;
  list : validator_named_list_definition;
  list_values,	(* if TRUE display list names and their entries *)
  sort,
  done,
  no_lists  : boolean;

begin
  list_desc.host_flag := PRIMARY_DISPLAY_HOSTLIST_KEYWORD = scanned.subcommand;
  list.host_flag := list_desc.host_flag;
  if scanned.freeword_count = 0
  then
    begin (* no list name entered, display ALL lists *)
      list_values := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if not argument_scan.check_keyword(
        PRIMARY_DISPLAY_LIST_NAMES_KEYWORD, scanned)
      then list_values := TRUE (* listing entire named list information *)
      else keyword := PRIMARY_DISPLAY_LIST_NAMES_KEYWORD;

      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  no_lists := TRUE (* no lists found so far *);
	  list_allocater.start_list(validator, list_desc.host_flag);
	  if list_values
	  then sort := keyword_scan.input_answer(SORT_ALL_QUERY);
	  format.start;
	  repeat
	    list_allocater.next_list(validator, list_desc.list_ptr, done);
	    if not done
	    then
	      begin (* found a list *)
		list_utility.read_next_list(list_desc, list);
		if list_utility.last_status <> NODE_HOST_OK
		then
		  begin (* list_utility.last_status <> NODE_HOST_OK *)
		    if format.buffer.size <> 0
		    then format.write_line(user_terminal);
		    list_utility.report_status(user_terminal, TRUE,list_desc, 
		      list_utility.last_status);
		    format.start;
		  end (* list_utility.last_status <> NODE_HOST_OK *)
		else
		  if list.named_list.name.size > 0 
		  then (* ignore lists being created *)
		    begin (* list_utility.last_status = NODE_HOST_OK *)
		      no_lists := FALSE;
		      if list_values
		      then
		        begin (* display all information for the list *)
			  sort_named_list(FALSE, sort, list);
			  write_named_list(list)
			end (* display all information for the list *)
		      else
		        if keyword = PRIMARY_DISPLAY_LIST_NAMES_KEYWORD
			then
			  begin (* display list names only *)
			    cmd_utility.check_line_length_and_write(
			      list.named_list.name.size + 5, 0, COMMA_SPACE);
			    format.listname(list.named_list.name)
			  end (* display list names only *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		    end (* list_utility.last_status = NODE_HOST_OK *)
	      end (* found a list *)
	  until done or not user_terminal.sendable;
	  if no_lists
	  then user_terminal.write_quoted_text_line('no lists found\ ')
	  else
	    if not list_values and
	      (keyword = PRIMARY_DISPLAY_LIST_NAMES_KEYWORD)
	    then format.write_line(user_terminal)
	end (* if CMD_OK *)
    end (* scanned.freeword_count = 0 *)
  else
    begin (* display the specified list *)
      freeword_utility.get_listname(0, scanned, list.named_list.name);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  list_utility.read_list(list_desc, list);
	  if list_utility.last_status <> NODE_HOST_OK
	  then report_list_status
	  else
	    begin
	      sort_named_list(TRUE, FALSE, list);
	      write_named_list(list)
	    end (* list_utility.last_status = NODE_HOST_OK *)
	end (* scanned.status = CMD_OK *)
    end (* display the specified list *)
end (* display_list *);
!
"
		DISPLAY PARAMETERS Command
"



(**************************  command_level  *****************************)
(*									*)
(*			   display_parameters				*)
(*									*)
(************************************************************************)

procedure display_parameters;

var
  gan : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  uun : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      param_manager.next_gan_and_uun(gan,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      uun);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      format.start;
      if INCLUDE_GAN
      then
        begin
	  format.string('Next \');
	  format.string(GAN_PROMPT);
	  format.number(gan, 8);
	  format.newline
	end (* INCLUDE_GAN *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
      format.string('Next UUN: \ ');
      format.number(uun, UUN_RADIX);
      format.write_line(user_terminal)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
    end (* scanned.status = CMD_OK *)
end (* display_parameters *);
!
"
		DISPLAY UPDATES Subcommand
"



(***************************  command_level  ****************************)
(*									*)
(*				format_time				*)
(*									*)
(*	Takes time in minutes and formats to HH:MM			*)
(*									*)
(************************************************************************)

procedure format_time(
      time	: integer);

begin
  format.format_number(time div 60, 10, -2);
  format.character(ASCII_COLON);
  format.format_number(time mod 60, 10 , -2)
end (* format_time *);
!
(******************  command_level  *************************************)
(*									*)
(*		DISPLAY_NETVAL_TABLE_AGE				*)
(*									*)
(************************************************************************)

procedure display_netval_table_age(
  var netval_table_exists : boolean);

begin (* display_netval_table_age *)
  if mud_change.table_date = 0
  then 
    begin (* netval table has not been created yet *)
      user_terminal.write_quoted_text_line(
            'Netval Class/group table has not been created\');
      netval_table_exists := FALSE
    end (* netval table has not been created yet *)
  else
    begin (* output class/group table creation date *)
      netval_table_exists := TRUE;
      format.start_message('Class/group table last created: \ ');
      format.time(mud_change.table_date);
      format.write_line(user_terminal)
    end (* output class/group date *)
end (* display_netval_table_age *);



(**************************  command_level  *****************************)
(*									*)
(*			    display_updates				*)
(*									*)
(************************************************************************)

procedure display_updates;

var
  header_info    : mudupd_disk_header;
  sup_core_info  : supervisor_in_core_information;
  real_sup 	 : real_supervisor_index;
  mud_change_eof : integer;
  netval_table_exists,
  none 	 	 : boolean (* TRUE if there are no legal sup *);

begin
  format.start_message('Current time is \ ');
  format.time(REALTIME);
  format.string(GMT_MESSAGE);
  format.newline;
  format.string('Blocks in CUD: \');
  format.number(MAXIMUM_NORMAL_CUD_BLOCK, 10);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  format.string('     MUD update EOF: \');
  mud_change_eof := mud_change.mud_change_eof;
  format.number(mud_change_eof, 10);
  format.string(' (\ ');
  format.number(mud_change_eof div (MUDUPD_DATA_MAX div 100), 10);
  format.string('% full)\');
  format.write_line(user_terminal);
  display_netval_table_age(netval_table_exists);

  mud_change.get_header_info(header_info);

  if (header_info.consistency_start = 0) and
    (header_info.consistency_stop = 0)
  then user_terminal.write_quoted_text_line(CONSISTENCY_DEACTIVATED_MESSAGE)
  else
    begin (* output consistency schedule *)
      format.start_message('Scheduled consistency period: \ ');
      format_time(header_info.consistency_start);
      format.string(' to \ ');
      format_time(header_info.consistency_stop);
      format.write_line(user_terminal)
    end (* output consistency schedule *);

  none := TRUE;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    if header_info.sup_disc_info[real_sup].state = real_sup (* if sup legal *)
    then
      begin
	if none
	then
	  begin (* write header for information *)
	    user_terminal.write_line_and_quoted_text_line(
	      'Sup                    MUD          CLASS/GROUP\');
	    user_terminal.write_quoted_text_line(
	      '          Ptr        Updated          Updated\');
	    none := FALSE
	  end (* write header for information *);

	with header_info.sup_disc_info[real_sup] do
	  begin (* write MUD and Class/group information *)
	    format.start;
	    format.sup_number(real_sup);
	    format.format_number(pointer, 10, 12);
	    format.skip_to(20);
	    if last_mud_update <> 0
	    then format.short_time(last_mud_update);
	    format.skip_to(37);
	    if last_cg_update <> 0
	    then format.short_time(last_cg_update);
	    format.write_line(user_terminal)
	  end (* write MUD and Class/group information *)
      end (* if sup is legal *);

  if none = TRUE
  then user_terminal.write_line_and_quoted_text_line(NO_LEGAL_SUPS_MESSAGE)
  else
    begin
      user_terminal.write_newline;
      (* write consistency information header *)
      user_terminal.write_quoted_text_line(
'Sup		       CONSISTENCY\');
      user_terminal.write_quoted_text_line(
'     Last Start     Last Stop   End Block	   Current Start   Block\');
(* write consistency info *)
      for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
	if header_info.sup_disc_info[real_sup].state = real_sup
	then
	  begin (* sup legal *)
	    format.start;
	    format.sup_number(real_sup);
	    mud_change.get_sup_update_info(real_sup, sup_core_info);
	    with header_info.sup_disc_info[real_sup] do
	      if history.consistency.start_date <> 0
	      then
		begin (* write consistency history, if any *)
		  format.skip(2);
		  format.short_time(history.consistency.start_date);
		  format.skip(3);
		  format.short_time(history.stop_date);
		  format.skip(2);
		  if history.consistency.block = CUD_BLOCK_LIMIT
		  then format.string('complete\ ')
		  else format.format_number(history.consistency.block, 10, 6);
		  format.skip_to(42);
		  if history.consistency.manual
		  then format.string('M \ ')
		  else format.string('  \ ');
		  if history.consistency.stopped
		  then format.string('S\')
		end (* write consistency history, if any *);

	    format.skip_to(52);

	    with sup_core_info.consistency do
	      if start_date <> 0
	      then
		begin (* write current consistency info, if any *)
		  format.short_time(start_date);
		  format.format_number(block, 10, 8);
		  if manual
		  then format.string(' M\ ')
		  else
		    if sup_core_info.run_init_auto_consistency
		    then format.string(' I\ ')
		end (* write current consistency info, if any *);

	    format.write_line(user_terminal)
	  end (* sup legal *)
    end (* legal sups exist *)
end (* display_updates *);
!
"
		DISPLAY USER Subcommand
"



(**********************  command_level  *********************************)
(*									*)
(*			 DISPLAY_USER		    			*)
(*									*)
(*	Prompts for a username and displays their cud entry, if found   *)
(*									*)
(************************************************************************)

procedure display_user;

var
  cud_entry : cud_user_entry;
  success : boolean;

begin
  get_and_access_name(FALSE, cud_entry, success);
  if success
  then write_cud_entry(cud_entry)
end (* display_user *);
!



(***************************  command_level  ****************************)
(*									*)
(*			      scan_display				*)
(*									*)
(*	Scans display command and calls appropriate subcommand		*)
(*									*)
(************************************************************************)

procedure scan_display;

var
  class_number : integer;
  group_number : integer;
  repeat_display : boolean;
  delay_value : integer;
  time_for_next_display : integer;

begin
  case scanned.subcommand of

    PRIMARY_DISPLAY_CLASS_KEYWORD:
      if scanned.freeword_count = 0
      then display_global_access(FIRST_CLASS, MAXIMUM_CLASS, TRUE)
      else
        begin
	  freeword_utility.get_class(0, scanned, class_number);
	  display_single_global_access(TRUE, class_number)
	end (* PRIMARY_DISPLAY_CLASS_KEYWORD *);

    PRIMARY_DISPLAY_CUD_KEYWORD: cmd_utility.display_block(TRUE, scanned);

    PRIMARY_DISPLAY_DIRECTORY_KEYWORD: cmd_utility.display_directory(scanned);

    PRIMARY_DISPLAY_FILTER_KEYWORD: filter_util.display_filters;

    PRIMARY_DISPLAY_GROUP_KEYWORD:
      if scanned.freeword_count = 0
      then display_global_access(FIRST_GROUP, MAXIMUM_GROUP, FALSE)
      else
        begin
	  freeword_utility.get_group(0, scanned, group_number);
	  display_single_global_access(FALSE, group_number)
	end (* PRIMARY_DISPLAY_GROUP_KEYWORD *);

    PRIMARY_DISPLAY_HOSTLIST_KEYWORD,
    PRIMARY_DISPLAY_NODELIST_KEYWORD: display_list;

    PRIMARY_DISPLAY_MUD_KEYWORD: cmd_utility.display_block(FALSE, scanned);

    PRIMARY_DISPLAY_PARAMETERS_KEYWORD: display_parameters;

    PRIMARY_DISPLAY_SELECT_KEYWORD:
      begin
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then cmd_utility.display_select
      end (* PRIMARY_DISPLAY_SELECT_KEYWORD *);

    PRIMARY_DISPLAY_UPDATES_KEYWORD:
      begin
        repeat_display := argument_scan.check_keyword(
	  PRIMARY_DISPLAY_UPDATES_REPEAT_KEYWORD, scanned);
	if repeat_display
	then
	  if scanned.freeword_count = 0 (* no value entered *)
	  then delay_value := 60 (* default is 1 minute (in seconds) *)
	  else freeword_utility.get_numeric_freeword_value(0, 10,
	    0, MAX_INTEGER, scanned, delay_value);
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then
	  repeat
	    display_updates;
	    if repeat_display and user_terminal.sendable
	    then
	      begin (* wait until time to do another display *)
	        user_terminal.write_newline;
	        time_for_next_display := REALTIME + delay_value;
		repeat
		  user_terminal.check_circuit; wait
		until not user_terminal.sendable or
		  (REALTIME > time_for_next_display)
	      end (* wait until time to do another display *)
	  until not user_terminal.sendable or not repeat_display 
      end (* PRIMARY_DISPLAY_UPDATES_KEYWORD *);

    PRIMARY_DISPLAY_USER_KEYWORD: display_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* case *)
end (* scan_display *);
!
"
		HOST Commands
"



(***************************  command_level  ****************************)
(*									*)
(*			   set_host_state				*)
(*									*)
(************************************************************************)

procedure set_host_state(
      new_state	: host_state);

begin
  if new_state = UP_STATE
  then
    begin (* confirm node and kernel host for this system *)
      cmd_utility.display_host_info;
      if not keyword_scan.input_answer(CONTINUE_MESSAGE)
      then scanned.status := RUN_ERROR;
      user_terminal.write_newline
    end (* confirm node and kernel host for this system *);
  if scanned.status = CMD_OK
  then
    begin
      sys_io.set_host_state(new_state);
      user_terminal.write_quoted_text_line(ENTRY_COMPLETED);
      format.start_message('Host state set to \ ');
      format.host_state_name(new_state);
      oper_messages.report_validator_message(profile)
    end (* scanned.status = CMD_OK *)
end (* set_host_state *);
!
"
		NEW ACCESS Command
"



(****************************  command_level  ***************************)
(*									*)
(*				new_access				*)
(*									*)
(************************************************************************)

procedure new_access;

var
  cud_entry : cud_user_entry;
  success : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  get_and_access_name(TRUE, cud_entry, success);
  if success
  then
    if cud_entry.access_profile.count = MAXIMUM_ACCESS_ENTRY
    then
      begin
	user_terminal.write_quoted_text_line('access profile is full\ ');
	cud_updater.abort_cud_change
      end (* full access profile *)
    else
      begin (* room for new access profile *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	get_access_profile(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  cud_entry.options, cud_entry.access_profile);
	user_terminal.write_newline;
	cmd_utility.write_access_profile(cud_entry.access_profile, FALSE);
	if entries_correct(TRUE)
	then change_user_access(cud_entry)
	else cud_updater.abort_cud_change
      end (* room for new access profile *)
end (* new_access *);
!
"
		NEW HOSTLIST and NODELIST Command
"



(****************************  command_level  ***************************)
(*									*)
(*				  new_list				*)
(*									*)
(************************************************************************)

procedure new_list;

var
  this_list : validator_named_list_definition;

begin
  this_list.host_flag := scanned.subcommand = PRIMARY_NEW_HOSTLIST_KEYWORD;
  freeword_utility.get_listname(0, scanned, this_list.named_list.name);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    begin
      list_utility.create_list(this_list);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
	begin (* list_utility.last_status = NODE_HOST_OK *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  this_list.named_list.count := 0;
	  this_list.sorted := TRUE;
	  if user_terminal.sendable
	  then add_to_named_list(this_list);
	  if user_terminal.sendable
	  then update_list(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    this_list)
	  else list_utility.abort
	end (* list_utility.last_status = NODE_HOST_OK *)
    end (* user_terminal.sendable and (scanned.status = CMD_OK) *)
end (* new_list *);
!
"
		NEW USER Command
"



(****************************  command_level  ***************************)
(*									*)
(*			      validate_user				*)
(*									*)
(************************************************************************)

procedure validate_user(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
  var cud_entry		: cud_user_entry);

var
  new_account : boolean;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
  cud_entry.uun := 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
  cud_entry.entry_change_date := 0;
  cud_entry.password_change_date := 0;
  user_terminal.write_newline;
  write_cud_entry(cud_entry);
  if not entries_correct(TRUE)
  then cud_updater.abort_cud_change
  else
    begin (* entries_correct *)
      if INCLUDE_GAN
      then new_account := cud_entry.gan = 0
      else new_account := FALSE;
      cud_updater.new_cud_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	cud_entry);
      if cud_updater.last_status = CUD_ENTRY_OK
      then
	begin
	  user_terminal.write_newline;
	  if new_account
	  then
	    begin
	      format.start_message(GAN_PROMPT);
	      format.number(cud_entry.gan, 8);
	      format.write_line(user_terminal)
	    end (* new_account *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	  format.start_message(UUN_PROMPT);
	  format.number(cud_entry.uun, UUN_RADIX);
	  format.write_line(user_terminal)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	end (* cud_updater.last_status = CUD_ENTRY_OK *);
      cud_utility.print_cud_entry_message
    end (* entries correct *)
end (* validate_user *);



(****************************  command_level  ***************************)
(*									*)
(*				 new_user				*)
(*									*)
(************************************************************************)

procedure new_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;

var
  success : boolean;
  cud_entry : cud_user_entry;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
(* first get new account information *)
  cud_entry.gan := 0;
  if INCLUDE_GAN
  then
    if profile.level = ACCOUNT_SUPERVISOR_VALIDATOR
    then cud_entry.gan := profile.gan
    else
      if not keyword_scan.input_answer(
	'does this user belong to a new account\ ')
      then
	if user_terminal.sendable
	then
	  repeat
	    freeword_utility.prompt_username('enter username in account: \',
	      cud_entry.name);
	    if user_terminal.sendable
	    then read_user_entry(cud_entry)
	  until (cud_updater.last_status <> CUD_ENTRY_NOT_FOUND) or
	    not user_terminal.sendable;

  if user_terminal.sendable
  then get_and_reserve_name(USERNAME_QUERY,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    cud_entry.name, success);
  if user_terminal.sendable
  then
    if success
    then
      begin
	get_options(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  cud_entry.options);
	if user_terminal.sendable and not (NO_PASSWORD in cud_entry.options)
	then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  password_read.get_new_cipher(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    -1, cud_entry.password);
	if user_terminal.sendable
	then freeword_utility.prompt_district(scanned, cud_entry.district);
	cud_entry.access_profile.count := 0;
	if user_terminal.sendable
	then get_access_profile(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  cud_entry.options, cud_entry.access_profile);
	if user_terminal.sendable
	then validate_user(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	  cud_entry)
	else cud_updater.abort_cud_change
      end (* success *)
end (* new_user *);



(****************************  command_level  ***************************)
(*									*)
(*			check_for_0_class_or_group			*)
(*									*)
(************************************************************************)

procedure check_for_0_class_or_group(
      access_entry	: access_entry_description;
  var found		: boolean);

var
  dest_index : destination_index (* to scan thru destinations *);

begin
  if not access_entry.in_place_origin
  then
    if access_entry.class_no = 0
    then found := TRUE (* zero CLASS found *);
  for dest_index := 0 to access_entry.destination.size - 1 do
    if access_entry.destination.list[dest_index].group_flag and
      (access_entry.destination.list[dest_index].value = 0)
    then found := TRUE (* zero GROUP found *)
end (* check_for_0_class_or_group *);



(****************************  command_level  ***************************)
(*									*)
(*			      new_user_as_old				*)
(*									*)
(*	The validator wants to validate a new user with all the		*)
(*	characteristics of an old user name.  A password must be	*)
(*	assigned to the new username if the control options specify one.*)
(*	If the validator is an account supervisor:			*)
(*		- the old user must be in the same GAN			*)
(*		- if CLASS_0_GROUP_0_ASSIGNABLE is FALSE, the old user	*)
(*		  may not have class 0 or group 0 in his access profile	*)
(*									*)
(************************************************************************)

procedure new_user_as_old(
      old_name	: username_string);

var
  cud_entry : cud_user_entry;
  success : boolean;
  found : boolean (* TRUE if class 0 or group 0 was found *);
  index : access_entry_index (* to scan thru access entries *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  cud_entry.name := old_name;
  read_user_entry(cud_entry) (* get information about OLD user *);
  if cud_updater.last_status = CUD_ENTRY_OK
  then
    if not profile.access_to_gan(cud_entry.gan, TRUE)
    then user_terminal.write_quoted_text_line(NO_ACCESS_TO_USER)
    else
      begin (* validator has access to old username *)
        success := TRUE;
        if not CLASS_0_GROUP_0_ASSIGNABLE and
	  (profile.level = ACCOUNT_SUPERVISOR_VALIDATOR)
	then
	  begin (* check for zero class or group *)
	    found := FALSE;
	    for index := 0 to cud_entry.access_profile.count - 1 do
	      check_for_0_class_or_group(
	        cud_entry.access_profile.entries[index], found);
	    if found
	    then
	      begin
	        success := FALSE;
		user_terminal.write_quoted_text_line(
'old user has a zero class or group value and cannot be used\')
	      end
	  end (* check for zero class or group *);
	if success
	then get_and_reserve_name(USERNAME_QUERY,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		  cud_entry.name, success);
	if success
	then
	  begin
	    if not (NO_PASSWORD in cud_entry.options)
	    then password_read.get_new_cipher(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      -1, cud_entry.password);
	    validate_user(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	      cud_entry)
	  end (* success *)
      end (* validator has access to gan *)
end (* new_user_as_old *);
!




(**************************  command_level  *****************************)
(*									*)
(*			make_table_value_header				*)
(*									*)
(************************************************************************)

procedure make_table_value_header(
      exception		: boolean;
      host_flag		: boolean;
  var start_line	: format_buffer_text_index);

begin
  if format.buffer.size <> 0
  then format.write_line(user_terminal);
  format.start_message('  \ ');
  if host_flag
  then format.string(HOST_MESSAGE)
  else format.string(NODE_MESSAGE);
  format.character(LOWER_CASE_S);
  if exception
  then format.string(' except\');
  format.colon_space;
  start_line := format.buffer.size
end (* make_table_value_header *);



(**************************  command_level  *****************************)
(*									*)
(*			extract_flag_and_value				*)
(*									*)
(************************************************************************)

procedure extract_flag_and_value(
      source_halfword	: halfword;
  var flag		: boolean;
  var value		: univ integer);

var
  temp : integer;

begin
  mutil.save_halfword_in_word(source_halfword, temp);
  if not mutil.test_bit(BIT16, temp)
  then flag := FALSE
  else
    begin (* bit is on *)
      flag := TRUE;
      mutil.clear_bit(BIT16, temp)
    end (* bit is on *);
  value := temp
end (* extract_flag_and_value *);



(**************************  command_level  *****************************)
(*									*)
(*			  write_table_entries				*)
(*									*)
(************************************************************************)

procedure write_table_entries(
      class_flag	: boolean;
      global_value	: univ integer;
      table		: class_group_table;
  var undefined		: boolean;
  var first_undefined	: integer);

var
  start_line : format_buffer_text_index;
  first_value,
  last_value,
  value_index,
  value : integer;
  count : halfword;
  exception,
  host_flag,	(* this value is a host *)
  hosts : boolean (* TRUE if outputting hosts *);

begin
  if class_flag
  then count := table.class_defs[global_value].count
  else
    begin
      count := table.group_defs[global_value].count;
      host_flag := TRUE
    end (* class_flag is FALSE *);
  if count <> ZERO_HALFWORD
  then
    begin
      if undefined
      then write_undefined(class_flag, global_value - 1, first_undefined);
      undefined := FALSE;
      if class_flag
      then
	begin
	  mutil.save_halfword_in_word(table.class_defs[global_value].index,
	    first_value);
	  first_value := (first_value-FIRST_TABLE_CLASS_VALUE_POINTER) div 2;
	  extract_flag_and_value(table.class_defs[global_value].count,
	    exception, value)
	end (* class_flag *)
      else
	begin (* not class_flag *)
	  mutil.save_halfword_in_word(table.group_defs[global_value].index,
	    first_value);
	  first_value := (first_value-FIRST_TABLE_GROUP_VALUE_POINTER) div 2;
	  extract_flag_and_value(table.group_defs[global_value].count,
	    exception, value)
	end (* not class_flag *);
      last_value := (first_value + (value div 2)) - 1;
      write_global_access_header(class_flag, global_value, global_value);
      user_terminal.write_newline;
      format.start;
      for value_index := first_value to last_value do
	begin
	  if class_flag
  	  then extract_flag_and_value(table.class_values[value_index],
	    host_flag, value)
  	  else mutil.save_halfword_in_word(table.group_values[value_index],
	    value);
	  if value_index = first_value
	  then
	    begin
	      make_table_value_header(exception, host_flag, start_line);
	      hosts := host_flag
	    end (* value_index = first_value *)
	  else
  	    if not host_flag and hosts
	    then
	      begin
		hosts := FALSE;
		make_table_value_header(exception, host_flag, start_line)
	      end (* not host_flag and hosts *);
	  cmd_utility.check_line_length_and_write(MAX_HOST_OUTPUT + 4,
	    start_line, COMMA_SPACE);
	  if host_flag
	  then format.number(value, 10)
	  else format.number(value, 8)
	end (* for *);
      format.newline;
      format.write_line(user_terminal)
    end (* count <> ZERO_HALFWORD *)
  else (* zero count *)
    if not undefined
    then
      begin (* found an undef'd class, and the previous was not undef'd *)
	first_undefined := global_value;
	undefined := TRUE
      end (* found an undef'd class, and the previous was not undef'd *)
end (* write_table_entries *);



(**************************  command_level  *****************************)
(*									*)
(*			   display_table				*)
(*									*)
(************************************************************************)

procedure display_table(
      table		 : class_group_table;
      display_sup_table  : boolean;
      table_display_type : class_group_table_display_type;
      sub_table_number   : integer;
      real_sup		 : real_supervisor_index); 
      
var
  class_no 	  : class_index;
  group_no 	  : group_index;
  first_undefined : integer;
  undefined 	  : boolean (* TRUE if any undef'd classes to be printed *);

begin (* display_table *)
  undefined := FALSE;
  if table_display_type = ENTIRE_TABLE
  then
    begin (* display entire Class_Group_Table *)
      for class_no := FIRST_CLASS to MAXIMUM_CLASS do
        if user_terminal.sendable
          then write_table_entries(TRUE, class_no, table, undefined,
                  			first_undefined);
      if undefined
      then write_undefined(TRUE, MAXIMUM_CLASS, first_undefined);

      user_terminal.write_newline; 
      undefined := FALSE;
      for group_no := FIRST_GROUP to MAXIMUM_GROUP do
        if user_terminal.sendable
        then write_table_entries(FALSE, group_no, table, undefined,
      					first_undefined);
      if undefined
      then write_undefined(FALSE, MAXIMUM_GROUP, first_undefined)
    end (* display entire Class_Group_Table *)
  else
    begin (* display a single class or group *)	  
      write_table_entries(table_display_type = ONLY_ONE_CLASS, 
				sub_table_number, table, undefined, 
				first_undefined);
      if undefined
      then write_undefined(table_display_type = ONLY_ONE_CLASS, 
				first_undefined, first_undefined)
    end (* display a single class or group *);	 
end (* display_table *);




(**************************  command_level  *****************************)
(*									*)
(*			display_available_table_space			*)
(*									*)
(************************************************************************)

procedure display_available_table_space(
      msg	: quoted_text;
      count	: integer);

begin
  format.start_message(msg);
  format.string(' available: \ ');
  format.number(count, 10);
  format.write_line(user_terminal)
end (* display_available_table_space *);



(**************************  command_level  *****************************)
(*									*)
(*			   read_netval_table				*)
(*									*)
(************************************************************************)

procedure read_netval_table(
      table_display_type 	: class_group_table_display_type;
      sub_table_number		: integer);

var
  table 		: class_group_table;
  class_list_index 	: table_class_list_index;
  available 		: integer;
  group_list_index 	: table_group_list_index;
  real_sup		: real_supervisor_index;
  done,
  success,
  netval_table_exists	: boolean;

begin  (* read_netval_table *);
  display_netval_table_age(netval_table_exists);
  user_terminal.write_newline;
  if netval_table_exists
  then
    begin (* netval table exists *)
      table_access.read_table(table, success);
      if not success
      then user_terminal.write_quoted_text_line(DISK_READ_ERROR_MESSAGE)
      else
	real_sup := FIRST_SUPERVISOR (* dummy for display_table *);
        if table_display_type = ENTIRE_TABLE
        then
          begin (* disc read OK, compute and display "available" *)
              done := FALSE; 
              class_list_index := 0;
              repeat (* compute "available" for class_table *)
                if table.class_values[class_list_index] = ZERO_HALFWORD
	        then
	          begin (* zero value found *)
	            done := TRUE;
	            available := MAXIMUM_TABLE_CLASS_LIST_HALFWORD_SIZE -
	                             class_list_index
	          end (* zero value found *)
	        else
	          if class_list_index = TABLE_CLASS_LIST_HALFWORD_LIMIT
	          then
	            begin (* list is full *)
	              done := TRUE;
	              available := 0
	            end (* list is full *)
	          else class_list_index := class_list_index + 1
              until done (* compute "available" for class_table *);
              display_available_table_space('Origins\', available);

              done := FALSE; 
              group_list_index := 0;
              repeat (* compute "available" for group_table *);
                if table.group_values[group_list_index] = ZERO_HALFWORD
	        then
	          begin (* zero value found *)
	            done := TRUE;
	            available := MAXIMUM_TABLE_GROUP_LIST_HALFWORD_SIZE -
	                 	     group_list_index
	          end (* zero value found *)
	        else
	          if group_list_index = TABLE_GROUP_LIST_HALFWORD_LIMIT
	          then
	            begin (* list is full *)
	              done :=TRUE;
	              available := 0
	            end (* list is full *)
	          else group_list_index := group_list_index + 1
              until done (* compute "available" for group_table *);
              display_available_table_space('Destinations\ ', available);
	      user_terminal.write_newline
          end (* disc read OK, compute and display "available" *);

          display_table(table, FALSE, table_display_type, sub_table_number,
			    real_sup)
    end (* netval table exists *)
end (* read_netval_table *);



(**************************  command_level  *****************************)
(*									*)
(*			 read_supervisor_table				*)
(*									*)
(************************************************************************)

procedure read_supervisor_table(
      real_sup			: real_supervisor_index;
      table_display_type	: class_group_table_display_type;
      sub_table_number		: integer);

var
  table  	: class_group_table;
  status 	: sysmsg1_status;
  header_info 	: mudupd_disk_header;

begin (* read_supervisor_table *)
  mud_change.get_header_info(header_info);
  with header_info.sup_disc_info[real_sup] do
    if last_cg_update <> 0 (* use table age stored in MUF Header data *)
    then 
      begin (* format last updated msg *)	  
        format.start_message('Supervisor Class/group table last updated: \');
	format.short_time(last_cg_update)
      end (* format last updated msg *)	 
    else format.start_message(
'Supervisor Class/group table has not been updated.\ ');
  format.write_line(user_terminal);
  user_terminal.write_newline;

  sysmsg1_util.read_sup_table(real_sup, table, status);
  if status = SYSMSG1_SUCCESSFUL
  then display_table(table, TRUE, table_display_type, sub_table_number, 
				real_sup)
  else
    begin (* report the SYSMSG1 error *)
      format.start;
      with aux_io do
	format.sysmsg1_error(status, aux_io.param.status,
	  aux_io.param.arg2);
      format.write_line(user_terminal)
    end (* report the SYSMSG1 error *)
end (* read_supervisor_table *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(**************************  command_level  *****************************)
(*									*)
(*				remark_command				*)
(*									*)
(************************************************************************)

procedure remark_command;

var
  remark : oplog_remark_message;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_terminal.write_quoted_text('Enter operator log remark: \');
      user_terminal.read_remark(remark);
      cud_updater.set_remark(remark)
    end (* scanned.status = CMD_OK *)
end (* remark_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		SEND Command
"


(**************************  command_level  *****************************)
(*									*)
(*				send	 				*)
(*									*)
(************************************************************************)

procedure send;

var
  send_wait : boolean;
  table : class_group_table;
  success : boolean;
  real_sup : real_supervisor_index;
  done_waiting : boolean;
  wait_time : integer;
  current_status : class_group_status;

begin
  send_wait := argument_scan.check_keyword(PRIMARY_SEND_WAIT_KEYWORD,
    scanned);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      list_access.lock_file;
      list_utility.create_table(user_terminal, table);
      if list_utility.last_status <> NODE_HOST_OK
      then
	begin
	  list_access.unlock_file;
	  report_list_status
	end (* list_utility.last_status <> NODE_HOST_OK *)
      else
	begin (* list_utility.last_status = NODE_HOST_OK *)
	  user_terminal.write_quoted_text_line('Class/group table built\');
	  table_access.write_table(table, success);
	  if not success
	  then user_terminal.write_line_and_quoted_text_line(
	    'error in writing NETVAL table\')
	  else
	    begin (* table written successfully *)
	      user_terminal.write_line_and_quoted_text_line(
		'Class/group send initialized\ ');
	      list_access.unlock_file;
	      format.start_message('SEND command executed\');
	      oper_messages.report_validator_message(profile);
	      if send_wait (* if validater asked to, wait for completion *)
	      then
		for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
		  if user_terminal.sendable and
		    mud_change.legal_supervisor(real_sup)
		  then
		    begin
		      done_waiting := FALSE;
		      repeat
		        current_status :=
			  mud_change.sup_table_status(real_sup);
			if current_status = CLASS_GROUP_NOT_TRIED
			then
			  begin (* this sup has not been tried as yet, wait *)
			    for wait_time := 1 to 10 do
			      wait;
			    user_terminal.check_circuit
			  end (* this sup has not been tried as yet *)
			else
			  begin (* update has been attempted *)
			    done_waiting := TRUE;
			    format.start_message('Supervisor \');
			    format.sup_number(real_sup);
			    format.colon_space;
			    if current_status = CLASS_GROUP_FAILED
			    then format.string('update failed\')
			    else format.string('table sent\ ');
			    format.write_line(user_terminal)
			  end (* update has been attempted *)
		      until done_waiting or not user_terminal.sendable
		    end (* legal_supervisor *)
	    end (* table written successfully *)
	end (* list_utility.last_status = NODE_HOST_OK *)
    end (* scanned.status = CMD_OK *)
end (* send *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		SET SCHEDULE Command
"



(***************************  command_level  ****************************)
(*									*)
(*			      set_schedule				*)
(*									*)
(*	sets auto_consistency period					*)
(*									*)
(************************************************************************)

procedure set_schedule;

var
  start_time : integer;
  stop_time : integer;
  
begin
  freeword_utility.prompt_time_in_minutes(CONSISTENCY_START_TIME_MESSAGE,
    start_time);
  if user_terminal.sendable
  then freeword_utility.prompt_time_in_minutes(CONSISTENCY_STOP_TIME_MESSAGE,
    stop_time);
  if user_terminal.sendable
  then
    if (start_time = 0) and (stop_time = 0)
    then user_terminal.write_line_and_quoted_text_line(
'use CLEAR command to deactivate automatic consistency\')
    else
      begin (* legal times entered, set schedule *)
        mud_change.set_schedule(start_time, stop_time);
	user_terminal.write_newline;
	user_terminal.write_quoted_text_line(ENTRY_COMPLETED);
	format.start_message('consistency schedule set\ ');
	oper_messages.report_validator_message(profile)
      end (* legal times entered, set schedule *)
end (* set_schedule *);
!
"
		SET SUPERVISOR Command
"



(***************************  command_level  ****************************)
(*									*)
(*			  send_errlog_message				*)
(*									*)
(*      Send a message that a Supervisor has been turned ON or OFF	*)
(*	to the Supervisor err log ("12x" is Supervisor host number;	*)
(*	"f" is 0 if OFF, 1 if ON)					*)
(*									*)
(* Supervisor ERR log message:						*)
(*	NODE REPORT nnnn SLOT ss VAL TYPE 11 12x f			*)
(*									*)
(* TMCS message:							*)
(*	NODE REPORT nnnn FROM SLOT ss VAL, SUPERVISOR 12x TURNED ON/OFF	*)
(*									*)
(************************************************************************)

procedure send_errlog_message(
      real_sup	: real_supervisor_index;
      turned_on	: boolean);

var
  data1 : char;
  data2	: halfword;

begin (* send_errlog_message *)
  mutil.save_word_in_halfword(real_sup, data2);
  if turned_on
  then data1 := '(:1:)' (* sup has been turned on *)
  else data1 := ZERO (* sup has been turned off *);
  aux_io.send_errlog_message(ERRLOG_SET_SUPERVISOR_MESSAGE_TYPE, data1, data2)
end (* send_errlog_message *);



(***************************  command_level  ****************************)
(*									*)
(*			Display_all_legal_sups				*)
(*									*)
(************************************************************************)

procedure display_all_legal_sups;

var
  real_sup : real_supervisor_index;
  first_one : boolean;

begin (* display_all_legal_sups *)
  first_one := TRUE;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    if mud_change.legal_supervisor(real_sup)
    then
      begin (* format legal_supervisor number *)
        if first_one
        then
    	  begin (* first one *)
	    format.start_message('Netval legal supervisors are: \ ');
  	    first_one := FALSE
	  end (* first_one *)
	else format.string(COMMA_SPACE);
	format.sup_number(real_sup)
      end (* format legal_supervisor number *);

  if first_one
  then user_terminal.write_quoted_text_line(NO_LEGAL_SUPS_MESSAGE)
  else format.write_line(user_terminal)
end (* display_all_legal_sups *);




(***********************  Command_Level  ********************************)
(*									*)
(*			record_change_of_sup_state	      		*)
(*									*)
(************************************************************************)

procedure record_change_of_sup_state(
      real_sup	: real_supervisor_index;
      on	: boolean);

begin (* record_change_of_sup_state *)
  format.start_message(SUPERVISOR_MESSAGE);
  format.sup_number(real_sup);
  format.string(' set \');
  if on
  then format.string('on\ ')
  else format.string('off\');
  oper_messages.report_validator_message(profile);

  send_errlog_message(real_sup, on) (* record changed sup status *);

  display_all_legal_sups  
end (* record_change_of_sup_state *);



(***************************  command_level  ****************************)
(*									*)
(*			     set_supervisor				*)
(*									*)
(*	turns designated sup on or off					*)
(*									*)
(************************************************************************)

procedure set_supervisor;

var
  real_sup    : real_supervisor_index;
  keyword     : command_keyword_index;
  success     : set_supervisor_status;
  on          : boolean (* TRUE if keyword = on *);

begin (* set_supervisor command processing *)
  argument_scan.find_keyword(PRIMARY_SET_SUPERVISOR_ON_KEYWORD,
    PRIMARY_SET_SUPERVISOR_OFF_KEYWORD, scanned, keyword);
  if scanned.status = CMD_OK (* if it's really a set_supervisor cmd *)
  then
    begin (* fetch rest of command *)
      on := keyword = PRIMARY_SET_SUPERVISOR_ON_KEYWORD;
      get_supervisor(PRIMARY_SET_SUPERVISOR_KEYWORD, real_sup);
      argument_scan.extra_argument_check(scanned)
    end (* fetch rest of command *);
  if scanned.status = CMD_OK (* if cmd params are OK *)
  then
    begin (* processing of OK set_supervisor command *)
      mud_change.set_supervisor(real_sup, on, success);
      case success of
        SET_SUP_SUCCESSFULL:
	  begin (* nothing unusual happened *)
            user_terminal.write_quoted_text_line(
ENTRY_COMPLETED);
	    record_change_of_sup_state(real_sup, on)
	  end (* nothing unusual happened *);

        SET_SUP_AUTO_CONSISTENCY_HALTED:
	  begin (* auto consistency halted *)
	    user_terminal.write_quoted_text_line(
CONSISTENCY_STOPPED_MESSAGE);
     	    user_terminal.write_quoted_text_line(
ENTRY_COMPLETED);
	    record_change_of_sup_state(real_sup, on)
	  end (* auto consistency halted *);

        SET_SUP_NO_ROOM_IN_PSEUDO_SUP_TABLE:
          begin (* no room in pseudo_sup_table *)
	    user_terminal.write_quoted_text_line(
'Cannot SET_SUPERVISOR:ON because MAXIMUM_EXPECTED_SUPERVISORS already ON\ ');
	    display_all_legal_sups
	  end (* no room in pseudo_sup_table *);

        SET_SUP_ALREADY_IN_PSEUDO_SUP_TABLE:
	  begin (* sup already in pseudo_sup_table *)
	    user_terminal.write_quoted_text_line(
'ERROR!! Supervisor already in pseudo_sup_table\ ');
	    crash_util.halt_slot
	  end (* sup already in pseudo_sup_table *);

        SET_SUP_MANUAL_CONSISTENCY_IN_PROGRESS:
	  begin (* manual consistency in progress *)
	    user_terminal.write_quoted_text_line(
'Cannot SET_SUPERVISOR:OFF because\');
            user_terminal.write_quoted_text_line(CONSISTENCY_UNSTOPPABLE_MSG)
	  end (* manual consistency in progress *);

	SET_SUP_ALREADY_ON:
	  begin (* supervisor is already on *)
	    user_terminal.write_quoted_text_line(
'Sup already on\ ');
	    display_all_legal_sups
	  end (* supervisor is already on *);

	SET_SUP_ALREADY_OFF:
	  begin (* supervisor is already off *)
	    user_terminal.write_quoted_text_line(
'Sup already off\');
	    display_all_legal_sups
	  end (* supervisor is already off *);

	SET_SUP_OFF_ALREADY_IN_PROGRESS:
	  begin (* another turn-off got here first *)
	    user_terminal.write_quoted_text_line(
'Sup already being SET:OFF\')
	  end (* another turn-off got here first *)
	end (* success case statement *)
    end (* processing of OK set_supervisor command *)
end (* set_supervisor *);
!
"
		STOP Command
"



(***************************  command_level  ****************************)
(*									*)
(*			       stop_command				*)
(*									*)
(************************************************************************)

procedure stop_command(
      real_sup : real_supervisor_index);

var
  in_core_info : supervisor_in_core_information;

begin
  mud_change.get_sup_update_info(real_sup, in_core_info);
  if (in_core_info.current_un2_activity = NOT_BUSY) 
     or (in_core_info.current_un2_activity = MUD_UPDATING)
  then user_terminal.write_quoted_text_line('consistency is not running\ ')
  else
    if in_core_info.consistency.manual
    then user_terminal.write_quoted_text_line(CONSISTENCY_UNSTOPPABLE_MSG)
    else
      begin
	mud_change.set_to_be_stopped_true(real_sup);
        user_terminal.write_quoted_text_line(CONSISTENCY_STOPPED_MESSAGE);
	format.start_message(CONSISTENCY_STOPPED_MESSAGE);
	format.string(SUPERVISOR_MESSAGE);
	format.sup_number(real_sup);
	oper_messages.report_validator_message(profile)
      end (* consistency running is not manual *)
end (* stop_command *);
!



(***************************  command_level  ****************************)
(*									*)
(*			   check_assigned_tape				*)
(*									*)
(************************************************************************)

procedure check_assigned_tape;

var
  unit : tape_unit_index;
  found : boolean;

begin
  tape_pool.validator_tape(validator, found, unit);
  if found
  then tape_util.deassign_tape(unit, TRUE)
end (* check_assigned_tape *);


!
"
	WRITE Command
"


(******************************  command_level  *************************)
(*									*)
(*			     knows_password				*)
(*									*)
(************************************************************************)

function knows_password : boolean;

var
  cud_entry : cud_user_entry;

begin
  knows_password := FALSE;
  cud_entry.name.text := PROGRAMMER_NAME;
  cud_entry.name.size := PROGRAMMER_NAME_SIZE;
  read_user_entry(cud_entry);
  if cud_updater.last_status = CUD_ENTRY_OK
  then knows_password := cud_entry.password = password_read.ciphered_password  
end (* knows_password *);



(*******************************  command_level  ************************)
(*									*)
(*			     write_command 				*)
(*									*)
(************************************************************************)

procedure write_command(
      real_sup		: real_supervisor_index;
      writing_from_cud	: boolean);

var
  success        : boolean;

begin
  success := not cmd_utility.buffer_is_empty(writing_from_cud);
  if success
  then
    if not knows_password
    then
      begin
        success := FALSE;
        user_terminal.write_quoted_text_line(PASSWORD_ERROR)
      end (* not knows_password *);
  if success
  then
    if scanned.subcommand = PRIMARY_WRITE_CUD_KEYWORD
    then cmd_utility.write_cud_buffer(writing_from_cud)
    else cmd_utility.write_mud_buffer(writing_from_cud, real_sup)
end (* write_command *);



(***************************  command_level  ****************************)
(*									*)
(*			      scan_primary				*)
(*									*)
(************************************************************************)

procedure scan_primary;

var
  name 			: username_string;
  real_sup 		: real_supervisor_index;
  block 		: cud_block_index;
  table_display_type	: class_group_table_display_type;
  sub_table_number	: integer;
  new_as 		: boolean;
  success 		: boolean;  
  consistency_nochange  : boolean (* TRUE if consistency NOCHANGE *);
  tape_assigned 	: boolean;
  lock_block 		: boolean;
  writing_from_cud 	: boolean;
  display_sup_table	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  case scanned.command of

    PRIMARY_ARCHIVE: archive.archive_command(scanned);

    PRIMARY_CHANGE:
      case scanned.subcommand of
        PRIMARY_CHANGE_ACCESS_KEYWORD:	change_access;
	PRIMARY_CHANGE_CLASS_KEYWORD:	change_global_access(TRUE);
	PRIMARY_CHANGE_CONTROL_KEYWORD:	change_control;
	PRIMARY_CHANGE_CUD_KEYWORD:	cmd_utility.change_cud(scanned);
	PRIMARY_CHANGE_DISTRICT_KEYWORD:change_district;
	PRIMARY_CHANGE_GAN_KEYWORD:	change_gan;
	PRIMARY_CHANGE_GROUP_KEYWORD:	change_global_access(FALSE);
	PRIMARY_CHANGE_HOSTLIST_KEYWORD:change_list(TRUE);
	PRIMARY_CHANGE_NAME_KEYWORD:	change_name;
	PRIMARY_CHANGE_NODELIST_KEYWORD:change_list(FALSE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	PRIMARY_CHANGE_PASSWORD_KEYWORD:change_password
      end (*  PRIMARY_CHANGE *);

    PRIMARY_CHECK:
      begin
        get_username(name, success);
	if success
	then
	  begin
	    cud_updater.check_for_name_in_cud(name);
	    cud_utility.print_cud_entry_error
	  end (* success *)
      end (* PRIMARY_CHECK *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_CLEAR:
      begin (* PRIMARY_CLEAR *)
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then
	  begin (* perform the CLEAR command *)
	    mud_change.set_schedule(0, 0);
	    user_terminal.write_quoted_text_line(
		CONSISTENCY_DEACTIVATED_MESSAGE);
	    format.start_message(
		'consistency cleared\');
	    oper_messages.report_validator_message(profile)
	  end (* perform the CLEAR command *)
      end (* PRIMARY_CLEAR *);

    PRIMARY_COMPARE: cmd_utility.compare(scanned);

    PRIMARY_CONSISTENCY:
      begin
        consistency_nochange := argument_scan.check_keyword(
	  PRIMARY_CONSISTENCY_NOCHANGE_KEYWORD, scanned);
	get_legal_supervisor(PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD, real_sup);
	if scanned.status = CMD_OK
	then
	  begin
	    block := 0;
	    if CONSISTENCY_RESTARTABLE
	    then
	      if argument_scan.check_keyword(PRIMARY_CONSISTENCY_FROM_KEYWORD,
	        scanned)
	      then keyword_util.get_numeric_keyword_value(
	        PRIMARY_CONSISTENCY_FROM_KEYWORD, 10, 0, CUD_BLOCK_LIMIT,
		  scanned, block)
	  end (* scanned.status = CMD_OK *);
        argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then run_consistency(real_sup, block, consistency_nochange)
      end (* PRIMARY_CONSISTENCY *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_DELETE:
      case scanned.subcommand of
	PRIMARY_DELETE_ACCESS_KEYWORD:	delete_access;
	PRIMARY_DELETE_CLASS_KEYWORD:	delete_global_access(TRUE);
	PRIMARY_DELETE_GROUP_KEYWORD:	delete_global_access(FALSE);
	PRIMARY_DELETE_HOSTLIST_KEYWORD:delete_list(TRUE);
	PRIMARY_DELETE_NODELIST_KEYWORD:delete_list(FALSE);
	PRIMARY_DELETE_USER_KEYWORD:	delete_user
      end (* case *);

    PRIMARY_DISPLAY: scan_display;

    PRIMARY_FILTER: filter_util.scan_filter_command(scanned);

    PRIMARY_GET:
      begin
	get_username(name, success);
	if success
	then
	  begin
	    block := cud_updater.hashed_cud_block(name);
	    cud_utility.print_cud_entry_error;
	    if cud_updater.last_status = CUD_ENTRY_OK
	    then
	      begin
		format.start_message('block number: \ ');
		format.number(block, 10);
		format.write_line(user_terminal)
	      end (* cud_updater.last_status = CUD_ENTRY_OK *)
	  end (* success *)
      end (* primary_get *);

    PRIMARY_HOST:
      begin
        argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then
	  case scanned.subcommand of
	    PRIMARY_HOST_SHUT_KEYWORD:	set_host_state(SHUT_STATE);
	    PRIMARY_HOST_STATUS_KEYWORD:cmd_utility.host_status_command;
	    PRIMARY_HOST_UP_KEYWORD:	set_host_state(UP_STATE)
	  end (* case *);
      end (* PRIMARY_HOST *);

    PRIMARY_MESSAGE: filter_util.scan_message_command(scanned);

    PRIMARY_NEW:
      case scanned.subcommand of
	PRIMARY_NEW_ACCESS_KEYWORD:	new_access;

	PRIMARY_NEW_HOSTLIST_KEYWORD,
	PRIMARY_NEW_NODELIST_KEYWORD:
	  begin
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then new_list
	  end (* PRIMARY_NEW_HOSTLIST_KEYWORD *);

	PRIMARY_NEW_USER_KEYWORD:
	  begin
	    new_as := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    if argument_scan.check_keyword(PRIMARY_NEW_USER_AS_KEYWORD,
	      scanned)
	    then
	      begin
		argument_scan.freeword_username(0, scanned, name);
		new_as := TRUE
	      end (* PRIMARY_NEW_USER_AS_KEYWORD *);
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then
	      if new_as
	      then new_user_as_old(name)
	      else new_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  end (* primary_new_user_keyword *)
      end (* case and PRIMARY_NEW *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_QUIT:
      begin
	if profile.level >= NETWORK_ADMINISTRATOR_VALIDATOR
	then
	  begin
	    tape_util.display_status(tape_assigned);
	    if tape_assigned (* deassign any tape unit assigned *)
	    then check_assigned_tape
	  end (* profile.level >= NETWORK_ADMINISTRATOR_VALIDATOR *);
	format.start_message('Logging out at \');
	format.time(REALTIME);
	format.write_line(user_terminal);
	user_terminal.wait_for_output;
	user_terminal.clear_circuit
      end (* PRIMARY_QUIT *);

    PRIMARY_READ:
      case scanned.subcommand of

	PRIMARY_READ_CUD_KEYWORD:
	  begin
	    get_cud_block(PRIMARY_READ_BLOCK_KEYWORD, block);
	    if scanned.status = CMD_OK
	    then lock_block :=
	      argument_scan.check_keyword(PRIMARY_READ_LOCK_KEYWORD, scanned);
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then cmd_utility.read_cud(lock_block, block,
              block_is_locked, shut_block)
	  end (* PRIMARY_READ_CUD_KEYWORD *);

	PRIMARY_READ_MUD_KEYWORD:
	  begin
	    get_cud_block(PRIMARY_READ_BLOCK_KEYWORD, block);
	    if scanned.status = CMD_OK
	    then get_legal_supervisor(PRIMARY_READ_MUD_KEYWORD, real_sup);
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then cmd_utility.read_mud(real_sup, block)
	  end (* PRIMARY_READ_MUD_KEYWORD *);

	PRIMARY_READ_TABLE_KEYWORD:
  	  begin (* process READ command *)
    	    table_display_type := ENTIRE_TABLE;
    	    display_sup_table := FALSE;
	    sub_table_number := 0;

    	    if argument_scan.check_keyword(
			PRIMARY_READ_TABLE_CLASS_KEYWORD, scanned)
    	    then
      	      begin (* set class_table display parameters *)
	        table_display_type := ONLY_ONE_CLASS;	
		keyword_util.get_numeric_keyword_value(
	    		PRIMARY_READ_TABLE_CLASS_KEYWORD, 10, 
			FIRST_CLASS, MAXIMUM_CLASS, scanned, sub_table_number)
      	      end (* set class_table display parameters *)
    	    else 
              if argument_scan.check_keyword(PRIMARY_READ_TABLE_GROUP_KEYWORD, 
			scanned)
      	      then
                begin (* set group_table display parameters *)
	  	  table_display_type := ONLY_ONE_GROUP;	
  	  	  keyword_util.get_numeric_keyword_value(
	          	PRIMARY_READ_TABLE_GROUP_KEYWORD, 10, FIRST_GROUP,
			MAXIMUM_GROUP, scanned, sub_table_number);
        	end (* set group_table display parameters *);

    	    if argument_scan.check_keyword(
			PRIMARY_READ_TABLE_SUPERVISOR_KEYWORD, scanned)
    	    then
      	      begin (* set sup table display parameters *)
                display_sup_table := TRUE;
		get_legal_supervisor(PRIMARY_READ_TABLE_SUPERVISOR_KEYWORD, 
			real_sup)
      	      end (* set sup table display parameters *);

      	    argument_scan.extra_argument_check(scanned);
    	    if scanned.status = CMD_OK
    	    then
      	      if display_sup_table
      	      then read_supervisor_table(real_sup, table_display_type, 
			sub_table_number)
      	      else read_netval_table(table_display_type, sub_table_number)
  	  end (* process READ command *)
      end (* case and PRIMARY_READ *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_REMARK: remark_command;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_SELECT: cmd_utility.select(scanned);

    PRIMARY_SEND: send;

    PRIMARY_SET:
      case scanned.subcommand of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PRIMARY_SET_SUPERVISOR_KEYWORD:	set_supervisor;
	PRIMARY_SET_SCHEDULE_KEYWORD:
	  begin
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then set_schedule
	  end (* PRIMARY_SET_SCHEDULE_KEYWORD *)
      end (* case and PRIMARY_SET *);

    PRIMARY_STOP:
      begin (* PRIMARY_STOP *)
	get_legal_supervisor(PRIMARY_STOP_SUPERVISOR_KEYWORD, real_sup);
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then stop_command(real_sup)
      end (* PRIMARY_STOP *);

    PRIMARY_UNLOCK:
      begin (* PRIMARY_UNLOCK *)
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then
	  if block_is_locked
	  then
	    begin
	      cud_access.unlock_cud_block(shut_block);
	      block_is_locked := FALSE;
	      format.start_message('block \ ');
	      format.number(shut_block, 10);
	      format.string(' unlocked\');
	      format.write_line(user_terminal)
	    end (* block_is_locked *)
	  else user_terminal.write_quoted_text_line('no block locked\')
      end (* PRIMARY_UNLOCK *);

    PRIMARY_WRITE:
      begin
        real_sup := FIRST_SUPERVISOR; 
	writing_from_cud := TRUE;
        if scanned.subcommand = PRIMARY_WRITE_MUD_KEYWORD
	then get_legal_supervisor(PRIMARY_WRITE_MUD_KEYWORD, real_sup)
	else
	  if argument_scan.check_keyword(PRIMARY_WRITE_CUD_FROM_KEYWORD,
	    scanned)
	  then
	    if argument_scan.check_keyword(
	      PRIMARY_WRITE_CUD_FROM_SUPERVISOR_KEYWORD, scanned)
	    then writing_from_cud := FALSE (* writing CUD from MUD buffer *)
	    else scanned.status := ARG_MISSING;
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then write_command(real_sup, writing_from_cud)
      end (* PRIMARY_WRITE *)
  end (* case *)
end (* scan_primary *);



(***************************  command_level  ****************************)
(*									*)
(*			    process_validator				*)
(*									*)
(*	This is the main processing routine.  It sets context, reads	*)
(*	commands and calls the appropriate command class routine.	*)
(*									*)
(************************************************************************)

procedure process_validator;

begin
  command_read.add_class(PRIMARY_CLASS);
  repeat
    command_read.get_command(scanned);
    if user_terminal.available
    then
      begin
	command_read.remove_class(PRIMARY_CLASS);
	user_terminal.write_newline;
 	scan_primary;
	command_read.add_class(PRIMARY_CLASS);
	scan_error.display_command_error(scanned)
      end (* if user_terminal.available *)
  until not user_terminal.available;
  check_assigned_tape
end (* process_validator *);
!
(****************************  command_level  ***************************)
(************************************************************************)

begin (* inital statement *)
  init sys_io, calendar, mutil, format, profile(validator),
    user_terminal(mutil), oper_messages(oplog, format), aux_io(mutil),
    crash_util,

(* command handlers *)
    argument_scan(mutil),

    keyword_util(profile, format, user_terminal, commands, argument_scan),

    input_scanner(profile, mutil, format, user_terminal, commands,
      argument_scan, keyword_util),

    freeword_utility(user_terminal, format, argument_scan, input_scanner,
      scan_error),

    keyword_scan(user_terminal, input_scanner),

    scan_error(user_terminal, format),

    filter_util(validator, format, argument_scan, keyword_util,
      mutil, user_terminal, oplog),

    command_read(validator, profile, statistics, user_terminal, argument_scan,
      format, input_scanner, scan_error, commands),

    dsksys(statistics),


(* CUD handlers *)
    block_utility(mutil, oper_messages, format, dsksys),

    block_updater(mutil, statistics, dsksys, cud_access, block_utility,
      format),

    cud_entry_util(mutil, format, oper_messages),

    cud_updater(validator, mutil, format, login_pool, mud_change,
      oper_messages,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_entry_util, cud_access, block_updater, param_manager, name_access),

    cud_utility(format, cud_updater, user_terminal),

    password_read(mutil, format, user_terminal),

    password_command(mutil, user_terminal, format, password_read,
      cud_updater, cud_utility),

    un2_util(aux_io, oper_messages, format, un2_access, mud_change),

    consistency(mutil, mud_change, un2_util, un2_access,
      block_updater, cud_entry_util, oper_messages, format, aux_io),


(* list handlers (class, group, node and host) *)
    list_io(statistics, file_system, oper_messages, format, list_access),
    list_utility(validator, statistics, file_system,
      format, list_io, list_allocater, list_access),

    sysmsg1_util(aux_io, format, oper_messages, sysmsg1_access),

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    cmd_utility(validator, sys_io, mutil, calendar, format, profile,
      oper_messages, aux_io, user_terminal, cud_access, block_utility,
      block_updater, cud_entry_util, cud_updater, cud_utility,
      un2_util, login_pool, argument_scan, keyword_util,
      input_scanner, freeword_utility, keyword_scan, dsksys),

(* tape and archive handlers *)
    tape_io,

    tape_util(validator, login_pool, tape_pool, format, user_terminal),

    archive(validator, login_pool, tape_pool, mud_change, sys_io, mutil,
      statistics, file_system, param_manager, 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cmd_utility, cud_utility,
      cud_access, block_updater,
      block_utility, cud_entry_util, cud_updater, dsksys, tape_io, tape_util,
      user_terminal, command_read, argument_scan, freeword_utility,
      keyword_util,
      keyword_scan, scan_error, format, oplog, oper_messages, list_io,
      list_allocater, list_access, calendar, list_utility);

  block_is_locked := FALSE;

  cycle
    login;
    process_validator;
    login_pool.release_unit(user_terminal.unit);
    oper_messages.report_logout(VALIDATOR_OPLOG_MSG, profile, 
      user_terminal.logout_reason)
  end (* cycle *)
end (* command_level *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	INIT.NTV							*)
(*									*)
(*			    initial process				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	19Jun86 - neh							*)
(*	      - add parameters to initialize OPLOG_REPORTER		*)
(*	12Feb86 - jrn							*)
(*	      - add lvol_time_stamp process				*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	06Jan86 - rsb							*)
(*		- Change declaration of "var Mud_Updaters" from		*)
(*		  "array[supervisor_index]" to				*)
(*		  "array[pseudo_sup_index]"				*)
(*		- every "sup" changed into "pseudo_sup"			*)
(*		- every "sup: supervisor_index" changed into		*)
(*		        "pseudo_sup ; pseudo_sup_index"			*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	16Jan85 - jrn							*)
(*	      - add all reuse_uun processes and monitors		*)
(*	12Dec84 - pgl/jrn						*)
(*	      - add logical volumes					*)
(*	20Jul84	- jrn							*)
(*	      - change call to disk_system				*)
(*	29SEP83	Original from (patrol)init.bas -- jrn			*)
(*									*)
(************************************************************************)


var
  sys_io		: system_handler;
  statistics		: statistics_gatherer;
  crash_util		: crash_utility;
  dsksys		: disk_system;
  config_utility	: configuration_utility;
  file_system		: file_system_manager;
  oplog			: operator_log;
  commands		: command_table;

  tape_pool		: tape_allocater;

  mud_change		: mud_change_handler;
  tick			: mud_change_tick;

  cud_access		: cud_access_controller;
  param_manager		: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  name_access		: cud_name_controller;

  table_access		: class_group_handler;
  list_access		: node_host_list_access;
  list_allocater	: node_host_list_allocater;
  sysmsg1_access	: sysmsg1_access_manager;
  table_updater		: class_group_updater;

  un2_access		: un2_access_manager;
  mud_updaters		: array [pseudo_supervisor_index] of mud_updater;

  login			: accept_login;
  login_pool		: login_distributer;


  (* Command level processes *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  password_only_validators : array [password_only_validator_index] of
    password_command_level;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  validators : array [licensed_validator_index] of command_level;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(******************************  initial  *******************************)
(*									*)
(*		initialize_disk_and_check_configuration			*)
(*									*)
(*	Initialize the monitors to access disk files and check		*)
(*	configuration parameters.			 		*)
(*									*)
(************************************************************************)

procedure initialize_disk_and_check_configuration;

var
  configuration : configuration_information;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  init statistics, dsksys(statistics), config_utility(dsksys, sys_io),
    file_system;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  config_utility.check_drive_configuration(FILE_SYSTEM_DISK, configuration);
  file_system.reset(configuration.files);
  init oplog(statistics, file_system)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* initialize_disk_and_check_configuration *);



(*******************************  initial  ******************************)
(*									*)
(*			  initialize_mud_updates			*)
(*									*)
(************************************************************************)

procedure initialize_mud_updates;

var
  pseudo_sup : pseudo_supervisor_index;

begin
  init mud_change(statistics, file_system, oplog), tick(mud_change);

  for pseudo_sup := FIRST_SUPERVISOR to MAXIMUM_EXPECTED_SUPERVISORS do
    init un2_access[pseudo_sup];

  for pseudo_sup := FIRST_SUPERVISOR to MAXIMUM_EXPECTED_SUPERVISORS do
    init mud_updaters[pseudo_sup](pseudo_sup, statistics, file_system, oplog,
      cud_access, mud_change, un2_access)
end (* initialize_mud_updates *);



(*******************************  initial  ******************************)
(*									*)
(*			    initialize_validators			*)
(*									*)
(************************************************************************)

procedure initialize_validators;

var
  vi : validator_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* initialize PASSWORD_ONLY validators *)
  for vi := FIRST_PASSWORD_ONLY_VALIDATOR to PASSWORD_ONLY_VALIDATOR_LIMIT do
    init password_only_validators[vi](vi, login_pool, commands, statistics,
      oplog, mud_change, cud_access, param_manager,
      name_access);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(* initialize licensed validators *)
  for vi := FIRST_LICENSED_VALIDATOR to VALIDATOR_LIMIT do
    init validators[vi](vi, login_pool, tape_pool, commands, statistics,
      file_system, oplog, mud_change, cud_access, param_manager,
      name_access, list_access, list_allocater, table_access, un2_access,
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      sysmsg1_access);

(* Initialize login process *)

  init login(statistics, oplog, mud_change, cud_access, param_manager,
    name_access, login_pool)
end (* initialize_validators *);
!
(************************************************************************)
(************************************************************************)

begin
  init sys_io, crash_util, login_pool, commands, tape_pool;

  initialize_disk_and_check_configuration;

  init cud_access, name_access,
    param_manager(statistics, file_system, oplog, cud_access);

  initialize_mud_updates;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init sysmsg1_access, list_access,
    table_access(statistics, file_system, oplog, mud_change),
    list_allocater(statistics, file_system, oplog, list_access),
    table_updater(oplog, mud_change, sysmsg1_access, table_access);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  initialize_validators;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* NETVAL *).
 / 6W