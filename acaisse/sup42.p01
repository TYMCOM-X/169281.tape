	LO	SUPER
:
ESUP	EQ	(SUPESZ*100)&-400 :MAKE CODE ARE A MULTIPLE OF 4 PAGES
				  :FORCE ESUP TO SIZE ALLOCATED IN SUPCOD MACRO
SPAPTR	EQ	SPATCH		:INIT SPATCH POINTER
DATPTR	EQ	DATPCH		:INIT DATPCH POINTER
:
	IF	MTSSUP
:
: This patch allows the Master to wait for two seconds for ring space to
: be available on the Slave before determining that the Slave is down.
: This problem manifested itself with the Master setting the Slave down
: due to full ring for a whole second, yet the Slave was not crashed.
: Problem was always seen following large scale command circuit retake
: incidents, where the Master was running at under 1 Exec loop per second.
: This problem may also be stimulated by running disimiliar Master and Slave
: hardware, causing the Slave to run slower than the Master.
: This is a temporary solution and should not be a problem in the future
: when the Retake inefficiencies are corrected.  Tested in the Public Network.
: Omar A. Serang 11/23/86. NO NSR
:
	REMARK	%ALLOW MASTER TO WAIT 2 SECONDS FOR SLAVE RING SPACE%
	ORG	MTSNDS+14
	BC	0,0
	ORG	MTSNDS+14
	LIS	C4,2		:HOW MANY DISMISSES TO WAIT FOR SPACE.

	ORG	MTSSMS+14
	BC	0,0
	ORG	MTSSMS+14
	LIS	C4,2		:HOW MANY DISMISSES TO WAIT FOR SPACE.

	ORG	MTSPMS+14
	BC	0,0
	ORG	MTSPMS+14
	LIS	C4,2		:HOW MANY DISMISSES TO WAIT FOR SPACE.
	EI	:MTSSUP
	IF	SVLSUP
:
: This patch corrects the race condition that exists in the CHKRTK logic
: in the Supsprout Slave.  If a node cannot be taken over due to lack
: of passthrough resource, shut lines or other, it is put on the delayed
: retake list, which causes another takeover attempt in 1 minute.  The
: Master is timing out before the Slave and sending out a takeover request
: and subsequently sending the received takeover response to the Slave
: before the Slave is ready for it.  This patch reduces the Slave CHKRTK
: timeout to 48 seconds, to allow the Slave to be ready for the takeover
: response when the Master sends it.  This is very similiar to the handling
: of the bad lines timeout.
:
: This fix is tested by running in the Public network and observing no
: more Slave crashes due to topological mismatch with the master. NO NSR
:
: OAS 11/03/86
:
	REMARK	%REDUCE SLAVE CHKRTK TO PREVENT TOPOLOGY MISMATCH%
	ORG	REMDN2+0E
	BC	0,0
	ORG	REMDN2+0E
	BC	00,30
	ORG	T2TSBF+14
	BC	0,0
	ORG	T2TSBF+14
	BC	00,30
	EI	:SVLSUP
:
: This patch increases the number of tries to read the UN2 mud
: block at TRY021 from one to two. #AC 02/20/87. NSR #1371
:
	IF	MSC
	REMARK	%PATCH TO ENABLE READING OF UN2 MUD BLOCK TWICE IN TRYDSK%
:
	ORG	TRY021+60
	BC	0,0,0,0,0,0
	ORG	TRY021+60
:
	JAL	LINK,SPAPTR,,
	ORG	SPAPTR
	LB	T1,V1BLOC+DSKBLK+SHRRS,,	:GET RESPONSE STATUS
	JE	4,LINK				:READ SUCCESSFUL, CONTINUE
	LIS	T1,MUDLU			:GET MUD LU
	EXHR	T1,T1				:POSTION R/S, LU, STATUS
	ST	T1,V1BLOC+DSKBLK+SHRRS,,	:PUT IN PARAM BLOCK
	SVC	SHARE,V1BLOC+DSKBLK,,		:READ BLOCK
	LB	T1,V1BLOC+DSKBLK+SHRRS,,	:GET RESPONSE STATUS
	JE	4,LINK				:READ SUCCESSFUL, CONTINUE
	J	TRY070,,			:ERROR, JUMP
SPAPTR	EQ	.
	EI	:MSC
:
	IF	NOSPAS
:
: Change the SUPASS routine to ignore out of passthrus on active SUP
: during takeover or retake, i.e. reset the NOPASS bit for active SUP
: even if PASSN indicates that the SUP is out of passthrus. NSR # 1096
:
	REMARK	%W/NOSPAS, IGNORE OUT OF PASSTHRUS FOR ACTIVE SUP%
	ORG	SUPAS3
	BC	0,0,0,0,0,0
	ORG	SUPAS3
	J	SPAPTR,,
	ORG	SPAPTR
	CLHI	T1,4*SUPERN		:IS THIS THE ACTIVE SUP?
	JE	SUPAS3+6,,		:YES, RESET NOPASS BITS
	LH	R15,PASSN,T2		:PASSTHRUS AVAILABLE?
	JLE	SUPAS2,,		:NO, RETURN
	J	SUPAS3+6,,		:YES, RESET NOPASS BITS
SPAPTR	EQ	.			:UPDATE SPATCH POINTER
:
	ELSE
:
: This patch is invoked in the Subroutine 'C2TREE' when sprouting
: a least cost T-II tree rooted at the active Supervisor. If the
: active Supervisor is out of passthroughs as indicated by 'PASSN'
: in the node descriptor, every path in the least cost tree has a
: cost of more than 800 hexadecimal. This leads to a circuit build
: failure for reasons of high cost. This patch resets the 'NOPASS'
: bits of all link status bytes in the active Supervisor's node
: descriptor prior to calling SPROUT. After SPROUT the above bits
: are set back to reflect their original status. #AC 02/25/87
:
	REMARK	%PATCH TO RESET AND SET OOPS BITS FOR SUP IN C2TREE%
	ORG	C2TREE+4
	BC	0,0,0,0,0,0
	ORG	C2TREE+4
	J	SPAPTR,,
	ORG	SPAPTR
:
	LHI	T1,(T2BN+SUPERN)^2	:SUPs INDEX INTO NODTBP
	L	R14,NODTBP,T1,		:ADDR. OF SUP'S NODE DESCRIPTOR
	LH	T1,PASSN,R14		:GET # OF PASSTHROUGHS AVAILABLE
	JGFS	C2TRE1			:NOT OOPS
:
: SUP OUT OF PASSTHROUGHS. RESET THE 'NOPASS' BIT IN STATUS BYTES
: OF ALL THE LINKS ON IT.
:
	LHI	C2,LINPTR,R14		:PTR. TO LINK DESC. POINTERS
	LIS	C5,NOPASS		:POS. OF OOP BIT IN STATUS/COST
C2TRE0	LHL	R12,LNKNOD,C2		:GET NEXT NEIGHBOR NODE NUMBER
	JEFS	C2TRE1			:NO MORE LINKS
	LHL	R15,LNKDSP,C2		:DISP. TO LINK DESCRIPTOR
	AIS	C2,LNKPSZ		:POINT TO NEXT LINK DESC. POINTER
:
: RESET THE 'NOPASS' OR OOP BIT IN STATUS BYTE FOR THIS LINK
:
	RBT	C5,LNKST,R15,R14	:INDICATE NOT OOP IN LINK STATUS
	JBS	C2TRE0			:EXAMINE NEXT LINK
C2TRE1	LI	R13,SPCOST		:COST TABLE FOR CONTROL CIRCUITS
	J	C2TREE+0A,,		:RETURN
SPAPTR	EQ	.			:UPDATE SPATCH POINTER
:
	ORG	C2TREE+36
	BC	0,0,0,0,0,0
	ORG	C2TREE+36
	J	SPAPTR,,
	ORG	SPAPTR
:
	LHI	T1,(T2BN+SUPERN)^2	:SUPs INDEX INTO NODTBP
	L	R14,NODTBP,T1,		:ADDR. OF SUP'S NODE DESCRIPTOR
	LH	T1,PASSN,R14		:GET # OF PASSTHROUGHS AVAILABLE
	JGFS	C2TRE3			:NOT OOPS
:
: SUP OUT OF PASSTHROUGS. SET THE 'NOPASS' BIT IN STATUS BYTES
: OF ALL LINKS ON IT.
:
	LHI	C2,LINPTR,R14		:POINTER TO LINK DESC. POINTERS
	LIS	C5,NOPASS		:POS. OF OOP BIT IN STATUS/COST
C2TRE2	LHL	R12,LNKNOD,C2		:GET NEXT NEIGHBOR NODE NUMBER
	JEFS	C2TRE3			:NO MORE LINKS
	LHL	R15,LNKDSP,C2		:DISPLACEMENT TO LINK DESCRIPTOR
	AIS	C2,LNKPSZ		:POINT TO NEXT LINK DESC. POINTER
:
: SET THE 'NOPASS' OR OOP BIT IN STATUS BYTE FOR THIS LINK
:
	SBT	C5,LNKST,R15,R14	:INDICATE OOP IN LINK STATUS
	JBS	C2TRE2			:EXAMINE NEXT LINE
C2TRE3	L	LINK,CTLINK		:RESTORE LINK
	JR	LINK			:RETURN
SPAPTR	EQ	.			:UPDATE SPATCH POINTER
:
	EI	:NOSPAS
:
:
:  Patch to write CHECKPOINT information before freezing SUP when # of
:  blocks fall below the freeze factor. Not writing the CHECKPOINT info
:  was causing the SUP to miss the CHECKPOINT in wake up state. NSR # 1396
:
	IF	NEWACC&DISK
	REMARK	%PATCH TO WRITE ACCOUNT CHECKPOINT BEFORE SUP FREEZE%
	ORG	ACOUNA+0A
	BC	0,0,0,0,0,0
	ORG	ACOUNA+0A
	J	SPAPTR,,
	ORG	SPAPTR
:
	CLR	T1,T2			:LOW ENOUGH TO FREEZE SUP
	JG	ACTOS3,,		:NO
	JAL	LINK,CHKWRT,,		:YES, WRITE CHECKPOINT INFO
	J	ACOUNA+10,,		:PROCEED TO FREEZE THE SUP
SPAPTR	EQ	.			:UPDATE SPATCH POINTER
	EI	:NEWACC&DISK
:
:
:  Fix remove/retake logic to allow active SUP to retake its neighbor
:  when node and link descriptors have out of passthru bit set. NO NSR
:
	REMARK	%ALLOW ACTIVE SUP TO RETAKE ITS NEIGHBOR BY%
	REMARK	IGNORING SUP OUT OF PASSTHRUS CONDITION%
	ORG	REM25
	BC	0,0,0,0,0,0
	ORG	REM25
	J	SPAPTR,,
	ORG	SPAPTR
:
	CLHI	R11,1^(0F-NOPASS)	:IS THIS LINK USABLE?
	JL	REM251-12,,		:YES, RETURN
	THI	R11,(1^(0F-LINOUT))!(1^(0F-LINSHT))!(1^(0F-NOCHAN)) :USABLE?
	JNFS	REM25D			:LINK OUT, SHUT OR OUT OF CHANNELS
	CLHI	C3,T2BN+SUPERN		:OOPS. IS THIS ME?
	JE	REM251-12,,		:YES, OK TO USE ME AS NEIGHBOR
REM25D	IF	E1C0
	J	REM25+8,,		:LOG MSG 1C0 W/REASON CODE
	ELSE
	J	REMEX2,,		:LOG MSG 1C0 W/O REASON CODE
	EI
SPAPTR	EQ	.			:UPDATE SPATCH POINTER
:
	ORG	REM34
	BC	0,0,0,0,0,0
	ORG	REM34
	J	SPAPTR,,
	ORG	SPAPTR
:
	CLHI	R11,1^(0F-NOPASS)	:IS THIS LINK USABLE?
	JL	REM341-12,,		:YES, RETURN
	THI	R11,(1^(0F-LINOUT))!(1^(0F-LINSHT))!(1^(0F-NOCHAN)) :USABLE?
	JNFS	REM34D			:LINK OUT, SHUT OR OUT OF CHANNELS
	CLHI	C2,(SUPERN+T2BN)^1	:OOPS. IS THIS ME?
	JE	REM341-12,,		:YES, OK TO USE ME AS NEIGHBOR
REM34D	IF	E1C0
	J	REM34+8,,		:LOG MSG 1C0 W/REASON CODE
	ELSE
	J	REMEX3,,		:LOG MSG 1C0 W/O REASON CODE
	EI
SPAPTR	EQ	.			:UPDATE SPATCH POINTER
:
:
: This patch allows circuit building to a base that is out of passthroughs
: and is a part of multi-targetted/based list of nodes. The halfword H3
: only indicates a multi-targetting flag, whereas the second node in
: DIRLIST would be present if the circuit is being multi-targetted or
: multi-based. This node is used as the multi-target/base flag instead of H3.
: ANC 12/10/87. NSR # 1315
:
	REMARK	%ALLOW CIRCUIT BUILD TO DESTINATION NODES WITH OOPS
	REMARK	%IN MULTI-TARGETTING/BASING%
	IF	MTSSUP
	ORG	MTSDIR+0E
	BC	0,0,0,0
	ORG	MTSDIR+0E
	LHL	T1,DIRLIST+2	:GET MULTI-TARGETTING/BASING FLAG
	EI	:MTSSUP

	ORG	DIRKL3+6
	BC	0,0,0,0
	ORG	DIRKL3+6
	LHL	T1,DIRLIST+2	:GET MULTI-TARGETTING/BASING FLAG
:
:
:  This patch saves register C1 (used as a byte index into OUTOLD bit
:  array) before calling REMOVE which clobbers C1. This is a fix for
:  a crash which occurs only when excessive flow control is detected
:  on a command port.  The first pass through the remove loop works
:  fine, but the next time through, C1 is bad and gives an index into
:  the ozone, usually causing excessive flow control detection
:  on a non-existent port of a non-existent node. NO NSR
:
	IF	E300
	IF	1-DEBMON
	REMARK	%PATCH TO SAVE/RESTORE INDEX REG IN OUTBOUND CONGESTION%
	ORG	OUTB0A+8
	BC	0,0,0,0,0,0
	ORG	OUTB0A+8
	J	SPAPTR,,
	ORG	SPAPTR
:
: C1 should be saved in DATPCH, but since the $%^&* needle dumping code
: uses this area, we kludge it into TT. This area is normally used for
: bufferlet debugging, so be aware that enabling bufferlet debugging
: will disable this patch.
:
	ST	C1,TT,,			:SAVE BYTE INDEX INTO OUTOLD
	JAL	LINK,REMOVE,,		:ZAP THE CIRCUIT AND CLEAN UP
	L	C1,TT,,			:RESTORE INDEX
	J	OUTB0A+8+6,,		:PROCEED WITH NEXT INSTRUCTION
	EI	:DEBMON
SPAPTR	EQ	.			:UPDATE SPATCH POINTER
	EI	:E300
:
: Patch to cause a more appropriate crash point when the command 
: circuit to the Supervisor's base node gets black-balled.
: See (SUPDEV:39)CRASH.LOG entry dated 7/22/87 for details
: David Fields -7/30/87

	IF 1-NOTI
	IF CHKZAP
	ORG	INDSP3+$A20
	BC	0,0,0,0,0,0
	ORG	INDSP3+$A20
	ELSE :CHKZAP
	ORG	INDSP3+$A14
	BC	0,0,0,0,0,0
	ORG	INDSP3+$A14
	EI   :CHKZAP
	ELSE :NOTI
	IF CHKZAP
	ORG INDSP3+$A12
	BC	0,0,0,0,0,0
	ORG INDSP3+$A12
	ELSE :CHKZAP
	ORG INDSP3+6
	BC	0,0,0,0,0,0
	ORG INDSP3+6
	EI   :CHKZAP
	EI   :NOTI
	J	SPAPTR,,

	REMARK	%PATCH FOR VALID CRASH POINT IF BASE CKT GETS BLACK BALLED%
	ORG	SPAPTR
	AR	R13,R13
	L	T1,NODTBP,R13,R13	:USE NODTBP FOR TEST INSTEAD OF NODUPS
	JLE	IND,,			:IF NO ENTRY , LOOP
	J	INDSP4,,			:RETURN TO NORMAL EXECUTION

SPAPTR	EQ	.

:
: Patch to check NODTBP instead of NODUPS when determining if 
: Supes are up so we can send them sleeping pills.
:
	REMARK	%PATCH TO AVOID SENDING SLEEPING PILLS TO LOST SUPES%
	ORG	SNDPI1
	HC	0,0,0,0

	ORG	SNDPI1
	J	SPAPTR,,

	ORG	SPAPTR

	CLHI	C1,SUPERN	:IS IT THIS SUPE?
	JNFS	SNDPI6		:NO
	J	SNDPI3,,	:YES, IGNORE IT

SNDPI6	EQ	.
	AHI	C1,T2BN		:SUPES BASE NO.
	AR	C1,C1		: X2
	L	T1,NODTBP,C1,C1	:GET NODE TABLE POINTER

	SRHLS	C1,1		:RESTORE SUPE NUMBER
	SHI	C1,T2BN
	LR	T1,T1		:TEST NODE POINTER
	JGFS	SNDPI9		:NODE UP
	J	SNDPI3,,	:NOT UP, CHECK NEXT ONE

SNDPI9	EQ	.
	J	SNDPI1+8,,	:SEND THE PILL

SPAPTR	EQ	.

:
: Patch to fix bug in restoring DIRNOD after using DIRNOD to keep
: track of destination nodes in DIRLIST that were out of passthroughs.
: This bug could lead to a crash at C2OTP6+8 after a DIRLIST
: overflow condition.
:
	REMARK	%PATCH TO RESTORE DIRNOD CORRECTLY%
	ORG	DPT6B+16
	BC	0,0,0,0
	ORG	DPT6B+16
	STH	R0,DIRNOD-2,K1	:RESTORE DIRNOD
:
:
:  Patch to  a) Bypass checking DSKBIT bit array while writing error
:  log and accounting buffers,  b) To set total attempts at writing
:  account buffer to three, and c) To skip a block on failure after
:  three attempts, and repeat this atleast three times.
:
        IF      MSC                     :ONLY IF DISC SPECIFIED
:
	REMARK	%PATCH TO SET RETRY COUNT FOR WRITING ACCOUNT BUFFER TO 3%
	ORG	ERR1+0A
	BC	0,0
	ORG	ERR1+0A			:WRITE ERROR LOG BUFFER
	JFS	ERR1A			:IRRESPECTIVE OF DSKBIT BIT ARRAY
:
	ORG	ACNTDW+0A
	BC	0,0
	ORG	ACNTDW+0A		:WRITE ACCOUNT BUFFER IRRESPECTIVE
	JFS	ACNT1			:OF DSKBIT BIT ARRAY
:
	ORG	LSTBRW			:END OF DATA AREA BEFORE R/W AREA
RTRCNT	HS	1			:TOTAL COUNT OF RETRIES
BSKCNT	HS	1			:TOTAL # OF BLOCKS SKIPPED
:
	ORG	ACTWRT
	BC	0,0,0,0,0,0
	ORG	ACTWRT
	J	SPAPTR,,
	ORG	SPAPTR
:
	STM	R13,ACTSAV+8		:SAVE REGISTERS
	LIS	R13,3			:SET RETRY COUNT TO 3
	LIS	R14,3			:SKIP UPTO 3 BLOCKS
ACTWR0	ST	T2,ACTDSK+SHRPOS	:STORE SECTOR ADDR IN PARAM BLOCK
	SVC	SHARE,ACTDSK		:WRITE BUFFER TO DISK WITH DISMISS
	LB	T1,ACTDSK+SHRRS		:GET STATUS BYTE
	JE	ACT999			:OPERATION SUCCESSFUL
	SIS	R13,1			:ERROR, DECR RETRY COUNT
	JLEFS	ACTWR1			:JUMP IF FINISHED WITH 3 ATTEMPTS
	LIS	T1,1			:WRITE WITH DISMISS
	STB	T1,ACTDSK+SHRRS		:SAVE IN PARAM BLOCK
	AHM	T1,RTRCNT,,		:BUMP RETRY COUNT
	J	ACTWR0			:TRY AGAIN
:
:  Skip a Block
:
ACTWR1	LR	R14,R14			:HAVE WE SKIPPED THREE BLOCKS
	JLE	ACTWR3			:YES, GO FREEZE THE SUP
	ST	T2,CHKLST		:UPDATE LAST WRITE IN CHECKPOINT BLOCK
	AIS	T2,ACTSEC		:NEXT DISK ADDRESS
	CLI	T2,ACTEND		:CHECK FOR WRAP
	JLFS	ACTWR2			:JUMP ON NO WRAP
	LIS	T2,ACTSTA		:WRAP, FIRST ADDRESS
ACTWR2	ST	T2,ACTDSK+SHRPOS	:SAVE NEW ADDRESS IN PARAM BLOCK
	XI	T2,55000000		:INCLUDE VALIDITY FLAG
	ST	T2,ACCDSK,,		:TELL SLAVE FILE POSITION
	L	T2,ACTDSK+SHRPOS	:RESTORE T2
	LIS	T1,1
	AHM	T1,BSKCNT,,		:BUMP # OF BLOCKS SKIPPED
	LIS	R13,3			:SET RETRY COUNT TO 3
	SIS	R14,1			:DECR # OF BLOCKS SKIPPED
	J	ACTWR0			:TRY TO WRITE AGAIN
:
:  Skipped 3 blocks and still can't write!!!, Freeze the SUP.
:
ACTWR3	LHI	R13,EM03A0		:SUP FREEZE MSG 3A0
	LIS	R14,0
	LIS	R15,4			:SUBTYPE 4
	JAL	LINK,ERRFIL,,		:POST IT IN ERROR LOG
	SVC	GEN,SV.FRZ		:FREEZE THE SUP
:
SPAPTR	EQ	.
:
:  Restore R13,R14,R15 saved at the beginning of ACTWRT
:
	ORG	ACT999
	BC	0,0,0,0,0,0
	ORG	ACT999
	J	SPAPTR,,
	ORG	SPAPTR
:
	LM	R13,ACTSAV+8		:RESTORE REGISTERS
	LIS	T1,1
	STB	T1,ACTDSK		:SET FOR NEXT WRITE
	JR	K1			:RETURN FROM ACTWRT
:
SPAPTR	EQ	.
:
:  Patch to attempt writing error log buffers atmost 3 times.
:
	REMARK	%PATCH TO SET RETRY COUNT FOR WRITING ERROR-LOG BUFFER TO 3%
	ORG	LSTBRW+4
ETRCNT	HS	1			:COUNT OF TOTAL RETRIES
:
	ORG	ERR1A+16
	BC	0,0,0,0,0,0
	ORG	ERR1A+16
	J	SPAPTR,,
	ORG	SPAPTR
:
	LB	T1,ERRDK1+SHRRS		:WAS WRITE OF FIRST BUFFER SUCCESSFUL?
	JE	ERR3,,			:YES, CHECK SECOND BUFFER
	LIS	K2,3			:SET RETRY COUNT TO 3
ERRFI1	LIS	T1,1			:WRITE WITH DISMISS
	AHM	T1,ETRCNT,,		:BUMP TOTAL # OF RETRIES
	STB	T1,ERRDK1+SHRRS		:SAVE IN PARAM BLOCK
	SVC	SHARE,ERRDK1		:WRITE FIRST BUFFER
	LB	T1,ERRDK1+SHRRS		:WAS WRITE SUCCESSFUL?
	JE	ERR3,,			:YES, CHECK SECOND BUFFER
	SIS	K2,1			:NO, DECREMENT RETRY COUNT
	JGBS	ERRFI1			:TRY WRITING AGAIN
	J	ERR1A+1E,,		:EXHAUSTED ATTEMPTS, JUMP TO
					:DISK ERROR ANALYZER
ERRFI2	EQ	.
:
	ORG	ERR3+4
	BC	0,0,0,0,0,0
	ORG	ERR3+4
	J	ERRFI2,,
	ORG	ERRFI2
:
	LB	T1,ERRDK2+SHRRS		:WAS WRITE OF SECOND BUFFER SUCCESSFUL?
	JE	ERR4,,			:YES, CONTINUE
	LIS	K2,3			:SET RETRY COUNT 3
ERRFI3	LIS	T1,1			:WRITE WITH DISMISS
	AHM	T1,ETRCNT,,		:BUMP TOTAL # OF RETRIES
	STB	T1,ERRDK2+SHRRS		:SAVE IN PARAM BLOCK
	SVC	SHARE,ERRDK2		:ISSUE WRITE REQUEST OF SECOND BUFFER
	LB	T1,ERRDK2+SHRRS		:WAS WRITE SUCCESSFUL?
	JE	ERR4,,			:YES, CONTINUE
	SIS	K2,1			:NO, DECREMENT RETRY COUNT
	JGBS	ERRFI3			:TRY WRITING AGAIN
	L	K2,ERRDK2+SHRPOS	:EXHAUSTED, RESTORE K2
	J	ERR3+0A,,		:JUMP TO DISK ERROR ANALYZER
:
SPAPTR	EQ	.
:
: Patch to set retry count to 3 in CHKWRT routine.
:
	REMARK	%PATCH TO SET WRITE ATTEMPT COUNT TO 3 IN CHKWRT ROUTINE%
	ORG	CHKWRT
	BC	0,0,0,0,0,0
	ORG	CHKWRT
	J	SPAPTR,,
	ORG	SPAPTR
:
	LIS	T2,3			:SET RETRY COUNT TO 3
CHKWR1	LIS	T1,1			:WRITE WITH DISMISS
	STB	T1,CHKDSK+SHRRS		:STORE IN PARAM BLOCK
	SVC	SHARE,CHKDSK		:ISSUE WRITE REQUEST
	LB	T1,CHKDSK+SHRRS		:GET STATUS OF OP
	JER	LINK			:WRITE SUCCESSFUL, RETURN
	SIS	T2,1			:DECREMENT RETRY COUNT
	JGBS	CHKWR1			:TRY SOME MORE
:
: Tried 3 times and still can't write, proceed to freeze the SUP
:
	J	CHKWRT+1C,,		:EXHAUSTED, FREEZE SUP
:
SPAPTR	EQ	.
        EI      (MSC)

:*****************************************************************************
:
: Patch to remove use of obsolete nodups table when handling PROBE
: UNBORI request in PTL19. This table sometimes gives erroneous
: indication of the sup's knowledge of a node, causing a crash when
: C2APPEND is called to send a message to a node which SUPBPV indicates
: is not known to the supervisor.
:
:*****************************************************************************

	IF	FULLTI
	ORG	PTL19+28
	BC	0,0,0,0,0,0,0,0,0,0
	ORG	PTL19+28
	ELSE	:FULLTI
	ORG	PTL19+2A
	BC	0,0,0,0,0,0,0,0,0,0
	ORG	PTL19+2A
	EI	:FULLTI

	REMARK	%PATCH TO USE NODTBP INSTEAD OF NODUPS IN PTL19%

	L	T1,NODTBP,R13,R13	:CHECK FOR NODE TABLE ENTRY
	JLE	PTL19B			:JUMP IF NO NODE


:**********************************************************************
: This patch allows to swap links on nodes with 2 or more neighbors
: when LLEVEL option is used.
: DFIELDS 4/30/87
:**********************************************************************
:
	REMARK %PATCH FOR NETWORKS WITH LLEVEL OPTION%
	IF	LLEVEL
	ORG	SWAP+4
	BC	0,0,0,0
	ORG	SWAP+4
	CLHI	R12,2
	EI

:**********************************************************************
: This patch properly detects the invalid TID during the normal logins 
: Gamis 7/28/88
:**********************************************************************
:
	REMARK %PATCH TO DETECT INVALID TID DURING NORMAL LOGIN%
	ORG	T2TIDB+34
	BC	0,0,0,0
	ORG	T2TIDB+34
	JE	T2TDE1

:**********************************************************************
: This patch sends timing diagnostic msg to all nodes in the net.
: Gamis 8/23/88
:**********************************************************************
:
	REMARK %PATCH TO SEND TIMING DIAGNOSTIC MSG TO ALL NODES%
	ORG	PTLTD0-8
	BC	0,0
	ORG	PTLTD0-8
	CLR	C1,C3


:**********************************************************************
: This patch corrects the Supervfrom sending garbage to nodecode
: during normal login preprocessing in case of the following errors-
: a) Invalid TID. b) Invalid requesting host #. c) Host not on
: requesting node. d) Host down on requesting node. e) Null character
: string (hence no TID). and f) Requesting host is terminate-only.
: Register C5 was being used to send the message without being
: initialized.   ANC  12/20/88
:**********************************************************************
:
	REMARK %PATCH TO CORRECT SUP FROM SENDING GARBAGE TO NODECODE%
	ORG	LOGNZ2+4
	BC	0,0,0,0,0,0
	ORG	LOGNZ2+4
	J	SPAPTR,,
	ORG	SPAPTR
:
	SRLS	R14,1
	STH	R14,CBUF+4,,
	LHI	C5,0DB2
	J	LOGNZ2+0A,,
SPAPTR	EQ	.


:******************************************************************
: This patch handles correctly 0E message with null characters from
: NodeCode. Gamis 04/26/89.
:******************************************************************
	REMARK %PATCH TO PREVENT SUP CRASH ON NULL 0E MESSAGE%
	ORG	LGCHE5+0A
	BC	0,0,0,0,0,0
	ORG	LGCHE5+0A
	J	SPAPTR,,

	ORG	SPAPTR
	LCS	T1,1		:ASSUME NORMAL CIRCUIT
	LR	C4,R14		:FLAGS FROM LOGIN LIST
	NI	C4,@TIDM	:EXTRACT TID TYPE
	JNFS	LGCH51		:NORMAL CIRCUIT?
	LIS	T1,0		:NO, IT IS AN AUX CIRCUIT
LGCH51	STH	T1,AUXFLG,,	:SAVE THE CIRCUIT TYPE
	LI	C4,5000000
	J	LGCHE5+10,,
SPAPTR	EQ	.

	REMARK	%PATCH TO PROCESS HOST ON KEY ARRIVAL INSTEAD OF ON TIMEOUT%
:
: Define storage required by the KPROCS routine
:
	ORG	DATPTR
KPRTIN	HS	1		:TIMEOUT ITEM # SAVED HERE
KPRLNK	HS	2		:LINK SAVED HERE
DATPTR	EQ	.		:UPDATE POINTER TO FREE AREA

	ORG	H2KKEY+2	:HOST KEY HANDLER
	BC	0,0,0,0,0,0
	ORG	H2KKEY+2	:HOST KEY HANDLER
	JAL	LINK,KPROCS,,	:PROCESS HOST KEY THE NEW WAY

	ORG	SPAPTR
:
: This patch processes the KLIST entry, on HOST KEY arrival instead
: of postponing it to TIMEOUT.
:
KPROCS	HS	0
	ST	LINK,KPRLNK,,	:SAVE LINK
	EXHR	R12,R12		:POSITION TIMEOUT ITEM #
	LHR	R15,R12		:HALFWORD ITEM #
	STH	R15,KPRTIN,,	:SAVE TIMEOUT ITEM #
	JAL	LINK,KREMOVE,,	:REMOVE & GET KLIST ENTRY	
	HC	0,0		:ENTRY NOT THERE, INCONSISTENCY!
	OR	R14,C5		:INCLUDE THE HOST KEY (SEE H2KKEY)
	LR	C4,R14		:SAVE FOR LATER
	EXHR	C1,R13		:EXCHANGE HOST# AND NODE#
	NHI	C1,3FFF		:COMPUTE HOST #
	NHI	R13,3FFF	:COMPUTE NODE #
	STH	R13,SR1,,	:SAVE FOR HTIME
:
: Compute address of the HOST table entry
:
	LR	C2,C1		:HOST #
	LR	T1,C1		:TEMPORARY
	SLLS	T1,1		:2*HOST#
	SLLS	C2,3		:8*HOST#
	AR	C2,T1		:10d*HOST#
	LA	C2,HOST,C2,	:ADDRESS OF HOST ENTRY
	LHL	K1,HBASE,C2	:GET NODE# FROM ENTRY
	JE	KPROCC		:ENTRY NULL, MAKE FIRST ENTRY
:
: HOST has existing entries in the HOST table. Check if this HOST/NODE
: exists. Indicate duplicate host if this entry exits and is UP. If
: the entry does not exist, make/update entry for this HOST/NODE combo,
: only if the KEY matches with the KEY of an already existing UP entry. If
: there are no UP entries, CLEAR all DOWN entries and make a FIRST entry
: for this HOST/NODE. 
:
	LIS	C3,0		:INIT ADDR OF OLD ENTRY FOR NODE
	LIS	T2,0		:INIT ADDR OF LAST UP ENTRY
	LIS	T1,1		:BIT TEST POSITION FOR UP/DOWN FLAG
	JFS	KPROC2		:ENTER SEARCH LOOP

KPROC1	LA	C2,ENDHST,K1,	:EXTENSION ENTRY ADDR
	LHL	K1,HBASE,C2	:GET NODE # FROM TABLE
	JE	KPROC5		:NO MORE

KPROC2	CLR	K1,R13		:SAME NODE?
	JNFS	KPROC3		:NO
:
: Both host and node match. The host has an existing entry.
:
	TBT	T1,HSTAT,C2	:OLD ENTRY SHOULD NOT BE UP!
	JEFS	KPROC4		:UP, SKIP
	LR	C3,C2		:ADDR OF NODE'S OLD DOWN ENTRY
	JFS	KPROC4		:JUMP

KPROC3	TBT	T1,HSTAT,C2	:THIS ENTRY DOWN?
	JNFS	KPROC4		:YES, CONTINUE SCAN

	LR	T2,C2		:ADDR OF UP ENTRY

KPROC4	LHL	K1,HEXTP,C2	:EXTENSION PTR
	JN	KPROC1		:CONTINUE SCAN IF MORE
:
: Scan Complete. C3 contains the address of the old DOWN entry (if any)
: for this HOST/NODE. T2 contains the address of the last UP entry.
:
KPROC5	LR	T2,T2		:WERE ANY ENTRIES UP?
	JE	KPROC9		:NO
:
: Compare the reported KEY with the KEY of an UP entry in the HOST table
:
	CLB	C4,HKEY,T2	:SAME KEY?
	JN	KPRER1		:NO, SECURITY VIOLATION (DUPLICATE HOST)

	LBR	T1,C4		:ISOLATE KEY
	JE	KPRER1		:ZERO KEY MATCHES NOTHING

	LR	C3,C3		:WAS THERE AN OLD DOWN ENTRY FOR NODE?
	JEFS	KPROC6		:NO, FIND EXTENSION

	LR	C2,C3		:GET ADDRESS
	J	KPROCD		:UPDATE OLD ENTRY
:
: Find available extension in the HOST table for this entry
:
KPROC6	LA	C3,ENDHXT,,
	LHI	T2,ENDHST+0A-ENDHXT

KPROC7	LHL	T1,HBASE,C3,T2	:GET NODE #
	JEFS	KPROC8		:ZERO, AVAILABLE ENTRY

	AIS	T2,0A
	JLBS	KPROC7		:CONTINUE SCAN IF MORE
	HC	0,0		:CRASH, RAN OUT OF SPACE FOR EXTENSIONS

KPROC8	AR	C3,T2		:ADDRESS OF AVAILABLE ENTRY
	AHI	T2,ENDHXT-ENDHST :PTR VALUE
	STH	T2,HEXTP,C2	:ADD TO END OF LIST
	LR	C2,C3		:GET EXTENSION ADDRESS
	J	KPROCC		:MAKE ENTRY
:
: Clear old DOWN entries (T2=0).
:
KPROC9	LR	C2,C1
	LR	T1,C1		:TEMPORARY
	SLLS	T1,1		:DOUBLE
	SLLS	C2,3		:EIGHT TIMES OF HOST ID
	AR	C2,T1		:10 BYTES/PER HOST ENTRY
	LA	C2,HOST,C2,	:START OF TABLE ENTRIES FOR HOST
	JFS	KPROCB		:ENTER ZERO LOOP

KPROCA	LA	C2,ENDHST,C2,	:ENTRY ADDRESS

KPROCB	LHL	T1,HEXTP,C2	:REMEMBER EXTENSION PTR
	ST	T2,,C2		:ZERO 1ST WORD
	ST	T2,4,C2		:ZERO 2ND WORD
	STH	T2,8,C2		:ZERO 5TH HALF WORD
	LR	C2,T1
	JNBS	KPROCA		:MORE TO ZERO
:
: Make FIRST entry for this HOST/NODE.
:
	LR	C2,C1
	LR	T1,C1		:TEMPORARY
	SLLS	T1,1		:DOUBLE
	SLLS	C2,3		:EIGHT TIMES OF HOST ID
	AR	C2,T1		:10 BYTES/PER HOST ENTRY
	LA	C2,HOST,C2,	:ADDR

KPROCC	STH	R13,HBASE,C2	:STORE NODE #

KPROCD	LBR	T1,C4		:GET HOST KEY 
	JEFS	KPROCE		:JUMP IF EMPTY
	STB	T1,HKEY,C2	:UPDATE KEY
KPROCE	EXBR	C4,C4		:GET HOST TYPE
	LBR	T1,C4		:ISOLATE SAME
	JEFS	KPROCF		:JUMP IF EMPTY
	STB	T1,HTYPE,C2	:UPDATE HOST TYPE
KPROCF	EXHR	C4,C4		:SWITCH 2 HALF WORD
	LBR	T1,C4		:GET HOST COST
	JEFS	KPROCG		:JUMP IF EMPTY
	STB	T1,HCOST,C2	:UPDATE HOST COST
KPROCG	EXBR	T1,C4		:GET HOST STATUS
	STB	T1,HSTAT,C2	:UPDATE STATUS
	EXHR	R15,R15		:GET MXP & SLOT # TO RIGHT HALF
	NHI	R15,07F7F	:CLEAR ESCAPE BIT
	JEFS	KPROCH		:JUMP IF EMPTY
	STH	R15,MXPID,C2	:UPDATE MXP & SLOT #
:
:  Check source of timeout & act accordingly
:
KPROCH	LR	R12,R12		:WHO ORIGINATED KLIST ENTRY?
	JL	KPREXT		:TAKEOVER ORIGINATED KLIST, NO NEED TO LOG 100
:
: Host Status report originated the KLIST/TIMEOUT for this HOST. Post
: error log message 100 for this HOST.
:
	LHI	R13,EM0100	:ERROR # $8400
	LB	R14,HTYPE,C2	:GET HOST TYPE (PRODID)
	EXBR	R14,R14		:SHIFT LEFT
	EXHR	R14,R14		:TO LEFTMOST BYTE
	OI	R14,10000,C1	:MERGE WITH SUBTYPE 1(UP), HOST #
	EXHR	R15,R15		:SHIFT MXP & SLOT # BACK TO LEFT HALF
	OH	R15,SR1,,	:MERGE WITH NODE #
	JAL	LINK,ERRFIL,,	:POST IT IN ERROR LOG
:
: Check if the HOST is answered
:
	NI	C4,HASM		:SHUT/ANSWERED BIT
	JNFS	KPROCI		:SHUT

	LHI	R13,EM0100	:ERRFIL MSG # - HOST STATUS
	LB	R14,HTYPE,C2	:GET HOST TYPE (PRODID)
	EXBR	R14,R14		:SHIFT LEFT 
	EXHR	R14,R14		:TO LEFTMOST BYTE
	OI	R14,30000,C1	:MESSAGE # FOR HOST ANSWERED, HOST #
	JAL	LINK,ERRFIL,,	:POST IT TO ERROR LOG

KPROCI	JAL	LINK,HTIME,,	:SEND TIME TO HOST
	J	KPREXT		:RETURN
:
: KEY MISMATCH, TREAT AS UP HOST REPORTING UP ON ANOTHER BASE
: ERRLOG ERROR # 38 SUB 2. FUDGE OLD HOST TABLE ENTRY.
: SEND HOST REJECT MESSAGE (T-I 3 SUB 9, T-II 0F90)
:
KPRER1	LHL	C6,,T2		:GET UP TABLE STATUS
	LR	R14,C6
	NHI	R14,300		:PORT ARRAY BITS
	SLLS	R14,4		:POSITION FOR FUDGE
	NI	C6,HASM!HUPM	:STATUS BITS
	OR	R14,C6		:PLACE STATUS BITS
	LHL	C6,2,T2		:NODE #
	NHI	C6,MSKNOD	:LOP OFF ANY HIGH ORDER BITS FOR FUDGE
	OR	R14,C6		:PLACE FAKED OLD TABLE ENTRY
	EXHR	R14,R14
	OR	R14,R13		:NODE # REPORTING UP
	EXHR	R15,C1		:HOST #
	OHI	R15,2		:SUBTYPE 2
	LR	C6,R13		:REMEMBER REPORTING NODE FOR REJECT
	LHI	R13,EM0038	:ERROR #
	JAL	LINK,ERRFIL,,	:POST IT TO ERROR LOG
:
: SEND REJECT MESSAGE TO IMPOSTOR
:
	LI	R14,60000,C6	:MESSAGE LENGTH & NODE #
	LI	R15,0F908000,C1	:MESSAGE TYPE & HOST #
	STM	R14,CBUF-2	:PLACE MESSAGE
	JAL	LINK,C2APPEND,,	:SEND MSG TO NODE
KPREXT	LHL	R15,KPRTIN,,	:GET TIMEOUT ITEM #
	JAL	LINK,TREMOVE,,	:REMOVE ASSOCIATED TIMEOUT ENTRY
	L	LINK,KPRLNK,,	:RESTORE LINK
	JR	LINK		:RETURN
:
SPAPTR	EQ	.

:
: Patch to fix BUG in KREMOVE routine. When removing the last entry on KLIST
: with previous entries present, the KEND cell (which must contain the end
: bufferlet number) was being incorrectly updated with 0 instead of the new
: last bufferlet number. The new end bufferlet number was calculated in R14
: at KREM3, but KEND was being stored from K2 instead of R14. The wiping out
: of KEND resulted in lose of KLIST entries which eventually lead to crash
: at TIMHST where missing KLIST condition was detected. ANC 12/13/89.
:
	ORG	KREM3+8
	BC	0,0,0,0
	ORG	KREM3+8
	STH	R14,KEND	:SAVE LAST BUFFERLET #


	REMARK	%PATCH TO FIX IIX CIRCUIT HANDLING%
:
: SHC	DEC.14,1989
:
	ORG	BILCE2-24
	BC	0,0,0,0,0,0
	ORG	BILCE2-24
	J	SPAPTR,,

	ORG	SPAPTR
	STH	T1,SRCBUF
	NHI	K2,HIQM^-8
	LR	R14,K2
	J	BILCE2-18
SPAPTR	EQ	.


:-------------------:
: END OF PATCH FILE :
:-------------------:

	IF	SPATCH-SPAPTR
	REMARK	%*** ERROR *** ILLEGAL USE OF SPAPTR!!!%
	EI

	IF	SPAPTR-(BSUP+ESUP)
	REMARK	%*** ERROR ***  PATCH AREA OVERFLOWS ADDRESSABLE CORE%
	EI
	FO	SUPER
    k qâ