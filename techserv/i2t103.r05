	SUBTTL	NODEX.NAD. . . .ISIS-II/TYMNET-I NODE CODE
NC.VER	EQ	$8 10305		:TYMNET-I NODE CODE VERSION #
	IF	SAL

NC.VER	EQ	$8 20000!NC.VER		:DIFFERENT VERSION FOR SAL
	EI	(SAL)
	GL	NC.VER

:	SET UP DEFAULTS
	DEFAULT(CTRACE,1)		:CHARACTER TRACE SWITCH
	DEFAULT(LTRACE,1)		:LEP TRACE SWITCH
	DEFAULT(PERMEA,0)		:PERFORMANCE MEASUREMENT (OFF)
	DEFAULT(ACCT,SAL)		:ACCOUNTING SWITCH
	DEFAULT(CRSAVE,0)		:CRASH SAVE SWITCH (OFF)
	DEFAULT(DISNOD,1)		:DISPLAY NODE #
	DEFAULT(MICRO,0)		:MICROCODE LEVEL
	DEFAULT(PSGLAS,0)		:PRIMARY TO SECONDARY TRANSPARENT LOGIN
	DEFAULT(SPGLAS,0)		:SECONDARY TO PRIMARY TRANSPARENT LOGIN
	IF	1-SAL
PSGLAS	EQ	0			:DISABLE TRANSPARENT LOGINS IF NOT GATEWAY
SPGLAS	EQ	0
	EI	(1-SAL)
	GL	NHPORT

	MO	.,NODE

ESYNC	EQ	MICRO-1			:ENHANCED SYNC OPTION
	IF	ESYNC
NC.VER	EQ	$8 140000!NC.VER	:SET 2 MSB'S IF ENHANCED SYNC
	EI

:	REASONS FOR CRASHING:
:	OCTAL	HEX	REASON
:	 CRASH CODE

:	0	0	POWER FAILURE
:	1	1	MANUAL RESTART
:	2	2	---
:	3	3	GCI/GBI CRASH
:	4	4	---
:	5	5	WCI/WBI CRASH
:	6	6	WRE CRASH
:	7	7	---
:	10	8	UNKNOWN CRASH
:	11	9	---
:	12	A	---
:	13	B	CLEAR CRASH
:	14	C	PARITY ERROR
:	15	D	---
:	16	E	---
:	17	F	---
:	20	10	DISPATCHER CRASH
:	21	11	ILLEGAL INSTRUCTION
:	22	12	ILLEGAL SVC
:	23	13	KERNEL CRASH (KERNEL PARITY ERROR)
:	24	14	PROTECTION VIOLATION
	SUBTTL	DEFINITIONS

	IF	PERMEA

:	IF NOT DECLARED, DEFINE DEFAULT VALUES FOR SIZE AND RESOLUTION
:	OF PERMEA TABLE (F.TABL).

	DEFAULT(P.TIMS,$A 60*60)	:DEFAULT TIME EACH F.TABL SLOT REPRESENTS

:	THE FORMAT OF P.TIMS (NUMBER OF SECONDS PER TIME SLOT) IS CONVENIENT
:	FOR THE USER TO OFFER SUBSTITUTE VALUES. NOW REDEFINE P.TIMS IN
:	TERMS OF REMOTE CLOCK TICKS.
P.TIME	EQ	P.TIMS*RATE	:SUITABLE FOR CODE REFERENCE

	DEFAULT(P.NSLT,$A 36)		:DEFAULT NUMBER OF F.TABL SLOTS DESIRED

	EI	(PERMEA)

CHIST	MACRO[IF	CTRACE;	J	HIST			:CHARACTER HISTORY TRACE
	ELSE;	JR	R5;	EI]

LPHIST	MACRO[IF	LTRACE
:	***	HISTORY-KEEPING PATCH	***
	LHL	R2,LEX
	STH	R6,LHIST+0,R2
	STH	R7,LHIST+2,R2
	STH	R8,LHIST+4,R2
	STH	R9,LHIST+6,R2
	AIS	R2,8
	CLHI	R2,LEXSIZ
	JLFS	.+4			:FOLD INDEX
	LIS	R2,0
	STH	R2,LEX
	EI
]

:	THE 'PERMS' MACRO IS PROVIDED FOR USE IN PERFORMANCE MEASUREMENT
:	CODE. IF THE FLAG 'PERMEA' IS TRUE (POSITIVE), THEN CODE IS
:	ENABLED TO INCREMENT A FIELD COUNTER OR ADD A SPECIFIED VALUE
:	TO A FIELD. ALL FIELDS ARE INDEXED BY NETWORK LINE NUMBER. THE
:	ARGUMENTS ARE DESCRIBED IN THE MACRO DEFINITION.

:	ARGUMENTS, AS FOLLOWS:
:P1	NULL IF P4 CONTAINS VAULE TO BE ADDED TO FIELD,
:	  ELSE SCRATCH REG FOR USE TO BUMP COUNTER.
:P2	RL2 OR RL1. IF P5 NON-ZERO, THEN RL1.
:P3	FIELD NAME
:P4	VALUE TO BE ADDED TO FIELD UNLESS P1 NULL.
:P5	FLAG WHICH, WHEN NON-ZERO, INDICATES P2=RL INSTEAD OF RL2.
PERMS	MACRO(P1,P2,P3,P4,P5) [
	IF	PERMEA
Q	EQ	1`P1
	IF	Q-1			:IF P1 IS NON-NULL
Q1	EQ	Q			:SET FLAG FOR CODE TO INCREMENT FIELD
	ELSE				:NOT Q-1 (P1 IS NULL)
Q1	EQ	0			:CODE WILL ADD P4 VALUE TO FIELD
	EI	(Q-1)
Q5	EQ	P5			:Q5 TRUE IF P2=RL (LINE NUMBER) INSTEAD OF
					:RL2 (LINE NUMBER*2)


	IF	Q1			:INCREMENT FIELD COUNT, P1 SCRATCH REG
	LIS	P1,1
	IF	Q5
	AHM	P1,P3,P2,P2		:P2=RL (LINE NUMBER)
	ELSE				:NOT Q5
	AHM	P1,P3,P2		:P2=RL2 (2*LINE NUMBER)
	EI	(Q5)
	ELSE				:NOT Q1 (P4 VALUE ADDED TO FIELD COUNT)
	IF	Q5
	AHM	P4,P3,P2,P2		:P2=RL (LINE NUMBER)
	ELSE				:NOT Q5
	AHM	P4,P3,P2		:P2=RL2 (2*LINE NUMBER)
	EI	(Q5)
	EI	(Q1)
	EI	(PERMEA)
]

NM	EQ	NLINES			:COMBINED LINK COUNT, SYNC LINE AND M-BOARD.
DOWLOA	EQ	((NM-1)*NLINES)!PERMEA	:SWITCH FOR DOWNSTREAM-LOAD CAPABILITY...
					:   ...NEED 1 SYNC LINE, 2 NEIGHBORS
					:   (OR IF PERFORMANCE MEASURING TURNED ON!)

Q	EQ	0F0000-NRATE		:DEFINE ADDRESS FOR SEGMENT 15D

MFASTC	EQ	0F0004
MSLOWC	EQ	MFASTC+4
RGMT	EQ	MSLOWC+4
RTEMP	EQ	RGMT+4
RVOLT	EQ	RTEMP+1
RVERNO	EQ	RVOLT+1

NPORT	EQ	$A256			:ALWAYS 256 FOR BASES

	IF	SAL
	TITLE	ISIS:  TYMNET-I NODE CODE:  GATEWAY
	DEFAULT(NHPORT,NPORT/8)		:(DEFAULT IS 32 PORTS, UNLESS OVERRIDDEN)
PPH	EQ	NPORT			:PORTS/HOST
HSHIFT	EQ	8			:PORT--HOST SHIFT FACTOR
SAL	EQ	1			:INSURE THIS HAS CORRECT NUMERIC VALUE
SUP	EQ	0			:CAN'T HAVE A SUP IF STAND-ALONE
	ELSE
	IF	PERMEA
	REMARK	%	PERFORMANCE MONITORING ENABLED
	REMARK	%	==============================
	EI	(PERMEA)
SAL	EQ	0			:INSURE THIS HAS CORRECT VALUE
NHPORT	EQ	NPORT			:NUMBER OF HOST PORTS
	IF	NUMHST-2		:(3 OR 4 HOSTS...64 PORTS EACH)
PPH	EQ	NPORT/4			:PORTS/HOST
HSHIFT	EQ	6			:PORT--HOST SHIFT FACTOR
	ELSE				:(2 HOSTS...128 PORTS EACH)
PPH	EQ	NPORT/2			:PORTS/HOST
HSHIFT	EQ	7			:PORT--HOST SHIFT FACTOR
	EI	(NUMHOST>2)
	DEFAULT(S1LIC,0)		:AVOID DIAGNOSTICS FOR UNUSED SLOTS
	DEFAULT(S2LIC,0)
	DEFAULT(S3LIC,0)
	EI	(SAL)

	IF	PTHRU
PTHRU	EQ	40
	EI


Q	EQ	.			:DEFINE GTx...TOTAL NUMBER OF GROUPS UP TO GROUP x
	ORG	0			:THIS WILL SIMPLIFY DATA ALLOCATION DIRECTIVES BELOW.
QQ	EQ	0;	RE	NM
GT|QQ|	BS	$A NGRP|QQ|
QQ	EQ	QQ+1;	NOLIST;	ER;	LIST
:	COMPUTE TOTAL NUMBER OF GROUPS OF ALL LINES FOR DATA ALLOCATIONS
:	DEFINED BELOW. ONE GRP SERVICES 16 CHANNELS ON A SYNCHRONOUS LINK.
NUMGRP	EQ	.
GTG
	ORG	Q


	IF	PTHRU
NPTHRU	EQ	0			:NO PASS THROUGHS FOR THIS CONFIGURATION
	ELSE
NPTHRU	EQ	$A192			:MAXIMUM NUMBER OF CIRCUITS PASSING THRU THIS NODE
	EI

CBSZ	EQ	10			:SIZE OF BFLETS
CBSZL	EQ	4			:LOG2 SIZE OF BFLETS
	GL	NBFLET
NBFLET	EQ	((NM*3+NUMGRP)*8+NPORT+NPTHRU)*2	:NUMBER OF BUFFERLETS
	IF	SUP
NBFLET	EQ	90*NM+NBFLET		:EXTRA BUFFERLETS IF SUP PRESENT
	EI
NBFLET	EQ	NBFLET!7F		:FORCE IT TO USE UP EXTRA IN 1-K
	IF	NBFLET*8-0FFF8
NBFLET	EQ	0FFF8/8;	EI
IRSIZE	EQ	200*NM-4		:INPUT RING SIZE DEPENDENT ON NUMBER OF LINES
ORSIZE	EQ	IRSIZE			:OUTPUT RING SIZE SAME AS INPUT

:	BUFFER STORAGE FOR CIRCUIT TRAFFIC.(PORT INTERFACE TRAFFIC, SUP TRAFFIC,
:	AND PASSTHRU TRAFFIC)
NBUF	EQ	(NPORT+$A16+NPTHRU)*2	:NPORT BUFFERS, 16 SUP BUFFERS, PASSTHRUS
	SUBTTL	ISIS CONTROL TABLE

:	CTA -- Control Table Area
:	fixed locations for constants and temp storage for dispatcher

	IF	SAL;	SEG	0E;	GL	CTA,CTASIZ;	EI
BIAS	EQ	0E0000-.		:SEGMENT ADDRESS ADJUSTMENT (SEGMENT 14d)

NCTA	BND	100			:THE START OF THE CONTROL TABLE
	IF	SAL
CTA	WC	82			:'CNTRL'...CONTROL FLAGS...ACK ZAPPERS, PORTS N/REUSABLE
	ELSE;	WC	80			:'CNTRL'...CONTROL FLAGS...ACK ZAPPERS;	EI
	WC	CTASIZ			:'CTASIZE'...SIZE OF THIS AREA
	WC	S0SIZE			:'AREAS'...SIZE OF EACH AREA
	WC	S1SIZE
	WC	S2SIZE
	IF	SAL;	WC	0
	ELSE;	WC	S3SIZE;	EI
	WC	0
	WC	0
	WC	0

	IF	CRSAVE
	WC	S7SIZE
	WC	S8SIZE
	IF	SAL
	WC	0
	ELSE;	WC	S9SIZE; EI
	WS	4

	ELSE	(1-CRSAVE)
	WS	7
	EI	(1-CRSAVE)
	HC	$A 10			:'NPROT'...COUNT OF USABLE PROTECTION BYTES
	BC	6,5,6,6,6,6,6,6,6,6,0,0,0,0 :'PROT'...MEMORY PROTECTION REQUIREMENTS

	WC	NSTART			:'IENTRY'...ENTRY POINT ADDRESS
	WC	0			:'DSTART'...DDT EXECUTION START ADDRESS
	WC	STATUS			:'STATUS'...POINTER TO FRONT-PANEL DISPLAY CELL
	WC	N.HTBL+BIAS		:'HTBLPT'...POINTER TO HOST TABLE
	WC	N.UTBL+BIAS		:'PTBLPT'...POINTER TO PORT TABLE
	WC	N.PTBL+BIAS		:'TTBLPT'...POINTER TO TERMINATION TABLE
	WC	AIRING			:'IRPNT'...INPUT -- RING DISCRIPTOR START ADDRESS
	WC	AORING			:'ORPNT'...OUTPUT -- RING DISCRIPTOR START ADDRESS
	WC	STOPIN			:'IBKPNT'...INPUT -- BACKPRESSURE ARRAY
	WC	STOPO			:'OBKPNT'...OUTPUT -- BACKPRESSURE ARRAY
	WC	N.PCTB+BIAS		:'PCBPNT'...PROJECT CODE TERMINATOR BITS POINTER

	WS	1			:FOR FUTURE EXPANSION!

	HC	1			:'MAXHST'...NUMBER OF HOSTS ON SLOT
	HC	NPORT-1			:'MAXPRT'...NUMBER OF HIGHEST PORT ON SLOT
	HC	IRSIZE			:'IMAXSZ'...INPUT -- SIZE OF INPUT RING IN BYTES
	HC	ORSIZE			:'OMAXSZ'...OUTPUT -- SIZE OF OUTPUT RING IN BYTES
	HS	1			:'SLOTNO'...NUMBER OF THIS SLOT
	HC	NC.VER			:'SVER'...SLOT'S CODE VERSION NUMBER

N.HTBL	HC	HST0			:TABLE OF HOST NUMBERS

N.UTBL	HC	NHPORT			:TABLE OF HOST PORTS

N.PTBL	HS	NPORT			:PERMUTER TABLE (PORT 0--CONTROL)

N.PCTB	HC	4,0,0,10,0,0,0,0,4	:PROJECT CODE TERMINATOR BITS
	HC	0,0,10,0,0,0,0

E.NCTA	HS	0			:END OF TABLE

	BND	100			:FORCE TO END OF PAGE
CTASIZ	EQ	.-NCTA			:SIZE OF THE CONTROL TABLES
	IF	SAL;SEGE	EQ	CTA;SESIZE	EQ	CTASIZ;	EI
	SUBTTL	S E G M E N T   0 --- V A R I A B L E S
	IF	SAL
	SEG	0			:SEGMENT 0 USED FOR LOCAL VARIABLES
SEG0	HS	0
S0AREA	HS	0
	ELSE
S0AREA	BND	100			:FORCE TO PAGE BOUNDARY
SEG0	EQ	0
	EI	(SAL)
BIAS	EQ	.
:	SIMULATED 620 CORE.  SUP REFERS TO <here> AS LOCATION 0 AND
:	TO <here>+2*N AS LOCATION N.


UPDOWN	EQ	.-BIAS;	HC	0,0			:LOC "0"...HOST UP/DOWN FLAG
STATUS	EQ	.-BIAS;	HC	0			:LOC "2"...CONSOLE STATUS DISPLAY

	HC	(CPOINT+2)/2		:LOC "3"...POINTER TO CRASH POINTER
	HC	PTHRU!20		:LOC "4"...ASSEMBLY FLAGS CONTROLING PASSTHROUGHS, 
					:20 CAUSES US TO GET INVOICE NUMBER IF INITIATING
					:	AUX CIRCUIT.
LEPREJ	EQ	.-BIAS;	HC	0			:LOC "5"...NUMBER OF LEPRETS PERFORMED
CRASHC	EQ	.-BIAS;	HC	$8100126		:LOC "6"...CRASH CODE
DOWSWI	EQ	.-BIAS;	HC	0			:LOC "7"...DOWNSTREAM SWITCH...0 = FREE
					:<0 MEANS HIGH BIT SET, REST IS SOURCE BUFFER INDEX,
					:	STATE 0
					:>0 SOURCE BUFFER INDEX, STATE 1

	ORG	BIAS+10			:FORCE TO LOC 10 IN LOCAL ADDRESS SPACE
TRPSD	EQ	.-BIAS;	WC	70F0,NSTART		:OLD TRACE PSD SAVED HERE
	WC	TRACE			:WHERE WE TRANSFER TO ON TRACE TRAP

DOWLIN	EQ	.-BIAS;	HC	-1			:CURRENT DOWNSTREAM-LOAD LINE NUMBER
DOWINX	EQ	.-BIAS;	HS	1			:CURRENT DOWNSTREAM-LOAD FILL INDEX

	BND	10			:FORCE TO A NICE BOUNDARY
REBC1	EQ	.-BIAS;	HC	0			:LOC "20"...COUNTS TIMES BUFFER STORAGE RESERVE LIST
					:	WAS MOVED TO MAIN FREE LIST
REBC2	EQ	.-BIAS;	HC	0			:LOC "21"...COUNTS TOTAL NUMBER OF BUFFER ZAPS DONE BY
					:	QUARTER SEC LOGIC
BFZ	EQ	.-BIAS;	HC	-1			:LOC "22"...LAST BUFFER ZAPPED
CPOINT	EQ	.-BIAS;	HC	0,0			:LOC "23, 24"...STORED INTO FROM CRASH
	IF	PERMEA
PERDMP	EQ	.-BIAS;	HC	0			:LOC "25"...SET NEGATIVE DURING PERFORMANCE DUMP
	ELSE
CFROM	EQ	.-BIAS;	HC	-1,-1			:LOC "25, 26"...WHERE CRASH WAS CALLED FROM

	BND	10			:FORCE TO REASONABLE BOUNDARY
CRREG	EQ	.-BIAS;	WS	10			:CRASH REGISTER SAVE AREA
	EI	(PERMEA)
PTRCTR	EQ	.-BIAS;	HC	0			:COUNT OF NON-NULL PERMUTER TABLE ENTRIES
					: WHICH WERE OVER-WRITTEN
RMPTW	EQ	.-BIAS;	HS	1			:COUNTER FOR "RM24" ITTERATIONS
BFUCTR	EQ	.-BIAS;	HS	1			:COUNT OF LEP2 MESSAGES REJECTED DUE
					: NON-ZERO BF

	ORG	$8 BIAS+100*2		:LOC o'100 IN Varian IMAGE
MACHNO	EQ	.-BIAS
	HC	MACHNM			:NODE NUMBER AT SIMULATED 620 LOCATION 100 OCTAL

VERNO	EQ	.-BIAS;	HC	NC.VER			:VERNO REFERENCED BY LEPRECHAUN

DLOCK	EQ	.-BIAS;	HC	0			:DEBUGGER LOCK
DSWICH	EQ	.-BIAS;	HC	0			:0 OR 1 TO 16 FOR DOWNSTREAM LINE NUMBER
CRSHCT	EQ	.-BIAS;	HC	0			:CRASH COUNT

:	SUPERVISOR'S BEGINNING-OF-RECORD-INDICATOR.
:	THE FIELD THAT HEADS PHYSICAL RECORDS.
:	DIRECTION BIT IS SETUP IN YRESET, INTO BORI
SBORI	EQ	.-BIAS
	IF	NM;	RE	NM;	HC	1000;	ER;	EI
	HS	10-NM

:	SUPERVISOR SHOULD NOT TRY TO STORE PAST HERE

:	LINE INDEXED PERMUTER TABLE ADDRESSES FOR THE SUP.
IOTA	EQ	.-BIAS
Q	EQ	0;	RE	NM			:TABLE OF ADDRESSES IN 620 IMAGE
	HC	$A IOT|Q|/2
Q	EQ	Q+1;	NOLIST;	ER;	LIST;	HS	10-NM

:	NUMBER OF GROUPS ON EACH LINE (NUMBER OF CHANNEL/(10 HEX))
GROUPN	EQ	.-BIAS
Q	EQ	0;	RE	NM;	HC	$A NGRP|Q|
Q	EQ	Q+1;	NOLIST;	ER;	LIST;	HS	10-NM

:	LINE INDEXED ARRAY OF MACHINE NUMBERS OF NEIGHBOR NODES.
MACH	EQ	.-BIAS
Q	EQ	0;	RE	NM;	HC	$A NEIG|Q|
Q	EQ	Q+1;	NOLIST;	ER;	LIST;	HS	10-NM

:	HOST DESCRIPTOR FOR BASE
	IF	SAL
HOST0	EQ	.-BIAS;	HC	HST1+8000
UP0	EQ	.-BIAS;	HC	NHPORT		:-1 IF DOWN, NUMBER OF PORTS IF UP
	HS	6			:OTHER 3 HOST SLOTS UNDEFINED
	ELSE
HOST0	EQ	.-BIAS;	HC	HST0+8000
UP0	EQ	.-BIAS;	HC	NKU			:-1 IF DOWN, NUMBER OF PORTS IF UP
Q	EQ	8000
	HC	0,Q,0,Q,0,Q		:ENTRIES FOR OTHER HOSTS
	EI	(SAL)

:	SEE LEP0 WHERE NODE TYPE IS SENT TO SUP
N940L	EQ	.-BIAS;	HC	8000+NUMHST*40+NM	:SUPERNODE BIT,HOST COUNT,LINE COUNT

:	PATCHABLE ERROR COUNTER LIMITS. THEY SHOULD START AT LOC. "216"
LRTLIM	EQ	.-BIAS;	HC	$A400			:LINE RETRANSMISSION REPORT THRESHOLD
LERLIM	EQ	.-BIAS;	HC	$A12			:LINE ERROR REPORT THRESHOLD
LOVLIM	EQ	.-BIAS;	HC	$8 40			:LINE OVERLOAD REPORT THRESHOLD
	IF	1-SAL

:	SLOT LICENCES
:	FIRST BIT ON MEANS ALLOWED TO BUILD AUX CIRCUITS
	WS	0
N.LIC	EQ	.-BIAS;	WC	0,S1LIC,S2LIC,S3LIC
	EI	(1-SAL)

:	END OF AREA THAT THE SUPERVISOR CAN REFERENCE BY FIXED LOCATIONS

:	IOT AND BR ARE SIMILIARLY ALLOCATED 2 DIMENSIONAL ARRAYS INDEXED BY
:	LINE AND CHANNEL NUMBERS. CHANI IS INDEXED BY LINE. IT GIVES THE
:	CHANNEL 0 DISPLACEMENT FOR IOT ( OR BR) FOR A GIVEN LINE.

:	BYTE DISPLACEMENT FOR BR AND IOT FOR CHANNEL 0 OF A LINE
CHANI	EQ	.-BIAS
QQ	EQ	0;	RE	NM;	HC	GT|QQ|*20
QQ	EQ	QQ+1;	NOLIST;	ER;	LIST
	RE	10-NM;	HC	GTG*20;	NOLIST;	ER;	LIST
	HC	GTG*20

:	CFOB IS A 2 DIMENSIONAL ARRAY OF ATTENTION BITS, ONE BIT FOR EACH
:	CHANNEL. CFOBA INDEXED BY LINE GIVES THE STARTING HALFWORD ADRS OF THE
:	ATTENTION BITS OF A LINE.

:	DISPLACEMENT TO CFOB FOR CHANNEL 0 OF A LINE
CFOBA	EQ	.-BIAS
QQ	EQ	0;	RE	NM;	HC	GT|QQ|*2
QQ	EQ	QQ+1;	NOLIST;	ER;	LIST;	HC	GTG*2

:	THE STORAGE FROM FROM "ONES" TO "ENDONE" IS SET TO ALL-1'S
ONES	EQ	.-BIAS
STOPIN	EQ	.-BIAS;	WS	NPORT/20		:BACKPRESSURE ARRAY FOR HOST INPUT...0 FOR BP ON
STOPO	EQ	.-BIAS;	WS	NPORT/20		:BACKPRESSURE ARRAY FOR HOST OUTPUT...0 FOR BP ON
ENDONE	EQ	.-BIAS


:	THE CELLS FROM FLAGS TO ENDZRO ARE INITIALIZED TO ZERO ON STARTUP
FLAGS	EQ	.-BIAS
	HS	1			:HERE START SEVERAL ARRAYS OF ATTENTION BITS THAT ARE
					:	TOGGLED ON AND OFF TO INDICATE BUFFER HOLDING
					:	INFO OR BUFFER EMPTY.  FLAG BITS ARE ADDRESSED
					:	RELATIVE TO THE SYMBOL FLAGS.  THE BIT
					:	DISPLACEMEETFOR EACH BUFFER IS CONTAINED IN A
					:	"BF" HALFWORD.  BF IS INDEXED BY BUFFER NUMBER.
SUPBIT	EQ	.-BIAS
RSUP	EQ	SUPBIT-FLAGS
	HS	1			: A BIT ON FOR EACH LINE THAT HAS SUP INFO TO INPUT
TOPORT	EQ	.-BIAS
RTOP	EQ	TOPORT-FLAGS		:TOPORT ATTENTION BITS ACTIVATE BASE PORT INPUT CODE
	HS	NPORT/10		:BITS ON WHEN CHARS COMING FROM NET GOING OUT TO PORT
LOGGER	EQ	.-BIAS
RLOG	EQ	LOGGER-FLAGS
	IF	SAL;	HS	NPORT/10		:BITS ON WHEN LOGON CHARS WAITING
	ELSE;	HS	PPH/8			:BITS ON WHEN LOGON CHARS WAITING TO BE SENT TO SUP;	EI	(SAL)
	IF	SAL
DETACH	EQ	.-BIAS
RDET	EQ	DETACH-FLAGS
	HS	(NHPORT+0F)/10		:BITS ON FOR PORTS LOOKING FOR ORANGE BALL OR ZAPPER
	EI	(SAL)
CFOB	EQ	.-BIAS
RCFOB	EQ	CFOB-FLAGS
	HS	NUMGRP			:BITS ON FOR SYNCH LINE CHANNELS THAT HAVE NONZERO BCT
CFOBI	EQ	.-BIAS;	HS	1			:CFOB FOR INTERNAL CIRCUITS
PCFOB	EQ	.-BIAS;	HS	NUMGRP			:MASKS OUT PROCESSED CFOB BITS. RMAKE SCHEDULING AID.
PCFOBI	EQ	.-BIAS;	HS	1			:PCFOB FOR INTERNAL CIRCUITS
BPSF	EQ	.-BIAS;	HS	NUMGRP			:BACKPRESSURE FLAGS. FILTERS RMAKE WORK.
BUSY	EQ	.-BIAS;	HS	NUMGRP			:USED TO COMPUTE LINE OVERLOAD
ACP	EQ	.-BIAS;	WS	NPORT/20		:ACTIVE PORT. PORT TO HOST IS PART OF ACTIVE CIRCUIT
ACKWAIT	EQ	.-BIAS;	WS	NPORT/20		:WAITING FOR ACK ON THIS PORT
CTERM	EQ	.-BIAS;	WS	NPORT/20		:CIRCUIT TERMINATED...SET IF CIRCUIT BUILT TO PORT
NPIIN	EQ	.-BIAS;	WS	NPORT/20		:PORT IN INPUT WAIT
HPFLAG	EQ	.-BIAS;	WS	NPORT/20		:BIT ON MEANS THIS IS HOST PORT
LOGON	EQ	.-BIAS;	WS	NPORT/20		:PORT IN NORMAL LOGON STATE...CHARS SENT TO SUP
	IF	SAL
LOGGING	EQ	.-BIAS;	WS	NPORT/20		:PORTS IN LOGON MODE
LOGECHO	EQ	.-BIAS;	WS	NPORT/20		:PORTS IN LOGON TO WHICH TO APPLY ECHO
	IF	SPGLAS+PSGLAS
SEMICO	EQ	.-BIAS; WS	NPORT/20		:FLAG FOR SEMI-: AFTER USERNAME
	EI	(SPGLAS+PSGLAS)
ECHOMSK	EQ	.-BIAS;	WS	NPORT/20		:PORTS WHICH MAY ECHO IF LOGECHO = 1
AUX	EQ	.-BIAS;	WS	NPORT/20		:PORTS WITH AUX CIRCUIT TID
ASCII	EQ	.-BIAS;	WS	NPORT/20		:PORTS NON-2741 TID
HAFDUX	EQ	.-BIAS;	WS	NPORT/20		:PORTS HALF-DUPLEX TID
YBT1	EQ	.-BIAS;	WS	NPORT/20		:YELLOW BALL TIMEOUT 1
YBT2	EQ	.-BIAS;	WS	NPORT/20		:YELLOW BALL TIMEOUT 2

IXTTBL	EQ	.-BIAS;	BS	NPORT			:TYMNET PORTS IN ISIS ORDER (INDEX BY ISIS PORT)
TXITBL	EQ	.-BIAS;	BS	NPORT			:ISIS PORTS IN TYMNET ORDER (INDEX BY TYMNET PORT)
TIDTBL	EQ	.-BIAS;	BS	NPORT			:TID'S FOR TYMNET PORTS
	ELSE	(1-SAL)

B4STAT	EQ	.-BIAS;	BS	NPORT			:B4 STATUS IF NON-ZERO
AVLB	EQ	.-BIAS;	HS	PPH/8			:AVAILABLE LOGON BUFFERS
ACLB	EQ	.-BIAS;	HS	PPH/8			:ACTIVE LOGON BUFFERS
:	AUX KEY IS 0 IF NO BUFFER IS ASSIGNED, ELSE = ASSIGNED BUFFER NUMBER
AUXKEY	EQ	.-BIAS;	BS	NPORT
:	SLOT KEY IS ORDERED IN BUFFER ORDER, ONE BYTE/BUFFER
SLKEY	EQ	.-BIAS;	HS	PPH
:	INTKEY IS ORDERED IN BUFFER ORDER, 1 HALFWORD/BUFFER
INTKEY	EQ	.-BIAS;	WS	PPH
ADIALC	EQ	.-BIAS;	WS	PPH			:AUX DIALECT KEY
AOHOST	EQ	.-BIAS;	WS	PPH			:AUX ORIGINATION HOST
DIALCT	EQ	.-BIAS;	HS	NPORT			:DIALECT CODE FOR CIRCUIT REQUEST
OHOST	EQ	.-BIAS;	HS	NPORT			:ORIGINATION HOST FOR CIRCUIT REQUEST
	EI	(SAL)

USWICH	EQ	.-BIAS;	HS	1			:0, OR OUTPUT BUFFER NUMBER FOR UPSTREAM BUFFER
LO0	EQ	.-BIAS;	HS	1			:LOGON...INTERNAL CIRCUIT FLAG
LO1	EQ	.-BIAS;	HS	2			:LOGON...INVOICE #
LO2	EQ	.-BIAS;	HS	1			:LOGON...DEST. HOST #
LO3	EQ	.-BIAS;	HS	1			:LOGON...ORIG. NODE #
LO4	EQ	.-BIAS;	HS	1			:LOGON...ORIG. HOST
LO5	EQ	.-BIAS;	HS	1			:LOGON...ORIG. PORT
LO6	EQ	.-BIAS;	HS	2			:LOGON...XXX
LO7	EQ	.-BIAS;	HS	1			:LOGON...DIALECT
LO8	EQ	.-BIAS;	HS	1			:LOGON...TID
PORT	EQ	.-BIAS;	HS	1			:CURRENT PORT #
IPORT	EQ	.-BIAS;	HS	1			:CURRENT ISIS PORT #
BUFNUM	EQ	.-BIAS;	HS	1			:CURRENT BUFFER NUMBER
TEMP	EQ	.-BIAS;	HS	2			:TEMP STORE
TEMP1	EQ	.-BIAS;	HS	2			:TEMP STORE
PORTSV	EQ	.-BIAS; HS	1			:TEMP PORT SAVE AREA

ZERO	EQ	.-BIAS;	HS	1			:A DATA WORD OF 0
ENDZRO	EQ	.-BIAS			:END OF AREA TO ZERO OUT ON CRASH

XLIMIT	EQ	.-BIAS;	BS	NPORT			:TRANSMIT LIMIT FOR ISIS (ISIS PORT ORDER)
RET4	EQ	.-BIAS;	WS	1			:SAVE RETURN ADDRESS HERE
TIRET4	EQ	.-BIAS;	WS	1			:SAVE RETURN ADDRESS HERE
FREELT	EQ	.-BIAS; HS	1			:BFLET FREE LIST HEAD (BFLET#)
REBL	EQ	.-BIAS;	HS	1			:FREE LIST POINTER FOR RESERVE STORAGE LIST
SECBEG	EQ	.-BIAS;	HS	1			:PTR TO BEGINNING OF OSEC RECORD. USED BY RMAKE.
	IF	DOWLOA
DLDHTO	EQ	.-BIAS; HS	2			:DLLOAD TIMER WAITING FOR TARGET LINE# FROM HOST
DLDHTC	EQ	.-BIAS; HS	1			:COUNTER OF HOST TARGET LINE# TIMEOUTS
	EI	(DOWLOA)

TO9	EQ	.-BIAS;	WS	1			:LINK FOR TIMEOUT LIST PROCESSER
NTLIST	EQ	$A 2*SAL+10		:NUMBER OF TLIST ENTRIES
	IF	PERMEA;NTLIST	EQ	NTLIST+1;	EI
TLIST	EQ	.-BIAS;	HS	(NTLIST+1)*5		:TIME OUT LIST. SEE TIMOUT, TOPUT.
:	ACTIVE LIST ENTRY= HALFWORD CHAIN PTR, FULLWORD ROUTINE ADRS, FULLWORD DUETIME
:	FREE LIST POINTER IS AT TLIST. ACTIVE LIST CHAIN PTR IS AT TLIST+2.
:	TLIST+4 NOT USED
:	ACTIVE LIST IS ORDERED BY TIME

LTHROT	EQ	.-BIAS;	HS	1			:COUNTER AND FLAG USED BY LEPRECHAUN
					:	TO INHIBIT EXCESSIVE SUP OUTPUT
	IF	SUP
FULTI.-BIAS;	HS	1			:FLAG, GOES NEGATIVE WHEN LOCAL SUP IS ALMOST FULL
	EI

	IF	LTRACE
LEX	EQ	.-BIAS;	HS	1			:LEPSN HISTORY KEEPING INDEX
LEXSIZ	EQ	400&(-8)		:NUMBER OF BYTES OF STORAGE USED FOR LEP HISTORY
LHIST	EQ	.-BIAS;	BS	LEXSIZ			:LEP HISTORY DATA AREA
	EI	(LTRACE)
	IF	CTRACE
HISX	EQ	.-BIAS;	HS	1
HISTAB	EQ	.-BIAS;	WS	100
	EI	(CTRACE)

	IF	PERMEA
	SUBTTL	PERFORMANCE MONITORING

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:		** DUMP PERFORMANCE DATA **

:	THE DOWN-STREAM LOAD/DUMP MECHANICS ARE USED TO DUMP THE F.TABL
:	(NODE PERFORMANCE DATA) THROUGH THE "HOST" CIRCUIT.  IF, AT "DOW00",
:	WE DETECT A 'LINE NUMBER' WITH A VALUE EQUAL TO "P.HCHR", WE SET
:	THE "PERDMP" NEGATIVE.  THIS GIVES CONTROL TO THE "DOWD0" ROUTINE, WHICH
:	SENDS THE "F.TABL" DATA UNTIL A ZAPPER ARRIVES FROM THAT PORT.
:	ARRIVES FROM THE HOST.
P.HCHR	EQ	80			:THIS CHARACTER TRIGGERS F.TABL DUMP IF THE
					: PERMEA SWITCH IS TRUE.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:	THE PERFORMANCE MONITORING SUBSYSTEM IS RUN BY 3 TABLES - P.TABL,
:	F.TABL, AND F.RELC. P.TABL HOLDS THE RAW, UNFORMATTED DATA GATHERED
:	ON A REAL-TIME BASIS. F.TABL WILL GET UPDATED PERIODICALLY WITH THE
:	P.TABL DATA, USING A TIME INDEX (F.TIDX). F.RELC PROVIDES MAPPING
:	INFORMATION TO UPDATE P.TABL DATA INTO F.TABL. THE DATA FROM F.TABL
:	IS IN THE FORMAT SEEN BY THE HOST DATA-GATHERING PROGRAM.

:	F.TABL, BECAUSE OF ITS VERY LARGE SIZE, IS MAINTAINED AT THE END
:	OF MEMORY SPACE.

TIMOVL	EQ	.-BIAS;	HS	20
DLDPIX	EQ	.-BIAS;	HS	2			:POINTER TO DUMP AREA
P.PORT	EQ	.-BIAS;	HS	2			:SUMMARY OF NUMBER OF PORTS
P.PTHR	EQ	.-BIAS;	HS	2			:SUMMARY OF NUMBER OF PASSTHROUGHS
P.SECC	EQ	.-BIAS;	HS	2			:SUMMARY OF NUMBER OF 1-SECOND OCCURANCES
P.XCTR	EQ	.-BIAS;	HS	1			:SUMMARY OF NUMBER OF EXEC LOOP ITTERATIONS
P.RETK	EQ	.-BIAS;	HS	1			:SUMMARY OF NUMBER OF RETAKES
	EI	(PERMEA)
PATCH	EQ	.-BIAS;	WS	80			:PATCH AREA. USED FOR DEBUGGING OR EXPERIMENTATION.
	SUBTTL	C O M M U N I C A T I O N S   D A T A   A R E A

ZFLAG	EQ	.-BIAS;	HS	1			:FLAG FOR TIME TO SET UP A NEW OUTPUT ROTOR STRING;
LRESET	EQ	.-BIAS;	HS	NM			:COUNTER OF RESETS ACCEPTED. CHECKED IN SEC16.;
INDATA	EQ	.-BIAS;	HS	NM			:COUNT OF GOOD PACKETS RECEIVED DURING 16 SEC. PERIOD.;
ANYDATA	EQ	.-BIAS;	HS	NM			:COUNT OF GOOD PACKETS RECEIVED DURING 256 SEC. PERIOD.;
INERR	EQ	.-BIAS;	HS	NM			:LINE ERROR MESSAGES;
LINER	EQ	.-BIAS;	HS	NM			:LINE ERROR COUNTER FOR 4 MINUTE DIAGNOSTICS;
LOVRLD	EQ	.-BIAS;	HS	NM			:LINE OVERLOAD COUNTER FOR 4 MINUTE DIAGNOSTICS.;
OVLD	EQ	.-BIAS;	HS	NM			:NEW LINE OVERLOAD COUNTER FOR 4 MINUTE DIAGNOSTICS.;
BORI	EQ	.-BIAS;	HS	NM			:BEGINNING-OF-RECORD-INPUT;
TSLR	EQ	.-BIAS;	HS	2*NM			:TIME SINCE LAST RESET.;
TIMEB	EQ	.-BIAS;	HS	2*NM			:BACKPRESSURE DUE TIME.
	IF	NLINES

:	****	201-LINE DATA AREA	****
ZN	EQ	$A68			:OUTPUT SECTOR HAS 1 HW OF RECORD SIZE, 1HW OF HEADER,
					:30 HW OF CONTENTS, 2 HW OF CKSUMS.

	IF	ESYNC
YN	EQ	100			:100 HEX BYTE YRG REQUIRED BY MICROCODE
	ELSE	(1-ESYNC)
YN	EQ	$A(33+1+2+92)*2
	EI	(1-ESYNC)
:	BYTE SPACE REQUIRED FOR INPUT RING FOR ONE LINE IS [ NUMBER OF
:	HALFWORDS FOR LONGEST RECORD PLUS ONE FOR UNSHIFTED LINE FORMAT PLUS
:	2 FOR THE TRAILING PTR LAG FROM THE LEAD POINTER IN YTD PROCESSING PLUS
:	MAX. NUMBER OF INTERRUPTS PER SECOND (600)  TIMES THE MAXIMUM
:	LATENCY (120/1000 SECONDS) ] TIMES 2 BYTES PER INTERRUPT
:	MINIMUM LATENCY IS 12 MILISECS. (SEE SYNC). MAXIMUM SYNC TARDINESS IS
:	100d MILISECS. (NOTE TARDINESS CHECK IN SYNC)


:	OSEC SECTOR FLAGS.  16 BITS PER LINE.  LEFT BYTE IS BITS SET AS SECTOR
:	IS FILLED BY RMAKE.  RIGHT BYTE BITS ARE ON FOR RECORDS THAT HAVE BEGUN
:	--AND MAYBE COMPLETED TRANSMISSION--BUT HAVE NOT BEEN ACK'ED YET.
OSF	EQ	.-BIAS;	HS	NLINES;
:	BIT N OF WORD M (M=0, NLINES-1) IS ON IF A RECORD IS RECEIVED
:	AND READY FOR RECORD TEARDOWN FROM SECTOR N OF THE ISEC SPACE ALLOCATED
:	TO LINE M.
ISF	EQ	.-BIAS;	HS	NLINES;
:	RETRANSMISSION FLAG.  SET=-1 BY ZR WHEN RETRANSMITTING AN OUTPUT
:	SECTOR TO PREVENT RMAKE FROM OVERWRITING THE SECTOR.
RTF	EQ	.-BIAS; HS	NLINES;
:	CURRENT OUTPUT SECTOR. INCREMENTS FORWARD AS TRANSMITTER
:	SEND RECORDS OUT TO THE SYNC LINE. THE LOW ORDER 2 BITS POINT TO ONE
:	OF THE 4 OUTPUT SECTORS OF A GIVEN LINE.
COS	EQ	.-BIAS;	HS	NLINES;
:	CURRENT ASSEMBLING OUTPUT SECTOR. USED BY RMAKE TO
:	PREPARE RECORDS FOR PICKUP BY THE OUTPUT TRANSMITTER.
CAOS	EQ	.-BIAS;	HS	NLINES;
:	CURRENT DISASSEMBLING SECTOR. USED BY YTD AND RTD TO
:	DISASSEMBLE AND ACKNOWLEDGE INPUT RECORDS IN CONSECUTIVE ORDER.
CDIS	EQ	.-BIAS;	HS	NLINES;
:	3 STATE INPUT JUMP SWITCH. INPUT RECEIVER LINE IS
:	LOOKING FOR A RESET, A BORI, OR AND END OF RECORD.
YSUB	EQ	.-BIAS;	HS	2*NLINES;
LRR	EQ	.-BIAS;	HS	NLINES			:LAST-RECORD-RECEIVED;
LRA	EQ	.-BIAS;	HS	NLINES			:LAST-RECORD-ACKNOWLEDGED;
LINRTR	EQ	.-BIAS;	HS	NLINES			:RETRANSMISSION RECEIVED COUNTER;
LINRTS	EQ	.-BIAS;	HS	NLINES			:RETRANSMISSION SENT COUNTER;
LCROSS	EQ	.-BIAS;	HS	NLINES			:CROSS TALK COUNTER;
BADACK	EQ	.-BIAS;	HS	NLINES			:OUT OF RANGE ACK RECEIVED COUNTER;
YTP	EQ	.-BIAS;	HS	NLINES			:YRG TRAILING PTR.
					:YTD CHASES AFTER THE REAL TIME LEAD POINTER;
YRSIZE	EQ	.-BIAS;	HS	NLINES			:SYNC RECEIVER RECORD SIZE. SEE YLBORI, YLEOR.;
YALIVE	EQ	.-BIAS;	HS	NLINES			:FLAG TO TELL SEC16 IF LINE INPUT INTS ARE HAPPENING;
ZALIVE	EQ	.-BIAS;	HS	NLINES			:FLAG TO NOTICE IF OUTPUT INTS ARE HAPPENING;
ZSUB	EQ	.-BIAS;	HS	2*NLINES		:SUBROUTINE TO CALL WHEN TIME TO MAKE A NEW ROTOR;
LST	EQ	.-BIAS;	HS	2*NLINES		:CHANGE IN FASTC THAT OCCURS WHEN YRES1 RUNS;
PALR	EQ	.-BIAS;	HS	NLINES			:POSITION AT LAST RESET;
LSS	EQ	.-BIAS;	HS	NLINES			:NUMBER OF BYTES INPUT DURING "LST" INTERVAL;

:	WHEN A BUFFER CARRYING CIRCUIT INFO GOES NON-ZERO (GETS INFO TO HOLD),
:	AN ATTENTION BIT IS SET (SEE WCI,WBI). THIS BIT WILL BE NOTICED BY
:	AN INDEPENDENT PROCESS THAT WANTS TO EMPTY THE BUFFER AND RESET THE
:	ATTENTION BIT. BF IS A BUFFER NUMBER INDEXED ARRAY OF BIT DISPLACEMENTS
:	INTO THE FLAGS ARRAY. BF ENTRIES FOR SYNC LINES ARE GENERALLY SET UP
:	AT CIRCUIT BUILDING TIME BY LEP2.

	WS	0
BF	EQ	.-BIAS;	WS	NPORT*2
BCT	EQ	BF+2		:HW BUFFER BYTE COUNT (INTERLEAVED WITH BF)
:	THE FIRST 2*NPORT BUFFERS ARE INITIALIZED AS NPORT INPUT-OUTPUT
:	BUFFER PAIRS. THE TYMNET CONVENTION IS THAT THE EVEN MEMBER OF
:	THE PAIR IS FOR CHARS GOING TO A HOST AND THE ODD MEMBER HOLDS CHARS
:	BOUND FOR AN OUTPUT TRANSMITTER. THEREFORE, FOR BASES, THE BUFFERS GOING
:	TO THE HOST HAVE FIXED ASSIGNMENTS AND THE BUFFERS GOING FROM THE BASE
:	INTO THE NET OR AWAY FROM THE HOST ARE ASSIGNED BY THE SUP. THE FIRST
:	NPORT EVEN BF'S ARE ASSIGNED TO TOPORT AND THE ODD BF'S IN BASES ARE
:	ASSIGNED BY THE SUP.

:	SUPERVISORY CHANNELS HAVE 10 HEX INPUT ATTENTION BITS ALL IN THE HALFWORD
:	AT SUPBIT. A BIT IN SUPBIT IS TURNED ON AS RTD BUFFERS ARRIVING SUP
:	INFO. WHEN THE LEPRECHAUN RELAYS SUP INPUT AS OUTPUT (OR CREATES SUP
:	OUTPUT FROM A RESIDENT SUP) A SYNC LINE ATTENTION BIT IN CFOB IS SET
:	FOR CHANNEL 0 OF THE UPSTREAM LINK.
:	NOTE THAT THE TYMNET CONVENTION FOR SUP BUFFER PAIRS IS THAT THE EVEN BUFFER
:	IS FOR OUTPUT AND THE ODD ONE IS FOR INPUT.

:	SUP INPUT RECEIVED ATTENTION FLAG FOR LINE 0
SUPBUF	EQ	.-BIAS;	WS	20
PASSBUF	EQ	.-BIAS;	WS	NPTHRU*2		:PASSTHRU BUFFER PAIRS

BB	EQ	.-BIAS;	WS	NBUF			:PTR TO FIRST BUFLET IN A BUFFER. MEANINGLESS IF BCT=0.
BE	EQ	.-BIAS;	WS	NBUF			:PTR TO LAST BUFFERLET.


	IF	PERMEA

:	P.TABL - UNFORMATTED, CURRENT PERFORMANCE DATA
P.TABL	EQ	.-BIAS;	HS	0
P.CHNI	EQ	.-BIAS;	HS	NM			:NORMAL CHARACTERS INPUT;
P.CHSI	EQ	.-BIAS;	HS	NM			:SUPERVISOR CHARACTERS INPUT;
P.CHNO	EQ	.-BIAS;	HS	NM			:NORMAL CHARACTERS OUTPUT;
P.CHSO	EQ	.-BIAS;	HS	NM			:SUPERVISOR CHARACTERS OUTPUT;
P.PKSM	EQ	.-BIAS;	HS	NM			:SIZE OF PACKETS MADE;
P.PKSR	EQ	.-BIAS;	HS	NM			:SIZE OF PACKETS RECEIVED;
P.PKTT	EQ	.-BIAS;	HS	NM			:NUMBER OF PACKETS MADE;
P.PKRC	EQ	.-BIAS;	HS	NM			:NUMBER OF PACKETS RECEIVED;
P.LRNR	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS RECEIVED;
P.LRNS	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS SENT;
P.LRRS	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS RESTRICTED BY PACKET SIZE;
P.BPNS	EQ	.-BIAS;	HS	NM			:NUMBER OF BACKPRESSURE RECORDS SENT;
P.BPNR	EQ	.-BIAS;	HS	NM			:NUMBER OF BACKPRESSURE RECORDS RECEIVED;
P.LOVH	EQ	.-BIAS;	HS	NM			:NUMBER OF 1/2 SECOND LINE OVERLOAD OCCURRENCES;
P.LNER	EQ	.-BIAS;	HS	NM			:NUMBER OF LINE ERRORS;

:	DEFINE TEMPORARY STORAGE FOR FAST MOVING COUNTERS
T.CHNI	EQ	.-BIAS;	WS	NM
T.CHSI	EQ	.-BIAS;	WS	NM
T.CHNO	EQ	.-BIAS;	WS	NM
T.CHSO	EQ	.-BIAS;	WS	NM
T.PKSM	EQ	.-BIAS;	WS	NM
T.PKSR	EQ	.-BIAS;	WS	NM
	EI	(PERMEA)

LSF	EQ	.-BIAS;	HS	1			:BIT ARRAY...1 IF LINE SPEED HASN'T BEEN REPORTED;
LVF	EQ	.-BIAS;	HS	1			:RMAKE AND SECH R/ AND S/ LINE INDEXED OVLD BITS;
LINOUT	EQ	.-BIAS;	HS	1			:FLAG ARRAY FOR LINES WHICH ARE OUT (=0);


GAP	EQ	.-BIAS;	RE	$A16;	HC	-1,-1;	NOLIST;	ER;	LIST
	HC	-1,$805253
RESET2	EQ	.-BIAS;	HC	MACHNM,-1		:RESET IS 33 WORDS OF 1'S FOLLOWED BY 2 WORD RESET
	WS	0			:FORCE TO WORD BOUNDARY

NROTOR	EQ	$A9			:NUMBER OF ROTOR ENTRIES/LINE

ROTORX	EQ	.-BIAS;	HS	NLINES			:THE CURRENT ROTOR INDEX FOR EACH LINE

ROTOR	EQ	.-BIAS;	WS	(NROTOR+1)*NLINES*2	:THE SPACE RESERVED FOR ROTORS

	BS	2			:AN EXTRA HALFWORD OF STORAGE
OSEC	EQ	.-BIAS;	BS	(NLINES+NUMSAT)*ZN*4	:RMAKE OUT BUFFER TO SYNC LINES;
ISEC	EQ	.-BIAS;	HS	(NLINES+NUMSAT)*20*4	:RTD INPUT BUFFER. PREPARED BY YTD.
YRG	EQ	.-BIAS;	HS	(YN+2)*NLINES/2		:SYNCHRONOUS LINE INPUT BUFFER. DIRECT FROM I/O.
EYRG	EQ	.-BIAS;
	IF	DOWLOA
DOWOBF	EQ	.-BIAS;	HS	$A33			:DOWNSTREAM LOADING OUTPUT BUFFER;
DOWCIS	EQ	.-BIAS;	BS	1			:DOWNSTREAM LOADING INPUT SECTOR;
DOWCDIS	EQ	.-BIAS;	BS	1			:DOWNSTREAM LOADING DISASSEMBLY INPUT SECTOR;
DOWSF	EQ	.-BIAS;	HS	1			:DOWNSTREAM LOAD INPUT SECTOR FLAGS;
DOWROT	EQ	.-BIAS;	HC	$A 0,66,0,DOWOBF,0	:ROTOR ENTRY FOR DOWN-STREAM OUTPUT;
	EI	(DOWLOA)
	EI	(NLINES)

:	BEGINING OF PERMUTER TABLES. EACH LINK HAS 10 HEX TIMES THE
:	NUMBER OF CHANNELS HALFWORDS ALLOCATED HERE. EACH ENTRY CORRESPONDS
:	TO A CHANNEL ON A LINK. SIGN BIT ON IS FOR HIGH SPEED CIRCUIT. THE LOW
:	ORDER 15 BITS IS THE BUFFER NUMBER ARGUMENT FOR WCI,GCI, ETC. WHICH
:	BUFFER THE CIRCUIT DATA. CHANNEL 0 FOR EACH LINE IS ASSEMBLED TO A SUP
:	BUFFER NUMBER. ALL LINES CAN CARRY SUP INFO. THE OTHER ENTRIES ARE -1 IF
:	UNUSED. A NORMAL ACTIVE ENTRY IS CREATED BY THE SUP AS IT BUILDS A
:	CIRCUIT (SEE LEP2).
IOT	EQ	.-BIAS			:THE START OF THE TABLE
Q	EQ	0;	RE	NM
	RA	$A 10
IOT|Q|	EQ	.-BIAS;	HS	16*NGRP|Q|;	RA	0
Q	EQ	Q+1;	NOLIST;	ER;	LIST
IOTI	EQ	.-BIAS;	HS	10			:INTERNAL CIRCUITS PERMUTER TABLE
NIOTB	EQ	.-BIAS-IOT		:NUMBER OF BYTES TAKEN UP BY PERMUTER TABLES

:	A HALFWORD FOR EACH SYNC LINE CHANNEL. COUNTS TOWARD
:	ZERO FOR EACH CHAR SENT. BACKPRESSURE IS PASSIVELY INVOKED
:	WHEN A BR VALUE REACHES ZERO. BR IS REFRESHED FROM BACKPRESSURE RECORDS
:	RECEIVED FROM THE NEIGHBOR NODE. SEE RTD BACKPRESSURE PROCESSING.
BR	EQ	.-BIAS;	BS	NIOTB			:SAVE AS MANY HALF-WORDS AS FOR PERMUTER TABLES

:	ACCOUNTING DATA
	WS	0			:START ADDR
AAARY	EQ	.-BIAS
AAINV	EQ	.-BIAS;	WS	NPORT			:INVOICE #

	IF	ACCT
AAIC	WS	NHPORT			:HOST INPUT CHAR COUNT
AAOC	WS	NHPORT			:HOST OUTPUT CHAR COUNT
AASAVE	WS	2			:REG SAVE AREA
AAPINV	WS	1			:TEMP AREA FOR PRIMARY NET INVOICE #
AALINS	WS	1			:LAST INVOICE # SENT TO SUP
AACPN	HS	1			:CURRENT PORT #

	EI	(ACCT)
	WS	0
AAASIZ	EQ	.-BIAS-AAARY		:SIZE OF ACCT DATA

	IF	ACCT
:	'CANNED' ACCOUNTING ADDENDUM MESSAGE
	HS	0
	BS	1			:FILLER
AAMSG	BC	6,0B7,0			:ISIS ACCOUNTING MESSAGE
AAMSG1	HS	2			:ACCT INVOICE RECORD
	EI	(ACCT)

ESEG0	EQ	.-BIAS			:END OF SEG 0
ENDCOR	EQ	ESEG0/2			:RANGE ADDRESSABLE BY SUP


	WS	0
S0SIZE	EQ	.-S0AREA		:SIZE OF SEGMENT 0
	SUBTTL	S E G M E N T   1 --- C O D E   A R E A
	IF	SAL
	SEG	1			:CODE GOES INTO SEGMENT 1
SEG1	HS	0

	ELSE
SEG1	BND	100			:FORCE TO A NEW PAGE BOUNDARY
	EI	(SAL)


CBIAS	EQ	.-10000			:THE BIAS FOR CODE STORAGE


:	CONSTANT (ARRAY) STORAGE

IOTPNT	RE	NM			:POINTERS TO I/O TABLES
	HC	$A IOT|(.-IOTPNT)/2|;	ER
Q	EQ	0C001+2*NPORT
IOTC0	RE	NM			:INITIALIZATION FOR CHANNEL 0
	HC	.-IOTC0+Q;	NOLIST;	ER;	LIST
	IF	NLINES

OSECPT	HS	0			:START OF OUTPUT SECTOR ARRAYS
Q	EQ	OSEC
	IF	NUMSAT;	RE	NUMSAT;	HC	Q;Q	EQ	ZN*8+Q;	ER;	EI
	RE	NLINES-NUMSAT;	HC	Q;Q	EQ	ZN*4+Q;	ER

OSOFST	EQ	.-CBIAS			:OUTPUT SECTOR OFFSET
Q	EQ	0;	RE	4;	HC	Q;Q	EQ	Q+ZN;	ER
	IF	NUMSAT;	RE	4;	HC	Q;Q	EQ	Q+ZN;	ER;	EI

ISECPT	HS	0			:START OF INPUT SECTOR ARRAYS
Q	EQ	ISEC
	IF	NUMSAT;	RE	NUMSAT;	HC	Q;Q	EQ	40*8+Q;	ER;	EI
	RE	NLINES-NUMSAT;	HC	Q;Q	EQ	40*4+Q;	ER

YRGPNT	HS	0			:START OF SYNCHRONOUS LINE INPUT BUFFERS
QQ	EQ	YRG
	RE	NLINES
	HC	QQ
QQ	EQ	YN+2+QQ
	ER

ACKMSK	HS	0			:MASK USED FOR ACK, RECORD #
	IF	NUMSAT;	RE	NUMSAT;	HC	0F;	ER;	EI
	RE	NLINES-NUMSAT;	HC	7;	ER
SECMSK	HS	0			:MASK USED FOR SECTOR NUMBER
	IF	NUMSAT;	RE	NUMSAT;	HC	7;	ER;	EI
	RE	NLINES-NUMSAT;	HC	3;	ER

ACKSHF	HS	0			:SHIFT REQUIRED FOR ACK
	IF	NUMSAT;	RE	NUMSAT;	HC	4;	ER;	EI
	RE	NLINES-NUMSAT;	HC	3;	ER

BKPRCN	HC	$8 40,200,1000,2400	:BACK-PRESSURE CONSTANTS

RSF	HC	00000,00000		:RESTRICTED SECTOR FLAGS
	HC	08040,02010
	HC	090C0,06030
	HC	0B0D0,0E070
	HC	0F0F0,0F0F0
	IF	NUMSAT

RSF8	HC	00000,00000,00000,00000	:SATELITE RESTRICTED FLAGS
	HC	08040,02010,00804,00201
	HC	081C0,06030,0180C,00603
	HC	083C1,0E070,0381C,00E07
	HC	087C3,0E1F0,0783C,01E0F
	HC	08FC7,0E3F1,0F87C,03E1F
	HC	09FCF,0E7F3,0F9FC,07E3F
	HC	0BFDF,0EFF7,0FBFD,0FE7F
	HC	0FFFF,0FFFF,0FFFF,0FFFF
	EI	(NUMSAT)
	EI	(NLINES)

:	HANDY INDEXABLE HALFWORD AND FULLWORD BIT MASKS
HMASK	EQ	.-CBIAS
	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1
ROTORP	HS	0			:AN ARRAY OF POINTERS TO EACH LINE'S ROTOR
					:	TABLE IN ROTOR ORDER
Q	EQ	0;	RE	NLINES;	HC	ROTOR+Q
Q	EQ	((NROTOR+1)*8)+Q	:NEXT ROTOR
	ER

ROTORT	HS	0			:TABLE OF ROTOR ENTRY INDICIES
Q	EQ	.;	RE	NROTOR;	HC	(.-Q)*4;	ER
	HC	0			:LAST ENTRY IS FOLD-POINT, LOCATION OF TRANSFER

ROTORI	HS	0			:TABLE OF INDEX INDICIES
	RE	2
Q	EQ	.;	RE	NROTOR;	HC	.-Q;	ER;	ER

:	CODE PATCH AREA
CPATCH	WS	20

:	TRACE LOGIC AREA
TRSUB	HS	0			:ADDRESS OF TRACE AREA IN REAL SPACE
TRACE	EQ	.-CBIAS			:ADDRESS OF TRACE AREA IN EXECUTION ADDRESS SPACE
	STM	R14,PATCH+24		:SAVE REGS
	LHL	R15,PATCH		:GET INDEX
	AIS	R15,2			:INCR IT
	NHI	R15,1E			:WRAP IF NECESSARY
	STH	R15,PATCH		:SAVE INDEX
	LHL	R14,TRPSD+6		:GET LOW HW OF ADDR
	STH	R14,PATCH+2,R15		:STORE ADDR IN RING
	JFS	TRACEX			:SKIP
:	PATCH AREA FOR TESTS, ETC.
	HS	$A 14
TRACEX	LM	R14,PATCH+24		:RESTORE REGS
	UPSW	TRPSD			:RETURN TO RUNNING CODE
	HS	20			:EXTRA SPACE FOR PATCHING

:	GENERAL MACHINE FAILURE
FAILCD	BC  $8	1,0,14,20,21,22,23,24	:FAILURE CODES
	WS	0			:FORCE TO WORD BOUNDARY
FAIL	WS	2			:PSD SAVED HERE
	WS	2			:R0,R1 SAVED HERE

	LB	R0,FAILCD,R1		:GET THE FAILURE REASON
	SLHLS	R0,6
	OHI	R0,$8 100026		:GENERATE CRASH CODE
	CLHI	R1,2
	JL	FAIL1			:QUICK CRASH FOR POWER OR MANUAL RESTART
	STM	R2,CRREG+8,,		:SAVE THE REGISTERS
	LM	R14,FAIL+8		:GET THE REST
	STM	R14,CRREG,,		:SAVE R0, R1
	LM	R14,FAIL
	IF	PERMEA
	STM	R14,F.TPSD,,		:SAVE FAILURE PSD
	EI	(PERMEA)
	ST	R15,CPOINT,,		:SAVE FAILURE ADDRESS
	LCS	R1,1
	ST	R1,CFROM,,		:FLUSH PLACE CALLED FROM
FAIL1	STH	R0,CRASHC,,		:SAVE CRASH CODE
	J	START			:AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH	STM	R0,CRREG,,		:SAVE REGISTERS AND
	ST	R10,CPOINT,,
	LIS	R0,$8 10		:FAKE UNKNOWN CRASH
	LCS	R1,1			:FROM NOWHERE
	LHL	R2,0,R10		:CHECK WHERE CALLED FROM
	JNFS	CRASH1			:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10		:GET CRASH CONDITION
	LB	R2,2,R10		:GET CALLING REGISTER
	L	R1,CRREG,R2,		:GET CONTENTS OF REGISTER
CRASH1	SLHLS	R0,6			:MAKE CRASH REASON
	OHI	R0,$8 100026
	STH	R0,CRASHC		:SAVE CRASH CODE
	ST	R1,CFROM,,		:SAVE PLACE CRASHED FROM

:	ENTER HERE WITH RESTART
START	HS	0

	IF	CRSAVE
:	SAVE SEGMENTS 0,2 AND 3 
	LI	R1,S0SIZE-4
CRSAV0	L	R0,SEG0,R1,		:COPY SEG0 TO SEG7
	ST	R0,SEG7,R1,
	SIS	R1,4
	JGEBS	CRSAV0

	LI	R1,S2SIZE-4
CRSAV1	L	R0,SEG2,R1,		:COPY SEG2 TO SEG8
	ST	R0,SEG8,R1,
	SIS	R1,4
	JGEBS	CRSAV1

	IF	1-SAL
	LI	R1,S3SIZE-4
CRSAV2	L	R0,SEG3,R1,		:COPY SEG3 TO SEG9
	ST	R0,SEG9,R1,
	SIS	R1,4
	JGEBS	CRSAV2
	EI	(1-SAL)
	EI	(CRSAVE)

NSTART	EQ	.-CBIAS			:FIRST-TIME START ADDRESS
	LIS	R1,1
	AHM	R1,CRSHCT		:COUNT THE CRASH
	IF	PERMEA;	AHM	R1,F.TCCT,,;	EI
	LIS	R0,0
	ST	R0,ONFMI,,		:EMPTY OUTPUT RING
	ST	R0,INFMI,,		:EMPTY INPUT RING
	IF	DOWLOA;	STH	R0,DOWSWI		:CANCEL DOWNSTREAM LOAD;	EI
	IF	SUP;	TS	NODECR,,		:INFORM SUP OF RESTART;	EI
	IF	SAL
	LIS	R0,$A 11		:REPORT HOST "GONE"
	LIS	R1,0
	LIS	R2,4
	JAL	R4,SLOR			:START-LOGICAL-OUTPUT-RECORD
	LIS	R0,0
	JAL	R4,PUTCH		:GARBAGE PADDING FOR "KEY"
	JAL	R4,PUTW			:GARBAGE PADDING FOR HOST #, # PORTS
	JAL	R4,PUTH			:SET REL. HOST 0
	LIS	R0,3			:SET HOST GONE
	STH	R0,UPDOWN		:AND REMEMBER IT
	JAL	R4,PUTCH
	JAL	R4,ELOR			:END-LOGICAL-OUTPUT-RECORD
	ELSE
	LHI	R1,NKU-1		:FOR ALL KERNEL PORTS:
START1	RBT	R1,ACP			:CANCEL ALL ACTIVE KERNEL PORTS
	JEFS	START2			:SKIP IF NOT SET
	SBT	R1,RZAPEM,,		:TELL KERNEL TO ZAP ALL ACTIVE PORTS
START2	SIS	R1,1
	JGEBS	START1
	EI	(SAL)
	LHI	R5,NPORT-1		:NOW, FOR ALL PORTS:
START3	RBT	R5,ACP			:FLUSH OUT ALL ACTIVE PORTS
	JEFS	START4			:SKIP IF NOT SET
	LIS	R0,3			:ZAP IT
	LR	R1,R5
	LHI	R2,ZAPMSG
	JAL	R4,SLOR
	JAL	R4,ELOR
START4	SIS	R5,1
	JGEBS	START3			:DO FOR ALL PORTS

	LA	R0,FAIL			:INITIALIZE RESTART
	SVC	SYS,0
	JAL	R10,CRASH		:NON-SKIP RETURN...CRASH
	JAL	R0,IZT			:INITIALIZE TIMEOUT LIST
	JAL	R0,IZYZ			:INITIALIZE SYNC LINES

	JAL	R2,AAINIT		:INIT ACCOUNTING

	LHI	R1,ENDONE-ONES-2	:INITIALIZE A LOT OF STORAGE
	LCS	R0,1
IZ1	STH	R0,ONES,R1
	SIS	R1,2
	JGEBS	IZ1
	LHI	R1,ENDZRO-FLAGS-2
	LIS	R0,0			:CLEAR A LOT OF MISCELANY
IZ0	STH	R0,FLAGS,R1
	SIS	R1,2
	JGEBS	IZ0
	IF	SUP

	LA	R1,NOSO			:CLEAR SUPERVISOR COMMUNICATIONS AREA
IZSUP1	STH	R0,SUPBASE,R1,
	SIS	R1,2
	JGEBS	IZSUP1
	EI

	LIS	R0,0			:ZERO BF,BCT,BB,BE FOR ALL BUFFERS
	LHI	R1,NBUF*4*3-4
IZBF	ST	R0,BF,R1
	SIS	R1,4
	JGEBS	IZBF

	LHI	R1,NM*4-2		:SET UP SUP BUFFERS BF'S
IZBF0	LHL	R2,SUPBF,R1		:GET VALUE FROM TABLE
	STH	R2,SUPBUF,R1,R1		:INIT BF
	SIS	R1,2			:DO IT FOR ALL ACTIVE LINES
	JGEBS	IZBF0

	IF	SAL
	LHI	R1,(NPORT-1)*8		:BF'S FOR ALL PORTS SET UP AS REMOTES
	LA	R2,RTOP*8+NPORT-1
IZBF3	STH	R2,BF+4,R1		:STORE TOWARD THE PORT BF'S
	ELSE

	LHI	R1,(NKU-1)*8		:SEE COMMENT AT BF FOR INITIAL PORT ASSIGNMENTS
	LHI	R2,NKU-1
	LHI	R3,NKU*2-1
	LA	R4,RTOP*8+NKU-1
IZBF1	STH	R4,BF,R1		:STORE TOWARD-HOST BF'S FOR KERNEL
	SIS	R4,1
	SBT	R2,HPFLAG		:SET KERNEL PORT AS A HOST PORT
	SIS	R2,1
	SBT	R3,AVLB			:SET BOTH BUFFERS NOT AVAILABLE FOR LOGON
	SIS	R3,1
	SBT	R3,AVLB
	SIS	R3,1
	SIS	R1,8
	JGEBS	IZBF1

	LHI	R1,(PPH-NKU)*8-4	:HOST 0 BUFFERS NOT USED ARE USED FOR CIRCUIT BUILDING
	LA	R2,((RLOG*4)+PPH)*2-1
IZBF2	STH	R2,NKU*8+BF,R1
	SIS	R2,1
	SIS	R1,4
	JGEBS	IZBF2

	LHI	R1,(NPORT-PPH-1)*8	:BF'S FOR ALL OTHER SLOTS SET UP AS REMOTES
	LA	R2,RTOP*8+NPORT-1
IZBF3	STH	R2,BF+8*PPH+4,R1	:STORE TOWARD THE PORT BF'S
	EI	(SAL)
	SIS	R2,1
	SIS	R1,8
	JGEBS	IZBF3

	LHI	R1,(NUMHST-1)*4		:NOW, FOR EACH HOST:
IZBF4	LR	R2,R1
	LR	R3,R1
	SLHLS	R2,HSHIFT-2		:FIRST PORT FOR HOST
	SLHLS	R3,HSHIFT+1		:FIRST BUFFER PAIR FOR HOST
	LHI	R4,PPH-1
	NH	R4,UP0,R1		:NUMBER OF PORTS FOR THIS HOST
	JEFS	IZBF6			:ABORT REST OF PROCESS FOR PARTITION IF NO PORTS
IZBF5	LHL	R0,BF,R3		:FOR EACH HOST PORT...
	LHL	R5,BF+4,R3
	STH	R5,BF,R3		:...SWAP BF'S
	STH	R0,BF+4,R3
	SBT	R2,HPFLAG		:SET HOST PORT
	AIS	R2,1
	AIS	R3,8
	SIS	R4,1
	JGBS	IZBF5			:DO FOR ALL HOST PORTS
IZBF6	SIS	R1,4
	JG	IZBF4

:	INITIALIZE BUFFER SPACE & LINK BFLET CHAIN
	LI	R2,71717171		:INIT BUFF DATA WITH LOWER CASE Q'S
	LI	R1,BLSIZE-4
IZBFR1	ST	R2,BUFERS,R1,
	SIS	R1,4
	JGEBS	IZBFR1

	LIS	R2,1
	STH	R2,FREELT		:INIT FREE LIST HEAD
	LIS	R1,0			:BUFF INDEX
	JFS	IZBFR3
IZBFR2	STH	R2,BUFERS+CBSZ-2,R1,	:STORE LINK TO NEXT BFLET
IZBFR3	AHI	R1,CBSZ			:INCR INDEX TO NEXT BFLET
	AIS	R2,1			:INC BFLET #
	CLHI	R2,NBFLET		:ALL BFLETS LINKED?
	JLBS	IZBFR2			:NO

	LIS	R2,0
	STH	R2,BUFERS+CBSZ-2,R1,	:LINK OF LAST BFLET = 0
	STH	R2,REBL			:SET RESERVE TANK EMPTY

	SUBTTL	EXECUTIVE SCHEDULER

EXEC	JAL	R0,TIMOUT
	IF	PERMEA;	LIS	R0,1;	AM	R0,P.XCTR,,;	EI
	IF	NLINES;	JAL	R0,RTD;	EI	(NLINES)		:TEAR DOWN LAST SYNC INPUT AND DISPERSE TO BUFFERS
	IF	DOWLOA;	JAL	R0,DOWNLD;	EI	(DOWLOA)		:CHECK FOR DOWN-STREAM LOADING
	JAL	R0,TIMOUT
	IF	SAL
	JAL	R0,LOGIN		:PROCESS LOGIN DATA
	ELSE
	JAL	R0,KIN			:PASS DATA TO KERNEL AS NECESSARY
	JAL	R0,KOUT			:PASS DATA FROM KERNEL AS NECESSARY
	EI	(SAL)
	JAL	R0,TIMOUT
	JAL	R0,TISIS		:SERVICE ISIS
	JAL	R0,TIMOUT
	SVC	FAST
	J	EXEC


:	FAKE TABLE FOR SUP BUFFER BF'S
Q	EQ	0
SUPBF	RE	NM
	HC	(2*GT|Q|+RCFOB)*8,RSUP*8+Q	:OUTPUT TO LINE CHANNEL 0, INPUT
Q	EQ	Q+1
	ER
	SUBTTL	UTILITIES

:	TIMEOUT PROCESSING

TORET	L	R0,TO9			:TIMEOUT ROUTINES EXIT HERE
TIMOUT	L	R1,MFASTC,,		:CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
	LHL	R2,TLIST+2		:GET POINTER TO ACTIVE LIST
	CL	R1,TLIST+6,R2		:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0			:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9			:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2		:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R2,TLIST
	STH	R4,TLIST,R2		:SPLICE INTO HEAD OF FREE CHAIN
	L	R0,TLIST+2,R2
	JR	R0			:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2			:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2		:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2			:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2		:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGEBS	TPT1			:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH		:FREE LIST EXHAUSTED
	BC	0,0,R5*4,$A10		:FLAG...REGISTER 5, REASON 10
TPT3	LH	R6,TLIST,R4
	STH	R6,TLIST		:SHORTEN FREE LIST
	STH	R4,TLIST,R3		:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	STH	R2,TLIST,R4		:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4		:PLACE ROUTINE ADDRESS
	ST	R1,TLIST+6,R4		:PLACE NEW TIME
	JR	R5			:STORE ARGUMENTS AND RETURN

IZT	ST	R0,RET4			:INITIALIZE TIMEOUT LIST
	LHI	R1,NTLIST*0A		:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0
	STH	R2,TLIST+2		:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1		:TERMINATE FREE LIST
IZT1	STH	R1,TLIST-0A,R1
	SIS	R1,0A
	JGBS	IZT1
	L	R7,MFASTC,,;
	IF	NLINES;	LHI	R1,RATE/$A40,R7;	LA	R0,RMAKE;	JAL	R5,TOPUT;	EI;
	IF	PERMEA;	LHI	R1,P.TIME,R7;	LA	R0,PERCTL;	JAL	R5,TOPUT;	EI;
	LHI	R1,RATE/$A25,R7;	LA	R0,CKBZ;	JAL	R5,TOPUT;
	LHI	R1,RATE/$A20,R7;	LA	R0,LEPBG;	JAL	R5,TOPUT;
	LHI	R1,RATE/2,R7;	LA	R0,SECH;	JAL	R5,TOPUT;
	LHI	R1,RATE,R7;	LA	R0,IQUASI;	JAL	R5,TOPUT;
	LHI	R1,RATE,R7;	LA	R0,SEC1;	JAL	R5,TOPUT;
	IF	SAL;	LHI	R1,RATE*8,R7;	LA	R0,SEC8;	JAL	R5,TOPUT;	
	LHI	R1,RATE/2,R7;	LA	R0,DETMO;	JAL	R5,TOPUT;	EI;
	LHI	R1,$A RATE*16,R7;	LA	R0,SEC16;	JAL	R5,TOPUT;
	LI	R1,$A RATE*60*4,R7;	LA	R0,MIN4;	JAL	R5,TOPUT;
	IF	ACCT
	LI	R1,$A RATE*60*20/NHPORT,R7;	LA	R0,AATIME;	JAL	R5,TOPUT
	EI	(ACCT)

	J	RET

:	**************************************


:	HALF WORD BIT IDENTIFIER
:	CALLED WITH NONZERO R1, LINK IN R3
:	LEFT HALF OF R1 MUST BE ZERO IF BIT 16 IS ZERO
:	RETURNS ORIGINAL WORD IN R1, NUMBER OF LEFTMOST BIT
:	OF RIGHT HALF OF R1 IN R2
	IF	ENGINE
BIDH	JFFOH	R1,BIDH1		:FIND FIRST ONE
	JAL	R10,CRASH
BIDH1	JR	R3
	ELSE
BIDH1	LB	R2,BIDTBL,R1
	JR	R3
BIDH	THI	R1,0FF00
	JEBS	BIDH1
	EXBR	R2,R1
	LBR	R2,R2
	LB	R2,BIDTBL,R2
	SIS	R2,8
	JR	R3
	EI

:	FULLWORD BIT IDENTIFIER
:	CALLED WITH NONZERO R1, LINK IN R3
:	RETURNS ORIGINAL WORD IN R1, NUMBER OF LEFTMOST NONZERO BIT IN R2
	IF	ENGINE
BID	JFFO	R1,BID1			:FIND FIRST ONE
	JAL	R10,CRASH
BID1	JR	R3
	ELSE
BID1	LB	R2,BIDTBL,R1
	AHI	R2,10
	JR	R3
BID2	THI	R1,0FF00
	JEBS	BID1
	EXBR	R2,R1
	LBR	R2,R2
	LB	R2,BIDTBL,R2
	AIS	R2,8
	JR	R3
BID	THI	R1,8000
	JEBS	BID2
	EXHR	R2,R1
	TI	R2,0FF00
	JEFS	BID3
	EXBR	R2,R2
	LBR	R2,R2
	LB	R2,BIDTBL,R2
	SIS	R2,8
	JR	R3
BID3	LBR	R2,R2
	LB	R2,BIDTBL,R2
	JR	R3
BIDTBL	HS	0
	NOLIST
	XC	100F0E0E0D0D0D0D0C0C0C0C0C0C0C0C0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B
	XC	0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A
	RE	2
	XC	0909090909090909090909090909090909090909090909090909090909090909
	ER
	RE	4
	XC	0808080808080808080808080808080808080808080808080808080808080808
	ER
	LIST
	EI

:	CHARACTER HANDLERS. THESE ROUTINES PASS BUFFER CHR IN R0,
:	R1 FOR TWICE THE BUFFER NUMBER, R2,R3 FOR WORKING REGISTERS, R5 IS LINK.
GCIER	JAL	R10,CRASH		:GCI ERROR - CRASH
	BC	0,0,R5*4,3		:FLAG...LINK IN R5, TYPE 3

:	GET A CHAR FROM BUFFER

GCI	THI	R1,3			:2 LSB'S SHOULD BE 0
	JNBS	GCIER			:ERROR IF NOT

	IF	ESYNC

GCIM	HC	3801			:GCI OPCODE, R0=CHAR, R1=4*BUFF#
	HC	NBUF*4			:NBUF*4
	HC	GCIER-GCIM		:ERROR PC
	HC	BB/4			:ADDR OF BB/4
	HC	GCRET-GCIM		:PC TO RETURN EMPTY BFLET
	HC	GCLAST-GCIM		:PC TO CLEAR BUFF AFTER LAST CHAR REMOVED

	ELSE

	LR	R1,R1			:CHECK FOR VALID BUFF# TIMES 4
	JLBS	GCIER			:ERROR IF NEGATIVE
	CLHI	R1,NBUF*4		:COMPARE TO MAX BUFF#
	JGEBS	GCIER			:ERROR

	L	R3,BB,R1		:GET OUT PTR
	JEBS	GCIER			:ERROR - EMPTY BUFFER
	LB	R0,0,R3			:GET THE CHAR
	CL	R3,BE,R1		:IS IT THE LAST CHAR IN BUFF?
	JEFS	GCLAST			:YES
	AIS	R3,1			:NO, MOVE TO NEXT CHAR
	THI	R3,CBSZ-1		:END OF BFLET?
	JEFS	GCRETJ			:YES, RETURN BFLET TO FREE LIST
	ST	R3,BB,R1		:UPDATE BB

	EI	(1-ESYNC)

	LCS	R2,1
	AHM	R2,BCT,R1		:DECR BUFFER BYTE COUNT

	CHIST

	IF	1-ESYNC
GCRETJ	J	GCRET
	EI

:	LAST CHAR - CLEAR THE BUFFER
GCLAST	LIS	R2,0
	ST	R2,BB,R1		:INDICATE BUFFER EMPTY
	ST	R2,BE,R1		: /
	STH	R2,BCT,R1		:/

	LHL	R2,BF,R1
	RBT	R2,FLAGS		:RESET FLAG BIT

	AIS	R3,CBSZ-1
	NHI	R3,@(CBSZ-1)		:COMPUTE BFLET LINK ADDR
	LHL	R2,FREELT
	STH	R2,0,R3			:LINK FREE LIST TO END

	SI	R3,BUFERS+CBSZ-2 	:COMPUTE BFLET #
	SRLS	R3,CBSZL
	STH	R3,FREELT		:MOVE BFLET TO TOP OF FREELT

	CHIST

:	RETURN BFLET TO FREE LIST
GCRET	LHL	R2,0,R3			:GET NEXT BFLET #
	SLLS	R2,CBSZL		:CALC NEXT BFLET ADDR
	AI	R2,BUFERS		:/
	ST	R2,BB,R1		:NEW BB

	LHL	R2,FREELT
	STH	R2,0,R3			:LINK FREE LIST TO ND OF BFLET

	SI	R3,BUFERS+CBSZ-2
	SRLS	R3,CBSZL		:CALC BFLET #
	STH	R3,FREELT		:MOVE BFLET TO TOP OF FREELT

	LCS	R2,1
	AHM	R2,BCT,R1		:DECR BUFF BYTE COUNT

	CHIST

:	WRITE CHAR INTO BUFFER

WCIER	JAL	R10,CRASH
	BC	0,0,R5*4,5		:FLAG...LINK IN R5, TYPE 5 CRASH

WCI	THI	R1,3			:2 LSB'S SHOULD BE 0
	JNBS	WCIER			:IF NOT - ERROR

	IF	ESYNC

WCIM	HC	3901			:WCI OPCODE, R0=CHAR, R1=4*BUFF#
	HC	NBUF*4			:NBUF*4
	HC	WCIER-WCIM		:ERROR PC
	HC	BE/4			:ADDR OF BE/4
	HC	WCNXT-WCIM		:PC TO GET ANOTHER BFLET
	HC	WCFRST-WCIM		:PC TO GET FIRST BFLET

	ELSE

	LR	R1,R1			:CHECK FOR VALID BUFF# TIMES 4
	JLBS	WCIER			:NEGATIVE - ERROR
	CLHI	R1,NBUF*4		:COMPARE TO MAX BUFF#
	JGEBS	WCIER			:ERROR

	L	R3,BE,R1		:GET IN PTR
	JE	WCFRST			:IF BUFF EMPTY, GET FIRST BFLET
	AIS	R3,1			:INCR TO NEXT CHAR
	THI	R3,CBSZ-1		:END OF BFLET?
	JEFS	WCNXTJ			:YES, GET NEXT BFLET
	STB	R0,0,R3			:NO, STORE CHAR
	ST	R3,BE,R1		:UPDATE NEW BE

	EI	(1-ESYNC)

	LIS	R2,1
	AHM	R2,BCT,R1		:INCR BUFFER BYTE COUNT

	CHIST

	IF	1-ESYNC
WCNXTJ	J	WCNXT
	EI

:	FIRST CHAR IN BUFFER - GET FIRST BFLET, SET FLAG BIT
WCFRST	LHL	R2,BF,R1		:GET BF 
	JER	R5			:IF 0, BIT BUCKET
	SBT	R2,FLAGS		:ALERT PROCESS THAT DATA IS WAITING IN BUFF

	LIS	R2,1
	STH	R2,BCT,R1		:BYTE CNT=1

	LHL	R3,FREELT		:HEAD OF FREE LIST
	JGFS	WCFR1
	JAL	R2,WRE			:FREE LIST EMPTY, GET RESERVE TANK

WCFR1	SLLS	R3,CBSZL		:CONVERT BFLET# TO BFLET ADDR
	AI	R3,BUFERS		:/
	ST	R3,BB,R1		:INIT BB

	LHL	R2,CBSZ-2,R3		:NEXT BFLET #
	STH	R2,FREELT		:NEW HEAD OF FREE LIST

	STB	R0,0,R3			:PUT CHAR IN BUFF
	ST	R3,BE,R1		:INIT BE

	CHIST

:	GET NEXT BFLET FROM FREE LIST
WCNXT	HS	0
	LIS	R2,1
	AHM	R2,BCT,R1		:INCR BUFFER BYTE COUNT

	LR	R2,R3			:SAVE PTR TO BFLET LINK
	LHL	R3,FREELT		:HEAD OF FREE LIST
	JGFS	WCNXT1
	JAL	R2,WRE			:FREE LIST EMPTY - GET RESERVE TANK
	L	R2,BE,R1		:RESTORE PTR TO BFLET LINK
	AIS	R2,1			:/

WCNXT1	STH	R3,0,R2			:LINK FREE LIST HEAD TO LAST BFLET
	SLLS	R3,CBSZL
	AI	R3,BUFERS		:CALC BFLET ADDR
	LHL	R2,CBSZ-2,R3
	STH	R2,FREELT		:NEW HEAD OF FREE LIST

	STB	R0,0,R3			:STORE CHAR IN BFLET
	ST	R3,BE,R1		:UPDATE BE

	CHIST



:	RETURN LAST CHAR TO BUFFER
WCD	L	R3,BB,R1		:OUT PTR
	JE	WCFRST			:EMPTY BUFF - SAME AS FIRST WCI

	LIS	R2,1
	AHM	R2,BCT,R1		:INCR BUFFER BYTE COUNT

	SIS	R3,1			:BACK UP PTR
	THI	R3,CBSZ-2		:OFF THE BFLET?
	JEFS	WDNXT			:YES

	ST	R3,BB,R1		:STORE NEW BB
	JR	R5			:RETURN

:	GET LAST BFLET RETURNED TO FREE LIST
WDNXT	LI	R2,-BUFERS+1,R3 	:CONVERT BFLET ADDR TO BFLET#
	SRLS	R2,CBSZL		:/

	LHL	R3,FREELT
	SLLS	R3,CBSZL
	AI	R3,BUFERS+CBSZ-3 	:PTR TO LAST CHAR OF LAST BFLET

	LHL	R0,1,R3			:GET LINK
	STH	R0,FREELT		:NEW HEAD OF FREE LIST

	STH	R2,1,R3			:CHAIN TO OLD BFLET
	ST	R3,BB,R1		:UPDATE BB
	JR	R5			:RETURN

:	CLEAR ALL DATA FROM BUFFER, RESET FLAG BIT

CLRER	JAL	R10,CRASH		:CLEAR ERROR - CRASH
	BC	0,0,R5*4,0B		:LINK IN R5, TYPE 13 OCTAL

CLEAR	THI	R1,3			:CHECK IF VALID BUFF# TIMES 4
	JNBS	CLRER			:2 LSB'S SHOULD BE 0
	LR	R1,R1
	JLBS	CLRER			:NEG - CRASH
	CLHI	R1,NBUF*4		:CHECK MAX
	JGEBS	CLRER			:ERROR - CRASH

	L	R3,BE,R1
	JER	R5			:ALREADY EMPTY

	AIS	R3,CBSZ-1
	NHI	R3,@(CBSZ-1)		:ADDR OF LAST BFLET IN BUFFER
	LHL	R2,FREELT
	STH	R2,0,R3			:LINK FREE LIST TO END

	L	R3,BB,R1
	SI	R3,BUFERS
	SRLS	R3,CBSZL		:CONVERT 1ST BFLET ADDR TO BFLET#
	STH	R3,FREELT		:NEW HEAD OF FREE LIST

	LHL	R3,BF,R1		:GET BF
	RBT	R3,FLAGS		:RESET FLAG BIT

	LIS	R3,0
	STH	R3,BCT,R1		:RESET BUFFER BYTE COUNT
	ST	R3,BE,R1		:RESET PTRS
	ST	R3,BB,R1
	JR	R5			:RETURN

:	MOVE RESERVE STORAGE SUPPLY TO MAIN FREE LIST
WRE	LHL	R3,REBL
	EXHR	R3,R3
	STH	R3,REBL
	EXHR	R3,R3
	JNR	R2
	JAL	R10,CRASH
	BC	0,0,4*R3,6		:FLAG...LINK IN R3, CRASH TYPE 6

	IF	CTRACE
HIST	LHL	R3,HISX
	AIS	R3,4
	NHI	R3,3FF
	STH	R3,HISX
	STB	R0,HISTAB,R3
	LR	R2,R1
	SRLS	R2,2
	STB	R2,HISTAB+1,R3
	STH	R5,HISTAB+2,R3
	JR	R5
	EI	(CTRACE)

:	GET A 6 BYTE (SUP) RECORD FROM A BUFFER. (2 RECORDS/BFLET)
:	RETURN WITH R2 POINTING TO BEGINNING OF RECORD, BCT DECR BY 6,
:	AND BB INCR PAST THE RECORD.  CLEAN UP IF LAST RECORD IN BUFFER.
GBICRA	JAL	R10,CRASH		:ERROR - CRASH
	BC	0,0,R5*4,3		:FLAG...LINK IN R5,TYPE 3 CRASH

GBI	HS	0
	THI	R1,3			:2LSB'S SHOULD BE ZERO
	JNBS	GBICRA			:CRASH IF NOT
	LR	R1,R1
	JLBS	GBICRA			:NEGATIVE INDEX - CRASH
	CLHI	R1,NBUF*4		:CHECK FOR MAX
	JGEBS	GBICRA			:OUT OF RANGE

	L	R2,BB,R1		:GET BB
	JLEBS	GBICRA			:BUFFER EMPTY

	LCS	R3,6
	AHM	R3,BCT,R1		:DECR BCT BY 6
	JEFS	GBLAST			:BUFFER IS NOW EMPTY
	JL	GBICRA			:BCT NEGATIVE - CRASH

	THI	R2,0D			:OLD BB AT BEGINNING OF BFLET?
	JN	GBRET			:NO, RETURN BFLET & GET NEXT BB
	LIS	R3,6			:NO, JUST INCR BB BY 6
	AM	R3,BB,R1

	JR	R5			:RETURN

:	BUFFER EMPTY - CLEAN UP
GBLAST	LIS	R3,0
	ST	R3,BB,R1		:ZERO BB
	ST	R3,BE,R1		:ZERO BE
	LHL	R3,BF,R1
	RBT	R3,FLAGS		:RESET FLAG BIT
GBLST0	LIS	R3,CBSZ-1		:MOVE BFLET TO HEAD OF FREE LIST
	AR	R3,R2
	NHI	R3,@(CBSZ-1)		:ADDR OF BFLET LINK
	LHL	R0,FREELT		:GET FREE LIST HEAD
	STH	R0,0,R3			:PUT IT IN LINK
	SI	R3,BUFERS+CBSZ-2
	SRLS	R3,CBSZL		:BFLET #
	STH	R3,FREELT		:NEW FREE LIST HEAD
	JR	R5			:RETURN

:	RETURN A BFLET TO THE FREE LIST
GBRET	LHL	R3,8,R2			:LINK TO NEXT BFLET
	SLLS	R3,CBSZL		:CALC NEXT BFLET ADDR
	AI	R3,BUFERS		:/
	ST	R3,BB,R1		:NEW BB
	J	GBLST0			:RETURN BFLET TO FREE LIST


:	WRITE A 6 BYTE (SUP) RECORD INTO A BUFFER. (2 RECORDS/BFLET)
:	RETURN WITH R3 POINTING TO AVAILABLE SPACE IN BUFFER, INCR BCT BY
:	6, UPDATE BE PAST NEW RECORD, SET FLAG IF NECESSARY.
WBICRA	JAL	R10,CRASH		:ERROR - CRASH
	BC	0,0,R5*4,5		:FLAG...LINK IN R5, TYPE 5 CRASH

WBI	HS	0
	THI	R1,3			:2 LSB'S OF BUFF*4 SHOULD BE ZERO
	JNBS	WBICRA			:ERROR IF NOT
	LR	R1,R1
	JLBS	WBICRA			:NEGATIVE INDEX - ERROR
	CLHI	R1,NBUF*4		:CHECK FOR MAX
	JGEBS	WBICRA			:OUT OF RANGE - CRASH

	L	R3,BE,R1		:GET BE
	JEFS	WBFRST			:0=EMPTY BUFFER - GET FIRST BFLET
	LIS	R2,6
	AHM	R2,BCT,R1		:INCR BCT BY 6
	AIS	R3,1			:INCR BE
	THI	R3,7			:BE AT END OF BFLET?
	JN	WBNXT			:YES, GET ANOTHER BFLET
	AM	R2,BE,R1		:YES, JUST INCR BE BY 6
	JR	R5			:RETURN

:	GET FIRST BFLET, SET FLAG
WBFRST	LHL	R2,BF,R1		:GET BF
	JE	WBICRA			:NULL FLAG IS ERROR
	SBT	R2,FLAGS		:INDICATE DATA IN BUFFER
	LHL	R3,FREELT		:HEAD OF FREE LIST
	JGFS	WBFST0			:JUMP IN NOT EMPTY
	JAL	R2,WRE			:ELSE GET MORE STORAGE FROM RESERVE TANK
WBFST0	SLLS	R3,CBSZL		:CALC BFLET ADDR..
	AI	R3,BUFERS+5		:...+5
	ST	R3,BE,R1		:NEW BE
	SIS	R3,5
	ST	R3,BB,R1		:NEW BB
	LHL	R2,CBSZ-2,R3		:LINK TO NEXT BFLET
	STH	R2,FREELT		:...IS NEW HEAD OF FREE LIST
	LIS	R2,6
	STH	R2,BCT,R1		:INIT BCT TO 6
	JR	R5			:RETURN

:	GET ANOTHER BFLET FROM FREELIST
WBNXT	LR	R2,R3			:SAVE BE+1
	LHL	R3,FREELT		:HEAD OF FREE LIST
	JGFS	WBNXT0			:JUMP IF NOT EMPTY
	JAL	R2,WRE			:ELSE GET MORE STORAGE FROM RESERVE TANK
	L	R2,BE,R1		:RESTORE BE+1
	AIS	R2,1			:/
WBNXT0	STH	R3,2,R2			:STORE LINK TO NEXT BFLET
	SLLS	R3,CBSZL		:CALC BUFFER ADDR..
	AI	R3,BUFERS+5		:...+5
	ST	R3,BE,R1		:NEW BE
	SIS	R3,5			:R3 POINTS TO BEGINNING OF 6 BYTE RECORD
	LHL	R2,CBSZ-2,R3		:GET LINK TO NEXT BFLET
	STH	R2,FREELT		:NEW HEAD OF FREE LIST
	JR	R5			:RETURN


:	EXPEDITE ZAPPERS, GOBBLERS. LINK IN R4. BUFFER NUM IN R1. ALSO, USES R2,R5
:	DON'T LET BACKPRESSURE RESTRAIN OUTBOUND FLOW FOR THIS CHANNEL
:	SEE WHERE BF IS POINTING
SPEED	JAL	R5,CLEAR
	LHL	R2,BF,R1
	LHI	R5,(FLAGS-CFOB)*8,R2
	JGEFS	SPEEDA			:MAYBE A BF FOR A SYNC LINE CHANNEL
	SHI	R2,RTOP*8
	JLR	R4			:(NOT A HOST INPUT BUFFER)
	CLHI	R2,NPORT
	JGER	R4
	SBT	R2,STOPIN		:HOST INPUT PORT NUMBER IN R2
	JR	R4
SPEEDA	CLHI	R5,(CFOBI-CFOB)*8
	JGER	R4			:(DON'T BOTHER WITH INTERNAL CIRCUITS)
	SBT	R5,PCFOB		:INSURE THAT THIS SYNC CHANNEL WILL BE SERVICED
	LHI	R2,6			:INSURE THAT AT LEAST 6 CHARS CAN GO
	AHM	R2,BR,R5,R5
	JR	R4


:	 SEE IF WE MUST ZAP BUFFERS BECAUSE BUFFER STORAGE RUNNING LOW
CKBZ	AHI	R1,RATE/$A25
	JAL	R5,TOPUT		:RUN 25 TIMES PER SECOND
	LH	R1,REBL
	JN	TORET			:PLENTY OF BUFFER STORAGE. DON'T ZAP BUFFERS
:	WCI,WBI GRABBED RESERVE BUFFER FREE LIST AND MOVED IT TO MAIN FREE LIST.
:	REFILL FREE LIST WITH 1/8 OF TOTAL BUFFER STORAGE. ZAP BUFFERS IF NECESSARY.
	LIS	R0,1
	AHM	R0,REBC1		:STATISTIC
REB1	LHI	R1,NBFLET/8		:SCAN MAIN FREE LIST FOR 1/8 FREE STORAGE
	LHL	R3,FREELT		:HEAD OF FREE LIST
	JFS	REB3
REB2	LR	R2,R3
	SLLS	R2,CBSZL		:CALC BFLET OFFSET
	LHL	R3,BUFERS+CBSZ-2,R2,	:GET LINK TO NEXT BFLET
REB3	JEFS	REBZ			:NOT ENOUGH ROOM - ZAP BUFFER
	SIS	R1,1			:DECR COUNT
	JGBS	REB2			:CONTINUE SCAN

	STH	R1,BUFERS+CBSZ-2,R2,	:PUT 0 LINK AT END OF RESERVE
	LHL	R1,FREELT		:MOVE HEAD OF FREE LIST...
	STH	R1,REBL			:...TO RESERVE
	STH	R3,FREELT		:NEW FREE LIST HEAD
	J	TORET

:	ZAP A BUFFER IN ORDER TO GET RESERVE TANK UP TO 1/8 OF TOTAL BUFFER STORAGE
REBZ	LHI	R1,NBUF*4-4		:BCT INDEX
	LIS	R7,0
REBZ1	LHL	R0,BCT,R1		:SEARCH FOR LARGEST BUFFER
	CLR	R7,R0
	JGEFS	REBZ2
	LR	R7,R0
	LR	R8,R1
REBZ2	SIS	R1,4
	JGEBS	REBZ1
	LIS	R0,1
	AHM	R0,REBC2
	STH	R8,BFZ			:STATISTICS
	LR	R1,R8
	JAL	R5,CLEAR		:RETRIEVE STORAGE
:	TEST IF SUP BUFFER (NPORT*8 TO NPORT*8+7C).DON'T SEND GOBBLER,BLACK BALL IF SUP.
	LHI	R2,-NPORT*8,R1
	SRLS	R2,7
	JEFS	REBZ3			:SUP BUFFER
	JAL	R4,SPEED		:EXPEDITE THE DRANO
	LIS	R0,2
	JAL	R5,WCI			:GOBBLER
	LIS	R0,1
	JAL	R5,WCI
	LHI	R0,0FD
	JAL	R5,WCI			:BLACK BALL
REBZ3	SRHLS	R7,3			:DIVIDE NUMBER OF CHARS ZAPPED BY 8
	CLHI	R7,200			:SEND DISGNOSTIC TO SUP
	JLFS	REBZ4
	LHI	R7,1FF			:9 BIT MAGNITUDE OF ZAP
REBZ4	SLHLS	R7,6
	OHI	R7,$8 100003		:SR2.BIT 0 ON, 9 BIT COUNT, 6 BIT SUBTYPE.
	SRLS	R8,2			:BUFFER NUMBER IN SR3
	JAL	R9,REPORT
	J	REB1			:TRY AGAIN TO FILL RESERVE STORAGE LIST

:	RETURN TO CALLING ROUTINE
RET	L	R0,RET4			:GET ADDRESS
	JR	R0			:AND GO THERE

:	SYNCHRONOUS LINE INITIALIZATION
:	201 AUTO DRIVER I/O  ROUTINES. Y IS INPUT MNEMONIC, Z FOR OUTPUT.

:	REGISTER DEFINITIONS FOR SYNCH LINE PROCESSORS
RL2	EQ	0F			:LINE NUMBER TIMES 2 REGISTER
RL	EQ	0E			:CONTAINS LINE NUMBER

:	INITIALIZE FOR 201 INPUT/OUTPUT INTERRUPTS
IZYZ	LR	R1,R0
	LIS	R0,0			:TURN OFF ANY EXISTING FOREGROUND-JOB
	SVC	SYS,1
	LR	R0,R1			:RESTORE R0

	LCS	R1,1
	LHI	R2,NIOTB-2		:INITIALIZE THE PERMUTER TABLES AND BUFFER RESTRICTIONS
	LHI	R3,100
IZYZ1	STH	R1,IOT,R2,
	STH	R3,BR,R2,
	SIS	R2,2
	JGEBS	IZYZ1
	LHI	R1,(NM-1)*2		:NOW SET THE ENTRY FOR SUP BUFFERS
IZYZ2	LHL	R2,IOTPNT,R1		:GET POINTER
	LHL	R3,IOTC0,R1		:GET VALUE
	STH	R3,0,R2			:PLUG IT IN
	SIS	R1,2
	JGEBS	IZYZ2			:DO FOR ALL LINES
	IF	NLINES

	LIS	R3,NLINES-1		:INITIALIZE ROTORS, FORCE ANY EXISTING OUTPUT OFF
IZYZ3	JAL	R6,ZROTOR		:FORCE OUTPUT TO HALT
	SIS	R3,1			:REPEAT FOR ALL LINES
	JGEBS	IZYZ3
	LHI	R1,(NLINES-1)*2
	LIS	R2,0
	LA	R3,ZRESET
	L	R4,MFASTC,,
	LI	R5,-(3*RATE)/2,R4	:IGNOR RESETS FOR 1/2 SECOND
	LA	R6,YLRES
IZYZ4	STH	R2,YTP,R1		:AIM INPUT POINTERS
	STH	R2,ISF,R1		:ZERO ISF SO NO ONE LOOKS AT BUFFERS
	ST	R3,ZSUB,R1,R1		:START OUTPUT LINE IN ZRESET STATE
	ST	R4,TIMEB,R1,R1
	ST	R5,TSLR,R1,R1		:TIME SINCE LAST RESET...INSURE WE SEND SOME RESETS
	ST	R6,YSUB,R1,R1		:START OUT LOOKING FOR RESETS
	SIS	R1,2
	JGE	IZYZ4

	LCS	R5,1
	LIS	R1,NLINES-1		:SET LOGICAL UNIT #
	LHI	R3,YN			:SIZE OF BUFFER AREA
IZYZ6	LHL	R2,YRGPNT-CBIAS,R1,R1	:GET POINTER TO THIS LINE'S BUFFER AREA
	LR	R4,R3			:GET SIZE OF RING
IZYZ7	ST	R5,2-4,R2,R4		:CLEAR INPUT RING (ALL ONES)
	SIS	R4,4			:DECR COUNT
	JGBS	IZYZ7			:CONTINUE UNTIL DONE
	STH	R4,0,R2			:ZERO LEAD INDEX
	SVC	CIO,CLIN+R1		:CONNECT LOGICAL INPUT LINE TO BUFFER
	JAL	R10,CRASH		:NO SKIP RETURN...ABORT
	SIS	R1,1			:NUMBER OF NEXT LINE
	JGE	IZYZ6			:DO FOR ALL LOGICAL LINES
	EI	(NLINES)
	JR	R0			:THEN EXIT


:	INITIALIZE THE FOREGROUND-PROCESS....WAIT 1 SECOND AFTER CRASH FOR STABLE ENVIRONS
IQUASI	LA	R0,QUASI		:NOW CONNECT THE FOREGROUND-JOB
	SVC	SYS,1
	J	TORET			:GOT HERE FROM TIMEOUT LIST, SO EXIT BACK TO THERE
	IF	NLINES



FPROT	BC	0,8,6,5,0,0,0,0,0,0	:FOREGROUND PROTECTION

:		****	FOREGROUND SECTION	****

RLP	EQ	0C			:LEAD POINTER
RTP	EQ	0D			:TRAILING POINTER USED IN YTD TO CHASE INFO UP TO RLP
RBA	EQ	0B			:BLOCK INDEX FOR A LINE IN YRG

QUASI	LA	R0,FPROT		:SET UP FOREGROUND PROTECTION
	SVC	SYS,$A 18		:CAN REFERENCE *ONLY* SEGMENT 0,1

:	PROCESS THE INPUT RING BUFFERS FOR ALL SYNCHRONOUS LINES
SYNC	SVC	FAST			:FAST DISMISS EVERYTIME WE GET HERE

:	SYNCHRONOUS LINE TEAR DOWN INTO RECORD FOR RTD
YTD	LHI	RL2,NLINES*2		:PROCESS ALL THE LINES
	JFS	Y3
Y1	CLH	RTP,YTP,RL2		:CHECK IF TRAILING PTR MOVED AT ALL
	JEFS	Y2			:NO
	TS	YALIVE,RL2		:YES, INDICATE INPUT INTS WORKING
Y2	STH	RTP,YTP,RL2		:REMEMBER HOW MUCH THE TRAILING PTR HAS PROGRESSED
Y3	SIS	RL2,2
	JL	ZRM			:INDEX TO THE NEXT LINE, THEN DO OUTPUT WHEN FINISHED
	LHL	RBA,YRGPNT,RL2		:RBA WILL POINT TO AN AREA OF YRG FOR EACH LINE
	LHL	RLP,0,RBA		:ADDRESS IS LEAD POINTER (SET BY INTERRUPT CODE)
	LHL	RTP,YTP,RL2		:YRG TRAILING POINTER CHASES LEAD POINTER
	L	R1,YSUB,RL2,RL2
	JR	R1			:LOOK FOR RESET,BORI,OR END OF REC

	IF	ESYNC

YLRHIT	JAL	R4,YFR			:CHECK FOR RESET
	LH	RTP,YWRAP+2,RTP		:MOVE FORWARD IN YRG

YLRES	LHI	R1,2,RBA		:ADDR OF YRG FOR THIS LINE
YLSCAN	HC	3500+RLP^4+R1		:SCAN OPCODE, LEAD PTR, YRG ADDR
	JBS	YLRHIT			:FOUND NON-MARKING DATA
	J	Y1			:CAUGHT UP, QUIT FOR NOW

	ELSE	(1-ESYNC)

YR0	LH	RTP,YWRAP+2,RTP		:MOVE FORWARD A STEP IN YRG
:	LOOKING FOR RESET. YRG MUST HAVE 2 COMPLETE HALFWRDS OR DON'T CALL YFR.
YLRES	CLH	RLP,YWRAP+2,RTP
	JE	Y1
	CLR	RLP,RTP
	JE	Y1			:CAUGHT UP...QUIT FOR NOW
	LH	R1,2,RBA,RTP		:GET NEXT DATA WORD
	JEBS	YR0			:IGNOR IF ALL ZERO
	AIS	R1,1			:TEST FOR MARKING STATE
	JEBS	YR0
	JAL	R4,YFR			:MAY HAVE SOMETHING
	J	YR0			:NORMAL RETURN...TRY AGAIN

	EI	(1-ESYNC)

:	SKIP IF BORI FOUND AT RTP.
:	R1 = PHYSICAL RECORD COUNT
:	R2 = ALIGNMENT SHIFT FACTOR
:	R6 = ALIGNED BORI HALFWORD
YFB	LI	R0,0FFFF
	LHL	R1,2,RTP,RBA
	XR	R1,R0
	JER	R4
	XR	R0,R1
	JAL	R3,BIDH
	LH	R3,YWRAP+2,RTP
	LHL	R1,2,R3,RBA
	EXHR	R0,R0
	OR	R1,R0
	SLL	R1,0,R2
	EXHR	R1,R1
	NHI	R1,7FFF
	LR	R6,R1
	XH	R1,BORI,RL2		:SET BITS 0-4 TO ZERO IF ACCEPTABLE BORI
	LH	R3,ACKSHF,RL2		:GET SHIFT FACTOR FOR THIS LINE
	AR	R3,R3			: *2
	SRL	R1,0,R3			:ADJUST HALFWORD COUNT RIGHT
	IF	NUMSAT
	CLHI	RL2,2*NUMSAT		:IS THIS A SATELITE LINE?
	JGEFS	YFB1			:NO...SKIP
	THI	R1,0E0			:YES...CHECK BORI FIELD
	JE	4,R4			:BORI ACCEPTED
	THI	R1,40			:CHECK DIRECTION BIT
	JNR	R4			:NONSKIP ERROR RETURN
	JFS	YFR			:BAD BORI

YFB1	EI
	THI	R1,3E0
	JE	4,R4			:BORI ACCEPTED
	THI	R1,100			:CHECK DIRECTION BIT
	JNR	R4			:NONSKIP ERROR RETURN

:	FIND RESET AT RTP PART OR YRG
YFR	L	R1,MFASTC,,		:CHECK TIME SINCE LAST RESET
	S	R1,TSLR,RL2,RL2
	JLFS	YFR0			:ALLOW FOR WRAP-AROUND
	SHI	R1,RATE*2		:DON'T ACCEPT A RESET FOR 2 SECONDS AFTER FIND ONE
	JLR	R4
YFR0	LI	R1,0FFFF		:CHECK CURRENT WORD
	LHL	R6,2,RTP,RBA
	XR	R1,R6
	JER	R4			:MARKING STATE...IGNOR FOR NOW
	JAL	R3,BIDH			:FIND THE NUMBER OF THE FIRST BIT
	LH	R1,YWRAP+2,RTP		:GET INDEX OF NEXT WORD
	LHL	R0,2,R1,RBA		:GET THE NEXT WORD
	EXHR	R6,R6			:PACK CURRENT AND NEXT WORD TOGETHER
	OR	R6,R0
	SLL	R6,0,R2			:THEN JUSTIFY SO THAT LEADING 0 IS AT LEFT
	EXHR	R6,R6			:BRING TO RIGHT HALF
	CHVR	R6,R6
	SHI	R6,$805253
	JNR	R4			:NOT A RESET
	LH	R3,YWRAP+4,RTP		:GOT FIRST HALF...SAME GAME FOR SECOND HALF OF RESET
	LHL	R6,2,R3,RBA
	EXHR	R0,R0
	OR	R0,R6
	SLL	R0,0,R2
	EXHR	R0,R0
	CHVR	R0,R0
	CLH	R0,MACH,RL2		:SECOND HALF SHOULD BE NEIGHBOR NUMBER
	JEFS	YFR1			:GOOD RESET...SKIP TO ACCEPT IT
	CLH	R0,MACHNO		:SECOND WORD WAS NOT EXPECTED NEIGHBOR
	JNR	R4			:NOT US EITHER
	LIS	R0,1
	AHM	R0,LCROSS,RL2		:CAUGHT TALKING TO OURSELVES
	JR	R4			:MAYBE MODEM IS IN LOOPBACK

YFR1	LI	R0,-10000		:GOT A GOOD RESET
	SRL	R0,0,R2			:ERASE THE BITS ALREADY USED
	OH	R0,2,R3,RBA		:IN CURRENT HALFWORD + 2
	STH	R0,2,R3,RBA
	LR	RTP,R3			:CONTINUE WITH CURRENT WORD + 2

YRESET	LHL	R0,ACKMSK,RL2		:RESET FOUND IN YRG
	STH	R0,LRR,RL2		:SET LAST-RECORD-RECEIVED
	STH	R0,LRA,RL2		:SET LAST-RECORD-ACKNOWLEDGED
	LR	RL,RL2			:COMPUTE LINE #
	SRHLS	RL,1
	LIS	R0,0
	STH	R0,ISF,RL2		:RESET INPUT-SECTOR-FLAG BITS
	STH	R0,CDIS,RL2		:SET CURRENT-DISASSEMBLY SECTOR = 0
	STH	R0,OSF,RL2		:SET OUTPUT-SECTOR-FLAG = 0
	STH	R0,COS,RL2		:SET CURRENT OUTPUT SECTOR = 0
	STH	R0,CAOS,RL2		:SET CURRENT ASSEMBLY OUTPUT SECTOR = 0
	LA	R0,ZSR
	ST	R0,ZSUB,RL2,RL2		:SET OUTPUT TRANSMITTER FOR SINGLE RESET
	LH	R0,0,RBA
	STH	R0,PALR,RL2,		:SAVE INPUT POSITION AS OF THIS RESET
	L	R0,MFASTC,,
	ST	R0,TSLR,RL2,RL2		:SET TIME-SINCE-LAST-RESET
	ST	R0,TIMEB,RL2,RL2	:SET TIME-FOR-BACKPRESSURE
	LIS	R1,1
	AHM	R1,LRESET,RL2		:COUNT ACCEPTED RESETS FOR SEC16
	LA	R0,YRES1		:SET UP A DELAY
	ST	R0,YSUB,RL2,RL2
	J	Y1			:AND DISMISS ONE FOREGROUND PERIOD

YRES1	L	R0,MFASTC,,		:GET TIME AFTER DELAY
	S	R0,TSLR,RL2,RL2		:HOW MUCH TIME HAS PASSED
	ST	R0,LST,RL2,RL2		:SAVE IT
	LR	R1,RLP
	SH	R1,PALR,RL2,		:CURRENT POSITION LESS ORIGINAL POSITION
	LHL	R1,YWRAP,R1		:NUMBER OF BYTES INPUT DURING INTERVAL
	STH	R1,LSS,RL2,		:SAVE THAT ALSO
YRES2	LA	R0,YLBORI		:YLBORI WILL HANDLE INPUT FROM NOW ON
	ST	R0,YSUB,RL2,RL2
	JFS	YLBORI			:LET IT TAKE IT NOW


	IF	ESYNC

YLBINC	LH	RTP,YWRAP+2,RTP		:INCR TRAIL PTR
YLBORI	LHI	R1,2,RBA		:ADDR OF YRG
	HC	3500+RLP^4+R1		:SCAN OPCODE, LEAD PTR, YRG ADDR
	JFS	YLBHIT			:FOUND NON-MARKING DATA
 	J	Y1			:CAUGHT UP, QUIT FOR NOW
YLBHIT	JAL	R4,YFB			:LOOK FOR BORI
	JBS	YLBINC			:NO, TRY NEXT WORD
	NOPR				:FILLER FOR SKIP+4 RETURN

	ELSE	(1-ESYNC)

YB0	LH	RTP,YWRAP+2,RTP		:GET POINTER TO NEXT WORD
:	LOOKING FOR BORI. MAY FIND A RESET.
YLBORI	CLH	RLP,YWRAP+2,RTP		:IS LEAD POINTER = NEXT WORD
	JE	Y1			:YES...QUIT FOR NOW
	CLR	RLP,RTP			:HAVE WE CAUGHT UP?
	JEBS	.-6			:YES...QUIT FOR NOW
	LH	R1,2,RBA,RTP		:GET CURRENT WORD
	AIS	R1,1			:CHECK FOR MARKING STATE
	JEBS	YB0			:IGNOR MARKING WORDS
	JAL	R4,YFB			:NOT ALL MARKING BITS...LOOK FOR BORI
	J	YB0			:NO...TRY NEXT WORD (NEED RX2 HERE FOR SKIP RETURN)

	EI	(1-ESYNC)

	LA	R3,6,R1,R1		:NUMBER OF BYTES IN PACKET, INCLUDING CKSUM
					:AND ALLOWING FOR NON-ALIGNMENT OF PACKET IN RING
	STH	R3,YRSIZE,RL2		:CONVERT COUNT FIELD TO PACKET BYTE SIZE
	LA	R3,YLEOR		:YLEOR WILL HANDLE THE CODE FROM NOW ON
	ST	R3,YSUB,RL2,RL2

:	LOOKING FOR END OF RECORD
YLEOR	LR	R1,RLP			:COMPUTE NUMBER OF BYTES IN BUFFER
	SR	R1,RTP
	LH	R1,YWRAP,R1
	CLH	R1,YRSIZE,RL2		:TEST IF ENOUGH FOR ENTIRE RECORD
	JL	Y1			:ABORT FOR NOW IF NOT

:	FULL RECORD IN CORE. ALIGN DATA INTO ISEC FOR RTD.
	LR	RL,RL2			:COMPUTE LINE #
	SRHLS	RL,1
	JAL	R4,YFB			:FIND BORI AGAIN...SET UP R1,R2,AND R6
	J	YRES2			:YFB WAS CALLED AWHILE AGO IN YLBORI.  SKIP RETURN
					:	EXPECTED.  YRG DATA WIPED OUT.  PROBABLE
					:	HARDWARE FAILURE.  THIS MAY BE CAUSED BY
					:	MEMORY FAILURES OR CPU SLURPERS THAT
					:	GREATLY DRAIN CPU POWER.  NAY ALSO BE
					:	CAUSED BY BORI ENTRY CHANGE.
	LHI	R8,-1000		:R8 IS SWITCH ON WHETHER OR NOT TO STORE DATA INTO ISEC
	LR	R5,R6
	LH	R7,ACKSHF,RL2		:GET SHIFT FACTOR FOR THIS LINE
	SRL	R5,0,R7			:EXTRACT RECORD NUMBER
	LR	R4,R5			:SAVE COPY
	SH	R5,LRR,RL2
	SIS	R5,1			:THIS RECORD # MUST BE .GT. LRR
	AR	R5,R5			: *2
	SRL	R5,0,R7			:PLACE HIGH BIT OF RECORD # IN STANDARD PLACE
	THI	R5,1
	JNFS	YE1			:NOT ONE OF THE ACCEPTABLE RECORDS
	NH	R4,SECMSK,RL2		:EXTRACT SECTOR #
	TBT	R4,ISF,RL2
	JNFS	YE1			:SECTOR ALREADY CONTAINS GOOD RECORD
	PERMS(3,RL2,P.PKRC)		:NUMBER OF PACKETS RECIEVED
	SLHLS	R4,6			: *64...OFFSET INTO INPUT SECTOR ARRAY
	LHL	R8,ISECPT,RL2		:GET BASE OF INPUT SECTOR ARRAY
	AR	R8,R4			:ISEC START ADDRESS
YE1	LIS	R5,0
	LIS	R7,0			:CHECKSUMS
	LIS	R10,0F
	XR	R10,R2			:COMPLEMENT OF 0 TO 0F SHIFT FACTOR
	LHL	R3,2,RTP,RBA
	LH	RTP,YWRAP+2,RTP		:INIT FOR YE2 LOOP

:	MAIN LOOP TO ALIGN DATA FOR RTD. LAST YRG HALFWRD IN R3, NEXT R9, INDEX RTP.

	IF	ESYNC

	AIS	R1,1			:INCR COUNT TO COPY VERT CKSUM TOO
	LHI	R9,2,RBA		:YRG ADDR
	HC	3600+R9^4+RTP		:ALIGN OPCODE, YRG ADDR, TRAIL PTR
	LCS	R1,1			:R1=-1 FOR MASK

	ELSE	(1-ESYNC)

YE2	LHL	R9,2,RTP,RBA
	LH	RTP,YWRAP+2,RTP		:PEEL THRU YRG
	EXHR	R0,R3
	OR	R0,R9
	SRL	R0,1,R10		:ALIGN UNSHIFTED HALFWORD
	XR	R5,R0
	CHVR	R7,R7
	RLL	R7,1
	XR	R7,R0			:COMPUTE BOTH CHECKSUMS
	LR	R8,R8			:CHECK SWITCH
	JLFS	YE2A			:SKIP IF NOT STORING
	STH	R0,0,R8			:ELSE STORE INTO AVAILABLE SECTOR
	AIS	R8,2			:BUMP INDEX
YE2A	LR	R3,R9
	SIS	R1,1
	JGE	YE2
	EI	(1-ESYNC)

	LHL	R0,2,RTP,RBA		:GET NEXT 16 BITS
	SLL	R1,1,R10		:R1=-1...MAKE MASK OF BITS ALREADY EXAMINED
	OR	R1,R0			:CANCEL THOSE BITS...IGNOR IN FUTURE
	STH	R1,2,RTP,RBA		:SET UP TO LOOK FOR NEXT BORI
	EXHR	R3,R3			:FINISH EXTRACTING LAST 16 BITS
	OR	R0,R3
	SRL	R0,1,R10
	XR	R7,R0
	OR	R7,R5			:R7 RIGHT HALF IS 0 IF BOTH CHECKSUMS GOOD
	CHVR	R7,R7			:CHECK OUT CHECKSUM
	JEFS	YE3			:GOOD...SKIP
	LIS	R1,1			:BAD...COUNT IT
	AHM	R1,LINER,RL2
	J	YRES2			:AND SET UP FOR NEXT TIME
YE3	LR	R8,R8			:CHECKSUM GOOD...WAS THIS RETRANSMISSION?
	JGEFS	YE4			:NO...SKIP
	LIS	R0,1			:COUNT RE-TRANSMISSION
	AHM	R0,LINRTR,RL2
	JFS	YE5			:AND SKIP
YE4	LR	R1,R6			:GOOD CHECKSUM AND NOT RE-TRANSMISSION
	LHL	R2,ACKSHF,RL2		:GET SHIFT FACTOR FOR THIS LINE
	SRL	R1,0,R2			:FROM PACKET HEADER,
	NH	R1,SECMSK,RL2		:EXTRACT SECTOR #
	SBT	R1,ISF,RL2		:SET PACKET-PRESENT IN ISF
:	GOOD CHECKSUMS (WHETHER RECORD STORED OR NOT).
:	CLEAR SOME OUTPUT SECTORS IF ACK FIELD LOOKS GOOD.
:	LEGAL ACKS MUST BE FROM CAOS-5 TO CAOS-1 AND...
:	LEGAL ACKS MUST BE FROM COS-5 TO COS-1
YE5	LH	R4,ACKMSK,RL2		:GET MASK FOR RECORD FIELDS
	LR	R2,R4
	LR	R3,R4
	NH	R2,CAOS,RL2		:SET UP 8 BIT MASK OF ACCEPTABLE ACKS FOR SECTORS 0 TO 7
	NH	R3,COS,RL2
	NR	R6,R4			:EXTRACT REAL ACK RETURNED
	IF	NUMSAT
	CLHI	RL,NUMSAT		:IS THIS A SATELITE LINE?
	JGEFS	YE5A			:SKIP IF NOT
	LI	R0,1FF01FF		:RIGHT HW SAYS IF CAOS=0, ACK 0-6 ILLEGAL, 7-15 OK
	LA	R7,RSF8
	JFS	YE5B			:AND SKIP
:	NOT SATELITE
YE5A	LI	R0,1F1F00		:RIGHT HW SAYS IF CAOS=0, ACK 0-2 ILLEGAL, 3-7 OK
	LA	R7,RSF			:SET BASE ADDRESS FOR ARRAY
YE5B	ELSE
	LI	R0,1F1F00		:RIGHT HW SAYS IF CAOS = 0, ACK 0-2 ILLEGAL, ACK 3-7 OK
	LA	R7,RSF			:SET BASE ADDRESS FOR ARRAY
	EI
	LR	R1,R0			:R1 FOR TEST AGAINST COS
	SRL	R0,0,R2			:ROTATE CAOS MASK ACCORDING TO CURRENT CAOS
	SRL	R1,0,R3			:AND LEAVE BITS FOR SECTORS UP TO COS-1
	NR	R1,R0			:NOW APPLY BOTH CAOS AND COS RESTRICTION
	NH	R1,HMASK,R6,R6		:SEE IF ACK WAS IN RANGE
	JNFS	YE6			:GOOD ACK
	LIS	R1,1			:BAD ACK...COUNT IT
	AHM	R1,BADACK,RL2
	J	YRES2
YE6	SIS	R2,1
	LR	R1,R2
	SR	R1,R6
	NR	R1,R4			:R1 WILL BE 0 - N+1, 2N DIFFERENT RECORDS
	SLHLS	R1,2			: *4
	AR	R7,R1			:BUILD INDEX
	IF	NUMSAT
	CLHI	RL,NUMSAT
	JGEFS	YE6A			:SKIP IF NOT SATELITE LINE
	AR	R7,R1			:ELSE TAKE THAT INTO ACCOUNT... *8
YE6A	EI
	NH	R2,SECMSK,RL2		:ADDRESS OF SECTOR FLAGS CLEARING MASK
	LB	R3,0,R2,R7		:THESE ARE THE BITS THAT MUST NOT BE RESET IN OSF
	EXBR	R0,R3			:SET UP LEFT AND RIGHT FIELDS
	OR	R3,R0
	LH	R0,OSF,RL2		:CURRENT OSF BITS.  OSF MAY GET ANOTHER BIT SET IN RMAKE
					:IN THE NEXT FEW MICROSECONDS
	NR	R3,R0			:PRESERVE THESE BITS
	SR	R3,R0			:R0-R3 ARE BITS TO TURN OFF. CREATE NEGATIVE OF THAT.
	AHM	R3,OSF,RL2		:TURN OFF SOME BITS. KEEP SOME BITS THAT WERE THERE AND
					:A BIT THAT RMAKE MAY HAVE JUST SET
	J	YRES2			:AND SET UP FOR NEXT TIME
	IF	DOWLOA

:	SPECIAL CODE FOR DOWN-STREAM LOADING OF NEIGHBORS
:	LOOKING FOR DOWNSTREAM HEADER.
YDOWN0	LH	RTP,YWRAP+2,RTP		:ADVANCE TRAILING PTR PAST ONES GAP
YDOWN	LR	R1,RLP			:COMPUTE NUMBER OF BYTES IN BUFFER
	SR	R1,RTP
	LH	R1,YWRAP,R1
	CLHI	R1,$A70			:MUST HAVE ENOUGH ROOM FOR 1 PACKET, + 2 HW GARBAGE
	JL	Y1			:NOT ENOUGH DATA...QUIT FOR NOW
	LHL	R0,2,RBA,RTP		:GET CURRENT WORD
	LI	R1,0FFFF
	XR	R1,R0			:COMPLEMENT RING DATA IN R1
	JE	YDOWN0			:IGNORE MARKING WORDS
	JAL	R3,BIDH			:FIND FIRST 0...R2 = ALIGNMENT SHIFT FACTOR
	LH	RTP,YWRAP+2,RTP		:ADVANCE TO NEXT HALFWORD
	LHL	R6,2,RTP,RBA		:EXTRACT ALIGNED 16 BITS FROM CURRENT AND NEXT HW'S
	LR	R3,R6			:MAKE COPY OF NEXT HW
	EXHR	R0,R0
	OR	R6,R0
	SLL	R6,0,R2
	EXHR	R6,R6
	CHVR	R6,R6			:R6 = ALIGNED HEADER HALFWORD
	CLHI	R6,3232			:LOOK FOR HEADER
	JN	YDOWN			:NO...TRY NEXT WORD
	LIS	R10,0F			:WE HAVE CORRECT HEADER...
	XR	R10,R2			:COMPLEMENT OF 0 TO 0F SHIFT FACTOR
	LCS	R2,1			:SWITCH TO AVOID STORING IN SECTOR
	LB	R4,DOWCIS,,		:DOWNSTREAM CURRENT INPUT SECTOR
	TBT	R4,DOWSF,,		:IS SECTOR AVAIL?
	JNFS	YDOWN1			:NO SECTOR AVAIL, DON'T STORE IT
	LR	R2,R4			:SAVE COPY OF CURRENT SECTOR
	SLHLS	R4,6			: *64...OFFSET INTO INPUT SECTOR ARRAY
	LHL	R8,ISECPT,RL2		:GET BASE OF INPUT SECTOR ARRAY
	AR	R8,R4			:ISEC START ADDRESS
YDOWN1	LHI	R1,$A31			:WE HAVE 31 WORDS MORE TO GET BEFORE DIAG. CHECKSUM
	LIS	R5,0
	LIS	R7,0			:CHECKSUMS
	LH	RTP,YWRAP+2,RTP

:	MAIN LOOP TO ALIGN DATA FOR DOWNLD.
:	R3	LAST YRG HALFWORD
:	R9	NEXT  "	"
:	RTP	INDEX

	IF	ESYNC
	LHI	R9,2,RBA		:START ADDR OF DATA
	HC	3600+R9^4+RTP		:ALIGN OPCODE, START ADDR, TRAIL PTR
	ELSE	:1-ESYNC

YD1	LHL	R9,2,RTP,RBA
	LH	RTP,YWRAP+2,RTP		:PEEL THRU YRG
	EXHR	R0,R3
	OR	R0,R9
	SRL	R0,1,R10		:ALIGN UNSHIFTED HALFWORD
	XR	R5,R0
	CHVR	R7,R7
	RLL	R7,1
	XR	R7,R0			:COMPUTE BOTH CHECKSUMS
	LR	R2,R2			:ARE WE STORING INTO SECTOR?
	JLFS	YD2			:SKIP IF NOT
	STH	R0,0,R8			:SAVE THIS HALF-WORD
	AIS	R8,2			:BUMP INDEX
YD2	LR	R3,R9
	SIS	R1,1
	JG	YD1
	EI	(1-ESYNC)

	LHL	R0,2,RTP,RBA		:GET NEXT 16 BITS
	LCS	R1,1
	SLL	R1,1,R10		:R1=-1...MAKE MASK OF BITS ALREADY EXAMINED
	OR	R1,R0			:CANCEL THOSE BITS...IGNOR IN FUTURE
	STH	R1,2,RTP,RBA		:SET UP TO LOOK FOR NEXT PACKET
	EXHR	R3,R3			:FINISH EXTRACTING LAST 16 BITS
	OR	R0,R3
	SRL	R0,1,R10
	LR	R2,R2			:ARE WE STORING INTO SECTOR?
	JLFS	YD3			:SKIP IF NOT
	STH	R0,0,R8			:SAVE DIAGONAL CHECKSUM TOO
YD3	XR	R7,R0
	OR	R7,R5			:R7 RIGHT HALF IS 0 IF BOTH CHECKSUMS GOOD
	CHVR	R7,R7			:CHECK OUT CHECKSUM
	JN	YDOWN			:BAD CHECKSUM...ABORT
	LR	R2,R2			:CHECKSUM GOOD--DID WE STORE INTO SECTOR?
	JL	YDOWN
	SBT	R2,DOWSF,,		:MARK SECTOR FOR DISASSEMBLY
	AIS	R2,1			:ADVANCE TO NEXT SECTOR
	NHI	R2,3			:ALLOW 4 SECTORS ON INPUT
	STB	R2,DOWCIS,,		:ELSE SET PACKET IN PLACE
	J	YDOWN			:AND CONTINUE
	EI	(DOWLOA)

	NOLIST
	RE	3			:CREATE 0,2,4,6...,YN-4,YN-2,0,2...YN-2,0,2..YN-6,YN-4,YN-2
NN	RE	YN/2
	HC	.-NN
	ER
	ER				:   THESE ARRAYS USED FOR QUICK YRG WRAPAROUND
YWRAP	EQ	.-2*YN
	LIST				:YWRAP IS THE MIDDLE OF THE 3 ARRAYS


:	FOREGROUND OUTPUT ROUTINE --- ROTOR MAKER
ZRM	LHI	R0,-1^($A16-NLINES)
ZRM1	LR	R1,R0			:COPY MASK
	NH	R1,ZFLAG		:IS THERE ANYTHING TO DO?
	JE	SYNC			:QUIT IF NOT
	JAL	R3,BIDH			:YES...WHICH LINE
	XH	R0,HMASK,R2,R2		:(RX3!!!) TURN OFF MASK TO IGNORE THIS LINE
	LR	R3,R2			:COPY LINE #
	AR	R2,R2			:MAKE 2*LINE#
	TS	ZALIVE,R2		:MARK TRANSMIT CLOCK AS WORKING
	L	R6,ZSUB,R2,R2		:GET SUBROUTINE TO CALL
	JR	R6			:GO TO THE ROUTINE..R0 PRIVATE, R2=2*LINE#, R3=LINE#

:	ARE THERE ANY RECORDS MADE BY RMAKE READY TO TRANSMIT
ZR	HS	0
	LHL	R6,SECMSK,R2		:GET MASK FOR SECTOR INDEX FOR THIS LINE
	NH	R6,COS,R2		:NEXT SECTOR TO BE OUTPUT
	TBT	R6,OSF,R2		:CHECK OSF ATTENTION BIT FOR NEXT SECTOR
	JNFS	ZR01			:SKIP IF SOMETHING TO DO
ZR0	LIS	R6,0			:NEXT RECORD NOT YET PREPARED BY RMAKE...ABORT
	STH	R6,RTF,R2		:CLEAR RETRANSMISSION FLAG
	J	ZRM1
ZR01	LA	R4,8,R6			:POINT TO RECORD SENT (OR ON THE WAY) FLAG
	TBT	R4,OSF,R2
	JE	ZR2			:HAVEN'T ALREADY SENT THIS ONE

	JAL	R9,ZSPACE		:IS THERE ROOM THERE?
	LA	R1,ZR1			:SEND GAP, RETURN LATER TO CONSIDER RETRANSMITTING
	ST	R1,ZSUB,R2,R2		:RETURN TO ZR1
	LHI	R5,$A31*2		:31 WORDS
	LA	R4,GAP,,		:FROM GAP
	J	ZSEND1			:SEND IT & DON'T SET ZFLAG UNTIL COMPLETED

ZR1	JAL	R9,ZSPACE		:CHECK THAT ROOM EXISTS IN ROTOR
	LA	R4,ZR			:SET UP NEXT CALL TO ZR
	ST	R4,ZSUB,R2,R2
	LHL	R6,SECMSK,R2		:GET MASK FOR LINE'S SECTOR INDEX
	NH	R6,COS,R2		:COS IS 4 (OR 8) SECTORS BEYOND OLDEST RECORD
	TBT	R6,OSF,R2		:IS THERE STILL A RECORD THERE TO SEND (NOT ACK'ED YET)?
	JE	ZR0			:NO...QUIT FOR NOW
	TS	RTF,R2			:SET RETRANSMISSION FLAG JUST IN CASE...
	LA	R4,8,R6			:POINT TO RECORD SENT (OR ON THE WAY) FLAG
	TBT	R4,OSF,R2		:HAS YTD ACCEPTED NEW ACKNOWLDGEMENT?
	JEFS	ZR2			:YES, DON'T RETRANSMIT...START NEW TRANSMISSION
	LIS	R4,1
	AHM	R4,LINRTS,R2		:RETRANSMISSION STATISTIC FOR 4 MIN DIAGNOSTICS
	JFS	ZR4			:RETRANSMIT OLDEST
ZR2	LIS	R9,0
	STH	R9,RTF,R2		:CLEAR RETRANSMISSION FLAG
ZR3	JAL	R9,ZSPACE		:CHECK THAT ROOM EXISTS IN ROTOR
	SBT	R4,OSF,R2		:IT DOES...SET FLAG
	LIS	R1,1
	AHM	R1,COS,R2		:TRANSMIT NEW OUTPUT RECORD
ZR4	LHL	R4,OSOFST,R6,R6		:SEND OR RESEND A RECORD FROM SECTOR IN R6...GET OFFSET
	AH	R4,OSECPT,R2		:COMPUTE START OF SECTOR
	LHL	R1,2,R4			:GET HEADER
:	INSERT NEW ACKNOWLEDGEMENT FIELD AND CHANGE CHECKSUMS TO CORRESPOND
	LHL	R7,LRR,R2		:LAST-RECORD-RECEIVED
	STH	R7,LRA,R2		:LAST-RECORD-ACKNOWLEDGED
	XR	R7,R1
	NH	R7,ACKMSK,R2		:DIFFERENCE BETWEEN OLD ACK AND NEW ACK
	XR	R1,R7
	STH	R1,2,R4			:OUTPUT HEADER WITH LATEST ACK FEEDBACK
	LHL	R5,0,R4			:GET PACKET SIZE SO WE CAN DIDDLE CHECKSUMS
	AIS	R4,2			:NOW BUMP POINTER TO ACTUAL START OF PACKET
	LR	R1,R7			:COPY THE CHANGES
	XH	R1,0,R4,R5
	STH	R1,0,R4,R5		:CHANGE VERTICAL CHECKSUM
	LR	R1,R5
	SRHLS	R1,1			: /2
	NHI	R1,0F			:4 BIT COUNT FOR ROTATION OF HEADER IN DIAGONAL CHECKSUM
	EXHR	R14,R7
	OR	R7,R14
	LR	R14,R7			:ACK FIELD IN LEFT HALFWORD AND RIGHT HALFWORD
	SLL	R7,0,R1
	EXHR	R7,R7			:ACK CHANGE DUE TO ROTATION OF HEADER
	XR	R7,R14			:ALSO, UNROTATED ACK CHANGES IN VERT CHECKSUM
	XH	R7,2,R4,R5
	STH	R7,2,R4,R5		:NEW DIAGONAL CHECKSUM
	AIS	R5,4			:ACCOUNT FOR CHECKSUMS
	LHL	R13,RTF,R2		:IS THIS A RETRANSMISSION?
	JE	ZSEND			:NO, SEND NORMALLY (POSSIBLY IN 2 PARTS)
ZSEND1	LHL	R7,ROTORI+4,R8		:YES, GET INDEX OF NEXT FREE CELL IN ROTOR
	J	ZSEND3			:PLACE OUTPUT IN ROTOR AND SET FLAG AFTER OUTPUT COMPLETE


:	ZERO OUT ROTOR, TURN OFF OUTPUT
:	R3 = LINE#
:	LINK ON R6
ZROTOR	LIS	R5,0			:SET VALUE TO STORE
	AR	R3,R3			:2*LINE#
	LHL	R4,ROTORP,R3		:GET BASE ADDRESS OF ROTOR
	SRLS	R3,1			:BACK TO LINE#
	LHI	R7,NROTOR*8		:HOW MANY WORDS TO ZERO OUT
ZROT1	ST	R5,0,R4,R7		:DO A WORD
	SIS	R7,4
	JGEBS	ZROT1			:DO THEM ALL
	STH	R5,ROTORX,R3,R3		:RESET THIS LINE'S INDEX
	SVC	CIO,FLOUT+R3		:CANCEL ANY OUTPUT IN PROGRESS
	JAL	R10,CRASH
	RBT	R3,ZFLAG
	LIS	R7,9
	STH	R7,2*4,R4		:PLACE COMMAND TO TURN ON "DTR"
	LIS	R7,5
	EXHR	R7,R7
	OR	R7,R3
	ST	R7,4*4,R4		:PLACE COMMAND TO SET BIT
	LA	R7,ZFLAG
	ST	R7,5*4,R4		:IN ZFLAG ARRAY..
	LIS	R7,4
	STH	R7,0*4,R4		:SET UP TO TURN "RS" ON
	SVC	CIO,FLOUT+R3		:INITIALIZE "RS", "DTR", AND ZFLAG
	JAL	R10,CRASH		:NON-SKIP RETURN...FAILED
	JR	R6			:THEN RETURN

:	SEND SINGLE RESET
ZSR	JAL	R9,ZSPACE		:INSURE THERE IS ROOM
	LA	R9,ZR			:YES...NEXT TIME SEND RECORD
	ST	R9,ZSUB,R2,R2
	JFS	ZRES			:AND SKIP

:	SEND OUTPUT RESET
:	R3	LINE#
ZRESET	JAL	R9,ZSPACE		:CHECK IF THERE IS ROOM THERE
ZRES	LIS	R5,0
	STH	R5,RTF,R2		:CLEAR RETRANSMISSION FLAG
	LHI	R5,$A36*2		:33 WORDS OF MARK, + 2 WORDS OF RESET + 1 WORD MARK
	LA	R4,GAP,,		: FROM GAP

:	SEND A MESSAGE ON
:	R4 = STRING START ADDRESS
:	R5 = STRING LENGTH IN BYTES
ZSEND	CLHI	R5,$A16*2		:CHECK IF WE CAN SPLIT STRING
	JGEFS	ZSEND2			:SKIP IF SO
ZSEND0	LIS	R13,1			:SET WRITE CMD
	LHL	R12,ROTORI+2,R8		:CAN'T SPLIT, SO PLACE ENTIRE STRING IN SECOND MESSAGE
	LR	R14,R5			:SIZE
	LR	R15,R4			:ADDRESS
	JAL	R9,ZPRE			:PLACE ROTOR ENTRY
	LR	R12,R8			:COPY INDEX FOR FIRST ENTRY
	JAL	R9,ZSFC			:SET FLAG COMMAND
	LHL	R7,ROTORI+4,R8		:GET INDEX OF NEXT FREE CELL
	J	ZSEND4			:AND SKIP

ZSEND2	LHL	R12,ROTORI+4,R8		:CAN SPLIT MESSAGE...INDEX OF THIRD CELL
	LIS	R13,1			:SET WRITE
	LHI	R14,$A15*2		:15 WORDS
	SR	R5,R14
	LR	R15,R4
	AR	R15,R5			:ADDRESS OF SECOND SEGMENT
	JAL	R9,ZPRE			:PLACE ROTOR ENTRY
	LHL	R7,ROTORI+6,R8		:SET NEXT FREE ROTOR ENTRY
ZSEND3	LHL	R12,ROTORI+2,R8		:ADDRESS OF FLAG ENTRY
	JAL	R9,ZSFC			:SET FLAG COMMAND
	LR	R12,R8			:INDEX OF FIRST CELL
	LIS	R13,1			:SET WRITE
	LR	R14,R5			:COUNT
	LR	R15,R4			:ADDRESS
	JAL	R9,ZPRE			:PLACE ROTOR ENTRY
ZSEND4	STH	R7,ROTORX,R2,		:SAVE NEXT ROTOR ENTRY FOR NEXT TIME
	LHL	R4,ROTORT,R8		:COMPUTE ADDRESS OF START OF ROTOR CELL STRING
	AR	R4,R11
	SVC	CIO,CLOUT+R3		:CONNECT LOGICAL OUTPUT IF NOT ALREADY IN PROGRESS
	J	ZRM1			:NON-SKIP RETURN
	J	ZRM1			:SKIP RETURN

:	OUTPUT...CHECK FOR SPACE IN THE ROTOR
:	R2	CURRENT LINE NUMBER*2
:	R9	LINK
:	RETURNS	R11	ROTOR BASE ADDRESS
:		R8	CURRENT ROTOR INDEX
ZSPACE	LHL	R11,ROTORP,R2		:GET CURRENT ROTOR BASE ADDRESS
	LH	R8,ROTORX,R2,		:GET CURRENT ROTOR INDEX
	LHL	R10,ROTORI+4,R8		:WRAP AROUND, ALLOW FOR (3-1)*2
	LHL	R10,ROTORT,R10		:GET INDEX FOR THAT CELL
	LHL	R10,OOP,R10,R11		:GET OUTPUT OPERATION FOR THERE
	JER	R9			:AND RETURN...OK TO CONTINUE IF R10=0
	J	ZRM1			:ELSE ABORT


:	OUTPUT...SET FLAG COMMAND
:	R3	CURRENT LINE NUMBER
:	R9	LINK
:	R10	USED FOR SCRATCH STORAGE
:	R11	ROTOR BASE ADDRESS
:	R12	CURRENT ROTOR INDEX
ZSFC	LIS	R13,5			:SET FLAG COMMAND
	LR	R14,R3			:COPY LINE #
	LA	R15,ZFLAG		:BIT TO BE SET IN ZFLAG...GO PLACE ROTOR ENTRY
	RBT	R3,ZFLAG		:MAKE SURE BIT IS RESET

:	OUTPUT...PLACE ROTOR ENTRY
:	R9	LINK
:	R10	USED FOR SCRATCH STORAGE
:	R11	ROTOR BASE ADDRESS
:	R12	CURRENT ROTOR ENTRY INDEX
:	R13	OUTPUT COMMAND
:	R14	OUTPUT COUNT
:	R15	POINTER TO STRING
:	RETURNS WITH ENTRY PLACED
ZPRE	LHL	R10,ROTORT,R12		:GET INDEX TO THIS ROTOR ENTRY
	ST	R15,OSP,R10,R11		:PLACE OUTPUT STRING POINTER
	STH	R14,OCT,R10,R11		:PLACE OUTPUT COUNT
	LHL	R12,ROTORI+2,R12	:LOOK UP NEXT ENTRY
	JNFS	ZPRE1			:SKIP IF NOT THE LAST ENTRY IN ROTOR RING
	ST	R11,OSP+8,R10,R11	:TERMINATE ROTOR WITH TRANSFER TO START OF ROTOR
	LIS	R12,2			:TRANSFER COMMAND
	STH	R12,OOP+8,R10,R11
ZPRE1	STH	R13,OOP,R10,R11		:PLACE OUTPUT COMMAND
	JR	R9			:THEN EXIT
	IF	DOWLOA

:		D O W N S T R E A M   L O A D   O F   N E I G H B O R


:	CONTROLLED BY 3-STATE SWITCH, "DOWSWI":
:	NOT IN PROCESS IF = 0
:	IN STATE 0 IF <0, THEN DOWSWI&7FFF= BUFFER INDEX FOR INPUT
:		HERE WE'RE LOOKING FOR A LINE #
:	IN STATE 1 IF >0, THEN DOWSWI= BUFFER INDEX FOR INPUT
:		PASSING DATA BOTH WAYS, AND WATCHING FOR ZAPPERS
DLDTIM	EQ	$A 60*2			:# SECONDS TO WAIT FOR TARGET LINE# FROM HOST

DOWNLD	LH	R1,DOWSWI		:CHECK SWITCH
	JER	R0			:ZERO...NOTHING TO DO
	ST	R0,RET4			:WE ARE ACTIVELY DOWN-LINE LOADING...SAVE RETURN
	JG	DOW1			:>0...STATE 1
	NHI	R1,7FFF			:STATE 0...MASK OFF STATE SWITCH
	LH	R2,BCT,R1		:CHECK BUFFER
	JGFS	DOW0			:SKIP IF SOMETHING THERE
	L	R2,DLDHTO		:CHECK TIMER
	S	R2,MSLOWC,,		:HAS IT EXPIRED YET?
	JGR	R0			:NO, QUIT FOR NOW
	LIS	R2,1
	AHM	R2,DLDHTC		:COUNT TIMEOUT OCCURANCES
	J	DOWZ1			:ZAP THE CIRCUIT
DOW0	STH	R1,DOWSWI		:NOT EMPTY...SET STATE 1 (ASSUME SUCCESS)
	JAL	R5,GCI			:GET THE CHAR
	CLHI	R0,7			:CHECK FOR NETWORK CHARS
	JGFS	DOW00			:SKIP IF NOT
	LR	R0,R0
	JN	DOWZAP			:ANYTHING BUT ESCAPE IS REASON TO ZAP
	JAL	R5,GCI			:ELSE GET THE ESCAPED CHAR
DOW00	IF	PERMEA
	CLHI	R0,P.HCHR
	JE	DOWD0			:CHECK FOR DUMP
	EI	(PERMEA)
	CLHI	R0,NLINES		:CHECK NUMBER INPUT
	JGE	DOWZAP			:ZAP IF NOT A VALID LINE #
	TBT	R0,LINOUT,,		:CHECK IF THAT LINE IS REALLY OUT
	JN	DOWZAP			:ABORT IF NOT
	STH	R0,DOWLIN		:OK...SAVE LINE REFERENCE
	LR	R8,R0			:MAKE ANOTHER COPY
	LHI	R7,$8 100035
	JAL	R9,REPORT		:REPORT THIS TO SUP
	LIS	R0,0			:INITIALIZE SOME COUNTERS
	STH	R0,DOWSF,,		:ALL SECTORS AVAIL FOR INPUT
	STH	R0,DOWINX		:OUTPUT BUFFER INDEX
	STH	R0,DOWROT,,		:INIT ROTOR ENTRY
	STB	R0,DOWCDIS,,		:DOWNSTREAM CURRENT DISASSEMBLY INPUT SECTOR
	STB	R0,DOWCIS,,		:DOWNSTREAM CURRENT INPUT SECTOR
	LIS	R1,4
	XH	R1,DOWSWI		:GET OUTPUT BUFFER INDEX
	CLHI	R8,7
	JGFS	DOW01			:SKIP IF NO NEED TO ESCAPE IT
	JAL	R5,WCI
DOW01	LR	R0,R8			:RESPOND WITH LINE #
	JAL	R5,WCI
	LR	R3,R8
	JAL	R6,ZROTOR		:CANCEL ONGOING I/O
	AR	R3,R3			:DOUBLE THE LINE NO.
	LA	R0,ZRM1
	ST	R0,ZSUB,R3,R3		:TURN OFF FURTHER OUTPUT
	LA	R0,YDOWN
	ST	R0,YSUB,R3,R3		:RE-DIRECT INPUT
	LHL	R1,DOWSWI		:RESTORE INPUT BUFFER INDEX

:	STATE 1...PASSING DATA TO NEIGHBOR
DOW1	IF	PERMEA
	LH	R0,PERDMP		:CHECK IF DUMPING
	JL	DOWD1			:SKIP IF SO
	EI	(PERMEA)
	LHL	R0,BCT,R1		:CHECK BUFFER
	JE	DOW2			:CHECK INPUT IF OUTPUT BUFFER IS EMPTY
	LH	R0,DOWROT,,		:CAN WE ACCEPT DATA?
	JEFS	DOW10			:SKIP IF SO
	JAL	R5,GCI			:ELSE GET FIRST CHAR
	SIS	R0,7			:CHECK FOR NETWORK CHARS
	JG	DOW13			:NO
	AIS	R0,7			:NOT ESCAPED
	JE	DOW14
	J	DOWDONE			:NETWORK CONTROL...CLEAN UP AND ZAP IT

:	WE CAN ACCEPT DATA
DOW10	JAL	R5,GCI			:EXAMINE CONTENTS
	CLHI	R0,7			:CHECK FOR NETWORK CHARS
	JGFS	DOW11			:NO
	LR	R0,R0			:CHECK FOR ESCAPED CHARS
	JN	DOWDONE			:ALL OTHERS ARE TO BE TREATED AS ZAPPERS
	JAL	R5,GCI			:ELSE GET THE CHAR
DOW11	LHL	R2,DOWINX		:CHECK CURRENT POSITION
	CLHI	R2,1
	JGFS	DOW12			:SKIP IF BEYOND HEADER
	CLHI	R0,32			:EXPECT SECOND CHAR TO BE 32 ALSO
	JEFS	DOW12			:SUCCESS...PLACE SECOND CHAR AND BUMP INDEX
	LIS	R2,0			:DIDN'T GET 32|32 AS HEADER...RESTART SCAN 'TIL WE DO
	STH	R2,DOWINX
	J	DOW1			:AND CHECK NEXT CHAR
DOW12	STB	R0,DOWOBF,R2,		:PLACE THE CHARACTER IN THE BUFFER
	AIS	R2,1
	STH	R2,DOWINX		:BUMP INDEX
	CLHI	R2,$A66
	JL	DOW1			:SCAN INPUT UNTIL WE GET A BUFFER FULL
	LHL	R2,DOWLIN		:GET LINE INDEX
	LA	R3,DOWROT,,		:SET ADDRESS
	LIS	R0,1
	STH	R0,0,R3			:SET ROTOR TO "WRITE"
	SVC	CIO,FLOUT+R2		:START THAT OUTPUT GOING
	NOP	0			:DON'T CARE ABOUT SKIPS
	LIS	R0,0
	STH	R0,DOWINX		:SET UP INDEX FOR NEXT TIME
	JFS	DOW2			:AND SKIP TO PROCESS INPUT

DOW13	AIS	R0,7			:RESTORE R0 FOR WCD
DOW14	JAL	R5,WCD			:CAN'T USE THE DATA NOW...PUT IT BACK INTO BUFFER

:	PROCESS INPUT FROM NEIGHBOR, AS NECESSARY
DOW2	XHI	R1,4			:SET OUTBOUND BUFFER
DOW20	LB	R6,DOWCDIS,,		:CHECK FOR DATA PRESENT
	TBT	R6,DOWSF,,
	JE	RET			:EXIT IF NOT
	LHI	R0,32			:ELSE FIRST FLUSH OUT THE HEADER
					:(SINCE KNOWN, WE DIDN'T SAVE IT)
	JAL	R5,WCI
	JAL	R5,WCI
	SLHLS	R6,6			: *64...OFFSET INTO INPUT SECTOR ARRAY
	LH	R5,DOWLIN
	AR	R5,R5
	LHL	R5,ISECPT,R5		:BASE ADDRESS OF INPUT SECTORS
	AR	R6,R5			:BASE ADDERESS OF THIS SECTOR
	LHI	R7,$A64			:NUMBER OF BYTES REMAINING
DOW21	LB	R0,0,R6			:GET A CHARACTER
	CLHI	R0,7			:CHECK IF IT NEEDS AN ESCAPE
	JGFS	DOW22			:SKIP IF NOT
	LIS	R0,0
	JAL	R5,WCI			:ELSE ESCAPE IT
	LB	R0,0,R6			:AND GET IT AGAIN
DOW22	JAL	R5,WCI
	AIS	R6,1			:BUMP INDEX TO NEXT CHAR
	SIS	R7,1
	JGBS	DOW21			:REPEAT FOR ALL CHARS
	LB	R0,DOWCDIS,,		:BUMP INDEX
	RBT	R0,DOWSF,,		:MAKE SECTOR AVAIL FOR FOREGROUND
	AIS	R0,1
	NHI	R0,3			:ALLOWS OF 4 OUTSTANDING PACKETS
	STB	R0,DOWCDIS,,
	J	DOW20			:AND SEE IF ANOTHER SECTOR CAN BE PROCESSED
	IF	PERMEA

:	ALLOW CONFIGURATION OPTION TO CONTROL AMOUNT OF DATA WE MAY
:	BUFFER FOR HOST CIRCUIT.
	DEFAULT(P.HMAX,$A 58)		:IF NO VALUE ASSIGNED, SET TO FULL PACKET SIZE

:	SET UP FOR PERFORMANCE DUMP
DOWD0	LA	R0,F.TABL,,		:INITIALIZE POINTER TO F.TABL,
	ST	R0,DLDPIX		: INCREMENTS AS DATA SENT TO HOST
	TS	PERDMP			:SET DISPATCH SWITCH FOR F.TABL DUMP

:	THIS ROUTINE GETS CONTROL EACH TIME THROUGH THE EXEC LOOP WHILE
:	F.TABL DUMP IN PROGRESS.
DOWD1	LHL	R0,BCT,R1		:ANY DATA FOR US...
	JN	DOWDONE			:YES - DISCONNECT
	XHI	R1,4			:BUFFER INDEX TO HOST
	L	R6,DLDPIX		:GET CURRENT DATA POINTER
	LCS	R8,1			:SET UP MASK TO COMPLEMENT DATA
DOWD10	LHL	R0,BCT,R1		:GET OUTBOUND BUFFER COUNT
	CLHI	R0,P.HMAX		:SHOULD WE THROTTLE OURSELVES?
	JG	DOWD12			:YES - EXERCISE SELF-RESTRAINT
	LB	R7,0,R6			:NEXT BYTE FROM F.TABL
	XR	R7,R8			:COMPLEMENT DATA. PROBABLY LOTS OF ZEROS IN
					: PERFORMANCE DATA, ELIMINATE EXCESSIVE NUMBER
					: OF ESCAPED CHARACTERS.
	LCS	R0,8			:.NOT. "7"
	NR	R0,R7			:ESCAPE REQUIRED?
	JNFS	DOWD11			:NO
	JAL	R5,WCI			:SEND ESCAPE
DOWD11	LR	R0,R7			:GET CHARACTER
	JAL	R5,WCI			: AND SEND IT TOWARDS HOST
	AIS	R6,1			:INCREMENT F.TABL INDEX
	CI	R6,F.TBND		:POINTING PAST TABLE END?
	JL	DOWD10			:NO - O.K.
:	RESET R6 TO TABLE BEGIN. NOTE THAT WE'LL DO THIS FOREVER IF NO
:	ZAPPER RECEIVED FROM HOST.
	LA	R6,F.TABL,,
	J	DOWD10
DOWD12	ST	R6,DLDPIX		:SAVE CURRENT F.TABL POINTER
	J	RET			:DONE FOR NOW
	EI	(PERMEA)

:	DONE...CANCEL THE CIRCUIT
DOWDONE	LH	R3,DOWLIN		:FOR THIS LINE...
	JAL	R6,ZROTOR		:FORCE DOWNLINE OUTPUT OFF
	AR	R3,R3			:HALF-WORD INDEX FOR LINE
	LCS	R0,1
	STH	R0,DOWLIN		:SET LINE NOT IN USE
	LA	R0,ZRESET
	ST	R0,ZSUB,R3,R3		:CONNECT OUTPUT AGAIN
	LA	R0,YLRES
	ST	R0,YSUB,R3,R3		:CONNECT INPUT AGAIN

:	ZAP THE CIRCUIT
DOWZAP	LHL	R1,DOWSWI		:GET BUFFER INDEX
DOWZ1	JAL	R5,CLEAR		:CLEAR INPUT BUFFER
	LIS	R0,0
	STH	R0,BF,R1		:MAKE IT A BIT BUCKET
	STH	R0,DOWSWI		:ALSO CLEAR SWITCH
	XHI	R1,4			:SELECT OUTPUT BUFFER
	JAL	R4,SPEED
	LIS	R0,3
	JAL	R5,WCI			:ZAP THE CIRCUIT
	J	RET			:AND EXIT
	EI	(DOWLOA)

:	RECORD TEARDOWN. PROCESS PHYSICAL RECORDS FROM 201 LINE.
:	R1	BUFFER
:	R7	COUNTDOWN FOR PHYSICAL RECORD
:	R8	COUNTDOWN FOR LOGICAL RECORD
:	R9	CURRENT RECORD NUMBER (FOR LRR)
:	R10	IOT INDEX
:	R11	CHANNEL 0 INDEX TO IOT FOR THE CURRENT LINE
:	R12	CHAR ADDR IN SECTOR
RTD	ST	R0,RET4
	LHI	RL2,(NLINES-1)*2	:FOR EACH LINE
RT1	LH	R12,SECMSK,RL2		:GET THE MASK FOR THIS LINE
	NH	R12,CDIS,RL2		:PROCESS ONLY THE NEXT INPUT SECTOR
					:EVEN IF OTHER SECTORS HAVE ARRIVED ON THIS LINE
	TBT	R12,ISF,RL2
	JNFS	RT2			:SECTOR NOT EMPTY
	SIS	RL2,2			:NOTHING THERE...NEXT LINE
	JGEBS	RT1			:CONTINUE IF NOT YET DONE
	J	RET			:ELSE EXIT

:	WE HAVE A LINE TO SERVICE
RT2	LR	RL,RL2
	SRHLS	RL,1			:CONVERT INDEX TO LINE NUMBER
	SLHLS	R12,6			: *64
	LHL	R3,ISECPT,RL2		:ISEC POINTER FOR THIS LINE
	AR	R12,R3			:ISEC INDEX
	LHL	R7,0,R12			:GET PHYSICAL RECORD HEADER
	LH	R3,ACKSHF,RL2	:GET SHIFT FACTOR
	SRL	R7,0,R3			:SET UP TO EXTRACT RECORD NUMBER
	LH	R9,ACKMSK,RL2		:GET MASK FOR THIS SIZE SECTOR
	NR	R9,R7			:EXTRACT RECORD NUMBER
					:THAT WE SHOULD SEND BACK TO THE NEIGHBOR
	SRL	R7,0,R3			:NOW EXTRACT THE RECORD SIZE
	NHI	R7,1F
	AR	R7,R7			: *2
	PERMS(,RL2,P.PKSR,R7)		:SIZE OF PACKET RECEIVED
	SIS	R7,3			:REC SIZE COUNTER
	JL	RT17			:NO LOGICAL RECORDS IN THIS PHYSICAL RECORD
	AIS	R12,2			:POINT AT FIRST BYTE IN PACKET
	LH	R11,CHANI,RL2		:POINT TO THE CHANNEL 0 ENTRY OF IOT FOR THIS LINE

:	PROCESS LOGICAL RECORD. MOVE ISEC DATA TO BUFFERS AND DIDDLE PTRS.
RT3	LB	R8,0,R12		:GET LOGICAL RECORD SIZE
	LR	R8,R8			:CHECK IT
	JE	RTE0			:ZERO-LENGTH-RECORD ERROR
	SR	R7,R8
	JL	RTE0			:EXCESS-LENGTH-RECORD ERROR
	LB	R0,1,R12		:GET CHANNEL NUMBER
	AIS	R12,2
	SIS	R7,2			:COUNT LOGICAL RECORD HEADER EXAMINED
	LR	R10,R0
	AR	R10,R10			:COMPUTE PERMUTER TABLE INDEX FROM CHANNEL NUMBER
	LHL	R1,IOT,R10,R11		:GET PERMUTER TABLE ENTRY
	NHI	R1,3FFF			:DISCARD GOUGING BITS
	SLLS	R1,2			:BUFFER INDEX FOR WCI
	LH	R2,CHANI+2,RL2		:RANGE CHECK ON CHANNEL NUMBER
	SR	R2,R11			:R11 CONTAINS POINTER TO START/PERMUTER TABLE FOR LINE
	CLR	R10,R2
	JLFS	RT4			:OK
	LHI	R1,$8 100424		:CHANNEL NUMBER OUT OF RANGE
	J	RTE
RT4	SIS	R0,1			:CHECK CHANNEL NUMBER
	JG	RT10			:NORMAL RECORD...GO PROCESS IT
	JE	RT6			:CHANNEL 1 FOR BACKPRESSURE

:	INPUT SUP RECORD
	PERMS(,RL2,P.CHSI,R8)		:NUMBER OF SUP CHARACTERS RECIEVED
RT5	JAL	R5,WBI			:GET A BUFFERLET, COPY 1 SUP RECORD
	LB	R0,0,R12
	STB	R0,0,R3
	LB	R0,1,R12
	STB	R0,1,R3
	LB	R0,2,R12
	STB	R0,2,R3
	LB	R0,3,R12
	STB	R0,3,R3
	LB	R0,4,R12
	STB	R0,4,R3
	LB	R0,5,R12
	STB	R0,5,R3
	AIS	R12,6
	SIS	R8,6
	JG	RT5			:THERE EXIST MORE SUP RECORDS
	JE	RT16			:DONE...CLEAN UP LOGICAL RECORD
	JAL	R5,CLEAR		:COUNT WAS NOT MULTIPLE OF 6 CHARS...FLUSH
	LHI	R1,$8 100124		:COUNT WAS NOT MULTIPLE OF 6 CHARS
	J	RTE			:CAUSE TO KNOCK DOWN LINE

:	PROCESS BACKPRESSURE INFO
RT6	LHI	R1,$8 100224
	SRHLS	R8,1
	CLH	R8,GROUPN,RL2
	JN	RTE
	PERMS(1,RL2,P.BPNR)		:NUMBER OF BACK-PRESSURE RECORDS RECEIVED
	LHL	R13,CFOBA,RL2		:INITIALIZE TO BIT ADRS FOR CHANNEL 0
	LR	R1,R11			:INDEX TO FIRST IOT AND BR ENTRY
	LIS	R5,0			:SET OVERLOAD ACCUMULATOR ZERO
RT7	LB	R4,0,R12
	LB	R0,1,R12
	EXBR	R4,R4
	OR	R4,R0			:16 BITS INDICATING WHICH OF 16 BR'S TO REFRESH
	STH	R4,BPSF,R13		:UPDATE BACK-PRESSURE FLAGS
	LH	R0,CFOB,R13		:BUSYnew = CFOB .AND. BPSF
	NR	R0,R4
	LH	R3,BUSY,R13
	STH	R0,BUSY,R13
	NR	R0,R3			:PARTIAL OVERLOAD = BUSYold .AND. BUSYnew
	OR	R5,R0
	AIS	R13,2
	LIS	R0,0F			:BIT COUNTER
RT8	CHVR	R4,R4			:CHECK HIGH BIT
	JGEFS	RT9			:DON'T REFRESH THIS COUNT
	LB	R3,IOT,R1,		:YES...GET GOUGING BITS
	SRHLS	R3,6
	AR	R3,R3			:MAKE GOUGING BITS INTO HALF-WORD INDEX
	LHL	R2,BKPRCN,R3		:GET APPROPRIATE BACK-PRESSURE CONSTANT
	STH	R2,BR,R1,
RT9	SLHLS	R4,1			:ADVANCE TO NEXT BIT
	AIS	R1,2
	SIS	R0,1
	JGEBS	RT8
	AIS	R12,2
	SIS	R8,1
	JG	RT7			:MOVE TO NEXT GROUP OF 16 CHANNELS
	LR	R5,R5			:CHECK OVERLOAD CONDITION
	JE	RT16			:NO...PROCEED
	LIS	R5,1			:YES...COUNT IT
	AHM	R5,OVLD,RL2
	J	RT16			:ALL CHANNELS PROCESSED FOR THIS LINE

:	NORMAL DATA CHANNEL LOGICAL RECORD
RT10	CLI	R1,0FFFC		:CHECK FOR UNASSIGNED ENTRY
	JNFS	RT11			:PERMUTER TABLE ENTRY NOT FOR ZAPPED CIRCUIT
	AR	R12,R8
	J	RT16			:SKIP OVER THIS RECORD

:	SPECIAL TESTS FOR FIRST CHAR IN RECORD
RT11	PERMS(0,RL2,P.LRNR)		:NUMBER OF LOGICAL RECORDS RECEIVED
	PERMS(,RL2,P.CHNI,R8)		:COUNT USER-CHANNEL CHARACTERS INPUT

	IF	ESYNC
	LHL	R0,BF,R1		:CHECK FOR ZERO BF
	JNFS	RT13			:IF NOT, CONTINUE
	AR	R12,R8			:DON'T BOTHER...JUST BUMP ISEC PTR
	J	RT16			:CHECK FOR END OF PHYSICAL RECORD
	EI	(ESYNC)

:	COPY CHARS FROM LOGICAL REC TO BUFFER
RT13	LB	R0,0,R12		:GET NEXT CHAR
	AIS	R12,1			:INCR SECTOR PTR
	CLHI	R0,3			:CHECK FOR SPECIAL CHARS
	JLE	RTSPCH			:PROCESS 0,1,2,3 CHARS
RT15	HS	0

	IF	ESYNC
	JAL	R5,WCI			:PUT CHAR IN BUFFER
	SIS	R8,1			:DECR BYTE COUNT
	JLE	RT16			:SKIP IF DONE

	L	R3,BE,R1		:GET BUFFER START ADDR
	AHM	R8,BCT,R1		:ADD BYTE COUNT TO BUFF BCT

	LHL	R2,0,R3			:SET UP SCRATCH REG FOR MICROCODE
	LHL	R0,0,R12		:  /
	EXHR	R2,R2			: /
	OR	R0,R2			:/

	HC	3B08			:RTD OPCODE, SCRATCH REG, BYTE COUNT
RT3C	HC	3C08			:CONTINUATION ENTRY POINT
	HC	RTNXBF-RT3C		:PC TO GET NEXT BFLET
	HC	RTC0-RT3C		:PC TO HANDLE CHAR=0 (CHAR PAIR)
	HC	RTC1-RT3C		:PC TO HANDLE CHAR=1 (PREFIX CODE)
	HC	RTGOB-RT3C		:PC TO HANDLE CHAR=2 (GOBBLER)
	HC	RTZAP-RT3C		:PC TO HANDLE CHAR=3 (ZAPPER)

	ST	R3,BE,R1		:UPDATE BE

	ELSE	:1-ESYNC
	JAL	R5,WCI			:WRITE CHAR IN BUFFER
	SIS	R8,1			:DECR BYTE COUNT
	JGBS	RT13			:CONTINUE IF NOT DONE WITH LOGICAL RECORD
	EI	(1-ESYNC)

RT16	LR	R7,R7
	JG	RT3			:CONTINUE IF DONE WITH PHYSICAL RECORD

RT17	LH	R1,SECMSK,RL2		:GET APPROPRIATE SECTOR MASK
	NH	R1,CDIS,RL2
	RBT	R1,ISF,RL2		:SECTOR IS FREE FOR MORE INPUT
	LIS	R1,1
	STH	R9,LRR,RL2		:THIS IS THE MOST UP TO DATE ACKNOWLEDGEMENT INFO
	AHM	R1,CDIS,RL2		:NOW WE CAN LOOK FOR THE NEXT SECTOR
	AHM	R1,INDATA,RL2		:INCREMENT PACKET-RECEIVED COUNTER
	AHM	R1,ANYDATA,RL2		:...OTHER ONE TOO
	J	RT1			:GO PROCESS NEXT SECTOR FOR THIS LINE IF IT'S THERE

:	PROCESS SPECIAL TYMNET CHARS
RTSPCH	CLHI	R0,2
	JLFS	RTCP			:CHAR = 00 OR 01
	JEFS	RTGOB0			:CHAR = 02
	JG	RTZAP0			:CHAR = 03

:	GOBBLER
RTGOB	HS	0
	IF	ESYNC
	ST	R3,BE,R1		:UPDATE BE
	LIS	R0,2
	EI

RTGOB0	JAL	R4,SPEED		:EMPTY BUFFER
	J	RT15

:	CHAR	PAIR
RTCP	JAL	R5,WCI			:PUT FIRST CHAR IN BUFFER

	IF	ESYNC
	JFS	RTCP1

RTC0	LIS	R0,0
	JFS	RTCP0
RTC1	LIS	R0,1
RTCP0	STB	R0,0,R3			:STORE CHAR IN CASE MICROCODE DID NOT (EVEN ADDR)
	ST	R3,BE,R1		:UPDATE BE
	LIS	R2,1			:ADJUST BCT FOR MICROCODE REENTRY
	SR	R2,R8			: /
	AHM	R2,BCT,R1		:/
	EI	(ESYNC)

RTCP1	SIS	R8,1			:DECR BYTE COUNT
	JGFS	RTCP2			:CONTINUE IF OK
	JAL	R5,CLEAR		:ERROR - SPLIT CHAR PAIR - CLEAR BUFFER
	LHI	R1,$8 100324
	J	RTE
RTCP2	LB	R0,0,R12		:GET NEXT CHAR FROM SECTOR
	AIS	R12,1			:INCR SECTOR PTR
	J	RT15

:	ZAPPER
:	RTD DEASSIGNS BUFFER ON RECEIVE SIDE AND LEAVES
:	SEND SIDE BUFFER ON A PASS-THROUGH TO BE DEASIGNED
:	BY RMAKE AFTER IT GETS ZAPPER INTO OSEC.
RTZAP	HS	0
	IF	ESYNC
	ST	R3,BE,R1		:UPDATE BE FOR CLEAR
	LIS	R0,3
	EI	(ESYNC)

RTZAP0	XHI	R1,4			:OTHER BUFF OF PAIR
	JAL	R5,CLEAR		:EMPTY IT
	LIS	R5,0
	STH	R5,BF,R1		:AND CANCEL IT
	XHI	R1,4			:INCOMING BUFFER AGAIN
	JAL	R4,SPEED		:EMPTY IT
	LCS	R4,1
	STH	R4,IOT,R10,R11		:DEASSIGN PERMUTER TABLE ENTRY
	J	RT15

	IF	ESYNC
:	GET NEXT BFLET FOR BUFFER FROM FREE LIST
RTNXBF	LR	R5,R3			:SAVE BFLET END ADDR
	LHL	R3,FREELT		:GET HEAD OF FREE LIST
	JNFS	RTNXB1			:SKIP IF NOT EMPTY
	JAL	R2,WRE			:GET RESERVE TANK
RTNXB1	STH	R3,0,R5			:LINK HEAD OF FREE LIST TO END OF BUFFER
	SLLS	R3,CBSZL		:CALC BFLET ADDR
	AI	R3,BUFERS		:/
	LHL	R2,CBSZ-2,R3		:GET LINK TO NEXT BFLET
	STH	R2,FREELT		:NEW HEAD OF FREE LIST
	J	RT3C			:CONTINUE
	EI	(ESYNC)

:	ERROR HANDLING
RTE0	LHI	R1,$8 100024		:LOGICAL RECORD COUNT = 0
:	ERROR...RECORD ERROR CONDITION, RESET THE LINE
RTE	STH	R1,INERR,RL2
	LH	R1,SECMSK,RL2
	NH	R1,CDIS,RL2
	RBT	R1,ISF,RL2
	L	R1,MFASTC,,
	ST	R1,TSLR,RL2,RL2		:RESET THE LINE
	LA	R0,YLRES
	LA	R1,ZRESET
	ST	R0,YSUB,RL2,RL2
	ST	R1,ZSUB,RL2,RL2
	J	RT1

:	RECORD MAKER.  MAKES PHYSICAL RECORDS FOR SYNCHRONOUS LINKS.

:	RUNS OFF TIMEOUT LOGIC, TO AVOID EXCESSIVE SMALL PACKETS

:	R1	BUFFER NUMBER
:	R6	CFOB ADRS FOR A LINE
:	R7	LINE IOT DISPLACEMENT FROM SYMBOL IOT
:	R8	POINTER TO BEGINNING OF LOGICAL RECORD
:	R9	CHARACTER SPACE LEFT IN PHYSICAL RECORD
:	R10	COUNT DOWN FOR LOGICAL RECORD
:	R11	SIZE OF LOGICAL RECORD
:	R12	BYTE INDEX
:	R13	IOT INDEX

RMAKE	AHI	R1,$A RATE/50		:50 TIMES/SECOND IS ENOUGH TO SERVICE ALL
	JAL	R5,TOPUT		:LINES AT ALL SPEEDS, STILL AVOID MAKING AN
					:EXCESSIVE NUMBER OF SMALL PACKETS
	LHI	RL2,NLINES*2		:MAKE PHYSICAL RECORDS FOR ALL LINKS
RM1	SIS	RL2,2			:MOVE TO NEXT LINE
	JL	TORET			:ALL LINES SERVICED
:	DON'T GET TOO FAR AHEAD. IT'S A MISTAKE TO USE UP A SECTOR IF JUST A
:	TRICKLE OF INFO HAS ARRIVED. AFTER COS INCREMENTS THE TRICKLE MAY
:	ACCUMULATE INTO A REASONABLE SIZE RECORD.
	LH	R0,CAOS,RL2
	SH	R0,COS,RL2		:0 IF OK TO MAKE RECORD
	OH	R0,RTF,RL2		:CHECK RETRANSMISSION IN PROGRESS FLAG
	JNBS	RM1
	LHL	R12,SECMSK,RL2		:GET SECTOR MASK FOR THIS LINE
	NH	R12,CAOS,RL2		:BIT INDEX TO SECTOR FOR THIS LINE
	TBT	R12,OSF,RL2
	JN	RM1			:SECTOR OCCUPIED

:	INITIALIZE SOME RECORD MAKING PARAMETERS
	LR	RL,RL2
	SRHLS	RL,1			:LINE NUMBER
:	SECTOR BASE IS OSECPT(2*RL) + OSOFST(CAOS)
	LHL	R12,OSOFST,R12,R12
	AH	R12,OSECPT,RL2		:BASE ADDRESS
	STH	R12,SECBEG		:SAVE POINTER TO START OF SECTOR
	AIS	R12,4			:SET TO ADDRESS OF FIRST CONTENT BYTE
	LHI	R9,$A58			:PHYSICAL RECORD CHR COUNT LIMIT

	L	R0,MFASTC,,
	CL	R0,TIMEB,RL2,RL2
	JL	RM5			:BACKPRESSURE NOT DUE YET
	LHI	R0,RATE/2
	AM	R0,TIMEB,RL2,RL2	:SET NEXT DUE TIME
	PERMS(0,RL2,P.BPNS)		:NUMBER OF BACK-PRESSURE RECORDS SENT
	LHL	R0,GROUPN,RL2		:NUMBER OF GROUPS
	EXBR	R1,R0
	AHI	R1,1,R1			:FORM 2*GROUPN|Channel1 FOR LOGICAL HEADER
	STH	R1,0,R12
	AIS	R12,2			:PUT IT INTO PHYSICAL RECORD
	SIS	R9,2			:DECR. SPACE LEFT COUNTER
	LHL	R3,CHANI,RL2		:POINT TO CHANNEL 0 PERMUTER TABLE ENTRY
	LIS	R6,6			:SET UP MASKS
	LHI	R7,3FFF

:	RM2 THRU RM4 SET A BIT IN THE BACKPRESSURE RECORD FOR EACH CHANNEL OF
:	THE LINE. 1 ASKS NEIGHBOR TO REFRESH BR COUNT. BR COUNT IS NOT REFRESHED
:	IF BIT IS 0. THIS INVOKES BACKPRESSURE. THERE ARE AS MANY BITS
:	AS THERE ARE CHANNELS (ALWAYS A MULTIPLE OF 16).
RM2	LCS	R4,1
	LCS	R5,$A 15
RM3	LH	R13,IOT,R3,
	CLHI	R13,-1			:CHECK FOR UNASSIGNED CHANNEL
	JEFS	RM4
	LR	R1,R13			:EXTRACT THE HIGH BITS
	SRHLS	R1,$A13
	NR	R1,R6
	LHL	R1,BKPRCN,R1		:GET THE APPROPRIATE BACK-PRESSURE CONSTANT
	NR	R13,R7			:REMOVE THESE BITS FROM ENTRY
	SLLS	R13,2			:4*BUFF#
	CLH	R1,BCT,R13
	JGEFS	RM4
	XH	R4,HMASK+1E,R5,R5
RM4	AIS	R3,2
	AIS	R5,1
	JLE	RM3
	STH	R4,0,R12
	AIS	R12,2
	SIS	R9,2
	SIS	R0,1
	JN	RM2

:	MAYBE SEND SOME SUP INFO. FIRST COMPUTE RECORD SIZE.
RM5	LHL	R6,CFOBA,RL2		:CHECK BACK-PRESSURE FOR SUP CHANNEL
	LH	R7,BPSF,R6
	JGE	RM7			:SKIP IF APPLIED
	LR	R7,RL2
	SLLS	R7,2			:8*LINE#

	LH	R10,BCT+NPORT*8,R7	:OUTBOUND BCT FOR SUP INFO ON THIS LINE
	LHL	R7,CHANI,RL2
	CLH	R10,BR,R7,
	JLFS	.+8
	LH	R10,BR,R7,
	CLR	R10,R9
	JLFS	.+4
	LR	R10,R9
:	R10 IS MINIMUM OF BCT, BR LIMIT, AND SPACE LEFT IN RECORD.
	LIS	R5,6
	LR	R0,R10
	DHR	R0,R5			:SUP RECORDS ARE ALWAYS A MULTIPLE OF 6
	SR	R10,R0
	JE	RM7			:NO ROOM FOR 6 CHR REC OR NO DATA
	PERMS(,RL2,P.CHSO,R10)		:COUNT OF SUP CHARS OUTPUT
	EXBR	R0,R10
	STH	R0,0,R12		:LOGICAL RECORD COUNT LEFT, CHANNEL 0 (SUP) RIGHT
	LIS	R0,0
	SR	R0,R10
	AHM	R0,BR,R7,
	SHI	R9,2,R10
	AIS	R12,2
	LR	R1,RL2
	SLLS	R1,2
	AHI	R1,NPORT*8		:4*BUFF#
RM6	JAL	R5,GBI			:MAKE LOGICAL RECORD OF SUP INFO
	L	R0,0,R2			:GET DATA FROM BUFFER
	ST	R0,0,R12		:STORE IN OUTPUT SECTOR
	LHL	R0,4,R2		
	STH	R0,4,R12
	AIS	R12,6
	SIS	R10,6
	JG	RM6
	CLHI	R9,6
	JL	RM17

:	LOOK FOR TRAFFIC ON NORMAL CHANNELS. INCR. R6 FOR EACH GROUP PROCESSED.
RM7	LHL	R6,CFOBA,RL2
	LHL	R7,CHANI,RL2		:BEGINNING OF IOT AND CFOB FOR LINE
RM8	CLH	R6,CFOBA+2,RL2
	JEFS	RM10			:SKIP...NO MORE GROUPS ON THIS LINE
RM9	LH	R1,PCFOB,R6
	NH	R1,CFOB,R6
	JN	RM13			:ATTENTION FLAG SET AND NOT INHIBITED BY PCFOB
	AIS	R6,2
	AHI	R7,20
	JBS	RM8			:MOVE TO NEXT GROUP FOR THIS LINE

:	PASSED THROUGH ALL GROUPS AND CHANNELS FOR THIS LINE. NOW WRAP AROUND
:	PERMUTER TABLE.

RM10	RBT	RL,LVF,,		:MARK THIS LINE AS REASONABLY WELL SERVICED (SEE SECH)
	LIS	R2,0			:LEAVE R2 ZERO IF NOTHING LEFT TO DO
	LHI	R1,3FFF			:SET PCFOB BITS TO 1...
	LHL	R6,CFOBA,RL2		:...(EXCEPT FOR SUP, FLOW CHANNELS)
RM11	CLH	R6,CFOBA+2,RL2
	JEFS	RM12
	NH	R1,BPSF,R6		:FOLD IN BACK-PRESSURE
	STH	R1,PCFOB,R6		:...DON'T SEND IF BACK-PRESSURE IS APPLIED
	NH	R1,CFOB,R6
	OR	R2,R1
	LCS	R1,1
	AIS	R6,2
	JBS	RM11
RM12	LR	R2,R2
	JN	RM7
	J	RM17

:	WE HAVE A CHANNEL TO BE SERVICED
RM13	JAL	R3,BIDH			:WE HAVE ONE OR MORE CHANNELS IN GROUP
	LR	R13,R2			:TAKE ONE OF THESE
	AR	R13,R2
	LH	R1,IOT,R7,R13		:LOOK UP PERMUTER TABLE ENTRY
	CLHI	R1,-1			:CHECK IF NOT IN USE
	JE	RM24			:SPECIAL HANDLING FOR THAT CASE
	EXBR	R0,R1			:EXTRACT GOUGING LEVEL
	SRHLS	R0,3
	NHI	R0,18			:0 FOR NORMAL, 10 FOR GOUGED
	AHI	R0,-8			:LIMIT...PATCH THIS AREA FOR TESTING
	NHI	R1,3FFF			:TOSS GOUGING BITS
	XHI	R1,1			:COMPUTE ORIGINATION BUFFER
	SLLS	R1,2			:BUFFER INDEX FOR OUTBOUND TRAFFIC ON CHANNEL
	LHL	R10,BCT,R1		: # CHARACTERS TO BE SENT
	LHL	R11,BR,R7,R13		: # WE ARE PERMITTED TO SEND
	JGFS	RM13A
	LIS	R11,2			:MAY BE OVER-RIDING...THEN ALLOW SENDING 2 CHARS
RM13A	CLR	R10,R11
	JLEFS	RM13B
	LR	R10,R11			:R10 = MIN( # AVAILABLE, # ALLOWED)
RM13B	CLR	R10,R9			:COMPARE WITH # WE HAVE SPACE FOR
	JLEFS	RM13C			:ALL CAN GO
	PERMS(0A,RL2,P.LRRS)		:COUNT OF LOGICAL RECORDS THROTTLED
					: BY SPACE IN PACKET
	LR	R10,R9			:SEND ONLY AS MANY AS WE HAVE ROOM FOR
	SR	R0,R9			:CHECK AGAINST LIMIT
	JGFS	RM13D			:SKIP IF SENDING LESS THAN LIMIT
RM13C	RBT	R2,PCFOB,R6		:MARK THIS CHANNEL AS SERVICED
:	R10 IS MINIMUM OF BCT, BR RESRICTION, AND SPACE LEFT
RM13D	SR	R11,R10			:NEW NUMBER WE'RE PERMITTED TO SEND
	STH	R11,BR,R7,R13		:DECREMENT BUFFER RESTRICTION COUNT
	SIS	R11,6
	JGFS	RM13E			:DON'T MAKE TINY LOGICAL RECORD NEXT TIME THRU HERE
	RBT	R2,BPSF,R6		:IT'S NOT WORTH THE SLIGHT INEFFICIENCY
	RBT	R2,PCFOB,R6
	RBT	R2,BUSY,R6		:DATA EXHAUSTED, SO CIRCUIT CAN'T BE BUSY

:	INITIALIZE TO COPY BYTES FROM BUFFER SPACE TO OSEC
RM13E	LR	R11,R10
	LR	R8,R12
	LR	R0,R6
	SH	R0,CFOBA,RL2
	SLHLS	R0,3
	AR	R0,R2
	STB	R0,1,R12		:CHANNEL NUMBER
	PERMS(0,RL2,P.LRNS)		:NUMBER OF LOGICAL RECORDS SENT
	PERMS(,RL2,P.CHNO,R10)		:COUNT OF NORMAL CHARACTERS OUTPUT
:	COPY BYTES FROM BUFFER TO REC

	IF	ESYNC

	AIS	R12,1			:INCR R12 TO 1ST DATA CHAR IN OSEC -1
	L	R3,BB,R1		:GET BB

RM0D	LHL	R2,0,R3			:SET UP SCRATCH REG FOR MICROCODE
	LHL	R0,0,R12		:  /
	EXHR	R0,R0			: /
	OR	R0,R2			:/

RM0E	HC	0E0A			:RMAKE OPCODE, SCRATCH REG, BYTE COUNT
RM0F	HC	0F0A			:CONTINUATION ENTRY POINT
	HC	RMRET-RM0F		:PC TO RETURN AN EMPTY BFLET GO FREE LIST
	HC	RMC0-RM0F		:PC TO HANDLE CHAR=0 (CHAR PAIR)
	HC	RMC1-RM0F		:PC TO HANDLE CHAR=1 (PREFIX CODE)
	HC	RMGOB-RM0F		:PC TO HANDLE CHAR=2 (GOBBLER)
	HC	RMZAP-RM0F		:PC TO HANDLE CHAR=3 (ZAPPER)

RM16B	AIS	R12,1			:INCR OSEC PTR PAST LAST CHAR STORED
RM16C	LHL	R2,BCT,R1		:GET BUFF BYTE COUNT
	JEFS	RM16			:CONINUE IF BUFF ALREADY EMPTY
	ST	R3,BB,R1		:UPDATE BB
	SR	R2,R11			:SUBTRACT # CHARS MOVED FROM BCT
	STH	R2,BCT,R1		:UPDATE BCT
	JGFS	RM16			:IF BUFF NOT EMPTY - CONTINUE
	JAL	R5,GCLAST		:EMPTY BUFF - CLEAN UP

	ELSE	:1-ESYNC

	AIS	R12,2
RM14	JAL	R5,GCI
	CLHI	R0,3
	JLE	RM19			:00,01,02, OR 03 ENCOUNTERED
RM15	STB	R0,0,R12
	AIS	R12,1
	SIS	R10,1
	JGBS	RM14			:STORE CHR, INCR CTRS

	EI	(1-ESYNC)

RM16	SHI	R9,2,R11

	STB	R11,0,R8		:LOGICAL RECORD COUNT INTO LOG REC HEADER
	CLHI	R9,6			:IF PHYSICAL RECORD ALMOST FULL DO NOT CREATE A TINY
	JGE	RM9			:LOGICAL RECORD AT THE END

:	FINISH PHYSICAL RECORD
RM17	LHI	R4,$A58
	SR	R4,R9
	JNFS	RM17A			:RMAKE MADE SOMETHING FOR THIS LINE
	LH	R1,LRR,RL2		:LAST-RECORD-RECEIVED
	SH	R1,LRA,RL2		:LAST-RECORD-ACKNOWLEDGED
	NH	R1,ACKMSK,RL2		:NUMBER OF RECORDS OUTSTANDING
	SIS	R1,2
	JLE	RM1			:LESS THAN 2, IGNOR...MORE, SEND BACK EMPTY FOR ACK
RM17A	AIS	R4,3			:FORCE RECORD SIZE UP, INCLUDE HEADER, ROUND IT
	AIS	R12,1			:ALSO COMPUTE ADDRESS FOR CHECKSUM
	NHI	R12,0FFFE
	LH	R7,ACKSHF,RL2		:GET SHIFT FACTOR
	PERMS(,RL2,P.PKSM,R4)		:SIZE OF PACKET MADE
	PERMS(1,RL2,P.PKTT)		:NUMBER OF PACKETS MADE
	SRHLS	R4,1			:MAKE HW COUNT
	LR	R6,R4			:MAKE COPY
	AR	R6,R6			:COMPUTE ACTUAL BYTE COUNT IN RECORD
	SLL	R4,0,R7			:PHYSICAL RECORD COUNT FIELD
	LH	R1,ACKMSK,RL2		:GET FIELD MASK
	NH	R1,CAOS,RL2
	OR	R4,R1
	SLL	R4,0,R7			:MERGE IN SECTOR FIELD
	LH	R2,MACHNO		:MERGE DIRECTION BIT ON,
	SH	R2,MACH,RL2		: IF NEIGHBOR HAS HIGHER MACHINE NUMBER
	NHI	R2,4000
	IF	NUMSAT
	CLHI	RL,NUMSAT
	JGEFS	RM17B			:SKIP IF NOT SATELITE LINE
	OHI	R4,2000,R2		:ELSE SET HEADER
	JFS	RM17C			:AND SKIP
RM17B	OHI	R4,1000,R2		:NORMAL LINE
RM17C	ELSE
	OHI	R4,1000,R2
	EI	(NUMSAT)
	LHL	R1,SECBEG		:ADDRESS OF START OF SECTOR
	STH	R6,0,R1			:SAVE BYTE COUNT
	STH	R4,2,R1			:AND SAVE HEADER
	CHVR	R5,R4			:R4=VERT. CKSUM, R5=DIAGONAL CKSUM

	IF	ESYNC
	LIS	R0,2			:ALLOW FOR HEADER
	SR	R0,R6			:NEGATIVE BYTE COUNT IN R0 FOR MICROCODE
	AIS	R1,4			:START ADDR OF DATA IN R1

	HC	3741			:CKSUM OPCODE, R4=VERT, R5=DIAG, R1=ADDR

	STH	R4,0,R12		:STORE VERT CKSUM
	STH	R5,2,R12		:STORE DIAG CKSUM

	ELSE	:1-ESYNC
	LIS	R3,2			:ALLOW FOR HEADER
	SR	R3,R6			:NEGATIVE BYTE COUNT
	JEFS	RM18A			:SKIP IF RECORD IS EMPTY
RM18	LHL	R2,0,R3,R12		:GET A HALFWORD FROM SECTOR
	XR	R4,R2
	RLL	R5,1
	XR	R5,R2
	AIS	R3,2
	JLBS	RM18
RM18A	RLL	R5,1
	XR	R5,R4
	STH	R4,0,R12		:STORE VERTICAL CHECKSUM
	EXHR	R4,R5
	XR	R4,R5
	STH	R4,2,R12		:STORE DIAGONAL CHECKSUM
	EI	(1-ESYNC)

	LH	R1,SECMSK,RL2		:GET SECTOR MASK
	NH	R1,CAOS,RL2		:UPDATE CAOS FIRST THEN OSF SECOND FOR...
	LIS	R4,1
	AHM	R4,CAOS,RL2
	SBT	R1,OSF,RL2		: INTERRUPT SAFETY
	J	RM1

	IF	ESYNC
:	GOBBLER
RMGOB	SIS	R10,1			:JUST DECR COUNT
	JG	RM0E			:CONTINUE IF NOT DONE
	LIS	R0,2			:ELSE STORE GOBBLER IN CASE MICROCODE DID NOT (EVEN ADDR)
	STB	R0,0,R12		:/
	J	RM16B

:	HANDLE CHAR PAIR (CHAR=0 OR 1)

RMC0	LIS	R0,0			:CHAR=0
	JFS	RMCP

RMC1	LIS	R0,1			:CHAR=1

RMCP	STB	R0,0,R12		:STORE CHAR IN CASE MICROCODE DID NOT (EVEN ADDR)
	SIS	R10,2			:DECR COUNT FOR 2 CHARS
	JGEFS	RMCP1			:CONTINUE IF ROOM
:	NO ROOM FOR 2 CHARS IN RECORD
	ST	R3,BB,R1		:UPDATE BB FOR WCD
	JAL	R5,WCD			:RETURN 1ST CHAR OF PAIR TO BUFFER
	L	R3,BB,R1		:RESTORE BB
	LCS	R5,1			:DECR BCT SINCE...
	AHM	R5,BCT,R1		:...WCD INCR'D IT
	SIS	R11,1			:ADJUST COUNT - LAST CHAR NOT STORED
	J	RM16C			:DONE WITH LOGICAL RECORD

RMCP1	LB	R0,0,R3			:GET 2ND CHAR
	AIS	R12,1			:INCR LOG REC PTR
	STB	R0,0,R12		:STORE IN LOG RECORD
	AIS	R3,1			:INCR BB
	THI	R3,CBSZ-1		:BFLET BOUNDARY?
	JNFS	RMCP2			:NO
	JAL	R5,RMRET1		:YES, RETURN BFLET
RMCP2	LR	R10,R10			:CHECK COUNT
	JG	RM0D			:>0 - MORE TO DO
	J	RM16B			:=0 - DONE WITH LOG REC

	ELSE	(1-ESYNC)
:	SPECIAL CHR 0,1,2, OR 3 RECEIVED
RM19	JE	RM21
	CLHI	R0,2
	JE	RM15
:	CHR PAIR. DON'T SPLIT CHR PAIR.
	SIS	R10,1
	JEFS	RM20
	STB	R0,0,R12
	JAL	R5,GCI
	AIS	R12,1
	J	RM15

RM20	JAL	R5,WCD
	SIS	R11,1
	J	RM16
	EI	(1-ESYNC)

:	CIRCUIT ZAPPER RECEIVED

	IF	ESYNC
RMZAP	ST	R3,BB,R1		:UPDATE BB FOR CLEAR
	EI

RM21	JAL	R5,CLEAR		:THROW AWAY TRAILING DATA
	LIS	R0,0
	STH	R0,BF,R1		:DISABLE ATTENTION FLAGGING
	CLHI	R1,8*NPORT
	JLFS	RM22			:FOR OTHER THAN PORT BUFFERS,
	XHI	R1,4
	JAL	R5,CLEAR		:CLEAR ANY INFO WE HAVE RECEIVED FOR THIS CHANNEL
	XHI	R1,4
RM22	LCS	R0,1
	STH	R0,IOT,R7,R13		:FREE PERMUTER TABLE ENTRY
	LIS	R0,3			:NOTHING BUT THIS ZAPPER WILL TRAVEL FOR THIS CHANNEL
	SHI	R11,-1,R10

	IF	ESYNC
	STB	R0,0,R12		:STORE ZAPPER
	AIS	R12,1			:INCR OSEC PTR PAST CHAR
	J	RM16

	ELSE	(1-ESYNC)
	LIS	R10,1
	J	RM15
	EI	(1-ESYNC)

:	CLEAR AND DEASSIGN ALL BUFFERS POINTING TO THIS ENTRY
RM24	AR	R13,R7
	SRLS	R13,1
	RBT	R13,CFOB
	AHI	R13,RCFOB*8
	LIS	R1,0
RM25	CLH	R13,BF,R1
	JEFS	RM26
	AIS	R1,4
	CLHI	R1,4*NBUF
	JNBS	RM25
	J	RM9
RM26	JAL	R5,CLEAR
	LIS	R0,0
	STH	R0,BF,R1
	J	RM25

	IF	ESYNC
:	RETURN AN EMPTY BFLET TO FREE LIST
RMRET	LA	R5,RM0F			:CONTINUATION ADDR FOR MICROCODE
RMRET1	LHI	R2,-1,R3		:BACK UP BB
	CL	R2,BE,R1		:WAS THIS THE LAST CHAR IN BUFFER?
	JER	R5			:YES, GCLAST WILL RETURN THIS BFLET

	LHL	R4,0,R3			:GET NEXT BFLET#
	SLLS	R4,CBSZL		:CONVERT TO BFLET ADDR
	AI	R4,BUFERS		:/

	LHL	R2,FREELT		:HEAD OF FREE LIST
	STH	R2,0,R3			:LINK FREE LIST TO END OF BFLET

	SI	R3,BUFERS+CBSZ-2
	SRLS	R3,CBSZL		:CONVERT BFLET ADDR TO BFLET#
	STH	R3,FREELT		:MOVE BFLET TO HEAD OF FREE LIST
	LR	R3,R4			:R3=NEW BB
	JR	R5			:RETURN

	EI	(ESYNC)

	EI	(NLINES)
	SUBTTL	SERVICE INTERNAL CIRCUITS
:		"Internal circuits" are STRANGE!!  Buffers assigned to two
:	ports are interconected through an "Internal permuter table" which
:	is one group long (16 entries).  However, it takes 2 of these entries
:	to describe a circuit, and, since this is treated like a "line"
:	in LEP2, the SUP can't assign 0 or 1, because of conflict with flow-
:	control and sup channels.  Furthermore, the SUP reserves the next pair
:	for PJ, and will never use them for anything else.  We end up with a
:	total of 12 entries usable (6 circuits allowable).
:		This is how a source and destination buffer are connected
:	(B=buffer, P=port, I=internal entry):

:		   ------	  -------		   ------
:		B1O| Ib |	Ia| B2I |		B2O| Ia |
:		   ------	  -------		   ------
:	P1	{				P2	{
:		   ------	  -------		   ------
:		B1I| xx |	Ib| B1I |		B2I| yy |
:		   ------	  -------		   ------

:	Entries are set to -1 if not in use.

:	SET BUFFER RESTRICTION BIT FOR INTERNAL CIRCUITS
INT	ST	R0,RET4
	LIS	R0,0
	STH	R0,PCFOBI		:SET TO EXAMINE NONE
	LIS	R15,0F			:FOR EACH CHANNEL:
INT1	LIS	R1,1			:CHECK OTHER INTERNAL ENTRY OF PAIR
	XR	R1,R15
	LH	R1,IOTI,R1,R1
	AIS	R1,1
	JEFS	INT2			:IGNOR IF NOT IN USE
	NHI	R1,3FFF			:ELSE EXTRACT BUFFER NUMBER
	SLLS	R1,2			:4*BUFF#
	LHL	R1,BCT-4,R1		:CHECK CHAR COUNT
	CLHI	R1,100
	JGEFS	INT2			:SKIP IF TOO MANY CHARS ALREADY THERE
	SBT	R15,PCFOBI		:ELSE TURN ON THE BIT
INT2	SIS	R15,1			:REPEAT FOR EACH CHANNEL
	JGE	INT1

:	NOW MOVE THE DATA
INT3	LHL	R1,CFOBI		:DATA PRESENT FOR CHANNEL
	NH	R1,PCFOBI		:CHANNELS WHICH CAN ACCEPT MORE DATA
	JE	RET			:EXIT IF NOTHING LEFT TO DO
	JAL	R3,BIDH			:ELSE DETERMINE WHICH CHANNEL CAN RECEIVE
	RBT	R2,PCFOBI		:SET IT DONE FOR THIS CHANNEL
	LR	R15,R2
	LIS	R14,1
	XH	R14,IOTI,R15,R15	:GET SOURCE BUFFER NUMBER
	NHI	R14,3FFF
	SLLS	R14,2			:COMPUTE SOURCE BUFFER INDEX
	LIS	R13,1
	XR	R13,R15			:COMPUTE OTHER CHANNEL OF PAIR
	LHL	R12,IOTI,R13,R13	:GET DESTINATION BUFFER INDEX
	NHI	R12,3FFF		:CANCEL GOUGING LEVEL
	SLLS	R12,2			:COMPUTE DESTINATION BUFFER INDEX
	LHI	R11,100
	SH	R11,BCT,R12		:COMPUTE SPACE IN DESTINATION
	CLH	R11,BCT,R14		:USE MIN(SPACE, AVAILABLE)
	JLEFS	INT4
	LHL	R11,BCT,R14
INT4	LR	R1,R14			:GET A CHAR
	JAL	R5,GCI
	CLHI	R0,3			:CHECK FOR NETWORK CONTROLS
	JLEFS	INT7			:SKIP IF SO
INT5	LR	R1,R12			:SET DESTINATION
INT6	JAL	R5,WCI			:PUT CHAR AWAY
	SIS	R11,1
	JGBS	INT4			:REPEAT AS NECESSARY
	J	INT3			:THEN PROCESS OTHERS AS NECESSARY

:	SPECIAL CHARS
INT7	JE	INT9			:SKIP IF ZAPPER
	CLHI	R0,2
	JNFS	INT8			:SKIP IF CHAR PAIR

:	GOBBLER
	LR	R1,R12
	JAL	R4,SPEED		:JUST SPEED IT ALONG
	JBS	INT6			:AND CONTINUE

:	CHAR PAIR
INT8	LR	R1,R12
	JAL	R5,WCI			:PASS FIRST OF PAIR
	SIS	R11,1			:COUNT A CHAR GONE
	LR	R1,R14
	JAL	R5,GCI			:GET SECOND
	J	INT5			:AND CONTINUE

:	ZAPPER
INT9	JAL	R5,CLEAR		:EMPTY BUFFER BEHIND US
	LIS	R6,0
	STH	R6,BF,R1		:CLEAR BUFFER FLAG FOR SOURCE
	XHI	R1,4			:COMPUTE OTHER BUFFER OF PAIR
	JAL	R5,CLEAR		:CLEAN IT OUT TOO
	LR	R1,R12			:NOW FOR DESTINATION...
	JAL	R4,SPEED		:SPEED IT ALONG
	JAL	R5,WCI
	XHI	R1,4			:COMPUTE OTHER BUFFER OF PAIR
	JAL	R5,CLEAR		:EMPTY IT
	STH	R6,BF,R1		:CLEAR IT'S BF
	LCS	R2,1
	STH	R2,IOTI,R15,R15		:CANCEL SOURCE PERMUTER TABLE ENTRY
	STH	R2,IOTI,R13,R13		:CANCEL DESTINATION PERMUTER TABLE ENTRY
	J	INT3			:AND CONTINUE WITH NEXT CHANNEL
	IF	PERMEA
	SUBTTL	PERFORMANCE MONITORING UPDATE

:	THIS ROUTINE RECEIVES CONTROL EACH P.TIMS INTERVAL TO UPDATE
:	THE F.TABL PERFORMANCE STATISTICS AND INCREMENT THE F.TIDX
:	TIME INDEX.
PERCTL	AI	R1,P.TIME		:SCHEDULE FOR P.TIME INTERVAL FROM NOW
	JAL	R5,TOPUT

	LA	R1,F.RELC		:UPDATE ALL LINE PERFORMANCE DATA FIELDS
	LHI	R7,(NM-1)*2		:SET ARRAY INDEX TO UPDATE FOR EACH LINE
	JAL	R0,PERUPD		:PERFORM UPDATE

	LA	R1,F.MISC		:UPDATE MISCELLANEOUS STATISTIC FIELDS
	LIS	R7,0			:SINGLE FIELDS, SET ARRAY INDEX TO ZERO
	JAL	R0,PERUPD		:PERFORM UPDATE

	LM	R8,TIMOVL		:GET OVERLOAD ARRAY FOR THE PAST
	STM	R8,F.NOVL,R2,		: TIME PERIOD AND UPDATE F.NOVL CURRENT
	LM	R8,ZEROES		: TIME SLOT ARRAY 8 FULLWORDS AT A TIME. ALSO
	STM	R8,TIMOVL		: REFRESH TIMOVL ARRAY WITH ZEROES.
	LM	R8,TIMOVL+20
	STM	R8,F.NOVL+20,R2,
	LM	R8,ZEROES
	STM	R8,TIMOVL+20

:	UPDATE F.TIDX TO POINT TO NEXT TIME SLOT
	AHI	R2,F.TBSZ		:ADD SLOT SIZE
	CLHI	R2,F.DTAS		:WRAPPING AROUND TABLE?
	JLFS	PERC10			:NO
	LIS	R2,0			:YES - BACK TO TABLE BEGINNING
PERC10	STH	R2,F.TIDX,,
	J	TORET			:DONE

ZEROES	WC	0,0,0,0,0,0,0,0		:FOR CLEARING 8 F/W'S AT A TIME


:			***  F.TABL MAPPING TABLES  ***

:	THE FOLLOWING TABLES ARE USED AS ARGUMENTS FOR THE PERUPD ROUTINE.
:	EACH TABLE CONSISTS OF ANY NUMBER OF 2 FULLWORD ENTRIES, WITH
:	-1 AS THE END-OF-TABLE INDICATOR.  THE TABLE ELEMENTS ARE DEFINED
:	VIA A MACRO WITH THE FOLLOWING ARGUMENTS:
:	ARGUMENT 1 - SOURCE POINTER. REAL TIME COUNTER GETS REFRESHED TO
:		ZERO AFTER UPDATE.
:	ARGUMENT 2 - DESTINATION POINTER.  F.TABL FIELD FOR CURRENT TIME SLOT.
:	ARGUMENT 3 - FIELD LENGTH.  SOURCE AND DESTINATION FIELDS ARE SAME LENGTH.
:		(SET TO 1 FOR WORD ARGUMENTS, 0 FOR HALF-WORD).

:	GENERATES TWO WORD ENTRY:
:		FIRST WORD IS FIELD SOURCE
:		SECOND WORD IS DESTINATION
:			SIGN BIT IS ON IF *WORD* QUANTITY


:	F.RELC - RELOCATION MAP TO UPDATE F.TABL WITH LATEST ENTRIES FROM
:	P.TABL. EACH TABLE ELEMENT HAS 3 FULLWORD ENTRIES - P.TABL
:	FIELD NAME (SOURCE), F.TABL FIELD NAME (DESTINATION), AND FIELD
:	LENGTH IN BYTES. ALL FIELDS IN F.RELC REPRESENT NETWORK LINE
:	STATISTICS, AND ARE UPDATED FOR EACH LINE.
FTABLM	MACRO(A1,A2,S)[
	IF	S
	WC	A1,80000000!A2
	ELSE
	WC	A1,A2
	EI
]
F.RELC	WS	0
	FTABLM(T.CHNI,F.CHNI,1)		:NORMAL CHARACTERS INPUT
	FTABLM(T.CHSI,F.CHSI,1)		:SUPERVISOR CHARACTERS INPUT
	FTABLM(T.CHNO,F.CHNO,1)		:NORMAL CHARACTERS OUTPUT
	FTABLM(T.CHSO,F.CHSO,1)		:SUPERVISOR CHARACTERS OUTPUT
	FTABLM(T.PKSM,F.PKSM,1)		:SIZE OF PACKETS MADE
	FTABLM(T.PKSR,F.PKSR,1)		:SIZE OF PACKETS RECEIVED
	FTABLM(P.PKTT,F.PKTT,0)		:NUMBER OF PACKETS MADE
	FTABLM(P.PKRC,F.PKRC,0)		:NUMBER OF PACKETS RECEIVED
	FTABLM(P.LRNR,F.LRNR,0)		:NUMBER OF LOGICAL RECORDS RECEIVED
	FTABLM(P.LRNS,F.LRNS,0)		:NUMBER OF LOGICAL RECORDS SENT
	FTABLM(P.LRRS,F.LRRS,0)		:NUMBER OF LOGICAL RECORDS RESTRICTED BY PACKET SIZE
	FTABLM(P.BPNS,F.BPNS,0)		:NUMBER OF BACKPRESSURE RECORDS SENT
	FTABLM(P.BPNR,F.BPNR,0)		:NUMBER OF BACKPRESSURE RECORDS RECEIVED
	FTABLM(P.LOVH,F.LOVH,0)		:NUMBER OF 1/2 SECOND LINE OVERLOADS
	FTABLM(P.LNER,F.LNER,0)		:NUMBER OF LINE ERRORS
	WC	-1


:	F.MISC - THIS TABLE PROVIDES MAPPING INFORMATION FOR MISCELLANEOUS
:	INDEPENDENT STATISTICS (NOT FOR EACH LINE).
F.MISC	WS	0
	FTABLM(P.PORT,F.PORT,1)		:NUMBER OF PORTS COUNTED BY 1-SECOND LOGIC
	FTABLM(P.PTHR,F.PTHR,1)		:NUMBER OF PASSTHRUS
	FTABLM(P.SECC,F.SECC,1)		:NUMBER OF 1-SECOND OCCURRENCES
	FTABLM(P.XCTR,F.XCTR,1)		:NUMBER OF EXEC LOOP ITERATIONS
	FTABLM(P.RETK,F.RETK,0)		:NUMBER OF RETAKES OF THIS NODE
	FTABLM(RMPTW,F.RMPW,0)		:NUMBER OF BF'S CLEARED IN RM21
	FTABLM(PTRCTR,F.PTUN,0)		:NUMBER OF NON-NULL PERMUTER TABLE ENTRIES USED
	FTABLM(BFUCTR,F.BFUN,0)		:NUMBER OF LEP2 REJECTS DUE TO NON-ZERO BF
	FTABLM(LEPREJ,F.LEPR,0)		:NUMBER OF LEP MESSAGES REJECTED
	WC	-1
	KILL	FTABLM			:DON'T NEED MACRO ANY MORE


:	PERUPD - THIS ROUTINE UPDATES THE F.TABL TABLE BASED ON THE CALLING
:	ARGUMENT IN REG 1, WHICH IS A MAPPING TABLE IN THE FORMAT OF F.RELC.
:	THE SOURCE FIELDS ARE STORED INTO THE DESTINATION FIELDS BEFORE BEING
:	REFRESHED TO ZERO. THE VALUE OF F.TIDX PROVIDES THE DISPLACEMENT
:	INTO THE PROPER TIME SLOT.

:	REGISTER USAGE:

:	CALLING
:R0	LINK
:R1	POINTER TO RELOCATION TABLE
:R7	MAXIMUM INDEX (DECREMENTS TO NEGATIVE VALUE)

:SCRATCH REGS - R2-R7, R13-R14
:R2	TIME (DISPLACEMENT) INDEX
:R3	ARRAY INDEX
:R4	WORK REG FOR ADDING SOURCE TO DESTINATION FIELD
:R5	ZERO, FOR CLEARING SOURCE FIELDS
:R6	INDEX FOR FULLWORD FIELDS
:R13	PRIMARY INDEX TO SOURCE FIELD
:R14	PRIMARY INDEX TO DESTINATION FIELD

PERUPD	LIS	R5,0			:TO REFRESH SOURCE FIELDS
	LHL	R2,F.TIDX,,		:TIME (DISPLACEMENT) INDEX INTO F.TABL
PERUP1	LR	R3,R7			:GET MAX ARRAY HALFWORD INDEX
	L	R13,0,R1		:GET NEXT RELOCATION TABLE ELEMENT
	JLR	R0			:NEGATIVE - END OF TABLE
	L	R14,4,R1		:GET NEXT DESTINATION TABLE ELEMENT
	AHI	R1,8			:BUMP RELOCATION TABLE INDEX
					: TO NEXT 8-BYTE ELEMENT
	AR	R14,R2			:DESTINATION POINTER BIASED BY TIME INDEX VALUE
	JG	PERUP3			:HALFWORD DESTINATION
:	DESTINATION FIELD IS FULLWORD. SET UP R6 AS F/W INDEX
	LR	R6,R3			:HALFWORD INDEX TIMES 2
	AR	R6,R6			:TIMES 4
PERUP2	L	R4,0,R13,R6		:GET FULLWORD REAL-TIME COUNTER
	ST	R5,0,R13,R6		: AND CLEAR IT
	ST	R4,0,R14,R6		:UPDATE DESTINATION COUNTER
	SIS	R6,4
	JGEBS	PERUP2			:UPDATE ARRAY FOR ALL LINES
	J	PERUP1			:GET NEXT RELOCATION TABLE ELEMENT

:	HALFWORD DESTINATION FIELD
PERUP3	LHL	R4,0,R13,R3		:GET HALFWORD REAL-TIME COUNTER
	STH	R5,0,R13,R3		: AND CLEAR IT
	STH	R4,0,R14,R3		:UPDATE DESTINATION COUNTER
	SIS	R3,2
	JGEBS	PERUP3			:DO FOR ALL LINES
	J	PERUP1

PERMND	EI	(PERMEA)
	SUBTTL		M I S C E L L A N Y

	IF	SAL

:	PERFORM LOGON FUNCTION IN BOTH DIRECTIONS
LOGIN	ST	R0,RET4
	LHI	R10,(NPORT/8)-4		:SEARCH FOR WORK TO DO
LOGA	L	R1,LOGON,R10		:PORT IN LOGON MODE
	N	R1,LOGGER,R10		:AND WITH DATA PRESENT
	JNFS	LOGB			:SKIP IF SOMETHING TO DO
	SIS	R10,4
	JGEBS	LOGA			:REPEAT FOR ALL PORTS
	J	RET			:THEN EXIT

:	WE HAVE A PORT TO PROCESS LOGONS FOR
LOGB	JAL	R3,BID			:GOT ONE...WHICH ONE?
	LR	R11,R10			:COMPUTE PORT #
	SLHLS	R11,3			:ALLOW FOR COUNT BY 4'S
	AR	R11,R2
	LR	R12,R11
	SLHLS	R12,3			:MAKE BUFFER INDEX
:	PROCESS ANOTHER CHARACTER IF ANY THERE
LOGC	TBT	R11,LOGGER		:CHECK IF DATA PRESENT
	JE	LOGA			:CONTINUE WITH OTHER PORTS IF NOT
	LR	R1,R12			:ELSE SET UP BUFFER INDEX
	JAL	R5,GCI			:GET NEXT CHARACTER
	CLHI	R0,3			:LOOK FOR ZAPPERS
	JN	LOGD			:SKIP IF NOT A ZAPPER
	RBT	R11,ACP			:GOT A ZAPPER...SET PORT NOT ACTIVE
	RBT	R11,LOGON		:NOT IN LOGON MODE
	RBT	R11,LOGGING		:NOT IN LOGON MODE
	LR	R8,R0			:COPY THE ZAPPER
	JAL	R5,CLEAR		:CLEAR THE BUFFERS
	AIS	R1,4
	JAL	R5,CLEAR
	TBT	R11,HPFLAG		:IS THIS A HOST PORT?
	JE	LOGU			:NO...SEND ON TO OUR SUP
	STH	R11,PORT		:YES...REPORT PORT FREE

	IF	ACCT
:	TERMINATE ACCOUNTING
	LIS	R0,3			:INDICATE USER ZAP
	JAL	R4,AARLO		:REPORT FINAL COUNTS
	LHL	R11,PORT		:RESTORE PORT #
	EI	(ACCT)

	JAL	R9,ZAPP
	LIS	R0,4			:SEND ZAPPER TO DISPATCHER
	LB	R1,TXITBL,R11		:GET ISIS PORT #
	LHI	R2,ZAPMSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	J	LOGA			:AND QUIT FOR THIS PORT

:	NOT A ZAPPER...CLEAN OUT NETWORK CHARS
LOGD	CLHI	R0,7			:CHECK FOR NETWORK CHARS
	JG	LOGG			:SKIP IF NOT
	CLHI	R0,5
	JE	LOGE			:SKIP IF GREEN BALL
	CLHI	R0,6
	JE	LOGE			:SKIP IF RED BALL

	IF	PSGLAS+SPGLAS
	CLHI	R0,4			:SPECIAL LDEM?
	JNFS	LOGD1			:NO
	SBT	R11,SEMICO		:SET SEMI-: FLAG
	J	LOGC
LOGD1	EI	(PSGLAS+SPGLAS)

	SIS	R0,1			:YES...CHECK IT
	JG	LOGC			:SINGLE CHAR...IGNOR
	JL	LOGF			:ESCAPED...SKIP
	JAL	R5,GCI			:PREFIX...TEST FOR YELLOW BALL
	CLHI	R0,0FF
	JN	LOGC			:OTHER PREFIX--TOSS
	XHI	R1,4
	LIS	R0,1
	JAL	R5,WCI			:BOUNCE ORANGE
	LHI	R0,0FE
	JAL	R5,WCI
	XHI	R1,4
	J	LOGC
:	RETURN READ OR GREEN BALLS
LOGE	XHI	R1,4
	JAL	R5,WCI
	XHI	R1,4
	J	LOGC
:	WE HAVE AN ESCAPED DATA CHAR
LOGF	JAL	R5,GCI			:ESCAPED...GET IT
:	WE HAVE A REAL LOGON CHARACTER
LOGG	OHI	R0,80			:SET HIGH BIT
	LR	R8,R0			:COPY THE CHAR

	IF	SPGLAS+PSGLAS
	RBT	R11,SEMICO		:RESET SEMI-: FLAG
	JEFS	LOGG0			:SKIP IF PREVIOUSLY RESET
	SBT	R11,LOGECHO		:TURN ECHO BACK ON
	CLHI	R0,0BA			:IS CHAR AFTER SEMI-: A COLON?
	JE	LOGG2			:YES, SEND THE COLON W/O THE SEMI-:
	JAL	R5,WCD			:NO, REPLACE THE CHAR IN BUFF
	LHI	R8,0BB			:SEND SEMI-: FIRST
	J	LOGI
LOGG0	EI	(SPGLAS+PSGLAS)

	CLHI	R0,88			:CHECK FOR ^H
	JNFS	LOGG1			:SKIP IF NOT
	RBT	R11,ECHOMSK		:SUPPRESS ECHO FOR HDX TERMINALS
	SBT	R11,HAFDUX		:GENERATE PASSWORD MASKS
LOGG1	CLHI	R0,09F			:CHECK FOR PRINTABLE CHAR
	JLE	LOGH			:DON'T ECHO IF NON-PRINTABLE
LOGG2	TBT	R11,LOGECHO		:SHOULD WE ECHO?
	JE	LOGH			:NO
	TBT	R11,ECHOMSK
	JE	LOGH			:NO ECHO FOR THIS TID
	XHI	R1,4			:YES...SHIP IT BACK
	JAL	R5,WCI

	IF	ACCT
	TBT	R11,HPFLAG		:IS THIS A HOST PORT?
	JEFS	LOGH			:NO, DON'T DO ACCOUNTING
	SLLS	R11,2			:4*PORT#
	LIS	R5,1
	AM	R5,AAOC,R11,		:INCR THE OUTPUT CHAR COUNT
	SRLS	R11,2			:RESTORE PORT #
	EI	(ACCT)

LOGH	CLHI	R8,8D			:LOOK FOR C/R
	JEFS	LOGI
	CLHI	R8,88			:OR FOR CONTROL-H
	JEFS	LOGJ			:...WHICH TURNS OFF ECHO,
	CLHI	R8,0BB			:OR FOR SEMI-:
	JNFS	LOGK
LOGI	RBT	R11,LOGON		:C/R OR SEMI-:...TURN OFF LOGON MODE
LOGJ	RBT	R11,LOGECHO		:INSURE NO MORE ECHOS
LOGK	TBT	R11,HPFLAG		:WHERE DO WE SEND THIS?
	JE	LOGT			:TO TYMNET

:	DIRECT CHARACTER TO ISIS IN LOGON MODE
	LIS	R0,4
	LB	R1,TXITBL,R11		:GET ISIS PORT #
	LHI	R2,NLOGCH		:SET LOGON CHARACTER
	JAL	R4,SLOR
	LR	R0,R8
	JAL	R4,PUTCH
	JAL	R4,ELOR			:TERMINATE LOGON MESSAGE

	IF	ACCT
:	COUNT THE CHAR
	LIS	R0,1
	SLLS	R11,2			:4*PORT#
	AM	R0,AAIC,R11,		:INCR THE INPUT CHAR COUNT
	SRLS	R11,2			:RESTORE PORT #
	EI	(ACCT)

	JFS	LOGL			:AND SKIP

:	ZAPPER RECEIVED ON NON-HOST PORT
LOGU	LIS	R0,0
	STH	R0,BF-4,R1		:CLEAR 'TO HOST' BF SO NEED1 CAN RE-ALLOCATE PORT

:	DIRECT CHARACTER IN R8 TO TYMNET SUPERVISOR
LOGT	LR	R7,R11			:SENT TO TYMNET SUP
	AR	R7,R7			:WHO EXPECTS BUFFER NUMBER
	LHI	R6,1000			:MESSAGE TYPE 1
	JAL	R9,LEPSNU		:SEND IT

LOGL	TBT	R11,LOGON		:SHOULD WE CONTINUE?
	JN	LOGC			:YES
	TBT	R11,ACP			:IS PORT STILL ACTIVE?
	JEFS	LOGM			:NO
	LIS	R1,4			:NO...COMPUTE OTHER BUFFER OF PAIR
	XR	R1,R12
	LIS	R0,1			:SEND BACK "ECHO OFF"
	JAL	R5,WCI
	LHI	R0,0C0
	JAL	R5,WCI
LOGM	J	LOGA			:AND QUIT FOR NOW

	ELSE	(1-SAL)

Q	EQ	.			:REMEMBER WHERE WE ARE
	ORG	40000			:BASE OF COMMUNICATIONS AREA UNDER MAC

::NKU	EQ	1+NSLOT+SUP		:NUMBER OF KERNEL USERS.  (NUMBER OF PORTS.)
					:(WE'LL ACTUALLY ALLOCATE ONE EXTRA, FOR TTY)
::KBSS	EQ	6
::KBS	EQ	1^KBSS			:KERNEL BUFFER SIZE FOR EACH IN- AND
					:OUT- BUFFER OF EACH PORT

RDISPL	HS	1			:USED FOR DISPLAY DRIVER
RNEWLOG	HS	8			:BIT ARRAY OF NEW LOGIN PORTS RECEIVED BY NODE
RZAPEM	HS	8			:BIT ARRAY OF PORTS TO ZAP
RKOF	HS	8			:A BIT ON FOR EACH PORT THAT HAS OUTPUT READY TO SEND
RKOFF	HS	8			:A BIT ON FOR EACH PORT THAT *REQUIRES* ATTENTION
	HS	8
	HS	8
RKIB	BS	(NKU+1)*KBS		:KERNEL INPUT BUFFERS
RKOB	BS	(NKU+1)*KBS		:KERNEL OUTPUT BUFFERS
RNII	BS	NKU+1			:NEXT IN INPUT ARRAY
RNMI	BS	NKU+1			:BETWEEN NEXT IN AND NEXT OUT
RNOI	BS	NKU+1			:NEXT OUT FOR INPUT BUFFERS
RNIO	BS	NKU+1
RNOO	BS	NKU+1
	ORG	Q			:RETURN TO WHERE WE WERE

:	KERNEL CHARACTER INPUT
:	R1	BUFFER NUMBER TIMES 4
:	R6	BUFFER INDEX MODULO KBS
:	R7	NUMBER OF CHARACTERS TO MOVE
:	R8	USER NUMBER
:	R9	USER BASE RELATIVE TO KIB
:	R13	GROUP INDEX
:	R14	MASK FOR KBS MODULO
:	R15	BIT ARRAY OF PORTS WAITING FOR INPUT SERVICE
KIN	ST	R0,RET4			:SAVE RETURN
	LHI	R13,(NKU-1)/10*2	:GROUP INDEX
	LHI	R14,KBS-1		:SET MASK FOR FOLDING CURSORS
KI0	LH	R15,ACP,R13
	NH	R15,TOPORT,R13		:CHOOSE PORTS TO LOOK AT FOR INPUT
KI1	LR	R1,R15
	JN	KI2			:MORE TO DO
	SIS	R13,2			:ON TO NEXT PORT
	JGEBS	KI0			:CONTINUE UNTIL ALL GROUPS EXHAUSTED
	J	RET			:ALL PORTS SERVICED
KI2	JAL	R3,BIDH			:GOT A PORT TO SERVICE
	XH	R15,HMASK,R2,R2		:CLEAR PORT FROM BIT ARRAY
	LR	R8,R13			:COMPUTE ACTUAL PORT #
	SLHLS	R8,3			:CONVERT GROUP TO PORT (ALLOW FOR COUNT BY 2)
	AR	R8,R2
	LR	R1,R8			:AGAIN
	SLLS	R1,3			:BUFFER INDEX IS 8*PORT NUMBER
	LB	R6,RNII,R8,		:OUR CURSOR
	LB	R7,RNOI,R8,		:KERNEL CURSOR
	SR	R7,R6
	JGFS	.+6			:SKIP IF KERNEL IS AHEAD OF US
	AHI	R7,KBS			:ELSE ALLOW FOR FOLDING
	SIS	R7,3			:COUNT < 4 MEANS BUFFER FULL, NO ROOM FOR POSSIBLE PAIR
	JLE	KI1			:QUIT IF NOT ROOM TO MOVE DATA INTO BUFFER
	AIS	R7,1			:HOW MANY CHARS WE HAVE ROOM FOR
	CLH	R7,BCT,R1		:NUMBER OF CHARS IN BUFFER
	JLEFS	.+6
	LH	R7,BCT,R1		:NUMBER OF CHRS IN BUFFER LESS, SO USE THAT MANY
	LR	R9,R1
	SLHLS	R9,KBSS-3		:R1 = 8*PORT ALREADY
KI3	JAL	R5,GCI			:GET A CHARACTER
KI4	STB	R0,RKIB,R6,R9		:SAVE THE CHARACTER
	AIS	R6,1			:MOVE POINTER
	NR	R6,R14			:ACCOUNT FOR POSSIBLE BUFFER FOLDING
	SIS	R0,1			:TEST FOR NETWORK CONTROL
	JGFS	KI5			:SKIP IF NOT CHARACTER PAIR
	JAL	R5,GCI			:PAIR...GET SECOND
	SIS	R7,1			:COUNT IT
	OHI	R0,100			:INSURE IT WON'T LOOK LIKE ANOTHER PAIR
	JBS	KI4			:GO BACK TO PUT IT IN
KI5	SIS	R7,1			:COUNT ANOTHER CHAR IN PLACE
	JG	KI3			:CONTINUE IF MORE ROOM
	STB	R6,RNII,R8,		:ADVANCE OUT CURSOR
	J	KI1			:THEN GO DO ANOTHER PORT


:	MOVE KERNEL OUTPUT
:	R1	BUFFER #
:	R6	CURRENT OUTPUT CURSOR
:	R7	# CHARS TO MOVE
:	R8	PORT #
:	R9	OUTPUT BUFFER BASE INDEX
:	R13	GROUP BIT MASK
:	R14	MASK FOR FOLDING CURSOR
:	R15	GROUP INDEX
KOUT	ST	R0,RET4			:SAVE RETURN
	LHI	R13,-1^(10-(NKU&0F))	:MASK FOR LAST GROUP
	LHI	R14,KBS-1		:SET MASK FOR FOLDING BUFFER
	LHI	R15,(NKU-1)/10*2
	JFS	KO1			:AND SKIP

KOUT0	RBT	R8,STOPO		:BACK-PRESSURE KERNEL
KO1	LHL	R1,STOPO,R15		:FOR PORTS NOT BACK-PRESSURED
	NH	R1,RKOF,R15,		:AND WITH DATA PRESENT
	OH	R1,RKOFF,R15,		:OR OUTPUT TO BE FORCED
	NR	R1,R13			:AND ONE OF THOSE TO BE EXAMINED
	JNFS	KO2			:SKIP IF ONE FOUND
	LCS	R13,1			:LOOK AT ALL BITS IN SUBSEQUENT GROUPS
	SIS	R15,2			:SEARCH ALL GROUPS
	JGEBS	KO1
	J	RET			:EXIT IF DONE

KO2	JAL	R3,BIDH			:GOT ONE...WHICH ONE?
	LR	R8,R15
	SLHLS	R8,3			:COMPUTE PORT NUMBER (ALLOW FOR COUNT BY 2)
	AR	R8,R2			:SAVE PORT # IN R8
	LR	R1,R8			:BUFFER # = (2*PORT# + 1) * 4
	SLLS	R1,3
	AIS	R1,4
KO3	RBT	R8,RKOFF,,		:CANCEL FORCE OUTPUT BIT
	JNFS	KO4			:SKIP IF IT WAS SET
	LB	R2,BCT,R1		:CHECK DATA ALREADY IN BUFFER
	LR	R2,R2
	JG	KOUT0			:MORE THAN 256 CHRS BACKED UP
KO4	RBT	R8,RKOF,,		:CANCEL DATA PRESENT FLAG
	LB	R6,RNOO,R8,		:GET CURRENT CURSOR FOR US
	LB	R7,RNIO,R8,		:GET CURRENT CURSOR FOR KERNEL
	SR	R7,R6			:HOW MANY CHARS THERE?
	JE	KO1			:TRY ANOTHER PORT IF NONE THERE
	NR	R7,R14			:ACTUAL NUMBER OF CHARS TO MOVE
	LR	R9,R8			:COPY PORT #
	SLHLS	R9,KBSS			:INDEX TO START OF OUTPUT DATA
	LIS	R4,0			:RESET FLAG REGISTER
KO5	LB	R0,RKOB,R6,R9		:GET NEXT CHARACTER
	AIS	R6,1			:BUMP TO NEXT CHAR
	NR	R6,R14			:FOLD OUR CURSOR
	STB	R6,RNOO,R8,		:UPDATE OUR CURSOR
	LR	R2,R4			:COPY FLAG
	AR	R2,R0			:ADD CHARACTER TO FLAG
	SIS	R2,3			:CHECK FOR CONTROL CHARS
	JLEFS	KO8			:SKIP IF CONTROL
KO6	LIS	R4,0			:RESET FLAG REGISTER
KO7	JAL	R5,WCI			:PUT CHAR INTO BUFFER
	SIS	R7,1			:COUNT IT DONE
	JG	KO5			:DO ANOTHER IF MORE CHARS EXIST
	LR	R0,R4			:DONE...CHECK FLAG
	JE	KO3			:FLAG RESET...NOT IN MIDDLE OF PAIR...CLEAN UP
	JBS	KO6			:DO ONE MORE...SPLIT CHARACTER PAIR
:	HERE WITH CONTROL CHARACTER
KO8	JEFS	KO9			:SKIP IF ZAPPER
	LHI	R4,100			:SET FLAG
	AIS	R2,1			:CHECK FOR GOBBLER
	JLBS	KO7			:NORMAL TREATMENT
	JAL	R4,SPEED		:PROCESS GOBBLER
	J	KO6			:AND GO ON, RESET FLAG
KO9	SIS	R7,1			:GOT A ZAPPER
	JEFS	KO10			:NOTHING SHOULD FOLLOW ZAPPER
	JAL	R10,CRASH		:CRASH IF IT DOES
KO10	LB	R4,RNII,R8,		:RESET ALL INPUT CURSORS
	STB	R4,RNMI,R8,
	STB	R4,RNOI,R8,
	JAL	R4,SPEED		:SEND ZAPPER
	JAL	R5,WCI
	RBT	R8,ACP			:CLEAR ACTIVE PORT
	LHI	R7,8000			:SPECIAL MESSAGE TYPE 0
	AR	R8,R8			:SR3 = BUFFER # FOR PORT
	JAL	R9,REPORT		:TELL SUP OF ZAP
	J	KO1			:GO ON TO SERVICE NEXT PORT
	EI	(SAL)

:		L E P R E C H A U N

:	LEP COMMUNICATES WITH SUPERVISOR
:	R14= BITS OF LINES FROM WHICH TO ACCEPT INPUT
	IF	SUP;:	R15 IS BASE ADDRESS OF SUP COMMUNICATION AREA;	EI

LEPBG	AHI	R1,$A RATE/20		:20 TIMES/SECOND IS ENOUGH TO SERVICE
	JAL	R5,TOPUT		:SUPERVISOR AT ALL LINE SPEEDS, WITHOUT
					:SPENDING EXCESSIVE TIME HERE, DISCOVERING
					:THAT THERE IS NOTHING (OR VERY LITTLE) TO DO.

LEPSUM	LHI	R0,$A (-600*NM)		:DETERMINE HOW MANY OUTBOUND SUP MESSAGES EXIST
	STH	R0,LTHROT		:PUT A THROTTLE ON HOW MUCH RMAKE WORK LEP CAN CREATE
	LCS	R14,1			:R14 IS MASK FOR WHAT LINES TO LOOK AT
	LH	R1,USWICH
	JLE	LEP			:LOOK AT ALL IF NO UPSTREAM
LEPSU1	RE	NM			:ONCE FOR EACH LINE
	AH	R0,NPORT*8+BCT+(.-LEPSU1)*2
	ER
	STH	R0,LTHROT		:COUNTER TO GO PLUS WHEN SUP OUTPUT EXCESSIVE
	JLFS	LEP			:NOT EXCESSIVE YET, SO LOOK AT ALL LINES
	LHI	R1,(NPORT+$A15)*8
	SH	R1,USWICH		:COMPUTE NUMBER OF UPSTREAM LINE
	SRHLS	R1,3
	LCS	R14,2			: = .NOT. 1
	RLL	R14,0,R1		:MASK CONTAINS BITS FOR ALL LINES EXCEPT TO SUP

LEP	IF	SUP
	LA	R15,SUPBASE,,		:SET BASE ADDRESS FOR SUP COMMUNICATIONS
	LH	R1,FULTIM		:CHECK LOCAL SUP INPUT.  SEE LEPSNU, SEC1.
	JEFS	LEPA			:SKIP IF SUP INPUT BFR NOT CLOGGED.
	LH	R1,NISI,R15
	SH	R1,NOSI,R15
	CHVR	R1,R1
	SHI	R1,2*(NS-NM-1)
	JG	TORET			:ABORT IF SUP IS NOT UNCLOGGING INPUT
LEPA	LH	R0,LTHROT		:CAN TAKE MORE OUTPUT FROM SUP
	JG	LEPB			:SKIP IF WE HAVE TOO MUCH ALREADY
	LH	R0,NOSO,R15
	CLH	R0,NISO,R15
	JE	LEPB			:NO LOCAL SUP OUTPUT
	LR	R3,R0			:OK...GET MESSAGE
	AIS	R0,2			:ADVANCE POINTER
	NHI	R3,NS*2-2		:ACCOUNT FOR FOLDING
	LHL	R8,SOB3,R3,R15		:GET MESSAGE TEXT
	LHL	R7,SOB2,R3,R15
	LH	R6,SOB1,R3,R15
	STH	R0,NOSO,R15		:NOW UPDATE CURSOR
	JL	LEPRET			:SUP SENT US UPSTREAM MESSAGE...SEND IT BACK
	LIS	R1,0			:DOWNSTREAM...SET FAKE BUFFER INDEX
	J	L1			:GO PROCESS MESSAGE
LEPB	EI
	LHL	R1,SUPBIT		:FIND LINES WITH INPUT WAITING
	NR	R1,R14
	JE	TORET
	JAL	R3,BIDH			:GET LINE NUMBER OF SUPBIT ATTENTION BIT BEING PROCESSED
	SLLS	R2,3
	LHI	R1,NPORT*8+4,R2
	JAL	R5,GBI			:GET THE RECORD
	LHL	R8,4,R2			:SR3
	LHL	R7,2,R2			:SR2
	LH	R6,0,R2			:GET SR1
	JGEFS	L1			:SKIP IF DOWN-STREAM RECORD
	LH	R5,USWICH		:UPSTREAM MESSAGE
	SHI	R5,-4,R1
	JE	LEPRET			:TOSS IT, UPSTREAM REC CAME FROM UPSTREAM
	JAL	R9,LEPPTS		:PASS TO SUP
	J	LEP
L1	LH	R5,USWICH		:DOWNSTREAM...CHECK ORIGIN OF MESSAGE
	SHI	R5,-4,R1
	JEFS	L2			:CAME FROM UPSTREAM
	CLH	R6,MACHNO		:NOT FROM UPSTREAM...IS IT TAKEOVER FOR US?
	JE	LEP0			:TAKEOVER FROM OTHER THAN UPSTREAM...PROCESS IT
	J	LEPRET			:DOWNSTREAM RECORD DIDN'T COME FROM UPSTREAM
L2	LR	R5,R6
	XH	R5,MACHNO
	THI	R5,0FFF
	JE	LEPDIS			:LEP MESSAGE IS FOR US
	LH	R1,DSWICH		:CHECK DOWN-STREAM
	JE	LEPRET			:NONE, SO RETURN IT
	CLHI	R1,NM
	JG	LEPRET
	SLLS	R1,2			:4*BUFF#
	AHI	R1,NPORT*8-8,R1
	JAL	R9,LEPSN
	J	LEP			:AND CONTINUE

:	USE 3 BIT SUP REC TYPE TO DISPATCH THRU LEPV TO APPROPRIATE ROUTINE
LEPDIS	LPHIST
	LHI	R5,07000		:SET MASK
	NR	R5,R6			:EXTRACT MESSAGE TYPE
	SRHLS	R5,$A10			:MESSAGE NUMBER*4
	J	LEPV,R5
LEPV	J	LEP0			:0
	J	LEP1			:1
	J	LEP2			:2
	J	LEP3			:3
	J	LEP4			:4
	J	LEP5			:5
	J	LEP6			:6
	J	LEP7			:7

:	TAKEOVER COMMAND
LEP0	LR	R0,R7
	SRHLS	R0,6
	CLHI	R0,$8555		:VALIDITY CHECK
	JN	LEPRET
	IF	PERMEA;	LIS	R0,1;	AHM	R0,P.RETK		:COUNT ANOTHER RETAKE;	EI
	LHI	R10,-4,R1
	LHI	R6,NM			:ANY OUTBOUND SUP TRAFFIC IS NOW IRRELEVANT
	LA	R1,SUPBUF-BF		:BUFFER INDEX FOR LINK 0 OUTBOUND SUP BUFFER
LEP0A	JAL	R5,CLEAR		:CLEAR ALL OUTBOUND SUP BUFFERS
	AIS	R1,8			:REPEAT FOR NEXT BUFFER
	SIS	R6,1
	JGBS	LEP0A

	JAL	R9,LEPSNU		:SEND TO OLD SUP, MESSAGE TYPE 0000
	LR	R1,R10
	STH	R1,USWICH
	IF	SUP;	JLFS	LEP0B			:DON'T CLEAR FOR OWN SUP;	EI
	JAL	R5,CLEAR
LEP0B	LIS	R0,0
	STH	R0,DSWICH
	LH	R7,N940L
	LH	R8,VERNO
	JAL	R9,LEPSNU
	LH	R7,CRASHC		:TEST CRASH CODE
	JGEFS	LEP0C			:REPORT ALREADY SENT
	LHI	R6,8000			:CANCEL FLAG
	XR	R6,R7
	STH	R6,CRASHC
	L	R8,CFROM,,		:PICK UP POINTER TO DIAGNOSTIC DATA
	JAL	R9,REPORT		:SEND REPORT
LEP0C	IF	1-SAL
	LH	R0,RGMT,,		:TEST IF WE HAVE UP-TO-DATE GMT
	JGEFS	LEP0D			:YES
	LHI	R6,6000			:NO...ASK SUP FOR NEW VALUE
	LHI	R7,8004
	LIS	R8,0
	JAL	R9,LEPSNU
LEP0D	LIS	R0,4			:INFORM ALL INTERFACES OF TAKEOVER
	JAL	R4,ROOM
	LHI	R0,200			:SPECIAL TYPE 2
	JAL	R4,PUTW
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
	LHI	R7,NPORT-1
LEP0E	LB	R6,AUXKEY,R7		:FLUSH ALL OUTSTANDING AUX KEYS
	LR	R6,R6			:LOOKING FOR NON-ZERO
	JE	LEP0F
	RBT	R6,ACLB			:RESET ACTIVE LOGON BUFFER FLAG
	LIS	R0,8			:8-BYTE MESSAGE
	LIS	R1,0			:FOR PORT 0
	STB	R1,AUXKEY,R7		:CLEAR KEY
	LIS	R2,09
	JAL	R4,SLOR			:START LOGICAL OUTPUT RECORD
	LB	R0,SLKEY,R6		:WITH SLOT KEY
	JAL	R4,PUTCH
	LR	R1,R6			:COMPUTE BUFFER NUMBER
	SLLS	R1,2			:4*BUFF#
	JAL	R5,CLEAR		:CLEAR BUFFER
	SRLS	R1,1			:BACK TO 2*BUFF#
	LHL	R0,INTKEY,R1		:GET INTERFACE KEY
	EXHR	R0,R0			:ERROR TYPE 0
	JAL	R4,PUTW
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
LEP0F	SIS	R7,1			:REPEAT FOR ALL PORTS
	JG	LEP0E
	EI	(1-SAL)
	LHI	R6,NPORT/8-4		:NOW HANG AND ZAP ALL NORMAL LOGONS
	IF	SAL
LEP0G	L	R1,HPFLAG,R6
	XHI	R1,-1			:.NOT. A HOST PORT
	N	R1,LOGGING,R6		:.AND. IN LOGIN STATE
	ELSE
LEP0G	L	R1,LOGON,R6
	EI	(SAL)
	JNFS	LEP0H
	SIS	R6,4
	JGEBS	LEP0G
	J	LEPSUM			:DONE...START OVER
LEP0H	JAL	R3,BID			:GOT ONE...WHICH ONE?
	LR	R7,R6
	SLHLS	R7,3			:COMPUTE PORT NUMBER...(ALLOW FOR COUNTING BY 4'S)
	AR	R7,R2
	RBT	R7,LOGON		:SET NOT IN LOGON STATE
	IF	SAL;	RBT	R7,LOGGING;	EI
	JE	LEP0G
	LR	R1,R7			:COMPUTE OUTBOUND BUFFER OF PAIR
	SLLS	R1,3			:4*BUFF#
	JAL	R5,CLEAR		:CLEAR BUFFER
	AIS	R1,4			:COMPUTE INBOUND BUFFER OF PAIR
	JAL	R5,CLEAR
	LIS	R0,3
	SBT	R7,ACKWAIT		:WE'LL WAIT FOR ACK
	IF	SAL
	JAL	R5,WCI			:PLACE A ZAPPER
	ELSE
	LR	R1,R7			:PORT #
	LHI	R2,ZAPMSG		:AND ZAP IT
	JAL	R4,SLOR			:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
	EI	(SAL)
	J	LEP0G			:AND TRY FOR ANOTHER

:	PLACE 2 SR3 CHRS IN BUFFER SPECIFIED BY SR2 (REG 7)
LEP1	LR	R1,R7
	SLLS	R1,2			:4*BUFF#
	IF	SUP
	JNFS	LEP1A			:SKIP IF NOT PORT 0
	CI	R8,8180			: FOR SLEEPING PILL
	JNFS	LEP1A			:SKIP IF NOT
	TS	SLEEP,,			:ELSE PASS IT TO SUP
	J	LEP			:AND CONTINUE
LEP1A	EI	(SUP)
	EXBR	R0,R8
	JAL	R5,WCI
	LR	R0,R8
	JAL	R5,WCI
	J	LEP

:	MAKE PERMUTER TABLE ENTRY
:	EXPECT:
:	SR2 (R7)	LLLL LLCC CCCC CCCC
:	SR3 (R8)	GGBB BBBB BBBB BBBB
:	WHERE:
:	L	LINE NUMBER
:	C	CHANNEL NUMBER
:	G	GOUGING BITS
:	B	BUFFER NUMBER
LEP2	LR	R10,R7
	SRHLS	R10,$A 10		:EXTRACT LINE NUMBER
	LH	R11,GROUPN,R10,R10	:GET NUMBER OF GROUPS ON LINE
	CLHI	R10,NM			:RANGE CHECK
	JLFS	LEP2A			:LEGAL LINE NUMBER
	CLHI	R10,10			:NOT LEGAL LINE...IS IT INTERNAL?
	JN	LEPRET			:ILLEGAL LINE NUMBER
	LIS	R11,1			:INTERNAL...LINE 16D, 1 GROUP
LEP2A	SLHLS	R11,4			:NUMBER OF CHANNELS ON LINE
	AR	R10,R10			:TWICE LINE NUMBER
	NHI	R7,3FF			:EXTRACT CHANNEL NUMBER
	CLR	R7,R11
	JGE	LEPRET			:CHANNEL NUMBER TOO HIGH
	CLHI	R7,2
	JL	LEPRET			:CHANNEL NUMBER TOO LOW
	LIS	R11,1
	XR	R11,R8			:OTHER BUFFER OF PAIR
	NHI	R11,3FFF
	CLHI	R11,NBUF
	JGE	LEPRET			:BAD BUFFER NUMBER
	SLLS	R11,2			:4*BUFF#
	CLHI	R11,(PASSBUF-BF)*2	:CHECK FOR PASSTHROUGHS
	JLFS	LEP2B			:IGNORE OTHER BUFFERS
	LH	R1,BF,R11		:IT WAS A PASS-THROUGH...CHECK
	JEFS	LEP2B			:NOT IN USE...PROCEED
	LIS	R0,1			:IT'S ALREADY IN USE!!
	AHM	R0,BFUCTR		:COUNT OCCURANCE
	J	LEPRET			:THEN TOSS REQUEST
LEP2B	LHL	R1,CHANI,R10
	SRHLS	R1,1			:HALF-WORD DISPLACEMENT FOR CFOB
	AR	R7,R1			:BIT DISPLACEMET FOR CFOB
	LHI	R10,8*RCFOB,R7		:NEW BF
	AR	R7,R7			:INDEX INTO PERMUTER TABLE
:	R7 NOW CONTAINS OVERALL INDEX INTO PERMUTER TABLES
:	R10 HAS THE NEW BF
:	R11 HAS 4 TIMES THE BUFFER NUMBER
	LH	R1,IOT,R7,
	AIS	R1,1			:CHECK IF P-TABLE ENTRY IS IN USE
	JE	LEP2C			:SKIP IF NOT
	SIS	R1,1			:YES...ZAP THE OLD CIRCUIT
	NHI	R1,3FFF
	SLLS	R1,2			:4*BUFF#
	JAL	R4,SPEED		:SPEED ALONG A ZAPPER
	LIS	R0,3
	JAL	R5,WCI
	XHI	R1,4			:OTHER BUFFER OF PAIR
	JAL	R5,CLEAR
	LIS	R0,0
	STH	R0,BF,R1
	LIS	R0,1
	AHM	R0,PTRCTR		:COUNT OCCURANCE OF CONDITION
LEP2C	STH	R8,IOT,R7,
	LH	R0,BF,R11
	RBT	R0,FLAGS
	JEFS	.+6
	SBT	R10,FLAGS
	STH	R10,BF,R11
	LHI	R7,8001
	JAL	R9,REPORT
	SRHLS	R11,3			:GET BACK PORT NUMBER AGAIN
	CLHI	R11,NPORT		:RANGE CHECK
	JGE	LEPSUM			:CODE BELOW APPLIES ONLY TO PORTS
	IF	SAL
	RBT	R11,LOGGING		:CLEAR LOGGING-IN FOR PORT
	J	LEP			:AND RETURN TO SCANNER
	ELSE
	RBT	R11,LOGON		:IS THIS A LOGON PORT?
	JE	LEP			:NO...QUIT FOR NOW
	LR	R7,R11			:YES...GET INVOICE NUMBER
	JAL	R6,INVOICE
	LIS	R0,$A 10		:10-BYTE MESSAGE
	JAL	R4,ROOM
	LR	R0,R11			:PORT NUMBER
	JAL	R4,PUTH
	LHI	R0,LOGOK^8		:(NORMAL) LOGON OK
	JAL	R4,PUTH
	L	R0,LO1			:INVOICE NUMBER
	JAL	R4,PUTW
	LH	R0,OHOST,R11,R11	:ORIGINATION HOST
	JAL	R4,PUTH
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
	J	LEPSUM			:AND START OVER
	EI	(SAL)

:	CHANGE CELL OR SPECIAL MESSAGE
LEP3	CHVR	R1,R7
	JL	LEP3S			:TEST IF SPECIAL LEP3 MESSAGE
	AR	R1,R1			:NO...CONVERT SUP ADDRESS TO BYTE ADDRESS
	LH	R0,DLOCK		:CHECK STATE OF LOCK
	JLFS	LEP3X			:UNLOCKED...GO DO IT
	CLHI	R1,DLOCK		:LOCKED...ONLY PERMIT RANGE...
	JL	LEP			...FROM DLOCK,...
	CLHI	R1,IOTA			:...TO IOTA (NON-INCLUSIVE)
	JGE	LEP
LEP3X	CLI	R1,ESEG0		:WRITE INTO CORE PERMITTED
	JGE	LEP
	STH	R8,0,R7,R7		:ADDRESS WITHIN 620 IMAGE
	J	LEP

:	TYPE 3, SUBTYPE SPECIAL
LEP3S	LIS	R2,0			:INITIATE SEARCH
LEP3S1	LH	R0,L3TAB,R2
	JE	LEPRET			:0 TERMINATES LIST
	SR	R0,R1			:ELSE TEST FOR SR2 MATCH
	JE	L3TAB+2,R2		:IF MATCH, GO TO ROUTINE
	AIS	R2,6			:ELSE GO TO NEXT ENTRY
	JBS	LEP3S1

L3TAB	HC	8000;	J	L30			:SUBTYPE 0...NORMAL LOGON STATUS
	HC	8004;	J	L34			:SUBTYPE 4...EMPTY A BUFFER
	HC	8005;	J	L35			:SUBTYPE 5...ZAP A BUFFER
	IF	1-SAL;	HC	800C;	J	L3C			:SUBTYPE C...DLOAD;	EI
	HC	800E;	J	L3E			:SUBTYPE E...REPORT LINE SPEEDS PLEASE
	HC	800F;	J	L3F			:SUBTYPE F...LOAD A NEIGHBOR
	HC	0			:0 TERMINATES LIST

:	SUBTYPE "0"...LOGON STATUS
:	NORMAL LOGON STATUS IN SR3
:	BITS ARE:
:	X X X 0 0 P P P P P P P P S S S
:	| | |	|		|
:	| | |	|		STATUS:
:	| | |	|		0 - CONTINUE
:	| | |	|		1 - PLEASE LOG IN
:	| | |	|		2 - ERROR, TYPE USER NAME
:	| | |	|		3 - ERROR, TYPE PASSWORD
:	| | |	|		4 - USERNAME
:	| | |	|		5 - PASSWORD
:	| | |	PORT NUMBER
:	| | EMPTY OUTPUT BUFFER
:	| ECHO ON IF SET
:	EMPTY INPUT BUFFER
	IF	SAL
L30	LR	R10,R8			:MAKE COPY OF SR3
	LIS	R11,7
	NR	R11,R8			:EXTRACT MESSAGE TYPE
	SLHLS	R11,2			:MAKE WORD INDEX
	SRHLS	R8,3			:NOW EXTRACT PORT #
	LHI	R1,0FF
	NR	R1,R8
	LR	R9,R1			:COPY PORT #
	SBT	R9,LOGON		:ALLOW CHARS TO FLOW
	THI	R10,4000		:TURN ECHO ON?
	JEFS	L30A			:NO
	SBT	R9,LOGECHO		:YES
L30A	SLLS	R1,3			:MAKE BUFFER INDEX
	CHVR	R10,R10			:SHOULD INPUT BUFFER BE FLUSHED?
	JGEFS	L30B			:SKIP IF NOT
	JAL	R5,CLEAR
L30B	AIS	R1,4			:NOW SET OUTPUT BUFFER
	THI	R10,2000		:FLUSH OUTPUT BUFFER?
	JGEFS	L30C			:NO
	JAL	R5,CLEAR
:	R9  = TYMNET PORT
:	R10 = STATUS
:	R11 = MESSAGE INDEX
L30C	LR	R11,R11			:CHECK IF 'CONTINUE'
	JE	LEP
	LA	R7,CRLF			:OUTPUT C/R, L/F
	JAL	R8,MSG

	IF	NETNAME&PSGLAS
	LA	R7,SECOND		:OUTPUT NET NAME
	JAL	R8,MSG
	LA	R7,SPAC			:...FOLLOWED BY A SPACE
	JAL	R8,MSG
	EI	(NETNAME+PSGLAS)

	IF	PSGLAS
	L	R7,LSM27T,R11		:ADDR OF BEG. OF MSG FOR 2741
	ELSE	(1-PSGLAS)
	L	R7,LSMS27,R11		:ADDR OF BEG. OF MSG FOR 2741
	EI	(1-PSGLAS)
	TBT	R9,ASCII		:IS IT REALLY ASCII TERMINAL?
	JEFS	L30E			:SKIP IF NOT
	IF	PSGLAS
	L	R7,LSMST,R11		:ADDR OF BEG. OF MSG FOR ASCII TERMINAL
	ELSE	(1-PSGLAS)
	L	R7,LSMS,R11		:ADDR OF BEG. OF MSG FOR ASCII TERMINAL
	EI	(1-PSGLAS)
	TBT	R9,HAFDUX		:IS IT HALF-DUPLEX TERMINAL?
	JNFS	L30D			:SKIP IF SO
	TBT	R9,AUX			:IS IT AN AUX CIRCUIT?
	JEFS	L30E			:SKIP IF NOT
	IF	PSGLAS
L30D	L	R7,LSMSHT,R11
	ELSE	(1-PSGLAS)
L30D	L	R7,LSMSH,R11		:HELP HALF DUX USERS HIDE PASSWORD
	EI	(1-PSGLAS)
L30E	JAL	R8,MSG

	IF	PSGLAS
	SRLS	R11,2
	TBT	R11,NLSOK		:SHOULD MSG BE FOLLOWED BY HANG?
	JN	LEP			:NO
	LIS	R0,1			:YES, APPEND HANG CHAR PAIR
	JAL	R5,WCI
	LHI	R0,0F0
	JAL	R5,WCI
	EI	(PSGLAS)

	J	LEP			:AND CONTINUE

	IF	2-PSGLAS-SPGLAS
LSMS	WC	LSMS0,LSMS1,LSMS2,LSMS3,LSMS4,LSMS5,LSMS0,LSMS0;
LSMS27	WC	LSMS0,LSMS1,LSMS2,LSMS32,LSMS4,LSMS52,LSMS0,LSMS0;
LSMSH	WC	LSMS0,LSMS1,LSMS2,LSMSC,LSMS4,LSMSE,LSMS0,LSMS0;
	EI	(2-PSGLAS-SPGLAS)

	IF	PSGLAS+SPGLAS
LSMST	WC	LSMS0,LSMS1T,LSMS2T,LSMS3,LSMS4T,LSMS5,LSMS0,LSMS0
LSM27T	WC	LSMS0,LSMS1T,LSMS2T,LSMS32,LSMS4T,LSMS52,LSMS0,LSMS0
LSMSHT	WC	LSMS0,LSMS1T,LSMS2T,LSMSC,LSMS4T,LSMSE,LSMS0,LSMS0

NLSOK	HC	$2 0001010000000000
	EI	(PSGLAS+SPGLAS)

LSMS0	BC	0;
	IF	2-PSGLAS-SPGLAS
LSMS1	SC	/please log in: /;
LSMS2	SC	/error, type user name: /;
	EI	(2-PSGLAS-SPGLAS)

	IF	PSGLAS+SPGLAS
LSMS1T	SC	/circuit cleared/
LSMS2T	SC	/bad user name/
	EI	PSGLAS+SPGLAS

LSMS3	SC	/error, type password: /;
	HC	ZMS32
LSMS32	EQ	.-1
	AC	/error, type password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
ZMS32	EQ	.-LSMS32-1;
	HC	ZMSC
LSMSC	EQ	.-1
	AC	/error, type password:/
	AC	/"8D"8A"FF###############/
	AC	/"8D"FF"FF+++++++++++++++/
	AC	/"8D"FF"FFOOOOOOOOOOOOOOO"8D/
ZMSC	EQ	.-LSMSC-1;
	IF	2-PSGLAS-SPGLAS
LSMS4	SC	/user name: /;
	EI	(2-PSGLAS-SPGLAS)

	IF	PSGLAS+SPGLAS
LSMS4T	SC	/user name missing/
	EI	(PSGLAS+SPGLAS)
LSMS5	SC	/password: /;
	HC	ZMS52
LSMS52	EQ	.-1
	AC	/password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
ZMS52	EQ	.-LSMS52-1;
	HC	ZMSE
LSMSE	EQ	.-1
	AC	/password:/
	AC	/"8D"8A"FF###############/
	AC	/"8D"FF"FF+++++++++++++++/
	AC	/"8D"FF"FFOOOOOOOOOOOOOOO"8D/
ZMSE	EQ	.-LSMSE-1;
	IF	NETNAME
PRIME	P.NAME()			:PRIMARY NET NAME;
SECOND	S.NAME()			:SECONDARY NET NAME;
FROM	SC	' from ';
TO	SC	' to ';
CRLF	SC	/"8D"8A/;
SPAC	SC	/ /;
	EI	(NETNAME)
:	DEFINE MACRO FOR TEXT FROM SOURCE (S.S) TO DESTINATION (D.D)
ROUTE	MACRO(S.S,D.D)[
	IF	NETNAME
	LA	R7,FROM;	JAL	R8,MSG			:" FROM "
	LA	R7,S.S;	JAL	R8,MSG			:"S.S"
	LA	R7,TO;	JAL	R8,MSG			:" TO "
	LA	R7,D.D;	JAL	R8,MSG			:"D.D"
	EI	(NETNAME)
]
	ELSE
L30	LR	R1,R8			:PORT NUMBER
	SRHLS	R1,3
	NHI	R1,0FF
	LIS	R5,7
	NR	R5,R8			:EXTRACT ERROR CODE
	EXBR	R8,R8			:EXTRACT CONTROL BITS
	NHI	R8,0E0
	OR	R5,R8
	THI	R0,20			:IS OUTPUT BUFFER TO BE FLUSHED?
	JNFS	L30A			:PASS ON DIRECTLY IF SO
	LR	R2,R1			:CHECK INPUT BUFFER
	SLLS	R2,3
	LHL	R0,BCT+4,R2		:IS IT EMPTY?
	JEFS	L30A			:YES
	XHI	R5,10			:NO...TOGGLE SPARE BIT, SHOULD FORCE NON-ZERO
	STB	R5,B4STAT,R1		:SAVE STATUS (WILL BE SENT AFTER BUFFER EMPTIES)
	J	LEP			:AND QUIT
L30A	LIS	R0,4			:EMPTY...PASS IT DIRECTLY IN
	LHI	R2,NLOGST
	JAL	R4,SLOR			:START-LOGICAL-OUTPUT-RECORD
	LR	R0,R5			:ADD STATUS
	JAL	R4,PUTCH
	JAL	R4,ELOR			:END-LOGICAL-OUTPUT-RECORD
	J	LEP			:AND QUIT
	EI

:	SUBTYPE "4"...EMPTY A BUFFER
L34	CLHI	R8,NBUF
	JGE	LEPRET
	LR	R1,R8
	SLLS	R1,2
	JAL	R5,CLEAR
	J	LEP

:	SUBTYPE "5"...PLACE ZAPPER IN A BUFFER
L35	CLHI	R8,NBUF
	JGE	LEPRET
	LR	R1,R8
	SLLS	R1,2
	JAL	R4,SPEED
	LIS	R0,3
	JAL	R5,WCI
	J	LEP
	IF	1-SAL

:	SUBTYPE "C"..."DLOAD"...KNOCK DOWN SYSTEM
L3C	CLHI	R8,7			:VALIDITY CHECK...R8 SHOULD BE 0-7
	JG	LEPRET			:IGNOR IF NOT SO
	LIS	R0,0			:ELSE TELL FLASHER TO TAKE IT DOWN
	CBT	R0,RDISPL,,		:(OR BACK UP, IF NO WATCHDOG)
	J	LEP			:SOMETHING TO DO,  JUST IN CASE FLASHER IS DEAD
	EI

:	SUBTYPE "E"...REPORT LINE SPEEDS
L3E	LHI	R1,-1^($A16-NM)
	STH	R1,LSF,,			:SUP WANTS TO SEE LINE SPEED REPORTS
	J	LEP

:	SUBTYPE "F"...LOAD NEIGHBOR
:	SR3 (R8) = LLLLLLCCCCCCCCCC
:	L = LINE #
:	C = CHANNEL #
L3F	LR	R10,R8			:EXTRACT LINE NUMBER
	SRHLS	R10,$A 10		:EXTRACT LINE NUMBER
	LH	R11,GROUPN,R10,R10	:GET NUMBER OF GROUPS ON LINE
	CLHI	R10,NM			:RANGE CHECK
	JLFS	L3F0			:LEGAL LINE NUMBER
	CLHI	R10,10			:NOT LEGAL LINE...IS IT INTERNAL?
	JN	LEPRET			:ILLEGAL LINE NUMBER
	LIS	R11,1			:INTERNAL...LINE 16D, 1 GROUP
L3F0	SLHLS	R11,4			:NUMBER OF CHANNELS ON LINE
	NHI	R8,3FF			:EXTRACT CHANNEL #
	CLHI	R8,1
	JLE	LEPRET			:CHANNEL 0, 1 NOT ACCEPTABLE
	SR	R11,R8
	JLE	LEPRET			:TOO MANY CHANNELS SPECIFIED
	AH	R8,IOTA,R10,R10		:ADD 1/2 POINTER TO PERMUTER TABLE ENTRY
	LH	R1,0,R8,R8		:GET PERMUTER TABLE ENTRY
	NHI	R1,3FFF			:CANCEL GOUGING
	SLLS	R1,2			:FINALLY...BUFFER INDEX
	JAL	R5,CLEAR		:CLEAR THE INPUT BUFFER
	IF	DOWLOA
	LH	R0,DOWSWI		:CHECK DOWNSTREAM SWITCH
	JN	L3F1			:SKIP IF ALREADY SET
	IF	PERMEA;	STH	R0,PERDMP		:SET .NOT. DUMP;	EI
	LIS	R0,$A 15
	STH	R0,BF,R1		:ELSE SET BF SO NO-ONE ELSE LOOKS AT US
	OHI	R1,8000			:SET SWITCH TO STATE 0
	STH	R1,DOWSWI
	L	R0,MSLOWC,,		:SET UP TIMER
	AHI	R0,DLDTIM		:...IN CASE TARGET LINE# NEVER ARRIVES
	ST	R0,DLDHTO		:STORE SLOWC TIME TO ZAP CIRCUIT
	J	LEP			:AND CONTINUE

L3F1	EI	(DOWLOA)		:CAN'T DO IT...ALREADY DOING IT
	LIS	R0,0
	STH	R0,BF,R1		:CANCEL IT
	XHI	R1,4			:NOW COMPUTE OTHER BUFFER OF THE PAIR
	JAL	R4,SPEED		:SPEED THE ZAPPER ALONG
	LIS	R0,3
	JAL	R5,WCI
	J	LEP			:AND CONTINUE

:	READ OUT 2 CELLS
LEP4	LHI	R10,7FFF		:SET MASK
	NR	R7,R10
	CLHI	R7,ENDCOR
	JGE	LEPRET
	NR	R10,R8
	CLHI	R10,ENDCOR
	JGE	LEPRET
	LH	R8,0,R7,R7		:ADDRESS WITHIN 620 IMAGE
	JAL	R9,REPORT
	LR	R7,R10
	LH	R8,0,R7,R7		:ADDRESS WITHIN 620 IMAGE
	JAL	R9,LEPSNU
	J	LEP

:	INPUT A MESSAGE TO HOST
LEP5	EXBR	R1,R8
	LBR	R1,R1			:EXTRACT SUBTYPE

	IF	SAL

	SIS	R1,9			:CHECK FOR NEW EXTERNAL LOGIN
	JN	LEPRET			:ABORT IF NOT
	LBR	R0,R7			:EXTRACT PORT #
	TBT	R0,ACP			:IS PORT ALREADY ACTIVE?
	JN	LEPRET			:IF SO, ABORT
	LBR	R7,R7			:LOGIN FOR INTERFACE...EXTRACT PORT NUMBER
	LHI	R0,MAXCHR		:SET UP INITIAL TRANSMIT LIMIT FOR PORT
	STB	R0,XLIMIT,R7
	SBT	R7,CTERM		:SET CIRCUIT-TERMINATED-ON-PORT FLAG
	STH	R7,PORT			:SAVE PORT #
	LIS	R1,0
	STB	R1,TXITBL,R7		:INDICATE ISIS PORT NOT ASSIGNED YET
	LR	R1,R7			:COPY PORT NUMBER
	SLHLS	R1,3			:MAKE INPUT BUFFER INDEX FROM PORT NUMBER
	LA	R0,RLOG*8,R7		:SET UP BF
	LHL	R2,BF,R1
	STH	R0,BF,R1
	RBT	R2,FLAGS
	SBT	R0,FLAGS		:WE EXPECT SOMETHING THERE
	JAL	R5,GCI			:GET TID
	LA	R9,LEPSUM		:SET ABORT RETURN ADDRESS
	THI	R0,@3			:IN CASE WE HAVE A ZAPPER OR GOBBLER,
	JE	ZAPP			:...THEN JUST ABORT
	STB	R0,LO8
	STB	R0,TIDTBL,R7		:SAVE TID FOR PSEUDO-NEEDLE PROCESSING
	JAL	R5,GCI
	JAL	R5,GCI
	JAL	R5,GCI			:TOSS ORIGINATION NODE AND PORT #
	LIS	R6,0			:SET COUNTER

	IF	SPGLAS
	LIS	R0,7			:MARK START OF LOGIN STRING IN BUFF
	JAL	R5,WCI			:/
	JAL	R5,GCI			:GET 1ST CHAR OF USERNAME
	CLHI	R0,0BF			:IS IT "?"? (TRANSPARENT GW USER)
	JEFS	LEP59H			:YES, DISCARD FOR NOW
	CLHI	R0,0A1			:IS IT A "!"?
	JNFS	LEP59G			:NO, PROCESS IT
LEP59H	AIS	R6,1			:YES, JUST COUNT IT
	EI	(SPGLAS)

LEP59A	JAL	R5,GCI			:GET USERNAME CHAR
LEP59G	NHI	R0,7F			:MASK DOWN CHAR TO 7-BIT
	AIS	R6,1			:COUNT IT
	CLHI	R0,0D			:TEST FOR C/R

	IF	SPGLAS
	JEFS	LEP59F			:WRITE CR INTO BUFFER
	CLHI	R0,03B			:TEST FOR SEMI-:
	JEFS	LEP59B
	OHI	R0,80			:SET CHAR MSB
	JAL	R5,WCI			:PUT USERNAME CHAR BACK INTO BUFFER
	JBS	LEP59A
LEP59B	LIS	R0,4			:PUT 04 IN BUFF TO INDICATE SEMI-: AFTER USERNAME
LEP59F	JAL	R5,WCI
	RBT	R7,SEMICO		:MAKE SURE SEMI-: FLAG IS RESET

	ELSE	(1-SPGLAS)
	JEFS	LEP59B
	CLHI	R0,03B			:TEST FOR SEMI-:
	JNBS	LEP59A			:TOSS ALL CHARS OF USER NAME
LEP59B	EI	(1-SPGLAS)
	THI	R6,1			:CHECK NUMBER OF CHARS PRESENT
	JEFS	LEP59C			:ALSO TOSS EXTRA PAD CHAR IF PRESENT
	JAL	R5,GCI
LEP59C	HS	0

	IF	SPGLAS
	JAL	R5,GCI			:MAKE SURE THIS IS THE START...
	CLHI	R0,7			:...OF THE LOGIN STRING
	JEFS	LEP59D			:YES IT IS
	JAL	R5,WCI			:NO, PUT IT AT THE END
	JBS	LEP59C			:AND LOOK FOR MORE
LEP59D	EI	(SPGLAS)

	IF	ACCT
	JAL	R4,AASTART		:INIT ACCOUNTING
	EI	(ACCT)
	LIS	R0,$A 11		:NOW REQUEST NEEDLE (NORMAL)
	LIS	R1,0
	LIS	R2,07
	JAL	R4,SLOR			:START LOGICAL OUTPUT RECORD
	JAL	R4,PUTCH		:PAD CHAR
	LHL	R0,PORT			:KEY IS PORT #
	JAL	R4,PUTH
	LIS	R0,0
	JAL	R4,PUTH			:DIALECT
	LHL	R0,N.HTBL,,
	JAL	R4,PUTH			:ORIG. HOST
	LHL	R4,PORT
	RBT	R4,AUX			:NOT AN AUX CIRCUIT
	RBT	R4,HAFDUX		:NOT HALF-DUPLEX TID
	SBT	R4,ASCII		:NOT A 2741 DEVICE
	SBT	R4,ECHOMSK		:PERMIT ECHO FOR THIS TERMINAL TYPE

	IF	SPGLAS
	RBT	R4,LOGECHO		:TURN ECHO OFF
	ELSE	(1-SPGLAS)
	SBT	R4,LOGECHO		:SET ECHO ON
	EI	(1-SPGLAS)

	LB	R0,TIDTBL,R4		:JUST PASS ON TID
	LHI	R1,1F
	NR	R1,R0
	SIS	R1,9
	JNFS	.+6
	RBT	R4,ASCII		:2741 TERMINAL TYPE
	LR	R1,R0			:COPY TID
	NHI	R0,@20			:STRIP H-DUX BIT
	XR	R1,R0			:REMEMBER IF IT WAS SET
	JEFS	.+$A10
	SBT	R4,HAFDUX
	RBT	R4,ECHOMSK		:NO ECHO FOR H-DUX EVER
	THI	R0,1F			:CONVERT AUX CIRCUIT TO PSEUDO-AUX TID
	JNFS	LEP59E
	AIS	R0,0E
	SBT	R4,AUX
	RBT	R4,ECHOMSK		:ALSO CANCEL ECHO
LEP59E	JAL	R4,PUTCH
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD

	ELSE	(1-SAL)

	SIS	R1,5			:SUBTYPE $8 5
	JE	LEP55
	SIS	R1,4			:SUBTYPE $8 11
	JE	LEP59
	SIS	R1,1			:SUBTYPE $8 12
	JN	LEPRET

:	SUBTYPE 12...INTERNALLY GENERATED NEW CIRCUIT
	LBR	R10,R7			:GET REAL PORT NUMBER
	LBR	R7,R8			:GET KEY
	LHI	R0,MAXCHR
	STB	R0,XLIMIT,R10		:SET UP INITIAL TRANSMIT LIMIT FOR PORT
	SBT	R10,CTERM		:SET CIRCUIT TERMINATED ON PORT FLAG
	SBT	R10,STOPIN		:SET INPUT NOT BACK-PRESSURED
	SBT	R10,STOPO		:SET OUTPUT NOT BACK-PRESSURED
	SBT	R10,ACP			:FLAG PORT AS ACTIVE
	JAL	R6,INVOICE		:COLLECT INVOICE #
	LIS	R0,$A 6			:SET 6-BYTE MESSAGE
	LR	R1,R10			:COPY PORT #
	LHI	R2,PNMSG		:PSEUDO NEEDLE
	JAL	R4,SLOR			:START LOGICAL OUTPUT RECORD
	LIS	R0,0
	LB	R9,AUXKEY,R7		:GET BUFFER #
	STB	R0,AUXKEY,R7		:AND CLEAR KEY
	RBT	R9,ACLB			:RESET ACTIVE LOGON BUFFER FLAG
	LB	R0,SLKEY,R9		:INDEX INTO SLOT KEY
	JAL	R4,PUTCH
	AR	R9,R9			:MAKE HALF-WORD INDEX
	LHL	R0,INTKEY,R9		:GET INTERFACE'S KEY
	JAL	R4,PUTH
	JAL	R4,ELOR			:END-LOGICAL-OUTPUT-RECORD
	LHI	R0,$A 60		:INSURE ENOUGH SPACE FOR THIS AND NEEDLE IF NECESSARY
	LR	R1,R10
	LHI	R2,LOGOK		:SUCCESSFUL LOGON
	JAL	R4,SLOR
	LIS	R0,0
	JAL	R4,PUTCH		:PADDING
	L	R0,LO1			:GET INVOICE #
	JAL	R4,PUTW
	LH	R0,AOHOST,R9		:ORIG. HOST #
	JAL	R4,PUTH
	LH	R3,LO0			:GET INTERNAL CIRCUIT FLAG
	JNFS	LEP5AA			:SKIP IF INTERNAL CIRCUIT
	JAL	R4,ELOR			:ELSE END-LOGICAL-OUTPUT-RECORD
	J	LEPSUM			:AND QUIT
LEP5AA	STH	R0,LO4			:SET...PASS ON ORIG. HOST TO NEEDLE
	LH	R0,ADIALC,R9
	STH	R0,LO7			:AND DIALECT CODE
	LIS	R0,0
	JAL	R4,PUTH			:PAD OUT THIS MESSAGE TO WORD BOUNDARY
	LHL	R0,PORTSV		:GET PREVIOUS PORT
	STH	R0,PORT			:SET UP FOR LEP59C
	J	LEP59C			:THEN CONTINUE WITH THE PRECEEDING LOGON

:	SUBTYPE 5...SUP MESSAGE
LEP55	LBR	R10,R7			:EXTRACT KEY
	CHVR	R7,R7			:CHECK SIGN OF SR2
	JL	LEP55B			:SKIP IF SET
	LB	R11,AUXKEY,R10		:NOT SET...GET BUFFER NUMBER
	SLLS	R11,2			:SHOULD NOT = 0
	JE	LEPRET
	LHI	R6,01000		:SEND BACK TYPE 1 SUP MESSAGES
	LR	R7,R10			:WITH KEY
	AR	R7,R7
	AIS	R7,1			:HERE WE NEED 2*KEY+1
LEP55A	LR	R1,R11			:GET BUFFER INDEX AGAIN
	LH	R0,BCT,R1		:ANY THING ELSE?
	JLE	LEPSUM			:NO...QUIT
	JAL	R5,GCI			:YES...GET ONE
	LR	R8,R0
	JAL	R9,LEPSNU		:SEND TO SUP
	JBS	LEP55A			:AND REPEAT

:	AUX TERMINATION
LEP55B	LB	R9,AUXKEY,R10		:GET KEY
	LR	R9,R9			:IGNOR IF 0
	JE	LEP
	NHI	R8,0FF			:CHECK ERROR INDICATION
	JE	LEP			:NONE...SUCCESS
	LIS	R0,8			:ERROR...ABORT
	LIS	R1,0
	RBT	R9,ACLB			:RESET ACTIVE LOGON BUFFER FLAG
	STB	R1,AUXKEY,R10		:CLEAR KEY
	LIS	R2,09			:SEND REJECT MESSAGE
	JAL	R4,SLOR			:START LOGICAL OUTPUT RECORD
	LB	R0,SLKEY,R9		:GET SLOT KEY
	JAL	R4,PUTCH
	AR	R9,R9			:MAKE BUFFER INDEX
	LHL	R0,INTKEY,R9		:GET INTERFACE KEY
	JAL	R4,PUTH
	LR	R0,R8			:AND ERROR CODE
	JAL	R4,PUTCH
	JAL	R4,ELOR			:END LOGICAL RECORD
	LR	R1,R9			:NOW FLUSH BUFFER...DON'T NEED IT ANY MORE
	AR	R1,R1			:4*BUFF#
	JAL	R5,CLEAR
	J	LEPSUM			:AND QUIT

:	SUBTYPE 9 ($8 11)...NEW EXTERNAL LOGIN
LEP59	LBR	R0,R7			:EXTRACT PORT #
	TBT	R0,ACP			:IS PORT ALREADY ACTIVE?
	JN	LEPRET			:IF SO, ABORT
	LBR	R7,R7			:EXTRACT PORT #
	CLHI	R7,NKU			:IS THIS A KERNEL PORT?
	JGEFS	LEP59A			:SKIP IF NOT FOR KERNEL
	SBT	R7,ACP			:SET ACTIVE PORT
	SBT	R7,RNEWLOG,,
	J	LEP

:	GET DATA FOR BUILDING NEEDLE
LEP59A	LHI	R0,$A 50		:INSURE RING-ROOM FOR NEEDLE!
	JAL	R4,ROOM
	LHI	R0,MAXCHR
	STB	R0,XLIMIT,R7		:SET UP INITIAL TRANSMIT LIMIT FOR PORT
	SBT	R7,CTERM		:SET CIRCUIT TERMINATED ON PORT FLAG
	STH	R7,PORT			:SAVE PORT NUMBER
	JAL	R6,INVOICE		:COLLECT INVOICE #
	LR	R1,R7			:COPY PORT #
	SRHLS	R7,HSHIFT-2		:SELECT HOST
	NHI	R7,0C
	LHL	R7,HOST0,R7		:GET APPROPRIATE HOST NUMBER
	NHI	R7,7FFF
	STH	R7,LO2			:SAVE IT TO MAKE A NEEDLE
	SLLS	R1,3			:MAKE INPUT BUFFER NUMBER FROM PORT NUMBER
	JAL	R5,GCI
	LA	R9,LEPSUM		:SET ABORT RETURN ADDRESS
	THI	R0,@3			:IN CASE WE HAVE A ZAPPER OR GOBBLER,
	JE	ZAPP			:...THEN JUST ABORT
	STB	R0,LO8			:ELSE SAVE TID
	JAL	R5,GCI
	NHI	R0,03F
	SLHLS	R0,6
	STH	R0,LO3
	JAL	R5,GCI
	NHI	R0,03F
	AHM	R0,LO3			:ORIG. NODE
	LIS	R0,0
	STH	R0,LO4			:ORIG. HOST
	STH	R0,LO7			:DIALECT CODE
	JAL	R5,GCI
	NHI	R0,7F			:TOSS ESCAPE BITS
	STH	R0,LO5			:ORIG PORT
	LHL	R2,LO3			:TEST IF COMING FROM THIS NODE
	SH	R2,MACHNO
	JN	LEP59C			:SKIP IF NOT
	LIS	R2,4			:YES...COMPUTE OUTGOING BUFFER INDEX
	XR	R2,R1
	LIS	R3,1
	XH	R3,BF,R2		:GET OUTBOUND BF, CONVERT TO OTHER INTERNAL P.T. ENTRY
	LHI	R0,3FFF			:SET A MASK,
	NH	R0,IOT-(10*RCFOB),R3,R3	:GET THAT INTERNAL PERMUTER TABLE ENTRY
	SRHLS	R0,1			:CONVERT TO PORT #
	LR	R1,R0			:COPY PORT #
	OHI	R0,08000		:SET INTERNAL PORT # FLAG
	STH	R0,LO5
	TBT	R1,HPFLAG		:CHECK IF ORIGINATED ON HOST PORT
	JEFS	LEP59B			:SKIP IF NOT
	TS	LO0			:ELSE SET FLAG
	LHL	R0,PORT			:SAVE PORT #
	STH	R0,PORTSV		:...UNTIL SUBTYPE 0A IS RECEIVED
	J	LEP			:AND START OVER
LEP59B	AR	R1,R1			:INTERNAL SOURCE, NORMAL CIRCUIT
	LH	R0,OHOST,R1		:PLACE ORIG. HOST
	STH	R0,LO4
	LH	R0,DIALCT,R1		:PLACE DIALECT CODE
	STH	R0,LO7
LEP59C	LHL	R0,PORT			:FOR THIS PORT:
	SBT	R0,ACP			:SET ACTIVE PORT
	SBT	R0,STOPIN		:SET INPUT NOT BACK-PRESSURED
	SBT	R0,STOPO		:SET OUTPUT NOT BACK-PRESSURED
	LR	R9,R14			:NOW LOCATE CURRENT POSITION IN RING
	EXHR	R0,R0			:MAKE NEEDLE HEADER
:	OHI	R0,NEDMSG^8
	JAL	R4,PUTW			:PLACE NEEDLE-HEADER WORD INTO RING
	LHI	R5,$A -19
LEP59D	LB	R0,$A LO1+19,R5
	JAL	R4,PUTCH
	AIS	R5,1
	JLBS	LEP59D			:MOVE NEEDLE HEADER INTO RING
	LR	R6,R14			:GET CURRENT POSITION
	JAL	R4,PUTCH		:MAKE A SPACE
	LIS	R7,0			:SET UP CHARACTER COUNTER
	LHL	R1,PORT			:GET PORT #
	SLLS	R1,3			:MAKE PORT INTO BUFFER#
LEP59E	JAL	R5,GCI			:GET THE NEXT CHARACTER
	LHI	R5,07F
	NR	R5,R0			:SAVE A COPY...LOW 7 BITS
	JAL	R4,PUTCH
	AIS	R7,1			:COUNT IT
	SIS	R5,0D			:TEST FOR C/R
	JEFS	LEP59F
	SHI	R5,03B-0D		:OR SEMI-:
	JNBS	LEP59E
LEP59F	THI	R7,1			:CHECK FOR EVEN NO. OF CHARS
	JEFS	LEP59G			:YES
	JAL	R5,GCI			:NO...STRIP PADDING CHAR
LEP59G	STB	R7,ORING,R6,		:FILL IN THE USER NAME COUNT
	AHI	R7,$A 20		:MAKE UP SIZE FOR HEADER
	STB	R7,ORING+3,R9,		:AND PLUG IT IN
	JAL	R4,ELOR			:SEND IT ON
	LIS	R0,0
	STH	R0,LO0			:CLEAR INTERNAL CIRCUIT FLAG
	EI	(SAL)
	J	LEPSUM			:AND START OVER


:	RECEIVE GMT TIME FROM SUPERVISOR
LEP6	IF	1-SAL
	LIS	R0,8			:INFORM INTERFACES OF NEW TIME
	JAL	R4,ROOM
	LHI	R0,600			:SET SPECIAL TYPE 6
	JAL	R4,PUTW
	EXHR	R0,R7			:PACK TIME INTO WORD
	OR	R0,R8
	JAL	R4,PUTW
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
	EI	(1-SAL)
	J	LEPSUM			:AND START OVER

:	PUT INVOICE NUMBER INTO AAINV
:	EXPECTS # IN R7,R8
LEP7	LBR	R9,R7			:SAVE COPY OF SR2
	EXBR	R7,R7
	LBR	R7,R7			:EXTRACT PORT NUMBER
	IF	1-SAL;	CLHI	R7,NKU;	JL	LEP;	EI
	SLLS	R7,2			:4*PORT#
	L	R10,AAINV,R7,		:GET PREVIOUS ENTRY
	STH	R9,AAINV,R7,		:STORE NEW INVOICE #
	STH	R8,AAINV+2,R7,		:/

	IF	ACCT&SAL
	LR	R10,R10			:CHECK PREVIOUS ENTRY
	JGEFS	LEP7A			:NO INVOICE RECEIVED FROM OTHER NET
	ST	R10,AAPINV,,		:STORE PRIMARY INV #
	LR	R11,R7			:4*PORT# FOR AASWAP
	JAL	R10,AASWAP		:EXCHANGE INVOICE #'S BETWEEN NETS
	EI	(ACCT&SAL)

LEP7A	J	LEP			:AND PROCESS NEXT SUP MESSAGE


:	EXTRACT INVOICE NUMBER FROM AAINV, LEAVE IT IN LO1
:	LINK ON R6
:	EXPECTS R7 = PORT #
	IF	1-SAL
INVOICE	SLLS	R7,2			:4*PORT#
	L	R0,AAINV,R7,		:GET INVOICE #
	ST	R0,LO1
	SRLS	R7,2			:RESTORE PORT#
	JR	R6			:RETURN
	EI	(1-SAL)

:	RETURN  A REJECTED CMND. KEEP SR2, SET SR3 = OLD SR1.
LEPRET	LIS	R8,1
	AHM	R8,LEPREJ		:COUNT ANOTHER REJECT
	LR	R8,R6
	LHI	R6,02000		:MESSAGE TYPE 2
	JAL	R9,LEPSNU
	J	LEP

:	SEND A TYPE 3 REPORT TO SUP
:	R7, R8 INITIALIZED
REPORT	LHI	R6,03000		:SET MESSAGE TYPE 3 AND FALL THROUGH

:	SEND A MESSAGE UPSTREAM
LEPSNU	OH	R6,MACHNO		:FILL IN NODE NUMBER
	OHI	R6,08000		:SET UPSTREAM BIT

:	PASS LEP MESSAGE TO SUP
LEPPTS	LH	R1,USWICH		:WHERE IS THE SUP?
	IF	SUP
	JG	LEPSN			:NOT ON THIS NODE...SKIP TO SEND ON MESSAGE
	JER	R9			:NO SUP...JUST TOSS MESSAGE
	LA	R2,SUPBASE,,		:WE HAVE ACTIVE SUP...SET BASE ADDRESS
	LH	R1,NISI,R2		:CHECK OUT SUP
	SH	R1,NOSI,R2
	JEFS	LSNU2			:EMPTY...GO DO IT
	NHI	R1,2*NS-1		:CHECK FOR FULL
	JNFS	LSNU1			:NO OVERRUN
:	SUP INPUT BUFFER FULL
	JR	R9			:ABORT
LSNU1	SHI	R1,2*(NS-NM-1)		:EXTRA CHECK
	JNFS	LSNU3			:SKIP IF OK
	LHI	R1,0C0			:ELSE SET A FLAG
LSNU2	STB	R1,FULTIM
LSNU3	LH	R1,NISI,R2		:OK...GET POINTER
	LHI	R3,2,R1			:ADVANCE IT
	NHI	R1,NS*2-2		:FOLD IT, FORCE TO HALF-WORD BOUNDARY
	STH	R6,SIB1,R1,R2		:PLACE THE DATA
	STH	R7,SIB2,R1,R2
	STH	R8,SIB3,R1,R2
	STH	R3,NISI,R2		:AND PASS TO SUPERVISOR
	JR	R9			:THEN RETURN
	ELSE
	JLER	R9			:TOSS IF NOT REASONABLE UPSTREAM POINTER
	EI	(SUP)

:	SEND A RECORD SOMEWHERE. USE REGS 2, 3, 5-9.
:	EXPECTS R1 = BUFFER INDEX
:		R6 = SR1
:		R7 = SR2
:		R8 = SR3
:		R9 = RETURN ADDR
LEPSN	LIS	R2,6
	AHM	R2,LTHROT
	LHI	R2,-NPORT*8,R1
	NHI	R2,-80
	JEFS	.+6
	JAL	R10,CRASH		:OUT OF RANGE
	JAL	R5,WBI
	STH	R6,0,R3
	STH	R7,2,R3
	STH	R8,4,R3
	LPHIST
	JR	R9
	SUBTTL	P E R I O D I C   L O G I C

:	HALF-SECOND LOGIC
SECH	AHI	R1,RATE/2
	JAL	R5,TOPUT		:RUN AGAIN IN A HALF SECOND
	IF	1-SAL
:	MAINTAIN KERNEL OUTPUT BACKPRESSURE BIT VECTOR
Q	EQ	(NKU-1)/10*2
	LHI	R1,-1^(0F-((NKU-1)&0F))
	OH	R1,STOPO+Q		:FOR KERNEL PORTS:
	STH	R1,STOPO+Q		:OPEN OUTPUT IF KOUT IS WILLING
	IF	Q
	LHI	R2,Q-2
	LCS	R1,1
SECH1	STH	R1,STOPO,R2
	SIS	R2,2
	JGEBS	SECH1			:DO FOR ALL KERNEL PORTS
	EI	(Q)
	EI	(1-SAL)
	LHL	R1,MACHNO		:SET UP RESET STRING IN CASE NODE NUMBER CHANGED
	STH	R1,RESET2,,


:	NOW, FOR EACH SYNC LINE
	LIS	RL,NM-1
	LIS	R1,1
SECH2	LR	RL2,RL
	AR	RL2,RL2			:HALF-WORD INDEX FOR LINE

:	INCREMENT LINE OVERLOAD COUNTER FOR EACH LINE THAT DID NOT SERVICE
:	ALL OF ITS CHANNELS AT LEAST ONCE IN THE LAST HALF-SECOND.
	SBT	RL,LVF,,
	JEFS	SECH3
	AHM	R1,LOVRLD,RL2
SECH3	SIS	RL,1
	JGEBS	SECH2
	J	TORET

:	ONE SECOND TIMEOUT PROCESSING
SEC1	AHI	R1,RATE
	JAL	R5,TOPUT		:RUN AGAIN IN 1 SECOND

	IF	1-SAL
	IF	DISNOD
:	DISPLAY NODE # EVERY 4TH SECOND
	LIS	R2,3
	NH	R2,MSLOWC+2,,
	JNFS	SEC1A0			:NOT THIS TIME
	LHI	R2,MACHO		:NODE # (OCTAL)
	STH	R2,STATUS
	J	SEC1B0

Q	EQ	MACHNM
MACHO	EQ	(Q^3&7000)+(Q^2&700)+(Q^1&70)+(Q&7)	:OCTAL NODE # FOR DISPLAY

	EI	(DISNOD)
	EI	(1-SAL)


:	DISPLAY PP|AA:
:	PP	THE PASSTHRU COUNT (0-0FF)
:	AA	ACTIVE PORT COUNT (0-0FF)
SEC1A0	HS	0
	IF	PTHRU;	LIS	R3,0;	ELSE
	LHI	R2,(NPTHRU-1)*4
	LIS	R3,0			:COUNT PASSTHRUS
SEC1A	L	R6,PASSBUF,R2
	JEFS	.+4
	AIS	R3,1
	SIS	R2,4
	JGEBS	SEC1A
	EI	(PTHRU)
	STB	R3,STATUS		:OUTPUT ACTIVE PASSTHROUGH COUNT
	IF	PERMEA;	AM	R3,P.PTHR		:COUNT TOTAL PASSTHROUGHS;	EI

	LHI	R2,(NPORT/8)-4
	LIS	R3,0			:COMPUTE ACTIVE PORT COUNT
SEC1B	L	R6,ACP,R2
	JAL	R5,S1BC
	AR	R3,R9
	SIS	R2,4
	JGEBS	SEC1B
	STB	R3,STATUS+1		:OUTPUT ACTIVE PORT COUNT
	IF	PERMEA
	AM	R3,P.PORT		:COUNT TOTAL PORTS
	LIS	R3,1
	AM	R3,P.SECC		:COUNT TIMES THROUGH HERE
	EI	(PERMEA)

SEC1B0	HS	0

	IF	SAL
:	DISPLAY X|S|CC:
:	X	SLOT-HOST STATE
:		8	UP, ANSWERED
:		9	DOWN
:		0A	UP, SHUT
:		0B	GONE
	ELSE
:	DISPLAY C|S:
	EI	(SAL)
:	CC	CRASH COUNT
:	S	NODE-NETWORK STATUS NUMBER
:		1	NODE NOT IN NET
:		2	NODE IN NET
	IF	SUP
:		3	NODE IS A BASE RUNNING WITH A FROZEN SUPERVISOR
:		4	SLEEPING SUP
:		5	CONTROLLING SUP RUNNING

:	UPDATE SUP PARAMETER
	LH	R0,FULTIM
	AHM	R0,FULTIM		:CLOGGED SUP INPUT TIMEOUT...SEE LEP
	EI	(SUP)

:	SET CRSHCT DISPLAY VALUE TO MAX IF CRSHCT GREATER THAN MAX
	LH	R3,CRSHCT
	IF	SAL
	CLHI	R3,100
	ELSE
	CLHI	R3,10
	EI	(SAL)
	JLFS	SEC1C
	LCS	R3,1
SEC1C	SLHLS	R3,4			:CRSHCT IS LEFT DIGITS IN DISPLAY FIELD
	IF	SAL
	LIS	R4,3			:WE DO THIS LOGIC ONLY 1 SECOND IN 4
	NH	R4,MSLOWC+2,,
	JN	SEC1E			:JUST IGNOR THE REST OF THE TIME
	OH	R3,UPDOWN		:ELSE MERGE IN SLOT HOST STATUS
	SLHLS	R3,4			:AND REPACKAGE IT
	ELSE
	LIS	R4,0F
	NH	R4,RDISPL,,
	JN	SEC1D			:HAVE RIGHTMOST HEX DIGIT FLICKER TO 0 EVERY OTHER PASS
	EI	(SAL)
	AIS	R3,2			:SET STATUS TO 2
	LH	R4,USWICH
	IF	SUP
	JNFS	.+8
	SIS	R3,1
	J	SEC1D			:STAT=1, NOT IN NET
:	SUP NODES CAN SET STAT=3,4, OR 5
	AIS	R3,1			:SET STAT =3 (FROZEN SUP)
	TS	SUPSTAT,,		:GET SUPERVISOR STATE TO CONDITION CODE
	JLFS	SEC1D			:SUP HASN'T UPDATED SUPSTAT, MUST BE FROZEN
	JGFS	.+4			:STAT=4 FOR SLEEPING SUP
	AIS	R3,1			:SUPSTAT WAS 0, SUP IS ACTIVE, STAT=5
	AIS	R3,1
	ELSE
	JNFS	SEC1D
	SIS	R3,1			:STAT = 1, NOT IN NET
	EI	(SUP)

	IF	SAL
SEC1D	EXBR	R3,R3			:NOW MAKE FINAL DISPLAY FORM
	OHI	R3,8000			:AND SET HIGH BIT AS A FLAG
	STH	R3,STATUS
SEC1E	HS	0
	ELSE
SEC1D	STB	R3,RDISPL+1,,		:OUTPUT CRASH COUNT DIGIT AND STAT DIGIT
	EI	(SAL)


:	NOW, FOR EACH SYNC LINE
	LIS	RL,NM-1
	LIS	R1,1
SEC1F	LR	RL2,RL
	AR	RL2,RL2			:HALF-WORD INDEX FOR LINE

:	RECOMPUTE WORKING BORI IN CASE SUPERVISOR HAS DECIDED TO ZAP IT
	LH	R2,MACH,RL2
	SH	R2,MACHNO		:SET INPUT DIRECTION BIT IF NEIGHBOR HAS
	NHI	R2,4000			:LOWER NODE NUMBER THAN US
	OH	R2,SBORI,RL2		:GET BORI
	IF	NUMSAT
	CLHI	RL,NUMSAT
	JGEFS	.+6
	AH	R2,SBORI,RL2		:ADJUST FOR SATELITE
	EI
	STH	R2,BORI,RL2		:MAKE WORKING BORI, WITH BITS SET CORRECTLY
	SIS	RL,1
	JGE	SEC1F
	J	TORET

S1BC	LIS	R9,0			:SET R9= TOTAL NUMBER OF ONE BITS IN R6
S1BC1	LIS	R7,0F
	NR	R7,R6
	AR	R7,R7
	JEFS	S1BC2
	LI	R8,$40001011201121223	:BIT COUNTS MINUS 1 FOR HEX VALUES 0-0F
	RLL	R8,2,R7
	NHI	R8,3
	AIS	R8,1
	AR	R9,R8
S1BC2	SRLS	R6,4
	JN	S1BC1
	JR	R5
	IF	SAL
:	8 SECOND LOGIC
SEC8	AHI	R1,RATE*8
	JAL	R5,TOPUT		:RUN AGAIN IN ABOUT 8 SECONDS
	LIS	R5,2			:ASSUME "SHUT"
	LH	R2,USWICH
	JEFS	.+4
	LIS	R5,0			:WE HAVE AN UPSTREAM, SO ASSUME "ANSWERED"
	CLH	R5,UPDOWN		:HAVE WE REPORTED THIS STATE ALREADY?
	JE	S8A			:YES...JUST IGNOR FOR NOW
	LIS	R0,$A 11		:ELSE REPORT NEW HOST STATE TO DISPATCHER
	LIS	R1,0
	LIS	R2,4
	JAL	R4,SLOR			:START-LOGICAL-OUTPUT-RECORD
	LIS	R0,0
	JAL	R4,PUTCH		:GARBAGE PADDING FOR "KEY"
	JAL	R4,PUTW			:GARBAGE PADDING FOR HOST #, # PORTS
	JAL	R4,PUTH			:SET REL. HOST 0
	LR	R0,R5			:SET HOST STATE
	STH	R0,UPDOWN		:AND REMEMBER IT
	JAL	R4,PUTCH
	JAL	R4,ELOR			:END-LOGICAL-OUTPUT-RECORD
S8A	LHI	R10,(NPORT/8)-2		:FOR ALL PORTS
S8B	LIS	R0,0			:SET VALUE
	LH	R1,YBT1,R10		:CHECK YELLOW BALL TIMEOUTS
	JNFS	S8C			:SKIP IF SOMETHING TO PROCESS
	LH	R1,YBT2,R10		:NONE...RESET TIMEOUTS
	STH	R0,YBT2,R10
	STH	R1,YBT1,R10
	SIS	R10,2
	JGEBS	S8B			:DO FOR ALL
	J	TORET			:RETURN
:	GOT ONE
S8C	JAL	R3,BIDH
	LR	R1,R10			:COMPUTE PORT #
	SLHLS	R1,3			:ALLOW FOR COUNT BY 2'S
	AR	R1,R2
	STH	R1,PORT			:SAVE PORT NUMBER
	LB	R0,TXITBL,R1		:GET ISIS PORT #
	STH	R0,IPORT
	RBT	R1,LOGON		:RESET LOGON STATE
	RBT	R1,LOGGING
	RBT	R1,YBT1			:TURN OFF BITS
	RBT	R1,YBT2
	SBT	R1,ACKWAIT		:WE'RE GOING TO WAIT FOR ACK
	SLHLS	R1,3			:MAKE BUFFER INDEX
	AIS	R1,4
	JAL	R4,SPEED		:AND ZAP THIS CIRCUIT
	LIS	R0,3
	JAL	R5,WCI
	JAL	R9,IZAPP		:AND NOTIFY ISIS THAT PORT IS FREED
	J	S8B			:NOW PICK UP WHERE WE LEFT OFF
	EI	(SAL)

:	16 SECOND LOGIC
SEC16	AHI	R1,$A RATE*16
	JAL	R5,TOPUT		:RUN AGAIN IN ABOUT 16 SECONDS
	IF	PERMEA

:	UPDATE AND REFRESH ACTIVE REAL-TIME COUNTERS FOR PERFORMANCE MEASUREMENT
	LA	R1,F.16SR		:POINT TO MAPPING TABLE
	LIS	R5,0			:R5 REFRESHES REAL-TIME COUNTER
PERI10	LHI	R3,(NM-1)*4		:FULLWORD LINE INDEX
	LHI	R6,(NM-1)*2		:HALFWORD INDEX
	LM	R14,0,R1		:GET NEXT TABLE ENTRY
	LR	R14,R14			:END OF TABLE?
	JL	PERI30			:YES
PERI20	LHL	R4,0,R14,R6		:GET HALFWORD REAL-TIME COUNTER
	STH	R5,0,R14,R6		:REFRESH IT AND
	AM	R4,0,R15,R3		: INCREMENT TEMPORARY FULLWORD CELL
	SIS	R3,4
	SIS	R6,2
	JGEBS	PERI20			:DO FOR ALL LINES
	AHI	R1,8			:ADVANCE TO NEXT TABLE ENTRY
	J	PERI10

:	F.16SR MAPS REAL-TIME PERFORMANCE DATA INTO TEMPORARY CELLS TO
:	PREVENT HALFWORD OVERFLOW ON THE CHARACTER COUNT FIELDS. EACH
:	ELEMENT IN F.16SR CONTAINS 2 FULLWORD ENTRIES:
:	1. P.TABL (SOURCE) FIELD POINTER
:	2. T.XXXX DESTINATION FIELD ADDRESS

:	THE P.TABL ENTRIES CHOSEN ARE THOSE WHICH ARE LIKELY TO OVERFLOW
:	WITHIN THE P.TIMS TIME INTERVAL SELECTED.
F.16SR	WS	0
	WC	P.CHNI,T.CHNI
	WC	P.CHSI,T.CHSI
	WC	P.CHNO,T.CHNO
	WC	P.CHSO,T.CHSO
	WC	P.PKSM,T.PKSM
	WC	P.PKSR,T.PKSR
	WC	-1			:END OF TABLE

PERI30	EI	(PERMEA)

	LHI	RL2,(NM-1)*2		:16 SECOND LINE OUT SCAN
	LIS	RL,NM-1
S16A	LH	R1,LRESET,RL2
	JEFS	S16B
	LHI	R7,8004			:SR2 OF LINE RESET DIAGNOSTIC
	SBT	RL,LINOUT,,		:ELSE FLAG LINE NOT OUT
	J	S16E			:AND SKIP TO GENERATE REPORT

:	HAS RTD HAD ANY GOOD RECORDS LATELY FOR THIS LINE
S16B	LH	R1,INDATA,RL2
	JN	S16I
	STH	R1,LOVRLD,RL2		:NO DATA COMING ON THIS LINE, CANCEL LOVRLD INFO
	IF	NLINES
	RBT	RL,LINOUT,,		:FLAG THIS LINE OUT
	IF	DOWLOA
	CLH	RL,DOWLIN		:IS THIS LINE ENGAGED IN DOWN-STREAM LOAD?
	JEFS	S16B2			:SKIP IF SO
	EI	(DOWLOA)
	LA	R2,YLRES
	ST	R2,YSUB,RL2,RL2		:DEMOTE LINE TO LOOKING FOR RESETS
	LA	R2,ZRESET		:PUT OUTPUT IN RESET STATE
	ST	R2,ZSUB,RL2,RL2		:SEND RESETS,ONES GAPS WHEN CURRENT BLOCK DONE
S16B2	L	R2,MFASTC,,		:SET TIME SINCE LAST RESET,
	SHI	R2,RATE			:TO 1 SECOND AGO, TO INSURE WE SEND SOME RESETS
	ST	R2,TSLR,RL2,RL2		:INSURE SOME RESET GET SENT
	LIS	R5,1
	LH	R1,YALIVE,RL2
	JE	S16D			:NO INPUT INTS
	LIS	R5,6
	LH	R1,ZALIVE,RL2,,
	JE	S16D			:NO OUTPUT INTS
	LIS	R5,4
	LH	R1,SBORI,RL2		:CHECK BORI
	JE	S16D			:SEEMS LIKE NO DATA RECEIVED BECAUSE BORI IS ZAPPED
:	MAYBE LINE IS INPUTTING CONSTANT SPACES OR MARKS
	LHL	R1,YRGPNT,RL2		:R1=BASE OF YRG BLOCK FOR THIS LINE
	LHI	R2,YN			:CHECK RECENT INPUT HISTORY, ONE RINGFULL
	LIS	R3,0
	LCS	R4,1			:R3 TO CHECK FOR SPACES, R4 FOR MARKS
S16C	LH	R5,0,R1,R2		:PICKUP A RING HALFWORD
	OR	R3,R5
	NR	R4,R5
	SIS	R2,2
	JGBS	S16C
	LIS	R5,2
	LR	R3,R3
	JEFS	S16D			:SPACEING (ZEROS)
	LIS	R5,3
	AIS	R4,1
	JEFS	S16D			:MARKING (ONES)
	LIS	R5,5			:DON'T KNOW WHY INDATA=0. JUST SAY BAD DATA RECEIVED.
S16D	SLHLS	R5,6
	LHI	R7,8005,R5		:LINE OUT MSG WITH DETAILS
	EI	(NLINES)

:	R7=DIAGNOSTIC DETAILS. TELL SUP OF CONDITION, CLEANUP CIRCUIT.
S16E	LR	R8,RL			:SR3 IS LINE NUMBER
	JAL	R9,REPORT		:SEND TYPE 3 MESSAGE UP TO SUP

	LA	R1,NPORT*4,RL2,RL2
	AR	R1,R1			:4*BUFF#
	JAL	R5,CLEAR		:REGAIN BUFFER SPACE OF SUP OUTPUT BUFFER
	SH	R1,USWICH
	JNFS	S16F
	STH	R1,USWICH		:SEE SEC1 REFERENCE TO USWICH

:	ZAP ALL CIRCUITS ON THIS LINK. KEEP CHANNELS 0 AND 1.
S16F	LH	R10,CHANI+2,RL2
	LH	R11,CHANI,RL2
	SR	R11,R10			:IOT INDICES
	LIS	R8,0
	AIS	R11,4			:SKIP CHANNEL 0,1
S16G	LH	R1,IOT,R10,R11
	CLHI	R1,-1
	JE	S16H
	NHI	R1,3FFF
	SLLS	R1,2			:4*BUFF#
	JAL	R4,SPEED
	LIS	R0,3
	JAL	R5,WCI			:ZAP WHEREVER THIS CIRCUIT WENT
	XHI	R1,4
	JAL	R5,CLEAR
	STH	R8,BF,R1		:DEASSIGN BUFFER TO DEFUNCT LINE
	LCS	R1,1
	STH	R1,IOT,R10,R11
S16H	AIS	R11,2
	JL	S16G

S16I	LHL	R7,INERR,RL2		:CHECK IF LINE SNIPPED
	JEFS	S16J			:SKIP IF NOT
	LIS	R0,0
	STH	R0,INERR,RL2		:CLEAR FLAG
	LR	R8,RL			:COPY LINE NUMBER
	JAL	R9,REPORT		:REPORT IT

S16J	LIS	R1,0
	STH	R1,LRESET,RL2		:RESET 16 SECOND STATISTICS AND FLAGS
	STH	R1,INDATA,RL2
	IF	NLINES
	STH	R1,ZALIVE,RL2,,
	STH	R1,YALIVE,RL2
	EI	(NLINES)
S16K	SIS	RL2,2
	SIS	RL,1
	JGE	S16A
	LIS	RL,NLINES-1
S16L	LH	R8,LCROSS,RL,RL		:CHECK CROSSTALK
	JEFS	S16M			:SKIP IF NO OCCURANCE
	LIS	R7,0
	STH	R7,LCROSS,RL,RL
	SLHLS	R8,6			:MAKE MESSAGE FORMAT
	OR	R8,RL
	LHI	R7,$8 100021
	JAL	R9,REPORT		:REPORT CONDITION
S16M	SIS	RL,1
	JGEBS	S16L			:DO FOR ALL LINES

:	SEND IN LINE-SPEED REPORTS TO SUPERVISOR
S16P	LH	R1,LSF,,			:SEE IF ANY REPORTS SHOULD GO
	JE	TORET			:ALL PENDING REPORTS SUBMITTED
	JAL	R3,BIDH			:GET LINE NUMBER
	RBT	R2,LSF,,			:MARK REPORT AS SENT
	LIS	R7,0			:SR2 WILL BE FILLED IN LATER
	LR	R8,R2			:SR3 IS 0 (ERR COUNT) LEFT 10 BITS,
					:...LINE NUMBER RIGHT 6 BITS
	IF	NLINES
	LHI	R9,NLS			:SET UP FOR SEARCH
	IF	NUMSAT
	CLHI	R8,NUMSAT
	JGEFS	S16Q			:SKIP IF NOT SATELITE
	LHI	R7,4000			:ELSE SET SATELITE BIT
S16Q	EI	(NUMSAT)
	AR	R2,R2			:HALF-WORD INDEX
	LHL	R3,LSS,R2,		:R3 = NUMBER OF BYTES INPUT
	SLLS	R3,3			:R3 = NUMBER OF BITS INPUT
	L	R4,LST,R2,R2		:R4 IS NUMBER OF CLOCK TICKS FOR THAT NUMBER
	JEFS	S16S			:DON'T DIVIDE BY ZERO
	DHR	R3,R4			:COMPUTE NUMBER OF BITS/CLOCK TICK
	LR	R4,R4			:TEST QUOTIENT
	JLEFS	S16S			:TREAT 0 AS UNKNOWN
S16R	SIS	R9,2
	CLH	R4,LSSTAB,R9
	JGBS	S16R			:SCAN
	EI	(NLINES)
S16S	OH	R7,LSMSG,R9		:SUBTYPE 6 MESSAGE,
	JAL	R9,REPORT		:UPSTREAM TYPE 3 MESSAGE
	J	S16P			:TELL SUP, CHECK OTHER LINES

:	LS TIME IS CLOCK TICKS AND BYTES INPUT
:	TIME PER BYTE = 1/(BPS/8).
:	FASTC CHANGE = (TIME PER BYTE TIMES RATE TIMES NUMBER OF BYTES)
:	LINE COST TABLE CORRESPONDING TO LSSTAB
Q	EQ	8006			:MESSAGE SUB-TYPE 6
QQ	EQ	$A RATE/100		:6(00)TICKS/SECOND

:		 SHUFFLER  19.2KB   9.6KB  7.2KB  4.8KB  2.4KB UNKNOWN
LSMSG	HC	   5^6+Q,  4^6+Q,  4^6+Q, 3^6+Q, 2^6+Q, 1^6+Q, Q
LSSTAB	HC	$A 10000, 375/QQ, 144/QQ, 84/QQ, 60/QQ, 36/QQ
NLS	EQ	.-LSSTAB		:INDEX FOR LAST ENTRY

:	4 MINUTE LOGIC
MIN4	AI	R1,$A4*60*RATE
	JAL	R5,TOPUT		:RUN AGAIN AFTER 4 MINUTES
	IF	1-SAL
:	SOLICIT NETWORK CLOCK IF IT HAS NOT BEEN SENT.
	LH	R0,RGMT,,		:GET GMT TIME
	JGEFS	MIN40			:SKIP IF SET
	LHI	R6,6000			:SR1=TYPE 6
	LHI	R7,8004			:SR2...SUBTYPE 4
	LIS	R8,0			:SR3
	JAL	R9,LEPSNU		:REQUEST TIME
MIN40	EI	(1-SAL)


	LB	R8,RTEMP,,		:GET TEMPERATURE
	CLHI	R8,60			:RANGE CHECK...DON'T REPORT IF T < 98.6f
	JLFS	TEMP9
	LHI	R7,$8 100012
::::	JAL	R9,REPORT		:REPORT BAD READING

TEMP9	LHI	RL2,NLINES*2		:CHECK SYNC LINES FOR A VARIETY OF DIAGNOSTIC CONDITIONS
	LHI	RL,NLINES
MIN4X	SIS	RL2,2
	SIS	RL,1
	JL	TORET			:ALL DIAGNOSTICS REPORTED
	LHI	R10,N4T-2		:SCAN LINE ERROR COUNTERS FOR A LINE
MIN41	LHL	R1,M4T1,R10
	AR	R1,RL2			:ADDRESS OF AN ERROR STATISTIC FOR THIS LINE
	LIS	R2,0
	LHL	R8,0,R1
	STH	R2,0,R1			:FETCH AND RESET COUNTER
	LHL	R4,M4T2,R10
	LHL	R4,0,R4			:CHECK LIMIT VALUE
	SR	R4,R8
	JGEFS	MIN42			:ERROR CONDITION NOT SEVERE ENOUGH TO REPORT
	LHL	R7,M4T3,R10
	SLHLS	R8,6
	OR	R8,RL
	JAL	R9,REPORT		:SEND TYPE 3 UPSTREAM WITH ERROR SUBTYPE IN R7,R8=COUNT
MIN42	SIS	R10,2
	JGE	MIN41			:SEE IF OTHER REPORTS FOR THIS LINE
	LH	R7,LINER,RL2		:NEW LINE-ERROR REPORT
	LR	R8,R7
	AH	R7,ANYDATA,RL2		:IF (LINER+ANYDATA)/64.LE.LINER, REPORT
	LIS	R6,0
	STH	R6,LINER,RL2		:CLEAR COUNTERS
	STH	R6,OVLD,RL2		:(INCLUDING NEW OVERLOAD CHECKER)
	STH	R6,ANYDATA,RL2
	SRLS	R7,6			: /64
	CR	R7,R8
	JG	MIN4X			:IF >, THEN IGNOR
	SLHLS	R7,6			:ELSE FORMAT ERROR
	SLHLS	R8,6
	OR	R8,RL			:SR3=ERROR COUNT|LINE #
	OHI	R7,$8 100006		:R7 = TOTAL COUNT|ERROR NUMBER
	JAL	R9,REPORT		:REPORT THIS TO SUPERVISOR
	J	MIN4X			:NEXT LINE

M4T1	HC	LOVRLD,LINRTS,LINRTR,BADACK
N4T	EQ	.-M4T1
M4T2	HC	LOVLIM,LRTLIM,LRTLIM,ZERO
M4T3	HC	$8 100007,100032,100031,100011
	SUBTTL	TYMNET-I TO ISIS-II DISPATCHER INTERFACE

:	DEFINE RING PARAMETERS
NFMI	EQ	0
CEI	EQ	2
RING	EQ	4

:	ASSEMBLY PARAMETERS
TNPG	EQ	(NPORT+0F)/10		:NUMBER OF PORT GROUPS

:	BIT ARRAY TO IDENTIFY DATA MESSAGES
BDATA	WC	07FFFFFFF,-1,-1,-1,-4,0,0,0


:		**INTERFACE DATA TYPES**


NEDMSG	EQ	0			:NEEDLE
FIRST	EQ	9E			:FIRST MESSAGE IN LIST
DETMSG	EQ	9E			:DETACH MESSAGE
ZAPMSG	EQ	9F			:DISCONNECT MESSAGE
NOSMSG	EQ	0A0			:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1			:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2			:FLUSH OUTPUT
BLKMSG	EQ	0A4			:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5			:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6			:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7			:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8			:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9			:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA			:GREEN BALL
RBMSG	EQ	0AB			:RED BALL
YBMSG	EQ	0AC			:YELLOW BALL
OBMSG	EQ	0AD			:ORANGE BALL
BKBMSG	EQ	0AE			:BREAK BEGIN
HNGMSG	EQ	0AF			:HANG UP
QTPMSG	EQ	0B0			:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1			:SET TERMINAL PARAMETER
PNMSG	EQ	0B2			:PSEUDO NEEDLE
NLOGCH	EQ	0B3			:NORMAL LOGON CHAR
NLOGST	EQ	0B4			:NORMAL LOGON STATUS
LGFAIL	EQ	0B5			:LOGON FAILURE
LOGOK	EQ	0B6			:SUCCESSFUL LOGON
ACTMSG	EQ	0B7			:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8			:SUPER-HANG UP
BKEMSG	EQ	0BA			:BREAK END
EAODM	EQ	0BC			:ENTER 'ALTERNATE OUTPUT DEVICE MODE'
LAODM	EQ	0BD			:LEAVE 'ALTERNATE OUTPUT DEVICE MODE'

MAXTYP	EQ	0BD			:MAXIMUM TYPE DEFINED

MAXCHR	EQ	21			:MAXIMUM NUMBER OF DATA CHARACTERS/LOGICAL RECORD


:		BACKPRESSURE PARAMETERS

MNBSIZ	EQ	020
MXBSIZ	EQ	0100			:MAX SIZE FOR BUFFER BEFORE WE APPLY BACK-PRESSURE


:	THE MAIN LOOP
TISIS	ST	R0,TIRET4		:SAVE RETURN

:	* * * P O R T   O U T P U T   P R O C E S S I N G * * *
:              * * * F R O M  I S I S * * *

OUTLOP	JAL	R4,LOOK			:ANYTHING THERE?
	J	OEXIT			:RING EMPTY
	LR	R10,R1			:SAVE PORT #
	JE	OUTL1			:SKIP IF CONTROL MESSAGE
	CLHI	R10,NPORT		:IS PORT NUMBER VALID?
	JGE	OUTINV			:BAD PORT NUMBER...CRASH HIM
	IF	1-SAL
	CLHI	R10,PPH			:DON'T EXPECT HOST 0 PORTS IN USE
	JL	OUTINV			:BAD PORT NUMBER...CRASH HIM
	EI	(1-SAL)
	CLHI	R2,MAXTYP		:CHECK MESSAGE TYPE
	JG	OUTINV			:CRASH HIM IF OUT OF RANGE
	LR	R11,R2			:SAVE IT
	IF	SAL
	JE	NEEDLE			:SKIP IF WE HAVE A NEEDLE FROM OTHER GUY
	EI	(SAL)
	JAL	R12,PROCO		:GO PROCESS THE MESSAGE
ORET	JAL	R4,ELIR			:TERMINATE THE MESSAGE
	J	OUTLOP			:CONTINUE

OUTL1	CLHI	R2,10			:CONTROL MESSAGE
	JGE	OUTINV			:OUT OF RANGE...CRASH HIM
	SLHLS	R2,2			:MAKE A WORD INDEX
	J	OUTCTB,R2		:GO TO FAN-OUT TABLE
	IF	SAL

OUTCTB	J	OUTC0			:0...RESTART REQUEST
	J	OUTC1			:1...RESTART RESPONSE
	J	OUTC2			:2...OTHER NODE RETAKEN
	J	OUTINV			:3...CRASH HIM
	J	OUTINV			:4...CRASH HIM
	J	OUTINV			:5...CRASH HIM
	J	OUTC6			:6...GMT TIME
	J	OUTINV			:7...CRASH HIM
	J	OUTINV			:8...CRASH HIM
	J	OUTC9			:9...UNABLE TO PROVIDE PSEUDO-NEEDLE
	J	OUTINV			:A...CRASH HIM
	J	OUTINV			:B...CRASH HIM
	J	OUTINV			:C...CRASH HIM
	J	OUTINV			:D...CRASH HIM
	J	OUTINV			:E...CRASH HIM
	J	OUTINV			:F...CRASH HIM

:	RESTART REQUEST
OUTC0	LIS	R15,0			:CANCEL INPUT
	ST	R15,AIRING,,
	LI	R14,40000
	LHI	R15,0100		:RESPONSE
	STM	R14,AORING,,
	J	OEXIT			:AND QUIT

:	RESTART RESPONSE
OUTC1	JAL	R4,ELIR			:JUST IGNOR
	J	OUTLOP

:	NODE RETAKEN ON OTHER SIDE
OUTC2	JAL	R4,ELIR			:JUST IGNOR
	J	OUTLOP

:	GMT TIME
OUTC6	LIS	R0,6			:FLUSH IT
	JAL	R4,FLUSH
	J	OUTLOP

:	UNABLE TO PROVIDE PSEUDO-NEEDLE
OUTC9	JAL	R4,GETH			:TOSS MESSAGE TYPE
	JAL	R4,GETH			:GET KEY
	LR	R1,R0			:SAVE COPY
	LR	R9,R0			:ANOTHER COPY FOR EDETM ROUTINE
	JAL	R4,GETCH		:GET ERR #
	JAL	R4,ELIR			:TERMINATE INPUT RECORD
	SLHLS	R1,3			:COMPUTE PORT INDEX
	AIS	R1,4
	CLHI	R0,9			:CHECK ERR #
	JLEFS	OUTC9A			:OK
	LIS	R0,0A			:OUT OF RANGE - USE MSG 0A
OUTC9A	LR	R4,R0
	SLLS	R4,2			:4*ERR#
	L	R7,LOFAIL,R4		:GET ADDR OF MSG
	JAL	R8,MSG		:	:OUTPUT ERROR MSG
	LA	R7,NONET		:SEND MESSAGE BACK
	JAL	R8,MSG
	JAL	R8,EDETM		:FOLLOW WITH YELLOW BALL (ENTER DETACH MODE)

	IF	ACCT
:	TERMINATE ACCOUNTING
	SRLS	R1,3			:COMPUTE 4*PORT#
	SLLS	R1,2			:/
	LR	R11,R1			:MAKE COPY
	JAL	R9,AAMIR		:SEND ACCT INVOICE RECORD
	LB	R8,LOFAIL,R4		:GET ACCT TERMINATION CODE
	OI	R8,0E0000000		:MSG #
	JAL	R9,AASAR		:SEND ACCT TERMINATION RECORD
	LIS	R9,0
	ST	R9,AAINV,R11,		:CLEAR INVOICE #
	EI	(ACCT)

	J	OUTLOP			:AND QUIT FOR NOW


:	RECEIVED A NEEDLE
NEEDLE	JAL	R4,GETH			:JUST TOSS IT
	JAL	R4,GETW			:INVOICE NUMBER
	IF	ACCT
	ST	R0,AAPINV,,		:SAVE INVOICE #
	EI	(ACCT)
	JAL	R4,GETW			:DEST HOST, ORIG NODE
	JAL	R4,GETW			:ORIG HOST, ORIG PORT
	JAL	R4,GETW			:XXX
	JAL	R4,GETW			:DIALECT, TID, SIZE
	LR	R8,R0			:COPY TID

	IF	1-PSGLAS
	LBR	R0,R0			:EXTRACT SIZE OF NAME
	JAL	R4,FLUSH		:DISCARD IT
	EI	(1-PSGLAS)

	LHL	R0,USWICH		:DO WE HAVE A SUP?
	JEFS	NEED2			:KILL CIRCUIT IF NOT
	LHI	R11,(NPORT/8)-4		:SEARCH FOR AVAILABLE PORT
NEED1	L	R1,HPFLAG,R11
	O	R1,ACP,R11
	XHI	R1,-1			:.NOT.(HOST PORT .OR. ACTIVE PORT)
NEED1A	JN	NEED3			:SKIP IF WE FOUND ONE
	SIS	R11,4			:ELSE KEEP SEARCHING
	JGEBS	NEED1
NEED2	HS	0

	IF	PSGLAS
	LBR	R0,R8			:EXTRACT SIZE OF NAME
	JAL	R4,FLUSH		:DISCARD IT
	EI	(PSGLAS)

	LR	R2,R10			:PORT #
	LA	R3,NONET		:MESSAGE
	JAL	R5,OCS			:OUTPUT CANNED STRING
	LR	R2,R10			:PORT #
	LA	R3,TACCT		:ACCOUNTING MESSAGE
	JAL	R5,OCM			:OUTPUT CANNED MESSAGE TO TERMINATE ACCOUNTING
	LIS	R0,3			:3-BYTE MESSAGE
	LR	R1,R10			:PORT NUMBER
	LHI	R2,DETMSG		:DETACH CIRCUIT
	JAL	R4,SLOR
	JAL	R4,ELOR
	J	OUTLOP			:AND CONTINUE
NEED3	JAL	R3,BID			:WE FOUND A PORT...WHICH ONE?
	LR	R9,R11			:SAVE COPY OF R11
	SLLS	R9,3			:CALC PORT#
	AR	R9,R2			:/
	SLLS	R9,3			:8*PORT# = 4*BUFF#
	LHL	R0,BF,R9		:MAKE SURE PORT IS REALLY NOT ACTIVE
	JEFS	NEED30			:OK IF BF=0
:	PORT STILL ACTIVE (RMAKE HASN'T PROCESSED ZAPPER YET)
	SLL	R1,1,R2			:RESET BIT FOR THIS PORT
	SRL	R1,1,R2			:/
	J	NEED1A			:CONTINUE SEARCH FOR AVAILABLE PORT

NEED30	SRLS	R9,3			:RESTORE PORT#
	LR	R11,R9			:...AND R11
	STB	R11,IXTTBL,R10		:SET UP PORT MAP MATRICIES
	STB	R10,TXITBL,R11

	IF	ACCT
:	SAVE PRIMARY NET INVOICE # TO EXCHANGE AFTER RECEIVING SECONDARY
	SLLS	R11,2			:4*PORT#
	L	R0,AAPINV,,		:GET INVOICE #
	OI	R0,80000000		:SET MSB TO INDICATE PRIMARY INV #
	ST	R0,AAINV,R11,		:STORE IN ARRAY
	SRLS	R11,2			:RESTORE PORT #
	EI	(ACCT)

	LHI	R0,MAXCHR		:SET UP INITIAL TRANSMIT LIMIT
	STB	R0,XLIMIT,R10
	SBT	R11,ACP			:SET PORT ACTIVE
	SBT	R11,LOGON		:AND IN LOGON MODE
	SBT	R11,LOGGING
	RBT	R11,AUX			:NOT AN AUX CIRCUIT
	RBT	R11,HAFDUX		:NOT HALF-DUPLEX
	SBT	R11,ASCII		:NOT A 2741 TID
	SBT	R11,ECHOMSK		:PERMIT ECHO FOR THIS TERMINAL TYPE

	IF	PSGLAS
	RBT	R11,LOGECHO		:TURN ECHO OFF
	ELSE	(1-PSGLAS)
	SBT	R11,LOGECHO		:INSURE THAT WE START IN ECHO MODE
	EI	(1-PSGLAS)

	SBT	R11,STOPIN		:INSURE INPUT IS NOT BACK-PRESSURED
	LA	R9,RLOG*8,R11		:COMPUTE BUFFER FLAG TO USE
	EXBR	R10,R8			:SAVE TID
	LBR	R10,R10
	LR	R1,R11			:COMPUTE BUFFER INDEX
	SLHLS	R1,3
	JAL	R5,CLEAR		:EMPTY INPUT BUFFER
	STH	R9,BF,R1		:AND SET NEW BF

	IF	PSGLAS
	LBR	R6,R8			:GET SIZE OF USERNAME
	JAL	R4,GETCH		:GET 1ST CHAR OF USERNAME
	SIS	R6,1			:COUNT IT
	CLHI	R0,0BF			:IS IT "?"? (TRANSPARENT GW USER)
	JEFS	NEED3B			:YES, DISCARD FOR NOW
	CLHI	R0,0A1			:IS IT "!"?
	JEFS	NEED3B			:IF SO, DISCARD
NEED3A	JAL	R5,WCI			:PUT IT IN BUFFER
NEED3B	JAL	R4,GETCH		:GET NEXT USERNAME CHAR
	SIS	R6,1			:COUNT IT
	JGBS	NEED3A			:DO IT FOR ALL CHARS
	JAL	R4,ELIR			:FINISH THE INPUT RECORD
	NHI	R0,7F			:MASK TO 7 BITS
	CLHI	R0,0D			:TEST FOR CR
	JEFS	NEED3C			:YES, SEND CR TOO
	LIS 	R0,4			:PUT 04 IN BUFF TO INDICATE SEMI-: AFTER USERNAME
NEED3C	JAL	R5,WCI
	RBT	R11,SEMICO		:INIT SEMI-: FLAG FOR LOGIN ROUTINE
	EI	(PSGLAS)

	AIS	R1,4			:COMPUTE OTHER BUFFER OF PAIR
	LA	R9,RTOP*8,R11		:COMPUTE BUFFER FLAG FOR TOPORT ARRAY
	JAL	R5,CLEAR		:AND CLEAR IT
	STH	R9,BF,R1		:RESTORE BF CLEARED BY POZAP1

	IF	1-PSGLAS
	LA	R7,NETOK;	JAL	R8,MSG			:RETURN BANNER TO USER
	ROUTE(PRIME,SECOND)
	LA	R7,CRLF;	JAL	R8,MSG			:C/R, L/F
	LA	R7,LSMS1;	JAL	R8,MSG			:"PLEASE LOG IN"
	EI	(1-PSGLAS)

	LHI	R6,1000			:NOW, SEND DIRECTLY TO SUP:
	LR	R7,R11			:BUFFER #
	AR	R7,R7
	LIS	R8,3			:START WITH A ZAPPER, TO CLEAN THINGS OUT
	JAL	R9,LEPSNU
	STB	R10,TIDTBL,R11		:SAVE TERMINAL TYPE
	LHI	R8,1F
	NR	R8,R10
	SIS	R8,9
	JNFS	.+6
	RBT	R11,ASCII		:2741 TERMINAL TYPE
	LHI	R8,@20			:CANCEL H-DUX
	NR	R8,R10
	XR	R10,R8			:REMEMBER IF H-DUX
	THI	R8,1F			:TEST FOR AUX TID
	JNFS	NEED4
	SBT	R11,AUX
	AIS	R8,0E			:CONVERT AUX CIRCUITS TO PSEUDO-AUX TID
	RBT	R11,ECHOMSK		:SUPPRESS ECHO ON AUX
NEED4	JAL	R9,LEPSNU		:SEND TID
	LR	R10,R10			:WAS IT H-DUX?
	JE	OUTLOP			:SKIP IF NOT
	SBT	R11,HAFDUX
	RBT	R11,ECHOMSK		:SUPPRESS ECHO
	LHI	R8,88
	JAL	R9,LEPSNU		:SEND CONT-H TO SUP
	J	OUTLOP

:	PLACE MESSAGE STRING INTO BUFFER
:	LINK ON R8
:	R7 = POINTER TO STRING
:	R1 = BUFFER INDEX
MSG	LB	R6,0,R7			:GET COUNT

	IF	ACCT
:	COUNT OUTPUT CHARS FOR ACCOUNTING
	LR	R3,R1
	SRLS	R3,3			:CALC PORT #
	TBT	R3,HPFLAG		:HOST PORT?
	JEFS	MSG1			:NO, DON'T COUNT 
	SLLS	R3,2			:4*PORT#
	AM	R6,AAOC,R3,		:COUNT THE CHARS
	EI	(ACCT)

MSG1	SIS	R6,1
	JLR	R8			:EXIT WHEN DONE
	AIS	R7,1			:ELSE POINT AT NEXT BYTE
	LB	R0,0,R7			:AND GET IT
	JAL	R5,WCI			:PLACE INTO BUFFER
	JBS	MSG1			:AND THEN REPEAT

NONET	SC	'"8D"8Aunable to complete inter-link...try again in a few minutes'
NETOK	SC	'"8D"8Ainter-link established'
NETGONE	SC	'"8D"8Ainter-link cleared'
TACCT	XC	06B700E0000008		:TERMINATE ACCOUNTING, OUT OF CHANNELS

:	PSEUDO-NEEDLE REJECT ERROR MSG'S + CORRESPONDING ACCOUNTING TERMINATION CODES
LOFAIL	WC	0E000000+LOF0		:ACCT TERM CODE + ADDR OF MSG
	WC	0E000000+LOF1
	WC	0B000000+LOF2
	WC	0E000000+LOF3
	WC	04000000+LOF4
	WC	0E000000+LOF5
	WC	0E000000+LOF6
	WC	0A000000+LOF7
	WC	07000000+LOF8
	WC	0E000000+LOF9
	WC	0E000000+LOFA

LOF0	SC	'"8D"8AISIS unable to complete request'
LOF1	SC	'"8D"8Aformat error'
LOF2	SC	'"8D"8Abad user name'
LOF3	SC	'"8D"8Abad mud'
LOF4	SC	'"8D"8Asystem unavailable'
LOF5	SC	'"8D"8Adialout failure'
LOF6	SC	'"8D"8Atimeout'
LOF7	SC	'"8D"8Aaccess not permitted'
LOF8	SC	'"8D"8Aout of origination ports'
LOF9	SC	'"8D"8Asup reject...try later'
LOFA	SC	'"8D"8Aunable to complete request'

	ELSE	(1-SAL)

OUTCTB	J	OUTC0			:0...RESTART REQUEST
	J	OUTC1			:1...RESTART RESPONSE
	J	OUTINV			:2...CRASH HIM
	J	OUTC3			:3...REPORT TO SUP LOG
	J	OUTC4			:4...REPORT HOST STATUS
	J	OUTC5			:5...REPORT ACCOUNTING
	J	OUTINV			:6...CRASH HIM
	J	OUTC7			:7...NORMAL CIRCUIT REQUEST
	J	OUTC8			:8...AUX CIRCUIT REQUEST
	J	OUTINV			:9...CRASH HIM
	J	OUTCA			:A...SOFT SHUT STATUS
	J	OUTINV			:B...CRASH HIM
	J	OUTCC			:C...HOST COST
	J	OUTINV			:D...CRASH HIM
	J	OUTINV			:E...CRASH HIM
	J	OUTINV			:F...CRASH HIM



:	RESTART REQUEST
OUTC0	LIS	R15,0			:CANCEL INPUT
	ST	R15,AIRING,,
	LI	R14,40000
	LHI	R15,0100		:RESPONSE
	STM	R14,AORING,,
	J	OEXIT			:AND QUIT



:	RESTART RESPONSE
OUTC1	JAL	R4,ELIR			:JUST IGNOR
	J	OUTLOP




:	REPORT TO SUP LOG (KLUDGE FOR TYMNET-I---TYMNET-II COMPATABILITY)
OUTC3	JAL	R4,GETH			:GET KEY
	LBR	R7,R0			:COPY KEY
	SRHLS	R7,2			:CONVERT KEY TO "X"
	OHI	R7,$8 100070		:MESSAGE SUBTYPE = 7X
	JAL	R4,GETH			:GET HW4
	LBR	R8,R0
	JAL	R4,GETH			:GET HW3
	LBR	R0,R0
	EXBR	R0,R0
	OR	R8,R0			:SR3 = (8)HW3|(8)HW4
	JAL	R4,GETCH		:GET HW2 (LOW)
	SLHLS	R0,6
	OR	R7,R0			:THIS GOES INTO SR2
	JAL	R4,ELIR			:END LOGICAL INPUT RECORD
	JAL	R9,REPORT		:REPORT THIS TO SUP
	J	OUTLOP			:AND QUIT




:	REPORT HOST STATUS
OUTC4	JAL	R4,GETH			:GET KEY, STATUS
	LBR	R10,R0			:SAVE SLOT (HOST) KEY
	JAL	R4,GETH			:HOST #
	LR	R6,R0
	JAL	R4,GETH			:NUMBER OF PORTS
	CLHI	R0,PPH-1		:NO MORE PORTS THAN SUP WILL ALLOW
	JLFS	.+6
	LHI	R0,PPH-1
	LR	R7,R0
	JNFS	OUTC4A			:SKIP IF PORTS SPECIFIED
	LR	R6,R6
	JEFS	OUTC4A			:SKIP IF NO HOST SPECIFIED
	LIS	R7,1			:HOST, NO PORTS DEFAULT TO 1 PORT
OUTC4A	JAL	R4,GETW			:RELATIVE HOST #|STATUS
	EXBR	R11,R0			:(HOST # MUST = 0 FOR TYMNET-I)
	JAL	R4,ELIR			:END LOGICAL INPUT RECORD
	THI	R11,1			:IS HOST DOWN?
	JEFS	OUTC4B			:SKIP IF NOT
	OHI	R7,8000			:DOWN...SET FLAG
	JFS	OUTC4C			:AND SKIP
OUTC4B	THI	R11,2			:HOST UP...ANSWERED?
	JNFS	OUTC4C			:SKIP IF NOT
	OHI	R6,8000			:ELSE SET ANSWERED FLAG
OUTC4C	LH	R1,HOST0,R10		:GET OLD HOST STATUS
	STH	R6,HOST0,R10		:AND SET NEW
	LH	R2,UP0,R10		:GET OLD UP/DOWN STATUS
	LR	R11,R2			:SAVE COPY
	STH	R7,UP0,R10		:AND SET NEW
	XR	R2,R7			:DETECT CHANGES IN UP/DOWN
	JE	OUTC4J			:SKIP IF NO CHANGE
	LR	R8,R10			:REPORT CHANGE TO SUP
	SLHLS	R8,$A10			:RELATIVE HOST NUMBER
	LHI	R0,8000
	NR	R0,R7			:GET UP/DOWN FLAG
	OR	R8,R0			:ADD TO MESSAGE
	NHI	R6,7FFF			:HOST NUMBER
	JE	OUTC4D			:DON'T REPORT IF HOST=0
	OR	R8,R6			:SR3
	NHI	R7,1FF			:EXTRACT NUMBER OF PORTS
	SLHLS	R7,6
	OHI	R7,8002			:SR2
	JAL	R9,REPORT		:REPORT IT TO SUP
OUTC4D	LH	R0,UP0,R10		:DID IT GO UP OR DOWN?
	JGE	OUTC4F			:WENT UP...SKIP
	LR	R7,R10			:WENT DOWN...ZAP ANY CIRCUITS ABOUT
	JE	OUTLOP			:...EXCEPT FOR KERNEL HOST...LEAVE IT ALONE!
	LA	R12,OUTLOP		:ELSE SET DEFAULT EXIT
	SLHLS	R7,HSHIFT-2		:FIRST PORT OF HOST
	SIS	R7,1
	NHI	R11,7FFF		:EXTRACT OLD NUMBER OF PORTS
OUTC4E	SIS	R11,1
	JLR	R12			:EXIT WHEN DONE
	AIS	R7,1			:SET NEXT PORT
	TBT	R7,ACP			:CHECK IT
	JEBS	OUTC4E			:WASN'T SET
	LA	R12,OEXIT		:WE DID FIND A PORT, GIVE ZAPPERS A CHANCE!
	SBT	R7,STOPIN		:TURN OFF ANY BACKPRESSURE, SO ZAPPER WILL FLOW
	SBT	R7,NPIIN		:INSURE IT WILL BE LOOKED AT
	LR	R1,R7			:COMPUTE BUFFER INDEX
	SLLS	R1,3			:4*BUFF#
	JAL	R4,SPEED
	LIS	R0,3			:ZAP IN BOTH DIRECTIONS
	JAL	R5,WCI
	XHI	R1,4
	JAL	R4,SPEED
	LHI	R0,3
	JAL	R5,WCI
	J	OUTC4E			:THEN GO DO ANOTHER PORT

:	JUST CAME UP
OUTC4F	LR	R9,R10			:COPY HOST INDEX
	JE	OUTC4K			:ABORT FOR KERNEL HOST
	SLHLS	R9,HSHIFT-2		:ELSE COMPUTE FIRST PORT FOR HOST
	LHI	R1,PPH			:SET UP BUFFER FLAGS
	SR	R1,R0			:R1 = NUMBER OF NORMAL PORTS + 1
	LR	R8,R9			:SAVE COPY
	LA	R2,RTOP*8,R9		:BF VALUE FOR FIRST PORT
	SLLS	R9,3			:FIRST PORT BUFFER FOR HOST
	LR	R0,R0			:CHECK FOR 0 HOST PORTS
	JE	OUTC4H			:SKIP HOST PORT SECTION IF NONE
OUTC4G	EXHR	R2,R2
	STH	R2,BF+4,R9		:STORE TOWARD THE HOST AND AWAY FROM HOST BF'S
	EXHR	R2,R2
	STH	R2,BF,R9
	AIS	R2,1
	AIS	R9,8
	SBT	R8,HPFLAG		:FLAG THIS AS A HOST PORT
	AIS	R8,1
	SIS	R0,1
	JGEBS	OUTC4G
OUTC4H	SIS	R1,1			:CHECK FOR ANY NORMAL PORTS
	JLE	OUTC4K			:SKIP IF NOT
OUTC4I	STH	R2,BF+4,R9		:STORE TOWARD PORT AND AWAY FROM PORT BF'S
	EXHR	R2,R2
	STH	R2,BF,R9
	EXHR	R2,R2
	AIS	R2,1
	AIS	R9,8
	RBT	R8,HPFLAG		:FLAG THIS PORT AS A NORMAL PORT
	AIS	R8,1
	SIS	R1,1
	JGBS	OUTC4I
	JFS	OUTC4K			:NOW GO REPORT ANSWER/SHUT

OUTC4J	XR	R6,R1			:HOST DIDN'T CHANGE...DETECT CHANGES IN ANS/SHUT
	JGE	OUTLOP			:NO CHANGE...DO ANOTHER MESSAGE
OUTC4K	LHI	R6,5000			:SR1
	LH	R7,HOST0,R10		:SR2
	THI	R7,7FFF			:CHECK FOR HOST=0
	JE	OUTLOP			:DON'T REPORT IT IF SO
	EXHR	R8,R7			:COPY BIT
	NHI	R8,1
	OHI	R8,0600			:SR3
	JAL	R9,LEPSNU		:SEND ON TO SUPERVISOR
	J	OUTLOP			:NOW GO FOR ANOTHER MESSAGE




:	REPORT ACCOUNTING
OUTC5	JAL	R4,GETH			:SKIP NEXT CHARACTER
	JAL	R4,GETH			:GET SR2
	LR	R7,R0
	JAL	R4,GETH			:GET SR3
	LR	R8,R0
	JAL	R4,ELIR			:END LOGICAL INPUT RECORD
	LHI	R6,7000			:SET ACCOUNTING MESSAGE
	JAL	R9,LEPSNU		:SEND ON TO SUP
	J	OUTLOP			:AND DO ANOTHER




:	WE HAVE A REQUEST FOR A NORMAL CIRCUIT
OUTC7	JAL	R4,GETH			:GET HOST KEY
	LBR	R6,R0			:SAVE COPY
	LH	R0,USWICH		:CHECK IF THERE'S A SUP
	JE	OUTC7B			:SKIP IF NOT
	LR	R7,R6
	SLHLS	R7,HSHIFT-5		:COMPUTE FIRST BIT FOR HOST IN BIT ARRAY
	LHI	R4,PPH/20		:SEARCH FOR AN AVAILABLE PORT
OUTC7A	L	R1,HPFLAG,R7		: .NOT. (HOSTPORT
	O	R1,ACP,R7		: .OR ACTIVE PORT)
	XHI	R1,-1
OUTC7F	JN	OUTC7D			:SKIP IF FOUND ONE
	AIS	R7,4
	SIS	R4,1
	JGBS	OUTC7A			:REPEAT FOR ALL PORTS
OUTC7B	JAL	R4,GETH			:CAN'T DO IT...REJECT REQUEST
	LR	R8,R0			:GET LOCAL KEY
	JAL	R4,GETH			:TOSS DIALECT
	JAL	R4,GETW			:SKIP OVER ORIG HOST, TID
	JAL	R4,ELIR			:END LOGICAL INPUT RECORD
OUTC7C	LIS	R0,8			:WE NEED TO SEND BACK 7 BYTES
	JAL	R4,ROOM
	LHI	R0,0900,R6		:MESSAGE TYPE 9
	JAL	R4,PUTW
	EXHR	R0,R8			:LOCAL KEY, ERROR 0
	JAL	R4,PUTW
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
	J	OUTLOP			:THEN SCAN FURTHER

OUTC7D	JAL	R3,BID			:WE FOUND A PORT TO USE...WHICH ONE?
	LR	R9,R7			:MAKE COPY OF R7
	SLLS	R9,3			:CALC PORT#
	AR	R9,R2			:/
	SLLS	R9,3			:8*PORT# = 4*BUFF#
	LHL	R0,BF,R9		:CHECK IF PORT IS REALLY INACTIVE
	JEFS	OUTC7E			:OK IF BF=0
:	PORT STILL ACTIVE (RMAKE HASN'T PROCESSED ZAPPER YET)
	SLL	R1,1,R2			:RESET BIT FOR THIS PORT
	SRL	R1,1,R2			:/
	J	OUTC7F			:CONTINUE SEARCH FOR AVAILABLE PORT

OUTC7E	SRLS	R9,3			:RESTORE PORT#
	LR	R7,R9			:...INTO R7
	LHI	R0,MAXCHR
	STB	R0,XLIMIT,R7		:SET UP INITIAL TRANSMIT LIMIT FOR PORT
	JAL	R4,GETW			:GET LOCAL KEY, DIALECT
	STH	R0,DIALCT,R7,R7		:SAVE DIALECT
	LR	R9,R0
	JAL	R4,GETW			:GET ORIG. HOST, TID
	EXBR	R10,R0			:SAVE TID
	OHI	R10,0C0			:FORCE TWO HIGH BITS ON, FOR SUP
	EXHR	R0,R0
	STH	R0,OHOST,R7,R7		:SAVE ORIGINATION HOST #
	JAL	R4,ELIR			:END LOGICAL INPUT RECORD
	LIS	R0,6			:SEND BACK 6 CHAR RESPONSE
	JAL	R4,ROOM
	LR	R0,R7			:PORT NUMBER
	JAL	R4,PUTH
	LHI	R0,PNMSG^8,R6		:PSEUDO NEEDLE
	JAL	R4,PUTH
	EXHR	R0,R9			:LOCAL KEY
	JAL	R4,PUTH
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
	SBT	R7,ACP			:SET PORT ACTIVE
	SBT	R7,LOGON		:SET LOGON MODE FLAG
	SBT	R7,STOPIN		:SET INPUT NOT BACK-PRESSURED
	SBT	R7,STOPO		:SET OUTPUT NOT BACK-PRESSURED
	LA	R0,8*RTOP,R7		:COMPUTE CORRECT BF VALUE
	AR	R7,R7			:SET CORRECT BUFFER NUMBER FOR SUP
	LR	R1,R7
	SLLS	R1,2			:COMPUTE BUFFER INDEX
	STH	R0,BF+4,R1		:SET UP BF FOR "TOHOST" BUFFER
	JAL	R5,CLEAR		:CLEAR TOHOST BUFFER
	AIS	R1,4			:COMPUTE OTHER BUFFER OF PAIR
	JAL	R5,CLEAR		:CLEAR FROMHOST BUFFER
	LHI	R6,01000		:NOW...TYPE 1 MESSAGE TO SUP
	LIS	R8,3			:FIRST, SEND SUP A ZAPPER TO CLEAN UP PORT
	JAL	R9,LEPSNU
	LBR	R8,R10			:NOW GET TID
	JAL	R9,LEPSNU
	J	OUTLOP			:NOW GO ON FOR NEXT MESSAGE




:	HAVE A REQUEST FOR AN AUX CIRCUIT
OUTC8	JAL	R4,GETH			:GET HOST INDEX
	LBR	R6,R0			:SAVE COPY
	LH	R0,USWICH		:DO WE HAVE A SUP?
	JE	OUTC8D			:ABORT REQUEST IF NOT
	LIS	R0,0
	TBT	R0,N.LIC,R6		:CHECK THE SLOT'S LICENCE
	JE	OUTC8D			:NO AUX-CIRCUIT LICENCE...ABORT
	LHI	R4,PPH/8-4		:SEARCH FOR UNASSIGNED BUFFER
OUTC8A	L	R1,AVLB,R4		:AVAILABLE BUFFERS
	O	R1,ACLB,R4		:ASSIGNED BUFFERS
	XHI	R1,-1			:NOT STATE
	JNFS	OUTC8B			:SKIP IF FOUND A BUFFER
	SIS	R4,4			:ELSE SCAN MORE
	JGEBS	OUTC8A
	J	OUTC8D			:NO LUCK...ABORT
OUTC8B	JAL	R3,BID			:GOT ONE...WHICH?
	SLHLS	R4,3			: *32 (ALLOW FOR COUNT BY 4)
	AR	R2,R4			:COMPUTE BUFFER NUMBER
	LR	R8,R6			:COMPUTE HOST NUMBER FROM DISPATCHER KEY
	SLHLS	R8,HSHIFT-2		:GET FIRST PORT FOR HOST
	LHI	R7,PPH-1,R8		:GET LAST PORT FOR HOST
OUTC8C	LB	R0,AUXKEY,R7		:SEARCH FOR A FREE PORT FOR THIS HOST
	LR	R0,R0			:LOOKING FOR 0
	JE	OUTC8E			:SKIP IF WE FOUND ONE
	SIS	R7,1
	CR	R7,R8
	JGEBS	OUTC8C			:SEARCH FOR IT
OUTC8D	JAL	R4,GETH			:WE HAVE TO REJECT IT...GET LOCAL KEY
	LR	R8,R0
	JAL	R4,GETH			:SKIP DIALECT
	JAL	R4,GETH			:SKIP ORIGINATION HOST
	JAL	R4,GETCH		:GET TEXT SIZE
	JAL	R4,FLUSH		:FLUSH REST OF MESSAGE
	J	OUTC7C			:AND REJECT REQUEST

:	WE HAVE A PORT # (SUPERVISOR KEY) (R7) AND A BUFFER # (R2)
OUTC8E	SBT	R2,ACLB			:GOT IT...FLAG IT ASSIGNED
	STB	R2,AUXKEY,R7		:SAVE BUFFER NUMBER IN AUXKEY(SUPKEY)
	STB	R6,SLKEY,R2		:SAVE SLOT KEY(BUFFER)
	LR	R1,R2			:COMPUTE BUFFER INDEX
	AR	R1,R1
	JAL	R4,GETH			:GET LOCAL KEY
	STH	R0,INTKEY,R1		:SAVE IT TOO
	JAL	R4,GETH			:DIALECT CODE
	STH	R0,ADIALC,R1
	JAL	R4,GETH			:ORIGINATION HOST
	STH	R0,AOHOST,R1
	AR	R1,R1			:4*BUFF#
	JAL	R4,GETCH		:NOW GET SIZE OF STRING
	LR	R6,R0
OUTC8F	JAL	R4,GETCH		:GET A CHAR
	OHI	R0,80			:FORCE HIGH BIT ON
	JAL	R5,WCI			:AND PLACE IN BUFFER
	CLHI	R0,08D			:C/R?
	JEFS	OUTC8G			:SKIP IF SO
	CLHI	R0,0BB			:SEMI-:?
	JEFS	OUTC8G
	SIS	R6,1			:ELSE REPEAT AS NECESSARY
	JGBS	OUTC8F
	LHI	R0,0BB			:DIDN'T FIND TERMINATOR, SO FAKE IT
	JAL	R5,WCI
	LIS	R6,1			:RESTORE COUNTER
OUTC8G	LR	R0,R6			:FLUSH INPUT MESSAGE
	SIS	R0,1			:REDUCE TO COUNT OF CHARS REMAINING
	JAL	R4,FLUSH
	LHI	R6,05000		:SUP MESSAGE TYPE 5
	LHI	R8,00500		:SUBTYPE 5...REQUEST AUX CIRCUIT
	JAL	R9,LEPSNU		:SEND TO SUP
	J	OUTLOP			:PROCESS NEXT MESSAGE




:	RECESS NEXT MESSAGE




:	REPORT SOFT ANSWER/SHUT
OUTCA	JAL	R4,GETH			:GET KEY
	LR	R8,R0			:COPY
	SLHLS	R8,$A 12		:ADJUST HOST-TABLE BITS (ALLOW FOR KEY OFFSET)
	JAL	R4,GETH			:GET HOST NUMBER
	OR	R8,R0			:FORMAT FIELDS INTO SR3
	LHI	R7,8002			:SET SOFT SHUT INTO SR2
	JAL	R4,GETH			:CHECK NUMBER OF PORTS
	LR	R0,R0
	JEFS	.+4			:SKIP IF SHUT
	AIS	R7,1			:ELSE CLEAR SOFT SHUT
	JAL	R4,GETH			:SKIP OVER RH#
	JAL	R4,ELIR			:END-LOGICAL-INPUT-RECORD
	LHI	R6,6000			:SET TYPE 6
	JAL	R9,LEPSNU		:SEND TO SUP
	J	OUTLOP			:PROCEED TO NEXT MESSAGE




:	REPORT HOST COST
OUTCC	JAL	R4,GETH			:GET KEY
	LR	R8,R0			:COPY
	SLHLS	R8,$A 14		:ADJUST HOST-TABLE BITS
	JAL	R4,GETH			:GET HOST NUMBER
	OR	R8,R0			:FORMAT FIELDS INTO SR3
	LHI	R7,8001			:SET COST MESSAGE INTO SR2
	JAL	R4,GETH			:FETCH COST
	SLHLS	R0,6			:JUSTIFY IT
	OR	R7,R0			:PUT COST INTO SR2
	JAL	R4,GETH			:SKIP RH#
	JAL	R4,ELIR			:END-LOGICAL-INPUT-RECORD
	LHI	R6,6000			:SET TYPE 6
	JAL	R9,LEPSNU		:SEND TO SUP
	J	OUTLOP			:PROCEED TO NEXT MESSAGE
	EI	(SAL)

OEXIT	JAL	R0,INT			:EXIT TO HERE...SERVICE INTERNAL CIRCUITS




:	* * * P O R T   I N P U T   P R O C E S S I N G * * *
:                 * * *  T O  I S I S  * * *

	LHI	R11,(TNPG-1)*2		:START WITH THE LAST GROUP
INNEXT	LHL	R1,NPIIN,R11		:'PORTS IN INPUT WAIT' NOT PROCESSED
	NH	R1,TOPORT,R11		:PORTS WITH DATA PRESENT
	NH	R1,ACP,R11		:ACTIVE PORTS
	NH	R1,STOPIN,R11		:PORTS NOT BACK-PRESSURED
	JE	INELOP			:NONE THERE...SKIP TO END OF LOOP
	JAL	R3,BIDH			:WE'VE GOT ONE...GO GET HIM
	LR	R1,R11			:COPY GROUP INDEX
	SLHLS	R1,3			:MAKE PORT NUMBER...ALLOW FOR COUNTING BY 2'S
	AR	R1,R2
	RBT	R1,NPIIN		:TAKE BIT DOWN
	IF	SAL
	LB	R2,TXITBL,R1		:GET ISIS PORT NUMBER
	STH	R2,IPORT		:SAVE ISIS PORT NUMBER
	ELSE
	CLHI	R1,NKU			:ARE WE LOOKING AT KERNEL BUFFER?
	JL	INNEXT			:YES...IGNOR IT
	STH	R1,IPORT		:SAVE ISIS PORT NUMBER
	EI	(SAL)
	STH	R1,PORT			:SAVE ABSOLUTE PORT NUMBER
	LR	R2,R1			:MAKE A COPY
	SLLS	R1,3			:4*(2*PORT) = 8*PORT = BUFFER NUMBER
	AIS	R1,4			:ASSUME IT'S NOT A HOST PORT
	TBT	R2,HPFLAG		:IS IT?
	JEFS	INNEX1			:SKIP IF NOT
	SIS	R1,4			:ELSE SET UP FOR HOST-PORT CONVENTIONS
INNEX1	STH	R1,BUFNUM
	JAL	R12,PROCI		:MOVE THE RECORD INTO THE BUFFER
	J	INNEXT			:PROCESS ANY OTHERS IN THIS GROUP
INELOP	SIS	R11,2			:GO TO NEXT GROUP
	JGE	INNEXT
	LCS	R0,1			:DONE IT ONCE...CLEAR NPIIN ARRAY
	LHI	R11,(TNPG-2)*2
INE1	ST	R0,NPIIN,R11
	SIS	R11,4
	JGEBS	INE1			:RESET NPIIN, THEN QUIT...WE'LL CATCH EVERYONE NEXT TIME
	JAL	R0,TIMOUT		:EXIT TO HERE
	IF	1-SAL



:	* * * T R A N S M I T   L O G O N   S T A T U S * * *
	LHI	R5,(TNPG-2)*2		:FOR ALL PORTS
TELS1	LCS	R1,1			: .NOT. DATA PRESENT
	X	R1,TOPORT,R5
	N	R1,LOGON,R5		:AND IN LOGON STATE
	JE	TELSXIT			:QUIT ON GROUP IF NONE THERE
	ST	R1,TEMP			:ELSE SAVE BIT ARRAY
TELS2	JAL	R3,BID			:WHICH BIT?
	RBT	R2,TEMP			:INSURE WE DON'T LOOK AGAIN
	LR	R1,R5			:MAKE PORT NUMBER
	SLHLS	R1,3			:*32 (ALLOW FOR COUNT BY 4'S)
	AR	R1,R2
	LB	R6,B4STAT,R1		:LOOK FOR STATUS
	LR	R6,R6
	JE	TELS3			:SKIP IF NO STATUS TO PASS
	LIS	R0,0			:ELSE CANCEL STATUS
	STB	R0,B4STAT,R1
	XHI	R6,10			:TOGGLE SPARE BIT
	LIS	R0,4			:4 BYTE MESSAGE
	LHI	R2,NLOGST		:NEW LOGON STATUS
	JAL	R4,SLOR			:START-LOGICAL-OUTPUT-RECORD
	LR	R0,R6
	JAL	R4,PUTCH
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
TELS3	L	R1,TEMP			:CHECK IF ANY OTHERS IN THIS GROUP
	JN	TELS2			:REPEAT IF SO
TELSXIT	SIS	R5,4			:REPEAT FOR ALL GROUPS
	JGE	TELS1
	EI



:	* * * C A N C E L   B A C K P R E S S U R E * * *
	LHI	R5,(TNPG-1)*2		:DO FOR ALL GROUPS
	LCS	R6,1
CBLOOP	STH	R6,TEMP
CBLOP1	LCS	R1,1			:FIND PORTS WITH BACK-PRESSURE APPLIED,
	XH	R1,STOPO,R5
	NH	R1,TEMP			:...THAT WE'VE NOT LOOKED AT YET
	JE	CBELOP			:NONE HERE...TRY NEXT
	JAL	R3,BIDH			:GOT ONE...WHICH ONE
	RBT	R2,TEMP			:INSURE WE DON'T LOOK AT IT AGAIN
	LR	R1,R5
	SLHLS	R1,3			:ALLOW FOR COUNTING BY 2'S
	AR	R2,R1			:MAKE PORT NUMBER
	IF	1-SAL
	CLHI	R2,NKU			:CHECK IF KERNEL PORT
	JL	CBLOP1			:IGNOR IF SO
	EI	(1-SAL)
	LR	R1,R2			:COPY PORT #
	SLLS	R2,3			:8*PORT#
	TBT	R1,HPFLAG		:IS THIS A HOST PORT?
	JEFS	.+4			:SKIP IF NOT
	AIS	R2,4			:ELSE COMPUTE OTHER BUFFER OF PAIR
	LHL	R0,BCT,R2
	CLHI	R0,MNBSIZ		:HAS IT LESS THAN MINIMUM?
	JG	CBLOP1			:IF NOT, FORGET HIM
	SBT	R1,STOPO		:ELSE TURN OFF FLAG
	LIS	R0,4			:START INPUT RECORD
	IF	SAL;	LB	R1,TXITBL,R1		:GET ISIS PORT #;	EI
	LHI	R2,SNDMSG
	JAL	R4,SLOR
	JAL	R4,ELOR			:TERMINATE MESSAGE
	J	CBLOP1			:AND DO ANOTHER

CBELOP	SIS	R5,2			:DO FOR ALL GROUPS
	JGE	CBLOOP			:DO FOR ALL
	L	R0,TIRET4
	JR	R0

:	INVALID OUTPUT...RESET IT
:OUTINV	LI	R14,40000
	LIS	R15,0
	ST	R15,AIRING,,		:EMPTY INPUT
	STM	R14,AORING,,		:RESET RINGS MESSAGE
OUTINV	HS	0			::::TEMP PATCH FOR DEBUGGING
	L	R0,TIRET4
	JR	R0


:	ZAP A CIRCUIT
:	RETURN ZAPPER TO ISIS SO DISPATCHER CAN REUSE PORT
:	LINK ON R9
:	REQUIRES IPORT = ISIS PORT NO.
IZAPP	LIS	R0,3
	LHL	R1,IPORT
	JER	R9			:RETURN IF ISIS PORT NOT ASSIGNED
	LHI	R2,ZAPMSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	JR	R9


:	ZAP A CIRCUIT
:	LINK ON R9
:	PORT IS SET TO PORT NUMBER
ZAPP	LHL	R8,PORT			:GET PORT NUMBER
	SBT	R8,STOPIN		:TURN OFF INPUT BACK-PRESSURE
	RBT	R8,ACP			:SET PORT NOT ACTIVE
	RBT	R8,CTERM		:TEST IF CIRCUIT TERMINATED HERE
	JER	R9			:RETURN IF NOT
	AR	R8,R8			:ELSE MAKE BUFFER NUMBER IN SR3
	LHI	R7,8000			:REPORT CIRCUIT ZAPPED TO SUP
	J	REPORT			:EXIT VIA REPORT


	IF	SAL

:	ENTER DETACH MODE (LOOK FOR ORANGE BALLS OR ZAPPERS)
:	EXPECTS R1 = BUFFER INDEX
:		R9 = PORT #
EDETM	SBT	R9,YBT2			SET YELLOW-BALL TIMEOUT
	LIS	R0,1			:OUTPUT YELLOW BALL
	JAL	R5,WCI			:  /
	LHI	R0,0FF			: /
	JAL	R5,WCI			:/

	XHI	R1,4			:OTHER BUFFER OF PAIR
	LHI	R0,RDET*8,R9		:POINT BF TO DETACH LOGIC
	LHL	R2,BF,R1		:GET OLD BF
	STH	R0,BF,R1		:STORE NEW BF
	RBT	R2,FLAGS		:CLEAR OLD FLAG
	JER	R8
	SBT	R0,FLAGS		:SET NEW FLAG IF OLD ONE WAS SET
	JR	R8			:RETURN


:	DETACH LOGIC 
:	LOOK FOR ORANGE BALLS OR ZAPPERS AND IGNORE EVERYTHING ELSE
DETMO	AHI	R1,RATE/2		:RUN AGAIN IN 1/2 SEC
	JAL	R5,TOPUT

	LHI	R11,((NHPORT+0F)/10)*2-2	:LOOK ONLY AT HOST PORTS
DETNXT	LHL	R1,YBT2,R11		:YELLOW BALL TIMERS
	OH	R1,YBT1,R11
	NH	R1,DETACH,R11		:.AND. PORTS WITH DATA
	JNFS	DET1			:PORT REQUIRING SERVICE
	SIS	R11,2			:GO TO NEXT GROUP
	JGEBS	DETNXT			:UNTIL ALL GROUPS ARE PROCESSED
	J	TORET			:THEN RETURN

DET1	JAL	R3,BIDH			:FIND WHICH PORT
	LR	R8,R11
	SLLS	R8,3
	AR	R8,R2			:PORT #

	LR	R1,R8
	SLLS	R1,3			:CALC BUFFER INDEX
DET2	LHL	R0,BCT,R1		:IS BUFFER NOW EMPTY?
	JLE	DETNXT			:YES
	JAL	R5,GCI			:NO...GET ANOTHER CHAR
	SIS	R0,3
	JGBS	DET2			:EAT ALL UNINTERESTING CHARS
	JE	DET4			:...BUT NOT ZAPPERS
	AIS	R0,2
	JGBS	DET2
	JEFS	DET3			:SKIP IF PREFIX CODE
	JAL	R5,GCI			:ESCAPED...EAT IT
	JBS	DET2
DET3	JAL	R5,GCI			:PREFIX CODE...IS IT ORANGE BALL?
	CLHI	R0,0FE
	JN	DET2			:NO..JUST IGNOR IT
	XHI	R1,4			:WE GOT ONE...OTHER BUFFER OF PAIR
	JAL	R4,SPEED
	LIS	R0,3
	JAL	R5,WCI			:SEND ZAPPER BACK
DET4	RBT	R8,YBT1
	RBT	R8,YBT2
	RBT	R8,LOGON		:CLEAR LOGON STATE
	RBT	R8,LOGGING
	SBT	R8,ACKWAIT		:WE'LL WAIT FOR DISPATCHER TO ACK ZAPPER
	LB	R1,TXITBL,R8		:GET ISIS PORT #
	STH	R1,IPORT		:SAVE FOR IZAPP
	JAL	R9,IZAPP		:AND NOTIFY ISIS THAT PORT IS FREED
	J	DETNXT			:AND THEN PROCEED

	EI	(SAL)

:	***PROCESS PORT OUTPUT MESSAGE***


:	OUTPUT CO-ROUTINES
:	DEPENDING ON MESSAGE TYPE, MAY CONTAIN POINTER, OR CHARACTER TO SEND (IF NEGATIVE)
POTTAB	WS	0			:FORCE TO WORD BOUNDARY
	J	POZAP			:9E  DETACH (TREAT AS ZAPPER)
	J	POZAPP			:9F  DISCONNECT
	J	PODONT			:A0  STOP SENDING
	J	POCAN			:A1  MAY SEND
	J	POGOB			:A2  GOBBLER
	J	POGOBB			:A3  REVERSE GOBBLER
	WC	0C00000FD		:A4  DATA LOSS IN THIS DIRECTION (PREFIX CHAR)
	WC	0C00000FC		:A5  DATA LOSS IN OPPOSITE DIRECTION (PREFIX CHAR)
	WC	080000007		:A6  ENTER 'DEM' (CHARACTER)
	WC	080000004		:A7  EXIT 'DEM' (CHARACTER)
	WC	0C00000F2		:A8  ENTER 'TM' (PREFIX CHAR)
	WC	0C00000F3		:A9  EXIT 'TM' (PREFIX CHAR)
	WC	080000005		:AA  GREEN BALL (CHAR)
	WC	080000006		:AB  RED BALL (CHAR)
	J	POYELB			:AC  YELLOW BALL (PREFIX CHAR)
	WC	0C00000FE		:AD  ORANGE BALL (PREFIX CHAR)
	WC	0C00000FB		:AE  BREAK BEGIN (PREFIX CHAR)
	IF	SAL
	J	POHANG			:AF  HANG CHARACTER (TREAT ALMOST AS ZAPPER)
	ELSE
	WC	0C00000F0		:AF  HANG CHARACTER (PREFIX CODE)
	EI
	J	POTPQ			:B0  TERMINAL CHARACTERISTICS- PROBE
	J	POTPS			:B1  TERMINAL CHARACTERISTICS- SET
	IF	SAL
	J	POPNED			:B2  PSEUDO-NEEDLE
	J	OUTINV			:B3  LOGIN CHAR
	J	POLS			:B4  LOGON STATUS
	J	ORET			:B5  LOGON FAILURE...IGNORE, ZAPPER WILL FOLLOW
	J	POSLOG			:B6  SUCCESSFUL LOGON
	ELSE
	J	OUTINV			:B2  PSEUDO-NEEDLE
	J	POLOGC			:B3  LOGON CHAR
	J	OUTINV			:B4  LOGON STATUS
	J	OUTINV			:B5  LOGON FAILURE
	J	OUTINV			:B6  SUCCESSFUL LOGON
	EI
	J	OUTINV			:B7  ADDENDUM TO ACCOUNTING
	WC	0C00000F1		:B8  SUPER-HANG CHARACTER (PREFIX CHAR)
	J	POSXL			:B9  SET TRANSMIT LIMIT
	WC	0C00000FA		:BA  BREAK END (PREFIX CHAR)
	J	POACK			:BB  ZAP ACKNOWLEDGEMENT
	WC	0C00000F4		:BC  ENTER 'ALTERNATE OUTPUT DEVICE MODE'
	WC	0C00000F5		:BC  LEAVE 'ALTERNATE OUTPUT DEVICE MODE'


:	P R O C E S S   P O R T   O U T P U T   F R O M   I S I S
:	CALLED VIA JAL  PROCO,R12
:		R10 = ISIS PORT NUMBER
:		R11 = MESSAGE TYPE
PROCO	STH	R10,IPORT		:SAVE ISIS PORT NUMBER
	IF	SAL;	LB	R10,IXTTBL,R10		:GET REAL PORT NUMBER;	EI
	STH	R10,PORT		:SAVE REAL PORT NUMBER
	LR	R9,R10			:SAVE COPY
	SLLS	R10,3			:4*(2*PORT+1) = OUTPUT BUFFER NUMBER
	TBT	R9,HPFLAG		:IS THIS A HOST PORT?
	JEFS	.+4			:SKIP IF NOT
	AIS	R10,4
	STH	R10,BUFNUM		:SAVE BUFFER NUMBER
	TBT	R11,BDATA		:TEST IF DATA OR TEXT
	JN	PONORM			:SKIP IF TEXT
	CLHI	R11,MAXTYP		:NOT TEXT...CHECK RANGE
	JG	OUTINV			:OUT OF RANGE
	LHI	R1,-FIRST,R11		:BIAS MESSAGE TYPE BY RANGE
	JL	OUTINV			:INVALID IF IT WAS 0
	SLHLS	R1,2			:ELSE MAKE WORD INDEX
	L	R10,POTTAB,R1		:GET TABLE ENTRY
	JG	POTTAB,R1		:POSATIVE, SO GO THERE
	TI	R10,040000000		:DOES IT TRANSLATE INTO PREFIX CODE?
	JEFS	PROCO2			:NO...SKIP

PROCO1	LIS	R0,1			:YES...PUT PREFIX IN
	LHL	R1,BUFNUM
	JAL	R5,WCI
PROCO2	LHL	R1,BUFNUM		:PUT CODE INTO BUFFER
	LBR	R0,R10			:CODE IS IN R10 FROM TRANSFER TABLE
	JAL	R5,WCI
	JR	R12			:AND EXIT...DONE


:	OUTPUT TEXT MESSAGE
PONORM	HS	0

	IF	ACCT
:	INCR CHAR COUNT FROM HOST (IF HOST PORT)
	LHL	R1,PORT			:GET PORT #
	TBT	R1,HPFLAG		:HOST PORT?
	JEFS	PONOR0			:NO, SKIP
	SLLS	R1,2			:4*PORT#
	AM	R11,AAOC,R1,		:INCR COUNT
PONOR0	HS	0
	EI	(ACCT)

	JAL	R4,GETCH		:SKIP MESSAGE TYPE
PONOR1	JAL	R4,GETCH		:GET THE NEXT CHARACTER
	LR	R9,R0			:COPY THE CHAR
	LHL	R1,BUFNUM		:SET BUFFER INDEX
	NHI	R0,0F8			:DO WE NEED AN ESCAPE?
	JNFS	PONOR2			:SKIP IF NOT
	JAL	R5,WCI			:YES
PONOR2	LR	R0,R9
	JAL	R5,WCI			:SEND CHAR
	SIS	R11,1
	JGBS	PONOR1			:AND CONTINUE

	LHL	R2,BCT,R1		:DONE...NOW CHECK THE BUFFER
	CLHI	R2,MXBSIZ
	JLR	R12			:EXIT IF WE DON'T HAVE TO APPLY BACK PRESSURE
	JAL	R4,ELIR			:END LOGICAL INPUT RECORD
	LHL	R1,PORT
	RBT	R1,STOPO		:APPLY BACK PRESSURE
	JE	OUTLOP			:DON'T BOTHER...WE ALREADY HAVE
	LIS	R0,4
	IF	SAL
	LHL	R1,IPORT		:GET ISIS PORT NUMBER
	EI
	LHI	R2,NOSMSG
	JAL	R4,SLOR
	JAL	R4,ELOR			:END THE MESSAGE
	J	OUTLOP


:	CANCEL BACK-PRESSURE
POCAN	LHL	R1,PORT			:GET PORT
	SBT	R1,STOPIN		:DO IT!
	JR	R12			:AND EXIT


:	APPLY BACK-PRESSURE
PODONT	LHL	R1,PORT
	RBT	R1,STOPIN		:DO IT!
	JR	R12			:AND EXIT


:	GOBBLER
POGOB	LHL	R1,BUFNUM		:SET BUFFER
	JAL	R4,SPEED		:SEND IT ON IT'S WAY
	LIS	R0,2			:SET GOBBLER
	JAL	R5,WCI
	JR	R12			:AND EXIT


:	REVERSE GOBBLER
POGOBB	LIS	R1,4
	XH	R1,BUFNUM		:SET OTHER BUFFER OF PAIR
	JAL	R5,CLEAR		:SEND IT ON IT'S WAY
	LIS	R0,2			:SET GOBBLER
	JAL	R5,WCI
	JR	R12			:AND EXIT
	IF	SAL



:	HANG CHARACTER
:	ZAP IN ONE DIRECTION, TREAT LIKE ZAPPER IN OTHER DIRECTION
POHANG	JAL	R4,ELIR			:END INPUT RECORD
	JAL	R9,IZAPP		:ZAP CIRCUIT GOING BACK INTO ISIS
	LHL	R9,PORT			:RESET PORT AGAIN
	JFS	POZAP0			:AND SKIP
	EI	(SAL)



:	DETACH
POZAP	HS	0
:	TREAT AS ZAPPER


:	ZAPPER
POZAPP	JAL	R4,ELIR			:END INPUT RECORD
POZAP0	TBT	R9,ACKWAIT		:ARE WE WAITING FOR ACK TO ZAPPER?
	JN	OUTLOP			:YES...JUST IGNOR ZAPPERS
	LHL	R1,BUFNUM		:OUTPUT BUFFER
	TBT	R9,HPFLAG		:IS THIS A HOST PORT?
	JE	POZAP1			:SKIP IF NOT
	IF	SAL

	IF	1-SPGLAS
	LA	R7,NETGONE		:TELL USER "INTERLINK CANCELED"
	JAL	R8,MSG
	ROUTE(SECOND,PRIME)
	EI	(1-SPGLAS)

	JAL	R8,EDETM		:SEND YELLOW BALL AND ENTER DETACH MODE

	IF	ACCT
	LR	R11,R9			:GET PORT #
	LIS	R0,2			:INDICATE HOST ZAP
	JAL	R4,AARLO		:TERMINATE ACCOUNTING
	EI	(ACCT)

	J	OUTLOP

	ELSE	(1-SAL)
	JAL	R4,SPEED		:YES...SPEED IT ALONG
	LIS	R0,3
	JAL	R5,WCI			:SEND THE ZAPPER
	J	POZAP2			:AND SKIP
	EI	(1-SAL)
:	NOT A HOST PORT
POZAP1	JAL	R4,SPEED		:SPEED IT ALONG
	LIS	R0,3
	JAL	R5,WCI			:SEND THE ZAPPER
	XHI	R1,4			:SET INPUT BUFFER
	JAL	R5,CLEAR		:CLEAN IT OUT
	LIS	R0,0
	STH	R0,BF,R1		:CLEAR BUFFER FLAG
	IF	1-SAL
	RBT	R9,LOGON		:CLEAR LOGON STATE
	JE	POZAP2			:SKIP IF NOT SET
	LHI	R6,01000		:ELSE SET TYPE 1 SUP MESSAGE
	LR	R7,R9
	AR	R7,R9			:SET PORT
	LIS	R8,3			:SEND ZAPPER TO SUP
	JAL	R9,LEPSNU
POZAP2	ELSE	SAL;	JAL	R9,IZAPP;	EI
	JAL	R9,ZAPP			:FINAL CLEAN-UP, REPORT TO SUP
	J	OUTLOP			:AND EXIT


:	RECEIVED ZAP ACKNOWLEDGEMENT
POACK	JAL	R4,ELIR			:END LOGICAL INPUT RECORD
	RBT	R9,ACKWAIT		:ARE WE WAITING FOR THIS?
	JE	OUTLOP			:NO...JUST IGNOR
	JAL	R9,ZAPP			:YES...CLEANUP, TELL SUP
	J	OUTLOP			:AND PROCEED


:	YELLOW BALL
POYELB	LHI	R10,0FF			:SET YELLOW BALL
	TBT	R9,LOGON		:LOGON STATE?
	JE	PROCO1			:NO...JUST SEND IT
	SIS	R10,1			:YES...SHIP ORANGE BALL BACK
	LIS	R1,4
	XH	R1,BUFNUM
	STH	R1,BUFNUM		:SET OTHER BUFFER OF PAIR
	J	PROCO1			:AND PROCEED


:	READ TERMINAL CHARACTERISTICS
:	R10 = PARAMETER SUBTYPE
POTPQ	JAL	R4,GETH			:GET THE SUB-TYPE
	LBR	R10,R0			:COPY SUBTYPE
	CLHI	R10,NSUBTF		:DO WE KNOW THIS ONE?
	JGER	R12			:NO...IGNOR REQUEST
	LB	R10,TFQ,R10		:GET CODE
	J	PROCO1			:GO SEND IT

:	REMOTE TERMINAL FLAGS QUERY
TFQ	BC	0A0			:0  ECHO CONTROL
	BC	0A2			:1  ECHO CONTROL-I
	BC	0A6			:2  ECHO LF WITH CR
	BC	0A4			:3  ECHO CR WITH LF
	BC	0AE			:4  CR DELAY
	BC	093			:5  INPUT BAUD RATE
	BC	098			:6  OUTPUT BAUD RATE
	BC	0AA			:7  PARITY
	BC	0A8			:8  HALF DUPLEX
	BC	097			:9  PARAMETER A
	BC	096			:A  PARAMETER B
	BC	095			:B  PARAMETER C
	BC	0AC			:C  X-ENABLE
	BC	0B0			:D  ECHO CONTROL-H
	BC	0B2			:E  REVERSE X-ENABLE
	BC	094			:F  PARAMETER D
	BC	0B4			:10 KATAKANA
	BC	0B6			:11 TERMINATE OUTPUT ON BREAK


:	SET TERMINAL CHARACTERISTICS
POTPS	JAL	R4,GETH			:GET SUBTYPE
	LBR	R11,R0			:COPY IT
	JAL	R4,GETCH		:GET VALUE
	CLHI	R11,5			:*** KLUDGE TO IGNORE  INPUT BAUD RATE ***
	JER	R12			:*** KLUDGE ***
	CLHI	R11,NSUBTF		:DO WE KNOW THIS ONE?
	JGER	R12			:NO...IGNOR REQUEST
	LB	R1,TFM,R11		:GET MASK
	NR	R1,R0			:MASK VALUE TO FIELD SIZE
	LB	R10,TFS,R11		:GET CODE
	OR	R10,R1			:MERGE WITH CODE
	J	PROCO1			:SEND IT


:	REMOTE TERMINAL FLAG SET
TFS	BC	0C0			:0  ECHO CONTROL
	BC	0C2			:1  ECHO CONTROL-I
	BC	0C6			:2  ECHO LF WITH CR
	BC	0C4			:3  ECHO CR WITH LF
	BC	0CE			:4  CR DELAY
	BC	030			:5  INPUT BAUD RATE (IGNORED)
	BC	080			:6  OUTPUT BAUD RATE
	BC	0CA			:7  PARITY
	BC	0C8			:8  HALF DUPLEX
	BC	070			:9  PARAMETER A
	BC	060			:A  PARAMETER B
	BC	050			:B  PARAMETER C
	BC	0CC			:C  X-ENABLE
	BC	0D0			:D  ECHO CONTROL-H
	BC	0D2			:E  REVERSE X-ENABLE
	BC	040			:F  PARAMETER D
	BC	0D4			:10 KATAKANA
	BC	0D6			:11 TERMINATE OUTPUT ON BREAK
NSUBTF	EQ	.-TFS			:NUMBER OF SUB-TYPES IMPLEMENTED

:	REMOTE FLAG VALUE MASKS
TFM	BC	01			:0  ECHO CONTROL
	BC	01			:1  ECHO CONTROL-I
	BC	01			:2  ECHO LF WITH CR
	BC	01			:3  ECHO CR WITH LF
	BC	01			:4  CR DELAY
	BC	0F			:5  INPUT BAUD RATE
	BC	0F			:6  OUTPUT BAUD RATE
	BC	01			:7  PARITY
	BC	01			:8  HALF DUPLEX
	BC	0F			:9  PARAMETER A
	BC	0F			:A  PARAMETER B
	BC	0F			:B  PARAMETER C
	BC	01			:C  X-ENABLE
	BC	01			:D  ECHO CONTROL-H
	BC	01			:E  REVERSE X-ENABLE
	BC	0F			:F  PARAMETER D
	BC	01			:10 KATAKANA
	BC	01			:11 TERMINATE OUTPUT ON BREAK


	IF	SAL
:	PSEUDO NEEDLE
POPNED	JAL	R4,GETH			:SKIP OVER TYPE CODE
	JAL	R4,GETH			:GET KEY
	JAL	R4,ELIR			:END INPUT
	SBT	R0,ACP			:SET PORT ACTIVE
	SBT	R0,LOGON		:ALLOW LOGON CHARS TO FLOW
	SBT	R0,LOGGING
	LR	R11,R0			:COPY KEY (OUR PORT #)
	LB	R0,TIDTBL,R11		:GET TERMINAL ID
	NHI	R0,20			:TEST HALF-DUPLEX
	JE	POPN1			:SKIP IF NOT
	LIS	R0,4
	LHL	R1,IPORT		:GET ISIS PORT #
	LHI	R2,NLOGCH		:SET LOGON CHAR
	JAL	R4,SLOR
	LHI	R0,88			:CONT-H
	JAL	R4,PUTCH		:SEND LOGIN CHAR = CONT H
	JAL	R4,ELOR
POPN1	LHL	R2,IPORT		:GET ISIS PORT #
	STB	R2,TXITBL,R11		:SET UP PORT MAP MATRIX
	STB	R11,IXTTBL,R2
	LHI	R0,MAXCHR		:SET UP INITIAL TRANSMIT LIMIT FOR PORT
	STB	R0,XLIMIT,R2
	LR	R1,R11
	SLLS	R1,3			:COMPUTE BUFFER INDEX
	AIS	R1,4			:SET OUTPUT BUFFER

	IF	1-SPGLAS
	LA	R7,NETOK;	JAL	R8,MSG			:OUTPUT BANNER
	ROUTE(SECOND,PRIME)
	LA	R7,CRLF;	JAL	R8,MSG			:C/R L/F
	LA	R7,LSMS1;	JAL	R8,MSG			:"PLEASE LOG IN"
	EI	(1-SPGLAS)

	J	OUTLOP			:EXIT...DONE

:	SUCESSFUL LOGON
POSLOG	JAL	R4,GETH			:TOSS KEY
	JAL	R4,GETW			:TOSS INVOICE NUMBER

	IF	ACCT
	ST	R0,AAPINV,,		:SAVE PRIMARY NET INVOICE #
	LHL	R11,PORT
	SLLS	R11,2			:4*PORT#
	JAL	R10,AASWAP		:EXCHANGE INVOICE #'S
	EI	(ACCT)

	JAL	R4,GETH			:TOSS ORIG. HOST #
	LH	R1,PORT
	SBT	R1,STOPIN		:INSURE NOT BACK-PRESSURED
	SBT	R1,STOPO
	LA	R0,RTOP*8,R1		:CHANGE BF
	LIS	R1,4
	XH	R1,BUFNUM		:COMPUTE OTHER BUFFER OF PAIR
	LHL	R2,BF,R1		:SWAP BF'S
	STH	R0,BF,R1
	RBT	R2,FLAGS
	JER	R12			:EXIT IF NOTHING THERE
	SBT	R0,FLAGS
	JR	R12			:AND EXIT

:	LOGIN STATUS
POLS	JAL	R4,GETH			:GET STATUS
	SBT	R9,LOGON		:ALLOW LOGON CHARS TO FLOW
	THI	R0,40			:CHECK FOR ECHO-ON
	JEFS	POLS1			:SKIP IF NOT
	SBT	R9,LOGECHO		:ELSE RE-ENABLE ECHOING
POLS1	LBR	R10,R0			:SAVE COPY
	LHL	R1,BUFNUM		:GET BUFFER INDEX
	THI	R10,20			:CHECK IF WE SHOULD FLUSH OUTPUT BUFFER
	JEFS	POLS2			:SKIP IF NOT
	JAL	R5,CLEAR		:ELSE DO IT
POLS2	THI	R10,80			:SHOULD WE EMPTY INPUT BUFFER?
	JEFS	POLS2A			:NO
	AIS	R1,4			:YES, OTHER BUFF
	JAL	R5,CLEAR
	SIS	R1,4
POLS2A	LIS	R11,7			:SET MASK
	NR	R11,R10
	JER	R12			:RETURN IF 'CONTINUE'
	SLHLS	R11,2			:MAKE WORD INDEX
:	R9  = TYMNET PORT
:	R10 = STATUS
:	R11 = MESSAGE INDEX
	LA	R7,CRLF			:OUTPUT C/R L/F
	JAL	R8,MSG

	IF	NETNAME&SPGLAS
	LA	R7,PRIME		:OUTPUT NET NAME
	JAL	R8,MSG
	LA	R7,SPAC			:...FOLLOWED BY A SPACE
	JAL	R8,MSG
	EI	(NETNAME+SPGLAS)

	IF	SPGLAS
	L	R7,LSM27T,R11		:ADDR OF BEG. OF MSG FOR 2741
	ELSE	(1-SPGLAS)
	L	R7,LSMS27,R11		:ADDR OF BEG. OF MSG FOR 2741
	EI	(1-SPGLAS)
	TBT	R9,ASCII		:IS IT REALLY ASCII TERMINAL?
	JEFS	POLS4			:SKIP IF NOT
	IF	SPGLAS
	L	R7,LSMST,R11		:ADDR OF BEG. OF MSG FOR ASCII TERMINAL
	ELSE	(1-SPGLAS)
	L	R7,LSMS,R11		:ADDR OF BEG. OF MSG FOR ASCII TERMINAL
	EI	(1-SPGLAS)
	TBT	R9,HAFDUX		:IS IT HALF-DUPLEX TERMINAL?
	JNFS	POLS3			:SKIP IF SO
	TBT	R9,AUX			:IS IT AN AUX CIRCUIT?
	JEFS	POLS4			:SKIP IF NOT
	IF	SPGLAS
POLS3	L	R7,LSMSHT,R11
	ELSE	(1-SPGLAS)
POLS3	L	R7,LSMSH,R11		:HELP HALF DUX USERS HIDE PASSWORD
	EI	(1-SPGLAS)
POLS4	JAL	R8,MSG

	IF	SPGLAS
	SRLS	R11,2
	TBT	R11,NLSOK		:SHOULD MSG BE FOLLOWED BY DETACH?
	JNR	R12			:NO
	JAL	R8,EDETM		:YES, ENTER DETACH MODE
	EI	(SPGLAS)

	JR	R12			:RETURN

	ELSE	(1-SAL)

:	LOGON CHAR
POLOGC	JAL	R4,GETH			:GET THE CHAR
	OHI	R8,80			:SET HIGH-BIT FOR SUP
	LBR	R8,R0
	LHL	R7,PORT			:GET PORT #
	TBT	R7,LOGON		:IS THIS PORT IN LOGON MODE?
	JER	R12			:ABORT AND IGNOR IF NOT
	AR	R7,R7			:ELSE SUP WANTS BUFFER NUMBER
	LHI	R6,01000		:TYPE 1 SUP MESSAGE
	JAL	R9,LEPSNU		:SEND ON TO SUP
	JR	R12			:AND EXIT
	EI


:	SET TRANSMIT LIMIT
POSXL	JAL	R4,GETH			:GET THE CHAR
	LBR	R0,R0
	LR	R0,R0
	JER	R12			:DON'T LET HIM SET IT DOWN TO ZERO
	CLHI	R0,FIRST
	JLFS	POSXL1
	LHI	R0,FIRST-1		:DON'T LET HIM SET IT TOO HIGH
POSXL1	LHL	R1,IPORT		:GET ISIS PORT NUMBER
	STB	R0,XLIMIT,R1		:SET NEW LIMIT
	JR	R12			:AND EXIT

:	***PROCESS INPUT PORT TO ISIS***
PROCI	JAL	R4,SPACE		:DON'T BOTHER IF NO ROOM IN RING
	SIS	R0,4
	JLER	R12
	JAL	R6,GETCHR		:GET A CHARACTER
	JLR	R12			:EXIT IF ABNORMAL
	JG	PISPC			:SKIP IF SPECIAL
	LR	R6,R0			:SAVE CHAR
	JAL	R4,SPACE		:HOW MUCH ROOM IS THERE?
	SIS	R0,3			:HOW BIG CAN IT BE?
	LHL	R1,IPORT		:HOW MANY CAN WE SEND FOR THIS PORT?
	LB	R7,XLIMIT,R1
	CR	R0,R7			:USE MINIMUM
	JGEFS	NORM			:SKIP IF MORE ROOM EXISTS THAN WE CAN USE
	LR	R7,R0			:ELSE SET NUMBER WE HAVE ROOM FOR
NORM	LR	R0,R1			:SEND MESSAGE, STARTING WITH PORT#
	JAL	R4,PUTH			:BUILD HEADER
	JAL	R4,PUTCH		:LEAVE ROOM FOR CODE
	LR	R0,R6			:RESTORE CHAR
	JFS	NORML1			:SKIP TO PUT CHARS THERE

NORML	LHL	R1,BUFNUM		:CHECK IF ANYTHING LEFT IN BUFFER
	LH	R0,BCT,R1
	JEFS	NORMT			:SKIP IF NOT
	JAL	R6,GETCHR		:ELSE GET NEXT CHARACTER
	JLBS	NORML			:TRY AGAIN IF WE GOT NOTHING
	JGFS	NORMT			:CONTROL...SKIP TO TERMINATE RECORD
NORML1	JAL	R4,PUTCH		:OK...PUT THIS CHAR AWAY
	SIS	R7,1			:COUNT ANOTHER CHAR IN PLACE
	JGBS	NORML			:REPEAT AS NECESSARY

NORMT	JAL	R4,ELODR		:TIME TO TERMINATE

	IF	ACCT
:	COUNT CHARS TO HOST
	LHL	R1,PORT			:GET PORT #
	TBT	R1,HPFLAG		:IS THIS A HOST PORT?
	JEFS	NORMT1			:NO, SKIP
	SLLS	R1,2			:4*PORT#
	AM	R0,AAIC,R1,		:INCR ACCT CHAR COUNT
NORMT1	EI	(ACCT)

	LR	R5,R5			:NOW TEST HOW WE TERMINATED
	JLER	R12			:EXIT IF WE RAN OUT OF DATA

:	HERE WITH SPECIAL MESSAGE...NUMBER OF CHARS IN R5, STRING IN R6
:	OR ALTERNATE CLUDGE...N IN R5, V IN R6, PACKED/BYTE
PISPC	CLHI	R5,0FF			:CHECK FOR CLUDGE
	JL	PISPCB			:NO...SKIP
PISPCA	LIS	R0,5			:YES...SET UP "SET TERMINAL PARAMETER N TO V"
	LHL	R1,IPORT
	LHI	R2,STPMSG
	JAL	R4,SLOR			:START-LOGICAL-OUTPUT-RECORD
	LBR	R0,R5;	JAL	R4,PUTCH		:N
	LBR	R0,R6;	JAL	R4,PUTCH		:V
	JAL	R4,ELOR			:END-LOGICAL-OUTPUT-RECORD
	SRLS	R5,8			:ANY MORE?
	JER	R12			:NO
	SRLS	R6,8
	J	PISPCA			:YES...DO NEXT ONE
PISPCB	CLHI	R5,1			:CHECK FOR 1-CHAR SPECIAL MESSAGE
	JN	PISPCG			:SKIP IF NOT
	CLHI	R6,ZAPMSG		:CHECK FOR ZAPPER
	JN	PISPCG			:SKIP IF NOT
	LHL	R2,PORT			:TEAR OUT CIRCUIT
	SBT	R2,ACKWAIT		:SET ACK-WAIT BIT

	IF	SAL
	TBT	R2,HPFLAG		:IS THIS A CIRCUIT ORIGINATING IN ISIS?

	IF	ACCT
	JEFS	PISPCC			:YES
	STH	R11,TEMP1		:SAVE R11
	LHL	R11,PORT		:GET PORT #
	LIS	R0,3			:INDICATE USER ZAP
	JAL	R4,AARLO		:TERMINATE ACCOUNTING
	LHI	R6,ZAPMSG		:RESTORE ZAPPER
	LHL	R11,TEMP1		:RESTORE R11
	J	PISPCF
PISPCC	HS	0
	ELSE	(1-ACCT)
	JN	PISPCF			:NO...SKIP
	EI	(1-ACCT)


	IF	1-PSGLAS
	LA	R3,NETGONE		:THEY ORIGINATED, SO SEND THEM "INTERLINK CANCELED"
	LHL	R2,IPORT		:GET ISIS PORT #
	JAL	R5,OCS
	IF	NETNAME
	LHL	R2,IPORT;	LA	R3,FROM;	JAL	R5,OCS			:"FROM "
	LHL	R2,IPORT;	LA	R3,PRIME;	JAL	R5,OCS			:"THEM"
	LHL	R2,IPORT;	LA	R3,TO  ;	JAL	R5,OCS			:" TO "
	LHL	R2,IPORT;	LA	R3,SECOND;	JAL	R5,OCS			:"US"
	EI	(NETNAME)
	EI	(1-PSGLAS)

	LHI	R6,DETMSG		:THEN DETACH IT
	EI	(SAL)
PISPCF	LIS	R5,1			:NOW DISCONNECT
PISPCG	HS	0

	LHI	R0,2,R5			:SET UP COUNT OF CHARS
	LHL	R1,IPORT		:ISIS PORT NUMBER
	LR	R2,R6			:MESSAGE TYPE
	JAL	R4,SLOR			:START LOGICAL OUTPUT RECORD
PISPC1	SIS	R5,1			:COUNT ONE CHAR GONE
	JLEFS	PISPC2			:SKIP IF DONE
	SRLS	R6,8
	LR	R0,R6			:GET NEXT CHAR
	JAL	R4,PUTCH		:SEND IT ON
	JBS	PISPC1			:AND REPEAT
PISPC2	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
	JR	R12			:THEN EXIT

:	* * * G E T   I N P U T   C H A R A C T E R * * *
:	LINK ON R6
:	RETURNS	CC < 0	ABNORMAL RETURN...NO GOOD DATA THERE THIS TIME
:		CC = 0, R5 = 0, THEN R0 = DATA CHARACTER
:		CC > 0, R5 = N, THEN R6 = BACKWARDS STRING OF LENGTH N
GETCHR	LHL	R1,BUFNUM
	JAL	R5,GCI			:GET THE NEXT CHARACTER
	CLHI	R0,7			:TEST FOR SPECIAL NETWORK CHARS
	JGFS	GCHN			:SKIP IF NORMAL
	SIS	R0,1			:ABNORMAL...CHECK IT OUT
	JGEFS	GCH			:SKIP IF NOT ESCAPED
	JAL	R5,GCI			:HERE WITH ESCAPED CHAR
GCHN	LIS	R5,0			:SET CONDITION CODES
	JR	R6			:AND RETURN WITH NORMAL DATA CHARACTER

GCH	JEFS	GCH1			:SKIP IF PREFIX
	LR	R1,R0			:COPY THE NETWORK CHAR
	LR	R4,R6			:COPY RETURN
	LB	R6,GETNT-1,R1		:GET CODE
	LIS	R5,1			:SET 1 CHARACTER
	JR	R4			:AND RETURN

GETNT	BC	GOBMSG			:2	NETWORK TRANSLATION
	BC	ZAPMSG			:3
	BC	LDMMSG			:4
	BC	GBMSG			:5
	BC	RBMSG			:6
	BC	EDMMSG			:7

:	PREFIX CODE...INTERPRET IT
GCH1	JAL	R5,GCI			:GET THE CHARACTER
	LR	R4,R6			:COPY RETURN
	LR	R1,R0			:EXTRACT 4-BIT TYPE
	SRHLS	R1,4			:MAKE WORD INDEX
	SLHLS	R1,2
	J	GETPT,R1		:GO TO APPROPRIATE PLACE

:	KLUDGE TO SET ECHO CONTROL, OLD STYLE
GETECO	LIS	R6,1			:EXTRACT INFO
	NR	R6,R0
	THI	R0,2
	JEFS	.+6
	OHI	R6,100
	EXHR	R6,R6			:SWAP
	THI	R0,4
	JEFS	.+6
	OHI	R6,1
	THI	R0,8
	JEFS	.+6
	OHI	R6,100
	LI	R5,02030001		:PASS 4 PARAMETERS
	JR	R4			:GO DO IT

:	KLUDGE FOR C/R DELAY,  INPUT BAUD RATE, OLD STYLE
GETIBR	LIS	R6,7			:SET UP MASK
	NR	R6,R0			:GET VALUE
	THI	R0,8
	JEFS	.+6
	OHI	R6,100			:SET BIT FOR C/R DELAY
	LHI	R5,405			:SEND ON INPUT BAUD RATE (LOW) AND CRDELAY (HIGH)
	JR	R4			:AND RETURN

GETPT	J	GETECO			:0	PREFIX SUBTYPE TABLE
	J	GETIBR			:1
	J	PREFER			:2
	J	GETCPF			:3	INPUT BAUD RATE
	J	GETCPF			:4	PARAMETER D
	J	GETCPF			:5	PARAMETER C
	J	GETCPF			:6	PARAMETER B
	J	GETCPF			:7	PARAMETER A
	J	GETCPF			:8	OUTPUT BAUD RATE
	J	GETCQF			:9	QUERY FIELD PARAMETER
	J	GETCQB			:A	QUERY BIT PARAMETER
	J	GETCQB			:B	QUERY BIT PARAMETER
	J	GETCPB			:C	BIT PARAMETERS
	J	GETCPB			:D	BIT PARAMETERS
	J	PREFER			:E
	J	GETC1F			:F	BALLS

:	PREFIX ERROR
PREFER	LCS	R5,1			:IGNOR
	JR	R4			:AND RETURN

:	QUERY FIELD PARAMETER
GETCQF	LIS	R6,0F			:SET MASK
	NR	R6,R0			:EXTRACT TYPE CODE
	LB	R6,TFF,R6		:TRANSLATE TO INTERNAL FIELD SUBTYPE
	JFS	GETCQC			:AND SKIP

:	QUERY BIT PARAMETER
GETCQB	SRHLS	R0,1			:JUSTIFY SUBTYPE
	LIS	R6,0F			:SET MASK
	NR	R6,R0			:EXTRACT SUBTYPE
	LB	R6,TFB,R6		:TRANSLATE TO INTERNAL BIT SUBTYPE

:	COMMON QUERY CODE
GETCQC	EXBR	R6,R6			:PACK BACKWARD
	CHVR	R6,R6			:CHECK FOR KNOWN PARAMETER
	JL	PREFER			:PREFIX ERROR IF NOT KNOWN
	OHI	R6,QTPMSG		:SET TERMINAL PARAMETER QUERY
	LIS	R5,2			:2 BYTES LONG
	JR	R4			:AND RETURN

:	SET FIELD PARAMETERS
GETCPF	SRHLS	R1,2			:RESTORE TYPE CODE
	LB	R1,TFF,R1		:GET TRANSLATION CODE
	LIS	R6,0F			:EXTRACT VALUE
	NR	R6,R0
	EXBR	R6,R6			:AND JUSTIFY IT
	JFS	GETCPC			:AND SKIP

:	SET BIT PARAMETER
GETCPB	LIS	R6,1			:EXTRACT VALUE
	NR	R6,R0
	EXBR	R6,R6
	SRHLS	R0,1			:JUSTIFY THE SUBTYPE
	LIS	R1,0F
	NR	R1,R0			:EXTRACT TYPE
	LB	R1,TFB,R1		:GET THE CODE
GETCPC	STBR	R1,R6			:PACK VALUE,MESSAGE BACKWARDS
	SLLS	R6,8
	OHI	R6,STPMSG		:SET TERMINAL PARAMETER
	LIS	R5,3			:SET 3 CHARACTERS
	JR	R4			:AND RETURN

TFF	BC	0			:INTERNAL FIELD SUBTYPES
	BC	0
	BC	0
	BC	5
	BC	$A 15
	BC	$A 11
	BC	$A 10
	BC	9
	BC	6
	BC	0FF,0FF,0FF,0FF,0FF,0FF,0FF

TFB	BC	0			:INTERNAL BIT SUBTYPES
	BC	1
	BC	3
	BC	2
	BC	8
	BC	7
	BC	0C
	BC	4
	BC	0D
	BC	0E
	BC	10
	BC	11
	BC	0FF,0FF,0FF,0FF

:	BALL LOGIC
GETC1F	LIS	R1,0F			:WHICH BALL?
	NR	R1,R0
	IF	SAL
	JNFS	GC1.F0			:SKIP IF NOT HANG CHARACTER
	LIS	R1,4			:ELSE ZAP THIS CIRCUIT
	XH	R1,BUFNUM
	JAL	R4,SPEED
	LIS	R0,3
	JAL	R5,WCI
	LR	R4,R6			:RE-COPY RETURN ADDRESS
	LIS	R5,1			:SET 1-CHAR SPECIAL MESSAGE
	LHI	R6,ZAPMSG
	JR	R4			:AND RETURN...HANG MAPPED INTO ZAPPER
GC1.F0	EI	(SAL)
	LB	R6,GETCBT,R1
	LR	R6,R6
	JE	PREFER			:NULL...IGNOR
	LIS	R5,1			:ELSE SET 1 CHAR MESSAGE
	JR	R4			:AND EXIT

:	BALL LOOKUP TABLE
GETCBT	BC	HNGMSG			:0	HANG CHARACTER
	BC	SHGMSG			:1	SUPER-HANG CHARACTER
	BC	ETMMSG			:2	ENTER TRANSPARENCY
	BC	LTMMSG			:3	LEAVE TRANSPARENCY
	BC	EAODM			:4	ENTER 'ALTERNATE OUTPUT DEVICE MODE'
	BC	LAODM			:5	LEAVE 'ALTERNATE OUTPUT DEVICE MODE'
	BC	0			:6
	BC	0			:7
	BC	0			:8
	BC	0			:9
	BC	BKEMSG			:A	BREAK END BALL
	BC	BKBMSG			:B	BREAK BEGIN BALL
	BC	GRYMSG			:C	GRAY BALL
	BC	BLKMSG			:D	BLACK BALL
	BC	OBMSG			:E	ORANGE BALL
	BC	YBMSG			:F	YELLOW BALL


	SUBTTL	ACCOUNTING

:	ARRAY INITIALIZATION
AAINIT	LIS	R0,0
	LHI	R1,AAASIZ-4		:SIZE OF ARRAY
AAI1	ST	R0,AAARY,R1,		:ZERO A WORD
	SIS	R1,4
	JGEBS	AAI1			:DO FOR ALL ELEMENTS
	JR	R2			:RETURN


	IF	ACCT

:	PERIODIC REPORT OF ACCOUNTING DATA
AATIME	AI	R1,$A RATE*60*20/NHPORT	:DO ALL PORTS EVERY 20 MIN
	JAL	R5,TOPUT

	LHL	R11,AACPN,,		:CURRENT PORT#
	SIS	R11,1			:DECR
	JGEFS	AATIM1
	LHI	R11,NHPORT-1		:WRAP PORT #
AATIM1	STH	R11,AACPN,,		:SAVE FOR NEXT TIME
	TBT	R11,ACP			:IS PORT ACTIVE?
	JEFS	AATIM2			:NO, JUST RETURN
	SLLS	R11,2			:4*PORT#
	JAL	R9,AAMIR		:SEND ACCT INVOICE RECORD
	L	R8,AAIC,R11,		:GET INPUT CHAR COUNT
	JAL	R9,AASAR		:SEND IT
	L	R8,AAOC,R11,		:GET OUTPUT CHAR COUNT
	JAL	R9,AASAR		:SEND IT
AATIM2	J	TORET			:RETURN



:	SESSION START ROUTINE
:	CALL	JAL	R4,AASTART
:	EXPECTS 'PORT' TO CONTAIN PORT#
AASTART	LHL	R1,PORT			:GET PORT#
	SLLS	R1,2			:4*PORT#
	LI	R0,80000000
	ST	R0,AAIC,R1,		:INIT INPUT COUNT AND CODE
	LI	R0,90000000
	ST	R0,AAOC,R1,		:INIT OUTPUT COUNT AND CODE
	JR	R4			:RETURN


:	MAKE ACCOUNTING INVOICE RECORD
:	CALL	JAL	R9,AAMIR
:	EXPECTS R11=4*PORT#
AAMIR	L	R8,AAINV,R11,		:GET INVOICE #
	CL	R8,AALINS,,		:COMPARE TO LAST INV# SENT
	JER	R9			:IF EQUAL, JUST RETURN
	ST	R8,AALINS,,		:SAVE FOR NEXT TIME
	OI	R8,70000000		:ADD MSG #


:	SEND AN ACCOUNTING RECORD
:	CALL	JAL	R9,AASAR
:	EXPECTS R8=ACCOUNTING WORD
AASAR	LHI	R6,7000			:SR1 TYPE 7 MSG
	EXHR	R7,R8			:PUT 1ST HW IN R7 (SR2)
	J	LEPSNU			:SEND RECORD TO SUP (RETURN LINK = R9)



:	RECEIVE LOGOUT NOTICE
:	CALL	JAL	R4,AARLO
:	EXPECTS R0 = REASON FOR LOGOUT
:		1 = HOST DOWN
:		2 = HOST ZAP
:		3 = USER ZAP
:		R11 = PORT #
AARLO	SLLS	R11,2			:4*PORT#
	SLLS	R0,$A 12
	AHM	R0,AAOC,R11,		:GENERATE THE TERMINATION CODE
	JAL	R9,AAMIR		:SEND AN ACCOUNTING INVOICE RECORD
	L	R8,AAIC,R11,		:GET INPUT CHAR COUNT
	JAL	R9,AASAR		:SEND IT
	L	R8,AAOC,R11,		:GET OUTPUT CHAR COUNT
	JAL	R9,AASAR		:SEND IT
	LIS	R9,0
	ST	R9,AAINV,R11,		:ZERO INVOICE #
	JR	R4			:RETURN


:	EXCHANGE INVOICE NUMBERS BETWEEN PRIMARY AND SECONDARY NETS
:	CALL	JAL	R10,AASWAP
:	EXPECTS R11 = 4*PORT#
:		AAPINV = PRIMARY NET INVOICE #
AASWAP	STM	R14,AASAVE,,		:SAVE SOME REGS
:	SEND DATA TO SECONDARY NET
	JAL	R9,AAMIR		:SEND INVOICE RECORD
	L	R8,AAPINV,,		:GET PRIMARY INVOICE#
	OI	R8,0E9000000		:ADD ACCT MSG TYPE
	JAL	R9,AASAR		:SEND ACCT RECORD
:	NOW SEND DATA TO PRIMARY NET
	L	R2,AAINV,R11,		:GET SECONDARY NET INVOICE#
	OI	R2,0E9000000		:ADD MSG TYPE
	ST	R2,AAMSG1,,		:STORE IN CANNED MSG
	SRLS	R11,2			:MAKE PORT#
	LB	R2,TXITBL,R11		:GET ISIS PORT#
	LA	R3,AAMSG,,		:ADDR OF CANNED MSG
	JAL	R5,OCM			:SEND MSG TO ISIS
	LM	R14,AASAVE,,		:RESTORE REGS
	JR	R10			:RETURN

	EI	(ACCT)

	SUBTTL	DISPATCHER RING UTILITIES

:		***********************************
:		***********************************
:		***********************************
:		***				***
:		***				***
:		***				***
:		***	UTILITY FUNCTIONS	***
:		***				***
:		***				***
:		***				***
:		***********************************
:		***********************************
:		***********************************

:	RING HANDLING ROUTINES

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R14	RING CHARACTER INDEX
:	R15	RING MAXIMUM

:	ALL ROUTINES LINK ON R4, UNLESS OTHERWISE NOTED

:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
LOOK	LHL	R14,ICEI,,		:GET CURRENT EMPTY INDEX
	CLH	R14,INFMI,,		:TEST IF CAUGHT UP
	JER	R4			:EMPTY...NORMAL RETURN
	LHI	R15,IRSIZE		:SET MAX INDEX
	AIS	R14,2			:BUMP POINTER PAST PORT #
	LB	R2,IRING,R14,		:GET MESSAGE TYPE
	LHL	R1,IRING-2,R14,		:AND PORT #
	J	4,R4			:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING,R14,		:GET THE CHAR
	AIS	R14,1			:BUMP INDEX
	CR	R14,R15			:TEST FOR FOLDING
	JLR	R4			:RETURN IF NOT
	LIS	R14,0			:ELSE FOLD IT
	JR	R4			:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING,R14,		:GET THE DATA
	AIS	R14,2			:BUMP INDEX
	CR	R14,R15			:TEST FOR FOLDING
	JLR	R4			:RETURN IF NOT
	LIS	R14,0			:ELSE FOLD IT
	JR	R4			:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING,R14,		:GET THE DATA
	AIS	R14,4			:BUMP INDEX
	CR	R14,R15			:TEST FOR FOLDING
	JLR	R4			:RETURN IF NOT
	LIS	R14,0			:ELSE FOLD IT
	JR	R4			:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0			:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3			:FORCE TO NEXT WORD
	NHI	R14,-4
	CR	R14,R15			:TEST FOR FOLDING
	JLFS	.+4			:NO
	SR	R14,R15			:YES
	STH	R14,ICEI,,
	JR	R4			:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3			:GET COUNT n
	AIS	R0,5			:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM			:INSURE THERE IS ROOM
	LR	R0,R2			:COPY PORT #
	JAL	R4,PUTH			:PLACE PORT NUMBER
	LB	R2,0,R3			:GET COUNT AGAIN
	J	OCS1			:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3			:GET COUNT n
	AIS	R0,6			:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM			:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH			:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2			:GET THE COUNT n
	JAL	R4,PUTCH		:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1			:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3			:GET THE NEXT CHARACTER
	JAL	R4,PUTCH		:PLACE IT INTO RING
	SIS	R2,1			:REDUCE COUNT
	JGBS	OCS1			:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR			:END LOGICAL OUTPUT RECORD
	JR	R5			:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4			:SET MASK
	LHL	R14,ONFMI,,
	LHI	R15,ORSIZE
	NH	R0,OCEI,,		:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R14			:SPACE BETWEEN US AND EMPTIER
	JGFS	.+4			:SKIP IF NO WRAP-AROUND
	AR	R0,R15			:ELSE CORRECT FOR WRAP
	SIS	R0,4			:CORRECT FOR POTENTIAL OVERFLOW
	JR	R4			:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R14,ONFMI,,
	LHI	R15,ORSIZE
ROOM1	LCS	R1,4			:SET MASK
	NH	R1,OCEI,,		:FORCE HIM TO WORD BOUNDARY
	SR	R1,R14			:CHECK RELATIVE POSITIONS
	JGFS	.+6			:SKIP IF HE'S AHEAD OF US
	JER	R4			:EQUAL...HE'S EMPTY...GO DO IT
	AR	R1,R15			:HE'S BEHIND US
	SIS	R1,4			:CORRECT FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4			:ROOM EXISTS...GO DO IT
	SVC	DISMISS
	JBS	ROOM1			:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, AND PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R14,ONFMI,,
	LHI	R15,ORSIZE
SLOR1	LCS	R3,4			:SET A MASK
	NH	R3,OCEI,,		:FORCE RECEIVER TO WORD BOUNDARY
	SR	R3,R14
	JGFS	.+4
	AR	R3,R15			:ACCOUNT FOR POSSIBLE RING FOLDING
	SIS	R3,4			:CORRECT FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR2			:SKIP IF WE CAN GO
	SVC	DISMISS
	JBS	SLOR1
SLOR2	STH	R1,ORING,R14,		:OK...PLACE MESSAGE
	STB	R2,ORING+2,R14,
	AIS	R14,3			:BUMP PAST THESE CHARACTERS
	JR	R4			:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING,R14,		:PLACE THE CHARACTER
	AIS	R14,1			:BUMP INDEX
	CR	R14,R15			:TEST IF NEED TO FOLD RING
	JLR	R4			:SKIP IF NOT
	LIS	R14,0			:ELSE WRAP AROUND
	JR	R4			:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING,R14,		:PLACE THE HALF-WORD
	AIS	R14,2			:BUMP INDEX
	CR	R14,R15			:TEST IF NEED TO FOLD RING
	JLR	R4			:EXIT IF NOT
	LIS	R14,0			:ELSE WRAP AROUND
	JR	R4			:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING,R14,		:PLACE THE WORD
	AIS	R14,4			:BUMP INDEX
	CR	R14,R15			:TEST IF NEED TO FOLD RING
	JLR	R4			:SKIP IF NOT
	LIS	R14,0			:ELSE WRAP AROUND
	JR	R4			:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,ONFMI,,		:GET START OF THIS MESSAGE
	LR	R0,R14			:COPY MESSAGE END
	SR	R0,R1			:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	.+4			:SKIP IF NO WRAP-AROUND
	AR	R0,R15			:ELSE CORRECT FOR WRAP
	SIS	R0,3			:MAKE ALLOWANCE FOR HEADER
	STB	R0,ORING+2,R1,		:INSET MESSAGE TYPE INTO MESSAGE
					:...AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R14,3
	NHI	R14,-4
	CR	R14,R15			:TEST FOR FOLDING
	JLFS	.+4
	LIS	R14,0			:FOLD IF NECESSARY
	STH	R14,ONFMI,,		:NOW ADVANCE THE POINTER TO NEXT MESSAGE
	JR	R4			:AND EXIT



	WS	0
S1SIZE	EQ	.-SEG1			:SIZE OF SEGMENT 1

	IF	SAL

	SEG	2			:BUFFERLETS IN SEGMENT 2
SEG2	HS	0
BLAREA	HS	0			:BFLET AREA
	ORG	((.+CBSZ-3)/CBSZ)*CBSZ+2	:START BUFERS ON 2MOD10 HEX ADDR
BUFERS	HS	CBSZ*NBFLET/2		:BUFFERS UP TO ENDBFL
ENDBFL	HS	0
BLSIZE	EQ	ENDBFL-BUFERS		:THE SIZE OF THE BUFFER SPACE

:	DISPATCHER COMMUNICATIONS AREA
AORING	HS	0
ONFMI	HS	1			:OUTPUT...NEXT FILL MESSAGE INDEX
OCEI	HS	1			:OUTPUT...CURRENT EMPTY INDEX
ORING	BS	ORSIZE			:THE OUTPUT RING

AIRING	HS	0			:THE INPUT RING
INFMI	HS	1			:INPUT...NEXT FILL MESSAGE INDEX
ICEI	HS	1			:INPUT...CURRENT EMPTY INDEX
IRING	BS	IRSIZE			:THE INPUT RING
	IF	PERMEA
	SUBTTL	PERFORMANCE MONITORING DATA

:	F.TABL - FORMATTED PERFORMANCE DATA. THIS TABLE IS INDEXED BY TIME
:	(F.TIDX), AND CONTAINS THE PERFORMANCE DATA IN THE FORMAT THAT THE
:	HOST PROGRAM SEES IT. 
	WS	0			:FORCE TO WORD BOUNDARY
BIAS	EQ	0			:BIAS FOR LABELS, TO PUT THEM INTO SEG 2
F.TABL	EQ	.-BIAS
	HC	3232			:SYNC, SYNC SO HOST KNOWS HE'S GOT RIGHT DATA
	HC	F.SIZE			:SIZE OF ENTIRE TABLE
	HC	MACHNM			:NODE NUMBER
	HC	NC.VER			:USEFUL FOR HOST AS FIELD FORMATS VARY
	HC	NM			:LET HOST PROGRAM FIGURE OUT INDEXING
	HC	-1^(10-NUMSAT)		:BIT ARRAY TO IDENTIFY SATELLITE LINES
	HC	S0SIZE/400		:AMOUNT OF MEMORY THIS SYSTEM (IN KILOBYTES)
	HC	F.TBSZ			:SIZE OF EACH TIME SLOT (IN BYTES)
	HC	P.TIMS			:NUMBER OF SECONDS IN TIME SLOT
	HC	P.NSLT			:NUMBER OF TIME SLOTS
	HC	F.HDSZ			:SIZE OF HEADER (IN BYTES)
F.TIDX	EQ	.-BIAS;	HC	0			:TIME INDEX. UPDATED EACH P.TIMS INTERVAL;
F.TCCT	EQ	.-BIAS;	HC	0			:CRASH COUNT (INCREMENTED IN CRASH);
F.TPSD	EQ	.-BIAS;	HC	-1,-1,0,0		:CRASH PSD;
CFROM	EQ	.-BIAS;	HC	-1,-1			:WHERE CRASH WAS CALLED FROM;
CRREG	EQ	.-BIAS;	WS	10			:CRASH REGISTER SAVE AREA;
:	ACTUAL PERFORMANCE DATA FOLLOWS
	WS	0			:FORCE TO WORD BOUNDARY
F.PDTA	EQ	.-BIAS
F.HDSZ	EQ	F.PDTA-F.TABL		:SIZE OF F.TABL HEADER

F.CHNI	EQ	.-BIAS;	WS	NM			:NORMAL CHARACTERS INPUT;
F.CHSI	EQ	.-BIAS;	WS	NM			:SUPERVISOR CHARACTERS INPUT;
F.CHNO	EQ	.-BIAS;	WS	NM			:NORMAL CHARACTERS OUTPUT;
F.CHSO	EQ	.-BIAS;	WS	NM			:SUPERVISOR CHARACTERS OUTPUT;
F.PKSM	EQ	.-BIAS;	WS	NM			:SIZE OF PACKETS MADE;
F.PKSR	EQ	.-BIAS;	WS	NM			:SIZE OF PACKETS RECEIVED;
F.PKTT	EQ	.-BIAS;	HS	NM			:NUMBER OF PACKETS MADE;
F.PKRC	EQ	.-BIAS;	HS	NM			:NUMBER OF PACKETS RECEIVED;
F.LRNR	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS RECEIVED;
F.LRNS	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS SENT;
F.LRRS	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS RESTRICTED BY PACKET SIZE;
F.BPNS	EQ	.-BIAS;	HS	NM			:NUMBER OF BACKPRESSURE RECORDS SENT;
F.BPNR	EQ	.-BIAS;	HS	NM			:NUMBER OF BACKPRESSURE RECORDS RECEIVED;
F.LOVH	EQ	.-BIAS;	HS	NM			:NUMBER OF 1/2 SECOND LINE OVERLOAD OCCURRENCES;
F.LNER	EQ	.-BIAS;	HS	NM			:NUMBER OF LINE ERRORS;
F.XCTR	EQ	.-BIAS;	HS	2			:NUMBER OF TIMES THROUGH EXEC LOOP (F/W COUNT);
F.NOVL	EQ	.-BIAS;	HS	20			:COUNT OF NODE OVERLOAD OCCURRENCES. EACH HALFWORD
					: IS A COUNTER FOR THE RELATIVE NUMBER OF
					: SECONDS WHICH CLOCK DRIFTED
					: DURING 4-MINUTE PERIOD.;
F.RETK	EQ	.-BIAS;	HS	1			:NUMBER OF RETAKES OF THIS NODE;
F.ASYI	EQ	.-BIAS;	HS	2			:NUMBER OF ASYNC CHARACTERS INPUT (F/W COUNT);
F.ASYO	EQ	.-BIAS;	HS	2			:NUMBER OF ASYNC CHARACTERS OUTPUT (F/W COUNT);
F.PORT	EQ	.-BIAS;	HS	2			:NUMBER OF PORTS, COUNTED EACH SECOND;
F.PTHR	EQ	.-BIAS;	HS	2			:NUMBER OF PASSTHROUGHHS, COUNTED EACH SECOND;
F.SECC	EQ	.-BIAS;	HS	2			:NUMBER OF COUNTING OCCURRENCES OF F.PORT, F.PTHR FOR
					: HOST PROGRAM TO COMPUTE AVERAGES OF EACH.;
F.RMPW	EQ	.-BIAS;	HS	1			:NUMBER OF BF'S CLEARED DUE TO NULL PERMUTER
					: TABLE ENTRY FOUND IN RMAKE.;
F.PTUN	EQ	.-BIAS;	HS	1			:NUMBER OF NON-NULL PERMUTER TABLE ENTRIES USED;
F.BFUN	EQ	.-BIAS;	HS	1			:NUMBER OF LEP2 REJECTS DUE TO NON-ZERO BF;
F.LEPR	EQ	.-BIAS;	HS	1			:TOTAL NUMBER OF LEP MESSAGES REJECTED;

F.TBSZ	EQ	.-BIAS-F.PDTA		:TIME SLOT SIZE
:	ALLOCATE STORAGE FOR REMAINING TIME SLOTS
	BS	(P.NSLT-1)*F.TBSZ
	WS	0			:FORCE TO WORD BOUNDARY
F.TBND	EQ	.-BIAS;
F.DTAS	EQ	.-BIAS-F.PDTA		:SIZE OF DATA AREA
F.SIZE	EQ	.-BIAS-F.TABL		:SIZE OF ENTIRE TABLE
	EI	(PERMEA)
	WS	0
S2SIZE	EQ	.-SEG2			:THE SIZE OF THE SEGMENT

	IF	CRSAVE
:	CRASH SAVE AREAS FOR SEGS 0,2,3

	IF	SAL
	SEG	7
	ELSE	(1-SAL)
	BND	100
	EI	(1-SAL)
SEG7	EQ	70000
	BS	S0SIZE
S7SIZE	EQ	S0SIZE

	IF	SAL
	SEG	8
	ELSE	(1-SAL)
	BND	100
	EI	(1-SAL)
SEG8	EQ	80000
	BS	S2SIZE
S8SIZE	EQ	S2SIZE

	IF	1-SAL
	BND	100
SEG9	EQ	90000
	BS	S3SIZE
S9SIZE	EQ	S3SIZE
	EI	(1-SAL)

	EI	(CRSAVE)


	REMARK	%.............................................
	REMARK	%%%%	***  ISIS-II  ***
	IF	PSGLAS+SPGLAS
	REMARK	%ISIS-II/TYMNET-I TRANSPARENT GATEWAY
	ELSE
	REMARK	%    ISIS-II/TYMNET-I GATEWAY
	EI	:PSGLAS+SPGLAS
	IF	PERMEA
	REMARK	%	PERFORMANCE MONITORING ENABLED!!
	REMARK	%	==================================
	EI	(PERMEA)
	REMARK	%	Version 
	NUMBER	$8 (NC.VER/100)
	REMARK	.
	NUMBER	$8 (NC.VER&77)
	REMARK	%	SLOT host is 
	NUMBER	$A HST0
	REMARK	%	NODE host is 
	NUMBER	$A HST1
	REMARK	%    node 
	NUMBER	$8 (MACHNM)
	REMARK	 has 
	NUMBER	$A NLINES
	REMARK	 sync line
	IF	ESYNC
	REMARK	%    enhanced sync microcode
	EI
	REMARK	%%	Configuration:
Q	EQ	0
	RE	NLINES
	REMARK	%link 
	NUMBER	$A Q
	REMARK	  neighbor 
QQ	EQ	$A NEIG|Q|
	NUMBER	$8 QQ
	REMARK	, 
	NUMBER	$A NGRP|Q|
	REMARK	 group
	IF	(NUMSAT-Q);	REMARK	, --WS8--;	EI
Q	EQ	Q+1
	ER

:	GENERATE DIAGNOSTICS
	REMARK	%
Q	EQ	0
	RE	3
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|-(Q*10000)
	REMARK	%"SEG 
	NUMBER	Q
	REMARK	" has been redefined%
	EI
	ER

:	BITCH IF ANY AREAS OVERFLOW
Q	EQ	0;	RE	3;	IF	S|Q|SIZE-10000;	REMARK	%Area 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	S|Q|SIZE-10000 $A;	REMARK	d bytes;	EI
Q	EQ	Q+1;	ER

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
	RE	$A 10
	IF	\S|Q|SIZE
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	 - length 
	NUMBER	$A S|Q|SIZE
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE!0FF)+1;	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI	(S|Q|SIZE)
	EI	(\S|Q|SIZE)
Q	EQ	Q+1
	ER
:	ALSO INCLUDE SEGMENT 0E'S INFORMATION
	REMARK	%SEGMENT 0E- length 
	NUMBER	$A CTASIZ
	REMARK	d, requires 
	NUMBER	CTASIZ
QQ	EQ	QQ+CTASIZ
	REMARK	x bytes of core.

:	GIVE FINAL SIZES
	REMARK	%%
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core%

	REMARK	%%.............................................%

	UN
	ELSE	(1-SAL)



S2AREA	BND	100			:FORCE TO A NEW PAGE
SEG2	EQ	20000

:	NOW DEFINE THE BUFFERLET AREA
BLAREA	WS	0
BUFERS	EQ	20002			:BUFFERLETS GO INTO MAC SEGMENT 2
	HS	CBSZ*NBFLET/2		:THE SPACE FOR BUFFERLETS
BLSIZE	EQ	.-BLAREA		:THE SIZE OF THE BUFFERLET AREA
ENDBFL	EQ	BLSIZE+BUFERS
	IF	PERMEA
	SUBTTL	PERFORMANCE MONITORING DATA

:	F.TABL - FORMATTED PERFORMANCE DATA. THIS TABLE IS INDEXED BY TIME
:	(F.TIDX), AND CONTAINS THE PERFORMANCE DATA IN THE FORMAT THAT THE
:	HOST PROGRAM SEES IT. 
	WS	0			:FORCE TO WORD BOUNDARY
BIAS	EQ	BLAREA-20000		:BIAS FOR LABELS, TO PUT THEM INTO SEG 2
F.TABL	EQ	.-BIAS
	HC	3232			:SYNC, SYNC SO HOST KNOWS HE'S GOT RIGHT DATA
	HC	F.SIZE			:SIZE OF ENTIRE TABLE
	HC	MACHNM			:NODE NUMBER
	HC	NC.VER			:USEFUL FOR HOST AS FIELD FORMATS VARY
	HC	NM			:LET HOST PROGRAM FIGURE OUT INDEXING
	HC	-1^(10-NUMSAT)		:BIT ARRAY TO IDENTIFY SATELLITE LINES
	HC	S0SIZE/400		:AMOUNT OF MEMORY THIS SYSTEM (IN KILOBYTES)
	HC	F.TBSZ			:SIZE OF EACH TIME SLOT (IN BYTES)
	HC	P.TIMS			:NUMBER OF SECONDS IN TIME SLOT
	HC	P.NSLT			:NUMBER OF TIME SLOTS
	HC	F.HDSZ			:SIZE OF HEADER (IN BYTES)
F.TIDX	EQ	.-BIAS;	HC	0			:TIME INDEX. UPDATED EACH P.TIMS INTERVAL;
F.TCCT	EQ	.-BIAS;	HC	0			:CRASH COUNT (INCREMENTED IN CRASH);
F.TPSD	EQ	.-BIAS;	HC	-1,-1			:CRASH PSD;
CPOINT	EQ	.-BIAS;	HC	0,0			:PSD ADDRESS...STORED INTO FROM CRASH;
CFROM	EQ	.-BIAS;	HC	-1,-1			:WHERE CRASH WAS CALLED FROM;
CRREG	EQ	.-BIAS;	WS	10			:CRASH REGISTER SAVE AREA;
:	ACTUAL PERFORMANCE DATA FOLLOWS
	WS	0			:FORCE TO WORD BOUNDARY
F.PDTA	EQ	.-BIAS
F.HDSZ	EQ	F.PDTA-F.TABL		:SIZE OF F.TABL HEADER

F.CHNI	EQ	.-BIAS;	WS	NM			:NORMAL CHARACTERS INPUT;
F.CHSI	EQ	.-BIAS;	WS	NM			:SUPERVISOR CHARACTERS INPUT;
F.CHNO	EQ	.-BIAS;	WS	NM			:NORMAL CHARACTERS OUTPUT;
F.CHSO	EQ	.-BIAS;	WS	NM			:SUPERVISOR CHARACTERS OUTPUT;
F.PKSM	EQ	.-BIAS;	WS	NM			:SIZE OF PACKETS MADE;
F.PKSR	EQ	.-BIAS;	WS	NM			:SIZE OF PACKETS RECEIVED;
F.PKTT	EQ	.-BIAS;	HS	NM			:NUMBER OF PACKETS MADE;
F.PKRC	EQ	.-BIAS;	HS	NM			:NUMBER OF PACKETS RECEIVED;
F.LRNR	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS RECEIVED;
F.LRNS	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS SENT;
F.LRRS	EQ	.-BIAS;	HS	NM			:NUMBER OF LOGICAL RECORDS RESTRICTED BY PACKET SIZE;
F.BPNS	EQ	.-BIAS;	HS	NM			:NUMBER OF BACKPRESSURE RECORDS SENT;
F.BPNR	EQ	.-BIAS;	HS	NM			:NUMBER OF BACKPRESSURE RECORDS RECEIVED;
F.LOVH	EQ	.-BIAS;	HS	NM			:NUMBER OF 1/2 SECOND LINE OVERLOAD OCCURRENCES;
F.LNER	EQ	.-BIAS;	HS	NM			:NUMBER OF LINE ERRORS;
F.XCTR	EQ	.-BIAS;	HS	2			:NUMBER OF TIMES THROUGH EXEC LOOP (F/W COUNT);
F.NOVL	EQ	.-BIAS;	HS	20			:COUNT OF NODE OVERLOAD OCCURRENCES. EACH HALFWORD
					: IS A COUNTER FOR THE RELATIVE NUMBER OF
					: SECONDS WHICH CLOCK DRIFTED
					: DURING 4-MINUTE PERIOD.;
F.RETK	EQ	.-BIAS;	HS	1			:NUMBER OF RETAKES OF THIS NODE;
F.ASYI	EQ	.-BIAS;	HS	2			:NUMBER OF ASYNC CHARACTERS INPUT (F/W COUNT);
F.ASYO	EQ	.-BIAS;	HS	2			:NUMBER OF ASYNC CHARACTERS OUTPUT (F/W COUNT);
F.PORT	EQ	.-BIAS;	HS	2			:NUMBER OF PORTS, COUNTED EACH SECOND;
F.PTHR	EQ	.-BIAS;	HS	2			:NUMBER OF PASSTHROUGHHS, COUNTED EACH SECOND;
F.SECC	EQ	.-BIAS;	HS	2			:NUMBER OF COUNTING OCCURRENCES OF F.PORT, F.PTHR FOR
					: HOST PROGRAM TO COMPUTE AVERAGES OF EACH.;
F.RMPW	EQ	.-BIAS;	HS	1			:NUMBER OF BF'S CLEARED DUE TO NULL PERMUTER
					: TABLE ENTRY FOUND IN RMAKE.;
F.PTUN	EQ	.-BIAS;	HS	1			:NUMBER OF NON-NULL PERMUTER TABLE ENTRIES USED;
F.BFUN	EQ	.-BIAS;	HS	1			:NUMBER OF LEP2 REJECTS DUE TO NON-ZERO BF;
F.LEPR	EQ	.-BIAS;	HS	1			:TOTAL NUMBER OF LEP MESSAGES REJECTED;

F.TBSZ	EQ	.-BIAS-F.PDTA		:TIME SLOT SIZE
:	ALLOCATE STORAGE FOR REMAINING TIME SLOTS
	BS	(P.NSLT-1)*F.TBSZ
	WS	0			:FORCE TO WORD BOUNDARY
F.TBND	EQ	.-BIAS;
F.DTAS	EQ	.-BIAS-F.PDTA		:SIZE OF DATA AREA
F.SIZE	EQ	.-BIAS-F.TABL		:SIZE OF ENTIRE TABLE
	EI	(PERMEA)
	WS	0
S2SIZE	EQ	.-S2AREA		:SIZE OF SEGMENT 2



S3AREA	BND	100			:FORCE TO A NEW PAGE BOUNDARY
SEG3	EQ	30000
RNGAREA	EQ	.
Q	EQ	30000-.

ONFMI	EQ	.+Q;	HS	1			:OUTPUT...NEXT FILL MESSAGE INDEX
AORING	EQ	ONFMI
OCEI	EQ	.+Q;	HS	1			:OUTPUT...CURRENT EMPTY INDEX
ORING	EQ	.+Q;	BS	ORSIZE			:

:	THE DISPATCHER INPUT RING
INFMI	EQ	.+Q;	HS	1			:INPUT...NEXT FILL MESSAGE INDEX
AIRING	EQ	INFMI
ICEI	EQ	.+Q;	HS	1			:INPUT...CURRENT EMPTY INDEX
IRING	EQ	.+Q;	BS	IRSIZE			:

	WS	0
S3SIZE	EQ	.-S3AREA		:SIZE OF SEGMENT 3


	IF	SUP
:	SUP COMMUNICATIONS AREA DEFINITIONS
SUPAREA	BND	100			:INSURE WE'RE ON A PAGE BOUNDARY
SUPBASE	EQ	50000			:BASE ADDRESS OF SUP AREA (WHAT WE'LL BE RELATIVE TO)
Q	EQ	SUPAREA
NS	EQ	100			:NUMBER OF SUP RECORDS IN EACH SUP BFR
:	SUP INPUT
SIB1	EQ	.-Q;	HS	NS			:SR1
SIB2	EQ	.-Q;	HS	NS			:SR2
SIB3	EQ	.-Q;	HS	NS			:SR3
:	SUP OUTPUT
SOB1	EQ	.-Q;	HS	NS			:SR1
SOB2	EQ	.-Q;	HS	NS			:SR2
SOB3	EQ	.-Q;	HS	NS			:SR3
NISI	EQ	.-Q;	HS	1			:NEXT IN POINTER FOR SUP INPUT
NOSI	EQ	.-Q;	HS	1			:NEXT OUT POINTER FOR SUP INPUT
NISO	EQ	.-Q;	HS	1			:NEXT IN POINTER FOR SUP OUTPUT
NOSO	EQ	.-Q;	HS	1			:NEXT OUT POINTER FOR SUP OUTPUT
SLEEP	EQ	.-Q+SUPBASE;	HS	1			:PLACE TO PLOP SLEEPING PILLS

SUPSIZE	EQ	.-SUPAREA		:SIZE OF MAC SEGMENT
SCMAC	EQ	MACVAL(SUPSIZE,SUPAREA,8)!80000000	:COMMON AREA
:	END OF SUP COMMUNICATIONS AREA


:	ALSO DEFINE TWO CELLS FOR SUP-NODE COMMON AREA #1
SUPSTAT	EQ	6001C			:THE CURRENT SUPERVISOR STATE (HALFWORD)
NODECR	EQ	60030			:SET WHEN NODE CODE CRASHES
	ELSE
	GL	SCMAC
SCMAC	EQ	0			:NO SUPERVISOR COMMUNICATIONS SEGMENT
	EI	(SUP)

	IF	CRSAVE
:	CRASH SAVE AREAS FOR SEGS 0,2,3

	IF	SAL
	SEG	7
	ELSE	(1-SAL)
	BND	100
	EI	(1-SAL)
SEG7	EQ	70000
	BS	S0SIZE
S7SIZE	EQ	S0SIZE

	IF	SAL
	SEG	8
	ELSE	(1-SAL)
	BND	100
	EI	(1-SAL)
SEG8	EQ	80000
	BS	S2SIZE
S8SIZE	EQ	S2SIZE

	IF	1-SAL
	BND	100
SEG9	EQ	90000
	BS	S3SIZE
S9SIZE	EQ	S3SIZE
	EI	(1-SAL)

	EI	(CRSAVE)

NODSIZ	EQ	.-NCTA			:SIZE OF NODE SPACE
	EM

	IF	MICRO
	LO	CLOCKS
	BND	100			:START OF ENHANCED-MICROCODE RING STORAGE
AS.CTL	BS	A.CSIZ			:CONTROL STORAGE
AS.LCT	BS	A.LSIZ			:TIMEOUT STORAGE
AS.RNG	BS	AS.SIZ			:RING STORAGE
AS.ERN	BS	0			:END-OF-RING STORAGE
	FO	CLOCKS
	EI	(MICRO)

S1MAC	BND	100			:START OF SLOT 1 MAC AREA...
					:  FORCE TO PAGE BOUNDARY
	IF	SUP

S1.CMN	EQ	S1MAC+QSC1M0!80000000	:SUP COMMON AREA 1
SN.CMN	EQ	S1.CMN			:NODE CODE'S SUP COMMON AREA 1

:	DEFINE LOCATION TO PLACE WWVB TIME FOR SUPERVISOR
S.TIME	EQ	S.COMN+S1MAC		:CURRENT TIME, DERIVED FROM WWVB (WORD)
	EI	(SUP)

	EI	(SAL)

	REMARK	%  
	NUMBER	$A NBFLET
	REMARK	d bufferlets allocated to node code

	UN

IEND	END
    M