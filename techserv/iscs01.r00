	TITLE	CONsolidated tymSAT		
	SUBTTL	VERIFY UNIVERSAL CONFIGURATION PARAMETERS -- 


:    ***   ***  *   *  ****  ***  *     ***** ****    *   ***** ***** ****
:   *   * *   * **  * *     *   * *       *   *   *  * *    *   *     *   *
:   *     *   * * * *  ***  *   * *       *   *   * *****   *   ****  *   *
:   *   * *   * *  **     * *   * *       *   *   * *   *   *   *     *   *
:    ***   ***  *   * ****   ***  ***** ***** ****  *   *   *   ***** ****


:                     ***** *   * *   *  ****   *   *****
:                       *    * *  ** ** *      * *    *
:                       *     *   * * *  ***  *****   *
:                       *     *   *   *     * *   *   *
:                       *     *   *   * ****  *   *   *


:   *   * ***** ****  ***** ***** *****  ***    *   ***** *****  ***  *   *
:   *   * *     *   *   *   *       *   *   *  * *    *     *   *   * **  *
:   *   * ****  ****    *   ****    *   *     *****   *     *   *   * * * *
:    * *  *     *  *    *   *       *   *   * *   *   *     *   *   * *  **
:     *   ***** *   * ***** *     *****  ***  *   *   *   *****  ***  *   *



:	=================================================================
:	|	This code is the sole property and confidential		|
:	|	information of TYMSHARE,  INC.,  and may not be		|
:	|	copied in whole or  in part or disclosed to any		|
:	|	third party without  the  prior written consent		|
:	|	of TYMSHARE.						|
:	=================================================================

:	This file is assembled after the users 'COM' file to define
:	TYMSAT related symbols dependent on the 'COM' file parameters.
:	This eliminates the need for the user to include these values
:	and calculations in the 'COM' file.


:	If necessary, generate default text message
	 IF	1-\TIDMX
	LTEXT(TIDM,please type your terminal identifier)
	 EI	:TIDMX


:	Declare some global values
	GLOBAL(CPS,0)
	GLOBAL(NGRP,(NPORT+1F)/20*2)	:Number of groups
					:(insure even for word addressing)
	GLOBAL(NAGRP,(NAPORT+0F)/10)	:Number of ASYNC groups
	GLOBAL(NSGRP,(NSPORT+0F)/10)	:Number of SIO groups
	GLOBAL(NHNGBK,0)		:No Hang on break
	GLOBAL(CONFIG,1)		:simple configuration report


:	Verify that ACHOST was specified.
	 IF	\.AHOST
	GL	.AHOST
	 ELSE
	ERROR(ACHOST never invoked -- this MUST be declared,0)
	 EI	:\.AHOST


:	Check out printer/ASYNC relationship
	 IF	NUMPRN-NAPORT
	ERROR(NUMPRN exceeds NAPORT - reducing to equal,0)
NUMPRN	EQ	NAPORT
	 EI	:NUMPRN-NAPORT
	SUBTTL	VERIFY UNIVERSAL CONFIGURATION PARAMETERS -- PVC PARAMETERS

	IF	PVC			:Don't do it if no PVC's

:	See if configuration contains substitute text for PVC messages.
:	If not, define using default text.
	 IF	1-\PVCMX1
	PTEXT(1,circuit building in progress)
	 EI	:1-\PVCMX1

	 IF	1-\PVCMX2
	PTEXT(2,circuit lost - rebuilding)
	 EI	:1-\PVCMX2

	 IF	1-\PVCMX3
	PTEXT(3,ALO user name configuration error)
	 EI	:1-\PVCMX3

	 IF	1-\PVCMX4
	PTEXT(4,ALO password configuration error)
	 EI	:1-\PVCMX4

	 IF	1-\PVCMX5
	PTEXT(5,ALO login string configuration error)
	 EI	:1-\PVCMX5

	 IF	NAPORT

:	Declare all ASYNC PVC ports to default PVCDEF

QQ	  EQ	1			:Bitch-flag
Q	  EQ	0			:port number
	  RE	NAPORT
	   IF	.BIT.(PVCG,Q)
	    IF	1-\PVCX|Q|
	     IF	1-\PVCDEF
	      IF QQ
	       ERROR(PVCDF never defined and PVCEX not specified,0)
	       ERRLIN(for ASYNC ports -,0)
QQ	       EQ 0
	      EI
	      .R1BIT(PVCX,Q)
	      REMARK  
	      NUMBER $A Q
	     ELSE
	      DEFAULT(PVCX|Q|,PVCDEF)
	     EI	:1-\PVCDEF
	    EI	:1-\PVCX|Q|
	   EI	:.BIT.
Q	   EQ	Q+1
	  ER

	  IF	1-QQ
	   ERREND( - Canceling PVC for these ports,0)
	  EI	:1-QQ
	 EI	:NAPORT

	 IF	NSPORT

:	Verify that all SIO PVC ports have SPVCEX declared

QQ	  EQ	1			:Bitch-flag
Q	  EQ	.SPORT			:port number
	  RE	NSPORT
	   IF	.BIT.(PVCG,Q)
	    IF	1-\PVCX|Q|
	     IF	QQ
	      ERROR(SPVCEX never declared for SIO ports -,1)
QQ	      EQ	0
	     EI	:QQ
	     .R1BIT(PVCG,Q)
	     REMARK   
	     NUMBER $A Q-.SPORT
	    EI	:1-\PVCX|Q|
	   EI	:.BIT.(PVCG,Q)
Q	   EQ	Q+1
	  ER

	  IF	1-QQ
	   ERREND( - Canceling PVC for these ports,0)
	  EI	:1-QQ
	 EI	:NSPORT


:	Examine PVC ports for special options

:	MACRO	T.OPT(N,OPT)	- Set OPT true if TID match on N.
T.OPT	MACRO(N,OPT) [
	IF	1-(((N^TS)%PVCX|Q|)&TSMASK)
OPT	 EQ	OPT+1
	 GL	OPT
	EI
]

:	MACRO	T.FLAG(N,BIT)	- Set BIT(Q) true if TID match on N.
T.FLAG	MACRO(N,BIT) [
	IF	1-(((N^TS)%PVCX|Q|)&TSMASK)
	 .S1BIT(BIT,Q)
	EI
]

Q	 EQ	0			:port number
	 RE	NPORT
	  IF	.BIT.(PVCG,Q)
	   GL	PVCX|Q|
	   IF	NONPI&PVCX|Q|
	    .S1BIT(.NPI,Q)
	   EI	:NONPI&PVCX|Q|
	   T.OPT(TIDSIO+19,BAUDY)
	   T.OPT(TIDSIO+1A,BAUDY)
	   T.OPT(1B,LISA)
	   T.FLAG(1B,.LSA)
	   T.OPT(1C,LISA)
	   T.FLAG(1C,.LSA)
	  EI	:.BIT.(PVCG,Q)
Q	  EQ	Q+1
	 ER

	 KILL	T.OPT,T.FLAG		:won't need these any more



	 IF	NMPVC			:Can't do it if not defined

:	Verify that all MPVC ports have MPVCUS declared.
Q	  EQ	0
	  RE	NMPVC
	   IF	.BIT.(.MPMU,Q)
	    ERROR(MPVCUS not invoked for MPVC port ,1)
	    NUMBER $A Q
	    ERREND
	   EI	:.BIT.(.MPMU,Q)
Q	   EQ	Q+1
	  ER

:	Verify that all MPVC ports have MPVCFO declared.
Q	  EQ	0
	  RE	NMPVC
	   IF	.BIT.(.MPMF,Q)
	    ERROR(MPVCFO not invoked for MPVC port ,1)
	    NUMBER $A Q
	    ERREND
	   EI	:.BIT.(.MPMF,Q)
Q	   EQ	Q+1
	  ER

	 EI	:NMPVC

	EI	:PVC


:	Next, "kill" macros and symbols no longer needed:
	KILL	BITCH,.SETNM
	KILL	TID1,TID2,TID3,TID4,TID5,TID6,TID7,TID8,TID9,TID10
	KILL	TID11,TID12,TID13,TID14,TID15,TID16,TID17,TID18,TID19,TID20
	KILL	TID21,TID22,TID23,TID24,TID25,TID26,TID27,TID28,TID29,TID30
	KILL	NPI,SLO,PAR,PCO,HNG,HDX,CRLF
	KILL	NONPI,NOAID,NOALO,NOSLO,NOPAR,NOPCO,NOHNG,NOHDX,NOCRLF
	KILL	AID,ALO
	KILL	LFCR,TRS,RBP,TXT,DSC,MPC
	KILL	NOLFCR,NOTRS,NORBP,NOTXT,NODSC,NOMPC
	KILL	.PVRNG,PVCRNG,SPVRNG
	KILL	.PVCDF,PVCDF
	KILL	.PXRNG,PVCEX,SPVCEX
	KILL	.UTRNG,UTXRNG,SUTXRG,MUTXRG
	KILL	MPVCUS,MPVCFO
	KILL	.SPRNG,.RPRNG,TID120,HD202,NOBUSY
	KILL	.SSPRG,SBAUDO
	KILL	ACHOST,.AHRNG,AHRNG,SHRNG,MHRNG
	KILL	ACCODE,.ACODE,.ACRNG,ACRNG,SCRNG,MCRNG
	TITLE	ISIS CONFIGURATION PARAMETERS -- 
	SUBTTL	PARAMETERS

:			*****  **** *****  ****
:			  *   *       *   *
:			  *    ***    *    ***
:			  *       *   *       *
:			***** ****  ***** ****

:	****    *   ****    *   *   * ***** ***** ***** ****   ****
:	*   *  * *  *   *  * *  ** ** *       *   *     *   * *
:	****  ***** ****  ***** * * * ****    *   ****  ****   ***
:	*     *   * *  *  *   * *   * *       *   *     *  *      *
:	*     *   * *   * *   * *   * *****   *   ***** *   * ****

:       This file is assembled after the 'VERIFY' file to define
:       ISIS related symbols dependent on the 'COM' file parameters.

	GL	SPACE,PUTCH,PUTH,PUTW,SLOR,ELOR

VERSION	EQ	$A 1			:Version Number
REVLEV	EQ	$A 0			:Revision Level
FTLVL	EQ	$A 0			:Field-Test Level

:	Declare some global values
	SEG	0
	GL	FLAGS
FLAGS	HS	0			:marks beginning of flag array

	GLOBAL(ISIS2,1)			:default to ISIS-II
	GLOBAL(IRSIZE,03FC)		:Size of ISIS input ring (bytes)
	GLOBAL(ORSIZE,03FC)		:Size of ISIS output ring (bytes)
	GLOBAL(ENGINE,1)		:Run under ENGINE
	GLOBAL(CNTRL,402)		:Control-word state
	GLOBAL(ASYERR,0)		:Check for ASYNC-ring underflow if 1
	GLOBAL(CRSTOP,0)		:Specify option off if not in TYM file


:	CONSAT Register Definitions
	GLOBAL(RBC,1)			:Bufferlet Character Register
	GLOBAL(RBP,2)			:Bufferlet Pointer Register
	GLOBAL(RCH,7)			:Bufferlet GETCH Link Register
	GLOBAL(RBF,8)			:Bufferlet Link Register
	GLOBAL(RLINK,0A)		:Link Register used by Polling when ir
					:calls port receiver or transmitter
	GLOBAL(RPOL,0B)			:reserved for polling
	GLOBAL(RPI,0C)			:Port Table Information Pointer
	GLOBAL(RP2,0D)			:Port Number * 2
	GLOBAL(RP,0E)			:Port Number

:	DEFINE MAXHOSTS
MAXHST	EQ	NHOST
	SUBTTL	CONSAT -- ISIS-specific Macros
: **	Define macro to cause a crash...ISIS style crash:
:	R = (link) register to save
:	N = crash reason

ABORT	MACRO(R,N) [GL	CRASH;	JAL	R10,CRASH,,;	BC	0,0,4*R,N ]


	 IF	NSPORT

:	Define MACRO for SIO I/O
:	R -	Register for device address
:	ADDR -	Address for output
SIOIO	MACRO(R,ADDR) [
	LB	R,LUNSIO,RP
	LA	R+1,ADDR
	SVC	3,0B0+R
	JAL	R10,CRASH]

	 EI	:NSPORT
	SUBTTL	PORT TABLE

	GL	.PORT,.TERMT,.TTBUF,.FTBUF,.LGBUF
	GL	.VSTAT,.VSAVE,.XSTAT,.XSAVE,.LSTAT
	GL	.PTP.			:name of array of pointers to port tables

Q	HS	0			:Remember where we are
	ORG	0
.PORT	HS	1			:Port number
.TERMT	HS	1			:Terminal type
.TTBUF	HS	2			:pointer to To-Terminal Buffer
.FTBUF	HS	2			:pointer to From-Terminal Buffer
.LGBUF	HS	2			:pointer to LOGON-Buffer
.VSTAT	HS	2			:pointer to current Receiver Filter
.VSAVE	HS	2			:pointer to normal Receiver Filter
.XSTAT	HS	2			:pointer to current Transmitter Filter
.XSAVE	HS	2			:pointer to back-up Transmitter Filter
.LSTAT	HS	2			:pointer to logon-status handler
:						(if .NE. 0)
	IF	PVC
	GL	.PVCX,.PVCTO,.PVCDO,.PVCLH
.PVCX	HS	2			:PVC Exception parameters
.PVCTO	HS	1			:PVC Timeout
.PVCLH	HS	2			:PVC logon-history/flag
.PVCDO	BS	1			:PVC Action-state (thing to do)
	EI	:PVC
.PTLEN	WS	0			:table entry length

	ORG	Q			:Return to where we were
	SUBTTL	ISIS Assembly Switch Definitions	- START.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	03;	NUMBER SLEV
	REMARK %Start.Lib NOT compatible with ISIS 5.00 (earlier,later OK)

: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	define registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:RESTART SYSCALL
CFGND.	EQ	1	:CONNECT FOREGROUND SYSCALL
DBGON.	EQ	2	:DEBUG MODE ON SYSCALL
DBGOF.	EQ	3	:DEBUG MODE OFF SYSCALL
TSTDB.	EQ	4	:TEST DEBUG MODE SYSCALL
FREEZ.	EQ	5	:FREEZE SLOT SYSCALL
THAW.	EQ	6	:THAW SLOT SYSCALL
TFREZ.	EQ	7	:TEST FREEZE SYSCALL
RDDTR.	EQ	8	:READ DDT REGISTER SYSCALL
RDDTP.	EQ	9	:READ DDT PSD SYSCALL
RBREG.	EQ	0A	:READ BACKGROUND REGISTER SYSCALL
RBPSD.	EQ	0B	:READ BACKGROUND PSD SYSCALL
RFREG.	EQ	0C	:READ FOREGROUND REGISTER SYSCALL
RFPSD.	EQ	0D	:READ FOREGROUND PSD SYSCALL
RDMAC.	EQ	0E	:READ DDT MAC REGISTER SYSCALL
RBMAC.	EQ	0F	:READ BACKGROUND MAC REGISTER SYSCALL
RFMAC.	EQ	10	:READ FOREGROUND MAC REGISTER SYSCALL
SET1P.	EQ	11	:SET 1 PROTECT SYSCALL
SETP.	EQ	12	:SET PROTECTION SYSCALL
SETBE.	EQ	13	:SET BACKGROUND EXECUTION ADDR SYSCALL
SETFE.	EQ	14	:SET FOREGROUND EXECUTION ADDR SYSCALL
CSUPF.	EQ	16	:CHECK SUP FREEZE STATE
CSUPR.	EQ	17	:CHECK SUP RUN Q STATE
FREZS.	EQ	18	:FREEZE THE SUP
THAWS.	EQ	19	:THAW THE SUP
ALARM.	EQ	1A	:SET/CLEAR ALARM
RSCLK.	EQ	1B	:READ THE SUPER CLOCK
SSCLK.	EQ	1C	:SET THE SUPER CLOCK
SUDIA.	EQ	1D	:SET USER DIAGNOSTIC
SFREZ.	EQ	1F	:SUPER FREEZE SLOT
HALT.	EQ	20	:HALT THE SLOT
SHALT.	EQ	21	:SUPER HALT THE SLOT

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:QUERY I/O ATTRIBUTES
CSYNI.	EQ	0	:CONNECT SYNC INPUT
CSYNO.	EQ	1	:CONNECT SYNC OUTPUT
FSYNO.	EQ	2	:FORCE SYNC OUTPUT
CASYN.	EQ	3	:CONNECT ASYNC
CPRT.	EQ	4	:CONNECT PRINTER
FPRT.	EQ	5	:FORCE PRINTER
TIISC.	EQ	6	:T-II SYNC CONNECT
TIISI.	EQ	7	:T-II SYNC IDLE TEST
CSIO.	EQ	8	:CONNECT SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:SHARED DEVICE SVC
K.IN	EQ	0A	:KERNEL INPUT SVC
K.OUT	EQ	0B	:KERNEL OUTPUT SVC
KIO	EQ	0D	:KERNEL-I/O (GENERAL) SVC
BDISC	EQ	0E	:BIG DISC SVC (OBSOLETE)
SDISC	EQ	0F	:SMALL DISC SVC (OBSOLETE)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAEQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

  IF	ISIS2
:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:	Entering :RCRAT,4B in NAD will dump the crash table.
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI

	SEG	A.DATA
CRAT	HS	0		:START OF CRASH TABLE AREA
CRSHCT	HC	0		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HC	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HC	0,0		:WHERE CRASH OCCURED
CFROM	HC	-1,-1		:WHERE CRASH WAS CALLED FROM
CRREG	HS	20		:CRASH REGISTER SAVE AREA
FGNDFL	HS	1		:FOREGROUND FLAG


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
	LB	R0,CRSHCD,R1	:CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1	STM	R2,CRREG+8	:SAVE THE REGISTERS
	STH	R0,CRASHC	:SAVE CRASH CODE
	LM	R12,FAIL	:GET THE REST
	STM	R14,CRREG	:SAVE R0 & R1
	ST	R13,CPOINT	:SAVE FAILURE ADDRESS
	LCS	R1,1
	ST	R1,CFROM	:FLUSH PLACE CALLED FROM
	J	ENTRY1		:AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH	STM	R0,CRREG	:SAVE REGISTERS AND
	ST	R10,CPOINT
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
	L	R1,CRREG,R2	:GET CONTENTS OF REGISTER
CRASH1	STH	R0,CRASHC	:SAVE CRASH CODE
	ST	R1,CFROM	:SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
	STH	R0,CRASHC	:STORE IT
ENTRY1	LIS	R1,1
	AHM	R1,CRSHCT	:SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
	LM	R0,CRREG	:RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH

:	NOW RESET OUTPUT RING, REPORT CRASH
	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING
	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300;	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRSHCT;	JAL	R4,PUTH,,	:HW4 = CRASH COUNT
	LHL	R0,CRASHC;	JAL	R4,PUTH,,	:HW3 = CRASH CODE
	LIS	R0,1;		JAL	R4,PUTCH,,	:HW2 IS DIAGNOSTIC 1
	JAL	R4,ELOR,,		:END LOGICAL OUTPUT RECORD
	J	START,,		:NOW GO TO INITIALIZATION CODE
	EM

  ELSE		:ISIS2
:			ISIS - I Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and CRASH will sit in a loop calling DISMISS.
:	This is less load on the CPU than sitting in a self loop.
:	In order to start the code again CRSHCT must be set to 0.
:
:	Entering :RCRAT,4B in NAD will dump the crash table.

	SEG	A.DATA
CRAT	HS	0		:START OF CRASH TABLE AREA
CRSHCT	HC	0		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HC	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HC	0,0		:WHERE CRASH OCCURED
CFROM	HC	-1,-1		:WHERE CRASH WAS CALLED FROM
CRREG	HS	20		:CRASH REGISTER SAVE AREA


	SEG	A.CODE		:NOW ADVANCE TO SEGMENT 1
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
	LHI	R0,$8 01;	J	FAIL0		:MANUAL RESTART
	LHI	R0,$8 00;	J	FAIL0		:POWER FAILURE
	LHI	R0,$8 14;	J	FAIL1		:PARITY ERROR
	LHI	R0,$8 20;	J	FAIL1		:DISPATCHER CRASH
	LHI	R0,$8 21;	J	FAIL1		:ILLEGAL INSTRUCTION
	LHI	R0,$8 22;	J	FAIL1		:ILLEGAL SVC
	LHI	R0,$8 23;	J	FAIL1		:PRIVILEGE VIOLATION
	LHI	R0,$8 24;	J	FAIL1		:PROTECTION VIOLATION
	LHI	R0,$8 25;	J	FAIL1		:ARITHMETIC FAULT

FAIL0	SVC	DISMISS,10	:POWER FAILURE OR MANUAL RESTART...
				:SLEEP FOR A WHILE
FAIL1	STM	R1,CRREG+4	:SAVE THE REGISTERS
	STH	R0,CRASHC	:SAVE CRASH CODE
	LM	R13,FAIL	:GET THE REST
	ST	R15,CRREG	:SAVE R0
	ST	R14,CPOINT	:SAVE FAILURE ADDRESS
	LCS	R1,1
	ST	R1,CFROM	:FLUSH PLACE CALLED FROM
	J	ENTRY1		:AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH	STM	R0,CRREG	:SAVE REGISTERS AND
	ST	R10,CPOINT
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
	L	R1,CRREG,R2	:GET CONTENTS OF REGISTER
CRASH1	STH	R0,CRASHC	:SAVE CRASH CODE
	ST	R1,CFROM	:SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
	STH	R0,CRASHC	:STORE IT
ENTRY1	LIS	R1,1
	AHM	R1,CRSHCT	:SAVE INTERESTING DATA

  IF	\CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
    IF	CRSTOP
	CLH	R1,CRSHCT	:TEST IF FIRST TIME
	JE	ENTRY0		:IF FIRST TIME IN
	SIS	R0,1
	JLE	ENTRY0		:IF POWER FAILURE OR MANUAL RESTART
	LHL	R0,UPDOWN	:SET HOST DOWN
	OHI	R0,4000
	STH	R0,UPDOWN
	LHI	R0,0BADC
	STH	R0,FPANEL	:SET PANEL TO BAD CRASH
	LM	R0,CRREG	:RESTORE REGISTERS
	SVC	DISMISS,$A 900	:SLEEP FOR 15 MINUTES
	JBS	.-4		:CONTINUE DISMISSING FOREVER
    EI	CRSTOP
  EI	\CRSTOP


ENTRY0	SVC	1,FAIL		:INITIALIZE RESTART
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH

:	NOW RESET OUTPUT RING, REPORT CRASH
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING
	JAL	R4,SPACE	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300;	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRSHCT;	JAL	R4,PUTH,,	:HW4 = CRASH COUNT
	LHL	R0,CRASHC;	JAL	R4,PUTH,,	:HW3 = CRASH CODE
	LIS	R0,1;		JAL	R4,PUTCH,,	:HW2 IS DIAGNOSTIC 1
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
	J	START,,		:NOW GO TO INITIALIZATION CODE
	EM

  EI		:ISIS2
	SUBTTL	STATUS.LIB . . . .DRIVER TO PROCESS ARBITRARY COMMANDS UNDER "?STAT"
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

  IF	1-\DB.STA			:DEFAULT DEBUG/STATUS TO ON
DB.STA	EQ	1
  EI

  IF	DB.STA				:ASSEMBLE ONLY WITH DEBUG STATUS ON

	SEG	A.CODE
	MO	.,STATUS
	RA	$00
	GL	DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL

:	STATUS - User Command Handler
:
:	Version history:
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimeter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:		The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).

:		Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:	C/R	L/F	H/T	","	and BLANK.

:		Entry Points:
:	DSTART	Place to exit on completion of command.
:	DNEXTK  Get next token with out prompt.
:	DS.ILL	Place to exit on illegal command -- types "Illegal command"
:	DS.ERR	Place to exit on command error -- types "type '\' "
:	DS.EXI	Place to exit machine.
:	DS.QUI	Place to exit back to DDT.
:	DS.GCH	Get a character...Link on R1, char (with high-order bit forced)
:			in R0...normal return if detected ^W, skip-4 if detect
:			~A, aborts back to DSTART if detects ESC.
:	DS.DEL	Check for delimiter...Link on R2, Character in R0.  Skip-4
:			return unless this is a delimiter, then normal return.
:	DS.CUC	Convert to upper case...Link on R1, Character in R0.
:	DS.TOK	Get a string token...Link on R4, TOKEN returned in R3...
:			inputs up to 4 characters, returns them (in uppercase)
:			left justified, 0 fill
:	DS.NUM	Get a number...Link on R5, expects Radix in R4...
:			number returned in R0.  May ABORT if any character is
:			input other than valid digit or delimiter.
:	DS.DLM  Location of last delimeter entered (1 byte)

:		There are two built-in commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.

:		additional commands may be defined via the DS.CMD macro:
:	 DS.CMD(TEXT,ADDR)
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	DS.CMD generates a 12-byte discriptor for this command, at the point
:	assembly where it is invoked.  This discriptor is on a WORD boundary.



OUT	EQ	0B			:OUTPUT SVC
IN	EQ	0A			:INPUT SVC

DS.ELL	EQ	0			:NULL POINTER FOR END OF LINKED LIST

	SEG	A.DATA
DS.DLM	BS	1			:LAST DELIMETER ENCOUNTERED
R4SAV	WS	1			:SAVE AREA FOR R4 IN DS.TOK
BADSTR	SC	/'xxxx'"8D"8A/		:PLACE TO PUT BAD COMMAND
	SEG	A.CODE

:	DEFINE ELEMENTS FOR COMMAND BLOCK
C.NEXT	EQ	0			:POINTER TO NEXT ENTRY
C.ADDR	EQ	C.NEXT+4		:POINTER TO COMMAND HANDLER
C.STR	EQ	C.ADDR+4		:RELATIVE POSITION OF STRING

:	DEFINE MACRO TO GENERATE THIS COMMAND BLOCK
DS.CMD	MACRO(STR,ADDR)[
   IF	DS.ELL
Q	WS	0
	ORG	DS.ELL
	WC	Q
	ORG	Q
   EI
DS.ELL	WC	0,ADDR
	AC	/STR/
	BND	4
]


:	TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST	WS	0			:FORCE TO WORD BOUNDARY
	DS.CMD(Q,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(QUIT,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(EXIT,DS.EXI)		:EXIT 
	DS.CMD(EXI,DS.EXI)		:EXIT 




:	DIAGNOSTIC MESSAGES
TERR	SC	/Illegal command /
TTERR	SC	/type '\'"8D"8A/
PROMPT	SC	/"8D"8A:>/		:"CR|LF:>"
BKSPAC	SC	/"88 "88/		:BACK SPACE
	SUBTTL	COMMAND SCANNER, VERIFIER, AND BITCHER

:	COMMAND INPUT HANDLER
DOIT	L	R0,C.ADDR,R1		:GO SERVICE THIS COMMAND
	JALR	R0,R0

:	NEXT COMMAND
DSTART	SVC	OUT,PROMPT		:ISSUE PROMPT
DNEXTK	JAL	R4,DS.TOK		:GET COMMAND TOKEN
	LA	R1,CMDLST		:SEARCH FOR STRING MATCH
DSTAR1	CL	R3,C.STR,R1
	JE	DOIT			:PROCEED IF FIND A MATCH
	L	R1,C.NEXT,R1		:ELSE CONTINUE SCAN
	JGBS	DSTAR1
DS.ILL	SVC	OUT,TERR		:"ILLEGAL COMMAND"
	ST	R3,BADSTR+2,,		:"XXX"<CR>
	SVC	OUT,BADSTR,,
DS.ERR	SVC	OUT,TTERR		:TELL USER TO TYPE FLUSH CHAR
BITCH	JAL	R1,DS.GCH		:FLUSH INPUT
	JBS	BITCH;	 NOPR	0			:^W...IGNOR
	JBS	BITCH;	 NOPR	0			:^A...IGNOR
	CLHI	R0,0DC			:READ UNTIL "\" IS FOUND
	JNBS	BITCH
	J	DSTART			:THEN EXIT


:	BUILT-IN COMMANDS

:		Command EXIt
:		===========-
DS.EXI	SVC	KIO,0			:DISCONNECT


:		Command Quit (exit back to DDT)
:		=========---
DS.QUI	SVC	KIO,1			:RETURN TO DDT
	J	DSTART			:IF OPERATOR TYPED "P", GET NEXT COMMAND
	SUBTTL	U T I L I T I E S

:	GET A COMMAND TOKEN...UP TO 4 CHARS LONG
:		SKIPS OVER EXTRA CHARACTERS TO NEXT DELIMITER
:	LINK ON R4
:	TOKEN RETURNED IN R3, LEFT JUSTIFIED
DS.TOK	HS	0
	ST	R4,R4SAV,,		:SAVE R4
TOKEN0	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	TOKEN0;	 NOPR	0			:^W...IGNORE
	JBS	TOKEN0;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:SKIP OVER DELIMITERS
	J	TOKEN0
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	CHI	R0,00DC			:= "\" ?
	JE	DSTART			:YES, PRINT PROMPT, GET NEXT COMMAND
	LBR	R3,R0			:SET UP STRING ACCUMULATOR (000000CC)
	LIS	R4,1			:1 CHAR. FOUND SO FAR
TOKEN	JAL	R1,DS.GCH		:GET ANOTHER CHAR
	J	TOKEN0			:^W...START OVER
	J	TOKEN3			:^A...TOSS LAST CHAR
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	J	TOKEN1			:GOT ONE...SKIP TO LEFT JUSTIFY IT
	CHI	R0,00DC			:= "\" ?
	JE	DS.ILL			:YES, TREAT AS ILLEGAL
	AIS	R4,1			:ONE MORE CHARACTER
	CHI	R4,4			:IF => 4 CHARS, DO NOT USE THIS ONE
	JG	TOKEN			:YES...SCAN FOR DELIMITER
	SLLS	R3,8			:NO...ACCUMULATE CHARS
	STBR	R0,R3
	J	TOKEN			:AND GET ANOTHER CHAR
TOKEN1	HS	0
	L	R4,R4SAV,,		:RESTORE R4
TOKEN2	TI	R3,0FF000000		:HAVE WE 4 CHARS ALREADY?
	JNR	R4			:YES...RETURN TOKEN IN R3
	SLLS	R3,8			:NO...JUSTIFY IT
	JBS	TOKEN2			:AND REPEAT

TOKEN3	HS	0			:HANDLE BACKSPACE IN TOKEN
	SIS	R4,1			:ONE LESS CHAR
	CHI	R4,4			:IF AFTER BACKSPACE TOKEN IS => 4
	JGE	TOKEN			: JUST DECRIMENT COUNTER
	SRLS	R3,8			:ELSE... DROP 1 CHARACTER
	J	TOKEN			:AND GET NEXT CHAR.

:	UTILITY ROUTINE TO READ A NUMBER
:	USES R0-R3
:	EXPECTS RADIX IN R4
:	LINK ON R5
:	ABORTS IF FIRST NON-DELIMITER IS NOT DIGIT
:	ELSE RETURNS NUMBER IN R0
DS.NUM	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	DS.NUM;	 NOPR	0			:^W...IGNORE
	JBS	DS.NUM;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER CHAR
	J	DS.NUM
	JAL	R2,DS.DIG		:TEST IF CHAR IS DIGIT
	J	DS.ILL			:NOT A DIGIT - GIVE ERROR MESSAGE
	CLR	R0,R4
	JGE	DS.ILL			:DIGIT IS BIGGER THAN RADIX...ABORT
	LR	R3,R0			:PUT FIRST DIGIT INTO ACCUMULATOR
NUMBER	JAL	R1,DS.GCH		:READ NEXT CHAR
	J	DS.NUM			:^W...START OVER
	J	DIVIDE			:^A...TOSS LAST DIGIT
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	LR	R0,R3;	 JR	R5	  :YES
	JAL	R2,DS.DIG		:SKIP IF DIGIT
	J	DS.ILL			:NO...ABORT
	CLR	R0,R4
	JGE	DS.ILL			:RADIX ERROR...BITCH
	MR	R2,R4			:BUILD NUMBER
	AR	R3,R0			:ADD NEW DIGIT
	J	NUMBER			:GET NEXT DIGIT
DIVIDE	LIS	R2,0			:GOT A ^A...MAKE DOUBLE-PRECISION ARG.
	DR	R2,R4			:QUOTENT INTO R3, WHERE WE WANT IT
	J	NUMBER			:NOW GO BACK FOR MORE DIGITS

:	DIGIT TEST
:	CHECK CHARACTER READ...SKIP RETURN IF DIGIT
:	THEN R0=BINARY VALUE OF HEX DIGIT
:	USES R1, LINK ON R2
DS.DIG	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	LR	R1,R0			:COPY CHAR
	SHI	R1,0B0			:IS IT "0"?
	JLR	R2			:RETURN IF LESS THAN "0"
	SIS	R1,0B9-0B0		:IS IF "9"
	JLEFS	DIGIT			:LESS THAN "9" THEN A GOOD DIGIT
	SIS	R1,0C1-0B9		:IS IT "A"?
	JLR	R2			:RETURN IF LESS THAN "A"
	SIS	R1,0C6-0C1		:IS IF "F"?
	JGR	R2			:RETURN IF GREATER THAN "F"
	SIS	R0,7			:0A - "A" (PARTIAL CONVERSION)
DIGIT	SHI	R0,0B0			:"0"
	J	4,R2			:SKIP RETURN

:	CHECK FOR DELIMITER
:	LINK	R2
:	USES	R0,R1
:	SKIP-4 RETURN UNLESS (R0) IS A DELIMITER CHARACTER
DS.DEL	LHI	R1,DLEN-1		:NUMBER OF DELIMITER CHARS
	STB	R0,DS.DLM,,		:SAVE DELIMITER
DELIM	CLB	R0,DLIST,R1		:COMPARE TO A DELIMITER
	JER	R2			:RETURN IF DELIMITER
	SIS	R1,1			:CHECK NEXT DELIMITER
	JGEBS	DELIM			:LOOP IF ANY MORE DELIMITERS
	J	4,R2			:SKIP RETURN
:	LIST OF DELIMITER CHARS
DLIST	AC	' ,'			:BLANK,","
	BC	8D,8A,89		:CR,LF,HT
DLEN	EQ	.-DLIST			:NUMBER OF DELIMITER CHARS

:	INPUT A CHARACTER
:	LINK	R1
:	NORMAL RETURN:  ^W INPUT...FLUSH ENTRY
:	SKIP-4 RETURN:  ^A or ^H INPUT...FLUSH LAST CHAR
:	SKIP-8 RETURN: CHAR IN R0 (HIGH-BIT ON)
:	ABORTS TO COMMAND SCANNER ON "ESC"
DS.GCH	SVC	IN,0F			:GET THE CHAR
	J	DS.GCH
	OHI	R0,80			:SET HIGH-ORDER BIT
	CLHI	R0,9B			:CHECK FOR ESCAPE
	 JE	DSTART			:ABORT, PROCEED WITH PROMPT IF SO
	CLHI	R0,97			:CHECK FOR ^W
	 JER	R1			:NORMAL RETURN
	CLHI	R0,81			:CHECK FOR ^A
	 JE	4,R1			:SKIP-4 RETURN
	CLHI	R0,88			:CHECK FOR ^H
	 JN	8,R1			:NO, SKIP-8 RETURN, CHAR IN R0

	SVC	OUT,BKSPAC		:BACK SPACE
	J	4,R1			:SKIP-4 RETURN FOR ^H

:	CONVERT CHAR IN (R0) TO UPPER CASE
:	LINK ON R1
DS.CUC	CLHI	R0,0E1			:COMPARE WITH "a"
	JLR	R1			:EXIT IF IT CAN'T BE LOWERCASE
	CLHI	R0,0FA			:COMPARE WITH "z"
	JGR	R1			:NOT LOWER CASE...JUST RETURN
	SHI	R0,20			:LOWER CASE...CONVERT TO UPPER
	JR	R1			:AND RETURN

	EM

  EI	:(DB.STA)
	SUBTTL	Data Conversion Routines	- CONVRT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
:
	RA	0
:
	MO	.,CONVRT
:
	GL	BINDEC,BINHEX
:
:*****************************************************************
:
:	BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII DECIMAL CHARACTERS.
:
:	ARGUMENTS: R9 CONTAINS THE BINARY NUMBER
:	           R10 CONTAINS NUMBER OF DIGITS OF OUTPUT
:	           R11 POINTS TO OUTPUT AREA
:	LINK ON R4
:
:****************************************************************
:
	SEG	A.DATA
:
RSAVE	HS	10	:REGISTER SAVE AREA
:
	SEG	A.CODE
:
DIGIT	AC	/0123456789ABCDEF/
:
:	FIRST CHECK FOR A NEGATIVE NUMBER
:		IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
BINDEC	STM	R8,RSAVE	:PRESERVE REGISTERS
	LR	R9,R9		: TEST FOR NEGATIVE NUMBER
	JGEFS	NOTNEG		:JUMP IF NOT NEGATIVE
	LHI	R12,$0 00AD	:'ASCII '-'
	STB	R12,0,R11
	SIS	R10,1		: ROOM FOR ONE LESS DIGIT
	AIS	R11,1		: DITTO
	JLE	RTRN		:NO ROOM FOR DIGIT AFTER MINUS SINE
:	COMPLEMENT THE NUMBER TO POSITIVE
	XI	R9,-1
	AIS	R9,1
NOTNEG	SIS	R11,1
	LIS	R12,$A 10	: DIVISOR
DIVIDE	SR	R8,R8		: CLEAR HI ORDER BITS OF DIVIDEND
	DR	R8,R12		:GET LOW DIGIT IN R9
	LB	R13,DIGIT,R8	:GET ASCII EQUIVALENT OF DEC NUMBER
	STB	R13,0,R10,R11	:STORE IN REVERSE ORDER
	SIS	R10,1		:DECREMENT COUNTER
	JGBS	DIVIDE		: KEEP LOOPING
RTRN	LM	R8,RSAVE	:RESTORE THE REGISTERS
	JR	R4		:AND RETURN
:
:******************************************************************
:
:	BINHEX IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII HEX CHARACTERS. A SPACE CHARACTER IS APPENDED ON THE
:	END OF THE HEX CHARACTER STRING.
:	ARGUMENTS: R8 - ADDRESS OF WHERE TO PUT ASCII CHARACTERS
:			   THIS REGISTER IS RETURNED UPDATED TO NEXT AVAIL
:				LOCATION
:	           R9 - BYTE COUNT
:		   R10 - START ADDRESS OF MEMORY TO BE PROCESSED
:	LINKS R4
:
:******************************************************************
BINHEX	STM	R9,RSAVE	:PRESERVE REGISTERS
LOOP	LB	R11,0,R10	:LOAD BYTE
	LBR	R12,R11		:COPY THE BYTE
	SRHLS	R12,4		:GET FIRST DIGIT
	LB	R13,DIGIT,R12	:GET ASCII CHARACTER
	STB	R13,0,R8	:STORE THE CHARACTER
	LIS	R12,0F		:LOAD MASK
	NR	R12,R11		:MASK OFF HIGH DIGIT
	LB	R13,DIGIT,R12	:GET ASCII CHAR
	STB	R13,1,R8	:STORE THE CHARACTER
	SIS	R9,1		:DECREMENT LOOP COUNT
	JGFS	REPEAT		:MORE TO DO?
	LHI	R13,$0 0A0	:LOAD SPACE CHARACTER
	STB	R13,2,R8	:STORE IT
	AIS	R8,3		:INCREMENT STRING POINTER
	LM	R9,RSAVE	:RESTORE THE REGISTERS
	JR	R4		:AND RETURN
:
REPEAT	AIS	R8,2		:INCREMENT STRING POINTER
	AIS	R10,1		:INCREMENT BYTE ADDRESS
	J	LOOP		:REPEAT

	EM
:
	SUBTTL	GMT Clock Conversion Routines	- DATIME.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
:
	RA	$0 0A
:
	MO	.,DATIME
:
	GL	DATIME,TMSTMP,DATE
:
:***************************************************************
:
:	THIS PROCEDURE CONVERTS THE GMT CLOCK
:	RELATIVE TO 1/1/74 FROM SECONDS TO
:	DDMMMYY HH:MM (GMT) OR
:	DDMMMYY HH:MM:SS (GMT)
:
:	PARMS
:		R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:		R4 = CHARACTERS OF OUTPUT (13 OR 16)
:		R5 = ADDRESS OF OUTPUT STRING
:		R6 = LINK REGISTER
:	ALL REGISTERS ARE PRESERVED
:
:**************************************************************
:
	SEG	A.DATA
:
RSAVE	HS	$020	:REGISTER SAVE AREA
:
	SEG	A.CODE
DATIME	STM	R0,RSAVE	:PRESERVE THE REGISTERS
	S	R3,SEC745	
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULAR YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2		: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	LR	R14,R2		:COPY TIME OF DAY
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
	LHI	R8,76		:BASE YEAR
	SLLS	R3,2		:QUAD YEAR * 4
	AR	R8,R3		:ADD TO BASE YEAR
	LA	R7,LEPYEA	:POINT TO DAYS IN MONTH
	C	R2,W366		:IS IT IN CURRENT YEAR?
	JL	MONTHD		:JUMP IF SO
	S	R2,W366		:SUBTRACT DAYS IN YEAR
	AIS	R8,1		:ADD 1 TO YEAR
	LR	R11,R2		:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
MONTHD	SR	R6,R6		:MONTH COUNTER
	AIS	R2,1		:MAKE 1/1/76 = DAY 1
MONLOP	LR	R9,R2		:SAVE DAYS
	LB	R3,0,R6,R7	:GET DAYS IN MONTH
	SR	R2,R3		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1		:INCREMENT INDEX
	JBS	MONLOP
:
:	DAYS IN R3
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
:	SAVE R4 AND R5
DAZE	SIS	R4,8		:SUBTRACT OUT DATE LENGTH
	LR	R13,R4		:PRESERVE IT
	LR	R11,R5		:COPY OUPUT AREA POINTER
:
:	CONVERT DAY
	LIS	R10,2		:# OF OUTPUT CHARACTERS
	JAL	R4,BINDEC	:CONVERT TO DECIMAL ASCII
:
:	MOVE IN MONTH
	AIS	R11,2
	SLHLS	R6,2		:MULTIPLY MONTH NUMBER BY 4
	L	R4,MONTHS,R6	:GET THE NAME IN R4
	STB	R4,2,R11
	SRLS	R4,8
	STB	R4,1,R11
	SRLS	R4,8
	STB	R4,0,R11
	AIS	R11,3
:
:	CONVERT YEAR
	LR	R9,R8
	LIS	R10,2
	JAL	R4,BINDEC	:CONVERT TO CHARACTERS
	LHI	R3,$00A0	:ASCII SPACE
	STB	R3,2,R11	:PUT IT AFTER DATE
	LHI	R5,3,R11	:SET UP OUTPUT POINTER
	LR	R4,R13		:COPY LENGTH ARGUEMENT
	LR	R3,R14		:COPY TIME OF DAY
	JFS	TIME1		:JUMP
:*************************************************************
:
:	GET THE TIME STAMP
:
:	TIME STAMP ROUTINE
:		THIS ROUTINE CONVERTS THE FULLWORD GMT TIME OF DAY
:	TO HH:MM OR HH:MM:SS
:
:	PARAMETERS:
:		R3 = FULLWORD TIME OF DAY (GMT CLOCK)
:		R4 = 5 OR 8 (# OF CHARACTERS TO OUTPUT)
:		R5 = FULLWORD ADDRESS OF OUTPUT
:		R6 = LINK REGISTER
:
:	DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:	IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:	ROUTINE IS ALL ABOUT
:
:****************************************************************
TMSTMP	STM	R0,RSAVE	:PRESERVE THE REGISTERS
  IF \TIMZON
	AHI	R3,TIMZON*$A3600	:TIME ZONE CONVERSION
  EI
TIME1	SR	R8,R8		:INDEX FOR OUTPUT AREA
:
	SR	R2,R2		:CLEAR HI-ORDER BITS
	D	R2,SECDAY
:		SECONDS NOW IN R2
	LR	R3,R2		:GET READY FOR
	SR	R2,R2		:ANOTHER DIVIDE
	D	R2,TENOUR	:GET TENS OF HOURS
	JAL	R6,ASCOUT	:PRINT IT OUT IN ASCII
	DH	R2,OURS		:GET HOURS
:		R2 HAS REMAINDER, R3 HAS QUOTIENT
	JAL	R6,ASCOUT	:PRINT IT OUT
	LHI	R3,$00BA	:COLON
	JAL	R6,PRTOUT
	DH	R2,TENMIN
	JAL	R6,ASCOUT
	DH	R2,MIN
	JAL	R6,ASCOUT
:	THE CONDITION CODE HAS BEEN SET -
:	SET IF ANY MORE CHARACTER WANTED
	JE	RETRN		:JUMP IF ONLY 5 CHAR
:
:	PUT IN COLON BEFORE SECONDS
	LHI	R3,$00BA
	JAL	R6,PRTOUT
	DH	R2,TENSEC
	JAL	R6,ASCOUT
	LR	R3,R2		:GET SECONDS IN R3
	JAL	R6,ASCOUT
RETRN	LM	R0,RSAVE	:RESTORE THE REGISTERS
	JR	R6		:RETURN
:
:
ASCOUT	AHI	R3,$00B0
PRTOUT	STB	R3,0,R8,R5
	AIS	R8,1	: UPDATE INDEX
	SIS	R4,1
	JR	R6
:
:****************************************************************
:
:	THIS ROUTINE RETURNS A FULLWORD REPRESENTATION OF THE DATE
:	AND TIME. THE FORMAT OF THE RESULT IS MMDDHHMM WHERE
:	MM, DD, HH, & MM REPRESENT MONTH, DAY, HOUR, & MINUTES RESPECTIVELY
:	ALL IN DECIMAL FORMAT. I.E. DEC 12 13:41 WOULD BE 12121341.
:
:	IF THE SYMBOL TIMEZON IS DEFINED IT SHOULD BE THE TIME-ZONE
:	CORRECTION FACTOR FROM CUT (COORDINATED UNIVERSAL TIME)
:	I.E. PST IS -8.
:
:	PARMS
:		R3 = GMT CLOCK VALUE
:		R6 = RESULT FULLWORD
:
:	LINKS R5
:
:	PRESERVES REGISTERS R7 - R15
:
:******************************************************************
DATE	STM	R7,RSAVE	:PRESERVE THE REGISTERS
	S	R3,SEC745
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULAR YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2		: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	LR	R14,R2		:COPY TIME OF DAY
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
	LHI	R8,76		:BASE YEAR
	SLLS	R3,2		:QUAD YEAR * 4
	AR	R8,R3		:ADD TO BASE YEAR
	LA	R7,LEPYEA	:POINT TO DAYS IN MONTH
	C	R2,W366		:IS IT IN CURRENT YEAR?
	JL	MNTHD		:JUMP IF SO
	S	R2,W366		:SUBTRACT DAYS IN YEAR
	AIS	R8,1		:ADD 1 TO YEAR
	LR	R11,R2		:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
MNTHD	SR	R6,R6		:MONTH COUNTER
	AIS	R2,1		:MAKE 1/1/76 = DAY 1
MLOOP	LR	R9,R2		:SAVE DAYS
	LB	R3,0,R6,R7	:GET DAYS IN MONTH
	SR	R2,R3		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE1		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1		:INCREMENT INDEX
	JBS	MLOOP
:
:	DAYS IN R9
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
DAZE1	AIS	R6,1		:CONVERT TO MONTH NUMBER
	LB	R6,DECMAL,R6	:CONVERT TO DECIMAL REPRESENTATION
	SLLS	R6,8		:MOVE IT OVER
	LB	R9,DECMAL,R9	:CONVERT DAY TO DECIMAL
	OR	R6,R9		:OR IT IN
	SLLS	R6,8		:SHIFT IT OVER
	LR	R2,R14		:COPY SECONDS IN THE DAY
	DH	R2,OURS		:R3 HAS NUMBER OF HOURS
	LB	R3,DECMAL,R3	:CONVERT TO DECIMAL
	OR	R6,R3		:OR IT IN
	SLLS	R6,4		:SHIFT IT OVER
	DH	R2,TENMIN	:R3 HAS TENS OF MINUTES
	OR	R6,R3		:OR IT IN
	SLLS	R6,4		:SHIFT IT OVER
	DH	R2,MIN		:R3 HAS MINUTES
	OR	R6,R3		:OR IT IN
:
	LM	R7,RSAVE	:RESTORE REGISTERS
	JR	R5		:RETURN
:
DECMAL	XC	0001020304050607080910111213141516171819202122232425262728293031
SECDAY	WC	24*60*60	:SECONDS IN A DAY
TENOUR	WC	10*60*60	:TENS OF HOURS
OURS	HC	60*60		:HOURS
TENMIN	HC	10*60		:TENS OF MINS
MIN	HC	60		:MIN
TENSEC	HC	10		:TENS OF SECS
  IF	\TIMZON
SEC745	WC	24*60*60*365*2-TIMZON*60*60	:SECONDS IN 74 & 75 PLUS 
						:TIME-ZONE CORRECTION
  ELSE
SEC745	WC	24*60*60*365*2	:SECONDS IN 74 AND 75
  EI
W365	WC	365
W366	WC	366
QUADAY	WC	4*365+1
LEPYEA	BC	31,29,31,30,31,30,31,31,30,31,30,31
REGYER	BC	31,28,31,30,31,30,31,31,30,31,30,31
	WS	0
MONTHS	AC	/ Jan/
	AC	/ Feb/
	AC	/ Mar/
	AC	/ Apr/
	AC	/ May/
	AC	/ Jun/
	AC	/ Jul/
	AC	/ Aug/
	AC	/ Sep/
	AC	/ Oct/
	AC	/ Nov/
	AC	/ Dec/
	EM

	RA	0	:RADIX TO HEX

	TITLE	INSTAT.LIB . . . .Package to gather Input Ring Statistics	
	SUBTTL	INSTAT....Definitions & Data

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	RA	00			:INSURE CORRECT RADIX
	GL	LOOK			:INTERCEPT SYMBOL
	SEG	A.CODE
	MO	.,INSTAT

	GL	DSTART,.LOOK.,GETCH,DATIME

:	INSTAT - ISIS input ring statistics package
:		Version of 15 April 1981



:		The INSTAT package is intended to provide a tool to gather
:	statistics on the ISIS input ring, invokable under the "?STAT" command.

:		Entry point:

:	.LOOK.	used INSTEAD of <FRING.LIB>LOOK


:		?STAT commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.
:	IS.?	Help
:	IS.I	Initialize
:	IS.H	Halt
:	IS.C	Check status
:	IS.L	Length Statistics
:	IS.D	Data Statistics
:	IS.S	String Statistics


OUT	EQ	0B			:OUTPUT SVC
KIO	EQ	0D			:KIO SVC

MAXMSG	EQ	0C0			HIGHEST MESSAGE EXPECTED
MAXDTA	EQ	9D			HIGHEST DATA MESSAGE EXPECTED
MAXSYS	EQ	10			HIGHEST SYSTEM MESSAGE EXPECTED

:	MACRO TO PRINT A NUMBER ON TERMINAL
:	ARG	USE
:	1	NUMBER OF DIGITS
:	2	ANY SUM OF OF:  .S, .B, .Z, ONE OF [ .D, .H, OR .O]
S.	EQ	80			:SIGNED OUTPUT
B.	EQ	20			:BLANK FILL
Z.	EQ	40			:ZERO FILL
D.	EQ	0A			:DECIMAL
O.	EQ	08			:OCTAL
H.	EQ	10			:HEXIDECIMAL
	KILL	PRINT			:INSURE NO CONFLICT
PRINT	MACRO(ND,M2)[
	LHI	R1,(ND*100)!M2
	SVC	KIO,$A 10
]




:		DATA AREA

	SEG	A.DATA

:	NOTE...MAINTAIN ORDER OF DEFINITIONS!!

IS.BGN	WS	1			:GMT START TIME
IS.END	WS	1			:GMT END TIME

IS.USE	WS	1			:COUNTER FOR USER MESSAGES
IS.LEN	WS	MAXMSG+1		:NORMAL MESSAGE TYPES

IS.SYN	WS	1			:COUNTER FOR SYSTEM MESSAGES
IS.SYS	WS	MAXSYS+1		:SYSTEM MESSAGE TYPES

IS.DCI	WS	1			:TOTAL DATA CHARACTERS INPUT
IS.DAT	WS	100			:DATA STATISTICS

IS.STI	WS	1			:TOTAL STRINGS (>1) DETECTED
IS.STR	WS	MAXDTA+1		:STRING STATISTICS

IS.FLG	HC	0			:ACTIVITY FLAG:
:					<0	ACTIVE
:					=0	NEVER ACTIVE
:					=1	INACTIVE (DONE)
:					>1	INACTIVE (HALTED)
IS.CNT	HC	0			:TEXT BUFFER COUNT
IS.BUF	BS	$A 20			:TEXT BUFFER
IS.RET	WS	1			:SAVE RETURN ADDRESS HERE
	SUBTTL	INSTAT....Statistics Gathering	

	SEG	A.CODE


:	LOOK
:	Acts just like <FRING.LIB>LOOK
LOOK	LH	R0,IS.FLG		:CHECK ACTIVITY
	JGE	.LOOK.,,		:JUST GO THROUGH ".LOOK." IF INACTIVE
	ST	R4,IS.RET		:ELSE SAVE LINK REGISTER
	JAL	R4,.LOOK.,,		:GO DO IT
	 J	NODATA			:NOTHING THERE...JUST RETURN TO CALLER
	JE	PORT0			:DATA IS FOR PORT 0
	CLHI	R2,MAXMSG		:USER PORT...RANGE CHECK
	JGFS	CONT			:IGNOR IF OUT OF RANGE
	LIS	R0,1
	LR	R4,R2			:MAKE TYPE WORD INDEX
	SLLS	R4,2
	AM	R0,IS.LEN,R4		:COUNT MESSAGE(TYPE)
	AM	R0,IS.USE		:COUNT USER MESSAGE
	JL	DONE			:ABORT IF COUNTER OVERFLOWED
	CLHI	R2,MAXDTA		:CHECK FOR DATA
	JLEFS	DATA			:SKIP IF SO
CONT	L	R4,IS.RET		:RESTORE RETURN, SET CC .NE. 0
	J	4,R4			:AND PERFORM SKIP RETURN

:	POSSIBLE DATA TEXT
DATA	LR	R2,R2			:CHECK FOR MESSAGE TYPE 0
	JEBS	CONT			:YES...CONTROL MESSAGE EXIT
	AM	R2,IS.DCI		:COUNT TOTAL DATA CHARS IN MESSAGE
	JL	DONE			:ABORT IF COUNTER OVERFLOWED
	JAL	R4,GETCH,,		:TOSS THAT FIELD
	JAL	R4,GETCH,,		:GET FIRST CHAR
DATA1	LR	R1,R0			:COPY THIS CHAR
	LIS	R3,1			:ONE OF THESE
	SIS	R2,1			:COUNT CHAR GONE
	JLEFS	DATA3			:SKIP IF IT WAS THE LAST ONE
DATA2	JAL	R4,GETCH,,		:GET NEXT CHAR
	CR	R0,R1			:IS THIS A STRING?
	JNFS	DATA3			:END OF STRING...GO COUNT IT
	AIS	R3,1			:SAME STRING...COUNT IT
	SIS	R2,1			:GO THROUGH ALL OF MESSAGE
	JGBS	DATA2			:...UNTIL EXHAUSTED
DATA3	SLLS	R1,2			:MAKE WORD INDEX
	AM	R3,IS.DAT,R1		:COUNT OCCURANCES OF CHAR
	SLLS	R3,2			:MAKE WORD INDEX OF COUNT
	LIS	R4,1			:SET INCREMENT
	AM	R4,IS.STR,R3		:COUNT OCCURANCE OF STRING OF THIS LENGTH
	CLHI	R3,4			:WAS STRING OF LENGTH 1?
	JLEFS	DATA4			:DON'T COUNT THOSE AS STRINGS
	AM	R4,IS.STI		:ELSE COUNT ANOTHER STRING DETECTED
DATA4	LR	R2,R2			:IS MESSAGE EXHAUSTED?
	JG	DATA1			:PROCEED IF NOT EXHAUSTED

:	FINISHED...
	L	R4,IS.RET		:RESTORE RETURN
	J	.LOOK.,,		:RE-EXECUTE FOR USER


:	SYSTEM MESSAGE...".LOOK." DID SKIP(4) RETURN, CC = 0
PORT0	CLHI	R2,MAXSYS		:VERIFY MESSAGE TYPE
	JGFS	PORT0A			:SKIP IF OUT OF RANGE
	LR	R4,R2			:ELSE MAKE A WORD INDEX FROM TYPE CODE
	SLLS	R4,2
	LIS	R0,1			:SET UP COUNTER
	AM	R0,IS.SYS,R4		:COUNT SYSTEM MESSAGE(TYPE)
	AM	R0,IS.SYN		:COUNT SYSTEM MESSAGE
	JL	DONE			:ABORT IF COUNTER OVERFLOWS
PORT0A	L	R4,IS.RET		:RESTORE LINK REGISTER
	LIS	R0,0			:FAKE CONDITION CODES
	J	4,R4			:AND PERFORM SKIP RETURN

NODATA	L	R4,IS.RET		:NOTHING THERE...RESTORE LINK REGISTER
	JR	R4			:AND RETURN


:	DONE...TURN OFF, RECORD GMT, AND EXIT VIA LOOK
DONE	LIS	R4,1
	STH	R4,IS.FLG		:TURN OFF
	L	R4,GMT,,
	ST	R4,IS.END		:SET TERMINATION TIME
	L	R4,IS.RET		:RESTORE RETURN
	J	.LOOK.,,		:AND EXIT VIA LOOK
	SUBTTL	INSTAT....Command Handlers:  "IS.?" (HELP)

	DS.CMD(IS.?,HELP)		:PRINT COMMAND LIST

HELP	SVC	K.OUT,BANNER
	SVC	K.OUT,HELPM1
	SVC	K.OUT,HELPM2
	SVC	K.OUT,HELPM3
	SVC	K.OUT,HELPM4
	SVC	K.OUT,HELPM5
	SVC	K.OUT,HELPM6
	SVC	K.OUT,HELPM7
	SVC	K.OUT,HELPM8
	SVC	K.OUT,HELPM9
	SVC	K.OUT,HELPMA
	J	DSTART

BANNER	SC	/"8D"8A"8AINSTAT -- ISIS Input ring statistics"0A/
HELPM1	SC	/"8D"8AValid commands are:/
HELPM2	SC	/"8D"8AEXIT or EXI - log off/
HELPM3	SC	/"8D"8AQUIT or Q   - exit INSTAT (back to DDT)/
HELPM4	SC	/"8D"8AIS.?        - print this list/
HELPM5	SC	/"8D"8AIS.I        - Initialize/
HELPM6	SC	/"8D"8AIS.H        - Halt/
HELPM7	SC	/"8D"8AIS.C        - Check status/
HELPM8	SC	/"8D"8AIS.L        - Length statistic/
HELPM9	SC	/"8D"8AIS.D        - Data statistic/
HELPMA	SC	/"8D"8AIS.S        - String statistic/
	SUBTTL	INSTAT....Control Handlers

	DS.CMD(IS.I,INIT)		:INITIALIZE
	DS.CMD(IS.H,HALT)		:HALT
	DS.CMD(IS.C,CHECK)		:CHECK

INIT	LIS	R0,0
	LHI	R1,IS.FLG-IS.USE	:SET COUNTER
INIT1	ST	R0,IS.END,R1
	SIS	R1,4
	JGEBS	INIT1			:ZERO STORAGE
	L	R0,GMT,,		:SET TIME
	ST	R0,IS.BGN
	TS	IS.FLG			:SET PROCESS ACTIVE
	J	DSTART



HALT	LH	R0,IS.FLG
	JGEFS	CHECK			:JUST SKIP UNLESS RUNNING
	LIS	R0,2			:TURN OFF, SET HALTED
	STH	R0,IS.FLG
	L	R0,GMT,,
	ST	R0,IS.END		:SET STOP TIME AND FALL THROUGH



CHECK	SVC	OUT,BANNER		:DISPLAY BANNER
	LH	R7,IS.FLG		:CHECK STATE
	JNFS	CHECK1			:USED OR IN USE
	SVC	OUT,CKM1		:"NOT USED"
	J	DSTART			:AND EXIT

CHECK1	SVC	OUT,CKM2		:"NSTAT started "
	L	R3,IS.BGN		:TIME
	LHI	R4,$A 16		:LENGTH
	STH	R4,IS.CNT
	LA	R5,IS.BUF		:BUFFER
	JAL	R6,DATIME		:CONVERT TIME
	SVC	OUT,IS.CNT+1
	LR	R7,R7			:RECHECK STATE AGAIN
	JGFS	CHECK2			:SKIP IF COMPLETED
	SVC	OUT,CKM3		:"Running for "
	L	R3,GMT,,
	JFS	CHECK5			:AND SKIP

CHECK2	CLHI	R7,1			:HOW DID IT STOP
	JEFS	CHECK3			:ABORTED
	SVC	OUT,CKM4		:"Halted after "
	JFS	CHECK4

CHECK3	SVC	OUT,CKM5		"Quit after "

CHECK4	L	R3,IS.END		:GET END TIME

CHECK5	S	R3,IS.BGN		:COMPUTE ELAPSED TIME
	LIS	R2,0			:CLEAR HI-ORDER BITS
	D	R2,SECDAY		:SEC --> R2, DAYS --> R3
	LR	R0,R3			:COPY DAYS
	JEFS	CHECK6			:SKIP IF ZERO
	PRINT(2,D.)			:ELSE PRINT 2 DECIMAL DIGITS
	SVC	OUT,PERIOD		:"."
CHECK6	DH	R2,SECHOR		:SECONDS --> R2, HOURS --> R3
	LR	R0,R3
	PRINT(2,D.!Z.)			:2 DECIMAL DIGITS, ZERO FILL
	SVC	OUT,COLON		: ":"
	DH	R2,SECMIN		:SECONDS --> R2, MINUTES --> R3
	LR	R0,R3			:MINUTES
	PRINT(2,D.!Z.)			:2 DICIMAL DIGITS, ZERO FILL
	SVC	OUT,COLON		: ":"
	LR	R0,R2			:SECONDS
	PRINT(2,D.!Z.)			:2 DECIMAL DIGITS, ZERO FILL
	SVC	OUT,CKM6		:"Input "
	L	R0,IS.USE
	PRINT(0C,D.)			:12 DECIMAL DIGITS, NO FILL
	SVC	OUT,CKM7		:" user messages, "
	L	R0,IS.SYN
	PRINT(0C,D.)			:12 DECIMAL DIGITS, NO FILL
	SVC	OUT,CKM8		:" system messages/Input a total of "
	L	R0,IS.DCI
	PRINT(0C,D.)			:12 DECIMAL DIGITS, NO FILL
	SVC	OUT,CKM9		:" user data message characters."
	J	DSTART

SECDAY	WC	$A 24*60*60		:SECONDS IN A DAY
SECHOR	HC	$A 60*60		:SECONDS/HOUR
SECMIN	HC	$A 60			:SECONDS/MIN
CKM1	SC	/"8D"8ANSTAT Not Used./
CKM2	SC	/"8D"8ANSTAT started /
CKM3	SC	/ (GMT)"8D"8ARunning for /
CKM4	SC	/ (GMT)"8D"8AHalted after /
CKM5	SC	/ (GMT)"8D"8AQuit after /
CKM6	SC	/"8D"8AInput /
CKM7	SC	/ user messages, /
CKM8	SC	/ system messages"8D"8AInput a total of /
CKM9	SC	/ user data message characters."8D"8A/
	SUBTTL	INSTAT....IS.L -- Length statistics

	DS.CMD(IS.L,LEN)		:LENGTH

LEN	SVC	OUT,CR2LF		:DOUBLE SPACE
	L	R0,IS.USE
	PRINT(0C,D.)			:12 DECIMAL DIGITS, NO FILL
	SVC	OUT,LENM1		:" user message types"
	L	R0,IS.USE		:CHECK
	JE	LEN5			:SKIP IF NO MESSAGES

:	USER DATA STATISTICS
	SVC	OUT,LENM2		:"    Data messages"
	LIS	R3,1			:SET TYPE COUNTER
	LHI	R4,MAXDTA*4		:FIND HIGHEST DATA MESSAGE USED
LEN1	L	R0,IS.LEN,R4
	JNFS	LEN2
	SIS	R4,4
	JGBS	LEN1
LEN2	SVC	OUT,CRLF		:NEW LINE
	LR	R2,R3
	SLLS	R2,2			:MAKE A WORD INDEX
	LR	R0,R3
	PRINT(3,B.!H.)			:3 HEX DIGITS, BLANK FILL
	L	R0,IS.LEN,R2		:GET VALUE
	PRINT(0C,B.!D.)			:12 DECIMAL DIGITS, BLANK FILL
	AIS	R3,1			:LOOP END
	CR	R2,R4			:RANGE CHECK
	JLE	LEN2

:	USER CONTROL STATISTICS
	SVC	OUT,LENM3		:"Control message types/  0"
	LIS	R2,0			:SET REAL FIRST INDEX
	LHI	R3,MAXDTA		:SET PSEUDO-FIRST INDEX
	JFS	LEN4			:AND SKIP FOR PSEUDO ENTRY
LEN3	SVC	OUT,CRLF		:NEW LINE
	LR	R0,R3
	PRINT(3,B.!H.)			:3 HEX DIGITS, BLANK FILL
	LR	R2,R3
	SLLS	R2,2			:MAKE A WORD INDEX
LEN4	L	R0,IS.LEN,R2		:GET VALUE
	PRINT(0C,B.!D.)			:12 DECIMAL DIGITS, BLANK FILL
	AIS	R3,1			:LOOP END
	CLHI	R3,MAXMSG		:RANGE CHECK
	JLE	LEN3

:	SYSTEM MESSAGE STATISTICS
LEN5	SVC	OUT,CR2LF		:DOUBLE SPACE
	L	R0,IS.SYN
	PRINT(0C,D.)			:12 DECIMAL DIGITS, NO FILL
	SVC	OUT,LENM4		:" system message types"
	L	R0,IS.SYN
	JE	DSTART			:ABORT IF NONE
	LIS	R3,0			:SET COUNTER
LEN6	SVC	OUT,CRLF		:NEW LINE
	LR	R0,R3
	PRINT(3,B.!H.)			:3 HEX DIGITS, BLANK FILL
	LR	R2,R3
	SLLS	R2,2			:MAKE A WORD INDEX
	L	R0,IS.SYS,R2		:GET VALUE
	PRINT(0C,B.!D.)			:12 DECIMAL DIGITS, BLANK FILL
	AIS	R3,1			:LOOP END
	CLHI	R3,MAXSYS		:RANGE CHECK
	JLE	LEN6
	J	DSTART

LENM1	SC	/ user message types"8D"8A/
LENM2	SC	/    Data messages"8D"8A/
LENM3	SC	/"8A"8D"8A    Control message types "8D"8A  0/
LENM4	SC	/ system message types "8D"8A/
CRLF	SC	/"8D"8A/
CR2LF	SC	/"8A"8D"8A/
PERIOD	SC	/./
COLON	SC	/:/
	SUBTTL	INSTAT....IS.D -- Data statistics

	DS.CMD(IS.D,DAT)		:DATA

DAT	SVC	OUT,DATM1		:"Data-character distributions ("
	L	R0,IS.DCI		:GET NUMBER OF CHARS
	PRINT(0C,D.)			:12 DECIMAL DIGITS, NO FILL
	SVC	OUT,DATM2		:" chars)"
	L	R0,IS.DCI		:ABORT IF NONE
	JE	DSTART
	LIS	R3,0			:SET COUNTER
DAT1	SVC	OUT,CRLF		:NEW LINE
	LR	R0,R3
	PRINT(2,Z.!H.)			:2 HEX DIGITS, ZERO FILL
	LR	R1,R3
	SLLS	R1,2			:MAKE A WORD INDEX
	L	R0,IS.DAT,R1		:GET VALUE
	PRINT(0C,B.!D.)			:12 DECIMAL DIGITS, BLANK FILL
	AIS	R3,1			:LOOP END
	CLHI	R3,100			:RANGE CHECK
	JL	DAT1
	J	DSTART

DATM1	SC	/"8A"8D"8AData-character distributions (/
DATM2	SC	/ chars)"8D"8A/
	SUBTTL	INSTAT....IS.S -- String statistics

	DS.CMD(IS.S,STR)		:STRING

STR	SVC	OUT,STRM1		:"Character-string length distributions ("
	L	R0,IS.STI
	PRINT(0C,D.)			:UP TO 12 DECIMAL DIGITS, NO FILL
	SVC	OUT,STRM2		:" strings out of "
	L	R0,IS.DCI
	PRINT(0C,D.)			:UP TO 12 DECIMAL DIGITS, NO FILL
	SVC	OUT,STRM3		:" data characters"
	L	R0,IS.STI		:CHECK
	JE	DSTART			:ABORT IF EMPTY
	LHI	R4,MAXDTA*4
	LIS	R3,1			:SET COUNTER (IGNORE NULL)
STR1	L	R0,IS.STR,R4		:SEARCH FOR LAST NON-ZERO ENTRY
	JNFS	STR2
	SIS	R4,4
	JGBS	STR1
STR2	SVC	OUT,CRLF		:NEW LINE
	LR	R0,R3
	PRINT(3,B.!D.)			:3 DECIMAL DIGITS, BLANK FILL
	LR	R2,R3
	SLLS	R2,2			:MAKE A WORD INDEX
	L	R0,IS.STR,R2		:GET VALUE
	PRINT(0C,B.!D.)			:12 DECIMAL DIGITS, BLANK FILL
	AIS	R3,1			:LOOP END
	CR	R2,R4			:RANGE CHECK
	JL	STR2
	J	DSTART

STRM1	SC	/"8A"8D"8ACharacter-string length distributions"8D"8A    (/
STRM2	SC	/ strings out of /
STRM3	SC	/ data characters)"8D"8A/


	EM
	TITLE	CONSAT -- CONsolidated tymSAT		
	SUBTTL	 


:    ***   ***  *   *  ****  ***  *     ***** ****    *   ***** ***** ****
:   *   * *   * **  * *     *   * *       *   *   *  * *    *   *     *   *
:   *     *   * * * *  ***  *   * *       *   *   * *****   *   ****  *   *
:   *   * *   * *  **     * *   * *       *   *   * *   *   *   *     *   *
:    ***   ***  *   * ****   ***  ***** ***** ****  *   *   *   ***** ****


:                     ***** *   * *   *  ****   *   *****
:                       *    * *  ** ** *      * *    *
:                       *     *   * * *  ***  *****   *
:                       *     *   *   *     * *   *   *
:                       *     *   *   * ****  *   *   *






:	This file contains the environment-independent portions of
:	the CONSOLIDATED TYMSAT.




:	-----------------------------------------------------------------
:	|	This code is the sole property and confidential		|
:	|	information of TYMSHARE,  INC.,  and may not be		|
:	|	copied in whole or  in part or disclosed to any		|
:	|	third party without  the  prior written consent		|
:	|	of TYMSHARE.						|
:	-----------------------------------------------------------------

	GL	FLAGS,PVC,PUTCHR,PUTSIG,GETCHR	:references
	GL	CPEEK,EMPTY,BF,BCT
	GL	CIRDIS,ESTPRT,EXDISM
	GL	VRET,VDEF,XRET,XDEF
	GL	CHNGBF,CIRBLT,RBTIME,GBTIME	:definitions
	GL	XSAVE,XSTATE,MSG,MSG0,OOS,IZPORT,ZAPPER
	GL	TAM
	 IF	NAPORT
	GL	ADELAY,AGETCH,APUTCH,A.TID,A.DAT,A.DSC,A.ANS,A.VID,A.OBR,A.IBR
	 EI	:NPORT
	 IF	.2HD
	GL	A.RS.U,A.RS.D
	 EI	:.2HD
	SUBTTL	MACRO DEFINITIONS


:	MACRO	D.STRU(BASE)
:	=====	========
:	This macro allows data-structure symbols to be defined using
:	standard storage pseudo-ops (BS, HS, WS, etc.) relative to a
:	given base address.

:	Example:
:		If ZOT=12300, then:
:		D.STRU(ZOT)
:	SYM1	HS	1	SYM1=12300
:	SYM2	HS	2	SYM2=12302
:	SYME	HS	0	SYME=12306
:		D.STRU(-1)

:	D.STRU(-1) closes the prototype and restores the origin.

:	The MACRO is equivalent to:
:	Q	EQ	.
:		ORG	BASE
:	SYM1	HS	1
:	SYM2	HS	2
:	SYME	HS	0
:		ORG	Q

D.STRU	MACRO(BASE)[
	DEFAULT(.ORG.,-1)		:default = closed
	IF	BASE+1			:+0, opening definition
	 IF	-.ORG.
.ORG.	  EQ	.			:remember where we were
	  ORG	BASE			:new place
	 ELSE
	  ERROR(RECURSIVE DECLARATION OF D.STRU MACRO,0)
	 EI

	ELSE				:-1, close definition
	 IF	-.ORG.			:not opened
	  ERROR(REDUNDANT USAGE OF D.STRU MACRO,0)
	 ELSE
	  ORG	.ORG.			:back to where we were
.ORG.	  EQ	-1			:set closed
	 EI
	EI]

:	BA(CH,ADDR)		Create a word with format:
:					CH[8-bits]|ADDR[24-bits]
BA	MACRO(CH,ADDR) [ WC	CH^18!ADDR]



:	Define a set of macros to provide generalized SIGNAL processing.
:	Usage is:

:	LSIG	SIGBGN(i,j-k,...)	:define co-routine LSIG, declare
:					: signals i (or range j-k) to be
:					: ignored for this case.
:		SIGEXC(SIG,HANDLER)	:entry for each exception signal and
:					: it's handler
:		...
:		SIGEND			:finish up co-routine.




: **	.IGNOR(P)		Internal macro to perform all processing
:				for parameter P in macro SIGBGN, with range
:				MAXSIG, and bit array .S.BT.  Defined to
:				reduce macro storage requirements.

.IGNOR	MACRO(P) [
	.RANGE(SIGBGN,0,MAXSIG,P)
	.S.BIT(.S.BT)
]


:	SIGBGN(Rp...)		Define code and bit array to service signals
:				and exceptions.  Each parameter given may be
:				used to specify one signal (or a range of
:				signals) to be ignored.

SIGBGN	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	LO	SIGNAL
	KILL	.SIBT.,.SIPT.,.LOOP.
	TBT	R5,.SIBT.
	JE	SIGNAL
	LA	RCH,.SIPT.
.LOOP.	L	RBF,0,RCH
	JER	RLINK
	CLB	R5,0,RCH
	JER	RBF
	AIS	RCH,4
	JBS	.LOOP.

.SIPT.	WS	0
	DEFBIT(.S.BT,MAXSIG)
	.IGNOR(P0)
	.IGNOR(P1)
	.IGNOR(P2)
	.IGNOR(P3)
	.IGNOR(P4)
	.IGNOR(P5)
	.IGNOR(P6)
	.IGNOR(P7)
	.IGNOR(P8)
	.IGNOR(P9)
	.IGNOR(PA)
	.IGNOR(PB)
	.IGNOR(PC)
	.IGNOR(PD)
	.IGNOR(PE)
	.IGNOR(PF)
]


:	SIGEXC(SIG,HANDLER)		Declare signal SIG to be an
:					 exception, with HANDLER.

SIGEXC	MACRO(SIG,HAND) [
	.S1BIT(.S.BT,SIG)
	BA(SIG,HAND)
]


:	SIGEND()			place list termination, define bit
:					array, kill signals.

SIGEND	MACRO [
	WC	0
.SIBT.	BARRAY(.S.BT,MAXSIG)
	KILL	.SIBT.,.SIPT.,.LOOP.
	FO	SIGNAL
]


: **	BARRAY(NAME,NBIT)	Macro to put "NAMEd" bit array into memory.
:				Must be preceeded by a WS 0 or BND 4 if label
:				is to be OK.

BARRAY	MACRO(NAME,NBIT) [
Q	EQ	0
	RE	(NBIT+1F)/20
	 WC	NAME`|Q|
Q	 EQ	Q+1
	ER
]


: **	MINH(R,S,X)		Macro to put 1 into R, and then AHM from R
:				into S,X.  (Halfword Memory Increment)
MINH	MACRO(R,S,X) [ LIS	R,1;	AHM	R,S,X]

: **	MDCH(R,S,X)		Macro to put -1 into R, and then AHM from R
:				into S,X.  (Halfword Memory Decrement)
MDCH	MACRO(R,S,X) [ LCS	R,1;	AHM	R,S,X]
	SUBTTL	SIGNAL DEFINITIONS

	MO	.,SIGNAL

:	Internal to the CONsolidated tymSAT, control information is refered
:	to as SIGNALS.  These are designed to be readily translatable between
:	either the ISIS environment, or the TYMNET/SOLO environment.

:	In general, "V" is a value associated with the signal...
:	"C" is a data character which is also sometimes associated.

:	The actual table of signal codes defined is:


:	Function	Usage
:	  Code

:			Control Functions
:	 0+[V]	Enter TID mode [V]
:	 1+V+C	Baud rate V detected with character C
:	 2	Break Begin
:	 3	Break End
:	 4	Enter Data Mode
:	 5	Disconnect
:	 6+V	Set Delay V
:	 7+V+C	Repeat data character C V-times
:	 8	Enter DEM
:	 9	Leave DEM
:	0A	Hang-up
:	0B	Super Hang-up
:	0C	Zapper
:	0D	Gobbler
:	0E	Red Ball
:	0F	Green Ball
:	10	Orange Ball
:	11	Yellow Ball
:	12	Gray Ball
:	13	Black Ball
:	14	Enter Transparency
:	15	Leave Transparency
:	16	Enter Alternate Output Device Mode
:	17	Leave Alternate Output Device Mode
:	18-1F		Reserved

:			Field parameters
:	20+V	Set Input Baud Rate
:	21	Query Input Baud Rate
:	22+V	Set Output Baud Rate
:	23	Query Output Baud Rate
:	24+V	Set Parameter A
:	25	Query Parameter A
:	26+V	Set Parameter B
:	27	Query Parameter B
:	28+V	Set Parameter C
:	29	Query Parameter C
:	2A+V	Set Parameter D
:	2B	Query Parameter D
:	2C-2F		Reserved

:			Bit parameters
:	30+V	Set Echo Control
:	31	Query Echo Control
:	32+V	Set Echo Control-I
:	33	Query Echo Control-I
:	34+V	Set Echo Control-H
:	35	Query Echo Control-H
:	36+V	Set Echo CR with CR/LF
:	37	Query Echo CR with CR/LF
:	38+V	Set Echo LF with LF/CR/RUB
:	39	Query Echo LF with LF/CR/RUB
:	3A+V	Set CR delay
:	3B	Query CR delay
:	3C+V	Set Parity
:	3D	Query Parity
:	3E+V	Set Half-Duplex
:	3F	Query Half-Duplex
:	40+V	Set X-Enable
:	41	Query X-Enable
:	42+V	Set Reverse X-Enable
:	43	Query Reverse X-Enable
:	44+V	Set KATAKANA
:	45	Query KATAKANA
:	46+V	Set Terminate-output on Break
:	47	Query Terminate-output on Break
:	48+V	Set Echo-ESC
:	49	Query Echo-ESC
:	4A+V	Set Q-mode
:	4B	Query Q-mode
:	4C-4F		Reserved

CNTSIG	EQ	0			:Connect
TIBSIG	EQ	1			:TID-Detected baud-rate
BBSIG	EQ	2			:Break Begin
BESIG	EQ	3			:Break End
DATSIG	EQ	4			:Enter Data-Mode
DSCSIG	EQ	5			:Disconnect
EDMSIG	EQ	8			:Enter DEM
LDMSIG	EQ	9			:Leave DEM
HNGSIG	EQ	0A			:Hang Signal
SHGSIG	EQ	0B			:Super-Hang Signal
ZAPSIG	EQ	0C			:Zapper
GOBSIG	EQ	0D			:Gobbler
RBSIG	EQ	0E			:Red Ball
GBSIG	EQ	0F			:Green Ball
OBSIG	EQ	10			:Orange Ball
YBSIG	EQ	11			:Yellow Ball
GRBSIG	EQ	12			:Gray Ball
BLBSIG	EQ	13			:Black Ball
ETMSIG	EQ	14			:Enter Transparancy
LTMSIG	EQ	15			:Leave Transparancy
EADSIG	EQ	16			:Enter Alternate Device
LADSIG	EQ	17			:Leave Alternate Device

SIRSIG	EQ	20			:Set Input Rate
QIRSIG	EQ	21			:Query Input Rate
SORSIG	EQ	22			:Set Output Rate
QORSIG	EQ	23			:Query Output Rate
SPASIG	EQ	24			:Set Parameter A
QPASIG	EQ	25			:Query Parameter A
SPBSIG	EQ	26			:Set Parameter B
QPBSIG	EQ	27			:Query Parameter B
SPCSIG	EQ	28			:Set Parameter C
QPCSIG	EQ	29			:Query Parameter C
SPDSIG	EQ	2A			:Set Parameter D
QPDSIG	EQ	2B			:Query Parameter D

SECSIG	EQ	30			:Set Echo Control
QECSIG	EQ	31			:Query Echo Control
SCISIG	EQ	32			:Set Echo Control-I
QCISIG	EQ	33			:Query Echo Control-I
SCHSIG	EQ	34			:Set Echo Control-H
QCHSIG	EQ	35			:Query Echo Control-H
SCLSIG	EQ	36			:Set Echo CR with LF
QCLSIG	EQ	37			:Query Echo CR with LF
SLCSIG	EQ	38			:Set Echo LF with LCR
QLCSIG	EQ	39			:Query Echo LF with LCR
SCRSIG	EQ	3A			:Set CR Delay
QCRSIG	EQ	3B			:Query CR Delay
SPRSIG	EQ	3C			:Set Parity
QPRSIG	EQ	3D			:Query Parity
SHDSIG	EQ	3E			:Set Half-duplex
QHDSIG	EQ	3F			:Query Half-duplex
SXESIG	EQ	40			:Set X-enable
QXESIG	EQ	41			:Query X-enable
SRXSIG	EQ	42			:Set Reverse X-enable
QRXSIG	EQ	43			:Query Reverse X-enable
SKKSIG	EQ	44			:Set Katakana
QKKSIG	EQ	45			:Query Katakana
STBSIG	EQ	46			:Set Terminate-output-on-break
QTBSIG	EQ	47			:Query Terminate-output-on-break
SEXSIG	EQ	48			:Set Echo-ESC
QEXSIG	EQ	49			:Query Echo-ESC
SQMSIG	EQ	4A			:Set Q-mode
QQMSIG	EQ	4B			:Query Q-mode
MAXSIG	EQ	4F			:Maximum number of signals defined

	EM	:SIGNAL
	SUBTTL	VARIABLE DATA STORAGE

	SEG	A.DATA

	MO	.,DATA

:	Define arrays for background, quasi transfers

:		The cells from BEGZRO to ENDZRO are initialized to zero on
:	Startup.  Here start several arrays of attention bits that are toggled
:	on and off to indicate Buffer holding information, or Buffer empty.
:	Flag bits are addressed relative to the symbol FLAGS.  The bit displ-
:	acement for each buffer is contained in a BF halfword.  BF is indexed
:	by buffer number.
BFA	MACRO(VAL) [(VAL-FLAGS)*8]	:Macro to compute BF values

BEGZRO	HS	0			:Start of area to zero on Initialization
RLA	HS	NGRP			:marks active lines
LOGGER	HS	NGRP			:1 while LOGIN active
LOGING	HS	NGRP			:1 while in LOGIN mode
UNAME	HS	NGRP			:1 if in User-name part of LOGIN
LGECHO	HS	NGRP			:1 if user-name is to be echoed
NEWLOG	HS	NGRP			:1 if new login (rather than subsequent)
GOLOG	HS	NGRP			:1 when LOGIN buffer contains data
TOLOG	HS	NGRP			:DATA to LOGGER
TOPORT	HS	NGRP			:DATA to port
P.DONE	HS	NGRP			:used in some polling processes
MPVC.C	HS	NGRP			:1 if "MPVC candidate"
:	Arrays for TYMSHARE Virtual Terminal
Q.MODE	HS	NGRP			:1 if in Q-mode
HAFDUX	HS	NGRP			:1 if half-duplex port
ECHO	HS	NGRP			:1 to echo
ECTLI	HS	NGRP			:1 to echo control-I
ECTLH	HS	NGRP			:1 to echo control-H
E.ESC	HS	NGRP			:1 to echo ESC
ECR.LF	HS	NGRP			:1 to echo LF on CR
ELF.CR	HS	NGRP			:1 to echo CR|RUB on LF
PARITY	HS	NGRP			:1 if even parity forced
TOSING	HS	NGRP			:1 if port is flushing data
TSNBRK	HS	NGRP			:1 if flushing output on BREAK
CRDE	HS	NGRP			:1 if carriage-return delay enabled
ASYNC	HS	NGRP			:1 if ASYNC port
ASCII	HS	NGRP			:1 if terminal is ASCII
XONENA	HS	NGRP			:1 if using XON feature
XONOUT	HS	NGRP			:1 if last XON/OFF char was XON
YONENA	HS	NGRP			:1 if using reverse backpressure feature
RXON	HS	NGRP			:set if waiting during reverse XONENA
NBO	HS	NGRP			:set if GREEN|RED response pending
DEM	HS	NGRP			:set if port in TYMSHARE defered echo
TBOA	HS	NGRP			:RED/GREEN ball timeout array
TBOB	HS	NGRP
GBO	HS	NGRP			:set if GREEN-BALL response pending
TIDTO	HS	NGRP			:time-out for TID (next)
TIDTO1	HS	NGRP			:time-out for TID (later)
BRK	HS	NGRP			:1 if port in BREAK state
BRKTO	HS	NGRP			:time-out for BREAK (next)
BRKTO1	HS	NGRP			:time-out for BREAK (later)
MARGE	HS	NPORT			:Char-count or delay
LASTCH	BS	NPORT			:save last character here (if necessary)
IBRATE	BS	NPORT			:Input Baud-rate
OBRATE	BS	NPORT			:Output Baud-rate
PAR.A	BS	NPORT			:Parameter A
PAR.B	BS	NPORT			:Parameter B
PAR.C	BS	NPORT			:Parameter C
PAR.D	BS	NPORT			:Parameter D
	 IF	.2HD
TRNCH	BS	NPORT			:HD-202 turn-around character
	 EI	:.2HD

XMTF	HS	NGRP			:1 if legal to transmit to terminal
ATTN	HS	NGRP			:1 if reverse chan.-req outstanding
RTS	BS	NGRP			:1 if RTS is up
HANGWT	HS	NGRP			:1 to hang a port used by SIO and ASYNC
	 IF	NAPORT
BUSY.H	HS	NAGRP			:ports currently busy (history)
BUSY.A	HS	NAGRP			:ports requiring busy service
:	Arrays for signal drivers
DTR	HS	NAGRP			:1 to hang a port
DSR	HS	NAGRP			:0 if Data Set Ready
NEWDSR	HS	NAGRP			:0 if Data Set Ready
CP	HS	NAGRP			:Carrier Present bit array
CPSAMP	HS	NAGRP*4			:2-dimentional Carrier Present array
					: CPSAMP+(2*NAGRP)*i, i=0,3 each
					: contain one set of CP-history samples.
A.SPED	HS	4			:bit-array for ASYNC speeds supported
AHATMP	HS	1			:temp store fo answer/hang
QRET	HS	2			:return for QUASI

:	2741 State Variables:
VTBA	EQ	PAR.A			:Receiver conversion table dispatcher
XTBA	EQ	PAR.B			:Transmiter conversion table dispatcher
SCF	EQ	ECR.LF			:1 if special (+/-) case set
UCF	EQ	ELF.CR			:1 if upper-case set
EOAF	EQ	ECTLH			:1 if receiver should expect EOA
EOTF	EQ	PARITY			:1 if transmitter should take the line
CARR	EQ	ECTLI			:1 if last char output was a new-line
	GL	TEBC

	 IF	NUMPRN

:	Printer variables
PRTACT	HS	1			:set to highest-numbered printer port
	 EI	:NUMPRN
	 EI	:NAPORT

:	Space for variable text messages
ULMSG	HS	80/2			:User message...force to boundary
MS0	HS	$A 12			:Storage for Port-ID message...24d bytes
	GL	MS00			:Name of position of Port-number field

	 IF	NSPORT			:SIO/Mother-Board optional
	SUBTTL	SIO STORAGE

:	SIO data area is composed of command blocks (ICMSIO, OCMSIO)
:	data blocks (OUTSIO, INPSIO), a bit array set if SIO port is
:	configured and connected (GOTSIO), array for which bit set designates
:	that the SIO port is hung by the software (HNGSIO).
:	Certain access to the SIO data areas is done with an index register
:	which is a function of the global CONSAT port-index, thus all data
:	labels are defined with a virtual offset since all SIO ports start
:	at .SPORT ports.
LUNSIO	EQ	.-.SPORT		:label relative to actual port number
	BS	NSPORT			:Unit-number for each port
CHRSIO	BS	1			:current SIO character
ECOSIO	HS	1			:echo possible if 0
GOTSIO	EQ	.-(.SPORT/8)		:Offset by .SPORT
	HS	NSGRP			:Bit set if SIO device is found
D.PAS1	EQ	.-(.SPORT/8)		:Offset by .SPORT
	HS	NSGRP
D.PAS2	EQ	.-(.SPORT/8)		:Offset by .SPORT
	HS	NSGRP			:These for break "one-shot"
SIOSTD	EQ	.-(.SPORT/8)		:Offset by .SPORT
	HS	NSGRP			:These SIO "something-to-do"
XINSIO	WS	NSPORT			:points to current in-buffer
LOWSIO	BND	10			:SIO requires this boundary
SAVSIO	WS	4			:general save area
XONSIO	WS	4			:XON-command
XOFSIO	WS	4			:XOFF-command
OCMSIO	WS	NSPORT*8		:This area has output-command lists
STASIO	 EQ	OCMSIO+10		:Status-words for each port
ICMSIO	WS	NSPORT*8		:This area has input-command lists
OUTSIO	WS	NSPORT*8		:32d-bytes output-area per port
	BND	40
INPSIO	WS	NSPORT*10		:Input, 4 blocks, 10 bytes/block, NSPORT ports
HIHSIO	HS	0


	 EI	:NSPORT

	 IF	PVC
	SUBTTL	PVC VARIABLES

PVCSTD	HS	NGRP			:Something-to-do array.  Bit on for PVC port
					: which requires some kind of service,
					: including ticking the clock.

:	A reset bit in the TATBIN array will prevent the HANG/ANSWER timeout
:	parameters from hanging a port which has not detected a TID character
:	in over 16 seconds from the time the port was connected.  If PVC is
:	set, then the array is initialized to ones, and only those ports with
:	the NOHNG option will have the TATBIN bit reset to prevent the TA/TB
:	timeout.
TATBIN	HS	NGRP			:Inhibit Hanging based on TA/TB parameters

:	Define default PVC username & password
PVCBAS	HS	1			:port-number bias
PVCUNL	EQ	$A 20			:Length of PVCUN storage
PVCPWL	EQ	$A 32			:Length of PVCPW storage

PVCUN	HS	PVCUNL/2		:ALO-default USERNAME
PVCPW	HS	PVCPWL/2		:ALO-default PASSWORD

PVCRET	HS	2			:PVC may save return address here

	 IF	NMPVC
	SUBTTL	MPVC VARIABLES

:	General MPVC variables
TOMPVC	HS	NGRP			:data-present for MPVC
MPV.CI	HS	1			:current input port
MPV.T1	HS	1			:temp-store 1
MPV.T2	HS	2			:temp-store 2
MPV.T3	HS	1			:temp-store 3
MPV.T4	HS	2			:temp-store 4

:	MPVC Variable descriptors:
Q	HS	0			:remember where we are
	ORG	0			:definition space:
MPV.AP	HS	NGRP			:port active
MPV.CO	HS	1			:current output port
MPV.PA	HS	1			:ports active
MPV.TO	HS	2			:inactivity timer
MPV.PS	HS	2			:port seconds for accounting
MPV.LP	HS	1			:number of logons for accounting
MPV.TD	BS	1			:temp-store for DEMUX character
MPV.SZ	HS	0			:the size of an variable descriptor
	ORG	Q			:back to real space again

:	Define MPVC variable blocks and bit arrays
Q	EQ	0
	 RE	NMPVC
MPVV|Q|	HS	MPV.SZ			:temp store for MPVC port Q
Q	EQ	Q+1
	 ER	:NMPVC
	 EI	:NMPVC

	 EI	:PVC

	EM	:DATA
	SUBTTL	CONSTANT DATA STORAGE

	SEG	A.CODE

	MO	.,DATA

BASE	HS	0			:base address for relocation in Code-Segment
	GL	BASE

EA	MACRO(VAL) [VAL-BASE]		:Macro to compute effective addresses


:	general bit arrays

	IF	.2HD
HD202	WS	0
	BARRAY(.2HD,NPORT)		:1 if HALF-DUX 202 port
	EI	:.2HD
NPIPRT	WS	0			:ports which have no NPI
	BARRAY(.NPI,NPORT)

:	Special ASYNC parameters
T120	WS	0;	BARRAY(.120T,NAPORT)		:1 if 1200 baud TID message

BUSY.C	WS	0
	BARRAY(.BSY,NAPORT)		:1 if BUSY-OUT supported

:	ASCII printable character set
PABLE	WC	-1,0,0,7		:0 - 37, 175 - 177 are unprintable

:	Special ASCII control characters
SPABLE	WC	00E45020,0,0,0		:^H, ^I, LF, CR, XON, XOFF, ESC

:	Parity-translation table...1 = odd parity
PARBIT	HC	6996,9669,9669,6996,9669,6996,6996,9669
	SUBTTL	PORT INITIALIZATION TABLES


:	Terminal-type table.  Matches baud rate and NID character in order to
:	determine terminal type.  Each entry also contains other information
:	relevant to initializing the port.

:	Define VID macro to generate a table entry:

:	VID(WHEN,KEY,VREC,XMIT,NID,TID,IBR,OBR,A,B,C,D,FLG,[INI])
:	    |    |   |    |    |   |   |   |   | | | | |   |
:	    |    |   |    |    |   |   |   |   | | | | |   init'l routine
:	    |    |   |    |    |   |   |   |   | | | | |     (optional), forward
:	    |    |   |    |    |   |   |   |   | | | | |     reference!
:	    |    |   |    |    |   |   |   |   | | | | Flag array (corresponds
:	    |    |   |    |    |   |   |   |   | | | |	to VIDBA -- Binary)
:	    |    |   |    |    |   |   |   |   | | | Parameter D (decimal)
:	    |    |   |    |    |   |   |   |   | | Parameter C (decimal)
:	    |    |   |    |    |   |   |   |   | Parameter B (decimal)
:	    |    |   |    |    |   |   |   |   Parameter A (decimal)
:	    |    |   |    |    |   |   |   Output Baud-rate index (decimal)
:	    |    |   |    |    |   |   Input Baud-rate index (decimal)
:	    |    |   |    |    |   Terminal NID character (hex)
:	    |    |   |    |    Network NID (decimal)
:	    |    |   |    Transmit Filter handler (symbolic)
:	    |    |   Receive Filter handler (symbolic)
:	    |    used to generate symbol for PVC tables (octal)
:	    Condition under which to generate entry (symbolic)

:	The table entry generated has the format:
VID.TI	WS	1			:This half-word consists of TID|IBR
					:	index, and may be referenced
					:	to identify the terminal
VID.IB	EQ	VID.TI+1		:This byte contains IBR
VID.OB	EQ	VID.IB+1		:this byte contains OBR
VID.ID	EQ	VID.OB+1		:this byte contains Network NID
VID.PA	BS	1			:this byte specifies Parameter A
VID.PB	BS	1			:this byte specifies Parameter B
VID.PC	BS	1			:this byte specifies Parameter C
VID.PD	BS	1			:this byte specifies Parameter D
VID.FL	HS	1			:this halfword contains flag bits to
					:	set/reset bit parameters
VID.VF	HS	1			:This halfword specifies Receive filter EA
VID.XF	HS	1			:This halfword specifies Transmit filter EA
VID.IZ	HS	1			:if non-zero, based pointer to init'l.
VID.SZ	EQ	.-VID.TI		:the size of an entry
	ORG	VID.TI			:Tables defined, now proceed...

:	THE FOLLOWING B.S. IS A TEMPORARY KLUDGE...REMEMBER TO FIX IT SOMEDAY!!
.2	EQ	$A 12			:2400 TID...should be 16d!!
.4	EQ	$A 12			:4800 TID...should be 19d!!

VID	MACRO(W,K,RF,XF,NID,TID,IBR,OBR,AA,B,C,D,FL,INITL) [
	RA	0A			:switch to decimal radix
	IF	W
	GL	RF,XF
TID.`K	EQ	.-VID.TI
	IF	$0 TID;	 BC	$0 1F&TID;	ELSE;	BC	$0 20;	EI
	BC	IBR,OBR,192!NID
	 IF	-AA
	HC	B	:TEBC case
	 ELSE
	BC	AA,B	:normal case
	 EI
	BC	C,D
	HC	$2 FL,EA(RF),EA(XF)
	 IF	\(INITL+0)		:1 if null or defined, else 0
	HC	0
	 ELSE	:\(INITL+0)
	GL	INITL
	HC	EA(INITL)
	 EI	:\(INITL+0)
	ELSE
TID.`K	EQ	-1
	EI	:W
	RA	0			:switch back to hex radix
]

:	     When Key  RCV  XMIT NID TID  I  O  A  B    C D  FLags
TID30	EQ	.-VID.TI
	VID(NAPORT,00, AVID,XASCI,00,000,08,08,01,0005,15,1,010100001)	:TID -	300
TID120	EQ	.-VID.TI
	VID(NAPORT,00, AVID,XASCI,00,000,09,09,01,0005,15,1,010100001)	:TID -	1200
	VID(NAPORT,14,VASCI,XASCI,01,0D9,02,02,00,0000,00,0,110000111)	:y -	300
	VID(NAPORT,10,VASCI,XASCI,01,0C1,02,02,00,0000,00,0,010000111)	:A -	300
	VID(NAPORT,11,VASCI,XASCI,02,0C3,02,02,04,0000,04,9,010000111)	:C -	300
	VID(NAPORT,12,VASCI,XASCI,03,0C5,02,02,04,0006,06,1,010000111)	:E -	300
	VID(NAPORT,13,VASCI,XASCI,04,0C7,02,02,03,0005,10,0,010000110)	:G -	300
	VID(NAPORT,04,VASCI,XASCI,05,0C2,01,01,06,0000,02,0,010000111)	:B -	150
	VID(NAPORT,05,VASCI,XASCI,06,0C6,01,01,04,0000,04,9,010000111)	:F -	150
	VID(NAPORT,01,VASCI,XASCI,10,0C4,00,00,00,0000,00,0,010001111)	:D -	110
	VID(NAPORT,15,VASCI,XASCI,12,0C1,05,05,00,0000,00,0,010000111)	:A -	1200
	VID(NAPORT,16,VASCI,XASCI,12,0C9,05,05,01,0012,08,6,010100111)	:I -	1200
	VID(NAPORT,17,VASCI,XASCI,12,0C7,05,05,03,0005,08,0,010100110)	:G -	1200
	VID(NAPORT,20,VASCI,XASCI,.2,0C1,10,10,00,0000,00,0,010000111)	:A -	2400
	VID(NAPORT,23,VASCI,XASCI,.2,0C9,10,10,01,0012,08,6,010100111)	:I -	2400
	VID(NAPORT,26,VASCI,XASCI,.2,0C7,10,10,03,0005,08,0,010100110)	:G -	2400
	VID(NAPORT,21,VASCI,XASCI,.4,0C1,11,11,00,0000,00,0,010000111)	:A -	4800
	VID(NAPORT,24,VASCI,XASCI,.4,0C9,11,11,01,0012,08,6,010100111)	:I -	4800
	VID(NAPORT,27,VASCI,XASCI,.4,0C7,11,11,03,0005,08,0,010100110)	:G -	4800
	VID(NAPORT,22,VASCI,XASCI,20,0C1,12,12,00,0000,00,0,010000111)	:A -	9600
	VID(NAPORT,25,VASCI,XASCI,20,0C9,12,12,01,0012,08,6,010100111)	:I -	9600
	VID(NAPORT,30,VASCI,XASCI,20,0C7,12,12,03,0005,08,0,010100110)	:G -	9600
	VID(LISA  ,18,VASCI,XASCI,22,000,05,05,00,0000,00,0,010000001,L.INIT)	:LISA/1200
	VID(LISA  ,19,VASCI,XASCI,22,000,11,11,00,0000,00,0,010000001,L.INIT)	:LISA/4800
	VID(NAPORT,00,V2741,X2741,09,06D,06,06,-1,TEBC,00,0,000000000)	:CR -	300
	VID(NAPORT,07,Z2741,X2741,09,00B,06,06,00,0000,00,0,000000000)	:PCorr-	300
	VID(NAPORT,06,Z2741,X2741,09,079,06,06,-1,TEBC,00,0,000000000)	:Pebcd-	300
	VID(NAPORT,00,V2741,X2741,09,06D,07,07,00,0000,00,0,000000000)	:CR -	133
	VID(NAPORT,03,Z2741,X2741,09,00B,07,07,00,0000,00,0,000000000)	:PCorr-	133
	VID(NAPORT,02,Z2741,X2741,09,079,07,07,-1,TEBC,00,0,000000000)	:Pebcd-	133
	 IF	NSPORT
	VID(BAUDY ,S8,VHSBAD,XHSBAD,15,0,15,15,00,0000,00,0,001000111) :SIO -	50 BAUDOT
	VID(BAUDY ,S9,VHSBAD,XHSBAD,15,0,16,16,00,0000,00,0,001000111) :SIO -	75 BAUDOT
TID.S	EQ	.-VID.TI		:entry for SIO
	GL	TID.S
	 EI	:NSPORT
	VID(NSPORT,S3, VSIO, XSIO,12,000,05,05,00,0000,00,0,010000111)	:SIO -	1200
	VID(NSPORT,S4, VSIO, XSIO,.2,000,10,10,00,0000,00,0,010000111)	:SIO -	2400
	VID(NSPORT,S5, VSIO, XSIO,.4,000,11,11,00,0000,00,0,010000111)	:SIO -	4800
	VID(NSPORT,S6, VSIO, XSIO,20,000,12,12,00,0000,00,0,010000111)	:SIO -	9600
	VID(NSPORT,S1, VSIO, XSIO,10,000,00,00,00,0000,00,0,010001111)	:SIO -	110
	VID(NSPORT,S2, VSIO, XSIO,01,000,02,02,00,0000,00,0,010000111)	:SIO -	300
	VID(NSPORT,S7, VSIO, XSIO,01,000,02,02,00,0000,00,0,110000111)	:y -	300
	 IF	NMPVC
TID.M	EQ	.-VID.TI		:entry for MPVC
	GL	TID.M
	 EI	:NMPVC
	VID( NMPVC,40,V.MPV,M.DMX,21,000,12,12,00,0000,00,0,000000111)	:BLAH -	MPVC
	HC	0			:zero terminates scan

	KILL	VID			:we no longer need (nor want) this!!
	KILL	.2,.4			:we no longer need (nor want) this!!


:	Table of addresses used (top to bottom) to initialize bit arrays.
:	Field of bit states are used right to left.  Note that 2741 bit
:	arrays SCF, UCF, EOAF and EOTF correspond to ECR.LF, ELF.CR, HAFDUX,
:	and PARITY and are therefore initialized with this mechanism.
VIDBA	HC	CRDE,ECR.LF,ELF.CR	:varies
	HC	ECTLI,ECHO,PARITY	:varies
	HC	HAFDUX,ASCII,MPVC.C	:varies
	HC	XONENA,XMTF,ATTN	:varies
	HC	TSNBRK,TOSING,ECTLH	:varies
	HC	0			:0 - terminator

:	Map of parameter "C"
CPARAM	BC	$A 0,1,2,3,4,5,7,10,14,19,26,36,50,69,95,131

:	Create table of accounting hosts in port order
ACHOST	HS	0
Q	EQ	0
	RE	NPORT
	 IF	\.ACH|Q|
	  HC	.ACH|Q|
	 ELSE
	  HC	.AHOST
	 EI	:\.ACH|Q|
Q	 EQ	Q+1
	ER	:NPORT

:	Create table of accounting codes in port order
ACPORT	HS	0
Q	EQ	0
	RE	NPORT
QQ	 EQ	0
	 IF	\.ACC|Q|
QQ	  EQ	.ACC|Q|
	 EI	:\.ACC|Q|
	 IF	QQ+1			:don't diddle Specials
	  IF	NUMPRN-Q
QQ	   EQ	QQ!1			:printer code
	  ELSE	NAPORT-Q
	   IF	.BIT.(.2HD,Q)
QQ	    EQ	QQ!3			:HD202
	   ELSE
QQ	    EQ	QQ!2			:normal ASYNC
	   EI	:.BIT.
	  ELSE	.SPORT+NSPORT-Q
QQ	    EQ	QQ!4			:SIO ASYNC
	  ELSE	.MPORT+NMPVC-Q
QQ	    EQ	QQ!5			:MPVC
	  EI
	 EI	:QQ-1
	 HC	QQ			:finally, place value
Q	 EQ	Q+1
	ER	:NPORT

:	Some text messages:
IULMSG	HS	0			:Initial text message...set up to copy
	 IF	\ULMSGX
	ULMSGM
	 EI	:\ULMSGX
	BC	0			:insure text terminated
	ORG	IULMSG+80		:save space for padding

	 IF	PVC
	SUBTTL	PVC TABLES
:	Build tables for PVC processes

:		Two tables are necessary for the PVC code:  PVCARY, which is
:	is a bit array, indexed by port number, in which a set condition
:	(1) indicates that a port requires some kind of PVC service, and
:	the .PVCX element of the Port-table entry pointed at by the
:	.PTP. entry for this port.  The element is a fullword in length,
:	and describes the options selected for each PVC port.

PVCARY	WS	0
	BARRAY(PVCG,NPORT)

:	Map the TID|N| AID option into the corresponding position of
:	this terminal-type in VID.TI.  This is a table of half-word offsets,
:	with null entries filled with -1!
PVCTID	HC	-1,TID.01,TID.02,TID.03,TID.04,TID.05,TID.06,TID.07
	HC	TID.10,TID.11,TID.12,TID.13,TID.14,TID.15,TID.16,TID.17
	HC	TID.20,TID.21,TID.22,TID.23,TID.24,TID.25,TID.26,TID.27
	HC	TID.30,-1,-1,TID.18,TID.19,-1,-1,-1
Q	EQ	(.-PVCTID)/2		:consistancy check
	IF	Q-TIDMAX
	 ERROR(** BUG ** PVCTID consistancy check,0)
	ELSE	TIDMAX-Q
	 ERROR(** BUG ** PVCTID consistancy check,0)
	EI
	IF	NSPORT
:	Additional entries for SIO ports
	HC	-1,TID.S2,-1,-1,-1,-1,-1,-1
	HC	TID.S1,-1,-1,-1,TID.S7,TID.S3,-1,-1
	HC	TID.S4,TID.S5,TID.S6,-1,-1,-1,-1,-1
	HC	-1,TID.S8,TID.S9,-1,-1,-1,-1,-1
Q	EQ	(.-PVCTID)/2-TIDMAX	:second consistancy check
	IF	Q-TIDMAX
	 ERROR(** BUG ** PVCTID consistancy check,0)
	ELSE	TIDMAX-Q
	 ERROR(** BUG ** PVCTID consistancy check,0)
	EI
	EI	:NSPORT
	HC	TID.40,-1,-1,-1,-1,-1,-1,-1

	DEFAULT(PVCS0,0)


:	Generate PVC messages...Default or substitute...
PVCMS1	PTEXT1				:"Circuit building..."
PVCMS2	PTEXT2				:"circuit lost..."
PVCMS3	PTEXT3				:"ALO user name..."
PVCMS4	PTEXT4				:"ALO password..."
PVCMS5	PTEXT5				:"ALO login string..."

	 IF	NUTXT
Q	EQ	0
	RE	NUTXT
UTXA|Q|	UTXM|Q|
Q	EQ	Q+1
	ER
	 EI	:NUTXT

:	Set up constants in USERNAME and PASSWORD which will be
:		generated for ALO ports.
IPVCUN	HS	0			:USERNAME
	AC	/XXnnnnppppYY/		:n=node number, p=port number
	BC	0			:Termination character
	ORG	IPVCUN+PVCUNL		:...space added for copying

IPVCPW	HS	0			:PASSWORD
	AC	/"BBPppppnnnn/		:semi-colon|P.port number.node number
:	Port and Node-number followed by optional security characters
	 IF	PVCS0
	STEXT0
	 EI	:PVCS0
	AC	/"8D/			:Carriage Return
	BC	0			:Terminator
	ORG	IPVCPW+PVCPWL		:...space added for copying

	 IF	NMPVC
	SUBTTL	MULTIPLEXED PVC TABLES


:	Define Format-table format for MPVC ports:
	D.STRU(0)			:declare beginning of structure

MPF.SP	WS	1			:SUCcess text-string pointer,
MPF.FP	WS	1			:FAIlure text-string pointer,
MPF.IA	HS	1			:INactivity timeout,
MPF.EX	BS	1			:ESCape character,
MPF.BL	BS	1			:BLock character,
MPF.SI	BS	1			:Signal-ID character.
MP.VAR	HS	1			:pointer to variable storage

	D.STRU(-1)			:return to normal address space


:	Pointers to MPVC format tables
Q	EQ	0
MPVCFO	WS	0
	 RE	NMPVC
	WC	.MPF|Q|
Q	EQ	Q+1
	 ER	:NMPVC


:	MPVC Format (and other info) tables (and interleaved text-strings too)
Q	EQ	0
	 RE	NMPVC
	.MMF|Q|
	KILL	.MMF|Q|			:we no longer need this!
:	additional entries...
	HC	MPVV|Q|			:pointer to variable-storage
:	KILL	MPVV|Q|			:we no longer need this either!
Q	EQ	Q+1
	 ER	:NMPVC

:	Build threaded list of MPVC user-names
:		Each entry consists of:
Q	EQ	.
	ORG	0
MPU.PT	WS	1			:Pointer to next entry
MPU.FI	HS	1			:first MPVC port number
MPU.LA	HS	1			:last MPVC port number
MPU.US	BS	0			:User-name string, terminated with zero
	ORG	Q			:return to normal address-space
:	(NOTE...list generated in reverse order so it will be searched forward!)
Q	EQ	0
	RE	.NMUS+1
	 WC	Q
Q	 EQ	.-4
	 HC	.MMB|.NMUS|,.MML|.NMUS|
	 .MM|.NMUS|()
	 KILL	.MMB|.NMUS|,.MML|.NMUS|,.MM|.NMUS|
.NMUS	 EQ	.NMUS-1
	ER	:.NMUS+1
MPVCUS	EQ	Q			:Done...MPVCUS points at start of list

	 EI	:NMPVC
	 EI	:PVC

	EM	:DATA
	SUBTTL	STATIC CONFIGURATION PARAMETERS

	SEG	A.CODE

	MO	.,CONSAT

	LO	DATA


:	Port filters for the CONSAT
:	==== ======= === === ======

:		This code will maintain up to 256 CONSAT ASYNC ports,
:	and a data-rate of approximately 4000 CPS.
:		Service of the CONSAT ports includes all facets of the
:	TYMSHARE terminal.



:	Register usage:

:	RLINK -	Driver link register
:	RP -	port number
:	RP2 -	port number*2
:	RPOL -	Register for polling index
:	RBF -	Link register for WCI
:	RBP -	Buffer-pointer for WCI, GETCHR, PUTCHR, PUTSIG
:	RBC -	Character argument for GETCHR, PUTCHR
:	RCH -	Link register for GETCHR, PUTCHR, PUTSIG
	SUBTTL	GENERAL UTILITY ROUTINES

:	Output Octal String
:	Expects:
:	R0	Number to place
:	R3	Pointer to first byte of string
:	R4	Number of bytes
:	uses R5 for scratch
:	Link	R6
OOS	SIS	R4,1			:Reduce count by 1
	JLR	R6			:exit when done
	LHI	R5,7			:Else set mask
	NR	R5,R0			:Extract digit
	SRLS	R0,3			:And remove it
	AHI	R5,0B0			:"0"
	STB	R5,0,R3,R4		:put digit into memory
	JBS	OOS			:and repeat for next digit

:	Put port-number into preamble message and output it
:	RP -	Port number
:	RP2 -	Port number*2
:	R9 -	Link
MSG0	LR	R0,RP			:get port number
	LA	R3,MS00			:place to put message
	LIS	R4,3			:3-bytes long
	JAL	R6,OOS			:Output-Octal-String
	LA	R6,MS0			:set pointer to message
					:fall through to send message

:	Output a message
:	R9 - link
:	R6 - address pointer to string terminated with 0-byte
:	80 in string means next character signal, don't terminate
:		if it is 0
MSG	LB	RBC,0,R6		:R6 points at next byte of message
	JER	R9
	AIS	R6,1
	THI	RBC,7F
	JEFS	MSG1
	JAL	RCH,PUTCHR
	JBS	MSG
MSG1	LB	R4,0,R6
	AIS	R6,1
	JAL	RCH,PUTSIG		:control in the string
	J	MSG


:	Change BF
:	R0 -	Scratch register
:	R1 -	new value of BF
:	RBP -	Buffer-pointer for change
:	R3 -	Link Register
CHNGBF	LR	R1,R1			:check if making null
	JEFS	CNGBF1			:yes...just skip this part
	RBT	R1,FLAGS		:insure new bit is off
CNGBF1	LHL	R0,BF,RBP		:get old value
	STH	R1,BF,RBP		:set new value
	JER	R3			:old null...just exit
	RBT	R0,FLAGS		:not null...turn off old bit
	JER	R3			:already off...just exit
	SBT	R1,FLAGS		:else turn on new bit
	JR	R3			:and return


:	Special routine to save and change .XSTAT and exit
:	R0 -	New state
XSAVE	L	R1,.XSTAT,RPI		:save old state
	ST	R1,.XSAVE,RPI

:	Special routine to change .XSTAT and exit
:	R0 -	New state
XSTATE	ST	R0,.XSTAT,RPI		:save new state
	J	XRET			:and exit


:	Routine for when port established.
:	Sets up LOGON, outputs messages:
:		Non-PVC:
:			first time:	NPID + PLI
:			Subsequent:	PLI
:		PVC:
:			first time:
:				ALO:		perform logon
:				Non-ALO:	NPID + PLI
:			Subsequent:
:				SLO or ALO:	set it up
:				neither:	PLI
:	RLINK -	link register
:	RPI -	port-table pointer
:	RP2 -	2*port number
:	RP -	port number
CIRBLT	L	RBP,.LGBUF,RPI		:clear logon-buffer
	JAL	RCH,EMPTY		:empty buffer
	TBT	RP,HAFDUX		:is this half-duplex port?
	JEFS	CIRBT1			:no
	LIS	RBC,8			:yes...output ^H
	JAL	RCH,PUTCHR		:...into logon-buffer
CIRBT1	L	RBP,.FTBUF,RPI		:From-terminal buffer-pointer
	JAL	RCH,EMPTY		:empty buffer
	L	RBP,.TTBUF,RPI		:to-terminal buffer-pointer
	JAL	RCH,EMPTY		:empty buffer
	SBT	RP,LOGGER		:Init Logger variables
	SBT	RP,LOGING
	SBT	RP,UNAME		:initially in user-name mode
	TBT	RP,NEWLOG		:is this first or subsequent invocation?
	 IF	PVC
	JE	SLOPVC			:subsequent...set up PVC options
	J	ALOPVC			:first...set up PVC options
	GL	ALOPVC,SLOPVC
	 ELSE	:PVC
	JEFS	CIRBT2			:subsequent...
	TBT	RP,NPIPRT		:new port...
	JNFS	CIRBT2			:skip if shouldn't output NPID
	LA	R6,ULMSG		:yes...
	JAL	R9,MSG			:output common message
	JAL	R9,MSG0			:...folowed by NPID
CIRBT2	LA	R6,PLI			:"Please log in..."
	GL	PLI
	JAL	R9,MSG
	JR	RLINK			:and exit
	 EI	:PVC


:	Go enter DEM
:	RP -	port number
:	RPI -	port table pointer
:	RCH -	link register
GO.EDM	RBT	RP,ECHO			:echo off
	SBT	RP,DEM			:DEM on
	 LO	SIGNAL
	LIS	R4,EDMSIG		:enter DEM
	 FO	SIGNAL
	L	RBP,.FTBUF,RPI		:place into from-terminal buffer
	J	PUTSIG			:exit via PUTSIG
	SUBTTL	IZPORT - INITIALIZE A PORT

:	General-purpose Port/Terminal initializer
:	=============== =========================
:	R5 -	Link register
:	R4 -	VID-entry cursor
:	RPI -	Port-table pointer
IZPORT	STH	R4,.TERMT,RPI		:save terminal-type cursor
	RBT	RP,YONENA		:reset some parameters
	RBT	RP,DEM
	RBT	RP,GBO	
	SBT	RP,NBO
	RBT	RP,E.ESC
	RBT	RP,Q.MODE
	LB	R0,VID.IB,R4
	STB	R0,IBRATE,RP		:set up input baud-rate
	LB	R0,VID.OB,R4
	STB	R0,OBRATE,RP		:set up output baud-rate
	LB	R0,VID.PA,R4		:set parameters A,B,C,D
	STB	R0,PAR.A,RP		:Parameter A
	LB	R0,VID.PB,R4
	STB	R0,PAR.B,RP		:Parameter B
	LB	R0,VID.PC,R4
	STB	R0,PAR.C,RP		:Parameter C
	LB	R0,VID.PD,R4
	STB	R0,PAR.D,RP		:Parameter D
	LHL	R2,VID.FL,R4		:Initialize bit arrays
	LCS	R3,2
IZP1	AIS	R3,2
	LHL	R1,VIDBA,R3
	JEFS	IZP2			:zero terminates list
	RBT	RP,0,R1			:turn the bit off
	SRHLS	R2,1			:test what it should be
	JNCBS	IZP1
	SBT	RP,0,R1			:else set it
	JBS	IZP1

IZP2	ST	R1,.LSTAT,RPI		:set no special status handler
	LA	R0,BASE			:set up base addresses
	LR	R1,R0
	AH	R0,VID.VF,R4		:convert EA to real address
	AH	R1,VID.XF,R4
	 IF	.2HD
	TBT	RP,HD202		:is this a 202 port?
	JEFS	IZP4			:no...proceed
	SBT	RP,HAFDUX		:yes...flag as half-duplex
	LB	R3,VID.TI,R4		:check TID for TID entry
	JEFS	IZP3			:don't change input handler for TID
	LA	R0,ZHDUX		:no, not TID...set alternate input
	L	R1,.XSTAT,RPI		:...keep same output
	JFS	IZP4			:and skip
IZP3	LA	R1,YHDUX		:TID...set alternate output handler
IZP4	 EI	:.2HD
	ST	R0,.VSTAT,RPI		:set state vectors
	ST	R1,.XSTAT,RPI
	TBT	RP,ASCII		:Check for non-ASCII terminals
	JEFS	IZP5
	TBT	RP,HAFDUX		:...or for half-duplex
	JER	R5
IZP5	RBT	RP,LGECHO		:for these, logger doesn't echo
	JR	R5			:and return
	SUBTTL	HALF SECOND LOGIC

:	HALF SECOND PROCESSING
:	==== ====== ==========

	GL	CSHSEC
CSHSEC	LHI	RPOL,(NGRP-2)*2		:for each pair of groups...
:	XON/XOFF Logic.  Give XON/XOFF service where needed.
XNF0	L	R0,RLA,RPOL
	N	R0,ASYNC,RPOL		:must be ASYNC port
	N	R0,XONENA,RPOL
	N	R0,ASCII,RPOL		:ASCII ports only!
	JEFS	XNF2			:nothing to do...
	ST	R0,P.DONE		:keep track of ports serviced
XNF1	L	R0,P.DONE
	JFFO	R0,XNF3			:find port to service
XNF2	SIS	RPOL,4			:end of a ring-group pair
	JGEBS	XNF0			:next ring group
	J	EXDISM,,		:done

XNF3	RBT	R1,P.DONE		:don't look at this port again
	LR	RP,RPOL			:compute port number
	SLLS	RP,3			:(*8 because 8 bits/byte)
	AR	RP,R1
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP,RP		:set pointer to table
	L	RBP,.FTBUF,RPI		:check from-terminal buffer
	LH	R0,BCT,RBP
	SIS	R0,0F
	JGEFS	XNF4			:skip...no reason to send XON
	SBT	RP,XONOUT		:small BCT...maybe send XON?
	JN	XNF1			:XON already out
	LHI	RBC,11			:XON char
	JFS	XNF5			:send XON character
XNF4	SHI	R0,40-0F		:check middle range
	JL	XNF1			:within middle range.  do nothing.
	RBT	RP,XONOUT
	JE	XNF1			:XOFF already out
	LHI	RBC,93			:XOFF char
XNF5	L	RBP,.TTBUF,RPI		:send to terminal
	JAL	RCH,PUTCHR		:...either XON or XOFF character
	J	XNF1			:...and proceed to another port

	 IF	1-NHNGBK
	SUBTTL	TWO-SECOND LOGIC

:	TWO-SECOND PROCESSING
:	=== ====== ==========

	GL	TWOSEC
TWOSEC	LHI	RPOL,(NGRP-2)*2		:for each pair of groups
	LIS	R0,0			:initialization value
:	Hang-on-break logic
TWOS1	L	R1,RLA,RPOL		:active port, which...
	N	R1,ASCII,RPOL		:...is ASYNC port
	N	R1,BRK,RPOL		:...must be in break-state
	N	R1,BRKTO,RPOL		:...and ready to time-out next!
	O	R1,HANGWT,RPOL		:hang these ports
	ST	R1,HANGWT,RPOL
	L	R1,BRKTO1,RPOL		:and update timeouts
	ST	R0,BRKTO1,RPOL
	ST	R1,BRKTO,RPOL
	SIS	RPOL,4			:end of a ring-group pair
	JGE	TWOS1			:next group
	J	EXDISM,,		:done
	 EI	:1-NHNGBK

	 IF	NAPORT
	SUBTTL	SIXTEEN-SECOND LOGIC

:	SIXTEEN-SECOND PROCESSING
:	======= ====== ==========

	GL	SEC16
SEC16	LHI	RPOL,(NGRP-2)*2		:for each pair of groups
	LIS	R0,0			:initialization value
SEC16A	L	R1,RLA,RPOL		:active port, which...
	N	R1,TIDTO,RPOL		:...is ready to time-out next!
	O	R1,HANGWT,RPOL		:hang these ports
	ST	R1,HANGWT,RPOL
	L	R1,TIDTO1,RPOL		:and update timeouts
	ST	R0,TIDTO1,RPOL
	ST	R1,TIDTO,RPOL
	SIS	RPOL,4			:end of a ring-group pair
	JGE	SEC16A			:next group
	J	EXDISM,,		:done
	 EI	:NAPORT
	SUBTTL	RED BALL LOGIC

:	Periodic logic to cancel lost balls
:	Runs every 8 seconds
RBTIME	LHI	RPOL,(NGRP-2)*2		:For all groups
RBTIM1	L	R0,NBO,RPOL
	O	R0,TOPORT,RPOL
	XHI	R0,-1
	N	R0,DEM,RPOL
	N	R0,TBOA,RPOL
	JFFO	R0,RBTIM2		:Find one
	L	R0,TBOB,RPOL
	ST	R0,TBOA,RPOL
	LCS	R0,1
	ST	R0,TBOB,RPOL		:Age the timeouts
	SIS	RPOL,4
	JGE	RBTIM1			:Service next 16 ports
	J	EXDISM,,		:exit

RBTIM2	LR	RP,RPOL			:Port number to RP
	SLLS	RP,3			:*8 because we're counting by 2's
	AR	RP,R1
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP,RP		:get pointer to port table
	RBT	RP,TBOA			:Avoid RBTIM1 loop
	RBT	RP,TBOB			:No red-balls for 8 seconds
	RBT	RP,GBO			:Reset green-ball flag...sending Red
	L	RBP,.FTBUF,RPI		:get from-terminal buffer-pointer
	LO	SIGNAL
	LIS	R4,RBSIG		:flush red-ball down pipe
	FO	SIGNAL
	JAL	RCH,PUTSIG		:send control signal
	J	RBTIM1
	SUBTTL	GREEN BALL LOGIC

:	Runs every 250ms, tries to get out of DEM by sending green balls
GBTIME	LHI	RPOL,(NGRP-2)*2		:For all group pairs...
GBTIM1	LCS	R0,1
	X	R0,TOPORT,RPOL		:no output pending
	N	R0,NBO,RPOL		:and no balls-out
	N	R0,DEM,RPOL		:and in DEM
	N	R0,RLA,RPOL		:and port active
	JFFO	R0,GBTIM2		:skip if a port qualifies
	SIS	RPOL,4			:next group pair...
	JGEBS	GBTIM1
	J	EXDISM,,		:and exit

GBTIM2	LR	RP,RPOL
	SLLS	RP,3			:*8 because 8 bits/byte
	AR	RP,R1
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP,RP
	RBT	RP,TBOB
	RBT	RP,TBOA			:Start green./red-ball timeout
	RBT	RP,NBO			:Show balls-out
	SBT	RP,GBO			:Expecting a return
	LO	SIGNAL
	LIS	R4,GBSIG		:Message type
	FO	SIGNAL
	L	RBP,.FTBUF,RPI		:Get from-terminal buffer-pointer
	JAL	RCH,PUTSIG
	J	GBTIM1
	SUBTTL	CONSAT SIGNAL PROCESSING



:	SIGNAL:  Generalized Signal Processor
:	=======  =========== ====== =========

:	Called from all transmitter to process control signals (in
:		standard fashion).

:	RLINK -	Link register
:	R5 -	Signal to process
:	RBC -	value (if present)
SIGNAL	LHL	R4,SIGDIS,R5,R5		:Get co-routine address
	J	BASE,R4			:go service signal

SIGDIS	HC	EA(TYCRSH)		:00 -	enter TID mode V
	HC	EA(TYCRSH)		:01 -	Baud-rate detected
	HC	EA(TYEXIT)		:02 -	Break-Begin
	HC	EA(TYEXIT)		:03 -	Break-end
	HC	EA(TYEXIT)		:04 -	enter data-mode
	HC	EA(TYEXIT)		:05 -	disconnect
	HC	EA(TYEXIT)		:06 -	set delay V
	HC	EA(TYEXIT)		:07 -	repeat data character
	HC	EA(TYEXIT)		:08 -	Enter DEM
	HC	EA(TYEXIT)		:09 -	Leave DEM
	HC	EA(HANGUP)		:0A -	Hang-up
	HC	EA(S.HANG)		:0B -	Super Hang-up
	HC	EA(ZAPPER)		:0C -	Zapper
	HC	EA(GOOBER)		:0D -	Gobbler
	HC	EA(R.BALL)		:0E -	Red ball
	HC	EA(G.BALL)		:0F -	Green ball
	HC	EA(TYEXIT)		:10 -	Orange ball
	HC	EA(BOUNCE)		:11 -	Yellow ball
	HC	EA(TYEXIT)		:12 -	Gray ball
	HC	EA(BOUNCE)		:13 -	Black ball
	HC	EA(TYEXIT)		:14 -	Enter Transparancy
	HC	EA(TYEXIT)		:15 -	Leave Transparancy
	HC	EA(TYEXIT)		:16 -	Enter ALternate-output-device mode
	HC	EA(TYEXIT)		:17 -	Leave ALternate-output-device mode
	HC	EA(TYEXIT)		:18 -	Unused
	HC	EA(TYEXIT)		:19 -	Unused
	HC	EA(TYEXIT)		:1A -	Unused
	HC	EA(TYEXIT)		:1B -	Unused
	HC	EA(TYEXIT)		:1C -	Unused
	HC	EA(TYEXIT)		:1D -	Unused
	HC	EA(TYEXIT)		:1E -	Unused
	HC	EA(TYEXIT)		:1F -	Unused

	HC	EA(QFPSIG)		:20 -	Set input baud-rate..default - DON'T
	HC	EA(QFPSIG)		:21 -	Query input baud-rate
	HC	EA(QFPSIG)		:22 -	Set output baud-rate..default - DON'T
	HC	EA(QFPSIG)		:23 -	Query output baud-rate
	HC	EA(SFPSIG)		:24 -	Set Parameter A
	HC	EA(QFPSIG)		:25 -	Query Parameter A
	HC	EA(SFPSIG)		:26 -	Set Parameter B
	HC	EA(QFPSIG)		:27 -	Query Parameter B
	HC	EA(SFPSIG)		:28 -	Set Parameter C
	HC	EA(QFPSIG)		:29 -	Query Parameter C
	HC	EA(SFPSIG)		:2A -	Set Parameter D
	HC	EA(QFPSIG)		:2B -	Query Parameter D
	HC	EA(TYEXIT)		:2C -	Unused
	HC	EA(TYEXIT)		:2D -	Unused
	HC	EA(TYEXIT)		:2E -	Unused
	HC	EA(TYEXIT)		:2F -	Unused

	HC	EA(SBPSIG)		:30 -	Set Echo-control
	HC	EA(QBPSIG)		:31 -	Query Echo-control
	HC	EA(SBPSIG)		:32 -	Set Echo control-I
	HC	EA(QBPSIG)		:33 -	Query Echo control-I
	HC	EA(SBPSIG)		:34 -	Set Echo control-H
	HC	EA(QBPSIG)		:35 -	Query Echo control-H
	HC	EA(SBPSIG)		:36 -	Set Echo CR with CR/LF
	HC	EA(QBPSIG)		:37 -	Query Echo CR with CR/LF
	HC	EA(SBPSIG)		:38 -	Set Echo LF with LF/CR/RUB
	HC	EA(QBPSIG)		:39 -	Query Echo LF with LF/CR/RUB
	HC	EA(SBPSIG)		:3A -	Set CR delay
	HC	EA(QBPSIG)		:3B -	Query CR delay
	HC	EA(SBPSIG)		:3C -	Set Parity
	HC	EA(QBPSIG)		:3D -	Query Parity
	HC	EA(SBPSIG)		:3E -	Set Half-duplex
	HC	EA(QBPSIG)		:3F -	Query Half-duplex
	HC	EA(SBPSIG)		:40 -	Set X-Enable
	HC	EA(QBPSIG)		:41 -	Query X-Enable
	HC	EA(SBPSIG)		:42 -	Set Reverse X-Enable
	HC	EA(QBPSIG)		:43 -	Query Reverse X-Enable
	HC	EA(SBPSIG)		:44 -	Set KATAKANA
	HC	EA(QBPSIG)		:45 -	Query KATAKANA
	HC	EA(SBPSIG)		:46 -	Set Terminate-output on break
	HC	EA(QBPSIG)		:47 -	Query Terminate-output on break
	HC	EA(SBPSIG)		:48 -	Set Echo-ESC
	HC	EA(QBPSIG)		:49 -	Query Echo-ESC
	HC	EA(SBPSIG)		:4A -	Set Q-mode
	HC	EA(QBPSIG)		:4B -	Query Q-mode
	HC	EA(TYEXIT)		:4C -	Unused
	HC	EA(TYEXIT)		:4D -	Unused
	HC	EA(TYEXIT)		:4E -	Unused
	HC	EA(TYEXIT)		:4F -	Unused

C.TYCC	EQ	84			:Illegal control signal

:	Illegal control-signal decoded
TYCRSH	ABORT(R8,C.TYCC)		:R5=Control signal



:		Signal processors:
:		====== ==========

:	Green-Ball
G.BALL	RBT	RP,GBO			:are we expecting a green ball?
	JER	RLINK			:no...just exit
	SBT	RP,NBO			:No-balls-out
	RBT	RP,DEM			:not Defered-Echo-Mode
	SBT	RP,ECHO			:Echo
	LO	SIGNAL
	LIS	R4,LDMSIG		:send host Leave-DEM
	FO	SIGNAL
	J	SIGRSP			:send it and exit

:	Red ball
R.BALL	SBT	RP,NBO			:No-balls-out

:	Default exit fo nothing-to-do
TYEXIT	JR	RLINK			:just return

	LO	SIGNAL

:	Set Echo-control
SECHO	NHI	RBC,1			:turn on or off?
	JEFS	SECHO1			:turn off...skip
	TBT	RP,ECHO			:turn on...check ECHO
	JN	QECHO1			:already on, just ACK
	SBT	RP,DEM			:off, let usual mechanism do it
	J	QECHO1			:...and ACK

SECHO1	L	RBP,.FTBUF,RPI		:from-terminal buffer-pointer
	RBT	RP,ECHO			:reset ECHO
	JEFS	SECHO2			:make sure it stays off
	LHI	R4,EDMSIG		:Notify host (EDEC)
	JAL	RCH,PUTSIG
SECHO2	RBT	RP,DEM			:Disarm Green-ball stuff
	RBT	RP,GBO	
	JEFS	SECHO3			:no balls expected, go ACK
	LHI	R4,RBSIG		:GREEN-BALL is out, send RED-BALL
	JAL	RCH,PUTSIG
	RBT	RP,TBOA			:reset the RED-BALL timeouts
	RBT	RP,TBOB
SECHO3	LHI	R5,SECSIG		:Restore signal number

:	Query ECHO
QECHO	LIS	RBC,1			:Prepare for echo on result
	TBT	RP,ECHO			:is ECHO on?
	JNFS	QECHO1			:yes...
	TBT	RP,DEM			:is ECHO about to go on?
	JNFS	QECHO1			:yes, return as on
	LIS	RBC,0			:ECHO not on
QECHO1	LCS	R4,2			:make even
	NR	R4,R5
	J	SIGRSP			:go answer query

:	Set a bit parameter
SBPSIG	LCS	R4,2			:Make even
	NR	R4,R5
	LHL	R3,BPFAN-SECSIG,R4	:get pointer to bit array
	JER	RLINK			:ignore if null
	SBT	RP,0,R3			:turn it on
	NHI	RBC,1			:test new state
	JNFS	QBPSIG			:Done...report it back
	RBT	RP,0,R3			:Else turn it off again
	CLHI	R4,SRXSIG		:special case for reverse X-enable
	JNFS	QBPSIG			:no
	RBT	RP,RXON			:yes...release back-pressure

:	Query a bit parameter
QBPSIG	LCS	R4,2			:Make even
	NR	R4,R5
	LHL	R3,BPFAN-SECSIG,R4	:get pointer to bit array
	JER	RLINK			:ignor if null
	LIS	RBC,0			:Expect to return a zero
	TBT	RP,0,R3			:is bit on?
	JE	SIGRSP			:no...skip
	LIS	RBC,1			:yes...return a 1
	J	SIGRSP


:	Set field parameter
SFPSIG	LCS	R4,2			:Make even
	NR	R4,R5
	LHL	R3,FPFAN-SIRSIG,R4	:get pointer to bit array
	JER	RLINK			:ignor if null
	STB	RBC,0,R3,RP		:set new value

:	Query Field parameter
QFPSIG	LCS	R4,2			:Make even
	NR	R4,R5
	LHL	R3,FPFAN-SIRSIG,R4	:get pointer to Field array
	JER	RLINK			:ignor if null
	LB	RBC,0,R3,RP		:get the parameter

:	Send back response
SIGRSP	L	RBP,.FTBUF,RPI		:set From-terminal buffer-pointer
	JAL	RCH,PUTSIG		:return signal
	JR	RLINK			:Then exit

	FO	SIGNAL

:	Pointers to bit parameters
BPFAN	HC	ECHO			:30 -	Echo control
	HC	ECTLI			:32 -	Echo Control-I
	HC	ECTLH			:34 -	Echo Control-H
	HC	ECR.LF			:36 -	Echo LF on CR
	HC	ELF.CR			:38 -	echo CR|RUB on LF
	HC	CRDE			:3A -	carriage-return delay
	HC	PARITY			:3C -	Parity
	HC	HAFDUX			:3E -	Half-duplex
	HC	XONENA			:40 -	X-Enable
	HC	YONENA			:42 -	Reverse X-Enable
	HC	0			:44 -	KATAKANA
	HC	TSNBRK			:46 -	Terminate output on BREAK
	HC	E.ESC			:48 -	Echo-ESC
	HC	Q.MODE			:4A -	Q-mode
	HC	0			:4C
	HC	0			:4E

:	Pointers to Field parameters
FPFAN	HC	IBRATE			:20 -	Input baud-rate
	HC	OBRATE			:22 -	Output baud-rate
	HC	PAR.A			:24 -	Parameter A
	HC	PAR.B			:26 -	Parameter B
	HC	PAR.C			:28 -	Parameter C
	HC	PAR.D			:2A -	Parameter D
	HC	0			:2C
	HC	0			:2E


:	Super-hang (for Half-Duplex, 2741)
S.HANG	TBT	RP,ASCII		:test if 2741
	JEFS	HANGUP			:do it if so
	RBT	RP,YONENA		:normal ASCII...Disable Reverse-XON
	JER	RLINK			:not set...just exit
	RBT	RP,RXON			:was it applied?
	JER	RLINK			:no...just exit
	L	R0,.XSAVE,RPI		:...else set normal transmitter
	ST	R0,.XSTAT,RPI
	JR	RLINK			:and exit

:	HANG Unconditionally
HANGUP	 IF	PVC
	TBT	RP,TATBIN		:is this special PVC port?
	JEFS	ZAPPER			:yes...HANG translates to ZAPPER
	 EI	:PVC
	SBT	RP,HANGWT		:hang it
	JR	RLINK			:and exit



:	zapper
ZAPPER	JAL	RLINK,CIRDIS		:insure circuit disconnected
	RBT	RP,ECHO			:echo off
	RBT	RP,GBO			:no green-ball out
	SBT	RP,NBO			:no ball out
	RBT	RP,E.ESC		:turn off Echo-ESC
	RBT	RP,Q.MODE		:turn off Q-mode
	RBT	RP,LOGING		:is LOGING set?
	JNFS	ZAP0			:Yes...special case
	JAL	RLINK,ESTPRT		:no...establish new port
	J	XRET			:and exit

ZAP0	LA	R6,LABTMG		:"Logon aborted..."
	JAL	R9,MSG			:(login-ports are hung!)
	JR	RLINK

	LO	SIGNAL
LABTMG	BC	80,SHGSIG		:preface with super-hang
	AC	/"8D"8Alogon aborted...disconnecting"8D"8A/
	BC	80,HNGSIG,0		:append hang, terminator
	FO	SIGNAL


:	Gobbler
GOOBER	RBT	RP,TOSING		:keep this reset
	JR	RLINK

:	Bounce a ball back
BOUNCE	LIS	R4,1			:Return its complement
	XR	R4,R5
	L	RBP,.FTBUF,RPI		:Place in from-terminal buffer
	JAL	RCH,PUTSIG
	JR	RLINK			:then exit

	 IF	NAPORT
	SUBTTL	TERMINAL IDENTIFIER/INITIALIZER

:	ASYNC Terminal-IDentifier and Port-Initializer
:	===== =================== === ================
AVID	JAL	RCH,AGETCH		:get input
	 J	AVID1			:skip if control-signal
	JR	RLINK			:Ignor anything not a control

	LO	SIGNAL
AVID1	CLHI	R5,TIBSIG		:check for TID
	FO	SIGNAL
	JNR	RLINK			:ignore all but those
	CLHI	RBC,0F			:Check for valid Baud-rate index
	JGR	RLINK			:Ignore...not valid
	STB	RBC,IBRATE,RP		:Save input baud-rate guess
	STB	RBC,OBRATE,RP
	JAL	RCH,AGETCH		:get TID char
	 J	0,RLINK			:control-signal...ignor
	LHI	R5,1F			:mask off lower 5 bits of TID char
	NR	R5,RBC
	LB	RBC,IBRATE,RP		:get input baud rate
	EXBR	R5,R5
	OR	RBC,R5			:TID char in next higher byte
	LHI	R4,TID120		:now scan table for match (skip TID entries)
AVID2	AHI	R4,VID.SZ
	LHL	R3,VID.TI,R4
	JNFS	AVID3
	JAL	RBF,A.TID		:Exit...no match found for TID character
	JR	RLINK

AVID3	SR	R3,RBC
	JNBS	AVID2			:continue if no match
	RBT	RP,TIDTO		:id accepted...cancel timeouts
	RBT	RP,TIDTO1
	JAL	R5,IZPORT		:set up terminal
	L	RBP,.TTBUF,RPI		:set to-terminal buffer-pointer
	JAL	RCH,EMPTY		:Clear  the "Please typ..." message
	JAL	R9,A.VID		:set it up
	JAL	RLINK,ESTPRT		:Establish the port with new TID
	J	VRET			:exit back to polling process
	SUBTTL	ASYNC DRIVER CODE -- ASCII

:		This code contains all the port drivers used with the CONSAT
:	module.


:	SIG.A:	Signal Processor for ASYNC
:	=====

:	Called from ASYNC transmitter to process control signals

:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.A	SIGBGN(ETMSIG,LTMSIG,LADSIG)
	SIGEXC(EADSIG,TYEAOD)		:Enter alternate-output-device
	SIGEXC(SIRSIG,SIBRAT)		:Set input baud-rate
	SIGEXC(SORSIG,SOBRAT)		:Set output baud-rate
	SIGEXC(SPASIG,SFPSIG)		:Set Parameter A
	SIGEXC(SPBSIG,SFPSIG)		:Set Parameter B
	SIGEXC(SPCSIG,SFPSIG)		:Set Parameter C
	SIGEXC(SPDSIG,SFPSIG)		:Set Parameter D
	SIGEXC(SECSIG,SECHO)		:Set echo-control
	SIGEXC(QECSIG,QECHO)		:Query echo-control
	SIGEND

:	Set input baud-rate
SIBRAT	TBT	RBC,A.SPED		:is new speed supported?
	JE	QFPSIG			:no...just go respond
	LB	R0,IBRATE,RP		:range-check on current value
	SIS	R0,0A
	JGE	QFPSIG			:>9...don't change it
	STB	RBC,IBRATE,RP		:update input rate
	JAL	RBF,A.IBR
	J	QFPSIG			:go ACK

:	Set output baud-rate
SOBRAT	TBT	RBC,A.SPED		:is new speed supported?
	JE	QFPSIG			:no...just go respond
	LB	R0,OBRATE,RP		:range-check on current value
	SIS	R0,0A
	JGE	QFPSIG			:>9...don't change it
	STB	RBC,OBRATE,RP		:update output rate
	JAL	RBF,A.OBR
	J	QFPSIG			:go ACK

:	Enter-alternate-output-device mode
	 IF	NUMPRN
TYEAOD	CLH	RP,PRTACT		:is this a printer-port?
	JGR	RLINK			:no, so ignore
	LA	R0,XPRINT		:set new driver
	ST	R0,.XSTAT,RPI
	GL	PINIT
	JAL	RCH,PINIT		:initialize printer
	JR	RLINK			:and exit
	 ELSE	:NUMPRN
TYEAOD	EQ	TYEXIT			:just exit
	 EI	:NUMPRN
	SUBTTL	ASYNC DRIVER CODE -- ASCII FULL-DUPLEX

:	Full-Duplex ASCII Terminal Receiver
:	=========== ===== ======== ========
VASCI	JAL	RCH,AGETCH		:get the char
	 J	VAESC			:Control-signal
	LR	R9,RBC			:data -- copy it
	NHI	RBC,7F			:Input Char in R9, Working Char in RBC
	TBT	RP,YONENA		:is XON/XOFF feature enabled?
	JE	VAS2			:Don't check for ^S, ^Q
	CLHI	RBC,11			:^Q=XON
	JEFS	VAS1			:Service ^Q
	CLHI	RBC,13			:^S=XOFF
	JNFS	VAS2			:neither ^Q nor ^S, must be data
	SBT	RP,RXON			:^S...disable transmitter
	JNFS	VAS2			:ignor if already set...then ^S is data
	LA	R0,XASOFF		:Else set XASOFF for transmitter
	J	XSAVE			:...saving current state

VAS1	L	R0,.XSAVE,RPI		:^Q, prepare to restore transmitter
	RBT	RP,RXON
	JN	XSTATE			:disabled...^Q is control

VAS2	TBT	RP,ECHO			:Echoing?
	JN	VAECKO			:yes, take alternate route
	RBT	RP,GBO			:We're not echoing
	JEFS	VASEND			:No green-ball out
	RBT	RP,TBOA
	RBT	RP,TBOB			:Reset red-ball timeout
	 LO	SIGNAL
	LIS	R4,RBSIG		:Red-ball signal
	 FO	SIGNAL
	L	RBP,.FTBUF,RPI		:from-terminal buffer-pointer
	JAL	RCH,PUTSIG		:send signal toward network
	JFS	VSS0

:	Send the data (in R9) into net
VASEND	L	RBP,.FTBUF,RPI		:from-terminal buffer-pointer
VSS0	LR	RBC,R9			:Get the character
	JAL	RCH,PUTCHR		:...and send it
	J	VRET			:and exit

VAECKO	TBT	RP,TOPORT		:is output pending?
	JN	VAED			:Yes, skip echo
	TBT	RP,RXON			:has user applied backpressure?
	JN	VAED			:yes, skip echo
	TBT	RP,HAFDUX		:Half-Duplex?
	JN	VAHD
	TBT	RBC,PABLE		:Is it easily printable?
	JN	VAN			:No, Check special cases

:	Echo (single) character
VAK1	LR	RBC,R9			:Get the character
VAK2	L	RBP,.TTBUF,RPI		:set to-terminal buffer-pointer
	JAL	RCH,PUTCHR		:...and echo it
	J	VASEND			:....then go send it

:	Handler for "Q"-mode
:	Echo "~" and "}"
:	Don't echo LF
:	Echo Cr (with LF) if Echo_on_LF set...
:		THEN ENTER DEM!!!
VAQ	LHI	R0,-7D,RBC		:is it "}"?
	JE	VAN1			:yes...echo it
	SIS	R0,7E-7D		:is it "~"?
	JE	VAN1			:yes...echo it
	LHI	R0,-0A,RBC		:LF?
	JE	VAED			:yes...enter DEM
	SIS	R0,0D-0A		:CR?
	JN	VAN1			:no...treat as non-Q char
	TBT	RP,ELF.CR		:yes...should we echo?
	JE	VAED			:no
	LR	RBC,R9			:yes...echo CR
	JAL	RCH,PUTCHR
	TBT	RP,ECR.LF		:Line-feed needed too?
	JEFS	VAQ1			:no
	LIS	RBC,0A			:yes...echo it
	JAL	RCH,PUTCHR		:echo CR/LF for CR
VAQ1	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
	LR	RBC,R9			:and send the CR
	JAL	RCH,PUTCHR
	JAL	RCH,GO.EDM		:go enter DEM
	J	VRET			:and exit


:	non-printable (?) char on echo...
VAN	TBT	RP,Q.MODE		:"non-printable"...is port in "Q"-mode?
	JN	VAQ			:yes...do it
VAN0	TBT	RBC,SPABLE		:special?
	JE	VAED			:no...go enter DEM
	SIS	RBC,0D			:CR?
	JNFS	VAN1			:not a CR
	TBT	RP,ECR.LF		:Line-feed needed too?
	JE	VAK1			:Echo CR for CR
	LI	R6,8A8D
	J	VAEK1			:echo CR/LF for CR
VAN1	AIS	RBC,0D-0A
	JNFS	VAN2			:Not a LF
	TBT	RP,ELF.CR		:Carriage return needed too?
	JE	VAK1			:echo LF for LF
	LI	R6,0FF8D8A
	J	VAEK1			:echo LF/CR/RUBOUT
VAN2	AIS	RBC,0A-9		:^I?
	JNFS	VAN3
	TBT	RP,ECTLI
	JE	VAED			:Didn't echo tabs
	J	VAK1
VAN3	AIS	RBC,9-8			:^H?
	JNFS	VAN4
	TBT	RP,ECTLH
	JEFS	VAED			:don't echo ^H
	J	VAK1
VAN4	AHI	RBC,1B-9		:ESC?
	JNFS	VAED
	TBT	RP,E.ESC
	JN	VAK1			:Echo-ESC

:	Output-buffer busy - can't echo...enter DEM
VAED	JAL	RCH,GO.EDM		:go enter DEM
	J	VSS0			:send data

:	Echo a (reverse) string of characters in R6
:	(original char in R9)
VAEK1	L	RBP,.TTBUF,RPI		:to-terminal buffer-pointer
VAEK2	LR	RBC,R6			:get a copy
	JAL	RCH,PUTCHR		:echo it
	SRLS	R6,8			:get next character...
	JNBS	VAEK2			:...If any (up to three)
	J	VASEND			:...then go send char and exit

VAHD	TBT	RBC,SPABLE		:Half-duplex...special char?
	JE	VASEND			:no...just go send it
	LHI	R3,-0D,RBC		:Carriage return?
	JNFS	VAHD1			:skip if not
	TBT	RP,ECR.LF		:yes...echo line-feed?
	JE	VASEND			:no...just send char
	LIS	RBC,0A			:else return line-feed
	J	VAK2			:echo it

VAHD1	AIS	R3,0D-0A		:line-feed?
	JN	VASEND			:no, just send char
	TBT	RP,ELF.CR		:yes...echo with CR|RUB?
	JE	VASEND			:no, just send it
	LHI	R6,7F0D			:yes
	J	VAEK1			:echo string of characters

	 LO	SIGNAL
VAESC	CLHI	R5,BBSIG		:Break?
	 FO	SIGNAL
	JNR	RLINK
	L	R0,.VSTAT,RPI		:Save Vstate
	ST	R0,.VSAVE,RPI
	LA	R0,VASBK		:Set VASBK as receiver
	ST	R0,.VSTAT,RPI		:...until we get end-break
	SBT	RP,BRK			:record break occuring
	 IF	1-NHNGBK
	RBT	RP,BRKTO		:insure no early expiration
	SBT	RP,BRKTO1		:...and start timeout
	 EI	:1-NHNGBK
	JR	RLINK


:	Receiver for BREAK-state
:	======== === ===========
:	Hang user if 2 seconds of BREAK, unless NHNGBK set
:	Return to normal ASCII Receiver when we detect end-BREAK
VASBK	JAL	RCH,AGETCH		:Get something (BREAK/end-BREAK signal)
	 J	VASBK1			:control-signal...skip
	JR	RLINK			:non-control...eat it

	 LO	SIGNAL
VASBK1	SIS	R5,BESIG		:end-BREAK?
	JNR	RLINK			:still breaking...just eat signal
	LIS	R4,BBSIG
	 FO	SIGNAL
	L	RBP,.FTBUF,RPI		:set to-net buffer
	JAL	RCH,PUTSIG		:Send BREAK-signal toward network
	L	R0,.VSAVE,RPI
	ST	R0,.VSTAT,RPI		:return to normal receiver
	RBT	RP,BRK			:turn off BREAK-flag
	SBT	RP,ATTN			:turn on ATTN
	TBT	RP,TSNBRK		:Enabled the flush-flag?
	JER	RLINK			:exit if not
	SBT	RP,TOSING		:set the flush-flag
	JR	RLINK			:and exit




:		Transmitters
:		============


:	Transmitter to delay output
:	=========== == ===== ======
XASWT	LIS	R5,3			:set .1 second delay
	JAL	RCH,ADELAY
	J	XDEF			:and defer output


:	Transmitter to service only signals
:	=========== == ======= ==== =======
XASOFF	JAL	RCH,CPEEK		:check for signal pending
	 J	XASWT			:no...delay before trying again


:	Full-duplex ASCII transmitter
:	=========== ===== ===========
XASCI	JAL	RCH,GETCHR		:Get the data
	 J	SIG.A			:normal return...It's a signal
	 IF	NUMPRN			:skip return...data

:	Check for printer port
	CLH	RP,PRTACT
	JGFS	XAS0			:no...just proceed
	CLHI	RBC,82			:yes...old-style set-printer-mode (^B)?
	JE	TYEAOD			:yes...enter-alt.-output-device mode
	 EI	:NUMPRN

XAS0	TBT	RP,TOSING		:Are we tossing data?
	JNR	RLINK			:do this until gobbler resets
:	transmit the character
	LR	R0,RBC			:make another copy of data-char
	NHI	R0,7F			:Remove MSB
	TBT	RP,PARITY		:Parity enabled?
	JEFS	XAS1
	LR	RBC,R0			:yes...set char with parity-bit off
	TBT	R0,PARBIT		:lookup parity
	JEFS	XAS1
	OHI	RBC,80			:turn parity-bit on if appropriate
XAS1	TBT	R0,SPABLE		:is it special?
	JEFS	XAS2			:no...just go output it
	SIS	R0,0D			:Carriage return?
	JE	XASCR
	AIS	R0,0D-0A		:LF?
	JE	XASLF
	AIS	R0,0A-09		:^I?
	JNFS	XAS2			:no
	LH	R0,MARGE,RP2		:yes
	OHI	R0,7			:force position to multiple of 8
	STH	R0,MARGE,RP2

XAS2	JAL	RCH,APUTCH		:transmit the character
	MINH(RBF,MARGE,RP2)		:count it
	JR	RLINK



:	Carriage return
XASCR	TBT	RP,CRDE			:delay needed?
	JE	XAS.PD			:nope...just output (with Parameter D)
	JAL	RCH,APUTCH		:First send it
	LB	R4,PAR.A,RP		:DELAY=MIN(B+N/2**A,CPARAM(C))
	LB	R0,PAR.B,RP		:Parameter B
	LB	R3,PAR.C,RP		:Parameter C
	LB	R5,MARGE+1,RP2		:N/2**A
	SRL	R5,0,R4
	AR	R5,R0
	CLB	R5,CPARAM,R3
	JLEFS	XASCR1
	LB	R5,CPARAM,R3
XASCR1	JAL	RCH,ADELAY		:Set up delay
	JR	RLINK

:	Output CR|LF with parameter D
XAS.PD	JAL	RCH,APUTCH		:send it
	MINH(R5,MARGE,RP2)		:Count it
	LB	R5,PAR.D,RP		:and follow it with Parameter D
	LB	R5,CPARAM,R5
	JAL	RCH,ADELAY
	JR	RLINK


:	Line-Feed
XASLF	TBT	RP,CRDE			:Delay needed?
	JNBS	XAS.PD			:no...output (with Parameter D)
	LB	R3,MARGE+1,RP2		:yes...need to generate LF delay
	JE	XAS2			:...but not if at column 0
	STB	RBC,LASTCH,RP		:save a copy of the character
	CLHI	R3,1
	JGFS	XASLF1
	LB	R5,PAR.A,RP		:Column 1...Delay is Parameter A
	JFS	XASLF3

XASLF1	LB	R5,PAR.C,RP		:DELAY=B+MAX(CPARAM(C)-NCHAR,0)
	LB	R5,CPARAM,R5		:Parameter C
	SR	R5,R3
	JGEFS	XASLF2
	LIS	R5,0
XASLF2	LB	R4,PAR.B,RBP		:add Parameter B
	AR	R5,R4

XASLF3	JAL	RCH,ADELAY		:Set delay
	LB	RBC,LASTCH,RP		:restore the character
	JAL	RCH,APUTCH		:and send line-feed
	JR	RLINK
	SUBTTL	ASYNC DRIVER CODE -- ASCII HALF-DUPLEX

	IF	.2HD


:		*   * ****         ***   ***   ***
:		*   * *   *       *   * *   * *   *
:		***** *   * *****    *  *   *    *
:		*   * *   *         *   *   *   *
:		*   * ****        *****  ***  *****

:	Initial state for HD202 terminals.  Eat input until get EOT (4),
:		ETX(3), or CR.  Set this for TRNCH(RP).
ZHDUX	JAL	RCH,AGETCH		:get the char
	 J	0,RLINK			:ignor control-signals
	LHI	R0,7F
	NR	R0,RBC			:check out the character
	SIS	R0,3			:ETX?
	JEFS	ZHDUX1			:yes
	SIS	R0,4-3			:EOT?
	JEFS	ZHDUX1			:yes
	SIS	R0,0D-4			:CR?
	JNR	RLINK			:ignor all others
	SBT	RP,CARR			:CR...make note of it
ZHDUX1	STB	RBC,TRNCH,RP		:success...set this as turn-around char
	LA	R0,VHDUX		:set subsequent execution address
	ST	R0,.VSTAT,RPI
	J	VHD1			:and skip to finish taking the line

:	HALF-DUPLEX ASCII terminal receiver.
:	=========== ===== ======== ========
VHDUX	JAL	RCH,AGETCH		:Assemble char
	 J	VAESC			:control-signal
	LBR	R9,RBC
	NHI	RBC,7F
	CLB	R9,TRNCH,RP		:line turn-around?
	JN	VHD2
	SIS	RBC,0D			:yes...CARRET?
	JNFS	VHD1			:skip if not
	L	RBP,.FTBUF,RPI		:else send it on
	LR	RBC,R9
	JAL	RCH,PUTCHR
	SBT	RP,CARR			:record CR passage

VHD1	SBT	RP,RTS			:take the line...
	JAL	RBF,A.RS.U		:bring RS up
	SBT	RP,DEM			:force new green-ball handshaking
	RBT	RP,ATTN
	JR	RLINK

VHD2	SIS	RBC,0D			:CARRET?
	JNFS	VHD3
	SBT	RP,CARR			:make note of it
	J	VASEND

VHD3	AIS	RBC,0D-0A		:LINE FEED?
	JNFS	VHD4			:no, send off character
	RBT	RP,CARR			:yes, ignore if after a CARRET
	JNR	RLINK
	AIS	R9,0D-0A		:else change to CARRET
	J	VASEND			:and send it off

VHD4	RBT	RP,CARR
	J	VASEND


:	HALF-DUPLEX ASCII Transmitter.
:	=========== ===== ===========

:	Initial handler to set up states for login
YHDUX	JAL	RBF,A.RS.U		:initially, bring RS up!
	SBT	RP,RTS			:record it on
	L	RBP,.TTBUF,RPI		:place a green-ball at end of TID...
	 LO	SIGNAL
	LIS	R4,GBSIG		:...message to insure line turn-around
	 FO	SIGNAL
	JAL	RCH,PUTSIG
	SBT	RP,DEM			:record that it's there
	J	XHD4			:...then go set up


:	normal transmitter
XHDUX	TBT	RP,XMTF			:Do we have the line?
	JEFS	XHD1			:no...check further
	RBT	RP,ATTN			:is there a reverse-channel request?
	JEFS	XHD2			:no...go service char
	RBT	RP,GBO			:yes...ignore future green-balls
	J	XHD6			:turn line around

XHD1	JAL	RCH,CPEEK		:check if control-signal pending
	 J	XHD3			:no

:	Get next element to service
XHD2	JAL	RCH,GETCHR
	 J	SIG.HD			:control signal
	J	XAS0			:data...use normal handler to send

:	No control-signals pending, and we can't transmit (yet).
XHD3	TBT	RP,RTS			:did line just turn around?
	JEFS	XHD5			:no, delay awhile longer
	LIS	R5,8			:yes, delay 0.25 sec
	JAL	RCH,ADELAY
	JAL	R0,XHSTAT

XHD4	SBT	RP,XMTF			:now we can transmit
XHD5	LIS	R5,3			:3 character times
	JAL	RCH,ADELAY
	J	XHD9			:restore XSTATE and defer output

:	send ETX and/or EOT to turn line around (back to input from terminal).
XHD6	LB	R5,TRNCH,RP
	NHI	R5,7F
	SIS	R5,4
	JEFS	XHD7			:turn-around char is EOT, don't send ETX
	LIS	RBC,3			:ETX
	JAL	RCH,APUTCH		:send it...
	JAL	R0,XHSTAT		:...and dismiss

	LB	R5,TRNCH,RP
	NHI	R5,7F
	SIS	R5,4
XHD7	AIS	R5,4-3
	JEFS	XHD8			:turn-around is ETX, don't send EOT
	LHI	RBC,84			:EOT with parity
	JAL	RCH,APUTCH		:send it...
	JAL	R0,XHSTAT		:...and dismiss

XHD8	LIS	R5,1			:delay until entire char transmitted
	JAL	RCH,ADELAY
	JAL	R0,XHSTAT		:...and dismiss

	JAL	RBF,A.RS.D		:drop request-to-send
	RBT	RP,RTS
	RBT	RP,XMTF			:we can transmit no more

:	Restore to normal transmitter function
XHD9	LA	R0,XHDUX		:restore XSTATE to normal
XHSTAT	ST	R0,.XSTAT,RPI
	J	XDEF			:defer further output


:	SIG.HD:	Signal Processor for half-duplex ASYNC
:	======

:	Called from Half-duplex ASYNC transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.HD	SIGBGN(ETMSIG,LTMSIG,EADSIG,LADSIG)
	SIGEXC(GBSIG,XHDGB)		:Green-ball
	SIGEXC(SIRSIG,SIBRAT)		:Set input baud-rate
	SIGEXC(SORSIG,SOBRAT)		:Set output baud-rate
	SIGEXC(SPASIG,SFPSIG)		:Set Parameter A
	SIGEXC(SPBSIG,SFPSIG)		:Set Parameter B
	SIGEXC(SPCSIG,SFPSIG)		:Set Parameter C
	SIGEXC(SPDSIG,SFPSIG)		:Set Parameter D
	SIGEXC(SECSIG,SECHO)		:Set echo-control
	SIGEXC(QECSIG,QECHO)		:Query echo-control
	SIGEND

	 LO	SIGNAL
:	Green-ball
XHDGB	RBT	RP,DEM			:check DEM
	JER	RLINK			:ignor if none expected
	RBT	RP,GBO
	SBT	RP,NBO
	LIS	R4,LDMSIG		:send LDEC to prevent echo
	L	RBP,.FTBUF,RPI		:from-terminal buffer-pointer
	JAL	RCH,PUTSIG		:send LDEC
	L	RBP,.TTBUF,RPI		:to-terminal buffer-pointer
	LIS	R4,GBSIG		:stuff green-ball back...
	 FO	SIGNAL
	JAL	RCH,PUTSIG		:...to insure activation
	J	XHD6			:turn line around

	EI	:.2HD
	SUBTTL	2741 DRIVER CODE


:	 ***  ***** *  *   **        *  ***  *****  ***  *****
:	*   *    *  *  *    *       *  *   *    *  *        *
:	   *    *   *****   *      *      *    *   ****    *
:	  *    *       *    *     *    *   *  *    *   *  *
:	***** *        *  *****  *      ***  *      ***  *

:	Symbolic names for 2741 control characters (8-bit)
.27CR	EQ	0ED			:CR (New-Line)
.27LF	EQ	0EE			:LF
.27SPC	EQ	0C0			:space
.27TAB	EQ	0AF			:HT
.27DUM	EQ	082			:dummy char (meaningless)
.27EOA	EQ	0B4			:EOA
.27EOT	EQ	0FC			:EOT
.27LC	EQ	09F			:lower-case
.27UC	EQ	09C			:upper-case
.27BS	EQ	0DD			:Back-space
.27IDL	EQ	0BD			:IDLE


:	Initial state for 2741-type terminals if not identified with CR.
:		Then must scan (and eat) input until CR arrives.  Only
:		then can we proceed with normal initialization.
Z2741	JAL	RCH,AGETCH		:Get the next character input
	 J	0,RLINK			:control-signal...ignore
	NHI	RBC,3F			:Reduce to 6-bits
	SHI	RBC,.27CR&3F		:looking for C/R
	JNR	RLINK			:exit if not

:	Got a CR...set up new receive driver
	LA	R3,V2741		:set new address
	ST	R3,.VSTAT,RPI		:...into state-vector
	JR	RLINK			:and exit


:	2741 Receiver.
:	==== ========
V2741	JAL	RCH,AGETCH		:assemble character
	 J	V27BRK			:control signal (BREAK begin or end)
	RBT	RP,EOAF			:if we're expecting EOA,
	JN	VEOA			:this must be it
	LB	R9,VTBA,RP		:translate - table start displacement
	NHI	RBC,3F			:strip stop and parity bits
	AR	R9,RBC
	RBT	RP,SCF			:special-case is good for only one char
	JEFS	V27A
	AHI	R9,80			:set special-case table address
	JFS	V27B
V27A	TBT	RP,UCF			:should this be upper case?
	JEFS	V27B
	AHI	R9,40			:yes...bias pointer to alternate table entry
V27B	LB	R9,T27VC,R9
	THI	R9,80			:high-bit of byte =0 means entry is
V27C	JE	V27C,R9			:	relative...address of special
					:	character processor
	LBR	RBC,R9			:transmit the character
V27D	JAL	RCH,PUTCHR
V27E	LIS	RBC,3			:increment carriage position count
	AHM	RBC,MARGE,RP2		:	(by 3, so we won't have to div)
	JR	RLINK

:	Special character processors:
VSPC	SBT	RP,SCF			:Special (+/-)-case shift
	JBS	V27E			:inc carriage pos on this one

:	CARRET
VCRC	LH	R5,MARGE,RP2		:compute delay
	SRLS	R5,5			:DELAY=((3*#CHAR)/32)+2
	AIS	R5,2
	JAL	RCH,ADELAY
	LHI	RBC,8D			:send a CARRET
	J	V27D

:	BREAK
V27BRK	TBT	RP,XMTF			:are we transmitting?
	JER	RLINK			:no...just ignore breaks
	 LO	SIGNAL
	SIS	R5,BESIG		:this must be ATTN request..
	 FO	SIGNAL
	JNR	RLINK			:wait until it's over (BREAK-end)
	SBT	RP,ATTN			:and set flag for transmitter
	JFS	VXCAL

VEOT	SBT	RP,EOTF			:EOT - tell X2741 that CONSAT
	SBT	RP,XMTF			:can now transmit
VXCAL	L	RBP,.TTBUF,RPI		:to-terminal buffer-pointer
	LHI	RBC,.27DUM		:put a dummy char into the buffer
	JAL	RCH,PUTCHR		:	...to insure X2741 is called

VEOA	RBT	RP,SCF			:EOA...reset this just in case

VLCC	RBT	RP,UCF			:Lower-case shift

VNUL	JR	RLINK


VUCC	SBT	RP,UCF			:Upper-case shift
	JR	RLINK



:	2741 transmitter.
:	==== ===========
X2741	TBT	RP,XMTF			:can we transmit?
	JNFS	X27A			:yes...proceed
	JAL	RCH,CPEEK		:no...any signals pending?
	 J	XDEF			:no...just defer for now
	JFS	X27B			:yes...go get it

X27A	RBT	RP,ATTN			:ATTN request?
	JN	X27ATN			:yes
	RBT	RP,EOTF			:was an EOT received?
	JEFS	X27B
	SBT	RP,DEM			:start the green-ball stuff
	LHI	RBC,.27EOA		:transmit EOA
	J	X27F			:and transmit it

X27B	JAL	RCH,GETCHR		:none of the above - get a char
	 J	SIG.27			:control signal
	NHI	RBC,7F			:mask to 7-bit
	LB	R4,XTBA,RP		:get translate-table start displacement
	LB	RBC,T27XC,RBC,R4	:2741 char now in RBC
	JER	RLINK			:don't output null characters
	CLHI	RBC,.27CR&7F		:is it a CARRET?
	JE	X27CR
	RBT	RP,CARR			:ignor  LF's after CR's
	JEFS	X27C
	CLHI	RBC,.27LF&7F		:LF?
	JER	RLINK
X27C	CLHI	RBC,.27LF&7F		:not CARRET...
	JE	X27LF			:LF not following CR!
	CLHI	RBC,.27SPC&7F		:don't shift case on spaces
	JE	X27E
	CLHI	RBC,.27TAB&7F		: ...or tabs
	JE	X27E
	LHI	R0,9C1F			:test for, and (if needed)...
	TBT	RP,UCF			:...shift to the correct case
	JEFS	X27D
	EXBR	R0,R0			:bit 24 now equals UCF
					:...bits 17-23 contain shift-code
					:	we might need to output
X27D	XR	R0,RBC
	THI	R0,80			:if it's 0, case is right
	JEFS	X27E
	LR	R9,RBC			:else save char...
	EXBR	RBC,R0			:output a case shift
	OHI	RBC,80			:(remembering to set high bit)
	JAL	RCH,APUTCH
	CBT	RP,UCF			:complement current case
	LR	RBC,R9			:restore the character

X27E	LIS	R5,3			:inc position
	AHM	R5,MARGE,RP2
	OHI	RBC,80			:Hi-order bit always=1
X27F	JAL	RCH,APUTCH		:...on chars sent to terminal
	JR	RLINK


:	Special character processors:
X27LF	LIS	R5,1			:Line-feed...preceed with 1 delay,
	JAL	RCH,ADELAY
	LHI	RBC,.27LF		:...then line-feed
	JAL	RCH,APUTCH
	LIS	R5,2			:follow with 2-char delay
	JAL	RCH,ADELAY
	J	XDEF			:...and defer further output for now

X27CR	LHI	RBC,.27CR		:CARRET
	JAL	RCH,APUTCH
	SBT	RP,CARR			:and remember it happened
	LB	R5,MARGE+1,RP2		:compute delay
	SRLS	R5,3
	AIS	R5,2
	JAL	RCH,ADELAY		:else set delay
	J	XDEF			:and defer output this go-roundie

:	SIG.27:	Signal Processor for 2741-transmitter
:	=====

:	Called from X2741 transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.27	SIGBGN(LTMSIG,EADSIG-LADSIG,SPASIG,SPBSIG,SEXSIG-QQMSIG)
	SIGEXC(GBSIG,X27GB)		:Green-ball
	SIGEXC(SHGSIG,HANGUP)		:Super-hang...just hang
	SIGEXC(ETMSIG,X27ETM)		:Enter transparancy
	SIGEXC(SPCSIG,QFPSIG)		:Set Parameter C
	SIGEXC(SPDSIG,QFPSIG)		:Set Parameter D
	SIGEXC(SECSIG,QBPSIG)		:Set Echo-control
	SIGEXC(SCISIG,QBPSIG)		:Set Echo Control-I
	SIGEXC(SCHSIG,QBPSIG)		:Set Echo Control-H
	SIGEXC(SCLSIG,QBPSIG)		:Set Echo LF with LF/CR
	SIGEXC(SLCSIG,QBPSIG)		:Set Echo CR with CR/LF
	SIGEXC(SPRSIG,QBPSIG)		:Set parity
	SIGEXC(SHDSIG,QBPSIG)		:Set half-duplex
	SIGEXC(SXESIG,QBPSIG)		:Set X-enable
	SIGEXC(SRXSIG,QBPSIG)		:Set Reverse X-enable
	SIGEXC(SKKSIG,QBPSIG)		:Set KATAKANA
	SIGEND

X27ATN	RBT	RP,GBO			:ignore future green-balls
	JFS	X27GB1

:	Green-ball
X27GB	RBT	RP,DEM			:check DEM
	JER	RLINK			:no...ignore it
	RBT	RP,GBO
	SBT	RP,NBO
	L	RBP,.FTBUF,RPI		:From-terminal buffer-pointer
	 LO	SIGNAL
	LIS	R4,LDMSIG
	 FO	SIGNAL
	JAL	RCH,PUTSIG		:send LDEC to host
X27GB1	LHI	RBC,.27EOT		:transmit EOT
	L	RBP,.TTBUF,RPI		:...toward terminal
	JAL	RCH,APUTCH
	RBT	RP,XMTF			:CONSAT can no longer transmit
	SBT	RP,EOAF			:tell receiver to expect an EOA
	LIS	R5,7
	JAL	RCH,ADELAY		:delay 7 times after EOT
	JR	RLINK

:	Enter-Transparancy-Mode
X27ETM	LA	R0,VGLASS
	LA	R1,XGLASS
	RBT	RP,SCF
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK
:	2741 transparancy-mode receiver.
:	==== ================= ========
VGLASS	JAL	RCH,AGETCH		:assemble the character
	 J	VGBRK			:control signal (BREAK begin or end)
	L	RBP,.FTBUF,RPI		:From-terminal buffer-pointer
	OHI	RBC,80			:always set Hi-order bit..
	LR	R9,RBC			:save copy of character sent
	JAL	RCH,PUTCHR
	RBT	RP,EOAF			:if we're expecting EOA,
	JN	VLCC			:...this must be it
	CLHI	R9,.27EOT		:keep track of terminal state..
	JNFS	VGLAS1
	SBT	RP,XMTF			:we can transmit now
	SBT	RP,EOTF
	J	VLCC

VGLAS1	CLHI	R9,.27UC		:...and case-shifts
	JE	VUCC
	CLHI	R9,.27LC		:down-shift?
	JE	VLCC
	JR	RLINK

:	ATTN request (BREAK begin or end) detected.
VGBRK	TBT	RP,XMTF			:bit set if CONSAT is transmitting,
	JER	RLINK			:	zero if terminal transmitting
					:	(CONSAT receiving)
	LO	SIGNAL
	SIS	R5,BESIG		:ignor until get BREAK-end
	JNR	RLINK			:not ATTN, discard noise
	L	RBP,.FTBUF,RPI		:From-terminal buffer-pointer
	TBT	RP,TSNBRK		:toss-data on BREAK enabled?
	JEFS	VGBRK1			:not enabled, handle ATTN request
					:	normally
	SBT	RP,TOSING		:alert transmitter to start tossing
					:	output
VGBRK1	SBT	RP,ATTN			:and set bit for transmitter
	JNR	RLINK			:if not first BREAK char, don't send
					:	BREAK to host
	LIS	R4,BBSIG		:send BREAK-begin signal into TYMNET
	JAL	RCH,PUTSIG
	LIS	R4,BBSIG		:...twice!
	FO	SIGNAL
	JAL	RCH,PUTSIG
	JR	RLINK			:done

:	2741 transparancy-mode transmitter.
:	==== ================= ===========
XGLASS	JAL	RCH,GETCHR		:get the character
	 J	SIG.XG			:normal return...control signal
	TBT	RP,TOSING		:are we tossing output?
	JNR	RLINK			:yes - TOSING reset by receipt of
					:	gobbler
	OHI	RBC,80			:set stop-bit
	LR	R9,RBC			:save character
	JAL	RCH,APUTCH		:transmit character to terminal
	RBT	RP,EOTF			:only needed in non-transparancy mode
	CLHI	R9,.27EOT		:EOT transmitted?
	JN	VGLAS1			:no, keep track of shifts
	RBT	RP,ATTN			:if ATTN req pending, it's satisfied
	RBT	RP,XMTF			:terminal now in transmit mode
	SBT	RP,EOAF			:and receiver should expect EOA
	JR	RLINK

:	SIG.XG:	Signal Processor for 2741-Transparancy
:	======
:	Called from XGLASS transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.XG	SIGBGN(ETMSIG,EADSIG-LADSIG,SPASIG,SPBSIG,SEXSIG-QQMSIG)
	SIGEXC(GBSIG,XGGB)		:green-ball
	SIGEXC(SHGSIG,HANGUP)		:Super-hang...just hang
	SIGEXC(ZAPSIG,XGZAP)		:Zapper
	SIGEXC(LTMSIG,XGLTM)		:Leave transparancy-mode
	SIGEXC(SPCSIG,QFPSIG)		:Set Parameter C
	SIGEXC(SPDSIG,QFPSIG)		:Set Parameter D
	SIGEXC(SECSIG,QBPSIG)		:Set Echo-control
	SIGEXC(SCISIG,QBPSIG)		:Set Echo Control-I
	SIGEXC(SCHSIG,QBPSIG)		:Set Echo Control-H
	SIGEXC(SCLSIG,QBPSIG)		:Set Echo LF with LF/CR
	SIGEXC(SLCSIG,QBPSIG)		:Set Echo CR with CR/LF
	SIGEXC(SPRSIG,QBPSIG)		:Set parity
	SIGEXC(SHDSIG,QBPSIG)		:Set half-duplex
	SIGEXC(SXESIG,QBPSIG)		:Set X-enable
	SIGEXC(SRXSIG,QBPSIG)		:Set Reverse X-enable
	SIGEXC(SKKSIG,QBPSIG)		:Set KATAKANA
	SIGEND

:	Green-ball
XGGB	RBT	RP,DEM			:just turn off DEM
	JR	RLINK			:...and ignore

:	Zapper
XGZAP	LA	R0,V2741
	LA	R1,X2741
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	J	ZAPPER			:and proceed with zapper

:	Leave-Transparancy-Mode
XGLTM	LA	R0,V2741
	LA	R1,X2741
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK
:	2741 Receiver conversion tables:

:	Three tables for each terminal type (EBCD or CORRESPONDANCE).
:	Single byte per entry.  Entries with high-order bit on are
:	ASCII code for character, others are P-relative addresses of
:	routines that handle special characters (i.e., case shifts).


	RA	8			:tables are in octal

NUL	EQ	VNUL-V27C		:define relative addresses..
CAR	EQ	VCRC-V27C		:of character processors
UCS	EQ	VUCC-V27C
LLS	EQ	VLCC-V27C
SPS	EQ	VSPC-V27C
ETS	EQ	VEOT-V27C

:	CORRESPONDENCE code:

:	Lower case
T27VC	BC	240,241,364,352,264,357,354,257,265,247,345,360
	BC	NUL,NUL,NUL,NUL,262,256,356,275,372,NUL,NUL,NUL
	BC	266,351,353,361,UCS,210,NUL,LLS,261,355,370,347
	BC	260,363,350,371,267,362,344,273,NUL,CAR,212,211
	BC	263,366,365,346,271,367,342,255,270,341,343,254
	BC	ETS,NUL,NUL,NUL
:	Upper case:
	BC	240,335,324,312,244,317,314,277,245,242,305,320
	BC	NUL,NUL,NUL,NUL,300,256,316,253,332,NUL,NUL,NUL
	BC	333,311,313,321,UCS,210,NUL,LLS,SPS,315,330,307
	BC	251,323,310,331,246,322,304,272,NUL,CAR,212,211
	BC	243,326,325,306,250,327,302,337,252,301,303,254
	BC	ETS,NUL,NUL,NUL
:	Special (+/-) case
	BC	NUL,336,224,212,234,217,214,334,235,340,205,220
	BC	NUL,NUL,NUL,NUL,NUL,374,216,373,232,NUL,NUL,NUL
	BC	236,211,213,221,UCS,NUL,NUL,LLS,NUL,215,230,207
	BC	276,223,210,231,237,222,204,377,NUL,NUL,NUL,NUL
	BC	233,226,225,206,274,227,202,376,375,201,203,NUL
	BC	ETS,NUL,NUL,NUL

:	EBCD code:

:	Lower case:
T27VE	BC	240,255,300,246,270,361,371,350,264,355,365,344
	BC	NUL,NUL,NUL,NUL,262,353,363,342,260,NUL,NUL,NUL
	BC	266,357,367,346,UCS,210,NUL,LLS,261,352,257,341
	BC	271,362,372,351,265,356,366,345,NUL,CAR,212,211
	BC	263,354,364,343,243,244,254,256,267,360,370,347
	BC	ETS,NUL,NUL,NUL
:	Upper case:
	BC	240,337,SPS,253,252,321,331,310,272,315,325,304
	BC	NUL,NUL,NUL,NUL,274,313,323,302,251,NUL,NUL,NUL
	BC	247,317,327,306,UCS,210,NUL,LLS,275,312,277,301
	BC	250,322,332,311,245,316,326,305,NUL,CAR,212,211
	BC	273,314,324,303,242,241,374,336,276,320,330,307
	BC	ETS,NUL,NUL,NUL
:	Special (+/-) case
	BC	NUL,376,NUL,037,375,221,231,210,234,215,225,204
	BC	NUL,NUL,NUL,NUL,333,213,223,202,335,NUL,NUL,NUL
	BC	236,217,227,206,UCS,NUL,NUL,LLS,373,336,334,201
	BC	333,222,232,211,235,216,226,205,377,CAR,NUL,NUL
	BC	233,214,224,203,340,336,377,334,237,220,230,207
	BC	ETS,NUL,NUL,NUL

:	2741 Transmitter conversion tables:

:	ASCII to 2741 code conversion.  One byte per entry.  High-order
:	bit on indicates character is upper case.

:	CORRESPONDENCE code:
T27XC	BC	000,000,000,000,000,000,000,040,135,057,156,000
	BC	000,155,000,000,000,000,000,000,000,000,000,000
	BC	000,000,000,000,000,000,000,000,100,001,311,360
	BC	204,210,350,111,364,344,270,223,273,067,121,007
	BC	144,040,020,160,004,010,130,150,070,064,353,153
	BC	264,023,344,207

	BC	220,371,366,372,252,312,363,243,246,231,303,232
	BC	306,341,322,305,213,333,251,245,202,262,261,365
	BC	342,347,324,330,007,201,001,267,111,171,166,172
	BC	052,112,163,043,046,031,103,032,106,141,122,105
	BC	013,133,051,045,002,062,061,165,142,147,124,264
	BC	001,344,000,075

:	EBCD code:
T27XE	BC	000,000,000,000,000,000,000,040,135,057,156,000
	BC	000,155,000,000,000,000,000,000,000,000,000,000
	BC	000,000,000,000,000,000,000,000,100,365,264,064
	BC	165,350,103,130,344,324,204,303,166,001,067,142
	BC	124,040,020,160,010,150,130,070,004,144,210,360
	BC	220,240,270,342

	BC	202,243,223,363,213,353,333,273,207,347,341,321
	BC	261,311,251,231,371,305,245,322,262,312,252,232
	BC	372,306,246,344,142,324,166,201,330,043,023,163
	BC	013,153,133,073,007,147,141,121,061,111,051,031
	BC	171,105,045,122,062,112,052,032,172,106,046,344
	BC	166,124,267,075

	RA	0			:back to Hex radix

TEBC	EQ	(T27VE-T27VC)^8!(T27XE-T27XC)	:kludge for byte forward refs
	SUBTTL	PRINTER-DRIVER CODE

	 IF	NUMPRN


:	****  ****  ***** *   * ***** ***** ****
:	*   * *   *   *   **  *   *   *     *   *
:	****  ****    *   * * *   *   ****  ****
:	*     *  *    *   *  **   *   *     *  *
:	*     *   * ***** *   *   *   ***** *   *

	GL	SETPRN,PCHAR,PFLUSH

:	SIG.P:	Signal Processor for PRINTER
:	=====

:	Called from PRINTER transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.P	SIGBGN(ETMSIG,LTMSIG,EADSIG)
	SIGEXC(ZAPSIG,PRZAP)		:zapper
	SIGEXC(GOBSIG,PRLAOD)		:gobbler
	SIGEXC(LADSIG,PRLAOD)		:Leave alternate-output-device
	SIGEXC(SIRSIG,SIBRAT)		:Set input baud-rate
	SIGEXC(SORSIG,SOBRAT)		:Set output baud-rate
	SIGEXC(SECSIG,SECHO)		:Set echo-control
	SIGEXC(QECSIG,QECHO)		:Query echo-control
	SIGEND

:	Leave alternate-output-device mode
PRLAOD	JAL	RBF,PFLUSH		:Flush output (if any)
	 NOP	0			:in case skip return
	LA	R0,XASCI		:restore normal handler
	ST	R0,.XSTAT,RPI
	JR	RLINK			:then exit

:	Zapper
PRZAP	JAL	RBF,PFLUSH		:Flush output (if any)
	 NOP	0			:in case skip return
	LA	R0,XASCI		:restore normal handler
	ST	R0,.XSTAT,RPI
	J	ZAPPER			:then proceed with zapper logic



:		PRINTER Driver
:	Copy output from buffer to printer until:
:	1.	Hit a signal,
:	2.	Hit a CR,
:	3.	or Fill a buffer.
:	RP -	Printer (port) number
:	RP2 -	Printer (port) number*2
:	RLINK -	Link register
XPRINT	JAL	RBF,SETPRN		:get current rotor entry
	 J	PRINT1			:output not busy
	JAL	RCH,CPEEK		:Output is busy...
	 J	XDEF			:defer if not a signal pending
					:...else process it!! (may be zapper)

:	Proceed with printing
PRINT1	TBT	RP,TOPORT		:any more data?
	JER	RLINK			:no, exit
	JAL	RCH,GETCHR		:get a character
	 J	SIG.P			:Control-signal
	CLHI	RBC,83			:return-to-terminal-output command (^C)?
	JE	PRLAOD			:yes...leave alternate-output-device mode
	CLHI	RBC,80			:is this a blank compression?
	JL	PRINT3			:jump if so
	CLHI	RBC,8D			:carriage return?
	JNFS	PRINT2			:jump if not
	LIS	RBC,0			:<CR> converts to 0 in new format
	JAL	RBF,PCHAR		:and send it
	 J	XDEF			:defer for now
	J	XDEF			:skip return...defer for now

:	Data char...print it
PRINT2	JAL	RBF,PCHAR		:send it
	 J	PRINT1			:and go on to next char
	J	XDEF			:skip exit...quit for now

:	Blank compression
PRINT3	SIS	RBC,8			:bias because 09 really means one blank
	LHI	R7,-40,RBC		:how many blanks to compress?
	JLFS	PRINT4			:less than 40..send it
	AIS	R7,1			:more than 40...
	LHI	RBC,3F			:send this many first...
	JAL	RBF,PCHAR
	 NOP	0			:don't care about skip returns
	LR	RBC,R7			:this many more
PRINT4	JAL	RBF,PCHAR		:send it
	 NOP	0			:don't care about skip returns
	J	XRET			:skip exit...quit for now

	 EI	:NUMPRN
	SUBTTL	ASYNC ANSWER/HANG CODE

:	Beginning of ENGINE ASYNC driver code, using ENGINE ASYNC card
:	This code is switched off if NAPORT equals 0


:		HANG/ANSWER logic
:		=================

:	This is the environment-independent portion of ASYNC ANSWER/HANG --
:	It performs the following sequence of functions (by port-group):
:	1	Compute new value of CP,
:	2	Compute new value of DSR,
:	3	Compute new value of DTR,
:	4	detects changes to RLA,
:			does Answer and Hang as necessary.

:	Working registers for HANG/ANSWER module
WDTR	EQ	9			:Data Terminal Ready
WDSR	EQ	8			:Data Set Ready
WCP	EQ	7			:Carrier Present
WRLA	EQ	WDTR			:Receiver line active

AHNGAN	ST	R0,QRET			:save return
	LHI	RPOL,(NAGRP-1)*2	:start with last group

:	Note -	in the following, TRUE = 0, FALSE = 1

:	CP= ((CP0!CP1!CP2!CP3)&OLDCP ! CP0&CP1&CP2&CP3)&@HD202
QHA1	LH	WCP,CPSAMP,RPOL
	OH	WCP,NAGRP*2+CPSAMP,RPOL
	OH	WCP,NAGRP*4+CPSAMP,RPOL
	OH	WCP,NAGRP*6+CPSAMP,RPOL	:TRUE if TRUE for all
	NH	WCP,CP,RPOL		:...OR if CPold TRUE
	LH	R1,CPSAMP,RPOL
	NH	R1,NAGRP*2+CPSAMP,RPOL
	NH	R1,NAGRP*4+CPSAMP,RPOL
	NH	R1,NAGRP*6+CPSAMP,RPOL	:TRUE if TRUE for any
	OR	WCP,R1
	 IF	.2HD
	LCS	R1,1
	XH	R1,HD202,RPOL		:@HD202
	NR	WCP,R1
	 EI	:.2HD

:	DSR updated, old used
	LH	WDSR,DSR,RPOL
	LH	R1,NEWDSR,RPOL		:copy new value to current
	STH	R1,DSR,RPOL

:	DTR=((HANGWT!OLDDTR)&@DSR ! CP&@OLDCP)
	LCS	WDTR,1
	XR	WDTR,WDSR		:TRUE only for active line
	LH	R1,HANGWT,RPOL		:TRUE waiting for hanging
	OH	R1,DTR,RPOL		:...OR previously hung
	NR	WDTR,R1
	LCS	R1,1
	XH	R1,CP,RPOL		:@ CPold
	NR	R1,WCP			:...OR CPnew
	OR	WDTR,R1

:	HANGWT=(@DTRnew&HANGWT)
	LCS	R1,1
	XR	R1,WDTR			:FALSE if DTRnew FALSE
	NH	R1,HANGWT,RPOL		:OR HANGWT FALSE
	STH	R1,HANGWT,RPOL		:disable HANGWT
	STH	WDTR,DTR,RPOL
	STH	WCP,CP,RPOL
	OR	WRLA,WDSR
	OR	WRLA,WCP		:RLAnew=@(DTR!DSR!CP)
	XHI	WRLA,-1
	STH	WRLA,AHATMP		:save this

:	detect changes to RLA
QHA2	LHL	R0,AHATMP		:any changes in Receiver Line Active?
	XH	R0,RLA,RPOL
	JFFOH	R0,QHA3			:Anything there?
	SIS	RPOL,2			:for next group
	JGE	QHA1
	L	R0,QRET
	JR	R0			:and exit

:	change to RLA detected for port...
:	figure out which port, change RLA to new value
:	...then decide if answer or hang.
QHA3	LR	RP,RPOL			:Compute port number
	SLLS	RP,3
	AR	RP,R1
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP,RP		:Set up pointer to port table
	CBT	RP,RLA
	JN	QHA6			:Line no longer active...

:	RLA went TRUE (=0)
:	Initialize new port
	SBT	RP,ASYNC		:flag as an ASYNC port
	RBT	RP,BRK			:make sure BREAK off
	SBT	RP,NEWLOG		:set new logon
	SBT	RP,LGECHO		:assume LOGON echoing desired
	RBT	RP,RXON			:reverse X-ON off
	SBT	RP,XONOUT		:init XON already out
	LHI	R3,100			:Initialize the port
	STH	R3,MARGE,RP2
	 IF	PVC
	GL	AIDPVC
	JAL	RLINK,AIDPVC		:Check if PVC Auto-ID port
	 J	QHA4			:normal return...NON-AID...proceed
:	PVC-AID port...
	JAL	R9,A.VID		:set up the port according to TID
	J	QHA2

QHA4	 EI	:PVC
	SBT	RP,TIDTO1		:initiate TID timeout
	LIS	R4,TID30		:assume 30 cps port
	TBT	RP,T120			:Should this be 1200 baud port?
	JEFS	QHA5			:...no
	LHI	R4,TID120		:Yes...set that up
QHA5	JAL	R5,IZPORT		:Initialize the port parameters
	JAL	RLINK,A.ANS		:go answer the port
	JAL	RBF,A.TID		:set up to look for TID
	L	RBP,.TTBUF,RPI		:to-terminal buffer-pointer
	LA	R6,LSMS0		:"Please type your..."
	JAL	R9,MSG			:send message to identify terminal
	J	QHA2

:	RLA went FALSE (=1)...
:	Circuit Disconnected
QHA6	JAL	RBF,A.DSC		:disconnect port
	JAL	RLINK,CIRDIS		:...and disconnect circuit
	RBT	RP,TIDTO
	RBT	RP,TIDTO1		:cancel timeouts
	J	QHA2

LSMS0	TIDMM				:"please type..." or equivalent

	 EI	:NAPORT
	SUBTTL	SIO CODE
	 IF	NSPORT			:SIO-Mother Board optional

:	Make a list of initialization constants
S.ASCI	HC	3,1444
	HC	3,03C1
	HC	3,05EA
	HC	0,0


:	SIO Full-Duplex Input Routine
:	=== =========== ===== =======
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R9 -	Pointer to SIO character
:	RPI -	Pointer to port-table entry
:	RP -	port number
:	RP2 -	port number*2
VSIO	LHI	R8,-.SPORT,RP		:make offset (relative to start of SIO)
	SLLS	R8,2			:make it a word offset
	L	R9,XINSIO,R8		:get pointer to current buffer
	LH	R0,0,R9			:Look at first character
	JL	VDEF			:<0...nothing there, so defer input

:	data present in buffer
	LHI	R0,10,R9		:point at next input buffer
	THI	R0,30			:check if at fold-point
	JNFS	VSIO1
	SHI	R0,40			:fold required
VSIO1	ST	R0,XINSIO,R8		:save buffer-pointer for next time
	SLHLS	R8,3			:make port-pointer into buffer offset
	JAL	RCH,VSECCK		:check if echo will be possible
	JFS	VSIO3			:and skip

:	Check for buffer-end
VSIO2	THI	R9,0F
	JE	VDEF			:buffer exhausted...quit for now

:	Now process all characters in buffer
VSIO3	LH	RBC,0,R9		:get the next character
	TS	0,R9			:Reset cell to -1
	JL	VDEF			:exit if no more data
	AIS	R9,2			:bump pointer to next character
	THI	RBC,100			:test for BREAK
	JEFS	VSIO4			:normal character...skip
	JAL	RCH,SIOBRK		:See if time for BREAK
	J	VSIO2

:	Service normal data-character
:		...Echo character if possible
VSIO4	STB	RBC,CHRSIO		:save the data-character
	LHI	R5,7F			:make a mask
	NR	R5,RBC			:reduce character to 7-bits
	CLHI	R5,13			:Check for XOFF
	JE	VSXOFF			:Do XOFF function
	CLHI	R5,11			:Check for XON
	JE	VSXON			:yes, do XON function
	TBT	RP,ECHO			:echo-able character...Echoing?
	JE	VSNOE1			:no...do ball-logic
	LH	R0,ECOSIO		:is echo permitted?
	JN	VSAED			:can't echo if output present
	L	RBP,.TTBUF,RPI		:set echo buffer in case needed
	TBT	R5,PABLE		:is it printable?
	JN	VSCHK			:no...special processing

:	echo the character
VSIO5	JAL	RCH,PUTCHR		:else echo the character
	J	VSSND			:and go send it

:	Non-echoable character
VSNOEC	TBT	RP,ECHO			:are we echoing?
	JNFS	VSAED			:yes, go enter DEM

VSNOE1	RBT	RP,GBO			:not echoing...
	JEFS	VSSND			:no green balls out
	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
	RBT	RP,TBOA
	RBT	RP,TBOB			:reset red-ball timeouts
	 LO	SIGNAL
	LIS	R4,RBSIG		:Send a RED BALL
	 FO	SIGNAL
	JAL	RCH,PUTSIG		:send RED-BALL to cancel GREEN-BALL
	JFS	VSSND1			:and send character

:	Enter DEM
VSAED	JAL	RCH,GO.EDM		:Enter Defered-Echo-Mode
	JFS	VSSND1			:and skip to send char

:	Pass the character into the network
VSSND	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
VSSND1	LB	RBC,CHRSIO		:get the character
	JAL	RCH,PUTCHR		:...and send it
	J	VSIO2			:now go back and service next element

:	Handler for "Q"-mode
:	Echo "~" and "}"
:	Don't echo LF
:	Echo Cr (with LF) if Echo_on_LF set...
:		THEN ENTER DEM!!!
VSQ	LHI	R0,-7D,R5		:is it "}"?
	JE	VSIO5			:yes...echo it
	SIS	R0,7E-7D		:is it "~"?
	JE	VSIO5			:yes...echo it
	LHI	R0,-0A,R5		:LF?
	JE	VSAED			:yes...enter DEM
	SIS	R0,0D-0A		:CR?
	JN	VSCHK1			:no...treat as non-Q char
	TBT	RP,ELF.CR		:CR...should we echo?
	JE	VSAED			:no...enter DEM
	JAL	RCH,PUTCHR		:echo CR
	TBT	RP,ECR.LF		:Line-feed needed too?
	JEFS	VSQ1			:no
	LIS	RBC,0A			:yes...do it too
	JAL	RCH,PUTCHR
VSQ1	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
	LB	RBC,CHRSIO		:and send the CR
	JAL	RCH,PUTCHR
	JAL	RCH,GO.EDM		:go enter EDM
	J	VSIO2			:and go service next element


:	echo on, non-printable (?) char...
VSCHK	TBT	RP,Q.MODE		:"non-printable"...is port in "Q"-mode?
	JN	VSQ			:yes...perform necessary services
VSCHK1	TBT	R5,SPABLE		:does it require special tests?
	JE	VSAED			:no...just enter DEM
	LHI	R0,-0D,R5		:is it CR?
	JNFS	VSCHK2			:not a CR
	JAL	RCH,PUTCHR		:echo the CR
	TBT	RP,ECR.LF		:need LF?
	JE	VSSND			:no...send it
	LIS	RBC,0A			:yes...echo LF
	J	VSIO5			:Echo LF and proceed
VSCHK2	AIS	R0,0D-0A		:check for LF
	JNFS	VSCHK3			:not a LF
	TBT	RP,ELF.CR		:echo CR|RUB too?
	JE	VSIO5			:Echo LF for LF
	JAL	RCH,PUTCHR		:echo LF...
	LIS	RBC,0D
	JAL	RCH,PUTCHR		:echo CR...
	LCS	RBC,1			:...and RUB
	J	VSIO5			:Echo LF/CR/RUBOUT
VSCHK3	AIS	R0,0A-9
	JNFS	VSCHK4			:not a tab (^I)
	TBT	RP,ECTLI
	JE	VSAED			:Enter DEM, Don't echo tabs
	J	VSIO5			:Echo it
VSCHK4	SIS	R0,9-8
	JN	VSAED			:Unprintable char, enter DEM
	TBT	RP,ECTLH
	JE	VSAED			:Enter DEM for control-H
	J	VSIO5			:Echo it

:	X-ON
VSXON	RBT	RP,RXON			:were they in Wait-State?
	JE	VSNOEC			:no...non-echoable character
	SBT	RP,TAM			:Set driver not full
	L	R0,.XSAVE,RPI		:get previous state
	ST	R0,.XSTAT,RPI		:and set it
	J	VSIO2			:then process next character

:	X-OFF
VSXOFF	TBT	RP,YONENA		:X-OFF...is it enabled?
	JE	VSNOEC			:no, non-echoable character
	SBT	RP,RXON			:yes...set wait-state
	JN	VSNOEC			:already set...non-echoable character
	RBT	RP,TAM			:else set back-pressure to back
	L	R0,.XSTAT,RPI		:save current state
	ST	R0,.XSAVE,RPI
	LA	R0,XASOFF		:...and set new state
	ST	R0,.XSTAT,RPI
	J	VSIO2			:then go service next character
:	Half-Duplex SIO Input Routine
:	=========== === ===== =======
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R7 -	Character from SIO driver
:	R8 -	8-word index
:	R9 -	Pointer to SIO character
:	RPI -	Pointer to port-table entry
:	RP -	port number
:	RP2 -	port number*2
VHSIO	LHI	R8,-.SPORT,RP		:make word offset (relative to SIO ports)
	SLLS	R8,2
	L	R9,XINSIO,R8		:get pointer to current buffer
	LH	R0,0,R9			:Look at first character
	J	VDEF			:<0...nothing there, so defer input

:	data present in buffer
	LHI	R0,10,R9		:point at next input buffer
	THI	R0,30			:check if at fold-point
	JNFS	VHSIO1
	SHI	R0,40			:fold required
VHSIO1	ST	R0,XINSIO,R8		:save buffer-pointer for next time
	SLHLS	R8,3			:make port-pointer into buffer offset
	JAL	RCH,VSECCK		:check echo-ability
	JFS	VHSIO3			:and skip

:	Check for buffer-end
VHSIO2	THI	R9,0F
	JE	VDEF			:buffer exhausted...quit for now

:	Now process all characters in buffer
VHSIO3	LH	R7,0,R9			:get the next character
	TS	0,R9			:Reset cell to -1
	JL	VDEF			:exit if no data there
	AIS	R9,2			:bump pointer to next character
	THI	R7,100			:test for BREAK
	JEFS	VHSIO4			:normal character...skip
	JAL	RCH,SIOBRK		:See if time for BREAK
	J	VHSIO2

:	Service normal data-character
VHSIO4	STB	R7,CHRSIO		:save the character
	LHI	R5,7F			:make a mask
	NR	R5,R7			:reduce character to 7-bits
	TBT	R5,SPABLE		:is it special?
	JNFS	VHSCHK			:yes...special processing

:	Pass the character into the network
VHSSND	LB	RBC,CHRSIO		:get the character
	JAL	RCH,PUTCHR		:...and send it
	J	VHSIO2			:now go back and service next element

:	non-printable character
VHSCHK	CLHI	R5,13			:Check for XOFF
	JE	VHSXOF			:Do XOFF function
	CLHI	R5,11			:Check for XON
	JE	VHSXON			:yes, do XON function
	LHI	R0,-0D,R5		:un-echoable character
	JNFS	VHSCK0			:not a CR
	TBT	RP,ECR.LF
	JE	VHSSND			:just send it
	LIS	R6,0A
	JFS	VHSECO			:Echo LF for CR
VHSCK0	AIS	R0,0D-0A
	JN	VHSSND			:not a LF
	TBT	RP,ELF.CR
	JE	VHSSND
	LI	R6,0FF8D		:echo CR/RUBOUT

:	Echo up to 2 characters
VHSECO	LH	R0,ECOSIO		:See if outputter is busy
	JN	VHSSND			:Output buffer busy...don't echo
	L	RBP,.TTBUF,RPI		:set to-terminal buffer
VHSEC1	LBR	RBC,R6			:get the char
	JAL	RCH,PUTCHR		:and echo it
	SRLS	R6,8			:position the next character
	JNBS	VHSEC1			:repeat if more characters
	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
	J	VHSSND			:and go send the character

:	X-ON
VHSXON	RBT	RP,RXON			:were they in Wait-State?
	JE	VHSSND			:no...non-echoable character
	SBT	RP,TAM			:Set driver not full
	L	R0,.XSAVE,RPI		:get previous state
	ST	R0,.XSTAT,RPI		:and set it
	J	VHSIO2			:then process next character

:	X-OFF
VHSXOF	TBT	RP,YONENA		:X-OFF...is it enabled?
	JE	VHSSND			:no, non-echoable character
	SBT	RP,RXON			:yes...set wait-state
	JN	VHSSND			:already set...non-echoable character
	RBT	RP,TAM			:else set back-pressure to back
	L	R0,.XSTAT,RPI		:save current state
	ST	R0,.XSAVE,RPI
	LA	R0,XASOFF		:...and set new state
	ST	R0,.XSTAT,RPI
	J	VHSIO2			:then go service next character
:	SIO Output Routine
:	=== ====== =======
XSIO	LHI	R9,-.SPORT,RP		:port-number relative to start of SIO
	SLLS	R9,5			:Make an 8-word index
	LHL	R0,OCMSIO,R9		:check command there
	JEFS	XSIO1			:If 0 then not busy
	SIS	R0,4			:if = 4 then busy
	JE	XDEF			:if so, defer output and exit
	LIS	R0,0
XSIO1	STH	R0,OUTSIO,R9		:reset character count
	RBT	RP,SIOSTD		:is there something to do?
	JE	XSIO3			:no...proceed with output
	TBT	RP,YONENA		:yes...is reverse-XON enabled?
	JEFS	XSIO2			:no...turn it off
	SIOIO(R2,XONSIO)		:yes...turn it on
	J	XDEF			:...and defer
XSIO2	SIOIO(R2,XOFSIO)		:no...turn it off
	J	XDEF			:...and defer
XSIO3	JAL	RCH,GETCHR		:get the character
	 J	SICNT			:Control-signal...go process it
	TBT	RP,TOSING		:Data...Are we tossing data?
	JNR	RLINK			:do this until gobbler resets
	LR	R0,RBC			:make another copy of data-char
	NHI	R0,7F			:Remove MSB
	TBT	RP,PARITY		:Parity enabled?
	JEFS	XSIO4
	LR	RBC,R0			:yes...set char with parity-bit off
	TBT	R0,PARBIT		:lookup parity
	JEFS	XSIO4
	OHI	RBC,80			:turn parity-bit on if appropriate
XSIO4	LHL	R7,OUTSIO,R9		:get cursor
	STB	RBC,OUTSIO+2,R7,R9	:put it away
	AIS	R7,1			:bump character count
	STH	R7,OUTSIO,R9		:save cursor
	TBT	RP,TOPORT		:any more?
	JEFS	XSIOX			:no...just terminate
	CLHI	R7,1E			:...any more room?
	JL	XSIO3			:yes...just continue
XSIOX	JAL	R0,X.SIO		:send as appropriate
	J	XRET			:...then exit

:	Control-signal in stream...close output first
SICNT	JAL	R0,X.SIO		:send data as appropriate

:	SIG.SI:	Signal Processor for SIO
:	=====
:	Called from SIO transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.SI	SIGBGN(ETMSIG,LTMSIG,EADSIG,LADSIG,SHGSIG)
	SIGEXC(SPASIG,QFPSIG)		:Set parameter A
	SIGEXC(SPBSIG,QFPSIG)		:Set parameter B
	SIGEXC(SPCSIG,QFPSIG)		:Set parameter C
	SIGEXC(SPDSIG,QFPSIG)		:Set parameter D
	SIGEXC(SECSIG,SECHO)		:Set echo-control
	SIGEXC(QECSIG,QECHO)		:Query echo-control
	SIGEXC(SHDSIG,SIO.HD)		:set HDUX
	SIGEXC(SRXSIG,SIO.RX)		:Set Reverse X-enable
	SIGEND


:	Set XON
SIO.RX	SBT	RP,SIOSTD		:set "something-to-do"
	J	SBPSIG			:...then go to common code

:	set HDUX
SIO.HD	LA	R0,VSIO			:set non-HDX
	NHI	RBC,1			:check new state
	JEFS	SIO.HX			:full...skip
	LA	R0,VHSIO		:half..set it up
SIO.HX	ST	R0,.VSTAT,RPI		:set appropriate handler
	J	SBPSIG			:and proceed

	 IF	BAUDY
:	Half-Duplex BAUDOT SIO

BICF	EQ	UCF			:BAUDOT input case flag...
BOCF	EQ	SCF			:BAUDOT output case flag...
					:	0 -	letter-case
					:	1 -	number-case

.BADLC	EQ	1F			:letter case shift
.BADNC	EQ	1B			:number case shift
.BADLF	EQ	62			:line-feed
.BADCR	EQ	68			:carriage return

:	Half-Duplex BAUDOT SIO Input Routine
:	=========== === ===== =======
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R7 -	Character from SIO driver
:	R8 -	8-word index
:	R9 -	Pointer to SIO character
:	RPI -	Pointer to port-table entry
:	RP -	port number
:	RP2 -	port number*2
VHSBAD	LHI	R8,-.SPORT,RP		:make word offset (relative to SIO ports)
	SLLS	R8,2
	L	R9,XINSIO,R8		:get pointer to current buffer
	LH	R0,0,R9			:Look at first character
	J	VDEF			:negative...nothing there, so defer input

:	data present in buffer
	LHI	R0,10,R9		:point at next input buffer
	THI	R0,30			:check if at fold-point
	JNFS	VHSBA1
	SHI	R0,40			:fold required
VHSBA1	ST	R0,XINSIO,R8		:save buffer-pointer for next time
	SLHLS	R8,3			:make port-pointer into buffer offset
	JFS	VHSBA3			:and skip

:	Check for buffer-end
VHSBA2	THI	R9,0F
	JE	VDEF			:buffer exhausted...quit for now

:	Now process all characters in buffer
VHSBA3	LH	R7,0,R9			:get the next character
	TS	0,R9			:Reset cell to -1
	JL	VRET			:exit if no data there
	AIS	R9,2			:bump pointer to next character
	THI	R7,100			:test for BREAK
	JEFS	VHSBA4			:normal character...skip
	JAL	RCH,SIOBRK		:See if time for BREAK
	J	VHSBA2

:	Service normal data-character
VHSBA4	NHI	R7,1F			:mask down the character
	TBT	RP,BICF			:which case to use
	JEFS	VHSBA5			:letter
	OHI	RBC,40			:number...USE PHILLIPS TRANSLATION TABLE!
VHSBA5	LB	RBC,BAUD.A,R7		:get the ASCII character
	THI	RBC,80			:is this real data?
	JEFS	VHSBA6			:no...skip to interpret
	JAL	RCH,PUTCHR		:yes...pass it on
	J	VHSBA2			:and repeat
VHSBA6	SIS	RBC,1			:special character...
	JGFS	VHSBA7			:letter-shift
	JL	VHSBA2			:0...ignor
	SBT	RP,BICF			:number-case
	J	VHSBA2
VHSBA7	RBT	RP,BICF			:letter-case
	J	VHSBA2


:	Half-Duplex BAUDOT SIO Output Routine
:	=========== ====== === ====== =======
XHSBAD	LHI	R9,-.SPORT,RP		:port-number relative to start of SIO
	SLLS	R9,5			:Make an 8-word index
	LHL	R0,OCMSIO,R9		:check command there
	JEFS	XHSBA1			:If 0 then not busy
	SIS	R0,4			:if = 4 then busy
	JE	XDEF			:if so, defer output and exit
	LIS	R0,0
XHSBA1	STH	R0,OUTSIO,R9		:reset character count
XHSBA2	JAL	RCH,GETCHR		:get the character
	 J	XHSBAC			:Control-signal...go process it
	NHI	RBC,7F			:mask the character
	LB	R0,A.BAUD,RBC		:get the BAUDOT character
	JE	XHSBA5			:ignor nulls
	LHL	R7,OUTSIO,R9		:get cursor
	THI	R0,80			:check for case-independence
	JN	XHSBA4			:send immediately if so
	LHI	R1,(.BADLC^8)!.BADNC!20	:set up case-shift constant
	TBT	RP,BOCF			:check current case
	JEFS	XHSBA3
	EXBR	R1,R1			:other case...swap
XHSBA3	XR	R1,R0			:check the shift required
	THI	R1,20			:check if same case as current
	JEFS	XHSBA4			:skip if OK
	CBT	RP,BOCF			:else change case
	EXBR	R1,R1			:R1 contains case-shift to send
	STB	R1,OUTSIO+2,R7,R9	:send case character
	AIS	R7,1			:bump index
XHSBA4	STB	R0,OUTSIO+2,R7,R9	:put data-character away
	AIS	R7,1			:bump character count
	STH	R7,OUTSIO,R9		:save cursor
XHSBA5	TBT	RP,TOPORT		:any more?
	JEFS	XHSBA6			:no...just terminate
	CLHI	R7,2D			:...any more room?
	JL	XHSBA2			:yes...just continue
XHSBA6	JAL	R0,X.SIO		:send data as appropriate
	J	XRET			:...then exit

:	Control-signal in stream...close output first
XHSBAC	JAL	R0,X.SIO		:send data as appropriate
:	RLINK -	Link register
:	R5 -	Signal to examine
	SIGBGN(EADSIG,LADSIG,SHGSIG,SEXSIG-QQMSIG)
	SIGEXC(ETMSIG,S.BETM)		:enter-transparancy-mode
	SIGEND

:	Enter-Transparancy-Mode
S.BETM	LA	R0,VHSBGD
	LA	R1,XHSBGD
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK


:	Table to translate from BAUDOT to ASCII
:	Look up the ASCII byte indexed by the 5-bit BAUDOT code
:	The BAUDOT must first be OR-ed with
:	with the case...20 = numbers, 0 = letters
:	if the translated 80 bit is on, this is data...
:	else:	0=toss,	1=figure-shift,	2=letter-shift
BAUD.A	AC	\"80E"8AA SIU"8DDRJNFCKTZLWHYPQOBG"01MVX"02\	:letter-shift
B.BAUD	EQ	0			:number-shift:	Vanilla
	AC	\"803"8A- "8787"8D$4',!:(5"A2)2#6019?&"01./"BB"02\
B.CCIT	EQ	1			:number-shift:	CCITT
	AC	\"803"8A- '87"8D"854"87,"80:(5+)2"806019?"80"01./="02\
B.PHIL	EQ	2			:number-shift:	PHILLIPS
	AC	\"803"8A- '87"8D$4"80,"80:(5+)2#6019?&"01./="02\


:	Table for ASCII to BAUDOT translation
:	First, remove MSB, then look up the character.
:	if 0, toss it.	If 80-bit on, case-independent.
:	Else the 20-bit must match the current receive-case
A.BAUD	BC	80,00,00,00,00,00,00,00
	BC	00,00,82,00,00,88,00,00	:case independent
	BC	00,00,00,00,00,00,00,00
	BC	00,00,00,00,00,00,00,00
	BC	64,00,00,34,29,00,3B,25
	BC	2F,32,00,31,2C,23,3C,3D
	BC	36,37,33,21,2A,30,35,27
	BC	26,38,2E,00,00,3E,00,39
	BC	00,43,59,4E,49,41,4D,5A
	BC	54,46,4B,4F,52,5C,4C,58
	BC	56,57,4A,45,50,47,5E,53
	BC	5D,55,51,00,00,00,00,00
	BC	00,43,59,4E,49,41,4D,5A
	BC	54,46,4B,4F,52,5C,4C,58
	BC	56,57,4A,45,50,47,5E,53
	BC	5D,55,51,00,00,00,00,00
:	Transparant (glass) Half-Duplex BAUDOT SIO

:	Half-Duplex BAUDOT SIO Input Routine
:	=========== === ===== =======
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R7 -	Character from SIO driver
:	R8 -	8-word index
:	R9 -	Pointer to SIO character
:	RPI -	Pointer to port-table entry
:	RP -	port number
:	RP2 -	port number*2
VHSBGD	LHI	R8,-.SPORT,RP		:make word offset (relative to SIO ports)
	SLLS	R8,2
	L	R9,XINSIO,R8		:get pointer to current buffer
	LH	R0,0,R9			:Look at first character
	J	VDEF			:negative...nothing there, so defer input

:	data present in buffer
	LHI	R0,10,R9		:point at next input buffer
	THI	R0,30			:check if at fold-point
	JNFS	VHSBG1
	SHI	R0,40			:fold required
VHSBG1	ST	R0,XINSIO,R8		:save buffer-pointer for next time
	SLHLS	R8,3			:make port-pointer into buffer offset
	JFS	VHSBG3			:and skip

:	Check for buffer-end
VHSBG2	THI	R9,0F
	JE	VDEF			:buffer exhausted...quit for now

:	Now process all characters in buffer
VHSBG3	LH	R7,0,R9			:get the next character
	TS	0,R9			:Reset cell to -1
	JL	VRET			:exit if no data there
	AIS	R9,2			:bump pointer to next character
	THI	R7,100			:test for BREAK
	JEFS	VHSBG4			:normal character...skip
	JAL	RCH,SIOBRK		:See if time for BREAK
	J	VHSBG2

:	Service normal data-character
VHSBG4	NHI	R7,1F			:mask down the character
	CLHI	R7,.BADLC		:letter-case?
	JNFS	VHSBG5			:no
	RBT	RP,BICF			:yes...set letter-case
	JFS	VHSBG6			:go send it
VHSBG5	CLHI	R7,.BADNC		:number-case?
	JNFS	VHSBG6			:no
	SBT	RP,BICF			:yes...set number-case
VHSBG6	LHI	RBC,0E0,R7		:insure high-order bits are set
	JAL	RCH,PUTCHR		:send it along
	J	VHSBG2


:	Half-Duplex BAUDOT SIO Output Routine
:	=========== ====== === ====== =======
XHSBGD	LHI	R9,-.SPORT,RP		:port-number relative to start of SIO
	SLLS	R9,5			:Make an 8-word index
	LHL	R0,OCMSIO,R9		:check command there
	JEFS	XHSBG1			:If 0 then not busy
	SIS	R0,4			:if = 4 then busy
	JE	XDEF			:if so, defer output and exit
	LIS	R0,0
XHSBG1	STH	R0,OUTSIO,R9		:reset character count
XHSBG2	JAL	RCH,GETCHR		:get the character
	 J	XHSBG6			:Control-signal...go process it
	NHI	RBC,1F			:mask the character
	CLHI	RBC,.BADNC		:record case-shifts
	JNFS	XHSBG3
	RBT	RP,BOCF
	JFS	XHSBG4
XHSBG3	CLHI	RBC,.BADNC		:record case-shifts
	JNFS	XHSBG4
	SBT	RP,BOCF
XHSBG4	LHL	R7,OUTSIO,R9		:get cursor
	STB	R0,OUTSIO+2,R7,R9	:put data-character away
	AIS	R7,1			:bump character count
	STH	R7,OUTSIO,R9		:save cursor
	TBT	RP,TOPORT		:any more?
	JEFS	XHSBG5			:no...just terminate
	CLHI	R7,2E			:...any more room?
	JL	XHSBG2			:yes...just continue
XHSBG5	JAL	R0,X.SIO		:send data as appropriate
	J	XRET			:...then exit

:	Control-signal in stream...close output first
XHSBG6	JAL	R0,X.SIO		:transmit as appropriate
:	RLINK -	Link register
:	R5 -	Signal to examine
	SIGBGN(ETMSIG,EADSIG,LADSIG,SHGSIG,SEXSIG-QQMSIG)
	SIGEXC(ZAPSIG,S.BZAP)		:Zapper
	SIGEXC(LTMSIG,S.BLTM)		:leave transparancy
	SIGEND

:	Zapper
S.BZAP	LA	R0,VHSBAD
	LA	R1,XHSBAD
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	J	ZAPPER			:and proceed with zapper

:	Leave-Transparancy-Mode
S.BLTM	LA	R0,VHSBAD
	LA	R1,XHSBAD
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK

	 EI	:BAUDY
	SUBTTL SIO UTILITY FUNCTIONS

:	Check if echo is permitted...ECOSIO is -1 if not
:	R8 -	8-word offset for port
:	RP -	Actual port number
:	RCH -	link register
VSECCK	TS	ECOSIO			:default is no-echo
	TBT	RP,TOPORT		:check buffer toward port
	JNR	RCH			:can't echo if output present
	LHL	R0,OCMSIO,R8		:See if outputter is busy
	JEFS	VSECC1			:skip if not
	SIS	R0,4			:if command=4 then busy
	JER	RCH			:Output buffer busy...can't echo
	LIS	R0,0
VSECC1	STH	R0,ECOSIO		:set echo-possible
	JR	RCH			:and return


:	SIO Break-handling logic
:	RCH -	link register
SIOBRK	SBT	RP,D.PAS1		:See if time for BREAK
	JNR	RCH			:ignor if already sent
	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
	 LO	SIGNAL
	LIS	R4,BBSIG		:Send BREAK-signal
	 FO	SIGNAL
	TBT	RP,TSNBRK		:enable the flush-flag?
	JE	PUTSIG			:no...exit by sending it
	SBT	RP,TOSING		:yes...set the flush-flag
	J	PUTSIG			:and exit by sending it


:	Transmit an SIO buffer
:	R0 -	Link register
:	R9 -	offset for SIO tables
:	R3,R4 -	scratch registers
X.SIO	LH	R3,OUTSIO,R9		:check if any data buffered
	JER	R0			:no...just exit
	LIS	R3,4			:else set command
	STH	R3,OCMSIO,R9
	SIOIO(R3,OCMSIO`,R9)		:perform output
	JR	R0			:...then exit
	SUBTTL	SIO HANG/ANSWER

:	SIO HANG/ANSWER
:	=== ===========
:	1 second logic to check for changes in receiver active
	GL	BRKSIO,QHASIO,Q.SHNG,Q.SANS
QHASIO	LHI	RP,.SPORT-1		:For SIO-ports
QHANS1	AIS	RP,1			:For next port
	CLHI	RP,.SPORT+NSPORT	:Last port?
	JGE	EXDISM,,		:yes...done
	TBT	RP,GOTSIO		:service ports which are there
	JEBS	QHANS1			:nothing to do for this port
	LR	RP2,RP			:compute 2*port number
	AR	RP2,RP2
	LHL	RPI,.PTP.,RP,RP		:set port-table pointer
	LHI	R2,-.SPORT,RP		:port number relative to .SPORT
	LR	R1,R2
	AR	R2,R2			:2*relative port number
	SLHLS	R1,5			:make 8-word index
	LB	R0,STASIO,R1		:get status
	CLHI	R0,0FF			:get this when unplugged
	JE	QHANS4
	THI	R0,028			:these off?
	JE	QHANS4
	TBT	RP,HANGWT
	JN	QHANS5			:Yes, then try to hang
	SBT	RP,RLA			:was he off?
	JN	QHANS1			:was on, continue
:	Now initialize this port
	SBT	RP,XONOUT		:Init XON already out
	SBT	RP,NEWLOG		:...New logon
	SBT	RP,LGECHO		:...assume logon-echo required
	RBT	RP,RXON			:...reverse X-ON off
	RBT	RP,D.PAS1		:...not in break-state
	RBT	RP,D.PAS2
:	we're playing funny games with addressing, since SIO card
:		expects addresses/10x, and we're obliging it.
	LA	R3,OUTSIO,R1		:get output data quad-address
	LIS	R0,0
	ST	R0,0,R3			:make sure output buffer shows 0 data
	SRLS	R3,4			:now make address into SIO space
	ST	R3,OCMSIO,R1		:set it
	LA	R3,INPSIO,R1,R1		:get start of data area
QHANS2	TS	0,R3			:Init it word by word
	AIS	R3,2			:...to no data-present
	THI	R3,3F
	JNBS	QHANS2
	LA	R0,INPSIO/10+40000,R2,R2 :make a command
Q	EQ	0
	 RE	4
	ST	R0,ICMSIO+Q,R1		:put it away
	AIS	R0,1			:next one
Q	EQ	Q+4
	 ER
	LI	R0,ICMSIO/10+20000,R2	:make a jump command
	ST	R0,ICMSIO+10,R1		:store it
	JAL	RLINK,Q.SANS		:and start it
	SBT	RP,TAM			:reset backpressure
	LA	R0,INPSIO,R1,R1		:set pointer to first buffer
	SRLS	R1,3			:make quad-buffer index
	ST	R0,XINSIO,R1		:set up input index
	L	RBP,.TTBUF,RPI		:set to-terminal buffer-pointer
	JAL	RCH,EMPTY		:empty buffer
	LHI	R4,TID.S		:set as SIO-type terminal
	JAL	R5,IZPORT		:go set it up
	JAL	RLINK,ESTPRT		:...and establish the port
	J	QHANS1			:continue

QHANS4	RBT	RP,HANGWT		:Hardware off so reset soft hang
QHANS5	RBT	RP,RLA			:was it off?
	JE	QHANS1			:yes...continue
:	Circuit disconnected
	JAL	RLINK,Q.SHNG		:go and get it hung for us
	J	QHANS1

:	SIO BREAK-DETECT
:	=== ===== ======

:	2.5 second logic to check for BREAK timeout
:	This is the environment-independent portion of SIO break timeout
:	(since the SIO card doesn't detect break-begin or break-end,
:	we must fake it with a timeout, to insure we can recognize the
:	end-of-break state.)
BRKSIO	LHI	RPOL,(.SPORT/8)+(NSGRP*2)-2	:For all SIO groups...
BRKS1	LH	R1,RLA,RPOL		:Service ports that are on line
	NH	R1,GOTSIO,RPOL		:...and are there
	NH	R1,D.PAS1,RPOL		:....and which are PAS1
	STH	R1,P.DONE		:put it away
BRKS2	LH	R1,P.DONE		:More to do?
	JFFOH	R1,BRKS3		:yes...skip
	SIS	RPOL,2			:else repeat for all groups
	CLHI	RPOL,.SPORT/8		:SIO starts at this group
	JGE	BRKS1
	J	EXDISM,,		:Done...return

BRKS3	RBT	R2,P.DONE		:flag port processed
	LR	RP,RPOL			:compute real port number
	SLLS	RP,3
	AR	RP,R2			:make port number
	CBT	RP,D.PAS2,RPOL		:Switch PAS2
	JE	BRKS2			:was 0....continue
	RBT	RP,D.PAS1,RPOL		:Else turn off PAS1
	RBT	RP,D.PAS2,RPOL		:and return PAS2
	J	BRKS2
	 EI	:NSPORT


	FO	DATA
	EM	:CONSAT
	SUBTTL	MULTIPLEXED PVC'S

	 IF	NMPVC

	GL	MPSCAN,M.MUX,M.DMX	:definitions
	GL	M.PER
	GL	IGCSCN,GCSCN,AIDPVC	:References
	GL	LGRET,CIRDSC,M.SACT,ZAPPER

	MO	.,MPVC

	LO	DATA

:		MPVC User-name Scanner
:	The MPVCUS STRING may contain the following "wild" characters:
:	"|"	Match ANY valid user-name character.  Will not match
:		user-name terminator characters (":", "semi-:", <CR>).
:	"}"	END-OF-MPVCUS!  Encountering this character during the
:		matching process signals successful matching of username,
:		even if entire username has not yet been scanned.  (Also
:		matches user-name terminator characters).

:	RBP -	From-terminal buffer-pointer
:	RPI -	Port-table pointer
:	RP -	Port-number
:	RP2 -	Port-number*2
:	RLINK -	Link register -- return if no match
MPSCAN	TBT	RP,UNAME		:only interested if in user-name field
	JER	RLINK			:password...exit
	TBT	RP,MPVC.C		:Is this port a MPVC candidate?
	JER	RLINK			:others have normal service
	L	RBP,.LGBUF,RPI		:ok...set logon buffer-pointer
	LA	R9,MPVCUS		:set pointer to start of list
	JFS	MPVCS2			:skip to begin search

MPVCS1	L	R9,MPU.PT,R9		:get new list-pointer
	JER	RLINK			:list exhausted...return
MPVCS2	LIS	R6,MPU.US-1		:...else set cursor
	JAL	RBF,IGCSCN		:set first character in buffer
	 J	0,RLINK			:unexpected normal return...quit

MPVCS3	JAL	RBF,GCSCN		:get next character in buffer
	 J	0,RLINK			:unexpected termination...quit
	NHI	RBC,7F			:reduce to 7-bit
	LHI	R0,-0D,RBC		:set R0=0 for CR
	JEFS	MPVCS4
	CLHI	RBC,20			:ignore all other control-characters
	JLBS	MPVCS3
	AHI	R0,0D-3B		:set R0=0 for semi-colon
	JEFS	MPVCS4
	AIS	R0,3B-3A		:...or for ":"
	JEFS	MPVCS4
	CLHI	RBC,60			:check for lower-case
	JLFS	MPVCS4			:skip if not
	SHI	RBC,20			:else convert to upper-case
MPVCS4	AIS	R6,1			:advance cursor
	LB	R5,0,R6,R9		:and get next character in list-entry
	JE	MPVCS7			:skip if end-of-string
	NHI	R5,7F			:convert to 7-bit
	CLHI	R5,60			:check if lower-case
	JLFS	MPVCS5			:no
	SHI	R5,20			:yes...force to upper-case
MPVCS5	CLHI	R5,75			:"}" ?
	JE	MPVCS8			:yes
	CLHI	R5,74			:"|" ?
	JNFS	MPVCS6			:no...chars must match
	LR	R0,R0			:yes...match anything but terminator
	JN	MPVCS3			:match succeeded
	J	MPVCS1			:match failed
MPVCS6	CR	R5,RBC			:characters MUST match!
	JE	MPVCS3			:yes!
	J	MPVCS1			:no...abort this entry

MPVCS7	LR	R0,R0			:check if terminator
	JN	MPVCS1			:no...abort ths entry, go on to next

:: ***	NOTE -- MPVCUS TABLE CONTAINS RANGE OF PORT NUMBERS...
:: ***	CURRENTLY WE ONLY USE FIRST ONE!!!!!
MPVCS8	LHL	R1,MPU.FI,R9		:success...get MPVC port number
	LR	R5,R1
	SLLS	R5,2			:PORT # * 4
	L	R5,MPVCFO,R5		:look up pointer
	LHL	R6,MP.VAR,R5		:get pointer to variables
	SBT	RP,MPV.AP,R6		:set this port active for MPVC
	LIS	R0,1
	AHM	R0,MPV.PA,R6
	AHM	R0,MPV.LP,R6		:count another logon
	LHI	R0,.MPORT,R1		:set actual MPVC port number
	STH	R0,MPV.T1		:save it for now
	LHI	R1,BFA(TOMPVC),R1	:compute new BF for this port
	L	RBP,.FTBUF,RPI
	JAL	R3,CHNGBF
	L	R6,MPF.SP,R5		:get success message
	L	RBP,.TTBUF,RPI		:place into to-terminal buffer
	JAL	R9,MSG
	JAL	RLINK,CIRDSC		:disconnect port
	LHL	RP,MPV.T1		:set up MPVC now
	SBT	RP,RLA			:is MPVC active?
	JN	LGRET			:yes...just exit to logon polling
	LR	RP2,RP			:no...set up for the PVC port
	AR	RP2,RP2
	LHL	RPI,.PTP.,RP,RP
	JAL	RLINK,AIDPVC		:perform AID
	J	.			:normal return...error!
					:skip return...port established
	J	LGRET			:exit to logon polling
	SUBTTL	Multiplexed PVC -- Periodic logic

:	RP -	MPVC port number
:	RP2 -	2*MPVC port number
:	RPI -	MPVC port port-table pointer
:	RPOL -	Polling index
:	RLINK -	MPVC port format-table pointer
:	R9 -	MPVC port variable-block pointer


:		MPVC PERiodic logic
:		==== ======== =====
:	On time-out list, runs every 1.0 seconds
M.PER	LHI	RP,.MPORT		:for all MPVC ports...
M.PER1	TBT	RP,RLA			:is this port active?
	JNFS	M.PER3			:yes...service it
M.PER2	AIS	RP,1			:done...next MPVC port
	CLHI	RP,.MPORT+NMPVC
	JLBS	M.PER1
	J	EXDISM,,		:done...exit

:	active MPVC port...service it
M.PER3	LR	RP2,RP
	AR	RP2,RP2
	L	RLINK,MPVCFO-(4*.MPORT),RP2,RP2 :set format-table pointer
	LHL	R9,MP.VAR,RLINK		:set variable-area pointer
	LH	R0,MPV.PA,R9		:are any ports active?
	JEFS	M.PER4			:no...check out why
	AHM	R0,MPV.PS,R9		:yes...update port-second accumulation
	LIS	R0,0			:cancel timeouts
	ST	R0,MPV.TO,R9
	J	M.PER2			:and quit

:	Nothing active...check timeout
M.PER4	L	R0,MPV.TO,R9		:when should time expire?
	JNFS	M.PER5			:something there
	L	R0,SLOWC,,		:nothing there yet...start time-out
	AH	R0,MPF.IA,RLINK		:"now" + inactivity timer
	ST	R0,MPV.TO,R9
M.PER5	S	R0,SLOWC,,		:has timeout expired?
	JGE	M.PER2			:not yet...just wait a while
	LHL	RPI,.PTP.,RP,RP		:yes...set port-table pointer
	JAL	R5,M.SACT		:terminate accounting
	JAL	RLINK,CIRDIS		:disconnect circuit
	RBT	RP,RLA			:set port not-active
	J	M.PER2			:and exit
	SUBTTL	Multiplexed PVC -- Multiplexer

:	RP -	MPVC port number
:	RP2 -	2*MPVC port number
:	RPI -	MPVC port port-table pointer
:	RPOL -	Polling index
:	RLINK -	MPVC port format-table pointer
:	R9 -	MPVC port variable-block pointer


:		MPVC MUX
:		==== ===
:	On time-out list, runs every .25 seconds
M.MUX	LHI	RP,.MPORT		:for all MPVC ports...
M.MUX1	TBT	RP,RLA			:is this port active?
	JNFS	M.MUX3			:yes...service it
M.MUX2	AIS	RP,1			:done...next MPVC port
	CLHI	RP,.MPORT+NMPVC
	JLBS	M.MUX1
	J	EXDISM,,		:done...exit

:	active MPVC port...service it
M.MUX3	LR	RP2,RP
	AR	RP2,RP2
	LHL	RPI,.PTP.,RP,RP		:set master port-table pointer
	L	RLINK,MPVCFO-(4*.MPORT),RP2,RP2 :set format-table pointer
	LHL	R9,MP.VAR,RLINK		:set variable-area pointer
	LIS	RPOL,(NGRP-2)*2		:prepare to poll all ports on this MPVC

:	Poll all ports for this MPVC
M.MUX4	L	R0,TOMPVC,RPOL		:data present
	N	R0,MPV.AP,RPOL,R9	:...on active port
	JFFO	R0,M.MUX5		:skip if anything there
	SIS	RPOL,4			:repeat for all groups
	JGEBS	M.MUX4
	J	M.MUX2			:...then proceed to next port

:	Found an active port (sub-channel)...service it
M.MUX5	LR	R0,RPOL			:compute port number
	SLLS	R0,3
	AR	R0,R1
	STH	R0,MPV.CI		:set current input port
	L	RBC,.FTBUF,RPI		:MPVC From-terminal Buffer-pointer
	LB	RBC,MPF.BL,RLINK	:New-block indicator
	JAL	RCH,PUTCHR
	LHL	RBC,MPV.CI		:port-number
	JAL	RCH,PUTCHR
	LHL	RBC,MPV.CI		:port-number
	LHL	R4,.PTP.,RBC,RBC	:sub-channel port-descriptor
	LA	R5,TOMPVC		:assume continuing port
	L	R6,.FTBUF,R4
	ST	R6,MPV.T2		:origination buffer
	STH	R5,MPV.T3		:Flag array
	RBT	RBC,LOGING		:New port?
	JE	M.MUX6			:no...just copy data
	LA	R5,GOLOG		:yes...data from login-buffer
	L	R6,.LGBUF,R4
	LHL	R4,.TERMT,R4		:locate terminal-type descriptor
	LB	RBC,VID.ID,R4		:and terminal NID
	STB	RBC,MPV.T1		:save TID
	ST	R6,MPV.T2		:origination buffer
	STH	R5,MPV.T3		:Flag array
	LB	RBC,MPF.SI,R9		:signal new port
	JAL	RCH,PUTCHR
	 LO	SIGNAL
	LIS	RBC,CNTSIG		:"connect"
	 FO	SIGNAL
	JAL	RCH,PUTCHR
	LB	RBC,MPV.T1		:get the TID
	JAL	RCH,PUTCHR		:sent it too

:	Move the data
M.MUX6	LHL	R0,MPV.CI		:current port
	LHL	R7,MPV.T3		:bit-array pointer
	TBT	R0,0,R7			:any more data there?
	JE	M.MUX4			:no...proceed to other ports
	L	RBP,MPV.T2		:yes...from-terminal buffer-pointer
	JAL	RCH,GETCHR
	 J	M.MUX9			:Signal! - go encode it
	L	RBP,.FTBUF,RPI		:MPVC From-terminal Buffer-pointer
	CLB	RBC,MPF.BL,RLINK	:need escapes?
	JEFS	M.MUX7
	CLB	RBC,MPF.SI,RLINK
	JEFS	M.MUX7
	CLB	RBC,MPF.SI,RLINK
	JEFS	M.MUX8
M.MUX7	STB	RBC,MPV.T1		:escape required...save the char
	LB	RBC,MPF.SI,RLINK	:Escape the char
	JAL	RCH,PUTCHR
	LB	RBC,MPV.T1		:restore the char
M.MUX8	JAL	RCH,PUTCHR		:send the character
	J	M.MUX6			:and go do another

:	Got a signal...pass it on, check for zappers
M.MUX9	STB	R5,MPV.T1		:save signal
	STB	RBC,MPV.T1+1		:save (possible) value
	L	RBP,.FTBUF,RPI		:from-terminal buffer-pointer for MPVC
	LB	RBC,MPF.SI,RLINK	:indicate signal
	JAL	RCH,PUTCHR
	LB	RBC,MPV.T1		:...followed by signal
	JAL	RCH,PUTCHR
	LB	RBC,MPV.T1		:does signal have data?
	TBT	RBC,M.D.ML
	JEFS	M.MUXA			:no...skip to check for zappers
	LB	RBC,MPV.T1+1		:yes...get data
	JAL	RCH,PUTCHR		:...and pass it too
	J	M.MUX6			:and continue with data-stream

:	Special test for zapper
	 LO	SIGNAL
M.MUXA	CLHI	RBC,ZAPSIG		:is this zapper?
	 FO	SIGNAL
	JN	M.MUX6			:no...just proceed

:	Sub-channel Zapped...clean up
	LHL	R0,MPV.CI		:check if current output port
	CLH	R0,MPV.CO,R9
	JNFS	M.MUXB			:skip if not
	TS	MPV.CO,R9		:else disconnect it
M.MUXB	RBT	R0,MPV.AP,R9		:set not active
	LCS	R0,1			:and count it gone
	AHM	R0,MPV.PA,R9
	LIS	R1,0
	JAL	R3,CHNGBF		:disconnect buffer from MPVC
	J	M.MUX4			:and proceed



:	MPVC error
M.ERR	ABORT(0,0)
V.MPV	EQ	M.ERR			:error if polling discovers MPVC input
	SUBTTL	Multiplexed PVC -- Demultiplexer

:	RP -	MPVC port number
:	RP2 -	2*MPVC port number
:	RPI -	MPVC port port-table pointer
:	RPOL -	Polling index (preserved)
:	RLINK -	MPVC port format-table pointer
:	R9 -	MPVC port variable-block pointer
:	R8 -	sub-channel port-table pointer


:		MPVC DE-MUX
:		==== == ===
:	Driver by port-polling logic
:	We start here when circuit first comes up
M.DMX	L	RLINK,MPVCFO-(4*.MPORT),RP2,RP2 :set up MPVC table pointer
	LHL	R9,MP.VAR,RLINK		:get pointer to variables
	TS	MPV.CO,R9		:set no port current
	JFS	M.DMX1			:and skip to main loop

:	Block-change exit for M.D.GC
M.DM.B	JAL	R6,M.D.GC		:get the port number
	STH	RBC,MPV.CO,R9		:and save port #


:	Get next multiplexed character
M.DMX1	JAL	R6,M.D.GC		:get next char
	CLB	RBC,MPF.SI,RLINK	:check for signal
	JEFS	M.DM.S			:yes...skip to process
	CLB	RBC,MPF.EX,RLINK	:check for escape
	JNFS	M.DMX2			:no...data
	JAL	R6,M.D.GC		:yes...get escaped data
M.DMX2	JAL	RCH,PUTCHR		:pass data to port
	J	M.DMX1			:...and process additional bytes

:	got a sub-channel signal...one or more bytes follow
M.DM.S	JAL	R6,M.D.GC		:get the signal code
	LR	R4,RBC			:copy it
	TBT	R4,M.D.VS		:is it valid?
	TBT	R4,M.D.ML		:Multiple-char?
	JNFS	M.DMS1			:skip if multiple char
	TBT	R4,M.D.IN		:is it potentially interesting signal?
	JEFS	M.DMS2			:no...just pass it on
	JAL	R0,M.DM.E		:yes...process exception
	J	M.DMX1			:...and proceed with next element

M.DMS1	STB	R4,MPV.TD,R9		:Multiple character...save signal
	JAL	R6,M.D.GC		:get second (value) character
	LB	R4,MPV.TD,R9		:restore signal
M.DMS2	JAL	RCH,PUTSIG		:transmit the signal
	J	M.DMX1			:and proceed with next element

:	GETCHR for MPVC DE-MUX
:	Gets the next data-char for this MPVC circuit, dismisses if necessary
:	Services all signals for this MPVC circuit
:	R6 -	Link register
:	RBP -	buffer-pointer
:	RLINK -	MPVC port format-table pointer
:	R8 -	sub-channel port-table pointer
M.D.GC	TBT	RP,TOPORT		:is there data for us?
	JNFS	M.D.G1			:yes...skip to get it
	ST	R6,.XSAVE,RPI		:no...save return address
	JAL	R0,XSTATE		:and dismiss for now

:	return from dismiss...restore return, MPVC table pointer
	L	R6,.XSAVE,RPI
	L	RLINK,MPVCFO-(4*.MPORT),RP2,RP2
	LHL	R9,MP.VAR,RLINK		:get pointer to variables
M.D.G1	L	RBP,.TTBUF,RPI		:to-terminal buffer-pointer
	JAL	RCH,GETCHR		:get the next character
	 J	M.DSIG			:signal...special action

	CLB	RBC,MPF.BL,RLINK	:check for  block-change
	JE	M.DM.B			:skip if so, abort current sequence
	LH	R7,MPV.CO,R9		:check out port
	JL	M.D.GC			:ignore if no port active
	LHL	R8,.PTP.,R7,R7		:get sub-channel port-table pointer
	L	RBP,.TTBUF,R8		:and get its to-terminal buffer-pointer
	JR	R6			:return


:	We've gotten a signal over main MPVC circuit...process it
M.DSIG	TBT	R5,M.D.IN		:are we even interested?
	JE	M.D.GC			:no...just ignore
	 LO	SIGNAL
	CLHI	R5,YBSIG		:Yellow ball?
	 FO	SIGNAL
	JNFS	M.DS1			:no
	LHI	R4,-1,R5		:yes...bounce it
	L	RBP,.FTBUF,RPI
	JAL	RCH,PUTSIG
	J	M.D.GC			:and proceed

M.DS1	LR	R4,R5			:must broad-cast to all ports

:	Broadcast signal (in R4) to all active ports
M.D.BC	LHI	R6,(NGRP-2)*2		:for all ports...
M.D.B1	L	R7,MPV.AP,R6,R9		:get an entry
M.D.B2	JFFO	R7,M.D.B3		:any ports to process?
	SIS	R6,4			:not now...do for all
	JGEBS	M.D.B1
	 LO	SIGNAL
	CLHI	R5,ZAPSIG		:Zapper?
	 FO	SIGNAL
	JN	M.D.GC			:no...go back for another
	JAL	R5,M.SACT		:yes...send accounting
	J	ZAPPER			:and exit via circuit-zapper logic

M.D.B3	STH	R6,MPV.T1		:save index
	ST	R7,MPV.T2		:and bits
	RBT	R8,MPV.T1		:won't look at this port again
	SLLS	R6,3			:compute port number
	AR	R8,R6
	STH	R8,MPV.CO,R9		:save it
	LHL	R8,.PTP.,R8,R8		:look up port-table for this port
	L	RBP,.TTBUF,R8		:set to-terminal buffer-pointer
	JAL	R0,M.DM.E		:send exception signal to this port
	L	R7,MPV.T2		:restore registers
	LHL	R6,MPV.T1
	J	M.D.B2			:and proceed with broadcast

:	Service eXception signals for port
:		(zappers, gobblers, yellow & black balls)
:	R0 -	Link register
:	RBP -	to-terminal buffer-pointer for the port
:	R4 -	Signal to send (preserved)
:	RP -	MPVC port number
:	RP2 -	2*MPVC port number
:	RPI -	MPVC port port-table pointer
:	RLINK -	MPVC port format-table pointer
:	R9 -	MPVC port variable-block pointer
:	R8 -	sub-channel port-table pointer
M.DM.E	ST	R0,MPV.T4		:save return
	STB	R4,MPV.T3		:save signal
	 LO	SIGNAL
	CLHI	R4,GOBSIG		:gobbler?
	JE	M.DME1			:yes...go flush output
	CLHI	R4,ZAPSIG		:Zapper?
	JN	M.DME2			:no...just pass on
	 FO	SIGNAL
	LHL	R0,MPV.CO,R9		:zapper...get current output port
	TS	MPV.CO,R9		:...and clear it
	RBT	R0,MPV.AP,R9		:set not active
	LCS	R0,1			:reduce number of active ports
	AHM	R0,MPV.PA,R9
	L	RBP,.FTBUF,R8		:From-terminal buffer-pointer
	LIS	R1,0
	JAL	R3,CHNGBF		:go change BF
	L	RBP,.TTBUF,R8		:to-terminal buffer-pointer
M.DME1	JAL	RCH,EMPTY		:empty to-terminal buffer
	LB	R4,MPV.T3		:Restore signal
M.DME2	JAL	RCH,PUTSIG		:transmit the signal
	LB	R4,MPV.T3		:restore signal value
	L	R0,MPV.T4		:restore return
	JR	R0			:and return

:	Valid signals (1 = valid)
M.D.VS	HC	30FF,0FF00,0FFF0,-1,0FF00,0,0,0,0,0,0,0,0,0,0,0

:	(Potentially) interesting signals
M.D.IN	HC	0C,5000,0,0,0,0		:zapper,gobbler,yellow&black ball

:	Multiple-character signals
M.D.ML	HC	0,0,0AAA0,0AAAA,0AA00,0


	FO	DATA
	EM	:MPVC

	 EI	:NMPVC
	SUBTTL	PVC CONTROL ROUTINES

	 IF	PVC

	GL	PLI,RELOG,LOG5		:references
	GL	PVCLOG			:definitions

	MO	.,PVC

	GL	CIRDIS,PVCIZ

C.PVC	EQ	88			:crash-code for PVC

	LO	DATA

:	Set up equates for handy reference to PVC parameters
POAID	EQ	1			:auto Terminal-ID option
POALO	EQ	1^1			:auto LOGON option
PONPI	EQ	1^2			:Print NODE/PORT IDentifier option
POSLO	EQ	1^3			:Subsequent LOGON to alternate host option
POPAR	EQ	1^4			:Even-Parity option
POPCO	EQ	1^5			:Permanent-Circuit option
POHNG	EQ	1^6			:Ignore Network-hang option
POHDX	EQ	1^7			:Half-duplex option
POCRLF	EQ	1^8			:Echo-LF-with-CR option
POLFCR	EQ	1^9			:echo-CR-with-LF option
POTRS	EQ	1^0A			:Reset terminal-options between LOGONS option
PORBP	EQ	1^0B			:Reverse-backpressure option
POTXT	EQ	1^0C			:Text-Output not permitted
PODSC	EQ	1^0D			:Disconnect on circuit Zapped
POMPC	EQ	1^0E			:MPVC Candidate


:	Entry-point for PVC control routines
:	Execute PVC control-routine frequently to see if any work to do
	GL	PVCCTL
PVCCTL	LHI	RPOL,(NGRP-2)*2		:for all ports...

PVCC10	L	R1,PVCSTD,RPOL		:Get something-to-do array
	JEFS	PVCC08			:skip if nothing to do here
	ST	R1,P.DONE		:else save value
PVCC04	L	R1,P.DONE		:get bits
	JFFO	R1,PVCC20		:Skip if we've got one
PVCC08	SIS	RPOL,4			:examine next port group
	JGEBS	PVCC10			:continue looking for work to do
	J	EXDISM,,		:no more work...exit

:	Got something to do.  Get port number, find state/time vector,
:		and dispatch state processor to proper handler.
PVCC20	RBT	R2,P.DONE		:R2 specifies relative port
	LR	RP,RPOL			:...within this group
	SLHLS	RP,3			:port group times $A 16
	AR	RP,R2			:add to relative port within this group
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP,RP		:set up pointer to port-table
	LH	R1,.PVCTO,RPI		:get ticker
	JEFS	PVCC30			:Clock ticked to zero.  Time to do something
	SIS	R1,1
	STH	R1,.PVCTO,RPI		:Tick another 1/4 second
	JGE	PVCC04
:	Clock went negative.  ERROR!
	JAL	R11,PVCRSH		:Better diagnose this one

:	Clock went to zero.  Whatever was scheduled is about to happen...
PVCC30	RBT	RP,PVCSTD		:disable control...may not need it again
	TS	.PVCTO,RPI		:...and turn off timeout
	LB	R3,.PVCDO,RPI		:Get dispatch value (*2)
	LHL	R2,PVCRTN,R3		:Index into service routine table
	J	BASE,R2			:go service PVC port


:	Routine table.  Relative entry corresponds to routine dispatch
:	value in .PVCDO.
PVCRTN	HC	EA(PVCERR)		: 0 -	Invalid Value
	HC	EA(PVC100)		: 1 -	first LOGON attempt timed-out
	HC	EA(PVC200)		: 2 -	subsequent-LOGON with PCO timed-out
	HC	EA(PVCERR)		: 3 -	Invalid value

:	ERROR in dispatch value.  Crash!
PVCERR	JAL	R11,PVCRSH		:fatal table error.  CRASH and diagnose

:	PVC CODE SUFFERED FATAL ERROR
PVCRSH	ABORT(R11,C.PVC)		:R11 might be interesting

:	Routine dispatch value 1.  Timed-out on original LOGIN attempt.
:	LOGIN should have completed by now.  Test BF to see if we are
:	still in LOGIN mode and retry if true
PVC100	TBT	RP,RLA			:See if port still active
	JE	PVCC04			:no - don't care about hung port
	TBT	RP,LOGING		:Test for still-in-LOGIN-mode
	JE	PVCC04			:no - last LOGIN must have succeeded
	JAL	RLINK,CIRDIS		:Go disconnect circuit
	JAL	RLINK,ESTPRT		:...and start new circuit
	JAL	RLINK,PVCSOP		:set up options
	JAL	RLINK,PVCSLS		:set up login-string
	J	PVCC04			:return to PVCCTL loop

:	Routine dispatch value 2.  Timed-out on subsequent LOGIN attempt.
:	LOGON-timer expired.  See if last LOGIN succeeded.
PVC200	TBT	RP,RLA			:see if port still active
	JE	PVCC04			:no - forget this guy
	TBT	RP,LOGING		:test for still-in-login-mode
	JE	PVCC04			:no - forget this guy
	L	RBP,.LGBUF,RPI		:logon-buffer buffer-pointer
	JAL	RCH,EMPTY		:clear logon buffer
	JAL	RLINK,CIRDIS		:go disconnect circuit
	JAL	RLINK,ESTPRT		:...and start new one
	JAL	RLINK,P.NEXT		:now rebuild the circuit
	JAL	RLINK,PVCSCF		:set up retry timer
	J	PVCC04			:and exit back to scanner





:	Test for AUTO-LoGon port.  Called when a new port becomes established.
:	RLINK -	Link register
:	RPI -	port-table pointer
:	RP2 -	2 * port number
:	RP -	port number
ALOPVC	TS	.PVCTO,RPI		:disable timeouts
	RBT	RP,PVCSTD		:turn off something-to-do
	L	RBP,.TTBUF,RPI		:set up to-terminal buffer-pointer
	TBT	RP,NPIPRT		:should banner be output?
	JNFS	ALOPV1			:no
	LA	R6,ULMSG		:yes...banner
	JAL	R9,MSG
	JAL	R9,MSG0			:followed by NPID
ALOPV1	L	R6,.PVCX,RPI		:test for ALO port
	THI	R6,POALO
	JNFS	P.NEW			:yes...do it
	THI	R6,POTXT		:text-output permitted?
	JNR	RLINK			:no...just exit
	LA	R6,PLI			:no...set "PLI"
	JAL	R9,MSG
	JR	RLINK			:and exit



:	Newly identified port -- Test for AUTO-LoGon port.
:	RLINK -	Link register
:	RPI -	port-table pointer
:	RP2 -	2 * port number
:	RP -	port number
P.NEW	ST	RLINK,PVCRET		:save return

:	1.	Set PVC option parameters, if any
:	2.	Test for AUTO-LOGON desired, and generate LOGON
:		string if so
:	3.	Schedule time-out process in case LOGON fails
	JAL	RLINK,PVCSOP		:Set any option parameters
	THI	R7,POALO		:test for ALO set for this port
	JEFS	P.NEW1			:no...skip
	JAL	RLINK,PVCALO		:ALO..generate message and logon-string
	JAL	RLINK,PVCSCO		:set up timeout
P.NEW1	L	RLINK,PVCRET		:restore return
	JR	RLINK			:return







:	Subsequent LOGON.  Set up parameters, then insure correct message
:	is generated.  Check to see if port is PVC, then if wants terminal
:	options reset.  Since this is not first LOGIN try, must test for
:	whether PCO or SLO set if ALO set.
:	RLINK -	Link register
:	RPI -	port-table pointer
:	RP2 -	2 * port number
:	RP -	port number
SLOPVC	TS	.PVCTO,RPI		:disable time-outs
	RBT	RP,PVCSTD		:turn off something-to-do
					:...and fall through to P.NEXT


:	Subsequent LOGON.
:	Since this is not first LOGIN try, must test for whether
:	PCO or SLO set if ALO set.
:	RLINK -	Link register
:	RPI -	Port-table pointer
:	RP2 -	2*port number
:	RP -	port number
P.NEXT	ST	RLINK,PVCRET		:save return
	L	RBP,.FTBUF,RPI		:From-terminal buffer-pointer
	JAL	RCH,EMPTY		:clear from-terminal pipe
	L	RBP,.TTBUF,RPI		:To-terminal buffer-pointer
	JAL	RCH,EMPTY		:clear anything bound for terminal
	L	R7,.PVCX,RPI		:get PVC parameter-word for this port

	THI	R7,PODSC		:disconnect port?
	JEFS	P.NEX1			:no
	SBT	RP,HANGWT		:yes...hang port
	J	P.NEW1			:and exit

P.NEX1	THI	R7,POTRS		:terminal-options to be reset?
	JEFS	P.NEX2			:no
	LHL	R4,.TERMT,RPI		:yes...get terminal-type cursor
	JAL	R5,IZPORT		:reset TID options and start LOGIN
	JAL	RLINK,PVCSOP		:set PVC options
	L	RBP,.TTBUF,RPI		:restore to-terminal buffer-pointer

P.NEX2	THI	R7,POALO!POPCO		:AUTO-LOGON port or Permanent Circuit?
	JE	P.NEX6			:no - generate "PLI"
	THI	R7,POSLO		:subsequent logon option?
	JN	P.NEX5			:yes...enable :L
	THI	R7,PONPI		:test for NODE/PORT message desired
	JNFS	P.NEX3			:no
	JAL	R9,MSG0			:send NODE/PORT identifier
	L	R7,.PVCX,RPI		:restore parameters
P.NEX3	THI	R7,POTXT		:Is output-text prohibited?
	JNFS	P.NEX4			:yes...skip
	LA	R6,PVCMS2		:set pointer to "CIRCUIT LOST - REBUILDING"
					:	message or equivalent
	JAL	R9,MSG			:let user know what's happening
P.NEX4	JAL	RLINK,PVCSLS		:now send LOGIN string
	JAL	RLINK,PVCSCS		:set timer and state-vector to check back
					:	later and keep trying if necessary
	J	P.NEW1			:done with PCO port

P.NEX5	LIS	R0,0			:SLO option
	STB	R0,.PVCDO,RPI		:set :L state 0
	ST	R0,.PVCLH,RPI		:enable :L and fall through for "PLI"

:	Neither ALO nor PCO...set up LGECHO as required
P.NEX6	TBT	RP,ASCII		:ASCII terminal?
	JEFS	P.NEX7			:no
	TBT	RP,HAFDUX		:Half-duplex?
	JNFS	P.NEX7			:yes
	SBT	RP,LGECHO		:normal...turn on logon-echo

:	Send user "PLI" message
P.NEX7	LR	R7,R7			:is this a PVC port?
	JEFS	P.NEX8			:no...just give him PLI
	THI	R7,POTXT		:text-output permitted?
	JN	P.NEW1			:no...exit now
	THI	R7,PONPI		:NPI required?
	JNFS	P.NEX8			:no
	JAL	R9,MSG0			:yes...say it
P.NEX8	LA	R6,PLI			:"please log in..."
	JAL	R9,MSG
	J	P.NEW1





:	Set Terminal-options as specified by PVC parameters
:	RLINK -	Link register
PVCSOP	L	RBP,.FTBUF,RPI		:Set from-terminal buffer-pointer
	JAL	RCH,EMPTY		:start out by emptying buffer
	L	R7,.PVCX,RPI		:Get PVC parameters for this port
	THI	R7,PORBP		:Test for Reverse-backpressure
	JEFS	PVCSO1			:no
	LHI	RBC,12			:yes
	JAL	RCH,PUTCHR		:Send ^R to Sup
	L	R7,.PVCX,RPI		:Restore PVC parameters
PVCSO1	THI	R7,POLFCR		:Test for Echo-LF-on-CR
	JEFS	PVCSO2			:Yes
	RBT	RP,ECR.LF		:Disable Echo-LF-on-CR
PVCSO2	THI	R7,POCRLF		:Test for Echo-CR|RUB-on-LF
	JEFS	PVCSO3			:yes
	RBT	RP,ELF.CR		:Disable Echo-CR|RUB-on-LF
PVCSO3	THI	R7,POHDX		:Test for Half-duplex
	JEFS	PVCSO4			:no
	LIS	RBC,8			:yes
	JAL	RCH,PUTCHR		:Send ^H to Sup
	L	R7,.PVCX,RPI		:Restore PVC parameters
PVCSO4	THI	R7,POPAR		:Test for Even-parity
	JEFS	PVCSO5			:no
	LHI	RBC,10			:yes
	JAL	RCH,PUTCHR		:Send ^P to Sup
	L	R7,.PVCX,RPI		:Restore PVC parameters
PVCSO5	THI	R7,POMPC		:MPVC candidate?
	JER	RLINK			:No
	SBT	RP,MPVC.C		:yes...flag it
	JR	RLINK			:Done


:	ALO Specified.  Output meaningful text fo user.  Send LOGIN
:	string to Supervisor.
:	RLINK -	Link
PVCALO	THI	R7,POTXT		:Output-text permitted?
	JNFS	PVCSLS			:no...skip
	L	RBP,.TTBUF,RPI		:Set up buffer pointer
	LA	R6,PVCMS1		:set "CIRCUIT BUILDING IN PROGRESS" or
					: equivalent message
	JAL	R9,MSG			:send message to terminal
					:...and fall through to PVCSLS


:	Send LOGIN string to supervisor.
:	RLINK -	Link register
:	RP2 -	2*port number
:	RP -	port number
PVCSLS	L	RBP,.FTBUF,RPI		:Set buffer index toward supervisor
	RBT	RP,LGECHO		:LOGGER shouldn't echo for PVC
	 IF	NUTXT
	LH	R6,IUTXTS,RP2		:Check userstring to use
	JLFS	PVCSL2			:none...use default
	LA	R6,BASE,R6		:special...set it up
	J	PVCSL8			:and skip to send it
PVCSL2	 EI	:NUTXT

:	Default username, password to be used
:	Insert (octal) port-number in default username before shipping it on.
	LR	R0,RP			:Port number
	OH	R0,PVCBAS		:add bias
	LA	R3,PVCUN+6		:place to put port number
	LIS	R4,4			:4 bytes
	JAL	R6,OOS			:Output-Octal-String
	LA	R6,PVCUN		:set up pointer to username
	JAL	R9,MSG

:	If here because of :L option, might be host-number specified
	L	R6,.PVCLH,RPI		:Get LOGIN history string entry
	JLE	PVCSL6			:nothing to do here
:	Host specified.  Send ":"|digit|... before Password.
:	May be several digits.
	LHI	RBC,3A			:Get a COLON
PVCSL4	JAL	RCH,PUTCHR		:Stick Character in Sup-bound buffer
	SRLS	R6,4			:Slide next host-number into position
	LIS	RBC,0F			:set mask
	NR	RBC,R6			:Isolate host-number digit
	SIS	RBC,1			:Subtract bias
	JLFS	PVCSL6			:Nothing there - done with host number
	OHI	RBC,30			:make number ASCII
	JBS	PVCSL4			:Continue

:	Insert (octal) port-number in default password before shipping it on.
PVCSL6	LR	R0,RP			:port number
	AH	R0,PVCBAS		:bias it
	LA	R3,PVCPW+2		:place to put port number
	LIS	R4,4			:4 bytes
	JAL	R6,OOS			:Output-Octal-String
	LA	R6,PVCPW		:pointer to password

PVCSL8	JAL	R9,MSG			:Send User-specified LOGIN string
	RBT	RP,DEM			:No Green-balls
	TS	.PVCLH,RPI		:Disable :L scanner
	JR	RLINK			:return


:	Set timer for original LOGIN attempt
:	RLINK -	link register
PVCSCO	LHI	R0,$A 90*4		:come back in 90 seconds if necessary
	LIS	R1,1*2			:set dispatch value...
PVCSET	STH	R0,.PVCTO,RPI		:store in time vector
	STB	R1,.PVCDO,RPI		:	so we know why we came back
	SBT	RP,PVCSTD		:set something-to-do
	JR	RLINK			:return

:	Set timer for (failed) subsequent LOGIN attempt for PCO port
:	RLINK -	Link register
PVCSCF	LHI	R0,PCORTY*4		:user defines how often we retry
	JFS	PVCSC1			:and skip

:	Set timer for subsequent LOGIN attempt for PCO port
:	RLINK -	Link register
PVCSCS	LHI	R0,PCOTRY*4		:user defines how often we retry
PVCSC1	LIS	R1,2*2			:set dispatch value to see if LOGON succeeds
	JBS	PVCSET			:go set up
	SUBTTL	PVC INITIALIZATION


:	PVC Initialization routine
PVCIZ	LHI	R1,(NPORT-1)*2		:For all ports...
	LIS	R2,0			:...and a 0
PVCI0	LHL	RPI,.PTP.,R1		:get pointer to port table entry
	STB	R2,.PVCDO,RPI		:initialize PVC state vector...no PVC
	STH	R2,.PVCTO,RPI
	L	R3,PVCX,R1,R1		:get value
	ST	R3,.PVCX,RPI		:...and put into table
	JEFS	PVCI1			:Skip if null PVC
	TS	.PVCTO,RPI		:-1 in timeout field means nothing to do
PVCI1	TS	.PVCLH,RPI		:Init. .PVCLH flag to -1
	SIS	R1,2
	JGE	PVCI0

:	Now do miscellaneous stuff
	LHI	R1,(NGRP-1)*2
PVCI30	STH	R2,PVCSTD,R1		:Init. with nothing to do
	TS	TATBIN,R1		:Init. TATBIN to -1
	SIS	R1,2			:...on to next group
	JGEBS	PVCI30			:Continue
	JR	R0			:then return

:	Define the PVC exception table
PVCX	WS	0
Q	EQ	0
	RE	NPORT			:for all ports...
	 IF	\PVCX|Q|
	  WC	0FFFFFFFF&PVCX|Q|	:Exception for port Q
	 ELSE	:\PVCX|Q|
	  WC	0			:null for non-PVC ports
	 EI	:\PVCX|Q|
Q	 EQ	Q+1
	ER	:NPORT

	 IF	NUTXT

:	Initialization for User-string texts.
:	0 -	not PVC
:	<0 -	Default (message not specified)
:	>0 -	EA(text)
IUTXTS	HS	0
Q	EQ	0
	RE	NPORT
	 IF	.BIT.(PVCG,Q)
	  IF	\UTAP|Q|
QQ	EQ	UTAP|Q|
	HC	EA(UTXA|QQ|)		:assigned string
	  ELSE	:not \UTAP|Q|
	HC	-1			:default (computed) string
	  EI	:\UTAP|Q|
	 ELSE	:.BIT.(PVCG,Q)
	HC	0			:not PVC
	 EI	:.BIT.(PVCG,Q)
Q	EQ	Q+1
	ER	:NPORT
	 EI	:NUTXT
	SUBTTL	":L" PVC PROCESSING

:	The Port-table entry .PVCLH contains a half-word entry for each
:	port.  This entry is initialized to -1.  When P.NEXT is setting up
:	a port for LOGIN, it sets that port's .PVCLH entry to 0.  If the
:	first LOGIN character entered by the user is ":", the entry will
:	incremented at each new character from that port, and dispatched
:	to the appropriate code.  Otherwise, .PVCLH is set to -1.

:	Subsequent character from port which started LOGON with a colon.
:	Handle character based on number previously entered.  If invalid
:	character detected, send escape to supervisor.
:	RLINK -	link register (not used often to return).
PVCLOG	LB	R3,.PVCDO,RPI		:get state
	AIS	R3,1			:advance to next state
	STB	R3,.PVCDO,RPI
	LHL	R4,PVCLGD,R3,R3		:get proper entry from dispatch table
	J	BASE,R4

:	Dispatch table for :L login.  The routine to get control is based
:	upon the number of characters already received.
PVCLGD	HC	EA(PVCESC)		:0th Character -  shouldn't happen!
	HC	EA(PVCLG1)		:1st Character -- should be ':'.
	HC	EA(PVCLG2)		:2nd Character -- should be 'L'.
	HC	EA(PVCLG3)		:3rd character -- CR or ':'
	HC	EA(PVCLG4)		:4th character -- host number
	HC	EA(PVCLG4)		:5th character -- host number or CR
	HC	EA(PVCLG4)		:6th character -- host number or CR
	HC	EA(PVCLG4)		:7th character -- host number or CR
	HC	EA(PVCLG4)		:8th character -- host number or CR
	HC	EA(PVCLG4)		:9th character -- should be CR
	HC	EA(PVCESC)		:10th character -- error


:	See if port has entered a COLON as first character of LOGIN.
:	Proceed with :L if so, else abort.
PVCLG1	CLHI	R9,3A			:":"?
	JE	RELOG			:yes...just proceed
	TS	.PVCLH,RPI		:no...abort process
	JR	RLINK			:and logon with this character

:	Second character in string.  Should be an 'L'.
PVCLG2	CLHI	R9,4C			:is it an "L"?
	JN	PVCESC			:no...error in :L LOGIN string...
					:	Send escape to supervisor.
	J	RELOG			:proceed with next char

:	Third character in string.  Maybe CR, or might be another colon
:	to specify host number.
PVCLG3	CLHI	R9,0D			:test for carriage return
	JE	PVCSCL			:yes - string terminated.  Tap PVC
					:	control process to generate
					:	login string.
	 IF	NUTXT
	LH	R0,IUTXTS,RP2		:check user-string in use for this port
	JGE	PVCESC			:not default user-name...entry error
	 EI	:NUTXT
	CLHI	R9,3A			:got another colon?
	JE	RELOG			:yes - proceed to wait for some numbers
	J	PVCESC			:no - entry error

:	4th - 9th character.  Number or carriage return valid.
PVCLG4	CLHI	R9,0D			:test for CR
	JE	PVCSCL			:yes - string terminated
:	Character must be between 30-39, inclusive
	LHI	R0,-30,R9
	JL	PVCESC			:too low
	CLHI	R0,9
	JG	PVCESC			:too high
	AIS	R0,1			:bias host number digit by 1 so we may
					:	tell difference between 0 and
					:	non-entered character.
	SIS	R3,4
	SLHLS	R3,2			:set up shift index of 4,8,0C
	SLL	R0,0,R3			:align 4-bit number to combine with
					:	what we already may have
	AM	R0,.PVCLH,RPI		:place new digit and proceed
	J	RELOG

:	Abort :L LOGON attempt.  Send ZAPPER to SUPERVISOR.
PVCESC	TS	.PVCLH,RPI		:disable :L scan function
	LHI	RBC,1B			:Escape character
	L	RBP,.LGBUF,RPI
	JAL	RCH,PUTCHR		:place into buffer...
	J	LOG5			:...and kill LOGIN

:	End of :L string.  Prevent further scanning and notify PVC control
:	mechanism that it has work to do for this port.
PVCSCL	L	RBP,.FTBUF,RPI		: ":L" received from port
	JAL	RCH,EMPTY		:empty buffer
	JAL	RLINK,PVCSLS		:fire-up login attempt
	J	RELOG			:now proceed to service it
	SUBTTL	PVC UTILITY ROUTINES

:	The routine that follows is called from various places in the
:	code to detect conditions which may require PVC service.

:	Test for AUTO-Terminal-ID port.  Called from HANG/ANSWER when a
:	new port becomes connected.
:	RLINK -	Link register
:	RPI -	port-table pointer
:	RP2 -	2 * port number
:	RP -	port number
:	Skip-4 return -	succeeded in setting up TID
:	Normal return -	failed, proceed with normal setup
AIDPVC	TS	.PVCLH,RPI		:Disable :L Scanner
	RBT	RP,PVCSTD		:turn off something-to-do
	TBT	RP,PVCARY		:test for PVC port
	JER	RLINK			:no
	L	R3,.PVCX,RPI		:Get PVC parameter word
	THI	R3,POHNG		:Allow HANGS?
	JEFS	AIDPV1			:yes
:	NOHNG set on PVC port.  Reset TATBIN bit to prevent hanging due to
:	TA/TB HANG/ANSWER timeout.
	RBT	RP,TATBIN		:if TID not received in over 16 seconds,
					:	won't get hung
AIDPV1	THI	R3,POAID		:test for AUTO-ID for this port
	JER	RLINK			:no
:	Got an AUTO-ID port.
	SRL	R3,$A 23
	NHI	R3,1FE			:Isolate 2*TID value
	LH	R4,PVCTID,R3		:map PVC TID value into useful VIDTT index
	JAL	R5,IZPORT		:initialize it
	AIS	RLINK,4			:set skip return
	J	ESTPRT			:exit via port-establishment for TID

	FO	DATA

	EM	:PVC
	 EI	:PVC
	SUBTTL	LOGGER

	GL	LGGO,LGRET,RELOG	:definitions
	GL	LSTAT,PLI
	GL	LOGCH			:references

	MO	.,LOGGER

	LO	DATA

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		PROCESS LOGIN CHARACTERS		::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:	Transmit LOGON-string for port specified by RP
SNDLOG	TBT	RP,GOLOG		:Any more there?
	JEFS	LGRET			:no...just quit for now
	L	RBP,.LGBUF,RPI		:Logon buffer
	JAL	RCH,GETCHR		:get the next char
	 J	.			:don't expect skip returns!
	LR	R9,RBC			:data-char...copy it
	JAL	RLINK,LOGCH		:send character
	JBS	SNDLOG			:go to see if any more



:		LOGGER
:		======
:	run every 50 ms. from timeout list.
LGGO	LHI	RPOL,(NGRP-2)*2		:word index into bit arrays
LGRET	L	R0,TOLOG,RPOL		:data present
	N	R0,LOGGER,RPOL		:LOGGER active
	N	R0,LOGING,RPOL		:in login mode
	JFFO	R0,LG1
	SIS	RPOL,4
	JGEBS	LGRET			:Next port-group:
	J	EXDISM,,		:done...exit timeout

LG1	LR	RP,RPOL			:Compute port number
	SLLS	RP,3
	AR	RP,R1
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP,RP		:set up Port-Table-Pointer
	J	VLOG			:Process logon characters
					:    VLOG may exit to:
					:	LGRET -- data exhausted,
					:	SNDLOG -- field completed.



:	Set a terminal parameter...
:	R4 -	Signal to send
LGSET	L	RBP,.TTBUF,RPI		:set to-terminal buffer-pointer
	LIS	RBC,1			:set to 1
	JAL	RCH,PUTSIG		:send signal and proceed

:	LOGGER, called from LGGO
:	======

:	Check if more characters present for this port.
RELOG	TBT	RP,TOLOG		:any more data present?
	JE	LGRET			:no, so exit back to LOGON poller


:	Entry point
:	Process another logon character
VLOG	L	RBP,.FTBUF,RPI		:Locate buffer to get char from
	JAL	RCH,GETCHR		:get the character
	 J	RELOG			:normal return...toss control signals
	NHI	RBC,7F			:Skip return...data...remove MSB
	JEBS	RELOG			:ignore nulls in logon
	CLHI	RBC,7F			:...and RUBOUT too
	JEBS	RELOG
	LR	R9,RBC			:save copy of data character
	L	RBP,.TTBUF,RPI		:set to-term buffer for echoing
	CLHI	RBC,20			:control character?
	JLFS	LOG1			:yes, control...skip to service

:	Data characters
	TBT	RP,UNAME		:Don't echo unless in username state
	JE	LOG3			:Password, skip echo
	TBT	RP,LGECHO		:should we echo?
	JE	LOG3			:No, skip echo
	JAL	RCH,PUTCHR		:Echo it
	J	LOG3			:and skip

:	control-char...check it out
LOG1	CLHI	R9,0D			:CR?
	JN	LOG6			:skip if not
	TBT	RP,LGECHO		:should we try to echo?
	JE	LOG3			:should we try to echo?
	TBT	RP,UNAME		:yes...in username?
	JE	LOG3			:no...don't try to echo
	TBT	RP,ASCII		:yes...should we echo?
	JE	LOG3			:no
	TBT	RP,HAFDUX		:yes...half-duplex?
	JNFS	LOG2			:yes
	JAL	RCH,PUTCHR		:no...echo CR
LOG2	LIS	RBC,0A			:...|LF
	JAL	RCH,PUTCHR

:	printable character echoed...what else do we do with it?
LOG3	 IF	PVC
	LH	R3,.PVCLH,RPI		:potential PVC log character
	JLFS	LGPVC1			:skip if not appropriate
	JAL	RLINK,PVCLOG		:check PVC state
LGPVC1	 EI	:PVC
	LHI	RBC,80,R9		:set high-order bit
	L	RBP,.LGBUF,RPI		:set pointer to LOGON-buffer
	JAL	RCH,PUTCHR		:go buffer new character
	LHL	RCH,BCT,RBP		:check number of chars accumulated
	SHI	RCH,$A 55
	JGEFS	LOG5			:too many...send to sup to fix!
	CLHI	R9,0D			:is this char CR?
	JEFS	LOG4			:yes
	CLHI	R9,3B			:was it semi-: ?
	JN	RELOG			:no...see if anything else to do

:	Terminator found...close out logon string
LOG4	 IF	NMPVC
	JAL	RLINK,MPSCAN		:check out user-name
	 EI	:NMPVC			:return means not MPVC, so proceed
LOG5	RBT	RP,LOGGER		:terminator, defer until LSTAT received
	J	SNDLOG			: and send in logon string

:	Control-character (other than CR)
LOG6	L	RBP,.LGBUF,RPI		:set logon-buffer
	LHI	RBC,80,R9		:place this character into buffer
	JAL	RCH,PUTCHR
	LHL	RCH,BCT,RBP		:check number of chars accumulated
	SHI	RCH,$A 55
	JGEBS	LOG5			:too many...send to sup to fix!
	CLHI	R9,1B			:check for various ESCAPE characters
	JGE	LOG5			:yes...flush buffer
	TBT	RP,UNAME		:Control character...
	JE	RELOG			:PASSWORD state...just pass on to sup
	LHI	RBC,-8,R9		:^H (Half-duplex)?
	JNFS	LOG7
	RBT	RP,LGECHO		:LOGGER shouldn't echo
	 LO	SIGNAL
	LHI	R4,SHDSIG		:set HDUX signal
	J	LGSET
LOG7	SIS	RBC,10-8		:^P (Parity)?
	JNFS	LOG8
	LHI	R4,SPRSIG		:Set parity signal
	J	LGSET
LOG8	SIS	RBC,12-10		:^R (Reverse X-Enable)?
	JNFS	LOG9
	LHI	R4,SRXSIG		:yes...enable it
	J	LGSET
LOG9	SIS	RBC,18-12		:^X (backpressure)?
	JN	RELOG
	LHI	R4,SXESIG		:set backpressure
	 FO	SIGNAL
	J	LGSET

	SUBTTL	LOGON STATUS

:	LOGON Status
:	R9 -	Status
:	RP -	Port number
:	RP2 -	Port number*2
:	RPI -	Port-table pointer
:	RLINK -	Link register
:	RBP -	Buffer-pointer (init'ed to To-terminal)
LSTAT	RBT	RP,UNAME		:turn off User-name
	THI	R9,80			:This bit set to flush input buffer
	JEFS	LSTA10			:not set
	L	RBP,.FTBUF,RPI		:set from-terminal buffer
	JAL	RCH,EMPTY		:Flush input buffer
	L	RBP,.TTBUF,RPI		:set to-terminal buffer
LSTA10	THI	R9,20			:This bit set to flush output buffer
	JEFS	LSTA20
	JAL	RCH,EMPTY		:Flush output buffer

:	Now set up R8 to index into a list of arrays of message pointers.
:	Supervisor status messages differ based upon whether terminal is
:	2741, Normal ASCII, Half-Duplex ASCII.  R8 will be set to:
:		0	Non-PVC 2741,
:		1	non-PVC normal ASCII,
:		2	non-PVC Half-duplex ASCII,
:		3	PVC 2741,
:		4	PVC Normal ASCII,
:	and	5	PVC Half-Duplex ASCII.
LSTA20	LIS	R8,2*2			:Initialize R8
	TBT	RP,HAFDUX		:Half-Duplex?
	JNFS	LSTA30			:yes
	LIS	R8,0*2
	TBT	RP,ASCII		:2741?
	JEFS	LSTA30			:no - normal ASCII
	LIS	R8,1*2			:set to 1 for normal
LSTA30	NHI	R9,7			:extract status-type
	SLLS	R9,2			:Convert message number to index
	 IF	PVC
	TBT	RP,PVCARY		:PVC port?
	JEFS	LSTA34			:no
	TBT	RP,PVCSTD
	JEFS	LSTA34
	AIS	R8,3*2			:PVC...set correct index
	 EI	:PVC
LSTA34	AH	R9,LSTBL,R8		:Array pointer based upon terminal type, message

:	Check if should preceed with explicit CR|LF
	LB	R5,BASE+2,R9		:Get CR|LF / set/reset flags
	THI	R5,80			:CR|LF?
	JEFS	LSTA36			:no...proceed
	LHI	RBC,8D			:yes...CR
	JAL	RCH,PUTCHR
	LHI	RBC,8A			:LF
	JAL	RCH,PUTCHR
	LB	R5,BASE+2,R9		:restore set/reset flags

:	Set/Reset bit arrays based on terminal type, Sup message type
LSTA36	LB	R6,BASE+3,R9		:Get count of arrays
	LIS	R7,0			:index for bit array address table
	JFS	LSTA44

LSTA40	RBT	RP,0,R8			:Reset bit
LSTA42	SIS	R6,1			:Decrement count
	JLEFS	LSTA50			:Done...send message and exit
	AIS	R7,2
LSTA44	LHL	R8,LSBATB,R7		:Get bit array address
	SRLS	R5,1			:Determine next operation
	JNCBS	LSTA40			:flag not set - reset bit
	SBT	RP,0,R8			:...else set bit
	JBS	LSTA42			:....and continue

LSTA50	LHL	R6,BASE,R9		:Get message pointer
	LA	R6,BASE,R6		:R6 points to desired message
	JAL	R9,MSG			:move text into terminal-bound buffer
	JR	RLINK			:Then exit


:		** Message Control Tables (Explanation) **
:	The tables pointed to by LSTBL (LSMS27, LSMS, LSMSH, LSMS2P, LSMSP,
:	LSMSHP) all contain 8 Full-word elements, indexed by Supervisor
:	message type.  Each full-word element contains 3 fields - message
:	address, bit-array flags, and bit-change count.  The message address
:	is relative to BASE, so it requires only a half-word.  The bit-array
:	flags has the high-order bit set if CR|LF is to be output preceeding
:	the text...it controls which bits get set or reset to properly control
:	the LOGON status.  The bit-array flags map into the elements of the
:	Bit-array table LSBATB.  The last byte of each entry determines the
:	number of bits upon which to operate.

:	Define a macro to create a LS ELEMent
LSELEM	MACRO(P,V,N) [
	HC	EA(P);	BC	V,N]

:	LSTBL - List of pointers to terminal-type arrays.  LSTBL is indexed
:	based on whether terminal is 2741, ASCII, Half-duplex ASCII
LSTBL	HC	EA(LSMS27)		:non-PVC 2741
	HC	EA(LSMS)		:non-PVC normal ASCII
	HC	EA(LSMSH)		:non-PVC Half-Duplex ASCII
	 IF	PVC
	HC	EA(LSMS2P)		:PVC-ALO 2741
	HC	EA(LSMSP)		:PVC-ALO normal ASCII
	HC	EA(LSMSHP)		:PVC-ALO Half-Duplex ASCII
	 EI	:PVC


:	LSBATB - LOGON status bit-array table.  This table maps the bit-array
:	flags from the message control-tables into the proper address for
:	the set/reset operation.  The bit-array flags are ordered from right
:	to left corresponding to the successive LSBATB entries.  A zero
:	indicates a reset operation is required, and a one requests a bit
:	set.
LSBATB	HS	0
	HC	UNAME			:01
	HC	LOGGER			:02
	HC	ECHO			:04


:	Message control-tables follow:

LSMS27	HS	0			:NON-PVC 2741
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(PLI,3,2)			:set UNAME, LOGGER
	LSELEM(LSMS2,83,2)		:CR|LF /set UNAME, LOGGER
	LSELEM(LSMS32,82,2)		:CR|LF / reset UNAME, set LOGGER
	LSELEM(LSMS4,83,2)		:CR|LF /set UNAME, LOGGER
	LSELEM(LSMS52,82,2)		:CR|LF / reset UNAME, set LOGGER
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(LZ,3,2)			:set UNAME, LOGGER


LSMS	HS	0			:non-PVC normal ASCII
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(PLI,3,2)			:set UNAME, LOGGER
	LSELEM(LSMS2,83,2)		:CR|LF /set UNAME, LOGGER
	LSELEM(LSMS3,82,2)		:CR|LF / reset UNAME, set LOGGER
	LSELEM(LSMS4,83,2)		:CR|LF /set UNAME, LOGGER
	LSELEM(LSMS5,82,2)		:CR|LF / reset UNAME, set LOGGER
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(LZ,3,2)			:set UNAME, LOGGER


LSMSH	HS	0			:non-PVC Half-Duplex ASCII
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(PLI,3,2)			:set UNAME, LOGGER
	LSELEM(LSMS2,83,2)		:CR|LF /set UNAME, LOGGER
	LSELEM(LSMSC,82,2)		:CR|LF / reset UNAME, set LOGGER
	LSELEM(LSMS4,83,2)		:CR|LF /set UNAME, LOGGER
	LSELEM(LSMSE,82,2)		:CR|LF / reset UNAME, set LOGGER
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(LZ,3,2)			:set UNAME, LOGGER

	 IF	PVC

LSMS2P	HS	0			:PVC-ALO 2741
LSMSP	EQ	LSMS2P			:PVC-ALO normal ASCII
LSMSHP	EQ	LSMS2P			:PVC-ALO Half-Duplex ASCII
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(LZ,0,2)			:reset UNAME, LOGGER
	LSELEM(PVCMS3,0,2)		:reset UNAME, LOGGER
	LSELEM(PVCMS4,0,2)		:reset UNAME, LOGGER
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(PVCMS5,0,2)		:reset UNAME, LOGGER
	LSELEM(LZ,2,2)			:reset UNAME, set LOGGER
	LSELEM(LZ,7,3)			:set UNAME, LOGGER, ECHO

	 EI	:PVC


	KILL	LSELEM			:Don't need (or want) any more




	LO	SIGNAL

LZ	BC	0
PLI	AC	/"8D"8Aplease log in: /
	BC	80,GBSIG,00
LSMS2	AC	/error, type /		:Continued...
LSMS4	AC	/user name: /
	BC	80,GBSIG,00
LSMS3	AC	/error, type /		:Continued...
LSMS5	AC	/password: "00/
LSMS32	AC	/error, type /		:Continued...
LSMS52	AC	/password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	BC	80,GBSIG,00
LSMSC	AC	/error, type /		:Continued...
LSMSE	AC	/password:/
	AC	/"8D"8A"FF###############/
	AC	/"8D"FF"FF+++++++++++++++/
	AC	/"8D"FF"FFOOOOOOOOOOOOOOO"8D"00/

	FO	SIGNAL

	FO	DATA
	EM	:LOGGER
	TITLE	CONsolidated tymSAT -- ISIS environment		
	SUBTTL	DEFINITIONS


:    ***   ***  *   *  ****  ***  *     ***** ****    *   ***** ***** ****
:   *   * *   * **  * *     *   * *       *   *   *  * *    *   *     *   *
:   *     *   * * * *  ***  *   * *       *   *   * *****   *   ****  *   *
:   *   * *   * *  **     * *   * *       *   *   * *   *   *   *     *   *
:    ***   ***  *   * ****   ***  ***** ***** ****  *   *   *   ***** ****


:                     ***** *   * *   *  ****   *   *****
:                       *    * *  ** ** *      * *    *
:                       *     *   * * *  ***  *****   *
:                       *     *   *   *     * *   *   *
:                       *     *   *   * ****  *   *   *


:		   *****  **** *****  ****       ***** *****
:		     *   *       *   *             *     *
:		     *    ***    *    ***  *****   *     *
:		     *       *   *       *         *     *
:		   ***** ****  ***** ****        ***** *****


:	   ***** *   * *   * ***** ****   ***  *   * ***** *   * *****
:	   *     **  * *   *   *   *   * *   * ** ** *     **  *   *
:	   ****  * * * *   *   *   ****  *   * * * * ****  * * *   *
:	   *     *  **  * *    *   * *   *   * *   * *     *  **   *
:	   ***** *   *   *   ***** *  *   ***  *   * ***** *   *   *




:    ====================================================================
:    |       THIS DOCUMENT IS THE SOLE PROPERTY AND CONFIDENTIAL        |
:    |       INFORMATION  OF  TYMSHARE,  INC.,  AND  MAY  NOT BE        |
:    |       COPIED  IN  WHOLE OR IN PART  OR  DISCLOSED  TO ANY        |
:    |       THIRD PARTY  WITHOUT THE PRIOR  WRITTEN  CONSENT OF        |
:    |       TYMSHARE.                                                  |
:    ====================================================================


	GL	C.INDM,C.IINM,LOGCH,INPUT
	GL	NLOGCH,LENGTH
	GL	IZT,TIMOUT,EXDISM,TSCHED,CRASH,N.TOUT,POLL
	GL	RET,RET4,CERR,FPANEL
	GL	GCI,WCI,NBBFLT,NBUF
	GL	IZBB
	 IF	NAPORT
	GL	IZASYN
	GLOBAL(AHIST,0)			:record ASYNC transfers if 1
	GLOBAL(ASYERR,0)		:check ASYNC errors if 1
	 EI	:NAPORT

P0.MAX	EQ	0F0022			:max value for port-0 message types
P.MAX	EQ	0F0024			:max value for other message types
P.P0L	EQ	0F0026			:pointer to port 0 length-table
LENGTH	EQ	0F0028			:ISIS-message length table
	GLOBAL(SPED.A,0F0128)		:Async terminal-speeds supported

:	Crash Codes
:	-----------
C.INDM	EQ	82			:Illegal Non-data message to IFAN
C.IINM	EQ	83			:Illegal Intra-node message to INSPT

:	Debugging and Tracing Switches
	GLOBAL(DCPSSW,0)		:Default is simple Front Panel display
	GLOBAL(FORRUN,1)		:Default is FOREGROUND execution
DCPSSW	EQ	DCPSSW*CPS		:meaningless if no CPS

:	Set up scheduling
N.TOUT	EQ	0			:initial number of timeout entries

:	SCHED(WHEN,PERIOD,ADDR)	conditional macro to schedule ADDR to run every PERIOD
SCHED	MACRO(W,P,A) [
	 IF	W
	GL	A
	LA	R0,A
	LR	R1,R7
	LHI	R2,P
	JAL	R6,TSCHED
N.TOUT	EQ	N.TOUT+1
	 EI	:W
]
	SUBTTL	VARIABLES

	SEG	A.DATA

	MO	.,DATA


TOISIS	HS	NGRP			:Bits set if data present for ISIS
SENDON	HS	NGRP			:Bits set for ISIS backpressure off
BKPRSR	HS	NGRP			:Bits on if we've back-pressured ISIS
	 IF	NAPORT
:	Define variables for port scanner
:	Define arrays for QUASI, DRIVER transfer
AR.RS	EQ	20			:ASYNC ring-size
TAMMER	HS	NAGRP			:array notes transition state
DQDAT	HS	NGRP			:DRIVER to QUASI data array
QDDAT	HS	NGRP			:QUASI to DRIVER
TAM	HS	NGRP			:QUASI to DRIVER backpressure

:	Arrays for signal drivers
HDWDTR	HS	NAGRP			:hardware DTR
HDWDSR	HS	NAGRP			:Hardware DSR
HDWCP	HS	NAGRP			:Hardware CP
HAC	HS	1			:Hang-Answer Cursor
ATEMP	HS	10			:temp store for async

	 IF	NUMPRN
TOPRINT	HS	1			:Printer-data flag
PRTBSY	HS	1			:Printer-busy flag
NROT	EQ	4			:number of ROTOR entries
BUFSIZ	EQ	100			:size of ROTOR buffer
:	define ROTOR and data storage
PAREA	HS	NUMPRN*NROT*BUFSIZ/2	:four ROTOR entries per printer
:	define data arrays
SVCPTR	WS	NUMPRN			:Points to current ROTOR entry
STAT	HS	NUMPRN			:address for status
LUNPRN	BS	NUMPRN			:Logical unit for printer device
	 EI	:NUMPRN
	 EI	:NAPORT

IPORTS	HS	1			:number of active ISIS ports
ZAPIT	HS	1			:Set to ISIS port to zap by DDT user
CERR	HS	1			:set negative if configuration error
FPANEL	HS	1			:contents of front-panel display
FPCNT	HS	1			:Front-panel cycle counter
FPETIM	HS	2			:Front-panel execution-timer
	 IF	DCPSSW
FPSTIM	HS	2			:current short-CPS start-time
FPLTIM	HS	2			:current long-CPS start-time
FPLCC	HS	2			:current long-CPS char-count
FPLGAV	HS	1			:long CPS average
FPSHAV	HS	1			:short CPS average
FPCPSC	HS	1			:CPS calculated flag
FPCPSX	HS	1			:long-cps calculation trigger
	 EI	:DCPSSW
	 IF	CPS
CPSIN	HS	1			:input character counter
CPSOUT	HS	1			:output character counter
	 EI	:CPS
ASNPUT	HS	NPORT			:port number for identification
XLIMIT	BS	NPORT			:Max number bytes to send at once

SEQKEY	BS	(NAPORT+NSPORT)		:Seq-num key used on normal needles
ENDZRO	HS	0			:End of area zeroed at Initialization!

:	PORT MAPS - INITIALIZED TO FFFF TO SIGNIFY NO MAPPING
BEGONE	HS	0			:beginning of init to 1'S (FFFF)
PMAPIA	HS	MAXPRT+1		:ISIS-ASYNC (+1, ISIS port 0 special)
PMAPAI	HS	NPORT			:ASYNC-ISIS
ENDONE	HS	0			:end of 1'S init

RET4	WS	1			:link for routines that exit through RET
	EM	:DATA

	SEG	A.CODE
	SUBTTL	INITIALIZATION

:	General Initialization
:	------- --------------
	LO	DATA

:	Initialize variables for restart

START	LHI	R1,ENDZRO-BEGZRO-2	:Zero some storage
	LIS	R0,0
INIT0	STH	R0,BEGZRO,R1
	SIS	R1,2
	JGEBS	INIT0

	LCS	R0,1			:Initialize -1 area
	LHI	R1,ENDONE-BEGONE-2
INIT1	STH	R0,BEGONE,R1
	SIS	R1,2
	JGEBS	INIT1

:	Set up timeout list
	JAL	R0,IZT
	L	R7,FASTC,,		:Get reference time
	AHI	R7,RATE			:start all one second from now
	SCHED(1,$A RATE/100,POLL)	:polling logic, every 10 ms.
	SCHED(1,$A RATE/40,GBTIME)	:Green-ball timeout, every .025 second
	SCHED(1,$A RATE/40,OUTPUT)	:Output to ISIS, every .025 second
	SCHED(1,$A RATE/20,BZAP)	:buffer-zap logic, every .05 second
	SCHED(1,$A RATE/20,LGGO)	:Log-on, every .05 second
	SCHED(LISA,$A RATE/20,L.POLL)	:LISA polling, every .05 second
	SCHED(PVC,RATE/4,PVCCTL)	:PVC control, every .25 seconds
	SCHED(NMPVC,RATE/4,M.MUX)	:MPVC Multiplexer, every .25 seconds
	SCHED(1,RATE/2,IHSEC)		:ISIS half-second, every .5 second
	SCHED(1,RATE/2,CSHSEC)		:CONSAT half-second, every .5 second
	SCHED(NAPORT,RATE/2,HANGAN)	:ASYNC Hang/answer, every .5 seconds
	SCHED(NSPORT,RATE,QHASIO)	:SIO HANG/ANSWER, every second
:	SCHED(LISA,RATE,L.TIME)		:LISA timeout, every second
	SCHED(NMPVC,RATE,M.PER)		:MPVC periodic logic, every second
	SCHED(NHNGBK,RATE*2,TWOSEC)	:two-second logic, every 2 seconds
	SCHED(NSPORT,5*RATE/2,BRKSIO)	:SIO BREAK-logic, every 2.5 seconds
	SCHED(1,RATE*5,A.BUSY)		:Port-busy, every 5 seconds
	SCHED(1,RATE*8,RBTIME)		:Red-ball timeout, every 8 seconds
	SCHED(NAPORT,$A 16*RATE,SEC16)	:16-second logic, every 16 seconds
	SCHED(1,$A 20*RATE,SEC20)	:20-second logic, every 20 seconds
	SCHED(NMPVC,$A 1020*RATE,M.ACCT) :MPVC accounting, every 17 minutes

:	Initialize User-message from backup
	LHI	R1,80-4			:There's 80 bytes to move
INIT2	L	R0,IULMSG,R1		:Copy 4 bytes
	ST	R0,ULMSG,R1
	SIS	R1,4
	JGEBS	INIT2			:repeat

:	Set up Port Identifier message, format:
:	MS0	NL-NNNN:SS-PPP-0
:		0123456789ABCDEF
:	MS00		   ^
MS00	EQ	MS0+0B			:place to put port number

	LI	R0,8D0A2D00		:"CR|LF|-|0"
	ST	R0,MS0
	STB	R0,MS0+0F		:Terminate it
	EXBR	R0,R0			:Position the "-"
	STB	R0,MS0+0A		:second "-"
	STB	R0,MS0+0E		:third "-"
	LHI	R0,3A			:":"
	STB	R0,MS0+7
	LHL	R0,NODEX,,		:Get node number from Common
	LA	R3,MS0+3		:pointer to string
	LIS	R4,4			:4 bytes
	JAL	R6,OOS			:Put string in place
	LHL	R0,SLOTNO,,		:Get Slot number from common
	LA	R3,MS0+8		:pointer to string
	LIS	R4,2			:2 bytes
	JAL	R6,OOS			:Put string in place
	 IF	PVC

:	Generate PVC username, password
	LIS	R0,7			:set mask
	NH	R0,SLOTNO,,		:extract slot-number digit
	SLLS	R0,9			:* 1000(octal)
	STH	R0,PVCBAS		:this becomes PVC Port-number bias
:	First of all, copy text to working storage
	LHI	R1,PVCUNL-4
INITPU	L	R0,IPVCUN,R1		:Copy user name
	ST	R0,PVCUN,R1
	SIS	R1,4
	JGEBS	INITPU

:	Now put node number into PVC messages
	LHL	R0,NODEX,,		:Get node number from Common
	LA	R3,PVCUN+2		:pointer to Username string
	LIS	R4,4			:4 bytes
	JAL	R6,OOS			:Put string in place

	LHI	R1,PVCPWL-4		:repeat for password
INITPP	L	R0,IPVCPW,R1
	ST	R0,PVCPW,R1
	SIS	R1,4
	JGEBS	INITPP
	LHL	R0,NODEX,,		:Again
	LA	R3,PVCPW+6		:...for password
	LIS	R4,4
	JAL	R6,OOS
	 EI	:PVC

:	Initialize processes
	JAL	R0,IZBB			:Initialize buffers and bufferlets
	 IF	NAPORT
	JAL	R6,IZASYN		:Initialize ASYNC
	 EI	:NAPORT
	 IF	NSPORT
	GL	SINIT
	JAL	R0,SINIT		:initialize SIO ports
	 EI	:NSPORT
	 IF	PVC
	JAL	R0,PVCIZ		:Initialize PVC tables
	 EI	:PVC
	 IF	NUMPRN
	GL	INITP
	JAL	R0,INITP		:initialize printers
	 EI	:NUMPRN
	 IF	NHOST

:	Set all hosts up, shut
	LHI	R5,NHOST-1		:For all hosts
XHOST	LIS	R0,0E			:14d-byte message
	LIS	R1,0			:..for port 0
	LHI	R2,10			:....type 10, extended host status report
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LIS	R0,0
	JAL	R4,PUTCH		:Pad for slot key
	JAL	R4,PUTW			:ISIS will fill in host no, number of ports.
	LR	R0,R5
	JAL	R4,PUTH			:Relative Host number
	LHI	R0,100			:Status = down | host key = null
	JAL	R4,PUTH			:set shut
	LIS	R0,0			:Dumb host | HID null
	JAL	R4,PUTH			:Set that
	JAL	R4,ELOR			:End-Logical-Output-Record
	SIS	R5,1			:Repeat for all hosts
	JGE	XHOST
	 EI	:NHOST

	 IF	FORRUN
	LA	R0,EXEC			:set EXEC as start of foreground
	SVC	2,1
BAKLOP	SVC	FASTD,0			:run entirely in foreground from now on
	JAL	RLINK,FPDISP		:go do front-panel display
	JBS	BAKLOP
	 EI	:FORRUN
	SUBTTL	EXEC LOOP

EXEC	SVC	FASTD,0			:Fast Dismiss
	JAL	R0,TIMOUT		:Service timeouts
	JAL	R0,INPUT		:Input from ISIS
	JAL	R0,TIMOUT		:Service timeouts
	 IF	1-FORRUN
	JAL	RLINK,FPDISP		:go do front-panel display
	JAL	R0,TIMOUT		:Service timeouts
	 EI	:1-FORRUN
	J	EXEC


:	General return routine
RET	L	R0,RET4			:exit for several routines
	JR	R0
	SUBTTL	FRONT PANEL DISPLAY DRIVER

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		    F R O N T   P A N E L   D I S P L A Y    		::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:	Format:	 DC: 0 | DN	(if configuration error)
:			then DC=device code, DN=device number
:	 else	delta-T|N.IPORT	(if no configuration error)
:			then high-order bit blinks at 1-second rate
FPDISP	LH	R0,CERR			:Doing Configuration-error?
	JNR	RLINK			:Yes
	LIS	R6,1			:Update Front-panel cycle-counter
	AH	R6,FPCNT
	STH	R6,FPCNT
	THI	R6,0F			:check if we've been here 16 times
	JNR	RLINK			:no...just exit
	L	R5,FASTC,,		:compute elapsed time
	LR	R1,R5			:copy time
	S	R1,FPETIM
	ST	R5,FPETIM		:and update time
	 IF	DCPSSW
	THI	R5,400			:1.7 second test
	JE	FPDIS2			:it's time...display CPS
	LIS	R0,0			:no...enable CPS calculation next time
	STH	R0,FPCPSC
	 EI	:DCPSSW
	SRLS	R1,4			:delta-t/16d
	SLLS	R1,8			:place digits
	OH	R1,IPORTS		:Display active ISIS ports
	THI	R6,40			:4 times on, 4 off...
	JEFS	FPDIS1			:...flash high-order bit
	OHI	R1,8000
FPDIS1	STH	R1,FPANEL		:Display on Front-panel
	JR	RLINK			:and exit
	 IF	DCPSSW

:	Display CPS
FPDIS2	TS	FPCPSC			:already calculated?
	JL	FPDIS3			:yes...just skip
	LIS	R0,0
	LHL	R1,CPSOUT		:output CPS
	AH	R1,CPSIN		:input CPS
	STH	R0,CPSIN		:re-initialize
	STH	R0,CPSOUT
	AM	R1,FPLCC		:accumulate long-time char count
	LHI	R2,RATE
	MHR	R1,R2			:R1= chars*clock tick-rate (per second)
	LR	R2,R5			:copy current time
	S	R2,FPSTIM		:compute difference
	ST	R5,FPSTIM		:and update
	DHR	R1,R2			:R2 = CPS
	STH	R2,FPSHAV		:save new value of short-CPS
	LH	R0,FPCPSX		:get counter
	SIS	R0,1			:decrement
	STH	R0,FPCPSX		:and save
	NHI	R0,0F			:time to recompute long average?
	JN	FPDIS3			:no...just skip
	L	R1,FPLCC		:get long count
	ST	R0,FPLCC		:..and reset it
	LHI	R2,RATE
	MR	R0,R2			:R1= chars*clock tick-rate (per second)
	LR	R2,R5			:copy current time
	S	R2,FPLTIM		:compute difference
	ST	R5,FPLTIM		:and update
	DR	R0,R2			:R1 = CPS
	STH	R1,FPLGAV		:save long-CPS average

:	proceed with display
FPDIS3	LHL	R0,FPSHAV		:assume short display
	THI	R5,1800			:Display 3.4 or 54.6 second average ?
	JNFS	FPDIS4			:Go display short (3.4) CPS
	LIS	R0,0			:long...assume blink off
	THI	R6,40			:Flash on or off ?
	JEFS	FPDIS4
	LHL	R0,FPLGAV		:on...get long CPS average
FPDIS4	STH	R0,FPANEL		:Display
	JR	RLINK
	 EI	:DCPSSW

	FO	DATA
	SUBTTL	CONSAT -- POLLING LOOP

	MO	.,CONSAT
	LO	DATA

:	Run every 10 ms.
POLL	LHI	RPOL,(NGRP-2)*2		:For all groups...
	LR	R15,R1			:copy next-activation time
VRET0	 IF	NSPORT
	LCS	R0,1
	ST	R0,P.DONE,RPOL		:set all bits
	JFS	VRET			:and skip

VDEF	RBT	RP,P.DONE		:set defered-input
	 ELSE	:NSPORT
VDEF	HS	0
	 EI	:NSPORT

VRET	L	R0,RLA,RPOL		:If receiver active
	N	R0,DQDAT,RPOL		:...that have data available
	 IF	NSPORT
	N	R0,P.DONE,RPOL		:.....Unless already serviced
	 EI	:NSPORT
	JFFO	R0,VRET1		:Find out which one
	SIS	RPOL,4			:Else check next group
	JGE	VRET0
	JFS	XMIT

VRET1	LR	RP,RPOL			:compute port number
	SLLS	RP,3
	AR	RP,R1			:For bit tests
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP2		:get port-table pointer
	L	RBP,.FTBUF,RPI		:Get From-terminal buffer pointer
	L	R5,.VSTAT,RPI		:Get pointer to Receiver Routine
	JALR	RLINK,R5		:...And go to it
	J	VRET			:Then do rest of ports

XMIT	LHI	RPOL,(NGRP-2)*2

:	check for re-activation
	CL	R15,FASTC,,
	JL	EXDISM			:exit if time to reactivate
XMIT0	LCS	R0,1
	ST	R0,P.DONE,RPOL		:set all bits
	JFS	XRET

XDEF	RBT	RP,P.DONE		:set defered output

XRET	L	R0,TOPORT,RPOL		:Get data-present flag array
	N	R0,TAM,RPOL		:...unless backpressured
	N	R0,P.DONE,RPOL		:...unless deferring
	JFFO	R0,XMIT2		:Find first one
	SIS	RPOL,4
	JGE	XMIT0			:Do for all Groups
	J	EXDISM			:Done...return to timeout process

XMIT2	LR	RP,RPOL			:Compute port number
	SLLS	RP,3
	AR	RP,R1			:For bit tests
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP2		:Get pointer to port-table
	L	RBP,.TTBUF,RPI		:pointer to to-terminal buffer
	L	R5,.XSTAT,RPI		:Locate output state
	JALR	RLINK,R5		:And go do it
	J	XRET			:Service next port
	SUBTTL	CONSAT -- AYSNC PROCESSES
	 IF	NAPORT

:	A.VID is called when ASYNC terminal is identified.
:	R9 -	link register
:	RP -	Port number
:	RP2 -	2*Port number
A.VID	JAL	RBF,A.DAT		:set data-mode
	LB	RBC,OBRATE,RP		:Set output baud-rate
	JAL	RBF,A.OBR		:send control
	LB	RBC,IBRATE,RP		:set input baud-rate
	JAL	RBF,A.IBR		:send control
	JR	R9			:and return


:	Initialize new port
:	RLINK -	Link register
:	RP -	Port number
:	RPI -	Port information table pointer
A.ANS	SBT	RP,TAM			:Turn TAM on
	LB	RBC,OBRATE,RP
	JAL	RBF,A.OBR
	JR	RLINK
	SUBTTL	CONSAT -- ASYNC ANSWER/HANG


:		HANG/ANSWER logic
:		-----------------

:	This is the environment-dependent portion of ASYNC HANG/ANSWER:
:	It performs the following sequence of functions:
:	1	Performs input for DSR and CP --> CPSAMP,
:	2	Calls AHNGAN to compute state changes
:			AHNGAN may in turn call upon A.ANS
:	3	Upon return from AHNGAN, outputs DTR.

HANGAN	LHL	R1,HAC			:get cursor for CPSAMP array
	SHI	R1,NAGRP*2
	JGEFS	HNGAN1			:Skip if non-negative
	LHI	R1,NAGRP*6		:else re-cycle
HNGAN1	STH	R1,HAC			:and save
	LHI	RPOL,(NAGRP-1)*2	:start with last group
HNGAN2	LH	R0,HDWCP,RPOL
	STH	R0,CPSAMP,R1,RPOL
	LH	R0,HDWDSR,RPOL
	STH	R0,NEWDSR,RPOL
	SIS	RPOL,2			:for next group
	JGEBS	HNGAN2
	JAL	R0,AHNGAN		:*** now call upon logic
	LHI	R1,(NAGRP-1)*2		:start with last group
HNGAN3	LHL	R0,DTR,R1		:Output DTR
	STH	R0,HDWDTR,R1
	SIS	R1,2			:for next group
	JGEBS	HNGAN3
	J	EXDISM			:then exit
	SUBTTL	CONSAT -- ASYNC INITIALIZATION

:	CRASH CODES
:	-----------
C.IZAS	EQ	80			:Failed connecting ASYNC logical unit

CNASYN	EQ	0C0			:new SVC to connect ASYNC

	SEG	3
	BND	10			:Force to proper boundary
DQ	BS	NAGRP*10*2*AR.RS	:2 rings/port, AR.RS bytes/ring

	SEG	A.CODE

:	Create pointer tables
Q	EQ	DQ+AR.RS
AR.TT	WS	0			:pointers to to-terminal buffers
	 RE	NAGRP*10
	WC	Q
Q	EQ	2*AR.RS+Q
	 ER

Q	EQ	DQ
AR.FT	WS	0			:pointers to from-terminal buffers
	 RE	NAGRP*10
	WC	Q
Q	EQ	2*AR.RS+Q
	 ER

:	define layout of ring:
AR.BCT	EQ	0			:halfword BCT...empty when =-1
AR.TAM	EQ	2			:halfword TAM threshold..TAM on when >0
AR.FC	EQ	4			:byte fill cursor (rel. to ring start)
AR.EC	EQ	5			:byte empty cursor (rel. to ring start)
AR.IC	EQ	6			:byte initial cursor

:	Initialize tables
:	R6 -	link register
IZASYN	LM	R14,SPED.A,,		:get terminal-speeds accepted
	STM	R14,A.SPED		:set terminal-speeds supported
	LIS	RP,0			:Starting with first port
	LIS	R0,AR.IC		:initial cursor
	LA	R2,DQ,,			:Locate input rings
	LCS	R3,7			:Initialize TAM count values
IZASN1	RBT	RP,TAMMER		:Reset transition marker
	SBT	RP,TAM			:Mark not backpressured
	RBT	RP,QDDAT
	RBT	RP,DQDAT		:...and no data
	SBT	RP,HANGWT		:hang that port (just in case)
	LR	R1,RP			:copy port number
	SLLS	R1,2			:Make buffer index
	TS	AR.BCT,R2		:Set input BCT count
	STB	R0,AR.FC,R2		:set fill and empty cursors
	STB	R0,AR.EC,R2
	TS	AR.RS+AR.BCT,R2		:set output BCT count
	STH	R3,AR.RS+AR.TAM,R2	:and output TAM count
	STB	R0,AR.RS+AR.FC,R2	:fill cursor
	STB	R0,AR.RS+AR.EC,R2	:and empty cursor
	AHI	R2,2*AR.RS		:point to next ring
	AIS	RP,1			:Next port
	CLHI	RP,NAPORT
	JL	IZASN1
	LCS	R1,1			:For each logical unit...
	LA	R2,ASNPUT		:Location of physical offsets
	LIS	R3,2
	LIS	R5,0			:port group
	 IF	AHIST;	STH	R5,AHISX;	 EI
	LM	R9,ASYBK		:initialize pointers
					: R8 -	LU number
					: R9 -	pointer to start of group ring array
					: R10 -	address of group CP half-word
					: R11 -	address of group DSR half-word
					: R12 -	address of group DTR half-word
					: R13 -	address of group TOPORT half-word
					: R14 -	address of group FROMPORT half-word
					: R15 -	address of group TAM half-word
IZASN2	AIS	R1,1			: Next L.U.
	SVC	IO,8000+R1,,		:Query the L.U. attributes
	 JAL	R7,IZASCR		:fail...abort
	LB	R4,0,R2			:check L.U. type
	CLHI	R4,0FE			:check device
	JEBS	IZASN2			:ignorable
	JLFS	IZASN3			:skip unless end-of-list
	TS	CERR			:exhausted devices...CONFIGURATION ERROR!
	JLR	R6			:exit...one already exists
	SRLS	R5,1			:else compute async group
	OHI	R5,1000			:display error forever!
	STH	R5,FPANEL
	JR	R6			:Done...exit

IZASN3	SIS	R4,1			:(expect 01|group #)
	JN	IZASN2			:ignore if not ASYNC
	LB	R4,1,R2			:get physical async group number
	SLLS	R4,4
	OHI	R4,100			:set ASYNC device
IZASN4	STH	R4,0,R2			:save it
	AIS	R2,2			:point at next
	AIS	R4,1
	THI	R4,0F			:fill in 16 entries
	JNBS	IZASN4
	TS	HDWDSR,R5		:start ports as inactive
	TS	HDWCP,R5
	AIS	R5,2			:set next group
	LR	R8,R1			:copy LU number
	OI	R8,AR.RS^10		:fill in ring size
	STM	R8,ATEMP		:save for SVC
	LA	R0,ATEMP		:point at block
	SVC	IO,CNASYN		:connect this ASYNC LU
	 JAL	R7,IZASCR		:connect failed, crash
	CLHI	R5,2*NAGRP		:Done all?
	JGER	R6			:yes...exit
	AHI	R9,20*AR.RS		:no...set next block
	AIS	R10,2			:next CP
	AIS	R11,2			:next DSR
	AIS	R12,2			:next DTR
	AIS	R13,2			:next TOPORT
	AIS	R14,2			:next FROMPORT
	AIS	R15,2			:next TAM
	J	IZASN2			:and repeat

:	Connect-ASYNC SVC failure
IZASCR	SIS	R7,8			:point at SVC call
	ABORT(R7,C.IZAS)

:	Initialization data-block for ASYNC code
ASYBK	WC	DQ,HDWCP,HDWDSR,HDWDTR,QDDAT,DQDAT,TAM

:	Port-Busy processing
:	==== ====
:	Check for busy-able ports which require service
A.BUSY	LHI	RPOL,(NAGRP-1)*2	:For each group...
BSY.1	LH	R0,BUSY.A,RPOL		:attention required?
	JFFOH	R0,BSY.2		:find it
	SIS	RPOL,2			:else proceed to next group
	JGEBS	BSY.1
	J	EXDISM

BSY.2	LR	RP,RPOL
	SLLS	RP,3
	AR	RP,R1			:Compute port-number
	RBT	RP,BUSY.A		:cancel attention
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHI	RBC,0E3			:RS up
	TBT	RP,BUSY.H		:which way should it be set?
	JNFS	BSY.3
	LHI	RBC,0E4			:RS down
BSY.3	JAL	RBF,AWCP
	J	BSY.1			:and proceed
	SUBTTL	CONSAT -- ASYNC - GET a CHaRacter, PUT a CHAracter

:	Get a character
:	RCH -	Link register
:	RBP -	Buffer pointer
:	RBC -	Data Character
:	Normal return if Control-Signal:
:		Then Signal is in R5, Value (if any) in RBC
:	Else Skip (-4) Return.
AGETCH	JAL	RBF,AGCI		:Get the data character
	LR	RBC,RBC			:check for data
	 IF	CPS
	JEFS	AGETC2			:not data
AGETC1	MINH(R4,CPSIN)			:count input data
	J	4,RCH			:and skip-return
AGETC2	HS	0
	 ELSE
	JN	4,RCH			:data...skip-return
	 EI	:CPS
	JAL	RBF,AGMI		:Escaped...get next byte
	LR	R5,RBC			:test if data
	 IF	CPS
	JEBS	AGETC1			:escaped 0...data
	 ELSE
	JE	4,RCH			:Escaped 0...skip-return
	 EI	:CPS
	LHI	RBC,-80,R5		:Control...translate it
	JL	AGC.CR			:Shouldn't be .LT. 80
	LO	SIGNAL
	LIS	R5,TIBSIG		:check for TID IBR
	LHI	R4,80-90,RBC
	JLR	RCH			:yes...return it
	JGFS	AGETC3			:not break-begin either
	LIS	R5,BBSIG		:break-begin
	JR	RCH			:...just return signal
AGETC3	LIS	R5,BESIG		:assume break-end
	SIS	R4,91-90		:verify it
	JER	RCH			:yes...return

	FO	SIGNAL

AGC.CR	ABORT(RCH,0F0)			:crash if something not expected



:	Put a (data) character
:	RCH -	Link register
:	RBC -	Data Character
APUTCH	 IF	CPS;	MINH(RBF,CPSOUT);	 EI
	LR	RBF,RCH			:Copy return address
	LR	R4,RBC			:Check for 0
	JN	AWCI			:no...just proceed with AWCI
	J	AWCP			:Use AWCP to put it into buffer escaped
	SUBTTL	CONSAT -- ASYNC CHARACTER MOVER

	DEFAULT(AHIST,0)		:keep history of activity if 1

	 IF	AHIST
	SEG	A.DATA
:	History buffer:
:	AHISX -	HW cursor for next entry (relative to AHISD)
:	entry -	BC	Character,
:		BC	buffer number (RBP/4)
:		HC	low-order 16-bits of RBF (caller address)
AHSIZ	EQ	400
AHISX	HS	1
AHISD	HS	AHSIZ/2

	SEG	A.CODE
:	Keep history
:	R0 -	Link
:	R1 -	Character
:	R3 -	Scratch
AHISTY	LHL	R3,AHISX		:get history index
	STB	RBC,AHISD,R3		:save char
	STB	RP,AHISD+1,R3		:save port #
	STH	RBF,AHISD+2,R3		:save caller
	AIS	R3,4			:advance cursor and save
	NHI	R3,AHSIZ-1
	STH	R3,AHISX
	JR	R0
	 EI	:AHIST



:	This begins the ASYNC character driver.  This driver uses the
:	ENGINE bufferlet code to send bytes across a 16-byte ring to
:	the ISIS ASYNC driver.

:	ASYNC Delay-generator
:	----- ----- ---------
:	RCH -	Link register
:	R5 -	Delay count
ADELAY	LIS	RBC,0			:reset MARGE
	STH	RBC,MARGE,RP2
	LR	RBC,R5			:Check for *ANY* delay
	JER	RCH			:no...just return
	SHI	R5,8F			:check for overflow
	JLEFS	ADLAY1			:skip if not
	LHI	RBC,8F
	JAL	RBF,AWCP		:send max
	LR	RBC,R5			:second delay for remainder
ADLAY1	JAL	RBF,AWCP		:send rest of delay
	JR	RCH			:and exit

:	Set Input baud-rate
:	--- ----- ---------
:	RBC -	rate value
:	RBF -	link
A.IBR	OHI	RBC,0B0			:set IBR
	J	AWCP			:and go send it

:	Set Output baud-rate
:	--- ------ ---------
:	RBC -	rate value
:	RBF -	link
A.OBR	OHI	RBC,090			:set OBR
	J	AWCP			:and go send it

:	Set TID mode
:	--- --- ----
:	RBF -	link
A.TID	LHI	RBC,0D0			:set Connect mode
	J	AWCP			:and go send it

:	Set DATA mode
:	--- ---- ----
:	RBF -	link
A.DAT	LHI	RBC,0E0			:set Data mode
	J	AWCP			:and go send it

:	Set DISCONNECT mode
:	--- ---------- ----
:	RBF -	link
A.DSC	LHI	RBC,0E1			:set Disconnect mode
	J	AWCP			:and go send it

:	Set RS to 0
:	--- -- -- -
:	RBF -	link
A.RS.U	LHI	RBC,0E3			:set RS up
	J	AWCP			:and go send it

:	Set RS to 1
:	--- -- -- -
:	RBF -	link
A.RS.D	LHI	RBC,0E4			:set RS down
	J	AWCP			:and go send it

:	Get a char from Async input ring
:	RBF -	link
:	RBP -	preserved
:	RP -	Port number
:	RBC -	Character returned

:	Entry point for control-byte
AGMI	SBT	RP,DQDAT

AGCI	L	R4,AR.FT,RP2,RP2	:pointer to input ring
	LB	R3,AR.EC,R4		:empty cursor
	LB	RBC,0,R4,R3		:get char
	AIS	R3,1			:bump cursor
	CLHI	R3,AR.RS		:check for ring-fold
	JLFS	AGCI1
	LIS	R3,AR.IC
AGCI1	STB	R3,AR.EC,R4		:save updated cursor
	 IF	AHIST;	JAL	R0,AHISTY;	 EI	:AHIST
	MDCH(R0,AR.BCT,R4)		:decrement BCT
	JGER	RBF			:return if not empty
	CBT	RP,DQDAT		:Flip flag
	JR	RBF


:	Place a single char in Async output ring
:	RBF -	link
:	RBC -	char to transmit
:	RBP -	Preserved
AWCI	 IF	AHIST;	JAL	R0,AHISTY;	 EI
	L	R4,AR.TT,RP2,RP2
	LB	R3,AR.FC,R4		:empty cursor
	STB	RBC,0,R4,R3		:stuff the character
	AIS	R3,1
	CLHI	R3,AR.RS
	JLFS	AWCI1
	LIS	R3,AR.IC
AWCI1	STB	R3,AR.FC,R4		:save updated cursor
	MINH(R0,AR.BCT,R4)		:Increment BCT
	JGFS	AWCI2			:already there...check TAM
	CBT	RP,QDDAT		:Flip data-flag
	AHM	R0,AR.TAM,R4		:and update TAM count
	JR	RBF
AWCI2	AHM	R0,AR.TAM,R4		:Update TAM count
	JLR	RBF			:Return...no backpressure
	JGFS	AWCI3			:greater, check TAM
	SBT	RP,TAMMER		:Note that passed zero
	JR	RBF
AWCI3	RBT	RP,TAMMER		:Been here yet?
	JER	RBF			:yes
	CBT	RP,TAM			:no...set TAM
	JR	RBF


:	Place escaped char in Async output ring
:	RBF -	link
:	RBP -	preserved
:	RBC -	char to transmit
AWCP	SLLS	RBC,8			:preceed with null
	 IF	AHIST;	JAL	R0,AHISTY;	 EI
	L	R4,AR.TT,RP2,RP2	:get pointer to buffer
	LB	R3,AR.FC,R4		:fill cursor
	STB	RBC,0,R4,R3		:place char
	AIS	R3,1
	CLHI	R3,AR.RS
	JLFS	AWCP1
	LIS	R3,AR.IC
AWCP1	SRLS	RBC,8			:normal exit...position the character
	STB	RBC,0,R4,R3		:save char
	AIS	R3,1
	CLHI	R3,AR.RS
	JLFS	AWCP2
	LIS	R3,AR.IC
AWCP2	STB	R3,AR.FC,R4		:save cursor
	 IF	AHIST;	JAL	R0,AHISTY;	 EI
	MINH(R0,AR.BCT,R4)		:Bump BCT
	JGFS	AWCPX1
	AHM	R0,AR.BCT,R4		:Bump BCT again
	LIS	R0,2			:and TAM count
	AHM	R0,AR.TAM,R4		:...twice
	CBT	RP,QDDAT		:and set data
	JR	RBF
AWCPX1	AHM	R0,AR.BCT,R4
	AHM	R0,AR.TAM,R4		:Update TAM count
	JGFS	AWCPX2			:Check if TAM must be fiddled with
	SBT	RP,TAMMER		:Mark transition
AWCPX2	AHM	R0,AR.TAM,R4		:bump TAM again
	JLER	RBF
	RBT	RP,TAMMER		:Has it been marked yet?
	JER	RBF			:If reset, then TAM already done
	CBT	RP,TAM
	JR	RBF
	SUBTTL	CONSAT -- PRINTER PROCESSES

	 IF	NUMPRN

:	PRINTER Initialization routine
:	R0 -	Link register
INITP	TS	PRTACT			:set not-active
	LIS	R1,0			:Use R1 to count LUN's
	LIS	RP,0			:use RP to count printers
INITP1	LA	R2,LUNPRN,RP		:use R2 to specify table for QUERY SVC
	LIS	R3,1			:R3 says query one byte of info
	SVC	IO,8000+R1,,		:get the attributes for this Logical unit
	JAL	R10,CRASH
	LB	R2,LUNPRN,RP		:get the device type
	SIS	R2,2			:is it a printer?
	JNFS	INITP2			:skip if not
	LR	RP2,RP
	AR	RP2,RP2			:2*port #
	JAL	RCH,PINIT		:Initialize ROTOR
	STH	RP,PRTACT		:keep count of NUMPRN
	STB	R1,LUNPRN,RP		:save LUN for this printer
	AIS	RP,1			:count this printer
INITP2	AIS	R1,1			:do for all Logical-Units
	CLHI	R2,0FE-2		:'FE' signals last LUN
	JGEFS	INITP3			:skip if LU's exhausted
	CLHI	RP,NUMPRN		:have we found all the printers?
	JER	R0			:yes...exit
	J	INITP1			:no...keep searching
INITP3	TS	CERR			:LU's exhausted...CONFIGURATION ERROR
	JLR	R0			:exit if one already found
	AHI	RP,2000			:Display 2|0|0|0|n
	STH	RP,FPANEL
	JR	R0			:and exit


:	Initialize a (Specific) printer
:	RP -	Printer (port) number
:	RP2 -	2*port number
:	RCH -	Link register
PINIT	LHI	R4,NROT*BUFSIZ		:compute offset
	MHR	R4,RP
	LA	R4,PAREA,R4		:address of buffer
	ST	R4,SVCPTR,RP2,RP2	:save pointer to area start
	LR	R5,R4			:copy pointer
	LIS	R3,0
	 RE	NROT			:set up each rotor entry
	ST	R3,0,R5			:zero command|count for each block
	LA	R6,10,R5		:point to adjacent data area
	ST	R6,4,R5
	ST	R3,8,R5			:zero command|count for each jump
	LA	R6,BUFSIZ,R5		:point to next command area
	ST	R6,0C,R5
	LR	R5,R6			:point to next SVC entry
	 ER	:NROT
	ST	R4,(NROT-1)*BUFSIZ+0C,R4 :make JUMP back to beginning
	LB	R3,LUNPRN,RP		:get the LUN
	LA	R5,STAT,RP2		:address for status
	SVC	IO,50+R3		:and halt I/O
	 NOP	0			:SVC normal return..I/O already in progress
	JR	RCH			:and exit


:		PRINTER set-up
:	Verify that there are 2 ROTORS available (for
:	compression overflow), then set up pointers.
:	Skip-4 return if no room, else normal return
:	R9 -	Pointer to current rotor entry
:	R6 -	pointer to next char within rotor
:	RBF -	Link register
:	RP -	Printer (port) number
:	RP2 -	2*port number
SETPRN	L	R9,SVCPTR,RP2,RP2	:get current rotor entry
	LHL	R0,0,R9			:is this rotor available?
	JN	4,RBF			:busy...skip return
	L	R6,0C,R9		:get next rotor pointer
	LHL	R0,0,R6			:is that rotor available?
	JER	RBF			:yes...normal return
	J	4,RBF			:busy...skip return


:	Print multiple characters
:	RBC -	Character to print
:	R6 -	Number of time to print it
:	RCH -	Link register
:	RP -	Printer (port) number
:	Normal return - just proceed
:	Skip (4) return - buffer flushed
PMULT	CLHI	R6,1			:how many chars to output?
	JLR	RCH			:none...quit
	JE	PMULTX			:only 1...skip
	CLHI	RBC,0A0			:Blanks?
	JE	PMULT1			:yes...just proceed

:	Character compression
	JAL	RBF,PCHAR		:no...print the character
	 NOP	0			:don't care about skip returns
	SIS	R6,1			:reduce the count
	LHI	RBC,40,R6		:set up the compression
	SHI	R6,3F			:must we do it in one or two steps?
	JLE	PMULT3			:one...go do it
	LHI	RBC,7F			:two...first value
	LHI	R6,41,R6		:...and remainder
	J	PMULT2			:skip to do it

:	Blank compression
PMULT1	LR	RBC,R6			:copy the count
	SHI	R6,3F			:how many blanks?
	JLEFS	PMULT3			:less than 40..send it
	AIS	R6,1			:more than 40...
	LHI	RBC,3F			:send this many first...

:	Send compression in 2 passes
PMULT2	JAL	RBF,PCHAR
	 NOP	0			:don't care about skip returns
	LR	RBC,R6			:this many more

:	Send remainder of compression
PMULT3	JAL	RBF,PCHAR		:send it
	 NOP	0			:don't care about skip returns
	J	4,RCH			:and skip-exit

:	Output single char...just pass through PCHAR
PMULTX	LR	RBF,RCH			:copy return and fall through


:	Print a character
:	RBC -	Character to print
:	RBF -	Link register
:	RP -	Printer (port) number
:	Normal return - just proceed
:	Skip (4) return - buffer flushed
PCHAR	LHL	R3,2,R9			:get cursor
	STB	RBC,10,R9,R3		:store the character
	AIS	R3,1			:bump the count
	STH	R3,2,R9			:put it back
	LR	RBC,RBC			:flush if CR (0)
	JEFS	PFLUSH
	CLHI	R3,BUFSIZ-11		:this is the buffer size
	JLER	RBF			:return if ROTOR-buffer not yet full


:	Flush current Print-rotor
:	RBF -	Link register
:	RP -	Printer (port) number
:	RP2 -	2*Printer (port) number
:	Normal return - just proceed
:	Skip (4) return - buffer flushed
PFLUSH	LH	R3,2,R9			:check buffer
	JER	RBF			:empty...just exit
	LIS	R3,1			:get the write command
	STH	R3,0,R9			:put into the SVC block
	LIS	R3,2			:prepare transfer command
	STH	R3,8,R9
	LB	R3,LUNPRN,RP		:get the LUN
	LR	R4,R9			:...and pointer to rotor entry
	L	R9,0C,R9		:get next rotor entry
	ST	R9,SVCPTR,RP2,RP2	:update entry
	LIS	R5,0			:Init it's count
	STH	R5,2,R9
	LA	R5,STAT,RP2		:address for status
	SVC	IO,40+R3		:and start I/O
	 NOP	0			:SVC normal return..I/O already in progress
	J	4,RBF			:SVC skip return...I/O started

	 EI	:NUMPRN

	 EI	:NAPORT
	SUBTTL	CONSAT -- SIO PROCESSES

	 IF	NSPORT

:	Initialize new port
:	RLINK -	Link register
:	RP -	port number
:	R1 -	Offset for command area (relative to SIO port 0)
Q.SANS	SBT	RP,DQDAT		:force service
	LB	R5,LUNSIO,RP		:Set logical unit
	LIS	R6,0
	SVC	IO,0B0+R5		:reset channel
	 JAL	R15,SABORT		:system skips this on success
	LA	R6,ICMSIO,R1		:point to command area
	SVC	IO,0A0+R5		:and start it
	 JAL	R15,SABORT
	JR	RLINK			:Then exit


:	Circuit disconnected
:	RLINK -	Link register
:	RP - 	number for SIO port
Q.SHNG	LB	R5,LUNSIO,RP		:set Logical unit
	LIS	R6,0			:Reset
	SVC	IO,0B0+R5		:Do it
	 JAL	R15,SABORT
	J	CIRDIS			:exit via CIRDIS

:		SIO Initialization
:		--- --------------
:	Find all SIO channels that are available
SINIT	LM	R12,S.ASCI		:Get the ASCII initial routine
	STM	R12,SAVSIO
	LI	R14,00051113		:make the XONENA program
	STM	R14,XONSIO
	LI	R14,0005FFFF		:make XOFF program
	STM	R14,XOFSIO
SINIT1	LHI	RP,.SPORT		:make a pointer into the SIO ports
	LCS	R1,1			:R1 is the LUN to be queried
	LIS	R3,1			:Query 1-byte of info
SINIT2	AIS	R1,1			:For next unit
	LA	R2,LUNSIO,RP		:Address of Query
	SVC	IO,8000+R1,,		:Get the attributes for this unit
	 JAL	R15,SABORT
	LB	R5,0,R2			:get the type
	CLHI	R5,4			:is it a SIO channel?
	JN	SINIT3			:no
	STB	R1,0,R2			:Store the LUN number
	LHI	R5,400,R1
	STH	R5,ASNPUT,RP,RP		:save for accounting ports
	SBT	RP,GOTSIO		:Set channel available
	RBT	RP,HANGWT		:and start with no soft-hang
	LR	R5,R1			:prepare for connect
	LA	R6,LOWSIO		:low limit
	LA	R7,HIHSIO		:High limit
	LHI	R4,-.SPORT,RP		:convert RP to SIO-port index
	SLLS	R4,5			:make 8-word index
	TS	OCMSIO+1A,R4		:set count negative
	LA	R8,OCMSIO+10,R4		:and set status-address
	LA	R9,DQDAT*8,RP,		:make a bit pointer with bit
					:addressing, and add SIO offset
	SVC	IO,90+R5		:connect
	 JAL	R15,SABORT

:	Now initialize the input program for this channel
	LIS	R6,0
	SVC	IO,0B0+R5		:reset channel
	 JAL	R15,SABORT
	LR	R5,R1			:get LUN
	LA	R6,SAVSIO		:and QUAD address
	SVC	IO,0B0+R5		:Initialize SIO registers
	JAL	R15,SABORT
	AIS	RP,1			:for next channel
	CLHI	RP,.SPORT+NSPORT	:Done?
	JL	SINIT2			:Try next unit
	JR	R0			:done...exit

SINIT3	CLHI	R5,0FE			:is this all the LUN?
	JN	SINIT2			:no
	TS	CERR			:yes...CONFIGURATION ERROR
	JLR	R0			:already have one...exit
	AHI	RP,3000-.SPORT		:display 3|0|0|port
	STH	RP,FPANEL
	JR	R0			:done

SABORT	ABORT(R15,0)			:SIO SVC failure

	 EI	:NSPORT

	FO	DATA
	EM	:CONSAT
	SUBTTL	GET/PUT a CHaRacter, PUT a SIGnal

:	Get a character
:	RCH -	Link register
:	RBP -	Buffer pointer
:	RBC -	Data Character
:	Normal return if Control-Signal:
:		Then Signal is in R5, Value (if any) in RBC
:	Else Skip (-4) Return.
	GL	GMI
GETCHR	JAL	RBF,GCI			:Get the data character
	LR	RBC,RBC			:check for data
	JN	4,RCH			:data...skip-return
	JAL	RBF,GMI			:Escaped...get next byte
	LR	R5,RBC			:test if data
	JE	4,RCH			:Escaped 0...skip-return
	TBT	R5,XBYTE1		:Control...test for value
	JER	RCH			:no...just return
	JAL	RBF,GMI			:yes...get it
	JR	RCH			:and return

:	Table of bits which specify multi-byte signals
XBYTE1	HC	$2 0100001100000000,0000000000000000
	HC	$2 1010101010101010,1010101010101010
	HC	$2 1010101010101010



:	Put a (data) character
:	RCH -	Link register
:	RBC -	Data Character
	 IF	1			:we'll use this buffer package for now
PUTCHR	LR	R5,RBC			:Check for 0
	JNFS	PUTCH1			:no...skip
	JAL	RBF,WCI			:yes...escape it
	LIS	RBC,0			:restore character
PUTCH1	LR	RBF,RCH			:copy return
	J	WCI			:and place data


:	Put a signal into buffer
:	RCH -	Link register
:	RBP -	Buffer pointer
:	R4 -	Signal number
:	RBC -	Value (if any)
PUTSIG	LBR	R5,RBC			:copy data
	EXBR	R5,R5
	STBR	R4,R5			:copy signal
	LIS	RBC,0			:place escape
	JAL	RBF,WCI
	LBR	RBC,R5			:restore signal
	TBT	RBC,XBYTE1		:check length
	JEFS	PUTSG1			:Skip if no value present
	JAL	RBF,WCI			:else place the signal,
	EXBR	RBC,R5			:...followed by data
PUTSG1	LR	RBF,RCH			:copy return address
	J	WCI			:and send last element
	SUBTTL	GCI/WCI Buffer Package - Microcode version

NBUF	EQ	3*NPORT			:Number of buffers

:	first NPORT buffers		 To-terminal buffers
:	Next NPORT buffers		 From-terminal buffers
:	Next NPORT buffers		 LOGON buffers

	GLOBAL(NBBFLT,10*NPORT)		:Allocate 10 bufferlets/port
	GLOBAL(RHIST,0)			:Keep bufferlet history if 1


	MO	.,BUFFER

	LO	DATA


:	This module contains all code and storage allocation needed for
:	bufferlet usage.
:	If the symbol RHIST is defined and has a value greater than 0,
:	then a trace of all GCI and WCI calls will be included and
:	HISX will be a halfword pointer into a table HISD.
:	HISD will contain 100 one word entries.  Each entry contains
:	a one byte character, one byte of buffer number, and a halfword
:	address of the caller of GCI/WCI.  The table is circular.

:	the following parameters MUST be defined before assembly:
:	NBUF	the number of buffers to create
:	NBBFLT	the number of bufferlets to create
:
:	The following symbol may be defined. If it is not defined the
:	default is FALSE.

:	may JAL R10,CRASH on certain conditions

:	Each routine is called with:
:	Link on RBF
:	R0 = argument
:	RBP = buffer index (buffer number*4)

:	routines:
:	IZBB	link on R0, used to initialize buffers
:	GCI	get a character from buffer
:	WCI	write a character into buffer
:	EMPTY	empty (flush) buffer

:	buffer index may be used to index into the following fullword arrays
:	from external routines:
:	BF	buffer flags
:	BB	buffer start address
:	BE	buffer end address
:	BCT	buffer counts

:	Note: The BF and BCT arrays consists of interleaved halfwords.


:	The data for these routines

:	BUFFERLET AREA
	SEG	A.BUFF			:Allocate in buffer area
	BND	10			:Force to multiple of 16d
BUFERS	BS	NBBFLT*10+2		:Bufferlet area size

:	DATA AREA
	SEG	A.DATA			:place into data area
REBL	HS	1			:free-list pointer for reserve-storage
REBC1	HS	1			:Counts times reserve-tank used
REBC2	HS	1			:Counts total number of buffer zaps
BFZ	HS	1			:last buffer zapped

BF	WS	NBUF			:Buffer flags
BCT	EQ	BF+2			:Buffer counts
BB	WS	NBUF			:buffer start-address
BE	WS	NBUF			:buffer end-address
SBB	WS	NBUF			:SCAN buffer-begin

	 IF	RHIST
:	History buffer:
:	HISX -	HW cursor for next entry (relative to HISD)
:	entry -	BC	Character,
:		BC	buffer number (RBP/4)
:		HC	low-order 16-bits of RBF (caller address)
HSIZ	EQ	400
HISX	HS	1
HISD	HS	HSIZ/2

	SEG	A.CODE
:	Keep history
:	R0 -	Link
:	R1 -	Character
:	R2 -	Buffer-pointer
:	R3 -	Scratch
HISTY	LHL	R3,HISX			:get history index
	STB	RBC,HISD,R3		:save char
	SRLS	RBP,2			:convert to buffer no.
	STB	RBP,HISD+1,R3		:and save it
	SLLS	RBP,2			:back to buffer index
	STH	RCH,HISD+2,R3		:save caller
	AIS	R3,4			:advance cursor and save
	NHI	R3,HSIZ-1
	STH	R3,HISX
	JR	R0
	 ELSE	:RHIST
	SEG	A.CODE
	 EI	:RHIST

:	Code section

:	Initialize buffers
IZBB	LIS	R1,0			:set a constant
	 IF	RHIST;	STH	R1,HISX;	 EI
	LHI	R2,(NBUF-1)*4		:for all buffers
IZBB1	STH	R1,BCT,R2		:set empty
	ST	R1,BB,R2		:clear start pointer
	ST	R1,BE,R2		:clear end pointer
	SIS	R2,4
	JGEBS	IZBB1
	STH	R1,REBL			:set reserve tank empty
	STH	R1,REBC1		:set reserve tank unused
	STH	R1,REBC2		:set no buffer-zaps (yet)
	LHI	R3,NBBFLT		:for all bufferlets
	LHI	R2,NBBFLT*10		:bufferlet-pointer address
	STH	R1,BUFERS,R2,		:terminate list
IZBB2	STH	R3,BUFERS-10,R2,	:link last to this
	SHI	R2,10
	SIS	R3,1			:decrement buffer number
	JGBS	IZBB2			:repeat for all bufferlets

:	Now set up the buffer flags for all buffers
	LIS	R1,0			:buffer index for To-terminal buffers
	LHI	R2,NPORT*4		:buffer index for From-terminal buffers
	LHI	R3,NPORT*8		:buffer index for LOGON buffers
	LHI	R4,-2*NPORT		:Loop control...do for each port (count up)
	LI	R5,BFA(TOPORT)
	LIS	R6,0			:From-port starts with 0 BF
	LI	R7,BFA(GOLOG)
IZBB3	STH	R5,BF,R1		:Init To-port buffer flags
	STH	R6,BF,R2		:Init From-port buffer flags
	STH	R7,BF,R3		:Init LOGON buffer flags
	LHL	R8,(2*NPORT)+.PTP.,R4	:get pointer to port table entry
	ST	R1,.TTBUF,R8		:Set To-terminal buffer pointer
	ST	R2,.FTBUF,R8		:Set From-terminal buffer pointer
	ST	R3,.LGBUF,R8		:Set LOGON buffer pointer
	AIS	R1,4			:advance to next port
	AIS	R2,4
	AIS	R3,4
	AIS	R5,1			:advance flags too
	AIS	R7,1
	AIS	R4,2			:next port
	JL	IZBB3			:...until all ports are done
	JR	R0			:Then exit

:	CHARACTER HANDLERS.

:	RBC -	Character
:	RBP -	buffer pointer (4*buffer number)
:	R0, R3-R5 -	scratch registers
:	RBF -	link register.

:	Get character from buffer and increment forward through the buffer.
GMI	HS	0			:dummy routine to get message
GCI	IF	RHIST
	L	R3,BB,RBP		:get the character
	LB	RBC,0,R3
	JAL	R0,HISTY
	 EI	:RHIST
	MDCH(R0,BCT,RBP)		:decrement character count

GCI1	HC	3800!(RBC^4)!RBP	:**GCI RBC,RBP
	HC	BE-BB			:size of BB storage
	HC	GCICRA-GCI1		:error-routine offset
	HC	BB/4			:address of BB storage
	HC	GCINXT-GCI1		:get-next-bufferlet-routine offset
	HC	GCILAS-GCI1		:buffer-empty-routine offset
	JR	RBF			:return with the character

GCINXT	LHL	R0,0,R3			:bufferlet exhausted - get next one
	SLLS	R0,4			:convert to bufferlet-pointer
	AI	R0,BUFERS-0E		:address of first character
	ST	R0,BB,RBP		:set BB to start of next bufferlet
	LHL	R0,BUFERS,,		:get pointer to free list
	STH	R0,0,R3			:link free-list to last bufferlet
	SI	R3,BUFERS		:convert to buffer-number
	SRLS	R3,4
	STH	R3,BUFERS,,		:put at head of free-list
	JR	RBF			:then exit

GCILAS	LHL	R0,BF,RBP		:empty...get pointer to bit
	RBT	R0,FLAGS		:reset flag bit
	AIS	R3,0E			:bump pointer past end of bufferlet
	NHI	R3,-10			:make chain a multiple of 16
	LHL	R0,BUFERS,,
	STH	R0,0,R3
	SI	R3,BUFERS		:convert to buffer number
	SRLS	R3,4
	STH	R3,BUFERS,,		:update free-list
	LIS	R0,0
	ST	R0,BB,RBP		:clear BB
	ST	R0,BE,RBP		:and BE
	JR	RBF

GCICRA	ABORT(RBF,3)			:link RBF, type 3

:	Put a character into the buffer
WCI	IF	RHIST;	JAL	R0,HISTY;	EI
WCI1	HC	3900!(RBC^4)!RBP	:**WCI RBC,RBP
	HC	BE-BB			:size of BB storage
	HC	WCICRA-WCI1		:error-routine offset
	HC	BE/4			:address of BE storage
	HC	WCINXT-WCI1		:get-next-bufferlet routine
	HC	WCIFRS-WCI1		:get-first-bufferlet routine
	MINH(R0,BCT,RBP)		:update count
	JR	RBF

WCINXT	LHL	R4,BUFERS,,		:need a new bufferlet
	JNFS	WCINXC			:skip if there is another
	JAL	R0,WRE			:(open the reserve tank)
WCINXC	STH	R4,0,R3			:link new bufferlet to last one
	SLLS	R4,4			:convert to buffer-pointer
	AI	R4,BUFERS		:make absolute address
	LHL	R3,0,R4			:remove from free-list
	STH	R3,BUFERS,,
	SIS	R4,0E			:back up new buferlet
	ST	R4,BE,RBP		:save as new BE
	STB	RBC,0,R4		:put the character there
	MINH(R0,BCT,RBP)		:increment count for buffer
	JR	RBF

WCIFRS	LHL	R0,BF,RBP		:the buffer was empty
	JER	RBF			:don't waste space on unassigned buffer
	SBT	R0,FLAGS		:attn bit on to specify data queued
	LIS	R0,1
	STH	R0,BCT,RBP		:set count = 1
	LHL	R4,BUFERS,,		:pop a bufferlet off free-list
	JGFS	WCIFR1			:skip if there was one
	JAL	R0,WRE			:else open the reserve tank
WCIFR1	SLLS	R4,4			:convert to bufferlet pointer
	AI	R4,BUFERS		:compute absolute address
	LHL	R0,0,R4			:get it's successor
	STH	R0,BUFERS,,		:update free-list
	SIS	R4,0E			:point it at first character
	ST	R4,BB,RBP		:set up BB
	ST	R4,BE,RBP		:and BE
	STB	RBC,0,R4		:put the character there
	JR	RBF

WCICRA	ABORT(RBF,5)			:link RBF, type 5 crash

:	move reserve storage supply to main free-list
WRE	LHL	R4,REBL			:get pointer to reserve-list
	EXHR	R4,R4
	STH	R4,REBL			:set reserve-list empty (=0)
	EXHR	R4,R4
	JNR	R0			:if it wasn't empty, return
	ABORT(RBF,6)			:link RBF, type 6 -- out of bufferlets


:	Peek at buffer...link on RCH
:	normal return if not in use, empty, or not control signal
:	skip (4) return if leads with control-signal
:		then RBC contains pending signal
CPEEK	LHL	RBC,BF,RBP		:First get the flag
	JER	RCH			:null...return
	LH	RBC,BCT,RBP		:Check if empty
	JLR	RCH			:yes...return
	L	R3,BB,RBP		:get the character
	LB	RBC,0,R3
	JNR	RCH			:not control-signal
	AIS	R3,1
	THI	R3,0F			:check for buffer fold
	JNFS	CPEEK1			:skip if not
	LHL	R3,0,R3			:get link
	AI	R3,BUFERS		:make it absolute
CPEEK1	LB	RBC,0,R3		:else get the char
	JN	4,RCH			:Control...skip return
	JR	RCH			:data...normal return


:	IGCSCN - Initialize scan through buffer
:	RCH -	Char returned (maybe)
:	RBP -	Pointer to buffer
:	RBF -	Link register
:	Normal return if buffer empty
IGCSCN	L	RBC,BB,RBP		:get pointer to beginning
	JER	RBF			:0 - empty...just normal exit
	SIS	RBC,1			:not empty...back up one place
	ST	RBC,SBB,RBP		:save updated cursor
	J	4,RBF			:skip return

:	GCSCN -	scan through buffer
:	RCH -	Char returned (maybe)
:	RBP -	Pointer to buffer
:	RBF -	Link register
:	Normal return if at end of buffer
:	Else skip (4) return, character in RBC
GCSCN	L	RBC,SBB,RBP		:get SCAN cursor
	C	RBC,BE,RBP		:check for end
	JER	RBF			:normal return if so
	AIS	RBF,4			:else set skip return
	AIS	RBC,1			:advance cursor
	THI	RBC,0F			:test if at end of bufferlet
	JNFS	GCSCN1			:no...just skip
	LHL	RBC,0,RBC		:yes...get link
	AI	RBC,BUFERS		:make it absolute
GCSCN1	ST	RBC,SBB,RBP		:save updated cursor
	LB	RBC,0,RBC		:get the character
	JR	RBF


:	Return all the storage assigned to a buffer
:	RCH -	Link register
EMPTY	CLHI	RBP,4*NBUF		:range check on buffer pointer
	JLFS	EMPTY1			:buffer argument accepted
	ABORT(RBF,0D)			:link RBF, type 13d

EMPTY1	LHL	R0,BCT,RBP		:check contents
	JER	RCH			:exit...buffer empty
	L	R3,BB,RBP		:pointer to first character in buffer
	SI	R3,BUFERS-0E		:get relative addr, insure round-up
	SRLS	R3,4			:comvert to bufferlet number
	LHL	R0,BUFERS,,		:get pointer to free-list
	STH	R3,BUFERS,,		:this buffer's bufferlets now free-list
	L	R3,BE,RBP		:get pointer into last bufferlet
	AIS	R3,0E			:locate the pointer in this bufferlet
	NHI	R3,-10
	STH	R0,0,R3			:chain old free-list to this bufferlet
	LHL	R0,BF,RBP
	RBT	R0,FLAGS		:set flags to empty-buffer
	LIS	R0,0
	STH	R0,BCT,RBP		:set count = 0
	ST	R0,BB,RBP		:clear BB
	ST	R0,BE,RBP		:and BE
	JR	RCH			:and return

:	See if we must zap buffers because bufferlet storage running low
:	Periodic logic, run every 50 ms.
BZAP	LH	RBP,REBL		:are we on the reserve-tank?
	JN	EXDISM			:Plenty of room...don't zap buffers.

:	WCI grabbed reserve bufferlet free-list and moved it to main free-list.
:	Refill free-list with 1/8 of total bufferlet storage.
:	Zap buffers if necessary.
	MINH(R0,REBC1)			:statistic
BZAP1	LIS	R1,0			:initial pointer to start of free-list
	LHI	R0,NBBFLT/8		:Scan main free-list for 1/8 storage

BZAP2	LHL	R1,BUFERS,R1,		:get next bufferlet on free-list
	JE	BZAP3			:not enough space...zap a buffer
	SLLS	R1,4			:convert bufferlet number to index
	SIS	R0,1			:got another...count it
	JGBS	BZAP2			:go until we've got enough
	LHL	R2,BUFERS,,		:done...split free-list into two parts
	STH	R2,REBL			:beginning of the reserve list
	LHL	R3,BUFERS,R1,
	STH	R3,BUFERS,,		:beginning of main-list
	STH	R0,BUFERS,R1,		:terminate reserve-list (=0)
	J	EXDISM

:	Zap a buffer in order to get reserve tank up to 1/8 of total
:	bufferlet storage
BZAP3	LHI	R1,(2*NPORT-1)*4	:buffer pointer
	LIS	R9,0			:R9 will contain size of largest buffer
BZAP4	CLH	R9,BCT,R1		:is this buffer bigger?
	JGEFS	BZAP5			:not yet
	LHL	R9,BCT,R1		:yes...update R9
	LR	RBP,R1			:RBP will remember biggest buffer
BZAP5	SIS	R1,4			:point to next buffer entry
	JGEBS	BZAP4			:do next buffer
	LIS	R0,1
	AHM	R0,REBC2		:increment counter
	STH	RBP,BFZ			:statistics
	JAL	RCH,EMPTY		:retrieve storage
	LO	SIGNAL
	LIS	R4,GOBSIG		:Put in a gobbler
	JAL	RCH,PUTSIG
	LHI	R4,BLBSIG		:...followed by a black-ball
	JAL	RCH,PUTSIG
	FO	SIGNAL
	LIS	R0,9			:we want to send a 9-byte message,
	LIS	R1,0			:...for port 0
	LIS	R2,3			:...type 3
	JAL	R4,SLOR			:send diagnostic to sup.
	LIS	R0,0
	JAL	R4,PUTCH		:pad
	LR	R0,R9
	JAL	R4,PUTH			:HW4 = char count
	LHL	R0,BFZ			:buffer index
	SRLS	R0,2			:convert to buffer number
	JAL	R4,PUTH			:HW3 = buffer number
	LIS	R0,0
	JAL	R4,PUTCH		:HW2 = 0
	JAL	R4,ELOR			:End-Logical-Output-Record
	J	BZAP1			:try again to fill reserve-list

	 ELSE	:1

:	THE FOLLOWING RE-ENTRANT BUFFER CODE HAS A MAJOR UN-RESOLVED BUG!!!
:	OCCASIONALLY ALL BUFFERLETS DISAPPEAR, AND IT STICKS IN A BZAP
:	LOOP!!!  THIS CODE IS CONSIDERED OBSOLETE, BUT IS RETAINED BECAUSE
:	OF THE POSSIBILITY THAT IT MAY STILL BE REQUIRED.  THE BUG HAS NOT
:	BEEN FIXED!!!!!!!!!!!!!!!!!

	GL	GMI
PUTCHR	LR	RBF,RCH			:Copy return address
	LR	R4,RBC			:Check for 0
	JN	WCI			:no...just proceed with WCI
	LIS	R5,1			:else set 1-byte message
	J	WMI			:Use WMI to put it into buffer escaped


:	Put a signal into buffer
:	RCH -	Link register
:	RBP -	Buffer pointer
:	R4 -	Signal number
:	RBC -	Value (if any)
PUTSIG	LR	RBF,RCH			:Set up return address
	TBT	R4,XBYTE1		:check length
	JNFS	PUTSG1			:Skip if value present
	LIS	R5,1			:set 1-byte message
	J	WMI			:...and let WMI put it away

PUTSG1	LIS	R5,2			:Value present...set 2-byte
	LBR	RBC,RBC			:make sure value stripped
	EXBR	RBC,RBC			:and pack together
	OR	R4,RBC
	J	WMI			:and send message
	SUBTTL	RE-ENTRANT BUFFERLET PACKAGE

NBUF	EQ	3*NPORT			:Number of buffers

:	first NPORT buffers		 To-terminal buffers
:	Next NPORT buffers		 From-terminal buffers
:	Next NPORT buffers		 LOGON buffers

	GLOBAL(BBFLSZ,10)		:size (bytes) of bufferlet
	GLOBAL(NBBFLT,10*NPORT)		:Allocate 10 bufferlets/port
	GLOBAL(RHIST,0)			:Keep bufferlet history if 1
	GLOBAL(BUGGER,0)		:debugging mode if 1

	MO	.,BUFFER


	LO	DATA

:	This package contains all code and storage allocation needed for
:	transfer of bytes and control messages between a foreground job
:	and background job.
:	This is the two level re-entrant version (all routines can be called
:	by both foreground and background).


:	the following parameters MUST be defined before assembly:
:	NBBFLT	the number of big bufferlets to create.

:	the following parameters are defined for the user:

:	CRASH	JAL R10,CRASH performed if catestrophic conditions occur.


:	The package contains both utility and primitive routines:
:	IZBB	-Initialize Big Bufferlets



:	BUFFERLET AREA
	SEG	A.BUFF			:Allocate in buffer area
	BND	10			:Force to multiple of 16d
	HS	1			:force bufferlets start at BND 4  +2
BBUFER	BS	NBBFLT*BBFLSZ		:Bufferlet area size

:	DATA AREA
	SEG	A.DATA
BB	WS	NBUF			:Buffer Begin
BE	WS	NBUF			:Buffer end
BF	WS	NBUF			:Buffer Flag
BCT	EQ	BF+2			:Buffer Count...BF and BCT are interleaved
SBB	WS	NBUF			:SCAN buffer begin
NAVAL	EQ	(NBBFLT+1F)/20*4	:number of bytes required for all bufferlets
AVAL	WS	NAVAL/4			:bit array to designate available bufferlets
BUFCNT	HS	1			:keep track of buffer usage
BPOINT	HS	1			:bit-available pointer
DATA	HS	(NBUF+1)/2		:bit set for buffer empty

	 IF	BUGGER
BUG1	HS	(NBUF+1)/2		:BIT SET FOR BUFFER EMPTY
BUG2	HS	(NBUF+1)/2		:BIT SET FOR BUFFER EMPTY
BUG3	HS	(NBUF+1)/2		:BIT SET FOR BUFFER EMPTY
BUG4	HS	(NBUF+1)/2		:BIT SET FOR BUFFER EMPTY
BUG5	HS	(NBUF+1)/2		:BIT SET FOR BUFFER EMPTY
BUG6	HS	(NBUF+1)/2
	 EI	:BUGGER

	 IF	RHIST
:	History buffer:
:	HISX -	HW cursor for next entry (relative to HISD)
:	entry -	BC	Character,
:		BC	buffer number (RBP/4)
:		HC	low-order 16-bits of RBF (caller address)
HSIZ	EQ	400
HISX	HS	1
HISD	HS	HSIZ/2

	SEG	A.CODE
:	Keep history
:	R0 -	Link
:	R1 -	time for next activation
:	R1 -	Character
:	R2 -	Buffer-pointer
:	R3 -	Scratch
HISTY	LHL	R3,HISX			:get history index
	STB	RBC,HISD,R3		:save char
	SRLS	RBP,2			:convert to buffer no.
	STB	RBP,HISD+1,R3		:and save it
	SLLS	RBP,2			:back to buffer index
	STH	RCH,HISD+2,R3		:save caller
	AIS	R3,4			:advance cursor and save
	NHI	R3,HSIZ-1
	STH	R3,HISX
	JR	R0
	 ELSE	:RHIST
	SEG	A.CODE
	 EI	:RHIST

:	Write Character
:	R0 -	Scratch
:	R1 -	Character
:	R2 -	Buffer-pointer
:	R3-R5 -	Scratch
:	R8 -	Link
WCI	IF	RHIST;	JAL	R0,HISTY;	EI
WCI1	HC	3900!(RBC^4)!RBP	:WCI RBC,RBP
	HC	BE-BB			:size of BB storage
	HC	WCIERR-WCI1		:invalid-buffer-number exit
	HC	BE/4			:address of BE storage
	HC	WCNXT-WCI1		:Here to chain in another bufferlet
	HC	WCFST-WCI1		:Here to get first bufferlet
	MINH(R0,BCT,RBP)		:normal exit...Buffer count
	JGR	RBF			:This is usual exit
	JL	WCIERR			:abort on error (Shouldn't happen)
	LHL	R0,BF,RBP		:get the BF location
	CBT	R0,FLAGS		:replace TOPORT (probably off)
	JR	RBF			:Done

:	First exit
WCFST	LH	R3,BCT,RBP		:Check out BCT
	JLFS	WCFST1			:Skip ahead for normal condition
	LIS	R3,0
	RBT	R3,BE,RBP		:just restore BE
	J	WCI1			:and restart

WCFST1	LH	R3,BPOINT		:get current pointer
WCFST2	L	R4,AVAL,R3		:get bit word
	JFFO	R4,WCFST4		:find next one
	SIS	R3,4
	JGEFS	WCFST3
	LHI	R3,NAVAL-4
WCFST3	STH	R3,BPOINT
	JBS	WCFST2
WCFST4	RBT	R5,AVAL,R3		:mark "taken"
	JEBS	WCFST2			:too late
	MINH(R4,BUFCNT)			:keep count of buffers
	SLLS	R3,3			:include offset
	AR	R3,R5			:particular buffer index
	SLLS	R3,4			:full buffer index
	AI	R3,BBUFER		:make absolute
	STB	RBC,0,R3		:and the character
	L	R4,BB,RBP
	ST	R3,BB,RBP		:BB must be stored first
	ST	R3,BE,RBP		:store pointer
	MINH(R0,BCT,RBP)		:set up BCT
	LHL	R0,BF,RBP		:get BF location
	RBT	R0,FLAGS		:test flag array
	JNR	RBF			:re-entrant, GET will clean-up
	RBT	RBP,DATA
	JNFS	WCFST5			:buffer empty...just set flag
	SI	R4,BBUFER		:make ASN index
	SRLS	R4,4
	SBT	R4,AVAL			:mark available
	MDCH(R4,BUFCNT)			:keep track of bufferlets
WCFST5	SBT	R0,FLAGS
	JR	RBF

:	Next exit
WCNXT	LIS	R0,0			:get a null
	SBT	R0,BE,RBP		:lock up BE
	JN	WCFST			:If set then exception condition
	LH	R3,BPOINT		:get current pointer
WCNXT1	L	R4,AVAL,R3		:get bit word
	JFFO	R4,WCNXT3		:find next one
	SIS	R3,4
	JGEFS	WCNXT2
	LHI	R3,NAVAL-4
WCNXT2	STH	R3,BPOINT
	JBS	WCNXT1
WCNXT3	RBT	R5,AVAL,R3		:mark "taken"
	JEBS	WCNXT1			:too late
	MINH(R0,BUFCNT)			:keep track
	SLLS	R3,3			:include offset
	AR	R3,R5			:particular buffer index
	SLLS	R3,4			:full buffer index
	L	R4,BE,RBP		:get current BE
	STH	R3,1,R4			:set link
	AI	R3,BBUFER		:make absolute
	STB	RBC,0,R3		:store character
	ST	R3,BE,RBP		:set BE
	MINH(R0,BCT,RBP)		:increment BCT
	JGR	RBF			:Normal exit
	JL	WCIERR			:Abort on error (Shouldn't happen)
	LHL	R0,BF,RBP		:get BF location
	C	R3,BB,RBP		:has GET made the link?
	JNFS	WCNXT4			:no
	CBT	R0,FLAGS
	JR	RBF
WCNXT4	ST	R3,BB,RBP		:set up BB
	CBT	R0,FLAGS		:flip flag pointer
	JNR	RBF			:let other return it
	SI	R4,BBUFER		:make an index
	SRLS	R4,4
	SBT	R4,AVAL			:mark available
	MDCH(R0,BUFCNT)			:keep track
	JR	RBF			:Done

:	Special entry for second of control set
GMI	LHL	R0,BF,RBP		:locate flag
	SBT	R0,FLAGS		:this insures proper flag

:	GCI - Get Character
:	R1 -	Char
:	R2 -	Bufer pointer
:	R0,R3,R4	Scratch
:	R8 -	Link
GCI	IF	RHIST
	L	R3,BB,RBP		:get the character
	LB	RBC,0,R3
	JAL	R0,HISTY
	 EI	:RHIST
GCI1	HC	3800!(RBC^4)!RBP	: GCI RBC,RBP (leaves BB in R3)
	HC	BE-BB			:size of BB storage
	HC	GCIERR-GCI1		:here on invalid buffer or empty
	HC	BB/4			:address of BB storage
	HC	GCNXT-GCI1		:here to return empty bufferlet
	HC	GCLST-GCI1		:here for last buffer
	 IF	BUGGER			:normal exit
	RBT	RBP,BUG1
	RBT	RBP,BUG2
	RBT	RBP,BUG3
	RBT	RBP,BUG4
	RBT	RBP,BUG5
	RBT	RBP,BUG6
	 EI	:BUGGER
	MDCH(R0,BCT,RBP)		:one less
	JGER	RBF			:Normal exit
	LHL	R0,BF,RBP		:get BF location
	CBT	R0,FLAGS		:restore BF (WCI probably will set it)
	JR	RBF

:	Last exit
GCLST	IF	BUGGER
	SBT	RBP,BUG5
	 EI	:BUGGER
	MDCH(R0,BCT,RBP)		:Count character gone
	JGE	GCLST3			:Skip ahead for exception
	 IF	BUGGER
	SBT	RBP,BUG1
	 EI	:BUGGER
	LIS	R0,0			:null
	SBT	R0,BE,RBP		:set last marker
	JN	GCLST2			:skip ahead, write doing next
	 IF	BUGGER
	SBT	RBP,BUG2
	 EI	:BUGGER
	LHR	R0,R3			:get right half
	CLH	R0,BE+2,RBP		:has last been continued?
	JN	GCLST1			:yes...exception, skip
	 IF	BUGGER
	SBT	RBP,BUG3
	 EI	:BUGGER
	SBT	RBP,DATA		:set this, WCFIRST won't return last
	SI	R3,BBUFER		:make an index
	SRLS	R3,4
	SBT	R3,AVAL			:mark "available"
	MDCH(R0,BUFCNT)			:count another bufferlet not in use
	LHL	R0,BF,RBP
	CBT	R0,FLAGS
	JNR	RBF			:WCFIRST not here...exit
	RBT	RBP,DATA		:WCFIRST added in
	JR	RBF
GCLST1	CLH	R0,BB+2,RBP		:else there is a new bufferlet
	JNFS	GCLST2			:yes, try to return old one
	AIS	R3,1			:else bump this...
	THI	R3,0F			:..this bufferlet continued
	JEFS	GCLST2			:...try to return it if next
	ST	R3,BB,RBP		:leave BB updated
	LHL	R0,BF,RBP
	CBT	R0,FLAGS
	JR	RBF
:	Under certain conditions, the two processes race to see which
:		returns the previous bufferlet
:	The second one through returns, this is determined
:		by the state of the flag
GCLST2	LHL	R0,BF,RBP		:locate flag
	CBT	R0,FLAGS		:flip it
	JNR	RBF			:other side not here yet
	SI	R3,BBUFER		:other side has gone by
	SRLS	R3,4			:...thus this side must return
	SBT	R3,AVAL			:release bufferlet
	MDCH(R0,BUFCNT)			:Count another bufferlet not in use
	JR	RBF
GCLST3	AIS	R3,1			:the count was greater than -1
	THI	R3,0F			:...because the other is linking
	JN	GCLST4			:...thus this process
	LHL	R0,0,R3			:...must perform micro functions
	AI	R0,BBUFER
	ST	R0,BB,RBP
	SI	R3,BBUFER
	SRLS	R3,4
	SBT	R3,AVAL			:mark "available"
	MDCH(R0,BUFCNT)			:Count another bufferlet not in use
	JR	RBF			:Done
GCLST4	ST	R3,BB,RBP		:BB needs updating
	JR	RBF

:	Next exit
GCNXT	LHL	R0,0,R3			:get link
	AI	R0,BBUFER		:make it absolute
	ST	R0,BB,RBP		:and set BB
	SI	R3,BBUFER		:make an index
	SRLS	R3,4
	SBT	R3,AVAL			:mark "available"
	MDCH(R0,BUFCNT)			:Set another bufferlet not in use
	 IF	BUGGER
	SBT	RBP,BUG4
	 EI	:BUGGER
	AHM	R0,BCT,RBP		:decrement count
	JGER	RBF
	 IF	BUGGER
	SBT	RBP,BUG6
	 EI	:BUGGER
	LHL	R0,BF,RBP		:locate flag
	CBT	R0,FLAGS
	JR	RBF

:	WMI	Write a control Message
:	R0-R1 -	Scratch
:	R2 -	Buffer pointer
:	R3 -	Scratch
:	R4 -	String to output (reversed)
:	R5 -	Count of characters
:	R8 -	Link
WMI	IF	RHIST
	LIS	RBC,0
	JAL	R0,HISTY		:record escape
	LR	RBC,R4			:copy string
	JAL	R0,HISTY
	CLHI	R5,1
	JLEFS	WMIX
	SRLS	RBC,8			:next char
	JAL	R0,HISTY
	CLHI	R5,2
	JLEFS	WMIX
	SRLS	RBC,8			:next char
	JAL	R0,HISTY
WMIX	 EI	:RHIST
	XHI	R5,-1			:Make Count Negative
	AIS	R5,1
	SLLS	R5,3			:Multiply by 8
	LIS	RBC,0			:precede with null
WMI1	HC	3900!(RBC^4)!RBP	:WCI RBC,RBP
	HC	BE-BB			:size of BB storage
	HC	WMERR-WMI1		:invalid buffer-number exit
	HC	BE/4			:address of BE storage
	HC	WMI1X-WMI1		:here to chain in another bufferlet
	HC	WMI10-WMI1		:here if WMI is first

:	Normal exit (for first-character)
WMI2	LA	R0,WMIEXI		:Note exit to take
WMI3	HC	3900!(R4^4)!RBP		:WCI R4,RBP
	HC	BE-BB			:size of BB storage
	HC	WMERR2-WMI3		:location on invalid buffer-number
	HC	BE/4			:address of BE storage
	HC	WMIXX-WMI3		:address to chain in next bufferlet
	HC	WMERR2-WMI3		:first is impossible

:	Subsequent byte normal exit
	SRLS	R4,8			:get next byte
	AIS	R5,9			:keep count
	JLBS	WMI3			:repeat as necesary
	JR	R0			:and enter exit-state

:	First (on first character)
WMI10	LH	R0,BCT,RBP		:get the count
	JLFS	WMI101			:skip-ahead is normal
	RBT	RBC,BE,RBP		:just start over (re-entrancy)
	J	WMI1
WMI101	LH	R3,BPOINT		:get current pointer
WMI102	L	R0,AVAL,R3		:get bit word
	JFFO	R0,WMI104		:find next one
	SIS	R3,4
	JGEFS	WMI103
	LHI	R3,NAVAL-4
WMI103	STH	R3,BPOINT
	JBS	WMI102
WMI104	RBT	R1,AVAL,R3		:mark "taken"
	JEBS	WMI102			:too late
	MINH(R0,BUFCNT)			:keep track of bufferlets in use
	SLLS	R3,3			:include offset
	AR	R3,R1			:particular buffer index
	SLLS	R3,4			:full buffer index
	AI	R3,BBUFER		:make absolute
	LIS	RBC,0			:place the 0
	STB	RBC,0,R3
	L	R1,BB,RBP		:save previous pointer
	ST	R3,BB,RBP
	ST	R3,BE,RBP		:and set BE
	LA	R0,WMIEX4		:set new exit-state
	J	WMI3			:and continue

:	Next (on first character)
WMI1X	SBT	RBC,BE,RBP		:check for first (RBC contains 0)
	JN	WMI10			:yes, let first handle
	LH	R3,BPOINT		:get current pointer
WMI1X1	L	R0,AVAL,R3		:get bit word
	JFFO	R0,WMI1X3		:find next one
	SIS	R3,4
	JGEFS	WMI1X2
	LHI	R3,NAVAL-4
WMI1X2	STH	R3,BPOINT
	JBS	WMI1X1
WMI1X3	RBT	R1,AVAL,R3		:mark bufferlet "taken"
	JEBS	WMI1X1			:too late
	MINH(R0,BUFCNT)			:count bufferlet in use
	SLLS	R3,3			:include offset
	AR	R3,R1			:particular bufferlet index
	SLLS	R3,4			:full bufferlet pointer
	L	R1,BE,RBP		:get cursor for last bufferlet
	STH	R3,1,R1
	AI	R3,BBUFER
	LIS	R0,0
	STB	R0,0,R3			:install the "0"
	ST	R3,BE,RBP		:set new BE
	LA	R0,WMIEX3		:set new exit-state
	J	WMI3			:and continue

:	Next character (for subsequent characters)
WMIXX	LH	R3,BPOINT		:get current pointer
WMIXX1	L	R0,AVAL,R3		:get bit word
	JFFO	R0,WMIXX3		:find next one
	SIS	R3,4
	JGEFS	WMIXX2
	LHI	R3,NAVAL-4
WMIXX2	STH	R3,BPOINT
	JBS	WMIXX1
WMIXX3	RBT	R1,AVAL,R3		:mark "taken"
	JEBS	WMIXX1			:too late
	MINH(R0,BUFCNT)			:keep track of bufferlets in use
	SLLS	R3,3			:include offset
	AR	R3,R1			:particular buffer index
	SLLS	R3,4			:full buffer index
	L	R1,BE,RBP		:get write pointer
	STH	R3,1,R1			:set link (no re-entrancy)
	AI	R3,BBUFER		:make absolute
	STB	R4,0,R3
	ST	R3,BE,RBP		:set end pointer
	SRLS	R4,8
	AIS	R5,9			:bump count
	JL	WMI2			:repeat if necessary

:	Exit point for requiring subsequent bufferlet on subsequent characters
WMIEXI	MINH(R0,BCT,RBP)		:update BCT
	JGFS	WMIEX2			:set another count
	JL	WMERR			:Abort on less (Shouldn't happen)
	AHM	R5,BCT,RBP		:rest of count
	LHL	R0,BF,RBP		:get flag location
WMIEX1	CBT	R0,FLAGS		:inverting (eventually comes out right)
	JR	RBF			:Done
WMIEX2	AHM	R5,BCT,RBP		:next count
	JR	RBF

:	exit point for next-bufferlet on 1st char
WMIEX3	MINH(R0,BCT,RBP)		:exit point for next
	JGBS	WMIEX2			:set another count
	JL	WMERR			:less shouldn't happen
	AHM	R5,BCT,RBP		:Set the count
	LHL	R0,BF,RBP		:Flag pointer
	C	R3,BB,RBP		:has GET made the link?
	JE	WMIEX1			:yes
	ST	R3,BB,RBP		:set up BB
	CBT	R0,FLAGS		:flag there
	JNR	RBF			:let other finish
	SI	R1,BBUFER		:else make into index
	SRLS	R1,4
	SBT	R1,AVAL			:mark available
	MDCH(R0,BUFCNT)			:keep track of bufferlets
	JR	RBF

:	Exit point for starting with empty buffer
WMIEX4	AIS	R5,1			:make a full count
	AHM	R5,BCT,RBP		:and set the count
	LHL	R0,BF,RBP		:get BF location
	RBT	R0,FLAGS		:test flag array
	JNR	RBF			:re-entrant, GET will clean-up
	RBT	RBP,DATA
	JNFS	WMIEX5			:buffer empty...just set flag
	SI	R1,BBUFER		:make ASN index
	SRLS	R1,4
	SBT	R1,AVAL			:mark available
	MDCH(R1,BUFCNT)			:keep track of bufferlets
WMIEX5	SBT	R0,FLAGS		:turn flag back on
	JR	RBF


:	Peek at buffer...link on RCH
:	normal return if not in use, empty, or not control signal
:	skip (4) return if leads with control-siganl
CPEEK	LHL	RBC,BF,RBP		:First get the flag
	JER	RCH			:null...return
	LH	RBC,BCT,RBP		:Check if empty
	JLR	RCH			:yes...return
	L	R3,BB,RBP		:get the character
	LB	RBC,0,R3
	JNR	RCH			:not control-signal
	AIS	R3,1
	THI	R3,0F			:check for buffer fold
	JNFS	CPEEK1			:skip if not
	LHL	R3,0,R3			:get link
	AI	R3,BBUFER		:make it absolute
CPEEK1	LB	RBC,0,R3		:else get the char
	JN	4,RCH			:Control...skip return
	JR	RCH			:data...normal return


:	EMPTY a buffer...link on RCH
EMPTY	LHL	RBC,BF,RBP		:First get the flag
	JER	RCH			:null...return
EMPTY1	LH	RBC,BCT,RBP		:Check if empty
	JLR	RCH			:yes...return
	SIS	RBC,$A 15		:check quantity left
	JLFS	EMPTY2			:skip if likely on last bufferlet
	LIS	RBC,BBFLSZ-1		:no..set mask
	NH	RBC,BB+2,RBP		:check if at beginning of bufferlet
	SIS	RBC,2
	JNFS	EMPTY2			:no...just take out another char
	LIS	RBC,$A 12		:yes...remove 12 characters
	AM	RBC,BB,RBP
	LCS	RBC,$A 12
	AHM	RBC,BCT,RBP		:...and reduce count of chars there
EMPTY2	JAL	RBF,GCI			:get another char
	J	EMPTY1


:	IGCSCN - Initialize scan through buffer
:	RCH -	Char returned (maybe)
:	RBP -	Pointer to buffer
:	RBF -	Link register
:	Normal return if buffer empty
IGCSCN	L	RBC,BB,RBP		:get pointer to beginning
	JER	RBF			:0 - empty...just normal exit
	SIS	RBC,1			:not empty...back up one place
	ST	RBC,SBB,RBP		:save updated cursor
	J	4,RBF			:skip return

:	GCSCN -	scan through buffer
:	RCH -	Char returned (maybe)
:	RBP -	Pointer to buffer
:	RBF -	Link register
:	Normal return if at end of buffer
:	Else skip (4) return, character in RBC
GCSCN	L	RBC,SBB,RBP		:get SCAN cursor
	C	RBC,BE,RBP		:check for end
	JER	RBF			:normal return if so
	AIS	RBF,4			:else set skip return
	AIS	RBC,1			:advance cursor
	THI	RBC,0F			:test if at end of bufferlet
	JNFS	GCSCN1			:no...just skip
	LHL	RBC,0,RBC		:yes...get link
	AI	RBC,BBUFER		:make it absolute
GCSCN1	ST	RBC,SBB,RBP		:save updated cursor
	LB	RBC,0,RBC		:get the character
	JR	RBF


WMERR2	ABORT(RBF,0)
WMERR	ABORT(RBF,0)
WCIERR	ABORT(RBF,0F0)
GCIERR	ABORT(RBF,0F1)
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			 S U B R O U T I N E   I Z B B				::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

IZBB	LIS	R4,0
	STB	R4,BUFCNT		:set no bufferlets in use
	LHI	R1,NAVAL-4
	STH	R1,BPOINT
	ST	R4,AVAL,R1		:Set last word to zero
	 IF	RHIST;	STH	R4,HISX;	 EI

:	Now set up the buffer parameters for all buffers
	LHI	R1,(NBUF-1)*4		:For each buffer:
IZBB1	TS	BCT,R1			:Set empty,
	ST	R4,BB,R1		:...and set pointers empty
	ST	R4,BE,R1
	SBT	R1,DATA
	SIS	R1,4			:For next buffer
	JGEBS	IZBB1			:...until done
	LHI	R1,NBBFLT-1
IZBB2	SBT	R1,AVAL
	SIS	R1,1
	JGEBS	IZBB2

:	Now set up the buffer flags for all buffers
	LIS	R1,0			:buffer index for To-terminal buffers
	LHI	R2,NPORT*4		:buffer index for From-terminal buffers
	LHI	R3,NPORT*8		:buffer index for LOGON buffers
	LHI	R4,-2*NPORT		:Loop control...do for each port (count up)
	LI	R5,BFA(TOPORT)
	LIS	R6,0			:From-port starts with 0 BF
	LI	R7,BFA(GOLOG)
IZBB3	STH	R5,BF,R1		:Init To-port buffer flags
	STH	R6,BF,R2		:Init From-port buffer flags
	STH	R7,BF,R3		:Init LOGON buffer flags
	LHL	R8,(2*NPORT)+.PTP.,R4	:get pointer to port table entry
	ST	R1,.TTBUF,R8		:Set To-terminal buffer pointer
	ST	R2,.FTBUF,R8		:Set From-terminal buffer pointer
	ST	R3,.LGBUF,R8		:Set LOGON buffer pointer
	AIS	R1,4			:advance to next port
	AIS	R2,4
	AIS	R3,4
	AIS	R5,1			:advance flags too
	AIS	R7,1
	AIS	R4,2			:next port
	JL	IZBB3			:...until all ports are done
	JR	R0			:Then exit
:	ROUTINE TO CHECK FOR BUFFER ZAPS
BZAP	LH	RP,BUFCNT
	CLHI	RP,$A NBBFLT*80/100
	JL	EXDISM
:	Must zap a buffer...search list for it
	LHI	RP,NPORT*2*4		:for all buffers...
	LIS	RBP,0			:Biggest buffer found index
	LIS	R0,0			:size of that buffer
BZAP1	SIS	RP,4			:next buffer
	JLFS	BZAP2
	CH	R0,BCT,RP		:Is this one bigger?
	JGBS	BZAP1			:no
	LR	RBP,RP			:yes...set new buffer
	LH	R0,BCT,RP		:...and new size
	JBS	BZAP1
BZAP2	JAL	RCH,EMPTY		:From-terminal buffer...empty it
	LO	SIGNAL
	LIS	R4,GOBSIG		:Put in a gobbler
	JAL	RCH,PUTSIG
	LHI	R4,BLBSIG		:...followed by a black-ball
	JAL	RCH,PUTSIG
	FO	SIGNAL
	J	BZAP			:repeat as necessary

	 EI	:1

	FO	DATA
	EM	:BUFFER
	SUBTTL	TIMEOUT PROCESSES

:	This package contains the timeout routines
:	The following parameters MUST be defined on entry:
:	N.TOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	four symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:	EXDISM	routines called by TIMOUT should exit to here
:	TSCHED	any code may call this to place an entry on timeout list:
:		link on R6...R7--R15 preserved
:		R0 = address to transfer to
:		R1 = when to call routine next
:		R2 = how often to call routine
:			(next time from each activiation)

	 MO	.,TIMOUT

	SEG	A.DATA			:place into data area

TORET	HS	2			:link for timeout processor

TLIST	HS	0			:timeout list
T.FREE	HS	1			:free-list pointer
T.ACT	HS	1			:active-list pointer
					:	active list entry:
T.NEXT	EQ	T.FREE			:	chain pointer
T.PER	EQ	T.ACT			:	period
T.ADDR	HS	2			:	word routine address
T.ACTT	HS	2			:	word time of next activiation
LSIZ	EQ	.-TLIST			:number of bytes in list entry
	HS	N.TOUT*LSIZ/2		:additional timeout list entries

	SEG	A.CODE

EXDISM	L	R0,TORET		:Timeout routines exit here
:	Call next time-out routine (if any) that has become due
TIMOUT	LHL	R5,T.ACT		:get active list pointer
	JER	R0			:exit if no active entries
	L	R1,FASTC,,		:get current clock time
	C	R1,T.ACTT,R5		:is 1st active-list timeout due?
	JLR	R0			:no timeouts due to proceed
	ST	R0,TORET		:routine must terminate by jumping to
					:	EXDISM
	LHL	R3,T.NEXT,R5
	STH	R3,T.ACT		:shorten active list
	L	R0,T.ADDR,R5		:fetch routine address
	AH	R1,T.PER,R5		:period...when to call again
	JAL	R6,QTOLNK		:put back onto list
	JR	R0			:enter timed-out routine

:	Put entry into timeout list
:	R0 -	address
:	R1 -	new time
:	R2 -	interval
:	R6 -	Link.
TSCHED	LHL	R5,T.FREE		:get free-list entry
	JGFS	QTPT1
	JAL	R10,CRASH,,		:free-list exhausted
	BC	0,0,4*R6,0F		:flag--link R6, type 15d crash
QTPT1	LHL	R4,T.NEXT,R5
	STH	R4,T.FREE		:shorten free list
	STH	R2,T.PER,R5
	ST	R0,T.ADDR,R5

:	Link entry into timeout list
:	R0 -	preserved
:	R1 -	time to run new entry
:	R5 -	pointer to entry
QTOLNK	ST	R1,T.ACTT,R5		:plug in new time to run
	LIS	R3,2			:find active list entry between
					:	earlier, later timeout.
QTLK1	LR	R4,R3
	LHL	R3,T.NEXT,R3		:check next timeout entry
	JEFS	QTLK2			:active list is empty
	C	R1,T.ACTT,R3		:is it earlier than argument due-time
	JGBS	QTLK1			:yes, continue 'til R4 is earlier and
					:	R3 is equal or later
QTLK2	STH	R5,T.NEXT,R4		:make earlier active-list entry point
					:	to new entry
	STH	R3,T.NEXT,R5		:have new entry point to next greater
					:	timeout entry
	JR	R6			:store arguments and return

:	Initialize timeout data
:	R0 -	link register
IZT	LHI	R1,N.TOUT*LSIZ		:initialize timeout free-list
	LIS	R2,0			:0 terminates list
	STH	R2,T.ACT		:active list is empty
	STH	R2,T.NEXT,R1		:terminate free-list
IZT1	STH	R1,T.FREE-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	IZT1
	JR	R0
	 EM	:TIMOUT
	SUBTTL	ISIS RING I/O...MESSAGE DEFINITIONS
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			I S I S   I N T E R F A C E			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	MO	.,ISIS

	LO	DATA

:	Interface message types - ISIS-II
NEDMSG	EQ	0			:NEEDLE
FIRST	EQ	9E			:FIRST MESSAGE IN LIST
DETMSG	EQ	9E			:DETACH MESSAGE
ZAPMSG	EQ	9F			:DISCONNECT MESSAGE
NOSMSG	EQ	0A0			:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1			:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2			:FLUSH OUTPUT
BKGMSG	EQ	0A3			:FLUSH INPUT
BLKMSG	EQ	0A4			:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5			:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6			:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7			:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8			:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9			:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA			:GREEN BALL
RBMSG	EQ	0AB			:RED BALL
YBMSG	EQ	0AC			:YELLOW BALL
OBMSG	EQ	0AD			:ORANGE BALL
BRKMSG	EQ	0AE			:BREAK DETECTED
HNGMSG	EQ	0AF			:HANG UP
QTPMSG	EQ	0B0			:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1			:SET TERMINAL PARAMETER
PNDMSG	EQ	0B2			:PSEUDO NEEDLE
NLOGCH	EQ	0B3			:NORMAL LOGON CHAR
NLOGST	EQ	0B4			:NORMAL LOGON STATUS
LOGFAL	EQ	0B5			:LOGON FAILURE
LOGOK	EQ	0B6			:SUCCESSFUL LOGON
ADAMSG	EQ	0B7			:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8			:SUPER-HANG UP
TLMMSG	EQ	0B9			:SET TRANSMIT LIMIT
BNDMSG	EQ	0BA			:BREAK-END
ZAKMSG	EQ	0BB			:ZAP ACKNOWLEDGE
EADMSG	EQ	0BC			:ENTER ALTERNATE OUTPUT DEVICE MODE
LADMSG	EQ	0BD			:LEAVE ALTERNATE OUTPUT DEVICE MODE
ZWRMSG	EQ	0BE			:ZAP W/REASON
SIXMSG	EQ	0BF			:SIIX COMMAND
TIXMSG	EQ	0C0			:TIIX COMMAND
MAXTYP	EQ	TIXMSG			:MAXIMUM TYPE DEFINED

:	Special (port 0) message types
INDNON	EQ	9			:Unable to provide pseudo-needle
INDREM	EQ	0E			:1-down remote

:	Back-Pressure constants
BPONLM	HC	$A 150
BPOFLM	HC	$A 100
	SUBTTL	SPECIAL ISIS FUNCTIONS

:	Routine to establish a port, used upon circuit zapped or TID
:	RLINK -	link register
:	RP -	port number
:	RP2 -	2*port number
:	RPI -	port-table pointer
ESTPRT	SBT	RP,SENDON		:release back-pressure
	LIS	R0,0B			:11d byte message
	LIS	R1,0			:...to ISIS port 0
	LIS	R2,7			:--Request Normal Needle
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LIS	R0,0
	JAL	R4,PUTCH		:pad
	LB	R0,SEQKEY,RP		:Get sequence number of port for key
	AIS	R0,1
	STB	R0,SEQKEY,RP
	EXBR	R0,R0			:Key R0 is /SEQ|PHY PORT/
	STBR	RP,R0
	JAL	R4,PUTH
	LIS	R0,0			:not IIX
	JAL	R4,PUTH
	LHL	R0,ACHOST,RP2
	JAL	R4,PUTH			:Output Origination Host
	LH	R5,.TERMT,RPI		:Get terminal type-pointer
	LB	R0,VID.ID,R5,		:Now get TID
	JAL	R4,PUTCH
	JAL	R4,ELOR			:End-Logical-Output-Record
	JR	RLINK



:	Disconnect circuit routine
:	RLINK -	link register
CIRDIS	L	RBP,.FTBUF,RPI		:get from-terminal buffer-pointer
	JAL	RCH,EMPTY		:empty it
	LIS	R1,0
	JAL	R3,CHNGBF		:disconnect buffer from processes
	RBT	RP,LOGGER		:Disable LOGIN output processor
	RBT	RP,LOGING		:set LOGGER inactive

:	Alternate entry, disconnect port from ISIS, but doesn't diddle port itself
CIRDSC	LH	R1,PMAPAI,RP2		:Get ISIS port number
	JLR	RLINK
	LIS	R0,3			:Send ZAPPER to ISIS
	LHI	R2,ZAPMSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	TS	PMAPIA,R1,R1
	TS	PMAPAI,RP2		:Kill mapping entries
	MDCH(R4,IPORTS)			:Decrement ISIS port-count
	RBT	RP,BKPRSR		:Reset input-backpressure to ISIS
	SBT	RP,SENDON		:Reset backpressure from ISIS
	JR	RLINK			:and return



:	Pass a LOGON character to ISIS
:	R9 -	Character
:	RP -	Port number
:	RP2 -	2*Port number
:	RLINK -	Link register
LOGCH	LIS	R0,4			:4 Character ISIS-message
	LH	R1,PMAPAI,RP2		:ISIS port number
	LHI	R2,NLOGCH		:New LOGON Character
	JAL	R4,SLOR			:Start Logical Output Record
	LR	R0,R9			:Character input
	OHI	R0,80
	JAL	R4,PUTCH
	JAL	R4,ELOR			:End Logical Output Record
	JR	RLINK

	 IF	NMPVC
	SUBTTL	Multiplexed PVC -- Accounting processes

	GL	M.ACCT,M.SACT		:definitions

:	RP -	MPVC port number
:	RP2 -	2*MPVC port number
:	RPOL -	Polling index
:	RLINK -	MPVC port format-table pointer
:	R9 -	MPVC port variable-block pointer


:		MPVC ACCounTing processes
:		==== ========== =========
:	On time-out list, runs every 17 minutes
M.ACCT	LHI	RP,.MPORT		:for all MPVC ports...
M.ACT1	TBT	RP,RLA			:is this port active?
	JNFS	M.ACT3			:yes...service it
M.ACT2	AIS	RP,1			:done...next MPVC port
	CLHI	RP,.MPORT+NMPVC
	JLBS	M.ACT1
	J	EXDISM			:done...exit

:	active MPVC port...service it
M.ACT3	LR	RP2,RP
	AR	RP2,RP2
	L	RLINK,MPVCFO-(4*.MPORT),RP2,RP2 :set format-table pointer
	LHL	R9,MP.VAR,RLINK		:set variable-area pointer
	JAL	R5,M.SACT		:send accounting
	J	M.ACT2			:and quit


:	Send MPVC accounting
:	R5 -	Link Register
:	R9 -	MPVC accounting data
:	RP2 -	2*MPVC port number
M.SACT	LIS	R0,8			:8-byte message
	LH	R1,PMAPAI,RP2		:for port...
	JLR	R5			:abort if port not connected
	LHI	R2,ADAMSG		:...addendum to accounting
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LIS	R0,0			:pad
	JAL	R4,PUTCH
	L	R0,MPV.LP,R9		:Logon-ports
	OI	R0,0E0160000
	JAL	R4,PUTW
	JAL	R4,ELOR			:End-Logical-Output-Record
	LIS	R0,8			:8-byte message
	LHL	R1,PMAPAI,RP2		:for port...
	LHI	R2,ADAMSG		:...addendum to accounting
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LIS	R0,0			:pad
	JAL	R4,PUTCH
	L	R0,MPV.PS,R9		:port seconds
	LHI	R1,$A 60		:convert to port minutes
	DHR	R0,R1
	LI	R0,0E0170000,R1
	JAL	R4,PUTW
	JAL	R4,ELOR			:End-Logical-Output-Record
	JR	R5			:and exit

	 EI	:NMPVC
	SUBTTL	ISIS PERIODIC STUFF

:	ISIS Half-second processing
:	==== ===========
:	Check all buffers for backpressure applied,
:		release where possible.
IHSEC	LHI	RPOL,(NGRP-2)*2		:word index...
IHSEC1	L	R0,BKPRSR,RPOL		:backpressure applied
	ST	R0,P.DONE		:candidates examined
IHSEC2	L	R0,P.DONE		:backpreassured and not serviced
	JFFO	R0,IHSEC3		:find it
	SIS	RPOL,4			:else proceed to next group
	JGEBS	IHSEC1
	J	EXDISM

IHSEC3	RBT	R1,P.DONE		:mark port as serviced
	LR	RP,RPOL
	SLLS	RP,3
	AR	RP,R1			:Compute port-number
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP2		:get pointer to table entry
	L	RBP,.TTBUF,RPI		:To-terminal buffer-pointer
	LH	R0,BCT,RBP		:contents of incoming buffer
	SH	R0,BPOFLM
	JG	IHSEC2			:not yet
	RBT	RP,BKPRSR
	LIS	R0,3			:3-byte message
	LH	R1,PMAPAI,RP2		:look up ISIS port #
	LHI	R2,SNDMSG		:release backpressure
	JAL	R4,SLOR			:Start-Logical-Output-Record
	JAL	R4,ELOR			:End-Logical-Output-Record
	J	IHSEC2			:and proceed


:	20 SECOND LOGIC
:	---------------
:	Check for DDT user requesting to ZAP an ISIS port
SEC20	LHL	R1,ZAPIT
	JE	EXDISM
	LIS	R0,3
	LHI	R2,ZAPMSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	LIS	R0,0
	STH	R0,ZAPIT
	J	EXDISM			:Quit
	SUBTTL	ISIS RING I/O...INPUT INTERFACE
:	INPUT from ISIS
:	===== ==== ====

INPUT	ST	R0,RET4			:Save return
INPUT1	JAL	R4,LOOK,,		:is there anything in ring?
	J	RET			:normal return...just exit
	JE	INSPEC			:jump to service special message
	LR	R10,R1			:copy ISIS port
	LH	RP,PMAPIA,R10,R10	:look up internal port number
	JGE	INPUT2			:skip...active port
	CLHI	R2,PNDMSG		:Pseudo-needle ?
	JE	NPNEED			:yes...service new circuit
	LR	R2,R2			:check for needle
	JE	NEEDLE			:yes...service needle
	JAL	R4,GETCH		:eat message type-byte

:	toss a message
TOSS	LR	R2,R0			:copy message type to index register
	LB	R0,LENGTH,R2,		:pick up message length
	SIS	R0,1			:already read type byte
	JAL	R4,FLUSH		:delete remainder of message
	J	INPUT1

INPUT2	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP2		:set pointer to port-table
	L	RBP,.TTBUF,RPI		:get to-terminal buffer-pointer
	JAL	R4,GETCH		:fetch and examine type
	CLHI	R0,FIRST		:is it data?
	JGE	INPUT7			:no...go process control information

	LR	R9,R0			:yes...save count of chars

INPUT3	JAL	R4,GETCH		:get next datum
	LR	RBC,R0			:copy it
	JAL	RCH,PUTCHR		:put it into the buffer
	SIS	R9,1
	JGBS	INPUT3			:repeat for all data characters
	JAL	R4,ELIR			:End-Logical-Input-Record

:	Check BACKPRESSURE limit to ISIS
	LHL	R0,BCT,RBP		:check buffer character count
	SH	R0,BPONLM
	JLE	INPUT1			:jump...backpressure-limit not exceeded
	SBT	RP,BKPRSR		:Check if we've applied backpressure
	JN	INPUT1			:jump...already applied
	LHI	R2,NOSMSG		:back-pressure-ISIS message

:	Send a 3-byte message to ISIS
INPUT4	LIS	R0,3			:set message size
	LR	R1,R10
	JAL	R4,SLOR			:Start-Logical-Output-Record
	JAL	R4,ELOR			:End-Logical-OUTPUT Record
	J	INPUT1			:and continue

:	Table of direct translations from ISIS to SIGNALS
:		(ordered in ISIS order, offset by FIRST)
	LO	SIGNAL
ISIS.S	BC	0,0			:9E,9F
	BC	0,0,0,0			:A0-A3
	BC	BLBSIG,0,EDMSIG,LDMSIG	:A4-A7
	BC	ETMSIG,LTMSIG,GBSIG,RBSIG :A8-AB
	BC	YBSIG,OBSIG,BBSIG,HNGSIG :AC-AF
	BC	0,0,0,0			:B0-B3
	BC	0,0,0,0			:B4-B7
	BC	SHGSIG,0,BESIG,0	:B8-BB
	BC	EADSIG,LADSIG,0,0	:BC-BF
	BC	0,0,0,0			:C0-C3
	BC	0,0,0,0			:C4-C7
	FO	SIGNAL

:	BIT array to identify messages to be passed directly to filters
BSPEC	HC	0,0			:00 - 00
	HC	0,0			:20
	HC	0,0			:40
	HC	0,0			:60
	HC	0,0			:80
	HC	$2 0000101111111001	:A0 - A4, A6-AC, AF
	HC	$2 0000000010001100	:B0 - B8, BC-BD
	HC	0,0			:C0
	HC	0,0			:E0

:	Control Information
INPUT7	TBT	R0,BSPEC		:can it be translated and passed directly?
	JE	ISSMSG			:no...go do special processing
	LR	R4,R0			:no, just translation...copy type
	LB	R4,ISIS.S-FIRST,R4	:translate it
	JE	CRASH,,			:unrecognized...crash
	JAL	RCH,PUTSIG		:Send signal on

:	Done...Terminate Record
INPUT9	JAL	R4,ELIR			:End-Logical-Input-Record
	J	INPUT1			:then go back for another record



:	Apply Backpressure
NOSEND	RBT	RP,SENDON		:do it
	JBS	INPUT9			:...and go close record

:	Release backpressure
RESEND	SBT	RP,SENDON		:turn on for port
	JBS	INPUT9			:...and go close record



:	Not data...process it

ISSMSG	LHI	R4,ISMSZ		:set index for table
ISMS1	CLB	R0,IFAN,R4		:check for match
	JNFS	ISMS2			:skip if not
	L	R4,IFAN,R4		:yes...get the address
	JR	R4			:...and go do it
ISMS2	SIS	R4,4			:else go to next entry
	JGEBS	ISMS1			:...until done
	J	TOSS			:can't find it, so toss it

:	Input fanout for special port-message processing -- ISIS-II
:		Fan out with:
:	RP -	Filter/port index
:	R10 -	ISIS port
:	RBP -	to-terminal buffer-pointer
:	RPI -	pointer to this port-table
IFAN	BA(NEDMSG,IFANCR)		:00 - Needle...crash if we get one
	BA(DETMSG,INPZAP)		:9E - ZAPPER
	BA(ZAPMSG,INPZAP)		:9F - DISCONECT
	BA(NOSMSG,NOSEND)		:A0 - APPLY BACKPRESSURE
	BA(SNDMSG,RESEND)		:A1 - RELEASE BACKPRESSURE
	BA(GOBMSG,GOBBLE)		:A2 - FLUSH OUTPUT
	BA(BKGMSG,RGOBBL)		:A3 - FLUSH INPUT
	BA(QTPMSG,QTP)			:B0 - QUERY TERMINAL PARAMETER
	BA(STPMSG,STP)			:B1 - SET TERMINAL PARAMETER
	BA(NLOGST,L.STAT)		:B4 - NORMAL LOGON STATUS
	BA(LOGFAL,TOSS)			:B5 - LOGON FAILURE
	BA(LOGOK,CIROK)			:B6 - SUCCESSFUL LOGON
	BA(TLMMSG,STXLIM)		:B9 - TRANSMIT LIMIT
ISMSZ	EQ	.-IFAN-4


:	Illegal port-control message decoded by IFAN
IFANCR	ABORT(R4,C.INDM)
NEEDLE	EQ	IFANCR


:	ISIS port zapped!  Clear mapping immediately so ISIS can
:	reuse the port number with safety.
INPZAP	JAL	R4,ELIR			:close input record
	TS	PMAPIA,R10,R10		:CLEAR ISIS-->filter
	JAL	RCH,EMPTY		:empty to-port buffer
	LO	SIGNAL
	LHI	R4,ZAPSIG		:send on Zapper
	FO	SIGNAL
	JAL	RCH,PUTSIG		:send on to filter
	L	RBP,.FTBUF,RPI		:empty from-port buffer
	JAL	RCH,EMPTY
	J	INPUT1			:then go on to next record


:	Set Terminal Parameter
STP	JAL	R4,GETCH		:which parameter
	LR	R6,R0			:copy parameter number
	JAL	R4,GETCH		:get value
	LR	RBC,R0
	LB	R4,P.SIG,R6		:look up signal number
	JE	INPUT9			:abort if null
	JAL	RCH,PUTSIG		:else send the signal
	J	INPUT9			:and close record


:	Query Terminal Parameter
QTP	JAL	R4,GETCH		:which parameter?
	LR	R6,R0			:copy parameter number
	LB	R4,P.SIG,R6		:look up signal number
	JE	INPUT9			:abort if null
	AIS	R4,1			:Query N = set N + 1
	JAL	RCH,PUTSIG		:else send the signal
	J	INPUT9			:and close record

	LO	SIGNAL

:	Table of expansions of Query and Set terminal parameters
:	(Makes use of fact that Query-signals = Set-signals + 1)
P.SIG	BC	SECSIG,SCISIG,SLCSIG,SCLSIG,SCRSIG,SIRSIG	:0-5
	BC	SORSIG,SPRSIG,SHDSIG,SPASIG,SPBSIG,SPCSIG	:6-B
	BC	SXESIG,SCHSIG,SRXSIG,SPDSIG,SKKSIG,STBSIG	:C-11
	BC	SEXSIG,SQMSIG,0,0,0,0				:11-17

	FO	SIGNAL


:	GOBBLER
GOBBLE	JAL	RCH,EMPTY		:empty to-terminal buffer
	LO	SIGNAL
	LIS	R4,GOBSIG
	FO	SIGNAL
	JAL	RCH,PUTSIG		:send it
	RBT	RP,BKPRSR		:check if we've applied backpressure
	JE	INPUT9			:continue if not
	LHI	R2,SNDMSG		:else release back-pressure from ISIS

:	Close input record and return new message
GOB200	JAL	R4,ELIR			:close input record
	J	INPUT4

:	Reverse Gobbler
RGOBBL	L	RBP,.FTBUF,RPI		:locate buffer
	JAL	RCH,EMPTY		:empty buffer
	J	INPUT9			:and close record

:	NEW PSEUDO-NEEDLE
NPNEED	JAL	R4,GETH			:skip Type|ISIS-key
	JAL	R4,GETH			:get internal key
	LHI	R2,ZAPMSG		:prepare to zap if not current sequence
	LBR	RP,R0			:save physical-port portion
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	SRLS	R0,8			:isolate sequence number
	CLB	R0,SEQKEY,RP		:is Pseudo-needle good?
	JN	GOB200
	TBT	RP,RLA			:is port still active?
	JE	GOB200			:go zap if not
	MINH(R0,IPORTS)			:update front-panel display
	STH	RP,PMAPIA,R10,R10	:set up maps
	STH	R10,PMAPAI,RP2
	LHL	RPI,.PTP.,RP2		:set port-table
	L	RBP,.FTBUF,RPI		:from-port buffer-pointer
	LI	R1,BFA(TOLOG),RP	:connect port to logger
	JAL	R3,CHNGBF
	JAL	RLINK,CIRBLT		:inform CONSAT to proceed
	JFS	STXLM1			:skip to init. transmit-limit to max

:	Set transmit-limit
STXLIM	JAL	R4,GETCH		:get limit in R0
	LR	R0,R0			:first test
	JLEFS	STXLM1			:can't set to 0
	CLHI	R0,FIRST-1		:range check
	JLFS	STXLM2
STXLM1	LHI	R0,FIRST-1		:use MIN(given, FIRST-1)
STXLM2	STB	R0,XLIMIT,RP		:and set limit
	J	INPUT9			:go close input record


:	LOGON Status
L.STAT	JAL	R4,GETCH		:get the status
	LR	R9,R0
	JAL	R4,ELIR			:End-Logical-Input-Record
.LSTA1	JAL	RLINK,LSTAT		:go process it
	J	INPUT1			:Done - go get another message

:	SUCCESSFUL NEW LOGON
CIROK	LIS	R0,7			:eat rest of message
	JAL	R4,FLUSH
	LIS	R0,8			:return message...8 bytes long,
	LR	R1,R10			:...origination port,
	LHI	R2,ADAMSG		:...addendum to accounting
	JAL	R4,SLOR
	LIS	R0,0
	JAL	R4,PUTCH		:pad
	LHL	R0,ASNPUT,RP2		:Physical unit adjust factor
	OI	R0,0E0090000		:/TYPE/MESSAGE/SUB-MESSAGE/PORT
	JAL	R4,PUTW
	JAL	R4,ELOR
	LIS	R0,8			:report accounting code...8 bytes long,
	LR	R1,R10			:...origination port,
	LHI	R2,ADAMSG		:...addendum to accounting
	JAL	R4,SLOR
	LIS	R0,0
	JAL	R4,PUTCH		:pad
	LHL	R0,ACPORT,RP,RP		:accounting code
	OI	R0,0E0130000		:/TYPE/MESSAGE/SUB-MESSAGE 19d/CODE
	JAL	R4,PUTW
	JAL	R4,ELOR
	SBT	RP,SENDON		:Release backpressure
	RBT	RP,LOGING		:no longer a logger
	RBT	RP,NEWLOG		:...and certainly no longer first time
	L	RBP,.FTBUF,RPI		:from-port buffer-pointer
	LI	R1,BFA(TOISIS),RP	:reconnect to ISIS output process
	JAL	R3,CHNGBF,,
	J	INPUT1			:and quit




:	Special ISIS-internal messages (ISIS port 0)
INSPEC	LHI	R4,INSPS		:search the table
INSP1	CLB	R2,INSPT,R4		:...for a match
	JNFS	INSP2			:skip if not
	L	R4,INSPT,R4		:else get address
	JR	R4			:...and go do it
INSP2	SIS	R4,4			:do next
	JGEBS	INSP1
	LB	R0,INDLGT,R2,		:get length and check if it can be flushed
	JEFS	INSPCR			:no, so crash
	JAL	R4,FLUSH		:else flush it
	J	INPUT1

:	Illegal intra-node message decoded by INSPT
INSPCR	ABORT(R8,C.IINM)

INSPT	BA(INDNON,NONEDL)		:unable to provide pseudoneedle
	BA(INDREM,REMOT)		:1-down remote
INSPS	EQ	.-INSPT-4		:size of table

:	Intra-node message length
:	(0 denotes variable length, can't be flushed)
INDLGT	BC	$A 1,1,1,7		:0-3
	BC	$A 10,6,6,9		:4-7
	BC	$A 0,5,8,5		:8-11d
	BC	$A 8,1,0,1		:13d-15d
	BC	$A 12,0,0,0		:16d-19d

:	REMOTE message
REMOT	JAL	R4,GETH			:get type and key
	JAL	R4,GETCH		:Flush sub-type
	JAL	R4,GETCH		:get size
	LR	R5,R0			:save copy
	LIS	R6,0			:set index
REMO1	JAL	R4,GETCH		:for each character...
	STB	R0,ULMSG,R6
	AIS	R6,1			:bump index
	SIS	R5,1			:count it gone
	JGBS	REMO1
	STB	R5,ULMSG,R6		:...then terminate
	J	INPUT9			:and continue

:	Unable to provide normal-needle
NONEDL	JAL	R4,GETH			:skip message type & ISIS key
	JAL	R4,GETH			:get our key
	LBR	RP,R0			:copy port number
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	SRLS	R0,8			:isolate sequence number
	CLB	R0,SEQKEY,RP		:Pseudo-needle good?
	JNFS	NOND20			:ignore if not
	LHL	RPI,.PTP.,RP2		:get pointer to port-table
	L	RBP,.TTBUF,RPI		:set to-terminal buffer-pointer
	JAL	RCH,EMPTY		:empty the buffer
	LA	R6,NOCIRM		:"NO PATH AVAILABLE..."
	JAL	R9,MSG,,
NOND20	JAL	R4,GETCH		:skip the error code
	J	INPUT9			:...then go close record

	LO	SIGNAL

NOCIRM	BC	80,SHGSIG		:prefix with super-hang
	AC	/"8D"8Ano path available...disconnecting/
	BC	80,HNGSIG,0		:append hang, terminator
	FO	SIGNAL
	SUBTTL	ISIS RING I/O...OUTPUT INTERFACE

:	OUTPUT TO ISIS
:	--------------
:	Run off timeout, every 25 ms.
OUTPUT	LHI	RPOL,(NGRP-2)*2		:word index...
OUT1	L	R0,SENDON,RPOL		:ports not backpressured
	ST	R0,P.DONE,RPOL		:ports neither backpressured nor serviced
OUT2	L	R0,P.DONE,RPOL		:port not yet serviced
	N	R0,TOISIS,RPOL		:...and Data-present for ISIS
	JFFO	R0,OUT3			:Any candidates?
	SIS	RPOL,4			:no...repeat for all groups
	JGEBS	OUT1
	J	EXDISM			:Then exit

OUT3	LR	RP,RPOL			:Got one...construct internal port-number
	SLLS	RP,3
	AR	RP,R1			:RP is port number
	LR	RP2,RP
	AR	RP2,RP2			:2*port
	LHL	RPI,.PTP.,RP2		:pointer to port-table
	L	RBP,.FTBUF,RPI		:Set from-terminal buffer-pointer
	JAL	RCH,GETCHR		:Check out first character
	 J	OUT8			:control signal...skip to send
	LR	R7,RBC			:data-char
	LB	R9,XLIMIT,RP		:construct a data message
	LHI	R0,3,R9			:How big the record will be
	RBT	RP,P.DONE		:mark port as serviced
	LH	R1,PMAPAI,RP2		:look up ISIS port number
	JAL	R4,SLOR			:Start-Logical-Output-Record
	L	RBP,.FTBUF,RPI		:locate From-terminal buffer
	LR	R0,R7			:send first data-character

OUT4	JAL	R4,PUTCH
	SIS	R9,1			:count another character placed
	JGFS	OUT6			:don't make message too big

OUT5	JAL	R4,ELODR		:big enough...stop now
	J	OUT2

OUT6	TBT	RP,TOISIS		:Any more data?
	JEBS	OUT5			:...if not, end data record
	JAL	RCH,GETCHR		:OK...look at next character
	 J	OUT7			:Control-signal, so send it on
	LR	R0,RBC			:copy it
	J	OUT4			:pass it

:	Control signal detected in input, terminate output, then process
OUT7	JAL	R4,ELODR		:End-Logical-Output-Data-Record

:	We got a control-signal...process it
OUT8	LR	R7,RBC			:copy value (if any)
	LIS	R0,8			:set excessive length for now
	LH	R1,PMAPAI,RP2		:look up ISIS port number
	LB	R2,OUT.T1,R5		:look up ISIS message type
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LO	SIGNAL
	SHI	R5,SIRSIG		:Check for Set/Query
	FO	SIGNAL
	JLFS	OUT9			:skip if not

	LB	R0,OUT.T2,R5		:Query/set...translate type-number
	JAL	R4,PUTCH
	THI	R5,1			:is it Query?
	JNFS	OUT9			:yes...just clean up
	EXBR	R0,R7			:set...copy value
	JAL	R4,PUTH			:...and send it too

OUT9	JAL	R4,ELOR			:Done...End-Logical-Output-Record
	J	OUT2			:then go process next port


:	Table of translation from Signals to ISIS
OUT.T1	BC	0,0,BRKMSG,BNDMSG,0,ZAPMSG			:0-5
	BC	0,0,EDMMSG,LDMMSG,HNGMSG,SHGMSG			:6-0B
	BC	ZAPMSG,GOBMSG,RBMSG,GBMSG,OBMSG,YBMSG		:0C-11
	BC	GRYMSG,BLKMSG,ETMMSG,LTMMSG,EADMSG,LADMSG	:12-17
	BC	0,0,0,0,0,0					:18-1D
	BC	0,0						:1E-1F
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:20-25
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:26-2B
	BC	0,0,0,0						:2C-2F
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:30-35
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:36-3B
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:3C-41
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:42-47
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,0,0			:48-4D
	BC	0,0						:4E-4F

:	Translation of signal type to parameters
:	(relative to SIRSIG)
OUT.T2	BC	$A  5,  5,  6,  6,  9,  9			:20-25
	BC	$A 10, 10, 11, 11, 15, 15			:26-2B
	BC	$A  0,  0,  0,  0				:2C-2F
	BC	$A  0,  0,  1,  1, 13, 13			:30-35
	BC	$A  3,  3,  2,  2,  4,  4			:36-3B
	BC	$A  7,  7,  8,  8, 12, 12			:3C-41
	BC	$A 14, 14, 16, 16, 17, 17			:42-47
	BC	$A 18, 18, 19, 19,  0,  0			:48-4D
	BC	$A  0,  0					:4E-4F

	FO	DATA
	SUBTTL	ISIS-Ring Handling Routines

:	ISIS-ring handlers

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 15 is dedicated to that operation,
:		until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.

:		R15 is used for input and output operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15' to 'LH R15'.

:	The package contains primitive routines:

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R15,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	Routines use dedicated register:
:	R15	ISIS ring index

:	NOTE....
:		IRSIZE and ORSIZE must each be less than 32K.


	GL	IRING,ORING,IRSIZE,ORSIZE

:	Define Ring-structure:
	D.STRU(0)
NFMI	HS	1			:next-fill-message-index
CEI	HS	1			:Current-Empty-Index
RING	BS	4			:start-of-ring-data
	D.STRU(-1)

:	Define data area
	SEG	A.RING			:rings in ring area

:	The dispatcher output ring
ORING	WS	0			:Output Block Start Address
	HS	1			:output next fill message cursor
	HS	1			:output current entry cursor
	BS	ORSIZE			:the output ring
EORING	HS	0			:End of output ring

:	The DISPATCHER input ring
IRING	WS	0			:Input-Block start address
	HS	1			:input next fill message cursor
	HS	1			:input current empty cursor
	BS	IRSIZE			:the input ring
EIRING	HS	0			:End-of-input ring

:	Code area
	SEG	A.CODE
:	Input Routines

:	LOOK at a ring entry
:	Normal return if ring empty
:	Else skip return, PORT returned in R1
:	Message-Type returned in R2
:	All registers set up for transfer
:	Position is advanced past port-number
	 IF	\LOOK;.LOOK.	  HS	0;	 ELSE;LOOK	  HS	0;	 EI
	LHL	R15,CEI+IRING,,		:Get current-empty-cursor
	CLH	R15,NFMI+IRING,,	:test if caught up
	JER	R4			:empty...normal return
	SHI	R15,IRSIZE		:*: Convert to negative cursor
	LHL	R1,EIRING,R15,		:get port number
	AIS	R15,2			:bump cursor past port number
	LB	R2,EIRING,R15,		:get message type
	LR	R1,R1			:set condition codes
	J	4,R4			:then skip return

:	GET a CHaracter from the input ring
:	Character returned in R0
GETCH	LB	R0,EIRING,R15,		:get the character
	AIS	R15,1			:bump cursor
	JLR	R4			:return if not
	LHI	R15,-IRSIZE		:else fold it
	JR	R4			:and exit

:	GET a Half-Word from the input ring
:	Assume have removed an INTEGRAL NUMBER of HALF-WORDS from record
:	Half-word returned in R0
GETH	LHL	R0,EIRING,R15,		:get the half-word data
	AIS	R15,2			:bump cursor
	JLR	R4			:return if not
	LHI	R15,-IRSIZE		:else fold it
	JR	R4			:and exit

:	GET a Word from the input ring
:	Assume have removed an INTEGRAL NUMBER of WORDS from record
:	Word returned in R0
GETW	L	R0,EIRING,R15,		:get the word data
	AIS	R15,4			:bump cursor
	JLR	R4			:return if not
	LHI	R15,-IRSIZE		:else fold it
	JR	R4			:and exit

:	FLUSH an input record
:	Number of characters to flush in R0
FLUSH	AR	R15,R0			:Advance ring and fall through

:	End-Logical-Input-Record
ELIR	AIS	R15,3			:Force to next word
	NHI	R15,-4
	JLFS	ELIR2			:no
	SHI	R15,IRSIZE		:yes
ELIR2
	AHI	R15,IRSIZE		:*: convert to posative cursor
	STH	R15,CEI+IRING,,
	JR	R4			:and exit

:	OUTPUT Routines

:	Find SPACE in the ring (How big a message it will take)
:	Returns R0 = Number of characters of space
SPACE	LCS	R0,4			:set mask
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,		:force emptier to Word boundary
	SR	R0,R15			:space between us and emptier
	JGFS	SPACE1			:skip if no wrap-around
	AHI	R0,ORSIZE		:else correct for wrap
SPACE1	SIS	R0,4			:Correct for possible overflow
	SHI	R15,ORSIZE		:*: convert to negative cursor
	JR	R4			:and return

:	Start-Logical-Output-Record
:	Provides function of ROOM, PUTH, & PUTCH for first 3 characters of message
:	R0 = number of characters of space required
:	R1 = port number
:	R2 = Message character code
SLOR	LHL	R15,NFMI+ORING,,
SLOR1	LCS	R3,4			:set a mask
	NH	R3,CEI+ORING,,		:force receiver to word boundary
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE		:account for possible ring folding
SLOR2	SIS	R3,4			:allow for potential overflow
	CR	R3,R0
	JGEFS	SLOR3			:skip if we can go
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	
	SHI	R15,ORSIZE		:*: convert to negative cursor
	STH	R1,EORING,R15,		:OK...Place message
	STB	R2,2+EORING,R15,
	AIS	R15,3			:bump past these characters
	JR	R4			:and exit

:	PUT a CHaracter into the ring
:	R0 = Character
PUTCH	STB	R0,EORING,R15,		:Place the character
	AIS	R15,1			:bump cursor
	JLR	R4			:skip if not
	LHI	R15,-ORSIZE		:else wrap around
	JR	R4			:and exit

:	PUT a Half-Word into the ring
:	R0 = half-word
PUTH	STH	R0,EORING,R15,		:Place the half-word
	AIS	R15,2			:bump cursor
	JLR	R4			:exit if not
	LHI	R15,-ORSIZE		:else wrap around
	JR	R4			:and exit

:	PUT a Word into the ring
:	R0 = word
PUTW	ST	R0,EORING,R15,		:Place the word
	AIS	R15,4			:bump cursor
	JLR	R4			:skip if not
	LHI	R15,-ORSIZE		:else wrap around
	JR	R4			:and exit

:	End-Logical-Output-Data-Record
ELODR	LHL	R1,NFMI+ORING,,		:Get start of this message
	SHI	R1,ORSIZE		:*: convert to negative cursor
	LR	R0,R15			:copy message end
	SR	R0,R1			:compute size of this message
	JGEFS	ELODR2			:skip if no wrap-around
	AHI	R0,ORSIZE		:else correct for wrap
ELODR2	SIS	R0,3			:Make allowance for header
	JER	R4			:exit if zero-length message
	STB	R0,2+EORING,R1,		:insert message type into message
					:and fall through

:	End-Logical-Output-Record
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE		:fold if necessary
ELOR2
	AHI	R15,ORSIZE		:*: convert back
	STH	R15,NFMI+ORING,,	:now advance cursor to next message
	JR	R4			:and exit

	EM	:ISIS
	SUBTTL	?STAT Command Handlers:  HELP, CODE

	MO	.,STATUS

	LO	DATA

	DS.CMD(HELP,HELP)		:Print Command List
	DS.CMD(?,HELP)			:Print Command List
	DS.CMD(CODE,CODE)		:Print Banner (which code this is).

HELP	SVC	K.OUT,BANNER
	SVC	K.OUT,HELPM1
	SVC	K.OUT,HELPM2
	SVC	K.OUT,HELPM3
	SVC	K.OUT,HELPM4
	SVC	K.OUT,HELPM5
	SVC	K.OUT,HELPM6
	SVC	K.OUT,HELPM7
	SVC	K.OUT,HELPM8
	SVC	K.OUT,HELPM9
	SVC	K.OUT,HELPMA
	SVC	K.OUT,HELPMB
	J	DSTART,,

CODE	SVC	K.OUT,BANNER		:display banner
	J	DSTART,,

BANNER	SC	/"8A"8D"8ACONSAT -- CONsolidated tymSAT"8A/
HELPM1	SC	/"8D"8AValid commands are:/
HELPM2	SC	/"8D"8AEXIT or EXI - log off/
HELPM3	SC	/"8D"8AQUIT or Q   - exit ?STAT (back to DDT)/
HELPM4	SC	/"8D"8AHELP or ?   - print this list/
HELPM5	SC	/"8D"8ACODE        - Describe the code in this slot/
HELPM6	SC	/"8D"8APORT        - Query status of all ports/
HELPM7	SC	/"8D"8AIPORT       - Query status of specific ISIS port/
HELPM8	SC	/"8D"8AQPORT       - Query status of specific physical port/
HELPM9	SC	/"8D"8AQBUSY       - query status of busy ports/
HELPMA	SC	/"8D"8ABUSY        - busy a port/
HELPMB	SC	/"8D"8AUNBUSY      - unbusy a port/
	SUBTTL	?STAT Command Handlers:  QBUSY, BUSY, UNBUSY

	DS.CMD(QBUS,QBUSY)		:Query busy-status
	DS.CMD(BUSY,SBUSY)		:busy port
	DS.CMD(UNBU,RBUSY)		:un-busy port

:	Query busy ports
QBUSY	SVC	K.OUT,QBM1		:"port busy status"
	LIS	RP,0			:start from port 0
	LIS	R2,0			:listing format control
QBUSY1	TBT	RP,BUSY.C,,		:find a busy-able port
	JNFS	QBUSY3			:got one...do it
QBUSY2	AIS	RP,1			:next port
	CLHI	RP,NAPORT
	JLBS	QBUSY1			:repeat until done
	LR	R2,R2			:Check for new line
	JE	DSTART,,		:no
	SVC	K.OUT,QPM2		:else output new line
	J	DSTART,,		:and exit

QBUSY3	LR	R0,RP			:got such a port...copy number
	LHI	R1,62A			:six decimal digits, blank fill
	SVC	KIO,$A 10
	LHI	R0,202A			:" *"
	TBT	RP,BUSY.H		:is the port busy?
	JNFS	QBUSY4			:yes
	EXBR	R0,R0			:no...change to "* "
QBUSY4	SVC	KIO,$A 14		:suffix port number with "*" if busy
	AIS	R2,1			:count for format control
	NHI	R2,07			:do line folding
	JN	QBUSY2			:not yet
	SVC	K.OUT,QPM2		:else go to new line
	J	QBUSY2			:and proceed

QBM1	SC	/"8D"8APort-busy status"8D"8A(busy port suffixed with "22*"22)"8D"8A/

:	Set unbusy
RBUSY	LIS	R4,$A 10		:set radix
	JAL	R5,DS.NUM,,		:get the port number
	CLHI	R0,NAPORT		:range check
	JG	SBUSY3			:bad range
	TBT	R0,BUSY.C,,		:is it a controllable port?
	JE	SBUSY3			:no...bad port
	RBT	R0,BUSY.H		:yes...make it unbusy
	JE	SBUSY2			:already was
	J	SBUSY1			:OK

:	Set busy
SBUSY	LIS	R4,$A 10		:set radix
	JAL	R5,DS.NUM,,		:get the port number
	CLHI	R0,NAPORT		:range check
	JG	SBUSY3			:bad range
	TBT	R0,BUSY.C,,		:is it a controllable port?
	JE	SBUSY3			:no...bad port
	SBT	R0,BUSY.H		:yes...make it busy
	JNFS	SBUSY2			:already was

SBUSY1	SBT	R0,BUSY.A		:flag action required
	SVC	K.OUT,SBM1		:"OK"
	J	DSTART,,		:and exit

SBUSY2	SVC	K.OUT,SBM2		:"Already is..."
	J	DSTART,,		:and exit

SBUSY3	SVC	K.OUT,SBM3		:"not a valid port number"
	J	DSTART,,		:and exit

SBM1	SC	/"8D"8AOK"8A/
SBM2	SC	/"8D"8A..Already is"8A/
SBM3	SC	/"8D"8ANot a valid port number"8A/
	SUBTTL	?STAT Command Handlers:  PORTS, IPORT, APORT

	DS.CMD(PORT,QALL)		:Query ALL ports
	DS.CMD(IPOR,QISIS)		:Query ISIS port
	DS.CMD(APOR,QPORT)		:Query port

:	Query ALL ports
QALL	LIS	RPOL,1			:start from port 1
	LCS	R2,1			:listing format control
QALL1	LH	RP,PMAPIA,RPOL,RPOL	:look up real port
	JLFS	QALL2			:skip if not in use
	LR	R0,RPOL			:else set up
	JAL	RLINK,DPORT		:display port information
QALL2	AIS	RPOL,1
	CLHI	RPOL,MAXPRT		:Done yet?
	JLE	QALL1			:no..continue
	SVC	K.OUT,QPM2		:yes...clean up
	J	DSTART,,		:and exit

:	Query ISIS port
QISIS	LHI	R4,$A 16		:set radix
	JAL	R5,DS.NUM,,		:get the port number
	LR	RP,R0			:copy port number
	LH	RP,PMAPIA,RP,RP		:look up physical port
	JAL	RLINK,DPORT		:display it
	SVC	K.OUT,QPM2		:clean up
	J	DSTART,,		:and exit

:	Query port
QPORT	LIS	R4,$A 10		:set radix
	JAL	R5,DS.NUM,,		:get the port number
	LR	RP,R0			:copy port number
	LH	R0,PMAPAI,RP,RP		:look up physical port
	JAL	RLINK,DPORT		:display it
	SVC	K.OUT,QPM2		:clean up
	J	DSTART,,		:and exit

:	Display the port information
:	RP -	Internal port number
:	R0 -	ISIS port number
:	R2 -	control...print header if <0
:	RLINK -	Link register
DPORT	AIS	R2,1			:header?
	JGFS	DPORT1			:no
	SVC	K.OUT,QPM1		:yes
	LIS	R2,1			:insure one time only
DPORT1	SVC	K.OUT,QPM2		:new line
	LR	R0,R0			:check ISIS port number
	JGFS	DPORT3
DPORT2	SVC	K.OUT,QPM3		:else bitch
	JR	RLINK			:and return

DPORT3	LHI	R1,330			:3 hex digits, blank fill
	SVC	KIO,$A 10
	CLHI	RP,NPORT		:check physical port
	JGEBS	DPORT2			:out of range...bitch
	LR	R0,RP			:now copy physical port number
	JGEFS	DPORT4			:skip if in use
	SVC	K.OUT,QPM4		:"not in use"
	JR	RLINK			:and exit

DPORT4	LHI	R1,62A			:6 decimal digits, blank fill
	SVC	KIO,$A 10
	JR	RLINK			:and return

QPM1	SC	/"8D"8AISIS  Port"8A/
QPM2	SC	/"8D"8A/
QPM3	SC	/    Not a valid port number/
QPM4	SC	/    Not in use/

	FO	DATA

	EM	:STATUS
	SUBTTL	PORT TABLE

:	We're finally able to define the port discriptor tables:

:	Firstly, generate a table of halfword pointers to port descriptors.
.PTP.	HS	0
Q	EQ	0
	RE	NPORT			:For each port
	 HC	Q*.PTLEN+.PTABL
Q	 EQ	Q+1
	ER

	SEG	A.DATA


:	Now define the space for the port descriptors
.PTABL	HS	NPORT*.PTLEN/2

:	ALL DONE!!
	SEG	A.CODE
	SUBTTL	Control Table Allocation and Assembly Diagnostics   - FINISH.LIB
:
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

  IF	ISIS2

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL	HS	1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	$A ($0S|Q|SIZE-10000);	REMARK	d bytes;	EI
Q	EQ	Q+1;	ER
	LIST

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
CTA	WC	CNTRL	:CONTROL FLAGS
	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
    IF	\APROT0
	BC	APROT0	:SET AREA 0 PROTECTION
    ELSE
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	BC	6	:EXECUTION PROTECTED
    EI
    IF	\APROT1
	BC	APROT1	:SET AREA ONE PROTECTION
    ELSE
	BC	5	:WRITE PROTECTED
    EI
Q	EQ	2
	RE	0C
    IF	\APROT|Q|
	BC	APROT|Q|
    ELSE
	BC	6	:EXECUTION PROTECTED
    EI
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols

  ELSE		:ISIS2

:GENERATE DIAGNOSTICS
Q	EQ	0
	RE	0E
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI

:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER

:	BITCH IF ANY SEGMENTS OVERFLOW
Q	EQ	0;	RE	0E;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	$A ($0S|Q|SIZE-10000);	REMARK	d bytes;	EI
Q	EQ	Q+1;	ER

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
	RE	0E
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
	NUMBER	$A S|Q|SIZE
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE!0FF)+1;	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols

  EI		:ISIS2
	TITLE	ISIS CONFIGURATION DESCRIPTION
	SUBTTL	OUTPUT ASSEMBLY CONFIGURATION


:    ***   ***  *   *  ****  ***  *     ***** ****    *   ***** ***** ****
:   *   * *   * **  * *     *   * *       *   *   *  * *    *   *     *   *
:   *     *   * * * *  ***  *   * *       *   *   * *****   *   ****  *   *
:   *   * *   * *  **     * *   * *       *   *   * *   *   *   *     *   *
:    ***   ***  *   * ****   ***  ***** ***** ****  *   *   *   ***** ****


:                     ***** *   * *   *  ****   *   *****
:                       *    * *  ** ** *      * *    *
:                       *     *   * * *  ***  *****   *
:                       *     *   *   *     * *   *   *
:                       *     *   *   * ****  *   *   *


:  ***   ***  *   * ***** *****  ***  *   * ****    *   ***** *****  ***  *   *
: *   * **  * **  * *       *   *   * *   * *   *  * *    *     *   *   * **  *
: *     *   * * * * ****    *   *     *   * ****  *****   *     *   *   * * * *
: *   * *   * *  ** *       *   *  ** *   * *  *  *   *   *     *   *   * *  **
:  ***   ***  *   * *     *****  ****  ***  *   * *   *   *   *****  ***  *   *

:	Display is based upon CONFIG parameter:
:	0 -	nothing displayed
:	1 -	simple display
:	2 -	simple display with debugging options


	IF	CONFIG
:	OUTPUT AN ASSEMBLY CONFIGURATION LIKE:

:	CONSAT CONFIGURATION - VERSION 6.00
:	----------------------------------------
:
:	Node:   303
:	Slot:   2
:	Default origination host:	16294
:
:	ASYNC ports:	64	(0-63)
:
:	   Debugging Options:
:		DCPSSW
:
:	--------------------------------------
:	Define Macros used...
	 KILL	PRANGE,SAY.P,BSAY,OPTION,ACCODE


:	PRANGE Macro -		report number of ports N
:				L2:	range over R
PRANGE	 MACRO(N,R)[
	 NUMBER	$A R
	 IF	CONFIG-3		:LEVEL 4
	  REMARK 	(
	  NUMBER $A N
	  IF	R-1
	   REMARK -
	   NUMBER $A N+R-1
	  EI
	  REMARK )%
	 EI
]


:	SAY.P(V) Macro		:output pretty port number V
SAY.P	MACRO(V) [
	 IF	$A 10-V
	  REMARK %  
	 ELSE	$A 100-V
	  REMARK % 
	 ELSE
	  REMARK %
	 EI
	 NUMBER $A V
	 REMARK :
]

:	BSAY (C,A,T1,T2) Macro -	If C is .TRUE., then
:					if (bit(A,P) =1, say T1 else T2
BSAY	MACRO(C,A,T1,T2)[
	 IF	C
	  IF	.BIT.(A,P)
	   REMARK T1
	  ELSE
	   REMARK T2
	  EI
	 EI
]

:	OPTION Macro -		Display parameter V if .TRUE.,
:				unless D is .TRUE. -- then DISPLAY Value V too.
OPTION	MACRO(D,V) [
	IF	D
	 REMARK %     V:	
	 NUMBER $A V
	ELSE
	 IF	V
	  REMARK %	V
	 EI	:V
	EI	:D
]


:	ACCODE Macro -		output Accounting status as required
:				for port P
ACCODE	MACRO [
	 IF	CONFIG-3			:LEVEL 4
	  IF	\.ACC|P|
	   IF	-.ACC|P|
	    REMARK 	AC-SPECIAL: 
	    NUMBER 7FFF&.ACC|P| $A
	   ELSE	7F00&.ACC|P|
	    REMARK 	AC
	    IF	.ACC|P|&4000
	     REMARK -PRIVATE
	    ELSE
	     REMARK -PUBLIC
	    EI
QQ	    EQ	(.ACC|P|/100)&3F
	    IF	QQ-2
	     REMARK -OUTWATS
	    ELSE	QQ-1
	     REMARK -INWATS
	    ELSE	QQ
	     REMARK -FDX
	    EI
	   EI
	  EI	:/.ACC|P|
	 EI
]
	SUBTTL	Generate output

:	VERSION, NODE, SLOT, PVC and MPVC
	 REMARK %%%%  CONSAT configuration - version 
	 NUMBER $8 VERSION
	 REMARK .
	 IF	0A-REVLEV
	  REMARK 0
	 EI
	 NUMBER $A REVLEV
	 IF	FTLVL
	  REMARK %	FIELD TEST 
	  NUMBER $A FTLVL
	 EI	:FTLVL
	 REMARK %----------------------------------------%

	 IF	ISIS2
	  IF	\NODE*\SLOT
	   REMARK %Node:	
	   NUMBER $8 NODE
	   REMARK %Slot:	
	   NUMBER $A SLOT
	  ELSE	\NODE
	   REMARK %Node:	
	   NUMBER $8 NODE
	   REMARK %Slot determined at start-up
	  ELSE	\SLOT
	   REMARK %Node determined at start-up
	   REMARK %Slot:	
	   NUMBER $A SLOT
	  ELSE
	   REMARK %Node and slot determined at start-up
	  EI
	 IF	\.AHOST
	  REMARK %Default Origination host:	
	  NUMBER $A .AHOST
	 EI	:\.AHOST
	 EI	:ISIS2


	 IF	PVC
	  REMARK %%PVC ports:	
	  NUMBER $A PVCCNT

	  IF	NMPVC
	   REMARK % MPVC ports:	
	   PRANGE(.MPORT,NMPVC)
	  EI	:NMPVC
	 EI	:PVC

	 IF	NAPORT
:	  ASYNC ports (and printer ports)
	  IF	NUMPRN
	   REMARK %%Printer ports:	
	   PRANGE(0,NUMPRN)
	  EI	:NUMPRN

	  REMARK %%ASYNC ports:	
	  PRANGE(0,NAPORT)

	  IF	CONFIG-1		:LEVEL 2
Q	   EQ	0
	   RE	NAPORT
P	   EQ	Q
	   SAY.P(P)
	   BSAY(1,.120T,  TID 120,  TID 30 )
	   BSAY(.2HD,.2HD,	202-S,)
	   BSAY(1,.BSY,	VADIC,)
	   ACCODE
	   BSAY(PVC,PVCG,	`(PVC`),)
Q	   EQ	Q+1
	    ER
	    REMARK %
	  EI	:CONFIG-1
	 EI	:NAPORT


	 IF	NSPORT
	  REMARK %%SIO ports:	
	  PRANGE(.SPORT,NSPORT)

	  IF	CONFIG-1		:LEVEL 2
Q	   EQ	0
	   RE	NSPORT
P	    EQ	.SPORT+Q
	    SAY.P(Q)
	    ACCODE
	    BSAY(PVC,PVCG,	`(PVC`),)
Q	    EQ	Q+1
	   ER
	    REMARK %
	  EI	:CONFIG-1
	  IF	1-BAUDY
	   REMARK %   all are expected to be ASCII%
	  EI	:BAUDY
	 EI	:NSPORT



	 IF	CONFIG-3		:LEVEL 4
:	  Debugging options DCPSSW, CPS
	  IF	CPS!DCPSSW
	   REMARK %%   Debugging Options:
	   OPTION(0,DCPSSW)
	   OPTION(0,CPS)
	  EI
	 EI	:CONFIG-3



	 IF	ISIS2
	  IF	CONFIG-4		:LEVEL 5
:	   ISIS debugging options CRSTOP, RHIST, AHIST, ASYERR, FORRUN
	   IF	(RHIST!AHIST!ASYERR!CRSTOP!FORRUN)&0FFFF
	    REMARK %%   ISIS Debugging Options:
	    OPTION(0,CRSTOP)
	    OPTION(0,RHIST)
	    OPTION(0,AHIST)
	    OPTION(0,ASYERR)
	    OPTION(0,FORRUN)
	   EI
	  EI	:CONFIG-4
	 EI	:ISIS2

	 IF	CONFIG-2		:LEVEL 3
:	  Assembly options ISIS2, NHNGBK
	  IF	(ISIS2!NHNGBK)&0FFFF
	   REMARK %%   Assembly Options:
	   OPTION(1,CONFIG)
	   OPTION(0,ISIS2)
	   OPTION(0,NHNGBK)
	  EI
	 EI	:CONFIG-2

	 IF	\HOST0
	  REMARK %PRINTER HAS HOST  
	  NUMBER $A HOST0
	 EI
	 REMARK %%----------------------------------------%%%%

	 KILL	PRANGE,SAY.P,BSAY,OPTION,ACCODE
	EI	:CONFIG
	KILL	SPECIAL,PRIVATE,PUBLIC,FEX,INWATS,OUTWATS
  4zy:n