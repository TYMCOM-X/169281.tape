: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 02.01         Release Date : 3/31/87   **
: **                                                              **
: **  File Name          : ALCC02.R01                             **
: **                                                              **
: **  File Description   : ALC-CMT                                **
: **                                                              **
: **  File Abstract      :                                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement: 160-200K                           **
: **                                                              **
: **  Basic Code Size:  161K                                      **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **       KB = MAXPRT  X (4/10) + 161                            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations: (TYMNET:25)ND2567.T03
: **                                                              **
: **  HARDWARE/FIRMWARE REQUIREMENTS:  TYMNET ENG                 **
: **                                                              **
: **  Other Software Requirements: TL.AUX LICENSE                 **
: **                                                              **
: **  Slot Limitations:  MAX:  MAXPRT = 80 ....192KB
: **                     MIN:  MAXPRT = 20 ....169KB              **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
	SUBTTL	ISIS Ring Handling Routines	- FRING.LIB
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR
        GL      NFMI,CEI,RING

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
LOOK	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
	SUBTTL	Standard Timeout Routine Library	- TIMOUT.LIB
	RA	0		:	TIMOUT.LIB

:	This package contains the standard timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:		R1 = current fast-clock time.
:	TORET	routines called by TIMOUT should exit to here
:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5...R6--R15 preserved
:		R0 = address to transfer to
:		R1 = next time to call routine
:	TOGET	called to delete an entry already on timout list
:		link on R5...R6--R15 preserved
:		R0 = routine address...entry with this address will be deleted
:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5...NO registers preserved! NOW!
:		routine address in R0
:	NOTE...when a routine is called from timeout list, it is removed from list,
:	and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 10		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,0F	:FLAG--LINK R5, TYPE 15d CRASH
TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4
	ST	R1,TLIST+6,R4
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
	SUBTTL	GCI/WCI Buffer Package
	RA	0		:	BUFFER.LIB

:	This packantains all code and storage allocation needed for
:	bufferlet usage.
:	If the symbol BUFTRC is defined and has a value greater than 0,
:	then a trace of all GCI and WCI calls will be included and
:	HISX will be a halfword pointer into a table HISTAB.
:	HISTAB will contain 100 one word entries.  Each entry contains
:	a one byte character, one byte of buffer number, and a halfword
:	address of the caller of GCI/WCI.  The table is circular.

:	the following parameters MUST be defined before assembly:
:	NBUF	the number of buffers to create
:	NBFLET	the number of bufferlets to create

:	uses routines in TIMOUT.LIB - - - requires one timeout list entry

:	may JAL R10,CRASH on certain conditions

:	Each routine is called with:
:	Link on R4
:	R0 = argument
:	R1 = buffer index (buffer number*2)

:	routines:
:	IZBF	link on R5, used to initialize buffers
:	GCI	get a character from buffer
:	WCI	write a character into buffer
:	WCD	back up a buffer to restore last character
:	EMPTY	empty (flush) buffer

:	buffer index may be used to index into the following halfword arrays
:	from external routines:
:	BF	buffer flags
:	BB	buffer start address
:	BE	buffer end address
:	BCT	buffer counts

:	the following should also be defined externally:
:	FLAGS	a bit array of length corresponding to max buffer flag value
:
:	If the macro ZAPBUF is defined then the code in the macro will
:	be executed whenever CKBZ is forced to zap a buffer. The code
:	will be executed immediately following the call to EMPTY
:	(R1 will contain the buffer index).  The first line of the macro
:	must be "ZAPBUF MACRO [.X" (where X may be a carriage return
:	or semicolon).


	GL	NBUF,NBFLET,BUFTRC
  IF	\BUFTRC
  ELSE
BUFTRC	EQ	0
	REMARK	%*** Define BUFTRC EQ 1 if debug trace desired
  EI

	MO	.,BUFFER
	GL	FASTC,TORET,TOPUT,RATE,FLAGS,CRASH
	GL	BF,BCT,BB,BE
	GL	IZBF,GCI,WCI,WCD,EMPTY,GCPEEK,GCSCAN,MCI

:	THE DATA FOR THESE ROUTINES
	SEG	A.DATA		:PLACE IN DATA AREA
REBL	HC	0		:FREE LIST POINTER FOR RESERVE STORAGE LIST
REBC1	HC	0		:COUNTS TIMES BUFFER STORAGE WAS MOVED TO MAIN FREE LIST
REBC2	HC	0		:COUNTS TOTAL NUMBER OF BUFFER ZAPS
BFZ	HC	-1		:LAST BUFFER ZAPPED

BF	HS	NBUF		:BUFFER FLAGS
BCT	HS	NBUF		:BUFFER COUNTS
BB	HS	NBUF		:BUFFER START ADDRESS
BE	HS	NBUF		:BUFFER END ADDRESS

  IF	BUFTRC
	GL	HISX,HISTAB
HISX	HC	0		:INDEX FOR HISTORY
HISTAB	HS	200		:HISTORY DATA...400 BYTES...100 HISTORY ENTRIES
  EI



:	CODE SECTION
	SEG	A.CODE		:PLACE IN CODE ARAEA

:	INITIALIZE BUFFERS
IZBF	LIS	R0,0		:SET A CONSTANT
	LHI	R1,NBUF*2-2	:FOR ALL BUFFERS
IZBF1	STH	R0,BCT,R1	:SET EMPTY
	LHL	R2,BF,R1
	RBT	R2,FLAGS	:TURN OFF FLAG BIT
	SIS	R1,2
	JGEBS	IZBF1
	LHI	R1,NBFLET*8	:FOR ALL BUFERLETS
	STH	R0,BUFERS,R1,	:TERMINATE LIST
IZBF2	STH	R1,BUFERS-8,R1,	:LINK LAST TO THIS
	STH	R0,BUFERS-6,R1,	:CLEAR DATA AREA
	ST	R0,BUFERS-4,R1,
	SIS	R1,8
	JGBS	IZBF2		:REPEAT FOR ALL BUFFERLETS
	STH	R0,REBL		:SET SPARE TANK EMPTY
	L	R1,FASTC,,
	LHI	R1,RATE/$A25,R1	:CALL EVERY 40 MS.
	LA	R0,CKBZ		:PUT BUFFER CHECKING LOGIN ON QUEUE
	J	TOPUT		:EXIT VIA TIMEOUT LIST ENTRY
:	CHARACTER HANDLERS. THESE ROUTINES PASS BFR CHR IN R0,
:	R1 FOR TWICE THE BUFFER NUMBER, R2,R3 FOR WORKING REGISTERS,
:	R4 IS LINK REGISTER.

:	GET CHAR FROM BUFFER AND INCREMENT FORWARD THRU THE BUFFER.
GCICRA	JAL	R10,CRASH;	BC	0,0,4*R4,3	:FLAG--LINK R4, TYPE 3
GCI	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JGEBS	GCICRA		:BUFFER NUMBER OUT OF RANGE...CRASH
	LHL	R2,BB,R1	:GOOD BUFFER...GET INDEX TO CHARACTER
	LB	R0,BUFERS,R2,	:PICK UP CHAR
	LCS	R3,1
	AHM	R3,BCT,R1	:REDUCE COUNT OF CHARS IN BUFFER
	JLE	GCILAS		:SKIP IF NO CHARACTERS LEFT
	AIS	R2,1		:ELSE INCREMENT BB VALUE
	THI	R2,7		:TEST IF AT END OF BUFFERLET
	JEFS	GCI1		:RETURN BUFFERLET TO FREE LIST IF SO
	STH	R2,BB,R1	:ELSE UPDATE BB
  IF	BUFTRC
	J	HIST		:AND RETURN WITH THE CHAR
  ELSE
	JR	R4		:AND RETURN WITH THE CHAR
  EI

GCI1	LHL	R3,BUFERS,R2,	:BUFFERLET EXHAUSTED
	SIS	R3,6		:CHAIN TO NEXT BUFFERLET
	STH	R3,BB,R1	:SET BB TO START OF NEXT BUFFERLET
	LHL	R3,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R3,BUFERS,R2,	:LINK LAST BUFFERLET TO FREE LIST
	STH	R2,BUFERS,,	:AND PUT AT THE HEAD OF THE FREE LIST
  IF	BUFTRC
	J	HIST		:THEN EXIT
  ELSE
	JR	R4		:THEN EXIT
  EI

GCILAS	JL	GCICRA		:CRASH IF BUFFER WAS EMPTY
	LHL	R3,BF,R1	:OK...GET POINTER TO FLAG BIT
	RBT	R3,FLAGS	:RESET ATTENTION FLAG
	AIS	R2,6		:BUMP CHARACTER POINTER PAST END OF BUFFERLET
	NHI	R2,-8		:MAKE CHAIN A MULTIPLE OF 8
	LHL	R3,BUFERS,,
	STH	R3,BUFERS,R2,
	STH	R2,BUFERS,,	:UPDATE FREE LIST
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

:	PUT A CHARACTER INTO THE BUFFER
WCI	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JLFS	WCI1		:SKIP IF OK
WCICRA	JAL	R10,CRASH	:ELSE CRASH
	BC	0,0,4*R4,5	:FLAG--LINK R4, TYPE 5 CRASH

WCI1	LHL	R2,BCT,R1	:CHECK COUNT
	JE	WCIFRS		:IF NEW BUFFER, SET UP ATTENTION FLAGS
	AIS	R2,1		:ELSE UPDATE COUNT
	STH	R2,BCT,R1
	LHL	R2,BE,R1	:GET POINTER TO LAST CHARACTER POSITION
	AIS	R2,1		:BUMP POINTER
	THI	R2,7		:TEST IF BUFFERLET FULL
	JEFS	WCINXB		:END OF BUFFERLET
	STH	R2,BE,R1	:ELSE UPDATE BE
	STB	R0,BUFERS,R2,	:AND SAVE CHAR IN BUFFER
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCINXB	LHL	R3,BUFERS,,	:NEED A NEW BUFFERLET
	JNFS	WCINXC		:SKIP IF THERE IS ANOTHER
	JAL	R2,WRE		:(OPEN THE RESERVE TANK)
	LHL	R2,BE,R1	:RESTORE R2
	AIS	R2,1
WCINXC	STH	R3,BUFERS,R2,	:LINK NEW BUFFERLET TO LAST ONE
	LHL	R2,BUFERS,R3,	:AND REMOVE FROM FREE LIST
	STH	R2,BUFERS,,
	SIS	R3,6		:BACK UP NEW BUFFERLET
	STH	R3,BE,R1	:SAVE AS NEW BE
	STB	R0,BUFERS,R3,	:PUT THE CHARACTER THERE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCIFRS	LH	R2,BF,R1	:THE BUFFER WAS EMPTY
  IF	BUFTRC
	JE	HIST		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  ELSE
	JER	R4		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  EI
	SBT	R2,FLAGS	:ATTENTION BIT ON TO ALERT SOME PROCESS OF DATA WAITING
	LIS	R2,1
	STH	R2,BCT,R1	:SET COUNT = 1
	LHL	R3,BUFERS,,	:POP A BUFFERLET OFF FREE LIST
	JGFS	.+6		:SKIP IF THERE WAS ONE
	JAL	R2,WRE		:ELSE OPEN THE RESERVE TANK
	LHL	R2,BUFERS,R3,
	STH	R2,BUFERS,,	:UPDATE FREE LIST
	SIS	R3,6		:POINT IT AT FIRST CHARACTER
	STH	R3,BB,R1	:SET UP BB
	STH	R3,BE,R1	:AND BE
	STB	R0,BUFERS,R3,	:PUT THE CHARACTER THERE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

:	MOVE RESERVE STORAGE SUPPLY TO MAIN FREE LIST
WRE	LHL	R3,REBL		:GET POINTER TO RESERVE BUFFERLETS
	EXHR	R3,R3
	STH	R3,REBL		:SET RESERVE BUFFERLETS EMPTY (=0)
	EXHR	R3,R3
	JNR	R2		:IF IT WASN'T EMPTY, RETURN
	JAL	R10,CRASH	:BUG, UNREASONABLY FAST STORAGE DRAIN
	BC	0,0,4*R4,6	:FLAG--LINK R4, TYPE 6

  IF	BUFTRC
:	UPDATE HISTORY (TRACE) AFTER EVERY BUFFER OPERATION
HIST	LH	R3,HISX		:GET HISTORY RING INDEX
	AIS	R3,4		:BUMP TO NEXT ENTRY
	NHI	R3,3FF		:ACCOUNT FOR FOLDING
	STH	R3,HISX		:SAVE IT AGAIN
	STB	R0,HISTAB,R3	:ENTRY (0) = CHARACTER
	LR	R2,R1
	SRHLS	R2,1		:COMPUTE BUFFER #
	STB	R2,HISTAB+1,R3	:ENTRY (1) = PORT #
	STH	R4,HISTAB+2,R3	:ENTRY (2, 3) = LOCATION WHERE CHAR PLACED
	JR	R4
  EI	(BUFTRC)

:	PEEK AT FIRST CHAR OF BUFFER
GCPCRA	JAL	R10,CRASH;	BC	0,0,4*R4,6	:CRASH TYPE 6
GCPEEK	CLHI	R1,2*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
	LHL	R2,BB,R1	:GET POINTER TO START OF BUFFER DATA
	LHL	R3,BCT,R1	:GET COUNT OF CHARS THERE
	JFS	GCS		:AND SKIP

:	SCAN SUCESSIVE CHARACTERS IN BUFFER
GCSCAN	CLHI	R1,2*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
GCS	SIS	R3,1
	JL	GCPCRA		:CRASH IF NO MORE CHARACTERS THERE
	LB	R0,BUFERS,R2,	:ELSE GET CHAR
	AIS	R2,1		:BUMP POINTER FOR NEXT TIME
	THI	R2,7
	JNR	R4		:EXIT IF NOT AT END OF BUFFERLET
	LHL	R2,BUFERS,R2,	:ELSE ADVANCE TO NEXT BUFFERLET
	SIS	R2,6		:POINT AT START
	JR	R4

:	MCI - MOVE ALL CHARACTERS FROM SOURCE TO DESTINATION BUFFER
:	R5 = SOURCE BUFFER INDEX
:	R6 = DESTINATION BUFFER INDEX
:	R7 = LINK
MCICRA	JAL	R10,CRASH
	BC	0,0,4*R7,4	:FLAG--LINK R7, TYPE 4
MCI	CLHI	R5,2*NBUF
	JGBS	MCICRA		:RANGE CHECK ON SOURCE
	CLHI	R6,2*NBUF
	JGBS	MCICRA		:RANGE CHECK ON DESTINATION
	LHL	R0,BCT,R5	:CHECK SOURCE
	JER	R7		:EXIT IF EMPTY
	LHL	R1,BF,R6	:SET DESTINATION FLAG
	JNFS	MCI1		:FLAG = 0 IS BIT BUCKET
	LR	R1,R5		:THEN JUST EMPTY BUFFERS
	LR	R4,R7
	J	EMPTY
MCI1	SBT	R1,FLAGS	:SET THE FLAG
	JNFS	MCI2		:NOT EMPTY...GO APPEND
	LHL	R0,BB,R5	:EMPTY...COPY BUFFER START
	STH	R0,BB,R6
	J	MCI4		:AND SKIP TO FINISH TRANSFER OF DATA
MCI2	LHL	R1,BE,R6	:CHECK DESTINATION
	AIS	R1,1		:IS IT AT END OF BUFFERLET?
	THI	R1,7
	JNFS	MCI3		:SKIP IF NOT
	LHL	R2,BB,R5	:YES...IS SOURCE ON BUFFERLET BOUNDARY?
	AIS	R2,6
	THI	R2,7
	JNFS	MCI3		:SKIP IF NOT
	STH	R2,BUFERS,R1,	:ELSE APPEND SOURCE TO DESTINATION
	JFS	MCI4		:AND SKIP
MCI3	LR	R1,R5		:MOVE A CHAR
	JAL	R4,GCI
	LR	R1,R6
	JAL	R4,WCI
	LHL	R0,BCT,R5	:CHECK SOURCE
	JG	MCI2		:LOOP IF NOT EMPTY
	JR	R7		:ELSE RETURN
MCI4	LHL	R0,BE,R5
	STH	R0,BE,R6	:UPDATE BUFFER END
	LHL	R0,BCT,R5
	AHM	R0,BCT,R6	:UPDATE COUNT
	LIS	R0,0
	STH	R0,BCT,R5	:CLEAR SOURCE BUFFER
	LHL	R1,BF,R5
	RBT	R1,FLAGS	:TURN OFF SOURCE FLAG
	JR	R7		:AND EXIT

:	BACK UP A BUFFER TO RESTORE LAST CHAR
WCD	LHL	R2,BCT,R1	:PICK UP COUNT
	JE	WCDZ		:BFR IS EMPTY BUT OLD CHAR IS STILL AROUND
	AIS	R2,1		:ELSE UPDATE COUNT
	STH	R2,BCT,R1
	LHL	R2,BB,R1	:BACK UP BB
	SIS	R2,1
	STH	R2,BB,R1
	AIS	R2,7		:TEST IF BACKED OVER BEGINNING OF BUFFERLET
	THI	R2,7
	JNR	R4		:EXIT IF NOT
	LHL	R3,BUFERS,,	:ELSE GET LAST ENTRY FROM FREE LIST
	LHL	R0,BUFERS,R3,
	STH	R0,BUFERS,,
	STH	R2,BUFERS,R3,	:LINK NEW FIRST ENTRY TO OLD FIRST
	SIS	R3,1
	STH	R3,BB,R1	:SET NEW ENTRY INTO BB
	JR	R4

WCDZ	LHL	R2,BUFERS,,	:HERE WITH BUFFER EMPTY (BB IS OK)
	LHL	R3,BUFERS,R2,
	STH	R3,BUFERS,,	:FIXUP FREE LIST
	LHL	R2,BF,R1
	SBT	R2,FLAGS	:SET NONEMPTY BFR ATTENTION FLAG
	LIS	R2,1
	STH	R2,BCT,R1	:SET COUNT = 1 CHARACTER
	JR	R4

:	RETURN ALL THE SPACE USED BY THE BUFFER
EMPTY	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JLFS	C1		:BFR ARGUMENT ACCEPTED
	JAL	R10,CRASH	:BFR ARG OUT OF RANGE
	BC	0,0,4*R4,0D	:FLAG--LINK R4, TYPE 13d

C1	LHL	R2,BCT,R1	:CHECK CONTENTS
	JER	R4		:EXIT...BUFFER EMPTY
	LIS	R2,0
	STH	R2,BCT,R1	:NOT EMPTY...SET COUNT = 0
	LHL	R2,BB,R1	:POINTER TO FIRST CHAR IN BUFFER
	AIS	R2,6
	NHI	R2,-8
	LHL	R3,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R2,BUFERS,,	:PUT THE BUFFERS BUFFERLETS ONTO FREE LIST
	LHL	R2,BE,R1	:GET POINTER TO LAST CHARACTER IN BUFFER
	AIS	R2,6		:LOCATE THE POINTER IN THIS BUFFERLET
	NHI	R2,-8
	STH	R3,BUFERS,R2,	:CHAIN PREVIOUS FREE LIST TO THIS BUFFERLET
	LH	R2,BF,R1
	RBT	R2,FLAGS	:SET FLAGS TO EMPTY BUFFER
	JR	R4		:AND RETURN

:	SEE IF WE MUST ZAP BFRS BECAUSE BFR STORAGE RUNNING LOW
CKBZ	LHI	R1,RATE/$A25,R1	:SET TIMER FOR NEXT CALL
	JAL	R5,TOPUT	:RUN 25 TIMES PER SECOND
	LH	R1,REBL		:ARE WE ON THE RESERVE TANK?
	JN	TORET		:PLENTY OF BFR STORAGE. DONT ZAP BFRS

:	WCI GRABBED RESERVE BFR FREE LIST AND MOVED IT TO MAIN FREE LIST.
:	REFILL FREE LIST WITH 1/8 OF TOTAL BFR STORAGE. ZAP BFRS IF NECESSARY.
	LIS	R0,1
	AHM	R0,REBC1	:STATISTIC
REB1	LIS	R2,0		:INITIAL POINTER IS TO START OF FREE LIST
	LA	R1,NBFLET/8	:SCAN MAIN FREE LIST FOR 1/8 FREE STORAGE

REB2	LHL	R2,BUFERS,R2,	:GET NEXT BUFFER ON FREE LIST
	JE	REBZ		:NOT ENOUGH SPARE SPACE. ZAP A BFR
	SIS	R1,1		:GOT ANOTHER...COUNT IT
	JGBS	REB2		:GO UNTIL WE'VE GOT ENOUGH
	LHL	R3,BUFERS,,	:DONE...SEPERATE FREE LIST INTO TWO PARTS
	STH	R3,REBL		:BEGINNING OF THE RESERVE LIST
	LHL	R4,BUFERS,R2,,
	STH	R4,BUFERS,,	:BEGINNING OF MAIN LIST
	STH	R1,BUFERS,R2,,	:DEATH'S BRIGHT ANGEL AT END OF SPARE LIST (=0)
	J	TORET

:	ZAP A BFR IN ORDER TO GET RESERVE TANK UP TO 1/8 OF TOTAL BFR STORAGE
REBZ	LHI	R1,NBUF*2-2	:BCT INDEX
	LIS	R7,0		:BCT CONTENTS OF LARGEST BFR
REBZ1	LHL	R0,BCT,R1
	CLR	R7,R0
	JGEFS	.+6
	LR	R7,R0
	LR	R8,R1
	SIS	R1,2
	JGEBS	REBZ1
	LIS	R0,1
	AHM	R0,REBC2
	STH	R8,BFZ		:STATISTICS
	LR	R1,R8		:ZAP BIGGEST BUFFER FOUND
	JAL	R4,EMPTY	:RETRIEVE STORAGE
  IF	\ZAPBUF : ZAPBUF WILL EXPAND INTO MACRO CALL IF DEFINED,
  EI		:ELSE THIS IS A NOOP
	LIS	R0,9
	JAL	R4,ROOM		:WE WANT TO SEND A 9-BYTE MESSAGE
	LHI	R0,0300		:SPECIAL MESSAGE TYPE 3...
	JAL	R4,PUTW		:SEND DIAGNOSTIC TO SUP
	LR	R0,R7
	JAL	R4,PUTH		:HW4 = CHAR COUNT
	LR	R0,R8
	SRHLS	R0,1
	JAL	R4,PUTH		:HW3 = BUFFER NUMBER
	LIS	R0,0
	JAL	R4,PUTCH	:HW2 = 0
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	J	REB1		:TRY AGAIN TO FILL RESERVE STORAGE LIST


:	BUFFER SEGMENT
	SEG	A.BUFF		:BUFFERLETS IN BUFFER AREA
BUFERS	HS	4*NBFLET+1	:THE STORAGE FOR THE BUFFERLETS
	EM
	SUBTTL	Library Package for BID and BIDH	- BID.LIB
	RA	0		:	BID.LIB
:	Library package for BID, BIDH

:	either routine called with bit pattern in R1, link on R3
:	returns number of a non-zero bit in R2
	GL	BID,BIDH
	SEG	A.CODE		:PLACE IN CODE AREA
	MO	.,BID
:

:	HALFWORD Bit identifier
:	left half of R1 must be zero if bit 16 is zero
:	returns original word in R1
:	number of leftmost bit of right half or R1 in R2
  IF	ENGINE
BIDH	JFFOH	R1,BIDH1	:FIND FIRST NON-ZERO BIT
	LHI	R2,10	:RETURN 10 IF NO BIT IS FOUND
BIDH1	JR	R3	:AND RETURN
  ELSE
BIDH1	LB	R2,BIDTAB,R1	:LEFT HALF IS EMPTY
	JR	R3		:GET ID OF FIRST BIT IN RIGHT HALF
BIDH	THI	R1,0FF00	:TEST IF FIRST BIT IS IN LEFT OR RIGHT BYTE OF HALFWORD
	JEBS	BIDH1		:RIGHT HALF
	EXBR	R2,R1		:LEFT HALF
	LBR	R2,R2		:COPY LEFT BYTE
	LB	R2,BIDTAB,R2	:USE IT TO INDEX INTO ID TABLE
	SIS	R2,8		:ADJUST NUMBER TO CORRESPOND TO LEFT BYTE
	JR	R3		:AND RETURN
  EI	ENGINE

:	FULLWORD Bit identifier
:	returns original word in R1
:	number of leftmost non-zero bit in R2
  IF	ENGINE
BID	JFFO	R1,BID1		:TEST FULLWORD FOR FIRST NON-ZERO BIT
	LHI	R2,20		:RETURN 20 IF NO BIT FOUND
BID1	JR	R3		:AND RETURN
  ELSE
BID1	LB	R2,BIDTAB,R1	:IN BYTE 4
	AHI	R2,10		:GET BIT ID FOR BYTE AND ADJUST FOR BYTE 4
	JR	R3
BID2	THI	R1,0FF00	:BYTE 1 AND 2 = 0
	JEBS	BID1		:IF BYTE 3 IS 0, LOOK UP BYTE 4
	EXBR	R2,R1		:ELSE COPY OUT BYTE 3
	LBR	R2,R2
	LB	R2,BIDTAB,R2	:PICK UP INDEX FOR THAT BYTE
	AIS	R2,8		:ADJUST FOR BYTE 3
	JR	R3
BID	THI	R1,8000		:TEST IF IN LEFT 17 BITS
	JEBS	BID2		:IF NOT, MUST BE IN BYTE 3 OR 4
	EXHR	R2,R1		:BIT IS IN BYTE 1 OR 2 (OR BIT 16)
	TI	R2,0FF00	:TEST IF BYTE 1
	JEFS	BID3		:SKIP IF NOT
	EXBR	R2,R2		:BIT IS IN BYTE 1, SO COPY BYTE 1
	LBR	R2,R2		:TO USE AS INDEX
	LB	R2,BIDTAB,R2	:LOOK UP ID WITHIN THIS BYTE
	SIS	R2,8		:ADJUST FOR REALLY BEING IN BYTE 1
	JR	R3
BID3	LBR	R2,R2		:HERE WITH BIT IN BYTE 2 (OR BIT 16)
	LB	R2,BIDTAB,R2	:LOOK UP ID WITHIN THIS BYTE
	JR	R3		:IF FIRST BIT WAS BIT 16, USE ENTRY 0 IN TABLE
BIDTAB	HS	0		:TABLE OF BIT NUMBERS IN A BYTE, BIASED BY 8
	NOLIST
	XC	100F0E0E0D0D0D0D0C0C0C0C0C0C0C0C0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B
	XC	0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A
	RE	2
	XC	0909090909090909090909090909090909090909090909090909090909090909
	ER
	RE	4
	XC	0808080808080808080808080808080808080808080808080808080808080808
	ER
	LIST
  EI	ENGINE
	EM
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
	RA	0		:	CRASH.LIB

  IF	ISIS2
:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:	Entering :RCRAT,4B in NAD will dump the crash table.
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI

	SEG	A.DATA
CRAT	HS	0		:START OF CRASH TABLE AREA
CRSHCT	HC	0		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HC	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HC	0,0		:WHERE CRASH OCCURED
CFROM	HC	-1,-1		:WHERE CRASH WAS CALLED FROM
CRREG	HS	20		:CRASH REGISTER SAVE AREA
FGNDFL	HS	1		:FOREGROUND FLAG


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	0	:POWER FAILURE
	BC	1	:MANUAL RESTART
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
	LB	R0,CRSHCD,R1	:CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1	STM	R2,CRREG+8	:SAVE THE REGISTERS
	STH	R0,CRASHC	:SAVE CRASH CODE
	LM	R12,FAIL	:GET THE REST
	STM	R14,CRREG	:SAVE R0 & R1
	ST	R13,CPOINT	:SAVE FAILURE ADDRESS
	LCS	R1,1
	ST	R1,CFROM	:FLUSH PLACE CALLED FROM
	J	ENTRY1		:AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH	STM	R0,CRREG	:SAVE REGISTERS AND
	ST	R10,CPOINT
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
	L	R1,CRREG,R2	:GET CONTENTS OF REGISTER
CRASH1	STH	R0,CRASHC	:SAVE CRASH CODE
	ST	R1,CFROM	:SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
	STH	R0,CRASHC	:STORE IT
ENTRY1	LIS	R1,1
	AHM	R1,CRSHCT	:SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
	LM	R0,CRREG	:RESTORE REGISTERS
	SVC	SYS,FREEZ.	:FREEZE THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH

:	NOW RESET OUTPUT RING, REPORT CRASH
	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING
	JAL	R4,SPACE	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300;	JAL	R4,PUTW		:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRSHCT;	JAL	R4,PUTH		:HW4 = CRASH COUNT
	LHL	R0,CRASHC;	JAL	R4,PUTH		:HW3 = CRASH CODE
	LIS	R0,1;	JAL	R4,PUTCH	:HW2 IS DIAGNOSTIC 1
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	J	START,,		:NOW GO TO INITIALIZATION CODE
	EM

  ELSE		:ISIS2
:			ISIS - I Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and CRASH will sit in a loop calling DISMISS.
:	This is less load on the CPU than sitting in a self loop.
:	In order to start the code again CRSHCT must be set to 0.
:
:	Entering :RCRAT,4B in NAD will dump the crash table.

	SEG	A.DATA
CRAT	HS	0		:START OF CRASH TABLE AREA
CRSHCT	HC	0		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HC	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HC	0,0		:WHERE CRASH OCCURED
CFROM	HC	-1,-1		:WHERE CRASH WAS CALLED FROM
CRREG	HS	20		:CRASH REGISTER SAVE AREA


	SEG	A.CODE		:NOW ADVANCE TO SEGMENT 1
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
	LHI	R0,$8 01;	J	FAIL0		:MANUAL RESTART
	LHI	R0,$8 00;	J	FAIL0		:POWER FAILURE
	LHI	R0,$8 14;	J	FAIL1		:PARITY ERROR
	LHI	R0,$8 20;	J	FAIL1		:DISPATCHER CRASH
	LHI	R0,$8 21;	J	FAIL1		:ILLEGAL INSTRUCTION
	LHI	R0,$8 22;	J	FAIL1		:ILLEGAL SVC
	LHI	R0,$8 23;	J	FAIL1		:PRIVILEGE VIOLATION
	LHI	R0,$8 24;	J	FAIL1		:PROTECTION VIOLATION
	LHI	R0,$8 25;	J	FAIL1		:ARITHMETIC FAULT

FAIL0	SVC	DISMISS,10	:POWER FAILURE OR MANUAL RESTART...
				:SLEEP FOR A WHILE
FAIL1	STM	R1,CRREG+4	:SAVE THE REGISTERS
	STH	R0,CRASHC	:SAVE CRASH CODE
	LM	R13,FAIL	:GET THE REST
	ST	R15,CRREG	:SAVE R0
	ST	R14,CPOINT	:SAVE FAILURE ADDRESS
	LCS	R1,1
	ST	R1,CFROM	:FLUSH PLACE CALLED FROM
	J	ENTRY1		:AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH	STM	R0,CRREG	:SAVE REGISTERS AND
	ST	R10,CPOINT
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
	L	R1,CRREG,R2	:GET CONTENTS OF REGISTER
CRASH1	STH	R0,CRASHC	:SAVE CRASH CODE
	ST	R1,CFROM	:SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
	STH	R0,CRASHC	:STORE IT
ENTRY1	LIS	R1,1
	AHM	R1,CRSHCT	:SAVE INTERESTING DATA

  IF	\CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
    IF	CRSTOP
	CLH	R1,CRSHCT	:TEST IF FIRST TIME
	JE	ENTRY0		:IF FIRST TIME IN
	SIS	R0,1
	JLE	ENTRY0		:IF POWER FAILURE OR MANUAL RESTART
	LHL	R0,UPDOWN	:SET HOST DOWN
	OHI	R0,4000
	STH	R0,UPDOWN
	LHI	R0,0BADC
	STH	R0,FPANEL	:SET PANEL TO BAD CRASH
	LM	R0,CRREG	:RESTORE REGISTERS
	SVC	DISMISS,$A 900	:SLEEP FOR 15 MINUTES
	JBS	.-4		:CONTINUE DISMISSING FOREVER
    EI	CRSTOP
  EI	\CRSTOP


ENTRY0	SVC	1,FAIL		:INITIALIZE RESTART
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH

:	NOW RESET OUTPUT RING, REPORT CRASH
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING
	JAL	R4,SPACE	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300;	JAL	R4,PUTW		:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRSHCT;	JAL	R4,PUTH		:HW4 = CRASH COUNT
	LHL	R0,CRASHC;	JAL	R4,PUTH		:HW3 = CRASH CODE
	LIS	R0,1;	JAL	R4,PUTCH	:HW2 IS DIAGNOSTIC 1
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	J	START,,		:NOW GO TO INITIALIZATION CODE
	EM

  EI		:ISIS2
	SUBTTL	PATCH AREA DEFINITIONS
	RA	0		:	PATCH.LIB

:	This library defines symbols, macros and areas used for patching
:	released code and keeping a history of patches in Engine memory.

:	A file containing the actual patches to the code should be
:	assembled as the last file before saving the NIB file.

:	Patches are added by ORGing to the area to patch,
:	zeroing memory for the length of the patch, writing new
:	code starting at that area.
:	Three macros have been defined to do this.
:	Each patch should start with a PATCH macro and if the
:	patch is for more than one area it should be continued
:	with a CONPATCH macro.  The patch should be ended with
:	an ENDPATCH macro.
:
:	Using these macros will cause the patch number, author
:	area patched, and reason for patch to be output during assembly.
:	Also, a history table starting at PATHIS will be created with
:	16 (10hex) byte entries.
:	Each entry will contain the date and time of patch and the author.
:	Also, the ?VERNO DDT command will indicate that patches are
:	installed by reporting a version biased by 100 octal.
:	For example, if the version is 1.13, ?VERNO will report 101.13.
:
:	If a patch must be temporarily added by hand, the
:	history area and the version (cell VERREV) should be updated.
:
:	The following symbols may be defined before assemply of PATCH.LIB.
:	If not defined they will take the default listed.
:
:	VERSION release version number, will be ORed with octal 100.
:		default: 00
:	VERREV	area in seg 0E which contains a one byte version and
:		a one byte revision.  Defined by FINISH.LIB.
:		default: none, symbol must be defined.
:	A.ERR	defines segment to use for patch history area
:		default: seg 0
:	PATHIS	defines the start of the patch history area,
:		each entry will be 16 bytes as follows,
:		19yy/mmdd/hhmm/uname(10 chars 0 filled)
:		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
:		digit) and uname is in ASCII.
:		default: an area will be defined by this library
:	PHSIZE defines the length in bytes of the PATHIS area.
:		default: 140 hex
:	PATCH0	defines the start of a Segment 0 patch area.
:		default: an area will be defined by this library
:	P0SIZE defines the length in bytes of the PATCH0 area.
:		default: 200 hex
:	PATCH1	defines the start of a code segment  patch area.
:		default: an area will be defined by this library
:	P1SIZE defines the length in bytes of the PATCH1 area.
:		default: 400 hex
:	SEGn,SnSIZE	Must be defined for the area being patched when
:		the patch is made.
:
:	The following symbols are used by the patch macros.
:	They may be read by, but should not be modified by, a patch.
:
:	PAHPTR	pointer to the next available entry in PATHIS
:	PA0PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH0 area.  It starts out
:		equal to PATCH0 and is moved up after each patch in
:		the PATCH0 area.  Use of the symbol assumes that all
:		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
:	PA1PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH1 area.  It starts out
:		equal to PATCH1 and is moved up after each patch in
:		the PATCH1 area.  Use of the symbol assumes that all
:		patches from PATCH1 to PATCH1+P0SIZE will be done in order.
:	QPATS	current patch segment number
:	QPATB	starting address of current patch
:	QPATL	length of current patch
:	QPATA	0 IF PATCH IS IN PATCH0 AREA, 1 IF IN PATCH1, ELSE -1
:	PATACT	> 0 if when a patch is active.



::	PATCH(yymmdd,hhmm,uname,fba,lba1,len)	grab a patch area
:
:		yymmdd	Date patch written, if patch is modified in ANY
:		way this must be updated.
:		hhmm	Time patch written, current Cupertino time.
:		If patch is modified this also must be updated.
:		uname	ONTYME username of person who authored patch.
:		Personal name, not NETMID or NET3 or such.
:	fba	adress of start of patch
:	lba1	address of next byte after end of patch
:	len	length (default hex) of patch in bytes if lba1 is missing
:
:	CONPATCH(fba,lba1,len)	continue a patch in a new area
:		Similar to PATCH but moves to a new area, must be
:		preceeded by a PATCH statement.
:
:	ENDPATCH(comment)	End a PATCH started with PATCH call.
:
:		comment	Description of patch to be output during
:			assembly.  Commas should be preceeded by `.
:
:	Example:
:	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
:	  IF	HDLC&(LAPB!LAP)
:	PATCH(811009,1422,FRED,XROOM,,2)
:		LIS	R4,7
:	ENDPATCH(fix hdlc room checking routine)
:	  EI
:
:	:	PATCH TO FIX TRANSMITER BUG
:	PATCH(811009,1630,DDM,XSEND,XSE010)
:	  IF	FINACT	:IF INTERFRAME FILL TIMER ENABLED
:		J	PA1PTR
:	  EI
:	PATRTN	LR	R6,RSIO
:		AHI	R6,OUTSCT,RSIP
:
:	CONPATCH(PA1PTR,,0C)
:		SBT	RL,FRMTMT,,	:INDICATE FRAME TRANSMITTED
:		JNR	R7		:IF ALREADY TRANSMITTED
:		J	PATRTN		:RETURN TO PATCHED AREA
:	ENDPATCH(fix transmitter bug)

	GL	VERSIO,VERREV,A.ERR,PATHIS,PHSIZE,PATCH0,P0SIZE,PATCH1,P1SIZE
	GL	PAHPTR,PA0PTR,PA1PTR,QPATS,QPATB,QPATL,QPATA,PATACT

:	FIRST DEFINE SOME MACROS
	GL	.35.
.35.	EQ	$A 35
	KILL	.NE.
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-.35.]
	KILL	.GT.
.GT.	MACRO(P1,P2)[((P2)-(P1))^-.35.]

:	NEXT DEFINE SOME DEFAULTS
  IF	1-\A.ERR
A.ERR	EQ	0
  EI
  IF	1-\PHSIZE
PHSIZE	EQ	140
  ELSE
PHSIZE	EQ	(PHSIZE+0F)/10*10
  EI
  IF	1-\P0SIZE
P0SIZE	EQ	200
  EI
  IF	1-\P1SIZE
P1SIZE	EQ	400
  EI
  IF	1-\PATHIS
	SEG	A.ERR
PATHIS	HS	PHSIZE/2
  EI
  IF	1-\PATCH0
	SEG	0
PATCH0	HS	P0SIZE/2
  EI
  IF	1-\PATCH1
	SEG	A.CODE
PATCH1	HS	P1SIZE/2
  EI

PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA
PA0PTR	EQ	PATCH0	:INIT PTR TO START OF AREA
PA1PTR	EQ	PATCH1	:INIT PTR TO START OF AREA
PATACT	EQ	0	:FLAG NO PATCH ACTIVE
QPATA	EQ	-1	:CLEAR PATCH AREA FLAG
QPATS	EQ	-1
QPATB	EQ	-1
QPATL	EQ	-1

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
  IF	\VERSION
VERSION EQ	VERSION!$8100
  ELSE
VERSION EQ	$8100
  EI
	SEG	0E
	ORG	VERREV
	BC	VERSION
	SEG	A.CODE
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	A.ERR
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	(lba1)-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	(.+1)-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK  overflow <<<<%
  EI
	ORG	QPATB

::	CONPAT(fba,lba1,len)	CONTINUE A PATCH
	KILL	CONPAT
CONPAT	MACRO(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	(clba1)-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	.-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK overflow <<<<$
  EI
	ORG	QPATB

::	ENDPATCH(com)	End a patch - does error checking, outputs comment
	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD CONPATCH(cfba,clba1,clen) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1````c2````c3````c4````c5 >>>
]
]

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD PATCH(day,tim,usr,fba,lba1,len) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1``c2``c3``c4``c5 >>>
]
]
: (MATS.P2)FRONT2.04P
:    Copied by Mele from (MATS.P2)FRONT2.03R on 08/24/83.
:    ECHOTAB added as global.In ECHOTAB there is the address of
:    the echo table.Matching echo table it will be established
:    if a character has to be echoed or not.
:
: (MATS.P2)FRONT2.03R
:    Copied by Cheung from (MATS.P2)FRONT2.02B on 09/27/82.
:    Declared NGRP as global.

: (MATS.P2)FRONT2.02B
:    Copied by Beecher from (MATS.P2)FRONT2.01S on 4/14/82.
:    Do not echo control characters, except <CR> which echoes
:    as a <CR><LF>.
:
: (MATS.P2)FRONT2.01S
:    Copied by Gimnicher from (MATS.P2)FRONT2.LIB.  8-23-81
:    Fixed a bug just before label SPEC2.  It was the intent of FRONT.LIB
:    to escape characters with a value of 00 for port zero messages.
:    However, the way this routine was coded, this would never occur.
:    A call is made to GETCH just before the label SPEC2 to get a character.
:    The condition code is then checked to determine if the character is 00
:    in order for FRONT.LIB to escape it.  However, the last thing
:    GETCH does is bump the index, rather than loading the character.
:    Therefore 00 characters are never escaped.
:
:    It seems to be much cleaner to not escape 00 characters, so the code
:    has been changed to deliberately do this by commenting out the
:    condition code check, and the extra WCI.

: FRONT2.LIB COPIED FROM 
: (MATS.DEV)FRONT2.LIB 10/15/80

	SUBTTL	ISIS Front-end Package
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRONT.LIB

:		This package is the ISIS front end...used to service the
:	ISIS input and output rings, and to activate user code
:	whenever a break (user defined) is encountered.
:	It also activates user code when a user-processable
:	(also user defined) non-data message is encountered,
:	if excessive data is input without a break, or if a timeout
:	occurs for a port.

:			CONVENTIONS

:		Each of NPORT ports has a buffer-pair associated with it.
:	Even numbered buffers are input buffers...the corresponding
:	odd numbered buffer is that port's output buffer.  The user-
:	provided code should intialize these buffers.

:	A 0-byte in the buffer is an escape...it is followed by a
:	data-0, or by an ISIS message code and the appropriate
:	character stream following.  (This does NOT apply to needles,
:	and thus unassigned ports should be connected to an appropriate
:	process.  Needles are parsed, and the following usage applies on
:	activation <Needles ALWAYS activate>:
:		R5	Invoice number,
:		R6	Destination Host number,
:		R7	Originating Node number,
:		R8	Originating Host Number
:		R9	Originating Port number,
:		R10	Dialect Code
:		R11	TID
:		R12	number of characters in user name,
:			The username is placed into the port's buffer.)

:	Data breaks on C/R if no break array is specified.

:	Activation always occurs after the breaking data character
:	is placed into the buffer, or after a complete MESSAGE is
:	placed in the buffer.

:	Break is activated with the buffer index in R1, and links on R15.
:	R0 contains an activation key, and condition codes are set appropriately:
:	>0	R0 is message type
:	=0	data break...R2 contains the activation char
:	=-1	needle
:	=-2	too many chars
:	=-3	flushing...next will not necessarily be data
:	=-4	timout
:	=-5	port 0 message
:	ACTCHA  contains the activation character

:	All registers are available for use while in the user code, and
:	on return, R0 is to contain a number N.  If N>0, it is default timeout
:	(in seconds) until the next activation...else timeout is disabled.
:	All data characters are automatically placed in the input buffer,
:	as are any control messages specified for user-handling.

:	ALL ISIS special messages are placed in the buffer for port 0,
:	and each breaks automatically.

:	For non-text messages, the escape convention applies ONLY to the
:	message type...the body of the message is unescaped.  ALL such
:	messages handled by the user cause a break.

:	The following WORD arrays (length NPORT words), and are to be initalized
:	by the user program:

:	BREAK	a pointer to the bit array of characters to break upon.
:	MBREAK	a pointer to the bit array of message types to break on.
:	PROCESS	a pointer to the process to be activated upon a break condition.

:	The following items are to be provided by the user:

:	A bit array TISIS of length NPORT, to signal output data.
:	A symbol MAXCHAR...causes break if the buffer count exceeds this value.
:	A symbol ECHO...causes tymsat echoing for terminals if >0.

:	the following routines should be called by the user (link R0):

:	IZFRONT	at initialization time, after calling IZT.
:	INPUT	from exec loop, to process input from ISIS.
:	OUTPUT	from exec loop, to process output to ISIS.

:IF PARS2 DEFINE GLOBALS FOR TIMEOUT ACTIVATION
        IF      PARS.2
        GL      P2U,AUBARB,AUBTYP,LUDNUR,RBCTO
        EI

        GL      NGRP
	GL	NPORT,MAXCHAR,ECHO,TISIS,BREAK,MBREAK,PROCESS,ACP
	GL	ECHOTB,ACTCHA
	GL	IZFRONT,INPUT,OUTPUT
	GL	TOPUT,TORET
	GL	GCI,WCI,BCT

	MO	.,FRONT

        GL      PARS.2

	SEG	A.DATA

BREAK	HS	2*NPORT		:pointer to data break array
ECHOTB	HS	2*NPORT		:pointer to echo character array
MBREAK	HS	2*NPORT		:pointer to message break array
PROCESS	HS	2*NPORT		:pointer to user supplied routine to process data.
ATIME	HS	2*NPORT		:next time to activate user.
XLIMIT	BS	NPORT		:max number of data characters we can send at one time.
ACTCHA	BS	1		:activation character
PORT	HS	1		:CURRENT PORT WE ARE PROCESSING
BUFFER	HS	1		:CURRENT BUFFER INDEX WE ARE PROCESSING.
SAVE	HS	20		:save registers here
RETP	HS	2		:save return here.

NGRP	EQ	(NPORT+0F)/10	:number of port groups to process.
ACP	HS	NGRP		:active ports.
PTIME	HS	NGRP		:ports on activate timeout.
TOISIS	HS	NGRP		:ports we can send data on.
FRISIS	HS	NGRP		:ports we have NOT backpressured.
DEM	HS	NGRP		:ports in defered echo mode.
GBALL	HS	NGRP		:HAVE A GREEN-BALL FOR THESE PORTS
PRTSVC	HS	1		:PORT ELIGIBLE FOR SERVICE INDICATOR
FRNTSV  WS      $A18            :SVE AREA FOR IMATS STANDARD CALL

	SEG	A.CODE		:THE CODE AND DATA AREA.
 
:	HANDY INDEXABLE HALFWORD BIT MASKS
HMASK	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1


:	DEFAULT BREAK ARRAY (CARRIAGE RETURN ONLY)
DEFAULT	HC	4,0,0		:C/R ONLY
	HC	0,0,0
	HC	0,0,4		:C/R ONLY
	HC	0,0,0
	HC	0,0,0
	HC	0

:	-----	ISIS INTERFACE	-----

:	BIT ARRAY TO IDENTIFY DATA MESSAGES
BDATA	HC	07FFF,-1,-1	:00
	HC	-1,-1,-1	:30
	HC	-1,-1,-1	:60
	HC	0FFFC,0,0	:90
	HC	0,0,0		:C0
	HC	0		:F0

BCTL	HC	0,0,0		:00	BIT ARRAY TO IDENTIFY CONTROL MESSAGES REQUIRING SPECIAL HANDLING
	HC	0,0,0		:30
	HC	0,0,0		:60
	HC	3,0F000,3140	:90  9E, 9F, A0, A1, A2, A3, B2, B3,B7, B9
	HC	0,0,0		:C0
	HC	0		:F0


LENGTH	BC	0		:MESSAGE LENGTH TABLE
	RE	9D;	BC	.-LENGTH+1;	NOLIST;	ER;	LIST	:DATA TEXT STRINGS
	BC	1		: 9E	DETACH
	BC	1		: 9F	DISCONNECT
	BC	1		: A0	APPLY BACKPRESSURE
	BC	1		: A1	RELEASE BACKPRESSURE
	BC	1		: A2	FLUSH FORWARD
	BC	1		: A3	FLUSH BACKWARD
	BC	1		: A4	BLACK BALL
	BC	1		: A5	GREY BALL
	BC	1		: A6	ENTER "DEM"
	BC	1		: A7	LEAVE "DEM"
	BC	1		: A8	ENTER "TRANSPARENCY"
	BC	1		: A9	LEAVE "TRANSPARENCY"
	BC	1		: AA	GREEN BALL
	BC	1		: AB	RED BALL
	BC	1		: AC	YELLOW BALL
	BC	1		: AD	ORANGE BALL
	BC	1		: AE	"BREAK" DETECTED
	BC	1		: AF	"HANG UP"
	BC	2		: B0	QUERY TERMINAL PARAMETER
	BC	3		: B1	SET TERMINAL PARAMETER
	BC	4		: B2	PSEUDO-NEEDLE
	BC	2		: B3	LOGON CHARACTER
	BC	2		: B4	NORMAL LOGON STATUS
	BC	2		: B5	LOGON FAILURE
	BC	8		: B6	SUCCESSFUL LOGON FROM THIS PORT
	BC	6		: B7	ADDENDUM TO ACCOUNTING
	BC	1		: B8	SUPER-"HANG UP"
	BC	2		: B9	TRANSMIT LIMIT

:		**INTERFACE DATA TYPES**


NEDMSG	EQ	0		:NEEDLE
FIRST	EQ	9E		:FIRST MESSAGE IN LIST
DETMSG	EQ	9E		:DETACH MESSAGE
ZAPMSG	EQ	9F		:DISCONNECT MESSAGE
NOSMSG	EQ	0A0		:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1		:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2		:FLUSH OUTPUT
BKGMSG	EQ	0A3		:FLUSH INPUT
BLKMSG	EQ	0A4		:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5		:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6		:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7		:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8		:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9		:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA		:GREEN BALL
RBMSG	EQ	0AB		:RED BALL
YBMSG	EQ	0AC		:YELLOW BALL
OBMSG	EQ	0AD		:ORANGE BALL
BRKMSG	EQ	0AE		:BREAK DETECTED
HNGMSG	EQ	0AF		:HANG UP
QTPMSG	EQ	0B0		:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1		:SET TERMINAL PARAMETER
PNDMSG	EQ	0B2		:PSEUDO NEEDLE
NLOGCH	EQ	0B3		:NORMAL LOGON CHAR
NLOGST	EQ	0B4		:NORMAL LOGON STATUS
LOGFAL	EQ	0B5		:NORMAL LOGON STATUS
LOGOK	EQ	0B6		:SUCCESSFUL NORMAL LOGON
ADACTG	EQ	0B7		:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8		:SUPER-HANG UP
MAXTYP	EQ	0B9		:MAXIMUM TYPE DEFINED

:	INPUT FROM ISIS
INPUT	ST	R0,RETP		:SAVE RETURN
INPUT1	JAL	R4,LOOK		:IS THERE ANYTHING THERE?
	J	RET		:NORMAL RETURN...JUST EXIT
	LR	R12,R1		:SET BREAK # 0, EXCEPT FOR PORT 0
	JN	INPUT2		:SKIP IF NOT PORT 0
	JAL	R4,GETH		:PORT 0---SPECIAL
	EXBR	R5,R0		:GET CODE
	LBR	R5,R5
	LR	R5,R5		:CHECK FOR MESSAGE 0
	JE	SPEC4		:IGNOR IF SO
	LB	R7,SPECL,R5	:GET MESSAGE REMAINDER LENGTH
	THI	R7,80		:80 FLAG MEANS WE HAVE NO BUSINESS GETTING THESE...
	JEFS	SPEC0
	JAL	R10,CRASH	:CRASH IF WE DO

SPEC0	LR	R5,R0		:COPY MESSAGE
	JAL	R6,PAIR		:ELSE PLACE MESSAGE TYPE IN BUFFER 0
SPEC1	SIS	R7,1		:ANY MORE
	JLEFS	SPEC3
	JAL	R4,GETCH	:YES
:JNFS	SPEC2		:TEST IF CHARACTER SHOULD BE ESCAPED
:JAL	R4,WCI		:ESCAPE IT

: Look at description at top of file for explanation as to why the top
: two statements have been commented out.  Port 0 messages will never
: be escaped.

SPEC2	JAL	R4,WCI
	JBS	SPEC1
SPEC3	LCS	R0,5		:DONE...SET PORT 0 MESSAGE CODE
	JAL	R4,ACTIV
SPEC4	JAL	R4,ELIR		:DONE...END LOGICAL INPUT RECORD
	J	INPUT1		:AND CONTINUE

SPECL	BC	0,0,0,86,88,85,5,88	:LENGTH OF SPECIAL (PORT 0) MESSAGES
	BC	88,4,87,4,87,80,80	:"80" MEANS TO CRASH

INPUT2	STH	R1,PORT		:SAVE ISIS PORT NUMBER
	SLHLS	R1,2
	STH	R1,BUFFER
	JAL	R4,GETCH	:SKIP OVER MESSAGE TYPE
	TBT	R0,BDATA	:IS THIS DATA MESSAGE?
	JE	INCONT		:NO...SKIP TO PROCESS CONTROL

:	TEXT MESSAGE...PASS TO BUFFER, ACTIVATE IF TOO MANY CHARS, BREAK CHAR
	LR	R5,R0		:YES...SAVE COUNT OF CHARS
	L	R10,BREAK,R1	:GET POINTER TO PORT'S BREAK TABLE
	JNFS	INDAT1		:SKIP IF NOT NULL
	LA	R10,DEFAULT	:ELSE SET DEFAULT
	ST	R10,BREAK,R1
INDAT1	JAL	R4,GETCH
	LR	R0,R0		:GET AND TEST A CHAR
	JNFS	INDAT2		:SKIP IF NOT NULL
	JAL	R4,WCI		:ESCAPE ALL ZEROS
INDAT2  JAL     R4,WCI          :copy the char to input buffer
	LHL	R4,PORT
	TBT	R4,DEM		:ARE WE TO DO ECHOING?
	JE  	INDAT4		:SKIP IF NOT
	L	R11,ECHOTB,R1,	:Address of echo table in R11
	TBT	R0,0,R11	:Match character in echo table
	JE	INDAT4		:Is the character to be echoed?
	AIS	R1,2		:Yes
	NHI	R0,$0 7F	:Knock off the high order bit
	CHI	R0,$00D		:Is it a CR
	IFF(E,THEN)
	  JAL	R4,WCI		:Yes, echo CR
	  LHI	R0,$0 8A	:Add LF
	  JAL	R4,WCI		:Echo
	  LHI	R0,$0 8D	:Put the CR back in R0
	ORELSE
	  JAL   R4,WCI		:Echo character
	ENDIF
        SIS     R1,2
INDAT4	TBT	R0,0,R10	:CHECK IF BREAK CHAR
	JEFS	INDAT5
	LR	R2,R0		:OK...WE'VE GOT A BREAK CHAR...PASS IT ON IN R2
	LIS	R0,0		:SET BREAK ACTIVATION CODE
	JAL	R4,ACTIV	:GO ACTIVATE JOB
INDAT5	SIS	R5,1
	JG	INDAT1		:REPEAT FOR ALL CHARS
	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R0,BCT,R1	:CHECK BUFFER SIZE
	CLHI	R0,MAXCHAR
	JL	INPUT1		:CONTINUE IF FULL
:	SEND BACKPRESSURE FOR THIS PORT
	LHL	R1,PORT		:GET PORT NUMBER
	RBT	R1,FRISIS	:SET BACKPRESSURE INDICATOR
	LIS	R0,3		:GENERATE BP MESSAGE
	LHI	R2,NOSMSG	:
	JAL	R4,SLOR		:START THE MESSAGE
	JAL	R4,ELOR		:END IT
	SLHLS	R1,2		:CONVERT BACK TO BUFFER NUMBER
	LCS	R0,2		:IF EXCEEDED, BREAK NOW
	JAL	R4,ACTIV	:ACTIVATE PORT PROCESS..CODE -2
	J	INPUT1		:THEN PROCESS ANOTHER RECORD

:	NOT DATA...PROCESS IT
INCONT	LR	R3,R0		:COPY MESSAGE TYPE
	JN	INCON		:SKIP IF NOT NEEDLE
	JAL	R4,GETCH	:NEEDLE...SKIP LENGTH
	JAL	R4,GETW;	LR	R5,R0		:INVOICE NUMBER
	JAL	R4,GETH;	LR	R6,R0		:DESTINATION HOST
	JAL	R4,GETH;	LR	R7,R0		:SOURCE NODE
	JAL	R4,GETH;	LR	R8,R0		:SOURCE HOST
	JAL	R4,GETH;	LR	R9,R0		:SOURCE PORT
	JAL	R4,GETW		:EXPANSION
	JAL	R4,GETH;	LR	R10,R0		:DIALECT
	JAL	R4,GETCH;	LR	R11,R0		:TID
	JAL	R4,GETCH;	LR	R12,R0		:CHARACTERS IN USER NAME
	LR	R13,R0		:SAVE A COPY FOR US TO COUNT WITH
NEEDLE	JAL	R4,GETCH
	JAL	R4,WCI		:MOVE A CHARACTER
	SIS	R13,1
	JGBS	NEEDLE		:REPEAT UNTIL DONE
	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LCS	R0,1		:SET NEEDLE CODE..-1
	JAL	R4,ACTIV	:ACTIVATE USER CODE
	IF	ECHO
:		TYMSAT SHOULD ECHO
	THI	R11,1F		:CHECK FOR TERMINAL
	JE	NEED1		:SKIP IF NOT
	LHL	R1,PORT
	THI	R11,20		:CHECK IF HALF DUPLEX TID
	JNFS	NEED0		:DON'T SET DEM IF SO
	SBT	R1,DEM
NEED0	RBT	R1,GBALL	:SET TO CORRECT INITIAL STATE
	LIS	R0,5
	LHI	R2,STPMSG
	JAL	R4,SLOR		:SET ECHO ON
	LIS	R0,0
	JAL	R4,PUTCH
	LIS	R0,1
	JAL	R4,PUTCH
	JAL	R4,ELOR
	EI
NEED1	LHL	R1,PORT
	LHI	R0,FIRST-1	:SET UP TRANSMIT LIMIT FOR PORT
	STB	R0,XLIMIT,R1
	SBT	R1,ACP		:SET THE PORT ACTIVE
	SBT	R1,TOISIS	:CLEAR BACKPRESSURES
	SBT	R1,FRISIS
	J	INPUT1		:GO BACK FOR MORE INPUT

:	NOT A NEEDLE...DOES USER WANT TO PROCESS MESSAGE?
INCON	L	R10,MBREAK,R1	:POINTER TO MESSAGE BREAK TABLE
	JE	INCTL		:IGNOR IF NULL
	TBT	R0,0,R10	:DOES HE WANT TO HANDLE IT?
	JE	INCTL		:NO...WE'LL DO IT
	LR	R5,R0		:HE WANTS TO
	LHL	R4,BCT,R1	:CHECK IF BUFFER IS EMPTY
	JEFS	INCON1		:SKIP IF SO
	LCS	R0,3		:ELSE GIVE A CHANCE TO FLUSH IT
	JAL	R4,ACTIV
INCON1	JAL	R6,PAIR		:FIRST PLACE ESCAPED MESSAGE TYPE
	LB	R7,LENGTH,R5
INCON2	SIS	R7,1
	JLEFS	INCON3		:SKIP WHEN DONE
	JAL	R4,GETCH
	JAL	R4,WCI		:COPY A CHAR
	JBS	INCON2		:MOVE AS MANY AS NECESSARY
INCON3	LR	R0,R5		:SET MESSAGE TYPE (CODE>0)
	JAL	R4,ACTIV	:ACTIVATE USER
	TBT	R5,BCTL		:DO WE WANT TO PROCESS THIS TOO?
	JNFS	INCON4		:SKIP IF SO
	JAL	R4,ELIR		:ELSE END LOGICAL INPUT RECORD
	J	INPUT1		:THEN GO BACK FOR ANOTHER RECORD

INCON4	JAL	R4,LOOK		:WE WANT TO LOOK TOO...BACK UP
	JAL	R10,CRASH	:ERROR IF WE TAKE THIS RETURN
	JAL	R4,GETCH	:GET THE MESSAGE AGAIN
	LR	R3,R0		:COPY IT


:	PROCESS THE MESSAGE OURSELVES
INCTL	SLHLS	R3,2		:MAKE A WORD INDEX
	J	IFAN-(4*FIRST),R3	:AND GO PROCESS MESSAGE

:	INPUT FANOUT FOR SPECIAL PROCESSING
IFAN	J	ZAP		:9E - ZAPPER
	J	ZAP		:9F - DISCONNECT
	J	NOSEND		:A0 - APPLY BACK-PRESSURE
	J	RESEND		:A1 - RELEASE BACK-PRESSURE
	J	GOBBLE		:A2 - FLUSH FORWARD
	J	FLBACK		:A3 - FLUSH BACKWARD
	J	OB		:A4 - DATA LOST IN THIS DIRECTION
	J	TOSS		:A5 - DATA LOST IN OTHER DIRECTION
	J	EDEM		:A6 - ENTER DEFERED ECHO MODE
	J	LDEM		:A7 - LEAVE DEFERED ECHO MODE
	J	TOSS		:A8 - ENTER TRANSPARENCY
	J	TOSS		:A9 - LEAVE TRANSPARENCY
	J	GB		:AA - GREEN BALL
	J	RB		:AB - RED BALL
	J	OB		:AC - YELLOW BALL
	J	TOSS		:AD - ORANGE BALL
	J	TOSS		:AE - BREAK DETECTED
	J	TOSS		:AF - HANG UP
	J	TOSS		:B0 - QUERY TERMINAL PARAMETER
	J	TOSS		:B1 - SET TERMINAL PARAMETER
	J	PNEED		:B2 - PSEUDO NEEDLE
	JAL	R10,CRASH	:B3 - LOGON CHAR---WE SHOULDN'T GET THESE!
	J	TOSS		:B4 - NORMAL LOGON STATUS
	J	TOSS		:B5 - LOGON FAILURE
	J	TOSS		:B6 - SUCCESSFUL LOGON
	JAL	R10,CRASH	:B7 - ADDENDUM TO ACCOUNTING---WE SHOULDN'T GET THESE
	J	TOSS		:B8 - SUPER-HANG UP
	J	XLIM		:B9 - TRANSMIT LIMIT


:	TOSS A MESSAGE
TOSS	LB	R0,LENGTH,R2	:PICK UP MESSAGE LENGTH
	SIS	R0,1		:WE'VE ALREADY GOTTEN MESSAGE TYPE
	JAL	R4,FLUSH	:DELETE REMAINDER OF MESSAGE
	J	INPUT1		:AND CONTINUE

:	DISCONNECT
ZAP	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,BUFFER	:GET BUFFER NUMBER
	JAL	R4,EMPTY	:EMPTY INPUT BUFFER
	AIS	R1,2
	JAL	R4,EMPTY	:EMPTY OUTPUT BUFFER
	LHL	R1,PORT
	RBT	R1,ACP		:SET PORT NOT ACTIVE
	RBT	R1,DEM		:NOT IN DEM
	RBT	R1,GBALL	:NO GREEN BALLS
	J	INPUT1

:	APPLY BACKPRESSURE
NOSEND	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,PORT		:TURN IT OFF FOR PORT
	RBT	R1,TOISIS
	J	INPUT1		:AND CONTINUE

:	RELEASE BACKPRESSURE
RESEND	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,PORT
	SBT	R1,TOISIS	:TURN IT ON FOR PORT
	J	INPUT1

:	GOBBLER
GOBBLE	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,BUFFER
	JAL	R4,EMPTY	:EMPTY INPUT BUFFER
	LHL	R1,PORT
	SBT	R1,FRISIS	:CHECK IF WE'VE APPLIED BACKPRESSURE
	JN	INPUT1		:CONTINUE IF NOT
	LIS	R0,3		:ELSE RELEASE IT
	LHI	R2,SNDMSG
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	J	INPUT1		:AND CONTINUE

:	FLUSH BACKWARD
FLBACK	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,BUFFER
	AIS	R1,2		:COMPUTE OUTPUT BUFFER
	JAL	R4,EMPTY	:EMPTY IT
	LIS	R0,3
	LHL	R1,PORT
	LHI	R2,GOBMSG	:SEND GOBBLER IN OTHER DIRECTION
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	J	INPUT1		:DO ANOTHER MESSAGE

:	ENTER DEM
EDEM	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,PORT
	SBT	R1,DEM		:SET DEM
	J	INPUT1		:AND DO ANOTHER

:	LEAVE DEM
LDEM	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,PORT
	RBT	R1,DEM		:CLEAR DEM
	J	INPUT1		:AND DO ANOTHER

:	GREEN BALL
GB	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,PORT		:GET PORT NUMBER
	LHL	R2,BUFFER	:GET BUFFER NUMBER
	LHL	R0,BCT+2,R2	:CHECK IF OUTPUT BUFFER IS EMPTY
	JEFS	GB1		:SKIP IF SO
	SBT	R1,GBALL	:NOT EMPTY...SET FLAG
	J	INPUT1
GB1	LIS	R0,3		:EMPTY...RETURN GREEN BALL
	LHI	R2,GBMSG
	JAL	R4,SLOR
	JAL	R4,ELOR		:SEND GREEN BALL BACK
	J	INPUT1

:	RED BALL
RB	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,PORT		:GET PORT NUMBER
	RBT	R1,GBALL	:ARE WE HOLDING A GREEN BALL?
	JEFS	RB1		:SKIP IF NOT
	LIS	R0,3		:YES...RETURN IT FIRST
	LHI	R2,GBMSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	LHI	R2,RBMSG	:RESTORE THE RED BALL MESSAGE
RB1	LIS	R0,3
	JAL	R4,SLOR
	JAL	R4,ELOR
	J	INPUT1		:AND PROCESS NEXT MESSAGE

:	ORANGE (OR BLACK) BALL
OB	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LIS	R0,3
	LHL	R1,PORT		:GET PORT NUMBER
	AIS	R2,1		:SET OTHER BALL OF PAIR
	JAL	R4,SLOR
	JAL	R4,ELOR		:SEND IT BACK
	J	INPUT1		:AND CONTINUE

:	 PSEUDO-NEEDLE
PNEED	LB	R0,LENGTH,R2	:JUST TOSS IT
	SIS	R0,1
	JAL	R4,FLUSH
	J	NEED1		:THEN SET UP PARAMETERS

:	TRANSMIT LIMIT
XLIM	JAL	R4,GETCH		:GET RESTRICTION
	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	LHL	R1,PORT
	LBR	R0,R0		:EXTRACT VALUE
	CLHI	R0,FIRST-1	:RANGE CHECK
	JLFS	XLIM1
	LHI	R0,FIRST-1
XLIM1	STB	R0,XLIMIT,R1	:SET UP RESTRICTION
	J	INPUT1


:	OUTPUT TO ISIS

OUTPUT	ST	R0,RETP
	LHI	R12,(NGRP-1)*2
OUT0	LCS	R1,1		:SET UP MASK OF SERVICED PORTS
	STH	R1,PRTSVC	:SAVE PORT SERVICED MASK
OUT1	LHL	R1,ACP,R12	:ACTIVE PORT
	NH	R1,TISIS,R12	:WITH DATA PRESENT
	NH	R1,TOISIS,R12	:AND NOT BACKPRESSURED
	NH	R1,PRTSVC	:AND NOT ALREADY SERVICED
	JNFS	OUT2		:SERVICE IF ANYTHING TO DO
	SIS	R12,2		:REPEAT FOR ALL GROUPS
	JGEBS	OUT0
	J	RET		:THEN EXIT
OUT2	JAL	R3,BIDH
	LR	R1,R12		:CONSTRUCT INTERNAL PORT NUMBER
	SLHLS	R1,3
	AR	R1,R2
	RBT	R2,PRTSVC	:CLEAR PORT TO BE SERVICED BIT
	STH	R1,PORT
	SLHLS	R1,2		:MAKE BUFFER NUMBER
	AIS	R1,2
	STH	R1,BUFFER
	JAL	R4,GCI		:PEEK AT NEXT CHAR
	LR	R5,R0
	JNFS	OUT3		:SKIP IF NOT AN ESCAPE
	JAL	R4,GCI		:ELSE GET ESCAPED CHAR
	LR	R5,R0		:SAVE COPY
	JN	OUT7		:SKIP IF NOT A "0"

:	WE HAVE DATA...CONSTRUCT A DATA MESSAGE
OUT3	LHL	R1,PORT
	LB	R6,XLIMIT,R1	:LIMIT OF CHARS WE CAN SEND AT ONCE
	LHI	R0,3,R6		:HOW BIG THE RECORD WILL BE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	LR	R0,R5		:SEND FIRST CHAR
OUT4	JAL	R4,PUTCH	:SEND CHAR
	LHL	R1,BUFFER	:GET ANY FURTHER CHARS FROM BUFFER
	SIS	R6,1
	JGFS	OUT6		:DON'T MAKE MESSAGE TOO BIG
OUT5	JAL	R4,ELODR	:BIG ENOUGH...STOP NOW
        LHL     R1,BUFFER       : RESTORE BUFFER INDEX
	J	OUT10
OUT6	LH	R0,BCT,R1	:CHECK STATE OF BUFFER
	JLEBS	OUT5		:QUIT NOW IF BUFFER IS EMPTY
	JAL	R4,GCI		:OK...LOOK AT NEXT CHAR
	LR	R5,R0
	JN	OUT4		:NOT ESCAPED, SO SEND IT ON
	JAL	R4,GCI		:ESCAPED...LOOK AT NEXT
	LR	R5,R0		:COPY IT
	JE	OUT4		:PASS IF DATA
	JAL	R4,ELODR	:END LOGICAL OUTPUT DATA RECORD

:	WE GOT A CONTROL MESSAGE
OUT7	LB	R6,LENGTH,R5	:COPY IT
	LHI	R0,2,R6		:...TO THE ISIS BUFFER TOO
	LHL	R1,PORT
	LR	R2,R5
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	LHL	R1,BUFFER	:GET ANY SUBSEQUENT CHARS FROM BUFFER
OUT8	SIS	R6,1		:COPY THE WHOLE MESSAGE
	JLEFS	OUT9		:NO MORE...SKIP
	JAL	R4,GCI		:COPY ANOTHER CHAR OF MESSAGE
	JAL	R4,PUTCH
	JBS	OUT8		:AND GO BACK FOR ANY MORE
OUT9	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	SHI	R5,DETMSG	:CHECK IF CIRCUIT ZAPPER
	JLFS	OUT10		:SKIP IF NOT
	SIS	R5,ZAPMSG-DETMSG
	JGFS	OUT10
	LHL	R5,PORT		:YES...CLEAN UP
	RBT	R5,ACP
OUT10	LHL	R0,BCT,R1	:CHECK FOR EMPTY BUFFER
	JN	OUT1		:GO ON TO NEXT PORT IF NOT
	LHL	R1,PORT
	RBT	R1,GBALL	:ARE WE HOLDING A GREEN BALL?
	JE	OUT1		:NO...GO ON
	LIS	R0,3
	LHI	R2,GBMSG
	JAL	R4,SLOR
	JAL	R4,ELOR		:BUFFER IS NOW EMPTY...RETURN GREEN BALL
	J	OUT1		:REPEAT FOR NEXT PORT

:	SEND A CHAR PAIR
:	R5 = CHAR PAIR
:	R6 = LINK
PAIR	EXBR	R0,R5		:FIRST CHAR
	JAL	R4,WCI
	LBR	R0,R5		:SECOND CHAR
	JAL	R4,WCI
	JR	R6		:AND RETURN


:	GENERAL RETURN ROUTINE
RET	L	R0,RETP		:EXIT FOR SEVERAL ROUTINES
	JR	R0


        IF      PARS.2
:
:       THIS ROUTINE CHECKS FOR A TIME OUT VALUE FROM THE ACTIVE RES
:       BLOCK IF THE USER IS A NORMAL USER (LUDNUR), AND SETS UP
:       A TIME OUT IF THE VALUE IS GREATER THAN ZERO.
:
:	GENERAL ROUTINE TO ACTIVATE A PROCESS
:	LINK ON R4
ACTIV	STM	R1,SAVE
	L	R15,PROCESS,R1	:LOCATE PROCESS
	JNFS	ACTIV1
	JAL	R10,CRASH	:NONE...CRASH
	BC	0,0,4*R4,10	:CRASH TYPE 10
ACTIV1  LA      R14,FRNTSV      :SET UP SIMULATED IMATS 'CALL'
        LR      R0,R0           :OK...SET CONDITION CODES
	STB	R2,ACTCHA	:STORE ACTIVATION CHARACTER
	JALR	R15,R15		:NOW GO THERE

	L 	R1,SAVE		:RESTORE R1 = PORT # * 4
        JE      ACTIV3          :IGNORE TIME OUT ON PORT 0
	LR	R0,R0
	JG	ACTIV2		:SKIP IF TO ACTIVATE ON TIMEOUT
        L       R2,P2U,R1       :AUB/AMT POINTER
        LB      R3,AUBTYP,R2    :USER TYPE
        CLHI    R3,LUDNUR       :CHECK FOR NORMAL USER
        JNFS    ACTIV3          :IGNORE TIME OUT IF NOT NORMAL USER
        L       R3,AUBARB,R2    :GET ACTIVE RES BLOCK
        LHL     R0,RBCTO,R3     :COMMAND TIME OUT IN SECONDS
        JGFS    ACTIV2          :TO ACTIVATE ON TIMEOUT
ACTIV3
        LM      R1,SAVE         :RESTORE REGISTERS
	LHL	R0,PORT		:ELSE TURN OFF ACTIVATION ON TIMEOUT
	RBT	R0,PTIME
	JR	R4		:AND RETURN
ACTIV2	A	R0,SLOWC,,	:SET UP TIMEOUT
	ST	R0,ATIME,R1
	LHL	R0,PORT
	SBT	R0,PTIME
        LM      R1,SAVE         :RESTORE REGISTERS
	JR	R4		:AND RETURN

        ELSE
:
:       NOT PARS2 -
:	GENERAL ROUTINE TO ACTIVATE A PROCESS
:	LINK ON R4
ACTIV	STM	R1,SAVE
	L	R15,PROCESS,R1	:LOCATE PROCESS
	JNFS	ACTIV1
	JAL	R10,CRASH	:NONE...CRASH
	BC	0,0,4*R4,10	:CRASH TYPE 10
ACTIV1  LA      R14,FRNTSV      :SET UP SIMULATED IMATS 'CALL'
        LR      R0,R0           :OK...SET CONDITION CODES
	JALR	R15,R15		:NOW GO THERE
	LM	R1,SAVE		:RESTORE REGS
	LR	R0,R0
	JGFS	ACTIV2		:SKIP IF TO ACTIVATE ON TIMEOUT
	LHL	R0,PORT		:ELSE TURN OFF ACTIVATION ON TIMEOUT
	RBT	R0,PTIME
	JR	R4		:AND RETURN
ACTIV2	A	R0,SLOWC,,	:SET UP TIMEOUT
	ST	R0,ATIME,R1
	LHL	R0,PORT
	SBT	R0,PTIME
	JR	R4		:AND RETURN


        EI


:	INITIALIZE
IZFRONT	ST	R0,RETP		:SAVE RETURN
	LHI	R1,NPORT-1
IZF1	RBT	R1,PTIME	:CANCEL OUTSTANDING TIMEOUTS
	SBT	R1,TOISIS	:CANCEL ALL BACK-PRESSURE
	SBT	R1,FRISIS
	RBT	R1,ACP		:PORT NOT ACTIVE
	SIS	R1,1
	JGEBS	IZF1		:DO FOR ALL
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,HS		:PUT HALFSECOND LOGIC ON TIMEOUT
	LHI	R1,RATE/2,R7
	JAL	R5,TOPUT
	LA	R0,ONESEC	:PUT ONE SECOND LOGIC ON TIMEOUT
	LHI	R1,RATE,R7
	AHI	R1,RATE		:START ONE SECOND FROM NOW
	JAL	R5,TOPUT
	J	RET		:AND EXIT


:	HALF SECOND PROCESSERS
HS	AHI	R1,RATE/2
	JAL	R5,TOPUT	:RUN AGAIN IN ABOUT A HALF SECOND

:	CHECK ALL BUFFERS FOR BACKPRESSURE APPLIED, RELEASE WHERE POSSIBLE
	LHI	R5,(NGRP-1)*2
	LHI	R6,(NGRP-1)*10
HS1	LCS	R7,1
	XH	R7,FRISIS,R5	:BACKPRESSURE APPLIED
	NH	R7,ACP,R5	:AND PORT ACTIVE
HS2	LR	R1,R7
	JNFS	HS3		:SOMETHING TO DO
	SIS	R5,2		:END OF A RING GROUP
	SHI	R6,10
	JGEBS	HS1		:NEXT RING GROUP
	J	TORET

HS3	JAL	R3,BIDH		:DETERMINE WHICH PORT ON GROUP MAY NEED SERVICE
	XH	R7,HMASK,R2,R2	:MARK PORT AS SERVICED
	AR	R2,R6
	LR	R1,R2		:SAVE COPY OF PORT #
	SLHLS	R2,2		:BUFFER NUMBER
	LH	R0,BCT,R2	:CONTENTS OF INCOMING BUFFER
	SHI	R0,MAXCHAR
	JG	HS2		:NOT YET
        SBT     R1,FRISIS
	LIS	R0,3		:3 BYTE MESSAGE
	LHI	R2,SNDMSG	:RELEASE BACKPRESSURE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	J	HS2		:AND PROCEED


:	ONE SECOND LOGIC
ONESEC	AHI	R1,RATE
	JAL	R5,TOPUT	:DO AGAIN IN ANOTHER SECOND
	LHI	R15,(NGRP-1)*2	:SEARCH BY GROUPS
OS1	LH	R14,ACP,R15	:ACTIVE PORT
	NH	R14,PTIME,R15
	JNFS	OS3		:SKIP IF ANY TO DO
OS2	SIS	R15,2
	JGEBS	OS1		:REPEAT FOR ALL GROUPS
	J	TORET		:THEN EXIT

OS3	LR	R1,R14		:COPY MASK OF PORTS TO PROCESS
	JEBS	OS2		:NONE...GO ON TO NEXT GROUP
	JAL	R3,BIDH
	XH	R14,HMASK,R2,R2	:SET IT EXAMINED
	LR	R1,R15
	SLHLS	R1,3		:MAKE PORT # (ALLOW FOR COUNT BY 2'S)
	AR	R1,R2
	STH	R1,PORT
	SLHLS	R1,2		:MAKE BUFFER NUMBER
	STH	R1,BUFFER
	L	R0,ATIME,R1	:CHECK IF TIMEOUT HAS EXPIRED
	S	R0,SLOWC,,
	JG	OS3		:NO...IGNOR FOR NOW
	LCS	R0,4		:YES...SET ACTIVATION DUE TO TIMEOUT
	JAL	R4,ACTIV	:AND ACTIVATE PORT
	J	OS3		:AND GO DO ANOTHER


	EM

:(MATS.P2)SEG0.S01
:       Copied by chen from (mats.p2)seg0.01c
:       defined symbols: WILDCH used by sign_off, template for fields in RESAAA
:(TIGERDEV)SEG0.01C
:       Copied by Chen from (TEST.INA)SEG0.31C on 6/14/85
:       Made a new directory for Flying Tiger project.
:
:(TEST.INA)SEG0.31C
:       copied by chen from (mats.p2)seg0.30P on 5/31/85
:       Added two error counter for hardcopy with C1,C2 supported terminal
:       ERHDLA,ERHDER
:
: -------------------------------------------------------
: (STEVEG)SEG0.03S copied from (STEVEG)SEG0.01S on 10-13-80
: by Steve Gimnicher in order to add variables needed for Monitor
: Screen Formatter implementation.
:
	RA	$0 0A
	SEG	0
CMDLEN  EQ      MAXCHAR+1       :COMMAND STORAGE AREA SIZE
        GL      NGRP

FLAGS   HS      (NBUF+10)/10    :BIT ARRAY AT LEAST NBUF+1 BITS.
TISIS   HS      NGRP            :BITS FOR DATA TO ISIS.
FISIS   HS      NGRP            :BITS FOR DATA FROM ISIS.

	ORG	(.+1)/2*2	:HALFWORD ALIGNMENT

:FB.AAA; DEFDEF(FB.AAA,1)  :IF FB.AAA NE 0, CERTAIN CODE WILL BE ASSEMBLED.
                           :THE CODE ADDED IS FREHKP (IA-TA FREEING HOUSEKEEPER)
                           :AND RELATED INSTRUCTIONS AND VARIABLES.
:UB.AAA; DEFDEF(UB.AAA,1)  :default for sign_in enabled
:SG.RTO; DEFDEF(SG.RTO,1)  : IF SG.RTO NE 0 RES TIMEOUT FUNCTION IS INCLUDED
                           : THIS CODE WAS ADDED BY STEVE GIMNICHER 10-1-80
                           : TO FIND ALL OF THE ADDITIONS AND MODIFICATIONS
                           : FOR THIS NEW FUNCTION, SIMPLY LOOK UP THE LABEL
                           : 'SG.RTO' IN THE CROSS REFERENCE.
        IF      FB.AAA     : auto_sign_off enabled, define variables for it


:SOFREB; GLABEL(SOFREB)  WS 1 :NUMBER OF TIMES WE SET UP A FREE-BLOCK
:SOFBAD; GLABEL(SOFBAD)  HS 1 :NUMBER OF TIMES WE RE-START IA-TA FREEING 
                              :SEQUENCE BECAUSE OF A BAD RESPONSE
:SOFTMO; GLABEL(SOFTMO)  HS 1 :NUMBER OF TIMES WE RE-START IA-TA FREEING 
                              :SEQUENCE BECAUSE OF NO RESPONSE
:SGOTIM; DEFDEF(SGOTIM,$A RATE*15)      :default response timeout value
:SGOINT; DEFDEF(SGOINT,$A RATE*5)      :run again time interval for SGOTMO
:SGOLMT; DEFDEF(SGOLMT,$A 3)            :max retries for 1st sign_off attemp
:HKPTIM; DEFDEF(HKPTIM,$A RATE*600)     :timeout for restart sign_off for
                                        :a frozen address
:HKPINT; DEFDEF(HKPINT,$A RATE*120)     :run again time interval for SGOHKP
:HKPRTR; DEFDEF(HKPRTR,$A 3)            :max retries after the 1st sign_off
:SGORND; DEFDEF(SGORND,$A 3)            :max times to start a sign_off process
                                        :each time has HKPRTR retries

        EI              : FB.AAA

        IF   UB.AAA                     :sign_in enabled

:SGIAUB; GLABEL(SGIAUB) WS 1            :# of times sign_in initiated
:SINBAD; GLABEL(SINBAD) HS 1            :# of bad res. for sign_in
:SINTMO; GLABEL(SINTMO) HS 1            :# of no resp. for sign_in
:SGITIM; DEFDEF(SGITIM,$A RATE*15)      :sign_in response timeout value
:SGIINT; DEFDEF(SGIINT,$A RATE*5)      :run again time interval for SGITMO
:SGILMT; DEFDEF(SGILMT,$A 3)            :max retries for sign_in

        EI

:
	GL	SYSTRC,SYSDBG,DBGREG,AUTFRE,AUTACT,RBFREE,TRCPTR,TRCRNG
	GL	TRCEND,DEBUG,R2UTAB,DIGIT,TRCLNG,DEBLNG,NUMUSR,NUMRB
	GL	NUMAUT,STRTTM,TRCENT,TRBLNG
        GL      DBTMP,PRTTMP
        GL      FREFRE,FREACT,NUMFRE

:
	GL	R2UNUM,R2UMAX
:
        GL      TRCREG,FRCLOG
:
DBTMP   BS      12
DIGIT	AC	/0123456789ABCDEF/	:ASCII CHARACTERS FOR HEX DIGITS
:
:SYSTEM TRACE STRING
:
PRTTMP	WS	1	:TEMP AREA FOR TRACE MSG ROUTINES
TRCREG	WS	1	:SAVE AREA FOR REGISTER SIX DURING TRACE
TRBLNG	EQ	(NPORT+11)/8	:TRACE BITS LENGTH IN BYTES
SYSTRC	BS	TRBLNG
: THERE IS ONE BIT PER PORT, PLUS 1 BIT FOR TRACING LOG, MAG AND 2 RSVD.
	SEG	0
	ORG	(.+1)/2*2	: HALFWORD ALIGN
:SYSTEM DEBUG STRING
SYSDBG	BS	20
: THERE IS ONE BIT FOR DISPLAYING THE TRACE RING, ONE FOR
: SUBROUTINE ANNOUNCING, 2 RESERVED BITS, THEN 4 SUBSYSTEM STRINGS, EACH
: 8 BITS LONG - LUD, CARL AND 2 OTHERS
:
DBGREG	WS	2	:TEMP STORAGE FOR DEBUG ROUTINE
:
	SEG	0
: CHAIN POINTERS
AUTFRE	WS	1	: POINTER TO FIRST AUT IN FREE AUT CHAIN
AUTACT	WS	1	:POINTER TO FIRST AUT IN ACTIVE AUT CHAIN
RBFREE	WS	1	: POINTER TO FREE RB CHAIN
FREFRE  WS      1       : POINTER TO HEAD OF FREE FREBLK CHAIN
FREACT  WS      1       : POINTER TO HEAD OF ACTIVE FREBLK CHAIN
TRCPTR	WC	.+4		:POINTER TO NEXT TRACE RING ENTRY
TRCLNG	EQ	24		:LENGTH OF TRACE RING ENTRIES
TRCRNG	BS	NTRACE*TRCLNG	:  TRACE RING ENTRIES @ 24 BYTES
TRCEND	EQ	.		:END OF TRACE AREA
:
TRCENT	WS	6	:A PLACE TO BUILD TRACE ENTRIES
:
	ORG	(.+1)/2*2	: HALFWORD ALIGN
:
:	USER DEBUG STRINGS (SAME STRUCTURE AS SYSDBG)
DEBLNG	EQ	24		:LENGTH OF DEBUG PARAMETER
DEBUG	BS	NDEBUG*DEBLNG
:

	GL	P2U
P2U	WS	NPORT		:P2U TABLE

	GL	CMDDAT,CMDSTR,CMDRES,CMDIA,CMDTA,CMDSEQ
CMDSTT  WS      0
CMDSOH  BC      $00DF
CMDRES  BS      1
CMDMAG  BC      $0 85
CMDSEQ  BS      1
CMDIA   BS      1
CMDTA   BS      1
	HS	0
CMDDAT	BS	CMDLEN		:STORAGE FOR COMMAND INPUT.


        GL      CRLEBF
CRLEBF  BS      CMDLEN

	GL	VLNCR
VLNCR	HS	1		:CR/SEMICOLON FLAG FOR VALDTR

	GL	HKHIRE
HKHIRE	HS	1		:HOUSEKEEPER-HIRED

	GL	INTLUD,RSPOOL
	WS	0
INTLUD	BS	LLUDBL		:LUD INTERFACE BLOCK.
	WS	0
RSPOOL	BS	LRESBL		:RES IATA POOL BLOCK.
NUMUSR	WC	0		:COUNT OF USERS LOGGED-ON AND DSC
NUMRB	WC	0		:COUNT OF RBS IN USE
NUMAUT	WC	0		:COUNT OF AUTS IN USE
NUMFRE  WC      0               : COUNT OF FREBLKS IN USE
:
: COUNT OF NUMBER OF ENTRIES IN R2UTAB
:
R2UMAX	WC	NR2U
R2UNUM	WC	0
FRCLOG  WC      0       :COUNT OF USERS FORCED OFF BY HOSKEPR
STRTTM	WS	1		:STARTUP TIME (FILLED IN BY INIT)

:LOGMSG STUFF.
	GL	LOGMSG,LMSTRT,LMTLNG,LMTEXT
LOGMSG	BS	1		:LENGTH, START OF 'SC' STRING
LMSTRT	AC	/LOGMSG- /	:START OF MESSAGE
LMTLNG	EQ	$A700	:MAXIMUM LENGTH OF TEXT
LMTEXT	BS	LMTLNG		:THE TEXT

        IF      SG.RTO
        GL      RESTOT,NUMRTO,RESTMS
RESTOT  HC      RESTON  :USED TO ENABLE/DISABLE RES TIMEOUT THROUGH NAD
NUMRTO  HS      1       :NUMBER OF RES TIMEOUTS
RESTMS  SC      !Service timeout. Connection terminated from NN"8D"8A!

        GL      RESBAD,CVTREG
RESBAD  HS      1       : COUNT OF NUMBER OF BAD RES NUMBERS RECEIVED IN
                        : MAG STARTUP MESSAGE
CVTREG  WS      1       : USED BY 'CVTRES' TO SAVE R2
        EI

        GL      SOFSHT,SHTFLG,SHTMSK,SHTMON,SHTMAG,SHTCIR,NUMSHT,NUMANS
SOFSHT  HC      SHUTON  :USED TO ENABLE/DISABLE SOFT SHUT THROUGH NAD
SHTFLG  BS      1       :FLAG TO SHOW IF HOST IS SHUT
SHTMSK  HS      1       :FLAG TO SHOW WHAT PROCESSES HAVE MATS SHUT
SHTMON  EQ      1       :  SHUT BECAUSE A MONITOR OR PROGRAMMER SHUT MATS
SHTMAG  EQ      2       :  SHUT BECAUSE NO MAG CIRCUITS ARE UP
SHTCIR  EQ      3       :  SHUT BECAUSE OUT OF AVAILABLE CIRCUITS
NUMSHT  HS      1       :NUMBER OF TIMES MATS SHUT
NUMANS  HS      1       :NUMBER OF TIMES MATS ANSWERED


: Global error counters
        GL      ERADDP,ERBSHP,ERDELP,ERBIDP,ERRSTA,ERRESP

        GL      CUEPZM,CUEPZA,CUECTY,CLKNFD,CBNEML,ERLPSN,ERLKIV,DROPMS
        GL      CIVRMC,CLSREC
        GL      EUXCTS,CDLKYE,ERUXMG,ERCARL

        BND     2
ERRORS  EQ      .
ERADDP  HS      1       : # of times R2UADD failed for printer res-ia-ta
ERBSHP  HS      1       : # of times BINSCH succeeded for printer res-ia-ta
                        : addition (BINSCH should fail for this instance)
ERDELP  HS      1       : # of times R2UDEL failed for printer res-ia-ta
ERBIDP  HS      1       : # of times BINSCH failed for printer res-ia-ta
ERRUSS  HS      1       :number of times we couldn't find corresponding RB
                        :for airline text
                        :deletion
ERSBE1  HS      1       :shouldn't get EOMC char.
ERSBI1  HS      1       :should be only ETX char.left
ERSBE2  HS      1       :shouldn't get EOMPB char.
ERSBI2  HS      1       should be only ETX char. left
ERSBI3  HS      1       :after EOMI should be only ETX char.
ERSBI4  HS      1       :after EOMU should be only ETX char.
ERSBE5  HS      1       :if only ETX is in from-buffer
ERSBE4  HS      1       :printer RB equal 0
ESCERR  HS      1       :counter of esc sequence error in VIPTXT
ERC1C2  HS      1       :# of times 2946 C1 C2 chars not present in
                        :airline message
ERUMS2  HS      1       :# of times 2946 UMSG2 char not after UMSG1 char in
                        :airline message
ERLADR  HS      1       :# of times 2946 line address chars out of range
                        :in airline message
ERNETX  HS      1       :# OF TIMES TTMS1 ETX CHAR MISSING IN AIRLINE RESPONSE

ERHDLA  HS      1       :error counter for hardcpy with C1,C2 supported, if
                        :no begining escape sequence for cursor position
ERHDER  HS      1       :harcopy with C1,C2 if no erase sequence for screen era

CUEPZM  HS      1       :port zero error
CUEPZA  HS      1       :unexpected port zero activation
CUECTY  HS      1       :unexpected circuit type
CLKNFD  HS      1       :local keys not found in table in needle err
CBNEML  HS      1       :bad needle error message length
ERLPSN  HS      1       :bad pseudo needle message length
ERLKIV  HS      1       :local key not found in local key table in good 
                        :pseudo needle
EUXCTS  HS      1       :unexpected circuit type in GPSNDL
CDLKYE  HS      1       :count of delete local key errors
CLSREC  HS      1       : Number of lost stat records
CIVRMC  HS      1       : Number of invalid receiver messages received
ERRSTA  HS      1       : NUMBER OF INVALID RECEIVER HOST STATUS
ERRESP  HS      1       : number of invalid RCVR responses to the
                        : "DROP" command
ERUXMG  HS      1       : Number of unexpected messages received by VALDTR
ERCARL  HS      1       :NUMBER OF TRANSLATION ERRORS.

:NOARBI; GLABEL(NOARBI) HS 1  :no active res block while sign_in failed
:RELNOF; GLABEL(RELNOF) HS 1  :no free block when try to initiate free proc.
:NOSOFP; GLABEL(NOSOFP) HS 1  :no sign_off AAA ptr table(in POOLIA)

ERRLNG  EQ      .-ERRORS



: MATS STATS variables

        GL      ABLANK
        GL      STBCMX,STRPTL,STOKTL,STPSTL,SQUNTL,RCTPER
        GL      SQFPOS,SQSPOS,SQEPOS,SQRLMT,SQNCNT,SQOCNT,STQSIZ,STQLNG
        GL      RCMNWR,RCMOKY,RCMDRK,RCMDRP,RCMCLS
        GL      LGIIVO,LGIOND,LGIOHO,LGIOPR,LGIDIA,LGITID,LGITIM,LGIMND
        GL      PSMBRK
        GL      MSCMXL
        GL      LSTHST
        GL      RSMSGP,RSMDAT,RSMLNG,RSMHST


ABLANK  SC      / /     :A blank for use as a dummy param to ZAPPRT

STBCMX  HC      STBCMV  :Maximum BCT we allow to accumulate for the
                        :Output Bufferlet chain for the Stats Circuit
                        :(we don't want it to rob space from user data).

STRPTL  WC RATE*STRPTV  :Stats Receiver Response timeout (FASTC)
                        :after which we zap.
STOKTL  WC STOKTV       : Activation timeout period (seconds) for
                        : stats circuit
STPSTL  WC RATE*STPSTV  :Stats period to timeout Pseudo-Needle
CTOCKL  WC RATE*CTOCKV  :Stats period to check psneedle timeout
SQUNTL  WC RATE*SQUNTV  :Period to unload the Stats Queue.
RCTPER  WC RATE*RCTPEV  :Period for generating record-count record

: Statistics-data-queue management variables

SQFPOS  WC      1       :Stats-Ring fill, offset from STAQPT to insert
                        :next character.  First character of STAEOR assembled
                        :in ring
SQSPOS  WC      0       :Stats-Ring send, offset from STAQPT for next
                        :character to send to receiver.
SQEPOS  WC      0       :Stats-Ring empty, offset from STAQPT to first
                        :saved character at which to begin retransmission.

SQRLMT  WC      SQRLMV  :How many characters to save in Stats queue in
                        :case of retransmission.

SQNCNT  WC      0       :Stats Queue unsent characters count
SQOCNT  WC      0       :Stats Queue old (sent) characters count being
                        :held for retransmission

STQSIZ  HC      STQLNG  :Size of statistics queue ring


: Statistics receiver command table

RCMNWR  SC      /NWR/                   : Not able to write message

RCMOKY  SC      /OKAY/                  : Okay message

RCMDRK  SC      /DRACK/                 : Drop acknowledge message

RCMDRP  SC      /DROP/                  : dDrop message
DROPMS  SC      /#DROP"8D/              :DROP msg with start of msg(#)

RCMCLS  SC      /CLOSE/                 : Close message


: Arrays of log-in information needed for user-startup record.  For
: each port, the information saved from the user's needle, i.e. all we 
: need to save before the user has an AUB.

LGITIM  WS      NPORT   :Login times from Needle
LGIIVO  WS      NPORT   :Invoice Number (session)
LGIOND  HS      NPORT   :Originating Node
LGIOHO  HS      NPORT   :Originating Host
LGIOPR  HS      NPORT   :Originating Port
LGIDIA  HS      NPORT   :Dialect
LGITID  HS      NPORT   :Terminal ID Code
LGIMND  WS      NPORT   :Numeric month and day of login for invoice #


: Message break table prior to needle arriving

PSMBRK  HC      0,0,0   :00
        HC      0,0,0   :30
        HC      0,0,0   :60
        HC      3,0,$02000:90 <-- Break on 9E(detach),9F(zapper),B2(pseudoneedle)
        HC      0,0,0   :C0
        HC      0       :F0

MSCMXL  HC      MSCMXV  :Max # of chars before ID msg

LSTHST  WS      1       :Last host a circuit building attempt was made to


        GL      STASOM

STASOM  EQ      $00A3   : '#' - MATS stats start of message character
                        :       (for control messages)

        GL      STAEOR

STAEOR  EQ      $08D    : MATS STATS End of Record character


 
:       USPREC - Assembly area for User-Startup Statistics Record

        GL      USPREC,USPRTY,USPSDA,USPSTI,USPSMD,USPSES,USPTTY,USPAID
        GL      USPUNM,USPUTY,USPDIA,USPOND,USPOHO,USPOPT,USPTID,USPLNG
        GL      USPEOR

 
USPREC  HS      0
 
USPCLS  AC      /A/     : Class
USPRTY  AC      /B/     : Record Type = B
USPSDA  BS      $A6     : YYMMDD - Date of Log-In
USPSTI  BS      $A6     : HHMMSS - Time of Log-In
USPSMD  BS      $A4     : Session month and day
USPSES  BS      $A10    : Tymnet Session (Invoice)
USPUNM  BS      NC.UNM  : Username (Tymnet Login Name)
        AC      /00/    : For future growth of terminal type (see next field)
USPTTY  BS      $A2     : Terminal Type (2 Hex Digits)
USPAID  BS      $A2     : Agent Initials
USPUTY  BS      $A1     : User type (ASCII "A" plus the CCB Type code)
USPDIA  BS      $A4     : Dialect, 4 Hex digits
USPOND  BS      $A4     : Originating Node, 4 digits decimal
USPOHO  BS      $A4     : Originating Host, 4 digits decimal
USPOPT  BS      $A3     : Originating Port, 3 digits decimal
USPTID  BS      $A2     : TID code from needle, 2 Hex digits.
USPEOR  BC      STAEOR  : End of Record character
 
USPLNG  EQ      .-USPREC
 
 
 
:       UVCREC - Assembly area for User-Service Record

        GL      UVCREC,UVCRTY,UVCEDA,UVCETI,UVCSMD,UVCSES,UVCSDA,UVCSTI
        GL      UVCEVT,UVCSCO,UVCSNU,UVCNDC,UVCNPC,UVCNTK,UVCSPO
        GL      UVCNCM,UVCNCE,UVCLAG,UVCLNG
        GL      UVCUNM,UVCEOR

  
UVCREC  HS      0       
 
UVCCLS  AC      /A/     : Class
UVCRTY  AC      /C/     : Record Type = C
UVCEDA  BS      $A6     : YYMMDD Event Date
UVCETI  BS      $A6     : HHMMSS Event time
UVCSMD  BS      $A4     : Session month and day
UVCSES  BS      $A10    : Tymnet Invoice
UVCUNM  BS      NC.UNM  : Username (Tymnet Login Name)
UVCSDA  BS      $A6     : Date Service Began
UVCSTI  BS      $A6     : HHMMSS Time Servece Began
UVCEVT  BS      $A1     : Event Type (ASCII "A" plus event code)
UVCSCO  AC      /    /  : Service code (Airline name left-justified in
                        : 4 spaces)
UVCSNU  BS      $A4     : Service Number (Res code) 4 decimal digits
UVCNDC  BS      $A7     : Number of characters, CRT traffic
UVCNPC  BS      $A7     : Number of characters Printed
UVCNTK  BS      $A5     : Number of tickets
UVCSPO  BS      $A4     : Service Port (IA-TA, 4 hex digits)
UVCNCM  BS      $A6     : Number of Commands
UVCNCE  BS      $A6     : Number of Command Errors
UVCLAG  BS      $A1     : Language, ASCII"A" plus code
UVCEOR  BC      STAEOR  : End of Record character
 
UVCLNG  EQ      .-UVCREC
 
 
 
:       MUPREC - Mats Startup Record assembly area

        GL      MUPREC,MUPRTY,MUPDAT,MUPTIM,MUPNOD,MUPHOS,MUPKHO
        GL      MUPSLO,MUPVER,MUPCCT,MUPCCO,MUPLNG
        GL      MUPEOR

 
MUPREC  HS      0
 
MUPCLS  AC      /A/     : Class
MUPRTY  AC      /A/     : Record type = A
MUPFTL  AC      /001/   : Format level
MUPDAT  BS      $A6     : YYMMDD Mats Startup Date
MUPTIM  BS      $A6     : HHMMSS Mats startup time
MUPNOD  BS      $A4     : Mats Node, 4 decimal digits
MUPHOS  BS      $A4     : Mats host, 4 decimal digits
MUPKHO  BS      $A4     : Mats Kernel Host, 4 decimal digits
MUPSLO  BS      $A2     : Mats Slot, 2 decimal digits
MUPVER  AC      /                              / : Mats version number
MUPCCT  BS      $A3     : Crash count, 3 decimal digits
MUPCCO  BS      $A2     : Crash code, 2 HEX digits
MUPEOR  BC      STAEOR  : End of Record character
 
MUPLNG  EQ      .-MUPREC

:       RCTREC - MATS Record-count Record assembly area


        GL      RCTREC,RCTRTY,RCTSDY,RCTSTI,RCTEDY,RCTETI,RCTUST
        GL      RCTUSR,RCTMST,RCTEOR,RCTLNG


RCTREC  HS      0

RCTCLS  AC      /A/             : Class
RCTRTY  AC      /E/             : Record type = E
RCTSDY  AC      /000000/        : YYMMDD start date
RCTSTI  AC      /000000/        : HHMMSS start time
RCTEDY  AC      /000000/        : YYMMDD end date
RCTETI  AC      /000000/        : HHMMSS end time
RCTUST  AC      /00000000/      : User startup record count
RCTUSR  AC      /00000000/      : User service record count
RCTMST  AC      /00000000/      : MATS startup record count
RCTEOR  BC      STAEOR          : End of Record character

RCTLNG  EQ      .-RCTREC


        GL      USTCNT,USECNT,MSTCNT

USTCNT  WC      0       : User startup record count
USECNT  WC      0       : User service record count
MSTCNT  WC      0       : MATS startup record count


: Receiver Startup Message

RSMSG   EQ      .
        IF      \ITC

        ELSE
        
        AC      /"8D"8D"8D"8D/
        AC      /TTY LC"8D/
        AC      /TTY NO ECHO"8D/
        AC      /TTY NO CRLF"8D/
        AC      /RUN RCVR"8D/

        EI


        AC      /$$NULL$$ MA/
RSMHST  AC      /hhhh/
        AC      / , /
RSMDAT  AC      /yymmddhhmmss/
        AC      /"8D#PURPLE"8D/
        AC      /  "8D/         : Empty data record - in case we append
                                : to a file with a truncated record.

RSMLNG  EQ      .-RSMSG

RSMSGP  WC      RSMSG   :Pointer to receiver startup message


:generate HW table containing offset to RESAAA table of a RES
:
        BND     2
:RESAOF; GLABEL(RESAOF)
Q       EQ      0
        RE      MAXRES+1
          HC    Q*RESALN
Q         EQ    Q+1
        ER



:(TIGERDEV)SEG2.S03
:       Copied by Byrne from .S02    4-Aug-86
:       Moved  MSCTAB from here to LUDMAC to allow SEG2 to after LUD.

:(TIGERDEV)SEG2.S02
:	Copied by Margalit from .S01	12/9/85
:	Only VT52 has LF as activation char, the others have it as CR
:	Added support for PCI-78

:(TIGERDEV)SEG2.S01
:	Copied by Margalit from .01C	9/24/85
:	Added the SCANSET

:(TIGERDEV)SEG2.01C
:       Copied by Chen from (TEST.INA)SEG2.03A on 6/14/85
:       Made a new directory for Flying Tiger project.
:
:(TEST.INA)SEG2.03A
:	Copied by Margalit from .02C	6/13/85
:	Changed TIB102 to what it was before
:	Added TIB52

:(TEST.INA)SEG2.02C
:       Copied by Chen from (TEST.INA)SEG2.01A on 5/29/85
:       Added new fields for each type of terminals to TIB
:       in order to handle FT type of terminal
:
:(TEST.INA)SEG2.01A
:	Copied by Margalit from (MATS.P2)SEG2.25T
:	Changed the activation character from "0D" to "0A"
:	for FLYING TIGERS

	SEG	2
:	GLOBAL NAMES
	GL	RBLOCK,AUBLKS,MAGTAB,AMTTAB,FRETAB
	GL	EDIBUF,EDINDX,EDILEN
:
:
:
:	RES BLOCK, USED TO HOLD USERS RES INFO, POINTED TO BY
:	A. OTHER RES BLOCK   B. RBFREE   C. AUTRB   D. AUTARB
        BND     4
RBLOCK	EQ	.
	ORG	.+NRBLK*RBLNG
:
	BND	2
AUBLKS  BS      NAUBS*AUBLNG
:
:	MAG TABLE - HOLDS ALL THE INFO ABOUT THE RES' STATUS, INCLUDING
:	THE IATA NUMBERS IN USE
	WS	0
MAGTAB	BS	NMAG*MAGLNG
:
:
:
AMTTAB	BS	NMON*AMTLNG
:
FRETAB  BS      NFRE*FRELNG
TERSP   HS      NPORT
:
EDIBUF	BS	MAXCHA+1        	: Allocate edit buffer
EDINDX	HC	0			: Allocate edit index
EDILEN	HC	0			: Allocate length of EDIBUF
:
:       TERMINAL INTERFACE BLOCKS
:
        GL      TIB440,TIB470,TIB415,TIB102,TIB431,TIB315,TIB52,TIB78
        BND     4
TIB440  AC     /"9B/    :ESCAPE CHARACTER
        AC     /t/      :LINE ERASE
        AC     /"00/    :CLEAR FIELD
        AC     /#/      :KEYBOARD LOCK
        AC     /"A2/    :KEYBOARD UNLOCK
        AC     /"82/    :START OF MESSAGE
        AC     /"83/    :END OF TEXT
        AC     /S/      :GET MESSAGE
        AC     /*/      :CLEAR TO NULLS
        AC     /"BA/    :CLEAR UNPROTECTED TO NULLS
        AC     /Y/      :CLEAR UNPROTECTED FROM CURSOR
        AC     /</      :UMSG LIGHT ON
        AC     />/      :UMSG LIGHT OFF
        AC     /B/      :BLOCK MODE
        AC     /C/      :CONVERSATIONAL MODE 
        AC     /)/      :WRITE PROTECT ON
        AC     /(/      :WRITE PROTECT OFF
        AC     /&/      :PROTECT ON
        AC     /'/      :PROTECT OFF
        AC      /"00/   :NON LIGHT PEN FIELD DEF
        AC      /"00/   :NORMAL PROTECTED FIELD
        AC      /"00/   :PROTECTED FIELD CHARACTER
        AC     /=/      :POSITION X , Y 
        AC     /"00/    :POSITION X
        AC     /"00/    :POSITION Y
        AC     /"00/    :ENABLE ATRIBUTES
        AC     /"00/    :DISABLE ATTRIBUTES
        AC     /"00/    :DISABLE DISPLAY
        AC     /"00/    :ENABLE DISPLAY
        AC     /"9E/    :HOME THE CURSOR
        AC      /"00/   :REPEAT TO ADDRESS
        BC      FALSE   :don't send echo because there is no printer
        BC      FALSE   :printer capability
        WC      NULSTR  :pointer to PRINTER ON string
        WC      NULSTR  :pointer to PRINTER OFF string
        WC      NULSTR  :pointer to cursor posi. string(begin)
        WC      NULSTR  :pointer to cursor posi. string (end)
        WC      NULSTR  :pointer to erase sequence string
        AC      /"00/   :MDT FOR 470
        AC      /"00/   :SET BUFFER ADDRESS
        HC      $A 64   :440 will NL after 64th char.
        AC     /"00/    :SLACK BYTE
:       80 CHARACTERS TO POSITION TO LINE OR COLUMN NUMBERS
:
        AC      / !"A2"A3$%&'()*+,-."AF0123456789"BA"BB<=>?@ABCDEF/
        AC      /GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno/
	RE	$0 40+CL.NUM
	BC	0	:Area for TIBECO,TIBACT,TIBCLS
	ER
T440LG  EQ      .-TIB440
        IF      T440LG-TIBLNG
        REMARK  %TIB440 has bad length:
        NUMBER  T440LG
        REMARK  instead of 
        NUMBER  TIBLNG
        EI

:Define action type of classes

	FUNCLS(TIB440,ESCHR,UPRTXT)
	FUNCLS(TIB440,UTCHR,UPRTXT)
	FUNCLS(TIB440,LTCHR,LOWTXT)
	FUNCLS(TIB440,BSCHR,IGNCHA)
	FUNCLS(TIB440,HTCHR,IGNCHA)
	FUNCLS(TIB440,LFCHR,IGNCHA)
	FUNCLS(TIB440,CRCHR,ENDLIN)
	FUNCLS(TIB440,IGCHR,IGNCHA)
	FUNCLS(TIB440,UNCHR,UPRTXT)
	FUNCLS(TIB440,DLCHR,IGNCHA)
	FUNCLS(TIB440,FWCHR,IGNCHA)
:Echo array

	BEGBIT(TIB440,$0100,TIBECO)
	 SETBIT($020,$07E)
	 SETBIT($00A0,$00DD)
	ENDBIT
:
:Activation char. array

	BEGBIT(TIB440,$0100,TIBACT)
	 SETBIT($00D)			: CR
	 SETBIT($08D)			: 	  
	ENDBIT




        BND     4
TIB470  AC      /"9B/   :ESCAPE CHARACTER
        AC      /I/     :LINE ERASE
        AC      /I/     :CLEAR FIELD
        AC      /(/     :KEYBOARD LOCK
        AC      /)/     :KEYBOARD UNLOCK
        AC      /"00/   :SEND SOM
        AC      /"00/   :SEND EOM
        AC      /?/     :GET MESSAGE
        AC      /K/     :CLEAR TO NULLS
        AC      /J/     :CLEAR UNPROTECTED TO NULLS
        AC      /J/     :CLEAR UNPROTECTED FROM CURSOR
        AC      /"00/   :UMSG LIGHT ON
        AC      /"00/   :UMSG LIGHT OFF
        AC      /W/     :BLOCK MODE
        AC      /G/     :CONVERSATIONAL MODE
        AC      /"00/   :PROTECTED FIELD ATTRIBUTE
        AC      /"00/   :NORMAL FIELD ATTRIBUTES
        AC      /"00/   :PROTECT ON
        AC      /"00/   :PROTECT OFF
        AC      /!/     :NON LIGHT PEN DETECTABLE
        AC      /"80/   :NORMAL FIELD ATTRIBUTE
        AC      /"82/   :PROTECTED FIELD ATTR
        AC      /"00/   :POSITION X, Y
        AC      /X/     :POSITION X
        AC      /Y/     :POSITION Y
        AC      '/'     :ENABLE ATTRIBUTES
        AC      /./     :DISABLE ATTRIBUTES
        AC      / /     :DISABLE DISPLAY
        AC      /@/     :ENABLE DISPLAY
        AC      /H/     :CURSOR TO HOME POSITION
        AC      /z/     :REPEAT TO ADDRESS CHAR FOR 470
        BC      FALSE   :don't send echo before printer text
        BC      TRUE    :printer capability
        WC      PON470  :pointer to PRINTER ON string
        WC      POF470  :pointer to PRINTER OFF string
        WC      NULSTR  :pointer to cursor posi. string(begin)
        WC      NULSTR  :pointer to cursor posi. string (end)
        WC      NULSTR  :pointer to erase sequence string
        
        AC      /Q/     :RESET MODIFIED DATA TAGS
        AC      /S/     :SET BUFFER ADDRESS
        HC      $A 80   :470 will NL after 80th char.
        AC      /"00/   :SLACK BYTE
:       80 CHARACTERS TO POSITION TO LINE OR COLUMN NUMBERS
:
        AC      / !"A2"A3$%&'()*+,-."AF0123456789"BA"BB<=>?@ABCDEF/
        AC      /GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno/
	RE	$0 40+CL.NUM
	BC	0	:Area for TIBECO,TIBACT,TIBCLS
	ER
T470LG  EQ      .-TIB470        
        IF      T470LG-TIBLNG
        REMARK  %TIB470 has bad length:
        NUMBER  T470LG
        REMARK  instead of 
        NUMBER  TIBLNG
        EI
:Define action type of classes

	FUNCLS(TIB470,ESCHR,UPRTXT)
	FUNCLS(TIB470,UTCHR,UPRTXT)
	FUNCLS(TIB470,LTCHR,LOWTXT)
	FUNCLS(TIB470,BSCHR,IGNCHA)
	FUNCLS(TIB470,HTCHR,IGNCHA)
	FUNCLS(TIB470,LFCHR,IGNCHA)
	FUNCLS(TIB470,CRCHR,ENDLIN)
	FUNCLS(TIB470,IGCHR,IGNCHA)
	FUNCLS(TIB470,UNCHR,UPRTXT)
	FUNCLS(TIB470,DLCHR,IGNCHA)
	FUNCLS(TIB470,FWCHR,IGNCHA)

:Echo array

	BEGBIT(TIB470,$0100,TIBECO)
	 SETBIT($0020,$007E)
	 SETBIT($00A0,$00DD)
	ENDBIT

:Activation character array

	BEGBIT(TIB470,$0100,TIBACT)
	 SETBIT($00D)			: CR
	 SETBIT($08D)
	ENDBIT



        BND     4
TIB415  RE      TIBECH  :fill unused bytes with nulls
        BC      0
        ER
        BC      TRUE    :send echo on/off msg's with printer text
        BC      TRUE    :printer capability
        WC      PON415  :pointer to PRINTER ON string
        WC      POF415  :pointer to PRINTER OFF string
        WC      LAB415  :pointer to cursor posi. string(begin)
        WC      NULSTR  :pointer to cursor posi. string (end)
        WC      ERA415  :pointer to erase sequence string
        BC      0       :MDT for 470
        BC      0       :set buffer address
        IF      \MARSP
          HC    $A 96   :415 will NL after 96th char.
        ELSE
          HC    $A 80   :415 will NL after 80th char.
        EI
        BC      0       :slack byte
        AC      / !"A2"A3$%&'()*+,-."AF0123456789"BA"BB<=>?@ABCDEF/
        AC      /GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno/
	RE	$0 40+CL.NUM
	BC	0	:Area for TIBECO,TIBACT,TIBCLS
	ER
T415LG  EQ      .-TIB415
        IF      T415LG-TIBLNG
        REMARK  %TIB415 has bad length:
        NUMBER  T415LG
        REMARK  instead of 
        NUMBER  TIBLNG
        EI

:Define action type of classes

	FUNCLS(TIB415,ESCHR,IGNCHA)
	FUNCLS(TIB415,UTCHR,UPRTXT)
	FUNCLS(TIB415,LTCHR,LOWTXT)
	FUNCLS(TIB415,BSCHR,CURLFT)
	FUNCLS(TIB415,HTCHR,CURRIT)
	FUNCLS(TIB415,LFCHR,LLIDEL)
	FUNCLS(TIB415,CRCHR,ENDLIN)
	FUNCLS(TIB415,IGCHR,IGNCHA)
	FUNCLS(TIB415,UNCHR,UPRTXT)
	FUNCLS(TIB415,DLCHR,IGNCHA)
	FUNCLS(TIB415,FWCHR,IGNCHA)

:Echo array

	BEGBIT(TIB415,$0100,TIBECO)
	 SETBIT($008,$009)
	 SETBIT($0020,$007E)
	 SETBIT($088,$089)
	 SETBIT($00A0,$00DD)
	ENDBIT

:Activation character array

	BEGBIT(TIB415,$0100,TIBACT)
	 SETBIT($00D)			: C.R --> trx
	 SETBIT($08D)
	 SETBIT($00A)			: L.F -->line delete
	 SETBIT($08A)
        ENDBIT





        BND     4
TIB315  RE      TIBECH  :fill unused bytes with nulls
        BC      0
        ER
        BC      FALSE   :don't send echo because no printer
        BC      FALSE   :printer capability
        WC      NULSTR  :pointer to PRINTER ON string
        WC      NULSTR  :pointer to PRINTER OFF string
        WC      NULSTR  :pointer to cursor posi. string(begin)
        WC      NULSTR  :pointer to cursor posi. string (end)
        WC      NULSTR  :pointer to erase sequence string
        BC      0       :MDT for 470
        BC      0       :set buffer address
        IF      \MARSP
          HC    $A 96   :315 will NL after 96th char.
        ELSE
          HC    $A 80   :315 will NL after 80th char.
        EI
        BC      0       :slack byte
        AC      /XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/
        AC      /XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/
	RE	$0 40+CL.NUM
	BC	0	:Area for TIBECO,TIBACT,TIBCLS
	ER
T315LG  EQ      .-TIB315
        IF      T315LG-TIBLNG
        REMARK  %TIB315 has bad length:
        NUMBER  T315LG
        REMARK  instead of 
        NUMBER  TIBLNG
        EI

:Define action type of classes

	FUNCLS(TIB315,ESCHR,LLIDEL)
	FUNCLS(TIB315,UTCHR,UPRTXT)
	FUNCLS(TIB315,LTCHR,LOWTXT)
	FUNCLS(TIB315,BSCHR,IGNCHA)
	FUNCLS(TIB315,HTCHR,IGNCHA)
	FUNCLS(TIB315,LFCHR,IGNCHA)
	FUNCLS(TIB315,CRCHR,ENDLIN)
	FUNCLS(TIB315,IGCHR,IGNCHA)
	FUNCLS(TIB315,UNCHR,CHADEL)
	FUNCLS(TIB315,DLCHR,IGNCHA)
	FUNCLS(TIB315,FWCHR,IGNCHA)

:Echo array

	BEGBIT(TIB315,$0100,TIBECO)
	 SETBIT($020,$07E)
	 SETBIT($00A0,$00DD)
	ENDBIT

:Activation type array

	BEGBIT(TIB315,$0100,TIBACT)
	 SETBIT($00D)			: CR
	 SETBIT($01B)			: ESC line delete character
	 SETBIT($08D)
         SETBIT($09B)
	ENDBIT
:
:

        BND     4
TIB102  RE      TIBECH  :fill unused bytes with nulls
        BC      0
        ER
        BC      TRUE    :send echo on/off msg's with printer text
        BC      TRUE    :printer capability
        WC      PON102  :pointer to PRINTER ON string
        WC      POF102  :pointer to PRINTER OFF string
        WC      NULSTR  :pointer to cursor posi. string(begin)
        WC      NULSTR  :pointer to cursor posi. string (end)
        WC      NULSTR  :pointer to erase sequence string
        BC      0       :MDT for 470
        BC      0       :set buffer address
        IF      \MARSP
          HC      $A 96 :102 will NL after 96th char (if for mars+).
        ELSE
          HC      $A 80 :102 will NL after 80th char.
        EI
        BC      0       :slack byte
:       80 CHARACTERS TO POSITION TO LINE OR COLUMN NUMBERS
:
        AC      /XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/
        AC      /XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/
	RE	$0 40+CL.NUM
	BC	0	:Area for TIBECO,TIBACT,TIBCLS
	ER
T102LG  EQ      .-TIB102
        IF      T102LG-TIBLNG
        REMARK  %TIB102 has bad length:
        NUMBER  T102LG
        REMARK  instead of 
        NUMBER  TIBLNG
        EI

:Define action type of classes

	FUNCLS(TIB102,ESCHR,IGNCHA)
	FUNCLS(TIB102,UTCHR,UPRTXT)
	FUNCLS(TIB102,LTCHR,LOWTXT)
	FUNCLS(TIB102,BSCHR,CURLFT)
	FUNCLS(TIB102,HTCHR,CURRIT)
	FUNCLS(TIB102,LFCHR,IGNCHA)
	FUNCLS(TIB102,CRCHR,ENDLIN)
	FUNCLS(TIB102,IGCHR,IGNCHA)
	FUNCLS(TIB102,UNCHR,UPRTXT)
	FUNCLS(TIB102,DLCHR,LLIDEL)
	FUNCLS(TIB102,FWCHR,IGNCHA)

:Echo array

	BEGBIT(TIB102,$0100,TIBECO)
	 SETBIT($008,$009)
	 SETBIT($0020,$007E)
	 SETBIT($00A0,$00DD)
	ENDBIT

:Activation character array

	BEGBIT(TIB102,$0100,TIBACT)
	 SETBIT($00D)			: CR
	 SETBIT($08D)
	 SETBIT($07F)			: Line delete
	 SETBIT($00FF)
        ENDBIT


        BND     4
TIB431  RE      TIBECH  :fill unused bytes with nulls
        BC      0
        ER
        BC      TRUE    :send echo on/off msg's with printer text
        BC      TRUE    :printer capability
        WC      PON431  :pointer to PRINTER ON string
        WC      POF431  :pointer to PRINTER OFF string
        WC      NULSTR  :pointer to cursor posi. string(begin)
        WC      NULSTR  :pointer to cursor posi. string (end)
        WC      NULSTR  :pointer to erase sequence string
        BC      0       :MDT for 470
        BC      0       :set buffer address
        IF      \MARSP
          HC      $A 96 :431 will NL after 96th char (for mars+).
        ELSE
          HC      $A 80 :431 will NL after 80th char.
        EI
        BC      0       :slack byte
        AC      /XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/
        AC      /XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/
	RE	$0 40+CL.NUM
	BC	0	:Area for TIBECO,TIBACT,TIBCLS
	ER
T431LG  EQ      .-TIB431
        IF      T431LG-TIBLNG
        REMARK  %TIB431 has bad length:
        NUMBER  T431LG
        REMARK  instead of 
        NUMBER  TIBLNG
        EI

:Define action type of classes

	FUNCLS(TIB431,ESCHR,IGNCHA)
	FUNCLS(TIB431,UTCHR,UPRTXT)
	FUNCLS(TIB431,LTCHR,LOWTXT)
	FUNCLS(TIB431,BSCHR,CURLFT)
	FUNCLS(TIB431,HTCHR,IGNCHA)
	FUNCLS(TIB431,LFCHR,LLIDEL)
	FUNCLS(TIB431,CRCHR,ENDLIN)
	FUNCLS(TIB431,IGCHR,IGNCHA)
	FUNCLS(TIB431,UNCHR,UPRTXT)
	FUNCLS(TIB431,DLCHR,IGNCHA)
	FUNCLS(TIB431,FWCHR,CURRIT)
:Echo array

	BEGBIT(TIB431,$0100,TIBECO)
	 SETBIT($008)
	 SETBIT($00C)
	 SETBIT($0020,$007E)
	 SETBIT($088)
	 SETBIT($08C)
	 SETBIT($00A0,$00DD)
	ENDBIT

:Activation character array

	BEGBIT(TIB431,$0100,TIBACT)
	 SETBIT($00D)			: CR
	 SETBIT($08D)
        ENDBIT


        BND     4
TIB52   RE      TIBECH  :fill unused bytes with nulls
        BC      0
        ER
        BC      TRUE    :send echo on/off msg's with printer text
        BC      TRUE    :printer capability
        WC      PON52   :pointer to PRINTER ON string
        WC      POF52   :pointer to PRINTER OFF string
        WC      LAB52   :pointer to cursor posi. string(begin)
        WC      NULSTR  :pointer to cursor posi. string (end)
        WC      ERA52   :pointer to erase sequence string
        BC      0       :MDT for 470
        BC      0       :set buffer address
        IF      \MARSP
          HC      $A 96 :52 will NL after 96th char (if for mars+).
        ELSE
          HC      $A 80 :52 will NL after 80th char.
        EI
        BC      0       :slack byte
:       80 CHARACTERS TO POSITION TO LINE OR COLUMN NUMBERS
:
        AC      / !"A2"A3$%&'()*+,-."AF0123456789"BA"BB<=>?@ABCDEF/
        AC      /GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno/
	RE	$0 40+CL.NUM
	BC	0	:Area for TIBECO,TIBACT,TIBCLS
	ER
T52LG   EQ      .-TIB52
        IF      T52LG-TIBLNG
        REMARK  %TIB52 has bad length:
        NUMBER  T52LG
        REMARK  instead of 
        NUMBER  TIBLNG
        EI

:Define action type of classes

	FUNCLS(TIB52,ESCHR,IGNCHA)
	FUNCLS(TIB52,UTCHR,UPRTXT)
	FUNCLS(TIB52,LTCHR,LOWTXT)
	FUNCLS(TIB52,BSCHR,CURLFT)
	FUNCLS(TIB52,HTCHR,CURRIT)
	FUNCLS(TIB52,LFCHR,IGNCHA)
	FUNCLS(TIB52,CRCHR,ENDLIN)
	FUNCLS(TIB52,IGCHR,IGNCHA)
	FUNCLS(TIB52,UNCHR,UPRTXT)
	FUNCLS(TIB52,DLCHR,LLIDEL)
	FUNCLS(TIB52,FWCHR,IGNCHA)

:Echo array

	BEGBIT(TIB52,$0100,TIBECO)
	 SETBIT($008,$009)
	 SETBIT($0020,$007E)
	 SETBIT($00A0,$00DD)
	ENDBIT

:Activation character array

	BEGBIT(TIB52,$0100,TIBACT)
	 SETBIT($00A)			: LF
	 SETBIT($08A)
	 SETBIT($07F)			: Line delete
	 SETBIT($00FF)
        ENDBIT



        BND     4
TIB78   RE      TIBECH  :fill unused bytes with nulls
        BC      0
        ER
        BC      TRUE    :send echo on/off msg's with printer text
        BC      TRUE    :printer capability
        WC      PON78   :pointer to PRINTER ON string
        WC      POF78   :pointer to PRINTER OFF string
        WC      LAB78   :pointer to cursor posi. string(begin)
        WC      NULSTR  :pointer to cursor posi. string (end)
        WC      ERA78   :pointer to erase sequence string
        BC      0       :MDT for 470
        BC      0       :set buffer address
        HC      $A 80   :78 automatically wraps after the 80th char
        BC      0       :slack byte
:       80 CHARACTERS TO POSITION TO LINE OR COLUMN NUMBERS
:
	AC	/"80"81"82"83"84"85"86"87"88"89"8A"8B"8C"8D"8E"8F/
	AC	/"90"91"92"93"94"95"96"97"98"99"9A"9B"9C"9D"9E"9F/
        AC      / !"A2"A3$%&'()*+,-."AF0123456789"BA"BB<=>?@ABCDEF/
        AC      /GHIJKLMNO/
	RE	$0 40+CL.NUM
	BC	0	:Area for TIBECO,TIBACT,TIBCLS
	ER
T78LG   EQ      .-TIB78
        IF      T78LG-TIBLNG
        REMARK  %TIB78 has bad length:
        NUMBER  T78LG
        REMARK  instead of 
        NUMBER  TIBLNG
        EI

:Define action type of classes

	FUNCLS(TIB78,ESCHR,IGNCHA)
	FUNCLS(TIB78,UTCHR,UPRTXT)
	FUNCLS(TIB78,LTCHR,LOWTXT)
	FUNCLS(TIB78,BSCHR,CURLFT)
	FUNCLS(TIB78,HTCHR,CURRIT)
	FUNCLS(TIB78,LFCHR,UPRTXT)
	FUNCLS(TIB78,CRCHR,ENDLIN)
	FUNCLS(TIB78,IGCHR,IGNCHA)
	FUNCLS(TIB78,UNCHR,UPRTXT)
	FUNCLS(TIB78,DLCHR,LLIDEL)
	FUNCLS(TIB78,FWCHR,IGNCHA)

:Echo array

	BEGBIT(TIB78,$0100,TIBECO)
	 SETBIT($008,$009)
	 SETBIT($0020,$007E)
	 SETBIT($00A0,$00DD)
	ENDBIT

:Activation character array

	BEGBIT(TIB78,$0100,TIBACT)
	 SETBIT($00D)			: CR
	 SETBIT($08D)
	 SETBIT($07F)			: Line delete
	 SETBIT($00FF)
        ENDBIT

:
: Terminal Command Pool
: for variable length escape sequences
:
: The first byte of each string contains the length of the string,
: so be sure to change the first byte if you change the string length.
: The NAD assembler doesn't allow semicolons to appear in statements,
: including strings and comments, so I use <SEM> to represent a
: semicolon in the comments.  <ESC> stands for escape, as usual.
:
NULSTR  BC      0                     :null string
PON470  BC      $0 3,9B,0BB,0B6       :printer on  470   <ESC><SEM>6
POF470  BC      $0 3,9B,0BB,0B1       :printer off 470   <ESC><SEM>1
PON415  BC      $0 3,9B,0BB,0B1       :printer on  415   <ESC><SEM>1
POF415  BC      $0 3,9B,0BB,0B0       :printer off 415   <ESC><SEM>0
PON102	BC	$0 4,9B,0DB,0B5,0E9    :printer on  102   <ESC><OPS>5<i>
POF102	BC	$0 4,9B,0DB,0B4,0E9    :printer off 102   <ESC><OPS>4<i>
PON431	BC	$0 3,9B,0C1,0B1	      :printer on  431   <ESC><A><1>
POF431	BC	$0 3,9B,0C1,0B0       :printer off 431   <ESC><A><0>
PON52	SC	/"9BW/			:printer on 52	 <ESC><W>
POF52	SC	/"9BX/			:printer off 52	 <ESC><X>
PON78	SC	/"9B*/			: printer on 78  <ESC><*>
POF78	SC	/"9B?/			: printer off 78 <ESC><?>
:
: SC strings for cuosor position(C2) and erase sequence(C1)
:    for Flying Tiger
:
LAB52  SC      /"9BY/
ERA52  SC      /"9BJ/
:
LAB415	SC	/"9BY/
ERA415	SC	/"9BJ/
:
LAB78	SC	/"9B"91/
ERA78	SC	/"9B"98/
:
:
:
:
: MATS STATS structures
        SEG     A.BUFF


        GL      LSTLKY,LKYCNT,LKYMAX,LKYTAB
        GL      STAQUE,STQLNG
        GL      DUMADR

DUMADR  BS      20                      : Dummy buffer space for GTCHRS calls


: LKYTAB - Table to hold local keys for outstanding circuit requests

LSTLKY  HS      1       :LAST LOCAL KEY USED
LKYCNT  WC      0       :Count of active entries in LKYTAB
LKYMAX  EQ      $A64    :Maximum outstanding local keys

LKYTAB  WS      0
        BS      (LKYMAX+1)*LKYLNG


: Statistics-data send queue.  It's a ring ...

STAQUE  BC      STAEOR  :Assemble in EOR as first character. SQFPOS shows this.
        BS      SQRGNC-1
STQLNG  EQ      .-STAQUE




:  (MATS.P2)CRTAB.S07
:     Copied by Byrne from (MATS.P2)CRTAB.06L on 16-Jul-86
:     Moved DEFACT and DEFCLS calls up to the end of the TIBMAC file
:     so that new Baseline format will assemble correctly.

:  (MATS.P2)CRTAB.06L
:     Copied by Cardini from (MATS.P2)CRTAB.05L on 2/22/84
:     in order to define a new class related to the character
:     $00C  for the handling of cursor right in the 431 terminal type.
:
:  (MATS.P2)CRTAB.05L
:     Copied by Cardini from (MATS.P2)CRTAB.04L on 12/16/83
:     in order to define a new class related to the character DEL
:     ($07F).
:
:  (MATS.P2)CRTAB.04L
:     Copied by Cardini from (MATS.P2)CRTAB.04L on 9/22/83
:     in order to add the new action type CHADEL.
:
:  (MATS.P2)CRTAB.03L
:     Copied by Cardini from (MATS.P2)CRTAB.02L on 9/21/83
:     in order to update CHRCLS table.
:    
:  (MATS.P2)CRTAB.02L
:     Copied by Cardini from (MATS.P2)CRTAB.01L in order to
:     make correction in character class table.    
:
:  (MATS.P2)CRTAB.01L created by L. Cardini on 8/19/83 in order to
:     fill TIBCLS table, ECHCHR and ACTCHR bit arrays. Action types
:     and Class types are defined. 
:


:  In order to perform some line editing functions related to different
:  terminal types, a number of macros have been written.
:
:  The whole set of ascii characters has been partitioned into a number
:  of classes, each character belonging to only one class.
:
:  A class is a grouping of characters where every character belonging    
:  to the class will produce the same action when entered on any terminal.
:
:  For each terminal type, and for each class, a function is specified
:  which indicates processing to be performed for that class and terminal.
:
:  Macros defined:
:
:  	DEFCLS(class)			- it defines a class type
:
:	DEFACT(action)			- it defines an action type
:
:	CHRCLS(class,char1,char2)	- it defines the range (char1-char2)
:					  of characters belonging to the
:	  				  specified class. 
:
:	Action type definitions are now defined in the TIBMAC file.
:
:        DEFACT(CURLFT)			: cursor left
:        DEFACT(CURRIT)			: cursor right
:        DEFACT(IGNCHA)			: ignore character
:        DEFACT(ENDLIN)			: end of line
:        DEFACT(UPRTXT)			: text
:        DEFACT(LOWTXT)			: lower case text
:        DEFACT(LLIDEL)			: line delete
:        DEFACT(CHADEL)			: character delete
:
:	Class type definitions are now defined in the TIBMAC file.
:
:        DEFCLS(ESCHR)			: escape
:        DEFCLS(UTCHR)			: upper case text
:        DEFCLS(LTCHR)			: lower case text
:        DEFCLS(BSCHR)			: backspace
:        DEFCLS(HTCHR)			: horizontal tab
:        DEFCLS(LFCHR)			: line feed
:        DEFCLS(CRCHR)			: carriage return
:        DEFCLS(IGCHR)			: ignore
:        DEFCLS(UNCHR)			: underscore
:        DEFCLS(DLCHR)			: delete char
:        DEFCLS(FWCHR)			: forespace char

:	Define default class and number of characters

        DFTCLS(UTCHR,$A256)


:	Specify ascii characters as belonging to a class


	CHRCLS(IGCHR,0)
	CHRCLS(UTCHR,1)
	CHRCLS(IGCHR,2,7)
	CHRCLS(BSCHR,8)
	CHRCLS(HTCHR,9)
	CHRCLS(LFCHR,$00A)
	CHRCLS(IGCHR,$00B)
	CHRCLS(FWCHR,$00C)
	CHRCLS(CRCHR,$00D)
	CHRCLS(IGCHR,$00E,$01A)
	CHRCLS(ESCHR,$01B)
	CHRCLS(IGCHR,$01C,$01E)
	CHRCLS(UTCHR,$01F,$05E)
	CHRCLS(UNCHR,$05F)
	CHRCLS(UTCHR,$060)
	CHRCLS(LTCHR,$061,$07A)
	CHRCLS(UTCHR,$07B,$07E)
	CHRCLS(DLCHR,$07F)
	CHRCLS(IGCHR,$080)
	CHRCLS(UTCHR,$081)
	CHRCLS(IGCHR,$082,$087)
	CHRCLS(BSCHR,$088)
	CHRCLS(HTCHR,$089)
	CHRCLS(LFCHR,$08A)
	CHRCLS(IGCHR,$08B)
	CHRCLS(FWCHR,$08C)
	CHRCLS(CRCHR,$08D)
	CHRCLS(IGCHR,$08E,$09A)
	CHRCLS(ESCHR,$09B)
	CHRCLS(IGCHR,$09C,$09E)
	CHRCLS(UTCHR,$009F,$00DE)
	CHRCLS(UNCHR,$00DF)
	CHRCLS(UTCHR,$00E0)
	CHRCLS(LTCHR,$00E1,$00FA)
	CHRCLS(UTCHR,$00FB,$00FE)
	CHRCLS(DLCHR,$00FF)


:(TIGERDEV)PTRAN.01C
:       Copied by Chen from (TEST.INA)PTRAN.01A on 6/14/85
:       Made a new directory for Flying Tiger project.
:

:	This file contains translation tables and some
:	other tables as transition & states tables used
:	to implement a state machine.
:	This file is used by the FLYING TIGERS 	Printer 
:	Messages routine - FTPRT



        GL      SAT.PT,SAT.BS


SAT.BS          :Base address

SAT.NO  BC      0               : No-op

SAT.CR  SC.BEG                  : Carriage return
        BC      $8 215,212      : CR, LF
        RE      PC.736          : Number of pad characters
          BC    $0 80
        ER
        SC.END

SAT.FF  SC.BEG                  : Form feed
        BC      $8 214          : ASCII FF
        RE      PF.736          : Number of pad characters
          BC    $0 80
        ER
        SC.END

SAT.TB  SC.BEG                  : Tab
        BC      $8 211          : ASCII TAB
        RE      PT.736          : Number of pad characters
          BC    $0 80
        ER
        SC.END

SAT.RS  SC.BEG                  : Printer reset
        BC      $8 215,214      : ASCII CR, FF
        RE      PR.736          : Number of pad characters
          BC    $0 80
        ER
        SC.END



SAT.0   EQ      SAT.NO
SAT.1   SC      !1!
SAT.2   SC      !2!
SAT.3   SC      !3!
SAT.4   SC      !4!
SAT.5   SC      !5!
SAT.6   SC      !6!
SAT.7   SC      !7!
SAT.10  SC      !8!
SAT.11  SC      !9!
SAT.12  SC      !0!
SAT.13  SC      !*!
SAT.14  EQ      SAT.CR          :Carriage return
SAT.15  EQ      SAT.NO
SAT.16  EQ      SAT.CR          :Carriage return
SAT.17  EQ      SAT.NO
SAT.20  EQ      SAT.NO
SAT.21  SC      !/!
SAT.22  SC      !S!
SAT.23  SC      !T!
SAT.24  SC      !U!
SAT.25  SC      !V!
SAT.26  SC      !W!
SAT.27  SC      !X!
SAT.30  SC      !Y!
SAT.31  SC      !Z!
SAT.32  SC      !-!
SAT.33  SC      !#!             :Cross of Lorraine
SAT.34  SC      ! !
SAT.35  EQ      SAT.NO
SAT.36  EQ      SAT.NO
SAT.37  EQ      SAT.NO
SAT.40  SC      !^!             :Lozenge
SAT.41  SC      !J!
SAT.42  SC      !K!
SAT.43  SC      !L!
SAT.44  SC      !M!
SAT.45  SC      !N!
SAT.46  SC      !O!
SAT.47  SC      !P!
SAT.50  SC      !Q!
SAT.51  SC      !R!
SAT.52  EQ      SAT.NO
SAT.53  SC      !<!
SAT.54  EQ      SAT.TB          :Tab
SAT.55  EQ      SAT.NO
SAT.56  EQ      SAT.NO
SAT.57  EQ      SAT.NO
SAT.60  SC      !$!
SAT.61  SC      !A!
SAT.62  SC      !B!
SAT.63  SC      !C!
SAT.64  SC      !D!
SAT.65  SC      !E!
SAT.66  SC      !F!
SAT.67  SC      !G!
SAT.70  SC      !H!
SAT.71  SC      !I!
SAT.72  EQ      SAT.NO
SAT.73  SC      !.!
SAT.74  EQ      SAT.FF          :Form feed (index)
SAT.75  EQ      SAT.NO
SAT.76  EQ      SAT.RS          : Printer reset
SAT.77  EQ      SAT.NO


:  Table of halfword pointers

        BND     2
SAT.PT          :Beginning of table of halfword pointers

Q       EQ      0

        RE      $8 100

          HC    SAT.|$8 Q|-SAT.BS  :Relative address of SC string
Q         EQ    Q+1

        ER

: Tables for State Machine implemented in FTPRT

: Data Definitions

DTACLS	EQ	0		: DATA CLASS
SFTCLS	EQ	1		: SHIFT CLASS
SPCCLS	EQ	2		: SPECIAL CLASS
CNTCLS	EQ	3		: COUNT CLASS
DGTCLS	EQ	4		: DIGIT CLASS

SFTCHR	EQ	$03A		: SHIFT CHAR IN SABRE
SP1CHR	EQ	2		: SPECIAL CHAR - TOP OF FORM
SP2CHR	EQ	3		: SPECIAL CHAR - VERTICAL TAB
CNTCHR	EQ	$02C		: COUNT CHAR IN SABRE
ONECHR	EQ	1		: DIGIT - ONE
DGTCHR	EQ	4		: FIRST DIGIT AFTER SP2CHR

DTASTT	EQ	0		: DATA STATE
SFTSTT	EQ	1		: SHIFT STATE
SPCSTT	EQ	2		: SPECIAL STATE
CNTSTT	EQ	3		: COUNT STATE
DGTSTT	EQ	4		: COUNT STATE
NMBSTT	EQ	5		: NUMBER OF STATES

ASCFF	EQ	$00C		: FORM FEED IN ASCII
ASCVT	EQ	$00B		: VERTICAL TAB IN ASCII

: Class Table

CLSTBL	BS	0
	RE	$A64		: 64 characters in Sabre
	 BC 	DTACLS		: default
	ER
ST.CL	EQ	.
	ORG	CLSTBL+SFTCHR
	BC	SFTCLS		: SHIFT
	ORG	CLSTBL+SP1CHR
	BC	SPCCLS		: form feed
	BC	SPCCLS		: VT
	ORG	CLSTBL+CNTCHR
	BC	CNTCLS		: COUNT
	ORG	CLSTBL+ONECHR
	BC	DGTCLS		: digit - 1
	ORG	CLSTBL+DGTCHR
	RE	7		: from 4 to 0
	 BC	DGTCLS		: digit 
	ER
	ORG	ST.CL		: origin right after the table
	KILL	ST.CL
	
: State Table

STTTBL	BS	0

: current state = DATA

	BC	DTASTT		: others
	BC	SFTSTT		: shift
	BC	DTASTT		: special
	BC	CNTSTT		: count
	BC	DTASTT		: digit

: current state = SHIFT

	BC	DTASTT		: others
	BC	DTASTT		: shift
	BC	SPCSTT		: special
	BC	DTASTT		: count
	BC	DTASTT		: digit

: current state = SPECIAL

	BC	DTASTT		: others
	BC	SFTSTT		: shift
	BC	DTASTT		: special
	BC	DTASTT		: count
	BC	DTASTT		: digit

: current state = COUNT

	BC	DTASTT		: others
	BC	SFTSTT		: shift
	BC	DGTSTT		: special
	BC	DTASTT		: count
	BC	DGTSTT		: digit

: current state = DIGIT

	BC	DTASTT		: others
	BC	SFTSTT		: shift
	BC	DTASTT		: special
	BC	DTASTT		: count
	BC	DTASTT		: digit
	
: Special Sabre to Ascii translation table

SPCTBL	BS	0
	RE	$A64		: 64 characters in Sabre
	 BC	0		: no translation
	ER
ST.SP	EQ	.
	ORG	SPCTBL+SP1CHR	
	BC	ASCFF		: form feed
	BC	ASCVT		: vertical tab
	ORG	ST.SP
	KILL	ST.SP




: (MATS.P2)DEBUGR.03S
:    Copied by Gimnicher from (MATS.P2)DEBUGR.02L.  8/19/81
:    Added variable DBGSTA for MATS STATS debugging.

: DEBUGR.02L copied from DEBUGR.01K on 01.09.81  by Svetlana
: Vaysburd in order to  add new variable DBGPRT.
: ***NOT READY FOR USE***
: DEBUGR.01K COPIED FROM
: (MATS.DEV)DEBUGR.NXX 10/15/80

	RA	$00A	:RADIX TO DECIMAL
:
:	DEBUG BIT NAMES
:
	GL	DBGRNG,DBGANC,DBGPRT,DBGCRL,DUSER,DALL,SENDIT
	GL	DBGSTA
:
DBGRNG	EQ	0	:DISPLAY TRACE RING EVENTS
DBGANC	EQ	1	:SUBROUTINE ANNOUNCEMENTS
DBGPRT  EQ      2       :printer subsystem debug string
DBGSTA  EQ      3       :MATS STATS debug bit
DBGLUD	EQ	8	:LUD SUBSYTEM DEBUG STRING
DBGCRL	EQ	16	:CARL SUBSYSTEM DEBUG STRING
DBGRV1	EQ	24	:16 BIT RESERVED FOR 2 MORE SUBSYSTEMS
:
DUSER	EQ	0	:DEBUG MESSAGE ONLY TO USER CAUSING EVENT
DALL	EQ	1	:DEBUG MESSAGE TO ALL DEBUGGING USERS
:
DEBUGS  MACRO(PTRREG,LENREG,BNAME,DFLAG,SVAREA,SEGNUM)
:
: MACRO TO DISPLAY LENREG CHARACTERS POINTED TO BY PTRREG TO THE
: APPROPRIATE DEBUGERS.  PTRREG & LENREG CAN BE ANY REGISTERS
: EXCEPT RLINK OR RSAVE.
:
[
        IF      DEBSW
        SEG     2
DMSG    BS      $A40
DPARM   WC      DMSG
        BC      BNAME,DFLAG
        SEG     SEGNUM
        ST      PTRREG,DBGREG
        ST      LENREG,DBGREG+4 : SAVE PARAMETERS
        CLHI    LENREG,$A37     : IS LENGTH OF STRING > 37 CHARS?
        JLEFS   .+6             : NO
        LHI     LENREG,$A37     : ONLY DISPLAY 37 TEXT CHARACTERS
        LA      RSAVE,DMSG,,    : START OF DEBUG MSG
        AIS     LENREG,2        : CR AND LF
        STB     LENREG,0,RSAVE  : STORE IN DMSG
        AIS     RSAVE,1         : NEXT CHAR IN DEBUG MSG
        LHI     RLINK,$08A8D    : CR AND LF IN REVERSE ORDER
        STB     RLINK,0,RSAVE   : STORE CR
        AIS     RSAVE,1         : NEXT CHAR IN DEBUG MSG
        SRLS    RLINK,8         : GET LF
        STB     RLINK,0,RSAVE   : STORE LF
        AIS     RSAVE,1
        SIS     LENREG,3        : REMAINING LENGTH OF MSG (WITH RESPECT TO 0)

: START OF LOOP
        LB      RLINK,0,PTRREG,LENREG : GET A BYTE
        STB     RLINK,0,RSAVE,LENREG  : STORE IN DEBUG MSG
        SIS     LENREG,1
        JGE     .-$00E

        L       PTRREG,DBGREG   : RESTORE PARAMETERS
        L       LENREG,DBGREG+4
        ST      R2,DBGREG       : SAVE R2
        LI      R2,DPARM        : ADDRESS OF POINTER TO DEBUG MSG
        LA      RSAVE,SVAREA,,
        JAL     RLINK,DEBUGR,,
        L       R2,DBGREG       : RESTORE R2
        EI
        ]
DEBUGM	MACRO(MSG,BNAME,DFLAG,SVAREA,SEGNUM)
[
	IF	DEBSW
	ST	R2,DBGREG
	SEG	2
DMSG	SC	/"8D"8A MSG/
DPARM	WC	DMSG
	BC	BNAME,DFLAG
	SEG	SEGNUM
	LI	R2,DPARM
	LA	RSAVE,SVAREA,,
	JAL	RLINK,DEBUGR,,
	L	R2,DBGREG
	EI
]
:
:	DEBUGM MACRO TO AID IN USE OF DEBUGGING FACILITY
:	ARGUMENTS:  MSG - THE MESSAGE TO BE DISPLAYED
:		    BNAME - BIT NAME OF DEBUG BIT
:		    DFLAG - DALL OR DUSER TO INDICATE SCOPE OF MESSAGE
:		    SVAREA - THE SAVE AREA LABEL
:
	MO	.,DEBUGR
:
:	DEBUGGING ROUTINE TO DISPLAY A MESSAGE UPON OCCURANCE OF AN EVENT
:	IF A PARTICULAR DEBUG BIT HAS BEEN SET. MESSAGE MAY BE SENT TO ALL
:	USER WITH THE PROPER DEBUG BIT SET OR ONLY TO A USER IF THE BIT IS
:	SET AND HE CAUSED THE EVENT.
:
:	ARGUMENTS: R2 - ADDRESS OF SIX BYTE PARAMETER STRING
:		BYTES   0 - 3  ADDRESS OF MESSAGE (AN SC CONSTANT OR LIKE)
:			   4  DEBUG BIT NUMBER
:			   5  ALL/USER INDICATOR (0=USER 1=ALL)
:
	PROC(DEBUGR)
	LB	R3,4,R2		:LOAD PARM
	TBT	R3,SYSDBG	:IS DEBUG BIT SET?
	JE	DONE		:NO... SKIP TO END
	LB	R4,5,R2		:LOAD PARAMETER
	L	R2,0,R2		:LOAD PARAMETER
	LB	R0,0,R2		:GET MESSAGE LENGTH
	LR	R5,R0		:SAVE R0
	AIS	R2,1		:INCREMENT MSG POINTER
	CHAIN(DSAVE)
	LHI	R10,(NDEBUG-1)*DEBLNG :SET UP LOOP POINTER
LOOP	TBT	R3,DEBUG+4,R10	:CHECK USER DEBUG BIT
	JE	ENDLOP		:BIT NOT SET...SKIP
	LR	R4,R4		:CHECK IF MSG TO ALL OR USER
	JNFS	ALL		:SEND TO ALL
	CL	RUBLK,DEBUG,R10	:CHECK IF CURRENT USER CAUSED EVENT
	JN	ENDLOP		:NO...SKIP
	CALL(SENDMS,DSAVE)
	JFS	DONE		:ONLY ONE USER CAN MATCH
:
ALL	L	RUBLK,DEBUG,R10	:LOAD UBLOCK ADDR OF USER TO GET MSG
	LR	R0,R5		:RESTORE R0
	CALL(SENDMS,DSAVE)
:
ENDLOP	SHI	R10,DEBLNG		:DECREMENT LOOP POINTER
	JGE	LOOP		:REPEAT IF > 0
DONE	RETURN(RUBLK)
:
:	CLEAR DEBUG USER ROUTINE TO CLEAR THE CURRENT USER (RUBLK) FROM
:	THE DEBUG TABLE (IF PRESENT). THE ROUTINE GBLDBG IS
:	INVOKED.
:	ARGUMENTS: RUBLK - USER BLOCK ADDRESS
:
	PROC(CLRDBG)
	LHI	R13,(NDEBUG-1)*DEBLNG :SET UP LOOP POINTER
CLOOP	CL	RUBLK,DEBUG,R13	:COMPARE USER BLOCK ADDR 
	JEFS	CMATCH		:MATCH... SKIP
	SHI	R13,DEBLNG	:DECREMENT LOOP POINTER
	JGEBS	CLOOP		:REPEAT IF > 0
:
	RETURN(R13)
:
CMATCH	LIS	R9,0		:INIT TO ZERO
	ST	R9,DEBUG,R13	:ZERO OUT ENTRY
	ST	R9,DEBUG+4,R13
	ST	R9,DEBUG+8,R13
	ST	R9,DEBUG+12,R13
	ST	R9,DEBUG+16,R13
	ST	R9,DEBUG+20,R13
	INVOKE(GBLDBG)
:
:	GLOBAL DEBUG ROUTINE TO 'OR' THE DEBUG BITS TOGETHER FOR
:	SYSDBG.
:	ARGUMENTS: NONE
:
	PROC(GBLDBG)
	LR	R5,RSAVE	:SAVE RSAVE
	L	R6,DEBUG+4	:LOAD FIRST DEBUG USER'S BITS
	L	R7,DEBUG+8
	L	R8,DEBUG+12
	L	R9,DEBUG+16
	L	R10,DEBUG+20
	LHI	R4,(NDEBUG-2)*DEBLNG : SET UP LOOP POINTER
GLOOP	LM	R11,DEBUG+DEBLNG+4,R4 : GET ALL THE USER DEBUG BITS
	OR	R6,R11		:OR THE BITS TOGETHER
	OR	R7,R12
	OR	R8,R13
	OR	R9,R14
	OR	R10,R15
	SHI	R4,DEBLNG	:DECREMENT LOOP POINTER
	JGEBS	GLOOP		:REPEAT IF > 0
	ST	R6,SYSDBG	:STORE THE SYSTEM DEBUG BITS
	ST	R7,SYSDBG+4
	ST	R8,SYSDBG+8
	ST	R9,SYSDBG+12
	ST	R10,SYSDBG+16
	LR	RSAVE,R5	:RESTORE RSAVE
	RETURN(R4)
:
:	INIT DEBUG ROUTINE TO INITIALIZE THE SYSTEM AND USER DEBUG BITS
:	ARGUMENTS: NONE
:
	PROC(INIDBG)
	LR	R9,RSAVE	:SAVE RSAVE
	LIS	R10,0		:INIT REGS TO ZERO
	LIS	R11,0
	LIS	R12,0
	LIS	R13,0
	LIS	R14,0
	LIS	R15,0
	STM	R11,SYSDBG	:INIT THE SYSTEM DEBUG BITS
	LHI	R8,(NDEBUG-1)*DEBLNG : SET UP LOOP POINTER
ILOOP	STM	R10,DEBUG,R8	:INIT THE USER DEBUG AREA
	SHI	R8,DEBLNG	:DECREMENT LOOP POINTER
	JGEBS	ILOOP		:REPEAT IF > 0
	LR	RSAVE,R9	:RESTORE RSAVE
	RETURN(R8)
:
	EM

: TRACE.02T  COPIED FROM
:            (MATS.P2)TRACE.01K  11/25/81.
:            HAS NEW TRACE MESSAGES FOR "RECEIVER" MESSAGES WITH
:            VARIABLE LENGTHS.


: TRACE.01K COPIED FROM
: (MATS.PRD)TRACE.NXX 10/15/80

	RA	0	:RADIX TO HEX
:
	GL	TVLDTR,TLUD1,TLUD2,TZAP,TTIMOT,TABEND,THSKPR,TSTATC,TMAGMS
	GL	TCMD,TAGID,TRSRSP,TTID,TAUAMT,TMAGMD,TRIATA,GLBEVT
        GL      MAGSND,TINIT,USRCMD
:
:	GLOBAL EVENTS
:
TVLDTR	EQ	1
TLUD1	EQ	2
TLUD2	EQ	3
TZAP	EQ	4
TTIMOT	EQ	5
TABEND	EQ	6
THSKPR	EQ	7
TSTATC	EQ	8
TMAGMS	EQ	9
TAGID	EQ	0A
TAUAMT	EQ	0B
TMAGMD	EQ	0C
MAGSND  EQ      0D
TINIT	EQ	0E
GLBEVT	EQ	100
:
:	LOCAL EVENTS
:
TCMD	EQ	101
TRSRSP	EQ	102
TTID	EQ	103
TRIATA	EQ	104
:
	RA	$00A	:RADIX TO DECIMAL
:
	GL	TRCLOG,TRCMAG,TRCPRT
:
TRCLOG	EQ	0	:LOGON/LOGOFF/DISC MONITOR BIT
TRCMAG	EQ	1	:MAG ACTIVITY MONITOR BIT
TRCRV1	EQ	2	:RESERVED
TRCRV2	EQ	3	:RESERVED
TRCPRT	EQ	4	:START OF PORT BITS
:
:	TRACE LOG MACRO TO DETERMINE IF TRACE LOG BIT IS SET AND
:	CALL THE MONITOR MESSAGE ROUTINE
:	ARGUMENTS: PNAME - ROUTINE TO SEND MONITOR MESSAGE
:		   SVAREA - SAVE AREA
:
TRLOG	MACRO(PNAME,SVAREA)
[
		ST	R6,TRCREG
		LIS	R6,TRCLOG	:LOAD TRACE BIT
		TBT	R6,SYSTRC	:TEST BIT
		JEFS	.+$A14		:NOT SET.. SKIP
		GL	PNAME
		LA	RSAVE,SVAREA,,
		JAL	RLINK,PNAME,,
		L	R6,TRCREG	]
:
:	TRACE PORT MACRO TO TEST IF PORT BIT IS SET AND CALL MONITOR
:	MESSAGE ROUTINE.
:	ARGUMENTS: PNAME - ROUTINE TO SEND MONITOR MESSAGE
:		   SVAREA - SAVE AREA
:
TRPORT	MACRO(PNAME,SVAREA)
[
		ST	R6,TRCREG
		LR	R6,RUBLK	:TEST IF NEGATIVE PORT #
		JLFS	.+$A26		:YES.. SKIP REST OF CODE
		LH	R6,0,RUBLK	:GET PORT #
		AIS	R6,4
		TBT	R6,SYSTRC
		JEFS	.+$A14	:SKIP REST OF CODE
		GL	PNAME
		LA	RSAVE,SVAREA,,
		JAL	RLINK,PNAME,,
		L	R6,TRCREG	]
:
	MO	.,TRACE
:
:	TRACE ROUTINE TO ENTER EVENT MESSAGES INTO THE TRACE RING AND
:	TO DISPLAY THE EVENT MESSAGE TO USER WHO HAVE REQUESTED GETTING
:	THIS INFORMATION.
:	ARGUMENTS: R2 - EVENT MSG POINTER
:
	PROC(TRACE)
	LR	R8,RSAVE	:SAVE THE RSAVE REGISTER
	L	R9,TRCPTR	:GET POINTER TO TRACE RING ENTRY
	LM	R10,0,R2	:GET EVENT MESSAGE
	STM	R10,0,R9	:STORE IT IN RING
	LR	RSAVE,R8	:RESTORE RSAVE
	AHI	R9,24		:INCREMENT RING POINTER
	CHI	R9,TRCEND	:CHECK IF PAST END OF RING
	JLFS	STORE		:IT IS NOT... SKIP 
	LA	R9,TRCRNG	:SET POINTER TO BEGINNING
STORE	ST	R9,TRCPTR	:STORE POINTER
:
	LIS	R9,DBGRNG	:LOAD BIT NAME FOR DISPLAY RING
	TBT	R9,SYSDBG	:DOES ANYONE HAVE THE BIT SET?
	JNFS	SEARCH		:YES... SKIP
	RETURN(R8)		:NO.. ALL DONE
:
SEARCH	LHI	R7,(NDEBUG-1)*24 :SET UP LOOP POINTER
	LIS	R4,0		:SET UP MSG CREATED FLAG
	SRL	R10,16		:SHIFT EVENT CODE INTO HALFWORD
	CLHI	R10,GLBEVT	:IS THIS A GLOBAL EVENT?
	JGFS	LOCAL		:NO.. SKIP
	LIS	R5,1		:SET GLOBAL EVENT FLAG
	JFS	LOOP
LOCAL	LIS	R5,0		:SET LOCAL EVENT FLAG
:
LOOP	TBT	R9,DEBUG+4,R7	:TEST USER DISPLAY RING BIT
	JEFS	ENDLOP		:NOT SET... SKIP
	LR	R5,R5		:IS THIS A GLOBAL EVENT?
	JGFS	GLOBAL		:YES
	CL	RUBLK,DEBUG,R7	:WAS EVENT CAUSED BY THIS USER?
	JEFS	PMSG		:YES.. PREPARE AND SEND MSG
ENDLOP	SHI	R7,24		:DECREMENT LOOP POINTER
	JGEBS	LOOP		:REPEAT IF > 0
	RETURN(RUBLK)
:
GLOBAL	L	RUBLK,DEBUG,R7	:LOAD USER BLOCK ADDRESS
	LR	R4,R4		:LOAD MSG CREATED FLAG
	JG	MSGRDY		:MESSAGE ALREADY CREATED
:
:	PREPARE THE MESSAGE
:
PMSG	CHAIN(TSAVE)
	LI	R8,RNGMSG	:LOAD MESSAGE DATA AREA ADDRESS
	LR	R10,R2		:LOAD ADDRESS OF EVENT MESSAGE
	LIS	R9,2		:PREPARE TO CONVERT TWO BYTES
	CALL(BINHEX,TSAVE)
	AIS	R10,2		:INCREMENT MSG BYTE POINTER
				:CONVERT TWO MORE BYTES
	CALL(BINHEX,TSAVE)
	AIS	R10,2		:INCREMENT MSG BYTE POINTER
	LIS	R9,4		:FOUR BYTES TO CONVERT
	LIS	R6,5		:SET UP LOOP COUNTER
MLOOP	CALL(BINHEX,TSAVE)
	AIS	R10,4		:INCREMENT MSG BYTE POINTER
	SIS	R6,1		:DECREMENT LOOP COUNTER
	JGBS	MLOOP		:REPEAT IF > 0
	LI	R2,TRCMSG	:LOAD MSG POINTER FOR SENDMS
	LIS	R9,DBGRNG	:RELOAD BIT POINTER
	LIS	R4,1		:SET MSG CREATED FLAG
:	MESSAGE IS CREATED!
MSGRDY	LHI	R0,56		:LOAD LENGTH ARGUMENT FOR SENDMS
	CALL(SENDMS,TSAVE)
	LR	R5,R5		:TEST GLOBAL EVENT FLAG
	JG	ENDLOP		:CONTINUE LOOP IF GLOBAL. IF LOCAL
				:THEN ONLY ONE MATCH POSSIBLE
	RETURN(R3)
:
	SEG	2
TRCMSG	AC	/"8D"8A/	:CR AND LF
RNGMSG	BS	55	:DATA AREA TO CREATED OUTPUT MESSAGE
:
:	MONITOR MESSAGE ROUTINES ARE USED TO SEND A PARTICULAR MESSAGE
:	TO THE APPROPRIATE MONITOR SCREENS.
:	ARGUMENTS: R6 - TRACING BIT NUMBER
:
	PROC(ULOGON)
	LI	R2,TMSG1	:LOAD MESSAGE ADDRESS
        LHI     R8,LTMSG1
	J	COMMON
:
	PROC(ULOGOF)
	LI	R2,TMSG2	:LOAD MESSAGE ADDRESS
        LHI     R8,LTMSG2
	J	COMMON
:
	PROC(URECON)
	LI	R2,TMSG3	:LOAD MESSAGE ADDRESS
        LHI     R8,LTMSG3
	J	COMMON
:
:       R2 must contain RES block
:
	PROC(USWTCH)
	LHL	R10,RBRESC,R2	:get res code
	STB	R10,TMSG4+$A52,,	: into message
	SRLS	R10,8	: Note: not halfword boundary
	STB	R10,TMSG4+$A51,,	: into message
	LI	R2,TMSG4	:LOAD MESSAGE ADDRESS
        LHI     R8,LTMSG4
	J	COMMON
:
	PROC(UDISC)
	LI	R2,TMSG5	:LOAD MESSAGE ADDRESS
        LHI     R8,LTMSG5
	J	COMMON
:
	PROC(UFORCD)
	LI	R2,TMSG6	:LOAD MESSAGE ADDRESS
        LHI     R8,LTMSG6
	J	COMMON
:
	PROC(UTIMEO)
	LI	R2,TMSG7	:LOAD MESSAGE ADDRESS
        LHI     R8,LTMSG7
	J	COMMON
:
	PROC(TRPBOT)	:PURPLE BALL OUTPUT
	CHAIN(TRPBSV)
	LA	R8,TMSG8+$A27,,
	LIS	R9,1
	LA	R10,MAGSEQ,RUBLK
	CALL(BINHEX,TRPBSV)
	LA	R2,TMSG8,,
        LHI     R8,LTMSG8
	J	COMMN2
:
:
:
	PROC(TRPBIN)
	CHAIN(TRPBS2)
	LI	R8,TMSG9+$A27,
	LIS	R9,1
	LA	R10,MAGSEQ,RUBLK
	CALL(BINHEX,TRPBS2)
	LI	R2,TMSG9,
        LHI     R8,LTMSG9
	J	COMMN2
:
:
:
	PROC(TRSTUP)
	LI	R2,TMSG10,
        LHI     R8,LTMG10
	J	COMMN2
:
:
:
	PROC(TRDOWN)
	LI	R2,TMSG11,
        LHI     R8,LTMG11
	J	COMMN2
:
:
:
	PROC(TRRS)		:RESET
	LI	R2,TMSG19,
        LHI     R8,LTMG19
	J	COMMN2
:
:
:
	PROC(TRBP)
	LI	R2,TMSG12,
        LHI     R8,LTMG12
	J	COMMN2
:
:
:
	PROC(TRRBPI)
	LI	R2,TMSG13,
        LHI     R8,LTMG13
	J	COMMN2
:
:
:
	PROC(TRCOER)		:COMM ERR
	LI	R2,TMSG20,
        LHI     R8,LTMG20
	J	COMMN2
:
:
	PROC(TRTPB)		:TEXT WITH PURPLE BALL
	CHAIN(TRTPSV)
	LI	R8,TMSG21+$A32,
	LIS	R9,1
	LA	R10,MAGSEQ,RUBLK
	CALL(BINHEX,TRTPSV)
	LI	R2,TMSG21,
        LHI     R8,LTMG21
	J	COMMN2
:
:
:
:
	PROC(TRRBPO)
	LI	R2,TMSG14,
        LHI     R8,LTMG14
	J	COMMN2
:
:
:
	PROC(TRAPPR)
	LI	R2,TMSG15,
        LHI     R8,LTMG15
	J	COMMN2
:
:
:
	PROC(TRZAPI)
	LI	R2,TMSG16,
        LHI     R8,LTMG16
	J	COMMN2
:
:
:
	PROC(TRZAPO)
	LI	R2,TMSG17,
        LHI     R8,LTMG17
	J	COMMN2
:
:
:
:
: TRDATA EXPECTS THE RUBLK TO POINT TO THE USER THAT IS
: BEING TRACE, BUT MUST ALSO CONTAIN THE MAGTAB ENTRY FOR THE
: INCOMING MESSAGE (OUTGOING TO THE USER) IN R8
:
:
	PROC(TRDATA)
	CHAIN(TRDTSV)
:
	LR	R5,R8	:SAVE THE MAGTAB POINTER
	GL	OUTBUF
	LA	R10,OUTBUF,,
	LHI	R9,$A20
	LA	R8,TMSG18+$A24,,	:PRINT OUT FIRST 20 CHAR TO USER
	CALL(BINASC,TRDTSV)
:
:
	LA	R10,1,RUBLK	:POINT TO 2ND CHAR OF PORTNUM
	LIS	R9,1
	LA	R8,TMSG18+$A50,,
	CALL(BINHEX,TRDTSV)
:
	LA	R2,TMSG18,,
        LHI     R8,LTMG18
	LH	R3,AUBAID,RUBLK
	STH	R3,$A54,R2
	LR	R3,RSAVE	:SAVE THIS REGISTER
	LM	R13,AUBUSR,RUBLK
	STM	R13,$A58,R2
	LR	RSAVE,R3
	LHI	R8,LTMG18	:GET MSG LENGTH
	LR	RUBLK,R5	POINT TO MAGTAB ENTRY
	J	COMMN2
:
:
        PROC(USRCMD)
:
        CHAIN(USRCSV)
        LA      R10,CMDDAT,,    :GET ADDR OF BUFFER AREA
        LIS     R11,$A 10       :10 CHARS MAX
        LHI     R12,$0 0A0      :LOAD A BLANK
        LA      R13,TMSG22+$A45,,  :AREA FOR COMMAND STRING
USRLOP  LB      R9,0,R10        :LOAD A BYTE OF ADATA
	JEFS	USRDON
        CLB     R12,0,R10       :CHECK FOR A BLANK
        JEFS    USRDON  :JUMP IF DONE
        STB     R9,0,R13        :STORE A BYTE
        AIS     R10,1
        AIS     R13,1
        SIS     R11,1           :DECREMENT COUNTER
        JNBS    USRLOP          :JUMP IF 10 MOVED
USRDON  LA      R2,TMSG22,,      :0GET ADDR OF MSG
        LHI     R8,LTMG22
	LR	R11,R11	SEE HOW MANY CHAR LEFT
	JE	COMMON	JUMP IF NONE
USRDLP	STB	R12,0,R13	STORE IN A BLANK
	AIS	R10,1
	AIS	R13,1
	SIS	R11,1
	JNBS	USRDLP
        J       COMMON          :GO TO COMMON ROUTINE
:
:
:   TRSTFM - ALLOWS TRACE OF USER CHOSEN SOURCE BUFFER WITH VARIABLE LENGTH
:            ASSUMES - R1 IS POINTER TO AUB OR MSC TABLE.
:                      R9 IS LENGTH OF TEXT (TRSTFM CHECKS FOR MAX OF 20)
:                      R10 IS STARTING ADDRESS OF SOURCE BUFFER.
:     TRSTFM SENDS A MESSAGE WITH "fm" IN IT. INDICATES FROM RECEIVER.
:
:
        PROC(TRSTFM)
        CHAIN(TRCSV1)
:
        CI      R9,$A 20        : LENGTH OF MESSAGE > 20 ?
        JLE     SAME1           : NO, JUST LEAVE IT ALONE
        LI      R9,$A 20        : YES, SET IT TO 20  - MAX
SAME1   SIS     R9,1            : ADJUST LENGTH FOR COMPARES
        LI      R2,$A 19        : BLANK FROM RIGHT TO LEFT
        LI      R3,$0 0A0       : R3 := BLANK
BLNK1   CLR     R2,R9           : BLANKED UP TO TEXT ?
        JE      SKP1            : YES
        STB     R3,TMSG23+$A50,R2,
        SIS     R2,1            : NO, BLANK MSG LOOP
        J       BLNK1

SKP1    AIS     R9,1            : RESTORE LENGTH BACK TO ORIG VAL
        LA      R8,TMSG23+$A50,, :GET MSG STRING ADDRESS
        CALL(BINASC,TRCSV1)     : TRACE IT

        LA      R2,TMSG23,,
        LI      R8,LTMG23
        J       COMMON

:
:
:   TRSTTO - ALLOWS TRACE OF USER CHOSEN SOURCE BUFFER WITH VARIABLE LENGTH
:            ASSUMES - R1 IS POINTER TO AUB OR MSC TABLE.
:                      R9 IS LENGTH OF TEXT (TRSTTO CHECKS FOR MAX OF 20)
:                      R10 IS STARTING ADDRESS OF SOURCE BUFFER.
:     TRSTTO SENDS A MESSAGE WITH "to" IN IT. INDICATES TO RECEIVER.
:
:
        PROC(TRSTTO)
        CHAIN(TRCSV2)
:
        CI      R9,$A 20        : LENGTH OF MESSAGE > 20 ?
        JLE     SAME2           : NO, JUST LEAVE IT ALONE
        LI      R9,$A 20        : YES, SET IT TO 20  - MAX
SAME2   SIS     R9,1            : ADJUST LENGTH FOR COMPARES
        LI      R2,$A 19        : BLANK FROM RIGHT TO LEFT
        LI      R3,$0 0A0       : R3 := BLANK
BLNK2   CLR     R2,R9           : BLANKED UP TO TEXT ?
        JE      SKP2            : YES
        STB     R3,TMSG24+$A50,R2,
        SIS     R2,1            : NO, BLANK MSG LOOP
        J       BLNK2


SKP2    AIS     R9,1            : RESTORE LENGTH BACK TO ORIG VAL
        LA      R8,TMSG24+$A50,, :GET MESSAGE STRING ADDRESS
        CALL(BINASC,TRCSV2)     : TRACE IT

        LA      R2,TMSG24,,
        LI      R8,LTMG24
        J       COMMON


:
:
: CONTROL L

:
:
:	R2 HAS ADDR OF MESSAGE, R8 HAS LENGTH
:
COMMON	CHAIN(TRSAVE)
	L	R3,GMT,,	:LOAD GMT CLOCK VALUE
	LIS	R4,8		:8 DIGIT CLOCK FORMAT
	LR	R5,R2		:ADDRESS OF MESSAGE AREA
	AIS	R5,2		:INCREMENT TO TIME FIELD OF MSG
	CALL(TMSTMP,TRSAVE)
	LR	R5,R8	:SAVE LENGTH OF MSG
	LR	R8,R2		:MSG ADDRESS
	AI	R8,24		:ADD IN OFFSET TO PORT # FIELD
	LR	R10,RUBLK	:TEST RUBLK
	JL	NEGPRT		:JUMP IF NEGATIVE
:
	LH	R10,0,RUBLK	:GET PORT NUMBER
	JEFS	DSCPRT		:JUMP IF ZERO PORT #
	LIS	R9,1		:ONE BYTE TO CONVERT
	LR	R10,RUBLK	:PORT NUMBER ADDRESS
	AIS	R10,1		:WANT SECOND BYTE
	CALL(BINHEX,TRSAVE)
	JFS	AGNTID
:
DSCPRT	LHI	R9,$00E4		: 'd'
	STB	R9,0,R8	
	LHI	R9,$00F3		: 's'
	STB	R9,1,R8
	LHI	R9,$00E3		: 'c'
	STB	R9,2,R8
AGNTID	LH	R3,AUBAID,RUBLK :GET AGENT ID
	STH	R3,28,R2	:STORE IT IN PROPER FIELD
	LR	R3,RSAVE	:SAVE RSAVE
	LM	R13,AUBUSR,RUBLK :LOAD USER NAME
	STM	R13,32,R2	:STORE IN PROPER FIELD
	LR	RSAVE,R3
	LR	R8,R5	RESTORE LENGTH OF MESSAGE
	INVOKE(MREADY)
:
NEGPRT	XI	R10,-1		:CONVERT PORT # TO POSITIVE
	AIS	R10,1
	LIS	R9,1		:ONE BYTE TO CONVERT
	STH	R10,PRTTMP	:STORE IN TEMP LOCATION
	LI	R10,PRTTMP+1	:LOAD ADDRESS OF LOC
	CALL(BINHEX,TRSAVE)
	LI	R10,$00A0A0A0A0	:SPACES
	STH	R10,28,R2	:CLEAR OUT AGNT ID
	ST	R10,32,R2	:CLEAR OUT USER ID
	ST	R10,36,R2
	ST	R10,40,R2
	LR	R8,R5	RESTORE LENGTH OF MESSAGE
	INVOKE(MREADY)
:
:	MESSAGE CREATED
:
	PROC(MREADY)
	CHAIN(MRDYSV)
	LHI	R7,(NMON-1)*AMTLNG+AMTTRC : SET UP LOOP POINTER
	LIS	R5,AUBOUT	:CONSTANT FOR OUTPUT MODE CHECK
TRLOOP	TBT	R6,AMTTAB,R7,	:IS BIT SET?
	JNFS	MATCH		:YES.. SKIP
LOOPER	SHI	R7,AMTLNG	:DECREMENT LOOP POINTER
	JGEBS	TRLOOP		:REPEAT IF > 0
	RETURN(RUBLK)
:
MATCH	LR	R0,R8		:LOAD MESSAGE LENGTH
	LI	RUBLK,AMTTAB-AMTTRC :LOAD UBLK POINTER
	AR	RUBLK,R7	:ADD IN OFFSET
	CLB	R5,AUBMOD,RUBLK	:IS USER IN OUTPUT MODE
	JN	LOOPER	DON'T SEND A MSG IF NOT
	CALL(SENDMS,MRDYSV)
	J	LOOPER		:REENTER LOOP
: CONTROL L

COMMN2	CHAIN(TRSAV2)
	L	R3,GMT,,	:GET CLOCK
	LIS	R4,8	: 8 DIGIT CLOCK FORMAT
	LA	R5,2,R2	: POINT TO OUTPUT AREA IN MSG
	CALL(TMSTMP,TRSAV2)
:
	LR	R3,R8	:SAVE MESSAGE LENGTH
	LA	R8,$A14,R2	POINT TO PORT FIELD
	LIS	R9,1	:NUMBER OF OUTPUT DIGITS
:    NEED START ADDRESS OF MEMORY TO PROCESS
:
:  SEE IF NEGATIVE PORT NUMBER
	LR	R10,RUBLK
	JL	NEGPOR	:JUMP IF NEGATIVE PORT
	LA	R10,1,RUBLK	:POINT TO 2ND BYTE OF PORT
	CALL(BINHEX,TRSAV2)
:
: MOVE IN RES CODE
:
	LH	R10,MAGRES,RUBLK
	STB	R10,$A18,R2
	SRLS	R10,8	GET NEXT CHARACTER
	STB	R10,$A17,R2
	LR	R8,R3	:RESTORE MESSAGE LENGTH
	INVOKE(MREADY)	:MESSAGE IS READY
:
NEGPOR	XI	R10,-1
	AIS	R10,1	:POSITIVE PORT NUMBER NOW
	STH	R10,PRTTMP
	LA	R10,PRTTMP+1,
	CALL(BINHEX,TRSAV2)
	LHI	R10,$00A0
	STB	R10,$A17,R2
	STB	R10,$A18,R2
	LR	R8,R3	:RESTORE MESSAGE LENGTH
	INVOKE(MREADY)
:
: CONTROL L - NEW PAGE

	SEG	2
	WS	0
:
: NOTE - 9BF4 IS THE ADM2 SEQUENCE TO ERASE THE REST OF THE LINE
:        ALSO, EACH MESSAGE MUST BE WORD BOUNDED THAT IS USED BY 
:        THE ROUTINE 'COMMON' - AS IT STORES THE 12 CHAR USERNAME
:        VIA A 'STM' COMMAND
:
TMSG1	AC	!"8D"8ANN:NN:NN LOGON   PORT NN  AA//             "9B"F4!
LTMSG1  EQ      .-TMSG1
        WS      0
TMSG2	AC	!"8D"8ANN:NN:NN LOGOFF  PORT NN  AA//             "9B"F4!
LTMSG2  EQ      .-TMSG2
        WS      0
TMSG3	AC	!"8D"8ANN:NN:NN RECONN  PORT NN  AA//             "9B"F4!
LTMSG3  EQ      .-TMSG3
        WS      0
TMSG4	AC	!"8D"8ANN:NN:NN SWITCH  PORT NN  AA//               RES TW"9B"F4!
LTMSG4	EQ	.-TMSG4
        WS      0
TMSG5	AC	!"8D"8ANN:NN:NN DISC    PORT NN  AA//             "9B"F4!
LTMSG5  EQ      .-TMSG5
        WS      0
TMSG6	AC	!"8D"8ANN:NN:NN FORCED  PORT NN  AA//             "9B"F4!
LTMSG6  EQ      .-TMSG6
        WS      0
TMSG7	AC	!"8D"8ANN:NN:NN TIMEOUT PORT NN  AA//             "9B"F4!
LTMSG7  EQ      .-TMSG7
        WS      0
TMSG8	AC	/"8D"8ANN:NN:NN to xx TW pball #xx "9B"F4/
LTMSG8  EQ      .-TMSG8
        WS      0
TMSG9	AC	/"8D"8ANN:NN:NN fm xx TW pball #xx "9B"F4/
LTMSG9	EQ	.-TMSG9
        WS      0
TMSG10	AC	/"8D"8ANN:NN:NN fm xx TW startup "9B"F4/
LTMG10  EQ      .-TMSG10
        WS      0
TMSG11	AC	/"8D"8ANN:NN:NN fm xx TW Airline Down   "9B"F4/
LTMG11  EQ      .-TMSG11
        WS      0
TMSG12	AC	/"8D"8ANN:NN:NN fm xx TW Backpressure   "9B"F4/
LTMG12  EQ      .-TMSG12
        WS      0
TMSG13	AC	/"8D"8ANN:NN:NN fm xx TW Release BP     "9B"F4/
LTMG13  EQ      .-TMSG13
        WS      0
TMSG14	AC	/"8D"8ANN:NN:NN to xx TW Release BP     "9B"F4/
LTMG14  EQ      .-TMSG14
        WS      0
TMSG15	AC	/"8D"8ANN:NN:NN to xx TW Apply Pressure "9B"F4/
LTMG15  EQ      .-TMSG15
        WS      0
TMSG16	AC	/"8D"8ANN:NN:NN fm xx TW Zap "9B"F4/
LTMG16  EQ      .-TMSG16
        WS      0
TMSG17	AC	/"8D"8ANN:NN:NN to xx TW Zap "9B"F4/
LTMG17  EQ      .-TMSG17
        WS      0
TMSG18	AC	!"8D"8ANN:NN:NN fm xx TW txt'XXXXXXXXXXXXXXXXXXXX'!
	AC	!  to XX  AA//AAAAAAAAAAAA "9B"F4!
LTMG18	EQ	.-TMSG18
        WS      0
TMSG19	AC	/"8D"8ANN:NN:NN fm xx TW reset  "9B"F4/
LTMG19  EQ      .-TMSG19
        WS      0
TMSG20	AC	/"8D"8ANN:NN:NN fm xx TW comm err       "9B"F4/
LTMG20  EQ      .-TMSG20
        WS      0
TMSG21	AC	/"8D"8ANN:NN:NN fm xx TW text\pball #xx "9B"F4/
LTMG21  EQ      .-TMSG21
	HS	0
TMSG22   AC      !"8D"8ANN:NN:NN USERCMD PORT NN  AA//             COMD567890 "9B"F4!
LTMG22	EQ	.-TMSG22
        WS      0
TMSG23  AC      !"8D"8ANN:NN:NN fm      PORT NN  AA//              !
        AC      !txt'XXXXXXXXXXXXXXXXXXXX'"9B"F4!
LTMG23  EQ      .-TMSG23
        WS      0
TMSG24  AC      !"8D"8ANN:NN:NN to      PORT NN  AA//              !
        AC      !txt'XXXXXXXXXXXXXXXXXXXX'"9B"F4!
LTMG24  EQ      .-TMSG24
        WS      0
:	CONTROL L - NEW PAGE
	
	PROC(GBLTRC)
:
:	THIS ROUTINE OR'S TOGETHER ALL THE INDIVIDUAL MONITOR TRACE
:		BITS AND DEPOSITS THE RESULTS IN THE GOLBAL TRACE STRUCTURE
:
	LHI	R13,TRBLNG-1	:INDEX TO BYTE WITHIN MONITOR ENTRY
LOOP1	LHI	R12,(NMON-1)*AMTLNG	:INDEX TO ONITOR TABLE
	LIS	R11,0	:CLEAR OR'ED REGISTER
LOOP2	LB	R10,AMTTAB+AMTTRC,R12,R13
	OR	R11,R10	:OR THE BITS TOGETHER
	SHI	R12,AMTLNG	:DECREMENT INDEX TO AMTTAB
	JGEBS	LOOP2	:KEEP LOOPING
	STB	R11,SYSTRC,R13	:STORE THE BYTE
	SIS	R13,1	: KEEP LOOPING FOR ALL THE BYTES
	JGEBS	LOOP1
	RETURN(R10)
:
:	INIT TRACE ROUTINE INITIALIZES THE SYSTEM TRACE BITS
:	ARGUMENTS:  NONE
:
	PROC(INITRC)
	LHI	R13,TRBLNG-1	:SET UP LOOP POINTER
	LIS	R12,0		:INIT REG TO ZERO
ILOOP	STB	R12,SYSTRC,R13	:INIT THE BYTE
	SIS	R13,1		:DECREMENT LOOP POINTER
	JGEBS	ILOOP		:REPEAT IF > 0
	RETURN(R12)
:
	EM


: (MATS.P2)BINHEX.02F
:    Copied by Bonnell from (MATS.P2)BINHEX.01K.  1/27/81
:    Added new procedure--BINHXW

: BINHEX.01K COPIED FROM
: (MATS.PRD)BINHEX.NAD 10/15/80

	RA	$00A	:RADIX TO DECIMAL
:
	GL	DIGIT
:
:	BINHEX IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII HEX CHARACTERS. A SPACE CHARACTER IS APPENDED ON THE
:	END OF THE HEX CHARACTER STRING.
:	ARGUMENTS: R8 - ADDRESS OF WHERE TO PUT ASCII CHARACTERS
:			   THIS REGISTER IS RETURNED UPDATED TO NEXT AVAIL
:				LOCATION
:	           R9 - BYTE COUNT
:		   R10 - START ADDRESS OF MEMORY TO BE PROCESSED
:
	PROC(BINHEX)
LOOP	LB	R11,0,R10	:LOAD BYTE
	LBR	R12,R11		:COPY THE BYTE
	SRHLS	R12,4		:GET FIRST DIGIT
	LB	R13,DIGIT,R12	:GET ASCII CHARACTER
	STB	R13,0,R8	:STORE THE CHARACTER
	LIS	R12,15		:LOAD MASK
	NR	R12,R11		:MASK OFF HIGH DIGIT
	LB	R13,DIGIT,R12	:GET ASCII CHAR
	STB	R13,1,R8	:STORE THE CHARACTER
	SIS	R9,1		:DECREMENT LOOP COUNT
	JGFS	REPEAT		:MORE TO DO?
	LHI	R13,$0 0A0	:LOAD SPACE CHARACTER
	STB	R13,2,R8	:STORE IT
	AIS	R8,3		:INCREMENT STRING POINTER
	RETURN(R9)
:
REPEAT	AIS	R8,2		:INCREMENT STRING POINTER
	AIS	R10,1		:INCREMENT BYTE ADDRESS
	J	LOOP		:REPEAT




:  Procedure BINHXW
:  --------- ------


:    BINHXW converts binary to hex (ASCII characters).  It is similar
:    to BINHEX, except that BINHXW does not append a space to the 
:    output string.


:  Input--

:       R8      Destination address

:       R9      Number of bytes (input) to process

:       R10     Address of first byte (input) to process


:  Output--

:       Character string 

:       R8      Points to first byte following the output string


        PROCS(BINHXW,$0 0D)

BHXWL   SIS     R9,1                    : Reduce count
        JL      BHXWX                   : Done

   : Process byte

        LB      R11,,R10
        SRHLS   R11,4                   : Get high order four bits
        LB      R12,DIGIT,R11           : Convert to ASCII
        STB     R12,,R8                 : Store in output string

        LB      R11,,R10
        NHI     R11,$0 0F               : Get low order four bits
        LB      R12,DIGIT,R11           : Convert to ASCII
        STB     R12,1,R8                : Store in output string

        AIS     R10,1
        AIS     R8,2
        J       BHXWL

BHXWX   RETURN(R9)


:HEXBIN  A routine to convert a hex string into a binary number.
:        Arguments:  R2 - Address of string to convert
:                    R3 - Number of characters in string
:
:        Return:     R0 - 0 if unsuccessful (illegal char), 1 if successful.
:                    R2 - Binary result of conversion (if any),
:                            else left unchanged.

PROC(HEXBIN)
	LIS	R0,0		:NUMBER WILL GO HERE
HB1	SIS	R3,1		:DECREMENT CHARACTER COUNT
	JL	HBDONE		:JUMP IF NONE LEFT
	LIS	R4,$00F	:PTR TO LAST HEX DIGIT IN 'DIGIT' STRING
	LB	R5,0,R2		:GET A CHARACTER OF INPUT STRING
HB2	CLB	R5,DIGIT,R4	:COMPARE WITH 'DIGIT' STRING
	JEFS	HB3		:JUMP ON MATCH
	SIS	R4,1		:ELSE DECREMENT 'DIGIT' POINTER
	JGEBS	HB2	:AND TRY AGAIN UNLESS AT END.

	LIS	R0,0		:CHARACTER NOT MATCHED - FAILURE RETURN
	RETURN(R2)

HB3	SLHLS	R0,4		:MULTIPLY BY 10 (HEX)
	AR	R0,R4		ADD IN THIS DIGIT
	AIS	R2,1
	J	HB1		:AND GO ON TO NEXT.

HBDONE	LR	R2,R0		:RETURN VALUE IN R2
	LIS	R0,1		:SUCCESSFUL RETURN
	RETURN(R3)
:

: BINDEC.01K COPIED FROM
: (MATS.PRD)BINDEC.NAD 10/15/80

	PROC(BINDEC)
:	BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII DECIMAL CHARACTERS.
:
:	ARGUMENTS: R3 CONTAINS THE BINARY NUMBER
:	           R4 CONTAINS NUMBER OF DIGITS OF OUTPUT
:	           R5 POINTS TO OUTPUT AREA
:
:	FIRST CHECK FOR A NEGATIVE NUMBER
:		IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
	LR	R3,R3	: TEST FOR NEGATIVE NUMBER
	JGEFS	NOTNEG	:JUMP IF NOT NEGATIVE
	LHI	R6,$0 00AD	:'ASCII '-'
	STB	R6,0,R5
	SIS	R4,1	: ROOM FOR ONE LESS DIGIT
	AIS	R5,1	: DITTO
	JLE	RTRN	:NO ROOM FOR DIGIT AFTER MINUS SINE
:	COMPLEMENT THE NUMBER TO POSITIVE
	XI	R3,-1
	AIS	R3,1
NOTNEG	SIS	R5,1
	LIS	R6,$A 10	: DIVISOR
DIVIDE	SR	R2,R2	: CLEAR HI ORDER BITS OF DIVIDEND
	DR	R2,R6	:GET LOW DIGIT IN R3
	LB	R7,DIGIT,R2	:GET ASCII EQUIVALENT OF DEC NUMBER
	STB	R7,0,R4,R5	:STORE IN REVERSE ORDER
	SIS	R4,1	:DECREMENT COUNTER
	JGBS	DIVIDE	: KEEP LOOPING
	SR	RRETC,RRETC
RTRN	RETURN(R1)
:
: DIGIT IS AN AC STRING IN SEG0.CSA WHICH LOOKS LIKE THIS-
: DIGIT AC /0123456789ABCDEF/
:	IT IS USED BY BINHEX ALSO.
:

: (MATS.P2)BINASC.02T
:   COPIED FROM  (MATS.P2)BINASC.01K BY BYRNE  ON 12/07/81.
:   CHANGED ENTRIES 23 AND A3 FROM '.' TO '#'  .

: BINASC.01K COPIED FROM
: (MATS.PRD)BINASC.NAD 10/15/80

	RA	$00A
	PROC(BINASC)
:
: BINASC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION TO
: ASCII CHARACTERS.  INVALID CHARACTERS ARE TRANSLATED TO PERIODS (.)
:
: ARGUMENTS
:    R8 - ADDRESS OF WHERE TO PUT TRANSLATED CHARACTERS
:    R9 - NUMBER OF BYTES TO TRANSLATE
:    R10- ADDRESS OF AREA TO START TRANSLATING
:
LOOP	LB	R11,0,R10
	LB	R11,BINTAB,R11,
	STB	R11,0,R8
	AIS	R8,1
	AIS	R10,1
	SIS	R9,1
	JGBS	LOOP
	RETURN(R8)
:
:
	SEG	2
BINTAB	AC	/................/ 00
	AC	/................/ 10
	AC	X ..#$%&'()*+,-./X 20
	AC	/0123456789....../ 30
	AC	/.ABCDEFGHIJKLMNO/ 40
	AC	/PQRSTUVWXYZ...../ 50
	AC	/.abcdefghijklmno/ 60
	AC	/pqrstuvwxyz...../ 70
	AC	/................/ 80
	AC	/................/ 90
	AC	X ..#$%&'()*+,-./X A0
	AC	/0123456789....../ B0
	AC	/.ABCDEFGHIJKLMNO/ C0
	AC	/PQRSTUVWXYZ...../ D0
	AC	/.abcdefghijklmno/ E0
	AC	/pqrstuvwxyz...../ F0
	SEG	1

:
:   Procedure:  DECBIN - Decimal to Binary
:
:       Decimal to binary conversion routine.
:
:   Input:
:
:       CHRBUF - Address of characters (Passed in R4)
:       CHRCNT - Count of characters to be converted (Passed in R5)
:       
:   Output:
:
:       BINNUM - Converted decimal number in binary.  Zero if any
:           error encountered.  (Returned in R3)
:       ERROR - Error flag.  FALSE = No error.  TRUE = Error. 
:           (Returned in R2)
:
:
:************************************************************************
:
:
        PROCS(DECBIN,A.CUCD)
        CHAINS(DECBSV,A.CUCD)

        LIS     R2,FALSE                : Initialize error flag to FALSE
        LIS     R3,0                    : Initialize Binary number to zero
        LIS     R6,0                    : Initialize loop index to zero

DBLOOP  CR      R6,R5                   : If loop index is GE to character
        JGE     DBDONE                  : count then we are done

        LB      R7,0,R4,R6              : Get next character
        NHI     R7,$07F                 : Keep only the seven data bits
        SHI     R7,$030                 : Convert digit to binary number

        CHI     R7,9                    : If digit's value is greater than
        JG      DBBAD                   : nine then we have not a digit
        CHI     R7,0                    : If digit's value is less than zero
        JGE     DBGOOD                  : then we have not a digit

DBBAD   LIS     R3,0                    : Set binary number to zero
        LIS     R2,TRUE                 : Make error flag TRUE
        J       DBDONE                  : It's all over

DBGOOD  LHI     R8,$A10                 : Place ten in reg for later multiply
        LIS     R9,0                    : Set R9 and R10 to current value of
        LR      R10,R3                  : binary number
        MR      R9,R8                   : Multiply the binary number by 10
        AR      R10,R7                  : Add the latest digit value
        LR      R3,R10                  : Save new binary number in R3
        AIS     R6,1                    : Bump loop index by one
        J       DBLOOP                  : Return to top of loop

DBDONE  RETURN(R4)                      : Return, restoring from R4

: (MATS.P2)DATIME.03F
:    Copied by Bonnell from (MATS.P2)DATIME.02W
:    Made corrections in DANTIM.

: (MATS.P2)DATIME.02W
:    Copied from DATIME.01K
:
: DATIME.01K COPIED FROM
: (MATS.PRD)DATIME.NAD 10/15/80
:
	RA	$0 0A
	MO	.,DATIME
	PROC(DATIME)
	CHAIN(DATSAV)
:	THIS PROCEDURE CONVERTS THE GMT CLOCK
:	RELATIVE TO 1/1/74 FROM SECONDS TO
:	DDMMMYY HH:MM (GMT) OR
:	DDMMMYY HH:MM:SS (GMT)
:
:	PARMS
:		R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:		R4 = CHARACTERS OF OUTPUT (13 OR 16)
:		R5 = ADDRESS OF OUTPUT STRING
:
	S	R3,SEC745	
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULARE YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2	: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	ST	R2,TIMEDY	:SAVE TIME OF DAY
	SR	R2,R2	:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
	LHI	R8,76	:BASE YEAR
	SLL	R3,2	:QUAD YEAR * 4
	AR	R8,R3	:ADD TO BASE YEAR
	LI	R7,LEPYEA	:POINT TO AYS IN MONTH
	C	R2,W366	:IS IT IN CURRENT YEAR?
	JL	MONTHD	:JUMP IF SO
	S	R2,W366	:SUBTRACT DYAS IN YEAR
	AIS	R8,1	:ADD 1 TO YEAR
	LR	R11,R2	:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
MONTHD	SR	R6,R6	:MONTH COUNTER
	AIS	R2,1	:MAKE 1/1/76 = DAY 1
MONLOP	LR	R3,R2	:SAVE DAYS
	LB	R9,0,R6,R7	GET DAYS IN MONTH
	SR	R2,R9	:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1	:INCREMENT INDEX
	JBS	MONLOP
:
:	DAYS IN R3
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
:       SAVE R4 AND R5
DAZE	LR	R11,R4
	LR	R12,R5
:
:	CONVERT DAY
	LIS	R4,2	:# OF OUTPUT CHARACTERS
	CALL(BINDEC,DATSAV)
:
:	MOVE IN MONTH
	AIS	R5,2
	SIS	R11,2	:DECREMENT DAYS PLACE
	SLL	R6,2	:MULTIPLY MONTH NUMBER BY 4
	L	R4,MONTHS,R6	:GET THE NAME IN R4
	STB	R4,2,R5
	SRL	R4,8
	STB	R4,1,R5
	SRL	R4,8
	STB	R4,0,R5
	AIS	R5,3
	SIS	R11,3
:
:	CONVERT YEAR
	LR	R3,R8
	LIS	R4,2
	CALL(BINDEC,DATSAV)
	LHI	R3,$00A0	:ASCII SPACE
        STB     R3,2,R5         : PUT IT AFTER DATE
	SIS	R11,3
	AIS	R5,3
	L	R3,TIMEDY
        LR      R4,R11          : GET TIME
:
:	GET THE TIME STAMP
:
	CALL(TMSTMP,DATSAV)
:
	RETURN(R1)
:
:************************************************************************
:
	PROC(TMSTMP)
:
:	THIS PROCEDURE CONVERTS THE FULLWORD TIME OF DAY FROM
:	SECONDS TO HH:MM OR HH:MM:SS
:
:		PARMS:
:			R3 = FULLWORD TIME OF DAY
:			R4 = 5 OR 8 (# OF CHARACTERS)
:			R5 = FULLWORD ADDRESS OF OUTPUT
:
:
:	DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:	IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:	ROUTINE IS ALL ABOUT
	SR	R8,R8	:INDEX FOR OUTPUT AREA
:
	SR	R2,R2	:CLEAR HI-OR@ER BITS
	D	R2,SECDAY
:		SECONDS NOW IN R2
	LR	R3,R2	:GET READY FOR
	SR	R2,R2	:ANOTHER DIVIDE
	D	R2,TENOUR	:GET TENS OF HOURS
	JAL	R6,ASCOUT	:PRINT IT OUT IN ASCII
	DH	R2,OURS	:GET HOURS
:		R2 HAS REMAINDER, R3 HAS QUOTIENT
	JAL	R6,ASCOUT	:PRINT IT OUT
	LHI	R3,$00BA	:COLON
	JAL	R6,PRTOUT
	DH	R2,TENMIN
	JAL	R6,ASCOUT
	DH	R2,MIN
	JAL	R6,ASCOUT
:	THE CONDITION CODE HAS BEEN SET -
:	SET IF ANY MORE CHARACTER WANTED
	JE	RETRN	:JUMP IF ONLY 5 CHAR
:
:	PUT IN COLON BEFORE SECONDS
	LHI	R3,$00BA
	JAL	R6,PRTOUT
	DH	R2,TENSEC
	JAL	R6,ASCOUT
	LR	R3,R2	:GET SECONDS IN R3
	JAL	R6,ASCOUT
RETRN	SR	RRETC,RRETC
	RETURN(R1)
:
:***********************************************************************
:
	PROC(DANTIM)
	CHAIN(DANTSV)
:	THIS PROCEDURE CONVERTS THE GMT CLOCK
:	RELATIVE TO 1/1/74 FROM SECONDS TO
:       YYMMDDHHMMSS (GMT)
:       YYMMDDHHMM (GMT)
:
:	PARMS
:		R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:		R4 = CHARACTERS OF OUTPUT (10 OR 12)
:		R5 = ADDRESS OF OUTPUT STRING
:
	S	R3,SEC745	
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULARE YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2	: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	ST	R2,TIMEDY	:SAVE TIME OF DAY
	SR	R2,R2	:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
	LHI	R8,76	:BASE YEAR
	SLL	R3,2	:QUAD YEAR * 4
	AR	R8,R3	:ADD TO BASE YEAR
	LI	R7,LEPYEA	:POINT TO AYS IN MONTH
	C	R2,W366	:IS IT IN CURRENT YEAR?
	JL	SMNTHD	:JUMP IF SO
	S	R2,W366	:SUBTRACT DYAS IN YEAR
	AIS	R8,1	:ADD 1 TO YEAR
	LR	R11,R2	:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
:
SMNTHD	SR	R6,R6	:MONTH COUNTER
	AIS	R2,1	:MAKE 1/1/76 = DAY 1
SMNLOP	LR	R3,R2	:SAVE DAYS
	LB	R9,0,R6,R7	GET DAYS IN MONTH
	SR	R2,R9	:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	SDAZE:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1	:INCREMENT INDEX
	JBS	SMNLOP
:
:	DAYS IN R3
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
SDAZE   LR      R9,R3                   : Save number of days

        LIS     R4,2                    : Set field width to 2

        LR      R3,R8                   : Get years 
        CALL(BINDEC,DANTSV)             : Write years out
        AIS     R5,2                    : Update output address

        LR      R3,R6                   : Get months - 1
        AIS     R3,1                    : Make months - 0
        CALL(BINDEC,DANTSV)             : Write months out
        AIS     R5,2                    : Update output address

        LR      R3,R9                   : Get days from register saved in
        CALL(BINDEC,DANTSV)             : Write out days
        AIS     R5,2                    : Update output address

        L       R3,TIMEDY,,             : Get time of day
        LIS     R4,6                    : Make time field width 6 chars
        CALL(STSTMP,DANTSV)             : Write out time

        RETURN(R1)                      : Return restoring from R1
:
:************************************************************************
:
:
:   PROCEDURE - SHORT TIME STAMP (STSTMP)
:
:	THIS PROCEDURE CONVERTS THE FULLWORD TIME OF DAY FROM
:	SECONDS TO HHMM OR HHMMSS
:
:		PARMS:
:			R3 = FULLWORD TIME OF DAY
:			R4 = 4 OR 6 (# OF CHARACTERS)
:			R5 = FULLWORD ADDRESS OF OUTPUT
:
:
:	DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:	IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:	ROUTINE IS ALL ABOUT
        PROC(STSTMP)
	SR	R8,R8	:INDEX FOR OUTPUT AREA
:
	SR	R2,R2	:CLEAR HI-OR@ER BITS
	D	R2,SECDAY
:		SECONDS NOW IN R2
	LR	R3,R2	:GET READY FOR
	SR	R2,R2	:ANOTHER DIVIDE
	D	R2,TENOUR	:GET TENS OF HOURS
	JAL	R6,ASCOUT	:PRINT IT OUT IN ASCII
	DH	R2,OURS	:GET HOURS
:		R2 HAS REMAINDER, R3 HAS QUOTIENT
	JAL	R6,ASCOUT	:PRINT IT OUT
	DH	R2,TENMIN
	JAL	R6,ASCOUT
	DH	R2,MIN
	JAL	R6,ASCOUT
:	THE CONDITION CODE HAS BEEN SET -
:	SET IF ANY MORE CHARACTER WANTED
	JE	SRETRN	:JUMP IF ONLY 4 CHAR
:
	DH	R2,TENSEC
	JAL	R6,ASCOUT
	LR	R3,R2	:GET SECONDS IN R3
	JAL	R6,ASCOUT
SRETRN	SR	RRETC,RRETC
	RETURN(R1)
:
:
ASCOUT	AHI	R3,$00B0
PRTOUT	STB	R3,0,R8,R5
	AIS	R8,1	: UPDATE INDEX
	SIS	R4,1
	JR	R6
:
:*************************************************************************
:
	SEG	0

SECDAY	WC	24*60*60	:SECONDS IN A DAY
TENOUR	WC	10*60*60	:TENS OF HOURS
OURS	HC	60*60	:HOURS
TENMIN	HC	10*60	:TENS OF MINS
MIN	HC	60	:MIN
TENSEC	HC	10	:TENS OF SECS
SEC745	WC	24*60*60*365*2
W365	WC	365
W366	WC	366
TIMEDY	WS	1
QUADAY	WC	4*365+1
LEPYEA	BC	31,29,31,30,31,30,31,31,30,31,30,31
REGYER	BC	31,28,31,30,31,30,31,31,30,31,30,31
	WS	0
MONTHS	AC	/ JAN/
	AC	/ FEB/
	AC	/ MAR/
	AC	/ APR/
	AC	/ MAY/
	AC	/ JUN/
	AC	/ JUL/
	AC	/ AUG/
	AC	/ SEP/
	AC	/ OCT/
	AC	/ NOV/
	AC	/ DEC/
	SEG	1
	EM

:(MATS.P2)MSGS.S02
:	Copied by Margalit from .S01	2/9/87
:	Rearanged the entire file

:(MATS.P2)MSGS.S01
:       Copied by chen from MSGS.15A on 1/27/87
:       Added new messages
:(MATS.P2)MSGS.15A
:	Copied by Margalit from 14E	5/29/85
:	Changed all the msgs that had the word AIRLINE in them.

: (MATS.P2)MSGS.14E
:       Copied by Gauci from .13S     5-mar-85
:       Changed text of Agent_Id prompt (removed Mars+ case)

: (MATS.P2)MSGS.13S
:    Copied by Gimnicher from (MATS.P2)MSGS.12P.  3-12-84
:    Changed text of NSACMD and NCLPFK messages.

:(MATS.P2)MSGS.12P
:	Copied by Mele from (MAST.P2)MSGS.11L on 12/23/83
:	Some messages changed for the Marsplus case
:
:(MATS.P2)MSGS.11L
:	Copied by Cardini from (MATS.P2)MSGS.10P on 12/16/83
:	in order to introduce some messages for MARSPLUS (under conditional
:	assembly).
:
:(MATS.P2)MSGS.10P
:Copied by Mele from (MATS.P2)MSGS.09P on 10/21/83
:Added NTRMAR,LOGSIN,NSACMD for MARSPLUS project.
:Also added the  prompt to the TYPERR message.

: (MATS.P2)MSGS.09P
:Copied by Mele form (MATS.P2)MSGS.08L on 9/1/83
:Added TYPERR
: (MATS.P2)MSGS.08L
: COPIED BY VAUSBURD FROM (MATS.P2)MSGS.07L ON 12.08.81
:Fixed misspelling in CLOMSA msg.
: (MATS.P2)MSGS.07L
: Copied by Vaysburd from (MATS.P2)MSGS.06B on 11.24.81
: Added new messages for "CLOSE", "DROP" and "OPEN" monitor commands.
:  MSGS.06B COPIED FROM (MATS.P2)MSGS.05L  1/28/81
:       CR AND LF REMOVED AND MESSAGES BROKEN UP TO LESS THAN ONE LINE
:
:  MSGS.05L COPIED FROM(MATS.P2)MSGS.04S
:       PRINTER MESSAGES ADDED
:
: (MATS.P2)MSGS.04S
:    Copied by Gimnicher from (MATS.P2)MSGS.03S.  1/12/81
:    Messages for printer project added.


: (MATS.P2)MSGS.03S
:    Copied by Gimnicher from (MATS.P2)MSGS.02S.  12/16/80
:    OWL support from (FRICKEL)MSGS.01B merged into this file.

: (STEVEG)MSGS.02S copied from (MATS.DEV)MSGS.NNN on 10-13-80
: by Steve Gimnicher in order to add messages for the Monitor
: Screen Formatter implementation.
:
:MSGS.STR  Message strings for IMATS.




:	START-UP MESSAGES

	SEG	0

BRESMS  SC      /Res number NNN in startup MAG message not in MAGCON/
WRESMS  SC      /Duplicate startup MAG message with wrong res number - NNN/

        SEG     1               :read only

DUPLOG  SC      /Duplicate logon...logoff complete/ :duplicate MAG logon


:	LOGIN MESSAGES(VALDTR)

LNREJM	SC	/Not valid user on this computer/	: not in LUD
HIFMSG	SC	/Host Interface not available/		: MAGSTA = NA
SRVMSG	SC	/Service not available.  Please try later/	: MAGSTA=DN
LUDMSG	SC	/LUDREQ Failed/
NRBMSG	SC	/Failed to allocate a RES block/
AUBMSG	SC	/Failed to allocate a User block/
ADRMSG	SC	/There are no addresses available. Please try later./
NOPRTM	SC	/System out of ports - Max users are logged in./
ALRMSG	SC	/User already logged in....logoff complete./

:	AGENT ID

ALRNM1  SC      /Your agent identifier is already logged in./
ALRNM2  SC      /What is your agent identifier please?>/
VLAIDM	SC	/What is your agent identifier please?>/
ADMS21  SC      /That agent identifier isn't recognized./
ADMS22  SC      /What is your agent identifier please?>/

:	TERMINAL TYPE

TRMMSG	SC	/"8D"8AWhat kind of terminal are you using?>/
INVTT1  SC      /That terminal isn't familiar./
INVTT2  sc      /What kind of terminal are you using?>/

:	MULTIPLE ACCESS(RES)

RBOVRF	SC	/** Out of RB's ** Can not connect this Host/
RNOTAV	SC	/Host Interface not available(multiple access)/
RNORSP	SC	/Service not available(multiple access)/
NTRRES	SC	/What Service would you like to use?/
INVRES	SC	/That Service code isn't familiar/
RECMSG	SC	/Reconnected/                        
MAXLOG	SC	/All your circuits to this Service are in use/

:	ACTIVE SESSION(USER INPUT)

RSBPMS	SC	/Please repeat.  Unable to send message/
RSNAMS	SC	/Service has stopped polling/		: MAGSTA = DN
RSNRMS	SC	/Connection to Host Interface has been lost/  :  = NA
BDXLAT  SC      /Invalid character in input.  Please reenter/
BADPFK  SC      /Unrecognizable function key/
TMANYC	SC	/You typed too many characters.  Please reenter/
NSACMD	SC	/Command invalid in this system./
TIMEUP  SC      /Command Time Out... Logoff complete.../

:	Auto Signin

SINPRO  SC      /Sign_in in process...../
SINFSR  SC      /Sign_in to service failed - Circuit zapped./
SINFMR  SC      /Sign_in to service failed, if you wish try another service./


:	OTHER COMMANDS

GDBYE	SC	/Logoff complete.../
NOUSER	SC	/Userid not logged on"8D"8A/
MAXMON	SC	/Maximum number of monitors exceeded/
MSGSET	SC	/Log msg set/
MSCLRD	SC	/Log msg cleared/
MSOVFL	SC	/Msg too long/
MSNONE	SC	/No msg/
INVCMD	SC	/Invalid command/
NOTYET	SC	/This command not supported yet/
MAGNA	SC	/MAG not available/
NOTONF	SC	/First parm not ON or OFF/
TRCRST	SC	/TRACE reset/
TRSETT	SC	/TRACE set/
BADPRM	SC	/Invalid parameter to command/
MAXDBG  SC      /Maximum number of debug users exceeded/
INVBIT SC       /Invalid bit string/
INVSUB  SC      /Invalid subsystem name/
DBGSET	SC	/DEBUG set/
DBGRST	SC	/DEBUG reset/
DBGOFF	SC	/DEBUG off/
SUBSET  SC      /SUBSYSTEM set/
CRLSET	SC	/CARL set/
CRLRST	SC	/CARL reset/
CRLMSG	SC	/(PARS ||) /
LLOCK	SC	/System busy.  Please try again/
TYPERR  SC	/Please type to the right of '>'/
:
: MESSAGES FOR QUERY COMMAND
:
NOLOG	SC	/No users logged onto system/
LOGGON	SC	/Port in process of logon/
FREPRT	SC	/Port not active/
NGPORT	SC	/Port number out of bounds/
:
: MSGS FOR TALK COMMAND
:
MSGSNT	SC	/Message sent/
BDEST	SC	/Bad destination/
:
: MESSAGES FOR FORC COMMAND
FRCUSR	SC	/Logoff forced by system/
:
USRFRC	SC	/USER FORCED OFF/
:
:

NCLPFK  SC      /Function key not valid/
:
:
:
NOTCON	SC	/Not connected to a reservation system/
HSHUT	SC	/Host shut...not available for logins/
HANSWR	SC	/Host answered...available for logins/
ATTMSG  SC      /Printer now attached/
WRONAP  SC      /Unable to attach printer - user or res not valid for printing/
ATTSTR  SC      !/ATTPTR!       : used for string comparison.
WRATMG  SC      !Enter Host code or Host code followed by /ATTPTR!
:
: Messages for new monitor commands - DROP, CLOSE and OPEN.
:
CLOMS1  SC      /MATS is already in the process of closing/
CLOMS2  SC      /MATS is already closed/
CLOMS3  SC      /MATS is now closed/
CLOMS4  SC      /Closing process started/
CLOMS5  SC      /MATS is already in the process of dropping/
CLOMS6  SC      /No circuit present to drop/
CLOMS7  SC      /Dropping process started/
CLOMS8  SC      /MATS is now opened/
CLOMS9  SC      /MATS is not closed/
CLOMSA  SC      /MATS is in the middle of building circuit.Try in a few minutes./

: (MATS.P2)DIRZAP.02W
:    Fixed comma comma bugs.  9/29/81

: (MATS.P2)DIRZAP.01F
:    Created by Bonnell.    9/04/81
 
:  PROCEDURE DIRZAP (port number)  --  Direct zap

:       This procedure zaps the circuit associated with an ISIS relative
:       port.  It does so by putting a zap message in ORING.  Thus, it is a
:       direct zap procedure.  (The TTMS subroutine ZAPPRT puts a zap
:       mesage in the port output buffer, and thus does an "indirect" zap.)

:       Unlike the TTMS routine ZAPPRT (see FILE PAR2IO), DIRZAP does not
:       invoke or call INITPT.

:       DIRZAP is similar to the subroutine ZAPPRT in the latest version
:       of FRONT.LIB.  Unlike the FRONT.LIB subroutine, however, DIRZAP does
:       not set the FRONT.LIB wait-for-zap-acknowledgement bit.

:       DIRZAP is compatible with the version of FRONT.LIB now used in
:       MATS [ (MATS.P2)FRONT2.01S].  DIRZAP resets appropriate bits in
:       FRONT.LIB bit arrays and empties the port input and
:       output buffers.



:  Input:

:       R1      port number (ISIS relative port)



        PROCS(DIRZAP,A.CUCD)

        LHI     R2,$09F                 : ISIS zap message
        LIS     R0,3                    : Length of message
        JAL     R4,SLOR,,               : Start putting message in ORING
        JAL     R4,ELOR,,               : End message

:    Clean up FRONT.LIB bits

        LO      FRONT

        RBT     R1,ACP
        RBT     R1,DEM
        RBT     R1,GBALL
        RBT     R1,PTIME

        FO      FRONT

:    Empty port input and output buffers

        SLHLS   R1,2                    : Input-buffer index
                                        :    ( 4*<port number> )
        JAL     R4,EMPTY,,

        AIS     R1,2                    : Output-buffer index
                                        :    ( 4*<port number> + 2 )
        JAL     R4,EMPTY,,


        RETURN(R1)


:(TIGERDEV)EDIT.01C
:       Copied by Chen from (TEST.INA)EDIT.01A on 6/14/85
:       Made a new directory for Flying Tiger project.
:
:(TEST.INA)EDIT.01A
:	Copied by Margalit from (MATS.P2)EDIT.05L	6/6/85
:	translate C.R to L.F for FLYING TIGERS


:TEXACT:
:	Is a MACRO called by EDIT to take action we need for
:	TEXT action type
:
:	Input RUBLK :negative port number or AUB pointer
:	      R0    :contains the character
:	      R12    :Edit Index
:	      R5    :Max Index
:
:	Output R11   :Return Flag
:	       R12   :Edit index
:	       R5   :Max  index
:
:	Global input:
:	       EDIBUF :Address of edit buffer




TEXACT  MACRO  [
:
          LR	R12,R12				:Set condition code
	  IFF(L,THEN)				:Is edit index <0
	    LCS	R11,1				:Set return flag
	    LA	R2,TYPERR			:
	    CALL(SENDIT,EDISAV)			:Send message
	    CALL(NEWLIN,EDISAV)			:New line
	    CALL(CIB,EDISAV)			:Clear buff
	  ORELSE
            OHI R0,$0 80			:Convert to 8 bit ASCII
	    STB	R0,EDIBUF,R12,,			:Put charct. into Edit buff.
	    CR 	R12,R5				:
	    IFF(E,THEN)				:If edit buff=max index
	      AIS	R5,1			:Yes increase max index
	    ENDIF
	    AIS	R12,1				:Incr. edit index
	  ENDIF
	  ]



:EDIT

:    EDIT is a general purpose input editing routine for all
:    terminals. EDIT's initial use is primarily for the addition
:    of editing functions for the SCANSET, particularly the
:    backspace, horizontal tab, and line-delete functions.
:    EDIT is called at the beginning of every activation routine
:    which subsequently calls READ. The output variable called
:    Edit_Buffer contains the edited input stream. Edit_Buffer is
:    used as an input parameter to the READ routine.




:    Input:  negative port# or AUB pointer (RUBLK)
:            R2 = Activation_Character{-1 if not activation character}
:
:
:    Output: R3 = Return_Flag  -2 :Activation character is Line_Delete
:                              -1 :Cursor_Error cursor too far to the
:                                               left
:                               0 :Normal case, terminator found and
:                                               edited data returned
:
:
:   Global output:
:	     EDILEN - Number of characters in  edit buffer
:	     EDINDX - Next character to be read in edit buffer
:

	PROC(EDIT)
	CHAIN(EDISAV)


	LR	R7,R2				:Save activation character
	LR	R6,R1				:Is the port number negative?
	IFF(GE,THEN)
	   LH	R6,AUBPRT,RUBLK			:Get port number
	   L	R9,AUBTIB,RUBLK			:Pointer to TIB
	   LA	R9,TIBCLS,R9			:Get pointer to TIBCLS
	ORELSE
	   XI	R6,-1				:Take two's complement of R6
	   AIS  R6,1				:Make port number positive
	   LA	R9,TIBCLS+TIB315,,		:Get pointer to TIBCLS
	ENDIF                                   :

	SLHLS	R6,2				:Imput buffer number
	SR	R11,R11				:Set return flag to 0
	LH	R5,BCT,R6
	IFF(G,THEN)				:Is bufferlet empty?
          SR	R12,R12				:Set edit index to 0
	  SR   	R5,R5				:Set max index to 0
	  LR	R2,R2				
	  IFF(GE,THEN)				:If not activation char. skip
	    LB   R8,CHCLSS,R7,			:Get activation char. class
	    LB   R8,0,R8,R9			:Get in R8 action type
	    CLHI R8,LLIDEL
      	    IFF(E,THEN)				:Is it line delete?
	      CALL(CIB,EDISAV)			:To empty bufferlets
	      LCS  R11,2 			:Set return flag
            ENDIF				:Act.type not delete line
          ENDIF					:Activation char. is not -1      
          LHL	R8,BCT,R6
:
:     DO WHILE Characters are left in bufferlets AND
:              Return flag is 0
:
 	  DO(WHILE,G)				:Is bufferlet empty?
	  LR 	R11,R11				:Activation code still 0?
	  EXITDO(N)
	    LR	R8,R1				:Save R1
	    LR	R1,R6				:Put in R1 inp.buff for GCI
	    JAL	R4,GCI,,			:Get character from input buff.
	    LR	R1,R8				:Restore R1 value
	    LR  R8,R0
	    LB	R8,CHCLSS,R8,			:Get activation char. class
	    LB	R8,0,R8,R9			:Get in R8 action type
	    SLHLS R8,2				:Prepare R1 fo jump table
            J	JTAB,R8				:Jump to table

:
:	   Create jump table
:
JTAB	WS 	0
EDQQ    EQ	0
	RE	AC.NUM				:Create a label for each action
	 J	EDCAS|$0 EDQQ|			
EDQQ    EQ      EDQQ+1			
	ER
:
:



EDCAS|$0CURLFT|	SIS	R12,1			:Decrement Edit index if left act
                  J	ENDEDC
:
EDCAS|$0CURRIT|	CLR	R12,R5			:Cursor right action
		IFF(E,THEN)			:Is edit index=max index?
		  LHI	R8,$00A0		:Put blank in R9
		  STB	R8,EDIBUF,R12,		:Put in edit buf[edit index]
		  AIS	R5,1			:Incremnt max index
		ENDIF
		AIS	R12,1			:Increment edit index
		J 	ENDEDC
:
EDCAS|$0IGNCHA|	J	ENDEDC			:Ignore action
:
EDCAS|$0ENDLIN|	CHI	R7,$0 0A		:activation chr is L.F?
		IFF(E,THEN)
		  LR	R0,R7
  		  TEXACT			:replace C.R with L.F
		ENDIF
		J	ENDEDC
:
EDCAS|$0UPRTXT|	TEXACT				:Text action
		J	ENDEDC
:
EDCAS|$0LOWTXT|	XHI	R0,$0 20		:conv. in up. case
       		TEXACT
		J	ENDEDC
:
EDCAS|$0LLIDEL|  J	ENDEDC			:del line case
:
EDCAS|$0CHADEL| SIS	R12,1			:decrement edit index
		SIS	R5,1			:decrement max index
		J	ENDEDC
:
ENDEDC	   LH	R8,BCT,R6			:Is the bufferlet empty?
           ENDDO
:
:
           CR	R12,R5
           IFF(L,THEN)				:If edit index<max index
	     LR	R12,R5				:Set edit index to max index
	   ENDIF
:
         ENDIF					:Bufferlets not empty
         STH	R12,EDILEN,,			:Update char.numb. in ed.buff
         SR	R12,R12
         STH    R12,EDINDX,,			:Index of the first character
         LR	R3,R11				:Return flag

  RETURN(R4)




:(mats.p2)PAR2IO.S03
:       Copied by chen from .s02 on 2/10/87
:       change instruction LH R7,AUBTYP,RUBLK to  LB R7,AUBTYP,RUBLK
:(TIGERDEV)PAR2IO.S02
:       Copied by Byrne from (TIGERDEV)PAR2IO.01C on 8-Aug-86
:       Moved banner string(s) to configuration.
:
:(TIGERDEV)PAR2IO.01C
:       Copied by Chen from (TEST.INA)PAR2IO.01A on 6/14/85
:       Made a new directory for Flying Tiger project.
:
:(TEST.INA)PAR2IO.01A
:	Copied by Margalit from (MATS.P2)PAR2IO.01A
:	Changed ULITE for FLYING TIGERS
:	Changed the Banner for Flightline

:USERIO.NAD  Contains routines which perform I/O to user, programmer
:     and monitor terAminals.  Most of them have to interface with
:     the ISIS library routines.

	MO	.,USERIO
	LO	MAIN
        SEG     0
	RA	$0 0A
        GL      V.LUD.
	GL	VARHEL		:Mars+ Help Flag
VARHEL	BC	0

:GCED MACRO:
:	The GCED 's use is to get a character from a buffer of 
:	specified address , this macro also returns the index
:	of the next character to be read
:
:   Input :INDBUF  -Register contain. the index to the next character to be read
:	   ADDBUF  -Register containing the buffer address
:	   LENBUF  -Register containing the numb. of char. in the buffer
:
:   Output:R0      -Character read (-1 if buffer empty)
:	   INDBUF  -Index to the next character
:
GCED	MACRO(INDBUF,ADDBUF,LENBUF)
[
	CLR	LENBUF,INDBUF				:Set condition code
	IFF(G,THEN)					:Is buffer not empty?
	   LB	R0,,ADDBUF,INDBUF 			:Load charact. in R0
	   AIS	INDBUF,1				:Point next character
	ORELSE						:Buffer empty
	   LCS	R0,1
	ENDIF
	]


:READ:
:	This routine reads from the EDIBUF into a data area stopping on
:	end-of-input , maximum character read and/or specific character
:	encountered
:
:
:  Input:
:	 R0 - Terminating character (-1 if none)
:	 R2 - Maximum number of characters to read
:	 R3 - Address to start storing characters
:
:  Output:
:	 R0 - end of input :-1
:	      character found :0
:	      maximum character read:1
:	 R2 - number of character read
:
: Global input :
:	 EDIBUF :address of edit buffer
:	 EDINDX :next character to be read
:	 EDILEN :number of characters in edit buffer
:
: Global output :
:	 EDINDX :updated
:
PROC(READ)
	LR	R6,R0					:Terminating character
	LR	R7,R2					:Max character
	LR	R8,R3					:Storage address
	LIS	R0,1					:Set R0 to max.char.
	LH	R11,EDINDX,,				:Set R11 to next char.
	LH	R12,EDILEN,,				:Set R12 to num. of char.
	LA	R10,EDIBUF,,				:Set R10 to buff. addr
	LIS 	R9,0				
	CR	R9,R7					
	DO(WHILE,L)					:Maximum character input?
	   GCED(R11,R10,R12)				:Get charact. from ed.buf
	   LR	R0,R0					:Is buffer empty?
	   EXITDO(L)					:Yes
	   CLR	R0,R6					:
	   IFF(E,THEN)					:Is terminat.charac?
	     LIS	R0,0				:Yes reset R0
	     EXITDO
	   ENDIF
	   STB	R0,0,R8,R9				:Store character
	   AIS	R9,1
	   CLR  R9,R7
	ENDDO
	LR	R2,R9					:Return number of cha.read
	STH	R11,EDINDX,,				:Update EDINDX
	RETURN(R3)
  


:NXTICH:
:	This routine positions Edit Index at next interesting (non
:	blank) character
: Global input:
:         EDIBUF - Address of Edit buffer
:	  EDINDX - Index to next character
:	  EDILEN - Number of characters in Edit buffer
:
: Output  :
:	  R0     - -1 if no characters left
: Global output:
:	  EDINDX - Updated
:

PROC(NXTICH)
	LH	R11,EDINDX,,				:Set R11 to next char.
	LH	R12,EDILEN,,				:Set R12 to num. of char.
	LA	R10,EDIBUF,,				:Set R10 to buff. addr
	DO(FOREVER)
	   GCED(R11,R10,R12)				:Get next character
	   LR	R0,R0					:
	   EXITDO(L)					:If buff.empty exit
	   CLHI	R0,$00A0				:
	   IFF(N,THEN)					:Is space ?
		SIS	R11,1				:Yes decrem. index
		EXITDO
	   ENDIF
	ENDDO
	STH	R11,EDINDX,,				:Update EDINDX
	RETURN(R1)

:SEND-IT  Sends an SC type string to the output buffer, preceded
:         by a new-line.
:    Expects string addr. in R2

PROC(SENDIT)
CHAIN(SENDSV)
	CALL(NEWLIN,SENDSV)
        CALL(LNERAS,SENDSV)     : ERASE LINE IF ADM-2
	LB	R0,0,R2		:GET STRING LENGTH
	AIS	R2,1		:INCREMENT ADDRESS POINTER
	INVOKE(SENDMS)


:SEND-MSG  Sends an AC type string to the output buffer.
:   Expects length in R0, string addr. in R2.

PROC(SENDMS)
CHAIN(SNMSSV)
	LR	R5,R0		MOVE ARGUMENTS
	LR	R6,R2
	LR	R10,R1		:AUB PTR (OR WHATEVER)
	JL	SEND1		:TREAT DIFFERENTLY IF IT IS A PORT NUMBER
        LB      R7,AUBTYP,RUBLK :LOAD TYPE
        CLHI    R7,LUDNUR       :COMPARE TO NORMAL USER
        JE      WRAP            :JUMP IF SO
        CLHI    R7,LUDPUR       :COMPARE TO PROGRAMMER
        JE      WRAP

        J       SEND0           :SKIP WRAPPING CODE FOR OTHER USER TYPES
WRAP    LH      R7,AUBLIN,R10,  :LOAD LINE POSITION
        CLHI    R7,$A24         :COMPARE TO 24
        JLE     NOWRAP          :IF LESS THEN NO PROBLEM
:
:       CODE TO PREVENT WRAPPING
:
        LH      R1,AUBPRT,R10,
        SLHLS   R1,2            :MULT BY 4
        AIS     R1,2            :NOW HAVE BUFFER NUMBER
        LIS     R8,5            :LINE 5
        LIS     R9,1            :COLUMN1
        CALL(VIPOSC,SNMSSV)
        LR      R1,R10          :RESTORE RUBLK
NOWRAP  LH      R7,AUBCOL,RUBLK, :LOAD COLUMN NUMBER
        AR      R7,R0           :ADD LENGTH OF THIS MESSAGE
        STH     R7,AUBCOL,RUBLK :STORE IT BACK
SEND0   LH      R1,AUBPRT,R10   :GET PORT NUMBER
	JFS	SEND2
SEND1	LIS	R1,0
        SR      RUBLK,R10       :MAKE IT POSITIVE
SEND2	SLHLS	R1,2		:CONVERT TO OUTPUT BUFFER NO.
	AIS	R1,2
        PUTSTR(R6,R5)           :write string (pointer, length)
        RETURN(R1)


:       LNERAS ERASE THE LINE IF TERMINAL IS AN ADM-2
:
PROC(LNERAS)
CHAIN(LNERSV)
        LR      R10,RUBLK       :SAVE THE AUB POINTER FOR LATER
        JLE     LNERET          : RETURN IF USER IS SIGNING ON
        LB      R5,AUBTTY,RUBLK :GET THE USERS TERMINAL TYPE
        NHI     R5,AUBVID       :AND WITH VIDEO TERMINAL TYPES
        JE      LNERET          : BRANCH IF NOT ADM-2
        LR      R10,R1          :AUB PTR OR (WHATEVER)
        JL      LNERE1          :TREAT DIFFERENTLY IF IT'S A PORT #
        LH      R1,AUBPRT,R10   :GET PORT #
        JFS     LNERE2
LNERE1  LIS     R1,0
        SR      RUBLK,R10       :MAKE IT POSITIVE
LNERE2  SLHLS   R1,2    :CONVERT TO OUTPUT BUFFER NUMBER
        AIS     R1,2
        CALL(VIERLN,LNERSV)
LNERET  RETURN(R1)


:	ZAP PORT	prints message, then zaps port
:		expects message address in R2.
:
	PROC(ZAPPRT)
	CHAIN(ZAPSV)

	LR	RUBLK,RUBLK	:TEST IF NEG OF PORT #
	JL	ZAP10

        LB      R3,AUBTYP,RUBLK,        : Test user type
        CLHI    R3,LUDNUR               : Normal user?
        JE      ZAP5

        CLHI    R3,LUDPUR               : Programmer user?
        JE      ZAP5

        CLHI    R3,LUDMUR               : Monitor user?
        JE      ZAP5

        J       ZAP10                   : All others

ZAP5    LB      R3,AUBTTY,RUBLK         : Test if video terminal
        NHI     R3,AUBVID
        JE      ZAP7                    : If = 0, not a video terminal

        CALL(NBLOCK,ZAPSV)

ZAP7    CALL(SENDIT,ZAPSV)
        J       ZAP15

ZAP10   LB      R0,,R2                  : Get message length from input string
                                        : pointer (SC format)
        AIS     R2,1                    : Adjust string pointer past length byte
        CALL(SENDMS,ZAPSV)

ZAP15   LA      R2,ZAPMS,,              : Send zap message
        LIS     R0,2                    : Length of zap message
        CALL(SENDMS,ZAPSV)

	INVOKE(INITPT)

ZAPMS	BC	0,$09E		:DETACH MESSAGE

:CIB  Clears the input buffer for the current port.

PROC(CIB)
	LR	RUBLK,RUBLK		:SET COND. CODES
	JL	CIB1
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	CIB2
CIB1	XI	R1,-1		:TWO'S COMPLEMENT
	AIS	R1,1
CIB2	SLHLS	R1,2		:INPUT BUFFER
	JAL	R4,EMPTY,,	:CLEAR BUFFER
	RETURN(R1)


:WRTUNM  Write username and semicolon back in input buffer
:        Expects address of LUD interface block in R2.

PROC(WRTUNM)
	LR	RUBLK,RUBLK		:SET CONDITION CODES
	JL	WRTUN1		:JUMP IF NOT AUT/AMT POINTER
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	WRTUN2
WRTUN1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
WRTUN2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	LR	R5,R2		:MOVE ARGUMENT (WCI DESTROYS R0-R4)
	LIS	R6,12		:MAXIMUM LENGTH OF USERNAME
WRTUN3	LB	R0,LUDNAM,R5	:GET CHAR.
	CLHI	R0,$00A0	:SPACE SIGNALS END OF USERNAME
	JE	WRTUN4
	JAL	R4,WCI,,		:WRITE CHAR
	AIS	R5,1
	SIS	R6,1
	JGBS	WRTUN3		:STOP AFTER 12 CHARS

WRTUN4	LHI	R0,$00BB	:SEMICOLON
	JAL	R4,WCI,,
	RETURN(R1)



:TERMINAL SUPPORT ROUTINES.

	RA	0		:HEX
ESCAPE	EQ	9B		:ESCAPE CHAR.


:NEWLIN  NEW-LINE
:        ADM2: esc,t,US      all others: CR,LF

PROC(NEWLIN)
CHAIN(NEWLSV)
        LR      R10,RUBLK       :SET COND CODES
        JL      NEWLN1          :JUMP IF NEG (NOT AUB/AMT)
:
:       ON RETURN WE WILL BE ONE LINE ADVANCED IN COLUMN ONE
:
        LH      R11,AUBLIN,RUBLK        :LOAD LINE NUMBER
        AIS     R11,1           :INCREMENT BY ONE
        STH     R11,AUBLIN,RUBLK        :STORE IT BACK
        LIS     R11,1           :LOAD A ONE
        STH     R11,AUBCOL,RUBLK        :FORCE COLUMN TO ONE
:
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	NEWLN2
NEWLN1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
NEWLN2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID       :VIDEO TERMINAL??
	JN	NEWLN3		:YES, JUMP
	LHI	R0,8D		:OUTPUT A CR
	JAL	R4,WCI,,
	LHI	R0,8A		:OUTPUT AN LF
	JAL	R4,WCI,,
	RETURN(R1)

NEWLN3  CALL(VIERLN,NEWLSV)
        LB      R5,AUBTTY,R10
        CLHI    R5,AUB470
        JN      NEWLN4
        LHI     R0,8D           :OUTPUT A CR
        JAL     R4,WCI,,
        LHI     R0,8A           :OUTPUT A LF
        JAL     R4,WCI,,
        RETURN(R1)
NEWLN4	LHI	R0,9F		:OUTPUT A US (NEW-LINE)
	JAL	R4,WCI,,
	RETURN(R1)


:LOCKKB  LOCK-KB
:        ADM2: esc,#      all others: no-op

PROC(LOCKKB)
CHAIN(LOKSAV)
        LR      R10,RUBLK               :SET CONDITION CODES
	JL	LOCK1		:JUMP IF NOT AUT/AMT POINTER
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	LOCK2
LOCK1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
LOCK2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID       :AND WITH VIDEO BITS
	JE	LOCK3		:DO NOTHING IF NOT.
        CALL(VILKKB,LOKSAV)

LOCK3	RETURN(R1)


:UNLKKB  UNLOCK-KB
:        ADM2: esc,"      all others: no-op
:        also sets input mode in AUT/AMT for port.

PROC(UNLKKB)
        CHAIN(UNLSAV)
        LR      R10,RUBLK               :SET CONDITION CODES
	JL	UNLK1		:JUMP IF NOT AUT/AMT POINTER
	LIS	R0,AUBINP	:SET INPUT MODE
	STB	R0,AUBMOD,R1	:IN AUT/AMT
	LIS	R0,0
	ST	R0,AUBTIM,RUBLK	:CLEAR TIME
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	UNLK2
UNLK1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
UNLK2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID               :AND WITH VIDEO TERM BITS
	JE	UNLK3		:DO NOTHING IF NOT.
        CALL(VIULKB,UNLSAV)

UNLK3	RETURN(R1)


:SNDSOM  SEND-SOM
:        ADM2: esc,^b      all others: >

PROC(SNDSOM)
CHAIN(SNSMSV)
        LR      R10,RUBLK       :SAVE RUBLK FOR LATER
	JL	SSOM2		:NOT A POINTER
        LB      R5,AUBTTY,RUBLK :GET TERMINAL TYPE
        NHI     R5,AUBVID       :AND WITH VIDEO BITS
        JN      SSOM3           :JUMP IF VIDEO TERMMINAL
	L	R5,AUBARB,RUBLK	:GET ARB POINTER (IF ANY)
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	SLHLS	R1,2		:CONVERT TO BUFFER NUMBER
	AIS	R1,2		:OUTPUT BUFFER
	LR	R5,R5		:IS THERE AN ARB?
	JE	SSOM1		:NO... SKIP
        L       R6,RBPRMP,R5    : If Prompt_String NOT defined
         JE     SSOM05          :  go use the Res Code as prompt
        LB      R7,,R6          : else output the Prompt_String (get cnt)
        DO(COUNT,R7)
          AIS   R6,1
          LB    R0,,R6
          JAL   R4,WCI,,
        ENDDO
        RETURN(R1)

SSOM05	LB	R0,RBRESC,R5	:GET FIRST CHAR OF RES CODE
	JAL	R4,WCI,,
	LB	R0,RBRESC+1,R5	:GET 2ND CHAR
	JAL	R4,WCI,,
SSOM1	LHI	R0,0BE		:> CHAR
	JAL	R4,WCI,,
	RETURN(R1)

SSOM2	XI	R1,-1		:CONVERT TO PORT NUMBER
	AIS	R1,1
	SLHLS	R1,2		:CONVERT TO BUFFER NUMBER
	AIS	R1,2		:OUTPUT BUFFER
	J	SSOM1

SSOM3	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	SLHLS	R1,2		:CONVERT TO BUFFER NUMBER
	AIS	R1,2		:OUTPUT BUFFER
        CALL(VISNSM,SNSMSV)
	RETURN(R1)


:SNDEOM  SEND-EOM
:        ADM2: esc,^c      all others: no-op

PROC(SNDEOM)
CHAIN(SNEMSV)
        LR      R10,RUBLK               :SET CONDITION CODES
	JL	SEOM1		:JUMP IF NOT AUT/AMT POINTER
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	SEOM2
SEOM1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
SEOM2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID       :AND WITH VIDEO TERMINAL BITS
        JE      SEOM3           :JUMP IF NOT VIDEO TERMINAL
        CALL(VICLFD,SNEMSV)
        CALL(VISNEM,SNEMSV)

SEOM3	RETURN(R1)


:GETMSG  GET-MSG
:        ADM2: esc,S      all others: no-op

PROC(GETMSG)
CHAIN(GTMSSV)
        LR      R10,RUBLK               :SAVE AUB POINTER FOR LATER
	JL	GETMS1		:JUMP IF NOT AUT/AMT POINTER
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	GETMS2
GETMS1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
GETMS2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID               :AND WITH VIDEO TERMINAL BITS
        JE      GETMS3          :SKIP IF HARDCOPY
        CALL(VIGTMS,GTMSSV)

GETMS3	RETURN(R1)


:CLSALL  CLEAR SCREEN ALL
:        ADM2: esc,*      all others: no-op

PROC(CLSALL)
CHAIN(CLSSAV)
        LR      R10,RUBLK       :SET CONDITION CODES
	JL	CLALL1		:JUMP IF NOT AUT/AMT POINTER
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	CLALL2
CLALL1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
CLALL2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID       :AND WITH VIDEO BITS
        JE      CLALL3          :DO NOTHING IF NOT VIDEO
        CALL(VICLAL,CLSSAV)

CLALL3	RETURN(R1)


:CLSUNP  CLEAR SCREEN UNPROTECTED
:        ADM2: esc,:      all others: no-op

PROC(CLSUNP)
CHAIN(CLUSAV)
        LR      R10,RUBLK       :SET CONDITION CODES
	JL	CLUNP1		:JUMP IF NOT AUT/AMT POINTER
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	CLUNP2
CLUNP1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
CLUNP2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID       :AND TERM TYPE WITH VIDEO TYPE
        JE      CLUNP3          :SKIP IF NOT VIDEO
        CALL(VICLUP,CLUSAV)

CLUNP3	RETURN(R1)


:ERSUNP  ERASE SCREEN UNPROTECTED
:        ADM2: esc,y      all others: no-op

PROC(ERSUNP)
CHAIN(ERSSAV)
        LR      R10,RUBLK       :SET CONDITION CODES
	JL	ERUNP1		:JUMP IF NOT AUT/AMT POINTER
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	ERUNP2
ERUNP1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
ERUNP2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID       :AND WITH VIDEO BITS
        JE      ERUNP3          :IF HARD .. DO NOTHING
        CALL(VIERUP,ERSSAV)

ERUNP3	RETURN(R1)


:ULITE  UMSG-LITE-ON
:        ADM2: esc,<      all others: no-op
:	Added a CALL to BEEPER for FLYING TIGERS

PROC(ULITE)
	CHAIN(ULTSAV)
:
        IF      \PARSII
:       FOR PARS II JUST RETURN 
:
        RETURN(RRETC)
        EI
        LR      R10,RUBLK       :CHECK FOR NEG PORT NUMBER
	JGFS	ULITE1	:JUMP IF NOT
	RETURN(RSAVE)	:NOTHING TO DO IF SO
ULITE1  LB      R5,AUBTTY,RUBLK :LOAD TERMINAL TYPE
        NHI     R5,AUBVID       :AND WITH VIDEO TERM BITS
        JNFS    ULITE2  :JUMP IF A VIDEO
	LA	R2,ULIT0	:HARDCOPY TERMINAL MESSAGE
	LHI	R0,LULIT0
	J  	ULITE3	:SEND THE MESSAGE
ULITE2  LR      R10,R1          :SET UP FOR VI CALL
        LH      R1,AUBPRT,R10,  :GET PORT
        SLHLS   R1,2            :MULT BY 2
        AIS     R1,2            :NOW BUFFER NUMBER
        CALL(VIUMSN,ULTSAV)
	J	ULITE4
ULITE3	CALL(SENDMS,ULTSAV)
ULITE4	CALL(BEEPER,ULTSAV)
	RETURN(RUBLK)
:
LULIT1	EQ	2
ULIT1	XC	9BBC
 
ULITS	EQ	.
ULIT0	AC	/UMSG waiting"8D"8A/
LULIT0	EQ	.-ULITS



:NULITE  UMSG-LITE-OFF
:        ADM2: esc,>      all others: no-op

PROC(NULITE)
CHAIN(NULSAV)
:
:       FOR PARS II JUST RETURN
:
        RETURN(RRETC)
        LR      R10,RUBLK               :SET CONDITION CODES
	JL	NLITE1		:JUMP IF NOT AUT/AMT POINTER
	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	NLITE2
NLITE1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
	LIS	R5,0		:SET UNKNOWN TERMINAL TYPE (DEFAULT)
NLITE2	SLHLS	R1,2		:BUFFER NUMBER FOR PORT
	AIS	R1,2		:OUTPUT BUFFER
        NHI     R5,AUBVID       :AND WITH VIDEO BITS
        JE      NLITE3
        CALL(VIUMSF,NULSAV)

NLITE3	RETURN(R1)


:BEEPER   SOUNDS BELL ON TERMINAL

	PROC(BEEPER)
	LR	RUBLK,RUBLK	:TEST VALUE
	JLFS	BEEP1		:NOT AN AUT/AMT POINTER
	LH	R1,AUBPRT,RUBLK	:GET PORT NUMBER
	JFS	BEEP2
BEEP1	XI	R1,-1		:CONVERT TO PORT NUMBER
	AIS	R1,1
BEEP2	SLHLS	R1,2		:CONVERT TO BUFFER NUMBER
	AIS	R1,2		:OUTPUT BUFFER
	LHI	R0,87		:BEEL CHARACTER
	JAL	R4,WCI,,		:OUTPUT IT
	RETURN(R1)


:BLOCK  Sets block mode, no echo, on ADM2

PROC(BLOCK)
CHAIN(BLKSAV)
	LA	R2,BLKMSG
	CALL(SENDIT,BLKSAV)
        LR      R10,R1          :LOAD R10 WITH AUB POINTER
        LH      R1,AUBPRT,RUBLK :GET PORT NUMBER
        SLHLS   R1,2            :MULTIPLY BY 4
        AIS     R1,2            :OUTPUT BUFFER NUMBER
        CALL(VIBLKM,BLKSAV)
        RETURN(R1)

BLKMSG	SC	/"00"B1"08"01"00"B1"02"00"00"B1"03"00"00"B1"04"00/


:NBLOCK  Turns off block mode, turns on echo, protect off, clr screen  (ADM2)

PROC(NBLOCK)
CHAIN(NBLKSV)
	LA	R2,NBLKMS
	CALL(SENDIT,NBLKSV)
        LR      R10,R1          :LOAD R10 FOR VIDEO ROUTINE
        LH      R1,AUBPRT,RUBLK :GET PORT NUMBER
        SLHLS   R1,2            :MULTIPLY BY 4
        AIS     R1,2            :ADD 2
        CALL(VICNVM,NBLKSV)
        CALL(VIPROF,NBLKSV)
        CALL(VICLAL,NBLKSV)
        RETURN(R1)

NBLKMS	SC	/"00"B1"08"00"00"B1"02"01"00"B1"03"01"00"B1"04"01/

:
:
: THIS ROUTINE FORMATS THE SCREEN, IF TERMINAL IS AN ADM2, AND
: SENDS OUT THE TTMS MATS BANNER
:
	PROC(FMTSCN)
	CHAIN(FMTSAV)
:
	SEG	1
:
:
:
:
: CODE TO STORE HOST NUMBER FOR DISPLAY
:

   IF  (\MARSP)!(\FLTLIN)
     ELSE

        LH      R3,HOSTS,,      :LOAD HOST NUMBER
        LHI     R4,$A 4         :4 DIGITS FOR DISPLAY
        LA      R5,NUMHST,,     :DATA AREA FOR CHARACTERS
        CALL(BINDEC,FMTSAV)
:
        LIS     R4,0            :OFFSET INTO OUTPUT ARE
        LB      R5,V.LUD.,,     :LOAD LENGTH BYTE
        JE      BLKPAD          :PAD WITH BLANKS IF ZERO LENGTH
        LI      R6,V.LUD.+1      :ADDRESS OF FIRST CHARACTER
VERSLP  LB      R3,,R4,R6       :GET A CHARACTER
        STB     R3,VERSON,R4,   :STORE IT
        AIS     R4,1            :INCREMENT BYTE INDEX
        SIS     R5,1            :SUBTRACT ONE FROM COUNTER
        JN      VERSLP          :IF NOT ZERO .. DO IT AGAIN
: DONE WITH DATA MOVEMENT
BLKPAD  LB      R3,SPACE7,,     :LOAD A BLANK
        LHI     R5,$A30         :LOAD CONSTANT 30 
BLKLOP  CR      R5,R4           :CHECK FOR 30 CHARS TOTAL
        JLE     BLKDON          :IF SO DONE
        STB     R3,VERSON,R4,   :STORE ANOTHER BLANK
        AIS     R4,1            :INCREMENT R4
        J       BLKLOP          :GO TEST AGAIN

	EI

BLKDON  LB      R5,AUBTTY,RUBLK :LOAD TERMINAL BYPE
        NHI     R5,AUBVID       :IS IT A VIDEO TERM
        JN      SNDFUL          :SEND FULL SCREEN IF SO
	CALL(NEWLIN,FMTSAV)
	IF \MARSP

	LB  R2,VARHEL
	IFF(E,THEN)		:IF BANNER CASE
	    LA	R2,BNRSTT,,	:ADDR OF BANNER
	    LHI	R0,LBANR	:LENGTH OF BANNER
	ORELSE			:IF HELP TABLE CASE
	    SR  R2,R2
	    STB R2,VARHEL,,
	    LA R2,HELSTT,,	:ADDRESS OF HELP TABLE
	    LHI R0,LHELP	:LENGTH OF HELP

	ENDIF

	ELSE
	   LA R2,BNRSTT,,
	   LHI R0,LBANR
	EI

	CALL(SENDMS,FMTSAV)
	CALL(NEWLIN,FMTSAV)
	LIS	RRETC,0
	RETURN(RUBLK)
:
:
SNDFUL	CLB	R2,AUBSCN,RUBLK	:IS THE SCREEN ALREADY FORMATTED?
	JNFS	WHATYPE	:JUMP IF NOT
	LIS	RRETC,0
	RETURN(RUBLK)
:
WHATYP	CLHI	R2,SCNPAR	:IS IT A PARS 
	JN	NGSCRN	:JUMP IF NOT PARS
	STB	R2,AUBSCN,RUBLK	:STORE THE TYPE
        LR      R10,RUBLK       :SET UP FOR VI CALLS
        LH      R1,AUBPRT,RUBLK :LOAD PORT NUMBER
        SLHLS   R1,2            :MULTIPLY BY 4
        AIS     R1,2            :OUTPUT BUFFER NUMBER
        CALL(VICLAL,FMTSAV)
        CALL(VILKKB,FMTSAV)
        LB      R5,AUBTTY,R10   :GET TERM TYPE
        CLHI    R5,AUB470       :COMPARE TO 470 TPE
        JE      SCN470
        CALL(VIWPON,FMTSAV)
        CALL(VIPROF,FMTSAV)
        LHI     R8,1            :LOAD LINE NUMBER
        LHI     R9,1            :LOAD COLUMN NUMBER
        CALL(VIPOSC,FMTSAV)
        LR      RUBLK,R10       :RESTORE RUBLK
        LA      R2,BNRSTT,,     :LOAD START OF VIDEO BANNER
        LHI     R0,LVIDBN       :LOAD LENGTH OF VIDEO BANNER
        CALL(SENDMS,FMTSAV)
        LH      R1,AUBPRT,R10   :GET PORT NUMBER
        SLHLS   R1,2            :INPUT BUFFER
        AIS     R1,2            :OUTPUT BUFFER
        LHI     R8,5            :LOAD LINE NUMBER
        LHI     R9,1            :LOAD COLUMN NUMBER
        CALL(VIPOSC,FMTSAV)
        LR      R1,R10          :SET UP FOR SENDMS CALL
        LA      R2,SPACE7,,     :LOAD POINTER TO 7 SPACE
        LHI     R0,7            :LOAD LENGTH
        CALL(SENDMS,FMTSAV)
        LH      R1,AUBPRT,R10
        SLHLS   R1,2            :MULTIPLY BY 4
        AIS     R1,2            :OUTPUT BUFFER
        CALL(VISNSM,FMTSAV)
        LHI     R8,5            :LINE 5
        LHI     R9,$A 73        :COLUMN 73
FMTLOP  LH      R1,AUBPRT,R10
        SLHLS   R1,2            :PORT NUMBER TIMES 4
        AIS     R1,2            :OUTPUT BUFFER
        CALL(VIPOSC,FMTSAV)
        LR      R1,R10          RESTORE RUBLK
        LA      R2,SPAC16,,     :ADDRESS OF 16 SPACES
        LHI     R0,$0 10        :LENGTH
        CALL(SENDMS,FMTSAV)
        AIS     R8,1            :NEXT LINE
        CLHI    R8,$A23         :MORE THAN 23
        JLE     FMTLOP          :IF NO LOOP
        LH      R1,AUBPRT,R10   :GET PRT NUM
        SLHLS   R1,2            :BUFFER
        AIS     R1,2            :OUTPUT BUFFER
        CALL(VIPOSC,FMTSAV)
:
        LR      R1,R10          :RESTORE RUBLK
        LA      R2,SPACE7,,     :LOAD ADDRESS OF 7 SPACES
        LHI     R0,$A 7         :LENGTH
        CALL(SENDMS,FMTSAV)
        LH      R1,AUBPRT,R10   :LOAD PORT NUMBER
        SLHLS   R1,2            :MULT BY 4
        AIS     R1,2            :ADD 2 FOR OUTPUT BUFFER
        CALL(VIWPOF,FMTSAV)
        CALL(VIPRON,FMTSAV)
        LHI     R8,5            :POSITION TO 5,2
        LHI     R9,2    
        CALL(VIPOSC,FMTSAV)
	LIS	RRETC,0
        J       FMTRTN          :JUMP TO RETURN
:
: 470 KLUGE
:
SCN470  LH      R1,AUBPRT,R10   :GET PORT NUM
        SLHLS   R1,2            :MULT 4
        AIS     R1,2            :OUTPUT BUFFNUM
        CALL(VIAPRO,FMTSAV)
:
        LR      R1,R10          :RESTORE RUBLK
        LA      R2,BNRSTT+1,,   :LOAD ONE PAST ADDRE OF BANNER
        LHI     R0,LVIDBN-2     :TWO CHARS SHROT FOR ATTRIBUTE BYTES
        CALL(SENDMS,FMTSAV)
        LH      R1,AUBPRT,R10   :PROT
        SLHLS   R1,2            :MULT 4

        AIS     R1,2            :OUTPUT BUFFER NUM
        CALL(VIANOR,FMTSAV)
:
        LHI     R8,5            :LINE 5
        LHI     R9,1            :COLUMN 1
        CALL(VIPOSC,FMTSAV)
FMTRTN  RETURN(RUBLK)
:
NGSCRN	JAL	R10,CRASH,,
	BC	0,0,4*RLINK,SCNERR	:INVALID SCREEN TYPE
:
:
: SNDBAN - THIS ROUTINE SENDS OUT THE BANNER TO THE TERMINAL
:          WHICH TELLS THE USER THE ACTIVE RES AND THE CONNECTIONS
:          THAT EXISTS.
:
	PROC(SNDBAN)
	CHAIN(BNRSAV)
	SEG	2
	RA	0
	WS	0
BNRSTR	EQ	.
BANNER  AC      /  /    : 2 SPACES
	AC	/AGENT /
AGNTID	AC	/XX/
        AC      /     CRT:  /
AIRCDE	AC	/XX/
        AC      /  LN-IA-TA  /
LNIATA  AC      /DD-EE-FF/
        AC      /       / :7 SPACES
PRTLAB  AC      /PTR:/
        AC      /  /
PRTAL   AC      /GG/
        AC      /  /
PLNLAB  AC      /LN-IA-TA/
        AC      /  /
PLNITA  AC      /HH-II-JJ/
:
BANLNG	EQ	.-BNRSTR
	IF	($A80-(.-BNRSTR))	BLANK OUT REST OF LINE
	RE	($A80-(.-BNRSTR))
	NOLIST
	AC	? ?
	ER
	LIST
	EI
:
: SECOND LINE OF BANNER - CONNECTIONS 
:
BNST2	EQ	.
BANNR2  AC      /      / :7 BLANKS
	AC	/CONNECTIONS:  /
NUMAIR	EQ	.
CONNCT	AC	/XX  XX  XX  XX  XX  XX  XX  XX  /
NUMAIR	EQ	(.-NUMAIR)/4
LBNR2	EQ	.-BNST2	:LENGTH OF 2ND BANNER
	IF	($A80-(.-BNST2))
	RE	($A80-(.-BNST2))	:POINT OUT WITH BLANKS
	NOLIST
	AC	/ /
	ER
	LIST
	EI
BANVDL  EQ      .-BANNER
FULSCN	EQ	.-BNRSTR
PRLAB1  SC      /PTR:/
PRLAB2  SC      /LN-IA-TA/
BLANK4  SC      /    /
BLANK8  SC      /        /
	SEG	1
	RA	$00A
:
:
: THIS ROUTINE EXTRACTS INFORMATION FROM THE AUB (AGENT INITIALS), THE
: ACTIVER RES BLOCK (RESCD AND RSIATA) AND THE RES BLOCK CHAIN
: (RESCD) AND SENDS THE INFO TO THE USER TERMINAL
:
:

  IF (\MARSP)!(\FLTLIN)
   ELSE

	LH	R5,AUBAID,RUBLK
	STB	R5,AGNTID+1,,	:PUT AGENTID IN BANNER
	SRHLS	R5,8
	STB	R5,AGNTID,,	:DITTO
:
	L	R5,AUBARB,RUBLK	GET ADDRESS OF ACTIVE RES
	JE	ERRONE	:IF ZERO WE'VE GOT A PBLM
	LH	R6,RBRESC,R5	:GET THE ACITVE RES CODE
	STB	R6,AIRCDE+1,,
	SRHLS	R6,8
	STB	R6,AIRCDE,,	:STORE THE RES CODE IN THE BANNER
:
:       MOVE LN IA TA TO DISPLAY
:
        LIS     R8,2            :2 BYTES TO MOVE
        LHI     R9,$0 0AD       :LOAD A -
        LA      R6,RBCLIT,R5,   :ADDRESS OF SOURCE LN
        LA      R7,LNIATA,,     :BANNER DESTINATION
        MVS(R6,R7,R8,R10)
        STB     R9,LNIATA+2,,   :STORE A MINUS
        LA      R7,LNIATA+3,,   :DESTINATION
        LIS     R8,2            :MOVE TWO BYTES
        MVS(R6,R7,R8,R10)
        STB     R9,LNIATA+5,,   :STORE A SECOND DASH
        LA      R7,LNIATA+6,,   :DESTINATION
        LIS     R8,2            :MOVE TWO BYTES
        MVS(R6,R7,R8,R10)
:
:       NOW CHECK FOR PRINTER DISPLAY
:
        LH      R6,AUBPTY,RUBLK :LOAD PRINTER TYPE
        JE      NOPRTR          :IF ZERO THEN NO PRINTER
:
:       USER CAN HAVE A PRINTER .. PUT IN LABELS
:
        LA      R6,PRLAB1,,     :ADDRESS OF FIRST LABEL
        LA      R7,PRTLAB,,     :DESTINATION
        MVSSC(R6,R7,R8,R9)      :MOVE IT
:
        LA      R6,PRLAB2,,     :ADDRESS OF SECOND LABEL
        LA      R7,PLNLAB,,     :DESTINATION
        MVSSC(R6,R7,R8,R9)
        L       R5,AUBPRB,RUBLK :LOAD ADDRESS OF ACTIVE PRINTER BLOCK
        JE      NOAGPT          :IF ZERO THEN NO ACTIE PRINTER
:
:       USER HAS PRINTER AND ID VALID TO USE
:
        LH      R6,RBRESC,R5    :RES CODE OF PRINTER RES
        STB     R6,PRTAL+1,,    :STORE SECOND CHAR
        SRLS    R6,8            :SHIFT OFF SECOND CHAR
        STB     R6,PRTAL,,      :STORE FIRST CHAR
:
        LIS     R8,2            :ALWAYS MOVE 2 BYTES
        LHI     R9,$0 0AD       :LOAD A -
        LA      R6,RBPLIT,R5,   :LOAD LINE ADDRESS
        LA      R7,PLNITA,,     :DESTINATION
        MVS(R6,R7,R8,R10)
        STB     R9,PLNITA+2,,   :STORE A DASH
        LA      R7,PLNITA+3,,   :DESTINATION
        LIS     R8,2            :MOVE 2 BYTES
        MVS(R6,R7,R8,R10)
        STB     R9,PLNITA+5,,   :STORE A DASH
        LA      R7,PLNITA+6,,   :DESTINATION
        LIS     R8,2            :MOVE TWO BYTES
        MVS(R6,R7,R8,R10)
        J       CONFMT          :GO TO FORMAT THE CONNECTIONS LINE
:
NOPRTR  LA      R6,BLANK4,,     :ADDRESS OF BLANKS
        LA      R7,PRTLAB,,     :DESTINATION
        MVSSC(R6,R7,R8,R9)
        LA      R6,BLANK8,,     :ADDRESS OF BLANKS
        LA      R7,PLNLAB,,     :DESTINATION
        MVSSC(R6,R7,R8,R9)
NOAGPT  L       R7,BLANK4,,     :LOAD BLANKS
        STB     R7,PRTAL+1,,    :STORE SECOND CHARACTER
        STB     R7,PRTAL,,      :STOE FIRST CHAR
        LA      R6,BLANK8,,     :ADDRESS OF BLANKS
        LA      R7,PLNITA,,     :DESTINATION
        MVSSC(R6,R7,R8,R9)
:
:
:
: CHAIN THRU RB'S EXTRACTING CODE
:
:
CONFMT  LIS     R8,NUMAIR       :GET NUM OF REPITITIONS IN OUTPUT
	LA	R9,CONNCT,,	:GET FIRST OUTPUT FIELD
	L	R6,AUBRCH,RUBLK	:GET FIRST IN CHAIN
	JFS	ANYRES
CHIAN	L	R6,RBNXT,R6
ANYRES	JNFS	GETCD	:JUMP IF THERE IS A RESBLOCK
BLANK	LHI	R7,$00A0A0
	JFS	STH
GETCD	LH	R7,RBRESC,R6
STH	STH	R7,0,R9
	AIS	R9,4	:INCREMENT OUTPUT INDEX
	SIS	R8,1	DECREMENT NUM OF REPITITIONS
	JLFS	WHTERM
	LR	R6,R6	:IS THERE AN VALID RBLOCK
	JEBS	BLANK	:NO - BLANK OUT
	JBS	CHIAN	YES
:
:
: NOW SEND THE 2 LINES :
:
:
WHTERM	LB	R5,AUBTTY,RUBLK	:GET TERMINAL TYPE
        NHI     R5,AUBVID       :AND WITH VIDEO TERM TYPES
        JN      SND440  
:
: SEND HARDCOPY (I.E. ONLY THE DATA, NOT THE CURSOR STUFF)
:
	CALL(NEWLIN,BNRSAV)
	LA	R2,BANNER,,
	LHI	R0,BANLNG
	CALL(SENDMS,BNRSAV)
	CALL(NEWLIN,BNRSAV)
	LA	R2,BANNR2,,
	LHI	R0,LBNR2
	CALL(SENDMS,BNRSAV)
	CALL(NEWLIN,BNRSAV)
	LIS	RRETC,0
	RETURN(RRETC)
:
: SEND TO A 440 TERMINAL :
:
SND440  CLHI    R5,AUB470       :CHECK  FOR 470
        JE      SND470
        LR      R10,RUBLK       :GET READY FOR VI CALLS
        LH      R1,AUBPRT,RUBLK :LOAD PORT NUMBER
        SLHLS   R1,2            :INPUT BUFFER
        AIS     R1,2            :OUTPUT BUFFER
        CALL(VIWPON,BNRSAV)
        CALL(VIPROF,BNRSAV)
        LHI     R8,2            :LINE 2
        LHI     R9,1            :COLUMN 1
        CALL(VIPOSC,BNRSAV)
        LR      RUBLK,R10       :LOAD RUBLK
        LA      R2,BANNER,,     :LOAD ADDRESS OF BANNER
        LHI     R0,BANVDL       :LOAD LENGTH OF STUF TO SND TO SCRN
        CALL(SENDMS,BNRSAV)
        LH      R1,AUBPRT,R10
        SLHLS   R1,2            :MULTIPLY BY 4
        AIS     R1,2            :OUTPUT BUFFER
        CALL(VIWPOF,BNRSAV)
        CALL(VIPRON,BNRSAV)
        LHI     R8,5
        LHI     R9,1            :POSITION CURSOR TO 5,1
        CALL(VIPOSC,BNRSAV)
	LIS	RRETC,0
	RETURN(RRETC)
SND470  LR      R10,RUBLK       :SET UP R10 FOR VI CALLS
        LH      R1,AUBPRT,RUBLK :GET PORT NUMBER
        SLHLS   R1,2            :MULT BY 4
        AIS     R1,2            :NOW HAVE OUTPUT BUFFER NUMBER
        LHI     R8,2            :LOAD LINE NUMBER
        LHI     R9,1            :LOAD COLUMN NUMBER
        CALL(VIPOSC,BNRSAV)
        LR      RUBLK,R10       :RESTORE RUBLK
        LA      R2,BANNER,,     :LOAD ADDRESS OF BANNER
        LHI     R0,BANVDL       :LENGTH TO BE SENT
        CALL(SENDMS,BNRSAV)
        LH      R1,AUBPRT,RUBLK :LOAD PORT NUMBER
        SLHLS   R1,2            :MULT BY 4
        AIS     R1,2            :NOW HAVE BUFFER NUMBER
        LHI     R8,5            :LINE NUMBER
        LHI     R9,1            :COLUMN NUMBER
        CALL(VIPOSC,BNRSAV)
        LIS     RRETC,0
        RETURN(RRETC)
:
: ERROR CONDITIONS
:
ERRONE	LIS	RRETC,1	:NO ACTIVER RB ADDRESS

    EI     :end no MARS+ case

	RETURN(RRETC)
:
:
:
:
	EM

:       REVXNB.01J   Created 08 Feb 81 by J. Burke
:          To turn on Reverse-X-Enable on Agent's Terminal.
 
 
:       Procedure REVXNB - Send a Tymnet Set-Terminal-Characteristics
:       Message to the Agent's terminal setting Reverse-X-Enable to 1.
:       This allows the agent to stop and start printing (or display)
:       by typing CTL-S and CTL-Q (DC3 and DC1).
:       Entry - R1 has AUB pointer.
 
        PROCS(REVXNB,$00D)
        CHAINS(RXNBSV,$00D)
        LA      R2,RXNBME,,             :R2 points to message,
                                        :(R1 has AUB pointer,)
        LA      R0,RXNBML               :R0 contains length ...
        CALL(SENDMS,RXNBSV)             :Send Message to agent.
        RETURN(R0)
 
RXNBME  BC      00,$00B1,$A014,01          :Front.lib escape, Set-Term,
                                        : Subtype X-Enb, Value=On.
RXNBML  EQ      .-RXNBME                :  Message length.
 
:(TIGERDEV)ECHOLF.S01
:	Created by Margalit 	12/12/85
 
:       Procedure ECHOLF - Send a Tymnet Set-Terminal-Characteristics
:       Message to the Agent's terminal setting the echo to a LF as
:	CR/LF/RUB.
:       Entry - R1 has AUB pointer.
 
        PROCS(ECHOLF,$00D)
        CHAINS(ECHOSV,$00D)
        LA      R2,ECHOME,,             :R2 points to message,
                                        :(R1 has AUB pointer,)
        LA      R0,ECHOML               :R0 contains length ...
        CALL(SENDMS,ECHOSV)             :Send Message to agent.
        RETURN(R0)
 
ECHOME  BC      00,$00B1,02,01          :Front.lib escape, Set-Term,
                                        : Subtype echo LF with CR/LF/RUB
ECHOML  EQ      .-ECHOME                :  Message length.
 
:(MATS.P2)INIT.S03
:       Copied by chen from (mats.p2)init.s02 on 1/26/87
: added the initialization of sign_in(SGITMO), sign_off(SGOTMO,SGOHKP)
: removed CALL(FREHKP)
: (TIGERDEV)INIT.S02
: Copied by Byrne from (MATS.P2)INIT.15P on 6-Aug-86
: Renamed PATCH as PCHCOD to eliminate conflict with PATCH.LIB macro.

: (MATS.P2)INIT.15P
: Copied by Melefrom (MATS.P2)INIT.14l on 11/30/83.
:  Added conditional assembly for no CARL case.
:
: (MATS.P2)INIT.13R
: Copied by Cheung from (MATS.P2)INIT.12L on 09/27/82.
: Increased the addr. field for reference of ITTIME, ITCC AND ITCTC.

: (MATS.P2)INIT.12L
: COPIED BY VAYSBURD FROM (MATS.P2)INIT.11F 0N 10.23.81
: CHANGED MAX LENGTH FOR V.LUD ON THE MONITOR SCREEN.

: (MATS.P2)INIT.11F
:    Copied by Bonnell from (MATS.P2)INIT.10W   8/26/81
:    Changed initialization of LSTHST

: (MATS.P@)INIT.10W
:    Copied by John Whitney from (MATS.P2)INIT.09F on 8/22/81
:    Added mats startup record creation record call
:

: (MATS.P2)INIT.09F
:    Copied by Bonnell from (MATS.P2)INIT.08S.  8/20/81
:    Added code to initialize status in MSCTAB.

: (MATS.P2)INIT.08S
:    Copied by Gimnicher from (MATS.P2)INIT.07J.  8/10/81
:    Made changes for MATS STATS project.


: (MATS.P2)INIT.07J
:       Copied from (MATS.P2)INIT.06K by J. Burke 2/08/81
:       Remove debug call from main loop (STUFFI).
 
: (MATS.P2)INIT.06K
:       Copied from (MATS.P2)INIT.05F by K. Adams 2/06/81
:       Put a debug call to STUFFI in main loop.
:       Turn a short jump into a long jump.
 
 
: (MATS.P2)INIT.05F
:    Copied by Bonnell from (MATS.P2)INIT.04S.  2/3/81
:    Modified the bit-array FLAGS to accomodate all NBUF buffers.
:    Made appropriate code changes to initialize BF for all buffers.
:    Did not change assignment of bits in the arrays TISIS and FISIS.
:    Also eliminated references to FB.AAA.

: (MATS.P2)INIT.04S
:   Copied by Gimnicher from (MATS.P2)INIT.03S.  1/28/81
:   Added code to call PRTTO.

: (MATS.P2)INIT.03S copied from (MATS.P2)INIT.02K on 10-23-80
: by Steve Gimnicher in order to make modifications for Soft
: Shut implementation and to add code to set up version number on
: monitor screen.
: -----------------------------------------------------------
: INIT.02K COPIED FROM
: (STEVEG)INIT.01S 10/15/80

:INIT.NAD   IMATS INITIALIZATION ROUTINE

	RA	0
	GL	STATS,VALDTR,PCHCOD,PTZERO,CRRCRC,SQUNTO,CIRTMO,PSMBRK

        GL      FREHKP


	SEG	0
NGRP	EQ	(NPORT+0F)/10		:NUMBER OF PORT GROUPS
:       FISIS, TISIS AND FLAGS HAVE BEEN MOVED TO SEG0.


INITSV	WS	$A18		:SAVE AREA
 
: RING MESSAGE
	WS	0
ITITRC	HC	TINIT	:IDENTIFIER
ITPORT	HS	1	:PORT NUMBER
ITTIME	WS	1	:CURRENT TIME
	HC	0
ITCC	HS	1	:CRASH COUNT
	HC	0
ITCTC	HS	1	:CRASH TYPE CODE
ITCT	WS	1	:TIME OF CRASH
	WC	0
:


	SEG	1		:PLACE IN SEGMENT 1


START
        NOP

        CHHOST(1)               : SHOW HOST DOWN
        GL      MATVER,V.LUD.
        LA      R3,MATVER,,     : ADDRESS OF VERSION # ON MONITOR SCREEN
        LA      R4,V.LUD.+1,,   : START OF VERSION NUMBER FROM LUD
        LB      R5,V.LUD.,,     : LENGTH OF VERSION NUMBER (SC FORMAT)
        CLHI    R5,$A27         : IS LENGTH > 27 (MAX SIZE ON MONITOR)
        IFF(G,THEN)             : IF > THEN YES
          LHI   R5,$A27
        ENDIF
        SIS     R5,1            : DECREMENT FOR LOOP
          DO(WHILE,GE)          : MOVE CHARACTERS FROM RIGHT TO LEFT
          LB      R6,,R4,R5     : GET A CHARACTER
          STB     R6,,R3,R5     : STORE A CHARACTER
          SIS     R5,1          : NEXT CHARACTER
          ENDDO

:	INIALIZE THE TRACE RING WITH STARTUP DATA
	LO	FRONT
	LH	R13,PORT	:GET PORT #
	FO	FRONT
	STH	R13,ITPORT,,	:INSERT INTO RING MESSAGE
	L	R13,GMT,,	:GET TIME
	ST	R13,ITTIME,,	:INSET INTO RING MSG
	LO	CRASH
	LH	R13,CRSHCT	:GET CRASH COUNT
	FO	CRASH
	STH	R13,ITCC,,	:INSERT INTO RING MSG
	LH	R13,CRASHC	:GET CRASH TYPE CODE
	STH	R13,ITCTC,,	:INSERT INTO RING MSG
        LIS     R13,0           : THE CRASH TIME IS NO LONGER AVAILABLE UNDER ISIS2
	ST	R13,ITCT,,	:INSERT INTO MSG
	LA	R2,ITITRC,,	:SET TRACE ROUTINE ARGUMENT
	CALL(TRACE,INITSV)
	SVC	DISMISS
	JAL	R0,IZT,,		:INIT TIMEOUTS

	JAL	R5,IZBF,,		:INITIALIZE BUFFERS

   : Initialize BF (pointer to buffer flag) for each buffer.

        LHI     R2,NBUF
        LHI     R1,(NBUF-1)*2   : Index for array BF

IBFL    STH     R2,BF,R1        : Set BF(i) = i+1
        SIS     R1,2
        SIS     R2,1
        JGBS    IBFL

   : We have now established a buffer flag for each buffer.  The following
   : code will redefine the buffer flags for buffers 0 to 2*NPORT-1 (i.e, the
   : input and output buffers.

CONTST	JAL	R0,IZFRONT,,	:INITIALIZE FRONT END
	LHI	R1,(NPORT-1)*4
	LA	R0,VALDTR	:ADDRESS OF VALIDATOR
	LIS	R4,0
	LA	R2,(TISIS-FLAGS)*8+NPORT-1
	LA	R3,(FISIS-FLAGS)*8+NPORT-1,,
	LA	R5,PSMBRK,,		:BREAK TABLE ADDRESS
START1	ST	R0,PROCESS,R1
	ST	R4,P2U,R1	:CLEAR P2U
	ST	R4,BREAK,R1	:SET CHAR BREAK ARRAY TO DEFAULT (CR ONLY)
	STH	R2,BF+2,R1
	STH	R3,BF,R1
	ST	R5,MBREAK,R1	:MSG BREAK TABLE
	SIS	R3,1
	SIS	R2,1
	SIS	R1,4
	JGEBS	START1
        LA      R0,PTZERO,,
        ST      R0,PROCESS,,    :Set Port 0 activation routine (PTZERO)
	SVC	DISMISS
	L	R0,GMT,,
	ST	R0,STRTTM	:STARTUP TIME
	CALL(INIRB,INITSV)

                                :not reinitialize if restart due to crashes
:        LIS     R0,0
:        ST      R0,SOFREB,,     :INITIALIZE COUNT-# of times sign_off initiated
:        STH     R0,SOFBAD,,     :INITIALIZE COUNT-# of bad resp for sign_off
:        STH     R0,SOFTMO,,     :INITIALIZE COUNT-# of no resp. for sign_off
:        ST      R0,SGIAUB,,     :# of times sign_in initiated
:        STH     R0,SINBAD,,     :# of bad resp. for sign_in
:        STH     R0,SINTMO,,     :# of no resp. for sign_in

        CALL(INTFRE,INITSV)


	CALL(INTAUB,INITSV)
	CALL(INIAMT,INITSV)
	CALL(INIMAG,INITSV)
	CALL(INITRC,INITSV)
	CALL(INIDBG,INITSV)

        IF      SG.RTO
        CALL(RESHKP,INITSV)
        EI

        IF      METER                   : Metering printer data
        L       R1,FASTC,,
        CALL(PRTTO,INITSV)
        EI

	IF 1-NOPARS
        IF      PARS.2
        CALL(INIPAR,INITSV)
        ELSE
        CALL(INICRL,INITSV)
        EI
	EI

        LHI     R0,CSTDWN
        STH     R0,MSCTAB+CCBSTA,,      : Set status for stats circuit

        L       R0,FASTC,,
        ST      R0,MSCTAB+CCBTIM,,      : Set time of last status change

        LHI     R0,-1                   : To make SNHSBC start at the
        STH     R0,LSTHST               : beginning of the host table

        CALL(CMSTAR,INITSV)             : Create mats startup record

	LIS	R0,0
	STH	R0,HKHIRE	:CLEAR HOUSEKEEPER-HIRED
	STB	R0,LOGMSG	:CLEAR LOGMSG
	ST	R0,NUMUSR	:CLEAR NUMUSR
	ST	R0,R2UNUM       :CEAR R2 USER NUMBER
	L	R1,FASTC,,	:FIRST CALL NOW.
        LR      R7,R1           :save it also in R7
	LI	R0,STATS	:PUT STATS INTERVAL PROCESSOR ON TIMEOUT LIST
	JAL	R5,TOPUT,,
	LA	R0,PCHCOD,,	:TRAP FOR MULTICIRCUIT PROBLEM
	JAL	R5,TOPUT,,
        LA      R0,CRRCRC,,     :Create record count record
        JAL     R5,TOPUT,,
        LA      R0,SQUNTO,,     :Unload queue
        JAL     R5,TOPUT,,
        LA      R0,CIRTMO,,     :Wait for pseudo-needle
        JAL     R5,TOPUT,,
        IF      FB.AAA          :free process enabled, put it in timeout list
          LA      R0,SGOTMO,,     :put sign_off timeout in the list
          LI      R1,SGOINT,R7
          JAL     R5,TOPUT,,
          LA      R0,SGOHKP,,     :put sign_off house_keeper timeout in the list
          LI      R1,HKPINT,R7
          JAL     R5,TOPUT,,
        EI      :FB.AAA
        IF      UB.AAA          :sign_in enabled, put it in timeout list
          LA      R0,SGITMO,,     :put sign_in timeout in list
          LI      R1,SGIINT,R7
          JAL     R5,TOPUT,,
        EI      :UB.AAA
        LIS     R0,1
        STB     R0,SHTFLG,,     : INIT SHTFLG TO NOT ANSWERED
        LIS     R0,0
        STH     R0,SHTMSK,,     : SHOW NO PROCESSES ARE HOLDING MATS SHUT
        CALL(ANSWIT,INITSV)     : ANSWER MATS

MAIN	SVC	DISMISS		:DISMISS
 
: :        JAL     R0,STUFFI,,     :Routine to Stuff IRING.
 
	JAL	R0,INPUT,,
	JAL	R0,OUTPUT,,
	JAL	R0,TIMOUT,,
	J  	MAIN


:(mats.p2)PJCRSP.S01
:
: Created by chen on 12/3/86
:
: ProJect Code ReSPonse. This routine is assembled if interface supports
: project code handling. It is activated by FRONT.LIB when one of the
: following event occurs(FRONT.LIB supplies the activation code):
:   1. project code arrives in time(activation code = 0)
:   2. receives ISIS detatch(9E), ZAP(9F) messages and input buffers are
:      not empty(activation code = -3, flush the input buffers), and then
:      process 3.
:   3. receives ISIS detatch(9E), ZAP(9F) messages and input buffers are
:      empty(activation code = 9E or 9F)
:   4. project code exceeds maximum data size allowed(should never happen,
:      activation code = -2)
:   5. the timeout value expires and no message arrives(activation code=-4)
: When a good project code arrives, it is saved in a special buffer which 
: can be up to configurable max_length and is indexed by port number. 
: When timeout expires, the validation process proceeds as normal(agent_ID,
: terminal type..etc). The next data message from terminal will be
: interpreted as project code and sent to SUPERVISOR by ISIS and will be
: handled by validator as it supposes to be.
:
: input - 
:       R0 = activation code(passed by FRONT.LIB or timeout routine)
:       R1 = port # * 4
:       P2U[port_# * 4] = negative port number
:       PJCOFF[por_# * 2] = offset to project code save area
:       SAVPJC = start of project code save area, each entry has
:                MXPJCL + 1 bytes, the first byte is the length of the
:                project code saved
:       MXPJCL = max project code length
: output -
:       SAVPJC[PJCOFF[port * 2]] contains the project code if there's one

        IF      \PJCSUP         :if support project code

        SEG     A.DATA          :allocate storage for project code 

:PJCACD; GLABEL(PJCACD)  HS 1   :storage to save activation code
:WATPJC; DEFDEF(WATPJC,$A 3)  :default timeout value wait for p.c(seconds)
:MXPJCL; DEFDEF(MXPJCL,$A 25)   :default project code length = 25
:SAVPJC; GLABEL(SAVPJC) BND 4   :start of p.c. save area
         BS     (MXPJCL+1)*NPORT :each entry = max length + 1(length byte)
:PJCOFF; GLABEL(PJCOFF) BND 2   :offset to p.c. save area for each port
Q       EQ      0
        RE      NPORT
          HC    Q*(MXPJCL+1)
Q       EQ      Q+1
        ER

        GL      VLNOT1

        PROC(PJCRSP)
        CHAIN(PJCSAV)

        STH     R0,PJCACD,,       :save activation code
	L	R1,P2U,R1	:GET P2U ENTRY(= negative port # now)
	LR	R0,R0		:check activation code
	JE	PJCDAT		:activation code = 0, is project code data
	CLHI	R0,9E		:DISCONNECT?
	JE	PJCZAP
	CLHI	R0,9F		:ZAPPER?
	JE	PJCZAP
	CLHI	R0,-3		:FLUSH?
	JE	PJCFL           :data in input buffers when 9E or 9F arrives
	CLHI	R0,-2		:TOO MANY CHARS?
	JE	PJCDAT
	CLHI	R0,-4		:TIMEOUT,
	JE	PJCDAT          :has to get agent id from LUT in order to
                                :proceed


	IF	DEBSW
	LIS	R10,1
	GL	NINVAC
	AHM	R10,NINVAC,,	:COUNTER NUMBER OF INVALID ACTIVATIONS
	EI

PJCZAP	
	INVOKE(INITPT)

PJCFL   CALL(CIB,PJCSAV)        :clear input buffer	
	LHI	R0,WATPJC	:set TIMEOUT FOR project code arrives
	RETURN(R1)

        :either data or timeout goes here. If data(project code) arrives
        :we should save the project code in its save area. Otherwise,
        :timeout expires(no project code), the part to save the project
        :code should be skipped. In either case, we should always get
        :the agent ID from LUT record in order to decide the corresponding 
        :action to be taken(i.e., single or multple agent id access).
        :To put the agent id of this username is a MUST, since there's 
        :only one LUD interface shared by all users, the LUDAID field
        :in LUD interface maybe changed while waiting for project code 
        :response

PJCDAT	LA  	R2,INTLUD+LUDNAM		:Lud interf.address
	LR	R10,R2
	LIS	R3,$A12			
	LHI	R4,0A0				:Clear to spaces
	CALL(CLEAR,PJCSAV)
	LR	R8,R1				:Save R1
	XI	R1,-1				:Take two's compl.of R1
	AIS	R1,1				:Make port numb.posit.
	SLHLS	R1,2
	LHL	R9,BCT,R1			:Are bufferlets empty?
	DO(WHILE,G)
	   JAL  R4,GCI,,				:Read character
	   CLI  R0,$00BB			:Is semicolon?r
	   EXITDO(E)				:Exit do
	   STB  R0,0,R10			:Store in INTLUD+LUDNAM
	   AIS  R10,1				:Increment pointer

	   LHL   R9,BCT,R1
	ENDDO
	LR	R1,R8	        :Restore neg. port # in R1
                                :EDIT and WRTNUM need it
        LA      R2,INTLUD       :get interface address
        LIS     R3,0            :reset LUDAID to 0
        STH     R3,LUDAID,R2    :
        LIS     R3,LRUNAM       :search for the username, LUDREQ save the
        CALL(LUDREQ,PJCSAV)     :agent_ID pointer in LUDAID of LUD interface
                                :if its a single agent id
        XI      R8,-1           :convert to positive(two's complememt)
        AIS     R8,1
        SLLS    R8,1            :port # * 2
        LH      R8,PJCOFF,R8,   :get offset of this port
        LA      R8,SAVPJC,R8,    :get address of this port's project code
                                :save area
        LIS     R3,0            :reset project code length to 0
        STB     R3,0,R8
        LH      R10,PJCACD,,      :get the activation code
        CLHI    R10,-4          :is it timeout?
        JE      CHKAID          :yes, no edit for project code and proceed
	LCS	R2,1         	:no activation character for EDIT
	CALL(EDIT,PJCSAV)	:Fill edit buffer
        LR      R2,R8           :get save area address in R2
        AIS     R2,1            :pass length byte
	LHI	R3,MXPJCL       :clear the whole entry to null
	LIS	R4,0
	CALL(CLEAR,PJCSAV)      :R2=start addr. to be cleared
                                :R3=total bytes to be cleared
                                :R4=char. to be put in clearing area
	LR	R3,R2		:get start addr. of project code save area
                                :pass the length byte
	LHI	R2,MXPJCL       :max byte of project code to be saved
	LHI	R0,$08D		:TERMINATING CHAR = CR
	CALL(READ,PJCSAV)       :from edit buffer to project code save area
                                :stop when 1. max bytes read
                                :          2. edit buffer empty
                                :          3. terminating char found
                                :     return R2=total data bytes moved
        STB     R2,-1,R3,       :put project code length in length byte
CHKAID	LA	R2,INTLUD	:NOW WRITE USERNAME BACK to input bufferlet
	CALL(WRTUNM,PJCSAV)     : including semicolon, R1(RUBLK)=neg. port
        LCS     R0,1            :set username ended char to CR,
        STH     R0,VLNCR        :always prompt agent_id for muti_aid user if
                                :interface supports project code
        J       VLNOT1          :to proceed the agent id process

        EI                      :if PJCSUP defined
:(MATS.P2)VALDTR.S06
:	Copied by Margalit from .S05	2/10/87
:	Made changes resulted from rearanging the err msgs
:(MATS.P2)VALDTR.S05
:       Copied by chen from (mats.p2)VALDTR.S04 on 1/21/87
:       start auto_sign_in process if it is configured right before
:       sending the banner/prompt to the user(calling RESSET)
:	Took out the code that dealt with LUD-locked.
:(MATS.P2)VALDTR.S04
:       Added conditional assembly for project code support 12/4/86
:       In label VLNOTR, added code if project code is supported
:       symbol PJCSUP is defined if the parameter of PJCODE macro is
:       set to YES in tymfile.
:
:       Copied by Byrne from .S03 on 15-Oct-86
:       Made code check for global users agent id and skip calling MATAUT
:       if agent id is GLAID.

:(TIGERDEV)VALDTR.S03
:       Copied by Byrne from .S02 on 5-Aug-86
:       Added printer check to init Res Block RBPRTS field.
:       Made terminal type logic ask for terminal type forever if no types are
:       valid in the LUD.

:(TIGERDEV)VALDTR.S02
:	Copied by Margalit form .01C	12/10/85
:	Added PCI-78, removed 440

:(TIGERDEV)VALDTR.01C
:       Copied by Chen from (TEST.INA)VALDTR.02A on 6/14/85
:       Made a new directory for Flying Tiger project.
:
:(TEST.INA)VALDTR.02A
:	Copied by Margalit from .01A	6/13/85
:	Added code to handle new trminal type - VT52

:(TEST.INA)VALDTR.01A
:	Copied by Margalit from (MATS.P2)VALDTR.41E
:	Made changes for FLYING TIGERS, init RBPRTS


:The Validator.  (User logon routines.)

	MO	.,VALDTR
	GL	LRUNAM,LRRES,LRAGID,MAGHND,LOGUSR,TTYTAB,CMDHND,TTTEND
	GL	NMAGDN,NMAGUP,NMAGRS,NMAGBP,NMAGRB,NMAGCE,NMAGTP,VALD9F
	LO	MAIN
	RA	0

	PROC(VALDTR)
	CHAIN(VALSV)

        SEG     0
VALD9F  BS      1
        SEG     1
	LR	R2,R1
	SRHLS	R1,2		:PUT -PORT # IN R1
	LR	R6,R1		:AND +PORT # IN R6
	XI	R1,-1
	AIS	R1,1

:	SETUP TRACE EVENT MSG

	LHI	R3,TVLDTR	:TRACE EVENT ID
	STH	R3,TRCENT	:STORE IT IN TRACE ENTRY
        STH     R6,TRCENT+2	:STORE PORT NUMBER
	ST	R0,TRCENT+$A20	:STORE ACTIVATION CODE
	CLHI	R0,-1		:NEEDLE?
	JE	VNEEDL		:PROCESS IT

        CLHI    R0,$00B2                : If pseudo needle message
        IFF(E)                          : activation then ...
          SLHLS   R6,2                  : Compute port number times four
          CALL(GPSNDL,VALSV)            : Process good pseudo needle
          RETURN(R1)                    : Return restoring from R1
        ENDIF                           :

	LR	R0,R0		:DATA BREAK? (TEST FOR 0)
	JE	VLACT1
	CLHI	R0,-3		:FLUSHING?
	JE	VLACT1
	CLHI	R0,9E		:DETACH?
	JE	VLACT1
	CLHI	R0,9F		:ZAPPER?
	JE	VLACT1
	CLHI	R0,-2		:TOO MANY CHARS?
	JE	VLACT1
	CLHI	R0,-4		:TIMEOUT?
	JN	VALABN		:OTHERWISE ABEND
	LIS	R0,0
	RETURN(R1)

VALABN	LIS	R3,1                    :Bump unexpected message
        AHM     R3,ERUXMG,,             :indicator

        LA      R2,ABLANK,,             :Zap this port
        CALL(ZAPPRT,VALSV)
        LIS     R0,0
        RETURN(R1)


VLACT1	LIS	R6,0
	ST	R6,TRCENT+4	:CLEAR UNDEFINED FIELDS
	ST	R6,TRCENT+8
	ST	R6,TRCENT+$A12
	ST	R6,TRCENT+$A16
	LA	R2,TRCENT	:MSG ADDRESS
	CALL(TRACE,VALSV)
	CALL(CIB,VALSV)		:EMPTY INPUT BUFFER
	LIS	R0,0
	RETURN(R1)

VNEEDL  LR      R3,R11
        NHI     R3,$8 37        :check the terminal type
        CLHI    R3,$A 12        :compare with 12
        IFF(E,THEN)             :if equal to 12?
          LHI   R3,$A 120       :terminal speed =1200baud
          STH   R3,TERSP,R6,R6  :store terminal speed
        ORELSE                  :if equal to something else
          LHI   R3,$A 30        :terminal speed = 300baud
          STH   R3,TERSP,R6,R6  :store terminal speed
        ENDIF
        ST      R1,P2U,R2	:SAVE NEP PORT # IN P2U

        LR      R2,R1                   : Compute two times port number and
        XI      R2,-1                   : place in R2
        AIS     R2,1                    :
        SLHLS   R2,1                    :

	LA	R8,TIBECO+TIB315,,	:Default termin. is 315
	ST	R8,ECHOTB,R2,R2		:Put echo default add. in ECHOTB
	LA	R8,TIBACT+TIB315,,	:Activation table of 315
	ST	R8,BREAK,R2,R2		:Set activ.tab default add.

        ST      R5,LGIIVO,R2,R2         : Save invoice number
        NHI     R8,$007FFF              : (Remove Tymnet's garbage bit)
        STH     R8,LGIOHO,R2,           : Save orig host number
        NHI     R7,$007FFF              : (Remove Tymnet's garbage bit)
        STH     R7,LGIOND,R2,           : Save orig node number
        STH     R9,LGIOPR,R2,           : Save orig port number
        STH     R10,LGIDIA,R2,          : Save dialect code
        STH     R11,LGITID,R2,          : Save terminal ID
        L       R3,GMT,,                : Get current time from GMT
        ST      R3,LGITIM,R2,R2         : Save login time
	

	LCS	R2,1		:No activation character
	CALL(EDIT,VALSV)	:Fill edit buffer
	LA	R2,INTLUD+LUDNAM	:ADDR OF USERNAME AREA
	LIS	R3,$A12		:LENGTH OF USERNAME ENTRY
	LHI	R4,0A0		:CLEAR TO SPACES
	CALL(CLEAR,VALSV)
	LR	R3,R2		:ADDR OF USERNAME ENTRY
	LIS	R2,$A13		:MAKE SURE SEMICOLON IS READ.
	LHI	R0,0BB		:TERMINATING CHAR. SEMICOLON
	CALL(READ,VALSV)
	STH	R0,VLNCR	:SET CR FLAG (-1 CR, 0 SEMICOLON)
	LA	R2,INTLUD	:GET INTERFACE ADDR.
	CALL(WRTUNM,VALSV)

:	HANDLE TRACING
	L	R5,INTLUD+LUDNAM	:USERNAME PART 1
	ST	R5,TRCENT+4
	L	R5,INTLUD+LUDNAM+4	:USERNAME PART 2
	ST	R5,TRCENT+8
	ST	R7,TRCENT+$A12	:ORIGINATING NODE
	ST	R8,TRCENT+$A16	:ORIGINATING PORT
	LR	R10,R2		:SAVE R2
	LA	R2,TRCENT	:ADDR OF TRACE ENTRY
	CALL(TRACE,VALSV)
	LR	R2,R10		:RESTORE R2

        LIS     R3,0            : clear LUDAID
        STH     R3,LUDAID,R2
	LIS	R3,LRUNAM	:USERNAME LUD SEARCH
	CALL(LUDREQ,VALSV)	:PERFORM SEARCH
	LR	R0,R0		:SET CONDITION CODES
	JG	VNLOK		:HE EXISTS!
        CALL(CUSTAR,VALSV)      :TO CREATE USER STARTUP RECORD

        :CALL CUSERV
        LIS     R2,0            :INPUT - RES BLOCK DOES NOT EXIST
        LI      R3,DISINV       :INPUT - CODE FOR ZAP FOR INVALID USER
        LR      R8,R1
        CALL(CUSERV,VALSV)      :TO CREATE USER SERVICE RECORD
	LA	R2,LNREJM	:NEVER HEARD OF HIM.
	INVOKE(ZAPPRT)



: USERNAME CHECKS OUT.  NOW FIND OUT USER TYPE AND PROCESS ACCORDINGLY.

VNLOK
        LR      R4,R1           : Get negative port number
        XI      R4,-1           : Make it positive by inverting all the
        AIS     R4,1            : bits and adding one
        SLHLS   R4,2            : multiply by four

        LA      R3,IMBRK,,      : Get address to break table
        ST      R3,MBREAK,R4,   : Store pointer to break table for port

     	LB	R0,LUDUTY,R2	:GET USER TYPE
	CLHI	R0,LUDMUR	:MONITOR?
	JN	VLNOTM		:NO, SKIP

	CALL(CIB,VALSV)

	CALL(GETAMT,VALSV)
	LR	R0,R0		:SET COND. CODES
	JE	GOTAMT		:JUMP IF SUCCESSFULL
	LA	R2,MAXMON	:SORRY!
	INVOKE(ZAPPRT)

GOTAMT	LA	R2,INTLUD+LUDNAM	:TRANSFER USERNAME
	LA	R3,AMTNME,R1
	LIS	R4,$A12
	CALL(TFR,VALSV)
	LHI	R2,0A0A0	:TWO SPACES
	STH	R2,AMTRSV,R1	:STORE IN 'AGENT ID' FIELD
        LB      R2,INTLUD+LUDLIC :TRANSFER LICENSES
	STB	R2,AMTLIC,R1
        LB      R2,INTLUD+LUDUTY :TRANSFER USER TYPE (MONITOR)
	STB	R2,AMTTYP,R1
	LIS	R2,AMTACT	:SET ACTIVE STATUS
	STH	R2,AMTSTA,R1
	L	R2,GMT,,	:STORE TIME
	ST	R2,AMTTIM,R1
	LHI	R2,AMT440	:FORCE TO ADM2 TERMINAL
	STB	R2,AMTTTY,R1
        LA      R2,TIB440,,     :address of the 440 TIB
        ST      R2,AMTTIB,R1    :goes in the AMT
	LH	R2,AMTPRT,R1	:BUILD POINTER TO P2U
	SLHLS	R2,2
	ST	R1,P2U,R2	:SAVE AMT ADDR IN P2U

	LHL	R0,VLNCR	:DID USERNAME END WITH CR?
	JE	VLMON1		:NO, IGNORE AGENT-ID
	J	VLMON3		:YES.. SKIP THIS PART
VLMON1	LA	R2,IGNAID
	CALL(SETJMP,VALSV)
	LIS	R0,0
	RETURN(R1)

:	IGNORE AGENT ID

	PROC(IGNAID)
	L	R1,P2U,R1
	CHAIN(VMONSV)

	CALL(CIB,VMONSV)

	LR	R0,R0		:TEST ACTIVATION
	JE	SETMON		:DATA ACTIVATION
	CLHI	R0,9E		:DISCONNECT?
	JE	MONZAP
	CLHI	R0,9F		:ZAPPER?
	JE	MONZAP
	CLHI	R0,-2		:TOO MANY CHARACTERS?
	JE	MONFL
	CLHI	R0,-3		:FLUSH?
	JE	MONFL

	JAL	R10,CRASH,,	:OTHERWISE CRASH
	BC	0,0,4*RLINK,CRVALD	:CRASH CODE
:
MONZAP	INVOKE(INITPT)
:
MONFL	LIS	R0,0		:NO TIMEOUT
	RETURN(R1)
:
:	SETUP MONITOR
:
VLMON3  LA      RLINK,VMONSV,,  :CHAIN IF PREVIOUS CODE WAS SKIPPED
	ST	RLINK,0,RSAVE	:LINK TO SON
        ST      RSAVE,VMONSV+4,, :LINK BACK TO FATHER
SETMON	CALL(LOCKKB,VMONSV)
	CALL(BLOCK,VMONSV)
	CALL(CLSALL,VMONSV)
	TRLOG(ULOGON,VMONSV)
	LIS	R2,AMTOUT		:SET OUTPUT MODE
	STB	R2,AMTMOD,R1
	LCS	R2,1	:SEND FULL MONITOR SCREEN
	CALL(MONSND,VMONSV)
	LA	R2,CMDHND	:SET JUMP ADDR TO COMMAND HANDLER
	CALL(SETJMP,VMONSV)
	LIS	R0,0
	RETURN(R1)

:
:	CHECK IF RES SYS USER
:
VLNOTM	CLHI	R0,LUDRUR	:IS IT A MAG?
	JN	VLNOTR		:JUMP IF NOT.

	CALL(CIB,VALSV)		:EMPTY INPUT BUFFER
	LA	R2,MAGHND
	CALL(SETJMP,VALSV)
	LA	R3,MAGBRK	:MAG BREAK CHAR ARRAY
	SLHLS	R6,2		:CONVERT TO TABLE INDEX
	ST	R3,BREAK,R6	:STORE IN BREAK TBL
	LHI	R0,$A720		:SET 12 MINUTE TIMEOUT FOR MAG
	RETURN(R1)
:
:	:	BREAK ARRAY FOR MAGS
:
MAGBRK	HS	$010
	BEGBIT(MAGBRK,$0100,0)
	   SETBIT($00D)		:CR only
	ENDBIT
:
:	MUST BE NORMAL OR DEBUG USER
:
VLNOTR
        IF      \PJCSUP         :if project code is supported
        GL      WATPJC
        CLHI    R0,LUDNUR       : is it a normal user ?
        IFF(E,THEN)             : yes, prepare to wait for project code
           LA   R2,PJCRSP       : setup project code response address
           CALL(SETJMP,VALSV)
           LHI  R0,WATPJC       : setup project code response timeout
           RETURN(R1)
        ENDIF
        EI                      :project code supported

VLNOT1  LHL     R0,LUDAID,R2    : if LUDAID NE 0
        IFF(N,THEN)
          CHAIN(AIDSAV)         : prepare to jump into AIDRSP
          J     AID2B           : to handle single AID user
        ENDIF
        LA	R2,AIDRSP
	CALL(SETJMP,VALSV)
	LHL	R0,VLNCR	:DID USERNAME END WITH CR?
	JE	VLSEMI		:NO, DON'T PROMPT FOR AGENT ID
	LA	R2,VLAIDM	:PROMPT.
	CALL(SENDIT,VALSV)
VLSEMI	LHI	R0,WAITID	:TIMEOUT FOR AGENT ID RESPONSE
	RETURN(R1)

: AGT-ID-RESP

	PROC(AIDRSP)
: Note:  This routine has a secondary entry point at AID2B that is jumped
:        to from routine VALDTR at VLNOTR.  This happens when this user has
:        an Agent_Id chain of one entry.  The routine that jumps to AID2B
:        Chains AIDSAV before the jump.
	CHAIN(AIDSAV)
	L	R1,P2U,R1	:GET P2U ENTRY

:	SETUP TRACE EVENT MESSAGE

	LHI	R10,TAGID	:TRACE EVENT ID
	STH	R10,TRCENT
	LR	R10,R1		:GET PORT NUMBER
	XI	R10,-1		:CONVERT TO POSITIVE PORT #
	AIS	R10,1
	STH	R10,TRCENT+2	:STORE IT
	ST	R0,TRCENT+$A16	:ACTIVATION CODE
	LIS	R10,0
	ST	R10,TRCENT+4
	ST	R10,TRCENT+8
	ST	R10,TRCENT+$A12
	ST	R10,TRCENT+$A20	:CLEAR RETCODE

	LR	R0,R0		:SET COND. CODE
	JE	AIDDAT		:DATA?
	CLHI	R0,9E		:DISCONNECT?
	JE	AIDZAP
	CLHI	R0,9F		:ZAPPER?
	JE	AIDZAP
	CLHI	R0,-3		:FLUSH?
	JE	AIDFL
	CLHI	R0,-2		:TOO MANY CHARS?
	JE	AIDDAT
	CLHI	R0,-4		:TIMEOUT?
	JE	AIDTO


	IF	DEBSW
	LIS	R10,1
	GL	NINVAC
	AHM	R10,NINVAC,,	:COUNTER NUMBER OF INVALID ACTIVATIONS
	EI

AIDZAP	LA	R2,TRCENT	:LOAD MSG ADDR
	CALL(TRACE,AIDSAV)
        CALL(CUSTAR,AIDSAV)     :TO CREATE USER STARTUP RECORD
        
        :CALL CUSERV
        LIS     R2,0            :INPUT - NO RES BLOCK
        LI      R3,DISAIZ       :INPUT - CODE FOR ZAP AT AGENT ID PROMPT
        LR      R8,R1
        CALL(CUSERV,AIDSAV)     :TO CREATE USER SERVICE RECORD
	INVOKE(INITPT)

AIDFL	CALL(CIB,AIDSAV)
	LA	R2,TRCENT	:LOAD MSG ADDR
	CALL(TRACE,AIDSAV)
	LHI	R0,WAITID		:SET TIMEOUT FOR AGNT ID RESP
	RETURN(R1)

AIDTO	LA	R2,TRCENT	:LOAD MSG ADDR
	CALL(TRACE,AIDSAV)
	TRLOG(UTIMEO,AIDSAV)
        CALL(CUSTAR,AIDSAV)     :TO CREATE USER STARTUP RECORD

        :CALL CUSERV
        LIS     R2,0            :INPUT - RES BLOCK DOES NOT EXIST
        LI      R3,DISAIT       :INPUT - CODE FOR TIMEOUT AT AGENT ID PROMPT
        LR      R8,R1
        CALL(CUSERV,AIDSAV)     :TO CREATE USER SERVICE RECORD
	LI	R2,GDBYE	:SAY GOODBYE
	INVOKE(ZAPPRT)		:AND SEND HIM ON HIS WAY.

AIDDAT	LA  	R2,INTLUD+LUDNAM		:Lud interf.address
	LR	R10,R2
	LIS	R3,$A12			
	LHI	R4,0A0				:Clear to spaces
	CALL(CLEAR,AIDSAV)
	LR	R8,R1				:Save R1
	XI	R1,-1				:Take two's compl.of R1
	AIS	R1,1				:Make port numb.posit.
	SLHLS	R1,2
	LHL	R9,BCT,R1			:Are bufferlets empty?
	DO(WHILE,G)
	   JAL  R4,GCI,,				:Read character
	   CLI  R0,$00BB			:Is semicolon?r
	   EXITDO(E)				:Exit do
	   STB  R0,0,R10			:Store in INTLUD+LUDNAM
	   AIS  R10,1				:Increment pointer

	   LHL   R9,BCT,R1
	ENDDO
	LR	R1,R8				:Restore R1
	LB	R2,ACTCHA	:Load activation character
	LA	R9,TIBCLS+TIB315,, :get point to TIBCLS
	LB	R8,CHCLSS,R2,		:get activ char class
	LB	R9,0,R9,R8	:get in R9 action type
	CLHI	R9,LLIDEL	:
	IFF(E,THEN)
	  LCS  R2,1		:if del line no activ.char
	  LCS  R8,1
	ORELSE
	  SR	R8,R8		:reset R9
	ENDIF
	CALL(EDIT,AIDSAV)	:Fill edit buffer
	LR	R8,R8
	IFF(N,THEN)
	  LCS  R3,2		:if activ.char was del.line
	ENDIF
	LR	R9,R3		:SAVE R3
	LR	R9,R9
	IFF(N,THEN)		:Is delete line or curs. left ?
	   CALL(CIB,AIDSAV)
	   LA	R2,INTLUD	:Write username back
	   CALL(WRTUNM,AIDSAV)
	   CALL(NEWLIN,AIDSAV)
	   LA	R2,ADMS22	:Ask agent identifier
 	   CALL(SENDIT,AIDSAV)
	   LHI	R0,WAITID	:Set agent idenfier resp. timeout
	   RETURN(R1)		:Yes
	ENDIF


	LA	R2,CMDDAT	:CLEAR COMMAND AREA TO NULLS
	LHI	R3,CMDLEN
	LIS	R4,0
	CALL(CLEAR,AIDSAV)
	LR	R3,R2		:READ AGENT-ID
	LHI	R2,CMDLEN
	LCS	R0,1		:NO TERMINATING CHAR
	CALL(READ,AIDSAV)
	LR	R5,R2		:SAVE LENGTH OF INPUT
	LR	R0,R0
AID1	LA	R2,INTLUD	:NOW WRITE USERNAME BACK.
	CALL(WRTUNM,AIDSAV)

	CLHI	R5,2		:AGENT-ID 2 CHARS LONG?
	JE	AID2		:YES--LOOKUP IN LUD
	L	R0,CMDDAT	:GET FIRST 4 CHARS
	NI	R0,0FFFFFF00	:LOOK AT FIRST 3 CHARS
	CLI	R0,0CCCFC700	:ARE THEY 'LOG'?
	JN	AID3		:NO, INVALID AGENT-ID
        CALL(CUSTAR,AIDSAV)     :To create user startup record

        :call CUSERV
        LIS     R2,0            :Input - no res block
        LI      R3,DISAIL       :Input - code for LOG at agent id prompt
        LR      R8,R1
        CALL(CUSERV,AIDSAV)     :To create user service record
	LA	R2,GDBYE	:HE WANTS TO LEAVE.
	INVOKE(ZAPPRT)

AID2	LHL	R0,CMDDAT	PUT 2 CHARS IN INTERFACE
	STH	R0,LUDAID,R2
AID2B	LIS	R3,LRAGID	:AGENT-ID SEARCH
	CALL(LUDREQ,AIDSAV)
	L	R10,INTLUD+LUDNAM	:GET USER NAME
	ST	R10,TRCENT+4	:STORE IT
	L 	R10,INTLUD+LUDNAM+4	:GET 2ND PART OF USER NAME
	ST	R10,TRCENT+8
	L	R10,CMDDAT	:GET RESPONSE
	ST	R10,TRCENT+$A12
	LR	R10,R0		:SAVE RETURN CODE
	ST	R0,TRCENT+$A20	:RETCODE
	LA	R2,TRCENT	:LOAD MSG ADDRESS
	CALL(TRACE,AIDSAV)
	LR	R0,R10		:SET COND. CODES
	JG	AIDOK		:JUMP IF AGENT ID OK.

AID3    LA      R2,ADMS21,,     :BAD AGENT ID
        CALL(SENDIT,AIDSAV)
        LA      R2,ADMS22,,     :SECOND LINE
AID4	CALL(SENDIT,AIDSAV)
	LHI	R0,WAITID		:SET TIMEOUT FOR AGNT ID RESP
	RETURN(R1)

AIDOK	LA	R2,INTLUD	:ADDR OF LUD INTERFACE
        LHI     R0,GLAID        :get agent id for global users
        CH      R0,LUDAID,R2    :if agent id for this user = GLAID
        JE      NOTENT          :then skip active AUB search (MATAUT)
	CALL(MATAUT,AIDSAV)	:SEARCH FOR MATCH IN ACTIVE AUB CHAIN
	LR	R2,R0		:RET CODE TO R2
	JE	NOTENT		:JUMP IF NO MATCH
	LHL	R3,AUBSTA,R2	:GET STATUS OF AUB
	NHI	R3,AUBDSC+AUBHLD	:DISCONNECTED OR HOLD?
	IFF(E,THEN)		: It is an active AUB
	    CALL(CUSTAR,AIDSAV) : statistics
	    LIS	R2,0
	    LI	R3,DISALR	: dissconnect because user already logged in
	    LR	R8,R1		: MAGTAB pointer
	    CALL(CUSERV,AIDSAV)	: statistics
	    LA	R2,ALRMSG,,	: user already logged in
	    INVOKE(ZAPPRT)	: send the user a msg and zap him off
	ENDIF			: It is an active AUB

	CALL(CIB,AIDSAV)
	XI	R1,-1		:CONVERT R1 TO PORT NO.
	AIS	R1,1
	STH	R1,AUBPRT,R2	:SAVE IN AUB
	SLHLS	R1,2		:INDEX INTO P2U
	ST	R2,P2U,R1	:SAVE AUB ADDR ON P2U
	LR	R1,R2		:AND IN R1.
	CLHI	R3,AUBHLD	:'HOLD' STATUS?
	JN	RECON2		:NO, DON'T TEST NUMUSR

	LB	R9,AUBTYP,R1	:GET USER TYPE
	CLHI	R9,LUDNUR	:NORMAL USER?
	JN	RECON2		:NO, SKIP
	L	R8,NUMUSR	:NUMBER OF NORMAL USERS
	CLHI	R8,MAXUSR	:FULL?
	JL	RECON1		:NO, HE'S OK.
	LHL	R7,HKHIRE	:HOUSEKEEPER-HIRED
	JN	NOPRTS		:CANT DO ANYTHING IF SET
	LIS	R2,1
	STH	R2,HKHIRE	:SET HOUSEKEEPER-HIRED
	LIS	R3,AUBLOG	:SET LOGIN STATUS SO HOUSEKEEPER
	STH	R3,AUBSTA,R1	:WON'T RELEASE THIS AUB
	CALL(HOSKEP,AIDSAV)
	LIS	R3,AUBHLD	:STATUS BACK TO HOLD
	STH	R3,AUBSTA,R1
	L	R8,NUMUSR	:SEE IF HOUSEKEEPER HELPED ANY...
	CLHI	R8,MAXUSR	:DID IT?
	JGE	NOPRTS		:JUMP IF IT DIDN'T.

RECON1	LIS	R2,1
	AM	R2,NUMUSR	:INCREMENT NUMUSERS

RECON2	LIS	R2,AUBLOG	:SET LOGIN STATUS
	STH	R2,AUBSTA,R1
	L	R2,GMT,,	:STORE TIME
	ST	R2,AUBTIM,R1
	TRPORT(URECON,AIDSAV)
	TRLOG(URECON,AIDSAV)
	INVOKE(TRMTYP)


NOTENT	LB	R9,INTLUD+LUDUTY	:GET USER TYPE
	CLHI	R9,LUDNUR	:NORMAL USER?
	JN	GOTPRT		:NO, SKIP
	L	R8,NUMUSR	:NUMBER OF NORMAL USERS
	CLHI	R8,MAXUSR	:FULL?
	JL	GOTPRT		:NO, HE'S OK.
	LHL	R7,HKHIRE	:HOUSEKEEPER-HIRED
	JN	NOPRTS		:CANT DO ANYTHING IF SET
	LIS	R2,1
	STH	R2,HKHIRE	:SET HOUSEKEEPER-HIRED
	CALL(HOSKEP,AIDSAV)
	L	R8,NUMUSR	:SEE IF HOUSEKEEPRER HELPED ANY...
	CLHI	R8,MAXUSR	:DID IT?
	JL	GOTPRT		:JUMP IF IT DID.

NOPRTS
        CALL(CUSTAR,AIDSAV)     :TO CREATE USER STARTUP RECORDS

        :CALL CUSERV
        LIS     R2,0            :INPUT - RES BLOCK DOES NOT EXIST
        LI      R3,DISNPT       :INPUT - CODE FOR OUT OF PORTS
        LR      R8,R1
        CALL(CUSERV,AIDSAV)     :TO CREATE USER SERVICE RECORD

      	LA	R2,NOPRTM	:SORRY.
	INVOKE(ZAPPRT)

GOTPRT	CALL(GETAUB,AIDSAV)
	LR	R0,R0		SUCCESSFUL?
	JE	GOTAUB		:YES, SKIP
	LHL	R7,HKHIRE	:HOUSEKEEPER HIRED?
	JN	NOAUBS		:YES, CAN'T DO ANYTHING NOW.
	LIS	R2,1
	STH	R2,HKHIRE	:SET HOUSEKEEPER-HIRED
	CALL(HOSKEP,AIDSAV)
	CALL(GETAUB,AIDSAV)
	LR	R0,R0		:SUCCESSFUL NOW?
	JE	GOTAUB

NOAUBS  CALL(CUSTAR,AIDSAV)
:       call CUSERV
        LIS     R2,0            :INPUT - NO RES BLOCK PTR
        LI      R3,DISMLI       :INPUT - CODE FOR MAX LOG INS EXCEEDED
        LR      R8,R1
        CALL(CUSERV,AIDSAV)     :TO CREATE USER SERVICE RECORD

        LA      R2,AUBMSG,,	: msg _ failed to allocate an AUB
	INVOKE(ZAPPRT)

GOTAUB  LA      R3,TIB315,,     :address of the 315 TIB (hardcopy)
        ST      R3,AUBTIB,R1    :goes in this brand new AUB
:       this ensures that there's always a TIB pointer in every AUB
        LA      R2,INTLUD+LUDNAM :copy username to AUB
	LA	R3,AUBUSR,R1
	LIS	R4,$A12		:12 BYTES
	CALL(TFR,AIDSAV)
	LHL	R2,INTLUD+LUDAID	:TRANSFER AGENT ID
	STH	R2,AUBAID,R1
	LB	R2,INTLUD+LUDLIC	:TRANSFER LICENSES
	STB	R2,AUBLIC,R1
        L       R2,FASTC,,              :SAVE THE FAST CLOCK TIME
        ST      R2,AUBYBT,R1
        LIS     R2,0                    :INITIALIZE YELLOW BALL COUNT
        STH     R2,AUBYBC,R1
        LH	R9,LUDSER+INTLUD	:DISTINGUISH BETWEEN SING.E MUL.ACC.
	STH	R9,AUBSER,R1
        LHL     R2,INTLUD+LUDPTY        :TRANSFER PRINTER TYPE
        STH     R2,AUBPTY,R1
        LI      R2,0                    :INITIALIZE POINTER TO RB
        ST      R2,AUBPRB,R1
:SET AUBICO LATER
        LIS     R2,FALSE                :SET PRINTING IN MIDDLE OF MSG TO FALSE
        STB     R2,AUBPMI,R1
        LIS     R2,0                    :INITIALIZE NUM OF CHARS SINCE LAST YB
        STH     R2,AUBYBC,R1
        LIS     R2,FALSE                :INITIALIZE YELLOW BALL OUT TO FALSE
        STB     R2,AUBYBO,R1
        L       R2,INTLUD+LUDIPT,,      :TRANSFER INDUSTRY POOL POINTER.
        ST      R2,AUBIPT,R1            :
        LIS     R2,SRHPNR               :INIT. TO 'SEARCH FOR PNR'
        STB     R2,AUBPNR,R1            :
        L       R2,INTLUD+LUDIND        :TRANSFER INDUSTRY CODE
        ST      R2,AUBIND,R1
        LR      R3,R2                   :INPUT TO BINDEC - BIN NUM TO CONVERT
        LIS     R4,NC.ICO               :INPUT TO BINDEC - LENGTH OF OUTSTRNG
        LA      R5,AUBICO,R1,           :INPUT TO BINDEC - ^ OUTPUT AREA
        CALL(BINDEC,AIDSAV)             :TO CONVERT INDUSTRY CODE TO ASCII
	L	R2,INTLUD+LUDFON	:TRANSFER PHONE NUMBER
	ST	R2,AUBFON,R1
	L	R2,INTLUD+LUDFON+4	:TRANSFER PHONE NUMBER
	ST	R2,AUBFON+4,R1
	L	R2,INTLUD+LUDFON+8	:TRANSFER PHONE NUMBER
	ST	R2,AUBFON+8,R1
	L	R2,INTLUD+LUDFON+$A12	:TRANSFER PHONE NUMBER
	ST	R2,AUBFON+$A12,R1
	LB	R2,INTLUD+LUDFON+$A16	:TRANSFER PHONE NUMBER
	STB	R2,AUBFON+$A16,R1
	LB	R2,INTLUD+LUDUTY	:COPY USER TYPE
	STB	R2,AUBTYP,R1
	LIS	R2,AUBLOG	:SET LOGIN STATUS
	STH	R2,AUBSTA,R1
	L	R2,GMT,,	:SAVE TIME
	ST	R2,AUBTIM,R1
	LH	R2,AUBPRT,R1	:COMPUTE P2U INDEX
	SLHLS	R2,2
	ST	R1,P2U,R2	:STORE AUB ADDR IN P2U
        LH      R2,AUBPRT,R1,           :get port #
        LH      R6,TERSP,R2,R2          :get speed of terminal
        STH     R6,AUBLNS,R1,           :store it in AUB
        LI      R3,MXPDLY
        MR      R2,R6
        STH     R3,AUBYBM,R1            :compute AUBYBM

        LIS     R6,DISZAP               : Initialize disconnect reason to
        STB     R6,AUBDRN,R1,           : zap

	CALL(ACTAUB,AIDSAV)

	LB	R6,AUBTYP,R1	:USER TYPE
	CLHI	R6,LUDNUR	:NORMAL USER?
	JN	NOTNUR		:NO, SKIP
	LIS	R2,1
	AM	R2,NUMUSR	:INCREMENT NUM-USERS

NOTNUR	CALL(CIB,AIDSAV)
	TRLOG(ULOGON,AIDSAV)
	INVOKE(TRMTYP)

:       Terminal type
:
:       Invoke the GOT routine automatically if the user is valid
:       on one terminal type only, otherwise ask him what type
:

        PROC(TRMTYP)
        CHAIN(TRMTSV)
        LB      R6,INTLUD+LUDTTY :valid terminal types for user
	STB	R6,AUBTTY,R1	:SAVE IN AUB
        LR      R6,R6
        JE      NOT440          :NO TERM TYPE IS VALID AT ALL
	CLHI	R6,LUD78	:PCI-78 ?
	JN	NOT78		:NO.
	INVOKE(GOT78)
NOT78	CLHI	R6,LUD430	:ADM3?
	JN	NOT430		:NO.
	INVOKE(GOT430)
NOT430  CLHI    R6,LUD415       :Scanset (415)?
        JN      NOT415
        INVOKE(GOT415)
NOT415	CLHI	R6,LUD102
	JN	NOT102		:VT102?
	INVOKE(GOT102)
NOT102	CLHI	R6,LUD431
	JN	NOT431		: 431 terminal type?
	INVOKE(GOT431)		
NOT431	CLHI	R6,LUD315	:DUMB TERMINAL?
	JN	NOT315		:NO.
	INVOKE(GOT315)
NOT315	CLHI	R6,LUD52	:DUMB TERMINAL?
	JN	NOT52		:NO.
	INVOKE(GOT52)

NOT52	CLHI	R6,LUD440
	JN	NOT440
	INVOKE(GOT440)

NOT440  LA      R2,TRMMSG+1,,   :ENTER TERM TYPE MSG
        LB      R0,TRMMSG,,     :LENGTH
	CALL(SENDMS,TRMTSV)
	LA	R2,TTYRSP	:TERM-TYPE-RESP
	CALL(SETJMP,TRMTSV)
	LHI	R0,WAITTR	:TIMEOUT FOR TERM TYPE RESPONSE
	RETURN(R1)


:TERM-TYPE-RESP

	PROC(TTYRSP)
	CHAIN(TTYRSV)
	L	RUBLK,P2U,R1	:GET P2U ENTRY
:	SETUP TRACE EVENT MESSAGE
	LHI	R10,TTID	:TRACE EVENT ID
	STH	R10,TRCENT
	LH	R10,0,RUBLK	:GET PORT NUMBER
	STH	R10,TRCENT+2
	L	R10,AUBUSR,RUBLK :GET USERNAME
	ST	R10,TRCENT+4
	L	R10,AUBUSR+4,RUBLK  :GET 2ND PART OF USER NAME
	ST	R10,TRCENT+8
	LIS	R10,0
	ST	R10,TRCENT+$A12	:CLEAR RESPONSE
	ST	R0,TRCENT+$A16	:STORE ACTIVATION REASON
	ST	R10,TRCENT+$A20 :CLEAR RETCODE
:
	LR	R0,R0		:SET COND. CODES
	JE	TTYDTA		:JUMP IF DATA
	CLHI	R0,9E		:DETACH?
	JE	TTYZAP
	CLHI	R0,9F		:ZAPPER?
	JE	TTYZAP
	CLHI	R0,-3		:FLUSH?
	JE	TTYFL
	CLHI	R0,-2		:OVERFLOW?
	JE	TTYDTA
	CLHI	R0,-4		:TIMEOUT?
	JE	TTYTO

	JAL	R10,CRASH,,
	BC	0,0,4*RLINK,CRVALD	:CRASH CODE


TTYZAP	CALL(CIB,TTYRSV)
	LA	R2,TRCENT	:LOAD MSG ADDR
	CALL(TRACE,TTYRSV)
        CALL(CUSTAR,TTYRSV)     :CALL CREATE USER STARTUP RECORD

        LIS     R2,0            :CUSERV INPUT - NO RES BLOCK
        LI      R3,DISTTZ       :INPUT - CODE FOR ZAP AT TERM TYPE PROMPT
        LR      R8,R1
        CALL(CUSERV,TTYRSV)     :CALL CREATE USER SERVICE RECORD
	INVOKE(INITPT)

TTYFL	CALL(CIB,TTYRSV)
	LA	R2,TRCENT	:LOAD MSG ADDR
	CALL(TRACE,TTYRSV)
	LHI	R0,WAITTR	:SET TIMEOUT
	RETURN(R1)

TTYTO	LA	R2,TRCENT	:LOAD MSG ADDR
	CALL(TRACE,TTYRSV)
	TRLOG(UTIMEO,AIDSAV)

        CALL(CUSTAR,TTYRSV)     :TO CREATE USER STARTUP RECORD

        :CALL CUSERV
        LIS     R2,0            :INPUT - NO RES BLOCK
        LI      R3,DISTTT       :INPUT - CODE FOR TIMEOUT AT TERM TYPE PROMPT
        LR      R8,R1
        CALL(CUSERV,TTYRSV)     :TO CREATE USER SERVICE RECORD

	LA	R2,GDBYE	:SAY GOODBYE
	INVOKE(ZAPPRT)

TTYDTA	LB	R2,ACTCHA	:Load activation character
	CALL(EDIT,TTYRSV)	:Fill edit buffer
	LR	R3,R3
	IFF(N,THEN)		:Is delete line  or cursor left?
	   CALL(NEWLIN,TTYRSV)
	   LA	R2,TRMMSG	:What kind of terminal are you using ?
	   CALL(SENDIT,TTYRSV)
	   LHI	R0,WAITTR	:Set timeout
	   RETURN(R1)		:Yes
	ENDIF
	LA	R3,CMDDAT	:ADDR OF COMMAND DATA AREA
	LHI	R2,CMDLEN	:MAX # OF CHARS TO READ
	LCS	R0,1		:NO TERMINATION CHAR
	CALL(READ,TTYRSV)
	LR	R3,R2		:MOVE # OF CHARS READ
	LA	R2,CMDDAT	:ADDR OF COMMAND
	LI	R4,TTYTAB	:TERMINAL TYPE LIST
	LI	R5,TTTEND	:END OF LIST
	CALL(CMDSRC,TTYRSV)
	L	R10,CMDDAT	:GET RESPONSE
	ST	R10,TRCENT+$A12
	ST	R0,TRCENT+$A20	:RETCODE
	LR	R10,R0		:SAVE R0
	LA	R2,TRCENT	:LOAD MSG ADDR
	CALL(TRACE,TTYRSV)
	LR	R2,R10
	JE	BADTTY		:JUMP IF NOT FOUND
	LB	R3,AUBTTY,R1	:GET VALID TYPES
        JE      BADTTY          :NO TERM TYPES VALID
	LB	R11,CMDTYP,R2	:GET TERM TYPE FROM USER
	NR	R3,R11
	CLB	R3,CMDTYP,R2	:WAS IT VALID?
	JE	GOTTTY		:YES, JUMP

BADTTY  LA      R2,INVTT1,,     :INVALID BYPE MSG
        CALL(SENDIT,TTYRSV)
        CALL(NEWLIN,TTYRSV)
        LA      R2,INVTT2,,     :SECOND LINE
	CALL(SENDIT,TTYRSV)
	LHI	R0,WAITTR	:TIMEOUT FOR TERM RESPONSE
	RETURN(R1)



GOTTTY	STB	R3,AUBTTY,RUBLK	:SAVE TERMINAL TYPE IN AUB
	L	R3,CMDADR,R2	:GET ADDR OF ROUTINE FOR THIS TERMINAL
	INVOKR(R3)

:
 
 
:		TERMINAL SETUP ROUTINES
:
:       GOT470 - (modified Perkin-Elmer Owl 1251)
 
        PROC(GOT470)
        CHAIN(SV470)
        LA      R3,TIB470,,             :address of the 470 TIB
        ST      R3,AUBTIB,RUBLK         :goes in this user's AUB
        CALL(REVXNB,SV470)              :Terminals with attached printer
                                        : require Revers-Backpressure, that is,
                                        : allow CTL-S/CTL-Q .
        CALL(SCNSUP,SV470)              :Screen Setup.
        INVOKE(TTYSET)
 
 
:       GOT440 - ADM 2  . . .
: Removed 440 in order to introduce the new terminal - PCI-78
 
	PROC(GOT440)
	CHAIN(SV440)
        LA      R3,TIB440,,             :address of the 440 TIB
        ST      R3,AUBTIB,RUBLK         :goes in this user's AUB
        CALL(SCNSUP,SV440)              :set up a screen
	INVOKE(TTYSET)

: GOT PCI-78

        PROC(GOT78)            :set up my PCI-78
        CHAIN(SV78)
        LA      R3,TIB78,,      :address of the 78 TIB
        ST      R3,AUBTIB,RUBLK :goes in this user's AUB
        L       R5,TIBPOF,R3    :pointer to "printer off" string
        CALL(REVXNB,SV78)       :reverse X enable
	CALL(ECHOLF,SV78)	: echo LF as CR\LF\RUB
        LR      R6,RUBLK        :save the RUBLK for a second
        LH      R1,AUBPRT,RUBLK :pick up the port number
        SLHLS   R1,2            :times four
	LA	R3,TIBECO+TIB78,,	:Echo offset in TIB template
	ST	R3,ECHOTB,R1	:Store address of echo array
	LA	R3,TIBACT+TIB78,,	:Act.char.offset in TIB
	ST	R3,BREAK,R1	:Store address of char.array
        AIS     R1,2            :port number * 4 + 2 is buffer number
                                : must be in R1 for the WCI routine
        PUTSC(R5,R7)            :write string (pointer, free reg)
                                : destroys R0, R2, R3, and R4
        LR      RUBLK,R6        :restore the RUBLK
        INVOKE(TTYSET)



 
 
:       SCNSUP - Screen Setup.  Common Routine to do setup for all screens
:       we know how to run in screen mode.
 
        PROC(SCNSUP)
        CHAIN(SCUPSV)
	CALL(LOCKKB,SCUPSV)
	CALL(BLOCK,SCUPSV)
        LIS     R2,SCNPAR               :FORMAT SCREEN TEMPORARILY
	CALL(FMTSCN,SCUPSV)
        LA      R3,TIBACT+TIB470,,           :ADDR OF DEFAULT DATA BREAK TABLE
        LH      R4,AUBPRT,RUBLK,        :GET PORT #
        SLHLS   R4,2                    :* 4
        ST      R3,BREAK,R4,            :STORE FOR FRONT.LIB
        RETURN(R0)
 


	PROC(GOT430)
        LA      R3,TIB315,,     :address of the 315 TIB (same as 430)
        ST      R3,AUBTIB,RUBLK :goes in this user's AUB
	LH	R4,AUBPRT,RUBLK	:PORT NO.
	SLHLS	R4,2		:CONVERT TO INDEX
	LA	R3,TIBECO+TIB315,,	:Echo offset in TIB template
	ST	R3,ECHOTB,R4	:Store address of echo array
	LA	R3,TIBACT+TIB315,,	:Act.char.offset in TIB
	ST	R3,BREAK,R4	:Store address of char.array
	INVOKE(TTYSET)


        PROC(GOT415)            :set up my Scanset
        CHAIN(SV415)
        LA      R3,TIB415,,     :address of the 415 TIB
        ST      R3,AUBTIB,RUBLK :goes in this user's AUB
        L       R5,TIBPOF,R3    :pointer to "printer off" string
        CALL(REVXNB,SV415)      :reverse X enable
        LR      R6,RUBLK        :save the RUBLK for a second
        LH      R1,AUBPRT,RUBLK :pick up the port number
        SLHLS   R1,2            :times four
	LA	R3,TIBECO+TIB415,,	:Echo offset in TIB template
	ST	R3,ECHOTB,R1	:Store address of echo array
	LA	R3,TIBACT+TIB415,,	:Act.char.offset in TIB
	ST	R3,BREAK,R1	:Store address of char.array
        AIS     R1,2            :port number * 4 + 2 is buffer number
                                : must be in R1 for the WCI routine
        PUTSC(R5,R7)            :write string (pointer, free reg)
                                : destroys R0, R2, R3, and R4
        LR      RUBLK,R6        :restore the RUBLK
        INVOKE(TTYSET)

        PROC(GOT102)            :set up my VT102
        CHAIN(SV102)
        LA      R3,TIB102,,     :address of the 102 TIB
        ST      R3,AUBTIB,RUBLK :goes in this user's AUB
        L       R5,TIBPOF,R3    :pointer to "printer off" string
        CALL(REVXNB,SV102)      :reverse X enable
        LR      R6,RUBLK        :save the RUBLK for a second
        LH      R1,AUBPRT,RUBLK :pick up the port number
        SLHLS   R1,2            :times four
	LA	R3,TIBECO+TIB102,,	:Echo offset in TIB template
	ST	R3,ECHOTB,R1	:Store address of echo array
	LA	R3,TIBACT+TIB102,,	:Act.char.offset in TIB
	ST	R3,BREAK,R1	:Store address of char.array
        AIS     R1,2            :port number * 4 + 2 is buffer number
                                : must be in R1 for the WCI routine
        PUTSC(R5,R7)            :write string (pointer, free reg)
                                : destroys R0, R2, R3, and R4
        LR      RUBLK,R6        :restore the RUBLK
        INVOKE(TTYSET)


        PROC(GOT431)            :set up my 431
        CHAIN(SV431)
        LA      R3,TIB431,,     :address of the 431 TIB
        ST      R3,AUBTIB,RUBLK :goes in this user's AUB
        L       R5,TIBPOF,R3    :pointer to "printer off" string
        CALL(REVXNB,SV431)      :reverse X enable
        LR      R6,RUBLK        :save the RUBLK for a second
        LH      R1,AUBPRT,RUBLK :pick up the port number
        SLHLS   R1,2            :times four
	LA	R3,TIBECO+TIB431,,	:Echo offset in TIB template
	ST	R3,ECHOTB,R1	:Store address of echo array
	LA	R3,TIBACT+TIB431,,	:Act.char.offset in TIB
	ST	R3,BREAK,R1	:Store address of char.array
        AIS     R1,2            :port number * 4 + 2 is buffer number
                                : must be in R1 for the WCI routine
        PUTSC(R5,R7)            :write string (pointer, free reg)
                                : destroys R0, R2, R3, and R4
        LR      RUBLK,R6        :restore the RUBLK
        INVOKE(TTYSET)

	PROC(GOT315)
        LA      R3,TIB315,,     :address of the 315 TIB
        ST      R3,AUBTIB,RUBLK :goes in this user's AUB
        LH      R4,AUBPRT,RUBLK :PORT NUMBER
	SLHLS	R4,2		:CONVERT TO INDEX
	LA	R3,TIBECO+TIB315,,	:Echo offset in TIB template
	ST	R3,ECHOTB,R4	:Store address of echo array
	LA	R3,TIBACT+TIB315,,	:Act.char.offset in TIB
	ST	R3,BREAK,R4	:Store address of char.array
	INVOKE(TTYSET)

        PROC(GOT52)            :set up my VT52
        CHAIN(SV52)
        LA      R3,TIB52,,      :address of the 52 TIB
        ST      R3,AUBTIB,RUBLK :goes in this user's AUB
        L       R5,TIBPOF,R3    :pointer to "printer off" string
        CALL(REVXNB,SV52)       :reverse X enable
        LR      R6,RUBLK        :save the RUBLK for a second
        LH      R1,AUBPRT,RUBLK :pick up the port number
        SLHLS   R1,2            :times four
	LA	R3,TIBECO+TIB52,,	:Echo offset in TIB template
	ST	R3,ECHOTB,R1	:Store address of echo array
	LA	R3,TIBACT+TIB52,,	:Act.char.offset in TIB
	ST	R3,BREAK,R1	:Store address of char.array
        AIS     R1,2            :port number * 4 + 2 is buffer number
                                : must be in R1 for the WCI routine
        PUTSC(R5,R7)            :write string (pointer, free reg)
                                : destroys R0, R2, R3, and R4
        LR      RUBLK,R6        :restore the RUBLK
        INVOKE(TTYSET)


:TERM-TYPE-SET
	PROC(TTYSET)
	CHAIN(TTYSSV)

        CALL(CUSTAR,TTYSSV)             : Create user startup record

	LA	R2,LOGMSG	:ADDR OF LOGMSG
	LB	R3,0,R2		GET LENGTH OF LOGMSG
	CLHI	R3,0		:IS THERE A LOGMSG?
	JEFS	TTYS1		:NO... SKIP
	CALL(SENDIT,TTYSSV)
TTYS1	LIS	R2,AUBACT	:SET STATUS AS ACTIVE
	STH	R2,AUBSTA,RUBLK
	L	R2,GMT,,	:SAVE TIME
	ST	R2,AUBTIM,R1
:TEST IF ACTIVE RB
	L	R2,AUBARB,RUBLK	:IS THERE AN ARB?
	JGFS	ACTRB		:YES...SKIP
	LH	R2,AUBSER,RUBLK :
	IFF(N,THEN)		:
	  INVOKE(SWTRES)	:If is single access
	ORELSE
          INVOKE(GETRES)	:If is multiple access
	ENDIF
:
:	RECONNECT TO ACTIVE RB
:
:	PUT RES IA TA BACK INTO R2U
:
ACTRB	L	R3,RBIATA,R2	:GET RES IA TA
	CALL(BINSCH,TTYSSV)
	LR	RRETC,RRETC	:TEST RETCODE
	JNFS	FNDPLC		:FOUND WHERE TO PUT IT

	JAL	R10,CRASH,,  	:ALREADY IN THE TABLE
	BC	0,0,4*RLINK,CRR2U	:CRASH CODES
:
FNDPLC	CALL(R2UADD,TTYSSV)
	LR	RRETC,RRETC
	JEFS	ACTRB1		:SUCCESS

	JAL	R10,CRASH,,  
	BC	0,0,4*RLINK,CRR2U
:
ACTRB1	CHAIN(ACTRBS)
	CALL(RESSET,ACTRBS)
	LA	R2,RECMSG	:RECONNECTED
ACTRB2	CALL(SENDIT,ACTRBS)
	CALL(NEWLIN,ACTRBS)
	CALL(SNDSOM,ACTRBS)
	CALL(UNLKKB,ACTRBS)
	LIS	R0,0		:NO TIMEOUT
	RETURN(R1)

:
:	GET-RES-CODE
:
	PROC(GETRES)
	CHAIN(GRESSV)

	IF \MARSP
	  LA  R2,NTRMAR		:Enter kind of service
	ELSE
	  LA  R2,NTRRES		:Enter RES code
	EI
	CALL(SENDIT,GRESSV)
        CALL(NEWLIN,GRESSV)
	CALL(SNDSOM,GRESSV)
	CALL(UNLKKB,GRESSV)
	LA	R2,RESRSP	:JUMP ADDRESS
	CALL(SETJMP,GRESSV)
	LHI	R0,WAITRS	:TIMEOUT FOR RESPONSE
	RETURN(R1)
:
:	RES-SYS-RESPONSE
:
	PROC(RESRSP)
	CHAIN(RRSPSV)
	L	RUBLK,P2U,R1	:GET P2U ENTRY
:
:	SET UP TRACE MSG
	LHI	R10,TRSRSP	:TRACE EVENT ID
	STH	R10,TRCENT
	LH	R10,0,RUBLK	:GET PORT NUMBER
	STH	R10,TRCENT+2
	L	R10,AUBUSR,RUBLK :GET USERNAME
	ST	R10,TRCENT+4
	L	R10,AUBUSR+4,RUBLK : GET SECOND PART OF USERNAME
	ST	R10,TRCENT+8
	LIS	R10,0
	ST	R10,TRCENT+$A12	:CLEAR RESPONSE
	ST	R0,TRCENT+$A16	:STORE ACTIVATION REASON
	ST	R10,TRCENT+$A20	:CLEAR RETCODE
:
	LR	R0,R0		:SET COND CODES
	JE	RESDTA		:DATA ACTIVATION
	CLHI	R0,9E		:DETACH?
	JE	RESZAP
	CLHI	R0,9F		:ZAPPER?
	JE	RESZAP
	CLHI	R0,-3		:FLUSH?
	JE	RESFL
	CLHI	R0,-2		:OVERFLOW
	JE	RESDTA
	CLHI	R0,-4		:TIMEOUT
	JE	RESTO

	JAL	R10,CRASH,,	:OTHERWISE CRASH
	BC	0,0,4*RLINK,CRVALD	:CRASH CODES
:
RESZAP
        L       R0,AUBRCH,R1    :TEST RES CHAIN POINTER
        IFF(E)                  :IF NO RES BLK EXISTS (AUBRCH=0)
          LIS     R2,0          :INPUT - NO RES BLOCK
          LI      R3,DISRCZ     :INPUT - CODE FOR ZAP AT RES CODE PROMPT
          LR      R8,R1
          CALL(CUSERV,RRSPSV)   :TO CREATE USER SERVICE RECORD
        ENDIF                   :IF NO RES BLK EXISTS
        INVOKE(DSCUSR)
 
RESFL	CALL(CIB,RRSPSV)
	LA	R2,TRCENT
	CALL(TRACE,RRSPSV)
	LHI	R0,WAITRS	:SET TIMEOUT
	RETURN(R1)
:
RESTO	LA	R2,TRCENT
	CALL(TRACE,RRSPSV)
	TRLOG(UTIMEO,RRSPSV)
        L       R0,AUBRCH,R1    :TEST FOR RES CHAIN POINTER
        IFF(E)                  :RES CHAIN POINTER DOES NOT EXIST
          :CALL CUSERV
          LIS     R2,0          :INPUT - RES BLOCK DOES NOT EXIST
          LI      R3,DISRCT     :INPUT - CODE FOR TIMOUT AT RES CODE
          LR      R8,R1
          CALL(CUSERV,RRSPSV)   :TO CREATE USER SERVICE RECORD
        ENDIF                   :RES CHAIN POINTER DOES NOT EXIST
	LA	R2,GDBYE	:GOODBYE..
	INVOKE(ZAPPRT)

RESDTA	LB	R2,ACTCHA	:Load activation character
	CALL(EDIT,RRSPSV)	:Fill edit buffer
	LR	R3,R3
	IFF(N,THEN)		:Is delete line  or cursor left ?
	   CALL(NEWLIN,RRSPSV)
	   INVOKE(GETRES)	:Yes
	ENDIF
        LB      R2,AUBTTY,RUBLK :GET TERMINAL TYPE
        CLHI    R2,AUB470       :IS THIS A 470?
        JN      SWT0            :NO
        LCS     R0,1            :YES - SKIP FIRST 5 CHARACTERS
        LIS     R2,5
        LA      R3,CMDDAT
        CALL(READ,RRSPSV)
SWT0
        INVOKE(SWTRES)

	PROC(SWTRES)
        CHAIN(SWTSAV)

	LH	R10,AUBSER,RUBLK :IS SINGLE ACCESS ?
	JN	RRSRS1		 :YES
	CALL(LOCKKB,SWTSAV)
        LA      R3,CMDDAT       :ADDR OF COMMAND DATA AREA
	LIS	R2,0		:CLEAR IT
	ST	R2,0,R3		:CLEAR COMMAND AREA
	LHI	R2,CMDLEN	:MAX CHARS
	LCS	R0,1		:NO TERMINATION CHAR
	CALL(READ,SWTSAV)
        LR      R3,R2           :MOVE CHAR COUNT
:
:	TRACE DATA
	L	R10,CMDDAT	:GET RESPONSE
	ST	R10,TRCENT+$A12
	ST	R0,TRCENT+$A20	:STORE RETCODE
	LA	R2,TRCENT
	CALL(TRACE,SWTSAV)
        LIS     R12,0           :INIT.FLAG,SHOWING IF ATTPTR ENTERED OR NOT
        STB     R12,VALD9F,,
        CLHI    R3,2            :CHECK RSP LENGTH
        JE      RRSRES

        CLI     R10,$00CCCFC700 : 'LOG'?
        IFF(E)                  :RESPONSE IS "LOG"
          L       R0,AUBRCH,R1  :TEST PTR TO RES BLOCK CHAIN
          IFF(E)                :IF AUBRCH=0, THERE IS NO RES BLK CHAIN
            LIS     R2,0        :INPUT - RES BLOCK PTR DOES NOT EXIST
            LI      R3,DISRCL   :INPUT - CODE FOR LOG AT RES PROMPT
            LR      R8,R1       :INPUT - PTR TO ACTIVE USER BLOCK
            CALL(CUSERV,SWTSAV) :TO CREATE USER SERVICE RECORD
          ENDIF                 :IF AUBRCH=0, THERE IS NO RES BLK CHAIN
          J       LOGUSR+4,,    :"CALL" LOGOFF USER
        ENDIF                   :RESPONSE IS "LOG"R


        CLI     R10,$00AAAAAA00 : '***' RES SYS
        JN      SWT9
        LIS     R3,LUDNUR
        CLB     R3,AUBTYP,RUBLK :TEST IF NORMAL USER
        JE      RSPINV
        J       RSP9
SWT9    CLHI    R3,$A9
        IFF(E,THEN)
          LA    R4,ATTSTR+1     :ADRESS OF '/ATTPTR'STRING
          LA    R2,CMDDAT+2     :ADRESS OF COMMAND STRING
          SIS   R3,2
          CALL(COMSTR,SWTSAV)
          LR    RRETC,RRETC     : SET CONDITION CODE
          IFF(N,THEN)
            LH  R2,AUBPTY,RUBLK,        :check if user is valid for print
            IFF(E,THEN)                 :not
              J   RSPINV
            ENDIF
            LA  R2,WRATMG,,             :string is not '  /ATTPRT'
            J   VAL9                   :jump to invalid response
          ORELSE
            LIS  R12,1          :SET FLAG-ATTPTR WAS ENTERED
        STB     R12,VALD9F,,
            J   RRSRES
          ENDIF
        ORELSE
          LH    R2,AUBPTY,RUBLK,        :check if user is valid for print
          IFF(E,THEN)                   :not
            J    RSPINV
          ENDIF                         :user is valid for print
          LA    R2,WRATMG,,             :length is not 9
          J     VAL9                    :jump to invalid responce
        ENDIF
:
:	THIS ALLOWS PROGRAMMER USER TO GET ACCESS TO CMD HANDLER WITHOUT
:	A RES SYS BEING UP
:
RSP9    LA      R2,CMDHND               :SET UP JUMP ADDRESS
	CALL(SETJMP,SWTSAV)
	CALL(NEWLIN,SWTSAV)
	CALL(SNDSOM,SWTSAV)
	CALL(UNLKKB,SWTSAV)
	LIS	R0,0		:NO TIMEOUT
	RETURN(R1)
:
RSPINV	LA	R2,INVRES	:INVALID RES CODE
VAL9    CALL(SENDIT,SWTSAV)
	INVOKE(GETRES)
:
:	SEARCH MAG FOR MATCH OF RES CODE
:
RRSRES	LH	R10,CMDDAT	:GET RESPONSE IN LOWER HALFWORD
	CLHI	R10,$081CF	:SEND PFK ?
	JNFS	RRSRS1
	INVOKE(SNDCMD)

RRSRS1	LA	R4,MAGTAB,,	:GET MAG ADDR
	LHI	R5,(NMAG-1)*MAGLNG	:SET UP LOOP PTR
RRLOOP	CLH	R10,MAGRES,R5,R4	:COMPARE RES CODES
	JEFS	RMATCH		:MATCH!!
	SHI	R5,MAGLNG	:DECREMENT LOOP PTR
	JGEBS	RRLOOP		:REPEAT IF > 0
	J	RSPINV		:NO MATCH.. JUMP
:
RMATCH	LH	R3,MAGSTA,R5,R4	:GET MAG STATUS
	CLHI	R3,RESUP	:UP ?
	JE	SRCHRB
	LH	R10,AUBSER,RUBLK, :Check if is single access
	IFF(N,THEN)		: it is a single acccess
	  CLHI	R3,RESNA	: RESNA = no connection to HI
	  IFF(E,THEN)		: if no connection to HI
	    LA	R2,HIFMSG,,	: msg telling the user
	  ORELSE		: RES is not polling
	    LA	R2,SRVMSG,,	: let the user know
	  ENDIF			: no connection..
	  J	VALOUT		: to zap the user and send msg
	ENDIF			: a single access
	CLHI	R3,RESBP	:BP ?
	JE	SRCHRB
	CLHI	R3,RESNA	:NA ?
	JNFS	RSNRSP
	LA	R2,RNOTAV	:RES NOT AVAIL
	JFS	RNRSP1
:
RSNRSP	LA	R2,RNORSP	:RES NOT RESPONDING
RNRSP1	CALL(SENDIT,SWTSAV)
	INVOKE(GETRES)

:
:	SEARCH	USER'S RB CHAIN FOR MATCH
:
SRCHRB	L	R2,AUBRCH,RUBLK	:GET RB CHAIN PTR
	JE	RQSTUI		:NO RB'S
SRLOOP	CLH	R10,RBRESC,R2	:CHECK FOR MATCH
	JEFS	RSMTCH		:RES MATCH!!
	L	R2,RBNXT,R2	:GET NEXT RB ADDR
	JGBS	SRLOOP		:LOOP IF LINK
	J	RQSTUI		:FELL OUT OF LOOP
:
:	MATCH ON RES CODE
:
RSMTCH	CALL(ACTRES,SWTSAV)
	TRPORT(USWTCH,SWTSAV)

        LIS     R10,0
        ST      R10,RBSCHT,R2,  :ZERO TIME RES BLOCK WAS FIRST SWITCHED
                                    :AWAY FROM

	J	ACTRB1
:
:	REQUEST USER INFO FROM LUD
:
RQSTUI	L	R3,AUBUSR,RUBLK	:GET USERNAME
	L	R4,AUBUSR+4,RUBLK
	L	R5,AUBUSR+8,RUBLK
	LA	R2,INTLUD	:LUD INTERFACE BLOCK
	ST	R3,LUDNAM,R2
	ST	R4,LUDNAM+4,R2
	ST	R5,LUDNAM+8,R2
	LH	R3,AUBAID,RUBLK
	STH	R3,LUDAID,R2	:AGENT ID
	LA	R5,RSPOOL	:RES POOL BLOCK
	ST	R5,LUDAPL,R2	:STORE PTR TO RES POOL
	STH	R10,LUDRES,R2	:PUT IN INTERFACE BLOCK
	LIS	R3,LRRES	:RES LOOKUP REQUEST
	CALL(LUDREQ,SWTSAV)
	LR	R0,R0		:TEST RETCODE
	JG      GOTRES          :SUCCESS !!!!
	LH	R2,AUBSER,RUBLK :Check if single access	
	IFF(N,THEN)		: if single access
	  LA	R2,LUDMSG,,	: msg - LUDREQ failed
	  J	VALOUT		: send msg and log the user off
	ENDIF			: single access
        LR      R0,R0           :TEST RETCODE AGAIN
	JE	RSPINV		:NOT FOUND
	LA	R2,LLOCK	:SYS DIR LOCKED
	CALL(SENDIT,SWTSAV)
	INVOKE(GETRES)
:
GOTRES  LIS  R4,1		:argument to TOGIA (set bit)
	LH	R6,RESNPL,R5	:GET # OF IATA'S IN POOL
	SLLS	R6,1		:DOUBLE FOR HALFWORD COUNT
TALOOP	SIS	R6,2		:DECREMENT LOOP COUNTER
	JL	NOIATA		:LIST EXHAUSTED
	LH	R7,RESITA,R6,R5	:GET IATA
	LH	R3,RESNUM,R5	:GET RESNUM
	EXHR	R3,R3		:SWAP INTO UPPER HALFWORD
	OR	R3,R7		:FORM RESIATA
	CALL(TOGIA,SWTSAV)
	LR	R0,R0		:TEST RETCODE
	JN	TALOOP		:IATA IN USE

        LH      R0,RESPTA,R6,R5 : Get corresponding printer ia_ta
        IFF(N,THEN)
          LH      R7,RESNUM,R5, : Get res number
          EXHR    R7,R7
          OR      R7,R0         : Form printer res_ia_ta
        ORELSE
          LIS     R7,0          : no printer res_ia_ta
          ENDIF

:
:	REQUEST RES BLOCK
:
	CALL(GETRB,SWTSAV)
	LR	R0,R0		:TEST RETCODE
	JGE	GOTRB
	LH	R2,AUBSER,RUBLK :Check if single access
	IFF(N,THEN)		: if single access
	  LA	R2,NRBMSG,,	: msg - failed to allocate an RB
	  J	VALOUT		: send msg and zap the user
	ENDIF
	LA	R2,RBOVRF	:RB OVERFLOW
	CALL(SENDIT,SWTSAV)
	INVOKE(GETRES)
:
:	FILL IN RES BLOCK
:
GOTRB	ST	R3,RBIATA,R2	:STORE RESIATA IN RB
        ST      R7,RBPTTA,R2,   :Store printer res_ia_ta in RB
        LA      R3,RESCDE,R5    :get res code address
        LA      R11,RBRESC,R2
        LHI     R12,NC.RSC
        MVS(R3,R11,R12,R13)
	LB	R3,RESLIC,R5	:GET LICENSE
	STB	R3,RBLIC,R2
	LH	R3,RESNUM,R5
	STH	R3,RBRESN,R2
:
:	CODE TO LOAD USER DEPENDENT DATA FOR RES GOES HERE
:
        LA      R3,RESSI,R5     :transfer send interface code
        LA      R11,RBSI,R2
        LHI     R12,NC.SI
        MVS(R3,R11,R12,R13)
        LA      R3,RESSPI,R5       :transfer send priority interface code
        LA      R11,RBSPI,R2
        LHI     R12,NC.SPI
        MVS(R3,R11,R12,R13)
        LA      R3,RESPRC,R5    :transfer pnr pricing entity
        LA      R11,RBPRIC,R2
        LHI     R12,NC.PRQ
        MVS(R3,R11,R12,R13)
        LA      R3,RESSIN,R5    :transfer agent sine-on code
        LA      R11,RBSINE,R2
        LHI     R12,NC.SIN
        MVS(R3,R11,R12,R13)
        LA      R3,RESPCT,R5    :transfer agency 'pseudo-city code'
        LA      R11,RBPSCT,R2
        LHI     R12,NC.PSC
        MVS(R3,R11,R12,R13)
        LH      R3,RESCTO,R5    :TRANSFER AGENCY COMMAND TIME OUT
        STH     R3,RBCTO,R2
        LIS     R3,0            :INITIALIZE PRINTER DOCUMENT TYPE
        STB     R3,RBPDT,R2
        LB      R3,RESVPT,R5    :TRANSFER PRINT INDICATOR
        STB     R3,RBVPT,R2
        LH      R3,RESSTO,R5,   :TRANSFER AGENCY RES TIME OUT 
        STH     R3,RBSTO,R2,

        L       R3,GMT,,                : Set RB start time
        ST      R3,RBSTTM,R2,           :

        LIS     R3,0                    : Set to zero the ...
        ST      R3,RBDSCC,R2,           : displayed CRT character count
        ST      R3,RBPRCC,R2,           : printed character count
        ST      R3,RBNTIK,R2,           : number of tickets printed
	STB	R3,RBESIN,R2,		: escape sequence indicator
        LHL     R3,AUBPTY,RUBLK,        : get printer type
        CHI     R3,PTYTGR               :
        IFF(E,THEN)                     : if Flying Tigers printer type then
          LIS	R3,DTASTT		: DATA state
          STB	R3,RBPRTS,R2,		: init Last_State of printer
        ENDIF

:    Set up RBCLIT (crt LN-IA-TA) and RBPLIT (printer LN-IA-TA)

  IF    6-NC.LIT

        REMARK  % *** VALDTR--NC.LIT not big enough

  ELSE

    : Get LN from MAG table

        LH      R7,RBRESN,R2
        CVTRES(R7,SWTSAV)               : Get number of MAG block
        LHI     R6,MAGLNG
        MHR     R6,R7                   : R6 now has MAGTAB offset

: I'm not pleased with the next two lines, they don't really 
: belong here, but should work ok.  Ed.
        L       R3,MAGTAB+MGPRMP,R6,    : copy Prompt String Pointer
        ST      R3,RBPRMP,R2

    : Fill in RBCLIT (crt LN-IA-TA)

        LA      R8,RBCLIT,R2            : Destination address for BINHXW
        LIS     R9,1                    : Byte count for BINHXW
        LA      R10,MAGTAB+MAGLN,R6,    : Address of LN
        CALL(BINHXW,SWTSAV)

        LIS     R9,2                    : Byte count for BINHXW
        LA      R10,RBIATA+2,R2,        : Address of IA-TA
        CALL(BINHXW,SWTSAV)

    : Fill in RBPLIT (printer LN-IA-TA)

        LA      R8,RBPLIT,R2            : Destination address for BINHXW
        LIS     R9,1                    : Byte count for BINHXW
        LA      R10,MAGTAB+MAGLN,R6,    : Address of LN
        CALL(BINHXW,SWTSAV)

        LIS     R9,2                    : Byte count for BINHXW
        LA      R10,RBPTTA+2,R2,        : Address of IA-TA
        CALL(BINHXW,SWTSAV)

  EI


:    Initialize printer statistics

        LIS     R3,0
        STH     R3,RBMESP,R2    :NUMBER OF MESSAGES PRINTED
        STH     R3,RBMESD,R2    :NUMBER OF MESSAGES DISCARDED
        STH     R3,RBBLKP,R2    :NUMBER OF BLOCKS PRINTED
        STH     R3,RBBLKD,R2    :NUMBER OF BLOCKS DISCARDED



	CALL(ACTRES,SWTSAV)
        L       R3,RBPTTA,R2,   : R2 POINTS TO ACTIVE RES IA-TA
        IFF(N,THEN)        : R3 -PRINTER RES IA-TA
          CALL(BINSCH,SWTSAV) : BINARY SEARCH IN R2UTAB
          LR    RRETC,RRETC     : SET COND.CODE
          IFF(N,THEN)        : RRETC=1- NOT FOUND
            CALL(R2UADD,SWTSAV)
            LR  RRETC,RRETC     : =0 - SUCCESS
            IFF(N,THEN)
              LIS       R12,1
              AHM       R12,ERADDP,,    :ERAADP-ERROR COUNTER TO ADD PRINTER IA-TA TO R2UTAB
                                        :WE CURTAINLY HAVE TO DO SOMTHING ELSE IN THIS CASE
            ENDIF
          ORELSE
            LIS R12,1
            AHM R12,ERBSHP,,    :WE ARE GOING TO ADD PRINTER IA-TA THAT ALREDY EXISTS IN R2UTAB
                                :ERBSHP IS INCREMENTED
          ENDIF
        ENDIF
	TRPORT(USWTCH,SWTSAV)
        LIS     R6,LUDNUR               :is it normal user ?
        CLB     R6,AUBTYP,RUBLK
        JN      VALRST                  :no, don't do sign_in
        L       R6,AUBRIT,RUBLK         :now check if sign_in should be handled
        SRL     R6,$0 10                :shift out IA, TA, R6 is RES#
        LH      R9,RESAOF,R6,R6         :get offset to RESAAA
        L       R9,RESAAA+SINPTR,R9,    :get sign_in AAA ptr
        IFF(G,THEN)                     : GT 0, sign_in process needed
          LA    R2,SINPRO               :tell user 'Sign_in in process....'
          CALL(SENDIT,SWTSAV)           : send it to user
          CALL(SETSIN,SWTSAV)           :set up related sign_in fields in AUB
                                        : with R1 = ptr to AUB
                                        :      R9 = ptr to sign_in AAA ptr tbl
          LB    R4,VALD9F,,             : save printer flag
          STB   R4,AUBD9F,RUBLK         : used by SGNPRO
          CVTRES(R6,SWTSAV)             :convert R6 to entry_num in MAGTAB
          LHI   R4,MAGLNG               :get entry size of magtab
          MHR   R6,R4                   :get offset to MAGTAB
          LA    R8,MAGTAB,R6,           :get pointer to MAGTAB(for this RES)
          L     R6,0,R9                 : get sign_in cmd ptr table for AAA
          ST    R6,SGNCMP,RUBLK         :put it in AUB for SGNCMH
          CALL(SGNCMH,SWTSAV)           : to start sign_in process,send 1st cmd
          LIS   R0,0                    : no timeout
          RETURN(R1)                    :return to front.lib
        ORELSE                          :no sign_in needed, do as normal
VALRST    INVOKE(RESSET)                : send banner/prompt to user
        ENDIF
:
:	NO IATA AVAILABLE
:
NOIATA	LH	R2,AUBSER,RUBLK :Check if single access
	IFF(N,THEN)		: if a single access
	  LA	R2,ADRMSG,,	: msg - no addresses are available
	  J	VALOUT		: send msg and zap the user
	ENDIF
	LA	R2,MAXLOG	:MAX AGCY LOG EXCEEDED FOR RES
	CALL(SENDIT,SWTSAV)
	INVOKE(GETRES)
:
:
VALOUT	  CALL(SENDIT,SWTSAV)	: send the message to the user
          L       R0,AUBRCH,R1  :TEST PTR TO RES BLOCK CHAIN
          IFF(E)                :IF AUBRCH=0, THERE IS NO RES BLK CHAIN
            LIS     R2,0        :INPUT - RES BLOCK PTR DOES NOT EXIST
            LI      R3,DISRCL   :INPUT - CODE FOR LOG AT RES PROMPT
            LR      R8,R1       :INPUT - PTR TO ACTIVE USER BLOCK
            CALL(CUSERV,SWTSAV) :TO CREATE USER SERVICE RECORD
          ENDIF                 :IF AUBRCH=0, THERE IS NO RES BLK CHAIN
          J       LOGUSR+4,,    :"CALL" LOGOFF USER


        :
        :routine to setup sign_in related fields in AUB
        : Input - 
        :       RUBLK(R1) : pointer to AUB
        :       R9        : pointer to sign_in AAAptr table
        :
      PROC(SETSIN)
        ST      R9,AUBAAA,RUBLK  :set up pointer to AAA table
        LHI     R9,SIGNIN       :set aub type to sign_in state
        STB     R9,AUBTYP,RUBLK :
        LIS     R9,1             :increment # of sign_in initiated
        AM      R9,SGIAUB,,
        LIS     R9,0             :initialize fields to 0
        STH     R9,AUBNRB,RUBLK  :# of bad response
        STH     R9,AUBNRT,RUBLK  :# of no response
        ST      R9,AUBSTM,RUBLK  :time last command sent
        LHI     R9,SGILMT        :# of retries allowed
        STH     R9,AUBLMT,RUBLK
      RETURN(R1)
        
        
:
:	RES-SET
:
	PROC(RESSET)
	CHAIN(RSETSV)
	L	R3,AUBARB,RUBLK	GET RESBLOK
	LH	R6,RBRESN,R3	:GET RES NUMBER
	CVTRES(R6,RSETSV) :CONVERT RES NUMBER TO MAGTAB INDEX NUMBER
:			COMPUTE ADDR OF MAGTAB ENTRY FOR RES NUM
:			AND GET THE SCREEN TYPE FOR THAT MAG
	LHI	R4,MAGLNG
	MR	R5,R4	:R6 NOW HAS OFFSET INTO MAGTAB
	LB	R2,MAGTAB+MAGSCN,R6,	:GET THE SCREENTYPE
	CALL(FMTSCN,RSETSV)
	CALL(CLSUNP,RSETSV)
        LB      R7,VALD9F,,     :VALD9F=1 if ATTPTR was entered
        IFF(N,THEN)        :VALD9F=0 if not
          CALL(SETPTR,RSETSV)  :R2-MSG-POINTER
          CALL(SNDBAN,RSETSV)  
          CALL(SENDIT,RSETSV)  :TO SEND MESSAGE TO USER
          CALL(NEWLIN,RSETSV)
        ORELSE
          CALL(SNDBAN,RSETSV)
        ENDIF
	LIS	R2,0
	CLB	R2,RBUMSG,R3	:TEST UMSG FLAG
	JEFS	RSET1
	CALL(ULITE,RSETSV)
RSET1	LA	R2,CMDHND	:SET UP JUMP ADDRESS
	CALL(SETJMP,RSETSV)
	CALL(SNDSOM,RSETSV)
	CALL(UNLKKB,RSETSV)
	LIS	R0,0		:FRONT2.LIB CHECKS FOR NORMAL USER TIMEOUT
	RETURN(R1)

        SEG     1               :PLACE IN SEGMENT 1

: MESSAGE TYPES TO BREAK ON

        GL      IMBRK

IMBRK   HC      0,0,0   :00
        HC      0,0,0   :30
        HC      0,0,0   :60
        HC      3,0,0   :90 <-- BREAK ON 9E (DETACH), 9F (ZAPPER)
        HC      0,0,0   :C0
        HC      0       :F0

	EM

:(MATS.P2)CMDTAB.S04
:	Copied by Margalit from .S03	1/15/87
:	Changed MAG1TX to MAGTXT
:	Replaced the EXIT cmd with LOGMAC

:(TIGERDEV)CMDTAB.S03
:	Copied by Margalit from .02A	12/12/85
:	Added cmd for PCI-78

:(TIGERDEV)CMDTAB.02A
:	Copied by Margalit from .01A	6/20/85
:	Changed LOGOFF cmd to EXIT

:(TIGERDEV)CMDTAB.01C
:       Copied by Chen from (TEST.INA)CMDTAB.01A on 6/14/85
:       Made a new directory for Flying Tiger project.
:
:	Added command for VT52


: CMDTAB.01K COPIED FROM
: (MATS.PRD)CMDTAB.NAD

:CMDTAB     ALL THE COMMAND TABLES.

	SEG	2

ALLUSR	EQ	LUDPUR+LUDMUR+LUDNUR	:SYMBOL FOR ALL USER TYPES TO BE
					:USED IN LICENSE FIELD.

	LIST	-X
TTYTAB	WS	0
COMMND(470,3,LUD470,0,GOT470)
COMMND(440,3,LUD440,0,GOT440)
COMMND(430,3,LUD430,0,GOT430)
COMMND(415,3,LUD415,0,GOT415)
COMMND(315,3,LUD315,0,GOT315)
COMMND(102,3,LUD102,0,GOT102)
COMMND(431,3,LUD431,0,GOT431)
COMMND(52,2,LUD52,0,GOT52)
COMMND(78,2,LUD78,0,GOT78)
COMMND(ADM2,4,LUD440,0,GOT440)
COMMND(ADM3,4,LUD430,0,GOT430)
COMMND(DECWRITER,3,LUD315,0,GOT315)
COMMND(HARDCOPY,4,LUD315,0,GOT315)
TTTEND	EQ	.


CMDTAB	WS	0
COMMND("81O,2,ALLUSR,0,SNDCMD)
COMMND(M.SWITCH,4,LUDNUR+LUDPUR,0,SWTCH)
COMMND(TRACE,2,LUDMUR,0,TRCCMD)
COMMND(QUERY,1,LUDPUR+LUDMUR,0,QRYCMD)
COMMND(FORCE,1,LUDPUR+LUDMUR,0,FRCCMD)
COMMND(BROADCAST,2,LUDPUR+LUDMUR,0,BRDCMD)
COMMND(TALK,4,LUDPUR+LUDMUR,0,TLKCMD)
COMMND(M.DONE,6,LUDNUR+LUDPUR,0,QUTCMD)
COMMND(M.LOGOUT,7,ALLUSR,0,LOGUSR)
COMMND(M.BANNER,5,LUDNUR+LUDPUR,0,RFSCMD)
COMMND(M.HELP,6,LUDNUR+LUDPUR,0,HELCMD)
COMMND(DEBUG,2,LUDPUR,0,DBGCMD)
COMMND(DISCONNECT,4,LUDPUR,0,DSCCMD)
COMMND(SHUT,4,LUDMUR+LUDPUR,0,SHTCMD)
COMMND(ANSWER,3,LUDMUR+LUDPUR,0,ANSCMD)
COMMND(SETMSG,4,LUDMUR+LUDPUR,0,SETMSG)
COMMND(M.SYSMSG,6,ALLUSR,0,SYSMSG)
COMMND(M.CARL,6,LUDNUR+LUDPUR,LUDCRL,CRLCMD)
COMMND(M.BYPASS,5,LUDNUR+LUDPUR,LUDCRL,BYPCMD)
COMMND(M.ATTPTR,8,LUDNUR+LUDPUR,0,ATTCMD)
COMMND(CLOSE,5,LUDMUR+LUDPUR,0,CLSCMD)
COMMND(OPEN,4,LUDMUR+LUDPUR,0,OPNCMD)
COMMND(DROP,4,LUDMUR+LUDPUR,0,DRPCMD)
COMMND(RCVRON,6,LUDMUR+LUDPUR,0,RVNCMD)
COMMND(RCVROFF,7,LUDMUR+LUDPUR,0,RVFCMD)
COMMND(RECEIVERS,3,LUDMUR+LUDPUR,0,RECCMD)
COMMND(FREE,4,LUDMUR+LUDPUR,0,FRTCMD)
COMMND(FROZENTAS,3,LUDMUR+LUDPUR,0,FZNCMD)
COMMND("81M,2,ALLUSR,0,CMDD2-4)	: REQUEST COMMAND
COMMND("81N,2,LUDPUR+LUDNUR,0,RFSCMD)
COMMND("81@,2,LUDPUR+LUDNUR,0,RPTCMD)
COMMND("81A,2,LUDPUR+LUDNUR,0,XITCMD)
COMMND("81B,2,LUDPUR+LUDNUR,0,ANKCMD)
COMMND("81C,2,LUDPUR+LUDNUR,0,UMSCMD)
COMMND("81D,2,LUDPUR+LUDNUR,0,IGNCMD)
COMMND("81E,2,LUDPUR+LUDNUR,0,ENDCMD)
COMMND("81F,2,LUDPUR+LUDNUR,0,QUTCMD)
	IF	\DEFLOG
LOGCMD				: logoff command
	ELSE
	  REMARK % *** Warning: LOGOFF string has not been defined %
	EI
CMDEND	EQ	.
:
: COMMAND TABLE FOR THE MAG MESSAGE HANDLER
:
: NOTE THIS TABLE IS NOT SEARCHED (BY CMDSRC).  SINCE THE MAG COMMANDS
: ARE NUMBERS, STARTING AT ZERO, THIS TABLE IS ACCESSED BY
: MULTIPLYING THE INCOMING MAG COMMAND BY CMDLNG (THE LENGTH OF EACH
: ETNRY IN THIS TABLE) AND USING THE ENTRY THERE.  A COMPARISON MUST BE
: DONE FIRST THO TO ENSURE THAT THE COMMAND NUMBER USED ISN'T 
: OUTSIDE THE RANGE OF THIS TABLE.  THAT HIGH NUMBER IS CALLED MAGHIG
: (WHAT ELSE?)
:
MAGMSG	WS	0
COMMND(PURPLEBALL,0,LUDRUR,0,MAG0PB)
COMMND(TEXT,1,LUDRUR,0,MAGTXT)
COMMND(AIRLINEDOWN,2,LUDRUR,0,MAG2DN)
COMMND(STARTUP,3,LUDRUR,0,MAG3ST)
COMMND(RESET,4,LUDRUR,0,MAG4RS)
COMMND(BACKPRESSURE,5,LUDRUR,0,MAG5BP)
COMMND(RELEASE BP,6,LUDRUR,0,M6GRBP)
COMMND(COMMUN_ERR,7,LUDRUR,0,M7GERR)
COMMND(TEXT/PB,8,LUDRUR,0,M8GTPB)
:
MAGHIG	EQ	(.-MAGMSG)/CMDLNG-1 :(MAKE IS RELATVE TO 0)

	LIST	X

:(MATS.P2)MAGHND.S09
:	Copied by Margalit from .S08	1/15/87
:	Changed MAG1TX to MAGTXT

: (TIGERDEV)MAGHND.S08
:    Copied by Byrne from (MATS.P2)MAGHND.07S  on 5-Aug-86
:    Call either SBUPRT or TGRPRT depending on printer type.

: (MATS.P2)MAGHND.07S
:    Copied by Gimnicher from (MATS.P2)MAGHND.06T.  11-23-81
:    Fixed bug introduced in MAGHND.06T causing bad IA value to
:    be stored in AKIA.

: (MATS.P2)MAGHND.06T
:    COPIED BY BYRNE FROM (MATS.P2)MAGHND.05S  10/12/81.  
:    CHANGED OUT OF RANGE INSTRUCTIONS TO RX3 (FOR "MAXPRT").
 
: (MATS.P2)MAGHND.05S
:    Copied by Gimnicher from (MATS.P2)MAGHND.04L.  8/31/81
:    Fixed bug in MAG3ST where CMDRET was erroneously being called at
:    end of routine.  RUBLK at that point contained a pointer
:    to the first byte after all the AMT tables causing CIB (called
:    by CMDRET) to pick up garbage.  CIB shouldn't be called in any case
:    since the port number will have been cleared out of the MAGTAB
:    by then.

: MAGHND.04L COPIED FROM (VAYSBURD)MAGHND.03L ON 01.19.81 in order 
: to change the contens of R1 before jump to EMPTY .It has to be 
: printer hold buffer index -#buffer*2
: not ready for use***
: (VAYSBURD)MAGHND.03L COPIED FROM (STEVEG)MAGHND.02S ON 01.14.81
:in order to change MAG4RS,which handles the reset message.Now it
:has to detect the PRINTER RESET as well as the TCU RESET.
: (STEVEG)MAGHND.02S copied from (MATS.DEV)MAGHND.NXX on 10-13-80
: by Steve Gimnicher in order to modify the CVTRES calls and to
: change the section handling the MAG startup message for the
: Monitor Screen Formatter implementation.
:
	MO	.,MAGHND
	GL	IA
	RA	0
:
: THIS PROGRAM IS THE MAG-MSG-COMMAND-HANDLER .. IT IS 'JUMPED' TO FROM
: THE FRONT-END ROUTINE
:
	LO	MAIN
:
	PROC(MAGHND)
:
	CHAIN(MAGSAV)
:
: FILL IN THE TRACE ENTRY
:
: THIS TRACE ENTRY IS TMAGMS - A MAG MSG HAS OCCURED
:
        ST      R0,T1ACTV,,     :STORE THE ACTIVATION REASON
	L	R10,GMT,,	:GET THE TIME
        ST      R10,T1TIME,,
        ST      R10,T2TIME,,
:
: LOAD RUBLOCK WITH EITHER THE MAGTAB ENTRY ADDRESS OR THE
:  NEGATIVE PORT NUMBER (IF THIS IS A LOGON)
:
	L	RUBLK,P2U,R1	:DO WE HAVE A MAGTAB ENTRY?
	JG	GETPRT	:YES WE DO
:
: RUBLK HAS NEGATIVE PORT NUMBER
:
	LR	R3,RUBLK
	XI	R3,-1
	AIS	R3,1	:R3 NOW HAS PORT NUMBER
        STH     R3,T1PORT,,     :PUT PORT NUMBER IN TRACE ENTRIES
        STH     R3,T2PORT,,
	LIS	R2,0
        STH     R2,T1RESN,,     :ZERO OUT FIELD WE DON'T HAVE YET
	J	ZERCMD	:FINISH FILLING IN CMDS
:
: FILL IN TRACE ENTRIES FROM MAGTAB ENTRY
:
GETPRT	LH	R2,MAGPRT,RUBLK
        STH     R2,T1PORT,,
        STH     R2,T2PORT,,
	LH	R2,MAGRES,RUBLK
        STH     R2,T1RESC,,
:
: RES NUMBER IS THE INDEX OF THIS ENTRY
	LH	R4,MAGNUM,RUBLK
        STH     R4,T1RESN,,
:
: CONTINUE FILLING IN TRACE ENTRY
:
ZERCMD	LIS	R2,0
        STH     R2,T1CMD,,
        STH     R2,T1SEQ,,
:       ST      R2,T1RETC,,
:
: NOW DECIDE WHAT TO DO
:
	LR	R0,R0	:TEST ACTIVATION CODE FOM FRONTLIB
	JE	CMDDTA	:JUMP IF DATA BREAK
	CLHI	R0,$09E	DETACH COMMAND (WE ZAPPED)
	JE	CMDZAP
	CLHI	R0,$09F	:ZAP COMMAND
	JE	CMDZAP	:JUMP IF SO
	CLHI	R0,-4	:TIMEOUT
	JE	CMDTO
	CLHI	R0,-3	FLUSHING
	JE	CMDFL
	CLHI	R0,-2	:TOO MANY CHAR?
	JE	CMDTMC
:
: INVALID ACTIVATION
:
	IF	DEBSW
	LIS	R2,1
	GL	NINVAC
	AHM	R2,NINVAC,,	:COUNT NUMBER OF INVALID ACTIVATIONS
	EI
:
	J	ZAPMAG	:BAD ACTIVATION, ZAP THE LINE
:
:
: TOO MANY CHAR/ FLUSH COMMAND
:
CMDTMC	EQ	.
CMDFL   ST      RRETC,T1RETC,,
        LA      R2,TRCMSG,,
	CALL(TRACE,MAGSAV)
        INVOKE(CMDRET)
:
: TIMEOUT - ZAP THE CIRCUIT
ZAPMAG	EQ	.
CMDTO   LA      R2,ZAPMSG,,
	LIS	R0,2
	CALL(SENDMS,MAGSAV)
	TRPORT(TRZAPO,MAGSAV) :TELL MONITOR WE ZAPPED
        J       CMDZAP  :*** FIX FOR MULTICIRCUIT BUG ***
	INVOKE(CMDRET)
CMDZAP	TRPORT(TRZAPI,MAGSAV)	:TELL SOMEONE WE GOT ZAPPED
        ST      RRETC,T2RETC,,
	LR	RUBLK,RUBLK	:DO WE HAVE AN ADDRESS OR A PORT NUMBER
	JLE	NOMGAD	:JUMP IF NO MAG ADDRESS
        ST      RUBLK,T2MAGT,,  :UPDATE TRACE FIELDS
:	SAVE THE PORT NUMBER WHERE THE MAG NOW IS (WAS?)
	LH	R3,MAGPRT,RUBLK
        STH     R3,T2PORT,,
:	ZERO OUT THE PORT NUMBER BEFORE CALLING MONITOR UPDATE
: THEN RESTORE IT, FOR INITPORT
	LIS	R2,0
	STH	R2,MAGPRT,RUBLK
:
	LH	R2,MAGSTA,RUBLK
        STH     R2,T2OSTT,,     :UPDATE TRACE FIELD
	LHI	R2,$0 0EEE1	: NEW STATUS IS NA
	STH	R2,MAGSTA,RUBLK
        STH     R2,T2NSTT,,
	L	R2,GMT,,	:GET TIME OF STATUS CHANGE
	ST	R2,MAGTIM,RUBLK
:
: UPDATE MONITOR SCREEN WITH CHANGE OF STATUS
:
	LH	R2,MAGNUM,RUBLK	:PARTIAL UPDATE
	CALL(MNUPDT,MAGSAV)
        LR      R12,RUBLK
        LIS     RUBLK,0
	CALL(MONSND,MAGSAV)
	LR	RUBLK,R12	:RESTORE RUBLK
:
: NOW RESTORE THE PORT NUMBER WHERE THE MAG WAS (IS?)
:
	STH	R3,MAGPRT,RUBLK
	L	R3,GMT,,
	ST	R3,MAGTIM,RUBLK	:STORE TIME
	J	STTIME	:JUMP TO COMMON FIELDS
:
: NO MAG ENTRY ADDRESS IN P2U
:
NOMGAD	LIS	R2,0
        ST      R2,T2MAGT,,     :ZERO OUT ADDRESS OF ENTRY
        STH     R2,T2OSTT,,     :OLD STATUS
        STH     R2,T2NSTT,,     :NEW STATUS
:
STTIME	LIS	R2,0
        ST      R2,T2IATA,,
        LA      R2,TRCMOD,,
	CALL(TRACE,MAGSAV)
:
:
: INITIALIZE THE PORT
:
:
        LR      RUBLK,RUBLK     : DO WE HAVE AN ADDRESS OR PORT #
        JLEFS   MAGHRT
        LH      R3,MAGNUM,RUBLK : RES NUMBER
        CALL(KILFRE,MAGSAV)     : KILL FREES IN PROCESS
MAGHRT  INVOKE(INITPT,MAGSAV)
:
:  DATA ACTIVATION
:
CMDDTA	LR	R6,RUBLK	SAVE THE MAGTAB ADDR/PORT NUMBER
	JG	GOTPRT	: JUMP IF MAGTAB ADDRESS
	XI	RUBLK,-1
	AIS	RUBLK,1
	J	CHKLNG	:MAKE USRE FOUR MORE CHAR IN BUFFER
GOTPRT	LH	RUBLK,MAGPRT,RUBLK
CHKLNG	SLHLS	R1,2	CONVERT PORT NUMBER TO BUFFER NUMBER
	LHL	R0,BCT,R1
	SIS	R0,6
        JGEFS   MAGIND
        LR      RUBLK,R6        :RESTORE RUBLK FOR CMDFL
        J       CMDFL
MAGIND  LIS     R5,0    INDEX TO MAGDAT
	LIS	R7,6	:EXPECT SIX CHARACTERS
NXTGCI	JAL	R4,GCI,,
        STB     R0,MAGDAT,R5,
	AIS	R5,1
	SIS	R7,1
	JGBS	NXTGCI
	LR	RUBLK,R6
        LB      R3,CMD,, :UPDATE TRACE ENTRIES
        STB     R3,T1CMD,,
        LB      R4,SEQ,,
        STB     R4,T1SEQ,,
        LB      R5,RES,,
	NI	R5,$07F
        STB     R5,RES,,
        STB     R5,T1RESN+1,,
	LHI	R6,$00DF	:CHECK FOR SOH
        CLB     R6,SOH,,
	JN	CMDFL 	:ZAP THIS GUY IF NOT
        LA      R2,TRCMSG,,
	CALL(TRACE,MAGSAV)
	LR	RUBLK,RUBLK	:IS THIS A NEW LOGON
	JG	RESCHK	:JUMP IF NOT
	LHI	R7,$0 83	:FIRST CMD AFTER LOGON MUST BE STARTUP
			:NOTE - HIGH ORDER BIT IS TURNED ON
        CLB     R7,CMD,,
	JE	CMDLUK	:JUMP IF IT IS
	LIS	RRETC,$00F
	J	ZAPMAG
:
: COMMAND MATCH
:
: DO NOT 'SEARCH' THE MAGCMD TABLE.  SIMPLY
: USE THE COMMAND NUMBER (IN FIELD CMD) AS A SUBSCRIPT INTO IT.  FIRST CHECK
: THAT THE COMMAND IS NOT GREATER THAN THE HIGHEST TABLE ENTRY
:
:	R3 STILL HAS COMMAND IN IT
: MAKE SURE THIS RES NUMBER IS CORRECT
:
RESCHK	CH	R5,MAGNUM,RUBLK
	JN	ZAPMAG
CMDLUK	NI	R3,$07F	TURN OFF HIGH ORDER BIT IN COMMAND
	CLHI	R3,MAGHIG	:IS COMMAND VALID
	JLE	GOOD1	JUMP IF IT IS
	LR	RUBLK,RUBLK	:IS THERE A MAGTAB ADDRESS
	JG	MAGERR	JUMP IF NOT
:
: INCREMENT MAG CMD ERROR COUNTER
:
	L	R4,MGICMD,RUBLK	:INCREMENT FIELD
	AIS	R4,1
	ST	R4,MGICMD,RUBLK
MAGERR	CALL(CIB,MAGSAV)
	RETURN(R1)
:
: GOOD COMMAND - ACTIVATE MAG COMMAND ROUTINE
:
:	R3 HAS COMMAND IN IT
GOOD1	LHI	R5,CMDLNG	GET LENGTH OF COMMAND TABLE ENTRY
	MR	R2,R5	AND COMPUTE DISPLACEMENT
	L	R3,MAGMSG+CMDADR,R3,	:EXTRACT ADDRESS FROM TABLE
	INVOKR(R3)
:
:
:       ROUTINE TO HANDLE MAG COMMAND ZERO, PURPLE BALL
:
        PROC(MAG0PB)
        CHAIN(MG0SV)
        SR      RRETC,RRETC
:
:
        LB      R3,SEQ,,        :LOAD DEQUENCE NUMBER
        STB     R3,MAGSEQ,RUBLK :STORE IT IN MAGTAB
:
        STB     R3,PBSEQ,,      :STORE IT IN THE COMMAND TO BE SENT
        LB      R3,IA,,
        STB     R3,PBIA,,
        LB      R3,TA,,
        STB     R3,PBTA,,
        LB      R3,RES,,        :LOAD THE RES FROM RECEIVED CMD
        OI      R3,$0 080       :TURN ON HIGH ORDER BIT
        STB     R3,PBRES,,      :STORE IT IN THE COMMAND 
:
        TRPORT(TRPBIN,MG0SV)
        LA      R2,PBALL,,      :LOAD ADDR OF MSG
        LIS     R0,$A 07        :MESSLENGTH
        CALL(SENDMS,MG0SV)
        TRPORT(TRPBOT,MG0SV)
        INVOKE(CMDRET)
:
:       ROUTINE TO PROCESS MAG CMD TWO, AIRLINE DOWN
:
        PROC(MAG2DN)
        CHAIN(MG2SV)
	IF	DEBSW
	LHI	RRETC,1
	AHM	RRETC,NMAGDN,,	:INCREMENT MAG EVENT COUNTER
	EI
        SR      RRETC,RRETC
:
        TRPORT(TRDOWN,MG2SV)
:
        LHI     R4,$0 0E4EE      :LOAD A DN
	CLH	R4,MAGSTA,RUBLK	:CHECK CURRENT STATUS FROM MAGTAB
        JE      ISDN            :IF SO GO RETURN
:
        STH     R4,MAGSTA,RUBLK :STORE NEW STATUS
        L      R5,GMT,,      :GET SLOW CLOCK
        ST      R5,MAGTIM,RUBLK :STORE TIME IN MAGTAB
        LH     R2,MAGNUM,RUBLK	PARTIAL UPDATE
        CALL(MNUPDT,MG2SV)
        LR      R12,RUBLK
        LIS     RUBLK,0
        CALL(MONSND,MG2SV)
        LR      RUBLK,R12
        LH      R3,MAGNUM,RUBLK : RES NUMBER
        CALL(KILFRE,MG2SV)      : KILL FREES IN PROCESS
:
ISDN    INVOKE(CMDRET)
:
:       ROUTINE TO PROCESS MAG CMD THREE STARTUP
:
        PROC(MAG3ST)
        CHAIN(MG3SV)
	IF	DEBSW
	LHI	RRETC,1
	AHM	RRETC,NMAGUP,,	:INCREMENT MAG EVENT COUNTER
	EI
        SR      RRETC,RRETC
        LB      R6,RES,,        :LOAD RES NUMBER FROM MAG MESSAGE
        LA      R7,MAGCON,,     :ADDR OF MAG CONSTANT TABLE

MAG300
        CLH     R6,MCRESN,R7,   :IS RES # FROM MAG MSG = RES # IN MAGCON?
        JE      MAG315          : YES
        AI      R7,MCLNG        : NO - NEXT MAGCON ENTRY
        CLI     R7,MCEND        :ARE WE AT MAGCON END?
        JL      MAG300          : NO - LOOP

        LIS     R7,1            : AT MAGCON END. NO MATCH ON RES #
        AHM     R7,RESBAD,,

        LA      R2,BRESMS,,     :BAD RES MESSAGE
        LB      R3,RES,,        :BAD RES NUMBER
        LIS     R4,3            :# OF OUTPUT DIGITS FROM BINDEC
        LA      R5,$A12,R2,     :WHERE TO PUT CONVERTED DIGITS
        CALL(BINDEC,MG3SV)
MAG303
        CALL(ZAPPRT,MG3SV)      :ZAP MAG CIRCUIT

        LA      RUBLK,AMTTAB,,  :ADDR OF ACTIVE MONITOR TABLE
        LIS     R7,NMON         :NUMBER OF POSSIBLE MONITORS
MAG305
        LH      R0,AMTPRT,RUBLK,:IS THERE A MONITOR LOGGED ON?
        JEFS    MAG310          :NO - LOOK AT NEXT ENTRY

        CALL(SENDIT,MG3SV)      :SEND MESSAGE TO MONITOR
        CALL(NEWLIN,MG3SV)

MAG310
        AHI     RUBLK,AMTLNG    :NEXT ENTRY IN MONITOR TABLE
        SIS     R7,1            :DECREMENT REMAINING MONITORS
        JG      MAG305          :LOOP

        LIS     R0,0
        RETURN(R1)              :EXIT ROUTINE

MAG315
        LB      R6,MCMENT,R7,   :FOUND RES # IN MAGCON. EXTRACT MAG TABLE
                                :ENTRY NUMBER
        LIS     R7,0            :ZERO R7 FOR MULTIPLY
        LHI     R5,MAGLNG       :MAG TABLE LENGTH
        MR      R4,R6           :R5 NOW CONTAINS MAG TABLE ENTRY FOR RES
        LR      RUBLK,RUBLK     :SET CONDITION CODE
        JLE     ISPRT           :IF NEGATIVE, THIS IS A PORT #

        LA      R5,MAGTAB,R5,   :ADD IN ORIGIN ADDRESS
        CLR     R5,RUBLK        :IF EQUAL TO RUBLK, THEN MULTI STARTUP
        JE      CHKSTA

        LA      R2,WRESMS,,     :MULTI STARTUP, BUT WRONG RES #
        LB      R3,RES,,        :WRONG RES #
        LIS     R4,3            :# OF OUTPUT DIGITS FROM BINDEC
        LA      R5,$A55,R2,     :WHERE TO PUT CONVERTED DIGITS
        CALL(BINDEC,MG3SV)
        J       MAG303

ISPRT   LR      R7,RUBLK        :SAVE RUBLK (-PRTNUM)
        XI      R7,-1
        AIS     R7,1            :NOW POSITIVE PORT NUMBER
        LR      R8,R7           :SAVE PORT NUMBER
:
: AT THIS POINT CHECK TO MAKE SURE THAT THE PORT NUMBER THAT THIS
: STARTUP MESSAGE IS COMING IN ON IS EITHER THE
: SAME AS THAT CONTAINED IN MAGPRT FOR THIS RES OR THAT MAGPRT IS
: ZERO, IMPLYING A NEW LOGON.  IF NOT, ZAP THIS LOGON
	LH	R6,MAGTAB+MAGPRT,R5,
	JEFS	SETUP	:JUMP IF PORT IS ZERO
	CR	R6,R8	:NOT ZERO - DO THEY MATCH?
	JEFS	SETUP
:
:  BAD LOGON
:
	LA	R2,DUPLOG
	INVOKE(ZAPPRT)
:
:
SETUP	SLLS	R7,2	:MULTIPLY BY 4 TO GET R2P OFFSET
        LA      R5,MAGTAB,R5,    :GET ABSOLUTE ADDRE OF MAGTAB ENTRY
        ST      R5,P2U,R7       :STORE MAGTAB ADDR IN P2U TABLE
        LR      RUBLK,R5        :LOAD RUBLK
        STH      R8,MAGPRT,RUBLK :STORE PORT NUMBER IN MAGTAB ENTRY
:
:
        LHI     R9,TRCMAG      :INDEX OF MAG TRACE BIT
        TBT     R9,SYSTRC,,     :TEST IT
        JE      CHKSTA          :JUMP IF ZEWRO
        AIS     R8,TRCPRT
        SBT     R8,SYSTRC,,     :SET MAG PORT BIT
        LA      R10,AMTTAB,,      :GET START OF MONITOR TABLE
        LHI     R11,NMON        :LOOP COUNTER
AMTLOP  LH      R12,AMTPRT,R10  :LOAD PORT
        JE      AMTINC          :NO PORT
        TBT     R9,AMTTRC,R10   :TEST MAG TRACE BIT
        JE      AMTINC          :THIS MONITOR NOT TRACING MAGS
        SBT     R8,AMTTRC,R10   :SET THE MAG TRACE PORT
AMTINC  AHI     R10,AMTLNG      :GET NEXT AMT ENTRY
        SIS     R11,1           :DECREMENT COUNTER
        JG      AMTLOP          :IF MORE JUMP
        TRPORT(TRSTUP,MG3SV)
CHKSTA  LHI     R4,$0 0F5F0     :LOAD AN UP
        CLH     R4,MAGSTA,RUBLK :CHECK CURRENT STATUS
        JE      ISUP3
:
        STH     R4,MAGSTA,RUBLK :STORE NEW STATUS
:
        L      R3,GMT,,      :GET TIME
        ST      R3,MAGTIM,RUBLK :STORE IT IN THE MAGTAB
	LH	R2,MAGNUM,RUBLK	:PARTIAL UPDATE
        CALL(MNUPDT,MG3SV)
        LR      R12,RUBLK
        LIS     RUBLK,0 
        CALL(MONSND,MG3SV)
        LR      RUBLK,R12
:
ISUP3   LB      R5,RES,,        :GET RES NUMBER
        OI      R5,$0 080       :TURN ON HIGH ORDER BIT
        STB     R5,AKRES,,      :STORE IT IN THE ACK MSG
        LB      R5,SEQ,,        :LOAD SEQ NUMBER
        STB     R5,MAGSEQ,RUBLK :STORE IT IN THE MAGBLOCK
        STB     R5,AKSEQ,,      :STORE IT IN MSG
        LB      R5,IA,,
        STB     R5,AKIA,,
        LB      R5,TA,,
        STB     R5,AKTA,,
:
        LA      R2,AKSTUP,,
        LIS     R0,$A 07        :LOAD LENGTH
        CALL(SENDMS,MG3SV)
        LB      R5,RES,,
        CALL(FREEUP,MG3SV)      : BEGIN FREE PROCESS
        INVOKE(CMDRET)
:
:	ROUTINE TO PROCESS MAG CMD FOUR:  RESET
:
	PROC(MAG4RS)
	CHAIN(MG4SV)
	IF	DEBSW
	LHI	RRETC,1
	AHM	RRETC,NMAGRS,,	:INCREMENT MAG EVENT COUNTER
	EI
	SR	RRETC,RRETC
:
	TRPORT(TRRS,MG4SV)
        LB      R5,TA,,
        NHI     R5,$07F
        CLI     R5,$01
        IFF(N,THEN)                     :TA ne 01 implies printer reset
          LR    R11,RUBLK               :save MAG RUBLK
          CALL(USRSCH,MG4SV)
          LR    RRETC,RRETC
          IFF(E,THEN)                   :found in R2TAB
            LR  R4,R4
            IFF(N,THEN)                 :it's printer IA-TA
                                        :and it isn't a FREE BLOCK
              CL  R5,AUBPRB,R2,         :printer RES BLOCK
              IFF(E,THEN)               :if equal to RES BL we found
                LH   R1,AUBPRT,R2,
                SLLS R1,2
                AHI  R1,NPORT*4+2       :R1-printer hold buffer index
                LR   R9,R2              :save AUB-pointer
                JAL  R4,EMPTY,,
                LHI  R0,$03E            :put reset code into R0
                JAL  R4,WCI,,
                LR   R2,R1              :FROM-BUFFER pointer
                LR   R1,R9              :AUB-pointer
                LHL  R4,AUBPTY,R1,      :get printer type
                CHI  R4,PTY736          :is it a 736?
                IFF(E,THEN)             :if 736 printer then
                  CALL(SBUPRT,MG4SV)    :send reset code to user
                ORELSE                  :else its not a 736
                  CHI  R4,PTYTGR        :is it a Flying Tigers printer?
                  IFF(E,THEN)           :if Flying Tigers printer then
                    CALL(TGRPRT,MG4SV)  :do FT functions
                  ENDIF                 :
                ENDIF                   :
                LR   RUBLK,R11          :restore MAG RUBLK
              ENDIF                     :printer is assigned to this RES
            ENDIF                       :it's printer RES BLOCK
          ENDIF                         :found in R2UTAB
        ORELSE                          :is a TCU reset
:TELL ALL USERS ABOUT RESET
	L	R3,R2UNUM	:SET LOOP COUNTER TO LENGTH OF CURRENT IA-TA TBL
	JE	RETRN4	:IF ZERO, NO USERS
	LA	R4,R2UTAB,,	:INITIAL ENTRY ACCESS REGISTER
	LA	R2,RSMSG	:SET UP MESSAGE SENDING
	LHI	R0,$A23	:SET MESSAGE LENGTH
	LIS	R6,AUBOUT	:SET UP USER MODE SETTING TESTING
	LR	R5,RUBLK	:SAVE RU BLK
:LOOP THROUGH IA-TA TABLE
RESET	L	RUBLK,R2UAUB,R4	:GET AUB ADDRESS
	CLB	R6,AUBMOD,RUBLK	:SEE IF USER'S TERMINAL IS IN OUTPUT MODE
	JN	RS	:IF NOT, ACCESS THE NEXT ENTRY
	CALL(SENDMS,MG4SV)
	CALL(SNDSOM,MG4SV)
	CALL(UNLKKB,MG4SV)
:ACCESS NEXT USER
RS	AIS	R4,8	:ADD ENTRY LENGTH
	SIS	R3,1	:REDUCE NUMBER OF ENTRIES TO GO
	JN	RESET
:FINISHED
RETRN4	LR	RUBLK,R5	:RESTORE MAG RU BLK
        ENDIF
        INVOKE(CMDRET)
:
:       ROUTINE TO PROCESS MAG CMD FIVE, APPLY BACKPRESSURE
:
        PROC(MAG5BP)
        CHAIN(MG5SV)
	IF	DEBSW
	LHI	RRETC,1
	AHM	RRETC,NMAGBP,,	:INCREMENT MAG EVENT COUNTER
	EI
        SR      RRETC,RRETC
:
        TRPORT(TRBP,MG5SV)
:       
        LHI     R4,$0 0E2F0             :LOAD A BP
	CLH	R3,MAGSTA,RUBLK	:IS CURRENT STATUS BP?
        JE      ISBP
:
        STH     R4,MAGSTA,RUBLK         :STORE THE BP
        L       R5,GMT,,      :GET SLOW CLOCK VALUE
        ST      R5,MAGTIM,RUBLK :STORE TIME
        LH     R2,MAGNUM,RUBLK	PARTIAL UPDATE
        CALL(MNUPDT,MG5SV)
        LR      R12,RUBLK
        LIS     RUBLK,0
        CALL(MONSND,MG5SV)
        LR      RUBLK,R12
ISBP    INVOKE(CMDRET)
:
:       ROUTINE TO RELEASE BACK PRESSURE, CMD SIX
:
        PROC(M6GRBP)
        CHAIN(MG6SV)
	IF	DEBSW
	LHI	RRETC,1
	AHM	RRETC,NMAGRB,,	:INCREMENT MAG EVENT COUNTER
	EI
        SR      RRETC,RRETC
:
	TRPORT(TRRBPI,MG6SV)
:
        LHI     R4,$0 0F5F0             :LOAD AN UP
	CLH	R3,MAGSTA,RUBLK	:IS CURRENT STATUS UP?
        JE      ALLUP
:
        STH     R4,MAGSTA,RUBLK         :STORE THE UP
        L       R5,GMT,,              :GET CLOCK
        ST      R5,MAGTIM,RUBLK         :STORE IN MAG AREA
        LH     R2,MAGNUM,RUBLK	:PARTIAL UPDATE
        CALL(MNUPDT,MG6SV)
        LR      R12,RUBLK
        LIS     RUBLK,0
        CALL(MONSND,MG6SV)
        LR      RUBLK,R12
:
ALLUP   INVOKE(CMDRET)
:
        PROC(CMDRET)
        CHAIN(CMDRSV)
        CALL(CIB,CMDRSV)
        LHI     RRETC,720
	RETURN(R1)
:
:       ROUTINE TO HANDLE MAG COMMAND SEVEN:  COMM ERR
:
        PROC(M7GERR)
        CHAIN(MG7SV)
	IF	DEBSW
	LHI	RRETC,1
	AHM	RRETC,NMAGCE,,	:INCREMENT MAG EVENT COUNTER
	EI
        SR      RRETC,RRETC
        TRPORT(TRCOER,MG7SV)
	LIS	R2,1
	AM	R2,MGIAIR,RUBLK	:INCREMENT AIRLINE ERR COUNTER
        INVOKE(CMDRET)
:
:       ROUTINE TO HANDLE MAG COMMAND EIGHT:  TEXT WITH PURPLE BALL
:
        PROC(M8GTPB)
        CHAIN(MG8SV)
	IF	DEBSW
	LHI	RRETC,1
	AHM	RRETC,NMAGTP,,	:INCREMENT MAG EVENT COUNTER
	EI
        SR      RRETC,RRETC
:
:
        TRPORT(TRTPB,MG8SV)
:PREPARE PURPLE MESSAGE
        LB      R3,SEQ,,        :LOAD SEQUENCE NUMBER
        STB     R3,MAGSEQ,RUBLK :STORE IT IN MAGTAB
:
        STB     R3,PBSEQ,,      :STORE IT IN THE COMMAND TO BE SENT
        LB      R3,IA,,
        STB     R3,PBIA,,
        LB      R3,TA,,
        STB     R3,PBTA,,
        LB      R3,RES,,        :LOAD THE RES FROM RECEIVED CMD
        OI      R3,$0 080       :TURN ON HIGH ORDER BIT
:
        STB     R3,PBRES,,      :STORE IT IN THE COMMAND 
        LA      R2,PBALL,,      :LOAD ADDR OF MSG
        LIS     R0,$A 07        :MESAGE LENGTH
        CALL(SENDMS,MG8SV)
        TRPORT(TRPBOT,MG8SV)
:SEND TEXT 
	INVOKE(MAGTXT)
:
:
: DATA AREAS
:
        GL      RES,IA,TA,AKSOH,AKETX,AKTXT
	SEG	0
	WS	0
:
:	TRACE RING ENTRIES
TRCMSG	HC	TMAGMS
T1PORT	HC	0
T1TIME	WC	0
T1RESN	HC	0
T1RESC	HC	0
T1CMD	BC	0
T1SEQ	BC	0
T1ACTV	WC	0
T1RETC	WC	0
:
TRCMOD	HC	TMAGMD
T2PORT	HC	0
T2TIME	WC	0
T2MAGT	WC	0	:MAGTAB ADDRESS
T2OSTT	HC	0
T2NSTT	HC	0
T2IATA	WC	0
T2RETC	WC	0
:
ZAPMSG	BC	0,$09E
:
	HS	0
MAGDAT	EQ	.
SOH	BC	0
RES	BC	0
CMD	BC	0
SEQ	BC	0
IA	BC	0
TA	BC	0
:
PBALL   BS      0
PBSOH   BC      $0 0DF
PBRES   BC      $0 0
PBCMD   BC      $0 80
PBSEQ   BC      $0 0       
PBIA    BC      $0 80
PBTA    BC      $0 81
PBETX   BC      $0 0D
:
AKSTUP  BS      0
AKSOH   BC      $0 0DF
AKRES   BC      $0 0 
AKCMD   BC      $0 84
AKSEQ   BC      $0 0 
AKIA    BC      $0 80
AKTA    BC      $0 81
AKETX   BC      $0 0D
AKTXT   BC      $085
:
RSMSG	AC	/RESET-reenter request"8D"8A/
	SEG	1
:
	EM

: HOSKEP.02T COPIED FROM HOSKEP.01K, 10/12/81, BY T. BYRNE.
:  UPDATES INSTRUCTIONS TO RX3 BECAUSE OF LARGER "MAXPRT".
 
: HOSKEP.01K COPIED FROM
: (MATS.PRD)HOSKEP.NAD.  10/15/80.

        RA      $00
        MO      .+3&-4,HOSKEP
        SEG     1
:
:       HOUSEKEEPER ROUTINE
:       THIS ROUTINE IS CALLED IF NO USER BLOCKS ARE AVAILABLE
:       IT FREES ALL USER BLOCK WHICH HAVE BEEN DISCONNECTED FOR LONGER
:       THAN SAVE-AUB-TIME.
:       ALL PORTS ARE FREED WHICH HAVE BEEN RESERVED LONGER THAN
:       SAVE-PORT-TIME.
:       IF NO AUBS CAN BE FREED, THE HOUSEKEEPER IS RESCHEDULED
:       TO EXECUTE WHEN THE OLDEST AUB CAN BE REMOVED.
:
PROC(HOSKEP)
CHAIN(HOSSAV)
        L       R8,GMT,,        :R8=GMT IN SECONDS PAST JAN1 1974
        SR      R9,R9           :ZERO R9 THE OLDEST AUB DISCONNECTED
:
        L      RUBLK,AUTACT    :GET POINTER TO FIRST ACTIVE AUT
HLOOP   L       R11,AUBNXT,RUBLK        :GET NTAEXT AUB IN CHAIN
        LH      R3,AUBSTA,RUBLK :R3 IS STATUS OF THIS AUB
        CHI     R3,AUBDSC       :IS AUB DISCONNECTED??
        JE      DSCHLD          :JUMP IF DISC
        CHI     R3,AUBHLD       :CHECK FOR HOLD STATUS
        JN     NODIS           :NOT DISC OR HOLD....SKIP
:
DSCHLD  L       R5,AUBTIM,RUBLK :GET DISCONNECT TIME FROM AUB
        LR      R4,R8           :GET CURRENT TIME
        SR      R4,R5           :COMPUTE NUMBER MINUTES DISCONNECTED
        CHI     R4,SVATIM       :CHECK IF DISCON LONGER THAN SAVE AUB TIME
        JL      NORELA          :JUMP IF CANT RELEASEE AUB
        CHI     R3,AUBDSC       :IF NOT DISCONNECTED DONT DECREMENT NUMUSR
        JN     PRTZER          :SKIP
        LB	     R12,AUBTYP,RUBLK      :GET TYPE
        CLHI    R12,LUDNUR      :IS HE A NORMAL USER
        JN      PRTZER          :IF NOT DONT DECREMENT
        LCS     R5,1            :LOAD R5 WITH -1
        AM      R5,NUMUSR       :DECREMENT NUMBER OF USERS
:
PRTZER  TRPORT(UFORCD,HOSSAV)   :TRACING CALLS
        TRLOG(UFORCD,HOSSAV)    
        CALL(RELAUB,HOSSAV)     :AX THE CURRENT ENTRY
        LIS     R5,1            :LOAD A ONE TO ADD TO USR FORCED
        AM      R5,FRCLOG       :INCREMENT FORCED LOGOFF COUNTER
        J       NODIS           :USER WAS AXED NO MORE PROCESSING
:
NORELA  CHI     R3,AUBHLD       :IS STATUS ALREADY HOLD???
        JE      NORELP          :DONT RELEASE PORT AGAIN
        CHI     R4,SVPTIM       :COMPAARE TIME DIF WITH PRT SVS 
        JL      NORELP          :SKIP IF WE CANT RELEASE THE PORT
        LB      R12,AUBTYP,RUBLK      :GET TYPE
        CLHI    R12,LUDNUR      :CHECK FOR NORMAL SUSER
        JN      NODEC           :IF NOT NORMAL USER THEN DNOT DECREMENT
        LCS     R12,1           :LOAD A -1
        AM      R12,NUMUSR      :DECREMENT NUMUSER
NODEC   SR      R12,R12         :ZERO R12
        STH     R12,AUBPRT,RUBLK:ZERO PORT NUMBER.... DONT RESERVE PORT
        LIS     R12,AUBHLD      :LOAD HOLD INDISTATUS
        STH      R12,AUBSTA,RUBLK        :STORE IT
        J       NODIS           :GO TO LOOK AT NEXT AUB
NORELP  CR      R4,R9           :IS TIME FOR THIS AUB GREATER THAN OLDEST FOUND
        JLE     NODIS           :JUMP IF NOT
        LR      R9,R4           :SAVE IN R9 THE OLDEST AUB
NODIS   LR      RUBLK,R11       :LOAD POINTER TO NEXT AUB STORED IN R11
        JN      HLOOP           :LOOP IF NOT ZERO
:
        L       R12,NUMUSR      :GET NUMBER OF USERS
        CHI     R12,MAXUSR      :COMPARE TO NUMBER OF USER PORTS
        JL      FREED           :JUMP IF WE FREED AN AUB
        LR      R9,R9           :SET CONDITION CODE FOR OLDEST
        JE      FREED           :BIG TROUBLE NO ONE DISC DONT SCHEDULE
        LI       R1,SVPTIM      :LOAD SAVE PORT TIME
        SR      R1,R9          :SUBTRACT OLDEST
:       CALL HERE TO TOPUT ROUTINE FROM TIMOUT.LIB....
:       NOTE....THIS INTERFACE IS NON STANDARD!!!!!
:
        LHI     R2,RATE :GET RATE OF FAST CLOCK....600
        MR      R0,R2           :R0 NOW HAS NUMBER FAST CLICKS TIL CAN REL
        A       R1,FASTC,,      :ADD CURRENT TIME
        LA      R0,HOSINT       :R0 IS ADDRESS OF HOUSEKEEPER INTERFACE ROUTINE
:
        JAL     R5,TOPUT,,        :JUMP AND LINK TO TIMEOUT ROUTINE
:
        SR      RRETC,RRETC     :SET GOOD RETURN CODE
        RETURN(R1)
FREED   SR      RRETC,RRETC     :ZERO RETURN CODE
        STH     RRETC,HKHIRE    :ZERO HOUSEKEEPER HIRED FLAG
        RETURN(R1)
:       INTERFACE ROUTINE FOR WHEN WE ARE ACTIVATED BY THE TIMMEOUT LIST
:
        SEG     0
HSISAV  WS      18      SAVE AREA
        SEG     1
HOSINT  ST      R3,HSISAV+4,,   :NO CALLERS SAVE AREA
:
        CALL(HOSKEP,HSISAV)     :INVOKE HOUSEKEEPER
:
        J       TORET,,
        EM


: (MATS.P2)LUDREQ.10E
:    Copied by Gauci from (MATS.P2)LUDREQ.09P     5-mar-85
:    On a username search, if user has  an agent_id chain of only 1
:       return the agent_id in ludaid.

: (MATS.P2)LUDREQ.09P
:     Copied by Mele from (MATS.P2)LUDREQ.08T on 10/21/83.
:     After the agent identifier search the RES chain will be scanned
:     to determine if it's single or multiple access case.
:
: (MATS.P2)LUDREQ.08T
:     Copied by Byrne from (MATS.P2)LUDREQ.07R  on 2/23/83.
:     Changed code which handles ATC# searches to fix a bug.  The
:     parameter interface was changed.

: (MATS.P2)LUDREQ.07R
: Copied by Cheung from (MATS.P2)LUDREQ.06L
: Moved the pointer of the Industry Pool Table to the interface block
: during the username search and added a new subroutine to
: perform matching of ATC# in the pool.

: (MATS.P2)LUDREQ.06L
: Copied by Vaysburd from (VAYSBURD)LUDREQ.05L
: Fixed bug
: (MATS.P2)LUDREQ.05L
:  Copied by Vaysburd from (MATS.P2)LUDREQ.04K 04.24.81 in
: order  to change group of transfering commands by MVS MACROS.
: (MATS.P2)LUDREQ.04K
:    COPIED FROM (MATS.P2)LUDREQ.03L BY ADAMS 1/16/81 IN ORDER
:    TO ADD NEW FIELDS NEED FOR TWA PRINTER PROJECT.
:***MODIFICATION IN PROGRESS***:


: (MATS.P2)LUDREQ.03L
:    COPIED FROM (MATS.P2)LUDREQ.02K BY VAYSBURD 12.17.80
:    IN ORDER TO CHANGE LUD.TABLE POINTERS FROM HALFWORDS TO FULLWORDS

: LUDREQ.02K COPIED FROM
: (STEVEG)LUDREQ.01S 10/15/80

:LUDREQ.NAD  CONTAINS LUDREQ PROCEDURE

	MO	.,LUD
	GL	LUD,LUDEND,LUDLOK,LITCNT,LITITA
	RA	0


:LUDREQ  Performs all searches on LUD.  This should be the only
:        routine in IMATS which accesses the LUD.  All other LUD
:        information must be retrieved via this routine and
:        the interface tables.
:  Arguments:  R2 - Address of interface table
:              R3 - Type of request:
	GL	LRUNAM,LRAGID,LRRES,LRATC
:
:  Return value for request types LRUNAM, LRAGID, and LRRES:
:              R0 = Address of the interface block (unchanged) if successful
:                 = 0 if search failed
:                 = -1 if LUD locked
:  If request is LRUNAM and user has an agent_id chain of 1 then return
:               the agent_id in LUDAID.
:
:
:  Return value for request type LRATC:
:              R0 = TRUE if found an ATC# match
:                 = FALSE if no ATC# match found
:
:
PROC(LUDREQ)
	LHL	R8,LUDLOK,,	: is LUD locked?
	JN	LLOCKD		:yes, error return
	LI	R8,LUD		:Pointer to start of LUD username table
	CHAIN(LUDSAV)
        CLHI    R3,LRATC        :Is ATC# search?
        JE      LRQATC          :Perform ATC# search
LRQ1	CLI	R8,LUDEND	:At end of table?
	JE	LRFAIL		:yes, search failed.
	L	R9,LUDNAM,R2	:first word of username
	ST	R9,TRCENT+4	: INSERT INTO TRACE MSG
	CL	R9,LUTNAM,R8	:Match?
	JN	LRUNXT		:no, try next entry
	L	R9,LUDNAM+4,R2	:test next word
	ST	R9,TRCENT+8	: INSERT INTO TRACE MSG
	CL	R9,LUTNAM+4,R8
	JN	LRUNXT		:no match
	L	R9,LUDNAM+8,R2	:try 3rd word
	CL	R9,LUTNAM+8,R8
	JE	LRUFND		:go process him if found
LRUNXT	AI	R8,LUTLNG	:skip to next LUD entry
	J	LRQ1		:and test it.

:He really exists!!
LRUFND	LB	R9,LUTTYP,R8	:move user type to interface table
	STB	R9,LUDUTY,R2
	LB	R9,LUTTRM,R8	:move term type
	STB	R9,LUDTTY,R2
	LB	R9,LUTLIC,R8	:move licenses
	STB	R9,TRCENT+$A16	: INSERT INTO TRACE MSG
	STB	R9,LUDLIC,R2
	L	R9,LUTIND,R8	:MOVE INDUSTRY CODE
	ST	R9,LUDIND,R2
        LHL     R9,LUTPTY,R8    :MOVE PRINTER TYPE
        STH     R9,LUDPTY,R2
        L       R9,LUTIPT,R8    :Move Industry Pool table pointer.
        ST      R9,LUDIPT,R2
	CLHI	R3,LRUNAM	:is this a username search?
	JG	LRQAID		:go check agent-id if not.
        L       R9,LUTAID,R8    :Get Agent_Id chain pointer
        IFF(N,THEN)             :If not 0 (should not be 0)
          LHL   R0,LAIAID,R9    :pick up Agent_Id
          L     R9,LAINXT,R9    :if Pointer_to_Next = 0 (only 1 in chain)
          IFF(E,THEN)
            STH R0,LUDAID,R2    : then set LUDAID to agent_id
          ENDIF
        ENDIF
	LR	R0,R2		:return code
	RETURN(R2)

LRQAID	LH	R10,LUDAID,R2	:get agent-id to search for
	STH	R10,TRCENT+$A12	: INSERT INTO TRACE MSG
	LHI	R0,TLUD1	:BUILD TRACE MSG
	STH	R0,TRCENT	: SET IDENTIFIER
	STH	R3,TRCENT+2	: INSERT FUNCTION CODE
	LHI	R0,$00A0A0	:  BLANK
	STH	R0,TRCENT+$A14	:   UNUSED
	STH	R0,TRCENT+$A18	:   AREAS
	L  	R9,LUTAID,R8	:pointer to agent-id chain
LRQAI1	JE	LRFAIL		:search fails if at end of chain
	CLH	R10,LAIAID,R9	:test agent-id
	JE	LRACC		:branch if found
	L  	R9,LAINXT,R9	:else try the next one
	JBS	LRQAI1
LRACC	L	R15,LAIRES,R9	:get pointer to res chain
	JE	LRFAIL		:If 0 error
	LH	R10,LRSRES,R15	:get reservation code
	L	R15,LRSNXT,R15	:get next pointer
	IFF(G,THEN)
	   SR	R10,R10		:If >0 then multi access
	ENDIF
        STH	R10,LUDSER,R2	:LUDSER will be RES if sing.acc.else 0

LRAFND	LIS	R0,1	: SET FOUND CODE
	ST	R0,TRCENT+$A20
	CLHI	R3,LRAGID	:is this an agent-id search?
	JG	LRQRES		:do res search if not
	LR	R0,R2		:set return code
	LA	R2,TRCENT	:PROVIDE TRACE MSG POINTER
	CALL(TRACE,LUDSAV)
	LR	R2,R0	:RESTORE R2
	RETURN(R2)

LRQRES	LH	R10,LUDRES,R2	:get res code to search for
	STH	R10,TRCENT+$A12	: INSERT INTO TRACE MSG
	LHI	R0,TLUD2	:BUILD TRACE MSG
	STH	R0,TRCENT	: INSERT IDENTIFIER
	L  	R9,LAIRES,R9	:get pointer to res chain
LRQRS1	JE	LRFAIL		:search fails if end of chain
	CLH	R10,LRSRES,R9	:test res code
	JE	LRRFND		:if match, go find IA-TA pool
	L  	R9,LRSNXT,R9	:try next entry
	JBS	LRQRS1

LRRFND	LB	R10,LRSRSN,R9	:res number to search for
	L  	R8,LUTAGC,R8	:pointer to AGENCY RES/DATA CHAIN
LRQAGC	JE	LRFAIL		:failure of none left
	CLB	R10,LAGRSN,R8	:is this it?
	JE	LRIFND		:yes, go get info.
	L  	R8,LAGNXT,R8	:no, try the next one
	JBS	LRQAGC

LRIFND	L	R3,LUDAPL,R2	:ptr to res IA-TA interface
	STH	R10,RESNUM,R3	:save res number
        LA      R10,LRSSIN,R9
        LA      R11,RESSIN,R3   :transfer sine-on code
        LHI     R12,NC.SIN
        MVS(R10,R11,R12,R13)
        LA      R10,LRSRES,R9
        LA      R11,RESCDE,R3   :transfer res code
        LHI     R12,NC.RSC
        MVS(R10,R11,R12,R13)
	LB	R10,LRSLIC,R9	:transfer license
	STB	R10,RESLIC,R3
        LB      R10,LRSVPT,R9   :MOVE ALLOWED-TO-PRINT INDICATOR
        STB     R10,RESVPT,R3
:
: MOVE IN REST OF FIELDS FROM LAG BLOCK
:
        LA      R10,LAGPCT,R8   :transfer psedo-city
        LA      R11,RESPCT,R3
        LHI     R12,NC.PSC
        MVS(R10,R11,R12,R13)
        LA      R10,LAGPRC,R8   :transfer PNR pricing entity
        LA      R11,RESPRC,R3
        LHI     R12,NC.PRQ
        MVS(R10,R11,R12,R13)
        LA      R10,LAGSI,R8    :transfer send interface code
        LA      R11,RESSI,R3
        LHI     R12,NC.SI
        MVS(R10,R11,R12,R13)
        LA      R10,LAGSPI,R8   :transfer send priority interface code
        LA      R11,RESSPI,R3
        LHI     R12,NC.SPI
        MVS(R10,R11,R12,R13)
        LH      R10,LAGCTO,R8   :transfer command time out
        STH     R10,RESCTO,R3

        LH      R10,LAGRTO,R8,  :TRANSFER RES TIMEOUT
        STH     R10,RESSTO,R3,

	L  	R8,LAGITA,R8	:GET POINTER TO IA-TA POOL
	JE	LRFAIL	:JUMP IF NOT THERE
	LHL	R9,LITCNT,R8	:IA-TA count
	CLHI	R9,MAXITA	: Guarantee no overflow
	JLEFS	LRQI	:OK
	LHI	R9,MAXITA	:too big
LRQI	STH	R9,RESNPL,R3
	LHI	R8,LITITA,R8	:addr of LUD IA-TA pool
        LHI     R7,RESPTA,R3    :addr of interface printer ia_ta storage
	LHI	R3,RESITA,R3	:addr of interface CRT IA-TA storage
LRQI3	SIS	R9,1		:decrement counter
	JLFS	LRQFIN		:branch if done
	LHL	R10,0,R8	:transfer an IA-TA
	STH	R10,0,R3
        LHL     R10,2,R8,       :transfer a printer IA_TA
        STH     R10,0,R7,
        AIS     R7,2
	AIS	R3,2		:next interface loc.
	AIS	R8,4		:next LUD loc of CRT IA_TA
	JBS	LRQI3


LRQFIN	LR	R0,R2		:set ret code
	LA	R2,TRCENT	:PROVIDE TRACE MSG POINTER
	CALL(TRACE,LUDSAV)
	LR	R2,R0	:RESTORE R2
	RETURN(R2)

LRFAIL	LIS	R0,0		:failure return
	ST	R0,TRCENT+$A20	: INSERT INTO TRACE MSG
	LR	R8,R2	:SAVE R2
	LA	R2,TRCENT	:PROVIDE TRACE MSG POINTER
	CALL(TRACE,LUDSAV)
	LR	R2,R8	:RESTORE R2
	RETURN(R2)


LLOCKD  LCS     R0,1            :LUD locked, return
        RETURN(R2)





:
:       LRQATC:
:               Search the Industry Pool for an ATC# which matches
:               the ATC# in the input.
:
:       INPUT:
:               R2 points to the interface block.
:               R3 has the type of LUD request, must be LRATC to get here.
:               Interface Block[LUDIPT] contains the Industry Pool pointer.
:               Interface Block[LUDIND] contains the Industry Code to
:                  search for.
:
:       OUTPUT:
:               R0 = TRUE if an ATC# match is found.
:                  = FALSE if no ATC# match is found.
:
LRQATC  LIS     R0,FALSE             :Preset output to ATC# not found
        L       R1,LUDIND,R2,        :Get ATC# from input
        L       R8,LUDIPT,R2,        :Get pointer to the Industry Pool Table
        IFF(N)                       :IF Pool exists
          L       R10,0,R8,          :THEN get number of ATC#'s
          DO(WHILE,G)                :DO WHILE any ATC#'s left in Pool
            CL      R1,4,R8,         :must compare starting 1 word past count
            IFF(E)                   :IF ATC# from input = ATC# in pool
              LIS     R0,TRUE        :THEN we have a match
              EXITDO                 :so, return
            ENDIF                    :
                                     :
            AIS     R8,4             :Point to next ATC# in pool
            SIS     R10,1            :Decrement ATC# count
          ENDDO                      :

        ENDIF                        :

        RETURN(R2)


	EM

:(MATS.P2)RBPGM.S01
:       copied by chen from (mats.p2)RBPGM.06S on 1/20/87
:       made changes for new auto_sign_off structures
:       RELRB, 
:       ACTRES - to save the RES_IA_AT of avtive res block in AUB
:                this field is needed for auto_sign_in process
: (MATS.P2)RBPGM.06S
:    Copied by Gimnicher from (MATS.P2)RBPGM.05W.  10-1-81
:    Moved CUSERV call in RELRB.
:    Added parameter of res block pointer to call to CUSERV.
:    This tasks were both done in order to fix some bugs in the MATS STATS
:    records.

: (MATS.P2)RBPGM.05W
: Copied from (MATS.P2)RBPGM.04L on 08/20/81
: Added MATS STATS changes
:
:(VAYSBURD)RBPGM.04L was copied from (mats.p2)rbpgm.03s on 01.07.81
:in order to change some routines for ATTPRT IMPLEMENTATION.
:***NOT READY FOR USE***
: (STEVEG)RBPGM.03S copied from (STEVEG)RBPGM.01S on 10-13-80
: by Steve Gimnicher in order to modify the CVTRES call for
: Monitor Screen Formatter implementation.
:
        RA      $00
        MO      .+3&-4,RBPGM
:       SEG     1
:
:       ROUTINE TO PUT ALL RES BLOCKS ON THE FREE LIST.
:       ON RETURN ALL RES BLOCKS ARE LINKED TOGETHER AS FREE
:       RES BLOCKS.
:
PROCS(INIRB,$0 0D)
        SR      RRETC,RRETC           :ZERO RETURN CODE, ROUTINE CANNOT FAIL (?)
        LA      R2,RBLOCK,,      :GET FIRST RES BLOCK ADDR
        ST      R2,RBFREE      :STORE ADDR IN FREE HEAD PTR
        LHI     R9,NRBLK        :GET NUMBER OF RES BLOCKS ALLOCATED
RBLOP   SR      R8,R8           :ZERO R8
        LR      R7,R2          :R7 IS THE BLOCK TO BE ZEROED
        LHI     R6,RBLNG       :LOAD LENGTH OF RES BLOCK IN BYTES
RBINZE  STB     R8,0,R7         :ZERO A BYTE OF THE RB
        AIS     R7,1            :INCREMENT R7 TO NEXT BYTE
        SIS     R6,1            :DECREMENT COUNTER
        JN      RBINZE          :IF MORE BYTES ...LOOP
:
        LA      R10,RBLNG,R2      :R10 -> NEXT RES BLOCK
        ST      R10,RBNXT,R2  :LINK BLOCKS TOGETHER
        LR      R2,R10         :BUMP POINTERS
        SIS     R9,1            :DECREMENT COUNTER OF BLOCKS
        JN      RBLOP           :IF NOT DONE LOOP
:
        ST      R8,0,R2        :ZERO LAST POINTER
        ST      R8,NUMRB        :NO RBS IN USE
        RETURN(R2)







:
:       ROUTINE TO GET A RES BLOCK FROM THE FREE LIST
:       ON RETURN RES BLOCK IS IN RUBLKS RES CHAINS
:       AND R2 POINTS TO THE EMPTY RES BLOCK GOTTEN
:       IF NO RES BLOCK ARE AVAIL   R2=0 AND RRETC=-1
:
PROCS(GETRB,$0 0D)
        LHI     RRETC,-1           :SET RETURN CODE TO BAD
        L       R2,RBFREE,,      :GET ADDR OF FREE L ST
        JN      GOTRB           :IF NOT  ZERO THEN RBS AVAIL
        RETURN(R3)
GOTRB   L       R10,RBNXT,R2   :GET NEXT FREE RES BLOCK
        ST      R10,RBFREE      :STORE ADDRESS IN FREE POINTER
        LIS     R3,1            :LOAD A 1
        AM      R3,NUMRB        :INCREMENT NUMBER OF ACTIVE RBS
:
        L       R5,AUBRCH,RUBLK :GET RBCHAINS POINTER FROM AUB
        ST      R5,RBNXT,R2     :STORE IT IN THE RB FOUND
        ST      R2,AUBRCH,RUBLK :POINT AUBCHAINS AT NEW RB
:
        SR      RRETC,RRETC     :ZERO RETURN CODE
        RETURN(R3)






:
:       ROUTINE TO FREE A RES BLOCK.  R2 POINTS TO THE RES BLOCK
:       TO BE FREED.  THE RES BLOCK IS REMOVED FROM RUBLKS RES CHAINS AND
:       PUT ON THE FREE LIST.  THE FREEING OF THE IA_TA IS BEGUN.
:       ON INPUT R3 SHOULD CONTAIN THE DISCONNECT REASON
:
PROCS(RELRB,$0 0D)
CHAINS(RELRSV,$0 0D)

        DEBUGM(entering RELRB,DBGANC,DALL,RELRSV,$00D)

        LR      R10,R3                  : Save disconnect reason

        LR      R8,RUBLK        : SAVE AUB PTR
        L       R3,RBIATA,R2    : GET RES_IA_TA
        LR      R11,R3          : SAVE RES_IA_TA
        LR      R5,R3           : COPY RES_IA_TA
        SRL     R5,$A16         : STRIP OFF IA_TA
        CVTRES(R5,RELRSV)
        LHI     R7,MAGLNG       : MAGTAB LENGTH
        MR      R4,R7           : CALC OFFSET OF THIS RES'S MAGTAB
        LA      RUBLK,MAGTAB,R5,: RUBLK NOW HAS POINTER TO MAGTAB

        LIS     R4,0
        CALL(TOGIA,RELRSV)      : SHOW IA_TA AVAILABLE (BUT NOT FREE YET!)
        LHR     R7,R3           : SAVE IA_TA

: AT THIS POINT THE PERTINENT REGISTERS ARE:
: R2 - RES BLOCK POINTER TO BE RELEASED
: R7 - IA_TA
: R8 - AUB POINTER
: RUBLK - POINTER TO MAGTAB

        L       R3,RBPTTA,R2,   :R3-PRINTER IA-TA
        IFF(N,THEN)        :IF/=0-DELETE IT FROM R2UYAB
          LR   R9,R1            :save RUBLK
          CL   R2,AUBPRB,R8,    :is it an active printer RES block
          IFF(E,THEN)
            LH   R1,AUBPRT,R8,  :port #
            SLLS R1,2
            AHI  R1,NPORT*4+2  :printer hold buffer-index
            LR   R6,R2          :store R2
            JAL  R4,EMPTY,,     :delete it
            LR   RUBLK,R9       :restore RUBLK
            LR   R2,R6          :restore R2
            L    R3,RBPTTA,R2,  :R3-printer IA-TA
            LIS  R9,0
            ST   R9,AUBPRB,R8,  :store 0 in printer RB pointer
            STB  R9,AUBPMI,R8,  :store 0 in PMI
          ENDIF
          CALL(BINSCH,RELRSV)   :BINARY SEARCH IN R2UTAB
          LR    RRETC,RRETC     :SET CONDIT.CODE
          IFF(E,THEN)
            CALL(R2UDEL,RELRSV)  :IF FOUND-DELETE
            LR  RRETC,RRETC
            IFF(N,THEN)
                LIS  R4,1       :ENCREMENT ERROR COUNTER
                AHM  R4,ERDELP,, :DELETE WASN'T SUCCEED
            ENDIF
          ORELSE
            LIS R4,1
            AHM R4,ERBIDP,,     :ENCREM.ERROR COUNTER-
                                :BINARY SEARCH WASN'T SUCCEED.
          ENDIF
        ENDIF
        L       R3,AUBRCH,R8    : GET AUB CHAIN POINTER
        CR      R3,R2           : DOES FIRST MATCH?
        JNFS    RBSCH           : NO...SKIP
        L       R4,RBNXT,R3     : GET POINTER TO NEXT RB
        ST      R4,AUBRCH,R8    : STORE IN RES CHAIN PTR
        J       RBINIT

RBSCH   L       R4,RBNXT,R3     : GET NEXT POINTER
        CR      R4,R2           : IS THE NEXT GUY THE ONE TO BE RELEASED?
        JE      UNCHRB          : YES
        LR      R3,R4           : MOVE ON TO NEXT RB
        JN      RBSCH           : IF NO ZERO...LOOP
        LCS     RRETC,1         : RB NOT FOUND
        J       RELRET

UNCHRB  L       R5,RBNXT,R4     : GET NEXT POINTER
        ST      R5,RBNXT,R3     : TAKE HIM OUT OF THE CHAIN

RBINIT  LR      R3,R10          : Get disconnect reason for CUSERV
        CALL(CUSERV,RELRSV)     : R2 = pointer to res block
                                : R3 = disconnect reason
                                : R8 = AUB pointer
                                : This call creates a user service record.

        LHI     R3,RBLNG        : SIZE
        SR      R4,R4           : PADDING CHARACTER
        CALL(CLEAR,RELRSV)
        L       R10,RBFREE      : LOAD ADDRESS OF FREE LIST
        ST      R10,RBNXT,R2    : STORE IT IN BLOCK TO BE PUSHED DOWN
        ST      R2,RBFREE       : STORE ADDRESS OF BLOCK IN FREE PTR
        LCS     R3,1
        AM      R3,NUMRB        : 1 LESS ACTIVE RES BLOCK

        LB      R3,AUBTYP,R8    : get current type :sign_in or normal
        CLHI    R3,SIGNIN       : is sign_in ?
        JE      RELRFR          : this routine was called because of sign_in 
                                : failed, don't go free process
        LH      R3,MAGNUM,RUBLK : GET RES #
        LH      R5,RESAOF,R3,R3 : get offset to RESAAA table for this RES
        L       R9,RESAAA+SOFPTR,R5,  : GET POINTER TO sign off AAA ptr table
        JLE     RELRFR          : no sign_off needed, mark IA_TA free anyway
                                : got sign_off AAA ptr table
        LH      R4,MAGSTA,RUBLK : GET RES STATUS
        CLHI    R4,RESUP        : IS RES "UP"?
        JE      RBGETF          : YES. GET A FREE BLOCK

RBDR2U  LR      R3,R11          : RES ISN'T UP. DELETE R2UTAB ENTRY
        CALL(BINSCH,RELRSV)
        LR      R4,RRETC
        SR      RRETC,RRETC
        LR      R4,R4           : TEST RETURN CODE FROM BINSCH
        JN      RELRET          : NOT ACTIVE RES BLOCK
        CALL(R2UDEL,RELRSV)
        SR      RRETC,RRETC
        J       RELRET

RBGETF  CALL(GETFRE,RELRSV)     : GET A FREE BLOCK
        LR      RRETC,RRETC     : got one if return code GE 0
        JGE     RBGOTF          : 
        LIS     R4,1            : increment error counter no free block
        AHM     R4,RELNOF       : 
        J       RBDR2U          : delete entry in R2uTAB
RBGOTF  LR      R4,R7           : IA_TA
        LHI     R5,IATUSR       : IA_TA WAS IN USE BY A USER
        CALL(SETFRE,RELRSV)
        CALL(ACTFRE,RELRSV)

        L       R3,FREITA,R2    : RES_IA_TA
        CALL(BINSCH,RELRSV)     : ADDRESS OF ENTRY IN R2UTAB
        LR      RRETC,RRETC     : WAS ENTRY FOUND?
        JNFS    NOTACT          : NO
        CALL(R2UDEL,RELRSV)     : DELETE CURRENT ENTRY

NOTACT  LR      R10,RUBLK       : SAVE MAGTAB POINTER
        LR      RUBLK,R2        : RUBLK NOW CONTAINS FREBLK POINTER
        CALL(R2UADD,RELRSV)     : ADD NEW ENTRY TO R2UTAB
        LR      R12,R8          :save AUB ptr
        L       R8,0,R9         : get cmd ptr table for this AAA
        ST      R8,SGNCMP,RUBLK : put it in F.B for SGNCMH
        LR      R8,R10          : R8 = MAGTAB_ptr
        CALL(SGNCMH,RELRSV)     : with R1(RUBLK) = ptr to free block
                                :      R8 = MAGTAB_ptr
        LR      R8,R12          : restore AUB ptr
        SR      RRETC,RRETC
        J       RELRET

RELRFR  LR      R3,R11          : GET RES_IA_TA
        CALL(BINSCH,RELRSV)
        LR      RRETC,RRETC
        JNFS    NODEL           : NOT ACTIVE RES BLOCK
        CALL(R2UDEL,RELRSV)

NODEL   LHR     R4,R3           : IA_TA
        CALL(PEEKFR,RELRSV)     : LOOK AT FREE/NOT FREE BIT
        RBT     R2,MAGFRE,RUBLK : MARK IA_TA AS FREE
        SR      RRETC,RRETC
        J       RELRET


RELRET  LR      RUBLK,R8        : RESTORE AUB PTR
        RETURN(R2)








:
:       ROUTINE TO ACTIVATE A RES BLOCK. R2 POINTS TO RES BLOCK TO BE 
:       ACTIVATED.  R2 IS STORED IN THE ACTIVE RB FIELD OF RUBLK.
:       THE MAGIATA BIT FOR RBIATA IS TURNED ON.
:       CALLS ARE MADE TO REMOVE RESIATA AND ADD RESIATA.
:
PROCS(ACTRES,$0 0D)
CHAINS(ARSSV,$0 0D)
        SR      RRETC,RRETC     :ZERO RETURN CODE
        ST      R2,AUBARB,RUBLK :STORE RB IN ACTIVVE POINTER
	LB	R3,RBLIC,R2	:GET CARL SETTING
	STB	R3,AUBCRL,RUBLK
	L	R3,RBIATA,R2	:GET NEW RES IA TA
        ST      R3,AUBRIT,RUBLK :RES_IA_TA of active res block
	CALL(BINSCH,ARSSV)      :require R3=RES_IA_TA, search in R2UTAB
                                :return 0 if found, -1 if not found
	LR	RRETC,RRETC	:TEST RETCODE
	JNFS	FNDPLC		:FOUND WHERE IT GOES
	JAL	R10,CRASH,,
	BC	0,0,4*RLINK,CRR2U	:CRASH CODES
:
FNDPLC	CALL(R2UADD,ARSSV)
	LR	RRETC,RRETC
	JEFS	ARSRET		:SUCCESS
	JAL	R10,CRASH,,
	BC	0,0,4*RLINK,CRR2U
:
ARSRET	RETURN(R2)







:
:       ROUTINE TO RELEASE ALL RBS ASSOCIATED WITH AN AUB
:       RUBLK POINTS TO AN AUB.  ON RETURN ALL RES BLOCKS
:       (IF ANY) ARE RELEASED....
:
PROCS(RELRBS,$0 0D)
CHAINS(RRBSSV,$0 0D)
        LB      R3,AUBDRN,RUBLK,        :GET DISCONNECT REASON
        L       R2,AUBRCH,RUBLK         :GET RES BLOCK CHAINS POINTER
:
RELONE  JE      RBSDON          :IF POINTER IS ZERO THEN DONE
        L       R4,RBNXT,R2             :GET NEXT ENTRY IN CHAINS
        CALL(RELRB,RRBSSV)              :RELEASE RB
        LR      R2,R4           :GO TO NEXT RB IN CHAINS
        J       RELONE
:
RBSDON  ST      R2,AUBRCH,RUBLK :ZERO CHAINS POINTER
:
       RETURN(R2)






:
:       ROUTINE TO SET OR RESET AN IATA BIT IN THE MAGTABLE
:       R3 IS THE LINE IA TA IN THE LOW ORDER 3 BYTES
:       R4=0 MEANS SET IATA BIT TO ZERO,
:       R4\=0 MEAS SET THE IATA BIT TO ONE
:
PROCS(TOGIA,$0 0D)
CHAINS(TOGISV,$0 0D)
        LR      R10,RUBLK       : SAVE CURRENT RUBLK VALUE
        SR      RRETC,RRETC     :ZERO RETURN CODE
        LR      R7,R3           :PRESERVE R3 FOR LATER
        SRL     R7,$A16           :SHIFT OFF THE IA AND TA BYTES
	CVTRES(R7,TOGISV)	:CVT RES NUMBER TO MAGTAB ENTRY NUMBER
        LHI     R5,MAGLNG       :LOAD LENGTH OF A MAG TABLE ENTRY
        MR      R6,R5           :R7 NOW POINTS AT THE START OF THE MAGTAB
        LA      RUBLK,MAGTAB,R7,,:SET RUBLK TO MAGTAB FOR THIS RES
:
        CHVR    R6,R3           :R6 IS IA TA...
	LBR	R8,R6		:R8 IS THE TA
        IF      MULTIA
	        SRLS    R6,8            :SHIFT OUT TA
	        SLLS    R6,6            :SHIFT LEFT TO LINE UP WITH IA
	        OR      R8,R6           :OR 6 BIT IA AND TA TOGETHER
	EI
        LR      R4,R4           :CHECK FOR SET OR RESET
        JN      SET2            :NONZERO SET IT
        RBT     R8,MAGITA,RUBLK : RESET IT
        LR      RUBLK,R10       : RESTORE RUBLK
        RETURN(R2)              :GO BACK TO CALLER
:
SET2    LR      R4,R3           :LOAD IATA IN R4
        CALL(PEEKFR,TOGISV)
        LR      RRETC,RRETC     :CHECK RETURN CODE
        JN      SET3          :IF NOT ZERO, IATA NOT FREE
:
        SBT     R2,MAGFRE,RUBLK :SET FREE BIT TO NOT FREE
	LIS	R0,0		:INIT RETURN CODE
        SBT     R8,MAGITA,RUBLK :SET IT
	JEFS	SET3		:TEST PREVIOUS SETTING OF BIT
	LIS	R0,1		:BIT WAS ALREADY SET
SET3    LR      RUBLK,R10       : RESTORE RUBLK
        RETURN(R2)







        IF      SG.RTO
PROCS(RESHKP,$0 0D)
CHAINS(RESHSV,$0 0D)
:
: RES BLOCK HOUSEKEEPER TIMEOUT ROUTINE
:
: THE FUNCTION OF THIS ROUTINE IS TO RELEASE RES BLOCKS, THEREBY
: STARTING THE FREEING PROCESS, OF THOSE RES BLOCKS THAT HAVE BEEN
: SWITCHED AWAY FROM TOO LONG.
:
: THIS ROUTINE LOOKS AT EVERY RES BLOCK VIA EVERY AUB.
:
: IT RESCHEDULES ITSELF TO RUN EITHER IN 'RESINT' SECONDS, IF THERE
: ARE NO SWITCHED RES BLOCKS, OR WHEN THE NEXT RES BLOCK IS
: DUE TO TIME OUT, UNLESS THIS TIME IS LESS THAN 'RESMIN', IN WHICH
: CASE THIS ROUTINE WILL RUN AGAIN IN 'RESMIN' SECONDS.
:

        DEBUGM(ENTERING RESHKP,DBGANC,DALL,RESHSV,$0 0D)

        LHI     R11,RESINT      : INIT 'NEXT TIME' TO RUN TO 'RESINT'

        LH      R3,RESTOT,,     : IS THE RES TIMEOUT FUNCTION ENABLED?
        JE      RESH25          : IF RESTOT = 0, RES TIMEOUT DISABLED

: DO WHILE AUBS IN CHAIN
        L       RUBLK,AUTACT,,  : GET POINTER TO FIRST ACTIVE AUB
        JE      RESH25          : IF POINTER = 0, NO AUBS AT ALL

: DO WHILE RES BLOCKS IN CHAIN FOR THIS AUB
RESH00  L       R2,AUBRCH,RUBLK,: GET FIRST RES BLOCK POINTER
        JE      RESH20          : NO RES BLOCKS FOR THIS AUB

RESH05  L       R5,RBNXT,R2,    : SAVE POINTER TO NEXT RES BLOCK IN CHAIN
        LH      R7,RBSTO,R2,    : GET RES TIMEOUT VALUE FOR THIS RES (SECONDS)
        JE      RESH15          : IF RBSTO = 0, NO RES TIMEOUT FOR THIS RES

        L       R8,RBSCHT,R2,   : GET TIME THAT THIS RES BLOCK WAS SWITCHED
        JE      RESH15          : IF RBSCHT = 0, THIS RES BLOCK IS ACTIVE

        L       R9,SLOWC,,      : GET CURRENT TIME (SECONDS)
        SR      R9,R8           : CALCULATE ELAPSED TIME SINCE SWITCH
        CR      R9,R7           : IS ELAPSED TIME > RES TIMEOUT
        JL      RESH10          : IF LOW DON'T TOUCH THIS RES BLOCK

: RELEASE RES BLOCK.  STARTS FREEING PROCESS, IF ENABLED
        LH      R10,RBRESC,R2,  : SAVE RES CODE FOR MESSAGE TO USER
        LIS     R3,DISRTO       : Set the reason for disconnect to res time out
        CALL(RELRB,RESHSV)      : RELEASE RES BLOCK
                                :   R2 POINTS TO RES BLOCK TO BE RELEASED
                                :   RUBLK POINTS TO AUB

: SEND MESSAGE TO USER TELLING HIM HIS RES HAS TIMED OUT
        LA      R2,RESTMS,,     : RES TIMEOUT MESSAGE
        STB     R10,$A 46,R2,   : STORE SECOND CHAR OF RES CODE IN MESSAGE
        SRLS    R10,8           : MOVE FIRST CHAR OF RES CODE INTO LOW BYTE
        STB     R10,$A 45,R2,   : STORE FIRST CHAR OF RES CODE IN MESSAGE
        CALL(SENDIT,RESHSV)     : SEND MESSAGE TO USER
                                :   R2 POINTS TO MESSAGE IN SC FORMAT
                                :   RUBLK POINTS TO AUB

: SEND MESSAGE TO TRACING MONITORS
        TRLOG(UTIMEO,RESHSV)

: NOTE THAT A RES TIMEOUT HAS OCCURRED
        LIS     R2,1
        AHM     R2,NUMRTO,,     : INCREMENT RES TIMEOUT COUNTER
        J       RESH15          : GET NEXT RES BLOCK

RESH10  SR      R7,R9           : CALCULATE REMAINING TIME BEFORE THIS
                                : RES BLOCK TIMES OUT
        CR      R7,R11          : IS REMAINING TIME < NEXT TIME?
        JGE     RESH15          : IF GE THEN DON'T CHANGE NEXT TIME
        LR      R11,R7          : REMAINING TIME < NEXT TIME. CHANGE NEXT TIME

: END DO WHILE RES BLOCKS IN CHAIN FOR THIS AUB
RESH15  LR      R2,R5           : MOVE POINTER OF NEXT RES BLOCK TO R2
        JN      RESH05          : IF POINTER \= 0 GO TO TOP OF RES BLOCK LOOP

: END DO WHILE AUBS IN CHAIN
RESH20  L       RUBLK,AUBNXT,RUBLK,: GET POINTER TO NEXT AUB
        JN      RESH00          : IF POINTER \= 0 GO TO TOP OF AUB LOOP

: FELL OUT OF BOTH AUB AND RES BLOCK LOOPS.  ALL RES BLOCKS HAVE BEEN PROCESSED
        CLI     R11,RESMIN      : IS NEXT TIME < MINIMUM TIME INTERVAL FOR
                                : FOR RUNNING THIS ROUTINE AGAIN
        JGE     RESH25          : IF GE, THEN DON'T CHANGE NEXT TIME
        LHI     R11,RESMIN      : RERUN IN MINIMUM TIME

: RESCHEDULE RESHKP
RESH25  M       R10,NRATE,,     : # OF FASTC TICKS PER SECOND
                                : (LOW ORDER HALF OF PRODUCT IN R11)
        A       R11,FASTC,,     : TIME TO RUN AGAIN
        LR      R1,R11          : MOVE TIME TO R1 FOR TOPUT
        LA      R0,RESHST,,     : ADDRESS FOR TIMEOUT LIST
        JAL     R5,TOPUT,,      : ADD TO TIMEOUT LIST

        LIS     RRETC,0         : ZERO RETURN CODE
        RETURN(R1)


: ENTRY ROUTINE JUMPED TO BY TIMOUT LIBRARY ROUTINE
CHAINS(RESHS1,$0 0D)

RESHST  CALL(RESHKP,RESHS1)     : CALL RES HOUSEKEEPER
        J       TORET,,         : RETURN TO TIMOUT ROUTINE
        EI                      : SG.RTO
        EM


:(MATS.P2)FREPGM.S01
:       Copied by chen from (mats.p2)FREPGM.04S on 1/19/86
:       make changes in routines: SETFRE, FREEUP, POOLIA
:       to accomodate the new structure of auto_sign_off
: (MATS.P2)FREPGM.04S
:    Copied by Gimnicher from (MATS.P2)FREPGM.03S.  1-12-81
:    Changes made to skip over printer ia-ta for printer project.

: (MATS.P2)FREPGM.03S copied from (MATS.P2)FREPGM.02S on 11-10-80
: by Steve Gimnicher in order to implement limiting IA_TA freeing attempts.
: ------------------------------------------------------------------------
: (STEVEG)FREPGM.02S copied from (STEVEG)FREPGM.NAD on 10-13-80
: by Steve Gimnicher in order to modify the CVTRES call for
: Monitor Screen Formatter implementation.
:
        RA      $00
        MO      .+3&-4,FREPGM
:                       SET TO LOAD CODE SEGMENT
        SEG     1

        GL      FB.AAA,HNGFRE

:
:       ROUTINE TO INITIALIZE THE FRE LIST
:       ON RETURN ALL FREBLKS WILL BE LINKED TOGETHER
:
PROCS(INTFRE,$0 0D)
CHAINS(INTFSV,$0 0D)
:
        LI      R2,FRETAB       :GET ADDR OF FREE BLOCK AREA
        ST      R2,FREFRE       :FREFRE -> FIRST FREBLK
        LI      R3,NFRE*FRELNG  : SIZE OF AREA TO BE INITIALIZED
        SR      R4,R4           :INIT TO ZEROES
        CALL(CLEAR,INTFSV)
        LHI     R9,NFRE         :INIT LOOP COUNTER
:
FRELOP  LA      R11,FRELNG,R2   :ADDR OF NEXT FREBLK
        ST      R11,FRENXT,R2   :CHAIN TOGETHER
        LR      R2,R11          :BUMP POINTER
        SHI     R9,1            :DECREMENT COUNTER
        JN      FRELOP          :JUMP IF NOT DONE
:
        SHI     R2,FRELNG       :BACKUP TO LAST FREBLK
        ST      R4,FRENXT,R2    :NULL LAST LINK
        ST      R4,FREACT       :NULL POINTER TO ACTIVE FREBLKS
        ST      R4,NUMFRE       :ZERO ACTIVE FREBLK COUNTER
        SR      RRETC,RRETC     :CANT FAIL
        RETURN(R2)






:
:       ROUTINE TO GET A FREBLK FROM FREE BLOCK LIST
:       NON-ZERO RETURN MEANS FAILED
:       R2 POINTS TO FREBLK RETURNED
:
PROCS(GETFRE,$0 0D)
CHAINS(GETFSV,$0 0D)

        DEBUGM(entering GETFRE,DBGANC,DALL,GETFSV,$00D)
        L       R2,FREFRE       :LOAD POINTER TO FRE FREE BLKS
        JN      MORFRE          :NOT NULL THEN JUMP
        LHI     RRETC,-1        :NO FREE BLOCKS LEFT SET BAD RC
        RETURN(R2)
:
MORFRE  L       R11,FRENXT,R2   :GET POINTER TO NEXT FREE BLOCK
        ST      R11,FREFRE      :POINT FREE LIST AT IT
:
        LIS     R3,1            :LOAD A 1
        AM      R3,NUMFRE       :ADD THIS BLOCK TO ACTIVE NUMBER
        SR      RRETC,RRETC     :GOOD RETURN
        RETURN(R3)






:
:       ROUTINE TO RELEASE A FREBLK
:       FREBLK TO BE RELEASED IS POINTED TO BE R2
:
PROCS(RELFRE,$0 0D)
CHAINS(RELFSV,$0 0D)

        DEBUGM(entering RELFRE,DBGANC,DALL,RELFSV,$00D)
        L       R11,FREACT      :LOAD FREE CHAIN POINTTER
        CR      R11,R2          :COMPARE TO ADDRESS PASSED
        JEFS    FNDFRE          :IF EQUAL FOUND IT
:
FRESER  L       R10,FRENXT,R11  :MOVE DOWN CHAIN
        JE      NOFRE           :IF ZERO ERROR NOT IN FREBLK CHAIN
        CR      R10,R2          :COMPARE TO PASSED ARG
        JEFS    FNDIT           :FOUND DESIRED BLOCK IN MIDDLE OF CHAIN
        LR      R11,R10         :MOVE ON
        JBS     FRESER          :TRY AGAIN
:
FNDFRE  L       R9,FRENXT,R2    :GET SUCCESSOR
        ST      R9,FREACT       :STORE POINTER TO SUCCESSOR
        JFS     FNDFR1
:
FNDIT   L       R9,FRENXT,R2    :GET SUCCESSOR
        ST      R9,FRENXT,R11   :REMOVE FROM CHAIN
:
FNDFR1   LHI    R3,FRELNG       :LENGTH TO BE CLEARED
        SR      R4,R4           :CLEAR TO ZEROS
        CALL(CLEAR,RELFSV)
:
        L       R9,FREFRE       :LOAD POINTER OT FREE LIST
        ST      R9,FRENXT,R2    :CHAIN INTO FRELIST
        ST      R2,FREFRE       : POINT FREFRE AT BLOCK FREED
        LCS     R3,1
        AM      R3,NUMFRE       :DECREMENT NUMFRE
        SR      RRETC,RRETC     :SET GOOD RETURN CODE
        RETURN(R3)
NOFRE   JAL     R10,CRASH,,     :NOW CRASH
        BC      0,0,4*RLINK,BADFRE






:
:       ROUTINE TO PLACE A FREE BLOCK IN THE ACTIVE FREE LIST
:       R2 POINTS TO THE FREBLK TO BE ACTIVATED
:
PROCS(ACTFRE,$0 0D)
        L       R11,FREACT      :GET HEAD OF ACTIVE FREE BLOCK LIST
        ST      R11,FRENXT,R2   :LINK FREBLK TO HEAD OF LIST
        ST      R2,FREACT       :POINT HEAD AT NEW FREBLK
        SR      RRETC,RRETC     :ZERO RETURN
        RETURN(R3)







:
: ROUTINE TO SEARCH THROUGH ALL THE ACTIVE FREE BLOCKS FOR A
: MATCH ON THE RES #
:
PROCS(MATFRE,$0 0D)
CHAINS(MATFSV,$0 0D)
:
: PARMS:
:        R3  RES #
: RETCODES:
:        R0 = 0 IF NO MATCH IS FOUND
:        R0 (RRETC) = ADDRESS OF FREE BLOCK IF FOUND
:
        DEBUGM(entering MATFRE,DBGANC,DALL,MATFSV,$00D)
	L	R2,FREACT	: GET START OF ACTIVE FREE LIST
	JE	MATF02		: JUMP IF NO ACTIVE FREES

MATF01	CLH	R3,FRERES,R2	: COMPARE TO RES #
	JE	MATF03		: IF EQUAL WE HAVE A MATCH
	L	R2,FRENXT,R2	: NO MATCH. GET PTR TO NEXT FREE BLOCK
	JNBS	MATF01		: LOOP IF ACTIVE FREE BLOCK
MATF02	SR	RRETC,RRETC	: NO MATCHES
	JFS	MATF04
MATF03	LR	RRETC,R2	: ADDRESS OF FREE BLOCK FOUND
MATF04	RETURN(R2)







:
:       ROUTINE TO KILL (RELEASE) ALL ACTIVE FREE BLOCKS.
:
: PARMS:    R3 - RES NUMBER
:
PROCS(KILFRE,$0 0D)
CHAINS(KILFSV,$0 0D)

        DEBUGM(entering KILFRE,DBGANC,DALL,KILFSV,$00D)
KILF01  CALL(MATFRE,KILFSV)     : LOCATE AN ACTIVE FREE BLOCK
        LR      R2,RRETC        : POINTER RETURNED IN RRETC
        JE      KILF03          : NO FREE BLOCKS
        LR      R6,R3           : SAVE RES #
        L       R3,FREITA,R2    : SAVE RES_IA_TA OUT OF FREE BLOCK
        CALL(RELFRE,KILFSV)     : RELEASE FREE BLOCK
        CALL(BINSCH,KILFSV)     : FIND LOCATION OF RES_IA_TA IN R2UTAB
        LR      RRETC,RRETC     : WAS ENTRY IN R2UTAB
        JN      KILF02          : NOT FOUND...SEVERE ERROR?
        CALL(R2UDEL,KILFSV)     : REMOVE RES_IA_TA FROM R2UTAB

KILF02  LR      R3,R6           : GET RES # AGAIN
        J       KILF01          : LOOP

KILF03  RETURN(R2)              : ALL ACTIVE FREE BLOCKS RELEASED







:
: ROUTINE TO "PEEK" AT THE AVAILABLE/IN USE BIT 
:
: PARMS:   R4 - IA_TA
:          RUBLK - POINTER TO MAGTAB
: 
: RETURNS: R2 - BIT OFFSET OF IA_TA IN MAGITA
:          RRETC - 0 BIT WAS OFF
:                - 1 BIT WAS ON
:
PROCS(PEEKIA,$0 0D)

        LHR     R6,R4           : R4 IS THE IA_TA
        LBR     R2,R6           : R2 IS THE TA
        IF      MULTIA
        SRLS    R6,8            : SHIFT OUT TA
        SLLS    R6,6            : SHIFT LEFT TO LINE UP WITH TA
        OR      R2,R6           : OR 6 BIT IA_TA TOGETHER
        EI

        TBT     R2,MAGITA,RUBLK : TEST BIT
        JG      PEKI01          : IA_TA IN USE

        SR      RRETC,RRETC     : IA_TA AVAILABLE
        JFS     PEKI02

PEKI01  LIS     RRETC,1         : SHOW BIT WAS ON

PEKI02  RETURN(R3)







:
: ROUTINE TO "PEEK" AT THE FREE/NOT FREE BIT
:
: PARMS:   R4 - IA_TA
:          RUBLK - POINTER TO MAGTAB
: 
: RETURNS: R2 - BIT OFFSET OF IA_TA IN MAGFRE
:          RRETC - 0 BIT WAS OFF
:                - 1 BIT WAS ON
:
PROCS(PEEKFR,$0 0D)

        LHR     R6,R4           : R4 IS THE IA_TA
        LBR     R2,R6           : R2 IS THE TA
        IF      MULTIA
        SRLS    R6,8            : SHIFT OUT TA
        SLLS    R6,6            : SHIFT LEFT TO LINE UP WITH TA
        OR      R2,R6           : OR 6 BIT IA_TA TOGETHER
        EI

        TBT     R2,MAGFRE,RUBLK : TEST BIT
        JG      PEKF01          : IA_TA NOT FREE

        SR      RRETC,RRETC     : IA_TA FREE
        JFS     PEKF02

PEKF01  LIS     RRETC,1         : SHOW BIT WAS ON

PEKF02  RETURN(R3)







:
: ROUTINE TO SET UP A FREE BLOCK
:
: PARMS:   R2 - POINTER TO FREE BLOCK
:          R3 - RES #
:          R4 - IA_TA
:          R5 - FREMOD INDICATOR (WHAT TYPE OF IA_TA IS BEING FREED)
:          R9 - POINTER TO auto_signoff AAA pointer table FOR RES
:          RUBLK - POINTER TO MAGTAB

PROCS(SETFRE,$0 0D)

        LHI     R7,MAGLIC-1
SETF01  LB      R10,MAGPRT,RUBLK,R7     : COPY THROUGH 'MAGLIC' FROM MAGTAB TO FRETAB
        STB     R10,FREPOR,R2,R7
        SIS     R7,1
        JGEBS   SETF01

        STB     R5,FREMOD,R2    
 
        LHI     R7,SIGNOF
        STB     R7,FRETYP,R2

        STH     R3,FRERES,R2
        EXHR    R3,R3           : FORM RES_IA_TA
        OR      R3,R4
        ST      R3,FREITA,R2

        ST      R9,FREAAA,R2    : POINTER TO auto_sign_off AAA table
                                : this field is not used any more

        LIS     R0,1
        AM      R0,SOFREB,,     :ADD 1 TO COUNTER

        LIS     R0,0
        STH     R0,FRENRB,R2    :CLEAR BAD-RESPONSE COUNT IN FREE BLOCK
        STH     R0,FRENRT,R2    :CLEAR NO-RESPONSE COUNT IN FREE BLOCK
        ST      R0,FRETIM,R2    :CLEAR TIME IN FREE BLOCK
        LHI     R0,SGOLMT       :GLOBAL MAX FREEING ATTEMPTS
        STH     R0,FRELMT,R2    :STORE IN FREE BLOCK
        LHI     R0,SGORND       :# of rounds to free a frozen address
        STB     R0,FREHKP,R2    :

        RETURN(R2)







:
: ROUTINE TO INITIATE THE FREEING OF ALL IA_TAS FOR A RES NUMBER THAT
: AREN'T ALREADY FREE
:
: PARMS:   R5 - RES NUMBER
:          RUBLK(R1) - POINTER TO MAGTAB
:
:

PROCS(FREEUP,$0 0D)
CHAINS(FREESV,$0 0D)

        DEBUGM(entering FREEUP,DBGANC,DALL,FREESV,$00D)
        LR      R3,R5           : SAVE RES #
        LH      R5,RESAOF,R3,R3 : get offset to RESAAA table for this res
        L       R9,RESAAA+SOFPTR,R5, : GET POINTER TO sign_off AAA table
        JLE     FREU05          : NO auto_sign_off  FOR THIS RES
        L       R6,RESAAA+ITAPTR,R5,    : POINTER TO IA_TA POOL POINTER TABLE
        JLE     FREU03          : NO IA_TA POOL POINTER TABLE. BAD NEWS!

FREU01  L       R12,0,R6        : POINTER TO FIRST IA_TA POOL
        JLE     FREU05          : NO IA_TAS AT ALL
        LH      R4,LITCNT,R12   : NUMBER OF IA_TAS IN CURRENT POOL
        JGFS    FREU02
        AIS     R6,4            : NEXT POOL POINTER
        JBS     FREU01
FREU02  SLLS    R4,2            : * 2 (HALFWORD EACH) * 2 (# OF PRINTER
                                : & CRT IA_TAS)
        SIS     R4,4            : R4 NOW HAS OFFSET OF LAST CRT IA_TA IN POOL
        ST      R4,MAGPOF,RUBLK

        AIS     R6,4            : POINTER TO NEXT IA_TA POOL POINTER
        ST      R6,MAGPOL,RUBLK

        LI      R12,LITITA,R12  : ADDRESS OF FIRST IA_TA IN POOL
        ST      R12,MAGCPL,RUBLK: POINTER TO BEGINNING OF CURRENT IA_TA POOL

        LHI     R4,FRESTT       : # OF FREBLKS TO STARTUP AT ONE TIME
        CALL(POOLIA,FREESV)     :with R1(RUBLK) = ptr to MAGTAB
                                :     R3 = RES #
                                :     R4 = # of IA_TAs to be freed
                                :     R9 = ptr to AAA_ptr table
        SR      RRETC,RRETC
        JFS     FREU10

FREU03  JAL     R10,CRASH,,     : RES DATA PRESENT, BUT NO IA_TA POOL
                                : POINTER TABLE. 'ENDLUD' MACRO PROBABLY
                                : MISSING FROM LUD CONFIGURATION
        BC      0,0,4*RLINK,NOPOOL

FREU05  LIS     RRETC,1
FREU10  RETURN(R2)







:
: ROUTINE TO START UP THE FREEING PROCSESS FOR A GROUP OF IA_TAS FOR
: A PARTICULAR RES.  THESE IA_TAS ARE TAKEN DIRECTLY FROM THE IA_TA POOLS.
: THESE IA_TAS ARE PROCESSED FROM THE POOLS IN REVERSE ORDER
: (JUST AS THEY ARE ASSIGNED).
:
: PARMS:   R3 - RES NUMBER
:          R4 - # IA_TAS TO FREE
:          RUBLK - POINTER TO MAGTAB
:          R9 - POINTER TO AAA DATA AREA FOR RES
:
: OUTPUT:  R0 - 0 IA_TA FREE STARTED
:             - 1 NO MORE IA_TAS IN POOL

PROCS(POOLIA,$0 0D)
CHAINS(POOLSV,$0 0D)

        DEBUGM(entering POOLIA,DBGANC,DALL,POOLSV,$00D)
        LR      R11,R3          : SAVE RES #
        LR      R7,R4           : SAVE # IA_TAS TO FREE
        L       R12,MAGCPL,RUBLK: POINTER TO CURRENT POOL
        L       R10,MAGPOF,RUBLK: OFFSET INTO CURRENT IA_TA POOL
        JGE     POOL05          : STILL HAVE IA_TAS IN CURRENT POOL

POOL00  L       R6,MAGPOL,RUBLK : NEED A NEW POOL
        JG      POOL03          : THERE IS ONE

POOL02  LIS     RRETC,1        : ALL IA_TAS PROCESSED
        J       POOL25

POOL03  L       R12,0,R6        : POINTER TO IA_TA POOL
        JLEBS   POOL02
        LH      R4,LITCNT,R12   : # OF IA_TA PAIRS IN CURRENT POOL
        JGFS    POOL04
        AIS     R6,4            : NO IA_TAS IN THIS POOL. NEXT POOL
        JBS     POOL03

POOL04  SLLS    R4,2            : * 2 (HALFWORD EACH) * 2 (# OF PRINTER
                                : & CRT IA_TAS)
        SIS     R4,4            : R4 NOW CONTAINS OFFSET OF LAST CRT IA_TA IN POOL
        LR      R10,R4
        AIS     R6,4            : NEXT POOL POINTER
        ST      R6,MAGPOL,RUBLK

        LI      R12,LITITA,R12  : ADDRESS OF FIRST IA_TA IN POOL
        ST      R12,MAGCPL,RUBLK

POOL05  LH      R4,0,R10,R12    : GET AN IA_TA
        CALL(PEEKIA,POOLSV)     : SEE IF IA_TA AVAILABLE
        LR      RRETC,RRETC     : IS IA_TA ASSIGNED (IN USE)?
        JN      POOL15          : YES
        CALL(PEEKFR,POOLSV)     : IS IA_TA ALREADY FREE?
        LR      RRETC,RRETC
        JE      POOL15          : YES, IA_TA ALREADY FREE

        CALL(GETFRE,POOLSV)     : GET A FREE BLOCK
        LR      RRETC,RRETC
        JL      POOL25          : NO FREE BLOCKS AVAILABLE

        LR      R3,R11          : GET RES #
        LHI     R5,IATPOL       : SHOW THIS IA_TA CAME FROM A POOL
        CALL(SETFRE,POOLSV)     : SET UP FREE BLOCK
                                : R2 - POINTER TO FREE BLOCK
                                : R3 - RES NUMBER
                                : R4 - IA_TA
                                : R5 - TYPE OF FREE
                                : R9 - POINTER TO auto_sign_off AAA table
                                : RUBLK - POINTER TO MAGTAB
        CALL(ACTFRE,POOLSV)
        L       R3,FREITA,R2    : GET RES_IA_TA
        CALL(BINSCH,POOLSV)
        LR      R13,RUBLK       : MAGTAB PTR
        LR      RUBLK,R2        : FREBLK POINTER FOR R2UADD
        CALL(R2UADD,POOLSV)     : ADD TO R2UTAB
        LR      RRETC,RRETC
        JEFS    POOL10          : EVERYTHING OK

        JAL     R10,CRASH,,     : R2UTAB FULL
        BC      0,0,4*RLINK,CRR2U

POOL10  
        L       R8,0,R9         : get cmd ptr table for this aaa
        ST      R8,SGNCMP,RUBLK : put it in F.B for SGNCMH
        LR      R8,R13          : get magtab ptr in R8
        CALL(SGNCMH,POOLSV)     : with R1=ptr to free block
                                :      R8=MAGTAB ptr
        LR      RUBLK,R13       : RESTORE MAGTAB_ptr
        SIS     R7,1            : DECREMENT IA_TA FREE COUNTER
        JG      POOL12          : FREE ANOTHER IA_TA
        SIS     R10,4           : DECREMENT CRT IA_TA OFFSET
        SR      RRETC,RRETC     : ALL IA_TA FREEING STARTED
        J       POOL25

POOL12  SIS     R10,4           : DECREMENT IA_TA OFFSET
        JGE     POOL05          : FREE ANOTHER IA_TA
        J       POOL00          : POOL EMPTY. TRY NEXT ONE

POOL15  SIS     R10,4           : IA_TA IN USE OR ALREADY FREE. TRY NEXT ONE
        JGE     POOL05
        J       POOL00          : POOL EMPTY. TRY NEXT ONE


POOL25  ST      R10,MAGPOF,RUBLK: SAVE IA_TA OFFSET IN CURRENT POOL
        RETURN(R2)









        EM

:(mats.p2)SGNPRO.S01
:       Created by Margalit	1/27/87
: SiGN_PROcess
:       This is the common routine to handle auto_sign_in and auto_sign_off
: processes after sign in(or off) process is initiated and the first command is
: sent. It is called by SGNTXT whenever a text arrives from host and the
: user is in sign in or sign off stage. Basically, it checks the response
: received with the configured one, if the response is good then send the next
: command... until the whole process is done. The first command is send when
: sign process starts by:
:
:  1. VALDTR - after user's validation complete and before banner/prompt
:              is sent to user, the auto_sign_in process starts..
:  2. RELRB  - when an address is to be released due to user's logoff
:              the port is zapped...etc., the auto_sign_off process starts...
:  3. POOLIA - when system starts up and pools of addresses to be freed,
:              auto_sign_off starts...
:  4. SGNAGN - if no response or bad response occurs, restart the process
:              again, send the first command...
: Routines 1, 2, 3 and 4 are to initialize an auto_sign_in(or off) process,
: and to send the first command. From then on, this rouitne is
: invoked by SGNTXT until the sign process is complete.
: This routine transparently handles the sign process(send cmd, check response)
: without knowing the type of sign process until the whole process is done.
: It is the resposibility of caller to set up a block(F.B or AUB) and its
: related fields before calling this routine.
:
: INPUT  - 
:        RUBLK : pointer to AUB or free block
:        R8    : pointer to MAGTAB entry
: 

	GL	VALD9F

	PROCS(SGNPRO,$0 0D)
	CHAINS(SGNPSV,$0 0D)
	

	  CALL(SGNRSH,SGNPSV)		: go check the response
	  LR	R0,R0			: check if response matches
	  IFF(N,THEN)			: if good response: 1=matched
                                        :  0 = no match
	    L	R9,SGNCMP,RUBLK		: pointer to cmd_pointer
            JL  SGNP03                  : done rsp, go for next AAA
	    L	R9,0,R9			: command pointer
	    IFF(G,THEN)			: if there are more commands
	      CALL(SGNCMH,SGNPSV)	: send next command
	    ORELSE			: no more commands
SGNP03	      L	R9,SGNAAP,RUBLK		: AAA pointer
	      AIS R9,4			: next AAA pointer
	      L   R10,0,R9		: check cmd_tbl pointer
	      IFF(LE,THEN)		: if no more AAA's
	        LB  R9,SGNTYP,RUBLK	: sign type(in or off)
		CHI R9,SIGNIN
		IFF(E,THEN)		: if signin
		  LHI R9,LUDNUR		: normal user
		  STB R9,AUBTYP,RUBLK	: make it normal user again
		  LB  R9,AUBD9F,RUBLK	: saved by VALDTR
		  STB R9,VALD9F,,
		  CALL(RESSET,SGNPSV)	: to send the banner
                  LHL R10,AUBPRT,RUBLK  : get port number
                  L   R9,AUBARB,RUBLK   : get active R.B.
                  LO  FRONT
                  LHL R9,RBCTO,R9       : get command timeout
                  IFF(G,THEN)           : active command timeout
                    A    R9,SLOWC,,        : get the timeout value
                    SLLS R10,2             : port # * 4
                    ST   R9,ATIME,R10      : save time
                    SRLS R10,2             : restore port #
                    SBT  R10,PTIME         : set bit to indicate timeout act.
                  ORELSE                : no timeout activated
                    RBT  R10,PTIME      : clear bit, no timeout needed
                  ENDIF                 : command timeout checks
                  FO  FRONT

		ORELSE			: signoff
		  CALL(SOFDON,SGNPSV)	: complete the signoff process
		ENDIF			: signin or signoff
	      ORELSE			: do for next AAA
	        ST  R9,SGNAAP,RUBLK	: make the next current
		ST  R10,SGNCMP,RUBLK	: current command pointer
		CALL(SGNCMH,SGNPSV)	: send command
	      ENDIF			: no more AAA's
	    ENDIF			:
	  ORELSE			: bad response
	    LHI	R7,SGNNRB		: sign_again_type = bad response
	    CALL(SGNAGN,SGNPSV)		: start the sign process again
	  ENDIF				: good or bad response

	RETURN(R7)

:(mats.p2)SGNCMH.S01
:       created by Margalit	1/27/87
: This routine sends a configured command string to the host during
: sign_in or sign_off process. It sets up all the parameters needed
: for SNDMAG rotuine, checks the corresponding action type and call
: SNDMAG. After the command is sent, it saves the time, updates command
: pointer to next entry of command table.
:
:
: Input  - RUBLK : pointer to current block(AUB or free block)
:          R8 : pointer to MAGTAB entry
:
: Output - 
:          SGNCMT[block_ptr] save the time last command sent
:          SGNCMP[block_ptr] point to next entry of command table
:          SGNRPT[block_ptr] point to response strings for this cmd
:          SGNSTA[block_ptr] is set to wait_response
:


	SEG 	0

: CMDACT is a jump table used to jump to the appropriate routine which
: takes action according to the command_action_code configured in the
: SGNCMD macroe.


	ALWDAR(CMDACT,$A1)
	  FLWDAR(CMDAPP,APNDPJ)
	ENDWAF


	PROCS(SGNCMH,$0 0D)
	CHAINS(SGNCSV,$0 0D)
	
	
	L	R9,SGNRIT,RUBLK		: RES-IA-TA
	OI	R9,$0 080		: set the highest bit on
	STB	R9,CMDTA		: TA
	SRLS	R9,8			: IA is now in least significant byte
	OI	R9,$0 080		: set the highest bit on
	STB	R9,CMDIA		: IA
	L	R10,SGNCMP,RUBLK	: pointer to current command table
        L       R10,0,R10               : ptr to current command string
	LB	R3,0,R10		: command length
	LA	R2,1,R10		: command address
	AR	R10,R3
	AIS	R10,2			: response pointer
	ST	R10,SGNRPT,RUBLK	: current response pointer
	SIS	R10,1			: pointer to command action code
	LB	R9,0,R10		: command action code
        CHI     R9,NOACTC               : is it command no action ? default=FF
	IFF(N,THEN)			: if an action should be taken
	  SLHLS  R9,2			: adress index 
	  L      R9,CMDACT,R9,		: routine address
	  JALR   R15,R9			: jump to action rtn
	ENDIF
	
	LR	R13,R8			: MAGTAB pointer
	CALL(SNDMAG,SGNCSV)		: send the command
	
	L	R9,FASTC,,
	ST	R9,SGNCMT,RUBLK		: time when command was sent
	
	L	R9,SGNCMP,RUBLK		: current command pointer
	AIS	R9,4			: next command
	ST	R9,SGNCMP,RUBLK		: make next--> current

	RETURN(R9)

	
: Subroutines which handle commands actions


APNDPJ	NOP
	JR	R15

:(MATS.P2)SGNRSH.S01
:       Created by Margalit	1/29/87
: This routine checks the response received from the host against
: all possible configured response strings. It compares the configured
: string with the received one up to the length of the configured string.
: Namely, it is considered to be a good response if the first # of chars
: match the configured one. If a good response received, it will check the 
: corresponding action type and process the action.
:
: Input  -
:         R8 : pointer to MAGTAB entry
:         RUBLK: pointer to AUB or free block
:         R2 : pointer the response from the host
:
: Output - 
:         R0 : a flag to indicate if the response is good or not
:



: RSPACT is a jump table used to jump to the appropriate routine
: which should take action after the response has arrived.

	SEG	0

	ALWDAR(RSPACT,1)
	  FLWDAR(RSPDNE,DONRSP)
	ENDWAF




	PROCS(SGNRSH,$0 0D)
	CHAINS(SGNRSV,$0 0D)

	L	R9,SGNRPT,RUBLK		: current pointer to response
	LB	R10,0,R9		: length of configured response
	DO(WHILE,G)			: loop on all configured responses
	  LA	R7,1,R9			: address of configured response
	  CALL(CMPRSP,SGNRSV)		: compare configured and received resp
	  LR	R0,R0			: 1 - match, 0 - no match
	  IFF(N,THEN)			: if there is a match
	    AR	R9,R10	
	    LB	R11,1,R9		: action code
            CHI R11,NOACTR              : is it response no action ? default=FF
	    IFF(N,THEN)			: if action should be taken
	      SLHLS  R11,2		: word index
	      L	     R11,RSPACT,R11,	: action routine address
	      JALR   R15,R11		: jump to the routine
	    ENDIF			: action should be taken
	    EXITDO			: a match was found
	  ENDIF				: there is a match
	  
	  AR	R9,R10
	  AIS	R9,2			: pointer to next response
	  LB	R10,0,R9		: length of next configured rsp
	ENDDO				: do for all configured responses

	RETURN(R7)






:(mats.P2)CMPRSP.S01
:       created by Margalit	1/29/87
: This routine compares 2 strings char by char up to input 'length'.
: Two strings to be compared need not be the same size. If the
: first 'length' chars are matched, it is considered as a good match.
:
: Input  -
:        R7 : pointer to string 1 to be compared(NAD SC format string,
:                       the highest bit is always on)
:        R2 : pointer to string 2 to be compared
:        R10   : # of bytes to be compared
: output -
:        R0 : a flag to indicate 2 strings are matched or not
:



	PROCS(CMPRSP,$0 0D)
	CHAINS(CMPRSV,$0 0D)

	LIS	R0,1		: set match_flag to TRUE
	LR	R10,R10		: do for all characters
	DO(WHILE,G)		: if characters left
	  LB	R9,0,R7		: get a configured char
	  CLHI	R9,WILDCH	: wild character
	  IFF(N,THEN)		: if not a wild character
	    LB	R11,0,R2	: get a received character
	    OHI	R11,$0 80	: set highest bit on
	    CR	R9,R11		: compare configured with received
	    IFF(N,THEN)		: if they dont match
	      SR  R0,R0		: set matc_flag to false
	      EXITDO		: no point in continuing
	    ENDIF		: dont match
	  ENDIF			: not a wild char
	  AIS	R7,1		: next configured char
	  AIS	R2,1		: next received char
	  SIS	R10,1		: one less char
	ENDDO			: characters left

	RETURN(R2)






: action routines to handle response actions

DONRSP	LCS	R12,1		: -1
	ST	R12,SGNCMP,RUBLK : done for current AAA
	JR	R15

:(MATS.P2)SGNAGN.S01
:
:       Created by Margalit	1/29/87
: SiGN_AGaiN
:       common routine to restart a sign_in or sign_off process. It is
: called from 3 places:
:   1. SGNPRO - if a response from host is bad
:   2. sign_in timeout - if timeout for a sign_in response expired
:   3. sign_off timeout - if timeout for a sign_off response expired.
: in any case, this routine will check if total number of 
: retries exceeds max_retry allowed. If retry does not exceed max_retry
: it updates corresponding retry counter and sets up fields in the 
: block(free block or AUB) for SGNCMH to send the first command.
:
: Input  - 
:        RUBLK : pointer to AUB or free block
:        R7 : either SGNNRB(bad rsp) or SGNNRT(timeout)
:        R8 : pointer to MAGTAB entry
: Output -
:        one of the counter: SINBAD, SOFBAD, SINTMO, SOFTMO, SGNNRB[block_ptr]
:                            SGNNRT[block_ptr] is incremented or
:                            HNGFRE is set to 0AA to set an indicator on
:                            monitor if retries > max_retry
:


	GL	HNGFRE



	PROCS(SGNAGN,$0 0D)
	CHAINS(SGNASV,$0 0D)

	LIS	R13,1
	LB	R12,SGNTYP,RUBLK	: sign type(signin or signoff)
	LH	R9,SGNNRB,RUBLK		: # of bad rsponses
	AH	R9,SGNNRT,RUBLK	        : # of no responses
	CH	R9,SGNLMT,RUBLK		: max # of retries
	IFF(L,THEN)			: if has'nt reached the max
	  L	R11,SGNRIT,RUBLK	: RES-IA-TA
	  SRL 	R11,$0 10               : get the RES #
	  LHL	R11,RESAOF,R11,R11	: offset into RESAAA table
	  CHI	R12,SIGNIN		: signin
	  IFF(E,THEN)			: if signin
	    L	R9,RESAAA+SINPTR,R11,	: AAA pointer
	    CHI	R7,SGNNRB		
	    IFF(E,THEN)			: if bad response is the reason
	      AHM  R13,SINBAD,,		: count bad responses
	    ORELSE			: if no response is the reason
	      AHM  R13,SINTMO,,		: count no response(timeout)
	    ENDIF
	  ORELSE			: signoff
	    L	R9,RESAAA+SOFPTR,R11,	: AAA pointer
	    CHI R7,SGNNRB
	    IFF(E,THEN)			: if bad response
	      AHM  R13,SOFBAD,,		: count signoff bad rsps
	    ORELSE			: no response
	      AHM  R13,SOFTMO,,		: count signoff no response
	    ENDIF
	  ENDIF				: signin or signoff
	  
	  AHM	R13,0,RUBLK,R7		: add one to either SGNNRB/SGNNRT
	  ST	R9,SGNAAP,RUBLK		: current AAA pointer
          L     R9,0,R9                 : get cmd table ptr for this aaa
          ST    R9,SGNCMP,RUBLK         : put it in the cmd ptr field
	  CALL(SGNCMH,SGNASV)		: to send first command with
                                        : R1(RUBLK) = block_ptr
                                        : R8 = ptr to MAGTAB
	  
	ORELSE				: retry >= max
	
	  CHI	R12,SIGNIN		: 
	  IFF(E,THEN)			: if signin
	    CALL(SGNFAL,SGNASV)		: sigin failed
	  ORELSE			: signoff
	    LHI	R9,$0 0AA
	    STB R9,HNGFRE,,		: indicate frozen addresses
	  ENDIF
	  
	ENDIF

	RETURN(R9)

:(MATS.P2)SOFDON.S01
:       
:       Extracted by chen from CONFRE on 1/16/86
: This routine is called when sign_off process complete. It sets the
: flag in MAGFRE to 'FREE', remove free block from active free block chain,
: delete the corresponding entry in R2UTAB. It also checks the current 
: free mode, if it is startup free process, then sets up parameters for
: POOLIA routine to continue freeing another address in pools belonging
: to current RES.
:
: Input  -
:        RUBLK(R1) : contains pointer to free block
:        R8 : pointer to MAGTAB
:        note : put all sign_in(off) related routines in SEG D as it was 
: 
        PROCS(SOFDON,$0 0D)
        CHAINS(SOFSAV,$0 0D)

        L       R3,FREITA,RUBLK :RESIATA WE ARE WORKING ON
        LR      R10,RUBLK       :SAVE FREBLK POINTER
        LR      RUBLK,R8        :RUBLK NOW IS MAGTAB POINTER
        LR      R4,R3
        CALL(PEEKFR,SOFSAV)
        RBT     R2,MAGFRE,RUBLK : RESET BIT TO SHOW IA_TA FREE
        LB      R7,FREMOD,R10   : SAVE TYPE OF FREE
        LR      R2,R10          :POINT R2 AT FREBLK TO RELEASE
        CALL(RELFRE,SOFSAV)
        CALL(BINSCH,SOFSAV)
        LR      R0,R0
        JEFS    DODEL
        JAL     R10,CRASH,,
        BC      0,0,4*RLINK,CRR2U
DODEL   CALL(R2UDEL,SOFSAV)
                                :CHECK FOR POOL FREE OR USER RELEASE...
        CLHI    R7,IATPOL       :ARE WE IN INITIALIZATION
        JN      SOFRET          :PURE VANILLA RELEASE
                                :SET UP FOR CALL TO POOLIA
                                :***make sure parameters set up right for
                                :   POOLIA !!!***
        LIS     R4,1            :FREE ONE IATA
        LH      R3,MAGNUM,RUBLK :LOAD RES NUMBER
        LH      R6,RESAOF,R3,R3 :get offset to RESAAA table
        L       R9,RESAAA+SOFPTR,R6,  :get pointer to sign_off AAA table
        CALL(POOLIA,SOFSAV)     :with R3 = RES_#
                                :     R4 = # of res_ia_TA to be freed
                                :     R1(RUBLK) = MAGTAB_ptr
                                :     R9 = pointer to auto_sign_off table
SOFRET  RETURN(R2)

:(MATS.P2)SGNFAL.S01
:       Created by chen on 1/22/87
: Sign_IN FAiL -
: Routine to release resources when a sign_in failed. This routine will
: release  resources depends on different conditions:
:  1. Single RES access user - release AUB, RB, zap the circuit
:  2. Multi RES access user - release
:           current sign_in res block only
: Input  - 
:        R1(RUBLK) - block_ptr : pointer to AUB
:
        PROCS(SGNFAL,$0 0D)
        CHAINS(SGNFSV,$0 0D)

        LI      R3,DISINF       :disconnect reason = sign_in fail
        LHI     R2,LUDNUR       :set aub type to normal user for zapprt
        STB     R2,AUBTYP,RUBLK : aub type is now SIGNIN
        LH      R2,AUBSER,RUBLK    :single res user NE 0
        IFF(N,THEN)             :yes, single res access user
          LA    R2,SINFSR,,     :send 'Sign_in failed ' msg to single res user
          CALL(ZAPPRT,SGNFSV)   : and zap the port
        ORELSE                  :multi res access user
          L     R2,AUBARB,RUBLK    :should have one
          IFF(G,THEN)           :got the active res block
            CALL(RELRB,SGNFSV)    :to release this res block
          ORELSE                :increment error counter
            LIS R2,1
            AHM R2,NOARBI       :no active res block when sign_in failed
          ENDIF
          LA    R2,SINFMR,,     :send 'Sign_in failed, try another RES'
          CALL(SENDIT,SGNFSV)   : to multi res access user
          CALL(GETRES,SGNFSV)   :to send msg to user, ask for another res
        ENDIF
        RETURN(R1)


          

                    :This file contain three timeout routines all related to the
:Auto Signin/off process.

:(MATS.P2)SGOTMO
:	Created by chen on 1/23/87

:	SigNOff_TiMe_Out loops on all the free blocks. For each block
:	it checks to see if Time_to_wait_for_response has passed. If
:	time expired then SGNAGN is called to decide whether the signoff
:	should be restarted.

:INPUT 	FREACT - start of free block chain
:	FRETIM[block-ptr] - time when last command was sent
:	SGOTIM - time to wait for response
:	SGOINT - the timeout value on which basis this routine runs

	IF	FB.AAA

        SEG     0
SGOTSV  WS      $A 18           :18 FWs storage area
        SEG     $0 0D           :code in seg 13

SGOTMO  L       R1,FREACT       :get active free block chain
        IFF(G,THEN)             :GT 0, free block(s) on active list
          DO(WHILE,G)           :loop for all active free blocks
            L   R8,FASTC,,      :get current fastc
            S   R8,FRETIM,R1    :fastc - last command sent time
            CI  R8,SGOTIM       :timeout expired ?
            IFF(G,THEN)         : yes, no response, try again
              LH   R8,FRERES,R1    :get res number
              CVTRES(R8,SGOTSV)    :convert to entry number in MAGTAB
              LHI  R2,MAGLNG       :get entry length in MAGTAB
              MHR  R8,R2           :get offset to MAGTAB
              LA   R8,MAGTAB,R8,   :get pointer to magtab
              LHI  R7,SGNNRT       :sign_again type = timeout(no response)
              CALL(SGNAGN,SGOTSV)  :with R1 = ptr to free block
                                   :     R7 = sign_again_type
                                   :     R8 = mag_ptr
            ENDIF                  :timeout expired
            L   R1,FRENXT,R1       :get next free block in active list
          ENDDO
        ORELSE                  :no free block on active list
          LHI   R2,$00A0        :clear indicator on monitor
          STB   R2,HNGFRE,,
        ENDIF
        L       R1,FASTC,,      :put it back to timeout list
        AI      R1,SGOINT       :run again time in R1
        LA      R0,SGOTMO       :routine address in R0               
        JAL     R5,TOPUT,,      :to put it on the list
        J       TORET,,         :return to timeout.lib


	EI			: FB.AAA
              
        






:(MATS.P2)SGITMO.S01
:	Created by chen on 1/23/87

:	SiGnIn_TiMe_Out runs periodically to check upon arrival of
:	responses to the signin commands. It loops on all AUBs and
:	checks if the user is in sigin process. for all these
:	users the time_to_wait_for_response is checked, and if 
:	expired SGNAGN is called to handle the situation.

:INPUT	AUTACT - start of AUB chain
:	AUBSTM[block-ptr] - time last command was sent
:	SGITIM - time to wait for response
:	SGIINT - time to schedule this routine to run again

	IF	UB.AAA

        SEG     0
SGITSV  WS      $A 18           :18 FWs storage area
        SEG     $0 0D           :code in seg 13

SGITMO    L       R1,AUTACT       :get active AUB chain
          DO(WHILE,G)           :loop for all active AUB blocks
           LB   R8,AUBTYP,R1    :is still in sign_in state ?
           CLHI R8,SIGNIN
           IFF(E,THEN)          :yes, check if response timeout expired
            L   R8,FASTC,,      :get current fastc
            S   R8,AUBSTM,R1    :fastc - last command sent time
            CI  R8,SGITIM       :timeout expired ?
            IFF(G,THEN)         : yes, no response, try again
              L    R8,AUBRIT,R1    :get RES_IA_TA
              SRL  R8,$0 10        :shift out ia_ta, get res number
              CVTRES(R8,SGITSV)    :convert to entry number in MAGTAB
              LHI  R2,MAGLNG       :get entry length in MAGTAB
              MHR  R8,R2           :get offset to MAGTAB
              LA   R8,MAGTAB,R8,   :get pointer to magtab
              LHI  R7,SGNNRT       :sign_again type = timeout(no response)
              CALL(SGNAGN,SGITSV)  :with R1 = ptr to AUB
                                   :     R7 = sign_again_type
                                   :     R8 = mag_ptr
            ENDIF                  :timeout expired
           ENDIF                   :signin state check
           L   R1,AUBNXT,R1       :get next AUb block in active list
          ENDDO
          L       R1,FASTC,,      :put it back to timeout list
          AI      R1,SGIINT       :run again time in R1
          LA      R0,SGITMO       :routine address in R0               
          JAL     R5,TOPUT,,      :to put it on the list
          J       TORET,,         :return to timeout.lib
  

	EI			: UB.AAA





:(MATS.P2)SGIOKP
:	Created by chen on 1/23/87

:	SiGnOff_House_KeePer is a timeout routine which runs periodically
:	and restarts the free process for all frozen addresses which meet
:	the following two requirements:
:	  1. The time interval between last retry and now is bigger then
:	     the configured House_Keeping timeout.
:	  2. The number of retries to free this frozen address has not been
:	     exhasted.

:INPUT	FREACT - start of free block chain
:	FRENRB[block_ptr] - # of times a bad response was received
:	FRENRT[block_ptr] - # of times no response was received
:	FRELMT[block_ptr] - max number of retries after which the address
:				is frozen.
:	FREHKP[block_ptr] - # of retries left to restart the auto logoff
:				for a frozen address.
:	HKPTIM - configured House_Keeping timeout.
:	HKPINT - time interval to reschedule this routine again.
:	HKPRTR - how many times to retry if the process failes

	IF	FB.AAA


        SEG     $0 0D           :code in seg 13

SGOHKP  L       R1,FREACT       :get active free block chain
        DO(WHILE,G)           :loop for all active free blocks
          LH  R8,FRENRB,R1    :# of retries because of bad response
          AH  R8,FRENRT,R1    :+ #of retries because of no response = total 
          CLH R8,FRELMT,R1      :total # of retries >= max allowed ?
          IFF(GE,THEN)          : yes, address was frozen before
            L   R8,FASTC,,      :get current fastc
            S   R8,FRETIM,R1    :fastc - last command sent time
            CI  R8,HKPTIM       :timeout expired ?
            IFF(G,THEN)         : yes, time to restart free for a frozen addr.
              LB   R8,FREHKP,R1    :get # of times left to restart a frozen add
              IFF(G,THEN)          :we should try again
                LHI R2,HKPRTR      :# of retries for this round
                AHM R2,FRELMT,R1  
                SIS R8,1           :decrement # of rounds left
                STB R8,FREHKP,R1
              ENDIF
            ENDIF                  :timeout expired
          ENDIF
          L   R1,FRENXT,R1       :get next free block in active list
        ENDDO
        L       R1,FASTC,,      :put it back to timeout list
        AI      R1,HKPINT       :run again time in R1
        LA      R0,SGOHKP       :routine address in R0               
        JAL     R5,TOPUT,,      :to put it on the list
        J       TORET,,         :return to timeout.lib

	EI			: FB.AAA


:(TIGERDEV)VIDPGM.S02
:	Copied by Margalit from .01C	12/11/85
:	Added a routine(HDSC78) to handle cur pos for PCI-78

:(TIGERDEV)VIDPGM.01C
:       Copied by Chen from (TEST.INA)VIDPGM.01C on 6/14/85
:       Made a new directory for Flying Tiger project.
:
:(TEST.INA)VIDPGM.01C
:       Copied by chen from (MATS.P2)VIDPGM.09R on 5/30/85
:       Added two routines(both are called by MAG1TX) for Fying Tiger
:       (1). HDSCPO: put the cursor position chars in OUTBUF
:       (2). HDERAS: put erase sequence chars in OUTBUF
:       (3). VBPOCH: routine to get translation position char. Directly 
:                    get the terminal's TIB address from AUB instead of 
:                    calling VBTPTB in VBGTPS.
:       (1). & (2). routines are only called by hardcopy with C1,C2 chars
:       supported terminals
:       Another routine PUTSC1 is called to put the SC
::      string in OUTBUF.
:

        RA      $00
        MO      .+3&-4,VIDPGM
        LO      MAIN
:
:       ROUTINE TO GET AN ESCAPE SEQUENCE FROM THE TIB
:       FOR IMMEDIATE VIDEO ROUTINES.
:       
:       R10 - AUB ADDRESS FOR USER TO GET ESCAPE SEQ.
:       R11 - OFFSET OF ESCAPE SEQUENCE IN TIB
:
:       R0 - CONTAINS ESCAPE SEQUENCE ON RETURN
:           -2  BAD OFFSET INTO TIB
:           -1  NO TIB FOR THIS USERS TERMINAL
:            0  NO CHARACTER FOR THIS OPERATION
:
        PROCS(VIGTEC,$0 0D)
        CHAINS(VIGTSV,$0 0D)
:
        DEBUGM(ENTERING VIGTEC,DBGANC,DALL,VIGTSV,$00D)
        LR      R11,R11         :SET CONDITION CODE
        JLE     VINOOP          :OFFSET IS ZERO OR NEGATIVE
        LHI     R2,TIBNUM       :LOAD STARTING OFFSET OF ADDRESSING CHAR
        CLR     R11,R2          :COMPARE TO INPUT ARGUMENT
        JGE     VIBDAG          :IF GREATER THEN NOOP
        JAL     RLINK,VITPTB    :put my TIB pointer in R12
        LR      R12,R12         :SET CONDITION CODE
        JLE     VIBDTM          :jump if no TIB for this terminal
        LB      R0,,R12,R11     :R0 IS NOW THE CONTROL CHARACTER BYTE
        JE      VINOOP          :IF EQUAL TO ZERO THEN NOOP
        SLLS    R0,8            :SHIFT ONE BYTE TO LEAVE ROOM FOR ESCAPE
        LB      R1,0,R12,       :R1 IS ESCAPE CHARACTER
        OR      R0,R1           :R0 IS CONTROL CHAR, ESCAPE CHAR
        J       VIGRET          :JUMP TO RETURN
VIBDAG  LCS     R0,2            :LOAD ERROR INDICATION IN R0
        J       VIGRET          :JUMP TO RETURN 
VIBDTM  LCS     R0,1            :PLACE ERROR INDICATION IN R0
        J       VIGRET          :JUMP TO RETURN
VINOOP  SR      R0,R0           :ZERO R0
VIGRET  RETURN(R1)
:
:       Get the TIB pointer for a user block
:
:       The TIB pointer is now stored in the AUBTIB field
:       so this routine merely picks it up and returns it.
:       Eventually the calling routines will fetch the TIB
:       pointer themselves and this routine will disappear.
:
:       Linkage - just JAL RLINK,VITPTB
:
:       expects - AUB address in R10
:       returns - TIB address from the AUB in R12
:                 (might be -1 if no TIB for this terminal type)
:
VITPTB  L       R12,AUBTIB,R10  :pick up this user's TIB pointer
        JR      RLINK           :and return
:
:
:       ROUTINE TO LOCK THE KEYBOARD OF VIDEO TERMINALS
:
:       R10 - AUB ADDRESS OF USER TO LOCK UP
:       R1 - BUFFER INDEX, ASSUMED TO BE CALCULATED BY CALLER
:
        PROCS(VILKKB,$0 0D)
        CHAINS(VILSAV,$0 0D)
        DEBUGM(entering VILKKB,DBGANC,DALL,VILSAV,$00D)
:
        LHI     R11,TIBLOC      :LOAD OFFSET OF LOCK KEYBOARD CHARACTER
        CALL(VIGTEC,VILSAV)
        LR      R0,R0           :DID WE GET ANYTHING TO SEND??
        JLE     VILKRT          :IF NO CHARACTERS THEN GO TO RETURN
        JAL     R4,WCI,,        : SEND FIRST CHARACTER (ESCAPE)
        SRLS    R0,8            :SHIFT OFF 8 BITS
        JAL     R4,WCI,,        :SEND LOCK CHARACTER
VILKRT  RETURN(R0)
:
:       ROUTINE TO UNLOCK THE KEYBOARD OF VIDEO TERMINALS
:
:       R10 - AUB ADDRESS OF USER TO UNLOCK
:       R1 - BUFFER INDEX, ASSUMED TO BE CALCULATED BY CALLER
:
        PROCS(VIULKB,$0 0D)
        CHAINS(VIULSV,$0 0D)
        DEBUGM(entering VIULKB,DBGANC,DALL,VIULSV,$00D)
:
        LHI     R11,TIBUNL      :LOAD OFFSET OF UNLOCK CHARACTER
        CALL(VIGTEC,VIULSV)
        LR      R0,R0           :DID WE GET A CHARACTER TO SEND?
        JLE     VIULRT          :IF NO CHARACTERS THEN RETURN
        JAL     R4,WCI,,        :SEND ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE CHARACTER
        JAL     R4,WCI,,        :SEND UNLOCK CHARACTER
VIULRT  RETURN(R11)
:
:       ROUTINE TO SEND A SOM TO THE TERMINAL
:       FOR 440W TERMINALS AND A '>' FOR OTHER VIDEO TERMINALS
:
:       R10 - AUB ADDRESS OF USER TO GET A SOM
:       R1 - BUFFER INDEX, ASSUMED TO BE CALCULATED BY CALLER
:
        PROCS(VISNSM,$0 0D)
        CHAINS(VISNSV,$0 0D)
        DEBUGM(entering VISNSM,DBGANC,DALL,VISNSV,$00D)
        LH      R11,AUBLIN,R10, :LOAD LINE ADDRESS
        CLHI    R11,$A20         :COMPARE TO 20TH LINE
        JLE     VBNOWP          :IF LESS NO PROB
        LHI     R8,5            :LINE 5
        LHI     R9,1            :COL 1
        CALL(VIPOSC,VISNSV)
VBNOWP  LHI     R0,AUB470       :LOAD 470 TYPE
        CLB     R0,AUBTTY,R10,  :COMPARE TO USERS TYPE
        JE      VINT44
        LHI     R11,TIBSOM      :LOAD OFFSET OF SOM CHARACTER
        CALL(VIGTEC,VISNSV)
        LR      R0,R0           :DID WE GET ANYTHING?
        JLE     VISNRT          :no, send nothing
        JAL     R4,WCI,,        :SEND ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE 
        JAL     R4,WCI,,        :send SOM to a 440
        J       VISNRT          :DONE   RETURN
:
:
:       MUST SET BUFFER ADDRESSS TO CURSOR ADDRESS
:       send > to a 470
:
VINT44  LHI     R11,TIBSBA      :GET SPA CHARACTER
        CALL(VIGTEC,VISNSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND SBA
        LR      R6,R10          :SET UP FOR VB CALL
        LH      R5,AUBLIN,R10,  :LOAD LINE ADDRESS OF CURSOR
        CALL(VBGTPS,VISNSV)
        LR      R0,R5           :LOAD POSITION BYTE
        JAL     R4,WCI,,         :SEND IT
        LH      R5,AUBCOL,R10,  :LOAD COLUMN ADDRESS
        CALL(VBGTPS,VISNSV)
        LR      R0,R5           :LOAD POSITION BYTE
        JAL     R4,WCI,,        :SEND IT
        LHI     R11,TIBRPA      :LOAD REPEAT  TO ADDRESS CHAR
        CALL(VIGTEC,VISNSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,          :SEND RPA
        LH      R5,AUBLIN,R10   :LOAD LINE ADDRESS OF CURSOR
        AIS     R5,4            :ADD 5 
        CALL(VBGTPS,VISNSV)
        LR      R0,R5           :MOVE TO R0
        JAL     R4,WCI,,        :SEND LINE POSITION
        LHI     R5,$A 80            :LOAD A $A 80
        CALL(VBGTPS,VISNSV)
        LR      R0,R5           :LOAD R0
        JAL     R4,WCI,,        :SEND POSITION CHAR
        LHI     R0,$0 080       :CLEAR TO NULLS
        JAL     R4,WCI,,        :SEND IT
:       CALL(VIWAIT,VISNSV)
        LHI     R11,TIBPRT      :LOAD PROTECTED FIELD OFFSET
        CALL(VIGTAT,VISNSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND NEXT CHAR
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND LAST
:
:       NOW MOVE CURSOR BACK TO WHERE WE GOT IT
:
        LHI     R11,TIBPSX      :POSITIONX CHARACTER
        CALL(VIGTEC,VISNSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND POSX CHAR
        LH      R5,AUBLIN,R10,  :LOAD LINE POSITION
        CALL(VBGTPS,VISNSV)
        LR      R0,R5
        JAL     R4,WCI,,        :SEND LINE POSITION
        LHI     R11,TIBPSY      :LOAD Y POSITIOONIING
        CALL(VIGTEC,VISNSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND Y
        LH      R5,AUBCOL,R10,  :LOAD COLUMN ADDRESS
        CALL(VBGTPS,VISNSV)
        LR      R0,R5           :MOVE CHAR
        JAL     R4,WCI,,        :SEND IT
:
:       PROMPT AND ATTRIBUTE CHAR
:
        LHI     R0,$03E         :LOAD A >
        JAL     R4,WCI,,        :SEND IT
        LHI     R11,TIBNOR      :LOAD NORMAL FIELD ATTR CHAR
        CALL(VIGTAT,VISNSV)
        JAL     R4,WCI,,        :SEND ESCAPRR
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND NEXT CHAR
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND LAST CHAR
:
:       NOW RESET MDTS
:
        LHI     R11,TIBMDT      :LOAD MDT OFFSET
        CALL(VIGTEC,VISNSV)
        JAL     R4,WCI,,        :SEND ESCPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND RESET MDT
:       CALL(VIWAIT,VISNSV)
:
:       CURSOR NOW TWO CHARS OVER SAME LINE
:
        LH      R0,AUBCOL,R10,  :LOAD COLUMN
        AIS     R0,2            :INCREMENT BY 2
        STH     R0,AUBCOL,R10,  :SAVE IT
        STH     R0,AUBPCL,R10,  :SET PROMPT ADDRESS
        LH      R0,AUBLIN,R10,  :GET LINE
        STH     R0,AUBPLN,R10,  :SAVE PROMPT LINE
VISNRT  RETURN(R0)
:
:       ROUTINE TO SEND AN EOM TO THE 440W TERMINAL.  THIS IS KNOWN
:       TO BE A NOOP FOR OTHER TYPES OF VIDEO TERMINALS.
:       
:       R10 - AUB ADDRESS OF USER TO GET AN EOM
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VISNEM,$0 0D)
        CHAINS(VIEMSV,$0 0D)
        DEBUGM(entering VISNEM,DBGANC,DALL,VIEMSV,$00D)
        LHI     R11,TIBEOM      :LOAD THE EOM CHARACTER
        CALL(VIGTEC,VIEMSV)
        LR      R0,R0           :CHECK FOR ANYTHING TO SEND
        JLE     VIEMRT          :IF NO RETURN
        JAL     R4,WCI,,        :SEND THE ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF THE ESCAPE
        JAL     R4,WCI,,        :SEND THE EOM
VIEMRT  RETURN(R0)
:
:       ROUTINE TO PLACE VIDEO TERMINAL IN CONVERSATIONAL MODE
:
:       R10 - POINTER TO AUB OF USER TO PUT IN CONV MODE
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VICNVM,$0 0D)
        CHAINS(VICNSV,$0 0D)
        DEBUGM(entering VICNVM,DBGANC,DALL,VICNSV,$00D)
        LHI     R11,TIBCNV      :LOAD OFFSET OF CONVERSATIONAL CHARACTER
        CALL(VIGTEC,VICNSV)
        LR      R0,R0           :CHECK FOR A CHARACTER TO SENT
        JLE     VICNRT          :IF NOT GO TO RETURN
        JAL     R4,WCI,,        :SEND ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE CHARACTER
        JAL     R4,WCI,,        :SEND CONVERSATIONAL CHARACTER
VICNRT  RETURN(R0)
:
:       ROUTINE TO PLACE A VIDEO TERMINAL IN BLOCK MODE
:
:       R10 - POINTS TO USERS AUB
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VIBLKM,$0 0D)
        CHAINS(VIBLSV,$0 0D)
        DEBUGM(entering VIBLKM,DBGANC,DALL,VIBLSV,$00D)
        LHI     R11,TIBBLK      :LOAD BLOCK MODE CHARACTER OFFSET
        CALL(VIGTEC,VIBLSV)
        LR      R0,R0           :SET CONDITION CODES
        JLE     VIBLRT          :JUMP IF NO CHARS TO SENT
        JAL     R4,WCI,,        :SEND ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE CHARACTER
        JAL     R4,WCI,,        :SEND BLOCK MODE CHARACTER
VIBLRT  RETURN(R0)
:
:       ROUTINE TO SEND ERASE LINE SEQUENCE TO THE VIDEO TERMINAL
:
:       R10 - POINTS TO THE USERS AUB
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VIERLN,$0 0D)
        CHAINS(VIERSV,$0 0D)
        DEBUGM(entering VIERLN,DBGANC,DALL,VIERSV,$00D)
        LHI     R12,AUB470      :LAAD 470 CODE
        CLB     R12,AUBTTY,R10, :COMPARE TO USERS TYPE
        JE      VILE47
        LHI     R11,TIBERL      :LOAD ERASE LINE CHARACTER
        CALL(VIGTEC,VIERSV)
        LR      R0,R0           :SET CONDITION CODE
        JLE     VERLRT          :IF NO CHARACTER, RETURN
        JAL     R4,WCI,,        :SEND THE ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE CHARACTER
        JAL     R4,WCI,,        :SEND ERASE LINE CHAR
        J       VERLRT
VILE47  LHI     R11,TIBSBA      :LOAD SPA BYTE
        CALL(VIGTEC,VIERSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND SBA CHARACTER
        LR      R6,R10          :LOAD R6 FOR VB CALLS
        LH      R5,AUBLIN,R10,  :LOAD LINE ADDRESS
        CALL(VBGTPS,VIERSV)
        LR      R0,R5           :LOAD R0
        JAL     R4,WCI,,        :SEND IT
        LH      R5,AUBCOL,R10,  :LOAD COLUMN ADDRESS
        CALL(VBGTPS,VIERSV)
        LR      R0,R5           :LOAD IT
        JAL     R4,WCI,,        :SEND IT
        LHI     R11,TIBRPA      :LOAD REPEAT TO ADDRESS
        CALL(VIGTEC,VIERSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,
        LH      R5,AUBLIN,R10,  :LOAD LINE NUMBER
        LR      R6,R10          :LOAD RUBLK FOR VB CALL
        CALL(VBGTPS,VIERSV)
        LR      R0,R5           :MOVE CHAR TO R0
        JAL     R4,WCI,,
        LHI     R5,$A80         :COLUMN 80
        CALL(VBGTPS,VIERSV)
        LR      R0,R5           :MOVE TO R0
        JAL     R4,WCI,,        :SEND IT
        LHI     R0,$080         :LOAD A NULL
        JAL     R4,WCI,,
:       CALL(VIWAIT,VIERSV)
:
:       NOW RETURN CURSOR TO ORIG POSITTION
:
        LHI     R11,TIBPSY      :NEED TO SET COLUMN ONLY
        CALL(VIGTEC,VIERSV)
        JAL     R4,WCI,,
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND MOVE Y CHAR
        LH      R5,AUBCOL,R10,  :GET COLUMN POSITION
        CALL(VBGTPS,VIERSV)
        LR      R0,R5           :MOVE CHAR TO REG 0
        JAL     R4,WCI,,        :SEND IT
VERLRT  RETURN(R0)
:
:       ROUTINE TO CLEAR SCREEN TO UNPROTECTED NULLS
:
:       R10 - POINTS TO USERS AUB 
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VICLAL,$0 0D)
        CHAINS(VICLSV,$0 0D)
        DEBUGM(entering VICLAL,DBGANC,DALL,VICLSV,$00D)
        LHI     R11,TIBCSN      :LOAD CLEAR CHARACTER OFFSET
        CALL(VIGTEC,VICLSV)
        LR      R0,R0           :SET CONDITION CODE
        JLE     VICLRT          :JUMP IF NO CHARS TO SEND
        JAL     R4,WCI,,        :SEND THE ESCAPE CHAR
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND CLEAR CHARACTER
VICLRT  RETURN(R0)
:
:       ROUTINE TO CLEAR UNPROTECTED CHARACTERS FROM CURSOR
:
:       R10 - POINTS TO AUB OF USER TO CLEAR
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VIERUP,$0 0D)
        CHAINS(VICCSV,$0 0D)
        DEBUGM(entering VIERUP,DBGANC,DALL,VICCSV,$00D)
        LHI     R12,AUB470      :LOAD 470 TERMINAL TYPE
        CLB     R12,AUBTTY,R10, :COMPARE TO USERS TYPE
        JE      VIER47          :JUMP IF 47-
        LHI     R11,TIBERS      :LOAD OFFSET OF CLEAR UNPRO CHAR
        CALL(VIGTEC,VICCSV)
        LR      R0,R0           :SET CONDITION CODE
        JLE     VIERRT          :JUMP TO RETURN
        JAL     R4,WCI,,        :SEND THE ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF THE ESCAPE
        JAL     R4,WCI,,        :SEND ERASE UNPROTECTED CHARACTER
        J       VIERRT
VIER47  LHI     R11,TIBSBA      :LOAD SPA BYTE
        CALL(VIGTEC,VICCSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND SBA CHARACTER
        LR      R6,R10          :LOAD R6 FOR VB CALLS
        LH      R5,AUBLIN,R10,  :LOAD LINE ADDRESS
        CALL(VBGTPS,VICCSV)
        LR      R0,R5           :LOAD R0
        JAL     R4,WCI,,        :SEND IT
        LH      R5,AUBCOL,R10,  :LOAD COLUMN ADDRESS
        CALL(VBGTPS,VICCSV)
        LR      R0,R5           :LOAD IT
        JAL     R4,WCI,,        :SEND IT
        LHI     R11,TIBRPA      :LOAD REPEAT TO ADDRESS OFFSET
        CALL(VIGTEC,VICCSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT OFF
        JAL     R4,WCI,,        :SEND RPA
        LR      R6,R10          :LOAD RUBLK FOR VB CALL
        LHI     R5,$A24         :LOAD LINE 24
        CALL(VBGTPS,VICCSV)
        LR      R0,R5           :LOAD CHAR IN R0 FOR XMISSION
        JAL     R4,WCI,,        :SENDIT
        LHI     R5,$A80         :COLUMN 80
        CALL(VBGTPS,VICCSV)
        LR      R0,R5           :LOAD CHAR INTO R0 FOR XMISSION
        JAL     R4,WCI,,        :SENDIT
        LHI     R0,$080         :LOAD A NULL
        JAL     R4,WCI,,        :SEND THE NULL
 :      CALL(VIWAIT,VICCSV)
:
:       NOW MOVE CURSOR BACK WHERE WE GOT IT
:
        LHI     R11,TIBPSX      :LOAD OFFSET OF POSX CHAR
        CALL(VIGTEC,VICCSV)
        JAL     R4,WCI,,        :SEND ESCAPE CHAR
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND POSITION X CHAR
        LH      R5,AUBLIN,R10,  :LOAD LINE ADDRESS FROM AUB
        CALL(VBGTPS,VICCSV)
        LR      R0,R5           :LOAD INTO R0
        JAL     R4,WCI,,        :SEND IT
        LHI     R11,TIBPSY      :LOAD Y POSITION OFFSET
        CALL(VIGTEC,VICCSV)
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND IT
        LH      R5,AUBCOL,R10,  :LOAD COLUMN INDEX
        CALL(VBGTPS,VICCSV)
        LR      R0,R5           :LOAD THE CHARACTER INTO R0
        JAL     R4,WCI,,        :SENDIT
VIERRT  RETURN(R0)
:
:       ROUTINE TO GET A MESSAGE FROM THE USERS TERMINAL
:
:       R10 - POINTS TO THE AUB OF USER TO GET MESSAGE FROM
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VIGTMS,$0 0D)
        CHAINS(VIGMSV,$0 0D)
        DEBUGM(entering VIGTMS,DBGANC,DALL,VIGMSV,$00D)
        LHI     R11,TIBGET      :LOAD GET MSG CHARACTER OFFSET
        CALL(VIGTEC,VIGMSV)
        LR      R0,R0           :SET CONDITION CODE
        JLE     VIGTRT          :IF NO CHARACTER RETURN
        JAL     R4,WCI,,        :SEND ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE CHARACTER
        JAL     R4,WCI,,        :SEND GET MSG CHARACTER
        J       VIGTRT
VIGTRT  RETURN(R0)
:
:       ROUTINE TO CLEAR UNPROTECTED LOCATIONS TO NULL
:
:       R10 - POINTS TO AUB OF USER TO CLEAR
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VICLUP,$0 0D)
        CHAINS(VICUSV,$0 0D)
        DEBUGM(entering VICLUP,DBGANC,DALL,VICUSV,$00D)
        LHI     R11,TIBCLU      :LOAD OFFSET OF CLEAR UNPROTECTED
        CALL(VIGTEC,VICUSV)
        LR      R0,R0           :SET CONDITION CODE
        JLE     VICLRT          :JUMP IF NO CHARACTERS TO SEND
        JAL     R4,WCI,,        :SEND ESCAPE SEQUENCE
        SRLS    R0,8            :SHIFT OUT ESCAPE CHARACTER
        JAL     R4,WCI,,        :SEND CLEAR CHARACTER
VICLRT  RETURN(R0)
:
:       ROUTINE TO INDICATE UNSOLICITED MESSAGE TO USER OF VIDEO TERMINAL
:
:       R10 - POINTS TO AUB OF RECEIVER OF UNSOLICITED MESSAGE
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VIUMSN,$0 0D)
        CHAINS(VIUNSV,$0 0D)
        DEBUGM(entering VIUMSN,DBGANC,DALL,VIUNSV,$00D)
        LHI     R11,TIBUON      :LOAD OFFSET OF UMSG ON CHARACTER
        CALL(VIGTEC,VIUNSV)
        LR      R0,R0           :SET CONDITION CODE
        JLE     VIUNN4          :JUMP IF NOTHING TO SEND
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT OFF ESCAPE CHARACTER
        JAL     R4,WCI,,        :SEND ULITE ON CHARACTER
        J       VIUNRT          :GO TO RETURN
:
VIUNN4  LA      R2,UONMSG       :LOAD ADDRESS OF MESSAGE
        LHI     R0,UONLNG       :LOAD LENGTH OF MESSAGE
        LR      R4,R1           :SAVE REG1 BUFFER INDEX
        LR      R1,R10          :MAKE R1 POINT TO AUB
        CALL(SENDMS,VIUNSV)
        LR      R1,R4           :RESTORE R1 TO BUFFER NUMBER
:
VIUNRT  RETURN(R11)
VIUMST  EQ      .
UONMSG  AC      /UMSG WAITING"8D"8A/
UONLNG  EQ      .-VIUMST
:
:       ROUTINE TO TURN OF UMSG INDICATION.  NOOP EXCEPT FOR 440W
:
:       R10 - POINTER TO USERS AUB
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VIUMSF,$0 0D)
        CHAINS(VIUMSV,$0 0D)
        DEBUGM(entering VIUMSF,DBGANC,DALL,VIUMSV,$00D)
        LHI     R11,TIBUOF      :LOAD OFFSET OF UMSG OFF
        CALL(VIGTEC,VIUMSV)
        LR      R0,R0           :SET CONDITION CODE
        JLE     VIUORT          :JUMP IF NO CHARS TO SEND
        JAL     R4,WCI,,        :SEND ESCAPE CHAR
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND ULITE OFF CHARACTER
VIUORT  RETURN(R11)
:
:       ROUTINE TO TURN PROTECT MODE OFF FOR VIDEO TERM
:       R10 - USERS AUB
:       R1 - BUFFER INDEX, COMPUTED BY USER
:
        PROCS(VIPROF,$0 0D)
        CHAINS(VIPFSV,$0 0D)
        DEBUGM(entering VIPROF,DBGANC,DALL,VIPFSV,$00D)
        LHI     R11,TIBPRF      :LOAD OFFSET OF PRO OFF CHAR
        CALL(VIGTEC,VIPFSV)
        LR      R0,R0           :SET CONDITION CODE
        JLE     VIPFRT          :JUMP IF NO CHARACTERS
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND PROFF CHAR
VIPFRT  RETURN(R0)
:
:       ROUTINE TO TURN PROTECT MODE ON FOR VIDEO TERM
:
:       R1 - BUFFER INDEX, COMPUTED BY CALLER
:
        PROCS(VIPRON,$0 0D)
        CHAINS(VIPRSV,$0 0D)
        DEBUGM(ENTERING VIPRON,DBGANC,DALL,VIPRSV,$00D)
        LHI     R11,TIBPRN      :LOAD OFFSET OF PROTECT ON CHAR
        CALL(VIGTEC,VIPRSV)
        LR      R0,R0           :SET CONDITION CODES
        JLE     VIPRNT          :JUMP IF NO CHARACTER
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND PROTECT ON CHAR
VIPRNT  RETURN(R0)
:
:       ROUTINE TO POSITION CURSOR TO A LINE AND COLUMN
:
:       R10 - AUB POINTER
:       R8 - LINE ADDRESS
:       R9 - COLUMN ADDRESS
:       R1 - BUFFER INDEX COMPUTED BY CALLER
:
        PROCS(VIPOSC,$0 0D)
        CHAINS(VIPSSV,$0 0D)
        DEBUGM(ENTERING VIPOSC,DBGANC,DALL,VIPSSV,$00D)
        STH     R8,AUBLIN,R10   :STORE LINE ADDRESS
        STH     R9,AUBCOL,R10   :STORE COLUMN ADDRESS
        LR      R6,R10          :SET UP R6 FOR VBGTPS CALLS
        LB      R13,AUBTTY,R10  :GET TERM TYPE
        CLHI    R13,AUB440      :DO WE HAVE A 440
        JN      VIPSN4          :JUMP IF NOT
        LHI     R11,TIBPOS      :LOAD POSITION CHAR INDEX
        CALL(VIGTEC,VIPSSV)
        JAL     R4,WCI,,        :WRITE ESCAPE
        SRLS    R0,8            :SHIFT OFF ESCAPE CHARACTER
        JAL     R4,WCI,,        :SEND POSITION CHARACTER
        LR      R5,R8           :LOAD LINE NUMBER
        CALL(VBGTPS,VIPSSV)
        LR      R0,R5           :LOAD POSITIONING CHARACTER
        JAL     R4,WCI,,        :WRITE LINE POSITIONING CHARACTER
        LR      R5,R9           :LOAD COLUMN NUMBER
        CALL(VBGTPS,VIPSSV)
        LR      R0,R5           :LOAD REGISTER TO WRITE
        JAL     R4,WCI,,        :WRITE COLUMN CHARACTER
        J       VIPSRT          :JUMP TO RETURN 
VIPSN4  LB      R13,AUBTTY,R10  :LOAD TTYY TYPE
        CLHI    R13,AUB470      :COMPARE TO 470 TYPE
        JN      VIPSRT          :JUMP IF NOT
        LHI     R11,TIBPSX      :LOAD POSITION X CHARACTER
        CALL(VIGTEC,VIPSSV)
        JAL     R4,WCI,,        :WRITE ESCAPE
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND POSITION X CHARACTER
        LR      R5,R8           :LOAD LINE ADDRESS
        CALL(VBGTPS,VIPSSV)
        LR      R0,R5           :LOAD POSITIONING CHARACTER
        JAL     R4,WCI,,        :SEND POSITIONING CHARACTER
        LHI     R11,TIBPSY      :LOAD OFFSET OF Y POSITIONING CHARACTE
        CALL(VIGTEC,VIPSSV)
        JAL     R4,WCI,,        :WRITE ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND POSITION Y CHARACTER
        LR      R5,R9           :LOAD COLUMN NUMBER
        CALL(VBGTPS,VIPSSV)
        LR      R0,R5           :LOAD CHAR FOR XMISSION
        JAL     R4,WCI,,
VIPSRT  RETURN(R0)
:
:       ROUTINE TO TURN WRITE PROTECT ON
:
:       R10 - USERS AUB ADDRESS
:       R1 - BUFFER INDEX  COMPUTED BY USER
:       ON RETURN PROTECT ON SEQ SENT TO TERMINAL
:
        PROCS(VIWPON,$0 0D)
        CHAINS(VIWPSV,$0 0D)
        DEBUGM(ETERING VIWPON,DBGANC,DALL,VIWPSV,$00D)
        LHI     R11,TIBWPN      :LOAD OFFSET OF WP ON CHAR
        CALL(VIGTEC,VIWPSV)
        LR      R0,R0           :SET CONDITION CODES
        JLE     VIWPRT          :JUMP IF NO CHARACTERS
        JAL     R4,WCI,,        :GO SENT ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE CHARACTER
        JAL     R4,WCI,,        :GO SEND SRITE PROTECT ON CHAR
VIWPRT  RETURN(R0)
:
:       ROUTINE TO TURN WRITE PROTECT OFF
:
:       R10 - USERS AUB ADDRESS
:       R1 - BUFFER INDEX
:
:       ON RETURN WRITE PROTECT OFF HAS BEEN SENT TO TERMINAL
:
        PROCS(VIWPOF,$0 0D)
        CHAINS(VIWPFS,$0 0D)
        DEBUGM(ENTERING VIWPOF,DBGANC,DALL,VIWPFS,$00D)
        LHI     R11,TIBWPF      :LOAD OFFSET OF WRITE PROTECT OFF CHAR
        CALL(VIGTEC,VIWPFS)
        LR      R0,R0           :CHECK FOR NO CHARS
        JLE     VIWPRF          :IF NO CHARS JUMP
        JAL     R4,WCI,,        :JUMP TO WRITE ESCAPE
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND WRITE PRO OFF CHAR
VIWPRF  RETURN(R0)
:
:       ROUTINE TO GET AN ATTRIBUTE CHARACTER (NON LIGHT PEN)
:       FOR TRANSMISSION
:
:       SEQUENCE- ESC, !, X   WHERE X IS THE CHARACTER (PROTECTED, ALPHA,....)
:       R10 - AUB ADDRESS
:       R11 - OFFSET IN THE TIB OF THE CHARACTER TO BE SENT
:
:       R0 - CONTAINS THE THREE CHARACTER SEQUENCE ON RETURN
:               -2  BAD OFFSET IN THE TIB
:               -1  NO TIB FOR THE USERS TERMINAL
:               0  NO CONTROL CHARAACTER FOUND
:               >0  GOOD SEQUENCE
:
        PROCS(VIGTAT,$0 0D)
        CHAINS(VIGASV,$0 0D)
        LR      R11,R11         :SET CONDITION CODE
        JLE     VIANOP          :BAD ARGUMENT
        LHI     R2,TIBNUM       :LOAD OFFSET OF END OF CONTROL CHARS
        CLR     R11,R2          :COMPARE TO INPUT ARG
        JGE     VIATBD          :CHARACTER OFF END OF TIB
        JAL     RLINK,VITPTB    :put my TIB pointer in R12
        LR      R12,R12         :DID WE GET A TIB??
        JLE     VIABDT          :NO RETURN
        LB      R0,,R12,R11     :LOAD THE CONTROL CHAR
        JE      VIANOP          :IF ZERO THEN JUMP
        SLLS    R0,8            :SHIFT ONE BYTE LEFT
        LB      R1,TIBNLP,R12,  :LOAD NOHN LIGHT PEN DETECTABLE
        JE      VIANOP          :IF ZERO NOT SUPPORTED
        OR      R0,R1           :OR THE CHARACTER IN
        SLLS    R0,8            :SHIFT THE TWO CHARACTERS LEFT ONE
        LB      R1,,R12,        :LOAD ESCAPE CHARACTER
        OR      R0,R1           :OR CHARACTERS TOGETHER
        J       VIARET          :JUMP TO RETURN
VIATBD  LCS     R0,2            :LOAD ERROR INDICATION
        J       VIARET
VIABDT  LCS     R0,1            :NO TIB ERROR
        J       VIARET
VIANOP  SR      R0,R0           :NO CHARACTER FOUND
VIARET  RETURN(R1)
:
:       ROUTINE TO SEND BEGIN PROTECTED FIELD SEQUENCE
:
:       R10 - AUB POINTER
:       R1 - BUFFERINDEX
:
        PROCS(VIAPRO,$0 0D)
        CHAINS(VIAPSV,$0 0D)
        LHI     R11,TIBPRT      :PROTECTED ATTRIBUTE FIELD
        CALL(VIGTAT,VIAPSV)
        LR      R0,R0           :SET CONTITION CODE
        JLE     VIPRET          :NULL OPERATION
        JAL     R4,WCI,,        :SEND ESCAPE CHARACTER
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND !
        SRLS    R0,8            :SHIFT OFF !
        JAL     R4,WCI,,        :SEND PROTECTED ATR CAHR
VIPRET  RETURN(R0)
:
:       ROUTINE TO SEND BEGIN NORMAL FIELD SEQUENCE
:
:       R10 - AUB POINTER
:       R1 - BUFFER INDEX
:
        PROCS(VIANOR,$0 0D)
        CHAINS(VIANSV,$0 0D)
        LHI     R11,TIBNOR      :LOAD OFFSET OF NORMAL FIELD
        CALL(VIGTAT,VIAPSV)
        LR      R0,R0           :SET CONDITIONS CODES
        JLE     VINRET          :IF  LE ZERO THEN NULL OP
        JAL     R4,WCI,,        :SEND ESCAPE
        SRLS    R0,8            :SHIFT OFF ESCAPE
        JAL     R4,WCI,,        :SEND !
        SRLS    R0,8            :SHIFT OFF !
        JAL     R4,WCI,,        :SEND NORMAL FIELD CHARACTER
VINRET  RETURN(R0)
:
:       ROUTINE TO CLEAR FIELD TO NULLS
:
:       R10 - AUB POINTTER
:       R1 - BUFFER INDEX
:
        PROCS(VICLFD,$0 0D)
        CHAINS(VICFSV,$0 0D)
        LHI     R11,TIBCFD      :LOAD ERASE LINE FIELD OFFSET
        CALL(VIGTEC,VICFSV)
        LR      R0,R0           :SET COND CODES
        JE      VICFRT          :JUMP IF NO CHAR
        JAL     R4,WCI,,        :SENT ESCAPE
        SRLS    R0,8            :SHIFT IT OFF
        JAL     R4,WCI,,        :SEND ERL
VICFRT  RETURN(R0)
:
:
:       BUFFERED VIDEO ROUTINES
:       INTERFACE AS FOLLOWS
:       R6 - AUB ADDRESS
:       R7 - POINTER TO OUTPUT BUFFER
:       R10 - # REMAINING BYTES
:       R11 - # CHARACTERS IN THE PRESENT LINE
:
:       ROUTINE TO GET AN ESCAPE SEQUENCE FROM THE TIB
:
:       R6 - AUB ADDRESS 
:       R5 - OFFSET IN TIB FOR ESCAPE CHARACTER
:       
:       R5 - ESCAPE SEQUENCE TO BE STORED ON RETURN
:
        PROCS(VBGTEC,$0 0D)
        CHAINS(VBGTSV,$0 0D)
:
        DEBUGM(entering VBGTEC,DBGANC,DALL,VBGTSV,$00D)
        LR      R5,R5           :SET CONDITION CODE
        JLE     VBNOOP          :ZERO OR NEG....NOOP
        CLHI    R5,TIBNUM       :LOAD HIGHEST GOOD OFFSET
        JGE     VBBDAG          :BAD CHARACTER....NOOP
        CALL(VBTPTB,VBGTSV)
: NOW POINTER TO TIB IS IN R7
        LR      R7,R7           :SET CONDITION CODE
        JLE     VBBDTM          :JUMP IF BAD TERMINAL TYPE
        LB      R5,,R7,R5       :LOAD CONTROL CHARACTER
        JE      VBNOOP          :IF NO CONTROL CHARACTER THEN NOOP
        SLLS    R5,8            :SHIFT LEFT 8 BITS
        LB      R8,0,R7,        :R8 IS ESCAPE CHARACTER
        OR      R5,R8           :OR ESCAPE SEQUENCE TOGETHER
        J       VBGRET          :GO TO RETURN SEQUENCE
VBBDAG  LCS     R5,2            :ERROR INDICATION IN R5
        J       VBGRET          :JUMP TO RETURN
VBBDTM  LCS     R5,1            :LOAD ERROR INDICATION
        J       VBGRET          :GO TO RETURN
VBNOOP  SR      R5,R5           :NULL OPERATION
VBGRET  RETURN(R6)
:
:       ROUTINE TO GET THE POSITIONING CHARACTER FROM TIB
:       
:       R5 - INTEGER TO BE CONVERTED TO CHARACTER 
:       R6 - AUB ADDRESS FOR USER
:
:       ON RETURN R5 IS CHARACTER FOR LINE ADDRESSING
:
        PROCS(VBGTPS,$0 0D)
        CHAINS(VBGPSV,$0 0D)
        DEBUGM(ENTERING VBGTPS,DBGANC,DALL,VBGPSV,$00D)
        CLHI    R5,$0 50        :MUST BE LESS THAN 80
        JG      VBGOFL          :JUMP TO ERROR IF OVERFLOW
        CLHI    R5,$0 1         :CANNOT BE LESS THAN 1
        JL      VBGUFL          :UNDERFLOW
        CALL(VBTPTB,VBGPSV)
        LR      R7,R7           :SET CONDITION CODES
        JLE     VBGTER          :JUMP TO ERROR
        LA      R7,TIBNUM,R7    :LOAD START OF CURSOR POSITIONING
        LB      R5,,R7,R5       :LOAD THE CONTROL CHARACTER
        J       VBGTRT          :JUMP T RETURN
VBGTER  LCS     R5,3            :LOAD ERROR
        J       VBGTRT
VBGUFL  LCS     R5,2            :SET ERROR CODE
        J       VBGTRT          :RETURN
VBGOFL  LCS     R5,1            :SET ERROR OVERFLOW
VBGTRT  RETURN(R6)
:
:       ROUTINE TO GET ADDRESS OF USERS TIB FOR A USER BLOCK
:       
:       R6 - AUB ADDRESS FOR USER
:
:       R7 - TIB ADDRESS
:
        PROCS(VBTPTB,$0 0D)
        LHI     R7,AUB440       :LOAD 440 TYPE
        CLB     R7,AUBTTY,R6,   :COMPARE TO USERS TYPE
        JN      VBNT44          :JUMP IF NOT A 440
        LA      R7,TIB440,,     :LOAD ADDRESS OF TIB FOR 440 TERMINAL
        J       VBTRET          :JUMP TO RETURN
VBNT44  LHI     R7,AUB470       :LOAD 470 TYPE
        CLB     R7,AUBTTY,R6,   :COMPARE TO USERS TYPE
        JN      VBTBAD          :JUMP IF NOT 440 OR 470
        LA      R7,TIB470,,     :LOAD 470 TIB ADDRESS
        J       VBTRET          :JUMP TO RETURN
VBTBAD  LCS     R7,1            :LOAD NEGATIVE FOR ERROR
VBTRET  RETURN(R8)

:
:       ROUTINE TO GET THE POSITIONING CHARACTER FROM TIB
:       This routine is substituted for VBGTPS & VBTPTB
:       Instead of calling VBTPTS to get the TIB address, get TIB
:       address directly from AUB
:       
:       R5 - INTEGER TO BE CONVERTED TO CHARACTER 
:       R6 - AUB ADDRESS FOR USER
:
:       ON RETURN R5 IS CHARACTER FOR LINE ADDRESSING
:
        PROCS(VBPOCH,$0 0D)
        CHAINS(VBPOSV,$0 0D)
        DEBUGM(ENTERING VBPOCH,DBGANC,DALL,VBPOSV,$00D)
        CLHI    R5,$0 50        :MUST BE LESS THAN 80
        JG      VBPOFL          :JUMP TO ERROR IF OVERFLOW
        CLHI    R5,$0 1         :CANNOT BE LESS THAN 1
        JL      VBPUFL          :UNDERFLOW
        L       R7,AUBTIB,R6    :get TIB addr  SET CONDITION CODES
        JLE     VBPTER          :JUMP TO ERROR
        LA      R7,TIBNUM,R7    :LOAD START OF CURSOR POSITIONING
        LB      R5,,R7,R5       :LOAD THE CONTROL CHARACTER
        J       VBPTRT          :JUMP T RETURN
VBPTER  LCS     R5,3            :LOAD ERROR
        J       VBPTRT
VBPUFL  LCS     R5,2            :SET ERROR CODE
        J       VBPTRT          :RETURN
VBPOFL  LCS     R5,1            :SET ERROR OVERFLOW
VBPTRT  RETURN(R6)

:
:       ROUTINE TO ERASE TO END OF LINE
:       
:       R6 - AUB ADDRESS
:
:       ON RETURN AN ERASE TO END OF LINE IN STORED IN BUFFER
:
:       FOR 470 AUBLIN, AUBCOL MUST BE ACCURATE SINCE CURSOR
:       IS MOVED TO THIS POSITION BEFORE RETURN
:
        PROCS(VBERLN,$0 0D)
        CHAINS(VBERSV,$0 0D)
        DEBUGM(ENTERING VBERLN,DBGANC,DALL,VBERSV,$00D)
        LH      R5,AUBTTY,R6,   :GET TERM TYPE
        CLHI    R5,AUB470       :COMPARE TO 470
        JE      VBEL47
        LHI     R5,TIBERL       :LOAD ERASE LINE CHARACTER
        CALL(VBGTEC,VBERSV)
        LR      R5,R5           :CHECK FOR NO CHARACTER
        JLE     VBERRT          :JUMP IF NOTHING TO DO
        STB     R5,0,R7         :STORE A BYTE IN BUFFER (ESCAPE)
        SRLS    R5,8            :SHIFT OFF ESCAPE
        STB     R5,1,R7         :STORE THE ERASE CHARACTER
        SIS     R10,2           :DECREMENT SPACE IN BUFFER
        AIS     R7,2            :INCREMENT BUFFER POINTER
        J       VBERRT          :RETURN TO CALLER
VBEL47  LHI     R5,TIBSBA       :LOAD SET BUFFER ADDRESS CHAR
        CALL(VBGTEC,VBERSV)
        STB     R5,0,R7         :STORE ESCAPE
        AIS     R7,1            :INCREMENT OPOINTER
        SRLS    R5,8            :SHIFT IT OFF
        STB     R5,0,R7         :STORE SBA
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,2           :DECREMENT AVAILABEL
        LH      R5,AUBLIN,R6,   :LOAD LINE ADDRESS
        CALL(VBGTPS,VBERSV)
        STB     R5,0,R7         :STORE THE LINE
        AIS     R7,1            :INCREMENT THE POINTER
        SIS     R10,1           :DECREMENT AVAILABLE
        LH      R5,AUBCOL,R6,   :LOAD COLUMN POSITION
        CALL(VBGTPS,VBERSV)
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1           :DECREMENT AVAILABLE
        LHI     R5,TIBRPA       :LOAD REPEAT TO ADDRESS  OFFSET
        CALL(VBGTEC,VBERSV)     :GET ESCAPE SEQ
        LR      R5,R5           :SET COND CODES
        JLE     VBERRT          :IF NULL RETURN
        STB     R5,0,R7         :STORE ESCAPE
        SRLS    R5,8            :SHIFT IT OFF
        STB     R5,1,R7         :STORE THE CONTROL CHAR
        AIS     R7,2            :INC POINTER
        SIS     R10,2           :DEC AVAIL
        LH      R5,AUBLIN,R6    :GET LINE NUMBER
        CALL(VBGTPS,VBERSV)     :GET THE POSITIONING CHARACTER
        LR      R5,R5           :SET COND CODE
        JL      VBERRT
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INC POINTER
        SIS     R10,1           :DEC AVAIL
        LHI     R5,$A 80        :COLUMN 80
        CALL(VBGTPS,VBERSV)
        STB     R5,0,R7         :STORE CONTROL CHAR
        AIS     R7,1            :INC POINTER
        SIS     R10,1           :DEC AVAIL
        LHI     R5,$0 80        :LOAD A NULL
        STB     R5,0,R7         :STORE NULL
        SIS     R10,1           :DEC AVAIL
        AIS     R7,1            :INC POINTER
:
:       NOW MOVE THE CURSOR BACK
:
        LHI     R5,TIBPSX       :LOAD POSITIONING OFFSET (MOVE BUF ADDR)
        CALL(VBGTEC,VBERSV)
        LR      R5,R5           :SET COND CODES
        JLE     VBERRT          :JUMP ID NO CHAR
        STB     R5,0,R7         :STORE ESCAPE
        SRHLS   R5,8            :SHIFT IT
        STB     R5,1,R7         :STORE POSITION X CHAR
        AIS     R7,2            :INCREMENT POINTER
        SIS     R10,2           :DECREMENT AVAIL
        LH      R5,AUBLIN,R6,   :LOAD CURSOR LINE ADRESS
        CALL(VBGTPS,VBERSV)
        LR      R5,R5           :SET COND CODES
        JLE     VBERRT          :JUMP IF BAD POSITION
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1           :DECREMENT BUFFER SPACE
        LHI     R5,TIBPSY       :LOAD Y POSITION 
        CALL(VBGTEC,VBERSV)
        LR      R5,R5           :SET COND CODE
        JLE     VBERRT          :SKIP  IF LOW
        STB     R5,0,R7         :STORE A BYTE 
        SRLS    R5,8            :SHIFT ESCAPE OFF
        STB     R5,1,R7         :STORE CONTROL CHAR
        SIS     R10,2           :DECREMENT AVAIL
        AIS     R7,2            :INCREMENT POINTER
        LH      R5,AUBCOL,R6,   :LOAD COLUMN
        CALL(VBGTPS,VBERSV)
        LR      R5,R5           :SET COND CODES
        JLE     VBERRT
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1           :DECREMENT AVAILABLE BYTES
VBERRT  RETURN(R12)              :RETURN TO CALLER
:
:       ROUTINE TO UNLOCK KEYBOARD
:
:       R6 - AUB POINTER
:
:       ON RETURN UNLOCK KEYBOARD SEQUENCE IS IN BUFFER
:
        PROCS(VBULKB,$0 0D)
        CHAINS(VBULSV,$0 0D)
        DEBUGM(ENTERING VBULKB,DBGANC,DALL,VBULSV,$00D)
        LHI     R5,TIBUNL       :LOAD UNLOCK KEYBOARD CHARACTER
        CALL(VBGTEC,VBULSV)
        LR      R5,R5           :CHECK FOR NO CHARACTER
        JLE     VBULRT          :JUMP IF NOTHING TO STORE
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT OFF ESCAPE CHARACTER
        STB     R5,1,R7         :STORE CONTROL CHARACTER
        SIS     R10,2           :DECREMENT AVAILABLE SPACE IN BUFFER
        AIS     R7,2            :INCREMENT BUFFER POINTER
VBULRT  RETURN(R12)             :RETURN TO CALLER
:
:       ROUTINE TO DISPLAY A SOM ON VIDEO TERMINAL
:
:       R6 - AUB POINTER
:
:       ON RETURN A SOM CHARACTER IS IN THE BUFFER
:
        PROCS(VBSNSM,$0 0D)
        CHAINS(VBSNSV,$0 0D)
        DEBUGM(ENTERING VBSNSM,DBGANC,DALL,VBSNSV,$00D)
        LH      R5,AUBLIN,R6,   :LOAD LINE POSITION
        CLHI    R5,$A20         :COMPARE TO 20
        JLE     VNOWRP          :JUMP IF NO WRAP
        LIS     R0,5            :LINE 5
        LIS     R5,1            :COLUMN 1
        CALL(VBPOSC,VBSNSV)
VNOWRP  LHI     R5,AUB470       :LOAD 470 TYPE
        CLB     R5,AUBTTY,R6,   :COMPARE TO USERS TERMINAL
        JE      VBSS44          :JUMP IF EQ
        LHL     R5,AUBCOL,R6    : CURR. COL. POSITION.
        CHI     R5,1            : CHECK CURR. COL. IS 1.
        IFF(G)                  : NOT COL1 - PUT SOM ON NEXT LINE.
          LHL     R0,AUBLIN,R6  : CURR. LINE NUMBER.
          CLHI    R0,$A 20      : LAST LINE ON CRT IS 20.
          IFF(L)                :
            AIS     R0,1        : ENOUGH ROOM NO NEED TO WRAP AROUND.
          ORELSE                : AT THE BOTTOM OF THE DISPLAY.
            LIS     R0,5        : RESET TO THE TOP OF THE DISPLAY (LINE=5)
          ENDIF
          LIS     R5,1          : SET TO COL=1.
          CALL(VBPOSC,VBSNSV)    : POSITION CURSOR.
        ENDIF   

        LHI     R5,TIBSOM       :LOAD SOM CHARACTER OFFSET
        CALL(VBGTEC,VBSNSV)
        LR      R5,R5           :ANYTHING TO SEND
        JLE     VBSNRT          :JUMP IF NOTHING
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT ESCAPE OFF
        STB     R5,1,R7         :STORE SOM CHARACTER
        SIS     R10,2           :DECREMENT CHARACTER COUNT
        AIS     R7,2            :INCREMENT BUFFER POINTER
        J       VBSNRT          :JUMP TO RETURN
VBSS44  LHI     R5,TIBSBA       :LOAD SET BUFFER ADDRESS CHAR
        CALL(VBGTEC,VBSNSV)
        STB     R5,0,R7         :STORE ESCAPE
        AIS     R7,1            :INCREMENT OPOINTER
        SRLS    R5,8            :SHIFT IT OFF
        STB     R5,0,R7         :STORE SBA
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,2           :DECREMENT AVAILABEL
        LH      R5,AUBLIN,R6,   :LOAD LINE ADDRESS
        CALL(VBGTPS,VBSNSV)
        STB     R5,0,R7         :STORE THE LINE
        AIS     R7,1            :INCREMENT THE POINTER
        SIS     R10,1           :DECREMENT AVAILABLE
        LH      R5,AUBCOL,R6,   :LOAD COLUMN POSITION
        CALL(VBGTPS,VBSNSV)
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1           :DECREMENT AVAILABLE
        LHI     R5,TIBRPA       :LOAD REPEAT TO ADDRESS SEQUENCE
        CALL(VBGTEC,VBSNSV)
        STB     R5,0,R7         :STORE THE ESCAPE
        SRHLS   R5,8            :SHIFT IT OFF
        STB     R5,1,R7         :STORE THE RPA CHAR
        LH      R5,AUBLIN,R6,   :LOAD THE LINE NUMBER
        AIS     R5,4            :ADD 5
        CALL(VBGTPS,VBSNSV)
        STB     R5,2,R7,        :STORE LINE CHAR
        LHI     R5,$A 80            :LOAD A $A 80
        CALL(VBGTPS,VBSNSV)
        STB     R5,3,R7,        :STORE COLUMN
        LHI     R5,$0 080         :LOAD A NULL
        STB     R5,4,R7         :STOE THE SPACE
 :      CALL(VBWAIT,VBSNSV)
:
:       NOW CLEARED INPUT AREA TO SPACES
:
        LHI     R5,TIBNLP       :LOAD NON LIGHT PEN CHAR
        CALL(VBGTEC,VBSNSV)
        STB     R5,5,R7,        :STORE THE ESCAPE
        SRLS    R5,8            :SHIFT IT OFF
        STB     R5,6,R7,        :STORE NON LIGHT PEN CHAR
        LHI     R5,TIBPRT       :LOAD PROTECTED FIELD OFFSET
        CALL(VBGTEC,VBSNSV)
        SRLS    R5,8            :SHIFT OFF ESCPE
        STB     R5,7,R7         :STORE PROTECTED FIELD
:
:       NOW MOVE CURSOR BACK WHERE IT WAS
:
        LHI     R5,TIBPSX       :LOAD COLUMN (X) POSITION CHAR
        CALL(VBGTEC,VBSNSV)
        STB     R5,8,R7,        :STORE ESCAPE
        SRLS    R5,8            :SHIFT IT OFF
        STB     R5,9,R7,        :STOE CHAR
        LH      R5,AUBLIN,R6,   :LOAD LINE NUMMBER
        CALL(VBGTPS,VBSNSV)
        STB     R5,$A 10,R7,    :STORE IT
        LHI     R5,TIBPSY       :LOAD COLUMN POSITIONING CHAR
        CALL(VBGTEC,VBSNSV)
        STB     R5,$A 11,R7,       :STORE ESCAPT
        SRLS    R5,8            :SHIFT IT OFF
        STB     R5,$A 12,R7,       :STORE COL POSITION CMD
        LH      R5,AUBCOL,R6,   :LOAD COLUMN ADDRESS
        CALL(VBGTPS,VBSNSV)
        STB     R5,$A 13,R7,       :STORE POSITION CHAR
:
:       NOW PUT OUT PROMT CHAR AND ATTR BYTE
:
        LHI     R5,$0 3E        :> CHAR
        STB     R5,$A 14,R7,       :STORE IT
        LHI     R5,TIBNLP       :LOAD NON LIGHT PEN CHAR
        CALL(VBGTEC,VBSNSV)
        STB     R5,$A 15,R7,       :STORE ESCAPE
        SRLS    R5,8            :SHIFT IT OFF
        STB     R5,$A 16,R7,       :STORE NLP BYTE
        LHI     R5,TIBNOR       :LOAD NORMAL FIELD ATTRA OFFSET
        CALL(VBGTEC,VBSNSV)
        SRLS    R5,8            :SHIFT OFF ESCAPE
        STB     R5,$A 17,R7,       :STORE NORMAL FIELD ATTR
        LH      R5,AUBCOL,R6,   :LOAD COLUMN POSITION
        AIS     R5,2            :NOW 2 COLUMNS OVER
        STH     R5,AUBCOL,R6,   :STORE IT BACK
        LHI     R5,TIBMDT       :RESET MODIFIED DATA TAGS SEQ
        CALL(VBGTEC,VBSNSV)
        STB     R5,$A 18,R7        :STORE ESCAPE
        SRLS    R5,8            :SHIFT IST OFF
        STB     R5,$A 19,R7        :STORE RESET MDT CHAR
        AI      R7,$A 20        :INCREMENT POINTER
        SI      R10,$A 20       :DECREMENT AVAILABLE BYTES
        LH      R5,AUBLIN,R6,  :LOAD LINE NUMBER
        STH     R5,AUBPLN,R6,  :STORE IN PROMPT LINE
        LH      R5,AUBCOL,R6,  :LOAD COLUMN
        STH     R5,AUBPCL,R6,  :STOE IN PROMPT COL
VBSNRT  RETURN(R12)             :RETURN TO SENDER
:
:       ROUTINE TO CLEAR SCREEN TO NULLS
:
:       R6 - AUB POINTER
:
:       ON RETURN CLAEAR TO NULLS IS IN THE BUFFER
:
        PROCS(VBCLAL,$0 0D)
        CHAINS(VBCLSV,$0 0D)
        DEBUGM(ENTERING VBCLAL,DBGANC,DALL,VBCLSV,$00D)
        LHI     R5,TIBCSN       :GET OFFSET OF THE CHARACTER
        CALL(VBGTEC,VBCLSV)
        LR      R5,R5           :CHECK FOR LESS THAN ZERO
        JLE     VBCLRT          :JUMP IF NOT GOOD CHARACTER
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT OFF ESCAPE
        STB     R5,1,R7         :STORE THE CONTROL CHAR
        SIS     R10,2           :DECREMENT ROOM LEFT IN BUFFER
        AIS     R7,2            :INCREMENT POINTER
VBCLRT  RETURN(R12)
:
:       ROUTINE TO ERASE UNPROTECTED LOCATIONS FROM CURSOR LOCATION
:
:       R6 - AUB ADDRESS
:
:       ON RETURN ERASE UNPROTECTED IS IN OUTPUT BUFFER
:
        PROCS(VBERUP,$0 0D)
        CHAINS(VBCCSV,$0 0D)
        DEBUGM(ENTERING VBERUP,DBGANC,DALL,VBCCSV,$00D)
        LHI     R5,AUB470       :LOAD 470 TERMINAL TYPE
        CLB     R5,AUBTTY,R6,   :COMPARE TO USERS TYPE
        JE      VBEU47          :JUMP IF SO
        LHI     R5,TIBERS       :LOAD OFFSET OF ERASE CHARACTER
        CALL(VBGTEC,VBCCSV)
        LR      R5,R5           :CHECK FOR NO SUCH CHARACTER
        JLE     VBERUT          :JUMP IF NO SUCH CHAR
        STB     R5,0,R7         :STORE ESCAPE CHARACTER IN BUF
        SRLS    R5,8            :SHIFT OUT ESCAPE CHARACTER
        STB     R5,1,R7         :STORE CONTROL CHARACTER
        SIS     R10,2           :SUBTRACT FROM AVAILABLE BUFFER SPACE
        AIS     R7,2            :INCREMENT POINTER
        J       VBERUT          :JUMP TO RETURN
VBEU47  LHI     R5,TIBSBA       :LOAD SET BUFFER ADDRESS CHAR
        CALL(VBGTEC,VBCCSV)
        STB     R5,0,R7         :STORE ESCAPE
        AIS     R7,1            :INCREMENT OPOINTER
        SRLS    R5,8            :SHIFT IT OFF
        STB     R5,0,R7         :STORE SBA
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,2           :DECREMENT AVAILABEL
        LH      R5,AUBLIN,R6,   :LOAD LINE ADDRESS
        CALL(VBGTPS,VBCCSV)
        STB     R5,0,R7         :STORE THE LINE
        AIS     R7,1            :INCREMENT THE POINTER
        SIS     R10,1           :DECREMENT AVAILABLE
        LH      R5,AUBCOL,R6,   :LOAD COLUMN POSITION
        CALL(VBGTPS,VBCCSV)
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1           :DECREMENT AVAILABLE
        LHI     R5,TIBRPA       :LOAD REPEAT TO ADDRESS OFFFSET
        CALL(VBGTEC,VBCCSV)
        LR      R5,R5           :SET COND CODES
        JLE     VBERUT          :IF NO CHAR THEN NULL OP
        STB     R5,0,R7         :STORE ESCAPE
        SRLS    R5,8            :SHIFT IT OFF
        AIS     R7,1            :INC POINTER
        STB     R5,0,R7         :STORE REPEAT CHAR
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,2           :DEC AVAIL
        LHI     R5,$A 24        : GO TO 24TH LINE
        CALL(VBGTPS,VBCCSV)
        STB     R5,0,R7         :STORE LINE CHAR
        AIS     R7,1            :INC POINTER
        SIS     R10,1           :DEC AVAIL
        LHI     R5,$A 80        :COLUMN 80
        CALL(VBGTPS,VBCCSV)
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INC POINTER
        SIS     R10,1           :DEC AVAIL
        LHI     R5,$0 80        :LOAD A NULL
        STB     R5,0,R7         :STORE IT 
        AIS     R7,1            :INC POINTER
        SIS     R10,1           :DEC SPACE
        LHI     R5,TIBPSX       :LOAD POSITIONING OFFSET (MOVE BUF ADDR)
        CALL(VBGTEC,VBCCSV)
        LR      R5,R5           :SET COND CODES
        JLE     VBERUT          :JUMP ID NO CHAR
        STB     R5,0,R7         :STORE ESCAPE
        SRHLS   R5,8            :SHIFT IT
        STB     R5,1,R7         :STORE POSITION X CHAR
        AIS     R7,2            :INCREMENT POINTER
        SIS     R10,2           :DECREMENT AVAIL
        LH      R5,AUBLIN,R6,   :LOAD CURSOR LINE ADRESS
        CALL(VBGTPS,VBCCSV)
        LR      R5,R5           :SET COND CODES
        JLE     VBERUT          :JUMP IF BAD POSITION
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1           :DECREMENT BUFFER SPACE
        LHI     R5,TIBPSY       :LOAD Y POSITION 
        CALL(VBGTEC,VBCCSV)
        LR      R5,R5           :SET COND CODE
        JLE     VBERUT          :SKIP  IF LOW
        STB     R5,0,R7         :STORE A BYTE 
        SRLS    R5,8            :SHIFT ESCAPE OFF
        STB     R5,1,R7         :STORE CONTROL CHAR
        SIS     R10,2           :DECREMENT AVAIL
        AIS     R7,2            :INCREMENT POINTER
        LH      R5,AUBCOL,R6,   :LOAD COLUMN
        CALL(VBGTPS,VBCCSV)
        LR      R5,R5           :SET COND CODES
        JLE     VBERUT
        STB     R5,0,R7         :STORE IT
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1           :DECREMENT AVAILABLE BYTES
VBERUT  RETURN(R12)
:
:       ROUTINE TO PUT TERMINAL IN BLOCK MODE
:
:       R6 - AUB POINTER
:
:       ON RETURN THE BLOCK MODE SEQUENCE IS IN THE BUFFER
:
        PROCS(VBBLKM,,$0 0D)
        CHAINS(VBBLSV,$0 0D)
        DEBUGM(ENTERING VBBLKM,DBGANC,DALL,VBBLSV,$00D)
        LHI     R5,TIBBLK       :LOAD OFFSET OF BLOCK MODE CHARACTER
        CALL(VBGTEC,VBBLSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBBLRT          :JUMP IF NO CHARS TO STORE
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT THE ESCAPE OFF
        STB     R5,1,R7         :STORE CONTROL CHARACTER
        AIS     R7,2            :BUMP POINTER
        SIS     R10,2           :DECREMENT AVAILABLE CHAR COUNT
VBBLRT  RETURN(R12)
:
:       ROUTINE TO PUT TERMINAL IN CONVERSATIONAL MODE
:
:       R6 - AUB POINTER
:
:       ON RETURN CONVERSATIONAL SEQUENCE S IN BUFFER
:
        PROCS(VBCNVM,$0 0D)
        CHAINS(VBCNSV,$0 0D)
        DEBUGM(ENTERING VBCNVM,DBGANC,DALL,VBCNSV,$00D)
        LHI     R5,TIBCNV       :LOAD CONVERSATIONAL CHARACTER
        CALL(VBGTEC,VBCNSV)
        LR      R5,R5           :LOAD TO SET COND CODE
        JLE     VBCNRT          :IF NO CHAR THEN A NOOP
        STB     R5,0,R7         :STORE ESCAPE CHAR
        SRLS    R5,8            :SHIFT OFF ESCAPE CHAR
        STB     R5,1,R7         :STORE CONVERSATIONAL CHARACTER
        AIS     R7,2            :INCREMENT POINTER
        SIS     R10,2           :DECREMENT AVAILABLE BUFFER SPACE
VBCNRT  RETURN(R12)
:
:       ROUTINE TO TURN WRITE PROTECT ON
:
:       R6 - AUB POINTER
:
:       ON RETURN PROTECT ON CHAR IS IN BUFFER
:
        PROCS(VBWPON,$0 0D)
        CHAINS(VBPRSV,$0 0D)
        DEBUGM(ENTERING VBWPON,DBGANC,DALL,VBPRSV,$00D)
        LHI     R5,TIBWPN       :LOAD A WRITE PROTECT ON OFFSET
        CALL(VBGTEC,VBPRSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBPRRT          :IF NO CHAR THEN RETURN
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT OFF ESCAPE CHARACTER
        STB     R5,1,R7         :STORE WPON CHAR
        AIS     R7,2            :INCREMENT POINTER
        SIS     R10,2           :DECREMENT AVAIL BYTES
        LB      R5,AUBTTY,R6    :LOAD USERS TERMINAL TYPE
        CLHI    R5,AUB470       :COMPARE TO 470 TYPE
        JN      VBPRRT          :IF NOT DONE
        LHI     R5,$0 082       :LOAD AN STX
        STB     R5,0,R7         :STORE IN BUFFER
        AIS     R7,1            :INCREMENT BUFFER POINTER
        SIS     R10,1           :DECREMENT AVAILABLE SPACE COUNTER
VBPRRT  RETURN(R12)
:
:       ROUTINE TO TURN WRITE PROTECT OFF
:
:       R6 - AUB POINTER
:
:       ON RETURN PRO OFF CHAR IS IN BUFFER
:
        PROCS(VBWPOF,$0 0D)
        CHAINS(VBPFSV,$0 0D)
        DEBUGM(ENTERING VBWPOF,DBGANC,DALL,VBPFSV,$00D)
        LHI     R5,TIBWPF       :LOAD OFFSET OF WRITE PRO OFF
        CALL(VBGTEC,VBPFSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBPFOT          :DO NOTHING IF NO CHARS
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT OFF ESCAPE CHARACTER
        STB     R5,1,R7         :STORE FUNCTION CHARACTER
        AIS     R7,2            :INCREMENT POINTER INTO BUFFER
        SIS     R10,2           :DECREMENT MAX BUFFER SIZE
        LB      R5,AUBTTY,R6    :LOAD USERS TTY TYPE
        CLHI    R5,AUB470
        JN      VBPFOT          :IF NOT 470 THEN RETURN
        LHI     R5,$0 80        :LOAD A NULL
        STB     R5,0,R7         :STORE IN BUFFER
        AIS     R7,1            :INCREMENT BUFFER POINTER
        SIS     R10,1           :DECREMENT AVAILABLE SPACE
VBPFOT  RETURN(R12)
:
:       ROUTINE TO TURN PROTECT MODE ON
:       
:       R6 - AUB POINTER
:
:       ON RETURN PROTECT ON CHAR IS IN BUFFER
:
        PROCS(VBPRON,$0 0D)
        CHAINS(VBPMSV,$0 0D)
        DEBUGM(ENTERING VBPRON,DBGANC,DALL,VBPMSV,$00D)
        LHI     R5,TIBPRN       :LOAD OFFSET OF PROTECT ON BIT
        CALL(VBGTEC,VBPMSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBPNRT          :IF NO CHARS THEN RETURN
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT OFF ESCAPE SEQUENCE
        STB     R5,1,R7         :STORE CONTROL CHAR
        AIS     R7,2            :INCREMENT BUFFER OINTER
        SIS     R10,2           :DECREMENT AVAILABLE BUFFER COUNT
VBPNRT  RETURN(R12)
:
:       ROUTINE TO TURN PROTECT MODE OFF
:
:       R6 - AUB POINTER
:
:       ON RETURN PROTECT OFF CHAR IS IN BUFFER
:
        PROCS(VBPROF,$0 0D)
        CHAINS(VBPFSV,$0 0D)
        DEBUGM(ENTERING VBPROF,DBGANC,DALL,VBPFSV,$00D)
        LHI     R5,TIBPRF       :LOAD OFFSET OF PROTECT OFF CHAR
        CALL(VBGTEC,VBPFSV)
        LR      R5,R5           :SET COND CODES
        JLE     VBPFRT          :JUMP IF NOTHING TO SEND
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT OFF ESCAPE CHARACTER
        STB     R5,1,R7         :STORE PROTECT OFF CHAR
        AIS     R7,2            :BUMP BUFFER POINTER
        SIS     R10,2           :DECREMENT BUFFER LENTGTH AVAIL
VBPFRT  RETURN(R12)
:
:       ROUTINE TO POSITION THE CURSOR
:       
:       R6 - AUB POINTER
:       R0 - LINE NUMBER
:       R5 - COLUMN NUMBER
:
:       ON RETURN CURSOR POSITIONING CHARACTERS ARE IN BUFFER
:
        PROCS(VBPOSC,$0 0D)
        CHAINS(VBPSSV,$0 0D)
        STH     R0,AUBLIN,R6    :STORE LINE ADDRESS
        STH     R5,AUBCOL,R6    :STORE COLUMN ADDRESS
        LB      R13,AUBTTY,R6   :GET TERMINAL TYPE
        CLHI    R13,AUB440      :DO WE HAVE A 440
        JN      VPSN4           :JUMP IF NOT
        LR      R12,R5          :SAVE COLUMN POSITION
        LHI     R5,TIBPOS       :LOAD 440 POSITIONING CHAR
        CALL(VBGTEC,VBPSSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBPSRT          :JUMP IF NO CURSOR POSITIONING
        STB     R5,0,R7         :STOREESCAPE CHARACTER
        SRLS    R5,8            :SHIFT OFF ESCAPE CHARACTER
        STB     R5,1,R7         :STORE CONTROL CHARACTER        
        LR      R5,R0           :LOAD LINE NUMBER
        CALL(VBGTPS,VBPSSV)
        STB     R5,2,R7         :STORE LINE NUMBER
        LR      R5,R12          :GET COLUMN NUMBER FOR POSITIONING
        CALL(VBGTPS,VBPSSV)     :GET CONTROL CHARACTER
        STB     R5,3,R7         :STORE THE CHARACTER IN THE BUF
        AIS     R7,4            :INCREMENT BUFFER POINTER
        SIS     R10,4           :DECREMENT AVAILABLE SPACE
        J       VBPSRT          :JUMP TO RETURN
VPSN4   LB      R13,AUBTTY,R6   :GET TERMINAL TYPE
        CLHI    R13,AUB470      :CMPARE TO 470
        JN      VBPSRT          :JUMP IF NOT EQUAL
        LR      R12,R5          :SAVE R5 (COLUMN POSITION)
        LHI     R5,TIBPSX       :LOAD POSITION X AXIS CHARACTER
        CALL(VBGTEC,VBPSSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBPSRT          :JUMP IF NO CHARACTER
        STB     R5,0,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :SHIFT OFF ESCAPE CHARACTER
        STB     R5,1,R7         :STORE POSITION X CHARACTER
        LR      R5,R0           :LOAD LINE ADDRESS
        CALL(VBGTPS,VBPSSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBPSRT          :JUMP IF ERROR
        STB     R5,2,R7         :STORE LINE POSITIONING CHARACTER
        LHI     R5,TIBPSY       :LOAD Y POSITIONING OFFSET
        CALL(VBGTEC,VBPSSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBPSRT          :JUMP IF ERROR
        STB     R5,3,R7         :STORE ESCAPE CHARACTER
        SRLS    R5,8            :STORE Y POSITIONSING CHARACTER
        STB     R5,4,R7         :STORE Y POSITIONING CHARACTER
        LR      R5,R12          :LOAD COLUMN NUMBER
        CALL(VBGTPS,VBPSSV)
        LR      R5,R5           :SET CONDITION CODES
        JLE     VBPSRT          :JUMP IF ERROR
        STB     R5,5,R7         :STORE COLUMN NUMBER CHARACTER
        AIS     R7,6            :INCREMENT BUFER POINTER
        SIS     R10,6           :DECREMENT AVAILABLE CHARACCTERS
VBPSRT  RETURN(R12)
:
:       ROUTINE TO TURN THE PRINTER ON
:
:       Expects an AUB pointer in R1 (RUBLK)
:
:       Looks at TIBPRI to see if the terminal has printing capability,
:       if so it picks up a string pointer at offset TIBPON and writes
:       it to the user's output buffer.
:
        PROCS(TUPRON,$0 0D)
        CHAINS(TUPRSV,$0 0D)
        L       R10,AUBTIB,RUBLK        :get TIB pointer
        LB      R11,TIBPRI,R10          :does terminal support printing?
        JE      TUPNRT                  :no, return
        LH      R1,AUBPRT,RUBLK         :port number
        SLHLS   R1,2                    :times four
        AIS     R1,2                    :plus two is buffer number
        LB      R11,TIBECH,R10          :do we need to turn echo off?
        JE      TUPRN2                  : no, skip it
        LA      R5,TECHOF               :address of ECHO OFF message
        PUTSC(R5,R6)                    :stuff it in the output buffer
TUPRN2  L       R5,TIBPON,R10           :pointer to "printer on" escape
                                        : sequence in SC format
        PUTSC(R5,R6)                    :write string (ptr, free reg)
TUPNRT  RETURN(RRETC)                   :and return
:
TECHOF  SC      /"00"B1"00"00/          :ISIS msg to turn echo off
TECHON  SC      /"00"B1"00"01/
:
:
:       ROUTINE TO TURN PRINTER OFF
:
:       Expects an AUB address in R1 (RUBLK)
:
:       Looks at TIBPRI to see if the terminal has printing capability,
:       if so it picks up a string pointer at offset TIBPOF and writes
:       it to the user's output buffer.
:
        PROCS(TUPROF,$0 0D)
        CHAINS(TUPFSV,$0 0D)
        L       R10,AUBTIB,RUBLK        :get TIB pointer
        LB      R11,TIBPRI,R10          :does terminal support printing?
        JE      TUPFRT                  :no, return
        LH      R1,AUBPRT,RUBLK         :port number
        SLHLS   R1,2                    :times four
        AIS     R1,2                    :plus two is buffer number
        LB      R11,TIBECH,R10          :do we need to turn echo on?
        JE      TUPRF2                  : no, skip it
        LA      R5,TECHON               :pointer to ECHO ON string
        PUTSC(R5,R6)                    :put it in the buffer
TUPRF2  L       R5,TIBPOF,R10           :pointer to "printer off" escape
                                        : sequence in SC format
        PUTSC(R5,R6)                    :write string (ptr, free reg)
TUPFRT  RETURN(RRETC)                   :and return
:
:       ROUTINE TO SEND NULLS TO 470 TERMINALS FOR 'LONG'
:       OPERATIONS 
:       R10  AUB
:       R1 - BUFFER ADDR
:
        PROCS(VIWAIT,$0 0D)
        LHI     R0,$0 80        :LOAD A NULL
        LIS     R12,$A10        :SET COUNTER TO 10
VIWTLP  JAL     R4,WCI,,        :SEND A NULL
        SIS     R12,1           :DECREMENT COUNTER
        JG      VIWTLP          :IF NOT ZERO DO IT AGAIN
        RETURN(RRETC)
:
:               ROUTINE TO PUT NULLS IN THE BUFFER TO
:       ALLOW LONG OPERATIONS TO COMPLETE ON THE 
:       TYM 470
:
:       R6 - AUB
:       R7 - BUFFER POINTER
:       R10 - BYTES REMAINING IN BUFFER
:       R11 - # CHARS IN PRESENT LINE (PRINTABLE)
:
        PROCS(VBWAIT,$0 0D)
        LHI     R5,$0 80        :LOAD A NULL
        LIS     R12,$A 10       :10 NULLS TO SEND
VBWTLP  STB     R5,0,R7         :STOE A BYTE
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1   :DECREMENT COUNTER
        JG      VBWTLP          :MORE IF NOT ZERO
        RETURN(RRETC)

: This routine is called to put a SC string into OUTBUF
: Input  : R13 - pointer to the start of SC string
:        : R14 - scatch
: Output : R7  - current pointer to OUTBUF(updated)
:        : R10 - space left in OUTBUF(updated)
:
        PROCS(PUTSC1,$0 0D)
        CHAINS(PUTSAV,$0 0D)

        LB      R12,0,R13               :get length of the string
        AIS     R13,1                   :advanced pointer
        DO(COUNT,R12)
          LB    R15,0,R13               :ge next char
          STB   R15,0,R7                :store char in OUTBUF
          AIS   R13,1                   :get next char
          AIS   R7,1                    :advanced OUTBUF pointer
          SIS   R10,1                   :decrement available space
        ENDDO
        RETURN(R12)





: This routine put cursor position chars into OUTBUF for hardcopy terminal
: with c1,C2 chars supported. It is called by MAG1TX, and calls  
: PUTSC1 to put a SC string into OUTBUF.
: input: R6 - pointer to AUB
:        R5 - contain line number
: output:R7 & R10 are updated.
:        R7 - current pointer to OUTBUF
:        R10 - space left in OUTBUF

        PROCS(HDSCPO,$0 0D)
        CHAINS(HDSSAV,$0 0D)
        
        L       R12,AUBTIB,R6           :GETTHE TIB ADDR OF THIS TERMINAL
        L       R13,TIBLAB,R12          :GET THE START ADDR OF SC STRING(BEGIN)
        JE      ERRHRD                  :NULL SC STRING,INCREMENT ERROR COUNTER
        CALL(PUTSC1,HDSSAV)             :PUT INTO OUTBUF
        CALL(VBPOCH,HDSSAV)             :translate(line # in R5)to control char
        STB     R5,0,R7                 :store line addressing char in OUTBUF
        LIS     R5,1                    :set colume # = 1
        CALL(VBPOCH,HDSSAV)             :translate col pos to addressing char
        STB     R5,1,R7                 :store it in OUTBUF
        AIS     R7,2                    :advanced pointer
        SIS     R10,2                   :decrement  available space
        L       R13,TIBLAE,R12          :any esc seq for cursor posi left ?
        JE      HDLNRT                  :no, jump return
        CALL(PUTSC1,HDSSAV)             :yes, put it in OUTBUF
        JFS     HDLNRT
ERRHRD  LIS     R5,1                    :increment the error counter
        AHM     R5,ERHDLA,,     
HDLNRT  RETURN(R12)



: This routine put cursor position chars into OUTBUF for PCI-78 terminal
: with c1,C2 chars supported. It is called by MAG1TX, and calls  
: PUTSC1 to put a SC string into OUTBUF.
: The difference between this routine and HDSCPO is that here the col 
: position is put before the line position
: input: R6 - pointer to AUB
:        R5 - contain line number
: output:R7 & R10 are updated.
:        R7 - current pointer to OUTBUF
:        R10 - space left in OUTBUF

        PROCS(HDSC78,$0 0D)
        CHAINS(HD78SV,$0 0D)
        
	LR	R11,R5			: save line number
        L       R12,AUBTIB,R6           :GETTHE TIB ADDR OF THIS TERMINAL
        L       R13,TIBLAB,R12          :GET THE START ADDR OF SC STRING(BEGIN)
        JE      ERR78                   :NULL SC STRING,INCREMENT ERROR COUNTER
        CALL(PUTSC1,HD78SV)             :PUT INTO OUTBUF
        LIS     R5,1                    :set colume # = 1
        CALL(VBPOCH,HD78SV)             :translate col pos to addressing char
        STB     R5,0,R7                 :store col addressing char in OUTBUF
	LR	R5,R11			: line number got as input
        CALL(VBPOCH,HD78SV)             :translate(line # in R5)to control char
        STB     R5,1,R7                 :store it in OUTBUF
        AIS     R7,2                    :advanced pointer
        SIS     R10,2                   :decrement  available space
        L       R13,TIBLAE,R12          :any esc seq for cursor posi left ?
        JE      HD78RT                  :no, jump return
        CALL(PUTSC1,HD78SV)             :yes, put it in OUTBUF
        JFS     HD78RT
ERR78   LIS     R5,1                    :increment the error counter
        AHM     R5,ERHDLA,,     
HD78RT  RETURN(R11)



: This routine is to put erase sequence into OUTBUF. It is called
: by MAG1TX for hardcopy terminal with C1,C2 chars supported
: Input: R6 - AUB pointer
: Output:R7 - pointer to current OUTBUF(updated)
:        R10- OUTBUF space left(updated)

        PROCS(HDERAS,$0 0D)
        CHAINS(HDESAV,$0 0D)
        L       R12,AUBTIB,R6           :get TIB pointer for this terminal
        L       R13,TIBERA,R12          :get pointer to SC string
        JE      ERRERA
        CALL(PUTSC1,HDESAV)
        J       HDERRT
ERRERA  LIS     R13,1                   :increment error counter
        AHM     R13,ERHDER,,
HDERRT  RETURN(R12)

        EM


: AUBPGM.01K COPIED FROM
: (MATS.PRD)AUBPGM.NAD.  10/15/80.

        RA      $00
        MO      .+3&-4,AUBPGM
:       CODE SEGMENT
        SEG     1
:       
:       Routine to initialize the AUB list.
:       On return all AUBs will be linked together on the free list.
PROC(INTAUB)
CHAIN(INTASV)
:
        LI      R2,AUBLKS      :GET ADDR OF FIRST AUB
        ST      R2,AUTFRE      :AUTFRE -> 1ST AUB
        LI      R3,NAUBS*AUBLNG :GET NUMBER OF BYTES TO BE ZEROED
        SR      R4,R4         :ZERO R4 FOR INITIALIZING AUBS
:
        CALL(CLEAR,INTASV)      :CALL ROUTINE TO ZERO AUBS
:
        LHI     R9,NAUBS        :LOAD NUMBER OF AUB
:
AUBLOP  LA      R11,AUBLNG,R2  :MOVE ON TO NEXT AUB
        ST      R11,AUBNXT,R2  :CHAIN AUBS TOGETHER
        LR      R2,R11         :BUMP POINTER
        SHI     R9,1            :DECREMENT AUB COUNTER
        JN      AUBLOP          :LOOP IF MORE TO LINK
:
        SHI     R2,AUBLNG       :BACKUP TO LAST AUB ENTRY..
        ST      R4,AUBNXT,R2   :NULL LAST LINK
        ST      R4,AUTACT       :NULL ACTIVE LIST POINTER
	ST	R4,NUMAUT	:NO ACTIVE AUBS
        SR      RRETC,RRETC     :ALWAYS SUCCEEDS.....
        RETURN(R2)
:
:       Routine to get an AUB from the free list.
:       NON ZERO RETURN CODE MEANS NO AUBS AVAIL
:       ON RETURN RUBLK POINTS TO AN AUB AND
:       THE AUBPRT FIELD HAS -RUBLK (THE PORT NUMBER)
:       On return, RUBLK points to the AUB gotten.
:
PROC(GETAUB)
        L       R2,AUTFRE      :GET HEAD OF AUBFRE LIST
        JN      GOTONE          :IF NONZERO, AUBS ARE AVIAL
        LHI     RRETC,-1           :NO AUBS AVAIL....SET BAD RETURN
        RETURN(R2)                  :NO AUB AVAIL
GOTONE  L       R11,AUBNXT,R2  :GET POINTER TO NEXT FREE AUB
        ST      R11,AUTFRE      :POINT FREE POINTER AT NEXT
        XI      RUBLK,-1        :COMPUTE NEGATIVE OF PORT NUMBER
        AIS     RUBLK,1
        STH     RUBLK,AUBPRT,R2         :STORE PORT NUMBER
        LR      RUBLK,R2                :SET USER BLOCK REGISTER
	LIS	R3,1
	AM	R3,NUMAUT	:INCREMENT NUMAUT
        SR      RRETC,RRETC     :GOOD RETURN CODE
        RETURN(R2)
:
:       Routine to place an AUB in the active list.
:       RUBLK must point to the AUB to be activated.
:
PROC(ACTAUB)
        L       R11,AUTACT      :GET HEAD OF ACTIVE AUB LIST
        ST      R11,AUBNXT,RUBLK  :LINK AUB TO HEAD OF LIST
        ST      RUBLK,AUTACT      :POINT ACTIVE HEAD TO AUB
        SR      RRETC,RRETC     :SET RETURN CODE
        RETURN(R2)
:
:       Routine to release an AUB.  That is to put the AUB on
:       the free list.  RUBLK points to the AUB to be released.
:
PROC(RELAUB)
CHAIN(RELASV)
        L       R11,AUTACT              :LOAD ADDR OF ACTIVE POINTER
	CR	R11,RUBLK	:TEST FOR MATCH
	JEFS	FNDTOP		:MATCH ... SKIP
 
SERLOP	L	R10,AUBNXT,R11	:MOVE DOWN CHAIN
        JE      NOFND           :GO TO ERROR PROCESSING
        CR      R10,RUBLK         :HVE WE FOUND PREDECESSOR??
        JEFS      FNDAUB          :HAVE FOUND PREDECESSOR
        LR      R11,R10         :BUMP POINTERS
        JBS     SERLOP          :CHECK NEXT ONE
:
FNDTOP	L	R9,AUBNXT,RUBLK	:GET SUCCESSOR
	ST	R9,AUTACT	:STORE IT
	JFS	FND1
:
FNDAUB  L       R9,AUBNXT,RUBLK :GET SUCCESSOR OF AUB TO BE AXED
        ST      R9,AUBNXT,R11           :REMOVE HIM FROM THE CHAIN
:
FND1	CALL(RELRBS,RELASV)	:RELEASE RB'S IF ANY
:
        LR      R2,RUBLK        :PREPARE TO CALL CLEAR ROUTINE
        LHI     R3,AUBLNG       :GET LENGTH OF AREA TO BE CLEARED
        SR      R4,R4           :ZERO R4
        CALL(CLEAR,RELASV)
:
        L       R9,AUTFRE       :GET FREE LIST POINTER
        ST      R9,AUBNXT,RUBLK   :POINT AUB AT TOP OF CHAIN
        ST      RUBLK,AUTFRE      :STORE AUB ADDRESS IN AUTFRE
	LCS	R3,1
	AM	R3,NUMAUT	:DECREMENT NUMAUT
        SR      RRETC,RRETC     :SET GOOD RETURN CODE...
        RETURN(R2)
NOFND	JAL	R10,CRASH,,	:CRASH
	BC	0,0,4*RLINK,BADAUT	:CRASH CODES
:
:	CONTROL L
	
	RA	$0 0A
:
	PROC(MATAUT)
:
:	THIS ROUTINE SEARCHES THE ACTIVE AUT LIST FOR
:	A MATCH AGAINST THE 12 CHARACTER USERNAME + 2 CHARACTER AGENT IDENTIFIER
:	SUPPLIED
:
:	PARMS:
:		R2 HAS ADDRESS OF 14 CHARACTER STRING TO MATCH
:
:	RETCODES
:		R0 = 0 IF NO MATCH IS FOUND
:		R0 (RRETC) = AUT ADDRESS IF FOUND
:
:
:
:	GET THE START OF THE ACTIVE USER LIST
:
	L	R11,AUTACT
	JE	CMPR3		:JUMP IF NO ACTIVE AUB'S
:
:	START COMPARING THE USER PARM TO USER NAMES
CMPR	LIS	R8,0	:INDEX INTO USER PARM/USER NAME
	LHI	R3,14	:LENGTH OF USR NAME PLUS AGENT ID
	LI	R12,AUBUSR,R11	:POINT TO USER NAME
:
:	GET THE NEXT BYTE FROM THE USER SUPPLIED PARM AND COMPARE
:	IT TO THE USERNAME
:
CMPR2	LB	R10,0,R2,R8	:GET USER SUPPLIED PARM
	CLB	R10,0,R12,R8	:COMPARE TO USERNAME
	JN	NXTAUT	:JUMP IF NO MATCH
	AIS	R8,1	: INCREMENT INDEX
	SIS	R3,1	::DECREMENT LOOP COUNTER
	JGBS	CMPR2
:
:	THIS 14 CHARACTER NAME/AGENT ID MATCHES. THEREFORE
:	IT'S THE ONE
	LR	RRETC,R11
RETRN	RETURN(R1)
:
:	CHAIN THRU ACTIVE AUTS
:
NXTAUT	L	R11,AUBNXT,R11
	JN	CMPR	:JUMP IF MORE USERS TO CHECK
CMPR3	SR	RRETC,RRETC	:NOONE MATCHES
	J	RETRN
:
	EM

: AMTPGM.01K COPIED FROM
: (MATS.PRD)AMTPGM.NAD.  10/15/80.

        RA      $00
        MO      .+3&-4,AMTPGM
:
:       ROUTINE TO INITIALIZE AMT TABLE ENTRIES.
:       AMT IS NOT CHAINED TOGETHER..... SO ONLY ZERO OUT
:       ALL FIELDS...
:       ON RETURN ALL FIELDS OF THE AMT TABLE ARE BINARY ZEROES.
:
PROC(INIAMT)
CHAIN(IAMRT)
        LI      R2,AMTTAB      :GET START OF MAIL LIST.
        LHI     R3,NMON*AMTLNG  :GET LENGTH OF MONITOR TABLE
        SR      R4,R4           :ZERO R4
        CALL(CLEAR,IAMRT)
:
        SR      RRETC,RRETC     :ZERO RETURN CODE
        RETURN(R2)              :ZERO AMTS AND RETURN
:
:       ROUTINE TO GET A MONITOR TABLE ENTRY.  IF THE PORT NUMBER
:       IS ZERO ...ASSUME THE AMB IS UNUSED...
:       ON RETURN RUBLK POINTS TO THE MONITOR BLOCK RETURNED.
:
PROC(GETAMT)
        LHI     R3,NMON         :LOAD NUMBER OF MONITORS TO BE SEARCHED
        LI      R4,AMTTAB      :GET ADDRESS OF BEGINNING OF AMTTAB
GTALOP  LH      R2,AMTPRT,R4  :GET PORT NUMBER FROM THIS ENTRY
        JE      GOTAMT          :IF ZERO THIS AMT IS AVAIL
        LA      R4,AMTLNG,R4  :GO TO NEXT AMT....
        SHI     R3,1            :DECREMENT COUNTER
        JN      GTALOP          :IF MORE AMTS LEFT ,,,LOOP
:
        LHI     RRETC,-1        :NO AMT AVAILABLE
        RETURN(R2)
:
GOTAMT  XI      RUBLK,-1        :COMPLEMENT RUBLK
        AIS     RUBLK,1 
        STH     RUBLK,AMTPRT,R4 :STORE PORT NUMBER 
        SR      RRETC,RRETC     :SET GOOD RETURN CODE
        LR      RUBLK,R4        :PUT REGISTER POINTER IN RUBLK
        RETURN(R2)
:
:       ROUTINE TO RELEASE AN AMT ENTRY...
:       STORES BINARY ZEROES IN AN AMT ENTRY,, THUSS MAKING
:       IT AVAILABLE FOR USE BY ANOTHER MONITOR.
:       ON ENTRY RUBLK POINTS TO AMT TO BE RELEASED
:
PROC(RELAMT)
CHAIN(RAMRET)
        LR      R2,RUBLK          :COPY ADDRESS OF AMT TO BE RELEASED
        LHI     R3,AMTLNG      :GET LENGTH OF AMT ENTRY
        SR      R4,R4           :ZERO R4
:
        CALL(CLEAR,RAMRET)
:
        CALL(GBLTRC,RAMRET)
:
        RETURN(R2)
:
        EM



:  (MATS.P2)R2UPGM.02F.

:    Copied by Bonnell from (MATS.P2)R2UPGM.01K.  11/05/80.

:    Replaced 'NAUBS' by 'NR2U'.

: R2UPGM.01K COPIED FROM
: (MATS.DEV)R2UPGM.NXX 10/15/80

	RA	$0 0A
	MO	.,R2UPGM
:
:MACRO MVWD (MOVE WORDS DOWN) WILL MOVE WORDS POINTED TO BY
: RX TO THE AREA POINTED TO BY RY, FOR A LENGTH OF RY+1
: (THEREFORE RY+1 MUST BE A MULTIPLE OF 4 AND GREATER THAN ZERO
MVWD	MACRO(RX,RY)
[
		SIS	RY+1,4
MVWDL		L	R0,R2ULNG,RX
		ST	R0,0,RX
		AIS	RX,4
		SIS	RY+1,4
		JGEBS MVWDL
]
:
: MACRO MVWU (MOVE WORDS UP) WILL MOVE WORDS POINTED TO BY
: RY TO THE AREA POINTED TO BY RX, FOR A LENGTH OF RX+1
: (THEREFORE RX+1 MUST BE A MULTIPLE OF 4
: AND GREATER THAN ZERO
MVWU	MACRO(RX,RY)
[
		SIS	RX+1,4
MVWUL		L	R0,0,RY,RX+1
		ST	R0,R2ULNG-4,RX
		SIS	RX,4
		SIS	RX+1,4
		JGEBS MVWUL
]
	PROC(BINSCH)
:
: THIS ROUTINE DOES A BINARY SEARCH OF THE R2U TABLE, AND LOOKS
: FOR A MATCH TO THE RES-IA-TA PASSED IN REGISTER 3
:
: IF A MATCH IS NOT FOUND, THEN THE ENTRY NUMBER 
:  (RELATIVE TO ZERO) WHERE IT SHOULD HAVE BEEN IS RETURNED IN R5
: AND -1 IS RETURNED IN REGISTER RRETC.  OTHERWISE, R5 CONTAINS THE
: ENTRY NUMBER WHERE THE RESIATA WAS FOUND (RELATIVE
: TO ZERO)AND RETURNS ZERO IN REGISTER RRETC.
:
:
: FIRST CALCULATE THE SIZE OF THE R2U TABLE TO THE HIGHEST
: POWER OF TWO. THEN DO A BINARY SEARCH, ENSURING THAT
: THE SUBSCRIPT NEVER EXCEEDS THE LIMIT OF THE TABLE, NOR
: THE VALID NUMBER OF ENTRIES (R2UNUM)
POWER	EQ	14
:	CALCULATE HIGHEST SUBSCRIPT
	NOLIST
	RE	14
	IF	(2^POWER-NR2U)
SIZE	EQ	POWER
	EI
POWER	EQ	POWER-1
	ER
	LIST
:
:SIZE NOW HAS POWER OF TWO WHICH EXCEEDS THE R2U TABLE SIZE
SIZE	EQ	SIZE-1
	LI	R7,(2^SIZE)^-1	GET MIDPOINT OF TABLE
	LI	R8,2^SIZE	GET HIGHEST SUBSCRIPT OF TABLE
	L	R6,R2UNUM
	JNFS	LOOP	:NO SPECIAL HANDLING
	LIS	R8,1
	LCS	RRETC,1	:INDICATE NOT FOUND
	J	RETRN
LOOP	C	R8,R2UNUM	:IS SUBSCRIPT OUT OF RANGE
	JG	LWRSUB	JUMP IF SO
	LR	R6,R8	GET SUBSCRIPT AND MULTIPLY BY ENTRYSIZE
	SLL	R6,3	 OF 8 BYTES
	LI	R6,R2UTAB-R2ULNG,R6	LOOK AT ENTRY
	C	R3,0,R6
:				RELATIVE TO 0
	JL	LWRSUB	JUMP IF TABLE ENTRY TOO LARGE
	JE	GOTIT
UPSUB	AR	R8,R7
	JFS	DONYET
LWRSUB	SR	R8,R7
DONYET	LR	R7,R7	:IF INCREMENT IS 0 WE'RE DONE
	JE	NOTHER
	SRL	R7,1	DIVIDE INCREMENT(DECREMENT) BY 2
	J	LOOP
NOTHER	LCS	RRETC,1
	C	R3,0,R6
	JLFS	RETRN
	C	R8,R2UNUM	:ARE WE ALREADY OUT OF BOUNDS
	JGFS	RETRN	:YUP
	AIS	R8,1	:ENTRY SHOULD HAVE BEEN HERE!
	J	RETRN
GOTIT	LIS	RRETC,0
RETRN	LR	R5,R8	GET SUBSCRIPT
	SIS	R5,1	:MAKE ENTRY NUMBER RELATIVE TO 0
	RETURN(R6)
:	CONTROL L - NEW PAGE

:	CONTROL L - NEW PAGE
	PROC(R2UADD)
:	R2UADD - ADD AN ENTRY TO R2UTAB
:
: THIS ROUTINE WILL ADD AN RES-IA-TA TO THE R2UTAB AS
: FOLLOWS
:    RUBLK - HAS ADDRESS OF AUB
:    R3    - HAS RES-IA-TA
:    R5 - ENTRY # TO ADD (RELATIVE TO ZERO).  BINSCH WILL SUPPLY THIS
:
	L	R7,R2UNUM	:GET # OF ENTRIES IN TABLE
	AIS	R7,1	INCREMENT SINCE THIS IS AN ADD
	C	R7,R2UMAX	IS NUMBER > TABLE SIZE
	JG	OVRFLW	JUMP IF SO
	CR	R5,R7	IS ENTRY WITHIN RANGE 
	JG	OVRFLW	JUMP IF TOO LIGH
	CHI	R5,0	: IS ENTRY LESS THAN ZERO
	JL	UDRFLW	JUMP IF TOO LOW
	ST	R7,R2UNUM	:SAVE NEW VALUE
	SIS	R7,1	MAKE # OF ENTRIES RELATIVE TO ZERO
	JAL	R10,CMPADR	:COMPUTE ADDRESS OF SENDING/RECEIVING FIELDS
:
: COMPUTE LENGTH OF MOVE
:
	LR	R8,R7	:R7 HAS ADDRESS OF LAST ENTRY (RECEIVING)
	SR	R8,R5	:R5 HAS ADDRESS OF 'FIRST' (SENDING) ENTRY
:			R8 HAS LENGTH OF TOTAL MOVE
	JE	NEWETY	:JUMP IF ZERO MOVE (NEW ENTRY IS LAST ENTRY)
:
:	SHIFT EVERY ENTRY UP ONE TO MAKE ROOM
:
	MVWU(R7,R5)
:
:	STORE IN NEW ENTRY
:
NEWETY	ST	RUBLK,4,R5
	ST	R3,0,R5
	LIS	RRETC,0
RTRN	RETURN(R1)
:
: ERROR RETURNS
:
OVRFLW	LIS	RRETC,1
	JBS	RTRN
:
UDRFLW	LHI	RRETC,-1
	JBS	RTRN
:
: CMPADR - COMPUTE ADDRESS OF LAST ENTRY IN R2UTAB , 
:          WHOSE NUMBER IS IN R7 (RELATIVE TO 0) AND THE
:          ADDRESS OF THE ENTRY TO BE INSERTED OR ADDED, WHOSE NUMBER
:          IS IN R5 (RELATIVE TO 0)
	SEG	0
WR2ULG	WC	R2ULNG
	SEG	1
CMPADR	LIS	R6,0
	M	R6,WR2ULG,,	: GET DISPLACEMENT FROM BEGINNING OF TABLE
	LI	R7,R2UTAB,R7	:MAKE IT RELATIVE TO 0
:
	LIS	R4,0
	M	R4,WR2ULG,,	:GET DISPLACEMENT FROM BEGINNING OF TABLE
	LI	R5,R2UTAB,R5	:MAKE IT RELATIVE TO 0
	JR	R10
:
:	CONTROL L - NEW PAGE

:	CONTROL L - NEW PAGE
	PROC(R2UDEL)
:	R2UDEL - DELETE AN ENTRY FROM THE R2UTAB
:   R5 HAS THE ENTRY # (RELATIVE TO ZERO) TO DELETE
:       BINSCH WILL SUPPLY THE ENTRY NUMBER
	L	R7,R2UNUM
	CR	R5,R7	: IS ENTRY NUMBER VALID?
	JG	OVRFLW	JUMP IF OUTSIDE RANGE
	SIS	R7,1	DECREMENT SINCE THIS IS A DELETE
	JL	UDRFLW	:CANT HAVE LESS THAN ZERO ENTRIES
	ST	R7,R2UNUM
	JE	R2URET	JUMP IF ZERO ENTRIES
	JAL	R10,CMPADR	:GET ADDRESS OF LAST ENTRY AND
:			ENTRY TO BE DELETED
:
:	COMPUTE LENTH OF MOVE
:
	LR	R8,R7
	SR	R8,R5
	JE	R2URET	:DON'T MOVE IF ITS THE LAST ENTRY
:
: SHIFT EVERY ENTRY DOWN ONE
:
	MVWD(R5,R7)
:
R2URET	LIS	RRETC,0
	RETURN(R1)
	EM

: (TIGERDEV)STATS.S13
:    Copied by Byrne from (MATS.P2)STATS.12S on 7-Aug-86
:    Changed VERSIN to VERSIO

: (MATS.P2)STATS.12S
:    Copied by Gimnicher from (MATS.P2)STATS.11L.  3/12/84
:    Added conditional assembly for FLTLIN.

: (MATS.P2)STATS.11L
:    Copied by Cardini from (MATS.P2)STATS.10T on 12/05/83
:    in order to introduce some code to recognize if this MATS
:    version is for MARSPLUS.
:
: (MATS.P2)STATS.10T
:    Copied by Byrne from (MATS.P2)STATS.09R on 9/27/82.
:    Added new receiver status (CSTLGI).

: (MATS.P2)STATS.09R
: Copied by Cheung from (MATS.P2)STATS.08L on 8-10-82
: Changed system title on the monitor screen for ITC.

: (MATS.P2)STATS.08L
: Copied by Vaysburd from (MATS.P2)STATS.07L on 11.25.81
: Added three new statuses of the receiver: DROPPING, CLOSING, CLOSED.
: (MATS.P2)STATS.07L
: COPIED BY VAYSBURD FROM (MATS.P2)STATS.06L
: ADDED 1 CHAR. TO THE MATS  HOST # IN THE MONITOR BANNER SCREEN.
:
: (MATS.P2)STATS.06L
: COPIED BY VAYSBURD FROM (MATS.P2)STATS.05L
: ADDED CODE WHICH WILL DISPLAY RECEIVER HOST STATUS ON THE MONITOR
: BANNER SCREEN.
:
: (MATS.P2)STATS.05L 
: Copied by Vaysburd from (MATS.P2)STATS.04S on 10.19.81
: Added conditional assembly code for monitor screen line 2 for ITC 
: and code which will display RECEIVER HOST STATUS on the banner screen.
: (MATS.P2)STATS.04S copied from (MATS.P2)STATS.03S on 11-10-80
: by Steve Gimnicher in order to add indicator to monitor
: screen for hung up free blocks.
: -------------------------------------------------------------------
: (MATS.P2)STATS.03S copied from (MATS.P2)STATS.02S on 10-23-80
: by Steve Gimnicher in order to modify MONSCN and MNUPDT for
: Soft Shut implementation.
:-----------------------------------------------------
: (STEVEG)STATS.02S copied from (MATS.DEV)STATS.NXX on 10-13-80
: by Steve Gimnicher in order to modify the CVTRES call for
: Monitor Screen Formatter implementation.
:
	RA	$0 0A
	MO	.,STATS
	GL	STATS
:		THIS ROUTINE IS ACTIVATED BY THE TIMEOUT ROUTINE.
:		IT UPDATES THE FIRST PORTION OF THE MONITOR
:		DISPLAY WHICH GIVES AIRLINE STATUS'
:
:	FIRST PUT MYSELF BACK ON THE TIMEOUT LIST FOR 10 MINUTES
	SEG	1	: CODE SEGMENT
STATS	ST	R1,STTIM,,
	ST	R0,STTME,,
	AI	R1,RATE*STINT
	JAL	R5,TOPUT,,
	LA	R2,STTRC,,
	CALL(TRACE,STTSAV)
	SEG	2
	ORG	(.+3)/4*4	:HALFWORD ALIGN
STTRC	HC	TTIMOT,0002
STTIM	WC	0
STTME	WC	0
	WC	0,0,0
	SEG	1
:
: ADD INTERVAL DATA TO TOTALS AND TRACE TOTALS
:
:	CLEAR OUT ERROR COUNTER REGISTERS
	LIS	R5,0
	LIS	R6,0
	LIS	R7,0
	LHI	R2,NMAG	:LOOP COUNTER
	LI	R3,MAGTAB
ADDMAG	L	R4,MGTCMD,R3
	A	R4,MGICMD,R3
	ST	R4,MGTCMD,R3
	AR	R5,R4
	L	R4,MGTFMT,R3
	A	R4,MGIFMT,R3
	ST	R4,MGTFMT,R3
	AR	R6,R4
	L	R4,MGTAIR,R3
	A	R4,MGIAIR,R3
	ST	R4,MGTAIR,R3
	AR	R7,R4
	L	R4,MGTMGU,R3
	A	R4,MGIMGU,R3
	ST	R4,MGTMGU,R3
	L	R4,MGTMGM,R3
	A	R4,MGIMGM,R3
	ST	R4,MGTMGM,R3
	L	R4,MGTUMG,R3
	A	R4,MGIUMG,R3
	ST	R4,MGTUMG,R3
	L	R4,MGTMMG,R3
	A	R4,MGIMMG,R3
	ST	R4,MGTMMG,R3
	L	R4,MGTRSP,R3
	A	R4,MGIRSP,R3
	ST	R4,MGTRSP,R3
	L	R4,MGIBBC,R3
	AM	R4,MGTBBC,R3
	L	R4,MGIRST,R3
	AM	R4,MGTRST,R3
:
:	NOW DECREMENT LOOP COUNTER
	AHI	R3,MAGLNG
	SIS	R2,1
	JG	ADDMAG
:
:	STORE THE FMT/CMD/AIR ERRORS IN TRACE
:
	ST	R5,STCMD,,
	ST	R6,STFMT,,
	ST	R7,STAIR,,
:
:	ESTABLISH STANDARD INTERFACE
:
	SEG	0
STTSAV	WS	18	:SAVE AREA
	SEG	1
	LIS	R3,0
	ST	R3,STTSAV+4,,	:THERE IS NO FATHER
:
	CALL(MONSCN,STTSAV)
:
: SEE IF ANY ACTIVE MONITORS EXISTS.  IT IS
: EASY TO TELL - IF ANY PORT NUMBER IN AMTTAB \= 0, 
: THEN SOMEONE IS LOGGED ON
	LI	RUBLK,AMTTAB
	LIS	R3,0
	LIS	R4,NMON	:LOOP COUNTER
ADDPRT	AH	R3,AMTPRT,RUBLK
	AHI	RUBLK,AMTLNG
	SIS	R4,1
	JGBS	ADDPRT
:	SEE IF ANY PORTS WERE NOT ZERO
	LR	R3,R3
	JE	CLEARM	: NOONE LOGGED ON
:
: SET PARM REGISTER (RUBLK) TO ZERO TO INDICATE TO MONSND THAT
: THIS SCREEN SHOULD BE SENT TO ALL USERS
:
	SR	RUBLK,RUBLK
	LCS	R2,1	:INDICATE FULL UPDATE
	CALL(MONSND,STTSAV)
:
:	CLEAR OUT THE INTERVAL AREAS
CLEARM	LHI	R2,NMAG		:LOOP COUNTER
	LI	R3,MAGTAB
	LIS	R4,0	:INIT VALUE
:
CLRMAG	ST	R4,MGICMD,R3
	ST	R4,MGIFMT,R3
	ST	R4,MGIAIR,R3
	ST	R4,MGIMGU,R3
	ST	R4,MGIMGM,R3
	ST	R4,MGIUMG,R3
	ST	R4,MGIMMG,R3
	ST	R4,MGIRSP,R3
	ST	R4,MGIRST,R3
	ST	R4,MGIBBC,R3
:
:	NOW DECREMENT LOOP COUNTER
	AHI	R3,MAGLNG
	SIS	R2,1
	JG	CLRMAG
:	ENTER TRACE  SAYING WE'RE DONE
	L	R2,GMT,,
	ST	R2,STTIM2,,
	LI	R2,STTRC2
	CALL(TRACE,STTSAV)
:
	SEG	2
	ORG	(.+3)/4*4	:FULLWORD ALIGN
STTRC2	HC	TSTATC
	HC	0
STTIM2	WC	0
STFMT	WC	0
STCMD	WC	0
STAIR	WC	0
	WC	0
	SEG	1
:
	J	TORET,,
:
:
		:CONTROL L - NEW PAGE
	PROC(MONSND)
	GL	LINPOS,SCNPOS
:	THIS ROUTINE SENDS THE PRE-FORMATTED MONITOR SCREEN
:	'MONITR' TO ANY ACTIVE MONITOR IN OUTPUT MODE
:
:	RUBLK = 0 MEANS SEND SCREEN TO ALL MONITORS
:	      \=0 MEANS SEND ONLY TO THE USER WHOSE AMT IS
:	          IN RUBLK .
:	R2 < 0 ==> SEND FULL SCREEN (TRY LCS R2,1)
:	R2 >=0 ==> RESNUM - JUST SEND THE LINE FOR THIS RES
:
:	CHAIN A SAVE AREA JUST IN CASE
	CHAIN(MN1SAV)
:
	SEG	0
	WS	0
	ORG	.+2	:A QUICK AND DIRTY WAY TO GET TO HALWORD BOUNDED
CURSTT	XC	9BA7	PROTECT OFF
CURPOS	BS	4	CURSOR POSITION
	XC	9BA9	WREITE WRITE PROTECT
LCURPO	EQ	.-CURSTT
:
CURST2	XC	9BA8	 END WRITE PROTECT
	XC	9BA6	SET PROTECT ON
	SEG	1
: NUMBER OF LINES IN MONITOR HEADER - RESNUM TO MONITOR LINE OFSET
MAGLIN	EQ	4
:
: ANNOUNCE YOURSELF
	DEBUGM(entering MONSND,DBGANC,DALL,MN1SAV,$01)
: FIRST DETERMINE MESSAGE TO BE SENT
	LIS	R8,0
	ST	R8,CURPOS,,	:CLEAR OUT CURSOR POS
	LR	R5,R2	:GET RESNUM TO SEND INFO ABOUT
	JL	WHOGET	:JUMP IF ALL RES INFOR WANTED
	CVTRES(R5,MN1SAV)	:CONVERT RES NUMBER TO MAGTAB(MONMAG) LINE NUMBER
	LHI	R3,$A80
	MR	R4,R3	:LENGTH OF MINTOR LINE* RESNUM
	LA	R5,MONMAG,R5,	:R5 NOW HAS ADDR OF SCREEN LINE TO SEND
	LR	R8,R2	GET RES NUMBER
	CVTRES(R8,MN1SAV)	:CONVERT RES NUMBER TO MAGTAB ENTRY NUMBER
	AIS	R8,MAGLIN	ADD LINE NUM OF SCREEN HEADER
:CONVERT R8 (LINE NUMBER) TO CURSOR COMMAND
	LB	R8,SCNPOS,R8,	:CONVERT TO SCREEN POS
	SLL	R8,8	:MAKE ROOM FOR REST OF CMD
	OI	R8,$09BBD00A0
	ST	R8,CURPOS,,	:SAVE CURSPOR POSITION
:
: NOW DETERMINE WHO GETS THE UPDATE
WHOGET	LIS	R4,NMON
	LIS	R3,AMTOUT
	LR	RUBLK,RUBLK
	JEFS	GETUSR	:JUMP IF GOES TO ALL USERS
	LIS	R4,1
	J	CHKLNS	:JUMP FOR 1 MONITOR USER
GETUSR	LA	RUBLK,AMTTAB,,	:GET ADDRESS OF MONITOR TABLE
CHKPRT	LH	R6,AMTPRT,RUBLK
	JE	NXTAMT	JUMP IF PORT = 0, (NOT LOGGED)
CHKLNS	LR	R8,R8	:IS THIS A SINGLE LINE UPDATE
	JNFS	GOTOIT	:IF SO, MONITOR ALWAGS GET IT
	CLB	R3,AMTMOD,RUBLK	:IS MONITOR IN OUTPUT MODE
	JN	NXTAMT	JUMP IF NOT
	J	SNDFUL	:SEND A FULL SCREEN
:
:
GOTOIT	CALL(LOCKKB,MN1SAV)	:LOCK THE KEYBOARD
	LIS	R0,LCURPO:GET LENGTH OF CURSOR STRING
	LA	R2,CURSTT,,	:GET START OD CURSOR STRING
	CALL(SENDMS,MN1SAV)
	LR	R2,R5	:GET LINE OF SCREEN TO SEND
	LHI	R0,$A80	LENGTH OF A LINE
	CALL(SENDMS,MN1SAV)
	LIS	R0,4	:LENGTH OF SCREEN CUROSR STRING
	LA	R2,CURST2,,	:ADDR OF STRING
	CALL(SENDMS,MN1SAV)
	CALL(BEEPER,MN1SAV)
	CLB	R3,AMTMOD,RUBLK	:WAS MONITOR IN OUTPUT MODE
	JE	NXTAMT	:JUMP IF SO - DON'T UNLOCK KEYBOARD
	CALL(UNLKKB,MN1SAV)	:UNLOCK THE KEYBOARD
	JFS	NXTAMT
:
: SNDFUL - SEND THE FULL SCREEN
:
SNDFUL	LHI	R0,LENMON
	LA	R2,MONITR,,
	CALL(SENDMS,MN1SAV)
:
NXTAMT	AHI	RUBLK,AMTLNG	:GET TO NEXT AMT
	SIS	R4,1
	JG	CHKPRT
	RETURN(R1)
:
: DATA AREAS
:
	:CONTROL L - NEW PAGE
: MONSCN - UPDATE FIELDS WITHIN MONITOR SCREEN
:
	PROC(MONSCN)
:
	CHAIN(MN2SAV)
:
:
:	CALCULATE TIME AND DATE
:
	L	R3,STRTTM
	LI	R5,DATSTT
	LHI	R4,13
	CALL(DATIME,MN2SAV)
:
	L	R3,GMT,,
	LHI	R4,13
	LI	R5,DATNOW
	CALL(DATIME,MN2SAV)
:
:
:	DISPLAY NUMBER OF LOGGED ON USERS
:
	L	R3,NUMUSR	: NUMBER OF USERS
	LIS	R4,3	:NUMBER OF OUTPUT DIGITS
	LI	R5,LGUSR	:OUTPUT ADDRESS
	CALL(BINDEC,MN2SAV)
:		R3 STILL HAS NUMBER OF USER
:
:	DISPLAY NUMBER OF ADDT'L USERS THAT WE CAN SUPPORT
:		(BASED ON FREE USER PORTS)
:
	LHI	R6,MAXUSR	:NUMBER OF USER PORTS
	SR	R6,R3
	LR	R3,R6	:NUMBER OF ADDTL USER PORTS
	LI	R5,MORUSR	:OUTPUT ADDRESS
:			R4 STILL HAS COUNT
	CALL(BINDEC,MN2SAV)

        L       R6,NUMUSR,,     :USE R6 TO CALC NUMUSR+NUMMON+NUMDBG IN
                                :ORDER TO DETERMINE IF HOST SHOULD BE
                                :SHUT OR ANSWERED

:
:	COUNT NUMBER OF MONITORS LOGGED ON
	LI	R8,AMTTAB
	LIS	R3,0	:CLEAR COUNTER
	LIS	R10,NMON	: LOOP COUNTER
CHKPRT	L	R7,AMTPRT,R8	:CHECK FOR ZERO PORT
	JEFS	NOTLOG
	AIS	R3,1
NOTLOG	AHI	R8,AMTLNG
	SIS	R10,1
	JGBS	CHKPRT
        AR      R6,R3           :NOW HAVE NUMUSR+NUMMON IN R6
	LI	R5,NUMMON
	LIS	R4,2
	CALL(BINDEC,MN2SAV)
:
:
:	NUMBER OF RES BLOCKS IN USE
:
	L	R3,NUMRB
	LIS	R4,4
	LI	R5,RBUSED
	CALL(BINDEC,MN2SAV)
:
:	NUMBER OF ADDT'L RES BLOCKS STILL BE TO USED
:
	LHI	R7,NRBLK
	SR	R7,R3	:R3 STILL HAS NUMRB COUNT
	LR	R3,R7
	LI	R5,FREERB
	CALL(BINDEC,MN2SAV)
:
:
:	COUNT OF ACTIVE USR BLOCKS IN USE
:
	LI	R5,AUTUSE
	LIS	R4,3
	L	R3,NUMAUT
	CALL(BINDEC,MN2SAV)
:
:		CALCULATE NUMBER OF DEBUGGERS LOGGED ON
:
	LHI	R13,(NDEBUG-1)*DEBLNG	:SET UP LOOP INDEX
	LIS	R12,0	:NO ACTIVE USER INDICATOR
	LIS	R3,0	:CLEAR COUNTER
LUUP	CL	R12,DEBUG,R13
	JEFS	UPNDEX
	AIS	R3,1
UPNDEX	SHI	R13,DEBLNG
	JGEBS	LUUP
        AR      R6,R3           :NOW HAVE NUMUSR+NUMMON+NUMDBV IN R6
	LIS	R4,2	: 2 DIGIT OUTPUT
	LI	R5,NUMDBG	:OUTPUT FIELD
	CALL(BINDEC,MN2SAV)
:
:	CALCULATE FREE AUTS
	LHI	R3,NAUBS
	S	R3,NUMAUT
	LIS	R4,3	:OUTPUT LENGTH
	LI	R5,FREAUT
	CALL(BINDEC,MN2SAV)
:
: DETERMINE IF HOST SHOULD BE SHUT OR ANSWERED
:
        LHL     R3,SOFSHT       :IS SOFT SHUT ENABLED?
        IFF(N,THEN)             :IF \= 0 THEN YES
          CLHI    R6,SHTNUM     :ARE THERE FEW ENOUGH UNUSED CIRCUITS
                                :LEFT THAT MATS SHOULD BE SHUT?
          IFF(GE,THEN)          :   YES
            LHI     R6,SHTCIR   :FLAG MATS AS BEING SHUT BECAUSE OUT OF CIRCUITS
            SBT     R6,SHTMSK,,
            CALL(SHUTIT,MN2SAV) :SHUT MATS (IF NOT ALREADY SHUT!)
          ORELSE
            CLHI    R6,ANSNUM   :ARE THERE ENOUGH UNUSED CIRCUITS LEFT
                                :THAT MATS SHOULD ANSWER ITSELF?
            IFF(LE,THEN)        :   YES
              LHI     R6,SHTCIR :FLAG MATS AS NO LONGER BEING SHUT BECAUSE OUT OF CIRCUITS
              RBT     R6,SHTMSK,,
              CALL(ANSWIT,MN2SAV):ANSWER MATS (IF NOT ALREADY ANSWERED OR
                                :PREVIOUSLY SHUT BY SOME OTHER PROCESS
            ENDIF
          ENDIF
        ENDIF

: PUT IN RECEIVER HOST STATUS
:
        LI      R1,MSCTAB
        LHL     R0,CCBSTA,R1                    :check circuit status
        CLHI    R0,CSTDWN
        IFF(E,THEN)
          LA    R8,QUEST,,                      :STATS CIRCUIT IS DOWN
          LA    R9,HOSTIN,,
          LHI   R10,4
          MVS(R8,R9,R10,R11)                    :move ????string to banner
          LA    R9,STATIN,,
          LI    R10,6
          SPAC(R9,R10,R11)                      :move empty string to banner
        ORELSE                                  :status is not down
         CLHI   R0,CSTCED                       :is status "CLOSED"?
         IFF(E,THEN)
          LA    R8,QUEST,,
          LA    R9,HOSTIN,,
          LHI   R10,4
          MVS(R8,R9,R10,R11)
          LA    R8,CLEDIN,,
          LA    R9,STATIN,,
          LHI   R10,6
          MVS(R8,R9,R10,R11)
         ORELSE                                 :status is not "CLOSED"
          LA    R9,HOSTIN,,
          LHI   R10,NC.HST
          SPAC(R9,R10,R11)
          L     R2,OBCHSP,R1                    :ptr to current STHTAB
          LA    R8,HSTNUM+1,R2                  :address of host # string
          LA    R9,HOSTIN,,
          LB    R10,HSTNUM,R2
          MVS(R8,R9,R10,R11)                    :move host # string to banner
          CLHI  R0,CSTUP
          IFF(E,THEN)
            LA  R8,UPIN,,                       :STATS CIRCUIT IS UP
            LA  R9,STATIN,,
            LHI R10,6
            MVS(R8,R9,R10,R11)                  :move status to the banner

          ORELSE                                :status is not up
            CLHI        R0,CSTWPS
            IFF(E,THEN)
              LA        R8,WTCTIN,,             :STATS CIRCUIT IS WAITING
              LA        R9,STATIN,,             :FOR PSEUDO-NEEDLE
              LHI       R10,6
              MVS(R8,R9,R10,R11)
            ORELSE                              :status is not CSTWPS
              CLHI      R0,CSTWRI
              IFF(E,THEN)                       :STATS CIRCUIT IS WAITING
                LA      R8,WAITIN,,             :FOR RCVR ID
                LA      R9,STATIN,,
                LHI     R10,6
                MVS(R8,R9,R10,R11)
              ORELSE
               CLHI     R0,CSTCNG               :is status "CLOSING"?
               IFF(E,THEN)
                LA      R8,CLNGIN,,
                LA      R9,STATIN,,
                LHI     R10,6
                MVS(R8,R9,R10,R11)
               ORELSE
                CLHI    R0,CSTNWR
                IFF(E,THEN)                     :STATS CIRCUIT HAD WRITE ERR
                  LA    R8,UNWRIN,,
                  LA    R9,STATIN,,
                  LHI   R10,6
                  MVS(R8,R9,R10,R11)
                ORELSE
                 CLHI   R0,CSTDNG               :is status "DROPPING"?
                 IFF(E,THEN)
                  LA    R8,DRPIN,,
                  LA    R9,STATIN,,
                  LHI   R10,6
                  MVS(R8,R9,R10,R11)
                 ORELSE                         :status is wrong
                  CLHI   R0,CSTLGI              :is status "logging in"
                  IFF(E,THEN)
                    LA    R8,LOGGIN,,
                    LA    R9,STATIN,,
                    LHI   R10,6
                    MVS(R8,R9,R10,R11)
                  ORELSE                        :status is wrong
                    LIS   R8,1
                    AHM   R8,ERRSTA,,           :increment error count
                    LA    R8,STATWR,,
                    LA    R9,STATIN,,
                    LHI   R10,6
                    MVS(R8,R9,R10,R11)
                  ENDIF
                 ENDIF
                ENDIF
              ENDIF
             ENDIF
            ENDIF
          ENDIF
         ENDIF
        ENDIF
 
 
: PUT IN CRASH COUNTS AND CODES
:
	LA	R8,CRSHNM,,
	LIS	R9,1
	LO	CRASH
	LA	R10,CRSHCT+1,,
	FO	CRASH
	CALL(BINHEX,MN2SAV)
:
	LA	R8,CRSHCD,,
	LIS	R9,1
	LA	R10,CRASHC+1,,
	CALL(BINHEX,MN2SAV)
:
:
: INDICATE A 'SLOW' (I.E. FULL) UPDATE TO MNUPDT
:
	LCS	R2,1
	INVOKE(MNUPDT)	:CONTINUE UPDATING SCREEN
:
:
		:CONTROL L - NEW PAGE
	PROC(MNUPDT)
:
: MNUPDT - UPDATE THE MONITOR SCREEN
:
:     R2 < 0 ==> UPDATE ENTIRE RES INFO (FULL UPDATE)
:     R2 >= 0 ==> RES NUM TO UPDATE
	CHAIN(MN3SAV)
:
:	LOOP TO PRINT OUT MAG TABLE
:
	LR	R6,R2	:SAVE THE RES NUMB UPDATE INDICATOR
	JL	ALMAG	:JUMP IF FULL UPDATE
CALCMG	LR	R3,R2	:GET RESNUM
	CVTRES(R3,MN3SAV)	:CVT RES NUMBER TO MAGTAB ENTRY NUMBER
	LHI	R4,MAGLNG
	MR	R2,R4	:CALCULATE LENGTH OF MAGTAB ENTRY
	LA	RUBLK,MAGTAB,R3,	:AND GET ADDRESS IN RUBLK
	LR	R3,R6	:CALCULATE MONITOR SCREEN ADDRESS
	CVTRES(R3,MN3SAV)	:CVT RES NUMBER TO MAGTAB ENTRY NUMBER
	LHI	R4,$A80	:LENGTH OF MONITOR SCREEN LINE
	MR	R2,R4	:RESNUM * LINE LENGTH
	LA	R11,MONMAG,R3,
	JFS	MAGMON	:UPDATE SCREEN
ALMAG	LA	R11,MONMAG,,
	LIS	R7,NMAG	:LOOP COUNTER
        LIS     R12,0   :AIRLINE UP FLAG. INIT TO 0 (FALSE)
	LI	RUBLK,MAGTAB
:		PORT NUMBER
:
:	SHOW PORT NUMBER WHERE MAG IS LOGGED ON
:
MAGMON	LA	R10,MAGPRT+1,RUBLK	:GET ADDRESS OF PORT FIELD - 2ND BYTE
	LIS	R9,1
	LI	R8,MNPORT,R11
	CALL(BINHEX,MN3SAV)
:	MOVE IN RES CODE
	LH	R2,MAGRES,RUBLK
	STB	R2,MNCODE+1,R11
	SRL	R2,8
	STB	R2,MNCODE,R11
:	MOVE STATUS IN OUTPUT AREA
	LH	R2,MAGSTA,RUBLK
        CLHI    R2,RESUP        :IS THIS RES UP?
        IFF(E,THEN)             :   YES
          LIS     R12,1         :FLAG THAT A RES IS UP
        ENDIF
	STB	R2,MNSTAT+1,R11
	SRL	R2,8
	STB	R2,MNSTAT,R11
:	STATUS TIME AND DATE
:
	L	R3,MAGTIM,RUBLK
	LHI	R4,13
	LI	R5,MNDATE,R11
	CALL(DATIME,MN3SAV)
:
:
: CHECK FOR FULL OR PARTIAL UPDATE
:
	LR	R6,R6	:LESS THAN ZERO MEANS FULL UPDATE
	JLFS	NMSGS	:JUMP IF FULL UPDATE
	LIS	RRETC,0	:PARTIAL UPDATE IS DONE
	RETURN(R1)
:
:	NUMBER OF MESSAGES (BOTH IN AND OUT)
:
NMSGS	L	R3,MGTMGU,RUBLK
	A	R3,MGTMGM,RUBLK
	LIS	R4,5
	LI	R5,MNNMSG,R11
	CALL(BINDEC,MN3SAV)
:
:	AVERAGE USER MESSAGE LENGTH
:
	SR	R2,R2
	L	R3,MGTUMG,RUBLK
	JEFS	.+6
	D	R2,MGTMGU,RUBLK
	LIS	R4,5
	LI	R5,MNLUMG,R11
	CALL(BINDEC,MN3SAV)
:
:	AVERAGE MAG MESSAGE LENGTH
:
	SR	R2,R2
	L	R3,MGTMMG,RUBLK
	JEFS	.+6
	D	R2,MGTMGM,RUBLK
	LIS	R4,5
	LI	R5,MNLMMG,R11
	CALL(BINDEC,MN3SAV)
:
:	AVERAGE RESPONSE TIME FOR THE INTERVAL
:
	L	R3,MGIRSP,RUBLK
	JEFS	NOCALC	NO NEED TO DO THIS IF ZERO
: MULTIPLY THE AVERAGE RESPONSE TIME BY THE
: FRACTION 5/3 TO GET THE ANSWER IN MILLISECONDS.  
: REMEMBER THE FASTC WORKS IN 600THS OF A SECOND, NOT MILLISECONDS
	LIS	R5,$A5
	MR	R2,R5	 NOW GOT THE DIVIDEND IN R3
	L	R8,MGIMGM,RUBLK	:NUM OF MSGS TO MAG
	S	R8,MGIRST,RUBLK	:LESS THOSE WITHOUT RESPONSE TIMES
	LIS	R5,3
	MR	R4,R8	DIVISOR IN R5
	DR	R2,R5	RESPONSE TIME IN MILLISEC IN R3
NOCALC	LIS	R4,5
	LI	R5,MNRSPI,R11
	CALL(BINDEC,MN3SAV)
:
:	AVERAGE RESPONSE TIME FOR THE TOTAL AVAILABLE TIME
:
	L	R3,MGTRSP,RUBLK
	JEFS	NCALC2
	LIS	R8,$A5
	MR	R2,R8	:NUMERATOR IN R3
	L	R5,MGTMGM,RUBLK	:NUM OF MSGS TO MAG
	S	R5,MGTRST,RUBLK	:LESS NUM OF MSGS W/O RESPONSE TIMES
	LIS	R9,$A3
	MR	R8,R5	DIVISOR IN R9
	DR	R2,R9
NCALC2	LI	R5,MNRSPT,R11
	LIS	R4,6	: LENGTH OF OUTPUT FIELD
	CALL(BINDEC,MN3SAV)
:
:	PRINT OUT INTERVAL RESET COUNTS
:
	LIS	R4,5
	L	R3,MGIRST,RUBLK
	LA	R5,MNRSTI,R11
	CALL(BINDEC,MN3SAV)
:
: PRINT OUT TOTAL RESET COUNTS
	L	R3,MGTRST,RUBLK
	LA	R5,MNRSTT,R11
	CALL(BINDEC,MN3SAV)
:
: FINISH LOOPING
:
	AHI	RUBLK,MAGLNG
	AHI	R11,80	:LENGTH OF AN OUTPUT LINE
	SIS	R7,1
	JG	MAGMON
:
: CHECK IF ANY MAGS ARE UP.  IF NOT, SHUT THIS MATS
:
        LHL     R3,SOFSHT       :IS SOFT SHUT ENABLED?
        IFF(N,THEN)             :   YES
          LR      R12,R12       :ARE ANY MAGS UP?
          IFF(E,THEN)           :IF =0, NO MAGS UP
            LHI     R12,SHTMAG  :SHOW MATS SHUT BECAUSE NO MAG CIRCUITS UP
            SBT     R12,SHTMSK,,
            CALL(SHUTIT,MN3SAV) :SHUT MATS (IF NOT ALREADY SHUT!)
          ORELSE
            LHI     R12,SHTMAG  :SHOW MATS NO LONGER SHUT BECAUSE NO MAG CIRCUITS UP
            RBT     R12,SHTMSK,,
            CALL(ANSWIT,MN3SAV) :ANSWER MATS (IF NOT ALREADY ANSWERS
                                :AND NOT SHUT BY MONITOR OR PROGRAMMER)
          ENDIF
        ENDIF

	LIS	RRETC,0
	RETURN(R1)
:
:  MONITOR SCREEN
: VARIABLES FOR THE RECEIVER HOST STATUS
QUEST   AC      /????/                  
UPIN    AC      /UP    /
UNWRIN  AC      /UNWRIT/
WAITIN  AC      /WAITID/
WTCTIN  AC      /WAITCT/
STATWR  AC      /BADSTA/
CLEDIN  AC      /CLOSED/
DRPIN   AC      /DROPNG/
CLNGIN  AC      /CLOSNG/
LOGGIN  AC      /LOGGNG/
:
: LINE ONE
	SEG	2
        GL      ANSWMS,SHUTMS,SHUTPL
SHUTMS  SC      !* SHUT *    !
SHUTPL  SC      !* SHUT+*    !
ANSWMS  SC      !* ANSWERED *!
MONORG	EQ	.
MONITR	XC	9BA7	:SET PROTECT OFF
	XC	9E	:POSITION CURSOR HOME
	XC	9BA9	:START WRITE PROTECT
LNSTRT	EQ	.	:START OF LINE
        IF      \ITC
        AC      /D A T S Vers /
        ELSE
         IF     \PARSI
         AC     /M.A.T.S. Vers /
         ELSE
	  IF	\MARSP
	  AC	/MARS +   Vers /
	  ELSE	   
           IF     \FLTLIN
           AC     /FlightLine Vers /
           ELSE

            AC     /PARS II Vers /
           EI
          EI
         EI
	EI

PLACE	EQ	$8 1000
	IF	((VERSIO/PLACE)&7)
	BC	((VERSIO/PLACE)&7)+$00B0
	ELSE
	AC	/ /
	EI
	BC	((VERSIO/$8100)&7)+$00B0
	AC	/./
	BC	((VERSIO/$810)&7)+$00B0
	BC	(VERSIO&7)+$00B0
	AC	/  startup /
DATSTT	AC	/29DEC99/
	AC	/ /
TIMSTT	AC	/XX:XX/
	AC	/  time /
DATNOW	AC	/29DEC99/
	AC	/ /
TIMNOW	AC	/XX:XX/
	AC	/ HOST:/
        BC      (HOSTNO/$A1000)+$00B0
        BC      ((HOSTNO-HOSTNO/$A1000*$A1000)/$A100)+$00B0
	BC	((HOSTNO-HOSTNO/$A100*$A100)/$A10)+$00B0
	BC	((HOSTNO-HOSTNO/$A10*$A10))+$00B0
:	PAD LINE OUT TO 80 BYTES
	IF	(80-(.-LNSTRT))
	NOLIST
	RE	80-(.-LNSTRT)
	AC	/ /
	ER
	LIST
	EI
:	LINE 2
LNSTRT	EQ	.
	AC	/SYSLOAD: users /
LGUSR	AC	/XXX/	: #OF LOGONS + DISC.
	AC	$/$
MORUSR	AC	/XXX/	: #OF USER PORTS STILL AVAIL
	AC	/ monitors /
NUMMON	AC	/XX/
	AC	/ dbgers /
NUMDBG	AC	/XX /
        GL      HNGFRE
        IF      \ITC                            :ITC MONITOR TERMINAL
        AC      / /                             :IS UNABLE TO PROVIDE
HNGFRE  AC      / /                             :BLINKING CHARACTER
        AC      / /
        AC      / RB /
RBUSED  AC      /XXXX/
        AC      $/$
FREERB  AC      /XXXX/
        AC      /  AUT /
AUTUSE  AC      /XXX/
        AC      $/$
FREAUT  AC      /XXX/
        IF      80-(.-LNSTRT)
        NOLIST
        RE      80-(.-LNSTRT)
        AC      / /
        ER
        LIST
        EI
 
        ELSE
        XC      9BDE                    :make next character blink
HNGFRE  AC      / /
        XC      9BDE
        AC      / RB /
RBUSED  AC      /XXXX/
        AC      $/$
FREERB  AC      /XXXX/
        AC      / AUT /
AUTUSE  AC      /XXX/
        AC      $/$
FREAUT  AC      /XXX/
        IF      (80-(.-LNSTRT)+2)        :the "+2" is for 2 escape chars around hngfre
        NOLIST
        RE      80-(.-LNSTRT)+2)
        AC      / /
        ER
        LIST
        EI
 
        EI
        :LINE 3
: SYSTEM ERROR MESSAGES
LNSTRT	EQ	.
        GL      HSTATE
HSTATE  AC      /* ANSWERED * / :SHUT OR ANSWERED STATE
MATVER  AC      /                           /             :27 SPACES RESERVED FOR V.LUD.
        AC      / RCVR /
HOSTIN  AC      /     /
STATIN  AC      /XXXXXX /
	AC	/CRSHCT /
CRSHNM	AC	/XX /
	AC	/CRSHCD /
CRSHCD	AC	/XX /
	IF	(80-(.-LNSTRT))
	NOLIST
	RE	(80-(.-LNSTRT))
	AC	/ /
	ER
	LIST
	EI
: LINE 4  - HEADINGS
LNSTRT	EQ	.
	AC	/port RES status since/
	AC	$     #msg l'msg(usr/MAG) resp(intv/ttl)$
	AC	$ RESET(intv/ttl) $
	IF	(80-(.-LNSTRT))
	NOLIST
	RE	80-(.-LNSTRT)
	AC	/ /
	ER	
	LIST
	EI
:
:	END OF FIXED PORTION OF SCREEN
:
: NOW ALLOCATE ENOUGH SPACE FOR ALL THE MAGs
MONMAG	EQ	.
	RE	NMAG
	AC	/                                     /
:			37 SPACES IN ABOVE STRING
	AC	$/$
	AC	/              /
:			14 SPACES IN ABOVE STRING
	AC	$/$
	AC	/               /
:			15 SPACES IN ABOVE STRING
	AC	$  /         $
	ER
:	FINISH SCREEN WITH PROTECT OFF CONTROL CHARACTERS
:		BUT FIRST GIVE ONE EXTRA LINE TO DELINEATE SCREEN
	RE	4
	AC	/                    /
:	ABOVE LINE HAS 20 SPACES
	ER
	XC	9BA8	:END WRITE PROTECT
	XC	9BA6	:SET PROTECT ON
LENMON	EQ	.-MONORG
:
: TEMPLATE FOR LINES OF MAG
:
OLDORG	EQ	.
	ORG	0
	BS	1	:LEADING SPACES
MNPORT	BS	2	:PORT NUMBER
	BS	2	: SPACE
MNCODE	BS	2	: RES CODE
	BS	1
MNSTAT	BS	2	: STATUS
	BS	1
MNDATE	BS	7	:DDMMMYY
	BS	1
MNTIME	BS	5	: HH:MM
	BS	1
MNNMSG	BS	5	: NUMBER MSG
	BS	2
MNLUMG	BS	5	: L'MSG/USR
MNSLH1	BS	1	: /
MNLMMG	BS	5	: L'MSG/MAG
	BS	4
MNRSPI	BS	5	: RESP/INTVL
MNSLH2	BS	1	: /
MNRSPT	BS	6	: RESP/TTL
	BS	6
MNRSTI	BS	5	: INTERVAL RESET  OUNT
MNSLH3	BS	1	: /
MNRSTT	BS	5	: TOTAL RESET COUNT
:
:
:
:	END OF TEMPLATE
	ORG	OLDORG
	EM

:(MATS.P2)P2MISC.S01
:       Copied by chen from (mats.p2)P2MISC.15E on 1/21/87
:       made changes in INIMAG for new auto_sign_off structures
: (MATS.P2)P2MISC.15E
:    Copied by Gauci from .14L    30-jan-85
:    Added initialization of MGPRMP.

: (MATS.P2)P2MISC.14L
:    Copied by Cardini from (MATS.P2)P2MISC.13R on 10/24/83
:    in order to add two statements to load MCSRIN field from MAGCON table
:    and store it in MGSRIN field of MAGTAB.
:
: (MATS.P2)P2MISC.13R
:    Copied by Cheung from (MATS.P2)P2MISC.12E on 11/22/82.
:    Added PNR security indicator to MAGTAB.

: (MATS.P2)P2MISC.12E
: Copied by Gauci from (mats.p2)p2misc.11l  on 9/3/82
: Added Common_Language_Bypass_Character to Magtab

: (MATS.P2)P2MISC.11L
: COPIED BY VAYSBURD FROM (MATS.P2)P2MISC.10J ON 11.24.81
: ADDED CODE WHICH WILL SET RECEIVER STATUS TO "CLOSED" IF IT IS
: "CLOSING" AND TO "DOWN" IN ALL OTHER CASES.
: (MATS.P2)P2MISC.09W Fixed INITPT bug on 8/26/81
:
: (MATS.P2)P2MISC.08W
: Copied from (MATS.P2)P2MISC.07F on 08/20/81
: Added MATS STATS changes
:
: (MATS.P2)P2MISC.07F
:    Copied by Bonnell from (MATS.P2)P2MISC.06K.  1/27/81
:    Changed INIMAG to set up new field--MAGPIL.

:(MATS.P2)P2MISC.06K
: COPIED FROM (MATS.P2)P2MISC.05L ON 1/14/81 BY KIRK ADAMS FOR THE
: PURPOSE OF PERFORMING CHANGES ON THE INIMAG PROCEDURE.

 :(MATS.P2)P2MISC.05L  COPIED FROM (MATS.P2)P2MISC.04S  ON 07.01.81
:BY SVETLANA VAYSBURD IN ORDER TO ADD  ROUTINE  COMSTR, WHICH COMPARES
: TWO STRINGS OF CHARACTERS.

: (MATS.P2)P2MISC.04S copied from (MATS.P2)P2MISC.03S on 10-23-80
: by Steve Gimnicher in order to add routines SHUTIT and ANSWIT
: for Soft Shut implementation.
: -------------------------------------------------------------
: (STEVEG)P2MISC.03S copied from (MATS.DEV)P2MISC.01F on 10-13-80
: by Steve Gimnicher in order to modify INIMAG and add SRCHMC for
: Monitor Screen Formatter implementation.
:
:MISC.NAD  Contains miscellaneous routines called by IMATS.

	MO	.,MISC
	LO	MAIN
	RA	$0 0A


:
:	INIT PORT
:
	PROC(INITPT)
	CHAIN(IPSV)
	CALL(CIB,IPSV)
	LA	R2,VALDTR	:SET JUMP ADDRESS TO VALIDATOR
	CALL(SETJMP,IPSV)
	LIS	R2,0
	LR	R3,R0		:SETJMP RETURNS 4*PORT NUMBER
	ST	R2,P2U,R3	:CLEAR P2U ENTRY
	ST	R2,BREAK,R3	:SET BREAK ARRAY TO DEFAULT (CR ONLY)
				:RELEASE AUB/AMT/MAG ENTRY IF ONE EXISTS
        LA      R2,PSMBRK,,             : Make port break on pseudo needle also
        ST      R2,MBREAK,R3,           :

	LR	R1,R1		:IS THERE AN AUB (ETC.)?
	JLE	NOAUB		:SKIP IF NOT.
:
: RESET THE GLOBAL AND MONITOR TRACE BITS FOR THIS PORT
:
	LH	R2,AUBPRT,RUBLK
        LR      R4,R2           : (save for later)
	JE	RESETP
	AIS	R2,TRCPRT	:ADD IN TRACE PORT OFFSET
	RBT	R2,SYSTRC,,	:RESET THE GLOBAL BIT
INDX	EQ	0	:INDEX FOR AMTTAB TABLE
	RE	NMON	:REPEAT ONCE FOR EACH MONITOR
	RBT	R2,AMTTAB+INDX*AMTLNG+AMTTRC,,
INDX	EQ	INDX+1
	ER
RESETP	LIS	R2,0
	STH	R2,AUBPRT,R1	:CLEAR PORT NUMBER
	LB	R2,AUBTYP,R1	:GET USER TYPE
	CLHI	R2,LUDNUR	:NORMAL USER?
	JEFS	IPAUB		:YES, RELEASE AUB
	CLHI	R2,LUDPUR	:PROGRAMMER?
	JN	IPNAUB		:NO, SKIP
	CALL(CLRDBG,IPSV)
IPAUB	LIS	R3,0
	STB	R3,AUBTTY,R1	:CLEAR TERMINAL TYPE
	LHL	R3,AUBSTA,R1	:GET STATUS
	THI	R3,AUBDSC+AUBHLD : TEST IF DISC OR HOLD
	JEFS	IPAUB2		:NO
        LHI     R3,SVATIM       :SHOULD THE AUB BE SAVED?
        JN      NOAUB           :YES
IPAUB2  CLHI    R2,LUDNUR       :NORMAL USER?
	JN	IPAUB1		:NO, DON'T TOUCH NUMUSR
	LCS	R2,1
	AM	R2,NUMUSR	:DECREMENT NUM-USERS
 
IPAUB1  STH     R4,AUBPRT,R1    :(put port# back temporarily)
        CALL(RELAUB,IPSV)
	J	NOAUB

IPNAUB	CLHI	R2,LUDMUR	:MONITOR?
	JN	IPMSC		:NO, MIGHT BE MSC
	CALL(RELAMT,IPSV)
	J  	NOAUB

IPMSC   CLHI    R2,MSCTYP               : Check if mats stats circuit CCB
        JN      IPRES                   : No.  Must be res sys
        LHL     R2,CCBSTA,R1,           :GET RSVR STATUS
        CLHI    R2,CSTCNG               :IF STATUS ="CLOSING"?
        IFF(E,THEN)
          LHI   R2,CSTCED
          STH   R2,CCBSTA,R1,           :SET STATUS TO "CLOSED"
        ORELSE
          LHI   R2,CSTDWN               :STATUS IS NOT "CLOSING"
          STH   R2,CCBSTA,R1,           :SET STATUS TO "DOWN
        ENDIF
        L       R2,FASTC,,              :
        ST      R2,CCBTIM,R1,           :

IPRES	EQ	.

NOAUB	LIS	R0,0		:NO TIMEOUT
	RETURN(R2)


:SETJMP  Sets jump address for process.
:        Expects jump addr. in R2.
:        Returns jump table offset in R0.

PROC(SETJMP)
	LR	R1,R1		:SET CONDITION CODES
	JL	SETJ1		:JUMP IF NOT AUT/AMT POINTER
	LH	R1,AUBPRT,R1	:GET PORT NUMBER
	JFS	SETJ2
SETJ1	XI	R1,-1		:COMPLEMENT R1
	AIS	R1,1		:ADD 1 (TWO'S COMPLEMENT)
SETJ2	SLHLS	R1,2		:TABLE OFFSET FOR PORT
	ST	R2,PROCESS,R1
	LR	R0,R1
	RETURN(R1)


:CLEAR  Sets all bytes of a data area to a specified value.
:    Expects data area addr. in R2, number of elements in R3,
:       byte value in R4.

PROC(CLEAR)
CLINT1	STB	R4,0,R2
	AIS	R2,1		:increment loc. pointer
	SIS	R3,1		:decrement counter
	JGBS	CLINT1		:loop until done
	RETURN(R2)


:TFR  Procedure to transfer a byte oriented data area from one
:     location to another.  The transfer is done backwards from
:     the end of the data area.  At least one byte will be transferred,
:     even if the count is 0 or negative.  These were done for the sake
:     of speed.
:     Arguments: R2 - Addr to transfer from
:                R3 - Addr to transfer to
:                R4 - Number of bytes to transfer

PROC(TFR)
	SIS	R4,1
TFRLP	LB	R0,0,R2,R4
	STB	R0,0,R3,R4
	SIS	R4,1
	JGEBS	TFRLP
	RETURN(R2)



: INIMAG - INITIALIZE THE MAGTAB BLOCK
	PROC(INIMAG)
        LA      R1,MAGCON,,     :START OF MAG CONSTANT TABLE
        LA      R2,MAGTAB,,     :START OF MAG TABLE
        LR      R6,RSAVE        :SAVE RSAVE REGISTER
        LIS     R8,0            :ZERO OUT REGISTERS FOR STM
        LIS     R9,0
        LIS     R10,0
        LIS     R11,0
        LIS     R12,0
        LIS     R13,0
        LIS     R14,0
        LIS     R15,0

        LHI     R4,NMAG         :NUMBER OF MAGCON & MAGTAB ENTRIES
        DO(WHILE,G)             :REPEAT ONCE FOR EACH MAG CIRCUIT
        STH     R15,MAGPRT,R2   :ZERO PORT #
        LH      R3,MCRESC,R1,   :GET RES CODE FROM MAGCON
        STH     R3,MAGRES,R2,   :STORE RES CODE IN MAGTAB
        LIS     R3,LUDRUR       :MAG BLOCK TYPE
        STB     R3,MAGTYP,R2,   :STORE BLOCK TYPE IN MAGTAB
        LHI     R3,RESNA        :INITIAL RES STATUS - 'NA'
        STH     R3,MAGSTA,R2,   :STORE RES STATUS IN MAGTAB
        L       R3,GMT,,        :CURRENT TIME
        ST      R3,MAGTIM,R2,   :STORE IN MAGTAB
        LH      R3,MCRESN,R1,   :GET RES NUMBER FROM MAGCON
        STH     R3,MAGNUM,R2,   :STORE RES NUMBER IN MAGTAB
        LH      R3,MCLINS,R1,   :GET LINE SIZE FROM MAGCON
        STH     R3,MAGLSZ,R2,   :STORE LINE SIZE IN MAGTAB
        LB      R3,MCDELY,R1,   :GET RESET DELAY VALUE FROM MAGCON
        STB     R3,MAGDLY,R2,   :STORE DELAY VALUE IN MAGTAB
        LB      R3,MCSCRN,R1,   :GET USER SCREEN TYPE FROM MAGCON
        STB     R3,MAGSCN,R2,   :STORE SCREEN TYPE IN MAGTAB
        L       R3,MCXLAT,R1,   :GET TRANSLATION TABLE ADDR FROM MAGCON
        ST      R3,MAGXLT,R2,   :STORE TRANSLATION TABLE ADDR IN MAGTAB
        LB	R3,MCSRIN,R1,	:GET SERVICE INDICATOR FROM MAGCON
	STB	R3,MGSRIN,R2,	:STORE SERVICE INDICATOR IN MAGTAB
        LB      R3,MCLN,R1,     :TRANSFER LINE NUMBER
        STB     R3,MAGLN,R2,    
        LB      R3,MCSPT,R1,    :TRANSFER SUPPORT PTR INDICATOR
        STB     R3,MAGSPT,R2,
        LB      R3,MCPFD,R1,    :TRANSFER PTR FIELD DELMTR
        STB     R3,MAGPFD,R2,
        LB      R3,MCNIC,R1,    :TRANSFER COUNT OF DIGITS IN IND CODE
        STB     R3,MAGNIC,R2,
        L       R3,MCFST,R1,    :TRANSFER ^FIELD SPEC TABLE
        ST      R3,MAGFST,R2,
        LH      R3,MCPIL,R1,    : Transfer printer ID length
        STH     R3,MAGPIL,R2,
        LB      R3,MCBCHR,R1,   :Transfer Command_Language_Bypass_Char
        STB     R3,MGBCHR,R2,
        L       R3,MCPRMP,R1,   :Transfer Prompt String Pointer
        ST      R3,MGPRMP,R2,
        LB      R3,MCPNR,R1,    :Transfer PNR security indicator
        STB     R3,MGPNR,R2,    
 
        IF      MULTIA
	LHI	R7,480
CLIA0	STM	R8,MAGITA,R2,R7	:Clear IA-TA bits
	SHI	R7,32
	JGEBS	CLIA0
        ELSE
        STM     R14,MAGITA,R2   ZERO OUT IA-TA BITS
        EI
        LH      R7,MAGNUM,R2,   : GET RES NUMBER
        LH      R7,RESAOF,R7,R7 : get offset to RESAAA table
        L       R7,RESAAA+SOFPTR,R7,     :get sign_off AAA table pointer
        JLE     NOAAA0          : NOauto_sign_off for this res
        LI      R3,-1           : INIT IA_TAS TO NOT FREE
        JFS     AAA0
NOAAA0  LIS     R3,0            : INIT IA_TAS TO FREE
AAA0    IF      MULTIA
        LHI     R7,508
        ELSE
        LHI     R7,4
        EI
CLFA0   ST      R3,MAGFRE,R2,R7         : SHOW IA_TA NOT FREE
        SIS     R7,4
        JGEBS   CLFA0
        STM     R8,MGICMD,R2   :ZERO OUT STATISTICS
        STM     R8,MGIMGM,R2    :FIELDS
	STM	R12,MGIBBC,R2
: INCREMENT TO NEXT RES

        AHI     R2,MAGLNG
        AHI     R1,MCLNG
        SIS     R4,1            :NUMBER OF RES' REMAINING
        ENDDO

	LR	RSAVE,R6
	RETURN(R1)







:LOGUSR  LOG-USER  (Called from command handler)

PROC(LOGUSR)
CHAIN(LOGSAV)
	TRLOG(ULOGOF,LOGSAV)
	TRPORT(ULOGOF,LOGSAV)
	CALL(UNLKKB,LOGSAV)
        LIS     R2,DISLOG               : Set disconnect reason to
        STB     R2,AUBDRN,RUBLK,        : log out in AUB
	LI	R2,GDBYE	:GOOD BYE...
	INVOKE(ZAPPRT)


:DSCUSR  DISCONNECT-USER  (Called when zappers received)
:             Disconnect commands must be handled differently.

PROC(DSCUSR)
CHAIN(DSCSAV)
	TRLOG(UDISC,DSCSAV)
	TRPORT(UDISC,DSCSAV)
	LIS	R2,AUBDSC
	STH	R2,AUBSTA,R1	:SET STATUS TO 'DISCONNECTED'
	LIS	R4,0
	STB	R4,AUBSCN,RUBLK	:CLEAR OUT SCREEN FORMAT TYPE
	L	R2,GMT,,	:SAVE TIME
	ST	R2,AUBTIM,R1
        LB      R13,AUBTYP,R1   :GET USER TYPE
        CLHI    R13,LUDMUR      :MONITOR USER?
        JE      DSCRET          :YES...SKIP
	L	R2,AUBARB,RUBLK	:GET ARB
	JE	DSCRET		:NO ARB
	L	R3,RBIATA,R2	:GET RES IA TA
	CALL(BINSCH,DSCSAV)
	LR	RRETC,RRETC	:TEST RETCODE
	JNFS	DSCRET		:NOT FOUND!!
:MAY WANT TO CRASH OR SOMETHING HERE
	CALL(R2UDEL,DSCSAV)
DSCRET	INVOKE(INITPT)
        PROCS(COMSTR,$00D)
        CHAINS(COMSAV,$00D)
: THIS ROUTINE IS CALLED TO COMPARE TWO STRINGS OF CHARACTERS. IT
:TERMINATES WHEN THE COUNTER OF CHARACTERS IN THE FIRST STRING IS EMPTY.
:
:       INPUT- R2-ADDRESS OF THE FIRST STRING
:               R3-COUNTER OF CHARACTERS IN THE FIRST STRING.
:               R4-ADDRESS OF THE SECOND STRING.
:       OUTPUT- R0=0-IF STRINGS MATCH.
:               R0=1- IF DON'T MATCH.
:
:
        DEBUGM(ENTERING COMSTR,DBGPRT,DALL,COMSAV,$00D)
:
        LIS     RRETC,0         :INITIALIZE RRETC
        SIS     R3,1
        DO(WHILE,GE)      :COMPARE TILL COUNTER(R3)>=0
        LB      R6,0,R4,R3      GET BYTES FROM THE SECOND STRING
        CLB     R6,0,R2,R3      :COMPARE WITH APPROPRIATE BYTES
                                :IN THE SECOND STRING
        IFF(N,THEN)
          LIS   RRETC,1
          EXITDO                :IF DON'T MATCH-EXIT,RRETC=1
        ENDIF
        SIS     R3,1
        ENDDO                   :IF MATCH-RRETC=0, EXIT
        RETURN(R2)


        PROC(SRCHMC)
:
: This routine, given a res number in R2, searches MAGCON sequentially
: looking for a match in the res number.  If found, it returns the
: corresponding MAG Table entry number in R2.  If not found, it
: crashes with a crash code of 2F.
:
        LA      R5,MAGCON,,     : MAGCON starting address
SRCH00
        CLH     R2,MCRESN,R5,   : Do res numbers match?
        JE      SRCH05          : YES

        AI      R5,MCLNG        : Next MAGCON entry
        CLI     R5,MCEND        : Have we reached the end of MAGCON?
        JL      SRCH00          : NO - loop

        JAL     R10,CRASH,,     : YES - crash....
        BC      0,0,4*RLINK,BADMGC

SRCH05
        LB      R2,MCMENT,R5,   : Res number match. Return MAG Table
                                : entry number
        RETURN(R3)
        PROC(SHUTIT)
        CHAIN(SHUTSV)
:
: This routine will shut MATS if not already shut.  It will also
: update the host state in the monitor.
:
        DEBUGM(entering SHUTIT,DBGANC,DALL,SHUTSV,$01)
        LB      R2,SHTFLG,,     : Is host already shut?
        IFF(E,THEN)             : If = 0, then no.
          CHHOST(2)             : Shut it
          LIS     R2,1          
          STB     R2,SHTFLG,,   : Show MATS is shut
          AHM     R2,NUMSHT,,   : Increment shut counter
        ENDIF

        LA      R2,HSTATE,,     : Addr of state location on monitor
        LHI     R4,SHTMON       : Did a monitor or programmer do a shut?
        TBT     R4,SHTMSK,,
        IFF(E,THEN)             : If = 0, shut automatically
          LA      R4,SHUTMS+1,, : Normal shut message
          LB      R3,SHUTMS,,   : Length of shut message (SC format)
        ORELSE                  : Shut by monitor or programmer
          LA      R4,SHUTPL+1,, : Special shut message (has "+")
          LB      R3,SHUTPL,,   : Length of shut message (SC format)
        ENDIF

        SIS     R3,1            : Decrement for loop

          DO(WHILE,GE)          : Move message into monitor from right to left
          LB      R5,,R4,R3     : Get a message character
          STB     R5,,R2,R3     : Store in monitor screen
          SIS     R3,1          : Next character
          ENDDO

        RETURN(R1)

        PROC(ANSWIT)
        CHAIN(ANSWSV)
:
: This routine will answer MATS if not already answered, and if it
: isn't being held shut by any other process (SHTMSK must = 0
: before this routine will answer MATS.  It will also update
: the host state in the monitor.
:
        DEBUGM(entering ANSWIT,DBGANC,DALL,ANSWSV,$01)
        LB      R2,SHTFLG,,     : Is host already answered?
        IFF(N,THEN)             : If \= 0, then no.
          LH      R2,SHTMSK,,   : Does some other process still want MATS shut?
          IFF(E,THEN)           : If = 0, then no. OK to answer it
            CHHOST(0)           : Answer it
            LA      R2,HSTATE,, : Addr of state location on monitor
            LA      R4,ANSWMS+1,,:Start of answer message
            LB      R3,ANSWMS,, : Length of answer message (SC format)
            SIS     R3,1        : Decrement for loop

              DO(WHILE,GE)      : Move message into monitor from right to left
              LB      R5,,R4,R3 : Get a message character
              STB     R5,,R2,R3 : Store in monitor screen
              SIS     R3,1      : Next character
              ENDDO

            LIS     R2,0
            STB     R2,SHTFLG,, : Show MATS is answered
            LIS     R2,1
            AHM     R2,NUMANS,, : Increment answer counter
          ENDIF
        ENDIF
        RETURN(R1)
	EM

: (MATS.P2)ATTPRF.03B
:    Copied by Beecher from (MATS.P2)ATTPRF.02S on 4/6/82
:    There is a new flag, TIBPRI, which is TRUE if a terminal
:    has printer capability.  The SETPTR routine will now
:    look at the flag instead of looking at the terminal type.
:
: (MATS.P2)ATTPRF.02S
:    Copied by Gimnicher from (MATS.P2)ATTPRF.01L
:    Added check to SETPTR for terminal type.

:File ATTPRF was created on 01.06.81 by SVETLANA VAYSBURD for ATTACH
:PRINTER IMPLEMENTATION.
:
        PROCS(ATTCMD,$00D)
        CHAINS(ATTSAV,$00D)
:
:This routine is called immideatly after the ATTPRT command is
:recognized via the command table.It calls SETPRT to attempt to
:establish the printer.If this routine succeeds, then the banner
:is updated and a message sent to the user.If it fails, then an
:error message is set to the user.
:
:Input: AUB-POINTER in RUBLK
:
:Output:message to user -R2
:       updated user banner
:       updated AUB
:
        DEBUGM(Entering ATTCMD,DBGPRT,DALL,ATTSAV,$00D)
        CALL(SETPTR,ATTSAV)             :attempt to set up printer
        LR      RRETC,RRETC             :Set condit.code
        IFF(E,THEN)
          CALL(SNDBAN,ATTSAV)           :to refresh banner
        ENDIF
        CALL(SENDIT,ATTSAV)             :to send message to user
        CALL(NEWLIN,ATTSAV)             :to set up new user input line
        INVOKE(RETCMD)                 :to return through standard return
:mechanism
:
:
        PROCS(ACTPTR,$00D)
        CHAINS(ACTSAV,$00D)
:
:This routine is called to make a RES block the active printer
:res block.It is called when ATTPTR has been entered by the user
:or when printer text arrives and there is no active printer res
:block.It updates theAUB to point to the printer RB.
:
:INPUT:   AUB-POINTER  -  RUBLK
:         RB-POINTER   -  R3
:
:OUTPUT:   updated AUB
:
        DEBUGM(Entering ACTPTR,DBGPRT,DALL,ACTSAV,$00D)
:
        ST      R3,AUBPRB,RUBLK,
        LR      R6,RUBLK                :save RUBLK
        LH      R1,AUBPRT,RUBLK,
        SLLS    R1,2
        AHI     R1,NPORT*4+2            :R1-printer hold buffer
        JAL     R4,EMPTY,,              :to empty printer hold buffer
        LR      R1,R6                   :to restore RUBLK
        LIS     R3,0
        STB     R3,AUBPMI,RUBLK,        :Initialize printer control
        STB     R3,AUBYBO,RUBLK,        : variables
        RETURN(R1)
:
:
        PROCS(SETPTR,$00D)
        CHAINS(SETSAV,$00D)
:
:This routine is called in response to the ATTPTR user command either
:as an option to the res code selection, or as a command of itself.
:It makes sure that the printer RES-IA-TA is not zero, that the user
:is configured to have a printer, that the RES is validated for printing,
:and that the user is allowed to use printing for the RES.
:If not, this routine
:returns a pointer to an error message and a bad return code.
:Otherwise if the user is not trying to attach his active printer,
:ACTPTR is called and SETPTR will return a pointer to the ATTPTR
:response and a good return code.
:
:Input:  AUB-POINTER -RUBLK
:
:Output: MESSAGE POINTER(error msg or ATTPTR response) in R2
:                       (0-good return)
:                       (1-bad return, user not set up for printer)
:                       updated AUB
:
        DEBUGM(Entering SETPTR,DBGPRT,DALL,SETSAV,$00D)
        L       R3,AUBARB,RUBLK,        :R3-pointer to act.res block
        LH      R6,RBRESN,R3,           :R6-RES number
        CVTRES(R6,SETSAV)               :to get appropriate MAG entry
        LHI     R4,MAGLNG
        MR      R5,R4                   :R6-has offset into MAGTAB
        L       R4,RBPTTA,R3,
        JE      SET1                    :if printer RES-IA-TA=0
        L       R4,AUBTIB,RUBLK         :get TIB pointer for this term type
        LB      R4,TIBPRI,R4            :TRUE if term supports printing
        JE      SET1                    :this term can't print
        LH      R4,AUBPTY,RUBLK,
        JE      SET1                    :printer type zero means no printer
        LB      R4,MAGTAB+MAGSPT,R6,
        JE      SET1                    :if RES doesn't support printing
        LB      R4,RBVPT,R3,
        JE      SET1                    :if user isn't valid for printing
:       is user trying to attach his active printer?
        L       R4,AUBPRB,RUBLK,
        CLR     R4,R3
:       If user doesn't have an active printer, or the printer
:       he's trying to attach is not the active printer
:       then attach it.  This makes act.RB the prt.RB.
        IFF(N,THEN)
          CALL(ACTPTR,SETSAV)
        ENDIF
        LA      R2,ATTMSG,,             :make MSG POINTER point to the
                                        : "printer attached" message
        LIS     RRETC,0                 :return code is zero
        J       SET9

SET1    LA      R2,WRONAP,,             :point MSG-POINTER to error message
        LIS     RRETC,1
SET9    RETURN(R3)
: FLTR.01E
: 
:   This routine is called from CMDHND after all of the user's command
:   has been transferred to CMDDAT.  
: 
:   Function:
: 
:     If CMDDAT contains the cmd 'N' or '0' or 'H0' or 'HN' then
:       Change CMDDAT TO 'I' (change size in R4 to 1)
:       Output a diagnostic message on the user's terminal
:       Return to CMDHND indicating non-error condition
:     ELSE
:       Return to CMDHND with a non-error conditon
: 
:   Input:
:     Text in CMDDAT
:     Size of Text in R4
:     Diagnostic Text Message
: 
:   Output:
:     Return Code (always non-error in this implementation)
:     Modified CMDDAT and size if CMDDAT contained one of the 4 cmnds
:     Diagnostic Message in the user's output buffer if CMDDAT matched
:
:   Return code is in R0.  Size is in R4.  R2 is scratched.
:    No other register is modified.
:
        PROC(FLTR)
        CHAIN(FLTRSV)

        LR      R4,R4                   : If length = 0 then no match
        JE      FLT8
        LIS     R15,0
        DO(FOREVER)                     : find 1st non-space or end
          CR    R15,R4
          EXITDO(GE)
          LB    R0,CMDDAT,R15,
          NHI   R0,$0 7F
          CHI   R0,$0 20
          EXITDO(N)
          AIS   R15,1
        ENDDO
                                        : now R15 points to 1st non-spc or end
        SLLS    R0,$0 8                 : get 1st 2 chars (or trash if all spc)
        LB      R15,CMDDAT+1,R15,
        OR      R0,R15
        NHI     R0,$0 7F7F
        CH      R0,FLC1                 : compate to the 4 cmds
        JE      FLT4
        CH      R0,FLC2
        JE      FLT4
        SRLS    R0,$0 8
        CLB     R0,FLC3
        JE      FLT4
        CLB     R0,FLC4
        JN      FLT8
FLT4                            : here if we find a match
        LHL     R0,FLIGN        : replace the text with 'I'
        STH     R0,CMDDAT
        LIS     R4,1            : length of 'I' = 1
        LI      R2,FLDIA        :  send the diagnostic
        CALL(SENDIT,FLTRSV)
        CALL(NEWLIN,FLTRSV)
FLT8                            : get here regardless of match
        LIS     R0,1            : set retcode to no-error
        RETURN(R15)             : return

        BND     2
FLC1    BC      $0 48,30        : H0
FLC2    BC      $0 48,4E        : HN
FLC3    BC      $0 4E           : N
FLC4    BC      $0 30           : 0
FLDIA   SC      /Please contact American Express./
FLIGN   AC      /I /


: (TIGERDEV)CMDHND.S01
:       Copied by Byrne from (MATS.P2)CMDHND.28E on 19-Aug-86
:       Made keyboard lock check configurable in the .TYM file.

: CMDHND.28E
:       Copied by Gauci from .27E    13-feb-84
:       Call the routine FLTR at ALLRED if the user does not have LUDFLT
:       bit set.

: (MATS.P2)CMDHND.27E
:       Copied by Gauci from .26P    6-feb-85
:       Disable locking of the keyboard, allow sending of a null msg
:       when the user types just a carriage return.
:       Note:  ** These two changes are "quick and dirty" and non-
:                 configurable.  We may want to change this in the
:                 future.

:  (MATS.P2)CMDHND.26P
:	Copied by Mele from (MATS.P2)CMDHND.26P on 7/13/84
:	In the case Mars+ service all the characters are translated in
:	themselves except ~ that gets translated in car.ret
:
:  (MATS.P2)CMDHND.25L
:	Copied by Cardini from (MATS.P2)CMDHND.24P on 1/23/84
:	in order to add a new command routine, HELCMD, to handle
:	the user command HELP.
:
:  (MATS.P2)CMDHND.24P
:	Copied by Mele from (MATS.P2)CMDHND.23P on 12/6/83
:	Fixed bug discovered in the MARS+ code
:
:  (MATS.P2)CMDHND.23P
:	Copied by Mele from (MATS.P2)CMDHND.23P on 12/5/83
:	Added in SENDMAG instructions to put an FF in front of
:	every MARS+ command
:
:  (MATS.P2)CMDHND.22P
:	Copied by Mele from (MATS.P2)CMDHND.21L ON 11/30/83
:	Added conditional assembly for the case NO CARL
:
:  (MATS.P2)CMDHND.21L
:    Copied by Cardini from (MATS.P2)CMDHND.20 on 11/1/83
:    in order to modify SNDMAG procedure to allow the handling
:    of VIP text message.
:    Moreover some code has been added to disable the use of '=' and
:    'switch' commands in single access context.
:
:  (MATS.P2)CMDHND.20L
:    Copied by Cardini from (MATS.P2)CMDHND.19P on 9/23/83
:    in order to modify RSTCMD and to add some instructions
:    after first  EDIT call for RESET activaction.
:    CRLERR procedure has been changed for error detection in
:    hard copy terminals (315 and 430).
:
:  (MATS.P2)CMDHND.19P
:    Copied by Mele from (MATS.P2)CMDHND.18R on  08/23/83.
:    All changes have been done to insert the EDIT routine.
:    The EDIT is called at the beginning of any activation routine 
:    that use READ . EDIT will interpret the characters read from 
:    the input buffer and return to the READ a buffer with the edited 
:    characters.EDIT is called at label CMDD1.
:    The particular instructions for CTRL/U,DC1,DC3,ESCAPE have been deleted
:
: (MATS.P2)CMDHND.18R
:    Copied by Cheung from (MATS.P2)CMDHND.17R on 11/22/82.
:    Reset PNR security indicator when the waiting period for the
:    'Reset' is over.

: (MATS.P2)CMDHND.17R
:    Copied by Cheung from (MATS.P2)CMDHND.16B  on 09.03.82.
:    Replaced hard coded by pass char. with the by pass char specified
:    in the MAGTAB table.

: (MATS.P2)CMDHND.16B
:    Copied by Beecher from (MATS.P2)CMDHND.15B on 4/26/82
:    Instead of assigning a delete line character to each terminal
:    type and storing it in the TIBDLC field we make CTRL/U valid
:    on all (non-block mode) terminals and we declare <ESC> to be
:    valid on certain terminal types.  Hence we no longer have the
:    TIBDLC field but we have a new field, TIBEOK, which is TRUE
:    if <ESC> is OK on a particular terminal type (specifically
:    on 315 and its aliases: Hardcopy, Decwriter, and 430).
:    If TIBEOK is FALSE and the user types <ESC> under the
:    current implementation we issue a warning, "Please use CTRL/U",
:    then we execute the delete line function anyway.
:
: (MATS.P2)CMDHND.15B
:    Copied by Beecher from (MATS.P2)CMDHND.14W on 4/8/82
:    Removed terminal dependent code from RSTCMD routine;
:    instead of examining the terminal type we now check the
:    TIBEDL field of the TIB (no TIB implies TIBEDL is TRUE).
:
: (MATS.P2)CMDHND.14W
: Copied from (MATS.P2)CMDHND.13S on 08/20/81
: Added MATS STATS changes
:
: (MATS.P2)CMDHND.13S
:    Copied by Gimnicher from (MATS.P2)CMDHND.12S.  3-31-81
:    Made changes for TSR # 110 - "Key-in Field Overwrites Wrapped Display"

: (MATS.P2)CMDHND.12S
:    Copied by Gimnicher from (MATS.P2)CMDHND.11F. 2/17/81.
:    Bug in command timeout function fixed.


: (MATS.P2)CMDHND.11F
:    Copied by Bonnell from (MATS.P2)CMDHND.10S.  2/9/81.
:    Instead of skipping first five characters of 470 input, reads the
:    cursor position.
:    Added special handling of CARL errors for 470.

: (MATS.P2)CMDHND.10S
:   Copied by Gimnicher from (MATS.P2)CMDHND.09B.  2-8-81
:   Fixed bug where reset function key didn't work on 470.
:   Carl error code that was in .09B has been removed in this file.

:  CMDHND.09B   COPIED FROM (MATS.P2)CMDHND.08S  2/4/81
:       MORE MODS FOR 470 IINVOLVING READING THE USER COMMAND
:

: (STEVEG)CMDHND.08S
:    Copied by Gimnicher from (MATS.P2)CMDHND.07B.  1/29/81
:    Modification made to command timeout for printer project.

:  (FRICKEL)CMDHND.07B
:     COPIED BY FRICKEL FROM (MATS.P2)CMDHND.06S   1/27/81
:     CHANGED FOR REMOVAL OF 8D8A FROM MESSAGES TO USER
:
:  (STEVEG)CMDHND.06S 
:    Copied by Gimnicher from (MATS.P2)CMDHND.05S.  1/9/81
:    Changes made for printer project to break on DC1 and DC3 data characters.


: (MATS.P2)CMDHND.05S
:    Copied by Gimnicher from (MATS.P2)CMDHND.04S.  12/22/80
:    OWL support code in (FRICKEL)CMDHND.02B merged in.

: (MATS.P2)CMDHND.04S.
:    Copied by Gimnicher from (MATS.P2)CMDHND.03S.  10-23-80
:    SHTCMD and ANSCMD modified for Soft Shut implementation.

: (MATS.P2)CMDHND.03S.
:    Copied by Gimnicher from (STEVEG)CMDHND.01S.  10-13-80
:    CVTRES calls modified for Monitor Screen Formatter implementation.

:                   THE COMMAND HANDLER & ASSOCIATED SUBROUTINES

	MO	.,CMDHND
	LO MAIN
	RA	0


:  Screen position macros.

:    These macros are put here temporarily.  Later they should be moved to
:    another file.


:  Macro SP2T1 (Rl, Rc, Rn, Rp)

:       Rl, Rc, Rn and Rp are registers.


:  Input--

:       Rl      LINE (line number)

:       Rc      COL (column number)--  1 <= COL <= NCOL

:       Rn      NCOL (number of columns per line)


:  Output--

:       Rp      Position:   LINE*NCOL + (COL-1)



SP2T1   MACRO(R.L,R.C,R.N,R.P)
[

        LR      R.P,R.L
        MHR     R.P,R.N         : LINE*NCOL
        AR      R.P,R.C         : LINE*NCOL + COL
        SIS     R.P,1           : LINE*NCOL + (COL-1)
]




:  Macro SP1T2 (Rp, Rn, Rc)

:       Rp, Rn and Rc are registers.

:       Warning!  SP1T2 uses register Rc+1.


:  Input--

:       Rp      Position (single coordinate)

:       Rn      NCOL (number of columns per line)



:  Output--

:       Rc      COL (column)--  1 <= COL <= NCOL

:       Rc+1    LINE (line number)



SP1T2   MACRO(R.P,R.N,R.C)
[
        LR      R.C,R.P
        DHR     R.C,R.N         : R.C has remainder (COL-1)
                                : R.C + 1 contains quotient (LINE)
        AIS     R.C,1           : COL
]



	PROC(CMDHND)
	CHAIN(CMDSV)
	L	RUBLK,P2U,R1	:AUB/AMT POINTER
:
	LR	R0,R0		:SET COND. CODES
	JE	CMDDTA		:JUMP IF DATA BREAK
	CLHI	R0,9E		:DETACH?
	JE	CMDZAP
	CLHI	R0,9F		:ZAPPER?
	JE	CMDZAP
	CLHI	R0,-3		:FLUSH?
	JE	CMDFL
	CLHI	R0,-2		:TOO MANY CHARS?
	JE	CMDTMC
	CLHI	R0,-4		:TIMOUT?
	JE	CMDTO

	JAL	R10,CRASH,,	:CRASH IF FALLS THROUGH
	BC	0,0,4*RLINK,CRBCMD	:CRASH CODES

CMDTO
        CLHI    R2,LUDMUR       : Is this a monitor user?
        IFF(N,THEN)             : No. Check if he received printer data within
                                : command timeout period of active crt res block
          L       R0,AUBLCT,RUBLK,      : Time last printer data was received
          L       R2,AUBARB,RUBLK,      : Active crt res block pointer
          IFF(N,THEN)
            AH      R0,RBCTO,R2,        : Next timeout interval
            L       R2,SLOWC,,  
            CR      R0,R2               : Has user received printer data
                                        : within timeout interval?
            IFF(G,THEN)                 : Yes. Don't time user out now
              SR    R0,R2               : Return time left in interval
              RETURN(R1)
              ENDIF
            ENDIF
          ENDIF

: Perform command time out
        LIS     R2,DISCTO       : Set disconnect reason to command
        STB     R2,AUBDRN,RUBLK,: time out in AUB
        LI      R2,TIMEUP       : Say command timeout...logoff complete
        INVOKE(ZAPPRT)

CMDZAP  INVOKE(DSCUSR)

CMDFL	CALL(CIB,CMDSV)
        LIS     R0,0            :FRONT2.LIB CHECKS FOR NORMAL USER TIMEOUT
	RETURN(R1)

CMDTMC  LI   R2,TMANYC		:TELL TOOMANY CHARACTERS
	CALL(SENDIT,CMDSV)
	CALL(NEWLIN,CMDSV)
	INVOKE(RETCMD)








CMDDTA  LB      R13,AUBTYP,RUBLK :get user type
                                :build trace event message
	LHI	R10,TCMD	:TRACE EVENT ID
	STH	R10,TRCENT	:LOAD TRACE MSG AREA
        LH      R10,AUBPRT,RUBLK :get port number
	STH	R10,TRCENT+2
        L       R10,GMT,,       :pick up Grenwich Mean Time
	ST	R10,TRCENT+4
	CLHI	R13,LUDMUR	:MONITOR USER?
	JEFS	CMDTR1		:YES.. SKIP
        L       R11,AUBARB,RUBLK :get active RB address
	ST	R11,TRCENT+$A12
	LIS	R11,0
	JFS	CMDTR2
CMDTR1	LIS	R11,0
	ST	R11,TRCENT+$A12	:CLEAR ENTRY
CMDTR2  ST      RUBLK,TRCENT+$A16 :store UBLOCK character
	ST	R11,TRCENT+$A20	:clear return code
:
:
:
:

      	LB	R2,ACTCHA	:Get activation character
	CALL(EDIT,CMDSV)	:fill edit buffer
	LR	R3,R3
	IFF(N,THEN)		:Is del lin. or curs. left
	  CLHI	R3,-2		:line delete or reset activation?
	    IFF(E,THEN)
      	      INVOKE(RSTCMD)	:Yes
	    ORELSE
	      INVOKE(RETCMD)
	    ENDIF
	ENDIF
	LB      R2,AUBTTY,RUBLK,        :GET TERMINAL TYPE
        CLHI    R2,AUB470       :IS THIS A 470?
        JN      CMD1H           :NO

   : The terminal is a 470.  Take care of the first five characters.
   : If the first character is SOH, the next two characters give the
   : cursor position.  The two characters following the cursor position
   : contain the addrress of the first data field.  (We assume that
   : the 470 is configured so that there is no field terminator.)

   : We will save the cursor position in (AUBLIN, AUBCOL).

   : In case of error, will go to CMD0.5

        LCS     R0,1                    : For READ
        LIS     R2,5                    : Read at most five characters
        LA      R3,CMDDAT               : Address for READ

        CALL(READ,CMDSV)                : To read at most five characters

        LR      R0,R0                   : Did we get five characters?
        JLE     CMD0.5                  : No.

        LR      R10,RUBLK               : Save AUB pointer

   : Is first character SOH?

        LB      R0,CMDDAT,,             : Get first character
        NHI     R0,$8 177               : Remove high-order bit
        CLHI    R0,1                    : Is it SOH?
        JN      CMDC1                   : No.  May be function key.

   : Read and translate cursor position

        LB      R0,CMDDAT+1,,           : Get cursor line position
        NHI     R0,$8 177               : Remove high-order bit
        SHI     R0,$8 40                : Convert from character to number
        JL      CMD0.5                  : Error.  Illegal cursor position.

        AIS     R0,1                    : First line is line 1.
        CLHI    R0,$A 24                : Is it too large for a line number?
        JG      CMD0.5                  : Yes.  Error.

        STH     R0,AUBLIN,R10,          : Save cursor line position.

        LB      R0,CMDDAT+2,,           : Get cursor column position.
        NHI     R0,$8 177               : Remove high-order bit
        SHI     R0,$8 40                : Convert from character to number.
        JL      CMD0.5                  : Error.  Illegal cursor position.

        AIS     R0,1                    : First column is column 1.
        CLHI    R0,$A 80                : Is it too large for a column number?
        JG      CMD0.5                  : Yes.  Error.

        STH     R0,AUBCOL,R10,          : Save cursor column position.

   : For now, ignore field address.


CMDC1
        LR      RUBLK,R10               : Restore AUB pointer to RUBLK

     : We are now finished with the first five characters of 470 input.


CMD1H
:       Note:  The next instructions disable locking of the keyboard
:              for non-block-mode terminals.
        IF      1-USRDLK
:******
          LB      R2,AUBTTY,RUBLK : if not type VID
          NHI     R2,AUBVID
          JE      CMDD4           : disable locking keyboard for VID term.
:******
        EI

	LIS	R2,AUBOUT
	CLB	R2,AUBMOD,RUBLK	:OUTPUT MODE?
	JN	CMDD4		:NO... SKIP
        LB      R2,AUBTTY,RUBLK,
        NHI     R2,AUBVID
	JE	CMDD3		:NO ....SKIP
	LA	R3,CMDDAT
	LIS	R2,0
	ST	R2,0,R3		:CLEAR DATA AREA
	LIS	R2,2		:TWO CHARS TO READ
	LCS	R4,1		:NO TERMINATING CHAR
	CALL(READ,CMDSV)
	L	R2,CMDDAT
	CLI	R2,$081CD0000	:PFK 14 (RESET)
	JN	CMDD0		:
	ST	R2,TRCENT+8	:HANDLE THE RESET
	LA	R2,TRCENT
	CALL(TRACE,CMDSV)
	CALL(CIB,CMDSV)
	INVOKE(RSTCMD)
CMDD0	JFS	CMDD3
:
CMDD2	CALL(UNLKKB,CMDSV)
	LIS	R2,AUBINP
	STB	R2,AUBMOD,RUBLK	:SET INPUT MODE
CMDD3	CALL(BEEPER,CMDSV)
	CALL(CIB,CMDSV)
        LIS     R0,0            :FRONT2.LIB CHECKS FOR NORMAL USER TIMEOUT
	RETURN(R2)
:

CMDD4	LIS	R2,AUBOUT
	STB	R2,AUBMOD,RUBLK	:SET TO OUTPUT MODE
        CALL(LOCKKB,CMDSV)
	L	R10,FASTC,,
	ST	R10,AUBTIM,RUBLK	:STORE TIME

:Begin inputting the command line-

CMD0    LI      R2,$00A0A0A0A0  :CLEAR OUT FIRST 3 WDS OF CMDDAT
        STH     R2,CMDDAT
        ST      R2,CMDDAT+2
        ST      R2,CMDDAT+6
	LIS	R2,1		:READ ONE CHARACTER
        LA      R3,CMDDAT       :where to put the input
	LCS	R0,1		:NO TERMINATING CHAR
	CALL(READ,CMDSV)
	LR	R0,R0
	JG	HAVCMD		:PROCESS ONLY IF INPUT EXISTS
:       Note:  The next 3 instructions allow sending of a null text
:       message when the user types a carriage return only.
        ST      R0,CDRDSV,,
        ST      R2,CDRDSV+4,,
        J       NOTCMD
CMD0.5  CLHI    R13,LUDMUR      :MONITOR?
	JNFS	CMD1		:NO, SKIP
	CALL(NEWLIN,CMDSV)
CMD1	INVOKE(RETCMD)

:CHECK FOR = CHAR
HAVCMD	LHI	R3,$00BD	:LOOK FOR EQUAL (SWITCH) COMMAND
	CLB	R3,CMDDAT	:SEE IF THATS THE COMMAND
	JN	NOTEQU	JUMP IF NOT EQUAL CMD
SWTCH	LA	R2,TRCENT	:LOAD TRACE EVENT MSG ADDR
	CALL(TRACE,CMDSV)
	LHL	R2,AUBSER,RUBLK,:GET SINGLE OR MULTIPLE ACCESS INDICATOR
	IFF(N,THEN)		:SINGLE ACCESS
	  LA	R2,NSACMD,,	:'INVALID COMMAND IN SINGLE ACCESS CONTEXT'
	  CALL(SENDIT,CMDSV)
	  CALL(NEWLIN,CMDSV)
	  INVOKE(RETCMD)
	ENDIF			:SINGLE ACCESS
	L	R2,AUBARB,RUBLK	:GET ARB
	JE	HAVCD1		:NO ARB

        IF      SG.RTO
        L       R3,SLOWC,,      :GET CURRENT TIME IN SECONDS
        ST      R3,RBSCHT,R2,   :STORE IN RES BLOCK BEING SWITCHED AWAY FROM
        EI

	L	R3,RBIATA,R2	:GET RES_IA_TA
	CALL(BINSCH,CMDSV)
	LR	RRETC,RRETC	:TEST RETURN CODE
	JNFS	HAVCD1		:NOT FOUND
:MAY WANT TO CRASH IF NOT FOUND
	CALL(R2UDEL,CMDSV)
	LIS	R3,0
	ST	R3,AUBARB,RUBLK	:CLEAR OUT ARB
HAVCD1	INVOKE(SWTRES)

NOTEQU	LI	R3,CMDDAT+1	:READ IN REST OF COMMAND
	LHI	R2,CMDLEN-1
	LHI	R0,0A0		:TERMINATE ON SPACE
	CALL(READ,CMDSV)
	LR	R3,R2		:NUMBER OF CHARS READ
	AIS	R3,1		:PLUS THE ONE BEFORE
        ST      R0,CDRDSV,,       :SAVE READ OUTPUT ARGS
        ST      R3,CDRDSV+4,,
	L	R2,CMDDAT	:GET 4 CHARS OF RESPONSE
	ST	R2,TRCENT+8
	LA	R2,TRCENT	:LOAD TRACE EVENT MSG ADDR
	CALL(TRACE,CMDSV)
	LI	R2,CMDDAT	:ADDR OF COMMAND
	LI	R4,CMDTAB	:COMMAND TABLE
	LI	R5,CMDEND	:END OF TABLE
	CALL(CMDSRC,CMDSV)
	LR	R6,R0		:FOUND?
	JE	NOTCMD		:NO, JUMP

	LB	R2,CMDLIC,R6	:CHECK LICENSE
	LB	R3,AUBLIC,R1	:AGAINST USER LICENSE
	NR	R2,R3
	CLB	R2,CMDLIC,R6	:OK?
	JN	NOTCMD		:NO, PRETEND COMMAND DOESN'T EXIST
	LB	R2,CMDTYP,R6	:USER TYPE
	LB	R3,AUBTYP,R1	:USER TYPE FROM AUG
	NR	R2,R3
	JE	NOTCMD		:JUMP IF USER TYPE DOESN'T MATCH
	CALL(NXTICH,CMDSV)	:POSITION AT NEXT INTERESTING CHAR.
	L	R2,CMDADR,R6	:ADDR OF ROUTINE
	INVOKR(R2)

NOTCMD	CLHI	R13,LUDMUR	:MONITOR?
	JN	NOTMON		:NO, JUMP
	LI	R2,INVCMD	:INVALID COMMAND MSG
	CALL(SENDIT,CMDSV)
	CALL(NEWLIN,CMDSV)
	INVOKE(RETCMD)

:	CHECK RES STATUS
NOTMON  L       R4,AUBARB,RUBLK :GET ACTIVE RES BLOCK
	JNFS	NOTMN1	:JUMP IF ARB FOUND
	LA	R2,NOTCON,,	:NOT CONNECTED MSG FOR PROGRAMMERS
	J	GETRSS
NOTMN1	LH       R7,RBRESN,R4    :GET RES NUMBER
	CVTRES(R7,CMDSV)	:CVT RES NUMBER TO MAGTAB ENTRY NUMBER
        LB      R10,RBIATA+2,R4 :LOAD IA
        OI      R10,$0 080
        STB     R10,CMDIA,,     :STORE IN IA
        LB      R10,RBIATA+3,R4 :LOAD TA
        OI      R10,$0 080
        STB     R10,CMDTA,,     :STORE IN TA
        LA      R5,MAGTAB,,      :GET MAGTAB ENTRY ADDRESS
        LHI     R8,MAGLNG       :LOAD LENGTH OF MAGTAB ENTRY
        MR      R6,R8           :COMPUTE OFFSET INTO MAGTAB
:
        LA      R13,,R5,R7       :R13 IS ADDR OF MAGTAB ENTRY
	TRPORT(USRCMD,CMDSV)
        LH      R9,MAGSTA,R13  ::LOAD STATUS FIELD
        CLHI    R9,RESUP        :IS RES UP
        JE      RSISUP          :IF YES JUMP
        CLHI    R9,RESBP        :IS RES BP
        JN     CKNA            :NOT BP CHECK NA
        LA      R2,RSBPMS,,       :LOAD ADDR OF BACK PRES MES
        J       GETRSS
CKNA    CLHI    R9,RESNA        :
        JN     NOTRSP          :IF ISNT NA.....GO TO NOT RSPONDING
NORES   LA      R2,RSNAMS,,     :LOAD ADDR OF NOT AVAIL MSS
        J       GETRSS
NOTRSP  LA      R2,RSNRMS,,     :LOAD ADDR OF NOT RESPONDIN MSG
GETRSS  CALL(SENDIT,CMDSV)
	CALL(NEWLIN,CMDSV)
	INVOKE(RETCMD)
:
:	RES SYSTEM IS UP
:
RSISUP  L       R2,CDRDSV+4,,   :LOAD NUMBER CHARS READ (TOTAL)
	LIS	R12,0		:CLEAR OUT THE BYPASS SWITCH
        LB      R5,MGBCHR,R13,  :LOAD BY-PASS CHAR FR. MAGTAB
        CLB     R5,CMDDAT       :COMPARE TO FIRST BYTE
        JN      ALMOVD
	LCS	R12,1		:INDICATE BYPASS SWITCH
        SIS     R2,1            :DECREMENT CHARACTER COUNTER
        LIS     R7,1
        LR      R5,R2
MOVLOP  JE      ALMOVD          :IF ALL CHARS MOVED THEN JUMP
        LB      R6,CMDDAT,R7    :LOAD A BYTE
        STB     R6,CMDDAT-1,R7    :STORE ONE CHAR BACK
        AIS     R7,1            :INCREMENT POINTER
        SIS     R5,1            :DECREMENT COUNTER
        J       MOVLOP          :LOOP
ALMOVD  LR      R4,R2           :SAVE LENGTH OF STRING READ
        L       R0,CDRDSV,,     :LOAD RETURN CODE FROM READ
        JL      ALLRED          :IF NEG THEN ALL CHARS READ
        JG      CMDTMC          :JUMP IF TOOMANY CHARS
        LHI     R3,$0 00A0      :LOAD A BLANK
        STB     R3,CMDDAT,R2    :STORE THE BLANK WE STOPPED ON
        LA      R4,1,R2         :R4 IS TOTAL CHARS READ
        LHI     R2,CMDLEN       :LOAD LENGTH OF BUFFER
        SR      R2,R4           :THIS MANY LEFT TO BE READ (MAX)
	LCS	R0,1		:READ TO END OF LINE
        LA      R3,CMDDAT,R4    :MOVE OVER TO NEXT CHAR POSITION
        CALL(READ,CMDSV)
	AR	R4,R2		:ADD THIS COUNT TO PREVIOUS COUNT
        LR      R0,R0           :SET COND CODE
        JG      CMDTMC          :BUFFER OVERFLOW

:Now the input string is completely read and the atsign, if the first character,
:has been stripped out. The input string is justified at CMDDAT.
:R4 now contains the number of characters in the input string.

allred
        LB      R2,AUBLIC,RUBLK
        NHI     R2,LUDFLT
        IFF(N,THEN)
          CALL(FLTR,CMDSV)
        ENDIF
        lis     r3,0
        stb     r3,cmddat,r4    :terminate the input string by a zero

:Check to make sure user did not type an invalid Function Key (PFK).
:Valid function keys will have already been noticed by the command
:search.

        lhi     r3,$0 081        :is an SOH (Control-A), indicating PFK
        clb     r3,cmddat       :the first character?
        jn      notpfk
        la      r2,badpfk,,
        call(sendit,cmdsv)
        call(newlin,cmdsv)
        invoke(retcmd)

notpfk  lhi     r3,carlon
        clb     r3,aubcrl,rublk :is CARL on?
        jn      caroff          :no

:CARL is on. CARL is called only if no bypass was specified (the atsign was
:removed already, and the bypass indication is in R12).
:If a valid PFK was typed, then the appropriate command handler
:was invoked, and each of them will fill the input buffer CMDDAT
:with their translation, and R2 with its length,  and then branch to PFKHIT, below.

        lr      r12,r12         :was atsign typed as first char?
        jn      bypass          :yes, don't call CARL

calcrl  debugm(CARL invoked,dbganc,dall,cmdsv,$01)
	IF  1-NOPARS		:No assembly if no CARL
        lr      r10,r4          :save length of input string
        if      pars.2
        gl      pars2
        else
        gl      carl
        ei
        if      pars.2
        jal     rlink,pars2,,
        else
        jal     rlink,carl,,
        ei
        lr      rretc,rretc
        je      carlok
        call(crlerr,cmdsv)

        LB      R0,AUBTTY,RUBLK,        : Get user terminal type
        CLHI    R0,TTY470               : Is it a 470?
        JE      CAR470                  : Yes.
	EI

        invoke(retcmd)

   : For a 470 we don't want to invoke RETCMD in case of a CARL error.
   : Instead, we use the following special code.

CAR470
        LR      R10,RUBLK               : AUB pointer

    : Reset modify data tags

        LHI     R11,TIBMDT              : TIB offset for modify-data-tags

        CALL(VIGTEC,CMDSV)              : Get escape sequence for the 470

        LHL     R1,AUBPRT,R10,          : Get port number
        SLHLS   R1,2
        AIS     R1,2                    : Output buffer index = (4*port) + 2

        JAL     R4,WCI,,                : Send escape character
        EXBR    R0,R0
        JAL     R4,WCI,,                : Send reset-modify-data-tags

        LR      RUBLK,R10               : Restore AUB pointer to RUBLK

        CALL(UNLKKB,CMDSV)              : To unlock keyboard and put user in
                                        : input mode.

        CALL(CIB,CMDSV)                 : To clear input buffer.

        LIS     R0,0
        RETURN(R1)                      : Finished with special handling for
                                        : Carl error on 470 terminal



carlok

:Register R2 contains address of translated string- R3 contains its length
:not counting the terminating zero.

        lr      r4,r3           :length into R4
        j       setsta          :go send it to the mag

bypass
caroff

:Jump here when bypass (@) was specified, or if user not in CARL mode.
:If a U command was entered, turn off umsg light.

        clhi    r4,1            :is length of cmd = 1?
        jn      nucmd
        lhi     r3,$0 0D5       :U?
        clb     r3,cmddat
        jn      nucmd
        call(nulite,cmdsv)
nucmd

        la      r2,cmddat
SETSTA  LR      R3,R4           :LOAD LENGTH
        LIS     R5,1            :LOAD A 1
        AM      R5,MGIMGM,R13   :INCREMENT COUNT
        AM      R3,MGIMMG,R13   :INCREMENT LENGTH
        INVOKE(SNDMAG)

:CRLERR         print message associated with error return from CARL

	PROC(CRLERR)
	CHAIN(CRLESV)

:Print error message at terminal, with indication of location of error.
:R2 contains address of error message, R3 contains its length.
:R4 contains character position of error in input line, as number of
:characters before the end of the line. We assume that the input line
:was left-justified in the screen and was not the last line on the screen.
:Length of input string has been saved in R10.

	SEG	0
BLANK3	SC	/   /
	SEG	1


        lr      r7,r2           :save addr of error msg
        sr      r10,r4          :get position of error from beginning of line

        LB      R0,AUBTTY,RUBLK,        : Get terminal type
        CLHI    R0,TTY470               : Is it a 470?
        JE      CRLE47                  : Yes.  Requires special handling.

        ais     r10,3           :account for prompt
        lb     r5,aubtty,rublk
        nhi     r5,aubvid
        jefs    somlbl
        sis     r10,2           :airline name not printed as part of prompt on 440
        call(newlin,crlesv)
somlbl  lr      r0,r10          :save length
        lb      r5,aubtty,rublk
        clhi    r5,aub470
        JE      CRLE04
        sis     r10,1           :number of spaces to space over, don't count last one where caret goes
        J       CRLE05
CRLE04  AIS     R0,1            :ADD ONE TO LENGTH
CRLE05	LR	R8,R0		:save R0
	LB	R0,AUBTTY,RUBLK :get terminal type
	NHI	R0,TTY315+TTY430 :is the terminal a hard copy ?
	JE	CRLE06		:
	LB	R0,BLANK3,,    	:yes, send 3 spaces
	LA	R2,BLANK3+1,,
	CALL(SENDMS,CRLESV)
	LH	R0,EDILEN,,	:send edibuf 
	LA	R2,EDIBUF,,
	CALL(SENDMS,CRLESV)
	CALL(NEWLIN,CRLESV)
CRLE06	LR	R0,R8		:restore R0
        LHI     R5,$0 0A0       :BLANK
        gl      crlebf
        la      r6,crlebf
spces   stb     r5,0,r6
        ais     r6,1            :increment pointer
        sis     r10,1           :decrement counter
        jg      spces
        lhi     r5,$0 0DE        :^ character
        stb     r5,0,r6
        la      r2,crlebf
        call(sendms,crlesv)
        la      r2,crlmsg,,
        call(sendit,crlesv)
        lr      r2,r7           :addr of error message
	LR	R0,R3		:LOAD MSG LENGTH
        call(sendms,crlesv)     :print it
        call(newlin,crlesv)
        lis     r0,0
        RETURN(R1)


:  Special handling for 470.

:       R7      address of error message
:       R3      length of error message
:       R10     position of bad character (relative to beginning of
:               input string)


:       (AUBPLN,AUBPCL) is the beginning of the input area.  We will put
:       the error message at (AUBPLN+5,2).  (AUBPLN is guaranteed to
:       be <= 20.)  The error message will be truncated if it takes more
:       than one line.


CRLE47

        LR      R12,R10                 : Save position of bad character

   : Put cursor at (AUBPLN+5,2), wrapping line if necessary

        LR      R10,RUBLK               : R10--AUB pointer for VIPOSC
        LHL     R8,AUBPLN,R10,
        AIS     R8,5                    : R8-- line number for VIPOSC
        CLHI    R8,$A24                 : Is this past end of screen?
        IFF(G,THEN)
          LIS     R8,5                  : Yes - put error message at top of
                                        : i/o area
          ENDIF
        LIS     R9,1                    : R9-- column number for VIPOSC
        LHL     R1,AUBPRT,R10,          :      port number
        SLHLS   R1,2
        AIS     R1,2                    : R1-- output buffer index (4*port+2)

        CALL(VIPOSC,CRLESV)             : to move cursor to (AUBPLN+5,1)
        CALL(VIERLN,CRLESV)

        LR      RUBLK,R10               : restore RUBLK

   : Put out message

        LB      R0,CRLMSG,,             : length of message header
        LR      R8,R3                   : length of body of message
        AR      R8,R0                   : total length

        CLHI    R8,$A 80
        JL      CRLET                   : OK.  Message is not too long.

        LHI     R3,$A 79
        SR      R3,R0                   : length of truncated message body

CRLET   LA      R2,CRLMSG+1,,           : address of message header for SENDMS

        CALL(SENDMS,CRLESV)             : to send message header

        LR      R0,R3                   : length of (possibly truncated) body
        LR      R2,R7                   : address of message body

        CALL(SENDMS,CRLESV)             : to send message body

   : Put cursor over bad character

        LHL     R2,AUBPLN,RUBLK,        : line number
        LHL     R3,AUBPCL,RUBLK,        : column number
        LHI     R10,$A 80               : line length

        SP2T1(R2,R3,R10,R11)            : convert to single coordinate

        AR      R11,R12                 : add relative position of bad character

        SP1T2(R11,R10,R7)               : convert back--
                                        :   R7--column
                                        :   R8--line

        SIS     R7,1                    : Adjust column to be over beginning of field
        LR      R9,R7                   : R9-- column for VIPOSC
        LR      R10,RUBLK               : R10--AUB pointer for VIPOSC
        LHL     R1,AUBPRT,R10,
        SLHLS   R1,2
        AIS     R1,2                    : R1-- output buffer index

        CALL(VIPOSC,CRLESV)             : to move cursor

        LR      RUBLK,R10               : restore RUBLK

        LIS     R0,0
        RETURN(R1)



:RETCMD  STANDARD RETURN FROM COMMAD HANDLER

PROC(RETCMD)
CHAIN(RETCSV)
        LB      R13,AUBTYP,RUBLK
	CLHI	R13,LUDMUR	:MONITOR?
	JE	RET2		:YES, SKIP
	CALL(SNDSOM,CMDSV)
	CALL(UNLKKB,CMDSV)
RET2	CALL(CIB,CMDSV)

        LIS     R0,0            :FRONT2.LIB CHECKS FOR NORMAL USER TIMEOUT
	RETURN(R1)

:CMDSRC  Search through command list for match.  The command list
:         shall be of the type defined by the COMMND macro.
:
:   Arguments:  R2 - Command address
:               R3 - Length of command
:               R4 - Addr. of top of search list
:               R5 - Addr. of end of search list
:
:   Return code:  R0 - 0 if not found
:                      Addr. of command entry if found

PROC(CMDSRC)
	CLHI	R3,$A12		:COMMAND LONGER THAT 12 CHARS?
	JG	CSFAIL		:YES, FAILURE. (MAX 12 CHARS)
CSNEXT	LHL	R6,CMDULS,R4	:UNIQUE LEFT SUBSET
	CLR	R3,R6		:INPUT LESS THAN ULS?
	JLFS	CSNOPE		:YES, NO MATCH.
	LR	R7,R3		:NUMBER OF CHARS TO LOOK AT
CSLOOP	SIS	R7,1		:DECREMENT CHARACTER COUNTER
	JL	CSFND		:COMMAND MATCH IF < 0!
	LB	R8,0,R2,R7	:GET CHARACTER OF COMMAND
	CLB	R8,CMDNME,R4,R7	:COMPARE WITH COMMAND LIST
	JEBS	CSLOOP		:CONTINUE TEST IF MATCH

CSNOPE	AHI	R4,CMDLNG		:NEXT ENTRY
	CLR	R4,R5		:END OF LIST?
	JN	CSNEXT		:NO, TEST COMMAND

CSFAIL	LIS	R0,0		:NO MATCH: RET. CODE 0
	RETURN(R2)

CSFND	LR	R0,R4		:FOUND!!!  RETURN ADDR OF ENTRY
	RETURN(R2)



:SNDCMD  Handle SEND PFK

	PROC(SNDCMD)
	CHAIN(SCSAV)
	CALL(LOCKKB,SCSAV)
	CALL(SNDEOM,SCSAV)
	LIS	R2,AUBINP	:SET INPUT MODE
	STB	R2,AUBMOD,RUBLK
	CALL(GETMSG,SCSAV)
	RETURN(R2)


:RSTCMD  Handle RESET PFK

	PROC(RSTCMD)
	CHAIN(RSTSAV)
	LIS	R12,AUBINP
        CLB     R12,AUBMOD,RUBLK :ALREADY IN INPUT MODE?
	JN	RST0
	LB	R2,AUBTTY,RUBLK	 : get terminal type
	NHI	R2,AUBVID	 : 440 or 470 terminal ?
	JE	RST1		 : perform delete line



                                : (might be a Scanset, for example)
:       Come here for block mode terminals (e.g. 440 and 470)
:       because they perform the delete line function themselves
        LIS     R0,0            :FRONT2.LIB CHECKS FOR NORMAL USER TIMEOUT
	RETURN(R12)
 
RST0	CLHI	R13,LUDMUR	:MONITOR?
	JE	RST1		:SKIP IF MONITOR

:       switch from output mode to input mode

	L	R2,AUBARB,RUBLK	:GET ACTIVE RB
	LH	R3,RBRESN,R2	:GET RES NUMBER
	CVTRES(R3,RSTSAV)	:CVT RES NUMBER TO MAGTAB ENTRY NUMBER
	LA	R5,MAGTAB,,	:MAG TAB OFFSET
	LHI	R6,MAGLNG	:MAG TAB LENGTH
	MR	R2,R6		:COMPUTE OFFSET IN TABLE
	LB	R7,MAGDLY,R5,R3	:GET DELAY TIME
	JE	RST05		:NO TIME DELAY...SKIP
	MH	R7,NRATE+2,,	:CONVERT TO SECONDS
	L	R6,FASTC,,	:GET TIME
	S	R6,AUBTIM,RUBLK
	CR	R7,R6		:TEST IF > DELAY TIME
	JLFS	RST05		:OK... RESET
	CALL(BEEPER,RSTSAV)
	J	RSTRET

:       increment the RESET counter

RST05	LIS	R7,1
	AM	R7,MGIRST,R5,R3
        LIS     R7,SRHPNR       : RESET TO 'SEARCH FOR PNR'
        STB     R7,AUBPNR,RUBLK : 
:
RST1    CALL(NEWLIN,RSTSAV)     :print a CRLF and update line counter
	CALL(SNDSOM,RSTSAV)
	CALL(UNLKKB,RSTSAV)
RSTRET  LIS     R0,0            :FRONT2.LIB CHECKS FOR NORMAL USER TIMEOUT
	RETURN(R2)



 
: RFSCMD - REFRESH SCREEN COMMAND
:
	PROC(RFSCMD)
	CHAIN(RFSAVE)
:
	LIS	R2,0		:RESET INDICATOR TO MAKE SNDBAN
	STB	R2,VARHEL,,	:SENDING THE BANNER
	STB	R2,AUBSCN,RUBLK	:CLEAR OUT SCREEN FORMAT TYPE
	L	R2,AUBARB,RUBLK	GET ACITVE RES
	JNFS	WHTSCN	JUMP IF ONE EXISTS
	LIS	R2,SCNPAR	:DEFAULT SCREEN TYPE
	CALL(FMTSCN,RFSAVE)	:FORMAT THE SCREEN
	LIS	RRETC,0	:NO BANNER NEED BE SEND
	INVOKE(RETCMD)
:
: GET SCREEN TYPE FROM MAGTAB
WHTSCN	LH	R3,RBRESN,R2	:GET RESNUMBER FROM ACTIVE RESBLOCK
	CVTRES(R3,RFSAVE)	:CVT RES NUMBER TO MAGTAB ENTRY NUMBER
	LHI	R4,MAGLNG	:LENGTH OF MAGTAB ENTRY
	MR	R2,R4	R3 HAS OFFSET INTO MAGTAB
	LB	R2,MAGTAB+MAGSCN,R3,	:GET SCREEN TYPE
	CALL(FMTSCN,RFSAVE)	:FORMAT THE SCREEN
	CALL(SNDBAN,RFSAVE)	:SEND THE BANNER
	LIS	RRETC,0
	INVOKE(RETCMD)


: HELCMD - HELP COMMAND ROUTINE
 
	PROC(HELCMD)
	CHAIN(HLSAVE)
:
	LIS	R2,1		:SET THE HELP INDICATOR TO MAKE SNDBAN
	STB	R2,VARHEL,,	:SENDING THE HELP MENU (VAR. RESET IN SNDBAN)
	LIS	R2,0
	STB	R2,AUBSCN,RUBLK	:CLEAR OUT SCREEN FORMAT TYPE
	L	R2,AUBARB,RUBLK	 :GET ACTIVE RES
	JNFS	WHTSC1          :JUMP IF ONE EXISTS
	LIS	R2,SCNPAR	:DEFAULT SCREEN TYPE
	CALL(FMTSCN,HLSAVE)	:FORMAT THE SCREEN
	LIS	RRETC,0	:NO BANNER NEED BE SEND
	INVOKE(RETCMD)
:
: GET SCREEN TYPE FROM MAGTAB
WHTSC1	LH	R3,RBRESN,R2	:GET RESNUMBER FROM ACTIVE RESBLOCK
	CVTRES(R3,HLSAVE)	:CVT RES NUMBER TO MAGTAB ENTRY NUMBER
	LHI	R4,MAGLNG	:LENGTH OF MAGTAB ENTRY
	MR	R2,R4	R3 HAS OFFSET INTO MAGTAB
	LB	R2,MAGTAB+MAGSCN,R3,	:GET SCREEN TYPE
	CALL(FMTSCN,HLSAVE)	:FORMAT THE SCREEN
	CALL(SNDBAN,HLSAVE)	:SEND THE BANNER
	LIS	RRETC,0
	INVOKE(RETCMD)

PROC(RPTCMD)
CHAIN(RPTCSV)

:RPT function key

        lhi     r2,$0 0D2        :R
        stb     r2,cmddat
        lis     r2,1
        j       pfkhit

PROC(ANKCMD)
CHAIN(ANKCSV)

:ARNK function key

        lhi     r2,$0 0B0        :0 (zero)
        stb     r2,cmddat
        lhi     r2,$0 0C1        :A
        stb     r2,cmddat+1
        lis     r2,2
        j       pfkhit

PROC(UMSCMD)
CHAIN(UMSCSV)

:UMSG functin key

        lhi     r2,$0 0D5        :U
        stb     r2,cmddat
        lis     r2,1
        j       pfkhit

PROC(XITCMD)
CHAIN(XITCSV)

:XITN function key

        lhi     r2,$0 0D8        :X
        stb     r2,cmddat
        lhi     r2,$0 0C9        :I
        stb     r2,cmddat+1
        lis     r2,2
        j       pfkhit

PROC(IGNCMD)
CHAIN(IGNCSV)

:IGN function key

        lhi     r2,$0 0C9        :I
        stb     r2,cmddat
        lis     r2,1
        j       pfkhit

PROC(ENDCMD)
CHAIN(ENDCSV)

:ET function key

        lhi     r2,$0 0C5        :E
        stb     r2,cmddat
        lis     r2,1
        j       pfkhit

pfkhit  st      r2,cdrdsv+4,,   :store length of new command
        lhi     r3,carlon
        clb     r3,aubcrl,rublk :is CARL on?
        je      notmon          :go process cmd as if typed in
        la      r2,nclpfk,,     :"Function key valid only in CARL mode"
        call(sendit,cmdsv)
        call(newlin,cmdsv)
        invoke(retcmd)

:DSCCMD  Handle disconnect command

PROC(DSCCMD)
CHAIN(DCSAV)
	TRLOG(UDISC,DCSAV)
	TRPORT(UDISC,DCSAV)
	LIS	R2,AUBDSC
	STH	R2,AUBSTA,R1	:SET STATUS TO 'DISCONNECTED'
	LIS	R4,0
	STB	R4,AUBSCN,RUBLK
	L	R2,GMT,,	:SAVE TIME
	ST	R2,AUBTIM,R1
	L	R2,AUBARB,RUBLK	:GET ARB
	JE	DSCC1		:NO ARB FOUND
	L	R3,RBIATA,R2	:GET RES IA TA
	CALL(BINSCH,DCSAV)
	LR	RRETC,RRETC	:TEST RETCODE
	JN	DSCC1		:NOT FOUND!!!
:MAY WANT TO CRASH OR SOMETHING HERE
	CALL(R2UDEL,DCSAV)
DSCC1	CALL(UNLKKB,DCSAV)
	LI	R2,GDBYE
	INVOKE(ZAPPRT)


:SHUTCMD  Set host shut.

PROC(SHTCMD)
CHAIN(SHTSV)
        LHI     R2,SHTMON
        SBT     R2,SHTMSK,,
        CALL(SHUTIT,SHTSV)      :SHUT MATS (IF NOT ALREADY SHUT)
	LA	R2,HSHUT,,	:LOAD MSG ADDR
	CALL(SENDIT,SHTSV)
	CALL(NEWLIN,SHTSV)
	INVOKE(RETCMD)


:ANSCMD  Set host answered.

PROC(ANSCMD)
CHAIN(ANSSV)
:
: Entry of the ANSWER command by a programmer or monitor will answer
: MATS regardless of any other process which may have shut it.
:
        LIS     R2,0
        STH     R2,SHTMSK,,     :SHOW NO LONGER SHUT BY ANY PROCESS
        CALL(ANSWIT,ANSSV)      :ANSWER MATS
	LA	R2,HANSWR,,	:LOAD MSG ADDR
	CALL(SENDIT,ANSSV)
	CALL(NEWLIN,ANSSV)
	INVOKE(RETCMD)


:SETMSG  LOG-SET-CMD  Set LOGMSG.

PROC(SETMSG)
CHAIN(STMSSV)
	LA	R2,LMTEXT	:ADDR OF MESSAGE TEXT AREA
	LHI	R3,LMTLNG	:ITS LENGTH
	LIS	R4,0		:CLEAR TO ZEROS
	CALL(CLEAR,STMSSV)
	LR	R3,R2		:ADDR TO R3
	LHI	R2,LMTLNG	:MAX # OF CHARS TO READ
	LCS	R0,1		:NO TERMINATING CHAR
	CALL(READ,STMSSV)
	LR	R0,R0		:CHECK RETURN CODE
	JG	SETMS2		:JUMP IF OVERFLOW
	LR	R2,R2		:NUMBER OF CHARS READ
	JE	SETMS1		:JUMP IF NOTHING READ (NULL MSG)
	AHI	R2,LMTEXT-LMSTRT	:ADD LENGTH OF HEADER
	STB	R2,LOGMSG	:SAVE LENGTH OF LOGMSG
	LA	R2,MSGSET,,	:'MSG SET'
	J	SMRTN

SETMS1	STB	R2,LOGMSG	:STORE THE ZERO AS ITS LENGTH
	LA	R2,MSCLRD,,	:'MSG CLEARED'
	JFS	SMRTN

SETMS2	LI	R2,MSOVFL	'MSG TOO LONG'

SMRTN	CALL(SENDIT,STMSSV)
	CALL(NEWLIN,STMSSV)
	INVOKE(RETCMD)


:SYSMSG  SYSMSG-CMD  Print current LOGMSG.

PROC(SYSMSG)
CHAIN(SYSMSV)
	LB	R2,LOGMSG	:GET LENGTH OF LOGMSG
	LR	R2,R2		:TEST IT
	JE	SYSMS1		:JUMP IF ZERO (NO MSG)
	LA	R2,LOGMSG	:ADDR OF LOGMSG
	JFS	SYSMRT

SYSMS1	LA	R2,MSNONE,,	:'NO MSG'

SYSMRT	CALL(SENDIT,SYSMSV)
	CALL(NEWLIN,SYSMSV)
	INVOKE(RETCMD)

:
: CRLCMD - SET CARL MODE IN AUB
:
	PROC(CRLCMD)
	CHAIN(CRLSAV)
	LIS	R2,CARLON
	STB	R2,AUBCRL,RUBLK
	L	R3,AUBARB,RUBLK	:CHANGE SETTING IN RESBLOCK
	JEFS	.+6	:JUMP IF NOT ACT RES
	STB	R2,RESLIC,R3	:SET IT IN ACTIVE RES
:
:
	LA	R2,CRLSET,,	:TELL THE USER
	CALL(SENDIT,CRLSAV)
        CALL(NEWLIN,CRLSAV)
:
	INVOKE(RETCMD)
:
:
: BYPCMD  - BYPASS COMMAND - SET  CARL SWITCH IN AUB OFF
:
:
	PROC(BYPCMD)
	CHAIN(BYPSAV)
	LIS	R2,CARLOF
	STB	R2,AUBCRL,RUBLK
	L	R3,AUBARB,RUBLK	:CHANGE SETTING IN RESBLK
	JEFS	.+6	:JUMP IF NO ACTRES
	STB	R2,RESLIC,R3
:
:
:
	LA	R2,CRLRST,,
	CALL(SENDIT,BYPSAV)
        CALL(NEWLIN,CRLSAV)
:
	INVOKE(RETCMD)

        SEG     2
CDRDSV  WS      2
SERIND  BS      1
:
:
        PROC(SNDMAG)
        CHAIN(SNDMSV)
:
        LH      R4,MAGPRT,R13 :GET PORT NUMBER
        STH     R4,MGSNPT,,     :STORE IN TRACE AREA
        L       R4,GMT,,                :GET TIME
        ST      R4,MGSNTM,,             :STORE IT IN TIME  TRACE
        LH      R4,MAGNUM,R13 :GET RES NUMBER
        STH     R4,MGSNRS,,             :STORE IT IN TRACE AREA
	OI	R4,$0 80	:TURN ON HIGH ORDER BIT
        STB     R4,CMDRES       :STORE IT IN OUTPUT STRING
        LB      R4,CMDIA,,       :LOAD IA
        STB     R4,MGSNIA,,             :STORE IT
        LB      R4,CMDTA,,   :LOAD TA
        STB     R4,MGSNTA,,             :STORE IT
:
        LR      R5,R2           :save address of string
        LA      R2,MGSNTR,,     :LOAD ADDR OF TRACE MSG
        CALL(TRACE,SNDMSV)
:
        LB      R4,MAGSEQ,R13 :-GET EEQUENCE NUMBER
        AIS     R4,1            :INCREMENT BY ONE
        CHI     R4,$A 256       :CHECK FOR RANGE ERROR
        JL      SEQOK           :JUMP IF OK
        LHI     R4,$A 128       :LOAD 128
SEQOK   STB     R4,MAGSEQ,R13 :STORE NEW SEQ IN MAGTB
        STB     R4,CMDSEQ,,

	LA  R8,CMDDAT
	LB	R4,MGSRIN,R13	:
	IFF(N,THEN)		:VIP Service
	  LA	R4,XLATMS,	:Load address for marspl translation process
	  LHI	R7,$083		:Load VIPTXT
	ORELSE			:MG2946
	  LIS	R4,0		:No skip
	  LHI   R7,$09D		:Load a EOM-C
	ENDIF
	STB	R7,SERIND,,

        LR      R7,R3           :LOAD NUMBER OF BYTES TO XLATE
XLATLP  JE      NOMORE          :NO MORE TO XLATE
        LB      R10,0,R5         :load a byte
	LR	R4,R4		:Check if we need translation
	JNR	R4
        LB      R10,ASCSBR,R10,  :get xlated byte from table
        LR      R10,R10         :set cnd code
        JN      XLATOK          :make sure we don't store a zero
        LA      R2,BDXLAT,,
        CALL(SENDIT,SNDMSV)
	CALL(NEWLIN,SNDMSV)
        INVOKE(RETCMD)
	J	XLATOK		:end no marsplus case
XLATMS  LB	R10,TSLMSP,R10, :marsplus case
XLATOK  STB     R10,0,R8        :store it into CMDDAT buffer
        AIS     R8,1            :increment pointer into CMDDAT buffer
        AIS     R5,1            :increment pointer into source buffer
        SIS     R7,1            :DECREMENT COUNTER
        J       XLATLP
nomore  LB      R11,SERIND,,     :load an EOMC (ASCII US) or a VIPETX 
        stb     r11,0,r8
        lhi     r11,$0 0D       :load CR for mag to activate
        stb     r11,1,r8

	LB  R4,MGSRIN,R13
	IFF(N,THEN)
	  LR  RUBLK,R13		:Load MAG port in RUBLK
	  LIS  R0,$006		:header length
	  LA  R2,CMDSTT,,	:header address
	  CALL(SENDMS,SNDMSV)	:send it
	  LHI  R0,$00FF		:MARS+needs a DEL before every comm.
	  LH   R1,MAGPRT,R13	:store MAG port
	  SLHLS  R1,2
	  AIS   R1,2
	  JAL   R4,WCI,,	:send DEL
	  LR  RUBLK,R13		:reset MAG PTR
	  SI  R8,CMDSTT+4	:total length of command
	  LR R0,R8		:
	  LA  R2,CMDSTT+6,,	:address of command
	  CALL(SENDMS,SNDMSV)
	ORELSE
          si      r8,cmdstt-2     :total length of string
          lr      r0,r8
          la      r2,cmdstt
	  LR	RUBLK,R13	:LOAD MAG PTR INTO RUBLK
          CALL(SENDMS,SNDMSV)
	ENDIF
        LIS     R0,0
        RETURN(R1)
:
:
:
	SEG	0
MGSNTR  HC      MAGSND
MGSNPT  HS      1
MGSNTM  WS      1
MGSNRS  HS      1
MGSNIA  BS      1
MGSNTA  BS      1
MGSNDM  WS      2
:
	SEG	1
	EM

: (MATS.P2)TRCCMD.03T
:   COPIED FROM (MATS.P2)TRCCMD.02B BY BYRNE ON 12/08/81.
:   ADDED A CHECK FOR USERNAME IN MSCTAB IF AUB NOT FOUND.

:  TRCCMD.02B  COPIED FROM (MATS.PRD)TRCCMD.01K  1/27/81
:       ADDED NEWLIN CALLS TO ALLOW FOR REMOVAL OF 8D 8D FROM MESSAGES
:
: TRCCMD.01K.  Copied from (MATS.PRD)TRCCMD.NAD.  10/15/80.

	RA	$0 0A
	LO	MAIN	:GET THE ERROR MESSAGE NAMES
	PROC(TRCCMD)
:
:	TRACE COMMAND ROUTINE - MONITOR COMMAND WHICH MANIPULATES THE
:		FIELD AMTTRC FOR THE USER
:
	CHAIN(TRCSAV)
:
:	CHECK THE FIRST PARM.  MUST BE 'ON' OR 'OFF'
:
	LHI	R0,$0 00AC	:LOOK FOR COMMA
	LIS	R2,4	:MAX # OF CHAR IN FIRST PARM (INCLUDING COMMA)
	LI	R3,CHAR15	:OUTPUT AREA
	CALL(READ,TRCSAV)	:GET THE FIRST PARM
:
	CHI	R2,3	:CHECK FOR MAXIMUM VALID LENGTH
	JG	NGONOF	:INVALID - NOT ON OR OFF
:	SEE WHICH PARM IT IS
	LHI	R6,$000CF	:LOAD AN ASCII O (ALPHA)
	CLB	R6,0,R3	:CHECK FOR O (ON OR OFF)
	JN	NGONOF
	LHI	R6,$000CE	:LOAD AN 'N'
	CLB	R6,1,R3	:CHECK FOR 'N' (ON)
	JN	TRYOFF	:JUMP IF NOT 'ON'
:
:	USER ENTERED 'ON'
:
	SIS	R2,2	:LENGTH S.B. = 2
	JN	NGONOF	:USER ENTERED ONX...
:
:	ON WITHOUT A PARM IS NOT VALID
	LR	R0,R0	:CHECK ENDING CODE FROM READ
	JL	NGPRM	:ON W/O A PARM IS N.G.
	LIS	R5,1	:1 IN R5 MEANS 'ON'
:			0 IN R5 MEANS 'OFF'
	J	NXTPRM	:GET NEXT PARM
TRYOFF	LHI	R6,$00C6	:LOOK FOR OFF
	CLB	R6,1,R3	: CHECK FOR 'F'
	JN	NGONOF	:JUMP IF NOT A MATCH
	CLB	R6,2,R3
	JN	NGONOF	:JUMP IF NOT MATCH
	LIS	R5,0	:0 IN R5 MEANS 'OFF'
	LR	R0,R0	:CHECK ENDING CODE
	JL	ALLOFF	:IF NO PARMS, TURN ALL TRACE OFF
:
:
: GET NEXT PARAMETER, BUT FIRST CLEAR OUT RECEIVING FIELD
NXTPRM	LI	R2,CHAR15
	LHI	R4,$0 0A0	:CLEAR TO SPACE
	LIS	R3,15
	CALL(CLEAR,TRCSAV)
	LHI	R0,$000AF	:LOOK FOR A '/'
	LR	R3,R2	:GET ADDRESS OF FFIELD
	LIS	R2,13	:MAX NUMBER OF CHARACTERS
:		R3 STILL HAS CHAR15 ADDRESS IN IT
	CALL(READ,TRCSAV)	:GET PARM AFTER ON/OFF
:
:	SEE IF '/' FOUND --> USERNAME ENTERED
:
	LR	R0,R0	:CHECK ENDING CODE FROM READ
	JE	USRNME	:'/' FOUND --> USRNAME GIVEN
	JG	NGPRM	:13 CHAR ENTERED W/O DELIM
:
:	SEE IF 'LOGS', 'MAGS', RESCODE OR PORT# GIVEN
:
:
:	SEARCH MAG TABLE FOR A MATCH BEFORE ASSUMING PORT NUMBER
	CHI	R2,2	:WAS A 2 CHAR(RESCODE) ENTERED
	JG	TRYPRT	:JUMP IF NOT TWO CHARACTERS
TRYRES	LIS	R6,NMAG	:LOOP COUNTER
	LIS	R7,0	INDEX INTO MAGTAB
	LB	R8,0,R3	:GET FIRST CHAR ENTERED
	LB	R9,1,R3	:GET 2ND CHAR ENTERED
RESLUP	CLB	R8,MAGTAB+MAGRES,R7,	:COMPARE IT
	JN	NXTMAG	:NOT THIS ONE
	CLB	R9,MAGTAB+MAGRES+1,R7,	:COMPARE 2ND CHAR
	JN	NXTMAG
:	SET THE PORT # FOR THIS MAG
	LH	R3,MAGTAB+MAGPRT,R7,
	JE	NOTAVL	:IF ZERO PORT THEN NOT AVAIL
	AIS	R3,TRCPRT	:ADD DISPLACEMENT
	JAL	R6,SETRST	:OTHERWISE SET IT
	J	GLOBST
NXTMAG	AHI	R7,MAGLNG	:UPDATE THE INDEX
	SIS	R6,1	DECREMENT LOOP
	JG	RESLUP
:	CHECK FOR A HEX PORT NUMBER
TRYPRT	LR	R4,R3	:SAVE ADDRESS OF USER ENTERED STRING
	LR	R3,R2	:LOAD NUMBER OF CHARACTERS ENTERED (FROM READ)
	LR	R2,R4	:ADDRESS FROM 2 INSTRUCTIONS ABOVE
	CALL(HEXBIN,TRCSAV)
:	IF THIS FAILS THEN A PORT NUMBER WASN'T ENTERED
	LR	R0,R0	:CHECK RETCODE
	JE	TRYLOG	:JUMP IF NOT A HEX NUMBER
:
:	P.A.T. ENTERED A PORT NUMBER
	LR	R3,R2	GET THE BINARY NUMBER INTO THE CORRECT REGISTER
	CLHI	R3,NPORT	:MAKE SURE ITS W/I OUR LIMITS
	JGE	NGPRT
	AIS	R3,TRCPRT	:ADD PORT DISPLACEMENT
	JAL	R6,SETRST
	J	GLOBST
:
:
:
:	R3 HAS # OF CHARACTERS ENTERED
:	R2 HAS ADDRESS OF CHARACTERS
TRYLOG	CHI	R3,4	:IS PARM CORRECT LENGTH
	JG	NGPRM	:JUMP IF NOT
	LHI	R6,$000CC	:LOOK FOR 'L'
	CLB	R6,0,R2
	JN	TRYMAG
	LHI	R6,$000CF	:LOOK FOR 'O'
	CLB	R6,1,R2
	JN	NGPRM
	LHI	R6,$000C7	:LOK FOR 'G'
	CLB	R6,2,R2
	JN	NGPRM
	LHI	R6,$00D3	:LOOK FOR 'S'
	CLB	R6,3,R2
	JN	NGPRM
:
:	LOGS WAS ENTERED
	LHI	R3,TRCLOG	:GET LOG BIT NUMBER
	JAL	R6,SETRST
	J	GLOBST
:	SEE IF USER ENTERED 'MAGS'
:
TRYMAG	LHI	R6,$0 0CD	:LOOK FOR 'M'

	CLB	R6,0,R2
	JN	NGPRM
	LHI	R6,$0 0C1	:LOOK FOR 'A'
	CLB	R6,1,R2
	JN	NGPRM
	LHI	R6,$0 0C7	:LOOK FOR 'G'
	CLB	R6,2,R2
	JN	NGPRM
	LHI	R6,$0 0D3	:LOOK FOR 'S'
	CLB	R6,3,R2
	JN	NGPRM
:
:	SET INDIVIDUAL PORTS FOR THOSE MAGS ALREADY AVAILABLE
	LIS	R8,NMAG	:LOOP COUNTER
	LIS	R7,0	:INDEX
MAGLUP	LH	R3,MAGTAB+MAGPRT,R7,
	JEFS	UPINDX	:IF NO PORT , THEN SKIP
	AIS	R3,TRCPRT	:ADD THE TRACE PORT OFFSET
	JAL	R6,SETRST	:SET/RESET THIS PORT
UPINDX	AHI	R7,MAGLNG	:UPDATE INDEX
	SIS	R8,1	DECREMENT LOOP COUNTER
	JGBS	MAGLUP
:
:	SET THE GLOBAL MAG SWITCH
	LI	R3,TRCMAG
	JAL	R6,SETRST
	J	GLOBST
:
:
:
:
:	SET OR REST THE BIT WHOSE NUMBER IS IN R3
:	BASED ON ON/OFF VALUE IN R5
:
SETRST	LR	R5,R5	:TEST FOR 'ON'(1)
	JG	SETT
RESETT	RBT	R3,AMTTRC,RUBLK
	LI	R2,TRCRST	:SEND TRACE RESET MSG
	JR	R6
SETT	SBT	R3,AMTTRC,RUBLK
	LI	R2,TRSETT	:SEND TRACE SET MSG
	JR	R6
:
:
:
: ALLOFF - TURN OFF EVERYTHING FOR THIS GUY
ALLOFF	LI	R2,AMTTRC,RUBLK
	LHI	R3,TRBLNG
	LIS	R4,0
	CALL(CLEAR,TRCSAV)
	LI	R2,TRCRST	:SET TRACE RESET MSG
	JAL	R6,SETRST
:
:	CREAT NEW GLOBAL TRACE STRING
GLOBST	CALL(GBLTRC,TRCSAV)
:
DONE	CALL(SENDIT,TRCSAV)
        CALL(NEWLIN,TRCSAV)
	CALL(NEWLIN,TRCSAV)	:MOVE CURSOR TO NEW LINE
:
	INVOKE(RETCMD)
:
	SEG	0
CHAR15	BS	15
	SEG	1
: P.A.T. ENTERED A USERNAME
:
: SEE IF USER GAVE AGENT IDENTIFIER
:
USRNME	LHI	R0,$0 0A0	:SPACE IS DELIMITER
	LIS	R2,3	:MAX NUM OF CHAR
	LI	R3,CHAR15+12	:MOVE IN AFTER USERNMAE
	CALL(READ,TRCSAV)
	LR	R0,R0
	JG	NGPRM	:TOO MUCH WAS ENTERED
	LI	R2,CHAR15	:POINT TO USERNAME+AGID
	CALL(MATAUT,TRCSAV)
	LR	R0,R0	:WAS A MATCH FOUND
        JE      CHKMSC          :SEE IF IN MSCTAB
	LR	R2,R0
	LH	R3,AUBPRT,R2	GET THE USERS PORT
	JE	NOTLGD	JUMP IF ZERO PORT NUMBER
	AIS	R3,TRCPRT	:ADD THE TRACE PORT OFFSET
	JAL	R6,SETRST
	J	GLOBST
:
:
CHKMSC  LIS     R3,$A 12        :LENGTH OF USER NAME
        LA      R4,MSCTAB+CCBUNM,,  :ADDR OF USERNAME TO COMPARE
        CALL(COMSTR,TRCSAV)         :COMPARE USERNAMES
        LR      R0,R0               :ARE THEY EQUAL ?
        JN      NOTLGD              :NO, NOT FOUND THEN
        LH      R3,MSCTAB+CCBPRT,,  :GET PORT #
        JE      NOTLGD              :NOT LOGGED IF PORT# = 0
        AIS     R3,TRCPRT           :ADD THE TRACE PORT OFFSET
        JAL     R6,SETRST    
        J       GLOBST
:
:
:
: RES SYSTEM NOT AVAILABLE
:
NOTAVL	LI	R2,MAGNA
	J	DONE
:
:
NGONOF	LI	R2,NOTONF
	J	DONE
:
NGPRM	LI	R2,BADPRM
	J	DONE
:
: USER NOT LOGGED ON TO A PORT
NOTLGD	LI	R2,NOUSER
	J	DONE
:
: USER ENTERED A PORT NUMBER TOO HIGH
:
NGPRT	LA	R2,NGPORT,,
	J	DONE

: (MATS.P2)QRYCMD.04T
:   COPIED FROM (MATS.P2)QRYCMD.03T BY BYRNE ON 12/08/81.
:   ADDE A CHECK FOR USERNAME IN MSCTAB IF AUB NOT FOUND.

:  QRYCMD.03T COPIED FROM (MATS.P2)QRYCMD.02B  BY T. BYRNE.
:       REMOVED NEWLIN CALL FOR FITTING ALL MESSAGES WITHOUT OVER-
:       WRITING ON THE SCREEN.  10/15/81.
 
:  QRYCMD.02B COPIED FROM (MATS.P2)QRYCMD.01K
:       ADDED NEWLIN CALLS TO ALLOW 8A 8D REMOVAL IN MESSAGES
:
: QRYCMD.01K.  Copied from (MATS.DEV)QRYCMD.NXX.  10/15/80.

	RA	$00A
	LO	MAIN
	PROC(QRYCMD)
	CHAIN(QRYSAV)
	LHI	R13,AUB440	PRELOAD THIS VALUE FOR LATER
	LA	R2,PARM15,,	:FIELD TO HOLD PARMS TO CMD
	LHI	R4,$00A0	:CLEAR TO SPACE
	LIS	R3,15	:LENGTH OF FIELD
	CALL(CLEAR,QRYSAV)
:
: NOW FIGURE OUT WHAT THE USER ENTERED
:
	LHI	R0,$00AF	:LOOK FOR A SLASH '/'
	LR	R3,R2	:ADDRESS OF PARM15
	LIS	R2,13	:MAX NUM OF CHAR BEFORE ITS FOUND
	CALL(READ,QRYSAV)
:
: SEE IF '/' FOUND, IF SO A USERNAME WAS ENTERED
:
	LR	R5,R2	:SAVE NUMBER OF CHAR READ INTO PARM15
	JE	BDPRM	:JUMP IF NOTHING ENTERED
	LR	RRETC,RRETC	:CHECK RETCODE FROM READ
	JE	USERNM	:JUMP IF '/' FOUND
	JG	BDPRM	:TOO MANY CHAR ENTERED
:
: END OF DATA W/O DELIMITER, THEREFORE SEE IF
: REQUESTER ENTERED A PORT NUM OR 'NAMES'
:
	LR	R2,R3	:NEED ADDR OF PARM15 IN R2
	LR	R3,R5	:NUM OF CHAR ENTERED
	CALL(HEXBIN,QRYSAV)
: IF THIS FAILS, THEN A PORT NUMBER WASN'T ENTERED
	LR	RRETC,RRETC	:CHECK RETCODE
	JE	TRYNME	:JUMP IF NOT A PORT NUMBER
:
: REQUESTOR ENTERED A PORT NUM, WHICH IS IN R2
:
	CLHI	R2,NPORT	:MAKE SURE ITS W/I OUR LIMITS
	JGE	BDPORT	:JUMP IF IT ISNT
	LR	R7,R2	SAVE THE PORT NUMBER
	SLHLS	R2,2	MULTIPLY BY 4 AS INDEX TO P2UTAB
	L	R6,P2U,R2	:GET THE USERBLOCK ADDRESS, IF ANY
	JE	PORTNA	:JUMP IF PORT NOT ACTIVE
	JL	LOGING	JUMP IF SOMEON IS LOGGING ON
:
: CLEAR OUT THE MESSAGE AREA AND TELL THE
: REQUESTOR WHO'S ON THE PORT (OR WHERE THE USER IS)
:
TELPAT	LA	R2,QRYPRT,,
	LHI	R3,LQRYPT
	LHI	R4,$00A0
	CALL(CLEAR,QRYSAV)
	LHI	R8,$00AF	:PUT BACK THE SLASH
	STB	R8,QRYPRT+6,,
:
: SEE WHAT TYPE OF USER IS ON THE PORT
:
	LIS	R7,LUDRUR	:IS THIS A MAG PORT?
	CLB	R7,AUBTYP,R6
	JNFS	FILLMG	:JUMP IF NOT
	LH	R7,MAGRES,R6	:GET RES CODE
	STH	R7,QRYPRT+8,,
	LH	R7,MAGSTA,R6	GET RES STATUS
	STH	R7,QRYPRT+4,,	:AND PUT IT IN AGID FIELD
	J	FILMG2	:FINISH FILLING THE MSG
:
: FILL IN QRYPRT WITH USERNAME AND AGID
:
FILLMG	LIS	R4,12
	LA	R2,AUBUSR,R6
	LA	R3,QRYPRT+7,,
	CALL(TFR,QRYSAV)
	LH	R4,AUBAID,R6
	STH	R4,QRYPRT+4,,
:
: FILL IN THE PRT NUMBER OR THE LETTERS 'DSC'
: THIS ROUTINE IS USED BY 'Q NAMES' ALSO.
FILMG2	LH	R10,AUBPRT,R6	:GET THE USER PORT NUMBER
	JE	DSCPRT	JUMP IF HE'S DISC
	LHI	R8,$00B0	:PUT IN A LEADING  ZERO
	STB	R8,QRYPRT,,
	LA	R8,QRYPRT+1,,
	LIS	R9,1
	LA	R10,1,R6	POINT TO 2ND BYTE OF PORT NUM
	CALL(BINHEX,QRYSAV)
	JFS	SNDIT
:
: USER IS DISCONNECTED
DSCPRT	LHI	R9,$00E4F3	:'DS'
	STH	R9,QRYPRT,,
	LHI	R9,$00E3	:'C'
	STB	R9,QRYPRT+2,,
SNDIT	LHI	R8,$00AD
	STB	R8,QRYPRT+3,,
	CLB	R13,AUBTTY,RUBLK	:IS THIS A 440
	JNFS	SNDIT2	:JUMP IF NOT
	CALL(NEWLIN,QRYSAV)
SNDIT2	LA	R2,QRYPRT,,
	LHI	R0,LQRYPT
	CALL(SENDMS,QRYSAV)
	CALL(NEWLIN,QRYSAV)
:
:
RTRN	LIS	RRETC,0
	INVOKE(RETCMD)
:
:
: REQUESTOR ENTERED A USERNAME
: NOW GET THE AGENTID AND PUT IT AFTER THE USERNAME IF PARM15
:
USERNM	LHI	R0,$00A0	:SPACE IS DELIMITER
	LIS	R2,3	:MAX NUM OF CHAR
	LA	R3,12,R3	:POINT PAST USERNMAE
	CALL(READ,QRYSAV)
	LR	RRETC,RRETC	TEST THE RETCODE
	JG	BDPRM	:JUMP - TOO MUCH ENTERED
	LA	R2,PARM15,,
	CALL(MATAUT,QRYSAV)	:FIND A MATCH
	LR	RRETC,RRETC	:WAS A MATCH FOUND
        JE      CKMSC           :NONE, TRY MSCTAB
	LR	R6,R0	PUT AUB ADDRESS IN R6
	J	TELPAT	FORMAT MESSAGE TO REQUESTOR
:
:
CKMSC   LIS     R3,$A 12        :LENGTH OF USERNAME
        LA      R4,MSCTAB+CCBUNM,,  :ADDR OF USERNAME TO COMPARE
        CALL(COMSTR,QRYSAV)         :COMPARE USERNAMES
        LR      R0,R0               :ARE THEY EQUAL ?
        JN      NOMTCH              :NO, NOT FOUND THEN
        LA      R6,MSCTAB,,         :MSCTAB INSTEAD OF AUB
        J       TELPAT              :FORMAT MESSAGE TO REQUESTOR
:
:
:
: SEE IF REQUESTED 'NAMES'
:
TRYNME	CLHI	R5,5	:WAS CORRECT NUM OF LETTERS ENTERED
	JN	BDPRM	JUMP IF NOT
	L	R9,NAMES	:GET THE LITERAL 'NAME'
	CL	R9,PARM15,,	:COMPARE IT TO FIELD IN PARM15
	JN	BDPRM	:JUMP IF NOT THE SAME
	LB	R9,NAMES+4	GET THE 'S'
	CLB	R9,PARM15+4,, : AND CHECK IT TO USER ENTERED DATA
	JN	BDPRM	:JUMP IF NOT NAMES
	L	R6,AUTACT	:GET FIRST ACTIVE AUB
	JE	NOLOGS	:JUMP IF NOONE IS LOGGED ON
:
: CHAIN THRU THE AUBS, FORMATTING 4 NAMES PER LINE
:
: FIRST SEE IF REQUESTOR IS ON A 440 AND IF SO SEND A NEWLIN
	CLB	R13,AUBTTY,RUBLK
	JNFS	NMLOOP
	CALL(NEWLIN,QRYSAV)
NMLOOP	LA	R2,LINE80,,	:OUTPUT LINE
	LHI	R4,$00A0	:CLEAR TO SPACE
	LHI	R3,80
	CALL(CLEAR,QRYSAV)
:
: R2 HAS ADDRESS OF LINE80
	LR	R12,R2	SAVE ADDRESS OF LINE80
	LIS	R11,4	:FOUR NAMES PER LINE
: FILL IN PORT NUMBER
FILPRT	LHI	R5,$00B0	START WITH A ZERO
	STB	R5,0,R12
	LH	R10,AUBPRT,R6
	JEFS	PRTDSC	JUMP IF ZERO
	LIS	R9,1	:ONE BYTE TO CONVERT
	LA	R8,1,R12	OUTPUT ADDRESS
	LA	R10,1,R6	:GET THE 2ND BYTE OF PORT
	CALL(BINHEX,QRYSAV)
	JFS	DASH
PRTDSC	LHI	R9,$00E4F3	:DS
	STH	R9,0,R12
	LHI	R9,$00E3	:C
	STB	R9,2,R12
DASH	LHI	R9,$00AD	: '-'
	STB	R9,3,R12
: : MOVE IN AGENT ID
	LH	R9,AUBAID,R6
	STH	R9,4,R12
: STORE IN A SLASH
	LHI	R9,$00AF
	STB	R9,6,R12
: TRANSFER USERNAME
	LIS	R4,12
	LA	R2,AUBUSR,R6
	LA	R3,7,R12
	CALL(TFR,QRYSAV)
:
: GET THE NEXT AUB
:
	L	R6,AUBNXT,R6
	JEFS	SNDLIN	:JUMP IF NO MORE
:
: INCREMENT OUTPUT POINTER
:
	LA	R12,20,R12
:
: SEE IF WE CAN PUT MORE NAMES IN THIS LINE
:
	SIS	R11,1
	JG	FILPRT	JUMP IF WE CAN
:
: SNDLIN - SEND THE LINE TO THE REQUESTOR
:
SNDLIN  LA      R2,LINE80,,
	LHI	R0,80
	CALL(SENDMS,QRYSAV)
:
: SEE IF ANY MORE USERNAMES TO PRESENT
:
	LR	R6,R6
	JN	NMLOOP	JUMP IF THERE ARE
	LIS	RRETC,0
	INVOKE(RETCMD)
:
: ERROR AND MESSAGE ROUTINES
:
BDPORT	LA	R2,NGPORT,,
	CALL(SENDIT,QRYSAV)
	J	RTRN
:
BDPRM	LA	R2,BADPRM,,
	CALL(SENDIT,QRYSAV)
        CALL(NEWLIN,QRYSAV)
	J	RTRN
:
PORTNA	LA	R2,FREPRT,,
	CALL(SENDIT,QRYSAV)
        CALL(NEWLIN,QRYSAV)
	J	RTRN
:
LOGING	LA	R2,LOGGON,,
	CALL(SENDIT,QRYSAV)
        CALL(NEWLIN,QRYSAV)
	J	RTRN
:
NOMTCH	LA	R2,NOUSER,,
	CALL(SENDIT,QRYSAV)
        CALL(NEWLIN,QRYSAV)
	J	RTRN
:
NOLOGS	LA	R2,NOLOG,,
	CALL(SENDIT,QRYSAV)
        CALL(NEWLIN,QRYSAV)
	J	RTRN
:
:
: DATA AREAS
:
	SEG	0
	WS	0
QRYSTT	EQ	.
QRYPRT	AC	!XXX-XX/XXXXXXXXXXXX!
LQRYPT	EQ	.-QRYSTT
:
	WS	0
:
	WS	0
PARM15	BS	15
	WS	0
LINE80	BS	80
:
	SEG	1
: READ ONLY
NAMES	AC	/NAMES/
:
:


: (MATS.P2)FRCCMD.05K
:       COPIED BY ADAMS FROM (MATS.P2)FRCCMD.04S ON 12/17/81
:       ADDED CALLS TO CUSTAR AND CUSERV FOR MATS STATS
:       PROJECT, PHASE 2.

: (MATS.P2)FRCCMD.04S
:    Copied by Gimnicher from (MATS.P2)FRCCMD.03W
:    Moved setting of AUBDRN to proper location.

: (MATS.P2)FRCCMD.03W
: Copied from (MATS.P2)FRCCMD.02B on 08/20/81
: Added MATS STATS changes
:
:  FRCCMD.02B COPIED FROM (MATS.P2)FRCCMD.01K  1/27/81
:       ADDED CALLS TO ALLOW REMOVAL OF 8A 8D ON MESSAGES
:
: FRCCMD.01K.  Copied from (MATS.DEV)FRCCMD.NXX.  10/15/80.

	RA	$00A
	LO	MAIN	:GET MSGS IN MSGS.STR
:
: FORCE - CLEAR UP ALL THE RESOURCES TAKEN UP BY THE
: USER WHOSE NAME WAS SUPPLIED, OR WHO IS ON THE SUPPLIED
: PORT NUMBER
	PROCS(FRCCMD,$00D)
	CHAINS(FRCSAV,$00D)
	LA	R2,PARM15,,	:PARM15 IS IN QRYCMD
	LHI	R4,$00A0	:CLEAR TO A SPACE
	LIS	R3,15
	CALL(CLEAR,FRCSAV)
:
: NOW FIGURE OUT WHAT THE P.A.T. ENTERED
:
	LHI	R0,$00AF	:LOOK FOR A SLASH '/'
	LR	R3,R2	:ADDR OF PARM15
	LIS	R2,13	:MAX NUM OF CHAR BEFORE '/' IS FOUND
	CALL(READ,FRCSAV)
:
: SEE IF SLASH FOUND, IF SO A USERNAME WAS ENTERED
:
	LR	R5,R2	:SAVE NUM OF CHAR READ
	JE	PRMBD	JUMP IF NOTHING ENTERED
	LR	RRETC,RRETC	:CHECK RETCODE FROM READ
	JE	NAMUSR	:JUMP IF '/' FOUND
	JG	PRMBD	:TOO MANY CHAR ENTERED
:
: END OF DATA WITHOUT DELIMITER, THEREFORE MUST BE A PORT NUMBER
	LR	R2,R3	:NEED ADDRESS OF PARM15
	LR	R3,R5	NUM OF CHAR ENTERED
	CALL(HEXBIN,FRCSAV)
: IF HEXBIN FAILS, THEN A HEX NUMBER WASN'T ENTERED
	LR	RRETC,RRETC	:CHECK RETCODE
	JE	PRMBD	:BAD PARM
:
: REQUESTER ENTERED A HEX NUM - MAKE SURE ITS A PORT
:
	CLHI	R2,NPORT	:MAKE SURE ITS W/I OUR LIMITS
	JGE	PORTBD	JUMP IF NOT
	LR	R2,R2	:GET PORT NUMBER
	JE	PORTBD	PORT ZERO IS NO GOOD
	SLHLS	R2,2	MULT BY 4 AS INDEX TO P2U
	L	R6,P2U,R2	:GET USERBLOCK
	JE	NAPORT	:PORT NOT ACTIVE
:
: FORCE THE USER OFF THE SYSTEM
:
FRCAUB	LR	R8,RUBLK	SAVE CALLER'S RUBLK
	LR	RUBLK,R6	GET FORCE'D RUBLK
	JL	FRCPRT	:JUMP IF LOGON IN PROCESS
	LIS	R12,LUDRUR	:IS THIS A RES SYSTEM BEING FORCED
	CLB	R12,AUBTYP,RUBLK	:WELL?
	JE	FRCMAG	:YES IT IS.. JUMP
TRCFRC	TRPORT(UFORCD,FRCSAV)	:TRACE WHILE AUB RUBLK EXISTS
	TRLOG(UFORCD,FRCSAV)
	LH	R7,AUBPRT,RUBLK	:SEE IS DISCONNECTED
	JN	FRCPRT	:JUMP IF NOT
: FORCE DISCONNECTED USER
:
: REMEMBER, A MONITOR CAN'T BE DISCONNECTED, THEREFORE NO NEED
: TO CHECK USER TYPE
	LIS	R12,LUDNUR	SEE IF FORCEE IS A USER
	CLB	R12,AUBTYP,RUBLK	WELL, IS HE?
	JN	FRCOFF	JUMP IF NOT
	LCS	R12,1	ADD -1
	AM	R12,NUMUSR	:TO NUMUSER ON SYSTEM
FRCOFF  CALL(RELAUB,FRCSAV)
        J       FRCDUN  :FORCE ID SONDE
FRCPRT  LIS     R2,DISFRC       :SET DISCONNET REASON TO FORCE OFF
        STB     R2,AUBDRN,RUBLK,:    IN AUB
 
        :IF NO RES BLOCK EXISTS, CREATE USER STARTUP AND USER
        :SERVICE RECORDS.  WE CREATE A USER STARTUP RECORD EVEN
        :THOUGH A USER STARTUP RECORD ALREADY EXISTS.  BUT SINCE
        :THE KEYS OF THE DUPLICATE RECORDS ARE IDENTICAL, THE
        :DATA BASE LOADER WILL DISCARD THE RECORD, IF IT IS NOT
        :NEEDED.

        L       R0,AUBRCH,RUBLK :TEST RES CHAIN POINTER
        IFF(E)                  :IF NO RES BLOCK EXISTS
          CALL(CUSTAR,FRCSAV)   :TO CREATE USER STARTUP RECORD
          LIS     R2,0          :INPUT - THERE IS NO RES BLOCK PTR
          LI      R3,DISFRC     :INPUT - CODE TO INDICATE A FORCE
          LR      R9,R8         :SAVE FORCER'S AUB POINTER
          LR      R8,RUBLK      :GET FORCEE'S AUB PTR (RUBLK=R1)
          CALL(CUSERV,FRCSAV)   :TO CREATE USER SERVICE RECORD
          LR      R8,R9         :RESTORE FORCER'S AUB POINTER
        ENDIF                   :IF NO RES BLOCK EXISTS

        LA      R2,FRCUSR,,     :TELL USER GOODBYTE
	CALL(ZAPPRT,FRCSAV)
FRCDUN	LR	RUBLK,R8	:RESTORE FORCOR'S RUBLK
	LA	R2,USRFRC,,	:TELL HIM FORCE IS DONE
	CALL(SENDIT,FRCSAV)
        CALL(NEWLIN,FRCSAV)
RETN	LIS	RRETC,0
	INVOKE(RETCMD)
:
FRCMAG	LA	R2,FRCUSR,,
	CALL(ZAPPRT,FRCSAV)
	LHI	R12,RESNA	:CHANGE RES STATUS IF FORCING
	STH	R12,MAGSTA,RUBLK
	L	R12,GMT,,
	ST	R12,MAGTIM,RUBLK
	LIS	R12,0
	STH	R12,MAGPRT,RUBLK
	LH	R2,MAGNUM,RUBLK	:GET RES NUMBER FOR SCREEN UPDATE
	CALL(MNUPDT,FRCSAV)
	LIS	RUBLK,0	TELL ALL MONITORS
	CALL(MONSND,FRCSAV)
        LR      R3,R2           : RES NUMBER FOR KILFRE
        CALL(KILFRE,FRCSAV)
	J	FRCDUN	:FORCE IS DUN
:
:
: P.A.T. ENTERED A USERNAME
NAMUSR	LHI	R0,$00A0	:SPACE IS DELIMITER
	LIS	R2,3	:MAX NUM OF CHAR
	LA	R3,12,R3	:POINT PAST USERNAME
	CALL(READ,FRCSAV)
	LR	RRETC,RRETC	:CHECK RETCODE
	JG	PRMBD	:TOO MUCH READ
	LA	R2,PARM15,,
	CALL(MATAUT,FRCSAV)	:SEE IF USER IS ON SYSTEM
	LR	RRETC,RRETC	WAS A MATCH FOUND?
	JE	NOMATH	JUMP IF NOT
	LR	R6,R0	:PUT AUBLK ADDR IN R6
	J	FRCAUB	:JUMP TO FORCE THIS AUB
:
: ERROR/INFORMATIONAL MESSAGE ROUTINES
:
: INVALID PARAMETER TO COMMAND
PRMBD	LA	R2,BADPRM,,
	CALL(SENDIT,FRCSAV)
        CALL(NEWLIN,FRCSAV)
	J	RETN
:
: PRT NUMBER OUT OF BOUNDS
PORTBD	LA	R2,NGPORT,,
        CALL(SENDIT,FRCSAV)
        CALL(NEWLIN,FRCSAV)
	J	RETN
:
: PORT NOT ACTIVE
NAPORT	LA	R2,FREPRT,,
        CALL(SENDIT,FRCSAV)
        CALL(NEWLIN,FRCSAV)
	J	RETN
:
: NO MATCH ON USERNAME ENTERED
NOMATH	LA	R2,NOUSER,,
        CALL(SENDIT,FRCSAV)
        CALL(NEWLIN,FRCSAV)
	J	RETN
:
:

: BRDCMD.01K.  Copied from (MATS.DEV)BRDCMD.NXX.  10/15/80.

	RA	$00A
	LO	MAIN
	PROC(BRDCMD)
	CHAIN(BRDSAV)
	SEG	0
: BROADCAST MESSAGE AREA
:			CHAR COUNT
BDCSTT	EQ	.
BDCHDR	SC	/HH:MM:SS"87"87 BROADCAST FROM XXXXXXXXXXXX:/
LBDCHD	EQ	.-BDCSTT
BDCSTT	EQ	.
BDCMSG	BS	81	:THIS LINE WILL LOOK LIKE AN SC CONSTANT
LBDCMS	EQ	.-BDCSTT
	SEG	1
	LCS	R0,1	:NO DELIMITER - READ TILL END OF DATA
	LA	R3,BDCMSG+1,,	:LEAVE A BYTE IN THE BEG. TO HOLD THE 
:			CHAR COUNT
	LHI	R2,LBDCMS-1	:NUM OF BYTES IN STRING 
	CALL(READ,BRDSAV)
:
: THE BROADCAST MESSAGE IS NOW IN BDCMSG
: NOW PUT IN THE TIME STAMP
	LIS	R4,8
	LA	R5,BDCHDR+1,,
	L	R3,GMT,,
	CALL(TMSTMP,BRDSAV)
:
	LR	R7,R2	GET NUMBER OF BYTES IN MESSAGE
	JE	RTN	JUMP IF NONE
	STB	R2,BDCMSG,,	:STORE THE CHARACTER COUNT IN THE MSG.
: GET THE USERNAME OF THE SENDER AND PUT IT IN THE HEADER
	LIS	R4,12
	LA	R2,AUBUSR,RUBLK
	LA	R3,BDCHDR+LBDCHD-13,,
	CALL(TFR,BRDSAV)
	LA	R2,BDCHDR,,	:GET ADDRESS OF STRING TO SEND
	JAL	R8,SNDLUP	:AND SEND IT TO ALL USERS
	LA	R2,BDCMSG,,
	JAL	R8,SNDLUP
RTN	INVOKE(RETCMD)
:
SNDLUP	LR	R13,RUBLK	:SAVE SENDERS AUB ADDRESS
	L	RUBLK,AUTACT	:ANY USER'S ACTIVE?
	JE	SNDMTR	JUMP IF NOT
SID	CALL(SENDIT,BRDSAV)
	CALL(NEWLIN,BRDSAV)
	L	RUBLK,AUBNXT,RUBLK	GET NEXT AUB
	JNBS	SID	JUMP IF NO MORE ACTIVE USERS
:
SNDMTR	LA	RUBLK,AMTTAB,,	:GET FIRST MONITOR ADDRESS
	LIS	R4,NMON
SNDLP2	LH	R0,AMTPRT,RUBLK	:GET PORT NUMBER
	JEFS	NXTMTR	JUMP IF NOONE HOME
	CALL(SENDIT,BRDSAV)
	CALL(NEWLIN,BRDSAV)
NXTMTR	AHI	RUBLK,AMTLNG	:GET NEXT MONITOR ADDRESS
	SIS	R4,1	AND MAKE SURE ITS A SYSBLK
	JG	SNDLP2	:JUMP IF IT IS
	LR	RUBLK,R13
	JR	R8

: (MATS.P2)QUTCMD.03L
:  Copied by Cardini from (MATS.P2) on 11/11/83
:  in order to disable the use of 'DONE' command for user allow
:  to access only one service (single access).
:
: (MATS.P2)QUTCMD.02W
: Copied from (MATS.P2)QUTCMD.01K on 08/20/81
: Added MATS STATS changes
:
: QUTCMD.01K.  Copied from (MATS.PRD)QUTCMD.NAD.  10/15/80.

	RA	$00A
	LO	MAIN	:GET MSGS.STR
	PROC(QUTCMD)
	CHAIN(QUTSAV)

	LHL	R2,AUBSER,RUBLK,	:GET SINGLE OR MULTIPLE ACCESS INDIC.
	IFF(N,THEN)			:SINGLE ACCESS
	  LA	R2,NSACMD,,		:'INVALID COMMAND IN SINGLE ACCESS CONTEXT'
	  CALL(SENDIT,QUTSAV)		:
	  CALL(NEWLIN,QUTSAV)		:
	  INVOKE(RETCMD)		:
	ENDIF
:
: RELEASE THE ACTIVE RB AND FREE UP THE RESOURCES
:
	L	R2,AUBARB,RUBLK	:GET ACTIVE RES BLOCK
	JNFS	CALREL	:JUMP IF ONE EXISTS
	CALL(CIB,QUTSAV)
	INVOKE(GETRES)
:
: HAVE RELRB FREE UP THE RESOURCE (RESIATA, ETC)
:
CALREL  LIS     R3,DISDON               : Set disconnect reason to done 
      	CALL(RELRB,QUTSAV)
	LR	RRETC,RRETC
	JNFS	RELERR	:JUMP IF THERE WAS AN ERROR
	CALL(CIB,QUTSAV)
	INVOKE(GETRES)
:
: RELERR - THERE WAS AN ERROR RELEASING THE ARB.  THIS CAN ONLY
: HAPPEN IF OUR RB CHAIN IS SCREWED UP.  FOR NOW, CRASH
:
RELERR	JAL	R10,CRASH,,
	BC	0,0,4*RLINK,QUTERR

: TLKCMD.01K.  Copied from (MATS.DEV)TLKCMD.NXX.  10/15/80.

	RA	$00A
	LO	MAIN	:GET LABELS IN MSGS.STR
:
: DAT AREAS :
:
	SEG	0
	WS	0
TALKSZ	BS	1
TLKSTT	EQ	.
TALKMG	BS	127
LTALKM	EQ	.-TLKSTT
:
TLKSTT	EQ	.
TLKHDR	SC	/HH:MM:SS"87"87 MSG FROM XXXXXXXXXXXX:/
LTLKHD	EQ	.-TLKSTT
	WS	0
USRNAM	BS	14
	SEG	1
	PROC(TLKCMD)
	CHAIN(TLKSAV)
:
:  CHECK WHO THE USER WANTS TO TALK TO 
:
	LHI	R0,$00AC	:READ TILL COMMA
	LHI	R2,16	:MAX CHAR FOR USERNAME/AGID
	LA	R3,TALKMG,,
	CALL(READ,TLKSAV)
:
: CHECK ENDING CODE TO MAKE SURE PARM IS VALID
:
	LR	RRETC,RRETC
	JN	BADDST	:INVALID IF > 16 OR END OF DATA
:
:	SEE IF DESTINATION IS A USERNAME OR A PORT NUMBER
:
	LR	R5,R2	SAVE NUM OF CHAR READ
	LR	R2,R3	R3 HAD ADDR OF USER ENTERED STRING (TALKMG)
	LR	R3,R5	:NUM OF CHAR ENTERED
	CALL(HEXBIN,TLKSAV)
:
: IF THIS FAILED , THE USER DIDN'T ENTER A PORT NUMBER
:
	LR	RRETC,RRETC
	JE	TRYNAM	:JUMP IF NOT A PORT NUM
	CLHI	R2,NPORT	:MAKE SURE ITS WITHIN OUR UPPER LIMIT
	JGE	BDPORT	:JUMP IF TOO LARGE
:
: R2 NOW HAS PORT NUMBER OF DESTINATION
:
SNDUSR	SLHLS	R2,2	:CONVERT PORT NUMBER TO AN INDEX
	L	R6,P2U,R2	:GET AUB/AMT ADDRESS
	JLE	FREEPT	:JUMP IF NO AUB/AMT
:
: MAKE SURE NOT TRYING TO SEND TO A MAG
:
	LIS	R7,LUDRUR
	CLB	R7,AUBTYP,R6
	JE	BADDST	:JUMP IF DEST IS A MAG
:
:READ IN MSG TO THE DEST.
:
GETUMS	LCS	R0,1
	LHI	R2,LTALKM
	LA	R3,TALKMG,,
	CALL(READ,TLKSAV)
	LR	R2,R2	:SEE HOW MAN CHAR READ
	JE	RTN
:
: PUT IN A TIME STAMP
:
	LA	R5,TLKHDR+1,,	:LEAVE ROOM FOR SC CONSTANT
	LIS	R4,8	:GET FULL TIMETSTAMP
	L	R3,GMT,,	:GET CLOCK
	CALL(TMSTMP,TLKSAV)
:
	STB	R2,TALKSZ,,	:MAKE TALKMG LOOK LIKE AN SC CONSTANT
	LIS	R4,12	:TRANSFER THE SENDERS NAME TO THE HEADER
	LA	R2,AUBUSR,RUBLK
	LA	R3,TLKHDR+LTLKHD-13,,
	CALL(TFR,TLKSAV)
	LR	R7,RUBLK	:SAVE ORIGINATING USERS BLOCK
	LR	RUBLK,R6	GET SENDERS BLK
	CALL(NEWLIN,TLKSAV)
	LA	R2,TLKHDR,,
	CALL(SENDIT,TLKSAV)
	CALL(NEWLIN,TLKSAV)
	LA	R2,TALKSZ,,
	CALL(SENDIT,TLKSAV)
	CALL(NEWLIN,TLKSAV)
	LR	RUBLK,R7	RESTORE SENDERS BLOCK
	LA	R2,MSGSNT,,	:CONFIRM MSG SENT
	J	SNDITT
:
: TRYNAM - USER MIGHT HAVE ENTERED A USERNAME
: RESCAN THE INPUT LINE TO SEE IF A '/' WAS ENTERED
:
TRYNAM	LI	R10,$00A0A0A0A0	:CLEAR OUT USERNAME AREA
	ST	R10,USRNAM,,
	ST	R10,USRNAM+4,,
	ST	R10,USRNAM+8,,
	STH	R10,USRNAM+12,,
	LIS	R10,12	:MAX NUM OF CHAR IN A USERNAME
	LR	R12,R5	:GET NUM OF CHAR READ
	LA	R2,TALKMG,,	:AND ADDR OF WHERE USERNAME WAS READ
	LIS	R9,0	INDEX REGISTER
	LHI	R13,$00AF	:SCAN PARM - '/'
FNDSLH	LB	R11,0,R9,R2	:GET USER ENTERED DATA BYTE
	CLR	R13,R11	AND COMPARE IT TO A SLASH
	JE	NAMDUN	JUMP IF IT IS
	STB	R11,USRNAM,R9,,	SAVE THE CHAR
	AIS	R9,1
	CLR	R9,R10	IS USERNAME TOO LONG
	JG	BADDST	JUMP IF SO
	SIS	R12,1
	JGBS	FNDSLH	MAKE SURE A / WAS ENTERED
	J	BADDST	:JUMP IF ONE WASNT
:
: NAMDUN - SLASH WAS FOUND, MAKE SURE ONLY ATWO MORE USER CHAR ENTERED
:
NAMDUN	SIS	R12,3	:SHOULD ONLY BE /XX LEFT
	JN	BADDST	JUMP IF THERES MORE OR LESS
	LB	R12,1,R9,R2	GET FIRST AGID CHAR
	STB	R12,USRNAM+12,,
	LB	R12,2,R9,R2	GET SECOND AGID CHAR
	STB	R12,USRNAM+13,,
	LA	R2,USRNAM,,
	CALL(MATAUT,TLKSAV)
	LR	RRETC,RRETC	DOES THIS USER EXIST?
	JE	NOMAT	JUMP IF NOT
	LR	R6,R0	:SWITCH AUB/AMT ADDRESS
	LH	R2,AUBPRT,R6	GET USERS PORT NUMBER
	JE	NOMAT	JUMP IF DISCONNECTED
	J	GETUMS	:AND JUMP TO COMMON CODE
:
: USER MESSAGE AND ERROR HANDLING ROUTINES
:
FREEPT	LA	R2,FREPRT,,	:PORT NOT ACTIVE
	JFS	SNDITT
BADDST	LA	R2,BDEST,,	:BAD DESTINATION
	JFS	SNDITT
NOMAT	LA	R2,NOUSER,,	:USER NOT LOGGED ON
	JFS	SNDITT
BDPORT	LA	R2,NGPORT,,	:PORT OUT OF BOUNDS
	JFS	SNDITT
:
SNDITT	CALL(SENDIT,TLKSAV)
	CALL(NEWLIN,TLKSAV)
RTN	LIS	RRETC,0
	INVOKE(RETCMD)

: (MATS.P2)CLSCMD.02L 
: Copied by Vaysburd from (MATS.P2)CLSCMD.01T on 11.24.81
: Implemented "CLOSE" command.
:(MATS.P2) CLSCMD.01T CREATED BY T. BYRNE 10/06/81
:  TO HANDLE THE "CLOSE" COMMAND.
: INPUT:   AMT or AUB pointer - RUBLK
:          MSCTAB(global)
:
 


        PROCS(CLSCMD,$00D)
        CHAINS(CLSSV,$00D)
 
        LA      R10,MSCTAB,,
        LHL     R11,CCBSTA,R10,                 :get active RCVR status
        CLHI    R11,CSTCNG                      :"CLOSING" status?
        IFF(E,THEN)
          LA    R2,CLOMS1,,                     
          CALL(SENDIT,CLSSV)
        ORELSE                                  :status is not "closing"
          CLHI  R11,CSTCED                      :"CLOSED" status?
          IFF(E,THEN)
            LA    R2,CLOMS2,,
            CALL(SENDIT,CLSSV)
          ORELSE
           CLHI R11,CSTWPS                      :is status CSTWPS?
           IFF(E,THEN)
            LA  R2,CLOMSA,,
            CALL(SENDIT,CLSSV)
           ORELSE
            CLHI R11,CSTDNG                     :"DROPPING" status?
            IFF(E,THEN)
              LHI       R12,CSTCNG
              STH       R12,CCBSTA,R10,         :set status to "CLOSING"
              LA        R2,CLOMS4,,
              CALL(SENDIT,CLSSV)
            ORELSE
              CLHI      R11,CSTDWN              :"DOWN" status?
              IFF(E,THEN)
                LHI     R12,CSTCED
                STH     R12,CCBSTA,R10,         :set status to "CLOSED"
                LA      R2,CLOMS3,,
                CALL(SENDIT,CLSSV)
              ORELSE
                LHI     R12,CSTCNG              :set status to "CLOSING"
                STH     R12,CCBSTA,R10,
                LA      R2,CLOMS4,,
                CALL(SENDIT,CLSSV)
                LR      R12,RUBLK               :save RUBLK
                LA      RUBLK,MSCTAB,,          :set R1 to MSCTAB ptr
                LA      R2,DROPMS,,
                LB      R0,0,R2                 :length in R0
                AIS     R2,1                    :address in R2
                CALL(SENDMS,CLSSV)
                LR      RUBLK,R12               :restore RUBLK
              ENDIF
            ENDIF
           ENDIF
          ENDIF
        ENDIF
        INVOKE(RETCMD)
: (MATS.P2)OPNCMD.02L
: Copied by Vaysburd from (MATS.P2)OPNCMD.01T on 11.24.81
: Implemented "OPEN" command.
:(MATS.P2) OPNCMD.01T CREATED BY T. BYRNE 10/06/81
:  TO HANDLE THE "OPEN" COMMAND.

:
: INPUT: AMT or AUB pointer - RUBLK
:        MSCTAB(global)
:
:
        PROCS(OPNCMD,$00D)
        CHAINS(OPNSV,$00D)

        LA      R10,MSCTAB,,
        LHL     R11,CCBSTA,R10,                 :get active RCVR status
        CLHI    R11,CSTCNG                      :"CLOSING" status?
        IFF(E,THEN)
          LHI   R12,CSTDNG
          STH   R12,CCBSTA,R10,                 :set status to "DROPPING"
          LA    R2,CLOMS8,,                     
          CALL(SENDIT,OPNSV)

        ORELSE                                  :status is not "closing"
          CLHI  R11,CSTCED                      :"CLOSED" status?
          IFF(E,THEN)
            LHI   R12,CSTDWN
            STH   R12,CCBSTA,R10,               :set status to "DOWN"
            LA    R2,CLOMS8,,
            CALL(SENDIT,OPNSV)
          ORELSE
            LA  R2,CLOMS9,,
            CALL(SENDIT,OPNSV)
          ENDIF
        ENDIF
 
        INVOKE(RETCMD)
: (MATS.P2)DRPCMD.02L
: Copied by Vaysburd from (MATS.P2)DRPCMD.01T on 11.24.81
: Implemented "DROP" command.
:(MATS.P2) DRPCMD.01T CREATED BY T. BYRNE 10/06/81
:  TO HANDLE THE "DROP" COMMAND.
:
:INPUT: AMT or AUB pointer - RUBLK
:       MSCTAB(global)
:
        PROCS(DRPCMD,$00D)
        CHAINS(DRPSV,$00D)

        LA      R10,MSCTAB,,
        LHL     R11,CCBSTA,R10,                 :get active RCVR status
        CLHI    R11,CSTCNG                      :"CLOSING" status?
        IFF(E,THEN)
          LA    R2,CLOMS1,,                     
          CALL(SENDIT,DRPSV)
        ORELSE                                  :status is not "closing"
          CLHI  R11,CSTCED                      :"CLOSED" status?
          IFF(E,THEN)
            LA    R2,CLOMS2,,
            CALL(SENDIT,DRPSV)
          ORELSE
           CLHI R11,CSTWPS                      :is status CSTWPS?
           IFF(E,THEN)
            LA  R2,CLOMSA,,
            CALL(SENDIT,DRPSV)
           ORELSE
            CLHI R11,CSTDNG                     :"DROPPING" status?
            IFF(E,THEN)
              LA        R2,CLOMS5,,
              CALL(SENDIT,DRPSV)
            ORELSE
              CLHI      R11,CSTDWN              :"DOWN" status?
              IFF(E,THEN)
                LA      R2,CLOMS6,,
                CALL(SENDIT,DRPSV)
              ORELSE
                LHI     R12,CSTDNG              :set status to "DROPPING"
                STH     R12,CCBSTA,R10,
                LA      R2,CLOMS7,,
                CALL(SENDIT,DRPSV)
                LR      R12,RUBLK               :save RUBLK
                LA      RUBLK,MSCTAB,,          :set R1 to MSCTAB ptr
                LA      R2,DROPMS,,
                LB      R0,0,R2                 :length in R0
                AIS     R2,1                    :address in R2
                CALL(SENDMS,DRPSV)
                LR      RUBLK,R12               :restore RUBLK
              ENDIF
            ENDIF
           ENDIF
          ENDIF
        ENDIF
        INVOKE(RETCMD)
 
:
:   Procedure:  RVNCMD - RCVRON command
:
:       This procedure processes the RCVRON command.  Since the
:       RCVRON and RCVROFF command are handled very much the same
:       with the exception of the new status setting, the ON
:       status is passed to RCVRSS which processes both commands
:
:   Input:
:
:       RUBLK - AUB ptr, AMT ptr or neg port number (R1)
:
:   Output:
:
:       RRETC - Good return code (R0)
:
:
:**********************************************************************
:
:
        PROCS(RVNCMD,A.CUCD)
        CHAINS(RVNSV,A.CUCD)

        LIS     R2,1                    : Set status parameter to ON
        CALL(RCVRSS,RVNSV)              : Process the RCVRON command

        LIS     RRETC,0                 : Set good return code
        INVOKE(RETCMD)                  : Return to command handler
:
:   Procedure:  RVFCMD - RCVROFF command
:
:       This procedure processes the RCVROFF command.  Since the
:       RCVRON and RCVROFF command are handled very much the same
:       with the exception of the new status setting, the OFF
:       status is passed to RCVRSS which processes both commands
:
:   Input:
:
:       RUBLK - AUB ptr, AMT ptr or neg port number (R1)
:
:   Output:
:
:       RRETC - Good return code (R0)
:
:
:***********************************************************************
:
:
        PROCS(RVFCMD,A.CUCD)            
        CHAINS(RVFSV,A.CUCD)            

        LIS     R2,0                    : Set status parameter to OFF
        CALL(RCVRSS,RVFSV)              : Process the RCVROFF command

        LIS     RRETC,0                 : Set good return code
        INVOKE(RETCMD)                  : Return to command handler
: (MATS.P2)RECCMD.04S
:    Copied by Gimnicher from (MATS.P2)RECCMD.03L.  12-3-81
:    Reworded lost stats records message.

: (MATS.P2)RECCMD.03L
: Copied by Vaysburd from (MATS.P2)RECCMD.02W on 11.16.81
: Added new print line with the number of lost stats records.
:
: (MATS.P2)RECCMD.02W  Created on 10/20/81.
:
:
:   Procedure: RECEIVERS command (RECCMD)
:
:       Routine to process the RECEIVERS command.  RECCMD will print 
:       out the contents of the MATS STATS receiver hosts table to
:       the user's terminal.
:
:   Input:
:
:       MSCTAB - MATS STATS circuit table (Global)
:       RUBLK - AMT ptr, AUB ptr or -port # (Passed)
:
:   Output:
:
:       None
:
:***************************************************************************
:
        PROCS(RECCMD,A.CUCD)
        CHAINS(RECSV,A.CUCD)

        L       R6,MSCTAB+OBCPRH,,      : Get ptr to MATS rcvr host table
        IFF(E)                          : IF no pointer then
          LA      R2,RECMS1,,           : let user know by sending him a
          CALL(SENDIT,RECSV)            : message

        ORELSE                          : Otherwise we do have a ptr to
          LH      R7,MSCTAB+OBCHCT,,    : Try and get count of table entries
          IFF(LE)                       : IF no entries then
            LA      R2,RECMS2,,         : let user know by sending him a
            CALL(SENDIT,RECSV)          : message

          ORELSE                        : Otherwise we do have entries so
            LA      R2,RECMS3,,         : Send first line of table header to
            CALL(SENDIT,RECSV)          : user
            LA      R2,RECMS4,,         : Send second line of table header to
            CALL(SENDIT,RECSV)          : user

            LIS      R8,1               : Set receiver ID to 1
            DO(COUNT,R7)                : DO for all entries ...
              LR      R3,R8             : Place receiver ID in print line
              LIS     R4,2              : 
              LA      R5,RCVID,,        : 
              CALL(BINDEC,RECSV)        : 

              LA      R2,RCVUNM,,       : First set the username field in the
              LIS     R3,NC.UNM         : print line to all blanks
              LHI     R4,$00A0          : 
              CALL(CLEAR,RECSV)         : 

              LA      R3,HSTUNM+1,R6,   : Place login username in print line
              LA      R4,RCVUNM,,       : 
              LB      R5,HSTUNM,R6,     : 
              MVS(R3,R4,R5,R9)          : 

              LA      R2,RCVHST,,       : First set the host field in the print
              LIS     R3,NC.HST         : line
              LHI     R4,$00A0          : 
              CALL(CLEAR,RECSV)         :

              LA      R3,HSTNUM+1,R6,   : Place login host number in print line
              LA      R4,RCVHST,,       : 
              LB      R5,HSTNUM,R6,     : 
              MVS(R3,R4,R5,R9)          : 

              LH      R3,HSTSTA,R6,     : Get host's status
              CLHI    R3,HSON           : Check if host is available
              IFF(E)                    : IF status is available then
                LA      R3,RCVON,,      : Place 'ON' for status in print line
                LA      R4,RCVSTA,,     : 
                LIS     R5,3            : 
                MVS(R3,R4,R5,R9)        : 
              ORELSE                    : Otherwise host is not available so
                LA      R3,RCVOFF,,     : Place 'OFF' for status in print line
                LA      R4,RCVSTA,,     : 
                LIS     R5,3            : 
                MVS(R3,R4,R5,R9)        : 
              ENDIF                     : 

              L       R3,HSTTO,R6,      : Place number of timeouts for host
              LIS     R4,5              : in print line
              LA      R5,RCVTO,,        : 
              CALL(BINDEC,RECSV)        : 

              L       R3,HSTZAP,R6,     : Place number of zaps for host in
              LIS     R4,5              : print line
              LA      R5,RCVZPS,,       : 
              CALL(BINDEC,RECSV)        : 

              L       R3,HSTTMC,R6,     : Place number of too-many-character
              LIS     R4,5              : activations for host in print line
              LA      R5,RCVTMC,,       : 
              CALL(BINDEC,RECSV)        : 

              L       R3,HSTUEA,R6,     : Place number of unexpected 
              LIS     R4,5              : activations for host in print line
              LA      R5,RCVUA,,        : 
              CALL(BINDEC,RECSV)        : 

              L       R3,HSTDAT,R6,     : Place number of data activations
              LIS     R4,7              : for host in print line
              LA      R5,RCVDA,,        : 
              CALL(BINDEC,RECSV)        : 

              CALL(NEWLIN,RECSV)        : Skip a line
              LHI     R0,RCVLNG         : Print the line we have been building
              LA      R2,RCVLIN,,       : Send it to the user's port
              CALL(SENDMS,RECSV)        : 

              AIS     R8,1              : Compute next receiver's ID

              AI      R6,HSTLNG         : Compute adr of next entry in table
            ENDDO                       : 
            LH  R3,CLSREC,,             : put number of
            LIS R4,5                    :lost stats records
            LA  R5,RCVLSC,,             :in print line
            CALL(BINDEC,RECSV)
            CALL(NEWLIN,RECSV)          :skip a line
            LHI R0,RCVLNA               :line length
            LA  R2,RCVLOS,,             :send line to the user's port
            CALL(SENDMS,RECSV)
          ENDIF                         : 
        ENDIF                           : 

        CALL(NEWLIN,RECSV)              : Skip a line

        LIS     RRETC,0                 : Set good return code
        INVOKE(RETCMD)                  : Return to command handler

        SEG     A.DATA                  : Definition of print line and messages

RCVLIN  AC      ' '                     : Print line for host table entry
RCVID   AC      'XX   '                 : Receiver ID
RCVUNM  AC      'XXXXXXXXXXXX '         : Username
RCVHST  AC      'XXXX   '               : Host number
RCVSTA  AC      'XXX   '                : Status (on or off)
RCVTO   AC      'XXXXX '                : Number of timeouts
RCVZPS  AC      'XXXXX '                : Number of zaps
RCVTMC  AC      'XXXXX '                : Number of too-many-characters
RCVUA   AC      'XXXXX '                : Number of unexpected activations
RCVDA   AC      'XXXXXXX'               : Number of data activations

RCVLNG  EQ      .-RCVLIN                : Length of print line

RCVLOS  AC       /The number of stats records dropped by MATS is /
RCVLSC  AC      /XXXXX/
RCVLNA  EQ      .-RCVLOS
RECMS1  SC      'No MATS STATS receiver hosts table found'

RECMS2  SC      'MATS STATS receiver host table is empty'

RECMS3  SC      '               MATS STATS receiver host table'

RECMS4  SC      'RCVR  USERNAME     HOST  STATUS  TO    ZAP   TMC   UA     DA'

RCVON   AC      'ON '                   : Available status
RCVOFF  AC      'OFF'                   : Unavailable status
: (MATS.P2)FRTCMD.03W  Created on 10/14/81.  Fixed bug.
:
: (MATS.P2)FRTCMD.02W  Created on 10/8/81.
:
:   Procedure:  Free TA command (FRTCMD)
:
:       Routine to process the FREE command.  FRTCMD will loop through
:       all the free blocks and start the freeing process for any
:       frozen IA-TAs.
:
:   Input:
:
:       RUBLK - AMT ptr, AUB ptr or -port #.  Passed in R1
:       FREACT - Pointer to first free block on free block chain
:
:   Output:
:
:       None
:
:
:****************************************************************************
:
:
        PROCS(FRTCMD,A.CUCD)
        CHAINS(FRTSV,A.CUCD)

        LIS     R3,0                    : Set cnt of IA-TAs to free to zero
        L       R2,FREACT,,             : Get pointer to first free block

        DO(WHILE,G)                     : While more free blocks do:
          LH      R4,FRENRB,R2,         : Add up bad and no responses for
          AH      R4,FRENRT,R2,         : this IA-TA
          CH      R4,FRELMT,R2,         : Compare sum to try limit
          IFF(GE)                       : If limit reached then
            AIS     R4,1                : Compute new limit
            STH     R4,FRELMT,R2,       : and store it away
            AIS     R3,1                : Bump count of frozen IA-TAs
          ENDIF                         : 
          L       R2,FRENXT,R2,         : Get pointer to next free block
        ENDDO                           : 

        LR      R3,R3                   : If count of frozen IA-TAs is greater 
        IFF(G)                          : then zero then
          LIS     R4,2                  : Call on BINDEC to place binary count
          LA      R5,FRTCFD,,           : of frozen IA-TAs in message
          CALL(BINDEC,FRTSV)            : 
          CALL(NEWLIN,FRTSV)            : Skip a line
          LHI     R0,FRTM1L             : Print message of IA-TAs freed on
          LA      R2,FRTMS1,,           : user terminal using SENDMS
          CALL(SENDMS,FRTSV)            : 
        ORELSE                          : Else no IA-TAs frozen
          LA      R2,FRTMS2,,           : Print message that no IA-TAs are 
          CALL(SENDIT,FRTSV)            : frozen
        ENDIF                           : 

        CALL(NEWLIN,FRTSV)              : Skip a line

        LIS     RRETC,0                 : Set good return code
        INVOKE(RETCMD)                  : Return to command handler

        SEG     A.DATA                  : Local variables

FRTMS1  AC      'Freeing of '
FRTCFD  AC      '?? frozen IA-TAs '     : IA-TAs being freed message
        AC      'started'               : 
FRTM1L  EQ      .-FRTMS1                : Message length

FRTMS2  SC      'No frozen IA-TAs to free'      : Another message
        
:(MATS.P2)FZNCMD.S01
:	Copied by Margalit	2/4/87
:	Changed FRELIM to SGOLMT

: (MATS.P2)FZNCMD.05W  Created on 10/21/81.  Added hex display of IA-TAs
:
: (MATS.P2)FZNCMD.04W  Created on 10/15/81.  Fixed equate problem.
:
: (MATS.P2)FZNCMD.03W  Created on 10/15/81.  Fixed CVTRES problem
:
: (MATS.P2)FZNCMD.02W  Created on 10/9/81.
:
:   Procedure: Frozen TA (FZNCMD)
:
:       Routine to process the FROZENTAS command.  FZNCMD will loop
:       through all of the free blocks looking for frozen or previously
:       frozen IA-TAs.  If any are found they are printed out in
:       tabular form on the user screen.
:
:   Input:
:
:       RUBLK - AMT ptr, AUB ptr or neg port number.  Passed in R1
:       FREACT - Pointer of first free block on free block chain
:       MAGTAB - Mag table
:       SGOLMT - Free attempt limit
:
:    Output:
:
:       None
:
:
:***********************************************************************
:
:
        PROCS(FZNCMD,A.CUCD)
        CHAINS(FZNSV,A.CUCD)

        LIS     R2,0                    : Set frozen IA-TA count to zero
        L       R6,FREACT,,             : Get pointer to first free block

        DO(WHILE,G)                     : While more free blocks do:
          LH      R7,FRENRB,R6,         : Sum up bad and no responses for this
          AH      R7,FRENRT,R6,         : IA-TA
          CHI     R7,SGOLMT             : Compare sum to assembled limit

          IFF(GE)                       : If ever frozen then
            AIS     R2,1                : Bump frozen IA-TA count
            CLHI    R2,1                : If frozen IA-TA count is one then
            IFF(E)                      : we need a header.
              LA      R2,FZNMS1,,       : Print header followed by a blank
              CALL(SENDIT,FZNSV)        : line
            ENDIF                       : 
            CH      R7,FRELMT,R6,       : If IA-TA is still frozen and no
            IFF(GE)                     : activity is pending then
              LHI     R7,$00AA          : set indicator to an asterisk
            ORELSE                      : otherwise
              LHI     R7,$00A0          : clear indicator to a space
            ENDIF                       : 
            STB     R7,FZNFLG,,         : Place indicator in print line

            LA      R7,FRERCD,R6,       : Place two character res code in
            LA      R8,FZNRCD,,         : print line
            LIS     R9,2                :
            MVS(R7,R8,R9,R10)           :

            LIS     R7,0                : Need to get line number
            LHL     R8,FRERES,R6,       : Get res number from free block
            CVTRES(R8,FZNSV)            : Convert res to MAGTAB index
            LHI     R9,MAGLNG           : Get length of MAG table entry
            MR      R7,R9               : Multiply MAG index by MAG entry len
            LA      R8,MAGTAB,R8,       : Add MAGTAB address to index
            LA      R10,MAGLN,R8,       : Get address of MAG line number
            LIS     R9,1                : Place two digit MAG line number in
            LA      R8,FZNLN,,          : print line
            CALL(BINHXW,FZNSV)          : 

            LA      R10,FREITA+2,R6,    : Get IA number
            LIS     R9,1                : Place two digit IA number in
            LA      R8,FZNIA,,          : print line in HEX
            CALL(BINHXW,FZNSV)          : 

            LA      R10,FREITA+3,R6,    : Get TA number
            LIS     R9,1                : Place two digit TA number in print
            LA      R8,FZNTA,,          : line in HEX
            CALL(BINHXW,FZNSV)          : 

            LHL     R3,FRENRB,R6,       : Get number of bad responses
            LIS     R4,3                : Place three digit number in print
            LA      R5,FZNRB,,          : line
            CALL(BINDEC,FZNSV)          : 

            LHL     R3,FRENRT,R6,       : Get number of no responses
            LIS     R4,3                : Place three digit number in print
            LA      R5,FZNRT,,          : line
            CALL(BINDEC,FZNSV)          : 

            LHL     R3,FRELMT,R6,       : Get try limit
            LIS     R4,3                : Place three digit try limit in print
            LA      R5,FZNLMT,,         : line
            CALL(BINDEC,FZNSV)          : 

            CALL(NEWLIN,FZNSV)          : Skip a line
            LHI     R0,FZNM2L           : Send print lint to user's port
            LA      R2,FZNMS2,,         : 
            CALL(SENDMS,FZNSV)          : 
            ENDIF                       : 

          L       R6,FRENXT,R6,         : Get pointer to next free block
        ENDDO                           : 

        CLHI    R2,0                    : If no frozen IA-TAs were found
        IFF(E)                          : then
          LA      R2,FZNMS3,,           : Send to user message saying so
          CALL(SENDIT,FZNSV)            : 
        ENDIF                           : 

        CALL(NEWLIN,FZNSV)              : Skip a line
        LIS     RRETC,0                 : Set good return code
        INVOKE(RETCMD)                  : Return to command handler

        SEG     A.DATA                  : Local variables

FZNMS1  SC      '  Res Code    LN IA TA    BR    NR    Limit'

FZNMS2                                  : Print line
FZNFLG  AC      '  '                    : No pending activity indicator
FZNRCD  AC      '            '          : Two character rec code
FZNLN   AC      '   '                   : Line number
FZNIA   AC      '   '                   : Interchange address
FZNTA   AC      '      '                : terminal Terminal address
FZNRB   AC      '      '                : Bad response
FZNRT   AC      '      '                : No response
FZNLMT  AC      '   '                   : Try limit
FZNM2L  EQ      .-FZNMS2                : Print line length

FZNMS3  SC      'No frozen IA-TAs found':No IA-TAs message
: (MATS.P2)RCVRSS.03W  Created on 11/9/81.  Replaced GTCHUC call
:
: (MATS.P2)RCVRSS.02W  Created on 11/9/81.  Fixed more bugs
:
: (MATS.P2)RCVRSS.01W  Created on 11/9/81.  Fixed bugs
:
:   Procedure:  RCVRSS - Receiver set status
:
:       This procedure processes both the RCVRON and RCVROFF
:       commands.  These commands allow the user to change the
:       status of the receivers in the receiver host table.
:
:   Input:
:
:       RUBLK - AUB ptr, AMT ptr or neg port number (Passed in R1)
:       NEWSTATUS - OFF(0) if RCVROFF command.  ON(1) if RCVRON command. 
:           (Passed in R2)
:
:   Output:
:
:       None
:
:
:************************************************************************
:
:
        PROCS(RCVRSS,A.CUCD)
        CHAINS(RCVRSV,A.CUCD)

        CLHI    R2,1                    : If we were called by the RCVRON
        IFF(E)                          : command then    
          LA      R6,ONMSG,,            : get pointer to 'ON ' string
        ORELSE                          : otherwise
          LA      R6,OFFMSG,,           : get pointer to 'OFF' string
        ENDIF                           : 
        LR      R10,R2                  : Save new status for later use

        LR      R7,R1                   : If RUBLK is a negative port
        IFF(L)                          : number then
          XI      R7,-1                 : make it positive by inverting it
          AIS     R7,1                  : and adding one
        ORELSE                          : otherwise
          LHL     R7,CCBPRT,R1,         : get port number form AUB
        ENDIF                           : Steve are you reading this?
        SLHLS   R7,2                    : Buffer index = 4 * port number

        LI      R0,-1                   : Call READ to get second parameter
        LIS     R2,$A10                 : including the carriage return
        LA      R3,PRMTR2,,             : 
        CALL(READ,RCVRSV)               : 
        LR      R0,R2                   : 

        IFF(G)                          : If we got any characters at all then
          LIS     R3,TRUE               : Check if characters = 'ALL'
          DO(COUNT,R2)                  : Loop through each character entered
            LB      R4,PRMTR2-1,R2,     : checking to see if there is a mis-
            OHI     R4,$080             : Turn on parity bit
            CLB     R4,ALLMSG-1,R2,     : match with the character string 'ALL'
            IFF(N)                      : If a mismatch then 
              LIS     R3,FALSE          : set compare flag to false and
              EXITDO                    : exit loop
            ENDIF                       : 
          ENDDO                         : 

          CLHI    R3,TRUE               : Was ALL entered?
          IFF(E)                        : If it was then
            L       R2,MSCTAB+OBCPRH,,  : get pointer to table of receiver
            LH      R3,MSCTAB+OBCHCT,,  : hosts and # of entries in table
            DO(COUNT,R3)                : Loop through table and set
              STH     R10,HSTSTA,R2,    : each receiver to the new status
              AHI     R2,HSTLNG         : Get pointer to next receiver in table
            ENDDO                       : 
            LA      R2,RMSG1,,          : Let user know that all receivers
            CALL(SENDIT,RCVRSV)         : in host table had their status set
            LIS     R0,3                : to the new status
            LR      R2,R6               : 
            CALL(SENDMS,RCVRSV)         : Print out new status
          ORELSE                        : otherwise ALL was not entered so
            LA      R4,PRMTR2,,         : try and convert the input to a
            LR      R5,R0               : binary number assuming input is
            CALL(DECBIN,RCVRSV)         : a number

            CLHI    R2,FALSE             : If input was a positive number of
            IFF(E)                        : some sort
              CLHI    R3,0                 : and it was greater than 
              IFF(G)                        : zero
                CLH     R3,MSCTAB+OBCHCT,,   : and less than or equal to # of
                IFF(LE)                       : entries in host table then
                  SIS     R3,1                 : compute address of receiver's
                  LIS     R2,0                  : entry in host table so the
                  LHI     R5,HSTLNG              : status can be checked
                  MR      R2,R5                  : 
                  L       R2,MSCTAB+OBCPRH,,
                  LA      R3,HSTSTA,R2,R3        : 
                  CLH     R10,0,R3,             : Check if status = new status
                  IFF(N)                       : If it is not then
                    STH     R10,0,R3,         : Place new status in entry and
                    LA      R2,RMSG2,,       : let user know new status was
                    CALL(SENDIT,RCVRSV)     : set
                    LIS     R0,3           : and what the new status
                    LR      R2,R6         : is
                    CALL(SENDMS,RCVRSV)  :
                  ORELSE                :  otherwise status is already set so
                    LA      R2,RMSG3,,  : let user know by sending him
                    CALL(SENDIT,RCVRSV) : a message to that effect
                    LIS     R0,3        :
                    LR      R2,R6       :
                    CALL(SENDMS,RCVRSV) :
                  ENDIF                 :
                ORELSE                  : otherwise parameter two was bad and
                  LA      R2,RMSG4,,    : the user should be told
                  CALL(SENDIT,RCVRSV)   :
                ENDIF                   : 
              ORELSE                    : otherwise ID is less than or equal
                LA      R2,RMSG4,,      : to zero.  Bad Bad Bad.
                CALL(SENDIT,RCVRSV)     :
              ENDIF                     : 
            ORELSE                      : otherwise DECBIN claims there was
              LA      R2,RMSG4,,        : a problem while converting the 
              CALL(SENDIT,RCVRSV)       : parameter
            ENDIF                       : 
          ENDIF                         :
        ORELSE                          : otherwise there was no second 
          LA      R2,RMSG5,,            : parameter and the user should be
          CALL(SENDIT,RCVRSV)           : told
        ENDIF                           : 

        CALL(NEWLIN,RCVRSV)             : Create a blank line
        RETURN(R1)                      : Return, restoring from R1

        SEG     A.DATA                  : Local variable definitions

ONMSG   AC      'ON '
OFFMSG  AC      'OFF'

ALLMSG  AC      'ALL'

PRMTR2  BS      10

RMSG1   SC      'All MATS STATS receiver hosts status set to '

RMSG2   SC      'Status set to '

RMSG3   SC      /Receiver"A7s status is already /

RMSG4   SC      'Invalid receiver ID.  Check ID with RECEIVERS command'

RMSG5   SC      'Second parameter missing.  Must be receiver ID or ALL'
:(MATS.P2)MAGTXT.S01
:	Created by Margalit	1/15/87

:This routine handles text messages coming from the circuit(from the Host).
:A search is made to find the user who is the recipient of this message.
:If no user is found USRTXT is called to conduct a long search on all RES's.
:If a user is found a check is madeupon the type of the user.
:  if in Sign process(signin or signoff): CALL SGNTXT
:  Else:(normal user session)             CALL USRTXT

:    INPUTS - RES,IA,TA in MAGDAT
:	      RUBLK - points to MAGTAB

:    OUTPUTS- RRETC(R0)=0, if found the user in R2UTAB.
:             USER-BLOCK(R2)- AUB or FREE BLOCK.
:             RES-IA-TA(R3)-given RES-IA-TA
:
:

	RA	$0 0

	PROC(MAGTXT)
	CHAIN(MAGTSV)
:
:
        LH      R2,IA,,
        NHI     R2,$007F7F              : IA-TA from MAGDAT
        LH      R3,MAGNUM,RUBLK,        :RUBLK points to the MAGTAB
        SLL     R3,$A 16
        OR      R3,R2                   :RES-IA-TA in R3
        LIS     R4,0                    :PRINTR=0 initially
        CALL(BINSCH,MAGTSV)	        :search in R2UTAB
        LR      RRETC,RRETC
        IFF(E,THEN)                     :R0=0 if found
          SLLS  R5,3                    :R5- entry number in R2UTAB
          L     R2,R2UTAB+R2UAUB,R5,    :get user's block pointer
          LB    R6,AUBTYP,R2,		:get User's type
          CLHI  R6,SIGNOF		:signof and signin are the last types  
          IFF(L,THEN)			:if a normal session
	    CALL(RBSRCH,MAGTSV)		:look for an RB
	    CALL(USRTXT,MAGTSV)		:handle a normal text message
	  ORELSE			:signof or signin
	    CALL(SGNTXT,MAGTSV)		:handle a signin/off message
	  ENDIF				:normal session
	ORELSE				: User block not found
	  CALL(USRTXT,MAGTSV)		:to conduct a long search on all RB's
	ENDIF
	
	INVOKE(CMDRET)

:(MATS.P2)USRTXT.S01
:	Copied by Margalit from MAG1TX.S03	1/16/87

:	This routine handles text packets destined to a user who is in
:	a normal session with the Host.
:	At first the routine checks if an AUB related to the msg address
:	was found, if not it checks to see if this is an unsolicited msg
:	for a user who is on a Hold_Disconnect status.
:	If an AUB was found then RBSCH is called to find the Res Block
:	associated with the RES-IA-TA and if this is a CRT or Printer.
:	It picks up the characters from Bufferlettes and put them in
:	OUTBUF.
:	Each character is translated from sabre to ascii for some special
:	characters like: LF,EOM's,EOP,etc. a subroutine is called to handle
:	the translation and for all the others it is a simple one to one
:	translation.
:	This routine also handles full screen support, in other words it
:	translates the C1,C2 characters into the appropriate control
:	sequences to be sent to the Terminal.

	GL	LINPOS,SCNPOS	:THIS TABLES ARE USED BY MONSND
	GL	IA
	RA	$0 0
	LO	MAIN
	PROC(USRTXT)
	CHAIN(USRTSV)
:
: REGISTER USAGE
:
: R0 - USED BY GCI TO RETURN THE CHARACTER (REMEMBER ALL HAVE THE HIGH ORDER
:      BIT TURNED ON, EXCEPT ETX ('0D')
: R1 - USED BY GCI, CONTAINS THE BUFFER NUMBER (PORT # OF MAGTAB * 4)
: R2 - USED BY GCI
: R3 - USED BY GCI
: R4 - LINK REGISTER FOR GCI
: R5 - WORK REGISTER (THE ONLY ONE!)
: R6 - USER AUB ADDRESS (GOTTEN FROM R2UTAB)
: R7 - ADDRESS OF OUTPUT BUFFER (GOES TO USER EVENTUALLY)
: R8 - ADDRESS OF MAGTAB ENTRY, FOR INCOMING MESSAGE
: R9 - MAGTAB TRANSLATE ADDRESS
: R10- REMAINING NUMBER OF BYTES IN OUTPUT BUFFER, USED TO PREVENT
:      OVERFLOW
: R11 - NUMBER OF CHAR IN PRESENT LINE COUNT . REQUIRED TO BE
:       ABLE TO SUPPORT HARDCOPY TERMINALS WHICH DONT PROVIDE AUTOMATIC LINEWRAP
: R12- USED IN SIMULATING XLATE OPCODE
: R13- USER TERMINAL TYPE (FROM AUB)
: R14 - SAVE REGISTER
: R15 -LINK REGISTER 
:
: EQUATES
:
ESCAPE	EQ	$09B
UMSG1	EQ	$02A
UMSG2	EQ	$005
:
NEWLNE	EQ	$00C
CRLF	EQ	$08A8D	:NOTE THIS HALFWORD IS EXPECTED TO
			:BE USED BACKWARDS (I.E. LFCR)
ERSDWN	EQ	$011	:ERASE DOWN SCREEN COMMAND
SCNOOP	EQ	$010	:SCREEN NO OP
:
HDROFF	EQ	$A4	SCREEN BANNER/HEADER OFFSET
:
MAXSCN	EQ	$A1024	:MAXIMUM SCRREN BUFFER TO USER
:
	SEG	2
SCNCMD	BS	1	:STOREAGE AREA FOR SCREEN CMD
CHARSV  BS      1       :TEMP. STORAGE AREA FOR A CHAR.
:
	GL	OUTBUF
OUTBUF	BS	MAXSCN
: OUTPUT SCREEN BUFFER ALLOCATION
:
: ADM2 SCREEN POSITION TRANSLATION
	RA	$00A	:SET RADIX TO DEMICAL
LINPOS	BC	0,0,0,0,13,14,15,16,0,0,0,0,0,0,0,0,0
	BC	17,18,19,20,21,22,23
	BC	0,0,0,0,0,0,0,0
	BC	24,25,26,27,28,29,30
	BC	0,0,0,0,0,0,0,0,0
	BC	1,2,3,4,5,6,7,8,9,10,11,12
:	A ZERO MEANS INVALID LINE POSITION CHARACTER
:
:ADM2 CURSOR POSITION TRANSLATION (FIRST CONSULT LINPOS)
:
SCNPOS	AC	/  "A2#$%&'()/   : THE "82 IS THE ONLY WAY TO ENTER A "
	AC	$*+,-./0123$
	AC	!456789"FA"DE"CC=!	: "FA IS NEEDED TO ENTER A :
: "DE IS NEEDED FOR SEMI-COLON   "CC IS FOR A <
	AC	$>?@ABCDEFG$
	AC	$HIJKLMNOPQ$
	AC	$RSTUVWXYZ_$
	AC	$\'^_9ABCDE$
	AC	$FGHIJKLMNO$
	SEG	1
:
        LR      R8,RUBLK                :save RUBLK
        LH      R1,MAGPRT,RUBLK,         :GET THE PORT NUMBER
        SLHLS   R1,2            :CONVERT TO BUFFER NUMBER
        LR      RRETC,RRETC             :if found an AUB/RB ,RRETC=0
        IFF(N,THEN)
          J     LNGUMG                  :jump to long search
        ENDIF 
	
        LR    R13,R4                    :save PRINTR
        LR    R12,R5                    :save RB pointer
        LR    R6,R2                     :save user's AUB
:
: CHECK TO MAKE SURE THE USER IS IN OUTPUT MODE
: (I.E. RESET KEY HASN'T BEEN HIT
:
INITIT	LHI	R10,MAXSCN	:GET OUTPUT BUFFER SIZE
        LH      R11,AUBCOL,R6,  :Get column position
	LA	R7,OUTBUF,,
	L	R9,MAGXLT,R8
:
:
: CHECK FOR UNSOLICITED MESSAGE
:
CKUMSG	LHL	R0,BCT,R1	:GET AT NUM OF BYTES IN BUFFER
	AM	R0,MGIUMG,R8
	LIS	R4,1
	AM	R4,MGIMGU,R8	:INCREMENT MSG COUNTER
	SIS	R0,2	:MAKE SURE THERE ARE AT LEAST 2
	JGEFS	WCHONE	:JUMP IF THERE ARE
        LIS     R4,1
        AHM     R4,ERC1C2,,             :increment error counter
        LR      RUBLK,R8                :ignore this message
        INVOKE(CMDRET)
:
WCHONE	JAL	R4,GCI,, :	:WHICH ONE (UMSG OR SCREEN POSITION?)
	LR	R5,R0	SAVE THE CHARACTER
	NI	R5,$07F	:TURN OFF HI BIT
	CLHI	R5,UMSG1	LOOK FOR UMSG
        JN      SCRNPO
	JAL	R4,GCI,, :	:GET SECOND CHARACTER
	NI	R0,$07F
	CLHI	R0,UMSG2	:CHECK FOR SECOND CHAR
	JN	STUFEM	:IF NOT CORRECT JUST PUT THEM IN OUTPUT
	LR	RUBLK,R6	:POINT TO USER BLOCK
        LR      R5,R13                  :check PRINTR
        IFF(E,THEN)                     :it is not printer IA-TA
          CALL(ULITE,USRTSV)
        ENDIF
        LR      RUBLK,R8        :RESTORE MAGTAB USER
	INVOKE(CMDRET)
STUFEM	LIS     R4,1
        AHM     R4,ERUMS2,,             :increment error counter
        LR      RUBLK,R8                :ignore this message
        INVOKE(CMDRET)
:
: LONG SEARCH ON UNSOLICITED MESSAGE - MUST CHAIN THROUGH ALL
: THE RES BLOCKS THAT ARE CHAINED FROM ALL THE AUBLKS.
:
LNGUMG	LR	R7,R3	:SAVE RES-IA-TA
	JAL	R4,GCI,,	:GET THE FIRST CHARACTER
	NI	R0,$07F	THRUN OFF HI ORDER BIT
	CLHI	R0,UMSG1	IS CMD UMSG?
	JEFS	CHKMG2	JUMP IF SO
	LR	RUBLK,R8	POINT TO MAGTAB (IGNORE THIS MSG)
	INVOKE(CMDRET)
CHKMG2	JAL	R4,GCI,,	:GET THE 2ND UMSG CHARACTER
	NI	R0,$07F
	CLHI	R0,UMSG2
	JEFS	FNDUSR
	LR	RUBLK,R8
	INVOKE(CMDRET)
:
: FIND THE USER BY SEARCHING THROUGH ALL THE AUBS AND RB
FNDUSR	L	R2,AUTACT	GET FIRST ACTIVE AUB
AUBLUP	JE	ALDONE	:IF ZERO WE'RE DONE
: NOW CHAIN THRU THE RBS
	L	R5,AUBRCH,R2	GET FIRST RB
	JE	NXTAUB	IF NOT RB, GET NEXT USER
RBLUP	C	R7,RBIATA,R5	IS THIS THE ONE?
	JNFS	NXTRB	JUMP IF NOT
	LIS	R3,1
	STB	R3,RBUMSG,R5
	LR	RUBLK,R8	POINT BACK TO THE MAG
	INVOKE(CMDRET)
NXTRB	L	R5,RBNXT,R5
	JEFS	NXTAUB	JUMP IF NO MORE RBS
	JBS	RBLUP	CONTINUE LOOKING THROU RBS
NXTAUB	L	R2,AUBNXT,R2
	JN	AUBLUP
ALDONE	LR	RUBLK,R8
	INVOKE(CMDRET)
:
:SCREEN POSITIONING
:
SCRNPO  LR      R13,R13                 :check PRINTR
        IFF(N,THEN)                     :it is a printer IA-TA
          LR    R1,R6                   :restore AUB- pointer
          LH    R2,MAGPRT,R8            :get port-#
          LR    R3,R12                  :restore RB pointer
          LR    R4,R0                   :get character C1
          CALL(AXPRNT,USRTSV)
          J   MAG1RT
 
        ENDIF 

          LR      R12,R12
          IFF(N)                : If there is a Res Block
            LHL     R4,MAGPRT,R8,
            SLLS    R4,2        : (Mag buffer index)
            LHL     R4,BCT,R4,    : How many characters for user,
            AIS     R4,7        : Plus S1 S2 IA TA C1 ... EOM CCC
            AM      R4,RBDSCC,R12,   : Add to Displayed-Chars Count for user
          ENDIF                 : There is a Res Block
 
          IF    HSTLOK
            LIS	R4,AUBOUT
            CLB	R4,AUBMOD,R6	:CHECK USERS MODE
            JE	SCRNPP	:CONTINUE PROCESSING
            LR	RUBLK,R8	RESTORE RUBLK TO MAGTAB
            LIS	R4,1
            AM	R4,MGIBBC,RUBLK	:ADD 1 TO BIT BUCKET COUNT
            INVOKE(CMDRET)
          EI
 
 
SCRNPP  LHI     R12,$0100                :comparision for XLTPAR TABLE
        STB	R5,SCNCMD,,	:SAVE THIS ONE
	JAL	R4,GCI,, :	:GET POSITION CHARCTER
	NI	R0,$07F	TURN OFF HI BIT
        STB     R0,CHARSV,,     :TEMP. SAVE THE CHAR.
        LB      R0,MGPNR,R8     :PNR PROCESS INDICATOR
        CLHI    R0,PNRON        :PNR SECURITY CHECK ON INDICATOR
        JN      SCRNP1          :PNR SECURITY CHECK IS NOT REQUIRED

        CALL(CHKPNR,USRTSV)     :DO PNR SECURITY CHECK
        
        CLHI    R0,TRUE         :IF MESSAGE PASSED THE SECURITY CHECK
        JE      SCRNP1          :THEN GO PROCESS THE MESSAGE
        LR      R1,R8           :ELSE RESTORE THE MAGTAB POINTER
        INVOKE(CMDRET)



SCRNP1  LB      R0,CHARSV,,     :RESTORE CCHAR, IF SECURITY CHECK PASSED
        LB      R13,AUBTTY,R6   :
        NHI     R13,AUBVID      :AND WITH VIDEO BITS
        JE      HRDCPY          :JUMP IF NOT VIDEO
	CLHI	R0,NEWLNE	CHECK FOR NEW LINE
	JN	CHKCUR	:JUMP IF NOT NEW LINE
:
: NEW LINE
:
        LB      R13,AUBTTY,R6   :GET TERMINAL TYPE
        NHI     R13,AUBVID
	JN	ESCT9F	:JUMP IF VIDEO TERMINAL

: FOR NORMAL HARDCOPY TERMINALS C/R,LF AND IGNORE SCREEN CMD
: For hardcopy with full screen(C1,C2) supported, check C1, C2 chars
: just  as block mode terminals

HRDCPY  LB      R13,AUBTTY,R6   :no, check if normal hardcopy or hardcopy 
        NHI     R13,AUBHDB      :  with c1,c2 supported
        IFF(E,THEN)             :  if it's a normal hardcopy
          LIS	R5,0
	  STB	R5,SCNCMD,,
          CLHI	R0,SCNOOP	IS THIS A NOOP CMD
          JE	TXTLOP	JUMP IF SO.. NOTHING TO DO
          J	STFCRL	:STUFF IN A CR/LF
        ORELSE                  :  not a normal hardcopy
          CLHI  R0,NEWLNE       :  C2 = newline ?
          JE    HDNWLN          :  yes, jump to hard copy new line
          J     CHKCUR          :  no, jump to check C2= NOP or line addr
        ENDIF                   : end of normal hard copy check
:
:NEW LINE FOR ADM2 - ESC,t,9F
ESCT9F  LR      R5,R11          :LOAD NUMBER OF CHAR IN THIS LINE
        AIS     R5,1            :NOW IS CURSOR POSITITON
        STH     R5,AUBCOL,R6    :STORE IT IN THE AUB
        LB      R13,AUBTTY,R6
        CLHI    R13,AUB440
        JE      ESC440
        LHI     R5,$008D8A      :send LF_CR for 470
        JFS     ESC470
HDNWLN  LHI     R5,CRLF         :send CR_LF
ESC470  STB     R5,0,R7
        SRLS    R5,8
        STB     R5,1,R7
        AIS     R7,2
        SIS     R10,2
        JLE     STFETX
        J       LINDON          :GO FINISH PROCESSING AND SEND LINE

ESC440  LHI     R5,$09F
        STB     R5,0,R7
        AIS     R7,1
        SIS     R10,1
        JLE     STFETX
LINDON  LI      R0,MAXSCN               :LOAD BUFFER SIZE
        SR      R0,R10          :COMPUTE NUMBER OF CHARS USED
        LA      R2,OUTBUF,,     :ADDRESS OF DATA TO BE SENT
        LR      R5,R1           SAVE R1
        LR      R1,R6           :LOAD RUBLK
        CALL(SENDMS,USRTSV)
        LR      R1,R5           :FIX R1
        LHI     R10,MAXSCN      :REINIT
        LIS     R11,0           :NO CHARS IN I LINE
        LA      R7,OUTBUF,,     :POINT OTO BEGINNING OF BUFFER
        LH      R5,AUBLIN,R6,   :LOAD LINE ADDRESS
        AIS     R5,1            :INCREMENT
        STH     R5,AUBLIN,R6,   :STORE IT BACK
        LIS     R5,1            :LOAD A 1
        STH     R5,AUBCOL,R6,   :FORCE COLUMN TO ONE
        J       SCRN
:
: CHECK CURSOR POSITION
:
CHKCUR	CLHI	R0,SCNOOP		:CHECK FOR SCREEN POSITION
	JE	SCRN	:JUMP IF WE'RE THERE
:
: MUST DO LINE ADDRESSING
:
	CLHI	R0,$001	:COMPARE LOW LINE ADDRESS
	JL	CRSHIT	:CRASH IF LESS
	CLHI	R0,$A59	:COMPARE HI LINE ADDR
	JG	CRSHIT	:JUMP IF GREATER
	LR	R5,R0	:USE CHAR AS INDEX
	LB	R5,LINPOS,R5,	:AND TRANSLATE
	JE	CRSHIT	:IF XLATES TO ZERO, JUMP

        LB      R13,AUBTTY,R6
        NHI     R13,AUBVID      : is a video terminal ?
        IFF(E,THEN)             : no, not a video
	  LB	R13,AUBTTY,R6
	  NHI	R13,AUB78	: PCI-78 ?
	  IFF(E,THEN)		: no, it is not PCI-78
            CALL(HDSCPO,USRTSV)   : to put screen posi chars into OUTBUF
	  ORELSE		: yes, it is PCI-78, put col before line
	    CALL(HDSC78,USRTSV) : screen pos for PCI-78
	  ENDIF
        ORELSE                  : yes, is a video terminal
  	  AIS	R5,HDROFF	:ADD IN OUR HEADER OFFSET
          LR      R0,R5           :LINE ADDRESS IN R0
          LHI     R5,1            :COLUMN POSITION 1
          CALL(VBPOSC,USRTSV)
        ENDIF

        LIS     R11,0           :RESET CHAR/LINE COUNTER
        LR      R10,R10         :SET CONDITION CODES
        JLE     STFETX
:
: CHECK SCREEN COMMAND AGAIN, ITS EITHER WRITE OR ERASE/WRITE
:
SCRN	LB	R5,SCNCMD,,
	CLHI	R5,ERSDWN
	JE	ERASES	JUMP IF NEED TO ERASE SCREEN
:
: CHECK FOR OTHER VALID SCREEN COMMANDS
:
CHKAGN	CLHI	R5,SCNOOP	:SCREEN NO OP
	JE	TXTLOP	:NOTHING TO DO WITH THIS COMMAND
:
: INVALID SCREEN COMMAND
:
CRSHIT  LIS     R4,1
        AHM     R4,ERLADR,,             :increment error counter
        LR      RUBLK,R8                :ignore this message
        INVOKE(CMDRET)
:
:
: ERASE REST OF SCREEN
:
ERASES  LB      R13,AUBTTY,R6
        NHI     R13,AUBVID              : is a video?
        IFF(E,THEN)                     : not a video terminal
          CALL(HDERAS,USRTSV)           : to put erase sequence into OUTBUF
        ORELSE                          : it is a video terminal
          CALL(VBERUP,USRTSV)
        ENDIF
        LR      R10,R10
	JLE	STFETX
TXTLOP	LHL	R0,BCT,R1	ANY CHAR LEFT?
	SIS	R0,1	SHOULD ALWAYS BE AN 'ETX'
	JGEFS	GETCHR
        LIS     R4,1
        AHM     R4,ERNETX,,             :increment error counter
        LR      RUBLK,R8                :ignore this message
        INVOKE(CMDRET)
:
GETCHR	JAL	R4,GCI,, :	:GET CHAR
	LR	R5,R0	 PUT CHARACTER IN R7
	SLHLS	R5,1	MULTIPLY CHAR BY 2 AND
	LHL	R5,0,R9,R5	USE AS INDEX TO XLATE TABLE
	JE	TXTLOP	:IF INVALID CHARACTER IGNORE IT
        LHI     R12,$0 100      :LOAD TEST VALUE HERE
	CLR	R5,R12	:CHECK FOR AN ADDRESS
	JL	STUFIT	:JUMP IF ITS NOT AN ADDRESS
	SLLS	R5,1	:MULTIPKY ADDRESS BY 2
	JR	R5	AND GO DO IT
:
STUFIT	STB	R5,0,R7	SOTRE CHAR IN BUFFER
	AIS	R11,1	INCREMENT CHAR IN LINE COUNT
	SIS	R10,1	DECREMENT SPACE LEFT IN BUFFER
	JLE	STFETX	JUMP IF NOT MORE ROOM
	AIS	R7,1	INCREMENT OUTPUT ADDRESS
:       check for count(chars_this_line) >= res_linesize AND
:       count(chars_this_line) >= TIBFNL(this_terminal_type)
	LH	R5,MAGLSZ,R8	GET RES LINESIZE
	CR	R11,R5	COMPARE OUR COUNT TO IT
	JL	TXTLOP	JUMP IF NO PROBLEM
        L       R5,AUBTIB,R6    :Get Tib address for this terminal
        CLH     R11,TIBFNL,R5   :Compare column number against TIBFNL
        JGE     NOCRLF          :If >= then terminal will give us a freebie NL
        J       STFNWL          :Else we need to put in a newline

: STFCRL is branched to from several locations in MAG1TX, including from STFNWL
STFCRL	LHI	R5,CRLF	STUFF IN A CR/LF
	STB	R5,0,R7
	SIS	R10,1
	JLE	STFETX
	SRHLS	R5,8
	STB	R5,1,R7
	SIS	R10,1
	JLE	STFETX
	AIS	R7,2
NOCRLF  LI      R0,MAXSCN       :LOAD SCREEN SIZE
        SR      R0,R10          :SUBTRACT REMAINING CHARS
        LA      R2,OUTBUF,,     :ADDRESS OF BUFFER TO BE SEND
        LR      R5,R1           :SAVE R1
        LR      R1,R6           :LOAD RUBLK FOR SENDMS
        CALL(SENDMS,USRTSV)
        TRPORT(TRDATA,USRTSV)
        LR      R1,R5           :FIX R1
        LI      R10,MAXSCN      :LOAD SCREEN SIZE
        LIS     R11,0           :ZERO LINE LENGTH
        LA      R7,OUTBUF,,     :POINTER TO BEGINNING OF OUTPUT 
        LH      R5,AUBLIN,R6    :LINE ADDRESS
        AIS     R5,1            :WE WROTE ONE LINE TO SCREEN
        STH     R5,AUBLIN,R6    :STORE IT BACK
        LIS     R5,1            :LOAD A ONE
        STH     R5,AUBCOL,R6    :WE ARE IN COLUMN ONE
	J	TXTLOP
:
: THESE ROUTINES HAVE THEIR ADDRESS IN THE HALFWORD XLATE TABLES
:
	HS	0
STFEMI	J	TXTLOP	:DON'T DO ANYTHING
STFEPB	J	TXTLOP	:DON'T DO ANYTHING
STFNWL  LB      R13,AUBTTY,R6   LOAD TERM TYPE
        CLHI    R13,AUB440      :IS THIS A 440
        JE      NWL440          :JUMP IF SO
:ALL OTHERS NEED CR/LF
	J	STFCRL
NWL440  LR      R5,R11          :LOAD COLUMN POISTION
        AIS     R11,1           :INCREMENT
        STH     R5,AUBCOL,R6    :NOW GOOD CURSOR ADDRESS
        CALL(VBERLN,USRTSV)
        LHI     R5,$09F         :LOAD AN NEW LINE CHAR (US)
        STB     R5,0,R7         :STORE IN BUFFER
        AIS     R7,1            :INCREMENT POINTER
        SIS     R10,1           :DECREMENT AVAILABLE BYTES
        JLE     STFETX          :JUMP IF NO MORE ROOM
	J	NOCRLF
:
:
:
STFSOM  LB      R13,AUBTTY,R6
        NHI     R13,AUBVID
	JN	SOM440
        L       R5,MGPRMP,R8    : If Prompt_String Not defined
         JE     STFS6           : go use RESCODE
        LB      R13,,R5         : get count
        DO(COUNT,R13)
          AIS   R5,1
          LB    R2,,R5          : pick up a char
          STB   R2,,R7          : put in output buffer
          AIS   R7,1
          SIS   R10,1           : dec buffer_space_left
          JLE   STFETX
        ENDDO
        J       TXTLOP          : proc next char from Mag

: ALL OTHERS GET  2 CHAR RESCODE AND THE PROMPT >
STFS6	LH	R5,MAGRES,R8
	JE	PRMPT
	STB	R5,1,R7
	SIS	R10,1
	JLE	STFETX
	SRHLS	R5,8
	STB	R5,0,R7
	SIS	R10,1
	JLE	STFETX
	AIS	R7,2
	AIS	R11,2
PRMPT	LHI	R5,$00BE
	J	STUFIT
:
SOM440  LR      R5,R11          :GET LINE CHAR COUNT
        AIS     R5,1            :NOW POINT TO CURSOR POSITION
        STH     R5,AUBCOL,R6    :SAVE IT IN COLUM POSITION
        CALL(VBSNSM,USRTSV)
        LHL     R11,AUBCOL,R6   : CURR. COL. #.
        LR      R10,R10         :SET CONDITION CODES
        JLE     STFETX          :JUMP IF NO MORE ROOM
	AIS	R11,2
	J	TXTLOP
:
STFEMC	EQ	.
STFEMU  LIS     R5,AUBINP       :UNLOCK THE KEYBOARD
	STB	R5,AUBMOD,R6
	LB      R13,AUBTTY,R6
        NHI     R13,AUBVID      :AND WITH VIDEO BITS
        JE      TXTLOP          :JUMP IF NOT VIDEO
        CALL(VBULKB,USRTSV)
        LR      R10,R10         :SET CONDITION CODES
        JLE     STFETX          :JUMP IF OUT OF ROOM
        AIS     R11,2           :INCREMENT LINE COUNTER
	J	TXTLOP
:
:STUFF ETX IS THE LAST ROUTINE TO BE CALLED AND SHOULD ALWAYS
: BE CALLED SINCE ETX IS THE ACTIVATION CHARACTER FOR THE MAG.
: IT WILL CLEAR THE INPUT BUFFER FROM THE MAGPORT AND SEND THE OUTPUT
: BUFFER TO THE USER
STFETX  LR      RUBLK,R6        :MOVE AUB PTR OR FREE PTR TO RUBLK
        TRPORT(TRDATA,USRTSV)   :TRACE
	L	R7,AUBTIM,RUBLK	:CALCULATE THE RESPONSE TIME
	JEFS	NOTIME	JUMP IF NO TIME IS THERE
	L	R9,FASTC,,:	GET THE PRESENT TIME
	SR	R9,R7	GET THE DIFFERENCE
	AM	R9,MGIRSP,R8	AND STORE IT IN THE MAGTAB ENTRY
	LIS	R7,0
	ST	R7,AUBTIM,RUBLK	AND ZERO OUT THE TIME IN THE AUB
NOTIME	LI	R0,MAXSCN	GET OUTPUT BUFFER SIZE
	SR	R0,R10	AND SUBTRACT REMAINING CHAR TO GET FILLED IN SIZE
	LA	R2,OUTBUF,,	 :POINT TO BUFFER
	CALL(SENDMS,USRTSV)
        STH     R11,AUBCOL,R6   :intermediate block
MAG1RT  LR      RUBLK,R8        : RESTORE REGISTER TO MAGTAB
	RETURN(R2)

:(MATS.P2)SGNTXT.S01
:	Created by Margalit	1/15/87

:	This routine handles text packets destined to a user who
:	is in a signin/off process.
:	The routine picks the characters from the bufferlettes and put
:	them in OUTBUF.
:	Each character is translated from sabre to ascii. The same trax
:	table used for normal text messages is used here, no action is taken
:	for characters which are translated into addresses.

:INPUT	RUBLK - points to MAGTAB
:	R2 - points to AUB/Free block


	PROC(SGNTXT)
	CHAIN(SGNTSV)

	LR	R8,RUBLK		: save pointer to MAGTAB
	LR	R6,R2			: save pointer to AUB/F.B.
	
	LH	R1,MAGPRT,RUBLK,	: port number
	SLHLS	R1,2			: buffer number
	LHI	R10,MAXSCN		: output buffer size
	LA	R7,OUTBUF,,		: output buffer address
	L	R9,MAGXLT,R8		: translation table address
	
	JAL	R4,GCI,,		: ger rid of C1
	JAL	R4,GCI,,		: ger rid of C2
	
: Text_Loop: move all chars from bufferlettes to OUTBUF

	LHL	R0,BCT,R1,		: # of chars in bufferlettes
	DO(WHILE,G)			: do while there are chars in buffer
	  JAL	R4,GCI,,		: get a char
	  LR	R5,R0			: char will serve as an index
	  SLHLS	R5,1			: HW index
	  LHL	R5,0,R9,R5		: get value from xlate table
	  CLHI	R5,ETX			: "EOP"
	  EXITDO(E)			: if eop(0d) then we are done
	  LR	R5,R5
	  IFF(G,THEN)			: if a valid char
	    LHI	R12,$0 100		: 256(dec)
	    CLR	R5,R12
	    IFF(L,THEN)			: if a normal graphic char
	      STB  R5,0,R7		: put char in OUTBUF
              AIS  R7,1                 : update outbuf index
	      SIS  R10,1		: one less space in output buffer
	      EXITDO(E)			: no more room --> exit
	    ENDIF			: normal graphic char
	  ENDIF				: a valid char
          LHL   R0,BCT,R1               : any char left ?
	ENDDO				: while there are chars in bufferlett
	
	LR	RUBLK,R6		: pointer to AUB/F.B.
	TRPORT(TRDATA,SGNTSV)		: trace
	
	LI	R0,MAXSCN		: output buffer size
	SR	R0,R10			: length of message in buffer
	LA	R2,OUTBUF,,		: address of buffer
	CALL(SGNPRO,SGNTSV)		: process the sign response
	
	LR	RUBLK,R8		: pointer to MAGTAB
	RETURN(R0)

: (MATS.P2)CHKPNR.05P
:     Copied by Mele from (MATS.P2)CHKPNR.04T on 12/1/83
:     Intoduced conditiional assembly in TOSPNR for the case
:     no PARS2 allowed

: (MATS.P2)CHKPNR.04T
:    Copied by Byrne from (MATS.P2)CHKPNR.03T  3/23/83.
:    Made more code changes for bugs caught during testing.
:    (changed parameters for SNDMAG and SENDMS calls)

: (MATS.P2)CHKPNR.03T
:    Copied by Byrne from (MATS.P2)CHKPNR.02T on 3-22-83.
:    Made code changes for bugs caught during testing.

: (MATS.P2)CHKPNR.02T
:    Copied by Byrne from (MATS.P2)CHKPNR.02T on 2/24/83.
:    Made changes to restructure the code.

: (MATS.P2)CHKPNR.01R
:    Created by Cheung on 11/23/82.
:    CHKPNR checks the PNR security.  The incoming message block
:    is discarded if the PNR security check failed.  An 
:    indicator is returned to the caller to reflect the result
:    of the checking.
:
:   INPUT:
:               C1 and C2 have been removed from the buffer
:               R1 contains port# * 4.
:               R6 contains AUB pointer.
:               R8 contains MAGTAB pointer.
:               R9 contains a pointer to the char. translation table.
:
:   OUTPUT:
:               AUB[AUBPNR] is set either to 'search for PNR' or
:                  'search failed'
:               R0 = TRUE if PNR security check passed ok  or
:                  = FALSE if PNR security check failed
:

                PROC(CHKPNR,A.CUCD)
                CHAIN(CHKPSV,A.CUCD)
        
        LIS     R0,TRUE                 :Preset output to 'PNR security ok'
        LIS     R7,SRHPNR               :Get PNR security indicator
        CLB     R7,AUBPNR,R6,           :IF indicator in AUB = 'search for PNR'
        IFF(E)                          :
           CALL(CHKSEC,CHKPSV)          :THEN check PNR security
        ENDIF


        LIS     R7,DISPNR              :Get PNR security indicator
        CLB     R7,AUBPNR,R6,          :IF indicator in AUB = 'fails PNR sec'
        IFF(E)                         :
           CALL(TOSPNR,CHKPSV)         :THEN discard the message
           LIS     R0,FALSE            :     Set output to 'fails PNR sec'
        ENDIF                          :


        RETURN(R1)




:
:
:       CHKSEC
:              Checks whether or not the message block contains a PNR.
:              If the message block does contain a PNR then the ATC#
:              will be validated for the user.
:
:       
:       INPUT
:               R1 IS PORT# * 4
:               R6 IS AUB POINTER
:               R9 CONTAINS THE POINTER TO THE CHAR TRANSLATION TABLE.
:
:       OUTPUT
:               AUB[AUBPNR] IS SET TO 'DISCARD MESSAGE' IF THE ATC# IN
:               THE MESSAGE BLOCK DID NOT MATCH ANY ATC# IN THE POOL
:               AND THE DEDICATED ATC#.
:





        SEG     2
        RA      0



FIDFA   BC      46,41,2D,20             : 'FA- '
FIDLEN  EQ      .-FIDFA


ATCID   BC      41,4E,2D,20             : 'AN- '
AIDLEN  EQ      .-ATCID




FADLEN  EQ      7                       :NO. OF CHARS IN PNR LOCATOR + SPACE
ATCLEN  EQ      7                       :NO. OF CHARS IN THE ATC NUMBER.
MINRLN  EQ      FIDLEN+AIDLEN+FADLEN+ATCLEN+3   :Minimum length of the PNR
                                                :3 includes SMI, EOM and CR



:  Find the maximum value of FIDLEN, AIDLEN, FADLEN, and ATCLEN

BUFSZ   EQ      FIDLEN                          :::::::::
                                                ::
        IF      AIDLEN-BUFSZ                    :: (AIDLEN > BUFSZ)
BUFSZ   EQ      AIDLEN                          ::
        EI                                      ::
                                                ::
        IF      FADLEN-BUFSZ                    :: (FADLEN > BUFSZ)
BUFSZ   EQ      FADLEN                          ::
        EI                                      ::
                                                ::
        IF      ATCLEN-BUFSZ                    :: (ATCLEN > BUFSZ)
BUFSZ   EQ      ATCLEN                          ::
        EI                                      :::::::::


BUFTMP  BS      BUFSZ                           :temporary storage






                PROC(CHKSEC,A.CUCD)
                CHAIN(CHKSSV,A.CUCD)


        LH      R0,BCT,R1               :Get the number of characters in msg
        CHI     R0,MINRLN               :IF minimum # of chars in the PNR
        IFF(GE)                         :
           JAL     R4,GCPEEK,,          :THEN set up for PEEK actions
           LR      R5,R0                :     character to be translated
           SLHLS   R5,1                 :     convert to halfword index
           LHL     R5,0,R9,R5           :     get translated char from HW table
           STB     R5,BUFTMP,,          :     save translated character

           LA      R8,BUFTMP+1,,        :     continue at the next location
           LIS     R7,FIDLEN-1          :     set up count of chars in file ID
           DO(COUNT,R7)                 :     GET FILE ID FROM INPUT
              JAL     R4,GCSCAN,,       :        get next input character
              LR      R5,R0             :        character to be translated
              SLHLS   R5,1              :        convert to halfword index
              LHL     R5,0,R9,R5        :        get Xlated char from HW table
              STB     R5,0,R8           :        save translated character
              AIS     R8,1              :        point to next BUFTMP location
           ENDDO                        :

           LR      R7,R2                :     save R2 for GCSCAN below
           LR      R8,R3                :     save R3 for GCSCAN below

           LA      R2,FIDFA,,           :     address of correct file ID
           LIS     R3,FIDLEN            :     length of file ID
           LA      R4,BUFTMP,,          :     address of file ID from input
           CALL(COMSTR,CHKSSV)          :     compare correct file ID with input
           LR      R2,R7                :     restore R2 for GCSCAN below
           LR      R3,R8                :     restore R3 for GCSCAN below
           LR      R0,R0                :     R0 = 0 is a match, 1 is no match
           IFF(E)                       :     IF a match
              LIS     R7,FADLEN         :     THEN skip past file address
              DO(COUNT,R7)              :
                 JAL     R4,GCSCAN,,    :          skip past each character
              ENDDO                     :

              LA      R8,BUFTMP,,       :          reset to beginning of save
              LIS     R7,AIDLEN         :          get count of chars in ATC ID
              DO(COUNT,R7)              :          GET ATC ID FROM INPUT
                 JAL     R4,GCSCAN,,    :            get next input character
                 LR      R5,R0          :            character to be Xlated
                 SLHLS   R5,1           :            convert to halfword index
                 LHL     R5,0,R9,R5     :            get Xlated chr from HW tble
                 STB     R5,0,R8,       :            save translated character
                 AIS     R8,1           :            point to next BUFTMP loc
              ENDDO                     :

              LR      R7,R2             :          save R2 for GCSCAN below
              LR      R8,R3             :          save R3 for GCSCAN below

              LA      R2,ATCID,,        :          address of correct ATC ID
              LIS     R3,AIDLEN         :          length of ATC ID
              LA      R4,BUFTMP,,       :          address of ATC ID from input
              CALL(COMSTR,CHKSSV)       :          comp correct ATC ID w/input
              LR      R2,R7             :          restore R2 for GCSCAN below
              LR      R3,R8             :          restore R3 for GCSCAN below
              LR      R0,R0             :          0 is a match, 1 is no match
              IFF(E)                    :          IF  they match
                 LA     R8,BUFTMP,,     :          THEN reset to start of save
                 LIS    R7,ATCLEN       :               count of chars in ATC#
                 DO(COUNT,R7)           :               GET ATC# FROM INPUT
                    JAL    R4,GCSCAN,,  :                 get next input char
                    LR     R5,R0        :                 char to be Xlated
                    SLHLS  R5,1         :                 convert to HW index
                    LHL    R5,0,R9,R5   :                 get Xlated chr from HW
                    STB    R5,0,R8,     :                 table, save chr
                    AIS    R8,1         :                 next BUFTMP loc
                 ENDDO                  :

                 LA     R4,BUFTMP,,     :               address of ATC #
                 LIS    R5,ATCLEN       :               length of ATC #
                 CALL(DECBIN,CHKSSV)    :               convert to binary
                 CLHI   R2,TRUE         :               IF no conversion problem
                 IFF(N)                 :
                    CL     R3,AUBIND,R6 :               IF dedicated ATC#
                    IFF(N)              :                  didn't match
                       LA   R2,INTLUD,,             :   THEN get LUD INTERFACE
                       ST   R3,INTLUD+LUDIND,,      :   save binary ATC #
                       L    R7,AUBIPT,R6,           :   Industry Pool table adr
                       ST   R7,INTLUD+LUDIPT,,      :   LUDREQ starts here
                       LHI  R3,LRATC                :   search for ATC# match
                       CALL(LUDREQ,CHKSSV)          :
                       LR   R0,R0                   :   IF there was no match
                       IFF(E)                       :
                          LIS   R0,DISPNR           :   THEN set the PNR
                          STB   R0,AUBPNR,R6,       :    indicator to 'toss PNR'
                       ENDIF                        :

                    ENDIF               :Dedicated ATC# check

                 ENDIF                  :DECBIN conversion problem

              ENDIF                     :ATC ID check

           ENDIF                        :FILE ID check

        ENDIF                           :minimum # of chars in message check


        RETURN(R0)





:
:       TOSPNR
:               All characters of the message in the bufferlets are
:               discarded.  If an EOM-C or an EOM-U is found in the
:               current bufferlets then the AUB[AUBPNR] is reset and
:               an IGNORE message is sent to the airline.  If the
:               IGNORE message can't be translated by the common
:               language, then an "I" will be sent.
:
:       INPUT
:               R1 CONTAINS PORT# * 4.
:               R6 CONTAINS AUB POINTER
:               R8 CONTAINS MAGTAB POINTER
:
:       OUTPUT
:               RESET AUB[AUBPNR] TO 'SEARCH FOR PNR' IF EOMC OR EOMU IS FOUND.
:
:

        SEG     2
        BND     2
IGNORE  AC      /I"00/
ASIGOR  SC      /I/
EOMCOU  WC      $0 4, 40000              :a 64 bit array, bits are turned on
                                         :for the characters to be selected
                                         :in this case EOM-C = 1D and
                                         :EOM-U = 2D


        IF      PARS.2
PNRMSG  SC      /(PARSII) PNR SECURED/
        ELSE
PNRMSG  SC      /(CARL) PNR SECURED/
        EI

                PROC(TOSPNR,A.CUCD)
                CHAIN(TOSSAV,A.CUCD)


        LH      R7,BCT,R1               :Get number of chars in the bufferlets
        DO(WHILE,G)                     :DO WHILE there are still chars left
           JAL     R4,GCI,,             :Get next character from bufferlets
           NHI     R0,$0 3F             :mask out upper 2 bits for bit array rng
           TBT     R0,EOMCOU,,          :IF char is EOM-C  or  EOM-U
           IFF(N)                       :
              JAL     R4,EMPTY,,        :THEN empty the buffer completely
              LIS     R7,0              :set count of characters to stop loop
              LHL     R0,IGNORE,,       :put 'I0' command into
              STH     R0,CMDDAT,,       :the common language buffer
              LIS     R2,2              :length of 2 characters in CMDDAT
              LR      R1,R6             :AUB pointer, parameter to PARS2 or CARL

	
	      IF     1-NOPARS		:If PARS allowed
              IF      PARS.2
                      GL    PARS2       :USE PARS2 COMMON LANGUAGE
                      JAL   R15,PARS2,, :
              ELSE
                      GL    CARL        :USE CARL COMMON LANGUAGE
                      JAL   R15,CARL,,  :
              EI
	      EI

              LR      R0,R0             :IF there is an error in translation
              IFF(N)                    :
                 LA      R2,ASIGOR+1,,  :THEN use 'I' as the message to send
                 LB      R3,ASIGOR,,    :     to the MAG

                 LIS     R0,1           :increment the
                 AHM     R0,ERCARL,,    :common language translation error count
              ENDIF                     :

              LB      R13,IA,,          :Get IA from MAGDAT
              STB     R13,CMDIA,,       :Save as parameter for SNDMAG
              LB      R13,TA,,          :Get TA from MAGDAT
              STB     R13,CMDTA,,       :Save as parameter for SNDMAG
              LR      R13,R8            :Get MAGTAB pointer
              CALL(SNDMAG,TOSSAV)       :send ignore message to the MAG
              L       R8,FASTC,,        :set 'RESET' time out
              ST      R8,AUBTIM,R6,     :starting from now

              LB      R0,PNRMSG,,       :get length of message
              LA      R2,PNRMSG+1,,     :get address of message
              LR      R1,R6             :AUB pointer is parameter
              CALL(SENDMS,TOSSAV)       :send the 'SECURED' msg to user's trm

              LIS     R8,SRHPNR         :set to 'search' for next block
              STB     R8,AUBPNR,R6,     :
           ENDIF                        :

           SIS      R7,1                :decrement number of chars left in
                                        :bufferlets
        ENDDO                           :


        RETURN(R0)

:(TIGERDEV)VALPRT.01C
:       Copied by Chen from (TEST.INA)VALPRT.07A on 6/14/85
:       Made a new directory for Flying Tiger project.
:
:(TEST.INA)VALPRT.07A
:	Copied by Margalit from (MATS.P2)VALPRT.06P	5/7/85
:	There in no more check upon industry code

:
:       Created by Kirk Adams 1/24/81



:***********************************************************************
:
:     Author: Kirk Adams
:
:     VALPRT    (VALidate PRinTer)
:
:     Register Usage:
:
:       Link: RLINK
:
:       Input:
:         R5  is a pointer to the AUB (Active User Block)
:         R6  is the FMPORT port number
:         R7  is a pointer to the printer res block
:
:       Output:
:         R4  is VALID, an indicator of success (TRUE or FALSE)
:
:       Internal:
:         R0-R3 are used by the BUFFER.LIB routines, and care should be
:               taken when using these registers.  Some segments of this
:               subroutine use these registers as scratch registers.
:               R0-R3 are not restored upon return.
:
:       Notes:
:
:         1. The registers which are used as pointers contain addresses,
:            not offsets.
:         2. Comments are based upon the pseudo-code used to write this
:            subroutine.  If a pseudo-code statement requires more than
:            one instruction to implement, these additional instructions
:            are flagged by ":*" in the comments field.
:
:***********************************************************************



  PROCS(VALPRT,$00D)
  CHAINS(VPRTSV,$00D)           :***************************************
  DEBUGM(Entering VALPRT,DBGPRT,DALL,VPRTSV,$00D)
  LIS     R8,TRUE               :Set VALID to TRUE
  LB      R9,RES,,              :Compute MAG
  CVTRES(R9,VPRTSV)             :*
  LHI     R1,MAGLNG             :*
  MHR     R9,R1                 :*
  AI      R9,MAGTAB             :*
  L       R0,AUBPRB,R5,         :Is printer assigned?
  IFF(E)                        :Printer is not assigned
    L       R1,AUBTIB,R5        :get TIB pointer
    LB      R1,TIBPRI,R1        :TRUE if term supports printing
    IFF(E)                      :if FALSE (i.e. if Equal to zero)
      LIS     R8,FALSE          :then this terminal doesn't support printing
    ENDIF
    LHL     R1,AUBPTY,R5,       :Is printer type null?
    CLHI    R1,PTYNOP           :*
    IFF(E)                      :Printer type is null
      LIS     R8,FALSE          :Set VALID false
    ENDIF                       :Printer type is null
    LB      R1,MAGSPT,R9,       :Does this res support printing?
    IFF(E)                      :Does not support printing
      LIS     R8,FALSE          :Set VALID false
    ENDIF                       :Does not support printing
    LB      R1,RBVPT,R7,        :Is user valid to prt on this res?
    IFF(E)                      :User not valid to print
      LIS     R8,FALSE          :Set VALID false
    ENDIF                       :User not valid to print
  ORELSE                        :Printer is already assigned
    C       R7,AUBPRB,R5,       :Is printer assigned to different RES?
    IFF(N)                      :Wrong RES block
      LIS     R8,FALSE          :Set VALID FALSE
    ENDIF                       :Different RES block
  ENDIF                         :Printer is not assigned

  CLHI    R8,TRUE               :Are res and user valid?
  IFF(E)                        :Data is from correct RES

    LB   R12,AUBPMI,R5,		: then check if first block
    IFF(E,THEN)
        L       R12,AUBPRB,R5,    :Is AUBPRB = 0?
        IFF(E)                    :Printer not attached
         CLHI    R8,TRUE           :Is VALID TRUE
         IFF(E)                   :Attach printer
          LR      R1,R5           :Input to ACTPTR - ^ AUB
          LR      R3,R7           :Input to ACTPTR - ^ RES Block
          CALL(ACTPTR,VPRTSV)     :To assign the printer
          CALL(SNDBAN,VPRTSV)     :To display updated banner
         ENDIF                    :Attach printer
        ENDIF                     :Printer not attached
        STB     R8,AUBPMI,R5,     :Set AUBPMI to value of VALID
     ORELSE                      :Not a start message block
        LIS     R12,FALSE         :Examine the state of the indicator 
        CLB     R12,AUBPMI,R5,    :*AUBPMI
        IFF(E)                    :AUBPMI is FALSE
          LIS     R8,FALSE        :Set VALID FALSE
        ENDIF                     :AUBPMI is FALSE
     ENDIF                       :No start message block
  ENDIF                         :Data is from correct RES
  LR      R4,R8                 :Output from VALPRT - VALID indicator
  RETURN(R5)                    :***************************************
:  (MATS.P2)SBUPRT.11P
:	Copied by MELE from (MATS.P2)SBUPRT.10P on 12/06/83.
:	In the MARS+ case 20 lf are added after every ETXVIP
:
:  (MATS.P2)SBUPRT.10P
:    	Copied by Mele from (MATS.P2)SBUPRT.09P on 12/4/83.
:	Fixed bug in MRSPRT.

: (MATS.P2)SBUPRT.09P
:	Copied by Mele from (MATS.P2)SBUPRT.08K on 11/1/83.
:	Changed code in SBUPRT to handle the MARSPLUS service.
:	Added the routine MRSPRT that ,in MARSPLUS case, will send
:	characters to the printer this routine is only called from
:	SBUPRT.
:
: (MATS.P2)SBUPRT.08K
:       Copied by ADAMS from (MATS.P2)SBUPRT.07L
:       Added code to maintain some counters for the MATS STATS project.

:  (MATS.P2)SBUPRT.07L
:  Copied by VAYSBURD from (MATS.P2)SBUPRT.06S
:  Added command LH before fullword maltiply because AUBLNS is a halfword
:  variable
: (MATS.P2)SBUPRT.06S
:    COPIED BY GIMNICHER FROM (MATS.P2)SBUPRT.05K
:    SOME BUG FIXES MADE FOUND DURING TESTING.

: (MATS.P2)SBUPRT.03S.
:   Copied by Gimnicher from (MATS.P2)SBUPRT.02L
:   Fixed a bug uncovered by printer test # 32 - receipt of printer
:   reset message.

:
:   (MATS.P2)SBUPRT.02L
:    Copied by Vaysburd from (VAYSBURD)SBUPRT.01L 1/30/81
:    Added the control if printer RES BLOCK pointer equal to 0 or not.
:
:  (VAYSBURD)SBUPRT.01L
:  
: This file was created by Svetlana Vaysburd on 01.21.81.
: It removes characters from the specified buffer, translates
: them as appropriate, and  places them in the user's output buffer.
: It assumes that the data in from-buffer came from the active printer RB
:
:       Input: FROM-BUFFER-INDEX-R2
:              AUB-POINTER-R1
:
:       Output:updated from-buffer
:              updated user output buffer
:              yellow ball in user's output buffer
:              ack message to MAG
:              updated AUB
:              updated printer RB
:
        SEG     0
        GL      EOMC,EOMPB,EOMI,EOMU,ETX
EOMC    EQ      $8 35
EOMPB   EQ      $8 75
EOMI    EQ      $8 15
EOMU    EQ      $8 55
ETX     EQ      $0 0D
ETXVIP  EQ	$0 83
:
        PROCS(SBUPRT,$00D)
        CHAINS(SBUPSV,$00D)
        DEBUGM(Entering SBUPRT,DBGPRT,DALL,SBUPSV,$00D)
SBU1T  :***Test label***
:
        IF      METER
                L       R4,FASTC,,
                S       R4,AUBYBT,RUBLK,
                LH      R5,AUBLNS,RUBLK,
                MR      R3,R5                              :R4-ELAPSED TIME
SBUELT  :***Test label***
                LHI     R10,RATE
                DR      R3,R10                          :R4-quotient
                LH      R6,AUBYBC,RUBLK,
                SR      R6,R4
                IFF(LE,THEN)                             
                  LIS   R6,0
                ENDIF
                STH     R6,AUBYBC,RUBLK,
                L       R3,FASTC,,
                ST      R3,AUBYBT,RUBLK,                :set tyme to FASTC
        EI
SBU2T   :***Test label***

        LR      R10,R2                                  :save R2 in R10
        LR      R7,RUBLK                                :save RUBLK in R7
        LH      R5,AUBPRT,RUBLK,                        :R5-AUB port#
        SLLS    R5,2
        AHI     R5,2                                    :R5-output buffer index
        LH      R9,BCT,R2,                              :#char. to be processed-R9
        IFF(N,THEN)                                     :if not 0
:
:  For the rest of this routine, the following
:  registers must not be reused.
                                                        :r10-from-buffer-index
                                                        :R7 -RUBLK
                                                        :R5 -output-buffer-index
                                                        :R9 -#char.to be processed
SBU3T   :***Test label***

          LH    R3,AUBPRT,RUBLK,
          LO    FRONT
          TBT   R3,TOISIS,,                             :check bit array
          FO    FRONT
          IFF(N,THEN)                                   :not backpressured
SBU4T   :***Test label***
            CALL(TUPRON,SBUPSV)                         :turn printer on

	    L  R13,AUBPRB,R7,				:R13 points to prt RB
	    IFF(E,THEN)
	      LR  R1,R10
	      JAL R4,EMPTY,,
	    ORELSE
	      LH  R4,RBRESN,R13,
	      CVTRES(R4,SBUPSV)				:get the MAG entry numb.
	      LHI R6,MAGLNG
	      MR  R3,R6
	      LB  R1,MAGTAB+MGSRIN,R4,
	      IFF(G,THEN)				:Is MARS+?
	        CALL(MRSPRT,SBUPSV)
	      ORELSE



            LR  R9,R9                                   :#char.to process
            DO(UNTIL,LE)
              LB  R3,AUBYBO,R7,                         :is YB out
              IFF(N,THEN)                               :yes
                LH   R8,AUBYBC,R7,                      :R8-# char. sent
                CLH  R8,AUBYBM,R7,                      :compare with max
                IFF(GE,THEN)
                  EXITDO                                :exit if greater
                ENDIF
              ENDIF                                     :end of check
              LR  R1,R10                                :R1-from-buffer-index
              JAL R4,GCI,,                              :get char.in R0
              SIS R9,1                                  :decrement char count
              LHI R3,EOMC
              OI  R3,$8200                              :turn on high bit
              CR  R3,R0
              IFF(E,THEN)                               :it is EOMC
                LIS   R3,1                              :increment error count.
                AHM   R3,ERSBE1,,
                CLHI  R9,1
                IFF(N,THEN)                             :should have only 1 char
                  LIS   R3,1
                  AHM   R3,ERSBI1,,
                ENDIF
                JAL   R4,EMPTY,,                        :empty from-buffer
                                                        :R1-from-buffer-index
                LIS   R3,0
                STB   R3,AUBPMI,R7,                     :reset AUBPMI
              ORELSE                                    :it isn't EOMC
                LHI   R3,EOMPB
                OI    R3,$8200                          :turn on high bit
                CR    R3,R0                             :is it a EOMPB
                IFF(E,THEN)                             :yes
                  LIS  R3,1                             :shouldn't get this char
                  AHM  R3,ERSBE2,,
                  CLHI R9,1
                  IFF(N,THEN)                           :if not 1 char follows
                    LIS  R3,1
                    AHM  R3,ERSBI2,,
                  ENDIF
                  JAL    R4,EMPTY,,                     :R1-from-buffer-index
                ORELSE                                  :it is not EOMPB
                  LHI  R3,EOMI
                  OI   R3,$8200                         :turn on high bit
                  CR   R3,R0                            :is it EOMI
                  IFF(E,THEN)                           :it is
                    L   R11,AUBPRB,R7,                  :R11-points to prt RB
                    IFF(n,THEN)                         :PRT RB =0 ?
                     LH  R4,RBRESN,R11,                  :r4-RES number
                     LR  R2,R4
                     CVTRES(R4,SBUPSV)                   :get appropr.MAG entry
                     LHI R6,MAGLNG
                     MR  R3,R6                           :R4-offset into MAGTAB
                     LH  R1,MAGTAB+MAGPRT,R4,            :R1-MAGport
                     L   R3,RBPTTA,R11,                  :R3-printer RES-IA-TA
                     LR  R4,R3
                     SRHL R3,$A 8
                                                        :INPUTS
                                                        :R1 -MAG port
                                                        :R2 -RES number
                                                        :R3 -printer IA
                                                        :R4 -printer TA
                     CALL(ACKPTR,SBUPSV)
                    ENDIF                               :AUBPRB shouldn't be0,
                                                        :error count.will be incremented
                                                        :at the end of this routine
                    CLHI R9,1
                    IFF(N,THEN)                         :not 1 char.in from-buf
                      LIS  R3,1                         :increm.error count
                      AHM  R3,ERSBI3,,
                    ENDIF
                    LR   R1,R10                         :restore from bufferindex
                    JAL  R4,EMPTY,,
                  ORELSE                                :not a EOMI
                    LHI  R3,EOMU
                    OI   R3,$8200
                    CR   R3,R0                          :if it is EOMU
                    IFF(E,THEN)                         :it is
                      L   R11,AUBPRB,R7,                :R11-pointer to prt RB
                      IFF(N,THEN)                       : PRT RB =0?
                       LIS R4,1
                       AM  R4,RBNTIK,R11,               :a MATS STATS counter
                       LH  R4,RBRESN,R11,                :R4-RES number
                       LR  R2,R4                         :R2-RES#
                       CVTRES(R4,SBUPSV)                 :get appropr.MAG entry
                       LHI R6,MAGLNG
                       MR  R3,R6                         :R4-offset into MAGTAB
                       LH  R1,MAGTAB+MAGPRT,R4,          :R1-MAG port
                       L   R3,RBPTTA,R11,                :R3-printer RES-IA-TA
                       LR  R4,R3                         :
                       SRHL R3,$A 8
                        CALL(ACKPTR,SBUPSV)
                      ENDIF                             :error count will be 
                                                        :increm.at the end of rout.
                      CLHI R9,1
                      IFF(N,THEN)                       :not 1 char.in from-buffer
                        LIS  R3,1
                        AHM  R3,ERSBI4,,
                      ENDIF
                      LR   R1,R10                       :restore from-buffer-index
                      JAL  R4,EMPTY,,
                      LIS  R3,0
                      STB  R3,AUBPMI,R7,                :show printer is not in progress
                    ORELSE
                      CLHI R0,ETX                       :if it is a ETX
                      IFF(E,THEN)                       :yes
                        LIS  R3,1
                        AHM  R3,ERSBE5,,
                        LR   R1,R10                     :restore from-buffer-index
                        JAL  R4,EMPTY,,
                      ORELSE                            :it is not ETX
                                                        :IT IS DATA CHARACTER
                        LR  R1,R5                       :put output buf-index
                        NHI R0,$877                     :start out with 6 bits
                        SLHLS R0,1                      :get relative address
                        LR  R6,R0                       :move offset to R6
                        LHL R11,SAT.PT,R6,              :pick up pointer
                        LB  R6,SAT.BS,R11,              :R6-gets # of char.
                        LH  R8,AUBYBC,R7,               :CURRENT COUNT AFTER YB
                        DO(COUNT,R6)
                          AIS  R11,1                    :increm.pointer
                          LB   R0,SAT.BS,R11,           :get char.
                          JAL  R4,WCI,,                 :send char.to output buf
                          AIS  R8,1                     :increm.count.
                        ENDDO
                        STH    R8,AUBYBC,R7,            :Save yellow ball count
                        CLH    R8,AUBYBM,R7,            :compare counter max
                        IFF(GE,THEN)
                          LB  R3,AUBYBO,R7,             :if yellow ball out
                          IFF(E,THEN)                   :no yellow ball out
                            LIS  R3,1
                            STB  R3,AUBYBO,R7,          :set yellow ball out
                            IF  1-METER
                                LIS   R0,0              :escape char.for YB msg
                                LR   R1,R5              :R1- port buffer-index
                                JAL   R4,WCI,,
                                LHI   R0,YBMSG          :send yellow ball
                                JAL   R4,WCI,,
                                LIS   R8,0
                                STH   R8,AUBYBC,R7,     :store 0 in counter
                                L     R3,FASTC,,
                                ST    R3,AUBYBT,R7,     :store FASTC
                            EI
                          ENDIF                         :yellow ball was out
                        ENDIF                           :max char.after YB wasn't reached
                      ENDIF                             :end not ETX
                    ENDIF                               :end not EOMU
                  ENDIF                                 :end not EOMI
                ENDIF                                   :end not EOMPB
              ENDIF                                     :end not EOMC
              LH   R9,BCT,R10,                          :get remaining char count
SBUED0  :***Test label***

                                                        :to be processed
            ENDDO

	    ENDIF					:end MARS+ case
	    ENDIF					:end prt RE not 0


            LR  RUBLK,R7                                :restore RUBLK
            CALL(TUPROF,SBUPSV)
          ENDIF                                         :end not backpressured
          L   R3,SLOWC,,
          ST  R3,AUBLCT,RUBLK,                          :store SLOWC
          L   R4,AUBPRB,R7,                             :R3-printer RB
          IFF(N,THEN)                                   :PRT RB =0?
           L   R5,RBSCHT,R4,
           IFF(N,THEN)
             ST  R3,RBSCHT,R4,
           ENDIF
          ORELSE
            LIS  R6,1                                   :increm.error counter
            AHM  R6,ERSBE4,,                            :PRT RB pointer shouldn't =0
          ENDIF
        ENDIF                                           :end count of char.=0
SBU9T   :***Test label***

:
        RETURN(R0)
           PROC(MRSPRT)
           CHAIN(MRSSAV)

:   This routine is only called by SBUPRT  in the case :MARSPLUS service.
:   It is used  to remove characters ,sent by MARSPLUS, from a specified
:   buffer and places them in the user's output buffer.It assumes that
:   the data in from-buffer come from active printer Res_block.
:
:   Input parameters:
:
:	R10  {pointer to "from_buffer"}
:	R7   {pointer to AUB table}
:	R9   {#char to be processed}
:	R5   {output buffer index}
:
:   It will update "from_buffer",user output buffer,yellow ball in 
:   user's output buffer,AUB,printer RB


            LR  R9,R9                                   :#char.to process
            DO(UNTIL,LE)

              LH   R8,AUBYBC,R7,                      :R8-# char. sent
              CLH  R8,AUBYBM,R7,                      :compare with max
              IFF(GE,THEN)
                  EXITDO                                :exit if greater
              ENDIF

              LR  R1,R10                                :R1-from-buffer-index
              JAL R4,GCI,,                              :get char.in R0
	      LR  R1,R5					:R1-out-buf-ind
              CLHI R0,ETX				:Is EOP ?
	      IFF(N,THEN)
                CLHI R0,ETXVIP				:Or ETXVIP ?
                IFF(E,THEN)				:Is ETXVIP
                 LIS  R3,0
                 STB  R3,AUBPMI,R7,                 :show printer is not in progress
	         LHI   R0,$08A			:Put LF in r0
		 LHI   R9,$015
		 DO(COUNT,R9)			:20 times in out-buf
		    JAL  R4,WCI,,
		 ENDDO
		 AHM R9,AUBYBC
                ORELSE                               :it is not ETX
                                                   :IT IS DATA CHARACTER
                 JAL  R4,WCI,,                      :send char.to output buf
		 AIS  R8,1
                 STH  R8,AUBYBC,R7,                 :save yellow ball count

	        ENDIF				    :normal char case
  	      ENDIF				    :no EOP case
	     LH  R9,BCT,R10,
           ENDDO
        RETURN(R1)    
            



: (TIGERDEV)TGRPRT.S01
:   Copied by Byrne from (TIGERDEV)SBUPRT.02C on 5-Aug-86
:   Renamed Flying Tigers SBUPRT to TGRPRT.
:
:
:
:PROCEDURE: TGRPRT
:
:        This routine moves printer messages from an input buffer
:        to the user output buffer. An EOM or ETX are handled
:        seperatly from the text characters.When a text character
:        is processed we can be in one of five states:
:        
:                1. DATA - text character was received
:                2. SHIFT - a SHIFT character was received
:                3. SPECIAL - a special character code
:                4. COUNT - a count chr was received(compress)
:                5. DIGIT - a digit was received after a count
:                
:        There is an action routine associated with each state:
:        
:                1. ADATA - the SABRE character is translated to
:                        an ASCII string. The character is saved
:                        in Last_Character
:                2. ARETRN - return                                
:                3. ASPECL - A special translation table is used
:                        to translate the character into Ascii,
:                        the Ascii chr is put in the output buf
:                4. ARETRN - return                     
:                5. ADIGIT - write to the output buf count+2
:                        times the translation of Last_Character
:
:        This routine assumes that the data is the from-buffer
:        came from the active printer Res Block.
:
:        This routine references the bit array TOISIS in FRONT.LIB;
:        in it, a bit is zero when the port is backpressured by
:        Tymnet.  TGRPRT will not send pronter data while the user's
:        port is backpressured, nor will it ack the printer IA-TA.
:
:       Input: FROM-BUFFER-INDEX-R2
:              AUB-POINTER-R1
:	       RBPRTS[printer RES]: Last_State of printer message
:	       RBPRTC[printer RES]: Last_Character of printer message
:
:       Output:updated from-buffer
:              updated user output buffer
:              yellow ball in user's output buffer
:              ack message to MAG
:              updated AUB
:              updated printer RB
:
        SEG     0
        GL      EOMC,EOMPB,EOMI,EOMU,ETX
EOMC    EQ      $8 35
EOMPB   EQ      $8 75
EOMI    EQ      $8 15
EOMU    EQ      $8 55
ETX     EQ      $0 0D
ETXVIP  EQ	$0 83
:
        SEG     2
SAVLNK  WS      1               :save link register area
SAVER7  WS      1
:        
        PROCS(TGRPRT,$00D)
        CHAINS(TGRPSV,$00D)
        DEBUGM(Entering TGRPRT,DBGPRT,DALL,TGRPSV,$00D)

        IF      METER
                L       R4,FASTC,,
                S       R4,AUBYBT,RUBLK,
                LH      R5,AUBLNS,RUBLK,
                MR      R3,R5                              :R4-ELAPSED TIME
                LHI     R10,RATE
                DR      R3,R10                          :R4-quotient
                LH      R6,AUBYBC,RUBLK,
                SR      R6,R4
                IFF(LE,THEN)                             
                  LIS   R6,0
                ENDIF
                STH     R6,AUBYBC,RUBLK,
                L       R3,FASTC,,
                ST      R3,AUBYBT,RUBLK,                :set tyme to FASTC
        EI

        LR      R10,R2                                  :save R2 in R10
        LR      R7,RUBLK                                :save RUBLK in R7
        LH      R5,AUBPRT,RUBLK,                        :R5-AUB port#
        SLLS    R5,2
        AHI     R5,2                                    :R5-output buffer index
        LH      R9,BCT,R2,                              :#char. to be processed-R9
        IFF(N,THEN)                                     :if not 0
:
:  For the rest of this routine, the following
:  registers must not be reused.
                                                        :r10-from-buffer-index
                                                        :R7 -RUBLK
                                                        :R5 -output-buffer-index
                                                        :R9 -#char.to be processed

          LH    R3,AUBPRT,RUBLK,
          LO    FRONT
          TBT   R3,TOISIS,,                             :check bit array
          FO    FRONT
          IFF(N,THEN)                                   :not backpressured
            CALL(TUPRON,TGRPSV)                         :turn printer on

	    L  R13,AUBPRB,R7,				:R13 points to prt RB
	    IFF(E,THEN)
	      LR  R1,R10
	      JAL R4,EMPTY,,
	    ORELSE
	      LH  R4,RBRESN,R13,
	      LB  R12,RBPRTS,R13,			: R12 - Last_State
	      LB  R13,RBPRTC,R13,			: R13 - Last_Character
	      CVTRES(R4,TGRPSV)				:get the MAG entry numb
	      LHI R6,MAGLNG
	      MR  R3,R6
	      LB  R1,MAGTAB+MGSRIN,R4,



            LR  R9,R9                                   :#char.to process
            DO(UNTIL,LE)
              LB  R3,AUBYBO,R7,                         :is YB out
              IFF(N,THEN)                               :yes
                LH   R8,AUBYBC,R7,                      :R8-# char. sent
                CLH  R8,AUBYBM,R7,                      :compare with max
                IFF(GE,THEN)
                  EXITDO                                :exit if greater
                ENDIF
              ENDIF                                     :end of check
              LR  R1,R10                                :R1-from-buffer-index
              JAL R4,GCI,,                              :get char.in R0
              SIS R9,1                                  :decrement char count
              LHI R3,EOMC
              OI  R3,$8200                              :turn on high bit
              CR  R3,R0
              IFF(E,THEN)                               :it is EOMC
                LIS   R3,1                              :increment error count.
                AHM   R3,ERSBE1,,
                CLHI  R9,1
                IFF(N,THEN)                             :should have only 1 char
                  LIS   R3,1
                  AHM   R3,ERSBI1,,
                ENDIF
                JAL   R4,EMPTY,,                        :empty from-buffer
                                                        :R1-from-buffer-index
                LIS   R3,0
                STB   R3,AUBPMI,R7,                     :reset AUBPMI
              ORELSE                                    :it isn't EOMC
                LHI   R3,EOMPB
                OI    R3,$8200                          :turn on high bit
                CR    R3,R0                             :is it a EOMPB
                IFF(E,THEN)                             :yes
                  LIS  R3,1                             :shouldn't get this char
                  AHM  R3,ERSBE2,,
                  CLHI R9,1
                  IFF(N,THEN)                           :if not 1 char follows
                    LIS  R3,1
                    AHM  R3,ERSBI2,,
                  ENDIF
                  JAL    R4,EMPTY,,                     :R1-from-buffer-index
                ORELSE                                  :it is not EOMPB
                  LHI  R3,EOMI
                  OI   R3,$8200                         :turn on high bit
                  CR   R3,R0                            :is it EOMI
                  IFF(E,THEN)                           :it is
                    L   R11,AUBPRB,R7,                  :R11-points to prt RB
                    IFF(n,THEN)                         :PRT RB =0 ?
                     LH  R4,RBRESN,R11,                  :r4-RES number
                     LR  R2,R4
                     CVTRES(R4,TGRPSV)                   :get appropr.MAG entry
                     LHI R6,MAGLNG
                     MR  R3,R6                           :R4-offset into MAGTAB
                     LH  R1,MAGTAB+MAGPRT,R4,            :R1-MAGport
                     L   R3,RBPTTA,R11,                  :R3-printer RES-IA-TA
                     LR  R4,R3
                     SRHL R3,$A 8
                                                        :INPUTS
                                                        :R1 -MAG port
                                                        :R2 -RES number
                                                        :R3 -printer IA
                                                        :R4 -printer TA
                     CALL(ACKPTR,TGRPSV)
                    ENDIF                               :AUBPRB shouldn't be0,
                                                        :error count.will be incremented
                                                        :at the end of this routine
                    CLHI R9,1
                    IFF(N,THEN)                         :not 1 char.in from-buf
                      LIS  R3,1                         :increm.error count
                      AHM  R3,ERSBI3,,
                    ENDIF
                    LR   R1,R10                         :restore from bufferindex
                    JAL  R4,EMPTY,,
                  ORELSE                                :not a EOMI
                    LHI  R3,EOMU
                    OI   R3,$8200
                    CR   R3,R0                          :if it is EOMU
                    IFF(E,THEN)                         :it is
                      L   R11,AUBPRB,R7,                :R11-pointer to prt RB
                      IFF(N,THEN)                       : PRT RB =0?
                       LIS R4,1
                       AM  R4,RBNTIK,R11,               :a MATS STATS counter
                       LH  R4,RBRESN,R11,                :R4-RES number
                       LR  R2,R4                         :R2-RES#
                       CVTRES(R4,TGRPSV)                 :get appropr.MAG entry
                       LHI R6,MAGLNG
                       MR  R3,R6                         :R4-offset into MAGTAB
                       LH  R1,MAGTAB+MAGPRT,R4,          :R1-MAG port
                       L   R3,RBPTTA,R11,                :R3-printer RES-IA-TA
                       LR  R4,R3                         :
                       SRHL R3,$A 8
                        CALL(ACKPTR,TGRPSV)
                      ENDIF                             :error count will be 
                                                        :increm.at the end of rout.
                      CLHI R9,1
                      IFF(N,THEN)                       :not 1 char.in from-buffer
                        LIS  R3,1
                        AHM  R3,ERSBI4,,
                      ENDIF
                      LR   R1,R10                       :restore from-buffer-index
                      JAL  R4,EMPTY,,
                      LIS  R3,0
                      STB  R3,AUBPMI,R7,                :show printer is not in progress
                    ORELSE
                      CLHI R0,ETX                       :if it is a ETX
                      IFF(E,THEN)                       :yes
                        LIS  R3,1
                        AHM  R3,ERSBE5,,
                        LR   R1,R10                     :restore from-buffer-index
                        JAL  R4,EMPTY,,
                      ORELSE                            :it is not ETX
                                                        :IT IS DATA CHARACTER
			
			
                        LR  R1,R5                       :put output buf-index
                        NHI R0,$877                     :start out with 6 bits
			LR  R6,R0			:Current_Character
                        LHI R8,NMBSTT                   :go to correct STTTBL
                        MR  R11,R8                      :address[Cur_st*5]
			LB  R6,CLSTBL,R6,		:Character_Class
			LB  R12,STTTBL,R12,R6		:Current_State
			LR  R11,R12
			SLHLS R11,2			: word index
			L   R6,ACTRTN,R11,		:Action Routine
			LH  R8,AUBYBC,R7,		:current count after YB
			JALR R3,R6			:call action routine
			
                        STH    R8,AUBYBC,R7,            :Save yellow ball count
                        CLH    R8,AUBYBM,R7,            :compare counter max
                        IFF(GE,THEN)
                          LB  R3,AUBYBO,R7,             :if yellow ball out
                          IFF(E,THEN)                   :no yellow ball out
                            LIS  R3,1
                            STB  R3,AUBYBO,R7,          :set yellow ball out
                            IF  1-METER
                                LIS   R0,0              :escape char.for YB msg
                                LR   R1,R5              :R1- port buffer-index
                                JAL   R4,WCI,,
                                LHI   R0,YBMSG          :send yellow ball
                                JAL   R4,WCI,,
                                LIS   R8,0
                                STH   R8,AUBYBC,R7,     :store 0 in counter
                                L     R3,FASTC,,
                                ST    R3,AUBYBT,R7,     :store FASTC
                            EI
                          ENDIF                         :yellow ball was out
                        ENDIF                           :max char.after YB wasn't reached
                      ENDIF                             :end not ETX
                    ENDIF                               :end not EOMU
                  ENDIF                                 :end not EOMI
                ENDIF                                   :end not EOMPB
              ENDIF                                     :end not EOMC
              LH   R9,BCT,R10,                          :get remaining char count
SBUED0  :***Test label***

                                                        :to be processed
            ENDDO

            L   R4,AUBPRB,R7,                            :get prt RES pointer
	    STB R12,RBPRTS,R4,				:Last_State
	    STB R13,RBPRTC,R4,				:Last_Character


	    ENDIF					:end prt RE not 0


            LR  RUBLK,R7                                :restore RUBLK
            CALL(TUPROF,TGRPSV)
          ENDIF                                         :end not backpressured
          L   R3,SLOWC,,
          ST  R3,AUBLCT,RUBLK,                          :store SLOWC
          L   R4,AUBPRB,R7,                             :R3-printer RB
          IFF(N,THEN)                                   :PRT RB =0?
           L   R5,RBSCHT,R4,
           IFF(N,THEN)
             ST  R3,RBSCHT,R4,
           ENDIF
          ORELSE
            LIS  R6,1                                   :increm.error counter
            AHM  R6,ERSBE4,,                            :PRT RB pointer shouldn't =0
          ENDIF
        ENDIF                                           :end count of char.=0
SBU9T   :***Test label***

:
        RETURN(R0)


: PROCEDURE ADATA

:	This action routine handles text characters. Each Sabre character
:	is translated into an Ascii string. In addition the Sabre
:	character is saved for data compression.
	

ADATA           ST    R3,SAVLNK,,               :save link register
		LR    R13,R0			:Last_Character
   		SLHLS R0,1                      :get relative address
                LR  R6,R0                       :move offset to R6
                LHL R11,SAT.PT,R6,              :pick up pointer
                LB  R6,SAT.BS,R11,              :R6-gets # of char.
                DO(COUNT,R6)
                  AIS  R11,1                    :increm.pointer
                  LB   R0,SAT.BS,R11,           :get char.
                  JAL  R4,WCI,,                 :send char.to output buf
                  AIS  R8,1                     :increm.count.
                ENDDO
                L   R3,SAVLNK,,                 :restore link register
		JR  R3				:return

: PROCEDURE ARETRN

ARETRN		JR R3				:return

: PROCEDURE ASPECL

:	This action routine translates the special character code
:	into an Ascii character and places it in the output buffer


ASPECL          ST  R3,SAVLNK,,                 :save link register
		LR  R6,R0			:special char
		LB  R0,SPCTBL,R6,		:translate to Ascii
		JAL R4,WCI,,			:put it in output buf
		AIS R8,1			:increment count
                L   R3,SAVLNK,,                 :restore link register
		JR  R3				:return

: PROCEDURE ADIGIT

:	This action routine decompress data. The Last_Character is
:	written COUNT+2 times to the output buffer after it has
:	been translated to an Ascii string.
	

ADIGIT		ST  R3,SAVLNK,,			:save link register
                ST  R7,SAVER7,,

		CHI R0,$0 0A			:is the digit zero?
		IFF(E,THEN)			:yes
		   LIS  R0,0			:count = 0
		ENDIF
		LR  R7,R0			:count 
		AIS R7,2			:count+2
		SLHLS  R13,1			:use Last_Character
		DO(COUNT,R7)			:decompress the data
		  LHL  R11,SAT.PT,R13,		:pointer for Last_Character
		  LB   R6,SAT.BS,R11,		: # of characters
		  DO(COUNT,R6)			:translate to Ascii
                    AIS  R11,1                  :increm.pointer
                    LB   R0,SAT.BS,R11,         :get char.
                    JAL  R4,WCI,,               :send char.to output buf
                    AIS  R8,1                   :increm.count.
		  ENDDO
                ENDDO
		L   R3,SAVLNK,,			:restore link register
                L   R7,SAVER7,,
		JR  R3				:return

: Action Routines

	SEG	2

ACTRTN	WS	0
	WC	ADATA		: handles regular data chrs
	WC	ARETRN		: return
	WC	ASPECL		: handles special chars code
	WC	ARETRN		: return
	WC	ADIGIT		: handles data decompression

:(MATS.P2)RCVMAG.S11
:	Copied from .S10	1/16/87
:	Added the routine RBSRCH
:	Took out the check for FRE from USRSCH

: (TIGERDEV)RCVMAG.S10
:   Copied by Byrne from (MATS.P2)RCVMAG.09P on 5-Aug-86
:   Call either SBUPRT or TGRPRT depending on printer type.
:


: This procedure finds the correct user's USER-BLOCK
: and RES BLOCK. Tells whether found the IA-TA
: and whether it's a printer IA-TA.
:    INPUTS - RES,IA TA.
:    OUTPUTS- RRETC(R0)=0, if found the user in R2UTAB.
:             PRINTR(R4)=1,if this IA-TA is for the printer.
:             USER-BLOCK(R2)- AUB 
:             RES-IA-TA(R3)-given RES-IA-TA
:             RES BLOCK(R5),if found 
:
:
        PROCS(USRSCH,$00D)
        CHAINS(USRSAV,$00D)
        DEBUGM(Entering USRSCH,DBGPRT,DALL,USRSAV,$00D)
:
:
        LH      R2,IA,,
        NHI     R2,$007F7F              : IA-TA from MAGDAT
        LH      R3,MAGNUM,RUBLK,        :RUBLK points to the MAGTAB
        SLL     R3,$A 16
        OR      R3,R2                   :RES-IA-TA in R3
        LIS     R4,0                    :PRINTR=0 initially
        CALL(BINSCH,USRSAV)         :search in R2UTAB
        LR      RRETC,RRETC
        IFF(E,THEN)                     :R0=0 if found
            LCS RRETC,1                 :initially bad
            L   R5,AUBRCH,R2,           :points to the RB chain
            DO(WHILE,N)                 :while next pointer do not =0
                LR   RRETC,RRETC
                IFF(E,THEN)
                  EXITDO                :if found - exit
                ENDIF
                L    R7,RBIATA,R5,      :RES-IA-TA (CRT)
                CLR  R7,R3              :compare with given RES-IA-TA
                IFF(N,THEN)             :it is not a crt
                  L     R7,RBPTTA,R5,   :PRINTER RES-IA-TA
                  CLR   R7,R3           :compare with given RES-IA-TA
                  IFF(E,THEN)           :it is a printer IA-TA
                    LIS R4,1            :set PRINTR pointer
                    LIS RRETC,0         
                  ORELSE                :it isn't a printer IA-TA
                    L   R5,RBNXT,R5,    :next pointer
                  ENDIF
                ORELSE
                  LIS   RRETC,0
                ENDIF                   :found a CRT RES-IA-TA
            ENDDO
            LR  RRETC,RRETC
            IFF(N,THEN)                 :didn't find in any RB
              LIS  R7,1
              AHM  R7,ERRUSS,,          :increment error count
            ENDIF
        ENDIF                           :didn't find RES-IA-TA in R2UTAB
        RETURN(R6)


: This procedure finds the Res block corresponding to the RES-IA-TA
: and tells whether it's a CRT or a printer.
:    INPUTS - RES,IA TA.
:             USER-BLOCK(R2)- AUB pointer
:             RES-IA-TA(R3)-given RES-IA-TA
:    OUTPUTS- RRETC(R0)=0, if found the Res Block
:             PRINTR(R4)=1,if this IA-TA is for the printer.
:
:
        PROCS(RBSRCH,$00D)
        CHAINS(RBSRSV,$00D)
        DEBUGM(Entering RBSRCH,DBGPRT,DALL,RBSRSV,$00D)
:
:
            LCS RRETC,1                 :initially bad
            L   R5,AUBRCH,R2,           :points to the RB chain
            DO(WHILE,N)                 :while next pointer do not =0
                L    R7,RBIATA,R5,      :RES-IA-TA (CRT)
                CLR  R7,R3              :compare with given RES-IA-TA
                IFF(N,THEN)             :it is not a crt
                  L     R7,RBPTTA,R5,   :PRINTER RES-IA-TA
                  CLR   R7,R3           :compare with given RES-IA-TA
                  IFF(E,THEN)           :it is a printer IA-TA
                    LIS R4,1            :set PRINTR pointer
                    LIS RRETC,0         
                  ORELSE                :it isn't a printer IA-TA
                    L   R5,RBNXT,R5,    :next pointer
                  ENDIF
                ORELSE
                  LIS   RRETC,0
                ENDIF                   :found a CRT RES-IA-TA
            ENDDO
            LR  RRETC,RRETC
            IFF(N,THEN)                 :didn't find in any RB
              LIS  R7,1
              AHM  R7,ERRUSS,,          :increment error count
            ENDIF

        RETURN(R6)


        PROCS(AXPRNT,$00D)
        CHAINS(AXPRSV,$00D)
:
: This routine disposes of printer data blocks belonging to a user
: who has a connection to the airline the block came from.  Data
: is either discarded, or passed on to the user.  If discarded, the
: block is acknowledged.  Otherwise, the data will be sent by calling
: SBUPRT or TGRPRT, which must acknowledge.
:
: Input:  R1 - AUB pointer
:         R2 - MAG port # on which the printer block arrived
:         R3 - Printer Res Block pointer
:         R4 - C1 2946 protocol character from printer message
:
:         IA and TA in MAGDAT are also needed.  These are accessed directly.
:
: Output: MAG input port buffer emptied.
:         Left over printer data placed in printer hold buffer
:         Ack message sent on MAG port.
:
        DEBUGM(Entering AXPRNT,DBGPRT,DALL,AXPRSV,$00D)

        LR      R5,R1           : Save AUB pointer
        LR      R6,R2           : Save MAG port #
        LR      R7,R3           : Save Printer Res Block pointer
        LR      R8,R4           : Save C1

        LR      R1,R6           : Move MAG port # to R1 for GCI
        SLLS    R1,2            : Convert port # to buffer index
        JAL     R4,GCI,,        : Get C2
        LR      R9,R0           : Save C2

        CALL(VALPRT,AXPRSV)     : Validate printer block
                                : Input
                                :   R5 = AUB pointer
                                :   R6 = MAG port #
                                :   R7 = Printer Res Block pointer
                                : Output
                                :   R4 = valid indicator

        LR      R4,R4           : Was printer block valid?
        IFF(N,THEN)             : Yes
          LR      R4,R6         : Maintain a MATS STATS counter
          SLLS    R4,2
          LHL     R4,BCT,R4,
          AIS     R4,7
          AM      R4,RBPRCC,R7,
          LH      R1,AUBPRT,R5,
          SLLS    R1,2
          AHI     R1,(NPORT*2+1)*2 : Now have printer hold buffer index
          LR      R0,R8         : Get C1
          JAL     R4,WCI,,      : Write in printer hold buffer

          LR      R0,R9         : Get C2
          JAL     R4,WCI,,      : Write in printer hold buffer

          LR      R2,R1         : Printer hold buffer index
          LR      R1,R5         : Get AUB pointer
          LHL     R4,AUBPTY,R1, : get printer type
          CHI     R4,PTY736     :
          IFF(E,THEN)           : if 736 printer type then
            CALL(SBUPRT,AXPRSV) : Initiate sending process for printer hld bfr
          ORELSE                : else not 736 printer type
            CHI     R4,PTYTGR   :
            IFF(E,THEN)         : if Flying Tigers printer type then
              CALL(TGRPRT,AXPRSV): do FT processing
            ENDIF               :
          ENDIF                 :

          LR      R8,R2         : Save printer hold buffer index
          SLLS    R6,2          : MAG port input buffer index
          LH      R4,BCT,R6,    : Any data left in MAG input buffer?
          IFF(N,THEN)           : Yes
            LH      R4,BCT,R8,  : Did SBUPRT send all the data in printer
                                : hold buffer?
            IFF(E,THEN)                  : Yes
               LR     R2,R6              : Send data in MAG input buffer
               LHL    R4,AUBPTY,R1,      : get printer type
               CHI    R4,PTY736          :
               IFF(E,THEN)               : if printer type is 736 then
                 CALL(SBUPRT,AXPRSV)     : send it
               ORELSE                    : else not 736
                 CHI    R4,PTYTGR        :
                 IFF(E,THEN)             : if Flying Tigers printer type then
                   CALL(TGRPRT,AXPRSV)   : send it
                 ENDIF                   :
               ENDIF                     :
             ENDIF                       :

            LH      R9,BCT,R6,  : Did SBUPRT empty the MAG input buffer
            IFF(N,THEN)         : No.  Move data to printer hold buffer
                DO(COUNT,R9)
                LR      R1,R6   : MAG input buffer index
                JAL     R4,GCI,,
                LR      R1,R8   : Printer Hold Buffer index
                JAL     R4,WCI,,
                ENDDO
              ENDIF             
            ENDIF
        ORELSE                  : Printer block not valid for printing
          LR      R1,R6         : MAG port #
          LB      R2,RES,,      : Res number from MAGDAT
          LB      R3,IA,,       : IA from MAGDAT
          LB      R4,TA,,       : TA from MAGDAT
          CALL(ACKPTR,AXPRSV)   : Acknowledge printer block
          ENDIF

        RETURN(R1)
:
: This routine sends Ack to the Res on Port for IA-TA
:
        PROCS(ACKPTR,$00D)
        CHAINS(ACKPSV,$00D)
:       Inputs:  -R1-MAG port#
:                 R2-RES # 
:                 R3-IA
:                 R4-TA
:       Outputs: -Ack message to the port for RES-IA-TA
:
        DEBUGM(Entering ACKPTR,DBGPRT,DALL,ACKPSV,$00D)
:
        LR      R5,R1                   :save  MAG PORT
        LR      R6,R2                   :save RES
        LR      R7,R3                   :save IA
        LR      R8,R4                   :save TA
        LB      R0,AKSOH,,              :SOH=$0 0DF
        SLLS    R1,2
        AIS     R1,2
        JAL     R4,WCI,,                :R1-MAG output-buffer-index
        LR      R0,R6
        OI      R0,$8 200               :send SOH
        JAL     R4,WCI,,                :sent RES#
        LB      R0,AKTXT,,
        JAL     R4,WCI,,                :sent text cmd
        CVTRES(R6,ACKPSV)
        LHI     R9,MAGLNG
        MHR     R6,R9                   :GET OFFSET INTO  MAGTAB
        LB      R0,MAGTAB+MAGSEQ,R6,    :get sequence #
        AIS     R0,1                    :increment by one
        CHI     R0,$A 256               :check for range error
        IFF(GE,THEN)                    :jump if OK
          LHI   R0,$A 128
        ENDIF 
        STB   R0,MAGTAB+MAGSEQ,R6,
        JAL     R4,WCI,,                :sent sequence #
        LR      R0,R7
        OI      R0,$8 200
        JAL     R4,WCI,,                :sent IA
        LR      R0,R8
        OI      R0,$8 200               :turn on high bit
        JAL     R4,WCI,,                :sent TA
        LHI     R0,EOMI
        OI      R0,$8 200               :turn on high bit
        JAL     R4,WCI,,                :sent EOMI
        LB      R0,AKETX,,
        JAL     R4,WCI,,                :sent EOT
        RETURN(R0)


        IF      METER                   : Check if metering data to printer

        PROCS(PRTTO,$00D)
        CHAINS(PRTTSV,$00D)             : Save area for PRTTO

:
: The speed at which printer data is accepted from the airline will be
: controlled by sending data to the user only as fast as the print data
: path, i.e., the lesser of printer speed and line speed.  This
: will be accomplished by calling SBUPRT or TGRPRT at the appropriate time
: if print data is present in the printer hold buffer.
:
: Where the full-scale design uses a yellow ball to determine
: the data has actually passed through, this method will assume the data
: arrives at the terminal according to the data rate.  This timeout
: routine will act as if a yellow ball were arriving at the appropriate
: time.

        AI      R1,$A2*RATE             : Reschedule to run again in 2 seconds
        LA      R0,PRTOST,,             : Address for timeout
        JAL     R5,TOPUT,,

        L       RUBLK,AUTACT,,          : Get pointer to first AUB

          DO(WHILE,N)                   : Repeat as long as there are AUBs
          LH      R2,AUBPRT,RUBLK,      : Get port #
          SLLS    R2,2                  : Calculate printer hold buffer index
          AHI     R2,(NPORT*2+1)*2
          LH      R3,BCT,R2,            : Any characters to be processed?
          IFF(N,THEN)                   : Yes
            LHL      R4,AUBPTY,RUBLK,   : get printer type
            CHI      R4,PTY736          :
            IFF(E,THEN)                 : if printer type is 736 then
              CALL(SBUPRT,PRTTSV)       : Input: RUBLK - AUB pointer
                                        :   R2 - printer hold buffer index
            ORELSE                      : else not 736
              CHI      R4,PTYTGR        :
              IFF(E,THEN)               : if Flying Tigers printer type then
                CALL(TGRPRT,PRTTSV)     : do FT processing
              ENDIF                     :
            ENDIF                       :
          ENDIF

          L       RUBLK,AUBNXT,RUBLK,   : Next AUB in chain
          ENDDO

        LIS     RRETC,0
        RETURN(R1)


: COMES HERE WHEN CALLED FROM TIMOUT

        CHAINS(PRTTS1,$00D)


PRTOST  CALL(PRTTO,PRTTS1)
        J       TORET,,                 : Return to timeout routine
        EI                              : Metering scheme


:This routine disposes of printer data blocks belonging to a user 
:handling a connection with MARSPLUS. At first it validates the 
:printer blocks and later it sends ,calling MRBPRT, the block.

:Input parameters:
:	
:	R5  {pointer to the AUB}
:	R6  {on which the printer block arrived}
:	R7  {pointer to the printer reservation block}
:
:The routine will leave the MAG port number emptied left over
:data placed in hold buffer

	PROCS(MRACPR,$00D)
	CHAINS(MRACSV,$00D)

        CALL(VALPRT,MRACSV)     : Validate printer block
                                : Input
                                :   R5 = AUB pointer
                                :   R6 = MAG port #
                                :   R7 = Printer Res Block pointer
                                : Output
                                :   R4 = valid indicator

        LR      R4,R4           : Was printer block valid?
        IFF(N,THEN)             : Yes
          LH      R2,AUBPRT,R5,
          SLLS    R2,2
          AHI     R2,(NPORT*2+1)*2 : Now have printer hold buffer index


          LR      R1,R5         : Get AUB pointer
          CALL(SBUPRT,MRACSV)   : Initiate sending process for printer
                                : hold buffer

          LR      R8,R2         : Save printer hold buffer index
          SLLS    R6,2          : MAG port input buffer index
          LH      R4,BCT,R6,    : Any data left in MAG input buffer?
          IFF(N,THEN)           : Yes
            LH      R4,BCT,R8,  : Did MRBPRT send all the data in printer
                                : hold buffer?
            IFF(E,THEN)         : Yes
               LR     R2,R6     : Send data in MAG input buffer
               CALL(SBUPRT,MRACSV)
               ENDIF

            LH      R9,BCT,R6,  : Did MRBPRT empty the MAG input buffer
            IFF(N,THEN)         : No.  Move data to printer hold buffer
                DO(COUNT,R9)
                LR      R1,R6   : MAG input buffer index
                JAL     R4,GCI,,
                LR      R1,R8   : Printer Hold Buffer index
                JAL     R4,WCI,,
                ENDDO
              ENDIF             
            ENDIF
          ENDIF

        RETURN(R1)

: (MATS.P2)DBGCMD.03S
:    Copied by Gimnicher from (MATS.P2)DBGCMD.02B.  8/19/81
:    Changed bit setting in response to 'DEBUG ON,ANNOUNCE' entry from
:    1 to ANNBIT (set in P2PARM).

:  DBGCMD.02B COPIED FROM (MATS.P2)DBGCMD.01K  1/27/81
:       ADDED CODE FOR REMOVAL OF 8A 8D FROM ERROR MESSAGES
:
: DBGCMD.01K.  Copied from (MATS.PRD)DBGCMD.NAD.  10/15/80.

        RA      $00
        LO      MAIN
:       DEBUG COMMAND PROCESSOR
:       THIS ROUTINE GETS CONTROL WHEN A DEBUG COMMAND IS DETECTED
:
PROC(DBGCMD)
CHAIN(DBGSAV)
        LA      R12,DEBUG,,     :GET ADDRESS OF THE DEBUG STRINGS
        LIS     R11,NDEBUG      :GET NUMBER OF USERS WHO CAN BE DEBUGGING
        SR      R9,R9           :ZERO EMPTY ADDRESS
        SR      R10,R10         :R10 IS ZERO FOR COMPARISON
DBGSCH  C       RUBLK,0,R12     :COMPARE TO THIS USER
        JE      GOTDB           :JUMP IF EQUAL
        C       R10,0,R12       :COMPARE ADDRESS POINTER TO ZERO
        JN      DECCNT          :IF NOT EQUAL SKIP
        LR      R9,R12          :SAVE ADDRESS OF AN EMPTY ENTRY
DECCNT  LA      R12,DEBLNG,R12  :ADVANCE POINTER
        SIS     R11,1           :DECREMENT COUNTER
        JN      DBGSCH          :JUMP IF MORE ENTRIES
:
        CR      R9,R10          :DID  WE FIND AN EMPTY DEBUG ENTRY???
        JN      FNDB            :YES.....YEAH!!!
        LI       R2,MAXDBG       :TOO MANY DEBUG USERS MSG
        CALL(SENDIT,DBGSAV)
        CALL(NEWLIN,DBGSAV)
        SR      RRETC,RRETC     :SET RETURN CODE
        INVOKE(RETCMD)
FNDB    LR      R12,R9          :LOAD R12 WITH LAST EMPTY ENTRY..
        LA      R2,4,R12        :SKIP ADDRESS
        LHI     R3,DEBLNG-4     :NUMBER OF BYTES TO ZERO
        LIS     R4,0            :STORE ZEROES
        CALL(CLEAR,DBGSAV)
        ST      RUBLK,0,R12       :STORE AUB POINTER
:
GOTDB   LHI     R0,$0 00AC      :STOP AT A COMMA
        LIS     R2,5            :LONGEST STRING IS 'CARL,'
        LI      R3,DBTMP        :ADDRESS OF BUFFER AREA
:
        CALL(READ,DBGSAV)
:
        CHI     R2,4            :DID WE READ TOO MANY CHARS???
        JG      KEYNG           :KEYWORD NO GOOD
	CHI	R2,0
	JLE	KEYNG
:
        LHI     R6,$0 00CF      :LOAD A 'O'
        CLB     R6,0,R3         :IS FIRST CHARACTER AN 'O'
        JN      DBGSUB           :NO... GO CHECK FOR 'LUD'
:
        LHI     R6,$0 00CE      :CHECK FOR 'ON'
        CLB     R6,1,R3         :NOT 'ON' .. CHECK FOR 'OFF'
        JN      CKOFF           :GO TOOFF TEST
        SIS     R2,2            :SUBTRACT 2 FROM LENGTH RETURNED
        JN      DBGSUB           :IF MORE THAN TWO CHARS NOT 'ON'
:
        LR      R0,R0           :SET COND CODE
        JGE     NTSTAL          :JUMP IF NOT SETTING ALL BITS ON
        LA       R2,4,R12        :SKIP ADDRESS AREA
        LHI     R3,DEBLNG-4     :NUMBER OF BITS TO SET ON
        LCS     R4,1            :ALL BITS ON
        CALL(CLEAR,DBGSAV)
:
	LI	R13,DBGSET
	J	INVSGD
NTSTAL  LIS     R5,1            :FLAG TO INDICATE THAT ON
        J       DISANN          :GO TO 'DISPLAY' AND 'ANNOUNCE' CODE
:
CKOFF   LHI     R6,$0 00C6      :LOAD AN 'F'
        CLB     R6,1,R3         :COMPARE TO SECOND CHARACTER
        JN      DBGSUB           :IF NOT EQUAL THEN KEYWORD NG
        CLB     R6,2,R3         :COMPARE TO THIRD CHARACTER
        JN      DBGSUB           :IF NOT THEN KEYWORD NG
        SIS     R2,3            :SUBTRAC 3 FROM RETURNED LENGTH
        JN      DBGSUB           :EXTRA CHARACTERS....NG
        LR      R0,R0           :SET COND CODE
        JGE     NTRSAL          :JUMP IF NOT RESETTING ALL
:
        LR      R2,R12          :WANT TO CLEAR ADDRESS FIELD TOO
        LHI     R3,DEBLNG               :LENGTH OF DATA TO CLEAR
        LHI     R4,0            :WANT TO CLEAR
        CALL(CLEAR,DBGSAV)
	LI	R13,DBGOFF
	J	INVSGD
:
NTRSAL  SR      R5,R5           :SET FLAG TO TURN OFF
:
DISANN  LHI     R0,$0 00AC      :LOAD A COMMA
        LIS     R2,9            :NINE CHRS INCLUDEING COMMA
        LI      R3,DBTMP        :ADDRESS OF BUFFER
:
        CALL(READ,DBGSAV)
        CHI     R2,8            :CHECK NUMBER OF CHARS READ
        JG      KEYNG           :TOO MANY CHARS READ
        CHI     R2,0            :DID WE READ ANY CHARATERS??
        JG      GDREAD          :YES, GO SEE WHAT IT WAS
:
CKBIT   SR      R9,R9   :ZERO R9
        LA      R10,4,R12       :SKIP TO DEBUG BITS
        LHI     R11,DEBLNG-4    :NUMBER OF BYTES TO BE CHECKED
CKLOP   CLB     R9,0,R10        :CHECK A BYTE FOR ZERO
        JN      INVSGD          :IF A BIT IS SET ... GO SEG GLOBAL DEBUG
        LA      R10,1,R10       :BUMP POINTER
        SIS     R11,1           :DECREMENT COUNTER
        JN      CKLOP   :MORE CHARS
        ST      R9,0,R12          :NO BITS ON ZERO AUB POINTER
	LI	R13,DBGOFF
INVSGD	CALL(GBLDBG,DBGSAV)
        LR      R2,R13          :LOAD SAVED ADDRESS OF MSG
	CALL(SENDIT,DBGSAV)
        CALL(NEWLIN,DBGSAV)
	INVOKE(RETCMD)
:
GDREAD  LHI     R6,$0 00C4      :LOAD A 'D'
        CLB     R6,0,R3         :COMPARE TO 1ST CHAR
        JN      CHKANN          :NOT DISPLAY....CHK ANNOUNCE
:
        LHI     R6,$0 00C9      :LOAD AN 'I'
        CLB     R6,1,R3         :COMPARE TO SECOND CHRACTER
        JN      KEYNG           :JUMP IF NO GOOD
:
        LHI     R6,$0 00D3      :LOAD AN 'S'
        CLB     R6,2,R3         :CHECK FOR 'DIS'
        JN      KEYNG           :NO DICE
:
        LHI     R6,$0 00D0      :LOAD A 'P'
        CLB     R6,3,R3         :CHECK FOR 'DISP'
        JN      KEYNG           :NO DICE
:
        LHI     R6,$0 00CC      :LOAD A 'L'
        CLB     R6,4,R3         :CHECK FOR 'DISPL'
        JN      KEYNG           :IF NOT ......
:       
        LHI     R6,$0 00C1      :LOAD A 'A'
        CLB     R6,5,R3         :CHECK FOR 'DISPLA'
        JN      KEYNG           :OOPS
:
        LHI     R6,$0 00D9      :LOAD A 'Y'
        CLB     R6,6,R3         :CHECK FOR 'DISPLAY'
        JN      KEYNG           :SO CLOSE AND YET SO FAR
:
        SIS     R2,7            :CHECK FOR NO MORE CHRS
        JN      KEYNG           :STRAY CHARACTERS FOUND
:
        SR      R9,R9           :NEED TO ALTER 1ST BIT
        LR      R5,R5           :SET CONT CODE
        JN      SETDIS          :SET BITON
        RBT     R9,4,R12        :RESET BIT
        LA      R13,DBGRST,,    :LOAD ADDR OF MESSAGE
        J       DISANN          :GO GET ANOTHER PARAMETER
SETDIS  SBT     R9,4,R12        :SET DISPLAY BIT
        LA      R13,DBGSET,,    :LOAD ADDRESS OF MESSAGE
        J       DISANN
:
CHKANN  LHI     R6,$0 00C1      :LOAD AN 'A'
        CLB     R6,0,R3         :CHECK FOR 'A'
        JN      KEYNG           :JUMP IF NOT
:
        LHI     R6,$0 00CE      :LOAD AN 'N'
        CLB     R6,1,R3         :CHECK FOR 'AN'
        JN      KEYNG           :JUMP IF NO
:
        CLB     R6,2,R3         :CHECK FOR 'ANN'
        JN      KEYNG           :JUMP IF NOT
:
        LHI     R6,$0 00CF      :LOAD AN 'O'
        CLB     R6,3,R3         :CHECK FOR ANNO
        JN      KEYNG           :JUMP IF NOT
:
        LHI     R6,$0 00D5      :LOAD A D
        CLB     R6,4,R3         :CHECK FOR ANNOU
        JN      KEYNG
:
        LHI     R6,$0 00CE      :LOAD A N
        CLB     R6,5,R3         :CHECK FOR ANNOUN
:
        LHI     R6,$0 00C3      :LOAD A C
        CLB     R6,6,R3         :LOOK FOR ANNOUNC
        JN      KEYNG           :JUMP TO BAC KEYWORD
:
        LHI     R6,$0 00C5      :LOAD AN E
        CLB     R6,7,R3         :CHECK FOR ANNOUNCE
        JN      KEYNG           :JUMP IF KEY NO GOOD
:
        SIS     R2,8           :SUBTRACT 8 FROM LENGTH OF STRING READ
        JN      KEYNG           :STRAY CHARACTERS FOLLOW
        LHI     R9,ANNBIT       :Change bit indicated by ANNBIT
        LR      R5,R5           :SET COND CODE
        JN      SETANN          :JUMP TO SET ON
        RBT     R9,4,R12        :RESET THE ANNOUNCE BIT
        LA      R13,DBGRST,,    :LOAD MSG ADDRESS
        J       DISANN
SETANN  SBT     R9,4,R12           :SET BIT ON
        LA      R13,DBGSET,,
        J       DISANN
DBGSUB   LHI     R6,$0 00CC      :LOAD AN 'L'
        CLB     R6,0,R3         :CHECK FOR 'L'
        JN      CKCARL          :IF NOT CHECK FOR CARL
:
        LHI     R6,$0 00D5      :LOAD A 'U'
	CLB	R6,1,R3
        JN      BADSUB           :JUMP IF NOT
:
        LHI     R6,$0 00C4      :LOAD A D
        CLB     R6,2,R3         :CHECK FOR 'LUD'
        JN      BADSUB           :JUMP IF NOT
:
        SIS     R2,3            :CHECK FOR CORRECT LENGTH
        JN      BADSUB           :STRAY CHARACTERS
        LA      R10,5,R12       :LOAD ADDRE OFF LUD BYTE
:
        J       RDBIT
:
:
CKCARL  LHI     R6,$0 00C3         :LOAD A C
        CLB     R6,0,R3         :CHECK FOR 'C'
        JN      BADSUB           :JUMP IF NOT
:
        LHI     R6,$0 00C1      :LOAD A A
        CLB     R6,1,R3         :CHECK FOR 'CA'
        JN      BADSUB
:
        LHI     R6,$000D2       :LOAD AN R
        CLB     R6,2,R3         :CHECK FOR CAR
        JN      BADSUB
:
        LHI     R6,$000CC       :LOAD AN L
        CLB     R6,3,R3            :CHECK FOR CARL
        JN      BADSUB
        LA      R10,6,R12       :LOAD ADDERSS OF CARL BYTE
:
RDBIT   L       R0,$0 00A0      :LOAD A BLANK
        LHI     R2,9            :MAX NUMBER OF CHARS TO READ
        LI      R3,DBTMP        :BUFFER AREA
        CALL(READ,DBGSAV)
:
        CHI     R2,8            :CHECK FOR TOO MANY CHARS
	JG	BADBIT
        CHI     R2,0            :CHECK FOR NOT BIT STRING
        JLE     BADBIT
:
CHKBIT	LHI	R7,$000B0	:LOAD A ZERO
        LHI     R8,$0 00B1      :LOAD A ONE
        SR      R9,R9           :REGISTER OT BUILD BYTE IN
:
BITLOP  CLB     R7,0,R3         :CHECK FOR A '0'
        JE      SHFT            :IF YES JUST SHIMFT
        CLB     R8,0,R3         :CHECK FOR A '1'
        JN      BADBIT          :IF NOT A ONE THEN ERRROR
        AI      R9,$0 80        :ADD THE HIGH ORDER BIT
SHFT    AIS     R3,1            :POINT TO NEXT BYTE
        SIS     R2,1            :DECREMENT COUTNER
        JE      STBIT           :IF DONT GO STORE IT
        SRLS    R9,1            :SHIFT RIGHT ONE BIT
        J       BITLOP
:
STBIT   STB     R9,0,R10                :STORE SUBSYS BYTE
        LA      R13,SUBSET,,
        J       CKBIT
KEYNG   LI       R2,BADPRM       :ADDRESS OF INVALID PARM MESS
        CALL(SENDIT,DBGSAV)
        CALL(NEWLIN,DBGSAV)
        SR      RRETC,RRETC
        INVOKE(RETCMD)
:
BADSUB  LI       R2,INVSUB       :LOAD INVALID SUBROUTINE MESS
        CALL(SENDIT,DBGSAV)
        CALL(NEWLIN,DBGSAV)
        SR      RRETC,RRETC
        INVOKE(RETCMD)
:
BADBIT  LI       R2,INVBIT       :LOAD ADDR OF INVALID BIT MESS
        CALL(SENDIT,DBGSAV)
        CALL(NEWLIN,DBGSAV)
        SR      RRETC,RRETC
        INVOKE(RETCMD)

:  HSEG0.01K.  Copied from (MATS.DEV)HSEG0.CSA.  10/15/80.

	RA	$00A	:RADIX TO DECIMAL
 
:	HIGH SEG 0 ALLOCATIONS
:		THIS FILE SHOULD BE ASSEMBLED JUST BEFORE FINISH.LIB
:
	SEG	0

:
:	RES IATA TO PORT TABLE USED BY THE MAG CMD PROCESSORS TO
:	SEE WHICH PORT (I.E. USER) IS USING A SPECIFIC RES-IA-TA
:
R2UTAB	BS	NR2U*R2ULNG
	IF	DEBSW
:
:	MAG SPECIAL MSG COUNTERS
:
NMAGDN	HC	0	:DOWNS
NMAGUP	HC	0	:UPS
NMAGRS	HC	0	:RESETS
NMAGBP	HC	0	:BACKPRESSURES
NMAGRB	HC	0	:BACPRESSURE RELEASES
NMAGCE	HC	0	:COMMUNICATION ERRORS
NMAGTP	HC	0	:TEXT WITH A PURPLE BALL
:
: SPECIAL EVENT COUNTERS
:
NINVAC	HC	0	:NUM OF INVALID ACTIVATIONS
:
	EI


: (TIGERDEV)PATCH.S02
:  Copied by Byrne from (MATS.P2)PATCH.01K on 6-Aug-86
:  Renamed PATCH to PCHCOD to eliminate conflict with PATCH.LIB macro.

:  PATCH.01K.  Copied from (MATS.PRD)PATCH.NAD.  10/15/80.

:
: this file just contains some segment 1 (xecute) area in which to
: patch, if need to do so arise
:
	SEG	1
	GL	PCHCOD
	ws	0
PCHCOD	AI	R1,RATE*$A5	:CALL ME BACK IN 5 SECONDS
	JAL	R5,TOPUT,,
: LOOP THRU THE P2U TABLE MAKING SURE THAT THER USER BLOCK
: POINTED TO BY THE TABLE HAS A PORT NUMBER EQUAL TO
: (INDEX INTO P2UTAB/4) IF P2UTAB ENTRY IS >0
	LHI	R7,NPORT-1	:NUMBER OF LOOPS
LOOP	LR	R8,R7	:GET THE PORT NUMBER
	SLHLS	R8,2	:MULTIPLY IT BY 4
	L	R6,P2U,R8
	JLEFS	NXTP2U	:JUMP IF NOT AN ADDRESS
	CH	R7,AUBPRT,R6	:DOES THE PORT NUMBER EQUAL THE EXPECTED NUMBER
	JNFS	TRAPED	:JUMP IF NOT
NXTP2U	SIS	R7,1
	JGEBS	LOOP
	J	TORET,,
TRAPED	LH	R5,MAGPRT,R6	:SAVE THE PORT NUMBER IN THE BLOCK
	LA	R9,ORING,,
	LA	R10,SAVORG,,
	LHI	R11,ORSIZE+3
LOOP1	LB	R12,0,R11,R9
	STB	R12,0,R11,R10
	SIS	R11,1
	JGEBS	LOOP1
	LA	R9,IRING,,
	LA	R10,SAVIRG,,
	LHI	R11,IRSIZE+3
LOOP2	LB	R12,0,R11,R9
	STB	R12,0,R11,R10
	SIS	R11,1
	JGEBS	LOOP2
	JAL	R10,CRASH,,
	BC	0,0,RLINK,-1
:
	SEG	0
SAVORG	BS	ORSIZE+4
SAVIRG	BS	IRSIZE+4
	SEG	1

: (MATS.P2)BLDHDL.02R
:    Copied by Cheung from (MATS.P2) on 10/06/82.
:    Corrected port# calculation AND CALL DIRZAP TO ZAP THE CIRCUIT.

: (MATS.P2)BLDHDL.01T
:    Created by Byrne on 9/24/82.
:    BLDHDL handles B4, B5, B6 messages used in conjunction
:    with the normal stats circuit which replaced the aux. stat circuit.

:  Input:
:       R1 contains port# * 4.

:  Procedure - Build Circuit Handler (BLDHDL)
:
:              Called as an activation routine for
:              B4 (normal logon status),
:              B5 (logon failure), and
:              B6 (successful logon)
:              messages for MATS Stats circuits.


        PROCS(BLDHDL,A.CUCD)
        CHAINS(HDLSAV,A.CUCD)

        GL      STAHND



        LR      R6,R1                     :save (port)*4  in R6
        L       R5,P2U,R1,                :get pointer to CCB
        L       R8,OBCHSP,R5,             :(current) STATAB address
        SRHLS   R1,2                      :R1 is RPORT number.
        CLHI    R0,$00B4                  :if message type is logon status
        IFF(E)                            : then send password
                                          :put port*4 in R1
          LA      R2,MSGADR,,             :put characters from bufferlets here
          LIS     R3,3                    :number of characters to get
          LR      R1,R6                     :rport*4.
          CALL(GTCHRS,HDLSAV)             :get chars (msg type + status byte)
          SRHLS   R1,2                     :RPORT number.
          CLHI    R0,3                    :check for short B4 message
          IFF(E)                          :if R0 = 3  then msg is ok
            LB      R0,LOGSTA,,           :get logon status
            CLHI    R0,0                  :if there is a good status (0)
            IFF(E)                        : then send password
              LA      R9,HSTPWD,R8,       :address of password string
              LB      R7,0,R9,            :length of password string
              IFF(N)                      :if length is not zero  then ...
                LB      R7,0,R9,          :length
                DO(WHILE,G)
                  LIS     R0,4            :PASSWORD LOOP
                                          :R0 is length of B3 message, R1=RPORT
                  LHI     R2,$00B3        :msg type = single char logon msg
                  JAL     R4,SLOR,,       :first three characters
                  AIS     R9,1            :next password character to be sent
                  LB      R0,0,R9,        :get character itself
                  JAL     R4,PUTCH,,      :put it in with rest of msg
                  JAL     R4,ELOR,,       :done with this character
                  SIS     R7,1            :next character
                ENDDO

                LIS     R0,4              :SEND A SEMI-COLON
                                          :R0 is length of B3 message, R1=RPORT
                LHI     R2,$00B3          :msg type = single char logon msg
                JAL     R4,SLOR,,         :first three characters
                LHI     R0,$003B          : 3B is a semi-colon
                JAL     R4,PUTCH,,        :send it
                JAL     R4,ELOR,,         :

              ENDIF


            ORELSE
              CALL(STAZAP,HDLSAV)       :bad status in B4 msg.

            ENDIF

          ORELSE           :short B4 msg.

            CALL(STAZAP,HDLSAV)        :set receiver status to down and zap

          ENDIF


        ORELSE              :not a B4 msg

            CLHI    R0,$00B5             :if message type = B5
            IFF(E)                       : then process logon failure msg

              CALL(STAZAP,HDLSAV)        :set receiver status to down and zap

            ORELSE

              CLHI    R0,$00B6           :if message type = B6
              IFF(E)                     : then process successful logon msg

                LR      R1,R5             :CCB pointer

                LA      R2,STAHND,,      : STAHND is activation routine
                CALL(SETJMP,HDLSAV)      :set new activation rtn for port
                LIS     R3,0             :set count of characters on this
                ST      R3,MSCSTC,R1,    : port to zero

                LH      R3,HOSTS,,       :get host #  for current MATS
                LIS     R4,4             : # of bytes needed for host #
                LA      R5,RSMHST,,      : get address to put host number
                CALL(BINDEC,HDLSAV)      :into

                L       R3,GMT,,         :put time in receiver startup msg
                LIS     R4,$A12          :
                LA      R5,RSMDAT,,      :
                CALL(DANTIM,HDLSAV)      :

                LI      R0,RSMLNG        :get receiver startup msg length
                L       R2,RSMSGP,,      :fet address of rec startup msg
                CALL(SENDMS,HDLSAV)      :send rec startup msg to port
                LR      R9,R0            :get length of message
                LR      R10,R2           :get address of message
                TRPORT(TRSTTO,HDLSAV)    :trace it

                LI      R0,MUPLNG        :get length of startup record
                LA      R2,MUPREC,,      :get addr of MATS startup record
                CALL(SENDMS,HDLSAV)      :send startup message to receiver
                LR      R9,R0            :get length of message
                LR      R10,R2           :get address of message
                TRPORT(TRSTTO,HDLSAV)    :trace it

                LI      R4,CSTWRI        :set CCB status to wait receiver
                STH     R4,CCBSTA,R1,    :response (CSTWRI)
                L       R4,FASTC,,       :set CCB status, change time
                ST      R4,CCBTIM,R1,    : current time
                CALL(SQRSET,HDLSAV)      :reset send pointer to empty

                LA      R4,RCVBRK,,      :set up receiver's break table
                LR      R1,R6             :get
                ST      R4,BREAK,R1,     :

              ORELSE

                CALL(STAZAP,HDLSAV)      :set receiver status to down and zap

              ENDIF

            ENDIF


        ENDIF

        JAL     R4,EMPTY,,              :empty the ports input bufferlets


        LIS     R0,0                    :Set activation timeout
        RETURN(R1)




:
:
:   STAZAP
:
:          Routine to select another receiver and
:          zap the circuit.
:
:          INPUT -  R5 is CCB pointer.
:                   R1 is relative port number.
:

        PROCS(STAZAP,A.CUCD)
        CHAINS(STZPSV,A.CUCD)


        CALL(DIRZAP,STZPSV)             :zap the circuit.
        LR      R1,R5                    :put CCB pointer into R1
        CALL(INITPT,STZPSV)              :initialize the port (zap it)
        CALL(SNHSBC,STZPSV)              :select another receiver

        RETURN(R1)


RCVBRK  HC      $024,0,0            : This is the CR LF break table for
        HC      0,0,0               : the receiver
        HC      $00,0,24
        HC      0,0,0
        HC      0,0,0
        HC      0



        SEG     0

MSGADR  BS      2              :space for putting msg gotten by GTCHRS
LOGSTA  BS      1              : <0> <message type> <status> ... from input
                               : (Note: FRONT.LIB does not do its normal
                               :  escaping of zeroes within ISIS messages)

: (MATS.P2)GPSNDL.11S
:    Copied by Gimnicher from (MATS.P2)GPSNDL.11R.  10/25/82
:    Added break array for 9E, 9F, B4, B5, and B6.

: (MATS.P2)GPSNDL.10R
:    Copied by Cheung from (MATS.P2)GPSNDL.10T on 10/06/82.
:    Restored MSCTAB pointer before call SETJMP for BLDHDL.

: (MATS.P2)GPSNDL.10T
:    Copied by Byrne from (MATS.P2)GPSNDL.09T   9/24/82.
:    Changed so that MATS expects a B2 message from a normal stats circuit
:    request (07) instead of an aux. circuit request (08).

: (MATS.P2)GPSNDL.09T
:    COPIED BY BYRNE FROM (MATS.P2)GPSNDL.08S.  11/25/81.
:    ADDS CODE FOR TRACING "RECEIVER" MESSAGES. ALSO PLACES
:    "RECEIVER" IN USERNAME FIELD OF MSCTAB.


: (MATS.P2)GPSNDL.08S
:    Copied by Gimnicher from (MATS.P2)GPSNDL.07F.  8/28/81
:    Fixed bad save area name on call to BINDEC for HOSTS.


: (MATS.P2)GPSNDL.07F
:    Copied by Bonnell from (MATS.P2)GPSNDL.06W    8/27/81
:    Changed SQRSET code to reflect changes in pseudo-code (see GPSNDL.P03).

: (MATS.P2)GPSNDL.06W Fixed up receiver startup message on 8/27/81
:
: (MATS.P2)GPSNDL.05W Corrected status store problem on 8/26/81
:
: (MATS.P2)GPSNDL.04W FIXED WRONG ACTIVATION SETUP ON 8/25/81
:
: (MATS.P2)GPSNDL.03W Fixed R2U storing problem on 8/25/81
:
: (MATS.P2)GPSNDL.02W Fixed default decimal mode problem on 8/25/81
:
: (MATS.P2)GPSNDL.01W
:    Copied from (MATS.P2)GPSNDL.00W by John Whitney on 8/22/81
:    Added sending of mats startup record and corrected two call bugs
:
:
:   Procedure:  Good pseudo needle (GPSNDL)
:
:   Input:
:
:       Local key table (global)
:       Local key count (global)
:       Negative port number (Passed in R1)
:       Port number times four (Passed in R6)
:
:   Output:
:
:       Time out value (Passed in R0)
:
:
:***************************************************************************
:
:
: Normal message break array for FRONT.LIB

        SEG     A.CUCD

NMLBRK  HC      0,0,0                   :00
        HC      0,0,0                   :30
        HC      0,0,0                   :60
        HC      3,0,$00E00              :break on 9E (detach), 9F (zapper)
                                        :B4 (logon status), B5 (logon failure),
                                        :B6 (good logon)
        HC      0,0,0                   :C0
        HC      0                       :F0

        PROCS(GPSNDL,A.CUCD)
        CHAINS(GPSNSV,A.CUCD)



        DEBUGM(Entering GPSNDL,DBGSTA,DALL,GPSNSV,A.CUCD)


        LR      R4,R1                   : Save negative port # in R4

        LR      R1,R6                   : Put port * 4 in Reg 1 for GTCHRS call
        LA      R2,MSGTYP,,             : Want character put in MSGTYP var
        LIS     R3,2                    : Want only one character
        CALL(GTCHRS,GPSNSV)             : Try and get message type character
        LA      R2,DUMADR,,             : Want next character put in DUMADR
        LIS     R3,1                    : Want one character to throw away
        CALL(GTCHRS,GPSNSV)             : Try and get key character
        LA      R2,LOCLKY,,             : Now want the local key
        LIS     R3,2                    : It should be two characters long
        CALL(GTCHRS,GPSNSV)             : Try and get 2 char local key
        CLHI    R0,2                    : If unable to get two character local
        IFF(N)                          : key then ...
        

          LIS     R3,1                  : Increment count of short pseudo
          AHM     R3,ERLPSN,,           : needle messages
          LR      R1,R4                 : Put neg port # in R1 for zap port call
          LA      R2,ABLANK,,           : Set up blank zap message
          CALL(ZAPPRT,GPSNSV)           : Zap circuit

        ORELSE                          : Able to get local key ...

          LHL     R3,LOCLKY,,           : Get local key for search
          CALL(SRCHLK,GPSNSV)           : Search local key table for local key
          CLHI    R0,FALSE              : If local key not found in local
          IFF(E)                        : key table then ...


            LIS     R3,1                : Increment count of local keys not
            AHM     R3,ERLKIV,,         : found in local key table
            LR      R1,R4               : Put neg port # in R1 for zap port call
            LA      R2,ABLANK,,         : Set up blank zap message
            CALL(ZAPPRT,GPSNSV)         : Zap circuit

          ORELSE                        : Local key found ...

            L       R5,LKYPTR,R2,       : Get pointer to CCB
            ST      R5,P2U,R6,          : Place CCB pointer in port 2 user tab
            CALL(DELKEY,GPSNSV)         : Delete the local key from table
            LR      R3,R6               : Compute port number by taking port
            SRHLS   R3,2                : * 4 and dividing by 4.  
            STH     R3,CCBPRT,R5,       : Save port number in CCB
            LB      R3,CCBTYP,R5,       : Get type of CCB
            CLHI    R3,MSCTYP           : If CCB type is mats stats circuit
            IFF(E)                      : then ...
  
              LIS     R0,0
              LA      R1,CCBUNM,R5      : INTO CCB
              LI      R2,LTRCVR         : LENGTH
              LA      R3,RCVRMG,,       : PUT "RECEIVER" AS USERNAME
              MVS(R3,R1,R2,R0)
:
              LA      R1,CCBAOR,R5,
              LIS     R3,2
              SPAC(R1,R3,R2)

              LR      R1,R5             : Put CCB pointer in R1 for SETJMP call
              TRPORT(ULOGON,GPSNSV)     : TRACE MESSAGE FOR PSEUDO NEEDLE

              L       R8,OBCHSP,R5,     :STHTAB address (current)
              LA      R9,HSTUNM,R8,     :address of username string
              LR      R1,R6             :
              SRHLS   R1,2              :RPORT in R1
              LB      R7,0,R9           :length of username
              DO(WHILE,G)
                LIS     R0,4            :length of a B3 message, R1 is RPORT
                LHI     R2,$00B3        :msg type = single char logon msg
                JAL     R4,SLOR,,       :first three bytes
                AIS     R9,1            :Next username character to be sent
                LB      R0,0,R9         :get character itself
                JAL     R4,PUTCH,,      :put it in with rest of B3 msg
                JAL     R4,ELOR,,       :done with this character
                SIS     R7,1            :next character
              ENDDO

              LIS     R0,0              :
              CLB     R0,HSTNUM,R8,     :if host# is defined
              IFF(N)                    : then send host# out

                LIS     R0,4            :send colon host# and semicolon
                                        :RPORT in R1
                LHI     R2,$00B3        :msg type = single char logon msg
                JAL     R4,SLOR,,       :first three characters
                LHI     R0,$003A        : 3A is a colon
                JAL     R4,PUTCH,,      :send a colon
                JAL     R4,ELOR,,       :

                LA      R9,HSTNUM,R8,   :address of host number string
                LB      R7,0,R9         :length of host number string
                DO(WHILE,G)
                  LIS     R0,4          :length of B3 message
                                        :RPORT in R1
                  LHI     R2,$00B3      :msg type = single char logon msg
                  JAL     R4,SLOR,,     :first three bytes
                  AIS     R9,1          :next host# character to be sent
                  LB      R0,0,R9       :get character itself
                  JAL     R4,PUTCH,,    :put it in with rest of B3 message
                  JAL     R4,ELOR,,     :done with this character
                  SIS     R7,1          :next character
                ENDDO

              ENDIF

                LIS     R0,4            :send the semi-colon
                                        :R0 is length of B3 message, R1 is RPORT
                LHI     R2,$00B3        :msg type = single char logon msg
                JAL     R4,SLOR,,       :first three characters
                LHI     R0,$003B        : 3B is a semi-colon
                JAL     R4,PUTCH,,      :send a semi-colon
                JAL     R4,ELOR,,       :

                LR      R1,R5           :put MSCTAB pointer for SETJMP call.
                LA      R2,BLDHDL,,     :set BLDHDL as new activation routine
                CALL(SETJMP,GPSNSV)     :for port

                LR      R2,R0           :SETJMP returns 4*port number in R0
                LA      R0,NMLBRK,,     :message break array for normal ckt
                ST      R0,MBREAK,R2,

                LI      R2,CSTLGI       :set CCB status to logging in
                STH     R2,CCBSTA,R5


  
            ORELSE                      : Other type of circuit ...

              LA       R1,MSCTAB,,
              TRPORT(UDISC,GPSNSV)      : TRACE ZAP

              LIS      R3,1             : Increment count of unexpected
              AHM      R3,EUXCTS,,      : circuit types
              LR       R1,R4            : Put neg port # in R1 for zap port call
              LA       R2,ABLANK,,      : Set up blank zap message
              CALL(ZAPPRT,GPSNSV)       : Zap circuit

            ENDIF                       : 

          ENDIF                         : 

        ENDIF                           : 
      
        LR      R1,R6                   : Get port * 4 in R1 for EMPTY call
        JAL     R4,EMPTY,,              : Empty the ports input bufferlets
        
        LIS     R0,0                    :Set activation time out value

        RETURN(R1)                      : Return restoring from R1


        SEG     0                       : Local variables

RCVRMG  AC      !RECEIVER    !
LTRCVR  EQ      .-RCVRMG

        WS      0

MSGTYP  HS      1
LOCLKY  HS      1                       : Local key

:
:   Procedure:  Stats queue reset (SQRSET)
:
:
:       Routine to reset the stats queue send pointer to the stats queue
:       empty pointer.
:
:   Input:
:
:       SQFPOS,SQEPOS - Stats queue pointers
:       STQSIZ - size of stats queue
:       STAQUE - Stats queue
:
:   Output:
:
:       SQSPOS,SQEPOS - Stats queue pointers reset
:       SQNCNT,SQOCNT - Updated stats queue counts
:
:
:***************************************************************************
:
:
        PROCS(SQRSET,A.CUCD)
        CHAINS(SQRSSV,A.CUCD)


          L       R1,SQEPOS,,             : Put stats queue empty pointer in R1
          L       R2,SQFPOS,,             : Put stats queue fill pointer in R2

          LR      R3,R2                 : Get fill pointer
          SR      R3,R1                 : Subtract empty pointer from it
          IFF(L)                        : If difference is negative then add
            AH      R3,STQSIZ,,         : size to correct for wraparound.
          ENDIF                         : 

          LB      R4,STAQUE,R1,         : Get next character in queue
SQRLB1    LR      R3,R3                 : Test unsent character count
          JLE     SQRLB2                : If LE 0 then exit loop
          CLHI    R4,STAEOR             : Test for end of message character
          JE      SQRLB2                : If EOM then exit loop

            SIS     R3,1                : Decrement unsent count
            AIS     R1,1                : Increment empty position by one
            CLH     R1,STQSIZ,,         : Check if beyond end of queue
            IFF(GE)                     : If beyond end of stats queue
              LIS     R1,0              : then set empty pointer to first pos
            ENDIF                       : 
            LB      R4,STAQUE,R1,       : Get character from queue

          J       SQRLB1                : Jump to top of loop

SQRLB2    ST      R1,SQSPOS,,           : Out of loop.  Save empty ^ in send ^
          ST      R1,SQEPOS,,           : Save empty pointer in empty pointer
          L       R3,SQFPOS,,           : Get fill pointer
          SR      R3,R1                 : Subtract send from empty pointer
          IFF(L)                        : If result negative then add
            AH      R3,STQSIZ,,         : size of stats queue to result
          ENDIF                         : 

          ST      R3,SQNCNT,,           : Save result in new count SQNCNT
          LIS     R3,0                  : Set the old count SQOCNT
          ST      R3,SQOCNT,,           : to zero


          RETURN(R1)                      : Return restoring from R1


: (MATS.P2)SQUNTO.04W FIXED CHAINS LABEL PROBLEM 8/24/81 BY WHITNEY

: (MATS.P2)SQUNTO.03K logic rewritten 8/14/81 by Adams
 
: (MATS.P2)SQUNTO.02J  by J. Burke: use the variable SQUNTL for t.o.

: (MATS.P2)SQUNTO.01K created 8/7/81 by Kirk Adams




: SQUNTO - Stats queue unloader timeout routine {SQUNTO}

: This routine repeatedly calls the module which unloads the Stats
: Queue.  The interval between calls is set by a full word
: at the location SQUNTL.  The interval is measured in
: FASTC ticks (600 ticks = 1 sec).

: Input:
:    {Global} SQUNTL

: Output:
:    {Global} SQUNTO puts itself back on the timeout list
:    {Global} The Stats queue is unloaded




            SEG A.CUCD
    CHAINS(SQUNSV,A.CUCD)
SQUNTO     CALL(SQUNL,SQUNSV)           :To try to unload the queue
    L       R1,FASTC,,                  :Compute next time to run
    A       R1,SQUNTL,,                 :**
    LI      R0,SQUNTO                   :Put myself back on t-o list
    JAL     R5,TOPUT,,                  :**
    J       TORET,,                     :RETURN

: (MATS.P2)STQLDR.01F
:    Copied by Bonnell from (MATS)STQLDR.00W    8/28/81
:    Changed code to match pseudo-code (STQLDR.P04)
:    Corrected some errors.


:
:    Procedure:  Stats queue loader (STQLDR)
:
:
:        Procedure to place a stats record in the stats queue and update
:        the stats queue pointers.
:
:    Input:
:
:    R2- STAREC - Pointer to stats record
:        SQFPOS,SQSPOS,SQEPOS - Stats queue pointers
:    R3- STARSZ - Stats record size
:        STQSIZ - Stats queue size in bytes
:        CLSREC - Count of times stats were lost
:        STAQUE - Stats queue
:
:    Output:
:
:        SQFPOS,SQSPOS,SQEPOS - Updated stats queue pointers
:        SQNCNT, SQOCNT - Updated
:        CLSREC - Updated count of times stats were lost
:        STAQUE - Stats queue now containing new stats record
:
:
:*****************************************************************************


        PROCS(STQLDR,A.CUCD)
        CHAINS(STQLSV,A.CUCD)
        DEBUGM(Entering STQLDR,DBGSTA,DALL,STQLSV,A.CUCD)

        LIS     R1,0                    : Set stats record character pos to zero
        LR      R10,R3                  : Make copy of stats record size

        DO(COUNT,R10)                   : For all chars in stats record do ...

          LB      R5,0,R2,R1            : Get next char from stats record
          L       R7,SQFPOS,,           : Get fill pointer
          STB     R5,STAQUE,R7,         : Place character in stats queue
          LIS     R5,1                  : Increment count of new characters
          AM      R5,SQNCNT,,           : in stats queue
          AM      R5,SQFPOS,,           : Bump stats queue fill position
          AIS     R1,1                  : Bump stats record character position

          L       R5,SQFPOS,,           : Get fill position
          CLH     R5,STQSIZ,,           : If fill position is beyond end
          IFF(GE)                       : of queue then ...
            LIS     R5,0                : Set fill position to first position
            ST      R5,SQFPOS,,         : of stats queue
          ENDIF

          CL      R5,SQEPOS,,           : If fill position if stepping on
          IFF(E)                        : empty position then ...

            LIS     R4,1                : Bump stats queue empty position
            AM      R4,SQEPOS,,         : to point to next character in queue
            LCS     R4,1                : Decrement count of old characters
            AM      R4,SQOCNT,,         : in queue
            L       R4,SQEPOS,,         : Get empty position
            CLH     R4,STQSIZ,,         : If empty position is beyond end
            IFF(GE)                     : of queue then ...
              LIS     R4,0              : Set empty position to first character
              ST      R4,SQEPOS,,       : position in the queue
            ENDIF
          ENDIF

          CL      R5,SQSPOS,,           : If fill position is stepping on
          IFF(E)                        : send position then ...

SQLLP
            LIS     R4,1                : Bump the stats queue send position
            AM      R4,SQSPOS,,         : one character
            LCS     R4,1                : Decrement the count of characters
            AM      R4,SQNCNT,,         : in queue to send to receiver
            L       R4,SQSPOS,,         : Get send position
            CLH    R4,STQSIZ,,         : If send position is beyond the end
            IFF(GE)                     : of stats queue then ...
              LIS     R4,0              : Set the send position to the first
              ST      R4,SQSPOS,,       : character position in the queue
            ENDIF

            L       R4,SQNCNT,,         : WHILE new characters still in queue
            JLE     SQLDON
            L       R5,SQSPOS,,         : AND first character to send is still
            LB      R4,STAQUE,R5,       : not the end of record character
            CLHI    R4,STAEOR
            JN      SQLLP

            
SQLDON      LIS     R4,0                : Set old character count to zero
            ST      R4,SQOCNT,,
            L       R4,SQSPOS,,         : Set empty pos to send pos
            ST      R4,SQEPOS,,
            LIS     R4,1                : Increment count of lost stat
            AHM     R4,CLSREC,,         : records

          ENDIF                         :

        ENDDO                           : End do

        RETURN(R1)                      : Return restoring from R1
: (MATS.P2)SQUNL.02T
:       COPIED BY BYRNE FROM (MATS.P2)SQUNL.01K  11/25/81.
:       CONTAINS CHANGES FOR TRACING RECEIVER MESSAGES.


: (MATS.P2)SQUNL.O1K
:       Created 8/10/81 by ADAMS


: SQUNL - Status Queue Unloader
:
: Routine responsible for getting statistics
: from the stats queue to the receiver
: running on a PDP-10.


:Globals
:   *SQSPOS - Stats queue send pointer
:   *SQEPOS - Stats queue empty pointer
:    STAQUE - Stats queue
:   *SQNCNT - Count of characters not yet sent to
:             the receiver
:   *SQOCNT - Count of characters saved
:
:   * - Indicates a global which is modified
:
:   There are no parameters passed through registers



  PROCS(SQUNL,A.CUCD)
  CHAINS(SQUSAV,A.CUCD)
  LI      R4,CSTUP
  LA      R9,MSCTAB,,
  CLH     R4,CCBSTA,R9                           :Buf index = port*4+2
  IFF(E)                                         :circuit is up
    LHL     R4,CCBPRT,R9                         :**
    SLLS    R4,2                                 :**
    AIS     R4,2                                 :**

                                                 :OUTBUFLIM=STBCMX-BCT
    LHL     R5,STBCMX,,                          :**
    SH      R5,BCT,R4,                           :**

    C       R5,SQNCNT,,                          :Compute MIN(SQNCNT,OUTBUFLTM)
    IFF(G)                                       :**
      L       R7,SQNCNT,,                        :**
    ORELSE                                       :**
      LR      R7,R5                              :**
    ENDIF                                        :**

    IFF(G)                                       :Characters to be sent
      L       R4,SQSPOS,,                        :Test for wrap around
      AR      R4,R7                              :**
      CLH     R4,STQSIZ,,                        :**
      IFF(G)                                     :Characters wrap
        LHL     R6,STQSIZ,,                      :CHRS=STQSIZ-SQSPOS
        S       R6,SQSPOS,,                      :**

        LR      R0,R6                            :Call SENDMS
        LR      R1,R9                            :**
        L       R2,SQSPOS,,                      :**
        AI      R2,STAQUE                        :**
        CALL(SENDMS,SQUSAV)                      :**

        LR      R9,R6                            :GET LNGTH OF MSG
        LR      R10,R2                           :GET ADDR OF MSG
        TRPORT(TRSTTO,SQUSAV)                    :TRACE IT
        LA      R9,MSCTAB,,                      :RESTORE R9


        LR      R4,R7                            :CHRS=MIN-CHRS
        SR      R4,R6                            :**
        LR      R6,R4                            :**

        LR      R0,R6                            :Call SENDMS
        LR      R1,R9                            :**
        LI      R2,STAQUE                        :**
        CALL(SENDMS,SQUSAV)                      :**

        LR      R9,R6                            :GET LNGTH OF MSG
        LR      R10,R2                           :GET ADDR OF MSG
        TRPORT(TRSTTO,SQUSAV)                    :TRACE IT
        LA      R9,MSCTAB,,                      :RESTORE R9

      ORELSE
        LR      R0,R7                            :Call SENDMS
        LR      R1,R9                            :**
        L       R2,SQSPOS,,                      :**
        AI      R2,STAQUE                        :**
        CALL(SENDMS,SQUSAV)                      :**

        LR      R9,R7                            :GET LNGTH OF MSG
        LR      R10,R2                           :GET ADDR OF MSG
        TRPORT(TRSTTO,SQUSAV)                    :TRACE IT
        LA      R9,MSCTAB,,                      :RESTORE R9
      ENDIF                                      :Characters wrap

      LR      R8,R7
      A       R8,SQSPOS,,                        :SQSPOS=SQSPOS+MIN
      LHL     R4,STQSIZ                          :IS SQSPOS >= STQSIZ?
      CR      R8,R4                              :**
      IFF(GE)                                    :**
        SR      R8,R4                            :SQSPOS = SQSPOS-STQSIZ
      ENDIF                                      :**
      ST      R8,SQSPOS,,                        :**

      AM      R7,SQOCNT,,                        :SQOCNT = SQOCNT+MIN
      LIS     R0,0                               :SQNCNT = SQNCNT-MIN
      SR      R0,R7                              :**
      AM      R0,SQNCNT,,                        :**



      L       R8,SQOCNT,,                        :EXTRACHARS = SQOCNT-SQRLMT
      S       R8,SQRLMT,,                        :**

      IFF(G)                                     :EXTRACHARS > 0
        LR      R4,R8                            :SQEPOS=SQEPOS+EXTRACHARS
        A       R4,SQEPOS,,                      :**
        CLH     R4,STQSIZ,,                      :Is SQEPOS >= STQSIZ?
        IFF(GE)                                  :**
          SH      R4,STQSIZ,,                    :SQEPOS=SQEPOS-STQSIZ
        ENDIF                                    :**
        ST      R4,SQEPOS,,                      :**
        LIS     R0,0                             :** Complement reg 8
        SR      R0,R8                            :**
        AM      R0,SQOCNT,,                      :** Store result
      ENDIF                                      :EXTRACHARS > 0
    ENDIF                                        :characters to send
  ORELSE                                         :circuit not up
      LHL     R4,CCBSTA,R9                       :
      CLI     R4,CSTDWN                          :
      IFF(E)                                     :circuit down
        LR      R1,R9                            :Call SNHSBC
        Call(SNHSBC,SQUSAV)                      :**
      ENDIF                                      :**
  ENDIF                                          :Circuit is up


  RETURN(R1)

: (MATS.P2)SNHSBC.04L
: Copied by Vaysburd from (MATS.P2)SNHSBC.03F on 11.24.81
: Added code which will check the receiver host status and return
: if it is "CLOSED".
: (MATS.P2)SNHSBC.03F
:    Revised by Bonnell    8/21/81
:    Revised by John B.    8/21/81 later


: PROCEDURE SNHSBC  -  Select next host and start building circuit


:   This procedure treats LSTHST as an index to the host table ( 0 <= LSTHST <
:   OBCHCT ).  SNHSBC advances the index, wrapping if necessary.  If the
:   host with index LSTHST is available, SNHSBC starts building a circuit;
:   if the host is not available, SNHSBC simply returns.  Thus several calls
:   to SNHSBC may be necessary before an available host is found.

:   This represents a simplification of the original SNHSBC.  In this version
:   host ordinals are ignored.


:  Input--

:       R1      CCBPTR     Pointer to the CCB for the stats circuit

:    (gloabl)   LSTHST     Host-table index


:  Output--

:    (global)   LSTHST     Host-table index (updated)


      PROCS(SNHSBC,A.CUCD)

      CHAINS(SNHSAV,A.CUCD)

      LHL       R0,CCBSTA,R1            : Get CCB status
      CLHI      R0,CSTCED               : Is status "CLOSED"?
      IFF(N,THEN)
        CLHI    R0,CSTDWN               : Is circuit down?

        IFF(N)

          LHI   R0,CSTDWN               : No.
          STH   R0,CCBSTA,R1            : Set status to 'down'

          L     R0,FASTC,,              : Get current time
          ST    R0,CCBTIM,R1            : Set time of status change

        ENDIF

        LIS     R0,1
        AHM     R0,LSTHST               : Add 1 to LSTHST

        LHL     R2,LSTHST               : Because it is a half-word, and we
                                        : use LHL, LSTHST is not negative.
        CLH     R2,OBCHCT,R1

        IFF(GE)

          LIS   R2,0                    : LSTHST is too big
          STH   R2,LSTHST               : Set LSTHST = 0

        ENDIF

        LHI     R0,HSTLNG               : Because there is no multiply-
                                        : halfword-immediate instruction
        MHR     R2,R0                   : R2 contains LSTHST*HSTLNG
        A       R2,OBCPRH,R1            : R2 contains HOSTPOINTER

        ST      R2,OBCHSP,R1            : Put host selection in CCB

        LHL     R0,HSTSTA,R2            : Get host availability
        CLHI    R0,HSON

        IFF(E)

          CALL(BLDCIR,SNHSAV)           : Host is available

        ENDIF
      ENDIF                             :Status is "CLOSED"

      RETURN(R0)


: (MATS.P2)BLDCIR.06R
:    Copied by Cheung from (MATS.P2)BLDCIR.05T on 10/06/82
:    Changed the value of TID from "c0" to "c1".

: (MATS.P2)BLDCIR.05T
:    Copied by Byrne from (MATS.P2)BLDCIR.04L on 9/23/82.
:    BLDCIR now builds a normal circuit with an 07 message instead
:    of an aux. circuit with an 08 message.

: (MATS.P2)BLDCIR.04L
: Copied by Vaysburd from (MATS.P2)BLDCIR.03F 0n 10.26.81
: Added new code which will create a login-string (now host table doesn't
: have login-string pointer but has user-name and host # instead).
:

: (MATS.P2)BLDCIR.03F
:    Copied by Bonnell from (MATS.P2)BLDCIR.02F    8/19/81
:    Added code to set LKYCNT = 0.

: (MATS.P2)BLDCIR.02F
:    Copied by Bonnell from (MATS.P2)BLDCIR.01K    8/18/81

: (MATS.P2)BLDCIR.01K
:        Created  8/10/81  by Kirk Adams


: Starts the circuit building process.  A local key is
: picked and on AUX circuit request is sent to ISIS

: Input
:     {REG 1} - Pointer to OBC which has stats circuit info
:     LSTLKY  - Value of last local key used
:     LKYCNT  - Count of local keys in local key table
:     LKYMAX  - Max of local keys allowed in table
:     LKYTAB  - Local key table


: Output
:     LSTLKY  - Updated value of lost local key used
:     LKYCNT  - Updated count of local key table entries
:     LKYTAB  - Updated local key table
:     CCB     - Updated status and status change time



: Note:  Comments which do not appear in the pseudo-code
:        are flagged with ":**"




    SEG     A.CUCD

    PROCS(BLDCIR,A.CUCD)
    CHAINS(BLDSAV,A.CUCD)

    LIS     R0,0
    ST      R0,LKYCNT,,         : Set LKYCNT = 0.  Temporary change!

    L       R0,LKYCNT,,                         :Compare LKYCNT and LKYMAX
    CLI     R0,LKYMAX                           :**

    IFF(L)                                      :LKYCNT < LKYMAX
      LHL     R9,LSTLKY,,                       :Select next local key
      AIS     R9,1                              :** Add 1 to local key
      NI      R9,$0 0FFFF                       :** Wrap, if required
      STH     R9,LSTLKY,,                       :**
   
      LIS     R9,1                              :Bump local key count
      AM      R9,LKYCNT,,                       :**
                                                :Put local key in new local
                                                :                 key table
      LI      R8,LKYLNG                         :**Compute index into table
      M       R7,LKYCNT,,                       :**
      LHL     R9,LSTLKY,,                       :**Load new local key
      STH     R9,LKYTAB+LKYKEY,R8,              :**
   
      ST      R1,LKYTAB+LKYPTR,R8,              :Put OBCPTR in new local key
   
      LIS     R9,0                              :Set OBC's port # to zero (b
      STH     R9,CCBPRT,R1                      :**(because it's using port 0
   
      LR      R7,R1                             :Save the contents of reg1

:Now, build a type 07 port 0 message to request a psuedo-needle
:

        LIS     R0,$A11                :number of bytes in 07 msg
        LIS     R1,0                   :R1 = port #
        LHI     R2,$007                :R2 = message type
        JAL     R4,SLOR,,              :start message, first 3 chars

        LIS     R0,0                   :put key=0 into ORING
        JAL     R4,PUTCH,,             :

        LHL     R0,LSTLKY,,            :get local key
        JAL     R4,PUTH,,              :into message

        LIS     R0,0                   : I orig. port
        JAL     R4,PUTH,,              :

        LHL     R0,HOSTS,,             : Orig. host (this MATS)
        JAL     R4,PUTH,,              :

        LHI     R0,$00C1               :TID = C1  (obtained by observing a needl
        JAL     R4,PUTCH,,             :  gotten from logging into a mats)

        JAL     R4,ELOR,,              :done sending a pseudo-needle request


        LI      R9,CSTWPS                         :Set CCB status to "WPS"
        STH     R9,CCBSTA,R7                      :** (Waiting for pseudo-nedl)
        L       R9,FASTC,,                        :Update CCB status chg time
        ST      R9,CCBTIM,R7                      :**
    ENDIF                                       : LKYCNT <= LKYMAX
   
    RETURN(R0)
: (MATS.P2)CRRCRC.06W   Took out record count zeroing on 9/10/81
:
: (MATS.P2)CRRCRC.05J   Fixed to end dat/time to start d.t.
:       - J.Burke
:
: (MATS.P2)CRRCRC.04W Fixed bugs on 8/28/81
:
: (MATS.P2)CRRCRC.03W Changed to accomidate the new record count record
: formats on 8/26/81
:
:   Procedure:  Create record count record (CRRCRC)
:
:       Routine to create the record count records.  First the old record
:       count record is sent to the queue.  Then a new record count record
:       is created and it is also sent to the queue.  This will cause each
:       record count record to be sent twice to the receiver.  This routine
:       is a timeout routine and it resubmitts it's self to run every n
:       seconds.  
:
:   Input:
:
:       Record counts {USTCNT,USECNT,MSTCNT}
:       Record count assembly area {RCTREC}
:
:   Output:
:
:       Stats queue now containing two more record count records
:
:
:************************************************************************
:
:

        CHAINS(CRRCSV,A.CUCD)
CRRCRC  DEBUGM(Entering CRRCRC,DBGSTA,DALL,CRRCSV,A.CUCD)

        LA      R2,RCTREC,,             : Add old record count record to the
        LI      R3,RCTLNG               : stats queue
        CALL(STQLDR,CRRCSV)             : 

        LA      R3,RCTEDY,,             : Make the previous end-time this
        LA      R4,RCTSDY,,             : record's start-time.
        LIS     R5,$A12                 :
        MVS(R3,R4,R5,R2)                :

        L       R3,GMT,,                : Set end time in record count record
        LHI     R4,$A12                 : to current time (Fills in RCTEDA
        LA      R5,RCTEDY,,             : and RCTETI
        CALL(DANTIM,CRRCSV)             : 

        L       R3,USTCNT,,             : Place count of user startup records
        LIS     R4,$A8                  : in record
        LA      R5,RCTUST,,             : 
        CALL(BINDEC,CRRCSV)             : 

        L       R3,USECNT,,             : Place count of user service records
        LIS     R4,$A8                  : in record
        LA      R5,RCTUSR,,             : 
        CALL(BINDEC,CRRCSV)             : 

        L       R3,MSTCNT,,             : Place count of mats startup records
        LIS     R4,$A8                  : in record
        LA      R5,RCTMST,,             : 
        CALL(BINDEC,CRRCSV)             : 

        LA      R2,RCTREC,,             : Add new record count record to stats
        LI      R3,RCTLNG               : queue
        CALL(STQLDR,CRRCSV)             : 

        LA      R0,CRRCRC,,             : Must submit CRRCRC to run again soon
        L       R1,RCTPER               : Compute time to run again.  
        A       R1,FASTC,,              : 
        JAL     R5,TOPUT,,              : 

        J       TORET,,                 : Jump back to time out return
: (MATS.P2)CIRTMO.08T
:    Copied by Byrne from (MATS.P2)CIRTMO.07T on 9/27/82.
:    Added check to wait while a normal circuit is being built.

: (MATS.P2)CIRTMO.07T
:  COPIED BY BYRNE FROM (MATS.P2)CIRTMO.06L   11/30/81.
:  ADDED CODE TO TRACE THE DIRECT ZAP.

: (MATS.P2)CIRTMO.06L
: Copied by Vaysburd from (MATS.P2)CIRTMO.05W on 11.24.81
: Added code which will check the receiver host status and return if
: it is "CLOSED" or "DOWN".IT WILL BUMP AN ERROR COUNTER IF STATUS IS
:"CLOSING" OR "DROPPING".
: (MATS.P2:56)CIRTMO.05W
: Added counting of host time outs on 9/10/81
:
:   Procedure:  Circuit timeout (CIRTMO)
:
:       Timeout routine to detect timeout of requests for a normal circuit
:       which never gets a response.
:       Trivial version for Mats Stats Phase I, just checks the MSCTAB for
:       Wait Pseudo Needle status MSC's
:
:   Input:
:
:       MSCTAB (global) - Mats Stats Circuit Table (CCB)
:
:   Output:
:
:       None
:
:
:**************************************************************************
:
:

        CHAINS(CIRTSV,A.CUCD)

CIRTMO  L       R1,FASTC,,              : Compute next time that this routine
        A       R1,CTOCKL,,             : should run again.
        LI      R0,CIRTMO               : Load up name of routine to run
        JAL     R5,TOPUT,,              : Submit routine to run in STPSTL ticks
        LA      R1,MSCTAB,,             :Get location of MSC table
        L       R3,FASTC,,              :Compute time since last activity   
        S       R3,CCBTIM,R1,

        LHL     R4,CCBSTA,R1            : Get circuit status
        CLHI    R4,CSTWPS               : If circuit status is waiting for
        IFF(E)                          : pseudo needle then ...
          C       R3,STPSTL,,           : If waiting longer than
          IFF(G)                        : tolerable then ...
            CALL(SNHSBC,CIRTSV)         : Build circuit to new host
          ENDIF                         : 
        ORELSE
          CLHI  R4,CSTDWN
          IFF(N,THEN)                   :status is not down
           CLHI R4,CSTCED
           IFF(N,THEN)                  :status is not "CLOSED"
            L       R1,STRPTL,,         :circuit response time limit
            CLHI    R4,CSTLGI           :if status is "logging on"
            IFF(E)                      :
              L       R1,STPSTL,,       : then use pseudo-needle time limit
            ENDIF                       :

            CR      R3,R1               :
            IFF(G,THEN)                 :IF TIMEOUT
              LA      R1,MSCTAB,,       :  THEN ZAP THE CIRCUIT
              TRPORT(UDISC,CIRTSV)      : TRACE ZAP
              LHL  R1,CCBPRT,R1
              CALL(DIRZAP,CIRTSV)
              LA        R1,MSCTAB,,
              CALL(INITPT,CIRTSV)
              L       R5,OBCHSP,R1,     : Get pointer of host table enter
              LIS     R6,1              : Bump the count of time outs for
              AM      R6,HSTTO,R5,      : this host
              CLHI      R4,CSTCNG       :IS STATUS "CLOSING"?
              IFF(E)
                LIS     R12,1           :BUMP ERROR COUNTER
                AHM     R12,ERRESP,,
              ORELSE
                CLHI    R4,CSTDNG       :IS STATUS "DROPPING"?
                IFF(E)
                  LIS   R12,1           :BUMP ERROR COUNTER
                  AHM   R12,ERRESP,,
                ENDIF
              ENDIF
            ENDIF
           ENDIF
          ENDIF
        ENDIF

        J       TORET,,                 : Return

: (MATS.P2)GTCHRS.02F
:    Copied by Bonnell from (MATS.P2)GTCHRS.01F.   8/26/81
:    Added new procedure -- GTCHBO

: (MATS.P2)GTCHRS.01F
:    Copied by Bonnell from (MATS.P2)GTCHRS.00W    8/24/81
:    Changed a couple of instructions.
:
:
:    Procedure: Get characters (GTCHRS)
:
:        Routine to get, from input buffer, characters and place them in
:        another buffer.  The routine will make sure not to read beyond the end
:        of bufferlet chain.  A count of characters read will be returned.
:        Use of this routine rather than GCI will insure that you do not
:        crash by reading beyond end of bufferlet chain.
:
:    Input:
:
:        R1  BUFCHN - Bufferlet chain number.  2 * Buffer number.
:        R2  BUFADR - Address of receipient buffer space
:        R3  GETCNT - Number of characters wanted
:
:    Output:
:
:            Updated bufferlet chain (Global)
:            Filled receipient bufferspace (Global)
:        R0  GOTCNT - Number of characters gotten
:
:
:**************************************************************************
:
:
        PROCS(GTCHRS,A.CUCD)
        CHAINS(GTCHSV,A.CUCD)
        DEBUGM(Entering GTCHRS,DBGSTA,DALL,GTCHSV,A.CUCD)

        LR      R5,R2                   : Place destination address in R5
        LR      R6,R3                   : Place want count in R6
        LIS     R7,0                    : Set gotten count to zero

GTCHLP  CR      R7,R6                   : Got enough characters?
        JGE     GTCDON                  : Yes.  We're done.

        LHL     R4,BCT,R1,              : Get count of characters left in buf
        JLE     GTCDON                  : No characters in buffer.

        JAL     R4,GCI,,                : Get character from bufferlet chain
        STB     R0,0,R5,R7              : Store character in destination buffer
        AIS     R7,1                    : Bump count of characters gotten
        J       GTCHLP                  : Loop for more characters

GTCDON  LR      R0,R7                   : Put count of characters gotten in R0
        RETURN(R1)                      : Return restoring from R1



:  PROCEDURE  GTCHBO -- Get characters with high bit on.

:       GTCHBO is just like GTCHRS, except that GTCHBO turns on the
:       high-order bit in each character it gets.



        PROCS(GTCHBO,A.CUCD)
        CHAINS(HBOSAV,A.CUCD)

        DEBUGM(Entering GTCHBO,DBGSTA,DALL,HBOSAV,A.CUCD)

        LR      R5,R2                   : Place destination address in R5
        LR      R6,R3                   : Place want count in R6
        LIS     R7,0                    : Set gotten count to zero

HBOHLP  CR      R7,R6                   : Got enough characters?
        JGE     HBODON                  : Yes.  We're done.

        LHL     R4,BCT,R1,              : Get count of characters left in buf
        JLE     HBODON                  : No characters in buffer.

        JAL     R4,GCI,,                : Get character from bufferlet chain
        OHI     R0,$080                 : Turn on high-order bit
        STB     R0,0,R5,R7              : Store character in destination buffer
        AIS     R7,1                    : Bump count of characters gotten
        J       HBOHLP                  : Loop for more characters

HBODON  LR      R0,R7                   : Put count of characters gotten in R0
        RETURN(R1)                      : Return restoring from R1

        





:
:   Procedure:  Port Zero (PTZERO)  
:
:   Last change:  8/13/81
:
:       Activation routine for port zero.  Routine will be activated
:       whenever there is a message on port zero.  Currently for
:       Mats stats the routine will only be conserned with one message,
:       the pseudo-needle error message (09).  This message is 
:       generated by the network supervisor when it is unable to 
:       provide a good needle or circuit when an AUX circuit request
:       is made.  At initialization time Mats will have to set this 
:       routine as the port zero activation routine.
:
:   Input:
:
:       Activation type from FRONT.LIB (Passed in R0)
:       Bufferlet index (Passed in R1)
:       Port zero input buffer (Global)
:       CUEPZM - Count of unexpected port zero messages (Global)
:       CUEPZA - Count of unexpected port zero activation (Global)
:
:   Output:
:
:       Empty port zero input buffer (Global)
:       Updated counts (CUEPZM,CUEPZA) (Global)
:       Time out period returned in R0 (Passed)
:       Local key table updated by NDLERR (Global)
:
:
:****************************************************************************
:
:
        PROCS(PTZERO,A.CUCD)
        CHAINS(PTZRSV,A.CUCD)
        DEBUGM(Entering PTZERO,DBGSTA,DALL,PTZRSV,A.CUCD)

        LA      R2,PZMSGT,,             : Local var for port zero msg type byte
        LIS     R3,1                     :ONLY ONE CHARACTER  wanted
        CALL(GTCHRS,PTZRSV)             : Get two chars from port 0 inp buffer
        CLHI    R0,1                    : If number of characters gotten is
        IFF(E)                          : ONE then ...

          LB      R0,PZMSGT,,          : Get the message type byte in register
          CLHI    R0,09                 : If message type is not pseudo needle
          IFF(E)                        : error {09} then ...

            CALL(NDLERR,PTZRSV)         : Process needle error message

          ORELSE                        :

            LIS     R0,1                : Add one to port zero error
            AHM     R0,CUEPZM,,         : count

          ENDIF                         :

        ORELSE                          : Didn't get all characters wanted ...

          LIS     R0,1                  : Increment count of port zero
          AHM     R0,CUEPZM,,           : errors

        ENDIF                           :

        JAL     R4,EMPTY,,              : Empty port zero input bufferlet chain
        LIS     R0,0                    : Return zero as time out value

        RETURN(R1)                      : to get default time out

        SEG     0                       : Local variable definitions

PZMSGT  BS      1                       : Port zero message type byte

: (MATS.P2)NDLERR.01W Fixed bug on 8/25/81
:
:
:    Procedure:  Needle error (NDLERR)  Okayed on 7/30
:
:        Routine to process the pseudo-needle error messages that is
:        received on port zero.
:
:    Input:
:
:        Port zero input buffer without message type (Global)
:        LKYTAB - Local key table (Global)
:        LKYCNT - Count of entries in the local key table (Global)
:        CUECTY - Count of unexpected circuit types (Global)
:        CLKNFD - Count of local keys not found in table (Global)
:        CBNEML - Count of bad needle error message lengths (Global)
:
:    Output:
:
:        Port zero input buffer without needle error message (Global)
:        LKYTAB - Local key table (Global)
:        LKYCNT - Updated count of entries in the local key table (Global)
:        CUECTY - Updated count of unexpected circuit types (Global)
:        CLKNFD - Updated count of local keys not found in table (Global)
:        CBNEML - Updated count of bad needle error message lengths (Global)
:
:
:***************************************************************************
:
:
        PROCS(NDLERR,A.CUCD)
        CHAINS(NDLESV,A.CUCD)
        DEBUGM(Entering NDLERR,DBGSTA,DALL,NDLESV,A.CUCD)

        LA      R2,DUMADR,,             : Get key and just throw it away
        LIS     R3,1                    : Set chars wanted to one
        CALL(GTCHRS,NDLESV)             : Try and get character
        LA      R2,LOCKEY,,             : Now get local key from input buffer
        LIS     R3,2                    : The local key is two chars long
        CALL(GTCHRS,NDLESV)             : Try and get two chars
        LA      R2,NDLERT,,             : Now get needle error type
        LIS     R3,1                    : Type is only one byte long
        CALL(GTCHRS,NDLESV)             : Try and get needle error type

        CLHI    R0,1                    : If needle error type was
        IFF(E)                          : gotten then ...

          LHL     R3,LOCKEY,,           : Load up local key value for search
          CALL(SRCHLK,NDLESV)           : Search for local key in LKYTAB
          CLHI    R0,TRUE               : If local key found in local key
          IFF(E)                        : table then ...

            L       R1,LKYPTR,R2,       : Get pointer to CCB
            CALL(DELKEY,NDLESV)         : Delete the local key table entry
            LB      R2,CCBTYP,R1,       : Get type of CCB
            CLHI    R2,MSCTYP           : If CCB type is mats stats circuit
            IFF(E)                      : then ...

              CALL(SNHSBC,NDLESV)       : Select another host to send to

            ORELSE                      : CCB type is not mats stats

              LIS     R2,1              : Increment count of unexpected
              AHM     R2,CUECTY,,       : circuit types by one

            ENDIF                       : 

          ORELSE                        : Local key not found

            LIS     R2,1                : Increment count of local keys not
            AHM     R2,CLKNFD,,         : found in table by one

          ENDIF                         :

        ORELSE                          : Bad needle error message length

          LIS     R2,1                  : Increment count of bad needle error
          AHM     R2,CBNEML,,           : message lengths by one

        ENDIF                           : 

        RETURN(R1)                      : Return

        SEG     0                       : Local variable definitions

LOCKEY  HS      1                       : Local key
NDLERT  BS      1                       : Needle error type

: (MATS.P2)SRCHLK.02W Fixed bug doe to register restoration on 8/25/81
:
: (MATS.P2)SRCHLK.01W Trivialized full length version on 8/21/81
:
:    Procedure:  Search for local key (SRCHLK)
:
:        Routine to search the local key table for an entry which
:        contains a given local key.
:        Phase I trivial routine which only returns the status of the
:        first entry in the table.
:
:    Input:
:
:        R3   - Local key to be searched for
:               LKYTAB - Local key table (Global)
:               LKYCNT - Count of entries in local key table (Global)
:
:    Output:
:
:        R2   - Pointer to entry that local key was found in
:        R0   - True (nonzero) if local key found
:               False (zero) if local key not found
:
:
:***************************************************************************
:
:
        PROCS(SRCHLK,A.CUCD)
        CHAINS(SRCHSV,A.CUCD)
        DEBUGM(Entering SRCHLK,DBGSTA,DALL,SRCHSV,A.CUCD)

        LIS     R0,FALSE                : Set found to false
        LA      R4,LKYTAB,,             : Get location of local key table
        AI      R4,LKYLNG               : Get location of first entry in table

        CLH     R3,LKYKEY,R4,           : If local key in first entry in local
        IFF(E)                          : key table is one desired then ...
          LR      R2,R4                 : Return pointer to local key
          LIS     R0,TRUE               : Set found to true
        ENDIF                           :

        RETURN(R3)                      : Return restoring from R3
:
:    Procedure:  Delete local key (DELKEY)  Okayed on 7/30
:
:    Last change:  8/20/81
:
:        Routine to delete a local key entry from the table of
:        outstanding local keys.
:        Temporary trivialized version, which only subtracts one from the
:        local key in the first table entry.
:
:    Input:
:
:        R2    - Pointer to local key to be deleted
:               LKYTAB - Local key table (Global)
:               LKYCNT - Count of entries in local key table (Global)
:               CDLKYE - Count of delete key errors (Global)
:
:    Output:
:
:        LKYCNT - Updated count of entries in local key table (Global)
:        CDLKYE - Updated count of delete key errors (Global)
:
:
:***************************************************************************
:
:
        PROCS(DELKEY,A.CUCD)
        CHAINS(DELKSV,A.CUCD)
        DEBUGM(Entering DELKEY,DBGSTA,DALL,DELKSV,A.CUCD)
 
        LCS     R4,1
        AHM     R4,LKYTAB+LKYLNG+LKYKEY,,
        RETURN(R1)                      : Return restoring from R1
: (MATS.P2) STAHND.09T
:    COPIED BY BYRNE FROM (MATS.P2)STAHND.08L 11/30/81.
:    ADDS CODE TO TRACE STATS MESSAGES.
:
:
: (MATS.P2)STAHND.08L
: Copied by Vaysburd from (MATS.P2)STAHND.07W on 11.24.81
: Added code which will check the receiver host status (in the case 
: of data activation) AND RETURN IF STATUS IS "CLOSING" OR "DROPPING"
: (MATS.P2)STAHND.07W
:    Added counting of  data activations on 11/10/81
:
: (MATS.P2)STAHND.06F
:    Copied by Bonnell from (MATS.P2)STAHND.05S.    9/4/81
:    Changed handling of timeout activation.  This code conforms to the
:    pseudo-code in STAHND.P05.

: (MATS.P2)STAHND.05S
:    Copied by Gimnicher from (MATS.P2)STAHND.04S
:    Changed #OKAY message to #PURPLE in order to differentiate
:    messages to the receiver from messages from the receiver.

: (MATS.P2)STAHND.04S
:    Copied by Gimnicher from (MATS.P2)STAHND.03W.  8-26-81
:    Changed GTCHRS calls to GTCHBO calls.

: (MATS.P2)STAHND.03W Fixed output port number error on 8/26/81
:
: (MATS.P2)STAHND.02W Fixed reviewer oversights on 8/26/81
:
: (MATS.P2)STAHND.01F
:    Copied by Bonnell from (MATS.P2)STAHND.00W    8/25/81
:    Made minor corrections to get a good assembly.

:
:
:    Procedure:  Stats handler (STAHND)
:
:        Activation routine for stats circuits.  Will handle the different
:        types of activations and process the receiver-to-mats messages.
:        STAHND is set up as the activation routine after initial ID is
:        recognized from the Receiver.
:
:    Input:
:
:    R1- port*4 (i.e. input-buffer index)
:        Stats port input buffer (Global)
:    R0- Activation type (Passed)
:        P2U[port] points to the Mats Stats Circuit Control Block (MSC);
:          the MSC contains an OBC which contains a CCB.
:        CIVRMC - Count of invalid receiver message characters
:        CURRM  - Count of unrecognized receiver messages
:
:    Output:
:
:        Stats port input buffer (Global)
:        CIVRMC - Count of invalid receiver message characters
:        CURRM  - Count of unrecognized receiver messages
:    R0- Returns the timeout value for FRONT.LIB in R0 as per FRONT.LIB
:            convention.  This is the period for which we want to send
:            the #OKAY to the receiver.
:
:
:****************************************************************************
:
:

        PROCS(STAHND,A.CUCD)
        CHAINS(STAHSV,A.CUCD)
        DEBUGM(Entering STAHND,DBGSTA,DALL,STAHSV,A.CUCD)

:   Begin compare macro

CMPRST MACRO(MSG001,MSG002)[
        LIS     R0,0                    : Set match flag to false
        LB      R9,MSG002,,             : Get length of msg2
        CLB     R9,MSG001,,             : If length of msg2 is less to length 
        IFF(L)                          : of msg1 then ...
          LIS     R0,1                  : Set match flag to true
          DO(COUNT,R9)                  : Loop through message2
            LB      R10,MSG001,R9,    : Get character from msg1
            CLB     R10,MSG002,R9,    : Compare it to character from msg2
            IFF(N)                      : If characters not equal then ...
              LIS     R0,0              : Set match flag to false
              EXITDO                    :
            ENDIF                       :
          ENDDO                         :
        ENDIF                           :
        ]

:   End compare macro

        LR      R5,R1                   : R1 has 4 times port number
        SRHLS   R5,2                    : R5 has port number
        LR      R11,R1                  : Save four times port number

        L       R6,P2U,R1,              : Get pointer to CCB from P2U
        L       R7,OBCHSP,R6,           : Get pointer to host table entry
        CLHI    R0,-4                   : If activation type is not timeout
        IFF(N)                          : then ...

          LR      R0,R0                 : If R0 = 0 then we have a data 
          JE      STDATA                : activation so branch to process data
          
          CLHI    R0,-2                 : If not a too many char activation 
          JN      STLB30                : then jump to check for zap activation

          LIS     R1,1                  : TMC activation so bump count of TMC
          AM      R1,HSTTMC,R7,         : activations for this receiver

STDATA    LIS     R3,1                  : Increment count of data activations
          AM      R3,HSTDAT,R7,         : 
          LHL   R12,CCBSTA,R6,          :get receiver status
          CLHI  R12,CSTCNG              :is it "CLOSING"?
          JE    STLB50
 
          CLHI  R12,CSTDNG              :is it "DROPPING"?
          JE    STLB50
          LA      R2,FSTCHR,,           : Get first character from the stats
          LIS     R3,1                  : circuit input buffer
          CALL(GTCHBO,STAHSV)           : 
          CLHI    R0,1                  : If character not gotten then jump
          JN      STLB05                : to count bad receiver message
          LB      R3,FSTCHR,,           : else get character in register
          CLHI    R3,STASOM             : If character is the stats SOM char.
          JE      STLB10                : then jump to process rest of msg

STLB05    LIS     R3,1                  : Increment count of invalid receiver
          AHM     R3,CIVRMC,,           : messages
          J       STLB25                : End data and TMC activation case

STLB10    LA      R2,STRMSG,,           : Clear out the stats receiver
          LHI     R3,SRMLNG             : message to all blanks
          LHI     R4,$00A0
          CALL(CLEAR,STAHSV)

          LA      R2,STRMSG+1,,         : Read in rest of characters up to CR
          LHI     R3,SRMLNG-1           : from input buffer and store in local
          CALL(GTCHBO,STAHSV)           : variable
          STB     R0,STRMSG,,           : Make msg a string constant (SC) by
                                        : storing length in first byte
          LA      R1,MSCTAB,,
          LR      R9,R0                 : GET LENGTH OF MSG
          LA      R10,STRMSG+1,,        : GET ADDRESS OF MSG
          TRPORT(TRSTFM,STAHSV)         :TRACE IT
:
:
  
          CMPRST(STRMSG,RCMNWR)         : Check for not able to write message
          CLHI  R0,1                    :
          JE      STLB15                :

          CMPRST(STRMSG,RCMDRP)         : Check for drop message
          CLHI    R0,1                  :
          JE      STLB15                :

          CMPRST(STRMSG,RCMDRK)         : Check for drack message
          CLHI    R0,1                  :
          JE      STLB15                :

          CMPRST(STRMSG,RCMOKY)         : Check for okay message
          CLHI    R0,1                  :
          JE      STLB20                :

          J       STLB25                : If none of these, do nothing

STLB15    LI      R4,CSTNWR             : Case for NWR, DROP and DRACK
                                        : Set status to NWR
STLB17    STH     R4,CCBSTA,R6,         : Set circuit status 
          L       R4,FASTC,,            : Also set time of event
          ST      R4,CCBTIM,R6,         :
          J       STLB25                :

STLB20    LI      R4,CSTUP              : Case for OKAY.  Set circuit status
          J       STLB17                : to up

STLB25    J       STLB50                : End of data activation case

STLB30    CLHI    R0,$09F               : If zap activation 
          JE      STLB35                : Jump to select new receiver
          CLHI    R0,$09E               : If detach activation 
          IFF(E)                        : then ...
STLB35      LA      R1,MSCTAB,,
            TRPORT(UDISC,STAHSV)        : TRACE INCOMING ZAP
            LIS     R3,1                : Increment count of zap activations
            AM      R3,HSTZAP,R7,       : for receiver
            LR      R1,R6               : Put CCB pointer in R1
            CALL(INITPT,STAHSV)         : Initialize the port (zap it)
            CALL(SNHSBC,STAHSV)         : Select another receiver
            J       STLB50
          ENDIF

          LIS     R3,1                  : Increment count of unexpected
          AM      R3,HSTUEA,R7,         : activations

STLB50    LR      R1,R11                : Get port times four in R1
          JAL     R4,EMPTY,,            : Clear out rest of input if any left

        ORELSE                          : Time out activation

          LR      R1,R6               : Send okay message to receiver
          L       R2,STMPOK,,         : 
          LB      R0,,R2,             : Get length of message to send
          LR      R9,R0               : SAVE LENGTH 
          AIS     R2,1                : Get real start of message
          CALL(SENDMS,STAHSV)         : Send the message
          LR      R10,R2                : GET ADDRESS OF MSG
          TRPORT(TRSTTO,STAHSV)         : TRACE IT
:
:


        ENDIF                           :

        L       R0,STOKTL               : Get timeout period (seconds)
        RETURN(R1)                      : Return restoring from R1

        SEG     0                       : Local variable definitions

STRMSG  BS      21                      : Stats receiver message
SRMLNG  EQ      .-STRMSG                : Length of receiver message space
STMPOK  WC      STMOK                   : Pointer to okay message that is sent
                                        : to the receiver
STMOK   SC      /#PURPLE"8D/            : Okay message for recever
FSTCHR  BS      1                       : First character


: (MATS.P2)CUSERV.07S
:    Copied by Gimnicher from (MATS.P2)CUSERV.06W.  10-1-81
:    Changed calling sequence to add parameter of res block.
:    Changed filling of unused fields from spaces to ascii
:    zeros.
:    These tasks were done in order to fix some bugs in the MATS STATS
:    records.

: (MATS.P2)CUSERV.06W Month and day added to invoice # on 9/11/81
:
: (MATS.P2)CUSERV.05W Still more bugs fixed on 8/29/81
:
: (MATS.P2)CUSERV.04W More bugs fixed on 8/28/81
:
: (MATS.P2)CUSERV.03W Fixed bugs on 8/28/81
:
: (MATS.P2)CUSERV.02W Changed code to take care of new record formats on 
: 8/26/81
:
:   Procedure:  Create user service record (CUSERV)
:
:       Routine to create the user service record.  This is done by gathering
:       all the service record information and converting it to printable
:       ASCII characters which are then placed in the user service record
:       assembly area.   Once the record is created it is loaded in the
:       stats queue.
:
:   Input:
:
:       AUB pointer or negative port # (Passed in R8)
:       Res block pointer passed in R2
:       Reason for creation of user serice record (Passed in R3)
:
:   Output:
:
:       Count of user service records incremented by one {USECNT}
:
:
:************************************************************************
:
:


        PROCS(CUSERV,A.CUCD)
        CHAINS(CUSESV,A.CUCD)
        DEBUGM(Entering CUSERV,DBGSTA,DALL,CUSESV,A.CUCD)

        LR      R11,R2                  : Save pointer to res block
        LR      R12,R3                  : Save reason in R12
        LR      R1,R8                   : Move AUB pointer or neg port # to R1
        LR      R6,R1                   : Get AUB ^ of negative port number
        IFF(L)                          : If negative port number then ...
          XI      R6,-1                 : invert it
          AIS     R6,1                  :
        ORELSE                          : Otherwise it is an AUB ^ so ...
          LHL     R6,AUBPRT,R1,         : get port number from AUBPRT
        ENDIF                           : Port number should now be in R6

        LR      R7,R6                   : Using port # compute port # * 2 for
        SLHLS   R7,1                    : later use as index into login arrays

        L       R3,GMT,,                : Place current time in event time in
        LHI     R4,$A12                 : startup record (fills in UVCEDA
        LA      R5,UVCEDA,,             : and UVCETI)
        CALL(DANTIM,CUSESV)             : 

        LA      R3,LGIMND,R7,R7         : Place login month and date in invoice
        LA      R4,UVCSMD,,             : number
        LIS     R5,4                    :
        MVS(R3,R4,R5,R8)                :

        L       R3,LGIIVO,R7,R7         : Place invoice number in record
        LIS     R4,$A10                 : 
        LA      R5,UVCSES,,             : 
        CALL(BINDEC,CUSESV)             : 

        CLHI    R1,0                    : Check is we have an AUB
        IFF(L)                          : If no AUB then ...

          LA      R3,INTLUD+LUDNAM,,    : Get user name from its temporary
          LA      R4,UVCUNM,,           : residence at INTLUD avenue and place
          LHI     R5,NC.UNM             : in record
          MVS(R3,R4,R5,R8)              : 

          LI      R3,UVCEOR-UVCSDA      : Here we are placing ascii zeros where
          LA      R2,UVCSDA,,           : normally information would be put
          LHI     R4,$00B0              : but we have no AUB to get info from
          CALL(CLEAR,CUSESV)

        ORELSE                          : We do have an AUB ...

          LA      R3,AUBUSR,R1,         : Place user name in record from AUB
          LA      R4,UVCUNM,,           : 
          LHI     R5,NC.UNM             : 
          MVS(R3,R4,R5,R8)              :

          CLI     R11,RBLOCK            : If res block seems valid
          IFF(GE)                       : then ...

            L       R3,RBSTTM,R11,      : Place service start time in record
            LIS     R4,$A12             : (fills in UVCSDA and UVCSTI)
            LA      R5,UVCSDA,,         : 
            CALL(DANTIM,CUSESV)         : 

            LA      R3,RBRESC,R11,      : Place service code in record
            LA      R4,UVCSCO,,         : 
            LIS     R5,2                : 
            MVS(R3,R4,R5,R8)            : 
            LI      R3,2                : Pad with two blanks
            LA      R4,UVCSCO+2,,       :
            SPAC(R4,R3,R5)              :

            LH      R3,RBRESN,R11,      : Place service number in record
            LIS     R4,4                : 
            LA      R5,UVCSNU,,         : 
            CALL(BINDEC,CUSESV)         : 

            L       R3,RBDSCC,R11,      : Place count of characters sent to
            LIS     R4,7                : CRT in record
            LA      R5,UVCNDC,,         : 
            CALL(BINDEC,CUSESV)         : 

            L       R3,RBPRCC,R11,      : Place count of printed characters
            LIS     R4,7                : in record
            LA      R5,UVCNPC,,         : 
            CALL(BINDEC,CUSESV)         : 

            L       R3,RBNTIK,R11,      : Place number of tickets printed in
            LIS     R4,5                : record
            LA      R5,UVCNTK,,         : 
            CALL(BINDEC,CUSESV)         : 

            LA      R8,UVCSPO,,         : Place service IA-TA in record
            LIS     R9,2                : 
            LA      R10,RBIATA+2,R11,   : 
            CALL(BINHXW,CUSESV)         : 


            LA      R2,UVCNCM,,         : Place zeros over number of commands
            LIS     R3,6                :
            LHI     R4,$00B0            :
            CALL(CLEAR,CUSESV)          :

            LA      R2,UVCNCE,,         : Place zeros over number of command
            LIS     R3,6                : errors
            LHI     R4,$00B0            : 
            CALL(CLEAR,CUSESV)          :

            LB      R3,RBLIC,R11,       : Place language used in record
            AI      R3,$00C1            : 
            STB     R3,UVCLAG,,         : 

          ORELSE                        : We have and AUB but no active RB ...

            LI      R3,UVCEOR-UVCSDA    : Here we are placing ascii zeros where
            LA      R2,UVCSDA,,         : normally information from res block
            LHI     R4,$00B0            : would be placed
            CALL(CLEAR,CUSESV)

          ENDIF                         : 

        ENDIF                           : 

        AI      R12,$00C1               : Place event type in record
        STB     R12,UVCEVT,,            : 

        LIS     R3,1                    : Bump count of user service records
        AM      R3,USECNT,,             : by one

        LA      R2,UVCREC,,             : Call the stats queue loader to load
        LI      R3,UVCLNG               : the record in the queue.  Need to
        CALL(STQLDR,CUSESV)             : pass record address and record length

        RETURN(R1)                      : Return restoring from R1

: (MATS.P2)CMSTAR.05W Still more bug fixes on 8/28/81
:
: (MATS.P2)CMSTAR.04W More bug fixes on 8/28/81
:
: (MATS.P2)CMSTAR.03W Fixed bugs on 8/28/81
:
: (MATS.P2)CMSTAR.02W Changed to accomidate new mats startup record format
: on 8/26/81
:
: (MATS.P2)CMSTAR.01W
:
:   Procedure:  Create mats startup record (CMSTAR)
:
:       Routine to create the mats startup record.  This is done by gathering
:       all the startup record information and converting it to printable
:       ASCII characters which are then placed in the mats startup record
:       assembly area.
:
:   Input:
:
:       GMT - Current dal and time (Global)
:       NODEX - Mats node number (Global)
:       HOSTS - Mats host number (Global)
:       HOSTX - Kernal host number (Global)
:       SLOTNO - Mats slow number (Global)
:       VERSON - Mats 30 character version (Global)
:       CRSHCT - Crash count (Global)
:       CRASHC - Crash code (Global)
:
:   Output:
:
:       Mats startup record in mats startup assembly area
:
:
:**************************************************************************
:
:
        PROCS(CMSTAR,A.CUCD)
        CHAINS(CMSTSV,A.CUCD)

        L       R3,GMT,,                : Place startup time in record
        LHI     R4,$A12                 : Fills in MUPDAT and MUPTIM
        LA      R5,MUPDAT,,             :
        CALL(DANTIM,CMSTSV)             :

        LHL     R3,NODEX,,              : Place mats node number in record
        LIS     R4,4                    :
        LA      R5,MUPNOD,,             :
        CALL(BINDEC,CMSTSV)             :

        LHL     R3,HOSTS,,              : Place mats host number in record
        LIS     R4,4                    :
        LA      R5,MUPHOS,,             :
        CALL(BINDEC,CMSTSV)             :

        LHL     R3,HOSTX,,              : Place kernal host number in record
        LIS     R4,4                    :
        LA      R5,MUPKHO,,             :
        CALL(BINDEC,CMSTSV)             :

        LHL     R3,SLOTNO,,             : Place mats slot number in record
        LIS     R4,2                    :
        LA      R5,MUPSLO,,             :
        CALL(BINDEC,CMSTSV)             :

        LA      R3,V.LUD.+1,,           : Place mats version number in record
        LA      R4,MUPVER,,             :
        LB      R5,V.LUD.,,             :
        MVS(R3,R4,R5,R6)                :

        LO      CRASH                   :
        LHL     R3,CRSHCT,,             : Place crash count in record
        LIS     R4,3                    :
        LA      R5,MUPCCT,,             :
        CALL(BINDEC,CMSTSV)             :

        LA      R8,MUPCCO,,             : Place crash code in record
        LIS     R9,1                    :
        LA      R10,CRASHC+1,,          :
        CALL(BINHXW,CMSTSV)             :
        FO      CRASH                   :

        LIS     R3,1                    : Bump count of mats startup records
        AM      R3,MSTCNT,,             : by one

        RETURN(R1)                      : Return restoring from R1
: (MATS.P2)CUSTAR.04W Added lengthened invoice number with month and
: day on 9/10/81
:
: (MATS.P2)CUSTAR.03W Fixed bugs on 8/28/81
:
: (MATS.P2)CUSTAR.02W Changed code to create new status record formats on
: 8/27/81
:
:   Procedure:  Create user startup record (CUSTAR)
:
:       Routine to create the user startup record.  This is done by gathering
:       all the startup record information and converting it to printable
:       ASCII characters which are then placed in the user startup record
:       assembly area.   Once the record is created it is loaded in the
:       stats queue.
:
:   Input:
:
:       AUB pointer or negative port # (Passed in R1)
:
:   Output:
:
:       Count of user startup records incremented by one {USTCNT}
:
:
:****************************************************************************
:
:
        PROCS(CUSTAR,A.CUCD)
        CHAINS(CUSTSV,A.CUCD)           
        DEBUGM(Entering CUSTAR,DBGSTA,DALL,CUSTSV,A.CUCD)

        LR      R6,R1                   : Get AUB ^ of negative port number
        IFF(L)                          : If negative port number then ...
          XI      R6,-1                 : invert it
          AIS     R6,1                  :
        ORELSE                          : Otherwise it is an AUB ^ so ...
          LHL     R6,AUBPRT,R1,         : get port number from AUBPRT
        ENDIF                           : Port number should now be in R6

        LR      R7,R6                   : Using port # compute port # * 2 for
        SLHLS   R7,1                    : later use as index into login arrays

        L       R3,LGITIM,R7,R7         : Place Greenwich mean login time for
        LI      R4,$A12                 : user in user start up record (fills
                                        : in USPSDA and USPSTI fields
        LA      R5,USPSDA,,             : 
        CALL(DANTIM,CUSTSV)             : 

        LA      R3,USPSDA+2,,           : Place numberic month and day of
        LA      R4,USPSMD,,             : login proceeding invoice #
        LIS     R5,4                    :
        MVS(R3,R4,R5,R2)                :

        LA      R3,USPSDA+2,,           : Also save it for later use
        LA      R4,LGIMND,R7,R7         : 
        LIS     R5,4                    :
        MVS(R3,R4,R5,R2)                :

        L       R3,LGIIVO,R7,R7         : Place invoice number in record
        LIS     R4,$A10                 : 
        LA      R5,USPSES,,             : 
        CALL(BINDEC,CUSTSV)             : 

        LA      R8,USPDIA,,             : Place dialect in record
        LIS     R9,2                    : 
        LA      R10,LGIDIA,R7,          : 
        CALL(BINHXW,CUSTSV)             : 

        LHL     R3,LGIOND,R7,           : Place originating node number in
        LIS     R4,4                    : record
        LA      R5,USPOND,,             : 
        CALL(BINDEC,CUSTSV)             : 

        LHL     R3,LGIOHO,R7,           : Place originating host number in
        LIS     R4,4                    : record
        LA      R5,USPOHO,,             : 
        CALL(BINDEC,CUSTSV)             : 

        LHL     R3,LGIOPR,R7,           : Place originating port number in
        LIS     R4,3                    : record
        LA      R5,USPOPT,,             : 
        CALL(BINDEC,CUSTSV)             : 

        LA      R8,USPTID,,             : Place terminal ID code from needle
        LIS     R9,1                    : in record
        LA      R10,LGITID+1,R7,        : 
        CALL(BINHXW,CUSTSV)             : 

        LR      R1,R1                   : Check if we have an AUB
        IFF(L)                          : If no AUB then ...

          LA      R3,INTLUD+LUDNAM,,    : Get user name from its temporary
          LA      R4,USPUNM,,           : residence at INTLUD avenue and place
          LHI     R5,NC.UNM             : in record
          MVS(R3,R4,R5,R2)              :

          LA      R2,USPTTY,,           : Here we are placing blanks or zeros 
          LIS     R3,4                  : where the agent ID, terminal type and
          LHI     R4,$00B0              : user type would normally been put
          CALL(CLEAR,CUSTSV)            : 
          LI      R3,2                  : 
          LA      R4,USPAID             : 
          SPAC(R4,R3,R2)                : 
          LI      R3,1                  : 
          LA      R4,USPUTY,,           : 
          SPAC(R4,R3,R2)                :

        ORELSE                          : We do have an AUB ...

          LA      R3,AUBUSR,R1,         : Place user name in record
          LA      R4,USPUNM,,           :
          LHI     R5,NC.UNM             : 
          MVS(R3,R4,R5,R2)              :

          LA      R8,USPTTY,,           : Place terminal type in record
          LIS     R9,1                  : 
          LA      R10,AUBTTY,R1,        : 
          CALL(BINHXW,CUSTSV)           : 

          LA      R3,AUBAID,R1,         : Place agent ID in record
          LA      R4,USPAID,,           : 
          LIS     R5,2                  : 
          MVS(R3,R4,R5,R2)              :

          LB      R3,AUBTYP,R1,         : Place user type from AUB in record
          AI      R3,$00C1              : 
          STB     R3,USPUTY,,           : 

        ENDIF                           : 

        LIS     R3,1                    : Increment count of user startup
        AM      R3,USTCNT,,             : records

        LA      R2,USPREC,,             : Call the stats queue loader to load
        LI      R3,USPLNG               : the record in the queue.  Need to
        CALL(STQLDR,CUSTSV)             : pass record address and record length

        RETURN(R1)                      :  Return restoring from R1
	SUBTTL	Control Table Allocation and Assembly Diagnostics   - FINISH.LIB
	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

  IF	ISIS2

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL	HS	1
  EI

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	$A ($0S|Q|SIZE-10000);	REMARK	d bytes;	EI
Q	EQ	Q+1;	ER
	LIST

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
CTA	WC	CNTRL	:CONTROL FLAGS
	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
    IF	\APROT0
	BC	APROT0	:SET AREA 0 PROTECTION
    ELSE
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	BC	6	:EXECUTION PROTECTED
    EI
    IF	\APROT1
	BC	APROT1	:SET AREA ONE PROTECTION
    ELSE
	BC	5	:WRITE PROTECTED
    EI
Q	EQ	2
	RE	0C
    IF	\APROT|Q|
	BC	APROT|Q|
    ELSE
	BC	6	:EXECUTION PROTECTED
    EI
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
	SEG	0E
  EI
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
	SEG	0E
  EI
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols

  ELSE		:ISIS2

:GENERATE DIAGNOSTICS
Q	EQ	0
	RE	0E
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI

:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER

:	BITCH IF ANY SEGMENTS OVERFLOW
Q	EQ	0;	RE	0E;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	$A ($0S|Q|SIZE-10000);	REMARK	d bytes;	EI
Q	EQ	Q+1;	ER

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
	RE	0E
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
	NUMBER	$A S|Q|SIZE
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE!0FF)+1;	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols

  EI		:ISIS2
: (TIGERDEV)SYSGEN.S02
:   Copied by Byrne from (MATS.P2)SYSGEN.01K on 7-Aug-86
:
:
:
	RA	$00A	:RADIX TO DECIAML
:
	REMARK	%%......................................................
	REMARK	%%%%       ****    ALCC    ****
	REMARK	%           Version  
	NUMBER	$8(VERSIO/100)
	REMARK	.
	NUMBER	$8(VERSIO&77)
	REMARK	%%    System host number is  
	NUMBER	HOSTNO
	REMARK	%%    Configured with  
	NUMBER	MAXPRT
	REMARK	  user ports for%                      
	NUMBER	NSPORT
	REMARK	  special ports%                      
	NUMBER	NMON
	REMARK	  Monitors%                      
	NUMBER	NMAG
	REMARK	  MAG's%                     
	NUMBER	MAXUSR
	REMARK	  users
	REMARK	%%    A disconnected user is guaranteed a port for 
	NUMBER	SVPTIM/60
	REMARK	 minutes%    and the user block is held for at least 
	NUMBER	SVATIM/60
	REMARK	 minutes.
	IF	DEBSW
		REMARK	%%    Debug code has been included
	EI
	IF	MULTIA
		REMARK	%%    Multiple IA's for a Res system are supported
	else
		REMARK	%%    Only one IA for a Res system is allowed
	EI
	REMARK	%%    Communications Configuration%%            
	NUMBER	NBUF
	REMARK	 Buffers%          
	NUMBER	NBFLET
	REMARK	 Bufferlets%          
	NUMBER	IRSIZE
	REMARK	 byte Input Ring%          
	NUMBER	ORSIZE
	REMARK	 byte Output Ring
	REMARK	%%               Table Configuration%%
	REMARK	Name   Address  # entries  entry size  table size%
	REMARK	TRCRNG   
	NUMBER	$0 TRCRNG
	REMARK	      
	NUMBER	NTRACE
	REMARK	         
	NUMBER	trclng
	REMARK	        
	NUMBER	NTRACE*TRCLNG
	REMARK	%DEBUG    
	NUMBER	$0 DEBUG
	REMARK	        
	NUMBER	NDEBUG
	REMARK	         
	NUMBER	DEBLNG
	REMARK	         
	NUMBER	NDEBUG*DEBLNG
	REMARK	%R2U      
	NUMBER	$0 R2UTAB
	REMARK	       
	NUMBER	NR2U
	REMARK	          
	NUMBER	R2ULNG
	REMARK	         
	NUMBER	NR2U*R2ULNG
	REMARK	%MAGTAB  
	NUMBER	$0 MAGTAB
	REMARK         
	NUMBER	NMAG
	REMARK	       
	NUMBER	MAGLNG
	REMARK	        
	NUMBER	NMAG*MAGLNG
	REMARK	%RBLOCK  
	NUMBER	$0 RBLOCK
	REMARK	       
	NUMBER	NRBLK
	REMARK	         
	NUMBER	RBLNG
	REMARK	        
	NUMBER	NRBLK*RBLNG
	REMARK	%FRETAB  
	NUMBER	$0 FRETAB
	REMARK	       
	NUMBER	NFRE
	REMARK	         
	NUMBER	FRELNG
	REMARK	        
	NUMBER	NFRE*FRELNG
	REMARK	%AUBLKS  
	NUMBER	$0 AUBLKS
	REMARK	       
	NUMBER	NAUBS
	REMARK	        
	NUMBER	AUBLNG
	REMARK	        
	NUMBER	NAUBS*AUBLNG
	REMARK	%LUD    
	NUMBER	$0 LUD
	REMARK	        
	NUMBER	LUDSIZ
	REMARK	         
	NUMBER	LUTLNG
	REMARK	         
	NUMBER	LUDSIZ*LUTLNG
	REMARK	%AMTTAB  
	NUMBER	$0 AMTTAB
	REMARK	        
	NUMBER	NMON
	REMARK	         
	NUMBER	AMTLNG
	REMARK	         
	NUMBER	NMON*AMTLNG
	REMARK	%%     System requires 
	NUMBER	(QQ+$03FF)/400$A
	REMARK	d K-bytes of core
	REMARK	%%...................................................
 
	RA	0
	end
    /n%