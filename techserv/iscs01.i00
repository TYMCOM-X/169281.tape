	TITLE	CONsolidated tymSAT INITIALIZATION		
	SUBTTL	DESCRIPTION


:    ***   ***  *   *  ****  ***  *     ***** ****    *   ***** ***** ****
:   *   * *   * **  * *     *   * *       *   *   *  * *    *   *     *   *
:   *     *   * * * *  ***  *   * *       *   *   * *****   *   ****  *   *
:   *   * *   * *  **     * *   * *       *   *   * *   *   *   *     *   *
:    ***   ***  *   * ****   ***  ***** ***** ****  *   *   *   ***** ****


:                     ***** *   * *   *  ****   *   *****
:                       *    * *  ** ** *      * *    *
:                       *     *   * * *  ***  *****   *
:                       *     *   *   *     * *   *   *
:                       *     *   *   * ****  *   *   *


:  ***** *   * ***** ***** *****   *   *     ***** *****   *  ***** *****  ***  *   *
:    *   **  *   *     *     *    * *  *       *      *   * *   *     *   *   * **  *
:    *   * * *   *     *     *   ***** *       *     *   *****  *     *   *   * * * *
:    *   *  **   *     *     *   *   * *       *    *    *   *  *     *   *   * *  **
:  ***** *   * *****   *   ***** *   * ***** ***** ***** *   *  *   *****  ***  *   *



:	=================================================================
:	|	This code is the sole property and confidential		|
:	|	information of TYMSHARE,  INC.,  and may not be		|
:	|	copied in whole or  in part or disclosed to any		|
:	|	third party without  the  prior written consent		|
:	|	of TYMSHARE.						|
:	=================================================================



:	SYSGEN CONVENTIONS.

:		All numeric option values are decimal unless otherwise stated.

:		Almost every option has a default value.  Therefore, very few
:	options must actually be specified in the TYM or CON files.
:		The only exception to this are the statements that associate
:	host numbers with port numbers (ACCODE and ACRNG).

:	MACRO NAMING CONVENTIONS.

:		All macros intended for internal use start with ".".


:	RANGING MACROS.

:	There are a number of macros which accept a set of RANGE parameters.
:		The generic form for these macros is:

:			MACRO(A,B,C-D,E,F-G)

:	where A,B and E are single ports selected, and the ranges C through
:		D and F through G are selected.
	SUBTTL	MACROS


: **	ERROR(text,cont)	Output configuration error to local TTY
: **	ERRLIN(text,cont)	Continue an error message on a new line
: **	ERREND(text)		End an error message

:	If text > 51 characters, it should be broken at a convenient place
:	and continued with the ERRLIN macro.

:	Format will be:
:	[CR:LF]>>>> ERROR **** text ****[CR:LF]

:	If cont>0 then message will end with text without a CR:LF
:	Numbers or other special things can be added.

:	ERRLIN(text) will print "..." at the end of the current line, then:
:	[CR:LF]>>>>            text ****[CR:LF]
:	and can be used for continuation lines when cont>0

:	ERREND(text) will add ****[CR:LF] on the current line

ERRCNT	EQ	0	:Number of errors so far

ERROR	MACRO(txt,cont)[
ERRCNT	EQ	ERRCNT+1
	REMARK	%>>>> ERROR **** txt
	IF	cont -1
	ELSE
	 ERREND
	EI
]

ERRLIN	MACRO(txt,cont)[
	REMARK	 ...%>>>>            txt
	IF	cont -1
	ELSE
	 ERREND
	EI
]

ERREND	MACRO(txt)[
	REMARK	txt ****%
]

:	BITCH(MAC,PAR)			This Macro is invoked if macro MAC is
:					invoked --
:					If PAR is false, one message...
:					If PAR is true, insist on setting
:					it in .TYM file, turn off

BITCH	MACRO(MAC,PAR) [
	IF	PAR
	 ERROR( MAC -- PAR MUST be set in .TYM file...turning off,0)
PAR	 EQ	0
	ELSE
	 ERROR( MAC invoked with PAR off...ignored,0)
	EI
]


: **	Define macro for easy defaults
DEFAULT	MACRO(ID,VAL)[
	IF	1-\ID
ID	 EQ	VAL
	EI
]


: **	... and macro for easy globals
GLOBAL	MACRO(ID,VAL)[
	GL	ID
	DEFAULT(ID,VAL)
]


: **	DEFBIT(NAME,NBITS)	Defines symbols NAMEi to be 0, GLOBAL
DEFBIT	MACRO(NAME,NBITS) [
	RA	0
QQ	EQ	(NBITS+1F)/20
	IF	QQ
Q	 EQ	0
	 RE	QQ
	  GL	NAME`|Q|
NAME`|Q|  EQ	0
Q	  EQ	Q+1
	 ER
	EI
]


: **	.RANGE(LABEL,RX,MX,P)	Called to check a range of values

:	P	may be a single # N, a range of #s Ni-Nj with 0=<Ni<Nj,
:		or null
:	RX	is radix of #s N
:	MX	is max value of N (given in radix RX),
:		range is 0 to $0 0FFFFFFFF
:	LABEL	is a label for diagnostics

:	returns QR = 0 if nothing to do,
:	else returns QR = number of itterations..
:			QI = first port to do.

.RANGE	MACRO(LABEL,RX,MX,P)[
Q	EQ	$`RX -(0/P+0)		:FOR P = "Ni-Nj", Q = -(0/Ni-Nj) = Nj
					: else 0
QI	EQ	$`RX Q+(P+0)		:FOR P = "Ni-Nj", Q=Nj, QI = Nj+(Ni-Nj) = Ni
					:FOR P = "Ni", Q=0, QI = Ni
					:FOR P = null,  QI = 0
QQ	EQ	$`RX P $0 100000000	:FOR P = null, QQ = $0100000000
QR	EQ	1
	IF	-QI
QI	 EQ	-QI
QQ	 EQ	$0100000000
	 ERROR(LABEL`: PARAMETER -,1)
	 NUMBER $`RX QI
	 ERREND( NOT POSITIVE)
	EI
	IF	$0 QQ&1FFFFFFFF%100000000	:IF P NOT NULL
	 IF	QI-($`RX`MX)
	  ERROR(LABEL`: PARAMETER ,1)
	  NUMBER $`RX QI
	  REMARK	 GREATER THAN 
	  NUMBER $`RX`MX; ERREND
	  ERREND
QR	  EQ	0
	 EI
	 IF	Q			:IF M NOT NULL
QR	  EQ	Q-QI+1
	  IF	Q-($`RX`MX)
	   ERROR(LABEL`: PARAMETER ,1); NUMBER $`RX Q
	   REMARK	 GREATER THAN ; NUMBER $`RX`MX; ERREND
QR	   EQ	0
	  EI
	  IF	QI-Q
	   ERROR(LABEL`: RANGE ,1); NUMBER $`RX QI
	   REMARK	-; NUMBER $`RX Q; ERREND( BACKWARD)
QR	   EQ	0
	  EI
	 EI
	ELSE
QR	 EQ	0
	EI
	KILL	Q,QQ
]


: **	.SETNM(NAME,VAL)	Called to set range of names to VAL
:			Expects QI and QR to be set to initial number and range.
.SETNM	MACRO(NAME,VALUE) [
	IF	QR
	 RE	QR
	 GLOBAL(NAME`|QI|,VALUE)
QI	 EQ	QI+1
	 ER
	EI
]


: **	.S.RNG(BITS,ST,RG)	Set range of bits in symbolic array
:					BITS starting at ST, range RG.
.S.RNG	MACRO(BITS,ST,RG) [
QI	EQ	ST
QR	EQ	RG
	.S.BIT(BITS)
]


: **	.R.RNG(BITS,ST,RG)	Reset range of bits in symbolic array
:					BITS starting at ST, range RG.
.R.RNG	MACRO(BITS,ST,RG) [
QI	EQ	ST
QR	EQ	RG
	.R.BIT(BITS)
]


: **	.S.BIT(BITS)	Set range of bits in symbolic array BITS
:			Expects QI and QR to be set to initial number
:			and range, respectively.
.S.BIT	MACRO(BITS) [
	IF	QR
	 RE	QR
	.S1BIT(BITS,QI)
QI	 EQ	QI+1
	 ER
	EI
]


: **	.R.BIT(BITS)	Reset range of bits in symbolic array BITS
:			Expects QI and QR to be set to initial number
:			and range, respectively.
.R.BIT	MACRO(BITS) [
	IF	QR
	 RE	QR
	.R1BIT(BITS,QI)
QI	 EQ	QI+1
	 ER
	EI
]


: **	.S1BIT(BITS,POS)	Set bit at POS in symbolic array BITS.
.S1BIT	MACRO(BITS,POS) [
BITS`|POS/20| EQ BITS`|POS/20|!(1^(1F-(1F&POS)))]


: **	.R1BIT(BITS,POS)	Reset bit at POS in symbolic array BITS.
.R1BIT	MACRO(BITS,POS) [
BITS`|POS/20| EQ BITS`|POS/20|&(-1%(1^(1F-(1F&POS))))]


: **	Macro .BIT.(NAME,POS)	Called to locate bit at POS in NAME

.BIT.	MACRO(NAME,POS) [(NAME`|POS/20|^((POS&1F)-1F)&1)]
	SUBTTL	PARAMETERS

:	Set up defaults

	GLOBAL(NAPORT,0)		:number of ASYNC ports
	GLOBAL(NUMPRN,0)		:number of Printers
	GLOBAL(NSPORT,0)		:number of SIO ports
	GLOBAL(NMPVC,0)			:number of Multiplexed PVC ports
	GLOBAL(NHOST,0)			:default number of (real) hosts

:	Force NAPORT to multiple of 16d, bitch if not
	IF	NAPORT&0F
NAPORT	 EQ	((-10)&NAPORT)+10
	 ERROR(NAPORT not multiple of 16 -- forced to ,1)
	 NUMBER	$A NAPORT;	ERREND
	EI

:	Check for specification conflict between PVC and MPVC
	IF	NMPVC
	 GLOBAL(PVC,1)			:Force PVC on for MPVC
	 IF	1-PVC
	  ERROR(PVC disabled when MPVC specified...Forced on,0)
PVC	  EQ	1
	 EI
	ELSE	:NMPVC
	GLOBAL(PVC,0)			:PVC defaults to off
	EI	:NMPVC

:	Compute number of ports, check for conflict
NPORT	EQ	NAPORT+NSPORT+NMPVC
	GL	NPORT
	GLOBAL(MAXPRT,NPORT)
	IF	NPORT-MAXPRT
	 ERROR(MAXPRT less than total ports required,0)
	EI

:	Define first port for each range
	GLOBAL(.SPORT,NAPORT)
	GLOBAL(.MPORT,.SPORT+NSPORT)

:	Initialize various symbolic bit arrays
	DEFBIT(.120T,NAPORT)		:ASYNC ports identified at 120 CPS
	DEFBIT(.2HD,NPORT)		:Bell 202S ports (all ports)
	DEFBIT(.LSA,NPORT)		:Lisa ports (all ports)
	DEFBIT(.BSY,NAPORT)		:Ports which support BUSY-OUT
	.S.RNG(.BSY,0,NAPORT)		:...initially all ASYNC ports
	DEFBIT(.NPI,NPORT)		:ports which DON'T want node-port ID
	.S.RNG(.NPI,.MPORT,NMPVC)	:	Include MPVC ports
	DEFBIT(PVCG,NPORT)		:ports with PVC options
	SUBTTL	PVC PARAMETERS

:	List port attributes.  A mnemonic is provided for each characteristic
:	which may be selected as a function of AID or ALO.  The default option
:	for each parameter is signified by '**'.
AID	EQ	1			:AUTOMATIC TERMINAL IDENTIFICATION
NOAID	EQ	0		:  **	 AID NOT DESIRED
ALO	EQ	1^1			:AUTOMATIC LOGON
NOALO	EQ	0		:  **	 ALO NOT DESIRED
NPI	EQ	0		:  **	 PRINT NODE/PORT IDENTIFIER FOR AID PORT
NONPI	EQ	1^2			:NPI NOT DESIRED
SLO	EQ	1^3			:SUBSEQUENT LOGON TO ALTERNATE HOST FOR ALO PORT
NOSLO	EQ	0		:  **	 SLO NOT DESIRED
PAR	EQ	1^4			:EVEN PARITY
NOPAR	EQ	0		:  **	 MARK PARITY (NORMAL)
PCO	EQ	1^5			:PERMANENT CIRCUIT FOR ALO PORT
NOPCO	EQ	0		:  **	 PCO NOT DESIRED
HNG	EQ	0		:  **	 ALLOW PORT TO BE HUNG BY NETWORK COMMAND
NOHNG	EQ	1^6			:DO NOT ALLOW PORT TO BE HUNG BY NETWORK COMMAND
HDX	EQ	1^7			:TYMNET H-DUX (NO ECHO EXCEPT FOR CR/LF PAIRS)
NOHDX	EQ	0		:  **	 HDX NOT DESIRED
CRLF	EQ	0		:  **	 ECHO LF WITH CR (NORMAL)
NOCRLF	EQ	1^8			:DO NOT ECHO LF WITH CR
LFCR	EQ	0		:  **	 ECHO CR WITH LF (NORMAL)
NOLFCR	EQ	1^9			:DO NOT ECHO CR WITH LF
TRS	EQ	1^0A			:RESET TERMINAL OPTIONS BETWEEN LOGONS
NOTRS	EQ	0		:  **	 DO NOT RESET TERMINAL OPTIONS BETWEEN LOGONS
RBP	EQ	1^0B			:Allow Reverse-Backpressure
NORBP	EQ	0		:  **	 Reverse-Backpressure not allowed
TXT	EQ	0		:  **	 Text-Output permitted
NOTXT	EQ	(1^0C)!NONPI		:Text-output not permitted
DSC	EQ	(1^0D)			:Disconnect on ZAPPER
NODSC	EQ	0		:  **	 No disconnect on ZAPPER
MPC	EQ	(1^0E)			:MPVC Candidate
NOMPC	EQ	0		:  **	 Not a MPVC candidate

:	List TID equivalents - 8 bit TID value is left-justified in 32-bit word.
TS	EQ	$A 24			:TID shift value
TSMASK	EQ	0FF^TS			:TID Mask
NO.A	EQ	400000000		:flag for no ASYNC support
NO.S	EQ	800000000		:flag for no SIO support

:	Define a macro to declare TID constants:
TIDDEF	MACRO(NO,OPT) [EQ (NO^TS)!OPT]

:Mnemonic		Description	    Network TID
TID1	TIDDEF(1,0)	110 baud ASCII		D
TID2	TIDDEF(2,NO.S)	EBCD 2741		P,CR
TID3	TIDDEF(3,NO.S)	CORRESPONDENCE 2741	P,CR
TID4	TIDDEF(4,NO.S)	150 baud ASCII		B
TID5	TIDDEF(5,NO.S)	150 baud ASCII		F
TID6	TIDDEF(6,NO.S)	EBCD 3767		P,CR
TID7	TIDDEF(7,NO.S)	CORRESPONDENCE 3767	P,CR
TID8	TIDDEF(19,0)	50 baud BAUDOT		 -
TID9	TIDDEF(1A,0)	75 baud BAUDOT		 -
TID10	TIDDEF(8,0)	300 baud ASCII		A
TID11	TIDDEF(9,NO.S)	300 baud ASCII		C
TID12	TIDDEF(0A,NO.S)	300 baud ASCII		E
TID13	TIDDEF(0B,NO.S)	300 baud ASCII		G
TID14	TIDDEF(0C,0)	300 baud TRANSACTION
:			 TELEPHONE		Y
TID15	TIDDEF(0D,0)	1200 baud ASCII		A
TID16	TIDDEF(0E,NO.S)	1200 baud ASCII		I
TID17	TIDDEF(0F,NO.S)	1200 baud ASCII		G
TID18	TIDDEF(1B,NO.S)	1200 baud LISA		 -
TID19	TIDDEF(1C,NO.S)	4800 baud LISA		 -
TID20	TIDDEF(10,0)	2400 baud ASCII		A
TID21	TIDDEF(11,0)	4800 baud ASCII		A
TID22	TIDDEF(12,0)	9600 baud ASCII		A
TID23	TIDDEF(13,NO.S)	2400 baud ASCII		I
TID24	TIDDEF(14,NO.S)	4800 baud ASCII		I
TID25	TIDDEF(15,NO.S)	9600 baud ASCII		I
TID26	TIDDEF(16,NO.S)	2400 baud ASCII		G
TID27	TIDDEF(17,NO.S)	4800 baud ASCII		G
TID30	TIDDEF(18,NO.S)	9600 baud ASCII		G
TID31	TIDDEF(1D,NO.S)	75/1200 baud ASCII	 -
	GLOBAL(TIDMAX,20)		:max TID implemented
					:	locked to PVCTID array!!!
TIDSIO	TIDDEF(TIDMAX,0)		:table-bias for SIO
Q	EQ	TIDMAX
	 IF	NSPORT
Q	EQ	Q+TIDMAX
	 EI
TID.MP	TIDDEF(Q,0)	Multiplexed PVC

	KILL	TIDDEF			:won't need this any more
	SUBTTL	PVC MACROS

:	Declare all ports which require PVC service.  The macros PVCRNG and
:	SPVRNG are "RANGING" format.

:	The PVCRNG macro creates 32-bit arrays.  A one bit in the array
:	defines the specified relative port as requiring some kind of PVC
:	service.  The 32-bit arrays are in the form of EQuates, named
:	PVCG0,PVCG1,...  Since a macro supports only up to 16 arguments,
:	the capability exists to declare the macro as many times as
:	necessary to get the desired configuration.  The PVCRNG macro
:	or's each occurance with the identical name, so all names must
:	be previously defined and initialized to 0.

	GL	PVCCNT			:Count of all ports desiring any kind
PVCCNT	EQ	NMPVC			:	of PVC service (init'ed to NMPVC)
	.S.RNG(PVCG,.MPORT,NMPVC)	:default all MPVC ports to PVC


: **	.PVRNG(NAM,RNG,OFF,P)	Internal macro to perform all processing
:				for parameter P in macro NAM, with range
:				RNG, and offset OFF.  Defined to reduce
:				macro storage requirements.

.PVRNG	MACRO(NAM,RNG,OFF,P) [
	.RANGE(NAM,A,RNG,P)
PVCCNT	EQ	PVCCNT+QR
	IF	OFF
QI	 EQ	QI+OFF
	EI
	.S.BIT(PVCG)
]


:	PVCRNG(Rp...)	Declare async PVC ports

PVCRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	 IF	PVC*NAPORT
	.PVRNG(PVCRNG,NAPORT,0,P0)
	.PVRNG(PVCRNG,NAPORT,0,P1)
	.PVRNG(PVCRNG,NAPORT,0,P2)
	.PVRNG(PVCRNG,NAPORT,0,P3)
	.PVRNG(PVCRNG,NAPORT,0,P4)
	.PVRNG(PVCRNG,NAPORT,0,P5)
	.PVRNG(PVCRNG,NAPORT,0,P6)
	.PVRNG(PVCRNG,NAPORT,0,P7)
	.PVRNG(PVCRNG,NAPORT,0,P8)
	.PVRNG(PVCRNG,NAPORT,0,P9)
	.PVRNG(PVCRNG,NAPORT,0,PA)
	.PVRNG(PVCRNG,NAPORT,0,PB)
	.PVRNG(PVCRNG,NAPORT,0,PC)
	.PVRNG(PVCRNG,NAPORT,0,PD)
	.PVRNG(PVCRNG,NAPORT,0,PE)
	.PVRNG(PVCRNG,NAPORT,0,PF)
	 ELSE	PVC
	ERROR(PVCRNG -- NO ASYNC PORTS - IGNORED,0)
	 ELSE
	ERROR(PVCRNG -- NO PVC - IGNORED,0)
	 EI	:PVC*NAPORT
]


:	SPVRNG(Rp...)	Declare SIO PVC ports

SPVRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	 IF	PVC*NSPORT
	.PVRNG(SPVRNG,NSPORT,.SPORT,P0)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P1)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P2)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P3)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P4)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P5)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P6)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P7)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P8)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P9)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PA)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PB)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PC)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PD)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PE)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PF)
	 ELSE	PVC
	ERROR(SPVRNG -- NO SIO PORTS - IGNORED,0)
	 ELSE
	ERROR(SPVRNG -- NO PVC - IGNORED,0)
	 EI	:PVC*NSPORT
]


: **	.PVCDF(...)	Define macro for setting up and checking PVC port values.

.PVCDF	MACRO(NAME,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC) [
Q0	EQ	P0
Q1	EQ	P1
Q2	EQ	P2
Q3	EQ	P3
Q4	EQ	P4
Q5	EQ	P5
Q6	EQ	P6
Q7	EQ	P7
Q8	EQ	P8
Q9	EQ	P9
QA	EQ	PA
QB	EQ	PB
QC	EQ	PC

QV	EQ	Q0!Q1!Q2!Q3!Q4!Q5!Q6!Q7!Q8!Q9!QA!QB!QC

	IF	QV&AID
	 IF	1-(TSMASK&QV)^-TS)
	 ERROR(NAME - AID REQUESTED BUT NO TID SPECIFIED,1)
	 EI
	EI	:QV&AID

	IF	ALO&QV
	 IF	PCO&QV
	  IF	SLO&QV
	   ERROR(NAME - PCO, SLO MUTUALLY EXCLUSIVE OPTIONS,1)
	  EI	:PCO&QV
	 EI	:SLO&QV
	 IF	1-((PCO&QV)!(SLO&QV))
	  ERROR(NAME - ALO SPECIFIED, BUT NO SLO OR PCO,1)
	 EI	:1-((PCO&QV)!(SLO&QV))
	EI	:ALO&QV
]


:	Define macro for setting ASYNC PVC default values.
PVCDF	MACRO(Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC) [
	IF	\PVCDEF
	 ERROR(PVCDF ALREADY DEFINED,0)
	EI	:\PVCDEF
	.PVCDF(PVCDF,Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC)
	IF	QV&NO.A
	 ERROR(PVCDF -- NON-ASYNC TID SPECIFIED - IGNORED,0)
	ELSE
PVCDEF	 EQ	QV
	 GL	PVCDEF
	EI
]


: **	.PXRNG(NAM,RNG,OFF,P,VAL)  Internal macro to perform all processing
:				   for range parameter P in macro NAM, with
:				   range RNG, and offset OFF.  Sets PVCXp
:				   to VAL.  Defined to reduce macro storage
:				   requirements.

.PXRNG	MACRO(NAM,RNG,OFF,P,VAL) [
	.RANGE(NAM,A,RNG,P)
QI	EQ	QI+OFF
	IF	QR
	 RE	QR
	  IF	.BIT.(PVCG,QI)
	  ELSE
	   ERROR(NAM - EXCEPTION DEFINED FOR NON-PVC PORT ,1)
	   NUMBER $A QI-OFF
	   ERRLIN(FORCING THIS PORT TO PVC,0)
	   .S1BIT(PVCG,QI)
PVCCNT	   EQ	PVCCNT+1
	  EI
	  IF	\PVCX|QI|
	   ERROR(NAM - PORT ,1)
	   NUMBER $A QI-OFF
	   ERRLIN( ALREADY DEFINED,0)
	  ELSE
PVCX|QI|   EQ	VAL
	  EI
QI	 EQ	QI+1
	 ER
	EI
]


:	Define PVCEX macro, which specifies exceptions to PVCDF options.
:	The first argument is the exception port number, in decimal.
PVCEX	MACRO(Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC,YD) [
	 IF	PVC*NAPORT
	.PVCDF(PVCEX{Y0},Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC,YD)
	IF	QV&NO.A
	ERROR(PVCEX{Y0} -- TID SPECIFIED IS NOT SUPPORTED - IGNORED,0)
	ELSE
	.PXRNG(PVCEX{Y0},NAPORT,0,Y0,QV)
	EI
	 ELSE	PVC
	ERROR(PVCEX -- NO ASYNC PORTS - IGNORED,0)
	 ELSE
	ERROR(PVCEX -- NO PVC - IGNORED,0)
	 EI
]


:	Define SPVCEX macro, which specifies exceptions to PVCDF options
:	for SIO ports.  The first argument is the exception port number,
:	in decimal.
SPVCEX	MACRO(Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC,YD) [
	 IF	PVC*NSPORT
	.PVCDF(SPVCEX{Y0},Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC,YD)
	IF	QV&NO.S
	ERROR(SPVCEX{Y0} -- TID SPECIFIED IS NOT SUPPORTED - IGNORED,0)
	ELSE
QV	EQ	QV+TIDSIO		:bias range
	.PXRNG(SPVCEX{Y0},NSPORT,.SPORT,Y0,QV)
	EI
	 ELSE	PVC
	ERROR(SPVCEX -- NO SIO PORTS - IGNORED,0)
	 ELSE
	ERROR(SPVCEX -- NO PVC - IGNORED,0)
	 EI
]


	 IF	NMPVC
:	Declare Multiplexed PVC ports.  ALL are identical exceptions!
	.PVCDF(** BUG1 **,TID.MP,AID,NOTXT,ALO,PCO,NOPAR,HDX,NOCRLF,NOLFCR,TRS,NOHNG)
	.PXRNG(** BUG2 **,NMPVC,.MPORT,0-`(NMPVC-1`),QV)
	 EI


:	Define text macros so user may supply text for PVC conditions.  The
:	PTEXT macro is supplied for the user to specify a PVC message number,
:	and the text that the PVC process should use for the message.  If no
:	PTEXT macro is specified for a PVC message, default text is used.
:	The PVC messages and their defaults are:
:	1. CIRCUIT BUILDING IN PROGRESS
:	2. CIRCUIT LOST - REBUILDING
:	3. ALO USER NAME CONFIGURATION ERROR
:	4. ALO PASSWORD CONFIGURATION ERROR
:	5. ALO LOGIN STRING CONFIGURATION ERROR

:	The PTEXT macro call is of the format:
:	PTEXT(<MESSAGE NUMBER>,<MESSAGE TEXT>)

PTEXT	MACRO(Y1,Y2) [
PVCMX`Y1 EQ	1
PTEXT`Y1 MACRO [
	AC	/"8D"8A/
	AC	/Y2/
	AC	/"8D"8A"00/
	]
	]


:	The STEXT macro is supplied for the user to define optional security
:	characters which will be included in the generated user name and
:	password for ports with the ALO option.  The format of the macro
:	call is:

:		STEXT(<CHARS>)

:	Where <CHARS> is a character string of from 1 to 4 characters, which
:	are legaII user name and password values.
:	Defines symbol PVCS0 so PVC code can detect this option.

STEXT	MACRO(Y1) [
PVCS0	EQ	1
STEXT0	MACRO [
	AC	/Y1/
	]
	]

:	The UTEXT macro permits a specific login string (user name and
:	password) may be supplied to be used instead of the generated
:	user name and password.  The format of the macro call is:
:	UTEXT(<CHARS>)
:	Where <CHARS> is any login string.

	GLOBAL(NUTXT,0)
UTEXT	MACRO(Y1) [
UTXM|NUTXT|	MACRO [
	AC	/Y1/
	BC	0
	]
NUTXT	EQ	NUTXT+1
	]


: **	.UTRNG(NAM,RNG,OFF,P)	Internal macro to perform all processing
:				for parameter P in macro NAM, with range
:				RNG, and offset OFF.  Defined to reduce
:				macro storage requirements.

.UTRNG	MACRO(NAM,RNG,OFF,P) [
	.RANGE(NAM,A,RNG,P)
	IF	OFF
QI	 EQ	QI+OFF
	EI
	.SETNM(UTAP,NUTXT-1)
]

:	The UTXRNG macro defines the ports which will use the most recently
:	defined UTEXT login string.  Each parameter is either a single port
:	or a range seperated by a minus sign.  Up to 16 parameters may be
:	specified in each call.  Any PVC ports not listed in any UTXRNG call
:	will default to the standard (computed) username and password.

UTXRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	 IF	PVC*NAPORT
	.UTRNG(UTXRNG,NAPORT,0,P0)
	.UTRNG(UTXRNG,NAPORT,0,P1)
	.UTRNG(UTXRNG,NAPORT,0,P2)
	.UTRNG(UTXRNG,NAPORT,0,P3)
	.UTRNG(UTXRNG,NAPORT,0,P4)
	.UTRNG(UTXRNG,NAPORT,0,P5)
	.UTRNG(UTXRNG,NAPORT,0,P6)
	.UTRNG(UTXRNG,NAPORT,0,P7)
	.UTRNG(UTXRNG,NAPORT,0,P8)
	.UTRNG(UTXRNG,NAPORT,0,P9)
	.UTRNG(UTXRNG,NAPORT,0,PA)
	.UTRNG(UTXRNG,NAPORT,0,PB)
	.UTRNG(UTXRNG,NAPORT,0,PC)
	.UTRNG(UTXRNG,NAPORT,0,PD)
	.UTRNG(UTXRNG,NAPORT,0,PE)
	.UTRNG(UTXRNG,NAPORT,0,PF)
	 ELSE	PVC
	ERROR(UTXRNG -- NO ASYNC PORTS - IGNORED,0)
	 ELSE
	ERROR(UTXRNG -- NO PVC - IGNORED,0)
	 EI
]


:	The SUTXRG macro is like UTXRNG, except it applies to SIO ports.

SUTXRG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	 IF	PVC*NSPORT
	.UTRNG(SUTXRG,NSPORT,.SPORT,P0)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P1)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P2)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P3)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P4)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P5)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P6)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P7)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P8)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P9)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PA)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PB)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PC)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PD)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PE)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PF)
	 ELSE	PVC
	ERROR(SUTXRG -- NO SIO PORTS - IGNORED,0)
	 ELSE
	ERROR(SUTXRG -- NO PVC - IGNORED,0)
	 EI
]


:	The MUTXRG macro is like UTXRNG, except it applies to MPVC ports.

MUTXRG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	 IF	PVC*NMPVC
	.UTRNG(MUTXRG,NMPVC,.MPORT,P0)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P1)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P2)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P3)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P4)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P5)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P6)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P7)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P8)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P9)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PA)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PB)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PC)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PD)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PE)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PF)
	 ELSE	PVC
	ERROR(MUTXRG -- NO MPVC PORTS - IGNORED,0)
	 ELSE
	ERROR(MUTXRG -- NO PVC - IGNORED,0)
	 EI
]


:	The user may define a retry timer value for PCO ports.  If not specified
:	by the user, we will supply a default value of 90 seconds.
	GLOBAL(PCOTRY,$A 90)
	GLOBAL(PCORTY,$A 90)
	SUBTTL	MPVC MACROS

:	First, define a pair of bit arrays to keep track of user-name and
:	format assignments.  We'll SET these bits, and turn them OFF as
:	defined, so we can easily determine if any were left undefined.
	DEFBIT(.MPMU,NMPVC)
	.S.RNG(.MPMU,0,NMPVC)
	DEFBIT(.MPMF,NMPVC)
	.S.RNG(.MPMF,0,NMPVC)

:	Define counter for MPVCUS definitions.
	GL	.NMUS
.NMUS	EQ	-1


: **	The MPVCUS macro is used to specify a MPVC username match string.

:	The MPVCUS macro invocation is of the format:
:	MPVCUS(MPVC port range,<MPVCUS STRING>)

:	Where the MPVC port range defines the context of the MPVCUS STRING.
:	The MPVCUS STRING may contain the following "wild" characters:
:	"|"	Match ANY valid user-name character.  Will not match
:		user-name terminator characters (":", "semi-:", <CR>).
:	"}"	END-OF-MPVCUS!  Encountering this character during the
:		matching process signals successful matching of username,
:		even if entire username has not yet been scanned.  (Also
:		matches user-name terminator characters).

:	Each invocation of the MPVCUS macro causes the creation of a
:	new macro .MMi, i=0, .NMUS...also variables .MMBi, .MMLi

MPVCUS	MACRO(Y1,Y2) [
	IF	NMPVC
	 .RANGE(MPVCUS,A,NMPVC,Y1)
	 .R.BIT(.MPMU,Y1)
	 IF	QR
.NMUS	  EQ	.NMUS+1
.MMB|.NMUS| EQ	QI
.MML|.NMUS| EQ	QI+QR-1
	  GL	.MMB|.NMUS|,.MML|.NMUS|
.MM|.NMUS| MACRO [ AC /Y2/; BC 0 ]
	 EI
	ELSE
	 ERROR(MPVCUS INVOKED WITH NMPVC = 0,0)
	EI
	]


: **	The MPVCFO macro is used to specify a MPVC-port format conventions.

:	The MPVCFO macro invocation is of the format:
:	MPVCFO(MPVC port #,BID,SID,EID,SUC,FAI,IN)

:	Where:
:		MPVC port # -	MPVC port to which this set of format
:					conventions is assigned.
:		BID -		Block-ID...numeric value of a single
:					character used to delimit
:					MPVC-channel blocks.
:		SID -		Signal-ID...Numeric value of a single
:					character used to delimit
:					MPVC-channel signals.
:		EID -		Escape-ID...numeric value of a single
:					character used to escape MPVC-
:					channel data.
:		SUC -		Success-message...form "MPVCx", output on
:					successful MPVC connection.
:		FAI -		Failure-message...form "MPVCx", output on
:					unsuccessful MPVC connection.
:		IN -		Inactivity timeout.

:	Each invocation of the MPVCUS macro causes the creation of a
:	new macro .MMFi, i=port #

:	(here is what the macro does:
:		1.	Verify MPVC usage,
:		2.	Verfiy MPVC port usage,
:		3.	Verfiy MPVC Success-text has already been defined,
:		4.	Verfiy MPVC Failure-text has already been defined,
:		5.	Then define macro .MMF, which in turn:
:			1.	saves text-string for Success if not already done,
:			2.	saves text-string for Failure if not already done,
:			3.	builds a table entry, of form:
:				.MPFn	WC	SUCcess text-string,
:					WC	FAIlure text-string,
:					HC	INactivity timeout,
:					BC	ESCape character,
:					BC	BLock character,
:					BC	SIgnal character.
:			5.	kills various macros.

MPVCFO	MACRO(Y1,BID,SID,EID,SUC,FAI,IN) [
	IF	NMPVC
	 IF	Y1+1-NMPVC
	  ERROR(MPVCFO -- PORT NUMBER Y1 EXCEEDS NMPVC,0)
	 ELSE	\1-SUC`X
	  ERROR(MPVCFO -- SUCCESS TEXT MUST BE DEFINED BEFORE INVOCATION,0)
	 ELSE	\1-FAI`X
	  ERROR(MPVCFO -- FAILURE TEXT MUST BE DEFINED BEFORE INVOCATION,0)
	 ELSE	.BIT.(.MPMF,Y1)
	  .R1BIT(.MPMF,Y1)
.MMF|Y1|  MACRO [
	  IF	SUC`X-1
SUC	   SUC`M
	   KILL	SUC`M
SUC`X	   EQ	1
	  EI	:SUC`X-1
	  IF	FAI`X-1
FAI	   FAI`M
	   KILL	FAI`M
FAI`X	   EQ	1
	  EI	:FAI`X-1
.MPF|Y1|  WC	SUC,FAI
	  HC	IN
	  BC	EID
	  BC	BID
	  BC	SID
	  ]
	 ELSE	:.BIT.(.MPMF,Y1)
	  ERROR(MPVCFO -- MULTIPLE INVOCATION FOR PORT ,1)
	  NUMBER	$A Y1
	  ERREND(`, IGNORED)
	 EI	:.BIT.(.MPMF,Y1)
	ELSE
	 ERROR(MPVCFO INVOKED WITH NMPVC = 0,0)
	EI
	]
	SUBTTL	OTHER MACROS

:	The LTEXT macro allows a user to specify text to be inserted or
:	substituted under pre-defined conditions.

:	The LTEXT macro invocation is of the format:
:	LTEXT(<MESSAGE NAME>,<MESSAGE TEXT>)

:	Where the MESSAGE NAME defines the context of the MESSAGE TEXT.
:	The MESSAGE NAME may not be greater than 5 characters.

:	Currently supported contexts are:
:	1. ULMSG - Text is inserted in front of 'PLEASE LOG IN:' prompt.
:	2. TIDM - Text is substituted for 'PLEASE TYPE YOUR TERMINAL
:		IDENTIFIER' message.

LTEXT	MACRO(Y1,Y2) [
	GL	Y1`X
Y1`X	EQ	2			:Let code know this macro called
Y1`M	MACRO [
	AC	/"0D"0A/
	AC	/Y2/
	BC	0
	]
	]




: **	.SPRNG(NAM,RNG,LABEL,P)	Internal macro to perform all range processing
:				for range parameter P in macro NAM, with valid
:				port range RNG, and bit array LABEL.  Bits are
:				turned ON.  Designed to reduce macro storage
:				requirements.

.SPRNG	MACRO(NAM,RNG,LABEL,P) [
	.RANGE(NAM,A,RNG,P)
	.S.BIT(LABEL)
]




: **	.RPRNG(NAM,RNG,LABEL,P)	Internal macro to perform all range processing
:				for range parameter P in macro NAM, with valid
:				port range RNG, and bit array LABEL.  Bits are
:				turned OFF!  Designed to reduce macro storage
:				requirements.

.RPRNG	MACRO(NAM,RNG,LABEL,P) [
	.RANGE(NAM,A,RNG,P)
	.R.BIT(LABEL)
]


:	TID120(Rp...)	Define async ports which are to receive 120 cps
:			TID message.

TID120	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.SPRNG(TID120,NAPORT,.120T,P0)
	.SPRNG(TID120,NAPORT,.120T,P1)
	.SPRNG(TID120,NAPORT,.120T,P2)
	.SPRNG(TID120,NAPORT,.120T,P3)
	.SPRNG(TID120,NAPORT,.120T,P4)
	.SPRNG(TID120,NAPORT,.120T,P5)
	.SPRNG(TID120,NAPORT,.120T,P6)
	.SPRNG(TID120,NAPORT,.120T,P7)
	.SPRNG(TID120,NAPORT,.120T,P8)
	.SPRNG(TID120,NAPORT,.120T,P9)
	.SPRNG(TID120,NAPORT,.120T,PA)
	.SPRNG(TID120,NAPORT,.120T,PB)
	.SPRNG(TID120,NAPORT,.120T,PC)
	.SPRNG(TID120,NAPORT,.120T,PD)
	.SPRNG(TID120,NAPORT,.120T,PE)
	.SPRNG(TID120,NAPORT,.120T,PF)
]


:	HD202(Rp...)	Define async ports which are to be configured
:			for HD202 half-duplex modems.
	GLOBAL(.2HD,0)			:symbol set to 1 if HD202 invoked

HD202	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
.2HD	EQ	1
	.SPRNG(HD202,NAPORT,.2HD,P0)
	.RPRNG(HD202,NAPORT,.BSY,P0)
	.SPRNG(HD202,NAPORT,.2HD,P1)
	.RPRNG(HD202,NAPORT,.BSY,P1)
	.SPRNG(HD202,NAPORT,.2HD,P2)
	.RPRNG(HD202,NAPORT,.BSY,P2)
	.SPRNG(HD202,NAPORT,.2HD,P3)
	.RPRNG(HD202,NAPORT,.BSY,P3)
	.SPRNG(HD202,NAPORT,.2HD,P4)
	.RPRNG(HD202,NAPORT,.BSY,P4)
	.SPRNG(HD202,NAPORT,.2HD,P5)
	.RPRNG(HD202,NAPORT,.BSY,P5)
	.SPRNG(HD202,NAPORT,.2HD,P6)
	.RPRNG(HD202,NAPORT,.BSY,P6)
	.SPRNG(HD202,NAPORT,.2HD,P7)
	.RPRNG(HD202,NAPORT,.BSY,P7)
	.SPRNG(HD202,NAPORT,.2HD,P8)
	.RPRNG(HD202,NAPORT,.BSY,P8)
	.SPRNG(HD202,NAPORT,.2HD,P9)
	.RPRNG(HD202,NAPORT,.BSY,P9)
	.SPRNG(HD202,NAPORT,.2HD,PA)
	.RPRNG(HD202,NAPORT,.BSY,PA)
	.SPRNG(HD202,NAPORT,.2HD,PB)
	.RPRNG(HD202,NAPORT,.BSY,PB)
	.SPRNG(HD202,NAPORT,.2HD,PC)
	.RPRNG(HD202,NAPORT,.BSY,PC)
	.SPRNG(HD202,NAPORT,.2HD,PD)
	.RPRNG(HD202,NAPORT,.BSY,PD)
	.SPRNG(HD202,NAPORT,.2HD,PE)
	.RPRNG(HD202,NAPORT,.BSY,PE)
	.SPRNG(HD202,NAPORT,.2HD,PF)
	.RPRNG(HD202,NAPORT,.BSY,PF)
]


:	NOBUSY(Rp...)	Define async ports which are NOT to be considered
:			for NOBUSY-OUT control (e.g. non-VADIC modems).

NOBUSY	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.RPRNG(NOBUSY,NAPORT,.BSY,P0)
	.RPRNG(NOBUSY,NAPORT,.BSY,P1)
	.RPRNG(NOBUSY,NAPORT,.BSY,P2)
	.RPRNG(NOBUSY,NAPORT,.BSY,P3)
	.RPRNG(NOBUSY,NAPORT,.BSY,P4)
	.RPRNG(NOBUSY,NAPORT,.BSY,P5)
	.RPRNG(NOBUSY,NAPORT,.BSY,P6)
	.RPRNG(NOBUSY,NAPORT,.BSY,P7)
	.RPRNG(NOBUSY,NAPORT,.BSY,P8)
	.RPRNG(NOBUSY,NAPORT,.BSY,P9)
	.RPRNG(NOBUSY,NAPORT,.BSY,PA)
	.RPRNG(NOBUSY,NAPORT,.BSY,PB)
	.RPRNG(NOBUSY,NAPORT,.BSY,PC)
	.RPRNG(NOBUSY,NAPORT,.BSY,PD)
	.RPRNG(NOBUSY,NAPORT,.BSY,PE)
	.RPRNG(NOBUSY,NAPORT,.BSY,PF)
]




: **	.SSPRG(NAM,RNG,LABEL,P)	Internal macro to perform all range processing
:				for SIO range parameter P in macro NAM, with
:				valid port range RNG, and bit array LABEL.
:				Bits are turned ON.  Designed to reduce macro
:				storage requirements.
.SSPRG	MACRO(NAM,RNG,LABEL,P) [
	.RANGE(NAM,A,RNG,P)
QI	EQ	QI+.SPORT
	.S.BIT(LABEL)
]

	GLOBAL(BAUDY,0)			:turn BAUDY off
	GLOBAL(BAUDA,0)			:turn BAUDA off
	GLOBAL(LISA,0)			:turn LISA off



:	ACHOST(NO)	This macro is used to define another accounting
:			host

ACHOST	MACRO(P1) [
Q	EQ	$A P1
	IF	Q
.AHOST	 EQ	Q!4000
	ELSE
	 ERROR(ACHOST -- INVALID ACCOUNTING HOST NUMBER ,1)
	 NUMBER	$A Q
	 ERREND(!,0)
	EI
]




: **	.AHRNG(NAM,RNG,OFF,P)	Internal macro to perform all processing
:				for parameter P in macro NAM, with range
:				RNG, and offset OFF.  Defined to reduce
:				macro storage requirements.

.AHRNG	MACRO(NAM,RNG,OFF,P) [
	.RANGE(NAM,A,RNG,P)
	IF	OFF
QI	 EQ	QI+OFF
	EI
	.SETNM(.ACH,.AHOST)
]


:	AHRNG(Rp...)	Specify Accounting-host range
AHRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.AHOST
	 .AHRNG(AHRNG,NAPORT,0,P0)
	 .AHRNG(AHRNG,NAPORT,0,P1)
	 .AHRNG(AHRNG,NAPORT,0,P2)
	 .AHRNG(AHRNG,NAPORT,0,P3)
	 .AHRNG(AHRNG,NAPORT,0,P4)
	 .AHRNG(AHRNG,NAPORT,0,P5)
	 .AHRNG(AHRNG,NAPORT,0,P6)
	 .AHRNG(AHRNG,NAPORT,0,P7)
	 .AHRNG(AHRNG,NAPORT,0,P8)
	 .AHRNG(AHRNG,NAPORT,0,P9)
	 .AHRNG(AHRNG,NAPORT,0,PA)
	 .AHRNG(AHRNG,NAPORT,0,PB)
	 .AHRNG(AHRNG,NAPORT,0,PC)
	 .AHRNG(AHRNG,NAPORT,0,PD)
	 .AHRNG(AHRNG,NAPORT,0,PE)
	 .AHRNG(AHRNG,NAPORT,0,PF)
	ELSE
	 ERROR(AHRNG used without previous declaration of ACHOST!,0)
	EI
]


:	SHRNG(Rp...)	Declare SIO ports which are to be assigned to
:				last previous ACHOST specified.

SHRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.AHOST
	 .AHRNG(SHRNG,NSPORT,.SPORT,P0)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P1)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P2)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P3)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P4)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P5)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P6)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P7)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P8)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P9)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PA)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PB)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PC)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PD)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PE)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PF)
	ELSE
	 ERROR(SHRNG used without previous declaration of ACHOST!,0)
	EI
]


:	MHRNG(Rp...)	Declare MPVC ports which are to be assigned to
:				last previous ACHOST specified.

MHRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.AHOST
	 .AHRNG(MHRNG,NMPVC,.MPORT,P0)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P1)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P2)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P3)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P4)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P5)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P6)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P7)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P8)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P9)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PA)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PB)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PC)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PD)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PE)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PF)
	ELSE
	 ERROR(MHRNG used without previous declaration of ACHOST!,0)
	EI
]



:	Defind ACCODE parameters:
:	SPECIAL -	negative
:	USAGE -		has 10000 bit set to determine multiple refs.
SPECIAL	EQ	0FFF008000
PRIVATE	EQ	4000
PUBLIC	EQ	0
FEX	EQ	10100
INWATS	EQ	10200
OUTWATS	EQ	10300

:	ACCODE(NO)	This macro is used to define another accounting
:			code

ACCODE	MACRO(P1,P2,P3,P4) [
Q0	EQ	$A P1
Q1	EQ	$A P2
Q2	EQ	$A P3
Q3	EQ	$A P4
.ACODE	EQ	Q0+Q1+Q2+Q3
	IF	.ACODE
	 IF	.ACODE&0FE0000
	  ERROR(ACCODE -- MULTIPLE USAGE SPECIFIED -- IGNORED,0)
.ACODE	  EQ	.ACODE&0C000
	 EI
	 IF	.ACODE&0FF
	  ERROR(ACCODE -- ILL-DEFINED DEVICE -- IGNORED,0)
.ACODE	  EQ	.ACODE&0FF00
	 EI
	EI
]




: **	.ACRNG(NAM,RNG,OFF,P)	Internal macro to perform all processing
:				for parameter P in macro NAM, with range
:				RNG, and offset OFF.  Defined to reduce
:				macro storage requirements.

.ACRNG	MACRO(NAM,RNG,OFF,P) [
	.RANGE(NAM,A,RNG,P)
	IF	OFF
QI	 EQ	QI+OFF
	EI
	.SETNM(.ACC,.ACODE)
]


:	ACRNG(Rp...)	Declare ASYNC ports which are to be assigned
:				to last previous ACCODE specified.
ACRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.ACODE
	 .ACRNG(ACRNG,NAPORT,0,P0)
	 .ACRNG(ACRNG,NAPORT,0,P1)
	 .ACRNG(ACRNG,NAPORT,0,P2)
	 .ACRNG(ACRNG,NAPORT,0,P3)
	 .ACRNG(ACRNG,NAPORT,0,P4)
	 .ACRNG(ACRNG,NAPORT,0,P5)
	 .ACRNG(ACRNG,NAPORT,0,P6)
	 .ACRNG(ACRNG,NAPORT,0,P7)
	 .ACRNG(ACRNG,NAPORT,0,P8)
	 .ACRNG(ACRNG,NAPORT,0,P9)
	 .ACRNG(ACRNG,NAPORT,0,PA)
	 .ACRNG(ACRNG,NAPORT,0,PB)
	 .ACRNG(ACRNG,NAPORT,0,PC)
	 .ACRNG(ACRNG,NAPORT,0,PD)
	 .ACRNG(ACRNG,NAPORT,0,PE)
	 .ACRNG(ACRNG,NAPORT,0,PF)
	ELSE
	 ERROR(ACRNG used without previous declaration of ACCODE!,0)
	EI
]


:	SCRNG(Rp...)	Declare SIO ports which are to be assigned to
:				last previous ACCODE specified.

SCRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.ACODE
	 .ACRNG(SCRNG,NSPORT,.SPORT,P0)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P1)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P2)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P3)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P4)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P5)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P6)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P7)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P8)
	 .ACRNG(SCRNG,NSPORT,.SPORT,P9)
	 .ACRNG(SCRNG,NSPORT,.SPORT,PA)
	 .ACRNG(SCRNG,NSPORT,.SPORT,PB)
	 .ACRNG(SCRNG,NSPORT,.SPORT,PC)
	 .ACRNG(SCRNG,NSPORT,.SPORT,PD)
	 .ACRNG(SCRNG,NSPORT,.SPORT,PE)
	 .ACRNG(SCRNG,NSPORT,.SPORT,PF)
	ELSE
	 ERROR(SCRNG used without previous declaration of ACCODE!,0)
	EI
]


:	MCRNG(Rp...)	Declare MPVC ports which are to be assigned to
:				last previous ACCODE specified.

MCRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.ACODE
	 .ACRNG(MCRNG,NMPVC,.MPORT,P0)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P1)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P2)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P3)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P4)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P5)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P6)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P7)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P8)
	 .ACRNG(MCRNG,NMPVC,.MPORT,P9)
	 .ACRNG(MCRNG,NMPVC,.MPORT,PA)
	 .ACRNG(MCRNG,NMPVC,.MPORT,PB)
	 .ACRNG(MCRNG,NMPVC,.MPORT,PC)
	 .ACRNG(MCRNG,NMPVC,.MPORT,PD)
	 .ACRNG(MCRNG,NMPVC,.MPORT,PE)
	 .ACRNG(MCRNG,NMPVC,.MPORT,PF)
	ELSE
	 ERROR(MCRNG used without previous declaration of ACCODE!,0)
	EI
]
    ( =o