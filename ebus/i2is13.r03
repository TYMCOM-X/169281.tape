
	SUBTTL	DEFS. . .ISIS DEFINITIONS AND CONFIG ERROR CHECKING

	RA	0

	TITLE	ISIS-II. . . . .VERSION 13.03
	GL	VERSION,IVERNO,IRVLNO
VERSION	EQ	$A 1303			:
IVERNO	EQ	$A 13			:ISIS OS Version Number
IRVLNO	EQ	$A 03			:ISIS OS Revision Level Number

:	=================================================================
:	|                                                               |
:	|           *****  **** *****  ****       ***** *****           |
:	|             *   *       *   *             *     *             |
:	|             *    ***    *    ***  *****   *     *             |
:	|             *       *   *       *         *     *             |
:	|           ***** ****  ***** ****        ***** *****           |
:	|           =========================================           |
:	|                                                               |
: 	|                  PROPRIETARY INFORMATION                     	|
: 	|                                                              	|
: 	|  This  source code listing constitutes the proprietary pro-  	|
: 	|  perty of TYMNET, Incorporated. The recipient, by receiving  	|
: 	|  this program listing, agrees that neither this listing nor  	|
: 	|  the   information  disclosed herein nor any  part  thereof  	|
: 	|  shall be  reproduced or transferred to other documents  or  	|
: 	|  used  or  disclosed to others for manufacturing or for any  	|
: 	|  other   purpose except as specifically authorized in  wri-  	|
:	|  ting by  TYMNET, Incorporated.                              	|
:	|								|
:	=================================================================

:	.......................................................................
:	Kill some symbols used in INIT.NAD file in order to prevent the
:	conflict usage later on in the code.
:	.......................................................................
					:
	KILL	YES,NO,OLD,NEW,BOTH,DISABLE,ENABLE,NORMAL,EXTENDED,ENGINE
	KILL	MINI,MICRO,TSI,PICO,HDLC,MAC1,MAC2,MAC3,MAC5,NULL, AUXCIR
	KILL	SUSPEND,ASYNC,SYNC,SIO,PRINTER,IPI,TBUS,LOAD,NOLOAD,RESET
	KILL	NORESET,NULL,slot.n,ON,OFF,MBOARD,SLOT,DMAMAP
	KILL	BOOTSTRAP,SHARED,EPROT,WPROT
	KILL	PRB,ERLG,ACCT,SYSM,UN2,UTL

   IF  \A.GROUP
NASYNG	EQ   $A ((NASYNG+1)/2)*2	:
	KILL	A.GROUP			:
   EI  (A.GROUP)			:
   IF	M.NCARD				:
Q	EQ	0			:
	RE	M.NCARD			:
	KILL	MBRD|Q|			:
	ER				:
   EI  (M.NCARD)			:

   IF	mxslot				:
    IF .GT.(mxslot,NSLOT)		:
NSLOT	EQ	mxslot			:
    EI (NSLOT)				:
   EI  (mxslot)				:
   KILL	mxslot				:
					:
:	.......................................................................
:	KILL SOME MACROS TO PREVENT CONFLICT OF USAGE
:	.......................................................................
	KILL	A.REF,M.REF,O.REF,S.REF,X.REF,TYMNET,BITCH,SGU.DEF
	KILL	DECLARE,DEFAULT,DMAMAP

SAL	EQ	0			:SET TRUE FOR STAND-ALONE NODE CODE
	GL	SAL

:	DEFINE REGISTER USAGE
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15


:	DEFINE MACRO TO DECLARE DEFAULT	 VALUES
DECLARE	MACRO(ID,V)[
	IF	\ID;	ELSE
ID	EQ	V;	EI
]


:	DEFINE MACRO TO DECLARE DEFAULT (GLOBAL) VALUES
DEFAULT	MACRO(ID,V)[
	DECLARE(ID,V)
	GL	ID
]
:

	DEFAULT(TSIDT,0)		:NO MDCSC DISC/TAPE SERVER

	IF	\FSYS1
FSYS	EQ	FSYS1
	ELSE
FSYS	EQ	0
	EI
	GL	KSYS
	IF	\KSYS1
	 IF	TSIDT
	 REMARK %KSYS is not supported on TSI - cancelled
KSYS	EQ	0
	 ELSE
KSYS	EQ	KSYS1
	 EI
	ELSE
KSYS	EQ	0
	EI

:	.......................................................................
:	ESTABLISH ISIS GENERATION TIME (GMT)
:	.......................................................................
					:
TIMNOW	CURGMT				:GET CURRENT GMT
	GENTIM(TIMNOW)			:COMPUTE DATE & TIME
					:
	RA	0			:
					:
:	.......................................................................
:	DEFINE DEFAULT PARAMETER AND SWITCH VALUES
:	.......................................................................
					:
	GL	MICRO			:
MICRO	EQ	2			:ALWAYS ENHANCED MICRO-CODE
	DEFAULT(PUBNET,0)		:Default to Private Network
	DEFAULT(MACHNM,0)		:NO NODE NUMBER
	DEFAULT(HST0,0)			:NO KERNEL HOST
	DEFAULT(ENGVER,1)		:Default Engine type
	DEFAULT(CPUVER,3)		:Default CPU type - CPU 3
	DEFAULT(MACVER,2)		:Default MAC type - MAC 2
	DEFAULT(SPASIZ,100)		:Default size of system patch area
	DEFAULT(KPASIZ,63)		:Default size of kernel patch area
	DEFAULT(NTDDBG,0)			:ISIS internal debugger flag OFF
        DEFAULT(TBAUDR,1)               :Default to test baudr mismatch
	DEFAULT(KIOSRC,0)		:DEFAULT NO KIO SOURCE
	DEFAULT(KIODES,0)		:DEFAULT NO KIO DESTINATION
	DEFAULT(KBLKMV,0)		:Default no block Kernel I/O 
	GL	NODENM			:
   IF	KIOSRC				:
	DEFAULT(NODENM,0)		:
   ELSE					:
	DEFAULT(NODENM,MACHNM)		:
   EI	(KIOSRC)			:
	DEFAULT(NLU,0)			:NO LOGICAL UNITS
	DEFAULT(TDIAGN,20)		:DEFAULT HISTORY
	DEFAULT(NBLKS,3)		:
	DEFAULT(MSLOT,0)		:DEFAULT NO MONITOR SLOT
	DEFAULT(FSYS,0)			:DEFAULT NO FILE SYSTEM
					:
   IF	FSYS				:
   ELSE
    IF	MSLOT				:
	  REMARK  %MSLOT requires FSYS reference...MSLOT CANCELED
MSLOT	  EQ	0
    EI (MSLOT)				:
   EI  (FSYS)				:
					:
   IF	KSYS				:
	DEFAULT(SCORE1,0)		:STARTING ADDRES FOR KSYS
	DEFAULT(CYL1,GU3|KSYS|)		:
	GL	DSCBOT			:
    IF	GU1|KSYS|%2			:
DSCBOT	EQ	1			:
    ELSE				:
DSCBOT	EQ	0			:
    EI (GU1|KSYS|%2)			:
   EI  (KSYS)				:
	DEFAULT(LOWSPD,0)		:DEFAULT TO NO LOW SPEED ASYNC
	DEFAULT(MEMIO1,0FF78)		:FIRST MEMORY ADDRESS TO SCAN
	DEFAULT(MEMIO2,0FF7F)		:1+LAST MEMORY I/O ADDRESS TO SCAN
	DEFAULT(TIINEW,0)		:
	DEFAULT(FORGND,1)		:Default foreground process is enabled
	DEFAULT(FGFREQ,$A 15)		:CLOCK TICKS BETWEEN FGND EXEC
	DEFAULT(CPUOVL,0)		:DEFAULT IS NO CPU OVERLOAD MEASURES
	DEFAULT(BGMIN,40)		:MINIMUM TIME BETWEEN BG EXEC
	DEFAULT(BGACPT,10)		:NO ERRORS ACCEPTABLE NOW
	DEFAULT(FGACPT,1)		:NO ERRORS ACCEPTABLE NOW
	DEFAULT(NUMHST,$A 64)		:No. of Hosts-non-MXP *17Aug87*
	DEFAULT(EE.BP,0)		:support end-to-end Back-pressure
	DEFAULT(LOG.II,1)		:Dispatcher supports LOG-II 10Aug87
	DEFAULT(SPAM,0)			:DEFAULT IS SPAM TIMING 'OFF' 7/15/87
	DEFAULT(SPMTRC,0)		:DEFAULT IS SPAM TRACE  'OFF' 7/15/87
	DEFAULT(KDWORD,0)		:SPAM XPI WORD CHARA COUNT    7/15/87
        DEFAULT(MACTRC,1)               :DEFAULT FOR MAC TRACE 'ON'
	GL	SPAM,SPMTRC,MACTRC
	DEFAULT(BAUDR,0)		:DEFAULT IS 1200 BAUD
	DEFAULT(WFROG,1)		:DEFAULT Watchfrog timer ON
	DEFAULT(WFTIME,5)		:DEFAULT TO 5 SECOND WATCHFROG
	DEFAULT(ZITEL,0)		:DEFAULT IS ZITEL MEMORY
	DEFAULT(TSIMAC,0)		:DEFAULT NO TSI MAC
	DEFAULT(PICONS,1)		:CONSOL DISPLAY OVERRIDE FOR PICO
	DEFAULT(MACV,0)			:DEFAULT NO MAC 5
   IF	MACV				:
	DEFAULT(MEMSIZ,0)		:
   ELSE					:Default total memory size for non-MAC5
	DEFAULT(MEMSIZ,100000)		:machine is One Megbyte
   EI  (MACV)				:
	DEFAULT(DMAREL,0)		:Default no DMA relocation in MAC-V
	DEFAULT(MULMAC,0)		:DEFAULT NO MULTIPLE MAC SETS
	DEFAULT(NASYNG,0)		:NO ASYNC
	DEFAULT(ASYNEW,2)		:default new driver
   if 1-\newarn				:require old async ring structure
	if nasyng			:users to specify the case -- solves
	  default(newarn,1)		:problems where ASYNCBOARD macro is
	ei				:not invoked and async is specified
   ei					:
	DEFAULT(NEWARN,0)		:Default no new Async ring structure
	DEFAULT(NETMON,0)		:DEFAULT NO SUP CHANNEL CONTROL
	DECLARE(SYSDEV,0)		:DEFAULT IS NO SYSTEM DEVICE
	DEFAULT(SYSMON,0)		:DEFAULT MODE IS NO STATISTICS
	DEFAULT(DB.FLG,0)		:DEFAULT MODE IS NOT DEBUG!!
	DEFAULT(AS.IS.,0)		:DEFAULT USAGE IS TURN OFF UNASSIGNED DEVICES
	DEFAULT(LBOOT,1)		:DEFAULT IS LOW CORE BOOT
	DEFAULT(ENGINE,1)		:DEFAULT MACHINE IS ENGINE!
   IF	1-ENGINE			:
	REMARK	%%ISIS NOT SUPPORTED ON INTERDATA!!
	ENGINE	EQ	1		:
   EI  (1-ENGINE)			:
	DEFAULT(N.ADA,0)		:SWITCH NEW ASYNC DEVICE ADDRESSES OFF!
	DEFAULT(SIOINC,0)		:MORE FREQ. SIO-DEVICE-STATUS POLLING
	DEFAULT(ESYNCI,1)		:SWITCH ENHANCED SYNC INTERRUPTS TO BEST STATE
	DEFAULT(ESYNC,1)		:SWITCH ENHANCED SYNC INSTRUCTIONS ON OR OFF
	DEFAULT(M.NCARD,0)		:SWITCH MOTHER-CARD OFF!
	DEFAULT(SYSDBG,0)		:SWITCH NEW DEBUGGER ON!
	DEFAULT(SUP,0)			:NO SUP
	DEFAULT(MULTI,0)		:
   IF	SUP				:
	DEFAULT(S.Q1,$0 1E)		:SUP     DEFAULT BKGND EXEC QUANTUM
	DEFAULT(S.Q2,$0 1E)		:PROBE   DEFAULT BKGND EXEC QUANTUM
	DEFAULT(S.Q3,$0 1E)		:ERR LOG DEFAULT BKGND EXEC QUANTUM
	DEFAULT(S.Q4,$0 1E)		:ACCT    DEFAULT BKGND EXEC QUANTUM
	DEFAULT(S.Q5,$0 1E)		:SYS MSG DEFAULT BKGND EXEC QUANTUM
	DEFAULT(S.Q6,$0 1E)		:UN2     DEFAULT BKGND EXEC QUANTUM
	DEFAULT(S.Q7,$0 1E)		:UTILITY DEFAULT BKGND EXEC QUANTUM
   EI  (SUP)				:
					:
  IF	SPAM				:
	RA	$A 10			:Set radix to decimal
   IF	SUP				:
Q	EQ	0			:
	RE	NSLOT+9
	GL	P.N|Q|
    IF	1-\P.N|Q|
P.N|Q|	EQ	0
    EI
Q	EQ	Q+1
	ER
   ELSE
Q	EQ	0
	RE	NSLOT+2
	GL	P.N|Q|
    IF	1-\P.N|Q|
P.N|Q|	EQ	0
    EI
Q	EQ	Q+1
	ER
   EI  (SUP)				:
  EI   (SPAM)				:
	RA	0			:Set radix to hexdecimal
	IF	\BAUDRS			:WAS BAUDR SET BY MACRO
	ELSE
	BAUD()				:CALL BAUD MACRO FOR RANGE CHECK
	EI
	IF	BAUDR*MSCDSK
	REMARK  %HIGH SPEED ASYNC AND MSC DISK ARE INCOMPATABLE...BAUDR CANCELLED!
BAUDR	EQ	0
	EI
	IF	BAUDR
	IF	NASYNG-4
	REMARK  %NO MORE THAN 4 GROUPS ALLOWED AT HIGH SPEED..NASYNG SET TO 4
NASYNG	EQ	4
	EI
	EI
	DEFAULT(NPRINT,0)		:NO PRINTER
	DEFAULT(XSELCH,0)		:NO EXTRA SELECTOR CHANNEL
	DEFAULT(XSYNC,0)		:NO EXTRA SYNC CARD
	DEFAULT(SBUS,0)			:DEFAULT TO NO SPIRIT BUS
	DEFAULT(SBSLOT,-1)		:DEFAULT SPIRIT BUS SLOT
	DEFAULT(SBLU,-1)		:DEFAULT SPIRIT BUS L.U.
	DEFAULT(STRACE,1)		:DEFAULT S-BUS TRACE ON

	DEFAULT(MACHIN,1)		:DEFAULT TO ENGINE
	DEFAULT(HMICRO,0)		:DEFAULT HMICRO OFF
	DEFAULT(NANO,0)			:DEFAULT NANO OFF
	DEFAULT(PXL,0)			:DEFAULT PXL OFF
	DEFAULT(PSPORT,0)		:NO OF POSSIBLE PORTS
	DEFAULT(TSI,0)			:DEFAULT TSI OFF
   if	tsi!nano
	default(totsiz,$a960)		:allows for 64k spirt bus window
   else
	default(totsiz,$a1024)
   ei	(tsi!nano)
	DEFAULT(SPIXPI,0)		:XPI EMUL. SPIRIT BUS
	DEFAULT(NCV530,0)		:NODE CODE VRS. 530 (OFF)
	DEFAULT(NPADS,$A 256)		:SYNC PAD COUNT

	IF	MACHIN-5
	 REMARK	%MACHIN is out of range...SET TO 1%
	ELSE	MACHIN-4		
PXL	EQ	1			:MACHIN=5 IS PXL
	ELSE	MACHIN-3		:
NANO	EQ	1			:MACHIN=4 IS NANO
	ELSE	MACHIN-2
TSI	 EQ	1			:MACHIN=3 IS TSI
	ELSE	MACHIN-1
HMICRO	 EQ	1			:MACHIN=2 IS HDLC MICRO
	ELSE	MACHIN
	ELSE
	 REMARK %MACHIN switch is off...SET TO 1%
	EI

   IF	TSI!NANO
MACTRC	EQ	0			:TURN MAC TRACE 'OFF'
   EI  (TSI!NANO)

   IF	TSI!NANO
TSIMAC	EQ	1			:TURN ON TSI MAC
   EI  (TSI!NANO)

   IF	TSI!NANO!MACV
ZITEL	EQ	0			:INSURE ZITEL IS OFF
   EI

MULMAC	EQ	ZITEL!MACV!TSIMAC	:THESE SUPPORT MULTIPLE MAC SETS

   IF	HMICRO!TSI!NANO
	DEFAULT(HTEST,1)
ESYNC	EQ	1			:HMICRO AND TSI NEED ENHANCED SYNC
ESYNCI	EQ	1
   EI  (HMICRO!TSI!NANO)

	DEFAULT(NSYNC,0)		:NUMBER OF SYNC LINES
	DEFAULT(DI.TRC,0)		:DISPATCHER CHARACTER TRACE TURNED OFF
	DEFAULT(MXPNM,-1)		:NOT MXP

	IF	SUP
	 LO	SUPER
	 IF	NASYNG*(SUPMIC-1)
	 FO	SUPER
	  REMARK	%ASYNC and SUPERVISOR MICROCODE not compatable...
	  REMARK	NASYNG CANCELED%
NASYNG	  EQ	0
	 EI
	EI	(SUP)

	GL	DISPAT,MXP,ENHMXP
DISPAT	EQ	NSLOT			:DISPATCHER PRESENT SWITCH
MXP	EQ	0			:MXP NOT ENABLED
	IF	MXPNM
DISPAT	EQ	0			:MAKE DISPATCHER GO AWAY
MXP	EQ	1			:MAKE MXP BE
	GL	SLTXMI,NMACH
	IF	MXPNM-NMACH
	REMARK	%The MXP machine number, MXPNM, must be .LE. the total
	REMARK	%number of machines in the cluster, NMACH.
	EI
	DEFAULT(ENHMXP,0)		:SWITCH OUT VERSION 3.00 AND LATER OF MXP XPI MEMORY IMAGE
	DEFAULT(XPIAD,88)		:XPI DEVICE ADDR
	DEFAULT(XPITMO,0A)		:XPI TIMEOUT TIME
	DEFAULT(XPIBUG,0)		:XPI DEBUG MODE SWITCH
	DEFAULT(XPISAV,0)		:XPI SAVE STATE SWITCH
	DEFAULT(KREXL,50+NSLOT*40)	:KDIO ENG-TO-XPI RING LENGTH
	DEFAULT(KRXEL,30+NSLOT*20)	:KDIO XPI-TO-ENG RING LENGTH
	ELSE
ENHMXP	EQ	0			:1 ONLY IF MXP AND DEFINED IN TYMFILE
	EI

	IF	\IPINUM
	DEFAULT(IPNMBR,IPINUM)
	ELSE
	DEFAULT(IPNMBR,0)
	EI
	IF	IPNMBR
	GL	IPICRA
	IF	MXP	
IPIADR	 EQ	89
	ELSE
IPIADR	 EQ	88
	EI
Q	EQ	0
	RE	IPNMBR
	DEFAULT(IPIAD|Q|,IPIADR+Q)
Q	EQ	Q+1
	ER
	EI	(IPNMBR)
	IF	IPNMBR
Q	EQ	0
	RE	IPNMBR
	IF	\IPDLC|Q|
	DEFAULT(SLTIP|Q|,IPDLC|Q|)
	ELSE
	DEFAULT(SLTIP|Q|,-1)
	EI
	IF	\IPRES|Q|
	DEFAULT(IPRST|Q|,IPRES|Q|)
	ELSE
	DEFAULT(IPRST|Q|,-1)
	EI
	IF	\IPGMB|Q|
	DEFAULT(GMBUG|Q|,IPGMB|Q|)
	ELSE
	DEFAULT(GMBUG|Q|,-1)
	EI
Q	EQ	Q+1
	ER
	EI (IPNMBR)


:	GENERATE DEFAULTS FOR HDLC MICRO-ENGINE, TSI AND NANO

	IF	HMICRO
	 IF	NSYNC-$00A
	 REMARK	%HDLC MICRO-ENGINE supports a maximum of 10d sync lines...
	 REMARK	NSYNC REDUCED TO 10d
NSYNC	 EQ	$00A
	 EI
	EI	(HMICRO)

	IF	NANO
	 IF	NSYNC-8
	 REMARK	%NANO supports a maximum of 8 sync lines...
	 REMARK	NSYNC REDUCED TO 8
NSYNC	 EQ	8
	 EI
	EI	(NANO)

	IF	TSI
	 IF	NSYNC-4
	 REMARK	%TSI supports a maximum of 4 sync lines...
	 REMARK	NSYNC REDUCED TO 4
NSYNC	 EQ	4
	 EI
	EI	(TSI)

	IF	NANO
PSPORT	EQ	8
	ELSE 	TSI
PSPORT	EQ	4
	ELSE	HMICRO
PSPORT	EQ	$A 10
	ELSE
PSPORT	EQ	NSYNC
	EI

	IF	HMICRO!TSI!NANO
	 IF	M.NCARD
	 ELSE
M.NCARD	 EQ	1			:MAX 1 MOTHER BOARD
	 EI
	 DEFAULT(M.NP0,0)		:START WITH SIO
M.NP0	 EQ 	NSYNC+M.NP0		:ADD IN EMULATED SYNC
	 DEFAULT(M.DA0,80)		:DEVICE ADDRESS IS 80x

	 IF	M.NCARD-1
	 IF	HMICRO
	  REMARK	%HDLC MICRO-ENGINE supports a maximum of 1 mother board...
	 EI	(HMICRO)
	 IF	TSI!NANO
	  REMARK	%TSI&NANO supports a maximum of 1 mother board...
	 EI	(TSI!NANO)
	 REMARK	M.NCARD REDUCED TO 1
M.NCARD	 EQ	1
	 EI

	 IF	HMICRO
	 IF	M.NP0-0E
	 REMARK	%HDLC MICRO-ENGINE supports a maximum of 14d channels...
	 REMARK	NSYNC+M.NP0 REDUCED TO 14d
M.NP0	 EQ	0E
	 EI
	 EI	(HMICRO)

	 IF	NANO
	 IF	M.NP0-8
	 REMARK	%NANO supports a maximum of 8 channels...
	 REMARK	NSYNC+M.NP0 REDUCED TO 8
M.NP0	 EQ	8
	 EI
	 EI	(NANO)

	 IF	TSI
	 IF	M.NP0-4
	 REMARK	%TSI supports a maximum of 4 channels...
	 REMARK	NSYNC+M.NP0 REDUCED TO 4
M.NP0	 EQ	4
	 EI
	 EI	(TSI)

	 IF	.NE.(M.DA0,80)
	 IF	HMICRO
	 REMARK	%HDLC MICRO-ENGINE only supports mother board at device 80x...
	 EI	(HMICRO)
	 IF	TSI!NANO
	 REMARK	%TSI&NANO only supports mother board at device 80x...
	 EI	(TSI!NANO)
	 REMARK	M.DA0 SET TO 80x
M.DA0	 EQ	80
	 EI
	EI	(HMICRO!TSI!NANO)


	IF	TSIDT&SUP
Q	EQ	NSLOT+1
	RE	7
	DEFAULT(TSIT|Q|,0)
	DEFAULT(TSIC|Q|,0)
Q	EQ	Q+1
	ER
	EI	(TSIDT&SUP)

   IF	KIOSRC				:
        GL      SDISIZ,SDOSIZ,SDIEND,SDOEND,SDRDEV,SDMBLU,MLUTBL
	GL      MBLSTR,GETCTL,PUTCTL,SKOFRG,SNEWRG,SKCTLI,SKCTLO
	GL	SRCDSC
	DEFAULT(MLUSW,0)		:DEFAULT NO M-BOARDS
	DEFAULT(SLUSW,0)		:DEFAULT NO USER RINGS
    IF	KIODES				:
	GL	DKOFRG,DNEWRG,DKCTLI,DKCTLO,DESDSC
    EI (KIODES)				:
   EI  (KIOSRC)				:
					:



:	....................................................................
:	CONSTANTS USED FOR ADDRESS AND MAC REGISTER MANIPULATION
:	....................................................................
					:
	GL	MACREG,MACDIS,MACPAG,MACSTR,MACSIZ,MACPRS,MASK1,MASK3
	GL	MASK6,MASK8,MASK9,MASKB,MASKE,MASKF,PAGE,CTASEG, ISEG
	GL	SEGSIZ,SEGPAG,MSHFTV,MSHFTA,MSHFTP,MSHFTL,MSHFTB
	GL	MMASKP,MMASKL,MMASKR,MSHFTX,MMASKS
					:
MACREG	EQ	$A 16			:MAC REGISTERS IN A SET
MACDIS	EQ	3E			:COPY POINTER DISPLACEMENT
CTASEG	EQ	$A 14			:CTA SEGEMENT
ISEG	EQ	$A 15			:SHARED ISIS SEGMENT
					:
   IF	MACV				:
SEGSIZ	EQ	100000			:SEGMENT SIZE IN BYTES
PAGE	EQ	400			:PAGE SIZE IN BYTES
MACPAG	EQ	$A 10			:SHIFT PLACES FOR PAGE
MACSTR	EQ	0FFFFFC00		:MAC REG START ADDR MASK
MACSIZ	EQ	0FFC00			:MAC SEG SIZE MASK
MACPRS	EQ	0FFF1			:MAC REG PRESENCE BIT MASK
MSHFTA	EQ	4			:ADDR ADJUSTMENT IN MAC REG
MSHFTB	EQ	0A			:SHIFT FOR LEN IN PAGES TO BYTES
MSHFTL	EQ	4			:SHIFT FOR LEN PLACEMENT
MSHFTP	EQ	0			:SHIFT PLACES FOR PROT
MSHFTS	EQ	-6			:SHIFT PLACES FOR SEG LEN
MSHFTV	EQ	14			:SHIFT PLACES FOR SEG TO ADDR
MSHFTX	EQ	4			:SHIFT PLACES TO RIGHT JUST SEG #
MMASKL	EQ	3FF0			:LENGTH MASK
MMASKP	EQ	0F			:PROTECTION MASK
MMASKR	EQ	0FFFFC000		:BASE PAGE MASK
MMASKS	EQ	0F0			:SEGMENT MASK
MASK1	EQ	1			:PROTECTION MASKS
MASK3	EQ	3			:
MASK6	EQ	6			:
MASK8	EQ	8			:
MASK9	EQ	9			:
MASKB	EQ	0B			:
MASKE	EQ	0E			:
MASKF	EQ	0F			:
   ELSE	TSIMAC				:
SEGSIZ	EQ	10000			:SEGMENT SIZE IN BYTES
PAGE	EQ	400			:PAGE SIZE IN BYTES
MACPAG	EQ	$A 10			:SHIFT PLACES FOR PAGE
MACSTR	EQ	0FFFFFC00		:MAC REG START ADDR MASK
MACSIZ	EQ	0FC00			:MAC SEG SIZE MASK
MACPRS	EQ	0FFF1			:MAC REG PRESENCE BIT MASK
MSHFTA	EQ	0			:ADDR ADJUSTMENT IN MAC REG
MSHFTB	EQ	0A			:SHIFT FOR LEN IN PAGES TO BYTES
MSHFTL	EQ	4			:SHIFT FOR LEN PLACEMENT
MSHFTP	EQ	0			:SHIFT PLACES FOR PROT
MSHFTS	EQ	-6			:SHIFT PLACES FOR SEG LEN
MSHFTV	EQ	10			:SHIFT PLACES FOR SEG TO ADDR
MSHFTX	EQ	0			:SHIFT PLACES TO RIGHT JUST SEG #
MMASKL	EQ	3F0			:LENGTH MASK
MMASKP	EQ	0F			:PROTECTION MASK
MMASKR	EQ	0FFFFFC00		:BASE PAGE MASK
MMASKS	EQ	0F			:SEGMENT MASK
MASK1	EQ	1			:PROTECTION MASKS
MASK3	EQ	3			:
MASK6	EQ	6			:
MASK8	EQ	8			:
MASK9	EQ	9			:
MASKB	EQ	0B			:
MASKE	EQ	0E			:
MASKF	EQ	0F			:
   ELSE					:
SEGSIZ	EQ	10000			:SEGMENT SIZE IN BYTES
PAGE	EQ	100			:PAGE SIZE IN BYTES
MACPAG	EQ	8			:SHIFT PLACES FOR PAGE
MACSTR	EQ	0FFF00			:MAC REG START ADDR MASK
MACSIZ	EQ	0FF00			:MAC SEG SIZE MASK
MACPRS	EQ	0FF10			:MAC REG PRESENCE BIT MASK
MSHFTA	EQ	0			:ADDR ADJUSTMENT IN MAC REG
MSHFTB	EQ	8			:SHIFT FOR LEN IN PAGE TO BYTE
MSHFTL	EQ	14			:SHIFT FOR LEN PLACEMENT
MSHFTS	EQ	0C			:SHIFT PLACES FOR SEG LEN
MSHFTP	EQ	4			:SHIFT PLACES FOR PROT
MSHFTV	EQ	10			:SHIFT PLACES FOR SEG TO ADDR
MSHFTX	EQ	0			:SHIFT PLACES TO RIGHT JUST SEG #
MMASKL	EQ	0FF00000		:LENGTH MASK
MMASKP	EQ	0F0			:PROTECTION MASK
MMASKR	EQ	0FFF00			:BASE PAGE MASK
MMASKS	EQ	0F			:SEGMENT MASK
MASK1	EQ	10			:PROTECTION MASKS
MASK3	EQ	30			:
MASK6	EQ	60			:
MASK8	EQ	80			:
MASK9	EQ	90			:
MASKB	EQ	0B0			:
MASKE	EQ	0E0			:
MASKF	EQ	0F0			:
   EI  (MACV)				:
					:
SEGPAG	EQ	SEGSIZ/PAGE		:PAGES PER SEGMENT
					:
:	.......................................................................
:	Discount the DMA segment size from real core memory allocation
:	.......................................................................
					:
  IF	MACV				:
X	EQ	$A 0
	RE	NSLOT+1
   IF  \S|$AX|CORE
    IF \DMSZ|$AX|
S|$AX|CORE	EQ	S|$AX|CORE-DMSZ|$AX|
    EI (DMSZ|X|)
   EI  (S|X|CORE)
X	EQ	$A X+1
	ER				:
  EI   (MACV)				:
					:
:	....................................................................
:	GENERATE A BIT ARRAY OF SLOTS WHICH WILL HAVE DISMISS-DRIVEN
:	WATCH FROG TIMERS.  THE SLOTS ARE DESIGNATED IN THE TYM FILE.
:	....................................................................
					:
 IF	WFROG				:Only if Watchfrog timer is enabled
QZ	EQ	0			:
	RE	NSLOT+1
  IF	\S|QZ|FRG
   IF	 S|QZ|FRG
    IF	\HI.FRG
    ELSE
	GL	HI.FRG,LO.FRG
HI.FRG	EQ	0
LO.FRG	EQ	0
    EI
    IF	(QZ-$A31)
LO.FRG	EQ	LO.FRG+(1^($A64-QZ-1))
    ELSE
HI.FRG	EQ	HI.FRG+(1^($A32-QZ-1))
    EI
   EI
  EI
QZ	EQ	QZ+1
	ER				:
					:
  IF	\HI.FRG				:
   IF	.EQ.((HI.FRG!LO.FRG),0)		:
	KILL	HI.FRG,LO.FRG		:
   EI  (HI.FRG!LO.FRG)			:
  EI   (\HI.FRG)			:
					:
 EI    (WFROG)				:

	GL	NSYNC,NLU,NSLOT,ACCESS,RPSW,AS.CTL,AS.LCT,AS.RNG,AS.ERN
   IF	NSYNC
	GL	SPORT,ISYNC
   EI  (NSYNC)
	GL	SYNCL,NSYNCL
	GL	SLICE,ILPSD,MMOPSD,MMPSD,RELPSW,SVCPSW,SVCVEC,ACSLOT
	GL	IMIVEC,SYNVEC,CLKVEC,TTYINIT,RNSLOT,SSSLOT
	GL	RATE,RDIV,NRATE,FASTC,SLOWC,GMT,WWVBT
	GL	DC.IRA,DSLOT,DHANG,SCRASH,CT.SLT,DC.SLT,SS.SLT,RS.SLT
	GL	FLASH,FLASHC,SLOWT,DISPLAY,TEMPER,SLTINF
	GL	KTOUT,KMANUAL,KINIT,MINIT
	GL	MACAREA,MACSTAT

:	....................................................................
:	DEFINE MACRO TO GENERATE A MAC VALUE
:	SIZ	SIZE OF MAC AREA (BYTES)
:	START	START OF MAC AREA (BYTE ADDRESS)
:	PROT	PROTECTION TO USE
:	....................................................................
					:
MACVAL	MACRO(SIZ,START,PROT)	[((START&MACSTR)^MSHFTA)!(((SIZ-1)&MACSIZ)^MSHFTS)!((PROT&0F)^MSHFTP)!MASK1]
					:
:	....................................................................
:	DEFINE MAC-DEFINITION MACRO
:	ID	SYMBOL TO DEFINE
:	SIZ	SIZE OF MAC AREA (BYTES)
:	START	START OF MAC AREA (BYTE ADDRESS)
:	PROT	PROTECTION TO USE
:	....................................................................
					:
MACDEF	MACRO(ID,SIZ,START,PROT) [
	GL	ID
ID	EQ	MACVAL(SIZ,START,PROT)
]					:
					:
:	....................................................................
:	DEFINE MACRO TO GENERATE FIRST LINE DIAGNOSTIC
:	....................................................................
					:
BITCH1	MACRO(S,L)[
	REMARK	%SLOT 
	NUMBER	$A S
	REMARK	, L.U. 
	NUMBER	$A L
]					:
					:
:	....................................................................
:	DEFINE MACRO TO GENERATE SECOND LINE DIAGNOSTIC
:	....................................................................
					:
BITCH2	MACRO(N)[
	NUMBER	N
	REMARK	...CANCELED
]					:
					:
:	....................................................................
:	SVC TYPE DESIGNATORS
:	....................................................................
					:
	GL	DISMISS,FAST,TICDIS,SYS,CIO,QIO,CLIN,CLOUT,FLOUT,IN,OUT,KIO
DISMISS	EQ	0			:DISMISS SVC
FAST	EQ	1			:FAST DISMISS
SYS	EQ	2			:SYSTEM CALLS
CIO	EQ	3			:CONNECT I/O
QIO	EQ	4			:QUEUED I/O (ESELCH DEVICES)
TICDIS	EQ	7			:Dismiss SVC  (in ticks)
CLIN	EQ	00			:CONNECT LOGICAL INPUT
CLOUT	EQ	10			:CONNECT LOGICAL OUTPUT
FLOUT	EQ	20			:FORCE LOGICAL OUTPUT
   IF	NASYNG				:
	GL	CLASYN			:
CLASYN	EQ	30			:CONNECT LOGICAL ASYNC
   EI  (NASYNG)				:
   IF	NPRINT				:
	GL	CPRINT,FPRINT		:
CPRINT	EQ	40			:CONNECT PRINTER
FPRINT	EQ	50			:FORCE PRINTER CONNECTION
   EI  (NPRINT)				:
IN	EQ	$0 0A			:TTY INPUT
OUT	EQ	$0 0B			:TTY OUTPUT
KIO	EQ	$0 0D			:KERNEL-I/O REQUESTS
					:
	IF	SUP

	SUBTTL	DEFINE SUP CORE LAYOUTS, ETC

	MO	.,SUPDEF

	GL	SCMAC
SMACK	MACRO(A,B) [((A-1)^MSHFTL)!(B^(MSHFTB+MSHFTA))]	:MACRO TO MAKE MAC FORMAT

:	....................................................................
:
:		SUPERVISOR CORE LAYOUT
:		======================
:		-----------------	___
:		|			 ^
:		|	AREA 2 (CODE)	 |
:		|			 | SUPA2
:	SUPA2B-	-----------------	---
:		|	AREA 1 (NODE COMMUNICATIONS)
:		|
:	SUPA1B-	-----------------
:		|
:		|
:		+
:		|			___	___
:		|			 ^	 ^
:		+			 |	 | SCA2S
:		|			 |	 |
:		|			 | SUPA0 |
:		+	AREA 0 (DATA)	 |	 |
:		|			 |	 |	(COMMON AREAS)
:		|			 |	 |
:		+			 |	 |
:		|			 |	 |
:		|			 | SCA2O___
:		+			 |	 ^ SCA1S
:		|			 | SCA1O___
:		|			 |
:	0---	-----------------	---
:
:	....................................................................
					:
					:
:	....................................................................
:	REDEFINE "SUP" AS NUMBER OF SIMULTANEOUS PORTS
:	....................................................................
					:
SUP	EQ	SUPNP+SUPNER+SUPNAC+SUPNSY+SUPNUN+NCSS
					:
:	....................................................................
:	NOW DEFINE SUPERVISOR AND RELATED MEMORY LAYOUT, ASSOCIATED MACS
:	....................................................................
					:
V	EQ	0			:RELATIVE CORE ADDRESS (PAGES)
SA0SEG	EQ  (SUPA1B+(SEGPAG-1))/SEGPAG 	:NUMBER OF SUP AREA 0 SEGMENTS
SA2SEG	EQ  (SUPA2+(SEGPAG-1))/SEGPAG 	:NUMBER OF SUP AREA 2 SEGMENTS
SC2SEG	EQ  (SUPA1B-SCA2O+(SEGPAG-1))/SEGPAG :NUMBER OF SUP CMN AREA 2 SEGMS
					:
   IF	1-\SCSIZ			:
SCSIZ	EQ	1200			:SIZE OF COMMON AREA
   EI  (1-\SCSIZ)			:
					:
:	....................................................................
:	DEFAULT SUP DMA DATA AREAS
:	....................................................................
					:
	GL	SBDMRG,PRDMRG,ERDMRG,ACDMRG,SYDMRG,UNDMRG,UTDMRG
					:
	DEFAULT(DSZSUP,0)		:SUPERVISOR DMA AREA SIZE
	DEFAULT(DSZPRB,0)		:PROBE
	DEFAULT(DSZERR,0)		:ERRLOG
	DEFAULT(DSZACT,0)		:ACCOUNTING
	DEFAULT(DSZSYS,0)		:SYS MESSAGE
	DEFAULT(DSZUN2,0)		:UN2
	DEFAULT(DSZUTL,0)		:UTILITY
	DEFAULT(SUPPAN,0)		:FRONT CONSOLE DISPLAY PTR
					:
:		DEFINE COMMON AREA MAC SEGMENTS

SC1MAC	EQ	SMACK(SCA1S,V+SCA1O)	:SUP COMMON AREA 1 MAC

V1	EQ	0			:COUNTER OF PAGES
V2	EQ	SCA2O			:BASE OF SUP COMMON AREA 2 MAC
V3	EQ	SCA2S			:SIZE OF SUP COMMON AREA 2
	RE	SC2SEG			:NUMBER OF SUP COMMON AREA 0 SEGMENTS
	IF	V3-(SEGPAG-1)
V4	EQ	SEGPAG;	ELSE
V4	EQ	V3;	EI
	IF	V4
SC2M|V1| EQ	SMACK(V4,V+V2)		:ANOTHER SUP COMMON 2 MAC REGISTER;	ELSE
SC2M|V1| EQ	0;	EI
V2	EQ	V2+V4
V3	EQ	V3-V4
V1	EQ	V1+1
	ER

:		DEFINE SUP WRITEABLE MEMORY LAYOUT (AREA 0)

V1	EQ	0			:COUNTER OF PAGES
V2	EQ	V			:BASE OF SUP DATA AREA MAC REGISTERS
V3	EQ	SUPA0			:SIZE OF SUP DATA AREA
	RE	SA0SEG
	IF	V3-(SEGPAG-1)
V4	EQ	SEGPAG;	ELSE
V4	EQ	V3;	EI
	IF	V4
SA0M|V1| EQ	SMACK(V4,V2)		:ANOTHER SUP DATA AREA MAC REGISTER;	ELSE
SA0M|V1| EQ	0;	EI
V2	EQ	V2+V4
V3	EQ	V3-V4
V1	EQ	V1+1
	ER

:		NOW DEFINE SUP CODE AREA MAC SEGMENT

V1	EQ	0
V3	EQ	SUPA2
	RE	SA2SEG
	IF	V3-(SEGPAG-1)
V4	EQ	SEGPAG
	ELSE
V4	EQ	V3
	EI
SA2M|V1| EQ	SMACK(V4,V2)
V2	EQ	V2+V4
V3	EQ	V3-V4
V1	EQ	V1+1
	ER
SUPCORE	EQ	V2

	EM
	EI	(SUP)
	IF	NSYNC!NPRINT

	SUBTTL	DEFINE DATA LAYOUTS

:	SYNCHRONOUS INPUT RING-BUFFER FORMAT

:	************************************************************
:	*	CURRENT INPUT INDEX...-1<CIP<FOLD+1
:	************************************************************
:	*	BUFFER AREA ("FOLD" BYTES OF STORAGE)
:	************************************************************
	ORG	0			:
	GL	CII,IBUF		:
CII	HS	1			:CURRENT INPUT INDEX
IBUF	HS	1			:THE INPUT BUFFER
					:
:	....................................................................
:	SYNCHRONOUS OUTPUT DISCRIPTOR FORMAT
:	....................................................................

:	*****************************************************
:	*	OPERATION	* BYTE COUNT (WILL BE OUTPUT AS HALFWORDS)
:	*****************************************************
:	*	STRING ADDRESS
:	*****************************************************
					:
	ORG	0			:
	GL	OOP,OCT,OSP		:
OOP	HS	1			:OUTPUT OPERATION
OCT	HS	1			:OUTPUT CHAR COUNT
OSP	HS	2			:OUTPUT STRING POINTER
					:
:	....................................................................
:	OOP CAN HAVE THE VALUES:
:	0	HALT OUTPUT (GO TO MARKING STATE)
:	1	OUTPUT STRING
:	2	TRANSFER TO NEW DISCRIPTOR
:	3	TURN OFF "RS"
:	4	TURN ON "RS"
:	5	SET FLAG BIT
:	6	CONNECT "CS" FLAG BIT
:	7	CONNECT "DSR" FLAG BIT
:	8	TURN OFF DTR
:	9	TURN ON DTR
:	10	SET OUTPUT PADDING STATE
:	11	SPECIAL OUTPUT (DON'T ZERO COMMAND)
:	12	SPECIAL TRANSFER (DON'T ZERO COMMAND)
:	....................................................................

  IF	NSYNC
   IF	ESYNCI
:	....................................................................
:	ENHANCED SYNC INTERRUPT BLOCK FORMAT (STARTS @ LOC X'400')
:	ONE BLOCK PER LINE
:	....................................................................
					:
	ORG	0			:
	GL	CIIPTR,OIX,OEAD		:
CIIPTR	HS	2			:PTR TO INPUT RING INDEX
OIX	HS	1			:OUTPUT DATA INDEX (NEGATIVE)
OEAD	HS	2			:OUTPUT DATA END ADDR
    IF	HMICRO!TSI!NANO			:
	GL	OPAD			:
OPAD	HS	1			:OUTPUT PAD HW
    EI (HMICRO!TSI!NANO)		:
					:
:	....................................................................
:	Note: INPUT RING INDEX MUST BE FOLLOWED IMMEDIATELY BY A X'100' BYTE
:	      INPUT RING.IF THE INPUT RING INDEX IS NEGATIVE, A CONVENTIONAL
:	      SOFTWARE INTERRUPT IS TAKEN.
:
:	      OUTPUT DATA INDEX...
:	      IF < 0  THE INDEX IS ADDED TO THE OUTPUT END ADDR TO GET THE
:		      ADDR OF THE NEXT WORD TO OUTPUT.   THE INDEX IS THEN
:		      INCR'D BY 2.
:	      IF > 0  A HW OF -1 IS OUTPUT AND THE INDEX THEN DECR'D BY 1.
:	      IF = 0  A CONVENTIONAL SOFTWARE INTERRUPT IS TAKEN.
:	....................................................................

   EI  (ESYNCI)
  EI   (NSYNC)
	EI	(NSYNC!NPRINT)

	ORG	0

	SUBTTL	DECLARE GLOBAL NETWORK PARAMETERS

	GL	NCTA,NCTAS		:
	GL	MACHNM,SUP		:
					:
   IF	1-SUP				:
SUP	EQ	0			:
   EI  (1-SUP)				:
					:
M1	EQ	7F000000		:MASKS FOR USE BELOW
M2	EQ	0FF			:
	RA	$A10			:
					:
	DECLARE(NDP,$0 100)		:NUMBER OF NODE PORTS
	DEFAULT(DI.CHN,NDP)		:NO. OF DISPATCHER CHANNELS
					:
   IF	$0 DI.CHN-1FFF			:
	 REMARK	%dispatcher has excessive channels (
	 NUMBER	$A DI.CHN
	 REMARK	d), reduced to 8191d!
DI.CHN	 EQ	$0 1FFF
   EI   (DI.CHN-1FFF)			:

   IF	NODENM
	 GL	HST0
    IF	$8 2001-NODENM
	 REMARK %%Bad TYMNET-II node number, < 2000
    EI  ( )
	DECLARE(SILINS,0)		:DEFAULT IS NO SIO-LINES
	DECLARE(NLINES,NLUS0)		:DEFAULT IS UNITS ASSIGNED TO SLOT 0,
    IF	(NLUS0+1-NLINES)*(NLINES+1)
    ELSE				:IF ( (NLINES+SILINS)>NLUS0) .OR. (NLINES<0)
	REMARK %%Node code expects more logical units (
	NUMBER $A NLINES
	REMARK d) than assigned (	
	NUMBER $A NLUS0
	REMARK d)
    EI (NLINES-NLUS0)
   EI  (NODENM)


	SUBTTL	DECLARE GLOBAL SLOT PARAMETERS

					:
:	....................................................................
:
:	Define global parameters for each specified slot
:
:	1. Slot background process quantum
:	2. Slot license
:	3. Slot core memory size
:	4. Slot Logical unit
:
:	....................................................................
					:
	GL	SLICLO,SLICHI

SLICLO	EQ	0			:SUSPEND LICENSE BIT ARRAY
SLICHI	EQ	0			:
Q	EQ	0			:
					:
	RE	NSLOT+1
	DEFAULT(Q.BG|Q|,$0 1E)
	DEFAULT(S|Q|LIC,0)
	DEFAULT(S|Q|CORE,1)
	DEFAULT(NLUS|Q|,0)
	IF	S|Q|CORE
	ELSE
S|Q|CORE EQ	1
	REMARK	%Slot 
	NUMBER	Q
	REMARK	 defined too small---forced to 1K.
	EI
	IF	S|Q|LIC&TL.SUS
	 IF	Q-$A31
SLICHI	  EQ	SLICHI!(1^($A63-Q))
	 ELSE
SLICLO	  EQ	SLICLO!(1^($A31-Q))
	 EI
	EI
	IF	NLUS|Q|-NLU
	 REMARK	%Slot
	 NUMBER	Q
	 REMARK	---too many logical units
NLUS|Q|	 EQ	NLU
	EI
QQ	EQ	0
	RE	NLU
	RA	0
	GL	X|Q|L|QQ|
	RA	$A10
	DECLARE(S|Q|L|QQ|,-1)		:DECLARE UNITS FOR USER IF HE FORGOT
QQ	EQ	QQ+1
	ER
Q	EQ	Q+1
	ER				:
					:

	IF	NODENM
:	NODE CODE SLOT CAN HAVE SYNC OR M-BOARD LINES ONLY
Q	EQ	0
	RE	NLUS0
	IF	1+S0L|Q|
V	 EQ	(S0L|Q|&M1)^-$010
	 IF	(V%SYN)*(V%(M.CARD^-$010))	: IF (V#SYN) & (V#M.CARD)
	  REMARK	%%Non-Synchronous device 
	  NUMBER	Q
	  REMARK	 on Node Code slot...Canceling
S0L|Q|	  EQ	-1
	 EI
	EI	(1+S0L|Q|)
Q	EQ	Q+1
	ER
	EI	:(NODENM)

	IF	HMICRO!TSI!NANO
	 IF	XSYNC
	 IF	HMICRO
	 REMARK %HDLC MICRO-ENGINE does not support extended sync lines...
	 EI	(HMICRO)
	 IF	TSI!NANO
	 REMARK %TSI&NANO does not support extended sync lines...
	 EI	(TSI!NANO)
	 REMARK	CANCELED
XSYNC 	 EQ	0
	 EI
	ELSE
	IF	NSYNC
	 IF	NSYNC-$020
	  REMARK	%Number of SYNC lines exceeds maximum...REDUCING TO 32d
NSYNC	  EQ	$0 20
	  ELSE	NSYNC-$010
XSYNC	   EQ	1
	  ELSE
NSYNC	   EQ	$0 10
	 EI
	EI	(NSYNC)

	IF	XSYNC
	 IF	NSYNC
NSYNC	  EQ	$0 20			:NUMBER OF SYNC LINES
	 ELSE
	  REMARK	%XSYNC not compatible with no SYNC lines...CANCELED
XSYNC	  EQ	0
PSPORT	EQ	NSYNC
	 EI	(NSYNC)
	EI	(XSYNC)
	EI	(HMICRO!TSI!NANO)

	NOLIST

:	NOW PROCESS ALL SYNC LINES FOR ALL SLOTS

:	CHECK FOR DUPLICATE USAGE
W	EQ	0
Q	EQ	0
NSYNCL	EQ	0
	RE	NSLOT+1
QQ	EQ	0
	IF	NLUS|Q|
	 RE	NLUS|Q|
V	 EQ	S|Q|L|QQ|
	 IF	1+V
	  IF	V&M1
	  ELSE
	   IF	PSPORT-V
U	    EQ	1^V
	    IF	W&U
	     BITCH1(Q,QQ)
	     REMARK	 Muliple usage of SYNC line 
	     BITCH2(V)
S|Q|L|QQ|    EQ	-1
	    EI
W	    EQ	W!U
NSYNCL	    EQ	NSYNCL+1
	   ELSE
	    BITCH1(Q,QQ)
	    REMARK	 Calls out excess SYNC line 
	    BITCH2(V)
S|Q|L|QQ|   EQ	-1
	   EI
	  EI
	 EI
QQ	 EQ	QQ+1
	 ER
	EI
Q	EQ	Q+1
	ER
	IF	1-W
	 IF	NSYNC
	  REMARK	%SYNC specified but not assigned...(warning only, no change)
	 EI
	EI
SYNCL	EQ	W		:REMEMBER WHICH SYNC LINES USED

:	NOW PROCESS ALL ASYNC UNITS FOR ALL SLOTS

:	CHECK FOR DUPLICATE USAGE
W	EQ	0
Q	EQ	0
	RE	NSLOT+1
QQ	EQ	0
	IF	NLUS|Q|
	 RE	NLUS|Q|
V	 EQ	S|Q|L|QQ|
	 IF	1+V
U	  EQ	V&M1
	  IF	U%ASN
	  ELSE
V	   EQ	V&M2
	   IF NASYNG
	    IF	NASYNG-V
U	     EQ	1^V
	     IF	W&U
	      BITCH1(Q,QQ)
	      REMARK	 Muliple usage of ASYNC group 
	      BITCH2(V)
S|Q|L|QQ|     EQ	-1
	     EI
W	     EQ	W!U
	    ELSE
	     BITCH1(Q,QQ)
	     REMARK	 Calls out excess ASYNC group 
	     BITCH2(V)
S|Q|L|QQ|    EQ	-1
	    EI
	   ELSE
	    BITCH1(Q,QQ)
	    REMARK	 Requires specification of ASYNC group 
	    BITCH2(V)
S|Q|L|QQ|   EQ	-1
	   EI
	  EI
	 EI
QQ	 EQ	QQ+1
	 ER
	EI
Q	EQ	Q+1
	ER
	IF	1-W;	 IF	NASYNG
	  REMARK %ASYNC specified but not assigned...
	  IF	AS.IS.;	   REMARK (warning only, no change)
	  ELSE;	   REMARK defaulting to NOT USED
NASYNG	   EQ	0;	  EI;	 EI;	EI


:	NOW PROCESS ALL PRINTER UNITS FOR ALL SLOTS

:	CHECK FOR DUPLICATE USAGE
W	EQ	0
Q	EQ	0
	RE	NSLOT+1
QQ	EQ	0
	IF	NLUS|Q|
	 RE	NLUS|Q|
V	 EQ	S|Q|L|QQ|
	 IF	1+V
U	  EQ	V&M1
	  IF	U%PRN
	  ELSE
V	  EQ	V&M2
	   IF	NPRINT
	    IF	NPRINT-V
U	     EQ	1^V
	     IF	W&U
	      BITCH1(Q,QQ)
	      REMARK	 Multiple usage of PRINTER 
	      BITCH2(V)
S|Q|L|QQ|     EQ	-1
	     EI
W	     EQ	W!U
	    ELSE
	     BITCH1(Q,QQ)
	     REMARK	 Calls out excess PRINTER 
	     BITCH2(V)
S|Q|L|QQ|    EQ	-1
	    EI
	   ELSE
	    BITCH1(Q,QQ)
	    REMARK	 Requires specification of PRINTER 
	    BITCH2(V)
S|Q|L|QQ|   EQ	-1
	   EI
	  EI
	 EI
QQ	 EQ	QQ+1
	 ER
	EI
Q	EQ	Q+1
	ER
	IF	1-W;	 IF	NPRINT
	  REMARK %PRINTERS specified but not assigned...
	  IF	AS.IS.;	   REMARK (warning only, no change)
	  ELSE;	   REMARK defaulting to NOT USED
NPRINT	   EQ	0;	  EI;	 EI;	EI

:	NOW PROCESS ALL MOTHER-CARD PORTS FOR ALL SLOTS

	IF	M.NCARD-8
	 REMARK	%Too many MOTHER-BOARDS configured...REDUCING TO 8
M.NCARD	 EQ	8
	EI

:	CHECK FOR EXCESSIVE CARD CALLED OUT
Q	EQ	0
	RE	NSLOT+1
QQ	EQ	0
	IF	NLUS|Q|
	 RE	NLUS|Q|
V	 EQ	S|Q|L|QQ|
	 IF	1+V
U	  EQ	V&M1
	  IF	U%M.CARD
	  ELSE
V	  EQ	$0 (V&M2)/10
	   IF	M.NCARD
	    IF	M.NCARD-V
	    ELSE
	     BITCH1(Q,QQ)
	     REMARK	 Calls out excess M-BOARD 
	     BITCH2(V)
S|Q|L|QQ|    EQ	-1
	    EI
	   ELSE
	    BITCH1(Q,QQ)
	    REMARK	 Requires specification of M-BOARD 
	    BITCH2(V)
S|Q|L|QQ|   EQ	-1
	   EI
	  EI
	 EI
QQ	 EQ	QQ+1
	 ER
	EI
Q	EQ	Q+1
	ER

	IF	M.NCARD

:	 DEFINE GLOBALS
Q3	 EQ	0
	 RE	M.NCARD
	 GL	M.NP|Q3|,M.DA|Q3|
Q3	 EQ	Q3+1
	 ER

:	 CHECK FOR DUPLICATE LINE USAGE
BITCH3	MACRO(A,B)[
	NUMBER	A
	REMARK	 LINE 
	BITCH2(B)
]
BITCH4	MACRO[
	REMARK	 Multiple usage of MOTHER-CARD 
]
BITCH5	MACRO[
	REMARK	 Calls out excess MOTHER-CARD 
]
BITCH6	MACRO[
	REMARK	 specified but not assigned (warning only, no change)
]
:	THE FOLLOWING MACROS WERE CREATED TO AVIOD EXCEEDING THE MAX
:	CHARACTER LIMIT WITHIN A REPEAT LOOP

XCHECK	MACRO(A)[
	BITCH1(Q,QQ)
	BITCH|A|
	BITCH3(Q3,V)
]
HCHECK	MACRO[
	IF SYNCL&U
	 IF	HMICRO
	 REMARK	%HDLC MICRO-ENGINE requires unique channel numbers 
	 EI	(HMICRO)
	 IF	TSI!NANO
	 REMARK	%TSI&NANO requires unique channel numbers 
	 EI	(TSI!NANO)
	 REMARK	for sync and sio lines...
	 BITCH1(Q,QQ)
	 REMARK	 calls out duplicate channel 
	 BITCH2(V)
S|Q|L|QQ| EQ	-1
	EI
]

Q3	EQ	0
	 RE	M.NCARD
W	 EQ	0
Q	 EQ	0
	 RE	NSLOT+1
	 IF	NLUS|Q|
QQ	 EQ	0
	  RE	NLUS|Q|
V	  EQ	S|Q|L|QQ|
	  IF	1+V
U	   EQ	$0 V&0FFFFFFF0
	   IF	$0 ((Q3*10)!M.CARD)%U
	   ELSE
V	    EQ	$0 V&0F
	    IF	M.NP|Q3|-V
U	     EQ	1^V
	     IF	W&U
		XCHECK(4)
S|Q|L|QQ|     EQ	-1
	     EI
	     IF	HMICRO!TSI!NANO
	       HCHECK
	     EI	(HMICRO!TSI!NANO)
W	     EQ	W!U
	    ELSE
		XCHECK(5)
S|Q|L|QQ|    EQ	-1
	    EI
	   EI
	  EI
QQ	  EQ	QQ+1
	  ER
	 EI
Q	 EQ	Q+1
	 ER
	 IF	1-W
	  REMARK %M-BOARD 
	  NUMBER Q3
	  BITCH6
	 EI
Q3	 EQ	Q3+1
	 ER
	 KILL	BITCH3			:CANCEL MACRO
	 KILL	BITCH4
	 KILL	BITCH5
	 KILL	BITCH6
	 KILL	HCHECK
	EI

:       NOW PROCESS ALL IPI BOARDS FOR ALL SLOTS

W 	EQ	0
Q	EQ	0
	RE	NSLOT+1
QQ	EQ	0
	IF	NLUS|Q|
	RE NLUS|Q|
V	EQ S|Q|L|QQ|
U	EQ V&M1
	IF U%IPIDEV
	ELSE
V	EQ V&M2
	IF IPNMBR		
	IF IPNMBR-V
U	EQ 1^V
	IF W&U
		BITCH1(Q,QQ)
		REMARK  ***Multiple usage of IPI device***%
		BITCH2(V)
S|Q|L|QQ|	EQ	-1
	EI
W	EQ	W!U
	ELSE
		BITCH1(Q,QQ)
		REMARK  ***Calls out excess IPI device***%
		BITCH2(V)
S|Q|L|QQ|	EQ	-1
	EI
	ELSE
		BITCH1(Q,QQ)
		REMARK  ***Requires specification of IPI board***%
		BITCH2(V)
	EI
	EI
QQ	EQ	QQ+1
	ER
	EI
Q	EQ	Q+1
	ER
	IF	IPNMBR
U	EQ	IPNMBR-W-1
	 IF 	U
	  REMARK	%IPI device specified but not assigned..warning only%
	 EI
	EI

:	NOW PROCESS SPIRIT BUS L.U. FOR ALL SLOTS
	GL	SBSLOT,SBLU

:	CHECK FOR DUPLICATE USAGE
W	EQ	0
Q	EQ	0
	RE	NSLOT+1
QQ	EQ	0
	IF	NLUS|Q|
	 RE	NLUS|Q|
V	 EQ	S|Q|L|QQ|
	 IF	1+V
U	  EQ	V&M1
	  IF	U%TDEV
	  ELSE
U	   EQ	1^V
	   IF	W&U
	    BITCH1(Q,QQ)
	    REMARK	 Muliple declaration of T.REF macro
	    REMARK	...CANCELED
S|Q|L|QQ|   EQ	-1
	   ELSE
SBSLOT	    EQ	Q
SBLU	    EQ  QQ
SBUS	    EQ	1
W	    EQ	W!U
	   EI
	  EI
	 EI
QQ	 EQ	QQ+1
	 ER
	EI
Q	EQ	Q+1
	ER
	IF	TSIDT
	 IF	TSI!NANO!SPIXPI
	 ELSE
	 REMARK %TSIDT is only valid for TSI or NANO - cancelled
TSIDT	EQ	0
	 EI	(TSI!NANO!SPIXPI)
	EI	(TSIDT)

ESELCH	EQ	NDISC+NTAPE
SHARE	EQ	ESELCH+MSCDSK+TSIDT
	IF	SUP
NCSLOT	EQ	NSLOT+1+NCSS		:NO. OF CONTROLLING DDT SLOTS
	ELSE
NCSLOT	EQ	NSLOT+1			:NO. OF CONTROLLING DDT SLOTS
	EI	(SUP)
	IF	SHARE;	ELSE;FSYS	EQ	0;	EI
	GL	SYSDEV,SHARE

	IF	SHARE

	 SUBTTL	SELECTOR CHANNEL AND OTHER SHARED DEVICES
	 GL	ESELCH,NDISC,NTAPE,MSCDSK,RD,WR,AT,SS,TSIDT

:	CHECK OUT DISC AND TAPE PARAMETERS

	 GL	NXLU,NGLU,XSELCH
	 DEFAULT(SHSTAT,1)		:GENERATE STATISTICS COUNTERS IF TRUE

:	.......................................................................
:	GENERATE DEFAULT XLU 0 FOR MSLOT
:	.......................................................................
					:
	IF	MSLOT
	IF	\X|MSLOT|U0		:IF XLU 0 EXISTS DO NOTHING
	ELSE
	SGU.REF(MSLOT,0,FSYS,SS+WR+RD)	:ELSE CREATE AN XLU 0 FOR MSLOT
	DECLARE(NXLU|MSLOT|,0)
NXLU|MSLOT|	EQ	NXLU|MSLOT|+1
	EI
	EI	(MSLOT)

:	DETERMINE NXLU:  MAX. NO. OF EXTENDED LOGICAL UNITS
        RA      $A10
NXLU	 EQ	0			:ASSUME NO EXTENDED LOGICAL UNITS
Q	 EQ	0			:START WITH SLOT 0
	 RE	NCSLOT
	  DECLARE(NXLU|Q|,0)
	IF	NXLU|Q|-NXLU+1
NXLU	  EQ	 NXLU|Q|
	 EI
Q	 EQ	Q+1
	 ER

	IF	FSYS
:SET UP A UNIT FOR THE FILE SYSTEM

	IF	NXLU
	ELSE
NXLU	EQ	1			:MAKE FSYS>0 IF NO PREV NXLU'S
	EI	(NXLU)

Q	EQ	0
	RE	NCSLOT
	SGU.REF(Q,NXLU,FSYS,SS+WR+RD)
Q	EQ	Q+1
	ER
FSYS	EQ	NXLU
NXLU	EQ	NXLU+1
	EI
	KILL	SGU.REF
:	ZERO UNUSED XLU'S
Q	 EQ	0			:START WITH SLOT 0
	 RE	NCSLOT
QQ	  EQ	0
	  RE	NXLU
	  RA	0
	   DEFAULT(X|Q|U|QQ|,0)
	  RA	$A10
QQ	   EQ	QQ+1
	  ER
Q	  EQ	Q+1
	 ER

:	DEFINE ALL GLOBAL UNIT SYMBOLS ZERO
NGLU	 EQ	0			:ASSUME NO GLOBAL UNITS
Q	 EQ	1			:START WITH GLOBAL UNIT 1
	 RE	MXGLU
	 IF	\GU1|Q|
NGLU	  EQ	Q
	 EI	(\GU1|Q|)
	  RA	0
	 DEFAULT(GU1|Q|,0)
	 DEFAULT(GU2|Q|,0)
	 DEFAULT(GU3|Q|,0)
	 DEFAULT(GU4|Q|,0)
Q	 EQ	Q+1
	 ER

	IF	MSCDSK
Q	EQ	0
	RE	MSCDSK
	 IF	TSIDT
	  DECLARE(MSCCY|Q|,200)
	  DECLARE(MSCTK|Q|,8)
	  DECLARE(MSCST|Q|,8)
	  DECLARE(NMSC|Q|,1)
	 ELSE
	 GL	MSCDA|Q|
	 EI
	 GL	NMSC|Q|			:DECLARE SYMBOLS GLOBAL
	 GL	MSCCY|Q|,MSCTK|Q|,MSCST|Q|
Q	 EQ	Q+1
	ER
	EI	(MSCDSK)

	EI	(ESELCH!MSCDSK)

	KILL	BITCH1,BITCH2		:KILL MACRO NAMES, DON'T NEED AGAIN
	LIST				:LISTING SUPPRESSED FOR MUCH OF LOGIC...SEE REAL FILE
	IF	NBLKS
	IF	NBLKS-2
	ELSE
	REMARK  %IF MEMORY BLOCKS ARE USED NBLKS MUST BE AT LEAST 3
NBLKS	EQ	3
	EI

:	.......................................................................
:	CREATE DEFAULT MEMORY BLOCK ASSIGNMENT
:	......................................................................

	RA	$A 10
Q1	EQ	0
	RE	NCSLOT
Q2	EQ	0
	RE	NBLKS
	IF	\M|Q1|L|Q2|
Q	EQ	MASKB			:START WITH ALL PROTECTION
	IF	P|Q1|M|Q2|&1
Q	EQ	Q&MASK3			:EXECUTION ACCESS PERMITTED
	EI
	IF	P|Q1|M|Q2|&2
Q	EQ	Q&MASK9			:WRITE ACCESS PERMITTED
	EI
P|Q1|M|Q2|	EQ	Q		:CONVERT TO MAC PROT FORMAT
	ELSE
M|Q1|L|Q2|	EQ	$0 10000
P|Q1|M|Q2|	EQ	0
	EI
	GL	P|Q1|M|Q2|,M|Q1|L|Q2|
Q2	EQ	Q2+1
	ER
Q1	EQ	Q1+1
	ER
	RA	0
	EI	:NBLKS

 if	DISPAT

	SUBTTL	DISPATCHER - Descriptors

	MO	.,DISPAT

:	....................................................................
:	Define some Descriptors:
:	(Defined here so Kernel can reference them)
:	....................................................................
					:
Q	HS	0			: remember where we are
					:
:	....................................................................
:	Define relative ring-addresses
:	....................................................................
					:
	ORG	0			:
NFMI	HS	1			: Next fill Message Index (Cursor)
CEI	HS	1			: Current Empty Index (Cursor)
RING	WS	0			: The start of the Data
					:
:	....................................................................
:	Define a Path-descriptor:
:	This includes buffer and other stuff
:	....................................................................
					:
	ORG	0			:
P.NEXT	WS	1			: Linked-list forward-pointer (should be first)
P.LAST	WS	1			: Linked-list Backward-pointer
P.BB	WS	1			: buffer start-address
P.BE	WS	1			: buffer end-address
P.BCT	HS	1			: buffer count
P.HIST	HS	1			: buffer history
P.STAT	BS	1			: Path-state
P.SLOT	BS	1			: Destination-Slot index
P.PORT	HS	1			: Destination-port
P.HOST	HS	1			: host associated with path
P.NO	HS	1			: Path-number
P.BIAS	HS	1			: byte-displacement to other path of pair
P.ACNT	HS	3			: count (input/output) for this path
P.ACX	HS	3			: other accounting stuff
p.unused hs	3			: fill length to 30 hex---***etm
P.LEN	HS	0			: the length of a path-descriptor
					:
	ORG	Q			: return to normal address-space
					:
	EM				: End of dispatcher module
 ei    (DISPAT)				:
 	SUBTTL	MACH. . .ISIS MACHINE DEPENDENT PROCESSES AND DRIVERS

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other   purpose except as specifically authorized in  wri-  **
: **  ting by  TYMNET, Incorporated.                              **
: ******************************************************************

:	CRASH MACROES
:
S.HLT0	MACRO(CC,PSD)
[
	ST	0,RSETS
	JAL	0,HLT.S
	HC	0,CC
PSD	HC	0,0,0,0
]
:
S.HLTF	MACRO(CC,PSD)
[
	ST	0,RSETS
	JAL	0,HLT.S
	HC	0F,CC
PSD	HC	0,0,0,0
]
:
S.HLTE	MACRO(CC,PSD)
[
	ST	0,RSETS
	JAL	0,HLT.S
	HC	0E,CC
PSD	HC	0,0,0,0
]
:
S.HLTI	MACRO(CC,PSD)
[
	ST	0,RSETS
	JAL	0,HLT.S
	HC	-1,CC
PSD	HC	0,0,0,0
]

:	.....................................................................
:	DEFINE FUNCTION TO GENERATE VALUE FOR KRASH
:	S	1 IF SYSTEM KRASH, ELSE 0
:	D	DEBUGGER CODE
:	F	FAIL CODE
:	.....................................................................
					:
KRCODE	MACRO(S,D,F)[
	LHI	R0,(S^0F)!(D^2)!(F^8)	:
]					:
					:
	RA	0			:
					:
TSPORT	EQ	1-SYSDBG		:SWITCH FOR "TYMSAT" PORT
   IF	-TSPORT				:
TSPORT	EQ	-TSPORT			:(ALLOW BOTH IF SYSDBG=2)
   EI  (-TSPORT)			:
					:
I.ENA	EQ	4000			:PSW BIT TO ENABLE IMMEDIATE INTERRUPTS
					:
   IF	NSYNC				:
    IF	ESYNCI				:
I.ENA	 EQ	4200			:PSW BITS TO ENABLE IMMEDIATE & ENHANCED SYNC INTS
    EI (ESYNCI)				:
   EI	(NSYNC)				:
					:
I.PSW	EQ	2000			:PSW USED FOR INTERRUPT PROCESSING
T.PSW	EQ	0000			:PSW USED FOR TRAP HANDLING
S.PSW	EQ	20F0			:PSW USED FOR SVC PROCESSING
K.PSW	EQ	20F0			:PSW USED FOR KERNEL PROCESSING
E.PSW	EQ	20F0!I.ENA		:PSW USED FOR NORMAL ENGINE USAGE
U.PSW	EQ	25F0!I.ENA		:PSW USED FOR NORMAL (NON-PRIVLEDGED) USER
					:
	GL	I.ENA,T.PSW,S.PSW,K.PSW,E.PSW,U.PSW,I.PSW
	GL	RSETS,HLT.S,USER,SLOT,TAKTIM
	GL	TSPORT,STSAVE,FTIMSW,TOTMEM
   IF	KIOSRC				:
   ELSE					:
	GL	FFRET,FFRET4		:
   EI  (KIOSRC)				:
	GL	SETDIAG,DIAG,SPIXPI,DUMP
	GL	KRASH,RBLEN,OTHER,UBS0,SUSSLT,WFROGT,WFROGD,SUSLST
	GL	FREEZE,XPIWF,QUANTUM,UFLAG,WFLAG,SLIST,TOSUSP,FRGCRS,IEND
	GL	EFLAG,FNDDDT,LLINK,RUN,WFTIME,HLT,FBACK,FQUASI,QUASI
	GL	SLTEND
   IF	ZITEL				:
	GL	MCHECK			:
   EI  (ZITEL)				:
					:

	SUBTTL		L O W   C O R E   L A Y O U T

	ORG	0			:
	JFS	0C			:
	JFS	0C			:
	JFS	0C			:
	JFS	0C			:
	JFS	0C			:
	JFS	0C			:
	J	HLT106			:LOC 0C...SKIP TO HALT SYSTEM
					:
:	.......................................................................
:	TRACE PSD... .OR. 01000 INTO PSW TO TURN ON
:	.......................................................................
					:
	GL	TRPSD,KPATCH		:
TRPSD	WS	2			:OLD PSD SAVED HERE
	WC	KPATCH			:NEW PSD TAKES YOU TO PATCH
					:
:	.......................................................................
	ORG	1C	
:	.......................................................................
					:
   IF	MACV				:
	WC	0			:
   ELSE					:
	WC	PECTR			:
	GL	PECTR			:
   EI  (MACV)				:
					:
:	.......................................................................
					:
	ORG	20			:
					:
:	.......................................................................
MMOPSD	WS	2			:OLD MACHINE MALFUNCTION PSD SAVED HERE
:	.......................................................................
	ORG	30			:
ILPSD	WC	T.PSW,I.ILINS		:ILLEGAL INSTRUCTION NEW PSW
MMPSD	WC	T.PSW,MMI		:MACHINE MALFUNCTION NEW PSD
	WS	2			:
					:
	ORG	4E			:
MSBOOT	J	.,,			:COME HERE TO GET MSC BOOTSTRAP
MTBOOT	J	.,,			:COME HERE TO GET TO MAG-TAPE BOOTSTRAP
DLBOOT	J	.,,			:COME HERE TO GET TO DOWN-STREAM LOAD BOOTSTRAP
TBOOT	J	.,,			:COME HERE TO GET TO TTY BOOTSTRAP
DBOOT	J	.,,			:COME HERE TO GET TO DISK BOOTSTRAP
CSHTBL	WC	CTABL			:LOCATION OF STANDARD CRASH TABLE
	ORG	70			:
   IF	KSYS				:
        GL      MANUAL, BSTART		:
ENTRY   J       BSTART			:START DISK BOOT PROCESS
   ELSE					:
ENTRY	J	MANUAL			:ENTER HERE, GO TO INITIALIZE
   EI  (KSYS)				:
HLT106	S.HLTF(0463)			:TRANSFER TO 0-C CAUSES HALT, CODE 63
					:
	ORG	90			:
RELPSW	WC	T.PSW,I.MACER		:RELOCATION NEW PSW
SVCPSW	WC	T.PSW!2000		:SVC PSW1 (ENABLE PARITY DETECTION)
SVCVEC	RE	10			:SVC VECTOR
	HC	I.SVCEX			:
	NOLIST				:
	ER				:
	LIST				:
	WS	1			:
					:
        GL      ENGIPI,IPDNBA,IPIRIR
ENGIPI  WS      1                       :ENG-TO-IPI MSG AREA (AT INIT'ZATION)
IPDNBA  HS      1                       :IPI DEVICE NUMBER BIT ARRAY
IPIRIR  HS      1                       :IPI RE-INIT REQUEST MSG AREA
					:
	GL	XPIMSG,ENGMSG
XPIMSG	WS	1			:ENGINE-TO-XPI MSG AREA (FOR MXP)
ENGMSG	WS	1			:XPI-TO-ENGINE MSG AREA
					:
IMIVEC	HS	2			:IMMEDIATE INTERRUPT VECTOR
	HS	1			:TTY INTERRUPT..ADDRESS 02
	HS	1D			:3-1F...UNUSED
SYNVEC	HS	40			:20-5F...SYNC CARD, SECOND SYNC CARD
	HS	10			:60-6F...UNUSED
CLKVEC	HS	8			:70-77...CLOCK INTERRUPTS
	HS	88			:78-FF...UNUSED
					:
   IF	.%2D0				:
	REMARK	ERROR, CHECK INTERRUPT VECTOR%
   EI  (.%2D0)				:
					:
:	.....................................................................
:	AREA FOR SYSLOAD COMMUNICATIONS
:	.....................................................................
					:
ACSLOT	HC	0,0,0,0			:BITS SPECIFY LOADED SLOTS
	WC	S0CORE*400-1		:SIZE OF SLOT 0 (FOR MERLIN)
	WC	0			:END OF MEMORY
					:
:	.....................................................................
:	CONSTANTS AND TEMP STORAGE
:	.....................................................................
					:
DC.IRA	HC	0,0,0,0			:BIT SET ON IRRECOVERABLE DEVICE ERROR
DSLOT	HC	 0			:CURRENT DISPATCHER SLOT TO RUN
DHANG	HC	-1			:KERNEL TO DISPATCHER, SLOT TO HANG
CT.SLT	HC	-1			:DDT TO KERNEL, SLOT TO CONNECT
DC.SLT	HC	-1			:DDT TO KERNEL, SLOT TO DISCONNECT
SPYFLAG	HC	-1,-1			:RUN SPY IF HIGH-HW = 0, IN USE IF >0
FLASHC	HC	0			:COUNTER FOR FLASH JOB
SLICE	HS	1			:TIME-SLICE TIMER...
					:...COUNT UP, PIN AT 0...
					:...ENTER KERNEL WHEN ADVANCE TO 0
SLOWT	HS	2			:TIMEOUT FOR SLOWC, USED BY FLASH JOB
SLOWCN	HC	-RATE			:
					:
MACAREA	ORG	300			:THE MAC AREA
MACSTAT	ORG	340			:THE MAC STATUS
   IF	TSI!NANO			:
	GL	MACABS,MACREL		:
MACABS	ORG	344			:ERROR ADDRESS ABSOLUTE
MACREL	ORG	348			:ERROR ADDRESS RELOCATED
   EI  (TSI!NANO)			:
	GL	MACADR,MAC.LOC		:
MACADR	ORG	348			:ADDR ON MEMORY LINES
MAC.LOC	ORG	34C			:THE MAC LOCATION LAST REFERENCED
					:
	ORG	400			:SKIP PAST MAC AREA
					:
   IF	ESYNCI				:
	RE	PSPORT
	HC	0,CIINUL,0,0,0
    IF	HMICRO!TSI!NANO
	HC	-1			:DEFAULT PAD HW
    EI (HMICRO!TSI!NANO)
	ER
	GL	CIINUL			:
CIINUL	HC	-1			:NULL INPUT RING INDEX TO FORCE SOFTWARE INTERRUPT
   EI  (ESYNCI)				:
					:
SPATCH	HS	SPASIZ			:PATCH AREA
					:
   IF	LBOOT				:
	ORG	700+0C00		:
   EI	(LBOOT)				:
					:
  IF	KSYS				:
	MO	.,BOOT			:

:	.......................................................................
:	INCLUDE A LITTLE BOOT PROGRAM
:	.......................................................................
					:
   IF	DSCBOT				:
DBOOT	EQ	66+2			:
   ELSE					:
DBOOT   EQ      4E+2            	:LOCATION OF DISK BOOT DRIVER ADDRESS
   EI  (DSCBOT)				:
					:
BSTART	J	SLSTART			:
SAVCMD	HS	0			:
BOOTST  WS      1               	:LOCATION OF LOADER CORE PLANE - X/F000
CMDADR  WS      1               	:LOCATION OF LOADER DISK DRIVER
KERNOD  WC      SCORE1          	:STARTING CORE ADDRESS FOR DISK WRITE
	WC	SLTEND			:SIZE FOR SAVING KERNEL AND SLOTS
   IF	DSCBOT				:
        HC      CYL1            	:INITIAL DISK CYLINDER
	HC	0210			:
   ELSE					:
        WC      CYL1			:
   EI  (DSCBOT)				:
					:
	GL	MSNBND			:
MSNBND	HC	0			:FLAG INDICATING IF MONITOR SLOT WAS NOT
					:IN BOUND FILE
					:
SLSTART	LIS	0C,0			:BOOT SEEMS TO FEEL BETTER WITH REG SET 0
	EPSR	0,0C			:
	LIS	0C,0F			:TRY UP TO 16 TIMES
        LM      0E,ACSLOT       	:COPY "2D0" FOR LATER REFERENCE
        STM     0E,STSAVE		:
        LCS     0F,1            	:FLAG FOR START FROM DISC
        STB     0F,FTIMSW		:
					:
        LIS     0F,0            	:TURN OFF ACSLOT
        ST      0F,ACSLOT		:
        ST      0F,ACSLOT+4		:
					:
        LI      0F,80000000^-NSLOT	:
        NR	0E,0F			:HAS NSLOT BEEN BOUND IN BY MERLIN
	JNFS	SLST1			:ONLY CONNECT MSLOT IF BOUND IN
	LM	0E,STSAVE		:IF MSLOT NOT BOUND IN, BRING UP LOADED SLOTS
	STM	0E,ACSLOT		:
	TS	MSNBND			:SET FLAG FFFF, MSLOT NOT BOUND IN
	JFS	SLST1+4			:AND CONTINUE
SLST1	ST      0F,ACSLOT		:
        LA      R0,MANUAL       	:SET 70 TO DO MANUAL
        STH     R0,72			:
	L       8,DBOOT         	:GET START-UP ADDR FOR DISK BOOT
        LR      7,8			:
        NI      8,0FFFFFF       	:TURN OFF EXTRANEOUS BITS
        ST      8,CMDADR        	:SAVE DISK DRIVER START ADDRESS
        NI      7,0FFF000       	:GET BOOT LOADER POINTER ADDRESSS
        ST      7,BOOTST        	:SAVE LOADER START ADDRESS
                                	:
LSKER	LM	0D,KERNOD		:PARAMETERS FOR DISK DRIVER
        STM     0D,0,7          	:SET BOOT DISK PARAMETERS FOR ISIS/NODE CODE
   IF	DSCBOT				:
   ELSE					:
        LHI     0F,1400			:
        STH     0F,0C,7			:
   EI  (DSCBOT)				:
        JAL     9,2,8           	:JUMP & LINK - OFFSET 2 - CALLED ADDRESS
        L       7,BOOTST		:
        L       8,CMDADR		:
	LIS	2,0E			:E INDICATES NO PROBLEMS
	SR	2,1			:1 IS DISK DRIVER DIAGNOSTIC REG
	JE	DSKOK			:
	SIS	0C,1			:DECREMENT TRY COUNT
	JGE	LSKER			:
	CIO	1,0			:INDICATE DIAGNOSTIC
	LHI	4,8006			:
	EPSR	5,4			:
					:
:	.....................................................................
:	PAST THIS POINT, SAVE EXECUTION OK
:	.....................................................................
					:
DSKOK   LM      0D,KERNOD       	:PARAMETERS FOR KERNEL/NODE LOAD
    IF	DSCBOT				:
	LHI	0F,0130			:
    EI (DSCBOT)				:
        STM     0D,0,7          	:LEAVE IT IN GOOD SHAPE
    IF	DSCBOT				:
    ELSE				:
        LHI     0F,2000			:
        STH     0F,0C,7			:
    EI (DSCBOT)				:
        LIS     0F,0            	:FLAG AS DOWNLINE LOAD
        STB     0F,FTIMSW		:
        J	MANUAL			:
	EM				:
  EI  (KSYS)				:
					:
					:
:	.....................................................................
:	COMMON AREA FOR ALL PROGRAMS TO BE ABLE TO ACCESS (SEGMENT F)
:	.....................................................................
					:
	GL	ISEGS,ISEGL

	BND	PAGE
RATE	EQ	$A600			:NUMBER OF CLOCK TICKS/SECOND
RDIV	EQ	9			:HIGHEST HIGH ORDER BIT IN 'RATE'
					:FOR APROX SHIFT DIVISION
ISEGS	HS	0			:START OF ISIS SEGMENT
NRATE	WC	RATE			:RATE CONSTANT
FASTC	WC	0			:NODE TIME, TICKS rate TIMES/SECOND
SLOWC	WC	0			:SLOW CLOCK, TICKS EVERY SECOND
GMT	WC	080000000		:GMT TIME, SET BY SUP
TEMPER	BC	0			:TEMPERATURE
VOLTS	BC	0			:VOLTAGE
VERNO	HC	VERSION			:VERSION NUMBER
WWVBT	WC	0			:CURRENT WWVB TIME
	IF	NODENM
HOSTX	HC	HST0			:KERNEL HOST NUMBER
	ELSE
	HC	0			:NO KERNEL HOST
	EI
NODEX	HC	MACHNM			:KERNEL NODE NUMBER
	GL	LOCLKX,LOCLKS
LCX	HC	LOCLKS-NRATE		:POINTER FOR SLOTS
SLCNT   HC      NSLOT                   :NUMBER OF DISPATCHER SLOTS
LCT	HC	CTABL-NRATE		:LOCATION OF CRASH TABLE
   if	LOG.II				: LOG-II support
MAXP0	HC	12			: largest port-0 Message
MAXMSG	HC	0C6			: largest non port-0 message
   else	:not LOG.II
MAXP0	HC	10			:LARGEST PORT 0 MESSAGE
MAXMSG	HC	0C1			:LARGEST NON PORT 0 MESSAGE
   ei  (LOG.II)				:
LP0LST	HC	INTLEN-NRATE		:LIST OF SIZE FOR PORT 0 MESSAGES
LENGTH	BC	0			:MESSAGE LENGTH TABLE
	RE	9D;	BC	.-LENGTH+1;	NOLIST;	ER;	LIST		:DATA TEXT STRINGS
	BC	1			: 9E	DETACH
	BC	1			: 9F	DISCONNECT
	BC	1			: A0	APPLY BACKPRESSURE
	BC	1			: A1	RELEASE BACKPRESSURE
	BC	1			: A2	FLUSH FORWARD
	BC	1			: A3	FLUSH BACKWARD
	BC	1			: A4	BLACK BALL
	BC	1			: A5	GREY BALL
	BC	1			: A6	ENTER "DEM"
	BC	1			: A7	LEAVE "DEM"
	BC	1			: A8	ENTER "TRANSPARENCY"
	BC	1			: A9	LEAVE "TRANSPARENCY"
	BC	1			: AA	GREEN BALL
	BC	1			: AB	RED BALL
	BC	1			: AC	YELLOW BALL
	BC	1			: AD	ORANGE BALL
	BC	1			: AE	"BREAK" BEGIN
	BC	1			: AF	"HANG UP"
	BC	2			: B0	QUERY TERMINAL PARAMETER
	BC	3			: B1	SET TERMINAL PARAMETER
	BC	4			: B2	PSEUDO-NEEDLE
	BC	2			: B3	LOGON CHARACTER
	BC	2			: B4	LOGON STATUS
	BC	2			: B5	LOGON FAILURE
	BC	8			: B6	SUCCESSFUL LOGON FROM THIS PORT
	BC	6			: B7	ADDENDUM TO ACCOUNTING
	BC	1			: B8	SUPER-"HANG UP"
	BC	2			: B9	TRANSMIT LIMIT
	BC	1			: BA	"BREAK" END
	BC	1			: BB	ZAP ACKNOWLEDGE
	BC	1			: BC	ENTER 'ALTERNATE MODE'
	BC	1			: BD	LEAVE 'ALTERNATE MODE'
	BC	2			: BE	ZAP BECAUSE
	BC	1			: BF	INITIATE IIX EXCHANGE
	BC	1			: C0	TERMINATE IIX
	BC	6			: C1	UUN
 if	LOG.II				: LOG-II:
	BC	0			: C2	ISN
	BC	0			: C3	RCRI
	BC	0			: C4	ICRS
	BC	6			: C5	ASLP
	BC	0			: C6	LGSC
 ei	:LOG.II
					:
        ORG     LENGTH+100
        GL      VALSPD
VALSPD  HS	0			:
  IF	NASYNG				:
   IF	BAUDR-1				:
        HC      2CF0			:
   ELSE					:
    IF	BAUDR				:
        HC      2CE0			:
    ELSE				:
        IF      LOWSPD			:
        HC      0FFC7			:
        ELSE				:
        HC      0FFC0			:
        EI     (LOWSPD)			:
    EI (BAUDR)				:
   EI  (BAUDR-1)			:
  ELSE					:(NASYNG)
        HC      0			:
  EI   (NASYNG)				:
        HC      0,0,0			:
STSAVE	HS	4			:SAVE AREA FOR START-UP BITS
FTIMSW  BC      0                       :0=LOAD FROM DLL, FF=DISC
	GL	SUP.SP			:
SUP.SP	BC	0			:supervisor state
RNSLOT	HC	0,0,0,0			:BIT MAP OF RUNNING SLOTS
SSSLOT	HC	0,0,0,0			:BIT MAP OF SUSPENDED SLOTS
MXPNUM	HC	MXPNM			:MXP MACHINE NMBR (0 IF NOT MXP)
	GL	GENGMT			:
GENGMT	BC	MONTH,DAY,YEAR		:ISIS GENERATION TIME
	BC	HOURS,MINS,SECS		:
					:
:	.......................................................................
:	CRASH TABLE ENTRIES
:	.......................................................................
					:
        WS      0                       :INSURE A WORD BOUNDRY
CTABL   HC      MACHNM                  :NODE NUMBER
        HC      7                       :NODE TYPE
        HC      1                       :TABLE VERSION
        HC      VERSION                 :ISIS VERSION
TAKTIM  WC      80000000                :REAL TIME OF FIRST TACKOVER
CRCT    HC      0                       :ISIS CRASH COUNT
SUMTBS	EQ	10			:SIZE OF SUMMARY TABLE
SUMTBL	BS	SUMTBS*10		:ROOM FOR 16 ENTRIES
DETSIZ	EQ	0F2			:SIZE OF DETAIL TABLE
DETTBL	BS	DETSIZ*2		:
					:
	WS	0			:
INTTYP	WS	1			:Interrupt type
INTPSD	WS	2			:Interrupt PSD save area
INTIME	WS	1			:FASTC
MRGSV0	WS	10			:General register set "0" save area
MRGSVF	WS	10			:General register set "F" save area
MAC300	WS	10			:MAC relocation registers save area
MAC340	WC	0			:Interrupt status register save area
MAC344	WC	0			:Last legal fetch address (relocated)
MAC348	WC	0			:Last memory parity address
MAC34C	WC	0			:Last legal fetch address (not relocated)
MAC350	WC	0			:Last MAC accessed physical memory addr.
MAC354	WC	0			:Memory upper bound address
MAC358	WC	0			:DRAM refresh register
MAC35C	WC	0			:Context register
MAC360	WC	0			:Trace command register
MAC364	WC	0			:Lower trace address
MAC368	WC	0			:Upper trace address
MAC36C	WC	0			:Trace condition match
					:
	GL	INTTYP,INTPSD,INTIME,MRGSV0,MRGSVF,MAC300,MAC340,MAC344,MAC348
	GL	MAC34C,MAC350,MAC354,MAC358,MAC35C,MAC360,MAC364,MAC368,MAC36C
	GL	LENGTH
					:
:	.......................................................................
:	TABLE OF LENGTHS FOR INTRA-ISIS COMMUNICATIONS (PORT = 0)
:	LENGTH OF ZERO INDICATES VARIABLE LENGTH
:	.......................................................................
					:
INTLEN	BC	1,1,2,7,0A,6,6,9,0,5,8,5,8,1,0,1,0C

   if	LOG.II				: LOG-II:
	BC	0,0			: ICRM, ECRI
   ei  (LOG.II)				:
					:
	HC	0			:SYSTEM CLOCK
LOCLKX	HC	0			:LOCAL-CLOCK INDEX, SYSTEM CLOCK
LOCLKS	HS	2*(NSLOT+2)		:THE LOCAL CLOCKS...LAST IS FOR NON-SLOTS
					:
ISEGL	EQ	.-NRATE			:
	GL	CONMAC			:
CONMAC	EQ	MACVAL(ISEGL,NRATE,0A)	:END OF SEGMENT F
					:
DETPOS  WC	DETTBL			:
   IF	MXP				:
	GL	XPITMR			:
XPITMR	WC	1			:XPI WATCHDOG TIMER
   EI  (MXP)				:
	GL	MEMTOP			:First Invalid Address
MEMTOP	WC	MEMSIZ			:TOP OF MEMORY (First Megabyte+1)
SS.SLT	HC	-1			:SET TO TELL KERNEL TO SUSPEND SLOT
RS.SLT	HC	-1			:SET TO TELL KERNEL TO RESUME SLOT
FRGCRS	HC	-1			:INDICATOR OF WATCH FROG CRASH (IF +1)
SCRASH	HC	-1			:DISPATCHER TO KERNEL, SLOT TO CRASH
					:
HSV	WS	1			:HALT ROUTINE - PATCH THE FOLLOWING
HLT	ST	R15,HPS+4		:INTO THE CODE TO HALT MACHINE:
	EPSR	R15,R15			:	ST	R15,HSV
	OHI	R15,8000		:	JAL	R15,HLT
	ST	R15,HPS			:
	L	R15,HSV			:PSW & ALL REGS PRESERVED,
	LPSW	HPS			:PC POINTS TO AFTER JAL
HPS	WS	2			:
					:
   IF	SYSMON				:
SYSTAT	HS	10			:STORAGE FOR STATISTICS
	GL	SYSTAT			:
   EI  (SYSMON)				:

					:
        SUBTTL  CRASH TABLE PROCESSING

OLDORG	EQ	.
        ORG     0               
:	...............................................................
:	SUMMARY TABLE ENTRIES
:	...............................................................
					:
CRCTS   HS      1               	:CRASH NUMBER
CRIDS   HS      1               	:CRASH ID
CRPSDS  WS      1               	:CRASH PSD
CRSHPC	WS	1			:CRASH PC
CRTIMS  WS      1               	:TIME OF CRASH
					:
        ORG     0			:
					:
:	...............................................................
:	DETAILED TABLE
:	...............................................................
					:
CRCTD   HS      1               	:CRASH NUMBER
CRIDD   HS      1               	:CRASH ID
CRPSDD  WS      2               	:CRASH PSD
CRTIMD  WS      1               	:TIME OF CRASH
REGS0D  WS      10              	:REG SET 0
REGSFD  WS      10              	:REG SET F (OR E)
MCRGD   HS      30              	:MAC REGS
LSTSLD  HS      1               	:LAST SLOT
CCMAN   EQ      0			:
					:
        ORG     OLDORG			:
					:
:	...............................................................
:	TEMPORARY SAVE AREA FOR REGISTERS
:	...............................................................
					:
RSETS   WS      10			:
HLT.S   STM     R1,RSETS+4      	:SAVE THE CURRENT REGS
        LR      R1,R0           	:COPY LINK
   IF	MXP				:
    IF	1-XPISAV			:
:	...............................................................
:	RESET THE XPI BOARD
:	...............................................................
	LHI	R0,XPIAD		:XPI DEVICE ADDR
	LIS	R2,4			:
	OCR	R0,R2			:
	LHI	R2,40			:
HLT.S1	SIS	R2,1			:
	JNBS	HLT.S1			:
	OCR	R0,R2			:RESET/HALT ON, TRANSLATE OFF
	LIS	R2,4			:HALT/TRANSLATE OFF, RESET ON
	OCR	R0,R2			:
	LIS	R2,8			:RESET/HALT/TRANSLATE ON
	OCR	R0,R2			:
	LHL	R0,2,R1			:GET CRASH REASON
	OI	R0,XMCRSH		:MAKE A CRASH CMD
	ST	R0,XPIMSG		:SAVE FOR XPI
    EI (1-XPISAV)			:
   EI  (MXP)				:
					:
   IF	IPNMBR				:
:	...............................................................
:       SEND CRASH MSG TO IPI(s)
:	...............................................................
					:
        JAL     R6,IPICRA		:
   EI  (IPNMBR)				:
					:
:	...............................................................
:	PUSH DOWN THE SUMMARY TABLE
:	...............................................................
					:
        LHI     R2,SUMTBS*10-20 	:16 ENTRIES OF 16 BYTES
PDOWN   LM      R12,SUMTBL,R2		:
        STM     R12,SUMTBL+10,R2	:
        SHI     R2,10			:
        JGEBS   PDOWN			:
					:
:	...............................................................
:	PLACE ENTRY IN SUMMARY TABL
:	...............................................................
					:
        LIS     R0,1            	:UPDATE CRASH CT
        AH      R0,CRCT			:
        STH     R0,CRCT         	:PLACE IN HEADR
        STH     R0,SUMTBL+CRCTS 	:AND SUMMARY
        LHL     R0,2,R1         	:GET CRASH CODE
        STH     R0,SUMTBL+CRIDS 	:PLACE IT IN SUMMARY
        L	R0,4,R1			:CHECK ON PSD
	JNFS	DETE10			:THERE IS ONE STORED USE IT
	ST	R1,SUMTBL+CRSHPC	:USE CALLING ADDRESS AS LOCATION
	JFS	DETE20			:
DETE10  LM      R14,4,R1                :GET CRASH PSD
        STM     R14,SUMTBL+CRPSDS	:
DETE20  L       R0,GMT          	:GET GMT
        ST      R0,SUMTBL+CRTIMS	:
   IF	MXP				:
    IF	1-XPISAV			:
:	.......................................................................
:	RELEASE THE XPI BOARD FROM RESET
:	.......................................................................
					:
	LHI	R2,100			:
HLT10	SIS	R2,1			:KEEP RESET FOR A WHILE
	JGEBS	HLT10			:
	LHI	R0,XPIAD		:XPI DEVICE ADDR
	LIS	R2,0E			:RESET/HALT OFF, TRANSLATE ON
	OCR	R0,R2			:
    EI (1-XPISAV)			:
   EI  (MXP)				:
					:
:	.......................................................................
:	DECIDE ABOUT A DETAILED REPORT
:	.......................................................................
					:
        LHL     R0,2,R1         	:CHECK MUNUAL RSTART
        CHI     R0,CCMAN		:
        JE      0C,R1           	:IF MANUEL RESTART RETURN FROM CALL
					:
:	.......................................................................
:	FILL IN A DETAILED REPORT
:	.......................................................................
					:
        L       R2,DETPOS       	:POINTER TO DETAILED REPORT
        LM      R12,SUMTBL      	:COPY SUM RPT TO DETAIL
        STM     R12,CRCTD,R2		:
					:
:	.......................................................................
:	ARE WE IN R-SET 0?
:	.......................................................................
					:
        LHL     R0,0,R1			:Get crash type?
	JL	HLT01			:Process interrupt crash
        JEFS    HLT00			:Process crash on register set "0"
        AHI     R2,40           	:Process crash on register set "E"
					:or "F"
HLT00   LM      R8,RSETS        	:R2 NOW OFFSET TO REGISTER
        STM     R8,REGS0D,R2    	:MOVE CRASH REGS
        LM      R8,RSETS+20		:
        STM     R8,REGS0D+20,R2		:
					:
        L       R2,DETPOS       	:RECOVER BASE
        LM      R4,MACAREA      	:MOVE MAC REGS
        STM     R4,MCRGD,R2		:
        LM      R4,MACAREA+30		:
        STM     R4,MCRGD+30,R2		:
	J	HLT1A			:
					:
:	.......................................................................
:
:	.......................................................................
					:
HLT01	LM      R8,MRGSV0        	:
        STM     R8,REGS0D,R2    	:MOVE CRASH REGS
        LM      R8,MRGSV0+20		:
        STM     R8,REGS0D+20,R2		:
					:
	LM      R8,MRGSVF        	:
        STM     R8,REGSFD,R2    	:MOVE CRASH REGS
        LM      R8,MRGSVF+20		:
        STM     R8,REGSFD+20,R2		:
					:
        L       R2,DETPOS       	:RECOVER BASE
        LM      R4,MAC300	      	:MOVE MAC REGS
        STM     R4,MCRGD,R2		:
        LM      R4,MAC300+30		:
        STM     R4,MCRGD+30,R2		:
					:
HLT1A   L       R3,USER,,       	:GET USER BLOCK
        LHL     R0,SLOT,R3      	:GET SLOT LAST RUN
        STH     R0,LSTSLD,R2		:
					:
:	.......................................................................
:	GET SECOND SET OF REGISTERS
:	.......................................................................
					:
        LHL     R0,0,R1			:
        JE      HLT02           	:BRANCH IF RSET 0
					:
        LA      R3,REGS0D,R2    	:ADDRESS OF WHERE REGS GO
        LIS     R0,0            	:NEW REG SET
        JFS     HLT03			:
					:
HLT02   LA      R3,REGSFD,R2    	:WHERE TO PUT REGS
        LHI     R0,0F0          	:NEW REGSET
					:
HLT03   STH     R3,HLT05        	:SAVE WHRE TO PUT REGS
        CI      R2,DETTBL       	:FIRST ENTRY?
        JNFS    HLT04           	:NO
					:
        AHI     R2,LSTSLD+2     	:POINT TO NEXT
        ST      R2,DETPOS		:
					:
HLT04   EPSR    R15,R0          	:SAVE THE OTHER REGISTER SET
        STM     R0,0,,			:
HLT05   EQ      .-2			:
					:
   IF	ZITEL				:
	JAL	R0,MCHECK,,		:READ MEMORY ERROR LOG
   EI  (ZITEL)				:
   IF	KIOSRC				:
	GL	KILMB			:
	LHI	R5,KIOSRC		:Get device address
	JAL	R7,KILMB,,		:Kill SIO motherboard
   EI  (KIOSRC)				:
	LB	R0,SUMTBL+CRIDS		:BUILD HALT *BADXX*
	OI	R0,0BAD00		:WHERE XX IS THE EXT. CC
					:
	LB	R1,SUMTBL+CRIDS+1 	:BUILD 87YY
	OHI	R1,8700			:WHERE YY IS THE CRASH CODE
	LPSWR	R0,R1			:HALT!!!!!!!!!
					:

					:
:	...............................................................
:	****	MANUAL RESTART	****
:	INITIALIZE THE MACHINE, THEN GIVE IT TO THE KERNEL
:	ON SUBSEQUENT MANUAL RESTARTS, CALL KMANUAL TO CRASH EVERYONE
:	...............................................................
					:
MANUAL	LHI	R14,0F0			:SWITCH TO REGISTER SET "F", NO INTERRUPTS
	EPSR	R0,R14			:THEN ENTER MANUAL RESTART
	JAL	R0,HLT.S		:
	HC	0F,0			:
	HC	0,0,0,0			:
	JAL	R0,MINIT		:INITIALIZE THE MACHINE
	L	R0,MANKER		:GO SET UP THE KERNEL
	LA	R1,KMANUAL,,		:
	ST	R1,MANKER		:SET IT UP SO NEXT TIME WE DO A MANUAL RESTART
	JALR	R0,R0			:...WE'LL INFORM THE KERNEL OF MANUAL RESTART
	J	KINIT,,			:NOW LET THE KERNEL HAVE THE MACHINE
MANKER	WC	KINIT			:PSD TO INITIALIZE THE KERNEL
					:
:	...............................................................
:	ROUTINE TO INITIALIZE THE MACHINE PORTION OF THE NODE
:	CALLED VIA JAL,R0 MINIT
:
:	REG:	R8	R9	R10	R11	R12	R13	R14	R15
MREGS1	WC	100-4,	200-2,	ILLINT,	0,	MMI,	0FFFFE,	20F0,	IZ2
MREGS2	WC	4, K.PSW+I.ENA,	ILINT2,	0,	FLUSHI
:
  if	tsi!nano
rtn69	lhl	r4,slot,r1		:slot
	la	r5,int69		:message
	jal	r11,setdiag,,		:message into history buffer
	lpswr	r0			:exit
:
savr6	ws	1
int69	sc	/*69-INT*/
  ei	(tsi!nano)				:
					:
MINIT	LHI	R13,0D0			:FIRST, SET UP REGISTER SET "D"
	EPSR	R15,R13			:...TO LARGE, POSATIVE VALUE
	LI	R14,100E0		:
	LHI	R0,0F0			:SWITCH TO REGISTER SET "F",
					:NO INTERRUPTS
	EPSR	R1,R0			:THEN PROCEED WITH INITIALIZATION
					:FROM REGISTER SET "F"
	LM	R8,MREGS1		:SET UP REGISTERS
	EPSR	R1,R14			:ENABLE MACH. MALFUNCTION
					:INTERRUPT
	ST	R11,MMPSD		:
	ST	R12,MMPSD+4		:SET UP ORDINARY PARITY/POWER FAIL TRAP
IZ3	STH	R10,IMIVEC,R9		:ALL INTERRUPTS PLUGGED TO ILLEGAL INTERRUPT
	SIS	R9,2			:
	JGEBS	IZ3			:INITIALIZE IMMEDIATE INTERRUPTS
IZ4	eq	.
   if	tsi!nano
:
: logs spurious interrupt instead of crashing slot on 8730 halt
:
	st	r6,savr6
	la	r6,rtn69		:interrupt vector
	sth	r6,0d0+(69)*2		:cell for inter. 69
	l	r6,savr6
   ei	(tsi!nano)
	ST	R11,MACAREA,R8		:INITIALIZE MAC AREA
	SIS	R8,4			:
	JGEBS	IZ4			:
	STM	R14,RELPSW		:SET UP A MAC PSW
	LHI	R14,24F0		:ENABLE MAC RELOCATION
	EPSR	R1,R14			:ENABLE MAC RELOCATION
	NOP
IZ2	EPSR	R14,R1			:DISABLE RELOCATION
	L	R1,MACSTAT		:MUST READ SOME MACS TO CLEAR
	ST	R1,MAC340		:Save the current MAC status register
	ST	R11,MACSTAT		:CLEAR MAC INTERUPT
   IF	MACV				:
					:
:	.....................................................................
:	MAC-V Initialization ...
:	.....................................................................
					:
	LI	R3,((SEGSIZ*(MACREG-1))^MSHFTA)+MMASKL+MASK1 :INITIAL MAC REG VALUE
	LHI	R2,(MACREG-1)*4		:INITIAL MAC REG OFFSET
IZ6	ST	R3,MACAREA,R2		:PLACE MAC REGISTER VALUE
	SI	R3,SEGSIZ^MSHFTA	:NEXT BASE ADDRESS
	SIS	R2,4			:DO NEXT MAC REG
	JGEBS	IZ6			:IF MORE, DO NEXT
	LI	R2,IZ8			:TEMP MAC INTERRUPT VECTOR
	ST	R2,RELPSW+4		:SET UP VECTOR
	LHI	R14,24F0		:ENABLE MAC RELOCATION
	EPSR	R1,R14			:ENABLE MAC RELOCATION
	LIS	R2,0			:
IZ7	AI	R2,40000		:LOOK AT NEXT MEMORY BLOCK
	L	R3,0,R2			:ACCESS MEMORY BLOCK
	CI	R2,SEGSIZ*MACREG	:END OF MEMORY?
	JLBS	IZ7			:IF NOT, DO NEXT BLOCK
	J	IZ9			:DONE
IZ8	L	R3,MACSTAT		:GET THE MAC STATUS REG
	ST	R11,MACSTAT		:CLEAR FOR SURE
	THI	R3,200			:IS IT A RANGE ERROR
	JNFS	IZ9			:IF SO, DONE
	LPSWR	R14			:IF NOT, CONTINUE
IZ9	ST	R2,MEMTOP		:SAVE TOP OF MEMORY
	EPSR	R14,R1			:DISABLE RELOCATION
	L	R4,-4,R2		:SANITY CHECK ON MEMORY
	LI	R1,12345678		:UNLIKELY VALUE
	ST	R1,-4,R2		:WRITE IT
	L	R3,-4,R2		:READ IT BACK
	CR	R1,R3			:IS IT THE SAME
	JE	IZ10			:IF SO CONTINUE
	S.HLTF(0070)			:BAD00 8770 - MEMORY INCONSISTENCY
IZ10	ST	R4,-4,R2		:RESTORE ORIGINAL VALUE
   EI  (MACV)				:Get total memory size from ISIS
	LI	R1,TOTMEM		:configuration
	CL	R1,MEMTOP		:Compare with actual memory size
	JL	IZ12			:Just skip if it's O.K.
	S.HLTF(0075)			:BAD00 8775 - Memory inconsistency
IZ12					:between ISIS configuration and 

   IF	MXP				:the actual memory size ...
	JAL	R1,IZXPI		:INITIALIZE XPI PROCESSING
   EI  (MXP)				:
					:
   IF	IPNMBR				:
        GL      IZIPI			:
        JAL     R1,IZIPI                :INITIALIZE IPIs
   EI  (IPNMBR)				:
					:
   IF   TBAUDR                          :
   ELSE                                 :not testing baudr mismatch
   	JAL     R1,IZCLOK,,             :INITIALIZE 3600 INTERRUPTS
   EI (TBAUDR)                          :
	JAL	R1,TTYINIT,,		:INITIALIZE THE TTY
					:
   IF	M.NCARD				:
	JAL	R1,M.INIT		:INITIALIZE MOTHER-BOARDS
   EI  (M.NCARD)			:
					:
   IF	MULTI				:
	JAL	R10,SRINIT		:INITIALIZE SIO RING COPY
   EI	(MULTI)				:
					:
   IF	SHARE				:
    IF	TSIDT				:
	GL	ITSIDT			:
	JAL	R1,ITSIDT,,		:INITIALIZE TSIDT STRUCTURES
    ELSE				:
	GL	ISHARE			:
	JAL	R1,ISHARE,,		:RESET CHANNELS, CONTROLLERS, ETC.
					:AND PUT OUT IMMEDIATE INT VECTOR
    EI (TSIDT)				:
   EI  (SHARE)				:
					:
   IF	SBUS				:
	JAL	R2,SBINIT		:INIT SPIRIT BUS HANDLER
   EI  (SBUS)				:
	LM	R11,MREGS2		:SET UP FOR NEXT STAGE
	SBT	R14,GMT			:FLAG "GMT" AS OUT OF DATE
	OCR	R11,R11			:INSURE THERMOMETER IS WORKING
	STH	R15,ILINT1		:SET UP TO IGNOR INTERRUPTS
	EPSR	R1,R12			:ENABLE AND FLUSH INTS...USE *F*
	NOP				:BUY SOME TIME
	NOP				:
	EPSR	R2,R1			:RETURN TO *F* WITH INTERRUPTS DISABLED
   IF   TBAUDR                          :testing baudr mismatch
	gl      baudcf                  :
	jal     r10,baudcf,,            :check for baudr mismatch
	jal     r1,izclok,,             :initialize 3600 interrupts
   EI   (TBAUDR)
   IF	NSYNC				:
	JAL	R1,ISYNC,,		:INITIALIZE THE SYNC CODE
   EI  (NSYNC)				:
					:
	STH	R13,ILINT1		:REINITIALIZE ILLEGAL INTERRUPT
					:
   IF	NPRINT				:
	JAL	R1,IPRINT		:INIT. PRINTERS
   EI	(NPRINT)			:
					:
   IF	MACV!ZITEL			:If MAC 5, 3, or 2
IECC	LHI	R1,0F0			:REG SET F, INTERRUPTS DISABLED
	EPSR	R2,R1			:
	STH	R2,SAVPSW		:SAVE TO RESTORE STATE
	ST	R0,SAVRET		:SAVE RETURN ADDRESS
	L	R1,RELPSW		:SAVE MAC INTERRRUPT VECTOR
	ST	R1,SAVMAC		:
	L	R1,RELPSW+4		:
	ST	R1,SAVMAC+4		:
	LIS	R1,0			:STORE TEMP MAC INTERRUPT VECTOR
	ST	R1,RELPSW		:
	LA	R1,IECC4		:
	ST	R1,RELPSW+4		:
	L	R1,MMPSD		:SAVE MACH MAL INTERRUPT VECTOR
	ST	R1,SAVMAL		:
	L	R1,MMPSD+4		:
	ST	R1,SAVMAL+4		:
	LIS	R1,0			:STORE TEMP MACH MAL INT VECTOR
	ST	R1,MMPSD		:
	LA	R1,IECC5		:
	ST	R1,MMPSD+4		:
					:
	LIS	R4,0E			:LOAD MAC SEGMENTS 0 - 14
	LHI	R3,MACAREA		:
	LI	R0,0FF00010		:
IECC1	ST	R0,0,R3			:
	AI	R0,10000		:
	AIS	R3,4			:
	SIS	R4,1			:
	JGE	IECC1			:
					:
	LHI	R2,4F0			:R2 IS MAC ENABLED
	LIS	R3,3			:BLOCK COUNT
	LIS	R4,0F			:64K COUNT
	LI	R0,1FF00010		:SEG F STARTING MAC REG
IECC2	ST	R0,MACAREA+0F*4	
	EPSR	R1,R2			:ENABLE MAC
	LI	R5,0F0000		:ADDRESS OF FIRST HALFWORD OF SEGMENT
	SR	R6,R6			:ZERO REG 6
	AHM	R6,0,R5			:READ AND WRITE FIRST ADD OF SEGMENT
	LI	R5,0FFFFE		:ENDING ADDRESS OF BLOCK TO COPY FROM
	LR	R6,R5			:ENDING ADDRESS OF BLOCK TO COPY TO
	LI	R7,7FFD0		:NUMB OF HALFWORDS TO COPY -1 *10
	COPY	R5,R7			:COPY SEGMENT TO ITSELF
	EPSR	R2,R1			:DISABLE MAC
	SIS	R4,1			:DEC 64K COUNT
	JL	IECC3			:
	AI	R0,10000		:SET UP MAC REEG FOR NEXT 64K
	J	IECC2			:GO DO NEXT 64K
IECC3	NI	R0,0FFF0FFFF		:SET UP MAC REG FOR NEXT BLOCK
	AI	R0,10000000		:
	LIS	R4,0F			:REINIT 64K COUNT
	SIS	R3,1			:DEC BLOCK COUNT
	JG	IECC2			:DO NEXT BLOCK
	J	IECC6			:FINISHED, LOOK FOR  ONE PARITY ERROR
					:
SAVPSW	HS	1			:AREA TO SAVE PSW
SAVMAC	WS	2			:AREA TO SAVE MAC INT VECTOR
SAVMAL	WS	2			:AREA TO SAVE MACH MAL INT VECTOR	
SAVRET	WS	1			:AREA TO SAVE RETURN ADDRESS
:
:
:	...............................................................
:	ROUTINE TO HANDLE MAC INTERRUPT
:	...............................................................
					:
IECC4	LHL	R1,MACSTAT+2		:GET MAC STATUS REG
	THI	R1,200			:IS MEMORY TIMEOUT BIT SET
	JG	IECC6			:IF SET JUMP TO LOOK FOR PARITY ERROR
	STM	R14,I.ECC		:ELSE HALT WITH CRASH CODE 56
	S.HLT0(250,I.ECC)		:
					:
:	...............................................................
:	ROUTINE TO HANDLE ONE MACHINE MALFUNCTION INTERRUPT
:	...............................................................
					:
IECC5	LHI	R1,0F0			:SWITHC TO REG SET F, INT DISABLED
	EPSR	R2,R1			:
	J	IECC7			:JUMP TO RESTORE STATE
					:
:	...............................................................
:	LOOK FOR ONE PARITY ERROR AFTER ENABLING MACHINE MALFUNCTION
:	INTERRUPT
:	...............................................................
					:
IECC6	LHI	R1,20F0			:REG SET F, MACH MAL INT ENABLED
	EPSR	R2,R1			:
	LHI	R2,$A 100		:
IECC6A	SIS	R2,1			:WAIT IN LOOP FOR MACH MAL INT
	JGBS	IECC6A			:
	LHI	R1,0F0			:REG SET F, INT DISABLED
	EPSR	R2,R1			:
					:
:	...............................................................
:	RESTORE STATE OF INTERUPT VECTORS
:	...............................................................
					:
IECC7	L	R1,SAVMAC		:RESTORE MAC INT VECTOR
	ST	R1,RELPSW		:
	L	R1,SAVMAC+4		:
	ST	R1,RELPSW+4		:
	L	R1,SAVMAL		:RESTORE MACH MAL INT VECTOR
	ST	R1,MMPSD		:
	L	R1,SAVMAL+4		:
	ST	R1,MMPSD+4		:
	LHL	R1,SAVPSW		:RESTORE ORIG STATE
	L	R0,SAVRET		:GET RETURN ADDRESS
	EPSR	R2,R1			:
					:
	LHI	R1,MEMIO1		:CLEAR MEMORY LOG
	LHI	R2,4000
IZ5	OCR	R1,R2			:"SET FOR AN I/O OPERATION"
	WDR	R1,R2			:WRITE CLEAR COMMAND
	WDR	R1,R2			:AGAIN
	AIS	R1,1			:FOR NEXT BOARD
	CHI	R1,MEMIO2		:HAVE CLEARED ALL ADDRESSES
	JLEBS	IZ5			:
   EI  (MACV!ZITEL)			:
					:
   IF	MULMAC				:
:	...............................................................
:	INITIALIZE LOCATION BDMSET TO FFFF, ALL MAC SETS ARE GOOD.
:	...............................................................
					:
	GL	BDMSET			:
	LCS	R1,1			:R1 IS ALL Fs
	STH	R1,BDMSET,,		:
   EI  (MULMAC)				:
	JR	R0			:EXIT BACK TO CALLER
					:
:	...............................................................
:	Machine Malfunction Interrupt Process
:	...............................................................
					:
MMI					:RECEIVE MACHINE MALFUNCTION INTERRUPT HERE
	JF	0F,ENTRY		:POWER UP. RESTART MACHINE
	LM	R14,MMOPSD		:GET OLD PSD
	STM	R14,MMIPSD		:
	S.HLT0(20,MMIPSD)		:CRASH WITH PARITY PSD
					:
:	..............................................................
:	
:	..............................................................
					:
	GL	ILLINT			:
					:
ILLINT	J	FLUSHI,,		:IGNORE INTERRUPTS
ILINT1	EQ	ILLINT+4		:
ILINT2	ST	R0,ILINT3		:SAVE PSD
	ST	R1,ILINT3+4		:
	S.HLT0(30,ILINT3)		:
					:...HALT 
I.ILINS	STM	R14,I.LL		:ILLEGAL INSTRUCTION
	S.HLT0(40,I.LL)			:
					:
I.MACER	STM	R14,I.LLM		:
	S.HLT0(50,I.LLM)		:
					:
I.SVCEX	STM	R14,I.LLS		:SAVE PSD
					:
	S.HLT0(60,I.LLS)		:
					:
	SUBTTL	TIMEKEEPER

:	..............................................................
:
:	TIMEX - (TimeKeeper) PERFORMS ALL INTERRUPT-LEVEL TIME-KEEPING
:		MAY EXIT VIA KERNEL TIMEOUT ROUTINE. THIS SECTION ALSO
:		HANDLES SPY CODE, UNEXPECTED INTERRUPTS, ETC.
:
:	..............................................................
					:
	GL	TIMEK,FLUSHI,LPSWR0,SPYXIT,SPYFLAG,SPY
					:
TIMEX	AM	R2,FASTC		:UPDATE FAST CLOCK
   IF	SYSMON				:
	AHM	R2,SYSTAT		:
   EI  (SYSMON)				:
	AHM	R2,SLICE		:BUMP CURRENT TIME-SLICE
	AHM	R2,LOCLKS,R3		:BUMP APPROPRIATE LOCAL CLOCK
	JFS	TIMER			:AND SKIP
TIMEK	LHI	R2,60D0			:*D*ENABLE INTERUPTS
	EPSR	R2,R2			:ENABLE INTERUPTS
	LIS	R2,1			:
	LH	R3,LOCLKX		:GET LOCAL-CLOCK INDEX
TIMER	AIS	R14,1^BAUDR		:RESET TIMEOUT
	JL	TIMEX			:EXCESSIVE TICKS...SPECIAL LOGIC REQUIRED
	AM	R2,FASTC		:UPDATE FAST CLOCK
   IF	SYSMON				:
	AHM	R2,SYSTAT		:
   EI  (SYSMON)				:
	AHM	R2,LOCLKS,R3		:BUMP APPROPRIATE LOCAL CLOCK
	AHM	R2,SLICE		:BUMP CURRENT TIME-SLICE
	JLEFS	SPYXIT			:TRY SPY IF TIME NOT YET UP
	J	KTOUT,,			:ELSE LET KERNEL HAVE MACHINE
					:
FLUSHI	RDR	R2,R3			:DO AN I/O OPERATION SO INTERRUPT SHUTS UP
SPYXIT	LH	R3,SPYFLAG		:CHECK IF SPYING
	JNFS	LPSWR0			:SKIP IF NOT
	JAL	R3,SPY,,		:ELSE GO DO IT
LPSWR0	LPSWR	R0			:
					:
:	..............................................................


	IF	SHARE
	IF	TSIDT
	ELSE
	SUBTTL	SHARED-DEVICE COMMON INTERRUPT ROUTINE AND STORAGE

	GL	DD,INTX,Q.PSW

	MO	.,SHARE

:	..............................................................
:	IMMEDIATE INTERRUPT HANDLER
:	..............................................................
					:
   IF	SHSTAT				:INCLUDE WHEN CHECKING OUT DISC APPLICATIONS
INTBAD	ST	R0,INTBVD		:INTERRUPT QUEUE VERRUN
	ST	R1,INTBVD+4		:
	S.HLT0(0662,INTBVD)		:
   EI  (SHSTAT)				:
					:
INTX	LH	2,QX			:*0*LOAD QUEUE INDEX
   IF	SHSTAT				:
	LH	4,QDATA,2		:*0*WRAP-AROUND CHECK
	JN	INTBAD			:*0*REMOVE LATER
	LIS	4,1			:*0*
	AM	4,QSTAT1		:*0*COUNT IMMEDIATE INTERRUPTS
   EI  (SHSTAT)				:
	ST	3,QDATA,2		:*0*SAVE LINKAGE REG
	LH	2,QNXT,2		:*0*SWITCH TO NEXT ENTRY
	STH	2,QX			:*0*SAVE FOR NEXT TIME
	TS	QUASIC			:*0*IS QUASI RUNNING?
	JGEFS	INTX1			:*0*IF GE, NO
	LPSWR	0			:*0*ELSE RETURN TO USER
INTX1	ST	0,DSAVE			:*0*SAVE USER PSD
	ST	1,DSAVE+4		:*0*
	LPSW	DDP			:*0*START SCANNER RUNNING WITH
					:INTERRUPTS ENABLED, REG. SET 0E!
Q.PSW	EQ	20E0			:PSW USED FOR QUASI CODE
DDP	WC	I.ENA!Q.PSW,DD		:PSD TO RUN QUASI, INTERRUPTS ENABLED
					:
DSAVE	WS	$A 12			:SAVED PSD AND R6-R15
	IF	SHSTAT
QSTAT1	WS	1			:NO. OF TIMES IMMEDIATE INTS OCCURRED
QSTAT2	WS	1			:NO. OF TIMES QUASI RUN
QSTAT3	WS	1			:NO. OF TIMES UNIT SCANNER RUN
QSTAT4	WS	1			:NO. OF TIMES CHANNEL SCANNER RUN
QSTAT5	WS	1			:NO. OF TIMES CHANNEL I/O STARTED
	EI	(SHSTAT)

QUASIC	HC	0			:NONZERO IF QUASI CODE RUNNING
QX	HC	0			:INDEX USED BY IMMEDIATE INT HANDLER
QX1	HC	0			:QUASI INDEX -- CATCHES UP TO QX
QSIZ	EQ	10			:SIZE OF QUASI INT QUEUE

:	CIRCULAR QUEUE OF INTERRUPTS TAKEN
QDATA	RE	QSIZ
	HC	0,0
	ER

:	CIRCULAR TABLE OF "NEXT" QUEUE INDEX
Q	EQ	4			:POINT TO NEXT
QNXT	RE	QSIZ-1
	HC	Q,0			:FOR SPEED, FULL-WORD INDEXING, BUT
Q	EQ	Q+4			: ...DATA IS ONLY IN FIRST HALFWORD
	ER
	HC	0			:LAST POINTS TO 1ST
	EM

	IF	ESELCH

	SUBTTL	INTERRUPT ROUTINES FOR DEVICE AND CHANNEL END

:	MUST BE LOCATED IN FIRST 64K OF MEMORY
	MO	.,ES.INT

:	.....................................................................
:	Note: Interrupt routines for device and channel end must be located
:	      in the first 64K of memory.
:	.....................................................................
					:
   IF	NDISC				:
	GL	DCP			:
   EI  (NDISC)				:
					:
UNT	EQ	0			:

INTDEF	MACRO(ADDR)[
INTV|UNT| JAL	3,INTX			:*0*
	HC	DUCB|UNT|,ADDR
	GL	DUCB|UNT|,ADDR
UNT	EQ	UNT+1
]					:
					:
:	EXTENDED SELECTOR CHANNELS

	INTDEF(RCHEND)			:
   IF	XSELCH				:
	INTDEF(RCHEND)			:
   EI  (XSELCH)				:
   IF	NDISC				:
	INTDEF(RDVEND)			:1ST DISC CONTROLLER
	INTDEF(RDVEND)			:UNIT 0 REMOVABLE
	INTDEF(RDVEND)			:UNIT 1 FIXED
    IF	NDISC-1				:
	INTDEF(RDVEND)			:UNIT 2 REMOVABLE
	INTDEF(RDVEND)			:UNIT 3 FIXED
    IF	NDISC-2				:
	INTDEF(RDVEND)			:UNIT 4 REMOVABLE
	INTDEF(RDVEND)			:UNIT 5 FIXED
    IF	NDISC-3				:
	INTDEF(RDVEND)			:UNIT 6 REMOVABLE
	INTDEF(RDVEND)			:UNIT 7 FIXED
    IF	NDISC-4				:
	INTDEF(RDVEND)			:2ND DISC CONTROLLER
	INTDEF(RDVEND)			:UNIT 0 REMOVABLE
	INTDEF(RDVEND)			:UNIT 1 FIXED
    IF	NDISC-5				:
	INTDEF(RDVEND)			:UNIT 2 REMOVABLE
	INTDEF(RDVEND)			:UNIT 3 FIXED
    IF	NDISC-6				:
	INTDEF(RDVEND)			:UNIT 4 REMOVABLE
	INTDEF(RDVEND)			:UNIT 5 FIXED
    IF	NDISC-7				:
	INTDEF(RDVEND)			:UNIT 6 REMOVABLE
	INTDEF(RDVEND)			:UNIT 7 FIXED
    EI (NDISC-7)			:
    EI (NDISC-6)			:
    EI (NDISC-5)			:
    EI (NDISC-4)			:
    EI (NDISC-3)			:
    EI (NDISC-2)			:
    EI (NDISC-1)			:
   EI  (NDISC)				:

   IF	NTAPE				:
	INTDEF(RDVEND)			:TAPE CONTROLLER 0 UNIT 0
   EI  (NTAPE)				:
   IF	NTAPE-1				:
	INTDEF(RDVEND)			:TAPE CONTROLLER 0 UNIT 1
   EI  (NTAPE-1)			:
   IF	NTAPE-2				:
	INTDEF(RDVEND)			:TAPE CONTROLLER 0 UNIT 2
   EI  (NTAPE-2)			:
   IF	NTAPE-3				:
	INTDEF(RDVEND)			:TAPE CONTROLLER 0 UNIT 3
   EI  (NTAPE-3)			:
   IF	NTAPE-4				:
	INTDEF(RDVEND)			:TAPE CONTROLLER 1 UNIT 0
   EI  (NTAPE-4)			:
   IF	NTAPE-5				:
	INTDEF(RDVEND)			:TAPE CONTROLLER 1 UNIT 1
   EI  (NTAPE-5)			:
   IF	NTAPE-6				:
	INTDEF(RDVEND)			:TAPE CONTROLLER 1 UNIT 2
   EI  (NTAPE-6)			:
   IF	NTAPE-7				:
	INTDEF(RDVEND)			:TAPE CONTROLLER 1 UNIT 3
   EI  (NTAPE-7)			:
					:
	KILL	INTDEF			:KILL MACRO DEFINITION
	EM				:
	EI	(ESELCH)		:

	IF	MSCDSK
	SUBTTL	STORAGE FOR MSC-1400 DISC CONTROLLER

	MO	.,MSC.INT

Q	HS	0
:	LAYOUT OF "SUPER-PACKET"
	ORG	0
PK.DPB	HS	1			:POINTER TO CONTROLLING DPB
PK.HND	HS	1			:HANDLER (REL. ADDR)
PK.LNK	WS	1			:LINK WORD
PK.SMA	WS	1			:STARTING MEMORY ADDRESS
PK.WC	WS	1			:WORD COUNT
PK.LSA	WS	1			:LOGICAL SECTOR ADDRESS
PK.CMD	HS	1			:COMMAND
PK.STA	HS	1			:STATUS
PK.FAU	HS	1			:SYSTEM FAULT CODE
PK.ID	HS	3			:RECORD ID
PK.FLG	HS	1			:FLAG WORD
PK.SFG  HS      1                       :SAVE AREA FOR FLAG DURING RECAL
PK.SST  HS      1                       :SAVE AREA FOR STATUS DUREING RECAL
PK.RTC  HS      1                       :RETRY COUNT FOROFFSETS
PK.XMA  WS      1                       :COPY OF MEMORY ADDRESS
PK.XWC  WS      1                       :COPY OF COUNT
PK.XSA  WS      1                       :COPY OF SECTOR ADDRESS
PK.SIZ	HS	0			:SIZE OF PACKET BLOCK

:	DEFINE FIFO RINGS
	ORG	0
MSC.PT	HS	1			:POINTER TO NEXT FIFO RING ENTRY
MSC.IT	HS	1			:FOLD-POINTER TO FIRST FIFO RING ENTRY
MRSIZE	EQ	4*20			:THE SIZE OF EACH FIFO RING (BYTES)
MSC.FF	HS	MRSIZE/2		:THE BEGINNING OF THE FIFO RING
MSC.ND	HS	2			:END OF THE FIFO RING

	ORG	Q			:END OF DESCRIPTOR

:	NOW GENERATE ACTUAL ENTRY
Q	EQ	0			:
	RE	MSCDSK			:FOR EACH CONTROLLER:
MSC.C|Q| WC	.+4			:INDEX | FOLD-POINT
	HS	MRSIZE/2
	HC	0010,MSC.C|Q|+MSC.FF	:POINTER BACK TO BEGINNING OF LIST
Q	EQ	Q+1
	ER				:
					:
:	SPECIAL PACKET FOR RE-CALIBRATE
RECALI	WC	-1,0,0,0,120000,0,0
RECALF	HC	0			:FLAG FOR RECALIBRATE PACKET

:
:TRACE TABLE.  TR.MSC IS A HALF-WORD TRACE INDEX.  IT IS LIMITED TO
:VALUES BETWEEN 0 AND FF.  EACH ENTRY IS TWO HALF WORDS .  THE FIRST
:HALF-WORD IS THE STATUS THE SECOND IS THE FLAG.
:
TR.MSC  HC      0
TRR.MSC HS      80
:
MSC.RT  BC      18
MSC.RY	BC	11			:"READY" COMMAND
MSC.CL	BC	14			:"CLEAR" COMMAND
MSC.LA	BC	20			:FIFO LIST COMMAND
MSC.IM	BC	28			:"IMMEDIATE ADDRESS" COMMAND
MSC.EN	BC	40			:"ENABLE INTERRUPTS" COMMAND

:	NOW DEFINE GENERALIZED INTERRUPT ROUTINE
MSC.I	LHI	R4,6200			:*0*ENABLE INTERUPTS
	EPSR	R4,R4
	RDR	2,4			:GET PACKET ADDRESS (A/2)
	CLHI	4,RECALI/2		:WAS IT "RECALIBRATE"?
	JE	MSC.I3			:SKIP TO PICK UP THE PIECES IF SO
MSC.I1	SSR	2,6			:ELSE WAIT FOR CONTROLLER
	JTBS	8,MSC.I1		:
	AR	4,4			:CONVERT TO BYTE ADDRESS
	LR	3,4			:COMPUTE ACTUAL ADDRESS
	SIS	3,PK.LNK		:FORCE TO BEGINNING OF BLOCK
:
:THE FOLLOWING CHECKS TO SEE IF THE THIS PACKET CONTAINS A
:RECALIBRATE COMMAND.  IF SO IT MUST HAVE COME FROM A RETRY
:ISSUED EARLIER.  THAT BEING THE CASE THE STATUS FROM THE
:ORIGINAL ERROR MUST BE PLACED INTO THIS PACKET AND PASSED ON TO
:THE ORIGINAL REQUESTING SLOT.
:
        LHL     R5,PK.CMD,R3            :GET THE COMMAND
        CHI     R5,12                   :CHECK FOR RECALIBRATE
        JN      MSC.R1                  :SKIP IF THIS WAS NOT A RECAL
:
        LHL     R6,PK.SFG,R3            :GET ORIGINAL FLAG
        STH     R6,PK.FLG,R3
        LHL     R6,PK.SST,R3            :GET ORIGINAL STATUS
        STH     R6,PK.STA,R3
        LHL     R5,PK.FLG,R3
        J       MSC.I2                  :PROCESS AS DONE
:
MSC.R1	LH	5,PK.FLG,3		:CHECK FOR ERRORS
	JGE	MSC.I2			:NONE...SKIP TO CLEAR
	LH	6,PK.STA,3		:CHECK STATUS
	JL	MSC.I2			:SKIP IF ANY FAULT
	THI	R6,1			:IS DRIVE SELECTED
	JN	MSC.I2			:IF NOT, DO NOT RETRY
        THI     R6,48                   :DO A RECAL ON THESE ERRORS
        JN      MSC.R3
        THI     R6,7                    :CHECK ON BUSY NR AND NOT SELECTED
        JN      MSC.I2                  :ERROR
:
        THI     R6,4800                 :THESE MIGHT LIKE AN OFFSET READ
        JE      MSC.R2                  :SKIP IF NOT
:
:CANDIDATE FOR A RETRY WITH OFFSET OR STROBE PROVIDED THIS IS
:A READ AND RETRIES ARE NOT YET EXHAUSTED.
:
        LHL     R5,PK.CMD,R3            :IS THIS A READ?
        THI     R5,20
        JE      MSC.R2                  :NOT A READ
:
        LHL     R5,PK.RTC,R3            :CONSTRUCT NEXT OP
        OHI     R5,20                   :MAKE A READ COMMAND
        STH     R5,PK.CMD,R3
:
        AIS     R5,1                    :CHECK LIMIT ON RETRIES
        CHI     R5,29
        JG      MSC.R3                  :OUT OF RETRIES
        STH     R5,PK.RTC,R3
:
        LM      R13,PK.XMA,R3           :RESET COUNTS AND ADDRESSES
        STM     R13,PK.SMA,R3
        J       MSC.R4
:
:OPERATION IS NOT A CANDIDATE FOR OFFSET
:CHECK FOR BIT 2.  IF ON DO A RECAL
:
MSC.R2  LHL     R5,PK.FLG,R3
        THI     R6,2000
        JE      MSC.I2
:
:AN ATTEMPT WILL BE MADE TO FIX THE CURRENT PROBLEMS WITH A
:RECALIBRATE.  THIS WILL BE DONE BY CHANGING THE CURRENT 
:PACKET INTO A RECALIBRATE COMMAND.  NO ATTEMPT WILL BE
:MADE TO REISSUE THE ORIGINAL COMMAND.  THE STATUS FROM THIS
:ERROR WILL BE RETURNED TO THE REQUESTING JOB ONCE THE
:RECALIBRATE IS COMPLETE
:
MSC.R3  STH     R6,PK.SST,R3            :SAVE STATUS
        LHL     R7,PK.FLG,R3            :SAVE FLAG
        STH     R7,PK.SFG,R3   
:
        LHL     R5,TR.MSC               :GET ERROR TRACE INDEX
        STH     R6,TRR.MSC,R5
        STH     R7,TRR.MSC+2,R5
        AIS     R5,4
        LBR     R5,R5
        STH     R5,TR.MSC
:
        LHI     R6,12                   :BUILD RECALIBRATE PACKET
        STH     R6,PK.CMD,R3
MSC.R4  OC      R2,MSC.RT               
        OC      R2,MSC.CL               :ISSUE CLEAR
        LPSWR   R0
:
MSC.I2	OC	2,MSC.CL		:**CLEAR CONTROLLER
	THI	5,2000			:CHECK IF INTERRUPT WAS EXPECTED
	JN	INTX			:YES...PASS TO COMMON ROUTINE...
					:    IN CHARGE OF QUEUEING INTERRUPTS
	LPSWR	0			:NO...JUST EXIT AND IGNORE IT

:	HAVE DETECTED THE COMPLETION OF A "RECALIBRATE" PACKET
:		RE-INITIALIZE CONTROLLER'S FIFO POINTER
MSC.I3	LHI	4,20			:SET UP COUNTER
MSC.I4	SSR	2,6			:WAIT FOR CONTROLLER
	JFFS	8,MSC.I5		:NOT BUSY...SKIP
	SIS	4,1			:BUSY...TIMEOUT
	JGEBS	MSC.I4			:
MSC.I5	OC	2,MSC.CL		:"CLEAR" CONTROLLER
	LHL	3,MSC.C0+MSC.PT		:GET POINTER TO CURRENT ENTRY
	LHL	4,0,3			:CHECK IF FULL
	JNFS	MSC.I8			:SKIP IF SO
MSC.I6	LHI	4,-4,3			:ELSE LOOK BACKWARD
	CLH	4,MSC.C0+MSC.IT		:CHECK FOR FOLDING
	JGEFS	MSC.I7			:SKIP IF NOT
	AHI	4,MRSIZE		:ELSE FOLD IT
MSC.I7	LHL	5,0,4			:CHECK THAT ENTRY
	JEFS	MSC.I8			:LAST ENTRY NULL...SET UP TO CURRENT ENTRY
	LR	3,4			:ELSE COPY POINTER TO LAST
	JBS	MSC.I6			:AND REPEAT SCAN TO HEAD OF LIST
MSC.I8	SRHLS	3,1			:SET HALF-WORD ADDRESS
	OC	2,MSC.LA		:GIVE CONTROLLER THE ADDRESS
	WDR	2,3			:
	LH	R3,0,R3,R3		:CHECK IF ANYTHING QUEUED UP
	JE	MSC.I9			:SKIP IF NOT
	OC	2,MSC.RY		:ELSE "READY" CONTROLLER
MSC.I9	LPSWR	0			:AND EXIT

:	ROUTINE TO OUTPUT A RECALIBRATE PACKET, TO INTERRUPT WHEN DONE
:	R2	DEVICE ADDRESS
:	R3	LINK
:	R4	PACKET LINK POINTER... -1 IF NONE
:	R5	DRIVE #
:	R6,R7	SCRATCH REGISTER
MSC.RE	LIS	6,1			:*x*INSURE RECALIBRATE PACKET NOT IN USE
	LI	R7,100000		:*X*SET UP A COUNTER HERE
MS.RE1	TBT	R6,RECALF		:*x*LOOKING FOR "DONE"
	JN	MS.RE2			:*X*
	SIS	R7,1
	JGBS	MS.RE1			:*X* THE CONTROLLER IS LOCKED UP IF THIS COUNTS DOWN
	ST	R0,MS.REX	
	ST	R1,MS.REX+4
	S.HLT0(0C62,MS.REX)
MS.RE2	ST	4,RECALI		:*x*LINK TO RECALIBRATE COMMAND
	OHI	5,2000			:*x*SET INTERRUPT ON "DONE"
	STH	5,RECALF		:*x*
	OC	2,MSC.IM		:*x*"IMMEDIATE ADDRESS" COMMAND
	LHI	5,(RECALI/2)		:*x*ADDRESS OF PACKET
	WDR	2,5			:*x*
	JR	3			:*x*
	EM
	EI	(MSCDSK)

	EI	(TSIDT)
	EI	(SHARE)


	IF	NSYNC			:

	SUBTTL	SYNC-CARD HANDLER

	MO	.,SYNC			:


Q	EQ	.			:REMEMBER WHERE WE ARE
	ORG	0
:	DEFINE SYNCHRONOUS I/O DEVICE BLOCK


LUATRB	BS	1		:B  LOGICAL UNIT ATRIBUTES
OPLN	BS	1		:B  PHYSICAL LINE NUMBER
	BS	1		:B  ATRIBUTE DATA
OPIX	BS	1		:B  PHYSICAL INTERRUPT INDEX
OAO	HS	2		:   OUTPUT ADDR OFFSET (SUBTR FROM ADDR)
OALL	HS	2		:   OUTPUT ADDRESS LOW LIMIT
OAHL	HS	2		:   OUTPUT ADDRESS HIGH LIMIT
ODA	HS	2		:   OUTPUT DESCRIPTOR ADDRESS
COC	HS	2		:   CURR OUTPUT CHARS (POINT TO END OF MSG)
OCC	HS	1		:H  OUTPUT CHAR COUNT
OPHW	HS	1		:H  OUTPUT PAD HALFWORD
IBA	HS	2		:   INPUT RING-BUFFER ADDRESS
ODSRBP	HS	2		:   "DSR" BIT POINTER
OCSBP	HS	2		:   "CS" BIT POINTER
IFP	HS	1		:H  INPUT FOLD POINT
SXMRKF	HS	1		:H  MARK FLAG
SXACK	HS	1		:H  FOR SAVING ACK
SXRTR	HS	1		:H  FOR COUNTING RETRANS
SXCTR	HS	1		:H  FOR COUNTING TRANS
SXRETN	HS	1		:H  TEMP STORAGE FOR SXINT
OLBITX	HS	1		:H  OUTPUT "RS", "CS" INDEX
	IF	HMICRO!TSI!NANO
LINIT	HS	1		:H  LINE INIT FLAG
HRPOP	HS	1		:H  REPOP DURING INIT FLAG
	EI	(HMICRO!TSI!NANO)
	IF	ESYNCI
OESIPT	HS	1		:H  ENHANCED SYNC INTERRUPT PTR
OSLOTO	HS	1		:H  ENHANCED SYNC SLOT OWNER
	EI	(ESYNCI)
SIOBL	HS	0		:SYNCHRONOUS I/O BLOCK LENGTH


:	SPECIAL SOFTWARE FOR THE TYMNET-II NODE CODE EXECUTING
:	UNDER ISIS.

:	SXINT PARAMETERS:

NRSMRK	EQ	$A 64			:# OF MARKS PRECEEDING RESET


:	LINK DESCRIPTOR VARIABLES:

	ORG	0

	HS	1			:NODE NUMBER
	BS	1			:LINK TYPE (***HWB)
	BS	1			:RECEIVED B-O-R INDICATOR
	BS	1			:4*(# OF LINES ATTACHED)
	BS	1			:4*(# OF LINES ASSEMBLED)
	BS	2			:LINK SPEED (+ 1 UNUSED BYTE)
	HS	1			:NUMBER OF CHANNELS
	HS	1			:PTR TO START OF INPUT RING
	HS	1			:PTR TO NEXT RECORD TO TEAR
AMSK	HS	1			:MASK FOR ACK TRUNCATION
	HS	1			:DITTO OUTPUT
	HS	1			:PTR TO NEXT RECORD TO MAKE
NRXM	HS	1			:PTR TO NEXT RECORD TO TRANSMIT
LRT	HS	1			:LAST RECORD TORN
LAS	HS	1			:LAST ACKNOWLEDGEMENT SENT
	HS	1			:LAST RECORD MADE
LAR	HS	1			:LAST ACKNOWLEDGEMENT RECEIVED
	HS	1			:NEXT ACK TO BE SENT
	HS	1			:NODE NUMBER WHEN DOWN OR 0
IDLE	HS	1			:FLAG FOR IDLE OUTPUT


	IF	TIINEW
PKTMSZ	EQ	20		:SIZE PARAMETER
PKTTIM	HS	PKTMSZ		:TIME OF PACKET CREATION BY RMAKE
KS.PQC	HS	2		:ACCUMULATOR OF PACKET QUEUEING DELAYS
	EI
:	RECORD DESCRIPTOR VARIABLES:

	ORG	0

RECN	HS	1			:RECORD NUMBER
RLNK	HS	1			:PTR TO NEXT RECORD IN BUFFER
EREC	HS	1			:PTR TO END OF DATA (FOLLOWS R10)
BREC	HS	1			:PTR TO BEGINNING OF DATA (VERT CHKSM)
RBSY	BS	1			:BUSY FLAG (**PRECEDES LLXM, HWB)
LLXM	BS	1			:LINE LAST TRANSMITTED BY (DEV NUM)
RSHF	BS	1			:SHIFT COUNT FOR DIAG CHKSM

	ORG	Q

XDUMM	HS	6
RSENT	HS	6

SYRESZ	HC	1			:NEGATIVE SIZE OF TYMNET-II RESET
TWDUMM	HC	3069,78AB,3069%78AB	:DUMMY RECORD
	HC	3069^2%78AB^1%3069%78AB


:	MACRO TO DEFINE A SYNC LINE DESCRIPTOR BLOCK IN CORRECT FORMAT
SYNBLK	MACRO(N)[
SLDB|N|	HS	0
QQ	EQ	-1;	IF	(N&2);QQ	  EQ	8
	  IF	N-10;QQ	    EQ	10;	  EI
QQ	  EQ	((@2&N)/2+(N&1))+QQ;	EI
	BC	2,N
	IF	HMICRO!TSI!NANO
	BC	80			:ALL LINES HAVE STATUS W/ HDLC
	ELSE
	BC	(QQ&80)%80
	EI	(HMICRO!TSI!NANO)
	BC	4*N
	ORG	SLDB|N|+OPHW;	HC	-1
	ORG	SLDB|N|+OLBITX
	IF	HMICRO!TSI!NANO
	HC	N			:ALL LINES HAVE STATUS W/ HDLC
	ELSE
	HC	QQ
	EI	(HMICRO!TSI!NANO)
	IF	ESYNCI
	ORG	SLDB|N|+OESIPT
	IF	HMICRO!TSI!NANO
	HC	400+N*0C,-1
	ELSE
	HC	400+N*0A,-1
	EI	(HMICRO!TSI!NANO)
	EI	(ESYNCI)]

:	SYNCHRONOUS LINE DESCRIPTORS
Q	EQ	0;	RE	PSPORT			:BOTH SYNC CARDS IF PRESENT
	SYNBLK(Q)
Q	EQ	Q+1;	NOLIST;	ER;	LIST


:	SYNCHRONOUS LINE DESCRIPTOR POINTERS (HALFWORDS)
SPORT	HS	0
Q	EQ	0;	RE	PSPORT			:DO FOR ALL SYNC PORTS
	HC	SLDB|Q|
Q	EQ	Q+1;	ER

   IF	HMICRO!TSI!NANO
:	SIO COMMANDS AND CHANNEL PROGRAMS FOR SYNC EMULATION
:	ON THE HDLC MICRO-ENGINE

HDEV	EQ	80		: SIO DEVICE #

HCMD0	EQ	0000!HDEV	: START INPUT COMMAND
HCMD1	EQ	1000!HDEV	: START OUTPUT COMMAND
HCMD8	EQ	8000!HDEV	: EMULATE & STORE STATUS COMMAND
HCMD9	EQ	9000!HDEV	: OUTPUT DATA
HCMDA	EQ	0A000!HDEV	: OUTPUT IMMEDIATE CCW

	BND	100
HPAIR1	WC	00030018	: CHANNEL PROGRAM TO INITIALIZE SIO
	WC	00034410
	WC	00038100
	WC	000316FF
	WC	000317FF
	WC	00030560
	WC	000703C2
	WC	00000000

	BND	10
HPAIR2	WC	0003F5EA	: CHANNEL PROGRAM TO RAISE DTR &
	WC	000703D1	: ENABLE XMIT & RECIEVE
	WC	00000000

	BND	10
HPAIR3	WC	00060000	: ENABLE INPUT ON CHANNEL


HSTAT	EQ	00000568	: CHAN PGM THAT WILL LOWER BOTH DTR
				: & RTS. IT MUST BE OR'ED WITH HDTR
				: OR HRTS IF STATUS IS TO BE PRESERVED
				: (IF ON) OR RAISED (IF OFF).
HDTR	EQ	80		: MASK TO RAISE DTR
HRTS	EQ	02		: MASK TO RAISE RTS

	BND	10
HSDSR	HS	1		: DSR STATUS AREA
HSCTS	HS	1		: CTS STATUS AREA
HSDTR	HS	1		: DTR STATUS AREA
HSRTS	HS	1		: RTS STATUS AREA

HTIME	EQ	$A30		: TIME GIVEN TO A SYNC EMULATED
				: LINE TO INIT BEFORE A DIAGNOSTIC
				: IS ISSUED

	GL	IHINT,HTIMER
HISTAT	HS	1		: STORE STATUS INIT FLAG
HTIMER	HS	1		: LINE INIT TIMER
HMASK	HS	1		: MASK FOR CHANNEL SELECTION
HSYNCL	HC	SYNCL		: SYNC LINES THAT ARE PRESENT
IHINT	HC	0		: ARRAY OF LINES EXP INTS ON 80

	
	IF	HTEST
	GL	HLEN,HINDEX,HTBL,MLEN,MINDEX,MTBL,HSAVE,MSAVE
HLINE	HS	10
HSAVE	WS	2
MSAVE	WS	2
HLEN	EQ	400
HINDEX	WC	0,0,0,0
HTBL	WS	HLEN/4
MLEN	EQ	400
MINDEX	WC	0,0,0,0
MTBL	WS	MLEN/4
	EI	(HTEST)

HLOG	MACRO(REG1,REG2)[
   IF	HTEST
	ST	R10,HSAVE
	ST	R11,HSAVE+4
	LHL	R10,HINDEX
	L	R11,FASTC,,
	ST	R11,HTBL,R10
	ST	REG1,HTBL+4,R10
	ST	REG2,HTBL+8,R10
	LA	R11,.
	ST	R11,HTBL+0C,R10
	AHI	R10,10
	NHI	R10,HLEN-1
	STH	R10,HINDEX
	L	R10,HSAVE
	L	R11,HSAVE+4
   EI  (HTEST)
]

MLOG	MACRO(REG1,REG2)[
	IF	HTEST
	ST	R10,MSAVE
	ST	R11,MSAVE+4
	LHL	R10,MINDEX
	L	R11,FASTC,,
	ST	R11,MTBL,R10
	ST	REG1,MTBL+4,R10
	ST	REG2,MTBL+8,R10
	LA	R11,.
	ST	R11,MTBL+0C,R10
	AHI	R10,10
	NHI	R10,MLEN-1
	STH	R10,MINDEX
	L	R10,MSAVE
	L	R11,MSAVE+4
	EI	(HTEST)
]

   EI  (HMICRO!TSI!NANO)

:	...............................................................
:
:	Historical Note(s):
:	SIGNALS ARE "FUNNY"...THEY ONLY APPEAR ON CERTAIN SYNC LINES 
:	(2,3,6,7,10,11,14,15) AND ARE MAPPED INTO CONTIGUOUS BITS IN
:	A BYTE. ONE I/O COMMAND SETS 2(!) DIFFERENT PARAMETERS FOR A
:	CARD!
:
:	OUT		DTR		RS
:		*********************************
:	HW	*	 1 1 1 1*	 1 1 1 1*
:	BITS	*2 3 6 7 0 1 4 5*2 3 6 7 0 1 4 5*
:		*********************************
:	IN		DSR		CS
:
:	NOTE:THE HDLC MICRO-ENGINE AND TSI (HMICRO!TSI!NANO) HAVE STATUS
:	     SIGNALS FOR ALL OF ITS SYNC CHANNELS IN EMULATION MODE.
:
:	...............................................................
					:
SDTR	HS	1+XSYNC			:WORD FOR DTR BITS (INCLUDE EXTRA SYNC CARD IF THERE)
SDSR	HS	1+XSYNC			:WORD FOR DSR BITS INPUT
					:
:	...............................................................
:	INITIALIZE SYNC TABLES
:	...............................................................
					:
ISYNC	LHI	R2,(PSPORT-1)*2		:SET HALF-WORD INDICES
   IF	HMICRO!TSI!NANO			:
	LCS	R3,1			:
	ST	R3,HSDTR		:TURN OFF DTR & RTS ON ALL CHANS
   ELSE					:
:	..................................................................	
:	function to determine if there are excessive sync boards are
:	configured and to crash isis with a bad00 8778 in that case.
:	the ssr status return is 8 for busy 4 for device fails after
:	2 ms. and 0 for success.
:	....................................................................
	if	(1-pxl)			:no check on pxl	
	lhi	r3,0bf			:check for sync board
	ssr	r3,r3			:sense status on board
	jtfs	4,s.hltx		:check fail
	if	xsync			:second board called out
	lhi	r3,0ff			:check for second sync board
	ssr	r3,r3			:sense status on board
	jtfs	4,s.hltx		:check for fail
	ei	(xsync)
	jfs	isync0			:sync board test passes
s.hltx	s.hltf(0078)
	ei	(1-pxl)
isync0	LHI	R3,00FF			:
	STH	R3,SDTR			:
   IF	XSYNC				:
	STH	R3,SDTR+2		:SECOND CARD
   EI  (XSYNC)				:
	LHI	R4,0BF			:NOW DRIVE DTR (HIGH BYTE) AND RS (LOW BYTE)
	WDR	R4,R3			:
   IF	XSYNC				:
	WDR	R3,R3			:
   EI  (XSYBC)				:
	L	R4,ISYNCA		:SET UP INT ADDRESSES
   EI  (HMICRO!TSI!NANO)		:
	LIS	R3,0			:SET UP A NULL
					:
   IF	ESYNCI				:
	LA	R7,CIINUL		:FORCE SOFTWARE INTERRUPT
   EI  (ESYNCI)				:
					:
ISYNC1	LHL	R5,SPORT,R2		:GET POINTER TO A BLOCK
	ST	R3,IBA,R5		:SET INPUT NULL
	ST	R3,COC,R5		:SET OUTPUT NULL
	ST	R3,ODSRBP,R5		:SET NULL 'DSR' POINTER
	ST	R3,OCSBP,R5		:SET NULL 'CS' POINTER
   IF	HMICRO!TSI!NANO			:
	STH	R3,LINIT,R5		:SET LINE INIT FLAG
	STH	R3,HRPOP,R5		:SET REPOP FLAG
   EI  (HMICRO!TSI!NANO)		:
					:
   IF	ESYNCI				:
	LHL	R6,OESIPT,R5		:PTR TO ENHANCED INT BLOCK
	STH	R3,OIX,R6		:FORCE SOFTWARE OUTPUT INT
	ST	R3,OEAD,R6		:NULL OUTPUT ADDR
	ST	R7,CIIPTR,R6		:FORCE SOFTWARE INPUT INT
   EI  (ESYNCI)				:
					:
   IF	HMICRO!TSI!NANO			:
	LHL	R4,OPHW,R5		:GET OUTPUT PAD HW
	STH	R4,OPAD,R6		:INIT INT BLOCK PAD
   ELSE					:
	LB	R5,OPIX,R5		:GET INTERRUPT INDEX
	ST	R4,SYNVEC,R5		:SET UP SYNC VECTOR
   EI	(HMICRO!TSI!NANO)		:
	SIS	R2,2			:
	JGE	ISYNC1			:DO FOR ALL LINES
   IF	HMICRO!TSI!NANO			:
	JAL	R2,IHSYN		:INIT HDLC SYNC CHANNELS
   EI	(HMICRO!TSI!NANO)		:
	JR	R1			:AND RETURN
					:
   IF	ESYNCI				:
ISYNCA	HC	SIN2,S.MARK		:
   ELSE					:
ISYNCA	HC	S.IN,S.MARK		:
   EI  (ESYNCI)				:
					:
   IF	HMICRO!TSI!NANO			:
:	INITIALIZE ALL HDLC MICRO-ENGINE CHANNELS THAT ARE EMULATING
:	TYMNET SYNC. THE INITIALIZATION PROCESS IS A SERIES OF STEPS
:	THAT MUST BE PROCESSED SEQUENTIALLY FOR EACH CHANNEL. THIS
:	ROUTINE BEGINS THIS PROCESS FOR EACH CHANNEL AND THE REMAINDER
:	OF THE STEPS ARE INTERRUPT DRIVEN.

IHSYN	LIS	R3,0			:GET A NULL
	STH	R3,IHINT		:ZERO INTERRUPT EXP ARRAY
	IF	HTEST
	STH	R3,HINDEX		:ZERO TRACE INDEX
	STH	R3,MINDEX		:ZERO TRACE INDEX
	EI	(HTEST)
	STH	R3,HISTAT		:SET STORE STAT NOT INIT'ED
	ST	R3,HSDSR		:SET DSR & CTS INACTIVE
	LHI	R3,HTIME		:GET MAX INIT FOR EMUL LINES
	STH	R3,HTIMER		:LOAD TIMER
	LCS	R3,1
	ST	R3,HSDTR		:SET DTR & RTS INACTIVE
	STH	R3,HMASK		:INIT LINES PROCESSED MASK
	LHL	R4,HSYNCL  		:GET ARRAY OF LINES USED

IHSYN1	NH	R4,HMASK		:EXCLUDE LINES PROCESSED
	JFFOH	R4,IHSYN2		:FIND NEXT LINE
	JR	R2			:RETURN, IF DONE

IHSYN2	RBT	R5,HMASK		:MARK IT STARTED
	lhi	r7,0d0			:set up timer
	epsr	r6,r7			:set up psw
	lhi	r14,rate/4		:250 millisec pause
	la	r15,IHSP03
	lhi	r13,60f0
	epsr	r12,r13
	LIS	R7,0F			:GET HIGHEST LINE #
	SR	R7,R5			:GET LINE # (ARRAY IS REV ORDER)
	SBT	R7,IHINT		:SIGNAL INT EXP ON DEV 80
	SBT	R7,HSDTR		:SET DTR INACTIVE
	SBT	R7,HSRTS		:SET RTS INACTIVE
	LHI	R6,IHSYN3		:GET ADDR OF NEXT INIT STEP
	SLLS	R7,1			:MAKE HW INDEX
	STH	R6,SYNVEC+2,R7,R7	:PLACE IN VECTOR TABLE
	SLLS	R7,7			:MOVE LINE # TO HIGH BYTE
	OI	R7,HCMD1		:MAKE START OUTPUT CMD
	LI	R6,HPAIR1/10		:GET QUAD ADDR OF CHAN PGM
	HLOG(R7,R6)
	WDR	R7,R6			:INIT SIO FOR THIS CHAN
ihsp02	lis	r5,5			:see enhanced async timer interrupts
	wdr	r5,r5			
	jbs	ihsp02
ihsp03	lhi	r13,20f0		:turn off i/o interrupts
	lis	r14,8			:and restore timkeeper things
	la	r15,timek		:in case this is the last line
	epsr	r12,r13
	J	IHSYN1			:DO NEXT LINE

IHSYN3	LHI	R3,IHSYN4		:GET ADDR OF NEXT INIT STEP
	STH	R3,SYNVEC-40,R2,R2	:PLACE IN VECTOR TABLE
	SHI	R2,21			:MAKE LINE #
	SLLS	R2,7			:MOVE LINE # TO HIGH BYTE
	OI	R2,HCMD8		:MAKE SYNC EMULATION CMD
	LIS	R3,1
	HLOG(R2,R3)
	WDR	R2,R3			:START SYNC EMULATION
	LPSWR	R0			:RETURN

IHSYN4	LHI	R3,IHSYN5		:GET ADDR OF NEXT INIT STEP
	STH	R3,SYNVEC-40,R2,R2	:PLACE IN VECTOR TABLE
	SHI	R2,21			:LINE # * 2
	SRLS	R2,1			:MAKE LINE #
	RBT	R2,HSDTR		:SET DTR ACTIVE
	RBT	R2,HSRTS		:SET RTS ACTIVE
	SLLS	R2,8			:MOVE LINE # TO HIGH BYTE
	OI	R2,HCMD1		:MAKE START OUTPUT
	LI	R3,HPAIR2/10		:GET QUAD ADDR OF CHAN PGM
	HLOG(R2,R3)
	WDR	R2,R3			:START OUTPUT
	LPSWR	R0			:RETURN

IHSYN5	LHI	R3,IHSYN6		:GET VECTOR FOR OUTPUT
	OI	R3,(SIN2^10)		:INCLUDE INPUT VECTOR
	ST	R3,SYNVEC-42,R2,R2	:PLACE IN VECTOR TABLE
	SHI	R2,21			:MAKE LINE #
	SLLS	R2,7			:MOVE LINE # TO HIGH BYTE
	OI	R2,HCMD0		:MAKE START INPUT CMD
	LI	R3,HPAIR3/10		:GET QUAD ADDR OF CHAN PGM
	HLOG(R2,R3)
	WDR	R2,R3			:START INPUT
	LPSWR	R0			:RETURN

IHSYN6	LHL	R3,SPORT-21,R2		:GET POINTER TO DESC BLOCK	
	TS	LINIT,R3		:SET LINE INITIALIZED
	TS	HISTAT			:HAS STORE STATUS BEEN INIT'ED
	JL	S.MARX			:IF SO, DO MARKS
	LHI	R3,S.MARX		:GET NEW VECTOR
	STH	R3,SYNVEC-40,R2,R2	:PLACE IN VECTOR TABLE
	SHI	R2,21			:MAKE LINE #
	SLLS	R2,7			:MOVE LINE # TO HIGH BYTE
	OI	R2,HCMD8		:GET STORE STATUS CMD
	LI	R3,HSDSR/10		:GET QUAD ADDR OF STATUS AREA
	HLOG(R2,R3)
	WDR	R2,R3			:GET STATUS
	LPSWR	R0			:RETURN
	EI	(HMICRO!TSI!NANO)
					:
:	...............................................................
:
:	SYNCHRONOUS RECEIVER
:
:	...............................................................
					:
   IF	ESYNCI				:
					:
:	...............................................................
:	INTERRUPT FOR INPUT NOT EXPECTED
:	...............................................................
					:
S.ZAPS	LHL	R3,SPORT-20,R2		:GET BLOCK POINTER FOR THIS LINE
	LH	R4,OSLOTO,R3		:BAD SLOT # IN R4
	JLFS	S.ZAPH			:IT'S OUR'S, SO HALT SYSTEM
	SBT	R4,DC.IRA		:NO..SET IRRECOVERABLE ERROR FOR SLOT
	LA	R4,SIN2			:SET IGNOR-INTERRUPTS
	STH	R4,SYNVEC-40,R2,R2
	LPSWR	R0			:THEN EXIT
S.ZAPH	ST	R0,S.ZAPP		:SAVE PSW
	ST	R1,S.ZAPP+4		:
	S.HLT0(0430,S.ZAPP)		:
					:
:	...............................................................
:	INTERRUPT FOR INPUT EXPECTED:
:	...............................................................
					:
S.IN	LR	R6,R3			:VALUE IS ALREADY IN R3
   ELSE					:
S.IN	RDR	R2,R6			:INPUT THE VALUE
   EI  (ESYNCI)				:
	LHL	R3,SPORT-20,R2		:GET BLOCK POINTER FOR THIS LINE
	L	R4,IBA,R3		:GET INPUT BUFFER ADDRESS FOR THIS LINE
	JEFS	SIN2			:SKIP IF NULL
	LHL	R5,CII,R4		:CONNECTED...BUMP POINTER
	STH	R6,IBUF,R4,R5		:STUFF AWAY
	AIS	R5,2			:
	CLH	R5,IFP,R3		:TEST FOR FOLDING
	JLFS	SIN1			:SKIP IF NOT
	LIS	R5,0			:ELSE RECYCLE IT
SIN1	STH	R5,CII,R4		:SAVE IT
SIN2	LPSWR	R0			:AND EXIT
					:
:	...............................................................
:	OUTPUT CO-ROUTINES...CONNECTED DIRECTLY TO INTERRUPT CELLS!!
:
:	SPECIAL SOFTWARE FOR THE TYMNET-II NODE CODE EXECUTING
:	UNDER ISIS.
:
:	SXINT:
:
:	SYNC LINE INTERRUPT TRANSMITTER.
:
:	NOTE: THAT ALL ADDRESSES ARE ASSUMED TO BE IN USER SEGMENT 0
:	      EXCEPT FOR "RECBUF" WHICH STARTS AT BEGINNING OF SEGMENT
:	      2. LINK AND RECORD DESCRIPTORS ARE REFERENCED BY BOTH
:	      THE KERNEL AND THE NODE CODE.
:	...............................................................
					:	
:	TO TRANSMIT A SINGLE RESET PATTERN.
					:
SXRST	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
	LHI	R4,-2*NRSMRK		:
	JAL	R7,SXMARK		:MARK A FULL RECORD
   IF	ESYNCI				:
	LHL	R3,SPORT-21,R2		:
   EI  (ESYNCI)				:
	LH	R5,SYRESZ		:GET NEGATIVE SIZE OF RESET
SXRS1	L	R4,ODA,R3		:POINTS AT PATTERN TO TRANSMIT
	SR	R4,R5			:POINT AT END OF PATTERN
	STH	R5,OCC,R3		:
	ST	R4,COC,R3		:
	JAL	R7,SXBLOK		:TRANSMIT PATTERN
   IF	ESYNCI				:
	LHL	R3,SPORT-21,R2		:
   EI  (ESYNCI)				:
	J	S.MARX			:
					:
:	...............................................................
:	TO TRANSMIT A BLOCK OF DATA:
:	...............................................................
					:
SXPAK	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
	LIS	R5,0			:MAKE A NEGATIVE BYTE COUNT
	SH	R5,OCC,R3		:BYTE COUNT
	AR	R5,R5			:
	J	SXRS1			:SEND BLOCK
					:
:	...............................................................
:	TO TRANSMIT CONTINUOUS RESET STREAM:
:	...............................................................
					:
SXRSM	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
	LHI	R4,-2*NRSMRK		:
	JAL	R7,SXMARK		:MARK FULL RECORD
   IF	ESYNCI				:
	LHL	R3,SPORT-21,R2		:
   EI  (ESYNCI)				:
	LH	R5,SYRESZ		:GET NEGATIVE SIZE OF RESET
	L	R4,ODA,R3		:POINTS TO PATTERN
	SR	R4,R5			:POINT TO END OF PATTERN
	ST	R4,COC,R3		:
	STH	R5,OCC,R3		:
	JAL	R7,SXBLOK		:
   IF	ESYNCI				:
	LHL	R3,SPORT-21,R2		:
   EI  (ESYNCI)				:
	J	SXRSM			:RESTART
					:
:	...............................................................
:	INTERRUPT TRANSMITTER FOR ATTACHED LINES
:	...............................................................
					:
:	SEND DUMMY RECORD	
					:
SXDUM	LA	R4,TWDUMM+8		:SEND A DUMMY RECORD
	ST	R4,COC,R3		:
	LCS	R4,8			:
	STH	R4,OCC,R3		:
	JAL	R7,SXBLOK		:
   IF	ESYNCI				:
	LHL	R3,SPORT-21,R2		:
   EI  (ESYNCI)				:
	LA	R4,SXATT		:
	STH	R4,SYNVEC-40,R2,R2	:
	J	S.MARK			:
SXAMX	LHI	R4,-2*NRSMRK		:MARK A FULL RECORD TIME
	JAL	R7,SXMARK		:
   IF	ESYNCI				:
	LHL	R3,SPORT-21,R2		:
   EI  (ESYNCI)				:
					:...AND FALL THROUGH TO ATTACHED TRANSMITTER
					:
:	...............................................................
:	INTERRUPT TRANSMITTER FOR ATTACHED LINES
:	...............................................................
					:
SXATT	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
	RBT	R2,RSENT		:DO NOT SEND DUMMY RECORD
	RBT	R2,XDUMM		:AFTER RESET
	LHI	R4,-2*NRSMRK		:MARK SOME RECORDS
	JAL	R7,SXMARK		:GO MARK IT
					:
SXATT1	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
SXATT2	L	R5,ODA,R3		:GET LINK POINTER
	LHL	R6,NRXM,R5		:ACTIVE LINE, GET PTR TO NEXT RECORD
	L	R8,OALL,R3		:SEGMENT 0 PHYSICAL ADDRESS
	LH	R7,RECN,R6,R8		:RECORD #
   IF	TIINEW
	LR	R4,R7			:SAVE IT IN R4 FOR PERF. MONITORING
   EI  (TIINEW)				:
	SH	R7,LAR,R5		:
	CHVR	R7,R7			:
	JGFS	SXATT3			:RECORD NEEDS TO BE SENT
	TS	IDLE,R5			:INDICATES LINK NOT SATURATED
	RBT	R2,XDUMM		:IS IT TIME TO XMIT DUMMY?
	JE	S.MRK1			:NO REASON TO
	J	SXDUM			:
					:
SXATT3					:
   IF	TIINEW
	NHI	R4,PKTMSZ-1		:FORM INDEX INTO PACKET TIME TABLE
	AR	R4,R4			:AND FORM HW OFFSET
	LH	R9,FASTC+2		:GET CURRENT TIME
	LH	R10,PKTTIM,R5,R4	:GET TIME PACKET WAS MADE OR REXMITTED
	STH	R9,PKTTIM,R5,R4		:STORE BACK CURRENT TIME
	SR	R9,R10			:GET TIME IN QUEUE
	JGEFS	SXAT6			:POSITIVE, NO WRAP
	AI	R9,10000		:CORRECT FOR WRAP
SXAT6	AM	R9,KS.PQC,R5		:ADD CURRNT DELAY INTO RUNNING SUM
   EI  (TIINEW)				:
	LB	R4,LLXM,R6,R8		:FIRST TRANSMISSION?
	JE	SXATT4			:YES
	CLHI	R4,1F			:CHECK FOR DUMMY LINE
	JLEFS	SXATT0			:
	CLHI	R4,2*PSPORT+1F		:RANGE CHECK FOR SAFETY
	JGFS	SXATT0			:
	LHL	R4,SPORT-21,R4		:FIND PREVIOUS LINE DESCRIPTOR
	STH	R2,SXMRKF,R4		:AND FLAG PREVIOUS LINE TO SEND MARKS
SXATT0	LHI	R4,1F			:
	STB	R4,LLXM,R6,R8		:CHANGE TO DUMMY LINE
	TS	SXMRKF,R3		:WERE WE FLAGGED?
	JGE	SXATT			:YES, GO MARK
	LIS	R7,1			:GET A ONE
	AHM	R7,SXRTR,R3		:COUNT RETRANSMISSIONS
	JFS	SXATT5			:
					:
SXATT4	TS	SXMRKF,R3		:WERE WE FLAGGED?
	JGE	SXATT			:YES, GO SEND MARKS
	LH	R7,RLNK,R6,R8		:ADVANCE NRXM
	STH	R7,NRXM,R5		:
					:
SXATT5	STB	R2,LLXM,R6,R8		:REMEMBER WE SENT THIS ONE
	RBT	R2,RSENT		:NOTE NO NEED TO SEND DUMMY
	LIS	R7,1			:GET A ONE
	AHM	R7,SXCTR,R3		:COUNT TRANSMISSIONS
	LHL	R7,LRT,R5		:UPDATE LAS
	STH	R7,LAS,R5		:
	NH	R7,AMSK,R5		:MASK IT FOR INCLUSION IN HEADER
   IF	ESYNCI				:
	LHL	R4,BREC,R6,R8		:ADDR OF START OF RECORD
	LR	R11,R0			:SAVE PSW
	LHR	R0,R4			:NEEDED SO GREATER THAN 8000 WORKS
	A	R4,OAHL,R3		:
	LCS	R9,1			:
	XH	R9,AMSK,R5		:CLEAR ONLY ACK AREA IN HEADER
	NH	R9,0,R4			:
	OR	R7,R9			:OR IN NEW ACK
    IF	HMICRO!TSI!NANO			:
	SHI	R2,21			:MAKE CHANNEL #
	SLLS	R2,7			:MOVE CHANNEL # TO HIGH BYTE
	OHI	R2,HCMD9		:GET OUTPUT DATA CMD
	HLOG(R2,R7)			:
    EI (HMICRO!TSI!NANO)		:
	WDR	R2,R7			:OUTPUT THE HEADER
					:
	STH	R7,0,R4			:STORE IT AWAY FOR CHECKSUMMING
					:
:	CALCULATE RECORD CHECKSUM
					:
	SH	R0,EREC,R6,R8		:
        LR      R7,R0                   :SAVE BECAUSE CHECK-SUM MAY KILL
	LIS	R9,0			:CLEAR VRC AND DRC ACCUMULATORS
	LIS	R10,0
	HC	3794			:****	CHECKSUM    ****

	SR	R4,R0			:ABSOLUTE ADDRESS OF END OF RECORD
	STH	R9,0,R4			:STORE CHECKSUMS
	STH	R10,2,R4
	LHL	R5,OESIPT,R3		:I/O CONTROL BLOCK ADDRESS
	SIS	R7,2
	STH	R7,OIX,R5		:NEGATIVE BYTE COUNT
	AIS	R4,4
	ST	R4,OEAD,R5		:POINT TO DIAG CHECKSUM
	LR	R0,R11
	LPSWR	R0			:DONE

SXMARK	LHL	R5,OESIPT,R3		:I/O CONTROL BLOCK ADDRESS
	SRLS	R4,1			:
	LIS	R6,0			:
	SR	R6,R4			:
	STH	R6,OIX,R5		:
	STH	R7,SYNVEC-40,R2,R2	:
   IF	HMICRO!TSI!NANO			:
	SHI	R2,21			:MAKE CHANNEL #
	SLLS	R2,7			:PUT DEVICE # IN HIGH BYTE
	OHI	R2,HCMD9		:GET START OUTPUT CMD
	LHL	R3,OPAD,R5		:GET PAD HW
	HLOG(R2,R3)			:
	WDR	R2,R3			:START PAD OUTPUT
   ELSE					:
	WD	R2,OPHW+1,R3		:
   EI  (HMICRO!TSI!NANO)		:
	LPSWR	R0			:
					:
SXBLOK	LHL	R5,OESIPT,R3		:I/O CONTROL BLOCK ADDRESS
	LH	R4,OCC,R3		:
	L	R6,COC,R3		:
   IF	HMICRO!TSI!NANO			:
	LHL	R8,0,R4,R6		:
	LHI	R3,-21,R2		:MAKE CHANNEL #
	SLLS	R3,7			:MOVE CHANNEL # TO HIGH BYTE
	OHI	R3,HCMD9		:GET START OUTPUT CMD
	HLOG(R3,R8)
	WDR	R3,R8			:OUTPUT HW
   ELSE					:
	WD	R2,1,R4,R6		:
   EI  (HMICRO!TSI!NANO)		:
	ST	R6,OEAD,R5		:
	AIS	R4,2			:
	STH	R4,OIX,R5		:
	STH	R7,SYNVEC-40,R2,R2	:
	LPSWR	R0			:
   ELSE					:
	LH	R5,EREC,R6,R8		:POINT TO END OF DATA
	A	R5,OAHL,R3		:
	ST	R5,COC,R3		:SAVE FOR INTERRUPT HANDLER
	STH	R7,SXACK,R3		:SAVE ACK FOR PUTTING IN CHECKSUMS
	LHL	R4,BREC,R6,R8		:POINT TO START OF DATA
	A	R4,OAHL,R3		:
	XH	R7,0,R4			:XOR ACK AND HEADER
	WDR	R2,R7			:
	AIS	R4,2			:PAST HEADER
	SR	R4,R5			:
	STH	R4,OCC,R3		:
	STH	R6,SXRETN,R3		:POINTER TO REC DESCRIPTOR
	LA	R4,S.REC		:SET TO SEND RECORD BODY
	STH	R4,SYNVEC-40,R2,R2	:
	LPSWR	R0			:
S.REC	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
	L	R4,COC,R3		:SEND RECORD BODY
	LH	R5,OCC,R3		:ALL DONE?
	JGEFS	S.VCHK			:GO SEND VERTICAL CHECKSUM
	WD	R2,1,R4,R5		:SEND DATA
	AIS	R5,2			:INDEX PTR
	STH	R5,OCC,R3		:
	LPSWR	R0			:

S.VCHK	LHL	R5,SXACK,R3		:SEND VERTICAL CHECKSUM
	XH	R5,0,R4
	WDR	R2,R5
	LA	R4,S.DCHK		:SET TO XMIT DIAG CHKSM
	STH	R4,SYNVEC-40,R2,R2
	LPSWR	R0

S.DCHK	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
	L	R4,COC,R3		:SEND DIAG CHKSM - PTR TO DATA
	LHL	R5,SXACK,R3		:INSERT ACKNOWLEDGEMENT
	EXHR	R6,R5			:REPLICATE ACK IN BOTH HW'S
	OR	R5,R6
	LHL	R6,SXRETN,R3		:RECORD DESCRIPTOR
	L	R8,OALL,R3
	LB	R7,RSHF,R6,R8		:RIGHT ROTATE COUNT
	SRL	R5,0,R7
	XH	R5,SXACK,R3
	XH	R5,2,R4
	WDR	R2,R5
	LA	R4,SXATT1
	STH	R4,SYNVEC-40,R2,R2
	LPSWR	R0




:	SUBROUTINES USED BY THE ABOVE:

:	TRANSMIT MARKS
:	R4	- # OF BYTES OF MARK TO SEND
:	R7	LINK REGISTER
SXMARK	STH	R4,OCC,R3		:COUNT OF MARKS TO OUTPUT
	STH	R7,SXRETN,R3		:SAVE RETURN
	LA	R4,SXMAR1
	STH	R4,SYNVEC-40,R2,R2
	JFS	SXMAR2

SXMAR1	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
SXMAR2	LIS	R5,2
	AHM	R5,OCC,R3
	JL	S.MARK
	LHL	R7,SXRETN,R3		:ALL DONE
	JR	R7

SXBLOK	STH	R7,SXRETN,R3		:SAVE RETURN
	LA	R4,SXBLO1
	STH	R4,SYNVEC-40,R2,R2
	JFS	SXBLO2
SXBLO1	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
SXBLO2	LH	R4,OCC,R3
	JGEFS	SXBLO3			:ALL DONE
	L	R5,COC,R3
	WD	R2,1,R4,R5		:SEND DATA
	AIS	R4,2			:INC POINTER
	STH	R4,OCC,R3
	LPSWR	R0
SXBLO3	LHL	R7,SXRETN,R3		:RETURN
	JR	R7
	EI	(ESYNCI)

:	CO-ROUTINE TO CHECK THE COMMAND (ROTOR) LIST
S.CHEK	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
	L	R4,ODA,R3		:GET POINTER TO OUTPUT DESCRIPTOR
	J	SOUT5			:AND SKIP TO PROCESS IT

:	CO-ROUTINE TO OUTPUT MARKS
S.MARX	LA	R3,S.MARK		:SET UP TO OUTPUT MARKS
	STH	R3,SYNVEC-40,R2,R2
S.MARK	LHL	R3,SPORT-21,R2		:GET POINTER TO LINE DESCRIPTOR
	IF	HMICRO!TSI!NANO
S.MRK1	LHL	R5,OESIPT,R3		:GET PTR TO EHANCED INT BLK
	SHI	R2,21			:MAKE LINE #
	SLLS	R2,7			:PUT DEVICE # IN HIGH BYTE
	OI	R2,HCMD9		:GET OUTPUT DATA CMD
	LHL	R3,OPAD,R5		:GET PAD HW
	HLOG(R2,R3)
	WDR	R2,R3			:START PAD OUTPUT
	LHI	R3,NPADS		:# OF PADS FOR OUTPUT
	STH	R3,OIX,R5		:STORE INTO INDEX
	ELSE
S.MRK1	WD	R2,OPHW+1,R3		:OUTPUT PADDING HALF-WORD
	EI	(HMICRO!TSI!NANO)
	LPSWR	R0			:AND EXIT

:	SYNCHRONOUS TRANSMITTER
S.OUT	LHL	R3,SPORT-21,R2		:GET BLOCK POINTER FOR THIS LINE
	IF	1-ESYNCI
	L	R4,COC,R3		:GET POINTER TO CURRENT OUTPUT TEXT
	JEBS	S.MARX			:ERROR IF NULL...THEN ENTER MARKING STATE
	LH	R5,OCC,R3		:GET INDEX FOR NEXT HALFWORD
S.OUT1	WD	R2,1,R4,R5		:OUTPUT NEXT HALFWORD
	AIS	R5,2			:BUMP COUNTER
	JGEFS	SOUT1			:SKIP IF COUNT NOW EXHAUSTED
	STH	R5,OCC,R3		:ELSE SAVE UPDATED COUNT
S.EXIT	LPSWR	R0			:AND EXIT
	EI	(1-ESYNCI)		:
					:
:	...............................................................
:	CLEAN UP LAST OP, CHAIN TO NEXT COMMAND MESSAGE
:	...............................................................
: 	In case of a range failure a context value is stored at dv8.f
: 	and the offending value is stored at r4.f (for the last case).
:	the device address will be found at r2.f
:					:
SOUT1	L	R4,ODA,R3		:GET OUTPUT DESCRIPTOR ADDRESS
	LHL	R6,OOP,R4		:CHECK LAST OP
	CLHI	R6,$A 11		:DON'T ZERO IF SPECIAL OUTPUT TYPE
	JEFS	SOUT3			:
SOUT2	LIS	R5,0			:ELSE ZERO OUT COMMAND
	STH	R5,OOP,R4		:SET LAST MESSAGE PROCESSED
SOUT3	AIS	R4,8			:POINT AT NEXT MESSAGE BLOCK
SOUT4	ST	R4,ODA,R3		:SAVE NEW DESCRIPTOR ADDRESS
SOUT5	C	R4,OAHL,R3		:RANGE CHECK ON DESCRIPTOR
	JLFS	SOUT5A			:OK
	lis	r3,1			:context
	J	S.XYZ			:HAVE RUN OFF USER'S SEGMENT
SOUT5A	LHL	R5,OOP,R4		:EXAMINE NEXT MESSAGE
	JEFS	S.MARS			:ABORT IF HALT COMMAND
	CLHI	R5,NSOUTT		:TEST IF VALID OPERATION
	JGEFS	S.MARS			:ILLEGAL...TREAT AS HALT
	LHL	R5,SOUTT,R5,R5		:LOOK UP ROUTINE ADDRESS
	JR	R5			:AND GO THERE
					:
:	...............................................................
:	ENTER MARK STATE NEXT INTERRUPT
:	...............................................................
					:
   IF	ESYNCI				:
S.MARS	J	S.MARX			:
   ELSE					:
S.MARS	LA	R3,S.MARK		:
	STH	R3,SYNVEC-40,R2,R2	:
	LPSWR	R0			:
   EI  (ESYNCI)				:

s.xyz	st	r2,r2.f			:device address
	st	r3,dv8.f		:context of crash
	st	r4,r4.f			:offending value
	LHL	R4,SPORT-20,R2		:
	LH	R4,OSLOTO,R4		:
	JL	S.ZAPH,,		:bad slot kill isis
	SBT	R4,DC.IRA		:set irrecoverable error for slot
	J	S.MARS			:return to code
:
r2.f	ws	1
r4.f	ws	1
dv8.f	hs	1
:
:	1---OUTPUT COMMAND
SOUT6	LIS	R5,0			:SET UP NEW OUTPUT OPERATION
	SH	R5,OCT,R4		:MAKE NEGATIVE COUNT

	LR	R6,R4			:save
	L	R4,OSP,R4		:get string pointer
	S	R4,OAO,R3		:make absolute
	C	R4,OALL,R3		:low boundary
	jgefs	dv8.0
	lis	r3,2
	j	s.xyz
:	JL	S.XYZ			:out of bounds
dv8.0	C	R4,OAHL,R3		:high boundary
	jlfs	dv8.1
	lis	r3,3
	j	s.xyz
:	JGE	S.XYZ			:out of bounds
:						:
dv8.1	L	R4,OSP,R6		:OUTPUT STRING POINTER
	SR	R4,R5			:END OF OUTPUT STRING...
	S	R4,OAO,R3		:MAKE ABSOLUTE ADDRESS

	IF	ESYNCI
	LHL	R3,OESIPT,R3		:GET PTR TO ENHANCED INT BLOCK
	ST	R4,OEAD,R3		:STORE OUTPUT DATA END ADDR
	AIS	R5,2			:INCR COUNT PAST 1ST WORD
	STH	R5,OIX,R3		:STORE NEGATIVE COUNT
	LA	R6,S.OUT		:SET INT VECTOR
	STH	R6,SYNVEC-40,R2,R2
	IF	HMICRO!TSI!NANO
	SHI	R2,21			:MAKE CHAN #
	SLLS	R2,7			:MOVE CHAN # TO HIGH BYTE
	OI	R2,HCMD9		:GET OUTPUT DATA CMD
	LHL	R3,-2,R5,R4		:GET FIRST HW OF DATA
	HLOG(R2,R3)
	WDR	R2,R3			:START OUTPUT
	ELSE
	WD	R2,1-2,R5,R4		:OUTPUT 1ST WORD
	EI	(HMICRO!TSI!NANO)
	LPSWR	R0			:AND EXIT

	ELSE
	ST	R4,COC,R3		:SAVE CURRENT OUTPUT ADDRESS
	LA	R6,S.OUT
	CLH	R6,SYNVEC-40,R2,R2	:ARE WE ALREADY IN OUTPUT STATE?
	JNFS	SOUT6A			:NO, START IT
	STH	R5,OCC,R3		:YES, SAVE NEW CHARACTER COUNT
	LPSWR	R0			:AND EXIT
SOUT6A	STH	R6,SYNVEC-40,R2,R2	:CHANGE TO OUTPUT STATE
	J	S.OUT1			:GO TO OUTPUT WITH R4=COC AND R5=-COUNT
	EI	(ESYNCI)

:	2---TRANSFER
SOUT7	LIS	R5,0			:TRANSFER...CLEAN OUT MESSAGE
	STH	R5,OOP,R4
SOUT7A	L	R4,OSP,R4		:GET STRING POINTER
	S	R4,OAO,R3		:BIAS IT
	C	R4,OALL,R3		:CHECK LOW LIMIT
	JGE	SOUT4			:OK...NOW GO CHECK HIGH LIMIT
	lis	r3,4
	J	S.XYZ			:OUT OF RANGE..TAKE OFF RUN QUEUE

:	3---TURN OFF RS
SOUT8	LH	R5,OLBITX,R3		:GET RS INDEX
	IF	HMICRO!TSI!NANO
	SBT	R5,HSRTS		:LOWER AND CHECK RTS
	JN	SOUT2			:ITS ALREADY OFF
	LI	R6,HSTAT		:GET STATUS CMD
	ELSE
	JL	SOUT2			:IGNOR IF INDEX IS NEGATIVE
	SBT	R5,SDTR			:SET BIT
	EI	(HMICRO!TSI!NANO)
	JFS	SOUT9A

:	4---TURN ON RS
SOUT9	LH	R5,OLBITX,R3		:GET RS INDEX
	IF	HMICRO!TSI!NANO
	RBT	R5,HSRTS		:RAISE AND CHECK RTS
	JE	SOUT2			:ITS ALREADY ON
	LI	R6,HSTAT!HRTS		:GET STATUS CMD & RAISE RTS
	ELSE
	JL	SOUT2			:IGNOR IF INDEX IS NEGATIVE
	RBT	R5,SDTR			:RESET BIT
	EI	(HMICRO!TSI!NANO)

	IF	HMICRO!TSI!NANO
SOUT9A	TBT	R5,HSDTR		:CHECK STATUS OF DTR
	JN	SOUT9C			:SKIP IF OFF
	OI	R6,HDTR			:PRESERVE IF ON
	JFS	SOUT9C

SOUT9B	TBT	R5,HSRTS		:CHECK STATUS OF RTS
	JN	SOUT9C			:SKIP IF OFF
	OI	R6,HRTS			:PRESERVE IF ON


SOUT9C	SLLS	R5,8			:MOVE CHAN# TO HIGH BYTE
	OI	R5,HCMDA		:GET START OUTPUT CMD
	LA	R7,S.OUT		:GET ADDR OF NEXT ROUJTINE
	STH	R7,SYNVEC-40,R2,R2	:PLACE IN VECTOR TABLE
	HLOG(R5,R6)
	WDR	R5,R6			:OUTPUT STATUS
	LPSWR	R0			:RETURN
	ELSE
SOUT9A	LHI	R5,0BF			:ADDRESS OF RS DEVICE
	WD	R5,SDTR+1		:DO RS OPERATION
	IF	XSYNC;	LHI	R5,0FF;	WD	R5,SDTR+3;	EI
	J	SOUT2			:AND CONTINUE SCANNING LIST
	EI	(HMICRO!TSI!NANO)

:	5---SET BIT FLAG
SOUT10	L	R5,OSP,R4		:COMPUTE THE ADDRESS
	S	R5,OAO,R3
	C	R5,OALL,R3		:RANGE CHECK
	jgefs	dv8.2
	lr	r4,r5
	lis	r3,5
	j	s.xyz	
:	JL	S.XYZ			:TAKE OFF RUN QUEUE
dv8.2	C	R5,OAHL,R3
	jlfs	dv8.3
	lr	r4,r5
	lis	r3,6
	j	s.xyz
:	JGE	S.XYZ			:TAKE OFF RUN QUEUE
dv8.3	LB	R6,OCT+1,R4		:GET THE COUNT...=BIT NUMBER RELATIVE TO ADDRESS
	SBT	R6,0,R5
	J	SOUT2			:AND CONTINUE

:	6---CONNECT "CS" BIT
SOUT11	L	R5,OSP,R4		:COMPUTE THE ADDRESS
	S	R5,OAO,R3
	C	R5,OALL,R3		:RANGE CHECK
	jgefs	dv8.4
	lr	r4,r5
	lis	r3,7
	j	s.xyz
:	JL	S.XYZ			:TAKE OFF RUN QUEUE
dv8.4	C	R5,OAHL,R3
	jlfs	dv8.5
	lr	r4,r5
	lis	r3,8
	j	s.xyz
:	JGE	S.XYZ			:TAKE OFF RUN QUEUE
dv8.5	LB	R6,OCT+1,R4		:GET RELATIVE BIT NUMBER
	ST	R5,OCSBP,R3		:SAVE POINTER
	STB	R6,OCSBP,R3
	J	SOUT2

:	7---CONNECT "DSR" BIT
SOUT12	L	R5,OSP,R4		:COMPUTE THE ADDRESS
	S	R5,OAO,R3
	C	R5,OALL,R3		:RANGE CHECK
	jgefs	dv8.6
	lr	r4,r5
	lis	r3,9
	j	s.xyz
:	JL	S.XYZ			:TAKE OFF RUN QUEUE
dv8.6	C	R5,OAHL,R3
	jlfs	dv8.7
	lr	r4,r5
	lis	r3,0a
	j	s.xyz
:	JGE	S.XYZ			:TAKE OFF RUN QUEUE
dv8.7	LB	R6,OCT+1,R4		:GET RELATIVE BIT NUMBER
	ST	R5,ODSRBP,R3		:SAVE POINTER
	STB	R6,ODSRBP,R3
	J	SOUT2

:	8---TURN OFF DTR
SOUT13	LH	R5,OLBITX,R3		:GET RS INDEX
	IF	HMICRO!TSI!NANO
	SBT	R5,HSDTR		:LOWER AND CHECK DTR
	JN	SOUT2			:ITS ALREADY OFF
	LI	R6,HSTAT		:GET STATUS CMD
	J	SOUT9B
	ELSE
	JL	SOUT2			:IGNOR IF INDEX IS NEGATIVE
	SIS	R5,8			:ELSE CONVERT CS INDEX TO DTR INDEX
	SBT	R5,SDTR			:SET BIT
	J	SOUT9A			:AND GO SEND IT
	EI	(HMICRO!TSI!NANO)

:	9---TURN ON DTR
SOUT14	LH	R5,OLBITX,R3		:GET RS INDEX
	IF	HMICRO!TSI!NANO
	RBT	R5,HSDTR		:RAISE AND CHECK DTR
	JE	SOUT2			:ITS ALREADY ON
	LI	R6,HSTAT!HDTR		:GET STATUS CMD & RAISE DTR
	J	SOUT9B
	ELSE
	JL	SOUT2			:IGNOR IF INDEX IS NEGATIVE
	SIS	R5,8			:ELSE CONVERT CS INDEX TO DTR INDEX
	RBT	R5,SDTR			:RESET BIT
	J	SOUT9A			:GO TRANSMIT THE STUFF
	EI	(HMICRO!TSI!NANO)

:	10d---SET OUTPUT PADDING STATE
SOUT15	LH	R5,OCT,R4		:STATE COMES FROM COUNT FIELD
	STH	R5,OPHW,R3		:SET IT UP
   IF	HMICRO!TSI!NANO			:
	LHL	R6,OESIPT,R3		:GET POINTER TO ENHANCED BLOCK
	STH	R5,OPAD,R6		:STORE PAD HW
   EI  (HMICRO!TSI!NANO)		:
	J	SOUT2			:AND CONTINUE
					:
:	...............................................................
:	TABLE OF CO-ROUTINES ORDERED BY COMMAND
:	...............................................................
					:
SOUTT	HC	S.MARS			:0...HALT OUTPUT
	HC	SOUT6			:1...OUTPUT
	HC	SOUT7			:2...TRANSFER
	HC	SOUT8			:3...TURN OFF RS
	HC	SOUT9			:4...TURN ON RS
	HC	SOUT10			:5...SET BIT FLAG
	HC	SOUT11			:6...CONNECT "CS" BIT
	HC	SOUT12			:7...CONNECT "DSR" BIT
	HC	SOUT13			:8...TURN OFF DTR
	HC	SOUT14			:9...TURN ON DTR
	HC	SOUT15			:10d.SET OUTPUT PADDING STATE
	HC	SOUT6			:11d.SPECIAL OUTPUT (DON'T ZERO COMMAND)
	HC	SOUT7A			:12d.SPECIAL TRANSFER (DON'T ZERO COMMAND)
NSOUTT	EQ	(.-SOUTT)/2		:THE NUMBER OF ENTRIES
					:
:	...............................................................
:
:	SYNC FOREGROUND CODE
:	LINK ON R0
:	CALLED FROM FLASH FOREGROUND JOB
:

:	...............................................................
					:
SFOREG	LHI	R3,(PSPORT-1)*2		:
   IF	HMICRO!TSI!NANO			:
   ELSE					:
	LHI	R4,0BF			:
	RDR	R4,R4			:GET CS VALUES
	STH	R4,SDSR			:
    IF	XSYNC				:
	LHI	R4,0FF			:
	RDR	R4,R4			:
	STH	R4,SDSR+2		:
    EI (XSYNC)				:
   EI  (HMICRO!TSI!NANO)		:
					:
SFORE1	LHL	R4,SPORT,R3		:GET POINTER TO PORT
	LH	R5,OLBITX,R4		:GET CS INDEX
	JL	SFORE5			:SKIP IF NOT APPLICABLE
	L	R7,OCSBP,R4		:GET POINTER
	JEFS	SFORE3			:SKIP IF NOT SET UP
	LB	R6,OCSBP,R4		:GET BIT NUMBER
   IF	HMICRO!TSI!NANO			:
	TBT	R5,HSCTS		:IS BIT ON?
   ELSE					:
	TBT	R5,SDSR			:IS BIT ON?
   EI  (HMICRO!TSI!NANO)		:
	JEFS	SFORE2			:SKIP IF NOT
	SBT	R6,0,R7			:YES...SET IT
	JFS	SFORE3			:AND SKIP
					:
SFORE2	RBT	R6,0,R7			:NOT SET...TURN IT OFF
					:
SFORE3	L	R7,ODSRBP,R4		:NOW FOR DSR:
	JEFS	SFORE5			:SKIP IF NOT IMPLEMENTED
	LB	R6,ODSRBP,R4		:GET BIT NUMBER
   IF	HMICRO!TSI!NANO			:
	TBT	R5,HSDSR		:IS BIT ON?
   ELSE					:
	SIS	R5,8			:CONVERT CS INDEX TO RS INDEX
	TBT	R5,SDSR			:
   EI  (HMICRO!TSI!NANO)		:
	JEFS	SFORE4			:SKIP IF NOT SET
	SBT	R6,0,R7			:YES...SET IT
	JFS	SFORE5			:AND SKIP
					:
SFORE4	RBT	R6,0,R7			:NOT SET...TURN IT OFF
					:
SFORE5	SIS	R3,2			:
	JGE	SFORE1			:DO FOR ALL
	JR	R0			:AND EXIT
	EM				:
	EI	(NSYNC)			:
					:

					:
	IF	NPRINT

	SUBTTL	PRINTER HANDLER

	GL	IPRINT

	MO	.,PRINT

Q	EQ	.			:REMEMBER WHERE WE ARE
	ORG	0
:	THE PRINTER DRIVER USAGE IS MUCH LIKE SYNCHRONOUS OUTPUT
:	IT IS DRIVEN VIA A LIST OF ROTOR ENTRIES

:	EACH ENTRY IS IDENTICAL TO SYNCHRONOUS OUTPUT DESCRIPTOR FORMAT:

:	OOP CAN HAVE THE VALUES:
:	0	HALT OUTPUT (GO TO MARKING STATE)
:	1	OUTPUT STRING
:	2	TRANSFER TO NEW DESCRIPTOR


:	DEFINE PRINTER DEVICE BLOCK

LUATRB	BS	1		:B  LOGICAL UNIT ATRIBUTES	
	BS	1		:B  PRINTER NUMBER	
	HS	1		:H  FILLER	
OAO	HS	2		:   OUTPUT ADDRESS OFFSET (SUBTR FROM ADDR)
OALL	HS	2		:   OUTPUT ADDRESS LOW LIMIT
OAHL	HS	2		:   OUTPUT ADDRESS HIGH LIMIT
ODA	HS	2		:   OUTPUT DESCRIPTOR ADDRESS
COC	HS	2		:   CURR OUTPUT CHARS (POINT TO END OF MSG)
OCC	HS	1		:H  OUTPUT CHAR COUNT
PRSTAT	HS	2		:   PRINTER STATUS PNTR (RETURNS STAT TO USER)
PRDEVA	HS	1		:H  OUTPUT DEVICE ADDRESS

:	NOTE...UP THROUGH OUTPUT CHAR COUNT, THIS BLOCK IS IDENTICAL TO
:	THAT USED FOR SYNCHRONOUS I/O!
PRBL	HS	0		:PRINTER BLOCK LENGTH
	ORG	Q

:	PRINTER DESCRIPTORS
PLDB	HS	0
Q	EQ	0;	RE	NPRINT
PLDB|Q|	BC	1,Q,0,0
	ORG	PLDB|Q|+PRDEVA;	HC	60+Q
Q	EQ	Q+1;	NOLIST;	ER;	LIST


:	PRINTER DESCRIPTOR POINTERS (HALFWORDS)
Q	EQ	0
PPORT	RE	NPRINT			:DO FOR ALL PRINTERS
	HC	PLDB|Q|
Q	EQ	Q+1
	NOLIST;	ER;	LIST

:	INITIALIZE PRINTER TABLES
IPRINT	LHI	R2,(NPRINT-1)*2		:SET HALF-WORD INDICES
	LIS	R3,0			:SET UP A NULL
IPRNT1	LHL	R4,PPORT,R2		:GET POINTER TO A BLOCK
	ST	R3,COC,R4		:SET OUTPUT NULL
	ST	R3,PRSTAT,R4		:SET STATUS NULL
	SIS	R2,2
	JGEBS	IPRNT1			:DO FOR ALL LINES
	JR	R1			:AND RETURN


:	P R I N T E R   D R I V E R S
PFOREG	STH	R0,FFRET4		:SAVE RETURN
	LHI	R15,(NPRINT-1)*2
PDRIVR	LHL	R1,PPORT,R15
	JAL	R0,POUT			:SERVICE A PRINTER
	SIS	R15,2			:THEN ON TO NEXT ONE
	JGEBS	PDRIVR
	J	FFRET			:AND EXIT BACK TO FOREGROUND EXEC


:	FOREGROUND PRINTER DRIVER
:	CALLED WITH LINK IN R0
:	R1 = POINTER TO PRINTER DESCRIPTOR BLOCK
POUT	LHL	R2,PRDEVA,R1		:GET PRINTER ADDRESS FOR THIS PRINTER
POUT1	RDR	R2,R3			:GET STATUS
	L	R4,PRSTAT,R1		:POINTER TO STATUS
	JEFS	POUT2			:SKIP IF NULL
	STH	R3,0,R4			:ELSE GIVE HIM STATUS
POUT2	LR	R3,R3			:CHECK PRINTER
	JNR	R0			:EXIT IF BUSY
	L	R3,COC,R1		:ELSE GET POINTER TO CURRENT OUTPUT TEXT
	JER	R0			:EXIT IF NULL
	LH	R4,OCC,R1		:ELSE GET OUTPUT CHARACTER COUNT TOO
POUT3	LB	R5,0,R3			:GET NEXT BYTE
	AIS	R3,1			:BUMP POINTER
	LR	R6,R5			:COPY CHAR
	THI	R5,80			:CHECK FOR SPECIAL CONTROLS
	JEFS	POUT5			:SKIP IF SO
	STB	R5,COC,R1		:ELSE SAVE CURRENT CHAR
	WDR	R2,R5			:OUTPUT CHAR
POUT4	AIS	R4,1			:COUNT IT
	JLBS	POUT3			:REPEAT FOR NEXT CHAR
	J	POUT10			:LAST CHAR IN ROTOR...SKIP TO NEXT

:	SPECIAL CONTROL CHARS:
:	0	END-OF-LINE
:	1-3F	BLANK COMPRESSION
:	40	FORM-FEED
:	41-7F	CHAR COMPRESSION
POUT5	LR	R6,R5			:COPY CHAR
	JE	POUT8			:SKIP IF END-OF-LINE
	THI	R6,40			:CHECK FOR BLANK COMPRESSION
	JNFS	POUT7			:SKIP IF NOT
	LHI	R5,20			:ELSE SET A BLANK
POUT6	WDR	R2,R5
	SIS	R6,1
	JGBS	POUT6			:REPEAT AS MANY TIMES AS NECESSARY
	JBS	POUT4			:THEN FINISH UP
POUT7	SHI	R6,40			:CHECK FOR FORM-FEED
	JEFS	POUT9			:SKIP IF SO
	LB	R5,COC,R1		:CHAR COMPRESSION...GET LAST CHAR
	JBS	POUT6			:GO OUTPUT IT
POUT8	LHI	R5,8000			:PRINT LINE
	WDR	R2,R5
	JFS	POUTA			:AND SKIP
POUT9	LHI	R5,8000			:FORM-FEED
	WDR	R2,R5
	LHI	R5,0A0
	WDR	R2,R5
POUTA	ST	R3,COC,R1		:SAVE POINTER
	AIS	R4,1			:COUNT IT DONE
	STH	R4,OCC,R1
	JNR	R0			:EXIT IF MORE TO DO

:	CLEAN UP LAST OP, CHAIN TO NEXT COMMAND MESSAGE
POUT10	L	R4,ODA,R1		:GET OUTPUT DESCRIPTOR ADDRESS
	LIS	R5,0
	ST	R5,OOP,R4		:SET LAST MESSAGE PROCESSED
	AIS	R4,8			:POINT AT NEXT MESSAGE BLOCK
POUT11	ST	R4,ODA,R1		:SAVE NEW DESCRIPTOR ADDRESS
	CL	R4,OAHL,R1		:RANGE CHECK ON DESCRIPTOR
	JGEFS	POUT12			:HAVE RUN OFF USERS SEGMENT
	LHL	R5,OOP,R4		:EXAMINE NEXT MESSAGE
	JGFS	POUT14			:SKIP IF NOT HALT COMMAND
POUT12	LIS	R5,0			:SET A 0
POUT13	ST	R5,COC,R1		:0 == HALT...TURN IT OFF
	JR	R0			:AND EXIT

POUT14	CLHI	R5,NPOUTT		:TEST IF VALID OPERATION
	JGEBS	POUT12			:ILLEGAL...TREAT AS HALT
	LHL	R5,POUTT,R5,R5		:LOOK UP ROUTINE ADDRESS
	JR	R5			:AND GO THERE

:	1---OUTPUT COMMAND
POUT15	LIS	R5,0			:SET UP NEW STUFF FOR NEXT TIME
	SH	R5,OCT,R4		:MAKE NEGATIVE
	STH	R5,OCC,R1		:INITIALIZE OUTPUT CHARACTER COUNT
	L	R5,OSP,R4		:OUTPUT STRING POINTER
	S	R5,OAO,R1		:MAKE ABSOLUTE ADDRESS
	ST	R5,COC,R1		:SAVE CURRENT OUTPUT ADDRESS
	J	POUT1			:AND CONTINUE

:	2---TRANSFER
POUT16	LIS	R5,0			:TRANSFER...CLEAN OUT MESSAGE
	STH	R5,OOP,R4
	L	R4,OSP,R4		:GET STRING POINTER
	S	R4,OAO,R1		:BIAS IT
	CL	R4,OALL,R1		:RANGE CHECK ON ADDRESS
	JGE	POUT11			:LOOK IT UP IF IN RANGE
	J	POUT12			:OUT OF RANGE...ABORT

:	TABLE OF CO-ROUTINES ORDERED BY COMMAND
POUTT	HC	POUT13			:0...HALT OUTPUT
	HC	POUT15			:1...OUTPUT
	HC	POUT16			:2...TRANSFER
NPOUTT	EQ	(.-POUTT)/2		:THE NUMBER OF ENTRIES

	EM
	EI	(NPRINT)

	SUBTTL	CLOCK INTERRUPT AND ASYNC DRIVERS

	GL	IZCLOK

	MO	.,CLOCKS		:
					:
NACARD	EQ	(NASYNG+1)/2		:
   IF	N.ADA				:
ADA	EQ	0C1			:NEW ASYNC DEVICE ADDRESS
   ELSE					:
ADA	EQ	91			:OLD ASYNC DEVICE ADDRESS
   EI  (N.ADA)				:
   IF	NASYNG				:
	GL	GPB,APBS		:
NPORT	EQ	NACARD*20		:
   EI  (NASYNG)				:
					:
:	.......................................................................
:	START BY DEFINING MACROS FOR ENHANCED INSTRUCTIONS
:	.......................................................................
					:
SBOD	MACRO[HC	1305]		:RUN SBOD...MAPPED ADDRESS OF TOPORT IN R5
SBODI	MACRO[HC	1603]		:GET INPUT CHARACTER...INPUT BAUD RATE INDEX IN R3
SBODO	MACRO[HC	1400]		:PUT OUTPUT CHARACTER
STID	MACRO[HC	1580]		:PERFORM TID FUNCTION...RETURN TICKS OF SPACE IN R6
LAREG	EQ	10-NASYNG		:LOWEST ASYNC REGISTER USED
F	EQ	18*NACARD		:FRAME SIZE (BYTES)
TIK5	EQ	5*F			:
   IF	NASYNG				:
A.CSIZ	EQ	4*100			:SIZE OF THE CONTROL STORAGE
A.LSIZ	EQ	2*100			:SIZE OF THE TIMEOUT STORAGE
   ELSE					:
A.CSIZ	EQ	0			:SIZE OF THE CONTROL STORAGE
A.LSIZ	EQ	0			:SIZE OF THE TIMEOUT STORAGE
   EI  (NASYNG)				:
					:
:	.......................................................................
:	DEFINE LENGTH (IN TIKMEM UNITS) OF LONGEST CHAR (MXCL)
:	AND SIZE OF ASYNC RING (AS.SIZ)
:	.......................................................................
					:
	GL	AS.SIZ			:
  IF	BAUDR-1				:4800 BAUD
MXCL	EQ	$A 77			:
AS.SIZ	EQ	$A (MXCL+80)*F+18*TIK5	:
  ELSE					:
   IF	BAUDR				:2400 BAUD
MXCL	EQ	$A 39			:
AS.SIZ	EQ	$A (MXCL+40)*F+11*TIK5	:
   ELSE					:1200 BAUD
    IF  LOWSPD				:
MXCL	EQ	$A 115			:
AS.SIZ  EQ      $A(MXCL+85)*F+20*TIK5	:
    ELSE				:
MXCL	EQ	$A 53			:
AS.SIZ	EQ	$A (MXCL+60)*F+20*TIK5	:
    EI (LOWSPD)				:
   EI  (BAUDR)				:
  EI   (BAUDR-1)			:
					:
	GL	AS.CTL			:START OF CONTROL STORAGE
	GL	AS.LCT			:TIMEOUT STORAGE
	GL	AS.RNG			:RING STORAGE
	GL	AS.ERN			:END OF RING
					:
:	.......................................................................
:	INITIALIZATION FOR REGISTER SET 1
:	.......................................................................
					:
					:R0	PSW SAVE
					:R1	WORKING
					:R2	PORT NUMBER
					:R3	OFFSET
IREG1	WC	0			:R4	CONTROL INDEX
	WC	AS.CTL			:R5	CONTROL ADDRESS
	WC	4			:R6	5COUNT
	WC	-AS.SIZ+F/6		:R7	SBX
	WC	-AS.SIZ+F/6		:R8	RGX1
	WC	-AS.SIZ+$AMXCL*F	:R9	RGX
	HC	F/6,2*F/6		:R10	1/6|2/6 FRAME
	HC	3*F/6,4*F/6		:R11	3/6|4/6 FRAME
	HC	5*F/6,F			:R12	5/6|6/6 FRAME
	WC	AS.SIZ			:R13	SIZE OF RING
	WC	AS.ERN			:R14	BASE ADDRESS
   IF	NASYNG				:
	HC	LAREG,ADA		:R15	YD INIT|ADDRESS INIT
   ELSE					:
	HC	8010,ADA		:R15	SIGN BIT SET IF NO ASYNC
   EI  (NASYNG)				:
					:
:	.......................................................................
:	INITIALIZATION FOR REGISTER SET 2
:	.......................................................................
					:
					:R0	PSW SAVE
					:R1	WORKING
					:R2	PORT NUMBER
					:R3	WORKING
					:R4	WORKING
IREG2	WC	-F			:R5	RGX
	WC	-F			:R6	RGI
	WC	AS.ERN			:R7	RING END
	WC	0			:R8	TIME5 COUNT
	WC	-AS.SIZ+$AMXCL*F+TIK5-F/6	:R9	8RGX5) INCR 120 TIMES/SECOND
	WC	LAREG			:R10	YDINIT
   IF	NASYNG				:
	WC	RCHAR			:R11	RCHAR
	WC	XLNGTH			:R12	TCHAR
   ELSE					:
	WC	0			:R11
	WC	0			:R12
   EI  (NASYNG)				:
	WC	AS.SIZ			:R13	RSIZE
	HC	4*TIK5,TIK5		:R14	4*TIKM5|TIKM5
	WC	AS.LCT			:R15	AS.LCT
					:
:	.......................................................................
:	INITIALIZATION FOR REGISTER SET 3
:	EACH REGISTER CORRESPONDS TO ONE GROUP...SBA|TAM
:	INITIALIZATION FOR REGISTER SET 4
:	EACH REGISTER CORRESPONDS TO ONE GROUP...OUT DATA
:	.......................................................................
					:
IREG34	RE	$A 10			:
	HC	-1,-1,-1		:
	ER				:
	HC	-1,-1			:
					:
:	.......................................................................
:	IZSBA  1=> NO NEED TO INITIALIZE SBA
:	.......................................................................
					:
IZSBA	RE	$A16			:
	HC	-1			:
	ER				:
IZRP1	WC	2010,IZRS1		:
IZRP2	WC	2020,IZRS2		:
IZRP3	WC	2030,IZRS3		:
IZRP4	WC	2040,IZRS4		:
IZRPD	WC	20D0,IZRSD		:
IZRPF	WC	20F0,IZR1		:
					:
  IF    TBAUDR
:	..................................................................	
:	function to determine if there is a baudr mismatch and if so to crash
:	isis with a bad00 8779
:	....................................................................
baudcf	eq	.
					:
 	epsr	r5,r5			:psw -> r5
 	sth	r5,timpsw		:save psw
: set up first interrupt to get steady state
 	lhi	r5,0d0			:reg set d (no interrupts)
 	epsr	r6,r5
 	lis	r14,1			:1 tick to prime it
 	la	r15,patbd0
 	lhi	r0,60f0			:reg set f (interrupts)
 	epsr	r1,r0			:go for it
tagin0	j	tagin0			:again
: interrupt routine to set up timing
patbd0	lhi	r5,0d0			:reg set d (no interrupts)
 	epsr	r6,r5
 	lis	r14,6			:6 ticks to boop
 	la	r15,timchk		:set up timchk
 	lhi	r0,60f0			:reg set f (interrupts)
 	epsr	r1,r0
 	lis	r1,0			:start booping
tagin	ais	r1,1			:count
 	jbs	tagin			:again for 6 ticks
: interrupt after 6 ticks.
timchk	eq	.
 	lh	r5,timpsw		:again regset f at int. routine
 	epsr	r6,r5
 	sth	r1,timspc		:store count
 	if	(tsi!nano)
 	REMARK % WARNING no baudr/straping check for TSI/NANO %
 	REMARK %
 	else
 	l	r2,mac340		:check for MAC type
 	if	macv			:determine mac type
 	thi	r2,20
 	jefs	idtypa
 	lhi	r2,2cc1			:cpu4
 	jfs	idtypb
idtypa	lhi	r2,1aa8			:mac5
idtypb	eq	.
 	else
 	nhi	r2,420			:check MAC I.D.
 	jefs	idtyp0
 	xhi	r2,420
 	jefs	idtyp1
idtyp0	lhi	r2,0df4			:MACI OR MACII
 	jfs	idtyp2
idtyp1	lhi	r2,1aa8			:MACIII
idtyp2	eq	.
 	ei	(macv)
 	sth	r2,r2chk		:save for reference
 	if	baudr			:
 	if	baudr-1			:baudr eq 2
 	clr	r1,r2
 	jlfs	stpok
 	s.hltf(0079)
	else				:baudr eq 1
 	REMARK % WARNING no baudr/straping check for baudr equal to 1 %
 	REMARK %
 	ei   (baudr-1)
 	else				:baudr eq 0
 	clr	r1,r2
 	jgfs	stpok
 	s.hltf(0079)
 	ei	(baudr)
 	ei	(tsi!nano)
stpok	eq	.
 	jr	r10
					:
timspc	hs	1			:save count
timpsw	hs	1			:save psw
r2chk	hs	1			:save r2
					:
  EI (TBAUDR)
:	.......................................................................
:	INITIALIZE THE ASYNC (AND CLOCK) STUFF
:	.......................................................................
					:
IZCLOK	LPSW	IZRP1			:START BY SWITCHING TO REGISTER SET 1
IZRS1	LM	R4,IREG1		:*1*
	LPSW	IZRP2			:*1*
IZRS2	LM	R5,IREG2		:*2*
	LPSW	IZRP3			:*2*
IZRS3	LM	R0,IREG34		:*3*
	LPSW	IZRP4			:*3*
IZRS4	LM	R0,IREG34		:*4*
	LPSW	IZRPD			:*4*
IZRSD	LIS	R14,8			:*D*...ALLOW 8 TICKS FOR CLEAN-UP
	LA	R15,TIMEK		:*D*.....BEFORE TRANSFER TO TIMEKEEPER
	LPSW	IZRPF			:*D*...RETURN TO REGISTER SET "F"
IZR1	LCS	R3,1			:
	LI 	R2,AS.RNG+$AMXCL*F-4	:
	SI	R2,AS.CTL		:
IZR2	ST	R3,AS.CTL,R2,		:
	SIS	R2,4			:
	JGEBS	IZR2			:
	LIS	R4,0			:
   IF	NASYNG				:
	LI 	R2,AS.SIZ-$AMXCL*F-4	:
IZR3	ST	R4,AS.RNG+$AMXCL*F,R2,	:
	SIS	R2,4			:
	JGEBS	IZR3			:
	LA	R2,VCLSBA		:INITIALIZE VSTATE TABLE
	LHI	R3,(NPORT-1)*2		:
IZR3A	STH	R2,VSTATE,R3		:
	SIS	R3,2			:
	JGEBS	IZR3A			:
	LCS	R3,1			:
	LHI	R2,(NACARD-1)*4		:
IZR4	ST	R3,RTS,R2		:
	SIS	R2,4			:
	JGEBS	IZR4			:
	JAL	R2,SNDRTS		:
   EI  (NASYNG)				:
	LHI	R2,8000			:
	STH	R2,SLICE		:INSURE NO TIMEOUTS FOR SUFFICIENTLY LONG TIME
	JR	R1			:AND RETURN
					:
   IF	NASYNG				:
					:
:	.......................................................................
:	SEND RTS (REQUEST TO SEND)
:	.......................................................................
					:
SNDRTS	LHI	R3,ADA+2		:
	LHI	R4,-NPORT/8		:SEND OUT NPORT BITS FROM RTS ARRAY
SBSY1	WD	R3,RTS+NPORT/8+1,R4	:SEND 16 BITS, AIM AT RIGHT BYTE OF HALFWORD
	AIS	R3,4			:NEXT DEVICE NUMBER AND...
	AIS	R4,2			:NEXT 16 BITS FROM RTS ARRAY
	JLBS	SBSY1			:
	JR	R2			:
					:
Q	EQ	.			:REMEMBER WHERE WE ARE
	ORG	0			:
					:
:	.......................................................................
:	DEFINE ASYNC POINTER BLOCK ENTRIES
:	.......................................................................
					:
	ORG	0			:
LUATR	BS	4			:LOGICAL UNIT ATRIBUTES
					:	"2"	LIST OF 2 ELEMENTS
					:	N	PHYSICAL GROUP #
					:	80/00	BIT SET IF CAN SUPPORT 1200 BAUD
					:	ADR	GROUP DEVICE ADDRESS
ARBP	HS	2			:RING BLOCK POINTER (START OF 16 PORT RINGS)
ACPP	HS	2			:POINTER TO CP ARRAY
ADSRP	HS	2			:POINTER TO DSR ARRAY
ADTRP	HS	2			:POINTER TO DTR ARRAY
ATOPP	HS	2			:POINTER TO TOPORT ARRAY
AFRPP	HS	2			:POINTER TO FROMPORT ARRAY
ATAMP	HS	2			:POINTER TO TAM ARRAY
APBS	HS	0			:SIZE OF POINTER BLOCK TABLE
	ORG	Q			:
   EI  (NASYNG)				:

   IF	NASYNG				:
					:
RTS	WS	NACARD			:REQUEST TO SEND
TOPORT	WS	NACARD			:DATA PRESENT TO GO TO PORT
BKSERV	WS	NACARD			:BREAK SERVICED RECENTLY (IF RESET)
BKDET	WS	NACARD			:BREAK DETECTED
VSTATE	HS	NPORT			:NEXT STATE FOR INPUT TRANSMITTER TO RUN
DELAY	BS	NPORT			:DELAY TO APPLY TO PORT IF >0
LCTIME	HS	2*NPORT			:LOCATES EARLIEST TIME THAT MORE OUTPUT
					:CAN BE PUT INTO RING
					:INDEXABLE BY PORT*4
IBRATE	BS	NPORT			:INPUT BAUD RATE INDEX
OBRATE	BS	NPORT			:OUTPUT BAUD RATE INDEX
BKTIME	HS	1			:TIMER FOR BREAK-END LOGIC
NNHITS	HS	2			:NUMBER OF NOISE HITS, INACTIVE PORTS
NOISE	HS	2			:COUNTS NUMBER OF TIMES NOISE
					:ENCOUNTERED IN INPUT BAUD RING
BITIND  HS      1                       :INDEX INTO SBA FOR INACTIVE PORT
					:
:	.......................................................................
:	PARAMETERS...******ORDER IS IMPORTANT FOR MICROCODE!!*****
:	CPS:	10     15    30    40    60    120   30    14.7  30/10  120/10
:		   X    X    X    75ms-BK 1/30-DY 1/10-DY
:	.......................................................................
					:
Q	EQ	F/2			:Q IS 1/1200TH OF A SECOND
					:
   IF	BAUDR-1				:
:	.......................................................................
:	4800 BAUD 
:	CPS	X	X	30	X	60	120	X	X
:		30/30	120/30	240	480	X	19MS BK	1/30DLY	1/30DLY
:	Q = 1/4800 SEC
:	.......................................................................
					:
XLNGTH	HC	$A80*Q,80*Q,160*Q,2*Q,80*Q,40*Q,80*Q,80*Q
	HC	$A160*Q,160*Q,20*Q,10*Q,80*Q,90*Q,160*Q,160*Q
					:
:	.......................................................................
:	BAUD LENGTH
:	.......................................................................
					:
BLNGTH	HC	$A1*Q,1*Q,16*Q,1*Q,8*Q,4*Q,1*Q,1*Q
	HC	$A16*Q,4*Q,2*Q,1*Q,1*Q,10*Q,0*Q,0*Q
					:
:	.......................................................................
:	HALF BAUD LENGTH FOR CENTERING
:	.......................................................................
					:
Q	EQ	F/6			:1/14400 SEC
CLNGTH	HC	$A0*Q,0*Q,24*Q,0*Q,12*Q,6*Q,0*Q,0*Q
	HC	$A0*Q,0*Q,3*Q,1*Q,0*Q,0*Q,0*Q,0*Q
:	RECEIVE CHAR LENGTH IN 2*1800 UNITS
RCHAR	HC	$A0,0,456,0,228,114,0,0
	HC	$A0,0,56,28,0,0,0,0
					:
   ELSE
    IF	BAUDR				:
					:
:	.......................................................................
:	2400 BAUD
:	CPS	X	X	30	60	120	X	X
:		30/30	120/30	240	X	30MS BK	1/30DLY	1/30DLY
:	Q = 1/2400 SEC
:	.......................................................................
					:
XLNGTH	HC	$A80*Q,80*Q,80*Q,80*Q,40*Q,20*Q,80*Q,80*Q
	HC	$A80*Q,80*Q,10*Q,80*Q,80*Q,72*Q,80*Q,80*Q
					:
:	.......................................................................
:	BAUD LENGTH
:	.......................................................................
					:
BLNGTH	HC	$A1*Q,1*Q,8*Q,1*Q,4*Q,2*Q,1*Q,1*Q
	HC	$A8*Q,4*Q,1*Q,1*Q,1*Q,9*Q,0*Q,0*Q
					:
:	.......................................................................
:	HALF BAUD LENGTH FOR CENTERING
:	.......................................................................
					:
Q	EQ	F/6			:1/7200 SEC
CLNGTH	HC	$A0*Q,0*Q,12*Q,0*Q,6*Q,3*Q,0*Q,0*Q
	HC	$A0*Q,0*Q,1*Q,0*Q,0*Q,0*Q,0*Q,0*Q
					:
:	.......................................................................
:	RECEIVE CHAR LENTTH IN 2*1800 UNITS
:	.......................................................................
					:
RCHAR	HC	$A0,0,228,0,114,56,0,0
	HC	$A0,0,28,0,0,0,0,0
    ELSE				:
					:
:	.......................................................................
:	1200 BAUD
:	CPS	10	15	30	40	60	120	30	14.7
:		30/10	120/10	50	75	75	75MS BK	1/30DLY	1/10DLY
:	Q = 1/1200 SEC
:
:	TRANSMIT WIDTH
:	.......................................................................
					:
XLNGTH	HC $A	120*Q, 80*Q, 40*Q, 30*Q, 20*Q, 10*Q, 40*Q, 90*Q, 120*Q, 120*Q
	HC	$A 180*Q, 120*Q, 160*Q, 90*Q,   40*Q,   120*Q
					:
:	.......................................................................
:	BAUD WIDTHS
:	.......................................................................
					:
BLNGTH	HC $A	11*Q,  8*Q,  4*Q,  3*Q,  2*Q,  1*Q,  4*Q,  9*Q,  4*Q,   1*Q
	HC	$A 24*Q, 16*Q, 16*Q, 10*Q,   0,      0
Q	EQ	F/6			:ONE FAST TICK
					:
:	.......................................................................
:	CENTER LENGTH
:	.......................................................................
					:
CLNGTH	HC $A	15*Q,  12*Q, 6*Q,  4*Q,  3*Q,  1*Q,  6*Q,  14*Q, 0,     0
	HC	$A 36*Q,	24*Q,	24*Q,	0,	0,	0
					:
:	.......................................................................
					:
:	RECEIVE CHARACTER LENGTH IN 2*1800 UNITS
RCHAR	HC $A	312,   228,  114,  86,   56,   28,   102,  230,  0,     0
	HC	$A468,	312,	456,	0,	0,	0
    EI (BAUDR)				:
   EI  (BAUDR-1)			:
					:
:	.......................................................................
:	STOP BIT CHECK MASK
:	.......................................................................
					:
RMASK	BC	0,0,0,0,0,0,80,80,0,0	:
    IF	BAUDR				:
	BC	0,0,0,20,20,0		:
    ELSE				:
	BC	20,20,0,0,0,0		:
    EI (BAUDR)				:
					:
:	.......................................................................
:	DEDICATED REGISTER USAGE
:	.......................................................................
					:
RLINK	EQ	R10			:LINK REGISTER USED BY ASYNC WHEN IT
					:CALLS PORT RECEIVER OR TRANSMITTER
RCD	EQ	R11			:RING CONTROL DISPLACEMENT FOR CONTROL HALFWORD
RDD	EQ	R12			:RING DATA DISPLACEMENT FOR A SAMPLE RING HALFWORD
RP2	EQ	R13			:TWICE THE PORT NUMBER (RP*2)
RP	EQ	R14			:PORT NUMBER
RX	EQ	R15			:START BAUD INDEX REGISTER
					:
:	.......................................................................
:	TRANSLATE TABLE FOR SPEED COMMANDS
:	.......................................................................
					:
BRMAP	BC	0			:0-> 110 BAUD
	BC	1			:1->150 BAUD
	BC	2			:2->300 BAUD
	BC	3			:3->400 BAUD
	BC	4			:4->600 BAUD
	BC	5			:5->1200 BAUD
	BC	6			:6->300 BAUD (2767)
	BC	7			:7->137.5 BAUD (2741)
	BC	8			:8->300 BAUD AT 10CPS
	BC	9			:9->1200 BAUD AT 10CPS
	BC	0A			:0A->2400 BAUD
	BC	0B			:0B->4800 BAUD
	BC	00			:0C->9600 BAUD (NOT SUPPORTED)
	BC	0A			:0D->50 BAUD BOUDOT
	BC	0B			:0E->75 BAUD BOUDOT
	BC	0C			:0F->75 BAUD ASCII
					:

:	.......................................................................
:	A S Y N C   F O R E G R O U N D   P R O C E S S E S
:	.......................................................................
					:
AFOREG	STH	R0,FFRET4		:SAVE RETURN ADDRESS
					:
:	.......................................................................
:		A S Y N C
:	START-BAUD SCANNER...PROCESS INPUT SIDE
:	.......................................................................
					:
   IF	NEWARN				:Only if uses new Async ring structure
					:
ASYNC	LHI	R1,(NASYNG-1)*2		:FOR EACH GROUP
	LA	R2,(NASYNG-1)*APBS+GPB	:ADDRESS OF LAST GROUP
ASYNC1	L	R3,ATOPP,R2		:GET POINTER TO GROUP'S "TOPORT" BITS
	JEFS	ASYNC2			:
	LHL	R3,0,R3			:GET BITS
ASYNC2	STH	R3,TOPORT,R1		:COPY FOR US TO USE
	SHI	R2,APBS			:NEXT GROUP
	SIS	R1,2			:
	JGEBS	ASYNC1			:DO FOR ALL GROUPS
	LA	R10,ASYN1		:return address for later
ASYN1	LA	R5,TOPORT		:MICROCODE NEEDS TO LOCATE TOPORT
	SBOD				:RUN START BAUD SCANNER
	J	AFORX			:DONE, SKIP TO ASYNC FOREGROUND EXIT
	jfs	ASYN2			:START BAUD DETECTED, R14 AND R13 ARE SET UP
	lr	r0,r0			: ***etm 8/5/88 save 1/2 mike or so
	J	XASCI			:OUTPUT HIT, R14 AND R13 ARE SET UP
ASYN2	LHL	R5,VSTATE,R13		:
	JR	R5			:
   ELSE					:
					:
ASYNC	LHI	R1,(NASYNG-1)*2		:FOR EACH GROUP
	LA	R2,(NASYNG-1)*APBS+GPB	:ADDRESS OF LAST GROUP
ASYNC1	L	R3,ATOPP,R2		:GET POINTER TO GROUP'S "TOPORT" BITS
	JEFS	ASYNC2			:
	LHL	R3,0,R3			:GET BITS
ASYNC2	STH	R3,TOPORT,R1		:COPY FOR US TO USE
	SHI	R2,APBS			:NEXT GROUP
	SIS	R1,2			:
	JGEBS	ASYNC1			:DO FOR ALL GROUPS
ASYN1	LA	R5,TOPORT		:MICROCODE NEEDS TO LOCATE TOPORT
	SBOD				:RUN START BAUD SCANNER
	J	AFORX			:DONE, SKIP TO ASYNC FOREGROUND EXIT
	J	ASYN2			:START BAUD DETECTED, R14 AND R13 ARE SET UP
	JAL	R10,XASCI		:OUTPUT HIT, R14 AND R13 ARE SET UP
	JBS	ASYN1			:
ASYN2	LA	R10,ASYN1		:INPUT RECEIVED
	LHL	R5,VSTATE,R13		:
	JR	R5			:
   EI  (NEWARN)				:
					:
:	.......................................................................
:	GOT HIT ON INACTIVE PORT
:	SCOFF IT UP SO WE WILL NOT BE BOTHERED FOR A WHILE
:	.......................................................................
					:
VCLSBA	LIS	R3,1			:COUNT IT
	AM	R3,NNHITS		:
:	.......................................................................
:	TURN OFF SBA FOR THIS PORT SO WE DONT GET ANY MORE DATA
:	.......................................................................
					:
        LR      R1,R13                  :INDEX
        NHI     R1,001E0                :MAKE HW INDEX
        LR      R0,R14                  :GET INDEX INTO WD
        NHI     R0,0F                   :BY BITS
        AR      R1,R0                   :FORWARD BY THAT MANY BITS
        STH     R1,BITIND               :
	RBT	R14,IZSBA		:REMEMBER THAT WE DID THIS
	ST	R10,VCLRET+4		:RETURN BY LPSW
        LHI     R0,30                   :CHANGE TO REGISTER SET 3
        EPSR    R1,R0                   :*3 INTERRUPTS OFF
        STM     $A16-NASYNG,RSETS       :*3 SAVE REGS
        LH      R1,BITIND               :*3 BIT INDEX
        RBT     R1,RSETS                :*3 CLEAR THE BIT
        LM      $A16-NASYNG,RSETS       :*3 RESTOR REGISTERS
	LPSW	VCLRET			:*3 RETURN TO USER
VCLRET	WC	6AF0			:
        WC      0               	:RETURN FROM RESETTING SBA
					:
VBAUD	LB	R3,IBRATE,R14		:GET INPUT BAUD RATE
	LIS	R1,0			:
	SBODI				:GET THE CHARACTER FROM THE RING
	LHI	R1,1			:NORMAL RETURN IF BREAK NOT DETECTED
	LB	R3,RMASK,R3		:GET STOP BIT MASK FOR BREAK CHECK
	JER	R5			:DONE IF NONE
	LR	R1,R0			:SET UP BREAK BASED ON SHORTER
	NR	R1,R3			:*CHAR LENGTH
	SIS	R3,1			:
	NR	R0,R3			:REMOVE EXTRA HI-ORDER BITS
	JR	R5			:*FROM CHARACTER
					:
XMITR	LB	R2,OBRATE,R14		:NEED BRATE IN R2, PORT NUMBER IN R14
	SBODO				:OUTPUT CHARACTER IN R0
	JR	R5			:
					:
:	.......................................................................
:	TERMINAL SPEED IDENTIFIER
:	.......................................................................
					:
VIDTN	JAL	R5,VBAUD		:NOISE, IGNORE FOR 1/10 SEC
	LR	R1,R1			:CHECK IF BREAK DETECTED
	JE	VIDBR			:YES
	J	VNOISE			:ELSE UPDATE NOISE STATISTICS
VIDT	STID				:DETERMINE NUMBER OF SPACING BITS
	JBS	VIDTN			:SKIP 2 RETURN IF <36D SPACE SAMPLES
VIDT2	LB	R0,VIDTG+$A36,R8	:MAP PULSE WIDTH INTO BAUD RATE
	CLHI	R0,0FF			:
	JE	VIDTN			:BAD PULSE WIDTH
	LR	R1,R0			:OK...COPY IT
	STB	R1,IBRATE,R14		:INITIALIZE INPUT BAUD RATE
	AHI	R0,80			:MAKE TERMINAL SPEED CODE
	JAL	R8,AWCP			:PLACE SPEED PAIR
	JAL	R5,VBAUD		:ASSEMBLE CHAR
	LR	R1,R1			:CHECK IF BREAK DETECTED
	JE	VIDBR			:SKIP IF SO
	JAL	R8,AWCTST		:SEND IN THE CHARACTER
	JR	R10			:AND RETURN
					:
VIDBR	LA	R0,VIDBK		:BREAK DETECTED, VIDBK WILL HANDLE 
	STH	R0,VSTATE,R13		:
	SBT	R14,BKDET		:SET BREAK-DETECTED
	RBT	R14,BKSERV		:SET BREAK-SERVICED
	LHI	R0,90			:
	JAL	R8,AWCP			:SEND PAIR FOR BREAK BEGIN
	JR	R10			:
					:
:	.......................................................................
:	BREAK RECEIVER, LOOKING FOR BREAK END
:	.......................................................................
					:
VIDBK	RBT	R14,BKSERV		:SET BREAK-SERVICED
	JAL	R5,VBAUD		:GET BREAK OR END OF BREAK SIGNAL
	LR	R0,R0			:
	JNFS	VIDBK1			:SKIP IF CHAR # 0 (CONT. BR. END)
	LR	R1,R1			:CHECK IF STILL BREAK
	JER	R10			:ABORT IF STILL IN BREAK STATE
					:
:	.......................................................................
:	END OF BREAK. SEND BREAK CHAR PAIR (00:91) ON
:	.......................................................................
					:
VIDBK1	LA	R0,VIDT			:
	STH	R0,VSTATE,R13		:RETURN TO NORMAL TID
	RBT	R14,BKDET		:CLEAR BREAK-DETECTED
	LHI	R0,91			:
	JAL	R8,AWCP			:
	JR	R10			:
					:
					:
   IF	NEWARN				:Only if uses new Async ring structure
					:
:	.......................................................................
:	ASYNC ASCII TERMINAL RECEIVER
:	Note(s) - Inline vbaud and awctst ***etm 8/8/88
:	.......................................................................
					:
vasci	LB	R3,IBRATE,R14		:GET INPUT BAUD RATE
	LIS	R1,0			:
	SBODI				:GET THE CHARACTER FROM THE RING
	LHI	R1,1			:NORMAL RETURN IF BREAK NOT DETECTED
	LB	R3,RMASK,R3		:GET STOP BIT MASK FOR BREAK CHECK
	jefs	vasci2			:DONE IF NONE
	LR	R1,R0			:SET UP BREAK BASED ON SHORTER
	NR	R1,R3			:*CHAR LENGTH
	SIS	R3,1			:
	NR	R0,R3			:REMOVE EXTRA HI-ORDER BITS
vasci2	lr	r1,r1			: break detected?
	jnfs	vasci1			:
	j	vasbr			:
vasci1	lr	r0,r0			: see if escaped char
	jnfs	vasci3			:
	lr	r8,r10			: make awcp return to the right place
	j	awcp			: sleazy, but effective
vasci3	LIS	R4,1			:set an incrementer
	L	R2,ARIR,R13,r13		:get pointer to ring
	LH	R3,AR.FC,R2		:get fill cursor
	STB	R0,ar.ic,R2,R3		:place character
	ais	r3,1			:decrement cursor
	jlfs	vasci4			: if >= 0
	sh	r3,ar.rs,r13		: reset to point to end of ring
vasci4	STH	R3,AR.FC,R2		:place the cursor
	AHM	R4,AR.BCT,R2		:increment BCT
	JNR	R10			:wasn't empty...just exit
	L	R3,BFI,R13,r13		:was empty...get pointer to bit
	CBT	R3,0			:
	JR	R10			:
   ELSE					:
					:
:	.......................................................................
:	ASYNC ASCII TERMINAL RECIVER
:	.......................................................................
					:
VASCI	JAL	R5,VBAUD		:ASSEMBLE CHAR
	LR	R1,R1			:CHECK IF BREAK DETECTED
	JEFS	VASBR			:BR IF SO
	JAL	R8,AWCTST		:NO...SEND CHAR
	JR	R10			:Return
					:
   EI  (NEWARN)				:
					:
VASBR	LA	R0,VASBK		:BREAK DETECTED, VASBK WILL HANDLE 
	STH	R0,VSTATE,R13		:
	SBT	R14,BKDET		:SET BREAK-DETECTED
	RBT	R14,BKSERV		:SET BREAK-SERVICED
	LHI	R0,90			:
	JAL	R8,AWCP			:SEND IN A PAIR FOR BREAK-BEGIN
	JR	R10			:
					:
:	.......................................................................
:	BREAK RECEIVER, LOOKING FOR BREAK END
:	.......................................................................
					:
VASBK	RBT	R14,BKSERV		:SET BREAK-SERVICED
	JAL	R5,VBAUD		:GET BREAK OR END OF BREAK SIGNAL
	LR	R0,R0			:
	JNFS	VASBK1			:SKIP IF CHAR. # 0 (CONT. BR. END)
	LR	R1,R1			:VERIFY IF BREAK STILL ONGOING
	JER	R10			:JUST EXIT IF SO
					:
:	.......................................................................
:	END OF BREAK. SEND BREAK CHAR PAIR (00:91) ON
:	.......................................................................
					:
VASBK1	LA	R0,VASCI		:
	STH	R0,VSTATE,R13		:RETURN TO NORMAL RECEIVER
	RBT	R14,BKDET		:CLEAR BREAK-DETECTED
	LHI	R0,91			:
	JAL	R8,AWCP			:
	JR	R10			:
					:
:	.......................................................................
:	BAUD RATE INDEX TABLE (4 BITS INPUT/4 BITS OUTPUT)
:	.......................................................................
					:
   IF	BAUDR-1				:4800 BAUD MAX
VIDTG	BC	0B			:4800 BAUD
	BC	0A,0A			:2400
	BC	5,5			:1200
	BC	0FF,0FF,0FF,0FF		:
	BC	0FF,0FF,0FF,0FF		:
	BC	2,2,2,2			:300
	BC	0FF,0FF,0FF,0FF,0FF	:
	BC	0FF,0FF,0FF,0FF,0FF	:
	BC	0FF,0FF,0FF,0FF,0FF	:
	BC	0FF,0FF,0FF,0FF		:
   ELSE					:
    IF	BAUDR				:2400 BAUD MAX
VIDTG	BC	0A			:2400 BAUD
	BC	5,5			:1200
	BC	0FF,0FF,0FF		:
	BC	2,2,2			:300
	BC	0FF,0FF,0FF,0FF,0FF	:
	BC	0FF,0FF,0FF,0FF,0FF	:
	BC	0FF,0FF,0FF,0FF,0FF	:
	BC	0FF,0FF,0FF,0FF,0FF	:
	BC	0FF,0FF,0FF,0FF,0FF	:
	BC	0FF,0FF			:
    ELSE				:1200 BAUD MAX
VIDTG	BC	5,5			:1200 BAUD
	BC	2,2,2			:3,4, OR 5 SAMPLE FOR 300 BAUD
	BC	0FF,0FF			:
	BC	7,7,7			:14.7 CPS
	BC	0FF,0FF,0FF,0FF		:
	BC	1,1,1			:15 CPS
	BC	0FF,0FF,0FF,0FF		:
	BC	0FF,0FF,0FF,0FF		:
	BC	0FF,0FF,0FF,0FF		:
	BC	0,0,0,0,0,0,0 		:10 CPS
	BC	0FF			:
    EI (BAUDR)				:
   EI  (BAUDR-1)			:
					:
VNOISE	LIS	R1,1			:INPUT RING NOISE SAMPLES FOUND
	AM	R1,NOISE		:
	JR	R10			:
					:

					:
:	.......................................................................
:	ASYNC FOREGROUND EXIT
:	.......................................................................
					:
AFORX	LCS	R0,1			:CHECK TIMEOUT
	AHM	R0,BKTIME		:
	JG	FFRET			:EXIT IF NOT YET TIMED-OUT
	LHI	R0,$A 33		:SERVICE EVERY 33 TURNS
	STH	R0,BKTIME		:(33*5 ms/TURN = 165ms)
	LHI	R9,(NACARD-1)*4		:FOR EACH CARD:
AFORX1	L	R1,BKDET,R9		:FIND BREAK DETECTED
	N	R1,BKSERV,R9		:AND NOT SERVICED
	JNFS	AFORX2			:SKIP IF ANY EXIST
	LCS	R1,1			:ELSE SET ALL IN GROUP NOT SERVICED
	ST	R1,BKSERV,R9		:
	SIS	R9,4			:REPEAT FOR ALL CARDS
	JGEBS	AFORX1			:
	J	FFRET			:THEN EXIT
AFORX2	JAL	R3,BID			:LOCATE OFFENDING PORT
	LR	R14,R9			:COMPUTE PORT #
	SLHLS	R14,3			:(ALLOW FOR WORD INDEXING)
	AR	R14,R2			:
	LR	R13,R14			:COMPUTE R13 AS WELL
	AR	R13,R13			:
	LHL	R5,VSTATE,R13		:FIND BREAK DETECTOR TO USE
	LA	R10,AFORX1		:SET RETURN ADDRESS
	CLHI	R5,VIDBK		:GO CLEANUP IF VSTATE=="VIDBK"
	JE	VIDBK1			:
	CLHI	R5,VASBK		:..OR IF VSTATE=="VASBK"
	JE	VASBK1			:
	RBT	R14,BKDET		:ELSE FORGET IT
	J	AFORX1			:AND REPEAT FOR ANY OTHERS
					:
   IF	NEWARN				:Only if uses new Async ring structure
					:
:	.......................................................................
:	ASYNC ASCII TRANSMITTER
:	.......................................................................
					:
XASCI	LB	R1,DELAY,R14		:DELAY MODE?
:	SIS	R1,1			:
:	JGE	XAS3			:SKIP IF DELAYING
	jlefs	xasci0			:
	j	xas3			: skip if delayingng ***etm
					:
:	.......................................................................
:	Note: In-line agci and agcip	***etm 8/5/88
:	.......................................................................
					:
xasci0	LCS	R4,1			:get a decrementer
	L	R1,AROR,R13,r13		:pointer to ring
	LH	R3,AR.EC,R1		:cursor for character
	LB	R0,ar.ic,R1,R3		:get the data character
	ais	r3,1			:increment cursor
	jlfs	xagc1			: if >= 0
	sh	r3,ar.rs,r13		: reset to point to beginnin of ring
xagc1	lr	r0,r0			: an escape character?
	jnfs	xagc2			:
	j	xagcp			:speed hack for common case
xagc2	LB	R2,OBRATE,R14		:NEED BRATE IN R2, PORT NUMBER IN R14
	SBODO				:OUTPUT CHARACTER IN R0
	STH	R3,AR.EC,R1		:restore cursor
	AHM	R4,AR.BCT,R1		:decrement BCT
	jger	r10			:skip if not last character
	L	R3,BFO,R13,r13		:else locate flag bit
	CBT	R3,0			:...and flip it
	RBT	R14,TOPORT		:don't look again
xagc3	jr	r10			:
					:
xagcp	lb	r0,ar.ic,r1,r3		:
	sis	r4,1			:one more character
	ais	r3,1			:
	jlfs	xagcp2			:
	sh	r3,ar.rs,r13		:
xagcp2	STH	R3,AR.EC,R1		:restore cursor
	AHM	R4,AR.BCT,R1		:decrement BCT
	jgefs	xagcp3			:skip if not last character
	L	R3,BFO,R13,r13		:else locate flag bit
	CBT	R3,0			:...and flip it
	RBT	R14,TOPORT		:don't look again
xagcp3	LR	R1,R0			:TEST FOR DATA ESCAPE
	JNFS	XAS2			:SKIP IF NOT
					:
					:
:	.......................................................................
:	Note: Inlined call to xmitr ***etm 8/5/88
:	.......................................................................
					:
xas1	LB	R2,OBRATE,R14		:NEED BRATE IN R2, PORT NUMBER IN R14
	SBODO				:OUTPUT CHARACTER IN R0
	j	asyn1			:branch straight back in common case
:	JR	R10			:
					:
:	.......................................................................
:	SPECIAL CHARACTER PROCESSORS:
:	.......................................................................
					:
XAS2	LHI	R2,-90,R1		:CHECK FOR DELAY (1-8F)
	JGE	XAS4			:SKIP IF NOT
xas3	sis	r1,1			:
	stb	r1,delay,r14		: *** etm 8/5/88
	LIS	R2,0E			:DELAY FOR 1/30 SECOND
   IF	BAUDR				:
   ELSE					:
	SIS	R1,2			:
	JLFS	XAS3A			:SKIP IF LESS THAN 3 OF THESE DELAYS REMAIN
	LIS	R2,0F			:ELSE SET DELAY FOR 1/10 SECOND
	STB	R1,DELAY,R14		:SAVE NEW DELAY COUNT
   EI  (BAUDR)				:
XAS3A	LIS	R0,0			:NOT NEEDED, BUT SPEEDS MICROCODE
	SBODO				:NEEDS PORT NUMBER IN R14
	JR	R10			:
					:
XAS4	LHI	R1,-20,R2		:NOW CHECK FOR OUTPUT BAUD RATE (90-AF)
	JGEFS	XAS5			:
        TBT     R2,VALSPD               :IS THIS SPEED VALID
        JER     R10                     :IGNORE IF NOT
        LB      R2,BRMAP,R2             :TRANSLATE INTO INDEX
	STB	R2,OBRATE,R14		:CHANGE IT
	JR	R10			:
					:
XAS5	LHI	R2,-20,R1		:NOW CHECK FOR INPUT BAUD RATE (B0-CF)
	JGEFS	XAS6			:SKIP IF NOT
        TBT     R1,VALSPD               :IS THIS SPEED VALID
        JER     R10                     :IGNORE IF NOT
        LB      R1,BRMAP,R1             :TRANSLATE INTO INDEX
	STB	R1,IBRATE,R14		:CHANGE IT
	JR	R10			:
					:
XAS6	LHI	R1,-10,R2		:CHECK FOR ENTER CONNECT MODE (D0-DF)
	JGE	XAS7			:
	LR	R2,R2			:ONLY HAVE 1 POSSIBLE FOR NOW
	JNR	R10			:
	RBT	R14,BKDET		:CLEAR BREAK-DETECTED
	STB	R2,IBRATE,R14		:FORCE 10 CPS DEFAULT INPUT
	LA	R1,VIDT			:SET TYMNET TID STATE
	STH	R1,VSTATE,R13		:
        J       XAS7A			:
XAS7	JG  	XAS8			:CHECK FOR ENTER DATA MODE (E0)
	LA	R0,VASCI		:YES...CHANGE TABLE
	STH	R0,VSTATE,R13		:
					:
:	.......................................................................
:	INSURE THAT SBA IS ON FOR THIS PORT
:	.......................................................................
					:
XAS7A	SBT	R14,IZSBA		:REMEMBER THAT THIS IS DONE
	JNR	R10			:IF BIT WAS ALREADY 1 WE ARE DONE
	LR	R1,R13			:
        NHI     R1,01E0                 :MAKE HW INDEX
        LR      R0,R14                  :GET INDEX INTO WD
        NHI     R0,0F                   :BY BITS
        AR      R1,R0                   :MOVE FORWARD
        STH     R1,BITIND               :SAVE THIS INDEX
	ST	R10,VCLRET+4		:SAVE RETURN FOR LPSW
        LHI     R0,30                   :CHANGE TO RSET 30
        EPSR    R1,R0                   :*3 INTERRUPTS OFF
        STM     $A16-NASYNG,RSETS       :*3 SAVE REGS
        LH      R1,BITIND               :*3 SIGN EXTEND REQUIRED
        SBT     R1,RSETS                :*3 TURN ON BIT
        LM      $A16-NASYNG,RSETS       :*3
	LPSW	VCLRET			:*3 RETURN WITH INTERRUPTS ENABLED
					:
XAS8	SIS	R1,2			:CHECK FOR DISCONNECT (E1)
	JGEFS	XAS9			:
	LA	R0,VCLSBA		:
	STH	R0,VSTATE,R13		:SET SBA OFF
	JR	R10			:
					:
XAS9	JGFS	XAS10			:SKIP IF NOT ENABLE (E2)
	JR	R10			:
					:
XAS10	SIS	R1,2			:CHECK FOR RS UP (E3)
	JGEFS	XAS11			:
	RBT	R14,RTS			:YES...BIT ON
	JAL	R2,SNDRTS		:AND SEND IT
	JR	R10			:
					:
XAS11	JGFS	XAS12			:CHECK FOR RS DOWN (E4)
	SBT	R14,RTS			:YES...BIT OFF
	JAL	R2,SNDRTS		:AND SEND IT
	JR	R10			:
					:
XAS12	SIS	R1,2			:CHECK FOR BREAK-EMIT (E5)...TOSS IF NOT
	JGER	R10			:
	LIS	R2,0D			:ELSE BREAK FOR 75 MS
	LIS	R0,0			:NOT NEEDED, BUT SPEEDS MICROCODE
	SBODO				:NEEDS PORT NUMBER IN R14
	JR	R10			:
					:
   ELSE					:Use regulart Async ring structure
:	.......................................................................
:	ASYNC ASCII TRANSMITTER
:	.......................................................................
					:
XASCI	LB	R1,DELAY,R14		:DELAY MODE?
	SIS	R1,1			:
	JGE	XAS3			:SKIP IF DELAYING
	JAL	R8,AGCI			:ELSE FETCH NEXT CHAR FOR OUTPUT
	LR	R0,R0			:CHECK FOR ESCAPE
	JNFS	XAS1			:SKIP IF NOT
	JAL	R8,AGCIP		:ESCAPED...GET CONTROL
	LR	R1,R0			:TEST FOR DATA ESCAPE
	JNFS	XAS2			:SKIP IF NOT
XAS1	JAL	R5,XMITR		:TRANSMIT
	JR	R10			:
					:
:	.......................................................................
:	SPECIAL CHARACTER PROCESSORS
:	.......................................................................
					:
XAS2	LHI	R2,-90,R1		:CHECK FOR DELAY (1-8F)
	JGE	XAS4			:SKIP IF NOT
	SIS	R1,1			:YES...REDUCE IT
XAS3	STB	R1,DELAY,R14		:SAVE NEW DELAY COUNT
	LIS	R2,0E			:DELAY FOR 1/30 SECOND
   IF	BAUDR				:
   ELSE					:
	SIS	R1,2			:
	JLFS	XAS3A			:SKIP IF LESS THAN 3 OF THESE DELAYS REMAIN
	LIS	R2,0F			:ELSE SET DELAY FOR 1/10 SECOND
	STB	R1,DELAY,R14		:SAVE NEW DELAY COUNT
   EI  (BAUDR)				:
XAS3A	LIS	R0,0			:NOT NEEDED, BUT SPEEDS MICROCODE
	SBODO				:NEEDS PORT NUMBER IN R14
	JR	R10			:
					:
XAS4	LHI	R1,-20,R2		:NOW CHECK FOR OUTPUT BAUD RATE (90-AF)
	JGEFS	XAS5			:
        TBT     R2,VALSPD               :IS THIS SPEED VALID
        JER     R10                     :IGNORE IF NOT
        LB      R2,BRMAP,R2             :TRANSLATE INTO INDEX
	STB	R2,OBRATE,R14		:CHANGE IT
	JR	R10			:
					:
XAS5	LHI	R2,-20,R1		:NOW CHECK FOR INPUT BAUD RATE (B0-CF)
	JGEFS	XAS6			:SKIP IF NOT
        TBT     R1,VALSPD               :IS THIS SPEED VALID
        JER     R10                     :IGNORE IF NOT
        LB      R1,BRMAP,R1             :TRANSLATE INTO INDEX
	STB	R1,IBRATE,R14		:CHANGE IT
	JR	R10			:
					:
XAS6	LHI	R1,-10,R2		:CHECK FOR ENTER CONNECT MODE (D0-DF)
	JGE	XAS7			:
	LR	R2,R2			:ONLY HAVE 1 POSSIBLE FOR NOW
	JNR	R10			:
	RBT	R14,BKDET		:CLEAR BREAK-DETECTED
	STB	R2,IBRATE,R14		:FORCE 10 CPS DEFAULT INPUT
	LA	R1,VIDT			:SET TYMNET TID STATE
	STH	R1,VSTATE,R13		:
        J       XAS7A			:
					:
XAS7	JG  	XAS8			:CHECK FOR ENTER DATA MODE (E0)
	LA	R0,VASCI		:YES...CHANGE TABLE
	STH	R0,VSTATE,R13		:
					:
:	.......................................................................
:	INSURE THAT SBA IS ON FOR THIS PORT
:	.......................................................................
					:
XAS7A	SBT	R14,IZSBA		:REMEMBER THAT THIS IS DONE
	JNR	R10			:IF BIT WAS ALREADY 1 WE ARE DONE
	LR	R1,R13			:
        NHI     R1,01E0                 :MAKE HW INDEX
        LR      R0,R14                  :GET INDEX INTO WD
        NHI     R0,0F                   :BY BITS
        AR      R1,R0                   :MOVE FORWARD
        STH     R1,BITIND               :SAVE THIS INDEX
	ST	R10,VCLRET+4		:SAVE RETURN FOR LPSW
        LHI     R0,30                   :CHANGE TO RSET 30
        EPSR    R1,R0                   :*3 INTERRUPTS OFF
        STM     $A16-NASYNG,RSETS       :*3 SAVE REGS
        LH      R1,BITIND               :*3 SIGN EXTEND REQUIRED
        SBT     R1,RSETS                :*3 TURN ON BIT
        LM      $A16-NASYNG,RSETS       :*3
	LPSW	VCLRET			:*3 RETURN WITH INTERRUPTS ENABLED
					:
XAS8	SIS	R1,2			:CHECK FOR DISCONNECT (E1)
	JGEFS	XAS9			:
	LA	R0,VCLSBA		:
	STH	R0,VSTATE,R13		:SET SBA OFF
	JR	R10			:
					:
XAS9	JGFS	XAS10			:SKIP IF NOT ENABLE (E2)
	JR	R10			:
					:
XAS10	SIS	R1,2			:CHECK FOR RS UP (E3)
	JGEFS	XAS11			:
	RBT	R14,RTS			:YES...BIT ON
	JAL	R2,SNDRTS		:AND SEND IT
	JR	R10			:
					:
XAS11	JGFS	XAS12			:CHECK FOR RS DOWN (E4)
	SBT	R14,RTS			:YES...BIT OFF
	JAL	R2,SNDRTS		:AND SEND IT
	JR	R10			:
					:
XAS12	SIS	R1,2			:CHECK FOR BREAK-EMIT (E5)...TOSS IF NOT
	JGER	R10			:
	LIS	R2,0D			:ELSE BREAK FOR 75 MS
	LIS	R0,0			:NOT NEEDED, BUT SPEEDS MICROCODE
	SBODO				:NEEDS PORT NUMBER IN R14
	JR	R10			:Return
					:
   EI  (NEWARN)				:
					:
:	.......................................................................
:	FULLWORD Bit identifier
:	returns original word in R1
:	number of leftmost non-zero bit in R2
:	.......................................................................
					:
BID	JFFO	R1,BID1			:LOCATE THE BIT
	LIS	R2,0			:FOUND NOTHING
BID1	JR	R3			:AND RETURN
					:

					:
   IF	ASYNEW-1			:
   ELSE					:
    IF	ASYNEW				:
:	.......................................................................
:	REDIFNE DRIVER ROUTINES, AND
:	CREATED NEW CALLS TO PICK BETWEEN
:	THE METHODS
:	.......................................................................
					:
NANEW	HS	NASYNG			:
AGCI	TBT	R14,NANEW		:
	JN	NAGCI
	J	OAGCI
AWCI	TBT	R14,NANEW
	JN	NAWCI
	J	OAWCI
AWCP	TBT	R14,NANEW
	JN	NAWCP
	J	OAWCP
AGCIP	TBT	R14,NANEW
	JN	NAGCIP			:
	J	OAGCIP			:
AWCTST	TBT	R14,NANEW		:
	JN	NAWTST			:
	J	OAWTST			:
    EI (ASYNEW)				:
   EI  (ASYNEW-1)			:
					:
   IF	ASYNEW-1			:
   ELSE					:


:	.......................................................................
:	ASYNC RING HANDLING
:	.......................................................................
					:
Q	HS	0			:REMEMBER WHERE WE ARE
	ORG	0			:
					:
:	.......................................................................
:	DEFINE RING BLOCK ENTRIES
:	.......................................................................
					:
RSIZE	EQ	$A14			:SIZE OF A RING
ROF	BS	1			:RING OUTPUT FILL INDEX
ROE	BS	1			:RING OUTPUT EMPTY INDEX
RO	BS	RSIZE			:THE OUTPUT RING
RIF	BS	1			:RING INPUT FILL INDEX
RIE	BS	1			:RING INPUT EMPTY INDEX
RI	BS	RSIZE			:THE INPUT RING
RBS	BS	0			:SIZE OF RING BLOCK
					:
	ORG	Q			:RETURN TO NORMAL ADDRESS SPACE
					:
:	.......................................................................
:	Get a char from Async input ring
:	R8	link
:	R10 return if ring empty, turns off FPORT bit
:	else char in R0
:	.......................................................................
					:
AGCI	LIS	R7,0F			:EXTRACT PORT/GROUP
	NR	R7,R14			:
	LR	R5,R7			:MAKE COPY
	SLHLS	R5,5			: *32
	LR	R6,R14			:NOW GET GROUP INDEX
	SRHLS	R6,4			:EXTRACT GROUP NUMBER
	AR	R6,R6			:
	LH	R6,GPBX,R6		:GET OFFSET INTO GROUP PARAMETERS
	A	R5,GPB+ARBP,R6		:GET RING BLOCK ADDRESS
	LB	R4,RIE,R5		:GET EMPTY INDEX
					:
:	.......................................................................
:	ADDITIONAL ENTRY POINT FOR GETTING SUBSEQUENT CHARS FOR SAME PORT
:	.......................................................................
					:
AGCIP	CLB	R4,RIF,R5		:TEST IF RING EMPTY
	JNFS	AGCI1			:SKIP IF NOT
	LR	R8,R10			:ELSE ABORT RETURN
	J	AGCI6			:AND SKIP
AGCI1	LB	R0,RI,R4,R5		:NOT EMPTY...GET THE CHAR
	AIS	R4,1			:BUMP INDEX
	CLHI	R4,RSIZE		:
	JLFS	AGCI2			:
	LIS	R4,0			:FOLD INDEX IF NECESSARY
AGCI2	STB	R4,RIE,R5		:SAVE IT
AGCI3	LB	R2,RIF,R5		:CHECK IF NOW EMPTY
	LR	R3,R2			:SAVE COPY
	SR	R2,R4			:
	JGEFS	AGCI4			:WRAP AROUND
	AIS	R2,RSIZE		:
AGCI4	SIS	R2,4			:CHECK RANGE
	JGR	R8			:EXIT IF MORE THAN 4 CHARS STILL THERE
	L	R1,GPB+ATAMP,R6		:ELSE TURN ON HIS TRANSMITTER ACTIVE FLAG
	JEFS	AGCI5			:HE DOESN'T CARE
	SBT	R7,0,R1			:ELSE TELL HIM TO GO AGAIN
	CLB	R3,RIF,R5		:
	JEFS	AGCI5			:NO RACE OCCURED
	RBT	R7,0,R1			:ELSE TRY AGAIN
	J	AGCI3			:
AGCI5	CR	R3,R4			:CHECK IF NOW EMPTY
	JNR	R8			:EXIT IF NOT EMPTY
AGCI6	L	R1,GPB+ATOPP,R6		:CHECK HIS BIT FLAG
	JEFS	AGCI7			:SKIP IF NONE
	RBT	R7,0,R1			:TURN OFF HIS BIT
	CLB	R4,RIF,R5		:CHECK FOR RACE
	JEFS	AGCI7			:
	SBT	R7,0,R1			:ELSE CANCEL IT
	JR	R8			:AND EXIT
AGCI7	RBT	R14,TOPORT		:TURN OFF OUR BIT SO WE WON'T LOOK AGAIN
	JR	R8			:AND EXIT
					:
:	.......................................................................
:	test if to place one or two data chars in async ouput ring
:	.......................................................................
					:
AWCTST	LR	R0,R0			:TEST IF CHAR SHOULD BE ESCAPED
	JE	AWCP			:YES...SEND ESCAPED PAIR
					:
:	.......................................................................
:	Place a single char in Async output ring
:	R8	link
:	R0	char to transmit
:	.......................................................................
					:
AWCI	LIS	R5,0F			:EXTRACT PORT/GROUP
	NR	R5,R14			:
	LR	R4,R5			:MAKE COPY
	SLHLS	R4,5			: *32
	LR	R2,R14			:NOW GET GROUP INDEX
	SRHLS	R2,4			:
	AR	R2,R2			:
	LH	R2,GPBX,R2		:GET OFFSET INTO GROUP PARAMETERS
	L	R1,GPB+ARBP,R2		:GET RING BLOCK ADDRESS
	JE	AWCI3			:SKIP IF NULL
	AR	R4,R1			:RING BLOCK ADDRESS FOR THIS PORT
	LB	R3,ROF,R4		:INDEX INTO RING
AWCI1	STB	R0,RO,R4,R3		:PLACE CHAR
	AIS	R3,1			:
	CLHI	R3,RSIZE		:
	JLFS	AWCI2			:SKIP IF NO RING FOLDING
	LIS	R3,0			:
AWCI2	STB	R3,ROF,R4		:UPDATE INDEX
	L	R1,GPB+AFRPP,R2		:
	JER	R8			:ABORT IF NULL POINTER
	SBT	R5,0,R1			:FLAG IT IN PLACE
	CLB	R3,ROE,R4		:MAKE SURE WE HAVEN'T SET IT TOO LATE
	JNR	R8			:
	RBT	R5,0,R1			:ELSE CANCEL FLAG
	JR	R8			:AND EXIT
					:
AWCI3	JR	R8			:AND EXIT
					:
:	.......................................................................
:	Place escaped char in Async output ring
:	R8	link
:	R0	char to transmit
:	.......................................................................
					:
AWCP	LIS	R5,0F			:EXTRACT PORT/GROUP
	NR	R5,R14			:
	LR	R4,R5			:MAKE COPY
	SLHLS	R4,5			: *32
	LR	R2,R14			:NOW GET GROUP INDEX
	SRHLS	R2,4			:
	AR	R2,R2			:
	LH	R2,GPBX,R2		:GET OFFSET INTO GROUP PARAMETERS
	L	R1,GPB+ARBP,R2		:GET RING BLOCK ADDRESS
	JEBS	AWCI3			:ABORT IF NULL
	AR	R4,R1			:RING BLOCK ADDRESS FOR THIS PORT
	LB	R3,ROF,R4		:INDEX INTO RING
	LIS	R1,0			:SEND ESCAPE
	STB	R1,RO,R4,R3		:
	AIS	R3,1			:
	CLHI	R3,RSIZE		:
	JL	AWCI1			:PROCEED IF NO RING FOLDING
	LIS	R3,0			:
	J	AWCI1			:
					:
   EI  (ASYNEW-1)			:
   IF	ASYNEW-1			:
   ELSE					:
    IF	ASYNEW				:
					:
:	.......................................................................
:	BOTH MECHANISMS ARE IN USE, REDEFINE ROUTINE NAMES SO THEY MAY BE
:	DIFFERENTIATED FROM THE NEW NAMES
:	.......................................................................
					:
OAGCI	EQ	AGCI			:
OAWCI	EQ	AWCI			:
OAWCP	EQ	AWCP			:
OAGCIP	EQ	AGCIP			:
OAWTST	EQ	AWCTST			:
    EI (ASYNEW)				:
   EI  (ASYNEW-1)			:
					:
   IF	ASYNEW				:
					:
:	.......................................................................
:	define layout of ring:
:	.......................................................................
					:
   IF	NEWARN				:Only if uses new Async ring structure
AR.BCT	EQ	0			:Halfword BCT...Empty when = -1
AR.FC	EQ	2			:Byte fill  cursor (rel. to ring start)
AR.EC	EQ	4			:Byte empty cursor (rel. to ring start)
AR.IC	EQ	0			:Byte inital cursor
   ELSE					:
AR.BCT	EQ	0			:halfword BCT...empty when =-1
AR.TAM	EQ	2			:halfword TAM threshold..TAM on when >0
AR.FC	EQ	4			:byte fill cursor (rel. to ring start)
AR.EC	EQ	5			:byte empty cursor (rel. to ring start)
AR.IC	EQ	6			:byte initial cursor
   EI  (NEWARN)				:
					:
:	.......................................................................
:	Define associated storage
:	.......................................................................
					:
BFO	WS	NASYNG*10		:Job output flags
   IF	NEWARN				:If uses the New Async ring structure
   ELSE					:
TAM	WS	NASYNG*10		:job transmitter-active flags
   EI  (NEWARN)				:
BFI	WS	NASYNG*10		:job input flags
AROR	WS	NASYNG*10		:pointer to port output ring
ARIR	WS	NASYNG*10		:pointer to port input ring
					:(note...high byte = maximum value)
   IF	NEWARN				:
AR.RS	HS	NASYNG*10		:Storage for ring size -1
   ELSE					:
TAMMER	WS	4*NACARD		:transition-array for TAM
   EI  (NEWARN)				:
					:
   IF	NEWARN				:Only if uses new Async ring structure
					:
:	.......................................................................
:	Get a char from ASYNC output ring
:	R8 -	link
:	R10 -	return if ring empty, turns off FPORT bit
:		else char in R0
:	Entry-point for control-character
:	.......................................................................
					:
AGCIP	L	R3,BFO,R13,R13		:get pointer to data-flag
	SBT	R3,0			:make sure it's set
					:
:	.......................................................................
:	Entry-point for data character
:
:	modified to use halfword cursors that decrement to the beginning
:	of the ring and no TAM array.***etm
:	.......................................................................
					:
AGCI	LR	R1,R13			:make buffer index
	AR	R1,R1			:
	LCS	R4,1			:get a decrementer
	L	R2,AROR,R1		:pointer to ring
:	LB	R3,AR.EC,R2		:cursor for character
	LH	R3,AR.EC,R2		:cursor for character
:	LB	R0,0,R2,R3		:get the data character
	LB	R0,ar.ic,R2,R3		:get the data character
:	AIS	R3,1			:bump cursor
:	CLB	R3,AROR,R1		:check for fold
:	JNFS	AGC1			:skip if not
:	LIS	R3,AR.IC		:else fold cursor
	ais	r3,1			:increment cursor
	jlfs	agc1			: if >= 0
	sh	r3,ar.rs,r13		: reset to point to beginnin of ring
:AGC1	STB	R3,AR.EC,R2		:restore cursor
AGC1	STH	R3,AR.EC,R2		:restore cursor
	AHM	R4,AR.BCT,R2		:decrement BCT
:	JGEFS	AGC2			:skip if not last character
	jger	r8			:skip if not last character
	L	R3,BFO,R1		:else locate flag bit
	CBT	R3,0			:...and flip it
	RBT	R14,TOPORT		:don't look again
:AGC2	AHM	R4,AR.TAM,R2		:decrement TAM count
:	JGR	R8			:return if >0
:	JLFS	AGC3			:less, check TAM
:	SBT	R14,TAMMER		:note that we passed through zero
:	JR	R8			:
:AGC3	RBT	R14,TAMMER		:what is the state
:	JER	R8			:
:	L	R3,TAM,R1		:locate TAM bit
:	CBT	R3,0			:
	JR	R8			:
					:
:	.......................................................................
:	Place escaped char in ASYNC input ring
:	R8 -	link
:	R0 -	char to transmit
:
:	modified to use halfword cursors that decrement to the beginning
:	of the ring and no TAM array.***etm
:	.......................................................................
					:
AWCP	LR	R1,R13			:make port index
	AR	R1,R1			:
:	LIS	R4,1			:set an incrementer
	LIS	R5,0			:preceed with a null
	L	R2,ARIR,R1		:pointer to ring
:	LB	R3,AR.FC,R2		:fill cursor
	LH	R3,AR.FC,R2		:fill cursor
:	STB	R5,0,R2,R3		:place null
	STB	R5,ar.ic,R2,R3		:place null
:	AIS	R3,1			:bump cursor
:	CLB	R3,ARIR,R1		:check for fold
:	JNFS	AWCP1			:
:	LIS	R3,AR.IC		:fold ring if necessary
	ais	r3,1			:increment cursor
	jlfs	awcp1			: if >= 0
	sh	r3,ar.rs,r13		: reset to point to end of ring
:AWCP1	STB	R0,0,R2,R3		:place data character
AWCP1	STB	R0,ar.ic,R2,R3		:place data character
:	AIS	R3,1			:bump cursor
:	CLB	R3,ARIR,R1		:check for fold
:	JNFS	AWCP2			:
:	LIS	R3,AR.IC		:
	ais	r3,1			:increment cursor
	jlfs	awcp2			: if >= 0
	sh	r3,ar.rs,r13		: reset to point to end of ring
:AWCP2	STB	R3,AR.FC,R2		:save new cursor
AWCP2	STH	R3,AR.FC,R2		:save new cursor
	lis	r4,2			:
	AHM	R4,AR.BCT,R2		:bump BCT
	jncr	r8			:no zero transition, so done
:	JLEFS	AWCP3			:
:	AHM	R4,AR.BCT,R2		:
:	JR	R8			:
:AWCP3	AHM	R4,AR.BCT,R2		:
	L	R3,BFI,R1		:
	CBT	R3,0			:
	JR	R8			:
					:
:	.......................................................................
:	test if to place one or two data chars in async ouput ring
:	.......................................................................
					:
AWCTST	LR	R0,R0			:test if char should be escaped
	JE	AWCP			:yes...send escaped pair
					:
:	.......................................................................
:	Place a single char in ASYNC input ring
:	R8 -	link
:	R0 -	char to transmit
:	.......................................................................
					:
AWCI	LR	R1,R13			:make buffer index
	AR	R1,R1			:
	LIS	R4,1			:set an incrementer
	L	R2,ARIR,R1		:get pointer to ring
	LH	R3,AR.FC,R2		:get fill cursor
	STB	R0,ar.ic,R2,R3		:place character
	ais	r3,1			:decrement cursor
	jlfs	awc1			: if >= 0
	sh	r3,ar.rs,r13		: reset to point to end of ring
AWC1	STH	R3,AR.FC,R2		:place the cursor
	AHM	R4,AR.BCT,R2		:increment BCT
	JNR	R8			:wasn't empty...just exit
	L	R3,BFI,R1		:was empty...get pointer to bit
	CBT	R3,0			:
	JR	R8			:
					:

   ELSE					:Use regular Async ring structure
					:
:	.......................................................................
:	Get a char from ASYNC output ring
:	R8 -	link
:	R10 -	return if ring empty, turns off FPORT bit
:		else char in R0
:	Entry-point for control-character
:	.......................................................................
					:
AGCIP	L	R3,BFO,R13,R13		:get pointer to data-flag
	SBT	R3,0			:make sure it's set
					:
:	.......................................................................
:	Entry-point for data character
:	.......................................................................
					:
AGCI	LR	R1,R13			:make buffer index
	AR	R1,R1			:
	LCS	R4,1			:get a decrementer
	L	R2,AROR,R1		:pointer to ring
	LB	R3,AR.EC,R2		:cursor for character
	LB	R0,0,R2,R3		:get the data character
	AIS	R3,1			:bump cursor
	CLB	R3,AROR,R1		:check for fold
	JNFS	AGC1			:skip if not
	LIS	R3,AR.IC		:else fold cursor
AGC1	STB	R3,AR.EC,R2		:restore cursor
	AHM	R4,AR.BCT,R2		:decrement BCT
	JGEFS	AGC2			:skip if not last character
	L	R3,BFO,R1		:else locate flag bit
	CBT	R3,0			:...and flip it
	RBT	R14,TOPORT		:don't look again
AGC2	AHM	R4,AR.TAM,R2		:decrement TAM count
	JGR	R8			:return if >0
	JLFS	AGC3			:less, check TAM
	SBT	R14,TAMMER		:note that we passed through zero
	JR	R8			:
AGC3	RBT	R14,TAMMER		:what is the state
	JER	R8			:
	L	R3,TAM,R1		:locate TAM bit
	CBT	R3,0			:
	JR	R8			:
					:
:	.......................................................................
:	Place escaped char in ASYNC input ring
:	R8 -	link
:	R0 -	char to transmit
:	.......................................................................
					:
AWCP	LR	R1,R13			:make port index
	AR	R1,R1			:
	LIS	R4,1			:set an incrementer
	LIS	R5,0			:preceed with a null
	L	R2,ARIR,R1		:pointer to ring
	LB	R3,AR.FC,R2		:fill cursor
	STB	R5,0,R2,R3		:place null
	AIS	R3,1			:bump cursor
	CLB	R3,ARIR,R1		:check for fold
	JNFS	AWCP1			:
	LIS	R3,AR.IC		:fold ring if necessary
AWCP1	STB	R0,0,R2,R3		:place data character
	AIS	R3,1			:bump cursor
	CLB	R3,ARIR,R1		:check for fold
	JNFS	AWCP2			:
	LIS	R3,AR.IC		:
AWCP2	STB	R3,AR.FC,R2		:save new cursor
	AHM	R4,AR.BCT,R2		:bump BCT
	JLEFS	AWCP3			:
	AHM	R4,AR.BCT,R2		:
	JR	R8			:
AWCP3	AHM	R4,AR.BCT,R2		:
	L	R3,BFI,R1		:
	CBT	R3,0			:
	JR	R8			:
					:
:	.......................................................................
:	test if to place one or two data chars in async ouput ring
:	.......................................................................
					:
AWCTST	LR	R0,R0			:test if char should be escaped
	JE	AWCP			:yes...send escaped pair
					:
:	.......................................................................
:	Place a single char in ASYNC input ring
:	R8 -	link
:	R0 -	char to transmit
:	.......................................................................
					:
AWCI	LR	R1,R13			:make buffer index
	AR	R1,R1			:
	LIS	R4,1			:set an incrementer
	L	R2,ARIR,R1		:get pointer to ring
	LB	R3,AR.FC,R2		:get fill cursor
	STB	R0,0,R2,R3		:place character
	AIS	R3,1			:bump cursor
	CLB	R3,ARIR,R1		:check for fold
	JNFS	AWC1			:
	LIS	R3,AR.IC		:
AWC1	STB	R3,AR.FC,R2		:place the cursor
	AHM	R4,AR.BCT,R2		:increment BCT
	JNR	R8			:wasn't empty...just exit
	L	R3,BFI,R1		:was empty...get pointer to bit
	CBT	R3,0			:
	JR	R8			:
					:
   EI  (NEWARN)				:
					:
    IF	ASYNEW&1			:IF = 1, MUST RE-DEFINE SYMBOLS FOR
					:DISTINGUISHING BETWEEN METHODS
NAGCI	EQ	AGCI			:
NAWCI	EQ	AWCI			:
NAWCP	EQ	AWCP			:
NAGCIP	EQ	AGCIP			:
NAWTST	EQ	AWCTST			:
    EI (ASYNEW&1)			:
   EI  (ASYNEW)				:
					:

:	.......................................................................
:	THE SET OF RING POINTER BLOCKS FOR EACH GROUP OF 16 PORTS
:	.......................................................................
					:
Q	EQ	0			:FOR ALL CARDS
GPB	HS	0			:
QQ	EQ	80			:
Q3	EQ	ADA			:
	RE	NASYNG
GPB|Q|	HS	0
	BC	2,Q,QQ,Q3
        HS      6
        HC      -1,-1
	ORG	GPB|Q|+APBS
Q	EQ	Q+1
Q3	EQ	Q3+4
	NOLIST
	ER
	LIST
					:
Q	EQ	0			:
GPBX	HS	0			:
	RE	NASYNG			:
	HC	GPB|Q|-GPB		:
Q	EQ	Q+1			:
	NOLIST				:
	ER				:
	LIST				:OFFSETS INTO GPB
					:
:	....................................................................
:
:	ASYNC BACKGROUND PROCESSING
:
:	ROUTINE TO GET AND SET ASYNC TERMS
:	LINK ON R2
:
:	....................................................................
					:
ABACK	LHI	R3,ADA+1		:SET DEVICE ADDRESSES -- DSR, DTR
	LHI	R4,ADA+2		:CP, BO (RVCI, RS)
Q	EQ	GPB			:SET UP POINTER
	RE	NASYNG			:
	L	R6,ACPP+Q		:
	JLEFS	.+8			:
	RDR	R4,R7			:
	STH	R7,0,R6			:CP
	L	R6,ADSRP+Q
	JLEFS	.+8
	RDR	R3,R7
	STH	R7,0,R6			:DSR
	L	R7,ADTRP+Q
	JLEFS	.+6
	LHL	R7,0,R7
	WDR	R3,R7			:DTR
	AIS	R3,4			:NEXT
	AIS	R4,4
Q	EQ	Q+APBS
	ER				:
	JR	R2			:AND RETURN
					:
   EI  (NASYNG)				:
					:
	EM				:End of ASYNC driver module
					:

   IF	M.NCARD				:Only Motherboard is defined

	SUBTTL	HANDLER FOR MOTHER-BOARD HANDLERS

	GL	M.INIT,DIAGNO,NDIAGN,DIAGIN,ONUMD
	MO	.,MBOARD

:	.......................................................................
:
:	DEFINE DAUGHTER-BLOCK DESCRIPTOR
:	NOTE: CODE EXPECTS D-BLOCK TO START ON ODD-BYTE BOUNDARY!!!
:
:	--------.-------.-------.-------+-------+-------+-------.-------+-------.-------.
:	|ATR CNT|CHN ADR|DEV ADR|	   STAT. ADDR		|USER STAT ADDR	|unused	|
:	---------------------------------------------------------------------------------
:
:	.......................................................................
					:
M.CHNA	EQ	1			:CHANNEL/DEVICE ADDRESS
M.STAT	EQ	3			:(OPTIONAL) STATUS ADDRESS
					: = 0 NOT IN USE
					: > 0 ADDRESS TO SAVE STATUS INTO
					: < 0 IN USE, BUT NO STATUS USED
M.USTAT	EQ	7			:USER STATUS (BND 10), RELATIVE BIT TO
HIGHWD	EQ	9			:High Window Address (/10 relative)
LOWWND	EQ	0B			:Low  Window Address (/10 relative)
M.LEN	EQ	$A 14			:LENGTH OF A BLOCK
					:
:	.......................................................................
:	NOW DEFINE THE COLLECTION OF DESCRIPTORS
:	.......................................................................
					:
	BND	2			:FORCE TO HALF-WORD BOUNDARY
	BS	1			:AND TO ODD-BYTE BOUNDARY!!
Q	EQ	0			:
	RE	M.NCARD
M.BLK|Q| BS	0
QQ	 EQ	0
	 RE	M.NP|Q|			:FOR EACH CARD
M.P|Q||QQ| BC	2,QQ,M.DA|Q|,0,0,0,0,0,0,0,0,0,0,0	:THE ENTRY FOR ONE CHANNEL
QQ	  EQ	QQ+1
	 ER
Q	 EQ	Q+1
	ER
M.NUM	EQ	.-M.BLK0-M.LEN		:THE NUMBER OF ELEMENTS
					:
:	.....................................................................
:	DEFINE OFFSET TABLE WITHIN EACH CARD
:	.....................................................................
					:
MOFFSET	RE	10			:
	BC	(.-MOFFSET)*M.LEN	:
	ER				:
					:
MNEXT	HC	M.NUM			:
					:
:	.....................................................................
: 	SCC PROTOCOL EQUATES
:	.....................................................................
					:
STRTIO	EQ	0F0020			:
CAMDIO	EQ	0F0024			:
SCCWIN	EQ	0F2020			:
					:
:	.....................................................................
:	SCC I/O CONROL BLOCK VALUES
:	.....................................................................
					:
SCCVAL	HC	0030			:I/O COMMAND
	HC	0000			:CM ADDRESS
	HC	008F			:
	HC	0020			:
	HC	0020			:
	HC	0000			:LENGTH
	HC	0080			:
					:
:	.....................................................................
:	INITIALIZE ALL BOARDS
:	LINK ON R0
:	.....................................................................
					:
M.INIT	LHI	R2,M.NUM		:FOR ALL BOARDS
	LIS	R4,0			:
M.INI1	ST	R4,M.STAT+M.BLK0,R2	:CANCEL STATUS REQUESTS
	SIS	R2,M.LEN		:REPEAT FOR ALL LINES
	JGEBS	M.INI1			:
	LHI	R2,(M.NCARD-1)*MBSIZE	:NOW, FOR EACH BOARD...
M.INI2	LHL	R3,MBLOCK,R2		:LOOK UP ONE DEVICE ADDRESS
	LHL	R4,MBLOCK+2,R2		:LOOK UP INTERRUPT ADDRESS
	STH	R4,IMIVEC,R3,R3		:SET THE INTERRUPT ADDRESS
	LR	R4,R3			:PUT DEVICE ADDRESS IN R4
	OHI	R4,6000			:MAKE A RESET-BOARD COMMAND
	OCR	R4,R4			:RESET THE BOARD
	LHI	R4,80			:*** SICK DISGUSTING KLUDGE TO ***
M.INI8	SIS	R4,1			:*** DELAY BECAUSE SIO MICRO-CODE ***
	JGEBS	M.INI8			:*** DOESN'T SET BUSY CORRECTLY ***
	LHL	R4,MBLOCK+6,R2		:GET NMBR OF PORTS ON BOARD - 1
	EXBR	R4,R4			:
	OR	R3,R4			:MAKE CHNL RESET CMD
M.INI7	LHI	R5,50			:SET CNT FOR 250us TIMER
M.INI3	SIS	R5,1			:DEC TIMER
	JL	M.INI5			:PUT MESSAGE IN HIST BUFF AND CONTINUE	
	SSR	R3,R4			:WAIT FOR DEVICE
   IF	TSI!NANO			:
	JTBS	0C,M.INI3		:DON'T LISTEN TO NON-FUNCTIONAL 
   ELSE					:
	JT	4,M.INI5		:NON-FUNCTIONAL...PLACE MSG AND CONTIN
	JTBS	8,M.INI3		:BUSY...WAIT FOR IT
   EI  (TSI!NANO)			:
	LHI	R4,7000,R3		:MAKE CHNL RESET CMD
	WDR	R4,R4			:RESET ALL CHANNELS ON THIS BOARD
	SHI	R3,100			:BUMP TO NEXT CHNL
	JGEBS	M.INI7			:BR IF MORE TO DO
M.INI4	SHI	R2,MBSIZE		:REPEAT FOR ALL BOARDS
	JGE	M.INI2			:
	LHI	R2,M.NUM		:FIRST PORT
	STH	R2,MNEXT		:KEEP TRACK OF CURRENT FOR SSR
					:
   IF	NANO				:
	LHI	R3,0			:
M.INA0	LHL	R4,SUMV00,R3		:MACRO VECTOR
	THI	R4,8000			:ARE WE INTERESTED ???
	JEFS	M.INA2			:
	NHI	R4,7FFF			:STRIP STATUS
	STH	R4,SCCTAB,R3		:OVERWRITE DEFAULT MATRIX
M.INA2	AHI	R3,4			:NEXT VECTOR
	CLHI	R3,80			:ARE WE FINISHED ???
	JL	M.INA0			:
:	.....................................................................
:	MOVE PARAMETER WINDOW TO SCC
:	.....................................................................
					:
	LHI	R3,0			:
M.INA6	LHL	R4,SCCTAB,R3		:
	STH	R4,SCCWIN,R3,		:
	AHI	R3,2			:
	CLHI	R3,80			:
	JL	M.INA6			:
					:
:	.....................................................................
:	FILL I/O CONTROL BLOCK 0 FOR  SCC CONFIGURATION
:	.....................................................................
					:
	LHI	R3,0			:
M.INA8	LHL	R4,SCCVAL,R3		:
	STH	R4,CAMDIO,R3,		:
	AHI	R3,2			:
	CLHI	R3,10			:
	JL	M.INA8			:
					:
:	.....................................................................
:	WRITE 01 TO START I/O LOCATION TO INTERRUPT CHANNEL PROCESSOR
:	.....................................................................
					:
	LHI	R4,1			:
	STH	R4,STRTIO,,		:
   EI  (NANO)				:
	JR	R1			:AND THEN RETURN
					:
:	.....................................................................
:	PLACE MESSAGE IN HISTORY BUFFER
:	.....................................................................
					:
M.INI5	LHL	R3,DIAGIN,,		:GET CURSOR
	LA	R4,M.MSG		:GET ADDRESS OF MSG
	ST	R4,DIAGNOS,R3		:
	LHI	R4,0FF			:SLOT NUMBER
	STB	R4,DIAGNOS,R3		:
	L	R4,SLOWC		:GET TIME
	JNFS	M.INI6			:TIME CAN'T BE ZERO
	LIS	R4,1			:
M.INI6	ST	R4,DIAGNOS+4,R3		:
	AIS	R3,8			:
	CLHI	R3,NDIAGN		:
	JLFS	.+4			:
	LIS	R3,0			:
	STH	R3,DIAGIN,,		:REPLACE CURSOR
	J	M.INI4			:
					:
M.MSG	SC	/MOTHERBOARD UNAVAILABLE AT INITIALIZATION/
					:
:	....................................................................
:	NOW BUILD INTERRUPT ROUTINE TABLE FOR ALL CARDS
:	EACH CARD HAS A SEVEN-HW BLOCK:
:	The 1st HW IS CARD DEVICE-ADDRESS
:	The 2nd HW IS INTERRUPT ROUTINE FOR THIS LINE
:	NEXT  5 HW'S ARE:
:			 LIS	R6,M.NPq
:			 LA	R4,M.BLKq
:			 J	M.INT	(CONDITIONAL)
:	....................................................................
					:
MBSIZE	EQ	$A 16			:SIZE OF INTERRUPT BLOCK
MBLOCK	HS	0			:FORCE TO HW BOUNDARY
Q	EQ	0			:
	RE	M.NCARD
	HC	M.DA|Q|,.+2		:DEVICE AND INTERRUPT ADDRESSES FOR CARD
	LHI	R6,M.NP|Q|-1		:NUMBER OF PORTS FOR CARD q -1
	LA	R4,M.BLK|Q|		:START OF CARD q'S PORT DESCRIPTORS
Q	EQ	Q+1
   IF	M.NCARD-Q
	J	M.INT			:AND SKIP TO COMMON INTERRUPT ROUTINE
   ELSE
					:AND FALL THROUGH TO COMMON INTERRUPT ROUTINE
   EI  (M.NCARD-Q)			:
	ER				:
					:
:	....................................................................
:	GENERALIZED INTERRUPT ROUTINE
:	....................................................................
					:
M.INT	SSR	R2,R3			:INPUT THE DEVICE STATUS
  IF	HMICRO!TSI!NANO			:
   IF	NSYNC				:
	MLOG(R2,R3)			:
   EI  (NSYNC)				:
  EI   (HMICRO!TSI!NANO)		:
	EXBR	R5,R3			:COPY CHANNEL ADDRESS
	NHI	R5,0F			:INSURE NO EXTRANEOUS BITS IN CHANNEL NUMBER
  IF	HMICRO!TSI!NANO			:
   IF	NSYNC				:
	LO	SYNC			:
	EXBR	R7,R3			:COPY STATUS
	NHI	R7,0F0			:ISOLATE STATUS
	CLHI	R7,0A0			:IS IT A REQUESTED INT?
	JN	M.INT0			:IF NOT, SKIP
	RBT	R5,IHINT		:DID THIS CHAN REQUEST IT?
	JE	M.INT0			:IF NOT, SKIP
	LR	R2,R5			:SET UP DEVICE # AS AN INT
	SLLS	R2,1			:MAKE DEVICE #
	AHI	R2,21			:
	LHL	R7,IMIVEC,R2,R2		:GET VECTOR FOR DEVICE
	MLOG(R2,R7)			:
	JR	R7			:EXEC SYNC ROUTINE
	FO	SYNC			:
   EI  (NSYNC)				:
  EI   (HMICRO!TSI!NANO)		:
M.INT0	SR	R6,R5			:RANGE CHECK ON CARD
	JL	M.INT1			:ABORT IF OUT OF RANGE
	CHI	R3,1			:Ignore Async interrupts
	JEFS	M.INT1			:Exit if it is Async interrupts
	LB	R5,MOFFSET,R5		:OK...OFFSET INTO SPECIFIC CHANNEL DESCRIPTOR
	L	R4,M.STAT,R4,R5		:NOW GET ADDRESS TO SAVE STATUS
	JLEFS	M.INT1			:IGNOR IF NULL
	STH	R3,8,R4			:ELSE SAVE IT
	L	R3,FASTC		:
	ST	R3,0A,R4		:ALSO SAVE THE TIME INTERRUPT WAS TAKEN
   IF	0				:
	LR	R10,R4			:Get address(Physical) status save area
	JAL	R11,GUBSP		:Find user block pointer
	LR	R1,R1			:Check if user block pointer in R1
	JLEFS	M.INT1			:Abort if no user block
	KRCODE(0,9,0)			:
	JAL	R11,KRASH		:
   EI					:
M.INT1	LPSWR	R0			:AND EXIT
					:
:	....................................................................
:	SIO FOREGROUND PROCESSOR
:	LINK ON R0
:	....................................................................
					:
M.FORE	EQ	.			:
   IF	SIOINC				:
	LHI	R1,M.NUM		:START OVER PER FORGROUND
   ELSE					:
	LHL	R1,MNEXT		:FOR NEXT PORT
   EI  (SIOINC)				:
M.FOR1	L	R3,M.STAT+M.BLK0,R1	:GET STATUS POINTER
	JLE	M.FOR2			:NONE...JUST SKIP
	LHL	R2,M.CHNA+M.BLK0,R1	:GET CHANNEL/DEVICE ADDRESS
	AHI	R2,05000		:
	LHI	R5,20			:SET TIMER SO WE DONT LOOP FOREVER
M.FOR3	SIS	R5,1			:DECR TIMER
	JLFS	M.FOR2			:GIVE UP IF TIMED OUT
	SSR	R2,R4			:SENSE IT
	STH	R4,6,R3			:SAVE FOR USER
	JTFS	4,M.FOR2		:SKIP IF NOT USABLE
	JTBS	8,M.FOR3		:WAIT IF BUSY
	LHL	R3,M.USTAT+M.BLK0,R1	:GET USER "QUAD-ADDRESS"
	WDR	R2,R3			:GO INPUT THE STATUS STUFF
M.FOR2	SIS	R1,M.LEN		:REPEAT FOR ALL LINES
   IF	SIOINC				:
	JGE	M.FOR1			:POLL NEXT DEVICE
   ELSE					:
	JGEFS	.+6			:START OVER IF DONE
	LHI	R1,M.NUM		:START OVER
	STH	R1,MNEXT		:
   EI  (SIOINC)				:
	JR	R0			:THEN RETURN
					:
:	.....................................................................
:	NANO CHANNEL PARAMETER VECTORS
:	.....................................................................
					:
Q	EQ	0
R	EQ	0
	RE	8
	RE	4
SUMV|Q||R|	BC	STV|Q||R|^7+ZZZ|Q||R|
	BC	RRR|Q||R|^5+TTT|Q||R|^3+AAA|Q||R|^2+BBB|Q||R|
	HC	0000
R	EQ	R+1
	ER
R	EQ	0
Q	EQ	Q+1
	ER				:
:	.....................................................................
:	SCC CONFIGURATION DEFAULT MATRIX
:	.....................................................................
					:
SCCTAB	RE	8
	HC	0951
	HC	0000
	HC	0915
	HC	0000
	HC	0915
	HC	0000
	HC	0909
	HC	0000
	ER				:

	EM				:End of SIO device driver module
   EI  (M.NCARD)			:


					:
        SUBTTL  IPI HANDLER

   IF	IPNMBR				:
					:
        MO      .,IPI			:
					:
        GL      IZIPI,IP1SEC
        GL      EIPDLD,EIPCRA,EIPIOW,EIPRIN
        GL      IPANMA,IPDLOK,IPCRSH,IPAIOW,UAKSIN
        GL      IPDLCS,SBASE,IPXDDT
					:
:	.......................................................................
:	DEFINE ENGINE-TO-IPI MESSAGE CODES
:	.......................................................................
					:
EIPDLD  EQ      01000000                :DOWN-LOAD AND START
EIPCRA  EQ      03000000                :ENGINE CRASH
EIPIOW  EQ      04000000                :START ADDR OF I/O WINDOW
EIPRIN  EQ      05000000                :TEST MSG USED W/ RE-INIT.
SLTINT  EQ      06000000                :SLOT INTERRUPT OF UPI
EIPGMB  EQ      07000000                :GO TO MACSBUG
					:
:	.......................................................................
:	DEFINE IPI-TO-ENGINE MESSAGE CODES
:	.......................................................................
					:
IPANMA  EQ      1                       :ACKNOWLEDGE NEW MSG AREA
IPDLOK  EQ      2                       :DOWN-LINE LOAD OK
IPCRSH  EQ      3                       :IPI CRASH
IPAIOW  EQ      4                       :ACKNOWLEDGE I/O WINDOW ADDR
UAKSIN  EQ      6                       :UPI ACK SLOT INTERRUPT
					:
:	.......................................................................
:	IPI LOGICAL UNIT DESCRIPTORS
:	.......................................................................
					:
        GL      IPLULN			:
IPLULN  EQ      $A 32                   :IPI LUN DESCRPTR LENGTH
QABCNT  EQ      2                       :FOR QUERY ATTRIBUTES SVC
					:
:	.......................................................................
:	DEFINE FIELDS IN LUN DESCRIPTOR
:	.......................................................................
					:
IPDNUM  EQ      1                       :IPI DEVICE NUMBER
IPADDR  EQ      2                       :DEVICE ADDRESS
ETOIPM  EQ      4                       :ENGINE-TO-IPI NEW MSG AREA
EIPTIM  EQ      8                       :TIME OF ENG-TO-IPI MSG
IPIMSG  EQ      $A 12                   :IPI INTERRUPT MSG
IPSTAT  EQ      $A 16                   :IPI STATUS AREA (IN SLOT)
IPIOWA  EQ      $A 20                   :IO WINDOW ADDR PASSED BY CNCT SVC
RESET   EQ      $A 25                   :RESET FLAG
GOMBUG  EQ      $A 26                   :FLAG FOR GOING TO MACSBUG
DWNLOD  EQ      $A 28                   :DOWN-LOAD CODE

Q	EQ	0
        WS      0
	RE	IPNMBR
	GL	IPLUD|Q|
IPLUD|Q| BC	QABCNT
	BC	Q
	HC	IPIAD|Q|
	WS	1
	WS	1
	WS	1
        WS      1
	WS	1
	HC	IPRST|Q|
        IF      GMBUG0
        HC      0  
        ELSE
        HC      -1
        EI
        WC      SLTIP|Q|
Q	EQ	Q+1
	ER

: BIT ARRAY TO TRACK WHICH SLOTS CONTAIN CODE TO DOWN-LINE LOAD TO IPI
IPDLCS  HC      0,0,0,0
ANSIPI  HS      1                       :COUNT OF IPIs ANSWERED TO INIT
IPCRSM  HS      1                       :FLAG CRASH MSG FROM IPI HERE
IPXDDT  HS      1                       :FLAG FROM "E" CMD OF DDT--IF -1 THEN
                                        :CALL OF CNC IPI SVC WILL NOT CAUSE
                                        :DONW-LOAD OF IPI CODE

: IPI INITIALIZATION

IZIPI   EQ      .
: GET ADDRESSES OF CODE TO DOWN-LINE LOAD, IF ANY, AND SET BIT IN IPDLCS
Q       EQ      0
        LIS     R3,0
        STH     R3,IPDNBA
        STH     R3,ANSIPI
        STH     R3,IPCRSM
        STH     R3,IPXDDT

        RE      IPNMBR
        ST      R3,IPLUD|Q|+ETOIPM
        ST      R3,IPLUD|Q|+EIPTIM
        ST      R3,IPLUD|Q|+IPIMSG
        ST      R3,IPLUD|Q|+IPIOWA
        ST      R3,IPLUD|Q|+IPSTAT
        IF      SLTIP|Q|
S       EQ      SLTIP|Q|
        GL      UBX|S|
        LA      R5,$A UBX|S|,,
        L       R4,SBASE,R5
        ST      R4,IPLUD|Q|+DWNLOD
        LHI     R4,SLTIP|Q|
        SBT     R4,IPDLCS
Q       EQ      Q+1
        EI
        ER

        LA      R6,IPLUD0               :START OF LUN DESCRIPTORS IN R6
        LIS     R7,0                    :IDX INTO INT HNDLER POINTER
        LIS     R5,0                    :CURRENT IPI DEVICE
IZIPI0  EQ      .
        LHL     R3,IPBLOK,R7                    :GET DEVICE ADDR
        LHL     R4,IPBLOK+2,R7          :GET POINTER TO INTRPT HNDLR
        STH     R4,IMIVEC,R3,R3         :SAVE IN IMIVEC TABLE
        LIS     R4,0
        EXBR    R4,R5                   :PUT IPI DEVICE NUMBER IN
        EXHR    R4,R4                   :HI-ORDER BYTE OF MSG TO IPI
        LA      R8,ETOIPM,R6            :GET ADDR OF PERM MSG AREA
        OR      R4,R8                   :ADD DEV # W/ PERM MSG AREA ADR
        ST      R4,ENGIPI               :PUT IN INIT MSG AREA
        LB      R4,RESET,R6             :RESETING?
        JL      IZIPI1                  :NO, THEN INTERRUPT
        LIS     R4,0                    :RESET/HALT ON, TRANSLATE OFF
        OCR     R3,R4
        LIS     R4,4                    :RESET/TRANSLATE OFF, HALT ON
        OCR     R3,R4
        LIS     R4,8                    :RESET/HALT/TRANSLATE ON
        OCR     R3,R4
        LHI     R4,1000                 :LEAVE RESET ON FOR AWHILE
IZIPI3  SIS     R4,1
        JGEBS   IZIPI3
        LIS     R4,0E                   :RESET/HALT OFF, TRANSLATE ON
        OCR     R3,R4
        J       IZIPI2
IZIPI1  EQ      .
        LIS     R4,7                    :INTERRUPT IPI
        OCR     R3,R4
        LIS     R4,6
        OCR     R3,R4
IZIPI2  EQ      .
        AIS     R5,1                    :INCREMENT
        CLHI    R5,IPNMBR               :ANY MORE?
        JER     R1                      :NO
        AHI     R6,IPLULN               :GET NEXT LUN DESCRIPTOR
        AHI     R7,IPBSIZ               :GET POINTER TO INT HNDLR
        J       IZIPI0

: INTERRUPT ROUTINE TABLE FOR EACH IPI
 
IPBSIZ  EQ      $A 8  
IPBLOK  HS      0
Q       EQ      0
        RE      IPNMBR
        HC      IPIAD|Q|,.+2            :DEVICE AND INTERRUPT ADDR
        LA      R3,IPLUD|Q|             :GET ADDR OF LUN DESCRIPTOR
Q       EQ      Q+1
        IF      IPNMBR-Q
          J     IPINTH                  :SKIP TO INTERRUPT HNDLR
        ELSE                            :FALL THROUGH TO INT. HNDLR
        EI
        ER

: DEFINE FIELDS IN SLOT'S IPI STATUS AREA

SLSTAT  EQ      0                       :INTRR MSG FROM IPI
SLSTIM  EQ      4                       :TIME OR INTERRUPT
SSRCRA  EQ      8                       :SENSE STATUS CRASH
SSRTIM  EQ      $A 12                   :TIME OF SSR CRASH

: IPI INTERRUPT HANDLER

IPINTH  LB      R5,IPDNUM,R3            :GET IPI DEV NUMBR
        LB      R2,IPIMSG+3,R3          :GET INTRPT MSG BYTE FROM IPI
        CLHI    R2,IPANMA               :ACKNOWLEDGING NEW MSG AREA?
        JE      IPINM1
        CLHI    R2,IPDLOK               :DOWN-LOAD OK MSG?
        JE      IPINM2
        CLHI    R2,IPCRSH               :IPI CRASH?
        JE      IPINM3
        CLHI    R2,IPAIOW               :IPI ACKNOWLEDGING IO WINDW ADDR?
        JE      IPINSM
        CLHI    R2,UAKSIN               :UPI ACKNOWLEDGING SLOT INTERRUPT?
        JE      IPINSM
IPINM1  SBT     R5,IPDNBA               :SET DEV. # BIT
        LHL     R4,ANSIPI               :GET # OF IPIS THAT HAVE ANSWERED INIT
        AIS     R4,1                    :INCREMENT
        CLHI    R4,IPNMBR               :ANYMORE?
        JNFS    IPNM1A                  :YES
        LIS     R4,0
        ST      R4,ENGIPI               :0 OUT ENG-TO-IPI MSG AREA
IPNM1A  STH     R4,ANSIPI
        LH      R6,GOMBUG,R3            :GOING TO MACSBUG?
        JGEFS   IPNM1B                  :YES
        LPSWR   0
IPNM1B  LI      R6,EIPGMB               :GET 'GO TO MACSBUG' MSG
        JFS     IPNM2A                  :SEND MSG TO IPI
IPINM2  L       R4,IPIOWA,R3            :GET I/O WINDOW ADDR
        LI      R6,EIPIOW               :GET 'THIS IS IO WINDOW' MSG CODE
        OR      R6,R4           
IPNM2A  ST      R6,ETOIPM,R3            :PUT IN PERM MSG AREA
        LHL     R3,IPADDR,R3            :GET DEVICE ADDR
        LIS     R4,7                    :AND INTERRUPT IT
        OCR     R3,R4
        LIS     R4,6
        OCR     R3,R4
        LPSWR   0
IPINM3  STH     R2,IPCRSM               :FLAG IPI CRASH MSG
        LH      R4,RESET,R3             :NO RESET OF IPI? (I.E., UPI)
        JGEFS   IPINSM                  :YES, RESET OK SO JUMP
        RBT     R5,IPDNBA               :CANNOT RESET BOARD--RESET DEV. # BIT
IPINSM  L       R5,IPSTAT,R3            :GET ADDR OF SLOT STATUS AREA
        ST      R2,SLSTAT,R5            :SAVE INTRR MSG IN STATUS AREA
        L       R4,GMT,,                :GET TIME
        ST      R4,SLSTIM,R5            :SAVE IN SLOT'S STATUS AREA
        LPSWR   0

: IPI 1-SECOND LOGIC

IP1SEC  EQ      .
        LIS     R3,0                    :IPI DEV NMBR COUNTER
        LA      R4,IPLUD0               :GET ADDR LUN DSCRIPTRS
IP1SC0  TBT     R3,IPDNBA               :IPI ALREADY CRASHED?
        JE      IP1SC1                  :YES, CHECK NEXT, IF ANY
        LHL     R5,IPADDR,R4            :GET DEVICE ADDRESS
        SSR     R5,R6                   :SENSE IPI STATUS
        THI     R6,1     
        JN      IP1SC1
        L       R2,IPSTAT,R4            :GET SLOT'S STATUS AREA ADDR
        JEFS    IP1SC1                  :IF 0, SLOT NOT CONNECTED
        LI      R6,-1                   :SLOT INTFACE WILL CRASH IF -1 
        ST      R6,SSRCRA,R2            :SAVE IN MSG AREA
        L       R6,GMT,,                :GET TIME
        ST      R6,SSRTIM,R2            :SAVE IT
IP1SC1  AIS     R3,1                    :INCREMENT DEVICE NMBR
        CLHI    R3,IPNMBR               :ANY MORE?
        JEFS    IP1SC2                  :NO--NOW CHECK FOR RE-INIT REQ.
        AHI     R4,IPLULN
        J       IP1SC0
IP1SC2  LHL     R6,IPIRIR               :GOT A RE-INIT REQUEST?
        JER     R1                      :NO, RETURN
        LA      R6,IPLUD0               :GET ADDR OF LUN DSCRPTRS
        LHI     R3,IPNMBR-1             :INIT COUNTER FOR IPIs  THAT WILL
        STH     R3,ANSIPI               :ANSWER BACK AT INIT--ONLY 1 WILL HERE
        LIS     R3,0                    :IPI DEVICE NUMBER COUNTER
IP1SC3  LI      R4,EIPRIN               :GET "JUST A TEST" MSG 
        ST      R4,ETOIPM,R6            :SAVE IN PERM. MSG AREA
        LA      R8,ETOIPM,R6            :GET ADDR OF PERM. MSG AREA
        LHL     R5,IPADDR,R6            :GET DEVICE ADDR
        LIS     R4,0                            
        EXBR    R4,R3                   :PUT IPI DEV NMBR IN HI-
        EXHR    R4,R4                   :ORDER BYTE OF MSG TO IPI
        OR      R4,R8                   :ADD DEV # W/ PERM MSG AREA ADR
        ST      R4,ENGIPI               :PUT IN INIT MSG AEREA
        LIS     R4,7                    :INTERRUPT IPI
        OCR     R5,R4
        LIS     R4,6
        OCR     R5,R4
        AIS     R3,1                    :INCREMNT IPI NMBR
        CLHI    R3,IPNMBR               :ANYMORE?
        JEFS    IP1SC4                  :NO--0 OUT IPIRIR
        AHI     R6,IPLULN               :GET NEXT DESCRIPTOR
        J       IP1SC3			:
IP1SC4  LIS     R5,0			:
        STH     R5,IPIRIR		:
        JR      R1			:
					:
:	.......................................................................
:	ROUTINE TO SEND CRASH MESSAGE IF ENGINE CRASHES--CALLED AT HLT.S
:	.......................................................................
					:
IPICRA  LI      R5,13000000     	:CRASH MSG
        ST      R5,ENGIPI       	:PUT IT IN PERM MSG AREA
        LIS     R7,0            	:IPI DEVICE COUNTER
        LA      R3,IPLUD0       	:GET ADDR OF 1ST IPI LUN DESCRIPTOR
IPICR0  ST      R5,ETOIPM,R3    	:PUT CRASH MSG IN MSG AREA
        LHL     R4,IPADDR,R3    	:GET IPI DEV ADDR
        LB      R5,RESET,R3     	:RESET IT?
        JL      IPICR1          	:INTERRUPT
        LIS     R5,0			:
        OCR     R4,R5			:
        LIS     R5,4			:
        OCR     R4,R5			:
        LIS     R5,8			:
        OCR     R4,R5			:
        LHI     R5,1000			:
IPICR3  SIS     R5,1			:
        JGEBS   IPICR3			:
        LIS     R5,0E           	:RESET/HALT OFF, TRANSLATE ON
        OCR     R4,R5			:
        J       IPICR2			:
IPICR1  LIS     R5,7            	:INTERRUPT
        OCR     R4,R5			:
        LIS     R5,6			:
        OCR     R4,R5			:
IPICR2  AIS     R7,1            	:INCREMENT COUNTER
        CLHI    R7,IPNMBR       	:ANY MORE?
        JER     R6              	:NO
        AHI     R3,IPLULN       	:POINT TO NEXT DESCRIPTOR
        J       IPICR0			:
					:
        EM				:End of IPI device driver module
   EI  (IPNMBR)				:

   IF	SBUS				:Only if SPIRIT Bus is defined

	SUBTTL	SPIRIT BUS HANDLER

	GL	ISTATD,SBCRB,SBDISC,SBDEV,SBFLAG,SBINIT,SBNRB
	GL	SBPROC,SBUBP,SBNEXT,SBILOC

	MO	.,SBUS

:	GENERAL S-BUS EQUATES

:	REQUEST BLOCK QUEUE ELEMENT

OLDORG	EQ	.
	ORG	0
LINKN	WS	1		:LINK TO NEXT ELEMENT IN QUEUE
	WS	1		:RESERVED FOR MBASE USE
MSTAT	HS	1		:MBASE STATUS AREA
ISTAT	HS	1		:ISIS STATUS AREA
SBSRBD	BS  $A 16		:SERVICE REQUEST BLOCK DATA
SRBLEN	EQ	.-SBSRBD	:SERVICE REQ BLK LENGTH IN BYTES
	ORG	OLDORG

:	MBASE STATUS AREA FLAGS

MSTATZ	EQ   0004		:ZERO SIO AND HIO FIELDS
MSTATY	EQ   0002		:YELLOW FLAG
MSTATF	EQ   0001		:FLUSH REQUEST

:	ISIS STATUS AREA FLAGS

ISTATD	EQ   8000		:REQUEST DONE
ISTATL	EQ   0100		:LINK ERROR
ISTATQ	EQ   0080		:END OF QUEUE
ISTATR	EQ   0040		:REQUEST PASSED TO SPIRIT
ISTATF	EQ   0001		:REQUEST FLUSHED

:	SBUS HANDLER FLAGS

SBBUSY	EQ	8000		:S-BUS HANDLER BUSY FLAG

	IF	SPIXPI
SBDEV	EQ	88
	ELSE
SBDEV	EQ	69		:SBUS DEVICE #
	EI


SBWIND	EQ	0F0000		:SBUS WINDOW START ADDR


	IF	STRACE
SBSAV	WS	6
SBLEN	EQ	400
SBINDX	WC	0,0,0,0
SBTBL	WS	SBLEN/4
	EI	(STRACE)

SBLOG	MACRO(N)[
	IF	STRACE
	STM	R10,SBSAV
	LHL	R10,SBINDX
	L	R12,FASTC,,
	LM	R13,0,R5
	STM	R12,SBTBL,R10
	LM	R12,SBCRB
	STM	R12,SBTBL+10,R10
	LIS	R12,N
	STH	R12,SBTBL+1E,R10
	AHI	R10,20
	NHI	R10,SBLEN-1
	STH	R10,SBINDX
	LM	R10,SBSAV
	EI	(STRACE)
]

SBLINK	WS	1		:LINK SAVE AREA
	
:	SBUS HANDLER DATA AREA	

SBPSW	WC	I.PSW		:PSW FOR S-BUS ROUTINES
SBRTN	WS	1		:POINTER TO CURRENTLY ACTIVE RTN
SBSAVE	WS	2		:PSW & PC FOR RETURN FROM INT

:	S-BUS DESCRIPTOR BLOCK

SBUSDB	WS	0
SBCRB	WS	1		:POINTER TO CURRENT REQUEST BLOCK
SBNRB	WS	1		:POINTER TO NEXT REQUEST BLOCK
SBUBP	WS	1		:POINTER TO SLOT'S USER BLOCK
SBFLAG	HS	1		:REQUEST FLAGS


:	ROUTINE TO INIT S-BUS HANDLER

SBINIT	ST	R2,SBLINK	:SAVE LINK
	LIS	R2,0
	ST	R2,SBCRB	:ZERO CURR REQ BLOCK
	ST	R2,SBNRB	:ZERO NEXT REQ BLOCK
	LHI	R2,SBENT	:GET S-BUS ENTRY POINT
	STH	R2,IMIVEC+(SBDEV*2) :PLACE IN INT VECTOR TABLE
	JFS	SBDSC1		:NOW DISCONNECT DEVICE

SBDISC	ST	R2,SBLINK	:SAVE LINK

SBDSC1	LA	R2,SBRETI	:GET S-BUS EXIT POINT
	ST	R2,SBRTN	:MAKE IT ACTIVE ROUTINE
	LHI	R2,@SBBUSY
	NH	R2,SBFLAG	:SET HANDLER NOT BUSY
	STH	R2,SBFLAG
	L	R2,SBLINK	:RESTORE LINK
	JR	R2

:	S-BUS ENTRY POINT

SBENT	SBLOG(0)
	ST	R0,SBSAVE	:SAVE CURRENT PSW
	ST	R1,SBSAVE+4	:SAVE CURRENT PC
	LM	R14,SBPSW	:GET ACTIVE PSD
	LA	R0,SBRETI	:SET INTERRUPTS TO FLUSH
	ST	R0,SBRTN
	LPSWR	R14		:DO CURRENTLY ACTIVE

:	ROUTINE TO SERVICE INTERRUPT FROM SPIRIT BUS

SBINT	SBLOG(1)
	L	R5,SBCRB	:GET CURRENT REQ BLOCK ADDR
	L	R1,SBUBP	:GET CURRENT USER BLOCK POINTER
	LHI	R7,ISTATD	:INIT ISTAT FLAGS FOR SBNEXT RTN

SBINT1	JAL	R10,SBNEXT	:FIND NEXT SRB ON QUEUE
	JN	SBINT2		:IF PRESENT SKIP
	LA	R0,SBRETI	:ELSE...
	ST	R0,SBRTN	:SET INTERRUPTS TO FLUSH
	LHI	R0,@SBBUSY
	NH	R0,SBFLAG	:RESET BUSY FLAG
	STH	R0,SBFLAG
	SBLOG(2)
	J	SBRETI		:AND RETURN

SBINT2	ST	R5,SBCRB	:SAVE NEW CURRENT REQ BLK PNTR
	JAL	R10,SBPROC,,	:PROCESS REQUEST BLOCK
	THI	R7,ISTATD	:WAS REQUEST COMPLETED?
	JN	SBINT1		:IF SO, DO NEXT
	STH	R7,ISTAT,R5	:SAVE CURRENT ISIS STATUS HW
	SBLOG(3)
	IF 	SPIXPI		:INTERRUPT XPI
	LHI	R3,SBDEV
	LIS	R2,7
	OCR	R3,R2
	LIS	R2,6
	OCR	R3,R2
	ELSE
	STH	R2,SBILOC	:PASS INTERRUPT TO SPIRIT
	EI

SBRETI	LPSW	SBSAVE		:RETURN FROM INTERRUPT

	EM
	EI	(SBUS)

   IF	MULTI				:
					:
	GL	INITBD,SRINIT		:

:	.....................................................................
:
:	Programming Note(s):
:	(1) MLUTBL points to a word-table of motherboard logical unit
:	    descriptors.
:	(2) MLUNUM is the highest motherboard logical unit number
:
:	    ------------------------------
:	    |  dev |  no. | strt |ln.|mch|
:	    |  no. | desc.| desc.|st.|num|
:	    ------------------------------
:   (bytes) |  1   |  1   |  1   |1/2|1/2| 
:	    ------------------------------
:
:
:	main loop for bringing up all SIO motherboards.
:	link register is R10
:	preserves R11,R3,R4,R5,R7(link) -- uses R1,R9
:
:	.....................................................................
					:
SRINIT	LIS	R11,0			:LOOP INDEX
INSIOA	CLHI	R11,(MLUNUM+1)*4	:COMPARE WITH HIGHEST MLU
	JGER	R10			:RETURN
	L	R9,MLUTBL,R11,		:GET MB-TABLE ENTRY
	LR	R1,R9			:COPY
	NI	R1,0FF000000		:ISOLATE DEVICE
	JE	INSIO9			:ANOTHER ENTRY
	EXBR	R9,R9			:
	LBR	R3,R9			:STARTING DESCRIPTOR
	EXHR	R9,R9			:
	LBR	R4,R9			:NO OF DESCRIPTORS
	EXBR	R9,R9			:
	LBR	R5,R9			:DEVICE NUMBER
	JAL	R13,INITBD,,		:INITIALIZE BOARD
INSIO9	AIS	R11,4			:INCREMENT INDEX
	J	INSIOA			:
					:
:	.....................................................................
:
:	SIOINT - sio interrupt tracing
:	quad word table
:	hw - device addr  hw - int. status
:	fw - ring fill  fw - ring empty indices
:	fw - interrupted psw - fw - interrupted pc
:	sioptr hs 1
:	siohis bs 100			:saves 25 vectors
:	lastin bs 10			:
:	kiotim bs 1
:	siotim ws 10
:
:	sioptr - pointer to SIO interrupt history buffer
:	siohis - sio interrupt history buffer
:	lastin - last or the most recent sio interrupt history buffer
:	kiotim - pointer to SIO interrupt history timestamp  buffer
:	siotim - sio interrupt timestamp buffer
:
:	----------------------------------------------
:	|  dev | int. |  ring    |   psw   |   pc    |
:	| addr | stat |fill/empty|         |         |
:	----------------------------------------------
:	|  2   |  2   |    4     |    4    |     4   |  (bytes)
:
:	Upon interrupt, R0 = PSW
:			R1 = PC
:			R2 = DEVICE ADDR
:			R3 = STATUS
:	Uses registers: R4,R5,R6,R7
:
:	.....................................................................
					:
	GL	SIOINT			:
SIOINT	ST	R0,SIOSAV		:SAVE INTR. 'PSW'
	ST	R1,SIOSAV+4		:SAVE INTR. 'PC'
	LHL	R4,SIOPTR		:SAVE HISTORY
	STH	R2,SIOHIS,R4		:DEVICE ADDR
	SSR	R2,R3			:READ STATUS OF SIO CARD
	STH	R3,SIOHIS+2,R4		:SAVE INT. STATUS
	LIS	R5,0			:
	ST	R5,SIOHIS+4,R4		:CLEAR RING FILL/EMPTY INDC.
	ST	R5,SIOHIS+8,R4		:CLEAR RING FILL/EMPTY INDC.
	ST	R0,SIOHIS+10,R4		:SAVE INTR. 'PSW'
	ST	R1,SIOHIS+14,R4		:SAVE INTR. 'PC'
	EXBR	R7,R3			:POSITION ERROR CODE
	LBR	R5,R7			:ISOLATE ERROR CODE
	CLHI	R5,6F			:IS IT ABOVE RING RANGE?
	JG	SIO1			:YES
	CLHI	R5,40			:IS IT BELOW RING RANGE?
	JL	SIO1			:YES
	LR	R7,R5			:IN THE RING RANGE
	NHI	R7,3F			:STRIP '40' FOR RING NUMBER
	SLHLS	R7,4			:POSITION TO QUAD WORD
	L	R6,MBLSTR+4,R7,		:Get input end ring address
	SIS	R6,4			:
	L	R3,0,R6			:Get fill and empty indices
	ST	R3,SIOHIS+4,R4		:Save input  ring indices
	L	R6,MBLSTR+8,R7,		:Get output end ring address
	SIS	R6,4			:
	L	R3,0,R6			:Get fill and empty indices
	ST	R3,SIOHIS+8,R4		:Save output ring indices
SIO1	AHI	R4,20			:UPDATE & SAVE HISTORY PTR.
	NHI	R4,1FF			:WRAP AT 100x
	STH	R4,SIOPTR		:SAVE HISTORY POINTER
					:
	CLHI	R5,30			:IS LINE OUT?
	JN	SIO2			:NO
					:
:	.....................................................................
:	find MLU descriptor with device number and set line down 
:	.....................................................................
					:
        LIS     R11,0                   :INDEX
SIOA    CLHI    R11,(MLUNUM+1)*4        :COMPARE WITH HIGHEST
        JGE     SIOX                    :CRASH
        L       R4,MLUTBL,R11,          :MB-TABLE ENTRY
        EXHR    R4,R4                   :SWITCH HALF WORDS
        EXBR    R4,R4                   :SWITCH BYTES
        LBR     R4,R4                   :GET DEVICE
	CR      R2,R4                   :COMPARE
	JEFS    SIOB                    :MATCH
	AIS     R11,4                   :UP INDEX
	JBS     SIOA			:
SIOB    LHI     R4,$A 27                :BIT VALUE
	RBT     R4,MLUTBL,R11,          :SET LINE DOWN
					:
:	.....................................................................
:	if device = master crash the user
:	.....................................................................
	CLHI	R2,KIOSRC		:MASTER?
	JN	SIO5			:IF NOT, SKIP
	LHI	R2,0F0			:REG SET F, NO INTERRUPTS
	EPSR	R3,R2			:
	JAL	R0,MINIT		:RE-INITIALIZE THE MACHINE
	LCS	R4,1			:SLOT KEY
	LA	R5,SIOEXT		:PLACE IN LOG
	JAL	R11,SETDIAG,,		:
	KRCODE(1,0E,14)			:CRASH ALL SLOTS
	JAL	R10,DUMP,,		:
	J	KINIT,,			:RE-INITIALIZE THE KERNEL
					:
SIOEXT	SC	/SIO ring restart/	:
					:
:	.....................................................................
:	if device = slave look for active & pass-throughs and zap them
:	.....................................................................
					:
SIO5	HS	0			:
   IF	KIODES				:
	GL	NKGRP,KPTHRU,KACT,KPTCEL
					:
	CLHI	R2,KIODES		:SLAVE?
	JN	SIO6E			:INCOMPATIBILY - SHOULD NOT HAPPEN
	LHL	R6,DISPLAY		:UPDATE DISPLAY
	NHI	R6,0FFF0
	OHI	R6,1			:SIGNAL SLAVE SIO RING DOWN
	STH	R6,DISPLAY
	LIS	R6,0			:INDEX
SIO6	CLHI	R6,NKGRP*2		:PROCESS IN HW INCREMENTS
	JGE	SIOF			:FINISHED
	LH	R9,KPTHRU,R6		:GET HW OF PASSTHRU
	NH	R9,KACT,R6		:CHECK ACTIVE BIT ARRAY	
	STH	R9,KPTCEL		:TEMP CELL
SIO6A	JFFOH	R9,SIO6B		:FIND ACTIVE BIT
	J	SIO6D			:EMPTY
					:
:	.......................................................................
:	Formulate zap message on port - R10 has port relative to HW
:	.......................................................................
					:
SIO6B	RBT	R10,KPTCEL		:RESET TEMP CELL
	LR	R0,R6			:COPY INDEX
	SLLS	R0,3			:COMPENSATE FOR 16 ports/HW
	AR	R0,R10			:add rel. port to get actual port
	EXBR	R0,R0			:MESSAGE FORMAT FOR ZAP
	LI	R2,SKCTLO		:
	LHI	R3,-CTLSIZ		:
	JAL	R1,PUTCTL		:ZAPPER IN CONTROL
	JNFS	SIO6C			:
	S.HLT0(2020)			:NO ROOM IN SIO CONTROL RING
SIO6C	LH	R9,KPTCEL		:GET UPDATED CELL
	J	SIO6A			:
					:
SIO6D	AIS	R6,2			:UP INDEX
	J	SIO6			:PROCESS NEXT HW
   EI  (KIODES)				:
					:
SIO6E	S.HLT0(2070)			:UNEXPECTED SIO RING DEVICE INTER.
					:
:	.......................................................................
:	re-initialize the board
:	.......................................................................
					:
SIOF	L	R9,MLUTBL,R11,		:GET MB-TABLE ENTRY
	EXBR	R9,R9			:
	LBR	R3,R9			:STARTING DESCRIPTOR
	EXHR	R9,R9			:
	LBR	R4,R9			:NO OF DESCRIPTORS
	EXBR	R9,R9			:
	LBR	R5,R9			:DEVICE NUMBER
	JAL	R13,INITBD,,		:INITIALIZE BOARD
	J	SIO4			:
SIO2	CLHI	R5,70			:Check if line up status?
	JE	SIO3			:Yes
	CLHI	R5,72			:Check if 100 checksum/10 aborts err?
	JLE	SIO4			:Just skip for nonfatal error ...
					:
:	.......................................................................
:	condition is fatal
:	.......................................................................
					:
	S.HLT0(2080)			:UNEXPECTED SIO RING ERROR CODE
SIOX	S.HLT0(2010)			:SIO RING SOFTWARE INCONSISTENCY
					:
:	.......................................................................
:	find MLU descriptor with device number and set line up 
:	.......................................................................
					:
SIO3	LIS	R11,0			:INDEX
SIOC	CLHI	R11,(MLUNUM+1)*4	:COMPARE WITH HIGHEST
	JGEBS	SIOX			:CRASH
	L	R4,MLUTBL,R11,		:MB-TABLE ENTRY
	EXHR	R4,R4			:SWITCH HALF WORDS
	EXBR	R4,R4			:SWITCH BYTES
	LBR	R4,R4			:GET DEVICE
	CR	R2,R4			:COMPARE
	JEFS	SIOD			:MATCH
	AIS	R11,4			:UP INDEX
	JBS	SIOC			:
SIOD	LHI	R4,$A 27		:BIT VALUE
	SBT	R4,MLUTBL,R11,		:SET LINE UP
					:	
:	.......................................................................
:	re-initialize the bit arrays
:	.......................................................................
        GL      NEWLOG,KSP
					:
	CLHI	R2,KIOSRC		:
        JN      INARY1			:
	LHL	R4,DISPLAY		:UPDATE DISPLAY
	NHI	R4,0FF0F		:
	OHI	R4,20			:SIGNAL MASTER SIO RING UP
	STH	R4,DISPLAY		:
        LA      R4,NEWLOG               :BEGINNING POINTER
        LA      R5,KSP                  :END POINTER
        LIS     R6,0                    :
INARY	CLR     R4,R5			:
        JGE	SIO4                    :EXIT ON CARRY SET
        STH     R6,0,R4                 :CLEAR HW
	AIS     R4,2                    :UP ADDRESS
	JBS     INARY			:
					:
INARY1	HS	0			:
   IF	KIODES				:
	CLHI	R2,KIODES		:
	JN	SIO4			:
	LHL	R4,DISPLAY		:UPDATE DISPLAY
	NHI	R4,0FFF0		:
	OHI	R4,2			:SIGNAL SLAVE SIO RING UP
	STH	R4,DISPLAY		:
   EI  (KIODES)				:
					:	
SIO4	L	R0,SIOSAV		:RESTORE INTR. 'PSW'
	L	R1,SIOSAV+4		:RESTORE INTR. 'PC'
	LPSWR	R0			:RETURN TO INT. USER
					:
SIOSAV	WS	2			:SAVE STATE FOR INTERUPT RESTORE
SILINK	WS	1			:LINK REGISTER SAVE AREA
SIOPTR	HS	1			:Pointer to Interrupt History Buffer
SIOHIS	BS	200			:SIO Interrupt History Buffer
KIOTIM	HS	1			:
SIOTIM	WS	10			:SIO Interrupt Time Stamps
					:
	GL	SIOPTR,SIOHIS,KIOTIM,SIOTIM

   EI  (MULTI)				:



	SUBTTL	MXP/XPI HANDLER

  IF	MXP

	GL	IZXPI,XPISEC,KDOS,KDOH,KDOW,KDOE,KDOM,KDI
	GL	KDIO,KRXE,KREX
	GL	UBX|$A SLTXMI|,SBASE
	GL	KDMCON,KDMDSC,KDMRST,KDMSUP,KDMGSS,KDMZCC,KDMGCC,KDMGPD
	GL	KDMGPB
	GL	KDMBIO,KDMKIK,XMCRSH,XMLOAD,XMINIT,XMXBUG,EMCRSH,EMSTRT
	GL	KFIL,KEMP,KDAT

   IF	ENHMXP
	GL	KDMDCC,KDMDSK,KDMRSR
   EI  (ENHMXP)				:SWITCH OUT MXP-XPI VERSION 3.00 AND LATER

:	KDIO MESSAGE EQUATES

KDMCON	EQ	0117			:CONNECT SLOT MSG
KDMDSC	EQ	0201			:DISCONNECT SLOT MSG
KDMRST	EQ	0301			:RESTART SLOT MSG
KDMSUP	EQ	0403			:SEND DIAG TO SUPERVISOR MSG
KDMGSS	EQ	0502			:GET SLOT STATUS
KDMZCC	EQ	0602			:ZERO CHAR COUNTERS
KDMGCC	EQ	0702			:GET CHAR COUNTERS
KDMGPD	EQ	0803			:GET PORT DESTINATION
KDMGPB	EQ	0903			:GET PORT BUFFER USAGE
KDMBIO	EQ	0A03			:CONNECT BIO
KDMKIK	EQ	0B00			:XPI WATCHDOG KICK
   IF	ENHMXP				:
KDMDCC	EQ	0C01			:GET DISPATCH EXECUTION COUNT
KDMDSK	EQ	0D01			:NEW DISPATCHER DISCONNECT MSG
KDMRSR	EQ	0E01			:NEW DISPATCHER RESTART MSG
   EI  (ENHMXP)				:FOR VERS 3.00 OF MXP-XPI

:	DEFINE ENGINE/XPI MESSAGE CODES

XMLOAD	EQ	04000000		:LOAD & START XPI
XMCRSH	EQ	05000000		:ENGINE CRASHED
XMINIT	EQ	06000000		:KDIO AREA ADDRESS
XMBOOT	EQ	07000000		:GO TO XPI LAN BOOT (UNUSED)
XMXBUG	EQ	08000000		:GO TO XPI DEBUGGER
EMCRSH	EQ	4			:XPI CRASHED
EMSTRT	EQ	5			:XPI STARTED
KFIL	EQ	0			:KDIO RLTV FILL POINTER
KEMP	EQ	2			:KDIO RLTV EMPTY POINTER
KDAT	EQ	4			:KDIO RLTV DATA START
					:
	MO	.,XPI
					:
:	.......................................................................
:	IZXPI - INITIALIZE XPI BOARD & KDIO COMMUNICATIONS
:	.......................................................................
					:
IZXPI	LHI	R3,XPIAD		:XPI DEVICE ADDR
	LIS	R4,4			:RESET/TRANSLATE OFF, HALT ON
	OCR	R3,R4			:
	LHI	R4,40			:
IZX0	SIS	R4,1			:
	JNBS	IZX0			:
	OCR	R3,R4			:RESET/HALT ON, TRANSLATE OFF
	LIS	R4,4			:RESET/TRANSLATE OFF, HALT ON
	OCR	R3,R4			:
	LIS	R4,8			:RESET/HALT/TRANSLATE ON
	OCR	R3,R4			:
	LA	R4,XPIINT		:SET UP XPI INTERRUPT VECTOR
	STH	R4,IMIVEC+2*XPIAD	:
	LHI	R4,SLTXMI		:SEE IF XPI MEMORY IMAGE LOADED
	TBT	R4,ACSLOT		:
	JNFS	IZX2			:
	S.HLTF(1868)			:XPI MEM IMAGE NOT LOADED CRASH
IZX2	LA	R4,$A UBX|SLTXMI|,,	:GET XPI MEMORY IMAGE ADDR
	L	R4,SBASE,R4		:
   IF	XPIBUG				:
	OI	R4,XMXBUG		:TELL XPI TO GO TO DEBUGGER
   ELSE					:
	OI	R4,XMLOAD		:TELL XPI TO START LOADING
   EI  (XPIBUG)				:
	ST	R4,XPIMSG		:
	LHI	R4,-KREXL		:
	STH	R4,KREX+KFIL,,		:CLEAR ENG-TO-XPI RING PTRS
	STH	R4,KREX+KEMP,,		:
	LHI	R4,-KRXEL		:
	STH	R4,KRXE+KFIL,,		:CLEAR XPI-TO-ENG RING PTRS
	STH	R4,KRXE+KEMP,,		:
	LHI	R4,XPITMO*4		:SET LOADING TIMEOUT
	ST	R4,XPITMR		:
	LHI	R4,1000			:
IZX3	SIS	R4,1			:LEAVE RESET ON FOR A WHILE
	JGEBS	IZX3			:
	LIS	R4,0E			:
	OCR	R3,R4			:RESET/HALT OFF, TRANSLATE ON
	JR	R1			:
					:
:	.......................................................................
:
:	XPISEC - XPI ONE-SECOND LOGIC TO CHECK THAT XPI IS ALL RIGHT
:	
:	.......................................................................
					:
XPISEC	HS				:
   IF	XPITMO				:
	LCS	R0,1			:
	AM	R0,XPITMR		:DECR XPI TIMEOUT CNTR
	JNFS	XPISC2			:RTRN IF NO TIMEOUT
	S.HLTF(1860)			:HAVEN'T HEARD FROM XPI CRASH
   EI  (XPITMO)				:
XPISC2	LHI	R0,KDMKIK		:GET XPI WATCHDOG MSG
	JAL	R4,KDOS,,		:SEND IT
	JAL	R4,KDOE,,		:
	L	R0,SLOWC		:DO EVERY 16 SECS
	THI	R0,0F			:
	JNR	R1			:
	LHI	R0,XPIAD		:XPI DEVICE ADDR
	SSR	R0,R2			:SET XPI STATUS
	THI	R2,1
	JNR	R1			:BR UNLESS XPI HALTED
	S.HLTF(1861)			:XPI GOT HALTED CRASH
					:
:	.......................................................................
:
:	XPIINT - XPI INTERRUPT HANDLER TO PROCESS MACHINE-LEVEL MESSAGES
:		 FROM XPI.
:	.......................................................................
					:
XPIINT	L	R4,ENGMSG		:GET MSG FROM XPI
	LR	R5,R4			:
	EXHR	R4,R4			:
	EXBR	R4,R4			:
	LBR	R4,R4			:
	CLHI	R4,EMCRSH		:SEE IF XPI CRASHED
	JNFS	XPII40			:
	STH	R5,XPII10+2		:
	S.HLT0(1864,XPII10)		:XPI CRASHED CRASH
XPII40	CLHI	R4,EMSTRT		:SEE IF XPI STARTED
	JEFS	XPII50			:
	S.HLT0(1862)			:BAD INTERRUPT MSG FROM XPI CRASH
					:
XPII50	LBR	R5,R5			:SEE IF MACHINE NMBR MATCHES
	CLHI	R5,MXPNM		:
	JEFS	XPII60			:
	S.HLT0(1867)			:MACHINE NMBR MISMATCH CRASH
XPII60	LI	R4,XMINIT+KDIO		:TELL XPI THE KDIO AREA ADDR
	ST	R4,XPIMSG		:
	LHI	R4,XPIAD		:XPI DEVICE ADDR
	LIS	R5,7			:FORCE XPI TO INTERRUPT
	OCR	R4,R5			:
	LIS	R5,6			:
	OCR	R4,R5			:
	LPSWR	R0			:INTERRUPT RETURN
					:
	EM				:
  EI   (MXP)				:

	SUBTTL	JOB FOR OCCASIONAL STUFF, SUCH AS DRIVING CONSOLE DISPLAY

:	.......................................................................
:
:	CONSOLE DISPLAY FORMAT:
:	--------.---------------.-------.-------.--------------------------------
:	|  KEY	|  SPEEDOMETER	| NC CT	| NC ST	|   STATUS FOR SLOT(KEY)	|
:	-------------------------------------------------------------------------
:
:	KEY IS CURRENT SLOT #
:	SPEEDOMETER IS ROTATING BIT
:	NC CT IS NODE CODE CRASH COUNT
:	NC ST IS NODE CODE STATUS (1-OUT OF NET, 2-TAKEN OVER)
:
:	.......................................................................
					:
	MO	.,FLASH			:
					:
SRATE	EQ	5			:SPEEDOMETER CONVERSION (USED FOR SHIFTING)
LINK	EQ	0B			:REGISTER EQUATE
BGNUM	EQ	$A601			:NUMBER OF BG MONITOR CELLS
BGON	HC	0			:BG EXEC MONITOR SWITCH (OFF = 0)
BGCNT	WS	BGNUM			:BG MONITOR CELLS
					:
FLASH	LIS	R0,0			:
	SVC	SYS,0			:INITIALIZE THE JOB
	NOP				:DON'T CARE ABOUT SKIP RETURN
					:
:	.......................................................................
:	Process Async Foreground Jobs
:	.......................................................................
					:
  IF	1-NASYNG			:IF NO ASYNC, WILL BE RUN AS NORMAL
   IF	KIOSRC				:FOREGROUND
   ELSE					:
    IF	FORGND				:
	GL	FLASHF			:
	LA	R0,FLASHF		:
	SVC	SYS,1			:CONNECT FLASH FOREGROUND JOB
    EI (FORGND)				:
   EI  (KIOSRC)				:
  EI   (1-NASYNG)			:
					:
FLASH1					:
					:
:	.......................................................................
:	Process Async Background Jobs
:	.......................................................................
					:
   IF	NASYNG				:
	LO	CLOCKS			:
	JAL	R2,ABACK		:
	FO	CLOCKS			:
   EI  (NASYNG)				:PROCESS ASYNC
					:
:	.......................................................................
:	Periodic TTY and KIO processing
:	.......................................................................
					:
   IF	TSPORT				:
	GL	TY.CHK			:Periodic TTY processing
	JAL	R1,TY.CHK		:
   EI  (TSPORT)				:
   IF	MULTI				:
	GL	KIOCHK			:
	JAL	R15,KIOCHK		:Periodic KIO processing
   ELSE					:
	GL	EXKP			:
	JAL	R10,EXKP		:Periodically examine kernel ports
   EI  (MULTI)				:
					:
   IF	KIOSRC				:
	GL	NKU, KACT, KOFBIT	:
	LHI	R2,NKU/10*2		:Get KIO user group index
FLASHK	LHL	R4,KACT,R2		:INSURE DATA IS SENT
	STH	R4,KOFBIT,R2		:
	SIS	R2,2			:
	JGEBS	FLASHK			:
   EI  (KIOSRC)				:

:	.......................................................................
:	Update console display
:	.......................................................................
					:
	LIS	R1,1			:SET CONSOLE DEVICE ADDRESS
	LHL	R4,LAST			:GET KEY
	EXHR	R4,R4			:
   IF	KIOSRC				:
	LB	R3,SLOWC+3		:MAKE IT ALTERNATE WITH 00
	NHI	R3,1			:
	JEFS	FLASHA			:
   EI  (KIOSRC)				:
	LH	R3,DISPLAY		:GET SLOT 0'S SPECIAL STATUS
FLASHA	NHI	R3,7FFF			:REMOVE OTHER GARBAGE
	OR	R4,R3			:
	L	R3,CURDIS		:GET POINTER TO CURRENT DISPLAY
	LHL	R3,0,R3			:GET DISPLAY VALUE
	LIS	R5,1			:RUN SPEEDOMETER
	AH	R5,FLASHC		:
	NHI	R5,8^SRATE-1		:CYCLE SPEEDOMETER
	STH	R5,FLASHC		:SAVE NEW VALUE
	SRHLS	R5,SRATE		:FORMAT SPEEDOMETER DISPLAY
   IF	MXP				:
	LHI	R6,101			:
   ELSE					:
	LHI	R6,303			:
   EI  (MXP)				:
	SLL	R6,4,R5			:POSITION THE BIT
   IF	MXP				:
	OH	R6,MXPDSP		:GET XPI SPEEDOMETER
   EI  (MXP)				:
	NI	R6,0FF00		:
	OR	R4,R6			:PUT IT ALL TOGETHER
   if	tsi!nano
     if picons
	lr	r3,r3
     else
	CIO	R3,R3			:OUTPUT DISPLAY
     ei	(picons)
   else
 	CIO	R3,R3			:OUTPUT DISPLAY
   ei   (tsi!nano)
   IF	KIOSRC				:
	LHI	R3,NSLOT+1		:SUPERVISOR SLOT
   ELSE					:
	CLHI	R3,NSLOT		:
	JLEFS	.+4			:
	LIS	R3,0			:GENERATE DEFAULT IF TOO BIG
   EI  (KIOSRC)				:
	STH	R3,LAST			:
	SLHLS	R3,2			:
	L	R3,DISTBL,R3		:SET UP NEXT POINTER
	ST	R3,CURDIS		:...AS NEW CURRENT DISPLAY
					:
   IF	CPUOVL				:
:	...............................................................
:	CHECK IF BG EXECUTION IS LATE
:	...............................................................
					:
	GL	FGER			:
					:
	LHL	R3,BGON			:ARE WE TRACING?
	JE	BGX1			:IF NOT, SKIP
	L	R3,FASTC		:GET CURRENT CLOCK
	S	R3,BGTIME		:COMPUTE TIME SINCE LAST TIME HERE
	CLI	R3,BGNUM-1		:IS IT BIGGER THAN WE CAN STAND?
	JLEFS	BGX			:IF NOT, USE IT
	LI	R3,BGNUM-1		:MAKE IT MAX VALUE
BGX	LIS	R0,1			:GET COUNT VALUE
	SLLS	R3,2			:MAKE FULLWORD INDEX
	AM	R0,BGCNT,R3		:BUMP COUNT
BGX1    L       R0,BGTIME		:
        AHI     R0,BGMIN		:
        C       R0,FASTC		:
        JGFS    FLASH3			:
        LIS     R0,1                    :COUNT EVENTS OVER LIMIT
        AHM     R0,BGFREQ		:
FLASH3  L       R0,FASTC		:
        ST      R0,BGTIME		:
   EI  (CPUOVL)				:
					:
   	L	R3,SLOWT		:GET SLOW TIMER
	AHI	R3,RATE			:WHEN IT WILL TIMEOUT
	CL	R3,FASTC		:HAS IT?
	JGE	FLASH7			:NO
					:
:	.......................................................................
:
:	General Purpose ISIS ONE-SECOND LOGIC consists of following:
:	(1) Update SLOWC timer
:	(2) Update KOFBIT
:	(3) Reset watchdog timer on Multifunction Card
:	(4) SPAM process
:
:	.......................................................................
					:
	ST	R3,SLOWT		:YES...UPDATE TIMER
	LIS	R1,1			:
	AM	R1,GMT			:BUMP GMT CLOCK
	AM	R1,SLOWC		:BUMP 1-SECOND CLOCK
					:
:	.......................................................................
:	Reset Watchdog Timer On Multifunction Card	
:	.......................................................................
					:
FNOP	NOPR				:DO NOT REMOVE THIS INSTRUCTION
	LIS	R2,5			:
	WDR	R2,R2			:Tickle Watchdog Timer on new card
    IF	TSI!NANO			:
    ELSE				:
	LIS	R2,6			:
	WDR	R2,R2			:Tickle Watchdog Timer on old card
    EI (TSI!NANO)			:
FLASH2	HS				:
BINST	EQ	(FLASH2-FNOP)/2!2300	:This is used by SVC 2, 39D
					:
:	.......................................................................
:	SPAM Processing
:	.......................................................................
					:
   IF	SPAM				:
	GL	CPSADR,CPFAIL,SPRDY,RESALL,ENAB,ADVCLK,STARTC
        LH      R2,SPRDY,,              :CHECK SPAM READY FLAG
	JN	SPASS			:IF SPAM ALREADY ON, SKIP
        L       R2,CPSADR,,             :SEE IF NODE CODE SYNC RECEIVED
        JGFS    SETRDY                  :IF POSITIVE, NODE CODE SYNC RECEIVED
        L       R2,STARTC,,             :GET TIME SINCE INITIALIZE
        AHI     R2,124                  :IF "CPSADR" NOT RECEIVED WITHIN 124
        C       R2,SLOWC                :SECONDS, START SPAM ANYWAY
        JG      SPASS1                  :ELSE WAIT
        LCS     R2,1			:
        STH     R2,CPFAIL,,             :***FOR OLD NODE CODE W/O SVC 53
SETRDY  LCS     R2,1			:
        STH     R2,ENAB,,               :SYNCHRONIZE WITH NODE CODE 
SPASS   EQ      .			:
        L       R2,CPSADR,,             :CHECK IF NODE CODE RE-STARTED
        JGFS    SPASS1                  :NO - CONTINUE IN LINE
        LH      R2,CPFAIL,,             :***CHECK FOR OLD NODE CODE
        JLFS    SPASS1                  :IF SO, IGNORE CPSADR
        JAL     R4,RESALL               :INITIALIZE SPAM CNTRS AND CONTROL
SPASS1  EQ      .			:
    IF  MXP				:
        GL      GETDCT			:
        L       R3,SLOWC                :GET CURRENT TIME
        AIS     R3,1                    :GET COUNT 1 SECOND EARLY
        CL      R3,ADVCLK,,             :EVERY 60 SECONDS (FOR PROPER SYNC)
        JNFS    NODSPX  		:
        JAL     R4,GETDCT               :GET XPI DISPATCHER COUNTS
NODSPX  EQ      .			:
    EI (MXP)				:
   EI  (SPAM)				:
					:
   IF	HMICRO!TSI!NANO			:
    IF	NSYNC				:
	LH	R1,HTIMER		:GET EMUL INIT TIMER
	JL	HCHK1			:SKIP, IF TIMED OUT
	SIS	R1,1			:DECREMENT TIMER
	STH	R1,HTIMER		:PLACE NEW TIME
	JN	HCHK1			:SKIP, IF MORE TIME
	LCS	R3,1			:
	LO	SYNC			:
	STH	R3,HMASK		:INIT LINES PROCESSED MASK
	LHL	R8,HSYNCL		:GET ARRAY OF LINES USED
HCHK	NH	R8,HMASK		:EXCLUSE LINES PROCESSED
	JFFOH	R8,HCHK0		:FIND NEXT LINE
	J	HCHK1			:JUMP, IF DONE
HCHK0	RBT	R9,HMASK		:MARK LINE PROCESSED
	LIS	R1,0F			:GET HIGHEST LINE NUMBER
	SR	R1,R9			:GET LINE#(ARRAY IN REVERSE ORDER)
	SLLS	R1,1			:MAKE HW INDEX
	LHL	R2,SPORT,R1		:GET LINE POINTER
	LH	R3,LINIT,R2		:GET LINE INIT FLAG
	JL	HCHK			:IGNORE IF LINE INIT'ED
	LHL	R4,OSLOTO,R2		:GET SLOT # FOR LINE
	FO	SYNC			:
	LR	R3,R1			:COPY LINE # * 2
	SRLS	R3,1			:MAKE LINE #
	LB	R5,HLFMSG		:GET LENGTH OF ERR MSG
	AIS	R5,1			:ADJUST FOR LENGTH BYTE
	MHR	R3,R5			:FIND MSG FOR THIS LINE
	LA	R5,HLFMSG,R3		:POINT TO IT
	JAL	R11,SETDIAG		:PUT IN HISTORY LOG
	J	HCHK			:IF ANY LEFT, DO NEXT
HCHK1	LIS	R1,1			:RESTORE R1	
    EI (NSYNC)				:
   EI  (HMICRO!TSI!NANO)		:
					:
:	.......................................................................
:	Every 256 secs, reloads a cpu set and optionally a mac register.
:	All sets are completed in 64 mins.
:	.......................................................................
					:
   IF	MACV				:
   ELSE					:
	LB	R2,SLOWC+3		:IS IT TIME TO DO THIS?
	NHI	R2,0F			:
	JN	REGFX3			:NO, WAIT
	EPSR	R8,R8			:YES, GET CURRENT PSW
	ST	R8,HLDPSW		:AND SAVE
	NHI	R8,0FF00		:MASK OFF REGISTER SET AND CONDITION CODES
	LHL	R9,NXTREG		:GET NEXT REGISTER SET TO FIX
	SLLS	R9,4			:POSITION IT
	OR	R9,R8			:BUILD PSW
	EPSR	R8,R9			:SWITCH REGISTER SETS, INTERRUPTS ENABLED
	LR	R0,R0			:
	LR	R1,R1			:
	LR	R2,R2			:
	LR	R3,R3			:
	LR	R4,R4			:
	LR	R5,R5			:
	LR	R6,R6			:
	LR	R7,R7			:
	LR	R8,R8			:
	LR	R9,R9			:
	LR	R10,R10			:
	LR	R11,R11			:
	LR	R12,R12			:
	LR	R13,R13			:
	LR	R14,R14			:
	LR	R15,R15			:
	LPSW	HLDPSW			:BACK TO ORIGINAL PSW
    IF	ZITEL				:If MAC 5, 3, or 2
REGFX1	LHL	R9,HLDPSW+2		:
	NHI	R9,0F0			:SELECT CURRENT REGISTER SET
	L	R2,NXTREG		:
	LBR	R10,R2			:
	EXHR	R2,R2			:
	EPSR	R8,R9			:DISABLE INTERRUPTS
	STH	R2,35C			:SELECT MAC REGISTER SET
	LIS	R9,0			:INNOCUOUS VALUE
	AM	R9,300,R10		:
	EPSR	R9,R8			:ENABLE INTERRUPTS
	L	R2,NXTREG		:
	AIS	R2,4			:UPDATE FOR NEXT TIME
	THI	R2,40			:MASK
	JEFS	REGFX2			:JUMP IF NOT DONE WITH THIS SET
	AI	R2,10000		:
REGFX2	NI	R2,0F003F		:
	ST	R2,NXTREG		:
    ELSE				:
REGFX1	LHL	R2,NXTREG		:
	AIS	R2,1			:
	NHI	R2,0F			:
	STH	R2,NXTREG		:
    EI (ZITEL)				:
   EI  (MACV)				:
					:
REGFX3	HS	0			:
	LIS	R2,6			:
	NH	R2,GMT+2		:WHILE TRACKING GMT,
	LHL	R2,FFFF,R2		:...HAVE A LITTLE FUN
	STH	R2,OFF			:
   IF	HMICRO!TSI!NANO			:
   ELSE					:
:
:  the following bypasses temperature and voltage sensing for all
:  machine types -- the code remains for historical purposes.
:
	lis	r8,0
	sth	r8,temper
	j	regfx9
	LIS	R2,4			:
	RDR	R2,R8			:GET TEMPERATURE TO REG 8
	LHI	R9,$A 100		:
	MHR	R8,R9			:
	SRLS	R8,8			:
	STB	R8,TEMPER		:SAVE TEMPERATURE VALUE
	JNOFS	FLASH4			:
	OCR	R2,R1			:RESTART THERMOMETER
FLASH4	SSR	R2,R8			:GET VOLTAGE
	LHI	R9,$A 100		:
	MHR	R8,R9			:
	SRLS	R8,8			:
	AHI	R8,$A 50		:
	STB	R8,TEMPER+1		:SAVE VALUE
   EI  (HMICRO!TSI!NANO)		:
regfx9	eq	.					:
   IF	MXP				:
	JAL	R1,XPISEC		:XPI 1-SEC LOGIC
   EI  (MXP)				:
   IF	IPNMBR  			:
        JAL     R1,IP1SEC               :IPI 1-SEC LOGIC
   EI  (IPNMBR)				:
  IF	SHARE				:
   IF	TSIDT				:
	GL	DTSTMR			:
	JAL	R1,DTSTMR,,		:TSI DISC/TAPE SERVICE TIMER
   ELSE					:
    IF	ESELCH				:
	L	R4,SLOWC		:CHECK ESELCH TIMEOUT
	THI	R4,1			:
	JEFS	FLASH5			:DO EVERY TWO SECONDS
	GL	SHBACK			:
	JAL	R1,SHBACK,,		:
    EI (ESELCH)				:
   EI  (TSIDT)				:
  EI   (SHARE)				:
   IF	ZITEL				:
	JAL	R0,MCHECK		:
   EI  (ZITEL)				:
					:
   IF	MULMAC				:
	GL	MACLUP			:
	JAL	R0,MACLUP,,		:ORDER JOBS BY CONTEXT RATE
   EI  (MULMAC)				:
					:
FLASH5	EQ	.			:
   IF	CPUOVL				:
:	....................................................................
:	REPORT ANY CPU OVERLOADS
:	....................................................................
					:
	LB	R0,SLOWC+3		:DO EVERY 256 SECONDS
	JN	FLASH6			:NOT TIME YET
        LIS     R8,0                    :CHECK BG OVERLOADS
        LHL     R13,BGFREQ,,		:
        STH     R8,BGFREQ,,             :RESET COUNTER
        CHI     R13,BGACPT              :IS IT OK?
        JLEFS   CPU010			:
        LHI     R11,0FF                 :OVERLOAD REPORT IS FF
        LIS     R12,0                   :0=>BACKROUND (00) TO XPI
        JAL     R5,DIAG,,               :SEND DIAGNOSTIC
					:
:	....................................................................
:	CHECK FG OVERLOAD
:	....................................................................
					:
CPU010  LHL     R13,FGER,,              :GET FG OVERLOAD
        LIS     R8,0			:
        STH     R8,FGER,,               :RESET COUNTER
        CHI     R13,FGACPT              :IS IT ACCEPTABLE
        JLE	CPU020                  :ALL OK
        LHI     R11,0FF                 :OVERLD REPORT
	LHI	R12,0FE			:-2=>FOREGROUND (FE) TO XPI
        JAL     R5,DIAG,,		:
					:
CPU020	HS	0			:
    IF	MSLOT				:
:	....................................................................
:	CHECK AND SEE IF MESSAGE THAT MONITOR SLOT WAS NOT IN BOUND FILE
:	NEEDS TO BE SENT.
:	....................................................................
					:
	LH	R0,MSNBND		:GET FLAG
	JE	FLASH6			:SKIP IF ZERO
	LHI	R4,0FF			:SLOT NUMBER
	LA	R5,MSMSG		:GET ADDRESS OF MESSAGE
	JAL	R11,SETDIAG		:PUT MSG INTO DIAGNOSTIC BUFFER
	LIS	R11,3			:GET MSG TYPE
	LIS	R12,0			:NO DATA, SO ZERO REGS 12 & 13
	LIS	R13,0			:
	STH	R13,MSNBND		:ZERO FLAG THAT CAUSES THESE MSGS
	JAL	R5,DIAG,,		:OUTPUT MSG TO PROBE VIA NODE CODE
    EI (MSLOT)				:
   EI  (CPUOVL)				:
					:
:	....................................................................
:	CHECK THE WATCHFROG TIMER OF EACH SLOT EVERY SECOND. ONCE A SLOT
:	ISSUES THE WATCHFROG TIMER SVC, IT MUST CONTINUE ISSUING SVC
:	PERIODICALLY.  IF IT STOPS (USUALLY BECAUSE OF SOFTWARE PROBLEMS),
:	THE SLOT WILL BE HALTED.
:	....................................................................
					:
   IF	WFROG				:Only if Watchfrog Time is enabled
FLASH6	L	R1,RUN,,		:POINT TO 1ST SLOT IN BG RUN LIST
	LCS	R12,1			:1ST TIME THROUGH ROUTINE - BG
MXX0	LH	R4,SLOT,R1		:GET THE SLOT NBR
	JL	MXX4			:IF NEG - SKIP IT
	LH	R4,UFLAG,R1		:CHECK TYPE OF SLOT
	THI	R4,FBACK		:BG SLOT ?
	JNFS	MXX01			:YEP
	THI	R4,FQUASI		:FG SLOT ?
	JE	MXX4			:IF NOT - SKIP IT
MXX01	L	R13,WFROGT,R1		:GET THE WFROGT OF THIS SLOT
	CLHI	R13,-2			:WAS WFROGT DISABLED VIA DDT ?
	JE	MXX4			:IF SO - NEXT SLOT
	CLHI	R13,-1			:IN USE ?
	JN	MXX1			:IF SO - THERE'S MORE TO CHECK
    IF \HI.FRG				:
	LH	R9,SLOT,R1		:GET SLOT NBR
	TBT	R9,DISFRG		:IS DISMISS DRIVEN WFROG ACTIVE ?
	JE	MXX4			:IF NOT - GO TO  THE NEXT SLOT
	L	R13,WFROGD,R1		:CHECK DISMISS WFROG
	CL	R13,SLOWC		:HAS IT TIMED OUT ?
	JNC	MXX3			:IF SO - TAKE CARE OF IT
    EI (HI.FRG)				:
	J	MXX4			:IF NOT - NEXT SLOT
MXX1	CL	R13,SLOWC		:HAS IT TIMED OUT ?
	JG	MXX4			:IF NOT - CHECK NEXT SLOT
MXX3	LCS	R13,1			:TIME OUT, SHUT OFF THE WATCH FROG
	L	R9,OTHER,R1		:
	JNFS	MXX31			:
	LR	R9,R1			:
MXX31	L	R4,WFROGT,R1		:CHECK WHICH TIMER IS ACTIVE
	JLFS	MXX33			:
	ST	R13,WFROGT,R1		:OFF WITH THE SVC DRIVEN TIMER
	ST	R13,WFROGT,R9		:
	JFS	MXX35			:
MXX33	ST	R13,WFROGD,R1		:OFF WITH THE DISMISS DRIVEN TIMER
	ST	R13,WFROGD,R9		:
MXX35	LH	R9,SLOT,R1		:DESIGNATE SLOT TO BE CRASHED
	SBT	R9,TOCRSH		:
MXX4	L	R1,LLINK,R1		:GET PTR TO NEXT ACTIVE SLOT 
	JN	MXX0			:IF THERE IS ONE - CHECK IT OUT
	AIS	R12,1			:END OF RUN LIST - WHICH LIST ?
	JGFS	XX20			:IF IT WAS FG - GO TO NEXT SECTION
	L	R1,QUASI,,		:POINT TO FG RUN LIST
	JN	MXX0			:GO DO IT IF THERE IS ANY FG
					:
:	.......................................................................
:	ALL THE SLOTS HAVE BEEN CHECK FOR WATCH FROG TIME OUTS.
:	NOW CRASH THE FIRST SLOT IN THE CRASH LIST - IF ANY.
:	.......................................................................
					:
XX20	LH	R12,SCRASH		:CRASH ALREADY IN PROGRESS ?
	JGE	XX7			:IF SO - WAIT TILL NEXT SECOND
	LIS	R9,0			:
	L	R12,TOCRSH		:CHECK TOP OF CRASH LIST
	JFFO	R12,XX24		:
	LIS	R9,4			:CHECK BOTTOM OF LIST
	L	R12,TOCRSH+4		:
	JFFO	R12,XX24		:
	J	XX7			:
XX24	RBT	R13,TOCRSH,R9		:REMOVE SLOT FROM CRASH LIST
	SLHLS	R9,3			:IF BIT CAME FROM LOW END OF LIST...
	AR	R13,R9			:ADD 32
	LR	R4,R13			:LOG A HISTORY FILE ENTRY...
	LA	R5,HLTMSG		:THAT THE SLOT WAS CRASHED
	JAL	LINK,SETDIAG		:
	SLHLS	R13,2			:
	NI	R13,$0 1FFFF		:SET FRGSRC (FROG CRASH FLAG)
	ST	R13,FRGCRS		:TELL SCHEDULER TO CRASH THIS SLOT
	L	R1,SLIST,R13		:
	JAL	LINK,FNDDDT		:POINT TO DDT BLOCK
	LHI	R9,0C^2			:REPORT THE FROG TIMEOUT
	STH	R9,EFLAG,R4		:
	JAL	R9,XX15			:GO SET UP DISPLAY
					:
:	.......................................................................
:	NOW SUSPEND THE FIRST SLOT IN THE SUSPEND LIST - IF ANY.
:	.......................................................................
					:
XX7	LH	R13,SS.SLT		:SUSPEND ALREADY IN PROGRESS ?
	JGE	FLASH7			:IF SO - WAIT TILL NEXT SECOND
	LIS	R9,0			:
	L	R12,TOSUSP		:CHECK TOP OF LIST FOR SLOTS
	JFFO	R12,XX10		:
	LIS	R9,4			:CHECK BOTTOM OF LIST
	L	R12,TOSUSP+4		:
	JFFO	R12,XX10		:
	J	FLASH7			:
XX10	RBT	R13,TOSUSP,R9		:REMOVE SLOT BIT FROM THE LIST
	SLL	R9,3			:IF BIT CAME FROM LOW END...
	AR	R13,R9			:ADD 32
	CLHI	R13,NSLOT+1		:SEE IF SLOT NBR IS VALID
	JC	FLASH7			:IF NOT - BYE
	TBT	R13,SSSLOT		:SEE IF ALREADY SUSPENDED
	JN	FLASH7			:IF SO - BYE
	LR	R9,R13			:
	STH	R9,SS.SLT		:SET TO SUSPEND SLOT
	LR	R4,R13			:LOG A HISTORY FILE ENTRY...
	LA	R5,SUSMSG		:REPORTING THE SLOT'S SUSPENSION
	JAL	LINK,SETDIAG		:
	SLHLS	R13,2			:GET SLOT INDEX
	L	R1,SLIST,R13		:
	JAL	LINK,FNDDDT		:GET DDT UB ADDR
	LHI	R1,0D^2			:
	STH	R1,EFLAG,R4		:ERROR CODE 0D - OWNER DIED
	JAL	R9,XX15			:GO SET UP THE DISPLAY
	J	FLASH7			:BYE
					:
XX15	LA	R12,DEAD,,		:
	ST	R12,DISTBL,R13,		:SET UP DISPLAY
	L	R12,SLIST,R13		:
	LIS	R13,0			:
	STH	R13,QUANTUM,R12		:
	L	R12,OTHER,R12		:
	JEFS	FLASH7			:
	LHI	R13,FREEZE		:
	OH	R13,WFLAG,R12		:
	STH	R13,WFLAG,R12		:
	JR	R9			:
					:
   EI  (WFROG)				:
					:
FLASH7	SVC	TICDIS,$A 15		:Dismiss for 15 ticks
	J	FLASH1			:AND DO IT AGAIN
					:
FLASHF	HS				:
	GL	FLASHF			:
   IF	FORGND				:Only if foreground processes enabled
					:
:	.......................................................................
:	FOREGROUND FLASH JOBs
:	.......................................................................
					:
    IF	NASYNG				:
	LO	CLOCKS			:
	JAL	R0,AFOREG		:Flash Async
	FO	CLOCKS			:
    EI (NASYNG)				:
    IF	NPRINT				:
	LO	PRINT			:
	JAL	R0,PFOREG		:Flash Printer
	FO	PRINT			:
    EI (NPRINT)				:
    IF	M.NCARD				:
	LO	MBOARD			:
	JAL	R0,M.FORE		:Flash SIO Motherboard
	FO	MBOARD			:
    EI (M.NCARD)			:
    IF	NSYNC				:
	LO	SYNC			:
	JAL	R0,SFOREG		:
	FO	SYNC			:
    EI (NSYNC)				:
	SVC	FAST			:FAST DISMISS UNTIL NEXT TIME
	J	FLASHF			:NOW START OVER
   EI  (FORGND)				:
					:
FFRET	J	.,,			:FOREGROUND RETURN
FFRET4	EQ	FFRET+4			:WHERE TO STUFF HALF-WORD ADDRESS
					:
   IF	MXP				:
	GL	MXPDSP			:
MXPDSP	HC	0101			:XPI SPEEDO, ROTATED BY XPI PROCESSOR
XMIDSP	HC	0AA00+MXPNM		:DISPLAY FOR XMI SLOT:  AA00+MACH NMBR
Q	EQ	0			:
   EI  (MXP)				:
CURDIS	WC	OFF			:PTR TO CURRENT STATUS TO DISPLAY
DISTBL	RE	NSLOT+1
   IF	MXP
    IF	.EQ.(Q,SLTXMI)			:
	WC	XMIDSP			:PTR TO STATUS FOR XMI SLOT
    ELSE
	WC	OFF			:PTRS TO STATUS FOR EACH SLOT
    EI
Q	EQ	Q+1
   ELSE
	WC	OFF			:PTRS TO STATUS FOR EACH SLOT
   EI
	ER				:
   IF	KIOSRC				:
	WC	OFF			:SUPERVISOR SLOT
   EI  (KIOSRC)				:
DEAD	HC	0DEAD			:DISPLAY FOR HALTED SLOT
DIED	HC	0D1ED			:DISPLAY FOR CRASHED SLOT
FFFF	HC	0FEE,0F1E,0F0E,0F00	:FUN AND GAMES FOR EMPTY SLOT
OFF	HC	0DEAD			:DISPLAY FOR NON-SLOT
LAST	HC	0			:LAST CONSOLE READ
TOSUSP	WC	0,0			:LIST OF SLOTS TO BE SUSPENDED
TOCRSH	WC	0,0			:LIST OF SLOTS TO BE CRASHED
					:
   IF	\HI.FRG				:
DISFRG	WC	HI.FRG,LO.FRG		:SLOTS WITH DISMISS DRIVEN WATCH FROG
   EI  (HI.FRG)				:
					:
   IF	MACV				:
   ELSE					:
NXTREG	WC	0			:
HLDPSW	WS	1			:
	WC	REGFX1			:
   EI  (MACV)				:
					:
HLTMSG	SC	/Crash - Watchfrog timeout/
SUSMSG	SC	/Suspended - owner down/

   IF	HMICRO!TSI!NANO			:
    IF	NSYNC				:
HLFMSG	SC	/Emulated Sync line  0 failed to initialize/
	SC	/Emulated Sync line  1 failed to initialize/
	SC	/Emulated Sync line  2 failed to initialize/
	SC	/Emulated Sync line  3 failed to initialize/
	SC	/Emulated Sync line  4 failed to initialize/
	SC	/Emulated Sync line  5 failed to initialize/
	SC	/Emulated Sync line  6 failed to initialize/
	SC	/Emulated Sync line  7 failed to initialize/
	SC	/Emulated Sync line  8 failed to initialize/
	SC	/Emulated Sync line  9 failed to initialize/
    EI (NSYNC)				:
   EI  (HMICRO!TSI!NANO)		:
					:

   IF	ZITEL				:
					:
:	.......................................................................
:	UPDATE MEMORY ERROR LOG
:	.......................................................................
					:
MCHECK	LHI	R1,MEMIO1-1		:FOR EACH ADDRESS
MCHK0	AIS	R1,1			:FOR NEXT ADDRESS
        CHI     R1,MEMIO2+1             :CHECK FOR UPPER LIMIT
	JER	R0			:
MCHK1	OCR	R1,0			:
	RDR	R1,R2			:READ LOG
	JT	4,MCHK0			:SKIP IF NOT THERE
	THI	R2,1			:CHECK FOR ERROR
	JE	MCHK5			:JUST CLEAR IT,NO ERROR
MCHK2	OC	R1,0			:
	LHI	R3,8000			:SET BIT 0
	WDR	R1,R3			:START LOG SCAN
MCHK3	SSR	R1,R2			:READ LOG
	THI	R2,0A			:CHECK FOR ERROR OR END OF PASS
	JEBS	MCHK3			:
	THI	R2,2			:CHECK FOR ERROR
	JN	MCHK5			:LOOK FOR NEXT ADDRESS IF END OF PASS
        LR      R3,R2			:
	NHI	R3,0700			:ISOLATE ROW-ADDRESS BITS
	SRHLS	R3,8			:RIGHT JUSTIFY
	LB	R4,ROWTBL,R3		:LOOK UP ACTUAL ROW
	THI	R2,4			:CHECK IF DOUBLE BIT
	JN	MCHK4			:
					:
:	.......................................................................
:	CALCULATE CHIP NUMBER	
:	.......................................................................
					:
	LHI	R3,$A 22		:22 BITS PER ROW
	MHR	R4,R3			:
        LR      R3,R2			:
	NHI	R3,0F800		:GET SYYNDROME BITS
	SRHLS	R3,0B			:ISOLATE,RIGHT JUSTIFY
	LB	R5,COLTBL,R3		:GET COLUMN FROM TABLE
	AR	R4,R5			:MAKE U NUMBER(POINT TO CHIP)
	CLHI	R5,0FF			:CHECK VALID SYNDROME
	JNFS	.+6			:
	LHI	R4,0FF			:ELSE MARK BAD SYNDROME
MCHK4	LBR	R2,R1			:GET ADDRESS
	SLHLS	R2,8			:LEFT JUSTIFY
	OR	R2,R4			:INCLUDE BYTE OF CHIP #
        SSR     R1,R3                   :SET CONDITION CODE
        JFFS    4,.+6			:IF DOUBLE BIT  ERROR , OR IN 8000
        OHI     R2,8000                 :SET HIGH ORDER BIT IF TWO BIT ERROR
					:
:	.......................................................................
:	SEE IF THIS IS RE-CURRANCE, THEN JUST BUMP COUNT
:	.......................................................................
					:
	LIS	R4,0			:
MCHK04	CLH	R2,MEMTRC+2,R4		:IS THIS IT
	JE	MCHK14			:YES
	AIS	R4,8			:
	CLHI	R4,NMTRC*8		:IS THIS ALL OF THEM
	JLBS	MCHK04			:
	LHL	R4,MEMIN		:GET CURSOR
	STH	R2,MEMTRC+2,R4		:SAVE FOR USER
	LIS	R2,1			:
	STB	R2,MEMTRC+1,R4		:RESET COUNT
	L	R2,SLOWC		:
	ST	R2,MEMTRC+4,R4		:AND TIME TAKEN
	AIS	R4,8			:
	CLHI	R4,NMTRC*8		:CHECK FOLD
	JLFS	.+4			:
	LIS	R4,0			:
	STH	R4,MEMIN		:
	J	MCHK1			:
MCHK14	LB	R2,MEMTRC+1,R4		:GET COUNT
	AIS	R2,1			:BUMP IT
	STB	R2,MEMTRC+1,R4		:RESTORE IT
	J	MCHK1			:
MCHK5	LHI	R3,4000			:
	WDR	R1,R3			:
	WDR	R1,R3			:
	J	MCHK0			:
					:
ROWTBL	BC	7,3,5,1,6,2,4,0
COLTBL	BC	11,16,15,08,14,0C,0FF,04,13,0E,0FF,6,0FF,0A,0FF,2,12,0F,0FF
	BC	7,0FF,0B,0FF,3,0FF,0D,0FF,5,0FF,9,10,1
NMTRC	EQ	10
MEMIN	HC	0
MEMTRC	HS	4*NMTRC
   EI  (ZITEL)				:
					:
   IF	CPUOVL				:
BGTIME  WS      1                       :TIHE OF LAST BG EXECUTION
BGFREQ  HS      1                       :NUMBER OF BG OVERLOADS
   EI  (CPUOVL)				:
					:
   IF	MSLOT				:
MSMSG	SC	/MONITOR SLOT NOT IN BOUND FILE/
   EI  (MSLOT)				:
					:
	EM				:

	SUBTTL	****	KERNEL COMMUNICATIONS AREA	****

	MO	.,KCAREA

DISPLAY	HC	0			:USED FOR DISPLAY DRIVER
DIAGIN	HS	1			:DIAGNOSTICS INPUT CURSOR
DIAGOUT	HS	1			:DIAGNOSTICS OUTPUT CURSOR
	BND	8			:FORCE TO DOUBLE-WORD BOUNDARY
DIAGNOS	WS	TDIAGN*2		:DEFAULT MINIMUM NUMBER
					:BYTE 0 = SLOT # (HEX)
					:REST OF WORD 0 = ADDRESS OF SC TEXT STRING
					:WORD 1 = TIME (SLOWC) OF RECORDING
	BND	100			:FORCE TO NEW PAGE BOUNDARY
NDIAGN	EQ	.-DIAGNOS		:NUMBER OF DIAGNOSTIC ENTRIES

	GL	NKU,NKUB,KBS
KCBASE	HS	0			:BASE OF KERNEL  COMMUNICATIONS
   IF	MULTI				:
NKU	EQ	KPORTS			:PORTS COME FROM TYMFILE
KBS	EQ	KIOSIZ			:SIZE COMES FROM TYMFILE
   ELSE					:
NKU	EQ	2+NSLOT+SUP		:NUMBER OF KERNEL USERS.  (NUMBER OF PORTS.)
KBS	EQ	$A 64			:KERNEL BUFFER SIZE FOR EACH IN- AND
   EI  (MULTI)				:(WE'LL ACTUALLY ALLOCATE ONE EXTRA, FOR TTY)
NKUB	EQ	2+NSLOT+SUP		:NUMBER OF USER BLOCKS
NKGRP	EQ	(NKU+1+0F)/10		:NUMBER KERNEL GROUPS
NEWLOG	HS	NKGRP			:BIT  ARRAY OF  NEW LOGIN PORTS
KACT	HS	NKGRP			:BIT SET IF  PORT BEING USED
KDEM	HS	NKGRP			:BIT ARRAY FOR DEFERED-ECHO MODE
KTDEM	HS	NKGRP			:BIT ARRAY FOR LOOK-AHEAD DEM
KECHO	HS	NKGRP			:BIT ARRAY FOR ECHO ON
  IF	MULTI				:
   IF	KIODES				:
KPTHRU	HS	NKGRP			:BIT ARRAY FOR PASSTHRU CIRCUITS
KPTHWT	HS	NKGRP			:BIT ARRAY TO WAIT FOR LOGON ACK
KOFCEL	HS	NKGRP			:TEMPORARY STORAGE FOR KOF VECTOR
PTHCEL 	HS	1			:TEMPORARY STORAGE FOR KPTHRU DATA
KPTCEL	HS	1			:TEMPORARY DATA CELL
KTID    BS      NKU                     :TERMINAL TYPE
KLNAME  HS      NKU*4                   :STORAGE FOR USERNAME
   EI  (KIODES)				:
KDZAP	HS	NKGRP			:BIT ARRAY FOR ZAP DIRECTION
KLPEND	HS	NKGRP			:BIT ARRAY FOR LOGON PENDING PORTS
  EI   (MULTI)				:
KSP	BS	NKU+1			:BYTE  OF SLOT NUMBER FOR OWNER
   IF	MULTI				:
KRPD	WS	NKU+1			:POINTERS TO PASSTHRU DATA RINGS
KOFBIT	WS	2			:KOF BIT ARRAY (for max. 48 ports)
KOFBAK	WS	2			:KOF BIT ARRAY BACKUP (max. 48 ports)
   ELSE					:
KAP	WS	NKU+1			:BIT POINTERS FOR ATTENTION REQUEST
KDP	WS	NKU+1			:BIT  POINTERS   FOR  DATA PRESENT
   EI  (MULTI)				:
KRP	WS	NKU+1			:POINTERS TO KERNEL  RINGS
KDESTZ	WS	NKU+1			:POINTERS TO DESTINATION JOB
NMI	HS	NKU+1			:BETWEEN NEXT IN AND NEXT OUT
					:OUT- BUFFER OF EACH PORT
					:
:	.....................................................................
:	LAYOUT OF A KERNEL RING PAIR
:	.....................................................................
					:
Q	EQ	.			:REMEMBER WHERE  WE ARE
	ORG	0			:
   IF	MULTI				:
	BS	KBS			:DATA STORAGE
KIB	HS	0			:END OF TO-KERNEL DATA STORAGE
NII	HS	1			:USER'S TO-KERNEL CURSOR
NOI	HS	1			:KERNEL'S TO-KERNEL  CURSOR
	BS	KBS			:DATA   STORAGE
KOB	HS	0			:END OF FROM-KERNEL STORAGE
NIO	HS	1			:KERNEL'S FROM-KERNEL CURSOR
NOO	HS	1			:USER'S FROM-KERNEL CURSOR
   ELSE					:
	BS	KBS			:DATA STORAGE
KOB	HS	0			:END OF FROM-KERNEL STORAGE
NIO	HS	1			:KERNEL'S FROM-KERNEL CURSOR
NOO	HS	1			:USER'S FROM-KERNEL CURSOR
	BS	KBS			:DATA   STORAGE
KIB	HS	0			:END OF TO-KERNEL DATA STORAGE
NII	HS	1			:USER'S TO-KERNEL CURSOR
NOI	HS	1			:KERNEL'S TO-KERNEL  CURSOR
   EI  (MULTI)				:
	ORG	Q			:RESTORE PC
	WS	0			:
TKRNG	BS	2*KBS+8			:SPACE FOR TTY RING PAIR
KCSIZE	EQ	.-KCBASE		:SIZE OF KERNEL COMMUNICATIONS  AREA
					:
					:END OF KERNEL COMMUNICATIONS AREA
	EM				:

	MO	.,TTY
	LO	KCAREA

	IF	TSPORT			:
					
	SUBTTL	TTY--KERNEL CHARACTER HANDLER

:	.....................................................................
:	We have set aside an additional port for KERNEL I/O, which can be
:	addressed from the TTY driver.
:	An additional routine can be used to check if any output is queued.
:
:	GIVE A CHARACTER (OR PAIR) TO THE KERNEL
:	R0-R2, R8-R15 preserved,
:	R3	CHAR (OR PAIR)
:	R4	LINK
:	USES R5...CURRENT INPUT CURSOR
:	.....................................................................
					:
T.KIN	LH	R5,NII+TKRNG		:OUR RING  IS LOCAL
	CLHI	R3,7			:CHECK FOR ESCAPE NEEDED
	JLEFS	T.KIN1			:SKIP IF SO
	CLHI	R3,0FF			:CHECK FOR DATA
	JLFS	T.KIN3			:YES
	CLHI	R3,1FF			:CHECK FOR PREFIX CODE
	JGFS	T.KIN2			:NO...CONTROL
T.KIN1	EXBR	R3,R3			:OUTPUT CHAR PAIR
	STB	R3,KIB+TKRNG,R5		:PLACE THE CHARACTER
	AIS	R5,1			:MOVE POINTER
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R5,-KBS			:ACCOUNT FOR POSSIBLE BUFFER FOLDING
T.KIN2	EXBR	R3,R3			:FLIP BACK
T.KIN3	STB	R3,KIB+TKRNG,R5		:PLACE  THE CHARACTER
	AIS	R5,1			:MOVE POINTER
	JLFS	.+6			:SKIP  IF NOT FOLDING
	LHI	R5,-KBS			:ACCOUNT FOR POSSIBLE BUFFER FOLDING
	STH	R5,NII+TKRNG		:RESTORE  POINTER
	JR	R4			:AND RETURN
					:
:	.....................................................................
:	INITIALIZE KERNEL INPUT (FOR LOGON)
:	.....................................................................
					:
T.KINI	LHI	R7,54			:SET INPUT MODE
	STB	R7,TY.MOD		:
	L	R7,T.KTXT		:SET LOGON HEADER
	ST	R7,TKRNG+KIB-KBS	:SET LOGON HEADER
	L	R7,T.KTXT+4		:
	ST	R7,TKRNG+KOB-KBS	:
	L	R7,T.KTXT+8		:
	ST	R7,TKRNG+KOB-KBS+4	:
	LHL	R7,T.KTXT+0C		:
	STH	R7,TKRNG+KOB-KBS+8	:THUS SET UP FOR LOGON
	LHI	R7,-KBS			:
	STH	R7,TKRNG+NOI		:RESET POINTERS
	STH	R7,NMI+NKU*2		:
	STH	R7,TKRNG+NOO		:
	LHI	R7,4-KBS		:
	STH	R7,TKRNG+NII		:SET  INPUT  READY
	LHI	R7,9-KBS		:
	STH	R7,TKRNG+NIO		:
	JR	R6			:AND RETURN
					:
T.KTXT	BC	0C1,((MACHNM/40)!0C0),((MACHNM&3F)!0C0),(NKU!80)
	AC	/"8D"8ALOGON:  /

	EI	(TSPORT)		:

	SUBTTL	TELETYPE DEBUGGER

TY.READ	EQ	54			:TTY READ/NOECHO COMMAND
TY.ECHO	EQ	64			:TTY READ/ECHO COMMAND
TY.WRITE EQ	58			:TTY WRITE COMMAND
TY.MOD	BC	TY.READ			:CURRENT READ MODE(ECHO OR NOT)
					:
TTYINIT	LA	R2,TY.INT		:
	STH	R2,IMIVEC+4		:INITIALIZE THE INTERRUPT VECTOR
	LIS	R2,0			:
	LHI	R3,KCSIZE-4		:CLEAR KERNEL COMMUNICATIONS AREA
TY.IN1	ST	R2,KCBASE,R3		:
	SIS	R3,4			:
	JGEBS	TY.IN1			:
	LCS	R2,1			:
	STB	R2,KSP+NKU		:SET SLOT FF  AS THE OWNER
	LIS	R2,2			:
   IF	TSPORT				:
	JAL	R15,T.LOGON		:SET UP
	LA	R15,T.LOG2		:
	STH	R15,TY.SUB		:
   EI  (TSPORT)				:
   IF	SYSDBG				:
	JAL	R6,TY.SRM		:SET READ MODE
	LA	R2,TY.0			:
	STH	R2,TY.SUB		:INITIALIZE INPUT SUBROUTINE
	LA	R2,TY.BRK		:
	STH	R2,BRKSUB		:INITIALIZE BREAK HANDLING SUBROUTINE
   EI  (SYSDBG)				:
	JR	R1			:AND EXIT
					:
:	.....................................................................
:	THE TTY INTERRUPT ROUTINE
:	.....................................................................
					:
TY.INT	LHL	R4,TY.SUB		:GET ROUTINE TO GO TO
	SSR	R2,R3			:CHECK STATUS
	JTFS	8,TY.F			:SKIP, IF BUSY
	JFFS	4,TY.1			:SKIP IF NO BREAK
	LHL	R4,BRKSUB		:ELSE GO TO BREAK HANDLER
TY.1	JALR	R15,R4			:PROCEED, R15 = ADDRESS OF TY.E
					:
TY.E	STH	R6,TY.SUB		:SAVE NEW SUB ROUTINE ADDRESS
TY.F	LPSWR	R0			:EXIT
   IF	SYSDBG				:

:	INITIAL ROUTINE TO READ CHARS A-D
TY.0	RDR	R2,R5			:READ CHAR
	NHI	R5,7F			:STRIP OFF PARITY
	SHI	R5,44			:SEE IF LEGAL CHAR. "D"
	JG	TY.ERR			:JUMP IF NOT
	AIS	R5,4			:SEE IF IN RANGE
	JL	TY.ERR
	NHI	R5,3			:GET LOW TWO BITS OF CHAR
	STH	R5,TY.WRD		:SAVE FOR LATER
	STH	R5,TY.WRR
	STH	R5,TY.SBC		:SAVE OPTION BITS
	LIS	R5,0
	STH	R5,TY.SB1
	JAL	R6,TY.RDN		:READ THE NUMBER

:	WHEN A RETURN IS MADE TO HERE CHECK TY.CNT FOR 5 OR LESS CHARS
:	IF ZERO JUST PRINT A CR/LF. IF GREATER THEN 5 THEN GO TO ERROR ROUT.
	LHL	R5,TY.CNT
	JE	TY.CR			:JUMP IF NO CHARS READ
	SIS	R5,5			:SEE IF 5 OR LESS DIGITS READ
	JG	TY.ERR
	L	R5,TY.NUM		:GET NUMBER READ
TY.NL	ST	R5,TY.ADR		:SAVE ADDRESS
	ST	R5,TY.ADC		:SAVE ADDRESS CONSTANT UNTOUCHED
	THI	R5,1			:CHECK IF A HALF WORD ADDRESS
	JN	TY.ERR

:	NOW OUTPUT A CR/LF AND THE ADDRESS ENCLOSED IN PARENS
	LHL	R5,TY.SBC		:CHECK IF D OPTION WAS TYPED
	JE	TY.M			:JUMP IF SO
	STH	R5,TY.SB1		:TAKE OUT OF READ NUMBER MODE
	JAL	R6,TY.SWM		:PUT TTY CARD IN WRITE MODE
TY.NA	JAL	R6,TY.CRLF		:C/R--L/F
	LHL	R6,TY.SBC		:TEST IF DUMP OPTION
	JNFS	TY.N1			:SKIP IF NOT
	LIS	R6,0A			:L/F TO DOUBLE-SPACE OUTPUT
	WDR	R2,R6
	JALR	R6,R15			:DISMISS
TY.N1	LHI	R5,28			:GET "("
	WDR	R2,R5			:OUTPUT IT
	JALR	R6,R15			:DISMISS
:	NOW OUTPUT ADDRESS AND A RIGHT PAREN.
:	TY.NUM CELL ALREADY HAS ADDRESS AND TY.CNT ALREADY SET UP
	LHI	R5,10			:LOAD SHIFT FACTOR FOR ADDRESS OUTPUT
	L	R4,TY.ADC
	JAL	R6,TY.OD		:OUTPUT DATA
	LHI	R5,29			:GET ")"
	WDR	R2,R5
	JALR	R6,R15			:DISMISS
	LHI	R5,20			:GET SPACE CHAR
	WDR	R2,R5
	JALR	R6,R15			:DISMISS

:	NOW HAVE OUTPUT CORE ADDRESS. CHECK TO SEE HOW MANY HALF WORDS TO OUTPUT
	LHL	R5,TY.WRD
	SLLS	R5,1			:MAKE INTO A HALFWORD INDEX
	L	R6,TY.ADR		:GET CORE ADDRESS
	AR	R6,R5
	ST	R6,TY.ADR
	LIS	R7,0
	SR	R7,R5			:FORMING COMPLEMENT OF HALF WORDS TO READ
	STH	R7,TY.WRD		:SAVE FOR LATER
	STH	R7,TY.WRB
:	NOW READ WORD(S) FROM CORE BUT DISABLE MAC AND MACHINE MALFUNCTION
:	INTERRUPTS IN CASE CORE IS NOT AVAILABLE
TY.N2	LIS	R3,0
	EPSR	R8,R3
	LHL	R4,0,R6,R7		:GET WORD FROM CORE
	EPSR	R3,R8
	LIS	R5,0C			:GET SHIFT FACTOR
	JAL	R6,TY.OD		:GO START OUTPUTTING DATA
	LHI	R5,20			:GET SPACE CHAR
	WDR	R2,R5
	JALR	R6,R15			:DISMISS
	LIS	R7,2			:UPDATE COUNT OF WORDS OUTPUT
	AH	R7,TY.WRD
	STH	R7,TY.WRD		:SAVE NEW COUNT
	JGEFS	TY.N4			:JUMP IF ALL DONE
	L	R6,TY.ADR
	J	TY.N2			:CONTINUE OUTPUT
TY.N4	LHL	R5,TY.SBC		:CHECK IF IN DUMP ROUTINE, OPTION D
	JE	TY.M4			:JUMP IF SO
:	NOW WORD IS OUTPUTTED, SET UP FOR READ OPERATION
	JAL	R6,TY.SRM		:PUT TTY CARD IN READ MODE
	LA	R5,TY.SV0		:ADDRESS OF WHERE TO PUT ANY DATA READ
	STH	R5,TY.SVA
TY.N5	JAL	R6,TY.RDN		:GO READ DATA

:	WHEN RETURN HERE CHECK FOR ZERO TO 4 CHARS READ. ALSO CHECK IF TO INPUT
:	MORE WORDS
	LHL	R5,TY.CNT		:SEE HOW MANY CHARS READ
	JE	TY.CR			:JUMP IF NONE
	SIS	R5,4			:SEE IF MORE THEN 4 CHARS
	JG	TY.ERR			:JUMP TO ERROR IF SO
	LHL	R5,TY.NUM+2		:GET HALFWORD READ
	LHL	R6,TY.SVA		:GET STORAGE ADDRESS TO SAVE DATA
	STH	R5,0,R6			:SAVE WORD
	LHL	R5,TY.WRR
	SIS	R5,1			:DECREMENT AMOUNT OF WORDS TO READ
	JE	TY.N6			:JUMP IF ALL WORDS READ
	STH	R5,TY.WRR
	AIS	R6,2			:UPDATE ADDRESS TO SAVE WORD AT
	STH	R6,TY.SVA
	J	TY.N5

:	NOW HAVE ALL NEW DATA USER WANTS TO STORE.
:	SET UP AND STORE IT PLUS EXIT FROM ROUTINE.
TY.N6	L	R6,TY.ADR		:GET BIASED CORE ADDRESS
	LH	R7,TY.WRB		:GET COMPLEMENT OF WORDS TO WRITE
	LHL	R5,TY.SVA		:ADDRESS LAST STORED INTO
	AIS	R5,2			:ADJUST SO FACTOR CAN BE USED
	LIS	R3,0
	EPSR	R8,R3			:TURN OFF MAC AND MACH. MALF.
TY.N7	LHL	R4,0,R5,R7		:READ DATA INPUT BY USER
	STH	R4,0,R6,R7		:STORE DATA IN CORE
	AIS	R7,2			:CHANGE INDEX
	JNBS	TY.N7			:JUMP IF NOT DONE
	EPSR	R3,R8			:RESTORE PSW
TY.CR	LHL	R5,TY.SB1
	SHI	R5,20			:SEE IF " " WAS TYPED
	JE	TY.SPA			:GO TO ROUTINE IF SO
	SIS	R5,2E-20		:SEE IF "." WAS TYPED
	JE	TY.PER			:GO TO ROUTINE IF SO
	SHI	R5,5E-2E		:SEE IF "^" WAS TYPED
	JEFS	TY.UA			:SKIP IF SO
TY.CR1	JAL	R6,TY.SWM		:SET WRITE MODE
TY.CR2	JAL	R6,TY.CRLF		:C/R--L/F
	JAL	R6,TY.SRM		:SET READ MODE
	LA	R6,TY.0			:RE-INITIALIZE INTERRUPT ROUTINE
	J	TY.E

:	A BREAK WAS SEEN. READ DATA TO CLEAN UP CARD.
:	(NO EFFECT IF CARD IN WRITE MODE.)
TY.BRK	RDR	R2,R6			:READ AND DISCARD DATA INPUT
	JBS	TY.CR1			:THEN SWITCH TO OUTPUT

:	ROUTINE USED FOR UP ARROW (^) OPTION
TY.UA	SH	R5,TY.SBC		:COMPUTE OFFSET (BACKWARDS)
	JFS	TY.PER			:SKIP TO COMMON SET-UP CODE
:	FOLLOWING ROUTINE USED FOR SPACE OPTION, LOOK AT NEXT CELL(S)
TY.SPA	LHL	R5,TY.SBC		:GET OPTION CHAR LOW BITS
:	FOLLOWING ROUTINE FOR PERIOD OPTION
TY.PER	LHL	R6,TY.SBC		:GET OPTION CHAR LOW BITS
	STH	R6,TY.WRD
	STH	R6,TY.WRR
	AR	R5,R5			:MAKE OFFSET NUMBER OF BYTES
	A	R5,TY.ADC		:+ CURRENT ADDRESS
	J	TY.NL			:AND CONTINUE

TY.ERR	JAL	R6,TY.SWM		:PUT TTY CARD IN WRITE MODE
	JAL	R6,TY.CRLF		:C/R--L/F
	LHI	R5,3F			:OUTPUT "?"
	WDR	R2,R5
	JALR	R6,R15			:DISMISS
	J	TY.CR2			:GO OUTPUT CR/LF

:	OUTPUT C/R|L/F, DISMISS AS NECESSARY
TY.CRLF	STH	R6,TY.RTN		:SAVE RETURN
	LIS	R6,0D			:C/R
	WDR	R2,R6
	JALR	R6,R15			:DISMISS
	LIS	R6,0A			:L/F
	WDR	R2,R6
	JALR	R6,R15			:DISMISS
	LHL	R6,TY.RTN		:RESTORE RETURN
	JR	R6

:	FOLLOWING ROUTINE HANDLES THE DUMP OPTION
TY.M	JAL	R6,TY.RDN		:READ NEXT ADDRESS
	LHL	R5,TY.CNT
	JE	TY.CR1			:SEE HOW MANY CHARS INPUT. IF ZERO, OUTPUT CR/LF
	SIS	R5,5			:CHECK FOR 5 OR LESS
	JG	TY.ERR			:JUMP IF TOO MANY
	L	R5,TY.NUM
	THI	R5,1			:SEE IF LEGAL HALFWORD ADDRESS
	JN	TY.ERR			:NOT AN EVEN NUMBER ADDRESS
	S	R5,TY.ADR		:GET AMOUNT OF HALFWORDS TO OUTPUT
	JLE	TY.ERR			:JUMP IF SECOND ADDRESS LESS THEN OR EQUAL FIRST
	SRLS	R5,1			:COMPUTE NUMBER OF HALF-WORDS
	AIS	R5,1
	STH	R5,TY.SVA
:	SET UP OUTPUT
	JAL	R6,TY.SWM		:PUT TTY CARD IN WRITE MODE
:	NOW CHECK NUMBER OF WORDS TO OUTPUT TO SEE IF MORE THEN ONE LINE
:	OF OUTPUT WILL BE GENERATED
TY.M1	LHL	R5,TY.SVA		:GET RUNNING COUNT OF WORDS TO OUTPUT
	SIS	R5,8			:SUBTRACT NUMBER OF HALFWORDS PER LINE
	JLFS	TY.M2
	STH	R5,TY.SVA		:UPDATE COUNT
	LIS	R5,8
	JFS	TY.M3			:AND SKIP
TY.M2	LHL	R5,TY.SVA
	LIS	R6,0
	STH	R6,TY.SVA		:SET UP SO ROUTINE WILL EXIT AFTER NEXT LINE
TY.M3	STH	R5,TY.WRD
	L	R5,TY.ADR
	ST	R5,TY.ADC
	J	TY.NA			:GO OUTPUT DATA
TY.M4	LHL	R5,TY.SVA
	JN	TY.M1			:REPEAT IF NOT YET DONE
	J	TY.CR2

:	FOLLOWING ROUTINE USED TO OUTPUT HALFWORDS AS NUMERIC DATA
:	R4 = NUMBER TO OUTPUT
:	R5 = INITIAL SHIFT
:	R6 = RETURN ADDRESS
TY.OD	ST	R4,TY.NUM		:SAVE NUMBER
	STH	R6,TY.RTN		:SAVE RETURN
	LA	R6,TY.OUT
	STH	R6,TY.SUB		:INSURE WE'RE CALLED NEXT TIME
	JFS	TY.OD0			:AND SKIP
TY.OUT	LH	R5,TY.SHF		:GET SHIFT COUNT
	JGEFS	TY.OTA			:JUMP IF MORE OUTPUT TO DO
	LHL	R6,TY.RTN		:ELSE RESTORE RETURN
	JR	R6			:AND RETURN

TY.OTA	L	R4,TY.NUM		:GET WORD TO OUTPUT
TY.OD0	SRL	R4,0,R5			:SHIFT CHAR INTO POSITION
	SIS	R5,4			:CHANGE SHIFT COUNT
	STH	R5,TY.SHF
	NHI	R4,0F			:GET CHAR, LOW FOUR BITS OF WORD
	SIS	R4,9			:FORM NUMERIC CHAR FOR OUTPUT
	JLEFS	.+4
	AIS	R4,7
	AHI	R4,39
	WDR	R2,R4
	LPSWR	R0			:EXIT

:	FOLLOWING ROUTINE IS USED TO READ A NUMBER FROM THE TERMINAL
:	EXPECTS A CR OR SPACE CHARACTER AS DELIMITERS
TY.RDN	STH	R6,TY.RTN		:SAVE RETURN
	LIS	R5,0
	ST	R5,TY.NUM		:INITIALIZE NUMBER
	STH	R5,TY.CNT		:INITIALIZE COUNT OF CHARS INPUT
	JALR	R6,R15			:DISMISS
	RDR	R2,R5
	NHI	R5,7F			:STRIP OFF PARITY
	LHI	R6,-0D,R5		:SEE IF CR
	JE	TY.RD2
	SHI	R6,20-0D		:SEE IF SPACE CHAR
	JEFS	TY.RD1			:JUMP IF SO
	SIS	R6,2C-20		:SEE IF COMMA
	JEFS	TY.RD2
	SIS	R6,2E-2C		:IS IT A PERIOD
	JEFS	TY.RD1			:JUMP IF SO
	SHI	R6,5E-2E		:IS IT "^"?
	JNFS	TY.RD3			:SKIP IF NOT
TY.RD1	LHL	R6,TY.SB1		:MAKE SURE NOT IN READ ADDRESS MODE
	JE	TY.ERR
	STH	R5,TY.SB1		:SAVE CHAR TYPED
TY.RD2	LHL	R6,TY.RTN
	JR	R6			:RETURN TO CALLER

TY.RD3	LIS	R3,1
	AHM	R3,TY.CNT		:UPDATE INPUT COUNT
	SHI	R5,46			:SEE IF CHAR IN RANGE
	JG	TY.ERR			:JUMP IF NOT
	AIS	R5,6
	JGFS	.+4
	AIS	R5,7
	AIS	R5,9
	JL	TY.ERR			:JUMP IF ILLEGAL CHAR
	L	R3,TY.NUM
	SLLS	R3,4			:ADJUST CHARS ALREADY READ
	OR	R3,R5			:OR IN NEW CHAR
	ST	R3,TY.NUM		:SAVE WORD
	LPSWR	R0			:EXIT
	EI	(SYSDBG)		:
					:
   IF	TSPORT				:
					:
:	.......................................................................
:	PSEUDO-TYMSAT, RUNNING OFF TTY CARD...*ACCESS ONLY TO KERNEL*
:
:	HERE IF BREAK INPUT WHILE LOGGING IN
:	.......................................................................
					:
T.LBRK	RDR	R2,R6			:TOSS THE CHAR
					:
:	.......................................................................
:	HERE FOR LOGON STRING...TERMINATED WITH C/R OR SEMI-:
:	.......................................................................
					:
T.LOGON	JAL	R6,T.KINI		:INITIALIZE RINGS FOR KERNEL
T.LOG1	LA	R6,T.LOG2		:SET INPUT ROUTINE
	STH	R6,TY.IN		:
	LA	R6,T.LBRK		:SET UP LOGON BREAK HANDLER
	STH	R6,BRKSUB		:
T.LOG2	JAL	R6,TY.SRM		:SET READ MODE
					:
:	.......................................................................
:	INPUT ANOTHER LOGON CHAR, PLACE IT INTO RING
:	.......................................................................
					:
T.LOG3	JALR	R6,R15			:DISMISS UNTIL GET CHAR
	RDR	R2,R3			:INPUT CHAR
	JAL	R4,T.KIN		:PASS TO KERNEL
	NHI	R3,7F			:TEST FOR END OF LOGON
	SIS	R3,0D			:
	JEFS	T.LOG4			:C/R
	SHI	R3,3B-0D		:
	JNBS	T.LOG3			:OR SEMI-:...ELSE JUST KEEP PASSING
					:CHARS
:	.......................................................................
:	FAKE A KERNEL LOGGIN SVC
:	.......................................................................
					:
T.LOG4	LA	R6,TKRNG		:POINTER TO TTY RING
	ST	R6,KRP+NKU*4		:PLACE  IT
	LHI	R6,NKU			:
	SBT	R6,NEWLOG		:
	SBT	R6,KACT			:SET PORT ACTIVE
	LA	R6,T.IN			:SET INPUT ROUTINE
	STH	R6,TY.IN		:
	LA	R6,T.IBRK		:SET NEW BREAK HANDLER
	STH	R6,BRKSUB		:
	J	T.IN			:AND SKIP
					:
:	.......................................................................
:	NORMAL SESSION...GOT BREAK
:	.......................................................................
					:
T.IBRK	RDR	R2,R6			:TOSS CARD INPUT
	LHI	R3,200			:
	JAL	R4,T.KIN		:FLUSH INPUT
	LHI	R3,83			:
	JAL	R4,T.KIN		:FLUSH INPUT
	LHI	R3,8F			:
	JAL	R4,T.KIN		:FLUSH OUTPUT
T.IN	STH	R2,T.MODE		:SET READ MODE
	LB	R7,TY.MOD		:GET CURRENT TTY MODE
	OCR	R2,R7			:SET CARD TO READ MODE, NO ECHO
					:
:	.......................................................................
:	INPUT ANOTHER DATA CHARACTER, PLACE INTO RING
:	.......................................................................
					:
T.IN1	JALR	R6,R15			:DISMISS UNTIL INPUT OCCURS
	RDR	R2,R3			:GET INPUT
	JAL	R4,T.KIN		:SEND IT ON
	JBS	T.IN1			:DO SAME FOR NEXT CHAR
					:
:	.......................................................................
:	TTY OUTPUT
:	.......................................................................
					:
T.OUT	WDR	R2,R3			:OUTPUT THE DATA IN R3
T.OUT1	JALR	R6,R15			:DISMISS UNTIL PREVIOUS CHAR SENT
T.OUT2	LHI	R3,NKU			:WE USE THE LAST BUFFER
	LH	R7,TKRNG+NOO		:GET CURRENT CURSOR FOR US
T.OUT3	CH	R7,TKRNG+NIO		:CHECK KERNEL'S CURSOR
	JNFS	T.OUT4			:DATA PRESENT...SKIP
	LH	R6,TY.IN		:NO OUTPUT PRESENT...GET INPUT NAME
	JR	R6			:...AND GO SET UP TO INPUT
T.OUT4	LB	R3,TKRNG+KOB,R7		:GET NEXT CHARACTER
	AIS	R7,1			:BUMP TO NEXT CHAR
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R7,-KBS			:FOLD OUR CURSOR
	STH	R7,TKRNG+NOO		:UPDATE OUR  CURSOR
	CLHI	R3,7			:CHECK IF DATA CHAR
	JGE	T.OUT			:YES...OUTPUT IT
	SIS	R3,1			:CHECK IF ESCAPED DATA CHAR
	JGEFS	T.OUT5			:SKIP IF NOT
	LB	R3,TKRNG+KOB,R7	:YES...GET NEXT CHARACTER
	AIS	R7,1			:BUMP TO NEXT CHAR
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R7,-KBS			:FOLD OUR CURSOR
	STH	R7,TKRNG+NOO		:UPDATE OUR CURSOR
	J	T.OUT			:AND SEND IT
					:
T.OUT5	JEFS	T.OUT6			:SKIP IF PREFIX-CONTROL CHAR
	SIS	R3,2			:DID WE GET A ZAPPER?
	JN	T.OUT3			:NO...TOSS ALL OTHERS
	LIS	R3,0A			:ZAPPER...OUTPUT A L/F
	WDR	R2,R3			:
	JAL	R6,T.KINI		:RE-INITIALIZE RINGS FOR NEXT SESSION
	LA	R6,T.LOG1		:PROCEED WITH NEXT SESSION
	STH	R6,TY.IN		:...AFTER BANNER IS OUTPUT
	LPSWR	R0			:DISMISS UNTIL L/F DONE
					:
T.OUT6	LB	R3,TKRNG+KOB,R7		:PREFIX...GET IT
	AIS	R7,1			:BUMP TO NEXT CHAR
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R7,-KBS			:FOLD CURSOR
	STH	R7,TKRNG+NOO		:UPDATE CURSOR
	CLHI	R3,0FF			:CHECK FOR YELLOW BALLS
	JN	T.OUT3			:IGNORE OTHERS
	AHI	R3,100-1		:ELSE RETURN AN ORANGE
	JAL	R4,T.KIN		:
	J	T.OUT3			:AND PROCEED
					:
:	.......................................................................
:	TTY PERIODIC LOGIC
:	LINK ON R1
:	.......................................................................
					:
TY.CHK	LHI	R6,E.PSW%I.ENA		:DISABLE INTERRUPTS
	EPSR	R0,R6			:*F*OLD PSD IS NOW IN R0:R1
	LH	R6,TKRNG+NOO		:*F*GET OUR CURSOR
	CLH	R6,TKRNG+NIO		:*F*COMPARE
	JEFS	TY.CXIT			:*F*EXIT IF NONE
	TS	T.MODE			:*F*DATA PRESENT...ARE WE OUTPUTTING?
	JLFS	TY.CXIT			:*F*YES...ABORT
	LA	R6,T.OUT2		:*F*NO...SET OUTPUT ROUTINE
	STH	R6,TY.SUB		:*F*
	LIS	R2,2			:*F*SET DEVICE ADDRESS
	LHI	R6,TY.WRITE		:*F*WRITE COMMAND
	OCR	R2,R6			:*F*SET WRITE MODE
TY.CXIT	LPSWR	R0			:AND EXIT BACK TO CALLER, WITH CORRECT
   EI  (TSPORT)				:PSW
					:
:	.......................................................................
:	ROUTINE TO SET CARD IN WRITE MODE...DISMISS IF CARD FORMERLY
:	IN READ MODE.
:	.......................................................................
					:
TY.SWM	TS	T.MODE			:TEST IF FORMERLY IN READ MODE
	JLR	R6			:NO...JUST PROCEED
	STH	R6,T.SRW		:YES...DISMISS ONCE
	LHI	R6,TY.WRITE		:
	OCR	R2,R6			:SET CARD TO WRITE MODE
	JALR	R6,R15			:DISMISS IT
	LHL	R6,T.SRW		:DONE...RESTORE RETURN
	JR	R6			:AND PROCEED
					:
:	.......................................................................
:	ROUTINE TO SET CARD IN READ MODE.
:	.......................................................................
					:
TY.SRM	STH	R2,T.MODE		:SET READ MODE
	LHI	R7,TY.ECHO		:
	OCR	R2,R7			:SET CARD TO READ MODE
	JR	R6			:AND RETURN
					:
:	.......................................................................
:	CONSTANTS AND VARIABLE STORAGE
:	.......................................................................
					:
T.MODE	HC	0			:CURRENT MODE...NEGATIVE IF WRITE
T.SRW	HC	0			:RETURN FROM SET/WRITE ROUTINE
TY.SUB	HC	0			:SUBROUTINE ADDRESS HOLDING CELL
BRKSUB	HC	0			:BREAK-HANDLING ROUTINE ADDRESS
TY.IN	HC	0			:CURRENT INPUT ROUTINE
   IF	SYSDBG				:
TY.RTN	HC	0			:SUBROUTINE RETURN ADDRESS HOLD CELL
TY.CNT	HC	0			:COUNT OF CHARS READ
TY.SHF	HC	0			:OUTPUT CHAR SHIFT FACTOR HOLDING CELL
TY.WRB	HC	0			:
TY.WRD	HC	0			:AMOUNT OF WORDS TO OUTPUT
TY.WRR	HC	0			:
TY.SV0	HS	3			:TEMP HOLDING CELL FOR HALFWORDS READ FROM TTY
TY.SVA	HC	0			:CORE ADDRESS READING OR WRITING INTO
TY.SB1	HC	0			:USED TO KEEP TRACK OF PERIOD OF SPACE OPTION
TY.SBC	HC	0			:SAVE CELL FOR UNCLOBBERED SUBROUT BITS
TY.NUM	WC	0			:
TY.ADR	WC	0			:
TY.ADC	WC	0			:SAVE CELL FOR UNCLOBBERED ADDRESS
   EI  (SYSDBG)				:
					:
	BND	100			:FORCE TO PAGE BOUNDARY
	FO	KCAREA			:
	EM				:

	NOLIST

:	FINALLY UPDATE ALL EXPRESSIONS FOR LOGICAL UNITS
:	FIRST DEFINE A MACRO TO BITCH WITH
BITCH	MACRO(VAL,MOD,TEXT)[
U	EQ	VAL;	FO	MOD
	ELSE
U	EQ	0
	REMARK	%% 'TEXT' ERR%%
]

:	THIS MACRO WAS CREATED TO AVOID A REPEAT RANGE ERROR

UPDATE	MACRO[
U	EQ	$A S|Q|L|QQ|
	IF	U+1
V	EQ	U&M1
W	EQ	U&M2
	IF	V-TDEV
U	EQ	0;	REMARK	%%%%FIX ME%%%%
	ELSE	V-IPIDEV
	LO	SBUS
	BITCH(V+SBUSDB,SBUS,SPIRIT_BUS_DEVICE)
	ELSE	V-M.CARD
	IF	IPNMBR; LO IPI
	BITCH(V+IPLUD|W|,IPI,IPI_DEVICE)
	EI
	ELSE	V-UDEV
	IF	M.NCARD;	LO	MBOARD
U	EQ	$0 W&0F
W	EQ	$0 W/10
	BITCH(V+M.P|W||U|,MBOARD,M-BOARD)
	EI
	ELSE	V-PRN
	REMARK	%% UNSUPPORTED DEVICE ERR%%
	ELSE	V-ASN
	IF	NPRINT;	LO	PRINT
	BITCH(V+PLDB|W|,PRINT,PRINT)
	EI
	ELSE	V-SYN
	IF	NASYNG;	LO	CLOCKS
	BITCH(V+GPB|W|,CLOCKS,ASYNC)
	EI
	ELSE
	IF NSYNC;	LO	SYNC
	BITCH(SLDB|W|,SYNC,SYNC)
	EI
	EI
	ELSE
U	EQ	0
	EI
X|Q|L|QQ| EQ    U
QQ	EQ	QQ+1
]

Q	EQ	0
	RE	NSLOT+1
QQ	EQ	0
	RE	NLU
	UPDATE
	ER
Q	EQ	Q+1
	ER

	KILL	BITCH		:DESTROY MACRO..DON'T NEED IT ANY MORE

	LIST


	SUBTTL	KERN. . .I S I S   K E R N E L

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other   purpose except as specifically authorized in  wri-  **
: **  ting by  TYMNET, Incorporated.                              **
: ******************************************************************

	GL	DDTBGN,TRAP,LOWDDT,HGHDDT,XDDT,NPART
	GL	XCORE,EXSLOT,TRASL,ACCESS,RPSW,SPIXPI,CPSADR
	GL	LOG,GODGUY,GGLIC,GGUSE,GGNAME,GGMACH,GGLEN
	GL	SPYTAB,SPYRNG,SPYSAD,SPYWTH,SPYFLAG,SPYFLC
   if	FSYS
	GL	DDTCLS,DD.MSK,FUSER,INUSE
   ei  (FSYS)
   if	SUP
	GL	GGPRO,GGERR,GGACC,GGSYS,GGUN2,SCAREA
   ei  (SUP)
	GL	I.HTBL,I.UTBL,I.PTBL,I.HSIZ,I.PSIZ
   if	MXP
	GL	LANSTS
   else
    if	NSLOT				:ASSEMBLE CORRECTLY IF NSLOT=0
	GL	I.IRNG,I.ORNG,I.IRSZ,I.IBKB,I.OBKB,I.PCTB
	GL	I.QUE,I.CMD0,I.CTL,I.CHRS
    ei (NSLOT)				:
   ei  (MXP)				:
					:
:	...............................................................
:	DEFINE DEFAULT FOREGROUND QUANTUM
:	...............................................................
					:
	RA	$A10			:
Q	EQ	0			:FOR ALL SLOTS
 re	NSLOT+1
	DEFAULT(Q.FG|Q|,NLUS|Q|/3+5)
  if	SHARE
	DEFAULT(SH.Q|Q|,5)		:DEFAULT "DREQ"
    IF	TSIDT
	DEFAULT(TSIT|Q|,0)		:SECONDS TO WAIT FOR T/C
	DEFAULT(TSIC|Q|,0)		:RETURN 'DEVICE UNAVAILABLE'
    EI (TSIDT)
  ei
Q	EQ	Q+1
 er					:
	RA	0			:

	MO    .,KERNEL			:
	LO	KCAREA			:

		SUBTTL	KERNEL FUNCTIONAL ORGANIZATION

:	...............................................................
:
:		The KERNEL has three major functions:
:
:	1.  perform the scheduling algorithm,
:	2.  perform services for users on request,
:	3.  Service certain abnormal events, such as power failure,
:	    illegal instructions, etc.
:
:		In addition, the KERNEL performs a number of minor additional
:	functions, such as handling special external devices--such as tape
:	and disc--which are shared by multiple users, and others, such as
:	initiating log-on to DDT and other processes, initialization, etc.
:
:		The KERNEL has control of a number of independent processes,
:	or "JOBS".  When the KERNEL is "active", it's major function is
:	the swift determination of the next JOB to run (scheduling).  JOBS
:	may be inactive or active--active JOBS may be waiting or runable.
:	Active jobs may be on either of two queues--Background or Foreground
:	(QUASI).
:
:		Furthermore, JOBS are collected into groups called SLOTS.
:	Each SLOT has several JOBS of different aspects--Background and
:	Foreground are two such aspects, as is DDT.
:		The KERNEL maintains the identity and connectivity of the
:	individual JOBS and SLOTS through descriptive USER BLOCKS.  These USER
:	BLOCKS are of varying length depending on the subset of functions
:	provided to that JOB...a DDT job requires more unique storage
:	than a Foreground job.
:
:		When the KERNEL is active, it first examines the queue of
:	Foreground JOBS to determine if one of them is to run, or the time <T>
:	remaining until the group of foreground processes is to execute.  If
:	there is free time remaining, the last-run background job is examined
:	to see if it is to continue execution...if not, the next runable job
:	in the Background queue is found, and set up with a 50-millisecond
:	run quantum.  For the JOB found, the MAC and registers are set up,
:	a <T> execution quantum (the time before it is to be interrupted)
:	is set, and execution is transfered to that process.
:
:		That process may exit by any of three mechanisms:
:	1.  It may crash through some illegal operaton,
:	2.  It may time-out, either because it is heavily loaded, or
:	because a higher-priority process (e.g., Foreground) needs
:	the machine,
:	3.  It may call upon the KERNEL to perform some function, which
:	explicitly or implicitly causes it to dismiss, either for the
:	current time-slice, or for the duration of some event (e.g. timeout).
:
:		When a JOB'S execution is terminated for any reason, it is
:	cleaned up by the KERNEL, which saves the JOB's PSW and, unless
:	told otherwise by the JOB, the JOB's registers.
:
:		The KERNEL has one special JOB which is not on either of
:	queues:  the DISPATCHER.  The DISPATCHER is run each time a Background
:	JOB (flagged to be associated with the DISPATCHER) is completed,
:	but before the next Background JOB is run.  The DISPATCHER thus
:	has an execution priority above other Background jobs, but below
:	all Foreground JOBS.
:
:		Only certain of the Background JOBS are connected to the
:	DISPATCHER.
:
:		The NODE code is such a Background JOB, and has a Foreground
:	JOB associated with it, for those processes requiring immediate
:	attention.
:
:		USER BLOCKS are always core resident.  They may appear in
:	one of 3 queues, the Foreground, Background, or Name (KERNEL-I/O
:	JOBS not currently logged-in) queue.  These queues are implemented
:	as straight linked lists.  Inactive jobs may be in the Name queue,
:	or dependants of other JOBS (e.g. a particular Foreground Job is
:	dependant on it's Background JOB, which is in turn dependant on
:	it's DDT job).
:
:		One type of JOB is associated with a function called KERNEL-
:	I/O (KIO).  DDT is of such a type, as is the LOGON process.  These
:	JOBS interface to the KERNEL for I/O, which in turn communicates with
:	the NODE code.  The NODE-KERNEL port interface is NKU ports.  There
:	is one additional port assigned for communications with the local TTY.
:	Each is a ring buffer with two pointers for output buffers, and
:	3 pointers for input buffers.  (On input, the KERNEL prescans recently
:	arrived characters looking for zappers, etc.)
:
:		When a new login occurs, the NODE code sets a bit in NEWLOG,
:	which is noticed by the KERNEL, causing LOGON to be connected to
:	be connected to that port for validation.  Once succesful, LOGON
:	switches context to the appropriate JOB.
:
:	...............................................................



:		K E R N E L   P A R A M E T E R S

					:
KQ	EQ	$ARATE*50/1000		:CLOCK TICKS FOR 50 MILISECOND KERNAL QUANTUM
FKP	EQ	KQ/2			:CLOCK TICKS FOR 25 MILISECOND FOREGROUND PERIOD
 if	baudr				:
FLASHD	EQ	FKP/5			:CLOCK TICKS FOR 5 MILISECOND FLASHER FOREGROUND DURATION
 else					:
flashd	eq	$a 13			: ***etm
 ei    (baudr)				:
 if	NASYNG				:
  if	baudr				:
FLASHP	EQ	FLASHD			:CLOCK TICKS FOR 5 MILISECOND FLASHER FOREGROUND PERIOD
  else					:
flashp	eq	$a 15			: run low speed async only 40 time/second ***etm
  ei   (baudr)				:
 else					:
FLASHP	EQ	FKP			:CLOCK TICKS FOR 25 MILISECOND FLASHER FOREGROUND PERIOD
 ei    (NASYNG)				:
FGNDP	EQ	FGFREQ			:CLK TICKS FOR FOREGND PERIOD
					:
NPART	EQ	NSLOT			:NUMBER OF PARTITIONS
 if	SUP				:
NPART	EQ	NSLOT+7			:NUMBER OF PARTITIONS IF SUP MACHINE
 ei    (SUP)				:
					:
:	...............................................................
:
:	REGISTER DESIGNATORS
:
:	R1	USER-BLOCK BASE REGISTER...MUST BE R1 !!!
:	R2	INTERNAL PORT INDEX
:	R3	KERNEL RING POINTER
:	R11	LINK REGISTER
:	R12	KERNEL CHARACTER REGISTER FOR KERNEL I/O
:
:	...............................................................



LKER	HS	0			:
					:
:	.......................................................................
:	DATA LAYOUT OF GOOD-GUY ENTRY
:	.......................................................................
					:
	ORG	0			:DEFINE RELATIVE ENTRIES
GGLIC	HS	1			:HALF-WORD OF LICENCE
GGUSE	HS	1			:HALF-WORD OF USAGE CONTROL
GGNAME	HS	4			:UP TO 8 BYTES OF USER NAME
GGMACH	HS	1			:MACHINE ATTRIBUTE
GGLEN	HS	0			:THE SIZE OF A LIST ENTRY
					:
:	.......................................................................
:	DATA LAYOUT OF USER BLOCK
:	.......................................................................
					:
	ORG	0			:DEFINE RELATIVE PARAMETERS
LLINK	WS	1			:LINKS BLOCK IN QUEUES (---MUST BE FIRST---)
OTHER	WS	1			:LINKS FOREGROUND AND BACKGROUND
CONTROL	WS	1			:POINTER TO CONTROLLING (OR CONTROLLED) DDT BLOCK
REST	WS	1			:DIST AREA & MEMORY FOR RESTART
INIPSW	WS	2			:INITIAL PSW
RPSW	WS	2			:CURRENT PSD
RREG	WS	10			:REGISTER SAVE AREA (MUST FOLLOW RPSW)
SUSLST	WS	2			:SLOTS TO SUSPEND IF THIS SLOT STOPS
WFROGT	WS	1			:SVC-DRIVEN WATCHFROG TIMER
WFROGD	WS	1			:DISMISS-DRIVEN WATCHFROG TIMER
MACTRN	WS	3			:POINTERS FOR MAC TRANSFER
MPROT	WS	MACREG			:MAC REGISTERS
 if	MULMAC				:
PSLOC	WS	1			:DUMMY PSD LOCATION
CCOUNT	HS	1			:LOCATION OF USAGE COUNT
MACSET	HS	1			:MAC SET IN USE
MLINK	WS	1			:R11 FOR MAC BLOCKS
 ei    (MULMAC)				:
UDMS	HS	5			:CODE TO SAVE REGISTERS FOR DISMISS
					:	STM	R0,RREG
					:	J	MAIN,,
USTRT	HS	4			:CODE TO RESTORE REGISTERS FOR START
					:	LM	R0,RREG
					:	LPSW	RPSW
UFLAG	HS	1			:USER FLAGS
WFLAG	HS	1			:USER WAIT FLAGS
SLOT	HS	1			:JOB SLOT NUMBER
STIME	HS	1			:USER TIME ALLOCATION
QUANTUM	HS	1			:BACKGROUND QUANTUM
FQNTUM	HS	1			:FOREGROUND QUANTUM
WAKE	HS	1			:WAKE-UP TIMER
WAKETR	WS	1			:WAKE-UP TIMER TRAP ADDRESS
XWAKE	WS	1			:UN-MAC'ED WAKE-UP TRAP ADDRESS
UTIME	WS	1			:TIME FOR TIMEOUT AFTER GIVEUP SVC
RLICEN	WS	1			:RUN SLOT LICENSES
   if	NBLKS				:DEFINE ONLY IF EXTENDED BLOCKS USED
STAMAC	HS	2			:0 IF EXTENDED MAC NOT SET-UP
STAPSW	HS	2			:LOCATION OF PSW BLOCK FOR USER
LIMMAC	HS	1			:LIMIT ON NUMBER OF MACS
BLKPRT	BS	NBLKS			:PROTECTION MASK FOR EACH BLOCK
BLOCKS	WS	NBLKS			:LIMITS FOR EACH BLOCK
   ei  (NBLKS)				:
LUN	WS	NLU			:POINTERS TO LOGICAL UNITS
   if	MULTI				:
SRSEG	HS	1			:SIO RING SEGMENT
	HS	1			:BOUNDRY FILLER
SLUTBL	WS	SLUNUM+1		:
   ei  (MULTI)				:
  if	SHARE				:
ESWQ	WS	1			:E-SELCH WAIT QUEUE
DREQ	HS	1			:NO. OF OUTSTANDING DISC/TAPE REQUESTS
					:IF ZERO WORK HAS BEEN COMPLETED OR ABANDONED
DQUOTA	HS	1			:DREQ QUOTA
   IF	TSIDT				:
DTSTO	HS	1			:NO TIMEOUT=0, OR # OF SECONDS
DTSIOU	HS	1			:HOW TO HANDLE DEVICE UNAVAILABLE
   EI  (TSIDT)				:
LUT	HS	NXLU			:EXTENDED LOGICAL UNITS
NDPB	EQ	 0			:WE'LL COUNT UP PARAMETER BLOCKS
  ei   (SHARE)				:
RBLEN	WS	0			:====THE SIZE OF A RUN BLOCK====
					:
XLLINK	WS	1			:EXTRA COPY OF FREE QUEUE R11
SLICEN	HS	1			:SLOT LICENCE REQUIREMENTS
SKEY	HS	1			:SLOT KEY
SBASE	WS	1			:PRIMATIVE MAC FOR THIS SLOT
CMAX	HS	1			:MAXIMUM NUMBER OF PAGES OF CORE FOR THIS SLOT
ULICEN	HS	1			:USER LICENCES
BUFNO	HS	1			:POINTS TO BUFFER PAIR
UOUT	HS	4			:SAVE AREA FOR START & END ADDR TTYOUT WAIT
UIN	HS	1			:SAVE AREA FOR BUFFER ADDR OF TTYIN WAIT
UDFLAG	HS	1			:USER DISCONNECT FLAG..<0=ZAPPER WAITING, >0=DETACH
GGNDX	HS	1			:INDEX FOR GOOD-GUY LIST FOR CURRENT USER
OGGNDX	HS	1			:INDEX FOR GOOD-GUY LIST FOR PRIOR USE
TERCAR	HS	1			:HOLDS LOGIN TERMINAL ID
BGTRAP	HS	2			:BKGND FAULT TRAP RTN ADDR
FGTRAP	HS	2			:FRGND FAULT TRAP RTN ADDR
EXTRAP	HS	2			:EXIT TRAP RTN ADDR
KBLEN	WS	0			:====LENGTH OF KIO (TTY I/O) BLOCK====

NEWPSW	WS	2
OLDPSW	WS	2
XX	HS	7
:	XX	STM	0,URSA
:		LM	0,DRSA
:		J	XDDT,,
YY	HS	6
:	YY	STM	0,DRSA
:		LM	0,URSA
:		LPSW	OLDPSW
SPSW	HS	1			:INITIAL STATUS BITS USED BY DDT INST "G"
CPSW	HS	1			:CURRENT STATUS BITS USED BY DDT INST "G"
MACLOC	HS	2			:ADDRESS OF LAST MAC ERROR ENCOUNTERED
MODE	HS	1			:ASCII - BINARY MODE FLAG
URSA	HS	20			:USER REGISTER SAVE AREA
DRSA	HS	20			:DDT REGISTER SAVE AREA
FLAG	HS	1			:USER TYPED BREAK CHARACTER
XFLGX	HS	2			:BREAKPOINT CONTEXT FLAG
XREG	BS	1			:REG/MEMORY CONTEXT FLAG
TEMP	HS	2			:USED BY ACONV IN BINARY MODE (ALSO "N" AND "P")
BPNO	EQ	0A			:NUMBER OF USER BREAKPOINTS
LISTA	HS	(BPNO+2)*2		:R3 ADDRESS LIST
LISTO	BS	BPNO+2			:R3 OPCODE LIST
SLINK	HS	2			:R11 SAVE AREAS
TLINK	HS	2
ULINK	HS	2
EFLAG	HS	1			:ERROR KEY SET BY KERNEL AT ENTRY
INBUF	BS	1			:INPUT BUFFER
	ORG	.!1			:INSURE ODD BOUNDARY
ROUT	BS	11			:ADDRESS OF ILL INST IN ERROR MSG
SMASK	HS	2			:MASK FOR DATA SEARCH
SLOW	HS	2			:START ADDR FOR SEARCH
SHGH	HS	2			:END ADDR FOR SEARCH
   if	SHARE				:
HDISK	HS	8			:WORKING SPACE FOR LOAD, STORE COMMANDS
   ei  (SHARE)				:
   if	FSYS				:
FSSEG	HS	1			:
   ei  (FSYS)				:
CC	HS	1			:CONDITION OF LAST MAC OR MALFUNCTION INT.
UMAC	WS	1			:CURRENT USER MAC THAT DDT USES
DDTMAC	WS	MACREG			:DDT MAC REGISTER STORAGE AREA
   if	MULMAC				:
	WS	3			:
   ei  (MULMAC)				:
DBLEN	WS	0			:====LENGTH OF DDT BLOCK====
					:
:	.......................................................................
:	USER FLAGS
:	.......................................................................
					:
FQUASI	EQ	8000			:QUASI JOB
FBACK	EQ	4000			:BACKGROUND JOB
FKIOJ	EQ	2000			:USER RUNNING UNDER KERNEL I/O
FDDT	EQ	1000			:USER RUNNING UNDER DDT
FLOGIN	EQ	800			:USER IN LOGIN
FDISP	EQ	400			:IF ON, RUN DISPATCHER AFTER BACKGROUND TIME SLICE
FNOREG	EQ	200			:DON'T LOAD REGISTERS IF SET--SEE START CODE
F1CRAS	EQ	100			:IF ON, KILL USER ON SUBSEQUENT CRASH
UFL80	EQ	80			:AVAIL FOR FUTURE USE
UFL40	EQ	40			:AVAIL FOR FUTURE USE
UFL20	EQ	20			:AVAIL FOR FUTURE USE
UFL10	EQ	10			:AVAIL FOR FUTURE USE
UFL8	EQ	8			:AVAIL FOR FUTURE USE
UFL4	EQ	4			:AVAIL FOR FUTURE USE
FDEBUG	EQ	2			:DEBUG MODE
FZAP	EQ	1			:WANTS TO BE INFORMED OF ZAPPERS
					:
:	.......................................................................
:	USER WAIT FLAGS
:	.......................................................................
					:
FGACK	EQ	100			:WAIT FOR GOBBLER ACK
FTIM	EQ	80			:WAIT TIMEOUT FROM GIVEUP SVC
FIN	EQ	40			:TTY IN WAIT
FOUT	EQ	20			:TTY OUT WAIT
FDSK1	EQ	10			:WAIT FOR DISK I/O COMPLETION
FDSK2	EQ	8			:WAIT FOR AVAILABLE DCB FOR DISK I/O
FREEZE	EQ	4			:WAIT FOR THAW
XPIWF	EQ	2			:WAIT FOR XPI RESPONSE
KDISC	EQ	1			:SHARED DEVICE NOT AVAILABLE - CRASH SLOT
FSLEEP	EQ	FREEZE!FIN!FOUT!FDSK1!FDSK2!FTIM!KDISC :ALL POSSIBLE NON-READY FLAGS
					:
:	.......................................................................
:	DDT LICENSES
:	NO LICENSE STILL ALLOWS ACCESS TO DETERMINE SLOT STATUS
:	.......................................................................
					:
L.DISC	EQ	0001			:LICENSE TO FORMAT A DISC
L.SYA	EQ	0002			:LICENSE TO ACCESS SYSTEM
L.S0A	EQ	0004			:LICENSE TO ACCESS SLOT 0
L.SUA	EQ	0008			:LICENSE TO ACCESS SUPERVISOR SLOTS, IF ANY
L.HALT	EQ	0010			:REQUIRES SLOT BE HALTED
L.SYP	EQ	8000			:LICENSE TO PATCH IN SYSTEM
L.SYR	EQ	4000			:LICENSE TO READ IN SYSTEM
L.S0P	EQ	2000			:LICENSE TO PATCH IN SLOT 0
L.S0R	EQ	1000			:LICENSE TO READ IN SLOT 0
L.P	EQ	0800			:LICENSE TO PATCH
L.H	EQ	0400			:LICENSE TO HALT A SLOT
L.E	EQ	0200			:LICENSE TO CONTROL EXECUTION ON A SLOT
L.L	EQ	0100			:LICENSE TO LOAD A SLOT
L.R	EQ	0080			:LICENSE TO READ A SLOT'S MEMORY
					:
:	.......................................................................
:	DATA LAYOUT OF SIO RING DESCRIPTOR BLOCK
:	.......................................................................
					:
	ORG	0			:
SDISIZ	HS	1			:INPUT RING SIZE
SDOSIZ	HS	1			:OUTPUT RING SIZE
SDIEND	WS	1			:INPUT RING END ADDR
SDOEND	WS	1			:OUTPUT RING END ADDR
SDRDEV	HS	1			:RING # AND DEVICE ADDR
SDMBLU	HS	1			:M-BOARD LU

	ORG	LKER

:	....................................................................
:
:			M A C R O   D E F I N I T I O N S
:
:	....................................................................
					:
:	....................................................................
:	DEFINE ONE ENTRY FOR GOOD-GUY LIST
:	....................................................................
					:
GG	MACRO(PR,ACCESS,NAME,MACH)[
Q	HC	PR,ACCESS
QQ	AC 'NAME'
	ORG	QQ+8
	HC	MACH
	ORG Q+GGLEN
]					:
					:
:	....................................................................
:	Macro to make MAC Register Format
:	....................................................................
					:
MAKEMAC	MACRO(A,B) [((A-1)^MSHFTL)!(B^(MSHFTB+MSHFTA))]
					:
:	....................................................................
:	MACRO TO CREATE A LIST OF MAC SET USAGES
:	....................................................................
					:
ZITMAC	MACRO	[
 if	MULMAC
	WC	0			:PSD LOCATION
	HC	0			:COUNT
	HC	$0 0FF00		:FLAG AS INTERNEL, MAC SET 0
MCLX	EQ	.			:REMEMBER WHERE WE ARE AT
	ORG	OMCLX			:BACK UP TO LST SET
	WC	$0 MCLX-0A		:THREAD ON LIST
	ORG	MCLX			:RETURN TO CURRENT
OMCLX	EQ	.			:REMEMBER THIS AS LAST
	WC	0			:TAG AS END OF LIST
 ei    (MULMAC)				:
]					:
					:
:	....................................................................
:	DEFINE MACRO TO GENERATE FIRST SECTION OF USER BLOCK
:	....................................................................
					:
UB1	MACRO(M1,M2,M3,M4,M5) [WC	M1,M2,M3,0
	WC	M4,M5			:
	WC	M4,M5			:
	WS	$010			:
	WC	0,0,-1,-1		:
]					:
					:
:	....................................................................
:	Define MACRO to generate "MPROT" section of user block
:	Setup MAC registers if they are pre-defined.
:	....................................................................
					:
MACBLK	MACRO(M0,M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14)[
	WC   $0 .+MPROT-MACTRN+MACDIS 	:LAST HW
	WC   $0 MACAREA+MACDIS		:LAST HW
	WC   $0 (1F)*10			:
	WC	M0,M1,M2,M3,M4,M5,M6	:MPROT
	WC	M7,M8,M9,M10,M11,M12	:
	WC	M13,M14 		:
	WC	CONMAC			:Segment F
	ZITMAC				:
]					:
					:
:	....................................................................
:	DEFINE MACRO TO GENERATE SECOND SECTION OF USER BLOCK
:	....................................................................
					:
UB2	MACRO(M0,M1,M2,M3,M4,M5)[
	ORG	M0+UDMS			:
 if	SPAM				:
	STM	R0,M0+RREG		:
	J	UDMISS,,		:
 else					:
	STM	R0,M0+RREG		:
	J	MAIN,,			:
 ei	(SPAM)				:
	LM	R0,M0+RREG		:
	LPSW	M0+RPSW			:
	HC	M1			:USER FLAGS
	HC	0			:USER WAIT FLAGS
	HC	M2			:JOB SLOT #
	HC	M3			:TIME ALLOCATION
	HC	M4			:QUANTUM
	HC	M4			:FOREGROUND QUANTUM
	HC	0			:WAKE TIMER
	WC	0			:WAKE TIMER TRAP ADDRESS
	WC	0			:USER'S WAKE ADDRESS
	WS	1			:UTIME
	WC	M5 0			:RUN SLOT LICENSE
 if	NBLKS
	HC	0,0,0,0,0		:FLAG FOR ACTIVE SEG E
  if	M2
	BC	000			:ALL ACCESS FOR FIRST AREA
	BC	$0 0A			:READ ONLY
	BC	$0 0A
QQ5	EQ	3
   if	NBLKS-3
    re	NBLKS-3
	BC	P|M2|M|QQ5|
QQ5	EQ	QQ5+1
    er
   ei	:NBLKS-3
	WC	0			:FIRST AREA FILLED IN LATER
	WC	0			:CTA TABLE FILLED IN AT EXECUTION
QQ5	EQ	$0(ISEGS/100)
	HC	QQ5
	HC	QQ5+$0(ISEGL/100)
QQ5	EQ	3
   if	NBLKS-3
    re	NBLKS-3
	WC	M|M2|L|QQ5|
QQ5	EQ	QQ5+1
    er
   ei	NBLKS-3
  else
	BS	NBLKS
	WS	NBLKS
  ei	:M2
 ei	:NBLKS
]
					:
:	....................................................................
:	DEFINE MACRO TO GENERATE UTILITY SECTION OF USER BLOCK
:	....................................................................
					:
UB3	MACRO(Q,Q3,Q4) [
	LUBLOK(Q4)
	SLUBLK(Q4)
	DSCBLK(Q4,SH.Q|Q4|,SH.Q|Q4|)
   if	(.GT.(Q4,0))!(.LE.(NODENM,0))
	 KIOBLK(UBX|Q4|,UBX|Q4+1|,L.P!L.H!L.L!L.R,Q4,Q+NCTA,Q3)
   else
	 KIOBLK(UBX|Q4|,UBX|Q4+1|,L.SYA!L.S0A!L.SYP!L.SYR!L.S0P!L.S0R,Q4,Q+NCTA,Q3)
   ei


]
					:
:	.......................................................................
:	DEFINE MACRO TO GENERATE LOGICAL UNIT TABLE
:	If N < 0 
:	   RESERVE SPACE
:	ELSE
:	   GENERATE ENTRIES FOR XnLi
:	.......................................................................
					:
LUBLOK	MACRO(N)[
 if	N+1
QQ5	EQ	0
  re	NLU
	WC	$0 X|N|L|QQ5|
QQ5	EQ	QQ5+1
  er
 else
	WS	NLU
 ei    (N+1)
]

:	.......................................................................
:	SLUBLK - DEFINE MACRO TO GENERATE THE USER RING LOGICAL UNIT TABLE
:		 where S SLOT #
:	.......................................................................
					:
SLUBLK	MACRO(S) [
   IF	MULTI				:
	HC	-1			:SRSEG FIELD
	HC	0			:BOUNDRY FILLER
	IF	SLUSW			:
QQ1	 EQ	0			:
	 RE	SLUNUM+1
	  IF	\U|S|M|QQ1|
QQ2	   EQ	U|S|M|QQ1|
QQ3	   EQ	U|S|P|QQ1|
	   GL	Z|QQ2|D|QQ3|
	   WC	Z|QQ2|D|QQ3|		:ALLOCATE DESCRIPTOR PTR
	  ELSE
	   WC	0			:INDICATE NO LU
	  EI
QQ1	  EQ	QQ1+1
	 ER
	ELSE				:
	 WC	0			:NULL ENTRY FOR NO LUS
	EI     (SLUSW)			:
   EI  (MULTI)				:
]

:	.......................................................................
:	DSCBLK - DEFINE MACRO TO GENERATE EXTENDED LOGICAL UNIT TABLE WHERE
:	V	SLOT #
:	NQ	NUMBER OF REQUESTS OUTSTANDING BEFORE DISMISSAL
:	NR	NUMBER OF REQUESTS ALLOWED FOR SLOT
:	.......................................................................
					:
DSCBLK	MACRO(V,NQ,NR)[
 if	SHARE
	WC	0
	HC	0,NQ			:DREQ,DQUOTA
   IF	TSIDT				:
	HC	TSIT|V|,TSIC|V|		:TSI -> TIMEOUT, TIMEOUT RESPONSE
   EI  (TSIDT)				:
Q7	EQ	0			:
  re	NXLU
	HC	$0 X|V|U|Q7|
Q7	EQ	Q7+1
  er
  if	NQ				:
NDPB	EQ	NDPB+NR			:
  ei   (NQ)				:
 ei    (SHARE)				:
]

:	.......................................................................
:	KIOBLK - DEFINE MACRO TO GENERATE KERNEL-I/O SECTION OF USER BLOCK
:	.......................................................................
					:
KIOBLK	MACRO(M1,M2,M3,M4,M5,M6)[
	ORG	M1+RBLEN		:FORCE TO CORRECT BOUNDARY
	WC	M2			:
	HC	M3			:SLOT LICENSE
	HC	M4			:SLOT KEY
	WC	M5			:SBASE
	HC	M6			:CMAX
	ORG	M1+KBLEN		:EVERYTHING ELSE
]

:	.......................................................................
:	DEFINE MACRO FOR DATA SEGMENT INITIALIZATION
:	.......................................................................
					:
UBXDDT	MACRO(M,PSW,SEGS)[
	ORG	M+NEWPSW
	WC	E.PSW,M+XX,PSW,-1
	STM	0,M+URSA
	LM	0,M+DRSA
	J	XDDT,,
	STM	0,M+DRSA
	LM	0,M+URSA
	LPSW	M+OLDPSW
	HC	PSW,PSW
	ORG	M+LISTA
 re	BPNO+2
	HC	-1,-1
 er
	ORG	M+EFLAG
	HC	0
 if	FSYS
	ORG	M+FSSEG
	HC	$0 SEGS 0
 ei
	ORG	M+UMAC
	WC	M+MPROT+MACDIS
	ORG	M+DDTMAC
Q7	EQ	0
 re	MACREG
	WC	MMASKL+MASK1+Q7
Q7	EQ	Q7+SEGSIZ
 er
	ZITMAC
	ORG	M+DBLEN
]


:	....................................................................
:	CTA (SEG 0E) DEFINITIONS
:	....................................................................
					:
	GL	X.AUX.,X.PNR.,X.RNP.,X.RHN.,X.TTK.,X.TST.,X.ARR.
	GL	X.ZAC.,X.IPC.,X.UBA.,X.RMT.,X.UTK.,X.EXM.,X.DMZ.
					:
Q	EQ	.			:REMEMBER WHERE WE ARE
					:
	ORG	0			:
CTA	WS	0			:THE START OF THE CONTROL TABLE
CNTRL	WS	1			:CONTROL FLAGS
X.AUX.	EQ	1			:  SET DURING CONNECT IF AUX CIRCUITS ALLOWED
X.PNR.	EQ	2			:  SET IF PORTS NOT REUSABLE UNTIL ZAP OUTPUT
X.RNP.	EQ	4			:  SET IF NUMBER OF PORTS MAY BE REDEFINED
X.RHN.	EQ	8			:  SET IF HOST NUMBER MAY BE REDEFINED
X.TTK.	EQ	10			:  INTERFACE WANTS TO KNOW ABOUT TAKEOVER
X.TST.	EQ	20			:  INTERFACE WANTS TO KNOW SUPERVISOR TIME
X.ARR.	EQ	40			:  SET IF DISPATCHER SHOULD ACCEPT RESET REQS
X.ZAC.	EQ	80			:  SET IF DISPATCHER SHOULD ACKNOWLEDGE ZAPPERS & DETACHS
X.IPC.	EQ	100			:  SET IF PROJECT CODE IS TO BE COLLECTED
X.UBA.	EQ	200			:  SET IF END TO END BACKPRESSURE ARRAYS USED
X.RMT.	EQ	400			:  SET IF SLOT ACCEPTS DOWN REMOTE MESSAGE
X.UTK.	EQ	800			:  SET IF SLOT CARES ABOUT UNTAKE
X.EXM.	EQ	1000			:	SET IF EXTENDED MAC USED
					:  >1000 NOT USED
X.DMZ.	EQ	2000			:  IF EXT MAC DEFAULT DDT TO SET 0
CTASIZE	WS	1			:SIZE OF THIS AREA
AREAS	WS	$A 14			:SIZE OF EACH AREA
NPROT	HS	1			:COUNT OF USABLE PROTECTION BYTES
PROT	BS	$A 14			:MEMORY PROTECTION REQUIREMENTS

IENTRY	WS	1			:ENTRY POINT ADDRESS
DD.BGN	WS	1			:DDT EXECUTION START ADDRESS
STATUS	WS	1			:POINTER TO FRONT-PANEL DISPLAY CELL
HTBLPT	WS	1			:POINTER TO HOST TABLE
PTBLPT	WS	1			:POINTER TO PORT TABLE
TTBLPT	WS	1			:POINTER TO TERMINATION TABLE
					:  entry = 0 --> not in use
					:  entry  >0 --> index for buffer
					:  entry  <0 --> timeout or cleanup wait
IRPNT	WS	1			:INPUT -- RING DISCRIPTOR START ADDRESS
ORPNT	WS	1			:OUTPUT -- RING DISCRIPTOR START ADDRESS
IBKPNT	WS	1			:INPUT -- BACK-PRESSURE BITS POINTER
OBKPNT	WS	1			:OUTPUT -- BACK-PRESSURE BITS POINTER
PCBPNT	WS	1			:PROJECT CODE BITS POINTER
CSADDR	WS	1			:CORE START ADDRESS (REAL ADDR. OF CTA)
MAXHST	HS	1			:MAX NUMBER OF HOSTS ON SLOT
MAXPRT	HS	1			:MAX NUMBER OF PORTS ON SLOT
IMAXSZ	HS	1			:INPUT -- SIZE OF INPUT RING IN BYTES
OMAXSZ	HS	1			:OUTPUT -- SIZE OF OUTPUT RING IN BYTES
SLOTNO	HS	1			:SLOT'S NUMBER
SVERNO	BS	1			:SLOT'S VERSION NUMBER
SREVLEV	BS	1			:SLOT'S REVISION LEVEL
DD.BG2	WS	1			:SECOND DDT ENTRY
MACPNT	HS	1			:HW POINTER TO MAC BLOCKS
MAXCNT	HS	1			:HW COUNT OF MAC SETS
DD.MSK	HS	1			:
PID	HS	1			:PRODUCT ID
PATVER	HS	1			:PATCH VERSION NUMBER
ISUSLO	WS	1			:INITIAL SUSPEND LIST LOW
ISUSHI	WS	1			:INITIAL SUSPEND LIST HIGH
TSTAMP	HS	3			:CODE GENERATION TIME STAMP
	WS	10			:FOR FUTURE EXPANSION!
					:
	ORG	Q			:


:	....................................................................
:	THE FOLLOWING CELL **MUST** BE IN THE FIRST 64-K OF CORE, TO
:	BE REACHABLE FROM SVC TRAP LOCATIONS.  THUS, THEY ARE PLACED
:	HERE TO INSURE ACCESS.
:	....................................................................
					:
Q	EQ	2			:
 re	$A 14				:
SADDR|Q| LHI	0C,TSVC|Q|		:*0* SVC
	J	SVCH			:*0*
Q	EQ	Q+1			:
 er					:

	SUBTTL	KERNEL CONSTANT AREA

:	....................................................................
:	INITIALIZE SVC INTERRUPT VECTOR(S)
:	....................................................................
					:
VECTOR	HC	S.GUP			:Position 0 - BKGND Dismiss in sec.
	HC	F.GUP			:Position 1 - FGGND Dismiss in ticks
Q	EQ	2			:
 RE	$A 5				:
	HC	SADDR|Q|		:
Q	EQ	Q+1			:
 ER					:
	HC	T.GUP			:Position 7 - BKGND Dismiss in ticks
Q	EQ	8			:
 RE	$A 8				:
	HC	SADDR|Q|		:
Q	EQ	Q+1			:
 ER					:
					:
:	....................................................................
:	LIST OF POINTERS TO SLOTS, IN SLOT ORDER
:	....................................................................
					:
SLIST	WS	0			:
Q	EQ	0			:STARTING WITH SLOT 0
 re	NSLOT+1				:
	WC	$A UBS|Q|		:
Q	EQ	Q+1			:
 er					:
 if	SUP				:
	WC	UBSUP,UBXPROBE,UBXERR,UBXACC,UBXSYS,UBXUN2,UBUTIL
 ei    (SUP)				:
					:
:	....................................................................
:	PSW'S USED
:	....................................................................
					:
MAINPSD	WC	I.ENA!K.PSW,MAIN	:PSW TO EXIT TO MAIN LOOP
DDTPSW	WC	E.PSW,DDTBGN		:PSD TO START DDT
					:

	SUBTTL	GENERALIZED SVC HANDLER

:	....................................................................
:	DEFINE FUNCTION TO GENERATE SVC FANOUT, DEFINE VALUE
:	N	SVC #
:	F	SET OF FLAG BITS FOR WHICH SVC IS VALID
:	L	1 IF TO MAKE RX3 JUMP
:	ADDR	WHERE TO TRANSFER TO
:	....................................................................
					:
SVCFAN	MACRO(N,F,L,ADDR)[
TSVC|N|	EQ	.-TSVC
	HC	F
 if	L
	J	ADDR,,
	GL	ADDR
 else
	J	ADDR
 ei
]					:
					:
SVCH	STM	0C,F1			:*0*SAVE SVC INDEX, USER DATA ADDR, OLD PSW
	LHI	0C,I.ENA!20F0		:*0*
	EPSR	0D,0C			:*0*ENABLE INTERRUPTS, REG SET 0F
	ST	R0,F1R0			:SAVE USER REGS 0&1 AFTER OLD PSW
	ST	R1,F1R1			:
	L	R1,USER			:ADDR OF USER BLOCK OF CURRENT USER
	STM	R2,RREG+8,R1		:SAVE IN R1
	LM	R12,F1PS1		:OLD PSW & REGS 0,1
	STM	R12,RPSW,R1		:SAVE IN R1
 if	SYSMON				:
	LIS	R4,1			:
	AHM	R4,SYSTAT+2		:COUNT THIS STATISTIC
 ei    (SYSMON)				:
	LHL	R4,F1SVCL		:SVC INDEX
	J	TSVC+2,R4		:GO TO APPROPRIATE SVC ROUTINE (THROUGH TABLE)
					:
TSVC	SVCFAN(0,0,0,NOTI)		:0...TABLE OF SVC ROUTINE ADDRS...DISMISS
	SVCFAN(1,0,0,NOTI)		:1...FAST DISMISS
	SVCFAN(2,0,0,SYS.S)		:2...SYSTEM CALL SVC
	SVCFAN(3,0,0,CONIO)		:3...CONNECT I/O
 if	SHARE				:
   IF	TSIDT				:
	SVCFAN(4,0,1,TSISHR)		:4... DTS SHARED DEVICE SVC
   ELSE					:
	SVCFAN(4,0,1,QIOSVC)		:4...SHARED DEVICE SVC
   EI  (TSIDT)				:
 else					:
	SVCFAN(4,0,0,NOTI)		:4...SHARED DEVICEE SVC (UNIMPLEMENTED)
 ei    (SHARE)				:
	SVCFAN(5,0,0,NEWMAC)		:5...CHANGE MAC REGISTERS
 if	SBUS				:
	SVCFAN(6,0,0,SBSVC)		:6...CONNECT SPIRIT BUS
 else					:
	SVCFAN(6,0,0,NOTI)		:6
 ei    (SBUS)				:
	SVCFAN(7,0,0,NOTI)		:7...DISMISS IN TICKS
	SVCFAN(8,0,0,NOTI)		:8...NOT USED SVC
	SVCFAN(9,0,0,NOTI)		:9...NOT USED SVC
	SVCFAN(0A,FDDT!FKIOJ,0,TTYIN)	:0A...TTY INPUT SVC
	SVCFAN(0B,FDDT!FKIOJ,0,TTYOUT)	:0B...TTY OUTPUT
  IF	SHARE				:
   IF	TSIDT				:
	SVCFAN(0C,0,1,JCMSVC)		:0C...CONNECT/POLL JCOM
   ELSE					:
	SVCFAN(0C,0,0,NOTI)		:0C...NOT-USED SVC
   EI  (TSIDT)				:
  ELSE					:
	SVCFAN(0C,0,0,NOTI)		:0C...NOT-USED SVC
  EI   (SHARE)				:
	SVCFAN(0D,FDDT!FKIOJ,0,GSVC)	:0D...GENERAL SVC
 if	SHARE				:
  if	NDISC*SUP			:
	SVCFAN(0E,0,1,DISKB)		:0E...BIG DISC SVC
	SVCFAN(0F,0,1,DISKS)		:0F...LITTLE DISC SVC
  else					:
	SVCFAN(0E,0,0,NOTI)		:0E...BIG DISC SVC (UNIMPLEMENTED)
	SVCFAN(0F,0,0,NOTI)		:0F...LITTLE DISC SVC (UNIMPLEMENTED)
  ei	(NDISC*SUP)			:
 else					:
	SVCFAN(0E,0,0,NOTI)		:0E...BIG DISC SVC (UNIMPLEMENTED)
	SVCFAN(0F,0,0,NOTI)		:0F...LITTLE DISC SVC (UNIMPLEMENTED)
 ei	(SHARE)				:
	KILL	SVCFAN			:DESTROY THIS SYMBOL
					:
:	....................................................................
:	REPOP SVC--FIXUP PROGRAM COUNTER SO THAT SVC RUNS AGAIN
:	NEXT TIME USER RUNS.
:	....................................................................
					:
STOP43	ST	R4,STP43		:BADD REPOP ADDRESS CRASH CODE 63
	ST	R13,STP43+4		:
	S.HLTF(0263,STP43)		:
					:
REPOP	LIS	R0,0			:
	STH	R0,QUANTUM,R1		:TIMEOUT USER, SO HE WON'T RUN 'TIL NEXT TIME
	L	R4,RPSW+4,R1		:USER LOCATION COUNTER
	SIS	R4,4			:BACK UP FULLWORD
	LR	R12,R4			:PREPARE FOR ADDR TRANSLATION
	LHL	R13,RPSW+2,R1		:EXAMINE PSW
	JAL	R11,ACCESS		:CALC PHYSICAL ADDR OF INSTRUCTION
	J	STOP43			:IMPOSSIBLE...CRASH AND BURN
	LHL	R5,0,R12		:CHECK IF SVC WAS RX3 TYPE
	NHI	R5,0F000		:ISOLATE FIRST HEX DIGIT
	CLHI	R5,4000			:IF RX3 THIS IS 2ND HALFWORD
	JNFS	REPOP1			:NOT RX3
	SIS	R4,2			:BACKUP HALFWORD FOR RX3
REPOP1	ST	R4,RPSW+4,R1		:SAVE ADJUSTED LOCATION COUNTER
	J	KRET1			:SKIP TO FINISH CLEAN-UP
					:
:	....................................................................
:	RETURN TO USER CODE
:	....................................................................
					:
KSKIP	LIS	R15,4			:SET UP SKIP(^1) RETURN
	AM	R15,RPSW+4,R1		:
KRET	LH	R15,SLICE		:HAS TIME-SLICE EXPIRED WHILE WITHIN KERNEL?
	JL	USTRT,R1		:NO...RETURN TO USER
KRET1	LH	R0,XWAKE,R1		:YES...IS WAKE-UP IN PROGRESS?
	JGE	KRET2			:NO...SKIP
	LH	R0,WAKE,R1		:YES...HAS HE TIMED OUT?
	JN	KRET2			:NO...WAIT TILL LATER
	L	R4,XWAKE,R1		:GET WAKEUP BLOCK ADDRESS
	LM	R12,RPSW,R1		:MOVE HIS REGS
	STM	R12,0,R4		:
	LIS	R4,0			:
	ST	R4,XWAKE,R1		:
	L	R14,INIPSW,R1		:
	L	R15,WAKETR,R1		:
	STM	R14,RPSW,R1		:HE WILL TRAP ON NEXT TIMESLICE
 if	SPAM				:
KRET2	EQ	.			:
  if	SPMTRC				:
	LIS	R10,5			:SPAM TRACE ROUTINE ID
  ei	(SPMTRC)			:
	JAL	R9,ENTIM		:GET ENDING DATA
	LPSW	MAINPSD			:JUST GO BACK TO MAIN LOOP
 else					:
KRET2	LPSW	MAINPSD			:JUST GO BACK TO MAIN LOOP
 ei	(SPAM)				:
					:
:	....................................................................
:	ISIS KERNEL TIMEOUT INTERRUPT
:	....................................................................
					:
KTOUT	THI	0,400			:*0*IS MAC BIT ON?
	JN	TOUT1			:*0*YES...KERNEL NOT RUNNING
	CLI	1,LKER			:*0*LOW ADDRESS OF KERNEL
	JL	TOUT1			:*0*NOT IN KERNEL
	CLI	1,LOWDDT		:*0*HIGH ADDRESS OF KERNEL
	JG	TOUT1			:*0*OUTSIDE KERNEL
	LPSWR	0			:*0*INSIDE KERNEL...KRET WILL CATCH
					:   CATCH IT WHEN KERNEL EXITS
TOUT1	L	8,USER			:*0*SAVE OLD PSW
	ST	0,RPSW,8		:*0*
	ST	1,RPSW+4,8		:*0*
	LH	1,XWAKE,8		:*0*IS WAKE-UP IN PROGRESS?
	JL	WAKEUP			:*0*ALTERNATE EXIT IF SO
	LA	1,UDMS,8		:*0*
	LHI	0,I.ENA!20F0		:*0*
	LPSWR	0			:*0*ENABLE INTERRUPTS, REG SET 0F
					:

	SUBTTL	INDIVIDUAL SVC HANDLERS

:	****	GIVE UP TIME SLICE (RETURN TO MAIN)	****


:	....................................................................
:	SVC 0, SLOW GIVE UP
:	....................................................................
					:
S.GUP	L	8,USER			:*0*SAVE OLD PSW
	STM	0E,RPSW,8		:*0*IN USER BLOCK
	LH	0B,XWAKE,8		:*0*CHECK IF "WAKE-UP" IN PROGRESS
	JL	WAKEUP			:*0*ALTERNATE EXIT IF SO
	LHI	0E,I.ENA!20F0		:*0*
	LHR	0D,0D			:*0*CHECK USER DATA ADDR FOR
	JNFS	S.GUP1			:*0*DISMISS OPTIONS IF NONZERO
  IF	WFROG				:ONLY IF WATCHFROG TIMER IS ENABLED
   if	\HI.FRG				:
	L	0B,SLOWC		:*0*UPDATE WATCHFROG TIMER
	AHI	0B,WFTIME		:
	ST	0B,WFROGD,R8		:
   ei  (HI.FRG)				:
  EI   (WFROG)				:
	STH	0D,QUANTUM,8		:*0*GIVE UP REMAINING QUANTUM
	LA	0F,UDMS,8		:*0*CALC ADDR FOR REGISTER SAVE
	LPSWR	0E			:*0*ENABLE INTS, REG SET 0F
					:
S.GUP1	STH	0D,F1ARG		:*0*SAVE ARGUMENT
	EPSR	0F,0E			:*0*ENABLE INTS, REG SET 0F
	ST	R1,F1R1			:SAVE REG 1
	L	R1,USER			:ADDR OF CURRENT USER BLK
	STM	R0,RREG,R1		:SAVE REGS 0-0F
	L	R15,F1R1		:THEN 1
	ST	R15,RREG+4,R1		:
	LHL	R5,F1ARG		:RETRIEVE ARG
	LR	R6,R5			:COPY ARG
	LH	R4,WFLAG,R1		:GET WAIT FLAG
	OHI	R4,FTIM			:SET TIMEOUT FLAG
	STH	R4,WFLAG,R1		:SAVE IN USER BLOCK
	LH	R4,UFLAG,R1		:GET USER FLAG
	THI	R4,FQUASI		:IF FOREGROUND DISMISS
	JNFS	S.GUP2			:ARG IN TICKS IF SO - JUMP
	LIS	R4,0			:
	STH	R4,QUANTUM,R1		:GIVE UP REMAINING QUANTUM
	LR	R5,R5			:
	JEFS	S.GUP2			:
	LHI	R6,RATE			:
	MHR	R5,R6			:Convert seconds to ticks
	LR	R6,R5			:Copy ticks for WFROG
S.GUP2	A	R5,FASTC		:FOREGROUND...SET TIMEOUT TIME
	ST	R5,UTIME,R1		:
	SRL	R6,RDIV			:DIVIDE BY APROX. RATE
  IF	WFROG				:
	L	R7,WFROGT,R1		:GET SVC WFROG TIMER
	JLFS	S.GUP4			:SKIP IF INACTIVE
	AR	R7,R6			:ADD IN ARG
	ST	R7,WFROGT,R1		:UPDATE TIMER
  EI   (WFROG)				:
S.GUP4	HS	0			:
  IF	WFROG				:
   if	\HI.FRG				:
	A	R6,SLOWC		:ADD ARG TO SLOWC
	AHI	R6,WFTIME		:INCLUDE FROG TIME
	ST	R6,WFROGD,R1		:UPDATE WFROG TIMER
   ei  (HI.FRG)				:
  EI   (WFROG)				:
 if	SPAM				:
  if	SPMTRC				:
	LIS	R10,2			:SPAM TRACE ROUTINE ID
  ei	(SPMTRC)			:
	JAL	R9,ENTIM		:
 ei	(SPAM)				:
	LPSW	MAINPSD			:
					:

					:
:	....................................................................
:	SVC 7, (SLOW DISMISS/GIVE UP TIME SLICE IN TICKS AND RETURN TO MAIN)
:	....................................................................
					:
T.GUP	L	8,USER			:*0*GET ADDRESS OF USER BLOCK
	STM	0E,RPSW,8		:*0*SAVE OLD PSW INTO USER BLOCK
	LH	0B,XWAKE,8		:*0*CHECK IF "WAKE-UP" IN PROGRESS?
	JL	WAKEUP			:*0*ALTERNATE EXITS IF SO
	LHI	0E,I.ENA!20F0		:*0*CHECK IF USER DATA ADDR FOR
	LHR	0D,0D			:*Check User data address for
	JNFS	T.GUP1			:*0*DISMISS OPTIONS IS NONZERO
  IF	WFROG				:ONLY IF WATCHFROG TIMER IS ENABLED
   IF  \HI.FRG				:
	L	0B,SLOWC		:GET THE CURRENT SLOWC
	AHI	0B,WFTIME		:UPDATE WATCHFROG TIMER
	ST	0B,WFROGD,R8		:
   EI  (HI.FRG)				:
  EI   (WFROG)				:
	STH	0D,QUANTUM,R8		:GIVE UP REMAINING QUANTUM
	LA	0F,UDMS,R8		:CALCULATE ADDR FOR REGISTER SAVE
	LPSWR	0E			:ENABLE INTERRUPTS, REGISTER SET 0F
T.GUP1	STH	0D,F1ARG		:SAVE ARGUMENTS
	EPSR	0F,0E			:ENABLE INTERRUPTS, REGISTER SET 0F
	ST	R1,F1R1			:SAVE REGISTER 1
	L	R1,USER			:GET ADDRESS OF CURRENT USER BLOCK
	STM	R0,RREG,R1		:SAVE USER REGISTER 0-0F
	L	R15,F1R1		:GET CONTENTS OF R1
	ST	R15,RREG+4,R1		:SAVE R1
	LHL	R5,F1ARG		:RETRIEVE THE ARGUMENT
	LR	R6,R5			:MAKE A COPY OF R5
	LH	R4,WFLAG,R1		:GET THE WAIT FLAG
	OHI	R4,FTIM			:SET TIME-OUT FLAG
	STH	R4,WFLAG,R1		:SAVE IT INTO USER BLOCK
	A	R5,FASTC		:SET TIMEOUT TIME VALUE (IN TICKS)
	ST	R5,UTIME,R1		:SAVE IT INTO USER BLOCK
	LIS	R4,0			:RESET TIME SLICE
	STH	R4,QUANTUM,R1		:GIVE UP THE REMAINING QUANTUM
	SRL	R6,RDIV			:DIVIDE BY APPROXIMATE RATE
  IF	WFROG				:ONLY IF WATCHFROG TIMER IS ENABLED
	L	R7,WFROGT,R1		:GET SVC WATCHFROG TIMER
	JLFS	T.GUP4			:JUST SKIP IT IS INACTIVE
	AR	R7,R6			:ADD IN ARGUMENT
	ST	R7,WFROGT,R1		:UPDATE WATCHFROG TIMER
  EI   (WFROG)				:
T.GUP4					:
  IF	WFROG				:ONLY WATCHFROG TIMER IS ENABLED
   IF  \HI.FRG				:
	A	R6,SLOWC		:ADD THE CURRENT SLOWC
	AHI	R6,WFTIME		:ALSO INCLUDE THE CURRENT FROG TIME
	ST	R6,WFROGD,R1		:UPDATE WATCHFROG TIMER AGAIN
   EI  (HI.FRG)				:
  EI   (WFROG)				:
  IF	SPAM				:
   IF	SPMTRC				:
	LHI	R10,22			:GET SPAM TRACE ROUTINE ID
   EI  (SPMTRC)				:
	JAL	R9,ENTIM		:
  EI   (SPAM)				:
	LPSW	MAINPSD			:
					:
:	....................................................................
:	SVC 1, (FAST DISMISS/GIVE UP)
:	....................................................................
					:
F.GUP	L	8,USER			:*0*SAVE OLD PSW
	STM	0E,RPSW,8		:*0*IN USER BLOCK
	LH	0D,XWAKE,8		:*0*CHECK WAKE-UP TIMER
	JL	WAKEUP			:*0*SKIP IF WAKE-UP IN PROGRESS
  IF	WFROG				:
   if	\HI.FRG				:
	L	0B,SLOWC		:*0*UPDATE WATCHFROG TIMER
	AHI	0B,WFTIME		:
	ST	0B,WFROGD,R8		:
   ei  (HI.FRG)				:
  EI   (WFROG)				:
	STH	0D,QUANTUM,8		:*0*GIVE UP REMAINING QUANTUM
	LHI	0D,FNOREG		:*0*
	OH	0D,UFLAG,8		:*0*TURN ON "FNOREG" BIT
	STH	0D,UFLAG,8		:
 if	SPAM				:
  if	SPMTRC				:
	LIS	R10,1			:SPAM TRACE ROUTINE ID
  ei	(SPMTRC)			:
	LR	R1,R8			:
	JAL	R9,ENTIM		:GET USER DISMISS DATA
 ei	(SPAM)				:
	LPSW	MAINPSD			:*0*RE-ENTER MAIN LOOP
					:
:	....................................................................
:	SERVICE "WAKE-UP" TRAP
:	....................................................................
					:
WAKEUP	LH	0,WAKE,8		:*0*HAS HE TIMED OUT?
	JN	WAKE2			:*0*NO...JUST GO CLEAN UP
WAKE1	L	1,XWAKE,8		:*0*GET WAKEUP BLOCK ADDRESS
	LM	0C,RPSW,8		:*0*MOVE HIS REGS
	STM	0C,0,1			:*0*
	LIS	1,0			:*0*
	ST	1,XWAKE,8		:*0*
	L	0E,INIPSW,8		:*0*
	L	0F,WAKETR,8		:*0*
	STM	0E,RPSW,8		:*0*HE WILL TRAP ON NEXT TIMESLICE
WAKE2	LA	0F,UDMS,8		:*0*SAVE REGISTERS
	LHI	0E,I.ENA!20F0		:*0*
  IF	WFROG				:
   if	\HI.FRG				:
	L	0B,SLOWC		:*0*UPDATE WATCHFROG TIMER
	AHI	0B,WFTIME		:
	ST	0B,WFROGD,R8		:
   ei  (HI.FRG)				:
  EI   (WFROG)				:
	LPSWR	0E			:*0*GO TO SAVE REGISTERS
					:

	SUBTTL	****	(SVC 2,OP) SYSTEM SVC	****
					:
SYS.S	LHL	R11,F1ARGL		:GET SYSCALL #
	SLHLS	R11,2			:MAKE A WORD INDEX
	CLHI	R11,N.SYS		:RANGE CHECK
	JL	SYS.T,R11		:OK...GO TO APPROPRIATE ROUTINE
	J	NOTI			:OUT OF RANGE...ILLEGAL INSTRUCTION
					:
SYS.T	J	RESTART			:CALL 0		RESTART
	J	CQJ			:CALL 1		CONNECT FOREGROUND JOB
	J	ONDBG			:CALL 2		TURN ON DEBUG MODE
	J	OFFDBG			:CALL 3		TURN OFF DEBUG MODE
	J	TSTDBG			:CALL 4		TEST DEBUG MODE
	J	ONFRZ			:CALL 5		FREEZE BACKGROUND & FOREGROUND
	J	OFFFRZ			:CALL 6		THAW BACKGROUND & FOREGROUND
	J	TSTFRZ			:CALL 7		TEST FREEZE STATE
	J	RDR			:CALL 8		READ DDT REGISTER
	J	RDP			:CALL 9		READ DDT PSW
	J	RBR			:CALL 10d	READ BACKGROUND REGISTER
	J	RBP			:CALL 11d	READ BACKGROUND PSW
	J	RFR			:CALL 12d	READ FOREGROUND REGISTER
	J	RFP			:CALL 13d	READ FOREGROUND PSW
	J	RDM			:CALL 14d	READ DDT MAC
	J	RBM			:CALL 15d	READ BACKGROUND MAC
	J	RFM			:CALL 16d	READ FOREGROUND MAC
	J	S.1MAC			:CALL 17d	SET 1 MAC SEGMENT
	J	S.MAC			:CALL 18d	SET COLLECTION OF MAC SEGMENTS
	J	SBEA			:CALL 19d	SET BACKGROUND EXECUTION ADDRESS
	J	SFEA			:CALL 20d	SET FOREGROUND EXECUTION ADDRESS
	J	LMAC			:CALL 21d	LOAD MAC FROM CONTROL TABLE
 if	SUP				:
	J	SU.CKF			:CALL 22d	CHECK SUP FREEZE STATE
	J	SU.CKR			:CALL 23d	CHECK SUP RUN-QUEUE STATE
	J	SU.FRZ			:CALL 24d	FREEZE THE SUPERVISOR
	J	SU.THW			:CALL 25d	THAW THE SUPERVISOR
 else					:
	J	NOTI			:CALL 22d	CHECK SUP...NOT IMPLEMENTED
	J	NOTI			:CALL 23d	CHECK SUP...NOT IMPLEMENTED
	J	NOTI			:CALL 24d	FREEZE SUP...NOT IMPLEMENTED
	J	NOTI			:CALL 25d	THAW SUP...NOT IMPLEMENTED
 ei	(SUP)				:
	J	ALARM			:CALL 26d	SET ALARM
	J	RSCLOK			:CALL 27d	READ SUPER-CLOCK
	J	CORTIM			:CALL 28d	CORRECT SUPER-CLOCK
	J	SUDIAG			:CALL 29d	SET USER DIAGNOSTIC
	J	UCORE			:CALL 30d	LOCATE STORAGE PARAMETERS
	J	DBFRZ			:CALL 31d	SUPER-FREEZE (SLOT-TO-SLOT)
	J	HALT			:CALL 32d	HALT THE SLOT
	J	DBHLT			:CALL 33D	HALT ANY JOB
	J	SVSPY			:CALL 34D	START/STOP SPY
	J	DISCON			:CALL 35D	DISCONNECT LOGICAL UNIT
 IF	KIOSRC				:
	J	NOTI			:
	J	NOTI			:
 ELSE					:
	J	KLOG			:CALL 36D	CONNECT RING TO KERNEL
	J	KZAP			:CALL 37D	DISCONNECT RING TO KERNEL
 EI    (KIOSRC)				:
 if	FSYS				:
	J	VREST			:CALL 38D	VARIANT RESTART
 else					:
	J	NOTI			:CALL 38D	NOT IMPLIMENTED
 ei    (FSYS)				:
	J	PBOOT			:CALL 39D	PUT MACHINE IN BOOT
 if	KIOSRC				:
	J	NOTI			:
 else					:
	J	SETDIS			:CALL 40D	SET NIBBLE OF DISPLAY
 ei    (KIOSRC)				:
	J	RSBLOK			:CALL 41D	DISCONNECT MACS IN USER
	J	CHNMAC			:CALL 42D	CHANGE CONTENTS OF MAC
	J	SUSPEN			:CALL 43D	SUSPEND SLOT
	J	RESUM			:CALL 44D	RESUME SLOT
 if	NSLOT				:SPAM FIX 9/23/86
	J	DSPINF			:CALL 45D	GET DISPATCHER INFO
 else					:
	J	NOTI			:
 ei    (NSLOT)				:
	J	SUSGRP			:CALL 46D	REPORT SUSPEND GROUP
 if	WFROG				:
	J	W.FROG			:CALL 47D	WATCHFROG TIMER
 else					:
	J	NOTI			:
 ei    (WFROG)				:
 if	MXP				:
	J	CONBIO			:CALL 48D	CONNECT BIO RING
 else					:
	J	NOTI			:CALL 48D	CNCT BIO RING (NOT IMP)
 ei    (MXP)				:
 if	IPNMBR				:
	J	XLVADR			:CALL 49D	XLATE VIRT. ADDR
	J	SINTIP			:CALL 50D	SLOT INTRRPT OF IPI
 else					:
	J	NOTI			:CALL 49D	XLATE ADDR--NOT IMPLEMNTD
	J	NOTI			:CALL 50D	INRPTR IPI--NOT IMPLMNTD
 ei    (IPNMBR)				:
	J	RUNSLT			:CALL 51D	EXECUTE SLOT
	J	CRASLT			:CALL 52D	CONTINUE SLOT CRASH
	J	INICPS			:CALL 53D	INIT CODE CPS ADDRESS
	J	NOTI			:CALL 54D	RESERVED FOR TURBO
	J	NOTI			:CALL 55D	RESERVED FOR TURBO
	J	NOTI			:CALL 56D	RESERVED FOR TURBO
 if	MULTI				:
	J	SGRNSL			:CALL 57D	SUPERVISOR RING INFO.
 else					:
	J	NOTI			:CALL 57D	NOT IMPLEMENTED
 ei    (MULTI)				:
	J	NOTI			:CALL 58D	Not implemented
 if	KIOSRC				:
	J	INSIOR			:CALL 59D	INITIALIZE SIO RING
 else					:
	J	NOTI			:CALL 59D	NOT IMPLEMENTED
 ei    (KIOSRC)				:
N.SYS	EQ	.-SYS.T			:SIZE OF TABLE
					:
					:
:	....................................................................
:	SVC SYS, OP = 0 ( RESTART SVC...RE-ENABLE CRASHING)
:	SKIP RETURN IF SUCCESSFUL
:	....................................................................
					:
RESTART	HS	0			:
:
: this code will crash a slot that crashes/restarts more than 5d times in 
: 10 minutes. it can be restarted with new counting via ddt (?dash)
:
	lh	r4,sltddt		:ddt flag for enable/disable
	je	sltinz			
	lh	r4,slot,r1		:slot #
	jl	sltinz			:skip on ff
	slls	r4,3			:index on slot
	l	r12,sltinf+2,r4		:get count
	je	sltin2			:new restart
	l	r12,slowc		:ticker
	s	r12,sltinf+4,r4		:time of last
	cli	r12,$a 600		:10 min elapsed
	jg	sltin2			:restart
	lh	r12,sltinf+2,r4		:get latest count
	clhi	r12,7			:crash on > 6 in 600 sec
	jgefs	sltin1			:crash it
	ais	r12,1			:increment count
	sth	r12,sltinf+2,r4		:save it
	j	sltinz			:continue
sltin1	lis	r12,0
	sth	r12,sltinf+2,r4		:reset count
:	j	krashk			:crash with no restart	
	lr	r4,r4			
	jefs	sltinx
	st	r12,rest,r1		:clear restart address
	j	kskip			:return
sltinx	s.hlti(0455)			:crash on node code
:
: get here on first time crash or exceeds time frame and restart count
:
sltin2	lis	r12,1
	sth	r12,sltinf+2,r4		:set count
	l	r12,slowc
	st	r12,sltinf+4,r4		:store slowc
sltinz	eq	.
:
	LHL	R4,UFLAG,R1		:CHECK USER
	THI	R4,FBACK		:SVC LEGAL ONLY FROM BACKGROUND JOB
	JE	NOTI			:
	LR	R5,R0			:USER'S RESTART ADDR
	JEFS	RESTA1			:JUST REQUEST TO TURN OFF F1CRAS
	LR	R12,R5			:COPY USER ADDR
	LHL	R13,F1PS1+2		:GET PSW
	JAL	R11,ACCESS		:VERIFY ACCESS
	J	KRET			:BAD ACCESS - NON SKIP RETURN
	ST	R5,REST,R1		:SAVE RESTART ADDR IN USER BLOCK
RESTA1	THI	R4,F1CRAS		:HAS HE CRASHED ONCE ALREADY?
	JNFS	RESTA2			:YES...PROCEED
	JAL	R11,FNDDDT		:GET DDT USER BLOCK
	LHI	R5,0A^2			:
	STH	R5,EFLAG,R4		:SET CODE A - USER CRASH
	LHL	R4,UFLAG,R1		:
	THI	R4,FDEBUG		:NO...IMPLIED INTERNAL CRASH...
	JN	ONFRZ			:...IF IN DEBUG NODE, CAUSE ENOUGH TO FREEZE HIM
RESTA2	L	R5,OTHER,R1		:CHECK FOR ASSOCIATED FOREGROUND JOB
	JEFS	RESTA3			:SKIP IF NONE
	LR	R1,R5			:ELSE SHUT DOWN HIS FOREGROUND
	JAL	R11,FDISC		:
	L	R1,USER			:RESTORE REGISTERS
RESTA3	JAL	R11,DCDEV		:DISCONNECT DEVICES
	LHL	R4,SLOT,R1		:
	JAL	R11,DCKIO		:DISCONNECT KIO PORT CREATIONS
	L	R1,USER			:
	LHL	R4,UFLAG,R1		:
	NHI	R4,@F1CRAS		:CLEAR CRASHED-ONCE FLAG
	THI	R4,FDISP		:IS THIS A DISPATCHER JOB?
	JNFS	RESTA4			:IF SO, PROCEED
	STH	R4,UFLAG,R1		:SAVE USER FLAG
	J	KSKIP			:SKIP RETURN
RESTA4	LHI	R11,20F0		:DISPATCHER JOB...DISABLE INTERRUPTS
	EPSR	R5,R11			:
   if	NSLOT!MXP			:
	JAL	R11,D.ENAB		:ENABLE DISPATCHER
   ei  (NSLOT!MXP)			:
	STH	R4,UFLAG,R1		:SAVE USER FLAG
	LIS	R5,4			:
	AM	R5,RPSW+4,R1		:SET UP SKIP RETURN TO USER
	LH	R4,WFLAG,R1		:GET WAIT FLAG
   IF	ENHMXP				:
	OHI	R4,XPIWF		:DEFINITELY WAIT FOR MXP DISPATCHER
   EI  (ENHMXP)				:
	OHI	R4,FTIM			:SET TIMEOUT FLAG...(ENTRY FROM RESTART SVC)
	STH	R4,WFLAG,R1		:SAVE IN USER BLOCK
	LIS	R4,0			:
	STH	R4,QUANTUM,R1		:GIVE UP REMAINING QUANTUM
	LHI	R5,4*RATE		:ADVANCE 4 SECONDS
	A	R5,FASTC		:
	ST	R5,UTIME,R1		:
	LHL	R4,SLOT,R1		:GENERATE DIAGNOSTIC
	LA	R5,RESTAM		:
  IF	WFROG				:ONLY IF WATCHFROG TIMER IS ENABLED
	L	R11,WFROGT,R1		:KILL ANY WATCH-FROGS
	AIS	R11,2			:
	JLFS	RESTA9			:
	LCS	R11,1			:
	ST	R11,WFROGT,R1		:
  EI   (WFROG)				:
RESTA9	HS	0			:
  IF	WFROG				:
   IF  \HI.FRG				:
	L	R11,SLOWC		:
	AIS	R11,0F			:WAIT 15 SECONDS
	ST	R11,WFROGD,R1		:
   EI  (HI.FRG)				:
  EI   (WFROG)				:
	LHI	R11,62F0		:Re-enable interrupts
	EPSR	R6,R11			:
	JAL	R11,SETDIAG		:
 if	SPAM				:
  if	SPMTRC				:
	LIS	R10,0B			:SPAM TRACE ROUTINE ID
  ei   (SPMTRC)				:
	JAL	R9,ENTIM		:COLLECT ENDING DATA
 ei    (SPAM)				:
	LPSW	MAINPSD			:
RESTAM	SC	/Restarted/		:
:
	bnd	4
sltinf	eq	.
q	eq	0
	re	nslot+1
zslt|q|	eq	q			:set equate
	hc	zslt|q|			:slot #
	hc	0			:restart #
	wc	0			:slowc
q	eq	q+1
	er
sltddt	hc	1			:enable on ddt flag


:	.......................................................................
:	****	OP=1:	CONNECT FOREGROUND JOB	  ****
:	.......................................................................
					:
CQJ	LHL	R4,UFLAG,R1		:CHECK TYPE OF JOB MAKING REQUEST
	THI	R4,FBACK		:
	JE	NOTI			:REQUEST VALID ONLY FROM BACKROUND JOB
	L	R4,OTHER,R1		:OK...GET POINTER TO FOREGROUND-BLOCK FOR THIS JOB
	JE	KRET			:NORMAL RETURN IF NO FOREGROUND
	LR	R1,R4			:THIS JOB HAS ONE...SEARCH QUASI-LIST FOR IT
	JAL	R11,FDISC		:LOOK FOR THIS FG JOB IN QUASI LIST
	LR	R4,R1			:POINTER TO QUASI BACK TO (R4)
	L	R1,USER			:NOW BACK TO THE ORIGINAL JOB BLOCK
	LCS	R5,1			:INDICATE FG TURNED OFF
	ST	R5,RPSW+4,R4		:
	LR	R5,R0			:NOW GET THE ARGUMENT (FG START ADDR)
	JE	KRET			:0 MEANS TURN OFF QUASI CODE
	ST	R5,RPSW+4,R4		:ELSE SET START ADDRESS
					:
   if	MULMAC				:INIT MULTIPLE MAC SET MAC
	LIS	R5,0			:
	STH	R5,CCOUNT,R4		:START WITH ZERO COUNT
	STB	R5,MACSET+1,R4		:MAC SET ZERO
   ei  (MULMAC)
	LA	R5,MPROT+3E,R4		:START FOR COPYING MPROT
	ST	R5,MACTRN,R4		:
	LIS	R5,0			:INSURE NO WAIT BITS ARE ON
	STH	R5,WFLAG,R4
	L	R5,FASTC		:GET START TIME (NOW)
	ST	R5,UTIME,R4		:THAT IS WHEN TO RUN THE JOB
	L	R5,QUASI		:R11 THIS JOB INTO QUASI
	ST	R5,LLINK,R4		:
	ST	R4,QUASI		:
  IF	WFROG				:
   if  \HI.FRG				:
:	....................................................................
:	IF THIS SLOT HAS A DISMISS DRIVEN WATCHFROG TIMER, ACTIVATE
:	IT IN THE FG USER BLOCK
:	....................................................................
					:
	L	R5,SLOWC		:
	AHI	R5,WFTIME		:
	ST	R5,WFROGD,R4		:ACTIVATE THE TIMER
   ei  (HI.FRG)				:
  EI   (WFROG)				:
	J	KRET			:AND RETURN
					:


:	****	OP=2:	TURN ON DEBUG MODE	****
ONDBG	JAL	R11,FNDDDT		:FIND CONTROLLING DDT
	LHI	R0,FDEBUG
	LR	R5,R0
	OH	R5,UFLAG,R4
	STH	R5,UFLAG,R4		:SET FOR DDT
 if	SPAM
  if	SPMTRC
	LHI	R10,13			:SPAM TRACE ROUTINE ID
  ei	(SPMTRC)
	LR	R1,R4
	JAL	R9,ENTIM		:COLLECT USER DATA
 ei	(SPAM)
	L	R4,CONTROL,R4		:GET CONTROLLED JOB
	JE	MAIN			:IF NONE, EXIT
	LR	R5,R0			:MAKE A COPY
	OH	R5,UFLAG,R4		:TURN ON DEBUG MODE
	STH	R5,UFLAG,R4		:PLACE NEW FLAGS
	L	R4,OTHER,R4		:GET FOREGROUND TOO
	JE	MAIN			:IF NONE, EXIT
	OH	R0,UFLAG,R4		:TURN ON DEBUG MODE
	STH	R0,UFLAG,R4		:PLACE NEW FLAGS
	J	MAIN			:EXIT




:	****	OP=3:	TURN OFF DEBUG MODE	****
OFFDBG	JAL	R11,FNDDDT		:FIND CONTROLLING DDT
	LHI	R0,@FDEBUG
	LR	R5,R0
	NH	R5,UFLAG,R4
	STH	R5,UFLAG,R4		:SET FOR DDT
	L	R4,CONTROL,R4		:GET CONTROLLED JOB
	JE	KRET			:IF NONE, EXIT
	LR	R5,R0			:MAKE A COPY
	NH	R5,UFLAG,R4		:TURN OFF DEBUG MODE
	STH	R5,UFLAG,R4		:PLACE NEW FLAGS
	L	R4,OTHER,R4		:GET FOREGROUND TOO
	JE	KRET			:IF NONE, EXIT
	NH	R0,UFLAG,R4		:TURN OFF DEBUG MODE
	STH	R0,UFLAG,R4		:PLACE NEW FLAGS
	J	KRET			:EXIT



:	****	OP=4:	TEST DEBUG MODE	   ****
TSTDBG	LHI	R0,FDEBUG		:SET FLAG
	NH	R0,UFLAG,R1
	ST	R0,RREG,R1		:SET STATE INTO USER'S R0
	J	KRET			:AND EXIT



:	****	OP=5:	TURN ON FREEZE	  ****
:	(ALSO LINKED TO VIA "DBFRZ")
ONFRZ	JAL	R11,FNDDDT		:FIND CONTROLLING DDT
	LHI	R0,8^2			:CODE 8 - SVC
	STH	R0,EFLAG,R4
ONFRZ1	JAL	R11,FNDDDT		:FIND CONTROLLING DDT
	LHL	R0,UFLAG,R1		:CHECK FOR REQUEST FROM FOREGROUND
	NHI	R0,FQUASI
	JNFS	ONFRZ2			:SKIP THOSE
	STH	R0,QUANTUM,R1		:ALL OTHERS, CANCEL CURRENT TIMESLICE
ONFRZ2	LHI	R0,FREEZE
SYS.ON	L	R4,CONTROL,R4		:GET CONTROLLED JOB
	JE	FRZXIT			:QUIT IF NONE SPECIFIED
	LR	R5,R0
	OH	R5,WFLAG,R4
	STH	R5,WFLAG,R4
	L	R4,OTHER,R4		:GET FOREGROUND TOO
	JE	FRZXIT			:QUIT IF NONE
	OH	R0,WFLAG,R4
	STH	R0,WFLAG,R4
FRZXIT	EQ	.
 if	SPAM
  if	SPMTRC
	LHI	R10,14			:SPAM TRACE ROUTINE ID
  ei	(SPMTRC)
	JAL	R9,ENTIM		:COLLECT USER DATA
 ei	(SPAM)
	J	MAIN			:AND ABORT THIS TIMESLICE, IN CASE FROZE SELF



:	****	OP=6:	TURN OFF FREEZE	   ****
OFFFRZ	JAL	R11,FNDDDT		:FIND CONTROLLING DDT
	LHI	R0,8^2
	STH	R0,EFLAG,R4		:CODE 8 - SVC
	LHI	R0,@FREEZE
SYS.OFF	L	R4,CONTROL,R4		:GET CONTROLLED JOB
	JE	KRET			:EXIT IF NONE SPECIFIED
	LR	R5,R0
	NH	R5,WFLAG,R4
	STH	R5,WFLAG,R4
	L	R4,OTHER,R4		:GET FOREGROUND TOO
	JE	KRET			:EXIT IF NONE
	NH	R0,WFLAG,R4
	STH	R0,WFLAG,R4
	J	KRET			:AND EXIT



:	****	OP=7:	TEST FREEZE	****
TSTFRZ	JAL	R11,FNDDDT		:WHO'S ASKING?
	L	R5,CONTROL,R1		:GET POINTER TO JOB
	LH	R0,WFLAG,R5
	NHI	R0,FREEZE		:TEST IF IN FREEZE STATE
	JEFS	TEST.F			:SKIP IF NOT
	LH	R0,EFLAG,R4		:ELSE GET ERROR CODE
TEST.F	ST	R0,RREG,R1		:SET STATE INTO USER'S R0
	J	KRET			:AND EXIT



:	****	OP=8:	READ DDT REGISTER    ****
RDR	NHI	R0,0F			:MASK OFF
	SLHLS	R0,2			:MAKE WORD INDEX
	AHI	R0,URSA
	JFS	RDP1			:AND SKIP



:	****	OP=9:	READ DDT PSD	****
RDP	NHI	R0,1			:MASK OFF
	SLHLS	R0,2
	AHI	R0,OLDPSW
RDP1	JAL	R11,FNDDDT		:NOW LOCATE DDT
	J	RFP2			:AND SKIP TO PROCESS



:	****	OP=10:	READ BACKGROUND REGISTER    ****
RBR	NHI	R0,0F			:MASK OFF
	SLHLS	R0,2			:MAKE WORD INDEX
	AHI	R0,RREG
	JFS	RBP1			:AND SKIP



:	****	OP=11d:	READ BACKGROUND PSD	****
RBP	NHI	R0,1			:MASK OFF
	SLHLS	R0,2
	AHI	R0,RPSW
RBP1	JAL	R11,FNDDDT		:NOW LOCATE DDT
	L	R4,CONTROL,R4		:GET BASE OF BACKGROUND
	J	RFP2			:AND SKIP TO PROCESS



:	****	OP=12d:	READ FOREGROUND REGISTER    ****
RFR	NHI	R0,0F			:MASK OFF
	SLHLS	R0,2			:MAKE WORD INDEX
	AHI	R0,RREG
	JFS	RFP1



:	****	OP=13d:	READ FOREGROUND PSD	****
RFP	NHI	R0,1			:MASK OFF
	SLHLS	R0,2
	AHI	R0,RPSW
RFP1	JAL	R11,FNDDDT		:NOW LOCATE DDT
	L	R4,CONTROL,R4		:GET BASE OF BACKGROUND
	JE	KRET			:IGNOR IF NULL
	L	R4,OTHER,R4		:NOW GET ADDRESS OF FOREGROUND BLOCK
RFP2	JE	KRET			:ABORT IF NULL
	AR	R4,R0			:ELSE MAKE OFFSET INTO BLOCK
	L	R0,0,R4			:GET THE VALUE
	ST	R0,RREG,R1		:RETURN TO CALLER
	J	KRET			:AND EXIT



:	****	OP=14d:	READ DDT MAC	****
RDM	JAL	R11,FNDDDT		:FIND THE DDT BLOCK
	JFS	RFM1			:AND SKIP



:	****	OP=15d:	READ BACKGROUND MAC	****
RBM	JAL	R11,FNDDDT		:FIND DDT
	L	R4,CONTROL,R4
	JFS	RFM1			:AND SKIP



:	****	OP=16d:	READ FOREGROUND MAC	****
RFM	JAL	R11,FNDDDT		:FIND DDT
	L	R4,CONTROL,R4		:
	JE	KRET			:
	L	R4,OTHER,R4		:NOW GET FOREGROUND
RFM1	JE	KRET			:
	LIS	R5,0F			:
	NR	R5,R0			:
	CLHI	R5,0F			:
	JNFS	RFM2			:SKIP IF NOT SEGMENT 15d
	LI	R0,CONMAC		:ELSE SET UP CONSTANT AREA MAC
	JFS	RFM3			:AND SKIP
RFM2	SLHLS	R5,2			:MAKE WORD ADDRESS
	L	R0,MPROT,R4,R5		:GET THE REGISTER
RFM3	HS	0			:
	ST	R0,RREG,R1		:SAVE THE VALUE
	J	KRET			:AND RETURN
					:
:	....................................................................
:	SVC SYS, OP = 17d (SET 1 MAC SEGMENT)
:	R0 CONTAINS <SEG #|PROT>
:	....................................................................
					:
S.1MAC	LHL	R4,STAMAC,R1		:THIS IS NOT VALID IF USING EXTENDE
	JN	NOTI			:MAC
	EXHR	R4,R0			:FETCH SEGMENT NUMBER
	LHR	R4,R4			:
	CLHI	R4,$A 13		:RANGE CHECK
	JG	NOTI			:UNIMPLEMENTED SVC IF >13d.
	SLHLS	R4,2			:ELSE MAKE WORD ADDRESS
	LR	R5,R0			:COPY PROTECTION SPECIFIED
	JAL	R11,SETPROT		:SET UP THE PROTECTION REQUESTED
	J	KRET			:AND EXIT
					:
:	....................................................................
:	SVC SYS, OP = 18d (SET COLLECTION OF MAC SEGMENTS)
:	R0 POINTS AT STRING...
:	a|b|c|d...STARTING AT SEGMENT a, FOR b SEGMENTS, SET PROTECTIONS c, 
:	d, ...
:	....................................................................
					:
S.MAC	LHL	R4,STAMAC,R1		:NOT VALID IF EXTENDED MAC IN USE
	JN	NOTI			:
	LR	R12,R0			:R0 CONTAINS ADDRESS OF STRING
	LHL	R13,F1PS1+2		:SET UP WITH PSW OF REQUESTOR
	JAL	R11,ACCESS		:TEST IT
	J	NOTI			:IF HE CAN'T GET TO IT, IT'S ILLEGAL
	LB	R4,0,R12		:OK...GET NUMBER OF FIRST SEGMENT
	CLHI	R4,$A 13		:
	JG	NOTI			:CAN'T BE > 13d
	LB	R5,1,R12		:GET SECOND BYTE...NUMBER TO DO
	LR	R6,R5			:
	AR	R5,R4			:
	CLHI	R5,$A14			:RANGE CHECK
	JG	NOTI			:
	SLHLS	R4,2			:OK...MAKE WORD ADDRESS
	LR	R7,R12			:COPY ADDRESS
S.MAC1	LB	R5,2,R7			:GET THE NEXT PROTECTION BYTE
	JAL	R11,SETPROT		:SET THE PROTECTION REQUESTED
	SIS	R6,1			:COUNT ANOTHER DONE
	JLE	KRET			:EXIT WHEN DONE
	AIS	R7,1			:ELSE DO ANOTHER
	AIS	R4,4			:
	JBS	S.MAC1			:
					:
:	....................................................................
:	SVC SYS, OP = 19d (SET BACKGROUND EXECUTION ADDRESS)
:	....................................................................
					:
SBEA	JAL	R11,FNDDDT		:LOCATE DDT
	L	R4,CONTROL,R4		:GET BASE OF BACKGROUND
	JFS	SFEA1			:AND SKIP TO PROCESS
					:
:	....................................................................
:	SVC SYS, OP = 20d (SET FOREGROUND EXECUTION ADDRESS)
:	....................................................................
					:
SFEA	JAL	R11,FNDDDT		:LOCATE DDT
	L	R4,CONTROL,R4		:GET BASE OF BACKGROUND
	JE	KRET			:IGNOR IF NULL
	L	R4,OTHER,R4		:NOW GET ADDRESS OF FOREGROUND BLOCK
SFEA1	JE	KRET			:ABORT IF NULL
	ST	R0,RPSW+4,R4		:SET NEW EXECUTION ADDRESS
	J	KRET			:AND EXIT
					:
:	....................................................................
:	SVC SYS, OP = 21d (LOAD MAC FROM CONTROL TABLE)
:	....................................................................
					:
LMAC	LHL	R0,RPSW+2,R1		:WE ARE REQUIRING UNMAC'ED AND PRIVELEGED
	THI	R0,0500			:
	JN	NOTI			:ALTERNATE IS NOT IMPLEMENTED
	JAL	R11,SETMAC		:GO DO IT
	J	KRET			:NORMAL RETURN IF FAILED
	J	 KSKIP			:SKIP   RETURN IF SUCCEEDED
					:
   IF	SUP				:
					:
:	....................................................................
:	SVC SYS, OP = 22d CHECK SUP FREEZE STATE)
:	....................................................................
					:
SU.CKF	LHI	R4,FREEZE		:SET MASK
	NH	R4,UBSUP+WFLAG,,	:CHECK SUP'S STATE
	JE	KRET			:NORMAL RETURN IF NOT FROZEN
	J	KSKIP			:ELSE SKIP RETURN
					:
:	.....................................................................
:
:	SVC SYS, OP = 23d (CHECK SUP RUN-QUEUE STATE)
:	NORMAL RETURN IF NOT IN RUN LIST
:	ELSE SKIP RETURN
:
:	.....................................................................
					:
SU.CKR	LA	R4,RUN			:START OF RUN LIST
SU.CR1	L	R4,LLINK,R4		:GET NEXT ENTRY ON RUN QUEUE
	JE	KRET			:NOT ON LIST...NORMAL RETURN
	CLI	R4,UBSUP		:IS THIS REQUIRED ENTRY?
	JNBS	SU.CR1			:NO...KEEP SCANNING
	L	R0,RPSW+4,R4		:GOT A MATCH...GET EXECUTION ADDRESS
	ST	R0,RREG,R1		:RETURN IT IN R0
	J	KSKIP			:DO A SKIP RETURN
					:
:	.....................................................................
:
:	SVC SYS, OP = 24d (FREEZE THE SUPERVISOR)
:
:	.....................................................................
					:
SU.FRZ	LCS	R10,1			:
	JFS	SU.TW1			:
					:
:	.....................................................................
:
:	SVC SYS, OP = 25d (THAW THE SUPERVISOR)
:	....................................................................
					:
SU.THW	LIS	R10,0			:
SU.TW1	LH	R4,SLOT,R1		:IS THIS SLOT 0?
	JE	SU.TW2			:YES...SKIP
	LHL	R4,UFLAG,R1		:NO...IS THIS A KIO OR DDT REQUEST?
	THI	R4,FDDT!FKIOJ		:
	JE	NOTI			:ANY ONE ELSE, UNIMPLEMENTED SVC!
	LHL	R4,GGNDX,R1		:FIND USER NAME USED TO RUN THIS JOB
	L	R4,GODGUY+GGNAME,R4,	:
	CLI	R4,0D0D2CFC2		:IS IT "PROBE"?
	JEFS	SU.TW2			:
   IF	PUBNET				:
	CLI	R4,0D3D0D2CF		:IS IT "SPROBE"?
   ELSE					:
	CLI	R4,0D2D0D2CF		:IS IT "RPROBE"?
   EI  (PUBNET)				:
	JN	NOTI			:UNIMPLEMENTED SVC FOR ANYONE ELSE!
SU.TW2	LA	R1,UBSUP,,		:
	JAL	R11,DCDEV		:DISCONNECT DEVICES
	LHL	R4,WFLAG,R1		:
	NHI	R4,@FTIM		:
	LR	R10,R10			:IS FREEZE ON?
	JE	SU.TW3			:SKIP IF NOT
	OHI	R4,FREEZE		:YES...SET FROZEN
	STH	R4,WFLAG,R1		:AND RESTORE IT
    if	KIOSRC				:
	L	R4,SUPDIS		:GET SUP CONSOLE PTR
	JE	SU.TW4			:IF NONE, SKIP
	LHL	R5,0,R4			:GET CURRENT DISPLAY
	NHI	R5,0FFF0		:SET TO FROZEN (3)
	OHI	R5,3			:
	STH	R5,0,R4			:
    ei (KIOSRC)				:
	J	SU.TW4			:AND SKIP
SU.TW3	LM	R14,INIPSW,R1		:
	STM	R14,RPSW,R1		:SET INITIAL STARTUP LOC
	LIS	R4,0			:
	STH	R4,WFLAG,R1		:ASSURE NOT SLEEPING
	LH	R4,UFLAG,R1		:GET USER FLAG
	OHI	R4,F1CRAS		:SET CRASHED-ONCE FLAG
	STH	R4,UFLAG,R1		:SET USER FLAGS
	JAL	R11,RDISC		:ASSURE NOT ON RUN LIST
	L	R0,RUN			:
	ST	R0,LLINK,R1		:PLACE ON RUN LIST
	ST	R1,RUN			:
SU.TW4	L	R1,USER			:RESTORE R1
	J	KRET			:
   EI	(SUP)				:
					:
:	....................................................................
:	SVC SYS, OP = 26d (SET ALARM)
:	....................................................................
					:
ALARM	L	R12,RREG,R1		:GET OPERANDS
	JNFS	ALARM1			:SKIP IF NOT NULL
	ST	R12,XWAKE,R1		:CANCEL IF = 0
	J	KSKIP			:AND SUCCESS RETURN
ALARM1	LA	R4,10,R12		:NOT NULL...SET TRAP ADDRESS
	ST	R4,WAKETR,R1		:SAVE TRAP ADDRESS
	EXHR	R4,R12			:EXTRACT TIME REQUIRED
	EXBR	R4,R4			:
	LBR	R4,R4			:
	LHL	R13,RPSW+2,R1		:NOW CHECK HIS PSW
	JAL	R11,ACCESS		:CHECK OUT ACCESS
	J	KRET			:FAILED...NORMAL RETURN
	OI	R12,80000000		:OK...SET FLAG FOR VALUE PRESENT
	ST	R12,XWAKE,R1		:AND SET TRAP-BLOCK ADDRESS
	LIS	R12,0			:
	SR	R12,R4			:COMPUTE -T
	AH	R4,SLICE		:CHECK TIME REMAINING FOR THIS SLICE
	JGE	ALARM2			:WE SHOULDN'T TIME OUT EARLY
	STH	R12,SLICE		:EARLY...SET NEW TIME
	LIS	R12,0			:
	AHM	R4,QUANTUM,R1		:GIVE HIM THAT TIME BACK
	LIS	R4,0			:AND SET TIME'S UP
ALARM2	STH	R4,WAKE,R1		:SET TIME HE HAS LEFT
	J	KSKIP			:AND SKIP EXIT
					:
:	....................................................................
:	SVC SYS, OP = 27d (READ SUPER-CLOCK)
:	....................................................................
					:
RSCLOK	LIS	R4,9			:DEVICE ADDRESS TO READ HIGH-16 BITS
	RDR	R4,R6			:READ HIGH-16 BITS OF CLOCK
	JT	4,KRET			:NORMAL RETURN IF NON-EXISTANT DEVICE
	LHI	R5,109			:DEVICE ADDRESS TO READ LOW-16 BITS
RSCLK1	STH	R6,RREG,R1		:SAVE HIGH-BITS
	RDR	R5,R7			:
	STH	R7,RREG+2,R1		:SAVE LOW BITS
	LR	R7,R6			:COPY HIGH-BITS
	RDR	R4,R6			:READ HIGH AGAIN
	XR	R7,R6			:TEST
	JNBS	RSCLK1			:RE-READ IF HIGH HAS CHANGED
	J	KSKIP			:ELSE SKIP RETURN
					:
:	....................................................................
:	SVC SYS, OP = 28d (CORRECT/RESET  SUPER CLOCK)
:	....................................................................
					:
 if	SUP				:
:	....................................................................
:	LEGAL ONLY FOR SUP,"PROBE", "RPROBE", OR "SPROBE"
:	....................................................................
					:
CORTIM	CLI	R1,UBSUP		:IS THIS SUP?
	JE	CORT1			:YES...SKIP
	LHL	R4,GGNDX,R1		:FIND USER NAME USED TO RUN THIS JOB
	L	R4,GODGUY+GGNAME,R4,	:
	CLI	R4,0D0D2CFC2		:IS IT "PROBE"?
	JEFS	CORT1			:YES,GO AHEAD
   IF	PUBNET				:
	CLI	R4,0D3D0D2CF		:IS IS "SPROBE"?
   ELSE					:
	CLI	R4,0D2D0D2CF		:IS IT "RPROBE"?
   EI  (PUBNET)				:
	JN	NOTI			:UNIMPLEMENTED SVC FOR ANYONE ELSE!
CORT1	HS	0			:
 else					:
:	....................................................................
:	LEGAL ONLY IF DDT USER WITH "L.SY" LICENCE
:	....................................................................
					:
CORTIM	LHL	R4,UFLAG,R1		:IS THIS DDT USER?
	THI	R4,FDDT			:
	JE	NOTI			:ELSE NOT IMPLEMENTED
	LHL	R4,ULICEN		:CHECK HIS LICENCE
	THI	R4,L.SYA		:
	JE	NOTI			:NOT IMPLEMENTED FOR EVERONE
 ei    (SUP)				:
	LHI	R4,209			:SET DEVICE ADDRESS FOR CORRECTION
	RDR	R4,R5			:CHECK DEVICE
	JT	4,KRET			:NORMAL RETURN IF NOT THERE
	J	KSKIP			:ELSE SKIP RETURN
					:
:	....................................................................
:	SVC SYS, OP = 29d (SET USER DIAGNOSTIC)
:	R0 = DIAGNOSTIC (SC FORMAT) ADDRESS
:	....................................................................
					:
SUDIAG	LR	R12,R0			:CHECK ADDRESS GIVEN
	LHL	R13,F1PS1+2		:
	JAL	R11,ACCESS		:
	 J	 KRET			:ERROR...IGNORE
	LHL	R4,SLOT,R1		:OK...SET SLOT NUMBER
	LR	R5,R12			:SET ABSOLUTE ADDRESS
	JAL	R11,SETDIAG		:ENTER DIAGNOSTIC INTO POOL
	J	KRET			:AND EXIT
					:
:	....................................................................
:	SVC SYS, OP = 30d (LOCATE STORAGE PARAMETERS)
:	RETURN	R0	SLOT PHYSICAL CORE START ADDRESS
:		R1	SLOT SIZE (BYTES)
:	....................................................................
					:
UCORE	LHL	R4,UFLAG,R1		:VALID ONLY FROM DDT
	THI	R4,FDDT			:
	JE	NOTI			:ELSE NOT IMPLEMENTED
	L	R14,SBASE,R1		:OK...LOCATE SLOT START ADDRESS
	LHL	R15,CMAX,R1		:SIZE IN PAGES
	SLLS	R15,MACPAG		:SIZE IN BYTES
	STM	R14,RREG,R1		:PLACE IN HIS R0, R1
	J	KRET			:AND EXIT BACK
					:


:	****	OP=31d FREEZE ANY JOB    ****
 if	DB.FLG&0010
:	R0	KEY BEING SEARCHED FOR
:	NORMAL RETURN IF NOT IN RUN LIST
:	ELSE SKIP RETURN, JOB FROZEN
DBFRZ	L	R4,RUN			:START OF RUN LIST
DBFRZ1	CLH	R0,SLOT,R4		:CHECK IF CURRENT SLOT IS POSSIBLE TARGET
	JNFS	DBFRZ2			:SKIP IF NOT
	LHL	R5,UFLAG,R4		:POSSIBLE...CHECK THAT IT'S NOT DDT
	THI	R5,FDDT
	JNFS	DBFRZ2			:DDT...IGNOR
	LIS	R0,4			:ELSE SET UP TO DO SKIP-RETURN
	AM	R0,RPSW+4,R1
	LR	R1,R4			:SET TARGET FOUND AS "CURRENT USER"
	J	ONFRZ			:TREAT AS REQUEST FROM "CURRENT USER"
DBFRZ2	L	R4,LLINK,R4		:NOT THIS ENTRY...GET NEXT ONE
	JN	DBFRZ1			:KEEP SCANNING
	J	KRET			:NORMAL RETURN IF NOT FOUND
 else
DBFRZ	J	NOTI			:NOT IMPLEMENTED UNLESS IN DEBUG MODE
 ei	(DB.FLG&0010)





:	****	OP=32d HALT OWN SLOT	****
:	IT IS AN ERROR TO CALL THIS FROM SYSTEM JOB


HALT	LH	R4,SLOT,R1
	JL	KRET
	LH	R5,DC.SLT
	JGE	REPOP			:SOMEONE HERE FIRST
	STH	R4,DC.SLT		:TELL KERNEL TO DO IT
	LHL	R4,UFLAG,R1
	THI	R4,F1CRAS		:SEE IF HERE RIGHT AFTER A CRASH
	JNFS	HALT00			:BR IF SO
HALTER	JAL	R11,FNDDDT		:FIND DDT
	LHI	R0,8^2
	STH	R0,EFLAG,R4		:SET CODE 8 - SVC
HALT00	LH	R4,SLOT,R1		:GET SLOT NMBR
	SLHLS	R4,2			:MAKE A WORD INDEX
	LO	FLASH
	LA	R5,DEAD,,
	ST	R5,DISTBL,R4,		:SET UP DISPLAY
	FO	FLASH
	L	R5,SLIST,R4
	LIS	R4,0
	STH	R4,QUANTUM,R5
	L	R5,OTHER,R5
	JEFS	HALT01			:THERE MAY BE NO OTHER
	LHI	R4,FREEZE
	OH	R4,WFLAG,R5
	STH	R4,WFLAG,R5
HALT01	LHL	R5,UFLAG,R1		:CHECK FLAGS
	THI	R5,FDDT
	JN	KSKIP
 if	SPAM
  if	SPMTRC
	LHI	R10,16			:SPAM TRACE ROUTINE ID
  ei	(SPMTRC)
	JAL	R9,ENTIM		:GET USER DATA
 ei	(SPAM)
	J	MAIN



:	****	OP 33d HALT ANY JOB	***
 if	DB.FLG&0010
:	R0	KEY BEING SEARCHED FOR

DBHLT	LH	R4,DC.SLT		:SEE IF DISCONNECT IS BUSY
	JGE	REPOP			:YES
	L	R4,RUN			:START OF RUN LIST
DBHLT1	CLH	R0,SLOT,R4		:CHECK IF THIS SLOT IS TARGET
	JNFS	DBHLT2			:SKIP IF NOT
	LHL	R5,UFLAG,R4		:CHECK IT IS NOT DDT
	THI	R5,FDDT
	JNFS	DBHLT2			:DDT...IGNORE
	LIS	R5,4			:ELSE SET UP FOR SKIP RETURN
	AM	R5,RPSW+4,R1
	LR	R1,R4			:SET TARGET AS CURRENT USER
	J	HALT			:TREAT AS REQUEST FROM CURRENT USER
DBHLT2	L	R4,LLINK,R4		:NOT THIS ENTRY..GET NEXT ONE
	JN	DBHLT1			:KEEP SCANNING
	J	KRET			:NORMAL RETURN IF NOT FOUND
 else
DBHLT	J	NOTI			:NOT IMPLEMENTED UNLESS IN DEBUG
 ei	(DB.FLG&0010)
:	LOCAL ROUTINE TO FIND DDT
:	R11 ON "LINK"
:	"UB" CONTAINS CURRENT USER BLOCK
:	RETURNS R4 = POINTER TO THIS SLOT'S DDT BLOCK
:	[ALSO RETURNS UFLAG(R1) IN T2]
FNDDDT	LR	R4,R1			:COPY POINTER TO CURRENT JOB
	LH	R5,UFLAG,R1		:GET IT'S FLAG BITS
	THI	R5,FDDT			:TEST IF DDT
	JNR	R11			:RETURN IF SO
	L	R4,CONTROL,R4		:ELSE GET CONTROLLER OF THIS BLOCK
	JR	R11			:AND RETURN



:       ****    OP 34D START/STOP SPY   ****
SVSPY	LHL	R4,SLOT,R1		:GET SLOT #
	L	R12,RREG,R1		:GET OPERAND ADDR
	JN	SUSP2			:BRANSH IF PRESENT
:
:OPERAND=0 DISCONNECT IF OWNED
:
	CL	R4,SPYFLAG,,		:DOES THIS PROCESS
	JNFS	SUSP1			:OWN IT?
:
	TS	SPYFLAG,,		:TURN OFF SPY
	J	KSKIP			:SKIP RETURN
:
SUSP1	L	R4,SPYFLAG,,		:REPORT WHO OWNS
	ST	R4,RREG,R1
	J	KRET
:
SUSP2	LH	R13,SPYFLAG,,		:BUSY
	JGEBS	SUSP1			:YES
:
	LHL	R13,RPSW+2,R1		:CONVERT ARG
	JAL	R11,ACCESS
	J	SUSP3			:ERROR IN PARAM
:
	LR	R4,R12			:T1=BASE OF ARGS
	L	R12,0,R4		:GET ADDRESS OF BIN
	JAL	R11,ACCESS		:CHECK ADDRESS
	J	SUSP3			:ERROR
	ST	R12,SPYTAB,,
:
	L	R12,4,R4		:GET START ADDRESS
	JAL	R11,ACCESS
	J	SUSP3
	ST	R12,SPYSAD,,
:
	L	R6,8,R4			:GET RANGE
	ST	R6,SPYRNG,,
:
	DH	R6,0C,R4		:DIVIDE BY COUNT OF BINS
	STH	R7,SPYWTH,,		:TO GET WIDTH OF BINS
:
	LHL	R12,0C,R4		:VERIFY RANGE OF BINS
	AR	R12,R12			:MAKE A HW
	A	R12,0,R4
	JAL	R11,ACCESS
	J	SUSP3
:
	LA	R4,0E,R4		:GET LOCATION OF FLAG
	ST	R4,SPYFLC,,
	LHL	R4,SLOT,R1		:PUT SLOT #IN
	ST	R4,SPYFLAG,,		:FLAG
	J	KSKIP
:
SUSP3	LCS	R4,1			:REPORT ARGUMENT ERROR
	ST	R4,RREG,R1
	J	KRET			:ERROR RETURN
:
:       ****    OP=35D DISCONNECT DEVICE
:
DISCON	LR	R13,R0			:GET LUN
	CHI	R13,NLU			:CHECK LIMIT
	JG	KRET
:
	SLLS	R13,2			:MAKE WD INDEX
	JAL	R11,DCDVC		:DISCONNECT
	J	KSKIP			:
					:
   IF	KIOSRC				:
   ELSE					:
:	....................................................................
:	SVC SYS, OP = 36D (CONNECT RING TO KERNEL HOST)
:	....................................................................
					:
KLOG	LHI	R10,0			:FOR EACH GROUP
KLOG0	LCS	R8,1			:
	XH	R8,KACT,R10		:LOOK AT LAST GROUP
	JFFOH	R8,KLOG1		:GET ONE
	AIS	R10,2			:FOR NEXT GROUP
	CLHI	R10,NKGRP*2		:UNTIL ALL GROUPS
	JLBS	KLOG0			:CHECK IT OUT
	J	KRET			:NO PORTS AVAILABLE
KLOG1	SLHLS	R10,3			:MAKING BIT INDEX
	AR	R10,R9			:MAKE A BIT INDEX
	CLHI	R10,NKU-1		:OUT OF RANGE?
	JG	KRET			:YES
	SBT	R10,KACT		:SET PORT ACTIVE
	SBT	R10,NEWLOG		:START LOGGER
	SLHLS	R10,2			:MAKE WORD INDEX
	L	R12,RREG,R1		:GET PARAMETER LOCATION
	LHL	R13,RPSW+2,R1		:FETCH PSW STATUS
	JAL	R11,ACCESS		:CONVERT TO PHYSICAL ADDRESS
	J	LOGFAL			:FAILED,RESTORE PORT
	LR	R9,R12			:SAVE POINTER TO PARAMETERS
	L	R12,0,R9		:GET POINTER TO RINGS
	LR	R13,R12			:COPY IT
	XHI	R13,KBS*2+8-1,R12	:ALL MUST EXIST ONE ONE SEGMENT
	TI	R13,-SEGSIZ		:MUST ALL EXIST WITHIN ONE SEGMENT
	JN	LOGFAL			:FAILED
	AHI	R12,KBS*2+8-1		:TRANSLATE END ADDRESS
	JAL	R11,TTRW		:CHECK IT
	J	LOGFAL			:BAD...NORMAL RETURN
	L	R12,0,R9		:OK...TRANSLATE START ADDRESS
	JAL	R11,TTRW		:
	J	LOGFAL			:FAILED
	ST	R12,KRP,R10		:PUT IT AWAY
	LCS	R13,1			:GET A ROUND NUMBER
	ST	R13,NIO,R12		:RESET OUPUT POINTERS
	LH	R12,NOI,R12		:GET KERNEL'S TO KERNEL CURSOR
	SRHLS	R10,1			:MAKE HALFWORD INDEX
	STH	R12,NMI,R10		:MAKE SURE NMI STARTS RIGHT
	SLHLS	R10,1			:RESTORE WORD INDEX
	L	R12,4,R9		:GET KOF POINTER
	JE	KLOG2			:NOT IN USE
	LR	R7,R12			:SAVE A COPY
	NHI	R12,-8
	SRLS	R12,3			:MAKE BYTE ADDRESS
	JAL	R11,TTRW		:
	J	LOGFAL			:
	SLLS	R12,3			:MAKE ANOTHER BIT INDEX
	NHI	R7,7			:REMOVE 3 LSB
	AR	R12,R7			:MAKE ABSOLUTE BIT INDEX
KLOG2	ST	R12,KDP,R10		:PUT IT IN GIVEN PORT INDEX
	L	R12,8,R9		:GET KOFF BIT POINTER
	JE	KLOG3			:NOT IN USE
	LR	R7,R12			:SAVE A COPY
	NHI	R12,-8			:
	SRLS	R12,3			:MAKE BYTE ADDRESS
	JAL	R11,TTRW		:
	J	LOGFAL			:
	SLLS	R12,3			:MAKE ANOTHER BIT INDEX
	NHI	R7,7			:REMOVE 3 LSB
	AR	R12,R7			:MAKE ABSOLUTE BIT INDEX
KLOG3	ST	R12,KAP,R10		:PUT IT IN GIVEN PORT INDEX
	LH	R4,SLOT,R1		:
	SRHLS	R10,2			:
	STB	R4,KSP,R10		:
	J	KSKIP			:
LOGFAL	LIS	R12,0			:
	ST	R12,KAP,R10		:
	ST	R12,KDP,R10		:
	ST	R12,KRP,R10		:CANCEL ARGUMENTS
	SRHLS	R10,2			:MAKE PORT INDEX
	RBT	R10,KACT		:SET PORT UNUSED
	RBT	R10,NEWLOG		:CANCEL LOGGER
	J	KRET			:
					:
:	....................................................................
:	SVC SYS, OP = 37D (ZAP FROM KERNAL INPUT)
:	THIS SVC SIMPLY FORCES A ZAPPER INTO THE KERNEL RING, SOMETHING
:	WHICH THE SLOT ZERO CODE CANNOT DO WHEN THE RING IS FULL
:	....................................................................
					:
KZAP	L	R12,RREG,R1		:GET ARGUEMENT
	LHL	R13,RPSW+2,R1		:EXAMINE PSW
	JAL	R11,ACCESS		:TRANSLATE
	J	KRET			:RETURN IF INVALAID
	LHI	R1,NKU*4		:FOR EACH PORT
KZAP0	SIS	R1,4			:DO NEXT PORT
	JL	KZAP1			:ALREADY GONE
	C	R12,KRP,R1		:IS THIS REQUESTED PORT?
	JNBS	KZAP0			:NO TRY NEXT
	SRHLS	R1,2			:MAKE A PORT INDEX
	JAL	R4,HANG			:HANG PORT
	L	R1,USER			:RECOVER CURRENT USER
	J	KSKIP			:RETURN
KZAP1	L	R1,USER			:RECOVER CURRENT USER
	J	KRET
:
   EI  (KIOSRC)				:
					:
:	....................................................................
:	SVC SYS, OP = 38D VARIANT RESTART (TO SET SAVE SEGMENT MASK)
:	....................................................................
					:
   if	FSYS				:
VREST	L	R12,F1R1		:GET USER'S MASK FROM R1
	JAL	R11,FNDDDT		:
	STH	R12,FSSEG,R4		:
	J	RESTART			:
   ei  (FSYS)				:
					:
:	....................................................................
:	****	OP=39D:PUT MACHINE IN BOOT
:	....................................................................
					:
PBOOT	LH	R4,SLOT,R1		:INVALID FROM INTERFACE SLOTS
	JG	KRET			:IGNORE
	LO	FLASH			:
	LHI	R4,BINST		:GET THE CORRECT OPCODE
	STH	R4,FNOP			:PLACE IT
	J	KRET			:
	FO	FLASH			:
					:
 if	KIOSRC
 else
:	****	OP=40D:	SET 2ND BYTE OF DISPLAY
SETDIS	LHL	R4,RREG+2,R1		:GET VALUE
	STB	R4,DISPLAY+1		:
	J	KRET			:
 ei	(KIOSRC)
:
:	****	OP=41D RESET BLOCKS.  IF ZITEL OR TSI ALSO UNTHREAD LIST
:
RSBLOK	LHL	R4,UFLAG,R1		:VALID ONLY FROM DDT
	THI	R4,FDDT
	JE	NOTI
:
	LA	R4,MPROT+MACDIS,R1	:RESET TO DEFAULT MAC SET
	ST	R4,UMAC,R1
	L	R4,SBASE,R1		:MAKE SBASE THE START OF
	SRLS	R4,MACPAG		: FIRST BLOCK AS A PAGE BOUND
	STH	R4,BLOCKS,R1		:START OF AREA 0
:
   if	MULMAC
					:
:	.......................................................................
:	MUST SCAN LIST OF MAC SETS FOR THIS SLOT AND DISCONNECT ANY THAT
:	ARE FOUND
:	.......................................................................
					:
	LA	R4,SML-0A		:FIRST R11
					:
RSBL01	LR	R5,R4			:ADVANCE R11
	L	R4,0A,R5		:
	JEFS	RSBL03			:DONE WHEN ZERO FOUND
					:
RSBL02	LB	R6,8,R4			:GET SLOT NUMBER
	CH	R6,SLOT,R1		:IS IT THE SAME?
	JNBS	RSBL01			:NO
					:
	L	R4,0A,R4		:MOVE R11
	ST	R4,0A,R5		:
	JNBS	RSBL02			:
					:
RSBL03					:
   ei  (MULMAC)				:
					:
	LIS	R0,0			:INDICATE USER MAC NOT SET UP
	ST	R0,STAMAC,R1		:SET INDICATOR IN DDT
	L	R5,CONTROL,R1		:DO IT TO BG
	ST	R0,STAMAC,R5		:
					:
	L	R5,OTHER,R5		:AND FG
	JE	KRET			:FI FG IS PRESENT
	ST	R0,STAMAC,R5		:
	J	KRET			:
					:
:	....................................................................
:       OP = 42D CHANGE A MAC SET
:	....................................................................
					:
CHNMAC	L	R5,STAMAC,R1		:SEE IF THIS IS INITIALIZED
	JE	KRET			:SIMPLY RETURN IF NOT
	LHL	R6,RREG+2,R1		:GET MAC SET NUMBER
	CH	R6,LIMMAC,R1		:IS IT WITHIN LIMITS?
	JGE	KRET			:REJECT IF NOT
	LHI	R0,$A19*4		:COMPUTE LOCATION OF MAC
	MHR	R6,R0			:
	AR	R6,R5			:ADD IN BASE ADDRESS
	L	R12,RREG+4,R1		:CHECK ON ADDRESS
	LHL	R13,F1PS1+2		:
	JAL	R11,ACCESS		:
	J	KRET			:ERROR ON ADDRESS
	JAL	R11,FNDDDT		:FIND DDT USER BLOCK
	LR	R1,R4			:MAKE IT R1
	LR	R5,R6			:R5 = BASE OF MAC SET
	LHI	R4,$A(2-16*4)		:LOCATE MAC REG 0
	LR	R13,R12			:SAVE USER ADDRESS IN R13
CHNM01	L	R0,$A16*4-2,R13,R4	:GET A MAC REG
	JAL	R12,MKEXTM		:CONVERT
	J	CHNM02			:MAKE AN ERROR RETURN IF NEEDED
	AIS	R4,4			:GO ON TO NEXT REG
	JLEBS	CHNM01			:
	L	R1,USER			:RESTORE R1
	L	R12,40,R13		:GET NEW PSD ADDRESS
	LHL	R13,F1PS1+2		:PSW FOR ACCESS
	JAL	R11,ACCESS		:
	J	KRET			:ACCESS DENIED
	ST	R12,2,R5		:SET NEW USER ADDRESS
	C	R5,MACTRN,R1		:IS THIS THE CURRENT MAC?
	JEFS	CHNM03			:BRANCH IF IT IS CURRENT
	LIS	R0,0			:SET MAC SET EQUAL TO ZERO
	STB	R0,9,R5			:
	J	KSKIP			:
CHNM02	L	R1,USER			:
	J	KRET			:
CHNM03	LM	R13,MACTRN,R1		:TRANSFER THE NEW MAC REGISTERS
	COPY	R13,R15			:
	J	KSKIP			:
					:
:	.......................................................................
:	INTERNAL ROUTINE TO SET UP 1 MAC REGISTER'S PROTECTION
:	link on R11
:	expects	R1	pointer to user block
:		R4	MAC register index (segment# * 4)
:		R5	user specified protection:
:			R W E	where:
:			| | |
:			| | set = 1 if execution permitted
:			| set = 1 if write permitted
:			set = 1 if read permitted
:	smashes R0,R12
:	.......................................................................
					:
PROTMAP	BC	00,00,00,00		:
	BC	MASKB,MASK3,MASK9,MASK1	:PROTECTION TO APPLY
					:
SETPROT	LHI	R0,@(MASKF)		:SET MASK
	N	R0,MPROT,R1,R4		:GET VALUE
	JER	R11			:DON'T TOUCH IF MAC = 0
	LIS	R12,7			:
	NR	R12,R5			:EXTRACT THE USER BITS
	LB	R12,PROTMAP,R12		:GET VALUE TO USE
	OR	R0,R12			:PUT THAT PROTECTION INTO THIS REGISTER
	ST	R0,MPROT,R1,R4		:SAVE VALUE
	ST	R0,MACAREA,R4		:LET IT TAKE IMMEDIATE EFFECT
	JR	R11			:AND RETURN
					:
:	.......................................................................
:	****	OP 43D SUSPEND SLOT
:	.......................................................................
					:
SUSPEN	L	R4,RLICEN,R1		:SEE IF VALID FROM THIS SLOT
	THI	R4,TL.SUS		:
	JE	KRET			:BR IF NOT (NON-SKIP RETURN)
	LH	R4,SS.SLT		:SEE IF SUSPEND ALRDY IN PROGRESS
	JGE	REPOP			:GO REDO IF SO
	CLHI	R0,NSLOT+1		:MAKE SURE SLOT NMBR VALID
	JC	KRET			:BR IF NOT
   if	MXP				:
	CLHI	R0,SLTXMI		:MAKE SURE NOT SUSPENDING XMI SLOT
	JE	KRET			:BR IF SO
   ei  (MXP)				:
	CLH	R0,SLOT,R1		:MAKE SURE NOT SUSPENDING OWN SLOT
	JE	KRET			:BR IF SO
	LIS	R5,4			:
	AM	R5,RPSW+4,R1		:ALL FUTURE RETURNS ARE SKIP-RETURNS
	TBT	R0,SSSLOT		:SEE IF ALREADY SUSPENDED
	JN	KRET			:SKIP-RET IF SO
	LR	R4,R0			:
	SLHLS	R4,2			:GET SLOT INDEX
	L	R1,SLIST,R4		:GET BKGND BLOCK FOR SPECIFIED SLOT
	STH	R0,SS.SLT		:SET TO SUSPEND SLOT
	TBT	R0,RNSLOT		:
	JE	HALT00			:GO FINISH HALT
	J	HALTER			:GO HALT & UPDATE REASON
					:
:	.......................................................................
:	****	OP 44D RESUME SLOT
:	.......................................................................
					:
RESUM	L	R4,RLICEN,R1		:SEE IF VALID FROM THIS SLOT
	THI	R4,TL.SUS		:
	JE	KRET			:BR IF NOT
	LH	R4,RS.SLT		:SEE IF RESUME ALRDY IN PROGRESS
	JGE	REPOP			:BR IF SO
	CLHI	R0,NSLOT+1		:SEE IF SLOT NMBR VALID
	JC	KRET			:BR IF NOT
	TBT	R0,SSSLOT		:SEE IF ALREADY RESUMED
	JE	KSKIP			:BR IF SO
	TBT	R0,RNSLOT		:SEE IF HALTED
	JNFS	RESM1			:BR IF NOT
	RBT	R0,SSSLOT		:INDICATE SLOT RESUMED
	J	KSKIP			:SKIP-RETURN
RESM1	LIS	R4,4			:
	AM	R4,RPSW+4,R1		:SET FOR SKIP-RETURN
	LR	R2,R0			:
	SLHLS	R2,2			:
	L	R2,SLIST,R2		:GET BLOCK ADDR
	JAL	R7,EXSLOT		:START UP SLOT
	 J	RESM2			:ERROR IF CAN'T
	STH	R0,RS.SLT		:SET TO FINISH RESUME
	LHI	R0,8^2			:
	STH	R0,EFLAG,R14		:SET CODE 8 - SVC
  if	SPAM				:
   if	SPMTRC				:
	LHI	R10,15			:SPAM TRACE ROUTINE ID
   ei  (SPMTRC)				:
	LR	R1,R8			:
	JAL	R9,ENTIM		:
  ei   (SPAM)				:
	J	MAIN			:
					:
RESM2	LHL	R0,SLOT,R14		:SLOT NMBR
	RBT	R0,ACSLOT		:
	RBT	R0,RNSLOT		:INDICATE SLOT HALTED
	RBT	R0,SSSLOT		:*BUT RESUMED
	LHI	R0,7^2			:SET BAD MAC ERROR CODE
	STH	R0,EFLAG,R14		:
	L	R1,USER			:RESTORE USER BLOCK ADDR
	J	KRET			:
					:
:	.......................................................................
:	EXSLOT - SUBROUTINE TO EXECUTE A SLOT
:	R2 - USER BLOCK ADDR OF SLOT TO EXECUTE
:	R7 - R11 REG
:	RETURN IF MAC NOT SET UP CORRECTLY TO RUN SLOT
:	SKIP-RETURN IF OKAY, MUST STH R0 TO CT.SLT OR RS.SLT
:	.......................................................................
					:
EXSLOT	LHL	R4,UFLAG,R2		:GET USER FLAGS FROM BACKGROUND
	LHL	R13,SLOT,R2		:GET SLOT #
	SLLS	R13,2			:SET 4* SLOT INDEX
	L	R14,CONTROL,R2		:POINTER TO DDT BLOCK
	THI	R4,FDISP		:
	JE	EXE.1			:
	L	R0,CTASEG*4+MPROT,R14	:YES...CHECK MAC SETUP
	CL	R0,MPROT,R14		:BAD IF SEG 14 SAME AS SEG 0
	JER	R7			:NON-SKIP RETURN IF BAD MAC
	SRLS	R0,MSHFTA		:MAKE INTO ADDRESS
	X	R0,SBASE,R14		:
	TI	R0,MACSTR		:GOOD IF SEG 14d IS AT START OF SPACE
	JNR	R7			:NON-SKIP RETURN IF BAD MAC
	LR	R12,R2			:PASS POINTER TO BACKGROUND BLOCK
	JAL	R10,K.KNCT		:LET THE DISPATCHER SET UP FIRST
	 J	0,R7			:NON-SKIP RETURN IF BAD MAC
	LR	R2,R12			:BACKGROUND BLOCK
EXE.1	HS	0			:
  if	SUP				:
   if	KIOSRC				:
	LHI	R3,(NSLOT+1)*4		:GET SUP SLOT #
	CR	R3,R13			:IS IT THE SUP SLOT
	JN	EXE.12			:IF NOT, EXIT
	L	R0,SUPDIS		:GET SUP DISPLAY PTR
	LO	FLASH			:
	ST	R0,DISTBL,R13		:PLACE PTR IN DISPLAY TABLE
	FO	FLASH			:
   ei  (KIOSRC)				:
  ei   (SUP)				:
EXE.12	LR	R1,R14			:R1 IS BASE OF DDT BLOCK
	L	R3,OTHER,R2		:FOREGROUND BLOCK
	JNFS	EXE.15			:SKIP IF THERE IS A FRGND FOR SLOT
	LR	R3,R2			:ELSE FAKE IT
EXE.15	LCS	R0,1			:INDICATE FG TURNED OFF
	ST	R0,RPSW+4,R3		:
	L	R0,INIPSW+4,R2		:
	ST	R0,RPSW+4,R2		:INITIALIZE BG PC
	LIS	R0,0			:
	ST	R0,REST,R2		:INITIALIZE RESTART ADDRESS
	ST	R0,BGTRAP,R2		:*AND TRAP ADDRS
	ST	R0,FGTRAP,R2		:
  IF	WFROG				:
	L	R0,WFROGT,R2		:WATCHFROG ENABLED?
	AIS	R0,2			:
	JE	EXE.17			:BR IF NOT
	LCS	R0,1
	ST	R0,WFROGT,R2		:TURN OFF SVC WATCHFROG
	ST	R0,WFROGT,R3		:
   if	\HI.FRG				:
	L	R0,SLOWC		:
	AHI	R0,WFTIME+5		:
	ST	R0,WFROGD,R2		:INIT DISMISS WATCHFROG
	ST	R0,WFROGD,R3		:
   ei  (HI.FRG)				:
  EI   (WFROG)				:
EXE.17	LHI	R4,(NLU-1)*4		:FOR ALL LOGICAL UNITS:
EXE.2	L	R0,LUN,R1,R4		:COPY ALL LOGICAL UNIT DESCRIPTORS
	ST	R0,LUN,R2,R4		:
	ST	R0,LUN,R3,R4		:
	SIS	R4,4			:
	JGEBS	EXE.2			:
 if	SHARE				:
:	....................................................................
:	COPY EXTENDED LOG UNIT TABLE FROM DDT BLOCK TO FORE- AND BACK-GND
:	....................................................................
					:
	LHI	R4,(NXLU-1)*2		:NUMBER OF BYTES
EXE.3	LH	R0,LUT,R1,R4		:
	STH	R0,LUT,R2,R4		:
	STH	R0,LUT,R3,R4		:
	SIS	R4,2			:
	JGEBS	EXE.3			:
 ei    (SHARE)				:
	LHI	R4,CTASEG*4		:SET UP MAC FOR SLOT
EXE.4	L	R0,MPROT,R1,R4		:
	ST	R0,MPROT,R2,R4		:
	ST	R0,MPROT,R3,R4		:
	SIS	R4,4			:
	JGEBS	EXE.4			:DO FOR ALL MAC SEGMENTS
	LIS	R4,0			:
	STH	R4,WFLAG,R2		:CANCEL ALL WAIT BITS
	LHL	R4,UFLAG,R2		:SET UP BACKROUND JOB'S FLAGS
	OHI	R4,F1CRAS		:SET TO DIE ON NEXT CRASH
	STH	R4,UFLAG,R2		:
	LHL	R0,SLOT,R2		:GET SLOT NMBR FOR STORE
	J	4,R7			:SKIP-RETURN
					:
:	....................................................................
:	SVC SYS, OP = 45D (GET INFO FROM DISPATCHER)
:
:	R0: HIGH BYTE = FUNC: 
:			0 = TEST STATUS
:			1 = RESET IN/OUT CHAR COUNTS
:			2 = GET IN/OUT CHAR COUNTS
:			    RTRN=IN CHR CT R0(B0-31),OUT CHR CT R1(B0-31)
:			3 = GET PORT DESTINATION
:			    RTRN=MACH#(B0-7),SLOT#(B8-15),PORT#(B16-31)
:			4 = GET PORT BUFFER USAGE
:			    RTRN=OUT CHR CT (B0-15), IN CHR CT (B16-31)
:                       5 = GET DISPATCHER EXECUTION RATE
:                           RTRN=DISP EXECUTIONS (B0-31)
:	    2ND BYTE = SLOT NMBR
:	    LOW HW   = PORT NMBR
:	
:	J   SLOT.DOWN OR BAD.FUNC
:	J   UNASSIGNED.PORT (FUNCS 3 & 4 ONLY)
:	R0: RTRN VALUE
:	NOTE: This is done here--rather than in Dispatcher--to insure
:	      that timeouts cannot occur while executiong within Dispatcher.
:	....................................................................
					:
 if	NSLOT				: SPAM fix 9/23.86
DSPINF	LHR	R5,R0			: save port-number
	EXHR	R0,R0			: extract slot-number
	LBR	R6,R0			:
	CLHI	R6,NSLOT		: make sure it's valid
	JG	KRET			: bad slot-number
	EXBR	R0,R0			:
	LBR	R3,R0			: extract FUNCtion code
	CLHI	R3,6			: make sure FUNC code is valid
	JGE	KRET			: no
	SLHLS	R6,2			: make Slot Key (word index)
  if	MXP				:
	LR	R3,R3			: Slot Status
	JNFS	DSIN20			: no
	LHI	R0,KDMGSS		: ask for Slot status
	J	DSISND			:
DSIN20					:
  else					:
	L	R2,I.CTL,R6,		: get Dispatcher status
	JGE	KRET			: non-skip return if DOWN
	LR	R3,R3			:
	JE	KSKIP			: slot-status ONLY
  ei   (MXP)				:
  if	MXP				:
	CHI	R3,5			:Dispatcher Execution-rate request?
   IF	ENHMXP				:VERSION 3.00 OF MXP-XPI
	JE	DSIN35			:yes
   ELSE					:
	JE	KRET			:
   EI  (ENHMXP)				:
  ei   (MXP)				:
	SIS	R3,2			:
	JG	DSIN10			:skip if FUNC > 2
	JEFS	DSIN30			:skip if FUNC = 2
  if	MXP				:
	LHI	R0,KDMZCC		:ask to clear Char-counts
	J	DSISND			:
DSIN30	LHI	R0,KDMGCC		:FUNC = 2...ask for Character-counts
	J	DSISND			:
  else					:
	LIS	R0,0			: FUNC = 1...clear IN/OUT char-counts
	ST	R0,I.CHRS,R6,r6		:
	st	r0,i.chrs+4,r6,r6	: ***pwk
	J	KSKIP			:
DSIN30	L	R0,I.CHRS,R6,r6		:FUNC = 2...get IN/OUT char counts
	ST	R0,RREG,R1		:set as Return-value
	l	r0,i.chrs+4,r6,r6	:***pwk
	st	r0,rreg+4,r1		:
	J	KSKIP			:
  ei   (MXP)				:
  if	ENHMXP				:
DSIN35	LHI	R0,KDMDCC		:FUNC = 5...Dispatcher execution-rate
	J	DSISND			:
  ei	(ENHMXP)			:
DSIN10	LR	R5,R5			: FUNC = 3 or 4
	JL	KSKIP			: port-number negative
	CLH	R5,I.PSIZ,R6,
	JG	KSKIP			: port-number too big
	L	R2,I.PTBL,R6,		: get Permuter-table Address
	AR	R5,R5			: make Port a HW-index
	LH	R4,0,R2,R5		: get Permuter-table entry
	JLE	KSKIP			: port unassigned
  if	MXP
	SIS	R3,2
	JEFS	DSIN40			: skip unless FUNC = 3
	LHI	R0,KDMGPD		: FUNC = 3...ask for Port-destination
	JFS	DSISND

DSIN40	LHI	R0,KDMGPB		: FUNC = 4... ask for Port Buffer-usage

DSISND	LR	R7,R1			: save user-block Address
	JAL	R4,KDOS			: send request to XPI thru KDIO
	LR	R1,R7
	SI	R7,UBLOKS		: use RLTV R1 address as Key
	LR	R0,R7
	JAL	R4,KDOH			: Key
	CHI	R2,1			: check for Length = 1 (Key only)
	JE	DSISN2			: end Message if so
	LR	R0,R6			: Slot-number whose Info is being
	SRLS	R0,2			:  requested
	JAL	R4,KDOH			: Slot-number
	SIS	R2,2			: see if needs Port-number
	JLEFS	DSISN2			: skip if not
	LR	R0,R5
	SRLS	R0,1
	JAL	R4,KDOH			: send Port-number
DSISN2	JAL	R4,KDOE			: end Message
	LHL	R0,WFLAG,R1		: put job in Wait-state
	OHI	R0,XPIWF		:  until response
	STH	R0,WFLAG,R1
	JAL	R11,FNDDDT		: find DDT-block
	LHI	R0,8^2			: indicate SVC
	STH	R0,EFLAG,R4		: place in Flag-indicator
	LIS	R0,0			: TRASH remaining time
	STH	R0,QUANTUM,R1
   if	SPAM
    if	SPMTRC
	LHI	R10,17			: SPAM TRACE-routine ID
    ei	(SPMTRC)
	JAL	R9,ENTIM		: get user data
   ei	(SPAM)
	J	MAIN			: DISMISS it too

  else	:not MXP
    LO	DISPAT
	GL	C.POOL
:	LHI	R7,P.LEN
	lr	r7,r4
	ar	r7,r7
	ar	r7,r4
	slls	r7,4			: compute offset***etm
:	MHR	R7,R4			: compute path-offset
	AI	R7,C.POOL		: compute pointer to Path descriptor
	SIS	R3,2
	JEFS	DSIN40			: skip unless FUNC = 3
	LB	R0,P.SLOT,R7		: FUNC = 3...get Destination Slot-number
	SRLS	R0,2
	EXHR	R0,R0
	LHL	R4,P.PORT,R7		: get Destination Port-number
	OR	R0,R4			: pack together
	JFS	DSIN50			: and skip

DSIN40	LHL	R0,P.HIST,R7		: FUNC = 4...get Output-buffer History
	EXHR	R0,R0
	STH	R0,P.HIST,R7
	AH	R7,P.BIAS,R7		: other path of pair
	LHL	R4,P.HIST,R7		: get input-buffer history
	OR	R0,R4

DSIN50	ST	R0,RREG,R1		: set Return-value
        LIS     R0,0
        STH     R0,P.HIST,R7            : RESET P.HIST AFTER EACH INQUIRY
    FO	DISPAT
	LIS	R0,8			: set for RETURN+8
	AM	R0,RPSW+4,R1
	J	KRET
  ei	:MXP

 ei	(NSLOT)
:	**** OP = 46D	REPORT SLOTS TO BE SUSPENDED IF THIS SLOT GOES DOWN
:	INPUT: R0,R1 CONTAIN BIT MAPS OF SLOTS
:	OUTPUT ON SUCCESS: RETURN WITH SKIP
:	OUTPUT ON ERROR: NORMAL RETURN WITH ERROR CODE IN R0
:		ERROR CODES: 1 = SLOT OUT OF BOUNDS
:			     2 = REQUESTING SLOT DOESN'T HAVE SUSPEND LICENSE


:	CHECK IF THE REQUESTING SLOT HAS A SUSPEND LICENSE
SUSGRP	L	R3,RLICEN,R1		:GET LICENSE OF THIS SLOT
	TI	R3,TL.SUS		:IS SUSP LICENSE BIT SET ?
	JNFS	SUS3			:IF SO - PROCEED
	LIS	R3,2			:ERROR CODE 2 - NO LICENSE
SUS1	ST	R3,RREG,R1
	J	KRET			:RETURN
:	CHECK IF THE DESIGNATED SLOTS IN THE GROUP ARE VALID
SUS3	L	R4,RREG+4,R1		:COPY LOW ORDER REG (USER'S R1)
	LHI	R3,NSLOT		:GET NBR OF SLOTS IN THIS ENGINE
	CHI	R3,$A 32
	JGEFS	SUS5
	LR	R4,R4			:DOES LOW ORDER REG HAVE SLOTS ?
	JNFS	SUS8			:IF SO & NSLOT .LT. 32 - ERROR
	L	R4,RREG,R1		:LOAD USER'S R0 (MOST SIG SLOTS)
	JFS	SUS6
SUS5	SHI	R3,$A 32		:DECR NSLOT TO 1 REG SIZE
SUS6	SLL	R4,1,R3			:SHIFT OUT VALID SLOT POSITIONS
	JEFS	SUS10			:IF 0 - GOOD
SUS8	LIS	R3,1			:ELSE - LOAD ERROR CODE OF INVALID SLOT
	J	SUS1			:
					:
:	....................................................................
:	STORE THE SLOT DESIGNATION IN THE USER BUFFER
:	....................................................................
					:
SUS10	L	R4,RREG+4,R1		:GET THE LOW ORDER SLOT LIST
	ST	R0,SUSLST,R1		:THE HIGH ORDER IS HERE
	ST	R4,SUSLST+4,R1		:
	L	R3,OTHER,R1		:POINT TO THE FG
	JEFS	SUS15			:
	ST	R0,SUSLST,R3		:ALSO PUT THE SLOTS INTO FG
	ST	R4,SUSLST+4,R3		:
					:
:	....................................................................
:	MAKE SURE THAT THE REQUESTING SLOT IS NOT IN THE SUSPEND LIST
:	....................................................................
					:
SUS15	LHL	R4,SLOT,R1		:GET THE SLOT NBR
	RBT	R4,SUSLST,R1		:ZAP BIT IN HIGH PART OF LIST
	J	KSKIP			:ALL DONE
					:
:	....................................................................
:	SVC SYS, OP = 47D (UPDATE WATCHFROG TIMER)
:	THIS TIMER IS USED TO VERIFY THAT A SLOT IS ALIVE AND NOT CAUGHT IN
:	A LOOP.  IT IS ONLY USED BY SLOTS REQUESTING IT, VIA THIS SVC. ONCE
:	INITIATING THE WATCHFROG TIMER, IF THE SLOT FAILS TO ISSUE THIS SVC
:	PERIDICALLY,IT WILL BE HALTED. HOWEVER, IF THE WATCHFROG WAS HALTED
:	BY A DDT COMMAND, THIS SVC CALL WILL NOT UPDATE IT,  AND THE KERNEL
:	WILL TREAT THE SLOT AS IF IT HAS NO WATCHFROG TIMER.
:	....................................................................
					:
   IF	WFROG				:
W.FROG	L	R3,WFROGT,R1		:GET PRESENT WATCHFROG VALUE
	AIS	R3,2			:WAS IT HALTED BY A DDT COMMAND ?
	JE	KRET			:IF SO - LEAVE IT ALONE
	L	R3,SLOWC		:GET THE CURRENT SLOWC
	AHI	R3,WFTIME		:INCREAMENT CURRENT WATCHFROG TIMER
	ST	R3,WFROGT,R1		:UPDATE WATCHFROG TIMER
	J	KRET			:RETURN ...
   EI  (WFROG)				:
					:
:	....................................................................
:	SVC SYS, OP = 48D (CONNECT BIO RING (MXP ONLY))
:	ON INPUT:R0 = ADDR OF BIO BUFFER AREA
:		 1ST HW CONTAINS LENGTH
:	....................................................................
   IF	MXP				:
CONBIO	LR	R12,R0			:
	JAL	R11,TTRW		:TRANSLATE/CHECK START ADDR
	J	KRET			:BAD ADDRESS
	LR	R9,R12			:
	LHL	R12,0,R12		:CALC END ADDR
	AR	R12,R0			:
	SIS	R12,1			:
	JAL	R11,TTRW		:TRANSLATE/CHECK END ADDR
	J	KRET			: BAD ADDRESS
	LR	R7,R1			:SAVE USER BLOCK ADDR
	LHI	R0,KDMBIO		:SEND CONNECT BIO MESSAGE
	JAL	R4,KDOS			:
	LR	R1,R7			:
	SI	R7,UBLOKS		:USE RLTV R1 ADDR AS KEY
	LR	R0,R7			:
	JAL	R4,KDOH			:KEY
	LR	R0,R9			:USER BIO BUFFER ADDR
	EXHR	R0,R0			:
	JAL	R4,KDOH			:
	EXHR	R0,R0			:
	JAL	R4,KDOH			:
	J	DSISN2			:GO END MSG & FREEZE SLOT
   EI  (MXP)				:
					:
 if	IPNMBR
:       ****    OP=49D  XLATE VIRTUAL ADDRESS   ****
XLVADR	LR	R12,R0			:GET ADDRESS
	LHL	R13,RPSW+2,R1		:GET USER'S PSW
	JAL	R11,ACCESS		:GO GET XLATED ADDR
	J	KRET			:ERROR...NORMAL RETURN
	ST	R12,RREG,R1		:ABSOLUTE ADDR RETURNED IN R0
	J	KSKIP			:SKIP RETURN

:       ****    OP=50D  INTERRUPT IPI   ***
SINTIP	CLHI	R0,NLU			:CHECK FOR OK LUN
	JG	KRET			:BAD LUN, NORMAL RETURN
	LR	R4,R0
	SLHLS	R4,2			:MAKE WORD INDEX
	LB	R5,LUN,R4,R1		:GET L.U.N. TYPE
	SIS	R5,5
	JN	KRET			:THIS LOG. UNIT NOT AN IPI
	L	R5,LUN,R4,R1		GET LUN DESCRIPTOR
	LO	IPI
	NI	R5,00FFFFFF		:GET RID OF HIGH BYTE
	LI	R4,SLTINT		:SLOT INTRPT MSG (06000000)
	ST	R4,ETOIPM,R5		:PUT IN PERM MSG AREA
	LHL	R2,IPADDR,R5		:GET DEVICE ADDR
	LIS	R4,7			:AND INTERRUPT
	OCR	R2,R4
	LIS	R4,6
	OCR	R2,R4
	J	KSKIP
	FO	IPI
 ei	(IPNMBR)

:	**** OP 51D  EXECUTE A SLOT

RUNSLT	LHL	R2,UFLAG,R1		:MAY ONLY BE CALLED FROM
	THI	R2,FDDT			:*DDT PROCESS
	JE	NOTI
	L	R2,CONTROL,R1		:GET BKGND UB ADDR
	JE	NOTI			:MUST BE ONE
	LIS	R3,1			:CODE FOR SLOT ALRDY RUNNING
	LHL	R4,SLOT,R1		:GET SLOT NMBR
	TBT	R4,RNSLOT		:SEE IF ALRDY RUNNING
	JN	RNS030			:ERROR IF SO
	TBT	R4,SSSLOT		:SEE IF SLOT SUSPENDED
	JN	RNS010			:BR IF SO
	LH	R4,CT.SLT		:SEE IF CNCT ALRDY IN PROGRESS
	JGE	REPOP			:TRY AGN LATER IF SO
	JAL	R7,EXSLOT		:START UP SLOT
	 J	RNS020			:BR IF BAD MAC
	STH	R0,CT.SLT		:SET TO FINISH CONNECT
	LHI	R0,8^2
	STH	R0,EFLAG,R14		:SET CODE 8 - SVC
	L	R1,USER			:RESTORE UB ADDR
	LIS	R4,4			:SET FOR SKIP RETURN
	AM	R4,RPSW+4,R1
	J	MAIN

RNS010	SBT	R4,RNSLOT		:SET TO RUN WHEN RESUMED
	SBT	R4,ACSLOT
	LIS	R0,0			:CLEAR WAIT BITS
	STH	R0,WFLAG,R1
	LIS	R3,2			:CODE FOR SUSPENDED
	JFS	RNS030

RNS020	LHI	R0,7^2
	STH	R0,EFLAG,R14		:SET CODE 7 - BAD MAC
	L	R1,USER			:RESTORE UB ADDR
	LIS	R3,3			:CODE FOR BAD MAC
RNS030	ST	R3,RREG,R1		:SAVE ERROR CODE IN R0
	J	KRET			:ERROR RETURN
					:
:	....................................................................
:	SVC SYS, OP = 52D (CONTINUE SLOT CRASH)
:	R0 = ADDR OF PSD, R0, R1
:	R1 = CRASH CODE
:	....................................................................
					:
CRASLT	LR	R12,R0			:GET SAVE AREA ADDR
	LHL	R13,F1PS1+2		:GET PSW
	JAL	R11,ACCESS		:GET PHYS ADDR
	 J	KRET			:BAD ADDR
	LR	R11,R12			:SAVE PHYS SAVE AREA ADDR
	LB	R2,RREG+4+3,R1		:GET CRASH CODE
	LM	R12,0,R11		:COPY CRASH PSD, R0, R1
	STM	R12,RPSW,R1		:
	LR	R0,R2			:COPY CRASH CODE
	SLLS	R0,8			:FAIL CRASH CODE TO HI BYTE
	CLHI	R2,0A			:SEE IF IN RANGE OF TBL
	JC	KRET			:ERROR IF OUT OF RANGE
	LB	R2,CRSCVT,R2		:GET CORRESPONDING DDT CODE
	OR	R0,R2			:MAKE PARAMETER FOR KRASH
	OHI	R0,4000			:IGNORE TRAP ROUTINES
	JAL	R11,KRASH		:CRASH THE SLOT
	J	MAIN			:
					:
CRSCVT	BC	0A*4,0A*4,3*4,5*4,6*4,1*4,0A*4,4*4,4*4,0C*4
					:

:	....................................................................
:	SVC SYS, OP = 53D  (INIT NODE CODE CPS POINTER
:	....................................................................
					:
INICPS	LR	R12,R0			:GET ADDRESS
        JLFS    INCPS0                  :IF NEGATIVE ADDR, RESTART REQUEST
	LHL	R13,RPSW+2,R1		:GET USER'S PSW
	JAL	R11,ACCESS		:GO GET XLATED ADDRESS
	J	KRET			:ERROR...NORMAL RETURN
INCPS0	ST	R12,CPSADR		:ABSOLUTE ADDR RETURNED IN R0
	J	KSKIP			:SKIP RETURN
					:
:	....................................................................
:
:			MULTI-KERNEL PROCESSOR
:
:	SVC SYS, OP = 57D (SUPERVISOR RING INFO.)
:	INPUT R1 = SLOT LOGICAL UNIT (SLU)
:
:	....................................................................
					:
   IF	MULTI				:
SGRNSL  L	R7,RREG+(R1*4),R1       :GET SLU VALUE
	CLHI	R7,SLUNUM		:CHECK SLU VALIDITY
	JLEFS	SGRN1			:SLU VALID
BADLU	LIS	R0,1			:BAD SLU NUMBER
	ST	R0,RREG+(R0*4),R1	:
	J	KRET			:ERROR RETURN
SGRN1   LH	R5,SRSEG,R1		:GET SEGMENT VALUE
	JGE     SGRN2			:GET RING INFO.
	LIS	R0,2			:NO SEGMENT ASSIGNED
	ST	R0,RREG+(R0*4),R1	:
	J	KRET			:
SGRN2   LR	R2,R7			:GET SLU VALUE
	SLLS	R2,2			:WORD INDEX
	L	R2,SLUTBL,R1,R2		:SLOT DESCRIPTOR QUADWORD
	JE	BADLU			:NO USER RINGS?
					:
:	....................................................................
:	get ring logical start address (LRA) where
:	LRA = physical ring addr - physical base + virtual segment address
:	....................................................................
					:
	L	R3,SDIEND,R2		:END ADDRESS FOR INPUT RING
	SH	R3,SDISIZ,R2		:SUBTRACT SIZE
	SIS	R3,4			:SUBTRACT CURSORS
	LR	R4,R5			:GET SEGMENT VALUE
	SLLS	R4,2			:WORD INDEX
	L	R4,MPROT,R1,R4		:GET MAC REGISTER
	NI	R4,MMASKR		:PHYSICAL BASE ADR. OF SEG.
	SRLS	R4,MSHFTA		:MAKE ADDRESS
	SR	R3,R4			:OFFSET=(PHYSICAL)[RING-BASE]
	SLL	R5,MSHFTV		:VIRTUAL SEGMENT START ADDRESS
	AR	R5,R3			:LRA=OFFSET+VIRTUAL SEG.
	ST	R5,RREG+(R1*4),R1	:
					:
:	....................................................................
:	determine input and output ring sizes
:	....................................................................
					:
	LH	R3,SDOSIZ,R2		:OUTPUT RING SIZE
	ST	R3,RREG+(R3*4),R1	:
	LH	R2,SDISIZ,R2		:INPUT RING SIZE
	ST	R2,RREG+(R2*4),R1	:
	LIS	R0,0			:SUCESSFUL RETURN
	ST	R0,RREG+(R0*4),R1	:
	J	KRET			:
   EI  (MULTI)				:
					:
:	....................................................................
:	SVC SYS, OP = 59D (INITIALIZE SIO RING)
:	INPUT  R0 = MOTHERBOARD LOGICAL UNIT
:	RETURN R1 = 1 - BAD LOGCIAL UNIT
:	RETURN R1 = 0 - SUCESSFUL RETURN
:	....................................................................
					:
   IF	KIOSRC				:
INSIOR	L	R9,RREG+(R0*4),R1	:LU INPUT
	CLHI	R9,MLUNUM		:CHECK VALIDITY
	JLEFS	INS1			:OK
	LIS	R2,1			:
	ST	R2,RREG+(R1*4),R1	:ERROR RETURN
	J	KRET			:
INS1	SLLS	R9,2			:MAKE INDEX
	L	R9,MLUTBL,R9,		:GET MB TABLE ENTRY
	EXBR	R9,R9			:
	LBR	R3,R9			:STARTING DESCRIPTOR
	EXHR	R9,R9			:
	LBR	R4,R9			:NO OF DESCRIPTORS
	EXBR	R9,R9			:
	LBR	R5,R9			:DEVICE NUMBER
	JAL	R13,INITBD		:INITIALIZE BOARD
	L	R1,USER			:GET UB PTR BACK, MAN
	LIS	R2,0			:
	ST	R2,RREG+(R1*4),R1	:SUCESSFUL RETURN
	J	KRET			:
   EI  (KIOSRC)				:
					:
:	....................................................................
		SUBTTL	SVC 3,IO (CONNECT I/O)
:	....................................................................
					:
CONIO	LHI	R11,-10			:SET MASK
	NH	R11,F1ARGL		:GET OP #
	JLFS	CONIO1			:SKIP IF QUERY
					:
:	....................................................................
:	NORMAL (NON-QUERY) REQUEST
:	....................................................................
					:
	SRHLS	R11,2			:MAKE A WORD INDEX
	CLHI	R11,NIOT		:RANGE CHECK
	JL	CONIOT,R11		:OK...GO TO APPROPRIATE ROUTINE
	J	KRET			:OUT OF RANGE...NORMAL RETURN
					:
:	....................................................................
:	QUERY ATTRIBUTES
:	....................................................................
					:
CONIO1	LIS	R4,0F			:SET A MASK
	NH	R4,F1ARGL		:PICK UP THE REGISTER POINTER
	CLHI	R4,0D			:3 REGS GIVEN, SO CHECK RANGE
	JG	KRET			:WE'RE NOT TO GO THROUGH THE HASSLE OF FOLDING REGS
	SLHLS	R4,2			:OK...MAKE WORD INDEX
	L	R12,RREG+4,R4,R1	:CHECK BUFFER POINTER PRESENTED
	LHL	R13,RPSW+2,R1		:VERIFY PSW
	JAL	R11,ACCESS		:GO CHECK
	J	KRET			:BAD REFERENCE...NORMAL RETURN
	LHL	R5,RREG+2,R4,R1		:OK...GET THE LU NUMBER
	LCS	R0,2			:SET RANGE CHECK DIAGNOSTIC (0FE)
	CLHI	R5,NLU			:RANGE CHECK ON LOGICAL UNIT NUMBER
	JGEFS	CONIO2			:SKIP IF TOO BIG
	SLHLS	R5,2			:OK...MAKE WORD INDEX
	LB	R0,LUN,R5,R1		:GET THE LOGICAL UNIT TYPE CODE
	L	R6,LUN,R5,R1		:GET THE LOGICAL UNIT POINTER
	JNFS	CONIO2			:NOT NULL...SKIP
	LCS	R0,1			:NULL...SET NO DEVICE (0FF)
CONIO2	STB	R0,0,R12		:INTO USER BUFFER
	LR	R0,R0			:CHECK ERROR CONDITION
	JL	KSKIP			:AND SKIP RETURN IF NOTHING ELSE TO DO
	LHL	R4,RREG+0A,R4,R1	:FIND HOW MANY ATTRIBUTES HE WANTS
	LB	R0,0,R6			:AND HOW MANY ATTRIBUTES THERE ARE
	CLR	R0,R4			:TAKE MIN OF THIS NUMBER
	JGEFS	CONIO3			:
	LR	R4,R0			:
CONIO3	CLHI	R4,1			:CHECK IF WE'VE NOTHING TO SEND
	JL	KSKIP			:EXIT IF NOT
CONIO4	LB	R0,0,R4,R6		:ELSE COPY ATTRIBUTES
	STB	R0,0,R4,R12		:
	SIS	R4,1			:
	JGBS	CONIO4			:DO FOR ALL
	J	KSKIP			:THEN EXIT
					:
CONIOT	HS	0			:
   if	NSYNC				:
	J	CIN			:OP=0...CONNECT INPUT
	J	COUT			:OP=1...CONNECT OUTPUT
	J	CFORCE			:OP=2...FORCE OUTPUT
   else					:
	J	KRET			:OP=0...NOT IMPLEMENTED
	J	KRET			:OP=1...NOT IMPLEMENTED
	J	KRET			:OP=2...NOT IMPLEMENTED
   ei  (NSYNC)				:
   if	NASYNG				:
    if	ASYNEW-1			:
	J	KRET			:USING NEW DRIVER ONLY
    else				:
	J	CASY			:
    ei (ASYNEW-1)			:
   else					:
	J	KRET			:OP=3...NOT IMPLEMENTED
   ei  (NASYNG)				:
   if	NPRINT				:
	J	PROUT			:OP=4
	J	PRFORC			:OP=5
   else					:
	J	KRET			:OP=4...NOT IMPLEMENTED
	J	KRET			:OP=5...NOT IMPLEMENTED
   ei  (NPRINT)				:
   if	NSYNC				:
	J	NCSYNC			:OP=6...T-II SYNC-LINE CONNECT
	J	NCSKP			:OP=7...T-II SYNC-LINE IDLE TEST
	J	NCPARM			:OP=8...T-II READ SYNC PARAMETERS
   else					:
	J	KRET			:OP=6...NOT IMPLEMENTED
	J	KRET			:OP=7...NOT IMPLEMENTED
	J	KRET			:OP=8...NOT IMPLEMENTED
   ei  (NSYNC)				:
   if	M.NCARD				:
	J	CMBRD			:OP=9...CONNECT MBOARD
	J	CMBRDI			:OP=10d...CONNECT MBOARD INPUT
	J	CMBRDO			:OP=11d...CONNECT MBOARD OUTPUT
   else					:
	J	KRET			:OP=9...NOT IMPLEMENTED
	J	KRET			:OP=10d...NOT IMPLEMENTED
	J	KRET			:OP=11d...NOT IMPLEMENTED
   ei  (M.NCARD)			:
   if	NASYNG				:
    if	ASYNEW				:
     if NEWARN				:
	J	KRET			:
     else				:
	J	NCASY			:OP=12D ...CONNECT NEW ASYNC DRIVER
     ei					:
    else				:
	J	KRET			:
    ei (ASYNEW)				:
   else					:
	J	KRET			:
   ei  (NASYNG)				:
   if	IPNMBR				:OP=13D .. CONNECT IPI
	J	CIPI			:OP=13D .. CONNECT IPI
   else					:
	J	KRET			:OP=13D ...NOT IMPLEMENTED
   ei  (IPNMBR)				:
					:
   IF	NASYNG				:
    IF	ASYNEW				:Op=14d ... Connect new Async driver
     IF	NEWARN				:
	J	NCASY			:with the new Async ring structure
     ELSE				:
	J	KRET			:
     EI
    ELSE				:
	J	KRET			:
    EI (ASYNEW&NEWARN)			:
   ELSE					:
	J	KRET			:
   EI  (NASYNG)				:
					:
NIOT	EQ	.-CONIOT		:SIZE OF TABLE

 if	NSYNC
	LO	SYNC
:	...............................................................
:	****	CONNECT SYNC INPUT OP=0	****
:		SKIP RETURN IF SUCCESSFUL
:	...............................................................
					:
CIN	LIS	R12,0			:SET TYPE 0 DEVICES
	JAL	R11,CCHECK		:GO CHECK OUT THE FIRST 2 ARGUMENTS
	J	KRET			:BAD REFERENCE...ABORT
 if	HMICRO!TSI!NANO			:
	LH	R6,LINIT,R5		:IS LINE INITIALIZED YET?
	JE	SREPOP			:REPOP OR RETURN
 ei    (HMICRO!TSI!NANO)		:
	LR	R6,R12			:OK...SAVE ABSOLUTE START ADDRESS
	LR	R12,R7			:COPY BACK START ADDRESS
	L	R7,RREG+8,R4,R1		:GET THIRD ARGUMENT
	JLE	KRET			:RANGE MUST BE .GT. 0
	AR	R12,R7			:COMPUTE BUFFER END ADDRESS
	LHL	R13,RPSW+2,R1		:PICK UP PSW
	JAL	R11,ACCESS		:CHECK OUT THIS ADDRESS
	J	KRET			:ABORT IF OUT OF RANGE
	LIS	R12,0			:ALL OK...INITIALIZE THE BUFFER
	STH	R12,CII,R6		:SET UP CURRENT-INPUT-INDEX
	STH	R7,IFP,R5		:SET UP INPUT-FOLD-POINT
	ST	R6,IBA,R5		:SET UP INPUT-BUFFER-ADDRESS...NOW CONNECTED
 if	ESYNCI				:
	LHL	R8,OESIPT,R5		:GET PTR TO ENHANCED SYNC INTERRUPT BLOCK
	LB	R9,OPIX,R5		:INTERRUPT VECTOR OFFSET
	CLHI	R7,100			:CHECK INPUT RING SIZE
	JNFS	CIN1			:CAN'T USE MICROCODE INTERRUPT HANDLING
	LHL	R7,SLOT,R1		:WE CAN USE MICRO-CODE...
	STH	R7,OSLOTO,R5		:SET UP SLOT-OWNER FIELD
	LA	R7,S.ZAPS		:INPUT INTERRUPTS SHOULD NEVER HAPPEN NOW
	JFS	CIN2			:AND SKIP
CIN1	LA	R6,CIINUL		:FORCE MICROCODE TO TAKE SOFTWARE INTERRUPT
	LA	R7,S.IN			:SET UP CONVENTIONAL INPUT INTERRUPT VECTOR
CIN2	ST	R6,CIIPTR,R8		:STORE INPUT RING POINTER
	STH	R7,SYNVEC,R9		:STORE INTERRUPT VECTOR
 ei    (ESYNCI)				:
	J	KSKIP			:SKIP RETURN TO USER
					:
:	...............................................................
:		****	CONNECT SYNC OUTPUT OP=1	****
:			SKIP RETURN IF SUCCESSFUL
:	...............................................................
					:
COUT	LIS	R12,0			:SET TYPE 0 DEVICES
	JAL	R11,CCHECK		:GO CHECK OUT THE FIRST 2 ARGUMENTS
	J	KRET			:BAD REFERENCE...ABORT
 if	HMICRO!TSI!NANO			:
	LH	R6,LINIT,R5		:IS LINE INITIALIZED YET?
	JE	SREPOP			:REPOP OR RETURN
 ei    (HMICRO!TSI!NANO)		:
	LB	R6,OPIX,R5		:GET INTERRUPT INDEX
	LA	R8,S.MARK		:SET MARK ADDRESS
	LHI	R13,20F0		:
	EPSR	R11,R13			:*F*DISABLE IMMEDIATE INTERRUPTS
	CLH	R8,SYNVEC+2,R6		:*F*CHECK IF OUTPUT IS IN PROGRESS
	JEFS	COUT2			:*F*SKIP IF NOT
COUT1	EPSR	R13,R11			:*F*ELSE RE-ENABLE INTERRUPTS
	J	KRET			:NORMAL RETURN IF IN USE
					:
COUT2	LH	R13,OOP,R12		:*F*CHECK FOR OVERRUN
	JEBS	COUT1			:*F*ABORT IF SO
	EPSR	R13,R11			:*F*ELSE RE-ENABLE INTERRUPTS
	J	CFORC1			:AND SKIP TO SET UP
					:
:	.......................................................................
:		****	FORCE SYNC OUTPUT OP=2	****
:			SKIP RETURN IF SUCCESSFUL
:	.......................................................................
: This code has been modified to handle segmentation issues for sync.
: there are two cases -- mac5 and non-mac5. It is required that
: output descriptors and buffers be in the same segment (as documented
: in the ISIS programers reference manual). In MAC5 virtural segments
: can be 1 meg this should not be a restriction. In non-mac5 cases the
: requirement is modified to check that the descriptors and buffers 
: are located in the slot space. If the descriptors and the buffers 
: overflow a segment and are in contiguous full segments, sync output 
: will work. It remains the slot responsibility to adhere to that
: requirement. In case of a range error, a context value is stored at dv8.f
: and the offending value is stored at r4.f (for the last case).
: The device address will be found at r2.f.
:					:
CFORCE	LIS	R12,0			:SET TYPE 0 DEVICES
	JAL	R11,CCHECK		:GO CHECK OUT THE 2 ARGUMENTS
	J	KRET			:BAD REFERENCE...ABORT
   if	HMICRO!TSI!NANO			:
	LH	R6,LINIT,R5		:IS LINE INITIALIZED YET?
	JE	SREPOP			:REPOP OR RETURN
   ei  (HMICRO!TSI!NANO)		:
	LB	R6,OPIX,R5		:OK...GET INTERRUPT INDEX
	LA	R8,S.MARK		:FORCE MARKING IN CASE INTERRUPTS OCCUR
	STH	R8,SYNVEC+2,R6		:
CFORC1	SR	R7,R12			:COMPUTE OFFSET BETWEEN GIVEN AND REAL ADDRESS
:	AR	R15,R14			:COMPUTE HIGH LIMIT
	if	macv
	ar	r15,r14			:comput high limit
	else				:non-mac5 case
	l	r1,user,,		:ubs0
	l	r2,control,r1		:ubx0
	lhl	r15,cmax,r2		:slot size in pages
	l	r2,sbase,r2		:slot start space
	l	r14,ctasiz,r2		:
	ahi	r14,0ff			:take to next segment
	ar	r14,r2			:slot + cta
	nhi	r14,-100		:adjust
	slls	r15,macpag		:size in bytes
	ar	r15,r2			:slot + size
	ahi	r15,-1			:adjust
	ei	(macv)
:
	STM	R14,OALL,R5		:SET UP LOW AND HIGH LIMITS
	ST	R7,OAO,R5		:SET OUTPUT ADDRESS OFFSET
   if	HMICRO!TSI!NANO			:
   else					:
	LH	R13,0,R12		:CHECK FIRST ENTRY IN ROTOR
	SIS	R13,4			:
	JNFS	CFORC2			:SKIP IF NOT "SET RS"
	LH	R13,OLBITX,R5		:"SET RS" COMMAND...APPLICABLE?
	JLFS	CFORC2			:SKIP IF NOT
	RBT	R13,SDTR		:YES...WE DO THIS HERE SINCE NO INTERRUPTS...
	LHI	R13,0BF			:  UNTIL WE TURN ON "RS"
	WD	R13,SDTR+1		:
    if	XSYNC				:
	LHI	R13,0FF			:
	WD	R13,SDTR+3		:
    ei (XSYNC)				:
	AIS	R12,8			:ADVANCE TO NEXT ROTOR ENTRY
   ei  (HMICRO!TSI!NANO)		:
CFORC2	ST	R12,ODA,R5		:AND SET OUTPUT DISCRIPTOR ADDRESS
	LA	R12,S.CHEK		:LET DRIVER DO CHECKING OF LISTS
	STH	R12,SYNVEC+2,R6		:
   IF	HMICRO!TSI!NANO			:
	LHL	R13,OESIPT,R5		:GET ENHANCED SYNC DESCRIPTOR
	LHL	R12,OIX,R13		:GET INDEX FOR MICROCODE INT.
	JLEFS	CFORC3			:LEAVE MICROCODE ALONE
	LHI	R12,0			:
	STH	R12,OIX,R13		:ZERO INDEX FOR MICR. INTERRUPT
   EI  (HMICRO!TSI!NANO)		:
CFORC3	J	KSKIP			:THEN RETURN
					:
:	.......................................................................
:
:	SPECIAL SOFTWARE FOR THE TYMNET-II NODE CODE EXECUTING UNDER ISIS.
:
:	T-II SYNC-LINE CONNECT SVC:
:	R0	HANDLER CODE # (IF < 0, SET XDUMM)
:	R1	LOGICAL UNIT #
:	R2	OPERAND START ADDRESS
:	R3	COUNT
:	.......................................................................
					:
NCSYNC	LH	R4,RREG+4*R1+2,R1	:GET LU # FROM (R1)
	CLHI	R4,NLU			:IS IT IN RANGE?
	JGE	KRET			:IF NOT, ABORT
	SLHLS	R4,2			:MAKE WORD INDEX
	LB	R5,LUN,R1,R4		:VERIFY THAT THIS IS SYNC DEVICE
	JN	KRET			:ABORT IF NOT SYNC-LINE DEVICE
	L	R5,LUN,R1,R4		:R5 = POINTER TO SYNC BLOCK
   if	HMICRO!TSI!NANO			:
	LH	R6,LINIT,R5		:IS LINE INITIALIZED YET?
	JE	SREPOP			:REPOP OR RETURN
   ei  (HMICRO!TSI!NANO)		:
	LB	R4,OPIX,R5		:R4 = 4*PHYSICAL LINE #
	LH	R6,RREG+4*R0+2,R1	:(R0)...HANDLER CODE #
	JGEFS	NCSYN1			:SKIP IF NOT TIME TO TRANSMIT DUMMY RECORD
	LM	R14,RSENT+4		:
	STM	R14,XDUMM+4		:
	LCS	R14,1			:
	LCS	R15,1			:
	STM	R14,RSENT+4		:
	J	KRET			:AND RETURN
NCSYN1	NHI	R6,7			:MASK HANDLER CODE
	LA	R7,S.MARK		:DISCONNECT INTERUPT WHILE WE DIDDLE PARAMETERS
	STH	R7,SYNVEC+2,R4		:
	CLHI	R6,4			:RESET HANDLER CODE?
	JN	NCSYN4			:NO
					:
:	.......................................................................
:	VERSION 5 OF THE NODE CODE PRESENTS THE SIZE OF THE RESET PATTERN
:	IN REGISTER 3, WHILE OLDER VERSIONS ASSUME A SIZE OF 8 BYTES.  TEST THE
:	VERSION NUMBER FOR THE SLOT FROM SEG 'E', AND STORE THE NEGATIVE BYTE
:	COUNT IN 'SYRESZ'.
:	.......................................................................
					:
	L	R7,CONTROL,R1		:GET ADDRESS OF DDT USER BLOCK TO
	L	R7,SBASE,R7		: GET SLOT'S BASE ADDRESS
	LB	R8,SVERNO,R7		:GRAB VERSION NUMBER
	NHI	R8,3F			:
	SIS	R8,5			:VERSION 5 OR GREATER?
	JLFS	NCSYN2			:NO
	LIS	R7,0			:YES - COMPUTE NEGATIVE BYTE SIZE FROM
	SH	R7,RREG+4*R3+2,R1	:USER REGISTER 3
	JFS	NCSYN3			:
NCSYN2	LCS	R7,8			:FOR BACKWARD COMPATIBILITY
NCSYN3	STH	R7,SYRESZ		:REFERENCED IN SXRSM,SXRST...
NCSYN4	LH	R6,NCSTAB,R6,R6		:R6 = ADDRESS OF INTERRUPT CO-HANDLER
	LHL	R7,RREG+4*R2+2,R1	:R7 = (R2)...OPERAND ADDR (IN SEG 0)
	LI	R8,MMASKR		:MAKE A MASK
	LR	R9,R8			:
	N	R8,MPROT,R1		:GET BASE OF SEG 0
	N	R9,MPROT+8,R1		:GET BASE OF SEG 2
	SRLS	R8,MSHFTA		:MAKE INTO ADDRESS
	SRLS	R9,MSHFTA		:MAKE INTO ADDRESS
	ST	R8,OALL,R5		:FOR THIS USAGE, OALL == START OF SEGMENT 0
	ST	R9,OAHL,R5		:FOR THIS USAGE, OAHL == START OF SEGMENT 2
	AR	R8,R7			:PHYS ADDR OF START OF OPERAND
	ST	R8,ODA,R5		:
	LHL	R8,RREG+4*R3+2,R1	:(R3) = COUNT
	NHI	R8,0FFF			:
	JNFS	.+4			:
	LIS	R8,4			:DEFAULT IF TOO BIG
	STH	R8,OCC,R5		:
	STH	R6,SYNVEC+2,R4		:SET INTERRUPT VECTOR TO HANDLER
   IF	HMICRO!TSI!NANO			:
	LHL	R13,OESIPT,R5		:GET ENHANCED SYNC DESCRIPTOR
	LHL	R12,OIX,R13		:GET INDEX FOR MICROCODE INT.
	JLEFS	NCSKP0			:LEAVE MICROCODE ALONE
	LHI	R12,0			:
	STH	R12,OIX,R13		:ZERO INDEX FOR MICR. INTERRUPT
   EI  (HMICRO!TSI!NANO)		:
NCSKP0	J	KRET			:NORMAL RETURN
					:
:	.......................................................................
:	NCSKP:
:	SKIP IF SYNC LINE IS IDLE:
:	.......................................................................
					:
NCSKP	LH	R4,RREG+6,R1		:GET LU # FROM (R1)
	CLHI	R4,NLU			:IS IT IN RANGE?
	JGE	KRET			:IF NOT, ABORT
	SLHLS	R4,2			:MAKE WORD INDEX
	LB	R5,LUN,R1,R4		:VERIFY THAT THIS IS SYNC DEVICE
	JN	KRET			:ABORT IF NOT SYNC-LINE DEVICE
	L	R5,LUN,R1,R4		:OK...GET R11 BLOCK ADDRESS
	LB	R5,OPIX,R5		:GET LINE INDEX
	LH	R5,SYNVEC+2,R5		:INTERRUPT VECTOR
	CLHI	R5,S.MARK		:TEST IF CURRENTLY IN MARKING STATE
	JE	KSKIP			:YES...SKIP RETURN
	J	KRET			:NO...NORMAL RETURN
					:
NCSTAB	HC	S.MARK,SXATT,SXRST,SXPAK,SXRSM,S.MARK,S.MARK,S.MARK
					:
:	.......................................................................
:	TII- QUERY RETRANSMISSIONS, TRANSMISSIONS
:	R0	LOGICAL UNIT NUMBER
:	R1	WILL CONTAIN :RE-TRANS:TRANS:
:	.......................................................................
					:
NCPARM	LH	R4,RREG+2,R1		:GET LU # FROM (R0)
	CLHI	R4,NLU			:IS IT IN RANGE?
	JGE	KRET			:IF NOT, ABORT
	SLHLS	R4,2			:MAKE WORD INDEX
	LB	R5,LUN,R1,R4		:VERIFY AS SYNC TYPE
 	JN	KRET			:ELSE ERROR
	L	R5,LUN,R1,R4		:R5 - POINTER TO IO BLOCK
	L	R6,SXRTR,R5		:GET BOTH PARAMS
	ST	R6,RREG+4,R1		:PUT THEM WHERE SLOT WANTS
	LIS	R6,0			:GET A NULL
	ST	R6,SXRTR,R5		:AND ZERO ENTRYS
	J	KSKIP			:
					:
   if	HMICRO!TSI!NANO			:
:	.......................................................................
:	ROUTINE TO REPOP A SYNC SVC IF THE LINE IS NOT INITIALIZED.
:	THIS CAN ONLY OCCUR ON A HDLC MICRO-ENGINE IN SYNC EMULATION MODE.
:	IF A REPOP HAS ALREADY BEEN PERFORMED FOR THIS L.U., A NON-SKIP
:	SVC RETURN IS TAKEN.
:	.......................................................................
					:
SREPOP	TS	HRPOP,R5		:MARK AND TEST FLAG
	JL	KRET			:RETURN, IF SECOND TIME
	LHI	R4,5*RATE		:Bump 5 seconds
	A	R4,FASTC		:Add to the current time
	ST	R4,UTIME,R1		:PLACE IN USER TIMER
	LHI	R4,FTIM			:GET WAIT BIT
	OH	R4,WFLAG,R1		:COMBINE WITH CURRENT FLAGS
	STH	R4,WFLAG,R1		:MAKE NEW FLAGS CURRENT
	LIS	R4,0			:GET NULL
	STH	R4,QUANTUM,R1		:CANCEL REST OF USER'S TIME
	J	REPOP			:REPOP THE SVC
   ei  (HMICRO!TSI!NANO)		:
	FO	SYNC			:
 ei	(NSYNC)				:
					:
:	.......................................................................
:
:	CCHECK - COMMON ROUTINE TO CHECK CONNECT REGISTERS
:	EXPECTS S1=DEVICE TYPE
:	NORMAL RETURN FOR FAILURE OF ANY SORT
:	SKIP RETURN IF SUCCESS
:	THEN:	R4 = WORD INDEX TO FIRST REGISTER IN RREG
:		R5 = POINTER TO LU DISCRIPTOR
:		R7 = ADDRESS WITHIN CALLING JOB (ARG 2)
:		R12 = ADDRESS IN MEMORY (ARG 2)
:		R14 = START OF THE MAC SEGMENT
:		R15 = SIZE OF MAC SEGMENT
:
:	.......................................................................
					:
CCHECK	LIS	R4,0F			:SET A MASK
	NH	R4,F1ARGL		:PICK UP THE REGISTER POINTER
	CLHI	R4,0D			:3 REGS GIVEN, SO CHECK RANGE
	JGR	R11			:WE'RE NOT TO GO THROUGH THE HASSLE OF FOLDING REGS
	SLHLS	R4,2			:OK...MAKE WORD INDEX
	L	R5,RREG,R4,R1		:GET THE FIRST ARG
	JLR	R11			:
	CLHI	R5,NLU			:RANGE CHECK ON LOGICAL UNIT NUMBER
	JGER	R11			:
	SLHLS	R5,2			:OK...MAKE WORD INDEX
	CLB	R12,LUN,R5,R1		:CHECK DEVICE TYPE
	JNR	R11			:NOT EXPECTED DEVICE...ABORT
	L	R5,LUN,R5,R1		:GET THE LOGICAL UNIT POINTER
	JER	R11			:NULL...NOT ASSIGNED
	L	R12,RREG+4,R4,R1	:OK...CHECK SECOND ARGUMENT
	LR	R7,R12			:SAVE COPY
	LHL	R13,RPSW+2,R1		:PICK UP PSW
	J	ACCESS			:NORMAL OR SKIP RETURN VIA "ACCESS"
					:

:	.......................................................................
:	CONNECT ASYNC OP=3
:	.......................................................................
					:
 if	NASYNG				:
	LO	CLOCKS			:
   if	ASYNEW-1			:
   else					:
					:
CASY	LIS	R4,0F			:CHECK REGISTER
	NH	R4,F1ARGL		:
	CLHI	R4,8			:NOT GOING TO FOOL AROUND WITH FOLDING REGS,
	JG	KRET			:AND WE NEED 8 REGS ANYWAY
	SLHLS	R4,2			:IT'S OK...MAKE INDEX INTO REGISTER
	LA	R4,RREG,R4,R1		:SET ADDRESS FOR FIRST REGISTER
	L	R5,0,R4			:GET THAT REGISTER
	CLHI	R5,NLU			:RANGE CHECK ON LOGICAL UNIT
	JG	KRET			:
	SLHLS	R5,2			:IN RANGE...MAKE INTO WORD INDEX
	LB	R6,LUN,R1,R5		:GET SLOT'S UNIT KEY
	SIS	R6,1			:IT MUST BE = 1 FOR ASYNC
	JN	KRET			:ABORT IF NOT
	L	R5,LUN,R5,R1		:OK...GET POINTER TO UNIT
	LHL	R6,F1PS1+2		:GET PS1 FOR SUBSEQUENT MAC CHECKS
	L	R12,4,R4		:GET FIRST ARGUMENT
	JNFS	CASY1			:NOT NULL...SKIP
	ST	R12,5*4,R4		:NULL...IGNOR TOPORT
	ST	R12,6*4,R4		:IGNOR FROMPORT
	ST	R12,7*4,R4		:IGNOR TAM
	J	CASY2			:AND SKIP
CASY1	THI	R6,400			:IS HE RUNNING UNDER MAC?
	JE	CASY2			:SKIP IF NOT
	LR	R13,R12			:COPY IT
	XHI	R13,10*20-1,R12		:COMPUTE END ADDRESS
	TI	R13,-SEGSIZ		:MUST ALL EXIST WITHIN ONE SEGMENT
	JN	KRET			:
	AHI	R12,10*20-1		:
	JAL	R11,TTRW		:CHECK IT
	J	KRET			:BAD...NORMAL RETURN
	L	R12,4,R4		:OK...TRANSLATE START ADDRESS
	JAL	R11,TTRW		:
	J	KRET			:
CASY2	ST	R12,ARBP,R5		:OK...SAVE VALUE
	LHI	R7,(7-1)*4		:SET INDEX
CASY3	L	R12,4,R4,R7		:GET AN ARGUMENT
	JEFS	CASY4			:SKIP IF NULL
	LR	R13,R6			:COPY PSD
	JAL	R11,ACCESS		:CHECK IT
	 J	CASY5			:ERROR RETURN
CASY4	ST	R12,ARBP,R5,R7		:SAVE ARG
	SIS	R7,4			:
	JGBS	CASY3			:DO FOR ALL
   if	ASYNEW-1			:
   else					:
    if	ASYNEW				:
	LB	R7,1,R5			:GET PHGYSICAL UNIT NUMBER
	LIS	R4,0			:
	STH	R4,NANEW,R7,R7		:MARK OLD STYLE
    ei (ASYNEW)				:
   ei  (ASYNEW)				:
	J	KSKIP			:DONE AND SUCCESS...SKIP RETURN
CASY5	LHI	R7,(7-1)*4		:ERROR...CANCEL
	LIS	R8,0			:
CASY6	ST	R8,ARBP,R5,R7		:
	SIS	R7,4			:
	JGEBS	CASY6			:
	J	KRET			:AND DO NORMAL RETURN
   ei  (ASYNEW-1)			:
					:
:	.......................................................................
:	NEW ASYNC CONNECT
:	.......................................................................
					:
   if	ASYNEW				:
					:
:	.......................................................................
:	layout of parameter block
:	.......................................................................
					:
Q	EQ	.			:Remember where we are
	ORG	0			:
    IF	NEWARN				:Only if uses new Async ring structure
ARRSIZ	HS	1			:Async ring size (halfword)
    ELSE					:
	BS	1			:not used
ARRSIZ	BS	1			:ring size (0 = 16d)
    EI (NEWARN)				;
UNIT	HS	1			:logical unit code
RINGS	WS	1			:group ring-start address
ARRCP	WS	1			:pointer to CP bits
ARRDSR	WS	1			:pointer to DSR bits
ARRDTR	WS	1			:pointer to DTR bits
ARROUT	WS	1			:pointer to output (toport) bits
ARRIN	WS	1			:pointer to input (fromport) bits
ARRTAM	WS	1			:pointer to TAM bits
	ORG	Q			:
					:
:	.......................................................................
:	New(er) ASYNC connect
:	.......................................................................
					:
NCASY	L	R12,RREG,R1		:get parameter-block pointer
	LHL	R13,RPSW+2,R1		:get PSW status
	JAL	R11,ACCESS		:convert to physical address
	J	KRET			:no access...normal return
	LR	R10,R12			:save pointer to parameters
	LHL	R4,UNIT,R10		:get LUN number
	CLHI	R4,NLU			:range-check on unit number
	JG	KRET			:out of range...error
	SLHLS	R4,2			:make LU into word index
	LB	R9,LUN,R4,R1		:get LUN entry
	SIS	R9,1			:must be type 1
	JN	KRET			:wrong type...ERROR
	L	R9,LUN,R4,R1		:get LU pointer
	L	R12,RINGS,R10		:Get pointer to start of rings
	LR	R13,R12			:copy it
   IF	NEWARN				:Only if uses new Async ring structure
	LH	R0,ARRSIZ,R10		:Get (variable) array size
   ELSE					:
	LB	R0,ARRSIZ,R10		:get (variable) array size
   EI  (NEWARN)				:
	JNFS	NCASY1			:skip if not zero
	LHI	R0,10			:else default to 16d
NCASY1	CLHI	R0,8			:range check on size
	JL	KRET			:normal return if too small
	THI	R0,1			:
	JN	KRET			:...or if not even
	LR	R14,R0			:compute range
	SLLS	R14,5			:*20
	LR	R15,R14			:COMPUTE END-ADDRESS
	AR	R15,R12			:
	XHI	R13,-1,R15		:
	TI	R13,-SEGSIZ		:MUST all exist within one segment
	JN	KRET			:
	AHI	R12,-1,R14		:
	JAL	R11,TTRW		:Check it
	J	KRET			:bad...normal return
	L	R12,RINGS,R10		:OK...translate start address
	JAL	R11,TTRW		:
	J	KRET			:
	LR	R7,R12			:Save copy
	L	R12,ARRIN,R10		:get input array
	JAL	R11,TTRW		:
	J	KRET			:
	LR	R6,R12			:save it
	SLLS	R6,3			:make it a bit index
	L	R12,ARROUT,R10		:get output array
	JAL	R11,TTRW		:translate address
	J	KRET			:
	LR	R5,R12			:save it
	SLLS	R5,3			:bit index
					:
   IF	NEWARN				:Only if uses new Async ring structure
   ELSE					:
	L	R12,ARRTAM,R10		:and TAM
	JAL	R11,TTRW		:
	J	KRET			:
   EI  (NEWARN)				:
					:
	LB	R8,1,R9			:locate physical group number
   if	ASYNEW&1			:if = 1, must distinguish old from new
	TS	NANEW,R8,R8		:set new type
   ei  (ASYNEW&1)			:
					:
   IF	NEWARN				:Only if uses new Async ring structure
	LR	R4,R8			:Make copy of group number
	SLHLS	R4,5			:Make half word index
   ELSE					:
	LR	R4,R12			:
	SLLS	R4,3			:Bit index
   EI  (NEWARN)				:
					:
	SLHLS	R8,6			:make index pointer
					:
   IF	NEWARN				:Only if uses new Async ring structure
	SIS	R0,6			:Ring size for drivers
	AR	R7,R0			:Point to the input BCT
   ELSE					:
   EI  (NEWARN)				:
					:
NCASY2	ST	R7,ARIR,R8,		:pointer to input ring
					:
   IF	NEWARN				:Only if uses new Async ring structure
	STH	R0,AR.RS,R4		:Ring size
	AR	R7,R0			:
	AIS	R7,6			:Point at output ring
   ELSE					:
	STB	R0,ARIR,R8,		:ring size
	AR	R7,R0			:point at output ring
   EI  (NEWARN)				:
					:
	ST	R7,AROR,R8,		:pointer to output ring
					:
   IF	NEWARN				:
	AR	R7,R0			:Point at the next ring
	AIS	R7,6			:
   ELSE					:
	STB	R0,AROR,R8,		:ring size
	AR	R7,R0			:pointer to next ring
   EI  (NEWARN)				:
					:
	ST	R6,BFI,R8,		:set up data array
	ST	R5,BFO,R8,		:and data array
					:
   IF	NEWARN				:Only if uses new Async ring structure
	AIS	R4,2			:
   ELSE					:
	ST	R4,TAM,R8,		:and TAM
	AIS	R4,1			:
   EI  (NEWARN)				:
					:
	AIS	R5,1			:
	AIS	R6,1			:for one bit each direction
	AIS	R8,4			:
	THI	R8,3F			:until done
	JN	NCASY2			:
	L	R12,ARRCP,R10		:locate CP array
	JAL	R11,TTRW		:translate
	J	KRET			:
	ST	R12,ACPP,R9		:set it up
	L	R12,ARRDSR,R10		:get DSR array
	JAL	R11,TTRW		:check it
	 J	NCASY3			:
	ST	R12,ADSRP,R9		:save it
	L	R12,ARRDTR,R10		:DTR pointer
	JAL	R11,TTRW		:
	 J	NCASY3			:
	ST	R12,ADTRP,R9		:save it
	L	R12,ARROUT,R10		:
	JAL	R11,TTRW		:
	 J	NCASY3			:
	ST	R12,ATOPP,R9		:
	J	KSKIP			:finished...skip return to slot
					:
NCASY3	LHI	R7,(7-1)*4		:ERROR...cancel request
	LIS	R8,0			:
NCASY4	ST	R8,ARBP,R9,R7		:
	SIS	R7,4			:
	JGEBS	NCASY4			:
	J	KRET			:and do normal-return to slot
					:
   ei  (ASYNEW)				:
	FO	CLOCKS			:
 ei    (NASYNG)				:


   IF	NPRINT				:

	LO	PRINT			:

					:
:	.......................................................................
:	CONNECT PRINTER OP = 4
:	SKIP RETURN IF SUCCESSFUL
:	.......................................................................
					:
PROUT	LIS	R12,2			:SET TYPE 2 DEVICES
	JAL	R11,CCHECK		:GO CHECK OUT THE FIRST 2 ARGUMENTS
	J	KRET			:BAD REFERENCE...ABORT
	L	R6,COC,R5		:CHECK IF OUTPUT IS IN PROGRESS
	JN	KRET			:NORMAL RETURN IF IN USE
	JFS	PRFOR1			:AND SKIP TO SET UP
					:
:	.......................................................................
:	FORCE PRINTER OP=5
:	SKIP RETURN IF SUCCESSFUL
:	.......................................................................
					:
PRFORC	LIS	R12,2			:SET TYPE 2 DEVICES
	JAL	R11,CCHECK		:GO CHECK OUT THE FIRST 2 ARGUMENTS
	J	KRET			:BAD REFERENCE...ABORT
PRFOR1	SR	R7,R12			:COMPUTE OFFSET BETWEEN GIVEN AND REAL ADDRESS
	AR	R15,R14			:COMPUTE HIGH LIMIT
	STM	R14,OALL,R5		:SET UP LOW AND HIGH LIMITS
	L	R6,RREG+8,R4,R1		:GET THIRD ARG
	JL	PRFOR3			:SKIP IF NEGATIVE (MAINTAIN CURRENT USAGE)
	JEFS	PRFOR2			:SKIP IF = 0 (TURN OFF)
	LHL	R11,F1PS1+2		:CHECK IF UNDER MAC
	THI	R11,400			:
	JEFS	PRFOR2			:SKIP IF NOT
	SR	R6,R7			:ELSE MAKE ABS ADDRESS
	CLR	R6,R14			:
	JL	KRET			:RANGE CHECK
	CLR	R6,R15			:
	JGE	KRET			:
PRFOR2	ST	R6,PRSTAT,R5		:SAVE POINTER TO STATUS
PRFOR3	LHL	R13,OOP,R12		:GET NEW OUTPUT OPERATION
	SLHLS	R13,2			: *4
	CLHI	R13,NPRFOR		:RANGE CHECK
	JL	PRFORT,R13		:IN RANGE...GO TO APPROPRIATE HANDLER
	J	KRET			:OUT OF RANGE...IGNORE, NORMAL RETURN
					:
PRFORT	J	PROUT0			:0---HALT
	J	PROUT1			:1---OUTPUT
	J	PROUT2			:2---TRANSFER
NPRFOR	EQ	.-PRFORT		:4*NUMBER OF ENTRIES
					:
PROUT0	ST	R13,COC,R5		:0---HALT OP...TURN OFF OUTPUT
	J	KSKIP			:AND DO SKIP RETURN
PROUT1	LIS	R13,0			:1---SET UP AN OUTPUT OPERATION
	ST	R13,COC,R5		:CANCEL ANY CURRENT OUTPUT
	SH	R13,OCT,R12		:GET NEGATIVE COUNT
	L	R14,OSP,R12		:GET OUTPUT STRING ADDRESS
	SR	R14,R7			:MAKE ABSOLUTE ADDRESS
	STH	R13,OCC,R5		:SET OUTPUT-CHARACTER-COUNT
	ST	R7,OAO,R5		:SET OUTPUT-ADDRESS-OFFSET
	ST	R12,ODA,R5		:SET OUTPUT-DISCRIPTOR-ADDRESS
	ST	R14,COC,R5		:SET OUTPUT-CURRENT CHARACTER
	J	KSKIP			:AND EXIT VIA SKIP RETURN
PROUT2	LIS	R13,0			:2---TRANSFER
	STH	R13,OOP,R12		:CLEAR GIVEN OP
	L	R12,OSP,R12		:GET TRANSFER ADDRESS
	SR	R12,R7			:COMPUTE ABSOLUTE ADDRESS
	CL	R12,OALL,R5		:CHECK LOW LIMIT
	JL	KRET			:TOO LOW...NORMAL RETURN
	CL	R12,OAHL,R5		:CHECK HIGH LIMIT
	JL	PRFOR3			:IN RANGE OF MAC SEGMENT...CONTINUE
	J	KRET			:TOO HIGH...NORMAL RETURN
	FO	PRINT			:
   ei  (NPRINT)				:


					:
:	.......................................................................
:	SVC 3, OP = 9 CONNECT Motherboard
:	SKIP RETURN IF SUCCESSFUL
:	.......................................................................
					:
  IF	M.NCARD				:Only if Motherboard is defined
CMBRD	LIS	R4,0F			:LOCATE REGISTER
	NH	R4,F1ARGL		:Pick up the register pointer
	CLHI	R4,R12			:NOT GOING TO FOOL AROUND WITH FOLDING REGS
	JG	CMBER1			:
	SLHLS	R4,2			:OK...MAKE WORD INDEX
	LHL	R15,RREG+2,R4,R1	:GET HIS REGISTER
	CLHI	R15,NLU			:RANGE CHECK
	JG	CMBER2			:BAD UNIT...NORMAL RETURN
	SLHLS	R15,2			:MAKE WORD ADDRESS
	LB	R5,LUN,R15,R1		:VERIFY DEVICE TYPE
	SIS	R5,4			:...MUST BE TYPE 4
	JN	CMBER2			:ELSE NORMAL RETURN...WRONG DEVICE TYPE
	L	R5,LUN,R15,R1		:OK...GET L.U. POINTER
	LO	MBOARD			:
	LHL	R2,M.CHNA,R5		:GET DEVICE ADDRESS
	JAL	R11,DEE			:WAIT FOR NOT BUSY
	L	R12,RREG+4,R4,R1	:NOW GET LOW ADDRESS
	LR	R6,R12			:VIRTUAL ADDRESS...LOWER LIMIT
	LHL	R13,RPSW+2,R1		:LOCATE HIS PSW BITS
	JAL	R11,ACCESS		:SEE IF HE CAN ACCESS AREA
	J	CMBER5			:ACCESS NOT ALLOWED
					:
:	.......................................................................
:	R12 has the Physical address on return from ACCESS
:	.......................................................................
					:
   IF	MACV				:
	CLI	R12,SEGSIZ		:DMA address must be within the first
	JG	CMBER5			:Megbyte of low core memory ...
   EI  (MACV)				:
	SR	R12,R6			:RELOCATION
	LR	R7,R12			:
	SRLS	R7,4			:R7 = RELOCATION CHUNK
	L	R12,RREG+8,R4,R1	:NOW GET HIGH ADDRESS
	LR	R8,R12			:SAVE COPY OF VIRTUAL HIGH ADDRESS
	LR	R13,R8			:Make another copy of high address
	SRLS	R13,4			:Save it for quick comparsion on doing
	STH	R13,HIGHWD,R5		:OUTPUT
	LHL	R13,RPSW+2,R1		:LOCATE HIS PSW BITS
	JAL	R11,ACCESS		:SEE IF HE CAN ACCESS AREA
	J	CMBER5			:ACCESS NOT ALLOWED
					:
:	.......................................................................
:	R12 has the Physical address on return from ACCESS
:	.......................................................................
					:
   IF	MACV				:
	CLI	R12,SEGSIZ		:Address must reside within low core
	JG	CMBER5			:
   EI  (MACV)				:
	SR	R8,R6			:COMPUTE WINDOW SIZE
	SRLS	R6,4			:R6 = LOW CHUNK ADDRESS (VIRTUAL)
	STH	R6,LOWWND,R5		:Save low chunk address
	SRLS	R8,4			:R8 = WINDOW SIZE (CHUNKS)
	LI	R9,80000000		:SET FLAG
	L	R12,RREG+0C,R4,R1	:NOW GET STATUS ADDRESS
	JE	CMBRD2			:SKIP IF NULL
	THI	R12,0F			:ELSE CHECK BOUNDARY
	JN	CMBER5			:MUST BE BND10
	LR	R10,R12			:COPY HIS ADDRESS
	LHL	R13,RPSW+2,R1		:LOCATE HIS PSW BITS
	JAL	R11,ACCESS		:SEE IF HE CAN ACCESS AREA
	J	CMBER5			:ACCESS NOT ALLOWED
   IF	MACV				:
	CLI	R12,SEGSIZ		:Address must reside within low core
	JG	CMBER5			:
   EI  (MACV)				:
	LR	R9,R12			:COPY ADDRESS
	SRLS	R10,4			:MAKE "QUAD-WORD ADDRESS"
	STH	R10,M.USTAT,R5		:SAVE USER VIRTUAL STATUS ADDRESS
CMBRD2	ST	R9,M.STAT,R5		:OK...SAVE ADDRESS
	OHI	R2,7000			:ISSUE A RESET
	WDR	R2,R2			:
	JAL	R11,DEE			:WAIT FOR NOT BUSY
	SHI	R2,5000			:2...RELOCATION
	WDR	R2,R7			:RELOCATION
	JAL	R11,DEE			:WAIT FOR NOT BUSY
	AHI	R2,1000			:3...LOWER LIMIT
	WDR	R2,R6			:
	JAL	R11,DEE			:WAIT FOR NOT BUSY
	AHI	R2,1000			:4...WINDOW SIZE
	WDR	R2,R8			:
	LR	R9,R9			:SEE IF STATUS ADDR
	JLE	KSKIP			:DONE IF NOT
	JAL	R11,DEE			:WAIT FOR NOT BUSY
	AHI	R2,1000			:5...READ STATUS
	WDR	R2,R10			:
	JAL	R11,DEE			:WAIT FOR NOT BUSY
	J	KSKIP			:AND EXIT
					:
:	.......................................................................
:	SUBR TO WAIT FOR MOTHERBOARD
:	.......................................................................
					:
DEE	LHI	R12,deeval		:SET TIMEOUT COUNTER
DEE2	SIS	R12,1			:SEE IF TIME-OUT
   IF	NANO				:
	JLEFS	CMBER			:BR IF TIMEOUT
	SSR	R2,R15			:SENSE STATUS
	JTFS	8,CMBER3		:BR IF DEVICE BUSY
	JTFS	4,CMBER4		:BR IF DEVICE UNAVAILABLE
   ELSE					:
	JLEFS	CMBER3			:BR IF BUSY TOO LONG
	SSR	R2,R15			:SENSE STATUS
	JTFS	4,CMBER4		:BR IF DEVICE UNAVAILABLE
	JTBS	8,DEE2			:LOOP IF BUSY
   EI  (NANO)				:
	JR	R11			:
					:
   if 	zitel!tsi!nano
deeval	eq	$a 64
   else
deeval	eq	$a 40
   ei	(zitel!tsi!nano)

:	.......................................................................
:	ERROR RETURNS FOR MOTHER BOARD SVC'S
:	.......................................................................
					:
CMBER3	LIS	R5,3			:ERROR 3 MOTHER BOARD BUSY
   IF	NANO				:
	JBS	DEE2			:
CMBER4	LIS	R5,4			:ERROR 4 DEVICE UNAVAILABLE
	JBS	DEE2			:
   ELSE					:
	JFS	CMBER			:
CMBER4	LIS	R5,4			:ERROR 4 DEVICE UNAVAILABLE
	JFS	CMBER			:
   EI  (NANO)				:
CMBER1	SLLS	R4,2			:ERROR 1 BAD REG
	LIS	R5,1			:
	JFS	CMBER			:
CMBER2	LIS	R5,2			:ERROR 2 ILLEGAL UNIT
CMBER	STH	R5,RREG,R4,R1		:
	J	KRET			:
CMBER5	LIS	R5,5			:ILLEGAL ADDRESS
	JBS	CMBER			:
					:
:	.......................................................................
:	SVC IO(3), OP = 10d CONNECT MOTHERBOARD INPUT
:	SKIP RETURN IF SUCCESSFUL
:	.......................................................................
					:
CMBRDI	LIS	R2,0			:SET INPUT
	JFS	CMBIO1			:AND SKIP
					:
:	.......................................................................
:	SVC IO(3), OP = 11d CONNECT MOTHERBOARD OUTPUT
:	SKIP RETURN IF SUCCESSFUL
:	.......................................................................
					:
CMBRDO	LHI	R2,1000			:SET OUTPUT
					:
CMBIO1	LIS	R12,4			:SET DEVICE TYPE 4
	JAL	R11,FCHECK		:CHECK USER ARGUMENTS
	J	CMBER2			:ABORT IF FAILED
	L	R12,M.STAT,R5		:CHECK IF INITIALIZED
	JN	CMBIO2			:BR IF INIT
	LHL	R2,M.CHNA,R5		:ELSE, SEE IF DEVICE AVAILABLE
	JAL	R11,DEE			:*OR TERMINALLY BUSY
	J	CMBER2			:ELSE, ABORT 2
CMBIO2	LHL	R15,M.CHNA,R5		:OK...GET DEVICE ADDRESS
	OR	R2,R15			:MAKE COMMAND
	JAL	R11,DEE			:WAIT FOR NOT BUSY
	LR	R6,R6			:
	JNFS	CMBIO4			:SKIP IF NOT NULL
	OHI	R2,7000			:ELSE ISSUE RESET INSTEAD
CMBIO4	WDR	R2,R6			:
	J	KSKIP			:AND EXIT
					:
:	.......................................................................
:
:	FCHECK - Fast address check for SIO I/O processes
:
:	.......................................................................
					:
FCHECK	LIS	R4,0F			:Set up a mask
	NH	R4,F1ARGL		:Pick up the register pointer
	SLLS	R4,2			:Make a full word index
	L	R5,RREG,R4,R1		:Get the first argument
	JLR	R11			:Error return on null-argument
	CLHI	R5,NLU			:Range check on logical unit number
	JGER	R11			:Range error ... return
	SLLS	R5,2			:Make a full word index
	CLB	R12,LUN,R5,R1		:Check up device type?
	JNR	R11			:Device type error...return
	L	R5,LUN,R5,R1		:Get logical unit pointer
	JER	R11			:Error return on null-not assigned
	L	R6,RREG+4,R4,R1		:OK...check the second argument
	JE	4,R11			:0 means not address but reset cmd
	SRLS	R6,4			:Make it into quadword address
	LHR	R7,R6			:Sign extend for comparion
	CLH	R7,LOWWND,R5		:Greater than start?
	JNCR	R11			:Logical compare
	CLH	R7,HIGHWD,R5		:But within the window
	JCR	R11			:Logically smaller
	J	4,R11			:
					:
	FO	MBOARD			:
  EI   (M.NCARD)			:
					:

 if	IPNMBR
:	.......................................................................
:       ***     CONNECT IPI SVC OP=0D   ***
:       SKIP RETURN IF SUCCESSFUL
:	.......................................................................
					:
CIPI	L	R4,F1SVC		:
	L	R4,F1ARG		:
	LIS	R4,0F			:LOCATE REGISTER
	NH	R4,F1ARGL		:
	CLHI	R4,R12			:DON'T HASSLE W/ FOLDING REGISTERS
	JG	CIPER1			:BAD REGISTER ERROR
	SLHLS	R4,2			:MAKE WORD INDEX
	LHL	R15,RREG+2,R4,R1	:GET L.U.N.
	CLHI	R15,NLU			:RANGE CHECK
	JG	CIPER2			:BAD UNIT ERROR
	SLHLS	R15,2			:MAKE WORD INDEX
	LB	R5,LUN,R15,R1		:VERIFY DEVICE TYPE
	SIS	R5,5			:MUST BE TYPE 5
	JN	CIPER2			:WRONG DEVICE TYPE
	L	R5,LUN,R15,R1		:GET L.U.POINTER
	LO	IPI			:
	LB	R3,IPDNUM,R5		:GET IPI DEVICE NUMBER
	TBT	R3,IPDNBA		:IS THE IPI READY?
	JE	CIPER3			:NO--UNAVAILABLE
	LHL	R2,IPADDR,R5		:GET DEVICE ADDR
	SSR	R2,R3			:
	THI	R3,1			:
	JE	CIPER0			:SEND SSR-DETECTED CRASH MSG
	L	R12,RREG+4,R4,R1	:GET START OF I/O WINDOW
	LHL	R13,RPSW+2,R1		:GET USER PSW
	JAL	R11,ACCESS		:GET PHYSICAL ADDR OF I/O WINDOW
	J	CIPER4			:NORMAL RETURN--ACCESS NOT ALLOWED
	ST	R12,IPIOWA,R5		:SAVE PHYSICAL ADDR OF IO WINDOW
	L	R12,RREG+8,R4,R1	:GET ADDR OF STATUS AREA
	LHL	R13,RPSW+2,R1		:GET PSW
	JAL	R11,ACCESS		:SEE IF HE CAN ACCESS AREA
	J	CIPER4			:NO ACCESS
	ST	R12,IPSTAT,R5		:SAVE SLOT STATUS AREA VIRTUAL ADDR
	L	R8,DWNLOD,R5		:DOWN-LOADING CODE?
	JLFS	CIPI1			:NO, GIVE IOWADDR TO IPI
	LH	R3,IPXDDT		:HAS "E" CMD OF DDT STARTED THIS?
	JLFS	CIPDDT			:YES, DON'T DOWN-LOAD
	LI	R4,EIPDLD		:GET 'GO DOWN-LOAD' MSG
	JFS	CIPI2			:AND SEND IT
CIPDDT	LIS	R3,0			:
	STH	R3,IPXDDT		:
CIPI1	LI	R4,EIPIOW		:GET 'THIS IS I/O WINDOW ADDR' MSG
	L	R8,IPIOWA,R5		:GET IO WINDOW PHYSICAL ADDR
CIPI2	OR	R4,R8			:OR MSG W/ ADDR
	ST	R4,ETOIPM,R5		:SAVE IN MSG ARE
	L	R4,GMT,,		:GET TIME MSG SENT
	ST	R4,EIPTIM,R5		:SAVE
	LHL	R3,IPADDR,R5		:GET DEV ADDR
	LIS	R4,7			:NOW INTERRUPT
	OCR	R3,R4			:
	LIS	R4,6			:
	OCR	R3,R4			:
	J	KSKIP			:SKIP RETURN
					:
:	.......................................................................
:	HANDLE ERRORS FOR CONNECT IPI SVC--NO SKIP RETURN
:	.......................................................................
					:
CIPER0	LHI	R5,13			:SSR-DETECTED CRASH
	J	CIPERR			:
CIPER1	SLHLS	R4,2			:MAKE INTO WORD INDEX
	LIS	R5,1			:BAD REGISTER
	JFS	CIPERR			:
CIPER2	LIS	R5,2			:ILLEGAL UNIT
	JFS	CIPERR			:
CIPER3	LIS	R5,3			:DEVICE UNAVAILABLE
	JFS	CIPERR			:
CIPER4	LIS	R5,4			:ILLEGAL ADDRESS
CIPERR	STH	R5,RREG,R4,R1		:SAVE IN HI-ORDER HLFWRD OF CALLING REG
	J	KRET			:NORMAL RETURN
					:
	FO	IPI			:
  ei   (IPNMBR)				:
					:

	SUBTTL *****   CHANGE MAC SET SVC  5,MACSET   *****

:	.......................................................................
:
:	NEWMAC - CHANGE MAC CONTEXT
:
:	THE OPERAND SPECIFIES AN INDEX TO THE MAC TABLE FOR WHICH MAC SET TO 
:	USE. THIS ALSO SPECIFIES AN INDEX FOR THE NEW EXECUTION ADDRESS.
:
:	.......................................................................
					:
NEWMAC	L	R13,STAMAC,R1		:IS MAC ALREADY SET
	JE	KRET			:NO ERROR RETURN
					:
	LH	R2,F1ARGL		:GET MAC #
	CH	R2,LIMMAC,R1		:CHECK LIMIT
	JGE	KRET			:RETURN IF TO BIG
					:
	LHI	R3,$A19*4		:SIZE OF A MAC BLOCK
	MHR	R2,R3			:GET THE MAC BLOCK THE USER REQUESTED
	AR	R13,R2			:ADD BASE OF MAC TABLE
	L	R4,2,R13		:LOCATION OF NEW PSD
	LM	R14,0,R4		:GET NEW PSD
	NHI	R14,100F		:LIMIT THE NEW PSD
	OHI	R14,U.PSW		:NEW PSD
	STM	R14,RPSW,R1		:
	ST	R13,MACTRN,R1		:FOR MAC TRANSFER
   if	MULMAC				:
	LIS	R0,1			:INCREMENT COUNT
	AHM	R0,6,R13		:
	LB	R0,9,R13		:CHECK ON MAC ASSIGNMENT
	STH	R0,35C			:CHANGE TO REQUIRED MAC SET
	JN	KRET			:IF NOT 0 MAC ALREADY BUILT
    ei (MULMAC)				:
	LM	R14,MACTRN+4,R1		:CHANGE THE MAC
	COPY	R13,R15			:
	J	KRET			:DO IT!
					:
 if	SBUS
	SUBTTL	*****	C O N N E C T   S P I R I T   B U S   *****

:	This SVC is used to connect a linked list of Spirit request
:	blocks to the Spirit Bus driver. The SVC arguement is the
:	address of the first request in the list. The SVC returns
:	with a return code in R0 and the condition flags of the psw
:	set to reflect the value of R0.
:
:	Return codes:
:
:		0  -  success return, no errors detected
:		1  -  driver busy (still processing a list from a
:			previous SVC)
:		2  -  invalid address arguement
:		3  -  SVC not valid from the slot
:

	LO	SBUS

:	SPIRIT INTERRUPT CONSTANTS

SBICON	EQ	0FF00			:CONSTANT TO GENERATE AN INTERRUPT
SBILOC	EQ	37E			:LOCATION TO WRITE FOR INTERRUPT

:	SVC RETURN CODES

SBRCOK	EQ	0			:SUCCESS RETURN CODE
SBRCBU	EQ	1			:DRIVER BUSY RETURN CODE
SBRCAD	EQ	2			:INVALID ADDR ARG RETURN CODE
SBRCSL	EQ	3			:INVALID SLOT RETURN CODE

:	LOW BYTE OF RETURN PSW

SBCCS	EQ	U.PSW&0F0		:SUCCESS PSW CONDITION FLAGS (0)
SBCCE	EQ	(U.PSW&0F0)!2		:ERROR PSW CONDITION FLAGS (2)


SBSVC	SBLOG(4)
	LHL	R2,SLOT,R1		:GET USER SLOT #
	CLHI	R2,SBSLOT		:IS SVC VALID FROM THIS SLOT?
	JEFS	SBSVC1			:IF SO, CONTINUE
	LIS	R2,SBRCSL		:SET UP ERROR RET CODE
	J	SBERR			:TAKE ERROR EXIT

SBSVC1	LH	R2,SBFLAG		:IS SBUS HANDLER BUSY?
	JGEFS	SBSVC2			:IF NOT, CONTINUE
	LIS	R2,SBRCBU		:SET UP ERROR RET CODE
	J	SBERR			:TAKE ERROR EXIT

SBSVC2	ST	R1,SBUBP		:SAVE USER BLOCK POINTER
	L	R12,F1ARG		:GET ADDR OF REQ BLK QUEUE
	LHL	R13,RPSW+2,R1		:GET PSW FOR ACCESS CHECK
	JAL	R11,ACCESS		:IS ADDRESS VALID?
	J	SBSVC6			:IF NOT, ERROR EXIT
	LR	R5,R12			:GET TRANSLATED ADDRESS

SBSVC3	ST	R5,SBCRB		:PLACE CURRENT REQ BLK POINTER
	JAL	R10,SBPROC		:PROCESS THE REQUEST BLOCK
	THI	R7,ISTATD		:WAS REQUEST COMPLETED?
	JEFS	SBSVC4			:IF NOT, RETURN FROM SVC
	JAL	R10,SBNEXT		:GET NEXT SRB ON QUEUE
	JNBS	SBSVC3			:IF NOT NULL, DO NEXT
	J	SBSVC5			:IF SO, RETURN FROM SVC

SBSVC4	STH	R7,ISTAT,R5		:SAVE ISIS STATUS FLAGS
	SBLOG(5)
	IF 	SPIXPI		:INTERRUPT XPI
	LHI	R3,SBDEV
	LIS	R2,7
	OCR	R3,R2
	LIS	R2,6
	OCR	R3,R2
	ELSE
	STH	R2,SBILOC	:PASS INTERRUPT TO SPIRIT
	EI

SBSVC5	LIS	R2,SBRCOK		:SET UP RETURN CODE
	LHI	R3,SBCCS		:GET LOW BYTE OF NEW PSW
	STB	R3,RPSW+3,R1		:MAKE USER PSW
	JFS	SBRET			:EXIT

SBSVC6	LIS	R2,SBRCAD		:SET UP ERROR RET CODE

SBERR	LHI	R3,SBCCE		:GET LOW BYTE OF NEW PSW
	STB	R3,RPSW+3,R1		:MAKE USER PSW

SBRET	ST	R2,RREG,R1		:PLACE RET CODE IN USER R0
	J	KRET			:RETURN FROM SVC


:	ROUTINE TO GET THE NEXT ENTRY ON THE SRB QUEUE
:
:		ENTRY:	R1  -  USER BLOCK POINTER
:			R5  -  CURRENT REQUEST BLOCK POINTER
:			R7  -  ISTAT FLAG HW
:

SBNEXT	L	R12,LINKN,R5		:GET POINTER TO NEXT REQ BLOCK
	JE	SBN020			:IF NULL, SKIP
	LHL	R13,RPSW+2,R1		:GET USER PSW
	JAL	R11,ACCESS		:CKECK ADDRESS
	J	SBN010			:IF INVALID, SKIP
	JFS	SBN030			:IF VALID, SKIP

SBN010	OHI	R7,ISTATL		:SET LINK ERROR
	LIS	R12,0			:SET NULL NEXT REQ BLOCK

SBN020	OHI	R7,ISTATQ		:SET END OF QUEUE

SBN030	OH	R7,ISTAT,R5		:INCLUDE NEW STATUS FLAGS
	STH	R7,ISTAT,R5		:UPDATE ISIS STATUS
	SBLOG(6)
	LR	R5,R12			:SET UP SRB POINTER
	JR	R10			:RETURN


:	ROUTINE TO PROCESS AN S-BUS REQUEST BLOCK
:
:		ENTRY:	R1  -  USER BLOCK POINTER
:			R5  -  CURRENT REQUEST BLOCK POINTER
:
:		EXIT:	R2  -  CONSTANT TO GENERATE SPIRIT INT
:			R7  -  ISTAT FLAG HW
:

SBPROC	SBLOG(7)
	LIS	R7,0			:INIT ISTAT FLAG HW
	LHL	R2,MSTAT,R5		:GET MBASE STATUS AREA
	NHI	R2,(MSTATF!MSTATY)	:IS IT A SPECIAL REQUEST?
	JE	SBP010			:IF NOT, SKIP
	OHI	R7,ISTATD		:SET ISIS REQUEST DONE FLAG
	NHI	R2,MSTATF		:SHOULD REQUEST BE FLUSHED
	JER	R10			:IF NOT, RETURN
	OHI	R7,ISTATF		:SET ISIS STATUS FLUSH
	JR	R10			:RETURN

SBP010	LHI	R3,SRBLEN-2		:INIT COUNT

SBP020	LB	R6,SBSRBD+1,R5,R3	:GET DATA BYTE
	STH	R6,SBWIND+2,R3,R3	:STORE AS HW IN SBUS REQ BLK
	SIS	R3,1			:DEC COUNT
	JGE	SBP020			:IF MORE, DO NEXT
	LHL	R3,MSTAT,R5		:GET MBASE STATUS AREA
	NHI	R3,MSTATZ		:SHOULD SIO & HIO BE ZEROED?
	JE	SBP030			:IF NOT, SKIP
	LB	R3,SBSRBD+3,R5		:GET IOCB #
	AIS	R3,1			:ADJUST IT
	SLLS	R3,5			:MAKE IOCB BLK INDEX
	LIS	R4,0
	ST	R4,SBWIND,R3,		:ZERO SIO & HIO

SBP030	LHI	R2,SBBUSY
	OH	R2,SBFLAG		:SET HANDLER BUSY
	STH	R2,SBFLAG
	OHI	R7,ISTATR		:SET SENT REQUEST TO SPIRIT
	LI	R2,SBINT		:POINT TO INTERRUPT ENTRY
	ST	R2,SBRTN		:MAKE ACTIVE ROUTINE
	LHI	R2,SBICON		:GET SPIRIT INTERRUPT CONSTANT
	JR	R10			:RETURN

	FO	SBUS
 ei	(SBUS)

	SUBTTL	****	T E R M I N A L   S V C ' S	****
:	GENERAL SVC

GSVC	LHL	R5,UFLAG,R1		:CHECK FLAGS
	THI	R5,FDDT!FKIOJ		:VALID ONLY FROM DDT
	JE	NOTI			:ELSE NOT IMPLEMENTED
	LHL	R4,F1ARGL		:GET SVC TYPE
	CLHI	R4,NGSVC		:IS TYPE VALID
	JGE	NOTI			:NO - TREAT AS NOT IMPLEMENTED SVC
	SLHLS	R4,2			:INDEX WORD TABLE
	J	GSVC1,R4		:JUMP TO APPROPRIATE ROUTINE

GSVC1	J	ZAPPER			:0...LOG USER OUT
	J	EXIT			:1...TRANSFER TO DDT
	J	GETTID			:2...GET TID INTO R0
	J	ECHOON			:3...TURN ECHO ON
	J	ECHOOFF			:4...TURN ECHO OFF
	J	GOBBLE			:5...FLUSH OUTPUT BUFFER
	J	XFER			:6...TRANSFER TO ANOTHER USER BLOCK
	J	RET			:7...TRANSFER TO DEFAULT USER BLOCK FOR NAME
	J	COB			:8...CHECK OWN BACKGROUND
	J	CB			:9...CHECK ANY BACKGROUND
	J	ONUM			:10d.OUTPUT NUMBER
	J	SETZAP			:11d.SET ZAPPER HANDLING
	J	SENDYB			:12d.SEND YELLOW BALL
	J	D.TRAP			:13d.SET DDT TRAP HANDLING
	J	K.1CH			:14d.OUTPUT 1 DATA CHAR (FROM R0)
	J	DEXTRP			:15d.SET EXIT TRAP HANDLER
	J	DBGTRP			:16d.SET BKGND TRAP HANDLER
	J	DFGTRP			:17d.SET FRGND TRAP HANDLER
	J	MKRTRP			:18d.KILL DDT PROCESS
NGSVC	EQ	(.-GSVC1)/4		:NUMBER OF SPECIAL SVC'S IMPLEMENTED


:	****    OP=18D: KILL DDT PROCESS
MKRTRP	JAL	R11,RDISC		:REMOVE PREVIOUS ENTRY FROM RUN LIST
 if	SPAM
 if	SPMTRC
	LHI	R10,20			:SPAM TRACE ROUTINE ID
 ei	(SPMTRC)
	JAL	R9,ENTIM		:COLLECT END DATA
 ei	(SPAM)
	LPSW	MAINPSD			:AND GO BACK TO MAIN LOOP


:	****	OP=17D: SET FOREGROUND TRAP HANDLER    ****
:	SKIP RETURN IF SUCCESSFUL
DFGTRP	L	R4,CONTROL,R1		:GET BKGND UB ADDR
	JE	NOTI			:BAD SVC IF NONE
	L	R4,OTHER,R4		:GET FRGND UB ADDR
	JE	NOTI			:BAD SVC IF NONE
	LHI	R6,FGTRAP		:REL ADDR OF FG TRAP ADDR
	JFS	DTRP10			:GO COMPLETE TRAP SET


:	****	OP=16D: SET BACKGROUND TRAP HANDLER    ****
:	SKIP RETURN IF SUCCESSFUL
DBGTRP	L	R4,CONTROL,R1		:GET BKGND UB ADDR
	JE	NOTI			:BAD SVC IF NONE
	LHI	R6,BGTRAP		:REL ADDR OF BG TRAP ADDR
	JFS	DTRP10			:GO COMPLETE TRAP SET


:	****	OP=15D: SET EXIT TRAP HANDLER    ****
:	SKIP RETURN IF SUCCESSFUL
DEXTRP	LR	R4,R1			:GET DDT UB ADDR
	LHI	R6,EXTRAP		:REL ADDR OF EXIT TRP ADR

DTRP10	LR	R12,R0			:GET ROUTINE ADDR
	JEFS	DTRP20			:BR IF BEING RESET
	LR	R1,R4			:SET UB ADDR
	LHL	R13,F1PS1+2		:GET PSW
	JAL	R11,ACCESS		:VERIFY ACCESS
	 J	DTRP30			:BR IF BAD
	L	R1,USER			:RESTORE DDT UB ADDR
DTRP20	ST	R0,0,R6,R1		:SAVE TRAP RTN ADDR
	J	KSKIP			:SKIP RETURN

DTRP30	L	R1,USER			:RESTORE DDT UB ADDR
	J	KRET			:ERROR RETURN


:	****	OP=14D:	OUTPUT SINGLE DATA CHAR    ****
K.1CH	JAL	R15,KIOSUP		:SET UP REGISTERS
	JAL	R15,OCHK		:INSURE THERE'S ROOM
	JGE	REPOP			:NO ROOM...WAIT TIL LATER
	LBR	R12,R0			:GET USER CHAR
	CLHI	R12,7
	JGFS	K.1CH1			:SKIP IF NO ESCAPE NEEDED
	EXBR	R12,R12			:ELSE OUTPUT ESCAPED PAIR
	JAL	R15,OUT2CH
	J	KRET			:AND EXIT
K.1CH1	JAL	R15,OUT1CH		:SINGLE CHAR...OUTPUT IT
	J	KRET			:AND RETURN



:	****	OP=13D:	SET DDT TRAP-HANDLING    ****
:	SKIP RETURN IF SUCCESSFUL
D.TRAP	NHI	R5,@F1CRAS		:CLEAR CRASHED-ONCE FLAG
	STH	R5,UFLAG,R1		:SAVE AND RETURN
	LR	R12,R0			:USER'S RESTART ADDR
	JE	KSKIP			:JUST REQUEST TO TURN OFF F1CRAS
	LHL	R13,F1PS1+2		:GET PSW
	JAL	R11,ACCESS		:VERIFY ACCESS
	 J	 KRET			: BAD ACCESS - NON SKIP RETURN
	ST	R0,REST,R1		:SAVE RESTART ADDR IN USER BLOCK
	J	KSKIP			:...VIA SKIP RETURN



:	****	OP=12d	SEND YELLOW BALL    ****
SENDYB	JAL	R15,KIOSUP		:SET UP REGISTERS
	JAL	R15,OCHK		:INSURE THAT ROOM EXISTS
	JGE	REPOP			:IF NO ROOM, DISMISS, LET SVC BE RE-EXECUTED
	LHI	R12,0FF01		:THIS IS A YELLOW BALL
	JAL	R15,OUT2CH		:SEND IT
	J	KRET			:AND RETURN



:	****	OP=11d	SET ZAPPER FLAG    ****
SETZAP	OHI	R5,FZAP			:SET THE FLAG
	STH	R5,UFLAG,R1
	J	KRET			:AND RETURN



:	****	OP=10d	OUTPUT NUMBER    ****
:	This SVC expects the user to provide the following:
:	R0	binary number to be output
:	R1	control information...format:
:		x x f f.f f f f.s z b r.r r r r
:		where:
:		x	unused
:		f	output field width
:		s	signed output
:		z	zero field fill
:		b	blank field fill
:		r	Radix
:	may have cause to REPOP if insufficient space in output area for number.
ONUM	JAL	R15,KIOSUP		:SET UP REGISTERS
	JAL	R15,OCHK		:FIND SPACE REMAINING
	LH	R4,RREG+1*4+2,R1	:GET CONTROL FIELDS	T1=CONTROL
	EXBR	R5,R4			:EXTRACT FIELD WIDTH	T2=FIELD WIDTH
	NHI	R5,3F
	AR	R13,R5			:DETERMINE IF IT WILL FIT
	JGE	REPOP			:WAIT TILL NEXT TIME IF NOT
	LHI	R6,1F
	NR	R6,R4			:EXTRACT RADIX		T3=RADIX
	CLHI	R6,1
	JLE	KRET			:RADIX .LE. 1 IS TO BE IGNORED
	CLHI	R6,10
	JG	KRET			:...AS IS RADIX .GT. 10
	L	R0,RREG,R1		:OPERAND (FROM USER'S R0)
	LCS	R7,1			:DIGIT INDEX		T4=DIGIT INDEX
	LR	R9,R0			:MAKE 64-BIT OPERAND	R8,T6=NUMBER
	THI	R4,80			:DO WE WANT SIGNED OUTPUT?
	JEFS	ONUM1			:NO
	LR	R9,R9			:YES
	JGEFS	ONUM1			:NOT NEGATIVE, SO PROCEED
	LIS	R9,0			:ELSE COMPUTE COMPLEMENT
	SR	R9,R0
	SIS	R5,1			:REDUCE FIELD WIDTH FOR THIS
ONUM1	LIS	R8,0			:MAKE 64-BIT OPERAND
	DR	R8,R6			:EXTRACT A DIGIT
	LB	R12,ONUMD,R8		:TRANSLATE TO ASCII
	AIS	R7,1			:ADVANCE CHAR INDEX
	STB	R12,ONUMB,R7		:AND SAVE IT
	SIS	R5,1			:COUNT ANOTHER CHAR IN PLACE
	JLEFS	ONUM2			:QUIT IF FIELD IS EXHAUSTED
	LR	R9,R9			:CHECK QOUTIENT
	JNBS	ONUM1			:AND DO NEXT DIGIT, UNLESS DONE
	JFS	ONUM3			:ELSE SKIP
ONUM2	LR	R9,R9			:FIELD FULL...MORE DIGITS?
	JEFS	ONUM3			:NO...OK
	THI	R4,80			:SIGN-EXTENDED?
	JEFS	ONUM3			:NO...IGNOR TRUNCATION
	LHI	R12,0BE			:">"
	STB	R12,ONUMB,R7
ONUM3	THI	R4,60			:CHECK FOR ANY FILL
	JEFS	ONUM5			:SKIP IF NOT
	LHI	R12,0A0			:" " FILL
	THI	R4,40			:TEST IF ZERO FILL INSTEAD
	JEFS	ONUM4			:SKIP IF NOT
	LHI	R12,0B0			:"0"
ONUM4	SIS	R5,1			:NOW PLACE FILL CHARS
	JLFS	ONUM5			:SKIP IF FILL EXHAUSTED
	JAL	R15,OUT1CH		:ELSE PLACE CHAR
	JBS	ONUM4
ONUM5	THI	R4,80			:TEST AGAIN FOR SIGNED NUMBER
	JEFS	ONUM6			:NO...SKIP
	LR	R0,R0			:IS IT NEGATIVE?
	JGEFS	ONUM6			:NO
	LHI	R12,0AD			:"-"
	JAL	R15,OUT1CH		:YES...SIGNED OUTPUT
ONUM6	LB	R12,ONUMB,R7		:NOW OUTPUT CHARS
	JAL	R15,OUT1CH		:PLACE THE CHAR
	SIS	R7,1
	JGEBS	ONUM6			:REPEAT AS NECESSARY
	J	KRET			:THEN EXIT

ONUMD	AC	'0123456789ABCDEF'	:DIGITS
ONUMB	BS	24			:BUFFER FOR CHARACTER CONVERSION



:	****	OP=8	CHECK OWN BACKGROUND    ****
COB	LH	R0,SLOT,R1		:GET OWN SLOT INDICATOR



:	****	OP=9	CHECK ANY BACKGROUND    ****
:	R0	KEY BEING SEARCHED FOR
:	NORMAL RETURN IF NOT IN RUN LIST
:	ELSE SKIP RETURN
CB	L	R4,RUN			:START OF RUN LIST
CB1	CLH	R0,SLOT,R4		:CHECK IF CURRENT SLOT IS POSSIBLE TARGET
	JNFS	CB2			:SKIP IF NOT
	LHL	R5,UFLAG,R4		:POSSIBLE...CHECK THAT IT'S NOT DDT
	THI	R5,FDDT
	JNFS	CB2			:DDT...IGNOR
	L	R0,RPSW+4,R4		:GOT MATCH...GET TARGET'S EXECUTION ADDRESS
	ST	R0,RREG,R1		:RETURN IT IN R0
	J	KSKIP			:DO A SKIP RETURN
CB2	L	R4,LLINK,R4		:NOT THIS ENTRY...GET NEXT ONE
	JN	CB1			:KEEP SCANNING
	J	KRET			:NORMAL RETURN IF NOT FOUND



:	****	OP=7	RETURN    ****
:	RETURN CONTROL BACK TO DEFAULT SLOT (FOR USER NAME)
:	SKIP^3 RETURN IF USER DOES NOT DEFAULT TO SPECIFIC SLOT
RET	LHL	R4,GGNDX,R1		:GET USER-NAME INDEX
	LH	R0,GODGUY+GGUSE,R4,	:GET REQUESTING-USER'S DEFAULT
	JL	XFER1			:ABORT IF DEFAULT<0, ELSE FALL INTO TRANSFER



:	****	OP=6	XFER    ****
:	TRANSFER CONTROL FROM CURRENT USER-BLOCK TO ANOTHER
:	EXPECTS	R0	KEY FOR NEW BLOCK, TO WHICH TO TRANSFER CONTROL
:		R1	POINTER TO USER BLOCK ORIGINATING REQUEST
:	MAY R11 TO "OUT0A" BEFORE RETURN, IF FAILURE RETURN
XFER	LA	R12,OOPMSG		:SET "OUT OF PORTS" MESSAGE
	L	R6,LFREE		:CHECK FREE LIST
	JE	OUT0A			:FREE LIST NULL - BITCH AND NORMAL RETURN

:	VALIDATE THE USER'S REFERENCE LICENCE
	LHL	R9,GGNDX,R1		:GET INDEX FOR FUTURE USE
	THI	R5,FDDT			:CHECK TYPE OF REQUESTOR
	JEFS	XFER2			:TRUST EVERYONE BUT DDT USER
	LH	R12,GODGUY+GGUSE,R9,	:CHECK FOR REQUESTING USER FORCED
					: TO SPECIFIC KEY
	JLFS	XFER2			:HE CAN GO ANYWHERE
	CR	R0,R12			:LIMITED TO FIXED KEY ONLY
	JEFS	XFER2			:OK...SKIP TO PROCEED
XFER1	LIS	R12,0C			:NO GOOD...SET UP SKIP^3 RETURN TO USER
					: BEFORE BITCHING
	AM	R12,RPSW+4,R1
	LA	R12,BKMSG		:SET "BAD KEY" MESSAGE
	J	OUT0A			:THEN BITCH AND QUIT

:	SEARCH FOR A MATCHING SLOT
XFER2	LA	R4,LFREE		:POINTER TO BEGINNING OF FREE LIST
XFER3	CH	R0,SKEY,R6
	JEFS	XFER4			:SKIP IF MATCH
	LR	R4,R6			:ELSE TRY NEXT
	L	R6,LLINK,R6
	JNBS	XFER3			:CONTINUE UNTIL FIND AN ENTRY
	LIS	R12,4			:ELSE SET SKIP^1 RETURN
	AM	R12,RPSW+4,R1
	LA	R12,NSMSG		:SET "NO SLOT" MESSAGE
	J	OUT0A			:THEN SKIP TO GENERATE DIAGNOSTIC, RETURN

:	CHECK LICENCE REQUIREMENTS FOR NEW SLOT
XFER4	LH	R5,ULICEN,R1		:FOUND BLOCK WITH CORRECT KEY, CHECK LICENCE
	XH	R5,SLICEN,R6
	NH	R5,SLICEN,R6		:CHECK IF SLOT HAS ANY ACCESS RESTRICTIONS
	THI	R5,L.SYA!L.S0A!L.SUA
	JEFS	XFER5			:SKIP IF USER HAS ALL NECESSARY ACCESS LICENCE
	LIS	R12,8			:NO...SET SKIP^2 RETURN
	AM	R12,RPSW+4,R1
	LA	R12,NLMSG		:SET "INSUFFICIENT LICENCE FOR SLOT" MESSAGE
	J	OUT0A			:THEN BITCH AND RETURN

:	WE HAVE A VALID TRANSFER...SET IT UP
XFER5	LCS	R8,5			:TRAP RTN CODE
	JAL	R7,TRAPEX		:GO TO EXIT TRP RTN IF DEFINED
	LHL	R8,UDFLAG,R1		:COPY DISCONNECT FLAG
	JN	ZAPPER			:SAME AS ZAP-SVC IF NONE-ZERO
	STH	R8,UDFLAG,R6
	LH	R5,GGNDX,R6		:CHECK PREVIOUS USER
	CR	R5,R9			:SAME USER RE-CONNECTING?
	JEFS	XFER6			:YES...DON'T SAVE HISTORY
	STH	R5,OGGNDX,R6		:ELSE SAVE LAST USER AS PREVIOUS USER
	STH	R9,GGNDX,R6		:...AND SET NEW GG INDEX
XFER6	LHL	R8,ULICEN,R1		:COPY LICENSES
	STH	R8,ULICEN,R6
	LHL	R3,BUFNO,R1		:COPY PORT INDEX
	STH	R3,BUFNO,R6		:COPY BUFFER NUMBER
	SLHLS	R3,2			:MAKE WORD INDEX
	ST	R6,KDESTZ,R3		:REMEMBER THE DESTINATION FOR THIS JOB
	LHL	R8,TERCAR,R1		:COPY TID CHARACTER
	STH	R8,TERCAR,R6
	LIS	R8,0
	STH	R8,WFLAG,R6		:CANCEL ALL WAIT BITS
	LHI	R8,@(FZAP)		:CANCEL ZAP WAIT
	NH	R8,UFLAG,R6
	STH	R8,UFLAG,R6
	LIS	R5,0			:CLEAR USER REGISTERS
	LHI	R7,4*0F			:INDEXING BACKWARDS
XFER7	ST	R5,RREG,R7,R6		:ZERO THIS REG
	SIS	R7,4
	JGEBS	XFER7
	ST	R5,REST,R6		:CANCEL DESTINATION RESTARTS
	ST	R5,REST,R1		:...AND SOURCE'S TOO
	ST	R5,EXTRAP,R6		:SAME FOR EXIT TRAPS
	ST	R5,EXTRAP,R1
	LM	R14,INIPSW,R6		:GET INITIAL PSW
	THI	R8,FDDT			:CHECK IF THIS IS A DDT JOB
	JE	XFER10			:SKIP IF NOT
	STH	R5,MODE,R6		:YES...INSURE USER STARTS OUT IN ASCII MODE
	STH	R5,FLAG,R6		:WITH NO ^C PENDING
	LH	R8,SPSW,R6		:INITIAL STATUS BITS FOR DDT INST "G"
	STH	R8,CPSW,R6		:CURRENT STATUS BITS FOR DDT INST "G"
	LM	R14,RPSW,R6		:GET PREVIOUS PSW
	XR	R8,R14			:CHECK IF PREVIOUSLY WAS RUNNING WITH THAT STATUS
	THI	R8,0FFF0		:...EXCEPT FOR CC'S
	JNFS	XFER8			:NO...MUST HAVE BEEN DDT
	STM	R14,OLDPSW,R6		:YES...SAVE PREVIOUS USER PSW IN DDT AREA
	LCS	R8,2			:ALLOW P TO START CODE IN DDT
	ST	R8,RREG+R13*4,R6
XFER8	LM	R14,DDTPSW		:PSW TO START DDT
	L	R8,SBASE,R6		:GET CTA START ADDRESS
	LHL	R8,CNTRL+2,R8		:GET CONTROLL WORD
	THI	R8,X.DMZ.		:IS DEFUALT MAC SET 0?
	JEFS	XFER82			:IF NOT, SKIP
	L	R7,STAMAC,R6		:IS MAC 0 SET UP?
	JNFS	XFER85			:IF NOT, SKIP
XFER82	LA	R7,MPROT+MACDIS,R6	:GET -1 MACSET (TO INIT DDT MAC SET)
XFER85	ST	R7,UMAC,R6		:MAKE IT USER MAC SET
	LHI	R7,4*0F			:INDEXING BACKWARDS
XFER9	ST	R5,URSA,R6,R7		:CLEAR USER REGISTER SAVE AREA IN DDT
	SIS	R7,4			:
	JGEBS	XFER9			:
XFER10					:
   if	MULMAC				:
	LIS	R7,0			:INSURE THAT NO MAC IS PRE LOADED
	STH	R7,CCOUNT,R6		:ZERO BOTH CCOUNT AND MACSET
	STB	R7,MACSET+1,R6		:
   ei  (MULMAC)				:
	STM	R14,RPSW,R6		:FINALLY SET UP NEW PSW
	L	R7,LLINK,R6		:REMOVE TARGET ENTRY FROM FREE LIST
	ST	R7,LLINK,R4		:
	L	R7,RUN			:THREAD ONTO RUN LIST
	ST	R7,LLINK,R6		:R11 RUN LIST TO NEW BLOCK
	ST	R6,RUN			:AND PLACE ON RUN LIST
   if	SHARE				:
	STH	R5,DREQ,R1		:SHOW NO OUTSTANDING DISK REQUESTS
   ei  (SHARE)				:
	JAL	R11,RDISC		:REMOVE PREVIOUS ENTRY FROM RUN LIST
					:AND PUT BACK ON FREE LIST IF APPROPRIATE
  if	SPAM				:
   if	SPMTRC				:
	LIS	R10,0C			:SPAM TRACE ROUTINE ID
   ei  (SPMTRC)				:
	JAL	R9,ENTIM		:COLLECT END DATA
  ei   (SPAM)				:
	LPSW	MAINPSD			:AND GO BACK TO MAIN LOOP
					:
NSMSG	SC	/"8D"8Aslot in use"8D"8A/
OOPMSG	SC	/"8D"8Aout of ports"8D"8A/
NLMSG	SC	/"8D"8AUser has insufficient license for access to slot/
BKMSG	SC	/"8D"8ABad key/


:	.......................................................................
:	****	OP=5	FLUSH OUTPUT BUFFER    ****
:	.......................................................................
					:
GOBBLE	JAL	R15,KIOSUP		:SET UP REGISTERS
  IF	KIOSRC				:
	LIS	R12,1			:GOBBLER CTL MSG
	JAL	R15,CTLOUT		:SEND CONTROL MESSAGE
   if	SPAM				:
    if	SPMTRC				:
	LHI	R10,21			:SPAM TRACE ROUTINE ID
    ei (SPMTRC)				:
	JAL	R9,ENTIM		:COLLECT END DATA
   ei  (SPAM)				:
	LPSW	MAINPSD			:GIVE UP TIME SLICE
  ELSE					:
	LR	R15,R2			:
	SLHLS	R15,2			:
	L	R15,KAP,R15		:GET POINTER TO USER ATTENTION BIT
	JEFS	.+6			:IGNORE IF UNUSED
	SBT	R15,0			:
	JAL	R15,OCHK		:INSURE THAT ROOM EXISTS
	JGE	REPOP			:IF NO ROOM, DISMISS, LET SVC BE RE-EXECUTED
	LIS	R12,2			:ELSE...THIS IS A GOBBLER
	JAL	R15,OUT1CH		:SEND IT
	J	KRET			:AND RETURN
  EI   (KIOSRC)				:
					:
:	.......................................................................
:	****	OP=4	TURN ECHO OFF    ****
:	.......................................................................
					:
ECHOOFF	JAL	R15,KIOSUP		:SET UP REGISTERS
	TBT	R2,KECHO		:CHECK ECHO
	JE	KRET			:QUIT IF ALREADY OFF
	JAL	R15,OCHK		:ELSE INSURE THAT ROOM EXISTS
	JGE	REPOP			:IF NO ROOM, DISMISS, LET SVC BE RE-EXECUTED
	RBT	R2,KECHO		:ELSE TURN ECHO OFF
	LHI	R12,0C001		:THIS IS AN ECHO-OFF
	JAL	R15,OUT2CH		:SEND IT
	J	KRET			:AND RETURN
					:
:	.......................................................................
:	****	OP=3	TURN ECHO ON    ****
:	.......................................................................
					:
ECHOON	JAL	R15,KIOSUP		:SET UP REGISTERS
	TBT	R2,KECHO		:CHECK ECHO
	JN	KRET			:QUIT IF ALREADY ON
	JAL	R15,OCHK		:ELSE INSURE THAT ROOM EXISTS
	JGE	REPOP			:IF NO ROOM, DISMISS, LET SVC BE RE-EXECUTED
	SBT	R2,KECHO		:ELSE TURN ECHO ON
	LHI	R12,0C101		:THIS IS AN ECHO-ON
	JAL	R15,OUT2CH		:SEND IT
	J	KRET			:AND RETURN
					:


:	****	OP=2	GET TID INTO R0    ****
GETTID	LHL	R0,TERCAR,R1		:GET IT
	ST	R0,RREG,R1		:PLACE INTO HIS REGISTER 0
	J	KRET			:AND RETURN TO USER



:	****	OP=1	EXIT SVC    ****
EXIT	LCS	R8,4			:TRAP RTN CODE
	JAL	R7,TRAPEX		:GO TO EXIT TRP RTN IF DEFINED
	THI	R5,FDDT			:IS THIS DDT JOB?
	JE	ZAPPER			:NO
	JAL	R11,SEXIT		:YES...SET UP CONTROL TRANSFER TO DDT
	J	KRET			:RETURN TO USER DDT

:	ROUTINE TO SET UP CONTROL TRANSFER TO DDT
SEXIT	ST	R11,KLINK		:SAVE R11
	LIS	R11,0
	ST	R11,REST,R1		:CANCEL RESTART ADDRESS

:	****	THIS IS AN ENTRY POINT FROM KRASH!
SEXIT1	LIS	R11,0			:CLEAR EXIT TRAP RTN
	ST	R11,EXTRAP,R1
	LM	R8,RREG,R1		:SAVE REGS IN DDT
	STM	R8,URSA,R1
	LM	R8,RREG+4*8,R1
	STM	R8,URSA+4*8,R1
	LM	R14,RPSW,R1		:SAVE PSW IN DDT DATA SEG
	STM	R14,OLDPSW,R1
	LM	R14,DDTPSW		:BRANCH TO DDT START
	STM	R14,RPSW,R1
	L	R11,KLINK		:RESTORE R11
	JR	R11			:RETURN

:	ROUTINE TO GO TO EXIT TRAP ROUTINE IF IT IS DEFINED

TRAPEX	L	R12,EXTRAP,R1		:SEE IF DEFINED
	JER	R7			:DONE IF NOT
	LR	R3,R12			:SAVE TRAP RTN ADDR
	LIS	R13,0			:CLEAR TRAP RTN
	ST	R13,EXTRAP,R1
	LHL	R13,RPSW+2,R1		:PSW FOR ACCESS
	JAL	R11,ACCESS		:SEE IF ADDR IS VALID
	 JR	R7			:DONE IF NOT
	 NOPR
	LR	R6,R12			:SAVE PHYSICAL ADDR
	LM	R12,RPSW,R1		:SAVE PSW, PC, R0, R1 FOR TRP RTN
	STM	R12,0,R6
	NHI	R12,@100F		:TRACE/CC BITS OFF IN PSW
	LA	R13,10,R3		:START ADDR OF TRAP RTN
	LR	R14,R0			:MAYBE XFER SLOT NMBR IN R0
	LR	R15,R8			:ENTRY REASON CODE IN R1
	STM	R12,RPSW,R1		:SAVE NEW PARAMS
	J	KRET			:GO TO TRAP RTN
					:
:	....................................................................
:	SVC ZAP, OP = 0
:	....................................................................
					:
ZAPPER	LCS	R8,3			:TRAP RTN CODE
	JAL	R7,TRAPEX		:GO TO EXIT TRP RTN IF DEFINED
	JAL	R15,KIOSUP		:SET UP KERNEL I/O REGS
 if	SHARE				:
  if	NDISC				:
	TBT	R2,DPDET		:IS PORT ALREADY DETACHED?
	JEFS	ZIN1			:SKIP IF SO
  ei	(NDISC)				:
 ei	(SHARE)				:
	LH	R4,UFLAG,R1		:
	THI	R4,FLOGIN		:
	JNFS	ZIN1			:UNCONDITIONAL LOG-OFF FOR LOGIN CODE
	LH	R4,UDFLAG,R1		:CHECK DISCONNECT FLAG
	JE	ZIN2			:SKIP IF NEITHER ZAPPED, NOR ORANGE
ZIN1					:BALL RETURNED
 if	FSYS				:
	C	R1,FUSER,,		:IS FILE OPEN?
	JN	ZIN1A			:NO! JUST ZAP
					:
:	....................................................................
:	FORCE A BRANCH TO THE CLEAN-UP FILES CODE AND LET IT HANDLE CLOSING
:	THE FILES.
:	....................................................................
					:
	LA	R4,DDTCLS,,		:ADDRESS OF CLOSE FILES ROUTINE
	ST	R4,RPSW+4,R1		:
	LHI	R4,E.PSW		:
	ST	R4,RPSW,R1		:
	LHI	R5,8000			:ALLOW USER A LITTLE TIME
	STH	R5,UDFLAG,R1		:
					:
   if	SPAM				:
    if	SPMTRC				:
	LIS	R10,0A			:SPAM TRACE ROUTINE ID
    ei (SPMTRC)				:
	JAL	R9,ENTIM		:SAVE EXIT DATA
   ei  (SPAM)				:
	LPSW	MAINPSD			:RETURN TO SCHEDULAR
					:
ZIN1A	EQ	.			:
 ei    (FSYS)				:
	LIS	R4,0			:CLEAR ANY ZAPPER TIMEOUT PENDING
	STH	R4,UDFLAG,R1		:CLEAR DISCONNECT FLAG
	JAL	R11,ZINSUB		:PLACE ZAPPER IN BUFFER & CLEAN UP USER BLOCK
	JAL	R11,RDISC		:REMOVE ENTRY FROM RUN LIST
					:AND PUT BACK ON FREE LIST IF APPROPRIATE
   if	SPAM				:
	LHL	R11,SLOT,R1		:GET SLOT NUMBER
	LHL	R7,UFLAG,R1		:GET USER FLAG
	THI	R7,40			:IS THIS ENTRY FROM MAIN?
	JEFS	RECORD			:NO, SKIP SPECIAL MAIN CHECKS
	LIS	R10,9			:SPAM TRACE ROUTINE ID
	RBT	R10,UFLAG,R1		:RESET '40' BIT IN USER FLAG
	LCS	R10,1			:Must be a DDT KIO zap from main scheduler
    if .GT.(NSLOT,$A32)			:
	AM	R10,MAICNT,,		:DECREMENT MAIN COUNTER BY 1
    else				:
	AM	R10,MAICNT		:DECREMENT MAIN COUNTER BY 1
    ei (  )				:
	JFS	NOEND			:YES, DON'T RECORD ENDING
					:
RECORD	EQ	.			:
    if	SPMTRC				:
	LIS	R10,9			:SPAM TRACE ROUTINE ID
    ei (SPMTRC)				:
	JAL	R9,ENTIM		:SAVE USER EXIT DATA
NOEND	EQ	.			:
   ei  (SPAM)				:
	LPSW	MAINPSD			:AND GO BACK TO MAIN LOOP
					:
   if	SPAM				:
ZIN1B	EQ	.			:SPECIAL FLAG FOR ENTRY FROM MAIN
	LIS	R10,9			:
	SBT	R10,UFLAG,R1		:SET '40' BIT IN USER FLAG
	J	ZIN1			:
					:
ZIN1C	LIS	R10,9			:SPECIAL FLAG FOR ENTRY FROM MAIN
	SBT	R10,UFLAG,R1		:SET '40' BIT IN USER FLAG
	J	ZAPPER			:
   ei  (SPAM)				:
					:
ZIN2	LIS	R4,01			:SET FLAG TO YELLOW-BALL OUT
	STH	R4,UDFLAG,R1		:
	JAL	R15,KIOSUP		:SET-UP KERNEL I/O REGS
	JAL	R15,OCHK		:SET UP OUTPUT POINTERS
	LHI	R12,0FF01		:SEND A YELLOW BALL
	JAL	R15,OUT2CH		:
	LHI	R4,5*RATE		:BUMP 5 SECONDS
	A	R4,FASTC		:Add to the current time 
	ST	R4,UTIME,R1		:
	LHI	R4,FIN!FTIM		:
	OH	R4,WFLAG,R1		:
	STH	R4,WFLAG,R1		:INSURE JOB SLEEPS FOR 5 SECONDS
	LIS	R4,0			:
	STH	R4,QUANTUM,R1		:SHUT JOB DOWN
	J	REPOP			:RE-EXECUTE SVC IF WE SHOULD TIMEOUT
					:
ZINSUB	JAL	R15,KIOSUP		:SET-UP KERNEL I/O REGS
   IF	KIOSRC				:
	CLHI	R2,NKU			:IS IT TTY PORT?
	JNFS	ZINS0			:IF NOT, NORMAL PROCESSING
	JAL	R15,OCHK		:PLACE CIRCUIT ZAPPER HERE
	LIS	R12,3			:THIS IS A ZAPPER CHARACTER
	JAL	R15,OUT1CH		:PLACE CHAR INTO OUTPUT STREAM
	J	ZINS3			:NO CTL MSG FOR TTY
ZINS0	RBT	R2,KDZAP		:IS IT INCOMING ZAPPER
	JE	ZINS1			:IF NOT, SKIP
	LHI	R12,80			:ELSE SEND ZAP ACK CTL MSG
	JFS	ZINS2			:
ZINS1	LIS	R12,0			:ZAPPER CTL MSG
ZINS2	JAL	R15,CTLOUT		:SEND CONTROL MESSAGE
   ELSE					:
	JAL	R15,OCHK		:PLACE CIRCUIT ZAPPER HERE
	LIS	R12,3			:THIS IS A ZAPPER CHARACTER
	JAL	R15,OUT1CH		:PLACE CHAR INTO OUTPUT STREAM
	SLHLS	R2,2			:
	L	R15,KAP,R2		:GET POINTER TO USRERS ATTENTION BIT
	JEFS	.+6			:IGNORE IF NOT IN USE
	SBT	R15,0			:
	SRHLS	R2,2			:RESTORE R2
   EI  (KIOSRC)				:
ZINS3	RBT	R2,KACT			:SET PORT AS UNUSED
	LIS	R14,0			:
	ST	R14,REST,R1		:CLEAR RESTART ADDRESS
	ST	R14,EXTRAP,R1		:AND EXIT TRAP RTN
 if	SHARE				:
	STH	R14,DREQ,R1		:SHOW NO OUTSTANDING DISK REQUESTS
  if	NDISC				:
	LCS	R14,1			:
	STH	R14,DPUN,R2,R2		:TURN OFF COMMANDS
	SBT	R2,DPDET		:FLAG PORT AS NOT DETACHED
	RBT	R2,DPACT		:FLAG PORT INACTIVE
	SH	R2,DPFLAG		:RELEASE COMMAND BUFFER IF OWNED
	JNR	R11			:
	STH	R2,DPFLAG		:
  ei	(NDISC)				:
 ei	(SHARE)				:
	JR	R11			:RETURN
					:
:	....................................................................
:	INPUT SVC (TTY)
:	....................................................................
					:
TTYIN	LHL	R4,UFLAG,R1		:CHECK FLAGS
	THI	R4,FDDT!FKIOJ		:
	JE	NOTI			:VALID ONLY FROM DDT...ELSE NOT IMPLEMENTED
	LA	R8,KSKIP		:SET UP INPUT COMPLETE BRANCH TO SKIP RETURN
	JAL	R15,KIOSUP		:SET UP KERNEL-I/O REGISTERS
 if	SHARE				:
  if	TSIDT				:
  else					:
   if	NDISC				:
	TBT	R2,DPACT		:CHECK FOR ACTIVE COMMAND PROCESS
	JEFS	.+8			:
	JAL	R7,DCP,,		:CALL DISC COMMAND PROCESSOR
   ei	(NDISC)				:
  ei	(TSIDT)				:
 ei	SHARE				:
	JAL	R7,IN1			:CALL IN SVC ROUTINE, COMPLETE IN R8, FAIL IN R7
	LHL	R5,F1ARGL		:INPUT FAILURE...SAVE USER BUFFER ADDR
	STH	R5,UIN,R1		:
	NHI	R5,0FF			:ISOLATE SLEEP TIME REQUESTED
	JE	KRET			:ZERO TIME - NON SKIP RETURN
	LHI	R10,RATE		:
	MHR	R5,R10			:Multiply by rate
	A	R5,FASTC		:
	ST	R5,UTIME,R1		:WAKE UP AFTER THIS TIME
	LHL	R5,WFLAG,R1		:
	OHI	R5,FIN!FTIM		:SET IN & TIME WAIT FLAGS
	STH	R5,WFLAG,R1		:
   if	SPAM				:
    if	SPMTRC				:
	LIS	R10,6			:SPAM TRACE ROUTINE ID
    ei (SPMTRC)				:
	JAL	R9,ENTIM		:
   ei  (SPAM)				:
	LIS	R4,0			:CANCEL ANY QUANTUM REMAINING
	STH	R4,QUANTUM,R1		:
	J	MAIN			:RETURN TO MAIN SEQUENCE
					:
:	....................................................................
:	PROCESS INPUT
:	R2	INTERNAL PORT INDEX
:	R1	USER BLOCK
:	R3	KERNEL RING POINTER
:	R7	FAIL RETURN ADDRESS
:	R8	SUCCESS RETURN ADDRESS
:	R12	BUFFER INDEX OFFSET
:	PROCESS SUCH CHARS AS NEED RESPONSE, RETURNS NEXT DATA CHAR
:	....................................................................
					:
IN0	STH	R4,NOI,R3		:SAVE UPDATED POINTER
	JFS	IN2			:AND SKIP TO GET ANOTHER CHAR
IN1	EQ	.			:
   IF	KIOSRC				:
	TBT	R2,KDZAP		:Zapper received from control?
	JN	IN6A			:
   EI  (KIOSRC)				:
	LH	R4,NOI,R3		:PTR TO FIRST CHAR OF IN BUFFER
IN2	CLH	R4,NMI,R2,R2		:COMPARE TO LAST EXAMINED CHAR PTR
	JER	R7			:EXIT...INPUT NOT COMPLETE
	LB	R12,KIB,R3,R4		:READ NEXT CHAR FROM IN BUFFER
	AIS	R4,1
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R4,-KBS			:ACCOUNT FOR FOLDING
	CLHI	R12,7			:IS IT < 8
	JG	IN9			:NO...TREAT AS NORMAL CHAR
	LR	R15,R12			:NO...MAKE SPECIAL CHAR INTO WORD INDEX
	SLHLS	R15,2			:
	J	IN3,R15			:SERVICE IN APPROPRIATE MANNER
IN3	J	IN8			:0 - ESCAPE
	J	IN7			:1 - PREFIX
	J	IN0			:2 - IGNOR
	J	IN6			:3 - ZAPPER
	J	IN5			:4 - LEAVE DEM
	J	IN4			:5 - GREEN BALL
	J	IN4			:6 - RED BALL
	SBT	R2,KDEM			:7...EDEM...SET DEM ON
	J	IN0			:AND PROCEED WITH NEXT CHAR
IN4	JAL	R15,OCHK		:5 OR 6...RED OR GREEN BALL...CAN WE RETURN IT?
	JGER	R7			:ABORT FOR NOW IF NO ROOM
	JAL	R15,OUT1CH		:ELSE RETURN IT
	J	IN0			:AND PROCEED
IN5	RBT	R2,KDEM			:4...LDEM...SET DEM OFF
	J	IN0			:AND PROCEED
IN6	STH	R4,NOI,R3		:3...ZAPPER...ADVANCE POINTER
IN6A	LHL	R6,UFLAG,R1		:
	THI	R6,FZAP			:DOES HE WANT TO KNOW ABOUT ZAPPERS?
	JE	ZAPPER			:NO...JUST GO ZAP HIM
	LIS	R6,0			:
	STH	R6,WFLAG,R1		:YES...INSURE HE'S AWAKE
	LCS	R6,2			:SET UP SKIP^2 RETURN
	AM	R6,RPSW+4,R1		:(BY CANCELING SKIP^4 RETURN)
	JR	R8			:THEN TAKE SUCCESS EXIT
IN7	LB	R12,KIB,R3,R4		:1...PREFIX...LOAD NEXT CHAR
	AIS	R4,1			:ADVANCE TO NEXT CHAR
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R4,-KBS			:ACCOUNT FOR FOLDING
	CLHI	R12,0FF			:IS CHAR AFTER 1 FF? (YELLOW BALL)
	JN	IN0			:NO - IGNORE THE COMBINATION
	JAL	R15,OCHK		:YES...CAN WE RESPOND TO YELLOW BALL?
	JGER	R7			:NO...INCOMPLETE EXIT
	LHI	R12,0FE01		:YES - ECHO YELLOW BALL AS ORANGE
	JAL	R15,OUT2CH		:TRANSMIT A CHARACTER PAIR
	J	IN0			:AND THEN PROCEED
IN8	LB	R12,KIB,R3,R4		:GOT A 0 (ESCAPE)...LOAD NEXT CHAR
	AIS	R4,1			:ADVANCE TO NEXT CHAR
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R4,-KBS			:ACCOUNT FOR FOLDING
IN9	LB	R6,F1ARGL		:GET USER SPECIFIED REG
	NHI	R6,0F			:LOW ORDER 4 BITS ONLY
	SLHLS	R6,2			:INDEX WORD VECTOR
	ST	R12,RREG,R1,R6		:STORE CHAR IN USER REG
	TBT	R2,KDEM			:ARE WE IN DEM?
	JE	IN10			:NO...SKIP
	TBT	R2,KECHO		:SHOULD WE ECHO?
	JE	IN10			:NO
	TBT	R12,INECHO		:YES...CAN THIS CHARACTER ECHO?
	JNFS	IN10			:NO...JUST SKIP IT
	JAL	R15,OCHK		:YES...IS THERE ROOM IN OUTPUT RING FOR RETURN?
	JGER	R7			:NO...ABORT FOR NOW
	JAL	R15,OUT1CH		:ELSE ECHO THE CHAR
	NHI	R12,7F			:WHILE ECHOING, ECHO C/R WITH L/F
	SIS	R12,0D			:
	JNFS	IN10			:SKIP IF NOT C/R
	LIS	R12,0A			:
	JAL	R15,OUT1CH		:
IN10	STH	R4,NOI,R3		:SAVE UPDATED POINTER
	JR	R8			:BRANCH TO INPUT COMPLETE ADDR
					:
INECHO	HC	0FEDB,-1,0,0,0,0	:BITS REFLECT CHARACTERS WHICH DON'T ECHO
	HC	0,7,0FEDB,-1,0,0,0,0,0,7
					:
					:
:	....................................................................
:	OUT SVC (TTY)
:	....................................................................
					:
TTYOUT	LHL	R4,UFLAG,R1		:CHECK FLAGS
	THI	R4,FDDT!FKIOJ		:
	JE	NOTI			:VALID ONLY FROM DDT...ELSE NOT IMPLEMENTED
	L	R12,F1ARG		:USER ADDR OF DATA
	LH	R13,F1PS1+2		:GET MAC BIT FOR USER
	JAL	R11,ACCESS		:CHECK ACCESS & TRANSLATE
	J	OUT0B			:NO ACCESS
OUT0A	LR	R4,R12			:COPY ACTUAL START ADDRESS
	LB	R5,0,R12		:COUNT
	AR	R5,R4			:USER ADDR OF END OF DATA
	JAL	R15,KIOSUP		:SET UP KERNEL-I/O REGISTERS
	LA	R8,KRET			:SET OUTPUT COMPLETE TRANSFER ADDRESS
	JAL	R9,OUT1			:CALL OUT SVC ROUTINE
	ST	R4,UOUT,R1		:OUTPUT INCOMPLETE...SAVE PTR TO USER DATA
	ST	R5,UOUT+4,R1		:
	LIS	R4,0			:CANCEL ANY QUANTUM REMAINING
	STH	R4,QUANTUM,R1		:
	LHI	R4,FOUT			:SET OUT WAIT
	OH	R4,WFLAG,R1		:
	STH	R4,WFLAG,R1		:
 if	SPAM				:
  if	SPMTRC				:
	LIS	R10,7			:SPAM TRACE ROUTINE ID
  ei   (SPMTRC)				:
	JAL	R9,ENTIM		:
 ei	(SPAM)				:
	J	MAIN			:RETURN TO MAIN LOOP
					:
:	....................................................................
:	PARAMETER FAILURE
:	....................................................................
					:
OUT0B	KRCODE(0,2,5)			:CRASH HIM
	JAL	R11,KRASH		:
 if	SPAM				:
  if	SPMTRC				:
	LHI	R10,18			:SPAM TRACE ROUTINE ID
  ei   (SPMTRC)				:
	JAL	R9,ENTIM		:GET USER DATA
 ei    (SPAM)				:
	J	MAIN			:EXIT BACK TO MAIN LOOP
					:
:	....................................................................
:
:	PROCESS OUTPUT
:	R1	USER BLOCK
:	R2	INTERNAL PORT INDEX
:	R3	KERNEL RING  POINTER
:	R4	MESSAGE START ADDRESS
:	R5	MESSAGE END ADDRESS
:	R8	ADDRESS FOR OUTPUT SUCCESSFULL
:	R9	ADDRESS FOR OUTPUT INCOMPLETE
:
:	....................................................................
					:
  IF	KBLKMV				:
   IF	KIOSRC				:
	SBT	R2,KOFBIT		:
   ELSE					:
	LR	R15,R2			:Make a copy of port number
	SLHLS	R15,2			:Make a fullword index
	L	R14,KDP,R15		:Get pointer
	SBT	R14,0			:
   EI  (KIOSRC)				:
					:
:	....................................................................
:	Determine amount of room available in the KIO ring
:	....................................................................
					:
OUT12	LH	R13,NIO,R3		:Get the next input
	SH	R13,NOO,R3		:Get the next output
	JLFS	OUT12A			:
	SHI	R13,KBS			:Make sure the count is negative
OUT12A	AIS	R13,1			:
					:
:	....................................................................
:	If amount of room left in KIO ring is less than 8 bytes, then take
:	the output incomplete return.
:	....................................................................
					:
	CHI	R13,-7			:
	JGER	R9			:Ouput incomplete...return
					:
:	....................................................................
:	Determine the minimum of room left in the KIO ring and the distance
:	toward the end of ring.
:	....................................................................
					:
	LH	R14,NIO,R3		:Get the distance to the end of ring
	CR	R13,R14			:Both are negative counters, so we
	JGEFS	OUT15			:must reverse the sense of compare
	LR	R13,R14			:Make sure R13 has the minimu
					:
:	....................................................................
:	If the current character is end of the message, then take the output
:	complete return.
:	....................................................................
					:
OUT15	CLR	R4,R5			:Is end of the message?
	JNFS	OUT15A			:Skip if not
	STH	R14,NIO,R3		:Save the ring index before return
	JR	R8			:Ouput complete...return
					:
:	....................................................................
:	Get the next character to transmit
:	....................................................................
					:
OUT15A	AIS	R4,1			:Bump the input pointer
	LB	R12,0,R4		:Get the character
					:
:	....................................................................
:	If the character count is less than 8, then the character needs 
:	escaping with a zero byte.
:	....................................................................
					:
	CLHI	R12,8			:
	JL	OUTA1			:
					:
:	....................................................................
:	Place the character into ring
:	....................................................................
					:
OUT18	STB	R12,KOB,R3,R14		:Put character into ring
	AIS	R14,1			:
	AIS	R13,1			:
					:
:	....................................................................
:	If the room left in the ring is not zero
:	....................................................................
					:
	JL	OUT15			:
					:
:	....................................................................
:	If the KIO ring index is 0 (zero) then set it to the negative of
:	the ring size.
:	....................................................................
					:
	LR	R14,R14			:
	JLFS	OUT111			:
	LHI	R14,-KBS		:KIO ring size
OUT111	STH	R14,NIO,R3		:Store the ring index
	J	OUT12			:
					:
:	....................................................................
:	Try to write two characters in the KIO ring. 
:	If we can't fit them both into the ring, then put the original
:	character back into source buffer,  and take output incomplete
:	return.
:	
:	....................................................................
					:
OUTA1	CLHI	R13,-1			:Is there is room for only one char?
	JE	OUTA4			:Skip if it is true
					:
:	....................................................................
:	Place a zero into the ring before the actual character
:	....................................................................
					:
	LIS	R15,0			:
	STB	R15,KOB,R3,R14		:
	AIS	R14,1			:
	AIS	R13,1			:
	J	OUT18			:
					:
:	....................................................................
:	Check if we at end of ring
:	....................................................................
					:
OUTA4	CR	R13,R14			:
	JEFS	OUTA7			:
					:
:	....................................................................
:	Decreament the next character pointer
:	....................................................................
					:
OUTA5	SIS	R4,1			:
	J	OUT111			:
					:
:	....................................................................
:	Calculate amount of room left in the ring
:	....................................................................
					:
OUTA7	LH	R13,NIO,R3		:
	SH	R13,NOO,R3		:
	JLFS	OUTA7A			:
	SHI	R13,KBS			:Make sure R13 is negative
					:
:	....................................................................
:	Check if amount of room left is still only one char
:	....................................................................
					:
OUTA7A	CHI	R13,-1			:
	JE	OUTA5			:Yes
					:
:	....................................................................
:	Place a zero into the last character of the ring
:	....................................................................
					:
	LIS	R15,0			:
	STB	R15,KOB,R3,R14		:
	AIS	R13,1			:
					:
:	....................................................................
:	Set the ring index to the negative of ring size
:	....................................................................
					:
	LHI	R14,-KBS		:Set ring index
	J	OUT18			:Just go to store the character
					:
  ELSE					:
OUT1	JAL	R15,OCHK		:CHECK FOR SPACE AVAILABLE IN OUTPUT BUFFER
OUT2	JGER	R9			:FULL...EXIT FOR NOW
	CLR	R4,R5			:ARE WE DONE?
	JER	R8			:YES - OUTPUT-COMPLETE BRANCH
	AIS	R4,1			:POINT TO NEXT BYTE
	LB	R12,0,R4		:FETCH DATA CHAR
	CLHI	R12,8			:IS CHAR < 8
	JGEFS	OUT3			:NO - OUTPUT CHAR
	EXBR	R12,R12			:MAKE ESCAPED PAIR
	JAL	R15,OUT2CH		:
	J	OUT2			:
OUT3	JAL	R15,OUT1CH		:
	J	OUT2			:LOOP
  EI   (KBLKMV)				:
					:
:	................................................................
:
:	SETUP KERNEL I/O REGISTERS
:	R11 ON S4!!!
:	EXPECTS	R1 = POINTER TO USER BLOCK
:	RETURNS	R2	INTERNAL PORT #
:		R3	KERNEL RING POINTER
:
:	................................................................
					:
KIOSUP	LHL	R2,BUFNO,R1		:GET INTERNAL PORT INDEX
	LR	R3,R2			:
	SLHLS	R3,2			:MAKE A WORD INDEX
	L	R3,KRP,R3		:GET RING POINTER
	JR	R15			:AND RETURN
					:
:	................................................................
:
:	CHECK OUTPUT RING
:	R11 ON S4!!!
:	EXPECTS	R2	INTERNAL PORT INDEX
:	RETURNS	R14	CURRENT OUTPUT POSITION
:		R13	SPACE REMAINING
:		C.C.	.LT. IF ROOM TO PLACE CHAR INTO OUTPUT RING
:
:	................................................................
					:
OCHK	LH	R13,NIO,R3		:NEXT-IN OUTPUT POSITION
	LH	R14,NOO,R3		:NEXT-OUT OUTPUT POSITION
	SR	R13,R14			:
	JLFS	.+6			:CHECK FOR POSSIBLE FOLDING
	SHI	R13,KBS			:
   IF	KIOSRC				:
	SBT	R2,KOFBIT		:SET DATA PRESENT BIT
   ELSE					:
	SLHLS	R2,2			:MAKE A WORD INDEX
	L	R14,KDP,R2		:GET BIT POINTER FOR USER DATA READY BIT
	JEFS	.+6			:IGNORE IF NOT IN USE
	SBT	R14,0			:SET IT
	SRHLS	R2,2			:RESTORE R2
   EI  (KIOSRC)				:
	LH	R14,NIO,R3		:RETURN R14 = NEXT-IN OUTPUT POS
	AIS	R13,8			:TEST IF THERE IS ROOM FOR AT LEAST 8 MORE CHARS
	JR	R15			:THEN RETURN
					:
:	................................................................
:
:	PLACE 2 CHARS INTO OUTPUT RING
:	R11 ON S4!!!
:	EXPECTS	R2	INTERNAL PORT INDEX
:		R3	KERNEL RING POINTER
:		R12	BACKWARD CHARACTER PAIR TO PLACE INTO RING
:	RETURNS	C.C. .LT. IF MORE CHARS CAN BE PLACED INTO RING
:
:	................................................................
					:
OUT2CH	HS	0			:
 if	SHARE				:
  if	NDISC				:
	TBT	R2,DPDET		:IGNOR FOR DETACHED PORT
	JE	OUT1CX			:
  ei   (NDISC)				:
 ei    (SHARE)				:
	LH	R14,NIO,R3		:GET POINTER
	STB	R12,KOB,R3,R14		:PLACE THE CHARACTER
	AIS	R14,1			:
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R14,-KBS		:ACCOUNT FOR FOLDING
	AIS	R13,1			:COUNT SPACE USED
	EXBR	R12,R12			:NOW POSITION SECOND CHAR OF PAIR, FALL THROUGH
	J	OUT1CZ			:OUTPUT NEXT
					:
:	................................................................
:
:	PLACE 1 CHAR INTO OUTPUT RING
:	R11 ON S4!!!
:	EXPECTS	R2	INTERNAL PORT INDEX
:		R3	KERNEL RING POINTER
:		R12	CHARACTER TO PLACE INTO RING
:	RETURNS	C.C. .LT. IF MORE CHARS CAN BE PLACED INTO RING
:
:	................................................................
					:
OUT1CH	HS	0			:
 if	SHARE				:
  if	NDISC				:
	TBT	R2,DPDET		:IGNOR FOR DETACHED PORT
	JNFS	OUT1CY			:
OUT1CX	LR	R13,R13			:SET UP CONDITION CODE
	JR	R15			:AND EXIT
OUT1CY					:
  ei   (NDISC)				:
 ei    (SHARE)				:
	LH	R14,NIO,R3		:GET POINTER
OUT1CZ	STB	R12,KOB,R3,R14		:PLACE THE CHARACTER
	AIS	R14,1			:
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R14,-KBS		:ACCOUNT FOR FOLDING
	STH	R14,NIO,R3		:SAVE POINTER
   IF	KIOSRC				:
	SBT	R2,KOFBIT		:SET DATA PRESENT BIT
   ELSE					:
	SLHLS	R2,2			:
	L	R14,KDP,R2		:GET BOINTER TO DATA READY BIT
	JEFS	.+6			:IGNORE IF NOT IN USE
	SBT	R14,0			:SET ATTENTION BIT
	SRHLS	R2,2			:RESTORE R2
   EI  (KIOSRC)				:
	AIS	R13,1			:COUNT ANOTHER CHAR IN PLACE
	JR	R15			:AND RETURN
					:
:	................................................................
:
:	HANG KERNEL PORT FOR DDT (?HANG)
:	R11 ON R4.  EXPECTS R1 = KERNEL PORT NO.
:
:	................................................................
					:
HANG	TBT	R1,KACT			:IS IT ACTIVE
	JER	R4			:SKIP IF NOT
	LR	R2,R1			:GET INDEX
	SLHLS	R2,2			:MAKE INDEX
	L	R2,KRP,R2		:GET RING POINTER
	LH	R3,NMI,R1,R1		:GET POINTER TO LAST CHAR EXAMINED
	STH	R3,NOI,R2		:FLUSH ALL DATA NOT YET INPUT
	LIS	R0,3			:A ZAPPER
	STB	R0,KIB,R2,R3		:
	AIS	R3,1			:
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R3,-KBS			:ACCOUNT FOR FOLDING
	STH	R3,NII,R2		:ADVANCE INPUT POINTER SO ZAPPER IS THERE
	JR	R4			:
					:
:	....................................................................
:	DCKIO - KILL ANY KIO PORTS THIS SLOT MAY HAVE CREATED
:	  R4  = SLOT NMBR
:	  R11 = R11
:	....................................................................
					:
DCKIO	LHI	R5,NKGRP*2-2		:FOR EACH GROUP
KKIO1	LHL	R0,KACT,R5,		:FOR NEXT GROUP
	STH	R0,TMP1			:SAVE COPY
KKIO2	LHL	R2,TMP1			:
	JFFOH	R2,KKIO3		:FIND ACTIVE SLOT
	SIS	R5,2			:FOR NEXT GROUP
	JGEBS	KKIO1			:
	JR	R11			:
					:
KKIO3	RBT	R3,TMP1			:CANCEL THIS ONE
	LR	R1,R5			:
	SLHLS	R1,3			:
	AR	R1,R3			:PORT INDEX
	CLB	R4,KSP,R1,		:DOES THIS SLOT OWN IT?
	JN	KKIO2			:
	STH	R4,TMP2			:
	JAL	R4,HANG,,		:CALL ON KERNEL TO HANG
	LHL	R4,TMP2			:
	J	KKIO2			:
					:
TMP1	HS	1			:
TMP2	HS	1			:
					:
   IF	KIOSRC				:
:	....................................................................
:	KIOCHK - PERIODIC KIO PROCESSING
:
:	Determine if there any kernel ports shall be zapped and
:		  if there any kernel ports are new and exist.
:
:	INPUT:	R15 - LINK
:	XXX - WORKING REGISTERS
:	....................................................................
					:
KIOCHK	JAL	R14,PNLOG		:Process new log ring
	JAL	R10,EXKP		:Examine kernel ports
	JAL	R14,PKOF		:PROCESS KOF RING
	JAL	R14,PSCTL		:PROCESS SRC CONTROL RING
   IF	KIODES				:
	JAL	R14,PDCTL		:PROCESS DEST CONTROL RING
	JAL	R14,PTHRU		:PROCESS PASSTHRU CIRCUITS
   EI  (KIODES)				:
	JR	R15			:RETURN
					:
:	....................................................................
:	PNLOG - PROCESS NEWLOG RING
:	INPUT - R14 REGISTER LINK
:
:	R0-R5 - WORKING REGISTERS
:	....................................................................
					:
PNLOG	LI	R2,SNEWRG		:PROCESS NEWLOG RING
	LHI	R3,-NEWSIZ		:SET UP RING SIZE
PNLOG1	JAL	R1,GETCTL		:GET NEXT MESSAGE
	JER	R14			:IF NONE, SKIP
	CLHI	R0,NKU			:IS PORT IN RANGE
	JLFS	PNLOG2			:IF SO, SKIP
	S.HLTF(2030)			:KIO PORT OUT OF RANGE
PNLOG2	TBT	R0,KACT			:IS PORT ACTIVE
	JEFS	PNLOG3			:IF NOT, CONTINUE
	S.HLTF(2040)			:KIO PORT INCONSISTENCY
PNLOG3	TBT	R0,KLPEND		:IS THIS PORT READY
	JNFS	PNLOG4			:IF SO, CONTINUE
	S.HLTF(2040)			:KIO PORT INCONSISTENCY
PNLOG4	SBT	R0,NEWLOG		:INDICATE NEW LOGON
	SBT	R0,KACT			:MAKE IT ACTIVE
	RBT	R0,KLPEND		:RESET LOGON PENDING
	JR	R14			:DO NEXT
					:
:	....................................................................
:	PKOF - PROCESS KOF RING
:	INPUT: R14 - LINK
:
:	R0-R2 - WORKING REGISTERS
:	....................................................................
					:
PKOF	LH	R1,SKOFRG-4,,		:HAS LAST VECTOR BEEN READ
	CLH	R1,SKOFRG-2,,		:
	JNR	R14			:IF NOT, RETURN
	L	R2,KOFBIT		:ANY PORTS WITH DATA?
	L	R3,KOFBAK		:GET LAST KOF
	OR	R3,R2			:ANY PORTS TO SERVICE?
	JER	R14			:IF NOT, RETURN
	ST	R3,SKOFRG-4,R1,		:PLACE NEW ARRAY
	AIS	R1,4			:BUMP INDEX
	JLFS	PKOF1			:ACCOUNT FOR FOLDING
	LHI	R1,-KOFSIZ		:
PKOF1	STH	R1,SKOFRG-4,,		:UPDATE INDEX
	ST	R2,KOFBAK		:REMEMBER LAST KOF
	LIS	R0,0			:RESET TEMP KOF ARRAY
	ST	R0,KOFBIT		:
	JR	R14			:
					:
:	....................................................................
:	PSCTL - PROCESS SOURCE KIO CONTROL RING
:	INPUT - R14 LINK REGISTER
:
:	R0-R7 - WORKING REGISTERS
:	....................................................................
					:
PSCTL	LI	R2,SKCTLI		:GET SRC CONTROL INPUT RING
	LHI	R3,-CTLSIZ		:SET UP RING SIZE
	JAL	R1,GETCTL		:GET NEXT MESSAGE
	JER	R14			:RETURN IF EMPTY
	LR	R5,R0			:COPY THE MESSAGE
	SRL	R5,8			:ISOLATE THE PORT #
	CLHI	R5,NKU			:IS PORT IN RANGE
	JLFS	PSCTL2			:IF SO, SKIP
	S.HLTF(2030)			:KIO PORT OUT OF RANGE
PSCTL2	LR	R8,R5			:COPY PORT #
	SLLS	R8,2			:MAKE WORD INDEX
	LR	R4,R0			:COPY THE MESSAGE
	NHI	R4,0FF			:ISOLATE THE MESSAGE TYPE
	THI	R4,80			:IS IT AN ACK
	JN	PSACK			:IF SO, PROCESS ACK
	LR	R4,R4			:IS IT A ZAP '00'
	JN	PSCTL5			:IF NOT, SKIP
   IF	KIODES				:
	TBT	R5,KPTHRU		:IS IT A PASSTHRU CIRCUIT
	JN	PSCTLB			:IF SO, PASS TO DEST
   EI  (KIODES)				:
	TBT	R5,KLPEND		:Is this port waiting for newlog?
	JEFS	PSCTL3			:No - normal process
	RBT	R5,KLPEND		:Yes, zap received before newlog
	J	PSCTLA			:Goto acknowledge zap 
PSCTL3	SBT	R5,KDZAP		:MARK INCOMING ZAPPER
	JR	R14			:Process one message per pass
					:
PSCTL5	SIS	R4,1			:IS IT A GOBBLER '01'
	JN	PSCTL7			:IF NOT, SKIP
	L	R6,KRP,R8		:GET DATA RING POINTER
	LH	R7,NII,R6		:FLUSH INPUT BUFFER
	STH	R7,NOI,R6		:
	STH	R7,NMI,R5,R5		:UPDATE NMI CURSOR
   IF	KIODES				:
	TBT	R5,KPTHRU		:IS IT A PASSTHRU CIRCUIT
	JN	PSCTLB			:IF SO, PASS TO DEST
   EI  (KIODES)				:
	J	PSCTLA			:ACK AND DO NEXT MSG
PSCTL7	SIS	R4,1			:IS IT A BUFFER CLEAR '02'
	JE	PSCTL8			:IF SO, CONTINUE
	S.HLTF(2050)			:INVALID KIO CONTROL MESSAGE
PSCTL8	TBT	R5,KACT			:IS PORT ACTIVE
	JEFS	PSCTL9			:IF NOT, CONTINUE
	S.HLTF(2040)			:KIO PORT INCONSISTENCY
PSCTL9	SBT	R5,KLPEND		:MARK LOGON PENDING
	LHI	R6,2,R5			:COPY PORT # + 2
	SLLS	R6,4			:MAKE QUAD-WORD INDEX
	LI	R6,SRCDSC,R6,		:GET DESCRIPTOR FOR PORT RING
	L	R6,SDIEND,R6		:GET INPUT RING END ADDR
	LI	R6,-KBS-4,R6,		:MAKE IT START ADDRESS	
	SLLS	R5,2			:MAKE WORD INDEX
	ST	R6,KRP,R5		:GET DATA RING POINTER
	LH	R7,NII,R6		:FLUSH INPUT BUFFER
	STH	R7,NOI,R6		:
	SRLS	R5,1			:MAKE HW INDEX
	STH	R7,NMI,R5		:UPDATE NMI CURSOR
PSCTLA	OHI	R0,80			:MAKE ACK MESSAGE
	LI	R2,SKCTLO		:GET SRC CTL OUT RING
	JAL	R1,PUTCTL		:PLACE ACK IN CONTROL RING
	JNR	R14			:Just return ...
	S.HLTF(2020)			:NO ROOM IN SIO CONTROL RING
   IF	KIODES				:
PSCTLB	LI	R2,DKCTLO		:GET DEST CTL OUT RING
	JAL	R1,PUTCTL		:PLACE ACK IN CONTROL RING
	JNR	R14			:
	S.HLTF(2020)			:NO ROOM IN SIO CONTROL RING
   EI  (KIODES)				:
					:
PSACK	SHI	R4,80			:IS IT A ZAP ACK '80'
	JNFS	PSACK3			:IF NOT, SKIP
   IF	KIODES				:
	TBT	R5,KPTHRU		:IS IT A PASSTHRU CIRCUIT
	JER	R14			:If not, just return ...
	RBT	R5,KACT			:RESET CIRCUIT
	RBT	R5,KPTHRU		:
	J	PSCTLB			:PASS IT TO DEST
   EI  (KIODES)				:
	JR	R14			:Return ...
PSACK3	SIS	R4,1			:IS IT A GOBBLER ACK '81'
	JE	PSACK4			:IF SO, CONTINUE
	S.HLTF(2050)			:INVALID KIO CONTROL MESSAGE
PSACK4	HS	0			:
   IF	KIODES				:
	TBT	R5,KPTHRU		:IS IT A PASSTHRU CIRCUIT
	JN	PSCTLB			:IF SO, PASS TO DEST
   EI  (KIODES)				:
	L	R6,KDESTZ,R8		:GET UB POINTER FOR CIRCUIT
	LHL	R7,WFLAG,R6		:TURN OFF GOBBLER ACK WAIT
	NHI	R7,@FGACK		:
	STH	R7,WFLAG,R6		:
	JR	R14			:Just return ...
					:
:	....................................................................
:	PDCTL - PROCESS DESTINATION KIO CONTROL RING
:	INPUT - R14 LINK REGISTER
:
:	R0-R7 - WORKING REGISTERS
:	....................................................................
					:
   IF	KIODES				:TRIPLE CONFIGURED
PDCTL	LI	R2,DKCTLI		:GET DEST CONTROL INPUT RING
	LHI	R3,-CTLSIZ		:SET UP RING SIZE
	JAL	R1,GETCTL		:GET NEXT MESSAGE
	JER	R14			:RETURN IF EMPTY
	LR	R5,R0			:COPY THE MESSAGE
	SRL	R5,8			:ISOLATE THE PORT #
	CLHI	R5,NKU			:IS PORT IN RANGE
	JLFS	PDCTL2			:IF SO, SKIP
	S.HLTF(2030)			:KIO PORT OUT OF RANGE
PDCTL2	LR	R4,R0			:COPY THE MESSAGE
	NHI	R4,0FF			:ISOLATE THE MESSAGE TYPE
	THI	R4,80			:IS IT AN ACK
	JN	PDACK			:IF SO, PROCESS ACK
	LR	R4,R4			:IS IT A ZAP '00'
	JE	PDCTL5			:IF SO, PASS IT TO SRC
	SIS	R4,1			:IS IT A GOBBLER '01'
	JE	PDCTL4			:IF SO, CONTINUE
	S.HLTF(2050)			:INVALID KIO CONTROL MESSAGE
PDCTL4	SLLS	R5,2			:MAKE WORD INDEX
	L	R6,KRPD,R5		:GET DEST DATA RING PTR
	LH	R7,NII,R6		:FLUSH INPUT BUFFER
	STH	R7,NOI,R6		:
PDCTL5	LI	R2,SKCTLO		:GET SRC CONTROL OUTPUT RING
	JAL	R1,PUTCTL		:PASS ON MSG TO SRC
	JN	PDCTL			:DO NEXT MSG
	S.HLTF(2020)			:NO ROOM IN SIO CONTROL RING
					:
PDACK	SHI	R4,80			:IS IT A ZAP ACK '80'
	JN	PDACK3			:IF NOT, SKIP
	RBT	R5,KACT			:RESET CIRCUIT
	RBT	R5,KPTHRU		:
	J	PDCTL5			:PASS ZAP ACK TO SRC
PDACK3	SIS	R4,1			:IS IT A GOBBLER ACK '81'
	JE	PDCTL5			:IF SO, PASS IT TO SRC
	SIS	R4,1			:IS IT BUFFER CLEAR ACK '82'
	JE	PDACK4			:IF SO, CONTINUE
	S.HLTF(2050)			:INVALID KIO CONTROL MESSAGE
					:
:	....................................................................
:	SEND LOGON STRING AND FLUSH INPUT BUFFER
:	....................................................................
					:
PDACK4	TBT	R5,KPTHWT		:TEST WAIT STATE
	JNFS	PDACK5			:IS ALL WELL?
	S.HLTF(2040)			:KIO PORT INCONSISTENCY
PDACK5	RBT	R5,KPTHWT		:REST WAIT STATE BIT
	LHI	R11,2,R5		:PORT# +2
	SLLS	R11,4			:MAKE QUAD-WORD INDEX
	LI	R11,DESDSC,R11,		:GET DESCRIPTOR FOR PORT RING
	L	R11,SDIEND,R11		:INPUT RING END ADDRESS
	LI	R11,-KBS-4,R11,		:MAKE IT START ADDR.
	SLLS	R5,2			:MAKE WORD INDEX OF PORT
	ST	R11,KRPD,R5		:DATA RING POINTER
	LH	R7,NII,R11		:FLUSH INPUT BUFFER
	STH	R7,NOI,R11		:
:	....................................................................
:	PASS LOGIN STRING (R11: DEST POINTER)
:	....................................................................
					:
	SRLS	R5,2			:MAKE IT PORT AGAIN
	LB	R10,KTID,R5		:GET TERM TYPE
	OHI	R10,80			:TURN ON HIGH BIT
	JAL	R1,MVIT			:MOVE IT
	LHI	R10,0D4			:'M'
	JAL	R1,MVIT			:MOVE IT
	LHI	R10,0C1			:'A'
	JAL	R1,MVIT			:MOVE IT
	LHI	R10,0E7			:'X'
	JAL	R1,MVIT			:MOVE IT
					:
:	....................................................................
:	MOVE USERNAME
:	....................................................................
					:
	SLLS	R5,3			:PORT*8
	LIS	R2,0			:COUNTER FOR LENGTH
MVC1	LB	R10,KLNAME,R2,R5	:GET USERNAME CHAR
	CLHI	R10,0			:NULL?
	JEFS	MVC2			:YES
	JAL	R1,MVIT			:MOVE IT
	AIS	R2,1			:UP COUNT
	CLHI	R2,8			:8 CHAR READ
	JLBS	MVC1			:NO
MVC2	LHI	R10,8D			:END CHAR
	JAL	R1,MVIT			:
	THI	R2,1			:EVEN/ODD LENGTH?
	JNFS	MVC3			:ODD?
	LHI	R10,80			:
	JAL	R1,MVIT			:MOVE NULL FOR PARITY
					:
:	.......................................................................
:	SEND NEWLOG MESSAGE
:	.......................................................................
					:
MVC3	SRLS	R5,3			:MAKE IT PORT AGAIN
	LR	R0,R5			:PORT# = MESSAGE
	LI	R2,DNEWRG		:DEST = NEWLOG
	LHI	R3,-NEWSIZ		:RING SIZE
	JAL	R1,PUTCTL		:PUT NEWLOG MESSAGE
	JNFS	PDACK6			:CHECK ON ROOM
	S.HLTF(2020)			:NO ROOM IN SIO CONTROL RING
PDACK6	SBT	R0,KPTHRU		:MARK AS PASSTHRU
	J	PDCTL			:DO NEXT MESSAGE
					:
:	.......................................................................
:	PTHRU - PROCESS PASSTHRU CIRCUITS
:	IN: R14 - LINK
:	USES R1,R2,R3,R10,R11,R12
:
:	PROCESS TRIPLE KOF VECTOR FOR DATA
:	.......................................................................
					:
PTHRU	LH	R1,DKOFRG-2,,		:EMPTY
	CLH	R1,DKOFRG-4,,		:COMPARE TO FILL
	JE	PTHRU4			:NOTHING HERE
	L	R2,DKOFRG-4,R1,		:GET ARRAY ELEMENT
	AIS	R1,4			:UP CURSOR
	JLFS	PTHRU1			:ACCOUNT FOR WRAP
	LHI	R1,-KOFSIZ		:WRAP
PTHRU1	STH	R1,DKOFRG-2,,		:UPDATE INDEX
	ST	R2,KOFCEL		:STORE BIT ARRAY
PTHRU2	JFFO	R2,PTHRU8		:FIND SET BIT
	J	PTHRU4			:IT'S EMPTY
PTHRU8	TBT	R3,KPTHRU		:IS THIS A PASSTHRU CIRCUIT?
	JEBS	PTHRU2			:IF NOT, IGNORE
:	S.HLTF(2040)			:KIO PORT INCONSISTENCY
PTHRU3	RBT	R3,KOFCEL		:CLEAR BIT
	SLLS	R3,2			:MAKE WORD INDEX
	L	R10,KRPD,R3		:SOURCE
	L	R11,KRP,R3		:DEST
	JAL	R12,MVKIO		:MOVE DATA
	SRLS	R3,2			:MAKE PORT #
	SBT	R3,KOFBIT		:MARK PORT ON OTHER SIDE
	L	R2,KOFCEL		:GET UPDATED KIO VECTOR
	J	PTHRU2			:PROCESS AGAIN
					:
:	.......................................................................
:	PROCESS DOUBLE FOR PASSTHRU DATA
:	.......................................................................
					:
PTHRU4	LIS	R4,0			:INDEX
PTHRU5	CLHI	R4,NKGRP*2		:PROCESS BIT ARRAY IN HW INCREM.
	JGER	R14			:OUT OF HERE
	LH	R2,KPTHRU,R4		:BIT ARRAY FOR PASSTHRU CIRCUITS
	STH	R2,PTHCEL		:WORKING STORAGE
PTHRU6	JFFOH	R2,PTHRU9		:FIND ACTIVE BIT
	J	PTHRU7			:IT'S EMPTY
PTHRU9	RBT	R3,PTHCEL		:RESET BIT
	LR	R5,R4			:COPY INDEX
	SLLS	R5,3			:COMPENSATE FOR FOR WHICH HW
	AR	R3,R5			:ADD BIT DISPLACEMENT
	SLLS	R3,2			:WORD INDEX
	L	R10,KRP,R3		:SOURCE
	L	R11,KRPD,R3		:DEST
	JAL	R12,MVKIO		:MOVE DATA
	LH	R2,PTHCEL		:GET UPDATED HALFWORD STORAGE
	J	PTHRU6			:PROCESS FOR MORE
PTHRU7	AIS	R4,2			:UP INDEX
	J	PTHRU5			:ANOTHER HALFWORD TO PROCESS
   EI  (KIODES)				:
					:
:	.......................................................................
:	GETCTL - GET A CONTROL RING MESSAGE
:	IN:	R1 - LINK
:	R2 - RING POINTER
:	R3 - NEGATIVE LENGTH
:	
:	OUT:	R0 - MESSAGE FOUND, IF NO MESSAGE CONDITION CODE Z IS SET
:
:	R4 - WORKING REGISTER
:	.......................................................................
					:
GETCTL	LH	R4,-2,R2,		:GET EMPTY POINTER
	CLH	R4,-4,R2,		:COMPARE WITH FILL PTR
	JER	R1			:RETURN IF EQUAL
	LHL	R0,-4,R2,R4		:GET NEXT MESSAGE
	AIS	R4,2			:BUMP INDEX
	JLFS	GCTL1			:ACCOUNT FOR WRAP
	LR	R4,R3			:
GCTL1	STH	R4,-2,R2,		:UPDATE EMPTY INDEX
	JR	R1			:RETURN
					:
:	.......................................................................
:	PUTCTL - PUT A CONTROL RING MESSAGE
:	IN:	R0 - MESSAGE
:		R1 - LINK
:		R2 - RING POINTER
:		R3 - NEGATIVE LENGTH
:
:	OUT:	IF NO ROOM IN RING CONDITION CODE Z IS SET
:
:	R4,R5 - WORKING REGISTERS
:	.......................................................................
					:
PUTCTL	LH	R4,-4,R2,		:GET FILL POINTER
	LHI	R5,2,R4			:ADD ROOM NEEDED
	JLFS	PCTL1			:ACCOUNT FOR WRAP
	LR	R5,R3			:
PCTL1	CLH	R5,-2,R2,		:COMPARE WITH EMPTY PTR
	JER	R1			:RETURN IF NO ROOM
	STH	R0,-4,R2,R4		:PLACE MESSAGE
	STH	R5,-4,R2,		:UPDATE FILL INDEX
	JR	R1			:RETURN
					:
:	.......................................................................
:	MVCHR - MOVE A CHARACTER INTO DEST RING (OUTPUT)
:	IN: R10 - CHARACTER, R11 - DEST RING POINTER, R12 - LINK
:	OUT: IF NO ROOM IN RING CONDITION CODE Z IS SET
:	R8, R9 - WORKING REGISTERS
:	.......................................................................
					:
   IF 	KIODES				:
MVCHR	LH	R8,NIO,R11		:FILL CURSOR
	LHI	R9,1,R8			:LOOK FOR ROOM
	JLFS	.+6			:WRAP?
	LHI	R9,-KBS			:
	CLH	R9,NOO,R11		:ROOM?
	JER	R12			:NO ROOM AND RETURN
	STB	R10,KOB,R11,R8		:MOVE IT
	STH	R9,NIO,R11		:UPDATE CURSOR
	JR	R12			:RETURN
					:
:	.......................................................................
:	MVIT - CALLS MVCHR AND HALTS IF NO ROOM
:	USES REGISTERS IN MVCHR AND LINK -- R1
:	.......................................................................
					:
MVIT	JAL	R12,MVCHR		:MOVE CHAR
	JNR	R1			:RETURN
	S.HLTF(2020)			:NO ROOM IN SIO CONTROL RING
   EI  (KIODES)				:
					:
:	.....................................................................
:	MVKIO - MOVES KIO RING DATA. 
:	MOVES A BYTE AT A TIME FOR SRC RING (INPUT) TO DEST RING (OUTPUT).
:	MOVES UNTIL EITHER NO MORE DATA TO MOVE OR NO MORE ROOM TO FILL
:
:	Register Usage:
:	R10 - SRC RING POINTER
:	R11 - DST RING POINTER
:	R12 - LINK Register
:	R6, R7, R8, R9 scrach register
:	.....................................................................
					:
   IF	KIODES				:
MVKIO	LH	R7,NOI,R10		:EMPTY CURSOR (INPUT)
	LH	R8,NIO,R11		:FILL CURSOR-FOR PATHOLOGICAL CASE
MV1	CLH	R7,NII,R10		:COMPARE EMPTY TO FILL
	JE	MVRET			:CLEANUP
	LB	R6,KIB,R10,R7		:GET BYTE OF DATA
	LHI	R9,1,R8			:LOOK FOR ROOM
	JLFS	.+6			:WRAP?
	LHI	R9,-KBS			:
	CLH	R9,NOO,R11		:ROOM?
	JEFS	MVRET			:FINISHED HERE
	STB	R6,KOB,R11,R8		:MOVE IT
	AIS	R7,1			:UP EMPTY CURSOR (INPUT)
	JLFS	.+6			:WRAP?
	LHI	R7,-KBS			:
	LR	R8,R9			:COPY NEW FILL (OUTPUT)
	J	MV1			:NEXT BYTE
MVRET	STH	R7,NOI,R10		:UPDATE EMPTY OF SOURCE
	STH	R8,NIO,R11		:UPDATE FILL ON DEST
	JR	R12			:
   EI  (KIODES)				:
					:
:	.....................................................................
:	CTLOUT - OUTPUT A CONTROL MESSAGE FOR A PORT
:	INP: R2  - PORT #
:	     R12 - CONTROL MESSAGE TYPE
:	     R15 - LINK
:	OUT: NO REGISTERS ARE MODIFIED
:	.....................................................................
					:
CTLOUT	ST	R0,CTLSAV		:SAVE ALL REGISTERS USED
	ST	R1,CTLSAV+4		:
	ST	R2,CTLSAV+8		:
	ST	R3,CTLSAV+0C		:
	ST	R4,CTLSAV+10		:
	ST	R5,CTLSAV+14		:
	CLHI	R2,NKU			:IS IT TTY PORT
	JE	CTLO2			:IF SO, NO CTL MSG
	EXBR	R0,R2			:SET UP PORT #
	OR	R0,R12			:PUT IN MESSAGE TYPE
	CLHI	R12,1			:IS IT A GOBBLER?
	JN	CTLO1			:IF NOT, SKIP
	SLLS	R2,2			:MAKE WORD INDEX
	L	R5,KDESTZ,R2		:GET PROCESS USER BLOCK
	LHL	R4,WFLAG,R5		:PUT IN GOBBLER ACK WAIT STATE
	OHI	R4,FGACK		:
	STH	R4,WFLAG,R5		:
CTLO1	LI	R2,SKCTLO		:GET CONTROL OUTPUT RING
	LHI	R3,-CTLSIZ		:NEGATIVE CTL RING SIZE
	JAL	R1,PUTCTL		:PLACE IN CONTROL RING
	JN	CTLO2			:IF ROOM, CONTINUE
	S.HLTF(2020)			:NO ROOM IN SIO CONTROL RING
CTLO2	L	R0,CTLSAV		:RESTORE REGISTERS
	L	R1,CTLSAV+4		:
	L	R2,CTLSAV+8		:
	L	R3,CTLSAV+0C		:
	L	R4,CTLSAV+10		:
	L	R5,CTLSAV+14		:
	JR	R15			:RETURN
					:
CTLSAV	WS	6			:REGISTER SAVE AREA
   EI  (KIOSRC)				:
					:

	SUBTTL	A D D R E S S   C H E C K I N G

:	.....................................................................
:	TEST USER'S ACCESS TO ADDRESS
:	R11	link
:	R1	pointer to user block
:	R12	address
:	R13	user PSW1
:	normal RETURN -- NO ACCESS
:	ELSE SKIP (4) RETURN:
:	returns	R12	translated address
:		R14	segment start
:		R15	segment size
:	.....................................................................
					:
ACCESS	THI	R13,400			:IS HE RUNNING UNDER MAC?
	JNFS	ACC1			:SKIP IF NOT
	LIS	R14,0			:ELSE FAKE BASE OF SEGMENT
	LI	R15,SEGSIZ*$A16		:AND SIZE OF SEGMENT
	J	4,R11			:ALWAYS EXIT SUCCESS
ACC1	HS	0			:
 if	SYSMON				:
	LIS	R14,1			:
	AHM	R14,SYSTAT+0A		:COUNT THIS STATISTIC
 ei    (SYSMON)				:
	EXHR	R14,R12			:R12 HAS USER ADDRESS
	NHI	R14,MMASKS		:ISOLATE "SN"
	SRHLS	R14,MSHFTX		:RIGHT JUSTIFY "SN"
	SLHLS	R14,2			:INDEX WORD TABLE
	L	R15,MACTRN,R1		:LOCATION OF CURRENT MAC SET
	L	R14,-MACDIS,R14,R15	:
	THI	R14,MASK1		:CHECK PRESENCE BIT
	JER	R11			:NO ACCESS - RETURN
	LR	R15,R14			:MAKE COPY OF MAC REG
 if	ZITEL				:
	TI	R15,30000000		:IS IT EXTENDED MEMORY AREA?
	JNR	R11			:IF SO, RETURN
 ei    (ZITEL)				:
	NI	R15,MMASKL		:ISOLATE "SLF"
	SRL	R15,MSHFTL		:POSITION "SLF" FOR TESTING
	AIS	R15,1			:ONE LARGER ADDR THAN PERM IN SEG
	SLLS	R15,MSHFTB		:MAKE HIGHEST ADDR
	NI	R12,SEGSIZ-1		:CHECK ONLY "BN" & "BD"
	CLR	R12,R15			:IS ADDR WITHIN SEGMENT
	JGER	R11			:NOT IN SEGMENT - RETURN
	NI	R14,MMASKR		:ISOLATE "SRF"
	SRLS	R14,MSHFTA		:MAKE INTO ADDRESS
	AR	R12,R14			:RELOCATE ADDR
	J	4,R11			:SKIP RETURN
					:
:	.....................................................................
:	TEST READ/WRITE ACCESS
:	.....................................................................
					:
TTRW	HS	0			:
 if	SYSMON				:
	LIS	R14,1			:
	AHM	R14,SYSTAT+0A		:COUNT THIS STATISTIC
 ei    (SYSMON)				:
	EXHR	R14,R12			:
	NHI	R14,MMASKS		:ISOLATE "SN"
	SRHLS	R14,MSHFTX		:RIGHT JUSTIFY "SN"
	SLHLS	R14,2			:INDEX WORD TABLE
	L	R15,MACTRN,R1		:GET LOCATION OF CURRENT MAC
	L	R14,-MACDIS,R15,R14	:GET SEGMENT REGISTER
	THI	R14,MASK1		:CHECK PRESENCE BIT
	JER	R11			:NO ACCESS - RETURN
	THI	R14,MASK6		:TEST INHIBIT BITS
	JNR	R11			:ACCESS INHIBITED - RETURN
	LR	R15,R14			:MAKE COPY OF MAC REG
	NI	R15,MMASKL		:ISOLATE "SLF"
	SRL	R15,MSHFTL		:POSITION "SLF" FOR TESTING
	AIS	R15,1			:ONE LARGER ADDR THAN PERM IN SEG
	SLLS	R15,MSHFTB		:MAKE HIGHEST ADDR
	NI	R12,SEGSIZ-1		:CHECK ONLY "BN" & "BD"
	CLR	R12,R15			:IS ADDR WITHIN SEGMENT
	JGER	R11			:NOT IN SEGMENT - RETURN
	NI	R14,MMASKR		:ISOLATE "SRF"
	SRLS	R14,MSHFTA		:MAKE INTO ADDRESS
	AR	R12,R14			:RELOCATE ADDR
	J	4,R11			:SKIP RETURN...PHYSICAL ADDR IN R12,
					:BASE OF SEGMENT IN R14, SIZE IN R15
					:
:	.....................................................................
:	RANGE...CHECK FOR RANGE OF ADDRESSES
:	.....................................................................
					:
RRO	LHI	R3,@(MASKF)		:SET MASK FOR READ ONLY
	JFS	RRW0			:
RRW	LCS	R3,1			:SET MASK FOR READ WRITE
RRW0	LR	R5,R13			:MAKE A COPY
        NI      R5,MACSIZ               :ISOLATE "BN"
	SRLS	R5,MSHFTB		:RIGHT JUSTIFY "BN"
	EXHR	R14,R12			:RIGHT JUSTIFY "SN" OF FIRST ADDR
	NHI	R14,MMASKS		:ISOLATE "SN"
	SRHLS	R14,MSHFTX		:RIGHT JUSTIFY "SN"
	SLHLS	R14,2			:INDEX WORD TABLE
	EXHR	R15,R13			:SAME FOR "SN" OF LAST ADDR
	NHI	R15,MMASKS		:
	SRHLS	R15,MSHFTX		:RIGHT JUSTIFY "SN"
	SLHLS	R15,2			:
	LR	R6,R14			:COPY "SN" OF FIRST ADDR
RRW1	L	R10,MACTRN,R1		:GET LOCATION OF CURRENT MAC
	L	R10,-MACDIS,R10,R14	:GET SEGMENTATION REGISTER
	THI	R10,MASK1		:TEST PRESENCE BIT
	JER	R11			:ERROR RETURN
	NR	R10,R3			:ZERO PROTECTION BITS IF READ ONLY
	THI	R10,MASK6		:TEST WRITE PROTECT BITS
	JNR	R11			:ERROR RETURN
	NI	R10,MMASKL		:ISOLATE LENGTH FIELD
	CLI	R10,MMASKL		:IS SEGMENT FULL?
	JEFS	RRW2			:YES - GO ON
	CLR	R14,R15			:IS THIS LAST SEGMENT OF RANGE
	JNR	R11			:NO - ERROR RETURN
	SRL	R10,MSHFTL		:RIGHT JUSTIFY LENGHT
	CR	R5,R10			:IS SEGMENT BIG ENOUGH
	JGR	R11			:NO - ERROR RETURN
	JFS	RRW3			:YES - TRANSLATE ADDRESSES
RRW2	AIS	R14,4			:GO TO NEXT SEGMENT
	CR	R14,R15			:ARE WE DONE
	JLE	RRW1			:LOOP
RRW3	L	R14,MACTRN,R1		:LOC MAC SET - TRANS 1ST ADDRESS
	L	R14,-MACDIS,R14,R6	:GET SEGMENTATION REGISTER
	NI	R14,MMASKR		:ISOLATE SRF
	SRLS	R14,MSHFTA		:MAKE INTO ADDRESS
	NI	R12,SEGSIZ-1		:ISOLATE "BN" & "BD"
	AR	R12,R14			:RELOCATE TO PHYSICAL ADDR
	L	R14,MACTRN,R1		:TRANSLATE LAST ADDR
	L	R14,-MACDIS,R14,R15	:GET SEGMENTATION REGISTER
	NI	R14,MMASKR		:
	SRLS	R14,MSHFTA		:MAKE INTO ADDRESS
	NI	R13,SEGSIZ-1		:
	AR	R13,R14			:
	J	4,R11			:SKIP RETURN - NO ERROR
					:
:	.....................................................................
:	SET UP USER'S MAC REGISTERS
:	CALLED VIA JAL R11,SETMAC
:	Expects:
:		R1 = POINTER TO AN APPROPRIATE DDT BLOCK
:		R2 = CTA Base Address
:		R3 = NPROT  Address
:	Returns:
:		Normal return if insufficient space 
:		Skip (4) return for success (MAC SET UP.)
:	.....................................................................
					:
	GL	CTASIZE,X.EXM.,MACPNT,MAXCNT,CNTRL,NPROT,AREAS
	GL	DMABIT,DMAOFF,DMAMAP
					:
SETMAC	LHI	R12,20F0		:DISABLE INTERRUPTS
	EPSR	R13,R12			:
	L	R2,SBASE,R1		:*F*  R2 = CTA BASE ADDRESS
	LA	R3,NPROT,R2		:*F*  R3 = NPROT ADDRESS
	EPSR	R12,R13			:*F*RE-INABLE INTERRUPTS
   IF	MACV				:
	LCS	R0,1			:Initialize DMA seg. tmp storage
	ST	R0,DMATMP,,		:
	ST	R0,DMATMP+4,,		:
	ST	R0,DMATMP+8,,		:
   EI  (MACV)				:
   if	FSYS				:
	LHL	R0,DD.MSK,R2		:GET SAVE BITS FROM USER
	JNFS	.+4			:SKIP IF BITS SET
	LCS	R0,2			:ALL BUT SEG F IF NOT PRESENT
	STH	R0,FSSEG,R1		:
   ei  (FSYS)				:
	L	R4,CONTROL,R1		:GET BASE OF BACKGROUND
	JER	R11			:ILLEGAL IF NULL
	L	R5,OTHER,R4		:NOW GET ADDRESS OF FOREGROUND BLOCK
	JNFS	SET.M1			:SKIP IF THERE IS A FOREGROUND
	LR	R5,R4			:ELSE DUPLICATE USAGE
					:
:	.....................................................................
:	INITIALIZE THE SOURCE OF THE MAC REGISTERS TO MPROT
:	.....................................................................
					:
SET.M1	LHI	R9,MPROT+MACDIS,R1	:LOC OF MAC FOR R1
	ST	R9,MACTRN,R1		:
	LHI	R9,MPROT+MACDIS,R4	:MAC FOR BG
	ST	R9,MACTRN,R4		:
	LHI	R9,MPROT+MACDIS,R5	:MAC FOR FG
	ST	R9,MACTRN,R5		:
					:
	LHL	R9,0,R3			:T6=HIGHEST SEGMENT
	CLHI	R9,CTASEG		:RANGE CHECK
	JGR	R11			:ERROR IF TOO MANY
	L	R12,SBASE,R1		:Get slot begining physical address
	LHL	R13,CMAX,R1		:Get slot memory size in page
	SLLS	R13,MACPAG		:Convert  memory size in byte
	AR	R12,R13			:Get slot highest physical address
	CL	R12,MEMTOP		:Check the range error before loading
	JGR	R11			:Out of range...not loadable...return
	L	R12,SBASE,R1		:FROM DDT, FIND BASE OF USER'S AREA
	L	R13,CTASIZE,R2		:LOOK UP SIZE OF TABLE AREA
	LHI	R14,MASKF		:SET READ ONLY
	JAL	R15,MAKAMAC		:GO BUILD MAC REGISTER
	ST	R14,CTASEG*4+MPROT,R1	:SEGMENT 14d...PLACE FOR DDT
	ST	R14,CTASEG*4+MPROT,R4	:PLACE FOR BACKGROUND
	ST	R14,CTASEG*4+MPROT,R5	:PLACE FOR FOREGROUND
	AR	R12,R13			:NEW START OF USER SPACE
	LHL	R10,CMAX,R1		:NOW GET NUMBER OF BYTES LEFT TO USE
	SLLS	R10,MACPAG		:CONVERT PAGES TO BYTES
	SR	R10,R13			:R10 = NUMBER OF BYTES REMAINING
   IF	MACV				:
	LHL	R6,DMAOFF,R2		:Get slot DMA segment bit-map from CTA
	STH	R6,DMABIT,,		:Save the bit-map 
	LHL	R6,SLOT,R1		:Get the current slot number
	LIS	R7,8			:Calculate slot DMA area mapping table
	MHR	R6,R7			:offset
	L	R7,DMAMAP,R6,		:Get start address of slot DMA area
	ST	R7,DMATMP,,		:Save it into tmp storage
	L	R7,DMAMAP+4,R6,		:Get size of slot DMA area
	SLLS	R7,MSHFTB		:Make size into byte count
	ST	R7,DMATMP+4,,		:Save it into tmp storage
   EI  (MACV)				:
	LIS	R6,0			:R6 = MAC-REGISTER INDEX
	LIS	R7,0			:R7 = SIZE-SOURCE TABLE INDEX
	LIS	R8,0			:R8 = PROTECTION BYTE INDEX
SET.M2	L	R0,AREAS,R2,R7		:GET HIS REQUESTED AREA SIZE
SET.M3	LB	R14,R2,R3,R8		:FIND PROTECTION REQUIRED ON THIS SEGMENT
	NHI	R14,7			:
	LB	R14,PROTMAP,R14		:
	L	R13,MPROT,R1,R6		:CHECK FOR "COMMON" AREA
   IF	MACV				:
	TBT	R8,DMABIT,,		:Is it a  DMA segment needs relocation
	JE	SET.3M			:No, just skip ...
	CL	R0,DMATMP+4,,		:Is there engout space in slot DMA area
	JGR	R11			:No. abort it ...
	ST	R12,DMATMP+8,,		:Save start address of high core memory
	L	R12,DMATMP,,		:Setup start address of slot DMA area
	LR	R13,R0			:Setup the size of slot DMA area
	JAL	R15,MAKAMAC		:Make slot DMA segment MAC register ...
	AM	R13,DMATMP,,		:Make new start addr of slot DMA area
	L	R12,DMATMP+4,,		:
	SR	R12,R13			:
	ST	R12,DMATMP+4,,		:
	L	R12,DMATMP+8,,		:Restore seg. start address
	LIS	R13,0			:Set length to zero
	LIS	R0,0			:
	J	SET.M8			:
SET.3M	LR	R13,R13			:Is it a "common" area
   EI  (MACV)				:
	JGEFS	SET.M4			:SKIP IF NOT
	LR	R0,R0			:YES...CHECK HIS REQUEST
	JNR	R11			:TRYING TO SET UP THAT SEGMENT...ABORT
	NHI	R13,@(MASKF)		:OK...JUST SET HIS PROTECTION
	OR	R14,R13			:
	LIS	R13,0			:SIZE DOESN'T COUNT ON "COMMON"
	JFS	SET.M8			:AND SKIP
					:
SET.M4	LR	R13,R0			:CHECK AREA
	JGFS	SET.M6			:SKIP IF USED
SET.M5	LIS	R14,0			:NO...CANCEL PROTECTIONS
	LIS	R13,0			:FORCE SMALL
	JFS	SET.M8			:AND SKIP
					:
SET.M6	CLI	R13,SEGSIZ		:CHECK SIZE OF AREA
	JLEFS	SET.M7			:LESS THAN ONE SEG..SKIP
	LI	R13,SEGSIZ		:MORE...USE DEFAULT
SET.M7	JAL	R15,MAKAMAC		:SET IT UP
					:
SET.M8	ST	R14,MPROT,R1,R6		:DO FOR DDT
	ST	R14,MPROT,R4,R6		:DO FOR BACKGROUND
	ST	R14,MPROT,R5,R6		:DO FOR FOREGROUND
	AR	R12,R13			:COMPUTE NEW BASE ADDRESS
	SR	R10,R13			:REDUCE NMBR OF BYTES BY THIS SEGMENT
	JLR	R11			:USED TOO MANY...ABORT
	AIS	R6,4			:ADVANCE MAC INDEX
	AIS	R8,1			:AND PROTECTION INDEX
	CLHI	R8,CTASEG		:CHECK IF RANGE EXCEEDED
	JGE	SET.M9			:BR IF SO
	SIS	R9,1			:REDUCE SEGMENTS LEFT
	JLE	SET.M5			:FINISH UP IF NO MORE REQUESTED
	SR	R0,R13			:REDUCE NUMBER OF BYTES FOR THIS AREA
	JG	SET.M3			:IF AREA WAS TOO BIG, REPEAT
	AIS	R7,4			:GO TO NEXT AREA
	J	SET.M2			:REPEAT FOR EACH AREA
					:
SET.M9	HS				:
   if	MULMAC				:
	LIS	R2,0			:CLEAR CCOUNT, MACSET FOR DDT AGAIN
	STH	R2,CCOUNT,R1		:
	STB	R2,MACSET+1,R1		:
   ei  (MULMAC)				:
   if	MULTI				:MULTI-KERNEL PROCESSOR
	JAL	R10,SETSLU		:SLOT LOGICAL UNIT SETUP
   ei  (MULTI)				:
  if	1-NBLKS				:
	J	4,R11			:SUCCESS EXIT
  else					:
					:
:	.....................................................................
:	INITIALIZE MAC REGISTER SETS
:	EXPECTS R2 = BASE OF CTA TABLE
:       	UB = DDT BLOCK
:
:	NORMAT RETURN = FAILURE
:	SKIP (4)      = SUCCESS
:
:	USER MAC FORMAT:
:
:	PPPP NNNN LLLL LLLL XXRR RRRR RRRR RRRR
:
:	WHERE P = PROTECTION
:             N = BLOCK NUMBER
:             L = LENGTH
:             X = UNUSED
: 	      R = BASE POSITION RELATIVE TO BLOCK
:
:
:	MAC FORMAT
:
:	XXBB LLLL LLLL BBBB BBBB BBBB PPPP XXXX
:
:	WHERE X = UNUSED
:	      B = BASE ADDRESS OF SEGMENT
:	      L = LENGTH OF SEGMENT
:	      P = PROTECTION
:
:	.....................................................................
					:
EXTMAC	L	R2,SBASE,R1		:GET BASE OF CTA TABLE
	LHL	R0,CNTRL+2,R2		:TEST CNTRL WD
	THI	R0,X.EXM.		:IF EXT MEM IS USED
	JE	4,R11			:RETURN IF NOT USED
					:
	L	R0,STAMAC,R1		:IS MAC ALREADY SET?
	JN	4,R11			:RETURN IF YES
					:
:	.....................................................................
:	SET UP FIRST TWO AREAS
:	.....................................................................
					:
	L	R0,CTASIZE,R2		:
	AHI	R0,(PAGE-1)		:ROUND TO PAGE BOUNDRY
	NHI	R0,MACSIZ		:
	AI	R0,-1,R2		:ADD IN BASE
	SRLS	R0,8			:MAKE A PAGE INDEX
	STH	R0,BLOCKS+4+2,R1	:USE AS UPPER LIMIT
	AIS	R0,1			:START OF 0
	STH	R0,BLOCKS,R1		:
					:
	LR	R0,R2			:SET UP START OF CTA AREA
	SRLS	R0,8			:
	STH	R0,BLOCKS+4,R1		:
					:
	LHL	R4,CMAX,R1		:GET SLOT LENGTH IN PAGES
   if	TSIMAC!MACV			:
	SLLS	R4,2			:ADJUST FOR PAGE SIZE
   ei  (TSIMAC)				:
	AR	R0,R4			:UPPER LIMIT OF AREA 0
	SIS	R0,1			:MAKE ADDRESS OF LAST BLOCK
	STH	R0,BLOCKS+2,R1		:
					:
	LHL	R4,MACPNT,R2		:BASE LOC OF MAC
	C	R4,CTASIZ,R2		:
	JGER	R11			:ERROR IF TO FAR
	LR	R5,R4			:INTERNALLY AN INDEX IS USED
	AHI	R5,MACDIS,R2		:THAT IS CORRECT FOR A COPY
	ST	R5,STAMAC,R1		:USING THE COPY INSTRUCTION
					:
	LHL	R0,MAXCNT,R2		:GET COUNT OF MAC BLOCKS
	JE	4,R11			:RETURN IF NONE SPECIFIED
	STH	R0,LIMMAC,R1		:REMEMBER THE COUNT
	LHI	R6,$A16*4+3*4		:SIZE OF EACH BLOCK
	MHR	R0,R6			:
	AR	R4,R0			:LAST LOCATION USED
	C	R4,CTASIZE,R2		:CHECK IF TOO BIG
	JGR	R11			:
	AR	R5,R0			:FORM USED INTERNALLY
					:
	LHI	R13,400			:USED BY ACCESS
	ST	R11,KLINK		:SAVE FOR FUTURE RETURN
   if	MULMAC				:
	L	R10,MLINK,R1		:FOR LINKING IN MACS
   ei  (MULMAC)				:
					:
:	.....................................................................
:	CONVERT A SET OF MAC REGISTERS, THE PSD ADDRESS COUNT MSET AND
:	LINKS IF ZITEL OR TSI
:	.....................................................................
					:
EXT010	SHI	R5,$A16*4+3*4		:NEXT MAC BLOCK
	C	R5,STAMAC,R1		:DONE?
	JL	EXT030			:EXIT IF DONE
					:
	LHI	R4,-MACDIS		:INDEX TO FIRST MAC
EXT020	L	R0,0,R4,R5		:GET MAC
	JAL	R12,MKEXTM		:MAKE INT. FORMAT
	J	EXT050			:ERROR EXIT
					:
	AIS	R4,4			:NEXT MAC REGISTER
	JLBS	EXT020			:
					:
	L	R12,2,R5		:GET PSD LOC
	JAL	R11,ACCESS		:CONVERT TO ABS
	J	EXT050			:ERROR
	ST	R12,2,R5		:SAVE ABSOLUTE FORM
					:
   if	MULMAC				:
	ST	R10,0A,R5		:PREVIOUS R11
	LR	R10,R5			:FOR NEXT TIME
	LHL	R6,SLOT,R1		:FILL IN SLOT CNT AND MSET
	SLLS	R6,8			:
	ST	R6,06,R5		:
   ei  (MULMAC)				:
	J	EXT010			:NEXT BLOCK
					:
EXT030	HS	0			:
   if	MULMAC				:
	ST	R10,MLINK,R1		:THREAD R1
   ei  (MULMAC)				:
					:
EXT040	LH	R6,LIMMAC,R1		:MAXIMUM MAC BLOCK
	L	R4,STAMAC,R1		:
	LHL	R12,CNTRL+2,R2		:GET CONTROL WORD
	THI	R12,X.DMZ.		:SHOULD MAC SET BE 0 FOR DDT?
	JEFS	EXT045			:IF NOT, SKIP
	ST	R4,UMAC,R1		:MAKE IT MAC SET 0 FOR DDT
EXT045	L	R11,KLINK		:EXIT
					:
:	.....................................................................
:	INFORM OTHER JOBS
:	.....................................................................
					:
	L	R12,CONTROL,R1		:CONTROLLED JOB (BACKGROUND)
	JE	4,R11			:INCASE THERE IS NONE
	ST	R4,STAMAC,R12		:
	STH	R6,LIMMAC,R12		:SAVE LIMIT OF MACS
					:
	L	R12,OTHER,R12		:FOREGROUND
	JE	4,R11			:IN CASE THERE IS NONE
	ST	R4,STAMAC,R12		:
	STH	R6,LIMMAC,R12		:LIMIT OF MACS
	J	4,R11			:
					:
EXT050	L	R11,KLINK		:ERROR EXIT
	JR	R11			:
					:
:	.....................................................................
:	SUBROUTINE TO MAKE AN EXTENDED MAC
:
:	ASSUMES THAT
:
:       R0      CONTAINS A USER FORMAT MAC
:       R2      CONTAINS BASE OF CTA TABLE
:       R4      CONTAINS LOCATION OF MAC REL TO R5
:       R1      POINTS TO CURRENT USER BLOCK
:	.....................................................................
					:
MKEXTM	LHR	R6,R0			:COPY DISPLACEMENT
	EXHR	R7,R0			:GET LENGTH+BLOCK+PROTECTION
	EXBR	R8,R7			:COPY PROTEC+BLK
					:
	LR	R9,R8			:BUILD PROTECTION
	NHI	R9,0F0			:
	SRLS	R9,4			:
	LB	R9,PROTMAP,R9		:CONVERT USER PROT TO MAC PROT
					:
	NHI	R8,0F			:MASK BLOCK #
	CHI	R8,NBLKS		:WITHIN LIMITS?
	JGER	R12			:ERROR RETURN
					:
	LB	R0,BLKPRT,R1,R8		:
	SLLS	R0,MSHFTP		:LEFT JUSTIFY PROTECTION IN BIT
	OR	R0,R9			:LIMIT ACCESS
					:
	SLLS	R8,2			:MAKE FW PNTR
					:
	AH	R6,BLOCKS,R1,R8		:LOCATE FIRST PAGE
	CH	R6,BLOCKS+2,R1,R8	:CHECK LIMIT
	JGR	R12			:ERROR RETURN
					:
	LR	R9,R6			:CHECK LIMIT
	NHI	R7,0FF			:ISOLATE CNT
	AR	R9,R7			:COMPUTE DISPLACEMENT
	CH	R9,BLOCKS+2,R1,R8	:OVER LIMIT?
	JGR	R12			:ERROR RETURN
					:
	LR	R8,R6			:COPY BASE ADDR
   if	TSIMAC!MACV			:
	SRLS	R8,2			:ADJUST FOR PAGE SIZE
   ei  (TSIMAC!MACV)			:
	SLLS	R8,MSHFTB+MSHFTA	:PUT BASE IN POSITION
	NI	R8,MMASKR		:MASK OFF EXTRANEOUS BITS
	STBR	R0,R8			:COPY IN PROT
   if	TSIMAC!MACV			:
	SRLS	R7,2			:ADJUST FOR PAGE SIZE
	SLL 	R7,MSHFTL		:POSITION LENGTH
	OR	R8,R7			:PUT IT TOGETHER
   else					:
	NHI	R6,3000			:GET TOP BITS
	SRLS	R6,4			:POSITION FOR LENGTH
	STBR	R7,R6			:PUT IN LENGTH
	EXHR	R6,R6			:MOVE INTO FINAL POSITOION
	SLLS	R6,4			:
	OR	R8,R6			:PUT IT TOGETHER
   ei  (TSIMAC!MACV)			:
	ST	R8,0,R5,R4		:PUT IT AWAY
	J	4,R12			:SKIP RETURN
					:
  ei   (NBLKS)				:
					:
   if	MULTI				:MULTI-KERNEL PROCESSOR
					:
:	.....................................................................
:	ROUTINE SETS UP SEGMENT (SRSEG) FIELD FOR SHARED STORAGE
:       FOR SLOTS USER RINGS IN USER BLOCK. THE MAC REGISTER IS
:	IS ALSO SETUP
:	.....................................................................
					:
SETSLU	TS	SRSEG,R1		:INITIALIZE SEGMENT FIELD
	LIS	R2,0			:LOOP INDEX
SETS1	CLHI	R2,(MACREG-2)*4		:UP TO SEGMENT 0D
	JGR	R10			:NO SEGMENT SELECTED
	L	R3,MPROT,R1,R2		:GET MAC REGISTER
	THI	R3,MASK1		:CHECK FOR PRESENCE BIT
	JEFS	SETS2			:FOUND ONE
	AIS	R2,4			:UP INDEX
	JBS	SETS1			:TRY AGAIN
SETS2	SRLS	R2,2			:SHIFT TO GET SEGMENT NUMBER
	LR	R6,R2			:SAVE NUMBER
					:
:	.....................................................................
:	initial values
:	.....................................................................
					:
	LHI	R12,-1			:START ADDRESS
	LIS	R13,0			:SIZE VALUE
	LIS	R2,0			:LOOP INDEX
SETS3	CLHI	R2,SLUNUM*4		:COMPARE WITH HIGHEST VALUE
	JG	SETS9			:ARRAY SCANNED
	L	R7,SLUTBL,R1,R2		:DESCRIPTOR ELEMENT FOR ARRAY
	JNFS	SETS4			:LOOK FOR NON-ZERO DESCRIPTOR
	AIS	R2,4			:UP INDEX
	JBS	SETS3			:LOOK AT ANOTHER ELEMENT
					:
:	.....................................................................
:	process descriptor -- get lowest address and ring size
:	for MAKAMAC input
:	.....................................................................
					:
SETS4	L	R3,SDIEND,R7		:END ADDRESS FOR INPUT RING
	SH	R3,SDISIZ,R7		:SUBTRACT SIZE
	SIS	R3,4			:SUBTRACT CURSOR = BEG PHYS. ADDR.
	CLR	R3,R12			:IS THIS LOWEST?
	JCFS	SETS5			:NO
	LR	R12,R3			:YES-NEW LOW VALUE
SETS5	AH	R13,SDISIZ,R7		:INPUT RING SIZE
	AH	R13,SDOSIZ,R7		:OUTPUT RING SIZE
	AHI	R13,8			:CURSOR VAUES
	AIS	R2,4			:UP INDEX
	J	SETS3			:PROCESS ANOTHER DESCRIPTOR
SETS9	LR	R13,R13			:CHECK SIZE
	JER	R10			:EXIT ON NO RINGS DEFINED
	STH	R6,SRSEG,R1		:SEGMENT VALUE IN UB(DDT)
	STH	R6,SRSEG,R4		:SEGMENT VALUE IN UB(BACKGROUND)
	STH	R6,SRSEG,R5		:SEGMENT VALUE IN UB(FOREGROUND)
	LHI	R14,MASK1		:PROTECTION
	JAL	R15,MAKAMAC		:SET UP MAC REGISTER
	SLLS	R6,2			:SEGMENT NUMBER * 4
	ST	R14,MPROT,R1,R6		:FOR DDT
	ST	R14,MPROT,R4,R6		:FOR BACKGROUND
	ST	R14,MPROT,R5,R6		:FOR FOREGROUND
	JR	R10			:EXIT
   ei  (MULTI)				:
					:
:	.....................................................................
:	LOCAL ROUTINE TO MAKE A MAC REGISTER
:	R12	START ADDRESS
:	R13	SIZE (BYTES)
:	R14	PROTECTION (Returned final MAC register)
:	R15	Link Register
:	.....................................................................
					:
MAKAMAC	LR	R13,R13			:LOOK AT LENGTH
	JG	MAKAM1			:IF >0, CONTINUE
	LR	R14,R13			:CANCEL MAC REGISTER
	JR	R15			:RETURN
					:
MAKAM1	AHI	R13,PAGE-1		:ROUND UP PAGE
	SRLS	R13,MSHFTB		:RIGHT JUSTIFY IT
	SIS	R13,1			:GET HIGHEST PAGE
	SLL	R13,MSHFTL		:POSITION IT
	NI	R13,MMASKL		:MASK LENGTH
	NHI	R14,MMASKP		:MASK PROTECTION
	OR	R14,R13			:COMBINE WITH PROTECTION
	NI	R12,MACSTR		:MASK START ADDRESS
	SLLS	R12,MSHFTA		:ADJUST FOR MAC FORMAT
	OR	R14,R12			:NOW HAVE ALL ELEMENTS TOGETHER
	SRLS	R12,MSHFTA		:MAKE BACK INTO ADDRESS
	SRL	R13,MSHFTL		:RIGHT JUSTIFY LENGTH
	AIS	R13,1			:LENGTH IS 1> THAN HIGH PAGE
	SLLS	R13,MSHFTB		:MAKE SIZE IN BYTES
	JR	R15			:AND RETURN
					:
:	.....................................................................
:	ROUTINE TO GENERATE A DIAGNOSTIC ENTRY
:	EXPECTS	R4	SLOT #
:		R5	ABSOLUTE ADDRESS OF "SC" STRING
:	.....................................................................
					:
SETDIAG	L	R7,SLOWC		:GET CURRENT TIME
	JER	R11			:EXIT IF T=0
	LHL	R6,DIAGIN,,		:GET CURSOR
	ST	R5,DIAGNOS,R6,		:PLACE ADDRESS
	STB	R4,DIAGNOS,R6,		:PLACE SLOT #
	ST	R7,DIAGNOS+4,R6,	:PLACE TIME
	AIS	R6,8			:
	CLHI	R6,NDIAGN		:
	JLFS	.+4			:
	LIS	R6,0			:
	STH	R6,DIAGIN,,		:REPLACE CURSOR
	JR	R11			:AND RETURN
					:

	SUBTTL	KERNEL INITIALIZATION
					:
:	.....................................................................
:
:		ISIS Kernel Initialization 
:
:	.....................................................................
					:
KBUG1	S.HLTF(63)			:UNABLE TO SET UP SLOT, HALT
					:
KINIT	LHI	R1,20F0			:RSET F, ENABLE MACHINE MALFUNCTIONS
	EPSR	R2,R1			:
 if	SUP				:
	LI	R1,SCSIZ-4		:ZERO OUT SUP/NODE CODE COMM AREA
	LIS	R2,0			:
KINIT6	ST	R2,SCAREA,R1,		:
	SIS	R1,4			:
	JGEBS	KINIT6			:
 ei    (SUP)				:
					:
	LIS	R2,0			:
	LR	R1,R2			:
	STH	R1,FOREGT		:
 if	FSYS				:
	STH	R2,INUSE,,		:
 ei    (FSYS)				:
 if	SUP				:
  if	KIOSRC				:
	OHI	R1,10			:INIT SRC SIO RING DISPLAY
  ei   (KIOSRC)				:
  if	KIODES				:
	OHI	R1,1			:INIT DEST SIO RING DISPLAY
  ei   (KIODES)				:
 ei    (SUP)				:
	STH	R1,DISPLAY		:INIT DISPLAY BYTE
	LCS	R1,1			:
	ST	R1,CPSADR		:SET NODE CPS POINTER NEGATIVE
    if .GT.(NSLOT,$A16)			:
	LA	R1,UBFLASH,,		:POINT USER TO FLASH CODE USER BLOCK
    else				:
	LA	R1,UBFLASH		:POINT USER TO FLASH CODE USER BLOCK
    ei (  )				:
	ST	R2,LLINK,R1		:INSURE NOT LINKED TO ANYTHING
	ST	R1,USER			:
	ST	R1,RUN			:PUT ONTO RUN LIST
	ST	R1,RUSER		:MAKE CURRENT RUN-LIST USER
 if	MULMAC				:
	STH	R2,CCOUNT,R1		:ZERO CCOUNT, MAC SET
	STB	R2,MACSET+1,R1		:
 ei    (MULMAC)				:
	LM	R14,ACSLOT		:GET INITIAL STATE OF SLOTS
	STM	R14,RNSLOT		:
	LM	R14,SLICSL		:SAVE SUSPEND LICENSE BIT ARRAY
	STM	R14,SLICTM		:
	LIS	R4,4			:
KINT1A	L	R5,SLICTM,R4		:GET SLOTS WITH SUSPEND LICENSE
        TS      DHANG,,			:
	N	R5,ACSLOT,R4		:*THAT ARE LOADED
	JFFO	R5,KINT1B		:BR IF NONE IN THIS GROUP
	SIS	R4,4			:
	JGEBS	KINT1A			:TRY OTHER GROUP
	J	KINTSI			:
					:
KINT1B	RBT	R6,SLICTM,R4		:INDICATE SLOT LOOKED AT
	SLLS	R5,3			:SLOT GROUP NMBR TO POSITION
	AR	R6,R5			:MAKE SLOT NMBR
	SLLS	R6,2			:*4
	L	R6,SLIST,R6		:GET BACKGROUND USER BLOCK ADDR
	L	R6,CONTROL,R6		:GET DDT BLOCK ADDR
	L	R6,SBASE,R6		:GET SLOT START ADDR (SEG E)
	LM	R14,ISUSLO,R6		:GET INITIAL SUSPEND LIST
	O	R14,SSSLOT		:OR INTO SUSPENDED SLOT LIST
	O	R15,SSSLOT+4		:
	STM	R14,SSSLOT		:
	J	KINT1A			:GO GET NEXT SLOT
					:
:	.....................................................................
:	Clear the frequency count CCOUNT and the MAC set # MACSET+1, going
:	thru the entire list starting from SML.
:	.....................................................................
					:
KINTSI	HS	0			:
   IF	MULMAC				:
	LIS	R3,0			:REGISTER USED TO CLEAR
	L	R4,SML,,		:GET PTR TO 1ST MAC LBK IN LIST
	JE	KINT1C
KINT1D	STH	R3,-MACDIS-MPROT+CCOUNT,R4	:CLEAR FREQUENCY
	STB	R3,-MACDIS-MPROT+MACSET+1,R4	:CLEAR MAC SET #
	L	R4,-MACDIS-MPROT+MLINK,R4	:GET NEXT MAC BLOCK
	JNBS	KINT1D				:LOOP UNTIL END OF LIST
   EI  (MULMAC)				:
KINT1C	LHI	R4,NPART		:THEN...FOR ALL SLOTS
					:
KINIT1	TBT	R4,ACSLOT		:SHOULD THIS SLOT BE CONNECTED?
	JE	KINIT3			:NO...SKIP
 if	IPNMBR				:
	TBT	R4,IPDLCS		:SLOT FOR IPI CODE TO DOWN-LINE LOAD?
	JE	NOTDLC			:
	STH	R4,DUMMY		:
	SLHLS	R4,2			:
	L	R3,SLIST,R4		:LOCATE BACKROUND BLOCK
	LHL	R4,DUMMY		:
	L	R14,CONTROL,R3		:
	LHI	R3,0B^2			:
	STH	R3,EFLAG,R14		:
	RBT	R4,RNSLOT		:
	J	KINIT3			:
 ei    (IPNMVR)				:
NOTDLC	STH	R4,DUMMY		:OKAY TO CONECT, SAVE INDEX
	SLHLS	R4,2			:MAKE A WORD INDEX
	L	R3,SLIST,R4		:LOCATE BACKGROUND BLOCK
	L	R2,OTHER,R3		:FOREGROUND BLOCK
	JNFS	KINIT7			:SKIP IF THERE IS A FRGND FOR SLOT
	LR	R2,R3			:ELSE FAKE IT
KINIT7	HS	0			:
 if	MXP				:
	L	R14,CONTROL,R3		:GET DDT BLOCK ADDR
	CLHI	R4,SLTXMI^2		:DO NOT START UP XPI MEM IMAGE SLOT
	JNFS	KINIT5			:
	LHI	R3,0B^2			:INDICATE SLOT LOADED
	STH	R3,EFLAG,R14		:
	LHL	R4,DUMMY		:
	RBT	R4,RNSLOT		:ITS NOT REALLY RUNNING
	J	KINIT3			:
KINIT5	LHL	R0,WFLAG,R2		:GET FRGND WAIT FLAGS
	NHI	R0,@XPIWF		:CANCEL XPI WAIT
	STH	R0,WFLAG,R2		:REPLACE FLAGS
	LHL	R0,WFLAG,R3		:GET BKGRND WAIT FLAGS
	NHI	R0,@XPIWF		:CANCEL XPI WAIT
	STH	R0,WFLAG,R3		:REPLACE FLAGS
	LHL	R0,WFLAG,R14		:GET DDT WAIT FLAGS
	NHI	R0,@XPIWF		:CANCEL XPI WAIT
	STH	R0,WFLAG,R14		:REPLACE FLAGS
 ei    (MXP)				:
	L	R0,WFROGT,R3		:WATCHFROG ENABLED?
	AIS	R0,2			:
	JE	KINIT8			:BR IF NOT
	LCS	R0,1			:
	ST	R0,WFROGT,R3		:TURN OFF SVC WATCHFROG
	ST	R0,WFROGT,R2		:
 if	\HI.FRG				:
	L	R0,SLOWC		:
	AHI	R0,WFTIME+5		:
	ST	R0,WFROGD,R3		:INIT DISMISS WATCHFROG
	ST	R0,WFROGD,R2		:
 ei    (\HI.FRG)			:
KINIT8	LIS	R0,0			:INIT THE SLOT'S SUSPEND LIST
	ST	R0,SUSLST,R2		:IN THE FG & BG USER BLOCKS
	ST	R0,SUSLST,R3		:
	ST	R0,SUSLST+4,R2		:
	ST	R0,SUSLST+4,R3		:
 if	MULMAC				:
	LIS	R2,0			:GET A NULL
	STH	R2,CCOUNT,R3		:ZERO MACSET, CCOUNT
	STB	R2,MACSET+1,R3		:
 ei    (MULMAC)				:
 if	SUP				:
	CLHI	R4,(NSLOT+1)*4		:
	JL	KINIT0			:SKIP IF NOT SUP OR SUP-SLAVE SLOT
	JN	KINT8A			:BR IF SUP-SLAVE SLOT
	L	R4,RUN			:PUT SUP ON RUN LIST
	ST	R4,LLINK,R3		:
	ST	R3,RUN			:
	L	R1,CONTROL,R3		:GET DDT USER BLOCK
	LHI	R2,0B^2			:INDICATE SLOT LOADED
	STH	R2,EFLAG,R1		:
 if	MULTI				:
	LH	R2,SRSEG,R3		:HAS IT BEEN SET UP
	JGE	KINIT2			:IF SO, DON'T DO IT AGAIN
	LR	R4,R3			:COPY SUP UB POINTER
	L	R1,CONTROL,R4		:DDT UB POINTER
	LR	R5,R4			:NO FOREGROUND UB
	JAL	R10,SETSLU		:SETUP SIO RINGS
 ei    (MULTI)				:
   if	KIOSRC				:
	LI	R0,SUPPAN		:GET CONSOLE POINTER
	ST	R0,SUPDIS		:
	JE	KINIT2			:NO PTR
	LR	R8,R1			:COPY UB PTR
	JAL	R9,TRASL		:MAKE PHYSICAL ADDRESS
	J	KINIT2			:ERROR, DON'T SET IT UP
	LHI	R1,(NSLOT+1)*4		:GET SUP SLOT INDEX
	LO	FLASH			:
	ST	R0,DISTBL,R1,		:UPDATE DISPLAY PTR TBL
	ST	R0,SUPDIS		:
	FO	FLASH			:
   ei  (KIOSRC)				:
	J	KINIT2			:
					:
KINT8A	LHL	R0,DUMMY		:FOR SUP-SLAVES, TURN OFF BIT
	RBT	R0,ACSLOT
	RBT	R0,RNSLOT
	LHI	R2,0B^2			:INDICATE SLOT LOADED
	STH	R2,EFLAG,R3
	L	R2,CONTROL,R3		:GET POINTER TO A CONTROLLED JOB
	JE	KINIT2			:MUST BE A SUP SUPER KLUDGE
	LH	R0,UFLAG,R2		:CHECK THAT JOB'S FLAGS
	THI	R0,FKIOJ		:
	JE	KBUG1			:NON-KIO JOBS NOT STARTED THIS WAY
	L	R3,OTHER,R2		:GET POINTER TO FREE DESCRIPTOR
	LHI	R0,@2000		:TURN OFF LOCK BIT
	NH	R0,GGUSE,R3		:
	STH	R0,GGUSE,R3		:CAN NOW LOG INTO CONTROLLED SLOTS
	J	KINIT2			:THEN SKIP TO SERVICE NEXT SLOT
KINIT0	HS	0			:
 ei	(SUP)				:
					:
	L	R1,CONTROL,R3		:NOW GET CONTROLLING DDT BLOCK
	JAL	R11,SETMAC		:
	J	KBUG1			: ERROR RETURN...HALT THE MACHINE
	LR	R14,R1			:POINTER TO DDT
	LHI	R4,9^2			:SET CODE 9 - DDT
	STH	R4,EFLAG,R14
	LHL	R13,DUMMY		:GET BACK SLOT INDEX AGAIN
	TBT	R13,SSSLOT		:SEE IF SLOT SUSPENDED
	JN	KINIT2			:DONE IF SO
	SLHLS	R13,2			:SLOT*4
	L	R12,CONTROL,R1		:POINTER TO BACKGROUND
	LHI	R0,F1CRAS		:SET TO DIE ON NEXT CRASH
	OH	R0,UFLAG,R12		:
	STH	R0,UFLAG,R12		:
	L	R4,RUN			:PUT ON RUN LIST
	ST	R4,LLINK,R12		:
	ST	R12,RUN			:
	JAL	R10,K.KNCT		:GO SET UP FROM CTA
	J	KBUG1			:
KINIT2	LHL	R4,DUMMY		:RESTORE INDEX
KINIT3	SIS	R4,1			:
	JGE	KINIT1			:REPEAT FOR ALL SLOTS
	L	R14,XLFREE		:NOW RELINK ALL FREE-LIST BLOCKS
	ST	R14,LFREE		:...IN CASE ONE GOT LOST SOMEWHERE
KINIT4	L	R15,XLLINK,R14		:
	ST	R15,LLINK,R14		:
	LR	R14,R15			:CHAIN DOWN LIST
	JNBS	KINIT4			:REPEAT AS NECESSARY
	ST	R14,NXTFU		:NO NEXT-FOREGROUND-USER
	STH	R14,DUMMY		:SET DUMMY AVAILABLE
	LHI	R14,0070		:Set up interrupt into register set 7 
	LA	R15,MACHMAL		:MACHINE MALFUNCTION ROUTINE ADDR
	STM	R14,MMPSD		:MACHINE MALFUNCTION NEW PSW
	LA	R15,MINT		:RELOCATION PROTECTION INTERRUPT
	STM	R14,RELPSW		:
	LA	R15,ILLINS		:ILLEGAL INSTRUCTION TO KERNEL
	STM	R14,ILPSD		:
	LHI	R15,6200		:INTERRUPTS ENABLE BUT RSET 0
	ST	R15,SVCPSW		:
	LM	R8,VECTOR		:INITIALIZE SVC VECTOR
	STM	R8,SVCVEC		:
	L	R0,FASTC		:SET TIME TO RUN FLASHER FOREGROUND NOW
	STH	R0,FLASHN		:
					:
   if	SPAM				:3/87
					:
:	.......................................................................
:	INITIALIZE SPAM FLAGS AND TABLES
:	.......................................................................
					:
        JAL     R4,RESALL               :RESET ALL SPAM ACCUMULATORS
   ei  (SPAM)				:
					:
   IF	MACTRC				:IF MAC TRACE LOGIC 
        LIS     R0,0			:
        LHI     R4,TRACEE		:
IZMACTR STH     R0,TRACMD,R4            :CLEAR MAC TRACE DATA AND CONTROL
        SIS     R4,2			:
        JGEBS   IZMACTR			:
        STH     R0,350                  :INSURE MAC TRACE IS DISABLED
   EI  (MACTRC)				:
	JAL	R1,IZCLOK,,		:INIT CLOCK AGAIN, TOO LONG HAS PASSED
	LPSW	MAINPSD			:ENABLE INTS, ENTER MAIN LOOP
					:
 if	SPAM				:
RESALL  LIS     R3,0			:
        LHI     R1,SPSIZE		:
CLRTBL  ST      R3,SPAREA,R1		:
        SIS     R1,4                    :CLEAR A WORD AT A TIME
        JGEBS   CLRTBL			:
        L       R3,SLOWC                :GET SLOWC
        ST      R3,STARTC,,             :RECORD TIME OF SYSTEM RESTART
RESA11  AHI     R3,$A 60                :ADVANCE CLOCK EXPIRATION 60 SECONDS
    if .GT.(NSLOT,$A32)			:
        ST      R3,ADVCLK,,		:
        L       R2,CPSADR,,             :FETCH POINTER FOR NODE CPS
    else				:
        ST      R3,ADVCLK		:
        L       R2,CPSADR               :FETCH POINTER FOR NODE CPS
    ei (  )
        JLR     R4                      :RETURN IF CPS ADDRESS MISSING
        L       R3,0,R2			:
        ST      R3,NODCPS,,             :SAVE FIRST HALF OF NODE CPS RATE
        L       R3,4,R2			:
        ST      R3,NODCPS+4,,           :SAVE SECOND HALF OF NODE CPS RATE
        JR      R4			:
RESCNT	LIS	R3,0            	:CLEAR ONLY CURRENT ACTIVE COUNTERS
	LHI	R2,CNTEND		:
ZLOOP	ST	R3,SPMTBL,R2		:
	SIS	R2,4			:
	JGEBS	ZLOOP			:
	L	R3,SLOWC		:GET 1 SECOND TIMER
        J       RESA11                  :GO FINISH UP
 ei	(SPAM)

 if	SPAM
					:CHARACTER COUNTS
 if	MXP			
GETDCT	EQ	.			:ROUTINE TO GET MXP DISPATHER CHAR CNT

	LHI	R3,NSLOT		:START WITH LAST SLOT
NXDC1	TBT	R3,RNSLOT		:CHECK IF SLOT HALTED
	JE	NXDC2			:SKIP COUNT IF HALTED
	LR	R0,R3			:SAVE SLOT NUMBER
	OHI	R0,200			:SET FUNC = 2, GET IN/OUT CHAR COUNTS
	EXHR	R0,R0
	SVC	SYS,$A 45		:GET DISPATCHER CHAR CNTRS
	LIS	R0,0			:ZERO COUNTERS IF SLOT IS DOWN
	LIS	R1,0
	SLLS	R3,2			:MAKE WORD INDEX
	AM	R0,IOCHRS+8,R3,R3	:SAVE SLOT INPUT CPS COUNT
	AM	R0,IOCHRS		:SAVE TOTAL INPUT COUNT FOR ALL SLOTS
	AM	R1,IOCHRS+0C,R3,R3	:SAVE SLOT OUTPUT CPS COUNT
	AM	R1,IOCHRS+4		:SAVE TOTAL OUTPUT COUNT FOR ALL SLOTS
	SRLS	R3,2			:UN-WORD INDEX

	LR	R0,R3
	OHI	R0,100			:SET FUNC = 1, CLEAR CHAR CNTRS
	EXHR	R0,R0
	SVC	SYS,$A 45		:CLEAR DISPATCHER CHAR CNTRS
	NOP				:RETURN FOR SLOT DOWN OR BAD FUNCTION
NXDC2	SIS	R3,1			:DECREMENT SLOT NO
	JGE	NXDC1

	if	ENHMXP			:version 3.00 of MXP-XPI
	LI	R0,05000000		:GET DISPATCHER CHARACTER COUNT
	SVC	SYS,$A 45
	ST	R0,DSPCNT		:SAVE DISPATCHER COUNT
	ei	(ENHMXP)
	JR	R4			:RETURN
 ei
 ei	(SPAM)


	SUBTTL	****	ISIS KERNEL SCHEDULER	****
:		****	   THE MAIN LOOP	****

:	....................................................................
:       USER DISMISS ENTERS HERE TO RECORD SPAM DATA
:	....................................................................
					:
UDMISS	EQ	.			:
 if	SPAM				:
  if	SPMTRC				:
	LIS	R10,4			:SPAM TRACE ROUTINE ID
  ei   (SPMTRC)				:
	L	R1,USER			:
	JAL	R9,ENTIM		:GET USER TIMOUT DATA
 ei    (SPAM)				:
					:
:	....................................................................
:	FIRST PRIORITY...DETERMINE IF FOREGROUND JOBS ARE DUE TO BE RUN
:	....................................................................
					:
MAIN	EQ	.			:
 if	SPAM				:
:	....................................................................
:       TEST FOR TRACE RESTART
:	....................................................................
					:
    if .GT.(NSLOT,$A32)			:
	LHL	R3,ENAB,,		:CHECK ENABLE FLAG
	JEFS	NOCHG			:NON ZERO WILL RESET TRACE ***etm
	JAL	R4,RESALL		:RESTART TIMER & CLR COUNTS
	LCS	R4,1			:
	STH	R4,SPRDY,,		:SET SPAM READY FLAG
    else				:
	LHL	R3,ENAB			:CHECK ENABLE FLAG
	JEFS	NOCHG			:NON ZERO WILL RESET TRACE ***etm
	JAL	R4,RESALL		:RESTART TIMER & CLR COUNTS
	LCS	R4,1			:
	STH	R4,SPRDY		:SET SPAM READY FLAG
    ei (   )				:
NOCHG	EQ	.			:
					:
:	....................................................................
:	CHECK SPAM COUNTERS FOR ERRORS
:	IF CKKPT IS NON-ZERO, AN ERROR IN THE COUNTERS HAS OCCURRED
:	....................................................................
					:
    if .GT.(NSLOT,$A32)			:   
	L	R3,ENDCNT,,		:GET JOB END TALLY
	C	R3,BEGCNT,,		:SUBTRACT JOB STARTS
	JNFS	CKPTER			:IF UNEQUAL, SPAM ERROR
	C	R3,MAICNT,,		:GET SCHEDULER PASSES
	JE	SPMCHK			:IF EQUAL, PROCEED
    else				:
	L	R3,ENDCNT		:GET JOB END TALLY
	C	R3,BEGCNT		:SUBTRACT JOB STARTS
	JNFS	CKPTER			:IF UNEQUAL, SPAM ERROR
	C	R3,MAICNT		:GET SCHEDULER PASSES
	JE	SPMCHK			:IF EQUAL, PROCEED
    ei (  )				:
CKPTER	EQ	.			:
  if	SPMTRC				:
	LH	R3,TRCON,,		:CHECK IF TRACE ALREADY ON
	JN	CKPTR1			:
  ei   (SPMTRC)				:
	LHL	R3,SPRDY,,		:
	JE	SPMCHK			:
	LIS	R3,4			:
	STH	R3,CHKPT,,		:SET SPAM ERROR
  if	SPMTRC				:
    if .GT.(NSLOT,$A32)			:
	STH	R3,TRCON,,		:ALSO TURN TRACE OFF
	L	R3,BEGCNT,,		:SAVE COUNTERS AT THIS POINT
	ST	R3,TRCNTR,,		:
	L	R3,ENDCNT,,		:
	ST	R3,TRCNTR+4,,		:
	L	R3,MAICNT,,		:
	ST	R3,TRCNTR+8,,		:
    else				:
	STH	R3,TRCON		:ALSO TURN TRACE OFF
	L	R3,BEGCNT		:SAVE COUNTERS AT THIS POINT
	ST	R3,TRCNTR		:
	L	R3,ENDCNT		:
	ST	R3,TRCNTR+4		:
	L	R3,MAICNT		:
	ST	R3,TRCNTR+8		:
    ei (  )				:
CKPTR1	EQ	.			:
  ei   (SPMTRC)				:
SPMCHK	EQ	.			:
	LIS	R0,1			:
    if .GT.(NSLOT,$A32)			:
	AM	R0,MAICNT,,		:BUMP MAIN COUNTER
	AM	R0,SKEDCT,,		:BUMP 1 MINUTE MAIN COUNTER
    else				:
	AM	R0,MAICNT		:BUMP MAIN COUNTER
	AM	R0,SKEDCT		:BUMP 1 MINUTE MAIN COUNTER
    ei (  )				:
 ei    (SPAM)				:
					:
MAINXX	EQ	.			:
	LHL	R0,FASTC+2		:GET THE CURRENT FASTC TIME
 IF	FORGND				:
 ELSE					:
	LR	R4,R0			:MAKE A COPY OF CURRENT FASTC
	SH	R0,BGTIME		:SUBTRACT PREVIOUS START TIME
	NHI	R0,-1			:MAKE MASK FOR FASTC ROLLOVER
	STH	R4,BGTIME		:SAVE CURRENT TIME FOR NEXT ENTRY
 EI    (FORGND)				:
					:
 IF	FORGND				:ONLY IF FORGND PRESENT IN THIS
  if	NASYNG				:MACHINE
:	....................................................................
:	FIRST DETERMINE IF FLASHER FOREGROUND IS DUE TO BE RUN
:	....................................................................
					:
	LR	R4,R0			:MAKE A COPY
	SH	R4,FLASHN		:WHEN THE FLASHER FOREGROUND SHOULD RUN NEXT
	LHR	R4,R4			:
	JL	MAIN0			:NOT YET!
	LIS	R0,FLASHP		:RUN IT NOW...SET TIME FOR NEXT RUN
	AHM	R0,FLASHN		:
	LCS	R0,FLASHD		:DURATION OF RUN FOR FLASHER
	LA	R1,QFLASH,,		:SET UP TO RUN FLASHER NEXT
  if	MULMAC				:SET UP MULTIPLE MAC SET MAC
	LIS	R2,0			:
	STH	R2,35C			:
  ei   (MULMAC)				:
	LI	R2,MMASKL!MASK1		:FULL SEGMENT WITH PRESENCE
	ST	R2,MACAREA		:SET UP MAC FOR MICRO CODE
	J	START1			:AND PROCEED (NEEDS NO MAC)
MAIN0	HS	0			:
  ei	(NASYNG)			:
					:
:	....................................................................
:	DETERMINE IF ANY FOREGROUND PROCESSES SHOULD RUN
:	....................................................................
					:
	L	R1,NXTFU		:IS THERE A NEXT-FOREGROUND-USER ALREADY SCHEDULED?
	JN	MAIN1			:PROCEED IF SO
	SH	R0,FOREGT		:NO...IS IT NOW TIME TO SERVICE FOREGROUNDS?
	LHR	R0,R0			:
	AIS	R0,1			:(THEY MAY GO UP TO 1 TICK EARLY)
	JL	MAIN5			:NO...PROCEED WITH NON-FOREGROUND LOOP
	LHI	R1,FGNDP		:TIME TO START SET OF FOREGROUNDS...SET NEXT START TIME
	AHM	R1,FOREGT		:
	L	R1,QUASI		:NOW GET LIST OF FOREGROUND PROCESSES TO EXECUTE
	JE	MAIN4			:SKIP IF NONE
  if	CPUOVL				:
	TS	FGLD			:CHECK INST. FG OVERLOAD
	JGEFS	MAIN1			:NO OVERLOAD
	LIS	R2,1			:COUNT OVERLOAD
	AHM	R2,FGER			:
  ei   (CPUOVL)				:
MAIN1	L	R5,LLINK,R1		:GET NEXT ENTRY IN LIST
	ST	R5,NXTFU		:HE WILL BECOME THE NEXT FOREGROUND USER
	LHL	R6,WFLAG,R1		:
	THI	R6,FREEZE		:CHECK IF FROZEN
	JN	MAIN3			:IGNORE ANY FROZEN FOREGROUND PROCESSES
	THI	R6,FTIM			:CHECK IF WAITING TIMEOUT
	JEFS	MAIN2			:NO...SKIP
	L	R7,FASTC		:SLEEPING
	CL	R7,UTIME,R1		:IS TIME UP?
	JLFS	MAIN3			:SKIP IF NOT
	NHI	R6,@FTIM		:ELSE CLEAR CONDITION
	STH	R6,WFLAG,R1		:
MAIN2	LH	R0,FQNTUM,R1		:HOW LONG TO RUN HIM
	J	START			:AND GO TO IT
MAIN3	LR	R1,R5			:THE ONE WE'RE LOOKING AT IS IN TIMEOUT
	JN	MAIN1			:PROCEED IF THERE IS ANOTHER TO SERVICE
					:
MAIN4	SHI	R0,FGNDP		:FOREGROUND QUEUE EMPTY...CHECK IT AGAIN IN 1 PERIOD
					:
MAIN5	SIS	R0,1			:NOW R0 = - TIME LEFT TO GO
  if	NASYNG				:
	CR	R0,R4			:
	JGEFS	MAIN6			:MINIMUM OF TIME TO FLASHER, OTHER FOREGROUNDS
	LR	R0,R4			:
  ei   (NASYNG)				:
 EI    (FORGND)				:
					:
:	....................................................................
:	SECOND PRIORITY...DOES LAST USER GET ANOTHER CHANCE?
:	....................................................................
					:
MAIN6					:
   if	CPUOVL				:
	LIS	R1,0			:CLEAR INST OVERLOAD
	STH	R1,FGLD			:
   ei  (CPUOVL)				:
	L	R1,RUSER		:CURRENT RUN-LIST USER IN ROUND ROBIN
	JE	MAIN7			:IF NONE, PROCEED WITH DISPATCHER
	LH	R4,QUANTUM,R1		:CHECK THE CURRENT JOB
   IF	FORGND				:
   ELSE					:
	AR	R4,R0			:ADJUST QUANTUM BY ELAPSED TIME
	STH	R4,QUANTUM,R1		:
   EI  (FORGND)				:
	JGE	MAIN7			:SKIP IF IT TIMED OUT OR DISMISSED ITSELF
	LHL	R5,WFLAG,R1		:VERIFY HE'S NOT NOW SLEEPING
	JN	MAIN7			:IF HE IS, IGNOR HIM
   IF	SPAM				:
	LIS	R2,1			:
	AM	R2,SKEDRN		:KERNEL SCHEDULER RE-ENTRY COUNTER
   EI  (SPAM)				:
   IF	FORGND				:
	SR	R4,R0			:REDUCE TIME REQUIRED BY TIME REMAINING
	STH	R4,QUANTUM,R1
	JLE	START			:AND START HIM UP IF NEEDS MORE THAN AVAILABLE
	AR	R0,R4			:NEEDS LESS TIME THAN AVAILABLE
   ELSE					:
	LR	R0,R4			:REDUCE TIME REQUIRED BY TIME REMAIN
   EI  (FORGND)				:
	J	START			:AND START HIM UP
					:
:	....................................................................
:	THIRD PRIORITY...SERVICE DISPATCHER AND DDT REQUESTS
:	....................................................................
					:
MAIN7	HS				:
  IF	DISPAT				:ONLY IF DISPATCHER PRESENT IN ISIS?
   if	MXP				:
	JAL	R9,KDI01,,		:PROCESS KDIO INPUT FROM XPI
   ei  (MXP)				:
	LH	R4,SCRASH		:DISPATCHER WANT US TO CRASH ANYONE?
	JL	MAIN7A			:SKIP IF NOT
	TS	SCRASH			:YES...CLEAR REQUEST
	L	R1,SLIST,R4		:GET POINTER TO SLOT BLOCK
	LH	R11,FRGCRS		:CHECK IF THE CRASH IS A WATCH FROG
	JLFS	MAN7AA			:IF NOT - JUMP
	KRCODE(0,0C,9)			:WATCH FROG TIME OUT
	TS	FRGCRS			:RESET WATCH FROG FLAG
	JFS	MAN7AB			:
MAN7AA	KRCODE(0,5,3)			:SET DISPATCHER CRASH
MAN7AB	JAL	R11,KRASH		:
	J	MAINXX			:AND RETURN TO MAIN LOOP
  EI   (DISPAT)				:
					:
:	....................................................................
:	DOES SOMEONE WANT A SLOT STARTED?
:	....................................................................
					:
MAIN7A	LH	R4,CT.SLT		:SLOT RUN PENDING?
	JGEFS	MAIN7G			:BR IF SO
	LH	R4,RS.SLT		:SLOT RESUME PENDING?
	JL	MAIN7B			:BR IF NOT
	TS	RS.SLT			:YES...CLEAR REQUEST
	RBT	R4,SSSLOT		:FLAG SLOT RESUMED
	LA	R5,M7CMSG		:LOG DIAGNOSTIC
	JFS	MAIN7H			:
MAIN7G	TS	CT.SLT			:YES...CLEAR REQUEST
	SBT	R4,ACSLOT		:FLAG SLOT ACTIVE
	SBT	R4,RNSLOT		:
	LA	R5,M7AMSG		:LOG DIAGNOSTIC
MAIN7H	JAL	R11,SETDIAG		:
	SLHLS	R4,2			:MAKE WORD INDEX
	L	R1,SLIST,R4		:GET POINTER TO SLOT BLOCK
	L	R4,RUN			:R11 TO START OF RUN LIST
	ST	R4,LLINK,R1		:
	ST	R1,RUN			:
 if	MULMAC				:
	LIS	R4,0			:INITIALIZE THE MAC SET
	STH	R4,CCOUNT,R1		:CCOUNT AND MACSET
	STB	R4,MACSET+1,R1		:
 ei    (MULMAC)				:
	J	MAIN8			:AND PROCEED
M7AMSG	SC	/Started/		:
M7CMSG	SC	/Resumed/		:
					:
:	....................................................................
:	DOES SOMEONE WANT A SLOT HALTED?
:	....................................................................
					:
MAIN7B	LH	R4,DC.SLT		:SLOT HALT PENDING?
	JGEFS	MAIN7I			:BR IF SO
	LH	R4,SS.SLT		:SLOT SUSPEND PENDING?
	JL	MAIN7C			:SKIP IF NOT
	TS	SS.SLT			:YES, CLEAR REQUEST
	SBT	R4,SSSLOT		:SET SUSPENDED
	LA	R5,M7DMSG		:LOG DIAGNOSTIC
	JFS	MAIN7J			:
MAIN7I	TS	DC.SLT			:YES, CLEAR REQUEST
	RBT	R4,ACSLOT		:SET NOT ACTIVE
	RBT	R4,RNSLOT		:
	LA	R5,M7BMSG		:LOG DIAGNOSTIC
MAIN7J	JAL	R11,SETDIAG		:
	JAL	R11,DCKIO		:DISCONNECT KIO PORTS
	SLLS	R4,2			:MAKE WORD INDEX
	L	R1,SLIST,R4		:GET POINTER TO SLOT BLOCK
	JAL	R11,RDISC		:GO DISCONNECT HIM
	JAL	R11,SUSSLT		:SET UP ASSOCIATED SLOT SUSPENSION
	JAL	R11,DCDEV		:DISCONNECT DEVICES TOO
	LH	R4,UFLAG,R1		:
	THI	R4,FDISP		:
	JEFS	MAIN7Q			:NO,SKIP IT
   if	MXP				:
	LHI	R0,KDMDSC		:TELL XPI TO DISCONNECT SLOT
	JAL	R4,KDOS			:
	LHL	R0,SLOT,R1		:SLOT NMBR
	JAL	R4,KDOH			:
	JAL	R4,KDOE			:
   else					:
    if	NSLOT				:
	GL	DSWCH			:
	LHL	R4,SLOT,R1		:
	LH	R5,DSLOT,,		:SEE IF DISPATCHER IS RUNNING
	JGEFS	.+8			:YES..SKIP
	STH	R4,DSLOT,,		:
	SLHLS	R4,2			:
	STH	R4,DSWCH,,		:
    ei (NSLOT)				:
   ei  (MXP)				:
MAIN7Q	L	R1,OTHER,R1		:GET BACKGROUND
	JAL	R11,FDISC		:DISCONNECT IT TOO
	J	MAIN8			:
M7BMSG	SC	/Halted/		:
M7DMSG	SC	/Suspended/		:
					:
:	....................................................................
:	DOES ESYNC WANT A SLOT HALTED?
:	....................................................................
					:
MAIN7C	HS	0			:
  if	NSYNC				:
    if	ESYNCI				:
	L	R4,DC.IRA		:HAS E-SYNC ASKED THAT WE STOP ANYONE?
	JFFO	R4,MAIN7E		:SKIP IF SO
	L	R4,DC.IRA+4		:
	JFFO	R4,MAIN7D		:
	JFS	MAIN7F			:NO...SKIP
MAIN7D	AHI	R5,20			:YES...SET SECOND GROUP
MAIN7E	RBT	R5,DC.IRA		:AND NOW CANCEL REQUEST
	SLLS	R5,2			:MAKE WORD INDEX
	L	R1,SLIST,R5		:GET POINTER TO SLOT BLOCK
	KRCODE(0,4,8)			:SET PROT.VIOLATION//DEVICE-CHECK CRASH
	JAL	R11,KRASH		:
	J	MAINXX			:AND RETURN TO MAIN LOOP
MAIN7F	HS	0			:
   ei  (ESYNCI)				:
  ei   (NSYNC)				:
					:
:	....................................................................
:	FOURTH PRIORITY...SERVICE DISPATCHER
:	....................................................................
					:
MAIN8	HS				:
 if	DISPAT				:
	LH	R2,DSLOT		:CHECK IF DISPATCHER TO RUN
	JLFS	MAIN9			:SKIP IF NOT
    if .GT.(NSLOT,$A32)			:
	LA	R1,UBDISP,,		:ELSE SET DISPATCHER TO RUN
    else				:
	LA	R1,UBDISP		:ELSE SET DISPATCHER TO RUN
    ei (  )				:
    if	SPAM				:
	LIS	R5,8			:
	SBT	R5,UFLAG,R1		:SET BIT IN 'UFLAG' FOR DISP. JOB
    ei (SPAM)				:
	SLLS	R2,2			:MAKE INDEX
	AIS	R2,2			:BIAS THE LOCAL CLOCK INDEX
	J	START3			:GO START UP DISPATCHER (NEEDS NO MAC)
 ei    (DISPAT)				:
					:
:	....................................................................
:	SELECT NEXT RUNABLE USER
:	....................................................................
					:
MAIN9	L	R1,RUSER		:CURRENT RUN-LIST RUN USER IN ROUND ROBBIN
	JE	MAINXX			:IF NONE, BACK TO MAIN LOOP
	LH	R4,STIME,R1		:HE RAN OUT OF SLICE...SET HIM UP FOR NEXT TIME
	STH	R4,QUANTUM,R1		:
	ST	R1,ENDUSER		:GO AROUND LOOP ONCE IF ALL JOBS SLEEPING
MAIN10	L	R1,LLINK,R1		:PTR TO NEXT USER
	JNFS	MAIN11			:SKIP IF NOT END OF LIST
	L	R1,RUN			:ELSE START OVER AT BEGINNING OF LIST
MAIN11	ST	R1,RUSER		:NEW CURRENT RUN-LIST USER
   IF	FORGND				:
   ELSE					:
	LH	R0,QUANTUM,R1		:SETUP RUN TIME PER TIME SLICE
   EI  (FORGND)				:
	LHL	R5,UFLAG,R1		:GET FLAGS
	THI	R5,FDDT!FKIOJ		:IS THIS A DDT JOB?
	JN	MAIN13			:SKIP IF SO
	LH	R4,WFLAG,R1		:CHECK SLEEP FLAGS
	JEFS	MAIN12			:NONE SET...CAN START IT
	THI	R4,FTIM			:IS JOB IN WAIT STATE?
	JE	MAIN31			:ELSE SKIP OVER THIS JOB
	L	R6,FASTC		:COMPARE WITH FASTC CLOCK
	CL	R6,UTIME,R1		:Is it time up?
	JL	MAIN31			:TIME NOT UP YET...SKIP THIS JOB
	NHI	R4,@FTIM		:TURN OFF TIMEOUT FLAG
	STH	R4,WFLAG,R1		:
MAIN12	HS				:
   if	DISPAT				:
	THI	R5,FDISP		:SHOULD DISPATCHER RUN NEXT?
	JE	START			:NO...JUST START HIM
	LHL	R5,SLOT,R1		:YES...PASS SLOT # TO DISPATCHER NEXT TIME
	STH	R5,DSLOT,,		:
   ei  (DISPAT)				:
	J	START			:START THIS JOB
					:
:	....................................................................
:	DDT JOB
:	....................................................................
					:
MAIN13	ST	R1,USER			:SAVE POINTER TO THIS USER
	LH	R4,UDFLAG,R1		:IS USER DISCONNECTED WITH ZAPPER WAITING?
	JGEFS	MAIN14			:NO
	AIS	R4,1			:COUNT DOWN
   if	SPAM				:
	JE	ZIN1C			:
   else					:
	JE	ZAPPER			:HIS TIME HAS EXPIRED
   ei  (SPAM)				:
	STH	R4,UDFLAG,R1		:ELSE COUNT HIM DOWN
					:
:	....................................................................
:	CHECK BUFFER PAIR FLAGS
:	....................................................................
					:
MAIN14	JAL	R15,KIOSUP		:SET UP KERNEL-I/O REGISTERS
	LHI	R7,FLOGIN!FKIOJ		:IS LOGIN IN PROGRESS, OR IS THIS NON-DDT JOB?
	NH	R7,UFLAG,R1		:
	LH	R4,NMI,R2,R2		:PTR TO FIRST CHARACTER NOT EXAMINED
					:
:	....................................................................
:	PROCESS NEWLY ARRIVED CHARACTERS
:	R1	BASE ADDRESS OF USER BLOCK
:	R2	PORT NUMBER
:	R3	INDEX TO BUFFER
:	R4	NMI FOR THIS BUFFER
:	....................................................................
					:
   IF	KIOSRC				:
	LIS	R5,3			:Pre-set fake zapper
	TBT	R2,KDZAP		:Did we get a zapper from CTL ring?
	JN	MAIN17			:Yes, just goto hang him ...
   EI  (KIOSRC)				:
MAIN15	CLH	R4,NII,R3		:HAVE WE LOOKED AT ALL CHARACTERS?
	JE	MAIN23			:SKIP IF NO MORE CHARS TO EXAMINE
	LB	R5,KIB,R3,R4		:GET NEXT CHARACTER
   IF	KIOSRC				:
	CLHI	R5,3			:If it's zapper don't bump index
	JE	MAIN17			:To allow TTYIN SVC find it in ring
   EI  (KIOSRC)				:
	AIS	R4,1			:BUMP POINTER
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R4,-KBS			:ACCOUNT FOR FOLDING
	CLHI	R5,8			:IS IT 0-7?
	JL	MAIN17			:YES
MAIN16	LR	R7,R7			:IS THIS USER NON-DDT?
	JN	MAIN15			:YES - DON'T CHECK FOR QUIT CHARS
	NHI	R5,7F			:TRASH HI BIT
	SIS	R5,3			:IS IT QUIT CHAR (CTRL-C)?
	JE	MAIN20			:YES
	SIS	R5,0F-3			:IS IT OUTPUT QUIT CHAR (CTRL-O)?
	JN	MAIN15			:NO...GO TO NEXT CHAR
					:
:	....................................................................
:	OUTPUT QUIT CHARACTER (DDT ONLY)
:	....................................................................
					:
   IF	KIOSRC				:
	LIS	R12,1			:GOBBLER CTL MSG
	JAL	R15,CTLOUT		:SEND CONTROL MESSAGE
   ELSE					:
	JAL	R15,OCHK		:PLACE GOBBLER AT THIS POSITION
	STH	R14,NOO,R3		:FLUSH OUTPUT BUFFER TO HERE
	LIS	R12,2			:THIS IS A GOBBLER
	JAL	R15,OUT1CH		:PUT GOBBLER IN OUTPUT BUFFER
	SLHLS	R2,2			:
	L	R15,KAP,R2		:GET POINTER TO USER'S ATTENTION BIT
	JEFS	.+6			:IGNORE IF NOT IN USE
	SBT	R15,0			:
	SRHLS	R2,2			:
   EI  (KIOSRC)				:
	LHL	R5,WFLAG,R1		:CLEAR OUTPUT WAIT IF ON
	NHI	R5,@FOUT		:
	STH	R5,WFLAG,R1		:
MAN16A	STH	R4,NOI,R3		:FLUSH INPUT BUFFER
	TBT	R2,KTDEM		:COPY OUR DEM FLAG TO
	JEFS	MAN16B			:*THE REAL ONE SINCE
	SBT	R2,KDEM			:*IT IS MORE UP-TO-DATE
	J	MAIN15			:
MAN16B	RBT	R2,KDEM			:
	J	MAIN15			:
					:
:	.......................................................................
:	SPECIAL NETWORK CHARACTER
:	.......................................................................
					:
MAIN17	SIS	R5,4			:IS IT A ZAPPER, GOBBLER, OR PAIR?
	JGE	MAN17A			:BR IF NOT
	AIS	R5,2			:IS IT CHAR PAIR
	JL	MAIN18			:BR IF SO
	STH	R4,NOI,R3		:ZAPPER OR GOBBLER, FLUSH BFR TO HERE
	STH	R4,NMI,R2,R2		:
	JE	MAIN15			:GOBBLER - JUST EXAMINE NEXT CHAR
	THI	R7,FLOGIN		:ZAPPER...IS USER IN LOGIN?
   if	SPAM				:
	JN	ZIN1B			:
   else					:
	JN	ZIN1			:YES, TREAT LIK ZAP SVC, NO TIMEOUT
   ei  (SPAM)				:
	LH	R6,UDFLAG,R1		:NO...CHECK IF DETACHED
   if	SPAM				:
	JG	ZIN1B			:
   else					:
	JG	ZIN1			:YES...COMPLETE ZAPPER LOGIC
   ei  (SPAM)				:
	JLFS	MAN17S			:Just skip if it's already set timeout
	LCS	R5,0A			:ALLOW THIS MANY TIME SLICES THEN FORCE LOGOUT
	STH	R5,UDFLAG,R1		:SAVE IN USER BLOCK
MAN17S	LR	R7,R7			:IS THIS DDT USER?
	JE	MAIN21			:YES...LET DDT CLEAN UP
	LHL	R5,UFLAG,R1		:IS USER LOOKING FOR ZAPPERS?
	THI	R5,FZAP
	JE	MAIN15			:NO...EXAMINE NEXT CHAR
	LH	R5,WFLAG,R1		:GET WAIT FLAG
	NHI	R5,FIN			:CANCEL ALL WAITS BUT INPUT
	STH	R5,WFLAG,R1
   if	SHARE				:
	LIS	R4,0			:
	STH	R4,DREQ,R1		:CANCEL DREQ
   ei  (SHARE)				:
	J	MAIN24			:AND PROCEED
					:
:	.......................................................................
:	DEFERRED ECHO MODE CHAR
:	.......................................................................
					:
MAN17A	JGFS	MAN17B			:BR UNLESS LDEM
	RBT	R2,KTDEM		:TURN OFF LK-AHD DEM
	J	MAIN15
MAN17B	SIS	R5,3
	JN	MAIN15			:BR UNLESS EDEM
	SBT	R2,KTDEM		:TURN ON LK-AHD DEM
	J	MAIN15
:	CHARACTER PAIR
MAIN18	LR	R6,R5			:SAVE PREFIX CODE
	LB	R5,KIB,R3,R4		:GET SECOND CHARACTER OF PAIR
	AIS	R4,1
	JLFS	.+6			:SKIP IF NOT FOLDING
	LHI	R4,-KBS			:ACCOUNT FOR FOLDING
	AIS	R6,1			:WAS FIRST CHARACTER A "1"?
	JN	MAIN16			:ESCAPE...JUST CONTINUE
	LH	R6,UDFLAG,R1		:YES...PREFIX CODE...CHECK FOR TIMEOUT
	JLE	MAIN15			:NOT IN TIMEOUT...JUST IGNOR
	STH	R4,NOI,R3		:IN TIMEOUT...FLUSH BUFFER THROUGH HERE
	STH	R4,NMI,R2,R2
	CLHI	R5,0FE			:CHECK FOR ORANGE BALL
	JN	MAIN15			:NOT YET...JUST SKIP OVER IT
 if	SPAM
	J	ZIN1B
 else
	J	ZIN1			:GOT IT...ALL OUTPUT FLUSHED...ZAP CIRCUIT
 ei	(SPAM)

:	QUIT CHAR (DDT ONLY)
MAIN20	STH	R4,NOI,R3		:FLUSH BUFFER TO HERE
	LCS	R7,1			:CODE FOR CTRL-C ENTRY
MAIN21	SIS	R7,1			:MAKE CODE -1 FOR ZAP, -2 FOR CTRL-C
	LIS	R5,0
 if	SHARE
	STH	R5,DREQ,R1		:CANCEL DREQ
 ei
	L	R6,RPSW,R1		:CHECK PSW
	THI	R6,400			:CAN'T BE DDT IF MAC BIT IS ON
	JNFS	MAIN22
	L	R6,RPSW+4,R1		:NO MAC...WAS DDT EXECUTING?
	CLI	R6,LOWDDT
	JLFS	MAIN22			:NO
	CLI	R6,HGHDDT
	JL	MAN22B			:YES...PROCEED
MAIN22	LIS	R5,0
	STH	R5,WFLAG,R1		:CLEAR ALL SLEEP CONDITIONS
	L	R12,EXTRAP,R1		:SEE IF CTRL-C TRAP RTN DEFINED
	JE	MAN22A			:BR IF NOT
	LR	R5,R12			:SAVE VIRT ADDR
	L	R13,RPSW,R1		:GET PSW
	JAL	R11,ACCESS		:CONVERT TO PHYS ADDR
	 J	MAN22A			:BR IF BAD ADDR
	LR	R6,R12			:SAVE PHYS ADDR
	LM	R12,RPSW,R1		:SAVE PSD, R0, R1
	STM	R12,0,R6
	NHI	R12,@100F		:TURN OFF STS & TRACE
	LA	R13,10,R5		:GET START ADDR
	LR	R15,R7			:GET ENTRY CODE
	STM	R12,RPSW,R1		:SET FOR BR TO TRAP RTN
	J	MAN16A

MAN22A	LIS	R5,0
	ST	R5,REST,R1		:CANCEL RESTART
	ST	R5,BGTRAP,R1		:AND TRAP RTNS
	ST	R5,FGTRAP,R1
	LM	R14,RPSW,R1		:USER'S PSW WHEN QUIT CHAR ARRIVED
	STM	R14,OLDPSW,R1		:SAVE IN DDT DATA SEG
	LHI	R14,I.ENA!20F0		:SET UP PSW FOR DDT
	LA	R15,XX,R1		:ENTER ALMOST LIKE INSTRUCTION TRAP
	STM	R14,RPSW,R1		:
MAN22B	TS	FLAG,R1			:TELL DDT QUIT CHAR ARRIVED
	J	MAN16A			:
					:
:	....................................................................
:	INPUT STREAM HAS BEEN INSPECTED
:	UPDATE THE "NEXT CHARACTER TO BE INSPECTED" POINTER
:	....................................................................
MAIN23	STH	R4,NMI,R2,R2		:SET NEW VALUE OF NMI - ALL CHARACTERS LOOKED AT
	LH	R5,UDFLAG,R1		:CHECK IF WE'RE IN DETACH STATE
	JLEFS	MAIN24			:NO...JUST PROCEED
	STH	R4,NOI,R3		:ELSE FLUSH BUFFER
					:
MAIN24	LHL	R4,WFLAG,R1		:GET CURRENT USER FLAGS
	THI	R4,FIN!FOUT!FTIM	:IS INPUT OR OUTPUT OR TIME WAIT ON
	JE	MAIN30			:NO
	THI	R4,FOUT			:IS OUT WAIT ON
	JE	MAIN26			:NO - CHECK IN WAIT
	L	R4,UOUT,R1		:
	L	R5,UOUT+4,R1		:
	LA	R8,MAIN25		:SET UP FOR CALL TO OUT SVC
	JAL	R9,OUT1			:CALL OUT SVC CODE...T6 IS INCOMPLETE ADDRESS
					:
:	....................................................................
:	FAIL RETURN
:	....................................................................
					:
	ST	R4,UOUT,R1		:OUTPUT INCOMPLETE - SAVE PTRS TO MSG
	J	MAIN30			:
					:
MAIN25	LHI	R4,@FOUT		:OUTPUT COMPLETE - CLEAR OUT WAIT
	NH	R4,WFLAG,R1		:
	STH	R4,WFLAG,R1		:
MAIN26	THI	R4,FIN			:IS IN WAIT ON
	JE	MAIN28			:NO - CHECK TIME WAIT
	LHL	R5,UIN,R1		:
	ST	R5,F1ARG		:
   IF	SPAM				:
	LIS	R7,9			:
	SBT	R7,UFLAG,R1		:Turn off special SPAM zapper trace flag
   EI  (SPAM)				:
	LA	R7,MAIN27		:SET UP FOR CALL TO IN SVC
	JAL	R8,IN1			:CALL IN SVC...T5 = SUCCESS RETURN
					:
:	....................................................................
:	SUCCESS
:	....................................................................
					:
	LIS	R5,4			:INPUT COMPLETE
	AM	R5,RPSW+4,R1		:SET UP SKIP RETURN
   IF	SPAM				:
	LIS	R7,9			:
	RBT	R7,UFLAG,R1		:Turn off special SPAM zapper trace flag
   EI  (SPAM)				:
	JFS	MAIN29			:
					:
MAIN27	EQ	.			:
   IF	SPAM				:
	LIS	R7,9			:
	RBT	R7,UFLAG,R1		:Turn off special SPAM zapper trace flag
   EI  (SPAM)				:
	LHL	R4,WFLAG,R1		:INPUT FAILURE...RESTORE USER FLAGS
					:
MAIN28	THI	R4,FTIM			:IS TIME WAIT ON?
	JEFS	MAIN30			:NO
	L	R4,FASTC		:COMPARE TO THE CURRENT TIME
	CL	R4,UTIME,R1		:TIME FOR END OF TIME WAIT
	JLFS	MAIN30			:
MAIN29	LHI	R4,@(FTIM!FIN)		:CLEAR TIME & IN WAIT FLAGS
	NH	R4,WFLAG,R1		:
	STH	R4,WFLAG,R1		:UPDATE FLAGS IN USER BLOCK
					:
MAIN30	LHL	R5,WFLAG,R1		:
	JE	MAIN32			:
MAIN31	CL	R1,ENDUSER		:ARE ALL ENTRIES ASLEEP
	JN	MAIN10			:NO - CHECK NEXT ENTRY
   IF	SPAM				:
	LIS	R4,1			:
	AM	R4,IDLCNT		:KEEP TRACT EXECUTIVE IDLE COUNTS
   EI  (SPAM)				:
	J	MAINXX			:PASS UP THIS TURN
   IF	FORGND				:
MAIN32	LH	R4,QUANTUM,R1		:ADJUST FOR THE NEXT FOREGROUND RUN
	SR	R4,R0			:REDUCE TIME REQUIRED BY TIME REMAIN
	STH	R4,QUANTUM,R1		:
	JLEFS	START			:
	AR	R0,R4			:NEEDS LESS TIME THAN AVAILABLE
   ELSE					:
MAIN32	EQ	.			:
   EI  (FORGND)				:
					:
:	....................................................................
:	START USER POINTED TO BY "UB"
:
:	NOTE: R0 CONTAINS TIME-SLICE TO GIVE THIS GUY
:	....................................................................
					:
START	HS	0			:
 if	0E-NSLOT			:
	LH	R2,SLOT,R1		:
	JL	START2			:
 ei    (0E-NSLOT)			:
 if	MULMAC				:
	L	R13,MACTRN,R1		:LOCATION OF MACBLK
	LIS	R2,1			:INCREMENT USAGE COUNT
	AHM	R2,06,R13		:ADD TO COUNT
	LB	R2,09,R13		:GET MAC SET ASSIGNED
	STH	R2,35C			:SET THAT SET ACTIVE
	JN	START1			:IF NOT ZERO THEN MAC IS SET UP
	LM	R14,MACTRN+4,R1		:VALUES FOR THE COPY INSTRUCTION
 else					:
	LM	R13,MACTRN,R1		:VALUES FOR COPY TO LOAD MAC
 ei    (MULMAC)				:
	COPY	R13,R15			:
 if	SYSMON				:
	LIS	R2,1			:
	AHM	R2,SYSTAT+6		:COUNT THIS STATISTIC
 ei    (SYSMON)				:
START1	LH	R2,SLOT,R1		:GET AND CHECK SLOT #
	CLHI	R2,NSLOT		:
	JLEFS	.+6			:
	LHI	R2,NSLOT+1		:ALL OTHERS GET EXCESS DEFAULT
START2	SLLS	R2,2			:COMPUTE INDEX
START3	STH	R2,LOCLKX		:SET LOCAL-CLOCK INDEX
	ST	R1,USER			:SET CURRENT USER
 if	SYSMON				:
	LIS	R2,1
	AHM	R2,SYSTAT+4		:COUNT THIS STATISTIC
 ei	:SYSMON
	LH	R2,XWAKE,R1		:CHECK FOR SPECIAL WAKE-UP USAGE
	JEFS	START4			:NOT IN USE
	LIS	R2,0			:COMPUTE TIME REMAINING
	SH	R2,WAKE,R1
	CR	R0,R2			:COMPARE TIME TO GIVE HIM WITH TIME TO WAKE-UP
	JGEFS	.+4			:HAVE LESS TIME TO SPEND
	LR	R0,R2			:MORE...USE MINIMUM
	AHM	R0,WAKE,R1		:REDUCE REMAINING TIME REQUIRED
START4	EQ	.			:
	STH	R0,SLICE		:SET TIMEOUT
 if	SPAM				:3/87
	L	R3,SLOWC		:GET CURRENT TIME
    if .GT.(NSLOT,$A32)			:
	CL	R3,ADVCLK,,		:GET EXPIRATION TIME (1 MINUUTE)
	JN	NOTIM			:NOT YET
	L	R3,SLOWC		:GET SLOWC NOW
	ST	R3,SLOSAV,,		:SAVE IT FOR SPAM
	LH	R3,SPRDY,,		:IF SYSTEM IN INITIALIZE STATE
	JE	NOTIM			:DON'T MOVE TO OUTPUT BUFFER
    else				:
	CL	R3,ADVCLK		:GET EXPIRATION TIME (1 MINUUTE)
	JN	NOTIM			:NOT YET
	L	R3,SLOWC		:GET SLOWC NOW
	ST	R3,SLOSAV		:SAVE IT FOR SPAM
	LH	R3,SPRDY		:IF SYSTEM IN INITIALIZE STATE
	JE	NOTIM			:DON'T MOVE TO OUTPUT BUFFER
    ei (  )				:
	LHI	R2,CNTEND		:INDEX TO LAST WORD OF TABLE
MOVDTA	L	R3,SPMTBL,R2		:PICK UP RUNNING TABLE DATA
	ST	R3,TIMTBL,R2		:SAVE IT IN DISPLAY BUFFER
	SIS	R2,4			:DECREMENT WORDS
	JGEBS	MOVDTA

	JAL	R4,RESCNT		:GO RESET COUNTERS
NOTIM	EQ	.
	LHL	R4,SLOT,R1		:GET CURRENT SLOT
	LHL	R3,UFLAG,R1		:GET CURRENT USER FLAG
	STH	R3,CURENT+2		:SAVE 'UFLAG'
	THI	R3,80			:DISPATCHER JOB?
	JEFS	NODSP			:IF NOT, SKIP
	LHL	R4,DSLOT		:GET DISPATCHER SLOT FROM SCHEDULER
	STH	R4,ENDATA		:SAVE IT FOR 'END' DATA
NODSP	STH	R4,CURENT		:SAVE SLOT
	LHL	R3,FASTC+2		:GET TIME NOW
	STH	R3,CURENT+4		:SAVE IT
 if	SPMTRC
	LHL	R3,CURENT+6		:GET JOB SEQUENCE NUMBER
	AIS	R3,1			:BUMP IT
	NHI	R3,0FFFF		:MASK FOR FASTC ROLLOVER
	STH	R3,CURENT+6		:SAVE IT
 ei	(SPMTRC)
	LIS	R4,1
	AM	R4,BEGCNT		:BUMP JOB START COUNTER
 ei	(SPAM)
 if	SPMTRC
	LHL	R3,TRCON,,		:TEST TRACE FLAG
	JN	NOWRP			:IF NON-ZERO, ERROR, EXIT
	LHL	R3,POITER		:GET TRACE TABLE POINTER
	L	R4,CURENT		:GET SLOT AND UFLAG
	ST	R4,TRCTBL,R3		:SAVE TRACE DATA
	L	R4,CURENT+4		:GET REST OF TRACE DATA
	ST	R4,TRCTBL+4,R3		:SAVE IT
	AHI	R3,$A 16		:BUMP TRACE POINTER
	NHI	R3,0FFF			:'AND' R3 WITH 1000-1
	STH	R3,POITER		:STORE IT
 ei	(SPMTRC)
NOWRP	EQ	.
	LHI	R0,FNOREG
	NH	R0,UFLAG,R1		:TEST TO SEE IF REGS SHOULD BE RESTORED
 if	SYSMON
	JNFS	START5
	LIS	R0,1
	AHM	R0,SYSTAT+8		:COUNT THIS STATISTIC
	J	USTRT,R1
START5	HS	0			:
 else					:
	JE	USTRT,R1		:RESTORE USER REGISTERS
 ei    (SYSMON)				:
	XH	R0,UFLAG,R1		:NO...TURN OFF BIT
	STH	R0,UFLAG,R1		:
	LPSW	RPSW,R1			:
					:
:	....................................................................
:
:	ROUTINE INDICATORS:
:	1 = KERNEL SVC FAST DISMISS (F.GUP)
:	2 = KERNEL SVC DISMISS (S.GUP)
:	4 = SLOT TIMEOUT (UDMISS)
:	5 = RETURN TO USER CODE FROM SYSTEM SVC'S (KRET2)
:	6 = RETURN FROM TTY INPUT SVC (TTYIN)
:	7 = RETURN FROM TTY OUTPUT SVC - TTYOUT (OUT0A)
:	8 = RETURN FROM TRAPPABLE MALFUNCTION ILLEGAL INSTRUCTION (ILLIN2)
:	9 = RETURN FROM ZAP SVC (ZIN1A)
:       A = RETURN FROM ZAP SVC (ZIN1) IF 'FSYS' ENABLED'
:       B = RETURN FROM RESTART SVC (RESTA9)
:       C = RETURN FROM XFER SVC (FER10)
:       D = RETURN FROM TRAPPABLE MALFUNCTIONS SVC'S NOT IMPLEMENTED (NOTI)
:       E = RETURN FROM MAC SET FAIL (MINT02)
:       F = RETURN FROM DDT PROTECTION VIOLATION (MINT03)
:      10 = RETURN FROM MACHINE MALFUNCTION INTERRUPT (MACHM3)
:      11 = XPI (KDICRA) MXP KDIO SLOT CRASH REQUEST
:      13 = RETURN FROM SYS. SVC (ONDBG) TURN ON DEBUG MODE
:      14 = RETURN FROM SYS. SVC (FRZIT) TURN OF FREEZE
:      15 = RETURN FROM "RESUME" COMMAND (RESM1)
:      16 = RETURN FROM SYS. SVC 32 (HALT01) HALT OWN SLOT
:      17 = RETURN FROM SYS. SVC 45 (DSISN2) GET INFO FROM DISPATCHER
:      18 = RETURN FROM PARAMETER FAILURE (OUT0B) TTYOUT
:      19 = RETURN FROM DISK RTN.  (EDPB5)
:      20 = KILL DDT PROCESS (MKRTRP)
:      21 = FLUSH OUTPUT BUFFER (GOBBLE)
:      22 = KERNEL SVC DISMISS (T.GUP)
:
:	ON ENTRY:
:	R7  = USER'S 'UFLAG'
:	R9  = LINK
:	R10 = ROUTINE INDICATOR
:	R11 = SLOT NUMBER
:
:	....................................................................
					:
 if	SPAM				:
	GL	ENDATA,ENDCNT,CURENT,CHKPT
					:
:	....................................................................
:	THIS SECTION CHECKS THE JOB TYPE, AND RECORDS DATA AT JOB
:	TERMINATION.  THIS DATA WILL BE OPERATED ON IN THE TIMING
:	SECTION.   IF SPAM FLAG (CHKPT) IS SET DURING A SCHEDULER
:	PASS, AN ERROR HAS OCCURRED IN SPAM.
:	....................................................................
					:
ENTIM	EQ	.			:
  if	SPMTRC				:
	STH	R10,ENDATA+6		:SAVE ROUTINE INDICATOR
  ei   (SPMTRC)				:
	LHL	R10,UFLAG,R1		:RECORD SLOT NUMBER
	STH	R10,ENDATA+2		:SAVE USER FLAG
	THI	R10,80			:DISPATCHER JOB?
	JNFS	DISJOB			:IF SO, SLOT SAVED AT JOB START TIME
	LHL	R10,SLOT,R1		:
	STH	R10,ENDATA		:SAVE SLOT
DISJOB	LHL	R10,FASTC+2		:GET TIME NOW (CURRENT JOB END TIME)
	STH	R10,ENDATA+4		:SAVE IT
	LIS	R10,1			:
	AM	R10,ENDCNT		:BUMP END COUNTS
					:
CALCTM	EQ	.			:
  if	SPMTRC				:
	GL	TRCTBL,ENDEX,TRCON
					:
:	....................................................................
:	THIS SECTION IS ASSEMBLED IF 'SPMTRC' IS EQUATED TO '1' IN THE
:	TYMFILE.  IT PROVIDES A MEANS FOR CHECKING ERROR CONDITIONS BY
:	EXAMINING THE TRACE TABLE (TRCTBL).  THE TRACE FLAG (TRCON) IS
:	SET WHEN AN ERROR IS ENCOUNTERED, AND TRACE IS DISABLED.
:
:	WHEN TRCON = 1 - MISCOMPARE ON JOB TYPE (UFLAG)
:		     2 - MISCOMPARE ON USER SLOT NUMBER
:		     3 - BOTH OF ABOVE ERRORS
:
:       R6  = WORK REGISTER
:       R7  = USER FLAG "UFLAG"
:       R5  = WORK REGISTER
:       R9  = LINK
:       R10 = FASTC+2 "ENDATA+4"
:       R11 = SLOT NUMBER "ENDATA"
:	....................................................................
					:
	LHL	R6,TRCON		:TEST THE TRACE FLAG
	JN	ENDTIM			:IF NON-ZERO, EXIT
	LHL	R6,ENDEX		:GET END TABLE POINTER
	L	R5,ENDATA		:*UPDATE TRACE TABLE*
	ST	R5,TRCTBL+8,R6		:SAVE "ENDATA" SLOT NUMBER
	L	R5,ENDATA+4		:
	ST	R5,TRCTBL+0C,R6 	:SAVE "ENDATA+4" CURRENT JOB END TIME
	LHI	R5,0F080		:ISOLATE FIRST AND THIRD DIGITS
	NH	R5,ENDATA+2		:STRIP BITS FROM USER FLAG
	NH	R5,CURENT+2		:TEST FOR USERFLAG MATCH
	JNFS	FLGOK			:IF NON-ZERO, OK, SKIP
	LIS	R5,1			:
	STH	R5,TRCON		:TURN OFF TRACE
FLGOK	AHI	R6,$A 16		:BUMP POINTER
	NHI	R6,0FFF			:TABLE LIMITER
	STH	R6,ENDEX		:SAVE INDEX TO TRACE TABLE
	JNFS	NOSTOP			:IF NOT AT END OF TRACE TABLE
	LH	R5,STPTRC		:TRACE STOP REQUESTED?
	JE	NOSTOP			:
	LIS	R5,9			:STOP TRACE MANUALLYY
	STH	R5,TRCON		:
NOSTOP	EQ	.			:
  ei   (SPMTRC)				:
					:
:	.......................................................................
:	THIS SECTION ACCUMULATES THE TIME USED BY ALL SLOTS FOR ALL JOBS.
:
:       R6  = WORK REGISTER
:       R7  = USER FLAG 'ENDATA+2'
:       R5  = WORK REGISTER
:       R9  = LINK
:       R10 = CURRENT JOB END TIME 'ENDATA+4'
:       R11 = SLOT NUMBER 'ENDATA'
:	.......................................................................
					:
ENDTIM	EQ	.			:
	LH	R10,ENDATA+4		:GET JOB END TIME
	LH	R11,ENDATA		:GET SLOT NUMBER
	CLH	R11,CURENT		:GET 'START' SLOT
	JE	ENDOK			:YES
	LHL	R7,SPRDY		:IS SPAM READY?
	JE	ENDOK			:NO, DON'T BOTHER
	LIS	R7,2			:
	STH	R7,CHKPT		:FLAG CHECKPOINT ROUTINE
  if	SPMTRC				:
	STH	R7,TRCON		:
  ei   (SPMTRC)				:
ENDOK	LHL	R7,ENDATA+2		:GET USER FLAG
	THI	R7,80			:TEST UFLAG FOR DISPATCHER JOB
	JEFS	NOTDIS			:IF ZERO, NON-DISPATCHER JOB
	AHI	R7,1000			:ADJUST FLAG FOR 'SPMTBL' INDEX (5000)
NOTDIS	NHI	R7,0F000		:TOSS UNNEEDED BITS
	SRLS	R7,0A			:SHIFT RIGHT FOR LATERAL INDEX
	AIS	R11,1			:INCREMENT VERTICAL INDEX
	SLLS	R11,5			:SHIFT LEFT TO ADJUST
	AR	R11,R7			:CONSOLIDATE INDEX TO 'SPMTBL'
	LIS	R5,1			:
	AM	R5,SLTCNT-4,R11		:INCREMENT APPROPRIATE JOB COUNTER
	LH	R5,CURENT+4		:GET CURRENT JOB START TIME
	SR	R10,R5			:GET THE DIFFERENCE IN TICKS
	NI	R10,0000FFFF		:MASK FOR ROLLOVER OF FASTC+2
	JE	ZRODIF			:IF DELTA TIME = 0, SAVE VECTOR
	CH	R5,SAVEND		:CURRENT START TIME = PREV. END TIME?
	JE	ZRODIF			:IF EQUAL, SAVE VECTOR
FULTIK	LHI	R5,$A 1000		:LOAD R4 = 1000 DEC. (1 TICK= 3E8 HEX)
	MHR	R10,R5			:MULTIPLY TICKS X 1000 DEC.
	AM	R10,SPMTBL-4,R11	:BUMP APPROPRIATE SLOT TIME TABLE
CHKTIM	LHL	R5,SAVEND		:GET PREVIOUS END TIME
	LHL	R10,ENDATA+4		:RETRIEVE CURRENT JOB END TIME
	CR	R5,R10			:PREVIOUS END TIME=TO CURRENT END TIME?
	JE	TIMXIT			:IF EQUAL, EXIT
	LHL	R6,PASCTR		:GET PASS COUNTER
	JE	TIMXIT			:IF ZERO, NO FRACTIONAL TIME TO ADD
	LHL	R5,TICTIM,R6		:GET FRACTIONAL TICK VALUE
NXTIM	LHL	R7,VECTBL,R6		:GET VECTORS TO (SPMTBL) TIME TABLE
	AM	R5,SPMTBL-4,R7		:BUMP SLOT TIME BY FRACTIONAL AMOUNT
	SIS	R6,2			:DECREMENT PASS COUNTER
	JNBS	NXTIM			:IF ZERO, ALL FRACTIONAL TICKS ADDED
	STH	R6,PASCTR		:RESTORE PASS COUNTER
	J	TIMXIT			:EXIT
ZRODIF	LHL	R6,PASCTR		:GET FRACTIONAL PASS COUNTER
	AIS	R6,2			:BUMP IT
	NHI	R6,3F			:RESET TO ZERO AT HEX. '03F'
	STH	R6,PASCTR		:SAVE IT
	STH	R11,VECTBL,R6		:SAVE SLOT VECTOR TO TIME TABLE
	CHI	R10,1			:TIME DIFF 1 OR LESS?
	JLE	CHKTIM			:YES, GO CHECK TRIGGER
	SIS	R10,1			:IF > 1, ADJUST FOR PARTIAL TICK
	J	FULTIK			:ADD REMAINING FULL TICKS
TIMXIT	STH	R10,SAVEND		:CURRENT END TIME TO PREVIOUS END
EXTIM	JR	R9			:TIME
					:
:	....................................................................
TICTIM	HC	0,$A 500,$A 333,$A 250,$A 200,$A 167,$A 143,$A 125,$A 111,
	HC	$A 100,$A 091,$A 083,$A 077,$A 071,$A 067,$A 063,$A 059,
	HC	$A 056,$A 053,$A 050,$A 48,$A 45,$A 43,$A 42,$A 40,$A 38,
	HC	$A 37,$A 36,$A 34,$A 33,$A 32,$A 31
VECTBL	HS	$A 32
:	....................................................................
					:
 ei    (SPAM)				:
					:
:
	SUBTTL	EXAMINE KERNEL PORTS FOR NEW LOGINS OR PORTS TO BE ZAPPED

					:
:	....................................................................
:
:	EXKP - Examine ISIS kernel ports for new logins and ports need to
:	       be zapped. It also determine if any new kernel ports exist.
:
:	NOTE: CALLED FROM FLASHER, OPERANDS REFERENCED BY SLOT 0 AND KERNEL
:
:	R10 - Link register
:	CALLED BY 1 SECOND LOGIC IN FLASHER. NOTE THAT THIS SUBROUTINE CAN
:	NOT BE INTERRUPTED WHEN FLASHER TIMESLICE IS EXHAUSTED SINCE IT IS
:	PART OF KERNEL CODE.
:
:	....................................................................
					:
EXKP	LHI	R8,NKU&0FFF0		:INDEX OF LAST GROUP
	LHI	R9,(NKU/10)*2		:INDEX OF LAST HALFWORD IN BIT ARRAY
					:
EXKP1	LHL	R4,NEWLOG,R9		:ARE ANY NEW LOGONS PENDING?
	JFFOH	R4,.+6			:SKIP IF THERE IS ANY BIT SET
	J	EXKP4			:ELSE AVOID IT
	TS	DUMMY			:SEE IF SPACE FOR ANOTHER LOGIN
	JN	EXKP4			:NO SPACE AVAILABLE - LET ALL WAIT
    if .GT.(NSLOT,$A32)			:
	LA	R1,LOGBX,,		:SET IT UP
    else				:
	LA	R1,LOGBX		:SET IT UP
    ei (  )				:
	LIS	R6,0			:
	STH	R6,UDFLAG,R1		:INITIALIZE TIMEOUT COUNTER
	STH	R6,WFLAG,R1		:Initialize wait flag
	LM	R14,INIPSW,R1		:PSW FOR LOGIN CODE
	STM	R14,RPSW,R1		:
	AR	R5,R8			:COMPUTE ACTUAL PORT #
	RBT	R5,NEWLOG		:CLEAR THIS BIT IN NEWLOG
	STH	R5,BUFNO,R1		:CONNECT LOGON USER BLOCK TO THIS BUFFER NUMBER
	SLHLS	R5,2			:MAKE WORD INDEX
	ST	R1,KDESTZ,R5		:SET LOGGER AS DESTINATION
	LHI	R4,FLOGIN!FKIOJ		:SET LOGIN, KERNAL I/O FLAG IN R1
	STH	R4,UFLAG,R1		:
	L	R4,RUN			:PUT AT HEAD OF RUN QUEUE
	ST	R4,LLINK,R1		:
	ST	R1,RUN			:INITIALIZE RUN QUEUE
	JNFS	EXKP4			:SKIP IF RUN QUEUE WAS NOT EMPTY
	ST	R1,RUSER		:ELSE MAKE THIS JOB THE CURRENT RUN-LIST USER
	JR	R10			:AND RETURN
EXKP4	SHI	R8,10			:REDUCE TO NEXT LOWER GROUP
	SIS	R9,2			:
	JGE	EXKP1			:REPEAT FOR AS MANY GROUPS AS NECESSARY
	JR	R10			:RETURN TO CALLER
					:
	SUBTTL	TRAPPABLE MALFUNCTIONS

:	HOW TO GET A JOB IN TROUBLE
:
:	NOT IMPLEMENTED SVC'S
					:
NOTI	JAL	R11,FNDDDT		:GET DDT USER BLOCK
	L	R0,RPSW+4,R1		:SAVE USER PC
	ST	R0,MACLOC,R4		:
	KRCODE(0,1,5)			:SET UP DDT CRASH REASON, ILL. SVC CODE
	JAL	R11,KRASH		:
 if	SPAM				:
  if	SPMTRC				:
	LIS	R10,0D			:SPAM TRACE ROUTINE ID
  ei   (SPMTRC)				:
	JAL	R9,ENTIM		:COLLECT 'END' USER DATA
 ei    (SPAM)				:
	LPSW	MAINPSD			:EXIT BACK TO MAIN LOOP
					:
:	....................................................................
:	HANDLE INTERRUPT FROM MAC HERE
:	....................................................................
					:
 if	MULMAC
MSRMSG	SC	/Restarted, Bad MAC Set # 0/
	SC	/Restarted, Bad MAC Set # 1/
	SC	/Restarted, Bad MAC Set # 2/
	SC	/Restarted, Bad MAC Set # 3/
	SC	/Restarted, Bad MAC Set # 4/
	SC	/Restarted, Bad MAC Set # 5/
	SC	/Restarted, Bad MAC Set # 6/
	SC	/Restarted, Bad MAC Set # 7/
	SC	/Restarted, Bad MAC Set # 8/
	SC	/Restarted, Bad MAC Set # 9/
	SC	/Restarted, Bad MAC Set # A/
	SC	/Restarted, Bad MAC Set # B/
	SC	/Restarted, Bad MAC Set # C/
	SC	/Restarted, Bad MAC Set # D/
	SC	/Restarted, Bad MAC Set # E/
	SC	/Restarted, Bad MAC Set # F/
	HC	0			:	
 ei    (MULMAC)				:
					:
:	....................................................................
:	The following code is entered upon a MAC violation where upon entry,
:	Register Set 7 (seven) is the new register set.   This allows us to
:	maintain the integrity of register set 0 (Zero).  At this initial
:	interrup, register set '0' (zero) and 'F' are saved along with MAC
:	registers 340 thru 350 so that at least one copy of the interrupt 
:	data is maintained regardless of whether the interrupt is kernel or
:	slot related.
:	....................................................................
					:
MINT	L	R13,FASTC		:Get  the current FASTC
	ST	R13,INTIME		:Save the current FASTC upon interrupt
	LHI	R13,90			:Indicate MAC interrupt type/location
	STM	R13,INTTYP		:Save MAC interrupt type and PSD
					:
	LM	R0,300			:Fetch MAC relocation registers
	STM	R0,MAC300		:Save  MAC relocation registers
					:
	LM	R12,344			:For TSI MAC-II gate-array
	L	R11,340			:location 340 must be read last.
	STM	R11,MAC340		:Save them...
					:
	LPSW	.+4			:
	HC	0,0F0,0,MINTSF		:Switch from register set "7" to "F"
MINTSF	STM	R0,MRGSVF		:Save register set "F"
					:
	LPSW	.+4			:
	HC	0,0,0,MINTS0		:Switch from register set "F" to "0"
MINTS0	STM	R0,MRGSV0		:Save register set "0"
	LM	R14,INTTYP+4		:Copy interrupt PSD to reg. E & F set 0
					:for subsequent crash processing
					:
   IF	MACTRC				:IF MAC TRACE SPECIFIED
					:
:	.......................................................................
:       SAVE MAC REGISTERS AND THEN TEST FOR TRACE INTERRUPT
:       THIS ALLOWS US TO PRESERVE ALL REGISTERS AT TIME OF INTERRUPT
:       PREVENTING THE INTERRUPT ROUTINE ITSELF FROM ALTERING THEM
:	.......................................................................
					:
        L       R15,MAC340              :RETRIEVE MAC INTERRUPT REGISTER
        THI     R15,40                  :TEST FOR MAC TRACE INTERRUPT
        JN      MINTA                   :IF TRACE, GO DO IT
        L       R15,MRGSV0              :RESTORE REGESTER 15
        J       MINTB                   :PROCESS NORMAL MAC INTERRUPT
					:
:	.......................................................................
:       TRACE LOGIC IF MAC INTERRUPT DETECTED WITH TRACE BIT ON
:	.......................................................................
					:
MINTA   L       R15,MRGSV0              :RESTORE R15
        STM     R0,TRACE2               :SAVE CURRENT REGISTER SET 0
        LHL     R15,TRACE3+2            :GET USER REGISTER SET
        NHI     R15,00F0                :PICK OUT REGISTER SET
        STH     R15,TRCSET              :SAVE IT FOR DISPLAY
        EPSR    R14,R15			:
        STM     R0,TRACE1               :SAVE USER REGISTER SET
        LPSW    TRCRTN                  :RESTORE REG SET 0 WITHOUT SCREWING
MINTPS  EQ      .                       :UP USER REGISTER SET
        LHI     R14,-80                 :TRACE BUFFER RANGE
MINTAA  L       R15,400,R14             :SAVE TRAP LOCATION FROM TRACE BUFFER
        NI      R15,0FFFFF              :STRIP OFF UNUSED BITS
        ST      R15,TRPLOC+80,R14
        AIS     R14,4
        JLBS    MINTAA
        LIS     R14,1                   :COUNT EACH TRACE INTERRUPT TAKEN
        AM      R14,COUNT
        L       R15,TRPLOC              :GET TRAPPED ADDRESS BACK
        LHL     R13,0,R15               :FETCH CONTENT OF TRAPPED LOCATION
        STH     R13,TRPDTA              :SAVE TRACE ADDRESS CONTENT
        LHL     R14,TERMCD              :SET TERMINATION CODE INDEX
        LHL     R15,DATACD              :SET DATA COMPARE CODE INDEX
        CLH     R13,PATERN              :SET UP BRANCH CONDITION
        J       TREXIT,R14,R15          :JUMP TO APPROPRIATE ROUTINE
					:
                           		:R14 TEMINATION CONTROL CODE VALUES
                                	:0 = LEAVE TRACE OFF AFTER SYNC
                                	:4 = TURN TRACE BACK ON AFTER SYNC
                                	:8 = JUMP TO BOOT LOADER AFTER SYNC
                           		:R15 DATA COMPARE CONTROL CODE VALUES
                                	:00 = NO TEST FOR DATA VALUE
                                	:0C = TEST FOR DATA VALUE EQUAL 
                                	:18 = TEST FOR DATA VALUE NOT EQUAL
TREXIT  EQ      .			:
        J       TURNOF          	:0  = NO DATA TEST, LEAVE TRACE OFF
        J       TURNON          	:4  = NO DATA TEST, TURN TRACE BACK ON
        J       5A              	:8  = NO DATA TEST, JUMP TO BOOT LOADER
        J       CEQOFF          	:0C = IF DATA EQUAL, LEAVE TRACE OFF
        J       CEQON           	:10 = IF DATA EQUAL, TURN TRACE BACK ON
        J       CEQBT           	:14 = IF DATA EQUAL, JUMP TO BOOT LOADER
        J       CNEQOF          	:18 = IF DATA NOT EQUAL, LEAVE TRACE OFF
        J       CNEQON          	:1C = IF DATA NOT EQUAL, TURN TRACE BACK ON
        J       CNEQBT          	:20 = IF DATA NOT EQUAL, JUMP TO BOOT LOADER
					:
CEQOFF  JE      TURNOF          	:LEAVE TRACE OFF IF DATA PATTERN EQUAL
        J       TURNON          	:ELSE TURN TRACE BACK ON
					:
CEQON   JE      TURNON          	:TURN TRACE BACK ON IF DATA PATTERN EQUAL
        J       TURNOF          	:ELSE LEAVE TRACE OFF
					:
CEQBT   JE      5A              	:PUT MACHINE IN BOOT IF DATA PATTERN EQUAL
        J       TURNON          	:ELSE TURN TRACE BACK ON
					:
CNEQOF  JN      TURNOF          	:TURN TRACE OFF IF DATA PATTERN  NOT EQUAL
        J       TURNON          	:ELSE TURN TRACE BACK ON
					:
CNEQON  JN      TURNON          	:TURN TRACE BACK ON IF DATA PATTERN  NOT EQUAL
        J       TURNOF          	:ELSE LEAVE TRACE OFF
					:
CNEQBT  JN      5A              	:PUT MACHINE IN BOOT IF DATA PATTERN NOT EQUAL
        J       TURNON          	:ELSE TURN TRACE BACK ON
					:
TURNON  LHL     R14,TRONOF              :CHECK IF TRACE REQUESTED OFF
        JE      TURNOF			:
        L       R14,MAC34C              :GET PROGRAM LOGICAL ADDRESS
        NI      R14,0FFFFF              :STRIP EXTRANEOUS MAC BITS
        CL      R14,TRACE3+4            :COMPARE TO PROGRAM RETURN ADDRESS
        JN      TRNON1                  :IF NOT EQUAL, TURN BACK ON
        LCS     R14,1                   :FLAG DISPLAY FOR ILLEGAL CONDITION
        STH     R14,ILLTRC		:
        JFS     TURNOF			:
TRNON1  LHL     R14,TRACMD              :FETCH TRACE COMMAND BITS
        STH     R14,350                 :RESTART MAC TRACE
        LCS     R14,1			:
        STH     R14,TRONOF              :TELL DDT TRACE IS STILL RUNNING
        JFS     TRCRET                  :EXIT
TURNOF  LIS     R14,0                   :DO NOT RESTART TRACE
        STH     R14,350                 :INSURANCE-NO TRACE BITS ON
        STH     R14,TRONOF              :TELL DDT TRACE HAS BEEN STOPPED
TRCRET  LM      R13,TRACE3-4            :RESTORE ORIGINAL REGISTER SET 0
        LPSW    TRACE3                  :RESTORE ORIGINAL PSD AND RETURN
TRCRTN  WC      0,MINTPS                :USED TO PRESERVE USER REGISTER SET
   EI  (MACTRC)				:
MINTB   EQ      .                       :ENTRY FOR NON TRACE MAC INTERRUPT
        L	R1,USER			:*0*Get the user block pointer
	LM	0E,INTPSD		:*0*Reload the old PSD and PC
	STM	0E,RPSW,1		:*0*Save PSD and PC into user block
	LHI	2,0F0			:*0*NO MACH MALF BECAUSE OF MAC STATUS REG
	EPSR	3,2			:*F*SET REG SET F
	ST	R1,KSAVE		:*F*SAVE USER REGISTER
	L	R1,USER			:*F*POINT TO USER BLOCK
	STM	R0,RREG,R1		:*F*SAVE USER REGISTERS
	L	R0,KSAVE		:*F*SAVED USER REG
	ST	R0,RREG+4,R1		:*F*CORRECT USER BLOCK
	L	R4,MAC34C		:*F*GET LOCATION OF LAST INSTR FETCH
	NI	R4,3FFFFF		:*F*MASK OFF UNUSED(NEW MAC)
	L	R0,MAC340		:*F*READ MAC STATUS REG
   if	TSIMAC				:
	J	MINT0			:*F*NO DMA TIMEOUT FOR TSI
   ei  (TSIMAC)				:
   if	ZITEL!MACV			:
	THI	R0,180			:*F*CHECK FOR ANY TIMEOUTS
   else					:
	THI	R0,80			:*F*CHECK FOR DMA DEVICE TIMEOUT
   ei  (ZITEL!MACV)			:
					:
	JE	MINT00			:*F*
	LM	0E,RPSW,R1		:GET PSW
	STM	0E,MPSD			:
	S.HLTI(0452,MPSD)		:
					:
MINT00	HS	0			:
   if	ZITEL!MACV			:
	lo	flash
	THI	R0,1F			:*F*CHECK FOR MEMORY RANGE ERROR
	JN	MINT0			:Blame the slot for the problem
	LHL	R2,UFLAG,R1		:Get user flag
	THI	R2,FDDT			:Is it a DDT job?
	JN	MINT0			:Skip if it is a DDT job ...
	LM	0E,RPSW,R1		:Blame all else for the problem
	STM	0E,MPSD			:Get and Save PSW
	lcs	r4,1			:slot key
	la	r5,msg453
	jal	r11,setdiag
	lh	r7,m453x		: check flag
	jefs	m453z			: first time
	l	r11,slowc
	s	r11,m453x+2
	cli	r11,$a 604800		: 7 days
	jlfs	m453y			: second crash within delta
m453z	lis	r11,1			: set flag
	sth	r11,m453x
	l	r11,slowc
	st	r11,m453x+2		: save slowc
	j	70,,			: restart
m453y	S.HLTI(0453,MPSD)		: crash
m453x	hc	0			:count
	wc	0			:slowc
msg453	sc	/range error in kernel/					:
	fo	flash
   ei  (ZITEL!MACV)			:
MINT0	NHI	R0,0FFFF		:*F*ONLY 16 MEANINGFULL BITS
	LIS	R2,0			:*F*
	ST	R2,MACSTAT		:*F*THIS CLEARS MAC INTERRUPT
	LHI	R14,I.ENA!20F0		:*F*
	EPSR	R15,R14			:*F*ENABLE MACH MALF, INTERRUPTS
	LR	R3,R1			:COPY USER-BLOCK BASE
	LHL	R2,UFLAG,R1		:CHECK FLAGS
	THI	R2,FDDT			:
	JNFS	MINT1			:SKIP IF DDT
	L	R3,CONTROL,R1		:ELSE GET CONTROLLING DDT
MINT1	STH	R0,CC,R3		:TELL DDT REASON FOR MAC INTERRUPT
	L	R4,RPSW+4,R1		:
	ST	R4,MACLOC,R3		:AND SAVE INTERRUPT LOCATION
					:
  if	MULMAC				:
:	.......................................................................
:	TRAPS MAC INTERRUPT AND VERIFIES MAC SET.  THIS ALLOWS A GRACEFUL
:	FAILURE OF A MAC SET IN THE HARDWARE.  IF A MAC REGISTER SET
:	BAD, THE SET IS TAKEN OUT OF SERVICE AND THE SLOT IS CRASHED AND
:	RESTARTED (AS IF IT WERE A MANUAL RESTART).  A MESSAGE IS SENT TO THE
:	HISTORY BUFFER AND TO THE SUPERVISOR LOG.  IF MAC SET 0 FAILS, THE
:	MACHINE IS CRASHED, BAD04 8751.
:	.......................................................................
					:
	L	R2,MACTRN,R1		:GET LOCATION OF CURRENT MAC SET
	LHI	R5,-(10*4)		:SET UP INDEX
MINT01	L	R3,2,R2,R5		:GET MAC SET
   if	ZITEL				:
	NI	R3,3FFFFFF0		:STRIP OFF UNUSED OR UNEQUAL BITS
   ei  (ZITEL)				:
   if	MACV				:
	NI	R3,0FFFFFF0		:
   ei  (MACV)				:
	L	R6,MACAREA+10*4,R5	:GET HARDWARE MAC SET
   if	ZITEL				:
	NI	R6,3FFFFFF0		:
   ei  (ZITEL)				:
   if	MACV				:
	NI	R6,0FFFFFF0		:
   ei  (MACV)				:
	CR	R3,R6			:COMPARE SOFTWARE AND HARDWARE MAC SET
	JNFS	MINT02			:IF BAD, TAKE ENTIRE SET OUT OF SERVICE
	AIS	R5,4			:ELSE CHECK NEXT REG
	JL	MINT01			:TIL DONE
	J	MINT03			:MAC REGS ARE GOOD, CONTINUE TO KRASH
					:
MINT02	LHI	R5,-(10*4)		:COUNT FOR MAC SET VERIFY FAILURE
MINT05	L	R3,2,R2,R5		:GET MAC SET
   IF	ZITEL				:
	NI	R3,3FFFFFF0		:STRIP OFF UNUSED OR UNEQUAL BITS
   EI  (ZITEL)				:
   IF	MACV				:
	NI	R3,0FFFFFF0		:STRIP OFF UNUSED OR UNEQUAL BITS
   EI  (MACV)				:
	ST	R3,MSETSF+10*4,R5	:STORE SOFT MAC SET
	L	R6,MACAREA+10*4,R5	:GET HARDWARE MAC SET
   IF	ZITEL				:
	NI	R6,3FFFFFF0		:STRIP OFF UNUSED OR UNEQUAL BITS
   EI  (ZITEL)				:
   IF	MACV				:
	NI	R6,0FFFFFF0		:STRIP OFF UNUSED OR UNEQUAL BITS
   EI  (MACV)				:
	ST	R6,MSETHD+10*4,R5	:STORE HARD MAC SET
	AIS	R5,4			:
	JL	MINT05			:
	LB	R3,09,R2		:GET MAC SET NUMBER
	JE	MINT04			:SET 0 BAD, CRASH MACHINE
	RBT	R3,BDMSET		:TAKE MAC SET OUT OF SERVICE
	LR	R12,R3			:SAVE MAC SET NUMB FOR NODE REPORT HW 2 LOW
	LIS	R5,0
	STH	R5,09,R2		:ASSIGN USER MAC TO SET 0
	LH	R4,SLOT,R1		:GET SLOT NUMBER
	LB	R5,MSRMSG		:GET LENGTH OF MESSAGE
	AIS	R5,1			:INCLUDE LENGTH BYTE IN LENGTH
	MHR	R3,R5			:MULT BY MAC SET NUMB, TO POINT TO MSG
	LA	R5,MSRMSG,R3		:GET ADDRESS OF MESSAGE
	JAL	R11,SETDIAG		:PUT MESSAGE INTO HISTORY BUFFER
					:
:	.......................................................................
:	PUT MESSAGE INTO SUP LOG
:	.......................................................................
					:
	LHL	R13,BDMSET		:GET BAD MAC SET ARRAY HW 4
	LIS	R11,2			:GET MESSAGE TYPE HW 3 (HIGH)
	JAL	R5,DIAG			:SEND MESSAGE
	L	R1,USER			:GET R1 ADDR BACK
	KRCODE(1,0,0)			:MANUAL RESTART OF SLOT
	JAL	R11,KRASH		:
					:
   if	SPAM				:
    if	SPMTRC				:
	LIS	R10,0E			:SPAM TRACE ROUTINE ID
    ei (SPMTRC)				:
	JAL	R9,ENTIM		:COLLECT USER ENDING DATA
   ei  (SPAM)				:
	LPSW	MAINPSD			:RETURN TO MAIN LOOP
  ei   (MULMAC)				:
					:
MINT03	KRCODE(0,4,7)			:SET ERR MSG FLAG, DDT PROT VIOLATION
	JAL	R11,KRASH		:CRASH THE JOB
  if	SPAM				:
   if	SPMTRC				:
	LIS	R10,0F			:SPAM TRACE ROUTINE ID
   ei  (SPMTRC)				:
	JAL	R9,ENTIM		:COLLECT USER DATA
  ei   (SPAM)				:
	LPSW	MAINPSD			:AND QUIT
					:
:	.......................................................................
:	CRASH MACHINE BAD04 8751 WHEN SET 0 BAD
:	.......................................................................
					:
MINT04	S.HLTI(0451,MPSD1)		:
					:
:	.......................................................................
:	BUFFERS FOR MAC SET VERIFY
:	.......................................................................
					:
MSETSF	BS	4*10			:
MSETHD	BS	4*10			:
					:
:	.......................................................................
:	MACHINE MALFUNCTION INTERRUPT
:	.......................................................................
					:
PUTEXT	SC	/Power restored/	:
POWUP	LHI	2,0F0			:*0*SWITCH TO REGISTER SET F
	EPSR	3,2			:*0*
	JAL	R0,MINIT		:*F*REINITIALIZE THE MACHINE
	LCS	R4,1			:SLOT KEY
	LA	R5,PUTEXT		:
	JAL	R11,SETDIAG		:RECORD DATA FOR LOG
	KRCODE(1,0,1)			:INFORM ANYONE INTERESTED THAT THERE
	JAL	R10,DUMP		:  HAS BEEN A POWER FAILURE
	J	KINIT			:AND RE-ENTER KERNEL INITIALIZATION
					:
:	....................................................................
:	The following code is entered upon a MAC violation where upon entry,
:	Register Set 7 (seven) is the new register set.   This allows us to
:	maintain the integrity of register set 0 (Zero).  At this initial
:	interrup, register set '0' (zero) and 'F' are saved along with MAC
:	registers 340 thru 350 so that at least one copy of the interrupt 
:	data is maintained regardless of whether the interrupt is kernel or
:	slot related.
:	....................................................................
					:
MACHMAL	JF	0F,POWUP		:*0*POWER UP
					:
	L	R13,FASTC		:Get  the current FASTC
	ST	R13,INTIME		:save the current FASTC upon interrupt
	LHI	R13,38			:Indicate interrupt type/location
	LM	R14,20			:Get machine malfunction interrupt PSD
					:from location 20
	STM	R13,INTTYP		:Save interrupt Type and PSD
	LM	R0,300			:Fetch MAC relocation registers
	STM	R0,MAC300		:Save  MAC relocation registers
					:
	LM	R12,344			:For TSI MAC-III gate-array
	L	R11,340			:Location
	STM	R11,MAC340		:340 must be read last.
					:
	LPSW	.+4			:
	HC	0,0F0,0,MACHMF		:Switch from register set "7" to "F"
MACHMF	STM	R0,MRGSVF		:Save register set "F"
					:
	LPSW	.+4			:
	HC	0,0,0,MACHM0		:Switch from register set "F" to "0"
MACHM0	STM	R0,MRGSV0		:Save register set "0"
					:
	LM	R14,INTTYP+4		:Copy interrupt PSD to register "E" &
					:"F" of set 0 for subsequent processing
   if	TSI!NANO			:
	L	R10,MACABS		:*0*GET ABSOLUTE ADDR OF ERROR
   else					:
	L	R10,MACADR		:*0*GET ADDRESS OF ERROR
   ei  (TSI!NANO)			:
	L	R0,MACSTAT		:*0*GET MAC STATUS REGISTER
   IF	MACV				:
   ELSE					:
    if	ZITEL				:
    else				:
	JAL	R5,PELOG		:*0*LOG THE ERROR
    ei (ZITEL)				:
   EI (MACV)				:
	LIS	R2,0			:*0*
	ST	R2,MACSTAT		:*0*CLEAR MAC INTERRUPT
   if	TSI!NANO			:
	THI	R0,MSCPU		:*0*IS IT A CPU ACCESS?
	JN	MACHM1			:*0*IF SO, SKIP
   else					:
	LR	R10,R10			:*0*CHECK FOR DMA ERRORS
	JGE	MACHM1			:*0*NOT ONE IF SIGN BIT IS OFF
					:DMA ERROR...LET USER FIND PARITY ERROR INSTEAD
	NI	R10,7FFFFFFF		:STRIP OFF DMA BIT
   ei  (TSI!NANO)			:
	LA	R2,LOWDDT,,		:*0*TEST IF WITHIN KERNEL
	CR	R10,R2			:*0*MACHINE CRASH IF SO
	JL	MACHM2			:*0*
	JAL	R11,GUBSP		:*0*DETERMINE SLOT ADDRESS SPACE
	CI	R1,0
	JE	MACHM2			:*0*CRASH MACHINE
	ST	R1,R1SAV		:*0*STORE SLOT POINTER
	LHI	R2,I.ENA!0F0		:*0*PREPARE TO ENABLE BITS
	EPSR	3,2			:*0*REG SET 0F
	ST	R1,MACH1		:SAVE USER REGISTER
	L	R1,R1SAV		:RESTORE SLOT POINTER
	J	MACHM5			:CRASH SLOT
MACHM1	LIS	2,5			:*0*TEST IF MAC'ED
	TBT	2,MMOPSD+2		:*0*
	JN	MACHM3			:*0*
	LA	2,LOWDDT,,		:*0*TEST IF WITHIN KERNEL
	C	2,MMOPSD+4		:*0*MACHINE CRASH IF SO
	JL	MACHM3			:*0*
MACHM2	L	R0,MMOPSD		:
	ST	R0,MACHMP		:
	L	R0,MMOPSD+4		:
	ST	R0,MACHMP+4		:
	S.HLTI(0220,MACHMP)		:
MACHM3	LHI	R2,I.ENA!0F0		:*0*PREPARE TO ENABLE INTS
	EPSR	3,2			:*0*REG SET 0F
	ST	R1,MACH1		:SAVE USER REG
	L	R1,USER			:PT TO USER BLOCK
MACHM5	STM	R0,RREG,R1		:SAVE USER REGS IN USER BLOCK
	L	R0,MACH1		:
	ST	R0,RREG+4,R1		:FIX REG 1
	L	R0,MMOPSD		:COPY PSD
	ST	R0,RPSW,R1		:
	L	R0,MMOPSD+4		:
	ST	R0,RPSW+4,R1		:
	LHL	R0,UFLAG,R1		:CHECK IF DDT JOB
	THI	R0,FDDT			:
	JNFS	MACHM4			:SKIP IF SO
	KRCODE(0,3,2)			:SET PARITY ERROR CODE
	JAL	R11,KRASH		:GO CRASH THIS USER
   if	SPAM				:
    if	SPMTRC				:
	LHI	R10,10			:SPAM TRACE ROUTINE ID
    ei (SPMTRC)				:
	JAL	R9,ENTIM		:COLLECT USER DATA
   ei  (SPAM)				:
	LPSW	MAINPSD			:GO BACK TO MAIN LOOP, ENABLE ALL INTERRUPTS
					:
MACHM4	STM	R8,URSA+8*4,R1		:SAVE REGISTERS IN DDT DATA SEG
	LM	R8,RREG,R1		:
	STM	R8,URSA,R1		:
	L	R15,RPSW+4,R1		:OLD PSW
	LHL	R14,CPSW,R1		:INSURE NO BAD STATUS BITS
	STM	R14,OLDPSW,R1		:SAVE IN DDT DATA SEG
	LIS	R3,3^2			:SET ERROR FLAG
	STH	R3,EFLAG,R1		:STORE IN DDT DATA SEG
	LPSW	DDTPSW			:TRANSFER TO DDT
					:
:	.......................................................................
:	GUBSP - Get User Block Pointer
:
:	ROUTINE TO DETERMINE IF A PHYSICAL ADDRESS RESIDES IN A SLOTS ADDRESS
:	SPACE. RETURNS USER BLOCK POINTER OR ZERO OTHERWIZE.
:
:	ENTRY:  R10 - CONTAINS THE PHYSICAL ADDRESS IN QUESTION
:	RETURN:	R1  - CONTAINS USB POINTER OR ZERO IF NOT A MATCH
:	USES:	R2 TO R6 as scratch register
:	LINK:	R11
:	.......................................................................
					:
GUBSP					:
   IF	SUP				:
	LHI	R3,NSLOT+7		:
   ELSE					:
	LHI	R3,NSLOT		:
   EI  (SUP)				:
	LIS	R4,0			:LOOP INDEX, KEY
GUBSP1	CLR	R4,R3			:
	JG	GUBSP5			:NOT MATCHED
	SLLS	R4,2			:KEY*4
	L	R1,SLIST,R4		:USER BLOCK POINTER
	L	R2,CONTROL,R1		:POINTER TO DDT BLOCK
	L	R5,SBASE,R2		:SLOT START ADDRESS
	CLR	R10,R5			:COMPARE
	JLFS	GUBSP5			:NOT MATCHED
	LHL	R6,CMAX,R2		:GET LENGTH IN PAGES
	SLLS	R6,MACPAG		:CONVERT TO BYTES
	AR	R5,R6			:SLOT END ADDRESS
	CLR	R10,R5			:COMPARE
	JLFS	GUBSP9			:RETURN USB POINTER
	AIS	R4,1			:UP INDEX
	J	GUBSP1			:LOOP
GUBSP5	LIS	R1,0			:ZERO RETURN
GUBSP9	JR	R11			:
					:
:	.......................................................................
:
:	ROUTINE TO LOG A PARITY ERROR
:
:	ENTRY:	R0  - CONTAINS THE MAC STATUS REGISTER (340x)
:		R10 - CONTAINS THE ADDRESS OF PARITY ERROR
:
:		BOTH R0 AND R10 ARE PRESERVED
:
:	USES:	R1 - R7,R12-R15
:	LINK:	R5
:
:	IF ZITEL IS ENABLED, THE ERROR IS NOT LOGGED AND ONLY THE
:	PARITY ERROR COUNT (PECTR) IS UPDATED.
:
:	MAC STATUS BIT EQUATES
:	.......................................................................
					:
MSPAR	EQ	0200			:MAC STATUS PARITY ERROR BIT
MSDMA	EQ	2000			:MAC STATUS DMA ACCESS BIT
MSIOCH	EQ	4000			:MAC STATUS I/O CHAN ACCESS BIT
MSCPU	EQ	8000			:MAC STATUS CPU ACCESS BIT
					:
  IF	MACV				:
  ELSE					:
   if	ZITEL				:
   else					:
					:
:	.......................................................................
:	PARITY ERROR LOG FLAG EQUATES
:	.......................................................................
					:
	GL	PEINDX,PETRC,PEFLAG,PETIME,PEADDR,PEUADR,PELEN
	GL	PTLEN

PEDMA	EQ	0100			:DMA ACCESS FLAG
PEIOCH	EQ	0200			:I/O CHAN ACCESS FLAG (TSI)
PECPU	EQ	0400			:CPU ACCESS FLAG
PEMAC	EQ	0800			:MAC BIT FLAG
PEUADR	EQ	4000			:UNKNOWN ADDR FLAG (TSI)
PEENT	EQ	8000			:LOG ENTRY PRESENT FLAG
					:
PENENT	EQ	8			:# OF ENTRIES IN LOG
OLDORG	EQ	.			:
	ORG	0			:
PETIME	WS	1			:TIME OF FIRST ERROR AT ADDR
PEFLAG	HS	1			:ERROR FLAGS
PECNT	HS	1			:ERROR COUNT
PEADDR	WS	1			:ADDRESS OF ERROR
PELEN	EQ	.-PETIME		:ENTRY LENGTH
	ORG	OLDORG			:
   ei  (ZITEL)				:
					:
PECTR	HC	0			:ERROR COUNTER
   if	ZITEL				:
   else					:
PEINDX	HC	0			:LOG INDEX
PETRC	HS	0			:LOG AREA
 re	PELEN*PENENT/2
	HC	0
 er
PTLEN	EQ	.-PETRC			:
   ei  (ZITEL)				:
					:
PELOG	LIS	R2,1			:
	AHM	R2,PECTR		:BUMP PARITY ERROR COUNT
   if	ZITEL				:
   else					:
	LR	R12,R10			:COPY ADDRESS OF ERROR
	LHL	R4,PEINDX		:GET CURRENT LOG INDEX
    if	TSI!NANO			:
	LR	R2,R0			:COPY MAC STATUS REGISTER
	NHI	R2,0E000		:ISSOLATE ACCESS TYPE BITS
	SRLS	R2,5			:MOVE INTO POSTION FOR LOG
	LHI	R3,PEENT,R2		:ADD IN ENTRY PRESENT FLAG
	THI	R0,MSPAR		:IS PARITY ERROR BIT ON?
	JN	PELG9			:IF SO, SKIP
    else				:
	LHI	R3,PEENT+PEDMA		:ASSUME DMA ACCESS
	LR	R12,R12			:WAS IT DMA ACCESS?
	JL	PELG8			:IF NOT, SKIP
	LHI	R3,PEENT+PECPU		:CHANGE TO CPU ACCESS
	LHI	R13,400			:GET MAC BIT
	NH	R13,MMOPSD+2		:IS MAC BIT ON?
	JE	PELG9			:IF NOT, SKIP
	L	R1,USER			:GET CURRENT USER
	JAL	R11,ACCESS		:GET PHYSICAL ADDRESS
	J	PELG4			:IF FAILS, LOG AS UNKNOWN
	J	PELG9			:IF OK, LOG IT
    ei (TSI!NANO)			:
PELG4	LH	R6,PETRC+PEFLAG,R4	:SEARCH FOR PREV UNKNWN ADDR
	JL	PELG7			:
PELG5	AHI	R4,PELEN		:GET LOG ENTRY LENGTH
	CLHI	R4,PTLEN		:END OF LOG?
	JLFS	PELG6			:IF NOT, SKIP
	LIS	R4,0			:WRAP INDEX
PELG6	CLH	R4,PEINDX		:EXAMINED ALL OF LOG?
	JNBS	PELG5			:IF NOT, DO NEXT
	OHI	R3,PEUADR		:SET UNKNWN FLAG AND COUNT
	J	PELG12			:FILL IN INFO AND EXIT
PELG7	THI	R6,PEUADR		:IS IT UNKNOWN ADDRESS ENTRY?
	JE	PELG5			:IF NOT, DO NEXT
	NHI	R6,700			:MASK ACCESS TYPE BITS
	NR	R6,R3			:IS ACCESS TYPE THE SAME
	JE	PELG5			:IF NOT, DO NEXT
	LIS	R2,1			:BUMP COUNT
	AHM	R2,PETRC+PECNT,R4	:
	JR	R5			:RETURN
    if	TSI!NANO			:
    else				:
PELG8	NI	R12,7FFFFFFF		:STRIP DMA BIT
    ei (TSI!NANO)			:
PELG9	LH	R6,PETRC+PEFLAG,R4	:GET FLAGS
	JL	PELG13			:IF AN ENTRY, SKIP
PELG10	AHI	R4,PELEN		:BUMP LOG INDEX
	CLHI	R4,PTLEN		:END OF LOG?
	JLFS	PELG11			:IF NOT, SKIP
	LIS	R4,0			:WRAP INDEX
PELG11	CLH	R4,PEINDX		:EXAMINED ALL OF LOG?
	JNBS	PELG9			:IF NOT, DO NEXT
	ST	R12,PETRC+PEADDR,R4	:PLACE ADDRESS IN LOG
PELG12	L	R2,SLOWC		:GET CURRENT TIME
	ST	R2,PETRC,R4		:PLACE TIME IN LOG
	STH	R3,PETRC+PEFLAG,R4	:PLACE FLAGS
	LIS	R2,1
	STH	R2,PETRC+PECNT,R4	:PLACE COUNT
	J	PELG14			:UPDATE INDEX AND EXIT
PELG13	THI	R6,PEUADR		:IS IT UNKNWN ADDR ENTRY?
	JN	PELG10			:IF SO, SKIP IT
	CL	R12,PETRC+PEADDR,R4	:IS ADDRESS THE SAME?
	JN	PELG10			:IF NOT, DO NEXT
	NHI	R6,700			:MASK ACCESS TYPE BITS
	NR	R6,R3			:ARE ACCESS TYPE THE SAME?
	JE	PELG10			:IF NOT, DO NEXT
	LIS	R2,1
	AHM	R2,PETRC+PECNT,R4	:INCREMENT COUNT
	JR	R5			:RETURN
PELG14	AHI	R4,PELEN		:BUMP INDEX
	CLHI	R4,PTLEN		:END OF LOG?
	JLFS	PELG15			:IF NOT, SKIP
	LIS	R4,0			:WRAP INDEX
PELG15	STH	R4,PEINDX		:PLACE INDEX
   ei  (ZITEL)				:
	JR	R5			:RETURN
  EI   (MACV)				:
					:
:	....................................................................
:	ILLEGAL INSTRUCTION EXECUTED
:
:	BIT MAP FOR GOOD OP-CODES
:	....................................................................
					:
GOODOP	HC	07FFF,0FFCC,0FF00,05FFB,0FFFC,0CFFC
	HC	04000,01F00,00000,0FC76,00000,00000
	HC	03FFC,0FC22,0C23E,01FF0
					:
:	....................................................................
:	The following code is entered upon a MAC violation where upon entry,
:	Register Set 7 (seven) is the new register set.   This allows us to
:	maintain the integrity of register set 0 (Zero).  At this initial
:	interrupt, register set '0' (zero) and 'F' are saved along with MAC
:	registers 340 thru 350 so that at least one copy of the interrupt 
:	data is maintained regardless of whether the interrupt is kernel or
:	slot related.
:	....................................................................
					:
ILLINS	L	R13,FASTC		:Get  the current FASTC
	ST	R13,INTIME		:save the current FASTC upon interrupt
	LHI	R13,30			:Indicate interrupt type/location
	STM	R13,INTTYP		:
					:
	LM	R0,300			:Fetch MAC relocation registers
	STM	R0,MAC300		:Save  MAC relocation registers
					:
	LM	R12,344			:On TSI MAC-III gate-array board
	L	R11,340			:Location 340
	STM	R11,MAC340		:340 must be read last...
					:
	LPSW	.+4			:
	HC	0,0F0,0,ILLINF		:Switch from register set "7" to "F"
ILLINF	STM	R0,MRGSVF		:Save register set "F"
					:
	LPSW	.+4			:
	HC	0,0,0,ILLIN0		:Switch from register set "F" to "0"
ILLIN0	STM	R0,MRGSV0		:Save register set "0"
	LM	R14,INTTYP+4		:Copy interrupt PSD to register "E" &
					:"F" of set 0.
	THI	0E,400			:Is MAC bit set (running under MAC)?
	JN	ILLIN2			:Yes, skip and no need save MAC reg.
	ST	R0,RSETS		:*0*SAVE R0
	LB	0,0,0F			:*0*CHECK OUT OP CODE
	TBT	0,GOODOP		:*0*IS IT A GOOD OP-CODE?
	JE	ILLIN1			:*0*NO...TAKE ILLEGAL INSTRUCTION TRAP
	L	R0,RSETS		:Restore R0
	STM	R14,ILLBMC		:*0*SAVE PSD
	S.HLT0(0441,ILLBMC)		:
					:
ILLIN1	CLI	0F,LOWDDT		:*0*WAS ILLEGAL INSTRUCTION BEFORE END OF KERNEL?
	JG	ILLIN2			:*0*NO
	STM	R14,ILLBKR		:SAVE PSD
	S.HLTI(0240,ILLBKR)		:
					:
ILLIN2	L	R0,RSETS		:Restore R0
	L	0D,USER			:*0*GET PTR TO USER BLOCK
	LHL	0C,UFLAG,0D		:*0*CHECK USER
	THI	0C,FDDT			:*0*IS IT DDT USAGE?
	JN	TRAP,,			:*0*LET DDT HANDLE IT IF SO
	STM	0E,RPSW,0D		:*0*SAVE OLD PSW
	LHI	0B,I.ENA!20F0		:*0*RESTORE INT.'S & SET REG SET F
	EPSR	0A,0B			:*0*
	ST	R1,KSAVE		:SAVE THIS USER REG
	L	R1,USER			:PTR TO USER BLOCK
	STM	R0,RREG,R1		:SAVE USER REGS IN USER BLOCK
	L	R2,CONTROL,R1		:DDT USER BLOCK
	JFS	ILLIN3

ILLIND	ST	R1,KSAVE		:ENTRY FROM DDT
	L	R1,USER
	STM	R0,RREG,R1		:SAVE USER REGS
	LR	R2,R1			:DDT USER BLOCK
ILLIN3	L	R0,KSAVE		:FIX REG 1 IN USER BLOCK, NOTE UB=R1
	ST	R0,RREG+4,R1
	L	R0,RPSW+4,R1		:SAVE USER PC
	ST	R0,MACLOC,R2
	KRCODE(0,6,4)			:ILLEGAL INSTR *OR* PRIVILEGE ERROR
	JAL	R11,KRASH		:CRASH THIS GUY
 if	SPAM
 if	SPMTRC
	LIS	R10,8			:SPAM TRACE ROUTINE ID
 ei	(SPMTRC)
	JAL	R9,ENTIM		:COLLECT 'ENDING' DATA
 ei	(SPAM)
	LPSW	MAINPSD			:RETURN TO MAIN LOOP
					:
:	MANUAL RESTART (FROM MACH CODE)
					:
KMTEXT	SC	/manual restart/	:
KMANUAL	LR	R10,R0			:GOT HERE VIA R0, RETURN VIA R10
	LCS	R4,1			:SET SYSTEM
	LA	R5,KMTEXT		:
	JAL	R11,SETDIAG		:RECORD DATA FOR LOG
	KRCODE(1,0,0)			:SET CODE FOR MANUAL RESTART
					:
:	.......................................................................
:	DUMP ALL JOBS
:	R10 = Link register
:	R0  = CRASH REASON
:	.......................................................................
					:
DUMP	LIS	R1,0			:CLEAR CURRENT-USER POINTERS
	ST	R1,USER			:
	ST	R1,RUSER		:
 if	DISPAT				:
	LA	R1,UBDISP		:CRASH THE DISPATCHER TOO
	JAL	R11,KRASH		:
 ei    (DISPAT)				:
	L	R1,RUN			:CHECK RUN LIST
	JER	R10			:ABORT IF NULL
DUMP1	L	R2,LLINK,R1		:GET POINTER TO NEXT JOB
	ST	R2,DUSER		:SAVE IT
	JAL	R11,KRASH		:CRASH THIS JOB
	L	R1,DUSER		:GET CURRENT RUN-LIST USER BACK
	JNBS	DUMP1			:DO FOR ALL USERS
	JR	R10			:THEN RETURN...ALL JOBS CRASHED, DISCONNECTED, ETC.
					:

	SUBTTL	CAUSING A SLOT TO CRASH

:	.......................................................................
:
:	KRASH -	K R A S H   A   J O B 
:	R1 = POINTER TO JOB
:	R0 = CRASH INDEX (HALFWORD)
:		HIGH BIT ON = MACHINE CRASH
:		HIGH BYTE   = RESTART CRASH CODE
:		LOW  BYTE   = DDT CRASH
:
:	On entry, R0 contains a "CRASH CODE" (which is preserved), designating,
:	in the right half, the "execution crash code", and in the left half, the
:	"debug" crash code.  Furthermore, if the sign bit is on, it designates
:	a "machine crash" condition, which permits restart for any and all
:	jobs of certain classes.
:		No matter what class of job, all I/O devices are first disconnected.
:		There are 4 types of distinct jobs (read user blocks), with differing
:	action performed for each:
:		DDT jobs -- these are CONTROLLING jobs, and can process an error condition
:	directly (unless it is a machine crash, which causes unconditional logoff).
:	All non-DDT jobs have an associated DDT job (which may be currently inactive)
:	and for these, the "debug crash code" is passed to the controlling DDT for
:	future error diagnosis.
:		KIO (Kernel I/O) jobs -- these are logged off UNCONDITIONALLY.  A special
:	case is the LOGGER job, which is set up to re-run in it's normal fashion.
:		Background job -- this may have an associated foreground (QUASI) job,
:	which is taken off the run list if the background job crashes.
:		Foreground (QUASI) job -- ALWAYS has an associated background job.
:	If the foreground crashes, the PSD and registers are copied to the associated
:	background, and the PSD is flagged with "FC" in the first byte, then the
:	foreground job is removed from the run list.
:	After the above has taken place for EITHER Foreground OR Background, then
:	the Background is crashed:
:		The background job may do a "restart" SVC, which specifies a restart
:	address.  In this case, and providing the job has not crashed since the
:	last restart SVC(the job is HUNG--deleted from run list, and disconnected
:	from DISPATCHER--if it HAS crashed) the crashing PSD and the first two
:	registers are saved at the specification address, and a new PSD formed
:	from the INITIAL PSW and an address which is = the restart address + 16d +
:	the EXECUTION CRASH CODE.  The job resumes execution from this point.
:		If there is no restart address, jobs which are internal to ISIS, or which
:	have undergone a machine crash, are restarted using the INITIAL PSD...others
:	are unconditionally HUNG.
:	
:	.......................................................................
					:
KRASH	ST	R11,KLINK		:SAVE RETURN
	JAL	R11,FNDDDT		:GET FLAGS, FIND THE CONTROLLING DDT BLOCK
	LHR	R0,R0			:TEST SYSTEM-CRASH BIT
	JLFS	KRASH0			:SYSTEM CRASH...DON'T DISTURB PRIOR CRASH CODE
	LBR	R6,R0			:ELSE COPY DDT CRASH REASON
	STH	R6,EFLAG,R4		:PLACE INTO DDT AREA
	JAL	R11,SUSSLT		:SET UP SUSPENDING ASSOCIATED SLOTS
KRASH0	THI	R5,FKIOJ!FDDT		:WAS IT A KERNEL I/O RELATED JOB?
	JE	KRASHD			:NO..SKIP
	THI	R5,FDDT			:Is this an extended DDT job?
	JNFS	KRASHA			:Yes, just skip...don't disconnect
	JAL	R11,DCDEV		:DISCONNECT ALL LOGICAL UNITS FOR JOB
KRASHA	LR	R0,R0			:IS THIS A SYSTEM-WIDE CRASH?
	JL	KRASHC			:SKIP IF SO
	L	R12,REST,R1		:HAS HE SET RESTART ADDRESS?
	JE	KRASHB			:NO...SKIP
	LHL	R13,RPSW+2,R1		:YES...GET PSW
	LIS	R11,0			:
	ST	R11,REST,R1		:CANCEL RESTART
	LR	R5,R12			:SAVE ADDRESS
	JAL	R11,ACCESS		:CHECK ACCESS
	J	 KRASHB			:BAD ADDRESS...ABORT
	LR	R6,R12			:OK...COPY REAL ADDRESS
	LM	R12,RPSW,R1		:SET UP RESTART
	STM	R12,0,R6		:
	LHL	R12,RPSW+2,R1		:MAKE MACHINE STATE SAME AS IT WAS
	NHI	R12,@100F		:(TURN OFF CONDITION CODE, TRACE)
	LA	R13,10,R5		:COMPUTE NEW START ADDRESS
	EXBR	R15,R0			:EXTRACT CODE
	NHI	R15,3F			:TOSS SYSTEM-DETECTED CRASH BIT
	STM	R12,RPSW,R1		:PLACE NEW PSD, REASON INTO HIS R1
	J	KRASHX			:AND EXIT

KRASHB	THI	R5,FDDT			:WAS IT DDT JOB?
	JN	SEXIT1			:TRANSFER CONTROL TO DDT IF SO
	JAL	R11,ZINSUB		:ZAP THIS USER, AND RE-INITIALIZE
	JAL	R11,RDISC		:REMOVE USER FROM RUN LIST
	LH	R4,SLOT,R1		:GET SLOT NMBR
	JL	KRASHX			:BR IF NOT USER SLOT
	RBT	R4,ACSLOT		:CLEAR RUNNING BITS
	RBT	R4,RNSLOT
	J	KRASHX			:AND EXIT

KRASHC	JAL	R11,ZINSUB		:ZAP THIS USER, AND RE-INITIALIZE
	JAL	R11,RDISC		:REMOVE USER FROM RUN LIST
	J	KRASHX

KRASHD	LR	R0,R0			:JOB IS NOT DDT, SYSTEM CRASH?
	JL	KRASHE			:YES...SKIP
	THI	R0,4000			:SEE IF TO IGNORE TRAP RTNS
	JN	KRSHD2			:BR IF SO
	L	R3,BGTRAP,R4		:GET BG TRAP ADDR
	THI	R5,FQUASI		:IS THIS FOREGROUND?
	JEFS	KRSHD1			:BR IF NOT
	L	R3,FGTRAP,R4		:GET FG TRAP ADDR
KRSHD1	LR	R3,R3			:SEE IF TRAP RTN DEFINED
	JEFS	KRSHD2			:BR IF NOT
	LR	R5,R3			:SAVE TRAP RTN ADDR
	LHL	R4,UFLAG,R1		:GET FLAGS BACK
	J	KRASHJ			:GO SET UP TRAP RTN

KRSHD2	THI	R5,FDEBUG		:IS IT IN DEBUG MODE?
	JN	ONFRZ1			:IF SO, A CRASH IS LIKE FREEZE SVC
KRASHE	JAL	R11,DCDEV		:DISCONNECT ALL LOGICAL UNITS FOR JOB
	THI	R5,FQUASI		:JOB IS NOT DEBUG...WAS IT FOREGROUND?
	JE	KRASHG			:SKIP IF NOT
	L	R4,OTHER,R1		:THIS IS A FOREGROUND-JOB
	LHI	R5,4*11			:COPY THE JOB STATE TO BACKGROUND
KRASHF	L	R6,RPSW,R1,R5
	ST	R6,RPSW,R4,R5
	SIS	R5,4
	JGEBS	KRASHF			:COPY PSD, REGISTERS
	STB	R5,RPSW,R4		:SET FLAG FOR FOREGROUND-CRASH
	JFS	KRASHH			:SKIP TO KILL FOREGROUND JOB

KRASHG	L	R6,OTHER,R1		:NOT FOREGROUND-JOB...IS THERE ONE ASSOCIATED?
	JEFS	KRASHI			:SKIP IF NOT
	LR	R1,R6			:YES...CLEAN IT UP FIRST
KRASHH	JAL	R11,FDISC		:REMOVE ENTRY FROM FOREGROUND QUEUE IF PRESENT
	L	R1,OTHER,R1		:NOW GET POINTER TO BACKGROUND JOB
	ST	R1,USER			:BACKROUND JOB IS NOW CURRENT USER
					:
:	.......................................................................
:	HERE TO CRASH BACKGROUND JOB
:	.......................................................................
					:
KRASHI	LHI	R5,MPROT+3E,R1		:RESET TO INITIAL USER MAC
	ST	R5,MACTRN,R1		:
	LH	R12,SLOT,R1		:TEST IF SYSTEM JOB
   IF	MXP				:
	JL	KRSHI1			:DON'T TRY TO DISCONNECT SYSTEM JOBS
	LR	R14,R0			:SAVE CRASH REASON
    if	ENHMXP				:version 3.00 of MXP-XPI
	LHI	R0,KDMDSK		:NEW KDIO DISCONNECT MSG
    else				:
	LHI	R0,KDMDSC		:disconn msg for version 2.04 of MXP
    ei (ENHMXP)				:
	JAL	R4,KDOS			:
	LR	R0,R12			:
	JAL	R4,KDOH			:
	JAL	R4,KDOE			:
	LR	R0,R14			:
   ELSE					:
	JLFS	KRSHI1			:
	STH	R12,DSLOT		:MAKE SURE THE DISPATCHER RUNS SOON
	STH	R12,DHANG		:& KILLS SLOT - (HOMOGENEOUS INTERFACE)
   EI  (MXP)				:
KRSHI1	L	R5,REST,R1		:GET RESTART ADDRESS
	JE	KRASHK			:NONE...SKIP
	LHL	R4,UFLAG,R1		:GET USER FLAGS
   IF	MXP				:
	THI	R4,FDISP		:test if dispatcher job
	JE	KRSHI2			:nothing to do if not
	LHL	R12,WFLAG,R1		:else get wait flag
    if	ENHMXP				:version 3.00 of MXP-XPI
	OHI	R12,XPIWF		:OR in wait bit
	STH	R12,WFLAG,R1		:
	LIS	R12,0			:kill remaining quantum
	STH	R12,QUANTUM,R1		:
    else				:not ENHMXP
	OHI	R12,FTIM		:set timout flag
	STH	R12,WFLAG,R1		:and pause slot
	LIS	R12,4			:for 4 seconds
	STH	R12,QUANTUM,R1		:
	LHI	R12,4*RATE		:
	A	R12,FASTC		:
	ST	R12,UTIME,R1		:
    ei (ENHMXP)				:
   EI  (MXP)				:
					:
:	.......................................................................
:	KILL THE WATCHFROG TIMER (IF ANY) HERE
:	.......................................................................
					:
  IF	MXP				:ONLY IF WE PAUSE SLOT
   IF	WFROG				:ONLY IF WATCHFROG TIMER ENABLED
	L	R12,WFROGT,R1		:
	AIS	R12,2			:
	JLFS	KRSHI2			:
	LCS	R12,1			:
	ST	R12,WFROGT,R1		:
    IF	\HI.FRG				:
	L	R12,SLOWC		:
	AIS	R12,0F			:15 SECONDS BETTER BE ENOUGH...
	ST	R12,WFROGD,R1		:
    EI (HI.FRG)				:
   EI  (WFROG)				:
  EI   (MXP)				:
KRSHI2	LR	R0,R0			:IS THIS A SYSTEM CRASH?
	JLFS	KRASHJ			:JUST RESTART IF SO
	THI	R4,F1CRAS		:ELSE TEST IF HE'S HAD A SYSTEM-DETECTED CRASH
					:...SINCE LAST RESTART
	JN	KRASHK			:YES...TAKE OFF RUN LIST
	OHI	R4,F1CRAS		:SET HIM TO CRASH NEXT TIME
					:
KRASHJ	NHI	R4,@FNOREG		:INSURE REGISTERS ARE RETURNED
	STH	R4,UFLAG,R1		:
	LR	R12,R5			:COPY ADDRESS
	LHL	R13,RPSW+2,R1		:TEST IF RUNNING UNDER MAC
	JAL	R11,ACCESS		:
	J	 KRASHK			:(LEAVE RX2!)NOT VALID...TREAT AS NO RESTART ADDRESS
	LR	R6,R12			:COPY USER ADDRESS
	LM	R12,RPSW,R1		:SET UP RESTART
	STM	R12,0,R6		:
	LHL	R12,INIPSW+2,R1		:MAKE MACHINE STATE SAME AS ORIGINAL
	LA	R13,10,R5		:COMPUTE NEW START ADDRESS
	EXBR	R15,R0			:EXTRACT CODE
	NHI	R15,3F			:TOSS SYSTEM-DETECTED CRASH BIT
	STM	R12,RPSW,R1		:PLACE NEW PSD, REASON INTO HIS R1
	J	KRASHX			:AND EXIT
					:
:	.......................................................................
:	THE BACKGROUND JOB DOES NOT HAVE A RESTART ADDRESS!
:	.......................................................................
					:
KRASHK	LH	R4,SLOT,R1		:
	JLFS	KRASHL			:JUST RESTART IF INTERNAL JOB
	LR	R0,R0			:ELSE CHECK FOR SYSTEM CRASH
	JGEFS	KRASHM			:IF NOT, DISCONNECT JOB AND LEAVE HANGING
KRASHL	LM	R14,INIPSW,R1		:
	STM	R14,RPSW,R1		:USE HIS INITIAL PSW TO RESTART HIM
	J	KRASHX			:AND EXIT
					:
:	.......................................................................
:	DISCONNECT JOB AND LEAVE HANGING!!
:	.......................................................................
					:
KRASHM	JAL	R11,RDISC		:DO IT!
	LH	R6,SLOT,R1		:GET SLOT NMBR
	JLFS	KRASHN			:BR IF NOT USER SLOT
	RBT	R6,ACSLOT		:CLEAR RUNNING BITS
	RBT	R6,RNSLOT		:
KRASHN	LR	R4,R6			:
	LR	R7,R1			:COPY USER BLOCK POINTER
	JAL	R11,DCKIO		:DISCONNECT KIO
	LR	R1,R7			:RESTORE USER BLOCK POINTER
	JAL	R11,FNDDDT		:GET DDT BLOCK
	LHL	R5,EFLAG,R4		:
	OHI	R5,8000			:INDICATE SLOT CRASH
	STH	R5,EFLAG,R4		:
	LH	R4,UFLAG,R1		:CHECK SLOT
	THI	R4,FDISP		:IS IT CONNECTED TO DISPATCHER?
   if	KIOSRC				:
	LHI	R4,(NSLOT+1)*4		:MAKE SUP SLOT INDEX
	JE	KRASHZ			:
   ei  (KIOSRC)				:
	JE	KRASHX			:SKIP IF NOT
	LR	R4,R6			:SLOT NMBR
	STH	R4,DHANG		:TELL DISPATCHER TO HANG
	STH	R4,DSLOT		:INSURE DISPATCHER RUNS NEXT
	LA	R5,KRAMSG		:LOG DIAGNOSTIC
	JAL	R11,SETDIAG		:
	SLHLS	R4,2			: *4
	LO	FLASH			:
KRASHZ	LA	R11,DIED,,		:SET UP DISPLAY
	ST	R11,DISTBL,R4,,		:
	FO	FLASH			:
KRASHX	L	R11,KLINK		:RESTORE RETURN
	JR	R11			:GO BACK WHERE WE CAME FROM
KRAMSG	SC	/Stopped!!/		:

					:
:	.......................................................................
:	DISCONNECT A USER BLOCK FROM FOREGROUND LIST
:	R1 = POINTER TO USER BLOCK
:	.......................................................................
					:
FDISC	LR	R1,R1			:CHECK FOR NULL
	JER	R11			:EXIT IF SO
	LA	R4,QUASI		:SET POINTER TO QUASI-LIST
FDISC1	CL	R1,LLINK,R4		:IS THIS ENTRY POINTING AT UB?
	JEFS	FDISC2			:YES...UNLINK IT
	L	R4,LLINK,R4		:NO...GET NEXT OF (R4)
	JNBS	FDISC1			:NOT AT END OF LIST...CONTINUE
	JR	R11			:NOT ON LIST...QUIT

FDISC2	L	R5,LLINK,R1		:WE HAVE A MATCH...UNLINK
	ST	R5,LLINK,R4
	JR	R11			:AND EXIT


:	DISCONNECT A USER BLOCK FROM RUN-LIST
:	R1 = POINTER TO USER BLOCK
RDISC	LA	R4,RUN			:SET POINTER TO RUN LIST
	LR	R6,R4			:COPY ADDR OF RUN LIST
RDISC1	CL	R1,LLINK,R4		:IS THIS ENTRY POINTING AT UB?
	JEFS	RDISC2			:YES...UNLINK IT
	L	R4,LLINK,R4		:NO...GET NEXT OF (R4)
	JNBS	RDISC1			:NOT AT END OF LIST...CONTINUE
	JR	R11			:NOT ON LIST...QUIT
:	*NOTE*	USER BLOCK NOT PLACED ON FREE LIST, IF NOT PRESENT ON RUN LIST

RDISC2	L	R5,LLINK,R1		:WE HAVE A MATCH...UNLINK
	ST	R5,LLINK,R4
	CL	R1,RUSER		:ARE WE DELETING THE CURRENT RUN-LIST USER?
	JNFS	RDISC6			:MUCH LESS TROUBLE IF NOT
	CLR	R4,R6			:WERE WE AT BEGINNING OF RUN LIST?
	JNFS	RDISC5			:IF NOT, CAN MAKE RUSER BE BLOCK
					: WHICH POINTED AT US
	JFS	RDISC4			:ELSE MUST POINT RUSER AT LISTEND

RDISC3	LR	R4,R5
RDISC4	L	R5,LLINK,R4		:FIND END OF RUN LIST
	JNBS	RDISC3
	CLR	R4,R6			:CHECK FOR EMPTY RUN LIST
	JNFS	RDISC5			:NOT EMPTY, MAKE RUSER = USER AT END OF LIST
	LIS	R4,0

RDISC5	ST	R4,RUSER		:RUSER IS PREVIOUS USER

RDISC6	LH	R5,UFLAG,R1		:DOES USER BELONG ON FREE LIST?
	THI	R5,FDDT!FKIOJ!FLOGIN	:OR IS IT LOGON BLOCK?
	JER	R11			:NEITHER, FINISHED
	THI	R5,FLOGIN		:IS IT THE LOGON BLOCK?
	JEFS	RDISC7			:SKIP IF NOT
	LIS	R4,0			:ELSE SET LOGIN BLOCK FREE
	STH	R4,DUMMY		:
	JR	R11			:
RDISC7	L	R4,LFREE		:
	ST	R4,LLINK,R1		:THREAD ONTO FREE LIST
	ST	R1,LFREE		:
	JR	R11			:
					:
:	....................................................................
:	DISCONNECT ALL DEVICES FROM USERBLOCK
:	R1 = USER BLOCK
:	R11 ON R11
:	USES R12,R13,R14
:	....................................................................
					:
LNKSAV	WC	1			:SAVE AREA FOR R11
DCDEV	ST	R11,LNKSAV		:SAVE RETURN R11
 if	SHARE				:
	IF	TSIDT
	GL	JCMCRA,DTSCRA
	JAL	R11,JCMCRA,,		:JCOM CRASH RESPONSE ROUTINE
	JAL	R11,DTSCRA,,		:DTS CRASH RESPONSE ROUTINE
	ELSE
	LH	R12,UFLAG,R1
	NHI	R12,FDDT!FKIOJ
	JNFS	DCDEV0			:SKIP IF DDT OR KERNEL I/O JOB
	STH	R12,DREQ,R1		:SHOW NO REQUESTS OUTSTANDING
	L	R13,OTHER,R1		:ADDR OF FOREGROUND(BACKGROUND)
	JEFS	DCDEV0			:SKIP IF NULL
	STH	R12,DREQ,R13		:SHOW NO REQUESTS OUTSTANDING
	EI	(TSIDT)
 ei	(SHARE)
DCDEV0	LHI	R13,NLU*4		:FOR ALL UNITS
DCDEV1	SIS	R13,4			:FOR NEXT UNIT
	JLFS	DCDEVR			:EXIT WHEN DONE
	JAL	R11,DCDVC		:RELEASE DEVICE
	JBS	DCDEV1			:GO DO NEXT ONE
					:
DCDEVR	L	R11,LNKSAV		:
	JR	R11			:
					:
:	.......................................................................
:	SUBROUTINE TO DISCONNECT A SINGLE DEVICE.  THIS IS USED
:	BY DCDEV ABOVE AND ALSO THE SVC TO DISCONNECT A DEVICE
:
:	EXPECTS R1 TO BE POINTING TO THE USER BLOCK AND USES
:	R12,R13,S3.
:	R13 CONTAINS AN INDEX INTO LUN FOR THE DEVICE TO DISCONNECT
:	.......................................................................
					:
DCDVC					:
	L	R14,LUN,R1,R13		:ELSE GET POINTER
	JER 	R11			:IGNOR IF NULL
	LB	R12,LUN,R1,R13		:CHECK IF SYNC
	JN	DCDEV2			:SKIP IF NOT
 if	NSYNC
	LO	SYNC
 if	HMICRO!TSI!NANO
	LH	R15,LINIT,R14		:IS IT IN INITIALIZATION
	JER	R11			:RETURN, IF SO
 ei
	ST	R12,IBA,R14		:IN USE...DISCONNECT INPUT
	ST	R12,ODSRBP,R14		:DISCONNECT DSR POINTER
	ST	R12,OCSBP,R14		:DISCONNECT CS POINTER
	L	R12,ISYNCA		:DISCONNECT OUTPUT AND INPUT
	LB	R14,OPIX,R14		:GET INTERRUPT INDEX
	ST	R12,SYNVEC,R14
	L	R14,LUN,R1,R13		:NOW RESTORE POINTER
 if	ESYNCI
	TS	OSLOTO,R14		:SET LINE NOT-OWNED
	LHL	R14,OESIPT,R14		:GET ENHANCED SYNC INT PTR
	LA	R12,CIINUL		:FORCE SOFTWARE INPUT INTERRUPTS
	ST	R12,CIIPTR,R14		:/
	LIS	R12,0
	STH	R12,OIX,R14		:FORCE SOFTWARE OUTPUT INTERRUPTS
	ST	R12,OEAD,R14		:/
 if	HMICRO!TSI!NANO
	LCS	R12,1
	STH	R12,OPAD,R14		:RESET OUTPUT PADDING
 ei	(HMICRO!TSI!NANO)
	L	R14,LUN,R1,R13		:RESTORE PTR
 ei	(ESYNCI)

	LCS	R12,1
	STH	R12,OPHW,R14		:RESET OUTPUT PADDING
 if	HMICRO!TSI!NANO
 else
	LH	R12,OLBITX,R14		:CHECK FOR RS PORT
	JLR	R11			:IGNOR IF NOT
	SBT	R12,SDTR		:TURN OFF RS
	SIS	R12,8			:MOVE ON TO DTR
	RBT	R12,SDTR
	LHI	R12,0BF			:DRIVE IT
	WD	R13,SDTR+1
 if	XSYNC
	LHI	R12,0FF
	WD	R12,SDTR+3
 ei
 ei	(HMICRO!TSI!NANO)
	FO	SYNC
	JR	R11			:AND TRY NEXT ONE
 ei	(NSYNC)
DCDEV2	SIS	R12,1			:CHECK FOR ASYNC
 if	NASYNG
	LO	CLOCKS			:
	JN	DCDEV4			:SKIP IF NOT
	ST	R12,ATOPP,R14		:STOP OUTPUT
	LCS	R12,1			:LOWER DTR
	ST	R12,ADTRP,R14		:
	ST	R12,ADSRP,R14		:
	ST	R12,ACPP,R14		:
					:
	LB	R12,1,R14		:GET PHYSICAL UNIT NUMBER
	SLLS	R12,5			:GET 1ST PORT NUMBER *2
	STH	R13,DCDSAV		:SAVE LUN
	LA	R13,VCLSBA		:SET TO NULL ACTIVITY ON INPUT
	LIS	R14,0F			:TURN OFF ALL 16 PORTS
:
DCDEV3	STH	R13,VSTATE,R12		:SET PORT INACTIVE
	AIS	R12,2			:NEXT PORT
	SIS	R14,1			:DONE?
	JGEBS	DCDEV3			:DO ALL 16
	LH	R13,DCDSAV
	JR	R11			:AND GO DO ANOTHER
DCDSAV	HS	1
	FO	CLOCKS
DCDEV4	HS	0
 ei	(NASYNG)
	SIS	R12,1			:CHECK FOR PRINTER
 if	NPRINT
	LO	PRINT
	JNFS	DCDEV5			:SKIP IF NOT
	ST	R12,COC,R14		:ELSE DISCONNECT OUTPUT
	ST	R12,PRSTAT,R14		:DISCONNECT STATUS
	JR	R11			:AND DO ANOTHER
	FO	PRINT
DCDEV5	HS	0
 ei	(NPRINT)
	SIS	R12,2			:CHECK FOR MOTHER-BOARD DEVICE
 if	M.NCARD
	LO	MBOARD
	JN	DCDEV7			:SKIP IF NOT
	ST	R12,M.STAT,R14		:YES...CANCEL STATUS MONITOR
	LHL	R12,M.CHNA,R14		:LOCATE ADDRESS
	OHI	R12,7000		:RESET COMMAND
	LHI	R2,20			:SET TIMER
DCDEV6	SIS	R2,1			:DECREMENT TIMER
	JLR	R11			:EXIT IF TIMER FIRES
	SSR	R12,R14			:CHECK DEVICE
	JTR	4,R11			:IGNOR IF NOT WORKING
	JTBS	8,DCDEV6		:ELSE WAIT FOR IT IF NECESSARY
	WDR	R12,R14			:HALT I/O FOR CHANNEL
	JR	R11			:AND EXIT
	FO	MBOARD
DCDEV7	HS	0
 ei	(M.NCARD)
	SIS	R12,1
 if	IPNMBR
	LO	IPI
	JN	DCDEV8
	LH	R12,IPCRSM,,		:DID IPI SEND CRASH MSG?
	JEFS	DCDV7A			:NO
	LIS	R12,0
	STH	R12,IPCRSM,,
	JR	R11			:DON'T SEND CRSH MSG BACK
DCDV7A	LI	R12,EIPCRA		:GET CRASH MSG
	ST	R12,ETOIPM,R14		:SAVE IN MSG AREA
	L	R12,FASTC,,
	ST	R12,EIPTIM,R14		:SAVE TIME OF DSCNECT
	LHL	R12,IPADDR,R14		:GET DEVICE ADDR
	SSR	R12,R2			:DEVICE THERE?
	THI	R2,1
	JER	R11			:IGNORE IF NOT
	LIS	R2,7			:INTERRUPT
	OCR	R12,R2
	LIS	R2,6
	OCR	R12,R2
	JR	R11
	FO	IPI
 ei	(IPNMBR)
DCDEV8	SIS	R12,1
 if	SBUS
	JN	DCDEV9			:NOT THIS DEVICE TYPE
	JAL	R2,SBDISC		:DISCONNECT SBUS DRIVER
 ei	(SBUS)
DCDEV9	JR	R11			:AND DO ANOTHER

:	THIS SUBROUTINE COPIES SLOT NUMBERS FROM THE SLOT'S SUSPEND
:	LIST TO THE KERNEL SUSPEND LIST, THUS SCHEDULING THEM TO BE
:	SUSPENDED.

:	CALLING SEQUENCE:  JAL R11,SUSSLT
:	INPUT: R1 (R1) HAS THE ADDRESS OF THE SLOT BUFFER

SUSSLT	ST	R13,SSSAV
	L	R13,RLICEN,R1		:CHECK IF SLOT HAS A SUSPEND LICENSE
	TI	R13,TL.SUS
	JE	SSS20			:IF NOT - BYE
	L	R13,TOSUSP,,		:IF SO - PUT DESIGNATED SLOTS...
	O	R13,SUSLST,R1		:INTO SUSPEND LIST
	ST	R13,TOSUSP,,
	L	R13,TOSUSP+4,,
	O	R13,SUSLST+4,R1
	ST	R13,TOSUSP+4,,

	LIS	R13,0			:RESET THE SUSPEND LIST
	L	R1,OTHER,R1		:POINT TO THE OTHER USER BLOCK
	JEFS	SSS10
	ST	R13,SUSLST,R1		:
	ST	R13,SUSLST+4,R1		:
	L	R1,OTHER,R1		:POINT BACK TO THE ORIGINAL
SSS10	ST	R13,SUSLST,R1		:
	ST	R13,SUSLST+4,R1		:
SSS20	L	R13,SSSAV		:
	JR	R11			:
					:
SSSAV	WS	1			:
					:
 if	MULMAC				:

	SUBTTL	SORT LIST OF MAC BLOCKS AND ASSIGN MAC SETS

:	.......................................................................
:	EACH MAC BLOCK CONSISTS OF 16 MAC REGISTERS FOLLOWED BY A FULLWORD
:	POINTER TO A PSD, THEN A HW USAGES COUNT THEN A BYTE INDICATING THE
:	SLOT NUMBER (FF FOR MAC BLOCKS CONTAINED IN THE USER BLOCK) FINALLY
:	THERE IS A FULL-WORD R11 THAT LINKS ALL OF THE BLOCKS ONTO A LIST.
:	THE LAST ENTRY ON THE LIST HAS A R11 OF ZERO.
:
:	FOR EFFICIENCY REASONS THE POINTER TO A BLOCK IS THE LAST HALFWORD OF
:	THE MAC REGISTER SETS.  THIS ALLOWS THE POINTER TO BE USED DIRECTLY FOR
:	A COPY COMMAND USED TO LOAD THE MAC REGISTERS.
:	.......................................................................
					:
MACLUP	L	R1,SML			:GET HEAD OF LIST
	LA	R3,SML-0A		:START R11 FOR INSERT
					:
MLOOP1	LR	R2,R1			:SAVE OLD R11
MLOOP2	L	R1,0A,R2		:ADVANCE FORWARD
	JE	MLOOP5			:DONE
					:
	LH	R4,06,R1		:FETCH COUNT
	JEBS	MLOOP1			:DON'T BOTHER WITH ZEROES
	LIS	R5,$A15			:SEARCH ONLY 15 ENTRIES
	LR	R7,R3			:COPY SEARCH START
					:
MLOOP3	LR	R6,R7			:
	L	R7,0A,R6		:NEXT R11
	CR	R7,R2			:DON'T SEARCH PAST SELF
	JEBS	MLOOP1			:
	CH	R4,06,R7		:
	JGFS	MLOOP4			:DO THE INSERT
	SIS	R5,1			:LIMIT AT 15 ENTRIES
	JGEBS	MLOOP3			:DO THE REST
	J	MLOOP1			:UNCUCCESSFUL
					:
:	.......................................................................
:	SUCCESSFUL SEARCH DO AN INSERT AND TIDY UP LINKS
:	.......................................................................
					:
MLOOP4	L	R5,0A,R1		:UNTHREAD CURRENT BLOCK
	ST	R5,0A,R2		:
					:
	ST	R1,0A,R6		:THREAD INT NEW POSTTION
	ST	R7,0A,R1		:
					:
	J	MLOOP2			:DO NEXT
					:
:	.......................................................................
:	LIST IS SORTED!!  NOW COLLECT THE NAC NUMBERS FOR ALL OF THESE
:	PRESERVING THE ONES IN THE FIRST 15 SETS RESETTING IN THE
:	SUBSEQUANT SETS AND CLEARING THE COUNT
:	.......................................................................
					:
MLOOP5	LIS	R5,$A15			:PRESERVE FIRST 15
	LIS	R4,0			:FOR CLEARING COUNTS
	STH	R4,MARRY		:REMEMBER WHAT M-REGS ARE USED
	LR	R1,R3			:GET TOP OF LIST
					:
MLOOP6	L	R1,0A,R1		:GET NEXT ON LIST
	JE	MLOOP8			:EXIT IF END FOUND
					:
	STH	R4,6,R1			:RESET COUNT
	LB	R2,9,R1			:REMEMBER THIS M-SET
	SBT	R2,MARRY		:
					:
	SIS	R5,1			:REDUCE COUNT
	JGEBS	MLOOP6			:
					:
MLOOP7	L	R1,0A,R1		:NEXT ON LIST
	JEFS	MLOOP8			:
	STH	R4,6,R1			:CLEAR COUNT
	STB	R4,09,R1		:CLEAR MSET
	JBS	MLOOP7			:
					:
:	.......................................................................
:	THE TOP 15 AR SORTED, REGISTER SETS ALREADY USED ARE RECORDED. NOW
:	ASSIGN UNUSED SETS TO ANY NEW ENTRIES
:	.......................................................................
					:
MLOOP8	LCS	R1,1			:INVERT THE BITS
	XH	R1,MARRY		:AND IF STILL NEGATIVE
	JLR	R0			:NO-ONE IS ASSIGNED "0"
					:
	STH	R1,MARRY		:1=> AVAILABLE
	LR	R2,R3			:SEARCH LIST
					:
MLOOP9	L	R2,0A,R2		:NEXT LIST ENTRY
	JER	R0			:EXIT IF END FOUND
					:
	LB	R3,9,R2			:IS ONE ALREADY ASSIGNED
	JNBS	MLOOP9			:GOTO NEXT IF ASSIGNED
					:
	LHL	R3,MARRY		:
	NH	R3,BDMSET		:TAKE BAD MAC SET OUT OF SERVICE
	JFFOH	R3,MLOOPA		:
	JR	R0			:EXIT IF 16 FOUND
					:
:	.......................................................................
:	AN AVAILABLE MAC SET IS FOUND
:	.......................................................................
					:
MLOOPA	RBT	R4,MARRY		:TAG AS USED
	STB	R4,9,R2			:RECORD FOR USER
	LR	R13,R2			:
	LM	R14,UBFLASH+MACTRN+4	:300,CNT
	STH	R4,35C			:SELECT HW MAC SET
	COPY	R13,R15			:LOAD UP MAC SET
	J	MLOOP9			:CONTINUE
 ei    (MULMAC)				:
					:
 if	MXP				:
					:
	SUBTTL	MXP KDIO AREA

	LO	XPI

:	.......................................................................
:	KDOS - KDIO OUTPUT MESSAGE START
:	  R0 - MESSAGE TYPE (TYPE\LENGTH)
:	  R4 - Link register
:	.......................................................................
					:
KDOS	LH	R15,KREX+KFIL,,		:GET FILL PTR
	LH	R3,KREX+KEMP,,		:GET EMPTY PTR
	SR	R3,R15			:CALC ROOM LEFT
	JGFS	KDOS10			:
	AHI	R3,KREXL		:ADJUST FOR WRAP
KDOS10	SIS	R3,4			:
	LBR	R2,R0			:ISOLATE MSG LENGTH
	CR	R3,R2			:SEE IF IT WILL FIT
	JGEFS	KDOH			:BR IF IT WILL
	S.HLTF(1865)			:TOO MUCH KDIO OUTPUT CRASH
					:
:	.......................................................................
:	KDOH - KDIO OUTPUT A HALFWORD
:	  R0 - HALFWORD TO OUTPUT
:	  R4 - R11
:	.......................................................................
					:
KDOH	STH	R0,KREX+KDAT+KREXL,R15,	:PUT HALFWORD IN RING
	AIS	R15,2			:
	JLR	R4			:
	LHI	R15,-KREXL		:WRAP
	JR	R4			:
					:
:	.......................................................................
:	KDOW - KDIO OUTPUT A FULLWORD
:	  R0 - WORD TO OUTPUT
:	  R4 - R11
:	.......................................................................
					:
KDOW	ST	R0,KREX+KDAT+KREXL,R15,	:PUT WORD IN RING
	AIS	R15,4			:
	JLR	R4			:
	LHI	R15,-KREXL		:WRAP
	JR	R4			:
					:
:	.......................................................................
:	KDOM - KDIO OUTPUT A MESSAGE
:	  R2 - ADDR OF MESSAGE, 1ST HALFWORD CONTAINS TYPE/LENGTH
:	  R5 - R11
:	.......................................................................
					:
KDOM	LH	R0,0,R2			:GET MSG TYPE/LENGTH
	LBR	R1,R0			:ISOLATE LENGTH
	JAL	R4,KDOS			:CHECK FOR ROOM & OUTPUT
KDOM10	SIS	R1,1			:
	JLFS	KDOM20			:BR IF DONE
	AIS	R2,2			:
	LH	R0,0,R2			:
	JAL	R4,KDOH			:OUTPUT A HALFWORD OF MSG
	JBS	KDOM10			:
KDOM20	LR	R4,R5			:SET UP RTRN REG
					:
:	.......................................................................
:	KDOE - KDIO OUTPUT MESSAGE END
:	  R4 - R11
:	.......................................................................
					:
KDOE	AIS	R15,3			:NEXT FULLWORD BOUNDARY
	NHI	R15,-4			:
	JLFS	KDOE10			:
	SHI	R15,KREXL		:WRAP
KDOE10	STH	R15,KREX+KFIL,,		:SAVE NEW FILL POINTER
	JR	R4			:
					:
:	.......................................................................
:	KDI - PROCESS KDIO INPUT RING
:	.......................................................................
					:
KDI01					:save last time kdi was executed and
	l	r14,fastc		:max interval
	lr	r13,r14			:
	s	r14,kditim		:
	st	r13,kditim		:
	c	r14,kdimax		:
	jlefs	kdi			:
	st	r14,kdimax		:
kdi					:
	LH	R14,KRXE+KEMP,,		:GET EMPTY PTR
	CLH	R14,KRXE+KFIL,,		:SEE IF ANYTHING IN RING
	JER	R9			:RTRN IF NOT
	LHL	R1,KRXE+KDAT+KRXEL,R14,	:GET A MSG TYPE
	AIS	R14,2			:
	LBR	R13,R1			:ISOLATE LENGTH
	EXBR	R1,R1			:
	LBR	R1,R1			:ISOLATE MSG TYPE
	SLLS	R1,2			:
	CLHI	R1,KDMAX		:SEE IF TOO LARGE
	JL	KDIFAN,R1		:BR TO PROCESS MSG IF OKAY
KDIBAD	S.HLTF(1866)			:BAD KDIO MSG FROM XPI CRASH
					:
KDIFAN	J	KDIBAD			:0 - INVALID
	J	KDIKIK			:1 - WATCHDOG KICK
	J	KDICRA			:2 - CRASH SLOT
	J	KDIGMT			:3 - GMT FROM SUP
	J	KDIINF			:4 - SLOT STATUS RETURN
	J	KDIINF			:5 - CHAR COUNTERS RETURN
	J	KDIINF			:6 - PORT DESTINATION RETURN
	J	KDIINF			:7 - PORT BUFFER USAGE RETURN
	J	KDIBIO			:8 - CONNECT BIO ACK
	J	KDILAN			:9 - LAN STATUS CHANGE
	if	ENHMXP			: version 3.00 of MXP-XPI
	J	KDII30			:A - DISP EXECUTION COUNT RETURN
	J	KDITHW			:B - DISPATCHER PROCESSED DSK/RSR MSG
	ei	:ENHMXP
KDMAX	EQ	.-KDIFAN		:MAX MSG TYPE

:	1 - WATCHDOG KICK

KDIKIK	LHI	R0,XPITMO		:RESET XPI WATCHDOG TIMER
	ST	R0,XPITMR
	JAL	R4,KDIE
	J	KDI

:	2 - SLOT CRASH REQUEST

KDICRA	JAL	R4,KDIH			:CRASH A SLOT
	LR	R5,R0			:SAVE SLOT NMBR
	AR	R5,R5
	JAL	R4,KDIE
	L	R1,SLIST,R5,R5		:PNT TO USER BLOCK
	KRCODE(0,5,3)
	JAL	R11,KRASH,,		:DISPATCHER CRASH
 if	SPAM
 if	SPMTRC
	LHI	R10,11			:SPAM TRACE ROUTINE ID
 ei	(SPMTRC)
	LR	R1,R8
	JAL	R9,ENTIM
 ei	(SPAM)
	J	MAIN,,

:	3 - GMT FROM SUPERVISOR

KDIGMT	JAL	R4,KDIH			:SKIP A HW
	JAL	R4,KDIH			:GET THE TIME
	STH	R0,GMT
	JAL	R4,KDIH			:GET THE TIME (LOWER HALFWORD)
	STH	R0,GMT+2		:SAVE TIME
	LH	R4,TAKTIM		:SEE IF TAKEOVER TIME SET
	JGEFS	KDIG10
	ST	R0,TAKTIM		:UPDATE TAKEOVER TIME
KDIG10	JAL	R4,KDIE
	J	KDI

:	4,5,6,7 - INFORMATION RETURN

KDIINF	JAL	R4,KDIH			:GET KEY
	AI	R0,UBLOKS		:GET REQUESTING USER BLOCK ADDR
	LR	R5,R0
	JAL	R4,KDIH			:GET SLOT STATUS
	LHR	R0,R0
	JGE	KDII90			:NON-SKIP RTRN IF SLOT DOWN
	LIS	R0,4
	AM	R0,RPSW+4,R5		:SET FOR RTRN+4
	J	KDIRTR-4*4,R1		:FAN OUT FOR INFO RTRN MSGS

KDIRTR	J	KDII90			:4 - SLOT STATUS ONLY
	J	KDII10			:5 - CHAR COUNTS
	J	KDII20			:6 - PORT DESTINATION
	J	KDII20			:7 - PORT BUFFER USAGE

 if	ENHMXP				:if new char word resp in vers 3.00
KDII10	JAL	R4,KDIH
	STH	R0,RREG,R5		:PLACE IN UPPER HALF WORD OF R0
	JAL	R4,KDIH
	STH	R0,RREG+2,R5		:PLACE IN LOWER HALFWORD OF R0
	JAL	R4,KDIH
	STH	R0,RREG+4,R5		:PLACE IN UPPER HALFWORD OF R1
	JAL	R4,KDIH
	STH	R0,RREG+6,R5		:PLACE IN LOWER HALFWORD OF R1
	J	KDII90
 else
KDII10	JAL	R4,KDIH			:GET CHAR COUNTS
	STH	R0,RREG,R5
	JAL	R4,KDIH
	STH	R0,RREG+2,R5
	J	KDII90
 ei	(ENHMXP)

KDII20	JAL	R4,KDIH			:GET PORT
	LHR	R0,R0
	JL	KDII90			:BR IF PORT UNASSIGNED
	JAL	R4,KDIH			:GET 1ST HW BACK
	STH	R0,RREG,R5
	JAL	R4,KDIH			:GET 2ND HW BACK
	STH	R0,RREG+2,R5
	LIS	R0,4
	AM	R0,RPSW+4,R5		:SET FOR RTRN+8
	J	KDII90

	if	ENHMXP			:version 3.00 of MXP-XPI

KDII30	EQ	.
	JAL	R4,KDIH			:FETCH KEY
	AI	R0,UBLOKS		:GET REQUESTING USER BLOCK ADDRESS
	LR	R5,R0			:USER BLOCK INDEX TO R5
	JAL	R4,KDIH			:GET 1ST HALF OF DISP COUNT
	STH	R0,RREG,R5		:PLACE IN UPPER HALF OF R0
	JAL	R4,KDIH			:GET 2ND HALF OF DISP COUNT
	STH	R0,RREG+2,R5		:PLACE IN LWER HALF OF R0

	ei	:ENHMXP

KDII90	JAL	R4,KDIE			:END INPUT MSG
	LHL	R0,WFLAG,R5		:TURN OFF XPI WAIT FLAG
	NHI	R0,@XPIWF
	STH	R0,WFLAG,R5
	JR	R9			:RETURN TO SCHEDULAR DISPATCHER SERVICE

:	8 - CONNECT BIO ACKNOWLEDGMENT

KDIBIO	JAL	R4,KDIH			:GET KEY
	AI	R0,UBLOKS		:GET REQUESTING USER BLOCK ADDR
	LR	R5,R0
	JAL	R4,KDIH			:GET RETURN CODE
	LR	R0,R0			:TEST CODE
	JN	KDII90			:NON-SKIP RTRN IF BAD
	LIS	R0,4
	AM	R0,RPSW+4,R5		:SET FOR SKIP RTRN
	J	KDII90			:GO RTRN & UNFREEZE

:	9 - LAN STATUS CHANGE

KDILAN	JAL	R4,KDIH			:GET NEW STATUS
	STH	R0,LANSTS,,		:SAVE IT AWAY
	JAL	R4,KDIE
	J	KDI

	if	ENHMXP			:version 3.00 of MXP-XPI

:	B - DISPATCHER SAW AND PROCESSED NEW RESTART/DISCONNECT MSG

KDITHW	JAL	R4,KDIH			:GET SLOT NUMBER
	LR	R5,R0			:SAVE IT
	AR	R5,R5			:MAKE INDEX
	JAL	R4,KDIE			:END INPUT MESSAGE
	L	R1,SLIST,R5,R5		:GET SLOT USER BLOCK
	LHL	R4,WFLAG,R1
	NHI	R4,@XPIWF		:TURN OFF WAIT FLAG
	STH	R4,WFLAG,R1		:SO WE CAN RUN AGAIN
	J	KDI			:BACK FOR MORE

	ei	:ENHMXP

: KDIH - KDIO INPUT HALFWORD
:	R0 - RETURNED HALFWORD
:	R4 - R11

KDIH	LHL	R0,KRXE+KDAT+KRXEL,R14,	:GET HALFWORD FROM RING
	SIS	R13,1
	AIS	R14,2
	JLR	R4
	LHI	R14,-KRXEL		:WRAP
	JR	R4

: KDIW - KDIO INPUT FULLWORD
:	R0 - RETURNED WORD
:	R4 - R11

KDIW	L	R0,KRXE+KDAT+KRXEL,R14,	:GET WORD FROM RING
	SIS	R13,2
	AIS	R14,4
	JLR	R4
	LHI	R14,-KRXEL		:WRAP
	JR	R4

: KDIE - KDIO INPUT MESSAGE END
:	R4 - R11

KDIE	AR	R14,R13			:FLUSH PAST REST OF MESSAGE
	AR	R14,R13
	AIS	R14,3			:NEXT FULLWORD BOUNDARY
	NHI	R14,-4
	JLFS	KDIE10
	SHI	R14,KRXEL		:WRAP
KDIE10	STH	R14,KRXE+KEMP,,		:SAVE NEW EMPTY PTR
	JR	R4

	FO	XPI
 ei	:(MXP)
	SUBTTL	CONNECT A SLOT

: DEFINE MACROES
:	KNCT PARAMETER MACRO
:	NA	1>>NULL ALLOWED...0 SHOULD STAY 0
:	SOR	CTA SOURCE
:	DEST	DESTINATION WORD TABLE
:	BB	0=STORE IN KDIO IF MXP, DEST IF NOT
:		1=STORE IN BOTH IF MXP, DEST IF NOT

KPARAM	MACRO(NA,SOR,DEST,BB)[
	L	R0,SOR,R11
 if	NA
	JEFS	.+0A
 ei
	JAL	R9,TRASL
	 J	0,R10
 if	BB!(1-MXP)
	ST	R0,DEST,R13,
 ei
 if	MXP
	EXHR	R0,R0
	JAL	R4,KDOH
	EXHR	R0,R0
	JAL	R4,KDOH
 ei
]

:	.....................................................................
:	MACRO TO STORE A FULLWORD IN DESTINATION AND/OR KDIO RING
:	.....................................................................
					:
KSTW	MACRO(DEST,BB)[
   if	BB!(1-MXP)
	ST	R0,DEST,R13,
   ei
   if	MXP
	EXHR	R0,R0
	JAL	R4,KDOH
	EXHR	R0,R0
	JAL	R4,KDOH
   ei
]

:	.....................................................................
:	MACRO TO STORE A HALFWORD IN DESTINATION AND/OR KDIO RING
:	.....................................................................
					:
KSTH	MACRO(DEST,BB)[
   if	BB!(1-MXP)
	STH	R0,DEST,R13,
   ei
   if	MXP
	JAL	R4,KDOH
   ei
]

:	.......................................................................
:	CONNECT A JOB
:	ENTER, LINK ON R10
:	EXPECTS R12 TO BE BACKGROUND BLOCK FOR SLOT
:		R14 = DDT BLOCK FOR SLOT
:		R13 = 4*SLOT#
:	SKIP-RETURN IF OKAY, NON-SKIP RETURN IF BAD MAC
:	NOTE:	we do this here--rather than using a Dispatcher Slave--to
:		insure that we can't timeout while executing in Dispatcher.
:	.......................................................................
					:
K.KNCT	LR	R8,R14			: set up base-register for DDT
	L	R11,SBASE,R14		: find start of Slot code
	ST	R11,CSADDR,R11		: let USER find self
	L	R0,IENTRY,R11		: set up initial PSD
	ST	R0,INIPSW+4,R12		:
	L	R1,REST,R12		: skip if Restart-address is defined
	JNFS	KNCT0A			:
	ST	R0,RPSW+4,R12		: else set Start-PSD
KNCT0A	HS	0			:
   if	FSYS				:
	LHL	R0,DD.MSK,R11		: Segment-save mask
	JNFS	KNCT0B			:
	LCS	R0,2			: set up default value
KNCT0B	STH	R0,FSSEG,R14		: put into DDT Block
   ei  (FSYS)				:
	L	R0,STATUS,R11		: set up Display
	JAL	R9,TRASL		:
	J	0,R10			:
	LO	FLASH			:
	ST	R0,DISTBL,R13,		: FLASHER drives Display
	FO	FLASH			:
	LR	R0,R13			:
	SRHLS	R0,2			: get Slot-number
	STH	R0,SLOTNO,R11		: place it where slot can find it
  if	NSLOT!MXP			:
   if	MXP				:
	LHI	R0,KDMCON		: tell XPI to connect Slot
	JAL	R4,KDOS			:
	LHL	R0,SLOTNO,R11		: slot-number
	JAL	R4,KDOH			:
   ei  (MXP)				:
	L	R0,CNTRL,R11		: nake a copy of the Control-bits
	NHI	R0,@X.AUX.		: clear AUX-circuit flag
	L	R4,RLICEN,R12		: see if AUX-circuits allowed
	JGEFS	KNCT0D			: skip if not
	AIS	R0,X.AUX.		: indicate AUX-circuits allowed
KNCT0D	HS				:
   if	MXP&.GT.(MACHNM,0)		:
	LR	R13,R13			:
	JNFS	KNCT0C			:
	OI	R0,80000000		: indicate this is Node code to XPI
   ei  (  )				:
KNCT0C	KSTW(I.CTL,0)			:
   if	EE.BP				:
	THI	R0,X.UBA.		: see if End-to-end Back-pressure enabled
	JE	KNCT1			: don't bother locating pointers
	KPARAM(1,IBKPNT,I.IBKB,0)	: locate Input Back-pressure bits
	KPARAM(1,OBKPNT,I.OBKB,0)	: locate Output Back-pressure bits
	JFS	KNCT1A			:
KNCT1
   ei  (EE.BP)				:
	LIS	R0,0			: will zero Back-pressure pointers
	KSTW(I.IBKB,0)			: slot's Input-array zeroed
	KSTW(I.OBKB,0)			: slot's Output-array zeroed
					:
KNCT1A	KPARAM(0,IRPNT,I.IRNG,0)	: locate Input-ring
	LR	R1,R0			: set up both cursors
	LIS	R0,0			:
	ST	R0,0,R1			:
	KPARAM(0,ORPNT,I.ORNG,0)	: same game for Output ring
	LR	R1,R0			: set up cursor...
	LIS	R0,0			:
	STH	R0,2,R1			: empty only...may already have stuff
	L	R0,IMAXSZ,R11		: get both MAX ring-sizes
					:
	KSTW(I.IRSZ,0)			: save them away for future use
					:
	KPARAM(1,PCBPNT,I.PCTB,0)	: locate Project-code table
	KPARAM(0,HTBLPT,I.HTBL,1)	: set Host-table pointer
	KPARAM(0,PTBLPT,I.UTBL,1)	: set port-table pointer
	LR	R2,R0			: save copy of this
	LHL	R0,MAXPRT,R11		:
	KSTH(I.PSIZ,1)			: save number of ports
	LR	R3,R0			: keep second copy too
	LHL	R0,MAXHST,R11		:
	KSTH(I.HSIZ,1)			: save number of hosts
	LR	R4,R0			: save maxhst value
	lr	r5,r0			: working copy of maxhst
	l	r0,ptblpt,r11		: get port table ptr(rel)
	ar	r5,r5			: for halfword indexing
	ar	r0,r5			: highest relative address
	jal	r9,trasl		: get maximum physical address
	j	0,r10			: mac'd out
KNCT2	SIS	R4,1			: for all hosts...
	JLFS	KNCT3			: skip if done
	LHI	R0,0C000		: else set another host gone
	OH	R0,0,R2			:
	STH	R0,0,R2			:
	AIS	R2,2			: advance pointer to next host
	JBS	KNCT2			: and repeat for it
					:
KNCT3	KPARAM(0,TTBLPT,I.PTBL,1)	: get address of Permuter-table
	LR	R1,R0			: copy to use as pointer
	LIS	R0,0			: set up rest of Permuter-table
   if	1-MXP				:
	ST	R0,I.QUE,R13,		: set queue empty
	LHL	R2,I.CMD0,R13,		: look up Command-path number
	STH	R2,0,R1			: set up port0
   ei  (1-MXP)				:
					:
:	.......................................................................
:	check to see if we have enough space allocated in the slot to zero
:	out the permuter table
:	.......................................................................
					:
	lr	r2,r1			: save p-table pointer (physical)
	l	r0,ttblpt,r11		: get p-table pointer (relative)
	lr	r1,r3			: get MAXPRT
	ar	r1,r1			: double for indexing
	ar	r0,r1			: get highest address
	jal	r9,trasl		: get physical address
	j	0,r10			: mac'd out
	lr	r1,r2			: restore pointer
	lis	r0,0			: for zeroing out p-table entry
KNCT4A	AIS	R1,2			: advance pointer
	SIS	R3,1			: count another one gone
	JLFS	KNCT4B			: skip when done
	STH	R0,0,R1			: else zero out another one
	JBS	KNCT4A			: and repeat

KNCT4B
  if	MXP
	JAL	R4,KDOE			: end of Connect-message
  ei
 ei	:(NSLOT!MXP)
	J	4,R10			: and return

  if	NSLOT!MXP			:
:	.......................................................................
:	ENABLE A SLOT
:	R1 = POINTER TO USER BLOCK, LINK ON "LINK"
:	R4 = USERFLAGS
:	.......................................................................
					:
D.ENAB	LHL	R5,SLOT,R1		:GET SLOT #
   if	MXP				:
	LR	R6,R4			:SAVE R4
    IF	ENHMXP				:VERSION 3.00 OF MXP-XPI
	LHI	R0,KDMRSR		:SEND SLOT RESTART MSG TO XPI
    ELSE				:VERSION 2.3,2.4 AND EARLIER OF MXP-XPI
	LHI	R0,KDMRST		:
    EI (ENHMXP)				:
	JAL	R4,KDOS			:
	LR	R0,R5			:SLOT NMBR
	JAL	R4,KDOH			:
	JAL	R4,KDOE			:
	LR	R4,R6			:
	JR	R11			:
   else					:
	SLHLS	R5,2			:MAKE A WORD INDEX
	LIS	R6,0			:
	SBT	R6,I.CTL,R5,		:ENABLE DISPATCHER FOR THIS SLOT
	JER	R11			:IF ALREADY DISABLED, JUST RETURN
	SRHLS	R5,2			:ELSE HANG FIRST
	STH	R5,DHANG		:
	STH	R5,DSLOT		:INSURE SLOT WILL RUN
	LHI	R11,62F0		:Re-enable the interrupts 
	EPSR	R6,R11			:
	J	REPOP			:EXIT UNTIL SLOT HUNG, THEN TRY AGAIN
   ei  (MXP)				:
  ei   (NSLTO!MXP)			:SPAM FIX 9/23/86
					:
:	.......................................................................
:	SUBMIT DIAGNOSTIC MESSAGE FOR DISPATCHER
:	R5  = Link Register
:	R11 = R_TYPE
:	R12 = DATA1
:	R13 = DATA2
:	.......................................................................
					:
PRODID	EQ	37			:ISI2 PRODUCT ID HW 2 (LOW)
					:
DIAG	HS				:
 if	MXP				:
	LHI	R0,KDMSUP		:SEND MSG TO SUPERVISOR VIA XPI
	JAL	R4,KDOS			:
	LR	R0,R11			:SEND ARGS TO XPI
	JAL	R4,KDOH			:
	LR	R0,R12			:
	JAL	R4,KDOH			:
	LR	R0,R13			:
	JAL	R4,KDOH			:
	JAL	R4,KDOE			:END XPI MESSAGE
 else					:
   if	NSLOT				:
	GL	SENDS0,SENDH,TERM	:
					:
	LIS	R2,$A 10		: 9-byte message
	JAL	R4,SENDS0,,		: to slot 0 command-path
	LHI	R0,0300+0FF		: message-type DIagnostic (Slot FF)
					: Node code sends it as 63
	JAL	R4,SENDH,,		:
	LR	R0,R13			: HW4
	JAL	R4,SENDH,,		:
	LR	R0,R11			: build HW 3 (high) RTYPE
	EXBR	R0,R0			:
	STBR	R12,R0			: combine low and high of HW 3
	JAL	R4,SENDH,,		:
	LHI	R0,PRODID^10		: get PRODID for HW2 (low)
	JAL	R4,SENDH,,		: and send
	JAL	R4,TERM,,		: terminate it
    ei (NSLOT)				:
 ei    (MXP)				:
	JR	R5			: return
					:
:	.......................................................................
:	TRANSLATE USER ADDRESS TO PHYSICAL ADDRESS
:	Note: 1. USER ADDRESS IN R0
:	      2. TRANSLATED ADDRESS RETURNS IN R0 - ASSUMES VALID ACCESS
:		 NON-SKIP RETURN IF BAD ADDRESS
:	      3. USES R1
:	.......................................................................
					:
TRASL	EXHR	R1,R0			:ADDR TO TRANSLATE
	NHI	R1,MMASKS		:ISOLATE "SN"
	SRLS	R1,MSHFTX		:RIGHT JUSTIFY IT
	CLHI	R1,ISEG			:CHECK FOR SEGMENT 15d
	JNFS	TRASL1			:NO...SKIP
	LI	R1,CONMAC		:YES...SET SEGMENT 15 SPECIAL MAC REG
	JFS	TRASL2			:AND SKIP
TRASL1	SLLS	R1,2			:INDEX WORD TABLE
	L	R1,MPROT,R1,R8		:GET MAC REGISTER
	JER	R9			:IF 0 THEN SEG IS NOT ACCESSIBLE
TRASL2	NI	R0,SEGSIZ-1		:REMOVE "SN" FROM ADDR
	NI	R1,MMASKR		:ISOLATE "SRF"
	SRLS	R1,MSHFTA		:MAKE IT AN ADDRESS
	AR	R0,R1			:RELOCATE ADDR
	CL	R0,MEMTOP		:Check physical memory address range?
	JGER	R9			:Error return ... if out of range
	J	4,R9			:
					:
   IF	KIOSRC

	SUBTTL SIO RING INITIALIZATION ROUTINES

:	.......................................................................
:
:	Inialize SIO Motherboard
:
:	R3  - Start Descriptor
:	R4  - Descriptor #
:	R5  - Device #
:	R13 - Link register
:	R1,R2,R6,R7,R8,R9,R12 destoried
:
:	Note: Preserves R10,R11 when initilizing all SIO motherboards
:
:	.......................................................................
					:
INITBD	JAL	R7,KILMB		:KILL MOTHERBOARD
	JAL	R7,INKIO		:INITIALIZE & ACTIVATE KIO RINGS
	JAL	R7,WAKMB		:WAKE MOTHERBOARD
	JR	R13			:RETURN
					:
:	.......................................................................
:	Kill motherboard
:	R5 - Device number
:	R7 - Link register
:	R1, R9 destoried
:	.......................................................................
					:
KILMB	LIS	R9,0			:
	LBR	R1,R5			:COPY DEVICE #
	AHI	R1,3000			:ADD COMMAND 30 (DIE)
	WDR	R1,R9			:KIO SIO CARD
	JR	R7			:RETURN
					:
:	.......................................................................
:
:	Initialize and Activate KIO rings
:
:	R3 - Start descriptor
:	R4 - Descriptors #
:	R5 - Device #
:	R7 - Link register
:	R9,R1,R2,R3,R6,R8,R12 destoried
:
:	.......................................................................
					:
INKIO	SLLS	R3,4			:INDEX INTO QUADWORD TABLE
	LA	R1,MBLSTR,R3,		:STARTING QUADWORD ADDRESS
	LIS	R9,0			:INDEX
	LIS	R6,0			:ZERO TO CLEAR
	JFS	INKIOB			:
					:
:	.......................................................................
:	Note: (carry is reset if first operand is less than second)
:	.......................................................................
					:
INKIOA	CLR	R9,R4			:COMPARE
	JCR	R7			:EXIT
	AHI	R1,10			:NEXT QUAD WORD
					:
:	.......................................................................
:	Clear input ring
:	.......................................................................
					:
INKIOB  L	R2,SDIEND,R1		:END ADDR FOR INPUT RING
	SIS	R2,4			:SUBTRACT CURSORS
	LR	R8,R2			:CUSSOR ADDRESS
	SH	R2,SDISIZ,R1		:BEGINNING ADDR. FOR INPUT RING
					:
:	.......................................................................
:	Note: (carry is set if first operand is greater than second)
:	.......................................................................
					:
INKIOC	CLR	R8,R2			:STILL INPUT RING ADDRESS?
	JNCFS	INKIOD			:INPUT RING CLEAR?
	STH	R6,0,R2			:ZERO OUT HALFWORD
	AIS	R2,2			:INCREMENT HALF WORD
	JBS	INKIOC			:
:	.......................................................................
:	Initialize cursors
:	.......................................................................
					:
INKIOD	LIS	R2,0			:
	SH	R2,SDISIZ,R1		:NEG INPUT RING SIZE
	STH	R2,0,R8			:FILL CURSOR
	STH	R2,2,R8			:EMPTY CURSOR
					:
:	.......................................................................
:	clear output ring
:	.......................................................................
					:
	L	R2,SDOEND,R1		:END ADDR FOR OUTPUT RING
	SIS	R2,4			:SUBTRACT CURSORS
	LR	R8,R2			:CUSSOR ADDRESS
	SH	R2,SDOSIZ,R1		:BEGINNING ADDR. FOR INPUT RING
					:
:	.......................................................................
:	Note: (carry is set if first operand is greater than second)
:	.......................................................................
					:
INKIOE	CLR	R8,R2			:STILL INPUT RING ADDRESS?
	JNCFS	INKIOF			:INPUT RING CLEAR?
	STH	R6,0,R2			:ZERO OUT HALFWORD
	AIS	R2,2			:INCREMENT HALF WORD
	JBS	INKIOE			:
					:
:	.......................................................................
:	initialize cursors
:	.......................................................................
					:
INKIOF	LIS	R2,0			:
	SH	R2,SDOSIZ,R1		:NEG INPUT RING SIZE
	STH	R2,0,R8			:FILL CURSOR
	STH	R2,2,R8			:EMPTY CURSOR
					:
:	.......................................................................
:	activate kio rings
:	.......................................................................
					:
	LHI	R3,$A 40		:COUNTER
INKIOG	SIS	R3,1			:DECRMENT COUNTER
	JGEFS	INKIOH			:
	S.HLTF(2060)			:SIO RING BOARD UNAVAILABLE
INKIOH  SSR	R5,R12			:CHECK CONDITION OF MUX INTERFACE
	JNBS	INKIOG 			:MUX INTERFACE BUSY
					:
	LH	R3,SDRDEV,R1		:SIO DEVICE ADDR PLUS RING NUMBER
	LR	R2,R1			:COPY ADDRESS OF QUAD WORD
	SRLS	R2,4			:QUAD ADDR OF QUAD WORD
	WDR	R3,R2			:ACTIVATE THIS RING
					:
:	.......................................................................
:	Process another descriptor
:	.......................................................................
					:
	AIS	R9,1			:INCREMENT FOR ANOTHER DESCRIPTOR
	J	INKIOA			:
					:
:	.......................................................................
:	Wakeup Motherboard
:	R5 - Device number
:	R7 - Link register
:	R9,R1,R2,R3,R6 destoried
:	.......................................................................
					:
WAKMB	LA	R2,SIOINT		:ADDR. OF SIO INTERRUPT ROUTINE
	LBR	R1,R5			:COPY DEVICE NUMBER
	SLLS	R1,1			:
	STH	R2,IMIVEC,R1		:STORE IN INTERRUPT VECTOR
	LIS	R9,0			:
	LHI	R3,$A 40		:COUNTER
WAKMB1	SIS	R3,1			:DECRMENT COUNTER
	JGEFS	WAKMB2
	S.HLTF(2060)			:SIO RING BOARD UNAVIALABLE
WAKMB2  SSR	R5,R6			:CHECK CONDITION OF MUX INTERFACE
	JNBS	WAKMB1			:MUX INTERFACE BUSY
					:
:	.......................................................................
:	Set the line condition to down	
:	.......................................................................
					:
	LHI	R9,$A 27		:
	RBT	R9,MLUTBL,R11,		:ZERO LINE AS DOWN
	AHI	R5,3100			:SIO DEV ADDR AND COMMAND 31 (AWAKE)
	WDR	R5,R9			:WAKE SIO CARD
	JR	R7			:RETURN
					:
   EI  (KIOSRC)				:
					:
					:
					:
	SUBTTL	K E R N E L   D A T A   A R E A
					:
	FO	KCAREA			:
					:
F1	WS	0			:SVC ARRAY...ORDER MUST BE MAINTAINED!!!
F1SVC	HS	1			:SAVE SVC R11 HERE
F1SVCL	HS	1			:SAVE LOW SVC R11 HERE
F1ARG	HS	1			:SAVE SVC ARGUMENT HERE
F1ARGL	HS	1			:SAVE SVC LOW ARGUMENT HERE
F1PS1	WS	1			:SAVE SVC PSW1 HERE
F1PS2	WS	1			:SAVE SVC PSW2 HERE
F1R0	WS	1			:SAVE SVC USER REGISTER 0 HERE
F1R1	WS	1			:SAVE SVC USER REGISTER 1 HERE
LFREE	WC	UBSYS			:POINTER TO FREE LIST
XLFREE	WC	UBSYS			:BACKUP POINTER TO FREE LIST
QUASI	WC	0			:PTR TO QUASI-JOB LIST
RUN	WS	1			:PTR TO RUN LIST
USER	WS	1			:POINTER TO CURRENTLY ACTIVE USER'S USER BLOCK
NXTFU	WS	1			:PTR TO NEXT FOREGROUND USER'S USER BLOCK
SML	WS	1			:PTR TO START OF JOB LIST ORDERED BY CONTEXT RATE
MARRY	WS	1			:MAC SET IN USE
BDMSET	HC	-1			:ARRAY TO INDICATE BAD MAC SETS
KSAVE	WS	1			:INTERRUPTS SAVE R1 HERE

   IF	MACTRC				:IF MAC TRACE SPECIFIED
					:
:	.......................................................................
:       TRACE CONTROL AND DATA
:	.......................................................................
					:
TRACMD  HC      0                       :TRACE COMMAND
TRONOF  HC      0                       :TRACE ON/OFF, 0=STOPPED,NZ=RUNNING
TRADR1  WC      0                       :BEGINNING TRACE ADDRESS
TRADR2  WC      0                       :ENDING TRACE ADDRESS
TERMCD  HC      0                       :TRACE ROUTINE TERMINATION CODE
DATACD  HC      0                       :DATA COMPARE CODE
PATERN  HC      0                       :DATA COMPARE VALUE
TRCSET  HC      0                       :INTERRUPTED REGISTER SET
TRPLOC  WS      80                      :PHYSICAL ADDRESS TRAPPED
TRPDTA  HC      0                       :CONTENT OF TRAPPED ADDRESS
ILLTRC  HC      0                       :NON-ZERO IF ILLEGAL TRACE PROCEDURE
COUNT   WC      0                       :COUNT OF TRACE INTERRUPTS
TRACE1  WS      $A16			:
TRACE2  WS      $A14			:
TRACE3  WC      0                       :INTERRUPT REGISTER 'E' OF RSET 0
        WC      0                       :INTERRUPT REGISTER 'F' OF RSET 0
TRACED  EQ      .-TRCSET-2		:
TRACEE  EQ      .-TRACMD-2		:
   EI  (MACTRC)				:
					:
KLINK	WS	1			:R11 SAVE FOR SEXIT & KRASH
ENDUSER	WS	1			:PTR TO CHECK IF ALL USERS IN WAIT
RUSER	WS	1			:CURRENT RUN-LIST USER POINTER
DUSER	WS	1			:NEXT USER TO BE KRASHED BY DUMP...
MACH1	HS	2			:USED TO SAVE A REG BY MACHINE MALFCT INT
R1SAV	HS	2			:USED TO SAVE A REG BY MACHINE MALFCT INT
FLASHN	HS	1			:HALF-WORD TIME TO RUN FLASHER FOREGROUND NEXT
   if	0				:
kiowhn	hc	0			:half-word time to run kio
   ei					:
kditim	hc	0,0			:
kdimax	hc	0,0			: ***etm
FOREGT	HS	1			:HALF-WORD TIME TO RUN ALL OTHER FOREGROUNDS NEXT
BGTIME	HC	0			:START TIME OF LAST USER SCHEDULED
DUMMY	HC	0			:FLAG FOR LOGON BLOCK IN USE IF NEGATIVE
SLICSL	WC	SLICLO,SLICHI		:INITIAL SUSPEND LIST
SLICTM	WS	2			:TEMP AREA
CPSADR	WC	-1			:POINTER TO NODE CODE CPS DATA
CPFAIL  HC      0                       :***FOR OLD NODE CODE W/O SVC 53
    if	CPUOVL				:
FGLD	HC	0			:FLAG FOR INST. FG OVERLOAD
FGER	HC	0			:COUNT OF FG OVERLOAD
   ei  (CPUOVL)				:
 if	SUP				:
  if	KIOSRC				:
SUPDIS	WS	1			:SUPERVISOR CONSOLE DISPLAY
  ei   (KIOSRC)				:
 ei    (SUP)				:
 if	SHARE				:
  if	NDISC!MSCDSK			:
DPUNIT	HC	-1			:
DPVBNO	WC	-1			:
DPFLAG	HC	-1			:
					:
:	.......................................................................
:	COMMAND PORTS ACTIVE
:	.......................................................................
					:
DPACT	HC	0,0,0,0,0,0,0,0
					:
:	.......................................................................
:	COMMAND PORTS DETACHED
:	.......................................................................
					:
DPDET	HC	-1,-1,-1,-1,-1,-1,-1,-1
DPUN	RE	NKU+2			:
	HC	-1			:
        ER				:
DPBN	WS	NKU+2			:
DPBX	BS	NKU+2			:
DPLRL	BS	NKU+2			:
  ei   (NDISC!MSCDSK)			:
 ei    (SHARE)				:
					:
  if	SPAM				:
	GL	SPMTBL,SKEDIT,TIMTBL,JOBCNT,IOCSAV,TABEND,IOCHRS,NODCPS
	GL	IDLECT,SKEDRS
   if	ENHMXP				:version 3.00 of MXP-XPI
	GL	DSPCNT			:
   ei  (ENHMXP)				:
SPAREA	EQ	.			:BEGINNING OF ENTIRE SPAM AREA
					:
   if	SUP				:
	WS	0			:FORCE WORD ALIGNMENT
SPMTBL	re	(NSLOT+9)		:SLOT TIME ACCUMULATION COUNTERS
	HS	10			:
	er				:
SLTCNT	re	(NSLOT+9)		:JOB COUNT ACCUMULATION COUNTERS
	HS	10			:
	er				:
IOCHRS	re	(NSLOT+9)		:IO CPS/SLOT ACCUMULATION COUNTERS
	WS	2			:
	er				:
SKEDCT	WC	0			:SCHEDULER ACCUMULATION COUNTER
SKEDRN	WC	0			:SCHEDULER RE-ENTRY COUNTER
IDLCNT	WC	0			:SCHEDULER IDLE COUNTER (MAIN31)
CNTEND	EQ	.-SPMTBL-4		:
					:
   else					:
	WS	0			:FORCE WORD ALIGNMENT
SPMTBL	re	(NSLOT+2)		:SLOT TIME ACCUMULAION COUNTERS
	HS	10			:
	er				:
SLTCNT	re	(NSLOT+2)		:JOB COUNT ACCUMULATION COUNTERS
	HS	10			:
	er				:
IOCHRS	re	(NSLOT+2)		:IO CPS/SLOT ACCUMULATION COUNTERS
	WS	2			:
	er				:
SKEDCT	WC	0			:SCHED ITERATION ACCUMULATION COUNTER
SKEDRN	WC	0			:SCHEDULER RE-ENTRY COUNTER
IDLCNT	WC	0			:SCHEDULER IDLE COUNTER
CNTEND	EQ	.-SPMTBL-4		:
   ei  (SUP)				:
					:
   if	SUP				:
	WS	0			:FORCE WORD ALIGNMENT
TIMTBL	re	(NSLOT+9)		:SLOT TIME ONE MINUTE TALLY STORAGE
	HS	10			:
	er				:
JOBCNT	re	(NSLOT+9)		:JOB COUNT ONE MINUTE TALLY STORAGE
	HS	10			:
	er				:
IOCSAV	re	(NSLOT+9)		:IO SLOT/CPS ACCUMULATION COUNTERS
	WS	2			:
	er				:
SKEDIT	WC	0			:SCHEDULER ONE MINUTE TALLY
SKEDRS	WC	0			:SCHEDULER JOB RE-ENTRY COUNTER (1 MINUTE)
IDLECT	WC	0			:SCHEDULER IDLE COUNTER
TABEND	EQ	.-TIMTBL-4		:
   else					:
	WS	0			:FORCE WORD ALIGNMENT
TIMTBL	re	(NSLOT+2)		:SLOT TIME ONE MINUTE TALLY COUNTERS
	HS	10			:
	er				:
JOBCNT	re	(NSLOT+2)		:JOB COUNT ONE MINUTE TALLY COUNTERS
	HS	10			:
	er				:
IOCSAV	re	(NSLOT+2)		:IO SLOT CPS/SLOT FOR ONE MIN. TALLY
	WS	2			:
	er				:
SKEDIT	WC	0			:SCHEDULER ITERATIONS - ONE MIN. TALLY
SKEDRS	WC	0			:SCHEDULER JOB RE-ENTRY COUNTER (1MINUTE)
IDLECT	WC	0			:SCHEDULER IDLE COUNTER
TABEND	EQ	.-TIMTBL-4		:
   ei  (SUP)				:
					:
	LIST
SPMPTR	EQ	.			:
	WS	0			:FORCE WORD BOUNDARY
CURENT	HC	0,0,0,0			:USER JOB DATA AT START4
ENDATA	HC	0,0,0,0			:ENDING JOB DATA
BEGCNT	WS	1			:START JOB TIME COUNTER
ENDCNT	WS	1			:ENDING JOB TIME COUNTER
MAICNT	WS	1			:'MAIN' ENTRY COUNTER
ADVCLK	WS	1			:FAST CLOCK SAVE AREA
NODCPS	WS	2			:NODE CODE CPS THRUPUT
   if	ENHMXP				:
DSPCNT	WS	1			:DISPAT EXEC COUNT FOR MXP vers 3.00
   ei  (ENHMXP)				:
SLOSAV	WS	1			:SLOWC SAVE AREA
CHKPT	HC	0			:SPAM ERROR INDICATOR
SAVEND	HC	0			:END TIME SAVE
PASCTR	HC	0			:PASS COUNTER
ENAB	HC	0			:SET TO NON-ZERO TO RESTART TRACE
SPRDY	HC	0			:SPAM READY - WAIT FOR INITIALIZE
STARTC	WC	0			:SLOWC TIME OF SYSTEM RESTART
	WS	0			:FORCE WORD BOUNDARY
CNTSIZ	EQ	.-SPMPTR-4		:
					:
   if	SPMTRC				:
TCAREA	EQ	.			:
	WS	0			:FORCE WORD BOUNDARY
POITER	HC	0			:INDEX TO TRCTBL
ENDEX	HC	0			:	"
TRCON	HC	0			:TRACE FLAG
STPTRC	HC	0			:STOP TRACE MANUALLY (IF NON-ZERO)
	HC	0			:UNUSED
TRCNTR	WS	3			:SPAM TRACE COUNTERS SAVE
TRCTBL	HS	$0800			:TABLE FOR DATA AT START4
	WS	0			:FORCE WORD BOUNDARY
TRCSIZ	EQ	.-SPMPTR-4		:
   ei  (SPMTRC)				:
					:
SPSIZE	EQ	.-SPAREA-4		:SIZE OF SPAM & TRACE
  ei   (SPAM)				:
					:
DMAOFF	EQ	0AA			:Offset to DMA Seg. Bit-Map in CTA tbl
DMABIT	HS	1			:Tmp storage for DMA seg. bit array
DMATMP	WS	10			:Tmp storage for DMA relocation use
					:

	SUBTTL	K E R N E L   U S E R   B L O C K S


:	...............................................................
:	SPECIAL USER BLOCK FOR DISPATCHER
:	...............................................................
					:
 if	MULMAC				:
OMCLX	EQ	SML			:HEAD OF THE LIST
 ei    (MULMAC)				:
	GL	UBLOKS			:
UBLOKS	HS	0			:START OF USER BLOCKS
 if	DISPAT				:
	GL	D.STRT			:
UBDISP	UB1(0,0,UBSYS,E.PSW,D.STRT)	:
	MACBLK()			:MAC SEGMENTS (EVERYTHING ACCESSABLE)
	UB2(UBDISP,FBACK,-1,-KQ)	:
	ORG	UBDISP+RBLEN		:EVERYTHING ELSE
 ei    (DISPAT)				:
					:
:	...............................................................
:	SPECIAL USER BLOCK FOR FLASHER
:	...............................................................
					:
   if	KIOSRC				:
UBFLASH	UB1(0,0,UBSYS,E.PSW,FLASH)	:
   else					:
UBFLASH	UB1(0,QFLASH,UBSYS,E.PSW,FLASH)	:
   ei  (KIOSRC)				:
	MACBLK()			:MAC SEGMENTS (EVERYTHING ACCESSABLE)
	UB2(UBFLASH,FBACK,-1,-KQ)	:
	ORG	UBFLASH+RBLEN		:EVERYTHING ELSE
					:
:	...............................................................
:	DUMMY LOGON USER BLOCK
:	...............................................................
					:
LOGBX	UB1(0,0,UBSYS,E.PSW,LOG)	:
	MACBLK()			:(THIS JOB HAS ACCESS TO EVERYTHING)
	UB2(LOGBX,0,-1,-KQ)		:
 if	SHARE				:
  if	NDISC				:
	ORG	LOGBX+LUT		:
	HC	SYSDEV			:
  ei   (NDISC)				:
 ei    (SHARE)				:
	KIOBLK(LOGBX,0,0,-1)		:
					:
:	.......................................................................
:	SYSTEM DDT BLOCK
:	.......................................................................
					:
UBSYS	UB1(UBX0,UBSYS,UBFLASH,E.PSW,DDTBGN)
	MACBLK()
	UB2(UBSYS,FDDT,-1,-KQ)
	KIOBLK(UBSYS,UBX0,L.SYA!L.SYP!L.SYR,0FF,0,1000)
	UBXDDT(UBSYS,E.PSW)		:
					:

	SUBTTL	SLOT DDT BLOCKS

	RA	$A 10			:ALL USER SYMBOLS NAMED W DECIMAL #
					:
:	.......................................................................
:	 Q IS THE NUMBER OF PAGES USED FOR SLOTS ALREADY
:	QQ IS A PRIMITIVE MAC REGISTER
:	Q1 IS THE NUMBER OF PAGES IN 1K
:	Q2 IS THE NUMBER OF PAGES IN A SEGMENT
:	Q3 IS THE NUMBER OF PAGES FOR THIS SLOT
:	Q4 IS THE SLOT NUMBER
:	Q5 is the number of pages used for slots' DMA memory already
:	.......................................................................
					:
Q	EQ	0			:
Q1	EQ	$0400/PAGE		:NUMBER OF PAGES IN 1K
Q2	EQ	SEGSIZ/PAGE		:NUMBER OF PAGES IN A SEGMENT
Q4	EQ	0			:DO ALL SLOTS
Q5	EQ	0			:Number of slot DMA area (pages in 1K)
					:
 if	MSLOT				:
QQQ	EQ	NSLOT-1			:
 else					:
QQQ	EQ	NSLOT			:
 ei    (MSLOT)				:
					:
:	.......................................................................
:	Define the first part of slots' user DDT block
:	.......................................................................
					:
	re	QQQ+1
Q3	EQ	S|Q4|CORE*Q1
   if	$0 Q3-Q2
Q6	EQ	Q2
   else
Q6	EQ	Q3
   ei
QQ	EQ	$0 ((Q6-1)^MSHFTL)!(Q^MSHFTA)!MASK1
UBX|Q4|	UB1(UBX|Q4+1|,UBX|Q4|,UBS|Q4|,E.PSW,DDTBGN)
   if	(.GT.(Q4,0))!(.LE.(SUP,0))
	 MACBLK(QQ+NCTAS)
   else
	IF KIOSRC
	 MACBLK(QQ+NCTAS)
	ELSE
	 if NCV530
	  MACBLK(QQ+NCTAS,,,,,,,,,,,,SCMAC)
	 else
	  MACBLK(QQ+NCTAS,,,,,SCMAC)
	 ei
	EI (KIOSRC)
   ei
	UB2(UBX|Q4|,FDDT,Q4,-KQ,,S|Q4|LIC)
	UB3(Q,Q3,Q4)
	UBXDDT(UBX|Q4|,U.PSW)
Q4	EQ	Q4+1
Q	EQ	$0 (Q3*PAGE)+Q
	er				:
					:
:	.......................................................................
:	Setup User DDT Block for Monitor slot if it is defined
:	.......................................................................
					:
 if	MSLOT				:IF MONITOR SLOT OPTION ON
	GL	MSTA			:
Q3	EQ	S|Q4|CORE*Q1		:
UBX|Q4| UB1(UBX|Q4+1|,UBX|Q4|,UBS|Q4|,E.PSW,DDTBGN)
	MACBLK(QQ+NCTAS)		:
	UB2(UBX|Q4|,FDDT,Q4,-KQ)	:
	LUBLOK(Q4)			:
	SLUBLK(Q4)			:
	DSCBLK(Q4,SH.Q|Q4|,SH.Q|Q4|)	:
	KIOBLK(UBX|Q4|,UBX|Q4+1|,L.P!L.H!L.L!L.R,Q4,MSTA,Q3)
	UBXDDT(UBX|Q4|,U.PSW)
Q4	EQ	Q4+1
 ei    (MSLOT)				:
					:
 if	SUP				:

	SUBTTL	SUPERVISOR USER BLOCKS

	LO	SUPDEF
	RA	0

:	...............................................................
:	FIRST REDEFINE SUP COMMON AREAS IN TERMS OF REAL AREAS
:	...............................................................
					:
	GL	S.COMN,QSC1M0,S1.CMN	:
S.COMN	EQ	(Q^MSHFTA)+SC1MAC	:SUP COMMON AREA 1
QSC1M0	EQ	S.COMN!MASK9		:
Y	EQ	0			:
 re	SC2SEG				:SUP COMMON AREA 2
 if	SC2M|Y|
QSC2M|Y| EQ	(Q^MSHFTA)+SC2M|Y|!MASKB
 else
QSC2M|Y| EQ	0
 ei
Y	EQ	Y+1
 er					:
					:
:	...............................................................
:	DEFINE A MACRO TO SET UP ALL THE SUP COMMON 2 SEGMENTS
:		(ALSO DEFINES REMAINING SEGMENTS NULL, "USED" IS COUNT
:		OF THOSE ALREADY USED)
:	...............................................................
					:
MACSC2	MACRO(M0,M1,USED,DMASEG)[
	WC	$0 .+MPROT-MACTRN+MACDIS
	WC	$0 MACAREA+MACDIS
	WC	$0 (1F)*10
	WC	M0
	WC	M1
	RA	0
Y	EQ	0
 re	SC2SEG
 if	QSC2M|Y|
	WC	QSC2M|Y|+NCTAS
 else
	WC	0
 ei
Y	EQ	Y+1
 er
Y	EQ	Y+USED
 if	$A 8-Y
 re	$A 8-Y
	WC	0
Y	EQ	Y+1
 er
 	WC	DMASEG
Y	EQ	Y+1
 ei
	WS	$A15-Y
	WC	CONMAC
	ZITMAC
	RA	0A
]
					:
:	...............................................................
:	A BLOCK FOR CONTROL OF THE SUPERVISOR
:	...............................................................
					:
	RA	$A 10			:
UBX|Q4|	UB1(UBX|Q4+1|,UBX|Q4|,UBSUP,E.PSW,DDTBGN)
UBXSUP	EQ	UBX|Q4|
QSUP	EQ	Q
QSUPS	EQ	QSUP^MSHFTA
	WC	$0 .+MPROT-MACTRN+MACDIS
	WC	$0 MACAREA+MACDIS
	WC	$0 (1F)*10
	RA	0
Y	EQ	0
 re	SA0SEG
 if	SA0M|Y|
	WC	NCTAS+QSUPS+SA0M|Y|!MASK9
 else
	WC	0
 ei
Y	EQ	Y+1
 er
   IF	KIOSRC				:
	WC	0			:
   ELSE					:
	WC	SCMAC			:SUP AREA 1
   EI  (KIOSRC)				:
Y	EQ	0
 re	SA2SEG
	WC	QSUPS+NCTAS+SA2M|Y|!MASK3	:SUP AREA 2
Y	EQ	Y+1
 er
Y	EQ	SA0SEG+SA2SEG+1
	WC	SBDMRG
Y	EQ	Y+1
	WS	$A15-Y			:FILL OUT UNUSED SEGMENTS NULL
	WC	CONMAC
	RA	$A10
	UB2(UBX|Q4|,FDDT,Q4,-S.Q1)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(Q4,5,5)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,L.SYA!L.SUA!L.SYP!L.SYR!L.P!L.H!L.L!L.R,Q4,QSUP+NCTA,SUPA0+SUPA2)
	UBXDDT(UBX|Q4|,U.PSW,0FFFE)

Q4	EQ	Q4+1
Q	EQ	$0 (SUPCORE*PAGE)+Q
					:

:	...............................................................
:	NOW DEFINE PROBE CONTROLLING SLOT
:	...............................................................
					:
V	EQ	Q4			:SLOT NUMBER FOR COLLECTION OF PROCESSES
Q5	EQ	$0 SMACK(PROA0,0)!(Q^MSHFTA)!MASK1 :SEGMENT 0 DEFINITION

UBX|Q4|	UB1(UBX|Q4+1|,UBX|Q4|,UBX|Q4+1|,E.PSW,DDTBGN)
UBXPROBE EQ	UBX|Q4|
	MACSC2(NCTAS+Q5,S1.CMN,2,PRDMRG)
	UB2(UBX|Q4|,FDDT,V,-S.Q2)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,5)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,L.P!L.H!L.L!L.R,V,Q+NCTA,PROA0)
	UBXDDT(UBX|Q4|,U.PSW,0FFFE)
Q4	EQ	Q4+1
					:
:	....................................................................
:	AND CORRESPONDING CONTROLLED SLOTS
:	....................................................................
					:
Q3	EQ	PROSA+PROSAI		:EXECUTION START ADDRESS
 re	SUPNP				:FOR EACH USER:
UBX|Q4|	UB1(UBX|Q4+1|,GGPRO,UBXPROBE,U.PSW,Q3)
	MACSC2(NCTAS+Q5,S1.CMN,2,PRDMRG)
	UB2(UBX|Q4|,FKIOJ,V,-S.Q2)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,0)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,0,$01000+V,Q+NCTA,PROA0)
Q3	EQ	Q3+PROSAI		:NEXT START ADDRESS
Q4	EQ	Q4+1
 er
V	EQ	V+1			:FOR NEXT SECTION
Q	EQ	$0 PROA0*PAGE+Q		:
					:

:	....................................................................
:	NOW DEFINE ERRLOG CONTROLLING SLOT
:	....................................................................
					:
Q5	EQ	$0 SMACK(ERRA0,0)!(Q^MSHFTA)!MASK1	:SEGMENT 0 DEFINITION

UBX|Q4|	UB1(UBX|Q4+1|,UBX|Q4|,UBX|Q4+1|,E.PSW,DDTBGN)
UBXERR	EQ	UBX|Q4|
	MACSC2(NCTAS+Q5,S1.CMN,2,ERDMRG)
	UB2(UBX|Q4|,FDDT,V,-S.Q3)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,1)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,L.P!L.H!L.L!L.R,V,Q+NCTA,ERRA0)
	UBXDDT(UBX|Q4|,U.PSW,0FFFE)
Q4	EQ	Q4+1
					:
:	....................................................................
:	AND CORRESPONDING CONTROLLED SLOTS
:	....................................................................
					:
Q3	EQ	ERRSA+ERRSAI		:EXECUTION START ADDRESS
 re	SUPNER				:FOR EACH USER:

UBX|Q4|	UB1(UBX|Q4+1|,GGERR,UBXERR,U.PSW,Q3)
	MACSC2(NCTAS+Q5,S1.CMN,2,ERDMRG)
	UB2(UBX|Q4|,FKIOJ,V,-S.Q3)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,0)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,0,$01000+V,Q+NCTA,ERRA0)
Q3	EQ	Q3+ERRSAI		:NEXT START ADDRESS
Q4	EQ	Q4+1
 er
V	EQ	V+1			:FOR NEXT SECTION:
Q	EQ	$0 ERRA0*PAGE+Q		:


					:
:	....................................................................
:	NOW DEFINE ACCOUNT CONTROLLING SLOT
:	....................................................................
					:
Q5	EQ	$0 SMACK(ACCA0,0)!(Q^MSHFTA)!MASK1	:SEGMENT 0 DEFINITION

UBX|Q4|	UB1(UBX|Q4+1|,UBX|Q4|,UBX|Q4+1|,E.PSW,DDTBGN)
UBXACC	EQ	UBX|Q4|
	MACBLK(NCTAS+Q5,NCTAS+QSC2M0,S1.CMN,0,0,0,0,0,ACDMRG) :REFERENCING SUP COMMON
	UB2(UBX|Q4|,FDDT,V,-S.Q4)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,1)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,L.P!L.H!L.L!L.R,V,Q+NCTA,ACCA0)
	UBXDDT(UBX|Q4|,U.PSW,0FFFE)
Q4	EQ	Q4+1			:
					:
:	....................................................................
:	AND CORRESPONDING CONTROLLED SLOTS
:	....................................................................
					:
Q3	EQ	ACCSA+ACCSAI		:EXECUTION START ADDRESS
 re	SUPNAC				:FOR EACH USER:

UBX|Q4|	UB1(UBX|Q4+1|,GGACC,UBXACC,U.PSW,Q3)
	MACBLK(NCTAS+Q5,NCTAS+QSC2M0,S1.CMN,0,0,0,0,0,ACDMRG)
	UB2(UBX|Q4|,FKIOJ,V,-S.Q4)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,0)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,0,$01000+V,Q+NCTA,ACCA0)
Q3	EQ	Q3+ACCSAI		:NEXT START ADDRESS
Q4	EQ	Q4+1
 er
V	EQ	V+1			:FOR NEXT SECTION:
Q	EQ	$0 ACCA0*PAGE+Q		:
					:

:	....................................................................
:	NOW DEFINE SYSMSG1 CONTROLLING SLOT
:	....................................................................
					:
Q5	EQ	$0 SMACK(SYSA0,0)!(Q^MSHFTA)!MASK1	:SEGMENT 0 DEFINITION

UBX|Q4|	UB1(UBX|Q4+1|,UBX|Q4|,UBX|Q4+1|,E.PSW,DDTBGN)
UBXSYS	EQ	UBX|Q4|
	MACSC2(NCTAS+Q5,S1.CMN,2,SYDMRG)
	UB2(UBX|Q4|,FDDT,V,-S.Q5)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,1)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,L.P!L.H!L.L!L.R,V,Q+NCTA,SYSA0)
	UBXDDT(UBX|Q4|,U.PSW,0FFFE)
Q4	EQ	Q4+1

:	AND CORRESPONDING CONTROLLED SLOTS
Q3	EQ	SYSSA+SYSSAI		:EXECUTION START ADDRESS
 re	SUPNSY				:FOR EACH USER:

UBX|Q4|	UB1(UBX|Q4+1|,GGSYS,UBXSYS,U.PSW,Q3)
	MACSC2(NCTAS+Q5,S1.CMN,2,SYDMRG)
	UB2(UBX|Q4|,FKIOJ,V,-S.Q5)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,0)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,0,$01000+V,Q+NCTA,SYSA0)
Q3	EQ	Q3+SYSSAI		:NEXT START ADDRESS
Q4	EQ	Q4+1
 er
V	EQ	V+1			:FOR NEXT SECTION:
Q	EQ	$0 SYSA0*PAGE+Q		:
					:

:	....................................................................
:	DEFINE UN2 CONTROLLING SLOT
:	....................................................................
					:
Q5	EQ	$0 SMACK(UN2A0,0)!(Q^MSHFTA)!MASK1	:SEGMENT 0 DEFINITION

UBX|Q4|	UB1(UBX|Q4+1|,UBX|Q4|,UBX|Q4+1|,E.PSW,DDTBGN)
UBXUN2	EQ	UBX|Q4|
	MACBLK(NCTAS+Q5,NCTAS+QSC1M0!$080000000,NCTAS+QSC2M0,0,0,0,0,0,UNDMRG)
	UB2(UBX|Q4|,FDDT,V,-S.Q6)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,1)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,L.P!L.H!L.L!L.R,V,Q+NCTA,UN2A0)
	UBXDDT(UBX|Q4|,U.PSW,0FFFE)
Q4	EQ	Q4+1

:	AND CORRESPONDING CONTROLLED SLOTS
Q3	EQ	UN2SA+UN2SAI		:EXECUTION START ADDRESS
 re	SUPNUN				:FOR EACH USER:

UBX|Q4|	UB1(UBX|Q4+1|,GGUN2,UBXUN2,U.PSW,Q3)
	MACBLK(NCTAS+Q5,NCTAS+QSC1M0!$080000000,NCTAS+QSC2M0,0,0,0,0,0,UNDMRG)
	UB2(UBX|Q4|,FKIOJ,V,-S.Q6)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,0)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,0,$01000+V,Q+NCTA,UN2A0)
Q3	EQ	Q3+UN2SAI		:NEXT START ADDRESS
Q4	EQ	Q4+1
 er					:
V	EQ	V+1			:FOR NEXT SECTION:
Q	EQ	UN2A0*PAGE+Q		:
					:

:	....................................................................
:	FINALLY DEFINE UTILITY SLOT
:	....................................................................
					:
UBX|Q4|	UB1(UBX|Q4+1|,0,0,E.PSW,DDTBGN)
UBUTIL	EQ	UBX|Q4|
	IF	DSZUTL
Q5	 EQ	$0 (SMACK(UTILA1,0)!MASK3)+(Q^MSHFTA)
	 MACBLK(UTDMRG,NCTAS+Q5)
	ELSE
Q3	 EQ	$0 SMACK(UTILA0,0)!MASK1+(Q^MSHFTA)
Q5	 EQ	$0 (SMACK(UTILA1,UTILA0)!MASK3)+(Q^MSHFTA)
	 MACBLK(NCTAS+Q3,NCTAS+Q5)
	EI	(DSZUTL)
	UB2(UBX|Q4|,FDDT,V,-S.Q7)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(V,1,1)
	KIOBLK(UBX|Q4|,UBX|Q4+1|,L.P!L.H!L.L!L.R,V,Q+NCTA,UTILA0+UTILA1)
	UBXDDT(UBX|Q4|,U.PSW,0FFFE)
Q4	EQ	Q4+1
V	EQ	V+1			:FOR NEXT SECTION:
Q	EQ	(UTILA0+UTILA1)*PAGE+Q
	FO	SUPDEF
	RA	$A10
 else
SN.CMN	EQ	0			:NODE'S SUP COMMON AREA 1
 ei	(SUP)

	RA	$A10
UBX|Q4|	EQ	0			:NULL ENTRY FOR CHAIN TERMINATION

XCORE	EQ	Q			:EXTRA CORE REQUIRED
					:

	SUBTTL	SLOT USER BLOCKS
					:
:	.......................................................................
:	Setup slots' Background User Block
:	.......................................................................
					:
Q4	EQ	0			:STARTING WITH SLOT 0
 re	NSLOT+1

UBS|Q4|	UB1(0,QS|Q4|,UBX|Q4|,U.PSW,.)
	MACBLK()
	UB2(UBS|Q4|,FBACK!FDISP,Q4,-Q.BG|Q4|,,S|Q4|LIC)
	LUBLOK(Q4)
	SLUBLK(Q4)
	DSCBLK(Q4,SH.Q|Q4|,0)
	ORG	UBS|Q4|+RBLEN
Q4	EQ	Q4+1
 er					:

 if	SUP

:	....................................................................
:	BACKGROUND USER BLOCK FOR THE SUPERVISOR
:	....................................................................
					:
	LO	SUPDEF			:
	LO	SUPER			:
  if	SUPMIC-1			:
M.PSW	EQ	U.PSW!$00800		:
 else					:
M.PSW	EQ	U.PSW			:
  ei					:
	FO	SUPER

UBSUP	UB1(0,0,UBXSUP,M.PSW,SUPST)
	WC	$0 .+MPROT-MACTRN+MACDIS
	WC	$0 MACAREA+MACDIS
	WC	$0 (1F)*10
	RA	0			:
Y	EQ	0			:
 re	SA0SEG
 if	SA0M|Y|
	WC	NCTAS+QSUPS+SA0M|Y|!MASK9
 else
	WC	0
 ei
Y	EQ	Y+1
 er
   IF	KIOSRC
	WC	0
   ELSE
	 WC	SCMAC			:SUP AREA 1
   EI   (KIOSRC)
Y	EQ	0
 re	SA2SEG
	WC	QSUPS+NCTAS+SA2M|Y|!MASK3	:SUP AREA 2
Y	EQ	Y+1
 er
Y	EQ	SA0SEG+SA2SEG+1
	WC	SBDMRG
Y	EQ	Y+1
	WS	$A15-Y			:FILL OUT UNUSED SEGMENTS NULL
	WC	CONMAC
	RA	$A10
	UB2(UBSUP,FBACK!F1CRAS,Q4,-S.Q1)
	LUBLOK(-1)
	SLUBLK(Q4)
	DSCBLK(Q4,5,5)
	ORG	UBSUP+RBLEN
 ei    (SUP)				:

	SUBTTL	FOREGROUND (QUASI) BLOCKS FOR SLOTS

    if	KIOSRC
    else	
:	.......................................................................
:	SPECIAL QUASI BLOCK FOR FLASHER
:	.......................................................................
					:
Q9	EQ	$0800
QFLASH	UB1(0,UBFLASH,UBSYS,E.PSW!Q9,FLASHF)
	MACBLK()			:MAC SEGMENTS
	UB2(QFLASH,FQUASI,-1,0,-FLASHD)	:
	ORG	QFLASH+RBLEN		:EVERYTHING ELSE
    ei (KIOSRC)				:
					:
:	.......................................................................
:	Setup slots' Foreground User Block
:	.......................................................................
					:
Q4	EQ	0			:STARTING WITH SLOT 0
 re	NSLOT+1
QS|Q4|	UB1(0,UBS|Q4|,UBX|Q4|,U.PSW,.)
	MACBLK()
	UB2(QS|Q4|,FQUASI,Q4,0,-Q.FG|Q4|,S|Q4|LIC)
	LUBLOK(Q4)
	SLUBLK(Q4)
	DSCBLK(Q4,SH.Q|Q4|,0)
	ORG	QS|Q4|+RBLEN		:EVERYTHING ELSE
Q4	EQ	Q4+1			:FOR NEXT SLOT
 er					:
					:
	SUBTTL KERNEL TRACE LOGIC AND PATCH AREA
					:
	RA	0			:
					:
KPATCH	HS				:
	ST	R0,PATCH3		:USED FOR TRACING...SAVE REGISTER
	L	R0,.,,			:PATCH WITH TEST QUANTITY
	JNFS	PATCH1			:JUMP IF OK
	L	R0,PATCH3		:FAILURE...RESTORE R0
	LPSW	.+4			:HALT THE MACHINE
	HC	0,8000,0,70		:
PATCH1	L	R0,TRPSD+4		:OK...SAVE CURRENT LOCATION
	ST	R0,PATCH2		:
	L	R0,PATCH3		:RESTORE R0
	UPSW	TRPSD			:
PATCH2	HS	2			:SAVE ADDRESS HERE
PATCH3	HS	2			:SAVE R0 HERE
	WS	KPASIZ			:PATCH AREA
KPAEND	WS	0			:
					:
	EM				:
					:
	RA	0			:
 if	MXP				:

	SUBTTL	MXP KDIO AREA
					:
:	...............................................................
:	KERNEL/DISPATCHER COMMUNICATIONS (KDIO) AREA
:	...............................................................
					:
	WS	0			:
LANSTS	HC	0			:CURRENT LAN STATUS
KDIO	HS				:KDIO START ("KDDSPA" MUST BE EVEN ADDR)
KDVERS	HC	1			:KDIO AREA VERSION
KDNODE	HC	MACHNM			:NODE NUMBER
KDNMCH	HC	NMACH			:MAXIMUM NMBR OF MACHINES IN CLUSTER
KDNSLT	HC	NSLOT			:NUMBER OF SLOTS
KDNDCH	HC	DI.CHN			:NUMBER OF DISPATCHER CHANNELS
KDDSPA	WC	MXPDSP			:XPI SPEEDOMETER DISPLAY ADDR
KDETXA	WC	KREX			:ENG-TO-XPI RING ADDR
KDXTEA	WC	KRXE			:XPI-TO-ENG RING ADDR
KDETXL	HC	KREXL			:ENG-TO-XPI RING LENGTH
KDXTEL	HC	KRXEL			:XPI-TO-ENG RING LENGTH
KDGMTA	WC	GMT			:ADDR OF GMT TIME
	WS	0			:
KREX	BS	KDAT+KREXL		:ENG-TO-XPI RING
	WS	0			:
KRXE	BS	KDAT+KRXEL		:XPI-TO-ENG RING
 ei    (MXP)				:
					:



	SUBTTL	SHAR. . .THE SHARED DEVICE AND EXTEND SELECTOR CHAN HANDLER

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other   purpose except as specifically authorized in  wri-  **
: **  ting by  TYMNET, Incorporated.                              **
: ******************************************************************

	IF	SHARE

	BND	100			:FORCE TO A NICE MEMORY BOUNDARY
	MO	.,SHARE

:	DEFINE MNEMONIC ERROR CODES
NO.ERR	EQ	00			:0d	NO ERROR
ERR.01	EQ	01			:1d	BAD MEMORY ACCESS
ERR.02	EQ	02			:2d	BAD DISK AREA NUMBER
ERR.03	EQ	03			:3d	BAD DISK AREA ACCESS
ERR.04	EQ	04			:4d	VIRTUAL DISK ADDRESS OUT OF AREA
ERR.05	EQ	05			:5d	BAD CYLINDER ADDRESS
ERR.06	EQ	06			:6d	BAD CYLINDER ADDRESS...SOME DATA TRANSFERED
ERR.07	EQ	07			:7d	ERROR RETURN FROM THE DISK
ERR.08	EQ	08			:8d	ERROR RETURN FROM THE CONTROLLER
ERR.09	EQ	09			:9d	ABORTED BY QUIT CHAR
ERR.10	EQ	0A			:10d	REQUESTED 0-LENGTH TRANSFER
ERR.11	EQ	0B			:11d	INVALID CYLINDER OVERFLOW
ERR.12	EQ	0C			:12d	CONTROLLER ERROR...DEFECTIVE SECTOR IN ALT. CYLS
ERR.13	EQ	0D			:13d	CONT. ERROR...DEFECTIVE SECTOR IN ALTS, NO MORE
ERR.14	EQ	0E			:14d	CAN'T READ MAPS FOR THIS DISK
ERR.15	EQ	0F			:15d	CONT. ERROR...BAD SECTOR...ALT. CYL. ASSIGNED
ERR.16	EQ	10			:16d	END OF FILE DETECTED
ERR.17	EQ	11			:17d	END OF VOLUME DETECTED
ERR.18	EQ	12			:18d	DEVICE UNAVAILABLE
ERR.19	EQ	13			:19d	WRITE PROTECTED VOLUME
ERR.20	EQ	14			:20d	ATTACH SUCCESSFUL BUT WRITE PROTECTED VOLUME
ERR.21	EQ	15			:21d	UNIT ALREADY ATTACHED
ERR.22	EQ	16			:22d	REQUEST IGNORED FOR THIS TYPE DEVICE
ERR.23	EQ	17			:23d	ESELCH TIMEOUT
ERR.24	EQ	18			:24d	OPERATION SUCCESSFUL, BUT ERROR RECOVERY DONE

	IF	1-TSIDT			

	REMARK	%Engine shared device handler selected

	IF	ESELCH;	 LO	ES.INT;	EI
	IF	MSCDSK;	 LO	MSC.INT;	EI
	 LO	KERNEL
	 LO	KCAREA

:	DEFINE FUNCTION TO COMPUTE ADDRESSES (RELATIVE TO LSHARE)
RAD	MACRO(ADDR)[ADDR-LSHARE]

:	DEFINE FUNCTION TO COMPUTE ABSOLUTE ADDRESSES (FROM THOSE RELATIVE)
AAD	MACRO(ADDR)[ADDR+LSHARE]



	IF	ESELCH
:		E S E L C H ,   D I S K   A N D   T A P E   E Q U A T E S

:	CHANNEL COMMANDS
CHSTP	EQ	8			:STOP
GO	EQ	10			:START SELCH
RDO	EQ	20			:READ MODE
CHXAR	EQ	40			:EXTENDED ADDR READ

:	CONTROLLER COMMANDS
DKRD	EQ	1			:READ
DKWR	EQ	2			:WRITE
DKCK	EQ	3			:CHECK READ
DKFT	EQ	4			:FORMAT
DKRST	EQ	8			:RESET
:	CONTROLLER STATUS BITS
DKERR	EQ	1			:DATA ERROR
CIDLE	EQ	2			:IDLE
EX	EQ	4			:EXAMINE
CYLOV	EQ	10			:CYLINDER OVERFLOW
DEFTRK	EQ	20			:DEFECTIVE TRACK
ADDRCF	EQ	40			:ADDRESS COMPARE FAILURE
OVERRUN EQ	80			:NO SECTOR MATCH
	IF	NDISC

:	DISC COMMANDS
RESTORE EQ	1			:RESTORE
SEEK	EQ	2			:SEEK
ENABLE	EQ	40			:INTERRUPT ENABLE
DISARM	EQ	0C0			:INTERRUPT DISARM
:	MISCELLANEOUS
ACFLG	EQ	80000000		:ALT CYL FLAG
:	DISC STATUS BITS
NRDY	EQ	1			:NOT READY
SINC	EQ	2			:SEEK INCOMPLETE
EX	EQ	4			:EXAMINE
NRSRW	EQ	8			:NOT READY TO SEEK, READ, OR WRITE
ADS	EQ	10			:ADDR INTERLOCK
ILLADR	EQ	20			:SET BY SEEK TO OUT-OF-RANGE CYLINDER
WRCHK	EQ	40			:WRITE CHECK OR POWER FLUCTUATION
WPROT	EQ	80			:VOLUME WRITE-LOCKED
	EI	(NDISC)
	IF	NTAPE

:	TAPE COMMANDS
SLDEN	EQ	2			:SET LOW DENSITY
XMODE	EQ	4			:MODE SET
EDIT	EQ	10			:EDIT MODE
BACKR	EQ	11			:BACK RECORD
SKRF	EQ	13			:SKIP REVERSE FILE
CLEAR	EQ	20			:CONTROLLER CLEAR
READ	EQ	21			:READ RECORD
WRITE	EQ	22			:WRITE RECORD
SKFF	EQ	23			:SKIP FORWARD FILE
WRFMK	EQ	30			:WRITE FILEMARK
ERASE	EQ	31			:ERASE GAP
XSTA	EQ	33			:SENSE STATUS EXTENDED
REW	EQ	38			:REWIND
ENABLE	EQ	40			:ENABLE INTERRUPTS
DISABLE	EQ	80			:DISABLE INTERRUPTS
DISARM	EQ	0C0			:DISARM INTERRUPTS
:	TAPE STATUS BITS
BOT	EQ	2			:BEGINNING OF VOLUME
FPROT	EQ	4			:VOLUME WRITE-LOCKED
DU	EQ	100			:DEVICE UNAVAIL
EOM	EQ	200			:END OF OPERATION
NMTN	EQ	1000			:NO MOTION
ET	EQ	2000			:BOT OR END OF VOLUME
EOF	EQ	4000			:END OF FIL
ERR	EQ	8000			:DATA ERROR
	EI	(NTAPE)
:	MISCELLANEOUS
MXRTRY	EQ	4			:NO. OF RETRIES FOR DISC/TAPE ERRORS
	EI	(ESELCH)

:	QIO SUBFUNCTION FLAGS (NEW)
QSFN	EQ	1			:NEW TYPE SVC CALL
QSFF	EQ	2000			:FORMAT READ OR WRITE
QSFC	EQ	4000			:CHECK DATA READ
	SUBTTL	HARDWARE CONFIGURATION WITH DISCS AND TAPES.

Q	EQ	0

:	DEFINE A PAIR OF DISCS N1, N2 WITH ADDRESSES A1, A2
DEF2DK	MACRO(N1,N2,A1,A2)[
N1	EQ	A1
N2	EQ	A2
	BITDEF(N1)
	EQUIV(N2,N1)
]

:	DEFINE ONE DEVICE TO BE SAME AS SECOND
EQUIV	MACRO(ADDR1,ADDR2)[
BIT|ADDR1| EQ	BIT|ADDR2|
BNO|ADDR1| EQ	BNO|ADDR2|
CHN|ADDR1| EQ	CH0
]

:	DEFINE UNIQUE DEVICE
BITDEF	MACRO(ADDR)[
	IF	Q-1F
	REM	%EXCEEDED LIMIT 32 TOTAL DEVICES
	ELSE
BNO|ADDR| EQ	Q
BIT|ADDR| EQ	80000000^-Q
CHN|ADDR| EQ	CH0
	EI
Q	EQ	Q+1
]

:	DEFINE CONTROLLER FOR DEVICE
CODEF	MACRO(CHADDR,ADDR)[
CH0	EQ	CHADDR
	BITDEF(ADDR)
]

:	DEFINE BUSY BITS FOR ALL KNOWN HARDWARE
	IF	ESELCH
CH0	EQ	0F0
	BITDEF(0F0)			:FIRST ESELCH
TIMED	EQ	BIT|0F0|		:INCLUDE THIS TO BE TIMEDOUT
	IF	XSELCH;	BITDEF(0F2)			:2ND ESELCH;TIMED	EQ	TIMED!BIT|0F2|;	EI
	IF	NDISC

:		5 4 4 0   D I S C   P A R A M E T E R S
DVNM0	EQ	444B			:DEVICE NAME - "DK"
MXCY0	EQ	$A 408			:408 CYLINDERS TO A 5440 PACK
MXHD0	EQ	$A 2			:2 HEADS
BPT0	EQ	$A 24			:24 BLOCKS PER TRACK
DDB0	EQ	$A 256			:256 BYTES/BLOCK
MXAC0	EQ	$A 4			:MAX NO. OF ALTERNATE CYLINDERS
MCYL0	EQ	MXCY0-MXAC0-1		:CYL RESERVED FOR ALT CYL MAPS
BACY0	EQ	MXCY0-MXAC0		:1ST ALT CYLINDER
LMAX0	EQ	2*NDISC			:TWO LOGICAL UNITS PER PHYSICAL UNIT
	IF	NASYNG-1
	 IF	N.ADA
:	NEW ASYNC DEVICE ADDRESSES START AT 0C1
	 REMARK	%CONFIGURATION ERROR--ASYNC AND DISK DEVICE ADDRESSES CONFLICT
	 EI	(N.ADA)
	EI	(NASYNG-1)

					:	::DISC UNIT::
					:REMOVABLE	FIXED
	CODEF(0F0,0B6)			:	1ST DISC CONTROLLER
	DEF2DK(D0A0,D0A1,0C6,0C7)	:0		1
	IF	NDISC-1;	DEF2DK(D0A2,D0A3,0D6,0D7);	:2		3;	EI
	IF	NDISC-2;	DEF2DK(D0A4,D0A5,0E6,0E7)	:4		5;	EI
	IF	NDISC-3;	DEF2DK(D0A6,D0A7,0F6,0F7)	:6		7;	EI
	IF	NDISC-4;	CODEF(0F0,036)			:	2ND DISC CONTROLLER
	DEF2DK(D0A8,D0A9,046,047)	:8		9;	EI
	IF	NDISC-5;	DEF2DK(D0A10,D0A11,056,057)	:10		11;	EI
	IF	NDISC-6;	DEF2DK(D0A12,D0A13,066,067)	:12		13;	EI
	IF	NDISC-7;	DEF2DK(D0A14,D0A15,076,077)	:14		15;	EI
	EI	(NDISC)
	IF	NTAPE

:		T A P E   P A R A M E T E R S
DVNM1	EQ	4D54			:DEVICE NAME - "MT"
MXCY1	EQ	0FFFF			:LET USER PUT ANYTHING INTO GLOBAL UNIT
					: DESCRIPTOR WORD
DDB1	EQ	$A 512			:DEFAULT BLOCK SIZE
LMAX1	EQ	NTAPE			:ONE LOGICAL UNIT PER PHYSICAL UNIT
	IF	NASYNG
	 IF	N.ADA
:	NEW ASYNC DEVICE ADDRESSES START AT 0C1
	  IF	NASYNG-1
	  REMARK %CONFIGURATION ERROR--ASYNC AND TAPE DEVICE ADDRESSES CONFLICT
	  EI	NASYNG-1
	 ELSE
:	OLD ASYNC DEVICE ADDRESSES START AT 091
	  IF	(NASYNG-1)*(NTAPE-5)
	  REMARK %CONFIGURATION ERROR--ASYNC AND TAPE DEVICE ADDRESSES CONFLICT
	  EI	( (NASYNG-1)*(NTAPE-5) )
	 EI	(N.ADA)
	EI	(NASYNG)
	IF	XSELCH
TSELCH	 EQ	0F2
	ELSE
TSELCH	 EQ	0F0
	EI	(XSELCH)
				:	::TAPE::
				:CONTROLLER	UNIT
D1A0	EQ	0C5;	CODEF(TSELCH,D1A0)	:0	0
	IF	NTAPE-1;D1A1	EQ	0D5;	EQUIV(D1A1,D1A0)	:0	1;	EI
	IF	NTAPE-2;D1A2	EQ	0E5;	EQUIV(D1A2,D1A0)	:0	2;	EI
	IF	NTAPE-3;D1A3	EQ	0F5;	EQUIV(D1A3,D1A0)	:0	3;	EI
	IF	NTAPE-4;D1A4	EQ	085;	CODEF(TSELCH,D1A4)	:1	0;	EI
	IF	NTAPE-5;D1A5	EQ	095;	EQUIV(D1A5,D1A4)	:1	1;	EI
	IF	NTAPE-6;D1A6	EQ	0A5;	EQUIV(D1A6,D1A4)	:1	2;	EI
	IF	NTAPE-7;D1A7	EQ	0B5;	EQUIV(D1A7,D1A4)	:1	3;	EI
TPBITS	EQ	@BIT|D1A0|
TIMED	EQ	TIMED!BIT|D1A0|		:INCLUDE TO BE TIMEDOUT
	IF	NTAPE-4
TPBITS	EQ	TPBITS&@BIT|D1A4|		:TO BE USED IN EDPB ROUTINE
TIMED	EQ	TIMED!BIT|DIA4|		:INCLUDE TO BE TIMED OUT
	EI
	EI	(NTAPE)
	EI	(ESELCH)
	IF	MSCDSK

:		M S C - 1 4 0 0   D I S C   P A R A M E T E R S
DVNM2	EQ	4D53			:DEVICE NAME - "MS"
MXCY2	EQ	MSCCY0			:MAX CYLINDERS CORRESPOND TO CONTROLLER 0
DDB2	EQ	$A 256			:256 BYTES/RECORD
:	PACKET COMMANDS
MSC.RC	EQ	0012			:RECALIBRATE
MSC.WR	EQ	0014			:WRITE
MSC.RD	EQ	0020			:READ
QQ	EQ	0
Q5	EQ	0
	RE	MSCDSK
Q3	EQ	MSCDA|QQ|
	CODEF(Q3,Q3)
Q4	EQ	0
	RE	NMSC|QQ|
D2A|Q5|  EQ	Q3+Q4
	 BITDEF(Q3+Q4)
Q4	 EQ	Q4+1
Q5	 EQ	Q5+1
	ER
LMAX2	EQ	Q5
QQ	EQ	QQ+1
	ER

	EI	(MSCDSK)

	KILL	DEF2DK,EQUIV,BITDEF,CODEF	:KILL MACRO'S USED
	SUBTTL	DEFINE CONTROL-BLOCK DATA STRUCTURES

LSHARE	WS	0			:BASIS OF SHARED-DEVICE HANDLERS

:		LAYOUT OF PARAMETERS COMMON TO ALL CONTROL BLOCKS
	ORG	0
CB.NXT	HS	1			:NEXT CONTROL BLOCK (REL ADDR)
CB.INI	HS	1			:INITIALIZE CO-ROUTINE (REL ADDR)
CB.DA	HS	1			:DEVICE ADDR (SAME AS DEVICE NO.)
CB.INT	HS	1			:ADDR OF IMMEDIATE INTERRUPT HANDLER
CB.BN	HS	1			:BIT NUMBER CORRESPONDING TO 'BIT'
					:USED IN SET AND RESET INSTRUCTIONS
CB.NBIT	WS	1			:1'S COMPLEMENT OF BIT
CB.BIT	WS	1			:MASK OF BUSY BITS FOR THIS DEVICE
					: DEVICE IS BUSY IF BIT SET IN DEVICE END MASK
CB.BGN	HS	0			:BEGINNING OF CONTROL-BLOCK VARIATIONS

:	MACRO TO GENERATE COMMON PORTION OF CONTROL BLOCK
:	REQUIRES DEVICE'S ADDRESS FOR UNIT (DA),
:		INITIALIZATION ROUTINE NAME (INIT),
:		INTERRRUPT ROUTINE ADDRESS (INT).
:	INCREMENTS UNIT NO (UNT)
CB.CMN	MACRO(DA,INIT,INT)[ WS 0
DUCB|UNT| EQ	RAD(.)
UCB|DA|	EQ	RAD(.)
UNT	EQ	UNT+1
	HC	DUCB|UNT|
	HC	RAD(INIT)
	HC	DA
	HC	INT
	HC	BNO|DA|
	WC	@BIT|DA|
	WC	BIT|DA|
]




:	LAYOUT OF COMMON PORTION OF UNIT CONTROL BLOCK
	ORG	CB.BGN
UCB.DM	WS	1			:MASK OF ALL DEVICES REQUIRED TO PROCESS
					: A REQUEST FOR THIS UNIT
UCB.MP	HS	1			:INDICATES DEVICE MAPS READ IF 0
UCB.COB	HS	1			:(REL ADDR) OF CONTROLLER BLOCK FOR THIS UNIT
UCB.CHB	HS	1			:(REL ADDR) OF CHANNEL BLOCK FOR THIS UNIT
UCB.STA	HS	1			:STATUS BITS FOR LAST COMPLETED REQUEST
UCB.DVD	HS	1			:(REL ADDR) OF DEVICE DESC BLK
UCB.NA	HS	1			:ASCII DEVICE NAME
UCB.TY	BS	1			:DEVICE TYPE
UCB.XDA	BS	1			:EXTENDED DEVICE ADDR
UCB.DDB	HS	1			:DEFAULT BLOCKSIZE IN BYTES
UCB.CDA	HS	1			:DEVICE ADDR (DEVICE NO.) FOR CONTROLLER
					: REPLICATED FROM DA FIELD IN CONTROLLER BLOCK
	IF	SHSTAT
UCB.NR	WS	1			:NO. OF REQUESTS FOR THIS UNIT
	EI
UCB.BGN	HS	0			:BEGINNING OF UNIT-CONTROL-BLOCK VARIATIONS

:	MACRO TO GENERATE COMMON PORTION OF UCB:
:	REQUIRES ADDRESS FOR DEVICE (DA),
:		INITIALIZATION ROUTINE ADDRESS (INIT),
:		INTERRUPT ROUTINE ADDRESS (INT),
:		EXTRA BITS REQUIRED (XBITS),
:		FLAG FOR MAPPING (MAP),
:		CONTROLLER BLOCK ADDRESS (COADR),
:		CHANNEL BLOCK ADDRESS (CHADR),
:		EXTENDED ADDRESS FOR DEVICE (CDA).
:	INVOKES CB.CMN MACRO

UCB.CMN	MACRO(DA,INIT,INT,XBITS,MAP,COADR,CHADR,CDA)[ WS 0
	CB.CMN(DA,INIT,INT)
	WC	BIT|DA|!XBITS
	HC	MAP
	HC	COADR,CHADR
	HC	0,RAD(DVDB|TYP|)
	HC	DVNM|TYP|
	BC	TYP,DA
	HC	DDB|TYP|
	HC	CDA
	IF	SHSTAT
	WC	0
	EI	(SHSTAT)
]

	IF	ESELCH
	SUBTTL		LAYOUT OF CHANNEL AND CONTROLLER BLOCKS


:		LAYOUT OF CHANNEL BLOCK
	ORG	CB.BGN
CH.E	HS	1			:CHANNEL END COROUTINE (REL ADDR)
CH.R	HS	1			:CHANNEL REQUEST (REL ADDR)
					: POINTS TO DPB FOR REQUEST ACTIVE ON THIS CHANNEL
CH.T	WS	1			:CHANNEL TIMER, COMPARED WITH SLOWC

:	MACRO TO GENERATE UCB FOR CHANNEL UNIT
:	REQUIRES DEVICES ADDRESS FOR UNIT (DA)
:	INCREMENTS UNIT NO (UNT)
CHUCB	MACRO(DA)[ WS 0
ADUCB|UNT| CB.CMN(DA,I.CHX,INTV|UNT-1|)
	HS	2
	HC	7FFF,0FFFF
]



:		LAYOUT OF CONTROLLER BLOCK
:	THIS CONTAINS ONLY THE COMMON AREA PARAMETERS

:	MACRO TO GENERATE UCB FOR CONTROLLER UNIT
:	REQUIRES DEVICES ADDRESS FOR UNIT (DA)
COUCB	MACRO(DA)[ WS 0
	CB.CMN(DA,I.DKCB,INTV|UNT-1|)
]
	EI	(ESELCH)

	IF	MSCDSK
	SUBTTL	LAYOUT OF MSC-1400 UNIT CONTROL BLOCK
	ORG	UCB.BGN
MS.SPT	HS	1			:SECTORS PER TRACK (**MUST BE FIRST**)
MS.TPC	HS	1			:TRACKS PER CYLINDER
MS.BPC	HS	1			:SECTORS PER CYLINDER
MS.FIFO	HS	1			:ADDRESS OF FIFO BLOCK IN LOW CORE
MS.MXS	WS	1			:NO. OF SECTORS

:	MACRO TO GENERATE UCB FOR MSC-1400 DISC UNIT
:	REQUIRES ADDRESS FOR DEVICE (DA),
:		NUMBER OF DEVICE (NO),
:		NUMBER OF CYLINDERS (CYL),
:		NUMBER OF TRACKS/CY (TRK),
:		NUMBER OF SECTOR/TK (SEC),
:		ADDRESS OF FIFO RING FOR CONTROLLER (FIFO).
:	INCREMENTS UNIT NO (UNT)
:	(DEVICE TYPE 2)

MS.UCB	MACRO(DA,NO,CYL,TRK,SEC,FIFO)[ WS 0
V	EQ	DA
	UCB.CMN(V,I.MSU,MSC.I,0,0,0,0,NO)
	HC	SEC,TRK,TRK*SEC,FIFO
	WC	CYL*TRK*SEC
]
	EI	(MSCDSK)

	IF	NTAPE
	SUBTTL		LAYOUT OF MAG TAPE UNIT CONTROL BLOCK
	ORG	UCB.BGN
MT.RIP	HS	1			:REWIND IN PROGRESS ON UNIT IF ZERO
MT.DEN	HS	1			:WILL CONTAIN CONTROL BYTE TO SET DENSITY

:	MACRO TO GENERATE UCB FOR MAGTAPE UNIT
:	REQUIRES DEVICES ADDRESS FOR UNIT (DA)
:	INCREMENTS UNIT NO (UNT)
:	(DEVICE TYPE 1)

MT.UCB	MACRO(DA)[ WS 0
CHDA	EQ	CHN|DA|
Q9	EQ	BIT|CHDA|
	UCB.CMN(DA,I.MTU,INTV|UNT-1|,Q9,0,UCB|DA|,UCB|CHDA|,DA)
	HC	-1,0
]
	EI	(NTAPE)

	IF	NDISC
	SUBTTL		LAYOUT OF 5440 DISC UNIT CONTROL BLOCK
:	TWO FOR EACH FILE - REMOVABLE AND FIXED PLATTERS
	ORG	UCB.BGN
DK.BPT	HS	1			:BLOCKS PER TRACK (**MUST BE FIRST**)
DK.MXH	HS	1			:NO. OF HEADS (TRACKS) PER CYLINDER
DK.BPC	HS	1			:BLOCKS PER CYLINDER
DK.MXC	HS	1			:NO. OF CYLINDERS
CYLNO	WS	1			:CYL NO. TO SEEK AT CYLNO+2
					: ALT CYL READ OR WRITE IF
					: SIGN BIT SET
MCYL	WS	1			:CYL AND HEAD FOR CYLINDER MAPS
MREC	HS	1			:RECORD (BLOCK) NO. FOR CYLINDER MAPS
BACYL	HS	1			:BASE CYLINDER FOR ALTERNATE CYLINDER ASSIGNMENT
ALTCYL	WS	1			:ADDR OF ALT CYL ENTRY LAST USED
MSMA	WS	1			:STARTING MEMORY ADDR FOR ALT CYL MAP
MEMA	WS	1			:ENDING	MEMORY ADDR FOR ALT CYL MAP

:	MACRO TO GENERATE UCB FOR DISC UNIT (1/2 5440 DISC)
:	REQUIRES DEVICES ADDRESSES FOR CONTROLLER (CDA) AND UNIT (DA).
:	INCREMENTS UNIT NO (UNT)
:	(DEVICE TYPE 0)

DK.UCB	MACRO(CDA,DA)[ WS 0
CHDA	EQ	CHN|DA|
Q8	EQ	BIT|CDA|
Q9	EQ	BIT|CHDA|
	UCB.CMN(DA,I.DKU,INTV|UNT-1|,Q8!Q9,-1,UCB|CDA|,UCB|CHDA|,CDA)
	HC	BPT0,MXHD0,BPT0*MXHD0,MXCY0
	WS	1
	HC	MCYL0,0
	HC	0,BACY0
	WS	1
	WC	.+8
	WC	.+(MXAC0+1)*4-1
	WS	MXAC0
]


:	AND DEFINE A MACRO TO GENERATE BOTH DISK UCB'S
:	CDA	CONTROLLER ADDRESS
:	D0	DRIVE 0 ADDRESS (REMOVABLE);
:	D1	DRIVE 1 ADDRESS (FIXED);
DK.PAIR	MACRO(CDA,D0,D1)[ WS 0
	DK.UCB(CDA,D0)
	DK.UCB(CDA,D1)
]
	EI	(NDISC)
	SUBTTL		DEVICE PARAMETER BLOCK (DPB)
	ORG	0
PB.NXT	HS	1			:NEXT DPB (REL ADDR)
					: DPB'S WILL BE THREADED TO SDQ IF ACTIVE
					: TO AVAIL LIST IF INACTIVE
PB.MAP	HS	1			:MAP READ REQUEST IF -1
					: NORMAL REQUEST IF 0
					: MAP WRITE REQUEST IF +1
					: VALUE COPIED FROM "UCB.MP" IN UCB BY DISC/TAPE SVC
PB.STA	WS	1			:COROUTINE (REL ADDR) FOR UNIT|CHANNEL SCANNER
					: (IN LEFT|RIGHT HALFWORDS)
PB.SMA	WS	1			:STARTING MEMORY ADDR FOR DATA TRANSFER
PB.EMA	WS	1			:ENDING	MEMORY ADDR FOR DATA TRANSFER
:	*** DO NOT REORDER THRU PB.REC ***
PB.CYL	HS	1			:STARTING CYL NO
PB.HED	HS	1			:STARTING HEAD NO
PB.RTY	HS	1			:RETRY CTR (INITIALLY ZERO)
PB.REC	HS	1			:STARTING RECORD NO
PB.USR	WS	1			:ADDR OF USER BLOCK
PB.PRM	WS	1			:ADDR OF PARAMETER BLOCK REFERENCED BY SVC CALL
PB.HUI	WS	1			:HARDWARE UNIT INTERLOCK MASK.  COPIED BY SVC
					: FROM DEVICE MASK IN UCB.
PB.SUI	WS	1			:SOFTWARE UNIT INTERLOCK MASK.  COPIED BY SVC
					: FROM DEVICE MASK IN UCB
PB.NEW	HS	1			:NEW/OLD SVC FLAG.  0=OLD
PB.UCB	HS	1			:(REL ADDR) OF UNIT CONTROL BLOCK
					: PERTAINING TO THIS REQUEST
	IF	MSCDSK
	BS	PK.SIZ-2		:SUPER-PACKET STORAGE
	EI	(MSCDSK)
DPBLEN	WS	0			:LENGTH OF THE DPB

:	MACRO TO GENERATE ONE DPB
DPB	MACRO [ WS 0
Q	IF	MSCDSK
	ORG	Q+PB.UCB+2
	HC	RAD(MSEND)
	EI	(MSCDSK)
	ORG	Q+DPBLEN ]
	SUBTTL		ADDITIONAL DESCRIPTOR BLOCKS

:		GLOBAL UNIT DESCRIPTOR BLOCK
	ORG	0
GU.STC	HS	1			:CYL NO. WHICH STARTS A DISC AREA
GU.NCY	HS	1			:NUMBER OF CYLINDERS IN AREA
GU.ATT	HS	1			:ZERO IF UNIT NOT ATTACHED
					: ELSE SLOT+1
GU.UCB	HS	1			:(REL ADDR) OF UNIT CONTROL BLOCK
GU.SIZ	HS	0			:SIZE OF GLOBAL UNIT DISCRIPTOR



:		LOCAL UNIT DESCRIPTOR BLOCK
	ORG	0
LU.PB	BS	1			:PROTECTION BYTE
LU.GUN	BS	1			:GLOBAL UNIT NO.



:		SVC PARAMETER BLOCK
	ORG	0
SVC.RS	BS	1			:REQUEST/STATUS BYTE
SVC.LU	BS	1			:LOCAL UNIT NO.
SVC.ST	HS	1			:DEVICE STATUS BYTES 1 & 2
SVC.VA	WS	1			:VIRTUAL MEMORY ADDR
SVC.CT	WS	1			:COUNT OF BYTES TO TRANSFER
SVC.VB	WS	1			:VIRTUAL BLOCK NO.

	ORG	SVC.VA			:FIELDS SPECIFIC TO "READ STATUS"
SVC.PB	BS	1			:PB
SVC.GU	BS	1			:GLOBAL UNIT
SVC.NA	HS	1			:NAME FIELD
SVC.TY	BS	1			:DEVICE TYPE
SVC.DA	BS	1			:DEVICE ADDRESS
SVC.DD	HS	1			:DEFAULT BLOCK SIZE
SVC.BT	HS	1			:BLOCKS/TRACK
SVC.TC	HS	1			:TRACKS/CYLINDER
SVC.SC	HS	1			:START CYLINDER
SVC.NC	HS	1			:NUMBER OF CYLINDERS



:		LAYOUT OF DEVICE DESCRIPTOR BLOCK
	ORG	0
DDB.NFU	WS	1			:MASK OF LEGAL FUNCTIONS FOR DEVICE (0-31)
DDB.IST	WS	13			:INITIAL STATE TABLE
					: STATES ORDERED BY COMMANDS:
:	0	READ
:	1	WRITE
:	2	ATTACH
:	3	DETACH
:	4	BACKSPACE RECORD
:	5	SKIP FORWARD FILE
:	6	SKIP BACKARD FILE
:	7	WRITE EOF
:	8	REWIND
:	9	UNLOAD
:	10	GET STATUS
:	11	ERASE GAP
:	12	SET LOW DENSITY (TAPES)


	ORG	LSHARE
	SUBTTL	DISK, TAPE, AND OTHER CHANNEL DEVICE DATA AREAS

:	DATA REGION FOR CHANNEL, CONTROLLER, AND UNIT CONTROL
:	BLOCKS, GLOBAL UNIT DESCRIPTORS, REQUEST PARAMETER BLOCKS,
:	AND INITIAL STATE TABLES


:	BEGIN DATA
PBERR	HC	0,S.PSW!I.ENA		:SVC-PARAMETER-BLOCK ERROR EXIT PSD
	HC	0,NOTI			: ...END UP AT ILLEGAL SVC TRAP

RNDM	WC	0			:REQUEST END MASK.  BUSY DEVICES DENOTED BY BITS SET
DNDM	WC	0			:DEVICE END MASK.  BUSY DEVICES DENOTED BY BITS SET
BPA	HC	0			:CURRENT DPB ADDR - SAVED BY GETDPB
SDQ	HC	0			:REQUEST QUEUE HEAD
EDQ	HC	RAD(SDQ)		:REQUEST QUEUE TAIL
SDL	HC	DUCB0			:DEVICE UNIT LIST
AVAIL	HC	RAD(DPBPOL)		:AVAIL LIST OF DPB'S
SWQ	WC	0			:START OF WAIT QUEUE
EWQ	WC	SWQ			:END OF WAIT QUEUE

CHMSK	WC	0			:MASK OF DEVICE BITS FOR CHANNELS
					:DEFINED
DKRSTA	WC	0			:SAVE AREA FOR OLD STATUS DURING
					:RESTORE

	IF	SUP
Z	EQ	80000000
:	MASK OF ERROR CODES WHICH RETURN CONTROLLER STATUS BYTE
CEMSK	WC	(Z^-8)+(Z^-0C)+(Z^-0D)+(Z^-0F)
THIRTY	HC	30
DSKSF1	HS	1			:SHIFT COUNT USED BY DISK SVC'S
DSKMPL	HS	1			:MULTIPLIER USED BY DISK SVC'S
DSKSF2	HS	1			:SHIFT COUNT USED BY DISK SVC'S
	EI	(SUP)
	IF	ESELCH
STOP	BC	CHXAR+CHSTP		:STOP COMMAND FOR ESELCH
	IF	NDISC
RESET	BC	DKRST			:DISC CONTROLLER RESET
	EI	(NDISC)
	IF	NTAPE
XSTAT	BC	XSTA			:READ EXTENDED STATUS BYTE
MTCLR	BC	CLEAR			:CLEAR COMMAND FOR TAPE CONTROLLERS
MTENI	BC	ENABLE+CLEAR		:ENABLE INTERRUPTS FOR UNIT
EDIMOD	BC	EDIT+XMODE		:SET EDIT MODE FOR UNLOAD
	EI	(NTAPE)
TTMOUT	HS	20			:ADD AND TIMEOUT COUNT OF UNIT IN USE
	EI	(ESELCH)


:		REQUEST PARAMETER BLOCKS
DPBPOL	WS	0			:FORCE WORD BOUNDARY
	RE	NDPB
	DPB
	ER
	IF	MSCDSK
	IF	.-1FFFF;	REMARK	%PACKETS TOO FAR UP IN CORE!!%;	EI

:	COMMANDS FOR PACKETS
MSCCMD	BC	MSC.RD,MSC.WR		:READ/WRITE COMMAND
	EI	(MSCDSK)
	IF	NGLU


:		GLOBAL UNIT TABLE
:	DEFINE MACRO FOR SHORTER REPEAT LOOP:

	KILL	BITCH			:KILL ANY MACRO WITH THIS NAME FIRST
BITCH	MACRO [ REMARK %Exceeded max no. of cylinders
]
GUT	HC	0,0,0,0			:FORCE HALF-WORD BOUNDARY, NULL UNIT 0
Q	EQ	1
	RE	NGLU
Q3	EQ	1			:ASSUME ERROR
Q4	EQ	GU1|Q|
Q5	EQ	GU2|Q|
Q6	EQ	GU3|Q|
Q7	EQ	GU4|Q|
	IF	Q4
Q4	  EQ	7F&Q4
Q8	 EQ	MXCY|Q4|
Q9	 EQ	LMAX|Q4|
	 IF	Q6-Q8+1
	  BITCH()
	 ELSE	Q6+Q7-Q8
	  BITCH()
	 ELSE	Q5+1-Q9
	  REMARK %Exceeded unit limit
	 ELSE
Q3	  EQ	0
QQ	  EQ	$A D|Q4|A|Q5|
	  HC	Q6,Q7,0,UCB|QQ|
	 EI
	ELSE
Q3	 EQ	0			:NO ERROR FOR UNDEFINED UNITS
	 HC	0,0,0,0
	EI
	IF	Q3
	 HC	0,0,0,0
	 REMARK	,  Unit 
	 NUMBER	Q5
	 REMARK	 type 
	 NUMBER	Q4
Q7	 EQ	Q6+Q7-1
	 REMARK	 STCYL 
	 NUMBER	Q6
	 REMARK	 ENCYL 
	 NUMBER	Q7
	EI
Q	EQ	Q+1
	ER
	EI	(NGLU)
	RA	0
	KILL	BITCH			:DON'T NEED MACRO ANY MORE!
	SUBTTL	ISHARE - CALLED BY MINIT

:	RESETS CONTROLLERS AND PUTS OUT IMMEDIATE INTERRUPT VECTOR
:	USES R1 AS LINKAGE REGISTER
:	PRESERVE R0!!
ISHARE	LHI	R15,RAD(SDL)		:FOLLOW THREADED LIST OF DEVICES
	LIS	R11,0
	ST	R11,CHMSK		:ZERO CHANNEL MASK
IS1	LHL	R15,AAD(CB.NXT),R15	:NEXT UCB
	JEFS	IS2
	LHL	R2,AAD(CB.DA),R15	:DEVICE ADDRESS
	LHL	R14,AAD(CB.INI),R15	:ADDRESS OF INITIALIZATION ROUTINE
	J	AAD(0),R14		:DISPATCH TO INITIALIZATION CODE WITH:
					:	R2 = DEVICE ADDR
					:	R11 = 0
					:	R15 = UCB ADDRESS

IS2	ST	R15,RNDM		:MARK ALL REQUESTS ENDED
	ST	R15,DNDM		:MARK ALL DEVICES ENDED
	STH	R15,QX			:ZERO QX
	STH	R15,QX1			:ZERO QX1
	STH	R15,QUASIC		:INDICATE QUASI INACTIVE
	ST	R15,DSAVE		:FOR DEBUGGING
	ST	R15,DSAVE+4		:FOR DEBUGGING
	IF	SHSTAT
	ST	R15,QSTAT1		:ZERO STATISTICS COUNTERS
	ST	R15,QSTAT2
	ST	R15,QSTAT3
	ST	R15,QSTAT4
	ST	R15,QSTAT5
	EI	(SHSTAT)
	LHI	R13,(QSIZ-1)*4
IS3	ST	R11,QDATA,R13		:ZERO INT. QUEUE
	SIS	R13,4
	JGEBS	IS3
	LHI	R13,RAD(SDQ)
	ST	R13,SDQ			:INIT EDQ AND SET SDQ=0 SINCE INTERRUPTS
					: WILL BE ENABLED AS SOON AS WE RETURN FROM
					: ISHARE AND WE WANT QUEUE EMPTY SO WE CAN
					: IGNOR SPURIOUS INTERRUPTS.
:	THREAD AVAIL LIST
	LHI	R2,RAD(DPBPOL)
	LHI	R3,NDPB			:NO. OF DPB'S
	STH	R2,AVAIL
IS4	LR	R4,R2
	AHI	R2,DPBLEN
	STH	R2,AAD(PB.NXT),R4	:THREAD TO NEXT
	SIS	R3,1
	JGBS	IS4
	STH	R3,AAD(PB.NXT),R4	:0 ENDS THE THREAD
:	EMPTY WAIT QUEUE
	L	R4,SWQ
	JEFS	IS6			:SKIP IF QUEUE IS EMPTY
	ST	R3,SWQ			:EMPTY QUEUE
IS5	SHI	R4,ESWQ			:ELSE POINT AT BEGINNING OF USER BLOCK
	L	R5,ESWQ,R4		:ADDR OF NEXT ENTRY
	ST	R3,ESWQ,R4		:CANCEL WAIT
	STH	R3,DREQ,R4		:NO REQUESTS OUTSTANDING
	LR	R4,R5			:COPY NEXT ENTRY
	JNBS	IS5
IS6	LA	R5,SWQ			:INITIALIZE EWQ
	ST	R5,EWQ
	IF	NGLU
	LHI	R4,(NGLU-1)*GU.SIZ	:DETACH ALL GLOBAL UNITS
IS7	STH	R3,GUT+GU.ATT,R4
	SIS	R4,GU.SIZ
	JGEBS	IS7
	EI	(NGLU)
	IF	NDISC
:	NOW INITIALIZE OTHER STUFF
	LCS	R2,1
	IF	SYSDEV
	LHI	R4,(8-1)*4
IS8	ST	R2,DPDET,R4,		:SET NOT DETACHED
	ST	R3,DPACT,R4,		:SET NOT ACTIVE
	SIS	R4,4
	JGEBS	IS8
	STH	R3,DPUN,,
	NOP	0,,			:SPACE FOR PATCH
	ST	R3,DPBN,,
	STB	R3,DPBX,,
	STB	R3,DPLRL,,
	SBT	R3,DPACT,,		:SET COMMANDS ACTIVE
	RBT	R3,DPDET,,		:SET DETACHED JOB
	SBT	R3,NEWLOG,,		:FAKE LOGIN
	EI	(SYSDEV)
	STH	R2,DPUNIT,,		:CLEAN UP COMMANDS BUFFER
	STH	R2,DPFLAG,,
	ST	R2,DPVBNO,,
	EI	(NDISC)
	JR	R1			:RETURN TO CALLER
	IF	ESELCH


:		INITIALIZE CHANNEL BLOCK
I.CHX	OC	R2,STOP			:STOP CHANNEL I/O
	LHI	R12,RAD(CHEND1)
	STH	R12,AAD(CH.E),R15	:SET UP CHANNEL END COROUTINE
	STH	R11,AAD(CH.R),R15	:NO REQUEST PENDING
	L	R12,CHMSK
	O	R12,AAD(CB.BIT),R15
	ST	R12,CHMSK		:INCLUDE IN ALL-CHANNEL MASK
	LI	R12,7FFFFFFF		:NO TIMER ACTIVE
	ST	R12,AAD(CH.T),R15
	JFS	I.CBX1


:		INITIALIZE CONTROLLER BLOCK
I.CBX	STH	R11,AAD(UCB.STA),R15
	IF	SHSTAT
	ST	R11,AAD(UCB.NR),R15	:ZERO TOTAL NO. OF REQUESTS
	EI	(SHSTAT)
I.CBX1	LHL	R12,AAD(CB.INT),R15	:ADDR OF IMMEDIATE INT. HANDLER
	STH	R12,IMIVEC,R2,R2	:INSTALL INTERRUPT VECTOR ENTRY
	J	IS1
	IF	NDISC


:		
I.DKCB	OC	R2,RESET		:RESET CONTROLLER
	JBS	I.CBX1


:		INITIALIZE DISC UCB
I.DKU	LCS	R12,1
	STH	R12,AAD(UCB.MP),R15
	L	R14,AAD(MSMA),R15	:START OF MAP AREA
I.DKU1	ST	R12,0,R14		:MARK MAP ENTRY FREE
	AIS	R14,4
	CL	R14,AAD(MEMA),R15
	JLBS	I.DKU1			:LOOP UNTIL DONE
	ST	R11,AAD(CYLNO),R15
	ST	R11,AAD(ALTCYL),R15
	J	I.CBX
	EI	(NDISC)
	IF	NTAPE


:		INITIALIZE TAPE UCB
I.MTU	LI	R12,0FFFF^10+(XMODE+DISARM)^8
	ST	R12,AAD(MT.RIP),R15
	STH	R11,AAD(UCB.MP),R15
	OC	R2,MTCLR		:CLEAR CONTROLLER
	J	I.CBX
	EI	(NTAPE)
	EI	(ESELCH)
	IF	MSCDSK


:		INITIALIZE MSC-1400 DISK UCB
I.MSU	LHL	R12,AAD(CB.INT),R15	:ADDR OF IMMEDIATE INT. HANDLER
	STH	R12,IMIVEC,R2,R2	:INSTALL INTERRUPT VECTOR ENTRY
	STH	R11,AAD(UCB.STA),R15
	IF	SHSTAT
	ST	R11,AAD(UCB.NR),R15	:ZERO TOTAL NO. OF REQUESTS
	EI	(SHSTAT)
	LHL	R5,AAD(UCB.CDA),R15	:GET DRIVE NUMBER
	JN	I.MSU3			:SKIP IF NOT DRIVE 0 (FIRST ONE WE DO)
	TS	RECALF			:SET "RECALIBRATE" PACKET "DONE"
	LHL	R9,AAD(MS.FIFO),R15	:INITIALIZE THE FIFO RING
	LHL	R12,MSC.IT,R9		:GET POINTER TO START OF FIFO RING
	STH	R12,MSC.PT,R9		:INIT. OUR WORKING POINTER
	LHI	R12,MRSIZE-4
I.MSU1	ST	R11,MSC.FF,R9,R12	:CLEAR AREA
	SIS	R12,4
	JGEBS	I.MSU1
	OC	R2,MSC.CL		:ELSE "CLEAR" CONTROLLER
I.MSU2	SSR	R2,R12
	JTBS	8,I.MSU2		:WAIT FOR CONTROLLER TO BE "NOT BUSY"
	OC	R2,MSC.EN		:ENABLE INTERRUPTS
I.MSU3	SSR	R2,R12			:CHECK CONTROLLER
	JTBS	8,I.MSU3		:WAIT IF CURRENTLY BUSY
	LCS	R4,1			:NO "LINK" FOR "RECALIBRATE"
	JAL	R3,MSC.RE		:SET UP RECALIBRATE, ETC
	J	IS1
	EI	(MSCDSK)
	SUBTTL	GENERAL SVC TO QUEUE I/O TO SHARED DEVICES (DISKS, TAPES)

:	SVC OPERAND POINTS TO 4 WORD PARAMETER BLOCK:
:		--------.-------.----------------
:		|O| R/S |  LU   |    status     |
:		|-------------------------------|
:		|     Virtual Memory Address	|
:		|-------------------------------|
:		|	  Byte Count		|
:		|-------------------------------|
:		|	 Device Position	|
:		---------------------------------

QIOSVC	LIS	R8,QSFN			:FLAG NEW TYPE OF SVC CALL
	L	R12,F1ARG,,		:POINTER TO PARAMETER BLOCK
	LHL	R13,RPSW+2,R1		:FETCH STATUS BITS OF PSW
	LHI	R5,400			:EXAMINE MAC BIT
	NR	R5,R13
	JAL	R11,ACCESS,,		:CONVERT ADDRESS TO PHYSICAL ADDR
	LPSW	PBERR			:BAD MEMORY ACCESS---ILLEGAL SVC
	LR	R4,R12			:RETAIN ADDR OF PARAMETER BLOCK IN R4
					: THROUGHOUT HANDLER
	JAL	R11,GETDPB		:ALLOCATE A DPB OR PERHAPS GET DISMISSED
:	SET UP WITH R9 = ADDR (REL TO KER) OF UCB,
:		R8 = ADDR OF GLOBAL UNIT DESCRIPTOR,
:		R7 = BITS 0-15 OF LOCAL UNIT DESCRIPTOR
:	ALSO,	R5 = MAC BIT
:		R4 = ADDR OF PARAMETER BLOCK
QIO1	LB	R7,SVC.LU,R4		:FETCH LOCAL UNIT NO.
	CLHI	R7,NXLU
	JGE	SVCE.2
	AR	R7,R7			:MAKE HALFWORD INDEX
	LHL	R7,LUT,R1,R7		:INTO LOCAL UNIT TABLE IN USER BLOCK
	JE	SVCE.3			:IF ZERO NO SUCH UNIT
	LBR	R8,R7			:EXAMINE GLOBAL UNIT NO (LU.GUN)
	SLHLS	R8,3			:MAKE DOUBLE-WORD INDEX
	LA	R8,GUT,R8		:SET UP ADDRESS
	LHL	R9,GU.UCB,R8		:FETCH REL ADDR OF UCB
	JE	SVCE.2			:IF ZERO NO SUCH UNIT
:	CHECK TO SEE IF UNIT IS ATTACHED.  IF SO, PERHAPS THIS SLOT OWNS IT.
	LH	R6,GU.ATT,R8
	JEFS	QIO2			:IF ZERO UNIT IS NOT ATTACHED
	SIS	R6,1			:IF NONZERO SHOULD BE SLOT+1
	CLH	R6,SLOT,R1		:COMPARE SLOT IN USER BLOCK
	JN	SVCE15			:THIS ERROR SHOULD RETURN SLOT
					: OF OWNER IN "STATUS"
:	CHECK FOR VALID REQUEST CODE.  CERTAIN REQUESTS ARE PRIVILEGED.
:	ALSO SET UP THE INITIAL STATE TABLE ADDR FOR REQUEST.
QIO2	LB	R10,SVC.RS,R4		:GET REQUEST TYPE
	NHI	R10,1F			:IGNORE SUBFUNCTION & OVERLAP BITS
	LHL	R12,AAD(UCB.DVD),R9	:ADDR OF DEVICE-DESCRIPTOR BLOCK
	TBT	R10,AAD(DDB.NFU),R12	:IS THIS A LEGAL FUNCTION?
	JE	SVCE16			:IF NOT PRETEND UNIMPLEMENTED
	SLHLS	R10,2			:MAKE FULLWORD INDEX
	LHL	R6,PRVTBL,R10		:FETCH REQUEST PRIVILEGE MASK
	NR	R6,R7			:LOGICAL PRODUCT USER PRIVILEGE FOR UNIT (LU.PB)
	JE	SVCE.3			:ACCESS DENIED
	L	R6,AAD(DDB.IST),R12,R10	:NOTE INITIAL STATE TABLE IS SEPARATE
					: FROM UCB, SO THAT IT WILL NOT HAVE
					: TO BE DUPLICATED FOR EACH UNIT.
	ST	R6,AAD(PB.STA),R3	:INITIAL STATE
	LHL	R6,PRVTBL+2,R10		:GET RELATIVE FUNCTION ADDR
	J	AAD(0),R6		:DISPATCH AS APPROPRIATE FOR TYPE OF
					: REQUEST


:	TABLES FOR QIO SVC.
:	LEFT HALFWORD IS LICENCES...RIGHT HW IS ADDRESS OF HANDLER
PRVTBL	HC	RD,RAD(QIOF0)		:00 - READ
	HC	WR,RAD(QIOF1)		:01 - WRITE
	HC	AT,RAD(QIOF2)		:02 - ATTACH
	HC	AT,RAD(QIOF3)		:03 - DETACH
	HC	RD!WR,RAD(QIOF4)	:04 - BACKSPACE
	HC	RD!WR,RAD(QIOF5)	:05 - SKIP FILE FWD
	HC	RD!WR,RAD(QIOF6)	:06 - SKIP FILE REV
	HC	WR,RAD(QIOF7)		:07 - WRITE FILE MARK
	HC	RD!WR,RAD(QIOF8)	:08 - REWIND
	HC	RD!WR,RAD(QIOF9)	:09 - UNLOAD
	HC	RD!WR,RAD(QIOFA)	:0A - GET STATUS
	HC	WR,RAD(QIOFB)		:0B - ERASE GAP
	HC	RD!WR,RAD(QIOFC)	:0C - SET LOW DENSITY
	HC	AT,RAD(QIOFD)		:0D - MOUNT DISC & DETACH
	HC	AT,RAD(QIOFE)		:0E - DISMOUNT DISC & ATTACH



:		MOUNT - DISMOUNT

:	***NOTE DESIGN ERROR--NEEDS SUPER ATTACH TO PREVENT ACCESS***
:	***BY OVERLAPPING AREAS.  PUT SUPER ATTACH SWITCH INTO UCB.***

:	MOUNT & DISMOUNT ARE PRIVILEGED COMMANDS.  DISMOUNT ATTACHES
:	A DISC AND ENTERS A REQUEST TO DISABLE CYLINDER MAPPING.  SO LONG
:	AS A DISC IS DISMOUNTED, SUBSEQUENT REQUESTS TO
:	READ/WRITE FORMAT OR READ CHECK WILL BE HONORED.  THE MOUNT COMMAND
:	SHOULD THEN BE ISSUED WHICH DETACHES THE DISC AND
:	MARKS CYLINDER MAPS AS NEEDING TO BE READ.

:	MOUNT
QIOFD	LIS	R12,0
	JFS	QIOFE1

:	DISMOUNT
QIOFE	LHL	R12,SLOT,R1		:GET SLOT NO.
	AIS	R12,1			:BIAS BY ONE (0 => NOT ATTACHED)
QIOFE1	LH	R10,UFLAG,R1
	THI	R10,FDDT			:ALLOWED ONLY TO DDT USERS
	JE	SVCE.3			:NOT ALLOWED
	LH	R10,ULICEN,R1
	THI	R10,L.SYP!L.DISC		:CHECK PRIVILEGES
	JE	SVCE.3			:NOT ALLOWED
	STH	R12,GU.ATT,R8		:SAVE SLOT NO.+1 IN GLOBAL UNIT DESCRIPTOR
	LIS	R5,0			:NOT A MAP REQUEST
	J	EDPB1			:ENTER REQUEST ON I/O QUEUE




:		GET STATUS

:	GET STATUS
QIOFA	JAL	R10,PARRW		:CHECK READ-WRITE ACCESS TO PARAMETER BLOCK
	STH	R7,SVC.PB,R4		:PLACE PB AND GLOBAL UNIT NO.
	L	R6,AAD(UCB.NA),R9	:PLACE NAME FIELD, TYPE, & DEV. ADDR
	ST	R6,SVC.NA,R4
	LHL	R6,AAD(UCB.DDB),R9	:PLACE DEFAULT BLOCK SIZE
	STH	R6,SVC.DD,R4
	LB	R6,AAD(UCB.TY),R9	:GET TYPE
	SIS	R6,1			:CHECK FOR MT
	JEFS	QIOFA1			:SKIP IF SO
	L	R6,AAD(UCB.BGN),R9	:ELSE GET SECTORS/TRACK | TRACK/CYLINDER
QIOFA1	ST	R6,SVC.BT,R4
	L	R6,GU.STC,R8		:PLACE START/NUMBER OF CYLINDERS
	ST	R6,SVC.SC,R4
	J	EDPB			:GO READ DEVICE STATUS BITS




:		ATTACH/DETACH

:	ATTACH
QIOF2	LHL	R6,SLOT,R1		:GET SLOT NO.
	AIS	R6,1			:BIAS BY ONE (0 => NOT ATTACHED)
	STH	R6,GU.ATT,R8		:STORE IN GLOBAL UNIT DESCRIPTOR
	J	EDPB			:ENTER DPB ONTO QUEUE, THEN QUEUE HANDLER.
					: WILL RETURN DEVICE STATUS TO
					: PARAMETER BLOCK
:	DETACH
QIOF3	LIS	R6,0
	STH	R6,GU.ATT,R8		:STORE IN GLOBAL UNIT DESCRIPTOR
	J	EDPB			:ENTER DPB ONTO QUEUE, THEN QUEUE HANDLER.



:		READ OR WRITE BLOCK


QIOF0	JAL	R10,PARRW		:CHECK READ-WRITE ACCESS TO PARAMETER
					: BLOCK.  COUNT WILL BE UPDATED.
QIOF1	LCS	R12,2
	N	R12,SVC.VA,R4		:ASSURE EVEN MEMORY ADDR
	L	R13,SVC.CT,R4		:FETCH BYTE COUNT
	JNFS	QIOF1A			:SKIP IF NON-ZERO
	LHL	R13,AAD(UCB.DDB),R9	:ELSE USE DEFAULT BLOCKSIZE
	JFS	QIOF1B
QIOF1A	THI	R13,1			:IS BYTE COUNT EVEN?
	JN	SVCE.A			:NO, ERROR
QIOF1B	AR	R13,R12			:LAST MEM ADDR + 1
	SIS	R13,1
	LR	R5,R5			:WAS MAC BIT SET?
	JEFS	QIOF1D			:NO, ALREADY HAVE PHYSICAL ADDR
	LR	R11,R0			:CHECK IF READ OR WRITE
	JEFS	QIOF1C			:DISK READ
	LHI	R11,RRO-RRW		:DISK WRITE
QIOF1C	JAL	R11,RRW,R11,		:CHECK MEM WRITE ACCESS
	J	SVCE.1
	LHL	R3,BPA			:RESTORE BP--SMASHED BY RRO OR RRW
					: ONLY R0,R1,R4,R7,R8,R9 ARE SAFE
QIOF1D	LB	R6,AAD(UCB.TY),R9	:GET DEVICE TYPE
	SLHLS	R6,2			:MAKE WORD INDEX
	J	QIOF1E,R6		:GO TO APPROPRIATE HANDLER FOR DEVICE TYPE

QIOF1E	J	QIODK			:DK
	J	QIOMT			:MT
	J	QIOMS			:MS

QIOMS	IF	MSCDSK

:		MSC-1400 DISK
	L	R15,SVC.VB,R4		:GET POSITION TO R15
	JL	SVCE.4			:MUST BE .GE. 0
	LH	R5,AAD(UCB.MP),R9	:IS DISK UNMOUNTED?
	AIS	R5,2
	JE	QIOMS1			:SKIP AREA CHECKS IF SO
	LHL	R10,GU.NCY,R8		:NO. OF CYLS IN DISK AREA
	MH	R10,AAD(MS.BPC),R9	:TIMES NO. OF BLOCKS/CYLINDER
					: R10 IS ONE PAST END OF AREA
	SR	R10,R15			:COMPUTE SPACE FROM START-OF-BLOCK
					: TO END-OF-AREA
	JLE	SVCE.4			:STARTING BLOCK IS PAST END OF AREA
	L	R14,SVC.CT,R4		:FETCH BYTE COUNT TO TRANSFER INTO R14
	LHI	R5,-1,R14		:SIZE - 1
	AH	R5,AAD(UCB.DDB),R9	:DEFAULT (SECTOR) SIZE
	DH	R5,AAD(UCB.DDB),R9	:NO. OF BLOCKS -> R6
	SR	R10,R6			:COMPUTE SPACE FROM END-OF-BLOCK TO
					: END-OF-AREA
	JL	SVCE.4			:ATTEMPT TO ACCESS PAST END OF DISK AREA
QIOMS1	LHL	R5,GU.STC,R8		:START CYLINDER
	MH	R5,AAD(MS.BPC),R9	:COMPUTE START SECTOR
	AR	R15,R5			:ADD TO USER'S STARTING BLOCK NUMBER
	CL	R15,AAD(MS.MXS),R9	:COMPARE MAX NO. OF SECTORS FOR UNIT
	JGE	SVCE.5			:PROBLEM WITH GLOBAL UNIT TABLES
	LA	R6,AAD(PB.UCB),R3	:SET UP FOR PACKET ADDRESSING
	ST	R12,PK.SMA,R6		:PUT IN START MEMORY ADDRESS
        ST      R12,PK.XMA,R6           :SPARE COPY FOR RETRIES
	STM	R14,PK.WC,R6		:PLACE BYTE COUNT INTO PACKET
					:  AND SET UP LOGICAL SECTOR ADDRESS
        STM     R14,PK.XWC,R6           :SPARE COPY FOR RETRIES
	LB	R5,SVC.RS,R4		:LOOK UP READ/WRITE
	NHI	R5,0F
	LB	R5,MSCCMD,R5		:NOW LOOK UP READ/WRITE COMMAND
	STH	R5,PK.CMD,R6
	LIS	R5,0
        STH     R2,PK.RTC,R6            :CLEAR PACKET RETRY COUNT
	ST	R5,AAD(PB.RTY),R3	:CLEAR RETRY COUNTER
	J	EDPB1			:AND SKIP
	EI	(MSCDSK)

QIOMT	IF	NTAPE

:		MAG TAPE
	LIS	R5,0			:SET NO MAP
	J	EDPB1			:AND SKIP
	EI	(NTAPE)

QIODK	IF	NDISC

:		DISC
	LH	R5,AAD(UCB.MP),R9	:IS DISK UNMOUNTED
	JL	QIODK1			:SKIP AREA CHECKS IF SO
	LHL	R10,GU.NCY,R8		:NO. OF CYLS IN DISK AREA
	MH	R10,AAD(DK.BPC),R9	:TIMES NO. OF BLOCKS/CYLINDER
					: R10 IS ONE PAST END OF AREA
	CL	R10,SVC.VB,R4		:COMPARE SPECIFIED BLOCK NO. TO START
	JLE	SVCE.4			:STARTING BLOCK IS PAST END OF AREA
	L	R5,SVC.CT,R4		:FETCH BYTE COUNT TO TRANSFER
	AH	R5,AAD(UCB.DDB),R9	:ADD BLOCKSIZE-1
	SIS	R5,1
	DH	R5,AAD(UCB.DDB),R9	:NO. OF BLOCKS -> R6
	A	R6,SVC.VB,R4		:R6 NOW CONTAINS NEXT BLOCK NO. TO TRANSFER
	CLR	R10,R6			:R10 IS ONE PAST AREA
	JL	SVCE.4			:TRANSFER PAST END OF AREA
QIODK1	L	R5,SVC.VB,R4
	DH	R5,AAD(DK.BPC),R9	:CYL NO -> R6 BLOCKS REMAINING -> R5
	AH	R6,GU.STC,R8		:ADD STARTING CYL NO FOR DISK AREA
	CLH	R6,AAD(DK.MXC),R9	:COMPARE MAX NO. OF CYL FOR UNIT
	JGE	SVCE.5			:PROBLEM WITH GLOBAL UNIT TABLES
	STH	R6,AAD(PB.CYL),R3	:SAVE STARTING CYL NO.
	DH	R5,AAD(DK.BPT),R9	:DIVIDE BY BLOCKS/TRACK
					: HEAD NO. -> R6 BLOCKS REMAINING -> R5
	CLH	R6,AAD(DK.MXH),R9	:COMPARE MAX NO. OF HEADS FOR UNIT
	JGE	SVCE.5			:PROBLEM WITH DK.BPT PARAMETER
	ST	R5,AAD(PB.RTY),R3	:SAVE RECORD NO. AND CLEAR RETRY CTR
	STH	R6,AAD(PB.HED),R3	:SAVE HEAD NO. AND FALL THRU TO EDPB
	EI	(NDISC)



:	THE FOLLOWING REQUESTS ARE EQUIVALENT TO DIRECT CALLS TO EDPB

QIOF4
QIOF5
QIOF6
QIOF7
QIOF8
QIOF9
QIOFB
QIOFC
:	ENTER DEVICE PARAMETER BLOCK ONTO I/O QUEUE.  FOR DISK
:	DEVICES CHECK TO SEE IF CYLINDER MAP IS MOUNTED, AND IF NOT,
:	CAUSE REPOP OF SVC CALL AND ENTER A DPB TO READ THE CYL MAP.

:	EXPECTS R1 = ADDR OF USER BLOCK
:		R3 = (REL ADDR) OF DPB
:		R4 = ADDR OF USER'S PARAMETER BLOCK DESCRIBING REQUEST
:		R9 = (REL ADDR) OF UNIT CONTROL BLOCK
:		R12 = STARTING MEMORY ADDR FOR DATA TRANSFER
:			IGNORED BY QUEUE SCANNER IF REQUEST IS NOT READ OR WRITE
:		R13 = ENDING MEMORY ADDR FOR DATA TRANSFER

EDPB	LH	R5,AAD(UCB.MP),R9	:WILL BE ZERO EXCEPT FOR DISCS
	IF	NDISC
	JE	EDPB1			:PROBLEM WITH MAP IF NONZERO
:	CYLINDER MAPS HAVE NOT BEEN READ ON THIS UNIT.
	JG	SVCE.E			: +1 = MAPS COULD NOT BE READ
					: -1 = MAPS NOT READ
					: 0 = MAPS ALREADY READ
					: -2 = MAPS DISABLED(DISC UNMOUNTED)
	AIS	R5,2			:CHECK DISMOUNTED DISC
	JE	EDPB1			:DISMOUNTED--OK TO PROCEED UNMAPPED
	LCS	R5,1
:	CHANGE THIS DPB TO DESCRIBE MAP READ AND REPOP SVC
	L	R12,AAD(MSMA),R9		:STARTING MEM ADDR FOR THIS UNIT'S MAP
	L	R13,AAD(MEMA),R9		:ENDING MEM ADDR
	LHL	R6,AAD(MREC),R9		:RECORD NO.
	ST	R6,AAD(PB.RTY),R3	:SAVE RECORD NO. AND CLEAR RETRY CTR
	L	R6,AAD(MCYL),R9		:CYLINDER AND HEAD NO.
	ST	R6,AAD(PB.CYL),R3	:NOTE ALIGNMENT OF PB.CYL|PB.HED IN DPB
	LHL	R6,AAD(UCB.DVD),R9	:(REL ADDR) OF DEVICE DESC BLK
	L	R6,AAD(DDB.IST),R6	:FIRST ENTRY IS FOR READ
	ST	R6,AAD(PB.STA),R3	:ASSURE READ REQUEST FOR MAP
					: NOTE MAP SWITCH WILL BE NONZERO
	EI	(NDISC)
EDPB1	STH	R5,AAD(PB.MAP),R3	:SWITCH WILL BE TESTED BY "READ"
					: TO SAVE A LOT OF DUPLICATED STATES
					: TO PERFORM A "MAP READ".
	ST	R12,AAD(PB.SMA),R3	:STARTING MEMORY ADDR
	ST	R13,AAD(PB.EMA),R3	:ENDING MEMORY ADDR
	ST	R1,AAD(PB.USR),R3	:ADDR OF USER BLOCK
	ST	R4,AAD(PB.PRM),R3	:ADDR OF PARAMETER BLOCK
	L	R5,AAD(UCB.DM),R9	:DEVICE MASK INDICATING THE PARTICULAR
					: CHANNEL, CONTROLLER, AND UNIT
					: REQUIRED BY THIS REQUEST
	ST	R5,AAD(PB.HUI),R3	:STORE HARDWARE UNIT INTERLOCK MASK
	ST	R5,AAD(PB.SUI),R3	:STORE SOFTWARE UNIT INTERLOCK MASK
	STH	R9,AAD(PB.UCB),R3	:REL UCB ADDR
	LM	R14,EDPB2		:DESTROYS S3-S4
	LIS	R5,1
	IF	SHSTAT
	AM	R5,AAD(UCB.NR),R9	:COUNT OF REQUESTS FOR UNIT
	EI	(SHSTAT)
	LHI	R6,S.PSW		:USE TO DISABLE INTS
	EPSR	R7,R6			:*F*INTS DISABLED
	AHM	R5,DREQ,R1		:*F*COUNT I/O REQUESTS
	LHL	R5,EDQ			:*F*(REL ADDR) OF END OF QUEUE
					: POINTS TO SDQ IF QUEUE IS EMPTY
	STH	R3,AAD(PB.NXT),R5	:*F*LINK PREV TO CURRENT
	STH	R3,EDQ			:*F*FIXUP END
	L	R5,DNDM			:*F*FETCH MASK OF OUTSTANDING INTS
	IF	NTAPE
	NI	R5,TPBITS
	EI
	JNFS	EDPB3			:*F*DON'T RUN QUASI IF INTS PENDING
	TS	QUASIC			:*F*SHOULD WE RUN QUASI CODE?
	JLFS	EDPB3			:*F*IF GE YES
	STM	R14,DSAVE		:*F*SETUP RETURN FROM QUASI CODE
	LPSW	DDP			:*F*ENTER QUEUE SCANNER (NORMALLY
					: RUNS WITH INTS ENABLED AS QUASI-
					: LEVEL TO DEVICE INT HANDLER)
EDPB2	WC	S.PSW!I.ENA,EDPB4
EDPB3	EPSR	R6,R7			:*F*ENABLE INTS
EDPB4	LH	R5,AAD(PB.MAP),R3	:IS THIS A MAP READ REQUEST?
	JN	EDPB6			:IF NONZERO YES
	CLI	R4,CBUF			:IS THIS OUR COMMAND-HANDLING REQUEST?
	JE	EDPB6			:YES...ABORT AND WAIT TO RE-EXECUTE SVC LATER
	LB	R5,SVC.RS,R4		:GET BYTE WITH OVERLAP BIT (THIS SHOULD
					: ALSO WORK FOR OLD-STYLE PARAMETER BLOCK)
	NHI	R5,80			:MASK OVERLAP BIT
	JEFS	EDPB5			:IF ZERO DISMISS USER
	LHL	R5,DQUOTA,R1		:IS USER EXCEEDING QUOTA?
	CLH	R5,DREQ,R1		:COMPARE REQUESTS OUTSTANDING
	JG	KRET,,			:IF QUOTA>DREQ RETURN TO USER
EDPB5	HS	0
 if     SPAM
  if     SPMTRC
          LHI     R10,22                :SPAM TRACE ROUTINE ID
  ei     (SPMTRC)
          JAL     R9,ENTIM,,            :COLLECT END DATA
 ei     (SPAM)
	LA	R15,MAIN,,		:ENTER ISIS MAIN LOOP
	JFS	EDPB7			:AND SKIP
EDPB6	LA	R15,REPOP,,		:FIXUP SO SVC RUNS AGAIN
:	SET USER FLAG TO DISMISS USER UNTIL HIS QUEUED I/O IS COMPLETE
EDPB7	LHI	R7,FDSK1
	LHI	R5,20F0
	LIS	R6,0
	EPSR	R14,R5			:*F*DISABLE INTS.
	LH	R5,DREQ,R1		:*F*CHECK I/O COUNT TO AVOID RACE
	JEFS	EDPB8			:*F*WITH ALL DONE
	OH	R7,WFLAG,R1		:*F***
	STH	R7,WFLAG,R1		:*F***
	STH	R6,QUANTUM,R1		:*F*CANCEL QUANTUM REMAINING
EDPB8	LPSWR	R14			:*F*ENABLE INTERRUPTS, EXITING TO KERNEL

	IF	SUP
	SUBTTL	OBSOLETE DISK SVC CALLS

:	ENTER HERE FOR SECTOR DISK SVC

DISKS	LIS	R4,8			:SHIFT SECTOR COUNT BY 8 FOR BYTE COUNT
	STH	R4,DSKSF1
	LHI	R4,30			:# OF SECTOR PER CYLINDR
	STH	R4,DSKMPL
	LIS	R4,0			:SHIFT SECTOR COUNT FOR SECTOR COUNT
	STH	R4,DSKSF2
	JFS	DISK			:USE COMMON CODE WITH BLOCK DISK SVC

:	ENTER HERE FOR BLOCK DISK SVC

DISKB	LIS	R4,0A			:SHIFT BLOCK COUNT BY 0A FOR BYTE COUNT
	STH	R4,DSKSF1
	LIS	R4,0C			:# OF BLOCKS PER CYLINDER
	STH	R4,DSKMPL
	LIS	R4,2			:SHIFT BLOCK COUNT FOR SECTOR COUNT
	STH	R4,DSKSF2

:	COMMON CODE FOR BLOCK & SECTOR DISK SVC'S

DISK	LIS	R8,0			:FLAG OLD TYPE OF SVC
	L	R12,F1ARG,,		:POINTER TO PARAM BLOCK
	LHL	R13,RPSW+2,R1		:STATUS BITS OF USER PSW
	LHI	R5,0400
	NR	R5,R13			:R5 = 0 IF NOT MAC'ED
	JAL	R11,ACCESS,,		:CHECK ACCESS & CONVERT TO PHYSICAL ADDR
	LPSW	PBERR			:BAD ACCESS---ILLEGAL SVC
	LR	R4,R12
	JAL	R11,GETDPB		:ALLOCATE DPB
	LCS	R12,2			:INSURE EVEN VALUE OF
	N	R12,8,R4			:...START MEM ADDR
	LHL	R13,2,R4			:BLOCK COUNT
	JE	SVCE.A			:ZERO BLOCK TRANSFER NOT VALID
	LHL	R15,DSKSF1		:SHIFT COUNT TO CONVERT TO BYTE COUNT
	SLL	R13,0,R15
	AR	R13,R12			:LAST MEM ADDR + 1
	SIS	R13,1
	LIS	R0,1			:CHECK READ OR WRITE
	NH	R0,0,R4			:USER'S REQUEST
	LR	R5,R5			:WAS MAC BIT SET
	JEFS	DISK2			:NO - ALREADY HAVE PHYSICAL ADDRS
	LR	R11,R0			:CHECK IF READ OR WRITE
	JEFS	DISK1			:DISK READ
	LHI	R11,RRO-RRW		:DISK WRITE
DISK1	JAL	R11,RRW,R11,		:CHECK MEM WRITE ACCESS
	J	SVCE.1			:NO ACCESS
	LHL	R3,BPA			:RESTORE BP--SMASHED BY RRO OR RRW
DISK2	LHL	R6,6,R4			:USER'S VIRTUAL DISK ADDR
	EXBR	R7,R6
	SRHLS	R7,5			:RIGHT JUSTIFY AREA NUMBER
	NHI	R7,7			:ISOLATE AREA NUMBER
:	ENTER WITH R7 = AREA NO. (LOCAL UNIT NO.)
:	SET UP WITH R9 = (REL ADDR) OF UCB,
:		R8 = ADDR OF GLOBAL UNIT DESCRIPTOR,
:		R7 = BITS 0-15 OF LOCAL UNIT DESCRIPTOR
:	ALSO,
:		R5 = MAC BIT
:		R4 = ADDR OF PARAMETER BLOCK

	CLHI	R7,NXLU
	JGE	SVCE.2
	AR	R7,R7			:MAKE HALFWORD INDEX
	LHL	R7,LUT,R1,R7		:INTO LOCAL UNIT TABLE IN USER BLOCK
	JE	SVCE.2			:IF ZERO NO SUCH UNIT
	LBR	R8,R7			:EXAMINE GLOBAL UNIT NO
	SLHLS	R8,3			:MAKE DOUBLE-WORD INDEX
	LA	R8,GUT,R8		:COMPUTE ADDRESS
	LHL	R9,GU.UCB,R8		:FETCH REL ADDR OF UCB
	JE	SVCE.2			:IF ZERO NO SUCH UNIT

:	CHECK TO SEE IF UNIT IS ATTACHED.  IF SO, PERHAPS THIS SLOT OWNS IT.

	LH	R6,GU.ATT,R8
	JEFS	DISK3			:IF ZERO UNIT IS NOT ATTACHED
	SIS	R6,1			:IF NONZERO SHOULD BE SLOT+1
	CLH	R6,SLOT,R1		:COMPARE SLOT IN USER BLOCK
	JN	SVCE15			:THIS ERROR SHOULD RETURN SLOT
					: OF OWNER IN "STATUS"
:	CHECK FOR PRIVILEGED REQUEST FOR THIS AREA (UNIT)
:	ALSO SET UP THE INITIAL STATE TABLE ADDR FOR REQUEST.
DISK3	LR	R10,R0			:COPY REQUEST TYPE
	SLHLS	R10,2			:MAKE FULLWORD INDEX
	LHL	R6,PRVTBL,R10		:FETCH REQUEST PRIVILEGE MASK
	NR	R6,R7			:LOGICAL PRODUCT USER PRIVILEGE FOR UNIT
	JE	SVCE.3			:ACCESS DENIED
	LHL	R7,AAD(UCB.DVD),R9
	TBT	R0,AAD(DDB.NFU),R7
	JE	SVCE16
	L	R6,AAD(DDB.IST),R7,R10	:NOTE INITIAL STATE TABLE IS SEPARATE FROM
					: UCB, SO THAT IT WILL NOT HAVE TO BE DUPLICATED
					: FOR EACH UNIT.
	ST	R6,AAD(PB.STA),R3	:INITIAL STATE
	LHL	R6,6,R4			:USER'S VIRTUAL DISK ADDR
	LHL	R7,GU.NCY,R8		:# OF CYLINDERS IN THIS AREA
	MH	R7,DSKMPL		:TIMES # OF BLOCKS OR SECTORS PER CYL IS SIZE
	SIS	R7,1			:NUMBER OF LAST PERMISIBLE BLOCK
	NHI	R6,1FFF			:ISOLATE BLOCK NUMBER OF USER VIRT DISK ADDR
	CLR	R6,R7			:IS IT WITHIN PHYSICAL AREA
	JG	SVCE.4			:NO...BAD ADDRESS
	LHL	R10,2,R4			:BLOCK COUNT
	AR	R10,R6			:LAST BLOCK + 1
	SIS	R10,1			:NUMBER OF LAST BLOCK
	CLR	R10,R7			:IS IT WITHIN PHYSICAL AREA
	JG	SVCE.4			:NO...BAD ADDRESS
	LIS	R10,0			:ASSUME HEAD 0
	LHL	R15,DSKSF2		:COUNT TO CONVERT START NUMBER TO SECT COUNT
	SLL	R6,0,R15			:CONVERT BLOCK TO SECTOR COUNT
	DH	R6,THIRTY		:DIVIDE BY 30 HEX (SECTORS/CYL)
	AH	R7,GU.STC,R8		:ADD STARTING CYL NO. = CYL NO. FOR TRANSFER
	CLHI	R7,198			:IS CYL NO. LEGAL
	JGE	SVCE.5			:ERROR SHOULD NEVER HAPPEN
	CLHI	R6,18			:CHECK IF HEAD 0
	JLFS	DISK4			:YES
	SHI	R6,18			:CORRECT SECT NO.
	LIS	R10,1			:SET HEAD 1
DISK4	STH	R7,AAD(PB.CYL),R3	:STORE CYL NO. IN DPB
	ST	R6,AAD(PB.RTY),R3	:SAVE RECORD NO. AND CLEAR RETRY CTR
	STH	R10,AAD(PB.HED),R3	:DITTO HEAD NO.
	J	EDPB			:FINISH UP
	EI	(SUP)
	SUBTTL	ERROR RETURNS FROM SVC HANDLER

:	ALL ERROR EXITS RETURN DPB BACK TO AVAIL LIST.

:	CYLINDER MAP COULD NOT BE READ.
SVCE.E	LCS	R6,1			:SET MAP SWITCH IN UNIT SO WE CAN RETRY
	STH	R6,AAD(UCB.MP),R9	:INDICATE MAP NOT READ
	LIS	R5,ERR.14
	IF	SUP
	LH	R6,AAD(PB.NEW),R3	:CHECK NEW/OLD FLAG
	NHI	R6,0FF			:MASK SUBFUNCTION BITS
	JE	SVCE.			:NO STATUS RETURNED IF OLD
	EI	(SUP)
	LHL	R6,AAD(UCB.STA),R9	:FETCH STATUS LAST UNIT OPERATION
	JFS	SVCE.Y
:	UNIT ALREADY ATTACHED - R6 = SLOT NO. OF OWNER
SVCE15	LHI	R5,ERR.21
SVCE.Y	STH	R6,SVC.ST,R4
	J	SVCE.
:	UNIMPLEMENTED REQUEST TYPE
SVCE16	LHI	R5,ERR.22
	JFS	SVCE.
:	BAD MEMORY ACCESS
SVCE.1	LHL	R3,BPA			:RESTORE R3 (SMASHED BY RRW,RR0)
	LIS	R5,ERR.01
	JFS	SVCE.
:	NO SUCH UNIT
SVCE.2	LIS	R5,ERR.02
	JFS	SVCE.
:	PRIVILEGED REQUEST TYPE
SVCE.3	LIS	R5,ERR.03
	JFS	SVCE.
:	ACCESS OUTSIDE AREA
SVCE.4	LIS	R5,ERR.04
	JFS	SVCE.
:	BAD TABLES
SVCE.5	LIS	R5,ERR.05
	JFS	SVCE.
:	ODD BYTE COUNT
SVCE.A	LIS	R5,ERR.10
:	COMMON ERROR EXIT
SVCE.	STB	R5,SVC.RS,R4		:STORE ERROR CODE IN REQUEST BYTE
	LHI	R5,S.PSW
	EPSR	R6,R5			:*F*DISABLE INTS.
	LHL	R4,AVAIL		:*F*RETURN DPB
	STH	R3,AVAIL		:*F*TO AVAIL LIST
	STH	R4,AAD(PB.NXT),R3	:*F*DPB'S NORMALLY RETURNED BY I/O-Q SCANNER
	EPSR	R5,R6			:*F*ENABLE INTS.
	J	KRET,,			:RETURN TO USER
	SUBTTL	SVC LIBRARY ROUTINES


:	ALLOCATE A DEVICE PARAMETER BLOCK (DPB) FROM THE AVAIL POOL.
:		IF NO DPB IS AVAIL, GIVE UP TIME SLICE AND REPOP SVC.

:		ENTER WITH T5=NEW/OLD SVC FLAG (0=OLD)
:		EXIT WITH BP=(REL ADDR) OF DPB
:		SMASHES R12,R13,R14,R15

GETDPB	LIS	R15,0
	LHI	R13,S.PSW		:USE TO DISABLE INTS
	EPSR	R14,R13			:*F*DISABLE INTS
	LHL	R3,AVAIL		:*F*GET DPB (REL ADDR)
	JE	DPBWT			:*F*IF ZERO, POOL EXHAUSTED
	LHL	R12,AAD(PB.NXT),R3	:*F*FETCH FORWARD R11
	STH	R12,AVAIL		:*F*FIXUP HEAD
	EPSR	R13,R14			:*F*RESTORE INTERRUPTS
	STH	R3,BPA			:SAVE R3 (SMASHED BY RRO,RRW)
	STH	R15,AAD(PB.NXT),R3	:ZERO FORWARD LINK--DPB WILL BE PLACED
					: AT END OF I/O QUEUE
	STH	R8,AAD(PB.NEW),R3	:SAVE NEW/OLD FLAG
	IF	MSCDSK
	LA	R12,AAD(PB.UCB),R3	:SET UP FOR PACKET ADDRESSING
	LCS	R13,1
	ST	R13,PK.LNK,R12		:SET UP R11
	LIS	R13,0
	ST	R13,PK.CMD,R12		:SET COMMAND (NULL) | STATUS
	ST	R13,PK.FAU,R12		:SET FAULT | RECORD ID 1
	ST	R13,PK.FAU+4,R12		:SET RECORD ID 2 | RECORD ID 3
	EI
	JR	R11

DPBWT	L	R12,ESWQ,R1		:*F*SINGLE NODE AVAIL LIST PER USER BLOCK
	JNFS	BWS1			:*F*IF ZERO NODE IS ALREADY
					: ON THE BUFFER WAIT QUEUE
	L	R12,EWQ			:*F*RETRIEVE END PTR.  POINTS TO SWQ IF
					: WAIT QUEUE IS EMPTY.
	LA	R13,ESWQ,R1		:*F*MAKE R11 FOR THIS USER-BLOCK
	ST	R13,ESWQ,R12		:*F*MAKE OLD END POINT TO NEW
					: FIXES SWQ IF QUEUE IS EMPTY
	ST	R13,EWQ			:*F*FIXUP END PTR.
BWS1	LHI	R13,FDSK2		:*F*SET BUFFER WAIT FLAG TO DISMISS USER
	OH	R13,WFLAG,R1		:*F*UNTIL I/O QUEUE HANDLER FREES A DPB.
	STH	R13,WFLAG,R1		:*F*USER WILL THEN BE AWAKENED.
	EPSR	R13,R14			:*F*ENABLE INTS
	J	REPOP,,			:GO CANCEL SVC, DISMISS USER...


:	PARRW - CHECK THAT ENTIRE PARAMETER BLOCK IS READ-WRITE

PARRW	LR	R5,R5			:CHECK MAC BIT
	JER	R10			:PARAMETER BLOCK ADDR IS PHYSICAL
	L	R12,F1ARG,,		:CALC VIRTUAL ADDRESS OF LAST
	AHI	R12,11			:  BYTE IN PARAMETER BLOCK
	JAL	R11,TTRW,,		:CHECK READ-WRITE ACCESS
	J	SVCE.1			:FAILED
	JR	R10			:RETURN
	SUBTTL	QUASI-LEVEL INTERRUPT ROUTINES



:		QUEUE SCANNER FOR SHARED DEVICES

:	RUNS WITH INTERRUPTS ENABLED AND IN REGISTER SET F
:	OLD PSD SHOULD BE SAVED AT DSAVE PRIOR TO CHANGING PSD
:	TO BEGIN EXECUTION AT DD.
:	ALL REGISTERS PRESERVED

DD	STM	R6,DSAVE+8		:SAVE REGS R6-R15 (USED BY SCANNER)
	IF	SHSTAT
	LIS	R6,1			:USED TO INCREMENT COUNTERS
	AM	R6,QSTAT2		:COUNT NO. OF TIMES QUASI RUNS
	EI	(SHSTAT)
	L	R14,RNDM		:LOAD REQUEST MASK
	L	R15,DNDM		:LOAD DEVICE END MASK

:		SERVICE IMMEDIATE INTERRUPT QUEUE.
:	QUEUE MAY HAVE ONE OR MORE POINTERS (WORD) TO ENTRIES OF FORM:
:		HC	DUCBn		:(RELATIVE TO LSHARE)
:		HC	HANDLER		:(RELATIVE TO LSHARE)
	LH	R13,QX1			:LOAD QUASI QUEUE INDEX
	JFS	DD2			:AND SKIP

:	ADVANCE TO NEXT ENTRY IN INTERRUPT QUEUE
DD1	LH	R13,QNXT,R13
DD2	CLH	R13,QX			:COMPARE HARDWARE QUEUE INDEX
	JE	USCAN0			:QUEUE EMPTY...USCAN0 WILL FIXUP QX1

DD3	L	R11,QDATA,R13		:LOAD LINKAGE ADDR
	IF	SHSTAT
	JNFS	DD4			:SKIP IF NOT NULL
	S.HLTE(0A63)
DD4	LIS	R12,0			:***REMOVE LATER***
	ST	R12,QDATA,R13		:***REMOVE LATER***
	EI	(SHSTAT)
	LHL	R12,0,R11		:LOAD UCB (REL ADDR)
	LHL	R10,2,R11		:GET HANDLER ADDRESS
	JN	AAD(0),R10		:DISPATCH TO QUASI-INT ROUTINE
					: WITH R12 = RELATIVE UCB ADDR
					:	R13 = QUASI QUEUE INDEX
					:	R14 = REQUEST END MASK
					:	R15 = DEVICE END MASK
	S.HLTE(0863)		:INVALID ADDRESS
	IF	ESELCH


:	****	CHANNEL END    ****
CHEND	LH	R11,AAD(CB.DA),R12	:GET DEVICE ADDR
RCHEND	EQ	RAD(CHEND)		:RELATIVE ADDRESS, CHANNEL END ROUTINE
	OC	R11,STOP		:STOP ESELCH
	LHL	R10,AAD(CH.E),R12	:LOAD CHANNEL END COROUTINE ADDR
	J	AAD(0),R10		:DISPATCH
CHEND1	LHI	R10,RAD(DVEND)		:MODIFY COROUTINE ADDR TO IGNORE
	STH	R10,AAD(CH.E),R12	:...SPURIOUS CHANNEL INTERRUPTS


:	****	DEVICE END    ****
DVEND	N	R15,AAD(CB.NBIT),R12	:MARK DEVICE END BY MASKING
RDVEND	EQ	RAD(DVEND)		:RELATIVE ADDRESS, DEVICE END ROUTINE
					: HARDWARE BUSY BIT
	J	DD1
	EI	(ESELCH)
	IF	MSCDSK


:	****	MSC-1400 END    ****
MSEND	LHI	R9,-PB.UCB,R11		:COMPUTE START ADDRESS OF PCB
	LHI	R10,RAD(MSEXIT)		:SET END ADDRESS
	STH	R10,PB.STA,R9		: ...INTO PCB (NOTE USE OF ABSOLUTE BASE ADDRESS)
	J	DD1			:AND PROCEED TO NEXT ENTRY
	EI	(MSCDSK)
	SUBTTL	UNIT SCANNER

:	THIS SCANNER PASS PROCESSES ALL REQUESTS FOR WHICH
:	REQUISITE HARDWARE IS NOT BUSY.  ALSO, WHEN A REQUEST
:	IS BEING PROCESSED IT SETS THE UNIT BIT IN THE REQUEST END
:	MASK (RNDM = R14) SO THAT NO OTHER REQUESTS
:	MAY BE STARTED ON THAT UNIT.  THE ACTIVE REQUEST RESETS
:	THE CORRESPONDING BIT IN ITS SOFTWARE UNIT INTERLOCK MASK
:	(PB.SUI) SO THAT IT WILL CONTINUE TO BE SERVICED.

:	IF THE EXPRESSION ((PB.SUI&RNDM)!DNDM)&PB.HUI IS TRUE, THEN
:	THE REQUEST IS NOT SERVICED.  ALSO, IF THE REQUEST IS
:	READY TO DO CHANNEL I/O IT IS NOT SERVICED SINCE ITS
:	SERVICE COROUTINE ADDR IS SET TO USCAN1.

:	SCANS THE QUEUE OF DPB'S HEADED BY SDQ AND ENDED BY EDQ.

USCAN0	STH	R13,QX1			:UPDATE QUASI QUEUE INDEX


USCAN	LHI	R13,RAD(SDQ)		:ADDR REQUEST QUEUE HEAD
	IF	SHSTAT
	AM	R6,QSTAT3		:COUNT NO. OF TIMES UNIT SCANNER RUNS
	EI	(SHSTAT)
USCAN1	LR	R12,R13
	LHL	R13,AAD(PB.NXT),R13	:ADDR OF NEXT REQUEST IN QUEUE
	JE	USCANX			:JUMP TO UNIT-SCANNER EXIT
	L	R11,AAD(PB.SUI),R13	:MASK TO ENABLE SOFTWARE UNIT INTERLOCKS
					: FOR THIS REQUEST
	NR	R11,R14			:LOGICAL PRODUCT UNITS SOFTWARE-LOCKED
	OR	R11,R15			:INCLUDE UNITS HARDWARE-LOCKED
	N	R11,AAD(PB.HUI),R13	:LOGICAL PRODUCT OF UNITS REQUIRED TO
					: PROCESS THIS REQUEST
	JNBS	USCAN1			:UNIT LOCKED--GO ON TO NEXT REQUEST
	LHL	R11,AAD(PB.STA),R13	:LOAD COROUTINE ADDR FOR UNIT SCAN
	J	AAD(0),R11		:JUMPS TO USCAN1 IF REQUEST IS READY
					: TO TRANSFER DATA...ELSE DISPATCH
					: TO COROUTINE WITH:
					:	R12 = PREVIOUS DPB
					:	R13 = CURRENT DPB
					:	R14 = REQUEST END MASK
					:	R15 = DEVICE END MASK
	SUBTTL	REQUEST POST-PROCESSOR

:	THE REQUEST POST-PROCESSOR UPDATES THE STATUS OF A
:	COMPLETED REQUEST IN THE SVC PARAMETER BLOCK AND WAKES
:	THE REQUESTING USER IF NECESSARY.  IT ALSO DELETES THE
:	COMPLETED DPB FROM THE I/O QUEUE AND RETURNS IT TO THE AVAIL LIST.
:	IT EXAMINES THE DPB WAIT QUEUE HEADED BY SWQ AND ENDED BY EWQ
:	AND IF THIS QUEUE IS NOT EMPTY, AN ENTRY FROM THIS
:	QUEUE IS REMOVED AND RETURNED TO THE AVAIL LIST HEADED BY
:	ESWQ IN THE PROPER USER BLOCK, AND THAT USER IS WAKENED IF
:	NECESSARY.

:	WARNING:  THE POST-PROCESSOR CAN BE ENTERED ONLY
:	FROM THE UNIT SCANNER.

:	ARGUMENTS REQUIRED
:	ARE:	R9 = RETURN CODE
:		R10 = DEVICE STATUS
:		R11 = UCB (REL ADDR)
:		R12 = PREVIOUS DPB (REL ADDR)
:		R13 = CURRENT DPB (REL ADDR)

:	ENTRY POINT FOR DEVICE NOT ON BUSS
DVNRDY	LHI	R9,ERR.18		:DEVICE NOT AVAILABLE
	LHI	R10,202
	JFS	UNEND1

UNEND	LIS	R9,NO.ERR		:ENTRY POINT FOR SUCCESSFUL
					: COMPLETION OF REQUEST

UNEND1	STH	R10,AAD(UCB.STA),R11	:SAVE STATUS IN UCB
	LCS	R7,1
	X	R7,AAD(PB.HUI),R13	:GET MASK OF UNITS REQUIRED
	NR	R14,7
	L	R7,AAD(PB.PRM),R13	:GET ADDR OF SVC PARAM BLOCK
	IF	NDISC
	LH	R8,AAD(PB.MAP),R13	:IS THIS A MAP READ OR WRITE?
	JE	UNND1D			:NO

:		MAP READ OR WRITE POST-PROCESSING
	JL	UNND1B			:-1 => READ
	LR	R9,R9			:TEST FOR ERROR
	JNFS	UNND1A			:WRITE ERROR
	LIS	R9,ERR.15		:ALT CYL ASSIGNED
	JFS	UNND1D
UNND1A	L	R8,AAD(ALTCYL),R11	:UNDO ALT CYL ASSIGNMENT
	LCS	R9,1
	ST	R9,0,R8			:MARK MAP ENTRY FREE
	LIS	R9,ERR.13		:NO ALT CYL COULD BE ASSIGNED
	JFS	UNND1D
UNND1B	LR	R9,R9			:WAS THERE A MAP READ ERROR?
	JEFS	UNND1C			:IF EQ NO
	LIS	R9,ERR.01		:INDICATE MAP READ FAILURE
UNND1C	STH	R9,AAD(UCB.MP),R11	:SAVE IN UCB FOR USER TO
					: DISCOVER WHEN RETRYING SVC
	J	UNEND3			:DO NOT OVERWRITE RS BYTE IN SVC PARAMETER
					: BLOCK - SVC WILL BE RE-SERVICED!
UNND1D	EI	(NDISC)
	L	R8,AAD(PB.USR),R13	:GET ADDR OF USER BLOCK
	LH	R8,DREQ,R8		:CHECK COUNT OF OUTSTANDING I/O
	JNFS	UNEND2
	LIS	R9,ERR.09		:ABORTED I/O
UNEND2	IF	SUP
	LH	R8,AAD(PB.NEW),R13	:IS THIS NEW OR OLD SVC CALL?
	NHI	R8,0FF			:IGNORE SUBFUNCTION BITS
	JN	UNND2D			:NEW...SKIP
:	OLD STYLE SVC...MAINTAIN COMPATIBILITY
	TBT	R9,CEMSK		:TEST ERROR CONDITIONS WHICH SHOULD
					: RETURN CONTROLLER STATUS
	JGFS	UNND2B			:JUMP IF CONTROLLER STATUS NEEDED
	CLHI	R9,ERR.06		:TEST ERROR CONDITION REQUIRING DISK STATUS
	JEFS	UNND2C
	LIS	R10,0			:ALL OTHERS GIVE ZERO
UNND2A	EXBR	R9,R9			:POSITION RETURN CODE
	OR	R9,R10			:INCLUDE STATUS BYTE
	STH	R9,SVC.RS,R7		:OVERWRITE REQUEST BYTE AND ADJACENT BYTE
	JFS	UNEND3
UNND2B	EXBR	R10,R10			:POSITION CONTROLLER STATUS BYTE
UNND2C	LBR	R10,R10			:EXTRACT LO ORDER BYTE
	JBS	UNND2A
UNND2D	EI	(SUP)
	STH	R10,SVC.ST,R7		:SAVE STATUS
	STB	R9,SVC.RS,R7		:SAVE RETURN CODE IN SVC PARAMETER BLOCK
					: NOTE THAT COUNT FIELD IN PARAMETER BLOCK
					: MODIFIED BY CHANNEL END CO-ROUTINE FOR MAG-
					: TAPE READ

:	TAKE DPB OFF I/O QUEUE
UNEND3	LHL	R11,AAD(PB.NXT),R13
	STH	R11,AAD(PB.NXT),R12	:FIXUP PREV DPB--PERHAPS SDQ
	JNFS	UNEND4			:IF EQUAL, END OF QUEUE
	STH	R12,EDQ			:FIXUP END OF QUEUE PTR

:	RETURN DPB TO AVAIL LIST
UNEND4	LHL	R11,AVAIL
	STH	R11,AAD(PB.NXT),R13
	STH	R13,AVAIL

:	EXAMINE DPB WAIT QUEUE

PSWQ	L	R10,SWQ			:GET START-OF-WAIT-QUEUE ADDRESS
	JE	PSWQ2			:IF 0, NONE WAITING
	SHI	R10,-ESWQ		:ADDR OF START OF USER BLOCK
	L	R11,ESWQ,R10
	ST	R11,SWQ			:DELETE NODE FROM QUEUE
	JNFS	PSWQ1			:IF =0, END OF QUEUE
	LA	R11,SWQ
	STH	R11,EWQ			:SINCE END, RESET LIST-END TO SWQ
PSWQ1	LIS	R11,0
	ST	R11,ESWQ,R10		:RETURN NODE TO USER'S AVAIL LIST
	LH	R11,DREQ,R10
	JE	PSWQ			:I/O FOR USER ABANDONED--TRY ANOTHER
	LHI	R11,@FDSK2		:TURN OFF DPB SLEEP BIT
	NH	R11,WFLAG,R10
	STH	R11,WFLAG,R10

:	WAKE USER WHO IS DISMISSED FOR DISC WORK
PSWQ2	L	R10,AAD(PB.USR),R13	:ADDR OF USER BLOCK
	LH	R11,DREQ,R10
	JEFS	PSWQ3			:IF EQ I/O HAS BEEN ABANDONED
	SIS	R11,1
	STH	R11,DREQ,R10		:DECREMENT COUNT OF OUTSTANDING I/O
	JNFS	PSWQ3			:DON'T WAKE USER UNTIL COUNT=0
	LHL	R11,WFLAG,R10
	NHI	R11,@FDSK1		:TURN OFF DISC SLEEP BIT
	STH	R11,WFLAG,R10

:	NEED TO RESCAN QUEUE SINCE RNDM WAS CHANGED.
:	HOPEFULLY, THE COMPLETED REQUEST WAS NEAR THE START
:	OF THE I/O QUEUE.
PSWQ3	J	USCAN

USCANX	HS	0			:UNIT SCANNER EXITS TO HERE!

	IF	ESELCH
	SUBTTL	CHANNEL SCANNER

:	THE PROLOGUE TO THE CHANNEL SCANNER ASSURES THAT THE INT
:	QUEUE IS STILL EMPTY.  IF NOT, IT RESTARTS THE ENTIRE SCAN
:	PROCESS.  IT ALSO CHECKS TO SEE IF ALL CHANNELS ARE BUSY.
:	IF SO, IT EXITS TO XSCAN (SEE CHIO CODE).

:	THE CHANNEL SCANNER PROCESSES THE QUEUE OF REQUEST DPB'S
:	HEADED BY SDQ AND ENDED BY EDQ.  NOTE THAT
:	IF A REQUEST IS NOT READY TO DO CHANNEL I/O ITS SERVICE
:	COROUTINE ADDR IS SET TO CSCAN1.

:	WHEN CHANNEL I/O IS STARTED (SEE CHIO) A CHECK IS MADE
:	TO SEE IF ALL CHANNELS ARE BUSY, AND IF SO, THE CHANNEL
:	SCANNER EXITS TO XSCAN.  XSCAN EXITS THE SCANNER
:	PROVIDING THE INT QUEUE IS EMPTY.  IF NOT,
:	THE SCANNER IS RESTARTED FROM THE TOP.

CSCAN	LH	R13,QX1
	CLH	R13,QX			:IS THE INT QUEUE EMPTY?
	JN	DD3			:NO, RESTART SCANNER
	L	R8,CHMSK		:MASK OF ALL CHANNELS
	LR	R9,R8
	NR	R8,R15
	CLR	R8,R9
	JE	XSCAN			:ALL CHANNELS BUSY

	LHI	R13,RAD(SDQ)		:(REL ADDR) QUEUE HEAD
	IF	SHSTAT
	AM	R6,QSTAT4		:COUNT NO. OF TIMES CHANNEL SCANNER RUNS
	EI	(SHSTAT)
CSCAN1	LHL	R13,AAD(PB.NXT),R13	:(REL ADDR) NEXT DPB
	JE	XSCAN			:QUEUE END - SCANNER EXIT
	LHL	R12,AAD(PB.STA+2),R13	:LOAD CHANNEL SCAN COROUTINE ADDR
	J	AAD(0),R12		:JUMP TO CSCAN1 IF NOT READY TO
					: PERFORM CHANNEL I/O.  ELSE
					: DISPATCH TO COROUTINE
					: WITH R13 = DPB ADDR
					:	R14 = REQUEST END MASK
					:	R15 = DEVICE END MASK

	SUBTTL	START CHANNEL I/O

:	ALTERNATE ENTRY POINT CHIO1 REQUIRES R7 = SLOWC FOR
:	CHANNEL I/O TIMEOUT

:	REQUIRES  R8 = NEW SCANNER SERVICE COROUTINE ADDR'S
:		  R9 = CONTROLLER DEVICE ADDR
:		 R10 = NOT USED (DESTROYED)
:		 R11 = CHANNEL COMMAND BYTE (BITS 0-7),
:			CONTROLLER COMMAND BYTE (BITS 8-15),
:			CHANNEL END COROUTINE ADDR (BITS 16-31).
:		 R12 = UCB ADDR (DESTROYED)
:		 R13 = DPB ADDR FOR CURRENT REQUEST
:		 R14 = REQUEST END MASK
:		 R15 = DEVICE END MASK

CHIO	LI	R7,7FFFFFFF		:NO TIMEOUT FOR CHANNEL I/O
CHIO1	ST	R8,AAD(PB.STA),R13	:SAVE SCANNER COROUTINE ADDR'S
	O	R15,AAD(PB.HUI),R13	:BUSY CHANNEL, CONTROLLER, AND UNIT
	IF	SHSTAT
	AM	R6,QSTAT5		:COUNT NO. OF TIMES CHANNEL STARTED
	EI	(SHSTAT)
	LHL	R10,AAD(UCB.CHB),R12	:ADDR OF CHANNEL CONTROL BLK FROM UCB
	LHL	R8,AAD(CB.BN),R10	:GET BIT NUMBER
	STB	R7,TTMOUT+1,R8,R8	:SAVE TIMEOUT COUNTER
	STH	R11,AAD(CH.E),R10	:SAVE CHANNEL END COROUTINE ADDR
	STH	R13,AAD(CH.R),R10	:SAVE ADDR OF RELEVANT REQUEST DPB
	LH	R10,AAD(CB.DA),R10	:GET CHANNEL DEVICE ADDR
	STB	R10,TTMOUT,R8,R8	:SAVE ADDRESS
	OC	R10,STOP		:STOP CHANNEL
	L	R8,AAD(PB.SMA),R13	:STARTING MEMORY ADDR
	CLI	R8,CBUF			:RANGE CHECK
	JL	CHIOER
	EXHR	R12,R8
	WDR	R10,R12			:HI ORDER BYTE TO CHANNEL
	EXBR	R12,R8
	WDR	R10,R12			:INTERMEDIATE BYTE TO CHANNEL
	WDR	R10,R8			:LO ORDER BYTE TO CHANNEL

	L	R8,AAD(PB.EMA),R13	:ENDING MEMORY ADDR
	EXHR	R12,R8
	WDR	R10,R12
	EXBR	R12,R8
	WDR	R10,R12
	WDR	R10,R8

	EXHR	R11,R11			:POSITION CONTROLLER COMMAND BYTE
	LHI	R8,Q.PSW
	EPSR	R7,R8			:*E*DISABLE IMMEDIATE INTS
	OCR	R9,R11			:*E*START CONTROLLER
	EXBR	R11,R11			:*E*POSITION CHANNEL COMMAND BYTE
	OCR	R10,R11			:*E*START CHANNEL
	EPSR	R8,R7			:*E*REENABLE INTS

	L	R8,CHMSK		:MASK OF ALL CHANNELS IN CONFIGURATION
	LR	R9,R8
	NR	R8,R15
	CLR	R8,R9			:ARE ALL CHANNELS NOW BUSY?
	JN	CSCAN1			:GO ON TO NEXT REQUEST
	J	XSCAN			:ELSE EXIT SCANNER



CHIOER	S.HLTE(1463)		:INVALID BUFFER ADDRESS

	ELSE

CSCAN1	EQ	USCAN1			:DEFINE SYMBOL FOR CASE OF NO CHANNELS
	EI	(ESELCH)
	SUBTTL	SCANNER EXIT

XSCAN	LIS	R12,0
	LH	R13,QX1			:QUASI INT QUEUE INDEX
	LHI	R10,Q.PSW		:PREPARE TO DISABLE INTS
	EPSR	R11,R10			:*E*DISABLE IMMEDIATE INTS
	CLH	R13,QX			:*E*IS INT QUEUE REALLY EMPTY?
	JNFS	XSCAN1			:*E*JUMP IF NOT
	STH	R12,QUASIC		:*E*INDICATE QUASI NOT RUNNING
	ST	R14,RNDM		:*E*SAVE MODIFIED REQUEST MASK
	ST	R15,DNDM		:*E*SAVE MODIFIED DEVICE END MASK
	LM	R6,DSAVE+8		:*E*RESTORE REGS USED BY SCANNER
	LPSW	DSAVE			:*E*RETURN TO INTERRUPTED CODE
XSCAN1	EPSR	R10,R11			:*E*ENABLE INTS
	J	DD3

	IF	MSCDSK
	SUBTTL	MSC-1400 DISC SERVICE

:	TABLE OF INDIVIDUAL REQUEST DRIVERS
DVDB2	WS	0			:FORCE TO WORD BOUNDARY
	HC	$2 1111000000100110,0	:"1"'S INDICATE LEGAL FUNCTIONS
	HC	RAD(MSCRW),RAD(CSCAN1)	:READ
	HC	RAD(MSCRW),RAD(CSCAN1)	:WRITE
	HC	RAD(MSAT0),RAD(CSCAN1)	:ATTACH
	HC	RAD(MSDT0),RAD(CSCAN1)	:DETACH
	WS	6
	HC	RAD(MSRS0),RAD(CSCAN1)	:REQUEST STATUS
	WS	2
	HC	RAD(MSMO0),RAD(CSCAN1)	:MOUNT
	HC	RAD(MSDM0),RAD(CSCAN1)	:DISMOUNT


:	MOUNT
MSMO0	LIS	R7,0
	JFS	MSDM0X

:	DISMOUNT
MSDM0	LCS	R7,2
MSDM0X	LHL	R11,AAD(PB.UCB),R13	:GET UCB ADDR
	STH	R7,AAD(UCB.MP),R11	:SET MAP SWITCH -2 FOR DISMOUNT
					: SET MAP SWITCH 0 FOR MOUNT
					: FALL INTO ATTACH-DETACH CODE

:	ATTACH
:	DETACH
:	READ STATUS
MSAT0
MSDT0
MSRS0	LHI	R10,10			:SET "DSTATE"
	STH	R10,AAD(PB.UCB)+PK.CMD,R13
					:AND FALL THROUGH TO "READ" DRIVE

:	READ/WRITE RECORD
MSCRW	LHL	R11,AAD(PB.UCB),R13	:LOCATE UNIT CONTROL BLOCK
	LCS	R7,4			:SET MASK
	NH	R7,AAD(CB.DA),R11	:GET DEVICE ADDRESS
MSCRW1	SSR	R7,R8
	JTBS	8,MSCRW1
	JFFS	4,MSCRW2		:SKIP IF CONTROLLER IS ON BUSS
	THI	R8,0F0			:CONDITION CODE SAYS CONTROLLER (MAYBE) NOT ON BUSS
	JE	DVNRDY			:NO REASON FOR "OR'ED" BIT TO BE ON...OFF LINE
MSCRW2	LHL	R10,AAD(MS.FIFO),R11	:OK...LOCATE FIFO TABLE
	LHL	R9,MSC.PT,R10		:LOCATE CURRENT ENTRY
	LHL	R8,0,R9			:CHECK BIT 10
	THI	R8,20
	JN	USCAN1			:RING IS FULL....WAIT FOR IT
	LHL	R8,AAD(UCB.CDA),R11	:OK...GET DRIVE NUMBER
	OHI	R8,3000			:SET "INTERUPT ON DONE", "RELEASE ON DONE"
	STH	R8,AAD(PB.UCB)+PK.FLG,R13 :AND SET UP FLAGS
	LA	R8,AAD(PB.UCB),R13	:NOW LOCATE THE SUPER-PACKET
	AI	R8,00200000+PK.LNK	:SET IN-USE BIT, ABSOLUTE ADDRESS
	ST	R8,0,R9			:AND PLACE IT IN FIFO RING
	AIS	R9,4			:ADVANCE OUR CURSOR
	LIS	R8,$A 11		:CHECK FOR END FLAG
	TBT	R8,0,R9
	JEFS	MSCRW3			:SKIP IF NOT END
	LHL	R9,MSC.IT,R10		:ELSE FOLD IT
MSCRW3	STH	R9,MSC.PT,R10
	LIS	R8,1			:TEST IF RECALIBRATING
	TBT	R8,RECALF
	JE	MSCRW4
	OC	R7,MSC.RY		:SIGNAL "READY"...START OPERATION
MSCRW4	LHI	R7,RAD(USCAN1)
	STH	R7,AAD(PB.STA),R13	:INSURE WE WON'T PASS THROUGH HERE AGAIN
	J	USCAN1			:AND QUIT, PROCESS NEXT REQUEST


:	MSEXIT...ALL DONE, PICK UP STATUS AND RETURN IT
MSEXIT	LHL	R11,AAD(PB.UCB),R13	:GET UCB ADDRESS
	LH	R10,AAD(PB.UCB)+PK.STA,R13 :GET STATUS
	JGEFS	MSXIT1			:SKIP IF NO FAULT
	LH	R9,AAD(PB.UCB)+PK.FAU,R13 :ELSE GET FAULT CODE
	L	R8,AAD(PB.PRM),R13	:GET SVC PARAMETER BLOCK ADDRESS
	STB	R9,SVC.VA,R8		:PLACE FAULT CODE THERE
MSXIT1	LH	R9,AAD(PB.UCB)+PK.FLG,R13 :EXAMINE FLAG WORD
	NHI	R9,8080			:CHECK FOR OTHER ERRORS
	JE	MSXIT5			:NO ERROR...EXIT
	JG	MSXIT4			:SKIP IF CORRECTED ERROR
	THI	R10,8			:CHECK IF DRIVE FAULT
	JNFS	MSXIT3			:SKIP IF SO
	THI	R10,3			:CHECK FOR DRIVE NOT RESPONDING
	JNFS	MSXIT2			:SKIP IF SO
	THI	R10,210			:CHECK FOR WRITE-PROTECTED
	JEFS	MSXIT3			:SKIP IF NOT SO
	LHI	R9,ERR.19		:ELSE SET WRITE-PROTECTED
	JFS	MSXIT5			:AND EXIT
MSXIT2	LHI	R9,ERR.18		:ELSE SET OFF-LINE
	JFS	MSXIT5			:AND SKIP
MSXIT3	LIS	R9,ERR.08		:ELSE SET ERROR CODE...ERROR RETURN FROM CONTROLLER
	JFS	MSXIT5			:AND EXIT
MSXIT4	LHI	R9,ERR.24		:NO ERROR, BUT ERROR RECOVERED
MSXIT5	J	UNEND1			:REPORT THAT AND EXIT

	EI	MSCDSK

	IF	ESELCH

	IF	NTAPE
	SUBTTL	TAPE SERVICE

:	TABLE OF INDIVIDUAL REQUEST DRIVERS
DVDB1	WS	0
	HC	$2 1111111111111000,0	:"1"'S INDICATE LEGAL FUNCTIONS
	HC	RAD(MTRD0),RAD(CSCAN1)	:READ
	HC	RAD(MTWR0),RAD(CSCAN1)	:WRITE
	HC	RAD(MTAT0),RAD(CSCAN1)	:ATTACH
	HC	RAD(MTDT0),RAD(CSCAN1)	:DETACH
	HC	RAD(MTBR0),RAD(CSCAN1)	:BACKSPACE
	HC	RAD(MTFF0),RAD(CSCAN1)	:SKIP FILE FWD
	HC	RAD(MTBF0),RAD(CSCAN1)	:SKIP FILE REV
	HC	RAD(MTFM0),RAD(CSCAN1)	:WRITE EOF
	HC	RAD(MTRW0),RAD(CSCAN1)	:REWIND
	HC	RAD(MTUL0),RAD(CSCAN1)	:UNLOAD
	HC	RAD(MTRS0),RAD(CSCAN1)	:GET STATUS
	HC	RAD(MTER0),RAD(CSCAN1)	:ERASE GAP
	HC	RAD(MTSD0),RAD(CSCAN1)	:SET LOW DENSITY

:	STATE 0 - INITIAL

:	READ RECORD
MTRD0	JAL	R7,RUS			:READ UNIT STATUS
	LI	R7,(RAD(USCAN1))^10+RAD(MTRD1)	:NEW STATE
	JFS	MTWR0X

:	WRITE RECORD
MTWR0	JAL	R7,RUS			:READ UNIT STATUS
	THI	R10,FPROT
	JN	VWRLOK			:VOLUME WRITE-LOCKED
	LI	R7,(RAD(USCAN1))^10+RAD(MTWR1)	:NEW STATE
MTWR0X	ST	R7,AAD(PB.STA),R13	:CHANGE SCANNER SERVICE ADDR'S
	J	USCAN1

:	ATTACH - CAN GIVE DU OR FPROT ERROR
MTAT0	JAL	R7,RUS			:READ UNIT STATUS
	LHI	R9,XMODE+DISARM		:DUMMY COMMAND TO CONTROLLER
	STB	R9,AAD(MT.DEN),R11	:TO SET DEFAULT DENSITY
	LHI	R9,ERR.20		:ASSUME WRITE-LOCKED BUT
					: SUCCESSFULLY ATTACHED NONETHELESS
	THI	R10,FPROT
	JN	UNEND1
	JFS	MTDT0X

:	DETACH
MTDT0	LHL	R11,AAD(PB.UCB),R13	:GET UCB ADDR
	LHI	R9,XMODE+DISARM		:DUMMY COMMAND TO CONTROLLER
	STB	R9,AAD(MT.DEN),R11	:TO SET DEFAULT DENSITY
	JAL	R7,RUS			:READ UNIT STATUS - CAN GIVE DU ERROR
MTDT0X	J	UNEND

:	BACKSPACE RECORD
MTBR0	JAL	R7,RUS			:READ UNIT STATUS
	THI	R10,BOT			:TEST LOAD POINT
	JNFS	MTBR0X			:DONE IF SO
	LI	R7,(BACKR+ENABLE)^10+RAD(MTBR1)
	J	MT0X
MTBR0X	LHI	R9,ERR.17		:END OF VOLUME SENSED
	J	UNEND1

:	SKIP FORWARD FILE
MTFF0	JAL	R7,RUS			:READ UNIT STATUS
	LI	R7,(SKFF+ENABLE)^10+RAD(MTFF1)
	J	MT0X

:	SKIP BACKWARD FILE
MTBF0	JAL	R7,RUS			:READ UNIT STATUS
	THI	R10,BOT			:TEST LOAD POINT
	JNBS	MTBR0X			:GIVE END OF VOLUME ERROR
	LI	R7,(SKRF+ENABLE)^10+RAD(MTBF1)
	J	MT0X

:	WRITE FILE MARK
MTFM0	JAL	R7,RUS			:READ UNIT STATUS
	THI	R10,FPROT
	JNFS	VWRLOK
	LI	R7,(WRFMK+ENABLE)^10+RAD(MTFM1)
	J	MT0X
VWRLOK	LHI	R9,ERR.19		:VOLUME WRITE-LOCKED
	J	UNEND1

:	REWIND
MTRW0	JAL	R7,RUS			:READ UNIT STATUS
	LHI	R9,REW+ENABLE
	OCR	R8,R9			:START REWIND
	JAL	R7,GS			:DO NOT WAIT FOR NMTN=1
	THI	R10,DU			:BUT DO CHECK DU
	JN	RUS1			:UNIT NOT READY
	THI	R10,NMTN		:HAS TAPE STOPPED?
	JNFS	RWFIN			:YES

E
	LIS	R9,0			:ASSUME SUCCESSFUL
	STH	R9,AAD(MT.RIP),R11	:SET REWIND-IN-PROGESS FLAG
	J	UNEND			:GIVE SUCCESS RETURN
RWFIN	THI	R10,BOT			:REQUIRE LOAD POINT
	JN	UNEND
	J	RUS3			:UNIT ERROR

:	UNLOAD (PUT OFFLINE)
MTUL0	JAL	R7,RUS			:READ UNIT STATUS
	OC	R8,EDIMOD		:SET EDIT MODE
	LHI	R9,REW+ENABLE		:REWIND COMMAND BYTE
	LHI	R7,RAD(MTUL1)		:NEW SERVICE COROUTINE ADDR
	J	MT0X1

:	READ STATUS.  DO NOT DISMISS
MTRS0	JAL	R7,GS			:ABBREVIATED VERSION OF GUS
	THI	R10,DU
	JN	RUS1
	J	UNEND

:	ERASE GAP
MTER0	JAL	R7,RUS			:READ UNIT STATUS
	THI	R10,FPROT
	JN	VWRLOK			:VOLUME WRITE-LOCKED
	LI	R7,(ERASE+ENABLE)^10+RAD(MTER1)
	J	MT0X

:	SET LOW DENSITY
MTSD0	JAL	R7,RUS			:READ UNIT STATUS
	LHI	R8,SLDEN+XMODE+DISARM
	STB	R8,AAD(MT.DEN),R11	:COMMAND TO CONTROLLER...PREFACES
	J	UNEND			:  READ OR WRITE TO SET LOW DENSITY


:	COMMON EXIT POINT FOR STATE 0

MT0X	EXHR	R9,R7			:POSITION COMMAND BYTE
	OC	R8,AAD(MT.DEN),R11
MT0X1	OCR	R8,R9			:ALERT CONTROLLER
	STH	R7,AAD(PB.STA),R13	:NEW SCANNER SERVICE COROUTINE ADDR
MT0X2	O	R15,AAD(CB.BIT),R11	:BUSY UNIT UNTIL OPERATION COMPLETE
	LHL	R9,AAD(CB.BN),R11	:GET BIT NUMBER
	STB	R8,TTMOUT,R9,R9		:SAVE ADDRESS FOR TIMEOUT ROUTINE
	LHI	R8,0A0		:AND TIMOUT COUNT = 256 SEC
	STB	R8,TTMOUT+1,R9,R9	:STORE IT
	J	USCAN1			:GO ON TO NEXT REQUEST




:	STATE 1 - INTERMEDIATE

:	READ RECORD
MTRD1	L	R12,AAD(PB.HUI),R13	:MASK OF DEVICES REQUIRED
	NR	R12,R15
	JN	CSCAN1			:ONE OR MORE STILL BUSY
	JAL	R7,SRWDEN		:SET DENSITY
	LI	R11,(GO+RDO)^18+(READ+ENABLE)^10+RAD(MTREND)
					: CHANNEL COMMAND BYTE BITS 0-7
					: CONTROLLER COMMAND BYTE BITS 8-15
					: CHANNEL END COROUTINE BITS 16-31
	LI	R8,(RAD(MTRD2))^10+RAD(CSCAN1)	:NEW SCANNER SERVICE ADDR'S
MTRD1X	LHL	R7,AAD(CB.BN),R12		:GET BIT NUMBER
	STB	R9,TTMOUT,R7,R7		:FIRST STORE DEVICE ADDRESS
	LHI	R10,40			:AND TIMEOUT COUNTER 128 SEC
	STB	R10,TTMOUT+1,R7,R7	:AND SET COUNTER
	LIS	R7,08			:AND 16 SEC CHANNEL TIMEOUT
	J	CHIO1			:START CHANNEL I/O

:	WRITE RECORD
MTWR1	L	R12,AAD(PB.HUI),R13	:MASK OF DEVICES REQUIRED
	NR	R12,R15
	JN	CSCAN1			:ONE OR MORE STILL BUSY
	JAL	R7,SRWDEN		:SET DENSITY
	LI	R11,(GO)^18+(WRITE+ENABLE)^10+RAD(MTWEND)
	LI	R8,(RAD(MTWR2))^10+RAD(CSCAN1)	:NEW SCANNER SERVICE ADDR'S
	J	MTRD1X			:START CHANNEL I/O

:	BACKSPACE RECORD
:	ERASE GAP
MTBR1
MTER1	JAL	R7,MTRS			:READ UNIT STATUS
	JAL	R7,MTMOUT		:AND CHECK TIMEOUTS
	THI	R10,ERR+ET+EOF
	JE	UNEND			:NO ERROR
	JFS	MTERR

:	SKIP FORWARD FILE
:	SKIP BACKWARD FILE
:	WRITE FILE MARK
:	ALL REQUIRE EOF TO BE SET
MTFF1
MTBF1
MTFM1	JAL	R7,MTRS			:READ UNIT STATUS
	JAL	R7,MTMOUT		:CHECK TIMEOUT
	THI	R10,ERR+ET+EOF		:REQUIRE AT LEAST EOF
					: TO BE SET
	JE	RUS3			:REPORT UNIT ERROR
	THI	R10,EOF			:IGNORE OTHER ERROR BITS IF EOF
	JN	UNEND			: IS SET

:	SOME KIND OF TAPE ERROR
MTERR	LHI	R9,ERR.16		:ASSUME END OF FILE
	THI	R10,EOF
	JNFS	MTERRX
	LHI	R9,ERR.17		:ASSUME END OF VOLUME
	THI	R10,ET
	JE	RUS3			:GIVE UNIT ERROR
MTERRX	J	UNEND1

:	UNLOAD (OFFLINE)
MTUL1	JAL	R7,GS			:DO NOT WAIT FOR NMTN=1
	JAL	R7,MTMOUT		:AND CHECK TIMEOUT
	THI	R10,DU
	JN	UNEND			:DEVICE UNAVAIL EXPECTED
	THI	R10,NMTN		:IS TAPE STILL REWINDING?
	JE	UNEND			:ASSUME IT WILL GO OFFLINE
	J	RUS3			:GIVE UNIT ERROR





:	STATE 2 - READ/WRITE COMPLETE

:	READ
:	WRITE
MTRD2
MTWR2	JAL	R7,GS			:GET UNIT STATUS
	JAL	R7,MTMOUT		:AND CHECK UNIT TIMEOUT
	THI	R10,DU
	JN	RUS1			:DEVICE UNAVAILABLE
	THI	R10,EOM			:WAIT FOR CONTROLLER EOM
	JE	MT0X2			:IGNORE EARLY CONTROLLER INTERRUPT
	THI	R10,ERR+EOF+ET
	JE	UNEND			:NO ERRORS TO REPORT
	LHI	R9,ERR.16		:ASSUME EOF ERROR
	THI	R10,EOF
	JNFS	MTWR2X
	LHI	R9,ERR.17		:ASSUME ET ERROR
	THI	R10,ET
	JNFS	MTWR2X
	LIS	R9,ERR.08		:REPORT CONTROLLER ERROR
MTWR2X	J	UNEND1





:	STATE 3 - READ TIMEOUT

:	ALSO HANDLE DU ERRORS--STOP TAPE MOTION

MTRD3	LHL	R11,AAD(PB.UCB),R13	:GET UCB ADDR
RUS1	LH	R9,AAD(CB.BN),R11	:MUST CLEAR ALL UNITS FOR CONTROLLER
	LHI	R11,RAD(SDL)		:SEARCH DEVICE CHAIN FOR ALL UNITS ON SAME
					: CONTROLLER
MTRD3A	LHL	R11,AAD(CB.NXT),R11	:NEXT UCB
	JEFS	MTRD3B			:END OF CHAIN
	CLH	R9,AAD(CB.BN),R11
	JNBS	MTRD3A
	LH	R10,AAD(CB.DA),R11	:GET DEVICE ADDR
	OC	R10,MTENI		:RESET CONTROLLER BUT LEAVE INTS ENABLED
	JBS	MTRD3A
MTRD3B	JAL	R7,GS
	LHI	R9,ERR.18		:ASSUME DEVICE UNAVAILABLE ERROR
	THI	R10,DU
	JNFS	MTRD3C
	LHI	R9,ERR.23		:TIMEOUT
MTRD3C	J	UNEND1

: CHECK TIMEOUT
MTMOUT	LHL	R9,AAD(CB.BN),R11	:GET BIT NUMBER
	LB	R9,TTMOUT+1,R9,R9		:GET LAST COUNT
	SIS	R9,1
	JGER	R7			:NO TIMEOUT
	LHL	R9,AAD(CB.BN),R11	:GET BIT NUMBER AGAIN
	LB	R9,TTMOUT,R9,R9	:GET ADDRESS OF UNIT
	OC	R9,MTCLR		:CLEAR IT
	LHI	R9,ERR.23		:TIMEOUT
	J	UNEND1
	SUBTTL	MAG TAPE ROUTINES

:	CHANNEL END COROUTINE FOR READ RECORD
:	NOTE R11 = CHANNEL DEVICE ADDDR, R12 = CHANNEL CONTROL BLK ADDR

MTREND	LI	R9,7FFFFFFF		:RESET I/O TIMER
	LHL	R8,AAD(CB.BN),R12	:GET THE BIT NUMBER
	SLLS	R8,1			:MAKE HALFWORD INDEX
	LB	R10,TTMOUT+1,R8		:GET THE TIMEOUT COUNTER
	STB	R9,TTMOUT+1,R8		:RESET IT
	LHL	R8,AAD(CH.R),R12	:FETCH DPB ADDR FOR THIS REQUEST
	SIS	R10,1			:CHECK FOR TIMEOUT
	JGEFS	MTRND2
MTRND1	LHL	R11,AAD(PB.UCB),R8	:FETCH UCB ADDR
	N	R15,AAD(CB.NBIT),R11	:UNBUSY UNIT
	LHI	R9,RAD(MTRD3)		:CHANGE SCANNER SERVICE TO GIVE ERROR
	J	MTZ0
MTRND2	RDR	R11,R10			:READ LAST ADDR TRANSFERRED
	EXHR	R10,R10			:POSITION HIGH ORDER BYTE
	RDR	R11,R9
	EXBR	R9,R9			:POSITION INTERMEDIATE BYTE
	OR	R10,R9
	RDR	R11,R9
	OR	R10,R9			:INCLUDE LOW ORDER BYTE
	S	R10,AAD(PB.SMA),R8	:R10 = COUNT ACTUALLY READ - 1
	JLE	MTZ1			:EOF OR OTHER ERROR
	AIS	R10,1			:COMPENSATE FOR ESELCH DESIGN ERROR
	LCS	R9,2			:WHICH GIVES ENDING ADDR ONE PAST
	NR	R10,R9			:LAST BYTE TRANSFERED IF REQUEST
					: IS FOR MORE THAN TAPE RECORD
	LR	R9,R10
	SIS	R9,0F			:CHECK NOISE RECORD
	JG	MTZ2
	LHL	R11,AAD(PB.UCB),R8	:FETCH UNIT CONTROL BLOCK
	LHL	R10,AAD(CB.DA),R11	:FETCH DEVICE ADDRESS
	SSR	R10,R9			:GET UN EXTENDED STATUS
	THI	R9,EOF^-8		:TEST FOR END OF FILE
	JN	MTZ1			:SKIP IF SO
:	A NOISE RECORD (PROBABLY WITH BAD PARITY) HAS BEEN READ.  RATHER
:	THAN GIVE A READ ERROR, RETRY THE READ BY CHANGING SCANNER SERVICE
:	ADDR'S BACK TO STATE 0.  SCANNER RESUMES WHEN
:	CONTROLLER INTERRUPTS
	LH	R9,AAD(PB.RTY),R8	:CHECK RETRY COUNTER
	AIS	R9,1
	CLHI	R9,MXRTRY
	JGFS	MTZ2
	STH	R9,AAD(PB.RTY),R8
	LHI	R9,RAD(MTRD0)
MTZ0	STH	R9,AAD(PB.STA),R8	:SAVE IN DPB
	JFS	MTZ3
MTZ1	LIS	R10,0			:EOF GIVE COUNT=0
MTZ2	L	R9,AAD(PB.PRM),R8	:GET ADDR OF SVC PARAM BLK
	ST	R10,SVC.CT,R9		:AND UPDATE COUNT FIELD
MTZ3	J	CHEND1			:RESUME INTERRUPT QUEUE SCAN

:	CHANNEL END COROUTINE FOR WRITE RECORD

MTWEND	LI	R9,7FFFFFFF		:RESET I/O TIMER
	LHL	R8,AAD(CB.BN),R12	:GET THE BIT NUMBER
	SLLS	R8,1			:MAKE HALFWORD INDEX
	LB	R10,TTMOUT+1,R8		:GET THE TIMEOUT COUNTER
	STB	R9,TTMOUT+1,R8		:RESET IT
	LHL	R8,AAD(CH.R),R12	:FETCH DPB ADDR FOR THIS REQUEST
	SIS	R10,1			:CHECK FOR TIMEOUT
	JGE	CHEND1			:NO TIMEOUT
	J	MTRND1

:	RUS - READ UNIT STATUS

:	USE R7 FOR LINKAGE REGISTER
:	RETURNS  R8 = UNIT DEVICE ADDR
:		R10 = DEVICE STATUS
:		R11 = UCB ADDR

:	SETS SOFTWARE INTERLOCK BIT TO INDICATE UNIT IS BUSY PROCESSING
:	A REQUEST.  SENSE 16 BITS OF DEVICE STATUS.  IF TAPE MOTION
:	HAS NOT STOPPED, SET HARDWARE INTERLOCK BIT FOR UNIT AND
:	DISMISS UNTIL UNIT INTERRUPTS.

MTRS	LHL	R11,AAD(PB.UCB),R13	:FAST FORM OF RUS WITHOUT
	JFS	RUS0			:SETTING SOFTWARE INTERLOCK

RUS	LHL	R11,AAD(PB.UCB),R13	:GET UCB ADDR
	O	R14,AAD(CB.BIT),R11	:SET UNIT INTERLOCK FOR ALL REQUESTS
	LH	R8,AAD(CB.BN),R11
	RBT	R8,AAD(PB.SUI),R13	:RESET UNIT INTERLOCK FOR THIS REQUEST
					: ONLY SO THIS REQUEST WILL CONTINUE
					: TO BE SERVICED UNTIL END-OF-REQUEST

RUS0	LHL	R8,AAD(CB.DA),R11	:GET DEVICE ADDR
	LHI	R9,Q.PSW
	EPSR	R11,R9			:*E*DISABLE INTS
	OC	R8,XSTAT		:*E*READ EXTENDED STATUS
	SSR	R8,R10			:*E*EXTENDED STATUS BYTE
	EPSR	R9,R11			:*E*ENABLE INTS
	LHL	R11,AAD(PB.UCB),R13	:RECOVER UCB ADDR
	SSR	R8,R9			:REGULAR STATUS BYTE
	CLHI	R9,EX
	JE	DVNRDY			:CONTROLLER NOT ON BUSS
	EXBR	R9,R9			:POSITION REGULAR STATUS
	OR	R10,R9			:INCLUDE IN EXTENDED STATUS
	THI	R10,DU			:TEST DEVICE UNAVAILABLE
	JN	RUS1			:UNIT OFFLINE OR OTHERWISE UNREADY
	THI	R10,NMTN		:HAS TAPE STOPPED?
	JE	MT0X2			:NO, DISMISS UNTIL INTERRUPT
	TS	AAD(MT.RIP),R11		:IS REWIND IN PROGRESS?
	JGEFS	RUS2			:JUMP IF SO
	JR	R7			:RETURN TO CALLER
:	CHECK REWIND SUCCESS
RUS2	THI	R10,BOT			:LOAD POINT
	JNR	R7			:RETURN TO CALLER IF YES
:	UNIT ERROR
RUS3	LIS	R9,ERR.07
	J	UNEND1


:	GS - GET STATUS

:	USES R7 AS LINKAGE REGISTER
:	RETURNS  R8 = UNIT DEVICE ADDR
:		R10 = 16 BIT DEVICE STATUS
:		R11 = UCB ADDR

:	THIS SUBROUTINE READS UNIT STATUS ONLY.  IT NEVER
:	DISMISSES OR PERFORMS ANY ERROR CHECKING.

GS	LHL	R11,AAD(PB.UCB),R13
	LHL	R8,AAD(CB.DA),R11	:GET UNIT DEVICE ADDR
	LHI	R9,Q.PSW
	EPSR	R11,R9			:*E*DISABLE INTS
	OC	R8,XSTAT		:*E*READ EXTENDED STATUS
	SSR	R8,R10			:*E*
	EPSR	R9,R11			:*E*ENABLE INTS
	LHL	R11,AAD(PB.UCB),R13	:RECOVER UCB ADDR
	SSR	R8,R9
	EXBR	R9,R9
	OR	R10,R9
	JR	R7			:RETURN TO CALLER


:	SRWDEN - SET DENSITY ON DUAL DENSITY DRIVE

:	USES R7 AS LINKAGE REGISTER
:	EXPECTS R13 = DPB ADDR
:	RETURNS  R9 = CONTROLLER DEVICE ADDR
:		R12 = UCB ADDR
SRWDEN	LHL	R12,AAD(PB.UCB),R13	:GET UCB ADDR
	LH	R9,AAD(UCB.CDA),R12	:GET CONTROLLER DEVICE ADDR
	LH	R8,AAD(CB.DA),R12	:GET UNIT DEVICE ADDR
	OC	R8,AAD(MT.DEN),R12	:OUTPUT DENSITY SELECTION
	JR	R7			:RETURN TO CALLER
	EI	(NTAPE)

	IF	NDISC
	SUBTTL	DISC SERVICE

:	TABLE OF INDIVIDULE REQUEST DRIVERS
DVDB0	WS	0
	HC	$2 1111000000100110,0	:"1"'S INDICATE LEGAL FUNCTIONS
	HC	RAD(DKRD0),RAD(CSCAN1)	:READ
	HC	RAD(DKWR0),RAD(CSCAN1)	:WRITE
	HC	RAD(DKAT0),RAD(CSCAN1)	:ATTACH
	HC	RAD(DKDT0),RAD(CSCAN1)	:DETACH
	WS	6
	HC	RAD(DKRS0),RAD(CSCAN1)	:REQUEST STATUS
	WS	2
	HC	RAD(DKMO0),RAD(CSCAN1)	:MOUNT
	HC	RAD(DKDM0),RAD(CSCAN1)	:DISMOUNT

:	STATE 0 - INITIAL

:	CONTINUE WRITE AFTER CYL OVERFLOW
DKWROV	LHI	R7,RAD(DKWR0)
	STH	R7,AAD(PB.STA),R13	:RETURN TO STATE 0

:	WRITE
DKWR0	JAL	R7,DKRUS		:READ UNIT STATUS
	THI	R10,WPROT
	JN	DKWRLK			:WRITE-LOCKED VOLUME
	LHI	R9,RAD(DKWR1)		:NEW SCANNER SERVICE ADDR
	JFS	DX0X

:	CONTINUE READ AFTER CYL OVERFLOW
DKRDOV	LHI	R7,RAD(DKRD0)
	STH	R7,AAD(PB.STA),R13	:RETURN TO STATE 0

:	READ
DKRD0	JAL	R7,DKRUS		:READ UNIT STATUS
	LHI	R9,RAD(DKRD1)		:NEW SCANNER SERVICE ADDR

:	START SEEK OR RESTORE ON UNIT

DX0X	LA	R7,DKRUS3		:JUMP ADDR FOR UNIT ERROR
	THI	R10,SINC+WRCHK		:TEST SEEK INCOMPLETE
	JN	DX0X9			:YES, RESTORE NEEDED
	THI	R10,NRSRW		:TEST NOT READY TO SEEK,
					: READ, OR WRITE
	JNR	R7			:IMPOSSIBLE ERROR--HOW COULD
					: SEEK STILL BE IN PROGRESS?
	STH	R9,AAD(PB.STA),R13	:SAVE NEW SCANNER SERVICE ADDR
	L	R9,AAD(MSMA),R11	:ADDR OF CYLINDER MAP
	L	R8,AAD(MEMA),R11	:ADDR OF CYLINDER MAP END
	LHL	R7,AAD(PB.CYL),R13	:GET CYL NO.
	LH	R10,AAD(UCB.MP),R11	:GET MAP SWITCH
	JL	DX0X2			:MAPS DISMOUNTED--DON'T USE
DX0X1	LH	R10,0,R9		:EXAMINE MAP ENTRY
	JLFS	DX0X2			:NEG CYL ENDS LIST
	CLR	R7,R10			:TRY TO MATCH REQUESTED CYL WITH
					: MAP ENTRY
	JN	DX0XA			:SKIP IF NO MATCH
:	SEEK TO ALTERNATE CYL
	LHL	R7,2,R9			:GET NEW CYL NO.
	OI	R7,ACFLG		:SET ALT CYL FLAG
	JFS	DX0X2
DX0XA	AIS	R9,4			:ADJUST INDEX TO EXAMINE NEXT MAP ENTRY
	CLR	R9,R8
	JLBS	DX0X1			:CONTINUE TO END OF TABLE
DX0X2	LH	R8,AAD(CB.DA),R11	:RECOVER UNIT DEVICE ADDR
	LHI	R10,SEEK+ENABLE		:COMMAND BYTE FOR DISC
DX0X3	ST	R7,AAD(CYLNO),R11	:SAVE CYL NO. AND ALT CYL FLAG
	EXBR	R9,R7
	WDR	R8,R9			:WRITE HI ORDER BYTE OF CYL TO DISC
	WDR	R8,R7			:WRITE LO ORDER BYTE OF CYL TO DISC
	OCR	R8,R10			:ISSUE SEEK OR RESTORE COMMAND TO DISC
	O	R15,AAD(CB.BIT),R11	:BUSY UNIT UNTIL INTERRUPT
	J	USCAN1

:	ERROR RECOVERY FOR ALL TYPES OF ERRORS ALL DO RESTORE.

:	CONTROLLER ERROR-READ
DX0X4	JAL	R7,DKRS
	LA	R7,DKER8
:	DISC ERROR-READ
DX0X5	LHI	R9,RAD(DKRD0)		:SET SCANNER SERVICE TO INITIAL STATE
	JFS	DX0X8
:	CONTROLLER ERROR-WRITE
DX0X6	JAL	R7,DKRS
	LA	R7,DKER8
:	DISC ERROR-WRITE
DX0X7	LHI	R9,RAD(DKWR0)		:SET SCANNER SERVICE TO INITIAL STATE
DX0X8	STH	R9,AAD(PB.STA),R13	:SAVE IN DPB
DX0X9	LH	R9,AAD(PB.RTY),R13
	AIS	R9,1
	CLHI	R9,MXRTRY
	JGR	R7			:EXCESSIVE ERRORS - JUMP TO DKRUS3 (UNIT ERROR)
					: OR DKER8 (CONTROLLER ERROR).
	STH	R9,AAD(PB.RTY),R13	:SAVE UPDATED ERROR COUNT
	LH	R9,AAD(UCB.CDA),R11
	OC	R9,RESET		:RESET DISC CONTROLLER
DX0X10	SSR	R9,R10
	JFBS	CIDLE,DX0X10
	LHI	R10,RESTORE+ENABLE
	LIS	R7,0			:RESTORE TO CYL 0
	J	DX0X3			:START RESTORE

:	MOUNT
DKMO0	LCS	R7,1
	JFS	DKDM0X

:	DISMOUNT
DKDM0	LCS	R7,2
DKDM0X	LHL	R11,AAD(PB.UCB),R13	:GET UCB ADDR
	STH	R7,AAD(UCB.MP),R11	:SET MAP SWITCH -2 FOR DISMOUNT
					: SET MAP SWITCH -1 TO FORCE MAP READ (MOUNT)
					: FALL INTO ATTACH-DETACH CODE

:	ATTACH
:	DETACH
:	READ STATUS
DKAT0
DKDT0
DKRS0	JAL	R7,DKRUS
	J	UNEND





:	STATE 1 - SEEK COMPLETED

:	READ
DKRD1	JAL	R7,DKRS			:READ UNIT STATUS
	LA	R7,DKRUS3		:SET UP FOR UNIT ERROR
	THI	R10,SINC+WRCHK		:SEEK INCOMPLETE?
	JN	DX0X5			:RESTORE UNIT
	LI	R7,(RAD(USCAN1))^10+RAD(DKRD2)
	JFS	DKWRX

:	WRITE
DKWR1	JAL	R7,DKRS			:READ UNIT STATUS
	LA	R7,DKRUS3		:SET UP FOR UNIT ERROR
	THI	R10,SINC+WRCHK		:SEEK INCOMPLETE
	JN	DX0X7			:RESTORE UNIT
	LI	R7,(RAD(USCAN1))^10+RAD(DKWR2)
DKWRX	ST	R7,AAD(PB.STA),R13	:SAVE NEW SCANNER SERVICE ADDR'S
	J	USCAN1





:	STATE 2 - READY TO READ OR WRITE


:	READ CHECK
DKRDCK	ST	R8,AAD(PB.STA),R13	:SAVE SCANNER SERVICE ADDR'S
	LHL	R8,AAD(UCB.COB),R12	:GET ADDR OF CONTROLLER UCB
	O	R15,AAD(CB.BIT),R8	:BUSY CONTROLLER ONLY
	LIS	R8,DKCK
	OCR	R9,R8			:START CONTROLLER READ
	J	CSCAN1

:	READ
DKRD2	L	R12,AAD(PB.HUI),R13
	NR	R12,R15
	JN	CSCAN1			:ONE OR MORE DEVICES STILL BUSY
	JAL	R7,ACAU			:ALERT CONTROLLER AND UNIT
					: SENDS CYL NO TO UNIT
					: SENDS HEAD AND RECORD NO TO CONTROLLER
					: RETURNS R9 = CONTROLLER DEVICE ADDR
					: AND	R12 = UCB ADDR
	LI	R11,(GO+RDO)^18+(DKRD)^10+RAD(DKREND)
	LI	R8,(RAD(DKRD3))^10+RAD(CSCAN1)
	JFS	DKWRXY			:START CHANNEL I/O

:	WRITE
DKWR2	L	R12,AAD(PB.HUI),R13
	NR	R12,R15
	JN	CSCAN1			:ONE OR MORE DEVICES STILL BUSY
	JAL	R7,ACAU			:ALERT CONTROLLER AND UNIT
	LI	R11,(GO)^18+(DKWR)^10+RAD(DKWEND)
	LI	R8,(RAD(DKWR3))^10+RAD(CSCAN1)

DKWRXY	LHL	R7,AAD(PB.NEW),R13	:CHECK SUBFUNCTION FLAGS
	THI	R7,QSFF!QSFC		:FOR FORMAT OR CHECK READ
	JE	CHIO
	THI	R7,QSFC			:CHECK READ?
	JN	DKRDCK			:YES
	OI	R11,(DKFT)^10		:ENABLE FORMAT READ/WRITE
	J	CHIO			:AND START CHANNEL I/O




:	STATE 3 - I/O COMPLETED


:	READ
DKRD3	JAL	R7,CEX			:CHECK EXAMINE BIT
	J	DX0X4			:CONTROLLER ERROR
	JAL	R7,COF			:CHECK CYL OVERFLOW BIT
	J	DKRDOV			:HAD CYL OVERFLOW
	J	DX0X4			:DEFECTIVE TRACK OR CONTROLLER ERROR

:	WRITE
DKWR3	JAL	R7,CEX			:CHECK EXAMINE BIT
	J	DX0X6			:CONTROLLER ERROR
	JAL	R7,COF			:CHECK CYL OVERFLOW BIT
	J	DKWROV			:CYL OVERFLOW
	THI	R9,DEFTRK		:DEFECTIVE TRACK?
	JE	DX0X6			:NO, OVERRUN,ADDR CHECK, OR
					: WRITE CHECK

:	ASSIGN ALTERNATE CYLINDER AND WRITE OUT MAP

AACYL	LH	R8,AAD(UCB.MP),R11	:CHECK DISC MAP SWITCH
	JLFS	AACYL0			:NO ALT CYL IF DISC DISMOUNTED
	LH	R8,AAD(PB.MAP),R13	:ARE WE DOING A MAP WRITE?
	OH	R8,AAD(CYLNO),R11	:INCLUSIVE OR ALT CYL FLAG
	JEFS	AACYL2			:ASSIGN ALT CYL IF NOT ALREADY
					: AN ALT CYL AND NOT A MAP WRITE
AACYL0	LIS	R9,ERR.12		:ALT TRACK BAD NOT A MAP WRITE
AACYL1	J	UNEND1
AACYL2	L	R9,AAD(MSMA),R11	:GET ADDR ALT CYL MAP
AACYL3	LH	R8,0,R9			:SEARCH FOR A FREE MAP ENTRY
	JLFS	AACYLX			:IF L FOUND ONE
	AIS	R9,4			:ADJ INDEX TO EXAMINE NEXT ENTRY
	CL	R9,AAD(MEMA),R11
	JLBS	AACYL3
	LIS	R9,ERR.13		:NO ALT CYLS LEFT
	JBS	AACYL1

:	UPDATE CYLINDER MAP
AACYLX	LR	R10,R9
	S	R9,AAD(MSMA),R11	:MAKE INDEX
	SRLS	R9,2			:DIV BY 4
	AH	R9,AAD(BACYL),R11	:ADD BASE CYL. NO.
	LHL	R8,AAD(PB.CYL),R13	:BAD CYL NO
	EXHR	R8,R8			:POSITION IN HI ORDER HALF
	OR	R8,R9			:INCLUDE ALT CYL ASSIGNED
	ST	R8,0,R10		:UPDATE MAP
	ST	R10,AAD(ALTCYL),R11	:SAVE ADDR IN CASE MAP CANNOT
					: BE WRITTEN SUCCESSFULLY

:	PERMUTE REQUEST INTO MAP WRITE REQUEST
	LIS	R8,1
	STH	R8,AAD(PB.MAP),R13	:INDICATE MAP WRITE
	L	R8,AAD(MSMA),R11
	ST	R8,AAD(PB.SMA),R13
	L	R8,AAD(MEMA),R11
	ST	R8,AAD(PB.EMA),R13
	LHL	R8,AAD(MREC),R11
	ST	R8,AAD(PB.RTY),R13	:ZERO RETRY CTR
	L	R8,AAD(MCYL),R11
	ST	R8,AAD(PB.CYL),R13
	J	DKWROV			:CONTINUE WITH WRITE FOR MAP
	SUBTTL	DISC ROUTINES


:	CHANNEL END COROUTINES FOR READ AND WRITE
:	NOTE R11 = CHANNEL DEVICE ADDR, R12 = CHANNEL CONTROL BLK ADDR

DKREND
DKWEND	LHL	R10,AAD(CH.R),R12	:DPB ADDR
	LHL	R9,AAD(PB.UCB),R10	:UNIT ADDR
:
:THE FOLLOWING IS TO COLLECT THE ENDING ADDRESS FROM THE SELCH AND
:RECORD IT SO THAT IT IS AVAILBLE TO A SUBSEQUENT CONTINUATION OF
:THIS DISC OPERATION.  IT IS POSSIBLE FOR MAG TAPE TO RUN BEFORE
:THE DISC ITSELF INTERRUPTS.
:
        LHL     R9,AAD(UCB.CHB),R9      :ADDRESS OF SELCH BLOCK
        LH      R8,AAD(CB.DA),R9
        OC      R8,STOP                 :STOP THE SELCH
:
        RDR     R8,R9                   :READ THE ADDRESS
        EXHR    R9,R9                   :PUT INTO HIGH ORDER BYTE
        RDR     R8,R10                  :MIDDLE BYTE
        EXBR    R10,R10                 :POSITION
        OR      R9,R10                  :AND COMBINE
        RDR     R8,R10                  :GET LAST BYTE
        OR      R9,R10
:
        LHL     R10,AAD(CH.R),R12       :RECOVER DPB ADDRESS
:
        S       R9,AAD(PB.SMA),R10      :COMPUT A NEW ADDRESS
        AIS     R9,2
        NHI     R9,0FF00                :ROUND TO SECTOR BOUNDS
        A       R9,AAD(PB.SMA),R10
        ST      R9,AAD(PB.SMA),R10
        LHL     R9,AAD(PB.UCB),R10      :UNIT ADDRESS
:
	N	R15,AAD(CB.NBIT),R9	:UNBUSY UNIT.  DVEND WILL UNBUSY CHANNEL,
					: CONTROLLER INT. WILL UNBUSY CONTROLLER
	LH	R8,AAD(UCB.CDA),R9	:CONTROLLER DEVICE ADDR
	SSR	R8,R7			:SENSE CONTROLLER STATUS
	THI	R7,OVERRUN
	JE	CHEND1
	LHL	R9,AAD(UCB.COB),R9	:GET ADDR CONTROL BLK FOR CONTROLLER
	N	R15,AAD(CB.NBIT),R9	:UNBUSY CONTROLLER--NO INT. FROM THE
					: CONTROLLER IN THIS CASE
	J	CHEND1


:	DKRUS - READ UNIT STATUS

:	USE R7 FOR LINKAGE REGISTER
:	RETURNS  R8 = UNIT DEVICE ADDR
:		R10 = DEVICE STATUS
:		R11 = UCB ADDR

:	SETS SOFTWARE INTERLOCK BIT TO INDICATE UNIT IS BUSY PROCESSING
:	A REQUEST.  SENSES CONTROLLER STATUS AND HANGS UNTIL CONTROLLER
:	IS IDLE.  SENSES UNIT STATUS AND HANGS UNTIL ADS IS CLEAR.  DETECTS
:	DEVICE UNAVAILABLE AND ILLEGAL ADDRESS ERRORS (IRRECOVERABLE).
DKRS	LHL	R11,AAD(PB.UCB),R13	:FAST FORM OF DKRUS WITHOUT
	J	DKRUS0			:SETTING SOFTWARE INTERLOCK

DKRUS	LHL	R11,AAD(PB.UCB),R13	:GET UCB ADDR
	LHL	R9,AAD(UCB.COB),R11	:GET REL ADDR OF CONTROLLER BLOCK
	O	R14,AAD(CB.BIT),R9	:SET UNIT INTERLOCK FOR CONTROLLER
	O	R14,AAD(CB.BIT),R11	:SET UNIT INTERLOCK FOR ALL REQUESTS
	LH	R8,AAD(CB.BN),R11
	RBT	R8,AAD(PB.SUI),R13	:RESET UNIT INTERLOCK FOR THIS REQUEST
	LH	R8,AAD(CB.BN),R9	:GET BIT # FOR CONTROLLER
	RBT	R8,AAD(PB.SUI),R13	:RESET UNIT INTERLOCK
					: ONLY SO THIS REQUEST WILL CONTINUE
					: TO BE SERVICED UNTIL END-OF-REQUEST

	LH	R8,AAD(UCB.MP),R11	:CHECK FOR DISMOUNTED DISC
	AIS	R8,2
	JNFS	DKRUS0
	L	R8,AAD(PB.PRM),R13	:GET ADDR OF USER PARAM BLOCK
	LB	R8,SVC.RS,R8		:GET REQUEST BYTE
	STB	R8,AAD(PB.NEW),R13	:SET SUBFUNCTION FLAGS IN HI ORDER BYTE
DKRUS0	LH	R8,AAD(UCB.CDA),R11	:GET CONTROLLER DEVICE ADDR
DKRUS1	SSR	R8,R9			:SENSE CONTROLLER STATUS
	CLHI	R9,EX
	JE	DVNRDY			:CONTROLLER NOT ON BUSS
	SSR	R8,R9			:SENSE AGAIN
	JFBS	CIDLE,DKRUS1		:LOOP UNTIL CONTROLLER IDLE...POSSIBLY
					: UP TO 40 US BUT IN ACTUALITY, NEVER,
					: SINCE IT TAKES TIME TO REACH THIS POINT
	LH	R8,AAD(CB.DA),R11	:GET UNIT DEVICE ADDR
DKRUS2	SSR	R8,R10			:SENSE UNIT STATUS
	THI	R10,ADS			:DISK ADDRESS INTERLOCK?
	JNBS	DKRUS2			:LOOP UNTIL ADS RESET--POSSIBLY
					: UP TO 60 US FOLLOWING CONT IDLE
					: AFTER A WRITE BUT IN ACTUALITY
					: NEVER SINCE IT TAKES TIME TO REACH
					: THIS POINT
	EXBR	R9,R9			:POSITION CONTROLLER STATUS BYTE
	OR	R10,R9			:HI ORDER BYTE = CONTROLLER STATUS
					: LO ORDER BYTE = UNIT STATUS
	THI	R10,NRDY+ILLADR		:MASK OF IRRECOVERABLE ERRORS
	JER	R7			:RETURN TO CALLER
	LHI	R9,ERR.18		:ASSUME DEVICE UNAVAILABLE
	THI	R10,NRDY
	JN	DKRUS4
	ST	R10,DKRSTA		:SAVE STATUS RETURNED
	LHI	R9,RAD(DKRUS5)		:SET UP SCANNER SERVICE ADDR
	STH	R9,AAD(PB.STA),R13	:SAVE NEW SCANNER SERVICE ADDR
	LHL	R9,AAD(UCB.CDA),R11	:GET CONTROLLER DEVICE ADDR
	J	DX0X10			:DO RESTORE
DKRUS5	L	R10,DKRSTA		:GET BACK PREVIOUS STATUS
	LIS	R9,ERR.06		:ILL CYL ADDR--MUST BE PROBLEM WITH
					: KERNEL TABLES, OR WITH DISK FORMATTING
	JFS	DKRUS4

DKWRLK	LHI	R9,ERR.19		:VOLUME WRITE-LOCKED
	JFS	DKRUS4

DKRUS3	LIS	R9,ERR.07		:UNIT ERROR
	JFS	DKRUS4

DKER8	LIS	R9,ERR.08		:CONTROLLER ERROR
DKRUS4	J	UNEND1


:	CEX - CHECKS EXAMINE BIT IN CONTROLLER STATUS

:	USES R7 FOR LINKAGE REG
:	SKIP RETURN IF EX IS SET
:	NORMAL RETURN FOR OTHER CONTROLLER ERRORS
:	NO RETURN (JUMP TO UNEND) IF NO ERRORS
:	RETURNS  R8 = CONTROLLER DEVICE ADDR
:		 R9 = CONTROLER STATUS
:		R11 = UCB ADDR

CEX	LHL	R11,AAD(PB.UCB),R13	:GET UCB ADDR
	LH	R8,AAD(UCB.CDA),R11	:GET CONTROLLER DEVICE ADDR
	SSR	R8,R9			:SENSE CONTROLLER STATUS
	JT	EX,4,R7			:SKIP RETURN IF "EX" SET
	JTR	DKERR,R7		:NORMAL RETURN FOR DATA XFR ERROR...SET
					: FOR LONGITUDINAL PARITY ERROR, WRITE
					: PROTECT VIOLATION, DEVICE UNAVAILABLE, OR
					: WRITE CHECK.
	LH	R8,AAD(CB.DA),R11	:GET UNIT DEVICE ADDR
	SSR	R8,R10			:SENSE UNIT STATUS (MAY NOT
					: BE MEANINGFUL)
	EXBR	R9,R9
	OR	R10,R9
	J	UNEND


:	COF - CHECK FOR CYLINDER OVERFLOW CONDITON

:	USES R7 FOR LINKAGE REG
:	NORMAL RETURN FOR OVERFLOW
:	SKIP RETURN FOR OVERRUN,ADDR COMP FAIL, DEF TRK
:	REQUIRES R9 = CONTROLLER STATUS
COF	THI	R9,OVERRUN+ADDRCF+DEFTRK
	JN	4,R7
	THI	R9,CYLOV
	JE	4,R7
	LHL	R9,AAD(PB.CYL),R13	:GET CYL NO.
	AIS	R9,1			:INCREMENT TO NEXT CYL
	CLH	R9,AAD(DK.MXC),R11	:COMPARE MAX
	JGE	COF1			:LIKELY PROBLEM WITH KERNEL
					: TABLES - ERROR 5
	STH	R9,AAD(PB.CYL),R13	:UPDATE CYL IN DPB
	LIS	R9,0
	ST	R9,AAD(PB.RTY),R13	:ZERO RECORD NO. AND RETRY CTR
	STH	R9,AAD(PB.HED),R13	:ZERO HEAD NO.
        L       R9,AAD(PB.SMA),R13      :UPDATED BY SELCH INTERRUPT
	S	R9,AAD(PB.EMA),R13
	SIS	R9,1
	JLR	R7			:NORMAL RETURN
	LIS	R9,ERR.11		:SPURIOUS OVERFLOW INDICATION
	JFS	COF2			:OR CHANNEL PROBLEM
COF1	LIS	R9,ERR.05		:PROBLEM WITH KERNEL TABLES
COF2	LH	R8,AAD(UCB.CDA),R11	:GET CONTROLLER DEVICE ADDR
	SSR	R8,R7			:SENSE CONTROLLER STATUS
	LH	R8,AAD(CB.DA),R11	:GET UNIT DEVICE ADDR
	SSR	R8,R10			:SENSE UNIT STATUS
	OR	R10,R7
	J	UNEND1


:	ACAU - ALERT CONTROLLER AND UNIT

:	USES R7 AS LINKAGE REG
:	RETURNS  R9 = CONTROLLER DEVICE ADDR
:		R12 = UCB ADDR
ACAU	LHL	R12,AAD(PB.UCB),R13	:UCB ADDR AS EXPECTED BY CHIO
	LH	R8,AAD(CB.DA),R12	:UNIT DEVICE ADDR
	LHL	R9,AAD(CYLNO+2),R12	:CYL NO SAVED AT SEEK
	EXBR	R10,R9			:POSITION HI ORDER BYTE
	WDR	R8,R10			:WRITE CYL ADDR TO FILE - HI ORDER
	WDR	R8,R9			:WRITE CYL ADDR TO FILE - LO ORDER
	LH	R9,AAD(UCB.CDA),R12	:GET CONTROLLER DEVICE ADDR--REPLICATED
					: FOR CONVENIENCE IN UCB
	LH	R8,AAD(PB.HED),R13	:GET HEAD NO.
	SLLS	R8,5			:*** POSITION HEAD NO
					: *** HARDWARE DEPENDENT
	OH	R8,AAD(PB.REC),R13	:INCLUDE RECORD NO.
	WDR	R9,R8			:WRITE HEAD AND RECORD TO CONTROLLER
	JR	R7
	EI	(NDISC)


:	SIMULATED ESELCH INTERRUPT (TIMEOUT)

:	ENTER FROM FLASHER
:	R11 ON R1
:	EXPECTS R2 = ABSOLUTE ADDR OF CHANNEL UCB.
:		R4 = SLOWC
SHBACK	L	R3,DNDM			:GET THE MASK OF BUSY HARDWARE
	NI	R3,TIMED		:MASK OUT DEVICES WITH NO TIMEOUT
	ST	R3,SHTMP		:SAVE A COPY
SHBAK0	L	R3,SHTMP		:FOR EACH BUSY UNIT
	JFFO	R3,SHBAK1		:FIND ONE
	JR	R1			:FINSHED
SHBAK1	LB	R3,TTMOUT+1,R4,R4	:GET COUNTER
	SIS	R3,1			:COUNT DOWN
	JLFS	SHBAK2			:THIS TIMED OUT
	STB	R3,TTMOUT+1,R4,R4	:REPLACE
	RBT	R4,SHTMP		:DON'T DO AGAIN
	J	SHBAK0			:CONTINUE
SHBAK2	LHI	R2,E.PSW%I.ENA		:PSW TO DISABLE INTS
	EPSR	R0,R2			:*F*NOTE R0 AND R1 NOW CONTAIN RETURN PSD
	LB	R3,TTMOUT,R4,R4		:*F*GET DEVICE ADDRESS
	LHL	R3,IMIVEC,R3,R3		:*F*GET INTERUPT ROUTINE
	JR	R3			:*F*FAKE IMMEDIATE INTERUPT
SHTMP	WS	1			:TEMP FOR TIMEOUT ROUTINE

	IF	NDISC
	SUBTTL	DISC COMMAND FEATURE.

:ALLOW COMMANDS FILES ON DISC

:	COMMAND PROCESSOR FOR COMMANDS FILES.
:	R11 ON T4.  EXPECTS R2 = PORT INDEX FOR ECHOING COMMAND
:	R1 = ADDR OF USER BLOCK, AND R8 = ADDR FOR SUCCESS RETURN
DCP	LR	R6,R2
	AR	R6,R6			:DOUBLE R2 FOR HALFWORD INDEXING
	LH	R12,DPUN,R6,		:CHECK FOR COMMANDS ABORT
	JL	DCPEOF			:CLEANUP IF SO
	JAL	R15,OCHK,,		:IS THERE ROOM FOR ECHO?
	JGE	REPOP,,			:NO, GIVE UP TIME SLICE FOR NOW
	LH	R4,DPFLAG,,		:CHECK TO SEE IF COMMAND BUFFER BUSY
	JLFS	DCP1			:NOT BUSY
	CLR	R4,R2			:IS IT OURS?
	JN	REPOP,,			:JUMP IF NOT
DCP1	LHL	R4,DPUNIT,,
	CLH	R4,DPUN,R6,		:DO WE HAVE CORRECT UNIT?
	JN	DRG			:NO, HANDLE IT
	L	R4,DPVBNO,,
	CL	R4,DPBN,R6,R6		:DO WE HAVE CORRECT BLOCK?
	JN	DRG			:NO, HANDLE IT
	LB	R4,DPLRL,R2,		:GET LOGICAL RECORD LENGTH
	LB	R5,DPBX,R2,		:AND BYTE INDEX
	LB	R12,DPBUF,R5		:GET NEXT BYTE FROM BUFFER
	AIS	R5,1			:ADVANCE BX FOR NEXT TIME
	CLHI	R5,100			:CHECK FOR END OF BLOCK
	JNFS	DCP3
	LIS	R5,1
	AM	R5,DPBN,R6,R6		:INCREMENT BLOCK NO.
	LIS	R5,0			:SET TO BEGINNING OF NEW BLOCK
DCP3	STB	R5,DPBX,R2,		:SAVE UPDATED BYTE INDEX
:	WE NOW HAVE DATA BYTE--PERHAPS LAST IN BLOCK--IN R12
	LR	R4,R4			:CHECK RECORD LENGTH
	JE	DCPBOR			:IF ZERO WE HAVE SIZE OF NEXT RECORD IN R12
	SIS	R4,1			:DECREMENT RECORD LENGTH
	STB	R4,DPLRL,R2,		:SAVE UPDATED RECORD LENGTH
	LB	R6,F1ARGL,,
	NHI	R6,0F
	SLHLS	R6,2			:MAKE WORD INDEX
	ST	R12,RREG,R1,R6		:SAVE DATA IN SPECIFIED REGISTER
	TBT	R12,INECHO,,		:SHOULD THIS CHAR ECHO?
	JNR	R8			:SKIP RETURN FROM SVC IF NOT
	JAL	R15,OCHK,,		:SET UP REGISTERS FOR OUTPUT
	JAL	R15,OUT1CH,,		:ECHO CHAR
	NHI	R12,7F
	SIS	R12,0D
	JNR	R8			:SKIP RETURN FROM SVC
	LIS	R12,0A
	JAL	R15,OUT1CH,,
	JR	R8			:SKIP RETURN FROM SVC
:	BEGINNING OF RECORD
DCPBOR	LR	R12,R12			:CHECK END OF FILE
	JEFS	DCPEOF			:SKIP IF SO (ZERO LENGTH RECORD)
	STB	R12,DPLRL,R2,		:SAVE RECORD LENGTH
	J	DCP1			:AND GO AGAIN
DCPEOF	LCS	R4,1
	STH	R4,DPUN,R6,		:SWITCH COMMANDS OFF
	STH	R4,DPUNIT,,		:OBSOLETE OLD BUFFER
	RBT	R2,DPACT,,		:DEACTIVATE COMMANDS PROCESS
	TBT	R2,DPDET,,		:TEST FOR DETACHED PORT
	JE	ZIN1,,			:GET RID OF JOB IF SO
	JR	R7			:FAILURE RETURN--INPUT FROM TTY

:	READ BLOCK FROM COMMANDS FILE
DRG	LH	R4,DPFLAG,,		:ARE WE HERE ON REPOP?
	JGE	DRG2			:YES
	STH	R2,DPFLAG,,		:INDICATE I/O STARTED
	LHI	R4,100
	ST	R4,CBUF+SVC.CT
	LA	R4,DPBUF
	ST	R4,CBUF+SVC.VA
	L	R4,DPBN,R6,R6
	ST	R4,CBUF+SVC.VB
	LHL	R4,DPUN,R6,
	NHI	R4,0FF			:ISOLATE UNIT
	EXHR	R4,R4			:POSITION UNIT NO.
	ST	R4,CBUF			:SAVE UNIT AND READ COMMAND (0)
					: AND SET STATUS ZERO
DRG1	LIS	R8,QSFN			:FLAG NEW TYPE OF SVC CALL
	JAL	R11,GETDPB		:ALLOCATE DPB OR GET DISMISSED
	LIS	R5,0			:UNMAPPED
	LA	R4,CBUF			:ADDRESS OF PARAM BLOCK
	J	QIO1			:ENTER QIO SVC
DRG2	L	R4,CBUF			:CHECK FOR SVC STILL IN PROGRESS
	NI	R4,-1-0FF0000		:IGNORE UNIT
	JEBS	DRG1			:REPOP SVC UNTIL STATUS NONZERO
	LCS	R4,1
	STH	R4,DPFLAG,,		:I/O COMPLETE
	LB	R4,CBUF
	JNFS	DRG3			:SOME KIND OF ERROR
	L	R4,DPBN,R6,R6
	ST	R4,DPVBNO,,		:UPDATE CURRENT UNIT AND ADDRESS
	LHL	R4,DPUN,R6,
	STH	R4,DPUNIT,,
	J	DCP1
DRG3	LCS	R5,1
	STH	R5,DPUN,R6,		:SET TO ABORT COMMANDS PROCESS
	CLHI	R4,9			:WAS I/O ABANDONED?
	JE	REPOP,,			:REPEAT SVC IF SO
	LA	R12,DRGMSG
	J	OUT0A,,			:GIVE DIAGNOSTIC MESSAGE

DRGMSG	SC	/"8D"8Acommand file disc error/


:		COMMAND BUFFER FOR READING DPBUF
CBUF	WC	0,DPBUF,100,0		: (LOWEST ADDRESS FOR DISC-I/O)

:		BUFFER FOR DDT COMMANDS "SAVED" ON DISC
DPBUF	HS	100/2
	ELSE

CBUF	HS	0			:END OF ACCESSIBLE MEMORY
	EI	(NDISC)
	ELSE				:(.NOT. ESELCH)

CBUF	HS	0			:END OF ACCESSIBLE MEMORY
	EI	(ESELCH)
	SUBTTL	C O N T R O L   T A B L E S

:	(DEFINED HERE TO PERMIT POTENTIAL DISC-MAP READS INTO AREAS)

UNT	EQ	0

	IF	ESELCH
:		EXTENDED SELECTOR CHANNELS
	CHUCB(0F0)			:1ST ESELCH
	IF	XSELCH;	CHUCB(0F2)			:2ND ESELCH;	EI
	IF	NDISC

:		5440 DISCS
TYP	EQ	0			:START OUT WITH DISCS
	COUCB(0B6)			:1ST DISC CONTROLLER
	DK.PAIR(0B6,D0A0,D0A1)		:UNITS 0 AND 1
	IF	NDISC-1;	DK.PAIR(0B6,D0A2,D0A3)		:UNITS 2 AND 3;	EI
	IF	NDISC-2;	DK.PAIR(0B6,D0A4,D0A5)		:UNITS 4 AND 5;	EI
	IF	NDISC-3;	DK.PAIR(0B6,D0A6,D0A7)		:UNITS 6 AND 7;	EI
	IF	NDISC-4;	COUCB(036)			:2ND DISC CONTROLLER
	DK.PAIR(036,D0A8,D0A9)		:UNITS 0 AND 1;	EI
	IF	NDISC-5;	DK.PAIR(036,D0A10,D0A11)	:UNITS 2 AND 3;	EI
	IF	NDISC-6;	DK.PAIR(036,D0A12,D0A13)	:UNITS 4 AND 5;	EI
	IF	NDISC-7;	DK.PAIR(036,D0A14,D0A15)	:UNITS 6 AND 7;	EI
	EI	(NDISC)
	IF	NTAPE

:		TAPES
TYP	EQ	1
				:	::TAPE::
				:CONT.	UNIT
	MT.UCB(D1A0)		:0	0
	IF	NTAPE-1;	MT.UCB(D1A1)		:0	1;	EI
	IF	NTAPE-2;	MT.UCB(D1A2)		:0	2;	EI
	IF	NTAPE-3;	MT.UCB(D1A3)		:0	3;	EI
	IF	NTAPE-4;	MT.UCB(D1A4)		:1	0;	EI
	IF	NTAPE-5;	MT.UCB(D1A5)		:1	1;	EI
	IF	NTAPE-6;	MT.UCB(D1A6)		:1	2;	EI
	IF	NTAPE-7;	MT.UCB(D1A7)		:1	3;	EI
	EI	(NTAPE)
	EI	(ESELCH)

	IF	MSCDSK

:	MSC-1400 DISKS
TYP	EQ	2
QQ	EQ	0
Q1	EQ	0
	RE	MSCDSK			:FOR ALL CONTROLLERS:
Q	 EQ	0
	 RE	NMSC|QQ|		:FOR EACH DRIVE:
	  MS.UCB(D2A|Q1|,Q,MSCCY|QQ|,MSCTK|QQ|,MSCST|QQ|,MSC.C|QQ|)
Q	  EQ	Q+1
Q1	  EQ	Q1+1
	 ER
QQ		EQ	QQ+1
	ER
	EI	(MSCDSK)

:	DEFINE NULL NAME, TO TERMINATE LISTS
DUCB|UNT| EQ	0

HPATCH	HS	80			:SHARED DEVICE PATCH AREA

	KILL	CB.CMN,UCB.CMN,CHUCB,COUCB	:KILL MACRO DEFINITIONS
	KILL	DK.UCB,DK.PAIR,MT.UCB,MS.UCB


	FO	KCAREA
	FO	KERNEL
	IF	MSCDSK;	FO	MSC.INT;	EI
	IF	ESELCH;	FO	ES.INT;	EI
	KILL	RAD,AAD			:KILL MACRO REFERENCES
	EM
	BND	100			:FORCE TO A NICE BOUNDARY

	ELSE	(TSIDT)

	REMARK	%MDCSC Disc and Tape Server selected

	SUBTTL	MDCSC DISC AND TAPE SUPPORT DOCUMENTATION

:	THIS SECTION OF CODE ALLOWS SHARE SVC CALLS TO BE TARGETED
:	AT A DISC AND TAPE SERVER RESIDING ON MCDONNELL DOUGLAS M6000
:	MACHINES EQUIPED WITH TSI RUNNING ISIS V11.0 UPWARDS AND
:	MBASE V2.0 UPWARDS.

:	THE CODE IS CROSS REFERENCED TO THE DISIGN DOCUMENTS RELATING
:	TO THIS CODE -

:	MBASE SUPERVISOR SUPPORT - GED FOR ISIS, BY DICK RAWSON
:	MBASE SUPERVISOR SUPPORT - GID FOR ISIS, BY DICK RAWSON


	SUBTTL	MDCSC DISC AND TAPE SUPPORT

	LO	KERNEL
	LO	KCAREA

:	MDCSC DISC EMULATES THE MSC-1400 DISC

DVNM2	EQ	4D53			:DAVICE NAME - "MS"
MXCY2	EQ	MSCCY0			:MAX CYLINDERS (EMULATED CONTROLLER 0)
DDB2	EQ	$A 256			:DEFAULT BLOCK SIZE
DFNC2	EQ	0F0260000		:BIT ARRAY OF LEGAL SVC FUNCTIONS

:	DISC STATUS BITS
FAU	EQ	8000			:SYSTEM FAULT
RDO	EQ	0010			:READ ONLY
NRD	EQ	0002			:NOT READY

:	MDCSC TAPE EMULATION

DVNM1	EQ	4D54			:DEVICE NAME - "MT"
MXCY1	EQ	0FFFF			:LET USER PUT ANYTHING IN GU
LMAX1	EQ	NTAPE			:ONE LOGICAL PER PHYSICAL UNIT
DDB1	EQ	$A 512			:DEFAULT BLOCK SIZE
DFNC1	EQ	0FFF80000		:BIT ARRAY OF LEGAL SVC REQUESTS

:	TAPE STATUS BITS
BOT	EQ	0002			:BEGINNING OF VOLUME
WP	EQ	0004			:VOLUME WRITE-LOCKED
HI	EQ	0008			:HIDH DENSITY
ILL	EQ	0010			:ILLEGAL OPERATION ATTEMPTED
TE	EQ	0040			:TIMING ERROR
PER	EQ	0080			:PARITY ERROR
DU	EQ	0100			:DEVICE UNAVAILABLE
EOM	EQ	0200			:END OF OPERATION
NMTN	EQ	1000			:NO MOTION
ET	EQ	2000			:BOT OR END OF VOLUME
EOF	EQ	4000			:END OF FILE
ERR	EQ	8000			:DATA ERROR


:	JCOM EQUATES

APDHMX	EQ	$A 31		:APDU HEADER MAX
TPDHMX	EQ	4		:TPDU HEADER MAX
MXHDRM	EQ	APDHMX+TPDHMX	:MAX_HEADROOM

:	JCOM SIGNALS

BBLLMS	EQ	0A4		:BLACK BALL
SIIXMS	EQ	0BF		:SIIX
RNGWRP	EQ	0FF		:RING WRAP

:	JCOM STATES

DSCRDD	EQ	0		:DISCARDING DATA STRING MESSAGES
WTG.NM	EQ	1		:WAITING FOR A NEW MESSAGE OF ANY KIND
WTG.IX	EQ	2		:WAITING FOR IIX COMMAND FIELD
WTG.LI	EQ	3		:WAITING FOR TPDU LI FIELD
WTG.HD	EQ	4		:WAITING FOR TPDU HEADER
WTG.TD	EQ	5		:WAITING FOR TPDU DATA FIELD

:	JCOM SVC ERROR CODES

JCOMOK	EQ	0		:JCOM CONNECTED OR SUCCESSFULLY POLLED
JCMJIN	EQ	1		:JCOM NOT CONNECTED, JCOM DESCRIPTOR INACCESSIBLE
JCMRIN	EQ	2		:JCOM NOT CONNECTED, A RING DESCRIPTOR INACCESSIBLE
JCMPOL	EQ	3		:EXPECTED CONNECT, GOT POLL
JCMIPL	EQ	4		:JCOM OR RING DESCRIPTOR INVALID (POLL REQ)
JCMCON	EQ	5		:EXPECTED POLL, GOT CONNECT
JCMIVD	EQ	6		:INVALID JCOM DATA

:	TRANSPORT SERVICE EQUATES

:	TPDU TYPES

CRTPDU	EQ	1		:CONNECT REQUEST
CCTPDU	EQ	2		:CONNECT CONFIRM
DATPDU	EQ	3		:DATA

:	CC TPDU 

CCBODY	EQ	5		:CC DATA BYTES
CCPROT	EQ	1		:CC PROTOCOL TYPE

:	TRANSPORT PROTOCOL STATES

S01	EQ	1		:CONNECTION UNAVAILABLE (JCOM-OUT_OF_ORDER)
S02	EQ	2		:CONNECTION PENDING - DISCARDING DATA
S03	EQ	3		:CONNECTION PENDING - AWAITING CC TPDU
S04	EQ	4		:CONNECTION AVAILABLE

:	TRANSPORT EVENTS

NORDER	EQ	0		:N-OUT_OF_ORDER
NOPERL	EQ	1		:N-OPERATIONAL
NRESET	EQ	2		:N-RESET
NRSYNC	EQ	3		:N-RESYNC
TPDU	EQ	4		:TPDU
TSDU	EQ	5		:TSDU
CRSENT	EQ	6		:CR_TPDU_SENT_COMPLETE (PSEUDO EVENT)

:	TRANSPORT SIGNALS

SYNCMS	EQ	8085		:SIIX,8085 IS RESYNC MSG
CRINPR	EQ	1		:CONNECT REQUEST IN PROGRESS (DP.RQS)

	SUBTTL	DTS PROTOCOL EQUEATES

:	DTS MESSAGE FUCTION VALUES

UARFNC	EQ	1		:UNIT ATTACH REQUEST
UACFNC	EQ	2		:UNIT ATTACH CONFIRM
UDRFNC	EQ	3		:UNIT DETACH REQUEST
UDCFNC	EQ	4		:UNIT DETACH CONFIRM
URRFNC	EQ	5		:UNIT READ REQUEST
URSFNC	EQ	6		:UNIT READ RESPONSE
UWRFNC	EQ	7		:UNIT WRITE REQUEST
UWSFNC	EQ	8		:UNIT WRITE RESPONSE
TCRFNC	EQ	9		:TAPE CONTROL REQUEST
TCSFNC	EQ	$A 10		:TAPE CONTROL RESPONSE

:	DTS MESSAGE FIELD OFFSETS FROM FUNCT

FUNCT	EQ	0		:FUNCTION
LI3	EQ	FUNCT-3		:THREE BYTE LI
KEY	EQ	1		:KEY (CORRESPONDS TO DPB INDEX)
UNIT	EQ	2		:UNIT (CORRESPONDS TO GLOBAL UNIT NUMBER)
RCODE	EQ	3		:REASON CODE
STATS	EQ	5		:STATUS
POSN	EQ	7		:POSITION
SUBOP	EQ	POSN		:SUB OPERATION
RECL	EQ	$A 11		:RECORD LENGTH

:	UNIT ATTACH REQUEST/CONFIRM OFFSETS FROM FUNCT

UAKIND	EQ	3		:KIND
UASTAT	EQ	5		:STATUS
UANAME	EQ	7		:NAME
UAPROT	EQ	$A 15		:PROT
UAFMT	EQ	$A 16		:FMT
UAMAXP	EQ	$A 17		:MAXP
UARECL	EQ	$A 21		:RECL
UASPCE	EQ	$A 25		:SPACE
UADATA	EQ	$A 29		:DATA (NON-EXISTENT)

:	UNIT DETACH REQUEST/CONFIRM OFFSETS FROM FUNCT

UDRCDE	EQ	3		:RCODE
UDDATA	EQ	5		:DATA (NON-EXISTENT)

:	UNIT READ REQUEST/RESPONSE OFFSETS FROM FUNCT

URRCDE	EQ	3		:RCODE
URSTAT	EQ	5		:STATUS
URPOSN	EQ	7		:POSN
URRECL	EQ	$A 11		:RECL
URDATA	EQ	$A 15		:DATA (RESPONSE)

:	UNIT WRITE REQUEST/RESPONSE OFFSETS FROM FUNCT

UWRCDE	EQ	3		:RCODE
UWSTAT	EQ	5		:STATUS
UWPOSN	EQ	7		:POSN
UWRECL	EQ	$A 11		:RECL
UWDATA	EQ	$A 15		:DATA (REQUEST)

:	TAPE CONTROL REQUEST/RESPONSE OFFSETS FROM FUNCT

TCRCDE	EQ	3		:RCODE
TCSTAT	EQ	5		:STATUS
TCSBOP	EQ	7		:SUBOP
TCDATA	EQ	8		:DATA (NON-EXISTENT)

:	DTS STATUS FIELD VALUES

DTS.X	EQ	0800		:OFFLINE
DTS.R	EQ	0400		:READ ONLY
DTS.L	EQ	0200		:LOAD POINT
DTS.B	EQ	0100		:BEGINNING OR END OF TAPE
DTS.HI	EQ	0002		:HIGH DENSITY

:	SVC REQUESTS

RDSVC	EQ	0		:READ
WRTSVC	EQ	1		:WRITE
ATTSVC	EQ	2		:ATTACH
DETSVC	EQ	3		:DETACH
BSPSVC	EQ	4		:BACKSPACE
SFFSVC	EQ	5		:SKIP FILE FORWARD
SFRSVC	EQ	6		:SKIP FILE REVERSE
WFMSVC	EQ	7		:WRITE FILE MARK
REWSVC	EQ	8		:REWIND
UNLSVC	EQ	9		:UNLOAD
GSTSVC	EQ	$A 10		:GET STATUS
ERGSVC	EQ	$A 11		:ERASE GAP
SLDSVC	EQ	$A 12		:SET LOW DENSITY
MDDSVC	EQ	$A 13		:MOUNT DISC AND DETACH
MDASVC	EQ	$A 14		:DISMOUNT DISC AND ATTACH


	SUBTTL	 MACRO DEFINITIONS

:	MACRO TO DEFINE A GLOBAL UNIT ENTRY
:	FNC	-	BITT ARRAY OF LEGAL SVC REQUESTS
:	DEV	-	DEVICE, 1=MT, 2=MS
:	NAM	-	NAME, "MS" OR "MT
:	CYL	-	CYLINDER EXTENT
:	DFT	-	DEFAULT BLOCK SIZE
GENTRY	MACRO(NUM,FNC,DEV,NAM,CYL,DFT)	[
GUE|NUM|
	WC	0			:OTQ
	WC	0			:WTQ
	WC	FNC
	HC	0			:FLG
	BC	0			:ATT
	BC	DEV
	HC	NAM
	HC	CYL
	HC	DFT
	HC	0			:STA
]

DTSBYT	MACRO(OFFSET,COUNT)	[
	LA	R15,OFFSET,R4,R12
	LIS	R14,COUNT
	JAL	R13,DTSGET
]

DMACNL	MACRO [
	LIS	R15,0
	ST	R15,RBCDMA
]

DTSPER	MACRO(REG,COUNT)	[
	LHL	REG,COUNT
	AIS	REG,1
	STH	REG,COUNT
	TS	DTSERR
]


	SUBTTL	GLOBAL AND LOCAL UNIT TABLE LAYOUT (GU) (LU)

LSHARE	WS	0		:BASIS OF SHARED DEVICE HANDLERS


:	GLOBAL UNIT DESCRIPTOR BLOCK (GU)
	ORG	0
GU.OTQ	WS	1		:OUTSTANDING DPB QUEUE
GU.WTQ	WS	1		:WAITING DPB QUEUE (FOR TRANSPORT CONNECT)
GU.FNC	WS	1		:BIT ARRAY OF LEGAL FUNCTIONS FOR THIS UNIT
GU.FLG	HS	1		:FLAGS
GU.ATT	BS	1		:SLOT NUMBER (+1) WHO HAS RESERVED THE GU
GU.DEV	BS	1		:DEVICE TYPE
GU.NAM	BS	2		:DEVICE NAME
GU.CYL	HS	1		:NUMBER OF CYLINDERS
GU.DFT	HS	1		:DEFAULT BLOCKSIZE
GU.STA	HS	1		:STATUS OF LAST COMPLETED DPB
GULEN	HS	0		:GU BLOCK LENGTH, GULEN-GU.OUT

:	GU FLAG FIELDS

ATTSER	EQ	0		:ATTACHED TO SERVER
UARQOT	EQ	1		:UNIT ATTACH REQUEST OUTSTANDING


:	LOCAL UNIT DESCRIPTOR BLOCK (LU)

	ORG	0
LU.PB	BS	1		:PROTECTION BYTE
LU.GUN	BS	1		:GLOBAL UNIT NUMBER

	SUBTTL	DEVICE PARAMETER BLOCK AND DEVICE DESCRIPTOR LAYOUT (DPB) (DD)

:	LAYOUT OF DEVICE PARAMETER BLOCK
	ORG	0
DP.DTQ	WS	1		:Q ELEMENT FOR GU, FREE AND WAITING
DP.JCQ	WS	1		:Q ELEMENT FOR JCOM OUTPUT Q
DP.IDX	HS	1		:INDEX NUMBER OF THIS DPB
DP.FLG	HS	1		:FLAGS
DP.SVC	WS	1		:SVC PARAMATER BLOCK ADDRESS
DP.UBK	WS	1		:ADDRESS OF USER BLOCK
DP.GLU	WS	1		:ADDRESS OF GLOBAL UNIT
DP.TOT	WS	1		:TIMEOUT VALUE FOR TRANSPORT CONNECT
DP.DA1	WS	1		:DATA MESSAGE PART 1 ADDRESS (USUALLY DP.HED)
DP.LN1	WS	1		:DATA MESSAGE PART 1 LENGTH
DP.DA2	WS	1		:DATA MESSAGE PART 2 ADDRESS (USUALLY SLOT MEMORY)
DP.LN2	WS	1		:DATA MESSAGE PART 2 LENGTH
DP.SLT	BS	1		:SLOT ASSOCIATED WITH THIS DPB
DP.RQS	BS	1		:SVC REQUEST
DP.STA	HS	1		:SVC STATUS RETURN
DP.RS	BS	2		:SVC RESPONSE
DP.HED	BS	MXHDRM		:TPDU (AND APDU) HEADER
DPBLEN	WS	0		:LENGTH OF A DPB


:	DPB FLAG FIELDS

CANCEL	EQ	1		:CANCEL DPB
OUTCMP	EQ	2		:OUTPUT COMPLETE
CNTMSS	EQ	3		:CONTROL MESSAGE (FROM TRANSPORT SERVICE)
DATIDX	EQ	4		:DATA MESSAGE INDEX (PART 1 OR 2)
SIXSNT	EQ	5		:SIIX SENT FLAG
IGLN2	EQ	6		:JOLODR - IGNORE DP.LN2 (READ RECL SAVED HERE)

:	LAYOUT OF DEVICE DESCRIPTOR BLOCK
	ORG	0
DDB.NFU	WS	1		:MASK OF LEGAL FUNCTIONS FOR DEVICE (0-31)


	SUBTTL SVC DESCRIPTOR BLOCKS


:	SVC PARAMETER BLOCK
	ORG	0
SVC.RS	BS	1		:REQUEST/STATUS BYTE
SVC.LU	BS	1		:LOCAL UNIT NUMBER
SVC.ST	HS	1		:DEVICE STATUS BYTES 1 AND 2
SVC.VA	WS	1		:VIRTUAL MEMORY ADDRESS
SVC.CT	WS	1		:COUNT OF BYTES TO TRANSFER
SVC.VB	WS	1		:VIRTUAL BLOCK NUMBER (POSN)

	ORG	SVC.VA		:FIELDS SPECIFIC TO "READ STATUS"
SVC.PB	BS	1		:PB
SVC.GU	BS	1		:GLOBAL UNIT
SVC.NA	HS	1		:NAME FIELD
SVC.TY	BS	1		:DEVICE TYPE
SVC.DA	BS	1		:DEVICE ADDRESS
SVC.DD	HS	1		:DEFAULT BLOCK SIZE
SVC.BT	HS	1		:BLOCKS/TRACK
SVC.TC	HS	1		:TRACKS/CYLINDER
SVC.SC	HS	1		:START CYLINDER
SVC.NC	HS	1		:NUMBER OF CYLINDERS

:	JCOM SVC DESCRIPTOR

	ORG	0
JCD.HD	HS	2		:4-BYTE EYE-CATCHER ("JCOM")
JCD.VR	BS	1		:VERSION NUMBER
JCD.FN	BS	1		:FUNCTION (0 = CONNECT, 1 = POLL)
JCD.ST	HS	1		:IGNORE - USED ONLY BY MBASE
JCD.OR	WS	1		:JCOM OUT RING ADDRESS (PRIRP)
JCD.IR	WS	1		:JCOM IN RING ADDRESS (SECRP)

:	JCOM RING DESCRIPTOR

	ORG	0
JRGHED	HS	2		:4-BYTE EYE-CATCHER ("RING")
JRGBLN	HS	1		:LENGTH OF RING BUFFER
JRGNFI	HS	1		:NEXT FILL INDEX
JRGCEI	HS	1		:CURRENT EMPTY INDEX
	HS	1		:RESERVED
JRGBUF	HS	1		:START OF RING BUFFER





	SUBTTL	DISC AND TAPE DATA AREAS

:	DATA AREA FOR CONTROL VARIABLES, GLOBAL UNIT TABLES, DEVICE
:	PARAMETER BLOCKS, DEVICE DESCRIPTORS

:	BEGIN DATA
	ORG	LSHARE

PBERR	HC	0,S.PSW!I.ENA		:SVC PARAMETER BLOCK ERROR EXIT PSD
	HC	0,NOTI			:...END UP AT ILLEGAL SVC TRAP

:	JCOM STATUS TABLE

	HS	0
JCSLOT	HC	0FFFF		:SLOT NUMBER OF CONNECTED SLOT, OR -1 IF NONE
JCDESC	WS	1		:ADDR OF JCOM DESCRIPTOR (MBASE SLOT MEMORY)
JORDES	WS	1		:JCOM OUT RING DECRIPTOR ADDR (SEE JCD.OR)
JORGLN	HS	1		:LENGTH OF OUTPUT RING BUFFER
JIRDES	WS	1		:JCOM INPUT RING DESCRIPTOR ADDR (SEE JCD.IR)
JIRGLN	HS	1		:LENGTH OF INPUT RING BUFFER
JCOUTQ	WS	1		:JCOM OUTPUT QUEUE
JCOQND	WC	JCOUTQ		:JCOM OUTPUT QUEUE END POINTER


:	JCOM INPUT ANALYSIS CONTROLS

JCSTAT	HS	1		:JCOM STATE
TPHDLN	HS	1		:LENGTH OF TPDU IN HEADER BUFFER
TPDULN	WS	1		:TPDU LENGTH SPECIFIED BY "LI" FIELD
TPDUAD	WS	1		:ADDR OF TPDU IN RING OR HEADER BUFFER

:	JCOM HEADER BUFFER

JHBNFI	HS	1		:JCOM HEADER BUFFER NEXT FILL INDEX
JCHDST	HS	1		:JCOM HEADER BUFFER STATUS
JCHDBF	BS	MXHDRM		:MAX_HEADROOM IN LENGTH

:	JCOM SIMULATOR CONTROLS

	WS	0
NFADMA	WS	1		:NEXT FILL ADDR IN SLOT MEMORY BUFFER
IBCDMA	WS	1		:INITIAL BYTE COUNT OF TRANSFER
RBCDMA	WS	1		:REMAINING BYTE COUNT OF TRANSFER
RBCTPD	WS	1		:REMAINING BYTE COUNT OF TPDU
DATOFF	HS	1		:OFFSET OF DATA FIELD FROM IST BYTE OF TPDU LI FIELD
GLUDMA	WS	1		:GLOBAL UNIT INDEX OF GU INVOLVED IN TRANSFER
DMASLT	HS	1		:SLOT INVOLVED IN TRANSFER

:	TRANSPORT STATUS TABLE

	HS	0
TRSTAT	HS	1		:TRANSPORT STATE
SRCREF	HS	1		:SRC-REF OF LAST CR TPDU
NORDCT	HC	0		:N-OUT_OF_ORDER COUNT
INTPDU	HC	0FFFF		:TPDU BOUNDARY FLAG: 0=WITHIN TPDU
TPROTE	WC	0		:TRANSPORT PROTOCOL ERROR ARRAY

:	DTS STATUS TABLE

TRACON	HC	0		:TRANSPORT CONNECTION, 0-NO, 1-YES
ATNEED	HC	0		:UNIT ATTACHES NEEDED
SONWTQ	HC	0		:SLOTS ON WAIT QUEUE COUNT
DTSDIE	HC	0		:SLOT NEEDS CRASHING FLAG

:	DTS PROTOCOL ERROR TABLE

DTSERR	HC	0		:DTS PROTOCOL ERROR FLAG
E.DFA1	HC	0		:GU FAULT  (DPBFAP)
E.DFA2	HC	0		:DPB FAULT (DPBFAP)
E.ILFN	HC	0		:ILLEGAL FUNCTION CODE (DTSARX)
E.ILLN	HC	0		:ILLEGAL APDU LENGTH (DTSARX)
E.DNGU	HC	0		:DPB NOT ON GU (RETDPB)

:	DTS VARIABLES

:	SWQ,EWQ. START AND END OF THE DPB WAIT QUEUE. SLOTS ARE PUT ON THIS
:	QUEUE IF THE DPB POOL IS EMPTY, IF THE SLOT HAS OVERLAPPED MORE THAN
:	ITS ALLOWANCE OF SVC'S

SWQ	WC	0		:START OF SLOT WAIR QUEUE
EWQ	WC	SWQ		:END OF SLOT WAIT QUEUE

BPA	WC	0		:CURRENT DPB ADDRESS
AVAIL	WC	0		:AVAILABLE DPB LIST


:	DBP,GU,LU STORAGE AREA

:	HERE ARE THE DPB'S
DPBPOL	WS	0		:FORCE WORD BOUNDARY
	BS	NDPB*DPBLEN	:DPB STORAGE AREA


:	HERE IS THE GLOBAL UNIT TABLE
GUT	WS	0		:FORCE WORD BOUDARY

	KILL	BITCH1,BITCH2,GUP1,GUP2

BITCH	MACRO	[REMARK %Exceeded max no. of cylinders
]

GUP1	MACRO	(N)	[
Q4	EQ	GU1|N|			:GU TYPE, 1=MT, 2=MS, 80=DK
Q5	EQ	GU2|N|			:PHYSIACL UNIT
Q6	EQ	GU3|N|			:START CYLINDER (HEX)
Q7	EQ	GU4|N|			:# OF CYLINDERS (HEX)
]

GUP2	MACRO(N)	[
Q8	EQ	MXCY|N|			:MAX CYLINDERS
Q9	EQ	LMAX|N|			:MAX PHYSICAL UNIT
Q10	EQ	DFNC|N|			:LEGAL REQUESTS FOR THIS GU
Q11	EQ	DVNM|N|			:DEVICE NAME - MT,MS
Q12	EQ	DDB|N|			:DEFAULT BLOCK SIZE
]

	GENTRY(0,0,0,0,0,0)		:GU 0 IS NULL

Q	EQ	1
	RE	NGLU
Q3	EQ	3			:ASSUME ERROR
	GUP1(Q)
	IF	Q4
Q4	EQ	7F&Q4
	  GUP2(Q4)
	  IF	    Q6-Q8+1
	    BITCH()
	  ELSE	    Q6+Q7-Q8
	    BITCH()
	  ELSE	    Q5-Q9+1
	    REMARK %Eceeded unit limit
	  ELSE
Q3	  EQ	    0
	  GENTRY(Q,Q10,Q4,Q11,Q7,Q12)
	  EI
	ELSE
Q3	  EQ	    0
	  GENTRY(Q,0,0,0,0,0)
	EI
	IF	Q3
	  GENTRY(Q,0,0,0,0,0)
	  REMARK ,  Unit
	  NUMBER  Q5
	  REMARK  type
	  NUMBER  Q4
Q7	  EQ	Q6+Q7-1
	  REMARK  STCYL
	  NUMBER  Q6
	  REMARK  ENCYL
	  NUMBER  Q7
	EI
Q	EQ	Q+1
	ER
	RA	0
	KILL	BITCH,GUP1,GUP2		:MACROS NOT NEEDED ANY MORE




	SUBTTL	DTS I/O DEVICE SERVICE INITIALIZATION (ITSIDT) - CALLED BY MINIT

:****************************************************************
:*								*
:*	ROUTINE	- ITISDT					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R0	-	PRESERVE THIS REGISTER			*	
:*								*
:*	LINK REGISTER - R1					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.2		*
:*								*
:*	CLEAR ALL THE CONTROL FIELDS IN THE GLOBAL UNIT TABLE.	*
:*	INITIALIZE ALL THE DPB'S AND LINK THEM ON THE AVAILABLE	*
:*	LIST. INITIALIZE THE DTS AND TRANSPORT STATUS TABLES.	*
:*								*
:****************************************************************

ITSIDT
	LIS	R3,0
	LIS	R4,1

	:INIT DTS STATUS TABLE

	STH	R3,TRACON		:TRNASPORT CONNECTION MISSING
	STH	R3,ATNEED		:NO ATTACHES NEEDED
	STH	R3,SONWTQ		:NO SLOTS ON WAIT Q

	:INIT THE TRANSPORT STATUS TABLE

	STH	R4,TRSTAT		:TRANSPORT STATE: S01
	STH	R3,SRCREF		:SOURCE REF OF TRANSPORT CONNECTION
	STH	R3,NORDER		:N-OUT_OF_ORDER COUNT

	:INIT THE DPB'S BY THREADING ALL NDPB'S ONTO THE AVAILABLE LIST,THEN
	:RESERVE DPB(0) FOR THE TRANSPORT LAYER (USED FOR N-RESYNC CR TPDU)

	LA	R2,DPBPOL		:BASE ADDRESS OF DPB'S
	LHI	R3,NDPB			:NUMBER OF DPB'S
	LHI	R4,0			:DPB INDEX NUMBER

DTIS2
	LR	R5,R2			:R5 -> CURRENT DPB
	AHI	R2,DPBLEN		:R2 -> NEXT DPB
	ST	R2,DP.DTQ,R5		:LINK ON THE DPB
	STH	R4,DP.IDX,R5		:DPB INDEX NUMBER
	AIS	R4,1			:NEXT INDEX
	SIS	R3,1			:FOR NDPB
	JNBS	DTIS2

	ST	R3,DP.DTQ,R5		:MARK END OF Q

	LA	R2,DPBPOL		:RESERVE DPB(0) FOR TRANSPORT
	L	R4,DP.DTQ,R2
	ST	R3,DP.DTQ,R2
	ST	R4,AVAIL

:	EMPTY SLOT WAIT QUEUE

	L	R4,SWQ
	JEFS	DTIS4			:SKIP IF Q EMPTY

	ST	R3,SWQ			:EMPTY THE Q
DTIS3
	SHI	R4,ESWQ			:POINT TO BEGINNING OF USER BLOCK
	L	R5,ESWQ,R4		:ADDRESS OF NEXT ENTRY
	ST	R3,ESWQ,R4		:CANCEL WAIT
	ST	R3,DREQ,R4		:NO REQUESTS OUTSTANDING
	L	R4,R5
	JNBS	DTIS3			:FOR ALL ENTRIES ON Q

DTIS4
	LA	R5,SWQ			:INIT EWQ
	ST	R5,EWQ

:	INIT THE GLOBAL UNIT TABLE

	IF	NGLU

	LA	R2,GUT
	LHI	R4,NGLU+1		:GU(0) IS NULL, BUT CLEAR IT ANYWAY
DTIS5
	LR	R5,R2			:R5 -> CURRENT GU
	AHI	R2,GULEN		:R2 -> NEXT GU
	ST	R3,GU.OTQ,R5		:CLEAR OUT SOME FIELDS
	ST	R3,GU.WTQ,R5
	STH	R3,GU.FLG,R5
	STB	R3,GU.ATT,R5
	STH	R3,GU.STA,R5
	SIS	R4,1
	JN	DTIS5			:FOR NGLU+1

	EI	(NGLU)

	JR	R1			:RETURN TO CALLER


	SUBTTL	DTS CRASH RESPONSE ROUTINE (DTSCRA) - CALLED BY DCDEV

:****************************************************************
:*								*
:*	ROUTINE - DTSCRA					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R0	-	PRESERVE				*
:*	R1	-	USER BLOCK				*
:*	R12	-	SCRATCH					*
:*	R13	-	SCRATCH					*
:*	R14	-	SCRATCH					*
:*								*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.3		*
:*								*
:*	CALLED BY KERNEL ROUTINE DCDEV - WHICH IS CALLED WHEN	*
:*	A SLOT CRASHES OR RESTARTS. iF THE SLOT HAS A GLOBAL	*
:*	UNIT, CLEAR UP ANY ACTIVITY PENDING ON IT.		*
:*	DO WE ALSO NEED TO CHECK WHETHER THE SLOT IS ON THE	*
:*	SWQ ?							*
:****************************************************************

DCRASV	WS	1		:SAVE AREA
DTSCRA
	IF	NXLU

	ST	R11,DCRASV	:SAVE LINK REGISTER

	LIS	R12,0
	LHI	R13,NXLU	:NUMBER OF EXTENDED LOGICAL UNITS

DTSCR1
	LHL	R14,LUT,R12,R1	:GET AN LU ENTRY
	NHI	R14,0FF		:GET THE GLOBAL UNIT NUMBER
	JEFS	DTSCR2		:IF EMPTY, DO NOTHING
	JAL	R11,DEVRES	:OTHERWISE, RESET THE DEVICE
DTSCR2
	AIS	R12,2		:OFFSET TO NEXT LU
	SIS	R13,1
	JNBS	DTSCR1		:FOR NXLU

	L	R11,DCRASV

	EI	(NXLU)
	JR	R11		:RETURN TO CALLER


	SUBTTL	DTS DEVICE RESET ROUTINE (DEVRES)

:****************************************************************
:*								*
:*	ROUTINE - DEVRES					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R1	-	USER BLOCK ADDRESS			*
:*	R14	-	GU NUMBER				*
:*								*
:*	LINK REGISTER	-  R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.6
:*								*
:*	GOES THOUGH THE TWO Q'S OF DPB'S ON A GU AND CHECKS	*
:*	WHETHER THE SLOT OWNS ANY OF THEM. IF SO, THE CANCEL	*
:*	FLAG IS SET IN THE DPB.					*
:****************************************************************

DVRSAV	WS	6			:SAVE AREA
DEVRES
	STM	R10,DVRSAV
	LHL	R10,SLOT,R1		:GET THE SLOT THAT CRASHED
	LIS	R11,CANCEL		:WE MIGHT NEED TO CANCEL DPB'S
	LHI	R12,GULEN		:GU TABLE ENTRY LENGTH
	MHR	R14,R12			:GU OFFSET FROM GUT
	LA	R13,GUT			:GU TABLE ADDRESS
	LR	R15,R13
	AR	R15,R14			:R15 -> GU
	CLH	R10,DMASLT		:DID SLOT HAVE DMA GOING ?
	JNFS	DEVRSA			:SKIP IF NOT
	DMACNL				:OTHERWISE, CANCEL THE DMA
DEVRSA
	L	R12,GU.OTQ,R14,R13	:DPB'S ON THE OUTSTANDING Q
	JE	DEVRS3			:IF NOTHING HERE, CHECK WAIT Q

DEVRS1
	CLB	R10,DP.SLT,R12		:DPB OWNED BY CRASHED SLOT?
	JNFS	DEVRS2			:SKIP IF NOT
	SBT	R11,DP.FLG,R12		:OTHERWISE, CANCEL THE DPB
DEVRS2
	L	R12,DP.DTQ,R12		:GET NEXT DPB IN Q
	JNBS	DEVRS1

DEVRS3
	L	R12,GU.WTQ,R14,R13	:ANYTHING ON THE WAIT Q?
	JE	DEVRS6			:SKIP IF NOT

DEVRS4
	CLB	R10,DP.SLT,R12		:DPB OWNED BY CRASHED SLOT
	JNFS	DEVRS5			:SKIP IF NOT
	SBT	R11,DP.FLG,R12		:OTHERWISE, CANCEL THE DPB
DEVRS5
	L	R12,DP.DTQ,R12		:GET NEXT DPB IN Q
	JNBS	DEVRS4

DEVRS6
	LM	R10,DVRSAV		:RESTORE
	JR	R11			:RETURN TO CALLER


	SUBTTL	DTS TIMER ROUTINE (DTSTMR)

:****************************************************************
:*								*
:*	ROUTINE  - DTSTMR					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R2,R3,R4,R8,R9,R10,R11	-	SCRATCH			*
:*								*
:*	LINK REGISTER	-  R1					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.5		*
:*								*
:*	GO THOUGH EVERY GLOBAL UNIT AND CHECK FOR DPB'S ON THE	*
:*	WAIT Q. IF THE DPB HAS TIMED OUT : IF THE DPB HAS NOT	*
:*	BEEN CANCELLED BY THE CRASH RESPONSE ROUTINE, THEN	*
:*	RETURN 'DEVICE UNAVAILABLE TO THE USER, OTHERWISE THE	*
:*	CANCEL FLAG IS SET, SO JUST RETURN THE DPB.		*
:****************************************************************

TMRSAV	WS	1			:SAVE AREA
DTSTMR
	ST	R1,TMRSAV		:SAVE LINK

	IF	NGLU

	LHL	R3,TRACON		:IS THERE A TRANSPORT CONNECTION?
	JN	DTTMR6			:IF THERE IS, CHECK FOR SLOTS TO CRASH

	LA	R9,GUT			:GU TABLE ADDRESS
	LHI	R8,NGLU			:NUMBER OF GU'S
	L	R10,FASTC,,		:GET CURRENT FAST CLOCK
	LIS	R4,CANCEL		:DPB CANCEL FLAG

	:GU(0) IS NULL
DTTMR0
	AHI	R9,GULEN		:POINT TO NEXT GU
DTTMR1
	L	R3,GU.WTQ,R9		:PICK UP WAITING DPB Q
	JE	DTTMR5			:SKIP TO NEXT GU
DTTMR2
	CL	R10,DP.TOT,R3		:HAS THE DPB TIMED OUT?
	JNC	DTTMR4			:SKIP IF NOT
	TBT	R4,DP.FLG,R3		:WAS THE DPB CANCELLED?
	JEFS	DTTMR3			:SKIP IF NOT
	JAL	R11,RETDPB		:CANCEL, SO JUST RETURN DPB
	J	DTTMR1			:HAVE TO SEARCH Q AGAIN
DTTMR3
	JAL	R11,DTSDUN		:RETURN 'DEVICE UNAVAILABLE' TO USER
	J	DTTMR1			:HAVE TO SEARCH Q AGAIN
DTTMR4
	L	R3,DP.DTQ,R3		:GET NEXT DPB ON Q
	JN	DTTMR2			:FOR ALL DPB'S ON Q

DTTMR5
	SIS	R8,1
	JN	DTTMR0			:FOR NGLU

	EI	(NGLU)

DTTMR6
	JAL	R11,DTSKLL		:SEE IF ANY SLOTS NEED CRASHING

	L	R1,TMRSAV		:RESTORE LINK
	JR	R1			:RETURN TO CALLER

:	DTSKLL - SEARCH ALL RUNNING JOBS FOR KDISC TO BE SET IN THE
:	SLOT WAIT FLAGS. IF THE FLAG IS SET, THE JOB NEEDS CRASHING
:	BECAUSE TRASNPORT IS NOT AVAILABLE.

DTKSAV	WS	10			:CRASH CALL SAVE AREA
DTSKLL
	LHL	R10,DTSDIE		:ANY SLOTS TO CRASH ?
	JER	R11			:EXIT IF NOT

:	SEARCH THE NON-FOREGROUND Q FOR JOBS TO CRASH

	L	R1,RUN,,		:GET THE JOB LIST
	JE	DTKLL3			:SKIP IF NONE RUNNING
DTKLL1
	LHL	R10,WFLAG,R1		:GET THE WAIT FLAGS
	NHI	R10,KDISC		:SEE IF SLOT NEEDS CRASHING
	JEFS	DTKLL2			:SKIP IF NOT
	STM	R0,DTKSAV		:KRASH USES LOTS OF REGISTERS
	KRCODE(0,9,0)			:DEVICE NOT READY
	JAL	R11,KRASH,,		:CRASH THE SLOT
	LM	R0,DTKSAV		:RESTORE REG'S
	LIS	R10,0
	STH	R10,WFLAG,R1		:LET THE SLOT CRASH
DTKLL2
	L	R1,LLINK,R1		:GET NEXT SLOT ON Q
	JN	DTKLL1			:AND CHECK IT

:	SEARCH THE FOREGROUND JOB LIST

DTKLL3
	L	R1,QUASI,,
	JE	DTKLL6			:SKIP IF NO JOBS
DTKLL4
	LHL	R10,WFLAG,R1		:SEE IF SLOT NEEDS CRASHING
	NHI	R10,KDISC
	JEFS	DTKLL5			:SKIP IF NOT
	STM	R0,DTKSAV		:KRASH USES LOTS OF REGISTERS
	KRCODE(0,9,0)			:DEVICE NOT READY
	JAL	R11,KRASH,,		:CRASH THE SLOT
	LM	R0,DTKSAV		:RESTORE REG'S
	LIS	R10,0
	STH	R10,WFLAG,R1		:LET THE SLOT CRASH
DTKLL5
	L	R1,LLINK,R1		:GET NEXT JOB ON Q
	JN	DTKLL4			:AND CHECK IT

DTKLL6
	LIS	R10,0			:SHOW WE HAVE SEARCHED ...
	STH	R10,DTSDIE		:THE QUEUES

	JR	R11			:RETURN TO CALLER




	SUBTTL	DTS SHARE SVC HANDLER (TSISHR)

:****************************************************************
:*								*
:*	ROUTINE  -  TSISHR					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R1	-	ADDR OF USER BLOCK			*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.7		*
:*								*
:*	THIS ROUTINE IS INVOKED BY A SLOT SHARE SVC CALL.	*
:*	FIRST A CHECK IS MADE FOR ANY SLOTS THAT NEED CRASHING	*
:*	THEN IT VALIDATES THE SVC PARAMETERS IN THE AND EITHER	*
:*	INITIATES PROCESSING OR DENIES THE REQUEST		*
:*								*
:****************************************************************

:	SVC OPERAND POINTS TO A FOUR WORD PARAMETER BLOCK
:	---------------------------------
:	|0| R/S |  LU   |    STATUS     |
:	|-------------------------------|
:	|     VIRTUAL MEMORY ADDRESS    |
:	|-------------------------------|
:	|         BYTE COUNT            |
:	|-------------------------------|
:	|        DEVICE ADDRESS         |
:	---------------------------------

:	QIO SVC LICENCES AND SUBOP VALUES
PRVTBL	BC	(RD)^-8,	00	:00 - READ
	BC	(WR)^-8,	00	:01 - WRITE
	BC	(AT)^-8,	00	:02 - ATTACH
	BC	(AT)^-8,	00	:03 - DETACH
	BC	(RD!WR)^-8,	05	:04 - BACKSPACE
	BC	(RD!WR)^-8,	07	:05 - SKIP FILE FWD
	BC	(RD!WR)^-8,	08	:06 - SKIP FILE REV
	BC	(WR)^-8,	03	:07 - WRITE FILE MARK
	BC	(RD!WR)^-8,	09	:08 - REWIND
	BC	(RD!WR)^-8,	0A	:09 - UNLOAD
	BC	(RD!WR)^-8,	01	:0A - GET STATUS
	BC	(WR)^-8,	04	:0B - ERASE GAP
	BC	(RD!WR)^-8,	02	:0C - SET LOW DENSITY
	BC	(AT)^-8,	00	:0D - MOUNT DISC AND DETACH
	BC	(AT)^-8,	00	:0E - DISMOUNT DISC AND ATTACH

	GL	TSISHR
TSISHR
	LR	R4,R1			:KEEP A COPY OF USER BLK ADDR
	JAL	R11,DTSKLL		:SEE IF ANY SLOTS NEED CRASHING
	LR	R1,R4			:GET USR BLK ADDR BACK
	L	R12,F1ARG,,		:POINTER TO PARAMETER BLOCK
	LHL	R13,RPSW+2,R1		:FETCH STATUS BITS OF PSW
	LHI	R5,400			:EXAMINE MAC BIT
	NR	R5,R13
	JAL	R11,ACCESS,,		:CONVERT ADDRESS TO PHYSICAL ADDRESS
	LPSW	PBERR			:BAD MEMORY ACCESS - ILLEGAL SVC
	LR	R4,R12			:RETAIN ADDRESS OF PARAMETER BLOCK
					:IN R4 THOUGHOUT HANDLER
	LIS	R3,0
	ST	R3,BPA			:CLEAR CURRENT DPB FIELD

	LB	R7,SVC.LU,R4		:GET LOCAL UNIT NUMBER
	CLHI	R7,NXLU
	JGE	SVCE.2			:LU NUMBER TOO BIG

	AR	R7,R7			:MAKE HALF WORD INDEX INTO
	LHL	R7,LUT,R1,R7		:LOCAL UNIT TABLE IN USER BLOCK
	JE	SVCE.3			:IF ZERO, NO SUCH UNIT

	LBR	R8,R7			:GET GLOBAL UNIT NUMBER
	JE	SVCE.2			:NO GU(0)

	CLHI	R8,NGLU
	JG	SVCE.2			:NO GU THAT HIGH

	LHI	R9,GULEN		:LENGTH OF GU ENTRY
	MHR	R9,R8
	LA	R9,GUT,R9,		:ADDR OF GU
	LB	R6,GU.ATT,R9		:GET THE ATTACHED SLOT
	JE	TSSH01			:IF ZERO UNIT IS NOT ATTACHED
	SIS	R6,1			:ADJUST TO ACTUAL SLOT NUMBER
	CLH	R6,SLOT,R1		:IS IT THE REQUESTING SLOT?
	JN	SVCE15			:IF NOT, THIS ERROR SHOULD RETURN
					:SLOT OF OWNER IN "STATUS"

TSSH01
	LB	R10,SVC.RS,R4
	NHI	R10,1F			:IGNORE SUBFUNC AND OVERLAP BITS
	TBT	R10,GU.FNC,R9		:IS IT A LEGAL FUNCTION FOR THIS UNIT
	JE	SVCE16			:IF NOT, PRETEND UNIMPLEMENTED
	LHL	R6,PRVTBL,R10,R10	:FETCH REQUEST PRIVILEGE MASK
	NHI	R6,0FF00		:CHOP OFF SUBOP BITS
	NR	R6,R7			:SEE IF SLOT ALLOWED THIS REQUEST
	JE	SVCE.3			:ACCESS DENIED

	:CHECK WHETHER SLOT WANTS TO ATTACH/DETACH THE UNIT

	CLHI	R10,ATTSVC
	JN	TSSH02
	LHL	R6,SLOT,R1		:ATTACH TO THIS SLOT
	AIS	R6,1			:BIAS SLOT NOMBER
	STB	R6,GU.ATT,R9
	LIS	R6,0
	STB	R6,SVC.RS,R4		:TELL SLOT OK
					:MORE "STATUS" PARAMS ???
	J	KRET,,			:RETURN TO SLOT
TSSH02
	CLHI	R10,DETSVC
	JN	TSSH03
	LIS	R6,0
	STB	R6,GU.ATT,R9		:DETACH THE UNIT
	STB	R6,SVC.RS,R4		:TELL SLOT OK
	J	KRET,,			:RETURN TO SLOT
TSSH03
	JAL	R11,GETDPB		:ALLOCATE A DPB OR PERHAPS GET STALLED
	ST	R9,DP.GLU,R3		:SAVE GLOBAL UNIT ADDR
	STB	R10,DP.RQS,R3		:SAVE REQUEST IN DPB
	ST	R4,DP.SVC,R3		:SAVE SVC ADDR
	CLHI	R10,GSTSVC		:GET STATUS REQUEST?
	JN	TSSH04

:	GET STATUS REQUEST
	JAL	R10,PARRW		:CHECK WRITE ACCESS TO PARAMETER BLOCK
					:THE ROUITNE MAY FAIL THE SVC
	STH	R7,SVC.PB,R4		:PROTECTION MASK AND GLOBAL UNIT
	LHL	R6,GU.NAM,R9		:DEVICE NAME
	STH	R6,SVC.NA,R4
	LHL	R6,GU.DFT,R9		:DEFAULT BLOCK SIZE
	STH	R6,SVC.DD,R4
	LIS	R6,0
	ST	R6,SVC.BT,R4		:BLOCKS/TRACK TRACKS/CYL
	ST	R6,SVC.SC,R4		:START AND NUMBER CYL
	LB	R6,GU.DEV,R9		:DEVICE TYPE
	STB	R6,SVC.TY,R4
	SIS	R6,1			:CHECK FOR TAPE
	JE	TSSH04			:IF SO, WE SNED THE REQUEST
					:OTHERWISE DISC,STRAIGHT BACK TO SLOT
	LHL	R6,GU.CYL,R9		:NUMBER OF CYLINDERS
	STH	R6,SVC.NC,R4
	LHI	R6,MSCST0		:SECTORS/TRACK FOR MS 0
	STH	R6,SVC.BT,R4
	LHI	R6,MSCTK0		:TRACKS/CYLINDER
	STH	R6,SVC.TC,R4
	LIS	R9,0			:THIS DPB IS NOT ON A GU
	ST	R9,DP.GLU,R3
	STB	R9,SVC.RS,R4		:SVC OK
	JAL	R11,RETDPB		:GET RID OF THE DPB
	J	KRET,,			:RETURN TO SLOT

TSSH04
	LB	R6,DP.RQS,R3		:PICK UP REQUEST
	JNFS	TSSH05			:SKIP IF ITS NOT A READ
	JAL	R10,PARRW		:OTHERWISE CHECK WRITE TO PARAM BLOCK
	JFS	TSSH06
TSSH05
	CLHI	R6,WRTSVC		:IF NOT A READ OR WRITE REQUEST
	JN	TSSH09			:JUST CONSTRUCT THE REQUEST AND ISSUE
TSSH06
	LCS	R12,2
	N	R12,SVC.VA,R4		:ASSURE EVEN MEMORY ADDR
	L	R13,SVC.CT,R4		:FETCH BYTE COUNT
	JNFS	TSSH07			:SKIP IF SPECIFIED
	LHL	R13,GU.DFT,R9		:OTHERWISE USE DEFAULT BLOCKSIZE
TSSH07
	THI	R13,1			:IS BYTE COUNT EVEN ?
	JN	SVCE.A			:NO, ERROR
	AR	R13,R12			:LAST MEM ADDR + 1
	SIS	R13,1
	LR	R5,R5			:WAS MAC BIT SET?
	JEFS	TSSH09			:NO, ALREADY PHYSICAL ADDR
	LR	R11,R6			:READ OR WRITE ?
	JEFS	TSSH08			:READ
	LHI	R11,RRO-RRW		:WRITE
TSSH08
	JAL	R11,RRW,R11,		:CHECK MEM WRITE ACCESS
	J	SVCE.1			:NON SKIP RETURN, ERROR


TSSH09
	L	R3,BPA			:RESTORE BP-- SMASHED BY RRO OR RRW
					:ONLY R0,R1,R4,R7,R8,R9, ARE SAFE
:	R9 -> GU
:	R3 -> DPB
:	R1 -> USER BLOCK

	JAL	R11,CNAPDU		:CONSTRUCT THE APDU
	JAL	R11,DTSGUR		:SEND THE DPB TO TRANSPORT

:	IF WE RETURN HERE, THEN THE SLOT HAS REQUESTED OVERLAP
:	AND ITS QUOTA HAS NOT BEEN EXCEEDED
	J	KRET,,			:RETURN TO SLOT

	SUBTTL	ERRO RETURNS FROM SVC HANDLER

:	UNIT ALREADY ATTACHED - R6 = SLOT NUMBER OF OWNER
SVCE15	LHI	R5,ERR.21
	STH	R6,SVC.ST,R4
	J	SVCERR

:	UNIMPLEMENTED REQUEST TYPE
SVCE16	LHI	R5,ERR.22
	JFS	SVCERR

:	BAD MEMORY ACCESS
SVCE.1	LIS	R5,ERR.01
	JFS	SVCERR

:	NO SUCH UNIT
SVCE.2	LHI	R5,ERR.02
	JFS	SVCERR

:	PRIVILEGED REQUEST TYPE
SVCE.3	LIS	R5,ERR.03
	JFS	SVCERR

:	ACCESS OUTSIDE AREA
SVCE.4	LIS	R5,ERR.04
	JFS	SVCERR

:	ODD BYTE COUNT
SVCE.A	LIS	R5,ERR.10

:	SVC ERROR RETURN ROUTINE
:	(BPA) = DPB ADDR
:	R5 = ERROR CODE

SVCERR
	L	R3,BPA			:SEE IF THERE IS A DPB TO RETURN
	JN	SVCER1			:SKIP IF THERE IS
	STB	R5,SVC.RS,R4		:SET UP ERROR CODE
	J	KRET,,			:NON-SKIP RETURN TO USER
SVCER1
	L	R4,DP.SVC,R3		:GET THE SVC ADDR CORRESPONDING TO
	STB	R5,SVC.RS,R4		:THIS DPB, UPDATE STATUS
	LIS	R5,0			:SHOW THIS DPB NOT ATTACHED TO A GU
	ST	R5,DP.GLU,R3
	JAL	R11,RETDPB		:RETURN THE DPB
	J	KRET,,

:	ROUTINE TO CONSTRUCT AN APDU
:	R9 -> GU
:	R3 -> DPB
:	R1 -> USER BLOCK
:	R11 - LINK REGISTER
:	R12 - TRANSFER PHYSICAL START ADDR
:	R13 - TRANSFER PHYSICAL END ADDR

CNAPDU
	:INITIALIZE SOME OF THE DPB FIELDS
	LIS	R6,0
	STH	R6,DP.FLG,R3		:CLEAR FLAGS
	LHL	R6,SLOT,R1
	STB	R6,DP.SLT,R3		:SET UP SLOT NUMBER
	ST	R1,DP.UBK,R3		:SAVE USER BLOCK ADDR
	LA	R6,DP.HED,R3		:APDU HEADER IN DPB WORK AREA
	ST	R6,DP.DA1,R3		:POINT TO IT

	L	R4,DP.SVC,R3		:GET THE SVC ADDR
	LR	R5,R13
	SR	R5,R12
	AIS	R5,1			:TRANSFER LENGTH
	ST	R12,DP.DA2,R3		:TRANSFER START
	ST	R5,DP.LN2,R3

	LB	R6,DP.RQS,R3		:WHAT WAS REQUESTED ?
	JE	CAPDU4			:SKIP IF IT WAS READ
	SIS	R6,1
	JN	CAPDU5			:SKIP IF IT WAS TAPE CONTROL

:	OTHERWISE IT'S A WRITE REQUEST

	LIS	R6,UWRFNC
	STB	R6,DP.RQS,R3		:UNIT WRITE REQUEST APDU
	AHI	R5,UWDATA+1		:ADD WRITE APDU HEADER LENGTH
					:+1 AS MINIMUM LI FIELD
	LIS	R7,1			:OFFSET TO 'FUNC' FIELD
	CLHI	R5,7F
	JLE	CAPDU3			:TRY FOR 1 BYTE LI FIELDS
CAPDU2
	AIS	R5,2			:3 BYTE LI
	AIS	R7,6			:MOVE UP THE OFFSET TO FUNC
	LR	R8,R5			:CONSTRUCT TPDU LENGTH
	AIS	R8,4			: 3 BYTE LI + 1 BYTE TYPE
	SLLS	R8,8			:GET LI AT MOST SIG END
	AIS	R8,DATPDU		:MOVE IN 'DA' TYPE
	LIS	R6,0
	ST	R8,DP.HED,R3		:SET UP TPDU HEADER
	SBT	R6,DP.HED,R3		:SET THE TOP BIT (3 BYTE LI)

	SLLS	R5,8			:POSITION THE APDU LI FIELD
	AIS	R5,UWRFNC		:THIS IS A WRITE APDU
	ST	R5,DP.HED+4,R3		:SET UP THE APDU HEADER
	SBT	R6,DP.HED+4,R3		:SHOW IT'S A THREE BYTE LI
	LI	R6,UWDATA+7		:TPDU LENGTH - DATA FIELD LENGTH
	ST	R6,DP.LN1,R3
	J	CAPDU7			:FILL IN THE REST OF THE APDU
CAPDU3
	LR	R8,R5			:GET TPDU LENGTH
	AIS	R8,2			:SEE IF 1 BYTE LI WILL DO
	CLHI	R8,7F
	JG	CAPDU2			:SKIP TO THREE BYTE LI FIELDS
	AIS	R7,2			:OFFSET TO FUNC FIELD
	SLLS	R8,8			:BUILD THE HEADER
	AIS	R8,DATPDU		:THIS IS A DATA TPDU
	SLLS	R8,8
	AR	R8,R5			:APDU LI FIELD
	SLLS	R8,8
	AIS	R8,UWRFNC		:THIS IS A WRITE APDU
	ST	R8,DP.HED,R3		:SET IT UP IN THE DPB BUFFER
	LI	R6,UWDATA+3		:TPDU LENGTH - DATA FIELD LENGTH
	ST	R6,DP.LN1,R3
	J	CAPDU7
CAPDU4
	LHI	R5,URDATA+1		:READ APDU HEADER LENGTH
	LIS	R10,0			:FLAG 'READ REQUEST'
	JFS	CAPDU6	
CAPDU5
	LHI	R5,TCDATA+1		:TAPE CONTROL APDU HEADER LENGTH
	LIS	R10,TCRFNC-URRFNC	:FLAG 'TAPE CONTROL'
					:FUNC(TC)-FUNC(RD)
CAPDU6
	LIS	R7,3			:OFFSET TO FUNC FIELD
	LR	R8,R5
	AIS	R8,2			:TPDU LENGTH
	ST	R8,DP.LN1,R3		:ALSO MSG 1 LENGTH
	SLLS	R8,8
	AIS	R8,DATPDU		:THIS IS A DATA TPDU
	SLLS	R8,8
	AR	R8,R5			:MOVE IN APDU LENGTH
	SLLS	R8,8
	AIS	R8,URRFNC		:THIS IS A READ APDU
	AR	R8,R10			:OR MAYBE A TAPE CONTROL APDU
	ST	R8,DP.HED,R3		:SET UP HEADER FIELDS IN BUFFER
	LR	R10,R10			:IS IT A TAPE CONTROL REQUEST?
	JN	CAPDU8			:SKIP IF IT IS
	LIS	R6,IGLN2		:TELL JOLODR TO IGNORE DP.LN2
	SBT	R6,DP.FLG,R3		:.. AS THIS FIELD HOLDS READ RECL
	LIS	R6,URRFNC
	STB	R6,DP.RQS,R3		:UNIT READ REQUEST APDU
CAPDU7
	LA	R8,DP.HED,R3		:POINT TO THE BUFFER
	L	R5,DP.LN2,R3		:GET RECL
	ST	R5,RECL,R8,R7		:SET UP RECL
	L	R5,SVC.VB,R4
	ST	R5,POSN,R8,R7		:SET UP POSN
	J	CAPDU9
CAPDU8
	LIS	R6,0
	ST	R6,DP.LN2,R3		:NO MSG PART 2 FOR TAPE CONTROL
	LA	R8,DP.HED,R3		:POINT TO THE BUFFER
	LB	R5,DP.RQS,R3		:GET THE REQUEST
	NHI	R5,1F			:CHOP OFF TOP BITS
	LHL	R6,PRVTBL,R5,R5		:GET SUBOP FOR THIS REQUEST
	STB	R6,SUBOP,R8,R7		:SET UP SUBOP
	LIS	R6,TCRFNC
	STB	R6,DP.RQS,R3		:TAPE CONTROL REQUEST APDU
CAPDU9
	LHL	R6,DP.IDX,R3		:DPB INDEX
	STB	R6,KEY,R8,R7		:BECOMES APDU KEY
	LB	R6,SVC.LU,R4		:GET LOCAL UNIT
	SLHLS	R6,1			:MAKE HALFWORD INDEX
	LHL	R6,LUT,R1,R6		:GET GLOBAL UNIT
	STB	R6,UNIT,R8,R7		:APDU UNIT
	LIS	R6,0
	STH	R6,STATS,R8,R7		:CLEAR STATUS
	STH	R6,RCODE,R8,R7		:CLEAR RCODE

	JR	R11			:RETURN TO CALLER



	SUBTTL	DTS GLOBAL UNIT REQUESTOR (DTSGUR)

:****************************************************************
:*								*
:*	ROUTINE	- DTSGUR					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R9	-	GU					*
:*	R3	-	DPB					*
:*	R1	-	USER BLOCK				*
:*								*
:*	LINK REGISTER	-  R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.8		*
:*								*
:*	THIS ROUTINE IS CALLED BY THE SHARE SVC HANDLER AFTER	*
:*	A DEVICE PARAMETER BLOCK HAS BENN PREPARED FOR THE	*
:*	REQUEST. IF POSSIBLE, THE DPB WILL BE QUEUED ON THE	*
:*	GLOBAL UNIT OUSTANDING Q AND PASSED TO TRANSPORT.	*
:*	EXCEPTION CONDITIONS ARE TRANSPORT NOT BEING AVAILABLE	*
:*	OR THE GLOBAL UNIT NOT BEING ATTACHED AT THIS TIME.	*
:*								*
:****************************************************************

GURSAV	WS	1			
DTSGUR
	ST	R11,GURSAV		:SAVE LINK

	LHL	R5,TRACON		:DO WE HAVE A TRANSPORT CONNECTION?
	JN	DTSGR1			:SKIP IF WE DO
	LHL	R5,DTSTO,R1		:GET THE TIME THE SLOT CAN WAIT
	LHI	R6,RATE			:SECONDS TO FASTC CONVERT
	MHR	R5,R6
	L	R6,FASTC,,		:GET CURRENT TIME
	AR	R5,R6
	ST	R5,DP.TOT,R3		:SET UP TIME OUT IN DPB
	JAL	R11,PDPBWQ		:PUT DPB ON WAIT Q
	J	DTSGR5			:PUT SLOT IN WAIT MODE
DTSGR1
	LIS	R6,ATTSER
	TBT	R6,GU.FLG,R9		:IS THE UNIT ATTACHED TO SERVER
	JE	DTSGR3			:SKIP IF NOT
	JAL	R11,PDPBOQ		:PUT DPB ON OUTPUT Q
	JAL	R11,TVTSDU		:TELL TRANSPORT ABOUT TSDU
	L	R4,DP.SVC,R3		:GET SVC ADDR
	LHL	R5,DREQ,R1		:GET OUSTANDING REQUESTS
	AIS	R5,1			:AND INCREMENT
	STH	R5,DREQ,R1
	CLH	R5,DQUOTA,R1		:HAS SLOT EXCEEDED QUOTA ?
	JG	DTSGR5			:IF SO, DISMISS
	LB	R5,SVC.RS,R4		:DID SLOT REQUEST OVERLAP ?
	NHI	R5,80
	JE	DTSGR5			:IF ZERO, DISMISS SLOT
	L	R11,GURSAV		:PICK UP LINK
	JR	R11			:THE SVC HANDLER WILL LET THE
					:SLOT CONTINUE PROCESSING
DTSGR3
	JAL	R11,PDPBWQ		:PUT DPB ON WAIT Q
	LIS	R6,UARQOT		:CHECK IF UNIT ATTACH IS OUTSTANDING
	TBT	R6,GU.FLG,R9		:IF THERE IS, JUST PUT SLOT IN WAIT
	JN	DTSGR5			:SKIP TO PUT IN WAIT
	LR	R2,R1			:SAVE USER BLOCK ADDR
	LIS	R1,0			:FLAG GETDPB NOT TO DISMISS IF NO
	JAL	R11,GETDPB		:DPB'S ARE AVAILABLE
	LR	R1,R2			:RETORE USER BLOCK POINTER
	LR	R3,R3			:DID WE GET A DPB ?
	JEFS	DTSGR4			:SKIP IF NO DPB
	JAL	R11,DTSSUA		:OTHERWISE, SEND UNIT ATTACH
	JFS	DTSGR5			:AND PUT SLOT IN WAIT
DTSGR4
	LHL	R5,ATNEED		:INCRMENT ATTACHES NEEDED
	AIS	R5,1
	STH	R5,ATNEED
DTSGR5
	LHI	R5,FDSK1
	LIS	R6,0
	OH	R5,WFLAG,R1
	STH	R5,WFLAG,R1		:SET FDSK1 IN WAIT FLAGS
	STH	R6,QUANTUM,R1		:CANCEL QUANTUM REMAINING
 if     SPAM
  if     SPMTRC
          LHI     R10,23                :SPAM TRACE ROUTINE ID
  ei     (SPMTRC)
          JAL     R9,ENTIM,,            :COLLECT END DATA
 ei     (SPAM)
	J	MAIN,,			:ENTER ISIS MAIN LOOP

:	SEND UNIT ATTACH ROUTINE (DTSSUA)

:	R9 -> GU
:	R3 -> DPB
:	R1 -> USER BLOCK

:	UNIT ATTACH SKELETON
DTSUA	HC	(LITLUA^8)!DATPDU		:LI,TYP
	HC	(LIDLUA^8)!UARFNC		:LI,FUNC
UAKEY	BC	0				:KEY
UAUNIT	BC	0				:UNIT
UAKIND	BC	0,0				:KIND
UASTAT	BC	0,0				:STATUS
UANAME	AC	/  GBLU/			:NAME
UANNUM	AC	/01/				:NUMBER
UAPROT	BC	1				:PROT
UAFMT	BC	0				:FMT
UAMAXP	BC	0,0,0,0				:MAXP
UARECL	BC	0,0,0,0				:RECL
UASPCE	BC	0,0,0,0				:SPACE
DUALEN	BS	0

LITLUA	EQ	DUALEN-DTSUA			:LI TPDU
LIDLUA	EQ	LITLUA-2			:LI APDU

SUASAV	WS	1
DTSSUA
	ST	R11,SUASAV		:SAVE LINK
	LHI	R6,UARQOT		:UNIT ATTACH REQUEST OUTSTANDING
	SBT	R6,GU.FLG,R9		:MARK IN GU
	LIS	R6,UARFNC
	STB	R6,DP.RQS,R3		:UNIT ATTACH REQUEST APDU
	ST	R9,DP.GLU,R3		:SAVE GU ADDR
	LA	R8,DP.HED,R3		:DPB WORK AREA
	ST	R8,DP.DA1,R3		:SET UP ADDR
	LIS	R6,0
	ST	R6,DP.LN2,R3		:NO MSG PART 2
	STH	R6,DP.FLG,R3		:CLEAR DPB FLAGS
	LHI	R6,LITLUA		:UNIT ATTACH LENGTH
	ST	R6,DP.LN1,R3		:SET UP LENGTH

	LA	R7,DTSUA		:BUILD REQUEST IN SKELETON
	LHL	R5,DP.IDX,R3		:GET DPB INDEX
	STB	R5,UAKEY-DTSUA,R7	:SET UP KEY
	JAL	R11,GUATON		:GET GLOBAL UNIT NUMBER
	STB	R15,UAUNIT-DTSUA,R7	:SET UP UNIT

:	AND THE REST OF THE FIELDS
	LB	R5,GU.DEV,R9		:GET DEVICE TYPE
	LIS	R6,0			:2=DISC, 1=TAPE
	STH	R6,UASTAT-DTSUA,R7	:ASSUME DISC
	STB	R6,UAFMT-DTSUA,R7	:FMT
	CLHI	R5,1			:TAPE ?
	JNFS	DTSUA0			:SKIP IF DISC
	LIS	R6,2			:SELECT HIGH DENSITY
	STH	R6,UASTAT-DTSUA,R7	:... FOR THE TAPE UNIT
	LIS	R6,1
DTSUA0
	STH	R6,UAKIND-DTSUA,R7	:KIND
	LR	R6,R6
	JEFS	DTSU00			:SKIP IF DISC
	LIS	R5,0
	ST	R5,UAMAXP-DTSUA,R7	:TAPE MAXP
	ST	R5,UARECL-DTSUA,R7	:TAPE MAXP
	ST	R5,UASPCE-DTSUA,R7	:TAPE SPACE
	J	DTSU01
DTSU00
	LHL	R5,GU.DFT,R9		:DEFAULT RECORD SIZE
	ST	R5,UARECL-DTSUA,R7	:DISC RECL
	LHL	R5,GU.CYL,R9		:# CYLINDERS
	LHI	R6,MSCTK0*MSCST0	:SECTORS/CYLINDER
	MHR	R5,R6
	ST	R5,UAMAXP-DTSUA,R7	:DISC MAXP
	LR	R11,R5
	LHL	R6,GU.DFT,R9		:DEFAULT RECORD SIZE
	MR	R5,R11
	ST	R6,UASPCE-DTSUA,R7	:DISC SPACE
DTSU01
	LB	R5,UAUNIT-DTSUA,R7	:GET UNIT
	LIS	R6,$A 10		:CONVERT TO DECIMAL
	DHR	R5,R6
	AHI	R6,30			:ASCII TENS
	STB	R6,UANNUM-DTSUA,R7	:GU NAME
	AHI	R5,30			:ASCII UNITS
	STB	R5,UANNUM+1-DTSUA,R7	:GU NAME

:	COPY THE UNIT ATTACH TO THE DPB BUFFER

	LHI	R6,LITLUA		:UNIT ATTACH LENGTH
DTSUA1
	LB	R5,-1,R7,R6		:GET A BYTE FROM SKELETON
	STB	R5,-1,R8,R6		:PUT IT IN DPB BUFFER
	SIS	R6,1
	JNBS	DTSUA1			:FOR DUALEN

	JAL	R11,PDPBOQ		:PUT DPB ON O/P Q
	JAL	R11,TVTSDU		:TELL TRANSPORT ABOUT TSDU
	L	R11,SUASAV		:RESTORE LINK
	JR	R11			:RETURN TO USER



	SUBTTL	DTS T-CONNECT RECEIVER (DTSTCN)

:****************************************************************
:*								*
:*	ROUTINE - DTSTCN					*
:*	-------							*
:*	LINK REGISTER	-  R10					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.9		*
:*								*
:*	MARK TRANSPORT CONNECTED AND ATTACH ANY WAITING UNITS	*
:****************************************************************

TCNSAV	WS	1			:SAVE AREA
DTSTCN
	ST	R10,TCNSAV		:SAVE LINK
	TS	TRACON			:SHOW TRANSPORT CONNECTED
	JAL	R11,DTSAWU		:ATTACH ANT WAITING UNITS
	L	R10,TCNSAV		:RESTORE LINK
	JR	R10			:RETURN TO CALLER

	SUBTTL	DTS ATTACH WAITING GLOBAL UNITS (DTSAWU)

:****************************************************************
:*								*
:*	ROUTINE - DTSAWU					*
:*	-------							*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.10		*
:*								*
:*	CALLED BY DTS T-CONNECT AND RETURN DPB ROUTINE.		*
:*	IF THERE ARE DPB'S WAITING ON A UNIT AND THER IS NOT	*
:*	A UNIT ATTACH REQUEST OUTSTANDING, THEN SEND ONE IF A	*
:*	DPB IS AVAILABLE.					*
:*								*
:****************************************************************

AWUSAV	WS	1			:LINK SAVE AREA
DTSAWU
	ST	R11,AWUSAV		:SAVE LINK
	LHI	R10,NGLU		:NUMBER OF GLOBAL UNITS
	LR	R2,R1			:SAVE USER BLOCK POINTER
	LIS	R1,0			:NON-USER FLAG FOR GETDPB
	LA	R9,GUT			:GLOBAL UNIT TABLE
DTSAW1
	AHI	R9,GULEN		:POINT TO NEXT GU
	L	R7,GU.WTQ,R9		:ANYTHING ON THE WAIT Q
	JE	DTSAW2			:SKIP THIS UNIT IF NOT
	LHI	R8,UARQOT
	TBT	R8,GU.FLG,R9		:IS THER A UA RQST OUTSTANDING ?
	JN	DTSAW2			:SKIP IF THERE IS
	JAL	R11,GETDPB		:TRY AND GET A DPB
	LR	R3,R3			: GOT ONE ?
	JE	DTSAW3			:IF NOT, INC ATTACHES NEEDED AND EXIT
	JAL	R11,DTSSUA		:SEND UNIT ATTACH
DTSAW2	SIS	R10,1
	JN	DTSAW1			:FOR NGLU
DTSAW3
	LR	R1,R2			:POINT TO USER BLOCK
	L	R11,AWUSAV		:PICK UP LINK
	JR	R11			:RETURN TO CALLER			


	SUBTTL	DTS T-DISCONNECT RECEIVER (DTSTDS)

:****************************************************************
:*								*
:*	ROUTINE	- DTSTDS					*
:*	-------							*
:*	LINK REGISTER	-  R10					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.11		*
:*								*
:*	GO THOUGH EVERY GLOBAL UNIT AND RETURN ALL DPB'S TO	*
:*	DEVICE ANAVAILABLE, WHICH WILL UPDATE THE SVC OR JUST	*
:*	RETURN THE DPB IF IT WAS CANCELLED OR A UNIT ATTACH	*
:*	REQUEST.						*
:****************************************************************

DTSTDS
	LIS	R6,0
	STH	R6,TRACON		:SHOW NO TRANSPORT AVAILABLE
	STH	R6,ATNEED		:SHOW NO ATTACHES NEEDED
	LA	R9,GUT			:GLOBAL UNIT TABLE
	LHI	R7,NGLU			:NUMBER OF GLOBAL UNITS
DTSTD1
	AHI	R9,GULEN		:POINT TO NEXT GU
	LIS	R6,0
	STH	R6,GU.FLG,R9		:CLEAR FLAGS
	L	R4,GU.OTQ,R9		:RETURN "DEVICE UNAVAILABLE" FOR ANY
					:..DPB'S THAT JCOM HAS OUTPUT TO RING
DTSTD2
	LR	R3,R4			:GET DPB ADDR
	JEFS	DTSTD3			:SKIP IF NONE
	L	R4,DP.DTQ,R3		:REMEMBER NEXT DPB ON Q
	LIS	R6,OUTCMP		:SEE IF JCOM HAS FINISHED...
	TBT	R6,DP.FLG,R3		:..WITH THIS DPB
	JEBS	DTSTD2			:SKIP IF NOT
	JAL	R11,DTSDUN		:OTHERWISE, RETURN STATUS
	JBS	DTSTD2			:CHECK NEXT DPB
DTSTD3
	L	R4,GU.WTQ,R9		:THESE DPB'S ARE WAITING FOR JCOM..
					:..SO JUST CLEAR THEM UP NOW
DTSTD4
	LR	R3,R4			:GET DPB ADDR
	JEFS	DTSTD5			:SKIP IF NONE
	L	R4,DP.DTQ,R3		:REMEMBER NEXT DPB ON Q
	JAL	R11,DTSDUN		:RETURN STATUS
	JBS	DTSTD4
DTSTD5
	SIS	R7,1
	JN	DTSTD1			:FOR NGLU

	JR	R10			:RETURN TO CALLER


	SUBTTL	DTS APDU RECEIVER (DTSARX)

:****************************************************************
:*								*
:*	ROUTINE - DTSARX					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R4	->	1ST BYTE OF APDU LI FIELD		*
:*	R5	-	LENGTH OF APDU				*
:*								*
:*	LINK REGISTER	-  R10					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.12		*
:*								*
:*	THE TRANSPORT EVENT HANDLER CALLS THIS ROUTINE TO	*
:*	DELIVER A TSDU TO THE APPLICATION LAYER.		*
:*	IF THE DPB CORRESPONDING TO THIS TSDU HAS BEEN		*
:*	CANCELLED THEN THE TSDU IS DISCARDED, OTHERWISE		*
:*	THE TSDU IS PROCESSED.					*
:*								*
:****************************************************************

DTSARX
	LB	R6,0,R4			:GET 1ST BYTE OF LI
	LIS	R12,1			:ASSUME 1 BYTE LI
	LB	R14,0,R4		:GET APDU LENGTH
	SIS	R14,1			:AND TAKE OFF LI FIELD LENGTH
	NHI	R6,80			:GET THE TOP BIT
	JEFS	DTSR01
	AIS	R12,2			:IT'S A 3 BYTE LI
	DTSBYT(LI3,3)			:GET APDU LENGTH
	NI	R14,7FFFFF		:DROP LI TOP BIT
	SIS	R14,3			:AND TAKE OFF LI FIELD LENGTH
DTSR01
	LB	R6,FUNCT,R4,R12		:GET THE FUNC
	CLHI	R6,MAXFNC		:RANGE CHECK
	JG	ILLFNC			:ILLEGAL FUNCTION
	SLHLS	R6,2			:MAKE FULLWORD INDEX
	L	R6,DTRTAB,R6,		:GET THE HANDLER
	JR	R6			:AND GO TO IT


DTRTAB	WC	ILLFNC			:OUT OF RANGE
	WC	ILLFNC			:UNIT ATTACH REQUEST
	WC	DTRUAC			:UNIT ATTACH CONFIRM
	WC	ILLFNC			:UNIT DETACH REQUEST
	WC	DTRUDC			:UNIT DETACH CONFIRM
	WC	ILLFNC			:UNIT READ REQUEST
	WC	DTRURR			:UNIT READ RESPONSE
	WC	ILLFNC			:UNIT WRITE REQUEST
	WC	DTRUWR			:UNIT WRITE RESPONSE
	WC	ILLFNC			:TAPE CONTROL REQUEST
	WC	DTRTCR			:TAPE CONTROL RESPONSE
DTRTBE	WS	0
MAXFNC	EQ	(DTRTBE-DTRTAB)/4

:	ILLEGAL FUNCION CODE IN APDU. THE JCOM SLOT HAS NOT FOLLOWED
:	THE PROTOCOL AND MUST BE CRASHED.

ILLFNC
	DTSPER(R6,E.ILFN)		:ILLEGAL FUNCTION COUNT
	J	DTREND
DTRUAC
	CLHI	R14,UADATA		:CHECK APDU LENGTH
	JC	UALNOK			:SKIP IF LENGTH OK
	DTSPER(R14,E.ILLN)		:INVALID APDU
	J	DTREND			:TRANSPORT WILL BREAK
UALNOK	LIS	R6,UACFNC		:R6=FUNC, R4->APDU, R12=OFFSET
	JAL	R11,DPBFAP		:GET DPB FROM APDU
					:RETURNS R3->DPB, R9->GU
	LR	R3,R3			:WAS THERE A DPB ?
	JNFS	DTUAC1			:SKIP IF THERE WAS
	:DIAGNOSTICS
	J	DTREND			:FINISH UP
DTUAC1
:	VALIDATE SOME FIELDS
	LIS	R6,UARQOT		:UNIT ATTACH REQUEST IS
	RBT	R6,GU.FLG,R9		:NO LONGER OUTSTANDING
	LIS	R6,ATTSER		:UNIT IS NOW ATTACHED
	SBT	R6,GU.FLG,R9		:TO SERVER
	LR	R2,R1			:SAVE USER BLOCK ADDR
	JAL	R11,RETDPB		:RETURN THE DPB
	LR	R1,R2			:RETORE USER BLOCK ADDR
	LIS	R3,0
	L	R2,GU.WTQ,R9		:WAITING Q
	ST	R3,GU.WTQ,R9		:CLEAR IT OUT
DTUAC2
	LR	R3,R2			:ANYTHING LEFT ON Q
	JE	DTREND			:SKIP TO FINISH IF NOT
	L	R2,DP.DTQ,R3		:GET LINK TO NEXT DPB
	JAL	R11,PDPBOQ		:PUT DPB ON O/P Q
	JAL	R11,TVTSDU		:TELL TRANSPORT ABOUT TSDU
	JBS	DTUAC2

DTRUDC
	CLHI	R14,UDDATA		:CHECK APDU LENGTH
	JC	UDLNOK			:SKIP IF LENGTH OK
	DTSPER(R14,E.ILLN)		:INVALID APDU
	J	DTREND			:TRANSPORT WILL BREAK
UDLNOK	LIS	R6,UDCFNC		:UNIT DISCINNECT CONFIRM
	JAL	R11,DPBFAP		:GET THE DPB
	LR	R3,R3			:WAS THER ONE ?
	JNFS	DTUDC1			:SKIP IF THERE WAS
:	DIAGNOSTICS
	J	DTREND			:FINISH UP
DTUDC1
	LIS	R6,UARQOT		:UNIT ATTACH REQUEST OUTSTANDING
	RBT	R6,GU.FLG,R9		:NOT ANY MORE
	LIS	R6,ATTSER		:AND NOT
	RBT	R6,GU.FLG,R9		:ATTACHED TO SERVER
	LR	R2,R1			:SAVE USER BLOCK ADDR
	JAL	R11,RETDPB		:RETURN THE DPB
	LR	R1,R2			:RESTORE USER BLOCK ADDR

	L	R2,GU.WTQ,R9		:CLEAR DOWN THE WAITING Q
DTUDC2
	LR	R3,R2			:ANYTHING LEFT ON Q ?
	JE	DTREND			:SKIP TO FINISH IF NOT
	L	R2,DP.DTQ,R3		:LINK TO NEXT DPB
	LIS	R6,CANCEL
	TBT	R6,DP.FLG,R3		:WAS DPB CANCELLED ?
	JEFS	DTUDC3			:SKIP IF NOT
	JAL	R11,RETDPB		:JUST RETURN DPB
	JBS	DTUDC2
DTUDC3
	JAL	R11,DTSDUN		:RETURN DEVICE UNAVAILABLE TO SVC
	J	DTUDC2

DTRURR
	CLHI	R14,URDATA		:CHECK APDU LENGTH
	JC	URLNOK			:SKIP IF LENGTH OK
	DTSPER(R14,E.ILLN)		:INVALID APDU
	J	DTREND			:TRANSPORT WILL BREAK
URLNOK	LIS	R6,URRFNC		:UNIT READ REQUEST
	JAL	R11,DPBFAP		:GET THE DPB FOR THIS REQUEST
	LR	R3,R3
	JNFS	DTURR1			:SKIP IF FOUND
:	DIAGNOSTICS
	J	DTREND			:FINISH UP
DTURR1
	DTSBYT(URSTAT,2)		:GET STATUS
	STH	R14,GU.STA,R9
	LIS	R6,CANCEL
	TBT	R6,DP.FLG,R3		:WAS THE DPB CANCELLED ?
	JE	DTURR2			:SKIP IF NOT

	:THE SLOT CRASHED BEFORE THIS REPLY RETURNED, SO WE HAVE TO SET
	:UP THE CONTROLS TO CLEAR THIS TPDU FROM THE RING

	DTSBYT(URRECL,4)		:GET RECL
	LR	R6,R14
	L	R5,DP.DA2,R3		:AND SLOT BUFFER ADDR
	JAL	R11,JDMARQ		:SET UP THE DMA CONTROLS
	DMACNL				:BUT CANCEL THE DATA TRANSFER TO SLOT
	L	R14,RBCTPD		:CHECK WHETHER DATA WAS RETURNED WITH
					:THIS READ RESPONSE
	JN	DTREND			:AND LET DTS DMA COMPLETE FINISH UP
	J	DTURR3			:OTHERWISE COMPLETE THE REQUEST NOW
DTURR2
	DTSBYT(URRCDE,2)		:GET RCODE
	LR	R8,R14
	JAL	R11,XLATRS		:UPDATE SVC RESPONSE
	DTSBYT(URRECL,4)		:GET RECL
	LR	R6,R14
	L	R5,DP.DA2,R3		:GET SLOT DMA ADDR
	JAL	R11,JDMARQ		:AND SET UP DMA CONTROLS
					:R12=OFFSET, R9->GU
					:R6=BYTES TO READ,R5=BUFFER ADDR
	L	R14,RBCTPD		:SKIP IF NO DATA RETURNED
	JN	DTREND			:DTS DMA COMPLETE WILL FINISH UP
DTURR3
	JAL	R11,DTSRCM		:COMPLETE THE REQUEST
	J	DTREND			:FINISH UP


DTRUWR
	CLHI	R14,UWDATA		:CHECK APDU LENGTH
	JC	UWLNOK			:SKIP IF LENGTH OK
	DTSPER(R14,E.ILLN)		:INVALID APDU
	J	DTREND			:TRANSPORT WILL BREAK
UWLNOK	LIS	R6,UWRFNC		:UNIT WRITE RESPONSE
DTTCR1
	JAL	R11,DPBFAP		:GET THE DPB FOR THIS REQUEST
	LR	R3,R3
	JNFS	DTUWR1			:SKIP IF FOUND
:	DIAGNOSTICS
	J	DTREND			:FINISH UP
DTUWR1
	DTSBYT(UWSTAT,2)		:GET STATUS
	STH	R14,GU.STA,R9
	LIS	R6,CANCEL
	TBT	R6,DP.FLG,R3		:WAS THE DPB CANCELLED ?
	JEFS	DTUWR2			:SKIP IF NOT
	JAL	R11,RETDPB		:JUST RETURN THE DPB
	J	DTREND			:AND FINISH UP
DTUWR2
	DTSBYT(UWRCDE,2)		:GET RCODE
	LR	R8,R14
	JAL	R11,XLATRS		:UPDATE SVC RESPONSE
	JAL	R11,DTSRCM		:COMPLETE THE REQUEST
	J	DTREND			:AND FINISH UP

DTRTCR
	CLHI	R14,TCDATA		:CHECK APDU LENGTH
	JC	TCLNOK			:SKIP IF LENGTH OK
	DTSPER(R14,E.ILLN)		:INVALID APDU
	J	DTREND			:TRANSPORT WILL BREAK
TCLNOK	LIS	R6,TCRFNC		:TAPE CONTROL RESPONSE
	J	DTTCR1			:SAME AS UNIT WRITE RESPONSE

DTREND
	JR	R10			:RETURN TO CALLER

:	GET THE DPB CORRESPONDING TO THE APDU
:	ON ENTRY 	R4 -> APDU
:			R6 =  REQUEST
:			R12 = OFFSET
:	ON EXIT		R3 -> DPB	(ZERO IF NOT FOUND)
:			R9 -> GU

DPBFAP
	LB	R14,UNIT,R4,R12		:GLOBAL UNIT NUMBER
	CLHI	R14,NGLU		:RANGE CHECK GU
	JG	DFAPE1			:SKIP IF OUT OF RANGE
	LHI	R15,GULEN		:GU ENTRY LENGTH
	LA	R13,GUT			:POINT TO GU TABLE
	MHR	R15,R14			:GET OFFSET TO GU
	AR	R15,R13			:GET ADDR OF GU
	L	R3,GU.OTQ,R15		:GET FIRST DPB ON GU O/P Q
	JE	DFAPE1			:ERROR SKIP IF NOTHING ON Q
	LB	R14,KEY,R4,R12		:GET APDU KEY (SHOULD MATCH DPB)
	CLHI	R14,NDPB		:RANGE CHECK DPB
	JG	DFAPE2			:ERROR SKIP
	CLH	R14,DP.IDX,R3		:DOES KEY MATCH ?
	JN	DFAPE2			:ERROR SKIP
	LB	R14,FUNCT,R4,R12	:GET APDU FUNCTION
	SIS	R14,1			:GET EXPECTED REQUEST
	CLB	R14,DP.RQS,R3		:MATCH ?
	JEFS	DPFAP1			:SKIP IF OK
	CLHI	R14,UDRFNC		:UNIT DETACH REQUEST
					:UNIT DETACH CONFIRM-1, UDC MAY BE
					:THE RESPONSE TO UAR
	JN	DFAPE2			:IF NOT ,THEN ERROR
	SIS	R14,2			:CHECK FOR UNIT ATTACH REQUEST
	CLB	R14,DP.RQS,R3		:MATCH ?
	JN	DFAPE2			:SKIP IF NOT
DPFAP1
	L	R9,DP.GLU,R3		:GET GLOBAL UNIT ADDR
	JR	R11			:RETURN TO CALLER
DFAPE1
	DTSPER(R3,E.DFA1)		:GU FAULT
	JFS	DFAPEX
DFAPE2
	DTSPER(R3,E.DFA2)		:DPB FAULT
DFAPEX
	LIS	R3,0			:FLAG APDU UNKNOWN
	JR	R11			:RETURN TO CALLER

:	TRANSLATE DTE RCODE TO SVC ERROR CODE
:	ON ENTRY	R9 -> GU
:			R8 = DTS RCODE
:			R3 -> DPB

:	TAPE STATUS TRANSLATION TABLE
	HS	0
RSTAPE		:RCODE,TAPE STATUS BITS
	HC	00,00
	HC	02,ERR+EOF
	HC	04,00
	HC	10,DU
	HC	11,DU
	HC	14,DU
	HC	15,DU
	HC	16,ERR+TE
	HC	17,ILL+WP
RSTBTE	EQ	.
RSTBLN	EQ	RSTBTE-RSTAPE


:	TAPE STATUS TO SVC RESPONSE TRANSLATION JUMP TABLE

XLATJT	WC	XLATRD			:0 - READ
	WC	XLATWR			:1 - WRITE
	WC	XLATAT			:2 - ATTACH
	WC	XLATDT			:3 - DETACH
	WC	XLATBS			:4 - BACKSPACE
	WC	XLATSF			:5 - SKIP FORWARD FILE
	WC	XLATSB			:6 - SKIP BACKWARD FILE
	WC	XLATFM			:7 - WRITE FILE MARK
	WC	XLATRW			:8 - REWIND
	WC	XLATUL			:9 - UNLOAD
	WC	XLATGS			:0A - GET STATUS
	WC	XLATEG			:0B - ERASE GAP
	WC	XLATLD			:0C - SET LOW DENSITY
	WC	XLATIL			:0D - ILLEGAL
	WC	XLATIL			:0E - ILLEGAL
	WC	XLATIL			:0F - ILLEGAL

XLATRS
	LB	R15,GU.DEV,R9		:GET DEVICE TYPE
	CLHI	R15,1			:TAPE ?
	JE	XLATT			:SLIP IF TAPE
	LR	R8,R8
	JNFS	XLATR0			:SKIP IF ERROR RETURNED
	LIS	R14,0			:STATUS 0
	J	XLATE
XLATR0
	CLHI	R8,4			:RCODE=4
	JNFS	XLATR1
	LIS	R8,NO.ERR		:RESPONSE=OK
	LIS	R14,0			:STATUS=0
	J	XLATE
XLATR1
	CLHI	R8,11			:RCODE=11
	JNFS	XLATR2
	LHI	R8,ERR.18		:DEVICE UNAVAILABLE
	LIS	R14,NRD			:STATUS - NOT READY
	J	XLATE
XLATR2
	CLHI	R8,15			:RCODE=15
	JNFS	XLATR3
	LIS	R8,ERR.04		:OUT OF RANGE
	LIS	R14,0			:STATUS 0
	J	XLATE
XLATR3
	CLHI	R8,17			:RCODE=17
	JNFS	XLATR4
	LHI	R8,ERR.19		:READ ONLY DEVICE
	LHI	R14,RDO			:STATUS - READ ONLY
	J	XLATE
XLATR4					:RCODE = ANYTHING ELSE
	L	R15,DP.SVC,R3		:GET SVC ADDR
	STB	R8,SVC.VA,R15		:SYSTEM ERROR CODE
	LIS	R8,ERR.08		:CONTROLLER ERROR
	LHI	R14,FAU			:STATUS - FAULT
XLATE
	STB	R8,DP.RS,R3		:UPDATE RESPONSE AND ...
	STH	R14,DP.STA,R3		:STATUS RETURNS
	JR	R11


XLATT
	LA	R15,RSTAPE		:GET CONVERSION TABLE ADDR
	LHI	R14,RSTBLN		:AND TABLE LENGTH
XLAT2
	CLH	R8,-4,R15,R14		:FIND THE ERROR CODE
	JEFS	XLAT3			:SKIP IF FOUND
	SIS	R14,4
	JNBS	XLAT2			:OTHERWISE CHECK NEXT ENTRY
	LHI	R14,DU			:IF NOT FOUND,DEVICE UNAVAILABLE
	JFS	XLAT4
XLAT3
	LHL	R14,-2,R15,R14		:PICK UP TAPE STATUS BITS
XLAT4
	LHL	R8,GU.STA,R9		:PICK UP STATUS RETURNED FROM SERVER
	THI	R8,DTS.X		:CHECK OFFLINE
	JEFS	XLAT5
	OHI	R14,DU
XLAT5
	THI	R8,DTS.R		:READ ONLY
	JEFS	XLAT6
	OHI	R14,WP
XLAT6
	THI	R8,DTS.L		:LOAD POINT
	JEFS	XLAT7
	OHI	R14,ET+BOT
XLAT7
	THI	R8,DTS.B		:BEGINNING OR END OF TAPE
	JEFS	XLAT8
	OHI	R14,ET
XLAT8
	THI	R8,DTS.HI		:HIGH DENSITY
	JEFS	XLAT9
	OHI	R14,HI
XLAT9
	STH	R14,DP.STA,R3		:DTS REQUEST COMPLETER
					:WILL UPDATE SVC.ST AND SVC.RS

	L	R15,DP.SVC,R3		:GET SVC ADDR
	LB	R15,SVC.RS,R15		:GET REQUEST
	NHI	R15,0F			:STRIP OFF UNWANTED BITS
	SLLS	R15,2			:MAKE FULLWORD INDEX
	LA	R13,XLATJT		:JUMP TABLE ADDR
	L	R13,0,R13,R15		:GET JUMP ADDR
	JR	R13			:AND GO TO IT

:	ATTACH,DETACH,ILLEGAL - SHOULD NEVER HAPPEN
XLATAT
XLATDT
XLATIL
	JR	R11			:JUST EXIT

:	WRITE
XLATWR
	THI	R14,WP
	JN	XRR.19			:WRITE PROTECTED

:	READ
XLATRD
	THI	R14,DU
	JN	XRR.18			:DEVICE UNAVAILABLE
	THI	R14,ERR+ET+EOF
	JE	XRR.00			:COMPLETE OK
	THI	R14,EOF
	JN	XRR.16			:END OF FILE
	THI	R14,ET
	JN	XRR.17			:END OF TAPE
	J	XRR.08			:CONTROLLER ERROR

:	BACKSPACE
XLATBS
	THI	R14,BOT
	JN	XRR.17			:BEGINNING OF TAPE
	JFS	XLEG1

:	ERASE GAP
XLATEG
	THI	R14,WP
	JN	XRR.19			:WRITE PROTECTED
XLEG1
	THI	R14,ERR+ET+EOF
	JE	XRR.00			:COMPLETE OK
	THI	R14,EOF
	JN	XRR.16			:END OF FILE
	THI	R14,ET
	JN	XRR.17			:END OF TAPE
	J	XRR.07			:UNIT ERROR

:	WRITE FILE MARK
XLATFM
	THI	R14,WP
	JN	XRR.19			:WRITE PROTECTED
	JFS	XLATSF

:	SKIP BACKWARD FILE
XLATSB
	THI	R14,BOT
	JN	XRR.17			:BEGINNING OF TAPE

:	SKIP FORWARD FILE
XLATSF
	THI	R14,ERR+ET+EOF
	JE	XRR.07			:UNIT ERROR
	THI	R14,EOF
	JN	XRR.00			:SHOULD BE END OF FILE
	THI	R14,ET
	JN	XRR.17			:END OF TAPE
	J	XRR.07			:UNIT ERROR

:	REWIND
XLATRW
	THI	R14,DU
	JN	XRR.18			:DEVICE UNAVAILABLE
	THI	R14,BOT
	JN	XRR.00			:OK IF BEGINNING OF TAPE
	J	XRR.07			:OTHERWISE UNIT ERROR

:	UNLOAD
XLATUL
	THI	R14,DU
	JN	XRR.00			:OK IF DEVICE UNAVAILABLE
	J	XRR.07			:OTHERWISE UNIT ERROR

:	GET STATUS
XLATGS
	THI	R14,DU
	JN	XRR.18			:DEVICE UNAVAILABLE
	J	XRR.00			:OTHERWISE OK

:	SET LOW DENSITY
XLATLD
	J	XRR.00			:ALWAYS OK


XRR.00
	LIS	R15,NO.ERR
	J	XRR.EX
XRR.07
	LIS	R15,ERR.07
	J	XRR.EX
XRR.08
	LIS	R15,ERR.08
	J	XRR.EX
XRR.16
	LHI	R15,ERR.16
	JFS	XRR.EX
XRR.17
	LHI	R15,ERR.17
	JFS	XRR.EX
XRR.18
	LHI	R15,ERR.18
	JFS	XRR.EX
XRR.19
	LHI	R15,ERR.19

XRR.EX
	STB	R15,DP.RS,R3		:SET UP SVC RESPONSE
	
	JR	R11			:RETURN TO CALLER


	SUBTTL	DTS APDU OUTPUT COMPLETE (DTSOPC)
:****************************************************************
:*								*
:*	ROUTINE	 - DTSOPC					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R	->	DPB					*
:*								*
:*	LINK REGISTER	- R10					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.13		*
:*								*
:*	THE JCOM MODULE CALLS THIS ROUTINE WHEN JCOM FINISHES	*
:*	COPYING THE APDU INTO ITS OUTPUT RING, OR WHEN JCOM	*
:*	ABANDONS COPYING THE APDU BECAUSE THE MBASE SLOT	*
:*	CRASHED.						*
:*								*
:****************************************************************

OPCSAV	WS	1			:LINK SAVE
DTSOPC
	ST	R11,OPCSAV		:SAVE LINK
	LIS	R15,OUTCMP		:DPB OUTPUT COMPLETE FLAG
	LHL	R14,TRACON		:IS THER A TRANSPORT CONNECTION
	JEFS	DTOPC1			:SKIP IF NOT
	SBT	R15,DP.FLG,R3		:FLAG OUTPUT COMPLETE
	JFS	DTOPCE			:RETURN TO CALLER
DTOPC1
	JAL	R11,DTSDUN		:RETURN 'DEVICE UNAVAILABLE'
DTOPCE
	L	R11,OPCSAV		:RESTORE LINK
	JR	R11			:AND RETURN TO CALLER


	SUBTTL	DTS DMA COMPLETE (DTSDAC)
:****************************************************************
:*								*
:*	ROUTINE - DTSDAC					*
:*	-------							*
:*								*
:*	LINK REGISTER	- R10					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.14		*
:*								*
:*	JCOM CALLS THIS ROUTINE WHEN A READ-RESPONSE DATA	*
:*	FIELD HAS BENN COMPLETELY COPIED INTO THE REQUESTING	*
:*	SLOT'S BUFFER, OR WHEN JCOM ABORTS THE DMA TRANSFER.	*
:*	IF THE TRANSFER WAS FOR A TAPE THEN THE SVC LENGTH	*
:*	FIELD IS UPDATED. THE REQUEST IS THEN COMPLETED WITH	*
:*	A CALL TO THE REQUEST COMPLETER.			*
:*								*
:****************************************************************

DTSDAC
	L	R9,GLUDMA		:GET THE GLOBAL UNIT ADDR
	L	R3,GU.OTQ,R9		:GET THE DPB
	LIS	R13,CANCEL
	TBT	R13,DP.FLG,R3		:WAS THE DPB CANCELLED
	JEFS	DTDAC1			:SKIP IF NOT
	JAL	R11,RETDPB		:JUST RETURN THE DPB
	JR	R10			:AND EXIT
DTDAC1
	LB	R15,GU.DEV,R9		:GET DEVICE TYPE
	SIS	R15,1			:DISC OR TAPE
	JNFS	DTDAC2			:SKIP IF DISC
	L	R15,IBCDMA		:INITIAL BYTE COUNT
	S	R15,RBCDMA		:=DATA DMA'D TO SLOT
	L	R14,DP.SVC,R3		:GET SVC ADDR
	ST	R15,SVC.CT,R14		:UPDATE SVC COUNT
DTDAC2
	JAL	R11,DTSRCM		:COMPLETE REQUEST
	JR	R10			:RETURN TO CALLER


	SUBTTL	DTS DEVICE UNAVAILABLE (DTSDUN)

:****************************************************************
:*								*
:*	ROUTINE - DTSDUN					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R3	->	DPB					*
:*								*
:*	LINK REGISTER	-  R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.15		*
:*								*
:*	THIS ROUTINE HANDLES DISPOSING OF A DPB WHOSE REQUEST	*
:*	COULD NOT BE CARRIED OUT BECAUSE THE DEVICE WAS		*
:*	UNAVAILABLE.						*
:*								*
:****************************************************************

DUNSAV	WS	1			:LINK SAVE
DTSDUN
	ST	R11,DUNSAV
	LIS	R15,CANCEL
	TBT	R15,DP.FLG,R3		:WAS DPB CANCELLED ?
	JN	DTDUN2			:SKIP IF IT WAS
	LHI	R14,ERR.18		:'DEVICE UNAVAILABLE'
	STB	R14,DP.RS,R3		:UPDATE SVC RESPONSE
	LIS	R14,0
	STH	R14,DP.STA,R3		:UPDATE SVC STATUS
	L	R14,DP.UBK,R3		:GET USER BLOCK ADDR
	JNFS	DTDUN1			:SKIP IF DPB CAME FROM SLOT
:	TRANSPORT HAS GONE DOWN DURING A UNIT ATTACH, JUST RETURN DPB
	JAL	R11,RETDPB
	J	DTDNEX
DTDUN1
	LHL	R15,DTSIOU,R14		:CRASH SLOT ?
	JE	DTDUN2			:SKIP IF NOT
	LIS	R15,0
	STH	R15,DREQ,R14		:ABORT DISC REQUESTS
	STH	R15,QUANTUM,R14		:THIS SLOT WILL RUN NO MORE
	LIS	R15,CANCEL		:THIS SLOT IS GOING TO CRASH, SO ..
	STB	R15,DP.FLG,R3		:DON'T PROCESS THE DPB FURTHER
	LHL	R15,WFLAG,R14		:THIS SLOT WILL WAIT WITH THE ...
	OHI	R15,KDISC		:CRASH FLAG SET
	STH	R15,WFLAG,R14
	TS	DTSDIE			:TELL SOMEONE TO CRASH THE SLOT
	JAL	R11,RETDPB		:RETURN DPB
	JFS	DTDNEX
DTDUN2
	JAL	R11,DTSRCM		:REQUEST COMPLETE
DTDNEX
	L	R11,DUNSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


	SUBTTL	DTS REQUEST COMPLETER (DTSRCM)

:****************************************************************
:*								*
:*	ROUTINE	- DTSRCM					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R3	->	DPB					*
:*								*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.16		*
:*								*
:*	THIS ROUTINE NOTIFIES A SLOT OF THE OUTCOME OF AN	*
:*	SVC REQUEST. IF THE REQUESTING SLOT HAS CRASHED IN THE	*
:*	MEANTIME THEN THE DPB IS DISCARDED, OTHERWISE THE SVC	*
:*	RESPONSE AND STATUS FIELDS ARE UPDATED FROM THE DPB.	*
:*								*
:****************************************************************

RCMSAV	WS	1			:SAVE AREA
DTSRCM
	ST	R11,RCMSAV		:SAVE LINK
	LHI	R15,CANCEL
	TBT	R15,DP.FLG,R3		:WAS DPB CANCELLED ?
	JNFS	DTRCM1			:SKIP IF IT WAS
	L	R15,DP.SVC,R3		:GET SVC PARAM ADDR
	LHL	R14,DP.STA,R3		:GET STATUS RESPONSE
	STH	R14,SVC.ST,R15		:AND UPDATE SVC PARAMETER BLOCK
	LB	R14,DP.RS,R3		:GET SVC RESPONSE
	STB	R14,SVC.RS,R15		:AND UPDATE SVC PARAMETER BLOCK
DTRCM1
	JAL	R11,RETDPB		:RETURN DPB
	L	R11,RCMSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


	SUBTTL	DTS DPB MANAGEMENT

:****************************************************************
:*								*
:*	ROUTINE - GETDPB					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R1	->	USER BLOCK				*
:*								*
:*	OUTPUT INTERFACE					*
:*	----------------					*
:*								*
:*	R3	-	DPB					*
:*								*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.17		*
:*								*
:*	GET A DPB FROM THE AVAILABLE LIST. IF THERE IS NO DPB	*
:*	AVAILABLE THEN SUSPEND THE SLOT, UNLESS THE REQUEST	*
:*	CAME FROM UNIT ATTACH, IN WHICH CASE THE COUNT OF	*
:*	ATTACHES NEEDED IS INCREMENTED.				*
:****************************************************************

GDPBSV	WS	1			:SAVE AREA
GETDPB
	ST	R11,GDPBSV		:SAVE LINK
	L	R3,AVAIL		:GET DPB
	JE	GETDP2			:SKIP IF NONE THERE
	L	R15,DP.DTQ,R3		:SET UP Q HEAD
	ST	R15,AVAIL
	ST	R1,DP.UBK,R3		:SAVE USER BLOCK ADDR
GETDP1
	ST	R3,BPA			:SAVE THE DPB'S ADDR
	L	R11,GDPBSV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER
GETDP2
	LR	R1,R1			:DID THE REQUEST COME FROM A SLOT ?
	JEBS	GETDP1			:EXIT IF NOT
GETDP3
	L	R12,ESWQ,R1		:USER BLOCK BUFFER WAIT Q ELEMENT
	JNFS	GETDP4			:SKIP IF ALREADY ON IT
	L	R12,EWQ			:END POINTER OF WAIT Q
	LA	R13,ESWQ,R1
	ST	R13,0,R12		:PUT SLOT ON END OF Q
	ST	R13,EWQ			:FIX UP END POINTER
GETDP4
	LHI	R13,FDSK2		:DISMISS USER IN BUFFER WAIT
	OH	R13,WFLAG,R1		:UNTIL DPB FREED
	STH	R13,WFLAG,R1
	J	REPOP,,			:SET UP SVC TO EXECUTE AGAIN
					:... AND DISMISS USER

:****************************************************************
:*								*
:*	ROUTINE  -  RETDPB					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R3	->	DPB					*
:*								*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 5.17		*
:*								*
:*	RETURN A DPB TO THE AVAILABLE LIST. IF A UNIT IS WAITING*
:*	ON A DPB FOR AN ATTACH REQUEST CALL THE ROUTINE TO 	*
:*	ATTACH THE UNIT. IF A SLOT IS WAITING FOR A DPB, CLEAR	*
:*	ITS WAIT FLAG SO THE SLOTS SVC WILL EXECUTE AGAIN. IF 	*
:*	THE OWNER OF THE DPB WAS I/O DISMISSED, WAKE THE SLOT 	*
:*	UP IF THIS IS THE LAST REMAINING I/O FOR THE SLOT (SVC'S*
:*	CAN BE OVERLAPPED).					*
:****************************************************************

RDPBSV	WS	1			:SAVE AREA
RDPBCL	HS	1
RETDPB
	ST	R11,RDPBSV		:SAVE LINK
	L	R15,DP.GLU,R3		:IS DPB ATTACHED TO A GU
	JE	RTDPBE			:SKIP IF NOT
	L	R14,GU.OTQ,R15		:SEARCH THE OUSTANDING Q FIRST
	JE	RTDPBB			:SKIP IF EMPTY
	CR	R3,R14			:IS DPB 1ST ON Q ?
	JNFS	RTDPBA			:SKIP IF NOT
	L	R14,DP.DTQ,R3		:GET NEXT DPB ON Q
	ST	R14,GU.OTQ,R15		:FIX UP Q HEAD
	J	RTDPBE
RTDPBA
	LR	R15,R14			:CHASE THE LINKS
	L	R14,DP.DTQ,R15		:NEXT DPB ON Q
	JE	RTDPBD			:SKIP IF Q EMPTY
	CR	R3,R14			:IS THIS THE DPB WE ARE LOOKING FOR ?
	JNBS	RTDPBA			:SKIP IF NOT
	L	R14,DP.DTQ,R14		:FIX UP LINKS
	ST	R14,DP.DTQ,R15
	J	RTDPBE
RTDPBB
:	CHECK IF IT'S ON THE WAIT Q
	L	R14,GU.WTQ,R15		:GET 1ST DPB ON Q
	JE	RTDPBD			:SKIP IF NONE ON Q
	CR	R3,R14			:IS IT 1ST DPB ON Q
	JNFS	RTDPBC			:SKIP IF NOT
	L	R14,DP.DTQ,R3		:GET NEXT DPB ON Q
	ST	R14,GU.WTQ,R15		:FIX UP Q HEAD
	J	RTDPBE
RTDPBC
	LR	R15,R14			:CHASE THE LINKS
	L	R14,DP.DTQ,R15		:NEXT DPB ON Q
	JEFS	RTDPBD			:SKIP IF NOT ON Q
	CR	R3,R14			:IS THIS THE DPB WE ARE LOOKING FOR ?
	JNBS	RTDPBC			:SKIP IF NOT
	L	R14,DP.DTQ,R14		:FIX UP LINKS
	ST	R14,DP.DTQ,R15
	JFS	RTDPBE
RTDPBD
:	BIG TROUBLE - DPB NOT FOUND ON EITHER Q

:	DTSPER(R14,E.DNGU)		:DPB NOT ON GU
	S.HLTF(0667)
RTDPBE
	LHI	R14,CANCEL
	STH	R14,RDPBCL		:ASSUME DPB CANCELLED
	TBT	R14,DP.FLG,R3		:WAS THE DPB CANCELLED ?
	JNFS	RTDPB1			:SKIP IF IT WAS
	LIS	R14,0			:REMEMBER DPB NOT CANCELLED
	STH	R14,RDPBCL
RTDPB1
	L	R14,DP.UBK,R3		:GET USER BLOCK ADDR
	L	R15,AVAIL		:PUT DPB ON AVAILABLE LIST
	ST	R15,DP.DTQ,R3
	ST	R3,AVAIL
	LHL	R15,ATNEED		:ATTACHES NEEDED ?
	JEFS	RTDPB2			:SKIP IF NOT
	JAL	R11,DTSAWU		:ATTACH WAITING UNITS
	J	RTDPB4			:AND SEE IF USER WAS DISMISSED

:	EXAMINE DPB WAIT Q
RTDPB2
	L	R12,SWQ			:GET FIRST USER ON WAIT Q
	JE	RTDPB4			:SKIP IF NONE WAITING
	SHI	R12,ESWQ		:ADDR OF START OF USER BLOCK
	L	R13,ESWQ,R12
	ST	R13,SWQ
	JNFS	RTDPB3
	LA	R13,SWQ			:EMPTY Q, EWQ-> SWQ
	ST	R13,EWQ
RTDPB3
	LIS	R13,0			:RETURN NODE TO USERS'S AVAILABLE LIST
	ST	R13,ESWQ,R12
	LHI	R13,@FDSK2		:TURN OFF DPB SLEEP BIT
	NH	R13,WFLAG,R12
	STH	R13,WFLAG,R12
:	WAKE USER WHO IS DISMISSED FOR DISC WORK
RTDPB4
	LR	R14,R14			:WAS DPB RETURNED BY A USER ?
	JE	RTDPB6			:SKIP IF NOT
	LHL	R15,RDPBCL		:WAS THE DPB CANCELLED ?
	JNFS	RTDPB6			:SKIP IF IT WAS
	LHL	R13,DREQ,R14		:DISC REQUESTS OUTSTANDING
	JEFS	RTDPB5			:SKIP IF NONE
	SIS	R13,1
	STH	R13,DREQ,R14		:DEC COUNT OF OUTSTANDING I/O
	JNFS	RTDPB6			:DON'T WAKE USER UNTIL DREQ=0
RTDPB5
	LHL	R13,WFLAG,R14
	NHI	R13,@FDSK1		:TURN OFF DISC SLEEP BIT
	STH	R13,WFLAG,R14		:LET THE USER RUN
RTDPB6
	L	R11,RDPBSV		:RETORE LINK
	JR	R11			:RETURN TO CALLER

	

	SUBTTL	DTS GENERAL PURPOSE ROUTINES

	SUBTTL	TRANSPORT INITIALIZATION (ITSITR) - CALLED BY ITSIDT

:****************************************************************
:*								*
:*	ROUTINE	- ITSITR					*
:*	-------							*
:*								*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 4.2
:*								*
:*	SET SRCREF TO ZERO AND TRANSPORT STATE TO S01		*
:****************************************************************

ITSITR
	LIS	R15,S01			:SET TRANSPORT STATE TO S01
	STH	R15,TRSTAT
	LIS	R15,0
	STH	R15,SRCREF
	JR	R11			:RETURN TO CALLER

	SUBTTL	TRANSPORT EVENT HANDLER (TEVENT)

:****************************************************************
:*								*
:*	ROUTINE	 - TEVENT AND TVTSDU				*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R6	-	EVENT					*
:*	R5	-	LENGTH					*
:*	R3	->	BUFFER OR DPB				*
:*								*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 4.2		*
:*								*
:*	THIS IS THE TRANSPORT EVENT HANDLER. SEE STATE TABLES	*
:*	IN GED. FOR TSDU FROM DTS R3 IS THE DPB ADDRESS. FOR	*
:*	DA TPDU'S FROM THE NETWORK, BUFFER AND LENGTH SPECIFY	*
:*	WHERE THE TPDU CAN BE FOUND AND HOW MUCH IS AVAILALBLE	*
:*	FOR INSPECTION. NETWORK ALWAYS ENSURES THAT AT LEAST	*
:*	THE LONGEST TPDU HEADER (MXHDRM) IS AVAILABLE. AS A	*
:*	CONSEQUENCE, THERE MAY BE DATA BYTES OF AN DA TPDU IN	*
:*	THE BUFFER.						*
:*	TWO TRANSPORT ROUTINES ARE USED :			*
:*	TVTSDU - TSDU'S FROM DTS				*
:*	TEVENT - NPDU'S AND TPDU'S				*
:****************************************************************


TVSSAV	WS	5			:SAVE AREA
TVTSDU
	STM	R11,TVSSAV		:SAVE LINK
	LHL	R12,TRSTAT		:GET TRANSPORT STATE
	CLHI	R12,S04			:TRANSPORT MUST BE CONNECTED
	JNFS	TVTSD1			:SKIP IF NOT
	JAL	R11,JOQUER		:PASS DPB TO JCOM
	JFS	TVSEND
TVTSD1
	LIS	R13,3			:S01,S02,S03 - TRANSPORT ERROR
	JAL	R11,TERROR
TVSEND
	LM	R11,TVSSAV
	JR	R11			:RETURN TO CALLER



:	TRANSPORT EVENT JUMP TABLE FOR TEVENT

					:EVENT
TSWTCH	WC	TRNOUT			:N-OUT_OF_ORDER
	WC	TRNOPR			:N-OPERATIONAL
	WC	TRNRST			:N-RESET
	WC	TRNRSC			:N-RESYNC
	WC	TRTPDU			:TPDU
TSTCHE	EQ	.
NEVENT	EQ	(TSTCHE-TSWTCH)/4

TEVSAV	WS	1			:SAVE AREA
TEVENT
	ST	R11,TEVSAV		:SAVE LINK
	CLHI	R6,NEVENT		:RANGE CHECK
	JLFS	TVNT01			:SKIP IF OK
	LIS	R13,9			:TRANSPORT ERROR 9
	JAL	R11,TERROR		:REPORT IT
	J	TRVEND
TVNT01
	LHL	R2,TRSTAT		:GET CURRENT TRNASPORT STATE
	SLHLS	R6,2			:MAKE FULLWORD INDEX
	LA	R15,TSWTCH		:INTO JUNP TABLE
	L	R15,0,R15,R6		:GET JUMP ADDR
	JR	R15			:AND GO TO IT

:	TRANSPORT EVENT HANDLERS

:	N-OUT_OF_ORDER
TRNOUT
	LHL	R7,NORDCT		:N-OUT_OF_ORDER COUNT
	AIS	R7,1
	STH	R7,NORDCT
	CLHI	R2,S04
	JNFS	TNOUT1
	JAL	R10,DTSTDS		:S04 - T-DISCONNECT
TNOUT1
	LIS	R2,S01			:MOVE TO S01
	STH	R2,TRSTAT
	J	TRVEND			:FINISH UP

:	N-OPERATIONAL
TRNOPR
	CLHI	R2,S04
	JNFS	TNOPR1
	JAL	R10,DTSTDS		:S04 - T-DISCONNECT
	LIS	R15,0
	JAL	R11,RSYCON		:RESYNC AND CONNECT
	JFS	TNOPR2
TNOPR1
	LIS	R15,0
	JAL	R11,RSYCON		:S01,S02,S03 - RESYNC AND CONNECT
TNOPR2
	LIS	R2,S02			:MOVE TO S02
	STH	R2,TRSTAT
	TS	INTPDU			:OUTSIDE TPDU BOUNDARY
	J	TRVEND

:	N-RESET
TRNRST
	CLHI	R2,S01
	JGFS	TNRST1
	LIS	R13,0			:PROTOCOL ERROR 0
	JAL	R11,TERROR
	JFS	TNRST3
TNRST1
	CLHI	R2,S03
	JGFS	TNRST2
	LIS	R15,0			:S02,S03 - RESYNC AND CONNECT
	JAL	R11,RSYCON
	JFS	TNRST3
TNRST2
	JAL	R10,DTSTDS		:S04 - T-DISCONNECT
	LIS	R15,0
	JAL	R11,RSYCON		:RESYNC AND CONNECT
TNRST3
	LIS	R2,S02			:MOVE TO S02
	STH	R2,TRSTAT
	JAL	R11,JCMSDD		:JCOM START DISCARDING DATA
	TS	INTPDU			:OUTSIDE TPDU BOUNDARY
	J	TRVEND			:FINISH UP

:	N-RESYNC
TRNRSC
	LH	R15,INTPDU		:WITHIN TPDU ?
	JN	TNRSC4			:SKIP IF OUTSIDE TPDU
	TS	INTPDU			:NEW TPDU BOUNDARY
	CLHI	R2,S02
	JGFS	TNRSC1
	LIS	R13,1			:S01,S02 - TRANSPORT ERROR 1
	JAL	R11,TERROR
	J	TRVEND
TNRSC1
	CLHI	R2,S03
	JNFS	TNRSC2
	LHL	R15,SRCREF		:S03 - USE SAME SOURCE REF
	JAL	R11,RSYCON		:FOR RESYNC AND CONNECT
	JFS	TNRSC3
TNRSC2
	JAL	R10,DTSTDS		:S04 -  T-DISCONNECT
	LIS	R15,0
	JAL	R11,RSYCON		:RESYNC AND CONNECT
TNRSC3
	LIS	R2,S03			:MOVE TO S03
	STH	R2,TRSTAT
	J	TRVEND

:	N-RESYNC OUTSIDE A TPDU
TNRSC4
	CLHI	R2,S01
	JGFS	TNRSC5
	LIS	R13,2			:S01 - PROTOCOL ERROR 2
	JAL	R11,TERROR
	J	TRVEND			:FINISH UP
TNRSC5
	CLHI	R2,S02
	JG	TRVEND			:S03,S04 - JUST FINISH UP
	LIS	R2,S03
	STH	R2,TRSTAT		:MOVE TO S03
	J	TRVEND			:FINISH UP

:	WE ARE EXPECTING EITHER A CC TPDU OR A DA TPDU. POSITION R4 AT
:	THE DESREF FIELD OF THE CC TPDU OR AT THE FIRST LI BYTE OF THE
:	APDU. R4 IS SET TO THE LENGTH OF THE APDU.
TRTPDU
	LB	R6,0,R3			:GET FIRST BYTE OF LI
	LIS	R12,2			:START BY ASSUMING 1 BYTE LI
	LB	R7,1,R3			:GET THE TPDU TYPE
	NHI	R6,80			:IF TOP BIT SET THEN 3 BYTE LI
	JEFS	TTPDU1			:SKIP IF 1 BYTE
	LIS	R12,4			:3 BYTE LI
	LB	R7,3,R3			:TPDU TYPE
TTPDU1
	LR	R4,R3
	AR	R4,R12			:R4 -> DESREF OR LI OF APDU
	SR	R5,R12			:R5 = LENGTH OF APDU
	CLHI	R7,DATPDU		:DA TPDU ?
	JNFS	TTPDU2			:SKIP IF NOT
	JAL	R11,HANDDA		:HANDLE DA TPDU
	J	TRVEND			:AND FINISH UP
TTPDU2
	CLHI	R7,CCTPDU		:CC TPDU ?
	JNFS	TTPDU3			:SKIP IF NOT
	JAL	R11,HANDCC		:HANDLE CC TPDU
	J	TRVEND			:AND FINISH UP
TTPDU3
	JAL	R11,HANDIV		:HANDLE INVALID TPDU
	J	TRVEND			:AND FINISH UP


TRVEND
	L	R11,TEVSAV		:RESTORE LINK
	JR	R11


:	HANDLE DATA TPDU
:	R2	=	TRANSPORT STATE
:	R4	->	1ST BYTE LI OF APDU
:	R5	=	APDU LENGTH
:	R11	=	LINK

HDASAV	WS	1			:SAVE AREA
HANDDA
	ST	R11,HDASAV		:SAVE LINK
	CLHI	R2,S03
	JGEFS	HNDDA1
	LIS	R13,4			:S01,S02 - PROTOCOL ERROR 4
	JAL	R11,TERROR
	J	HNDEND
HNDDA1
	JNFS	HNDDA2
	LHL	R15,SRCREF		:S03 - RESYNC AND CONNECT
	JAL	R11,RSYCON		:WITH THE SAME SRCREF
	JFS	HNDEND
HNDDA2
	JAL	R10,DTSARX		:S04 - PASS THE APDU TO DTS
HNDEND
	L	R11,HDASAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


:	HANDLE INVALID TPDU
:	R2	=	TRANSPORT STATE
:	R11	=	LINK

HIVSAV	WS	1			:SAVE AREA
HANDIV
	ST	R11,HIVSAV		:SAVE LINK
	CLHI	R2,S03
	JGEFS	HNDIV1
	LIS	R13,5			:S01,S02 - PROTOCOL ERROR 5
	JAL	R11,TERROR
	J	HIVEND
HNDIV1
	JNFS	HNDIV2
	LHL	R15,SRCREF		:S03 - RESYNC AND CONNECT
	JAL	R11,RSYCON		:WITH SAME SRCREF
	J	HIVEND
HNDIV2
	JAL	R10,DTSTDS		:S04 -  T-DISCONNECT
	LIS	R15,0
	JAL	R11,RSYCON		:WITH NEW SRCREF
HIVEND
	LIS	R2,S02			:MOVE TO S02
	STH	R2,TRSTAT
	JAL	R11,JCMSDD		:NEED TO RE-ALLIGN TPDU'S
	L	R11,HIVSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER

:	HANDLE CC TPDU
:	R4	->	DSTERF

HCCSAV	WS	1			:SAVE AREA
HANDCC
	ST	R11,HCCSAV		:SAVE LINK
	CLHI	R5,CCBODY		:CC LENGTH CORRECT ?
	JNFS	HNCC00			:INVALID IF NOT
	LB	R7,4,R4			:PROTOCOL CORRECT ?
	CLHI	R7,CCPROT
	JEFS	HNCC01			:SKIP IF IT IS
HNCC00
	JAL	R11,HANDIV		:HANDLE INVALID TPDU
	J	HCCEND			:AND EXIT
HNCC01
	LHL	R7,SRCREF		:SRCREF OF LAST CR TPDU
	CLB	R7,1,R4			:CHECK DSTREF = SRCREF
	JNFS	HNDCC1			:SKIP IF MISMATCH
	SRHLS	R7,8
	CLB	R7,0,R4
	JE	HNDCC5			:SKIP IF MATCH, CC TPDU OK
HNDCC1
	CLHI	R2,S03
	JGEFS	HNDCC2
	LIS	R13,6			:S01,S02 - PROTOCOL ERROR 6
	JAL	R11,TERROR
	J	HCCEND
HNDCC2
	JNFS	HNDCC3
	LHL	R15,SRCREF		:S03 - RESYNC AND CONNECT
	JAL	R11,RSYCON		:WITH SAME SRCREF
	JFS	HNDCC4
HNDCC3
	JAL	R10,DTSTDS		:S04 -  T-DISCONNECT
	LIS	R15,0			:RESYNC AND CONNECT
	JAL	R11,RSYCON		:WITH NEW SRCREF
HNDCC4
	LIS	R2,S03			:MOVE TO S03
	STH	R2,TRSTAT
	J	HCCEND
HNDCC5
	CLHI	R2,S03
	JGEFS	HNDCC6
	LIS	R13,7			:S01,S02 - PROTOCOL ERROR 7
	JAL	R11,TERROR
	J	HCCEND
HNDCC6
	JNFS	HCCEND			:ASSUME REDUNDANT IF S04
	LIS	R2,S04			:MOVE TO S04
	STH	R2,TRSTAT
	JAL	R10,DTSTCN		:S03 -  T-CONNECT
HCCEND
	L	R11,HCCSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER

:	RESYNC AND CONNECT
:	R15	=	0 - NEW SRCREF, N- SRFREF(N)
:	R11	=	LINK

:	RESYNC AND CONNECT REQUEST SKELETON
	HS	0
CONREQ	BC	80,85			:RESYNC
	BC	05,CRTPDU		:LI, CR TYPE
	BC	00,00			:SRCREF
	BC	01			:PROTOCOL TYPE
CREQLN	EQ	.-CONREQ


RSCSAV	WS	1			:SAVE AREA
RSYCON
	ST	R11,RSCSAV		:SAVE LINK
	LA	R3,DPBPOL		:DPB(0) RESERVED FOR THIS ROUTINE
	LB	R14,DP.RQS,R3		:CHECK IF DPB IN USE
	JEFS	RSYCN1			:SKIP IF NOT
	JR	R11			:JUST RETURN FOR THE MOMENT
RSYCN1
	LHI	R14,CRINPR		:CR IN PROGRESS
	STB	R14,DP.RQS,R3		:SHOW DPB IN USE
	LIS	R14,0
	STH	R14,DP.FLG,R3		:CLEAR THE FLAGS
	LIS	R14,CNTMSS		:TELL JCOM THAT THIS DPB
	SBT	R14,DP.FLG,R3		:CAME FROM TRANSPORT
	LR	R15,R15			:NEW SRCREF REQUIRED ?
	JNFS	RSYCN2			:SKIP IF NOT
	LHL	R15,SRCREF		:GET A NEW SRCREF NUMBER
	AIS	R15,1
	STH	R15,SRCREF
RSYCN2
	LHI	R14,CREQLN		:RESYNC + CR TPDU LENGTH
	ST	R14,DP.LN1,R3		:SHOW JCOM LENGTH TO SEND
	LA	R14,CONREQ		:PICK UP SKELETON ADDR
	ST	R14,DP.DA1,R3		:SHOW JCOM WHERE IT IS
	STB	R15,5,R14		:PUT IN LSB(SRCREF)
	SRHLS	R15,8
	STB	R15,4,R14		:PUT IN MSB(SRCREF)
	LIS	R15,0
	ST	R15,DP.LN2,R3		:NO MESSAGE PART 2
	JAL	R11,JOQUER		:PASS THE DPB TO JCOM

	L	R11,RSCSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER

:	TRANSPORT ERROR RECORDING
:	R13	=	ERROR ARRAY INDEX

TERROR
	LA	R15,TPROTE		:PROTOCOL ERROR ARRAY
	SBT	R13,0,R15		:SET THE ERROR BIT
	S.HLTF(0666)
	JR	R11			:RETURN TO CALLER


	SUBTTL TRANSPORT MISCELLANEOUS ROUTINES

	SUBTTL	JCOM INITIALIZATION (ITSIJC) - CALLED BY JCOM SVC HANDLER

:****************************************************************
:*								*
:*	ROUTINE   -  ITSIJC					*
:*	-------							*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 3.2		*
:*								*
:*	INITIALIZE THE JCOM STATUS TABLE			*
:****************************************************************

ITSIJC
	LIS	R6,0
	ST	R6,JCDESC		:JCOM DESCRIPTOR
	ST	R6,JORDES		:JCOM OUT RING DESCRIPTOR
	STH	R6,JORGLN		:JCOM OUT RING LENGTH
	ST	R6,JIRDES		:JCOM IN RING DESCRIPTOR
	STH	R6,JIRGLN		:JCOM IN RING LENGTH

	LIS	R6,DSCRDD		:JCOM DISCARDING DATA
	STH	R6,JCSTAT

	JR	R11			:RETURN TO CALLER


	SUBTTL	JCOM CRASH RESPONSE ROUTINE (JCMCRA)

:****************************************************************
:*								*
:*	ROUTINE -  JCMCRA					*
:*	-------							*
:*	INOUT INTERFACE						*
:*	---------------						*
:*	R0	-	PRESERVE				*
:*	R1	-	USER BLOCK				*
:*	R12/13/14 -	SCRATCH					*
:*								*
:*	LINK REGISTER	-  R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 3.3		*
:*								*
:*	IF THE CRASHING SLOT HAS JCOM CONNECTED, DISCONNECT	*
:*	JCOM FROM THE SLOT AND INFORM TRANSPORT OF THE		*
:*	N-OUT_OF_ORDER CONDITION. REMOVE ALL DPB'S FROM THE	*
:*	JCOM O/P Q AND RETURN THEM TO THEIR OWNERS - TRANSPORT	*
:*	OR DTS.							*
:****************************************************************

JCRSAV	WS	$A 14			:SAVE AREA
JCMCRA
	STM	R2,JCRSAV
	LHL	R12,JCSLOT		:DOES THIS SLOT HAVE JCOM ?
	CLH	R12,SLOT,R1
	JN	JCCRA3			:SKIP IF NOT
	TS	JCSLOT			:DISCONNECT JCOM
	LIS	R6,0
	ST	R6,RBCDMA		:CANCEL DMA
	LIS	R6,NORDER		:N-OUT_OF_ORDER
	JAL	R11,TEVENT		:TELL TRANSPORT ABOUT IT
JCCRA1
	L	R3,JCOUTQ		:IS THERE ANYTHING ON O/P Q ?
	JE	JCCRA3			:SKIP IF NOT
	JAL	R11,JQUNLK		:GET THE DPB OFF THE Q
	LIS	R6,CNTMSS		:CHECK IF IT CAME FROM TRANSPORT
	TBT	R6,DP.FLG,R3
	JEFS	JCCRA2			:SKIP IF NOT
	LIS	R6,0
	STB	R6,DP.RQS,R3		:CANCEL THE N-RESYNC CR TPDU
	JBS	JCCRA1
JCCRA2
	JAL	R11,DTSOPC		:TELL DTS ABOUT IT
	J	JCCRA1			:GET NEXT DPB
JCCRA3
	LM	R2,JCRSAV		:RETORE LINK
	JR	R11			:RETURN TO CALLER


	SUBTTL	JCOM SVC HANDLER (JCMSVC)

:****************************************************************
:*								*
:*	ROUTINE	  - JCMSVC					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R1	->	USER BLOCK				*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 3.4		*
:*								*
:*	HANDLE THE JCOM CONNECT/POLL SVC. FOR A CONNECT, VERIFY	*
:*	THAT THE RING DESCRIPTORS ARE VALID AND TELL TRANSPORT	*
:*	THAT JCOM IS AVAILABLE. FOR A POLL, CHECK THAT THE	*
:*	DESCRIPTOR ADDR HAS NOT CHANGED SINCE THE CONNECT AND	*
:*	CALL THE ROUTINES TO PROCESS THE RINGS.			*
:****************************************************************

:	JCOM SVC FORMAT

:	---------------------------------
:	|   J	|   C	|   O	|   M	|
:	 -------------------------------
:	|  VER	| FUNCT	|    STATUS	|
:	 -------------------------------
:	|      PRIMARY INPUT RING	|
:	 -------------------------------
:	|     SECONDARY INPUT RING	|
:	---------------------------------

:	JCOM RING DESCRIPTOR

:	---------------------------------
:	|  R	|   I	|   N	|   G	|
:	 -------------------------------
:	|    LENGTH	|      NFI	|
:	 -------------------------------
:	|      CEI	|    RESERVED	|
:	 -------------------------------
:	| -> RING SPACE
:	-------------------------


	GL	JCMSVC
JCMSVC
	L	R12,F1ARG,,		:VIRTUAL ADDR OF PARAM BLOCK
	LHL	R13,RPSW+2,R1		:FETCH STATUS BITS OF PSW
	JAL	R11,ACCESS,,		:CONVERT TO PHYSICAL ADDR
	J	JSVCE1			:ERRO IF SLOT DOES NOT HAVE ACCESS
	LR	R4,R12			:PHYSICAL ADDR OF PARAM BLOCK
					:STAYS IN R4 THOUGHOUT HANDLER
	LH	R13,JCSLOT		:IS JCOM ALREADT CONNECTED ?
	JL	JSVCAT			:SKIP IF NOT

:	JCOM IS BEING POLLED
	C	R4,JCDESC		:IS THE POLL DESCRIPTOR ADDR THE SAME
					:AS THAT USED IN THE CONNECT ?
	JN	JSVCE4			:SKIP IF DIFFERENT
	LB	R14,JCD.FN,R4		:CHECK IT IS A POLL
	JE	JSVCE5			:SKIP ON ERROR
	JAL	R11,JINRAN		:TAKE A LOOK AT THE IN RING
	LIS	R15,0			:MAYBE WE CAN RESET NFI,CEI
	L	R14,JIRDES		:GET IN RING DESCRIPTOR
	L	R13,JRGNFI,R14		:GET NFI
	CLH	R13,JRGCEI,R14		:SAME AS CEI ?
	JNFS	JCSVC1			:SKIP IF NOT
	ST	R15,JRGNFI,R14		:CLEAR NFI,CEI
JCSVC1
	JAL	R11,JOLODR		:SEE IF ANYTHING TO SEND
	LIS	R15,JCOMOK		:TELL SLOT SVC OK
	ST	R15,RREG,R1		:USER R0
	J	KSKIP,,			:SKIP RETURN TO USER

:	JCOM CONNECT REQUEST

JSVCAT
	LB	R14,JCD.FN,R4		:CHECK CONNECT REQUEST
	JN	JSVCE3			:ERROR IF POLL REQUEST
	JAL	R11,ITSIJC		:INITIALIZE JCOM
	NHI	R12,1			:CHECK FOR EVEN ADDR
	JN	JSVCE1			:JCOM DESC'R INACCESSIBLE
	ST	R4,JCDESC		:SAVE THE REAL ADDR OF DESC'R
:	VERIFY PRIMARY RING PARAMETERS
	L	R12,JCD.OR,R4		:PRIMARY RING (VIRTUAL)
	LHL	R13,RPSW+2,R1		:STATUS BITS OF PSW
	JAL	R11,ACCESS,,		:CONVERT TO PHYSICAL ADDR
	J	JSVCE2			:SKIP IF SLOT DOES NOT HAVE ACCESS
	ST	R12,JORDES		:KEEP VERIFIED COPY
	LHL	R13,JRGBLN,R12		:GET LENGTH OF RING
	STH	R13,JORGLN		:SAVE COPY
	L	R12,JCD.OR,R4		:DESC'R ADDR (VIRTUAL)
	AR	R13,R12			:1 PAST END OF RING
	SIS	R13,1			:BACK UP
	JAL	R11,RRW,,		:CHECK READ/WRITE ACCESS
	J	JSVCE2			:RING DESC'R INACCESSIBLE
	LIS	R13,0
	L	R12,JORDES		:PICK UP DESC'R ADDR (REAL)
	ST	R13,JRGNFI,R12		:CLEAR NFI,CEI

:	VERIFY SECONDARY RING PARAMETERS

	L	R12,JCD.IR,R4		:JCOM SECONDARY RING DESC'R (VIRTUAL)
	LHL	R13,RPSW+2,R1		:STATUS BITS OF PSW
	JAL	R11,ACCESS,,		:CONVERT TO PHYSICAL ADDR
	J	JSVCE2			:SKIP IF SLOT DOES NOT HAVE ACCESS
	ST	R12,JIRDES		:KEEP VERIFIED COPY
	LHL	R13,JRGBLN,R12		:GET RING LENGTH
	STH	R13,JIRGLN		:KEEP A COPY
	L	R12,JCD.IR,R4		:DESC'R ADDR (VIRTUAL)
	AR	R13,R12			:1 PAST END OF RING
	SIS	R13,1			:BACK UP
	JAL	R11,RRW,,		:CHECK READ/WRITE ACCESS
	J	JSVCE2			:DESC'R INACCESSIBLE
	LIS	R13,0
	L	R12,JIRDES		:PICK UP IN RING ADDR
	ST	R13,JRGNFI,R12		:CLEAR NFI,CEI

:	START JCOM UP

	LHL	R13,SLOT,R1		:GET CONNECTING SLOT
	STH	R13,JCSLOT
	LIS	R6,NOPERL		:N-OPERATIONAL
	JAL	R11,TEVENT		:TELL TRANSPORT ABOUT IT
	LIS	R13,JCOMOK		:TELL SLOT JCOM CONNECTED
	ST	R13,RREG,R1		:USER R0
	J	KSKIP,,			:SKIP RETURN TO USER

:	JCOM SVC ERROR

:	JCOM NOT CONNECTED, JCOM DESCRIPTOR INACCESSIBLE
JSVCE1
	LIS	R13,JCMJIN
	J	JSVCER

:	JCOM NOT CONNECTED, A RING DESCRIPTOR INACCESSIBLE
JSVCE2
	LIS	R13,JCMRIN
	J	JSVCER
:	EXPECTED CONNECT, GOT POLL
JSVCE3
	LIS	R13,JCMPOL
	J	JSVCER
:	JCOM OR RING DESCRIPTOR INVALID (POLL REQUEST)
JSVCE4
	LIS	R13,JCMIPL
	JFS	JSVCER
:	EXPECTED POLL, GOT CONNECT
JSVCE5
	LIS	R13,JCMCON
	JFS	JSVCER
:	INVALID JCOM DATA (NOT SIIX, BLACK BALL OR DATA)
	LIS	R13,JCMIVD

JSVCER
	ST	R13,RREG,R1		:USER R0
	J	KRET,,			:NON-SKIP RETURN



	SUBTTL	JCOM OUTPUT QUEUEING ROUTINE (JOQUER)

:****************************************************************
:*								*
:*	ROUTINE  - JOQUER					*
:*	-------							*
:*								*
:*	INPUT INTERFACE						*
:*	---------------						*
:*								*
:*	R3	->	DPB					*
:*								*
:*	LINK REGISTER	-  R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 3.5		*
:*								*
:*	PUT A DPB ON THE JCOM OUTPUT QUEUE. IF NOTHING WAS ON	*
:*	THE Q TO START WITH, CALL THE JCOM LOADER ROUTINE TO	*
:*	START OUTPUT.						*
:****************************************************************

JOQSAV	WS	10			:SAVE AREA
JOQUER
	STM	R0,JOQSAV		:SAVE LINK
	LIS	R15,0
	ST	R15,DP.JCQ,R3		:DPB GOES ON END OF Q
	L	R15,JCOUTQ		:ANYTHING ON THE Q ?
	JNFS	JQUER1			:SKIP IF THERE IS
	ST	R3,JCOUTQ		:PUT AT HEAD OF Q
	ST	R3,JCOQND		:FIX UP TAIL
	JAL	R11,JOLODR		:CALL THE RING LOADER
	JFS	JQUER2
JQUER1
	L	R15,JCOQND		:PUT DPB ON END OF Q
	ST	R3,DP.JCQ,R15		:LINK ON END
	ST	R3,JCOQND		:FIX UP TAIL
JQUER2
	LM	R0,JOQSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


	SUBTTL	JCOM OUT RING LOADER (JOLODR)

:****************************************************************
:*								*
:*	ROUTINE  - JOLODR					*
:*	-------							*
:*								*
:*	REGISTER USAGE						*
:*	--------------						*
:*								*
:*	R10	-	SPACE AVAILABLE IN THE RING		*
:*	R9	-	SPACE AVAILABLE BEFORE RING MUST WRAP	*
:*			NEGATIVE IF CEI > NFI			*
:*	R8	-	NFI (OF RING)				*
:*	R7	-	CEI (OF BUFFER)				*
:*	R6	-	BUFFER ADDR				*
:*	R5	-	BUFFER LENGTH				*
:*	R4	->	RING DESCRIPTOR				*
:*	R3	->	DPB					*
:*								*
:*	LINK REGISTER - R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 3.6		*
:*								*
:*	LOAD DPB MESSAGES INTO THE JCOM OUTPUT RING. MESSAGES	*
:*	CAN BE SPLIT INTO TWO PARTS AS DEFINED BY THE DPB	*
:*	FIELDS DP.DA1/2, DP.LN1/2. DPB'S CAN COME FROM EITHER	*
:*	THE TRANSPORT SERVICE OR DTS, AS DEFINED BY THE FLAG	*
:*	CNTMSS. JOLODR TAKES THE DPB'S FROM THE FIFO JCOUTQ.	*
:****************************************************************

JLDSAV	WS	1			:REGISTER SAVE AREA
JOLODR
	ST	R11,JLDSAV		:SAVE LINK
	L	R3,JCOUTQ		:GET FIRST DPB ON Q
	JAL	R11,JCSPCE		:GET AVAILABLE SPACE
JLDLP1
	LR	R3,R3			:IS THERE A DPB ?
	JE	JLDNFI			:SKIP IF NOT, FIX UP NFI
	LR	R10,R10			:ANY SPACE LEFT ?
	JE	JLDNFI			:SKIP IF NOT, FIX UP NFI
	LIS	R15,0			:ASSUME MESSAGE PART 1
	LIS	R14,DATIDX		:TEST FOR MESSAGE PART 2
	TBT	R14,DP.FLG,R3
	JEFS	JLDR01			:SKIP IF PART 1
	LIS	R15,8			:OTHERWISE, OFFSET TO PART 2
JLDR01
	L	R5,DP.LN1,R3,R15	:MESSAGE LENGTH
	L	R6,DP.DA1,R3,R15	:MESSAGE ADDR
	LR	R15,R15			:WAS IT MSG PART 1 ?
	JN	JLDLP2			:SKIP IF PART 2
	LIS	R14,CNTMSS		:RESYNC FROM TRANSPORT ?
	TBT	R14,DP.FLG,R3
	JE	JLDLP2			:SKIP IF NOT
	LIS	R2,SIXSNT		:HAS THE SIIX BEEN SENT ?
	TBT	R2,DP.FLG,R3
	JN	JLDLP2			:SKIP IF IT HAS
	LHI	R14,SIIXMS		:TRY AND SEND SIIX
	JAL	R11,PUTSIG
	LR	R14,R14			:DID THE SIGNAL GO ?
	JNFS	JLDLP2			:SKIP IF NOT (SPACE FORCED TO 0)
	SBT	R2,DP.FLG,R3		:SHOW SIIX SENT
JLDLP2
	LR	R10,R10			:ANT SPACE LEFT ?
	JE	JLDNFI			:SKIP IF NOT, FIX UP NFI
	LIS	R7,0			:NEW CEI OF BUFFER
	LR	R5,R5			:ANY BYTES TO GO IN RING ?
	JN	JLDR05			:SKIP IF THERE IS 
	LIS	R15,DATIDX		:MSG PART 1 ?
	TBT	R15,DP.FLG,R3
	JNFS	JLDRDF			:SKIP IF FINISHED WITH DPB
	LIS	R15,IGLN2		:THIS FLAG IS SET IF DA.LN2 STORES..
	TBT	R15,DP.FLG,R3		:RECL OF A READ,I.E NO OUTPUT TO RING
	JNFS	JLDRDF			:SKIP IF READ RECL IN DP.LN2
	LIS	R15,DATIDX		:OTHERWISE MOVE ON TO MSG PART 2
	J	JLDR04
JLDRDF	JAL	R11,JQUNLK		:TAKE DPB OFF Q
	LIS	R15,CNTMSS		:FOR TRANSPORT OR DTS ?
	TBT	R15,DP.FLG,R3
	JNFS	JLDR02			:SKIP FOR TRANSPORT
	JAL	R11,DTSOPC		:TELL DTS OUTPUT COMPLETE
	JFS	JLDR03
JLDR02
	LIS	R6,0
	STB	R6,DP.RQS,R3		:SHOW DPB NO LONGER IN USE
JLDR03
	L	R3,JCOUTQ		:GET NEXT DPB
	J	JLDLP1			:AND SEE IF WE CAN CONTINUE
JLDR04
	SBT	R15,DP.FLG,R3		:SHOW WE ARE ON MSG PART 2
	L	R5,DP.LN2,R3		:PART 2 LENGTH
	L	R6,DP.DA2,R3		:PART 2 ADDR
	J	JLDLP2
JLDR05
	JAL	R11,JCMSTF		:STUFF BYTES IN RING
	LIS	R15,0			:ASSUME MSG PART 1
	LIS	R14,DATIDX
	TBT	R14,DP.FLG,R3
	JEFS	JLDR06			:SKIP IF PART 1
	LIS	R15,8			:OTHERWISE PART 2
JLDR06
	AR	R6,R7			:PUSH ADDR ON
	SR	R5,R7			:DECREMENT BYTES TO GO
	ST	R6,DP.DA1,R3,R15	:UPDATE ADDR
	ST	R5,DP.LN1,R3,R15	:UPDATE LENGTH
	J	JLDLP2			:MORE SPACE, MORE BYTES ?
JLDNFI
	L	R4,JORDES		:JCOM OUT RING DESC'R
	STH	R8,JRGNFI,R4		:UPDATE NFI
	L	R11,JLDSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


:	STUFF BYTES INTO THE JCOM OUTPUT RING.
:	R9 IS THE NUMBER OF BYTES AVAILABLE IN THE RING BEFORE THE RING MUST
:	BE WRAPPED. IF R9=0, NFI IS POINTING TO THE LAST BYTES IN THE RING
:	AND A RINGWRAP MUST BE PLACED THERE. IF R9>0, THEN NFI > CEI, WHICH
:	MEANS A RINGWRAP WILL EVENTUALLY BE PUT IN THE RING BEFORE THE RING
:	IS FULL. IF R9<0 THEN CEI > NFI, WHICH MEANS A RINGWRAP MESSAGE WILL
:	NOT BE PLACED IN THE RING AT THIS TIME (IF ENOUGH DATA COULD BE PUT
:	IN THE RING AT THIS TIME).

:	ON ENTRY -
:	R10	=	RINGSPACE
:	R9	=	BYTES BEFORE WRAP
:	R8	=	RING NFI
:	R7	=	BUFFER NFI
:	R6	=	BUFFER ADDR
:	R5	=	BUFFER LENGTH

STFSAV	WS	1			:SAVE AREA
JCMSTF
	ST	R11,STFSAV		:SAVE LINK
JCSFLP
	LR	R10,R10			:ANY SPACE LEFT ?
	JE	JSFEND			:IF NOT,GET OUT
	CR	R5,R7			:ANY MORE BYTES TO GO ?
	JE	JSFEND			:IF NOT,GET OUT
	LR	R9,R9			:HOW MUCH SPACE BEFORE WRAP ?
	JL	JCSF02			:SKIP IF NO WRAP
	CLHI	R9,2			:AT LEAST TWO BYTES FOR A DATA MSG
	JC	JCSF01			:SKIP IF THERE IS
	JAL	R11,PUTWRP		:OTHERWISE, WRAP THE RING
	J	JCSFLP			:AND TRY AGAIN
JCSF01
	LR	R15,R9			:PUT UPTO WRAP BYTES IN RING
	JAL	R11,JCMPDM
	J	JCSFLP			:AND TRY SOME MORE
JCSF02
	CLHI	R10,2			:AT LEAST TWO BYTES FOR A DATA MSG
	JC	JCSF03			:SKIP IF THERE IS
	LIS	R10,0			:CANCEL AVAILABLE SPACE
	JFS	JSFEND			:AND EXIT
JCSF03
	LR	R15,R10			:PUT UP TO SPACE BYTES IN RING
	JAL	R11,JCMPDM
	J	JCSFLP			:DO SOME CHECKS, WE SHOULD EXIT
JSFEND
	L	R11,STFSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


:	PUT DATA MESSAGE IN JCOM OUTPUT RING
:	ON ENTRY - R9 = R10 OR R9
:	R15	=	AVAILABLE SPACE
:	R10	=	RING SPACE
:	R9	=	BYTES BEFORE WRAP
:	R8	=	NFI OF RING
:	R7	=	CEI OF BUFFER
:	R6	=	BUFFER ADDR

PDMSAV	WS	1			:SAVE AREA
JCMPDM
	ST	R11,PDMSAV		:SAVE LINK
JPDMLP
	CLHI	R15,2			:NEED MORE THAN 1 BYTE FOR A DATA MSG
	JNC	JPMEND			:GET OUT IF NOT ENOUGH SPACE
	CR	R5,R7			:ALL MSG IN RING ?
	JE	JPMEND			:GET OUT IF SO
	LR	R14,R5
	SR	R14,R7			:R14 = BYTES REMAINING
	LR	R13,R15			:GET MAX MSG THAT COULD GO IN
	CLHI	R13,9E			:MAX MSG LENGTH = 9E
	JNC	JPDM01			:SKIP IF BYTES AVAIL < MAX MSG
	LHI	R13,9E			:OTHERWISE, ENFORCE MAX
JPDM01
	AIS	R14,1			:NEDD 1 BYTES FOR MSG TYPE (1-9D)
	CLR	R13,R14			:MSG = MIN(R13,R14)
	JNC	JPDM02
	LR	R13,R14
JPDM02
	LR	R14,R13
	SIS	R14,1			:R14 = BUFFER BYTES MOVED
	L	R4,JORDES		:OUT RING DESC'R
	STB	R14,JRGBUF,R4,R8	:RING[NFI] = MSG LENGTH
	AIS	R8,1			:++NFI
	SR	R10,R13			:RINGSPACE -= BYTES THIS TIME
	SR	R15,R13			:BYTES AVAILABLE -= BYTES THIS TIME
	SR	R9,R13			:WRAP -= BYTES THIS TIME
JPDM03
	LB	R13,0,R6,R7		:R13 = BUFFER[CEI]
	STB	R13,JRGBUF,R4,R8	:RING[NFI] = BYTE
	AIS	R8,1			:++NFI
	AIS	R7,1			:++CEI
	SIS	R14,1			:FOR BYTES TO BE MOVED
	JNBS	JPDM03
	J	JPDMLP			:SEE IF ANY MORE TO GO
JPMEND
	L	R11,PDMSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


	:STUFFJCOM,PUTRINGWRAP,PUTBYTEINJCOM,PUTDATAMSGINJCOM
	:JCOMSPACE

:	PUT RING WRAP. THE RING CANNOT BE WRAPPED IF THE CEI IS ZERO, IN
:	THIS CASE JUST SET THE AMOUNT OF RINGSPACE AVAILABLE TO ZERO.

WRPSAV	WS	1			:SAVE AREA
PUTWRP
	ST	R11,WRPSAV		:SAVE LINK
	L	R4,JORDES		:OUT RING DESC'R
	LHL	R15,JRGCEI,R4		:CHECK FOR CEI = 0
	JNFS	PTWRP1			:SKIP IF NOT
	LIS	R10,0			:NO SPACE IN RING
	JR	R11			:RETURN TO CALLER
PTWRP1
	LHI	R15,RNGWRP		:RING WRAP MESSAGE
	STB	R15,JRGBUF,R4,R8	:AT NFI
	LIS	R15,0			:RESET NFI
	STH	R15,JRGNFI,R4		:IN THE DESC'R
	JAL	R11,JCSPCE		:RECALCULATE SPACE AVAILABLE
	L	R11,WRPSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER

:	CALCULATE THE AMOUNT OF SPACE LEFT IN THE OUTPUT RING AND THE
:	NUMBER OF BYTES THAT CAN BE PUT IN THE RING BEFORE THE RING
:	MUST BE WRAPPED. IF CEI>NFI THE RING CANNOT BE WRAPPED SO THE
:	WRAP LENGTH IS SET TO -1 .
:
:	ON EXIT -
:	R8	=	RING NFI
:	R9	=	WRAP
:	R10	=	SPACE

JCSPCE
	L	R4,JORDES		:OUT RING DESC'R
	LHL	R8,JRGNFI,R4		:GET THE NFI
	LHL	R15,JRGCEI,R4		:AND THE CEI
	CR	R8,R15
	JNFS	JCSPC1			:SKIP IF CEI # NFI
	LHL	R10,JRGBLN,R4		:CEI = NFI
	SIS	R10,1			:SPACE = LENGTH -1
	LR	R9,R10
	SR	R9,R8			:WRAP = LENGTH - NFI -1
	JR	R11			:RETURN TO CALLER
JCSPC1
	JGFS	JCSPC2
	LR	R10,R15			:CEI > NFI
	SR	R10,R8
	SIS	R10,1			:SPACE = CEI - NFI - 1
	LCS	R9,1			:WRAP = -1
	JR	R11			:RETURN TO CALLER
JCSPC2
	LHL	R10,JRGBLN,R4		:NFI > CEI
	AR	R10,R15
	SR	R10,R8
	SIS	R10,1			:SPACE = LENGTH + CEI - NFI - 1
	LR	R9,R10
	SR	R9,R15			:WRAP = SPACE - CEI
	JR	R11			:RETURN TO CALLER

:	PUT A SIGNAL IN THE OUTPUT RING. RETURNS 0 IF THE SIGNAL WAS
:	SENT OTHERWISE RETURNS SIGNAL (SINAL > X9D)
:	R14	=	SIGNAL

SIGSAV	WS	1			:SAVE AREA
PUTSIG
	ST	R11,SIGSAV		:SAVE LINK
	LR	R9,R9			:DO WE NEED TO WRAP
	JNFS	PTSIG1			:SKIP IF NOT WRAPPING
	JAL	R11,PUTWRP		:OTHERWISE WRAP THE RING
PTSIG1
	LR	R10,R10			:ANY SPACE LEFT IN THE RING ?
	JNFS	PTSIG2			:SKIP IF THERE IS
	L	R11,SIGSAV		:RETORE LINK
	JR	R11			:RETURN TO CALLER
PTSIG2
	L	R4,JORDES		:OUT RING DESC'R
	STB	R14,JRGBUF,R4,R8	:PUT SIGNAL AT NFI
	AIS	R8,1			:++NFI
	SIS	R10,1			:--SPACE
	SIS	R9,1			:--WRAP
	LIS	R14,0			:SIGNAL SENT OK
	L	R11,SIGSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


	SUBTTL	JCOM INPUT RING ANALYSER (JINRAN)

:****************************************************************
:*								*
:*	ROUTINE	- JINRAN					*
:*	-------							*
:*	LINK REGISTER	- R11					*
:*	-------------						*
:*								*
:*	DESCRIPTION						*
:*	-----------						*
:*								*
:*	SEE: MBASE SUPERVISOR SUPPORT GID, SECTION 3.7		*
:*								*
:*	THIS ROUTINE CONVERTS THE STREAM OF BYTES IN THE	*
:*	JCOM INPUT RING TO NETWORK AND TRANSPORT PROTOCOL	*
:*	UNITS							*
:*								*
:****************************************************************

:	JUMP TABLE FOR JCOM STATE

	WS	0
INRJMP
	WC	DDSMSG			:DISCARDING DATA STRING MESSAGES
	WC	NEWMSG			:WAITING FOR NEW MSG OF ANY KIND
	WC	IIXCMD			:WAITING FOR IIX CMD FIELD
	WC	TPDULI			:WAITING FOR TPDU LI FIELD
	WC	TPDUHD			:WAITING FOR TPDU HEADER
	WC	TPDUDA			:WAITING FOR TPDU DATA FIELD
INREND	EQ	.
INRJLN	EQ	(INREND-INRJMP)/4	:LENGTH OF JUMP TABLE

INRSAV	WS	1			:SAVE AREA
JINRAN
	ST	R11,INRSAV		:SAVE LINK
JINRLP
	JAL	R11,JCMLOK		:LOOK IN THE RING
	LR	R10,R10			:ANYTHING THERE ?
	JNFS	JINR01			:SKIP IF THERE IS
	STH	R10,JRGNFI,R4		:RESET RING POINTERS
	STH	R10,JRGCEI,R4
	L	R11,INRSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER
JINR01
	JAL	R11,JCMCNM		:CHECK FOR NON-DATA MSG'S
:	RETURNS	R4 ->	RING DESC'R
:		R7 =	RING CEI
:		R8 =	BYTES IN RING MSG
:	ALSO THIS ROUTINE WILL DEAL WITH SIIX, BLACKBALL AND INVALID MSG'S

	LR	R8,R8			:HAVE WE GOT DATA ?
	JE	JINRLP			:SKIP IF NOT
	LHL	R15,JCSTAT		:JCOM STATE
	CLHI	R15,INRJLN		:RANGE CHECK
	JNC	JINR02			:SKIP IF IN RANGE
:	BIG TROUBLE -- CRASH ISIS
JINR02
	SLHLS	R15,2			:MAKE FULLWORD INDEX
	LA	R14,INRJMP		:GET JUMP TABLE ADDR
	L	R15,0,R14,R15		:GET HANDLER ADDR
	JR	R15			:AND GO TO IT

:	DISCARDING DATA STRING MESSAGES

DDSMSG
	LR	R15,R8			:DELETE MSG FROM RING
	JAL	R11,JCMDLN
	J	JINRLP			:AND LOOK AGAIN

:	WAITING FOR A NEW MESSAGE OF ANY KIND

NEWMSG
	LIS	R15,0
	STH	R15,INTPDU		:WITHIN TPDU BOUNDARY
	LB	R15,JRGBUF+1,R4,R7	:FIRST BYTE TPDU LI
	LR	R14,R15
	NHI	R14,80			:TOP BIT SET IF 3 BYTE LI
	JE	NMSG02			:SKIP IF ONLY 1 BYTE LI
	CLHI	R8,3			:DO WE HAVE ALL 3 BYTES OF LI
	JNC	NMSG01			:SKIP IF NOT
	LA	R15,JRGBUF+1,R4,R7	:POINT TO THE LI FIELD
	LIS	R14,3
	JAL	R13,JCMGET		:GET THE LI FIELD
	NI	R14,7FFFFF		:CLEAR THE TOP BIT
	ST	R14,TPDULN		:LENGTH OF TPDU
	J	NMSG03
NMSG01
	LIS	R14,WTG.LI		:WAITING FOR LI FIELD...
	STH	R14,JCSTAT		:IS NEW JCOM STATUS
	STH	R8,JHBNFI		:HEADER BUFFER NFI
	LB	R15,JRGBUF+1,R4,R7	:GET 1ST BYTE LI
	STB	R15,JCHDBF		:IN JCHDBF[0]
	LB	R15,JRGBUF+2,R4,R7	:2ND BYTE LI (MAY BE INVALID)
	STB	R15,JCHDBF+1		:JCHDBF[1]
	LR	R15,R8
	JAL	R11,JCMDLN		:DELETE R15 BYTES FROM RING
	J	JINRLP			:GO LOOK FOR MORE INPUT
NMSG02
	ST	R15,TPDULN		:LENGTH OF TPDU
NMSG03
	C	R8,TPDULN		:IS THE WHOLE TPDU AVAILABLE
	JCFS	NMSG04			:SKIP IF IT IS
	CLHI	R8,MXHDRM		:OR AT LEAST MAX HEADROOM BYTES
	JNCFS	NMSG05			:SKIP IF NOT
NMSG04
	LA	R15,JRGBUF+1,R4,R7	:ADDR OF TPDU
	ST	R15,TPDUAD
	JAL	R11,RTPDUH		:READY WITH TPDU HEADER
	J	JINRLP			:GO LOOK FOR MORE INPUT
NMSG05
	L	R15,TPDULN		:TPDU LENGTH
	LHI	R14,MXHDRM		:MAX HEADROON
	CLR	R15,R14
	JNCFS	NMSG06
	LR	R15,R14
NMSG06
	STH	R15,TPHDLN		:TPHDLN = MIN(TPDULN,MXHDRM)
	LR	R13,R8			:BYTES TO TRANSFER
	AR	R4,R7			:OFFSET TO CEI
NMSG07
	LB	R15,JRGBUF,R4,R13	:GET BYTE FROM RING
	STB	R15,JCHDBF-1,R13	:AND PUT IN HEADER BUFF
	SIS	R13,1			:DUMP INDEX
	JNBS	NMSG07			:FOR BYTES TO COPY
	STH	R8,JHBNFI		:UPDATE BUFFER NFI
	LR	R15,R8
	JAL	R11,JCMDLN		:DELETE R15 BYTES FROM RING
	LIS	R15,WTG.HD		:WAITING FOR TPDU HEADER
	STH	R15,JCSTAT
	J	JINRLP			:GO LOOK FOR MORE INPUT

:WAITING FOR IIX COMMAND FIELD

IIXCMD
	LIS	R15,2			:PUT UP TO 2 BYTES IN HEADER BUFF
	JAL	R11,STFHED
	CLHI	R14,2			:GOT BOTH BYTES OF RESYNC ?
	JN	JINRLP			:GO LOOK FOR MORE IF NOT
	LH	R15,JCHDBF		:PICK UP 2 BYTES FROM HEADER BUFF
	LIS	R6,WTG.NM		:WAITING FOR A NEW MSG OF ANY KIND
	STH	R6,JCSTAT		:IS NEW JCOM STATUS IF RESYNC OK
	LIS	R6,NRSYNC		:ASSUME A VALID N-RESYNC
	CLHI	R15,SYNCMS		:IS IT A RESYNC MSG ?
	JEFS	IIXC01			:SKIP IF IT IS
	LIS	R6,NRESET		:OTHERWISE, INDICATE N-RESET
IIXC01
	JAL	R11,TEVENT		:TELL TRANSPORT ABOUT IT
	J	JINRLP			:GO LOOK FOR MORE INPUT

:	WAITING FOR TPDU LI FIELD

TPDULI
	LIS	R15,3			:TRY AND GET 3 BYTE LI IN HEADER BUFF
	JAL	R11,STFHED
	CLHI	R14,3			:GOT ALL LI ?
	JN	JINRLP			:GO LOOK FOR MORE IF NOT
	L	R15,JCHDBF		:GET TPDU LI
	NI	R15,7FFFFFFF		:STRIP OFF TOP BIT
	SRLS	R15,8			:ALIGN 3 LSB'S
	ST	R15,TPDULN		:TPDU LENGTH
	LHI	R14,MXHDRM		:MAX HEADROOM
	CLR	R15,R14
	JNC	TPLI01
	LR	R15,R14
TPLI01					:R15= MIN(TPDULN,MXHDRM)
	STH	R15,TPHDLN		:BYTES TO PUT IN HEADER BUFF
	LIS	R15,WTG.HD		:WAITING FOR TPDU HEADER...
	STH	R15,JCSTAT		:IS NEW JCOM STATE
	J	JINRLP			:GO LOOK FOR MORE INPUT

:	WAITING FOR TPDU HEADER

TPDUHD
	LHL	R15,TPHDLN		:BYTES NEEDED IN HEADER BUFF
	JAL	R11,STFHED		:TRY AND GET THEM
	CH	R14,TPHDLN		:GOT AS MUCH AS WE NEED ?
	JN	JINRLP			:LOOK FOR MORE INPUT IF NOT
	LA	R15,JCHDBF		:TPDU IS IN HEADER BUFF
	ST	R15,TPDUAD		:FIX UP ADDR
	JAL	R11,RTPDUH		:READY WITH TPDU HEADER
	J	JINRLP			:GO LOOK FOR MORE INPUT

:	WAITING FOR TPDU DATA FIELD

TPDUDA
	L	R15,RBCDMA		:REMAINING BYTE COUNT TO DMA
	CLR	R15,R8
	JNC	TPDA01
	LR	R15,R8
TPDA01
	LR	R15,R15			:R15 = MIN(MSG,RBCDMA)
	JE	TPDA03			:SKIP IF DMA COMPLETE
	LR	R2,R15			:KEEP A COPY
	AR	R4,R7			:R4 + JRGBUF -> MSG
	L	R14,RBCDMA		:UPDATE RBCDMA
	SR	R14,R15
	ST	R14,RBCDMA
	L	R14,RBCTPD		:UPDATE RBCTPD
	SR	R14,R15
	ST	R14,RBCTPD
	L	R14,NFADMA		:UPDATE NFADMA
	LR	R13,R14			:KEEP A COPY
	AR	R14,R15
	ST	R14,NFADMA
TPDA02
	LB	R12,JRGBUF,R4,R15	:GET BYTE FROM MSG
	STB	R12,-1,R13,R15		:DMA TO SLOT
	SIS	R15,1
	JNBS	TPDA02			:FOR BYTES TO TRANSFER
	LR	R15,R2			:BYTES TO DELETE
	JAL	R11,JCMDLN		:DELETE THEM
	J	TPDA05			:SEE IF THAT COMPLETES THE TPDU
TPDA03

	L	R15,RBCTPD		:REMAINING BYTE COUNT IN TPDU
	LR	R14,R15			:KEEP A COPY
	CLR	R15,R8
	JNC	TPDA04
	LR	R15,R8
TPDA04
	LR	R15,R15			:R15 = MIN(MSG,RBCTPD)
	JE	TPDA06			:SKIP IF TPDU PROCESSING COMPLETE
	SR	R14,R15			:UPDATE RBCTPD
	ST	R14,RBCTPD
	JAL	R11,JCMDLN		:DELETE BYTES FROM THE RING
TPDA05
	L	R14,RBCTPD		:IS THIS TPDU COMPLETE ?
	JN	JINRLP			:GO LOOK AGAIN IF NOT
TPDA06
	LIS	R6,WTG.NM		:WAITING FOR A NEW MSG OF ANY KIND...
	STH	R6,JCSTAT		:IS NEW JCOM STATE
	TS	INTPDU			:NO LONGER IN TPDU
	JAL	R10,DTSDAC		:DTS DMA COMPLETE
	J	JINRLP			:GO LOOK FOR MORE INPUT


:	STUFF BYTES IN THE HEADER BUFFER
:	R15	=	NUMBER OF BYTES WANTED
:	R8	=	NUMBER OF BYTES IN RING MSG
:	R7	=	RING	CEI
:	R4	=	RING DESC'R
:	ROUTINE COPIES MIN(R8,R15-JHBNFI) TO HEADER BUFFER
:	ON EXIT -
:	R14	=	JHBNFI
:	R4	->	MSG

SFHSAV	WS	1			:SAVE AREA
STFHED
	ST	R11,SFHSAV		:SAVE LINK
	SH	R15,JHBNFI		:SUBTRACT BYTES ALREADY THERE
	CLR	R15,R8			:GET R15 = MIN(R15,R8)
	JNC	STFHD1			:SKIP IF R15 LESS
	LR	R15,R8			:OTHERWISE, MOVE IN R8
STFHD1
	AR	R4,R7			:R4 -> MSG
	LR	R13,R15			:BYTES TO MOVE
	LHL	R14,JHBNFI		:HEADER BUFF NFI
STFHD2	:BACKWARDS COPY BYTES INTO HEADER BUFF FROM RING
	LB	R12,JRGBUF,R4,R13	:BYTE FROM RING
	STB	R12,JCHDBF-1,R14,R13	:PUT IN BUFFER
	SIS	R13,1			:FOR BYTES TO MOVE
	JNBS	STFHD2
	AR	R14,R15			:BUMP NFI
	STH	R14,JHBNFI
	JAL	R11,JCMDLN		:DELETE THE BYTES FROM RING
	L	R11,SFHSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


:	CHECK FOR NON-DATA MESSAGES

:	THIS ROUTINE RETURNS R8 = 0 IF
:	A VALID RINGWRAP, BLACKBALL OR SIIX IS FOUND IN THE RING
:	AND THE JCOM INPUT ANALYSIS STATE WILL BE CHANGED ACCORDINGLY.
:	THIS ROUTINE CRASHES MBASE AND DOES NOT RETURN IF THER IS ANYTHING
:	INVALID IN THE RING.
:	OTHERWISE R8 = LENGTH OF DATA MESSAGE FOUND IN THE RING.

CNMSAV	WS	1			:SAVE AREA
JCMCNM
	ST	R11,CNMSAV		:SAVE LINK
	JAL	R11,JCMMSG		:GET NEXT MSG
	CLHI	R8,RNGWRP		:RING WRAP ?
	JE	CNMEND			:JUST RETURN NULL IF WRAP
	CLHI	R8,SIIXMS		:SIIX ?
	JNFS	JCNM02			:SKIP IF NOT
	LIS	R8,WTG.IX		:WAITING FOR IIX CMD FIELD...
	STH	R8,JCSTAT		:IS NEW JCOM STATE
	LIS	R8,0
	STH	R8,JHBNFI		:INIT HEADER BUFF NFI
	J	CNMEND			:AND RETURN NULL
JCNM02
	CLHI	R8,BBLLMS		:BLACK BALL ?
	JNFS	JCNM03			:SKIP MUST BE A DATA MSG
	LIS	R6,NRESET		:N-RESET
	JAL	R11,TEVENT		:TELL TRANSPORT ABOUT IT
CNMEND
	LIS	R8,0			:RETURN NULL
JCNM03
	L	R11,CNMSAV		:RETORE LINK
	JR	R11			:RETURN TO CALLER

:	JCOM LOOK
:	RETURNS NUMBER OF BYTES TO PROCESS (R10) AND SETS THE VALUE
:	OF THE LARGEST POSSIBLE DATA MSG (R9) THAT COULD FIT IN THE
:	RING BEFORE A RINGWRAP SHOULD BE FOUND.
:	N = NFI - CEI
:	IF N = 0 THEN R10 = 0
:	IF N > 0 THEN R10 = N AND R9 = N-1
:	IF N < 0 THEN R10 = RING LENGTH + N AND R9 = RING LENGTH - 2 - CEI

JCMLOK
	L	R4,JIRDES		:JCOM IN RING DESC'R
	LHL	R10,JRGNFI,R4		:GET RING NFI
	LHL	R14,JRGCEI,R4		:GET RING CEI
	SR	R10,R14			:BYTES TO READ
	JER	R11			:RETURN IF ZERP
	JLFS	JLOOK1
	LR	R9,R10
	SIS	R9,1
	JR	R11
JLOOK1
	LHL	R9,JRGBLN,R4		:RING LENGTH
	AR	R10,R9
	SR	R9,R14
	SIS	R9,2
	JR	R11

:	GET JCOM MESSAGE
:	THE PARAMETER PASSED TO THIS ROUTINE (R9), IS THE LARGEST POSSIBLE
:	DATA MESSAGE THAT CAN FIT IN THE RING WITHOUT USING UP THE LAST
:	BYTE FOR A RINGWRAP MESSAGE. IF R9 = -1, THEN THE RING'S CEI IS 
:	POINTING TO THE LAST BYTE IN THE RING, IN WHICH CASE A RINGWRAP
:	MESSAGE MUST BE FOUND: IF A RINGWRAP IS NOT FOUND, THE JCOM SLOT
:	GETS AN ERROR RETURN TO THE SVC. THERE ARE ONLY THREE PERMISSIBLE
:	MESSAGES IN A JCOM RING: SIIX, BLACKBALL AND A DATA MESSAGE. IF
:	ANY OTHER MESSAGE IS DETECTED, THE JCOM SLOT GETS AN ERROR RETURN
:	TO THE SVC. IF A DATA MESSAGE LENGTH EXCEEDS (R9), THE JCOM SLOT
:	GETS AN ERROR RETURN TO THE SVC.

JCMMSG
	L	R4,JIRDES		:JCOM IN RING DESC'R
	LHL	R7,JRGCEI,R4		:GET CEI
	LB	R8,JRGBUF,R4,R7		:GET MSG
	CLHI	R8,RNGWRP		:RING WRAP ?
	JNFS	JMSG01			:SKIP IF NOT
	LIS	R7,0			:CEI = 0
	STH	R7,JRGCEI,R4		:UPDATE RING DESC'R
	JR	R11			:RETURN TO CALLER
JMSG01
	CLHI	R8,9E			:IS IT A DATA MESSAGE ?
	JL	JMSG06			:SKIP IF IT IS
	LCS	R14,1			:IS MAX MSG (R10) = -1
	CR	R9,R14			:I.E CEI AT END OF RING
	JNFS	JMSG03			:SKIP IF NOT
JMSG02
	LIS	R15,6			:SHOULD HAVE BEEN RING WRAP
	ST	R15,RREG,R1		:SLOT R0 = 6
	J	KRET,,			:NON-SKIP RETURN TO SLOT
JMSG03
	CLHI	R8,SIIXMS		:SIIX ?
	JNFS	JMSG05			:SKIP IF NOT
JMSG04
	AIS	R7,1
	STH	R7,JRGCEI,R4		:BUMP CEI
	JR	R11			:AND RETURN TO CALLER
JMSG05
	CLHI	R8,BBLLMS		:BLACK BALL ?
	JEBS	JMSG04			:SKIP IF IT IS
	J	JMSG02			:OTHERWISE, TELL THE SLOT
JMSG06
	CLR	R9,R8			:MAX DATA MSG < MSG ?
	JNC	JMSG02			:SKIP IF IT IS

	JR	R11


:	DELET BYTES FROM THE JCOM INPUT RING
:	R15	=	BYTES TO DELETE
:	R4	->	JCOM IN RING DESC'R

DLNSAV	WS	2			:SAVE AREA
JCMDLN
	STM	R14,DLNSAV		:SAVE R14,R15
	LR	R15,R15			:REJECT ZERO LENGTH
	JE	JDLEND
	L	R4,JIRDES		:JCOM INPUT RING DESC'R ADDR
	LHL	R14,JRGCEI,R4		:GET CEI
	LB	R13,JRGBUF,R4,R14	:GET MSG LENGTH
	CR	R13,R15			:DELETE THE WHOLE MSG ?
	JNFS	JDLN01			:SKIP IF NOT
	AR	R14,R15			:BUMP NFI...
	AIS	R14,1			:PAST MSG
	STH	R14,JRGCEI,R4		:UPDATE DESC'R
	J	JDLEND			:AND EXIT
JDLN01
	AR	R14,R15			:BUMP NFI
	SR	R13,R15			:DEC BYTES IN MSG
	STB	R13,JRGBUF,R4,R14	:UPDATE RING
	STH	R14,JRGCEI,R4		:UPDATE DESC'R
JDLEND
	LM	R14,DLNSAV		:RETORE R14,R15
	JR	R11			:RETURN TO CALLER

:	READY WITH TPDU HEADER
:	PAASES TPDU TO THE EVENT HANDLER. IF IT IS A DA TPDU, DTS WILL
:	HAVE SET UP DMA CONTROLS FOR THE TRANSFER TO SLOT MEMORY. IF
:	ANY OF THE DATA BYTES ARE HELD IN THE HEADER BUFFER, THIS ROUTINE WILL
:	COPY THEM TO THE SLOT MEMORY.

:	ON ENTRY -
:	TPDUAD	=	ADDR OF THE TPDU
:	TPDULN	=	LENGTH OF THE TPDU

THDSAV	WS	1			:SAVE AREA
RTPDUH
	ST	R11,THDSAV		:SAVE LINK
	LIS	R6,WTG.NM		:ASSUME THIS WILL BE NEXT STATE
	STH	R6,JCSTAT		:...WAITING FOR NEW MSG OF ANY KIND
	LIS	R6,0
	STH	R6,DTSERR		:NO DTS PROTOCOL ERROR, YET
	ST	R6,RBCDMA		:NO DMA IN PROGRESS
	ST	R6,RBCTPD		:AND NO TPDU TO CLEAR OUT OF RING
	LIS	R6,TPDU			:EVENT TPDU
	L	R5,TPDULN		:TPDU LENGTH
	L	R3,TPDUAD		:TPDU ADDR
	JAL	R11,TEVENT		:TELL TRANSPORT ABOUT IT
	LHL	R6,DTSERR		:WAS THERE A DTS PROTOCOL ERROR ?
	JEFS	RTPDOK			:SKIP IF NOT
	LIS	R6,NRESET		:OTHERWISE, BREAK THIS CONNECTION
	JAL	R11,TEVENT		:..AND START OVER
	J	RTPEND
:	DMA CONTROLS SHOULD BE SET UP BY NOW
RTPDOK	L	R15,RBCTPD		:WAS DMA SET UP ?
	JE	RTPD04			:SKIP IF NOT
	L	R15,RBCDMA		:GET THE BYTE COUNT TO DMA
	LA	R14,JCHDBF		:ADDR OF JCOM HEADER BUFF
	C	R14,TPDUAD		:IS THE TPDU THERE ?
	JN	RTPD02			:SKIP IF IN RING
	LHL	R13,TPHDLN		:BYTES IN HEADER BUFF
	SH	R13,DATOFF		:CALACULATE DATA BYTES IN HEADER BUFF
	JLE	RTPD03			:SKIP IF NONE THERE
	L	R12,RBCTPD		:REMAINING BYTES OF TPDU (FROM DATOFF)
	SR	R12,R13			:LEASS STUFF IN HEADER BUFF
	ST	R12,RBCTPD		:UPDATE BYTES REMAINING
	LR	R15,R15			:ANY BYTES TO DMA ?
					:MAYBE NONE IF SLOT CRASHED SINCE..
					:THIS SVC WAS ISSUED OR IF ERROR
					:..RETURN FROM SERVER TO READ REQUEST
					:..IN WHICH CASE RECL=0
	JE	RTPD03			:JUST CLEAR THE REST OF THE TPDU
					:..FROM RING
	CLR	R13,R15			:TRANSFER UP TO RBCDMA BYTES FROM
					:HEADER BUFF TO SLOT
	JNC	RTPD00
	LR	R13,R15
RTPD00					:R13 = MIN(BYTES IN HEADER,RBCDMA)
	SR	R15,R13			:UPDATE RBCDMA
	ST	R15,RBCDMA
	L	R15,NFADMA		:NEXT FILLL ADDR FOR DMA
	LR	R12,R15			:CALCULATE NEXT FILL ADDR...
	AR	R12,R13			:AFTER THIS TRANSFER
	ST	R12,NFADMA
	LHL	R12,DATOFF		:GET OFFSET TO DATA BYTES
	AR	R14,R12			:R14 -> DATA BYTES
RTPD01
	LB	R12,-1,R14,R13		:GET BYTE FROM HEADER BUFF
	STB	R12,-1,R15,R13		:STORE AT DMA ADDR
	SIS	R13,1
	JNBS	RTPD01			:FOR DATA BYTES IN HEADER BUFF
	JFS	RTPD03
RTPD02
	LHL	R15,DATOFF
	JAL	R11,JCMDLN		:JUST DELETE DATOFF BYTES FROM RING
RTPD03
	LIS	R6,WTG.TD		:WAITING FOR TPDU DATA...
	STH	R6,JCSTAT		:IS NEW JCOM STATE
	J	RTPEND
RTPD04
	TS	INTPDU			:NO LONGER IN TPDU
	LA	R14,JCHDBF		:WAS THE TPDU...
	C	R14,TPDUAD		:IN THE HEADER BUFF ?
	JEFS	RTPEND			:SKIP IF IT WAS
	L	R15,TPDULN
	JAL	R11,JCMDLN		:DELETE TPDULN BYTES FROM RING
RTPEND
	L	R11,THDSAV		:RESTORE LINK
	JR	R11			:RETURN TO CALLER


:	JCOM DMA REQUEST
:	CALLED BY THE DTS APDU RECEIVER. SETS UP THE OFFSET TO THE APDU
:	DATA FIELD FROM THE START OF THE TPDU AND CALCULATES THE
:	REMAINING BYTE COUNT OF THE TPDU FROM THE OFFSET. THE INITIAL
:	BYTE COUNT FOR THE DMA AND THE REMAINING BYTE COUNT OF THE TPDU
:	DETERMINE HOW MUCH OF THE RR TPDU NEED TO BE DISCARDED AFTER THE
:	DMA IS COMPLETE.
:	ON ENTRY -
:	R12	=	FUNCT OFFSET FROM APDU LI
:	R9	=	GLOBAL UNIT ADDRESS
:	R6	=	TRANSFER LENGTH
:	R5	=	DMA START ADDRESS

JDMARQ
	LIS	R13,2			:ASSUME 1 BYTE TPDU LI
	L	R15,TPDUAD		:GET TPDU ADDR
	LB	R15,0,R15		:GET TPDU LI
	NHI	R15,80			:TOP BIT SET ?
	JEFS	JDMRQ1			:SKIP IF NOT
	LIS	R13,4			:3 BYTE LI
JDMRQ1
	AR	R12,R13			:R12=OFFSET TO FUNCT FROM TPDU LI
	AHI	R12,URDATA		:R12=OFFSET TO DATA FIELD
	STH	R12,DATOFF		:DMA CONTROL - DATOFF
	ST	R9,GLUDMA		:DMA CONTROL - GU ADDR
	LB	R15,DP.SLT,R3		:DMA SLOT
	STH	R15,DMASLT
	L	R15,TPDULN
	SR	R15,R12
	ST	R15,RBCTPD		:DMA CONTROL - RBCTPD
	ST	R6,IBCDMA		:DMA CONTROL - IBCDMA
	ST	R6,RBCDMA		:DMA CONTROL - RBCDMA
	ST	R5,NFADMA		:DMA CONTROL - HFADMA
	JR	R11			:RETURN TO CALLER


:	JCOM START DISCARDING DATA
:	CHANGE JCOM STATE TO START DISCARDING DATA. CANCEL ANY DMA
:	REQUEST IN PROGRESS

SDDSAV	WS	1			:SAVE AREA
JCMSDD
	ST	R11,SDDSAV		:SAVE LINK
	LIS	R15,DSCRDD		:START DISCARDING DATA MSG'S
	STH	R15,JCSTAT		:IS NEW JCOM STATUS
	L	R15,RBCDMA		:IS DMA IN PROGRESS
	JER	R11			:RETURN TO CALLER IF NOT
	JAL	R10,DTSDAC		:DTS DMA COMPLETE
	JR	R11			:RETURN TO CALLER

:	SUBTTL	DTS UTILITY ROUTINES

:	PARRW - CHECK THAT THE ENTIRE PARAMETER BLOCK IS READ WRITE

PARRW
	LR	R5,R5			:CHECK MAC BIT
	JER	R10			:PARAMETER BLOCK ADDR IS PHYSICAL
	L	R12,F1ARG,,		:CALCULATE VIRTUAL ADDR OF LAST
	AHI	R12,11			:BYTE IN PARAMETER BLOCK
	JAL	R11,TTRW,,		:CHECK READ-WRITE ACCESS
	J	SVCE.1			:FAILED
	JR	R10			:RETURN OK

:	JQUNLK - UNLINK A DPB FROM THE JCOM OUTPUT QUEUE
:	R3	->	DPB

JQUNLK
	L	R15,DP.JCQ,R3		:GET NEXT DPB ON Q
	ST	R15,JCOUTQ		:PUT AT Q HEAD
	JNFS	JQNLK1			:SKIP IF THERE WAS ANOTHER DPB
	LA	R15,JCOUTQ		:OTHERWISE, FIX UP Q TAIL
	ST	R15,JCOQND
JQNLK1
	JR	R11			:RETURN TO CALLER

:	PDPBWQ - PUT A DPB ON A GU WAIT QUEUE
:	R9	->	GU
:	R3	->	DPB

PDPBWQ
	LIS	R15,0
	ST	R15,DP.DTQ,R3		:END OF Q MARK
	L	R15,GU.WTQ,R9		:ANYTHING ALREADY ON THE Q ?
	JNFS	PDPWQ1			:SKIP IF THERE IS
	ST	R3,GU.WTQ,R9		:PUT DPB AT HEAD OF Q
	JR	R11
PDPWQ1
	LR	R14,R15			:GET NEXT DPB ON Q
	L	R15,DP.DTQ,R14		:LAST ON Q ?
	JNBS	PDPWQ1			:TRY AGAIN IF NOT
	ST	R3,DP.DTQ,R14		:PUT DPB AT END OF Q
	JR	R11			:RETURN TO CALLER

:	PDPBOQ - PUT A DPB ON A GU OUTSTANDING QUEUE
:	R9	->	GU
:	R3	->	DPB

PDPBOQ
	LIS	R15,0
	ST	R15,DP.DTQ,R3		:END OF Q MARK
	L	R15,GU.OTQ,R9		:ANYTHING ALREADY ON THE Q?
	JNFS	PDPOQ1			:SKIP IF THERE IS
	ST	R3,GU.OTQ,R9		:PUT DPB AT HEAD OF Q
	JR	R11
PDPOQ1
	LR	R14,R15			:GET NEXT DPB ON Q
	L	R15,DP.DTQ,R14		:LAST ON Q ?
	JNBS	PDPOQ1			:TRY AGAIN IF NOT
	ST	R3,DP.DTQ,R14		:PUT DPB AT END OF Q
	JR	R11			:RETURN TO CALLER


:	DTSGET,JCMGET - PACK BYTES INTO A REGISTER
:	R15	-	BYTE START ADDR
:	R14	-	BYTE COUNT
:	R13	-	LINK
:	R14	=	RESULT ON EXIT

GETSAV	WS	4			:SAVE AREA
JCMGET
DTSGET
	STM	R12,GETSAV		:ALL REG'S UNCHANGED ON EXIT,EXCEPT R14
	LIS	R12,0			:PACK REG
GETSV1
	SLLS	R12,8			:MAKE ROOM FOR NEXT BYTE
	LB	R13,0,R15		:GET NEXT BYTE
	OR	R12,R13			:PACK IT
	AIS	R15,1			:POINT TO NEXT BYTE
	SIS	R14,1			:DEC COUNT
	JNBS	GETSV1			:FOR COUNT
	ST	R12,GETSAV+8		:RESULT IN R14
	LM	R12,GETSAV
	JR	R13			:RETURN TO CALLER

:	GUATON	-  GLOBAL UNIT ADDRESS TO NUMBER
:	R9	=	GU ADDR
:	R11	=	LINK
:	ON EXIT -
:	R15	=	GU NUMBER
:	R14	SMASHED

GUATON
	LA	R15,GUT			:GU TABLE BASE ADDRESS
	LR	R14,R9			:GU ADDR
	SR	R14,R15			:REL ADDR OF GU
	LHI	R15,GULEN		:GU ENTRY LENGTH
	DHR	R14,R15			:R15 = GU NUMBER
	JR	R11


HPATCH	HS	80			:SHARED DEVICE PATCH AREA

	FO	KCAREA
	FO	KERNEL

	EM
	BND	100			:FORCE TO A NICE BOUNDARY

	EI	(1-TSIDT)
	EI	(SHARE)

	SUBTTL	IDDT. . .ISIS DYNAMIC DEBUGGING TOOL

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other   purpose except as specifically authorized in  wri-  **
: **  ting by  TYMNET, Incorporated.                              **
: ******************************************************************

	MO	.,DDT
	LO	KERNEL

:	DDT - Command Handler

:		The debugger (DDT) is a reentrant user program that resides
:	outside the user's address space.  DDT accepts one character commands,
:	with arguments (see ISIS.DOC for a list of commands, and binary mode
:	operation).  "DDTBGN" is the starting point of DDT.  It sets up the
:	base registers for the user's data area (this is a private work
:	area for DDT...an extension of the DDT user block).  Some code is
:	stored in the user's data area to handle illegal instruction interrupts,
:	and to return control to the user's program.  The old PSW in the user's
:	data area is checked, if it is null the default status bits from the
:	KERNEL's user block for this user (these bits are used for determining
:	MAC on/off for accessing core in the user's space).  Lastly, a cell
:	in the user's data area is checked to see if the KERNEL requested a
:	message be sent to the user.
:		Breakpoints are implemented by storing an illegal instruction
:	op-code 0) in the user's address space.  When ever the user references
:	his address through DDT (eg, the R command) the breakpoints are all
:	undone, the reference made, and the breakpoints all restored.
:		To proceed from a breakpoint, a special breakpoint is set at
:	the very next instruction (if the instruction being processed is
:	a JUMP, a second special breakpoint is set at the jump destination),
:	the current breakpoint is undone, and control is given to that address.
:	when one of the special breakpoints is reached, both special breakpoints
:	are undone, the user's breakpoint is reinstated, and control returns
:	to the user.
:		The NEXT instruction uses the same special breakpoint mechanism,
:	except that control returns to the terminal after the special breakpoint
:	is reached.
:		Certain commands (such as H) require DDT manipulate KERNEL storage.
:		The code for DDT is followed by a patch area, and all the user
:	data areas.  Following that are all the KERNEL job blocks.


:	REGISTER ASSIGNMENTS

:	R8	POINTER TO DDT DATA SEGMENT
:	R9	LINK REGISTER
:	R10	FLAG FOR INPUT CHARACTER ALREADY READ IF = 2
:	R11	SPECIAL BREAKPOINT FLAG
:	R12	CURRENT ADDRESS
:	R15	END ADDRESS




:	DEFINE ELEMENTS FOR COMMAND BLOCK
C.STR	EQ	0			:RELATIVE POSITION OF STRING
C.LIC	EQ	C.STR+2			:RELATIVE POSITION OF COMMAND LICENCE REQUIREMENTS
C.HAND	EQ	C.LIC+2			:RELATIVE POSITION OF COMMAND HANDLER (JUMP)
C.LEN	EQ	C.HAND+4		:LENGTH OF COMMAND BLOCK

:	DEFINE MACRO TO GENERATE THIS COMMAND BLOCK
COMAND	MACRO(STR,LIC,ADDR)[
Q	BS	C.LIC-1;	AC	/STR/;	ORG	Q+C.LIC
	HC	LIC
	J	ADDR
]

:	....................................................................
:	DEFINE MACRO FOR QUERY TABLE
:	....................................................................
					:
QENTRY	MACRO(N,STR,LOC)[
	BND	2			:
	BS	4-N			:
	AC 	/STR/			:
	J	LOC			:
]					:
					:
:	....................................................................
:	DEFIND MACRO FOR ERROR MESSAGES
:	....................................................................
					:
ERROR	MACRO(N,STR)[			:
	BC	2,80,N			:
	SC	~STR~			:
]					:
					:

:	....................................................................
:	TABLE OF COMMANDS, LICENCES REQUIRED, AND TARGET ROUTINES.
:	....................................................................
					:
TTYLST	COMAND(\,0,ETST)		:CHECK CRASH CONDITIONS
	COMAND(?,0,QUERY)		:QUERY SET
	COMAND(Z,0,ZAPP)		:ZAP CIRCUIT
	COMAND(I,0,D.INIT)		:INITIALIZE DDT
	COMAND(C,0,CNVRT)		:CONVERT INPUT
	COMAND(^,0,TRANS)		:TRANSFER TO ANOTHER SLOT
	COMAND(R,L.SYP!L.SYR!L.S0P!L.S0R!L.P!L.H!L.L!L.R,DREAD)	:READ MEMORY
	COMAND(T,L.SYP!L.SYR!L.S0P!L.S0R!L.P!L.H!L.L!L.R,DT)	:TYPE CURRENT PSD
	COMAND(G,L.SYP!L.SYR!L.S0P!L.S0R!L.P!L.H!L.L!L.R,DGO)	:GO
	COMAND(P,L.SYP!L.SYR!L.S0P!L.S0R!L.P!L.H!L.L!L.R,DP)	:PROCEED
	COMAND(M,L.SYP!L.SYR!L.S0P!L.S0R!L.P!L.H!L.L!L.R,M)	:SET SEARCH MASK AND BOUNDS
	COMAND(X,L.SYP!L.SYR!L.S0P!L.S0R!L.P!L.H!L.L!L.R,XXX)	:DATA SEARCH
	COMAND(Y,L.SYP!L.SYR!L.S0P!L.S0R!L.P!L.H!L.L!L.R,D.Y)	:INSTRUCTION SEARCH
	COMAND(B,L.HALT!L.S0P!L.S0R!L.P!L.H!L.L,BREAK)	:SET UP BREAKPOINT
	COMAND(N,L.HALT!L.S0P!L.S0R!L.P!L.H!L.L,NEX)	:NEXT
	COMAND(A,L.HALT!L.S0P!L.P!L.H!L.L,ADDR)	:SET UP ADDRESS SPACE
  IF	SHARE
   IF	NDISC
	COMAND(K,L.HALT!L.S0P!L.P!L.H!L.L,KOM)	:TAKE COMMANDS FROM DISC
   EI  (NDISC)
   IF	NDISC!MSCDSK
	COMAND(L,L.HALT!L.S0P!L.P!L.H!L.L,LOAD)	:LOAD FROM DISC
	COMAND(S,L.S0P!L.P!L.H!L.L,SAVE)	:SAVE ON DISC
   EI  (NDISC!MSCDSK)
  EI   (SHARE)
	COMAND(E,L.HALT!L.S0P!L.P!L.H!L.L!L.E,EXEC)	:EXECUTE JOB
	COMAND(W,L.SYP!L.S0P!L.P!L.H!L.L,DWRITE)	:WRITE MEMORY
	COMAND(F,L.SYP!L.S0P!L.P!L.H!L.L!L.E,DF)	:ENABLE CONNECTION TO A SET OF KIO JOBS
	COMAND(H,L.SYP!L.S0P!L.P!L.H!L.E,DHALT)	:HALT JOB
	COMAND(V,L.SYP!L.S0P!L.P!L.H,DSPY)	:SPY ON MEMORY USAGE
	COMAND(U,L.SYP!L.S0P!L.P!L.H,DDT.U)	:CHANGE PSD BITS
	COMAND(J,0,SUS)			:SUSPEND A SLOT
	COMAND(Q,0,RSM)			:RESUME A  SUSPENDED SLOT
	COMAND(O,0,ONFRG)		:RE-ACTIVATE THE SLOT'S WATCH FROG TIMER
	COMAND(D,0,OFFFRG)		:DISABLE THE SLOT'S WATCH FROG TIMER	
NTTY	EQ	.-TTYLST		:LENGTH OF TABLE
					:
:	....................................................................
:	MESSAGE STRING AREA
:	....................................................................
					:
ETAB	WC	KER0			:NOT LOADED
	WC	KER1			:ILLEGAL SVC
	WC	KER2			:ILLEGAL OUT-SVC
	WC	KER3			:PARITY ERROR
	WC	KER4			:ILLEGAL MEMORY REFERENCE
	WC	KER5			:DISPATCHER CRASH
	WC	KER6			:ILLEGAL INSTRUCTION
	WC	KER7			:BAD MAC
	WC	KER8			:SVC
	WC	KER9			:DDT
	WC	KERA			:USER CRASH
	WC	KERB			:LOADED
	WC	KERC			:WATCH FROG TIMER
	WC	KERD			:OWNER DOWN
	WC	KERE			:SIO RING CRASH
ERSTR	HC	7F20			:BIT ON IF "restart- " NEEDED
EADDR	HC	4A00			:BIT ON IF TO PRINT MACLOC
					:
:	....................................................................
:	DIAGNOSTIC MESSAGES
:	....................................................................
	BC	01,81,00
TTERR	SC	/type '\'"8D"8A/	:
	BC	02,80,02		:
SPROMPT	SC	'"8D"8A*'		:"CRLF*";
	BC	02,80,03		:
TERR	SC	'illegal command"8D"8A'	:CR - 8D	LF - 8A;
	BC	02,80,04
XERR	SC	'illegal inst. at ';
	BC	02,80,05
XMSG	SC	'>>breakpoint ';
	BC	02,80,06
GMSG	SC	'address out of range"8D"8A';
	BC	02,80,07
BPERR	SC	'breakpoint number out of range"8D"8A';
	BC	02,80,08
PRERR	SC	'no breakpoint to proceed from"8D"8A';
	BC	02,80,09
VMSG1	SC	'memory out of bounds"8D"8A';
	BC	02,80,0A
VMSG2	SC	'ill. reg. number"8D"8A';
   IF	SHARE
    IF	NDISC!MSCDSK
	BC	02,80,0B
LERR	SC	'disc error '
    EI(NDISC!MSCDSK)
   EI (SHARE)
	BC	02,80,0C
BADNUM	SC	'invalid number"8D"8A';
	BC	02,80,0D
XERR1	SC	'incorrect bounds"8D"8A';
	BC	02,80,0E
XERR2	SC	'bad search length"8D"8A';
	BC	02,80,0F
XERR3	SC	'bad search boundary"8D"8A';
	BC	02,80,10
KER1	SC	'ill SVC executed at ';
	BC	02,80,11
KER2	SC	'ill mem ref by out-SVC"8D"8A'
	BC	02,80,12
KER3	SC	/parity error"8D"8A/;
	BC	02,80,13
KER4	SC	'ill mem ref at ';
	BC	02,80,14
ZAPMSG	SC	' Logging off (Y"2FN)? ';
	BC	02,80,15
PERR1	SC	'jump out of bounds"8A"8D';
	BC	2,80,16
SCONCT	SC	'slot already connected"8D"8A';
	BC	02,80,17
KER6	SC	'ill instr at '
	BC	2,80,18
BXERR	SC	'breakpoint already exists there"8D"8A';
	BC	2,80,19
KER5	SC	/dispatcher crash"8D"8A/
	BC	02,80,1A
DSERR1	SC	/"8D"8ABad 'M' arguments/;
	BC	02,80,1B
DSERR2	SC	/"8D"8AWe already have use of SPY...aborting/;
	BC	02,80,1C
DSERR3	SC	/"8D"8A...aborting/;
	BC	02,80,1D
BADLIC	SC	/"8D"8Ainsufficient license"8D"8A/;
	BC	02,80,1E
FRZMS	SC	/frozen- /;
	BC	02,80,1F
BADMAC	SC	/"8D"8AMAC not set up correctly /
	BC	02,80,20
COREXC	SC	'"8D"8AABORTING--available space exceeded';
	IF	SHARE;	IF	NDISC!MSCDSK
	BC	02,80,21
SSERR	SC	'disc area save protected"8D"8A';	EI	(NDISC!MSCDSK);	EI	(SHARE);
	BC	02,80,22
HLTMS	SC	/halted- /
	BC	02,80,23
SUSPMS	SC	/ suspended/
	BC	02,80,24
KER7	SC	/bad MAC set up/
	BC	02,80,25
KER8	SC	/SVC/
	BC	02,80,26
KER9	SC	/DDT/
	BC	02,80,27
KER0	SC	/not loaded/
	BC	02,80,28
KERA	SC	/slot initiated/
	BC	02,80,29
KERB	SC	/ loaded/
	BC	02,80,2A
CRSHMS	SC	/crashed- /
	BC	02,80,2B
RSTRMS	SC	/restart- /
	BC	02,80,2C
SLOTMS	SC	/"8D"8ASlot /
	BC	02,80,2D
SUSPWN	SC	/"8D"8ASlot suspended/
	BC	02,80,2E
KERC	SC	/watchfrog timeout/
	BC	02,80,2F
KERD	SC	/owner down/
	BC	02,80,30
XPIWMS	SC	/waiting for XPI response- /
	BC	02,80,31
KERE	SC	/sio ring crash/
AGAIN	SC	/Are you sure (Y"2FN)? /
	BS	02,80,32
dsdash	sc	/disable auto slot halt? (Y"2FN)? /
	bs	02,80,33
esdash	sc	/enable auto slot halt? (Y"2FN)? /
	bs	02,80,34
RUNMS	SC	/ running: /
AMPSND	SC	/ &/
DWNMS	SC	/ down: /
COLMS	SC	/: /
SYSID	SC	/"8D"8A /
SYSPRO	SC	/"8D"8A<<< ISIS System Configuration Profile >>>"8D"8A/
MEM00	SC	/"8D"8AThe current system is configurated with /
MEM01	SC	/"8D"8AThe current system actually has /
MEM02	SC	/dK bytes memory/
CPUID	SC	/"8D"8ACPU version /
MACID	SC	/"8D"8AMAC version /
TYMENG	SC	/"8D"8ACommunication Processor - Tymnet Engine /
MINENG	SC	/"8D"8ACommunication Processor - Tymnet Mini Engine /
MICENG	SC	/"8D"8ACommunication Processor - Tymnet Micro Engine/
TSIENG	SC	/"8D"8ACommunication Processor - Tymnet TSI Engine /
PICENG	SC	/"8D"8ACommunication Processor - Tymnet PICO Engine /
HDLENG	SC	/"8D"8ACommunication Processor - Tymnet HDLC Micro Engine /
PXLENG	SC	/"8D"8ACommunication Processor - Tymnet PXL Micro Engine /
ddttmp	ws	10

					:
	SUBTTL	SPY DRIVER FOR DDT
:	....................................................................
:	EXPECTS PSD IN R0-R1
:	LINK IN R3
:	....................................................................
					:
SPY	LR	R4,R1			:COPY ADDRESS INTERRUPTED FROM
	THI	R0,400			:IS USER UNDER MAC?
	JE	SPY0			:SKIP IF NOT
	EXHR	R5,R4			:SEGMENT TO TRANSLATE
	NHI	R5,0F			:
	SLLS	R5,2			:ISOLATE "SN" AND SET UP TO INDEX WORD TABLE
	A	R5,USER,,		:GET ADDRESS OF USER BLOCK
	L	R5,MPROT,R5		:GET MAC REGISTER
	NI	R4,SEGSIZ-1		:REMOVE "SN"
	NI	R5,MMASKR		:ISOLATE "SRF"
	SRLS	R5,MSHFTA		:MAKE ADDRESS
	AR	R4,R5			:COMPUTE ABSOLUTE ADDRESS
SPY0	S	R4,SPYSAD		:CHECK AGAINST START ADDRESS
	JLR	R3			:BELOW RANGE...ABORT
	CL	R4,SPYRNG		:RANGE CHECK
	JGER	R3			:EXIT IF OUT OF RANGE
	DH	R4,SPYWTH		:ELSE COMPUTE BIN NUMBER
	L	R4,SPYTAB		:GET START OF SPY TABLE
	AR	R5,R5			:MAKE HALF-WORD ADDRESS
	LIS	R2,1			:
	AHM	R2,0,R4,R5		:TICK BIN COUNTER
	JNR	R3			:RETURN IF SUCCESSFUL
	LCS	R2,1			:ELSE CANCEL IT AND CLEAN UP
	AHM	R2,0,R4,R5		:
	ST	R2,SPYFLAG		:CLEAR FLAG SO WE STOP REFERENCES
        L       R5,SPYFLC               :FLAG USER
        STH     R2,0,R5			:
	JR	R3			:AND THEN EXIT
					:
:	....................................................................
:	DATA AREA FOR DDT SPY DRIVER
:	....................................................................
					:
SPYTAB	HS	2			:POINTER TO TABLE TO INCREMENT
SPYSAD	HS	2			:SPY ABSOLUTE START ADDRESS
SPYRNG	HS	2			:SPY RANGE (NUMBER OF BYTES)
SPYWTH	HS	1			:SPY BIN WIDTH (BYTES)
SPYFLC  HS      2                       :FLAG TO TELL USER WE STOPPED
					:

	SUBTTL	****	D D T   E N T R Y   P O I N T	****

:	....................................................................
:	DDT Entry Point - CODE INITIALLY SETS UP THE R8 REGISTER FOR THIS
:	USER'S DATA SEGMENT.
:	....................................................................
					:
LOWDDT	EQ	.			:*** START OF INTERRUPTABLE CODE ***
DDTBGN	L	R8,USER,,		:LOAD R8 REG FROM KERNEL-SET LOCATION
	LHI	R14,E.PSW!I.ENA		:PSW FOR ENTRY TO DDT AT BREAKPOINT
	LA	R15,XX,R8		:ADDR OF CODE TO SWAP REGISTERS
	STM	R14,NEWPSW,R8		:
	LIS	R10,0			:CLEAR INPUT BUFFER PTR
	L	R1,OLDPSW,R8		:CHECK FOR NULL OLD PSW
	JNFS	ETST			:NOT NULL
	LHL	R0,CPSW,R8		:STATUS BITS TO USE FOR INST "G"
	ST	R0,OLDPSW,R8		:SET STATUS BITS IN OLD PSW
					:
:	....................................................................
:	PRINT SLOT STATUS
:	....................................................................
					:
ETST	LA	R1,SLOTMS		:PRINT "Slot "
	JAL	R9,OOUT			:
	LH	R0,SLOT,R8		:PRINT SLOT NUMBER
	LIS	R1,2			:
	JAL	R9,ACONV		:
	LHL	R2,EFLAG,R8		:GET ERROR CODE
	LH	R0,SLOT,R8		:
	JL	TTY			:
   IF	KSYS				:
	CLHI	R0,NSLOT+1		:SUP SLAVE?
	JLEFS	ETST00			:
	TBT	R0,STSAVE		:SEE IF LOADED
	JEFS	ETST00			:
	LHI	R2,0B^2			:
	STH	R2,EFLAG,R8		:FAKE IT INTO BEING LOADED
ETST00					:
   EI  (FSYS)				:
	CLHI	R2,0B^2			:
	JE	ETST60			:
	TBT	R0,SSSLOT		:SEE IF SUSPENDED
	JEFS	ETST10			:
	LA	R1,SUSPMS		:PRINT " suspended"
	JAL	R9,OOUT			:
	LCS	R2,1			:INDICATE SUSPENDED
					:
ETST10	TBT	R0,RNSLOT		:SEE IF RUNNING
	JNFS	ETST20			:BR IF SHOULD BE
	LA	R3,CRSHMS		:SET "crashed- "
	LH	R0,EFLAG,R8		:SEE IF CRASHED OR HALTED
	JL	ETST30			:BR IF CRASHED
	LA	R3,HLTMS		:SET "halted- "
	J	ETST30			:
ETST20	LA	R3,FRZMS		:SET "frozen- "
	L	R4,CONTROL,R8		:
	LHL	R0,WFLAG,R4		:SEE IF FROZEN
	THI	R0,FREEZE
	JN	ETST30			:BR IF SO
   IF	MXP				:
	LA	R3,XPIWMS		:SET "waiting for XPI response- "
	THI	R0,XPIWF		:SEE IF WAITING
	JN	ETST30			:BR IF SO
   EI  (MXP)				:
	LR	R2,R2			:SEE IF SUSPENDED
	JGEFS	ETST25			:BR IF NOT
	LA	R1,COLMS		:PRINT ": "
	JAL	R9,MOUT			:
	J	ETST60			:
ETST25	LA	R3,RUNMS		:SET " running: "
	SRLS	R2,2			:
	TBT	R2,ERSTR		:SEE IF RESTARTED
	JEFS	ETST50			:BR IF NOT
	LR	R1,R3			:
	LA	R3,RSTRMS		:SET "restart- "
	JFS	ETST45			:
ETST30	LR	R2,R2			:SEE IF SUSPENDED
	JGEFS	ETST40			:BR IF NOT
	LA	R1,AMPSND		:PRINT " &"
	JAL	R9,MOUT
ETST40	LA	R1,DWNMS		:PRINT " down: "
ETST45	JAL	R9,MOUT
ETST50	LB	R2,EFLAG+1,R8		:SEE IF LOADED
	JEFS	ETST60			:BR IF NOT
	LR	R1,R3
	JAL	R9,OOUT			:PRINT CURRENT STATE

ETST60	LB	R2,EFLAG+1,R8		:GET REASON CODE
	L	R1,ETAB,R2		:ADDR OF APPROPRIATE MSG
	JAL	R9,OOUT			:ISSUE ERROR MSG

	SRLS	R2,2
	TBT	R2,EADDR		:SEE IF TO PRINT AN ADDRESS
	JEFS	TTY			:NO, DONE
	L	R0,MACLOC,R8
	LIS	R1,6			:6 DIGITS
	JAL	R9,ACONV		:
	JFS	TTY			:SKIP TO GET COMMAND
					:

	SUBTTL	COMMAND SCANNER, VERIFIER, AND BITCHER

:	....................................................................
:	COMMAND INPUT HANDLER
:	....................................................................
					:
TTYDOIT	JAL	R9,TTYLST+C.HAND,R1	:GO SERVICE THIS COMMAND

:	NEXT COMMAND
TTY					:
:	....................................................................
:	SET MACTRN FOR DDT TO MPROT AND INSURE THAT THE MAC IS OFF
:	....................................................................
					:
        LHI     R3,E.PSW		:
        EPSR    R1,R3                   :THIS INSURES THAT THE MAC IS OFF
        LA      R3,MPROT+MACDIS,R8      :SET TO MPROT
        ST      R3,MACTRN,R8            :DO IT TO MACTRN
        SVC     DISMIS                  :LET THINGS GET STAIGHT
					:
	LIS	R3,0			:SET ACCUMULATOR = 0
	STH	R3,FLAG,R8		:CLEAR ^C FLAG
	LA	R1,SPROMPT		:ISSUE PROMPT, GET INPUT CHAR
	JAL	R9,OOUT			:
	JAL	R9,GETCMD		:
	JFS	TTY2			:AND SKIP
TTY1	JAL	R2,GETCHAR		:GET ANOTHER CHARACTER
	NOP	0			:DON'T CARE ABOUT SKIP RETURNS
TTY2	JAL	R1,CUC			:CONVERT CHAR TO UPPER CASE
	JAL	R2,ZDLIM		:CHECK FOR DELIMITER
	J	TTY3			:GOT ONE...SKIP TO PROCESS
	SLLS	R3,8			:NO...ACCUMULATE CHARS
	STBR	R0,R3
:::	JBS	TTY1			:AND GET ANOTHER CHAR
TTY3	LHI	R1,NTTY-8		:SEARCH FOR STRING MATCH
TTY4	CH	R3,TTYLST+C.STR,R1
	JEFS	TTY5			:SKIP IF FIND A MATCH
	SIS	R1,8			:ELSE CONTINUE SCAN
	JGEBS	TTY4
	J	TTYERR			:ABORT IF NO MATCH FOUND
TTY5	LH	R2,TTYLST+C.LIC,R1	:CHECK LICENCES REQUIRED FOR COMMAND
	JE	TTYDOIT			:NONE REQUIRED, SO JUST DO IT
	LR	R4,R2			:COMMAND REQUIRES LICENCES...DOES SLOT?
	NH	R2,SLICEN,R8
	JE	TTYDOIT			:NONE REQUIRED BY SLOT, SO JUST DO IT
	NH	R2,ULICEN,R8		:LICENCE REQUIRED...DOES USER HAVE ANY REQUISIT?
	JE	LICERR			:NO...ERROR
	THI	R4,L.HALT		:YES...DOES COMMAND REQUIRE SLOT BE HALTED?
	JE	TTYDOIT			:NO...SERVICE COMMAND
	THI	R4,L.SYP!L.S0P!L.P	:YES...LET HIM DO IT ANYWAY,
	JN	TTYDOIT			:...IF HE HAS PATCH LICENSE
	LHL	R0,SLOT,R8		:YES...GET SLOT #
	SVC	KIO,9			:TEST IF SLOT ACTIVE
	J	TTYDOIT			:NO...SERVICE COMMAND
	LA	R1,SCONCT		:YES..."ALREADY CONNECTED"
	JFS	BITCH			:

LICERR	LA	R1,BADLIC		:BAD LICENCE
	JFS	BITCH			:
TTYERR	LA	R1,TERR			:"ILLEGAL COMMAND"
BITCH	JAL	R9,OOUT			:ISSUE DIAGNOSTIC
	IF	SHARE
	IF	NDISC!MSCDSK
	LCS	R0,1
	LHL	R2,BUFNO,R8
	STH	R0,DPUN,R2,R2		:FLAG COMMANDS ABORT
	EI	(NDISC!MSCDSK)
	EI	(SHARE)
	LA	R1,TTERR
	JAL	R9,OOUT			:TELL USER TO TYPE FLUSH CHAR
	LH	R0,MODE,R8		:CHECK MODE
	JEFS	BITCH2			:ASCII FLUSH
BITCH1	JAL	R2,GETCHAR		:READ NEXT BYTE
	NOP	0			:DON'T CARE ABOUT SKIP RETURN DISTINCTION
	JBS	BITCH1			:
BITCH2	JAL	R9,CHARM		:FLUSH INPUT
	CLHI	R0,0DC			:READ UNTIL "\" IS FOUND
	JNBS	BITCH2			:
	J	ETST			:THEN EXIT VIA DIAGNOSTIC CHECK
					:

	SUBTTL	TRAP HANDLING AND INDIVIDUAL COMMANDS

:	....................................................................
:	THE FOLLOWING HANDLES ILLEGAL INSTRUCTION TRAPS
:	....................................................................
					:
TRAP	L	R8,USER,,		:*0*ADDRESS OF DATA SEG FROM MONITOR
	STM	0E,OLDPSW,R8		:*0*STORE OLD PSW
	LPSW	NEWPSW,R8		:*0*LOAD PSW FROM DATA SEG
					:
XDDT	ST	R9,SLINK,R8		:SAVE LINK
	LR	R4,R13			:SAVE LAST BP #
	SLLS	R4,2			:POINT INTO ADDR TABLE
	LH	R0,FLAG,R8		:CHECK IF USER TYPED BREAK CHAR
	JE	XDDTO			:HE DID NOT - CHECK IF BP OR ILL INST
	LHL	R0,TERCAR,R8		:WHATS HIS TERMINAL?
	JEFS	.+6			:SKIP IF AUXILIARY
	SVC	KIO,3			:ELSE ECHO ON
	LIS	R0,0			:YES...CLEANUP AFTER QUIT CHARACTER
	STH	R0,FLAG,R8		:CLEAR FLAG
	LCS	R13,2			:REMEMBER USER PROG STOPPED FOR BREAK CHAR
	LR	R11,R11			:IF SPECIAL BP'S SET - REMOVE THEM
	JER	R9			:NO SPCIAL BP'S, RETURN
	LIS	R11,0			:CLEAR SPECIAL BP FLAG
	LIS	R14,BPNO		:CLEAR FIRST SPECIAL BP
	JAL	R9,RBK			:
	LIS	R14,BPNO+1		:CLEAR SECOND SPECIAL BP
	JAL	R9,RBK			:
					:
:	....................................................................
:	RESTORE BREAKPOINT
:	....................................................................
					:
	LR	R4,R4			:
	JL	LX4			:NO PREVIOUS BPT
	L	R0,LISTA,R8,R4		:USER ADDR OF BP
	LIS	R15,5			:POSITION OF MAC BIT IN SPSW
	TBT	R15,SPSW,R8		:IS MAC BEING USED
	JEFS	LX0			:NO
	JAL	R9,TRASL,,		:TRANSLATE TO PHYSICAL ADDR
	J	BMAC			:
LX0	LR	R15,R0			:PHYSICAL ADDR
	LIS	R2,0			:
	STB	R2,0,R15		:SET OPCODE TO ZERO
	J	LX4			:RESTORE LINK AND RETURN
XDDTO	L	R0,OLDPSW+4,R8		:GET ADDR OF ILL INST
	LR	R11,R11			:WAS THIS A SPECIAL BP?
	JN	LX1			:YES - BRANCH
	LHI	R13,BPNO*4		:SET UP FOR SEARCH OF LISTA
LX2	CL	R0,LISTA-4,R8,R13	:
	JE	LX3			:FOUND IT
	SIS	R13,4			:
	JNBS	LX2			:LOOP
LX6	LCS	R13,1			:NOT FOUND, THIS IS AN ILLEGAL INST
	LM	R14,OLDPSW,R8		:SAVE USER PSW FOR KRASH
	STM	R14,RPSW,R8		:
	LM	R0,URSA,R8		:RESTORE USER REGS
	J	ILLIND,,		:GO KRASH DDT JOB
					:
LX3	LHL	R0,TERCAR,R8		:WHATS HIS TERMINAL?
	JEFS	.+6			:SKIP IF AUXILIARY
	SVC	KIO,3			:ELSE ECHO ON
	SIS	R13,4			:INDEX IS OFF BY 4 - CORRECT
	SRLS	R13,2			:GET BP NUMBER
	lis	r1,1			:store context ***ern
	stb	r1,xflgx,r8		:store context
	stb	r13,xflgx+1,r8		:store bp#
	LA	R1,XMSG
	JAL	R9,OOUT			:GIVE MESSAGE ABOUT BP
	LR	R0,R13			:PRINT BP NUMBER
	LIS	R1,2			:TWO DIGITS
	JAL	R9,ACONV
	JAL	R9,DOCRLF		:TERMINATE LINE WITH CR|LF
LX4	L	R9,SLINK,R8		:RESTORE LINK
	JR	R9			:RETURN
LX1	CL	R0,(BPNO*4)+LISTA,R8	:IS IT SPECIAL BP 1
	JEFS	LX5			:YES
	CL	R0,(BPNO+1)*4+LISTA,R8  :IS IT SPECIAL BP 2
	JEFS	LX5			:YES
	LCS	R13,1			:INDICATE A USER ILLEGAL INST.
LX5	LIS	R14,BPNO+1		:REMOVE SECOND SPECIAL BP
	JAL	R9,RBK
	LIS	R14,BPNO		:REMOVE FIRST SPECIAL BP
	JAL	R9,RBK
:	RESTORE BREAKPOINT
	LR	R4,R4
	JL	LX8			:NO PREVIOUS BPT
	L	R0,LISTA,R8,R4		:USER ADDR OF BP
	LIS	R15,5			:POSITION OF MAC BIT IN SPSW
	TBT	R15,SPSW,R8		:IS MAC BEING USED
	JEFS	LX7			:NO
	JAL	R9,TRASL,,		:TRANSLATE TO PHYSICAL ADDR
	 J	BMAC
LX7	LR	R15,R0			:PHYSICAL ADDR
	LIS	R2,0
	STB	R2,0,R15		:SET OPCODE TO ZERO
LX8	CLHI	R13,-1			:WAS THIS ILL INST?
	JEFS	LX9			:YES
	LHL	R0,TERCAR,R8		:WHATS HIS TERMINAL?
	JEFS	.+6			:SKIP IF AUXILIARY
	SVC	KIO,3			:ELSE ECHO ON
	LR	R11,R11			:TEST FOR "NEXT" IN PROGRESS
	JL	LX10			:BREAK ("NEXT")
	LIS	R11,0			:RESET SPECIAL BP FLAG
	L	R9,SLINK,R8		:RESTORE LINK
	J	YY,R8			:RETURN TO USER PROGRAM
					:
:	.......................................................................
:	WAS ILL INST AT LAST BP
:	.......................................................................
					:
LX9	LIS	R11,0			:CLEAR FLAG
	LR	R4,R4			:
	JLFS	LX12			:NO PREVIOUS BPT
	L	R0,LISTA,R8,R4		:ADDR OF LAST BP
	CL	R0,OLDPSW+4,R8		:IS IT SAME AS ILL INST ADDR
	JE	LX6			:YES - ISSUE ILL INST MSG
LX12	J	XDDTO			:CHECK IF BP AFTER INTERRUPT
					:
:	.......................................................................
:	"NEXT" COMMAND - BREAK AND PRINT MESSAGE
:	.......................................................................
					:
LX10	LIS	R1,6			:
	L	R0,OLDPSW+4,R8		:PRINT ADDRESS
	JAL	R9,ACONV		:
	LA	R1,XMSG			:SAME MESSAGE AS FOR BP
	JAL	R9,OOUT			:
	JAL	R9,DOCRLF		:TERMINATE OUTPUT WITH CR|LF
	J	LX4			:RETURN TO COMMAND LEVEL
					:
:	.......................................................................
:		Command N	(Next)
:		=========
:	.......................................................................
					:
NEX	LCS	R11,1			:INDICATE "NEXT" IN PROGRESS
	J	P1			:USES SAME CODE AS PROCEED COMMAND
					:
:	.......................................................................
:		Command P	(Proceed from breakpoint)
:		=========
:	.......................................................................
					:
DP	lb	r11,xflgx,r8		:is this a breakpoint? ***ern
	jnfs	dp0			:process breakpoint
	la	r1,prerr		:no breakpoint to proceed from!
	j	bitch			:
dp0	lis	r11,0			:
	stb	r11,xflgx,r8		:clear context
	CLHI	R13,-2			:DID USER STOP DUE TO BREAK CHAR
	JE	YY,R8			:YES - RETURN TO USER CODE
	LIS	R11,1			:INDICATE "P" IN PROGRESS
P1	CLHI	R13,-1			:R13 = -1 OR -2 IS ERROR
	JGFS	P2			:
	LA	R1,PRERR		:
	J	BITCH			:OUTPUT ERROR MESSAGE
P2	ST	R11,TEMP,R8		:SAVE SPECIAL BP FLAG (CLOBBERED BY TEX)
	lb	r13,xflgx+1,r8		:get breakpoint # ***ern
	LR	R4,R13			:NUMBER OF LAST BP ENCOUNTERED
	SLLS	R4,2			:INDEX INTO ADDRESS LIST (LISTA)
	L	R0,OLDPSW+4,R8		:GET USER ADDRESS
	ST	R9,SLINK,R8		:SAVE RETURN LINK
	LR	R7,R0			:SAVE ADDR
	LHL	R6,SPSW,R8		:GET STATUS BITS FROM SPSW
	NHI	R6,400			:ISOLATE MAC BIT
	JEFS	P3			:NOT RUNNING UNDER MAC
	JAL	R9,TRASL,,		:TRANSLATE TO PHYSICAL ADDR
	J	BMAC
P3	LR	R15,R0			:R15 NOW HAS REAL ADDRESS
	CL	R7,LISTA,R8,R4		:DID USER STOP AT BP?
	JNFS	P4			:NO
	LB	R12,LISTO,R8,R13	:YES, RESTORE BP INSTR
	STB	R12,0,R15
	JFS	P5
P4	LB	R12,0,R15		:GET OPCODE FROM USER ADDRESS
P5	LR	R4,R0			:SAVE REAL ADDR
	JAL	R9,BLEN			: GET LENGTH OF INSTRUCTION
	LR	R5,R0			:SAVE INSTRUCTION LENGTH
	AR	R15,R0			:ADD TO GET NEXT INSTR ADDRESS
	AR	R7,R0			:DO BOTH REAL AND VIRTUAL ADDRESSES
	LR	R0,R7
	LR	R6,R6			:IS MAC IN USE?
	JEFS	P5A			:NO...SKIP
	JAL	R9,TEX
	J	PERR			:NO ACCESS
P5A	LIS	R14,BPNO		:SET FIRST SPECIAL BP
	JAL	R9,SBK
	LH	R1,0,R4			:CHECK IF LAST OPCODE IS BRANCH
	LB	R12,0,R4		:COPY OPCODE
	NHI	R1,0FFF0		:IGNORE R2 FIELD
	CLHI	R1,4200			:TEST FOR NO-OP
	JE	PNOGO			:NO ADDRESS CHECK IF SO
	CLHI	R12,0E1			:TEST FOR SVC
	JNFS	P6			:SKIP IF NOT
	AIS	R15,4			:INCR REAL ADDR
	AIS	R7,4			:INCR USER ADDR
	LR	R0,R7
	LR	R6,R6			:IS MAC IN USE?
	JE	PBRBP			:NO...SKIP
	JAL	R9,TEX
	J	PERR			:NO ACCESS
	J	PBRBP			:ELSE SET SECOND BREAKPOINT
P6	LHI	R1,BRLEN-1		:INDEX OF LAST ENTRY IN BRANCH OP-CODE LIST
PBINS	CLB	R12,BR,R1		:IS ENTRY EQUAL TO OPCODE OF OLD BP?
	JE	PGO			:THIS IS BRANCH OPCODE
	SIS	R1,1			:NO..CONTINUE
	JGEBS	PBINS
	CLHI	R12,0C2			:IS OP CODE LPSW
	JNFS	PNGO			:NO
	SR	R15,R5			:OPCODE IS LPSW--GET ITS ADDR
	SR	R7,R5			:SAME FOR USER ADDR
	JAL	R9,PRXBR		:GET ADDR IN INST (PUT IN R0)
	LR	R15,R0
	L	R15,4,R15		:ADDR IN NEW PSW
	J	PBRBP			:PROCEED AS IF BRANCH
PNGO	CLHI	R12,18			:IS OP CODE LPSWR
	JN	PNOGO			:NO - RETURN TO USER CODE
	LIS	R2,1			:INDICATE LPSWR
	JFS	PGOA			:TREAT AS R BRANCH

PGO	LH	R2,0,R4			:THIS IS A BRANCH...IS IT NO-OP?
	XHI	R2,4200			:(NO-OP WITH INVALID ADDRESS IS OK...
	THI	R2,0FFF0		: SO TREAT IT AS A NON-BRANCH)
	JE	PNOGO			:
	LIS	R2,0			:ELSE INDICATE THIS IS BRANCH, NOT LPSWR
PGOA	SR	R15,R5			:OPCODE IS A BRANCH - GET ITS ADDRESS
	SR	R7,R5			:SAME FOR USER ADDR
	CLHI	R12,41			:IF R12 >= 41 THEN RX TYPE BRANCH
	JGE	PRXB			:
	LIS	R1,0F			:RR OR SF BRANCH
	NH	R1,0,R15		:EXTRACT REGISTER NUMBER OR DISPLACEMENT
	CLHI	R12,20			:IF R12 >= 20 THEN SF TYPE BRANCH
	JGE	PSFB			:
	AR	R1,R2			:RR...ADD 0 IF BRANCH, 1 IF LPSWR
	SLLS	R1,2			:MAKE INDEX INTO REGISTER SAVE AREA
	L	R7,URSA,R8,R1		:FETCH REGISTER CONTENTS FROM SAVE AREA
	LR	R0,R7			:USER ADDR
	LR	R6,R6			:IS USER RUNNING UNDER MAC
	JEFS	P7			:NO
	JAL	R9,TEX			:TEST FOR EXECUTE ACCESS
	J	PERR			:NO ACCESS - ERROR
	JAL	R9,TRASL,,		:TRANSLATE TO PHYSICAL ADDR
	J	BMAC			:
P7	LR	R15,R0			:SAVE PHYSICAL ADDR
	J	PBRBP			:SET A SPECIAL BP AT THIS ADDRESS
PSFB	AR	R1,R1			:SF...CONVERT HALFWORD COUNT TO BYTES
	THI	R12,1			:EVEN OP-CODE IS BACKWARD BRANCH
	JNFS	PSFB0			:
	SR	R15,R1			:ADDRESS OF BACKWARD BRANCH
	SR	R7,R1			:DITTO FOR USER ADDR
	JFS	PSFB1			:CHECK IF MAC IS IN USE
PSFB0	AR	R15,R1			:ADDRESS OF FORWARD BRANCH
	AR	R7,R1			:DITTO FOR USER ADDR
PSFB1	LR	R6,R6			:IS MAC BEING USED
	JE	PBRBP			:NO
	LR	R0,R7			:USER ADDR
	JAL	R9,TEX			:CHECK EXECUTE ACCESS
	J	PERR			:NO ACCESS
	J	PBRBP			:SET A SPECIAL BP AT THIS ADDRESS
PRXB	JAL	R9,PRXBR		:RX...PUT ADDR OF BRANCH IN R0
	LR	R7,R0			:PUT USER BRANCH ADDR IN R7 FOR SETTING BP
	LR	R6,R6			:IS MAC BEING USED
	JEFS	P8			:NO
	JAL	R9,TEX			:TEST EXECUTE ACCESS
	J	PERR			:NO ACCESS
	JAL	R9,TRASL,,		:TRANSLATE TO PHYSICAL ADDR
	J	BMAC			:
P8	LR	R15,R0			:SAVE PHYSICAL ADDR
PBRBP	LIS	R14,BPNO+1		:SET SPECIAL BP #2
	JAL	R9,SBK			:
PNOGO	L	R11,TEMP,R8		:RESTORE SPECIAL BP INDICATOR
	L	R9,SLINK,R8		:RESTORE LINK
	J	YY,R8			:BRANCH TO USER'S CODE
					:
:	.......................................................................
:	CALCULATE VIRTUAL ADDRESS FOR BRANCH AND RETURN IN R0
:	EXPECTS R5 = INSTRUCTION LENGTH
:		R15 = OPCODE ADDRESS
:		R7 = VIRTUAL ADDRESS OF OPCODE
:	.......................................................................
					:
PRXBR	LBR	R0,R5			:THIS IS RX TYPE - GET LENGTH
	SIS	R0,6			:IS IT RX3
	JE	PRX3			:
	LH	R0,2,R15		:FETCH DISPLACEMENT OF RX1 OR RX2
	JGEFS	PRXBR1			:IF SIGN BIT 0 THEN RX1 GO ADD X2 TO ADDR
	SLL	R0,11			:REMOVE FLAG BIT OF RX2
	SRA	R0,11			:EXTEND SIGN BIT
	AHI	R0,4,R7			:ADDR = ADDR+DISPL.+4, SINCE RX2 REQUIRES INCR. PC.
PRXBR1	LIS	R1,0F			:SET X2 MASK
	NH	R1,0,R15		:1ST HALFWORD OF INST TO GET X2 OR FX2
	JER	R9			:NO INDEXING IF X2 OF FX2 = 0
	J	PRX3B			:ELSE SKIP TO COMPUTE INDEXED ADDRESS
PRX3	LH	R2,2,R15		:RX3 FLAGS, SX2, HIGH ORDER ADDR BITS
	LBR	R0,R2			:COPY 4 HIGH BITS OF ADDRESS
	EXHR	R0,R0			:SHIFT INTO HIGH ORDER POSITIONS
	LHL	R1,4,R15		:FETCH LOWORDER BITS OF A2
	AR	R0,R1			:GET WHOLE A2 IN R0
	LIS	R1,0F			:SET INDEX MASK
	NH	R1,0,R15		:FIRST HALF WORD OF INST...IS THERE INDEXING?
	JEFS	PRX3C			:ALLOW INDEXING WITHOUT 1ST LEVEL
	NHI	R2,0F00			:ISOLATE SX2
	JEFS	PRX3B			:NO INDEXING IF SX2 = 0
	SRLS	R2,6			:GET REGISTER NUMBER TIMES 4
	A	R0,URSA,R8,R2		:ADD REG VALUE FROM SAVE AREA
PRX3B	SLLS	R1,2			:GET REGISTER NUMBER TIMES 4
	A	R0,URSA,R8,R1		:ADD REG VALUE FROM SAVE AREA
	JR	R9			:RETURN
PRX3C	NHI	R2,0F00
	JER	R9
	SRLS	R2,6
	A	R0,URSA,R8,R2
	JR	R9

PERR	LIS	R14,BPNO		:REMOVE SPECIAL BP
	JAL	R9,RBK
	LIS	R11,0			:TURN OFF SPECIAL BP FLAG
	LA	R1,PERR1		:ISSUE ERROR MSG
	JAL	R9,OOUT
	L	R9,SLINK,R8		:RESTORE LINK
	JR	R9			:RETURN
					:
:	.......................................................................
:	THE FOLLOWING CODE IS USED BY "P" TO DETERMINE THE LENGTH
:	OF THE INST AT R15
:	.......................................................................
					:
BLEN	LIS	R0,2			:FIND LENGTH OF INST AT BP - ASSUME 2 BYTES
	LB	R1,0,R15		:FETCH OPCODE
	THI	R1,40			:THIS BIT ON MEANS RX OR RI FORMAT
	JER	R9			:STORE LENGTH OF 2 BYTES
	LIS	R0,6			:ASSUME LENGTH OF 6 BYTES
	CLHI	R1,0F0			:CHECK FOR RI2
	JGER	R9			:RETURN IF SO
	LIS	R0,4			:ASSUME LENGTH 4 BYTES
	CLHI	R1,0C3			:OPCODE < C3 THEN RX TYPE
	JLFS	BRX			:
	CLHI	R1,0EA			:OPCODE >= EA THEN RI1 TYPE
	JGER	R9			:
	CLHI	R1,0CF			:OPCODE < CF THEN RI1
	JLR	R9			:
	CLHI	R1,0E2			:OPCODE = E2 THEN RI1
	JER	R9			:
BRX	LB	R2,2,R15		:IF 3RD BYTE OF INST IS 4X THEN RX3 TYPE
	NHI	R2,0F0			:ISOLATE LEFT DIGIT OF BYTE
	CLHI	R2,40			:
	JNR	R9			:STORE LENGTH TO RX1 OR 2
	LIS	R0,6			:LENGTH OF RX3
	JR	R9			:
BR	BC	01,02,03,20,21,22,23	:TABLE OF BRANCH OPCODES...RR TYPE
	BC	31			:JFFO
	BC	33			:JFFOH
	BC	41,42,43,0C0,0C1	:RX TYPE BRANCH OPCODES
BRLEN	EQ	.-BR			:NUMBER OF JUMP OPCODES
					:
:	.......................................................................
:		Command B  (Set or clear breakpoint)
:		=========
:	.......................................................................
					:
BREAK	ST	R9,SLINK,R8		:SAVE LINK
	JAL	R9,NUM			:GET ADDRESS
	LR	R7,R0			:SAVE USER ADDR
	JE	BREAK1			:IF ZERO REMOVE BP ONLY
	LIS	R1,5			:POSITION OF MAC BIT IN SPSW
	TBT	R1,SPSW,R8		:WAS USER RUNNING UNDER MAC
	JEFS	BREAK0			:NO - DO NOT TRANSLATE ADDR
	JAL	R9,TEX			:TEST IF USER HAS ACCESS
	 J	BERR			:NO - ISSUE ERROR MESSAGE
	JAL	R9,TRASL,,		:TRANSLATE USER ADDR TO PHYSICAL ADDR
	J	BMAC			:
BREAK0	CL	R0,MEMTOP		:IS IT IN RANGE?
	JGE	BERR			:NO - ISSUE ERROR MESSAGE
BREAK1	LR	R6,R0			:
	JAL	R9,NUM			:GET BP NUMBER
	LR	R14,R0			:
	CHI	R14,BPNO-1		:R14 MUST BE  0 <= R14 < BPNO
	JLEFS	BREAK2			:
	LA	R1,BPERR		:
	J	BITCH			:ISSUE ERROR MESSAGE
BREAK2	JAL	R9,RBK			:REMOVE BREAKPOINT IF THERE IS ONE
	L	R9,SLINK,R8		:RESTORE LINK
	LR	R7,R7			:USER ADDR = 0 MEANS REMOVE BP N
	JER	R9			:BP ALREADY REMOVED - RETURN
	LB	R15,0,R6		:CHECK OP CODE THERE
	JNFS	BREAK3			:SKIP IF NOT = 0
	LA	R1,BXERR		:
	J	BITCH			:ELSE ISSUE ERROR MESSAGE
BERR	LA	R1,GMSG			:ISSUE ERROR MSG
	J	BITCH			:SEND MSG
					:
BREAK3	LR	R15,R6			:PHYSICAL ADDR
	L	R9,SLINK,R8		:RESTORE LINK
					:
:	.......................................................................
:	SET SPECIAL BREAKPOINT
:	R14	BREAKPOINT NUMBER
:	R7	USER ADDRESS OF BREAKPOINT
:	.......................................................................
					:
SBK	LR	R3,R14			:SET BP
	SLLS	R3,2			:GENERATE INDEX TO ADDRESS TABLE
	ST	R7,LISTA,R8,R3		:STORE USER ADDRESS OF BP
	LB	R12,0,R15		:FETCH OPCODE AGAIN (BECAUSE OF ENTRY POINT)
	STB	R12,LISTO,R8,R14	:SAVE OPCODE IN TABLE
	LIS	R12,0			:
	STB	R12,0,R15		:PLACE 0 OPCODE IN BP LOCATION
	JR	R9			:RETURN
					:
:	.......................................................................
:	REMOVE BREAKPOINT
:	R14	BREAKPOINT NUMBER
:	.......................................................................
					:
RBK	LR	R3,R14			:REMOVE BP
	SLLS	R3,2			:GENERATE INDEX TO ADDRESS TABLE
	L	R0,LISTA,R8,R3		:FETCH USER ADDRESS OF BP N
	JLR	R9			:IF R0 = -1 THERE IS NO BP - RETURN
	LIS	R15,5			:POSITION OF MAC BIT IN SPSW
	TBT	R15,SPSW,R8		:IS MAC BEING USED
	JEFS	RBK1			:NO
	LR	R15,R9			:SAVE LINK
	JAL	R9,TRASL,,		:TRANSLATE TO PHYSICAL ADDR
	J	BMAC			:
	LR	R9,R15			:RESTORE LINK
RBK1	LR	R15,R0			:PHYSICAL ADDR
					:
: i fail to see what purpose the following check serves ***ern 10/27/88
: if it  stands the test of time this all should be removed!!!!
:	LB	R12,0,R15		:CHECK IF BP STILL SET (OP CODE = 0)
:	JNR	R9			:OP CODE NOT ZERO - DON'T TOUCH!!
	LB	R12,LISTO,R8,R14	:FETCH OPCODE OF INST AT BP FROM TABLE
	STB	R12,0,R15		:RESTORE OPCODE
	LCS	R12,1			:CLEAR ADDRESS TABLE ENTRY
	ST	R12,LISTA,R8,R3		:
	JR	R9			:RETURN
					:
:	.......................................................................
:	DDT Command R  (Read memory or registers)
:	.......................................................................
					:
DREAD	ST	R9,SLINK,R8		:SAVE LINK
	LA	R7,TRO			:SET TEST FOR READ ACCESS
	JAL	R9,VENT			:READ USER INPUT - SET REGS R15, R12
	LHL	R3,MODE,R8		:CHECK ASCII-BINARY FLAG
	JN	RB			:BINARY
					:
:	.......................................................................
:	ASCII
:	.......................................................................
					:
	LR	R6,R6			:CHECK IF "RR"
	JE	RA			:SKIP IF NOT
					:
:	.......................................................................
:	FUNCTION TO DISPLAY REGISTERS FROM CORE, FROM (R15) TO (R12)
:	.......................................................................
					:
RRDISP	LIS	R3,0			:"RR"...SET FLAG
RRLOOP	L	R0,0,R15		:GET REGISTER
	LHI	R1,850			:8 HEX DIGITS
	SVC	KIO,$A 10		:
	JAL	R9,DO2BL		:FOLLOW REGISTER WITH 2 BLANKS
	AIS	R15,4			:BUMP TO NEXT
	CR	R15,R12			:TEST IF LAST ONE
	JGE	TTY			:YES...QUIT
	AIS	R3,1			:ELSE PUT 4 REGS/LINE
	THI	R3,3			:TEST IF TO FOLD LINE
	JNBS	RRLOOP			:PROCEED IF NOT
	JAL	R9,DOCRLF		:ELSE TERMINATE LINE WITH CR|LF
	J	RRLOOP			:AND CONTINUE
					:
:	.......................................................................
:	Read ASCII
:	.......................................................................
					:
RA	LHI	R1,650			:6 HEX DIGITS
	LR	R0,R14			:COPY EFFECTIVE ADDRESS
	SVC	KIO,$A 10		:PRINT ADDRESS
	LIS	R6,7			:8 HALFWORDS/LINE
	THI	R15,1			:
	JE	RA1			:SKIP IF NOT START ON ODD BOUNDARY
	JAL	R9,DO2BL		:ODD BOUNDARY...ADVANCE TO EVEN
   IF	FSYS				:
	JAL	R9,GETDSC		:TRY TO READ FROM DISC
   EI  (FSYS)				:
	LB	R0,0,R15		:
	AIS	R15,1			:DO SINGLE BYTE TO GET TO EVEN BOUNDARY
	AIS	R14,1			:
	LHI	R1,250			:2 HEX DIGITS
	SVC	KIO,$A 10		:
	CR	R15,R12			:
	JGE	REND			:QUIT IF ONLY ONE DIGIT
RA1	JAL	R9,DO2BL		:PRECEED EACH HALF-WORD WITH "  "
   IF	FSYS				:
	JAL	R9,GETDSC		:
   EI  (FSYS)				:
	LHL	R0,0,R15		:GET A HALF-WORD
	AIS	R15,2			:
	LHI	R1,450			:4 HEX DIGITS, ZERO FILL
	SVC	KIO,$A 10		:OUTPUT VALUE
	CR	R15,R12			:ARE WE DONE?
	JGE	REND			:YES...CLEAN UP
	AIS	R14,2			:ELSE BUMP EFFECTIVE ADDRESS
	SIS	R6,1			:CHECK FOR LINE FOLDING
	JGE	RA1			:
	LH	R0,FLAG,R8		:HAS BREAK CHARACTER ARRIVED?
	JN	REND			:YES...ABORT
	JAL	R9,DOCRLF		:TERMINATE LINE WITH CR|LF
	J	RA			:AND START OVER
					:
:	.......................................................................
:	BINARY
:	.......................................................................
					:
RB	LIS	R0,1			:ONE CHAR AT A TIME
	STB	R0,ROUT,R8		:
RBLOOP	HS	0			:
   IF	FSYS				:FILE SYSTEM ENABLED
	JAL	R9,GETDSC		:TRY IT FROM DISC
   EI  (FSYS)				:
	LB	R1,0,R15		:READ BYTE AT R15
	STB	R1,ROUT+1,R8		:
	SVC	OUT,ROUT,R8		:GIVE OUTPUT BUFFER TO SYSTEM
	LH	R1,FLAG,R8		:CHECK IF BREAK CHAR HAS ARRIVED
	JNFS	REND			:
	AIS	R15,1			:CHECK NEXT BYTE
	CLR	R15,R12			:TERMINATE IF  R15 > R12
	JL	RBLOOP			:
					:
:	.......................................................................
:	READ & WRITE BOTH EXECUTE THIS CODE!!!
:	ENTRY POINT FOR "X" & "Y" TO RESTORE BP'S AND RETURN
:	.......................................................................
					:
REND	L	R9,SLINK,R8		:RESTORE LINK
REND0   LHI     R0,E.PSW                :TURN OFF MAC IN PSW
        EPSR    R1,R0			:
	LA	R3,MPROT+MACDIS,R8	:GET MAC POINTERS
	ST	R3,MACTRN,R8		:RESTORE MAC BEFORE BP'S
	SVC	DISMIS			:LET MAC BE RESTORED
	lb	r6,xreg,r8		:check register context ***ern
	jefs	rend1			:memory context
	lis	r6,0			:
	stb	r6,xreg,r8		:reset context
	jr	r9			:return on registers referenced
rend1	LHI	R12,BPNO*4		:REPLACE BREAKPOINTS
	LIS	R14,BPNO-1		:
RDPB	L	R0,LISTA-4,R8,R12	:SEARCH ADDRESS LIST FOR NON-NEG ENTRIES
	JL	RTEST			:SKIP EMPTY ENTRIES
	LIS	R15,5			:POSITION OF MAC BIT IN SPSW
	TBT	R15,SPSW,R8		:IS MAC BEING USED
	JEFS	RDBP1			:NO
	JAL	R9,TRASL,,		:TRANSLATE TO PHYSICAL ADDR
	J	BMAC			:
RDBP1	LR	R15,R0			:PHYSICAL ADDR
	LB	R3,0,R15		:FETCH OPCODE
	CLB	R3,LISTO,R8,R14		:HAS OPCODE BEEN CHANGED BY "W"
	JEFS	RNXT			:NO
	STB	R3,LISTO,R8,R14		:STORE NEW OPCODE INTO BP LIST
RNXT	STB	R6,0,R15		:STORE ILLEGAL OPCODE AT BP
RTEST	SIS	R12,4			:DECR INDEX INTO ADDR LIST
	SIS	R14,1			:DECR INDEX INTO OPCODE LIST
	JGE	RDPB			:CONTINUE SEARCH
	L	R9,SLINK,R8		:RESTORE LINK
	JR	R9			:RETURN
					:
:	.......................................................................
:	DDT Command W  (Write memory or registers)
:	.......................................................................
					:
DWRITE	ST	R9,SLINK,R8		:SAVE LINK
	LA	R7,TRO			:SET TEST FOR READ ACCESS
	JAL	R9,VENT			:READ USER INPUT - SET REGS A, X
WLOOP	JAL	R9,NXTBYT		:READ USER DATA - ONE BYTE
	J	WBNUM			:INVALID NUMBER
	J	WCOMP			:COMPRESSION CODE...SKIP TO EXPAND
   IF	FSYS				:
	JAL	R9,SNDCHA		:
   EI  (FSYS)				:
	STB	R0,0,R15		:STORE IT AT R15
	LH	R1,FLAG,R8		:CHECK IF BREAK CHAR HAS ARRIVED
	JN	REND			:
	AIS	R15,1			:CHECK NEXT BYTE ADDRESS
WLOOP1	CLR	R15,R12			:LOOP UNTIL  R15 > R12
	JL	WLOOP			:
	J	REND			:USE SAME TERMINATION PROCEEDURE AS READ
					:
:	.......................................................................
:	COMPRESSION CHAR
:	.......................................................................
					:
WCOMP	LIS	R7,1			:EXPAND FILL
	NR	R7,R0			:
	JEFS	.+4			:"0"'S FILL
	LCS	R7,1			:"1"'S FILL
	JAL	R2,GETCHAR		:MUST BE BINARY TO GET HERE...
	NOP	0			:...SO GET COUNT
	LR	R6,R0			:
WCOMP1	LH	R1,FLAG,R8		:CHECK FOR BREAK CHAR INPUT
	JN	REND			:
	SIS	R6,1			:COUNT ANOTHER CHAR GONE
	JL	WLOOP1			:EXIT WHEN DONE
   IF	FSYS				:
	JAL	R9,SNDCHB		:
   EI  (FSYS)				:
	STB	R7,0,R15		:ELSE FILL ANOTHER BYTE
	AIS	R15,1			:
	CLR	R15,R12			:CHECK IF REACHED END OF WRITE AREA
	JLBS	WCOMP1			:
	J	REND			:ELSE TERMINATE WRITE
WBNUM	LA	R9,WB1			:SET UP KLUDGE TO RETURN HERE
	ST	R9,SLINK,R8		:
	J	REND0			:CLEANUP
WB1	LA	R1,BADNUM		:
	J	BITCH			:ISSUE ERROR MESSAGE AND FLUSH INPUT
					:
:	.......................................................................
:	THE FOLLOWING CODE IS USED BY BOTH R & W TO DETERMINE ADDR OR REG
:	.......................................................................
					:
VENT	ST	R9,ULINK,R8		:SAVE LINK
	JAL	R9,PEEK			:PEEK AT NEXT CHAR
	LIS	R6,0			:
	CLHI	R0,0D2			:R6 GETS 1 IF CHAR IS "R"  ELSE 0
	JEFS	VRREG			:
	CLHI	R0,0F2			:IS IT LOWER CASE "R"
	JNFS	VMEM			:
VRREG	LH	R15,MODE,R8		:IF ASCII MODE READ THE "R"
	JNFS	VRREG1			:BINARY MODE
	JAL	R9,CHARM		:ASCII MODE - READ THE "R"
VRREG1	LIS	R6,1			:SET R6 TO 1, INDICATING "RR"
VMEM	JAL	R9,NUM			:READ ADDRESS
	LR	R15,R0			:
	JAL	R9,NUM			:READ COUNT
	LR	R14,R0			:
	JLE	TTYERR			:COUNT MUST BE GT ZERO
	CI	R14,SEGSIZ		:CHECK COUNT
	JLEFS	VMEM0			:JUMP IF < 64K
	LA	R1,VMSG1		:ELSE FAKE MEMORY OUT OF BOUNDS
	J	BITCH			:AND GO COMPLAIN AND RESYNC
VMEM0	LR	R6,R6			:SET CONDITION CODE - ZERO IF MEMORY
	JE	VMEM1			:ADDR REFERENCED CORE
	lis	r1,1			:set register context ***ern
	stb	r1,xreg,r8		:
	CHI	R15,0F			:REGISTERS...IS FIRST REGISTER NUMBER VALID?
	JG	VERR2			:
	LR	R12,R14			:COPY NUMBER OF REGISTERS
	AR	R12,R15			:COMPUTE LAST REGISTER NUMBER
	CHI	R12,10			:IS REG NUMBER VALID?
	JG	VERR2			:
	SLLS	R15,2			:COMPUTE FIRST BYTE ADDR IN SAVE AREA
	SLLS	R12,2			:COMPUTE ADDR OF LAST BYTE IN REG SAVE AREA
	LA	R9,URSA,R8		:R8 ADDR OF SAVE AREA
	AR	R15,R9			:
	AR	R12,R9			:
	L	R9,ULINK,R8		:RESTORE R8
	JR	R9			:RETURN
VERR1	LA	R1,VMSG1		:"MEMORY ADDR OUT OF BOUNDS"
	JFS	VER			:
VERR2	LA	R1,VMSG2		:"REGISTER NUMBER INVALID"
VER	L	R9,ULINK,R8		:CHECK LINK
	CLI	R9,WLOOP		:IF TRUE FLUSH INPUT
	JE	BITCH			:
	L	R9,SLINK,R8		:RETURN TO TTY HANDLER
	J	OOUT			: VIA OUTPUTTING DIAGNOSTIC
VMEM1	LR	R12,R14			:SET UP TEST FOR VALID ACCESS TO MEMORY
	AR	R12,R15			:LAST ADDR OF ACCESS
					:
   IF	FSYS				:
:	.......................................................................
:	AT THIS POINT A CHECK IS MADE WHETHER THIS USER HAS OPENED A FILE FOR
:	THE SAME MODE AS THE CALLER OF VENT,IF SO THEN ACCESS TEST IS SKIPPED
:	AND THE  VARIABLE STBYTE IS SET UP
:	.......................................................................
					:
	C	R8,FUSER		:HAS THIS USER GOT FILE OPEN
	JN	NEGFIL			:NO,SKIP TO THE USUAL CODE
	L	R9,ULINK,R8		:CHECK LINK
	CLI	R9,WLOOP		:IS THIS WRITE
	JNFS	VMEM2			:CHECK FOR FMODE = READ
	LH	R0,FMODE		:ELSE FMODE MUST BE WRITE
	JL	NEGFIL			:FILE NOT READABLE
	JFS	VMEM4			:THIS DATA GOING TO FILE
VMEM2	LH	R0,FMODE		:CHECK FILE MODE
	JE	NEGFIL			:MATCHING MODES
VMEM3	ST	R15,STBYTE		:STORE HERE(READS ONLY)
        LR      R14,R15                 :R14 = EFFECTIVE ADDRESS
	J	VENT1			:SKIP MEMORY TESTS
VMEM4	ST	R15,DADDR		:FILE IO NEEDS THIS VARIABLE
	LR	R14,R15			:R14 = EFFECTIVE ADDRESS
	J	VENT1			:SKIP MEMORY TESTS
NEGFIL	HS	0			:
   EI  (FSYS)				:
					:
	LHL	R0,SPSW,R8		:IS USER RUNNING UNDER MAC?
	THI	R0,0400			:
	JNFS	VENT0			:YES TRANSLATE ADDRESS
	CL	R12,MEMTOP		:IS IT IN RANGE?
	JG	VERR1			:IF NOT, ERROR
        LR      R14,R15                 :INSURE VIRTUAL AND ABSOLUTE =
        J       VENT1			:
VENT0	L	R9,ULINK,R8		:RECLAIM 'ULINK' FOR 'BPUN' RTN
	ST	R9,TLINK,R8		:SAVE LINK
	JAL	R9,BPUN			:REMOVE BP'S BEFORE MAC CHANGE
					:ELSE A PROTECTION ERROR
	L	R9,TLINK,R8		:RECLAIM 'TLINK' FOR 'MTST' RTN
	ST	R9,ULINK,R8		:SAVE LINK
	SIS	R12,1			:
	JAL	R9,MTST			:
	LR	R0,R15			:TEST SUCCESSFUL
	JAL	R9,GETMRG		:TRANSLATE START ADDR TO PHYSICAL ADDR
        NHI     R1,MACPRS               :ALLOW ONLY PRESENCE BIT
        ST      R1,DDTMAC+CTASEG*4,R8   :MAKE THIS SEG "E"
        LIS     R1,0E                   :ALTER R15
        LR      R0,R12                  :SAVE R12 FOR GETMRG
        LR      R12,R14                 :SAVE A COPY OF R14
        LR      R14,R15			:
        EXHR    R15,R15                 :ALTER THE SEG ADDRESS
	RRL	R15,MSHFTX		:POSITION SEGMENT NUMBER
        STBR    R1,R15                  :TO POINT TO DDT PAGE
	RLL	R15,MSHFTX		:POSITION SEGMENT NUMBER
        EXHR    R15,R15                 :PUT IT BACK TOGETHER
					:
	JAL	R9,GETMRG		:GET MAC REGISTER FROM CURRENT SET
        NHI     R1,MACPRS               :ALLOW ONLY PRESENCE BIT
        ST      R1,DDTMAC+ISEG*4,R8     :MAKE THIS SEG "F"
        AR      R12,R15			:
					:
   IF	MULMAC				:
        LIS     R0,0                    :FORCE TO MAC SET ZERO
        STB     R0,DDTMAC+47,R8		:
   EI  (MULMAC)				:
        LA      R1,DDTMAC+MACDIS,R8     :CHANGE MAC
        ST      R1,MACTRN,R8		:
        SVC     DISMIS                  :LET SYSTEM CHANGE THE MAC
        LHI     R0,E.PSW+400            :TURN ON THE MAC
        EPSR    R1,R0			:
	L	R9,ULINK,R8		:ALREADY REMOVED BP'S
	JR	R9			:RETURN
VENT1	L	R9,ULINK,R8		:RESTORE LINK
					:
:	.......................................................................
:	ENTRY POINT FOR "X" & "Y" TO UNDO BP'S
:	.......................................................................
					:
BPUN	ST	R9,ULINK,R8		:SAVE LINK
	LHI	R2,(BPNO-1)*4		:UNDO BREAKPOINTS
	LIS	R3,BPNO-1		:
VUBP	L	R0,LISTA,R8,R2		:SEARCH ADDRESS LIST FOR NON-(-1) ENTRIES
	JL	VTST			:
	LIS	R1,5			:POSITION OF MAC BIT IN SPSW
	TBT	R1,SPSW,R8		:IS MAC BEING USED
	JEFS	VUBP1			:NO
	JAL	R9,TRASL,,		:TRANSLATE TO PHYSICAL ADDR
	J	BMAC			:
VUBP1	LR	R1,R0			:PHYSICAL ADDR
	LB	R0,LISTO,R8,R3		:RESTORE OPCODE
	STB	R0,0,R1			:
VTST	SIS	R3,1			:GO TO NEXT BP
	SIS	R2,4			:IS THIS THE LAST BP
	JGE	VUBP			:LOOP
	L	R9,ULINK,R8		:RESTORE LINK
	JR	R9			:RETURN
					:
:	.......................................................................
:	DDT Command M (Set search mask & bounds)
:	.......................................................................
					:
M	LA	R9,WLOOP		:THIS WILL FORCE VERR1 TO JUMP TO BITCH
	ST	R9,ULINK,R8		:IF IT ENCOUNTERS INVALID ADDRESS RANGE
	JAL	R9,NUM			:
	LR	R14,R0			:IF MASK 0 SET TO -1
	JNFS	M0			:
	LCS	R14,1			:
M0	JAL	R9,NUM			:
	LR	R15,R0			:START SEARCH ADDR
	JAL	R9,NUM			:
	CLR	R0,R15			:START ADDR <= END ADDR
	JGEFS	M1			:
	LA	R1,XERR1		:
	JAL	R9,OOUT			:ISSUE ERROR MESSAGE
	J	TTY			:RETURN
M1	LR	R12,R0			:END ADDRESS
	LIS	R3,5			:POSITION OF MAC BIT IN SPSW
	TBT	R3,SPSW,R8		:IS USER RUNNING UNDER MAC
	JN	M4			:YES - TRANSLATE ADDRS
	CL	R12,MEMTOP		:IS IT IN RANGE?
	JGE	VERR1			:IF NOT, ERROR
	J	M3			:ELSE CONTINUE
M4	LA	R7,TRO			:SET UP TEST FOR READ ACCESS
	JAL	R9,MTST			:
	LR	R0,R15			:TEST SUCCESSFUL
	JAL	R9,TRASL,,		:TRANSLATE START ADDR TO PHYSICAL ADDR
	J	BMAC			:
	LR	R15,R0			:
	LR	R0,R12			:
	JAL	R9,TRASL,,		:TRANSLATE END ADDR TO PHYSICAL ADDR
	J	BMAC			:
	LR	R12,R0			:
M3	ST	R14,SMASK,R8		:SAVE MASK
	ST	R15,SLOW,R8		:SAVE START ADDR
	ST	R12,SHGH,R8		:SAVE END ADDR
	J	TTY			:RETURN
					:
:	.......................................................................
:	V -- DDT SPY COMMAND
:	^V TAB:  where:
:	TAB	start of user's halfword table
:	if TAB=0, turn off SPY.
:	expects user previously executed "M" command, with args:
:	CNT, FAD, LAD, where:
:	CNT is number of half-words in user table
:	FAD is spy start address
:	LAD is spy end address
:	.......................................................................
					:
DSPY	JAL	R9,NUM			:TAB
	LHL	R14,SLOT,R8		:FETCH OUR SLOT #
	LR	R15,R0			:COPY AND TEST
	JGFS	DSPY1			:SKIP IF NOT "TURN-OFF"
	CL	R14,SPYFLAG
	JN	TTY			:NOT OURS...JUST EXIT
	LCS	R0,1
	ST	R0,SPYFLAG		:ELSE COMPLETE "TURN OFF"
	J	TTY			:AND EXIT
DSPY1	LH	R12,SMASK+2,R8		:CHECK MASK ARGUMENTS
	JGFS	DSPY4			:SKIP IF POTENTIAL VALIDITY
DSPY2	LA	R1,DSERR1		:ELSE BITCH
DSPY3	JAL	R9,OOUT			:OUTPUT DIAGNOSTIC
	J	TTY			:AND PROCEED
DSPY4	AR	R12,R12			:COMPUTE END ADDRESS
	AR	R12,R0
	LHL	R1,SPSW,R8		:CHECK FOR MAC IN USE
	THI	R1,0400
	JNFS	DSPY9			:IF SO, TRANSLATE ADDR
	CL	R12,MEMTOP		:IS IT IN RANGE?
	JLFS	DSPY5			:IF SO, CONTINUE
	J	VERR1			:ELSE ERROR
DSPY9	LA	R7,TRO			:ELSE SET UP TO TEST ACCESS
	JAL	R9,MTST
	LR	R0,R15			:TEST SUCCESSFUL, TRANSLATE STRT ADDR
	JAL	R9,TRASL,,	
	 J	BMAC
	LR	R15,R0			:AND SAVE IT

DSPY5	L	R4,SLOW,R8		:MAC USAGE IS OK...SET UP
	L	R5,SHGH,R8
	SR	R5,R4
	AIS	R5,1			:RANGE OF BYTES TO PROCESS
	LH	R1,SMASK+2,R8		:NUMBER OF BINS TO SERVICE
	DHR	R5,R1			:NUMBER OF BYTES/CELL
	LR	R7,R6			:SAVE THAT
	JE	DSPY2			:BAD RANGE...ABORT
	MHR	R6,R1			:RANGE OF BYTES TO PROCESS

	LIS	R0,0			:TRY TO GET USE OF SPY
	RBT	R0,SPYFLAG
	JN	DSPY8			:SKIP IF SUCCESSFUL
	L	R0,SPYFLAG		:ALREADY IN USE...IS IT BY US?
	CR	R0,R14
	JNFS	DSPY6			:NO...COMMENT ON FACT
	LA	R1,DSERR2		:DIAGNOSTIC...WE ALREADY HAVE IT
	J	DSPY3
DSPY6	SVC	OUT,DSMSG		:SOMEONE ELSE ALREADY OWNS SPY...TELL WHO
	LHI	R1,210			:OUTPUT 2 DIGITS OF CURRENT OWNER
	SVC	KIO,$A 10
	LIS	R0,0			:RESTORE R0
DSPY7	RBT	R0,SPYFLAG		:KEEP TRYING TO GET IT
	JNFS	DSPY8			:SUCCESS
	SVC	IN,4			:NOT YET...LOOK FOR INPUT FOR ABORT
	J	DSPY7			:ELSE KEEP TRYING
	LA	R1,DSERR2		:WE GOT ABORTED...COMMENT AND PROCEED
	J	DSPY3

:	WE HAVE SUCCEEDED...SET UP TABLE, TURN ON SPY
DSPY8	ST	R15,SPYTAB		:SET POINTER TO TABLE
	STH	R7,SPYWTH		:SAVE TABLE START, # BINS
	ST	R4,SPYSAD		:SAVE MEMORY START ADDRESS
	ST	R6,SPYRNG		:SAVE RANGE
	ST	R14,SPYFLAG		:FINALLY, TURN SPY ON
        LA      R6,SPYFLC               :SET DUMMY SPY REPORT LOCATION
        ST      R6,SPYFLC
	J	TTY			:THEN PROCEED, SPY NOW RUNNING IN PARALLEL

DSMSG	SC	/"8D"8ASPY already in use by slot /;


:		Command X (Data search)
:		=========
XXX	ST	R9,SLINK,R8		:SAVE LINK
	JAL	R9,NUM
	LR	R14,R0			:MATCH FLAG
	JEFS	.+4
	LIS	R14,8			:0 FOR MATCH, ELSE NON-MATCH
	JAL	R9,NUM
	LR	R12,R0			:LENGTH (1,2,4) - CHECK
	JEFS	XE0			:ZERO IS ERROR
	SIS	R0,4
	JGFS	XE0			:>4 IS ERROR
	AIS	R0,1
	JNFS	XE1			:=3 IS ERROR ELSE OK
XE0	LA	R1,XERR2
	J	BITCH			:FLUSH INPUT
XE1	JAL	R9,NUM
	LR	R5,R0			:SEARCH VALUE
	L	R15,SLOW,R8		:START ADDR OF SEARCH
	LHI	R0,-1,R12		:CHECK TYPE OF SCAN
	JEFS	XX0			:BYTE SCAN...JUST PROCEED
	THI	R15,1			:HALF-WORD OR WORD...MUST START ON EVEN BYTE
	JEFS	XX0			:BOUNDARY O.K.
	LA	R1,XERR3
	J	BITCH			:ISSUE ERROR MSG - BAD BOUNDARY
XX0	LR	R6,R12			:SAVE COPY OF LENGTH
	SRLS	R12,1
	MH	R12,SIX			:FUDGE JUMP TO PROPER LOAD
	JAL	R9,BPUN			:UNDO BREAK POINTS BEFORE SEARCH
X0	J	.+4,R12			:LOAD NEXT LOCATION APPROPRIATELY
	LB	R7,0,R15
	JFS	X1
	LHL	R7,0,R15
	JFS	X1
	L	R7,0,R15

X1	N	R7,SMASK,R8		:APPLY USER MASK
	J	X1A,R14			:MAKE CORRECT TEST
X1A	CLR	R7,R5			:EQUALITY TEST
	JN	X4			:NO...GO ON
	JFS	X2			:YES...PRINT IT

	CLR	R7,R5			:LOOK FOR NOT EQUAL
	JE	X4			:NO - GET NEXT LOC
X2	LR	R7,R15			:TEMPORARY STORE
	NHI	R15,-2			:FORCE TO HALFWORD BOUNDARY
	LR	R0,R15
	LIS	R1,5			:POSITION OF MAC BIT IN SPSW
	TBT	R1,SPSW,R8		:IS MAC BEING USED
	JEFS	X2A			:NO - SKIP TRANSLATION
	JAL	R9,UTRASL		:CONVERT PHYSICAL ADDR TO USER ADDR
X2A	LIS	R1,6			:6 DIGITS
	JAL	R9,ACONV
	JAL	R9,DO2BL		:TAB
	LR	R1,R15
	L	R0,0,R1			:GET THE WORD TO PRINT
	LIS	R1,8
	JAL	R9,ACONV
	JAL	R9,DOCRLF		:TERMINATE LINE WITH CR|LF
	LH	R0,FLAG,R8		:CHECK IF BREAK CHAR ARRIVED
	JNFS	X5			:YES - RETURN
	LR	R15,R7			:REPLACE FROM TEMPORARY
X4	LH	R0,FLAG,R8		:CHECK IF BREAK CHARACTER HAS ARRIVED
	AR	R15,R6			:INCR TO NEXT LOC
X2B	CL	R15,SHGH,R8		:CHECK END OF SEARCH
	JGEFS	X5
	LR	R0,R15			:CHECK IF NEXT LOAD IS PAST MEMORY OF USER
	AR	R0,R6
	C	R0,SHGH,R8
	JLE	X0
X5	LIS	R11,0			:CLEAR SPECIAL BP FLAG
	LIS	R6,0			:FLAG FOR REND
	J	REND			:RESTORE BREAK POINTS AND RETURN
SIX	HC	6



:		Command Y (Instruction search)
:		=========
D.Y	ST	R9,SLINK,R8		:SAVE LINK
	JAL	R9,NUM
	LR	R12,R0			:LENGTH OF INST.
	JEFS	YE0			:VERIFY LENGTH 1,2, OR 3
	SIS	R0,4
	JLFS	Y0
YE0	LA	R1,XERR2		:"BAD LENGTH"
	J	BITCH			:FLUSH INPUT
Y0	LR	R7,R12			:COPY NUMBER OF HALF-WORDS
	AR	R12,R12			:EXPAND LENGTH TO BYTE COUNT
	JAL	R9,NUM
	LR	R5,R0			:FIRST HALFWORD
	SIS	R7,1			:IS INST ONLY ONE HALFWORD
	JEFS	Y1
	JAL	R9,NUM
	LR	R6,R0			:SECOND HALFWORD
	SIS	R7,1			:IS IT ONLY ONE WORD
	JEFS	Y1
	JAL	R9,NUM
	LR	R7,R0			:THIRD HALFWORD
Y1	L	R15,SLOW,R8
	THI	R15,1			:INSURE START ADDR IS EVEN
	JEFS	YY2
	LA	R1,XERR3
	J	BITCH			:ISSUE ERROR MSG - BAD BOUNDARY
YY2	JAL	R9,BPUN			:REMOVE BREAK POINTS BEFORE SEARCH
Y2	LR	R14,R15			:CHECK IF END OF INST IN SEARCH RANGE
	AR	R14,R12			:ADD LENGTH OF INST
	C	R14,SHGH,R8		:COMPARE TO END OF SEARCH RANGE
	JG	Y6			:IF GREATER RETURN
	LHL	R4,0,R15		:COMPARE FIRST HALFWORD AGAINST MEMORY
	CLR	R5,R4
	JN	Y4			:NOT EQUAL INCR TO NEXT HALFWORD
	CLHI	R12,2			:IS SEARCH FOR ONE HALFWORD
	JE	Y3			:YES - PRINT ADDR
	LHL	R4,2,R15		:COMPARE SECOND HALFWORD TO MEMORY
	CLR	R6,R4
	JN	Y4			:NOT EQUAL INCR TO NEXT HALFWORD
	CLHI	R12,4			:IS SEARCH FOR TWO HALFWORDS
	JEFS	Y3			:YES - PRINT ADDR
	LHL	R4,4,R15		:COMPARE THIRD HALFWORD TO MEMORY
	CLR	R7,R4
	JN	Y4			:NOT EQUAL INCR TO NEXT HALFWORD
Y3	LR	R0,R15			:ADDR TO BE PRINTED
	LIS	R1,5			:POSITION OF MAC BIT IN SPSW
	TBT	R1,SPSW,R8		:IS MAC BEING USED
	JEFS	Y3A			:NO - SKIP TRANSLATION
	JAL	R9,UTRASL		:CONVERT PHYSICAL ADDR TO USER ADDR
Y3A	LIS	R1,6			:NUMBER OF DIGITS IN ADDR
	JAL	R9,ACONV
	JAL	R9,DOCRLF		:REQUEST CR|LF AT END OF MESSAGE
	AR	R15,R12			:CONTINUE SEARCH PAST THIS INST.
	JFS	Y5
Y4	AIS	R15,2			:INCR TO NEXT HALFWORD
Y5	LH	R0,FLAG,R8		:CHECK IF BREAK CHARACTER ARRIVED
	JE	Y2			:NO - LOOP
Y6	LIS	R6,0			:FLAG FOR REND
	J	REND			:RESTORE BREAK POINTS AND RETURN
					:
:	....................................................................
:	DDT Command "G" -  (Go to start program execution)
:	....................................................................
					:
DGO	ST	R9,SLINK,R8		:STORE LINK
	JAL	R9,NUM			:GET START ADDR
	LIS	R3,5			:POSITION OF MAC BIT IN SPSW
	TBT	R3,SPSW,R8		:IS USER RUNNING UNDER MAC
	JNFS	DGO1			:YES - TRANSLATE ADDR
	CL	R0,MEMTOP		:IS IT IN RANGE?
	JLFS	DGO2			:IF SO, CONTINUE
	J	DGOERR			:NO
DGO1	JAL	R9,TRO			:DOES USER HAVE ACCESS TO THIS ADDR
	J	DGOERR			:NO
DGO2	ST	R0,DDTTMP		:Save input address
	LA	R1,AGAIN		:Get confirmation message...
	JAL	R9,OOUT			:Ask user again for confirmation?
	JAL	R1,INCHAR		:Get the user response...
	JAL	R1,CUC			:Convert input char to upper case
	CLHI	R0,0D9			:Is it "Y"?
	JN	TTY			:No, user not sure...just return
	L	R9,SLINK,R8		:RESTORE LINK
	LIS	R11,0			:CLEAR SPECIAL BP FLAG
	LCS	R13,2			:INIT BREAKPOINT NUMBER
	LHL	R1,CPSW,R8		:PSW TO USE
	ST	R1,OLDPSW,R8		:STORE IN PSW LOCATION
	L	R0,DDTTMP		:Restore new start address
	ST	R0,OLDPSW+4,R8		:SET PSW ADDR TO START ADDR
	J	YY,R8			:SWAP REGISTERS AND LOAD PSW
DGOERR	LA	R1,GMSG			:
	J	BITCH			:ISSUE ERROR MESSAGE
					:
:	....................................................................
:	DDT Command "U" (Change PSW bits)
:	....................................................................
					:
DDT.U	JAL	R9,NUM			:READ NEW STATUS BITS
	NHI	R0,100F			:NON-GOD USER MAY ONLY SET CONDITION CODE, TRACE
	LHI	R1,0EFF0		:SET MASK
	NH	R1,CPSW,R8		:CLEAR BITS IN CURRENT STATUS BITS
	OR	R1,R0			:ENTER NEW BITS
	STH	R1,CPSW,R8		:SAVE FOR NEXT G COMMAND
	J	TTY			:AND PROCEED
					:
:	....................................................................
:	DDT Command "T" (Type out curent user PSD)
:	....................................................................
					:
DT	LIS	R0,0			:
	LHL	R6,CC,R8		:GET MAC CONDITIONS
	STH	R0,CC,R8		:AND CLEAR
	LIS	R7,$A 9

:	FUNCTION TO DISPLAY PSW (SVC SYS,0,R7), CC(R6) IF ANY
TDISP	LIS	R0,0			:PSW STATUS BITS
	SVC	SYS,0,R7		:GET THEM
	LIS	R1,8
	JAL	R9,ACONV		:PRINT IT
	JAL	R9,DO2BL		:OUTPUT 2 BLANKS
	LIS	R0,1			:ADDR
	SVC	SYS,0,R7
	LIS	R1,8			:EIGHT DIGITS IN ADDRESS
	JAL	R9,ACONV		:PRINT IT WITH 2 SPACES
	LR	R6,R6			:NOW FOR CC
	JE	TTY			:ABORT IF NULL
	JAL	R9,DO2BL		:ELSE OUTPUT 2 MORE BLANKS
	LR	R0,R6
	LIS	R1,4			:OUTPUT TWO DIGITS
	JAL	R9,ACONV		:CONVERT TO ASCII, PRINT
	J	TTY			:THEN QUIT



:		Command C	(Convert to binary input)
:		=========
CNVRT	JAL	R9,CHARM		:GET NEXT CHAR
	NHI	R0,7F			:REMOVE PARITY BIT
	SHI	R0,42			:IS IT "B"
	JNFS	CX1			:NO--IS IT "A"?
	LCS	R0,3			:CONSTANT FOR BINARY MODE
	JFS	CX2			:AND SKIP
CX1	AIS	R0,1			:IS IT "A"
	JN	TTY			:NO - NO MODE CHANGE
CX2	STH	R0,MODE,R8		:SET MODE TO 0(ASCII) OR -3(BINARY)
	J	TTY			:AND PROCEED
					:
:	.......................................................................
:	DDT Command = I	(Initialize DDT)
:	.......................................................................
					:
D.INIT	SVC	SYS,3			:TURN OFF DEBUG MODE
DINI	ST	R9,TLINK,R8		:SAVE RETURN
	JAL	R9,BPUN			:UNDO ALL EXISTING BREAKPOINTS
	L	R9,TLINK,R8		:AND RESTORE RETURN
	LCS	R13,1			:SHOW NO LAST BP
	LIS	R11,0			:NOT SPECIAL BP
	STH	R11,FLAG,R8		:ZERO BREAK CHARACTER FLAG
	LHI	R1,(BPNO-1)*4		:ZERO BP ADDR TABLE
	LCS	R2,1			:
ILOOP	ST	R2,LISTA,R8,R1		:CLEAR THIS ENTRY
	SIS	R1,4			:GO TO NEXT ENTRY
	JGEBS	ILOOP			:LOOP
	JR	R9			:RETURN
					:
:	.......................................................................
:	DDT Command = A	(Set up MAC for this slot)
:	.......................................................................
					:
ADDR	LHL	R0,SLOT,R8		:MUST BE A VALID SLOT
	SHI	R0,NSLOT		:
	JG	TTYERR			:ALL OTHERS INVALID USAGE
	JAL	R9,D.INIT		:
	LIS	R0,0			:CLEAR MAC REGISTERS
	LHI	R1,CTASEG*4		:
ADDR1	ST	R0,MPROT,R1,R8		:
	SIS	R1,4			:
	JGEBS	ADDR1			:REPEAT FOR ALL REGISTERS
	L	R2,SBASE,R8		:GET BASE OF SLOT'S AREA
   IF	MACV				:
	SLLS	R2,MSHFTA		:
   EI  (MACV)				:
	OHI	R2,MASK1		:JUST SET STORAGE PRESENT
	LHL	R3,CMAX,R8		:GET PAGE COUNT
	LR	R1,R8			:SET UP INDEX
ADDR2	LR	R0,R3			:SET UP FOR ONE LARGE AREA
	SIS	R0,1			:
	CLHI	R0,SEGSIZ/PAGE		:
	JLFS	ADDR3			:SKIP IF LESS THAN ONE SEGMENT
	LHI	R0,(SEGSIZ/PAGE)-1	:ELSE FORCE TO MAX SEGMENT SIZE
ADDR3	SLL	R0,MSHFTL		:
	OR	R0,R2			:
	ST	R0,MPROT,R1		:
	AIS	R1,4			:FORCE TO NEXT SEGMENT
	AI	R2,SEGSIZ		:
	SHI	R3,SEGSIZ/PAGE		:CHECK IF WE NEED MORE THAN 1 SEGMENT
	JG	ADDR2			:DO SO, IF SO
	L	R0,MPROT,R8		:SET UP SEGMENT 14d
	ST	R0,CTASEG*4+MPROT,R8	:...SAME AS SEGMENT 0
        LA      R0,MPROT+MACDIS,R8
        ST      R0,MACTRN,R8            :SWITHC TO INTERNAL MAC
        SVC     SYS,$A41                :DETACH ANY USER MACS
	SVC	DISMISS,0		:DISMISS SO MAC AREA WILL BE RELOADED
	J	TTY			:THEN GO CLEAN UP
					:
:	.......................................................................
:	DDT Command = H	(Halt a slot's job)
:	Note: Only allow user name "GATEWAY" and "SLOAD" to use "H" command,
:	      other user request must go through QHALT for validation.
:	.......................................................................
					:
DHALT	LHL	R1,ULICEN,R8		:Get the users' license ...
	THI	R1,L.L			:Dose user have load license?
	JNFS	DHALT1			:User has valid...just skip
	LA	R1,BADLIC		:Bad license ...
	JAL	R9,OOUT			:
	J	TTYERR			:Error ... return	
DHALT1	LR	R1,R8			:For ourself
	LH	R15,SLOT,R8		:Get the current slot number
	JLE	TTYERR			:Nodecode can't be halted
DHALT2	EQ	.
   IF	MXP				:
	CLHI	R15,SLTXMI		:Not valid for HMI slot
	JE	TTYERR			:
   EI  (MXP)				:
   IF	IPNMBR				:
	TBT	R15,IPDLCS,,		:Slot from where to down-load IPI?
	JN	TTYERR			:
   EI  (IPNMBR)				:
	STM	R0,DRSA,R8		:OK...SAVE ALL REGISTERS
	L	R7,CONTROL,R8		:
	JE	TTYERR			:ERROR IF NULL
	LH	R0,UFLAG,R7		:CHECK THAT JOB'S FLAGS
	THI	R0,FKIOJ		:
	JN	H2			:KIO CONTROLLED JOBS STOPPED IN SPECIAL WAY
	LR	R1,R7			:RESTORE R1
	LHL	R15,UFLAG,R1		:CHECK FLAGS
	THI	R15,FDISP		:IS IT CONNECTED TO DISPATCHER?
	JEFS	H1			:NO...SKIP
	LHI	R15,8000		:
	OH	R15,OGGNDX,R1		:SET PREVIOUS USER FLAG
	STH	R15,OGGNDX,R1		:
	LHL	R15,SLOT,R1		:GET SLOT NUMBER AGAIN
	STH	R15,DSLOT		:INSURE DISPATCHER WAKES UP
H1	SVC	2,20			:
	J	TTYERR			:
	SVC	DISMISS			:
	L	R2,USER,,		:GET POINTER TO CURRENT AREA
	LM	R14,RPSW,R7		:COPY PSD
	STM	R14,OLDPSW,R2		:
	LM	R8,RREG,R7		:COPY REGISTERS
	STM	R8,URSA,R2		:
	LM	R8,RREG+4*8,R7		:
	STM	R8,URSA+4*8,R2		:
	SVC	SYS,3			:DISCONNECTED...TURN OFF DEBUG MODE
	SVC	SYS,6			:AND REMOVE ANY OUTSTANDING FREEZES
	LHI	R1,9^2			:SET CODE 9 - DDT
	STH	R1,EFLAG,R2		:
        LA      R0,HBU                  :REPORT HALT BY USER
        SVC     SYS,$A29		:
	LM	R0,DRSA,R2		:RESTORE ALL REGISTERS
	J	TTY			:
					:
HBU     SC      /HALTED BY COMMAND/
					:
:	....................................................................
:	DISABLE A SET OF KIO JOBS
:	....................................................................
					:
H2	L	R3,OTHER,R7		:GET POINTER TO NAME DESCRIPTOR
	LHI	R0,2000			:TURN ON LOCK BIT
	OH	R0,GGUSE,R3		:
	STH	R0,GGUSE,R3		:THAT NAME CAN NO LONGER LOG INTO CONTROLLED SLOTS
	L	R8,USER,,		:RESTORE REGS
	LM	R0,DRSA,R8		:
	J	TTY			:
					:
:	....................................................................
:	DDT COMMAND = Q	(RESUME A SUSPENDED SLOT)
:	....................................................................
					:
RSM	LH	R0,RS.SLT		:IS RESUME ALREADY IN PROGRESS ?
	JLFS	RSM.1			:
	SVC	DISMISS			:IF SO - WAIT
	JBS	RSM			:
RSM.1	LH	R0,SLOT,R8		:GET THE SLOT NBR
	RBT	R0,SSSLOT		:REMOVE THE SUSPEND DESIGNATION
	JE	TTY			:RETURN IF ALREADY UNSUSPENDED
	TBT	R0,RNSLOT		:IS THE SLOT'S RUN BIT SET ?
	JE	TTY			:IF NOT - SKIP EXSLOT
	STM	R0,DRSA,R8		:SAVE REGS
	LR	R2,R0			:
	SLHLS	R2,2
	L	R2,SLIST,R2,		:GET BLOCK ADDR
	JAL	R7,EXSLOT,,		:START UP THE SLOT
	 J	BMAC			:IF ERROR REPORT IT
	STH	R0,RS.SLT		:SET TO FINISH RESUME
	LM	R0,DRSA,R8		:RESTORE REGS
	J	TTY			:GO BACK
					:
:	......................................................................
:	DDT COMMAND = J (SUSPEND A SLOT)
:	......................................................................
					:
SUS	LH	R0,SS.SLT		:SUSPEND ALREADY IN PROGRESS ?
	JLFS	SUS.1			:
	SVC	DISMISS			:IF SO - WAIT
	JBS	SUS			:
SUS.1	LH	R0,SLOT,R8		:GET THE SLOT NBR
	CHI	R0,NSLOT		:
	JG	TTY			:Don't allow command for Sup slots
	TBT	R0,SSSLOT		:SEE IF ALREADY SUSPENDED
	JN	TTY			:IF SO - RETURN
	STH	R0,SS.SLT		:SET TO SUSPEND SLOT
	TBT	R0,RNSLOT		:
	JE	TTY			:DON'T CHANGE REASON IF DOWN
	LHI	R0,9^2			:
	STH	R0,EFLAG,R8		:
	J	TTY			:GO BACK
					:
:	.......................................................................
:	DDT COMMAND = D (disable the slot's watch frog timer)
:	.......................................................................
					:
OFFFRG	L	R9,CONTROL,R8		:POINT TO THE BG USER BLOCK
	LCS	R0,2			:GET DISABLE CODE
	ST	R0,WFROGT,R9		:DISABLE THE BG WFROG
	L	R9,OTHER,R9		:POINT TO FG
	JEFS	FFF4			:IF NO FG - BYE
	ST	R0,WFROGT,R9		:DISABLE THE SLOT'S FG WATCH FROG
FFF4	LA	R1,DISFRX		:LOAD MSG FOR USER
	J	ONF7			:GO DISPLAY IT



:		COMMAND O	(re-enable the slot's watch frog timer)
:		=========

ONFRG	L	R9,CONTROL,R8		:POINT TO THE SLOT'S BG BLOCK
	L	R0,WFROGT,R9		:WAS THE WFROG HALTED VIA DDT ?
	AIS	R0,2
	JEFS	ONF3			:IF SO - PROCEED
	LA	R1,MAYNOT		:TELL THE USER NO DICE
	J	ONF7
ONF3	L	R7,OTHER,R9		:CHECK OUT THE FG
	JNFS	ONF4
	LR	R7,R9
ONF4	LCS	R0,1			:RE-INIT SVC WATCHFROG
	ST	R0,WFROGT,R9
	ST	R0,WFROGT,R7
	L	R0,SLOWC		:SET DISMISS WATCHFROG
	AHI	R0,WFTIME
	ST	R0,WFROGD,R9
	ST	R0,WFROGD,R7
	LA	R1,MONFRG		:REPORT SUCCESS
ONF7	JAL	R9,OOUT
	J	TTY

DISFRX	SC	/"8D"8AWatchfrog timer disabled/
MAYNOT	SC	/"8D"8AWatchfrog timer already enabled/
MONFRG	SC	/"8D"8AWatchfrog timer enabled/



:		Command E	(Execute (start-up) a slot's job)
:		=========
EXEC	L	R2,CONTROL,R8		:LOCATE CONTROLLED JOB
	JE	TTYERR			:ERROR IF NULL
	LH	R0,SLOT,R8		:FIND OUR SLOT NUMBER
	JL	TTYERR			:CAN'T EXECUTE A SYSTEM JOB
:
: this resets the repeat crash counter flag for starting slots
: and re-enables auto start halt
:
	lis	r1,0			:
	lr	r3,r0			:copy slot #
	slls	r3,3			:index on slot
	sth	r1,sltinf+2,r3,		:clear repeat crash counter
	lis	r1,1			:enable auto slot halt
	sth	r1,sltddt,,
:
	IF	MXP
	CLHI	R0,SLTXMI		:NOT VALID IF XMI SLOT
	JE	TTYERR
	EI
	LHL	R2,UFLAG,R2		:TEST TYPE OF JOB
	THI	R2,FKIOJ
	JN	DF			:FAKE "F" COMMAND FOR THESE
	SVC	KIO,9			:TEST IF SLOT ACTIVE
	J	EXE.0			:NO...PROCEED
	LA	R1,SCONCT		:YES..."ALREADY CONNECTED"
	J	BITCH

EXE.0	STM	R0,DRSA,R8		:SAVE ALL REGISTERS
        IF      IPNMBR
        TBT     R0,IPDLCS,,             :SLOT FOR IPI CODE TO DOWN-LINE LOAD?
        JN      TTYERR
        LIS     R1,0
EX.IP1  L       R3,LUN,R1,R8            :GET LUN        
        JE      EX.IP0                  :NO IPI FOR THIS SLOT
        LB      R2,LUN,R1,R8            :IS THIS LUN AN IPI?
        SIS     R2,5                    :AN IPI?
        JEFS    EX.IP2                  :YES    
        AIS     R1,4                    :CHECK NEXT LUN
        JBS     EX.IP1
EX.IP2  NI      R3,00FFFFFF
        LO      IPI
        LB      R2,IPDNUM,R3            :GET DEV NUM OF SLOT'S IPI
        TBT     R2,IPDNBA,,             :IS IPI RUNNING?
        JEFS    EX.IP0                  :NO, SO CNCT IPI SVC WILL DOWN-LOAD IPI
        TS      IPXDDT,,                :YES, SET FLAG TO AVOID DOWN-LOAD
        FO      IPI
EX.IP0  EQ      .
        EI
	JAL	R9,DINI			:INITIALIZE, CLEAR BREAKPOINTS
	LHL	R1,SLOT,R8		:GET SLOT NMBR
	L	R2,CONTROL,R8		:GET POINTER TO BACKGROUND BLOCK
	TBT	R1,SSSLOT		:SEE IF SUSPENDED
	JE	EXE.01			:BR IF NOT
	SBT	R1,ACSLOT		:SUSPENDED, DON'T RUN IT,
	SBT	R1,RNSLOT		:*JUST INDICATE IT COULD BE
	LH	R1,WFLAG,R2		:*AND UNFREEZE IT
	NHI	R1,@FREEZE
	STH	R1,WFLAG,R2
	LA	R1,SUSPWN		:PRINT "SUSPENDED" WARNING
	JAL	R9,OOUT
	J	TTY

EXE.01	JAL	R7,EXSLOT,,		:SET UP SLOT FOR EXECUTION
	 J	BMAC			:HERE IF BAD MAC
	STH	R0,CT.SLT
	LHI	R0,9^2			:SET CODE 9 - DDT
	STH	R0,EFLAG,R8
EXE.5	LM	R0,DRSA,R8		:RESTORE ALL REGISTERS
	J	TTY

BMAC	LA	R1,BADMAC		:BAD MAC, SAY SO
	J	BITCH


:		Command D	(Enable a set of KIO jobs)
:		=========
DF	L	R2,CONTROL,R8		:GET POINTER TO (ONE OF) CONTROLLED JOBS
	JE	TTYERR			:ERROR IF NULL
	LH	R0,UFLAG,R2		:CHECK THAT JOB'S FLAGS
	THI	R0,FKIOJ
	JE	TTYERR			:NON-KIO CONTROLLED JOBS NOT STARTED THIS WAY
	L	R3,OTHER,R2		:GET POINTER TO NAME DESCRIPTOR
	LHI	R0,@2000		:TURN OFF LOCK BIT
	NH	R0,GGUSE,R3
	STH	R0,GGUSE,R3		:THAT NAME CAN NOW LOG INTO CONTROLLED SLOTS
	J	TTY



:		Command ^	(Transfer to another slot)
:		=========
TRANS	JAL	R9,NUM			:WHAT DOES HE WANT TO TRANSFER TO?
	LIS	R1,6			:SET TYPE OF TRANSFER TO DO
TRANS1	SVC	KIO,0,R1		:TRY TRANSFER
	J	TTY			:OUT OF PORTS
	J	TTY			:NO SLOT
	J	TTY			:INSUFFICIENT LICENCE
	J	TTYERR			:BAD KEY...MAKE HIM RETRY


:	....................................................................
:		Command Z	(Zap circuit)
:		=========
:	....................................................................
					:
ZAPP	LA	R1,ZAPMSG		:
	JAL	R9,OOUT			:MAKE SURE USER USER WANTS TO LOG OUT
	JAL	R1,INCHAR		:READ A CHAR
	JAL	R1,CUC			:CONVERT TO UPPER CASE
	CLHI	R0,0D9			:IS IT A "Y"?
	JEFS	ZAPP0			:Yes, go ahead to zap the circuit...
	CLHI	R0,0DA			:Is it a "Z"?
	JN	TTY			:NO - IGNORE
ZAPP0	SVC	KIO,0			:DISCONNECT
					:
					:
  IF	SHARE				:
   IF	NDISC!MSCDSK			:
					:
:	....................................................................
:	SAVE(UNIT,BLOCK,ADDRESS,COUNT) (SS)
:	SAVE(VADDR,COUNT,ADDRESS) (S)
:	....................................................................
					:
SAVE	ST	R9,SLINK,R8		:SAVE LINK FOR MTST FAILURES
	LA	R7,TRO			:CHECK READ ACCESS
	LHI	R6,0D3			:"S"
	JAL	R9,HLS			:SET UP DISK I/O
	THI	R1,SS			:AREA MUST HAVE SAVE ATTRIBUTE
	JNFS	SAVE1			:
	LA	R1,SSERR		:
	J	BITCH			:
SAVE1	LIS	R0,1			:SET WRITE
	JFS	LOAD1			:USE SAME CODE AS LOAD (L)
					:
:	....................................................................
:	WARNING: BREAKPOINTS ARE NOT CLEARED! 
:		 USE "I" COMMAND IF DESIRED.
:	LOAD (UNIT,BLOCK,ADDRESS,COUNT) (LL)
:	LOAD(VADDR,COUNT,ADDRESS) (L)
:	....................................................................
					:
LOAD	ST	R9,SLINK,R8		:SAVE LINK FOR MTST FAILURES
	LA	R7,TRO			:ONLY READ ACCESS IS REQUIRED
	LHI	R6,0CC			:"L"
	JAL	R9,HLS			:SET UP DISK I/O
	LIS	R0,0
LOAD1	STB	R0,HDISK,R8
	SVC	QIO,HDISK,R8		:ISSUE DISK READ/WRITE
	LB	R0,HDISK,R8		:CHECK RETURN STATUS
	JE	TTY			:NO DISK ERROR - RETURN
	CLHI	R0,9			:WAS REQUESTED ABANDONED BY QUIT CHAR?
	JE	TTY			:RETURN IF SO
	LA	R1,LERR
	JAL	R9,OOUT			:ISSUE STOCK MESSAGE
	L	R0,HDISK,R8
	LIS	R1,8			:PRINT IN FORM "SSUUCCDD"
					:SS = STATUS CODE
					:UU = UNIT
					:CC = CONTROLLER STATUS BYTE
					:DD = UNIT STATUS BYTE
	JAL	R9,ACONV		:
	JAL	R9,DOCRLF		:
	J	TTY			:
					:
:	.......................................................................
:	UTILITY ROUTINE TO SET UP DISK I/O
:	SET UP OUR "HDISK", RETURN ATRIBUTES IN R1
:	.......................................................................
					:
HLS	ST	R9,ULINK,R8		:SAVE LINK
   IF	SUP				:
	JAL	R9,PEEK			:
	JAL	R1,CUC			:
	CLR	R0,R6			:LOOK FOR "LL" OR "SS"
	JN	HLS2			:IF NOT, OLD ADDR FORMAT
	JAL	R9,CHARM		:CONSUME CHAR
   ELSE					:
	JAL	R2,GETCHAR		:GET SECOND COMMAND CHAR
	NOP	0			:DON'T CARE ABOUT SKIP RETURNS
	JAL	R1,CUC			:CONVERT TO UPPER CASE
	XR	R0,R6			:VERIFY "LL" OR "SS" COMMAND
	JN	TTYERR			:ANYTHING ELSE IS ERROR
   EI  (SUP)				:
	JAL	R9,NUM			:READ UNIT NO.
	LR	R5,R0			:R5 = UNIT
	JAL	R9,NUM			:READ BLOCK NO.
	LR	R6,R0			:R6 = BLOCK
	JAL	R9,NUM			:READ CORE ADDRESS
	LR	R15,R0			:R15 = START ADDRESS
	JAL	R9,NUM			:READ NUMBER OF BYTES
	LR	R12,R0			:R12 = NO. OF BYTES
	JNFS	.+6
	LHI	R12,100			:DEFAULT 1 SECTOR
	LO	SHARE
HLS0	ST	R12,HDISK+SVC.CT,R8
	STB	R5,HDISK+SVC.LU,R8
	ST	R6,HDISK+SVC.VB,R8
	ST	R15,HDISK+SVC.VA,R8
	AR	R12,R15			:SET UP READ/WRITE ACCESS TEST
	SIS	R12,1			:ENDING CORE ADDRESS
	LIS	R0,5			:POSITION OF MAC BIT IN 2ND HALF WORD OF PSW
	TBT	R0,SPSW,R8		:IS USER RUNNING MAPPED?
	JNFS	HLS00			:YES - TRANSLATE ADDR
	CL	R12,MEMTOP		:IS IT IN RANGE?
	JLFS	HLS1			:IF SO, CONTINUE
	J	VERR1
HLS00	JAL	R9,MTST			:CHECK ACCESS TO RANGE
	LR	R0,R15
	JAL	R9,TRASL,,		:CONVERT USER ADDR TO PHYSICAL ADDR
	 J	BMAC
	ST	R0,HDISK+SVC.VA,R8	:USE THIS ADDR IN DISK PARAM BLK
HLS1	LB	R1,HDISK+SVC.LU,R8	:RECOVER UNIT NO.
	FO	SHARE
	AR	R1,R1			:MAKE HALFWORD INDEX
	LH	R1,LUT,R1,R8		:RETRIEVE UNIT PROTECTION
	L	R9,ULINK,R8		:RESTORE LINK
	JR	R9			:RETURN
	IF	SUP
HLS2	JAL	R9,NUM			:READ VIRTUAL DISK ADDR
	LR	R5,R0
	LR	R6,R0			:COPY IT
	SRLS	R5,0D			:R5 = UNIT
	NHI	R6,1FFF
	SLLS	R6,2			:R6 = BLOCK NO. TO START
	JAL	R9,NUM			:READ NO. OF 1024-BYTE BLOCKS
	LR	R12,R0
	SLLS	R12,0A			:R12 = BYTE COUNT
	JAL	R9,NUM			:READ ADDR
	LR	R15,R0			:R15 = STARTING MEMORY ADDR
	J	HLS0
	EI	(SUP)

:	COMMANDS (UNIT,ADDRESS) (K)
:	TAKES DDT COMMANDS FROM STRING CONSTANTS PREVIOUSLY SAVED
KOM	LHL	R5,BUFNO,R8		:INTERNAL PORT INDEX (IPX)
	LR	R7,R5
	AR	R7,R7			:DOUBLE IPX
	JAL	R9,NUM			:READ UNIT NO.
	LHI	R6,-1
	THI	R0,-100
	JN	KOM1			:SWITCH COMMANDS OFF IF NO UNIT SPECIFIED
	LR	R6,R0			:SAVE UNIT
	JAL	R9,NUM			:READ BLOCK NO.
	SBT	R5,DPACT,,		:ACTIVATE COMMAND PROCESSOR
KOM1	ST	R0,DPBN,R7,R7
	STH	R6,DPUN,R7,
	LIS	R0,0
	STB	R0,DPBX,R5,		:ZERO BYTE INDEX
	STB	R0,DPLRL,R5,		:ZERO RECORD LENGTH
	J	TTY
	EI	(NDISC!MSCDSK)
	EI	(SHARE)

	SUBTTL	Q U E R I E S
					:
QUERY	LIS	R3,0			:SET ACCUMULATOR = 0
QUERY1	JAL	R2,GETCHAR		:GET ANOTHER CHARACTER
	NOP	0			:DON'T CARE ABOUT SKIP RETURNS
	JAL	R1,CUC			:CONVERT CHAR TO UPPER CASE
	JAL	R2,ZDLIM		:CHECK FOR DELIMITER
	J	QUERY2			:GOT ONE...SKIP TO PROCESS
	TI	R3,0FF000000		:HAVE WE 4 CHARS ALREADY?
	JNBS	QUERY1			:YES...SCAN FOR DELIMITER
	SLLS	R3,8			:NO...ACCUMULATE CHARS
	STBR	R0,R3			:
	J	QUERY1			:AND GET ANOTHER CHAR
QUERY2	LHI	R1,NQUERY-8		:SEARCH FOR STRING MATCH
QUERY3	C	R3,QUERYL,R1		:
	JE	QUERYL+4,R1		:DO IT IF FIND A MATCH
	SIS	R1,8			:ELSE CONTINUE SCAN
	JGEBS	QUERY3			:
	J	QCOM			:SEE IF USER DEFINED COMMAND HANDLER
QUERYL	QENTRY(1,B,QB)			:QUERY BREAKPOINTS
	QENTRY(4,BOOT,QBOOT)		:PUT MACHINE IN BOOT
	QENTRY(4,HALT,QHALT)		:Halt a slot job?
	QENTRY(4,DASH,QDASH)		:disable auto slot halt?
	QENTRY(3,WHO,QWHO)		:QUERY WHO
	QENTRY(4,EDBG,QEDBG)		:ENTER DEBUG
	QENTRY(4,LDBG,QLDBG)		:LEAVE DEBUG
	QENTRY(2,LU,QLU)		:QUERY LOGICAL UNITS
   IF	NSLOT				:
	QENTRY(4,TRAN,QTRAN)		:QUERY TRANSFER LU
   EI  (NSLOT)				:
   IF	NSLOT!MXP			:
	QENTRY(2,CT,QCT)		:QUERY PORTS TERMINATING
	QENTRY(4,HOST,QHOST)		:QUERY HOST STATUS
	QENTRY(3,USE,QUSE)		:QUERY USAGE
   EI  (NSLOT!MXP)			:
   IF	SYSMON				:
	QENTRY(3,SYS,QSYS)		:GET SYSTAT VARIABLES
   EI  (SYSMON)				:
   IF	MACV				:
   ELSE					:
	QENTRY(3,MEM,QMEM)		:QUERY ZITEL MEMORY ERRORS
   EI  (MACV)				:
   IF	FSYS				:
	QENTRY(4,SAVE,QSAV)		:SAVE SLOT IMAGE
	QENTRY(4,NAME,QRNAM)		:RENAME FILE
	QENTRY(4,SSEG,QSSEG)		:SAVE SPECIFIED SEGMENTS
	QENTRY(4,REST,QRES)		:RESTORE SLOT IMAGE
	QENTRY(4,WRIT,QGET)		:GRAB THE FILE  SYSTEM
	QENTRY(4,CLOS,QREL)		:RELEASE THE FILE  SYSTEM
	QENTRY(4,DELE,QDEL)		:DELETE FILE
	QENTRY(4,READ,QOPEN)		:OPEN FOR READ
	QENTRY(4,LIST,QLIS)		:LIST FILES
	QENTRY(4,INIT,QFOR)		:INITIALIZE DISC SYSTEM
   EI  (FSYS)				:
	QENTRY(4,FREZ,QFREZ)		:FREEZE
	QENTRY(4,THAW,QTHAW)		:THAW
	QENTRY(4,LMAC,QLMAC)		:SET MAC
	QENTRY(3,MAC,QMAC)		:QUERY MAC
	QENTRY(3,ABS,QABS)		:QUERY ABS ADDRESS
	QENTRY(4,SLOT,QSLOT)		:QUERY SLOT
	QENTRY(2,BT,QBT)		:QUERY BACKGROUND PSW
	QENTRY(2,FT,QFT)		:QUERY FOREGROUND PSW
	QENTRY(3,BRR,QBRR)		:QUERY BACKGROUND REGISTERS
	QENTRY(3,FRR,QFRR)		:QUERY FOREGROUND REGISTERS
	QENTRY(3,RET,QRET)		:QUERY RETURN
	QENTRY(4,STAT,QSTAT)		:QUERY STATUS
	QENTRY(4,PROF,QPROF)		:Query ISIS system configuration profile
	QENTRY(4,VERN,QVERN)		:QUERY VERSION NUMBER
	QENTRY(4,PORT,QPORT)		:QUERY KERNEL PORTS
	QENTRY(4,HANG,QHANG)		:HANG KERNEL PORT (COMMAND)
	QENTRY(3,CPU,QCPU)		:EXAMINE CPU USE
	QENTRY(4,TIME,QTIME)		:TELL SYSTEM TIME (SLOWC)
	QENTRY(4,DIAG,QDIAG)		:FLUSH DIAGNOSTICS
	QENTRY(4,HIST,QHIST)		:OUTPUT ALL HISTORY OF DIAGNOSTICS
        QENTRY(4,SMAC,QSMAC)		:
   IF	SPAM				:
        QENTRY(4,SPAM,QSPAM)            :OUTPUT SPAM STATISTICS
   EI  (SPAM)				:
   IF   MACTRC		                :IF MAC HARDWARE TRACE
        QENTRY(4,PTRC,QPTRAC)           :ENTER MAC TRACE PARAMETERS
        QENTRY(4,STRC,QSTRAC)           :START/STOP MAC TRACE
        QENTRY(4,DTRC,QDTRAC)           :DISPLAY TRACE DATA
   EI  (MACTRC)				:
	QENTRY(4,BRST,QBRST)		:RESET BACKGROUND EXEC COUNTERS
	QENTRY(4,BDSP,QBDSP)		:DISPLAY BACKGROUND EXEC COUNTERS
   IF	MULTI				:Multi-Kernels and KIO(s) are defined
	QENTRY(4,SRNG,QSRING)		:Display Kernel/User I/O ring status
	QENTRY(4,SRHI,QSRHIS)		:Display SIO ring copy int. history
	QENTRY(4,SINI,QSRINI)		:Initialize SIO ring card
   EI  (MULTI)				:
NQUERY	EQ	.-QUERYL		:LENGTH OF TABLE

   IF	FSYS				:

:	.....................................................................
:
:		* THIS SECTION OF THE CODE IS A SIMPLE  FILE  MANAGER *
:
:	(1) IT IS USED TO SAVE SLOTIMAGES ON DISC AND RESTORE THEM TO CORE
:	(2) IT IS SINGLE PROCESS (ALLOWING ONE  USER AT A TIME)
:	(3) IT IS ACCESSIBLE FROM  THE  ?SAVE,?DELE,?REST,?WRIT,?READ,?SSEG,
:	    ?INIT,?LIST COMMANDS. THE FILES RESIDE ON A DISC AREA WHOSE UNIT
:	    NUMBERIS FSYS, AND ANY USER SLOT MUST HAVE A LOGICAL UNIT NUMBER
:	    WHICH IS EQUAL TO FSYS,AND POINTS THE THE COMMON GLOBAL UNIT THE
:	    FILES ARE WRITTEN IN 256 BYTE CHUNKS,EACH 256 BLOCK IS ALLOCATED
:	    FROM THE FREE LIST FILE.  FILES HAVE NAMES UP TOEIGHT BYTES LONG
:	    AND THE NAMES ARE  USED ASTHE ARGUMENTS COMMANDS
:
:	.....................................................................
					:
LFIL	HS	0			:R8 OF FSYS SYSTEM
GETS	EQ	0A			:SHARE OPERATION TO GET UNIT STATUS
FREE	EQ	0C6D2C5C5		:NAME FREE LIST FILE
BLKSZ	EQ	100			:UNIVERSAL DATA BLOCK SIZE
FWRT	EQ	1			:DISC WRITE BLOCK COMMAND
FRRD	EQ	0			:DISC READ COMMAND
STAT	HS	1			:PARMS BLOCK FOR FORMAT ROUTINE
	HS	1			:CONTROLLER STATUS
PM	BS	1			:
GU	BS	1			:
NAM	HS	1			:
TYP	BS	1			:
DA	BS	1			:
DBS	HS	1			:
BPT	HS	1			:
TPC	HS	1			:
STC	HS	1			:
NMC	HS	1			:
					:
:	.......................................................................
:	WHEN WRITING TO A FILE, COMPRESSION MAY TAKE PLACE
:	IF SO THEN FLAG FCOMP IS SET -1
:	.......................................................................
					:
FCHSAV	HS	1			:TEMPORARY STORAGE
FCOMP	HS	1			:SET TO -1 WHEN COMPRESSING
FCOUNT	EQ	10			:COMPRESS ONLY WHEN THIS MANY OR MORE
					:
:	.......................................................................
:	THE FILE IS OPEN FOR READ XOR WRITE -1 IN FMODE SIGNIFIES READ, 0 WRITE
:	.......................................................................
					:
FSTRT	HS	0			:ZERO ALL STARTING HERE
FMODE	HC	0			:SPECIFIES FILE READ OR WRITE
FFMSK	HC	0			:TEMP STORAGE FOR SSEG COMMAND
NBLOK	WS	1			:SIZE IN BLOCKS,THIS UNIT
STBYTE	WS	1			:START BYTE WHEN SAVING IMAGE TO DISC
NBYTE	WS	1			:NUMBER  BYTES WHEN SAVING
MACOK	HC	0			:NEGATIVE WHEN MAC MAPPING IS AVAILABLE
DREADY	HC	0			:THIS FLAG =-1 WHEN DISC IS FORMATTED
INUSE	HS	1			:SET TO -1 WHEN SYSTEM IN USE
FUSER	WS	1			:CURRENT DISC USER
					:
:	.......................................................................
:	THE DIRECTORY IS COMPOSED OF ONE OR MORE BLOCKS FOR EACH DIRECTORY
:	BLOCK THE FIRST WORD IS THE LINK TO THE NEXT DIRECTORY BLOCK,  THE
:	SECOND WORD IS THE NUMBER OF DIRECTORY ELEMENTS * $A16,  FOLLOWING
:	THIS IS A LIST OF 15 HEADER ENTRIES LAYOUT OF A  DIRECTORY ENTRY
:	THE FIRST WORD IS THE FIRST HEADER BLOCK THE 2ND WORD IS THE NUMBER
:	OF DATA BLOCKS THE THIRD AND FORTH WORD IS AN 8 BYTE NAME
:	.......................................................................
					:
DDCUR	WS	1			:BLOCK NUMBER CURRENT DIRECTORY BLOCK
DDLNK	WS	1			:LINK TO NEXT DIRECTORY BLOCK
DDSIZ	EQ	$0 10			:SIZE OF A DIRECTORY ENTRY
DDNMB	EQ	((BLKSZ-8)/DDSIZ)*DDSIZ	:SIZE OF FULL DIRECTORY BLOCK
DDNDX	WS	1			:NUMBER ENTRIES *$A16 IN THIS BLOCK
DDLST	WS	(BLKSZ-8)/4		:SPACE FOR ENTRIES
					:
:	.......................................................................
:			FILE HEADER DESCRIPTOR
:	A FILE HEADER IS A LIST  OF DATA BLOCKS FOR THE FILE THEY ARE LINKED
:	BY THE FIRST WORD IN EACH HEADER SET ASIDE STORAGE FOR ONE FILE HEADER
:	BLOCK ONLY ONE FILE IS OPEN AT A TIME
:	.......................................................................
					:
HHSEQ	WS	1			:File sequence number
HNAME	WS	2			:File name 8 bit ascii
HHCUR	WS	1			:Block number of this header block
HHLNK	WS	1			:Link to next header block
HHNDX	WS	1			:Number elements (*12) in this header
					:
:	.......................................................................
:	A HEADER ELEMENT HAS ONE WORD DATA BLOCK NUMBER
:	NEXT WORD USER'S ASSIGNED ADDRESS
:	THIRD IS NUMBER BYTES IN BLOCK
:	.......................................................................
					:
HRSIZE	EQ	3*4			:SIZE OF HEADER ELEMENT
HNUMB	EQ	HRSIZE*$A20		:NUMBER BYTES ALLOCATED FOR ELEMENT LIST
HHLST	WS	(BLKSZ-8)/4		:LIST OF DATA BLOCKS THIS HEADER
					:
:	.......................................................................
:	THE FREE LIST IS A SET OF SPECIAL HEADERS CONTAINING DISC BLOCKS
:	AVAILABLE FOR USE
:	.......................................................................
					:
FFLNK	WS	1			:LINK TO NEXT FREE LIST HEADER
FFNDX	WS	1			:NUMBER ELEMENTS (*4) IN THIS HEADER
FFLST	WS	(BLKSZ-8)/4		:LIST OF FREE DATA BLOCKS
					:
:	.......................................................................
:	THE FREE LIST IS SIMILIAR TO A REGULAR FILE BUT IT REMAINS PERMANENTLY
:	OPEN IT IS THE FIRST DIRECTORY ENTRY BUT SINCE THE FIRST DIRECTORY
:	BLOCK MAY NOT ALWAYS BE IN CORE IT IS NECESSARY TO KEEP A PERMANENT
:	 COPY OF OF THE FREE LIST DIRECTORY ENTRY IN CORE
:	.......................................................................
					:
FFCUR	WS	1			:CURRENT FREE LIST HEADER
FFCNT	WS	1			:NUMBER FRRE BLOCKS
					:
:	.......................................................................
:	AREA FOR DATA BLOCK  WHEN MANIPULATING A  FILE
:	.......................................................................
					:
DADDR	WS	1			:VIRTUAL ADDRESS OF DATA IN CORE
DSIZE	WS	1			:NUMBER OF BYTES THIS DATA BLOCK
DBUF	HS	$A128			:DATA BLOCK FOR ALL DATA BLOCK DISC TRANSFERS
FZEND	HS	0			:FINISH ZEROING HERE
					:
:	.......................................................................
:	PARAMETER BLOCK  FOR ALL  DISC TRANSFERS
:	.......................................................................
					:
	BND	4			:
Q	BS	1			:
	BC	FSYS			:
	HS	1			:
QQ	WS	1			:
	WC	BLKSZ			:
QQQ	WS	1			:
					:
:	.......................................................................
:	MACRO TO READ OR WRITE
:	r1 MUST POINT TO BLOCK NUMBER
:	A SHARED OPERATION IS ALWAYS DONE WITH A CALL TO DOOP
:	A DISC ARROR EXIT MAY BE TAKEN FROM DOOP
:	THE ADDRESS OT THE DATA IN CORE IS LISTED
:	RIGHT AFTER THE CALL INSTRUCION, ALONG WITH
:	THE OPERATION.  THE RETURN SKIP EIGHT BYTES
:	.......................................................................
					:
SHOP	MACRO(OP,ADDR)[
	JAL	R2,DOOP
	HC	ADDR-LFIL
	HC	OP
]
					:
:	.......................................................................
:	GENERAL ROUTINE TO PERFORM SHARED OPERATION
:	LINK R2
:	.......................................................................
					:
DOOP	STM	R0,RBBF			:
	LHL	R0,2,R2			:GET REQUESTED OPERATION
	STB	R0,Q			:PLACE IT IN IO PARAMETER BLOCK
	LHL	R0,0,R2			:GET ADDRESS OF DATA BLOCK
	AI	R0,LFIL			:ADD OFFSET
	ST	R0,QQ			:PLACE IN IO PARAMETER BLOVK
	ST	R1,QQQ			:R1 CONTAIND DISC BLOCK NUMBER
	SVC	4,Q			:ISSUE REQUEST
	LB	R0,Q			:CHECK RESULT
	JEFS	DOOP0			:SKIP AHEAD NO ERROR
	SIS	R0,9			:ERROR NINE IS OK
DOOP0	JN	FILDISC			:OTHER THAN ZERO IS SOME ERROR
					:
:	.......................................................................
:	TYMSHARE HARDWARE USUALLY DOESNT WORK
:	.......................................................................
					:
	LA	R1,TBBF			:DOUBLE CHECK HARDWARE
	ST	R1,QQ			:
	SVC	4,Q			:
	LB	R0,Q			:
	JEFS	DOOP1			:
	SIS	R0,9			:
DOOP1	JN	FILDISC			:
	LHL	R2,0,R2			:
	AI	R2,LFIL			:
	LHI	R3,BLKSZ		:
DOOP2	SIS	R3,1			:
	JL	DOOP3			:
	LB	R0,0,R3,R2		:
	CLB	R0,0,R3,R1		:
	JN	FILDISC			:
	J	DOOP2			:
DOOP3	LM	R0,RBBF			:
	J	4,R2			:DO SKIP RETURN
RBBF	WS	10			:
TBBF	BS	100			:
					:
:	.......................................................................
:	OPEN FILE FOR READING
:	.......................................................................
					:
QOPEN	JAL	R7,FSET			:GET SET UP
	JAL	R4,GTFNAM		:GET REQUESTED  FILE
	JAL	R3,FNDFIL		:FIND IT IN THE LIST
	J	FILNOT			:DONT EXIST,JUST RELEASE FILE SYSTEM
	L	R0,DDLST,R1		:GET HEADER START
	JE	FILERR			:SERIOUS FILE BUG
	JAL	R4,FOPEN		:OPEN REQUESTED FILE
	LCS	R0,1			:SET READ MODE
	STH	R0,FMODE		:PLACE IT
	J	TTY			:FILE NOW READY FOR SUBSEQUENT READ
					:
:	.......................................................................
:	EXECUTION OF THIS COMMAND  CAUSES ALL 'WRITE' DATA TO BE SENT TO DISC,
:	RATHER THAN CORE
:	.......................................................................
					:
QGET	JAL	R7,FSET			:SET UP  TO USE SYSTEM
	JAL	R4,GTFNAM		:GET HIS FILENAME
	JAL	R3,FNDFIL		:SEE IF IT EXISTS
	J	QGET0			:NO,SKIP AHEAD
	JAL	R5,FDEL			:ELSE DELETE IT
QGET0	JAL	R4,MKFIL		:ELSE MAKE ROOM IN DIRECTORY
	L	R1,HHSEQ		:GET SEQUENCE NUMBER
	LHL	R0,DDLST,R1		:GET BLOCK NUMBER OF FIRST HEADER
	JN	FILERR			:SERIOUS BUG IN  FILE SYSTEM
	JAL	R4,FOPEN		:THEN OPEN IT
	LIS	R0,0			:SET WRITE MODE
	STH	R0,FMODE		:PLACE IT
	J	TTY			:GET NEXT COMMAND
					:
:	.......................................................................
:	RELEASE FILES
:	THE FILE SYSTEM MUST BE RELEASED WHICH INCLUDES  THE CLOSING OF THE
:	OPEN FILE
:	.......................................................................
					:
QREL	C	R8,FUSER		:PROPER  OWNER?
	JN	TTY			:IGNORE WRONG OWNER
	LH	R0,FMODE		:CHECK MODE
	JL	FREL			:NO NEED TO CLOSE READ ONLY FILE
	JAL	R3,FCLOS		:CLOSE ANY FILE USER MAY HAVE OPENED
					:
:	.......................................................................
:	CHECK FOR AND DELETE FILE WITH NO DATA
:	.......................................................................
					:
	L	R1,DDCUR		:READ IN CURRENT DIRECTORY
	SHOP(FRRD,DDLNK)		:
	L	R1,HHSEQ		:GET SEQUENCE NUMB
	L	R1,DDLST,R1		:GET FIRST HEADER BLOCK
	SHOP(FRRD,HHLNK)		:
	L	R1,HHLNK+4		:GET NUMB OF ELEMENTS - IF ELEMENTS
	JNFS	FREL			: THEN KEEP FILE
	JAL	R5,FDEL0		:ELSE, DELETE IT
FREL	TS	FUSER			:SET FILE SYSTEM 'UNOWNED'
	LIS	R0,0			:
	STH	R0,INUSE		:MARK IT AVAILABLE
	J	TTY			:GET NEXT COMMAND
					:
:	.......................................................................
:	LIST  FILES
:	.......................................................................
					:
QLIS	JAL	R7,FSET			:FIRST GRAB THE SYSTEM
	LIS	R1,0			:ELSE GET THE FIRST
FLST0	SHOP(FRRD,DDLNK)		:READ NEXT HEADER
	LHI	R2,-10			:STARTING WITH FIRST ELEMENT
FLST1	AHI	R2,10			:FOR EACH ENTRY
	C	R2,DDNDX		:UNLESS DONE
	JL	FLST2			:SKIP TO LIST IT
	L	R1,DDLNK		:GET NEXT DIRECTORY BLOCK
	JE	FREL			:UNLESS THATS ALL
	J	FLST0			:GET NEXT DIRECTORY BLOCK
FLST2	L	R0,DDLST+4,R2		:GET NUMBER BLOCKS
	LHI	R1,830			:EIGHT DIGITS,BLANK FILL
	SVC	KIO,$A 10		:OUTPUT
	SVC	OUT,BLBL		:PRECEDE NAME WITH TWO BLANKS
	LIS	R3,0			:GET AN INDEX
FLST3	LB	R0,DDLST+08,R2,R3	:GET A BYTE OF NAME
	JE	FLST4			:DONE
	SVC	KIO,$A14		:OUTPUT IT
	AIS	R3,1			:BUMP CHARACTER INDEX
	CLHI	R3,8			:DONE?
	JL	FLST3			:NO,OUTPUT NEXT BYTE
FLST4	SVC	OUT,CRLF		:TERMINATE NAME WITH CARRAIGERETURN
	J	FLST1			:LIST NEXT FILE
					:
:	....................................................................
:	INITIALIZE DISC SYSTEM AND THIS ERASES ANY FILES
:	....................................................................
					:
QFOR	LH	R7,ULICEN,R8		:MUST HAVE LICENCE TO DO THIS
	NHI	R7,L.DISC		:
	JE	LICERR			:
					:
QFOR0	TS	INUSE			:MAKE SURE NOT USED
	JGE	QFOR1			:WE HAVE IT
	SVC	DISMISS,0		:WAIT FOR OTHER USER
	J	QFOR0			:TRY AGAIN
QFOR1	JAL	R6,DINIT0		:DO IT
	TS	DREADY			:SET DISC READY
	J	FREL			:AND RELEASE SYSTEM
					:
:	....................................................................
:	QDEL - DELETE A GIVEN FILE
:	....................................................................
					:
QDEL	JAL	R7,FSET			:GET SET UP
	JAL	R4,GTFNAM		:GET FILENAME FROM USER
	JAL	R3,FNDFIL		:FIND FILE AMONG DIRECTORY
	J	FILNOT			:NOT THERE
	JAL	R5,FDEL			:DELETE FILE
	J	FREL			:DONE,RELEASE SYSTEM
					:
:	....................................................................
:	QRNAM - RENAME OLD FILE TO NEW FILE
:	....................................................................
					:
QRNAM	JAL	R7,FSET			:GRAB THE 'SYSTEM'
	JAL	R4,GTFNAM		:GET OLD FILE NAME
	JAL	R3,FNDFIL		:FIND IT
	J	FILNOT			:SKIP,NOT EXIST
	JAL	R4,GTFNAM		:GET SECOND NAME
	L	R1,HHSEQ		:GET SEQUENCE NUMBER
	LM	R14,HNAME		:GET NEW NAME
	STM	R14,DDLST+8,R1		:SAVE IT
	L	R1,DDCUR		:GET CURRENT DIRECTORY BLOCK
	SHOP(FWRT,DDLNK)		:
	J	FREL			:
					:
:	....................................................................
:	QSSEG - SAVE FROM CORE SPECIFIED SEGMENTS
:	....................................................................
					:
QSSEG	JAL	R7,FSET			:GET SET UP
	JAL	R9,NUMA			:GET USERS MASK
	JFS	QSEG0			:ENTER QSAV CODE
					:
:	....................................................................
:	QSAV - SAVE SLOT IMAGE TO DISC
:	....................................................................
					:
QSAV	JAL	R7,FSET			:GET SET UP
	LHL	R0,FSSEG,R8		:GET PROPER MASK
QSEG0	STH	R0,FFMSK		:PLACE IT
	JAL	R4,GTFNAM		:GET REQUESTED FILENAME
	JAL	R3,FNDFIL		:SEE IF IT EXISTS
	J	QSAV1			:NO,SKIP AHEAD
	JAL	R5,FDEL			:ELSE DELETE OLD
QSAV1	JAL	R4,MKFIL		:MAKE A NEW FILE
	L	R1,HHSEQ		:RECOVER SEQUENCE NUMBER
	LHL	R0,DDLST,R1		:GET HEADER START
	JN	FILERR			:SERIOUS FILE BUG
QSAV2	JAL	R4,FOPEN		:OPEN THE FILE
QSAV3	LHL	R6,FFMSK		:GET MASK
	JFFOH	R6,.+6			:FIND NEXT ONE
	J	QSAVX			:ELSE DONE
	RBT	R7,FFMSK		:MARK IT DONE
	SLHLS	R7,2			:MAKE A WORD INDEX
	L	r4,MPROT,R8,R7		:GET THE MAC VALUE
	JLE	QSAV3			:IGNORE SHARED OR  NOT PRESENT
	LIS	R6,0			:MAKE BYTE INDEX
	LR	R0,R4			:GET A COPY
	NI	R0,MMASKR		:ISOLATE START ADDRESS
	SRLS	R0,MSHFTA		:MAKE ADDRESS
	ST	R0,STBYTE		:SAVE IT
	NI	R4,MMASKL		:MASK LENGTH
	SRL	R4,MSHFTL		:RIGHT JUSTIFY LENGTH
	AIS	R4,1			:ROUND UP
	SLLS	R4,MSHFTB		:MAKE PAGES INTO BYTES
	ST	R4,NBYTE		:SAVE IT
	LIS	R2,0			:GET A NULL
	ST	R2,DSIZE		:ZERO CHARACTER INDEX
	EXHR	R0,R7			:POSITION SEG NUMBER
	SRLS	R0,2			:
	ST	R0,DADDR		:THIS IS VIRTUAL ADDRESS
QSAV5	L	R1,STBYTE		:GETSTART BYTE
	LB	R0,0,R1,R6		:Get next byte
	AIS	R6,1			:BUMP CHAR COUNT
	JAL	R5,PUTDISC		:SEND CHARACTER
	LCS	R0,1			:GET SUBTRACTOR
	AM	r0,nbyte		:Decrement count of bytes
	JLEFS	QSAV6			:DONE  WITH THIS SEGMENT
	J	QSAV5			:CONTINUE WITH OLD DATA BLOCK
QSAV6	L	R4,DSIZE		:ELSE, IF ANY THING TO WRITE
	JLEFS	QSAV7			:
	JAL	r4,WRTB			:write it out
QSAV7	J	QSAV3			:ELSE, TRY NEXT SEGMENT
QSAVX	JAL	R3,FCLOS		:ALL SEGMENTS SCANNED
	J	FREL			:RELEASE SYSTEM
					:
:	.......................................................................
:	RESTORE SLOT IMAGE FROM DISC
:	.......................................................................
					:
QRES	JAL	R7,FSET			:GET SET UP
	JAL	R4,GTFNAM		:GET REQUESTED  FILE
	JAL	R3,FNDFIL		:FIND IT IN THE LIST
	J	FILNOT			:NOT EXISTING
	L	R0,DDLST,R1		:GET HEADER START
	JE	FILERR			:SERIOUS FILE BUG
	L	R1,CONTROL,R8		:FIND CONTROLLED JOB
	LHL	R1,UFLAG,R1		:CHECK TYPE JOB
	THI	R1,FDISP		:OTHERS HAVE MAC SET
	JE	QRES1			:SKIP IF NOT DISPATCHER
	LI	R0,0E0000		:LOCATING SEGMENT E
	ST	R0,STBYTE		:PUT REQUEST IN LOCATION
	JAL	R5,FNDBLK		:FIND BLOCK CONTAINING SEGMENT E
	JAL	R3,OUTB			:OUTPUT BLOCK(ALSO SETS UP MAC)
	SVC	SYS,$A 21		:TRY TO SET UP MAC
	J	FILMAC			:SOME ERROR HERE
QRES1	JAL	R4,FOPEN		:OPEN REQUESTED FILE
	LIS	R5,0			:R5 HAS HEADER INDEX NUMBER
QRES2	C	R5,HHNDX		:DONE THIS HEADER
	JL	QRES3			:NO,READ IT
	L	r1,HHLNK		:YES,GET NEXT
	JE	FREL			:LAST ONE,FINISH
	ST	r1,HHCUR
	SHOP(FRRD,HHLNK)		:PERFORM READ TRANSFER
	LIS	R5,0			:RESET INDEX
QRES3	LR	R2,R5			:GET COPY OF INDEX
	JAL	r3,READB		:READ REQUESTED BLOCK
	JAL	R3,OUTB			:PASS DATA TO USERS CORE
	AIS	R5,HRSIZE		:POINT TO NEXT ENTRY
	J	QRES2			:CONTINUE FOR NEXT BLOCK
					:
:	.......................................................................
:	THE DISC MUST BE KEPT CONSISTANT AT ALL TIMES.
:	THE RULE FOR DOING THIS IS SIMPLY TO UPDATE THE DIRECORY, FREE LIST
:	HEADER AND FILE HEADER EACH TIME A FILE IS CLOSED UPDATING ANY HEADERS
:	IS NOT NECESSARY DURING THE LONG TIME A FILE IS OPENFOR READ BECAUSE
:	ONLY FREE BLOCKS WILL BE WRITTEN TO DURING THAT PERIOD FORMAT DISC
:	LINK ON R6
:	.......................................................................
					:
DINIT	LIS	R1,0			:READ FIRST BLOCK IN UNIT
	SHOP(FRRD,DDLNK)		:READ IT IN
	L	R0,DDLST+8		:GET FIRST NAME
	CI	R0,FREE			:IS IT THE CORRECT
	JN	DINIT0			:NO,START FRESH
	L	R0,DDLST+4		:GET FREE LIST COUNT
	ST	R0,FFCNT		:KEEP A RECORD
	L	R1,DDLST		:GET FIRST FREE LIST HEADER
	ST	R1,FFCUR		:PLACE IT PROPERLY
	SHOP(FRRD,FFLNK)		:READ IT
	JR	R6			:DONE
DINIT0	LIS	R0,0			:GET A NULL
	LHI	r1,FZEND-FSTRT		:ZERO THIS ALL
DINIT1	SIS	r1,2			:...AND FOR EACH HALFWORD
	JL	DINIT2			:UNTIL DONE
	STH	r0,FSTRT,r1		:ZERO IT
	J	DINIT1			:CONTINUE
DINIT2	LHI	R0,GETS^8!FSYS		:MAKE GET STATUS OPERAND
	STH	R0,STAT			:STORE IT IN THE PARMS BLOCK
	SVC	4,STAT			:GET VARIABLES
	LH	r2,NMC			:NUMBER CILINDERS
	LH	R0,TPC			:TRACKS PER CILINDER
	MR	r1,R0			:BEGETS NUMBER TRACKS
	LH	R0,BPT			:AND BLOCKS PER TRACK
	MR	r1,R0			:BEGETS NUMBER BLOCKS
	SIS	R2,1			:SAVE ONE FOR DIRECTORY
	ST	r2,NBLOK		:SAVE NUMBER AVAILABLE
	LI	R0,FREE			:SET UP FREE LIST NAME
	ST	R0,DDLST+8		:SAVE IT
	LHI	R0,10			:NUMBER FILES*10
	ST	R0,DDNDX		:SYSTEM HAS ONE FILE
	LIS	R5,1			:FOR FIRST BLOCK
	ST	R5,FFCUR		:BECOMES 'LAST' AVAILABLE BLOCK
DINIT3	C	R5,NBLOK		:UNLESS DONE
	JL	DINIT4			:SKIP AHEAD,MORE TO DO
	L	R1,FFCUR		:GET CURRENT FREE LIST HEADER
	ST	R1,DDLST		:PLACE IT IN DIRECTORY
	SHOP(FWRT,FFLNK)		:WRITE FREE LIST
	L	R0,FFCNT		:AND FREE LIST COUNT
	ST	R0,DDLST+4		:PLACE IT
	LIS	R1,0			:FOR FIRST DIRECTORY BLOCK
	SHOP(FWRT,DDLNK)		:WRITE IT OUT
	JR	R6			:
DINIT4	AIS	R5,1			:FOR NEXT BLOCK
	LR	R0,R5			:PUTB WANTS BLOCK IN R0
	JAL	R3,PUTB			:PLACE ON FREE LIST
	J	DINIT3			:TRY ANOTHER
					:
:	.......................................................................
:	PUTB -- Puts a block back on the free list
:	Expects r0 to contain the block number
:	LINK R4
:	.......................................................................
					:
PUTB	LIS	R1,1			:PREPARE TO UPDATE COUNT
	AM	R1,FFCNT		:KEEP COUNT
	L	r1,FFNDX		:GET FREE LIST HEADER BLOCK INDEX
	CLHI	R1,BLKSZ-8		:IS THIS HEADER FULL
	JE	PUTB0			:YES,START NEXT HEADER
	AIS	r1,4			:ELSE BUMP INDEX
	ST	R0,FFLST-4,R1		:PLACE RETURNING BLOCK
	ST	R1,FFNDX		:REPLACE INDEX
	JR	R3			:DONE
PUTB0	L	R1,FFCUR		:GET CURRENT BLOCK NUMBER
	ST	R0,FFCUR		:REPLACE WITH RETURNING
	SHOP(FWRT,FFLNK)		:WRITE OUT FULL HEADER
	ST	R1,FFLNK		:POINT THIS TO PREVIOUS
	LIS	R1,0			:PREPARE TO ZERO INDEX
	ST	R1,FFNDX		:NEW FREE LIST HEADER HAS NO BLOCKS YET
	JR	R3			:DONE,RETURN
					:
:	.......................................................................
:	GETB -- Gets a lock from the free list
:	Return block number in r0
:	Link on R3
:	.......................................................................
					:
GETB	L	R1,FFNDX		:Get the index
	JE	GETB0			:SKIP IF NONE LEFT
	LCS	R0,1			:DECREMENT COUNT
	AM	R0,FFCNT		:FREE COUNT KEPT HERE
	L	R0,FFLST-4,R1		:Get the next available block
	SIS	R1,4			:DECREMENT INDEX
	ST	R1,FFNDX		:REPLACE IT
	JR	R3			:DONE
GETB0	L	R1,FFLNK		:TAKE NEXT HEADER
	JE	FILNBK			:OUT OF BLOCKS
	SHOP(FRRD,FFLNK)		:READ IN NEXT HEADER
	LCS	R0,1			:DEC COUNT
	AM	R0,FFCNT		:
	L	R0,FFCUR		:GIVE CALLER THE CURRENT
	ST	R1,FFCUR		:AND LINK BECOMES CURRENT
	JR	R3			:RETURN
					:
:	.......................................................................
:	OPEN
:	LINK ON R4
:	.......................................................................
					:
FOPEN	LIS	r1,0			:GET A NULL
	ST	R1,DSIZE		:ZERO DATA BUFER INDEX
	L	R1,HHSEQ		:GET CURRENT FILE SEQUENCE
	L	r1,DDLST,r1		:Get first header
	JN	OPEN1			:SKIP IF NOT A NEW FILE
	JAL	R3,GETB			:GET BLOCK FOR FIRST HEADER
	L	R1,HHSEQ		:RECOVER SEQUENCE NUMBER
	ST	r0,DDLST,r1		:Set up first header
	ST	R0,HHCUR		:THIS IS CURRENT HEADER
	LIS	R0,1			:
	ST	R0,DDLST+4,R1		:COUNT FIRST BLOCK
	L	R0,HNAME		:ENTER NEW NAME TO DIRECTORY
	ST	R0,DDLST+08,R1		:PLACE FIRST FOUR BYTES
	L	R0,HNAME+4		:GET SECOND FOUR
	ST	R0,DDLST+0C,R1		:PLACE THEM
	LIS	R0,0			:GET A NULL
	ST	R0,HHLNK		:THIS HEADER WILL BE LAST ON LIST
	ST	R0,HHNDX		:ZERO BLOCK INDEX
	JR	R4			:DONE FOR NEW FILE
OPEN1	ST	r1,HHCUR		:THIS IS CURRENT HEADER
	SHOP(FRRD,HHLNK)		:READ FIRST HEADER BLOCK
	JR	R4			:RETURN
					:
:	.......................................................................
:	THIS ROUTINE IS FORCED BY THE OCCURANCE OF A ZAPPER WHEN THE
:	FILE SYSTEM IS OPEN.  IT CLOSES IT AND RETURNS TO ZAP.
:	.......................................................................
					:
DDTCLS  TS      FUSER                   :RESET FLAG
        LIS     R0,0			:
        STH     R0,INUSE                :SET NOT IN USE
        JAL     R3,FCLOS		:
					:
        SVC     KIO,0                   :ZAP!
					:
:	.......................................................................
:	CLOSE A FILE
:	LINK R3
:	.......................................................................
					:
FCLOS	L	r1,HHCUR		:CURRENT HEADER OF OPENED FILE
	SHOP(FWRT,HHLNK)		:PUT IT AWAY
FCLOS0	L	R1,FFCUR		:CURRENT FREE LIST BLOCK
	SHOP(FWRT,FFLNK)		:UPDATE FREE LIST
	L	R1,DDCUR		:FOR CURRENT DIRECTORY BLOCK
	SHOP(FWRT,DDLNK)		:UPDATE IT
	LIS	R1,0			:PREPARE TO GET FIRST DIRECTORY BLOCK
	SHOP(FRRD,DDLNK)		:FIRST READ IT IN
	L	R0,FFCUR		:AND FOR FIRST FREE LIST HEADER
	ST	R0,DDLST		:PLACE IT
	L	R0,FFCNT		:AND FOR FREE LIST COUNT
	ST	R0,DDLST+4		:PLACE IT
	SHOP(FWRT,DDLNK)		:REPLACE FIRST DIRECTORY BLOCK
	JR	R3			:RETURN
					:
:	.......................................................................
:	DELETE FILE,LINK R5
:	.......................................................................
					:
FDEL	JAL	R4,FOPEN		:OPEN IT
FDEL0	L	R2,HHNDX		:GET CURRENT INDEX
	JG	FDEL1			:SKIP IF MORE TO DO
	L	R0,HHCUR		:RETURN HEADER BLOCK
	JAL	R3,PUTB			:CALL FREE LIST ROUTINE
	L	R1,HHLNK		:GET NEXT HEADER
	JE	FDEL2			:DONE,UPDATE DISC
	ST	R1,HHCUR		:SAVE IT
	SHOP(FRRD,HHLNK)		:READ IN HEADER
	J	FDEL0			:AND FLUSH THIS HEADER LIST
FDEL1	SIS	R2,HRSIZE		:POINT TO NEXT HEADER ELEMENT
	ST	R2,HHNDX		:REPLACE POINTER
	L	R0,HHLST,R2		:GET NEXT ONE
	JL	FDEL0			:IGNORE IF COMPRTESSION
	JAL	R3,PUTB			:RETURN THIS ELEMENT
	J	FDEL0			:CONTINUE WITH THIS LIST
					:
:	.......................................................................
:	FILE NOW DELETED AND USED BLOCKS RETURNED TO FREE LIST
:	IT IS NECESSARY HERE TO FILL THE NOW BLANK ELEMENT IN THE DIRECTORY
:	BLOCK WITH THE LAST ELEMENT IN THE DIRECTORY BLOCK SO THAT THE
:	DIRECTORY BLOCKS HAVE NO BLANK ELEMENTS EXCEPT AT THE END
:	.......................................................................
					:
FDEL2	L	R1,DDNDX		:GET CURRENT INDEX
	SHI	R1,10			:UPDATE IT
	ST	R1,DDNDX		:AND PLACE IT
	L	R2,HHSEQ		:GET SEQUENCE NUMBER DELETED FILE
					:
:	.......................................................................
:	NOW MOVE THE LAST FILE UP TO TAKE PLACE OF JUST DELETE FILE
:	(KEEP FILE ENTRY LIST CONTIGUOUS)
:	.......................................................................
					:
	L	R3,DDLST,R1		:GET LAST ELEMENT
	ST	R3,DDLST,R2		:REPLACE RECENT GAP
	L	R3,DDLST+4,R1		:AND SECOND WORD
	ST	R3,DDLST+4,R2		:REPLACE GAP
	L	R3,DDLST+8,R1		:GET FIRST FOUR BYTES NAME
	ST	R3,DDLST+8,R2		:MOVE IT UP
	L	R3,DDLST+0C,R1		:AND SECOND FOUR
	ST	R3,DDLST+0C,R2		:MOVE IT
	JAL	R3,FCLOS0		:NOW DO A SHORT FILE CLOSE
	JR	R5			:RETURN
					:
:	.......................................................................
:	READS NEXT BLOCK FROM FILE
:	ALSO SETS UP DADDR TO USER ADDRESS ASSIGNED TO BLOCK
:	AND SETS UP DSIZE, THE NUMBER BYTES THIS BLOCK
:	R2 CONTAINS INDEX INTO CURRENT HEADER
:	.......................................................................
					:
READB	L	R0,HHLST+4,R2		:GET VIRTUAL ADDRESS THIS ELEMENT
	ST	R0,DADDR		:PLACE IT
	L	R0,HHLST+8,R2		:GET NUMBER BYTES
	ST	R0,DSIZE		:PLACE IT
	L	r1,HHLST,r2		:GET REQUESTED BLOCK
	JL	READ0			:SKIP AHEAD,DE COMPRESSION
	SHOP(FRRD,DBUF)			:READ REQUESTED DATA
	JR	R3			:RETURN
READ0	L	R2,DSIZE		:GET NUMBER COMPRESSION CHARS
READ1	SIS	R2,1			:FOR EACH CHAR
	JLR	R3			:UNTIL DONE
	STB	R1,DBUF,R2		:ELSE DECOMPRESS
	JBS	READ1			:
					:
:	.......................................................................
:	WRITES A  BLOCK TO CURRENT  FILE
:	.......................................................................
					:
WRTB	L	r3,HHNDX		:GET CURRENT INDEX
	CLHI	r3,HNUMB		:THIS HEADER FULL?
	JL	WRT1			:NO,SKIP TO ADD ON
	L	R1,HHCUR		:GET CURRENT HEADER NUMBER
	SHOP(FWRT,HHLNK)		:WRITE OUT PREVIOUS HEADER
	ST	R1,HHLNK		:MAKE IT THE LINK
	JAL	R3,GETB			:GET ANOTHER
	ST	r0,HHCUR		:MAKE IT THE CURRENT
	L	R1,HHSEQ		:RECOVER SEQUENCE
	ST	R0,DDLST,R1		:BECOMES FIRST HEADER
	LIS	R0,1			:
	AM	R0,DDLST+4,R1		:ADD ONE MORE COUNT FOR HEADER
	LIS	r3,0			:
	ST	r3,HHNDX		:ZERO BLOCK INDEX THIS HEADER
WRT1	L	R3,HHNDX		:GET HEADER INDEX
	L	R1,DADDR		:GET VIRTUAL ADDRESS
	ST	R1,HHLST+4,R3		:PLACE IT IN HEADER ELEMENT
	L	R1,DSIZE		:GET NUMBER BYTES THIS BLOCK
	ST	R1,HHLST+8,R3		:PLACE IT IN HEADER ELEMENT
	AM	R1,DADDR		:AND UPDATE CALLERS VIRTUAL
	LIS	R1,0			:GET A NULL
	ST	R1,DSIZE		:RESET THIS
	LH	R0,FCOMP		:CHECK FOR COMPRESSION
	JL	WRT2			:SKIP AHEAD, SERVICE COMPRESSION
	L	r1,HHSEQ		:LOCATE FILE SEQUENCE
	LIS	r3,1			:GET AN ADDER
	AM	r3,DDLST+4,R1		:UPDATE DATA BLOCK COUNT
	JAL	R3,GETB			:GET NECESSARY BLOCK FOR DATA
	L	R3,HHNDX		:GET CURRENT BLOCK INDEX
	ST	r0,HHLST,r3		:PUT IN HHLST
	AIS	r3,HRSIZE		:UPDATE BLOCK INDEX
	ST	r3,HHNDX		:UPDATE INDEX
	LR	r1,r0			:GET COPY OF BLOCK NUMBER
	SHOP(FWRT,DBUF)			:NOW JUST WRITE OUT THE DATA BLOCK
	JR	r4			:RETURN
WRT2	L	R3,HHNDX		:GET CURRENT HEADER INDEX
	LB	R0,DBUF			:GET COMPRESSION CHARACTER
	STB	R0,HHLST+3,R3		:PLACE IT
	LCS	R0,1			:GET A COMPRESSION FLAG
	STH	R0,HHLST,R3		:PLACE IT
	AIS	r3,HRSIZE		:UPDATE BLOCK INDEX
	ST	r3,HHNDX		:UPDATE INDEX
	JR	R4			:RETURN
					:
:	.......................................................................
:	OUPUTS A BLOCK TO CORE
:	LINK R3
:	.......................................................................
					:
OUTB	L	R2,DADDR		:
	EXHR	R1,R2			:GET VIRTUAL START ADDRESS
	NHI	R1,0F			:CHECK SEGMENT
	CLHI	R1,0E			:CHECK FOR SEGMENT E
	JN	FLOUT0			:NO,GO COMPUTE REAL ADDRESS
	L	R1,SBASE,R8		:ELSE SEGMENT STARTS HERE
	J	FLOUT2			:
FLOUT0	SLHLS	R1,2			:MAKE AWORD  INDEX
	L	R1,MPROT,R1,R8		:GET SEGMENT
	JE	FILMAC			:ERROR IN MAC
	NI	R1,MMASKR		:GET START BYTE
	SRLS	R1,MSHFTA		:MAKE ADDRESS
FLOUT2	NI	R2,SEGSIZ-1		:GET  START RELATIVE TO SEGMENT
	AR	R2,R1			:ABSOLUTE START
	L	R1,DSIZE		:GET NUMBER OF BYTES
:	.......................................................................
:	FIRST CHECK IF DATA IS WITHIN SLOT BOUNDS
:	.......................................................................
					:
	LHL	R0,CMAX,R8		:GET NUMBER PAGES
	SLLS	R0,MSHFTB		:CONVERT TO BYTES
	A	R0,SBASE,R8		:COMPUTE ABSOLUTE END OF SLOT SPACE
	SR	R0,R1			:SUBTRACT  #BYTES NEEDED
	AIS	R0,1			:ZERO SHOULD NOT HAVE BEEN INVENTED
	CLR	R2,R0			:IN BOUNDS
	JG	FILMAC			:MAC ERROR
FLOUT3	SIS	R1,1			:FOR EACH BYTE
	JLR	R3			:DONE,RETURN
	LB	R0,DBUF,R1		:GET BYTE
	STB	R0,0,R1,R2		:PLACE BYTE
	JBS	FLOUT3			:CONTINUE
					:
:	.......................................................................
:	PUT DISC IS USED TO SEND ONE CHARACTER TO THE DISC
:	WHEN A DATA BUFFER IS FULL IT IS APPENDED TO THE OPEN FILE
:
:	THIS ROUTINE ATTEMPTS COMPRESSION BASED ON THE FOLLO0WING RULES.
:	WHEN STARTING A NEW BLOCK THE FIRST CHARACTER IS SAVED ALSO A FLAG IS
:	SET (FCOMP). AS LONG AS THE SUCCEDING CHARACTERS ARE THE SAME AS THE
:	FIRST THE  FLAG REMAINS SET. WHEN THE CURRENT CHARACTER' IS UN EQUAL,
:	THEN A CHECK IS MADE WHETHER THE NUMBER OF LIKE CHARACTERS IS GREATER
:	THAN FCOUNT.  IF SO THEN A HEADER ENTRY IS MADE SPECIFYING A 
:	COMPRESSION BLOCK BY SETTING THE MSB ON THE BLOCK NUMBER, USING THE
:	BLOCK NUMBER HEADER ENTRY TO ALSO SPECIFY THE CHARACTER COMPRESSED
:	THIS IS DONE WITH A CALL TO WRTB IF THE COUNT IS NOT GREAT ENOUGH THEN
:	THE COMPRESSION FLAG IS RESET AND THE BLOCK FILLED AND WRITTEN 
:	NORMALLY.
:	.......................................................................
					:
PUTDISC	L	R1,DSIZE		:GET SIZE CURRENT DATA BLOCK
	JN	PUTD0			:JUMP AHEAD NORMALLY
	TS	FCOMP			:ELSE START COMPRESSION
PUTD0	LH	R2,FCOMP		:IS THIS COMPRESSION?
	JGE	PUTD2			:NO,CONTINUE
	CLB	R0,DBUF			:IS THIS THE SAME?
	JE	PUTD2			:YES, CONTINUE
	CLHI	R1,FCOUNT		:IS IT BIG ENOUGH
	JLFS	PUTD1			:NO,SKIP AHEAD
	STH	R0,FCHSAV		:SAVE THIS ODD CHARACTER
	JAL	R4,WRTB			:ELSE WRITE OUT COMPRESSED SET
	LHL	R0,FCHSAV		:RECOVER ODD CHARACTER
	J	PUTDISC			:AND RECURSE THIS ROUTINE
PUTD1	LIS	R2,0			:GET A NULL
	STH	R2,FCOMP		:RESET FLAG
PUTD2	STB	R0,DBUF,R1		:PLACE THE CHARACTER
	AIS	R1,1			:BUMP CHARACTER COUNT
	ST	R1,DSIZE		:REPLACE IT
	CLHI	R1,BLKSZ		:IS THE BUFFER FULL?
	JLR	R5			:NO, RETURN
PUTD3	JAL	R4,WRTB			:OUTPUT BLOCK
	LIS	R1,0			:
	ST	R1,DSIZE		:SET NEXT BLOCK EMPTY
	JR	R5			:RETURN
					:
:	.......................................................................
:	SNDCHA, AND SNDCHB ARE TO 'WRITE TO DISC ROUTINES' THEY ARE CALLED
:	FROM THE DDT WRITE LOOPS AND WILL SEND A CHARACTER TO THE DISC IF
:	THE CURRENT DDT USERS HAS THE DISC, AND IS IN WRITE MODE
:	A SKIP RETURN ON SUCCESS
:	SNDCHB IS CALLES FROM THE EXPANSION LOOP
:	.......................................................................
					:
SNDCHB	LR	R0,R7			:GET THE BYTE
SNDCHA	C	R8,FUSER		:FOR THIS ONE?
	JNR	R9			:WRONG USER,NON SKIP RETURN
	L	R1,FMODE		:WRITE MODE?
	JNR	R9			:NO,NON SKIP RETURN
SNDCH0	JAL	R5,PUTDISC		:AND PLACE IT TO THE FILE
	CI	R12,1,R15		:DONE?
	JG	4,R9			:NO, SKIP RETURN
	L	R0,DSIZE		:ANYTHING  LEFT?
	JE	4,R9			:NO
	JAL	R4,WRTB			:WRITE LAST BLOCK
	J	4,R9			:SKIP RETURN
					:
:	.......................................................................
:	GET DISC, GETS HALF FROM FILE, DOES SKIP RETURN
:	IF CALLER DOES NOT OWN FILE SYSTEM, WILL DO
:	NON-SKIP RETURN
:	THIS ROUTINE CALLED FROM DDT READ ROUTINE
:	.......................................................................
					:
GETDSC	C	R8,FUSER		:DOES THIS USER OWM THE DISC?
	JNR	R9			:NO,TAKE NON-SKIP RETURN
	LH	R4,FMODE		:CHECK PROPER MODE
	JGER	R9			:WRONG MODE NON-SKIP RETURN
	L	R4,STBYTE		:GET HIS REQUESTED START BYTE
	S	R4,DADDR		:IS IT BELOW ADDRESS CURRENT DATA BLOCK
	JL	GETD0			:OUT OF RANGE
	C	R4,DSIZE		:IS IT WITHIN THE DATA BLOCK?
	JL	GETD1			:YES,SKIP
GETD0	JAL	R5,FNDBLK		:THEN SEARCH WHOLE FILE
GETD1	LHL	R0,DBUF,R4		:GET HALF WORD
	LIS	R4,2			:BUMPING COUNT
	AM	R4,STBYTE		:UPDADTE READ ADDRESS
	NOP				:
	NOP				:
	NOP				:
	NOP				:
	J	4,R9			:
:	.......................................................................
:	FNDBLK, FINDS DATA BLOCK IN OPENED FILE WHICH
:	CONTAINS VIRTUAL ADDRESS IN STBYTE
:	LINK R5
:	.......................................................................
					:
FNDBLK	JAL	R4,FOPEN		:REOPEN FILE TO START
FNDBL1	LIS	R1,0			:STARTING WITH ELEMENT ONE
FNDBL2	C	R1,HHNDX		:HAS THIS HEADER BLOCK BEEN SEARCHED?
	JL	FNDBL3			:NO,SKIP TO CHECK ITS NEXT ENTRY
	L	R1,HHLNK		:YES, GET NEXT BLOCK
	JE	FILDAT			:TAKE MISSING DATA ERROR
	ST	R1,HHCUR		:SET NEW BLOCK AS CURRENT
	SHOP(FRRD,HHLNK)		:READ IT
	J	FNDBL1			:AND CONTINUE
FNDBL3	L	R4,STBYTE		:GET HIS REQUESTED ADDRESS
	S	R4,HHLST+4,R1		:IS IT WITHIN FIRST DATA BLOCK?
	JL	FNDBL4			:NO,SKIP TO CHECK NEXT
	C	R4,HHLST+8,R1		:IS REQUEST OUT OF RANGE THIS BLOCK?
	JL	FNDBL5			:NO, THIS IS IT
FNDBL4	AIS	R1,HRSIZE		:CHECK NEXT DATA BLOCK
	J	FNDBL2			:AND CONTINUE SEARCH
FNDBL5	LR	R2,R1			:GET COPY FOR READB ROUTINE
	JAL	R3,READB		:READ APPROPIATE DATA BLOCK
	JR	R5			:AND RETURN
					:
:	....................................................................
:	GRAB FILE SYSTEM, INITIALIZE DISC IN NEED BE, WAIT IF  NECESSARY
:	UNTIL OTHER USER DONE,LINK R7
:	....................................................................
					:
FSET	LHI	R0,L.SYP!L.S0P!L.P!L.H!L.L	:SAME LICENCE AS WRITE
	NH	R0,SLICEN,R8		:
	JE	FSET1			:
	NH	R0,ULICEN,R8		:
	JE	LICERR			:SORRY CHARLIE!
					:
FSET1	TS	INUSE			:IN USE?
	JGEFS	.+6			:
	JAL	R0,FILWAT		:WAIT   FOR OTHER USER
	ST	R8,FUSER		:RESERVE  IT
	LH	R1,SLOT,R8		:GET THE SLOT R8
	JL	FILSFF			:SLOT  FF CANNOT USE  THIS
	TS	DREADY			:CHECK DISC FORMATTED
	JLR	R7			:DISC READY,RETURN
	JAL	R6,DINIT		:ELSE FORMAT IT
	JR	R7			:RETURN
					:
:	....................................................................
:	FNDFIL - FIND FILE ROUTINE USED TO MACH A USER SUPPLIED NAME
:		 TO THE LIST IN THE DIRECTORY
:	Link On R3, SUCCESS SKIP RETURN (+4)
:	....................................................................
					:
FNDFIL	LIS	R1,0			:STARTING WITH FIRST DIR BLOCK
FND1	ST	R1,DDCUR		:SET IT AS CURRENT
	SHOP(FRRD,DDLNK)		:READ IT
	LHI	R1,-10			:STARTING WITH FIRST ENTRY
FND2	AHI	R1,10			:FOR NEXT ENTRY
	C	R1,DDNDX		:UNLESS THATS IT THIS BLOCK
	JL	FND3			:
	L	R1,DDLNK		:GET NEXT DIRECTORY BLOCK
	JER	R3			:LAST ONE, NON SKIP RETURN
	J	FND1			:READ IT AND SEARCH
FND3	L	R2,HNAME		:GET FIRST
	C	R2,DDLST+8,R1		:CAN IT BE THIS
	JN	FND2			:NO, CHECK NEXT
	L	R2,HNAME+4		:GET NEXT
	C	R2,DDLST+0C,R1		:IS THIS IT
	JN	FND2			:NO CHECK NEXT
	ST	R1,HHSEQ		:SAVE SEQUENCE NUMBER
	J	4,R3			:TAKE SKIP RETURN
					:
:	.......................................................................
:	MKFIL FINDS A SPOT FOR A NEW FILE
:	.......................................................................
					:
MKFIL	LIS	R0,0			:FIND ROOM ON FIRST BLOCK
MKF0	LR	R1,R0			:RECOVER NEXT BLOCK
	ST	R1,DDCUR		:STORE AS CURRENT DIR BLOCK
	SHOP(FRRD,DDLNK)		:READ IT
	L	R0,DDNDX		:GET BLOCK INDEX
	CLHI	R0,DDNMB		:THIS ONE FULL?
	JL	MKF1			:NO
	L	R0,DDLNK		:TRY NEXT
	JN	MKF0			:AND GO CHACK IT
					:
:	.......................................................................
:	ALL BLOCKS FULL, GET ANOTHER
:	.......................................................................
					:
	ST	R1,DDCUR		:SAVE CURRENT
	JAL	R3,GETB			:GET A FREE BLOCK
	ST	R0,DDLNK		:PLACE IT AS A LINK
	L	R1,DDCUR		:RECOVER CURRENT
	SHOP(FWRT,DDLNK)		:WRITE PREVIOUS BACK IN
	L	R0,DDLNK		:GET NEW CURRENT
	ST	R0,DDCUR		:PLACE IT
	LIS	R0,0			:GET A NULL
	ST	R0,DDNDX		:SET IT EMPTY
	ST	R0,DDLNK		:AND SET IT LAST
MKF1	L	R1,DDNDX		:RECOVER FILE INDEX
	LIS	R0,0			:SET A NULL
	ST	R0,DDLST,R1		:SET FILE AS EMPTY
	L	R0,HNAME		:GET CALLER'S FILENAME
	ST	R0,DDLST+8,R1		:STORE IT
	L	R0,HNAME+4		:REST OF NAME
	ST	R0,DDLST+0C,R1		:SECOND FOUR BYTES
	ST	R1,HHSEQ		:
	AHI	R1,10			:BUMP INDEX
	ST	R1,DDNDX		:UPDATE INDEX
	JR	R4			:RETURN
					:
:	.......................................................................
:	GET FILE  NAME, LINK R4
:	GETS AN 8 BYTE OR LESS ASCII NAME FROM USER
:	.......................................................................
					:
GTFNAM	LIS	R3,0			:GET ACCUMULATOR
	ST	R3,HNAME		:RESET RESULT
	ST	R3,HNAME+4		:ALL EIGHT BYTES
GTF0	JAL	R2,GETCHAR		:GET A USER BYTE
	NOP				:IGNORE NON SKIP RETURN
	JAL	R2,ZDLIM		:CHECK FOR DILIMINETER
	J	0,R4			:GOT  ONE,RETURN
					:
	CLHI	R0,0E1			:CONVERT LOWER CASE TO UPPER
	JL	GTF1			:
	CLHI	R0,0FA			:
	JG	GTF1			:
	NHI	R0,0DF			:
					:
GTF1	STB	R0,HNAME,R3		:PLACE IT
	AIS	R3,1			:BUMP CHARACTER COUNT
	CLHI	R3,07			:COMPLETE NAME?
	JER	R4			:DONE
	J	GTF0			:GET NEXT CHARACTER
					:
:	.......................................................................
:	FILE SYSTEM ERROR ARE HANDLED HERE
:	.......................................................................
					:
FILNOT	LA	R1,FFGONE		:CANT FIND REQUESTED FILE
	J	FILMSG			:
FILDIS	LA	R1,LERR			:DISC ERROR MESSAGE
	J	FILMSG			:GO SEND IT
FILSFF	LA	R1,FFERR		:ILLEGAL ACCESS FROM SLT FF
	J	FILMSG			:GO SEND IT
FILNBK	JAL	R5,FDEL0		:RELEASE BLOCKS FROM UNWRITTEN FILE
	LA	R1,FNOBLK		:NO MORE BLOCKS
	J	FILMSG			:GO SEND IT
					:
FILERR	LA	R1,FBUG			:FILE ERROR
	J	FILMSG			:GO SEND IT
FILDAT	LA	R1,FFDAT		:PRINT NO DATA ERROR
	JFS	FILMSG			:
FILMAC	LA	R1,BADMAC		:SOMETHING WRONG WITH MAC
	JFS	FILMSG
FILMSG	SVC	OUT,0,R1		:OUTPUT APPROPIATE MESSAGE
	J	FREL			:RELEASE SYSTEM
					:
:	.......................................................................
:	WHEN FILE SYSTEM BUSY, MESSAGE IS OUTPUT AND USER IS RETURNED TO
:	COMMAND HANDLER
:	.......................................................................
					:
FILWAT	SVC	OUT,FILBSY		:
	J	TTY			:RETURN TO COMMANDS
					:
FILBSY	SC	'FILE SYSTEM BUSY..."8D"8A'
FFDAT	SC	'FILE MISSING REQUIRED DATA"8D"8A'
					:
:	.......................................................................
:	FILE NOT HERE MESSAGE
:	THE '\' CHARACTER IS NEEDED,DO NOT REMOVE(SEE ISRS CODE)
:	.......................................................................
					:
FFGONE	SC	'FILE NOT FOUND\'
FFERR	SC	'ILLEGAL FROM  SYSTEM  DDT"8D"8A'
FNOBLK	SC	'NO MORE BLOCKS"8D"8A'
FBUG	SC	'FILE BUG"8D"8A'

   EI  (FSYS)				:


:	QUERY BREAKPOINT
QB	LCS	R0,1			:SET FLAG
	LIS	R3,0
	LIS	R4,1
QB1	L	R4,LISTA,R8,R3	:CHECK A BREAKPOINT
	JGFS	QB3			:GOT ONE
QB2	AIS	R3,4			:KEEP SEARCHING
	CLHI	R3,(BPNO-1)*4
	JLEBS	QB1			:UNTIL HAVE FOUND ALL
	LR	R0,R0			:HAVE WE DONE ANY OUTPUT?
	JGE	TTY			:YES...JUST QUIT
	SVC	OUT,QB4			:NO...TELL THAT THERE ARE NO BREAKPOINTS
	J	TTY			:AND THEN QUIT
QB3	SVC	OUT,QB5			:WE HAVE ONE..."BREAKPOINT "
	LR	R0,R3
	SRLS	R0,2
	LHI	R1,210			:2 HEX DIGITS
	SVC	KIO,$A 10		:BP #
	SVC	OUT,QB6			:" AT "
	LR	R0,R4
	LHI	R1,650			:6 HEX DIGITS
	SVC	KIO,$A 10		:BP ADDR
	J	QB2
QB4	SC	'"8D"8ANo breakpoints in use'
QB5	SC	'"8D"8ABreakpoint '
QB6	SC	' at '
					:
:	.......................................................................
:	DDT command = ?BOOT - PUT MACHINE IN BOOT
:	.......................................................................
					:
QBOOT	LH	R0,ULICEN,R8		:Get the user's license ...
	THI	R0,L.SYP		:User has license to boot machine?
	JNFS	QBOOT1			:Yes...just skip
	LA	R1,BADLIC		:No, bad license 
	JAL	R9,OOUT			:Warn the user for bad license ...
	J	TTYERR			:Take an error return ...
QBOOT1	LH	R0,SLOT,R8		:
	JG	TTYERR			:MUST BE SLOT 0 OR FF
	LA	R1,AGAIN		:Get confirmation message ...
	JAL	R9,OOUT			:Ask user again for confirmation
	JAL	R1,INCHAR		:Get the user response ...
	JAL	R1,CUC			:Convert input char to upper case
	CLHI	R0,0D9			:Is answer "Y"?
	JN	TTY			:No, the user is not sure...return
   IF	KIOSRC				:
	LHI	R5,KIOSRC		:
	JAL	R7,KILMB,,		:Kill SIO motherboard
	J	5A			:
   ELSE					:
	SVC	2,$A 39			:TELL KERNEL TO STOP UPDATING WATCHDOG
	J	TTY			:
   EI  (KIOSRC)				:
					:
					:
:	.......................................................................
:	CHKUSR - Check the current user's license before execute some of 
:		 DDT commands
:	Note(s): Following user names do not require license validation.
:		 1. ISRS
:		 2. GATEWAY
:		 3. ISISTECH
:	   R1  - contains the user's license status as of 
:		 >  0 O.K. execute the requested DDT command
:		 <= 0 insufficent license to execute the requested DDT command
:	   R15 - Link Register
:	.......................................................................
					:
CHKUSR	LHL	R4,GGNDX,R8		:Get index to the Good-guy lists
	L	R1,GODGUY+GGNAME,R4	:Get the first word of user name
CKUSR0	CLI	R1,0C9D3D2D3		:Is the user "ISRS"?
	JER	R15			:Yes...just return
	CLI	R1,0CCCFC1C4		:Is it "LOAD"?
	JNFS	CKUSR1			:No, check for the next username
	LHL	R1,GODGUY+GGNAME+4,R4	:Get the next two bytes
	CLHI	R1,0C9C9		:Is it "II" for "LOADII"?
	JER	R15			:Yes, successful return ...
	J	CKUSR4			:
CKUSR1	CLI	R1,0C9D3C9D3		:Is it "ISIS"?
	JNFS	CKUSR2			:No....just skip
	L	R1,GODGUY+GGNAME+4,R4	:
	CLI	R1,0D4C5C3C8		:Is it "TECH"?
	JER	R15			:Return if it's user "ISISTECH"
	JFS	CKUSR4			:
CKUSR2	CLI	R1,0C7C0D4C5		:Is the user "GATE"?
	JNFS	CKUSR4			:
	L	R1,GODGUY+GGNAME+3,R4	:
	CLI	R1,0C5D7C1D9		:Is the user "EWAY"?
	JER	R15			:
CKUSR4	LIS	R1,0			:Reset user license status
	JR	R15			:Return ...
					:
:	....................................................................
:	DDT command = ?HALT - Halt a slot's job
:	....................................................................
					:
QHALT	LHL	R1,ULICEN,R8		:Get the user's license ...
	THI	R1,L.H			:The user has license to kill?
	JNFS	QHALT0			:Yes...go to confirm the user request
	LA	R1,BADLIC		:Warn the user for bad license 
	JAL	R9,OOUT			:
	J	TTYERR			:Take error return 
QHALT0	LH	R1,SLOT,R8		:Get the current slot #
	JL	TTYERR			:ISIS system can not be halted
	if	1-ntddbg
	CLHI	R1,0			:node code slot?
	JNFS	QHALT1			:no
	LHL	R0,BUFNO,R8		:yes
	CLHI	R0,NKU			:log in from tty port?
	JN	TTYERR			:no
	ei	(1-ntddbg)
QHALT1	LA	R1,AGAIN		:Get confirmation message...
	JAL	R9,OOUT			:Send confirmation msg out to user..
	JAL	R1,INCHAR		:Get the next input character
	JAL	R1,CUC			:Convert it to upper case char...
	CLHI	R0,0D9			:Is it a "Y"?
	JN	TTY			:User isn't sure...try it next time
	J	DHALT2			:Go ahead to halt a slot job
					:
:	....................................................................
:	DDT command = ?DASH  - Disable auto slot halt
:	looks at sltddt flag -- 0 for disabled, 1 for enabled (default)
:	....................................................................
qdash	lh	r1,sltddt,,		:get context
	je	qdash1			:jump on disabled
	la	r1,dsdash		:get message for disable
	jal	r9,oout,,		:send to user
	jal	r1,inchar,,		:get the next input character
	jal	r1,cuc,,		:convert to upper case
	clhi	r0,0d9			:is it a "Y"?
	jn	tty			:user isn't sure..
	lis	r1,0			:set disable flag
	sth	r1,sltddt,,
	j	tty			:
qdash1	la	r1,esdash		:get messabe for enable
	jal	r9,oout,,		:send to user
	jal	r1,inchar,,		:get the next input character
	jal	r1,cuc,,		:convert to upper case
	clhi	r0,0d9			:is it a "Y"?
	jn	tty			:user isn't sure..
	lis	r1,1			:set enable flag
	sth	r1,sltddt,,		
	lis	r1,0
	lh	r9,slot,r8		:get slot #
	slls	r9,3			:index on slot
	sth	r1,sltinf+2,r9,		:clear repeat crash counter
	j	tty			:
:	....................................................................
:	QUERY STATISTICS
:	....................................................................
					:
   IF	SYSMON

STHNG1	SC	/"8D"8A    SVC   CONTEXT  CS,WITH CS,WITH  ACCESS/
STHNG2	SC	/"8D"8A   CALLS  SWITCHES  MACLDS  REG,RST  CHECKS"8D"8A/
QSYS	SVC	OUT,STHNG1		:TWO HEADINGS
	SVC	OUT,STHNG2
	LHL	R7,ULICEN,R8
	THI	R7,L.SYA		:IS LICENSE SUFFICIENT
	JE	TTY
	LHI	R2,0C
	LIS	R1,0
QSY1	ST	R1,SYSTAT,R2,
	SIS	R2,4			:ZERO THE NEXT WORD
	JGEBS	QSY1
	SVC	DISMISS,2		:GO AWAY AND LET THE STATISTICS COUNT
	LIS	R2,2
	LH	R5,NRATE+2,,
	AR	R5,R5
	AIS	R5,1
	LHI	R1,82A
QSY3	LHL	R3,SYSTAT,R2,		:GET THE STATISTIC
	MHR	R3,R5			:32 BIT RESULT IN R3
	DH	R3,SYSTAT,,		:16 BIT QUOTIENT IN R4
	SRLS	R4,1
	LR	R0,R4			:PREPARE FOR OUTPUT
	SVC	KIO,$A 10
	AIS	R2,2			:POINT TO NEXT VARIABLE
	CLHI	R2,0C
	JLBS	QSY3
	SVC	OUT,CRLF
	J	TTY
   EI  (SYSMON)				:
					:
   IF	NSLOT				:
:	....................................................................
:
:	TRANSFER LOGICAL UNITS
:
:	Note: USER MUST HAVE ADEQUATE LICENCE TO TRANSFER (EXCHANGE) A LU
:
:	....................................................................
					:
QTRAN	LHL	R4,ULICEN,R8		:CHECK ON LICENCE
	THI	R4,L.SYP		:MUST HAVE SYSTEM PATCH
	JE	TTYERR			:
					:
:	....................................................................
:	OK,GET LOGICAL UNIT
:	....................................................................
					:
QTRN01	SVC	OUT,QTRNM1		:PROMPT FOR LU
	JAL	R9,NUM			:
	CHI	R0,NLU			:ERROR IF TOO BIG
	JG	TTYERR			:
					:
:	....................................................................
:	CHECK OUT LOGICAL UNIT SOURCE
:	....................................................................
					:
	LR	R3,R0			:GOT LU
	SLLS	R3,2			:*4
	L	R0,LUN,R8,R3		:CHECK IF LU PRESENT
	JE	TTYERR			:ERROR IF NOT
	LR	R15,R3			:SAVE SOURCE LU
					:
:	....................................................................
:	GET DESTINATION SLOT
:	....................................................................
					:
	SVC	OUT,QTRNM2		:PROMPT
	JAL	R9,NUM			:
	CHI	R0,NSLOT		:CHECK VALIDITY
	JG	TTYERR			:
	LR	R3,R0			:COPY SLOT #
	SLLS	R3,2			:MAKE WD INDEX
	L	R6,SLIST,R3,		:
					:
:	....................................................................
:	GET DESTINATION LU
:	....................................................................
					:
	SVC	OUT,QTRNM3		:PROMPT
	JAL	R9,NUM			:
	CHI	R0,NLU			:CHECK RANGE
	JG	TTYERR			:
	LR	R3,R0			:MAKE A FW INDEX
	SLLS	R3,2			:
	L	R0,LUN,R6,R3		:CHECK LUN
	JN	TTYERR			:NO GOOD
	LR	R0,R15			:DISCONNECT DEVICE FIRST
	SVC	SYS,$A35		:
	NOP	
	L	R1,LUN,R8,R15		:SAVE LOGICAL UNIT
	ST	R1,LUN,R6,R3
	LIS	R0,0
	ST	R0,LUN,R8,R15		:REMOVE SOURCE REFERENCE
	L	R7,CONTROL,R8		:CLEAR OUT BG
	ST	R0,LUN,R7,R15
	L	R7,OTHER,R7		:CLEAR OUT BG
	ST	R0,LUN,R7,R15
:
	L	R7,OTHER,R6		:COPY TO DESTINATION FG
	ST	R1,LUN,R7,R3		
	L	R7,CONTROL,R6		
	ST	R1,LUN,R7,R3		:UPDATE DDT
	J	TTY			:DONE

QTRNM1	SC	/ENTER SOURCE L.U.: /
QTRNM2	SC	/ENTER DESTINATION SLOT: /
QTRNM3	SC	/ENTER DESTINATION L.U.: /
	EI	:NSLOT
	IF	NSLOT!MXP

: ?CT - CHANNELS TERMINATING

QCT	JAL	R4,QCHECK		:CHECK REQUEST
	LIS	R7,0			:SET FLAG
	LHL	R4,I.PSIZ,R6		:PROCEEDING TO LAST PORT...
	JE	QCT3			:(UNLESS THERE ARE NONE)...
	LIS	R4,1			:AND STARTING WITH PORT 1
	L	R5,I.PTBL,R6		:GET PTR TO START OF PERMUTER TABLE

QCT1	LH	R3,2,R5			:GET A PERMUTER TABLE ENTRY
	JE	QCT2			:BR IF NOTHING THERE
	JL	QCT4			:BR IF TIMEOUT OR CLEANUP
	LR	R0,R6			:GET SLOT NMBR
	SRLS	R0,2
	OHI	R0,300			:SET FUNC = 3 , PORT DESTINATION
	EXHR	R0,R0
	OR	R0,R4			:PORT NMBR
	SVC	SYS,$A 45		:GET PORT DESTINATION INFO
	 J	QCT7			:  SLOT WENT DOWN, END OUTPUT
	 J	QCT1			:  PORT WENT AWAY, TRY AGAIN
	EXHR	R7,R0			:SAVE MACH,SLOT,PORT
	SVC	OUT,QCTM2		:"PORT "
	LR	R0,R4
	LHI	R1,410
	SVC	KIO,$A 10		:PRINT PORT NMBR
	SVC	OUT,QCTM5		:"-->X"
	IF	MXP
	EXBR	R9,R7
	LBR	R0,R9			:ISOLATE MACHINE NMBR
	LHI	R1,30A
	SVC	KIO,$A 10		:PRINT MACHINE NMBR
	LBR	R0,R7
	CLHI	R0,0FF			:SEE IF SLOT NMBR KNOWN
	JEFS	QCT8			:BR IF NOT
	SVC	OUT,QCTM7		:":S" - SLOT NMBR
	EI
	LBR	R0,R7			:ISOLATE SLOT NMBR
	LHI	R1,20A			:2 DECIMAL DIGITS
	SVC	KIO,$A 10
	IF	MXP
QCT8	LBR	R9,R9
	CLHI	R9,MXPNM		:SEE IF DEST IS IN SAME MACHINE
	JEFS	QCT9			:BR IF SO
	SVC	OUT,QCTM8		:":R" - ROUTE NMBR
	JFS	QCT10
	EI
QCT9	SVC	OUT,QCTM6		:":P" - PORT NMBR
QCT10	EXHR	R0,R7			:ISOLATE PORT NMBR
	LHR	R0,R0
	LHI	R1,450			:4 HEX DIGITS
	SVC	KIO,$A 10
	J	QCT2			:AND CONTINUE

QCT4	SVC	OUT,QCTM2		:"PORT "
	LIS	R7,1			:NOT NO PORTS
	LR	R0,R4
	LHI	R1,410			:4 HEX DIGITS
	SVC	KIO,$A 10		:DISPLAY PORT #
	THI	R3,4000			:DISTINGUISH CLEANUP FROM TIMEOUT
	JEFS	QCT5			:CLEANUP...SKIP
	SVC	OUT,QCTM3		:"IN TIMEOUT"
	JFS	QCT2			:AND PROCEED
QCT5	SVC	OUT,QCTM4		:"IN CLEANUP"

QCT2	AIS	R5,2
	AIS	R4,1
	CLH	R4,I.PSIZ,R6		:TEST IF HAVE REACHED LAST PORT YET
	JLE	QCT1			:REPEAT FOR ALL
QCT7	LR	R7,R7			:CHECK FLAG
	JN	TTY,,			:WE'VE USED IT, SO JUST EXIT
QCT3	SVC	OUT,QCTM1		:"NO PORTS IN USE"
	J	TTY,,			:AND EXIT

QCTM1	SC	'"8D"8ANo ports in use'
QCTM2	SC	'"8D"8APort '
QCTM3	SC	' in timeout'
QCTM4	SC	' in cleanup'
	IF	MXP
QCTM5	SC	'-->m'
QCTM7	SC	':s'
QCTM8	SC	':r'
	ELSE
QCTM5	SC	'-->s'
	EI
QCTM6	SC	':p'
					:
:	.......................................................................
:	?HOST - HOST STATES
:	.......................................................................
					:
QHOST	JAL	R4,QCHECK		:CHECK OUT SLOT
	LR	R7,R6			:COPY SLOT INDEX
	LHL	R6,I.HSIZ,R7		:GET SIZE OF HOST TABLE
	JEFS	QHOST1			:SKIP IF NONE
	L	R6,I.HTBL,R7		:GET POINTER TO HOST TABLE
	JEFS	QHOST1			:(UNLESS THERE ARE NONE)...
	L	R5,I.UTBL,R7		:GET POINTER TO PORT TABLE
	JNFS	QHOST2			:(UNLESS THERE ARE NONE)...
QHOST1	SVC	OUT,QHM0		:"NO HOSTS IN USE"
	J	QHOST6			:ELSE TELL NUMBER OF PORTS
QHOST2	LIS	R4,0			:STARTING WITH HOST 0
QHOST3	SVC	OUT,QHM1		:CR/LF
	LR	R0,R4			:
	LHI	R1,410			:4 HEX DIGITS
	SVC	KIO,$A 10		:DISPLAY RELATIVE HOST #
	SVC	OUT,QHM2		:" HOST "
	LH	R0,0,R6			:GET HOST NUMBER
	JNFS	QHOST4			:SKIP IF IN USE
	SVC	OUT,QHM3		:"NOT IN USE"
	J	QHOST5			:AND PROCEED
QHOST4	LHI	R1,50A			:5 DECIMAL DIGITS
	SVC	KIO,$A 10		:DISPLAY HOST NUMBER
	SVC	OUT,QHM4		:" HAS "
	LHI	R0,3FFF			:
	NH	R0,0,R5			:GET NUMBER OF PORTS
	SVC	KIO,$A 10
	SVC	OUT,QHM5		:" PORTS, IS "
	LB	R1,0,R5			:LOCATE STATE
	SRHLS	R1,6			:
	LB	R1,QHMTBL,R1		:GET POINTER TO TEXT
	SVC	OUT,QHM6,R1		:OUTPUT MESSAGE
QHOST5	AIS	R6,2			:NEXT ENTRY
	AIS	R5,2			:
	AIS	R4,1			:
	CLH	R4,I.HSIZ,R7		:TEST IF HAVE REACHED LAST HOST YET
	JL	QHOST3			:REPEAT FOR ALL
QHOST6	LHL	R1,I.PSIZ,R7		:NOW, FOR ALL PORTS
	AR	R1,R1			:INDEX FOR LAST PERMUTER TABLE ENTRY
	JGFS	QHOST7			:(UNLESS THERE ARE NONE)...
	SVC	OUT,QCTM1		:"NO PORTS IN USE"
	J	TTY,,			:AND EXIT
QHOST7	SVC	OUT,QHM1		: CR-LF
	LIS	R0,0			:NUMBER OF PORTS IN USE
	L	R2,I.PTBL,R7		:GET POINTER TO START OF PERMUTER TABLE
QHOST8	LH	R3,0,R1,R2		:GET A PERMUTER TABLE ENTRY
	JLEFS	QHOST9			:SKIP IF NOT IN USE
	AIS	R0,1			:ELSE COUNT IT
QHOST9	SIS	R1,2			:ELSE SEARCH FURTHER
	JGBS	QHOST8			:REPEAT FOR ALL
	LHI	R1,50A			:5 DECIMAL DIGITS
	SVC	KIO,$A 10		:NUMBER OF PORTS
	SVC	OUT,QHM10		:"D PORTS IN USE"
	J	TTY,,			:EXIT
					:
QHM0	SC	'"8D"8ANo hosts in use'
QHM1	SC	'"8D"8A'		:CR/LF
QHM2	SC	' Host '
QHM3	SC	' not in use'
QHM4	SC	'd has '
QHM5	SC	'd ports, is '
QHM6	SC	'gone!'
QHM7	SC	'down!'
QHM8	SC	'shut'
QHM9	SC	'answered'
QHM10	SC	'd ports in use'
QHMTBL	BC	QHM9-QHM6,QHM7-QHM6,QHM8-QHM6,QHM6-QHM6	:STATE MESSAGE TABLE
					:
:	.......................................................................
:	?USE - REPORT USAGE
:	.......................................................................
					:
QUSE	JAL	R4,QCHECK		:CHECK REQUEST
	LHL	R7,I.PSIZ,R6		:FOR ALL PORTS
	JNFS	QUSE1			:(UNLESS THERE ARE NONE)...
	SVC	OUT,QCTM1		:"NO PORTS IN USE"
	J	TTY,,			:AND EXIT
					:
QUSE1	SVC	OUT,QUSEM1		:"HEADER..."
	SVC	OUT,QUSEM2		:"AND MORE HEADER..."
	LIS	R3,1			:NUMBER OF PORTS IN USE (CONTROL PORT)
	LIS	R4,0			:NUMBER WHICH REQUIRED BUFFERS
	LIS	R5,0			:AND STARTING WITH PORT 0
	L	R6,I.PTBL,R6		:GET POINTER TO START OF PERMUTER TABLE
	LHL	R0,SLOT,R8		:GET SLOT NMBR
	OHI	R0,400			:FUNC = 4, BFR USAGE
	EXHR	R0,R0			:PORT = 0
	SVC	SYS,$A 45		:GET PORT 0 BFR USAGE
	 J	QUSE			:SLOT DOWN, START OVER
	 NOP
	J	QUSE7			:AND SKIP

QUSE2	LH	R2,0,R6			:GET A PERMUTER TABLE ENTRY
	JG	QUSE4			:SKIP IF WE HAVE SOMETHING
QUSE3	AIS	R5,1			:ELSE SEARCH FURTHER
	AIS	R6,2
	SIS	R7,1			:TEST IF HAVE REACHED LAST PORT YET
	JGEBS	QUSE2			:REPEAT FOR ALL
QUSE9	LR	R4,R4			:WERE ANY BUFFERS USED?
	JE	TTY,,			:NO...JUST QUIT
	SVC	OUT,QUSEM4		:YES..."OUT OF "
	LHI	R1,50A			:5 DECIMAL DIGITS
	LR	R0,R3
	SVC	KIO,$A 10		:NUMBER OF PORTS
	SVC	OUT,QHM10		:"D PORTS IN USE"
	SVC	OUT,QUSEM5		:", USE WAS MADE OF "
	LR	R0,R4
	SVC	KIO,$A 10		:BUFFERS USED
	SVC	OUT,QUSEM6		:"D DISPATCHER BUFFERS"
	J	TTY,,			:AND EXIT

QUSE4	LHL	R0,SLOT,R8		:SLOT NMBR
	OHI	R0,400			:FUNC = 4
	EXHR	R0,R0
	OR	R0,R5			:PORT NMBR
	SVC	SYS,$A 45		:GET BFR USAGE INFO
	 J	QUSE9			:  SLOT DOWN, ABORT
	 J	QUSE3			:  PORT DOWN, BUMP TO NEXT
	EXHR	R2,R0			:SAVE INFO
	AIS	R3,1			:COUNT ANOTHER PORT
	SVC	OUT,QHM1		:"C/R::L/F"
	LR	R0,R5			:DISPLAY PORT #
	LHI	R1,530			:5 HEX DIGITS, BLANK FILL
	SVC	KIO,$A 10		:DISPLAY PORT #
	LHR	R0,R2			:GET PORT OUTPUT HISTORY
	JEFS	QUSE5			:NOT USED...SKIP
	AIS	R4,1			:USED IT...COUNT IT
	LHI	R1,0AAA			:10 SIGNED DECIMAL DIGITS, BLANK FILL
	SVC	KIO,$A 10		:AND DISPLAY NUMBER
	JFS	QUSE6			:AND SKIP
QUSE5	SVC	OUT,QUSEM3		:"NOT USED"
QUSE6	EXHR	R0,R2
QUSE7	LHR	R0,R0			:PORT INPUT HISTORY
	JEFS	QUSE8			:SKIP IF NOT USED
	AIS	R4,1			:ELSE COUNT IT
	LHI	R1,0AAA			:10 SIGNED DECIMAL DIGITS, BLANK FILL
	SVC	KIO,$A 10		:AND DISPLAY NUMBER
	J	QUSE3			:AND CONTINUE
QUSE8	SVC	OUT,QUSEM3		:"NOT USED"
	J	QUSE3			:AND CONTINUE

QUSEM1	SC	'"8D"8ADISPATCHER BUFFER USAGE:"8D"8A'
QUSEM2	SC	' port    output     input (# chars.)"8A"8D"8Acontrol    --  '
QUSEM3	SC	'  not used'
QUSEM4	SC	'"8D"8AOut of '
QUSEM5	SC	', use was made of '
QUSEM6	SC	'd DISPATCHER buffers'
	EI	:NSLOT!MXP
					:
:	.......................................................................
:	QUERY LOGICAL UNITS
:	.......................................................................
					:
QLU	LHI	R3,NLU			:Get max. number of L.U. per slot
	JLE	TTY			:Just return if there L.U. assigned
	LIS	R3,0			:LOGICAL UNIT COUNTER
					:
QLU010	SVC	OUT,QLUR01		:DEVICE NUMBER
	LHI	R1,20A
	LR	R0,R3
	SRLS	R0,2
	SVC	KIO,$A10		:
					:
	L	R1,LUN,R8,R3		:GET TYPE,UNIT
	JE	QLU030			:NULL
					:
	LB	R1,LUN,R8,R3		:GET JUST TYPE
	SLLS	R1,2			:MAKE FW INDEX
	L	R1,QLUR02,R1		:GET DEVICE TYPE TEXT
	ST	R1,QLUR04		:
	SVC	OUT,QLUR03		:DISPLAY TYPE
					:
	L	R1,LUN,R8,R3		:GET INDEX TO DEVICE TABLE
	LB	R0,1,R1			:GET LU NUMBER
	LHI	R1,32A			:
	SVC	KIO,$A10		:
					:
	LB	R0,LUN,R8,R3		:CHECK IF SIO
	CHI	R0,4			:
	JNFS	QLU020			:NO I/O ADDRESS IF NOT SIO
:
	SVC	OUT,QLUR06		:" ADDRESS "
	L	R1,LUN,R8,R3		:GET TABLE ADDRESS BACK
	LB	R0,2,R1			:GET I/O ADDRESS
	LHI	R1,230			:OUTPUT IN HEX
	SVC	KIO,$A10
:
QLU020	SVC	OUT,CRLF
	AIS	R3,4
	CHI	R3,NLU*4
	JL	QLU010
	J	TTY			:DONE!
:
QLU030	SVC	OUT,QLUR05		:REPORT NULL DEVIC
	JBS	QLU020
:
QLUR01  SC      /LU # /
QLUR02  AC      / SYN/
        AC      / ASN/
        AC      / PTR/
        AC      / ERR/
        AC      / SIO/
QLUR03  BC      $A19
        AC      / IS DEVICE TYPE/
QLUR04  BS      4
QLUR05  SC      / IS NOT USED/
QLUR06	SC	/ ADDRESS /
					:
:	.......................................................................
:	QPROF - Query ISIS system configuration profile
:	Following information will be provided:
:	1. Type of CPU
:	2. Type of MAC
:	.......................................................................
					:
	GL	MEMCON			:
QPROF	SVC	OUT,SYSPRO		:Output system profile header
	LIS	R1,ENGVER		:
	LR	R1,R1			:Is it a TSI Engine?
	JNFS	SYSCO1			:No, just skip ...
	SVC	OUT,TSIENG		:
	J	SYSCPU			:
SYSCO1	SIS	R1,1			:Is it a Tymnet Engine?
	JNFS	SYSCO2			:
	SVC	OUT,TYMENG		:
	J	SYSCPU			:
SYSCO2	SIS	R1,1			:Is it a Tymnet Mini Engine?
	JNFS	SYSCO3			:No, just skip ...
	SVC	OUT,MINENG		:Mini Engine
	J	SYSCPU			:
SYSCO3	SIS	R1,1			:
	JNFS	SYSCO4			:
	SVC	OUT,MICENG		:Micro Engine
	J	SYSCPU			:
SYSCO4	SIS	R1,1			:
	JNFS	SYSCO5			:
	SVC	OUT,PICENG		:PICO Engine
	JFS	SYSCPU			:
SYSCO5	SIS	R1,1			:
	JNFS	SYSc06			:
	SVC	OUT,HDLENG		:hdlc
	JFS	SYSCPU			:
sysc06	sis	r1,1
	JNFS	SYSCPU			:
	svc	out,pxleng		:pxl
SYSCPU	SVC	OUT,CPUID		:
	LHI	R1,24A			:2 decimal digits zero fill
	LHI	R0,CPUVER		:Type of CPU is in used
	SVC	KIO,$A	10		:
	SVC	OUT,MACID		:
	LHI	R1,24A			:2 decimal digits zero fill
	LHI	R0,MACVER		:Type of MAC is in used
	SVC	KIO,$A	10		:
	SVC	OUT,MEM00		:
	LHI	R0,MEMCON		:
	LHI	R1,40A			:4 decimal digits no zero fill
	SVC	KIO,$A	10		:
	SVC	OUT,MEM02		:
	SVC	OUT,MEM01		:
	L	R0,MEMTOP,,		:
	SRLS	R0,0A			:
	LHI	R1,40A			:4 decimal digits no zero fill
	SVC	KIO, $A 10		:
	SVC	OUT,MEM02		:
	J	TTY			:
					:
:	.......................................................................
:	QUERY CPU
:	CPU OF SLOT AS PERCENTAGE OF SYSTEM TIME
:	.......................................................................
					:
QCPU	SVC	OUT,Q1HDNG		:OUTPUT A BANNER
	SVC	OUT,Q2HDNG		:OUTPUT A BANNER
	LHL	R7,ULICEN,R8,		:CHECK REQUESTOR'S LISCENSE
        THI     R7,L.SYA                :DO ONLY HIS SLOT OTHERWISE
        JE      QCPU1			:
	LCS	R3,1			:
	JAL	R7,QCPUS		:
Q	EQ	0			:
	RE	NSLOT+1
   IF	10-Q
	LIS	R3,Q
   ELSE
	LHI	R3,Q
   EI	
        JAL     R7,QCPUS
Q       EQ      Q+1
        ER				:
        J       TTY			:
QCPU1	LH	R3,SLOT,R8,		:USERS SLOT ONLY
        JAL     R7,QCPUS		:
        J       TTY			:
					:
QCPUS	EQ	.
   IF	NSLOT
	LR	R6,R3			:Is it ISIS slot "FF"?
	JLFS	QCPUS0			:Yes...just skip over
	LR	R0,R3			:Make a copy of slot number
	EXHR	R0,R0			:Set func=0 and slot number
	SVC	SYS,$A 45		:Test slot status (up or down)?
	JR	R7			:Just return if slot is down ...
   EI  (NSLOT)
QCPUS0	LR	R0,R3			:Make a copy of slot number
	SLLS	R3,2			:MAKING AN INDEX
	LH	R5,LOCLKS,R3		:GET TIME FOR THIS SLOT
	LH	R1,LOCLKS+2,R3		:AND SYS TIME
					:
   IF	NSLOT				:
	LR	R6,R6			:Is it ISIS slot "FF"
	JLFS	QCPUS2			:NOT IF SYSTEM SLOT
	LR	R0,R6			:
	OHI	R0,100			:SET FUNC = 1, CLEAR CHAR CNTRS
	EXHR	R0,R0			:
	SVC	SYS,$A 45		:CLEAR DISPATCHER CHAR CNTRS
	NOP				:
   EI  (NSLOT)				:
					:
QCPUS2  L       R6,FASTC,               :AND SYSTEM
	SVC     DISMISS,1               :LET TIME FLY
	SH	R5,LOCLKS,R3		:TIME HAS PASSED?
	SIS	R5,1			:
	XI	R5,0FFFFFFFF		:MAKE THESE NUMBERS POSITIVE
	SH	R1,LOCLKS+2,R3		:AND SYS TIME
	SIS	R1,1			:
	XI	R1,0FFFFFFFF		:
	L	R4,FASTC,		:
	SR	R4,R6			:
        LHI     R6,$A 100               :MAKE A PERCENTAGE
	MHR	R5,R6			:MAKE A PERCENTAGE
	MHR	R1,R6			:
	DHR	R1,R4			:FIND USE
	DHR	R5,R4			:FIND USE
        SVC     OUT,CRLF                :NEW LINE
	LR	R0,R3			:GET THE SLOT INDEX
	SRLS	R0,2			:PUT BACK TO BYTE UNITS
	NHI	R0,0FF			:REMOVE EXCESS F'S FOR SYS SLOT
	LHI	R1,730			:7 HEX DIGITS, BLANK FILL
        SVC     KIO,$A 10             	:SLOT#
	LHI	R1,62A			:SIX WIDE,BLANK FILL,RADIX 10
	LR	R0,R6			:USE
        SVC     KIO,$A 10		:
	LR	R0,R2			:SYS USE
	SVC	KIO,$A 10		:
   IF	NSLOT!MXP			:
	LR	R0,R3			:SLOT INDEX
	JLR	R7			:IF SYSTEM SLOT
	SRLS	R0,2			:SLOT NMBR
	OHI	R0,200			:FUNC = 2, GET CHAR CNTRS
	EXHR	R0,R0			:
	SVC	SYS,$A 45		:GET DISPATCHER CHAR CNTRS
	LIS	R0,0			:Slot down, zero out counters
	LIS	R1,0			:
	LR	R2,R1			:SAVE OUTPUT CNTR
	LHI	R1,62A			:Six wide, blank fill, radix 10
	SVC	KIO,$A 10		:PRINT INPUT CPS
	LR	R0,R2			:RESTORE OUTPUT CNTR
	LHI	R1,62A			:Six wide, blank fill, radix 10
	SVC	KIO,$A 10		:PRINT OUTPUT CPS
   EI  (NSLOT)				:
        JR      R7			:Return ...
					:
   IF	NSLOT!MXP			:
Q1HDNG	SC	/"8D"8A    SLOT  RATE   RATE  RING STATS/
Q2HDNG	SC	/"8D"8A          USER  SYSTEM ICPS OCPS"8D"8A/
   ELSE					:
Q1HDNG	SC	/"8D"8A    SLOT  RATE   RATE/
Q2HDNG	SC	/"8D"8A          USER  SYSTEM"8D"8A/
   EI  (NSLOT)				:
					:
:	.......................................................................
:
:	QUERY WHO
:	self	p* USERNAME
:	active	p@ USERNAME
:	last	p  USERNAME (last user logged into this slot's DDT)
:		where p is slot number
:
:	.......................................................................
					:
QWHO	LA	R6,UBSYS,,		:
	JAL	R7,QWHOS		:START WITH SYSTEM SLOT
Q	EQ	0			:FOR ALL SLOTS:
	RE	NSLOT+1			:
	LA	R6,$A UBX|Q|,,
	JAL	R7,QWHOS
Q	EQ	Q+1
	ER				:
   IF	SUP				:
	LHL	R7,ULICEN,R8		:
	THI	R7,L.SUA!L.SYA		:CHECK REQUESTOR'S LICENCES
	JE	TTY			:QUIT IF INSUFFICIENT
	LA	R6,UBXSUP,,		:
	JAL	R7,QWHOS		:ELSE TELL OF SUP
	LA	R6,UBXPROBE,,		:
	JAL	R7,QWHOS		:...PROBE,
	LA	R6,UBXERR,,		:
	JAL	R7,QWHOS		:...ERRLOG,
	LA	R6,UBXACC,,		:
	JAL	R7,QWHOS		:...ACCOUNTING SLAVE,
	LA	R6,UBXSYS,,		:
	JAL	R7,QWHOS		:...SYSMSG1,
	LA	R6,UBXUN2,,		:
	JAL	R7,QWHOS		:...UN2,
	LA	R6,UBUTIL,,		:
	JAL	R7,QWHOS		:...AND UTILITY!
   EI  (SUP)				:
	J	TTY			:DONE...EXIT
					:
:	.......................................................................
:	WHO SUBROUTINE
:	.......................................................................
					:
QWHOS	SVC	OUT,CRLF		:START ON NEW LINE
	LH	R0,SLOT,R6		:
	LHI	R1,230			:2 HEX DIGITS, BLANK FILL
	SVC	KIO,$A 10		:SLOT #
	CR	R6,R8			:IS THIS US?
	JNFS	QWHOS1			:SKIP IF NOT
	SVC	OUT,QWHOM1		:"* "
	JFS	QWHOS4			:AND SKIP
QWHOS1	L	R1,RUN,,		:SEARCH IF THIS DDT IS ON RUN LIST
QWHOS2	CR	R6,R1			:
	JEFS	QWHOS3			:YES
	L	R1,LLINK,R1		:
	JNBS	QWHOS2			:KEEP SEARCHING
	SVC	OUT,BLBL		:NOT ON LIST..."  "
	JFS	QWHOS4			:AND SKIP
QWHOS3	SVC	OUT,QWHOM2		:"@ "
QWHOS4	LHL	R1,GGNDX,R6		:LOOK UP NAME
	LA	R1,GODGUY,R1		:COMPUTE HIS R8 ADDRESS
	L	R2,GGNAME,R1		:
	ST	R2,DRSA+2,R8		:
	LIS	R0,4			:COPY FIRST WORD OF NAME, SET SIZE
	L	R3,GGNAME+4,R1		:
	JEFS	QWHOS5			:SKIP IF SECOND WORD IS NULL
	ST	R3,DRSA+6,R8		:
	LR	R2,R3			:SAVE COPY OF LAST WORD
	LIS	R0,8			:
QWHOS5	THI	R2,0FF			:STRIP TRAILING NULLS
	JNFS	QWHOS6			:
	SRLS	R2,8			:
	SIS	R0,1			:
	JBS	QWHOS5			:
QWHOS6	STH	R0,DRSA,R8		:PLACE COUNT IN POSITION
	SVC	OUT,DRSA+1,R8		:OUTPUT USER NAME
	LHI	R1,7FFF			:LOOK UP PREVIOUS NAME
	NH	R1,OGGNDX,R6		:
	JER	R7			:RETURN IF NULL
	SVC	OUT,QWHOM3		:"  {"
	LA	R1,GODGUY,R1		:COMPUTE HIS R8 ADDRESS
	L	R2,GGNAME,R1		:
	ST	R2,DRSA+2,R8		:
	LIS	R0,4			:COPY FIRST WORD OF NAME, SET SIZE
	L	R3,GGNAME+4,R1		:
	JEFS	QWHOS7			:SKIP IF SECOND WORD IS NULL
	ST	R3,DRSA+6,R8		:
	LR	R2,R3			:SAVE COPY OF LAST WORD
	LIS	R0,8			:
QWHOS7	THI	R2,0FF			:STRIP TRAILING NULLS
	JNFS	QWHOS8			:
	SRLS	R2,8			:
	SIS	R0,1			:
	JBS	QWHOS7			:
QWHOS8	STH	R0,DRSA,R8		:PLACE COUNT IN POSITION
	SVC	OUT,DRSA+1,R8		:OUTPUT USER NAME
	SVC	OUT,QWHOM4		:"}"
	JR	R7			:THEN RETURN
					:
QWHOM1	SC	'* '			:
QWHOM2	SC	'@ '			:
QWHOM3	SC	'  {'			:
QWHOM4	SC	'}'			:
					:
:	.......................................................................
:	ENTER DEBUG MODE
:	.......................................................................
					:
QEDBG	LHL	R0,ULICEN,R8		:Get the current user license ...
	THI	R0,L.H!L.SYP		:Check if user has license to kill?
	JNFS	QEDBG0			:Yes...just skip
	LA	R1,BADLIC		:Get bad license
	JAL	R9,OOUT			:Send warning message to user
	J	TTYERR			:Take an error return
QEDBG0	LA	R1,AGAIN		:Confirm the user's request
	JAL	R9,OOUT			:
	JAL	R1,INCHAR		:Get the next input character
	JAL	R1,CUC			:Convert it to the upper case
	CLHI	R0,0D9			:Is it a "Y"?
	JN	TTY			:Return if user is not sure himself?
	SVC	SYS,2			:ENTER DEBUG
	J	TTY			:AND PROCEED
					:
:	.......................................................................
:	LEAVE DEBUG MODE
:	.......................................................................
					:
QLDBG	LHL	R0,ULICEN,R8		:Get the current user license ...
	THI	R0,L.H!L.SYP		:Check if user have sufficient license
	JNFS	QLDBG0			:Yes...just skip
	LA	R1,BADLIC		:Get the bad license message
	JAL	R9,OOUT			:Send warning message out to user
	J	TTYERR			:Take an error return
QLDBG0	LA	R1,AGAIN		:Confirm the user's request
	JAL	R9,OOUT			:
	JAL	R1,INCHAR		:Get the next input character
	JAL	R1,CUC			:Convert it to the upper case
	CLHI	R0,0D9			:Is it a "Y"?
	JN	TTY			:Return if user is not sure himself
	SVC	SYS,3			:LEAVE DEBUG
	J	TTY			:AND PROCEED
					:
:	.......................................................................
:	FREEZE SLOT
:	.......................................................................
					:
QFREZ	LHL	R0,ULICEN,R8		:Get the current user license ...
	THI	R0,L.H			:User have the license to kill
	JNFS	QFREZ0			:Yes, just skip ...
	LA	R1,BADLIC		:Get the bad license message
	JAL	R9,OOUT			:Send warning out to user for bad license
	J	TTYERR			:
QFREZ0	LA	R1,AGAIN		:Confirm the user's request
	JAL	R9,OOUT			:
	JAL	R1,INCHAR		:Get the next input character
	JAL	R1,CUC			:Convert it to the upper case
	CLHI	R0,0D9			:Is it a "Y"?
	JN	TTY			:Return if user is not sure himself
	SVC	SYS,5			:FREEZE IT
	LHI	R0,9^2			:Set code 9 - DDT
	STH	R0,EFLAG,R8		:Save it ...
	J	TTY			:and proceed to the next command
					:
:	.......................................................................
:	THAW SLOT
:	.......................................................................
					:
QTHAW	LHL	R0,ULICEN,R8		:Get the current user license...
	THI	R0,L.H			:User have the license to kill?
	JNFS	QTHAW0			:Yes, just skip
	LA	R1,BADLIC		:
	JAL	R9,OOUT			:Send warning message for bad license
	J	TTYERR			:
QTHAW0	LA	R1,AGAIN		:
	JAL	R9,OOUT			:Confirm the user's request
	JAL	R1,INCHAR		:Get the next input character
	JAL	R1,CUC			:Convert it to the upper case
	CLHI	R0,0D9			:Is it a "Y"?
	JN	TTY			:Return if user is not sure ..
	SVC	SYS,6			:THAW THE SLOT
QTHAW2	LHI	R0,9^2			:SET CODE 9 - DDT
	STH	R0,EFLAG,R8		:
	J	TTY			:AND PROCEED TO NEXT COMMAND
					:
:	.......................................................................
:	LOAD MAC
:	.......................................................................
					:
QLMAC	L	R1,CONTROL,R8		:INSURE CONTROLLED JOB IS DISPATCHER JOB
	LHL	R0,UFLAG,R1		:
	THI	R0,FDISP		:
	JE	TTYERR			:ERROR IF NOT
   IF	IPNMBR				:
        LHL     R0,SLOT,R8		:
        TBT     R0,IPDLCS,,             :SLOT FROM WHERE TO DOWN-LOAD IPI?
        JN      TTYERR                  :YES
   EI  (IPNMBR)				:
	JAL	R9,D.INIT		:KILL BREAKPOINTS, ETC
	LA	R1,COREXC		:SET ADDRESS OF ERROR MESSAGE IF FAIL
	SVC	SYS,$A 21		:GO DO IT
	J	BITCH			:FAILED...GO BITCH
	J	TTY			:SUCCESS...GO FOR NEXT COMMAND
					:
:	.......................................................................
:	QUERY MAC
:	.......................................................................
					:
QMAC	SVC	OUT,MACID		:Output MAC ID header
	LHI	R1,24A			:2 decimal digits zero fill
	LHI	R0,MACVER		:
	SVC	KIO,$A 10		:
	LHI	R3,@10+1		:COUNTER OF MAC REGISTERS
	L	R2,UMAC,R8		:GET ADDRESS OF CURRENT MAC SET
	SI	R2,MACDIS		:POINT TO START OF CURRENT MAC SET
QMAC1	L	R0,0,R2			:GET SEGMENTS MAC REG
	THI	R0,MASK1		:TEST PRESENCE
	JNFS	QMAC3			:GOT ONE
QMAC2	AIS	R2,4			:BUMP INDEX TO GET NEXT MAC REG	
	AIS	R3,1			:
	JLBS	QMAC1			:SEARCH ALL SEGMENTS
	J	TTY			:QUIT WHEN DONE
QMAC3	SVC	OUT,QMACM2		:WE HAVE ONE..."MAC SEG. "
	LR	R5,R0			:SAVE COPY
	LHI	R0,$A 16,R3		:
	LHI	R1,210			:2 HEX DIGITS
	SVC	KIO,$A 10		:SEGMENT #
	SVC	OUT,QMACM3		:" HAS "
	LR	R0,R5			:MAKE A COPY OF MAC REG
	NI	R0,MMASKL		:ISOLATE LENGTH FIELD
	SRL	R0,MSHFTL		:RIGHT JUSTIFY IT
	AIS	R0,1			:FORCE TO NEXT PAGE
	SLLS	R0,MSHFTB		:MAKE BYTE COUNT
	JAL	R9,OPROT		:OUTPUT VALUE, PROTECTION
	J	QMAC2			:
QMACM2	SC	'"8D"8AMAC seg. '	:
QMACM3	SC	' has '			:
					:
:	.......................................................................
:	ABS ROUTINE
:	.......................................................................
					:
QABS	JAL	R9,NUM			:GET ADDRESS
	LHI	R5,100			:
	NH	R5,CPSW,R8		:DETERMINE IF UNDER MAC
	JE	QABS1			:SKIP IF NOT
	LI	R2,SEGSIZ-1		:SET MASK
	NR	R2,R0			:ADDRESS WITHIN SEGMENT
	EXHR	R5,R0			:SEGMENT NUMBER
	NHI	R5,MMASKS		:
	SRLS	R5,MSHFTX		:RIGHT JUSTIFY IT
	SLLS	R5,2			:MAKE A WORD INDEX
	L	R6,UMAC,R8		:GET ADDR OF CURRENT MAC
	SI	R6,MACDIS		:POINT TO START OF MAC SET
	L	R5,0,R6,R5		:GET MAC REGISTER
	LR	R0,R5			:COPY IT
	JE	QABS2			:NULL...SKIP
	THI	R5,MASK1		:CHECK FOR PRESENT
	JE	QABS2			:SKIP IF NOT
	LR	R1,R0			:CHECK RANGE
	NI	R1,MMASKL		:ISOLATE LENGTH
	SRL	R1,MSHFTL		:RIGHT JUSTIFY IT
	AIS	R1,1			:FORCE TO NEXT PAGE
	SLLS	R1,MSHFTB		:MAKE FISRT ILLEGAL ADDRESS
	SR	R1,R2			:
	JLE	QABS2			:NO ACCESS PERMITTED
	NI	R0,MMASKR		:ELSE COMPUTE ABSOLUTE ADDRESS
	SRLS	R0,MSHFTA		:MAKE ADDRESS
	AR	R0,R2			:
   IF	ZITEL				:
	LR	R6,R5			:COPY MAC REGISTER
	NI	R6,30000000		:ISOLATE EXTENDED ADDRESS
	SRLS	R6,8			:SHIFT INTO POSITION
	OR	R0,R6			:COMBINE FOR ADDRESS
   EI  (ZITEL)				:
QABS1	SVC	OUT,QABSM2		:"PHYSICAL ADDRESS: "
	JAL	R9,OPROT		:OUTPUT VALUE, PROTECTION
	J	TTY			:AND EXIT
QABS2	SVC	OUT,QABSM1		:" ACCESS NOT ALLOWED"
	J	TTY			:
QABSM1	SC	' Access not allowed!'	:
QABSM2	SC	'Physical address: '	:
					:
:	.......................................................................
:	INTERNAL ROUTINE TO OUTPUT VALUE, PROTECTION
:	LINK ON R9
:	VALUE IN R0
:	MAC REGISTER IN R5
:	PRESERVES R1<-->DLINK
:	.......................................................................
					:
OPROT	LHI	R1,610			:6 HEX DIGITS
	SVC	KIO,$A 10		:BP ADDR
	SVC	OUT,OPROM1		:"X, "
	LR	R1,R5			:PUT MAC REG INT R1
   IF	ZITEL				:
	NI	R1,30000000		:ISOLATE 2 MOST SIG BITS OF ADDRESS
	SRLS	R1,8			:SHIFT OVER TO CORRECT POSITION
   EI  (ZITEL)				:
	LR	R0,R5			:PUT MAC REG INTO R0
	NI	R0,MMASKR		:ISOL 12 NEXT MOST SIG BITS OF ADD
	SRLS	R0,MSHFTA		:MAKE ADDRESS
   IF	ZITEL				:
	AR	R0,R1			:COMBINE TO GET ADDRESS
   EI  (ZITEL)				:
	SVC	OUT,OPROM7		:"STARTING AT LOCATION "
	LHI	R1,610			:6 HEX DIGITS
	SVC	KIO,$A 10		:OUTPUT SEGMENT START ADDRESS
	THI	R5,MASKE		:
	JNFS	OPROT1			:
	SVC	OUT,OPROM2		:"NO "
OPROT1	THI	R5,MASK6		:
	JEFS	OPROT2			:
	SVC	OUT,OPROM3		:"WRITE "
OPROT2	THI	R5,MASK8		:
	JEFS	OPROT3			:
	SVC	OUT,OPROM4		:"EXECUTION "
OPROT3	SVC	OUT,OPROM5		:"PROTECTION"
	LR	R5,R5			:CHECK IF COMMON AREA
	JGER	R9			:RETURN IF NOT
	SVC	OUT,OPROM6		:": SHARED!"
	JR	R9			:
OPROM1	SC	'x, '			:
OPROM2	SC	' no'			:
OPROM3	SC	' write'		:
OPROM4	SC	' execution'		:
OPROM5	SC	' protection'		:
OPROM6	SC	': SHARED!'		:
OPROM7	SC	'starting at location '	:
					:
:	.......................................................................
:	QUERY SLOT
:	.......................................................................
					:
QSLOT	SVC	OUT,QSLTM2		:OUTPUT HEADER
	SVC	OUT,QSLTM3		:OUTPUT UNDERLINE
	LH	R0,SLOT,R8		:GET SLOT KEY
	JLFS	QSLOT1			:SKIP, IF ISIS KERNEL
	L	R7,CONTROL,R8		:GET CONTROLED JOB
	JN	QSLOT0			:
	LR	R7,R8			:
QSLOT0	JAL	R4,QSLT1 		:OUTPUT SLOT INFO
	JAL	R4,QSLT3		:OUTPUT ISIS INFO
	J	TTY			:EXIT
					:
QSLOT1	JAL	R4,QSLT3		:OUTPUT ISIS INFO
	LR	R11,R8			:SAVE CURRENT UB POINTER
	LI	R9,NPART		:GET HIGHEST SLOT #
	LIS	R10,0			:START WITH SLOT 0
					:
QSLOT2	L	R7,SLIST,R10,		:POINT TO SLOT'S USER BLOCK
	L	R8,CONTROL,R7		:GET DDT USER BLOCK
	JN	QSLOT4			:
	LR	R8,R7			:		
QSLOT4	LHL	R0,SLOT,R8		:RTN EXPECTS SLOT # IN R0
	JAL	R4,QSLT1		:OUTPUT SLOT INFO
					:
QSLOT3	AIS	R10,4			:INC FULLWORD INDEX
	SIS	R9,1			:DEC # OF SLOTS LEFT
	JGE	QSLOT2			:IF MORE, DO NEXT
	LR	R8,R11			:RESTORE UB POINTER
	J	TTY			:EXIT
					:
QSLT1	SVC	OUT,QSLTMA		:"<CR><LF>"
	LHI	R1,730			:7 HEX DIGITS BLANK FILL
	SVC	KIO,$A 10		:OUTPUT SLOT #
	LH	R1,UFLAG,R7		:GET USER FLAGS
	THI	R1,FDISP		:IS IT DISPATCHER CONNECTED
	JE	QSLT13			:SKIP, IF NOT
	L	R0,CTASEG*4+MPROT,R8	:GET CTA MAC REG
	CL	R0,MPROT,R8		:IS IT SAME AS SEG 0
	JE	QSLT14			:IF SO, NOT LOADED
	SRLS	R0,MSHFTA		:MAKE ADDRESS
	X	R0,SBASE,R8		:
	TI	R0,MMASKR		:IS SEG E SET UP?
	JN	QSLT14			:IF NOT, NOT LOADED
	L	R2,SBASE,R8		:LOCATE CTA TABLE
	LHL	R3,PID,R2		:GET PRODUCT ID
	SHI	R3,PIDLOW		:ADJUST FOR LOWEST PID
	JL	QSLT11			:SKIP, IF OUT OF RANGE
	CLHI	R3,PIDENT-1		:CHECK FOR HIGHEST PID
	JG	QSLT11			:SKIP, IF OUT OF RANGE
	LR	R1,R3			:MAKE COPY OF OFFSET
	SLLS	R1,2			:MAKE FW INDEX
	L	R0,PIDTBL,R1		:GET PID CODE
	JE	QSLT11			:SKIP, IF NOT IN TBLE
	LIS	R1,3			:INIT CHAR COUNTER
					:
QSLT10	STB	R0,QSLTMD+6,R1		:STORE A CHAR OF PID
	SRLS	R0,8			:MOVE IN NEXT CHAR
	SIS	R1,1			:DEC CHAR COUNT
	JGE	QSLT10			:IF MORE, DO NEXT
	SVC	OUT,QSLTMD		:OUTPUT PID CODE
	JFS	QSLT12			:DO VERSION NEXT
					:
QSLT11	AHI	R3,PIDLOW		:RE-ADJUST PID
	LR	R0,R3			:MAKE COPY TO OUTPUT
	SVC	OUT,QSLTM7		:"  "
	SVC	OUT,QSLTM8		:"    "
	LHI	R1,250			:2 HEX DIGITS ZERO FILL
	SVC	KIO,$A 10		:OUTPUT NOT FOUND PID
	SVC	OUT,QSLTME		:" "

QSLT12	LB	R0,SVERNO,R2		:GET SLOT'S VERSION #
	LHI	R1,828			:8 OCTAL DIGITS BLANK FILL
	SVC	KIO,$A 10		:OUTPUT VERSION #
	SVC	OUT,QSLTM4		:"."
	LB	R0,SREVLEV,R2		:GET SLOT'S REVSION LEVEL
	LHI	R1,248			:2 OCTAL DIGITS ZERO FILL
	SVC	KIO,$A 10		:OUTPUT REVISION LEVEL
	LA	R3,TSTAMP,R2		:POINT TO GEN TIME STAMP 
	JAL	R5,QSLT2		:OUTPUT CODE GENERATION TIME
	JR	R4			:RETURN

QSLT13	SVC	OUT,QSLTMB		:WE HAVE NO INFO FOR SLOT
	JR	R4			:RETURN

QSLT14	SVC	OUT,QSLTM1		:SLOT IS NOT LOADED
	JR	R4			:RETURN

QSLT2	SVC	OUT,QSLTM7		:"    "
	LHI	R1,24A			:2 DECIMAL DIGITS ZERO FILL
	LB	R0,0,R3			:GET MONTH
	JE	QSLT21			:SKIP, IF DATE NOT PRESENT
	SVC	KIO,$A 10		:OUTPUT MONTH
	SVC	OUT,QSLTM6		:"/"
	LB	R0,1,R3			:GET DAY
	SVC	KIO,$A 10		:OUTPUT DAY
	SVC	OUT,QSLTM6		:"/"
	LB	R0,2,R3			:GET YEAR
	SVC	KIO,$A 10		:OUTPUT YEAR
	SVC	OUT,QSLTM8		:"  "
	LB	R0,3,R3			:GET HOURS
	SVC	KIO,$A 10		:OUTPUT HOURS
	SVC	OUT,QSLTM5		:":"
	LB	R0,4,R3			:GET MINUTES
	SVC	KIO,$A 10		:OUTPUT MINUTES
	SVC	OUT,QSLTM5		:":"
	LB	R0,5,R3			:GET SECONDS
	SVC	KIO,$A 10		:OUTPUT SECONDS
	SVC	OUT,QSLTM9		:" GMT"

QSLT21	JR	R5			:RETURN

QSLT3	SVC	OUT,QSLTMA		:"<CR><LF>"
	LHI	R0,0FF			:GET KERNEL SLOT #
	LHI	R1,730			:7 HEX DIGITS BLANK FILL
	SVC	KIO,$A 10		:OUTPUT SLOT #
	SVC	OUT,QSLTMC		:"     I2IS"
	LHI	R2,VERSION		:GET ISIS VERSION & REV
	LHI	R3,$A 100		:SEPARATE VER FROM REV
	DHR	R2,R3			: (VERSION IS DECIMAL)
	LR	R0,R3			:GET ISIS VERSION
	LHI	R1,82A			:8 DECIMAL DIGITS BLANK FILL
	SVC	KIO,$A 10		:OUTPUT VERSION
	SVC	OUT,QSLTM4		:"."
	LR	R0,R2			:GET ISIS REVSION
	LHI	R1,24A			:2 DECIMAL DIGITS ZERO FILL
	SVC	KIO,$A 10		:OUTPUT ISIS REVSION
	LA	R3,GENGMT		:POINT TO ISIS GEN TIME
	JAL	R5,QSLT2		:OUTPUT ISIS GEN TIME
	JR	R4			:RETURN
					:

QSLTM1	SC	/     * Not Loaded */
QSLTM2	SC	/    Slot    PID     Version    Code Generated"8D"8A/
QSLTM3	SC	/    ----    ----    -------    ----------------------/
QSLTM4	SC	/./
QSLTM5	SC	/:/
QSLTM6	SC	/"2F/
QSLTM7	SC	/    /
QSLTM8	SC	/  /
QSLTM9	SC	/ GMT/
QSLTMA	SC	/"8D"8A/
QSLTMB	SC	/     * Unknown */
QSLTMC	SC	/     I2IS/
QSLTMD	SC	/         /
QSLTME	SC	/ /
					:
:	.......................................................................
:	QUERY BACKGROUND PSW
:	.......................................................................
					:
QBT	LIS	R6,0			:SET CC FALSE
	LIS	R7,$A 11		:SET BACKGROUND PSD
	J	TDISP			:DISPLAY AND EXIT
					:
:	.......................................................................
:	QUERY FOREGROUND PSW
:	.......................................................................
					:
QFT	LIS	R6,0			:SET CC FALSE
	LIS	R7,$A 13		:SET FOREGROUND PSW
	J	TDISP			:DISPLAY AND EXIT
					:
:	.......................................................................
:	QUERY BACKGROUND REGISTERS
:	.......................................................................
					:
QBRR	LHI	R0,FBACK		:SET BACKGROUND TEST
	L	R7,CONTROL,R8		:LOCATE CONTROLLED JOB
	JFS	QRR			:PROCEED TO COMMON CODE
					:
:	.......................................................................
:	QUERY FOREGROUND REGISTERS
:	.......................................................................
					:
QFRR	L	R7,CONTROL,R8		:LOCATE CONTROLLED JOB
	JE	TTYERR			:ABORT IF NULL
	LHI	R0,FQUASI		:SET FOREGROUND TEST
	L	R7,OTHER,R7		:LOCATE CONTROLLED FOREGROUND
					:
:	.......................................................................
:	COMMON CODE TO QUERY REGISTERS
:	.......................................................................
					:
QRR	JE	TTYERR			:ABORT IF NULL
	NH	R0,UFLAG,R7		:CHECK IT OUT
	JE	TTYERR			:CONTROLLED MUST BE BACKGROUND
	LA	R7,RREG,R7		:START ADDRESS OF REGISTERS TO DISPLAY
	JAL	R9,NUM			:READ ADDRESS
	CHI	R0,0F			:IS FIRST REGISTER NUMBER VALID?
	JG	TTYERR			:
	LR	R15,R0			:
	JAL	R9,NUM			:READ COUNT
	AR	R0,R15			:NUMBER OF LAST REGISTER
	CHI	R0,10			:IS REG NUMBER VALID?
	JG	TTYERR			:
	LR	R12,R0			:
	SLLS	R15,2			:COMPUTE FIRST BYTE ADDR IN SAVE AREA
	AR	R15,R7			:R8 ADDR OF SAVE AREA
	SLLS	R12,2			:COMPUTE ADDR OF LAST BYTE IN REG SAVE AREA
	AR	R12,R7			:R8 ADDR OF SAVE AREA
	J	RRDISP			:AND GO DISPLAY IT
					:
:	.......................................................................
:	QUERY RETURN
:	.......................................................................
					:
QRET	LIS	R1,7			:SET SVC #
	J	TRANS1			:AND TRY TRANSFER TO DEFAULT USER SLOT, IF ANY
					:
:	.......................................................................
:	CHECK FOR USER DEFINED ENTRY
:	.......................................................................
					:
QCOM	L	R2,SBASE,R8		:GET SLOT'S CTA TABLE
	L	R0,DD.BG2,R2		:HAS HE DEFINED THIS?
	JE	TTYERR			:NO,ABORT
	JAL	R9,TRASL,,		:FIND PHYSICAL ADDRESS
	J	BMAC			:
	LR	R1,R0			:COPY ABSOLUTE
	LHL	R2,2,R1,		:GET NUMBER OF ENTRIES
	SIS	R2,1			:DECREMENT
	SLHLS	R2,3			:MAKE DOUBLE WORD INDEX
QCOM3	C	R3,4,R1,R2		:
	JEFS	QCOM4			:SKIP AHEAD,MATCH
	SIS	R2,8			:ELSE CONTINUE SCAN
	JGEBS	QCOM3			:CHECK NEXT ENTRY
	J	TTYERR			:ERROR, NO MATCH
QCOM4	L	R0,8,R1,R2		:
	LA	R9,TTY			:SET A RETURNTO TTY
	J	QSTAT1			:
					:
:	.......................................................................
:	QUERY STATUS
:	.......................................................................
					:
QSTAT	LH	R0,SLOT,R8		:IS COMMAND ISSUED FROM SLOT FF
	JL	TTYERR			:COMMAND ERROR IF SO
	L	R0,CTASEG*4+MPROT,R8	:GET CTA SEG REG
	CL	R0,MPROT,R8		:SAME AS SEG 0?
	JE	TTYERR			:ERROR, MAC NOT SET UP
	L	R2,SBASE,R8		:BASE OF CTA TABLE
	L	R0,DD.BGN,R2		:USER START ADDRESS
	JE	TTYERR			:COMMAND ERROR IF NO ADDRESS SPECIFIED
QSTAT1	ST	R0,OLDPSW+4,R8		:ELSE SET ADDRESS
	LHL	R0,SPSW,R8		:
	STH	R0,OLDPSW+2,R8		:AND SET UP PSD
	J	YY,R8			:ENTER USER CODE
					:
:	.......................................................................
:	QUERY VERSION
:	.......................................................................
					:
QVERN	SVC	OUT,QVERNM		:"ISIS VERSION "
	LHI	R0,IVERNO		:Output version #
	LHI	R1,20A			:2 DECIMAL DIGITS
	SVC	KIO,$A 10		:
	SVC	OUT,QVERM1		:Output "."
	LHI	R0,IRVLNO		:Output revision level #
	LHI	R1,24A			:3 DECIMAL DIGITS
	SVC	KIO,$A 10		:
	L	R7,CONTROL,R8		:GET CONTROLLED PROCESS
	JE	TTY			:EXIT IF NONE
	LH	R0,UFLAG,R7		:
	THI	R0,FDISP		:ALSO EXIT IF NOT A DISPATCHER JOB
	JE	TTY			:
	SVC	OUT,QVERM		:", SLOT'S VERSION "
	L	R2,SBASE,R8		:LOCATE CTA TABLE
	LB	R0,SVERNO,R2		:GET SLOT'S VERSION NUMBER
	LHI	R1,308			:3 OCTAL DIGITS
	SVC	KIO,$A 10		:
	SVC	OUT,QVERM1		:"."
	LB	R0,SREVLEV,R2		:REVISION LEVEL
	LHI	R1,348			:3 OCTAL DIGITS, ZERO FILL
	SVC	KIO,$A 10		:
	J	TTY			:AND QUIT
					:
QVERNM	SC	'"8D"8AISIS version: '
QVERM	SC	/d, slot's version: /
QVERM1	SC	/./
					:
:	.......................................................................
:	RESET BACKGROUND EXEC COUNTERS
:	.......................................................................
					:
	LO	FLASH			:
QBRST	LIS	R0,0			:
	STH	R0,BGON,,		:TURN OFF TRACE
	LI	R1,BGNUM-1		:GET HIGHEST CELL
	SLLS	R1,2			:MAKE FULLWORD INDEX
QBRST1	ST	R0,BGCNT,R1		:CLEAR THE COUNT
	SIS	R1,4			:
	JGEBS	QBRST1			:IF NOT DONE, DO NEXT
	LIS	R0,1			:
	STH	R0,BGON,,		:TURN TRACE BACK ON
	J	TTY			:
	FO	FLASH			:
					:
:	.......................................................................
:	DISPLAY BACKGROUND EXEC COUNTERS
:	.......................................................................
					:
	LO	FLASH			:
QBDSP	LIS	R0,0			:
	STH	R0,BGON,,		:TURN OFF TRACE
	SVC	OUT,QBDSM1		:DISPLAY HEADER
	SVC	OUT,QBDSM2		:
	L	R0,BGCNT		:GET FIRST COUNT VALUE
	JEFS	QBDSP1			:IF ZERO, SKIP IT
	SVC	OUT,QBDSM3		:OUTPUT HEADER
	LHI	R1,0C2A			:TWELVE DECIMAL BLANK FILL
	SVC	KIO,$A10		:OUTPUT COUNT
	SVC	OUT,CRLF		:GET NEXT LINE
QBDSP1	LIS	R2,0			:
QBDSP2	AIS	R2,4			:BUMP INDEX
	CLI	R2,(BGNUM-1)*4		:IS IT LAST ENTRY
	JGE	QBDSP3			:
	L	R3,BGCNT,R2		:GET COUNT VALUE
	JEBS	QBDSP2			:IF ZERO, SKIP
	LR	R0,R2			:
	SRLS	R0,2			:GET COUNTER NUMBER
	LHI	R1,82A			:EIGHT DECIMAL BLANK FILL
	SVC	KIO,$A10		:OUTPUT COUNTER NUMBER
	LR	R0,R3			:GET COUNT BACK
	LHI	R1,0C2A			:TWELVE DECIMAL BLANK FILL
	SVC	KIO,$A10		:OUTPUT COUNT
	SVC	OUT,CRLF		:GET NEXT LINE
	J	QBDSP2			:LOOK AT NEXT COUNTER
QBDSP3	L	R0,BGCNT,R2		:GET FIRST COUNT VALUE
	JEFS	QBDSP4			:IF ZERO, SKIP IT
	SVC	OUT,QBDSM4		:OUTPUT HEADER
	LHI	R1,0C2A			:TWELVE DECIMAL BLANK FILL
	SVC	KIO,$A10		:OUTPUT COUNT
	SVC	OUT,CRLF		:GET NEXT LINE
QBDSP4	LIS	R0,1			:
	STH	R0,BGON,,		:TURN TRACE BACK ON
	J	TTY			:
	FO	FLASH			:


QBDSM1	SC	/    ticks    frequency"8D"8A/
QBDSM2	SC	/    -----    ---------"8D"8A/
QBDSM3	SC	/      <1/
QBDSM4	SC	/    >600/

					:
:	....................................................................
:	HANG PORT
:	....................................................................
					:
QHANG	LHL	R4,ULICEN,R8		:
	THI	R4,L.SYA!L.SUA		:
	JE	TTYERR			:
	JAL	R9,NUM			:READ THE PORT NO.
	CLHI	R0,NKU+1		:
	JGE	TTYERR			:
	LR	R1,R0			:SET R1 FOR CALL TO HANG
	JAL	R4,HANG,,		:CALL ON KERNEL TO HANG PORT
	J	TTY			:
					:
:	....................................................................
:	QUERY PORT
:	SELF   P* USERNAME
:	ACTIVE P  USERNAME WHERE P IS KERNEL PORT NO.
:	....................................................................
					:
Q	EQ	0			:
QPORT	SVC	OUT,QPMSG0		:Output header message
	LA	R6,UBSYS,,		:
	JAL	R7,QPORTS		:
	RE	NKUB
	LA	R6,$A UBX|Q|,,
	JAL	R7,QPORTS
Q	EQ	Q+1
	ER				:
	J	TTY			:Return ...
					:
QPMSG0	SC	/Port Slot   U"2FB PTR   Username /
					:
					:
:	....................................................................
:	QPORTS SUBROUTINE
:	....................................................................
					:
	HS	0			:
QPORTS	L	R1,RUN,,		:
QPRT1	CR	R6,R1			:
	JEFS	QPRT2			:
	L	R1,LLINK,R1		:
	JNBS	QPRT1			:
	JR	R7			:
QPRT2	SVC	OUT,CRLF		:
	LHL	R0,BUFNO,R6		:
	LHI	R1,230			:2 HEX DIGITS, BLANK FILL
	SVC	KIO,$A 10		:PORT #
	LA	R1,BLBL			:
	CL	R6,USER,,		:
	JNFS	QPRT3			:
	LA	R1,QWHOM1		:
QPRT3	SVC	OUT,0,R1		:
	SVC	OUT,BLBL		:
	LHL	R0,SLOT,R6		:Get the current slot number
	LHI	R1,230			:
	SVC	KIO,$A 10		:Output the slot number
	SVC	OUT,BLBL1		:
	LR	R0,R6			:
	LHI	R1,850			:
	SVC	KIO,$A 10		:Output U/B pointer
	SVC	OUT,BLBL		:
	LHL	R1,GGNDX,R6		:LOOK UP NAME
	LA	R1,GODGUY,R1,		:COMPUTE HIS R8 ADDRESS
	L	R2,GGNAME,R1		:
	ST	R2,DRSA+2,R8		:
	LIS	R0,4			:COPY FIRST WORD OF NAME, SET SIZE
	L	R3,GGNAME+4,R1		:
	JEFS	QPRT4			:SKIP IF SECOND WORD IS NULL
	ST	R3,DRSA+6,R8		:
	LR	R2,R3			:SAVE COPY OF LAST WORD
	LIS	R0,8			:
QPRT4	THI	R2,0FF			:STRIP TRAILING NULLS
	JNFS	QPRT5			:
	SRLS	R2,8			:
	SIS	R0,1			:
	JBS	QPRT4			:
QPRT5	STH	R0,DRSA,R8		:PLACE COUNT IN POSITION
	SVC	OUT,DRSA+1,R8		:OUTPUT USER NAME
	JR	R7			:THEN RETURN
					:
:	.......................................................................
:       Query SMAC - GET MAC SET NUMBER FOR USE BY DDT
:	.......................................................................
					:
QSMAC   L       R1,STAMAC,R8            :IS EXT. MAC THERE?
        JE      TTYERR                  :ERROR IF NOT
					:
	CLHI	R0,8D			:IS DELIMITER CR
	JE	QSMC20			:IF SO, USE INTERNAL SET
	CLHI	R0,8A			:IS IT LF
	JE	QSMC20			:IF SO, USE INTERNAL SET
					:
        JAL     R9,NUM                  :READ MAC SET #
        LHR     R0,R0                   :CHECK FOR 8000 OR LARGER
        JL      QSMC20                  :USE INTERNAL SET
					:
        CH      R0,LIMMAC,R8            :CHECK ON LIMIT
        JGE     TTYERR			:
					:
        LHI     R1,$A19*4               :LOCATE MAC
        MHR     R0,R1                   :DISPLACEMENT TO MAC SET
        A       R0,STAMAC,R8            :ABSOLUTE ADDRESS
QSM010  ST      R0,UMAC,R8              :CHAGE UMAC
        J       TTY			:
					:
QSMC20  LA      R0,MPROT+MACDIS,R8      :SWITCH TO INTERNAL
        JBS     QSM010			:
					:

	SUBTTL	DDT UTILITIES RELATED TO MAC

:	.......................................................................
:
:	GETMRG - FIND MAC SEGMENT REGISTER ASSOCIATED WITH ADDRESS SPECIFIED 
:		 IN RO
:
:       LINK ON R9
:       DESTROYS R0
:       RETURNS MAC IN R1
:
:	.......................................................................
					:
GETMRG  EXHR    R1,R0                   :GET SEG NUMBER
        NHI     R1,MMASKS               :ISOLATE SEGMENT NUMBER
	SRLS	R1,MSHFTX		:RIGHT JUSTIFY IT
        SLLS    R1,2                    :MAKE FW INDEX
        A       R1,UMAC,R8              :LOCATION OF MAC
        L       R1,-MACDIS,R1,          :GET MAC VALUE
        JR      R9			:
					:
:	.......................................................................
:	MTST - TEST ACCESS  - R7 HAS ADDR OF ACCESS TYPE - RO OR RW
:	USES R0---CALLS USER (SPECIFIED BY R7) OF R0-R2
:	.......................................................................
					:
MTST	ST	R9,TLINK,R8		:SAVE LINK
	LR	R0,R12			:COPY END ADDRESS
VLOOP	JALR	R9,R7			:CALL CHECKER
	J	VERR1			:BAD ACCESS
	OI	R0,SEGSIZ-1		:FORCE TO END OF SEGMENT
	SI	R0,SEGSIZ		:BUMP TO LAST ADDRESS OF NEXT LOWER SEGMENT
	CR	R0,R15			:IS THIS ADDRESS < START ADDRESS?
	JGEBS	VLOOP			:YES
	L	R9,TLINK,R8		:
	JR	R9			:RETURN
					:
:	.......................................................................
:	TEST READ ACCESS (NOT STRICTLY READ ONLY)
:	.......................................................................
					:
TRO	LIS	R11,0			:SET MASK FOR INHIBIT BITS
	JFS	TRWX0			:EXECUTE COMMON CODE WITH TEX, TRW
					:
:	.......................................................................
:	TEST EXECUTE ACCESS
:	.......................................................................
					:
TEX	LHI	R11,MASK8		:SET UP MASK FOR INHIBIT BITS
					:
:	.......................................................................
:	COMMON CODE FOR TRO, TEX
:	.......................................................................
					:
TRWX0	EXHR	R1,R0			:R0 HAS USER ADDRESS - RIGHT JUSTIFY "SN"
	NHI	R1,MMASKS		:ISOLATE "SN"
	SRLS	R1,MSHFTX		:RIGHT JUSTIFY IT
TRWX1	SLLS	R1,2			:INDEX WORD TABLE
        A       R1,UMAC,R8              :LOCATE USER'S MAC
        L       R1,-MACDIS,R1,          :GET THE MAC REGISTER
	THI	R1,MASK1		:CHECK PRESENCE BIT
	JER	R9			:SEGMENT NOT PRESENT - ERROR
TRWX2	NR	R11,R1			:CHECK ACCESS INHIBIT BITS
	JEFS	TRWX3			:ACCESS NOT INHIBITED
	LIS	R11,0			:RESTORE VALUE OF R11
	JR	R9			:NON-SKIP RETURN - NO ACCESS
TRWX3	NI	R1,MMASKL		:ISOLATE "SLF" 
	SRL	R1,MSHFTL		:RIGHT JUSTIFY IT
	LR	R2,R0			:MAKE A COPY OF ADDRESS
	NI	R2,MACSIZ		:ISOLATE "BN" 
	SRL	R2,MSHFTB		:RIGHT JUSTIFY IT
	CR	R2,R1			:IS ADDR IN RANGE OF SEGMENT
	JLE	4,R9			:ACCESS OK
	JR	R9			:ERROR RETURN
					:
:	.......................................................................
:	UTRASL - TRANSLATE PHYSICAL ADDRESS TO USER ADDRESS 
:	RETURN -1 IF NO TRANSLATION
:	PHYSICAL ADDR IN R0, USES R1-R4
:	.......................................................................
					:
UTRASL	LHI	R1,CTASEG*4		:SEARCH MAC REGISTERS BACKWARDS
UTRAS0	L	R3,MPROT,R1,R8		:GET NEXT MAC REGISTER
	LR	R4,R3			:
	NI	R3,MMASKR		:ISOLATE "SRF" - MIN ADDR FOR SEG
	SRLS	R3,MSHFTA		:MAKE ADDRESS
	NI	R4,MMASKL		:ISOLATE "SLF"
	SRL	R4,MSHFTL		:RIGHT JUSTIFY IT
	SLLS	R4,MSHFTB		:MAKE BYTE ADDRESS 
	AHI	R4,PAGE-1,R3		:MAX ADDR FOR THIS SEGMENT
	CLR	R0,R3			:CHECK IF PHYSICAL ADDR IN SEGMENT
	JLFS	UTRAS1			:NOT IN THIS SEGMENT
	CR	R0,R4			:
	JLEFS	UTRAS2			:IN THIS SEGMENT !!!
UTRAS1	SIS	R1,4			:INDEX NEXT MAC REGISTER
	JGE	UTRAS0			:LOOP
	LCS	R0,1			:CANNOT TRANSLATE - RETURN -1
	JR	R9			:
UTRAS2	SR	R0,R3			:REMOVE RELOCATION
	SRLS	R1,2			:RIGHT JUSTIFY "SN"
	EXHR	R1,R1			:POSITION "SN"
	SLLS	R1,MSHFTX		:POSITION FOR MAC REGISTER
	OR	R0,R1			:THIS IS USER ADDR
	JR	R9			:
					:

	SUBTTL	U T I L I T I E S

					:
:	.......................................................................
:	FRONT END FOR QUERIES...GENERATES GENERAL DIAGNOSTICS FOR USER
:
:	LINKED TO VIA R4
:	RETURNS	R7	R8 OF CONTROLLED USER BLOCK
:		R6	SLOT INDEX
:	.......................................................................
					:
QCHECK	LA	R1,QCHKM1		:NO CONTROL MESSAGE
	L	R7,CONTROL,R8		:GET CONTROLLED PROCESS
	JE	QCHK2			:SKIP IF THERE IS NONE
	SVC	SYS,7			:IS SLOT FROZEN?
	LR	R0,R0			:
	JEFS	QCHK1			:SKIP IF NOT
	SVC	OUT,QCHKM4		:"...FROZEN"
QCHK1	LA	R1,QCHKM2		:NOT DISPATCHER MESSAGE
	LH	R0,UFLAG,R7		:TEST IF DISPATCHER JOB
	THI	R0,FDISP		:
	JEFS	QCHK2			:NO..SKIP
	LH	R6,SLOT,R7		:SLOT NMBR
	EXHR	R0,R6			:SET FUNC = 0 & SLOT NMBR
	SLLS	R6,2			:SLOT INDEX
	SVC	SYS,$A 45		:GET DISPATCHER STS OF SLOT
	 J	QCHK3			:BR IF DOWN
	JR	R4			:UP ... PROCEED
QCHK3	LA	R1,QCHKM3		:DOWN...SAY SO
QCHK2	SVC	OUT,0,R1		:GIVE DIAGNOSTIC
	J	TTY,,			:THEN QUIT
					:
QCHKM1	SC	'"8D"8ANo controlled process'
QCHKM2	SC	'"8D"8ACommand valid ONLY if controlling background job'
QCHKM3	SC	'"8D"8ADispatcher indicates slot is down'
QCHKM4	SC	'"8D"8ASlot is FROZEN!!'

					:
:	.......................................................................
:	GET A COMMAND CHAR
:	USES R0-R2
:	.......................................................................
					:
GETCMD	LH	R0,MODE,R8		:CHECK MODE
	JE	GCMD1			:ASCII...JUST SKIP TO GET CHARACTER
	JAL	R2,INCMD		:READ A CHAR
	CLHI	R0,81			:IS IT FLUSH CHAR?
	JE	TTY			:YES...ABORT
	CLHI	R0,80			:IS IT ESCAPE CHAR?
	JN	GCMD4			:BYTE IN R0 - SKIP
	JAL	R1,INCHAR		:READ ESCAPED BYTE
	XHI	R0,40			:DECODE ESCAPED BYTE
	JFS	GCMD4			:CHAR IN R0 - SKIP
GCMD1	LR	R10,R10			:ASCII..IF WE'VE NOT "PEEKED", INPUT CHAR
	JEFS	GCMD2			:
	LB	R0,INBUF,R8		:ELSE RETURN CHAR ALREADY "PEEKED" AT
	LIS	R10,0			:SET IT GONE
	JFS	GCMD3			:AND SKIP
GCMD2	JAL	R2,INCMD		:READ A CHAR
					:
GCMD3	JAL	R2,ZDLIM		:FIND NEXT NON-DELIMITER CHAR
	J	GCMD1			:*LEAVE RX2*ANOTHER DELIMITER
GCMD4	JAL	R1,CUC			:CONVERT "a-z" TO "A-Z"
	JR	R9			:RETURN
					:
:	.......................................................................
:	INPUT A COMMAND CHARACTER
:	LINK	R2
:	RETURN CHAR IN R0...BUT EXITS TO TTY IF ESCAPE OCCURS
:	ALSO, FOR CONSOLE TTY, ABORT AND PRINT DIAGNOSTICS IF PRESENT
:	.......................................................................
					:
INCMD	SVC	IN,8			:GET THE CHAR
	J	INCMD1			:IF NOT THERE, CHECK FOR ESCAPES
	LIS	R10,0			:SHOW NO CHARS IN BUFFER
	JR	R2			:THEN RETURN, CHAR IN R0
INCMD1	LH	R0,FLAG,R8		:SEE IF USER HAS ABORTED
	JL	TTY			:YES
	LH	R0,MODE,R8		:CHECK MODE
	JNBS	INCMD			:BINARY...KEEP SCANNING
	LHL	R0,BUFNO,R8		:CHECK PORT
	LO	KCAREA			:
	CLHI	R0,NKU			:LOOKING FOR CONSOLE TTY
	JN	INCMD			:OTHERS, JUST IGNOR
	LHL	R0,DIAGIN,,		:
	CLH	R0,DIAGOUT,,		:OK...CHECK FOR NEW DIAGNOSTIC
	JE	INCMD			:NO...JUST CONTINUE


:	OUTPUT DIAGNOSTICS (UNREPORTED DIAGNOSTICS)
:	(ENTRY FOR TTY PORT, OR FROM "?DIAG" COMMAND)
QDIAG	JAL	R3,TOSTIM		:OUTPUT SYSTEM TIME
	LHL	R4,DIAGOUT,,		:GET OUTPUT CURSOR
	CLH	R4,DIAGIN,,		:CHECK IT
	JE	TTY			:NOTHING PRESENT
QDIAG1	JAL	R5,ODIAGN		:ELSE OUTPUT MESSAGE
	JAL	R1,ADC			:ADVANCE CURSOR
	JFS	QDIAG2			:DONE..SKIP
	JBS	QDIAG1			:NOT DONE...PRINT NEXT MESSAGE
QDIAG2	STH	R4,DIAGOUT,,		:DONE...SAVE CURSOR
	J	TTY			:AND EXIT TO COMMAND SCANNER
					:
:	.......................................................................
:	QUERY MEMORY ERRORS FROM MEMORY BOARD LOG
:	LAYOUT:  |BYT(SPR)|BYT(CNT)|HALF(D/S,BD,ROW/CHIP|WORD(TIME)|
:	.......................................................................
					:
  IF	MACV				:
  ELSE					:
QMEM	LIS	R5,0			:SIGNAL HEADING NOT OUTPUT
   IF	ZITEL				:
	LO	FLASH			:MEM TRACE IN FLASH LOGIC
	LHL	R4,MEMIN,,		:GET LOG INDEX
QMEM1	L	R0,MEMTRC+4,R4,		:GET TIME OF ERROR
	JE	QMEM5			:IF NO ENTRY, LOOK AT NEXT
   ELSE					:
	LHL	R4,PEINDX,,		:GET PARITY LOG INDEX
QMEM1	LH	R6,PETRC+PEFLAG,R4,	:GET FLAGS FOR ENTRY
	JGE	QMEM5			:IF NO ENTRY, LOOK AT NEXT
   EI  (ZITEL)				:
	LR	R5,R5			:HAS HEADING BEEN OUTPUT?
	JNFS	QMEM2			:IF SO, SKIP
	LIS	R5,1			:SIGNAL HEADING OUTPUT
	SVC	OUT,QMEMM1		:OUTPUT HEADING LINE
	SVC	OUT,QMEMM2		:OUTPUT HEADING LINE
QMEM2	SVC	OUT,QMEMM3		:OUTPUT CR&LF
	SVC	OUT,QMEMM4		:OUTPUT BLANKS
	L	R1,SLOWC		:GET CURRENT TIME
   IF	ZITEL				:
   ELSE					:
	L	R0,PETRC+PETIME,R4,	:GET TIME OF ERROR
   EI  (ZITEL)				:
	SR	R1,R0			:GET TIME ELAPSED
	JAL	R3,TOTIME		:OUTPUT ELAPSED TIME
   IF	ZITEL				:
	LHI	R1,092A			:9 DEC BLANK FILL
	LB	R0,MEMTRC+1,R4,		:GET COUNT
	SVC	KIO,$A 10		:OUTPUT COUNT
	LB	R0,MEMTRC+2,R4,		:GET BOARD
	NHI	R0,0F			:REMOVE EXTRANEOUS
	LHI	R1,082A			:8 DEC BLANK FILL
	SVC	KIO,$A 10		:OUTPUT BOARD #
	LH	R0,MEMTRC+2,R4,		:GET ERROR TYPE
	JLFS	QMEM3			:IF DOUBLE BIT , SKIP
	SVC	OUT,QMEMM5		:OUTPUT SINGLE BIT MESSAGE
	JFS	QMEM4			:SKIP
QMEM3	SVC	OUT,QMEMM6		:OUTPUT DOUBLE BIT MESSAGE
QMEM4	LB	R0,MEMTRC+3,R4,		:GET U NUMBER OR ROW
	LHI	R1,03AA			:3 DEC SIGNED
	SVC	KIO,$A 10		:OUTPUT IT
QMEM5	AIS	R4,8			:BUMP LOG INDEX
	CLHI	R4,NMTRC*8		:END OF LOG?
	JLFS	QMEM6			:IF NOT, SKIP
	LIS	R4,0			:WRAP LOG INDEX
QMEM6	CH	R4,MEMIN,,		:GONE THROUGH THE LOG?
	JN	QMEM1			:IF NOT, DO NEXT
	FO	FLASH			:
   ELSE					:
	SVC	OUT,QMEMM4		:OUTPUT BLANKS
	LR	R2,R6			:COPY FLAGS
	NHI	R2,700			:MASK OFF TYPE BITS
	SRLS	R2,9			:DIVIDE TYPE BY 2
	SLLS	R2,2			:MAKE WORD INDEX
	SVC	OUT,QMEMM5,R2		:OUTPUT TYPE TEXT
	LHL	R0,PETRC+PECNT,R4,	:GET ERROR COUNT
	LHI	R1,0A2A			:10 DEC BLANK FILL
	SVC	KIO,$A 10		:OUTPUT COUNT
	THI	R6,PEUADR		:WAS ADDR UNKNOWN?
	JEFS	QMEM3			:IF NOT, SKIP
	SVC	OUT,QMEMM7		:OUTPUT UNKNOWN MSG
	JFS	QMEM5			:DO NEXT ENTRY
QMEM3	L	R0,PETRC+PEADDR,R4,	:GET ADDRESS OF ERROR
	LHI	R1,0D30			:13 HEX BLANK FILL
	SVC	KIO,$A 10		:OUTPUT ADDRESS
QMEM5	AHI	R4,PELEN		:BUMP LOG INDEX
	CLHI	R4,PTLEN		:IS IT END OF LOG?
	JLFS	QMEM6			:IF NOT, SKIP
	LIS	R4,0			:WRAP INDEX
QMEM6	CLH	R4,PEINDX,,		:ALL ENTRIES OUTPUT?
	JN	QMEM1			:IF NOT, DO NEXT
   EI  (ZITEL)				:
	LR	R5,R5			:WERE ANY ERRORS FOUND?
	JE	QMEM7			:IF NOT, SKIP
	JAL	R3,TOSTIM		:OUTPUT SYSTEM TIME
	J	TTY			:RETURN
QMEM7	SVC	OUT,QMEMMA		:OUTPUT NO ERRORS MSG
	J	TTY			:RETURN
					:	
   IF	ZITEL
QMEMM1	SC	/    Time Ago         Times    Board    Type    Row    Chip"8D"8A/
QMEMM2	SC	/    -------------    -----    -----    ----    ---    ----/
	ELSE
QMEMM1	SC	/    Time Ago         Type    Times    Phys. Address"8D"8A/
QMEMM2	SC	/    -------------    ----    -----    -------------/
   EI  (ZITEL)
QMEMM3	SC	/"8D"8A/
QMEMM4	SC	/    /
   IF	ZITEL
QMEMM5	SC	/      SB             /
QMEMM6	SC	/      DB      /
   ELSE
    IF	TSI!NANO
QMEMM5	SC	/SPI/
	SC	/I"2FO/
	SC	/CPU/
	SC	/***/
    ELSE
QMEMM5	SC	/DMA/
	SC	/***/
	SC	/CPU/
	SC	/***/
    EI (TSI!NANO)
   EI  (ZITEL)
QMEMM7	SC	/      unknown/
QMEMMA	SC	/No parity errors reported/
  EI   (MACV)				:
					:
:	.......................................................................
:	OUTPUT HISTORY (ALL PREVIOUS DIAGNOSTICS)
:	.......................................................................
					:
QHIST	JAL	R3,TOSTIM		:OUTPUT SYSTEM TIME
	LHL	R4,DIAGIN,,		:GET INPUT CURSOR
QHIST1	JAL	R5,ODIAGN		:OUTPUT MESSAGE
	JAL	R1,ADC			:ADVANCE CURSOR
	JR	R9			:DONE...EXIT
	JBS	QHIST1			:NOT DONE...PRINT NEXT MESSAGE
					:
:	.......................................................................
:	OUTPUT A DIAGNOSTIC TEXT LINE
:	LINK ON R5
:	R4	DIAGNOSTIC CURSOR
:	IMMEDIATE RETURN (NO OUTPUT) FOR NULL ENTRY
:	.......................................................................
					:
ODIAGN	L	R0,DIAGNOS+4,R4,	:GET TIME
	JER	R5			:ABORT IF NULL
	SVC	OUT,CRLF		:"newline"
	L	R1,SLOWC		:
	SR	R1,R0			:ELAPSED TIME IN R1
	JAL	R3,TOTIME		:
	SVC	OUT,ODM1		:" SINCE SLOT "
	LB	R0,DIAGNOS,R4,		:GET NUMBER
	LHI	R1,03AA			:3 SIGNED DECIMAL DIGITS
	SVC	KIO,$A 10		:
	SVC	OUT,ODM2		:": "
	L	R1,DIAGNOS,R4,		:GET POINTER TO TEXT
	SVC	OUT,0,R1		:
	JR	R5			:AND EXIT
					:
ODM1	SC	/ ago, slot /		:
ODM2	SC	/: /			:
					:
:	.......................................................................
:	ADVANCE DIAGNOSTIC CURSOR
:	LINK ON R1
:	R4 = CURRENT OUTPUT CURSOR
:	NORMAL RETURN IF IN = OUT
:	ELSE SKIP (^2) RETURN
:	.......................................................................
					:
ADC	AIS	R4,8			:BUMP IT
	CLHI	R4,NDIAGN		:
	JLFS	.+4			:NO FOLD
	LIS	R4,0			:ELSE FOLD BACK
	CLH	R4,DIAGIN,,		:
	JER	R1			:CAUGHT UP...NORMAL RETURN
	J	2,R1			:NOT CAUGHT UP...SKIP 2 RETURN
					:
	FO	KCAREA			:
					:
QTIME	LR	R3,R9			:ENTRY FROM "?TIME"...COPY RETURN
					:
:	.......................................................................
:	TYPE OUT SYSTEM TIME (SLOWC)
:	LINK ON R3
:	.......................................................................
					:
TOSTIM	L	R1,SLOWC		:GET TIME
	SVC	OUT,STOM1		:" CURRENT SYSTEM TIME IS: "
					:
:	.......................................................................
:	TYPE OUT TIME
:	R3 = LINK
:	R1 = TIME
:	.......................................................................
					:
TOTIME	LIS	R0,0			:
	D	R0,DAYS			:STRIP OUT DAYS
	LR	R2,R0			:
	LR	R0,R1			:ANY DAYS?
	JNFS	TOTIM1			:IF SO, SKIP
	SVC	OUT,TOM2		:OUTPUT BLANKS
	JFS	TOTIM2			:
TOTIM1	LHI	R1,042A			:4 DECIMAL DIGITS
	SVC	KIO,$A 10		:
	SVC	OUT,TOM1		: ":"
TOTIM2	LR	R0,R2			:
	DH	R0,HOUR			:STRIP OUT HOURS
	LR	R2,R0			:
	LR	R0,R1			:
	LHI	R1,024A			:2 DIGITS, ZERO FILL
	SVC	KIO,$A 10		:
	SVC	OUT,TOM1		: ":"
	LR	R0,R2			:
	DH	R0,SIXTY		:STRIP OUT MINUTES, SECONDS
	LR	R2,R0			:
	LR	R0,R1			:
	LHI	R1,024A			:2 DECIMAL DIGITS, ZERO FILL
	SVC	KIO,$A 10		:
	SVC	OUT,TOM1		: ":"
	LR	R0,R2			:NOW FOR SECONDS
	SVC	KIO,$A 10		:
	JR	R3			:AND RETURN
					:
DAYS	WC	$A 24*60*60		:SECONDS IN A DAY
HOUR	HC	$A 60*60		:SECONDS IN A HOUR
SIXTY	HC	$A 60			:
TOM1	SC	/"BA/			: ":"
TOM2	SC	/     /
STOM1	SC	/"8D"8ACurrent system time is: /
					:
:	.......................................................................
:	UTILITY TO PRINT OUT ASCII ERROR, MAP TO BINARY CODE DEPENDING
:	ON MODE
:	.......................................................................
					:
OOUT	AH	R1,MODE,R8		:MODE IS 0 OR -3
	SVC	OUT,0,R1		:SEND MESSAGE
	JR	R9			:
					:
:	.......................................................................
:	PRINT ASCII MESSAGE UNLESS BINARY MODE
:	.......................................................................
					:
MOUT	LH	R0,MODE,R8		:
	JNR	R9			:RETURN IF BINARY MODE
	SVC	OUT,0,R1		:SEND MESSAGE
	JR	R9			:
					:
:	.......................................................................
:	OUTPUT 2 BLANKS
:	USES R0
:	.......................................................................
					:
DO2BL	LH	R0,MODE,R8		:CHECK MODE
	JNR	R9			:BINARY...IGNOR
	SVC	OUT,BLBL		:ASCII...OUTPUT "  "
	JR	R9			:AND RETURN
BLBL	SC	'  '			:
BLBL1	SC	'    '			"
					:
:	.......................................................................
:	OUTPUT CR|LF
:	USES R0
:	.......................................................................
					:
DOCRLF	LH	R0,MODE,R8		:CHECK MODE
	JNR	R9			:BINARY...IGNOR
	SVC	OUT,CRLF		:ASCII...OUTPUT "CR|LF"
	JR	R9			:AND RETURN
CRLF	SC	'"8D"8A'		:
					:
:	.......................................................................
:	UTILITY TO CONVERT R0 TO ASCII AND PRINT - ASSUME ROUT STARTS ON
:	ODD BOUNDARY & R1 IS THE NUMBER OF DIGITS TO BE PRINTED UP TO 8 AND
:	IS EVEN!!
:	USES R0, R1, R2, R3, R4
:	.......................................................................
					:
ACONV	LH	R2,MODE,R8		:CHECK MODE
	JNFS	AC0			:SKIP IF BINARY
					:
:	.......................................................................
:	PRINT (R1) BYTES OF (R0)
:	.......................................................................
					:
	EXBR	R1,R1			:SET UP FIELD WIDTH
	OHI	R1,50			:SET ZERO FILL HEX
	SVC	KIO,$A 10		:LET SYSTEM DO CONVERSION
	JR	R9			:THEN EXIT
					:
:	.......................................................................
:	OUTPUT (R1) BYTES OF (R0)
:	.......................................................................
					:
AC0	LIS	R2,0			:POINTER INTO OUTPUT BYTE STREAM
	SRLS	R1,1			:NUMBER OF DATA BYTES TO BE OUTPUT
	ST	R0,TEMP,R8		:DATA BYTE STREAM
	LIS	R4,4			:COMPUTE POSITION OF FIRST DATA BYTE
	SR	R4,R1			:FROM ADDR TEMP
AC1	LB	R3,TEMP,R8,R4		:GET NEXT DATA BYTE
	CLHI	R3,80			:IF 80 ESCAPE IT
	JEFS	AC2			:
	CLHI	R3,81			:IF 81 ESCAPE IT
	JNFS	AC3			:
AC2	LHI	R0,80			:ESCAPE BYTE VALUE
	STB	R0,ROUT+1,R8,R2		:STORE IN OUT-STREAM
	AIS	R2,1			:INCR PTR TO NEXT BYTE IN OUT STREAM
	XR	R3,R0			:MODIFY ESCAPED CHAR
AC3	STB	R3,ROUT+1,R8,R2		:STORE IN OUT STREAM
	AIS	R4,1			:PT TO NEXT DATA BYTE
	AIS	R2,1			:PT TO NEXT OUT BYTE POSITION
	SIS	R1,1			:DECR COUNT OF DATA BYTES
	JN	AC1			:TERMINATE WHEN ZERO
	STB	R2,ROUT,R8		:STORE COUNT FOR SVC
	SVC	OUT,ROUT,R8		:SEND OUT STREAM
	JR	R9			:RETURN
					:
:	....................................................................
:	UTILITY ROUTINE TO READ A NUMBER
:	USES R0-R4
:	....................................................................
					:
NUM	LH	R0,MODE,R8		:CHECK MODE
	JEFS	NUMA			:ASCII - DO DECODE TO HEX
	LIS	R4,3			:NUMBER OF BYTES TO BE READ
NUMB	JAL	R2,GETCHAR		:READ A BYTE
	NOP	0			:DON'T CARE ABOUT SKIP RETURNS
	SLLS	R3,8			:ACCUMULATE RESULT IN R3
	OR	R3,R0			:R3 NOT INITIALIZED BECAUSE 4 BYTES ARE ROTATED IN
	SIS	R4,1			:DECR BYTE COUNT
	JGEBS	NUMB			:DO FOR 4 BYTES
	LR	R0,R3			:NOW RETURN VALUE ACCUMULATED
	JR	R9			:AND RETURN
					:
NUMA	JAL	R2,GETNEXT		:GET NEXT CHAR
	NOP	0			:DON'T CARE ABOUT SKIP RETURN
	JAL	R2,ZDLIM		:CHECK FOR DELIMITER CHAR
	J	NUMA			:
	JAL	R2,ZDTST		:TEST IF CHAR IS DIGIT
	J	NUMERR			:NOT A DIGIT - GIVE ERROR MESSAGE
	LR	R4,R0			:PUT FIRST DIGIT INTO ACCUMULATOR
NUMA1	JAL	R1,INCHAR		:READ NEXT CHAR
	JAL	R2,ZDTST		:SKIP IF DIGIT
	J	NEXTT			:END OF NUMBER - EXIT
	SLLS	R4,4			:SHIFT ACC.
	AR	R4,R0			:ADD NEW DIGIT
	JBS	NUMA1			:GET NEXT DIGIT
NEXTT	JAL	R2,ZDLIM		:IS IT A DELIMITER
	LR	R0,R4			:
	JR	R9			:YES...SKIP RETURN
NUMERR	LA	R1,BADNUM,,		:SEND DIAGNOSTIC AND QUIT
	J	BITCH			:ERROR RETURN
					:
:	....................................................................
:	UTILITY ROUTINE TO READ A BYTE FROM THE USER
:	NORMAL RETURN IF NOT ASCII DIGIT
:	SKIP 4 RETURN IF COMPRESSION (84 OR 85)
:	ELSE SKIP 8
:	USES R0-R3
:	....................................................................
					:
NXTBYT	LH	R0,MODE,R8		:CHECK MODE
	JEFS	NXTBA			:ASCII - DECODE NEXT BYTE TO HEX
	AIS	R9,4			:SET UP FOR SKIP RETURN
	JAL	R2,GETCHAR		:GET BINARY BYTE
	J	4,R9			:DATA BYTE IS IN R0 - RETURN
	CLHI	R0,84			:CHECK FOR COMPRESSION CHARS
	JER	R9			:"0" FILL
	CLHI	R0,85			:
	JER	R9			:"1" FILL
	J	4,R9			:REAL BYTE IS IN R0 - RETURN
					:
NXTBA	JAL	R2,GETNEXT		:GET NEXT CHAR
	NOP	0			:DON'T CARE ABOUT SKIP RETURNS HERE
	JAL	R2,ZDLIM		:CHECK FOR DELIMITER
	J	NXTBA			:
	JAL	R2,ZDTST		:IS IT A DIGIT
	J	0,R9			:NO - ERROR RETURN
	LR	R3,R0			:ACCUMULATE IN R3
	JAL	R1,INCHAR		:GET ANOTHER CHARACTER
	JAL	R2,ZDLIM		:CHECK FOR DELIMITER
	LR	R0,R3			:IT WAS A DELIMITER...USE FIRST DIGIT ONLY
	JFS	NXTBA1			:AND SKIP
	JAL	R2,ZDTST		:IS IT A DIGIT?
	J	0,R9			:NO...ERROR RETURN
	SLLS	R3,4			:ACCUMULATE RESULT IN R3
	AR	R0,R3			:
NXTBA1	J	8,R9			:SKIP^8 RETURN
					:
:	.......................................................................
:	ZDLIM - CHECK FOR DELIMITER
:	LINK	R2
:	USES	R0,R1
:	SKIP RETURN UNLESS (R0) IS A DELIMITER CHARACTER
:	.......................................................................
					:
ZDLIM	OHI	R0,80			:ADD PARITY BIT
	STB	R0,INBUF,R8		:SAVE CHAR JUST READ
	LHI	R1,DLEN-1		:NUMBER OF DELIMITER CHARS
ZDLIM1	CLB	R0,ZDLST,R1		:COMPARE TO A DELIMITER
	JER	R2			:RETURN IF DELIMITER
	SIS	R1,1			:CHECK NEXT DELIMITER
	JGEBS	ZDLIM1			:LOOP IF ANY MORE DELIMITERS
	J	4,R2			:SKIP RETURN
					:
:	.......................................................................
:	LIST OF DELIMITER CHARS
:	.......................................................................
					:
ZDLST	AC	' '			:BLANK
	BC	8D			:CR
	BC	8A			:LF
	BC	80			:
	BC	89			:HT
	AC	','			:
DLEN	EQ	.-ZDLST			:NUMBER OF DELIMITER CHARS
					:
:	.......................................................................
:	DIGIT TEST
:	CHECK CHARACTER READ...SKIP RETURN IF DIGIT
:	THEN R0=BINARY VALUE OF HEX DIGIT
:	USES R1, LINK ON R2
:	.......................................................................
					:
ZDTST	JAL	R1,CUC			:CONVERT TO UPPER CASE, PARITY BIT ON
	LR	R1,R0			:COPY CHAR
	SHI	R1,0B0			:IS IT "0"?
	JLR	R2			:RETURN IF LESS THAN "0"
	SIS	R1,0B9-0B0		:IS IF "9"
	JLEFS	ZDTST1			:LESS THAN "9" THEN A GOOD DIGIT
	SIS	R1,0C1-0B9		:IS IT "A"?
	JLR	R2			:RETURN IF LESS THAN "A"
	SIS	R1,0C6-0C1		:IS IF "F"?
	JGR	R2			:RETURN IF GREATER THAN "F"
	SIS	R0,7			:0A - "A" (PARTIAL CONVERSION)
ZDTST1	SHI	R0,0B0			:"0"
	J	4,R2			:SKIP RETURN
					:
:	.......................................................................
:	CONVERT CHAR IN (R0) TO UPPER CASE
:	LINK ON R1
:	.......................................................................
					:
CUC	OHI	R0,80			:FORCE PARITY BIT
	CLHI	R0,0E1			:COMPARE WITH "a"
	JLR	R1			:EXIT IF IT CAN'T BE LOWERCASE
	CLHI	R0,0FA			:COMPARE WITH "z"
	JGR	R1			:NOT LOWER CASE...JUST RETURN
	SHI	R0,20			:LOWER CASE...CONVERT TO UPPER
	JR	R1			:AND RETURN
					:
:	.......................................................................
:	READ NEXT CHARACTER
:	USES R0-R2
:	.......................................................................
					:
CHARM	LH	R0,MODE,R8		:CHECK MODE
	JEFS	CNM1			:ASCII...JUST GET CHARACTER
	JAL	R2,GETCHAR		:BINARY...GET CHAR
	J	0,R9			:DON'T CARE ABOUT SKIP RETURNS
	JR	R9			:AND RETURN
CNM1	JAL	R2,GETNEXT		:READ A CHARACTER
	NOP	0			:DON'T CARE ABOUT SKIP RETURNS
	JAL	R2,ZDLIM		:FIND NEXT NON-DELIMITER CHAR
	J	CNM1			:ANOTHER DELIMITER
	JR	R9			:RETURN
					:
:	....................................................................
:	PEEK AT NEXT CHAR
:	USES R0-R2
:	....................................................................
					:
PEEK	LH	R0,MODE,R8		:CHECK MODE
	JEFS	PEEK1			:SKIP IF ASCII
	JAL	R2,GETCHAR		:BINARY - GET CHARACTER
	J	0,R9			:DON'T CARE ABOUT SKIP RETURNS
	JR	R9			:AND EXIT
PEEK1	LR	R10,R10			:R10 = 0 THEN MUST READ CHAR
	JEFS	PEEK2			:
	LB	R0,INBUF,R8		:RETURN THE CHARACTER
	JR	R9			:
PEEK2	JAL	R1,INCHAR		:GET CHAR
	JAL	R2,ZDLIM		:FIND NEXT NON-DELIMITER CHAR
	J	PEEK2			:
	STB	R0,INBUF,R8		:SAVE THE CHARACTER
	LIS	R10,2			:SET R10 TO CHAR "PEEKED" AT
	JR	R9			:RETURN
:	....................................................................
:	UTILITY ROUTINE TO GET NEXT CHAR
:	LINK ON R2
:	USES R0, R1
:	NORMAL RETURN IF CHARACTER IS ESCAPED...ELSE SKIP^4 RETURN
:	....................................................................
					:
GETNEXT	LH	R0,MODE,R8		:CHECK MODE
	JNFS	GETCHAR			:DEFAULT TO GETCHAR FOR BINARY
	LR	R10,R10			:IF WE'VE NOT "PEEKED", DEFAULT TO GETCHAR
	JEFS	GETCHAR			:
	LB	R0,INBUF,R8		:ELSE RETURN CHAR ALREADY "PEEKED" AT
	LIS	R10,0			:SET IT GONE
	J	4,R2			:AND RETURN VIA SKIP RETURN
					:
:	....................................................................
:	UTILITY ROUTINE TO READ NEXT CHAR
:	LINK ON R2
:	USES R0, R1
:	NORMAL RETURN IF CHARACTER IS ESCAPED...ELSE SKIP^4 RETURN
:	....................................................................
					:
GETCHAR	JAL	R1,INCHAR		:READ A CHAR
	LH	R1,MODE,R8		:CHECK MODE
	JE	4,R2			:ASCII - SKIP RETURN
	CLHI	R0,81			:IS IT FLUSH CHAR?
	JE	TTY			:YES...ABORT
	CLHI	R0,80			:IS IT ESCAPE CHAR?
	JN	4,R2			:BYTE IN R0 - SKIP RETURN
	JAL	R1,INCHAR		:READ ESCAPED BYTE
	XHI	R0,40			:DECODE ESCAPED BYTE
	JR	R2			:BYTE IN R0 - RETURN
					:
:	....................................................................
:	INPUT A CHARACTER
:	LINK	R1
:	RETURN CHAR IN R0...BUT EXITS TO TTY IF ESCAPE OCCURS
:	....................................................................
					:
INCHAR	SVC	IN,8			:GET THE CHAR
	J	INCH1			:IF NOT THERE, CHECK FOR ESCAPES
	LIS	R10,0			:SHOW NO CHARS IN BUFFER
	JR	R1			:THEN RETURN, CHAR IN R0
INCH1	LH	R0,FLAG,R8		:SEE IF USER HAS ABORTED
	JGEBS	INCHAR			:NO
   IF	FSYS				:
	C	R8,FUSER		:IS FILE SYSTEM BEING USED?
	JNFS	INCH2			:IF NOT, SKIP
	JAL	R3,FCLOS		:CLOSE CURRENT FILE
	TS	FUSER			:CANCEL CURRENT USER
	LIS	R0,0			:
	STH	R0,INUSE		:GIVE UP FILE SYSTEM
INCH2	EQ	.			:
   EI  (FSYS)				:
	J	TTY			:YES
					:

PIDLOW	EQ	31			:LOWEST PRODUCT ID
PIDTBL	HS	0			:PRODUCT ID TABLE
	AC	/ASATACOMXCOMPBH PBT MSATI2ISTII XXB BBXSELF /
	AC	/I2G1I2T1LDIIMRLNONTMPRB RAM SUP NVALISCSBOOT/
	AC	/KER SKERSDLCTNTTUTSHNTRHVMB EWS NEM TMCSOUT /
	AC	/CMTITRSWITI UTSTTOM LEM MUX UTILPBOMSOM PAOM/
	AC	/CREDTLXGXOM NTRTXPC SNATSNAHTNTHCMTUACCTELSV/
	AC	/ERLGNAD NTCNSYSMUN2 ISRMONTROBJNCPASSTARTMDM/
	AC	/TMRENMDMNMRENCDMNCRENVDMMSRVSHMNXPI CPPPATC /
	AC	/ODNUOPASACUSXCOMXCOMIHSADMACMLI ISRSMXPICICL/
	AC	/HICLTICLI2G2DMEMLHOSMDT MDH IPI EBUSPTI CMH /
	AC	/MBAS/
	HC	0,0,0,0,0,0,0,0
	AC	/EXPE/
PIDENT	EQ	(.-PIDTBL)/4

DPATCH	HS	20			:PATCH AREA
					:
        IF      MACTRC                  :IF MAC TRACE SPECIFIED
					:
:	.......................................................................
:	SET UP MAC TRACE PARAMETERS
:
:	Note: USER MUST HAVE ADEQUATE LICENCE
:
:	.......................................................................
					:
QPTRAC  EQ      .			:
					:
        JAL     R9,CHKMAC               :MAKE SURE WE HAVE CORRECT MAC
                                        :AND PATCH LICENSE
					:
:	.......................................................................
:	GET BEGINNING TRACE ADDRESS
:	.......................................................................
					:
	SVC	OUT,TRCEM1		:PROMPT FOR ADDRESS
	JAL	R9,NUM			:
	CI	R0,0FFFFE		:MAX MEMORY 1 MBYTE
	JG	TTYERR			:
        LIS     R4,0                    :INSURE TRACE IS OFF BEFORE
        STH     R4,TRONOF,,             :CHANGING PARAMETERS
        ST      R0,TRADR1,,             :SAVE BEGINNING TRACE ADDRESS
					:
:	.......................................................................
:	GET ENDING TRACE ADDRESS
:	.......................................................................
					:
	SVC	OUT,TRCEM2		:PROMPT FOR ADDRESS
	JAL	R9,NUM			:
	CI	R0,0FFFFE		:MAX MEMORY 1 MBYTE
	JG	TTYERR			:
        ST      R0,TRADR2,,             :SAVE ENDING TRACE ADDRESS
					:
:	.......................................................................
:	GET TRACE COMMAND HALFWORD
:	.......................................................................
					:
	SVC	OUT,TRCEM3		:PROMPT FOR TRACE COMMAND BITS
	JAL	R9,NUM			:
	LR	R4,R0			:
        NHI     R4,801F                 :CHECK FOR UNUSED BITS
	JN	TTYERR			:
        OHI     R0,8000                 :FORCE ENABLE BIT ON
        STH     R0,TRACMD,,             :SAVE TRACE COMMAND
					:
:	.......................................................................
:	GET TRACE TERMINATION TYPE
:	.......................................................................
					:
	SVC	OUT,TRCEM4		:PROMPT
	JAL	R9,NUM			:
	CHI	R0,2			:CHECK RANGE
	JG	TTYERR			:
	SLLS	R0,2			:ESTABLISH INDEX
	STH	R0,TERMCD,,		:SAVE TERMINATION CONTROL CODE
					:
:	.......................................................................
:	GET DATA COMPARE CONTROL CODE
:	.......................................................................
					:
	SVC	OUT,TRCEM5		:PROMPT FOR DATA COMPARE CODE
	JAL	R9,NUM			:
	CHI	R0,2			:CHECK RANGE
	JG	TTYERR			:
        LR      R4,R0			:
        JE      PTRAC2                  :SAVE IT IF ZERO
        LIS     R4,0			:
PTRAC1  AIS     R4,0C			:
        SIS     R0,1			:
        JN      PTRAC1			:
PTRAC2	STH	R4,DATACD,,		:SAVE DATA COMPARE CODE
        LR      R4,R4			:
        JE      TTY                     :IF ZERO, SKIP DATA PROMPT
					:
:	.......................................................................
:	GET DATA COMPARE HALFWORD VALUE
:	.......................................................................
					:
	SVC	OUT,TRCEM6		:PROMPT FOR DATA COMPARE CODE
	JAL	R9,NUM			:
        STH     R0,PATERN,,             :SAVE DATA PATTERN HALFWORD
        J       TTY                     :RETURN
					:
:	.......................................................................
:	COMMAND TO START/STOP MAC TRACE
:	Note: USER MUST HAVE ADEQUATE LICENCE
:	.......................................................................
					:
QSTRAC  JAL     R9,CHKMAC               :MAKE SURE WE HAVE CORRECT MAC
                                        :AND PATCH LICENSE
	SVC	OUT,STRCM1		:PROMPT FOR YES OR NO
	JAL	R9,CHARM                :GET CHARACTER
        NHI     R0,5F                   :STRIP BIT 0,2
        CHI     R0,59                   :IS IT A 'Y'?
        JE      STRTRC                  :GO START TRACE
        CHI     R0,4E                   :IS IT AN 'N'?
        JE      TRSTOP                  :GO STOP TRACE
        J       TTYERR                  :ELSE ERROR
					:
STRTRC  LIS     R0,0                    :CLEAR TRACE DATA TABLES
        LHI     R4,TRACED		:
STRTR1  STH     R0,TRCSET,R4,,		:
        SIS     R4,2			:
        JGEBS   STRTR1			:
        L       R4,TRADR1,,             :SET UP START TRACE ADDRESS
        ST      R4,354,,		:
        L       R4,TRADR2,,             :SET UP END TRACE ADDRESS
        ST      R4,358,,		:
        LHL     R4,TRACMD,,		:
        STH     R4,350,,                :STORE IN 350 INITIALIZES TRACE
        LCS     R4,1			:
        STH     R4,TRONOF,,             :FLAG TRACE "RUNNING"
        J       TTY			:
TRSTOP  LIS     R4,0			:
        STH     R4,TRONOF,,             :FLAG TRACE "STOPPED"
        J       TTY                     :RETURN
					:
:	.......................................................................
:	DISPLAY MAC TRACE DATA
:	.......................................................................
					:
QDTRAC  EQ      .			:
        JAL     R9,CHKMAC               :MAKE SURE WE HAVE CORRECT MAC
                                        :AND PATCH LICENSE
        SVC     OUT,DTRC01              :OUTPUT TRACE STATUS
        LH      R4,TRONOF,,             :RUN/STOP FLAG
        JE      DTRCR1			:
        SVC     OUT,DTRC02              :OUTPUT RUNNING
        JFS     DTRCR2			:
DTRCR1  SVC     OUT,DTRC03              :OUTPUT STOPPED
					:
DTRCR2  SVC     OUT,DTRC4A              :OUTPUT COMMAND
        LHL     R0,TRACMD,,		:
        NHI     R0,7FFF                 :STRIP OF ENABLE BIT
        LHI     R1,450                  :4 HEX DIGITS
        SVC     KIO,$A 10		:
        JAL     R9,DO2BL                :FOLLOW WITH 2 BLANKS
        SVC     OUT,DTRC4B              :OUTPUT BEGIN ADDRESS
        L       R0,TRADR1,,		:
        LHI     R1,650                  :6 HEX DIGITS
        SVC     KIO,$A 10		:
        JAL     R9,DO2BL                :FOLLOW WITH 2 BLANKS
        SVC     OUT,DTRC4C              :OUTPUT ENDING ADRESS
        L       R0,TRADR2,,		:
        LHI     R1,650                  :6 HEX DIGITS
        SVC     KIO,$A 10		:
        JAL     R9,DO2BL		:
        JAL     R9,DOCRLF               :DO CR/LF
					:
        SVC     OUT,DTRC09              :OUTPUT DATA COMPARE INFO
        LHL     R4,DATACD,,             :FETCH COMPARE CONTROL
        JEFS    DTRAC1                  :
        SIS     R4,0C			:
        JEFS    DTRAC2			:
        SVC     OUT,DTRC11              :OUTPUT 'NOT EQUAL'
        JFS     DTRAC3                  :ASSUME NOT EQUAL
DTRAC2  SVC     OUT,DTRC10              :OUTPUT 'EQUAL'
        JFS     DTRAC3			:
DTRAC1  SVC     OUT,DTRC12              :OUTPUT 'NONE'
					:
DTRAC3  SVC     OUT,DTRC16              :OUTPUT 'VALUE'
        LHL     R0,PATERN,,		:
        LHI     R1,450                  :4 HEX DIGITS
        SVC     KIO,$A 10		:
        JAL     R9,DO2BL                :OUTPUT 2 BLANKS
					:
        LHL     R4,TERMCD,,             :FETCH TERMINATION CODE
        JEFS    DTRACA			:
        SIS     R4,4			:
        JEFS    DTRACB			:
        SVC     OUT,DTRC08              :OUTPUT 'BOOT'
        J       DTRACC			:
DTRACA  SVC     OUT,DTRC06              :OUTPUT 'STOP'
        J       DTRACC			:
DTRACB  SVC     OUT,DTRC07              :OUTPUT 'RESTART'
        LHL     R0,ILLTRC,,             :CHECK FOR ILLEGAL LOOP
        JE      DTRACC                  :SKIP IF NON OCCURRED
        SVC     OUT,DTRC71              :SEND 'INVALID'
					:
DTRACC  JAL     R9,DOCRLF		:
        JAL     R9,DOCRLF		:
        SVC     OUT,DTRC13		:
        SVC     OUT,DTRR40              :OUTPUT MAC REG 340
        L       R0,MAC340,,		:
        LHI     R1,850                  :OUTPUT 8 HEX DIGITS
        SVC     KIO,$A 10		:
        JAL     R9,DO2BL                :FOLLOW WITH 2 BLANKS
        SVC     OUT,DTRR44              :OUTPUT MAC REG 344
        L       R0,MAC344,,		:
        LHI     R1,850          	:
        SVC     KIO,$A 10		:
        JAL     R9,DO2BL		:
        SVC     OUT,DTRR48              :OUTPUT MAC REG 348
        L       R0,MAC348,,		:
        LHI     R1,850			:
        SVC     KIO,$A 10		:
        JAL     R9,DO2BL		:
        SVC     OUT,DTRR4C              :OUTPUT MAC REG 34C
        L       R0,MAC34C,,		:
        LHI     R1,850			:
        SVC     KIO,$A 10		:
        JAL     R9,DOCRLF		:
        JAL     R9,DOCRLF		:
					:
        SVC     OUT,DTRC18              :OUTPUT TRAPPED ADDRESS
        L       R0,TRPLOC,,             :FETCH IT
        LHI     R1,650                  :6 DIGITS
        SVC     KIO,$A10		:
        JAL     R9,DO2BL		:
					:
        SVC     OUT,DTRC19              :OUTPUT TRAPPED DATA
        LHL     R0,TRPDTA,,		:
        LHI     R1,450                  :4 DIGITS
        SVC     KIO,$A10		:
        JAL     R9,DO2BL		:
					:
        SVC     OUT,DTRC20              :OUTPUT TRAP COUNTER
        L       R0,COUNT,,		:
        LHI     R1,850                  :8 DIGITS
        SVC     KIO,$A10		:
        JAL     R9,DOCRLF		:
        JAL     R9,DOCRLF		:
					:
        SVC     OUT,DTRC15              :OUTPUT "REG SET n"
        LHL     R0,TRCSET,,             :FETCH REGISTER SET INTERRUPTED
        SRLS    R0,4			:
        LHI     R1,150                  :OUTPUT 1 DIGIT
        SVC     KIO,$A 10		:
        JAL     R9,DOCRLF		:
        LA      R15,TRACE1,,            :POINT TO TRACE REG SET 'n'
        JAL     R5,TRCREG               :OUTPUT TRACE REGISTERS
        SVC     OUT,DTRC17              :OUTPUT REGISTER SET '0'
        LA      R15,TRACE2,,            :POINT TO INTERRUPTING REGISTER SET
        JAL     R5,TRCREG		:
					:
        SVC     OUT,DTRC21              :OUTPUT TRACE BUFFER ADDRESSES
        LIS     R3,0			:
        LI      R4,-80			:
QBTR1   L       R0,TRPLOC+80,R4,        :GET FIRST ENTRY
        LHI     R1,650                  :OUTPUT 6 HEX DIGITS
        SVC     KIO,$A10		:
        JAL     R9,DO2BL		:
        AIS     R3,1			:
        THI     R3,7			:
        JNFS    QBTR2			:
        JAL     R9,DOCRLF		:
QBTR2   AIS     R4,4			:
        JL      QBTR1                   :SCAN NEXT LOCATION
        J       TTY			:
					:
TRCREG  LIS     R3,0			:
        LIS     R4,0F                   :OUTPUT 16 REGISTERS
TRLOOP  L       R0,0,R15                :GET REGISTER
        LHI     R1,850                  :8 HEX DIGITS
        SVC     KIO,$A10		:
        JAL     R9,DO2BL                :FOLLOW REG WITH 2 BLANKS
        AIS     R15,4                   :INCREMENT TO NEXT REGISTER
        AIS     R3,1                    :PUT 4 REGISTERS PER LINE
        THI     R3,3                    :FOLD LINE?
        JNBS    TRLOOP                  :FINISH LINE
        JAL     R9,DOCRLF               :TERMINATE WITH CR/LF
        SIS     R4,4                    :DECREMENT REGISTER COUNT
        JG      TRLOOP			:
        JR      R5                      :RETURN
					:
CHKMAC  LHL     R4,ULICEN,R8            :CHECK ON LICENSE
        THI     R4,L.SYP                :MUST HAVE SYSTEM PATCH
        JE      TTYERR			:
        L       R4,MACSTAT              :FETCH MAC STATUS REGISTER
        THI     R4,20                   :TEST FOR BIT 10 ON
        JER     R9                      :IF NOT ON, RETURN
        SVC     OUT,STRCM2              :TELL USER THIS WON'T WORK
        J       TTY                     :EXIT
					:
DTRC01  SC      /"8D"8ATRACE: /
DTRC02  SC      /RUNNING    /
DTRC03  SC      /STOPPED    /
DTRC4A  SC      /COMMAND:  /
DTRC4B  SC      /BEG ADDR:  /
DTRC4C  SC      /END ADDR:  /
DTRC06  SC      /STOP TRACE AFTER SYNC /
DTRC07  SC      /RESTART TRACE AFTER SYNC /
DTRC71  SC      /(ILLEGAL TERM)/
DTRC08  SC      /GO TO BOOT AFTER SYNC /
DTRC09  SC      /DATA COMPARE: /
DTRC10  SC      /IF EQUAL  /
DTRC11  SC      /IF NOT EQUAL  /
DTRC12  SC      /NONE  /
DTRC13  SC      /MAC REGISTERS: /
DTRR40  SC      /340 /
DTRR44  SC      /344 /
DTRR48  SC      /348 /
DTRR4C  SC      /34C /
DTRC15  SC      /REG SET INTERRUPTED: /
DTRC16  SC      /VALUE: /
DTRC17  SC      /REGISTER SET 0:"8D"8A/
DTRC18  SC      /TRAPPED ADDR: /
DTRC19  SC      /TRAPPED DATA: /
DTRC20  SC      /TRAP COUNT: /
DTRC21  SC      /TRACE BUFFER ADDRESSES:"8D"8A/
TRCEM1	SC	/ENTER BEG PHYS ADDR: /
TRCEM2	SC	/ENTER END PHYS ADDR: /
TRCEM3	SC	/ENTER TRACE COMMAND HALFWORD: /
TRCEM4	SC	/ENTER TRACE TERMINATION CODE: /
TRCEM5	SC	/ENTER TRACE COMPARE CODE: /
TRCEM6	SC	/ENTER COMPARE HALFWORD VALUE: /
STRCM1	SC	/START TRACE? Y=START, N=STOP: /
STRCM2  SC      /MAC TRACE VALID FOR STD MAC-II ONLY/
        EI      (MACTRC)

   IF	MULTI


	HC	0			:
KIOM00	SC	/"8D"8ARING INTERFACE:/
KIOM01	SC	/"8D"8ALAST INTERRUPT STATUS:/
KIOM02	SC	/"8D"8AKIO PORT STATUS:/
KIOM03	SC	/"8D"8AUSER RING STATUS:/
KIOM04	SC	/GU:/
KIOM05	SC	/DEV ADDR:/
KIOM06	SC	/STATUS:/
KIOM07	SC	/UP/
KIOM08	SC	/DOWN/
KIOM09	SC	/CONTROL/
KIOM10	SC	/INUSED/
KIOM11	SC	/UNUSED/
KIOM12	SC	/-/
KIOM13	SC	/"8D"8A/
KIOM14	SC	/"8D"8A/
KIOM15	SC	/"20/
KIOM16	SC	/"20"20/
KIOM17	SC	/"20"20"20/
KIOM18	SC	/"20"20"20"20/
KIOM19	SC	/"20"20"20"20"20/
KIOM20	SC	/"20"20"20"20"20"20/
KIOM40	SC	/"8D"8A                      INPUT       OUTPUT       INPUT    OUTPUT/
KIOM41	SC	/"8D"8APORT  RING  STATUS  FILL"2FEMPTY  FILL"2FEMPTY      CPS      CPS/
KIOM50	SC	/"8D"8A                           INPUT        OUTPUT       INPUT     OUTPUT/
KIOM51	SC	/"8D"8ASLOT  LU   RING   STATUS   FILL"2FEMPTY   FILL"2FEMPTY    CPS       CPS/
KIOM60	SC	/"8D"8ADEVICE  DEVICE  INPUT RING  OUTPUT RING  INTERRUPT  INTERRUPT  TIME/
KIOM61	SC	/"8D"8A ADDR   STATUS  FILL"2FEMPTY  FILL"2FEMPTY      PSW        PC     STAMPS/
KIOTMP	HS	2			:
					:
:	.....................................................................
:
:	DDT command "?SRING" - SIO Ring Status Command
:	    Syntax:  ?SRING nn where "nn" equals to the global logical unit
:	The following status will be displayed:
:	        (1) SIO Ring Interface
:		(2) Last Interrupt Status
:		(3) KIO  Port Status
:		(4) User Ring Status
:
:	.....................................................................
					:
	HC	0			:
QSRING	SVC	OUT,KIOM00		:KIO ring interface
	SVC	OUT,KIOM01		:Last Interrupt Status
	SVC	OUT,KIOM04		:Global Logical Unit
	SVC	OUT,KIOM05		:SIO motherboard device address
	SVC	OUT,KIOM06		:Status
	SVC	OUT,KIOM02		:KIO port status
	SVC	OUT,KIOM40		:
	SVC	OUT,KIOM41		:
	SVC	OUT,KIOM03		:User Ring status
	SVC	OUT,KIOM50		:
	SVC	OUT,KIOM51		:
	J	TTY			:

:	.....................................................................
:
:	DDT command "?SRHIST" will display the SIO ring copy motherboard
:	interrupt history for each motherboard configured in the Tymfile
:
:	.....................................................................
					:
QSRHIS	SVC	OUT,KIOM60		:Start to output message banner
	SVC	OUT,KIOM61		:
	SVC	OUT,KIOM14		:...<cr><lf>
	LHI	R5,10			:Set counter up to 16 buffer dumps
	LHL	R6,SIOPTR		:Initialize SIO history buf. pointer
SRHIS0	SHI	R6,10			:Track history information  backward
	NHI	R6,0FF			:Prevent buffer wrap at 100x
	LHL	R0,SIOHIS,R6		:Get SIO device address
	LHI	R1,230			:Output device address in HEX
	SVC	KIO,$A 10		:KIO output
	SVC	OUT,KIOM15		:
	LHL	R0,SIOHIS+2,R6		:Get SIO interrupt status
	LHI	R1,530			:Output SIO interrupt status
	SVC	KIO,$A 10		:KIO output
	LHL	R0,SIOHIS+4,R6		:Get SIO ring Fill/Empty coursor
	L	R0,SIOHIS+8,R6		:Get SIO interrupt PSW
	LHI	R1,830			:Output SIO interrupt PSW
	SVC	KIO,$A 10		:
	LHL	R0,SIOHIS+0C,R6		:Get SIO interrupt PC
	LHI	R1,830			:
	SVC	KIO,$A 10		:
	SVC	OUT,KIOM14		:Advance <cr><lf> ...
	SIS	R5,1			:Decrement counter
	JG	SRHIS0			:To dump another history buffer
	J	TTY			:Done! return ...
					:
:	.....................................................................
:	
:	DDT command "?SINIT" - SIO Ring Initialization command which will
:		    (1) Reset the SIO Ring Card
:		    (2) Initialize kernel Ring area, newlog, data ready array
:		    (3) User Ring Area
:	
:	.....................................................................
					:
:	DDT command ?SINIT		:
   IF	MLUSW				:
QSRINI	LIS	R0,MLUNUM		:Start from the highest motherboard LU
SRINIT	SVC	SYS,$A59		:Initialize SIO ring(s)...
	LR	R1,R1			:
	JN	TTY			:Return on bad motherboard LU
	SIS	R0,1			:Get the next LU number
	JGEBS	SRINIT			:Go to initialize next LU
	J	TTY			:Done! ... return
   EI  (MLUSW)				:
					:
   EI  (MULTI)				:
					:
					:
   IF	SPAM				:7/87
					:
:	.......................................................................
:		<<< SYSTEM PERFORMANCE ANALYSIS MONITOR >>>
:	.......................................................................
					:
        HS      0			:
QSPAM   STM     R0,SPMSAV               :SAVE RETURN REGISTERS
        LH      R0,SLOT,R8              :SLOT 'FF' ONLY SLOT VALID
        JL      SPMHDR                  :
        SVC     OUT,SPAM12              :RETURN ERROR MSG TO USER - WRONG SLOT
        LM      R0,SPMSAV		:
        J       TTY,,			:
					:
:	.......................................................................
:       BUILD SPAM HEADER LINES
:	.......................................................................
					:  
SPMHDR  EQ      .			:GET NODE AND HOST NUMBERS
   IF	MXP				:
        LHI     R2,MXPNM                :GET MXP NUMBER
   ELSE					:
      	LHI	R2,HST0			:GET HOST NO.
   EI  (MXP)				:
	LIS	R4,$A 10		:OUTPUT IN DECIMAL
   IF      MXP				:
        LIS     R6,2                    :CHARACTER COUNT
   ELSE					:
	LIS	R6,5			:CHARACTER COUNT
   EI  (MXP)				:
	LA	R7,SPMHD1+$A39		:HOST(OR)MXP# LINE ADRESS
	LIS	R8,0			:NO DEC. PT.
	JAL	R9,CBD			:CONVERT TO ASCII 
	LHI	R2,MACHNM		:GET NODE NO.
	LIS	R4,8			:OUTPUT IN OCTAL
	LIS	R6,5			:CHARACTER COUNT
	LA	R7,SPMHD1+$A27		:NODE NUMBER LINE ADDRESS
	JAL	R9,CBD			:CONVERT TO OCTAL
					:
:	.......................................................................
:	CHECK IF BUFFER XFER IMMINENT
:	.......................................................................
					:
        L       R2,ADVCLK,,             :GET ROLLOVER TIME
        L       R3,SLOWC                :SUBTRACT CURRENT TIME
        SR      R2,R3                   :GET TIME DIFFERENCE
        CLHI    R2,4                    :WITHIN 4 SECONDS OF ROLLOVER?
        JG      ISITIM			:
        SVC     DISMIS,5                :WAIT 5 SECONDS FOR BUFFER TRANSFER
  					:
:	.......................................................................
:	GET ISIS TIME
:	.......................................................................
					:
ISITIM  EQ      .			:
	L	R11,SLOSAV,,		:GET TIME OF BUFFER XFER FOR OUTPUT
	LIS	R10,0			:
	D	R10,DAYS1		:STRIP OUT DAYS
	LR	R12,R10			:
	LR	R10,R11			:
	LR	R2,R10			:GET DAYS IN R2
	LIS	R6,3			:CHARACTER COUNT
	LIS	R4,$A 10		:DECIMAL OUTPUT
	LIS	R8,0			:NO DEC. PT. REQUIRED
	LA	R7,SPMHD1+$A51		:SAMPLE TIME JDAY LINE ADDRRESS
	JAL	R9,CBD			:CONVERT TO DEC.
	LR	R10,R12			:STRIP OUT HOURS
	DH	R10,HOUR1		:
	LR	R12,R10			:
	LR	R10,R11			:
	LR	R2,R10			:GET HOURS IN R2
	LIS	R6,2			:CHARACTER COUNT
	LA	R7,SPMHD1+$A55		:SAMPLE TIME HOUR LINE ADDRESS
	JAL	R9,CBD			:CONVERT TO DEC.
	LR	R10,R12			:
	DH	R10,SIXTY1		:STRIP OUT MINUTES, SECONDS
	LR	R12,R10			:
	LR	R10,R11			:
	LR	R2,R10			:GET MINS. IN R2
	LIS	R6,2			:CHARACTER COUNT
	LA	R7,SPMHD1+$A58		:SAMPLE TIME MINUTE LINE ADDRESS
	JAL	R9,CBD			:CONVERT TO DEC.
	LR	R2,R12			:GET SECONDS IN R2
	LIS	R6,2			:CHARACTER COUNT
	LA	R7,SPMHD1+$A61		:SAMPLE TIME SECONDS LINE ADDRESS
	JAL	R9,CBD			:CONVERT TO DECIMAL
  					:
:	.......................................................................
:	OUTPUT HEADERS
:	.......................................................................
					:
	SVC	OUT,SPMHD0		:OUTPUT SPAM HEADER
	SVC	OUT,SPMHD1		:OUTPUT NODE, HOST AND ISIS TIME
	SVC	OUT,SPMHD2		:OUTPUT DATA HEADERS
	SVC	OUT,SPMHD3		:
  					:
SLSTRT  EQ      .			:
					:
:	.......................................................................
:       BUILD SLOT LINE DATA AND ACCUMULATE ACTIVITY LINE DATA
:  
:       INITIALIZE REGISTERS FOR SLOT LINES
:	.......................................................................
					:  
	LIS	R0,0			:R10 = 0
	LHI	R3,EXEND		:END OF COMMON JOB TABLE
SPMCLR	ST 	R0,DDTTIM,R3		:CLEAR JOB TIME & EXEC TABLES
	SIS	R3,4			:DECREMENT R3
	JGEBS	SPMCLR			:LOOP
					:
        LCS     R10,1                   :BEGIN WITH SLOT '-1' (ISIS)
                                        :MAINTAINS TRUE SLOT NUMBER
					:
        LIS     R11,0                   :SLOT TABLE INDEX, 0 = SLOT FF
                                        :INDEX R11 INCREMENTED BY 20 HEX
                                        :FOR "TIMTBL" AND "JOBCNT" TABLES
SPAMID  EQ      .			:
	JAL	R1,GTSPID		:GET AND SET UP SLOT ID'S
					:
:	.......................................................................
:	GET SLOT Q.FG VALUES FROM TABLE
:	.......................................................................
					:
	LIS	R12,0C			:SET UP WORK INDEX FOR JOBS (0C=BG)
                                        :INDEX R12 INCREMENTED BY WORDS FROM
                                        :0 THRU 1C FOR JOBS WITHIN SLOTS
	LIS	R13,08			:WORD INDEX FOR ACCUMULATOR (08=BG)
					: 
FGQUAN  EQ      .			:
        LR      R8,R10                  :COPY SLOT NUMBER
        AIS     R8,1                    :OFFSET INDEX BY 1 SO 'FF' = '00'
        LB      R2,SPMQFG,R8            :GET Q.FG FR THIS SLOT
	LIS	R8,0			:NO DEC. PT.
	LIS	R4,$A 10		:SET RADIX DECIMAL
	LIS	R6,2			:CHARACTER COUNT
	LA	R7,SPMDET+9		:FOREGROUND QUANTUM LINE ADDRESS
	JAL	R9,CBD			:CONVERT TO ASCII 
  					:
:	.......................................................................	
:       "TIMTBL" AND "JOBCNT" TABLES CONSIST OF 8 WORDS PER
:       SLOT AS FOLLOWS:
:
:       DDT    / KIO    / UNUSED / BGRND
:       DISP   / UNUSED / UNUSED / FGRND
:	.......................................................................
					: 
:	.......................................................................
:		GET BACKGROUND TIME AND PLACE IN OUTPUT LINE
:	.......................................................................
					: 
        L       R2,TIMTBL,R11,R12       :GET TICKS FOR THIS SLOT/BGRND
        AM      R2,DDTTIM,R13           :ADD TO BACKGROUND TIME ACCUMULATOR
        AM      R2,TOTLTI               :ADD TICKS ALL SLOT TIME ACCUM
        AM      R2,SLOTOT               :ADD TO TOTAL SLOT TIME ACCUMULATOR
        LIS     R6,6                    :CHARACTER COUNT 6
	LA	R7,SPMDET+$A32		:BACKGROUND TIMING LINE ADDRESS
	JAL	R5,CVTICK		:CONVERT TO DEC AND OUTPUT TO LINE
					:
:	.......................................................................
:               GET BACKGROUND EXEC COUNT AND PLACE IN OUTPUT LINE
:	.......................................................................
					:
	L	R2,JOBCNT,R11,R12	:GET EXEC COUNT FOR THIS SLOT/BGRND
        AM      R2,DDTEXE,R13           :ADD TO BACKGROUND EXEC ACCUMULATOR
        AM      R2,TOTJOB               :ADD TO TOTAL EXECUTION ACCUMULATOR
	LA	R7,SPMDET+$A25		:BACKGROUND EXEC COUNT LINE ADDRESS
        LIS     R6,6                    :CHARA COUNT
        LIS     R8,0                    :NO DECIMAL POINT
        JAL     R9,CBD                  :CONVERT TO ASCII AND OUTPUT TO LINE
					:
:	.......................................................................
:               GET DISPATCHER TIME AND PLACE IN OUTPUT LINE
:	.......................................................................
					:
        AIS     R12,4                   :BUMP TABLE INDEX = '10'
        AIS     R13,4                   :BUMP ACCUM INDEX
					:
        LR      R10,R10                 :TEST FOR ISIS SLOT 'FF'
        JGE     SPMDS1                  :PROCESS DISPATCHER LINE IF NOT 'FF'
        LI      R2,0A0A0A0A0            :SET SPACES IN DISPATCHER ENTRIES
        STB     R2,SPMDET+$A39		:
        ST      R2,SPMDET+$A40		:
        ST      R2,SPMDET+$A44		:
        ST      R2,SPMDET+$A48		:
        J       SPMDS2                  :SKIP DISPATCHER COUNTS
					:
SPMDS1  L       R2,TIMTBL,R11,R12       :GET TICKS FOR THIS SLOT/JOB
        AM      R2,DDTTIM,R13           :ADD TO DISPATCHER TIME ACCUMULATOR
        AM      R2,TOTLTI               :ADD TICKS ALL SLOT TIME ACCUM
        AM      R2,SLOTOT               :ADD TO TOTAL SLOT TIME ACCUMULATOR
        LIS     R6,6                    :CHARACTER COUNT 6
	LA	R7,SPMDET+$A46		:DISPATCHER TIMING LINE ADDRESS
	JAL	R5,CVTICK		:CONVERT TO DEC AND OUTPUT TO LINE
					:
:	.......................................................................
:               GET DISPATCHER EXEC COUNT AND PLACE IN OUTPUT LINE
:	.......................................................................
					:
	L	R2,JOBCNT,R11,R12	:GET EXEC COUNT FOR THIS SLOT/BGRND
        AM      R2,DDTEXE,R13           :ADD TO DISPATCHER EXEC ACCUMULATOR
        AM      R2,TOTJOB               :ADD TO TOTAL EXECUTION ACCUMULATOR
	LA	R7,SPMDET+$A39		:DISPATCHER EXEC COUNT LINE ADDRESS
        LIS     R6,6                    :CHARA COUNT
        LIS     R8,0                    :NO DECIMAL POINT
        JAL     R9,CBD                  :CONVERT TO ASCII AND OUTPUT TO LINE
					:
:	.......................................................................
:               GET FOREGROUND TIME AND PLACE IN OUTPUT LINE
:	.......................................................................
					:
SPMDS2  AIS     R12,0C                  :BUMP TABLE INDEX = '1C'
        AIS     R13,4                   :BUMP ACCUM INDEX
					:
        L       R2,TIMTBL,R11,R12       :GET TICKS FOR THIS SLOT/JOB
        AM      R2,DDTTIM,R13           :ADD TO FOREGROUND TIME ACCUMULATOOR
        AM      R2,TOTLTI               :ADD TICKS ALL SLOT TIME ACCUM
        AM      R2,SLOTOT               :ADD TO TOTAL SLOT TIME ACCUMULATOR
        LIS     R6,6                    :CHARACTER COUNT 6
	LA	R7,SPMDET+$A18		:FOREGROUND TIMING LINE ADDRESS
	JAL	R5,CVTICK		:CONVERT TO DEC AND OUTPUT TO LINE
					:
:	.......................................................................
:               GET FOREGROUND EXEC COUNT AND PLACE IN OUTPUT LINE
:	.......................................................................
					:
	L	R2,JOBCNT,R11,R12	:GET EXEC COUNT FOR THIS SLOT/BGRND
        AM      R2,DDTEXE,R13           :ADD TO FOREGROUND TIME ACCUMULATOOR
        AM      R2,TOTJOB               :ADD TO TOTAL EXECUTION ACCUMULATOR
	LA	R7,SPMDET+$A12		:FOREGROUND EXEC COUNT LINE ADDRESS
        LIS     R6,5                    :CHARA COUNT
        LIS     R8,0                    :NO DECIMAL POINT
        JAL     R9,CBD                  :CONVERT TO ASCII AND OUTPUT TO LINE
  					:
:	.......................................................................
:		GET AVERAGE DISPATCHER I/O CPS FOR SLOTS
:	.......................................................................
  					:
        LR      R14,R10                 :COPY CURRENT SLOT NUMBER
        AIS     R14,1                   :ADJUST FOR SLOT 'FF'
        SLLS    R14,3                   :8 BYTE INDEX
	L	R2,IOCSAV,R14,,		:GET DISPATCH INPUT CHARA COUNT
	LIS	R1,0			:ZERO R1
	LHI	R7,$A 60		:SIXTY SECOND DIVISOR
	DR	R1,R7			:DIVIDE TO GET AVERAGE
	LIS	R8,0			:NO DEC. PT. REQUIRED
	LA	R7,SPMDET+$A65		:DISPATCH INP CHAR COUNT LINE ADDRESS
	LIS	R6,6			:CHARACTER COUNT 
	JAL	R9,CBD			:CONVERT TO ASCII 
					:
	L	R2,IOCSAV+4,R14,,	:GET DISPATCH OUTPUT CHARA COUNT
	LIS	R1,0			:ZERO R1
	LHI	R7,$A 60 		:SIXTY SECOND DIVISOR
	DR	R1,R7			:DIVIDE TO GET AVERAGE
	LIS	R8,0			:NO DEC. PT. REQUIRED
	LIS	R6,6			:CHARACTER COUNT
	LA	R7,SPMDET+$A72		:DISPATCH OUTPUT CHAR CNT LINE ADDRESS
	LIS	R8,0			:NO DEC. PT. REQUIRED
	JAL	R9,CBD			:CONVERT TO ASCII 
  					:
:	.......................................................................
:		GET TOTAL TIME FOR THIS SLOT (FG+BG+DISP.TIME)
:		...AND GET PERCENTAGE OF ONE MINUTE'S TIME USED
:	.......................................................................
					:
	L	R2,SLOTOT		:GET TOTAL SLOT TIME (FG+BG+DISP)
	LR	R15,R2			:SAVE THE TOTAL IN R15 FOR CVTPCT
	LIS	R6,6			:CHARACTER COUNT 
	LA	R7,SPMDET+$A53		:TOTAL SLOT TIMING LINE ADDRESS
	JAL	R5,CVTICK		:CONVERT TO DECIMAL 
  
	LR	R2,R15			:GET TOTAL SLOT TICKS IN R2
	LA	R7,SPMDET+$A60		:SLOT PERCENT LINE ADDRESS
	JAL	R5,CVTPCT		:GET JOB TIME PERCENTAGE
        LIS     R0,0			:
        ST      R0,SLOTOT               :RESET SLOT LINE TOTAL ACCUMULATOR
					:
:	.......................................................................
:       THE FOLLOWING WILL DISPLAY THE MXP/XPI DISPATCHER RATE IN THE
:       SLOT 'FF' DISPATCHER COUNT FIELD WITHOUT INCLUDING IT INTO THE
:       ISIS SYSTEM TALLIES.  
:
:	available only for version 3.00 of MXP-XPI
:	.......................................................................
					:
        IF      ENHMXP
        LR      R10,R10                 :TEST FOR SLOT 'FF'
        JGE     NOTFF                   :IF NOT
        L       R2,DSPCNT,,             :GET DISPATCHER EXECUTION FROM XPI
        LA      R7,SPMDET+$A39          :DISP EXEC CNT LINE ADDRESS
        LIS     R6,6                    :FIELD SIZE
        LIS     R8,0                    :NO DECIMAL POINT
        JAL     R9,CBD                  :CONVERT TO ASCII AND OUTPUT
        LI      R2,0A8D8D0C9            :'(XPI'
        ST      R2,SPMDET+$A46          :STOORE IN TIME FIELD
        LHI     R2,0A9                  :')'
        STB     R2,SPMDET+$A50
NOTFF   EQ      .
        EI      (ENHMXP)
:*************************************************************************
:	OUTPUT SLOT LINE TO TERMINAL, RESET INDICES, TEST FOR DONE
:*************************************************************************
	SVC	OUT,SPMDET		:OUTPUT SPAM SLOT DATA
  
:               ADJUST INDICES FOR SLOT LINES
:
        AHI     R11,20                  :POINT TO NEXT SLOTS JOB TABLES
        AIS     R10,1                   :INCREMENT TRUE SLOT INDEX
:
        IF      SUP
        CHI     R10,NSLOT+2             :IF SUP SLOT ONLY
        ELSE
        CHI     R10,NSLOT+1             :ALL SLOTS PROCESSED?
        EI      SUP
        JL      SPAMID                  :NO - GO PROCESS NEXT SLOT

:*************************************************************************
:	ACCUMULATE AND OUTPUT DDT/KIO COUNTS AND TIMINGS SEPARATELY 
:*************************************************************************
:
:		GET DDT AND KIO DATA - ADD TO ACTIVITY ACCUMULATORS ONLY
  
	SVC	OUT,SPKIO1
	SVC	OUT,SPKIO2		:OUTPUT DDT/KIO JOB HEADERS
	LHI	R0,0A0			:ASCII SPACE
	LHI	R11,$A69
CLRDET	STB	R0,SPMDET+$A8,R11	:CLEAR TO END OF OUTPUT LINE
	SIS	R11,1
	JGEBS	CLRDET

DDTKIO	EQ	.			:OUTPUT ONE LINE OF DATA PER SLOT
	LCS	R10,1			:BEGIN WITH SLOT '-1' (ISIS)
	LIS	R11,0			:SLOT TABLE INDEX, 0 = SLOT FF
					:INCREMENTED BY 20 HEX
	LIS	R12,4			:WORD INDEX FOR JOBS WITHIN SLOT, 0=DDT, 4=KIO
	LIS	R13,4			:WORD INDEX FOR ACCUMULATOR TABLES 0=DDT, 4=KIO
:
DKIO1	EQ	.
	JAL	R1,GTSPID		:SET UP SPAM ID'S

:
	L	R2,JOBCNT,R11,R12	:GET EXEC COUNT FOR THIS SLOT (kio)
        AM      R2,DDTEXE,R13           :ADD TO TIME ACCUMULATOOR
        AM      R2,TOTJOB               :ADD TO TOTAL EXECUTION ACCUMULATOR
	LA	R7,SPMDET+$A25		:EXEC COUNT LINE ADDRESS
	LIS	R6,5			:CHARA COUNT
        LIS     R8,0                    :NO DECIMAL POINT
        JAL     R9,CBD                  :CONVERT TO ASCII AND OUTPUT TO LINE

	L       R2,TIMTBL,R11,R12       :GET TICKS FOR THIS SLOT/JOB (KIO)
        AM      R2,DDTTIM,R13           :ADD TO  TIME ACCUMULATOOR
        AM      R2,TOTLTI               :ADD TICKS ALL SLOT TIME ACCUM
	AM	R2,SLOTOT		:ADD TO SLOT LINE ACCUMULATOR
        LIS     R6,6                    :CHARACTER COUNT 6
	LA	R7,SPMDET+$A32		:TIMING LINE ADDRESS
	JAL	R5,CVTICK		:CONVERT TO DEC AND OUTPUT TO LIN

:	OUTPUT KIO EXECUTION TIME PER ITERERATION

	L	R2,TIMTBL,R11,R12	:GET KIO TIME IN TICKS
	L	R6,JOBCNT,R11,R13	:GET KIO EXEC COUNT
	JAL	R3,CVT4A		:CONVERT TO EXCEC TIME IN MICROSECONDS
	LA	R7,SPMDET+$A40		:POINT TO OUTPUT STRING ADDRESS
	LIS	R6,7			:FIELD LENGTH
	LIS	R8,1			:DECIMAL PLACEMENT IN POSITION 1
	JAL	R9,CBD			:CONVERT TO ASCII AND OUTPUT TO LINE

	SIS	R12,4			:POINT TO DDT
	SIS	R13,4

	L	R2,JOBCNT,R11,R12	:GET EXEC COUNT FOR THIS SLOT (DDT)
        AM      R2,DDTEXE,R13           :ADD TO TIME ACCUMULATOOR
        AM      R2,TOTJOB               :ADD TO TOTAL EXECUTION ACCUMULATOR
	LA	R7,SPMDET+$A12		:EXEC COUNT LINE ADDRESS
	LIS	R6,5  			:CHARA COUNT
        LIS     R8,0                    :NO DECIMAL POINT
        JAL     R9,CBD                  :CONVERT TO ASCII AND OUTPUT TO LINE

	L       R2,TIMTBL,R11,R12       :GET TICKS FOR THIS SLOT/JOB (DDT)
        AM      R2,DDTTIM,R13           :ADD TO  TIME ACCUMULATOOR
        AM      R2,TOTLTI               :ADD TICKS ALL SLOT TIME ACCUM
	AM	R2,SLOTOT		:ADD TO SLOT LINE ACCUMULATOR
        LIS     R6,6                    :CHARACTER COUNT 6
	LA	R7,SPMDET+$A18		:TIMING LINE ADDRESS
	JAL	R5,CVTICK		:CONVERT TO DEC AND OUTPUT TO LINE

:		GET TOTAL TIME FOR THIS SLOT (DDT+KIO TIME)
:		AND GET PERCENTAGE OF ONE MINUTE'S TIME USED
  
	L	R2,SLOTOT		:GET TOTAL SLOT TIME (DDT+KIO)
	LR	R15,R2			:SAVE THE TOTAL IN R15 FOR CVTPCT
	LIS	R6,6			:CHARACTER COUNT 
	LA	R7,SPMDET+$A53		:TOTAL SLOT TIMING LINE ADDRESS
	JAL	R5,CVTICK		:CONVERT TO DECIMAL 
  
	LR	R2,R15			:GET TOTAL SLOT TICKS IN R2
	LA	R7,SPMDET+$A60  	:SLOT PERCENT LINE ADDRESS
	JAL	R5,CVTPCT		:GET JOB TIME PERCENTAGE
        LIS     R0,0
        ST      R0,SLOTOT               :RESET SLOT LINE TOTAL ACCUMULATOR

 	SVC	OUT,SPMDET		:OUTPUT (ONE LINE) SPAM SLOT DDT/KIO DATA


:               ADJUST INDICES FOR SLOT LINES
:
        AHI     R11,20                  :POINT TO NEXT SLOT TABLE ENTRIES
        LIS     R12,4                   :RESET SLOT/JOB POINTER
        LIS     R13,4                   :RESET ACCUMULATOR INDEX
        AIS     R10,1                   :INCREMENT TRUE SLOT INDEX
:
	IF	SUP
	CHI	R10,NSLOT+8		:KER=FF,NODE=00,SUP, SLAVES*6
	ELSE
	CHI	R10,NSLOT+1
	EI	SUP
	JN	DKIO1			:NOT - GO PROCESS NEXT SLOT

:*************************************************************************
:	COLLECT JOB TOTAL TIME, EXECUTIONS AND PERCENTAGES
:*************************************************************************
:		GET DDT TOTALS
: 
        LIS     R12,0                   :INDEX TO DDT ACCUMULATORS
     	LA	R7,SPMST5+$A23		:DDT ACTIVITY ELAPSED TIME LINE ADDR
        JAL     R3,CVT3                 :GET PARAMETERS FOR CVTICK
	JAL	R5,CVTICK		:CONVERT TO DECIMAL 
:
	LR	R2,R15			:GET TOTAL JOB TICKS IN R2
	LA	R7,SPMST5+$A37		:DDT ACTIVITY PERCENT LINE ADDR
	JAL	R5,CVTPCT		:GET PERCENTAGE 
:
	LA	R7,SPMST5+$A11		:DDT ACTIVITY EXEC COUNT LINE ADDR
        JAL     R3,CVT2                 :GET PARAMETERS FOR CBD
	JAL	R9,CBD			:JAL TO BCD 
	JAL	R3,CVT4			:GET JOB EXECUTION TIME IN uSECS.
	LA	R7,SPMST5+$A44		:DDT ACTIVITY EXEC TIMING LINE ADDR
	LIS	R6,7			:CHARACTER COUNT
	LIS	R8,1
	JAL	R9,CBD			:CONVERT TO DEC. MICROSECONDS
  
:		GET KIO TOTALS
   
        AIS     R12,4                   :INDEX TO KIO ACCUMULATORS
	LA	R7,SPMST6+$A23		:KIO ACTIVITY ELAPSED TIME LINE ADDR
	JAL	R3,CVT3			:GET PARAMS FOR CVTICK
	JAL	R5,CVTICK		:CONVERT TO DECIMAL 
	LR	R2,R15			:GET TOTAL JOB TICKS IN R2
	LA	R7,SPMST6+$A37		:KIO ACTIVITY PERCENT LINE ADDRESS
	JAL	R5,CVTPCT		:GET PERCENTAGE
	LA	R7,SPMST6+$A11		:KIO ACTIVITY EXEC COUNT LINE ADDR
	JAL	R3,CVT2			:GET PARAMS FOR CBD
	JAL	R9,CBD			:CONVERT TO DEC.
	JAL	R3,CVT4			:GET JOB EXEC. TIME IN uSECS.
	LA	R7,SPMST6+$A44		:KIO ACTIVITY EXEC TIMING LINE ADDRESS
	LIS	R6,7			:CHARACTER COUNT
	LIS	R8,1
	JAL 	R9,CBD			:CONVERT TO uSECS.
   
:		GET BACKGROUND TOTALS
   
        AIS     R12,4                   :INDEX TO BACKGROUND ACCUMULATORS
	LA	R7,SPMST3+$A23		:BACKGRND ACTIVITY ELAP TIME LINE ADDR
	JAL	R3,CVT3			:GET PARAMS FOR CVTICK
	JAL	R5,CVTICK		:CONVERT TO DECIMAL 
	LR	R2,R15			:GETTOTAL JOB TICKS IN R2
	LA	R7,SPMST3+$A37		:BACKGRND ACTIVITY PERCENT LINE ADDR
	JAL	R5,CVTPCT		:GET PERCENTAGE
	LA	R7,SPMST3+$A11		:BACKGRND ACTIVITY EXEC COUNT LINE ADDR
	JAL	R3,CVT2			:GET PARAMS FOR CBD
	JAL	R9,CBD			:CONVERT TO DEC.
	JAL	R3,CVT4			:GET JOB EXEC. TIME IN uSECS.
	LA	R7,SPMST3+$A44		:BACKGRND ACTIVITY EXEC TIME LINE ADDR
	LIS	R6,7			:CHARACTER COUNT 
	LIS	R8,1
	JAL	R9,CBD			:CONVERT TO uSECS.
   
:		GET DISPATCHER TOTALS
  
        AIS     R12,4                   :INDEX TO DISPATCHER ACCUMULATORS
	LA	R7,SPMST4+$A23		:DISP ACTIVITY ELAP TIME LINE ADDR
	JAL	R3,CVT3			:GET PARAMS FOR CVTICK
	JAL	R5,CVTICK		:CONVERT TO DECIMAL 
	LR	R2,R15			:GET TOTAL JOB TICKS IN R2
	LA	R7,SPMST4+$A37		:DISP ACTIVITY PERCENT LINE ADDR
	JAL	R5,CVTPCT		:GET PERCENTAGE
	LA	R7,SPMST4+$A11		:DISP ACTIVITY EXEC COUNT LINE ADDR
	JAL	R3,CVT2			:GET PARAMS FOR CBD
	JAL	R9,CBD			:CONVERT TO DEC.
	JAL	R3,CVT4			:GET JOB EXEC. TIME IN uSECS.
	LA	R7,SPMST4+$A44		:DISP ACTIVITY EXEC TIME LINE ADDR
	LIS	R6,7			:CHARACTER COUNT
	LIS	R8,1
	JAL 	R9,CBD			:CONVERT JOB EXEC TO uSECS.
   
:		GET FOREGROUND TOTALS
   
        AIS     R12,4                   :INDEX TO FOREGROUND ACCUMULATORS
	LA	R7,SPMST2+$A23		:FOREGRND ACTIVITY ELAP TIME LINE ADDR
	JAL	R3,CVT3			:GET PARAMS FOR CVTICK
	JAL	R5,CVTICK		:CONVERT TO DECIMAL 
	LR	R2,R15			:GET TOTAL JOB TICKS IN R2
	LA	R7,SPMST2+$A37		:FOREGRND ACTIVITY PERCENT LINE ADDR
	JAL	R5,CVTPCT		:GET PERCENTAGE
	LA	R7,SPMST2+$A11		:FOREGRND ACTIVITY EXEC COUNT LINE ADDR
	JAL	R3,CVT2			:GET PARAMS FOR CBD
	JAL	R9,CBD			:CONVERT TO DEC.
	JAL	R3,CVT4			:GET JOB EXEC. TIME IN uSECS.
	LA	R7,SPMST2+$A44		:FOREGRND ACTIVITY EXEC TIME LINE ADDR
	LIS	R6,7			:CHARACTER COUNT
	LIS	R8,1
	JAL	R9,CBD			:CONVERT TO DEC. uSECS.
   
:		GET NODE CPS (PHYSICAL)
   
	L	R2,NODCPS,,		:GET OUTPUT NODE CPS
	LA	R7,SPMST2+$A72		:NODE OUTPUT CPS LINE ADDR
	LIS	R6,6			:CHARACTER COUNT
	LIS	R8,0			:NO DECIMAL PT.
	JAL	R9,CBD			:CONVERT TO DECIMAL
	L	R2,NODCPS+4,,		:GET INPUT CPS
	LA	R7,SPMST2+$A65		:NODE INPUT CPS LINE ADDR
	LIS	R6,6			:CHARACTER COUNT
	LIS	R8,0			:NO DECIMAL PT.
	JAL	R9,CBD			:CONVERT TO DECIMAL
					:
:	.......................................................................
:		GET "TOTALS" FOR ALL JOBS
:	.......................................................................
   					:
	L	R2,TOTLTI		:GET TOTAL ELAPSED TIME (ALL JOBS)
	LR	R15,R2			:SAVE TIME IN R2
	LA	R7,SPMST7+$A23		:ACTVITY TOTALS ELAP TIME LINE ADDR
	LIS	R6,6			:CHARACTER COUNT
	JAL	R5,CVTICK		:CONVERT TO DECIMAL
	LR	R2,R15			:GET TOTAL TIME FOR ALL JOBS IN R2
	LA	R7,SPMST7+$A37		:ACTIVITY TOTALS PERCENT LINE ADDR
	JAL	R5,CVTPCT		:GET PERCENTAGE
	L	R2,TOTJOB		:GET TOTAL EXECS (ALL JOBS)
	LA	R7,SPMST7+$A11		:ACTIVITY TOTALS EXEC COUNT LINE ADDR
	LIS	R6,6			:CHARACTER COUNT
	LIS	R8,0			:NO DECIMAL PT.
	JAL 	R9,CBD			:CONVERT TO DEC.
					:
:	.......................................................................
:	OUTPUT "TOTALS" EXECUTION TIME PER ITERERATION
:	.......................................................................
					:
	L	R2,TOTLTI		:GET TOTAL TIME IN TICKS
	L	R6,TOTJOB		:GET TOTAL EXECUTIONS COUNT
	JAL	R3,CVT4A		:CONVERT TO EXCEC TIME IN MICROSECONDS
	LA	R7,SPMST7+$A44		:POINT TO OUTPUT STRING ADDRESS
	LIS	R6,7			:FIELD LENGTH
	LIS	R8,1			:DECIMAL PLACEMENT IN POSITION 1
	JAL	R9,CBD			:CONVERT TO ASCII AND OUTPUT TO LINE
					:
:	.......................................................................
:		GET SCHEDULER PASSES
:	.......................................................................
					:
   	L	R2,SKEDIT,,		:GET TOTAL SCHEDULER COUNT
	LA	R7,SPMST1+$A11		:ACTIVITY SYSTEM EXEC COUNT LINE ADDR
	LIS	R6,6			:CHARACTER COUNT
	LIS	R8,0			:NO DECIMAL PT.
	JAL	R9,CBD			:CONVERT TO DEC.
  					:
:	.......................................................................
:		GET SYSTEM STATISTICS
:	.......................................................................
					:
        LIS     R3,0			:
	L	R2,TOTLTI		:GET TOTAL IN TICKS FOR ALL JOBS
        JE      SPNZRO                  :SKIP IF ZERO
	LI	R3,$A 36000000		:LOAD 36,000,000 TICKS
	SR	R3,R2			:GET THE DIFFERENCE
	JGFS	SPNZRO			:IF POSITIVE, CALC. SYS.TIME
	LIS	R3,0			:ELSE, SET TO ZERO
SPNZRO	LR	R2,R3			:GET DIFFERENCE IN R2
	ST	R2,SPMJOB		:SAVE DIFFERENCE AS SYSTEM TIME IN TICKS
	LR	R15,R2			:COPY DIFFERENCE TO R15
	LIS	R6,6			:CHARACTER COUNT
	LA	R7,SPMST1+$A23		:ACTIVITY SYSTEM ELAP TIME LINE ADDR
	JAL	R5,CVTICK		:CONVERT TO DECIMAL 
	LR	R2,R15			:GET THE TIME IN R2
	LA	R7,SPMST1+$A37		:ACTIVITY SYSTEM PERCENT LINE ADDR
	JAL	R5,CVTPCT		:OUTPUT PERCENTAGE
					:
:	.......................................................................
:	OUTPUT "SYSTEM" EXECUTION TIME PER ITERERATION
:	.......................................................................
					:
	L	R2,SPMJOB		:GET TOTAL TIME IN TICKS
	L	R6,SKEDIT,,		:GET TOTAL SCHEDULAR EXECUTION COUNT
	JAL	R3,CVT4A		:CONVERT TO EXCEC TIME IN MICROSECONDS
	LA	R7,SPMST1+$A44		:POINT TO OUTPUT STRING ADDRESS
	LIS	R6,7			:FIELD LENGTH
	LIS	R8,1			:DECIMAL PLACEMENT IN POSITION 1
	JAL	R9,CBD			:CONVERT TO ASCII AND OUTPUT TO LINE
					:
:	.......................................................................
:	OUTPUT EXECUTIVE IDLE COUNT
:	.......................................................................
					:  
   	L	R2,IDLECT,,		:GET SCHEDULER IDLE COUNT
	LA	R7,SPMST8+$A11		:EXEC IDLE COUNT LINE ADDR
	LIS	R6,6			:CHARACTER COUNT
	LIS	R8,0			:NO DECIMAL PT.
	JAL	R9,CBD			:CONVERT TO DEC.
					:
:	.......................................................................
:	OUTPUT SYSTEM JOB RESTART COUNT
:	.......................................................................
					:
   	L	R2,SKEDRS,,		:GET TOTAL SCHEDULER COUNT
	LA	R7,SPMST0+$A11		:ACTIVITY SYSTEM EXEC COUNT LINE ADDR
	LIS	R6,6			:CHARACTER COUNT
	LIS	R8,0			:NO DECIMAL PT.
	JAL	R9,CBD			:CONVERT TO DEC.  
					:
:	.......................................................................
:       OUTPUT SYSTEM ACTIVITY LINES TO TERMINAL
:	.......................................................................
					:
CMNOUT	SVC	OUT,SPMHD4		:OUTPUT YET SOME MORE HEADERS
	SVC	OUT,SPMHD5		:
	SVC	OUT,SPMST2		:FOREGROUND TOTALS
	SVC	OUT,SPMST3		:BACKGROUND TOTALS
	SVC	OUT,SPMST4		:DISPATCHER TOTALS
	SVC	OUT,SPMST5	  	:DDT TOTALS
	SVC	OUT,SPMST6		:KIO TOTALS
	SVC	OUT,CRLF		:
	SVC	OUT,SPMST7		:TOTAL OF ABOVE JOBS MINUS SYSTEM TIME
	SVC	OUT,CRLF		:
	SVC	OUT,SPMST1		:OUTPUT SYSTEM TOTAL TIME
	SVC	OUT,SPMST0		:OUTPUT SYSTEM JOB RESTART COUNT
	SVC	OUT,SPMST8		:OUTPUT EXECUTIVE IDLE COUNT
	LHL	R2,CHKPT,,		:CHECK SPAM ERROR INDICATOR
	JEFS	SPMXIT			:IF ZERO, EXIT
   IF	SPMTRC				:IF SPAM TRACE IS ON, OUTPUT TRACE STOP REASON
	LHL	R2,TRCON,,		:
   ELSE					:ELSE OUTPUT CHECKPOINT REASON
   EI  (SPMTRC)				:
	LIS	R6,2			:CHARACTER COUNT
	LA	R7,SPMERR+$A27		:ACTIVITY SYSTEM EXEC COUNT LINE ADDR
	LIS	R8,0			:NO DECIMAL PT.
	JAL	R9,CBD			:CONVERT TO DEC.
	SVC	OUT,SPMERR		:OUTPUT MESSAGE TO USER
	IF	SPMTRC			:IF SPAM TRACE IS ON, DON'T RESTART AFTER ERROR
	ELSE				:IF SPAM TRACE OFF, ZERO EVERYTHING AND RESTART
	LCS	R2,1
	STH	R2,ENAB,,		:RESTART SPAM FROM SCRATCH
	EI	(SPMTRC)
SPMXIT	LM	R0,SPMSAV		:RESTORE RETURN REGISTER
	J	TTY,,			:EXIT SPAM
  
:	SET UP PARAMETERS TO PASS TO CVTICK AND CBD ROUTINES
  
CVT2	L	R2,DDTEXE,R12		:GET TOTAL JOB EXECUTIONS
	LR	R0,R2			:GET EXECS IN R0
	LIS	R6,6			:CHARACTER COUNT
	LIS	R8,0			:NO DECIMAL PT. REQUIRED
	JR	R3			:RETURN
  
CVT3	L	R2,DDTTIM,R12		:GET TOTAL JOB TIME
	LR	R15,R2			:SAVE FOR CVTPCT
	LIS	R6,6			:CHARACTER COUNT
	JR	R3			:RETURN
  
CVT4	L 	R2,DDTTIM,R12		:GET TOTAL JOB TIME IN TICKS
	L	R6,DDTEXE,R12		:GET TOTAL NUMBER OF JOB EXECUTIONS
CVT4A	LR	R2,R2			:TEST FOR ZERO
	JER	R3			:IF ZERO, RETURN
	LIS	R1,0
	DR	R1,R6			:DIVIDE TIME BY EXECS (R2 = TICKS/EXEC)
	LHI	R6,$A 16667		:GET MULTIPLIER (1 TICKx10000)
	LIS	R1,0
	MR	R1,R6			:GET TOTAL TIME
	LIS	R1,0
	LHI	R6,$A 10000		:GET DIVISOR
	DR	R1,R6			:EXECUTION TIME IN MICROSECONDS IN R2
	JR	R3


  





	
N


	  
  
	WC	0
	NOLIST
SPMHD0  SC      /                      SYSTEM PERFORMANCE ANALYSIS MONITOR"8D"8A"8D"8A/
        IF      MXP
SPMHD1  SC      /                    NODE:       MXP#:       TIME:    :  :  :   "8D"8A"8D"8A/
        ELSE
SPMHD1  SC      /                    NODE:       HOST:       TIME:    :  :  :   "8D"8A"8D"8A/
        EI      (MXP)
SPMHD2  SC      /SLOT       FOREGROUND   BACKGROUND    DISPATCHER    TOTAL  SLOT DISP AVER CPS"8D"8A/
SPMHD3  SC      /NAME NO FQ COUNT TIME   COUNT  TIME   COUNT  TIME   TIME   PRCT INPUT  OUTPUT"8D"8A"8A/
SPMHD4  SC      /"8D"8AACTIVITY EXEC COUNT  ELAPSED TIME  PERCENT EXEC TIME       AVER PHYS NODE CPS"8D"8A/
SPMHD5  SC      /                                                                INPUT  OUTPUT"8D"8A/
SPMST0	SC	/RESTARTS        "8D"8A/
SPMST1  SC      /SYSTEM                                            "8D"8A/
SPMST2	SC	/FOREGRND                                                                      "8D"8A/
SPMST3  SC      /BACKGRND                                          "8D"8A/
SPMST4	SC	/DISPATCH                                          "8D"8A/
SPMST5  SC      /DDT                                               "8D"8A/
SPMST6  SC      /KIO                                               "8D"8A/
SPMST7  SC      /TOTALS                                            "8D"8A/
SPMST8	SC	/EXC IDLE        "8D"8A/
SPMERR  SC      /"8D"8A        SPAM CHECKPOINT XX TAKEN!! "8D"8A/
	HS	0
SPMDET  SC      /                                                                             "8D"8A/
SPKIO1	SC	/"8D"8A           DDT JOB      KIO JOB         KIO EXEC    TOTAL  SLOT"8D"8A/
SPKIO2	SC	/           COUNT TIME   COUNT  TIME     TIME        TIME   PRCT"8D"8A/

SPAM12	SC	'"8D"8A     *SPAM ACCESS RESTRICTED TO SLOT FF!*"8D"8A'
	LIST
Q	EQ	0
SPMQFG	EQ	.
	BC	01			:ISIS Q.FG = 01
	RE	NSLOT+1
	BC	Q.FG|$A Q|
Q	EQ	Q+1
	ER
	WS	0
P	EQ	0
	IF	SUP
SPAPRD  EQ      .
	RE	NSLOT+8
        HC      P.N|$A P|
P       EQ      P+1
        ER
        ELSE
SPAPRD  EQ      .
        RE      NSLOT+2
        HC      P.N|$A P|
P	EQ	P+1
	ER
	EI	SUP
DAYS1	WC	$A 24*60*60		:SECONDS IN A DAY
HOUR1	HC	$A 60*60		:SECONDS IN AN HOUR
SIXTY1	HC	$A 60
        WS      0                       :FORCE WORD BOUNDARY

DDTTIM  WC      0                       :DDT TIME ACCUMULATOR
KIOTIM  WC      0                       :KIO TIME ACUMULATOR
BGDTIM  WC      0                       :BACKGROUND TIME ACCUMULATOR
DSPTIM  WC      0                       :DISPATCHER TIME ACCUMULATOR
FGDTIM  WC      0                       :FOREGROUND TIME ACCULULATOR

DDTEXE  WC      0                       :DDT EXECUTION ACCUMULATOR
KIOEXE  WC      0                       :KIO EXECUTION ACCUMULATOR
BGDEXE  WC      0                       :BACKGROUND EXECUTION ACCUMULATOR
DSPEXE  WC      0                       :DISPATCHER EXECUTION ACCUMULATOR
FGDEXE  WC      0                       :FOREGROUND EXECUTION ACCUMULATOR

TOTJOB	WC	0			:TOTAL JOB EXECUTIONS FOR ALL SLOTS
TOTLTI	WC	0			:TOTAL TIME FOR ALL JOB EXECS FOR ALL SLOTS
SLOTOT	WC	0			:TOTAL TIME FOR EACH SLOT (FG+BG+DISP)
SPMJOB	WC	0			:TOTAL OF ALL JOBS+SYSTEM TIME
EXEND	EQ	.-DDTTIM-4
SPMSAV	WS	$A16			:REGISTER SAVE
  
:	GET PRODUCT ID FROM CTA (PIDTBL)
:
:       FIRST CHECK TYM FILE FOR PRODUCT ID OVER-RIDE
: 
GTSPID	EQ	.
        LHI     R3,37                   :SET UP FOR ISIS ID
        LR      R10,R10                 :TEST SLOT NUMBER
        JL      SPSTUF                  :IF ISIS - ALWAY STUFF IT
	LH	R3,SPAPRD,R10,R10	:GET PRODUCT ID FROM TYMFILE
        JN      SPSTUF                  :IF TYMFILE ENTRY FOUND, USE IT
	chi	r10,nslot+1		:if no tymfile entry for sup and slaves
	jge	spgoof			:assume no PID. 
        LR      R14,R10                 :COPY SLOT NUMBER
        SLLS    R14,2                   :ADJUST TO FULLWORD INDEX
        L       R7,SLIST,R14,,          :GET POINTER TO NEXT USER BLOCK
	L	R8,CONTROL,R7		:GET DDT USER BLOCK FOR THIS SLOT
	L 	R2,SBASE,R8		:LOCATE CTA TABLE
        LHL     R3,PID,R2               :GET PRODUCT ID
SPSTUF	SHI	R3,PIDLOW		:ADJUST FOR LOWEST PID
	JL	SPGOOF 			:EXIT, NO PID LISTED
	CLHI	R3,PIDENT-1		:CHECK HIGHEST PID
	JG	SPGOOF			:EXIT, NO PID LISTED
IDRTRN  LR      R7,R3                   :MAKE COPY OF OFFSET
	SLLS	R7,2			:MAKE FW INDEX
	L	R8,PIDTBL,R7		:GET PID ASCII CODE
        JE      SPGOOF                  :NO ASCII EQUIVALENT
SPMRTN  LIS     R7,3                    :CHARA CNT = 4
SPMOUT  STB     R8,SPMDET+1,R7          :PRODUCT NAME LINE ADDRESS (1-4)
	SRLS	R8,8			:MOVE NEXT CHARACTER IN
	SIS	R7,1			:DECREMENT CHARACTER COUNT
	JGEBS	SPMOUT			:IF MORE, GET NEXT
	J	SLOTN0			:GO GET SPAM DATA
SPGOOF	LI	R8,0ADADADAD		:GET DEFAULT (HYPHEN)
        J       SPMRTN                  :GO OUTPUT
:
:       OUTPUT SLOT NUMBER TO SLOT DETAIL LINE
:
SLOTN0  LR      R2,R10                  :TEST FOR 'ISIS'
        JGE     SLOTN1                  :IF NON-ISIS SLOT
        LHI     R8,0C6C6                :ASCII 'FF'
        STH     R8,SPMDET+6             :SLOT NUMBER LINE ADDRESS
	JR	R1			:RETURN

SLOTN1  LIS     R8,0                    :NO DECIMAL POINT REQUIRED
	LA	R7,SPMDET+6		:SLOT NUMBER LINE ADDRESS
	LIS	R6,2			:CHARACTER COUNT
	JAL	R9,CBD			:CONVERT TO ASCII
	JR	R1			:RETURN
:
:	SPMCNV (SPAM SUBROUTINE TO CONVERT FROM BINARY TO ASCII DECIMAL)
  
:       SETUP TO USE "CVTICK" ROUTINE
:
:       L       R2,TIMTBL,Rn    :R2 - TICK VALUE TO CONVERT
:       L       R7,ADDR         :R7 - ADDRESS TO DEPOSIT ASCII STRING
:       LIS     R6,6            :R6 - ASCII OUTPUT FIELD LENGTH
:       JAL     R5,CVTICK       :R5 - LINK

:*******************************************
:
:       THE FOLLOWING CONVERTS TICK FRACTIONS TO REAL TIME VALUE
:       AND CONVERTS TO ASCII STRING OUTPUT IN DECIMAL VALUE
:       TO 3 DECIMAL POSITIONS.  RETURNS TIME VALUE IN MILLISECONDS
:       IN R0
:
RBCBA	EQ	2
RADX	EQ	4
RSCBA	EQ	6
RACBA	EQ	7
RNCBA	EQ	8
RLCBA	EQ	9

CVTICK  EQ      .
        LHI     R3,$A16667      :R3 - VALUE OF ONE TICK
        LIS     R1,0            :ZERO HIGH ORDER WORD
        MR      R1,R3           :CONVERT TICKS TO REAL TIME
                                :R1/R2 = RESULT 0.0000000
        LI      R3,$A10000000   :COPMENSATE FOR 7 DECIMAL PLACES
        DR      R1,R3           :R2 = RESULT IN MILLISECONDS 0.000
        LIS     RADX,$A10       :SET CBA RADIX TO 10 DEC
        LIS     R8,3            :R8 - NUMBER OF DECIMAL PLACES TO OUTPUT
        JAL     RLCBA,CBD       :CONVERT BINARY TO ASCII
        JR      R5              :RETURN

:************************************************
:       THE FOLLOWING CONVERTS THE VALUE OF THE JOB TICKS FOR
:       EACH JOB AND CONVERTS IT TO A PERCENTAGE OF ONE MINUTE
:       AND OUTPUTS IT IN AN ASCII STRING
:
CVTPCT  EQ      .
        LIS     R1,0            :ZERO HIGH ORDER WORD
        LHI     R3,$A 3600	:GET 
        DR      R1,R3           :R2 - RESULT IN PERCENT
	LIS	R1,0		:ZERO R1
	LIS	R3,$A 10	:LOAD DIVISOR
	DR	R1,R3		:STRIP OFF ONE DIGIT
        LIS     RADX,$A10
        LIS     R8,3            :SET FOR 1 DECIMAL PLACE
        LIS     R6,4            :SET ASCII OUTPUT FIELD LENGTH XX.X
        JAL     RLCBA,CBD       
        JR      R5              :RETURN


:************************************************
:
:       THE FOLLOWING CONVERTS A BINARY NUMBER TO AN ASCII STRING
:       IN THE REQUESTED RADIX ALONG WITH REQUESTED DECIMAL PLACEMENT
:       IF DESIRED.  VALUES TO THE RIGHT OF THE DECIMAL WILL BE
:       ZERO FILLED.  VALUES TO THE LEFT OF THE DECIMAL WILL BE
:       BLANK FILLED.
:
:RBCBA   EQ      2
:RADX    EQ      4
:RSCBA   EQ      6
:RACBA   EQ      7
:RNCBA   EQ      8
:RLCBA   EQ      9
:
:
:       ENTRY   RBCBA   BINARY #
:               RADX    RADIX (2 TO 10 HEX)
:               RNCBA   DECIMAL PLACEMENT (POSITIONS TO RIGHT OF DECIMAL)
:               RLCBA   LINK
:               RACBA   ADDRESS TO DEPOSIT STRING
:               RSCBA   SIZE OF FIELD IN CHARACTERS
:
:       DESTROYS R2,3,6,RSCBA (SIZE)




CBD     LR      R3,RBCBA        :GET NUMBER TO SCRATCH REGISTER
CBD010  LIS     R2,0            :CLEAR UPPER HALF
        DR      R2,RADX         :DIVIDE BY RADIX
        LB      R2,CBAASC,R2    :CONVERT TO ASCII
CBD020  STB     R2,-1,RACBA,RSCBA       :SAVE CHARACTER
        SIS     RSCBA,1         :COUNT CHARACTER IN STRING
        JLER    RLCBA           :RETURN IF FIELD FULL
        CR      RSCBA,RNCBA     :CHECK FOR DECIMAL PLACEMENT
        JNFS    CBD30           :NOT YET
        LHI     R2,POINT
        STB     R2,-1,RACBA,RSCBA       :STORE DECEIMAL POINT
        SIS     RSCBA,1         :COUNT DECIMAL AS CHARA IN STRING
        JLER    RLCBA           :RETURN IF FIELD FULL
CBD30   LR      R3,R3           :IS NUMBER FULLY PROCESSED?
        JG      CBD010          :IF NOT
        LHI     R2,CBDFIL       :FILL CHARA (ASCII 0)
        CR      RSCBA,RNCBA     :CHECK FOR RIGHT OF DECIMAL
        JG      CBD020          :ZERO FILL
        LHI     R2,CBDFIL       :FILL CHAR (DEFAULT IS BLANK)
        J       CBD020          :GO CHAR. FILL

CBAASC  AC      "0123456789ABCDEF"
CBAFIL  EQ      0A0             :ASCII BLANK
CBDFIL  EQ      0B0             :ASCII ZERO
POINT   EQ      0AE             :ASCII DECIAML POINT
  
	EI	(SPAM)

HGHDDT	WS	0			:FORCE TO WORD BOUNDARY
					:

	SUBTTL	L O G I N   C O D E

:	....................................................................
:	ISIS DDT Logger
:	....................................................................
					:
LOG	L	R1,USER,,		:USE SCRATCH AREA OF USER BLOCK FOR DATA
	LIS	R0,0			:
	ST	R0,UNAME		:INITIALIZE USERNAME
	ST	R0,UNAME+4		:
	LHL	R2,BUFNO,R1		:FIND BUFFER NUMBER
	LO	KCAREA			:
	SBT	R2,KDEM,,		:SET DEM ON
	SBT	R2,KTDEM,,		:LOOK-AHEAD DEM ON TOO
	RBT	R2,KECHO,,		:SET ECHO OFF
	SVC	IN,$A 60		:
	SVC	KIO,0			:HANG HIM IF NO RESPONSE
	NHI	R0,3F			:STRIP OUT TERMINAL TYPE
	STH	R0,TERCAR,R1		:AND SAVE IN USER BLOCK
   IF	KIODES				:
        STB     R0,KTID,R2,             :SAVE IN ARRAY FOR LOGIN
   EI  (KIODES)				:
	SVC	IN,$A 60		:
	SVC	KIO,0			:HANG HIM IF NO RESPONSE
:	STB	R0,MAX+1
	SVC	IN,$A 60		:
	SVC	KIO,0			:HANG HIM IF NO RESPONSE
:	STB	R0,MAX+2
	SVC	IN,$A 60		:
	SVC	KIO,0			:HANG HIM IF NO RESPONSE
:	STB	R0,MAX+3		:
	LIS	R4,0			:COUNT OF CHARS IN NAME
	LHI	R5,$A 20		:MAXIMUM NUMBER OF CHARACTERS EXPECTED
					:
:	....................................................................
:	INPUT THE USER NAME USED
:	....................................................................
					:
	SVC	IN,$A 60		:FIRST CHAR OF NAME OR EXCLAIM
	SVC	KIO,0			:HANG HIM IF NO RESPONSE
	CLHI	R0,0A1			:IS IT AN EXCLAIM?
	JEFS	LOG2			:YES...COUNT IT AS INPUT, BUT IGNORE IT
	JFS	LOG3			:NO...SKIP TO PUT IN PLACE
LOG1	CLHI	R4,8			:HOW MANY HAVE WE GOTTEN SO FAR?
	JGEFS	LOG2			:WE HAVE MORE THAN 8...JUST SCAN FOR TERMINATION
	STB	R0,UNAME,R4		:ACCUMULATE ANOTHER CHAR
	AIS	R4,1			:COUNT IT THERE
LOG2	SIS	R5,1			:COUNT ANOTHER CHAR INPUT
	JL	LOG4			:ABORT IF TOO MANY
	SVC	IN,$A 60		:NEXT CHAR OF NAME
	SVC	KIO,0			:HANG HIM IF NO RESPONSE
LOG3	OHI	R0,80			:ADD A PARITY BIT
	CLHI	R0,0BB			:IS IT SEMICOLON?
	JE	LOG5			:YES - END OF NAME
	CLHI	R0,8D			:IS IT CR?
	JE	LOG5			:YES...END OF NAME
	JLE	LOG4			:SKIP IF TOO MANY INPUT
	CLHI	R0,83			:CHECK FOR CONTROL-C
	JEFS	LOG4			:
	CLHI	R0,0E1			:IS IT LOWER CASE?
	JL	LOG1			:NO...PROCEED
	CLHI	R0,0FA			:CHECK HIGH BOUNDRY
	JG	LOG1			:NOT LOWER CASE...PROCEED
	SHI	R0,20			:CONVERT TO UPPER CASE
	J	LOG1			:PROCEED
LOG4	SVC	KIO,0			:SOMETHING WRONG...ABORT
					:
LOG5	THI	R5,1			:DID WE READ AN EVEN # OF CHARS?
	JNFS	LOG6			:YES (CR OR SEMICOLON NOT COUNTED)
	CLHI	R2,NKU			:DID HE COME FROM TTY?
	JGEFS	LOG6			:DON'T CARE IF SO
	SVC	IN,$A 60		:READ NULL PLACED IN BUFFER BY SUPERVISOR
	SVC	KIO,0			:HANG HIM IF NO RESPONSE
					:
:	....................................................................
:	NOW SEARCH FOR THAT NAME IN GOOD-GUY LIST
:	....................................................................
					:
LOG6	L	R3,UNAME		:CHECK FOR NULL LENGTH NAME
	JE	LOG9			:
	L	R4,UNAME+4		:GET SECOND WORD OF NAME
	LA	R6,GGSIZE		:POINTER TO LAST ENTRY IN LIST
LOG7	CL	R3,GODGUY+GGNAME,R6	:
	JNFS	LOG8			:NO MATCH - GO ON
	CL	R4,GODGUY+GGNAME+4,R6	:
	JEFS	LOG10			:MATCH - LOG HIM IN
LOG8	SIS	R6,GGLEN		:NEXT GOODGUY
	JGEBS	LOG7			:LOOP IF THERE IS ANOTHER GOODGUY
					:
:	....................................................................
:	ABNORMAL CONDITION...OUTPUT DIAGNOSTIC, THEN ZAP THIS GUY
:	....................................................................
					:
LOG9	SVC	OUT,BUMSG		:BITCH
	SVC	KIO,0			:AND EXIT
					:
:	....................................................................
:	NAME APPEARS IN GOOD-GUY LIST...SET UP TO SERVICE IT
:	....................................................................
					:
LOG10	HS	0			:
   IF	KIODES				:TRIPLEX
	CLHI	R2,NKU			:IS IT TTY PORT?
	JGE	LOG10B			:IF SO, FORCE TO THIS MACHINE
	LHL	R0,GODGUY+GGMACH,R6	:GET MACHINE ATTRIBUTE
	JE	LOG10B			:SUP-BASE
					:
:	....................................................................
:       DETERMINE IF SLAVE IS UP -- IF NOT ZAP CIRCUIT
:	....................................................................
					:
	LIS	R3,0			:INDEX
LOG10C	CLHI	R3,(MLUNUM+1)*4		:COMPARE TO HIGHEST
	JGE	LOG10X			:WIERDNESS??
	L	R4,MLUTBL,R3,		:MB-TABLE ENTRY
	LR	R5,R4			:COPY
	EXHR	R5,R5			:SWITCH HW
	EXBR	R5,R5			:SWITCH BYTES
	LBR	R5,R5			:GET DEVICE
	CLHI	R5,KIODES		:SLAVE?
:	CLHI	R5,91			:SLAVE?***###***
	JEFS	LOG10D			:YES
	AIS	R3,4			:UP INDEX
	JBS	LOG10C			:TRY NEXT
LOG10D	NHI	R4,0F0			:ISSOLATE LINE STATUS
	JNFS	LOG10E			:LINE UP-PROCEEED
	SVC	OUT,SLVDN		:MESSAGE
	SVC	KIO,0			:EXIT AND ZAP
LOG10X	S.HLTF(2010)			:SIO RING SOFTWARE INSISTENCY
LOG10E	LR      R3,R2                   :PORT#
        SLLS    R3,3                    :*8
        L       R6,UNAME                :FIRST WORD OF NAME
        ST      R6,KLNAME,R3,           :STORE IN ARRAY
        L       R6,UNAME+4              :SECOND WORD OF NAME
        ST      R6,KLNAME+4,R3,         :
	SBT	R2,KPTHWT,,		:MARK WAIT FOR LOGIN ACK (R2=PORT#)
	LR	R0,R2			:
	SLL	R0,8			:
	OHI	R0,2			:FORM CONTROL MESSAGE
	LR	R6,R1			:SAVE USER
	LI	R2,DKCTLO		:DEST CTL OUT RING
	LHI	R3,-CTLSIZ		:RING SIZE
	JAL	R1,PUTCTL,,		:BUFFER CLEAR (02) IN CTL RING
	JNFS	LOG10A			:
	S.HLTF(2020)			:NO ROOM IN SIO CONTROL RING
LOG10A	LR	R1,R6			:RE-ESTABLISH USER
	SVC	KIO,$A 18		:EXIT LOGGER
   EI  (KIODES)				:
	FO	KCAREA			:
LOG10B	STH	R6,GGNDX,R1		:SAVE INDEX FOR FUTURE USE
        LIS     R8,0			:
        ST      R8,EXTRAP,R1            :CLEAR EXIT TRAP FIELD
	LH	R8,GODGUY+GGLIC,R6	:COPY LICENSES
	STH	R8,ULICEN,R1		:
	LHL	R0,TERCAR,R1		:CHECK TERMINAL ID
	JEFS	LOG11			:SKIP IF AUX CIRCUIT
	SVC	KIO,3			:ELSE TURN ECHO ON
LOG11	LH	R0,GODGUY+GGUSE,R6	:CHECK FOR NAME FORCED TO SPECIFIC KEY 
	JGE	LOG15			:SKIP IF SO
					:
:	....................................................................
:	USER CAN GET TO ANY SLOT...TELL WHERE HE'S GOTTEN TO, ASK FOR KEY
:	....................................................................
					:
   IF	MXP				:
	SVC	OUT,GREET0		:TELL HIM ITS MXP
	LHI	R0,MXPNM		:
	LHI	R1,30A			:
	SVC	KIO,$A 10		:TELL HIM THE MXP MACHINE NMBR
   EI  (MXP)				:
   IF	MACHNM				:
	SVC	OUT,GREET1		:TELL WHAT NODE HE'S GOTTEN TO
	LHI	R0,MACHNM		:
	LHI	R1,508			:5 OCTAL DIGITS for node number
	SVC	KIO,$A 10		:
    IF	HST0				:
	SVC	OUT,GREET2		:TELL WHAT HOST HE'S GOTTEN TO
	LHI	R0,HST0			:
	LHI	R1,50A			:5 DECIMAL DIGITS for kernel host #
	SVC	KIO,$A 10		:
    EI (HST0)				:
   EI  (MACHNM)				:
	SVC	OUT,GREET3		:
        L       R1,USER,,               :RESTORE R1
LOG12	SVC	OUT,SMSG		:"SLOT #: "
	SVC	IN,$A 60		:1 MINUTE TIMEOUT
	SVC	KIO,0			:NO RESPONSE IN THAT TIME, SO HANG HIM
	LHL	R3,TERCAR,R1		:CHECK TERMINAL TYPE
	JE	LOG13			:AUX CIRCUIT, SO USER MUST TYPE "SEMI-:R0N"
	NHI	R0,7F			:LOOK AT DIGIT TYPED
	AHI	R0,0FF-021		:MAP "!" INTO '0FF'
	CLHI	R0,0FF			:
	JE	LOG15			:IT MATCHES...USE KEY '0FF' FOR SYSTEM USAGE
	SHI	R0,0FF-021+046		:MATCH FAILED...TEST FOR "F"
	JGFS	LOG14			:RANGE CHECK
	AIS	R0,6			:
	JGFS	.+4			:
	AIS	R0,7			:
	AIS	R0,9			:
	JLFS	LOG14			:
LOG13	CLHI	R0,0FF			:SPECIAL TEST FOR KEY '0FF'...FOR SYSTEM
	JEFS	LOG15			:
	CLHI	R0,NPART		:RANGE CHECK AGAIN
	JLEFS	LOG15			:
LOG14	SVC	OUT,BSMSG		:"??"
	J	LOG12			:LET HIM TRY AGAIN
					:
:	....................................................................
:	WE HAVE A KEY SPECIFIED FOR THIS USER...TRY TO SWITCH TO NEW CONTEXT
:	....................................................................
					:
LOG15	SVC	KIO,6			:TRY TO TRANSFER
	SVC	KIO,0			::TRANSFER FAILED...NULL NAME LIST...JUST EXIT
	J	LOG16			:NO SLOT AVAILABLE WITH THAT KEY...JUST EXIT
	NOP	0			:INSUFFICIENT LICENCE FOR SLOT
	CLHI	R0,NPART		:CHECK IF SPECIAL KEY USAGE
	JLE	LOG12			:LET HIM TRY AGAIN IF NOT
	SVC	KIO,0			:ELSE HANG USER
LOG16	LH	R0,GODGUY+GGUSE,R6	:IS USER TIED TO A SLOT?
	JL	LOG12			:IF NOT, TRY AGAIN
	SVC	KIO,0			:ELSE HANG USER
					:
   IF	MXP
GREET0	SC	/"8D"8AMXP machine: /
   EI  (MXP)				:
GREET1	SC	/"8D"8Anode: /
GREET2	SC	/"8D"8Ahost: /
GREET3	SC	/"8D"8A/
SMSG	SC	/"8D"8Aslot #: /
BUMSG	SC	/"8D"8Anot a valid user on this system"8D"8A/
SLVDN	SC	/"8D"8Aslave is down"8D"8A/
BSMSG	SC	/"8D"8A??/
UNAME	HS	4			:ACCUMULATE USERNAME HERE

	SUBTTL	THE ISIS GOOD-GUY TABLE


GODGUY	HS	0			:THE GOOD GUY LIST...FORCE TO HW BOUNDARY
	GG(0,-1,*no one*)		:
	XGG				:ANY ADDITIONAL GOOD GUYS GO HERE
GGSIZE	EQ	.-GODGUY-GGLEN		:INDEX FOR LAST ENTRY
					:
	BND	100			:FORCE TO PAGE BOUNDARY
   IF	SHARE				:
	FO	SHARE			:
   EI  (SHARE)				:
	FO	KERNEL			:
					:
	EM				:End of DDT module
					:
	SUBTTL	DISP . . . I S I S   D I S P A T C H E R

: ************************************************************************
: **			  PROPRIETARY INFORMATION			**
: **									**
: **	This source code listing constitutes the proprietary property	**
: **	of McDonnell Douglas Corporation. The recipient, by receiving	**
: **	this program listing,  agrees that  neither this listing  nor	**
: **	the information disclosed herein  nor any part thereof  shall	**
: **	be reproduced  or transferred  to other documents  or used or	**
: **	disclosed  to others  for  manufacturing  or  for  any  other	**
: **	purpose  except  as  specifically authorized  in  writing  by	**
: **	McDonnell Douglas Corporation.					**
: ************************************************************************

:	The Dispatcher may initiate a machine Halt for a variety of reasons...
:	these are:

:	Display	Reason
:	BAD02 8765	GHI CRASH
:	BAD04 8764	WHI CRASH
:	BAD06 8765	WRE CRASH
:	BAD08 8765	EMPTY CRASH
:	BAD0C 8765	AAMAKP CRASH
:	BAD0E 8765	CHNERR CRASH
:	BAD10 8765	P.NERR CRASH
:	BAD0E 8720	Parity error within Dispatcher
:	BAD0E 8740	Illegal Instruction within Dispatcher
:	BAD0E 8750	Protection Violation within Dispatcher (shouldn't happen)
:	BAD0E 8753	Invalid Accounting Invoice-Number zero (0)
:	BAD0E 8760	Illegal SVC within Dispatcher

	MO	.,DISPAT
:	INTER-CONNECTION OF SLOTS

:	Slot 0 is always PRIMARY slot (usually TYMNET, but not necessarily)
:	ALL control, diagnostic, and accounting information is handled by
:	slot 0.

:	Most dispatcher operations involve a slot as source or destination
:	of message traffic--in ALL such cases, the following rules apply:

R15.s	EQ	R15			: R15 contains slot key of SOURCE!
R14.d	EQ	R14			: R14 contains slot key of DESTINATION!

:			(Slot Key = 4*Slot-number)

:	Each Active circuit is assigned a Channel -- each Channel consists of
:	a pair of Paths, which are assigned by even-odd pairs.  By convention,
:	the "even" path is called path 0, the "odd" path 1.  The pointer to
:	Path 0 then also happens to be the pointer to the channel.  By further
:	convention, path 0 is ALWAYS assigned to carry information in the same
:	direction that the Needle had (or would) travel...in particular, this
:	greatly simplifies Project-code collection.

:	Each slot has a half-word permuter table built in.

:	Each HW permuter-table entry specifies the state of that port.
:	The values (and states) may be:
:	0	port is available
:	P	port is active (P is path-number)
:	P+8000	port is in CLEANUP state (then P.HIST is timeout)
:	P+C000	port is in TIMEOUT state (waiting for orange-ball)

:	'P' is the Path-number of the Path assigned to the output for that port.

:	Each PATH is described by a Path-descriptor.  This has a byte Destin-
:	ation slot Key P.SLOT, and a Halfword P.PORT associated with it.  To
:	determine the destination of a message with port number P, look up
:		PATH = PERMUTER[P].
:	Then destination is PATH->P.PORT on slot PATH->P.SLOT.

:	Other Registers in regular use are:
:	(We give these special names to remind us of their dedicated usage)
R1.p	EQ	R1			: pointer for Path (GHI/WHI)
R3.c	EQ	R3			: pointer to Channel (Accounting)
R6.pt	EQ	R6			: pointer to Permuter-table
R7.PT.	EQ	R7			: contents of Permuter-table
R7.c	EQ	R7			: pointer to Channel (Accounting)
R8.Or	EQ	R8			: pointer to Output Ring
R9.Oc	EQ	R9			: Output-ring Cursor
R10.Om	EQ	R10			: Output-ring Maximum size
R11.Ir	EQ	R11			: pointer to Input Ring
R12.Ic	EQ	R12			: Input-ring Cursor
R13.Im	EQ	R13			: Input-ring Maximum size

:	Define Buffer Parameters
DBG.PA	EQ	1			: debugging paths
BFL.SZ	EQ	$A 16			: size of a bufferlet (Power of 2!)
NCHAN	EQ	(-10)&((NSLOT+1)/2+DI.CHN+11) : Actual number of Channels provided
NGRP	EQ	NCHAN/10		: number of Channel-groups (16d/group)
NPATH	EQ	2*NCHAN			: number of path-descriptors
	DEFAULT(DI.BFL,$A 48*NPATH/BFL.SZ) : Min no. of Bufferlets to allocate
	SUBTTL	DISPATCHER - Descriptors

:	Slot-tables -- these comprise Descriptors for ALL slots
:		Indexable by slot-Key ... first set referenced by DDT
S0KEY	EQ	0			: Key for Slot 0
I.HTBL	WS	NSLOT+1			: PTRS to Slot Host-number table
I.UTBL	WS	NSLOT+1			: PTRS to slot port-number table
I.PTBL	WS	NSLOT+1			: PTRS to slot Permuter table
I.HSIZ	WS	NSLOT+1			: Slot Maximum number of Hosts (HW)
I.PSIZ	 EQ	I.HSIZ+2		: Slot Maximum number of Ports (HW)
 if	DISPAT
I.CTL	WS	NSLOT+1			: Control bits for each Slot,  Negative = UP
I.IRNG	WS	NSLOT+1			: PTRS to Input-rings in Slot-order
I.ORNG	WS	NSLOT+1			: PTRS to Output-rings in Slot order
I.IBKB	WS	NSLOT+1			: PTR to Input Back-pressure bits
I.OBKB	WS	NSLOT+1			: PTR to Output Back-pressure bits
I.PCTB	WS	NSLOT+1			: PTR to Project-code Termination-bits
I.IRSZ	WS	NSLOT+1			: Slot Input-ring size (HW)
I.ORSZ	 EQ	I.IRSZ+2		: Slot Output-ring size (HW)
I.USING	HC	0			: Flags are set when Buffers were used
I.USED	HC	0			: other stuff
  re	NSLOT
	WC	0
  er
:I.CHRS	WS	NSLOT+1			: Ring-traffic for ?CPU Cmd (HW)
I.CHRS	WS	2*NSLOT+2		: Ring-traffic for ?CPU Cmd ***etm
  if	NETMON
:I.RATE	 EQ	I.CHRS+2		: keep rate of Port-zero Traffic (HW)
I.RATE	 EQ	I.CHRS+4		: keep rate of Port-zero Traffic ***etm
  ei
I.CMD0	WS	0			: number for Port0 Path (HW)
Q	EQ	0
  re	NSLOT+1
Q	EQ	Q+1
	HC	Q,0
  er
I.CPATH	WS	0			: Pointer for Port0 Path
Q	EQ	0
  re	NSLOT+1
Q	EQ	Q+P.LEN			: next path
	WC	C.POOL+Q		: pointer to this Path
  er
I.QUE	WS	NSLOT+1			: head of path-queue
					:  if non-zero, points at first path in
					:  a list which contains data buffered
					:  for this slot.


:	Define some Descriptors:
Q	HS	0			: remember where we are

:       Time-out List entry:
:       (We use bufferlets for these)
	ORG	0
T.NEXT	WS	1			: pointer to next entry (must be first)
T.ADDR	WS	1			: Activation (execution) address
T.TIME	WS	1			: Time of activation
T.INTV	WS	1			: Activation interval
T.LEN	HS	0			: length of entry

:		Host descriptor
:	(Preserve relationship of fields flagged with "/" and "\")
	ORG	0
H.SKEY	HS	1			: Slot Key (who owns host)
H.NO	HS	1			: \ Host number
H.NPT	HS	1			: / number of ports
H.RHX	HS	1			: relative host index
H.STAT	BS	1			: \ Status
					:	0 -	Answered
					:	1 -	Down
					:	2 -	Shut (but up)
					:	3 -	Gone
H.KEYL	BS	1			: / Host Key
H.IIX	BS	1			: \ IIX-state
H.PID	BS	1			: / Product-ID
H.COST	HS	1			: Host cost
H.NPTL	HS	1			: number of ports left
H.LEN	HS	1			: length of descriptor

:	Define a Path-descriptor...
:	(Duplicates definition in DEFS module, defined there so that Kernel
:	 can reference these elements)
: 00	P.NEXT	WS	1		: Linked-list forward-pointer (should be first)
: 04	P.LAST	WS	1		: Linked-list Backward-pointer
: 08	P.BB	WS	1		: buffer start-address
: 0C	P.BE	WS	1		: buffer end-address
: 10	P.BCT	HS	1		: buffer count
: 12	P.HIST	HS	1		: buffer history
: 14	P.STAT	BS	1		: Path-state
: 15	P.SLOT	BS	1		: Destination-Slot index
: 16	P.PORT	HS	1		: Destination-port
: 18	P.HOST	HS	1		: host associated with path
: 1A	P.NO	HS	1		: Path-number
: 1C	P.BIAS	HS	1		: byte-displacement to other path of pair
: 1E	P.ACNT	HS	3		: count (input/output) for this path
: 24	P.ACX	HS	3		: other accounting stuff
: 2a	p.unused hs	3		: unused pad to 30 ***etm
: 30	P.LEN	HS	0		: the length of a path-descriptor


:	define a Channel-Descriptor
:	This contains two paths (plus some other stuff...symetric around path):
	ORG	0
CPATH0	BS	P.LEN			: Path 0...circuit built in this direction
C.NEXT	EQ	CPATH0+P.unused		: Pointer to next free Channel***etm/pwk
c.used	eq	cpath0+P.unused+4	: flag for whether channel is free ***etm
C.AAIC	EQ	CPATH0+P.ACNT		: Input character-counts
C.AAPC	EQ	CPATH0+P.ACX		: project-code accumulator
C.WHY	EQ	C.AAPC			: reuse that for Reason for Disconnect
C.STAT	EQ	C.AAPC+4		: Channel state
CPATH1	BS	P.LEN			: Path 1...direction toward circuit origination
C.AAOC	EQ	CPATH1+P.ACNT		: Output Character-counts
C.INV	EQ	CPATH1+P.ACX		: Invoice number
C.LEN	HS	0			: the length of a Channel-descriptor
					:
	ORG	Q			: return to normal address-space
					:
:	..........................................................
:	Each Path has an Accounting-state associated with it (P.STAT)...
:	..........................................................
					:
PA.CPC	EQ	1			: Collect Project-code
PA.DHU	EQ	2			: Data Held up
PA.BBP	EQ	4			: Buffer Back-pressured
PA.CMD	EQ	8			: command-Path
PA.ILI	EQ	10			: in LOGIN
PA.LII	EQ	20			: in LOGII
					:
:	..........................................................
:	Each Channel also has an Accounting-state associated with it (C.STAT)...
:	..........................................................
					:
CA.PCO	EQ	1			: project-code open
CA.CTO	EQ	2			: Count-report open
CA.WHY	EQ	4			: set if Termination-reason recorded
CA.ORG	EQ	8			: Origination slot acct flag
					:

	SUBTTL	DISPATCHER - Macros

:	..........................................................
:	D E F I N E   S P E C I A L   M A C R O S
:	..........................................................

:	Macro to verify Path-number
:	Rs -	register which contains path-number
CHK.PN	MACRO(Rs) [
 if	DBG.PA
	CHI	Rs,NPATH
	JGE	PN.HLT
 ei	:DBG.PA
]

:	Macro to compute Path from Path-number
:	Rd -	register where we want the path-pointer (NOT R0!)
:	Rs -	register where the path-number is now
        if      0
CPFPN	MACRO(Rs,Rd) [ LHI Rd,P.LEN; MHR Rd,Rs; LA Rd,C.POOL,Rd ]
        ei
CPFPN	MACRO(Rs,Rd) [ lr rd,rs; ar rd,rd; ar rd,rs; slls rd,4; LA Rd,C.POOL,Rd ] :***etm

:	Macro to compute Channel-pointer from Path-pointer
:	Rd -	register where we want the Channel-pointer
:	Rs -	register where the path-pointer is now
CCFP	MACRO(Rs,Rd) [ LH Rd,P.BIAS,Rs; JLFS .+4; lis Rd,0; AR Rd,Rs ]

:	Macro to compute other Path of pair
:	Rd -	register where we want the other path-pointer
:	Rs -	register where the path-pointer is now
COPOP	MACRO(Rs,Rd) [
 if	Rs%Rd
	LR	Rd,Rs
 ei
	AH	Rd,P.BIAS,Rs
]

:	Macro to update rate of use on Command-channel
NETRAT	MACRO(VAL)[
  if	NETMON
	LIS	R4,VAL
:	AHM	R4,I.RATE,R15.s
	AM	R4,I.RATE,R15.s,R15.s	: ***etm/pwk
	JGE	MAIN1
  ei
]


:	Macro to Enable/Disable Dispatcher XHI Trace
  if	DI.TRC
DCHIST	MACRO [ J HIST ]		: Character History-trace
  else
DCHIST	MACRO [ JR R4 ]
  ei

:       Macro to generate a crash
D.CRSH  MACRO(Why,Rno) [ STM	R0,CRREG	: save ALL registers
	JAL	R10,DCRAS0
	BC	Why,4*Rno
]
	SUBTTL	DISPATCHER - Constants and Definitions

:	Define symbolic names for messages
NEDMSG	EQ	0			: Needle
DETMSG	EQ	9E			: Detach
ZAPMSG	EQ	9F			: Disconnect (Zap)
NOSMSG	EQ	0A0			: Apply Back-pressure (don't send)
SNDMSG	EQ	0A1			: Release Back-preasure (send again)
GOBMSG	EQ	0A2			: Flush circuit
DLBMSG	EQ	0A4			: Data-lost
YBMSG	EQ	0AC			: Yellow-ball
OBMSG	EQ	0AD			: Orange-ball
PNMSG	EQ	0B2			: Pseudoneedle
NLCMSG	EQ	0B3			: Normal Logon-char Message
LOKMSG	EQ	0B6			: Logon-OK Message
ACTMSG	EQ	0B7			: Addendum to Accounting
ZACMSG	EQ	0BB			: Zapper Acknowledgement
WHYMSG	EQ	0BE			: Zap Because (with reason)
  if	LOG.II				: LOG-II
ISNMSG	EQ	0C2			: LOG-II Isis_Needle
RCRIMG	EQ	0C3			: LOG-II RCRI
ICRSMG	EQ	0C4			: LOG-II ICRS
ASLPMG	EQ	0C5			: LOG-II ASLP
LGSCMG	EQ	0C6			: LOG-II LGSC
MAXMSG	EQ	0C6			: Highest Message defined
ICRMMG	EQ	011			: LOG-II ICRM message (port0)
ECRIMG	EQ	012			: LOG-II ECRI message (port0)

:	Also define some parameters for LOG-II

: the following are MO definitions:
MO.CAP	EQ	$A 1^17			: Application CLASS -- default = Universal
MO.FCO	EQ	$A 1^16			: Constructor FORM  -- default = Primative
MO.LGS	EQ	01!MO.CAP!MO.FCO	: LGSC
MO.IIX	EQ	03!MO.CAP		: IIX-capability
MO.DHO	EQ	0D!MO.CAP		: Destination host
MO.OHO	EQ	0E!MO.CAP		: Origination Host
MO.RMO	EQ	10!MO.FCO		: RMO
MO.OPT	EQ	1A!MO.CAP		: Origination Port
MO.FLA	EQ	1B!MO.CAP		: Flags
MO.ISN	EQ	1D!MO.CAP!MO.FCO	: ISN
MO.INV	EQ	26!MO.CAP		: Invoice
MO.SHU	EQ	2F!MO.CAP		: Shut Over-ride
MO.DIS	EQ	36!MO.CAP!MO.FCO	: Dispatcher

X4.VSZ	EQ	6			: value length (bytes) for X.409
LII.IX	EQ	80			: Incomplete flag
LII.SU	EQ	40			: Subsequent flag
LII.IN	EQ	01			: Internal-circuit flag
  else	:not LOG.II
MAXMSG	EQ	0C1			: Highest Message defined
  ei	:LOG.II

:	The following table is in normal-port Message-order...
:	It contains the "licences" for each message
:	Each valid message has at least one bit on...invalid messages contain 0:
M.V	EQ	80			: Valid message (if no others)
:	The first group of messages apply to active circuits:
M.D	EQ	1			: Data Message
M.S	EQ	2			: Special Message
M.ILI	EQ	4			: "In Login"...LOG-I
M.ILII	EQ	8			: "In Login"...LOG-II
:	The second group apply to "inactive" ports:
M.IAX	EQ	10			: special attention required
M.BLD	EQ	20			: Circuit-builder
M.LII	EQ	40			: LOG-II Variable length message

M.LIC	BC	M.S+M.IAX!M.BLD		: 00	Needle
  re	9D
	BC	M.D			: 01-9D	Data-text strings
  er
	BC	M.S!M.ILI!M.ILII+M.IAX	: 9E	Detach
	BC	M.S!M.ILI!M.ILII+M.IAX	: 9F	Disconnect
	BC	M.S!M.ILI!M.ILII	: A0	Apply Back-pressure
	BC	M.S!M.ILI!M.ILII	: A1	Release Back-pressure
	BC	M.S			: A2	Flush forward (Gobbler)
	BC	M.V			: A3	Flush Backward
	BC	M.V			: A4	Black Ball
	BC	M.V			: A5	Grey Ball
	BC	M.V			: A6	Enter "DEM"
	BC	M.V			: A7	Leave "DEM"
	BC	M.V			: A8	Enter "TRANSPARENCY"
	BC	M.V			: A9	Leave "TRANSPARENCY"
	BC	M.V			: AA	Green Ball
	BC	M.V			: AB	Red Ball
	BC	M.V			: AC	Yellow Ball
	BC	M.IAX			: AD	Orange Ball
	BC	M.V			: AE	"Break" begin
	BC	M.V			: AF	"Hang Up"
	BC	M.V			: B0	Query Terminal Parameter
	BC	M.V			: B1	Set Terminal Parameter
	BC	M.S+M.IAX!M.BLD		: B2	Pseudoneedle
	BC	M.S!M.ILI		: B3	LOGON Character
	BC	M.V			: B4	LOGON Status
	BC	M.V			: B5	LOGON Failure
	BC	M.S			: B6	Successful LOGON from this port
	BC	M.S+M.IAX		: B7	Addendum to ACCOUNTING
	BC	M.V			: B8	Super-"Hang Up"
	BC	M.ILI!M.ILII		: B9	Transmit Limit
	BC	M.V			: BA	"Break" end
	BC	M.S			: BB	ZAP Acknowledge
	BC	M.V			: BC	Enter 'Alternate mode'
	BC	M.V			: BD	Leave 'Alternate mode'
	BC	M.S!M.ILI!M.ILII+M.IAX	: BE	ZAP w/Reason
	BC	M.V			: BF	initiate IIX Exchange
	BC	M.V			: C0	Terminate IIX
	BC	M.V			: C1	UUN
  if	LOG.II				: LOG-II:
	BC	M.S+M.IAX!M.BLD		: C2	ISN
	BC	M.S+M.LII		: C3	RCRI
	BC	M.S!M.ILII+M.LII	: C4	ICRS
	BC	M.S+M.IAX!M.BLD		: C5	ASLP
	BC	M.S+M.LII		: C6	LGSC
  ei	:LOG.II
  re	M.LIC+100-.
	BC	0			: fill rest with 0...not valid
  er
	SUBTTL	DISPATCHER - CRASH HANDLING

:	* * * * * * * * * * * * * * * * * * * * * *
:	*					  *
:	*	C R A S H   H A N D L I N G       *
:	*					  *
:	* * * * * * * * * * * * * * * * * * * * * *

:	Crash conversion table...crash reasons in ISIS order
CRSHCV	BC	0,0			: Manual-Restart and Power-Fail
	BC	20			: Parity-Error
	BC	61			: Dispatcher-Crash (Must be KERNEL Crash)
	BC	40			: Illegal-Instruction
	BC	60			: Illegal-SVC
	BC	63			: System-Crash
	BC	50			: Protection-Violation

:	General Machine Failure
DFAIL	WS	2			: PSD saved here
	WS	2			: R0,R1 saved here
:	Enter here...
	CLHI	R1,2			: Check for Manual-restart or Power-failure
	JL	D.STRT			: Ignore these
	STM	R2,CRREG+8		: Save registers
	LM	R12,DFAIL		: PSD, rest of registers
	STM	R14,CRREG
	ST	R13,CPOINT		: save failure address
	ST	R12,CPOINT+4		: ...and PSW
	LCS	R0,1
	ST	R0,CFROM		: cancel where_called_from
	LB	R1,CRSHCV,R1		: Convert to standard Crash-code
	OHI	R1,0E00
	J	DCRAS1			:  and skip

:	Come here to CRASH
:	Code	Reason
:	02	GHI CRASH
:	04	WHI CRASH
:	06	WRE CRASH
:	08	EMPTY CRASH
:	0C	AAMAKP CRASH
DCRASH	STM	R0,CRREG		: save registers
DCRAS0	ST	R10,CPOINT		: save where we crashed From
	LB	R1,1,R10		: get 4*link-register
	L	R0,CRREG,R1		: get contents of Link-register
	ST	R0,CFROM		: save where called From
	LB	R1,0,R10		: get Crash sub-reason
	EXBR	R1,R1
	OHI	R1,65			: Crash reason
DCRAS1	STH	R1,CRASHC		: save Crash-code
	LIS	R0,1
	AHM	R0,CRSHCT		: count another crash
	LM	R0,CRREG		: recover Crash registers
	ST	R0,RSETS
	JAL	R0,HLT.S		: Crash machine
	 HC	0F
CRASHC	HC	0			: crash code
CPOINT	HC	0,0			: crash point (address)
	HC	0,0			: crash PSD (on FAIL)
CFROM	WC	-1			: where failed otherwise
CRSHCT	HC	0			: CRASH-count
CRREG	HS	20			: save registers here on CRASH


  if	DBG.PA
:	General place to crash from on detection of bad path-number
:	called via JAL R0,PN.HLT
PN.HLT	D.CRSH(10,R0)			: reason 10, called via R0
  ei	:DBG.PA
	SUBTTL	DISPATCHER - Start-up Code...Initialization

:	* * * * * * * * * * * * * * * * * * * * * *
:	*					  *
:	*	S T A R T - U P   C O D E         *
:	*					  *
:	* * * * * * * * * * * * * * * * * * * * * *

D.STRT	LA	R0,DFAIL		: Initialize -- Restart-address
	SVC	SYS,0
	 NOP				: Don't care about skip-return

:	Initialize bulk storage
	LIS	R0,0			: set up to save 0's
	LI	R1,ZEROSZ-2
IZBM	STH	R0,ZERO,R1		: zero a cell
	SIS	R1,2
	JGEBS	IZBM			: do for all elements

:	Create a block of free bufferlet-space beginning at BFLETS
	LI	R1,BLSIZE-4		: size of the storage
	LI	R2,3F3F3F3F		: put "?"'s in data-area
IZBFR1	ST	R2,BFLETS,R1,
	SIS	R1,4
	JGEBS	IZBFR1

:	Link bufferlets together
	LIS	R1,0			: last chain-pointer (NULL)
	LA	R2,BFLETS,,		: the current one
	LHI	R3,NBFLET		: how many to do
IZBFR2	ST	R1,0,R2			: store bufferlet forward link POINTER
	LR	R1,R2			: this becomes last
	AHI	R2,BFL.SZ		: this becomes next
	SIS	R3,1			: count another one done
	JGBS	IZBFR2
	ST	R1,FREBFL		: pointer to first bufferlet

:	Place the Path-number in ALL Path-descriptors
	LHI	R3,NPATH-1		: last path-number
	LA	R2,C.PEND-P.LEN,,	: POINTER to last element
IZBFR3	STH	R3,P.NO,R2		: set path-number
	SHI	R2,P.LEN		: next Path
	SIS	R3,1			: next path-number
	JGBS	IZBFR3

:	Organize the Channels into a linked list of Free-Channels
	LIS	R1,0			: current channel
	LHI	R3,NPATH-1		: last path-number
	LA	R2,(NCHAN-1)*C.LEN+C.POOL,, : POINTER to last element
IZBFR4	ST	R0,C.NEXT,R2		: set NEXT for Channel
	ts	c.used,r2		: flag as on free list
	LR	R0,R2			: THIS now becomes next NEXT
	SHI	R2,C.LEN		: next channel
	SIS	R3,2			: next path
	CLHI	R3,NSLOT+2		: do for all normal paths
	JG	IZBFR4
	ST	R0,C.FREE		: record first free channel

:	Initialize BF and P.SLOT for command-ports
	LIS	R0,PA.CMD		: Port0 Command-path flag
	LA	R2,(NSLOT+1)*P.LEN+C.POOL,, : Path-pointer
	LHI	R3,NSLOT*4		: Slot-Key
IZBFR5	STB	R0,P.STAT,R2		: Command-path State
	STB	R3,P.SLOT,R2		: Command-path Destination-key
	SHI	R2,P.LEN
	SIS	R3,4
	JGEBS	IZBFR5

	JAL	R0,IZT			: initialize timeouts

:	Send diagnostic to Slot 0
	LIS	R11,1			: HW2 = Diagnostic type = 1
	LHL	R12,CRASHC		: HW3 = Crash-code
	LHL	R13,CRSHCT		: HW4 = Crash-count
	JAL	R5,DIAG,,		: send it
	J	MAIN1
	SUBTTL	DISPATCHER - THE MAIN LOOP

:	* * * * * * * * * * * * * * * * * * * * * * * * * * * *
:	*						      *
:	*	D I S P A T C H E R   M A I N   L O O P       *
:	*						      *
:	* * * * * * * * * * * * * * * * * * * * * * * * * * * *

MAIN	L	R11.Ir,I.ORNG,R15.s	: get pointer to slot's output ring
	LHL	R12.Ic,CEI,R11.Ir	: get empty cursor
	SH	R12.Ic,CEIBGN		: How much flushed?
	JGEFS	MAIN0			: fold?
	AH	R12,I.ORSZ,R15.s	: fold it
:MAIN0	AHM	R12,I.CHRS+2,R15.s	: keep the total
MAIN0	AM	R12,I.CHRS+4,R15.s,R15.s: keep the total ***etm/pwk
  if	SPAM
   if	MXP
   else
	AM	R12,IOCHRS+0C,R15.s,R15.s : keep slot total for SPAM
	AM	R12,IOCHRS+4,,		: keep total of I/O chars through ISIS
   ei	:(MXP)
  ei	:(SPAM)
MAIN1	TS	DSLOT			: set last slot complete

:       <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
					:	Fast Dismiss
	SVC	FAST			:  so KERNEL can process
					:	another slot
:       >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	JAL	R0,TIMOUT		: process timeouts

:	Check Disconnection
	LH	R15.s,DSWCH		: check the switch
	JLFS	DCHK1			: not set...ignore this time
	JAL	R6,DCSLOT		: Disconnect the slot requested
	LIS	R0,0
	RBT	R0,I.CTL,R15.s		: now flag slot DOWN
	TS	DSWCH			: reset the Switch
DCHK1	LH	R15.s,DHANG		: should we hang someone for KERNEL?
	JLFS	DCHK2			: skip if not
	SLHLS	R15.s,2			: else make Slot-Key
	JAL	R6,DCSLOT		: go disconnect it
	LIS	R0,0
	RBT	R0,I.CTL,R15.s		: now flag slot DOWN
	TS	DHANG

DCHK2	LH	R15.s,DSLOT		: check the current slot
	JL	MAIN1			: if none, back to main loop
	SLHLS	R15.s,2			: make slot into working Slot-Key
	STH	R15.s,SORCX		: save index for current tables

:	Range-check Ring cursors
	LH	R0,I.CTL,R15.s		: check out slot
	JGE	MAIN1			: ignore if DOWN or not in use
	L	R1,I.IRNG,R15.s		: Input-ring
	L	R2,I.ORNG,R15.s		: Output-ring
	LHL	R3,I.IRSZ,R15.s		: Input-ring size
	LHL	R4,I.ORSZ,R15.s		: Output-ring size
	LHL	R0,NFMI,R1		: check
	CR	R0,R3
	jlfs	dchkz
	stm	r0,dspreg		: save register set F
	lhi	r5,0			: dispatcher error # 1
	j	gkill			: abort if error
:	JGE	GKILL			: abort if error
dchkz	LHL	R0,NFMI,R2
	CR	R0,R4
	jlfs	dchky
	stm	r0,dspreg		: save register set F
	lhi	r5,1			: dispatcher error # 2
	j	gkill			: crash slot
:	JGE	GKILL
dchky	LHL	R0,CEI,R1
	CR	R0,R3
	jlfs	dchkx
	stm	r0,dspreg		: save register set F
	lhi	r5,2			: dispatcher error # 3
	j	gkill			: crash slot
:	JGE	GKILL
dchkx	LR	R5,R0
	SH	R0,I.USED,R15.s		: check difference since last round
	JGEFS	DCHK3			: fold if necessary
	AR	R0,R3
DCHK3	AM	R0,I.CHRS,R15.s,R15.s	: keep a total ***etm/pwk
:DCHK3	AHM	R0,I.CHRS,R15.s		: keep a total
  if	SPAM
   if	MXP
   else
	AM	R0,IOCHRS+8,R15.s,R15.s	: keep slot-total of input chars for SPAM
	AM	R0,IOCHRS,,		: keep total of I/O chars through ISIS
   ei	:(MXP)
  ei	:(SPAM)
	STH	R5,I.USED,R15.s		: for next round
	LHL	R0,CEI,R2
	CR	R0,R4
	jlfs	dchkw
	stm	r0,dspreg		: save register set F
	lhi	r5,3			: dispatcher error # 4
	j	gkill			: Abort if any are out of range
:	JGE	GKILL			: Abort if any are out of range
dchkw	STH	R0,CEIBGN		: check this when done with session

  if	EE.BP				: support End-to-end Back-pressure

	SUBTTL	DISPATCHER - SERVICE BACKPRESSURE

	L	R13,I.IBKB,R15.s	: Back-pressure array for this slot
	JE	SBPXIT			: not defined, so don't do it
	L	R12,I.PTBL,R15.s	: locate Permuter-table start-address
	LHL	R11,I.PSIZ,R15.s	: get number of ports
	AR	R12,R11
	AR	R12,R11			: address of last Permuter-table entry
	AIS	R11,1			: needs a bias
SBP1	SIS	R11,1			: for next port...
	JL	SBPXIT			: exit when all ports surveyed
	SIS	R12,2			: current permuter-table entry-1
	LH	R0,2,R12		: look up path leaving slot(R15.s)
	JLEBS	SBP1			: ignore ports not in use
	CPFPN(R0,R1.p)			: compute pointer from path-number
	COPOP(R1.p,R2)			: get the Path coming toward slot(R15.s)
	LB	R0,P.STAT,R2		: get the state of the incoming path
	TBT	R11,0,R13		: check back-pressure being applied
	JE	SBP3			: ON...skip to test

:	Back-pressure is released
	NHI	R0,@PA.BBP		: turn off back-presssure
	CLB	R0,P.STAT,R2		:  ...and see if it changed
	JE	SBP1			: same...proceed to next port
	STB	R0,P.STAT,R2		: it changed...record new state
	LH	R0,P.BCT,R2		: check incoming path
	JN	SBP1			: it's not empty...we'll pass on
					:  Back-pressure later
	LH	R2,P.PORT,R1.p		: check Destination port
	JLE	SBP1			: Abort if not connected
	LB	R14.d,P.SLOT,R1.p	: Else locate Destination slot
	L	R4,I.OBKB,R14.d		: ...and it's Back-presure bit-array
	JEFS	SBP2			: Skip if none defined
	SBT	R2,0,R4			: else release back-pressure
SBP2	LIS	R2,4			: 3-byte message
	JAL	R4,CHECK
	LHI	R0,SNDMSG^8
	JAL	R4,SENDH		: allow data to flow
	JAL	R4,TERM
	J	SBP1			: and proceed

:	Back-pressure is applied
SBP3	OHI	R0,PA.BBP		: the bit's ON...record new state
	CLB	R0,P.STAT,R2		:  ...and see if it changed
	JN	SBP1			: already knew it...proceed to next port
	STB	R0,P.STAT,R2
	LH	R0,P.BCT,R2		: Check Path
	JN	SBP1			: it's not empty...we've already applied
					:  Back-pressure
	LH	R2,P.PORT,R1.p		: check destination-port
	JLE	SBP1			: abort if not connected
	LB	R14.d,P.SLOT,R1.p	: else locate destination slot
	L	R4,I.OBKB,R14.d		: and it's Back-pressure bit-array
	JEFS	SBP4			: skip if none defined
	RBT	R2,0,R4			: else set back-pressure
SBP4	LIS	R2,4			: 3-byte message
	JAL	R4,CHECK
	LHI	R0,NOSMSG^8
	JAL	R4,SENDH		: halt data-flow
	JAL	R4,TERM
	J	SBP1			: and proceed

SBPXIT	HS	0			: EXIT to here

  ei	:EE.BP
	SUBTTL	DISPATCHER - MOVE MESSAGES FROM COMMAND BUFFER TO RING

:	Message format -- HW count, followed by Port-number and rest of string
:	We try to empty the control buffer...the ONLY reason we'll quit is if
:	the ring won't hold the next buffered message!
MMCBR	hs	0			:***etm
:	LHL	R15.s,SORCX		: get source-index
:	LH	R6,I.CTL,R15.s		: check slot-state
:	JGE	MAIN1			: quit if not in use
	LR	R14.d,R15.s		: process messages stored for this slot
	L	R1.p,I.CPATH,R14.d	: get pointer to command-path
MMCBR1	LHL	R0,P.BCT,R1.p		: check Path
	JE	MMCBR3			: quit if empty
	L	R2,P.BB,R1.p		: look at size-HW
	LH	R13,0,R2
	JAL	R3,SPACE		: how much room is in ring?
	SR	R0,R13
	JLFS	MMCBR3			: no room...abort
	JAL	R4,GHI			: room exists...toss size-HW

MMCBR2	JAL	R4,GHI			: move a HW
	JAL	R4,PUTH
	SIS	R13,2
	JGBS	MMCBR2			: repeat for all HWs
	JAL	R4,ELOR			: End-Logical-Output-Record
	J	MMCBR1			: and go move another
					:
MMCBR3	HS	0			: EXIT to here
					:
	SUBTTL	DISPATCHER - Flush User Paths

:	.......................................................................
:	Move one message from each non-empty user-Path (in queue) to dest.
:	ring (if there is Room in the ring...)
:	Each Message contains HW Length, followed by that many BYTES of data
:	(may have a pad-byte to fill out to integral number of HWs).
:	Message-data contains Port-number and Type-byte, as well as contents.
:	.......................................................................
					:
MMBR	L	R1.p,I.QUE,R14.d	: check to see if paths on queue
	JE	MMBRX			:
MMBR1	L	R0,P.NEXT,R1.p		: record pointer to next entry
	ST	R0,TEMP			:
	LB	R0,P.STAT,R1.p		: check this path
	THI	R0,PA.CMD!PA.DHU	: Command-path or Data Held Up?
	JN	MMBR5			: ignor these
	LH	R0,P.PORT,R1.p		: OK...get port# of Destination
	JGEFS	MMBR2			: not negative port...skip
	JAL	R4,EMPTY		: <0...just thrash messages
	J	MMBR5			: and abort
					:
MMBR2	JAL	R3,SPACE		: how much room is there?
	L	R2,P.BB,R1.p		:
	LH	R11,0,R2		: examine leading-HW in Path (message-size)
	SR	R0,R11			: check that message will fit into ring
	sis	r0,4			: allow for roundup and port too ***ern
	JLE	MMBR5			: not this time...try again
	JAL	R4,GHI			: strip size off message in buffer
	lh	r0,p.port,r1.p		: get port# of Destination  ***ern
	jal	r4,puth			:
MMBR3	JAL	R4,GHI			: move a HW
	JAL	R4,PUTH			:
	SIS	R11,2			:
	JGBS	MMBR3			: do for all HWs
	JAL	R4,ELOR			: End-Logical-Output-Record
	LHL	R0,P.BCT,R1.p		: have we emptied the Path?
	JN	MMBR5			: not yet
	LB	R0,P.STAT,R1.p		: it's now empty...check state
	THI	R0,PA.BBP		: is back-pressure applied?
	JN	MMBR5			: yes...continue
	COPOP(R1.p,R1.p)		: no...compute other Path of pair
	LB	R14.d,P.SLOT,R1.p	:
  if	EE.BP				: support End-to-end Back-pressure
	L	R4,I.OBKB,R14.d		:
	JEFS	MMBR4			:
	LH	R2,P.PORT,R1.p		:
	JLFS	MMBR4			:
	SBT	R2,0,R4			:
MMBR4
  ei	:EE.BP
	LIS	R2,4			: 3-byte message
	JAL	R4,CHECK		: Transmit Back-pressure Release
	LHI	R0,SNDMSG^8
	JAL	R4,SENDH		: Release Back-pressure
	JAL	R4,TERM			: Terminate message
	LHL	R14.d,SORCX		: restore Source-index

MMBR5	L	R1.p,TEMP		: Done...check if there is another
	JN	MMBR1			: yes...go service it
					:
MMBRX	HS	0			: exit to here

	SUBTTL	DISPATCHER - ZAP BUFFERS TO RECOVER STORAGE

:	.......................................................................
:	We have (hopefully) been able to flush some Paths into their rings...
:	See if we must ZAP Paths because Bufferlet-storage running low
:	.......................................................................
					:
BZAP	L	R1,RTANK		: are we on the Reserve-tank?
	JG	BZAP7			: Plenty of buffer-storage.  Don't ZAP Paths
	LIS	R0,1			: DWCI has used reserve-tank, we must refill it
	AHM	R0,REBC1		: ...With 1/8 of buf'lets, ZAPping if needed
BZAP1	L	R2,FREBFL		: initial pointer is to start of free-list
	LHI	R1,NBFLET/8		: scan main Free-list for 1/8 free storage
BZAP2	L	R2,0,R2			: get next bufferlet on Free-list
	JEFS	BZAP3			: not enough spare space...ZAP a Path
	SIS	R1,1			: get another...count it
	JGBS	BZAP2			: go until we've got enough
	L	R3,FREBFL		: Done...seperate Free-list into two parts
	ST	R3,RTANK		: beginning of the Reserve-list
	L	R4,0,R2			:
	ST	R4,FREBFL		: new beginning of main list
	ST	R1,0,R2			: flag end of Reserve-list (=0)
	J	BZAP7			: and then quit
					:
:	.......................................................................
:	ZAP a Path in order to get Reserve-tank up to 1/8 of total buffer-storage
:	.......................................................................
					:
BZAP3	LA	R1.p,C.PEND-P.LEN,,	: pointer to last path
	LIS	R13,0			:
BZAP4	LHL	R0,P.BCT,R1.p		: get size for this Path
	CR	R13,R0			:
	JGEFS	BZAP5			: skip if this is not biggest yet
	LR	R13,R0			: else save new size
	LR	R12,R1.p		:  ...and buffer-index
BZAP5	SHI	R1.p,P.LEN		: repeat for all Paths
	LH	R0,P.NO,R1.p		:
	JGBS	BZAP4			:
	LIS	R0,1			:
	AHM	R0,REBC2		:
	STH	R12,BFZ			: statistics
	LR	R1.p,R12		:
	JAL	R4,EMPTY		: retrieve storage
	LB	R0,P.STAT,R1.p		: test if one of our internal Paths
	THI	R0,PA.CMD		:
	JNFS	BZAP6			: skip...System Path
	LB	R14.d,P.SLOT,R1.p	: get slot-index
	LIS	R2,4			: 3-char Message
	JAL	R4,GOBUF		: put into buffers unconditionally
	LHI	R0,DLBMSG^8		:
	JAL	R4,SENDH		: BLACK BALL
	JAL	R4,TERM			: Terminate message
BZAP6	LIS	R0,0			: flag history-keeper
	SH	R0,P.HIST,R12		:
	STH	R0,P.HIST,R12		: sign negative shows buffer-ZAP
					:
:	.......................................................................
:	sends to sup:	DATA1	Path-number
:			DATA2	Number of Characters Zapped
:	.......................................................................
					:
	LIS	R11,0			: Diagnostic-type = 0
	LHL	R12,P.NO,R12		: Path-number in DATA1
	JAL	R5,DIAG,,		: send Diagnostic
	J	BZAP1			: try again to fill Reserve storage-list
					:
BZAP7	HS	0			: EXIT to here

	SUBTTL	DISPATCHER - FLUSH SLOT'S RING

:	.......................................................................
:	Move a message from the current ring
:	Registers:
:	R5	2*port#
:	R6.pt	PTABLE Base-address
:	R7.PT.	Contents of permuter-table
:	R8-R10	Destination-ring Descriptor
:	R11-R13	Source-ring Descriptor
:	R14.d	Destination-slot Key
:	R15.s	Source-slot Key
:	.......................................................................
					:
MMFR	hs	0			:***etm
	LH	R15.s,SORCX		: for the current slot...
	JL	MAIN			: if negative, abort this Dispatcher Session
:	LH	R0,I.CTL,R15.s		: for this slot, test source-pointer
:	JGE	MAIN			: ignore if not in use
	:
	:	in-line the call to look ***etm
	:
	LHL	R13.Im,I.ORSZ,R15.s	: get Max index
	L	R11.Ir,I.ORNG,R15.s	: get pointer to slot's output-ring (our input)
	LHL	R12.Ic,CEI,R11.Ir	: get Current Empty Index cursor
mmfr0	CLH	R12.Ic,NFMI,R11.Ir	: test if caught up
	jnfs	mmfr01
	JE	main			: empty... return
mmfr01	AIS	R12.Ic,2		: bump cursor past port-number
	LB	R2,RING,R11.Ir,R12.Ic	: get message-type
	LHL	R1,RING-2,R11.Ir,R12.Ic	:  and port-number (set CC)
	if	ee.bp
	STH	R1,SORPOR		: save a copy of the port-number
	ei
:	JAL	R4,LOOK			: is there anything there?
:	 JFS	MMFR1			: YES
:	J	MAIN			: no...ignore this time

:	Got another message...condition codes reflect port = 0
MMFR1	JE	GNOME			: Communications if Port0
	CLH	R1,I.PSIZ,R15.s		: Range-check on Port-number specified
	jlefs	mmfraz			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,4			: dispatcher error # 5
	j	gkill			: crash slot
:	JG	GKILL
mmfraz	LB	R4,M.LIC,R2		: get message-licence...check if valid
	jnfs	mmfray			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,5			: dispatcher error # 6
	j	gkill			: crash slot
:	JE	GKILL			: BOMB this slot if the message is garbage
mmfray	LR	R5,R1			: all OK...copy port-number
	AR	R5,R5			: make index to Permuter-table
	L	R6.pt,I.PTBL,R15.s	: locate this slot's Permuter-table
	LH	R7.PT.,0,R5,R6.pt	:  and contents
	JG	MMFR20			: Skip if in use



:	Port not in use...Check for New-circuits, Cleanup, Reuse
	THI	R4,M.IAX		: have we any possible interest in this message?
	JE	MMFR11			: no...just go thrash the message
	THI	R4,M.BLD		: circuit-builder?
	JEFS	MMFR2			: no

:	This is a circuit-building message
	LR	R2,R2			: is it a Needle?
	JE	NEEDLE			: Connect Message...Process it
	CLHI	R2,PNMSG		: no...Pseudoneedle?
	JE	PNEED			: yes
  if	LOG.II
	CLHI	R2,ISNMSG		: no...ISN?
	JE	MSGISN			: yes
	J	ASLP			: no...must be ASLP
  ei	:LOG.II

:	Not circuit-builder
MMFR2	CHI	R2,ZAPMSG		: look for Zappers
	JEFS	MMFR3
	CHI	R2,DETMSG		: or for Disconnect
	JEFS	MMFR3
	CHI	R2,WHYMSG		: or ZAP W/Reason
	JN	MMFR7

:	ZAP or Disconnect
MMFR3	LIS	R0,0
	STH	R0,0,R5,R6.pt		: Kill Permuter-table Entry
	JAL	R4,ELIR			: End-Logical-Input-Record
	LHI	R0,X.ZAC.		: test if slot wants ACK back
	NH	R0,I.CTL+2,R15.s
	JEFS	MMFR4
	LR	R14.d,R15.s		: yes...ACK it
	JAL	R4,SPEED		: speed message
	LHI	R0,ZACMSG^8		:
	JAL	R4,SENDH		:
	JAL	R4,TERM			: and terminate it
MMFR4	LR	R5,R7.PT.		:
	JE	MMFR			: no more to do if idle port
	NHI	R7.PT.,3FFF		: extract Path-number
	CPFPN(R7.PT.,R1.p)		: convert to path-pointer
	LB	R0,P.STAT,R1.p		: check state
:	JEFS	MMFR5			: all done
	LIS	R0,$2 01		: else terminate Accounting
	NH	R0,P.NO,R1.p		: 01 if odd (came from Dest)
	AIS	R0,$2 10		: ==> 2 if Host zap, 3 if User zap
	JAL	R4,AATERM		: (remember, Zapper "bounced")
MMFR5	JAL	R4,RELS.C		: release channel now
	J	MMFR			:
					:
:	.................................................................
:	Neither Connect nor Disconnect...What state is port in?
:	.................................................................
					:
MMFR7	LR	R7.PT.,R7.PT.		: is port in TIMEOUT or CLEANUP?
	JE	MMFR11			: no...skip
					:
:	Port in TIMEOUT or CLEANUP...Special tests
					:
	NHI	R7.PT.,7FFF		: Yes...strip off High-bit
	THI	R7.PT.,4000		: test for TIMEOUT-state
	JNFS	MMFR8			: skip test if so
	CLHI	R2,ACTMSG		: CLEANUP may be Accounting Addendum
	JN	MMFR11			: toss all others
	CPFPN(R7.PT.,R1.p)		: accounting...compute path
	J	MSGB7			: and enter Accounting Message Processing
					:
MMFR8	CHI	R2,OBMSG		: Check for Orange-ball
	JN	MMFR11			: toss all others
	JAL	R4,ELIR			: End-Logical-Input-Record (frees R11-R13)
	AR	R6.pt,R5		: make ABSOLUTE pointer to permuter-table
	NHI	R7.PT.,3FFF		: leave just Path-number
	LR	R11,R1			: preserve port number
	CPFPN(R7.PT.,R1.p)		: compute path-pointer
	LIS	R0,X.PNR.		:
	NH	R0,I.CTL+2,R15.s	: see if Ports-not-reusable
	JNFS	MMFR9			: Skip if so
	JAL	R4,RELS.C		: Release Channel
	LIS	R7,0			: change to INACTIVE state
	JFS	MMFR10			:
					:
:	port not reusable...set CLEANUP state
					:
MMFR9	JAL	R5,DCTBOP		: empty and disconnect buffer
	OHI	R7.PT.,8000		: Change to CLEANUP-state
MMFR10	STH	R7,0,R6.pt		: new Permuter-table entry
	LR	R14.d,R15.s		: copy pointers for output
	LR	R1,R11			: and port number
	JAL	R5,ZAPEM		: send back a Zapper
	J	MMFR			:
					:
:	Thrash Message
					:
MMFR11	THI	R4,M.LII		: LOG-II variable-length message?
	JNFS	MMFR12			: yes...skip to get length
	LB	R0,LENGTH,R2		: no...find Message-size
	JFS	MMFR13			: and skip to flush message

MMFR12	JAL	R4,GETH			: LOG-II variable length...toss type
	JAL	R4,GETH			: get length remaining

MMFR13	JAL	R4,FLUSH		: Flush the message
	J	MMFR			: and go back and try again
:	We have a Message on an Active "Normal" port and need to move it
:	R1 =	Port-number
:	R2 =	type,
:	R4 =	message licence,
:	R5 =	Port-number*2
:	R6.pt =	Permuter-table base-address
:	R7.PT.=	Path-pointer
MMFR20	CPFPN(R7.PT.,R1.p)		: compute Path-pointer from Path-number
	ST	R1.p,CURPAT		: save current path-pointer
	LB	R3,P.STAT,R1.p		: check status
	THI	R3,PA.ILI		: in log-in?
	JEFS	MMFR22			: skip if not
	LIS	R0,M.ILI		: assume LOG1
	THI	R3,PA.LII		: See if circuit in LOGII-state
	JEFS	MMFR21			: skip if not
	LIS	R0,M.ILII		: require LOG2
MMFR21	NR	R0,R4			: see if this message is valid
	jnfs	mmfr22			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,6			: dispatcher error # 7
	j	gkill			: crash slot
:	JE	GKILL			: Trash slot if not

MMFR22	THI	R4,M.S			: is this a special message?
	JN	MMFRS			: yes...go handle individually
	THI	R4,M.D			: is it a Text_Data Message?
	JE	MMFR30			: skip if not
	THI	R3,PA.CPC		: yes...check if to collect Project code
	JEFS	MMFR24			: skip if NOT Project_Code-state

:	We have to accumulate the Project-code
	JAL	R4,GETCH		: get and skip Message-type
	LR	R6,R0			: copy message-type (also = Length)

:	Now copy chars from Ring to Accounting
:	(Accounting done by AARDPI)
MMFR23	JAL	R4,GETCH		: get another data-character
	JAL	R5,AARPDI		: pass to Accounting
	SIS	R6,1			: count it
	JGBS	MMFR23			: do for all data-characters
	JAL	R4,LOOK			: rescan message for forwarding
	L	R1.p,CURPAT		: restore path-pointer
	JFS	MMFR30			: skip to forward it

MMFR24	AHM	R2,P.ACNT+4,R1.p	: count the traffic
	JNCFS	MMFR30
	LIS	R0,1			: we have to propogate overflow
	AM	R0,P.ACNT,R1.p


:	This message is definitely to be moved
MMFR30	LB	R14.d,P.SLOT,R1.p	: locate destination slot
	LHL	R0,P.BCT,R1.p		: is anything already in buffer?
	JN	MMFR40			: yes...add this message to it
	LB	R0,P.STAT,R1.p		: check state
	THI	R0,PA.DHU		: Holding up?
	JN	MMFR40			: yes
	:
	:	in-line call to space ***etm
:	LCS	R0,4
	L	R8.Or,I.IRNG,R14.d	: set up pointers (Slot-input is our Output)
	LHL	R9.Oc,NFMI,R8.Or
	LHL	R10.Om,I.IRSZ,R14.d
:	NH	R0,CEI,R8.Or		: force Emptier to Word boundary
	LH	R0,CEI,R8.Or		
	SR	R0,R9.Oc		: space between us and Emptier
	JGFS	mmfr31			: skip if no wrap-around
	AR	R0,R10.Om		: else correct for wrap, possible Empty-state
mmfr31	SIS	R0,4			: allow for potential overflow
:	JAL	R3,SPACE		: no...is there room there?
	LB	R3,LENGTH,R2		: length of message
	SHI	R0,2,R3			: allow for port-number
	JLFS	MMFR32			: no room...Back-pressure Origin and Buffer it
	LR	R0,R3			: we can move it directly!
:	LA	R4,MMFR			: fake a JAL,R4 to exit properly
	LA	R4,MMFR0		: fake a JAL,R4 to exit properly ***etm
	LH	R1,P.PORT,R1.p		: get destination-port
	JGE	MOVRNG			: else go move from Ring to Ring
	J	FLUSH			: Negative...just flush message...no Dest!


:	Message must go into buffer.....

:	Apply Back-pressure
MMFR32	TS	I.USING,R14.d		: flag slot for full Input-ring
	COPOP(R1.p,R1.p)		: Compute other path of pair
	LB	R4,P.STAT,R1.p		: check path-state
	THI	R4,PA.BBP		: path already back-pressured?
	JN	MMFR34			: skip if already applied
	LR	R14.d,R15.s		: and send back to origination
  if	EE.BP				: end-to-end Back-pressure
	L	R4,I.OBKB,R14.d		: Back-pressure Source directly
	JEFS	MMFR33			: ...if Bit-array is defined
	LH	R2,P.PORT,R1.p		: Source Port-number
	JLFS	MMFR33			: no Destination...Ignore
	RBT	R2,0,R4			: Apply it
MMFR33
  ei	:EE.BP
	LIS	R2,4			: 3-byte message
	JAL	R4,CHECK
	LHI	R0,NOSMSG^8		: Back-pressure this port
	JAL	R4,SENDH		: send it back to source
	JAL	R4,TERM			: terminate message
	JAL	R4,LOOK			: restore Parameters
MMFR34	L	R1.p,CURPAT		: restore forward path-pointer
	LB	R14.d,P.SLOT,R1.p	:  ...and destination slot

:	Move the data into the buffer
MMFR40	LB	R5,LENGTH,R2		: copy Message-length
:	LHI	R0,2,R5			: actual length
	lr	r0,r5			: ***ern
	JAL	R4,WHI			: put HW length into buffer
:	LHL	R0,P.PORT,R1.p		: get port-number
:	JAL	R4,WHI			: put it into buffer too

:	Now copy chars from Ring to Buffer
MMFR41	JAL	R4,GETH			: get another HW
	JAL	R4,WHI
	SIS	R5,2			: count it
	JGBS	MMFR41			: do for all characters
	LHL	R0,P.BCT,R1.p		: keep History
	CLH	R0,P.HIST,R1.p
:	JLEFS	MMFR42			: skip if not worst case
	jnc	mmfr42			: 64k bufferlet data ***ern
	STH	R0,P.HIST,R1.p		: record largest Buffer-usage for session

:	Finally, close the input
MMFR42	JAL	R4,ELIR			: End-Logical-Input-Record
	lh	r15.s,sorcx		: do we continue this session? 
					: going on the buffer reserve tank
					: will set sorcx to -1.
	jge	mmfr0			: yes ***etm 8/31/88
	j	main			:no,  back up to the top.
:	j	mmfr0			: ***etm
:	J	MMFR			: and repeat
	SUBTTL	DISPATCHER - MESSAGES REQUIRING SPECIAL HANDLING

:	We have special processing to do on these message-types
:	which are valid ONLY on ACTIVE circuits.  Some may come
:	here which are ILLEGAL (if not in list)...these we KILL!
:	Those we perform, we enter with:
:	R1.p	- Path-pointer
:	R2	- Message-type
:	R5	- 2 * port#
:	R6.pt	- Base of permuter-table
:	R7.PT.	- contents of permuter-table
MMFRS	LHI	R4,NMMFRS		: Search table
MMFRS1	CLB	R2,MMFRST,R4
	JNFS	MMFRS2			: not a match
	L	R4,MMFRST,R4		: got a match...fetch address
	LB	R14.d,P.SLOT,R1.p	: Look up destination
	JR	R4			: and go there

MMFRS2	SIS	R4,4			: Keep Scanning
	JGEBS	MMFRS1
	stm	r0,dspreg		: save register set F
	lhi	r5,7			: dispatcher error # 8
	J	GKILL			: can't find it...unrecognizable...KILL him

:	Table of special Messages, Handlers
:	(These are searched in DESCENDING order,
:	 ...so most common should be at END)
MMFRST	WC	(ZACMSG^18)!MMFR11	: ZAP ACK...toss it
	WC	(DETMSG^18)!MSG9F	: Detach
	WC	(ZAPMSG^18)!MSG9F	: Disconnect (ZAPper)
	WC	(WHYMSG^18)!MSGBE	: ZAP w/Reason
  if	LOG.II				: LOG-II
	WC	(ISNMSG^18)!MSGISN	: ISN
	WC	(RCRIMG^18)!MSGC3	: RCRI
	WC	(ICRSMG^18)!MSGC4	: ICRS
	WC	(LGSCMG^18)!MSGC6	: LGSC
  ei	:LOG.II
	WC	(LOKMSG^18)!MSGB6	: Soccessful LOGON
	WC	(NLCMSG^18)!MSGB3	: Normal Logon-character
	WC	(ACTMSG^18)!MSGB7	: Accounting Addendum
	WC	(GOBMSG^18)!MSGA2	: Flush Circuit
	WC	(NOSMSG^18)!MSGA0	: Back-pressure applied
	WC	(SNDMSG^18)!MSGA1	: Back-pressure released
NMMFRS	EQ	.-MMFRST-4
:	SPECIAL MESSAGE:	Back-pressure Applied
:	format:		--------.-------.--------
:			|     port	|   A0	|
:			-------------------------
MSGA0	JAL	R4,ELIR			: flush the message
	COPOP(R1.p,R3)			: locate other path of pair
  if	EE.BP				: end-to-end Back-pressure
	L	R4,I.IBKB,R15.s		: set up slot-applied Back-pressure
	JEFS	MSGA0A			: skip if not used
	LHL	R0,SORPOR		: get source port-number
	RBT	R0,0,R4
MSGA0A
  ei	:EE.BP
	LB	R4,P.STAT,R3		: check path-state
	THI	R4,PA.BBP		: already back-pressured?
	JN	MMFR			: already ON...ignore it
	OHI	R4,PA.BBP		: set it on, record it
	STB	R4,P.STAT,R3
	LHL	R3,P.BCT,R3		: have we applied it?
	JN	MMFR			: yes...ignore it
  if	EE.BP				: end-to-end Back-pressure
	L	R4,I.OBKB,R14.d		: no...locate Dest. Input Back-pressure bits
	JEFS	MSGA0B			: proceed if none
	LH	R0,P.PORT,R1.p		: else locate Destination-port
	JLFS	MSGA0B			: don't bother if not assigned
	RBT	R0,0,R4			: and pass bits along
MSGA0B
  ei	:EE.BP
	LIS	R2,4			: send 4-byte message
	JAL	R4,CHECK		: forward it directly (since we
	LHI	R0,0A0^8		:  just SET back-pressure)
	JAL	R4,SENDH		: A0 | pad
	JAL	R4,TERM			:
	J	MMFR			: done
					:

:	.......................................................................
:	SPECIAL MESSAGE:	Back-pressure released
:	format:		--------.-------.--------
:			|     port	|   A1	|
:			-------------------------
:	.......................................................................
					:
MSGA1	COPOP(R1.p,R3)			: compute other path of pair
  if	EE.BP				: end-to-end Back-pressure
	L	R4,I.IBKB,R15.s		: Locate source's Back-pressure array
	JEFS	MSGA1A			: skip if none
	LHL	R0,SORPOR		: else get source-port
	SBT	R0,0,R4			: remove Back-pressure
MSGA1A
  ei	:EE.BP
	LB	R4,P.STAT,R3		: check path-state
	THI	R4,PA.BBP		: is it on?
	JE	MMFR42			: already OFF...ignore it
	NHI	R4,@PA.BBP
	STB	R4,P.STAT,R3		: turn it off and record it
	LHL	R4,P.BCT,R3		: should we wait to send it on?
	JN	MMFR42			: yes...ignore it
  if	EE.BP				: end-to-end Back-pressure
	L	R4,I.OBKB,R14.d		: no...locate Dest. Back-pressure bits
	JEFS	MSGA1B			: proceed if none
	LH	R3,P.PORT,R1.p		: else locate Dest. port
	JLFS	MSGA1B			: don't bother if not assigned
	SBT	R3,0,R4			: and release back-pressure
MSGA1B
  ei	:EE.BP
	J	MMFR30			: and send it

					:
:	.......................................................................
:	Special Message:	Flush circuit
:	format:		--------.-------.--------
:			|     port	|   A2	|
:			-------------------------
:	.......................................................................
					:
MSGA2	LR	R5,R2			:
	JAL	R4,EMPTY		: empty Path
	LR	R2,R5			:
	J	MMFR30			: and go forward it
					:

:	.......................................................................
:	SPECIAL MESSAGE:	Accounting Addendum
:	Format:		--------.-------.-------.--------
:			|     port	|   B7	|unused	|
:			|-------.-------+-------+-------|
:			|	 Accounting word	|
:			---------------------------------
:	.......................................................................
					:
MSGB7	LR	R15.s,R15.s		: should NEVER get this from slot 0
	jnfs	msgb7z			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,8			: dispatcher error # 9
	j	gkill			: crash slot
:	JE	GKILL			:
msgb7z	JAL	R4,GETH			: yes...skip next pair of bytes
	JAL	R4,GETW			: get the word of data
	JAL	R4,ELIR			: End-Logical-Input-Record
	JAL	R4,AAMSG		: let accounting handle message
	J	MMFR			: then go look for another message
					:

:	.......................................................................
:	SPECIAL MESSAGE:	Log-in character
:	format:		--------.-------.-------.--------
:			|     port	|   B3	| char	|
:			---------------------------------
:	.......................................................................
					:
MSGB3	LB	R4,P.STAT,R1.p		: See if circuit in LOGIN-state
	THI	R4,PA.ILI		:
	JN	MMFR30			: continue if so
	stm	r0,dspreg		: save register set F
	lhi	r5,9			: dispatcher error # 10
	J	GKILL			: Trash slot if not
					:
:	.......................................................................
:	SPECIAL MESSAGE:	Successful Logon
:	format:		--------.-------.-------.--------
:			|     port	|   B6	|I H_typ|
:			|-------.-------+-------+-------|
:			|	 INVOICE NUMBER		|
:			|-------+-------+-------+-------|
:			|  Orig. Host	|  Extra I.N.	|
:			---------------------------------
:	.......................................................................
					:
MSGB6	LR	R15.s,R15.s		: should get these ONLY from slot 0
	jefs	msgb6z			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 10		: dispatcher error # 11
	j	gkill			: crash slot
:	JN	GKILL			:
msgb6z	JAL	R4,GETH			:
	COPOP(R1.p,R7)			: compute other-going Path
	LB	R4,P.STAT,R7		: indicate no longer in LOGIN state
	NHI	R4,@PA.ILI		:
	THI	R0,80			: check for internal
	JEFS	MSGB6A			: normal...skip
	NHI	R0,@080			: remove set-bit
	OHI	R4,PA.DHU		: set that state too
MSGB6A	STB	R4,P.STAT,R7		: save new status
	LIS	R4,CA.ORG		: setup acct. flag for origination
	OH	R4,C.STAT,R7		: update acct. state
	STH	R4,C.STAT,R7		: store back acct. information
	LR	R6,R0			: save TYPE | DEST. HOST Type
	JAL	R4,GETW			: get INVOICE NUMBER
	ST	R0,LO.INV+2		: save it
	JAL	R4,GETW			: get ORIG. HOST | Extra I.N.
	STH	R0,LO.INV		: save Extra IN
	LR	R5,R0			:
	JAL	R4,ELIR			: End-Logical-Input-Record
	LIS	R2,$A 12		: Insure there's room
	JAL	R4,CHECK		: check for space
	LR	R0,R6			: get TYPE | HOST TYPE
	JAL	R4,SENDH		: send on message
	L	R0,LO.INV+2		: include INVOICE NUMBER
	JAL	R4,SENDW		:
	LR	R0,R5			: ORIG. HOST | Extra I.N.
	JAL	R4,SENDW		:
	JAL	R4,TERM			:
	LR	R1.p,R7			: set Other (=Path0 / Channel)
	JAL	R4,AASINV		: Set up Accounting
	J	MMFR			:

:	.......................................................................
:	SPECIAL MESSAGE:	ZAP with reason
:	format:		--------.-------.----------------
:			|     port	|   BE	|reason |
:			---------------------------------
:	.......................................................................
					:
MSGBE	JAL	R4,GETH			: get msg | reason
	LHI	R7,9F^8			: forward a Zapper
	LBR	R0,R0			: extract reason
	JN	MSG9FB			: non-zero...reason for termination
	LR	R14.d,R14.d		: is this for slot 0?
	JN	MSG9FA			: no...treat like zapper
	LHL	R0,P.HOST,R1.p		: yes...locate the host
	JE	MSG9FA			: none...ignor
	STH	R15.s,HSTSVE		: source slot key
	JAL	R4,FNDHST		: examine the host state
	JNFS	MSG9FA			: coundn't find it...ignore
	LHI	R0,$A 17		: assume slot never told us
	LH	R2,H.NPTL,R1		:  ...that he had no ports left
	JNFS	MSG9FB			: he didn't
	LIS	R0,7			: he did...reason=out_of_ports
	JFS	MSG9FB			:
					:
:	.......................................................................
:	SPECIAL MESSAGE: Disconnect from Source and Buffers, do Accounting
:	format:		--------.-------.--------
:			|     port	|   9E	|
:			-------------------------
:
:	OR:		--------.-------.--------
:			|     port	|   9F	|
:			-------------------------
:	.......................................................................
					:
MSG9F	JAL	R4,GETH			: get message
	LR	R7,R0			: save copy
MSG9FA	LIS	R0,$2 01		: determine source
	NH	R0,P.NO,R1.p		: 01 if came from host
	XHI	R0,$2 11		: set to 2 if from host, 3 if from user
MSG9FB	STH	R0,SAVE+2		: record reason for termination
	STH	R7,SAVE			: save message ( & reason)
	JAL	R4,ELIR			: End-Logical-Input-Record
	LIS	R0,0			: Close source Permuter-table
	STH	R0,0,R5,R6.pt		:
	L	R1.p,CURPAT		: restore current path-pointer
	LHL	R0,I.CTL+2,R15.s	: check if Origination wants ACK
	THI	R0,X.ZAC.		:
	JE	MSG9FC			: skip if not
	LR	R14.d,R15.s		: yes.. send it back
	LR	R1,R5			: recompute originating port-number
	SRHLS	R1,1			:
	JAL	R4,SPEED		:
	LHI	R0,ZACMSG^8		: ACK it
	JAL	R4,SENDH		:
	JAL	R4,TERM			: terminate message
	L	R1.p,CURPAT		: restore path-pointer
	LB	R14.d,P.SLOT,R1.p	: and set up to proceed
MSG9FC	JAL	R5,DCDEST		: disconnect destination
	LA	R4,AATERM		: assume we'll want to Terminate Accounting
	LIS	R0,X.PNR.		: is destination port re-usable?
	NH	R0,I.CTL+2,R14.d	:
	JEFS	MSG9FD			: no
	LA	R4,AACLOSE		: yes...just close the Accounting
MSG9FD	LHL	R0,SAVE+2		: recover reason for termination
	JALR	R4,R4			: perform appropriate Accounting action
	J	MMFR			:
					:
  if	LOG.II


:	.......................................................................
:	LOG-II Response/RejectCircuit Request Message (RCRI)
:	format:		--------.-------.-------.--------
:			|      Port	|  C3	|X......|
:			|-------.-------+-------+-----------
:			|   length	|    SMO list.......
:			------------------------------------
:	.......................................................................
					:
MSGC3	LR	R15.s,R15.s		: valid ONLY from NC
	jefs	msgc3a			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 11		: dispatcher error # 12
	j	gkill			: crash slot
:	JN	GKILL			:
					:
:	.......................................................................
:	This is also an entry from MSGC4
:	.......................................................................
					:
MSGC3A	JAL	R4,GETH			: get type | X......
	LR	R5,R0			: save a copy
	JAL	R4,GETH			: get length
	LR	R6,R0			: save a copy
	LHI	R2,$A 6,R6		: Compute Message-size
	JAL	R4,CHECK		: decide where to put it
	LR	R0,R5			: subtype | X.....
	JAL	R4,SENDH		:
	LR	R0,R6			: Length
	JAL	R4,SENDH		:
MSGC3B	JAL	R4,GETH			: copy the rest of the message
	JAL	R4,SENDH		:
	SIS	R6,2			: count another HW gone
	JGBS	MSGC3B			:
	JAL	R4,TERM			: Terminate it
	JAL	R4,ELIR			: Terminate Input
	J	MMFR			: go back and do another


:	LOG-II ISIS Circuit Request Suplement Message (ICRS)
:	format:		--------.-------.-------.--------
:			|      Port	|  C4	|X......|
:			|-------.-------+-------+-----------
:			|   length	|    SMO list.......
:			------------------------------------
MSGC4	LR	R15.s,R15.s		: NOT valid from NC
	JN	MSGC3A			: OK...on to common code
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 12		: dispatcher error # 13
	J	GKILL			: error...kill slot
:	LOG-II Logon Success Indicator Message (LGSC)
:	format:		--------.-------.-------.--------
:			|      Port	|  C6	|XS....I|
:			|-------.-------+-------+-----------
:			|   length	|    SMO list.......
:			------------------------------------
MSGC6	LR	R15.s,R15.s		: should get these ONLY from slot 0
	jefs	msgc6z			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 13		: dispatcher error # 14
	j	gkill			: crash slot
:	JN	GKILL
msgc6z	JAL	R4,GETH			: get type | XS....I
	LR	R5,R0			: save copy
	JAL	R4,GETH			: get length
	LR	R6,R0			: save a copy
	THI	R5,LII.SU		: check Subsequent
	JN	MSGC6D			: only interested in first-time
	STH	R0,X4.LEN		: how much more there is
	COPOP(R1.p,R7.c)		: compute other-going Path
	LB	R4,P.STAT,R7.c		: adjust state
	NHI	R4,@(PA.LII!PA.ILI)	: no longer in LOGIN, LOGII
	THI	R5,LII.IN		: check for internal circuit
	JEFS	MSGC6A			: normal...skip
	OHI	R4,PA.DHU		: hold up the data
MSGC6A	STB	R4,P.STAT,R7.c		: record new states
	LIS	R4,CA.ORG		: setup acct. flag for origination
	OH	R4,C.STAT,R7.c		: update acct. information
	STH	R4,C.STAT,R7.c		: store back acct. information
	JAL	R5,X4.RCV		: get first element...LGSC MO
	jnfs	msgc6y			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 14		: dispatcher error # 15
	j	gkill			: crash slot
:	JE	GKILL			: it's wrong! 
msgc6y	L	R0,X4.CLS		: Class . form . I . D
	CI	R0,MO.LGS		:  APL  . Cons . LGSC
	jefs	msgc6x			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 15		: dispatcher error # 16
	j	gkill			: crash slot
:	JN	GKILL			: he got it wrong
msgc6x	JAL	R5,X4.RCV		: get second element...RMO MO
	jnfs	msgc6w
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 16		: dispatcher error # 17
	j	gkill			: crash slot
:	JE	GKILL			: it's wrong!
msgc6w	
	L	R0,X4.CLS		: Class . form . I . D
	CI	R0,MO.RMO		:  UNI  . Cons .  RMO
	jefs	msgc6v			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 17		: dispatcher error # 18
	j	gkill			: crash slot
:	JN	GKILL			: he got it wrong
msgc6v	STH	R2,X4.LFT		: OK...look only this far
MSGC6B	LH	R0,X4.LEN		: check for overrun
	jgefs	msgc6u
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 18		: dispatcher error # 19
	j	gkill			: crash slot
:	JL	GKILL
msgc6u	
	LH	R0,X4.LFT		: again
	JE	MSGC6D			: exhausted it...skip out of loop
	jgefs	msgc6t			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 19		: dispatcher error # 20
	j	gkill			: crash slot
:	JL	GKILL
msgc6t	JAL	R5,X4.RCV		: get the next element
	jnfs	msgc6s			: it's right!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 20		: dispatcher error # 21
	j	gkill			: got it wrong!
:	JE	GKILL			: got it wrong
msgc6s	JAL	R5,X4.RV		: get the value too
	L	R0,X4.CLS		: Class . form . I . D
	CI	R0,MO.INV		:  APL  . Cons . Invoice
	JNFS	MSGC6C			: not it
	L	R0,X4.VND-6		: get 32-bit value
	ST	R0,LO.INV
	LHL	R0,X4.VND-2		: get 16-bit value
	STH	R0,LO.INV+4
	J	MSGC6B			: and try for another

MSGC6C	CI	R0,MO.OHO		:  APL  . Cons . Org_host
	J	MSGC6B			: loop

MSGC6D	LR	R1.p,R7.c		: set Other (=Path0 / Channel)
	JAL	R4,AASINV		: Set up Accounting
	JAL	R4,LOOK			: re-scan message
	L	R1.p,CURPAT		: restore current path-pointer
	LHI	R2,$A 6,R6		: Compute Message-size
	JAL	R4,CHECK		: decide where to put it
	AIS	R6,4			: Length left
MSGC6E	JAL	R4,GETH			: copy the rest of the message
	JAL	R4,SENDH
	SIS	R6,2			: count another pair gone
	JGBS	MSGC6E
	JAL	R4,TERM			: Terminate it
	JAL	R4,ELIR			: Terminate Input
	J	MMFR

  ei	:LOG.II
	SUBTTL	DISPATCHER - GNOME (SYSTEM MESSAGE) LOGIC

:	We have Command-traffic

:	Define "licences" for which slots can use which messages
OK.N	EQ	80000000		: OK from node code (TBT with 0)
OK.S	EQ	40000000		: OK from slot (TBT with 1)
OK.A	EQ	OK.N!OK.S		: OK from either

:	"Case" table with slot licences for each possible command
GFAN	WC	OK.A!GNOME0		: 0
	WC	OK.A!GNOME1		: 1
	WC	OK.N!GNOME2		: 2
	WC	OK.S!GNOME3		: 3
	WC	OK.S!GNOME4		: 4
	WC	GKILL			: 5...not legal from ANYBODY!
	WC	OK.N!GNOME6		: 6
	WC	OK.S!GNOME7		: 7
	WC	OK.S!GNOME8		: 8
	WC	OK.N!GNOME9		: 9
	WC	OK.S!GNOM0A		: A
	WC	OK.N!GNOMEB		: B
	WC	OK.S!GNOM0A		: C
	WC	OK.N!GNOMED		: D
	WC	OK.N!GNOMEE		: E
	WC	OK.N!GNOMEF		: F
	WC	OK.S!GNOME4		: 10
  if	LOG.II				: LOG-II
	WC	OK.S!GNOM11		: 11
	WC	OK.N!GNOM12		: 12
  ei	:LOG.II
GFLEN	EQ	.-GFAN


:	On entry:
:	R2	- message type
:	R15.s	- originating slot key
GNOME	LR	R1,R2			: Compute index
	SLHLS	R1,2			:  *4
	CLHI	R1,GFLEN		: Range-check
	jlfs	gnomez			: it's ok
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 21		: dispatcher error # 22
	j	gkill			: kill slot
:	JGEFS	GKILL			: Kill Slot if not in range
gnomez	L	R4,GFAN,R1		: get effective address
	LR	R14.d,R15.s		: copy source-slot index
	JEFS	GNOMEA			: skip if slot-0
	LIS	R14.d,1			: else switch to second bit
GNOMEA	TBT	R14.d,GFAN,R1		: test if command is valid from this slot
	JNR	R4			: OK...go to correct routine for service

:	KILL Slot
:
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 42		: dispatcher error # 43
:
: GKILL causes the slot to crash with an entry in the history log specifying
: one of 43 reasons why the dispatcher does not like what it sees. The label
: 'dspmsg' points to an array of strings which describes the crash type.
: A table of four entries at 'dsptyp' gives information on the last four 
: crashes. Namely, the ring pointers CEI and NFMI for a half word each, the
: SLOT # for a half word, half word of crash type (1-43), and GMT for
: a word and the psw for a word. Also at the label 'dspreg' is found the 
: register set F for 40 bytes.
:

GKILL	eq	.
	lhl	r3,dspndx		: get index into table
	slls	r3,4			: quad word address	
	l	r11.ir,i.orng,r15.s	: pointer to slot's output ring
	lhl	r6,cei,r11.ir		: current empty index cursor
	sth	r6,dsptyp,r3
	lhl	r6,nfmi,r11.ir		: current fill index cursor
	sth	r6,dsptyp+2,r3
	lhr	r4,r15.s		: slot key
	srls	r4,2			: slot #
	sth	r4,dsptyp+4,r3		: slot crash
	ais	r5,1			: crash type adjust
	sth	r5,dsptyp+6,r3		: store type
	sis	r5,1			: crash type re-adjust
	l	r6,gmt			: get current time
	st	r6,dsptyp+8,r3		:
	lpswr	r4,r6			: get psw
	st	r6,dsptyp+0c,r3		:
	srls	r3,4			: get back index
	ais	r3,1			: increment for next cell
	clhi	r3,4			: range check
	jlfs	gkill0
	lis 	r3,0			: reset table
gkill0	sth	r3,dspndx		: store it
	slls	r5,4			: index to message
	la	r5,dspmsg,r5		:
	jal	r11,setdiag,,		: put message into history log
:
	JAL	R6,DCSLOT		: Disconnect the slot
	LIS	R0,0
	RBT	R0,I.CTL,R15.s		: now flag slot DOWN
	STH	R15.s,SCRASH		: tell KERNEL to disconnect him
	J	MAIN			: ...and quit
:

dspndx	hc	0			: array index
:
	bnd	4			: word boundary			:
dsptyp	eq	.			: last dispatcher slot crash handles
	re	4			: set up four cells
	hs	1			: cei
	hs	1			: nfmi
	hs	1			: slot
	hs	1			: type
	ws	1			: time
	ws	1			: psw
	er
:
dspreg	ws	10			: register set "F" save area
:
dspmsg	eq	.
	sc	/dispat crash#01/		:fill cursor > size (I)
	sc	/dispat crash#02/		:fill cursor > size (O)
	sc	/dispat crash#03/		:empty cursor > size (I)
	sc	/dispat crash#04/		:empty cursor > size (O)
	sc	/dispat crash#05/		:range check on specified port (MMFR)
	sc	/dispat crash#06/		:message license failure (MMFR)
	sc	/dispat crash#07/		:unrecognizable message (MMFR)
	sc	/dispat crash#08/		:unrecog. mesg. type on act. cr. (MMFRS)
	sc	/dispat crash#09/		:accounting addendum on slot 0 (B7)
	sc	/dispat crash#10/		:Login state failure (B3)
	sc	/dispat crash#11/		:not slot 0 (B6)
	sc	/dispat crash#12/		:not slot 0 (LOGII RCRI)
	sc	/dispat crash#13/		:Not valid from NC (LOGII ICRS C4)
	sc	/dispat crash#14/		:not slot 0 (LOGII LGSC C6)
	sc	/dispat crash#15/		:bad first element (C6)	
	sc	/dispat crash#16/		:APL . Cons . LGSC wrong el. (C6)
	sc	/dispat crash#17/		:RMO MO second el wrong (C6)
	sc	/dispat crash#18/		:UNI . Cons . RMO wrong (C6)
	sc	/dispat crash#19/		:overrun failure (C6)
	sc	/dispat crash#20/		:overrun again (C6)
	sc	/dispat crash#21/		:failure on next el. (C6)
	sc	/dispat crash#22/		:range failure on slot (GNOME)
	sc	/dispat crash#23/		:err. on rest. req. GNOME0
	sc	/dispat crash#24/		:err. on resp. to restart req. GNOME1
	sc	/dispat crash#25/		:err. on host# on host stat. req. GNONE4
	sc	/dispat crash#26/		:ill. req. change # of ports GNOME4
	sc	/dispat crash#27/		:trying to change host # GNOME4
	sc	/dispat crash#28/		:failure on pseudo needle req. GNONE7
	sc	/dispat crash#29/		:range fail.on sup. pseu. req. GNOME9
	sc	/dispat crash#30/		:Invalid host on port avail. GNOMOA
	sc	/dispat crash#31/		:range fail. on host unaccpt. GNOMEB
	sc	/dispat crash#32/		:range fail. (ECRM) GNOM12
	sc	/dispat crash#33/		:needle req. not slot 0 NEEDLE
	sc	/dispat crash#34/		:needle req. perm. tab. in timo. NEEDLE
	sc	/dispat crash#35/		:int. circuit port out of range 
	sc	/dispat crash#36/		:pseudo nd. not slot 0 (B2)
	sc	/dispat crash#37/		:pseude nd. perm. table timo. (B2)
	sc	/dispat crash#38/		:not slot 0 (LOGII ISN C2)
	sc	/dispat crash#39/		:port 0 (silly) (LOGII ISN C2)
	sc	/dispat crash#40/		:port out of range (LOGII ISN C2)
	sc	/dispat crash#41/		:valid on from slot 0 (LOGII ASLP C5)
	sc	/dispat crash#42/		:fail gnome command test -- falls thru.
	sc	/dispat crash#43/		:not slot 0 (GNOME)
:	Restart Request
:	format:		--------.-------.--------
:			|       0       |   0   |
:			-------------------------
GNOME0	LHL	R0,I.CTL+2,R15.s	: check if valid
	THI	R0,X.ARR.		: should we accept request?
	jnfs	gnomey			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 22		: dispatcher error # 23
	j	gkill			: crash slot	
:	JE	GKILL			: NO...error-condition
gnomey	JAL	R4,ELIR			: Else close-out I/O
	LIS	R0,0			: Reset Slot's cursors
	L	R1,I.IRNG,R15.s
	ST	R0,NFMI,R1
	L	R1,I.ORNG,R15.s
	ST	R0,NFMI,R1
	JAL	R6,DCSLOT		: Disconnect Slot (Hosts DOWN, ZAP Ports)
	LR	R14.d,R15.s		: Now respond to request
	JAL	R3,SPACE		: we can do direct, since guaranteed empty
	LHI	R0,100
	JAL	R4,PUTW			: Port0, Message-type 1
	JAL	R4,ELOR			: End-Logical-Output_Record
	J	MAIN			: Obviously, nothing left to do for this slot!


:	Response to Restart
:	format:		--------.-------.--------
:			|       0       |   1   |
:			-------------------------
GNOME1	LHL	R0,I.CTL+2,R15.s	: Check if valid
	THI	R0,X.ARR.		: should we accept request?
	jnfs	gnomex			: it's ok
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 23		: dispatcher error # 24
	j	gkill			: crash slot
:	JE	GKILL			: NO...error-condition
gnomex	JAL	R4,ELIR			: else just ignore these
	J	MMFR



:	Node Taken Over
:	format:		--------.-------.-------.--------
:			|       0       |   2   |Sup No.|
:			---------------------------------

:		Also used for:

:	Sup Lost
:	format:		--------.-------.-------.--------
:			|       0	|  0D	|   0	|
:			---------------------------------
GNOMED
GNOME2	JAL	R4,GETH			: get message-type | Sup #
	STB	R0,SUP.SP		: save it in SEGF
	LR	R5,R0			: save it
	JAL	R4,ELIR			: End-Logical-Input-Record
	LIS	R0,0
	ST	R0,AALINS		: Insure Accounting-invoice is Transmitted
	STH	R0,AALINS+4
	LHI	R14.d,NSLOT*4		: for all slots...
G.02.A	L	R0,I.CTL,R14.d
	JGE	G.02.D			: Ignore if slot not operable
	THI	R5,0200			: DIfferent test for Each message-type
	JNFS	G.02.B			: do other test
	THI	R0,X.UTK.
	JNFS	G.02.C			: wants to know about untaker
	JFS	G.02.D			: doesn't care about untaker

G.02.B	THI	R0,X.TTK.		: does this slot care about takeover?
	JEFS	G.02.D			: skip if not
G.02.C	JAL	R4,SENDTO		: yes...tell him on port-0
	LR	R0,R5			: Message-type
	JAL	R4,SENDH
	JAL	R4,TERM			: End-Logical-Output-Record
G.02.D	SIS	R14.d,4			: repeat for all slots
	JG	G.02.A			: ...but NOT from slot 0!
	J	MMFR			: then get next message



:	Report to Sup Log
:	format:		--------.-------.-------.--------
:			|       0	|   03	|  key	|
:			|-------.-------+-------+-------|
:			|     DATA2	| R_typ	| DATA1	|
:			|-------+-------+----------------
:			| ProdID|
:			---------
GNOME3	NETRAT(1)			: DISMISS if overusing Port0
	LIS	R2,$A 10		: 10-byte message
	JAL	R4,SENDS0		: start sending to slot 0
	LHI	R0,300,R15.s		: TYPE|KEY
	JAL	R4,SENDH
	JAL	R4,GETH			: skip second HW of source
	JAL	R4,GETW			: copy 2 more HWs
	JAL	R4,SENDW
	JAL	R4,GETH			: and last byte | PAD
	JAL	R4,SENDH
	JAL	R4,TERM			: terminate message
	JAL	R4,ELIR
	J	MMFR			: get another message



:	Report Host-status
:	format:		--------.-------.-------.--------
:			|       0	|  4/10	|  key	|
:			|-------.-------+-------+-------|
:			|  Host number	| number/ports	|
:			|-------.-------+-------+-------|
:			|      RH#	| status|hst key|
:			|-------.-------+----------------
:			|IP	|  PID	|			(type 10 ONLY)
:			-----------------
GNOME4	NETRAT(1)			: Overuse of Port0 causes DISMISS
	LR	R14.d,R2		: Keep copy of Type
	JAL	R4,GETH			: Skip to second word
	JAL	R4,GETH			: get Host-number
	LR	R5,R0			: save copy
	JAL	R4,GETH			: number of ports
	LR	R6,R0			: save copy
	JAL	R4,GETH			: get Host Index
	CLH	R0,I.HSIZ,R15.s		: verify valid Host
	jlfs	gnomew
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 24		: dispatcher error # 25
	j	gkill			: crash slot
:	JGE	GKILL			: Excuse to crash him if wrong number
gnomew	LR	R10,R0			: OK...save it
	AR	R10,R10			: make HW index
	L	R8,I.HTBL,R15.s		: pointer to slot's Host Table
	L	R9,I.UTBL,R15.s		: pointer to Port Table
	LHL	R4,I.CTL+2,R15.s	: Check User's Limits
	THI	R4,X.RNP.		: may he redefine number of ports?
	JNFS	G.04.A			: yes
	LHL	R6,0,R9,R10		: no...so use default value
	NHI	R6,3FFF			: mask off the status-bits
G.04.A	THI	R4,X.RHN.		: may he redefine Host-numbers?
	JNFS	G.04.B			: yes
	LHL	R5,0,R8,R10		: no...use default
G.04.B	JAL	R4,GETH			: get status
	LB	R4,0,R9,R10		: get current Status-bits
	SRHLS	R4,6
	SIS	R4,3			: R4 = 0 if previous state was "GONE"
	je	g.04.c			:
:	JEFS	G.04.C			: changes legal in that case ONLY!
	LHI	R3,3FFF			: wasn't GONE...verify no change attempted
	NH	R3,0,R9,R10		: Extract current number of ports/host
	CR	R3,R6			: test if trying to change # of ports
	jefs	gnomev			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 25		: dispatcher error # 26
	j	gkill			: crash slot
:	JN	GKILL			: yes...illegal request
gnomev	CLH	R5,0,R8,R10		: now check if trying to change host-number
	jefs	g.04.c			: it's ok
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 26		: dispatcher error # 27
	j	gkill			: crash slot
:	JN	GKILL			: crash him if illegal

G.04.C	LHL	R3,0,R8,R10		: OK...get old Host-number
	STH	R5,0,R8,R10		: set new Host-number
	LR	R4,R0			: copy New status
	NHI	R4,300			: Remove other bits
	SLHLS	R4,6
	OR	R4,R6
	STH	R4,0,R9,R10		: save new status | number of ports
	EXHR	R7,R5			: Pack H.NO, H.NPT to R7
	OR	R7,R6
	LR	R6,R0			: copy Status
	LIS	R0,0			: set R0 to 0
	SIS	R14.d,4
	JEFS	G.04.D			: Ignore ID-field if Type = 4
	JAL	R4,GETH			: else get it
G.04.D	LR	R5,R0
	JAL	R4,ELIR			: Terminate input from Source
	STH	R15.s,HSTSVE		: slot key source
 	LR	R0,R3			: get old host-number
	JAL	R4,FNDHST		: see if host in table
	JL	G.04.E			: no room in table
	ST	R7,H.NO,R1		: ok...set up descriptor NO | NPT
	STH	R7,H.NPTL,R1		: NPTL = NPT
	STH	R15.s,H.SKEY,R1
	STH	R6,H.STAT,R1		: STAT | KEYL
	STH	R5,H.IIX,R1		: IIX | PID
	STH	R10,H.RHX,R1
	LIS	R0,0
	STH	R0,H.COST,R1
	LR	R5,R1			: copy pointer
	JAL	R6,SNDHST		: send host-report to slot 0
	J	MMFR			: and proceed

:	Reject host...no space left
G.04.E	LHI	R0,0C000		: flag host gone in slot
	OH	R0,0,R9,R10
	STH	R0,0,R9,R10
	LR	R14.d,R15.s		: return to sender...
	LIS	R2,8			: 8-byte message
	JAL	R4,SENDTO		: on CMD-port
	LHI	R0,0B00			: host unacceptable
	JAL	R4,SENDH
	LI	R0,0FFFF0000
	NR	R0,R7			: Host-number | 0=no table-space left
	JAL	R4,SENDW
	JAL	R4,TERM			: done
	J	MMFR
:	Supervisor Time
:	format:		--------.-------.-------.--------
:			|       0	|   6	|unused	|
:			|-------.-------+-------+-------|
:			|              GMT		|
:			---------------------------------
GNOME6	JAL	R4,GETH			: skip next pair of characters
	JAL	R4,GETW			: get the time
	ST	R0,GMT			: save time
	LH	R4,TAKTIM		: check to see if Takeover-time is set
	JGEFS	G.06.A
	ST	R0,TAKTIM		: Update Takeover-time
G.06.A	JAL	R4,ELIR			: End-Logical-Input-Record
	LHI	R14.d,NSLOT*4		: for all slots...
G.06.B	L	R0,I.CTL,R14.d
	JGE	G.06.C			: ignore if slot not operable
	THI	R0,X.TST.		: does this slot care?
	JE	G.06.C			: skip if not
	LIS	R2,8			: yes...tell him
	JAL	R4,SENDTO		: where do we send it?
	LHI	R0,600			: Message-type 6
	JAL	R4,SENDH
	L	R0,GMT			: Copy Time
	JAL	R4,SENDW
	JAL	R4,TERM			: Terminate message
G.06.C	SIS	R14.d,4			: repeat for all
	JG	G.06.B			: ...but NOT for slot 0
	J	MMFR			: then get next message



:	Request for Pseudoneedle -- Normal
:	format:		--------.-------.-------.--------
:			|       0	|   7	| key	|
:			|-------.-------+-------+-------|
:			|   Local Key	|IEU		|
:			|-------.-------+-------+--------
:			| Orig. Host	|  CCT	|
:			-------------------------
GNOME7	NETRAT(3)			: Pseudoneedle Request is expensive
	JAL	R4,GETH			: Skip over code, pad
	JAL	R4,GETW			: get LOCAL KEY | IEU
	LR	R5,R0
	JAL	R4,GETW			: get ORIG. HOST Host, CCT
	LR	R6,R0
	EXBR	R0,R0
	LBR	R0,R0			: isolate byte of CCT
	CHI	R0,0C1
	jgefs	gnomeu
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 27		: dispatcher error # 28
	j	gkill			: crash slot
:	JL	GKILL
gnomeu	JAL	R4,ELIR			: End-Logical-Input-Record
	LIS	R2,$A 12		: 12-byte Message
	JAL	R4,SENDS0		: to slot 0 command-port
	LHI	R0,700,R15.s		: subtype | originating slot Key
	JAL	R4,SENDH
	LR	R0,R5			: send LOCAL KEY | IEU
	JAL	R4,SENDW
	LR	R0,R6			: send ORIG. HOST | CCT
	JAL	R4,SENDW
	JAL	R4,TERM			: Terminate it
	J	MMFR			: go back and do another



:	Request for Pseudo-needle -- AUX
:	format:		--------.-------.-------.--------
:			|       0	|   8	| key	|
:			|-------.-------+-------+-------|
:			|   local key	|Iix		|
:			|-------.-------+-------+-----------
:			|  Orig. Host	| size	| string
:			------------------------------------
GNOME8	NETRAT(3)			: check overuse
	JAL	R4,GETH			: skip to second Word
	JAL	R4,GETW			: get LOCAL KEY | Iix
	LR	R6,R0			: save a copy
	JAL	R4,GETW			: get ORIG. HOST | size | char
	LR	R7,R0			: save copy
	EXBR	R5,R0			: isolate size
	LBR	R5,R5
	SIS	R5,1			: account for char we already got
	LIS	R1,X.AUX.
	NH	R1,I.CTL+2,R15.s	: see if AUX circuits allowed
	JE	G.08.B			: skip if not
	LHI	R2,$A 11,R5		: Compute Message-size
	JAL	R4,SENDS0		: send to slot 0 command-port
	LHI	R0,0800,R15.s		: subtype | originating slot Key
	JAL	R4,SENDH
	LR	R0,R6			: LOCAL KEY | Iix
	JAL	R4,SENDW
	LR	R0,R7			: add ORIG. HOST | size | char
	JAL	R4,SENDW
G.08.A	JAL	R4,GETH			: copy the string
	JAL	R4,SENDH
	SIS	R5,2			: count another one gone
	JGBS	G.08.A
	JAL	R4,TERM			: Terminate it
	JAL	R4,ELIR			: Terminate Input
	J	MMFR			: go back and do another

:	Slot doesn't have AUX-licence...refuse request
G.08.B	LR	R0,R5			: copy chars left
	JAL	R4,FLUSH		: Done with rest of message
	LR	R14.d,R15.s		: send back to sender:
	NI	R6,0FFFF0000		: LOCAL KEY | Error-code = 0 | pad
	J	G.09.A			: skip to common code to forward it
:	Unable to supply Pseudo-needle
:	format:		--------.-------.-------.--------
:			|	0	|   9	|  key	|
:			|-------.-------+-------+--------
:			|   local key	|  err	|
:			-------------------------
GNOME9	JAL	R4,GETH			: get code | Key
	LBR	R14.d,R0		: copy Key only
	CLHI	R14.d,4*NSLOT		: Range-check
	jlefs	gnomet
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 28		: dispatcher error # 29
	j	gkill			: crash slot
:	JG	GKILL
gnomet	JAL	R4,GETW			: get LOCAL KEY | ERROR KEY | pad
	LR	R6,R0			: save copy
	JAL	R4,ELIR			: End-Logical-Input-Record
	LH	R1,I.CTL,R14.d		: check Destination
	JGE	MMFR			: Abort if Destination DOWN

:	Alternate entry from GNOME8:
:	R14.d -	Destination slot
:	R6 -	Local-key | error | pad
G.09.A	LIS	R2,8			: 8-byte message
	JAL	R4,SENDTO		: ...on command-channel
	LHI	R0,09^8,R14.d		: compute Type | key
	JAL	R4,SENDH		: send it
	LR	R0,R6			: LOCAL KEY | ERROR KEY | pad
	JAL	R4,SENDW
	JAL	R4,TERM			: End-Logical-Output-Record
	J	MMFR			: go back and get another message
:	Report Host-Port availability
:	format:		--------.-------.-------.--------
:			|       0	|   0A	| key	|
:			|-------.-------+-------+-------|
:			|  Host number	| number/ports	|
:			|-------.-------+-------.--------
:			|      RH#      |
:			-----------------
:		Also used for:
:	Report Host-Cost
:	format:		--------.-------.-------.--------
:			|       0	|   0C	| key	|
:			|-------.-------+-------+-------|
:			|  Host number	|     cost	|
:			|-------.-------+-------.--------
:			|      RH#      |
:			-----------------
GNOM0A	NETRAT(1)			: Check overuse of Port0
	JAL	R4,GETH			: get Message-type
	LHI	R5,0FF00
	NR	R5,R0			: make copy
	JAL	R4,GETH			: Skip Host-number
	JAL	R4,GETH			: Number-of-Ports OR Cost
	LR	R7,R0			: save copy
	JAL	R4,GETH			: get Host-Index
	CLH	R0,I.HSIZ,R15.s		: verify valid Host
	jlfs	gnomes			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 29		: dispatcher error # 30
	j	gkill			: crash slot
:	JGE	GKILL			: excuse to crash him if too big
gnomes	LR	R8,R0			: OK...Save it
	AR	R8,R8			: make HW index
	L	R9,I.HTBL,R15.s		: pointer to Host-table
	LHL	R6,0,R8,R9		: get Host-number
	JAL	R4,ELIR			: End-Logical-Input-Record
	STH	R15.s,HSTSVE		: source slot-key
	LR	R0,R6			: copy host-number
	JAL	R4,FNDHST		: find host-descriptor
	JN	MMFR			: host not known...ignore request
	CLHI	R5,0A00			: Host-port message?
	JNFS	G.0A.A			: no
	STH	R7,H.NPTL,R1		: yes
	LR	R5,R1			: copy pointer
	JAL	R6,SNDPTA		:  ...and forward report
	J	MMFR			: done.

G.0A.A	STH	R7,H.COST,R1		: must be Host-cost
	LR	R5,R1			: copy pointer
	JAL	R6,SNDCOST		:  ...and forward report
	J	MMFR			: done.
:	Host unacceptable
:	format:		--------.-------.-------.--------
:			|	0	|  0B	|  key	|
:			|-------.-------+-------+--------
:			|  host number	|  err	|
:			-------------------------
GNOMEB	JAL	R4,GETH			: get code | Key
	LR	R5,R0			: save copy
	LBR	R14.d,R0		: copy Key only
	CLHI	R14.d,4*NSLOT		: range-check
	jlefs	gnomer			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 30		: dispatcher error # 31
	j	gkill			: crash slot
:	JG	GKILL
gnomer	JAL	R4,GETW			: get HOST # | ERROR KEY | pad
	LR	R6,R0			: save copy
	JAL	R4,ELIR			: End-Logical-Input-Record
	LH	R1,I.CTL,R14.d		: check Destination
	JGE	MMFR			: abort if Destination DOWN
	LIS	R2,8			: 8-byte message
	JAL	R4,SENDTO		: ...on port0
	LR	R0,R5			: Type | pad
	JAL	R4,SENDH		: send it
	LR	R0,R6			: LOCAL KEY | ERROR KEY | pad
	JAL	R4,SENDW
	JAL	R4,TERM			: End-Logical-Output-Record

:	Set Host Gone
	EXHR	R6,R6			: Isolate Host-Number
	LHR	R6,R6
	L	R9,I.HTBL,R14.d		: Host-table address
	LHL	R8,I.HSIZ,R14.d		: Host-table Length
	AR	R8,R8
G.0B.A	SIS	R8,2			: search Host-table for this host
	JL	MMFR			: not found...Oh well...
	CLH	R6,0,R9,R8		: is this it?
	JNBS	G.0B.A			: no
	L	R9,I.UTBL,R14.d		: found...get Status|Port-table Address
	LH	R0,0,R9,R8		: set Host GONE
	OHI	R0,0C000
	STH	R0,0,R9,R8
	STH	R14.d,HSTSVE		: destination slot-key
	LR	R0,R6			: host number
	JAL	R4,FNDHST		: look it up
	JL	MMFR			: not there
	LIS	R0,0			: found it...
	STH	R0,H.NO,R1		: ...now it's gone
	J	MMFR			: go back and get another Message
:	Remote (1-Down) Message
:	format:		--------.-------.-------.--------
:			|       0	|  0E	| key	|
:			|-------+-------+-------------------
:			| Type	| size	| string
:			------------------------------------
GNOMEE	JAL	R4,GETH			: get type | slot Key
	LBR	R14.d,R0		: save a copy
	JNFS	G.0E.B			: skip if not a Broadcast

G.0E.A	AIS	R14.d,4			: for next slot...
G.0E.B	CLHI	R14.d,NSLOT*4		: if in range
	JG	G.0E.E			: too big
	L	R0,I.CTL,R14.d		: get control-word
	JGE	G.0E.D			: skip if not connected
	THI	R0,X.RMT.		: is the slot accepting?
	JE	G.0E.D			: no
	JAL	R4,GETH			: get Subtype | size
	LR	R6,R0			: save copy
	LBR	R5,R0			: save copy of size
	LHI	R2,6,R5			: compute message-size
	JAL	R4,SENDTO		: decide where to put it
	LHI	R0,0E00,R14.d		: Subtype | Destination Key
	JAL	R4,SENDH
	LR	R0,R6			: Subtype | size
	JAL	R4,SENDH
G.0E.C	JAL	R4,GETH			: copy the string
	JAL	R4,SENDH		: ...2 bytes at a time
	SIS	R5,2			: count another HW gone
	JGBS	G.0E.C
	JAL	R4,TERM			: terminate it
G.0E.D	JAL	R4,LOOK			: RESCAN the message
	JAL	R4,GETH			: flush TYPE | KEY
	LBR	R0,R0			: is this a Broadcast?
	JE	G.0E.A			: yes...continue
G.0E.E	JAL	R4,GETCH		: flush sub-type
	JAL	R4,GETCH		: get message-size
	JAL	R4,FLUSH		: and flush
	J	MMFR
:	Report all Hosts' status
:	format:		--------.-------.--------
:			|       0       |   F   |
:			-------------------------
GNOMEF	JAL	R4,ELIR			: End-Logical-Input-Record

:	Search Host-tables
	LA	R5,HSTTBL		: pointer to First Host
	LHI	R15.s,NUMHST		: how many there are
G.0F.A	LH	R0,H.NO,R5		: is this host active?
	JEFS	G.0F.B			: no
	JAL	R6,SNDHST		: yes...report it
	JAL	R6,SNDPTA		:  ...and ports available
	LH	R0,H.COST,R5		: is cost non-zero?
	JEFS	G.0F.B			: no
	JAL	R6,SNDCOST		: yes...send cost too
G.0F.B	AHI	R5,H.LEN		: advance to next host
	SIS	R15.s,1
	JG	G.0F.A			: loop to report all hosts
	J	MMFR			: done!

  if	LOG.II



:	LOG-II Circuit-Request Message (ICRM)
:	format:		--------.-------.-------.--------
:			|       0	|  11	|X.....A|
:			|-------.-------+-------+-------|
:			|    length	|   Slot Key	|
:			|-------.-------+-------+-----------
:			|  Local Key	|    SMO list.......
:			------------------------------------
GNOM11	NETRAT(3)			: check overuse
	JAL	R4,GETH			: get subtype | X.....A
	LCS	R5,2			: set mask
	NR	R5,R0			: save a copy, 'A' = 0
	JAL	R4,GETH			: get length
	LR	R6,R0			: save a copy
	JAL	R4,GETH			: skip over Slot Key field
	LR	R7,R15.s		: record source key
	LIS	R14.d,S0KEY		: pass on to slot 0
	LIS	R0,X.AUX.
	NH	R0,I.CTL+2,R15.s	: check if AUX allowed
	JEFS	G.11.A			: no
	AIS	R5,1			: yes...set 'A' = 1

:	This is also an entry from GNOME12
G.11.A	LHI	R2,$A 6,R6		: Compute Message-size
	JAL	R4,SENDTO		: decide where to put it
	LR	R0,R5			: subtype | X....A
	JAL	R4,SENDH
	LR	R0,R6			: Length
	JAL	R4,SENDH
	LR	R0,R7			: add slot-Key
	JAL	R4,SENDH
	SIS	R6,2			: count those bytes gone too
G.11.B	JAL	R4,GETH			: copy the rest of the message
	JAL	R4,SENDH
	SIS	R6,2			: count another pair gone
	JGBS	G.11.B
	JAL	R4,TERM			: Terminate it
	JAL	R4,ELIR			: Terminate Input
	J	MMFR			: go back and do another



:	LOG-II Early Circuit Reject Message (ECRM)
:	format:		--------.-------.-------.--------
:			|       0	|  12	|X......|
:			|-------.-------+-------+-------|
:			|    length	|   Slot Key	|
:			|-------.-------+-------+-----------
:			|  Local Key	|    SMO list.......
:			------------------------------------
GNOM12	JAL	R4,GETH			: get subtype | X......
	LR	R5,R0			: save a copy
	JAL	R4,GETH			: get length
	LR	R6,R0			: save a copy
	JAL	R4,GETH			: get Slot Key field
	CLHI	R0,4*NSLOT		: Range-check
	jlefs	gnomeq			: it's ok
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 31		: dispatcher error # 32
	j	gkill			: crash slot
:	JG	GKILL			: bad Key from Node Code
gnomeq	LR	R14.d,R0		: save copy
	LR	R7,R0			: ...and another too for shared code
	L	R1.p,I.CPATH,R14.d	: locate slot's Command-Path
	LH	R0,I.CTL,R14.d		: check destination
	JL	G.11.A			: up...go to shared code to send it
	LHI	R0,-2,R6		: compute length...already read Slot key
	JAL	R4,FLUSH		: toss message
	J	MMFR			: go back and do another

  ei	:LOG.II
	SUBTTL	DISPATCHER - Circuit-building Logic

:	DISPATCHER - NEEDLE Logic

:	we have a free port and a Connect message
:	format:		--------.-------.-------.--------
:			|    RPORT	|   0	| length|
:			|-------.-------+-------+-------|
:			|       INVOICE NUMBER          |
:			|-------.-------+-------.-------|
:			| Dest. Host #  | Orig. Node #  |
:			|-------.-------+-------.-------|
:			| Orig. Host #	|* Orig. Port #	|
:			|-------.-------+-------+-------|
:			|  Extra I.N.	|  XXX	|  TPC	|
:			|-------.-------+-------+-------|
:			|I   Dest Node	|  CCT	| size	|
:			|-------.-------.-------.-------|
:			|   USER NAME ("size" bytes long)
:			---------------------------------
:	On entry:
:	R1 =	Port-number
:	R2 =	type,
:	R5 =	Port-number*2
:	R6.pt =	Permuter-table base-address
:	R7.PT.=	contents of Permuter-table entry
:	R15.s =	Origination Slot key
NEEDLE	LR	R15.s,R15.s
	jefs	needlz			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 32		: dispatcher error # 33
	j	gkill			: crash slot
:	JN	GKILL			: valid ONLY from slot 0
needlz	LR	R7.PT.,R7.PT.		: check for Permuter-table in TIMEOUT
	jefs	needly			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 33		: dispatcher error # 34
	j	gkill			: crash slot
:	JN	GKILL			: cause to crash slot 0
needly	STH	R1,LO.SPT		: record Source-port
	STH	R5,LO.PTP		: record source Permuter-table index
	LR	R7,R1			: copy source port-number
					:
:	.......................................................................
:	Get the NEEDLE
:	.......................................................................
					:
	JAL	R4,GETH			: get message-length
	LBR	R0,R0			: ignore sub-type
	AIS	R0,2			: length exclusive of RPORT
	STH	R0,LO.LEN		:
	JAL	R4,GETW			:
	ST	R0,LO.INV+2		: Invoice-number
	JAL	R4,GETH			:
	STH	R0,LO.HST		: Host-number
	JAL	R4,GETH			: ignore Origination node-number
	JAL	R4,GETW			: get Origination Host- / Port- number
	STH	R0,LO.INT		: set Internal-circuit flag < 0
	NHI	R0,7FFF			: mask off Internal-bit
	STH	R0,LO.OPT		: Originating port
	JAL	R4,GETW			: Extra IN | XXX | TPC
	EXHR	R0,R0			: toss XXX | TPC
	STH	R0,LO.INV		: high-order Invoice-number
	JAL	R4,GETH			: ignore IIX | Dest Node
	JAL	R4,GETCH		: get CCT
	NHI	R0,1F			:
	SIS	R0,1			:
	STH	R0,LO.AUX		: set <0 if AUX-circuit
	JAL	R4,GETCH		: skip count
					:
:	.......................................................................
:	Got body of message, now check it out
:	.......................................................................
					:
	LCS	R0,1			: host-any-slot-key (-1)
	STH	R0,HSTSVE		:
	LHL	R0,LO.HST		: get host number
	JAL	R4,FNDHST		: locate it
	JEFS	NEED1			: we found it!
	LA	R2,NOHOST		: else set no_host_found message
	J	NOCIR			: can't do it...go report and clean-up
					:
:	.......................................................................
:	We have located the destination slot
:	.......................................................................
					:
NEED1	LHL	R14.d,H.SKEY,R1		: get pointer to destination slot
	LB	R0,H.STAT,R1		: check Host-state
	NHI	R0,03			: isolate Host-state bits
	JEFS	NEED2			: 0 = Answered...skip
	LA	R2,HOSTDN		: in case it's down
	SIS	R0,01			: DOWN?
	JE	NOCIR			: yes...abort login
	JAL	R4,GETCH		: must be SHUT...get first char
	LA	R2,HOSTSH		: Host-Shut msg in case NOT Override
	CLHI	R0,0A1			:  is it "!" ?
	JN	NOCIR			: no...lock user out
					:
:	.......................................................................
:	Host is up and answered...Proceed
:	.......................................................................
					:
NEED2	LHL	R9,I.PSIZ,R14.d		: find a Destination-port
	AR	R9,R9			: index of last port
	L	R8,I.PTBL,R14.d		: locate Destination's Permuter-table
NEED3	LHL	R0,0,R8,R9		: check an entry
	JEFS	NEED4			: got one...skip to service it
	SIS	R9,2			: try next port
	JGBS	NEED3			: repeat for all ports
	LA	R2,OUTPRT		: none there...set message
	J	NOCIR			: abort
					:
:	.......................................................................
:	Have a port on Destination
:	At this point:
:	R5	Slot 0 Permuter-table index
:	R6.pt	Base-address of slot 0 Permuter-table
:	R7	Slot 0 port-number
:	R8	Base address of Destination Permuter-table
:	R9	Destination Permuter-table index
:	R14.d	Destination slot Key (Word-index)
:	.......................................................................
					:
NEED4	LH	R1,LO.INT		: check source of LOGON
	JGE	NEED10			: external LOGON...skip
					:
:	.......................................................................
:	This LOGON is coming from us, and looped out through slot 0...
:	look up and remove this extraneous loop
:	.......................................................................
					:
	LHL	R1,LO.OPT		: get port-number
	CLH	R1,I.PSIZ,R15.s		: Range-check
	jlefs	needlx			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 34		: dispatcher error # 35
	j	gkill			: crash slot
:	JG	GKILL			: crash if Orig. port is out of range
needlx	AR	R1,R1			: make Permuter-table index
	LH	R2,0,R1,R6.pt		: and get it
	JGFS	NEED5			: skip if internal circuit was Zapped
	LA	R2,ORIZAP		: else say Zapped by user
	J	NOCIR			: and abort it
NEED5	LIS	R0,0			:
	STH	R0,0,R1,R6.pt		: clear that Permuter-table entry
	STH	R2,0,R8,R9		: move entry to Dest. Permuter-table
	CPFPN(R2,R1.p)			: compute path from path-number
	LHL	R0,LO.HST		: record destination-host
	STH	R0,P.HOST,R1.p		:  ...in backward path
	COPOP(R1.p,R1.p)		: compute other path (channel / path 0)
	ST	R1.p,CURPAT		: save path pointer for later
	SRHLS	R9,1			: make port-number
	STH	R9,LO.PRT		: save destination-port
	STH	R9,P.PORT,R1.p		: plug into Path
	LIS	R0,CA.CTO		: set Channel-state to Counts open
	LB	R4,P.STAT,R1.p		: get path state too
	NHI	R4,@(PA.DHU!PA.ILI!PA.LII) : cancel data-hold-up, LOGIN
	LHI	R5,X.IPC.		:
	NH	R5,I.CTL+2,R14.d	:
	JEFS	NEED6			: dest. doesn't care about project-code
	AIS	R0,CA.PCO		: set channel to collect project-code too
	OHI	R4,PA.CPC		: set path to collect project-code
NEED6	STB	R4,P.STAT,R1.p		: set new path-state
	OH	R0,C.STAT,R1.p		: update acct. info. for origination
	STH	R0,C.STAT,R1.p		: save Channel Project_code-state
	STB	R14.d,P.SLOT,R1.p	: connect Path to this slot
	STH	R14.d,LO.KEY		: save destination Key
	lhl	r2,p.bct,r1.p		: is there data to process? ***ern
	je	need8			: yes => unlink from node and link to dest
					:
:	.......................................................................
:	unlink from linked list
:	.......................................................................
					:
	l	r2,p.last,r1.p		: pointer to our last
	l	r3,p.next,r1.p		: pointer to our next
	st	r3,p.next,r2		: link last to next
	jefs	need7			: skip if next is null
	st	r2,p.last,r3		: link next back to last
					:
:	.......................................................................
:	Do linked-list insert
:	.......................................................................
					:
need7	la	r3,i.que,r14.d		: pointer to queue
	la	r2,p.next,r1.p		: convert to pointer
	st	r3,p.last,r1.p		: point back to queue
	l	r3,i.que,r14.d		:
	st	r2,i.que,r14.d		: link queue to this
	st	r3,p.next,r1.p		: link this to previous queue head
	jefs	need8			: null?
	st	r2,p.last,r3		: no...link new next back to this
need8	LR	R14.d,R15.s		: now Zap the circuit going back
	LR	R1,R7			: source port-number
	JAL	R5,ZAPEM		:
	LHL	R14.d,LO.KEY		: restore Destination slot Key
	L	R1.p,CURPAT		: restore Path-pointer
	J	SNDACT			: and skip to pass it on, set up Accounting
					:
:	.......................................................................
:	Circuit comes from external Source
:	.......................................................................
					:
NEED10	JAL	R4,ALOCC.		: find a free Path-pair
	 J	NEED11			: got one
	LA	R2,NOCHAN		: none there...set failure
	J	NOCIR			: and abort
					:
:	.......................................................................
:	We have found an unassigned Channel (Path-pair)
:	R0	- Path 1 number
:	R1.p	- Path 0 (Forward) Path POINTER
:	R2	- Path 1 (Reverse) Path POINTER
:	R3	- Path 0 number
:	.......................................................................
					:
NEED11	STH	R0,0,R8,R9		: connect Destination P-table to path1
	STH	R7,P.PORT,R2		: connect path1 to source-port
	LHL	R0,LO.HST		: record destination host
	STH	R0,P.HOST,R2		:  ...in backward path
	STH	R3,0,R5,R6.pt		: connect Source Permuter-table to path0
	SRHLS	R9,1			: make Destination port-number
	STH	R9,LO.PRT
	STH	R9,P.PORT,R1.p		: connect path0 to Destination-port
	STB	R14.d,P.SLOT,R1.p	:  ...and to Destination-slot
	LIS	R0,0			: set up Path-state
	LIS	R2,CA.CTO		:  ...and Channel to Counts
	LHI	R4,X.IPC.		:
	NH	R4,I.CTL+2,R14.d	:
	JEFS	NEED12			: no concern with Project code
	AIS	R2,CA.PCO		: project-code open too
	AIS	R0,PA.CPC		: collect project-code
NEED12	STB	R0,P.STAT,R1.p		: save state
	STH	R2,C.STAT,R1.p		: Channel state too
	J	SNDACT			: go finish off
					:

:	.......................................................................
:
:	DISPATCHER - PSEUDONEEDLE Logic
:
:	We have a free port and a Pseudoneedle
:	format:		--------.-------.-------.--------
:			|    RPORT      |  B2   | index |
:			|-------.-------+-------+--------
:			|   local key   |
:			--------.--------
:
:	.......................................................................
					:
PNEED	LR	R15.s,R15.s		:
	jefs	pneedz			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 35		: dispatcher error # 36
	j	gkill			: crash slot
:	JN	GKILL			: valid ONLY from slot 0
pneedz	LR	R7,R7			: check for Permuter-table in timeout
	jefs	pneedy			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 36		: dispatcher error # 37
	j	gkill			: crash slot
:	JN	GKILL			: cause to Crash slot 0
					:
:	.......................................................................
:	Get the Pseudoneedle
:	.......................................................................
					:
pneedy	LR	R7,R1			: copy source port-number
	JAL	R4,GETH			: get slot Key
	LBR	R14.d,R0		: copy Key
	JAL	R4,GETH			: get Local Key
	STH	R0,TEMP			:
	JAL	R4,ELIR			: End-Logical-Input-Record
	LH	R0,I.CTL,R14.d		: check slot originating request
	JGE	PNEED4			: if down, just zap and forget it
	LHL	R8,I.PSIZ,R14.d		: get number of ports on slot
	AR	R8,R8			: index of last port
	L	R6,I.PTBL,R14.d		: get pointer to Destination's Permuter-table
PNEED1	LH	R0,0,R6,R8		: check a port
	JEFS	PNEED2			: skip if one found
	SIS	R8,2			: else keep searching
	JGBS	PNEED1			:
	JFS	PNEED3			: ran out...ABORT
					:
:	.......................................................................
:	Have a port on destination
:	at this point:
:	R5	Source Permuter-table index
:	R6	Destination Permuter-table base-address
:	R7	Source port-number
:	R8	Destination Permuter-table index
:	R14.d	Destination slot Key (Word-index)
:	.......................................................................
					:
PNEED2	JAL	R4,ALOCC.		: find a free channel
	 J	PNEED5			: found one
					:
:	.......................................................................
:	Can't complete connection...cancel it
:	.......................................................................
					:
PNEED3	LIS	R2,8			: tell Destination no circuit
	JAL	R4,SENDTO		:
	LHI	R0,09^8			: Pseudoneedle rejected and pad
	JAL	R4,SENDH		:
	LHL	R0,TEMP			: Local Key
	JAL	R4,SENDH		:
	LHI	R0,08^8			: Reason 8 = out_of_ports | pad
	JAL	R4,SENDH		:
	JAL	R4,TERM			:
PNEED4	LR	R14.d,R15.s		: return to sender:
	LR	R1,R7			: port-number
	JAL	R5,ZAPEM		:
	J	MMFR			: go back and examine next record
					:
:	.......................................................................
:	We have found an unassigned Channel (Path-pair)
:	R0	- Path 1 number
:	R1.p	- Path 0 (Forward) Path POINTER
:	R2	- Path 1 (Reverse) Path POINTER
:	R3	- Path 0 number
:	Since the CIRCUIT is Originating on the Destination slot, we connect IT
:	to path 0.
:	.......................................................................
					:
PNEED5	STH	R3,0,R6,R8		: connect destination P-table to path0
	STH	R7,P.PORT,R1.p		: connect path0 to source-port
					: (path-init. already set key to 0)
	L	R3,I.PTBL,R15.s		: locate source's Permuter-table base
	STH	R0,0,R3,R5		: connect Source Permuter-table to path1
	SRHLS	R8,1			: make Destination Port-number
	STH	R8,P.PORT,R2		: connect path1 to  Destination-port
	STB	R14.d,P.SLOT,R2		: connect path1 to Destination-slot
	LHI	R0,PA.ILI		: set path to LOGIN
	STB	R0,P.STAT,R1.p
	LR	R1.p,R2			: forward Pseudoneedle along path1
	LIS	R2,6			: set size of Pseudoneedle
	JAL	R4,CHECK		: place message
	LHI	R0,PNMSG^8		: Pseudoneedle (and pad)
	JAL	R4,SENDH
	LHL	R0,TEMP			: follow with Key
	JAL	R4,SENDH
	JAL	R4,TERM
	J	MMFR			: we're done...repeat

  if	LOG.II
:	DISPATCHER - LOG-II ISN logic

:	We have a port and an ISN (ISIS Needle) Message
:	format:		--------.-------.-------.--------
:			|      Port	|  C2	|XS....I|
:			|-------.-------+-------+-------|
:			|   length	|    reserved	|
:			|-------.-------+-------+-----------
:			|	   SMO list.......
:			------------------------------------
:       There are two ways we can get here...
:	On initial entry (i.e., new circuit)---then
:		R1 -	Port-number
:	On subsequent entry (i.e., circuit is already in place)---then
:		R1.p -	Path-pointer
:		r2 -	message-type
:	In both cases:
:		R5 -	2*Port-number
:		R6 -	Source Permuter-table base-address
:		R7 -	contents of Source Permuter-table entry
:		R15.s -	Source Slot Key
MSGISN	LA	R14,GKILL		: pointer to failure-routine
	LR	R15.s,R15.s
	jefs	msgisz			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 37		: dispatcher error # 38
	jr	r14			: crash slot
:	JNR	R14			: valid ONLY from slot 0

:	Zero out the descriptor
msgisz	LHI	R4,X4.SIZ-2
	LIS	R0,0
ISN1	STH	R0,LO.LEN,R4
	SIS	R4,2
	JGEBS	ISN1

:	Begin to get the ISN
	JAL	R4,GETH			: get type | XS....I
	LR	R8,R0			: save a copy
	SLHLS	R0,7
	STB	R0,LO.INT		: set Internal-flag
	JAL	R4,GETH			: get length
	AIS	R0,4			: length exclusive of RPORT
	STH	R0,LO.LEN		: save length
	LR	R7.PT.,R7.PT.		: is circuit already up?
	JEFS	ISN2			: no...skip to build it
	THI	R8,LII.SU		: yes...is this a Subsequent message?
	JER	R14			: no...first...something wrong here
	LHL	R0,P.PORT,R1.p		: yes...set up destination port
	STH	R0,LO.PRT
	LB	R14.d,P.SLOT,R1.p	: set destination
	J	FWDCIR			: go copy the circuit

:	Permuter table contains 0
ISN2	THI	R8,LII.SU		: is this a Subsequent message?
	JN	MSGTOS			: yes...just toss it
	STH	R1,LO.SPT		: record Source port
	STH	R5,LO.PTP		: record Source Permuter-table index

:	Get the remainder of the ISN...the SMO's........
	LR	R7,R1			: copy source port-number
	STH	R0,X4.LEN		: how much more there is
	JAL	R4,GET.X4		: skip over reserved
	JAL	R4,GET.X4
	JAL	R5,X4.RCV		: get first element...ISN MO
	JER	R14			: it's wrong!
	L	R0,X4.CLS		: Class . form . I . D
	CI	R0,MO.ISN		:  APL  . Cons . ISN
	JNR	R14			: he got it wrong
	JAL	R5,X4.RCV		: get second element...RMO MO
	JER	R14			: it's wrong!
	L	R0,X4.CLS		: Class . form . I . D
	CI	R0,MO.RMO		:  UNI  . Cons .  RMO
	JNR	R14			: he got it wrong
	JAL	R5,X4.RCV		: get third element...DIS MO
	JER	R14			: it's wrong!
	L	R0,X4.CLS		: Class . form . I . D
	CI	R0,MO.DIS		:  APL  . Cons . DIS
	JNR	R14			: he got it wrong
	STH	R2,X4.LFT		: OK...look only this far

:	Now scan SMO list for items of interest
ISN3	LH	R0,X4.LEN		: check for overrun
	JLR	R14
	LH	R0,X4.LFT		: again
	JE	ISN10			: exhausted it...skip out of loop
	JLR	R14
	JAL	R5,X4.RCV		: get the next element
	JER	R14			: error some place
	JAL	R5,X4.RV		: get the value too
	L	R0,X4.CLS		: Class . form . I . D
	CI	R0,MO.INV		:  APL  . Cons . Invoice
	JNFS	ISN4			: not it
	L	R0,X4.VND-4		: get 32-bit value
	ST	R0,LO.INV+2		: Invoice
	LHL	R0,X4.VND-6		: get 16-bit value
	STH	R0,LO.INV
	J	ISN3			: and try for another

ISN4	CI	R0,MO.DHO		:  APL  . Cons . Term_host
	JNFS	ISN5			: not it
	LHL	R0,X4.VND-2		: get 16-bit value
	STH	R0,LO.HST		: Destination Host
	J	ISN3			: and try for another

ISN5	CI	R0,MO.FLA		:  APL  . Cons . Flags
	JNFS	ISN6			: not it
	LB	R0,X4.VND-1		: get 8-bit value
	STB	R0,LO.AUX		: flags...bit 0 set if AUX
	J	ISN3			: and try for another

ISN6	CI	R0,MO.OPT		:  APL  . Cons . Orig_port
	JNFS	ISN7			: not it
	LHL	R0,X4.VND-2		: get 16-bit value
	STH	R0,LO.OPT		: Origination-port
	J	ISN3			: and try for another

ISN7	CI	R0,MO.SHU		:  APL  . Cons . Shut_override
	JNFS	ISN8			: not it
	LB	R0,X4.VND-1		: get 8-bit value
	STB	R0,LO.SHU		: shut override
	J	ISN3			: and try for another

ISN8	CI	R0,MO.IIX		:  APL  . Cons . IIX
	JN	ISN3			: not it
	LB	R0,X4.VND-1		: get 8-bit value
	STB	R0,LO.IIX		: IIX indicator
	J	ISN3			: and try for another




:	We have extracted the information from the SMO list
ISN10	LCS	R0,1			: host-any-slt-key
	STH	R0,HSTSVE
	LHL	R0,LO.HST		: get host number
	JAL	R4,FNDHST		: locate the target host
	JEFS	ISN11			: we found it!
	LA	R2,NOHOST		: else set no_host_found message
	J	NOCIR			: no host found...send message

:	We have located the destination host
ISN11	LHL	R14.d,H.SKEY,R1		: get host's slot key
	LB	R0,H.STAT,R1		: check Host-state
	NHI	R0,03			: isolate Host-state bits
	JEFS	ISN12			: 0 = Answered...proceed
	LA	R2,HOSTDN		: in case it's down
	SIS	R0,01			: DOWN?
	JE	NOCIR			: yes...abort logon
	LB	R4,LO.SHU		: must be SHUT...check shut-override
	JNFS	ISN12			: yes...let him go
	LA	R2,HOSTSH		: NOT override...Host-Shut msg
	J	NOCIR			: lock user out

:	Host is up and answered...Proceed
ISN12	LHL	R9,I.PSIZ,R14.d		: find a Destination-port
	AR	R9,R9			: index of last port
	L	R8,I.PTBL,R14.d		: locate Destination's Permuter-table
ISN13	LHL	R0,0,R9,R8		: check an entry
	JEFS	ISN14			: got one...skip to service it
	SIS	R9,2			: try next port
	JGBS	ISN13			: repeat for all ports
	LA	R2,OUTPRT		: none there...set message
	J	NOCIR			: abort

:	Have a port on Destination
:	At this point:
:	R6.pt	Base-address of slot 0 Permuter-table
:	R7	Slot 0 port-number
:	R8	Base address of Destination Permuter-table
:	R9	Destination Permuter-table index
:	R14.d	Destination slot Key (Word-index)
ISN14	LH	R0,LO.INT		: check source of LOGON
	JGE	ISN20			: external LOGON...skip

:	This LOGON is coming from us, and looped out through slot 0...
:	look up and remove this extraneous loop
	LHL	R1,LO.OPT		: get real port
	jnfs	isnz			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 38		: dispatcher error # 39
	j	gkill			: crash slot
:	JE	GKILL			: 0 is silly
isnz	CLH	R1,I.PSIZ,R15.s		: Range-check
	jlefs	isny			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 39		: dispatcher error # 40
	j	gkill			: crash slot
:	JG	GKILL			: crash if Orig. port is out of range
isny	AR	R1,R1			: make Permuter-table index
	LH	R2,0,R1,R6		: and get it
	JGFS	ISN15			: skip if internal circuit was Zapped
	LA	R2,ORIZAP		: else say Zapped by user
	J	NOCIR			: and abort it

ISN15	LIS	R0,0
	STH	R0,0,R1,R6		: clear that entry
	STH	R2,0,R9,R8		: move entry to Dest. Permuter-table
	CPFPN(R2,R1.p)			: compute path from path-number
	LHL	R0,LO.HST		: record destination host
	STH	R0,P.HOST,R1.p		: ...in backward path
	COPOP(R1.p,R1.p)		: compute other path (Channel / Path0)
	ST	R1.p,CURPAT		: save path index for later
	LB	R4,P.STAT,R1.p		: get path-state
	NHI	R4,@(PA.DHU!PA.ILI!PA.LII) : cancel DHU, LOGIN, LOGII
	SRHLS	R9,1			: make port-number
	STH	R9,LO.PRT		: save destination-port
	STH	R9,P.PORT,R1.p		: plug into path
	LHL	R0,C.STAT,R1.p		: make Accounting connection
	LHI	R5,X.IPC.
	NH	R5,I.CTL+2,R14.d
	JEFS	ISN16			: ISN Destination is TYMCOM side
	AIS	R0,CA.PCO		: set channel to project-code open
	OHI	R4,PA.CPC		: set project code
ISN16	OH	R0,C.STAT,R1.p		: update acct. info. for origination
	STH	R0,C.STAT,R1.p		: set new Channel-state
	STB	R4,P.STAT,R1.p		: set new Path-state
	STB	R14.d,P.SLOT,R1.p	: connect Path to this slot
	STH	R14.d,LO.KEY		: save destination-pointer
	lhl	r2,p.bct,r1.p		: is there data to process? ***ern
	je	isn18			: yes => unlink from node and link to dest
:	unlink from linked list
	l	r2,p.last,r1.p		: pointer to our last
	l	r3,p.next,r1.p		: pointer to our next
	st	r3,p.next,r2		: link last to next
	jefs	isn17			: skip if next is null
	st	r2,p.last,r3		: link next back to last
:	Do linked-list insert
isn17	la	r3,i.que,r14.d		: pointer to queue
	la	r2,p.next,r1.p		: convert to pointer
	st	r3,p.last,r1.p		: point back to queue
	l	r3,i.que,r14.d
	st	r2,i.que,r14.d		: link queue to this
	st	r3,p.next,r1.p		: link this to previous queue head
	jefs	isn18			: null?
	st	r2,p.last,r3		: no...link new next back to this
isn18	LR	R14.d,R15.s		: now Zap the circuit going back
	LR	R1,R7			: source port-number
	JAL	R5,ZAPEM
	LHL	R14.d,LO.KEY		: restore Destination slot Key
	L	R1.p,CURPAT		: restore Path-pointer
	J	SNDACT			: and skip to pass it on, set up Accounting

:	Circuit comes from external Source
ISN20	JAL	R4,ALOCC.		: go allocate a Channel
	 J	ISN21			: got one
	LA	R2,NOCHAN		: failed...set reason
	J	NOCIR			: and abort

:	We have found an unassigned Channel (Path-pair)
:	R0	- Path 1 number
:	R1.p	- Path 0 (Forward) Path POINTER
:	R2	- Path 1 (Reverse) Path POINTER
:	R3	- Path 0 number
ISN21	STH	R0,0,R8,R9		: connect Destination P-table to path1
	STH	R7,P.PORT,R2		: connect path1 to source-port
	LHL	R0,LO.HST		: record destination host
	STH	R0,P.HOST,R2		:  ...in backward path
	LHL	R5,LO.PTP		: restore permuter-table offset
	STH	R3,0,R5,R6.pt		: connect Source Permuter-table to Path0
	SRHLS	R9,1			: make Destination port-number
	STH	R9,LO.PRT
	STH	R9,P.PORT,R1.p		: connect path0 to Destination-port
	STB	R14.d,P.SLOT,R1.p	:  ...and to Destination-slot
	LIS	R2,CA.CTO		: set Channel-state to Counts open
	LIS	R0,0			: source may be vanilla
	LHI	R4,X.IPC.
	NH	R4,I.CTL+2,R14.d
	JEFS	ISN22
	AIS	R2,CA.PCO		: set project-code open too
	AIS	R0,PA.CPC		: path is to collect it
ISN22	STB	R0,P.STAT,R1.p		: set this path's new state
	STH	R2,C.STAT,R1.p		: set this channel's new state
	J	SNDACT			: and skip to pass it on, set up Accounting
:	DISPATCHER - LOG-II ASLP logic

:	We have a free port and a LOG-II ASLP message from Node code
:	format:		--------.-------.-------.--------
:			|    RPORT	|  C5	| unused|
:			|-------.-------+-------+-------|
:			|    slot Key	|   local key	|
:			---------------------------------
ASLP	LR	R15.s,R15.s
	jefs	aslpz			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 40		: dispatcher error # 41
	j	gkill			: crash slot
:	JN	GKILL			: valid ONLY from slot 0
aslpz	LR	R7,R7			: check for Permuter-table in timeout
	jefs	aslpy			: it's ok!
	stm	r0,dspreg		: save register set F
	lhi	r5,$a 41		: dispatcher error # 42
	j	gkill			: crash slot
:	JN	GKILL			: ...cause to crash slot 0

:	Get the ASLP
aslpy	LR	R7,R1			: copy source port-number
	JAL	R4,GETH			: toss C5 | unused
	JAL	R4,GETH			: get slot Key
	LBR	R14.d,R0		: make copy
	JAL	R4,GETH			: get Local Key
	STH	R0,TEMP
	JAL	R4,ELIR			: End-Logical-Input-Record
	LH	R0,I.CTL,R14.d		: check slot which originated request
	JGE	ASLP4			: if down, just zap and forget it
	LHL	R8,I.PSIZ,R14.d		: get number of ports on slot
	AR	R8,R8			: index of last port
	L	R6,I.PTBL,R14.d		: get pointer to Destination's Permuter table
ASLP1	LH	R0,0,R6,R8		: check a port
	JEFS	ASLP2			: skip if one found
	SIS	R8,2			: else keep searching
	JGBS	ASLP1
	JFS	ASLP3			: ran out...abort

:	Have a port on Destination
:	At this point:
:	R5	Source Permuter-table index
:	R6	Destination Permuter-table Base address
:	R7	Source Port-number
:	R8	Destination Permuter-table index
:	R14.d	Destination slot Key (Word-index)
ASLP2	JAL	R4,ALOCC.		: find a free channel
	 J	ASLP5			: found one

:	Can't complete connection...cancel it
ASLP3	LHI	R2,$A 16		: tell Destination no circuit
	JAL	R4,SENDTO
	LHI	R0,1200			: ECRM | X....A
	JAL	R4,SENDH
	LIS	R0,9			: length
	JAL	R4,SENDH
	LR	R0,R14.d		: slot Key
	JAL	R4,SENDH
	LHL	R0,TEMP			: Local Key
	JAL	R4,SENDH
	LHI	R0,3103			: RMO
	JAL	R4,SENDH
	LI	R0,5F290100		: out of ports!
	JAL	R4,SENDW
	JAL	R4,TERM
ASLP4	LR	R14.d,R15.s		: return to sender:
	LR	R1,R7			: port-number
	JAL	R5,ZAPEM
	J	MMFR			: go back and examine next message

:	We have found an unassigned Channel (Path-pair)
:	R0	- Path 1 number
:	R1.p	- Path 0 Path POINTER
:	R2	- Path 1 Path POINTER
:	R3	- Path 0 number
:	Since CIRCUIT Originates on Destination Slot, we connect IT to Path0.
ASLP5	STH	R3,0,R8,R6		: connect Destination P-table to path0
	STH	R7,P.PORT,R1.p		: connect path0 to source-port
	L	R3,I.PTBL,R15.s		: locate source's Permuter-table base
	STH	R0,0,R3,R5		: connect source Permuter-table to path1
	SRHLS	R8,1			: make destination port-number
	STH	R8,P.PORT,R2		: connect Path1 to  Destination-port
	STB	R14.d,P.SLOT,R2		:  ...and to Destination-slot
	LHI	R0,PA.ILI!PA.LII	: set LOGIN, LOGII
	STB	R0,P.STAT,R1.p		:  ...for path0
	LR	R1.p,R2			: forward ASLP along path1
	LIS	R2,8			: set size of ASLP
	JAL	R4,CHECK		: Place message
	LHI	R0,ASLPMG^8		: ASLP (and pad)
	JAL	R4,SENDH
	LR	R0,R14.d		: follow with slot Key
	JAL	R4,SENDH
	LHL	R0,TEMP			: ..and Local Key
	JAL	R4,SENDH
	JAL	R4,TERM
	J	MMFR			: we're done...repeat

  ei	:LOG.II

:	.......................................................................
:	Circuit-building utility-routines
:
:	Can't complete connection...cancel it
:	Expects	R2	Pointer to message to use for report
:		R7	Origination Port-number
:		R15.s	Source-slot Key
:		LO.INT	<0 if Internal-circuit
:		LO.AUX	<0 if Aux-circuit
:		LO.SPT	Source Port-number
:		LO.PTP	Source Permuter-table pointer
:		LO.INV	INVOICE-number
:	.......................................................................
					:
NOCIR	L	R6.pt,I.PTBL,R15.s	: get pointer to source Permuter-table
	LIS	R0,0			: release source-port
	LHL	R5,LO.PTP		: source Permuter-table entry
	STH	R0,0,R5,R6.pt		:
	LHL	R0,0,R2			: get termination-reason
	STH	R0,LO.WHY		:
	LA	R3,2,R2			: bump pointer past reason
	LR	R14.d,R15.s		: send message back
	LHL	R0,LO.AUX		: is this AUX circuit?
	JLFS	NOCIR1			: skip if AUX-circuit
	LR	R2,R3			: copy Message-pointer
	LR	R1,R7			: Port-number
	JAL	R5,SMP			: send Message for Port
	LR	R1,R7			: recover port-number
	LA	R2,IDMSG		: identify Source
	JAL	R5,SMP			: send it
NOCIR1	LR	R1,R7			: now send Detach to Node-code
	JAL	R4,SPEED		:
	LHI	R0,DETMSG^8		: Detach
	JAL	R4,SENDH		:
	JAL	R4,TERM			: and terminate message
	LA	R4,LO.INV		: Invoice-number
	JAL	R12,AASIR		: send an Accounting Invoice-Record
	LHL	R6,LO.WHY		: Reason for termination of Accounting
	OI	R6,0E0000000		: Special msg with Accounting Heading
	JAL	R5,AASAR		:
					:

:	.......................................................................
:	Toss away a message
:	Expects	R15.s	Source Slot Key
:		LO.LEN	message-length exclusive of RPORT
:	.......................................................................
					:
MSGTOS	JAL	R4,LOOK			: back up to beginning of message
	LHL	R0,LO.LEN		: flush source-message
	JAL	R4,FLUSH		:
	J	MMFR			:
					:
:	.......................................................................
:	Set up Accounting
:	Expects	R1.p -	Path0 pointer
:		LO.INV-	Invoice-number
:	.......................................................................
					:
SNDACT	JAL	R4,AASINV		: place Invoice into Channel
					:
:	.......................................................................
:	Forward Circuit-Message on to Destination
:	Expects	R14.d	Destination Slot Key
:		LO.LEN	Length of message exclusive of RPORT
:		LO.PRT	Destination port
:	.......................................................................
					:
FWDCIR	JAL	R4,LOOK			: Back up over Message
	LHL	R5,LO.LEN		: get size of Message
	LHI	R2,2,R5			: compute total size
	LHL	R1,LO.PRT		: get destination port again
	JAL	R4,CHUCK		: insure there's room there
FWDCI1	JAL	R4,GETH			: copy body of Message
	JAL	R4,SENDH		:
	SIS	R5,2			:
	JGBS	FWDCI1			:
	JAL	R4,ELIR			: End-Logical-Input-Record
	JAL	R4,TERM			: Terminate Transmission
	J	MMFR			:
					:
  if	LOG.II
	SUBTTL	LOG-II/X.409 receivers

:	.......................................................................
:	internal routine to get another byte, update the counters
:	R4 =	Link register
:	R0 =	byte returned
:	.......................................................................
					:
GET.X4	LCS	R0,1			: decrementer
	AHM	R0,X4.LEN		: total length
	AHM	R0,X4.LFT		: left in list
	J	GETCH			: exit via GETCH, which returns value
					:
:	.......................................................................
:	X.409 receiver
:	Interprets an overall X.409 element
:	R5 =	Link register
:	R0,R2-R4 smashed
:	Returns Condition Codes reflecting value of length
:		length in R2
:	.......................................................................
					:
X4.RCV	JAL	R4,GET.X4		: get first byte of ID field
	LR	R4,R0			: extract CLASS and FORM
	SRHLS	R4,5			:
	CLHI	R4,3			: > Application?
	JLEFS	X4.RC1			: no
	OHI	R4,-2			: yes...set to -1
X4.RC1	STH	R4,X4.CLS		: save it
	LHI	R2,1F			: extract ID
	NR	R2,R0			:
	CHI	R2,1F			: indefinite?
	JNFS	X4.RC3			: no
	LIS	R2,0			: yes...must scan additional bytes
X4.RC2	JAL	R4,GET.X4		: get another byte....
	LHI	R4,7F			: extract value
	NR	R4,R0			:
	SLLS	R2,7			:
	OR	R2,R4			: accumulate it
	XR	R0,R4			: check continue
	JNBS	X4.RC2			: ...while byte & 80 != 0
X4.RC3	STH	R2,X4.ID		: save ID
	JAL	R4,GET.X4		: get first byte of length
	LHI	R2,7F			: extract it
	NR	R2,R0			:
	CLHI	R0,80			: indefinite?
	JEFS	X4.RC5			: yes...return FALSE
	XR	R0,R2			: no...is extension-bit set?
	JEFS	X4.RC5			: no
	LR	R3,R2			: N...accumulate this many more bytes
	LIS	R2,0			: initialize accumulator
X4.RC4	JAL	R4,GET.X4		: get another byte....
	SLLS	R2,8			:
	OR	R2,R0			: accumulate it
	SIS	R3,1			: done yet?
	JNBS	X4.RC4			: ...while N > 0
X4.RC5	LR	R2,R2			: set condition codes
	JR	R5			: and exit
					:
:	.......................................................................
:	X.409 Value receiver
:	expects value length in R2 ("V").
:	accumulates up to length bytes in X4.VAL,
:		right justified, with 0 left fill
:	.......................................................................
					:
X4.RV	LIS	R3,X4.VSZ-1		: N...cursor
	LIS	R0,0			: 0-fill
X4.RV1	STB	R0,X4.VAL,R3		: while N-- > 0...
	SIS	R3,1			:
	JGEBS	X4.RV1			: ...0-fill buffer
	LIS	R3,X4.VSZ-1		: N...cursor
X4.RV2	SIS	R2,1			: while --V > N...
	CR	R2,R3			:
	JLEFS	X4.RV3			:
	JAL	R4,GET.X4		: ...toss some data
	JBS	X4.RV2			: ...
X4.RV3	SR	R3,R2			: N...cursor
X4.RV4	JAL	R4,GET.X4		: while V-- >= 0...
	STB	R0,X4.VAL,R3		:
	AIS	R3,1			:
	SIS	R2,1			:
	JGEBS	X4.RV4			: ...get next byte
	JR	R5			: done

  ei	:LOG.II

	SUBTTL	DISPATCHER - TIMEOUT Processing

:	.......................................................................
:
:		*********************************
:		*				*
:		*	TIMEOUT PROCESSING	*
:		*				*
:		*********************************
:
:	.......................................................................
					:
:	.......................................................................
:	Initialize TIMEOUT-list
:	.......................................................................
					:
IZT	ST	R0,RET			:
  if	NETMON				:
	LIS	R5,0			: beginning Immediately,
	LA	R6,RATIME		: put Command-channel throttler on Queue,
	LI	R7,$A RATE*60*2		: then do every two minutes
	JAL	R8,TOPUT		:

  ei
	LHI	R5,RATE*5		: beginning in 5 seconds,
	LA	R6,ZAPP			: put slot timeout-checking on Queue,
	LHI	R7,$A RATE*16		: then do every 16d seconds
	JAL	R8,TOPUT

	LHI	R5,RATE			: beginning in 1 second,
	LA	R6,AATIME		: put Accounting onto Queue,
	LI	R7,$A RATE*60*20/NCHAN	: and do all Channels every 20 minutes
	JAL	R8,TOPUT

	LI	R5,RATE*60*20		: beginning in 20 minutes,
	LA	R6,USAGE		: put Usage onto Queue,
	LR	R7,R5			: and do all Slots every 20 minutes
	JAL	R8,TOPUT
	L	R0,RET
	JR	R0

TORET	L	R0,TO9			: TIMEOUT-routines exit here

:	Call next TIMEOUT-routine (if any) that has become due
TIMOUT	L	R5,FASTC
	L	R3,TLIST
	CL	R5,T.TIME,R3		: is 1st active list TIMEOUT due?
	JLR	R0			: no TIMEOUTs due to process
	ST	R0,TO9			: Routine MUST terminate by jumping to TORET
	L	R4,T.NEXT,R3
	ST	R4,TLIST		: shorten active-list
	L	R8,T.ADDR,R3
	A	R5,T.INTV,R3		: do again T.INTV from now
	JFS	TPT1			: go put back onto TIMEOUT list, then execute

:	Put an entry on Active Timeout-list, for PERIODIC activation.
:	R5 -	(Relative) Time to activate it (from NOW)
:	R6 -	Execution address
:	R7 -	interval between activations
:	R8 -	Link
TOPUT	JAL	R4,GETBFL		: we'll use a bufferlet for this
	A	R5,FASTC		: "now"
	ST	R6,T.ADDR,R3		: initialize execution address
	ST	R7,T.INTV,R3		: initialize time-interval

:	find active-list entry between earlier, later TIMEOUT
:	(Also used by TIMOUT)
:	R3 -	POINTER to entry
:	R5 -	Time of next activation
:	R8 -	return (or activation) address
TPT1	ST	R5,T.TIME,R3		: initialize start-time
	LA	R2,TLIST		: address of first pointer
TPT2	LR	R1,R2
	L	R2,T.NEXT,R2		: check next TIMEOUT-entry
	JEFS	TPT3			: active-list is exhausted
	CL	R5,T.TIME,R2		: is it earlier than Argument Due-time
	JGEBS	TPT2			: yes, continue til R1 is earlier
					:  and R2 is later
TPT3	ST	R3,T.NEXT,R1		: make earlier Active-list entry
					:   point to new entry
	ST	R2,T.NEXT,R3		: make new entry point to next
					:  greater TIMEOUT-entry
	JR	R8			: return


  if	NETMON

:	Routine to update the Rate-limit for Channel-0 usage
RATIME	LHI	R14.d,NSLOT*4		: for all slots
	LHI	R0,-NETMON		: reset the limit
RATT0	ST	R0,I.RATE,R14.d,R14.d	: ***etm/pwk
:RATT0	STH	R0,I.RATE,R14.d
	SIS	R14.d,4
	JGEBS	RATT0
	J	TORET
  ei


:	Routine to TIMEOUT Detached-circuits and disconnect them
ZAPP	LHI	R14.d,NSLOT*4		: for ( d = nslot , , --d > 0 )
ZAPP1	L	R0,I.CTL,R14.d		: { if (    ( slot_state == active )
	JGEFS	ZAPP4
	LHL	R12,I.PSIZ,R14.d	:	 && ( nport > 0 )
	JEFS	ZAPP4			:      )
	AR	R12,R12			:   {	R12 = 2*nport, R13 = &Permuter_table
	L	R13,I.PTBL,R14.d	:	while ( R12-- > 0 )
ZAPP2	LH	R2,0,R12,R13		:	{ if ( *r13[R12] < 0 )
	JLFS	ZAPP5			:	    goto port_in_state
ZAPP3	SIS	R12,2			:	}
	JGBS	ZAPP2			:   }
ZAPP4	SIS	R14.d,4			: } repeat for all slots
	JGE	ZAPP1
	J	TORET			: and exit

:	Found a port in timeout/cleanup (it was <0)
ZAPP5	THI	R2,4000			: see if CLEANUP-state
	JEBS	ZAPP3			: ignore if so
	NHI	R2,3FFF			: isolate path-number
	CPFPN(R2,R1.p)			: compute path from path-number
	LIS	R0,1			: bump timer
	AHM	R0,P.HIST,R1.p
	JL	ZAPP3			: skip if not yet timed-out
	LIS	R0,X.PNR.
	NH	R0,I.CTL+2,R14.d	: see if PNR option on
	JNFS	ZAPP6			: skip if so
	JAL	R4,RELS.C		: release channel
	LIS	R0,0			: set no longer in use
	JFS	ZAPP7

ZAPP6	LHI	R0,8000,R2		: change to CLEANUP-state
ZAPP7	STH	R0,0,R12,R13		: set Permuter-table entry
	CHK.PN(R0)
	JAL	R5,DCTBOP		: empty & disconnect Path
	LR	R1,R12			: just timed-out
	SRHLS	R1,1			: re-compute port-number
	JAL	R5,ZAPEM		: ZAP the circuit
	J	ZAPP3			:
					:
:	.......................................................................
:	Routine to make periodic report of all Accounting data
:	CYCLE through ALL channels...manipulates Channel-pointer
:	.......................................................................
					:
AATIME	LA	R11,TORET		: set return-address
	L	R7,AACC.		:
	SHI	R7,C.LEN		: do for the next Channel
	JGFS	AATIM1			:
	LI	R7,(NCHAN-1)*C.LEN	:
AATIM1	ST	R7,AACC.		: save for next time
	LA	R7,C.POOL,R7		: convert to pointer
	J	AACNTS			: send counts / exit
					:
:	.......................................................................
:	Routine to make periodic report of all slots which required buffering
:	CYCLE through ALL slots
:	.......................................................................
					:
USAGE	LHI	R15.s,NSLOT*4		:
USAGE1	LH	R13,I.USING,R15.s	: check a slot
	JEFS	USAGE2			: not used...no reason for report
					:
:	.......................................................................
:	Send diagnostic to Slot 0
:	.......................................................................
					:
	LIS	R11,4			: Diagnostic type = 4
	LR	R12,R15.s		: copy slot key
	SRHLS	R12,2			: DATA1 = slot number
	LIS	R13,0			: DATA2 = 0
	JAL	R5,DIAG,,		: send it
	LIS	R13,0
	STH	R13,I.USING,R15.s	: clear flag
USAGE2	SIS	R15.s,4
	JGEBS	USAGE1			: repeat for all slots
	J	TORET			: exit
	SUBTTL	DISPATCHER - General Routines

:	Disconnect Slot specified by R15.s
:	R6 -	Link register
DCSLOT	LH	R0,I.CTL,R15.s		: check out slot
	JGER	R6			: just exit of already DOWN
	LR	R15.s,R15.s		: crashing slot 0?
	JNFS	DCSL0			: no
	STB	R15.s,SUP.SP		: yes...no sup left!
DCSL0	TS	SAVE			: set flag to save work if no ports active
	L	R1.p,I.CPATH,R15.s	: for port0...
	JAL	R4,EMPTY		: ...Just empty the input-Path
	LIS	R0,0
	STH	R0,P.HIST,R1.p		: cancel history
	L	R12,I.PTBL,R15.s	: start of Permuter-table
	LHL	R11,I.PSIZ,R15.s	: get number of ports
	JE	DCSL6			: in case slot has zero data-ports,
					: ...don't ZAP Control-port
	AR	R11,R11			: make index to last entry

:	first, clear paths for these ports
DCSL1A	LH	R13,0,R11,R12		: get path # ***ern
	JLEFS	DCSL1B			: jump if not active
	CPFPN(R13,R1.p)			: compute path from path#
	JAL	R4,EMPTY		: clear it
	COPOP(R1.p,R1.p)		: compute other path of pair
	JAL	R4,EMPTY		: clear it also
DCSL1B	SIS	R11,2			: repeat for each entry
	JG	DCSL1A
	LHL	R11,I.PSIZ,R15.s	: get number of ports
	AR	R11,R11			: make index into last entry

:	next, terminate all Accounting for these ports
DCSL1	LH	R13,0,R11,R12		: get a Permuter-table entry
	JGE	DCSL2			: not on TIMEOUT
	LIS	R0,0			: Timing out...cancel it
	STH	R0,0,R11,R12
	NHI	R13,3FFF		: extract path-no
	CPFPN(R13,R1.p)			: compute path
:	JAL	R4,EMPTY		: empty it
	JAL	R4,RELS.C		: ...and release channel
	LR	R13,R13			: reset CC
DCSL2	JEFS	DCSL3			: skip if not active
	STM	R6,SAVE			: port active...save registers
	CPFPN(R13,R1.p)			: compute path from path-number
	LIS	R0,1			: set HOST_DOWN reason
	JAL	R4,AATERM		: go terminate the Accounting
	LM	R6,SAVE			: restore Registers
DCSL3	SIS	R11,2			: repeat for each entry
	JG	DCSL1			: ...other than port0

:	All accounting is now processed, port0 is taken care of
	LH	R0,SAVE			: check out our flag
	JL	DCSL6			: no ports active...just finish cleaning up

:	Some ports are active...tear them down, gracefully
	LHL	R13,I.PSIZ,R15.s	: repeat scan, Disconnecting all (start w/P1)
	LIS	R0,0
DCSL4	LH	R2,2,R12		: check an entry
	STH	R0,2,R12		: set it null...this may be redundant,
					:  but an internal circuit may have
					:  wrapped back
	JLEFS	DCSL5			: skip if NULL or TIMING out
	CPFPN(R2,R1.p)			: compute Path from Path-number
	ST	R1.p,CURPAT		: record current path
	LB	R14.d,P.SLOT,R1.p	: find Destination Key
	JAL	R5,DCZAP
	LIS	R0,0			: restore constant
DCSL5	AIS	R12,2			: repeat for all entries
	SIS	R13,1
	JG	DCSL4

:	Take all HOSTS on a SLOT to GONE state, and report
DCSL6	LR	R11,R6			: copy return-address
	L	R13,I.UTBL,R15.s	: get pointer to tables
	LHL	R12,I.HSIZ,R15.s	: and number of entries
	SIS	R12,1
	JLR	R11			: exit if none
	AR	R12,R12			: else compute End-address
DCSL7	LB	R0,0,R12,R13		: get an entry
	XHI	R0,0C0
	THI	R0,0C0			: test if already GONE
	JE	DCSL8			: skip if so
	L	R4,I.HTBL,R15.s		: look up Host-number
	LH	R0,0,R4,R12
	JEFS	DCSL8			: null host
	STH	R15.s,HSTSVE		: source slot-key
	JAL	R4,FNDHST
	JNFS	DCSL8			: not there
	LIS	R0,3			: else set GONE
	STB	R0,H.STAT,R1
	LR	R5,R1			: copy pointer
	JAL	R6,SNDHST		: send host-report
					: (reporting GONE host removes from table too)
DCSL8	LHI	R0,0C000
	OH	R0,0,R12,R13		: set slot gone
	STH	R0,0,R12,R13
	SIS	R12,2			: check next entry
	JGE	DCSL7
	JR	R11			: then exit


:	Disconnect Destination
:	R1.p	Path pointer
:	SAVE	Message-type (DETMSG, ZAPMSG)
:	Link on R5
:	Uses SAVE as temp
DCZAP	LHI	R2,ZAPMSG^8		: Zap it
	STH	R2,SAVE

DCDEST	LH	R4,P.PORT,R1.p		: verify Destination
	JL	DCOBOP			: just disconnect other Path if not in use

:	Final disconnection of Destination
	AR	R4,R4
	A	R4,I.PTBL,R14.d		: calculate Permuter-table entry-address
	ST	R4,DCTEMP		: save it
	LB	R2,SAVE			: get Message-type
	CLHI	R2,DETMSG		: is this DETACH?
	JNFS	DCD1			: skip if not
	LCS	R3,4			: set up TIMEOUT-timer
	STH	R3,P.HIST,R1.p
	LHI	R3,0C001		: set TIMEOUT-flags
	LHI	R0,YBMSG^8		: send Yellow-ball
	STH	R0,SAVE			:  ...instead of Zapper
	J	DCD3			: and skip to finish up

DCD1	LIS	R3,0
	STH	R3,P.STAT,R1.p		: close path
	LIS	R3,X.PNR.		: ZAPPER, no CLEANUP unless PNR
	NH	R3,I.CTL+2,R14.d	: test control-bits
	JNFS	DCD2			: skip if so
:	JAL	R4,EMPTY		: else empty this Path
	JAL	R4,RELS.C		: set Channel Not_assigned
	LIS	R3,0			: set port-available value
	JFS	DCD4			: and skip

DCD2	LHI	R3,8001			: PNR...set CLEANUP-state
DCD3	XH	R3,P.NO,R1.p		: compute Path-number from path-pointer
DCD4	L	R4,DCTEMP
	STH	R3,0,R4			: set Destination Permuter-table
	LHL	R1,P.PORT,R1.p		: get port
	JAL	R4,SPEED		: send to Ring or Control-Buffer
	LHL	R0,SAVE			: get Message back
	JAL	R4,SENDH
	JAL	R4,TERM
	L	R1.p,CURPAT		: get Path-pointer again
					:
:	.......................................................................
:	Disconnect OTHER/THIS Path of pair
:	R1.p	Path-pointer
:	.......................................................................
					:
DCOBOP	COPOP(R1.p,R1.p)		: compute Other Buffer of Pair
DCTBOP	JAL	R4,EMPTY		: Empty it
	LCS	R0,1			:
	STH	R0,P.PORT,R1.p		: flag other Path's destination NULL
	LIS	R0,0			:
	STB	R0,P.STAT,R1.p		: close path
	JR	R5			: then return
					:
	SUBTTL	DISPATCHER - Channel Management

:	.......................................................................
:	Allocate a Channel
:	Link -	R4
:	Returns	SKIP-4 return if no channels left
:	Else	NORMAL return, with Channel ALLOCATED:
:	R0 -	Path 1 NUMBER
:	R1 -	Channel/Path 0 POINTER
:	R2 -	Path 1 POINTER
:	R3 -	Path 0 NUMBER
:	.......................................................................
					:
ALOCC.	L	R1.p,C.FREE		: get a channel
	JE	4,R4			: none there...SKIP-4 return
	CI	R1.p,C.POOL+(nslot+2)/2*c.len
	JL	CHNERR			:
	CI	R1.p,C.PEND-P.LEN	:
	JG	CHNERR			:
	lh	r0,c.used,r1.p		: channel already in use?
	je	chnerr			: yes, die ***etm
	L	R0,C.NEXT,R1.p		: else unlink it
	ST	R0,C.FREE		:
	LIS	R0,0			: initialize the Channel
	LA	R2,C.LEN,R1.p		: END...POINTER past end
	LH	R3,P.NO,R1.p		: keep path-number aside
ALOCC1	SIS	R2,4			: while ( END-- > BEGIN ) *END = 0
	ST	R0,0,R2			:
	CR	R2,R1.p			:
	JNBS	ALOCC1			:
	LA	R2,P.LEN,R1.p		: POINTER to Path 1
	LHI	R0,P.LEN		:
	STH	R0,P.BIAS,R1		:
	LHI	R0,-P.LEN		:
	STH	R0,P.BIAS,R2		:
	STH	R3,P.NO,R1		: restore Path0 path-number
	LHI	R0,1,R3			: next path
	STH	R0,P.NO,R2		:
	JR	R4			: done...NORMAL return
					:
CHNERR	D.CRSH(0E,R4)			: else crash
					:
:	.......................................................................
:	Release a Channel
:	Link -	R4
:	Expects	R1.p -	Path-pointer
:	Smashes R0, R2
:	.......................................................................
					:
RELS.C	CCFP(R1.p,R2)			: compute Channel from Path
	CI	R1.p,C.POOL+(nslot+2)/2*c.len	: range-check on Path-pointer
	JL	CHNERR			:
	CI	R1.p,C.PEND-P.LEN	:
	JG	CHNERR			:
	ts	c.used,r2		: channel already on free list?
	jn	chnerr			: yes, die ***etm
	st	r2,s.save		:
	st	r3,s.save+4		:
	st	r4,s.save+8		:save some registers
	jal	r4,empty		:
	copop(r1.p,r1.p)		:find other path
	jal	r4,empty		:empty it too
	copop(r1.p,r1.p)		:back to original
	l	r2,s.save		:
	l	r3,s.save+4		:
	l	r4,s.save+8		:restore the registers
	L	R0,C.FREE		: link back onto list
	ST	R0,C.NEXT,R2		:
	ST	R2,C.FREE		:
	JR	R4			: done...return
					:
	SUBTTL	DISPATCHER - Accounting

:	.......................................................................
:	Circuits have a TYMSAT side and a TYMCOM side, the TYMSAT
:	side receives Successful-LOGON, and TYMCOM side receives NEEDLE
:	P.STAT(Buffer) gives the Accounting-state for the Termination
:	of the circuit in the direction of the Path.  Accounting
:	is done only for the "NEEDLE half" of the circuit
:
:	Set Channel Invoice
:	Call	JAL	R4,AASINV
:	Expects	LO.INV	INVOICE-number
:		R1.p	Channel / Path 0 pointer
:	.......................................................................
					:
AASINV	L	R0,LO.INV+2		: install Invoice-number
	ST	R0,C.INV+2,R1.p		:
	LHL	R0,LO.INV		:
	STH	R0,C.INV,R1.p		:
	JR	R4			: and exit
					:
:	.......................................................................
:	Receive Project-code data Input to host
:	Call	JAL	R5,AARPDI
:	Expects	R0	Character
:		R1.p	Path pointer
:	Counts chars for accounting
:	Cancels P.STAT & PA.CPC[R1.p] when project-code done
:	.......................................................................
					:
AARPDI	JAL	R2,AAMAKP		: make pointer to accounting data
	LIS	R2,1			: 
	AHM	R2,C.AAIC+4,R3.c	: count the character
	LIS	R2,CA.PCO		: project-code open?
	NH	R2,C.STAT,R3.c		: test state to see
	JER	R5			: exit if not in Project-code state
					:
:	.......................................................................
:	Here in Project-code state
:	.......................................................................
					:
	THI	R0,07F			: test for NULL character
	JER	R5			: exit if NULL character
	LB	R4,C.AAPC,R3.c		: get position
	STB	R0,C.AAPC+1,R4,R3.c	: save current char
	AIS	R4,1			: bump index
	STB	R4,C.AAPC,R3.c		:
	L	R2,I.PCTB,R14.d		: does Destination have PC bit-array?
	JEFS	AARPD1			: no...just skip
	TBT	R0,0,R2			: yes...is this a termination char?
	JN	AARPD2			: yes...terminate PC
AARPD1	LHL	R2,C.AAIC+4,R3.c	:
	CLHI	R2,$A 27		:
	JGEFS	AARPD2			: collect until we have accumulated 27
	SIS	R4,3			:
	JLR	R5			: exit, not yet a full word
	STM	R0,AASAVE		: save registers
	LR	R7.c,R3.c		: copy Channel-pointer
	JAL	R11,AASPC		: send Project-code
	LM	R0,AASAVE		: restore registers
	JR	R5			:
					:
:	.......................................................................
:	Terminate Project-code
:	.......................................................................
					:
AARPD2	STM	R0,AASAVE		: save registers
	LR	R7.c,R3.c		: copy Channel-pointer
	JAL	R11,AATPC		: terminate and send Project-code
	LM	R0,AASAVE		: get registers
	JR	R5			:
					:
:	.......................................................................
:	Special Accounting message
:	Come here on receipt of a Dispatcher B7 message
:	call	JAL	R4,AAMSG
:	Expects	R0	Message
:		R1.p	Path-pointer
:	.......................................................................
					:
AAMSG	JAL	R2,AAMAKP		: make pointer to Accounting-data
	LH	R2,C.STAT,R3.c		: check state
	JER	R4			: not in use...just return
	STM	R0,AASAVE		: save registers
	LR	R7.c,R3.c		: copy Channel-pointer
	LR	R2,R0			: special test...
	SRL	R2,$A 28		:  check if this is a 13d project-code
	SIS	R2,$A 13		:
	JEFS	AAMSG1			: yes...these we let through
	OI	R0,0E0000000		: else ensure either "E" or "F" message
AAMSG1	ST	R0,AATEMP		: save message
	EXHR	R0,R0			:
	LHR	R0,R0			:
	CHI	R0,0E000		: test if termination
	JNFS	AAMSG2			: not termination
	LIS	R0,1			: "Reason for Termination"
	NH	R0,P.NO,R1.p		:  from Destination?
	JN	AACLO1			: go clean up if so
	LHI	R5,0E021		: from source...convert to
	STH	R5,AATEMP		:  ...Origin Circuit-Termination Reason
AAMSG2	JAL	R12,AAMIR		: make an accounting record
	L	R6,AATEMP		: send in this message
	JAL	R5,AASAR		:
	LM	R0,AASAVE		: restore registers
	JR	R4			: and return
					:
:	.......................................................................
:	Receive LOGOUT notice...Close Accounting
:	Call	JAL	R4,AACLOSE
:	Expects	R0	Reason for LOGOUT:
:			1 = HOST DOWN
:			2 = HOST ZAP
:			3 = USER ZAP
:			7 = Out of ports
:			17 = Out of ports (ill-behaved slot)
:		R1.p	Path pointer
:	.......................................................................
					:
AACLOSE	JAL	R2,AAMAKP		: make pointer to Accounting data
	LHL	R2,C.STAT,R3.c		:
					:
:	.......................................................................
:	Closes Project code, records Reason for Termination
:	.......................................................................
					:
	JER	R4			: abort if Channel not in use
	STM	R0,AASAVE		: else save registers
	OI	R0,0E0000000		: generate the Termination-code
	ST	R0,AATEMP		: and save it
	LR	R7.c,R3.c		: copy Channel-pointer
					:
:	.......................................................................
:	This is an entry-point from AAMSG!
:	.......................................................................
					:
AACLO1	JAL	R11,AATPC		: terminate Project-code
	L	R6,AATEMP		:
	ST	R6,C.WHY,R7.c		: record reason for termination
	LIS	R0,CA.WHY		: record that reason is present
	OH	R0,C.STAT,R7.c		:
	STH	R0,C.STAT,R7.c		:
	LM	R0,AASAVE		: restore registers
	JR	R4			: Done...exit
					:
:	.......................................................................
:	Receive LOGOUT notice...Terminate Accounting
:	Call	JAL	R4,AATERM
:	Expects	R0	Reason for LOGOUT:
:			1 = HOST DOWN
:			2 = HOST ZAP
:			3 = USER ZAP
:			7 = Out of ports
:			17 = Out of ports (ill-behaved slot)
:		R1.p	Path pointer
:	Closes Project-code and counts, sends reason UNLESS reason is already
:	recorded.
:	.......................................................................
					:
AATERM	JAL	R2,AAMAKP		: make pointer to Accounting data
	LHL	R2,C.STAT,R3.c		:
	JER	R4			: abort if Channel not in use
	STM	R0,AASAVE		: else save registers
	OI	R0,0E0000000		: generate the Termination-code
	ST	R0,AATEMP		: and save it
	LR	R7.c,R3.c		: copy Channel-pointer
	JAL	R11,AATPC		: terminate Project-code if still open
	JAL	R11,AATCNT		: terminate and send I/O counts
	L	R6,AATEMP		:
	LIS	R2,CA.WHY		:
	NH	R2,C.STAT,R7.c		: do we already have a reason?
	JEFS	AATER1			: no...use given value
	L	R6,C.WHY,R7.c		: yes...report previous value
AATER1	JAL	R5,AASAR		: send reason for termination
	LHI	R0,@CA.ORG		: close accounting
	NHI	R0,C.STAT,R7.c		:
	STH	R0,C.STAT,R7.c		:
	LM	R0,AASAVE		: restore registers
	JR	R4			: Done...exit
					:
:	.......................................................................
:	Terminate Project-code state
:	Call	JAL	R11,AATPC
:	Expects	R7.c	Channel-pointer
:	Smashes RO-R11, R14.d
:	.......................................................................
					:
AATPC	LIS	R6,CA.PCO		: project-code open?
	NH	R6,C.STAT,R7.c		:  ...in current channel state
	JER	R11			: no...quit
	XH	R6,C.STAT,R7.c		: was on...turn it off
	STH	R6,C.STAT,R7.c		: record it
					:
:	.......................................................................
:	Send Project-code
:	call	JAL	R11,AASPC
:	Expects	R7.c	Channel-pointer
:	.......................................................................
					:
AASPC	JAL	R12,AAMIR		: send Invoice-record
	L	R6,C.AAPC,R7.c		: get PC bytes
	NI	R6,000FFFFFF		: mask in relevant data
	JER	R11			: don't send if no data
	OI	R6,0D0000000		: make an Accounting word
	LIS	R5,0			: now reset index
	ST	R5,C.AAPC,R7.c
	JAL	R5,AASAR		: send in one message
	JR	R11			:
					:
:	.......................................................................
:	Terminate counts
:	call	JAL	R11,AACNTS
:	Expects	R7.c	Channel-pointer
:	Destroys R1-R6, R12
:	.......................................................................
					:
AATCNT	LHI	R0,@CA.CTO		:
	NH	R0,C.STAT,R7.c		:
	STH	R0,C.STAT,R7.c		:
	JFS	AACNT1			:
					:
:	.......................................................................
:	Transmit counts
:	call	JAL	R11,AACNTS
:	Expects	R7.c	Channel-pointer
:	Destroys R1-R6, R12
:	.......................................................................
					:
AACNTS	LIS	R0,CA.CTO		:
	NH	R0,C.STAT,R7.c		: counts open?
	JER	R11			: no...don't bother
AACNT1	JAL	R12,AAMIR		: send Invoice-number
	LA	R4,C.AAIC,R7.c		: set pointer to Input-count
	LI	R5,080000000		: set type
	JAL	R12,AASMP		: send it
	LA	R4,C.AAOC,R7.c		: Output too
	LI	R5,090000000		: set type
	JAL	R12,AASMP		: send it
	JR	R11			: return
					:
:	.......................................................................
:	Make an Accounting Invoice record
:	Call	JAL	R12,AAMIR
:	Expects	R7.c	Channel pointer
:	.......................................................................
					:
AAMIR	LA	R4,C.INV,R7.c		: set POINTER to Invoice-number
	L	R0,2,R4			: check if same as last one sent
	S	R0,AALINS+2		:
	JNFS	AASIR			: no
	LH	R0,0,R4			:
	SH	R0,AALINS		:
	JER	R12			: yes
					:
:	.......................................................................
:	Send an Accounting Invoice record
:	Call	JAL	R12,AASIR
:	Expects	R4	POINTER to Invoice-number
:	.......................................................................
					:
AASIR	L	R0,2,R4			:
	ST	R0,AALINS+2		: yes...save for next test
	LHL	R5,0,R4			:
	STH	R5,AALINS		: Check to see if it is a non-zero
	OR	R0,R5			: Invoice-Number?
	JN	AASIR8			: Just skip if Invoice # is non-zero
	D.CRSH(0C,R12)			: Crash on zero accounting invoice #
AASIR8	LI	R5,070000000		: set INVOICE-record type
					: exit via AASMP
					:
:	.......................................................................
:	Send Multiple-precision Accounting-message
:	call	JAL	R12,AASMP
:	Expects	R4	POINTER to multiple-precision value
:		R5	Accounting-type code
:	Destroys R1-R6
:	.......................................................................
					:
AASMP	L	R6,0,R4			: get High-order value
	SRLS	R6,8			: will this fit into 24 bits?
	JNFS	AASMP1			: no
	L	R6,2,R4			: check LSF
	JER	R12			: value is zero...don't bother sending anything
	OR	R6,R5			: single-precision...add type-field
	J	AASMP2			: and go send it
					:
:	.......................................................................
:	Multiple-precision field
:	.......................................................................
					:
AASMP1	OI	R6,00F000000,R5		: set MSF
	ST	R6,AATYPE		: save it
	LI	R6,000FFFFFF		: set mask
	N	R6,2,R4			: get LSF value
	OI	R6,00E000000,R5		: set LSF flag & type
	JAL	R5,AASAR		: send LSF field
	L	R6,AATYPE		: get type
AASMP2	LR	R5,R12			: copy return-address
					: fall thru to send/exit
					:
:	.......................................................................
:	Send an Accounting record
:	Call	JAL	R5,AASAR
:	Expects	R6	Accounting Word
:	.......................................................................
					:
AASAR	LIS	R2,8			: Message-size
	JAL	R4,SENDS0		: to slot 0
	LHI	R0,0500			: set accounting Heading
	JAL	R4,SENDH		: send it
  if	$0 DB.FLG&20			:
ACTSIZ	EQ	200			:
	LR	R0,R6			: get a copy of the Message
	SRL	R0,1C			: isolate Subtype
	SIS	R0,0E			: only saving Sub-type 0E
	JNFS	ACHISX
	LHL	R4,AHISX		: get the ACCT Hist index
	AIS	R4,8			: bump it
	NHI	R4,ACTSIZ-1		: fold if necessary
	STH	R4,AHISX		: store it
	ST	R6,ACTAB,R4		: save the word
	LHL	R0,SORCX		: get current slot key
	SRHLS	R0,2			: make slot-number
	STH	R0,ACTAB+4,R4		: store it
ACHISX
  ei
	LR	R0,R6			: get a copy
	JAL	R4,SENDW		: send it
	JAL	R4,TERM			: and end message
	JR	R5			: and exit
					:
:	.......................................................................
:	Make the pointers to the tables
:	Call	JAL	R2,AAMAKP
:	Expects	R1	Path-pointer
:	returns	R3.c	pointer to channel
:	.......................................................................
					:
AAMAKP	CCFP(R1.p,R3.c)			: compute channel from path
	CI	R1.p,C.POOL		: range-check on Path-pointer
	JLFS	AAMAKH			:
	CI	R1.p,C.PEND-P.LEN	:
	JLER	R2			:
AAMAKH	D.CRSH(0C,R4)			:

	SUBTTL	DISPATCHER - Host-table Management

:	.......................................................................
:	Find a host-table coresponding to a specific host
:	Expects	R0	Target host-number (0 finds first free host-entry)
:	  	HSTSVE	Host slot-key  (-1 specifies host-any-slot-key)
:		R4 -	link register  (general purpose reg. within)
:
:	Returns	R1 -	POINTER to host-entry if found (either target or free)
:			CC set GT if free
:			CC set EQ if target
:			else CC set LT if none found
:	.......................................................................
					:
FNDHST	ST	R4,RETVEC		: store return
	LCS	R2,1			: set exception
	LHI	R1,(NUMHST-1)*H.LEN	: set index
FNDHO1	LHL	R3,HSTTBL+H.NO,R1	: check an entry
	JE	FNDHO2			: not in use
	CR	R0,R3			: in use...check entry
	JN	FNDHO3			: not it
	LH	R4,HSTSVE		: check for host-any-slot-key
	JLFS	FNDHO4			: we can use it
	LHL	R3,HSTTBL+H.SKEY,R1	: get slot-key
	LBR	R3,R3
	CLR	R3,R4			: match on slots?
	JNFS	FNDHO3			: not it?
FNDHO4	LA	R1,HSTTBL,R1		: got it...set address
	L	R4,RETVEC		: restore return
	LIS	R2,0			: force CC EQ
	JR	R4			: and return

FNDHO2	LR	R2,R1			: not in use...copy index
FNDHO3	SHI	R1,H.LEN
	JGE	FNDHO1			: keep searching
	L	R4,RETVEC		: restore return
	LR	R1,R2			: find any?
	JLR	R4			: no...table full
	LA	R1,HSTTBL,R1		: else set address
	LIS	R2,1			: force CC to GT
	JR	R4			: and return
					:
:	.......................................................................
:	Send Host report to Slot 0
:	Expects	R5 -	POINTER to Host-descriptor
:		R6 -	Link-register
:	REMOVES host from table AFTER report if H.STAT == GONE
:	.......................................................................
					:
SNDHST	LH	R0,H.NO,R5		: verify host exists
	JER	R6			: ignore if not
	LIS	R2,$A 14		: else set 14d-byte message
	JAL	R4,SENDS0		: to slot 0 command-port
	LHL	R0,H.SKEY,R5		: get "owning" slot
	OHI	R0,1000			: subtype | origination slot Key
	JAL	R4,SENDH		:
	LHL	R0,H.NO,R5		: get Host-number
	JAL	R4,SENDH		:
	LHL	R0,H.NPT,R5		: get number of ports
	JAL	R4,SENDH		:
	LHL	R0,H.RHX,R5		:
	JAL	R4,SENDH		: RH#...slot 0 doesn't care
	LHL	R0,H.STAT,R5		: get status | Host-key
	JAL	R4,SENDH		: Status | Host-key
	LHL	R0,H.IIX,R5		: IIX | PID
	JAL	R4,SENDH		:
	JAL	R4,TERM			: Terminate message
	LB	R0,H.STAT,R5		: check status just reported
	NHI	R0,3			:
	SIS	R0,3			: is reported status GONE?
	JNR	R6			: no...exit
	STH	R0,H.NO,R5		: yes...make it go away
	JR	R6			: and exit
					:
:	.......................................................................
:	Send Host-cost report to Slot 0
:	Expects	R5 -	POINTER to Host-descriptor
:		R6 -	Link-register
:	.......................................................................
					:
SNDCOST	LH	R0,H.NO,R5		: verify host exists
	JER	R6			: ignore if not
	LIS	R2,$A 10		: else set 10d-byte message
	JAL	R4,SENDS0		: to spot 0 command-port
	LHL	R0,H.SKEY,R5		: get "owning" slot
	OHI	R0,0C00			: subtype | origination slot Key
	JAL	R4,SENDH		:
	LHL	R0,H.NO,R5		: get Host-number
	JAL	R4,SENDH		:
	LHL	R0,H.COST,R5		: get cost
	JAL	R4,SENDH		:
	LHL	R0,H.RHX,R5		:
	JAL	R4,SENDH		: RH#...slot 0 doesn't care
	JAL	R4,TERM			: Terminate message
	JR	R6			: and exit
					:
:	.......................................................................
:	Send Host-Port_available report to Slot 0
:	Expects	R5 -	POINTER to Host-descriptor
:		R6 -	Link-register
:	.......................................................................
					:
SNDPTA	LH	R0,H.NO,R5		: verify host exists
	JER	R6			: ignor if not
	LIS	R2,$A 10		: else send 10d-byte message
	JAL	R4,SENDS0		: to slot 0
	LHL	R0,H.SKEY,R5		: get "owning" slot
	OHI	R0,0A00			: subtype | origination slot Key
	JAL	R4,SENDH		:
	LHL	R0,H.NO,R5		: get Host-number
	JAL	R4,SENDH		:
	LHL	R0,H.NPTL,R5		: get number_of_ports-left
	JAL	R4,SENDH		:
	LHL	R0,H.RHX,R5
	JAL	R4,SENDH		: RH#...slot 0 doesn't care
	JAL	R4,TERM			: Terminate message
	JR	R6			: and exit

	SUBTTL	DISPATCHER - Utilities

:	.......................................................................
:	ZAP a port
:	Places ZAPPER in RIng if possible, else special Message in Control-Path
:	R1	PORT #
:	R5	LINK
:	R14.d	Slot Key
:	.......................................................................
					:
ZAPEM	JAL	R4,SPEED		: speed 3-byte message
	LHI	R0,ZAPMSG^8		:
	JAL	R4,SENDH		:
	JAL	R4,TERM			: terminate message
	JR	R5			:
					:
:	.......................................................................
:	Send a Message for port
:	WIll place in Ring if possible, else in Control-Path
:	R1	PORT#
:	R2	Pointer to Message-string
:	R5	LINK
:	R14.d	Slot Key
:	.......................................................................
					:
SMP	ST	R2,TEMP			: save String-address
	LB	R2,0,R2			: How much do we need?
	JER	R5			: just ignor NULL (0-length) messages
	STB	R2,TEMP			: else save COUNT|ADDRESS
	AIS	R2,3			: allow for port-number, type
	JAL	R4,CHUCK		: place Port-number
SMP1	L	R3,TEMP			: bump pointer
	JLFS	SMP2			: skip if done
	LHL	R0,0,R3			: get HW
	AI	R3,0FE000002		:  ...AND decrement count
	ST	R3,TEMP			: save for next time
	JAL	R4,SENDH		:
	JBS	SMP1			: repeat as necesary
SMP2	JAL	R4,TERM			: terminate message
	JR	R5			: and return
					:
	SUBTTL	DISPATCHER - General Message-transmission Routines

:	.......................................................................
:	General routines to send message to destination
:	Decides whether to place in Ring, or in Buffer
:	General sequence:
:	call SPEED with Port-number (for 3 and 4 byte messages)
:	-or- CHUCK with Size, Port-number
:	-or- SENDS0 with Size (for Slot 0 Path0 messages)
:	-or- SENDTO with Size, R14.d set to Destination (for Path0 messages)
:	-or- CHECK with Size, Path-pointer
:	then call SENDx
:	finally call TERM

:	Conventions
:	If Ring is used, R8.Or, R9.Oc, R10.Om set up Appropriately
:	else:
:		R8.Or	zero
:		R9.Oc	Buffer-number
:		R10.Om	used for temp
:
:	Send to Slot 0's Command-port
:	Link on R4
:	R2	Number of bytes required
:	R14.d	Destination Slot Key
:	.......................................................................
					:
SENDS0	LIS	R14.d,S0KEY		: set slot 0...
					:
:	.......................................................................
:	Send to Slot's Command-port
:	Link on R4
:	R2	Number of bytes required
:	R14.d	Destination Slot Key
:	.......................................................................
					:
SENDTO	L	R1.p,I.CPATH,R14.d	: set Command path-pointer...
					: ...then fall through
					:
:	.......................................................................
:	Check out status
:	Link on R4
:	R1.p	Path pointer
:	R2	Number of bytes required
:	R14.d	Destination Slot Key
:	If Ring, Places Port-number
:	If Buffer, places Character-count
:	.......................................................................
					:
CHECK	LH	R0,I.CTL,R14.d		: check destination slot
	JLFS	CHECK1			: active
	LA	R1,C.POOL		: inactive...set path 0 = bit-bucket
	JFS	GOBUF			:
					:
CHECK1	LHL	R0,P.BCT,R1.p		: is Buffer empty?
	JNFS	GOBUF			: no...use Buffer
	JAL	R3,SPACE		: how much room is there in Ring?
	CR	R2,R0			:
	JGFS	GOBUF			: not enough...use Buffer
	LH	R0,P.PORT,R1.p		: enough...get Port-number
	JGE	PUTH			: place into Ring (unless port negative)
					:
GOBUF	LR	R9.Oc,R1.p		: save Buffer-number
	lb	r3,p.stat,r1.p		: get path state ***ern
	thi	r3,pa.cmd		: command path ?
	jefs	gobuf1			: jump if not command path
	LHL	R1,P.PORT,R9.Oc		: get port #
	J	CHUCK2			: skip to place LENGTH | PORT
gobuf1	lr	r0,r2			: get # of required bytes ***ern
	sis	r0,2			: strip of port HW size (2 bytes)
	lis	r8.Or,0			: reset
	j	whi			: send/exit
					:
:	.......................................................................
:	Speed 3 or 4 byte message to Slot
:	Link on R4
:	R1	Port-number
:	.......................................................................
					:
SPEED	LIS	R2,4			: set length and fall through...
					:
:	.......................................................................
:	CHUCK out a message
:	Like CHECK, except may place Message in Command-Path instead
:	using Port-number instead of Path-pointer.
:	R1	Port-number
:	R2	Number of bytes required
:	R14.d	Destination Slot Key
:	if Buffer, Places Escaped count, followed by Port-number
:	.......................................................................
					:
CHUCK	JAL	R3,SPACE		: is there room?
	CR	R2,R0			:
	JGFS	CHUCK1			: skip if not enough room there
	LR	R0,R1			: else place port-number into Ring
	J	PUTH			:
CHUCK1	L	R9.Oc,I.CPATH,R14.d	: get Command-port Path-pointer
CHUCK2	EXHR	R8.Or,R2		: pack up word to place
	OR	R8.Or,R1		: Count | Port
	TS	I.USING,R14.d		: also record buffer usage for this slot
	JFS	SEND4			: and skip to transmit
					:
:	.......................................................................
:	Send a Word
:	R0	Word to send
:	.......................................................................
					:
SENDW	LR	R8.Or,R8.Or		:
	JN	PUTW			: flag not set, so use Ring
	LR	R8.Or,R0		: must use Buffers...save Word
SEND4	LR	R10.Om,R4		: save return
	LR	R1.p,R9.Oc		: set up Path register
	EXHR	R0,R8.Or		: first HW
	JAL	R4,WHI			:
	LR	R0,R8.Or		: second HW
	LIS	R8.Or,0			: reset flag
	LR	R4,R10.Om		: restore return
	J	WHI			: send / exit
					:
:	.......................................................................
:	Send a Halfword
:	R0	HW to send
:	.......................................................................
					:
SENDH	LR	R8.Or,R8.Or		:
	JN	PUTH			: flag not set, so use Ring
	LR	R1.p,R9.Oc		: must use Path-buffer
	J	WHI			: send / exit
					:
:	.......................................................................
:	Terminate
:	.......................................................................
					:
TERM	LR	R8.Or,R8.Or		:
	JN	ELOR			: flag not set, so clean up Ring
	LHL	R8.Or,P.BCT,R9.Oc	: set...check Buffer-size
	CLH	R8.Or,P.HIST,R9.Oc	:
:	JLER	R4			: this is not biggest buffer ever, so quit
	jnc	term1			: not biggest buffer ever, so quit
	je	term1			: ditto
	STH	R8.Or,P.HIST,R9.Oc	: biggest ever...save History
term1	JR	R4			: and return
					:
	SUBTTL	DISPATCHER - Ring-handling Routines

:	.......................................................................
:	Conventions:
:	Output-Routines use DEDICATED Registers:
:	R8.Or	Pointer to Output-ring
:	R9.Oc	Ring Cursor
:	R10.Om	Ring-Maximum
:
:	Input-Routines use DEDICATED Registers:
:	R11.Ir	Pointer to Input-ring
:	R12.Ic	Ring Cursor
:	R13.Im	Ring-maximum
:
:	ALL Routines link on R4
:
:	*****************************
:	*			    *
:	*	INPUT ROUTINES	    *
:	*			    *
:	*****************************
:
:	LOOK at a ring-entry
:	SKIP (+2) Return if Ring is Empty
:	Else	Port Returned in R1
:		Message-type returned in R2
:	All Registers set up for Transfer
:	Position is advanced past Port#
:	Condition-code set EQ if port = 0
:
:	.......................................................................
					:
LOOK	L	R11.Ir,I.ORNG,R15.s	: get pointer to slot's output-ring (our input)
	LHL	R12.Ic,CEI,R11.Ir	: get Current Empty Index cursor
	CLH	R12.Ic,NFMI,R11.Ir	: test if caught up
	JE	2,R4			: empty...skip (2) return
	LHL	R13.Im,I.ORSZ,R15.s	: get Max index
	AIS	R12.Ic,2		: bump cursor past port-number
	LB	R2,RING,R11.Ir,R12.Ic	: get message-type
	LHL	R1,RING-2,R11.Ir,R12.Ic	:  and port-number (set CC)
	STH	R1,SORPOR		: save a copy of the port-number
	JR	R4			: then return
					:
:	.......................................................................
:	Get a CHARACTER from the Input-ring
:	CHARACTER returned in R0
:	.......................................................................
					:
GETCH	LB	R0,RING,R11.Ir,R12.Ic	: get the char
	AIS	R12.Ic,1		: bump cursor
	CR	R12.Ic,R13.Im		: test for folding
	JLR	R4			: return if not
	LIS	R12.Ic,0		: else fold it
	JR	R4			: and exit
					:
:	.......................................................................
:	get a HALF-WORD from the Input-ring
:	ASSUME have removed an integral number of HALF-WORDS from Message
:	HALF-WORD returned in R0
:	.......................................................................
					:
GETH	LH	R0,RING,R11.Ir,R12.Ic	: get the data
	AIS	R12.Ic,2		: bump cursor
	CR	R12.Ic,R13.Im		: test for folding
	JLR	R4			: return if not
	LIS	R12.Ic,0		: else fold it
	JR	R4			: and exit
					:
:	.......................................................................
:	Get a WORD from the Input-ring
:	ASSUME have removed an integral number of WORDS from Message
:	WORD returned in R0
:	.......................................................................
					:
GETW	L	R0,RING,R11.Ir,R12.Ic	: get the data
	AIS	R12.Ic,4		: bump cursor
	CR	R12.Ic,R13.Im		: test for folding
	JLR	R4			: return if not
	LIS	R12.Ic,0		: else fold it
	JR	R4			: and exit
					:
:	.......................................................................
:	FLUSH an Input-message
:	Number of bytes to FLUSH in R0
:	.......................................................................
					:
FLUSH	AR	R12.Ic,R0		: advance ring and fall through
					:
:	.......................................................................
:	End-Logical-Input-Record
:	.......................................................................
					:
ELIR	AIS	R12.Ic,3		: force to next Word boundary
	NHI	R12.Ic,-4		:
	CR	R12.Ic,R13.Im		: test for folding
	JLFS	ELIR1			: no
	SR	R12.Ic,R13.Im		: yes
ELIR1	STH	R12.Ic,CEI,R11.Ir	:
	JR	R4			: and exit
					:

:	.......................................................................
:	MOVE Data from RING to RING
:	Origination-ring Described by R11.Ir-R13.Im
:	Destination-ring Described by R8.Or-R10.Om
:	R0	Number of bytes to move
:	R1	Destination Port-number
:	ASSUMES that enough space exists in Output-ring
:	.......................................................................
					:
MOVRNG	STH	R1,RING,R8.Or,R9.Oc	: place the port-number
	LHL	R1,RING,R11.Ir,R12.Ic
	STH	R1,RING+2,R8.Or,R9.Oc	: add next two chars to output
	AIS	R12.Ic,2		: bump source
	CR	R12.Ic,R13.Im		: test for folding
	JLFS	MRING1
	LIS	R12.Ic,0
MRING1	AIS	R9.Oc,4			: bump destination
	CR	R9.Oc,R10.Om
	JLFS	MRING2
	LIS	R9.Oc,0
MRING2	SIS	R0,2			: count it done
	JGFS	MRING3			: skip if more to do
	STH	R9.Oc,NFMI,R8.Or	: else set new message in ring
	STH	R12.Ic,CEI,R11.Ir	: set source message gone
	JR	R4			: and exit

:***********************************************************************
: Change to put in a copy instruction for large block moves.  Gives a small
: hit on 2-5 byte messages, and a big gain on longer ones.
: Ed Mooring -- 6-May-88
:***********************************************************************

mring3	clhi	r0,4
	jg	mring6			: if more than 1 word to move, copy
	l	r1,ring,r11.ir,r12.ic	: move next word
	st	r1,ring,r8.or,r9.oc
	ais	r12.ic,4		: bump output cursor
	cr	r12.ic,r13.im
	jlfs	mring4
	lis	r12.ic,0		: fold cursor if necessary
mring4	ais	r9.oc,4
	cr	r9.oc,r10.om		: bump and fold input ring
	jlfs	mring5
	lis	r9.oc,0
mring5	sth	r9.oc,nfmi,r8.or	: store cursors
	sth	r12.ic,cei,r11.ir
	jr	r4
	:
	:	compute minimum of distances to end of source ring
	:	and distance to end of destination ring
	:
mring6	lr	r1,r10.om
	sr	r1,r9.oc		: distance to end of destination
	lr	r2,r13.im
	sr	r2,r12.ic		: distance to end of source
	cr	r1,r2			: find minimum
	jlefs	mring7
	lr	r1,r2			: in r1
mring7	clhi	r1,4			:if only one word don't copy
	jg	mrngcl
	l	r1,ring,r11.ir,r12.ic	: move next word
	st	r1,ring,r8.or,r9.oc
	ais	r12.ic,4		: bump output cursor
	cr	r12.ic,r13.im
	jlfs	mring8
	lis	r12.ic,0		: fold cursor if necessary
mring8	ais	r9.oc,4
	cr	r9.oc,r10.om		: bump and fold input ring
	jlfs	mring9
	lis	r9.oc,0
mring9	sis	r0,4			: decrement length
	j	mring3
	:
	:	compute minimum of length and r1 and copy that many bytes
	:
mrngcl	cr	r1,r0			: find minimum
	jlefs	mrc1
	lr	r1,r0
	ais	r1,3
	nhi	r1,-4			: make into full word
mrc1	sr	r0,r1			: subtract from total length
	ar	r9.oc,r1
	ar	r12.ic,r1		: bump the cursors
	lr	r2,r11.ir
	ahi	r2,ring-2,r12.ic	: last source halfword
	lr	r3,r8.or
	ahi	r3,ring-2,r9.oc		: last destination halfword
	sis	r1,2			: -1 halfword
	slls	r1,3			: number of h/w *10
	copy	r2,r1			: copy 'em
	cr	r9.oc,r10.om		: update and fold cursor
	jlfs	mrc2
	lis	r9.oc,0
mrc2	cr	r12.ic,r13.im		: update and fold cursor
	jlfs	mrc3
	lis	r12.ic,0
mrc3	lr	r0,r0			: anything left to move?
	jg	mring3
	sth	r9.oc,nfmi,r8.or
	sth	r12.ic,cei,r11.ir	: save the cursors
	jr	r4			: and return


:MRING3	L	R1,RING,R11.Ir,R12.Ic	: move next Word
:	ST	R1,RING,R8.Or,R9.Oc
:	AIS	R12.Ic,4		: bump Output cursor
:	CR	R12.Ic,R13.Im
:	JLFS	MRING4
:	LIS	R12.Ic,0		: fold cursor if necessary
:MRING4	AIS	R9.Oc,4
:	CR	R9.Oc,R10.Om		: bump and fold Input ring
:	JLFS	MRING5
:	LIS	R9.Oc,0
:MRING5	SIS	R0,4			: count a Word moved
:	JGBS	MRING3			: continue if not done
:	STH	R9.Oc,NFMI,R8.Or	: Done...update Cursors
:	STH	R12.Ic,CEI,R11.Ir
:	JR	R4			: and exit
:	******************************
:	*			     *
:	*	OUTPUT ROUTINES	     *
:	*			     *
:	******************************

:	Find SPACE in the Ring (How big a Message it will take)
:	Returns	R0	Number of Bytes of SPACE
:		Link on R3
SPACE	LCS	R0,4			: set mask
	L	R8.Or,I.IRNG,R14.d	: set up pointers (Slot-input is our Output)
	LHL	R9.Oc,NFMI,R8.Or
	LHL	R10.Om,I.IRSZ,R14.d
	NH	R0,CEI,R8.Or		: force Emptier to Word boundary
	SR	R0,R9.Oc		: space between us and Emptier
	JGFS	SPACE1			: skip if no wrap-around
	AR	R0,R10.Om		: else correct for wrap, possible Empty-state
SPACE1	SIS	R0,4			: allow for potential overflow
	JR	R3			: and return

:	Put a HALF-WORD into the Ring
:	R0	HALF-WORD
PUTH	STH	R0,RING,R8.Or,R9.Oc	: place the HW
	AIS	R9.Oc,2			: bump cursor
	CR	R9.Oc,R10.Om		: test if need to fold cursor
	JLR	R4			: exit if not
	LIS	R9.Oc,0			: else wrap it
	JR	R4			: and exit

:	Put a WORD into the Ring
:	R0	WORD
PUTW	ST	R0,RING,R8.Or,R9.Oc	: Place the Word
	AIS	R9.Oc,4			: bump cursor
	CR	R9.Oc,R10.Om		: test if need to fold cursor
	JLR	R4			: exit if not
	LIS	R9.Oc,0			: else wrap it
	JR	R4			: and exit

:	End-Logical-Output-Record
ELOR	AIS	R9.Oc,3
	NHI	R9.Oc,-4
	CR	R9.Oc,R10.Om		: test for folding
	JLFS	ELOR1
	LIS	R9.Oc,0			: fold if necessary
ELOR1	STH	R9.Oc,NFMI,R8.Or	: now advance cursor to next message
	JR	R4			: and exit
	SUBTTL	DISPATCHER - BUFFERLET ROUTINES

:	HW handlers...These routines:
:	pass buffer HW in R0,
:	R1.p - Path-pointer,
:	R2,R3 for working registers,
:	R4 is link.

GHIH	D.CRSH(02,R4)			: GHI CRASH, reason 2, Link register ********

:	Get HW from Path and increment forward thru the Path.
GHI	HS	0
 if	DBG.PA
	CI	R1.p,C.POOL		: range-check on Path-pointer
	JLBS	GHIH
	CI	R1.p,C.PEND-P.LEN
	JGBS	GHIH
 ei	:DBG.PA
	L	R2,P.BB,R1.p		: good Path...get index to HW
	LHL	R0,0,R2			: pick up HW
:	LCS	R3,2
:	AHM	R3,P.BCT,R1.p		: update count
:	JLE	GHI2			: skip if no HWs left
	lhl	r3,p.bct,r1.p		: get count ***ern
	je	ghih			: crash if empty
	sis	r3,2
	sth	r3,p.bct,r1.p		: update count
	je	ghi2			: last HW in path
	AIS	R2,2			: else increment P.BB value
	THI	R2,BFL.SZ-1		: test if at end of bufferlet
	JEFS	GHI1			: return bufferlet to free-list if so
	ST	R2,P.BB,R1.p		: else update P.BB
	DCHIST				: and return with the HW

:	Bufferlet exhausted
GHI1	SHI	R2,BFL.SZ		: back up to pointer
	L	R3,0,R2			: get next bufferlet from pointer
	AIS	R3,4			: advance it to data
	ST	R3,P.BB,R1.p		: set P.BB to start of next bufferlet
	L	R3,FREBFL		: get pointer to free-list
	ST	R3,0,R2			: link last bufferlet to free-list
	ST	R2,FREBFL		: and put at the head of the free-list
	DCHIST				: then exit

:	last HW in Path
GHI2	NHI	R2,-BFL.SZ		: back up pointer
	L	R3,FREBFL
	ST	R3,0,R2
	ST	R2,FREBFL		: update free-list
	LIS	R2,0
	ST	R2,P.BB,R1.p
	ST	R2,P.BE,R1.p

:	Unlink from Linked-list
	L	R2,P.LAST,R1.p		: pointer to our last
	L	R3,P.NEXT,R1.p		: pointer to our next
	ST	R3,P.NEXT,R2		: link last to next
	JEFS	GHI3			: skip if next is null
	ST	R2,P.LAST,R3		: link next back to last
GHI3	DCHIST


WHIH	D.CRSH(04,R4)			: WHI CRASH, reason 4, Link register ********

:	Put a HW into the Path
WHI	HS	0
	CI	R1.p,C.POOL		: range-check on Path-pointer
	JER	R4			: toss it...path 0 is bit-bucket!
 if	DBG.PA
	JLBS	WHIH
	CI	R1.p,C.PEND-P.LEN
	JGBS	WHIH
 ei	:DBG.PA
	LHL	R2,P.BCT,R1.p		: check count
	JE	WHI4			: if new buffer, set up Active-queue
	LIS	R2,2			: else update count
	AHM	R2,P.BCT,R1.p
	JE	WHIH			: something wrong (exceeded 64k)- *** ern
	L	R2,P.BE,R1.p		: get pointer to last HW position
	AIS	R2,2			: bump pointer
	THI	R2,BFL.SZ-1		: test if bufferlet full
	JEFS	WHI2			: end of bufferlet
	ST	R2,P.BE,R1.p		: else update P.BE
	STH	R0,0,R2			: and save HW in buffer
	DCHIST

:	need a new bufferlet
WHI2	L	R3,FREBFL
	JGFS	WHI3			: skip if there is another
	JAL	R2,WRE			: (Open the Reserve-tank)
WHI3	LHI	R2,-BFL.SZ		: set up mask
	N	R2,P.BE,R1.p		: Restore pointer to start of current bufferlet
	ST	R3,0,R2			: link new bufferlet to last one
	L	R2,0,R3			: and remove from Free-list
	ST	R2,FREBFL
	LIS	R2,0
	ST	R2,0,R3
	AIS	R3,4			: advance pointer to start of data
	ST	R3,P.BE,R1.p		: save as new P.BE
	STH	R0,0,R3			: put the HW there
	DCHIST

:	the Path was empty
WHI4	LIS	R2,2
	STH	R2,P.BCT,R1.p		: set count = 2
	L	R3,FREBFL		: Pop a bufferlet off Free-list
	JGFS	WHI5			: skip if there was one
	JAL	R2,WRE			: else open the Reserve-tank
WHI5	L	R2,0,R3
	ST	R2,FREBFL		: update Free-list
	LIS	R2,0
	ST	R2,0,R3
	AIS	R3,4			: point it at first HW
	ST	R3,P.BB,R1.p		: set up P.BB
	ST	R3,P.BE,R1.p		: and P.BE
	STH	R0,0,R3			: put the HW there

:	Do linked-list insert
	LA	R3,I.QUE,R14.d		: POINTER to QUEUE
	LA	R2,P.NEXT,R1.p		: convert to POINTER
	ST	R3,P.LAST,R1.p		: point back to queue
	L	R3,I.QUE,R14.d
	ST	R2,I.QUE,R14.d		: link QUEUE to this
	ST	R3,P.NEXT,R1.p		: link this to previous queue head
	JEFS	WHI6			: null?
	ST	R2,P.LAST,R3		: no...link new next back to this
WHI6	DCHIST


:	Move Reserve-tank storage to main Free-list
WRE	L	R3,RTANK		: get pointer to Reserve Bufferlets
	TS	SORCX			: cause this Dispatcher-session to ABORT!
	TS	RTANK			: set Reserve-tank empty (<0)
	LR	R3,R3			: check what it was
	JGR	R2			: if it wasn't empty (i.e., was > 0)
	D.CRSH(06,R2)			: WRE CRASH, reason 6, link Register ********


:	return a bufferlet
:	Expects	R3 -	POINTER to bufferlet start
:		R4 - link
:	Smashes	R2
RLSBFL	L	R2,FREBFL
	ST	R2,0,R3
	ST	R3,FREBFL		: update free-list
	JR	R4			: and return


:	Allocate a bufferlet
:	Expects	R4 -	link
:	Returns	R3 -	POINTER to Bufferlet
:	Smashes	R2
GETBFL	L	R3,FREBFL		: Pop a bufferlet off Free-list
	JGFS	GBFL1			: skip if there was one
	JAL	R2,WRE			: else open the Reserve-tank
GBFL1	L	R2,0,R3
	ST	R2,FREBFL		: update Free-list
	LIS	R2,0
	ST	R2,0,R3
	JR	R4

  if	DI.TRC

:	Update history (TRACE) after every buffer-operation
HSTSIZ	EQ	400			: size of History-ring
HIST	LHL	R3,HISX			: get History-ring index
	AIS	R3,8			: bump to next entry
	NHI	R3,HSTSIZ-1		: account for folding
	STH	R3,HISX			: save it again
	STH	R0,HISTAB,R3		: Entry (0) = Char
	LHL	R2,P.NO,R1.p		: compute path-number
	STH	R2,HISTAB+2,R3		: Entry (2) = Path-number
	ST	R4,HISTAB+4,R3		: entry (4-7) = Link-address
	JR	R4
  ei	(DI.TRC)


EMPTYH	D.CRSH(08,R4)			: EMPTY CRASH, reason 8, Link-register *******

:	Return all the space used by the Path
EMPTY	HS	0
 if	DBG.PA
	CI	R1.p,C.POOL		: range-check on Path-pointer
	JLBS	EMPTYH
	CI	R1.p,C.PEND-P.LEN
	JGBS	EMPTYH
 ei	:DBG.PA
	LHL	R2,P.BCT,R1.p		: check contents
	JER	R4			: Exit...Path empty
	L	R2,P.BB,R1.p		: not empty...pointer to first HW in Path-buffer
	NHI	R2,-BFL.SZ		: pointer to start of bufferlet
	L	R3,FREBFL		: get pointer to Free-list
	ST	R2,FREBFL		: put the buffer's bufferlets onto Free-list
	L	R2,P.BE,R1.p		: get pointer to last HW in Path-buffer
	NHI	R2,-BFL.SZ
	ST	R3,0,R2			: chain previous Free-list to this bufferlet
	LIS	R2,0
	STH	R2,P.BCT,R1.p		: set count = 0
	ST	R2,P.BB,R1.p
	ST	R2,P.BE,R1.p

:	Unlink from Linked-list
	L	R2,P.LAST,R1.p		: pointer to our last
	L	R3,P.NEXT,R1.p		: pointer to our next
	ST	R3,P.NEXT,R2		: link last to our next
	JER	R4			: quit if next is null
	ST	R2,P.LAST,R3		: link next back to last
	JR	R4			: and return
	SUBTTL	DISPATCHER - CONSTANTS

ORIZAP	HC	3,0			: ZAPPED BY USER
NOHOST	HC	4;	SC	/"8D"8Ahost not available/
HOSTDN	HC	5;	SC	/"8D"8Ahost down/
HOSTSH	HC	6;	SC	/"8D"8Ahost shut/
OUTPRT	HC	10;	SC	/"8D"8Aslot out of ports/
NOCHAN	HC	8;	SC	/"8D"8Aout of channels/
NOROOM	HC	33;	SC	/"8D"8Aring too small/

:	Create a string with the Node number in it
IDMSG	HS	0			: SMP requires HW boundary
	BC	0B
	AC	/ Node #/
Q	EQ	3
  re	4
	BC	0B0!((MACHNM^-(Q*3))&7)	: extract one digit at a time
Q	EQ	Q-1
  er

	SUBTTL	DISPATCHER - Bulk Storage

  if	DI.TRC
HISX	HC	0			: Index for History
HISTAB	HS	HSTSIZ/2		: History data
  ei	:DI.TRC

  if	DB.FLG&20
AHISX	HC	0
ACTAB	HS	ACTSIZ/2
  ei

REBC1	HC	0			: counts times Reserve-tank invoked
REBC2	HC	0			: counts total number of Buffer-Zaps

DSWCH	HC	-1			: Disconnect Switch

IEND	HS	0			: how much to load in "*.BND" file


ZERO	HS	0			: beginning of area to be zero'ed out

SAVE	WS	10			: general register-save area

CEIBGN	HS	1			: record initial CEI here

TO9	HS	2			: Link for TIMEOUT processing
TLIST	HS	2			: Timeout list head


:	LOGON Parameters
:	(Maintain order of *'ed elements)
LO.LEN	HS	1			:*length of item
LO.INV	HS	3			: INVOICE-number
LO.HST	HS	1			: Host-number
LO.PRT	HS	1			: Destination port
LO.OPT	HS	1			: Origination port
LO.SPT	HS	1			: Source Port
LO.PTP	HS	1			: Origin Permuter-table index
LO.KEY	HS	1			: Destination Key
LO.INT	HS	1			: flag...<0 if internal circuit
LO.AUX	HS	1			: flag...<0 if AUX circuit
LO.SHU	HS	1			: flag...<0 if SHUT-override
LO.IIX	HS	1			: flag...<0 if IIX-capable
LO.WHY	HS	1			: termination reason
LO.SIZ	EQ	.-LO.LEN		: size of this section

  if	LOG.II

:	LOG-II parameters for X.409 interpretation
X4.LEN	HS	1			: total length
X4.LFT	HS	1			: bytes left in list
X4.CLS	HS	1			:*element CLASS
					:   0 -	Universal
					:   1 -	application-wide
					:  -1 -	context-specific
					: packed together with element FORM:
					:   0 -	Primative
					:   1 -	Constructor
X4.ID	HS	1			:*element ID
X4.VAL	HS	X4.VSZ/2		:*value
X4.VND	HS	0			:*value-end
X4.SIZ	EQ	X4.VND-LO.LEN		:*the size of the X4 descriptor
  ei	:LOG.II

AATEMP	HS	2			: ACCOUNTING Message temp store
AATYPE	HS	2			: ACCOUNTING Message-type store
AALINS	HS	3			: last INVOICE-number sent
AACC.	HS	2			: Word for Current Channel-pointer (index)
AASAVE	HS	20			: Accounting saves registers here

RET	HS	2			: Location to save Return-address

SORCX	HS	1			: Save Source-slot Key here
SORPOR	HS	1			: Save Source-port here
CURPAT	HS	2			: Save current path here

DCTEMP	HS	2			: temp for DCDEST
s.save	hs	6			: temp for rels.c
TEMP	HS	2			: what else?
TEMP1	HS	1			: same for HW

FREBFL	HS	2			: Free-list pointer for Bufferlets
RTANK	HS	2			: Free-list pointer for Reserve-Tank
					: (if > 0...else empty)
BFZ	HS	1			: Buffer-ZAP Statistics


:	Host-table storage
HSTTBL	HS	NUMHST*H.LEN/2		: entries for NUMHST hosts
HSTSVE	HS	1			: host slot value
RETVEC	WS	1			: return vector


C.FREE	WS	1			: pointer to list of free Channels
C.POOL	BS	C.LEN*NCHAN		: the storage for channels
C.PEND	HS	0			: End of pool

:	The Buffer-storage
:	Each bufferlet is a total of BFL.SZ bytes long...
:	The FIRST four bytes contain the chain-pointer
	BND	BFL.SZ			: insure pointer allignment
NO.OVL	EQ	10000			: overflow boundary
: define Q as the number of bufferlets the configuration requires plus
: what is left over in a page boundary.
: define QWQ as the number of bufferlets that insures we have no data overflow
:
Q	EQ	((400-((.+DI.BFL*BFL.SZ)&3FF))/BFL.SZ)+DI.BFL
QWQ	EQ	NO.OVL/(BFL.SZ-4)
	IF	Q-QWQ		
Q	EQ	QWQ			: apply a govenor
	EI
NBFLET	EQ	Q			: actual number of bufferlets allocated
BLSIZE	EQ	NBFLET*BFL.SZ		: size of bufferlet storage
BFLETS	BS	BLSIZE			: bufferlet storage
ZEROSZ	EQ	.-ZERO			: size of area to be zeroed out

	REMARK	%   
	NUMBER	$A NBFLET
	REMARK	d (
	NUMBER	$A BFL.SZ
	REMARK	d-byte) bufferlets allocated to dispatcher
 else
IEND	EQ	.			: How much to load in "*.BND" file
 ei	: (DISPAT)
	EM
	SUBTTL	CONF - FINISH ISIS CODE GENERATION AND DISPLAY CONFIG

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other   purpose except as specifically authorized in  wri-  **
: **  ting by  TYMNET, Incorporated.                              **
: ******************************************************************

  IF	KIOSRC				:

	RA	$0 0A

:	.......................................................................
:	ALLOCATE SIO USER RINGS
:	.......................................................................

QQ1	EQ	0			:SLOT #
	RE	NPART+1
QQ2	 EQ	0			:SLU #
QQ5	 EQ	1			:NEW SLOT FLAG
	 RE	SLUNUM+1
	  IF	\U|QQ1|M|QQ2|
	   IF	QQ5
	    BND	PAGE			:NEW SLOT MUST BE ON PAGE
	    WC	0			:NEEDED FOR FUNKY COPY INSTR.
QQ5	    EQ	0
	   EI
QQ3	   EQ	U|QQ1|M|QQ2|
QQ4	   EQ	U|QQ1|P|QQ2|
	   GL	Z|QQ3|B|QQ4|
Z|QQ3|B|QQ4| EQ	.
	   HS	(Z|QQ3|I|QQ4|/2)+2
	   HS	(Z|QQ3|O|QQ4|/2)+2
	  EI
QQ2	  EQ	QQ2+1
	 ER
QQ1	 EQ	QQ1+1
	ER

:	.......................................................................
:	ALLOCATE SIO KIO RINGS
:	.......................................................................
					:
   IF	MLUSW				:
KIRCTL	MACRO(Q1Q,Q2Q) [
    IF Q2Q
     IF Q2Q-1
     ELSE
      IF	MBL|Q1Q|M-1
DKOFRG	       EQ .			:KIO DESTINATION NEWLOG RING
      ELSE MBL|Q1Q|M
SNEWRG	       EQ .			:KIO SOURCE NEWLOG RING
      EI
     EI
    ELSE
     IF	MBL|Q1Q|M-1
DKCTLI	      EQ .			:KIO DESTINATION CTL IRING
     ELSE
SKCTLI        EQ .			:KIO SOURCE CTL IRING
     EI
    EI

]					:
					:
KORCTL	MACRO(Q1Q,Q2Q) [
    IF Q2Q				:
     IF	Q2Q-1				:
     ELSE				:
      IF MBL|Q1Q|M-1			:
DNEWRG	EQ .				:KIO DESTINATION KOF RING
      ELSE				:
SKOFRG  EQ .				:KIO SOURCE KOF RING
      EI
     EI
    ELSE
     IF	MBL|Q1Q|M-1
DKCTLO	EQ .				:KIO DESTINATION CTL ORING
     ELSE				:
SKCTLO	      EQ .			:KIO SOURCE CTL ORING
     EI					:
    EI

]					:

   EI  (MLUSW)				:
					:
   IF	MLUSW				:
QQ1	EQ	0			:M-BOARD LU #
	RE	MLUNUM+1
	IF	\MBL|QQ1|N
	 IF	MBL|QQ1|K
QQ2	EQ	0			:M-BOARD PORT #
	  RE	KPORTS+2		:KIO CTL AND DATA RINGS
	    GL	Z|QQ1|B|QQ2|
Z|QQ1|B|QQ2| EQ	.			:RING BASE ADDRESS
	    HS	(Z|QQ1|I|QQ2|/2)+2	:ALLOCATE INPUT RING
	    KIRCTL(QQ1,QQ2)		:
	    HS	(Z|QQ1|O|QQ2|/2)+2	:ALLOCATE OUTPUT IRING
	    KORCTL(QQ1,QQ2)		:
QQ2	    EQ	QQ2+1
	  ER
	 EI	:MBL|QQ1|K
	EI
QQ1	EQ	QQ1+1			:
	ER
   EI  (MLUSW)				:
					:
:	.......................................................................
:	ALLOCATE SIO RING DESCRIPTORS
:	.......................................................................
					:
   IF	MLUSW				:
SIORNG	MACRO(Q1Q,Q2Q,Q3Q,Q4Q) [
	HC	Q3Q			:INPUT RING SIZE
	HC	Q4Q			:OUTPUT RING SIZE
	WC	Z|Q1Q|B|Q2Q|+Q3Q+4	:INPUT RING END ADDR
	WC	Z|Q1Q|B|Q2Q|+Q3Q+Q4Q+8	:OUTPUT RING END ADDR
	BC	Q2Q			:M-BOARD PORT #
	BC MBL|Q1Q|A			:M-BOARD DEVICE ADDR
	HC	Q1Q			:M-BOARD LU #
]					:
   EI  (MLUSW)				:
					:
	IF	MLUSW
QQ1	 EQ	0			:M-BOARD LU #
QQ5	 EQ	0			:INITIAL DESCRIPTOR FOR BOARD
	 BND	16			:ON QUAD-WORD BOUNDRY
MBLSTR	 EQ	.	
	 RE	MLUNUM+1
	  IF	\MBL|QQ1|N
	   IF	MBL|QQ1|M-1		:KIO SOURCE MACH IS -1
DESDSC	    EQ	.			:DEST MACH DESCRIPTORS
	   ELSE MBL|QQ1|M
SRCDSC	    EQ	.			:SRC MACH DESCRIPTORS
	   EI
QQ2	   EQ	0			:M-BOARD PORT #
MBL|QQ1|D EQ	QQ5
	   RE	MBL|QQ1|N
	    IF	\Z|QQ1|B|QQ2|
	     BND  16			:ON QUAD-WORD BOUNDRY
Z|QQ1|D|QQ2|  EQ	.
QQ3	     EQ	Z|QQ1|I|QQ2|		:INPUT RING SIZE
QQ4	     EQ	Z|QQ1|O|QQ2|		:OUTPUT RING SIZE
	     SIORNG(QQ1,QQ2,QQ3,QQ4)
	    EI
QQ2	    EQ	QQ2+1
QQ5	    EQ	QQ5+1
	   ER
	  EI
QQ1	  EQ	QQ1+1
	 ER
MBLEND	 EQ	.
	EI

:	.......................................................................
:	ALLOCATE MOTHER BOARD LU DESCRIPTORS
:	.......................................................................
					:
   IF	MLUSW				:
QQ1	 EQ	0			:M-BOARD LU #
MLUTBL	 HS	0			:FORCE BOUNDRY
	 RE	MLUNUM+1
	  IF	\MBL|QQ1|N
	   BC	MBL|QQ1|A		:M-BOARD ADDR
	   BC	MBL|QQ1|N		:# OF DESCRIPTORS
	   BC	MBL|QQ1|D		:STARTING DESCRIPTOR
	   BC	MBL|QQ1|M		:MACHINE #
	  ELSE
	   HC	0
	   HC	0
	   HC	0
	   HC	0
	  EI
QQ1	  EQ	QQ1+1
	 ER
   EI  (MLUSW)				:
IEND	EQ	.			:END OF ISIS FOR .NIB
					:
	RA	$0 0			:
  EI   (KIOSRC)				:
SYSEND	EQ	.			:End of ISIS code/data area
					:

:	.......................................................................
:	SLOT DMA AREAS ALLOCATION
:	1. Allocate Sup/Slave DMA areas first then
:	2. Allocate Slots' DMA areas
:	.......................................................................
					:
  IF	SUP				:
    if macv
	BND	PAGE			:
	GL	DMABGN,DMAEND		:
DMABGN	EQ	.			:
   IF	DSZSUP				:
SBDMBA  HS	DSZSUP*(PAGE/2)		:ALLOCATE MEMORY
SBDMRG  EQ	$0 SMACK(DSZSUP,(SBDMBA/PAGE))!MASK9 :CREATE SEGMENTATION REG
   ELSE					:
SBDMRG  EQ	0			:
   EI  (DSZSUP)				:
   IF	DSZPRB				:
	BND	PAGE			:
PRDMBA  HS	DSZPRB*(PAGE/2)		:ALLOCATE MEMORY
PRDMRG  EQ	$0 SMACK(DSZPRB,(PRDMBA/PAGE))!MASK9 :CREATE SEGMENTATION REG
   ELSE					:
PRDMRG  EQ	0			:
   EI  (DSZPRB)				:
   IF	DSZERR				:
	BND	PAGE			:
ERDMBA  HS	DSZERR*(PAGE/2)		:ALLOCATE MEMORY
ERDMRG  EQ	$0 SMACK(DSZERR,(ERDMBA/PAGE))!MASK9 :CREATE SEGMENTATION REG
   ELSE					:
ERDMRG  EQ	0			:
   EI  (DSZERR)				:
   IF	DSZACT				:
	BND	PAGE			:
ACDMBA  HS	DSZACT*(PAGE/2)		:ALLOCATE MEMORY
ACDMRG  EQ	$0 SMACK(DSZACT,(ACDMBA/PAGE))!MASK9 :CREATE SEGMENTATION REG
   ELSE					:
ACDMRG  EQ	0			:
   EI  (DSZACT)				:
   IF	DSZSYS				:
	BND	PAGE			:
SYDMBA  HS	DSZSYS*(PAGE/2)		:ALLOCATE MEMORY
SYDMRG  EQ	$0 SMACK(DSZSYS,(SYDMBA/PAGE))!MASK9 :CREATE SEGMENTATION REG
   ELSE					:
SYDMRG  EQ	0			:
   EI  (DSZSYS)				:
   IF	DSZUN2				:
	BND	PAGE			:
UNDMBA  HS	DSZUN2*(PAGE/2)		:ALLOCATE MEMORY
UNDMRG  EQ	$0 SMACK(DSZUN2,(UNDMBA/PAGE))!MASK9 :CREATE SEGMENTATION REG
   ELSE					:
UNDMRG  EQ	0			:
   EI (DSZUN2)				:
   IF	DSZUTL				:
	BND	PAGE			:
UTDMBA  HS	DSZUTL*(PAGE/2)		:ALLOCATE MEMORY
UTDMRG  EQ	$0 SMACK(DSZUTL,(UTDMBA/PAGE))!MASK9 :CREATE SEGMENTATION REG
   ELSE					:
UTDMRG  EQ	0			:
   EI  (DSZUTL)				:
					:
:	.......................................................................
:	DEFINE SUPERVISOR-NODE CODE COMMUNICATIONS COMMON AREA
:	.......................................................................
					:
	BND	PAGE			:
SCMAC	EQ	MACVAL(SCSIZ,.,8)!80000000	:COMMON AREA FOR SUP COMM
SCAREA	HS	SCSIZ/2			:
DMAEND	EQ	.			:End of relocated DMA area
     ei (macv)
   EI  (SUP)				:
					:
:	.......................................................................
:	Allocate DMA areas for conventional slots where
:	X - Slot number
:
:	DMA|X|   - Address of slot DMA area
:	DMSZ|X| - Size of slot DMA area
:
:	.......................................................................
					:
 IF	SUP				:
 ELSE					:
  IF	MACV				:Only if it is a MAC-5 machine
   IF	DMAREL				:Only if DMA relocation requested
    IF \DMABGN				:
    ELSE				:
	GL	DMABGN,DMAEND		:
DMABGN	EQ	.			:Begining address of relocated DMA area
    EI (DMABGN)				:
X	EQ	0			:Start with slot 0
	RE	$A NSLOT+1
   IF  \DMSZ|$AX|
	GL	DMA|$AX|
	BND	PAGE
DMA|$AX|	HS	DMSZ|$AX|*(PAGE/2)
   EI  (  )
X	EQ	$A X+1
	ER
DMAEND	EQ	.			:
   EI  (DMAREL)				:
  EI  (MACV)				:
 EI   (SUP)				:
					:
:	.......................................................................
:	Check slot DMA relocation area .vs. 1MG boundary
:	.......................................................................
					:
  IF	\DMABGN				:
   IF	.GT.(DMAEND,SEGSIZ)		:
	REMARK	%Slot DMA area allocation exceeds 1-MByte boundary ... Slot DMA 
	REMARK	%relocation cancelled! Please consider following suggestions:
	REMARK	%
	REMARK	%	1. Reduce the size of DMA segment to be relocated
	REMARK	%	2. Reduce the number of slot with DMA usage
	REMARK	%%%
   EI  
  EI   (DMAREL)				:
					:
:	.......................................................................
:	DEFINE MICRO-CODED ASYNC RING-STORAGE AREA
:	.......................................................................
					:
	LO	CLOCKS			:
	BND	100			:START OF RING STORAGE
AS.CTL	BS	A.CSIZ			:CONTROL STORAGE
AS.LCT	BS	A.LSIZ			:TIMEOUT STORAGE
AS.RNG	BS	AS.SIZ			:RING STORAGE
AS.ERN	BS	0			:END-OF-RING STORAGE
	FO	CLOCKS			:
					:
   IF	MSLOT				:
:	.......................................................................
:	MONITOR SLOT STORAGE
:	.......................................................................
					:
	BND	PAGE			:FORCE TO PAGE BOUNDARY
Q	EQ	NSLOT			:
MSTA	BS	S|Q|CORE*400		:SET ASIDE SOME STORAGE
   EI  (MSLOT)				:
					:

:	.......................................................................
:
:	Setup conventional slot DMA relocation reference table
:
:		        ....................
:			| Addr of DMA area |
:		Slot 0  ....................
:			| Size of DMA area |
:			....................
:			|	.	   |
:			....................
:		   .	|	.	   |
:		   .	....................
:		   . 	| Addr of DMA area |
:		Slot F	....................
:			| Size of DMA area |
:			....................
:
:	where Address of DMA area is the begining physical address for each
:	slot DMA area.
:
:	DMABTBL  - Beigning address of slot DMA relocation reference table
:
:	.......................................................................
					:
	BND	PAGE			:Force to the current page boundary
DMAMAP	EQ	.			:Begining address of refernece table
	ORG	DMAMAP			:
   IF	MACV				:
    IF	.GT.(MAXDMA,$A64)		:
	REMARK	%%%No more than 64 slots may request for DMA segment relocation!
	REMARK	%Number of slots for DMA segment allocation is reduced to 64...%
    EI (NSLOT)				:
   EI  (MACV)				:
	WS	0			:
X	EQ	$A 0			:Start with slot 0
	RE	$A 64
    IF	\DMA|$AX|
	WC	DMA|$AX|		:Slot DMA area physical start address
	WC	DMSZ|$AX|
    ELSE
	WC	0,0
    EI (  )
X	EQ	$A X+1
	ER
	KILL	X			:
					:
:	.......................................................................
:	ISIS System Configuration Table
:	.......................................................................
					:
SYSCON	HC	ENGVER			:Type of machine in use
	HC	CPUVER			:Type of CPU in use
	HC	MACVER			:Type of MAC controller in use
	HC	-1			:
	HC	-1			:
	HC	-1			:
	HC	-1			:
	HC	-1			:
	WS	4			:
					:
IEND	EQ	.			:End of ISIS cod/data area
					:
NCTA	BND	PAGE			:WHERE SLOT 0 WILL START
NCTAS   EQ      NCTA^MSHFTA             :ADJUSTED FOR MAC REG FORMAT
					:
   IF	SUP				:
:	.......................................................................
:	DEFINE SUP'S COMMON AREA 1
:	.......................................................................
					:
S1.CMN	EQ	(NCTAS+QSC1M0)!80000000	:SUP COMMON AREA 1
					:
:	.......................................................................
:	DEFINE LOCATION TO PLACE WWVB TIME FOR SUPERVISOR
:	.......................................................................
					:
S.TIME	EQ	S.COMN+NCTA		:CURRENT TIME, DERIVED FROM WWVB (WORD)
   EI  (SUP)				:


	SUBTTL	DISPLAY ISIS CONFIGURAION

:	.......................................................................
:	PRINT OUT ISIS CONFIGURATION
:	.......................................................................

	RA	$A 10

	REMARK	%.............................................
	REMARK	%%%%    ***  ISIS-II System Configuration  ***
	REMARK	%      		Version 
	NUMBER	VERSION/100
	REMARK	.
   IF	(VERSION-((VERSION/100)*100))-9
   ELSE
	REMARK	0
   EI
	NUMBER	VERSION-((VERSION/100)*100)
	REMARK	d%
	REMARK	%Total ISIS system memory used - 
X	EQ	(IEND+1023)/1024
	NUMBER	X
	REMARK	dK Byte(s) %
	REMARK	Memory used by ISIS operating system itself - 
X	EQ	(SYSEND+1023)/1024
	NUMBER	X
	REMARK	dK Byte(s)%
   IF  \DMAEND
X	EQ	((IEND-DMAEND+1023)/1024)
   ELSE
X	EQ	((IEND+1023)/1024)-((SYSEND+1023)/1024))
   EI  (DMAEND)
	REMARK	Misc. data area used by ISIS operating system - 
	NUMBER	X
	REMARK	dK Byte(s)%
   IF	MACV
    IF	\DMABGN
X	EQ	((DMAEND-SYSEND)+1023)/1024
	REMARK	ISIS has reserved 
	NUMBER	X
	REMARK	dK bytes low core memory for slots' DMA area relocation%
    ELSE
	REMARK	There are no slot DMA memory reserved by ISIS Operating System%
    EI (DMABGN)				:
   EI  (MACV)				:
   IF	\DMABGN				:
X	EQ	((SEGSIZ-DMAEND)+1023)/1024
   ELSE					:
X	EQ	((SEGSIZ-SYSEND)+1023)/1024
   EI  (DMAREL)				:
   IF	MACV				:
    IF	X				:
	REMARK	There are 
	NUMBER	X 
	REMARK	dK bytes low core memory available for slot DMA area allocation%
    ELSE				:
	REMARK %There is no more low core memory available for DMA relocation
    EI (X)
   EI  (MACV)				:
					:
   IF	SPAM
        REMARK %System Performance Analysis Monitor (SPAM) Enabled
   EI  (SPAM)
   IF   SPMTRC
        REMARK %%SPAM Job Trace Debug Logic Enabled%
   EI  (SPMTRC)
   IF	DB.FLG&0016
	 REMARK	%****  ***** ****  *   *  ****
	 REMARK	%*   * *     *   * *   * *
	 REMARK	%*   * ****  ****  *   * *  **
	 REMARK	%*   * *     *   * *   * *   *
	 REMARK	%****  ***** ****   ***   ****%
   EI  (DB.FLG&0010)
	IF	SUP;	 REMARK	%%    === SUPERVISOR ===%;	EI
	IF	MXP
	 REMARK	%MXP machine number 
	 NUMBER	$A MXPNM
	EI
	IF	MACHNM
	 REMARK	%%TYMNET-II Node 
	 NUMBER	$8 (MACHNM)
	 REMARK	, Kernel Host 
	 NUMBER	$A HST0
	ELSE
	 REMARK %No node code in machine
	EI
	REMARK	%%Maximum slot number is 
	NUMBER	$A (NSLOT)

:	.......................................................................
:	PRINT OUT EXPECTED HARDWARE CONFIGURATION
:	.......................................................................

	REMARK	%%%       >>> HARDWARE CONFIGURATION <<<%

	IF	MACHIN-1
	IF	HMICRO
	REMARK	%Expects HDLC Micro Engine
	ELSE	TSI
	REMARK	%Expects TSI hardware
	ELSE	NANO
	REMARK	%Expects NANO hardware
	EI
	ELSE
	REMARK	%Expects enhanced sync microcode

	IF	SUP
	 LO	SUPER
	 IF	SUPMIC-1
	 FO	SUPER
	  REMARK %Expects supervisor microcode
	 ELSE
	  REMARK %Expects enhanced async microcode
	 EI
	ELSE
	 REMARK	%Expects enhanced async microcode
	EI	(SUP)

	IF	MACV
	 REMARK	%Expects MAC V
	ELSE	ZITEL
	 REMARK	%Expects MAC II
	ELSE
	 REMARK	%Expects MAC I
	EI
	IF	BAUDR
	 REMARK	%Expects maximum baud rate of 4800
	ELSE
	 REMARK	%Expects maximum baud rate of 1200
	EI
	IF	NSYNC
	 REMARK	%Expects 
	 NUMBER NSYNC/$010
	 REMARK  sync board(s)
	EI
	IF	NASYNG
	 REMARK	%Expects 
	 NUMBER (NASYNG+1)/2
	 REMARK  async board(s), device address is 
	 LO	CLOCKS;	  NUMBER	$0  ADA;	  FO	CLOCKS
	 IF	ASYNEW-1
	 REMARK	%Supports new async driver only
	 ELSE	ASYNEW
	 REMARK	%Supports both old and new async driver
	 ELSE
	 REMARK	%Supports old async driver only
	 EI
	EI	(NASYNG)
	IF	MXP
	 REMARK	%Expects 1 XPI, device address is 
	 NUMBER	$0 XPIAD
	EI
	IF	NPRINT
	 REMARK	%Expects 
	 NUMBER	NPRINT
	 REMARK	 printer(s)
	EI
	IF	M.NCARD
	 REMARK	%Expects 
	 NUMBER	M.NCARD
	 REMARK	 SIO mother-board processor(s)
Q	 EQ	0
	 RE	M.NCARD
	 REMARK	%   Board 
	 NUMBER	Q
	 REMARK	 has 
	 NUMBER	M.NP|Q|
	 REMARK	 channel(s), device address 
	 NUMBER	$0 M.DA|Q|
Q	 EQ	Q+1
	 ER
	EI
	IF	KIOSRC
	IF	MLUSW
	 REMARK	%Expects 
	 NUMBER	MLUNUM+1
	 REMARK	 SIO ring copy processor(s)
Q	 EQ	0
	 RE	MLUNUM+1
	 REMARK	%   Board 
	 NUMBER	Q
	 REMARK	 has 
	 NUMBER	MBL|Q|N
	 REMARK	 ring pair(s), device address 
	 NUMBER	$0 MBL|Q|A
Q	 EQ	Q+1
	 ER
	EI	(MLUSW)
	EI	(KIOSRC)
	EI	(MACHIN-1)
	IF	NDISC
	 IF	TSIDT
	 ELSE
	  REMARK %Expects 
	  NUMBER NDISC
	  REMARK  10MB disc drive(s)
	 EI
	EI
	IF	NTAPE
	 IF	TSIDT
	  REMARK %Expects MDCSC Tape Server with 
	  NUMBER NTAPE
	  REMARK  tape drive(s)
	 ELSE
	  REMARK %Expects 
	  NUMBER NTAPE
	  REMARK  tape drive(s)
	 EI	(TSIDT)
	EI
	IF	MSCDSK
	 IF	TSIDT
	  REMARK %Expects MDCSC Disc Server
	 ELSE
	 REMARK	%Expects 
	 NUMBER	MSCDSK
	 REMARK	 MSC-1400 disc controller(s)
	 IF	MSCDSK-1
Q	  EQ	0
	  RE	MSCDSK
	   REMARK %   Controller 
	   NUMBER Q
	   REMARK  has 
	   NUMBER NMSC|Q|
	   REMARK  drive(s)
Q	   EQ	Q+1
	  ER
	 ELSE
	  REMARK  w/ 
	  NUMBER NMSC0
	  REMARK  drive(s)
	 EI
	 EI	(TSIDT)
	EI
        IF      IPNMBR
         REMARK %Expects 
         NUMBER IPNMBR
         REMARK  IPI processor(s)
Q	 EQ	0
	 RE	IPNMBR
	 REMARK %   IPI device 
	 NUMBER Q
	 REMARK  has device address 
	 NUMBER $0 IPIAD|Q|
Q	 EQ	Q+1
	 ER
        EI

					:
:	.......................................................................
:	Calculate starting address of DMA area for each slot
:	.......................................................................
					:
X	EQ	$A 0			:Index for slot number
	RE	$A NSLOT+1
   IF  \DMSZ|X|
DMST|X|	EQ	DMA|X|
   EI
X	EQ	$A X+1
	ER
					:
:	.......................................................................
:	PRINT OUT SLOT CONFIGURATIONS
:	.......................................................................

:	DEFINE MACRO TO DISPLAY LU USAGE FOR SLOTS

IGTXT1	MACRO(Q)[
	IF	NLUS|Q|
	 REMARK	%   
	 NUMBER	$A NLUS|Q|
	 REMARK	 logical unit(s)
MASK	 EQ	$0 0F
QQ	 EQ	0
	 RE	NLUS|Q|
U	 EQ	S|Q|L|QQ|
	 REMARK	%   L.U. 
	 NUMBER	$A QQ
	 REMARK	 is 
	 IF	U+1
V	  EQ	U&M1
U	  EQ	U&M2
E
	  IF	V-IPIDEV; REMARK Spirit Bus device 
	  ELSE	V-M.CARD; REMARK IPI device 
	  ELSE	V-UDEV
	        REMARK	mboard 
MBQ		EQ	U^-4
CHQ		EQ	U&MASK
		NUMBER	$0 M.DA|MBQ| 
		REMARK	 channel 
		NUMBER	$A CHQ 
	  ELSE	V-PRN;	REMARK	unsupported device line 
	  ELSE	V-ASN;	REMARK	printer 
	  ELSE	V;	REMARK	async group 
	  ELSE;	REMARK	sync line 
	  EI

	  IF	V-UDEV
	  ELSE
	  	NUMBER	$A U
	  EI
	  
	 ELSE
	  REMARK	unused
	 EI
QQ	 EQ	QQ+1
	 ER
	ELSE
	 REMARK	%   no logical units
	EI
]

:	.......................................................................
:	PRINT SIO USER RING ALLOCATIONS
:	.......................................................................
					:
SLUOUT	MACRO(Q)[
   IF	KIOSRC
    IF	SLUSW
QQ	 EQ	0
	 RE	SLUNUM+1
	 IF	\U|Q|M|QQ|
QQ	  EQ	QQ+1
	 EI
	 ER
	 IF	QQ
	  REMARK	%   
	  NUMBER	$A QQ
	  REMARK	 SIO user ring(s)
	 EI	(QQ)
QQ	 EQ	0
	 RE	SLUNUM+1
	 IF	\U|Q|M|QQ|
	  REMARK	%   User ring 
	  NUMBER	$A QQ
	  REMARK	 on SIO ring board 
	  NUMBER	$A U|Q|M|QQ|
	 EI
QQ	 EQ	QQ+1
	 ER
    EI (SLUSW)
   EI  (KIOSRC)
]

:	.......................................................................
:	DXTMAC - DEFINE MACRO TO OUTPUT MAP OF EXTENDED MAC AREAS WHERE
:	  SLOT - SLOT NUMBER TO MAP
:	.......................................................................
					:
DXTMAC	MACRO(SLOT) [
	RA	$0 0
Q5	EQ	3			:Q5 IS BLOCK NUMBER
	RE	$A 13			:CHECK FOR 13 BLOCKS
   IF	\M|SLOT|L|$AQ5|
    IF	M|SLOT|L|$AQ5|&$00FFFE0000
	REMARK	%       extended mac block 
	NUMBER	$AQ5
	REMARK	 is from 
Q6	EQ	(M|SLOT|L|$AQ5|&$00FFFF0000)/100	:EXTRACT STARTING PAGE
	NUMBER	Q6
	REMARK	 to 
Q7	EQ	(M|SLOT|L|$AQ5|&$00FFFF)*100	:EXTRACT NUMBER OF PAGES
Q7	EQ	Q7+0FF			:CALCULATE ENDING ADDRESS
	NUMBER 	Q7
    EI	
   EI
Q5	EQ	Q5+1
	ER	
	RA	$0 0A	]

:	.......................................................................
:	DEFINE MACRO TO SET UP SLOT ADDRESSES
:	.......................................................................
					:
UBXFIL  MACRO   [
        ORG     Q4              	:GET TO MAC AREA
        WC      Q2
Q4      EQ      .               	:REMEMBER WHERE
					:
   IF	NBLKS
PAGE1   EQ      Q2^-8
PAGE2   EQ      ((Q2+Q3)^-8)-1
        LO      KERNEL
        ORG     UBX|Q|+BLOCKS
        HC      PAGE1
        HC      PAGE2
        FO      KERNEL
   EI  (NBLKS)
]

:	.......................................................................
:	DEFINE MACRO TO DISPLAY SLOT CORE ALLOCATIONS
:	.......................................................................
					:
DCORE	MACRO[
X	EQ	$A Q
Q3	EQ	S|X|CORE
	REMARK	%%SLOT 
	NUMBER	$A Q
	IF	(.GT.(MACHNM,0))&(.EQ.(Q,0))
	 REMARK	, NODE CODE,
	EI
	IF	MXP
	 IF	.EQ.(Q,SLTXMI)
	 REMARK	, XPI MEMORY IMAGE,
	 EI
	EI
	REMARK	 has 
	NUMBER	$A Q3
   IF	MACV
	REMARK	 K-bytes of conventional core memory
    IF \DMSZ|X|
	REMARK	%%There are 
	NUMBER	$A DMSZ|X|
	REMARK  K-bytes of system core memory reserved by ISIS for DMA usage
    EI (DMSZ|X|)
    IF \DMST|X|
X1	EQ	DMST|X|
X2	EQ	DMSZ|X|
	REMARK	%%Slot DMA Segment(s) are allocated from 
	NUMBER	$0 X1
	REMARK	 to 
	NUMBER	$0 (X1+(X2*400))
    EI (DMST|X|)
	REMARK	%%Slot conventional memory is allocated from 
   ELSE
	REMARK	 K-bytes of core, from 
   EI  (MACV)
					:
:	.......................................................................
:	  Q2	 = Starting address of slot (Physical)
:	  Q3	 = Ending   address of slot (Physical)
:	DMSZ|Q|  = Size of slot DMA area have been relocated
:	.......................................................................
					:
Q3	EQ	1024*Q3			:
   IF   MSLOT*(Q+1-NSLOT)		:
        NUMBER $0 MSTA
        REMARK	 to 
        NUMBER  $0 MSTA+Q3-1
XXX     EQ      Q2
Q2      EQ      MSTA
        UBXFIL
Q2      EQ      XXX
   ELSE					:
	NUMBER	$0 Q2
	REMARK	 to 
	NUMBER	$0 Q2+Q3-1
	REMARK	 (Physical address)
	REMARK	%
        UBXFIL
Q2	EQ	Q2+Q3
   EI
]					:End of MACRO DCORE

:	.......................................................................
	REMARK %%       >>> SLOT CONFIGURATIONS <<<
:	.......................................................................
					:
        ORG     MACAREA         	:PLACE TO PUT MEMORY POSITION INFO
Q       EQ      0               	:SLOT 0
Q2      EQ      NCTA            	:START OF SLOT 0
Q4      EQ      .               	:SLOT ADDRESS INFORMATION

        RE      NSLOT+1
	DCORE(Q)			:DISPLAY CORE REQUIREMENTS
	DXTMAC(Q)			:DISPLAY EXTENDED MAC AREAS
   IF	S|Q|LIC&TL.SUS
	 REMARK	%   Suspend license
   EI
	IGTXT1(Q)
	SLUOUT(Q)
Q	EQ	Q+1
	ER

   IF	SUP

:	.......................................................................
:	SUPERVISOR SLOTS
:	.......................................................................

	 LO	SUPDEF
	 ORG	Q4
Q3	 EQ	$0 SUPCORE*PAGE		:SUP AREA
	 WC	$0 Q2!01000000		:TABLE
	 REMARK	%%slot 
	 NUMBER	$A Q
	 REMARK	, SUPERVISOR, has 
	 NUMBER	$A (Q3+1023)/1024
	 REMARK	 K-bytes of core, from 
	 NUMBER	$0 Q2
	 REMARK	 to 
	 NUMBER	$0 Q2+Q3-1
	 SLUOUT(Q)
Q2	 EQ	Q2+Q3
Q	 EQ	Q+1

Q3	 EQ	$0 PROA0*PAGE		:PROBE AREA
	 WC	$0 Q2!02000000		:TABLE
	 REMARK	%%slot 
	 NUMBER	$A Q
	 REMARK	, PROBE, has 
	 NUMBER	$A (Q3+1023)/1024
	 REMARK	 K-bytes of core, from 
	 NUMBER	$0 Q2
	 REMARK	 to 
	 NUMBER	$0 Q2+Q3-1
Q2	 EQ	Q2+Q3
Q	 EQ	Q+1

Q3	 EQ	$0 ERRA0*PAGE		:ERRLOG AREA
	 WC	$0 Q2!03000000		:TABLE
	 REMARK	%%slot 
	 NUMBER	$A Q
	 REMARK	, ERRLOG, has 
	 NUMBER	$A (Q3+1023)/1024
	 REMARK	 K-bytes of core, from 
	 NUMBER	$0 Q2
	 REMARK	 to 
	 NUMBER	$0 Q2+Q3-1
Q2	 EQ	Q2+Q3
Q	 EQ	Q+1

Q3	 EQ	$0 ACCA0*PAGE		:ACCOUNTING AREA
	 WC	$0 Q2!04000000		:TABLE
	 REMARK	%%slot 
	 NUMBER	$A Q
	 REMARK	, ACCOUNT, has 
	 NUMBER	$A (Q3+1023)/1024
	 REMARK	 K-bytes of core, from 
	 NUMBER	$0 Q2
	 REMARK	 to 
	 NUMBER	$0 Q2+Q3-1
Q2	 EQ	Q2+Q3
Q	 EQ	Q+1

Q3	 EQ	$0 SYSA0*PAGE		:SYSMSG1 AREA
	 WC	$0 Q2!05000000		:TABLE
	 REMARK	%%slot 
	 NUMBER	$A Q
	 REMARK	, SYSMSG1, has 
	 NUMBER	$A (Q3+1023)/1024
	 REMARK	 K-bytes of core, from 
	 NUMBER	$0 Q2
	 REMARK	 to 
	 NUMBER	$0 Q2+Q3-1
Q2	 EQ	Q2+Q3
Q	 EQ	Q+1

Q3	 EQ	$0 UN2A0*PAGE		:UN2 AREA
	 WC	$0 Q2!06000000		:TABLE
	 REMARK	%%slot 
	 NUMBER	$A Q
	 REMARK	, UN2, has 
	 NUMBER	$A (Q3+1023)/1024
	 REMARK	 K-bytes of core, from 
	 NUMBER	$0 Q2
	 REMARK	 to 
	 NUMBER	$0 Q2+Q3-1
Q2	 EQ	Q2+Q3
Q	 EQ	Q+1

Q3	 EQ	$0 (UTILA0+UTILA1)*PAGE	:UTILITY AREA
	 WC	$0 Q2!07000000		:TABLE
	 REMARK	%%slot 
	 NUMBER	$A Q
	 REMARK	, UTIL, has 
	 NUMBER	$A (Q3+1023)/1024
	 REMARK	 K-bytes of core, from 
	 NUMBER	$0 Q2
	 REMARK	 to 
	 NUMBER	$0 Q2+Q3-1
Q2	 EQ	Q2+Q3
Q	 EQ	Q+1

	 FO	SUPDEF
   EI	(SUP)

					:
TOTMEM	EQ	$A (Q2+1023)		:
SLTEND	EQ	Q2			:END OF SLOT MEMORY
	ORG	$0 2DC			:PLACE END-OF-CORE WORD
	WC	Q2			:
	ORG	NCTA			:NOW, BACK TO END LOCATION
					:
MEMCON	EQ	(Q2+1023)/1024		:Total configured system memory size
	REMARK	%%***Highest location used in this configuration is 
	NUMBER	$0 Q2
:
     if macv
     else
	if (memcon-totsiz)
	   REMARK %%MEMORY SIZE CONFIGURATION INCONSISTENCY!%%
	   REMARK Assembly Memory Size Exceeds Total Configuration Memory Size%%
	   REMARK Assembly Memory Size:          
	   NUMBER $A MEMCON
	   REMARK kb%
	   REMARK Configuration Memory Size:     
	   NUMBER $A totsiz
	   REMARK kb%%
	   REMARK %%Fatal error ... machine over configured.. assembly killed!%
	   quit 1
	ei (memcon-totsiz)
     ei
:
	REMARK	%%Requires 
:	NOTE:	BOOTSTRAP REQUIRES 1000X BYTES OF CORE!
:	NOTE:	TSI REQUIRES 64K FOR S-BUS WINDOW (INCLUDES BOOTSTRAP)
	IF	TSI!NANO
	NUMBER	(Q2+65536+1023)/1024
	ELSE
	NUMBER	(Q2+4096+1023)/1024  		:adds 4K for boot
	EI	(TSI!NANO)
	REMARK	d k-bytes of core memory
	REMARK	%%%.............................................%

	RA	$0 0A

	REMARK	%%Code Generated:  
	IF	10-MONTH
	REMARK	0
	EI
	NUMBER	MONTH
	REMARK	/
	IF	10-DAY
	REMARK	0
	EI
	NUMBER	DAY
	REMARK	/
	NUMBER	YEAR
	REMARK	  
	IF	10-HOURS
	REMARK	0
	EI
	NUMBER	HOURS
	REMARK	:
	IF	10-MINS
	REMARK	0
	EI
	NUMBER	MINS
	REMARK	:
	IF	10-SECS
	REMARK	0
	EI
	NUMBER	SECS
	REMARK	 GMT%

	REMARK	%.............................................%

	RA	0

:	.......................................................................
:	THE FOLLOWING MACRO WILL DEFINE AN ENTRY IN THE SYMBOL DEFINITION
:	TABLE.  IT WILL ALSO INCREMENT A COUNTER "NDEF" WITH EACH REFERENCE
:	.......................................................................
					:
SYMDEF  MACRO(SYM) [
Q       HS      0
        AC      /SYM/
        IF      Q+6-.
        RE      Q+6-.
        BC      20
        ER
        ELSE
        ORG     Q+6
        EI

        HC      SYM
NDEF    EQ      NDEF+1
]
					:
:	.......................................................................
:	THE FOLLOWING MACRO WILL MAKE A REFERENCE ENTRY IN THE SYMBOL 
:	DEFINITION TABLE.  IT WILL INCREMENT NREF WITH EACH REFERENCE
:	.......................................................................
					:
SYMREF  MACRO(SYM,BITS,MIN,MAX) [
Q       HS      0
        AC      /SYM/
        IF      Q+6-.
        RE      Q+6-.
        BC      20
        ER
        ELSE
        ORG     Q+6
        EI
        HC      BITS
        HC      MIN
        HC      MAX
NREF    EQ      NREF+1
]
					:
:	.......................................................................
:	NEXT IS A SERIES OF CONSTANTS REPRESENTING LETTERS OF THE ALPHABET.
:	.......................................................................
					:
A.      EQ      0C1     ;B.     EQ      0C2     ;C.     EQ      0C3
D.      EQ      0C4     ;E.     EQ      0C5     ;F.     EQ      0C6
G.      EQ      0C7     ;H.     EQ      0C8     ;I.     EQ      0C9
J.      EQ      0CA     ;K.     EQ      0CB     ;L.     EQ      0CC
M.      EQ      0CD     ;N.     EQ      0CE     ;O.     EQ      0CF
P.      EQ      0D0     ;Q.     EQ      0D1     ;R.     EQ      0D2
S.      EQ      0D3     ;T.     EQ      0D4     ;U.     EQ      0D5
V.      EQ      0D6     ;W.     EQ      0D7     ;X.     EQ      0D8
Y.      EQ      0D9     ;Z.     EQ      0DA     ;Z      EQ      0B0
BL	EQ	0A0	;PT	EQ	0AE
					:
:	.......................................................................
:	THE NEXT MACROES ARE SIMILAR TO THE SYMDEF AND SYMREF MACROES BUT
:	ALLOW SPECIFICATION OF THE LETTERS OF THE SYMBOLS SEPARATELY
:	.......................................................................
					:
SYMDFX  MACRO(S1,S2,S3,S4,S5,S6,VALUE) [
        BC      S1,S2,S3,S4,S5,S6
        HC      VALUE&$00FFFF
NDEF    EQ      NDEF+1
]
					:
SYMRFX  MACRO(S1,S2,S3,S4,S5,S6,BITS,MIN,MAX) [
        BC      S1,S2,S3,S4,S5,S6
        HC      BITS,MIN,MAX
NREF    EQ      NREF+1
]
					:
:	.......................................................................
:	ISIS PARAMETERS TO BE REFERENCED BY EXTERNAL PROCESSES
:	.......................................................................
					:
        SEG     0F
  IF MACV
        ORG     0F00000
  ELSE
        ORG     0F0000
  EI (MACV)
NDEF    EQ      0
        HC      NDEFT           	:COUNT OF ENTRIES
        SYMDEF(NDP)
        SYMDEF(NKU)
        SYMDEF(NSLOT)
        SYMDEF(MACHNM)
   IF	NODENM
        SYMDEF(SILINS)
        SYMDEF(HST0)
   EI  (NODNM)
	SYMDEF(MICRO)
	SYMDEF(BAUDR)
	SYMDEF(ASYNEW)
	SYMDEF(TIINEW)
	SYMDEF(ZITEL)
	SYMDEF(MSCDSK)
ISISVR  EQ      VERSIO
        SYMDEF(ISISVR)
	SYMDEF(MACHIN)
:	.......................................................................
:	THE FOLLOWING PARAMETERS A DEFINED THROUGH SYMBOL GENERATION
:	AND THUS AR A LITTLE MORE DIFFICULT TO CREATE AS STRINGS.
:	.......................................................................
					:
SLT     EQ      0
	RA	0A
        RE      NSLOT
SL0	EQ	SLT/10
SL1	EQ	SLT-SL0*10
   IF	SL0
SL0	EQ	SL0!Z
SL1	EQ	SL1!Z
   ELSE
SL0	EQ	SL1!Z
SL1	EQ	BL
   EI  (SL0)
	SYMDFX(N.,L.,U.,S.,SL0,SL1,NLUS|SLT|)
   IF	SLT-9
	SYMDFX(S.,SL0,SL1,C.,O.,R.,S|SLT|CORE)
   ELSE
	SYMDFX(S.,SL0,C.,O.,R.,E.,S|SLT|CORE)
   EI  (SLT-9)
	SYMDFX(Q.,PT,F.,G.,SL0,SL1,Q.FG|SLT|)
	SYMDFX(Q.,PT,B.,G.,SL0,SL1,Q.BG|SLT|)
SLT	EQ	SLT+1
	ER
SLT	EQ	0
	RE	NSLOT
SL0	EQ	SLT/10
SL1	EQ	SLT-SL0*10
	IF	SL0
SL0	EQ	SL0!Z
SL1	EQ	SL1!Z
	ELSE
SL0	EQ	SL1!Z
SL1	EQ	BL
	EI
LU	EQ	0
	RE	NLUS|SLT|
LU0	EQ	LU/10
LU1	EQ	LU-LU0*10
	IF	LU0
LU0	EQ	LU0!Z
LU1	EQ	LU1!Z
	ELSE
LU0	EQ	LU1!Z
LU1	EQ	BL
	EI
   IF	SLT-9
	SYMDFX(S.,SL0,SL1,L.,LU0,LU1,S|SLT|L|LU|^-16)
	ELSE
	SYMDFX(S.,SL0,L.,LU0,LU1,BL,S|SLT|L|LU|^-16)
   EI  (SLT-9)
LU	EQ	LU+1
	ER
SLT	EQ	SLT+1
	ER
	RA	0
NDEFT	EQ	NDEF
        HC      0               :ISIS MAKES NO REFERENCES
  IF MACV
SFSIZE  EQ      .-0F00000
  ELSE
SFSIZE  EQ      .-0F0000
  EI (MACV)

  IF MACV
SEGF    EQ      0F00000
  ELSE
SEGF    EQ      0F0000
  EI (MACV)
	UN
	END
  T@5