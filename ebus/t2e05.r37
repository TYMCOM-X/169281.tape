
	SUBTTL  SHARE

:			*****     ***** *****
:			  *         *     *
:			  *   ***   *     *
:			  *         *     *
:			  *       ***** *****

:		   	TYMNET II NODE CODE

REVLEV	EQ	$8 0537	:REVISION LEVEL, used to set VERSION
:	>>> Remember to change INITVR if you change REVLEV <<<

CTL.NO	EQ	19	:control#, subordinate to revlev/version
			:00-09... 90-99  so hex reflects dec #'s

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source  code  listing  constitutes  the proprietary   **
: **  property of BTNA.        The recipient, by receiving this   **
: **  program listing, agrees that neither this listing nor the   **
: **  information disclosed herein nor any part thereof shall be  **
: **  reproduced or transferred to other documents or used or dis-**
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by BTNA.       **
: ******************************************************************

:	after a few years the code was accepted.  just a reminder of the
:	history of this code.
:
:  REMARK%%This is special test code.  Unauthorized use is strictly prohibited
:  remark%%and very unwise.  The code is to be used only where authorized by
:  remark%%NTS/STS.                                    sdw    03/02/90%%%


:			 **** *   *   *   ****  *****
:			*     *   *  * *  *   * *
:			 ***  ***** ***** ****  ****
:			    * *   * *   * *  *  *
:			****  *   * *   * *   * *****

::#####################################################################
::
::	MODULE:		SHARE
::
::	FUNCTION:  Define the default value of 'IF' switches and
::		   equates symbols.  Checks configuration and kills
::		   the tymfile macros that are no longer needed.
::
::	SUBTTLS:   None
::		   
::#####################################################################

:	DEFINE KILLIT TO ENABLE ASSEMBLY.  IF KILLIT GETS SET > 0,
:	ASSEMBLY STOPS IMMEDIATELY!

KILLIT	EQ	0
	IF	(1-KILLIT)	:OK to assemble

	RA	0		:INITIALIZE TO HEX RADIX

::*********************************************************************
::
::	 KILL TYMFILE MACROS
::
::*********************************************************************

      if	machnm-$82007	:supervisor has it's own tymend macro which
				:we can't call
	TYMEND		:kills tymfile macros and symbols
      else	:this is a sup
       IF	\TUNL		:see if user put tymend at end of nc tymfile
 REMARK%%%TYMEND macro not at end of Node Code tymfile.  Assembly error
 REMARK%% likely to occur.  Please put TYMEND at end of Node Code tymfile
 REMARK%% and reassemble.%%
	QUIT 1
       EI	:\TUNL
      ei	:machnm-$82007

	kill	TYMEND	:and remove it

	SUBTTL	SHARE (ConFIGuration DEFAULts)

::*********************************************************************
::
::	CFIG:  GENERAL NODE CODE CONFIGURATION DEFAULTS
::
::*********************************************************************

:	CONFIGURATION DEFAULTS ON
	DEFAULT(NCV530,0)	:check to make sure ISIS has patch which
				:puts shared mem in seg C.		###sdw
       IF	\IKNRNG 	:if defined
	IF	1-IKNRNG	:only works with isis v7.00+    	###sdw
	REMARK%%%%
	REMARK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%
	REMARK!!!  FATAL CONFIGURATION ERROR             !!!%
	REMARK!!!  ASSEMBLY HAS BEEN KILLED              !!!%
	REMARK!!!  THIS VERSION OF NODE CODE DOES NOT    !!!%
	REMARK!!!  RUN WITH ISIS VERSIONS PRIOR TO V7.00 !!!%
	REMARK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%%%%%
	KILLER(1)
	EI      :1-IKNRNG
       EI	:\IKNRNG

CKSM    EQ	0		:need to add code for it to work
:	CONFIGURATION DEFAULTS OFF
	CFIG(CKSM,0)		:DON,T SEND software checksum on SIO lines
	cfig(.help.,0)
	CFIG(BLAB,0)
	CFIG(T2GATE,0)		:Gateway not configured normally
	CFIG(SUP,0)		:FOR ISIS GOODGY LIST COMPATABILITY	###OAS
	CFIG(CRHRMK,0)
	CFIG(INTACC,1)		:INTERNAL HOST ACCOUNTING 		##AL
	CFIG(PKTSAV,0)		:SAVE PACKETS ON CRASH 			###LSH
	CFIG(NDREAD,0)		:enable reading of last org ndl in node
	CFIG(SPAM,0)    	:issue SVC sending node CPS to SPAM	###sdw
	CFIG(BFLTMR,0)		:for buffer timer pairs
	CFIG(NETNAM,0)
	CFIG(IDTACH,0)		:ISIS Detach				###wjl
	CFIG(SUPTRC,0)		:SUP RING TRACE DEBUG CODE		###OAS
	CFIG(NETMOD,0)		:NETWORK MODIFIER (TYMFILE SPEC)	###OAS
	CFIG(SUBNET,0)		:SUBNET NUMBER (TYMFILE SPEC)		###OAS
				:THESE PARAMETERS ARE USED IN THE
				:EXPANDED SUPERVISOR TAKEOVER RESPONSE
	CFIG(DIALUP,0)		:and in the Expanded Reset pattern	###wjl
				:AND WILL EVENTUALLY BE A TYMFILE SPEC	###OAS
	CFIG(ACCT2,0)		:Default for current accounting formats 
				:19-apr-85  supports 24bit fields only	###EV
	cfig(MORTIM,0)		:expanded time for rebuild timeouts
	cfig(SR.GMT,0)		:sup backpressure rings SR cmd shows GMT
	cfig(SPLIT,0)		:split sup flag
	DEFAULT(O.FLAG,0)	:DEFAULT TO 0 IF NOT DEFINED
	cfig(SUPWAT,SUPW&O.FLAG)	:sup monitoring commands

SUPER	EQ	MACHNM%400	:SUPER # (IF APPLICABLE)
       IF	(SUPER-7)
SUPER	EQ	0		:NOT A SUP NODE
supwat	eq	0		:can't be enabled
split	eq	0		:not a split sup
       EI	:super-7

	DEFAULT(SQNUMB,200)	:how many chars between sending sqack

     if		\nslot		:if defined (could be a gateway)
      if	\dcslot		:max slot num for dynamic reconfig
       if	dcslot-nslot	:if bigger than highest slot
nslot	eq	dcslot		:then it is new highest slot number
       ei	:dcslot-nslot
      ei	:\dcslot
       if	nslot		:if have slots then probably not a swtchr
	cfig(SWTCHR,0)		:ISIS Switcher (removes SVC DISMISS from BG)
       else	:0 slots	
	cfig(SWTCHR,1)		:ISIS Switcher (removes SVC DISMISS from BG)
       ei	:nslot
     else	:nslot not defined (like for gateway)
	cfig(SWTCHR,0)  	:ISIS Switcher (removes SVC DISMISS from BG)
     ei		:\nslot

	cfig(multln,1)		:1 fully support multi-line link
	cfig(loglim,8)		:8 logon requests out to sup at a time
	cfig(chboot,1)		:see if neighbor is in boot
	cfig(fstdat,1)		:support 8kcps circuits (priority tclass)
	cfig(ncprio,0)	:have nc set priority bit in needles
	cfig(cmpnul,1)		:a sdw specialty #2 compress nulls
:	early retransmission logic to send retransmission when getting back
:	same acks from neighbor of a packet in the old part of the window.
:	value enables logic and determines how old is old.
:	value of 1 is oldest 1/2 of window, 2 is oldest 1/4th,
:	3 is oldest 1/8th and so on.
	default(prertr,0)	:disable sending of early retransmissions

	if	t2gate
	cfig(lodcst,1)		:some gateway host cost stuff
	else
lodcst	eq	0
	ei

::*********************************************************************
::
::	CFIG:  XRAY RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	CFIG(PRIMSG,1)		:PRIORITY CRYPTO MESSAGE BUFFER
				: DEFAULTED FOR XRAY ##AL
	default(numxlt,4)	:number of line tester possibilities	###sdw
	CFIG(XRYMES,0)		:DEFAULT FOR XRAY MESSAGE ENTERED IN TYMFILE
	CFIG(XRYRMK,0)  	:xray cmd PK to display packetsize
	CFIG(NCSLOT,0)  	:for NC nonslot 0 testing
	if	t2gate!super
swtchr	eq	0
	ei	:t2gate!super
       if	swtchr  	:if we are a switcher
	cfig(autrac,1)
ncslot  eq	1		:we do not send messages to dispatcher
numhst  eq	4		:only 1 host (numhst must be mult of 4)
ndp	eq	0		:and no dispatcher ports
       else	:swtchr
	cfig(autrac,0)		:circuit tracing by criteria
       ei

	CFIG(CHNCHK,0)  	:if 1 crash on any error in CHNSIO	###sdw

	if	\nslot  	:if node code
	if	nslot   	:if slots
	cfig(tii.fg,1)  	:if 1 then run syvler in FG, else in BG
	else    :nslot=0
	cfig(tii.fg,0)  	:if 1 then run syvler in FG, else in BG
	ei	:nslot
	else    :\nslot not defined
	cfig(tii.fg,1)  	:if 1 then run syvler in FG, else in BG
	ei	:nslot defined
	if	autrac
	DEFAULT(XRONSZ,300)	:max # of chars to put in output buffer
	else	:standard value
	DEFAULT(XRONSZ,100)	:max # of chars to put in output buffer
	ei
	CFIG(REBTAK,1)  	:resend rebuild requests after takeover

::*********************************************************************
::
::	CFIG: GENERAL HARDWARE RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	cfig(macv,0)		:default to not mac v cpu iv memory layout
	DEFAULT(MACHIN,1)	:ISIS Tymfile parameter - 1=Engine,	###wjl
	CFIG(HMICRO,0)		:	2=HDLC Micro, 3=TSI or PICO
	CFIG(TSI,0)		:					###wjl
:	INSERT FUTURE SWITCHES AT THE TOP OF THE LIST BELOW		###wjl
	IF	MACHIN-2
TSI	EQ	1
	ELSE	MACHIN-1
HMICRO	EQ	1
	ELSE	:MACHIN
:	DEFAULT
	EI	:MACHIN

      IF	macv
PAGESZ	EQ	400			:###wjl
       if	t2gate
	default(dmaavl,0)		:default is 0 for gateway
       else	:not t2gate
	default(dmaavl,$a64*1024)	:default is 64K if macv
       ei	:t2gate
      ELSE	TSI			:###wjl
dmaavl	eq	0			:no dma region
PAGESZ  EQ	400
      ELSE	:Engine			:###wjl
dmaavl	eq	0			:no dma region
PAGESZ  EQ	100
      EI	:macv



::*********************************************************************
::
::	CFIG:  MXP RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	DEFAULT(NMACH,1)	:NUMBER OF MACHINES FOR ISIS-MXP SUPPORT
	CFIG(MXPNM,0)		:FOR ISIS-MXP SUPPORT
	IF	MXPNM		:###wjl
	DEFAULT(NUMHST,$A 128)	:TYMFILE spec for NHOSTS
	ELSE	:not MXPNM
	DEFAULT(NUMHST,$A 64)
	EI	:MXPNM

::*********************************************************************
::
::	CFIG:  GATEWAY RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

       IF	INTACC  	:internal host accounting
ACCT    EQ	1		:include the 'normal' accouting routines
       EI	:INTACC

	CFIG(IRC,0)		:INTERNATNAL RCD CARRIER FOR GATEWAY##AL
	CFIG(ACCT,0)		:GATEWAY ACCOUNTING 			##AL

	IF	T2GATE
	DEFAULT(INCOST,0)
	DEFAULT(HNCOST,0)
acct	eq	1		:gateways must do accounting
SWTCHR	EQ	0		:Not a switcher
IDTACH	EQ	1		:Gateway will use Isis detatch logic
NUSLT	EQ	0
NUMHST  EQ	4		:must be a multiple of four  ###sdw
	default(npthr,80)	:gateway defaults to fewer passthroughs
LOGII   EQ	0		:no LOG II yet
	EI	:T2GATE	

::*********************************************************************
::
::	CFIG:  TYMSTAR RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	DEFAULT(TH.ACK,2)	:NULL REC ACK THRESHOLD			###sdw
	DEFAULT(MINWSZ,4)	:smallest allowed windowsize    	###sdw
	CFIG(NGRDTM,0)		:THRESHOLD FOR NO GOOD DATA REPORT	###AL

::*********************************************************************
::
::	CFIG:  LOGII RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

       IF	\LOG.II 	:what ISIS decided to use
LOGII   EQ	LOG.II
       EI
LG2OFF EQ	NETID&$00DF	:see if netid is southwest bell
       IF	LG2OFF
	CFIG(LOGII,0)		:Exclude LOG II code 
       ELSE			:LG2OFF
	CFIG(LOGII,1)		:Include LOG II code for Southwest Bell only
       EI			:LG2OFF
       IF	LOGII
IDTACH  EQ	1
       EI
	DEFAULT(X4NENT,40)	:max number of elements in an X.409 message


::*********************************************************************
::
::	CFIG:  SKYWALKER RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	CFIG(NAD68,0)		:NAD to 68020 assembler			###wjl

::*****************************************************************
::
::	EXEC OPTOMIZATION
::
::*****************************************************************

:	define maximum number of ticks for each of the major processes.
:	This lets that process run for that long before checking EXEC to
:	yield (EXYLD).  This is to prevent important processes from
:	checking exec after doing virtually nothing.  Thus, RTEAR will
:	not check exec after servicing each link, same for rest.	###sdw

:	give ticks to each of the major data movers
	DEFAULT(TICDSI,07)		:DISIN (data out of NC)
	DEFAULT(TICDSO,07)		:DISOUT (empty ISIS ring to NC) 
					:extra large to prevent dispatcher
					:from buffering
	DEFAULT(TICRTD,04)		:RTEAR
	DEFAULT(TICRMK,04)		:RMAKE 
	DEFAULT(TICXRY,09)		:prevent xray cmds from hogging cpu
	DEFAULT(SIOTHR,$a 100)  	:more than 100 ticks between servicing
					:an sio line means stop RTd calls from
					:sio input and instead copy that data
					:Prevents possibility of sio ring wrap


::*********************************************************************
::
::	DEFAULT:	PHSIZE:
::	FUNCTION:
::	The PHSIZE symbol may be defined in the TYMFILE if the default
::	listed below is not sufficient for all the patches.
::	PHSIZE defines the length in bytes of the PATHIS area.
::		default: 140 hex
::
::*********************************************************************

	DEFAULT(PHSIZE,200)
PHSIZE	EQ	(PHSIZE+0F)/10*10

: remark %%dbgqut set to 1 for convenience of dev.  delete these two lines before releasing code%
:dbgqut	eq	1
	default(dbgqut,0)	:if enabled then don't call quit directive

	DEFAULT(BAUDR,0)	:Async rate: 0=1200, 1=not used, 2=4800 BPS

:	SET UP DEBUGGING AND TEST OPTIONS. THE OPTIONS MAY BE SPECIFIED
:	BY EXPLICIT DEFINITION OF FLAGS TO BE SET, BY USE OF THE OPTION MACRO,
:	OR BY SETTING THE SYMBOL O.FLAG WITH THE PROPER BIT ARRAY VALUE.

	CFIG(DB.TRC,O.FLAG&UTRC)	:DB.TRC ENABLES UPSW JUMP TRACE OPTION
	CFIG(DB.CIR,O.FLAG&CIRD)	:DB.CIR ENABLES XRAY DISPLAY OF
					: CIRCUITS BUILT AND ZAPPED.

	IF	O.FLAG&NTLV	:NTLV DISABLES TLEV TRACING		###OAS 
DB.TSN	EQ	0
	ELSE	:Q
DB.TSN	EQ	TLEV		:DB.TSN ENABLES SYNC LINE DIAGNOSTIC TRACE
	EI	:Q

:	DB.SD1 is a switch that enables calls to D.SDW on R8 from many
:	places in SPIDER.  It is to be used to trap various corruptions.
	CFIG(DB.SD1,0)		: default off
	CFIG(DB.CHN,0)		: crash on what might be chn error
	CFIG(DB.SNP,0)		: crash on link snip
:	CFIG(DB.DEB,O.FLAG&DBUG)	:GENERAL NODE CODE DEBUGGING OPTION
DB.DEB	EQ	0		:code is not stable with it enabled
	CFIG(REBILD,(O.FLAG&REBLD)/REBLD)	:REBUILD LOST CIRCUITS

	if	1-rebild
rebtak  eq	0		:if no rebuild then no fancy recovery logic
	ei

	GLOBAL(NSYMBL,0)	:init count of symbols for XRAY symbol table
	GLOBAL(ADRESZ,0A)	:size of symbol table entry

::*********************************************************************
::
::	DEFINE DEFAULT VALUES FOR CONFIGURATION PARAMETERS
::
::*********************************************************************


	DEFAULT(PTHRU,0)	:DEFAULT TO PASSTHROUGHS ENABLED
	DEFAULT(NPTHR,100)	:DEFAULT TO $A 256 PASSTHROUGHS
	DEFAULT(NDP,100)	:DEFAULT TO $A 256 DISPATCHER PORTS
	DEFAULT(NSP,180)	:DEFAULT TO $A 384 SUP PORTS FOR SUP NODE

	if	1-swtchr
	if	2-ndp
	remark%%ERROR!!  If node code is not a SWITCHER then it requires at
	remark%%         least two (2) Dispatcher ports.  The parameter NDP
	remark%%         sets the number of Dispatcher ports.
	ei	
	ei

:	NETID MUST BE SPECIFIED IN TYMFILE
	IF	\NETID
	ELSE	:NETID NOT DEFINED
	REMARK	%
	REMARK	%****************************************
	REMARK	%!! NETID MUST BE SPECIFIED IN TYMFILE !!
	REMARK	%****************************************
	REMARK	%
	KILLER(1)		:KILL ASSEMBLY!!
	EI	:\NETID

	if	1-netid 	:0 is not a valid netid
	Remark%%%       ERROR!!!!   NETID of 0 is not valid.%%%
	killer(1)
	ei

XGGER1	ERRCNT

	if	xggcnt		:Security violation!!	###sln
	REMARK	%****************************************
	REMARK  % Entries to good-guy list must be contained in XGG macro.
	REMARK  % This rule has been violated.
	REMARK	%****************************************
	KILLER(1)		:KILL ASSEMBLY!!
	ei	:xggcnt

	XGG			:define good-guys from XGG macro

XGGER2	ERRCNT
	IF	XGGER2-XGGER1
	REMARK	%
	REMARK	%****************************************
	REMARK	%!!!! XGG MACRO ERROR !!!!!!!!!!!!!!!!!!!
	REMARK	%!!!! GOODGUY LIST MUST BE PROVIDED !!!!!
	REMARK	%****************************************
	REMARK	%
	EI	:XGGER2-XGGER1

	IF	XGGCNT
	ELSE	:XGGCNT
	REMARK	%
	REMARK	%*****************************************
	REMARK	%!!!!! NO XRAY GOODGUY LIST PROVIDED !!!!!
	REMARK	%*****************************************
	REMARK	%
	EI	:XGGCNT

	IF	\MICRO
	IF	(2-MICRO)		:MICRO 0 OR 1
	REMARK	%>>> MICRO = 0, AND MICRO = 1 NOT SUPPORTED!!!!!! <<<
	REMARK	%>>> CHANGE TYM-FILE IF YOUR MACHINE CAN RUN SYNC <<<
	REMARK	%>>> E N H A N C E D !!!!!!!!!!!!!!!!!!!!!!!!!!!! <<<%
	KILLER(1)		:kill assembly
	EI	(2-MICRO)
	ELSE	:NOT \MICRO
MICRO	EQ	2		:DEFAULT, AND ONLY ACCEPTABLE VALUE
	EI	(\MICRO)

: COMPUTE NUMBER OF SYNC (NLINES') AND SIO (SILINS) FROM TYMFILE INFO
: THEN RECOMPUTE TOTAL LINES (NLINES = NLINES + SILINS)

	IF	T2GATE		:For T2 Gateway use sync logical units
	default(t2sylu,0)	:no sync unless specified
NLINES	EQ	T2SYLU		:###EV
	DEFAULT(SILINS,0)	:no SILINS unless given in gateway tymfile
	ELSE
:	MACRO TO SAVE THE REPEAT LOOP FROM 640 CHAR OVERFLOW
QQQ MACRO[REMARK%*****************************************************************]
Q	EQ	0
QSIO    EQ	0
NLINES  EQ	0
	RE	NLUS0   	:max number of lines    		###sdw
	IF	\S0L|$A Q|	:logical unit defined?
NLINES  EQ	NLINES+1
	 IF	S0L|$A Q|-1000  :sync 0-fff   SIO 10000 and up
QSIO    EQ	QSIO+1  	:another SIO
	 ELSE QSIO		:must be a sync ref after a SIO ref
	REMARK%%%;    QQQ
    REMARK %!!       C O N F I G U R A T I O N    E R R O R                !!
    REMARK %!!   All sync references must precede the first SIO reference  !!%
	QQQ; REMARK%%%
	KILLER(1)
	 EI	:S0L|Q|-1000
	EI	:\S0L|Q|
Q	EQ	Q+1
	ER	:20
SILINS  EQ	QSIO    	:what I count to be the SIO lines	###sdw
NLINES  EQ	NLINES-SILINS   :number of sync lines, temporarily
	KILL    QQQ	:KILL THAT GOOFY MACRO
	EI	:T2GATE
:	(SEE RE-DEFINITION OF NLINES BELOW TO REFLECT TOTAL NETWORK PORTS)



:	SYNLNA:	FW WITH 1-BIT FOR EACH SYNC LINE GEN'D

Q	EQ	0
SYNLNA	EQ	0
	IF	NLINES
	RE	NLINES
SYNLNA	EQ	SYNLNA+(80000000^Q)
Q	EQ	Q-1
	ER	:NLINES
	EI	:NLINES
sylins	eq	nlines		:number of sync lines if any
NLINES	EQ	NLINES+SILINS	:NLINES = TOTAL NUMBER OF NETWORK PORTS

LNSIZE	EQ	(((S-1)/20)+1)*4  :SIZE OF ARRAY IN BYTES
NLINEW	EQ	$A (NLINES+31)/32	: Number of words of bits to reserve

SBASE	EQ	2*(NLINES-SILINS)	:2*FIRST SIO LINE, RELATIVE

	DEFAULT(XLINKS,0)	:DEFAULT TO 0 XLINKS
	CFIG(INFLGT,0)		:DEFAULT TO INFINITE LOGON TIMER NOT ENABLED
	DEFAULT(NXUBLK,3)	:DEFAULT TO 4 CONCURRENT REMOTE XRAY USERS
	DEFAULT(MEMRMK,0)	:NO SPECIAL MEMORY REMARKS

NXUBLK	EQ	NXUBLK+1	:ADD 1 FOR TTY ACCESS
	IF	(2-NXUBLK)	:NO REMOTE XRAY ACCESS.
	REMARK	%***NO REMOTE XRAY PORTS DEFINED (NXUBLK < 1)***%
	EI	(2-NXUBLK)
	IF	(NXUBLK-0F)	:NO MORE THAN 15d XRAY USERS TOTAL
	REMARK	%***NXUBLK TOO LARGE, HAS BEEN RESET TO MAX VALUE (14d)***%
NXUBLK	EQ	0F
	EI	(NXUBLK-0F)

:	INSURE COMPATIBLE INITIALIZATION FILE USED...
Q	EQ	0	:Q WILL GET SET IF OLD INITIALIZATION FILE
 IF	(1-\INITVR)
Q	EQ	1
 ELSE		:INITVR DEFINED. TEST FOR PROPER VERSION
  IF	($8INITVR%37)
Q	EQ	1
  EI	($8 INITVR%37)
 EI	(1-\INITVR)
	IF	Q
	REMARK %* Must use T2E05.I37 initialization file! *%
	KILLER(1)		:kill assembly 
	EI	:Q

	CFIG(RESHST,0)		:NO RESTRICTED HOSTS

:	THE CODFLT (CRASH OPTION DEFAULT) MACRO SETS THE SYMBOL
:	C.xxxx TO 1 IF THE OPTION IS TRUE, ELSE SETS IT TO 0. THE xxxx
:	MNEMONIC VALUE IS BASED ON THE COMMON CRASH ACTION DEFINITIONS.


	CODFLT(NRSH)
	CODFLT(NRSS)
	CODFLT(NHTH)
	CODFLT(NHTS)
	CODFLT(NBTH)
	CODFLT(NBTS)
	CODFLT(NSTH)
	CODFLT(NSTS)

:	IF NO HARDWARE OPTION DEFINED, DEFAULT TO NRSH
	IF	(1-(C.NHTH+C.NBTH+C.NSTH))
C.NRSH	EQ	1		:RESTART ON HARDWARE CRASH
	EI	(1-(C.NHTH+C.NBTH+C.NSTH))

:	IF NO SOFTWARE OPTION DEFINED, DEFAULT TO NRSS
	IF	(1-(C.NHTS+C.NBTS+C.NSTS))
C.NRSS	EQ	1		:RESTART ON SOFTWARE CRASH
	EI	(1-(C.NHTS+C.NBTS+C.NSTS))

	IF	((C.NRSH+C.NHTH+C.NBTH+C.NSTH)-1)
	REMARK %ERROR - MULTIPLE HARDWARE CRASH OPTIONS DEFINED!%
	KILLER(1)		:kill assembly
	EI	((C.NRSH+C.NHTH+C.NBTH+C.NSTH)-1)

	IF	((C.NRSS+C.NHTS+C.NBTS+C.NSTS)-1)
	REMARK %ERROR - MULTIPLE SOFTWARE CRASH OPTIONS DEFINED!%
	KILLER(1)		:kill assembly
	EI	((C.NRSS+C.NHTS+C.NBTS+C.NSTS)-1)

:	SET UP CRASH HANDLING OPTION.  VALUE OF CRSTOP DETERMINES THE ACTION
:	TAKEN ON HARDWARE (MAC, ILLEGAL INST) AND SOFTWARE ( JAL R0,OOPS)
:	CRASHES. THE UPPER BYTE OF CRSTOP IS FOR HARDWARE, THE LOWER FOR
:	SOFTWARE. THE CODES ARE:
:		0	=>	RESTART
:		1	=>	STOP NODE CODE, LEAVE XRAY ON
:		2	=>	DISABLE WATCHDOG TIMER AND DO BOOT SVC
:		3	=>	HALT MACHINE, TURN WAIT BAR ON

HLTNOD	EQ	3
DOBOOT	EQ	2
STOPLK	EQ	1
RSTRT	EQ	0

	DEFAULT(CRSTOP,0000)	:DEFAULT TO RESTART IN ALL CASES


	IF	(C.NHTH)
CRSTOP	EQ	(CRSTOP&0FF)+0300
	EI	(C.NHTH - HALT ON HARDWARE CRASH)

	IF	(C.NBTH)
CRSTOP	EQ	(CRSTOP&0FF)+0200
	EI	(C.NBTH - BOOT ON HARDWARE CRASH)

	IF	(C.NSTH)
CRSTOP	EQ	(CRSTOP&0FF)+0100
	EI	(C.NSTH - STOP ON HARDWARE CRASH)

	IF	(C.NHTS)
CRSTOP	EQ	(CRSTOP&0FF00)+03
	EI	(C.NHTS - HALT ON SOFTWARE CRASH)

	IF	(C.NBTS)
CRSTOP	EQ	(CRSTOP&0FF00)+02
	EI	(C.NBTS - BOOT ON SOFTWARE CRASH)

	IF	(C.NSTS)
CRSTOP	EQ	(CRSTOP&0FF00)+01
	EI	(C.NSTS - STOP ON SOFTWARE CRASH)

	DEFAULT(RPTHCE,2)	:REPORTING THRESHOLD FOR CIRCUIT ERRORS

	IF	\NBFLET
	KILL	NBFLET		:PREVENT OLD TYM FILE OPTION FROM LIVING
	EI	(\NBFLET)

::	Define the links of each type declared.				###ev
:	FIRST ALL TIILNKS
	IF 	TIICNT
X	EQ	0
	RE	TIICNT
	.TII|X|
	kill	.TII|X|
X	EQ	X+1
	ER
	EI	:TIICNT

:	COMPUTE MAXIMUM NUMBER OF LINKS
NLINKS	EQ	XLINKS		:START WITH NUMBER OF WILD CARD LINKS
Q	EQ	0
:	FOR EACH LINK DESCRIPTOR DEFINED, INCREMENT NUMBER OF LINKS
	RE	MAXLNK
	IF	\NEI|$AQ|
NLINKS	EQ	NLINKS+1
	ELSE
NLINKS	EQ	NLINKS
	EI	:(\NEI|$AQ|)
Q	EQ	Q+1
	ER


NLINKW	EQ	$A (NLINKS+31)/32	: Number of words needed for bits

LKSIZE	EQ	(((NLINKS-1)/20)+1)*4	:SIZE OF ARRAY IN BYTES

::	DETERMINE MEMORY AVAILABLE

	IF	T2GATE		:Not used for gateway
MEMAVL  EQ	MEMORY*400		:Gateway declares memory in Tymfile
       ELSE  :NOT T2GATE
MEMAVL	EQ	S0CORE*400
       EI	:T2GATE

	if	memavl&(pagesz-1)	:node assigned partial page
memavl	eq	memavl&(-pagesz)	:round away the unusable fragments
	remark%%Node code assigned memory it cannot use.  This hardware
	remark%%platform uses memory in ; number $a pagesz/1024 ; remark%K blocks.
	remark%%Please allocate memory in that size increments to not waste memory.
	ei

:	DEFINE THE NUMBER OF CONSECUTIVE OCCURRENCES OF FOUR SECONDS
:	WITH NO RECORDS RECEIVED IN A LINE, WHICH IS ALLOWED BEFORE
:	DETACH IS TAKEN.	###LH

	DEFAULT(LNCKTM,4)	:DEFAULT TO 4 IF NOT DEFINED IN TYMFILE

     IF		SUPER
      IF	\HST0
Q	EQ	$A 120+SUPER
       IF	(Q%HST0)	:BITCH IF HST0 INCORRECT FOR SUP NODE...
	REMARK %** SUP HOST NUMBER SPECIFIED INCORRECTLY - 
	REMARK SETTING TO $A 
	NUMBER $A Q
	REMARK  **%
       EI	(Q%HST0)
      EI	(\HST0)

HST0	EQ	$A 120+SUPER	:SET HOST NUMBER FOR SUPERVISOR

	DEFAULT(SUPNKU,$A 24)		: 24d SUP kernel users if supervisor
	LO.LIM(SUPNKU,1)		: Range check. 1d-46d		#gunnar
	HI.LIM(SUPNKU,2E)
	CFIG(KSVC62,1)		:Issue connext KIO SVC 62 which has forced
				: port mapping
	if	split
	default(srmblu,0)		:SIO Ring Copy LU for nc's use
	default(srmadr,90)		:default mboard address
	if	1-nslot			:if split and no slots
ndp	eq	0			:then no dispatcher ports
ncslot	eq	1			:and no dispatcher logic
numhst	eq	4			:don't need lots of host table space
	ei	:1-nslot
	ei	:split
       ELSE	:NOT SUPER
	CFIG(KSVC62,0)		: Do not issue connext KIO SVC 62
	DEFAULT(HST0,MACHNM-$82000+$A520)
       EI	:SUPER

	IF	T2GATE		:Gateway uses a specified or default
	IF	\HHOST		:for Network host number
HST0	EQ	HHOST	:If specified, it can be either as HHOST
	ELSE	: (use HST0, either specified or default)  <<<--- OR
HHOST	EQ	HST0	:as HST0.
	EI	:\HHOST
	EI	:T2GATE

NSP	EQ	NSP*SUPER/SUPER		:NO LIMITS TO NSP		###GT
	IF	(NSP&1F)
	REMARK	%>>WARNING - NSP not a multiple of 32d!!<<%
	EI	:(NSP&1F)
	IF	MXPNM		:ISIS-MXP SUPPORT
NUSLT	EQ	NMACH*$A16	:# SLOTS = # MACHINES * 16		###GT
	ELSE			:DEFINE A NEW SYMBOL FOR # SLOTS	###GT
	IF	1-T2GATE		:###EV
NUSLT	EQ	NSLOT		:OLD ISIS
	EI	:1-T2GATE		:###EV
	EI	:MXPNM

	IF	(1-SUPER)
SUPNKU	EQ	0	:0 SUP KERNEL USERS IF NO SUPERVISOR
	EI	(1-SUPER)
	IF	T2GATE		:###EV
NKU	EQ	0		:T2 Gateway has no kernel ports
NSLOT	EQ	0		:Nor does Gateway have slots!
	ELSE
NKU	EQ	2+NSLOT+SUPNKU	:# OF KERNEL USERS
	EI	:T2GATE		:###EV

	SUBTTL	SHARE (Parameter DEFAULTs)

::*********************************************************************
::
::	PARAMETER DEFAULTS:
::
::*********************************************************************

	cfig(aplybp,0)		:apply backpressure logic
	cfig(S.CKSM,0)		:software checksums on some SIO lines
	DEFAULT(PRIMSG,0)	:PRIORITY CRYPTO MSG.
	DEFAULT(AUDSIZ,400)	:audit log size (128 entries)
audsiz	eq	((audsiz+7)/8)*8
	default(pl.num,$a24)	:performance log entries
	default(pl.all,swtchr)	:only want all entries if switcher
       if	pl.all
pl.num	eq	pl.num*7	:7 lines per entry
       else	:small version
pl.num	eq	pl.num*3	:3 lines per entry
       ei	pl.all

	default(pl.frq,$a60)
       if	pl.frq-$a60	:interval more than an hour
pl.frq	eq	((pl.FRQ+$a59)/60)*60 :force to a multiple of an hour
       else	:less than an hour
	if (($a60+pl.frq-1)/pl.frq)-($a60/pl.frq) :it does not cleanly divide60
remark %%WARNING - PL.FRQ does not divide cleanly into one hour.  Reseting to 60d.
pl.frq	eq	$a 60
       ei	:clean division
      ei	:pl.frq
	IF	T2GATE
	IF	PRIMSG
	DEFAULT(CRYPPS,100)
	EI	:PRIMSG
	DEFAULT(CRYPRS,400)	:Gateway will always default to smaller buffers
	DEFAULT(TRRSIZ,200)
	DEFAULT(TRTBSZ,80)
	DEFAULT(HISTSZ,40)
	ELSE			:not gateway
	IF	PRIMSG
	DEFAULT(CRYPPS,400)	:SIZE OF PRIORITY MSG BUFFER (MUST BE PWR 2)
	EI	:PRIMSG
	if	swtchr  	:lots of lines fill up the crypto log
	DEFAULT(CRYPRS,4000)	:SIZE OF CRYPTOGRAM BUFFER (MUST BE PWR 2)
       else	:swtchr 	:not switcher so memory might matter
	DEFAULT(CRYPRS,1000)	:SIZE OF CRYPTOGRAM BUFFER (MUST BE PWR 2)
       ei	:swtchr
       if	autrac
	if	swtchr
	DEFAULT(TRRSIZ,8000)	:CHARACTER TRACE RING SIZE
	else
	DEFAULT(TRRSIZ,800)	:CHARACTER TRACE RING SIZE
	ei	:autrac
       else
	DEFAULT(TRRSIZ,400)	:CHARACTER TRACE RING SIZE
       ei	:autrac
	DEFAULT(TRTBSZ,100)	:UPSW TRACE CAN STORE $A 64 ENTRIES
	DEFAULT(HISTSZ,80)
	EI	:T2GATE
       IF	T2GATE  	:ring must be bigger when node code	###sdw
	DEFAULT(DRSZ,400)
       ELSE	:node code
	DEFAULT(DRSZ,800)	:!!!NOTE: MUST BE POWER OF 2!!!
       EI	:T2GATE
       if	ncslot  	:switcher's have no need for dispatcher rings
DRSZ    EQ	100		:minimum size
       ei	:ncslot
	SYAD(DRSZ  )

	default(kbsz,40)	:default KIO ring size
	lo.lim(KBSZ,20)		:smallest usable size
	hi.lim(KBSZ,1FFE)	:biggest usable size

      if	super
	default(SUPBSZ,800)		:SIZE OF SUP BUFFERS
	default(SIBPSZ,NSP*4+2)		:size of backpressure rings
	default(SOBPSZ,NSP*4+2)
	default(SOCSZ,10)		:control ring
	default(SICSZ,10)		:control ring
       if	sobpsz-1ffe		:bp rings have max size
sibpsz	eq	1ffe
sobpsz	eq	1ffe
       ei	:size too big
      ei	:super

	if	silins
:	The following are SIO-unique parameters
SIOPSZ	EQ	$A 128			: SIO packet size
SIOFSZ	EQ	SIOPSZ+2		: SIO Frame size (allow for size HW)
SOBFSZ	EQ	(SIOFSZ+0E)&0FFFF0	: SIO Output Buffer Size
SIBFSZ	EQ	(8*SIOFSZ)		: default SIO Input Buffer size

:	define symbol for all lines that indicates speed of the line (defined
:	via LU(SIO,mb,prt,spd)
q	eq	(nlines-silins)
      re	silins
       if	1-\.lks|$a q|
.lks|$a q|	eq	0		:define symbol
       ei	:\.lks|q|
       if	.eq.($a256,.lks|$a q|)
ncha|$a q|	eq	4		:256kb line gets extra big ccw chain
.lkz|$a q|	eq	SIBFSZ*4	:input area extra large for 256kb
       else	:not a 256kb
ncha|$a q|	eq	2		:default len of sio output ccws
.lkz|$a q|	eq	SIBFSZ		:INPUT BUFFER size
       ei	:check for 256
q	eq	q+1
      er	:silins
	ei	:silins	

	KILL    .SPED.  	:kill macros used only in Share 	##sdw

	EI	(1-KILLIT)

	KILMSG(SHARE)

:	***NOTHING PAST THIS POINT***



	
	SUBTTL	DATA

:			****    *   *****   *
:			*   *  * *    *    * *
:			*   * *****   *   *****
:			*   * *   *   *   *   *
:			****  *   *   *   *   *

::#####################################################################
::
::	MODULE:		DATA
::
::	FUNCTION:	Define Data Storage areas, equates and constants,
::		tables structures, parameter defaults, crash codes,
::		crypto messages, etc.
::
::	SUBTTLS:
::		Define register, segment, SVC naming conventions
::		Define ASCII equates
::		Define codes for node Faults, Node Reports
::		Crash Codes
::		Parameter Defaults
::		Equates and Constants
::		Crypto Messages
::		Table Structure Variables
::		Low Core SEG 0 Variables
::		Segment 0 -  Data Areas
::		Segments 2 & 3 - Buffer Descriptors
::		Segment 4 - Kernel Communications
::		Segment 5 - Supervisor Communications
::		Segment 6,7,8,9 - IOTAB and Bufferlets
::		Segment B - SYNC Input 
::		Segment C - Table Storage
::		Segment E - Control Table Area (CTA)
::		Segment F - ISIS Data Area (IDA)
::
::#####################################################################

	IF 1-KILLIT
	BEGMO.

:	Define General Registers

	GLOBAL(R0,0)			: register 0
	GLOBAL(R1,1)			: register 1
	GLOBAL(R2,2)			: register 2
	GLOBAL(R3,3)			: register 3
	GLOBAL(R4,4)			: register 4
	GLOBAL(R5,5)			: register 5
	GLOBAL(R6,6)			: register 6
	GLOBAL(R7,7)			: register 7
	GLOBAL(R8,8)			: register 8
	GLOBAL(R9,9)			: register 9
	GLOBAL(R10,0A)			: register 10
	GLOBAL(R11,0B)			: register 11
	GLOBAL(R12,0C)			: register 12
	GLOBAL(R13,0D)			: register 13
	GLOBAL(R14,0E)			: register 14
	GLOBAL(R15,0F)			: register 15

:	Special Register Definitions

CD	EQ	R13		:pointer to reCord Descriptor
KD	EQ	R15		:pointer to linK Descriptor
KN	EQ	R11		:linK Number 
KX	EQ	KN		:pointer to linK descriptor (Xray)
LN	EQ	R14		:Line Number
PRD	EQ	R12		:Pointer to Record Data
R2BE	EQ	R2		:EVEN BUFFER INDEX
R2BO	EQ	R2		:ODD BUFFER INDEX

SD	EQ	PRD		:pointer to reSet Data buffer
XD	EQ	R15		:pointer to Xray user block Descriptor
XN	EQ	XD		:Xray user slot Number

TC	EQ	R15		:FOR TRUNCATING RING POINTERS (POWER OF 2 MASK)
LRC	EQ	R14		:LOGICAL RECORD BYTE COUNT
PRC	EQ	R10		:PHYSICAL DITTO
CHN	EQ	R5		:CHANNEL #

TYC	EQ	R11		:HOLDS MAGIC CONSTANT (03 OR 07)
HN	EQ	CD		:HOST #
KP	EQ	R7		:KERNEL PORT BUFFER OFFSET

:	DEFINE VIRTUAL SEGMENTS
       if	swtchr		:if switcher then seg 1 won't be that big
A.CODE	eq	0c		:able to use segs 0-b for data (max that out)
       else	super
A.CODE	eq	0a		:may need two segs for code and seg C is for sup
       else
A.CODE	eq	0b		:use seg b and c for code and segs 0-A for data
       ei

A.XRAY	eq	0d		:use seg D for xray stuff
A.SUP	EQ	0c
	seg	1		:determine segment size
segsiz	hs	0
	seg	a.code
seg|a.code|	hs 0		:for MEMRMK memory usage display
seg1	hs	0		:the label for start of code segment
	seg	a.xray
segd	hs	0
	seg	0e
sege	hs	0
	seg	0f
segf	hs	0

     if	macv
	if	0f0000-segsiz	:if mac 5 and segment incorrectly defined
       if	t2gate
 remark%%ERROR!  MACV switch indicates MAC 5 hardware and assembly is not
 remark %using nad -v.  Assembly terminated. %%
       else	:not t2gate
 remark%%ERROR!  HARDWARE macro indicates MAC 5 hardware and assembly is not
 remark %using nad -v.  Assembly terminated. %%
       ei	:not t2gate
	quit	1
	ei	:segment incorrectly defined
     else	segsiz-0f0000	:not mac 5 and segment incorrectly defined
       if	t2gate
 remark%%ERROR!  MACV switch does not indicate MAC 5 hardware and assembly is
 remark %using nad -v.  Assembly terminated. %%
       else	:not t2gate
 remark%%ERROR!  HARDWARE macro does not indicate MAC 5 hardware and assembly is
 remark %using nad -v.  Assembly terminated. %%
       ei	:not t2gate
	quit	1
     ei		:mac 5 and segment properly defined


:	DEFINE SYMBOLS TO IDENTIFY ISIS SVC'S
DISMIS	EQ	0		:dismiss
FAST	EQ	1		:fast dismiss
SYS	EQ	2		:system
IO	EQ	3		:I/O control
KIO	EQ	0D		:KIO control

ISIS	EQ	0

	SUBTTL DATA (ASCII EQuates)

::*********************************************************************
::
::	ASCII equates for character comparison ###JHL
::
::*********************************************************************

ASC7BT	EQ	7F	:SEVEN BITS OF CHARACTER
ASCLF	EQ	0A	:ASCII LINE FEED
ASCCR	EQ	0D	:ASCII CARRIAGE RETRUN
ASCESC	EQ	1B	:ASCII ESCAPE CHAR
ASCSPC	EQ	20	:ASCII SPACE
ASCEXP	EQ	21	:ASCII EXCLAMATION POINT
ASCAST	EQ	2A	:ASCII *
ASCPLS	EQ	2B	:ASCII +	
ASCCOM	EQ	2C	:ASCII COMMA
ASCDSH	EQ	2D	:ASCII DASH (HYPHEN)
ASCDOT	EQ	2E	:ASCII PERIOD
ASCFSL	EQ	2F	:ASCII FORESLASH
ASCZRO	EQ	30	:ASCII ZERO
ASCONE	EQ	31	:ASCII ONE
ASCTWO	EQ	32	:ASCII TWO
ASCTHR	EQ	33	:ASCII THREE
ASCFOU	EQ	34	:ASCII FOUR
ASCFIV	EQ	35	:ASCII FIVE
ASCSIX	EQ	36	:ASCII SIX
ASCSEV	EQ	37	:ASCII SEVEN
ASCEIG	EQ	38	:ASCII EIGHT
ASCNIN	EQ	39	:ASCII NINE
ASCCOL	EQ	3A	:ASCII COLON
ASCSMC	EQ	3B	:ASCII SEMICOLON
ASCQST	EQ	3F	:ASCII ?
ASCAT	EQ	40	:ASCII @
ASCA	EQ	41	:ASCII A
ASCB	EQ	42	:ASCII B
ASCC	EQ	43	:ASCII C
ASCD	EQ	44	:ASCII D
ASCE	EQ	45	:ASCII E
ASCF	EQ	46	:ASCII F
ASCG	EQ	47	:ASCII G
ASCH	EQ	48	:ASCII H
ASCI	EQ	49	:ASCII I
ASCJ	EQ	4A	:ASCII J
ASCK	EQ	4B	:ASCII K
ASCL	EQ	4C	:ASCII L
ASCM	EQ	4D	:ASCII M
ASCN	EQ	4E	:ASCII N
ASCO	EQ	4F	:ASCII O
ASCP	EQ	50	:ASCII P
ASCQ	EQ	51	:ASCII Q
ASCR	EQ	52	:ASCII R
ASCS	EQ	53	:ASCII S
ASCT	EQ	54	:ASCII T
ASCU	EQ	55	:ASCII U
ASCV	EQ	56	:ASCII V
ASCW	EQ	57	:ASCII W
ASCX	EQ	58	:ASCII X
ASCY	EQ	59	:ASCII Y
ASCZ	EQ	5A	:ASCII Z
ASCBSL	EQ	5C	:ASCII BACKSLASH
ASCAP	EQ	5F	:and-mask to force upper case 
ASCUC	EQ	0DF	:and-mask with HOB set


	SUBTTL	DATA (Define node Faults, Node Reports)


::*********************************************************************
::
::	NR.###:	DEFINE VALUES TO IDENTIFY NODE REPORTS TO SUPERVISOR.
::	NODE REPORTS ARE THE 'REPORT TO SUPERVISOR'S LOG' MESSAGE, TYPE 1280.
::	THE NODE REPORT CONTAINS 3 HALFWORDS OF DATA.  THE FIRST
::	HALFWORD IS THE NODE REPORT MESSAGE TYPE, DEFINED AS FOLLOWS:
::
::*********************************************************************

NR.CHU	EQ	1		:CHANNEL IN USE
NR.UAC	EQ	2		:DATA ON UNASSIGNED CHANNEL
NR.BFZ	EQ	3		:BUFFER ZAP
NR.RLK	EQ	4		:RESPONSE TO REMOVE NEIGHBOR COMMAND
NR.ALK	EQ	5		:RESPONSE TO ADD NEIGHBOR COMMAND
NR.BUB	EQ	6		:LINK BUBBLE
NR.SHK	EQ	7		:LINK SHRINK
NR.NPT	EQ	8		:OUT OF PERMUTER TABLE SPACE
NR.NKD	EQ	9		:OUT OF LINK SPACE FOR NEW LINE ATTACH
NR.PLI	EQ	0A		:NUMBER CIRCUITS ZAPPED DUE TO LINK OUT
NR.ODP	EQ	0B		:NODE OUT OF DISPATCHER PORTS
NR.NRJ	EQ	0C		:NEEDLE REJECTED BY SLOT
NR.HIM	EQ	0D		:HOST IS IMPOSTER, DETECTED BY NODE CODE
NR.CTM	EQ	0E		:REPORT CIRCUIT LIFETIME (IN SECONDS) FOLLOWING
				:CHANNEL IN USE REPORT
NR.SNP	EQ	0F		:LINK SNIP - NEIGHBOR SPLIT CHARACTER PAIR OR
				:SENT INVALID CHANNEL NUMBER IN PACKET
NR.DGN	EQ	10		:GENERAL DIAGNOSTIC NODE REPORT - FIRST BYTE OF
				:HW2 CONTAINS SUB-TYPE
NR.NNE	EQ	11		:NEEDLE BOUND FOR NEIGHBOR NOT FOUND
NR.XMN	EQ	12		:INVALID NODE NUMBER ON COMMAND CIRCUIT MESSAGE
NR.XCM	EQ	13		:INVALID COMMAND TYPE ON COMMAND CIRCUIT
NR.NCE	EQ	14		:CIRCUIT BUILDING ERRORS DETECTED
NR.CKC	EQ	15		:CIRCUIT BUILDING CONSISTENCY ERRORS
NR.LFR	EQ	16		:LINK FROZEN
NR.LTH	EQ	17		:LINK THAWED
NR.CCZ	EQ	18		:COUNT OF CMD CRCUITS ZAPPED DUE TO LINK OUTAGE
NR.CRP	EQ	19		:NODE CRASH REPORT
NR.SSX	EQ	1A		:REPORT # SIO, SYNC, XLINKS, NLINKS
NR.PPT	EQ	1B		:REPORT # PORTS, PASSTHROUGHS
NR.UNL	EQ	1C		:REPORT UNUSED LINES
NR.LNR	EQ	1D		:LINE/LINK REPORT (INSTEAD OF SYNPRT)
NR.SML	EQ	1E		:SLOT REPORT LIMIT EXCEEDED
NR.INH	EQ	1F		:INVALID HOST ON RESTRICTED HOST NODE
NR.CLE	EQ	20		:SLOT/HOST CIRCUIT LIMIT EXCEEDED
NR.DLD	EQ	21		:COUNT OF CIRCUITS ZAPPED DUE TO DLOAD COMMAND
NR.I3C	EQ	22		:INVALID 03-CHAR PAIR ON COMMAND CIRCUIT
NR.MAC	EQ	23		:NODE TOOK MAC INTERRUPT AND RECOVERED
NR.K56	EQ	24		:56KB DIAGNOSTIC - SIO TIMEOUT ON OUTPUT
				:25 UNUSED
NR.T13	EQ	26		:INVALID 03-CHAR PAIR ON T-I COMMAND CIRCUIT
NR.T1L	EQ	27		:T-I SUP RECORD WITH INVALID LENGTH
NR.DMA	EQ	28		:MAC INTERRUPT CASED BY DMA HARDWARE TIMEOUT
NR.KZF	EQ	29		:KERNEL PORT ZAP SVC GAVE NON-SKIP RETURN
NR.CR1	EQ	2A		:FIRST ADDENDUM TO CRASH REPORT, CRASH ID
NR.CR2	EQ	2B		:2ND ADDENDUM TO CRASH REPORT,REGISTER CONTENTS
NR.HVR	EQ	2C		:REPORT KERNEL HOST NUMBER AND VERSION NUMBER
NR.SQF	EQ	2D		:SQFIX ERROR. HW1=BUFFER, HW2=COUNT
NR.TMP	EQ	2E		:TEMPERATURE EXCEEDS DESIRABLE RANGE
				:(OR IS BELOW ACCEPTABLE).		###JHL
NR.NID	EQ	2F		:NETID mismatch for potential new link	###wjl
NR.WSZ	EQ	30		:WSIZ match down for new link		###wjl
NR.XID	EQ	31		:XRAY NETID change for new link		###wjl
NR.RRF	EQ	32		:STARLINK Remote Reset Failure		###ev
NR.ARW	EQ	33		:Async Ring Wrap			###wjl

:	DEFINE SUB-TYPES FOR GENERAL DIAGNOSTIC NODE REPORT (NR.DGN)

DR.SYM	EQ	0		:SYNC SCAN INSTRUCTION TOOK NON-SKIP RETURN
:	INDICATING 'START BIT' FOUND IN SYNC RING, BUT MEMORY POINTED TO
:	BY INDEX REGISTERS (R11 & R13) CONTAINED ALL ONES.  SECOND BYTE
:	OF HW2 HAS 2*LINE NUMBER, HW3 HAS R13 (SYNC RING BASE INDEX,
:	OFFSET INTO SYNC AREA).

DR.SIO	EQ	1		:SIO BUFFER LENGTH FIELD = 0 OR > 132d,
:	SHOULD BE NEGATIVE UNTIL POSITIVE COUNT STORED BY MOTHER
:	BOARD.  SECOND BYTE OF HW2 HAS 2*LINE NUMBER, HW3 HAS NUMBER OF
:	OCCURRENCES.

DR.SZC	EQ	2	:TIMEOUT ON M-BOARD WHILE ATTEMPTING CONNECT.
:	SECOND BYTE OF HW2 = LINE NUMBER, HW3= NEIGHBOR NUMBER (+8000 IF UP)

DR.SZI	EQ	3	:IDENTICAL TO DR.SZC FOR INPUT TIMEOUT
DR.SZO	EQ	4	:IDENTICAL TO DR.SZC FOR OUTPUT TIMEOUTS
DR.SZS	EQ	5	:IDENTICAL TO DR.SZS FOR STATUS SVC TIMEOUTS

:	THE FOLLOWING MESSAGE TYPES ARE FOR REPORTING LINE DIAGNOSTICS.
:	THE FIRST 16 BITS ARE OF THE FORMAT TTLL, WHERE TT IS THE
:	MESSAGE TYPE, AND LL IS THE LINE NUMBER FOR WHICH THE DIAGNOSTIC
:	REPORT IS BEING MADE.

LL	EQ	0		:VALID VALUES ARE 0 - NLINES-1

NR.SRT	EQ	8000+LL		:TOTAL PACKETS SENT AND RECEIVED
NR.BRI	EQ	8100+LL		:# OF BAD BORI'S
NR.ACK	EQ	8200+LL		:# OF BAD ACKS
NR.RCN	EQ	8300+LL		:# OF BAD RECORD NUMBERS
NR.CHS	EQ	8400+LL		:# OF CHECKSUM ERRORS
NR.RTR	EQ	8500+LL		:# OF RETRANSMISSIONS RECEIVED
NR.RTS	EQ	8600+LL		:# OF RETRANSMISSIONS SENT
NR.4SG	EQ	8700+LL		:# OF 4-SECOND GAPS W/ NO GOOD RECORDS RECEIVED
NR.CRS	EQ	8800+LL		:# OF CROSS-TALK ERRORS
NR.SPC	EQ	8900+LL		:# OF TIMES SPACING DETECTED ON INPUT
NR.HCK	EQ	8A00+LL		:# OF SIO HDLC CHECKSUM ERRORS
NR.HAB	EQ	8B00+LL		:# OF SIO HDLC ABORTS

	SUBTTL	DATA (Crash Codes)

::*********************************************************************
::
::	CRASH CODES:
::	All crash codes are defined here.  New crash codes should be added
::	at the end of this list, they must not be inserted since this would
::	change the definition of codes which follow the insertion.  They
::	should not be under any switches.
::
::*********************************************************************

.EXCRH	DFCRH.(.EXCRH,C.SWCE,0,EXCRH EXEC tried to dispatch to nonexistent process%(PROCID*2 in R2))
.BIDCR	DFCRH.(.BIDCR,C.INML,0,BIDCR BIDDY found nothing to do.%  (R1 = dispatch array - should be non-zero))
.YKMCR	DFCRH.(.YKMCR,C.HWCE,0,YKMCR YAKMAC tried to recover from MAC error`, failed.  %KD contains difference between expected and actual KD's.)
.BIDHC	DFCRH.(.BIDHC,C.INML,0,BIDHC JFFOH failure.)
.BIDC0	DFCRH.(.BIDC0,C.INML,0,BIDC0 JFFO error.)
.SV39C	DFCRH.(.SV39C,C.SVER,39*2,SV39C ISIS connect SIO line SVC error.)
.SV3BC	DFCRH.(.SV3BC,C.SVER,3B*2,SV3BC ISIS start SIO output SVC error.)
.SV3AC	DFCRH.(.SV3AC,C.SVER,3A*2,SV3AC ISIS start SIO input SVC error.)
.SV0CC	DFCRH.(.SV0CC,C.SVER,0C*2,SV0CC SOLO connect SIO line SVC error.)
.SV0EC	DFCRH.(.SV0EC,C.SVER,0E*2,SV0EC SOLO start SIO output SVC error.)
.SV0DC	DFCRH.(.SV0DC,C.SVER,0D*2,SV0DC SOLO start SIO input SVC error.)
.SV38C	DFCRH.(.SV38C,C.SVER,38*2,SV38C ISIS get SIO status SVC error.)
.SV0FC	DFCRH.(.SV0FC,C.SVER,0F*2,SV0FC SOLO get SIO status SVC error.)
.SV32C	DFCRH.(.SV32C,C.SVER,32*2,SV32C ISIS force SYNC output SVC error.)
.SV30C	DFCRH.(.SV30C,C.SVER,30*2,SV30C ISIS connect SYNC SVC error.)
.LKER0	DFCRH.(.LKER0,C.SWCE,0,LKER0 LINKER found more than 0 lines on inactive link.)
.O1263	DFCRH.(.O1263,C.SWCE,0,O1263 LINKER found active link with 0 lines.)
.O1463	DFCRH.(.O1463,C.SWCE,0,O1463 LINKER found KDKN/KDSVLN inconsistency.)
.O1663	DFCRH.(.O1663,C.SWCE,0,O1663 LINKER found active line marked inactive.)
.O1863	DFCRH.(.O1863,C.SWCE,0,O1863 LINKER found NLAT .NE. sum of lines fields.)
.SIER0	DFCRH.(.SIER0,C.SWCE,0,SIER0 SOLO SIO CCW chaining failure.)
.RTZC0	DFCRH.(.RTZC0,C.SWCE,0,RTZC0 RTD detected zapper for circuit with null P/T entry.)
.RMEB0	DFCRH.(.RMEB0,C.SWCE,0,RMEB0 RMAKE found buffer empty.)
.RMZLR	DFCRH.(.RMZLR,C.SWCE,0,RMZLR RMAKE couldn't find 2nd character of 00/01 pair.)
.RMZL3	DFCRH.(.RMZL3,C.SWCE,0,RMZL3 RMAKE couldn't find 2nd character of 03 pair.)
.RMNER	DFCRH.(.RMNER,C.SWCE,0,RMNER NEDOUT <= 0 in RMAKE.)
.RMKNE	DFCRH.(.RMKNE,C.SWCE,0,RMKNE RMAKE NEEDLE ERROR)
.RMKHS	DFCRH.(.RMKHS,C.SWCE,0,RMKHS RMAKE NEGATIVE LOGICAL RECORD COUNT)
.RMHS3	DFCRH.(.RMHS3,C.SWCE,0,RMHS3 RMAKE NEGATIVE LOGICAL RECORD COUNT)
.RMZL0	DFCRH.(.RMZL0,C.SWCE,0,RMZL0 RMAKE ZERO LENGTH RECORD)
.RMNE0	DFCRH.(.RMNE0,C.SWCE,0,RMNE0 RMAKE NEEDLE OUTSTANDING, NEEDOUT NOT POSITIVE)
.RMPER	DFCRH.(.RMPER,C.SWCE,0,RMPER RMAKE BAD PERF MON CHAR)
.RMZL1	DFCRH.(.RMZL1,C.SWCE,0,RMZL1 RMAKE ZERO LENGTH RECORD)
.RMBE0	DFCRH.(.RMBE0,C.SWCE,0,RMBE0 RMAKE BUFFER EMPTY)
.RMTIE	DFCRH.(.RMTIE,C.SWCE,0,RMTIE RMAKE BAD 03-PAIR TO T-I NEIGHBOR)
.RMTNS	DFCRH.(.RMTNS,C.SWCE,0,RMTNS RMAKE):???
.RMHS2	DFCRH.(.RMHS2,C.SWCE,0,RMHS2 RMAKE ILLEGAL 02 FOR HISTORY):###TZ
.KERIC	DFCRH.(.KERIC,C.INML,0,KERIC JFFO failure.)
.KERI0	DFCRH.(.KERI0,C.SWCE,0,KERI0 KERIN found 0 P/T entry.)
.KICTC	DFCRH.(.KICTC,C.SWCE,0,KICTC XHOSTS found invalid 03 pair from kernel.)
.KRCXC	DFCRH.(.KRCXC,C.SWCE,0,KRCXC XHOSTS detected invalid control record from kernel.)
.KRXCA	DFCRH.(.KRXCA,C.SWCE,0,KRXCA XHOSTS detected invalid ack from kernel.)
.SUPIC	DFCRH.(.SUPIC,C.SWCE,0,SUPIC XHOSTS supe interface - no circuit.)
.SUPI0	DFCRH.(.SUPI0,C.SWCE,0,SUPI0 XHOSTS supe interface 0 length record.)
.SUPI1	DFCRH.(.SUPI1,C.SWCE,0,SUPI1 XHOSTS supe interface empty buffer.)
.DISI0	DFCRH.(.DISI0,C.SWCE,0,DISI0 DISPI found no dispatcher circuit.)
.DISO0	DFCRH.(.DISO0,C.SWCE,0,DISO0 DISPI got RPORT out of range from dispatcher.)
.DSOC0	DFCRH.(.DSOC0,C.SWCE,0,DSOC0 DISPI dispatcher output msg type invalid.)
.DSZE0	DFCRH.(.DSZE0,C.SWCE,0,DSZE0 DISPI got junk from dispatcher on channel 0.)
.DSIO0	DFCRH.(.DSIO0,C.SWCE,0,DSIO0 DISPI invalid message from dispatcher)
.DSKP0	DFCRH.(.DSKP0,C.SWCE,0,DSKP0 DISPI DSK type too large.)
::*	Crash codes used in SWITCH
.WCIC0	DFCRH.(.WCIC0,C.SWCE,0,WCIC0 SWITCH illegal WCI to buffer 1 or 0.)
.WCIC1	DFCRH.(.WCIC1,C.SWCE,0,WCIC1 SWITCH invalid WCI buffer index.)
.WRECR	DFCRH.(.WRECR,C.SWCE,0,WRECR SWITCH reserve tank empty.)
.GCICR	DFCRH.(.GCICR,C.SWCE,0,GCICR SWITCH GCI buffer 0.)
.GCIC0	DFCRH.(.GCIC0,C.GCEB,0,GCIC0 SWITCH GCI for empty buffer or bad buffer index.)
.CBCLC	DFCRH.(.CBCLC,C.SWCE,0,CBCLC SWITCH CBCLR bad buffer index.)
.CBCL0	DFCRH.(.CBCL0,C.SWCE,0,CBCL0 SWITCH CBCLR invalid channel number.)
.RTBLC	DFCRH.(.RTBLC,C.SWCE,0,RTBLC SWITCH RETBLT BCT went < 0)
.CRQCR	DFCRH.(.CRQCR,C.SWCE,0,CRQCR SWITCH CRQ bad buffer index.)
.CRQC0	DFCRH.(.CRQC0,C.SWCE,0,CRQC0 SWITCH CRQ needle garbage.)
.LEPCR	DFCRH.(.LEPCR,C.SWCE,0,LEPCR SWITCH LEP invalid rebild reject.)
.INTCR	DFCRH.(.INTCR,C.SWCE,0,INTCR SWITCH INHST found no work to do.)
.SUPCR	DFCRH.(.SUPCR,C.SWCE,0,SUPCR SWITCH invalid accounting data type from supe.)
.CRQC2	DFCRH.(.CRQC2,C.SWCE,0,CRQC2 SWITCH CRQ buffer out of range.)
.ZAPCR	DFCRH.(.ZAPCR,C.SWCE,0,ZAPCR SWITCH ZAPX bad IOTAB entry.)
.ZAPC0	DFCRH.(.ZAPC0,C.SWCE,0,ZAPC0 SWITCH ZAPV bad IOTAB entry.)
.ZAPC1	DFCRH.(.ZAPC1,C.SWCE,0,ZAPC1 SWITCH ZAPV bad compementary BF.)
.GFCR0	DFCRH.(.GFCR0,C.SWCE,0,GFCR0 SWITCH GFCBUF no more buffers.)
.GFCR1	DFCRH.(.GFCR1,C.IFLP,0,GFCR1 SWITCH GFCBUF invalid free list pointer.)
.GFCR2	DFCRH.(.GFCR2,C.SWCE,0,GFCR2 SWITCH GFCBUF invalid link buffer pointer.)
.GFCR3	DFCRH.(.GFCR3,C.SWCE,0,GFCR3 SWITCH GFCBUF bad buffer index.)
.RFCR0	DFCRH.(.RFCR0,C.SWCE,0,RFCR0 SWITCH RFCBUF invalid buffer index.)
.FNCHC	DFCRH.(.FNCHC,C.SWCE,0,FNCHC SWITCH FNDCHN ACP consistency error.)
.FNCH0	DFCRH.(.FNCH0,C.SWCE,0,FNCH0 SWITCH FNDCHN ACP/IOTAB consistency error.)
.BUBCR	DFCRH.(.BUBCR,C.SWCE,0,BUBCR SWITCH BUBBLE BF/NIOTAB consistency error.)
.BUBC0	DFCRH.(.BUBC0,C.SWCE,0,BUBC0 SWITCH BUBBLE LKAPND consistency error.)
.BUBC1	DFCRH.(.BUBC1,C.SWCE,0,BUBC1 SWITCH BUBBLE IOTAB consistency error.)
.CBCT0	DFCRH.(.CBCT0,C.SWCE,0,CBCT0 SWITCH CBCCT-BCT consistency error.)
.ASLO0	DFCRH.(.ASLO0,C.SWCE,0,ASLO0 ASYNC ASYLOU no ANITAB entry for port.)
.ASLO1	DFCRH.(.ASLO1,C.SWCE,0,ASLO1 ASYNC ASYLOU ANITAB entry not complement of .LGBUF.)
.ASC20	DFCRH.(.ASC20,C.SWCE,0,ASC20 ASYNC 02 character pair toward port.)
.ASC30	DFCRH.(.ASC30,C.SWCE,0,ASC30 ASYNC invalid 03 character pair toward port.)
.ASY30	DFCRH.(.ASY30,C.SWCE,0,ASY30 ASYNC illegal ALIERR code.)
.GCHCR	DFCRH.(.GCHCR,C.SWCE,0,GCHCR ASYNC invalid prefix code.)
.PTSGC	DFCRH.(.PTSGC,C.SWCE,0,PTSGC ASYNC invalid signal from CONSAT.)
.ASLO2	DFCRH.(.ASLO2,C.SWCE,0,ASLO2 ASYNC)
.CPKCR	DFCRH.(.CPKCR,C.SWCE,0,CPKCR ASYNC)
:
:	NEW CRASH CODES TYPE C.SWCE ARE ADDED HERE REGARDLESS OF LOCATION
:	IN THE CODE IN ORDER TO LEAVE PREVIOUS C.SWCE CRASH SUBTYPES THE SAME
:	(C.SWCE CRASH SUBTYPES ARE SEQUENTIAL BY ORDER OF DFCRH. INVOKATIONS).
:
.RMHS4  DFCRH.(.RMHS4,C.SWCE,0,RMHS4 YAKYAK RMAKE LRC<0 after fat gob shrink.)
.NEGBF	DFCRH.(.NEGBF,C.SWCE,0,NEGBF YAKYAK BFLTSV<0 AFTER BUFFERLET ACQ OR REL)
.NEGHB	DFCRH.(.NEGHB,C.SWCE,0,NEGHB YAKYAK HBFTSV<0 AFTER HIST BUF ACQ OR REL)
.WREFL	DFCRH.(.WREFL,C.SWCE,0,WRE SWITCH ILLEGAL CALL TO WRE - POSSIBLE MACERROR)

::	Some crashes of log 2
.LEP0A  DFCRH.(.LEP0A,C.SWCE,0,LEP0A Illegal message)
.DSISN  DFCRH.(.DSISN,C.SWCE,0,ISN needle data missing)
.GCD0   DFCRH.(.GCD0,C.SWCE,0,GCD discovered corrupted bufferlet chain)
.ckzb0	DFCRH.(.ckzb0,C.SWCE,0,.CKZB discovered circularly linked bflet chain)
.FNCH1	DFCRH.(.FNCH1,C.SWCE,0,FNDCHN discovered error between NC and DISPATCHER PORT in use.)
.EXE02	DFCRH.(.EXE02,C.SWCE,0,EXE02 discovered corrupted mapping.)
.DISHS	DFCRH.(.DISHS,C.SWCE,0,Gateway host was rejected in INET.)
.IZSIR	DFCRH.(.IZSIR,C.SWCE,0,Split Sup rings connect failed.)
.XRYSN	DFCRH.(.XRYSN,C.SWCE,0,Crash requested by Xray command.)
.XRYZP	DFCRH.(.XRYZP,C.SWCE,0,Crash in Xray ZP cmd due to lack of buffers)
.sup14	DFCRH.(.sup14,C.SWCE,0,Sup14 got an illegal accounting invoice number)
.nci02	DFCRH.(.nci02,C.SWCE,0,PCIS or PCI or NCI looked at an empty buffer)
.whwi0	DFCRH.(.whwi0,C.SWCE,0,WHWI0 called with buffer number greater than 4)
.ghwi0	DFCRH.(.ghwi0,C.SWCE,0,GHWI0 called with buffer number greater than 4)
.disza	DFCRH.(.disza,C.SWCE,0,DSIZAP found other half of circuit up)
.DISHH	DFCRH.(.DISHH,C.SWCE,0,Gateway host was rejected in HNET.)

	SUBTTL	DATA (EQuates and constants)

::*********************************************************************
::
::	EXEC PARAMETERS:
::
::*********************************************************************

VERSION	EQ	REVLEV!10000!30000*T2GATE :VERSION NUMBER

CTBVER	EQ	1			:CRASH TABLE VERSION

FASTC	EQ	segf+4		:FASTC
LO.CLK	EQ	segf+1c		:SEGF HW REFERENCE PTR TO SLOT CLOCKS	###OAS
	SYAD(FASTC )
SLOWC	EQ	segf+8		:ISIS MAINTAINS SLOWC RESOLVED TO A SECOND
	SYAD(SLOWC )
GMT	eq	segf+0c		:isis stores GMT

TEMPER	EQ	segf+10		:ISIS-SUPPLIED TEMPERATURE
VOLTS	EQ	segf+11		:AND VOLTAGE
	SYAD(TEMPER)		:ADD TO XRAY SYMBOL TABLE FOR
verno	eq	segf+12		:where isis puts it's version
LCT	eq	segf+20		:address of local crash table

     IF T2GATE  		:gateway has no kernel
IKERNL  EQ	0
     ELSE
IKERNL	EQ	1		:ENABLE ISIS KERNEL CODE
     EI
NHOSTS	EQ	NUMHST		:# OF HOSTS, TYMFILE SPEC (DEFAULTED 64 OR 128)

:	OTHER DEFINITIONS:
ORCBSZ	EQ	$A 144	:SIZE OF RECORD BUFFERS +16 so no copy sio output
RECBSZ	EQ	$A 128	:SIZE OF input RECORD BUFFERS
SVNBSZ	EQ	100		:SIZE OF SYNC LINE INPUT BUFFERS
RATE	EQ	$A600		:FAST CLOCK TICKS/SEC

::*********************************************************************
::
::	LINKER PARAMETERS:
::
::*********************************************************************

	RA	0A		:SET DECIMAL RADIX

	DEFAULT(DEFWSZ,8)		:DEFAULT WSIZ (Tymfile parameter)##wjl

::	Compute total number of physical records to be reserved
NRECDS	EQ	0		
Q	EQ	0
	RE	NLINKS
	DEFAULT(WSIZ|Q|,DEFWSZ)		:Window size defaults to 8	###wjl
NRECDS  EQ	NRECDS+2*WSIZ|Q|	:this link is tunnel or not, the
Q	EQ	Q+1			:			###EV
	ER

	RA	0		:RESTORE HEX RADIX

:	CALCULATE PERMUTER TABLE SPACE - INCLUDE NSP IN CALCULATIONS	###gt
:					- include NDP   		###sdw
TCHANS	EQ	80*(NLINKS+2+2*NPTHR/80+NSP/80+ndp/80) :TOTAL NUMBER OF LINK CHNS

TINTCH	EQ	$A 16		:TOTAL NUMBER OF INTERNAL HOST CHANNELS

::	Number of circuits to keep accounting for
NACCTS	EQ	0		:start off with none
	IF	T2GATE
NACCTS	EQ	NDP
	EI
	IF	INTACC		:Internal host accouting
NACCTS	EQ	TINTCH+NKU+naccts	:Internal Host ports plus Kernel ports
	EI	:INTACC
				:.... MUST BE POWER  OF 2
	if	numxlt-tintch	:more line tester ports than internal ports?
numxlt	eq	tintch
	ei	:not too many ports
	if	1-numxlt	:a minimum of 1 line tester ports
numxlt	eq	1
	ei
xltpsz	eq	90		:memory required for a line test packet
DWLPSZ	EQ	42		:packet size for dwl line packet
DWLBSZ	EQ	50		:output buffer size for dwl line packet

:	SYNC LINE TRACE OPTION:

	IF	DB.TSN
	IF	T2GATE
	DEFAULT(TSTSZE,80)
	ELSE
	DEFAULT(TSTSZE,200)	:200 BYTES, 200/TSESZE ENTRIES
	EI	:T2GATE
	ELSE	:NOT DB.TSN
TSTSZE	EQ	0		:IF NOT DB.TSN, TRACE-SYNC TABLE SIZE = 0
	EI 	:DB.TSN

:	NOTE THAT IF DB.TSN IS SPECIFIED AND TSTSZE IS DEFINED WITH
:	A ZERO VALUE, THE TRACE-SYNC OPTION IS NOT ENABLED. IF TSTSZE IS
:	SPECIFIED, IT MUST BE A POWER OF 2.

	IF	TSTSZE

:	TRACE-SYNC PACKAGE ENABLED. AN ENTRY IS MADE IN A TABLE FOR EACH
:	SYNC LINE EVENT DETECTED FOR A PARTICULAR LINK OF INTEREST. WHEN THE
:	OPTION IS ENABLED IN A NODE, THE TRACING BEGINS WHEN THE 'TSLINK'
:	HALFWORD IS PATCHED WITH THE NEIGHBOR NUMBER ON THE LINK TO BE TRACED.
:	SYNC LINE EVENTS FOR ALL LINES ON THE LINK ARE RECORDED. THE TRACING
:	ENDS WHEN THE NODE DECLARES THE LINK OUT, EITHER BY DETECTING A RESET
:	OR BY RECEIVING NO GOOD RECORDS IN A FOUR-SECOND INTERVAL. EACH SYNC
:	ENTRY IS TSESZE (8) BYTES LONG, WITH THE FORMAT:
:
:	______________________________________________________________
:
:	| TYPE | LINE |      PACKET HEADER     |      FASTC TIME     |
:	______________________________________________________________
:	   1       1	       3 BYTES		       3 BYTES
:
:	SINCE THE SYNC LINE RECEIVER ROUTINES (SYLVER) RUN AS A FOREGROUND
:	PROCESS IN ISIS, TWO TABLES ARE MAINTAINED: TSFTBL FOR FOREGROUND (LINE
:	RECEIVER) EVENTS, AND TSBTBL FOR BACKGROUND (ATTACH, DETACH, RTD, AND
:	RMAKE) EVENTS. THE EVENT TYPES ARE DEFINED AS FOLLOWS:
:
:	BACKGROUND:
TS.ATT	EQ	3	:LINE ATTACH - HAS 'NLAT' VALUE FROM LINK DESCRIPTOR
			: INSTEAD OF HEADER IN BYTES 2 AND 3.
TS.DET	EQ	2	:LINE DETACH - HAS 'LRT' VALUE FROM LINK DESCRIPTOR
			: INSTEAD OF HEADER IN BYTES 2 AND 3,
			: AND 'DREASON' IN BYTE 4.
TS.MAK	EQ	0	:PACKET QUEUED FOR TRANSMISSION BY RMAKE. BYTE 1 IS
			: 'LAS', BYTE 2 IS FIRST BYTE OF PACKET,
			: BYTE 3 IS 'LRT', BYTE 4 IS PACKET RECORD NUMBER.
TS.RTD	EQ	1	:PACKET TORN BY RTEAR. BYTE 1 IS 'LAS', BYTES 2 - 4
			: ARE ACTUAL PACKET HEADER.

:	FOREGROUND:
TS.HDR	EQ	0	:A ZERO BIT HAS BEEN DETECTED WHILE LINE IS IN MARKING
			: STATE. ALIGNED POTENTIAL HEADER IS IN FIRST 2
			: BYTES OF HEADER FIELD.
TS.RST	EQ	1	:RESET DETECTED ON ATTACHED LINE.
TS.DUM	EQ	2	:DUMMY RECORD DETECTED.
TS.REC	EQ	7	:ENTIRE RECORD RECEIVED WITH GOOD CHECKSUM.
TS.CSE	EQ	3	:ENTIRE RECORD RECEIVED, CHECKSUM ERROR DETECTED.
TS.BAK	EQ	4	:ENTIRE GOOD RECORD RECEIVED, BAD ACK. HAS 'LAR' VALUE
			: FROM LINK DESCRIPTOR IN BYTES 5 AND 6.
TS.RXC	EQ	5	:ENTIRE GOOD RECORD RECEIVED, RETRANSMISSION.
TS.BRN	EQ	6	:ENTIRE GOOD RECORD RECEIVED, BAD RECORD NUMBER.
TS.UAL	EQ	8	:HEADER RECEIVED ON UNASSIGNED LINE

:	NOTE THAT SOME EVENTS UTILIZE ONLY 2 BYTES OF HEADER FIELD
:	IN THAT CASE ALL FOUR BYTES OF FASTC APPEAR.

TSESZE	EQ	8		:ENTRY SIZE (IN BYTES)
	EI	:TSTSZE

WBORIM	EQ	$2 00100000	:T-II MASTER BORI
WBORIS	EQ	$2 00010000	:T-II SLAVE BORI
NAKORI	EQ	$2 01010000	:T-II STARLINK NEGATIVE ACK PACKET
SATSPD  EQ	$2 01000000	:FOR DENOTING SATELLITE TO SUP

RBOTHD	EQ	3010		:TYMSTAR HUB REMOTE-BOOT HEADER		###AL

:	RESET HEADERS
TTRSHD	EQ	30A0		:T-II RESET HEADER FOR NEW LINK
TSRSHD	EQ	30B0		:T-II RESET HEADER FOR SUBSEQUENT LINE ON LINK
TRRSHD	EQ	30C0		:SCLP reset header			###wjl

TWDMHD	EQ	306978AB	:TYMNET-II DUMMY RECORD
DWNLHD	EQ	3232		:DOWNLINE LOAD RECORD HEADER

KDIGTM	EQ	$A 120		:NUMBER OF SECONDS TO IGNORE LINE WHICH DID
:	NOT PASS PROPER KEY IN RESET SEQUENCE, OR COULDN'T BE ATTACHED DUE TO
:	LACK OF PERMUTER TABLE SPACE.

:	SUP REPORTS ARE TYPE 14, SUBTYPE xx, WHERE xx IS:
LKOVMS	EQ	93		:LINK OVERLOADED SUBTYPE
LKSTMS	EQ	94		:LINK SATURATED SUBTYPE

:	name of link attributes
LK.SHK	eq	1		:neighbor (naima) does not want a shrink
LK.RAB	eq	2		:sendor requests active BP messagess
LK.SAB	eq	4		:sendor will send active BP

:	DEFAULT THRESHOLDS ARE DEFINED AS FOLLOWS:

	DEFAULT(LKOVTH,$A 10)	:DEFAULT LINK OVERLOAD THRESHOLD TO 10
	DEFAULT(LKSTTH,$A70)	:DEFAULT SATURATED THRESHHOLD		###TZ


::*********************************************************************
::
::	YAKYAK PARAMETERS:
::
::*********************************************************************

	DEFAULT(TRIKLV,4)	:THRESHOLD FOR RTD TO DETERMINE 'GUSH' OR
				: 'TRIKLE' BACKPRESSURE REQUIREMENTS

	DEFAULT(T2SRVS,40)	:T-II THRESHOLD FOR SUCCESSIVE CHANNEL SERVICE
				: (SEE RMK10)

::*********************************************************************
::
::	XHOSTS PARAMETERS:
::
::*********************************************************************

:	HOST PID EQUATES
I2ISTP	EQ	37		:ISIS PID				###OAS
TIITYP	EQ	38		:SOLO NODE CODE PID			###OAS
SUPTYP	EQ	43		:SUPVERSIOR KERNEL PID			###OAS
SKERTY	EQ	48		:SPLIT SUPERVISOR(KERNEL) PID		###OAS

:	DEFINE MESSAGE TYPES FOR CONTROL RINGS
KR.ZAP	EQ	0		:ZAPPER
KR.GOB	EQ	1		:GOBBLER
KR.NLG	EQ	2		:NEWLOG SET-UP
KR.ACK	EQ	80		:INDICATES ACK RESPONSE
KR.ZAK	EQ	KR.ZAP+KR.ACK	:ZAPPER ACK
KR.GAK	EQ	KR.GOB+KR.ACK	:GOBBLER ACK

	IF 	SPLIT
SIRDWN	EQ	30		:STATUS INDICATING SIO BOARD DOWN (LINE OUT)
SIRUP	EQ	70		:STATUS INDICATING SIO BOARD UP
SIRRM0	EQ	20		:STATUS FOR RING PAIR 0 MISMATCH FROM SIO CARD
STSRM0	EQ	3F		:'SIRFLG' VALUE FOR RING MISMATCH 0
SIRINT	EQ	0ff		:initial status of SIO Ring copy mboard
	EI	:SPLIT

::*********************************************************************
::
::	DISPI PARAMETERS:
::
::*********************************************************************


:	Intra-node messages.  Compare with DSZETB jump table for
:	from-dispatcher messages.
INRSRQ	EQ	0	:restart request (unused)
INRSRP	EQ	1	:restart response (unused)
INTKVR	EQ	2	:node has been taken over (from node code)
INRPLG	EQ	3	:report to sup's log (from slot to node code)
INRPHT	EQ	4	:report host status (from ISIS or slot)
INRPAC	EQ	5	:report accounting (ISIS to node code)
INSTTM	EQ	6	:tell host what time it is (from node code)
INPNRQ	EQ	7	:pseudo-needle request (from slot to node code)
INACRQ	EQ	8	:aux-circuit request (from slot to node code)
INPNFL	EQ	9	:pseudo needle request failed (from ISIS or node code)
INRPPT	EQ	0A	:report host port availability (from slot)
INHTRJ	EQ	0B	:host unacceptable (from node code)
INRPCT	EQ	0C	:report host cost (from slot to node code)
INNOSP	EQ	0D	:no supervisor (node code to all slots)
IN1DWN	EQ	0E	:1_DOWN text follows (to slot)
INHTRQ	EQ	0F	:request for report of all hosts (from node code)
INRPHE	EQ	10	:extended host status report (from slot or ISIS)
NCHCST	EQ	88	:host status host cost message type
:	Host status codes for HSTAT
HANSW	EQ	0	:###EV
HDOWN	EQ	1
HSHUT	EQ	2
HGONE	EQ	3

:	Bits in HSTATN byte for EXPANDED HOST STATUS	###jhl
:	The format of this word matches the host status word in the
:	expanded takeover response, node-to-sup msg 19.
EHANSW	EQ	0
EHDOWN	EQ	40
EHSHUT	EQ	80
EHGONE	EQ	0C0
EHSTTS	EQ	0C0		:location of status bits
EHHOPT	EQ	20		:set if host out of ports
EHIIX	EQ	10		:IIX host
EHORGN	EQ	8		:origination only host
EHDSTN	EQ	4		:destination only host

:	Translated values of network messages to send to ISIS
ISDTCH	EQ	09E	:DETACH	###wjl
ISZAPR	EQ	09F	:ZAPPER
ISSTBP	EQ	0A0	:SET BACKPRESSURE
ISRLBP	EQ	0A1	:RELEASE BACKPRESSURE
ISGBLR	EQ	0A2	:GOBBLER
ISBLKB	EQ	0A4	:BLACK BALL
ISGRYB	EQ	0A5	:GREY BALL
ISEDEM	EQ	0A6	:ENTER DEFERRED ECHO MODE
ISLDEM	EQ	0A7	:LEAVE DEFERRED ECHO MODE
ISETRM	EQ	0A8	:ENTER TRM
ISLTRM	EQ	0A9	:LEAVE TRM
ISGRBL	EQ	0AA	:GREEN BALL
ISRDBL	EQ	0AB	:RED BALL
ISYLWB	EQ	0AC	:YELLOW BALL
ISRNGB	EQ	0AD	:ORANGE BALL
ISBRKD	EQ	0AE	:DETECTED BREAK
ISHANG	EQ	0AF	:HANG UP
ISQPRM	EQ	0B0	:QUERY PARAMETER
ISSPRM	EQ	0B1	:SET PARAMETER
ISLGCH	EQ	0B3	:LOGON CHAR
ISACCT	EQ	0B7	:ADDENDUM TO ACCOUNTING
ISHNG	EQ	0B8	:SUPERHANG
ISXLIM	EQ	0B9	:SET XMIT LIMIT
ISEBRK	EQ	0BA	:END OF BREAK
ISZACK	EQ	0BB	:ZAP ACK
ISEADM	EQ	0BC	:ENTER ALTERNATE DEVICE MODE
ISLADM	EQ	0BD	:LEAVE ALTERNATE DEVICE MODE
ISZRSN	EQ	0BE	:ZAP WITH REASON
ISSIIX	EQ	0BF	:ENTER IIX EXCHANGE
ISTIIX	EQ	0C0	:LEAVE IIX EXCHANGE
ISLISN  EQ	0C2	:Log2 ISIS needle
ISRCRI  EQ	0C3	:Log2 response for terminal in logon mode
ISICRS  EQ	0C4	:Log2 supplemental logon information
ISASLP  EQ	0C5	:Log2 Assign Logon port
ISLGSC  EQ	0C6	:Log2 Logon Successful (to origination)

INXLIM	EQ	9D		:INITIAL XMIT LIMIT
DTDAT	EQ	9D		:LAST DATA TYPE
       IF	LOGII   	:logon has last few new messages
DTCON   EQ	0C4
       ELSE     :LOGII
DTCON	EQ	0C0		:LAST CONTROL TYPE
       EI	:LOGII

:	SET DEFAULT VALUES FOR SCLTDF AND SMLTDF TO -1, INDICATING
:	NO LIMITS FOR CIRCUITS/MINUTE AND SLOT REPORTS/MINUTE BY SLOT.
	DEFAULT(SCLTDF,-1)
	DEFAULT(SMLTDF,-1)

:	SET VALUES FOR LIMITS FOR EACH SLOT TO THE DEFAULT IF NOT
:	ALREADY DEFINED.
	IF	(1-T2GATE)
Q	EQ	1
	RE	NUSLT
	DEFAULT(SCLT|$0Q|,SCLTDF)
	DEFAULT(SMLT|$0Q|,SMLTDF)
Q	EQ	Q+1
	ER
	EI	:(1-T2GATE)		###EV

	SUBTTL	DATA (X.409 Identifiers for LOG II)

::****************************************************************
::
::	The following equates the LOG2 x.409 ID and MOs with
::	their name and number.  It should not cause any concern that
::	many (if not most) of the equates are never used again.
::	Under LOG 2, NC passes most of the x,409 data without examining
::	it.
::
::****************************************************************

IDLGSC  EQ	1		:Logon success indicator (to origination)
ID.CCT  EQ	2		:MO containing the CCT
ID.RIX  EQ	3		:boolean IIX request indicator
ID.LGS  EQ	4		:logon status (normal response code)
ID.RUN  EQ	5		:boolean UUN request indicator
ID.BAT  EQ	6		:boolean batch circuit request
ID.OAD  EQ	7		:origination address
ID.ULC  EQ	8		:unparsed logon characters
ID.TPC  EQ	9		:throughput class
ID.COS  EQ	0A		:cost table
ID.ZAP  EQ	0B		:logon zap
ID.IRC  EQ	0C		:username's IRC
ID.THS  EQ	0D		:term host #
ID.OHS  EQ	0E		:orig host #
ID.HDX  EQ	0F		:boolean half duplex indication
ID.REV  EQ	10		:reverse charge call request
ID.NNL  EQ	11		:needle node list
ID.UNM  EQ	12		:username
ID.UUN  EQ	13		:UUN value
:	EQ	14		:acknowledge logon zap
ID.TAR  EQ	15		:target selection and qualification
ID.OPT  EQ	16		:logon options list
ID.SDL  EQ	17		:specified destination list
ID.RDA  EQ	18		:resultant destination address
ID.EXT  EQ	19		:host extension
ID.PRT  EQ	1A		:originating port number (real dport#)
ID.INF  EQ	1B		:ISN needle flags
ID.PWD  EQ	1C		:password for transparent logons
ID.ISN  EQ	1D		:ISN needle identifier
:	EQ	1E		:unused
ID.NCB  EQ	1F		:Node Code needle body identifier
ID.MSG  EQ	20		:message from supe to logon terminal
ID.NCF  EQ	21		:NCN flags
ID.NCH  EQ	22		:NCN head identifier
ID.ESC  EQ	23		:logon session reset (escape typed)
ID.NRJ  EQ	24		:node code generated rejects
ID.CNF  EQ	25		:CCN flags
ID.INV  EQ	26		:invoice number
ID.SRJ  EQ	27		:supe generated reject codes
ID.LNK  EQ	28		:number of links (nodes) circuit crosses
ID.ERC  EQ	29		:early (like psn reject) reject codes
ID.CCN  EQ	2A		:CCN identifier
ID.ONM  EQ	2B		:orig node number
ID.LTM  EQ	2C		:not a log 2 destination
ID.CCS  EQ	2D		:circuit cost
ID.TLI  EQ	2E		:transparent logon indication
ID.SHT  EQ	2F		:shut override
ID.SHN  EQ	30		:sub host number
ID.TIX  EQ	31		:tells origination if dest iix cap
IDRCRI  EQ	32		:RCRI identifier
ID.RMF  EQ	33		:RCRM flags
IDICRM  EQ	34		:ICRM identifier
:	EQ	35		:
ID.DIS  EQ	36		:dispatcher info sequence
ID.IMF  EQ	37		:ICRM flags
IDECRI  EQ	38		:ECRI identifier
ID.EIF  EQ	39		:ECRI flags
IDICRS  EQ	3A		:ICRS identifier
IDRCRM  EQ	3B		:ICRM identifier
IDNCRM  EQ	3C		:NCRM identifier
ID.NMF  EQ	3D		:NCRM flags
ID.RIF  EQ	3E		:RCRI flags
:	EQ	3F		:undefined
ID.NDT  EQ	40		:needle data (contain data for ISN)
ID.RPD  EQ	41		:PID of rejecting host
ID.OPD  EQ	42		:PID of originating host
ID.TPD  EQ	43		:PID of terminating host
ID.GOM  EQ	44		:gateway to origination logon msg
ID.OGM  EQ	45		:origination to gateway msg
ID.PGT  EQ	46		:passthrough generated text msg
ID.GGT  EQ	47		:gateway generated text msg

:	the following two are defined as part of x.409.  ie the
:	leading bits do not indication application ID.

RMOID   EQ	30		:with the constructor bit set (app bit off)
SMOID   EQ	31		:with the constructor bit set (app bit off)

:	following defined equates for the leading bits of the x.409 id

MO.C    EQ	20		:the constructor bit
IDBITS  EQ	1F		:the ID bits
MO.A    EQ	40		:the application bit
MO.AC1  EQ	60		:application/construction header for onebyte id
MO.AC2  EQ	7F00    	:application/construction header for twobyte id
MO.A1   EQ	40		:application bit for 1 byte ID
MO.A2   EQ	5F00    	:application bit for 2 byte ID
MO.LFM  EQ	80		:len is long form

:	following are names for bits in bit string MOs

L2F.AX  EQ	80		:aux circuit request
L2F.SQ  EQ	40		:subsequent logon info
L2F.ZA  EQ	40		:logon zapper ack
L2F.RJ  EQ	20		:logon is being rejected
L2F.CC  EQ	80		:command circuit needle - not supported
L2F.RC  EQ	40		:rebuild needle - not supported
L2F.IC  EQ	20		:intra node circuit
L2F.N2  EQ	10		:not log 2 dest
L2F.PN  EQ	08		:passthrough log II
L2F.PT  EQ	80		:partial log II ISIS msg
L2F.SP  EQ	40		:second piece of an ISIS log II msg
L2F.DL  EQ	1		:licensed to build aux circuit
L2F.NC  EQ	0
       IF	LOGII   	:report to supe as LOG II NC
L2F.NC  EQ	4000    	:in takeover say NC is log II capable
       EI	:LOGII
L2F.TK  EQ	40		:bit in takeover msg saying LOG II supe
L2F.DK  EQ	80		:tell dispatcher a LOG II supe
L2F.BT  EQ	4		:tell if circuit path is batch cost table

:	following are used in the MO create logic to determine the status
:	and location of the data for the MO

X4C.DT  EQ	0		:data is stored in table
X4C.UC  EQ	1		:unfinished constructor
X4C.BF  EQ	2		:data is stored in buffer (address in table)
X4C.MM  EQ	4		:data is stored in memory (address in table)
X4C.CC  EQ	8		:constructor completed


::*********************************************************************
::
::	SWITCH PARAMETERS:
::
::*********************************************************************

LOGBUF	EQ	4

:	TOTAL NUMBER OF CIRCUITS TERMINATING ON THE NODE
NLQ	EQ	8			:# of circuits to the LEPrechaun
NIQ	EQ	2*NLINKS		:# of Internode circuits (ILC, BPM)

NTERMS	EQ	NLQ+NIQ+NKU+NDP+NSP	:# of terminations

:	NUMBER OF CIRCUITS PASSING THROUGH THE NODE
NPASTH	EQ	(1-PTHRU)*NPTHR		:number of passthroughs allowed

:	NUMBER OF EXTRA COMMAND CIRCUITS in case node goes out of passthrus
	DEFAULT(NXCMDC,20)		:Tymfile parameter 		###wjl

:	NUMBER OF EXTRA LOGIN CIRCUITS

:	TOTAL NUMBER OF CIRCUITS ON THE NODE
	IF	T2GATE
NCIRCS	EQ	NLQ+NIQ+NDP+NXCMDC		:total cks thru gw node
	ELSE	:NOT GATEWAY
NCIRCS	EQ	NTERMS+NPASTH+NXCMDC	:total circuits thru node##LSH
	EI	:T2GATE

:	macro to return accounting block pointer
aamkpt	macro(RB)[
	lr	r11,RB
	SLLS	R11,2		:Make fullword index
]

:	do BCT since microcode won't help us
CBCCTM  MACRO(RA,RB,RS)[
	LHL	RS,BB+2,RB,
	NHI	RS,CBSZ-1
	LHL	RA,BE+2,RB,
	NHI	RA,CBSZ-1
	SR	RA,RS
	LHL	RS,BCT,RB,		:for BCT > 7FFF 		###wjl
	AR	RA,RS   		:  will cause crash		###wjl
]
	DEFAULT(CBSZL,6)	:default to 64 byte bufferlets
	if	macv
	if	6-cbszl		:not big enough to address it's space
cbszl	eq	6		:force big enough (bfletaddress/cbsz)
	ei ; ei			:must fit into a hw.

CBSZ	EQ	1^CBSZL		:SIZE OF BUFFERLETS
CBPTSZ  eq	2		:size of pointer

:	DEFINE CIRCUIT BACKPRESSURE CONSTANTS FOR THROUGHPUT CLASSES 0 TO 3.
:	EACH CIRCUIT MAY MOVE THIS MANY CHARACTERS PER HALF-SECOND BEFORE
:	BEING BACK-PRESSURED.

CIRSP0	EQ	$A32		:BPS CONSTANTS FOR CIRCUIT SPEEDS
CIRSP1	EQ	$A80
CIRSP2	EQ	$A256
CIRSP3	EQ	$A1024

:	TYMNET CONTROL CHARACTERS AND CHARACTER PAIRS:

ZAPPH	EQ	0301	:HARD ZAPPER
ZAPMIN	EQ	0301	:SMALLEST ZAPPER
ZAPPS	EQ	0302	:SOFT ZAPPER
ZAPPN	EQ	0303	:NON-GOBBLING ZAPPER
ZAPMAX	EQ	0303	:LARGEST SKINNY ZAPPER
ZAPPF	EQ	0304	:FAT ZAPPER (NODE PAIR FOLLOWS)
GOBBL	EQ	0308	:GOBBLER
GOBBF	EQ	0309	:FAT GOBBLER (NEW SEQUENCE NUMBER IN SECOND HW)
SQFIX	EQ	030B	:SQF - SEQUENCE NUMBER FIX FOR REBUILD
SQACK	EQ	030C	:SQACK - SEQUENCE NUMBER ACK FOR REBUILD
NEEDP	EQ	0310	:NEEDLE POINT
NEEDE	EQ	0311	:NEEDLE EYE
TILIM	EQ	0312	:MESSAGE FOR TERMINAL IN LOGIN
LOGRR	EQ	0313	:ERROR IN CIRCUIT REQUEST
COMET	EQ	0314	:buffer timer pair ###jhl

:	following are new network control pairs for LOG 2
:	these are internal and are directed only towards the dispatcher

L2SRJT  EQ	0315    	:for dispi, response/reject logon from supe
L2NRJT  EQ	0316    	:for dispi, response/reject logon from node
LG2EYE  EQ	0317    	:for dispi, needle eye for log 2
NEEDCV  EQ	0318    	:tells dispi this LOGI needle has LOG II ISN
:	control pairs that can be sent along the circuit
NEEDHD  EQ	0329    	:needle head for log 2
NEEDBD  EQ	032A    	:needle body for log 2
NEEDTL  EQ	032B    	:needle tail


:	PERFORMANCE MONITORING CONTROL CHARACTERS
:	CONTROL CHAR PAIRS 03-20 TO 03-3F ARE RESERVED FOR THIS PURPOSE
:	THESE CHARS ARE THE SECOND BYTE IN A 03-XX CHAR PAIR

XLAX	EQ	20	:XLAX IS LIKE TIMER, BUT HOPS TO HEAD OF USER DATA
XLACK	EQ	21	:XLAX ACK IS RETURNED BY TERMINATING NODE
TIMER	EQ	22	:TIMER MEASURES DELAY ON USER CRQ, MOVES WITH USER DATA
TIMACK	EQ	23	:TIMER ACK IS RETURNED BY TERMINATING NODE
REJECT	EQ	24	:RESPONSE BY TERMINATING NODE TO UNKNOWN CHAR PAIR
REAMER	EQ	25	:REAMER OPENS UP A CRQ

:	DEFINE BIT POSITIONS IN NEEDLE FLAG:

NF.REB	EQ	1	:REBUILD CIRCUIT
NF.CMD	EQ	2	:COMMAND CIRCUIT
:NF.T1O	EQ	4	:TYMNET-I ORIGINATION :no longer used
:NF.T1D	EQ	8	:TYMNET-I DESTINATION :no longer used
NF.LG2	EQ	8	:set if LOG II information follows needle
NF.BAT  EQ	40	:batch circuit request
NF.PRI	EQ	100	:PRIORITY CIRCUIT
NF.SMC	EQ	200	:SMART CIRCUIT (SIQ ORIGINATION, HIQ HOST)
NF.INT	EQ	8000	:INTERNAL CIRCUIT IF RESET (SET, RESET BY NODE CODE)
:	these flags are in the user flag HW in the needle
NF.HDX  EQ	200	:halfduplex
NF.CCL  EQ	40	:collect call

:	Login state flags.  These values are stored in the BF of a
:	login input buffer and they indicate the state of the login.
LOGSUP	EQ	04		:Bit means OK to send data to sup
LOGNDC	EQ	02		:Bit means node code ready to xmit login data
LG.TID	EQ	01		:Bit means TID is still in login buffer (hasn't
				:been sent to the sup yet).
LGSNT.	EQ	10+LOGSUP+LG.TID+LOGNDC	:SUP=Y, NC=Y, TID=Y
LGST.N	EQ	10+LOGSUP+LG.TID	:SUP=Y, TID=Y, NC=N
LGN.ST	EQ	10+LOGNDC		:NC=Y, SUP=N, TID=N
LG.SNT	EQ	10			:SUP=N, NC=N, TID=N
LGSN.T	EQ	10+LOGSUP+LOGNDC	:SUP=Y, NC=Y, TID=N
LOGXMT	EQ	10+LOGSUP+LOGNDC	:SUP=Y, NC=Y, TID=N
LOGMIN	EQ	10			:Minimum valid state flag
LOGMAX	EQ	17			:Maximum valid state flag


:	EQUATES FOR TEMPERATURE REPORTING--RANGES AND DELAY TIME.	###JHL
DLYTMP	EQ	$A 14		:INHIBIT TEMP RPT FOR 15 4 MIN INTERVALS
TOOHOT	EQ	26		:ISIS CONVERTS MF READING TO CENTIGRADE

:	HANDLE DATA FOR 'DETACHED PORTS'
:	THE FOLLOWING EQUATES IDENTIFY THE DETACH REASONS:
DETR00	EQ	0	:DISPATCHER OUT OF PORTS. DETECTED IN CRQ.
DETR01	EQ	1	:HOST OUT OF PORTS. DETECTED IN CRQ.
DETR02	EQ	2	:ZAP WITH REASON, HOST OUT OF PORTS. HANDLED IN DSOZWR
DETR03	EQ	3	:KERNEL OUT OF PORTS. DETECTED IN CRQ.
DETR04	EQ	4	:KERNEL SIO INTERFACE DOWN. SET UP IN KCQDET.

::	Accounting logout and zap reason equates
AALR02	EQ	02		:Normal disconnect by host
AALR03	EQ	03		:Normal disconnect by user
AALR07	EQ	07		:Out of internal host ports
AALR11	EQ	11		:User-name rejected .. bad Xray username
AALR19	EQ	19		:Host rejected caller .. out of Xray slots
				:or invalid DWL or PLI Message Function
AALR24	EQ	24		:Circuit rejected as invalid .. bad control
				:character or bad Internal Host function
AALR25	EQ	25		:host not answering .. circuit timeout
AALR26	EQ	26		:Resource limit exceeded .. bumped by
				:higher status Xray user

	SUBTTL	DATA (CRYPTO messages)

::*********************************************************************
::
::	CRYPTO MESSAGES:
::	HO NIBBLE MAPS BY BIT TO HW'S CONTAINING SIGNIFICANT DATA
::	2ND NIBBLE SPECIFIES CRYPTO MESSAGE CLASS:
::		0 = GENERAL, ALWAYS DISPLAYS
::		1 = CRYDIS, CIRCUIT BUILT, ZAPPED MESSAGES
::		2 = ASYDIS, ASYNC MESSAGES
::		3 = REBDIS, REBUILD MESSAGES
::		4-0F = RESERVED
::	LO BYTE IS MESSAGE NUMBER
::
::*********************************************************************

CRYE00	EQ	7000	:CRASH. HW1=CRSHID, HW2&3=CRASH ADDRESS
			:CRASH ID : 0=> OOPS, 1=> POWER FAIL, 2=>OPERATOR
			:HALT, 4=> ILLEGAL INST, 8=> MAC ERROR
CRYE01	EQ	3001	:LINK UP - HW2=LINK#, HW3=NEIGHBOR#
CRYE02	EQ	3002	:LINK DOWN. HW3 = NEIGHBOR NUMBER
CRYE03	EQ	3003	:NO PERMUTER TABLE HALF PAGES AVAILABLE FOR NEW
			: LINK - HW2=LINK#, HW3=NEIGHBOR#
CRYE04	EQ	7004	:LINE DETACHED. HW1=REASON, HW2=LINE#, HW3=NEIGHBOR#.
			:REASON : 1 => NO REC RECEIVED, 2=> NO GOOD REC
			: RECEIVED, 3=> RESET RECEIVED, 4 => BORI ZAP
CRYE05	EQ	4005	:TAKEOVER. HW1 = SUPERVISOR NUMBER
CRYE06	EQ	0006	:SUPERVISOR STOP
CRYE07	EQ	4007	:SUPERVISOR CRQ LOST. HW1 = SUPERVISOR NUMBER
CRYE08	EQ	5008	:NEEDLE GOBBLED IN CRQ. HW1= 03XX PAIR HW3= NEIGHBOR#
CRYE09	EQ	5009	:ZAPPER ON UNASSIGNED CHANNEL FROM T-I NEIGHBOR -
			:HW1=CHANNEL#, HW3=NEIGHBOR#
CRYE0A	EQ	100A	:NO NEIGHBOR - HW3=NEIGHBOR#
CRYE0B	EQ	0C10B	:CRQ BUILT. HW0&1 = NEEDLE ENTRY PORT, EXIT PORT
CRYE0C	EQ	0C10C	:CRQ ZAP. HW0&1 = ZAPPER ENTRY PORT, EXIT PORT
			:THE PRECEEDING TWO MESSAGES MUST BE MANUALLY ENABLED
			:BY LETTING CRYDIS > 0
CRYE0D	EQ	400D	:TERMINATING NEEDLE SPECIFIES A DESTINATION HOST NOT
			:ON THIS NODE. CRQ IS ZAPPED.  HW1 = HOST NUMBER
CRYE0E	EQ	500E	:GOBBLER OR OTHER CHARACTER PAIR FOLLOWS NEEDLE.
			:HW1 = CHARACTER. HW3=NEIGHBOR#
CRYE0F	EQ	400F	:TIMEOUT ON CHANNEL PROCESSING NEEDLE.
			:HW1=ABS CHN#
CRYE10	EQ	0C010	:CHANNEL IN USE - HW?= CHANNEL NUMBER
CRYE11	EQ	7311	:REBUILD REQUEST.
CRYE12	EQ	7312	:CRQ REBUILD COMPLETE.
CRYE13	EQ	0C013	:REBUILD REJECT
CRYE14	EQ	4014	:REBUILD DATA LOST
CRYE15	EQ	5015	:CHANGE IN HOST STATUS - HW1=STATUS, HW3=HOST #
CRYE16	EQ	7016	:NEW LINE ATTACHED. HW1=NLAT,HW2= LINE #, HW3= NGHBR
CRYE17	EQ	0C017	:OUT OF COMMAND PORTS, HW0= , HW1= .
CRYE18	EQ	0C018	:EARLY ZAPPER FOLLOWS NEEDLE.CHAN, NEIGHBOR
CRYE19	EQ	1019	:OUT OF CHANNELS TO NEIGHBOR. HW3= NEIGHBOR #
CRYE1A	EQ	401A	:BAD NEEDLE POINT RECEIVED. HW1= 'NEEDLE POINT'
CRYE1B	EQ	001B	:OUT OF PORTS TO NODE KERNEL
CRYE1C	EQ	501C	:NO MORE PORTS TO ISIS DISPATCHER. HW1=NDP, HW3=HOST#
CRYE1D	EQ	0F01D	:SIO INTERRUPT REPORT - HW1=INTERRUPT,
			: HW2=CONDITION CODE, HW3=LINE#, HW4=NEGHBR#
			: INTERRUPT CODE - 1 =ASYNC INTERRUPT, 2 =CCW ERROR,
			: 6 =UNDERRUN, 8 =I/O COMMAND ERROR, FFFF =BAD REC SIZE
			: CONDITION CODE - 0 = MBOARD AVAILABLE, 4 =NON-
			: FUNCTIONING BOARD, 8 =MBOARD BUSY		###OAS
CRYE1E	EQ	301E	:TYMNET-I LINE WENT 4 SECONDS WITH NO GOOD RECORDS
			: RECEIVED - HW2=LINE#, HW3=NEIGHBOR NUMBER
CRYE1F	EQ	401F	:RTD DETECTED NON-GOBBLING ZAPPER - HW1= NEIGHBOR
CRYE20	EQ	7020	:LINE SUSPENDED DUE TO RESET ERROR - HW1=NO. SEC'S
			:HW2=LINE#, HW3=NEIGHBOR#
CRYE21	EQ	5021	:LINK SHRINK - HW1=NCHN,  HW3=NEIGHBOR NUMBER
CRYE22	EQ	5022	:LINK BUBBLE - HW1=NCHN,  HW3=NEIGHBOR#
CRYE23	EQ	0C023	:INVALID LOGGER ENTRY - HW0=BUFFER,HW1=ILLEGAL BF
CRYE24	EQ	4024	:SUP DATA ON UNASSIGNED CHANNEL - HW1=CHN#
CRYE25	EQ	4025	:SUP ZAP ON UNASSIGNED CHANNEL - HW1=CHN#
CRYE26	EQ	5026	:INVALID MACHINE NUMBER ON SUP COMMAND CIRCUIT - HW1=
			: ERRONEOUS NEIGHBOR NUMBER (WE COULD BE OUT OF SYNC
			: ON COMMAND CIRCUIT)
CRYE27	EQ	0C027	:INVALID COMMAND TYPE FROM SUP - HW1=BAD COMMAND
CRYE28	EQ	5028	:DATA ON UNASSIGNED CHANNEL FROM NEIGHBOR - HW1=
			: CHANNEL NUMBER, HW3= NEIGHBOR #
CRYE29	EQ	5029	:NEEDLE ON ASSIGNED CHANNEL - HW1=CHANNEL NUMBER
			: HW3= NEIGHBOR NUMBER
CRYE2A	EQ	0C02A	:RECEIVED 03 CHARACTER PAIR WHICH IS INVALID -
			: HW0=2ND CHAR, HW1=ABS CHN#
CRYE2B	EQ	402B	:INTERNAL HOST CHANNEL TIMEOUT. A CHANNEL
			:WITH TIMEOUT ENABLED HASNT RECEIVED DATA FOR 30 SEC
			:CRQ IS ZAPPED. R0 =  FUNCTION BYTE, ABSOLUTE CH #
			:SEE INTHST IN SWITCH FOR FUNCTION BYTE MEANINGS
CRYE2C	EQ	602C	:A NEW DOWNLINE LOAD CRQ HAS BEEN ESTABLISHED.
			:R0 = TARGET LINE #,  ABSOLUTE CH # TO HOST.
CRYE2D	EQ	602D	:DOWNLINE LOAD LINE CRQ ZAP.  R0=LINE NUMBER,REASON.
			:REASON : 0=> ZAPPER, 1=> LINE # TOO BIG, 2=> LINE
			:ATTACHED, 3 => LINE ALREADY IN USE FOR DWL
CRYE2E	EQ	002E	:OUT OF INTERNAL HOST LOAD PORTS
CRYE2F	EQ	0C02F	:ISIS HOST OUT OF PORTS
CRYE30	EQ	0C030	:SYNC SCAN ERROR.  R0 - LN*2, SEGB OFFSET
CRYE31	EQ	0031	:DETDGN CALLING ERROR - R0 MEANINGLESS
CRYE32	EQ	0C032	:SIO BUFFER COUNT ERROR. R0 - LN*2, COUNT
CRYE33	EQ	0C033	:M-BOARD TIMEOUT. R0 - LN, SVC INDEX.
			:INDEX : 2 = CONNECT SVC, 3 = INPUT SVC, 4 = OUTPUT
			: 5 = STATUS SVC
CRYE34	EQ	0C034	:CIRCUIT BUILDING ERRORS. HW0=LEP ERRS, HW1=CRQ ERRS
CRYE35	EQ	0C035	:CIRCUIT COUNTING INCONSISTENCY. R0 HAS NUMBER
			: OF OCCURRENCES, MAGNITUDE OF INCONSISTENCY.
CRYE36	EQ	5036	:LINK OVERLOADED - R0 HAS COUNT, HW3 HAS NGHBR	###OAS
CRYE37	EQ	5037	:LINK SATURATED - R0 HAS COUNT, HW3 HAS NGHBR	###OAS
CRYE38	EQ	1038	:LINK ERROR - ILC BUF ZERO. HW3=NGHBR
CRYE39	EQ	5039	:LINK SNIP DUE TO LINK ERROR. HW3 HAS NEIGHBOR NUMBER
CRYE3A	EQ	003A	:SIO RING CONNECT SUCCESSFUL
CRYE3B	EQ	403B	:SIO CARD RING INTERRUPT  HW1=STATUS
CRYE3C	EQ	003C	:SIO ring went down
CRYE3D	EQ	403D	:Supervisor gone to sleep
CRYE3E	EQ	003E	:Supervisor's communicating again
CRYE3F	EQ	603F	:Gateway Host Unacceptable
CRYE40	EQ	0F040	:TOTAL PACKETS REC'D/SENT
CRYE41	EQ	7041	:BAD BORI
CRYE42	EQ	7042	:BAD ACK
CRYE43	EQ	7043	:BAD REC NO.
CRYE44	EQ	7044	:BAD CHECKSUM
CRYE45	EQ	7045	:RETRANSMISSIONS REC'D
CRYE46	EQ	7046	:RETRANSMISSIONS SENT
CRYE47	EQ	7047	:4 SEC GAPS
CRYE48	EQ	7048	:CROSS-TALK
CRYE49	EQ	7049	:SPACING ON INPUT
CRYE4A	EQ	704A	:HDLC CHECKSUM ERRORS
CRYE4B	EQ	704B	:HDLC ABORTS
CRYE4C	EQ	404C	: Link's rejected due to bad guy  list NSR#4950
CRYE4D	EQ	704D	:LINK OUT ZAP COUNT. HW1=CNT, HW2=KN, HW3=NGHBR
CRYE4E	EQ	704E	:CMD CT ZAP COUNT. HW1=CNT, HW2=KN, HW3=NGHBR
CRYE4F	EQ	404f	:KIO did not send a zap ack to a zapper
CRYE50	EQ	4050	:BAD INTERNAL HOST FUNCTION
CRYE51	EQ	1051	:LINK FROZEN. HW3=NEIGHBOR
CRYE52	EQ	1052	:LINK THAWED. HW3=NEIGHBOR
CRYE53	EQ	0D053	:BAD SIO RECORD LENGTH - HW0=LN, HW1=NEIGHBOR#, HW3=cnt
CRYE54	EQ	0F054	:XRAY AUDIT. HW1=COMMAND, HW2,3,4=USERNAME
CRYE55	EQ	7055	:SIO LINE with SW CKSM ERRORS- CNT= HW1 
			:HW2=LINE#, HW3=NEIGHBOR#
CRYE56	EQ	0B056	:KIO Connect failed due to PORT in USE
CRYE57	EQ	0F057	:owner of the KIO port in use
CRYE58	EQ	0C058	:SLOT REPORT LIMIT EXCEEDED
CRYE59	EQ	0	:unused
CRYE5A	EQ	505A	:SLOT/HOST CIRCUIT LIMIT EXCEEDED - HW1=SLOT, HW3=HOST#
CRYE5B	EQ	505B	:INVALID HOST FOR RESTRICTED NODE
CRYE5C	EQ	505C	:INVALID 03-PAIR ON T-I CMD CIRCUIT
CRYE5D	EQ	0	:unused
CRYE5E	EQ	405E	:INVALID 03-PAIR ON OUR COMMAND CIRCUIT
CRYE5F	EQ	505F	:CHANNEL IN USE - HW1=REL CHAN, HW3=NEIGHBOR
CRYE60	EQ	7060	:BUFFER ZAP - HW0=COUNT, HW1=CHAN, HW3=BUFFER
CRYE61	EQ	5061	:NEEDLE REJECTED BY SLOT - HW1= # PORTS, HW3=HOST
CRYE62	EQ	5062	:IMPOSTER HOST - HW1= SLOTS, HW3=HOST
CRYE63	EQ	0C063	:SQA ERROR - HW0=DIF, HW1=TERM CHAN
CRYE64	EQ	1064	:KERNEL PORT ZAP FAILED.
CRYE65	EQ	0F365	:RTDSQA - TERM PORT, NET PORT, SQA
CRYE66	EQ	0F366	:RECEIVED A SQACK
CRYE67	EQ	0F367	:CRQREB -  FIRST CHAR IN SEQ#, EXPECTED SEQN
CRYE68	EQ	3068	:NO P/T SPACE
CRYE69	EQ	3069	:NO L/D FOR NEW LINE
CRYE6A	EQ	736A	:GENERAL CIRCUIT STATUS - CHAN, HSEQN
CRYE6B	EQ	436B	:REBUILD DISABLED - CHAN
CRYE6C	EQ	406C	:EARLY REBUILD NEEDLE - CHAN
CRYE6D	EQ	0C06D	:INTERCEPT ABANDONED DUE TO STUB TIMEOUT
CRYE6E	EQ	0F36E	:CIRCUIT STATUS - VSEQN, XSEQN
CRYE6F	EQ	736F	:SQF SENT - CHAN, XSEQN
CRYE70	EQ	3070	:SIO ERROR MBOARD RC=4 HW2=LN#, HW3=NEIGHBOR
CRYE71	EQ	0F071	:WILD-CARD MESSAGE
CRYE72	EQ	4072	:SIO PORT UNAVAILABLE HW1 = LN#
CRYE73	EQ	4073	:BAD ZAP REASON FROM ISIS, HW1 = REASON
CRYE74	EQ	0C074	:TAKEOVER RESP #LNK NOT MATCH #NBR,HW0=#LNK,HW1=#NBR
CRYE75	EQ	0C075	:NETID MISMATCH - HW0=LINE, HW1=NETID
CRYE76	EQ	0C076	:WSIZ MATCH DOWN - HW0=LINE, HW1=WSIZ
CRYE77	EQ	0C077	:XRAYS NETID MOD - HW0=LINE, HW1=NETID
CRYE78	EQ	0C078	: SIO RING CONNECT FAILED (SPLIT SUP)
			:  HW0=Ring Logical Unit
			:  HW1=reason
			:   1 => bad logical unit number
			:   2 => no shared memory segment selected
			:   3 => segment select error, for a segment
			:        already in use (e.g. seg E, F)
			:  84 => Ring addr mismatch
			:  85 => Input ring size mismatch
			:  86 => Output ring size mismatch

CRYE7B	EQ	407B	:SIO INIT SOFTWARE TIMEOUT - HW1=LINE		###wjl

::*********************************************************************
::
::	LINK SNIP REASONS FOR XRAY, NODE REPORTS
::
::*********************************************************************

LS.SCP	EQ	01	:SPLIT CHARACTER PAIR - 00 OR 01
LS.I3P	EQ	02	:INVALID 03 CHARACTER PAIR
LS.S3P	EQ	03	:SPLIT 03 CHARACTER PAIR
LS.BPC	EQ	04	:BAD CHANNEL NUMBER DETECTED IN BACKPRESSURE REC
LS.COR	EQ	05	:CHANNEL NUMBER OUT OF RANGE (more than 1 page)
LS.ILC	EQ	06	:ILC PERMUTER TABLE ENTRY ZERO FOR T-II NEIGHBOR
LS.BPV	EQ	07	:BPMV PERMUTER TABLE ENTRY 0 FOR T-I NEIGHBOR
LS.UCR	EQ	08	:UNRECOGNIZED CONTROL RECORD RECEIVED
LS.SNC	EQ	09	:SHRINK FROM NEIGHBOR, NO CHANNELS TO SHRINK
LS.MCE	EQ	0A	:MICROCODE CLOBBERED R12 (PRD)

LS.ARC	EQ	10	:ARRAYAND ERROR, BOTH BITS NOT SET
LS.ACR	EQ	11	:ARRAYAND ERROR, CHANNEL OUT OF RANGE
LS.ZPT	EQ	12	:ZERO PERMUTER TABLE ENTRY FOR ACTIVE CHANNEL
LS.BPZ	EQ	13	:BPSCNT ZERO
LS.EBF	EQ	14	:EMPTY BUFFER BUT BUFFER FLAG SET
LS.ZLR	EQ	15	:ATTEMPT TO BUILD ZERO-LENGTH RECORD
LS.MAC	EQ	16	:RECOVERY FROM MAC INTERRUPT IN RMAKE OR RTEAR
LS.OOB	EQ	17	:out of buffers					###wjl
ls.zpv	eq	18	:tymnet-I zap ack (ILC)
ls.bpa	eq	19	:apply bp msg with chn out of range
ls.bpr	eq	20	:release bp with chn out of range
ls.pr2	eq	21	:unexpect apply bp msg
ls.pr3	eq	22	:unexpect release bp msg
ls.BOD	eq	23	:chn number out of range (a bubble and not a needle)
LS.IL2	EQ	24	:ILC msg out of range


	SUBTTL	DATA (Table structure variables)

:	CRASH TABLE STRUCTURES

Q	EQ	.		:HERE WE ARE

::*********************************************************************
::
::	CRASH SUMMARY TABLES:
::
::*********************************************************************

	ORG	0
CS.CNT	HS	1		:CRASH COUNT
CS.CID	HS	1		:CRASH ID
CS.PSD	HS	4		:CRASH PSD
CS.TIM	HS	2		:GMT OF CRASH
CS.SIZ	EQ	.		:SIZE OF SUMMARY ENTRY

::*********************************************************************
::
::	CRASH DETAIL TABLES:
::
::*********************************************************************

	ORG 	0
CD.CNT	HS	1		:CRASH COUNT
CD.CID	HS	1		:CRASH ID
CD.PSD	HS	4		:CRASH PSD
CD.TIM	HS	2		:CRASH TIME (GMT)
CD.RSF	HS	20		:R-SET F REGISTERS
CD.SLT	HS	1		:NOT USED (USED BY ISIS)
CD.SIZ	EQ	.		:SIZE OF DETAIL TABLE
CS.NEN	EQ	10		:NUMBER OF ENTRIES IN SUMMARY TABLE
CSMTBS	EQ	CS.SIZ*10	:SIZE OF SUMMARY TABLE AREA
CDTTBS	EQ	CD.SIZ*2

::*********************************************************************
::
::	CRYPTO MESSAGE FORMAT:
::
::*********************************************************************

	ORG	0
CRYGMT	WS	1
CRYFAS	HS	1
CRYFLG	BS	1
CRYTYP	BS	1
CRYHW0	HS	1
CRYHW1	HS	1
CRYHW2	HS	1
CRYHW3	HS	1

::*********************************************************************
::
::	AUDIT LOG MESSAGE FORMAT:
::
::*********************************************************************

	ORG	0
AUDGMT	WS	1		:time of entry
AUDBLK	HS	1		:xray user block of the entry
AUDCMD	HS	1		:the cmd that was attempted

::*********************************************************************
::
::	PERFORMANCE LOG MESSAGE FORMAT:
::
::*********************************************************************

	ORG	0
PL.GMT	WS	1		:time of entry
PL.EXE	HS	1		:exec count
pl.lc	bs	5		:in & out logical chars (20 bits for each)
pl.pc	bs	5		:in & out physical chars (20 bits for each)
pl.del	bs	3		:hw & sw delays (12 bits for each)
pl.prt	bs	5		:ports, pthrus, cmdcts (12,13,13 bits each)
pl.siz	hs	0

::*********************************************************************
::
::	PERFORMANCE temp holding FORMAT:  All in words to make compares
::		faster.
::
::*********************************************************************

	ORG	0
PT.GMT	WS	1		:time of entry
PT.EXE	WS	1		:exec count
pt.lco	WS	1		:logical chars out
pt.lci	WS	1		:logical chars in
pt.pco	WS	1		:physical chars out
pt.pci	WS	1		:physical chars in
pt.hwd	ws	1		:hardware delay
pt.swd	ws	1		:software delay
pt.prt	ws	1		:ports
pt.pth	ws	1		:passthroughs
pt.cmd	ws	1		:cmd circuits
pt.siz	hs	0

::******************************************************************
::
::	SIO TRANSMIT BLOCK LAYOUT:	###JOK
::	(See also SIORIZ, where this layout is used)
::
::******************************************************************

	IF	SILINS
	ORG	0
SB.CMD	HS	1			: CCW Command field
SB.DQA	HS	1			: CCW Data Quad-word Address
SB.CD2	HS	1			: Second CCW Command field
	HS	1			: init'ed to Quad-word addr of next CCW
SB.OBA	HS	1			: Output Buffer Address (Absolute)
SB.QBA	HS	1			: Quad-word Output Buffer Address
	BND	10			: extra padding to fill out to Quad-wrd
SB.SIZ	WS	0			: how big the entry is
	EI	:SILINS

::*********************************************************************
::
::	SIO STATUS BLOCK LAYOUT TABLE:		###wjl
::	Index into SIOSTT, three halfwords for engine, four halfwords
::	for HDLC micro	(See LDRPRT and XSIOST for usuage)
::
::*********************************************************************

	IF	SILINS
	ORG	0
SS.REG	HS	1	:read REG 0 on the SIO chip	(bits 0 - 7)
			:read REG 1 on the SIO chip	(bits 8 -15)
SS.IDL	BS	1	:idle line counter		(bits 16-23)
SS.CRC	BS	1	:CRC error counter		(bits 24-31)
SS.ABR	HS	1	:HDLC abort counter		(bits 32-43)
			:				(bits 44-47)
SS.HM1	BS	1	:HDLC MICRO-engine receive overrun counter
SS.HM2	BS	1	:HDLC MICRO-engine (reserved)
	EI	:SILINS

::*********************************************************************
::
::	LINK DESCRIPTOR VARIABLES:
::
::*********************************************************************

	ORG	0
NDID	HS	1		:NODE NUMBER
SIOROR  BS	1		:pointer to line on the sio rotation
BORI	BS	1		:RECEIVED B-O-R INDICATOR
NLAT	BS	1		:# OF LINES ATTACHED
WSIZ	BS	1		:WINDOW SIZE
KSPD	BS	1		:LINK SPEED
LKNM	BS	1		:LINK NUMBER
NCHN	HS	1		:NUMBER OF CHANNELS
ISEC	HS	1		:PTR TO START OF INPUT RING
NRTR	HS	1		:PTR TO NEXT RECORD TO TEAR
AMSK	HS	1		: MASK FOR ACK TRUNCATION
OSEC	HS	1		:DITTO OUTPUT
NRMK	HS	1		:PTR TO NEXT RECORD TO MAKE
suschn	hs	1		:count of suspended chns when link bubbled.
LRT	HS	1		: LAST RECORD TORN
LAS	HS	1		: LAST ACKNOWLEDGEMENT SENT
LRM	HS	1		:LAST RECORD MADE
LAR	HS	1		: LAST ACKNOWLEDGEMENT RECEIVED
NAS	HS	1		:NEXT ACKNOWLEDGEMENT TO BE SENT
ONDID	HS	1		:NODE NUMBER WHEN DOWN OR 0
IDLE	HS	1		: FLAG FOR IDLE OUTPUT
LNIDLE  hs	1		:<0 if link has a line sending stuff
KS.PQC	HS	2		:RUNNING COUNT OF PACKET QUEUEING TIMES
:	ISIS-INDEPENDENT DESCRIPTORS BEGIN HERE
RKEY	HS	2		:RESET KEY RECEIVED FROM NEIGHBOR FOR
				: MULTI-LINE ATTACHMENT VERIFICATION
SHSTAT	BS	1		:SHRINK STATE, VALUES AS FOLLOWS:
:	0	NO SHRINK ACTIVITY IN PROGRESS
:	1	RTD DETECTED SHRINK COMMAND FROM NEIGHBOR
:	2	MSHRINK FOUND MANY SPARE CHANNELS THIS LINK
:	3	RMAKE FROZEN WAITING FOR NEIGHBOR TO COMPLETE SHRINK

NEDSUS	BS	1		:NON-ZERO IF LINK SHRINK SUSPENDED DUE TO
				: NEEDLES OUTSTANDING
:	!! SHSTAT AND NEDSUS MUST BE IN SAME HALFWORD !!
:	SOME CODE DOES A LH OF SHSTAT TO TEST BOTH SHSTAT AND NEDSUS

NEDOUT	HS	1		:# OF NEEDLES OUTSTANDING BETWEEN CRQ AND RMAKE

ANCHN	HS	1		:NUMBER OF ACTIVE CHANNELS

KFROZN	HS	1		:INDICATE LINK'S NETWORK STATUS - 0 FOR UP,
				:-1 FOR FROZEN,LINK UP BUT REPORTED OUT TO SUP
PRICNT	HS	1			:COUNTER FOR PRIORITY CHANNEL LOGIC
RMKFLG  HS	1		:complete round robin for this link in rmk?
SIOROT  BS	nlines  	:list of lines on this link		###dmj
SIOBTT  hs	2		:time of last SIO retransmission	###dmj

:	THE FOLLOWING FIELDS EXIST TO RECORD LOAD STATISTICS FOR EACH LINK

KS.PCO	HS	2		:RUNNING COUNT OF PACKET CHARACTERS OUTPUT
KS.PMO	HS	2		:LAST MINUTE, COUNT OF PACKET CHARACTERS OUTPUT
KS.PHO	HS	2		:HI-WATER MARK OF PACKET CHARACTERS OUTPUT
ks.otp	hs	2		:time of high-water

KS.PCI	HS	2		:RUNNING COUNT OF PACKET CHARACTERS INPUT
KS.PMI	HS	2		:LAST MINUTE'S COUNT OF PACKET CHARACTERS INPUT
KS.PHI	HS	2		:HI-WATER MARK OF PACKET CHARACTERS INPUT
ks.itp	hs	2		:time of high-water

KS.LCO	HS	2		:RUNNING COUNT OF LOGICAL CHARACTERS OUTPUT
KS.LMO	HS	2		:LAST MINUTE, COUNT OF LOG CHARACTERS OUTPUT
KS.LHO	HS	2		:HI-WATER MARK OF LOGICAL CHARACTERS OUTPUT
ks.otl	hs	2		:time of high-water

KS.LCI	HS	2		:RUNNING COUNT OF LOGICAL CHARACTERS INPUT
KS.LMI	HS	2		:LAST MINUTE, COUNT OF LOGICAL CHARACTERS INPUT
KS.LHI	HS	2		:HI-WATER MARK OF LOGICAL CHARACTERS INPUT
ks.itl	hs	2		:time of high-water

KS.NPC	HS	2		:RUNNING COUNT OF TIMES NO PACKET MADE IN RMAKE
KS.NPM	HS	2		:SAVE AREA FOR KS.NPC

KS.RRC	HS	2		:COUNT FOR NUMBER OF ROUND ROBINS
KS.RRT	HS	1		:AVERAGE TIME PER ROUND ROBIN IN FASTC

KS.OVL	HS	1		:LAST MINUTE'S LINK OVERLOAD COUNT
KS.SAT	HS	1		:LAST MINUTE'S LINK SATURATED COUNT

KS.BAK	HS	1		:RUNNING COUNT OF BACKLOGS
KS.BAM	HS	1		:SAVE AREA

KS.PKM	HS	1		:COUNT OF PACKETS MADE
KS.ASZ	HS	1		:AVERAGE PACKET SIZE

KS.LRM	HS	1		:RMK COUNT OF LOGICAL RECORDS PUT INTO PACKETS
KS.LRA	HS	1		:MTRFIC STORAGE FOR LOG REC/PACKET	###jhl

	IF	BFLTMR		:###JHL for buffer delay timer pairs
BDLACC	HS	1		:buffer delay accumulator
BDLCNT	HS	1		:buffer timer-pair counter
KS.BFD	HS	1		:last minute's acc'ed bfr delay
KS.BFC	HS	1		:last minute's count of bfr pairs
	EI	:BFLTMR		:###JHL

KS.SRC	HS	2		:CUMMULATIVE SUM, SYLVER-RTEAR DELAYS
KS.SRA	HS	1		:AVERAGE TIME BETWEEN SYLVER AND RTEAR

KS.AQU	HS	1		:AVERAGE QUEUEING DELAY, RMAKE TO SYLVEX

KS.XMT	HS	1		:AVERAGE PACKET TRANSMISSION TIME

KS.SEM	HS	1		:SEMAPHORE BETWEEN INTERRUPT-DRIVEN SYLVEX AND SIO
				:ROUTINES IN SYLVER. NEEDED ONLY ON SIO-SYNC LINKS
LRMSAV	HS	1		:SAVE AREA FOR LRM
LRTSAV	HS	1		:SAVE AREA FOR LRT

KSSZ	EQ	.-KS.PCO	:SIZE OF STATISTICS AREA
lkattr	hs	2		:received link attributes on this link
KVERNO	HS	1		:NEIGHBOR VERSION NUMBER (-1 IF UNKNOWN)
KNETID	HS	1		:Neighbor's NETID
KHOST0	HS	2		:Neighbor's Kernel Host Number
KLINE	BS	1		:Neighbor Line Number
kspdrr	bs	1		:the real link speed (not limited to 1f=MS)
kspdmt	bs	1		:the link speed index used for mtrfic
	if	prertr
nakrtr	hs	1		:packet probably needing a rtr
	ei	:prertr
:	Following is to be able to restore the windowsize each time the
:	link goes down.  Allow a windowsize matchdown use the full window
:	as soon as the neighbor's window is expanded.   		###sdw

ISECSV  HS	1		:Address of the break in ISEC chain
ISECS1  HS	1		:adrress of the broken piece in ISEC chain
OSECSV  HS	1		:Address of the break in the OSEC chain
OSECS1  HS	1		:Address of the broken piece in OSEC chain

KDPATC  HS	8		:give space for patches
	HS	0
KDSZ	EQ	.-NDID		:SIZE OF LINK DESCRIPTOR, NOT STRLNK


::*********************************************************************
::
::	RESET BUFFER DESCRIPTOR:
::
::*********************************************************************

	ORG	0
VRSTP	HS	1		:Received Reset Pattern
VNDID	HS	2		:Received Node Number
VVERNO	HS	1		:Received Version Number
VNETID	HS	1		:Received Network ID
VSUBNT	HS	1		:Received Subnet Number
VWSIZ	BS	1		:Received Link Window Size
VLINE	BS	1		:Received Line Number
VHOST0	HS	2		:Received Kernel Host Number
VRSRSN	BS	1		:Received Reset Reason
VKSPD	BS	1		:Received Link Capabilities
VKATTR	HS	2		:Received Link Attributes
VDIAL	HS	2		:Received Dial-Up Number
	HS	0
VSDSZ	EQ	.-VRSTP		:Size of Received Reset Buffer

XRSTP	HS	1		:Transmitted Reset Pattern
XNDID	HS	2		:Transmitted Node Number
XVERNO	HS	1		:Transmitted Version Number
XNETID	HS	1		:Transmitted Network ID
XSUBNT	HS	1		:Transmitted Subnet Number
XWSIZ	BS	1		:Transmitted Link Window Size
XLINE	BS	1		:Transmitted Line Number
XHOST0	HS	2		:Transmitted Kernel Host Number
XRSRSN	BS	1		:Transmitted Reset Reason
XKSPD	BS	1		:Transmitted Link Capabilities
XKATTR	HS	2		:Transmitted Link Attributes
XDIAL	HS	2		:Transmitted Dial-Up Number
XCKSUM	HS	2		:Transmitted Checksum
	HS	0
XSDSZ	EQ	.-XRSTP		:Size of Transmitted Reset Buffer
XSDCNT	EQ	((XSDSZ-1)/8)^8	:Reset Length Count Code for header 
TXRSHD	EQ	TTRSHD!XSDCNT	:T-II Expanded Reset Header for new link
TYRSHD	EQ	TSRSHD!XSDCNT	:T-II Expanded Reset Header for subsequent line
TZRSHD	EQ	TRRSHD!XSDCNT	:SCLP reset header			###wjl

RSCNT	HS	1		:RESET COUNT
RSTIM	HS	1		:HOLDS TIMEOUT DURING RESET PROCEDURE
	HS	0
SDBSZ	EQ	.-VRSTP		:SIZE OF RESET DESCRIPTOR

::*********************************************************************
::
::	RECORD DESCRIPTOR:
::
::*********************************************************************

	ORG	0
RECN	HS	1		: RECORD NUMBER
RLNK	HS	1		: PTR TO NEXT RECORD IN BUFFER
ERECsz	hs	1		: length of record in buffer
BREC	hs	2		: PTR TO BEGINNING OF DATA (VERT CHKSM)
pkttim	hs	1		: delay time for output
intime	eq	pkttim		: Delay time for input (record can't be both)
LLXM	hs	1		: LINE LAST TRANSMITTED BY (DEV NUM)
	HS	0		:make sure CDSZ is not odd 		###cwc
CDSZ	EQ	.-RECN		:SIZE OF RECORD DESCRIPTORS


::*********************************************************************
::
::	DEFINE FORMAT OF XRAY GOODGUY LIST
::
::*********************************************************************

	ORG	0
XGGPRV	BS	1		:USER'S PRIVILEGE CAPABILITY
XGGOVR	BS	1		:USER'S OVERRIDE CAPABILITY
XGGTAR	HS	2		:user's TARGET dispatch address		###wjl
XGGNAM	HS	6		:USER NAME (UP TO 12 CHARS)
XGGSIZ	HS	0		:GOODGUY ENTRY SIZE

::*********************************************************************
::
::	DEFINE FORMAT OF XRAY USER BLOCK
::
::*********************************************************************

XBFSZE	EQ	10

	ORG	0
XUNAME	HS	1		:INDEX TO USER IN GOODGUY LIST	###OAS
XULGTM	WS	1		:LOG IN TIME
XUSLTN	HS	1		:XRAY USER SLOT NUMBER
XUINTH	HS	1		:XRAY USER INTERNAL HOST CHANNEL
XPOWER	HS	1		:XRAY USER POWER
XRYBFO	HS	1		:OUTPUT BUFFER NO.
XRYPTF	HS	1		:FILL POINTER
XRYPTE	HS	1		:EMPTY POINTER
CRYMOD	HS	1		:AUTO CRYPTO DISPLAY MODE
EKOTYP	HS	1		:CHARACTER ECHO MODE
xcmdip	hs	1		:pointer to the cmd table entry for the cmd
				: currently being executed (or last executed)
xnumsp	hs	2		:which typspace routine should be called
xsform	bs	1		:if doing short format commands
xslast	bs	1		:what was the last char output
XRYADR	WS	1		:SCHEDUING ADDRESS
XHDSAV	WS	1		:LINK SAVE AREA
XRSAVE	WS	6
DPRSAV	WS	1
XREGSV	WS	10		:REGISTER SAVE AREA
argmin	bs	1		:min number of args (must be adjacent to max)
ARGMAX	BS	1		:max number of args
ARGCT	HS	1
argpos	hs	1		:first byte pos, 2nd byte pos of end of line
VALUE1	WS	10*2	    	:16d args allowed and 128 bytes of space
				:for rdarg buffering
:	crymsk and trmask use smae memory as both are used only within
:	the display routine and are reinitialized upon entry
CRYMSK	WS	8		:which crypto msgs not to display
:trmask	ws	4		:bit position (by position in msg) as to 
trmask	eq	crymsk		:whether TD/TE/TA can display this byte
xupatc	hs	4		:sport for putting patches
CRYPPU	HS	1		:CRYPTO PRIO. BUF OUT PTR	###AL
CRYPTU	HS	1
XKNSAV	HS	1
       if	supwat
xdjsav	hs	1		:for monitoring the sup port
xdjsat	hs	1		:flag for display data 
       ei	:supwat
:::
XKDSAV	WS	1
XPRTTP	WS	1
XRYBFI	BS	XBFSZE		:INPUT BRACELET
	HS	0
XNDSAV	HS	1		:NODE # SAVE AREA FOR ND COMMAND###SHM
XUBSZ	EQ	.-XUNAME	:SIZE OF XRAY USER BLOCK

::*********************************************************************
::
::	DELAY-TABLE LAYOUT:	###JK
::
::*********************************************************************

	ORG	0
DLSTAT	HS	1		:STATUS OF DELAY MEASUREMENT PROCESS
DLYFLG	HS	1		:PRIORITY SELECT FOR TEST CHANNEL
DLYFIL	HS	1		:NUMBER OF FILL HW PER TEST PACKET
DLYPTF	HS	1		:FILL POINTER TO DLYTBL
DLYAV1	HS	1		:RUNNING AVERAGE OF SAMPLES
DLYAV2	HS	1		:RUNNING AVERAGE OF AVERAGES.
NODLST	HS	10		:NODE LIST FOR THIS PATH		###wjl
NODCNT	HS	1		:2 X NUMBER OF ONE WAY NODES IN THIS TEST PATH
DLYTSL	EQ	5		:LOG OF TABLE SIZE
DLYTSZ	EQ	40		:2 * DLYTBL SIZE
DLYTBL	HS	DLYTSZ/2	:32h DATA VALUES
DLYBSZ	HS	0		:TOTAL DELAY MEASUREMENT AREA

	ORG	Q		:RESTORE PC


::************************************************************
::
::	X4TBBG	is a table containing info on all X.409 elements that
::		were parsed while the parser was looking for some element
::
::************************************************************


Q	EQ	.
	ORG	0
X4T.AP  BS	1		:application/constructor bits
X4T.ID  BS	1		:ID of this element
X4T.LN  HS	1		:length :this first three must be inthis order
X4T.DI  HS	1		:distance from start to ID
X4T.DD  HS	1		:distance from start to data field
X4T.BB  WS	1		:address within buf of start of element
X4T.LB  WS	1		:address within buf of len field
X4T.DB  WS	1		:address within buf of data field
X4T.EB  WS	1		:address within buf of end of element
X4TBSZ  HS	0		:table size (HW boundary)
	ORG	Q


::*****************************************************************
:
:	Define structure of create X.409 element table.
:
::*****************************************************************

	IF	LOGII
Q	EQ	.
	ORG	0
X4CDTA  WS	1		:a word for either address of data or data
X4CLEN  HS	1		:halfword for len of this element
X4CFLG  BS	1		:save info on data and if constructor
X4CHLN  BS	1		:sum of len of len and len of id
X4CID   HS	1		:the ID and application bits
X4CTSZ  HS	0		:size of table
	ORG	Q		:restore old PC
	EI	:LOGII


	SUBTTL	DATA (Low Core SEG 0 variables)

:	Memory Layout Summary
:
:
:	SEGMENT	Usage			Remarks
:	   0	Node code Data		RX1 addressible (+ catch-all for junk)
:	   1	Node code Code		RX2 addressible (most of the time)
:	   2-0C	Data then bufferlets	No segmentation restrictions
:	  0D	XRAY execute & data	(execute only)
:	  0E	CTA Table		(ISIS)
:	  0F	SEGF			(ISIS)
:
:
:	THIS AREA RESERVED FOR DATA AREAS WHICH MUST BE ASSEMBLED
:	LOW IN SEG 0 FOR RX1 INDEXING.

::*********************************************************************
::
::	EXEC VARIABLES:
::
::*********************************************************************

	SEG.(0)				:DATA SEGMENT 0 BEGINS HERE
	ORG	0
SEG0	HS	0

:	***NOTE: FIRST 10x BYTES ARE UNUSED***

	ORG	10			:REQUIRED FOR MICROCODE TRACE INTERRUPT
TRPSW	WS	2			:OLD PSW FOR TRACE ROUTINE
	WS	1			:POINTER TO TRACE ROUTINE

:	NODE DESCRIPTOR:

NODEID	HS	1			:NODE NUMBER
VERSID	HS	1			:VERSION NUMBER
CRHCNT	HS	1			:CRASH COUNT
CRSHID	HS	1			:CRASH ID #
	SYAD(CRSHID)
CRSHPS	WS	1			:CRASH PSW
CRSHAD	WS	1			:CRASH ADDRESS
	SYAD(CRSHAD)
CRSHTM	WS	1			:GMT OF LAST CRASH
ERRREG	WS	10			:CRASH REGISTERS
CRYPPI	HS	1			:Pointer into regular crypto buffer
CRYPRI	HS	1			:Pointer into priority crypto buffer

CRTYPE	HS	1			:CRASH TYPE (<0 =HRDWR, >=0 =SFTWR)##TZ

CRASHX	WS	1			:CRASH ADDRESS FOR XRAY 'ND' COMMAND

TRRIX	HS	1			:INDEX FOR TRRING,
	SYAD(TRRIX )			:CHARACTER TRACE BY CHANNEL

XFIRST	WS	1			:FIRST TIME (GMT) NODE WAS TAKEN OVER

ABRSAV	WS	10			:REGISTER SAVE AREA FOR SOFT MAC CRASH
	SYAD(ABRSAV)
REBNEB	HS	1			:TEMPORARY,DELETE WHEN REBILD TEST OVER
CSMCNT	HC	0			:# OF SUMMARY TABLE ENTRIES MADE###GT
CDTPTR	HS	1			:OFFSET TO NEXT DETAIL TABLE ENTRY
CDTCNT	HS	1			:COUNT OF CRASH DETAIL ENTRIES
       if	audsiz
AUDPTR	hs	1			:pointer into audit log
       ei	:audsiz
       if	pl.num
pl.ptr	hs	1			:pointer into performance log
       ei	:pl.num

ERREG0	WS	10			:CRASH SAVE AREA FOR REG SET 0
	IF	DB.DEB
CRHSAV	HS	2
	EI	:DB.DEB
NXTCRP	HS	1			:OFFSET INTO CRASH SUMMARY TABLE FOR
					:NEXT CRASH TO REPORT TO SUPERVISOR

	IF	T2GATE
::	Gateway to Dispatcher port Zero Message templates
hcosth	hs	1		:host cost to Hnet
GAVPTS	HC	NDP		:gateway available ports,init by NDP##al
MG148F	BC	0		:TO HNET SUP MSG 148F SENT FLAG##AL
G0DFG	BC	0		:NO SUP 0D MSG FLAG
: Type 03,0A,0C,10 messages
GDZ03M	HC	00	:5 bytes message report to port 0 (msg 03)
	BC	03,00
	AC	/GW/	:DATA2 fld put an identifier, may change later
DZ03NR	HC	00	:Node Report parameter (msg subtype & DATA1)
DZ03LK	BC	8B	:product ID for T2G2
GDZ03L	EQ	.-GDZ03M	:msg length

GDZ0AM	HC	00	:8 sec. check for port sts chang (msg 0A)
	BC	0A,00	:Message type and key
DZ0AHN	HC	IHOST	:host number
DZ0APT	HC	00	:ports available 
DZ0ARH	HC	00	:relative host number
GDZ0AL	EQ	.-GDZ0AM	:msg length

GDZ0CM	HC	00	:hst cost configuratn (msg 0C)
	BC	0C,00	:Message type and key
DZ0CHN	HC	IHOST	:host number
hcosti	HC	INCOST	:host cost to inet
DZ0CRH	HC	00	:relative host number
GDZ0CL	EQ	.-GDZ0CM

GDZ10M	HC	00	:report hst sts (msg 10)
	BC	10,00	:Message type and key
DZ10HN	HC	IHOST	:host number
DZ10PT	HC	00	:ports available 
DZ10RH	HC	00	:relative host number
DZ10ST	BC	0	:host status
GKEY	BC	0	:host key
GHIQ	BC	80	:host IQ,I bit set
GPID	BC	8B	:product ID code
GDZ10L	EQ	.-GDZ10M	:Length of mesage in Bytes

::Other control message tables for Gateway dispatcher
GDB7M	HS	0
GB7PRT	HC	00	:INsert Dispatchr port number
	BC	0B7,00	:Type B7 message
GB7INV	BC	0E0,00	:Addendum to accounting 
	BC	00	:use for invoice exchange or ....
GB7REA	BC	00	:Insert reason for disconnect
GDB7L	EQ	.-GDB7M	:Length of message

GD9FM	HS	0
	HC	00
	BC	9F	:Zapper
GD9FL	EQ	.-GD9FM

GDM07M	HC	00		:Port zero message
	BC	07		:Type 07 (Pseudo Needle Request)
GSLKEY	BC	00		:Key  (slot# * 4)
GLOKEY	HC	00		:Local Key (for Gateway is buffer #)
GIXELF	HC	00		:IIX and ELS field
	HC	IHOST		:always IHOST is circuit origin to INET
GHINID	BC	00		:TID (CCT) from HNET to INET
GDM07L	EQ	.-GDM07M	:Message length

::	IRC (International Record Carrier) report for T2GATE	###AL
Q	EQ	0
	RE	NLINKS		:LINK NUMBERS ASSIGNED
	IF	\IRC|Q|
IRC	EQ	1		:IRC VALUE DEFINED
	ELSE	:IRC|Q| NOT DEFINED
IRC|Q|	EQ	0
	EI	:IRC|Q|
Q	EQ	Q+1
	ER

	IF	IRC
IRCTBL	HS	0
Q	EQ	0
	RE	NLINKS		:LINK NUMBERS ASSIGNED
	BC	IRC|Q|
Q	EQ	Q+1
	ER
	EI	:IRC
	EI	:T2GATE		:not to be zeroed during init

RSEG0	HS	0			:**SEGMENT 0 WRITTEN OUT TO HERE**

:*******FROM HERE TO CLSEG0 (BELOW) FOR CRASH TABLE STUFF ONLY*******

:	COMMON CRASH TABLE AREAS

:	COMMON CRASH TABLE HEADER

CRSHDR	WS	0		:LOADII crash dump option expects FW bndry##wjl
NODENU	HS	1		:NODE NUMBER
NODETY	HS	1		:MACHINE TYPE
TABVER	HS	1		:COMMON CRASH TABLE VERSION
CODVER	HS	1		:CODE VERSION
TAKETI	HS	2		:GMT OF FIRST TAKEOVER
CRCNT	HS	1		:CURRENT CRASH COUNT

CSMTBL	BS	CSMTBS		:CRASH SUMMARY TABLE AREA (16d OF THEM)
CDTTBL	BS	CDTTBS		:CRASH DETAIL TABLE AREA (2 OF THEM)
:*******FROM RSEG0 (ABOVE) TO HERE FOR CRASH TABLE STUFF ONLY*******

CLSEG0	HS	0		:SEG0 CLEARED FROM HERE

SQNSAV	HS	1		:SEQUENCE NUMBER SAVE AREA
BUFSAV	HS	1		:BUFFER INDEX SAVE AREA

R1RBFT  WS	1		:return bufferlets routine
R0RBFT  WS	1		:return bufferlets routine
R4RBFT  WS	1		:return bufferlets routine

PROCID	HS	1		:CURRENT PROCESS NUMBER
SAVEKN	WS	1		:Save kn / r11 in zap routine
::
ALINES	BS	LNSIZE		:ACTIVE LINES
ALINKS	BS	LKSIZE		:ACTIVE LINKS
NALNKA	WS	1		:STORAGE FOR BE ADDR. FOR NALINK FLD.	###AL
TEMPHS	HS	1		:TEMPORARY STORAGE FOR A HW		###AL
MXLINK	HS	1		:MAXIMUM NUMBER OF ACTIVE LINKS
NALINK	HS	1		:# OF ACTIVE LINKS
MXPASS	HS	1		:MAXIMUM NUMBER OF PASSTHRU CIRCUITS
PASTHR	HS	1		:# OF PASSTHRU CIRCUITS
pasthc	hs	1		:whether # of passthru circuits has changed 
				:since last report (any builds or zaps)
nbrcmd  hs	1		:# of passthru that are cmd circuits
PTHRPD	HS	1		:# of passthrus reported as available	###wjl
TERMIN	HS	1		:# OF CIRCUIT TERMINATIONS
MXPORT	HS	1		:PEAK ACTIVE KERNEL OR ISIS PORTS
CREPRT	HS	1		:CRASH REPORT INDICATOR, -1 IF REPORT SENT
CONSOL	WS	2		:CURRENT CONSOLE OUTPUT

:	OTHER VARIABLES:

:	SCHEDULER CLOCKS AND QUEUE:

SQUEUE	WS	1		:PROCESS QUEUE

SCHTAB	WS	0		:SCHEDULER TABLE

T08MIN	WS	1		:SCHEDULE TABLE LABELS
T04MIN	WS	1
T02MIN	WS	1
T01MIN	WS	1

T30SEC	WS	1
T16SEC	WS	1
T08SEC	WS	1
T04SEC	WS	1

T02SEC	WS	1
T01SEC	WS	1
T500MS	WS	1
T250MS	WS	1

T125MS	WS	1
T064MS	WS	1
T032MS	WS	1
T016MS	WS	1

QEXEC	WS	20		:PROCESS P-COUNTERS
SQLAST	WS	1		:FOR SAVING LAST RUN QUEUE

PROTIM	WS	20		:FASTC TIME THAT PROCESS LAST RAN
PROHWM	WS	20		:HIGH-WATER MARK FOR EACH PROCESS'S EXECUTION
				: TIME (IN FASTC UNITS)
PROCNT	WS	20		:COUNT OF PROCESS EXECUTION OCCURRENCES
PACTIM	WS	20		:ACCUMULATOR FOR TIME SPENT IN A PROCESS
PSVTIM	HS	20		:SAVE AREA FOR PACTIM, SAVED IN 1-MIN LOGIC

EXLAVG	HS	1		:AVG EXEC LOOP ITERATIONS/SEC OVER LAST MINUTE
EXLALW	HS	1		:LOW-WATER AVG EXEC LOOPS/SECOND
EXLAHW	HS	1		:HIGH-WATER AVG EXEC LOOPS/SECOND
EXDHWM	HS	1		:DISMISS HIGH-WATER MARK (FASTC UNITS)
EXEHWM	HS	1		:EXEC LOOP HIGH-WATER MARK (FASTC UNITS)
SYLHWM	HS	1		:SYLVER INTERVAL HIGH-WATER MARK (FASTC UNITS)
NEDHWM	HS	1		:NEEDLE TRANSIT TIME HI-WATER MARK(FASTC UNITS)
	SYAD(NEDHWM)
NEDCNT	HS	1		:NUMBER OF NEEDLES THROUGH NODE
RMKRMS	HS	2		:NUMBER OF RMK CALLS LAST MINUTE AND
RMKNRS	HS	2		: NUMBER OF TIMES NO RECORD MADE
rmklrs	HS	2		: number of logical records made
rtdlrr	HS	2		: number of logical records torn (running)
rtdlrs	HS	2		: number of logical records torn (last min)
rtdpks	HS	2		: number of packets torn (last min)

EXTIME	HS	2		:TIME OF ENTRY/EXIT FOR EXEC LOOP
EXLCNT	HS	2		:EXEC LOOP COUNT (RESET EACH MINUTE)
EXLTLA	HS	2		:SLOWC TIME OF LAST AVERAGE COMPUTATION
DISSAV	HS	2		:SAVE RETURN FOR FAST DISMISS

DUESCH	WS	1		:SEE EXEC
syvsch	WS	1		:when syvler is to run again
s16min	hs	1		:when to run 16 minute stuff (cnboot)
EISECC	HS	1		:INC'D EVERY 1/8 SEC IF ISIS

GOVSWI  HS	1		:limit switch to 40 times a second

      if	pl.num		:performance log
pl.tim	hs	1		:counting down to actually save it away
pl.cnt	hs	1		:how many entries saved
pl.ave	bs	pt.siz		:the running totals (to be averaged)
       if	pl.all		:all options to be saved
pl.tsz	eq	pt.siz*6	:min/max exec and max cps being remembered 
       else	:not pl.all
pl.tsz	eq	pt.siz*2	:min/max exec being remembered
       ei	:pl.all
pl.cur	bs	pl.tsz		:holding area of running values
      ei	:pl.num

CRYSAV	WS	10		:REG SAVE FOR CRYPTO
CRYSBF	WS	2		:CRYPTO MESSAGE BUFFER

HISTI	HS	1		:HISTORY BUFFER PTR

XLCRSH	WS	1		:TIME OF LAST CRASH FOR XRAY
CLKSAV	WS	1		:SAVE LOC FOR CLOCK TESTS

DLDFLG	HS	1		:for node request to go to boot

MTRTIM	WS	1		:TIME TO RUN NEXT 60 SECOND PERFORMANCE LOGIC
LDRTIM	HS	1		:SCHED LDRPRT EVERY 4 MTRFIC'S		###JHL
MININT	HS	1		:EXACT INTERVAL BETWEEN 1-MIN LOGIC EXECUTIONS
MINSAV	HS	1		:SAVE AREA USED IN COMPUTING MININT
S1SLOC	WS	1		:COUNTS OCCURRENCES OF 1-SECOND LOGIC.
				: DIFFERENCE BETWEEN 'S1SLOC' AND 'SLOWC'
				: INDICATES DRIFT IN 'G01SE1' SCHEDULING.

g125bp	hs	1		:for g125ms to know each 1/2 as well
glinkr	hs	1		:set nonzero if linker has somehting to do
RTDGOV  HS	1		:LIMIT RTD CALLS FROM SIO INPUT
rtdgvt  hs	2		:time to start governing
BFLTMX	WS	1		:14*(MAX NUMBER OF BUFFERLETS IN USE)
BFLTSV	WS	1		:RUNNING COUNT CELL FOR DETERMINING BFLTMX

	IF	REBILD
HBFTMX	WS	1		:14*(MAX NUMBER OF BUFFERLETS IN USE) HISTORY
HBFTSV	WS	1		:RUNNING COUNT CELL FOR DETERMINING HBFTMX
	EI 	:REBILD

::*********************************************************************
::
::	LINKER VARIABLES:
::
::*********************************************************************

KDLN	WS	NLINES		:LINK DESCRIPTOR POINTERS
	SYAD(KDLN  )
::
detsav	hs	2		:save for detlin
INHRST	BS	LNSIZE		:INHIBIT RESETS ON THESE LINES
INHRLS	BS	LNSIZE		:PREVIOUS STATE OF INHRST
LINATT	BS	LNSIZE		:LINES TO BE ATTACHED
LINDET	BS	LNSIZE		:LINES TO BE DETACHED
LINKAS	BS	LNSIZE		:TEMP STORAGE FOR LINKER
VRSTDL	BS	LNSIZE		:RESET DETECTED ON DETACHED LINES
:	please note that bori zap is now 0 to zap			###sdw
BORZAP	BS	LKSIZE		:0 TO CAUSE 'BORI ZAP'
NOSHRK	bs	LKSIZE		: 1 if neighbor does not want a shrink
       if	aplybp		:if doing active backpressure
XACTBP	bs	lksize		: 1 if sending active bp msgs
VACTBP	bs	lksize		: 1 if receiving active backpressure msgs
       ei	:aplybp
LNSUSC	BS	LNSIZE		:CURRENT COPY OF LINES SUSPENDED
LNSUSO	BS	LNSIZE		:OLD (1-MINUTE) COPY OF LINES SUSPENDED
OSRLIR  BS	LNSIZE  	:idle lines sending old style resets    ###sdw
OSRLIH  BS	LNSIZE  	:history of OSRLIR (only send OSR for a second)

SIORPC  BS	LNSIZE  	:Bits set in 1 sec logic to let SIORR send it
	if	chboot
cnbtgo	bs	lnsize		:lines to see if neighbor in boot
cnbtya	bs	lnsize		:1 if neighbor looks like it is in boot
cnbrsp	hs	lnsize		:1 if got a boot response to a recent send
	ei	:chboot
LINSPT	WS	1		:LINKER FLAGS LINES NEEDING LINE SPEED CALC
	SYAD(LINSPT)
LINSPD	WS	1		:1-SEC LOGIC FLAG LINES NEEDING LINE SPEED CALC

LNCHLR	WS	1		:LNCHCK LINK REG
IZLNLR	WS	1		:IZLNKR LINK REG
FREELR	WS	1		:HEAD OF FREE RECORD-BUFFER CHAIN

LNGREC	BS	LNSIZE		:GOOD RECORD RECEIVED ON LINE
LKGREC	BS	LKSIZE		:DITTO ON LINK
OLDKGR	BS	LKSIZE		:LAST 4 SECOND'S LKGREC
SIOBTR  BS	LKSIZE  	:last packet sent was retransmission    ###dmj

:	a whole bunch of stuff for the Line Tester
xltsiz	hs	nlines		:size of packet
xltact	bs	lnsize		:bit =1 if test is running on this line
xltcha	hs	1		:bit =1 if test is running on this int chn
xl2047	hs	2		:bit =1 if running 2047 on this int chn
xltchn	hs	nlines		:internal chn # that started this test	
xltlnm	hs	tintch		:line number under test for this int chn
xl204p	hs	nlines		:current seed for 2047 test pattern
xltcse	hs	nlines*2	:number of software checksum errors
xltrat	hs	nlines		:period between sending packets (in fastc)
xltdur	hs	nlines*2	:seconds to run the test (0 is forever)
xlttim	hs	nlines		:time (in fastc) to send next packet
xltent	hs	nlines*2	:time (in slowc) to end the test
xltpks	hs	nlines*2	:packets sent so far in this test
xltpkr	hs	nlines*2	:packets received so far in this test
	if	silins
xlthdl	hs	nlines		:number of sio hdlc checksum errors
xlthdo	hs	nlines		:prev ss.crc to calculate xlthdl
	ei	:silins

BGLSIZ  EQ	10
BGLIST	HS	BGLSIZ		:BAD GUY LIST (DO NOT TALK TO THEM)
MRESTZ	EQ	NLINKS/2+1
MRESET	HS	MRESTZ		:LIST OF LINES IN RESET STATE FOR WHICH
				: WE ARE MASTER
RSRSHD	HS	1		:for reset header setup for call to RSTORE#wjl
ATTSAV	HS	1		:register save area for ATTLIN		###wjl
OSRLSV  WS	1		:save link register for OSRLIN  	###sdw
OSRTMP  HS	1		:temp within OSRLIN

:	STORAGE SPACE FOR BUILDING RESET AND
:	NULL RECORDS DURING SYNC LINE INPUT.
	if	sylins
: SYSTOR	WS	2*((XSDSZ+7)/8)	:Must be multiple of 8 bytes
systor	ws	20		:some room for holding line test as well
SYSTSZ	EQ	(.-SYSTOR)/2	:Size of Sync Storage in HW
	ei	:sylins

::*********************************************************************
::
::	LINE DESCRIPTOR PARAMETERS:
::	NOTE:  ">name" corresponds to proposed new usage
::
::*********************************************************************

	if	sylins
QSYLVR	HS	sylins		:SYLVER STATE VARIABLES - P COUNTERS	>L.SYLP
	ei	sylins

:	The following are for gathering statistics
LDARLN	WS	(NLINES+1)/2	:1 HW BIT ARRAY FOR EACH LINE KEEPS	>L.LDAR
				: TRACK OF ERRATE FOR ND DISPLAY
RCRCVD	HS	NLINES		:GOOD RECORDS RECEIVED			>L.RCVD
RCTRNS	HS	NLINES		:NUMBER RECORDS TRANSMITTED		>L.TRNS

:	The following are sync-unique parameters
	if	sylins
SVNTOP	HS	sylins		:DATA BUFFER OUTPUT POINTER		>L.TAIL
SYLSHF	HS	sylins		:LEFT SHIFT COUNT STORAGE		>L.SHFT
SYBCNT	HS	sylins		:RECORD BYTE COUNT			>L.BCNT
SYHEDR	WS	sylins		:RECORD HEADER				>L.HEDR
	ei	:sylins

	IF	SILINS
:	The following are SIO-unique storage
Q	EQ	(NLINES-SILINS)*2		: 2*first line #
SIBUFN	EQ	.-Q			: INDEX INTO SIBUF		>L.SIBF
	SYAD(SIBUFN)
	HS	SILINS
       EI	:SILINS

SIOTST	HS	NLINES			: SIO OUTPUT STATE		>L.SIST

:	fix initialization to not loop for while waiting to complete
:	initialization.				 			###sdw

SIOTSV  HS	NLINES  		:saved state while waiting	###SDW
SIOTIM  HS	NLINES*2

SIOFB   HS	NLINES  		:next free output area
SIOTB   EQ	SIOFB+1 		:interleaved byte arrray with SIOFB
	SYAD(SIOFB )
	IF	NGRDTM
LCRPCT	BS	NLINES			:LINE CHECK REPORT COUNT FOR NON-4SEC
	EI				: REPORTING			###AL
	HS	0
linsvd  hs	lnsize
ccwdsv  ws	1		:link save in ccwsnd and ccwrtr
ccwds1  ws	1		:link save in sndrtr (the nak routine)
rmlnsv  hs	1			:sve line # during rmake
SIONOG  HS	LNSIZE  		:no go on this line
SIOROL  HS	1			: whether rotating multiline link###dmj
SIOROS  HS	1			: first line in this pass of rotat##dmj
SIOBRS	HS	1			: BAD RECORD SIZE COUNTER
SIOREG  HS	20			:place to save all registers    ###dmj
srtdsv  hs	20			:save regs
srtdsp  hs	2			:for SIORTD (rtd from sio buffer)
SIOBCS	HS	SILINS			: BAD SOFTWARE CHECKSUM COUNTER
	SYAD(SIOBCS)
SIOMIS	HS	1			: RECORD SIZE MISMATCH
SIOIZL	HS	2			: SAVE AREA FOR RETURN LINK IN SIOIZ
SIOECT	HS	1			: NUMBER OF TIMES BUFFER COUNT INVALID
SIOPTA	WS	(NLINES+1F)/20		: SIO PORT AVAILABLE BIT ARRAY	###OAS
					: 0 = PORT AVAIL., USED FOR PORT SWITCH
:	HDLC micro SIO init software 'timeout' crpyto ignore flag	###wjl
	IF	HMICRO		:HDLC micro only			###wjl
SIOIGN	BS	LNSIZE		:bit array to ignore crypto 7B		###wjl
	EI	:HMICRO		:					###wjl


       IF	SPAM
SPMINI  HC	0		:used to indicate SPAM sync done	###dmj
SPSYNC  WC	0		:used to synchronize spam		###dmj
       EI	:SPAM
SYLTIM	WS	1		:FASTC TIME TO CHECK FOR SYNC RING OVERRUN
SYLINT	HS	1		:FASTC INTERVAL FOR LINE SPEED CALC'S
LNKRET	HS	2		:RETURN LINK FOR LKVOLT
SYLXEC	HS	1		:COUNT OF NUMBER OF SYLVER EXECUTIONS
SYLXAV	HS	1		:AVERAGE INTERVAL BETWEEN SYLVER EXECUTIONS


:	TRACE-SYNC WORK AREAS:
	IF	TSTSZE
TSLINK	HS	1		:LINK OF INTEREST (TRACING ENABLED BY
	SYAD(TSLINK)		: PATCHING NEIGHBOR NUMBER IN THIS CELL
				: TSLINK ZEROED WHEN LINK GOES OUT.)
TSLINE	HS	1		:LINE OF INTEREST - SAME CONVENTION AS TSLINK
	SYAD(TSLINE,1)
TSRSVE	HS	4		:REGISTER SAVE - FOREGROUND
TSBSVE	HS	2		:REGISTER SAVE - BACKGROUND
TSFPTR	HS	1		:CURRENT ENTRY PNTR FOR FOREGROUND TRACE TBL
	SYAD(TSFPTR)
TSFTBL	BS	TSTSZE		:FOREGROUND EVENT TRACE TABLE
TSBPTR	HS	1		:CURRENT ENTRY POINTER FOR BACKGROUND TRACE TBL
TSBTBL	BS	TSTSZE		:BACKGROUND EVENT TRACE TABLE
	SYAD(TSBTBL)
	EI 	:TSTSZE

:	STORAGE AREA FOR SIO TIMEOUT CODE
SBZSAV	WS	10		:SAVE AREA FOR REGISTERS

LDRGSV	HS	2		:SAVE LINK REGISTER
TIK4MN	HS	2		:4-MINUTE TICKER (# OCCURRENCES OF LDRPRT)
LDTARY	HS	(NLINES+0F)/10	:SET BIT FOR LINE WHICH MADE DIAGNOSTIC REPORT

	IF	SILINS
siohcr	hs	silins		:running count of sio hdlc cksm errors
				:checking one byte every 4 minutes allows
				:possibility of wrapping the counter
SIOHCK	HS	SILINS		:SAVE CUMULATIVE # OF SIO HDLC CKSM ERRORS
SIOHAB	HS	SILINS		:SAVE CUMULATIVE # OF SIO HDLC ABORTS
BADSLN	EQ	.-SBASE		:index by SIO line number (not for sync)
	HS	SILINS		:sio of the bad record for crypto msg 53
	EI	:SILINS
MSBASE	EQ	(SILINS-NLINES)*2

::*********************************************************************
::
::	YAKYAK VARIABLES:
::
::*********************************************************************
::
LKTEAR	BS	LKSIZE		:LINKS BEING PROCESSED BY RTEAR
LKMAKE	BS	LKSIZE		:DITTO RMAKE
LKSRVD	BS	LKSIZE		:LINKS BEING SERVICED BY RTD/RMK

DIDALL  HS	1		:by servicing a packet for each link before
DIXLFT  HS	1		:for handling multiple messages for one port in
dsi.r2  HS	1		:have to save r2
ds.chn  HS	1		:for quickly finding ports to service in DSINXT
				:one pass through DISIN

NEWLNR	WS	1		:SAVE RETURN FOR NEWLNK/TRLINK
BPMPRC	WS	1		:TEMP STORAGE FOR BPMV
LKRR	BS	LKSIZE		:CLEARED WHEN LINK COMPLETES ROUND ROBIN
	DEFAULT(RTRMAX,7F)	: max. no. of chars RTEAR will do for one line
RTRCNT	HS	1		: where we keep track of the above

RMTSR1	HS	1		:TEMP STORAGE
RMTSR2	HS	1
RMTSR3	HS	1
RMTSR4	HS	1
RMRFLG	HS	1		:so can count round robin accurately
NUMPAG	HS	1		:NUMBER OF AVAILABLE HALF PAGES

RMT1SL	HS	1		:SAVE SIZE OF EACH T-I SUP RECORD HERE
RMT1SB	HS	1		:SAVE BUFFER# WHEN ZAPPING T-I COMMAND CRQ

MINLR	HS	1		:MINIMUM LOGICAL RECORD SIZE (3 FOR T-I,
				: 1 FOR T-II). USED BY RTD TO DETERMINE IF
				: ANY LOGICAL RECORDS REMAINING IN PACKET
LSNIPS	HS	1		:COUNT LINK SNIPS
	SYAD(LSNIPS)
ZAPCNT	HS	1		:COUNT ZAPPED CIRCUITS FOR LINK OUT NODE REPORT
CMDZCT	HS	1		:COUNT ZAPPED COMMAND CIRCUITS FOR REPORTING
TRREGS	WS	10		:REGISTER SAVE FOR CALLING TRACE, SUP12

:	MISCELLANEOUS FLAGS:

:	GUSH AND TRIKLE ARE CHANNEL BIT ARRAYS WHICH INDICATE RATE OF DATA
:	FLOW INBOUND. RTD TESTS THE SIZE OF EACH LOGICAL RECORD TORN,
:	AND SETS THE GUSH ARRAY IF L.R. SIZE IS 'TRIKLV' OR GREATER.
:	IF L.R. SIZE IS LESS THAN 'TRIKLV', THE TRIKLE ARRAY IS SET
:	FOR THAT CHANNEL. EVERY 2 SECONDS THE TRIKLE ARRAY IS OR'D
:	INTO THE GUSH ARRAY. WHEN RMAKE SENDS BACKPRESSURE RECORDS, IT
:	WILL ONLY TEST THE CHANNELS WITH GUSH SET TO SEE IF
:	BACKPRESSURE MAY BE RELIEVED.

RTMXSV	WS	1		:TEMP STORAGE FOR RTD/RMK
RTMT1	WS	1
RTMT2	WS	1
RTMT3	WS	1
RMTNSV	WS	1
RMTNFL	HS	1
	IF	DB.DEB
RMKHWM	HS	1		:HIGH-WATER MARK FOR INTERVALS BETWEEN
				: RMAKE EXECUTIONS (IN FASTC UNITS)
RMKTIM	HS	2		:TIME OF LAST RMAKE EXECUTION
	EI	:DB.DEB

CKOSAV	WS	1		:WORK SPACE FOR LINK OVERLOAD CHECKER

XWMFLG	WS	1		:flag for XRAY warning msg

ARRIVX	WS	1		:storage for XLACK char
ARRIVT	WS	1


::*********************************************************************
::
::	XHOSTS VARIABLES:
::
::*********************************************************************

:	HOST TABLES
:	Consider for possible future Host descriptor
HSTPTA	HS	NHOSTS		:# OF HOST PORTS AVAILABLE (via host status msg
HNPORT	HS	1		:number of active dispatcher/kernel ports
:	NOTE:  Portions of host table not cleared at restart.	
:	The previous two entries MUST precede HOSTN for the
:	reinitialization of the host tables at (re)start to work
:	properly in NSTART.###jhl (this is not real smooth)
:	We zero out HNPORT and reset HSTPTA to HMAXP.

:*******FROM HERE TO NEWSUP LABEL (BELOW) FOR HOST TABLE STUFF ONLY****

HOSTN	HS	NHOSTS		:HOST #S
HMAXP	HS	NHOSTS		:MAX # OF PORTS
	HS	0		:HSTAT STARTED AT HW BOUNDARY		##AL
HSTAT	BS	NHOSTS		:STATUS BITS
HSTKEY	BS	NHOSTS		:KEY (4*SLOT #), FOR EACH HOST
:	EXPANDED HOST STATUS INFORMATION
HSTMBK	BS	NHOSTS		:MULTI-BASED HOST KEY			###OAS
	IF	T2GATE
HSTATN	EQ	HSTAT		:ONLY ONE SLOT HOST & STATUS FOR T2G	##AL
	ELSE
HSTATN	BS	NHOSTS		:EXPANDED HOST STATUS(sup19 status byte)###OAS
	EI	:T2GATE##AL	:BITS 0,1 - STATUS (SAME AS HSTAT 6,7)
				:BIT 2 SET IF OUT OF PORTS
				:BIT 3 SET INDICATES IIX
				:BIT 4 SET - ORG ONLY HOST
				:BIT 5 SET - DEST ONLY HOST
				: (IF 4 AND 5 SET, SAME AS BOTH NOT SET)
				:Bits 6,7 - unused
HSTYPE	BS	NHOSTS		:HOST TYPE (PID)			###OAS
HSTCST	BS	NHOSTS		:HOST COST (MULTI TARGET HOST)		###OAS
HSTTIM	WS	NHOSTS		:TIME OF LAST HOST STATUS UPDATE	###OAS
HSTAT3	BS	NHOSTS		:Additional host status byte		###wjl
				:Bit  0	- unused			###wjl
				:Bit  1 - LOG II host			###sdw
				:Bit  2	- unused			###wjl
				:Bit 3 - set if proxy host		###wjl
				:Bits 4,5 - Collect-calls		###wjl
				: 00 = never accept Collect-calls	###wjl
				: 01 = only accept calls		###wjl
				: 10 = leave decision to destination host##wjl
				: 11 = unused				###wjl
				:Bits 6,7 - unused			###wjl

:*******FROM HOSTN (ABOVE) TO HERE FOR HOST TABLE STUFF ONLY***********

:	NEWSUP label used by NSTART to resume clearing
NEWSUP	HS	1		:NEW/OLD (1/0) SUPERVISOR FLAG		###OAS

HSTFLG	HS	(NHOSTS+0F)/10	:FLAG INDICATING NODE CODE HAS GOT HOST
:	STATUS REPORT (MESSAGE 04 OR 10) FROM ISIS FOR SPECIFIC HOST.
:	ONE BIT FOR ONE HOST.  ***NEED CLEAR ALL FLAGS WHEN RESTART***
HSTSAV	WS	1		:TEMP. STORAGE TO SAVE R2

	IF	RESHST		:RESTRICTED HOST STUFF
HCTSM	HS	NHOSTS		:CIRCUITS/MINUTE LIMIT
HCTSCT	HS	NHOSTS		:CIRCUITS/MINUTE COUNT
RESHMS	HS	(NHOSTS+0F)/10	:BIT ARRAY TO THROTTLE NODE REPORTS FOR
				: RESTRICTED HOST VIOLATIONS
	EI	:RESHST

KERNWL	WS	(NKU+1F)/20	:NEW CIRCUITS TO KERIO
KERBPX	WS	(NKU+1F)/20	:BACKPRESSURE OUTBOUND DATA FROM KERNEL IF ZERO
kzptim	hs	nku		:timeout on zap ack after we sent zap

      IF	SPLIT
								
:	ISIS Split-Sup Communication status
SIRXOL	BS	1			:previous SIRX - SIO MB status
SPLCON	BS	1			:shared memory connected flag

SIRFLG	HS	1			: SIO interrupt status for SPLIT
	SYAD(SIRFLG)
:	SIO Ring flag, state values as follows:
:	=0	SIO Card is dead (DOWN)
:	-1	SIO Card is alive (UP)
:	>0	SIO Config messed up.
:		>0 value 3F = ring mismatch
:		>0 value 3E = given unknown status in SIRX


SIRCSV	HS	2			: save link for SIRSCK
       IF	DB.DEB
S57SAV  WS      30                      : Register-save for the 3 SVC 57 Rings 
					: connect
	SYAD(S57SAV)
SIRSAV	HS	4			: history of initial ring pointers
SIRSA2	HS	2
       EI	:DB.DEB
      EI 	:SPLIT

:	COMMON STUFF

FASSAV	WS	1		:FASTC AT TIME OF SUP CRASH
KERSVD	WS	(NKU+1F)/20	:KERNEL PORTS BEING PROCESSED BY KERIO

LEPSVT	WS	1		:return for LEP
XHSVRT	WS	1		:SAVE RETURNS for KERIN/KEROUT/SUPIN/SUPOUT
SBPTMP	WS	1		:TEMP STORAGE
XHPRCS	HS	1		:PRC SAVE
schnsv	hs	1		:last chn serviced in SUPIN
bchnsv	hs	1		:last chn used in sup release backpressure
KERICC	HS	2		:COUNT OF CHARS INTO THE KERNEL
KEROCC	HS	2		:DITTO OUT
SUPICC	WS	1		:GUESS
SUPOCC	WS	1
       IF	SUPER		:expanded sup monitoring cmds
KERICT	WS	NKU+2		: char count into kernel by port
KEROCT	WS	NKU+2		: char count from kernel by port
KRICCT	WS	1		: running CPS into the kernel
KROCCT	WS	1		: running CPS from the kernel
KROCCW	WS	1		: highwater mark CPS 
KRICCW	WS	1		: highwater mark CPS 
SUOCCW	WS	1		: highwater mark CPS
SUICCW	WS	1		: highwater mark CPS
SUICCT	WS	1		: running CPS
SUOCCT	WS	1

SUICHR	HS	1		:SAVE AREA FOR INVALID CHARACTER PAIRS
				: ARRIVING AT A SUP PORT
SUERCH	HS	1		:SAVE CHANNEL FOR ERRONEOUS NETWORK CHARACTERS
SUERTP	HS	1		:SAVE TYPE OF ERRONEOUS CHARACTERS DETECTED

:	The following is used for SH (sup ring histograms) xray command
:	main sup ring
SPOHGM  WS	8		:output histogram
SPIHGM  WS	8		:input histogram
SUPICP	HS	1		:high amount of ring fill for input
SUPOCP	HS	1		:high amount of ring fill for output
:	backpressure rings
SIBHGM	WS	8		:output histogram (from node to sup)
SOBHGM	WS	8		:input histogram (from sup to node)
SIBCP	HS	1		:high amount of ring fill for input
SOBCP	HS	1		:high amount of ring fill for output
SUPSTO	HS	1		: flag indicates "sup stop" msg sent

	IF	DB.DEB
SRNRPS	HS	1		:SAVE ORIGINAL PRD (NODE INDEX)
	SYAD(SRNRPS)
SRNPRS	HS	1		:SAVE ORIGINAL PRC (SUP INDEX)
	SYAD(SRNPRS)
SRNRCS	HS	1		:SAVE COMPUTED ROOM
	SYAD(SRNRCS)
	EI 	:DB.DEB

	ei	:super

::*********************************************************************
::
::	DISPI VARIABLES:
::
::*********************************************************************

DSOLGH	HS	2		:'HOST #', 'TID', 'ESC' FOR DSOLGC
DSOSPC	WS	1		:CONTROL CHARACTER ARRAY FOR LOGIN STRING

DIXLIM	HS	NDP		:TRANSMIT LIMITS (PER PORT)

DISBPV	WS	(NDP+1F)/20	:RECEIVED BACKPRESSURE FLAGS
	SYAD(DISBPV)
DISBPX	WS	(NDP+1F)/20	:TRANSMITTED SUCH
	SYAD(DISBPX)
DISSVD	WS	(NDP+1F)/20	:PORT SERVICED FLAGS
disgob	WS	(NDP+1F)/20	:bp overridden by gobbler, set BP after gobbler
				:is sent
       if	cmpnul		:if doing null compression
nulcom	WS	(NDP+1F)/20	:1 if port has compression enabled.
rcvesc	WS	(NDP+1F)/20	:1=incoming bytes 04-07 are data (not signals)
sndesc	WS	(NDP+1F)/20	:1=transmit bytes 04-07 as data (not signals)
       ei	:cmpnul

       if	t2gate
GISSVD  WS	(NDP+1F)/20	:GATEWAY LOGING SERVICED FLAGS
       ei

DISAUX	WS	(NDP+1F)/20	:AUX CIRCUIT REQUEST FLAGS
DISHNG	WS	(NDP+1F)/20	:HANG SENT TO DISP PORT, NOT YET ZAPPED
	SYAD(DISHNG)
DISZNK	WS	(NDP+1F)/20	:ZAP SENT TO DISP PORT, AWAITING ZAP ACK
	SYAD(DISZNK)
DISELS	WS	(NDP+1F)/20	:REQUEST EXTENDED LOGIN STATUS FLAGS

       IF	LOGII
L2CHSV	WS	1		:reg save area for LogII CRQ utility
ICRMS1  WS	1		:temp area
ICRMS2  WS	1		:temp area
ICRMS3  WS	1		:temp area
ICRMSZ  WS	1		:temp area for MO size
ICRMSB  HS	1		:save x.409 flags field
DORLKY  HS	1		:save area for local key in ICRM
DORDKY  HS	1		:save area for dispacher key in ICRM
DORCHN  HS	NSLOT+1 	:CHN for ICRM arriving in pieces
SLTRJT  BS	(NSLOT+8)/8	:set if rejecting ICRM pieces for slot

DISLG2  WS	(NDP+1F)/20	:port using/used LOG II login? (org ports only)
	SYAD(DISLG2)
       IF	T2GATE  	:for gateway log2
GDBUFT  WS	1		:temporary buffer address
       EI	:T2GATE
       EI	:LOGII

DSSVRT	WS	1		:FOR SAVING RETURN
DSOREG  WS	10		:for saving all regs (DSODBP)

DIDTIM	WS	1		:DISPATCHER PROCESS DISMISS TIME

:	The following is used for expansive IS command  	###sdw
DISICC	WS	1		:CHARACTER COUNTS - INTO DISPATCHER
DISOCC	WS	1		:FROM DISPATCHER
DISOCH  WS	1		:highwater dispatcher movement  	##sdw
DISICH  WS	1		:input highwater dispatcher movement
DISOCM  WS	1		:output new 1 min history
DISICM  WS	1		:input new 1 min history
DISOCT  WS	1		:output time of highwater
DISICT  WS	1		:input time of highwater
DSOHGM  WS	8		:output histogram
DSIHGM  WS	8		:input histogram
:	Following 8 hw are expected to be contigious in this order by xray IS
:	command display							###sdw
DISICP  HS	1		:high amount of ring fill
DISOCP  HS	1		:high amount of ring fill for output    ###sdw
DSICHN	HS	1		:NEW NEEDLE CHANNEL NUMBER
				: (SEE 0310 MESSAGE)
DSINOD	HS	1		:CIRCUIT ORIGINATING NODE NUMBER
				: (SEE 0310 MESSAGE)
DORHST	HS	1		:ORIGINATING HOST NUMBER
				: (SEE 07 MESSAGE)
DOILLG	HS	1		:NUMBER OF ILLEGAL LOGIN CHARACTERS
				: FROM DISPATCHER PORTS NOT IN LOGIN MODE
				: (SEE B3 MESSAGE)
DIDISM	HS	1		:NUMBER OF FORCED DISMISSES FOR DISIN
DODISM	HS	1		:NUMBER OF FORCED DISMISSES FOR DISOUT

DORSLT	HS	1		:SLOT NUMBER * 2
				: LAST SLOT WHICH ORIGINATED CIRCUIT
RPSAV	HS	1		:TEMP STORAGE
DSIPRT	HS	1		:CIRCUIT ORIGINATING PORT NUMBER
DSIHST	HS	1		:CIRCUIT ORIGINATING HOST NUMBER
DSINFL	HS	1		:SAVE NEEDLE FLAGS
DSITLG	HS	1		:INDICATE TRANSPARENT LOGIN IF POSITIVE
DORSIQ	HS	1		:SAVE SIQ
DSOHYP	HS	1		:INDICATE IF HOST STATUS MESSAGE CONTAINS HYPE
	IF	(1-T2GATE)
SCLCNT	HS	NUSLT		:COUNT NUMBER OF CIRCUITS, BY SLOT
SMLCNT	HS	NUSLT		:COUNT NUMBER OF SLOT REPORTS, BY SLOT
	EI	:(1-T2GATE)		###EV
DIMMSV	HS	2*2		:SAVE FOR REG'S 14,15

XFNDSV	WS	1	:XFNDLK ROUTINE


::*********************************************************************
::
::	SWITCH VARIABLES:
::
::*********************************************************************

PFMTYP	HS	1		:RTD STORES ARRIVING PERF MON.CHAR HERE
ARRIVL	WS	1		:RTD STORES ARRIVAL TIME OF PERF MON CHAR PAIRS
	if	loglim
logout  hs	1		:count of outstanding messages to supe
logouo  hs	1		:old count of outstanding messages to supe
	ei	:loglim
TVRSUP	HS	1		:CONTAINS SUP # AFTER TAKEOVER
	SYAD(TVRSUP,1)
TVRBUF	HS	1		:SUP UPSTREAM BUFFER #
TVRSTT	HS	1		:SUPERVISOR STATUS (5=AWK,4=SLP,3=FRZN)
LOGZPF	HS	1		:TO CAUSE LOGGER TO ZAP CIRCUITS ON TVR
TAKOVR	HS	1		:SHOW RECENT TAKEOVER,DEFERRED RESOURCES REPORT
LEPINB	HS	1		:BUFFER BEING PROCESSED BY LEP
LEPNOD	HS	1		:BUFFER FOR LEP MESSAGES
LEPMES	HS	80
SUPMBF	HS	5		:BUFFER FOR SUP UPSTREAM MESSAGES
       IF	LOGII
LEPAS1  HS	2		:series of saves for LOG2 LEP
LEPAS2  HS	2
LEPAS3  HS	2
LEPAS4  HS	2
LEPAS5  HS	2
       EI	:LOGII
KDISP	HS	1		:FOR FLASHING DISPLAY OF NETWORK STATUS
SUPIBF	HS	3		:TEMPORARY BUFFER FOR DIAGNOSTIC MESSAGES
				: GENERATED IN ISIS FOREGROUND ROUTINE

LEPNPF	HS	2		:LEFT HALFWORD POSITIVE IF HANDLING SUP NOPP
:	COMMAND FOR LOAD TEST. RIGHT HALFWORD HAS LOOP COUNTER. SEE 'LEPNOP'.
LEPNSF	HS	2		:SUP FASTC SAVE AREA FOR SUP NOP
LEPXER	HS	1		:NUMBER OF LEP ERRORS (SEE LEPXMN, LEPXCM)


:	THE STORAGE FOR THE DEBUGGER				###LSH

:	TURN OFF ALL THE ASSEMBLY SWITCHES FOR  ALL THE DEBUGGERS
CFIG(LNFDBG,0)		:LOGON/LOGOFF DEBUGGER OFF
CFIG(CBZDBG,0)		:CIRCUIT BUILDING/ZAPING DEBUGGER OFF
CFIG(BFSDBG,0)		:BUFFER STRUCTURE DEBUGGER OFF
CFIG(LPGDBG,0)		:LEP/LOGGER DEBUGGER OFF
CFIG(LNKDBG,0)		:LINE/LINK DEBUGGER OFF
CFIG(DBGON,LNFDBG!CBZDBG!BFSDBG!LPGDBG!LNKDBG)

	WS	0
REGST	WS	10		:temp storage for registers in background
RGST	WS	10		:used for any foreground debugs

       IF	DB.SD1
REGSDW	WS	10		:storage area for trap code
       EI	:DB.SD1

	IF	LPGDBG
LPGSSV	WS	1		:TEMP STORAGE FOR RING POINTER
	EI	:LPGDBG

	IF	LNFDBG
LGINUS	HS	1		:"LG" XRAY COMMAND IN USE INDICATOR
	EI	:LNFDBG
	IF	CBZDBG
CZINUS	HS	1		:"CZ"XRAY COMMAND IN USE INDICATOR
	EI	:CBZDBG
	IF	BFSDBG
BFINUS	HS	1		:"BF" XRAY COMMAND IN USE INDICATOR
	EI	:BFSDBG
	IF	LPGDBG
LLINUS	HS	1		:"LL" XRAY COMMAND IN USE INDICATOR
	EI	:LPGDBG
	IF	LNKDBG
LKINUS  HS	1		:"LK" XRAY COMMAND IN USE INDICATOR
	EI	:LNKDBG


:	TURN OFF ALL THE ENABLE/DISABLE FLAGS FOR ALL THE DEBUGGERS

	IF	LNFDBG		:FOR LOGON/LOGOFF DEBUGGER

LINDIS	HS	1		:FLAG FOR LOGIN. 
	SYAD(LINDIS)
	EI	:LNFDBG

	IF	CBZDBG		:FOR CIRCUIT BUILDING/ZAPPING DEBUGGER
CRQDIS	HS	1		:FLAG FOR CRQ, AND CRQHCR.
	SYAD(CRQDIS)
ZAPDIS	HS	1		:FLAG FOR ZAPHRD, AND ZAPV.
	SYAD(ZAPDIS)
	EI	:CBZDBG

	IF	BFSDBG		:FOR BUFFER STRUCTURE DEBUGGER
GRFDIS	HS	1		:FLAG FOR GFCBUF, AND RFCBUF.
	SYAD(GRFDIS)
WREDIS	HS	1		:FLAG FOR WRE, CKZB, REBZ, BUFZAP
	SYAD(WREDIS)
CBCDIS	HS	1		:FLAG FOR CBCLR.
	SYAD(CBCDIS)
	EI	:BFSDBG

       IF	LPGDBG		:FOR LEP/LOGGER DEBUGGER
LPGDIS	HS	1		:FLAG FOR LEP AND LOGGER.
	SYAD(LPGDIS)
LPDDIS	HS	1		:FLAG FOR LEP0D, LEP09, AND LEPZLI
	SYAD(LPDDIS)
	EI	:LPGDBG


       IF	LNKDBG		:FOR LINE/LINK DEBUGGER
LKLDIS	HS	1		:FLAG FOR LINK/LINE DEBUGGER
	SYAD(LKLDIS)
	DEFAULT(PKSVLH,20)		: How many bytes to save of bad SIO rec
PSLNUM	HS	1			: FLAG SET WILL TURN-ON SIPKSV
	SYAD(PSLNUM)
       EI	:LNKDBG

:	THE END OF STORAGE FOR DEBUGGER		###LSH


LOGSAV	WS	1		:TEMP STORAGE FOR LOGIN
LOGTBF	WS	1
LOGTID	BS	1
       IF	REBTAK
LP8RS1  WS	1		:ave for new rebuild resend		###sdw
       EI	:REBTAK

LGCSAV	WS	1		:TEMP STORAGE FOR LOGCLR		###LSH
CRDSAV	WS	1		:TEMP STORAGE FOR CIRDIS		###LSH
CRDSSV	WS	1		:TEMP STORAGE FOR CIRDIS		###LSH
ASMSSV	WS	1		:TEMP STORAGE FOR ASYMPC		###LSH

FREELB	HS	1		:HEAD OF THE FREE BUFFER-PAIR LIST
	SYAD(FREELB)
FREELT	HS	2		:HEAD OF FREE BUFFERLET LIST
	SYAD(FREELT)
freelf	hs	1		:head of list of returned bflets
REBL	HS	2		:POINTER TO RESERVE TANK LIST
WRERET  WS	1		:RETURN POINTER FOR WRE ROUTINE

       IF	LOGII   	:log II (new logon stuff including X.409)
GTLNSV  WS	1		:temp for X4GTLN
X4WTSV  WS	1		:temp for X4WTEL
X4TBPT  WS	1		:pointer into table X4TBBG (for parsing)
X4NXVL  WS	2		:contains bits, ID, LEN from parser
ELEPOS  WS	1		:current address within buf of parser
ELEDIS  HS	1		:how many char parsed from start
X4CPTR  WS	1		:pointer to current position in table
X4CWSV  WS	1		:save area when writing X.409 element to buffer
X4CWS1  WS	1		:save area when writing X.409 element to buffer
       EI	:log II
X4NXSV  WS	1		:save for X4NXTEL
SWIVSV	WS	1		:TEMPORARY STORAGE FOR SWITCH
YAKT1	WS	1		:TEMP
LEPSV1	WS	1		:DITTO
:::
BPMTII	BS	LKSIZE		:DO FLOW CONTROL FOR TYMNET-II LINKS
	if	fstdat
bpmtiq	bs	lksize		:possibly send bp relief more often
	ei	:fstdat
CRQASV	WS	1		:SAVE LINK REG FOR CRQALT
BPMXSR	WS	1		:SAVE RETURN FOR BPMX
BPSHSV	WS	1		:TEMP STORAGE FOR BPMSHF
BPSHRT	WS	1
GETRSV	WS	1
RFCSAV	WS	1
TRCSV1	WS	1
TRCSV2	WS	1
HPRUNV	WS	1
ZAPXS1	WS	1		:SAVE AREA FOR CALLING LOGCLR FROM ZAPX
ZAPXS2	WS	1
ZAPXS3	WS	1
SPLSV1  WS	1		:work area for merge
appnsv	ws	4		:stm r12 lm r12 in append rtd save area
BUBS1	HS	1		:WORK AREAS FOR BUBBLE
BUBS2	HS	2
BUBS3	HS	1
LNKRGS	WS	2		:REG STORAGE FOR SHRK4, FNDKNC, BUBBLE
WCDSAV	WS	2		:TEMP STORAGE FOR WCD
GCDSV   HS	1		:TEMP STORAGE FOR GCD
CHUSAV	WS	1		:TEMP STORAGE FOR SWRCHU

RFAT	WS	1		:DATA FROM FAT ZAPPER FOR REBUILD REQUEST

DETSVC	WS	1		:SERVICED FLAGS FOR 'DETACH'
DETMTY	BS	$A32		:MESSAGE TYPE FOR EACH DETACHED PORT
				: OUTPUT IT ON RECEIPT OF NEEDLE
DETTSV	HS	1		:TEMP AREA FOR ABOVE

ACT7LO	HS	6		:LAST '07' (invoice) acct msgs low 24 bits
ACT7HI	HS	6		:high 8 bits of invoice (only do 32 bits inv
actsv1	hs	2		:save r10 (link register)
actsv2	hs	2		:save invoice data field (link register)
ACTLST	BS	1		:INDEX TO LAST TYPE '07' MSG SENT

WATCHDOG BS	1		:WATCHDOG TIMER FLAG

NEDFLG	HS	1		:LEP SAVE NEEDLE FLAGS

:	CIRCUIT BUILDING CONSISTENCY FIELDS
NC.LPE	HS	1		:NUMBER OF LEP CHAN IN USE, NO NEIGHBOR ERRORS
NC.CRQ	HS	1		:TOTAL NUMBER OF CIRCUITS ATTEMPTED BY CRQ
NC.CRZ	HS	1		:NUMBER OF CIRCUITS ZAPPED BY CRQ
NC.CRC	HS	1		:TOTAL NUMBER OF CIRCUITS COMPLETED BY CRQ
NC.THS	HS	1		:CIRCUIT ERROR REPORTING THRESHOLD
NC.CER	HS	1		:TOTAL NUMBER OF CONSISTENCY ERRORS

PLISLT	HS	1		:STORAGE FOR ISIS SLOT NO. FOR PLI MESSAGE
PLICNT	HS	1		:BYTE COUNT IN PLI MESSAGE
PLINDX	HS	1		:CURRENT RECEIVED BYTE COUNT FOR PLI MESSAGE
PLIXOR	HS	1		:CHECKSUM
PLICN2	BS	1		:ANOTHER BYTE COUNT FIELD, FOR BUFCAN ROUTINE
PLIDAT	HS	100/2		:PLI MESSAGE DATA AREA (HW aligned)	###jhl

INTSAV	HS	8		:WORKING AREA FOR INTERNAL HOST PROCESSOR

INTTSV	WS	1
INTDWF	HS	1		:INTERNAL HOST DWL CHANNELS ARRAY
	SYAD(INTDWF)
INTOUT	HS	1		:INTERNAL HOST TIMEOUT ENABLE BIT ARRAY
SI1DBG	HS	1
SI2DBG	HS	1
INTUSE	HS	1		:INTERNAL HOST CHANNEL IN USE BIT ARRAY
	SYAD(INTUSE)
INTLST	HS	1		:WORKING AREA FOR INTERNAL HOST PROCESSOR
INTACT	HS	1		:INTERNAL HOST ACTIVE CHANNEL BIT ARRAY
INTWRN	HS	1		:INTERNAL HOST TIMEOUT WARNING BIT ARRAY
INT8MN	HS	1		:8-MINUTE CELL FOR INTTIM
INTXRF	HS	1		:INTERNAL HOST REMOTE XRAY CHANNEL BIT ARRAY
XUSIUA	HS	1		:XRAY USER SLOTS IN USE ARRAY
INTLPF	HS	1		:LOOPBACK TEST BIT ARRAY
	SYAD(INTLPF)

INTDSF	HS	1		:CRQ DELAY CHECK SOURCE CHANNEL BIT ARRAY
INTDRF	HS	1		:CRQ DELAY CHECK RECEIVING CHANNEL BIT ARRAY

XRYRUN	HS	1		:RUN FLAG FOR XRAY
XDDTAD	WS	1		:address where XDDT job wants background to do
				:something (prevent job collision)###sdw
XDDTSV  WS	20		:XDDT registers for BG task
DBEGS1  WS	1		:link register save for begin delay circuit
DLYES1  WS	1		:link register save for end delay circuit
XWRBS1  WS	1		:link register save for write buffer cmd
XNIDS1  WS	1		:link register save for change NEITD cmd
XRPFS1  WS	1		:link register save for perf mon cmd (PM)

DWLCOU	HS	1		:THIS AND THE NEXT THREE LOCATIONS ARE FOR
	SYAD(DWLCOU)
DWLCLI	HS	1		:SPOTTING DWL PROBLEMS
DWLCIN	HS	1
DWLDSP	WS	2		:BIT ARRAY FOR SPEEDY DISPATCH OF DWL LINES
STDWDS	WS	2		:FOR STARLINE LOADS BOTH INDEXED BY 2*Line#
DWQUEU	HS	1		:DWL JOB QUEUE FOR DWLIN
DWTEST	HS	1		:SEMAPHORE BETWEEN LINKER AND DWLIN

dlyrat  hs	1		:so dlysrc can pace delay source data
DLYINT	HS	10		:INTERVAL in 1/8 seconds-1 between test data

NETDCT	HS	2		:THROTTLE COUNTER FOR DIAGNOSTIC NODE REPORTS
NTDRET	HS	2		:SAVE LINK REGISTER FOR NETDGN

	WS	0		:WORKING STORAGE FOR CRQ
CQNBUF	HS	1		:NEEDLE BUFFER #

CQNLK	HS	1		:WORKING STORAGE FOR CRQ
GDNINV	WS	0		:Overlay invoice numbers
CQINV	WS	1		:INVOICE #

	IF	ACCT
GASTOR	WS	1
	EI	:ACCT
CQNFLG	HS	1		:FLAGS
CQNODE	HS	1		:REQUESTING NODE
CQPORT	HS	1		:REQUESTING PORT
CQDHST	HS	1		:DESTINATION HOST IF INTERNAL CIRCUIT
CQTID	BS	1		:Originating TID (CCT)
	BS	1		:Could store User Flags if needed
CQHOST	HS	1		:HOST # (DESTINATION NODE IF T-I)

CQNSZ	HS	1
	if	autrac
cqgoug	bs	1		:gouging and cost table (3 bits in a row)
cqohst	hs	1		:origination
cqdnod	hs	1		:destination node
	ei	:autrac
CQVSEQ	WS	1		:SEQN NUMBERS ARE NOW 32 BITS		###GT
	SYAD(CQVSEQ)
CQXSEQ	WS	1
	SYAD(CQXSEQ)

CRQARL	EQ	((NCIRCS+1F)/20)*4	:# BYTES IN CRQ BIT ARRAYS

CRQEND	WS	CRQARL/4	:EACH BIT REPRESENTS BUFFER PAIR, BIT SET FOR
	SYAD(CRQEND)		: CIRCUIT TERMINATION (INTERNAL OR T-1)
BURSAV	WS	1		:Register save area
	IF	REBILD
CRQBSY	WS	CRQARL/4	:EACH BIT REPRESENTS BUFFER PAIR, BIT SET FOR
	SYAD(CRQBSY)		: REBUILDABLE TERMINATION (NOT TPUT CLASS 3)
REBTMO	WS	CRQARL/4	:CIRCUIT BUILDING TIMEOUT FLAGS
	if	mortim
rebtm1	ws	CRQARL/4
rebtm2	ws	CRQARL/4
	ei	:mortim
REBTMI	WS	CRQARL/4
SQFIXV	WS	CRQARL/4	:SET IF REBILD QUAD EVER RECEIVED FOR THIS CRQ
SQFTMI	WS	CRQARL/4	:REBUILD TIMEOUT FLAGS			###GT
SQFTMO	WS	CRQARL/4
	EI 	:REBILD

CHNMPD	HS	NLINKS		:NODE NUMBERS FOR PROBE TRACE
CHNMAP	WS	NLINKS+6+SUPER	:CHANNEL MAP FOR PROBE TRACE


       IF	ACCT
::	STORAGE
aaorig	hs	((naccts+0f)/10) :bit array indicating orig (don't send cnts)
AAINV	HS	2*naccts	:Invoice number	
AAICMS	HS	2*naccts	:MSF 32 bits of Input character count
AAOCMS	HS	2*naccts	:MSF 32 bits of Output character count
:	AAICMS and AAOCMS are interleaved as both are accessed by a
:	FW pointer.
AAICLS	HS	2*naccts	:LSF 16 bits of Input char count
AAOCLS	EQ	AAICLS+2	:LSF 16 bits of output char count

AAREAS	HS	2		:Logout reason save area
AAR1SV	HS	2		:Return save
AAR2SV	HS	2		:Ditto
ININV	HS	2		:Store INET Invoice number for AASWAP

AARGSV	WS	10		:Accounting routines register save area
AA20MN	WS	1		:Timer count save area
AASVCT	WS	1		:Port counter for periodic report
	EI	:ACCT

::*********************************************************************
::
::	FUNCTION:	Data storage areas for gateway logon process
::*********************************************************************

	IF	T2GATE
CCTTBL	BS	NDP		:Save area for CCT's for Gateway circuits
LOGING	WS	(NDP+1F)/20	:Ports marked when in Log-in mode
	SYAD(LOGING)
GDSTPT	WS	(NDP+1F)/20	:Ports marked as circuit destinations
GORGPT	WS	(NDP+1F)/20	:Ports marked as circuit origins
GTAUX	WS	(NDP+1F)/20	:Gateway circuits originated as Aux circuits
GIIXCT	WS	(NDP+1F)/20	:Circuits marked as IIX capable
GTTRNS	WS	(NDP+1F)/20	:Circuits originating as transparent log-ons
GTHDX	WS	(NDP+1F)/20	:Circuits originating from HDUX terminals
GTASCI	WS	(NDP+1F)/20	:Circuits determined as 2741 or 3767 origin
GTECHO	WS	(NDP+1F)/20	:Echo mask per port - primary Echo switch
GTLGEC	WS	(NDP+1F)/20	:Echo for log-on processing
GMSG0F	HS	0		:Companion array to mark log-on status
LOGDAT	WS	(NDP+1F)/20	:Ports with data for Log-in
GLGDAT	WS	(NDP+1F)/20	:Ports for more data log-in (B3)
::Storage areas for Gateway log-ins
GASAVE	WS	1		:Return save area
GDSAVE	WS	1		:Return save area
GESAVE	WS	1		:Return save area
GRSAVE	WS	1		:Return save area
GZSAVE	WS	1		:Return save area
GZAPSV	WS	1		:Return save area
GDPRD	HS	1		:Save area for Dispatcher ring pointer
GDDIAL	HS	1		:Saved from Needle - Dialect field
GDCCT	BS	1		:Saved from Needle - CCT field
GDUNSZ	BS	1		:Saved from Needle - Username size
GDSPED	BS	1		:From Needle - Speed bits ready in low nible
GDTPC	BS	1		:From Needle - Throughput class field
GDNLEN	HS	1		:From Needle - additional length of Needle
GDUSRF	HS	1		:From Needle - User Flags
GDFLGS	HS 	1		:From Needle - Needle Flags
GLGSTA	HS	1		:Log-on status storage
::Miscellaneous	Gateway variables and equates
DZLEN	WS	1		:Storage for message length reg	
UPDOWN	HS	1		:Storage for host status
GT.VER	EQ	((VERSION*4)&0FF00)!(REVLEV)
::Some equates
GAXTID	EQ	0CE		:Aux circuit TID (CCT) is '0E'
GXPRNT	EQ	0BF		:Test for transparent log-on is "?"
GLGTMR	EQ	$A120		:Log-on timer is two minutes

	EI	:T2GATE		:###ev

:	Internal host processor arrays

INTDSP	HS	TINTCH		:Dispatch vectors (less SEG1 offset)
	if	t2gate
intdss	HS	TINTCH		:saved dispatch vectors (while doing iix)
	ei	:t2gate
INTUSR  WS	TINTCH		:Username save area
INTCHN	HS	1		:temp storage for INTHST channel number ###wjl

:	Downline load arrays, indexed by internal host channel number
dwldum	hs	nlines		:for smart loaders (if ever written)
DWLNUM	HS	TINTCH		:Downline load line number (* 2)
DWLOPT	HS	TINTCH		:DWL output pointers
DWBUSY	HS	TINTCH		:DWL buffer busy flags

:	Delay measurement arrays, indexed by internal host channel number

CHNFIL	HS	TINTCH		:TABLE TELLS SOURCE ROUTN # OF FILL HW TO USE
CFLCNT	HS	TINTCH		:working FILL ch depletion array	###jhl
CHNDLY	HS	TINTCH		:INT HST CHAN # TO DELAY USER # PERMUTER TABLE
DLYCHN	HS	TINTCH/2	:DELAY USER # TO INT HOST CHANNEL # TABLE
INTNDX	HS	TINTCH		:DB-INDEX BY INTHST CHAN #
DB0USE	WS	1		:0 IF DLY CHN 0 NOT IN USE, ELSE XD OF USER
DB1USE	WS	1		:0 IF DLY CHN 1 NOT IN USE, ELSE XD OF USER
DB2USE	WS	1		:0 IF DLY CHN 2 NOT IN USE, ELSE XD OF USER
DB3USE	WS	1		:0 IF DLY CHN 3 NOT IN USE, ELSE XD OF USER
DB4USE	WS	1		:0 IF DLY CHN 4 NOT IN USE, ELSE XD OF USER
DB5USE	WS	1		:0 IF DLY CHN 5 NOT IN USE, ELSE XD OF USER
DB6USE	WS	1		:0 IF DLY CHN 6 NOT IN USE, ELSE XD OF USER
DB7USE	WS	1		:0 IF DLY CHN 7 NOT IN USE, ELSE XD OF USER

XUTMP	WS	3		:TEMP STORAGE FOR USERNAME VALIDATION

:	Node performance statistics storage
TOTCHR	WS	1		:INPUT+OUTPUT LOGICAL CHARS FOR LAST MINUTE
NSCPSO	WS	1		:LAST MINUTE'S CPS OUT FOR NODE'S LINKS
NSCPSI	WS	1		:LAST MINUTE'S CPS IN FOR NODE'S LINK
NSCPHO	WS	1		:NODE'S CPS OUT HI-WATER MARK
NSCPHI	WS	1		:NODE'S CPS IN HI-WATER MARK
MTLTIM	HS	1		:LAST TIME LINK TRAFFIC MEASUREMENT WAS DONE
MTLFST	HS	1		:LIKE MTLTIM BUT IN FASTC UNITS
MTTINT	HS	1		:TIME INTERVAL BETWEEN TWO LINK TRAFFIC MEAS.

:	Physical addr of NS.PCO (PHPCPS) sent to ISIS in SVC SYS,$A 51
:	in NSTART if SPAM enabled.  Expects FW storage for NS.PCO and NS.PCI.
NS.PCO	WS	1		:last minute's Physical CPS Out
NS.PCI	WS	1		:last minute's Physical CPS In
NS.PHO	WS	1		:node's Physical CPS Out Hi-water mark
NS.PHI	WS	1		:node's Physical CPS In Hi-water mark
NS.ITL	WS	1		: time of max nodal input logical cps
NS.OTL	WS	1		: time of max nodal output logical cps
NS.ITP	WS	1		: time of max nodal input physical cps
NS.OTP	WS	1		: time of max nodal output physical cps
ns.swd	ws	1		: software delay
ns.hwd	ws	1		: hardware delay
       IF	SUPER
SUP.IT	WS	1		: time of max SUP input cps
SUP.OT	WS	1		: time of max SUP output cps
KER.IT	WS	1		: time of max Kernel input cps
KER.OT	WS	1		: time of max Kernel output cps
       EI	:SUPER


MTRSAV	WS	1		:register save area for MTRFIC routine	###wjl

shrksv	WS	10		:REGISTER SAVE AREA USED IN 'SHRINK' (YAKYAK)

:	LINKER line descriptor arrays indexed by line number
NGSVLN	HS	NLINES		:LAST NEIGHBOR ON LINE
KDSVLN	WS	NLINES		:LINK TO WHICH LINE WAS LAST ATTACHED
DREASN	BS	NLINES		:REASON FOR DETACH 2= NO REC, 3= RESET
RREASN	BS	NLINES		:Reason for Reset **to be implemented**
RESETE	HS	NLINES		:RESET KEY FOR STEP E
RESETF	HS	NLINES		:RESET KEY FOR STEP F
BAUDRT	HS	NLINES		:LINE SPEEDS
BAUDRR	HS	NLINES		:real LINE SPEEDS (not limited to MS = 1f)
LNRTIM	HS	NLINES		:FOR COMPUTING LINE SPEEDS
LNRPOS	HS	NLINES		:DITTO
LINTIM	WS	NLINES		:FOR EACH LINE, TIME OF LAST ATT/DET
LNETID	HS	NLINES		:NETID for each line
BNETID	HS	NLINES		:neighbor of netid mismatch		###sdw
rtrdel	hs	nlines		:delay wait for retrans pacing		###sdw
:	The following are for gathering statistics
KL.RRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (RCTRNS)
KL.RSV	HS	NLINES		:COUNT DURING LAST MINUTE (RCTRNS)
LINERR	HS	NLINES		:LINE STATISTICS - NOISE
SPACNG	HS	NLINES		:SPACING (ALL ZEROES) DETECTED ON INPUT
BADACK	HS	NLINES		:BAD ACKNOWLEDGEMENTS
BADRCN	HS	NLINES		:BAD RECORD #'S
BADCSM	HS	NLINES		:BAD CHECKSUMS
RCRXMT	HS	NLINES		:RETRANSMISSIONS RECEIVED
LXMSET	HS	NLINES		:NUMBER OF RETRANSMISSIONS CONSIDERED
KL.LRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (LXMSET)
KL.LSV	HS	NLINES		:COUNT DURING LAST MINUTE (LXMSET)
LCROSS	HS	NLINES		:CROSS-TALK ERRORS
TRRXMT	HS	NLINES		:RETRANSMISSIONS SENT
KL.TRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (TRRXMT)
KL.TSV	HS	NLINES		:COUNT DURING LAST MINUTE (TRRXMT)

:	The following are sync-unique parameters
CONFSG	HS	NLINES		:# CONSECUTIVE 4-SEC GAPS WITH NO RECORDS RCVD
:	OVER TYMNET-I LINK (TAKE LINK OUT AFTER 16 SECONDS)
FOURSG	HS	NLINES		:TOT # 4-SEC GAPS WITH NO RECORDS RECEIVED
:	OVER TYMNET-I LINK (FOR STATISTICS)
SYLLNK	WS	NLINES		:save return for SYLXRS
	
XRSTBT	HS	(NLINES+7)/8	:reset type bit array - by LN*2 and (LN*2)+1
XRBGUY	HS	(NLINES+7)/8	:link down since neighbor on bguy list

:	VARIABLES FOR TEMPERATURE REPORTING--RANGES AND DELAY TIME.	###JHL
TMCHFG	HS	1		:FLAG TO DISABLE TEMP CHECK (NON-0 IS OFF)
INHTMP	HS	1		:FLAG FOR INHIBITING TEMP RPTING TO 1/HR
	SYAD(TMCHFG)		:LET USER FIND FLAG TO SET IT		###JHL

:	DATA AREAS FOR GMT ROUTINES
CYRCOD	HS	1		:=0 IF CURRENT YEAR IS LEAPYR,ELSE 1,2,OR 3
GMTSLC	WS	1		:SLOWC TIME AT TIME WE GOT BASE GMT
GMTHEX	WS	1		:BASE GMT SEC'S INTO CURRENT YEAR CORRESPONDS
				:TO GMTSLC + 1DAY
GMTNOW	WS	1		:CURRENT GMT
CYRMAX	WS	1		:NO. SEC'S IN CURRENT YEAR + 1 DAY
GETGMT	HS	1		:FLAG WHETHER TO GET GMT FROM SUP (ONLY IF
				:=0), IE ONLY AFTER CRASH/TAKEOVER.
NODSLC	WS	1		:SLOWC AT STARTUP
XYSAVE	WS	1		:SAVE AREA FOR CRYPTO/GMTCAL
SUPTIM	WS	1		:RAW GMT FROM SUP
SUPSLC	WS	1		:SLOWC EQUIVALENT OF SUPTIM

CNTXOR	HS	1		:FOR COUNT0/1 IN XRAY.
XQUEC	HS	1		:CURRENT XRAY USER QUEUE
XQUEM	HS	1		:MASTER XRAY USER QUEUE
XNINT	BS	10		:XRAY USER SLOT NO. BY INTERNAL HOST PORT NO.

BFZPRS	HS	20		:REG SAVE AREA FOR BUFFER ZAP ROUTINE (BUFZAP)

::*********************************************************************
::
::	XRAY VARIABLES:
::
::*********************************************************************

BFLTHS	HS	8
BFLTHG	WS	8		:BUFFERLET USE HISTOGRAMS
BZAPCT	HS	1		:COUNT OF BUFFER ZAPS

EXPSSV	HS	1		:SAVE AREA FOR EXEPSW FOR TR COMMAND
xpmciu	hs	2			:lock for xray PM cmd
xpmnqe	hs	2			:ensure circuit was not zapped and
					:rebuilt during PM
XTDASC  hs	1			:1 if doing ascii display (TA)
XTDESC  hs	1			:1 if showing escaping (TE)
XTDATO  hs	1			:1 if doing continous display (Y option
XTDCPT  HS	NXUBLK  		:last displayed for continous display
XTDLNZ  HS	NXUBLK  		:line display size (depends on mode)
XTDMSN  hs	NXUBLK

LOSEG0	HS	0	:END OF NODE CODE'S SHARE OF FIRST 16K OF SEG 0

       if	.-3fff
	REMARK%%%%
	REMARK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%
	REMARK!!!  FATAL CONFIGURATION ERROR             !!!%
	REMARK!!!  ASSEMBLY HAS BEEN KILLED              !!!%
	REMARK!!!  OVERFLOW OF RX1 ADDRESSABLE MEMORY IN !!!%
	REMARK!!!  SEG 0.  PLEASE REPORT TO SUPPORT AND  !!!%
	REMARK!!!  REDUCE THE CONFIGURATION.             !!!%
	REMARK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%%%%%
	KILLER(1)
       ei	

:	NOTE: DATA AREAS DEFINED FROM HERE CANNOT BE ASSUMED TO
:	BE RX1 ADDRESSABLE.

::*********************************************************************
::
::	ATTENTION FLAGS:
::
::*********************************************************************

BEGZRO	WS	0
NFLAGS	WS	0
	SYAD(NFLAGS)
FLAGS	WS	0
CRQFLG	WS	1		:ALL SAVE LO-ORD BIT UNUSED
LEPFLG	HS	1		:LEPRECHAUN FLAGS
INTFLG	HS	1		:INTERNAL HOST FLAGS
KERFLG	WS	(NKU+1F)/20	:KERNEL PORT FLAGS (1/PORT)
SUPFLG	WS	NSP/20		:SUP FLAGS (1/PORT)
DISFLG	WS	(NDP+1F)/20	:DISPATCHER FLAGS (1/PORT)
LNKFLG	WS	TCHANS/20	:LINK CHANNEL ATTN FLAGS (1/CHAN)
ILCFLG	WS	NLINKW		:ILC FLAGS (1/LINK)###sln
BPMFLG	WS	NLINKW		:BPM FLAGS (1/LINK)###sln
DETFLG	WS	1		:DETACHED PORTS
ENDFLG	HS	0		:LAST FLAG ADDR+1

::*********************************************************************
::
::	aaaZFL:	Absolute channel numbers corresponding to processes'
::		relative channel 0.
::
::*********************************************************************

CRQZFL	EQ	(CRQFLG-NFLAGS)*8+1F	:CRQ.
STUBFL	EQ	CRQZFL-1		:Circuit stub in process of rebild.
INCPFL	EQ	STUBFL-1		:Circuits in intercept state (see CRQ)
EARLFL	EQ	INCPFL-1		:Early data from??? T-I z-flag.
ILCZFL	EQ	(ILCFLG-NFLAGS)*8	:Interlink control
BPMZFL	EQ	(BPMFLG-NFLAGS)*8	:Backpressure monitor
LEPZFL	EQ	(LEPFLG-NFLAGS)*8	:Leprechaun
KERZFL	EQ	(KERFLG-NFLAGS)*8	:Kernel
SUPZFL	EQ	(SUPFLG-NFLAGS)*8	:Supervisor
DISZFL	EQ	(DISFLG-NFLAGS)*8	:Dispatcher
	SYAD(DISZFL)
INTZFL	EQ	(INTFLG-NFLAGS)*8	:Internal host ports
LNKZFL	EQ	(LNKFLG-NFLAGS)*8	:Links
LNKLFL	EQ	LNKZFL+TCHANS	 	:Last link flag + 1
DETZFL	EQ	(DETFLG-NFLAGS)*8	:Detached ports
ENDZFL	EQ	(ENDFLG-NFLAGS)*8	:Last flag +1

mnachn	eq	0			:default
	if	t2gate
MNACHN	EQ	diszfl
	ei
	if	intacc		:if gateway and intacc then is still intzfl
MNACHN	EQ	INTZFL
	ei

MXACHN	EQ	MNACHN+NACCTS	:Highest accountable  channel number

::	ACP:	ACTIVE PORTS
::		ACtive-Port bit array, corresponds exactly to the node's
::		absolute channel numbers.  A set (1) bit means a port
::		(channel) is available.  A reset (0) bit means the channel
::		is in use.  Note that the negative portion of the ACP array
::		(from ACPBQE to ACP) is a mirror image of the positive
::		portion of ACP.  Negative ACP is used for top-down channel
::		assignment on T-II links on which we are the master.

ACPBSE	WS	0		:The bottom (lower limit) of negative ACP.
	SYAD(ACPBSE)
	WS	1		:DET
	WS	2*NLINKW	:BPM, ILC	###sln
	WS	TCHANS/20	:NEGATIVE MIRROR OF LNKACP
EKNACP	WS	0		:End of link portion of negative ACP.
	WS	(NDP+1F)/20
	WS	NSP/20
	WS	(NKU+1F)/20
	WS	2		:CRQ, LEP, INT HST
ACPSZN	EQ	.-ACPBSE	:Size of negative ACP (must = ACPSZP).

ACP	WS	0		:Start of positive ACP.
	SYAD(ACP   )
CRQACP	WS	1		:CRQ (unused).
LEPACP	HS	1		:Leprechaun.
INTACP	HS	1		:Internal host.
KERACP	WS	(NKU+1F)/20	:Kernel
SUPACP	WS	NSP/20		:Supervisor
DISACP	WS	(NDP+1F)/20	:Dispatcher (ISIS only)
LNKACP	WS	TCHANS/20	:Link channels
ILCACP	WS	NLINKW		:Inter-link control (unused)	###sln
BPMACP	WS	NLINKW		:BPM??? (unused)		###sln
DETACP	WS	1		:Detached ports
ACPSZP	EQ	.-ACP		:Size of positive ACP (must = ACPSZN)

	IF	ACPSZN%ACPSZP
	REMARK	%!!ACP ALLOCATION ERROR!!%
	KILLER(1)		:kill assembly
	EI 	:ACPSZN%ACPSZP

::	CHS:	CHANNEL SUSPENDED ARRAY
::		CHannel-Suspended bit array.  Same structure as ACP
::		(positive and negative portions, a bit for each channel,
::		0-bit means channel suspended).  A channel is temporarily
::		suspended to allow a recent zapper to clear a circuit.
::		A link channel is considered available only if its ACP and
::		CHS bits are set.  SWITCH initialization expects CHS to
::		follow ACP.

CHSBSE	WS	0		:Bottom of negative CHS
	WS	1		:DET		###sln
	WS	2*NLINKW	:BPM, ILC	###sln
	WS	TCHANS/20
EKNCHS	WS	0		:Top of links' negative CHS
	WS	(NDP+1F)/20
	WS	NSP/20
	WS	(NKU+1F)/20
	WS	2		:LEP, INTERNAL HOST
CHS	WS	0		:Beginning of positive CHS
	SYAD(CHS   )		:ORIGIN OF CHS ARRAY
	WS	2		:LEP, INTERNAL HOST
KERCHS	WS	(NKU+1F)/20	:KERNEL
	WS	NSP/20		:SUPERVISOR
	WS	(NDP+1F)/20	:DISPATCHER
LNKCHS	WS	TCHANS/20	:LINKS
	WS	2*NLINKW	:ILC, BPM	###sln
	WS	1		:DET		###sln

:	CHSRVD and LNKBPV must be in seg 0 since their addresses are stored as
:	halfwords in several places.
LNKBPV	WS	TCHANS/20	:RCVD BACK-PRESSURE RELIEF (ENABLE SERVICE)
CHSRVD	WS	TCHANS/20	:CHANNEL SERVICED FLAGS (1/CHAN)

       if	super		:moved out of low seg 0
SUPSVD	WS	NSP/20		:SUP SIMILAR
SUPBPV	WS	NSP/20		:RESET IF BP'D FROM NODE-->SUP
SUPBPX	WS	NSP/20		:RESET IF BP'D FROM SUP-->NODE
       ei	:super


::*********************************************************************
::
::	SWITCH VARIABLES:
::
::*********************************************************************

CDSC	BS	NRECDS*CDSZ	:Packet record descriptors

:	Data structures for buffer delay timer pairs
	IF	BFLTMR		:###JHL
BFDARY	WS	TCHANS/20	:a bit for each link channel
BFDEND	HS	0		:end marker for COPY instruction
BFDSCH	HS	1		:EXEC cell for scheduling from G08SEC
BFDFRQ	EQ	4		:# times G08SEC runs per sched of BFRUPD
BFDOPT	HS	1		:cell to select bfr timer use in XRAY
	EI	:BFLTMR		:###jhl
:::

:	DEFINE WORK AREAS ASSOCIATED WITH NEEDLE TIMING
	DEFAULT(NEDTSZ,RATE/4)	:DEFAULT SIZE OF NEEDLE TIME HISTOGRAM - ALLOW
				: FOR UP TO 1 SECOND, RECORDED IN FASTC/4 UNITS
NEDHST	HS	NEDTSZ/2	:NEEDLE TIME HISTOGRAM
	SYAD(NEDHST)

KERUSR	BS	40		:USER NAME STRING OF LAST KERNEL LOGIN
	SYAD(KERUSR)

XUBLK	BS	XUBSZ*NXUBLK	:XRAY USER BLOCK AREA
	SYAD(XUBLK )

:	STORAGE AREA FOR ISIS-STYLE TRAPS
	IF	1-\NTRAP
NTRAP   EQ	4
	EI

	WS	0
TRPREG	WS	10*NTRAP	:SAVE AREA FOR TRAP REGISTERS
TRPPSW	WS	2		:how to return from a sprung trap
TRPADR	WS	NTRAP		:FOR TRAP PC
TRPXD	WS	NTRAP		:TRAP OWNER
TRPSAV	WS	2*NTRAP		:FOR CLOBBERED MEMORY
TRPTIM  WS	NTRAP   	:time of trap springing
TRPCNT  HS	NTRAP   	:how many springs left
TRPFLG	HS	1		:AND FOR TRAP SPRUNG INDICATION

DBCRSV	WS	2


	SUBTTL	DATA (SEGMENT 1 START AND TEXT AREA)

::*****************************************************************
::
::	SEGMENT 1 - CODE and TEXT
::
::*****************************************************************

	SEG.(a.code)			:SEGMENT 1 DATA BEGINS HERE
	ORG	seg1

VERSSV	WC	VERSION		:VERSION # ALWAYS AT start of code
CRACTN	HC	CRSTOP		:CRASH STOP OPTION


::*********************************************************************
::
::	FAIL:	RESTART SVC FOR NODE
::
::*********************************************************************

FAIL	WS	2			:PSW
	WS	2			:R0,R1
	STH	R1,CRSHID		:SAVE CRASH CODE
	SIS	R1,1			:IF POWER UP OR MANUAL RESTART, 
	JLE	NSTART			: INIT NODE WITHOUT SAVING REGS, ETC...
	TS	CRTYPE			:INDICATE NOT OOPS CRASH
	L	R1,FAIL+4		:SAVE CRASH ADDRESS
	ST	R1,CRSHAD		:AS SUPPLIED BY ISIS
	L	R1,FAIL			:CRASH PSW
	ST	R1,CRSHPS
	L	R0,FAIL+8		:SAVE REGISTERS
	L	R1,FAIL+0C
	J	SFAIL			:PROCEED AS USUAL

REBCEN	HC	REBILD			:REBUILD CONTROL CHARACTERS ENABLED
	SYAD(REBCEN)	
REBREN	HC	1			:REBUILD REQUESTS ENABLED
	SYAD(REBREN)	

::*********************************************************************
::
::	TABLE:		DETMTB:
::	FUNCTION:	CANNED DETACH MESSAGES
::
::*********************************************************************

	NOLIST
DETM00	SC	/"8A"8Ddestination node out of ports/
DETM01	SC	/"8A"8Dhost out of ports./	:NC DETECTED
DETM02	SC	/"8A"8Dhost out of ports!/	:SLOT DETECTED
DETM03	SC	/"8A"8Ddestination node out of kernel ports/
DETM04	SC	/"8A"8DKernel SIO ring interface down/
DETM05	SC	/"8A"8Dout of xray slots/
DETM06	SC	/"8A"8Dxray slot overridden/
DETM07	SC	/"8A"8DBAD XRAY USERNAME/
	IF	T2GATE
DTM08X	HC	DTM08L
DETM08	EQ	DTM08X+1
	AC	/inter-link cleared from /
	IF	NETNAM
	HNAME()
	ELSE
	AC	/HOME NETWORK/
	EI	:NETNAM
	AC	/ to /
	IF	NETNAM
	INAME()
	ELSE
	AC	/ISIS NETWORK/
	EI	:NETNAM
	AC	/"8D"8A/
DTM08L	EQ	.-DETM08-1
	EI	:T2GATE
	LIST

DETMTB  HC	DETM00-SEG1,DETM01-SEG1,DETM02-SEG1,DETM03-SEG1,DETM04-SEG1
	HC	DETM05-SEG1,DETM06-SEG1,DETM07-SEG1
	IF	T2GATE
	HC	DETM08-SEG1
	EI	:T2GATE

:	define msgs if the new connect svc fails.  routine puts the return
:	reason+30x so if get weird reason from isis it is not invisible.
       if	ksvc62
ksvcm0	sc	/"0d"0aConnect to KIO failed:  Code /
ksvcm1	sc	/ = Invalid parameter block address"0d"0a/
ksvcm2	sc	/ = Port in use"0d"0a/
ksvcm3	sc	/ = Port number out of range"0d"0a/
ksvcm4	sc	/ = Invalid ring addresses"0d"0a/
ksvcm5	sc	/ = Rings cross segment boundary"0d"0a/
ksvcm6	sc	/ = Invalid address pointer KOF"0d"0a/
ksvcm7	sc	/ = Invalid address pointer KOFF"0d"0a/

KSVCMF	SC	/Retrying Connect without port number."0d"0a/

:	define a table which points to them.  Note that table begins with
:	an offset as there is no entry for 0.
	hs	0
ksvcms	eq	.-2
q	eq	1
	re	7
	hc	ksvcm|q|-SEG1
q	eq	q+1
	er
       ei	:ksvc62

	SUBTTL	DATA (SEGMENTS 2 & 3 - Buffer Descriptors)

::*********************************************************************
::
::	SEGMENT 2 & 3 - Buffer Descriptors, DMA Region, and Link Tables
::
::*********************************************************************

	SEG.(0)
SEG2	HS	0
CRQBUF	EQ	0		:CRQ LIST BUFFER
LOGBUF	EQ	4		:LOGGER DITTO
NCCBUF	EQ	8		:TEMPORARY BUFFER WHEN NO COMMAND CIRCUIT
ILCZBF	EQ	10		:# OF ILC BUFF FOR LINK 0
BPMZBF	EQ	ILCZBF+8*NLINKS	:# OF BPM BUFF FOR SAME
CIRZBF	EQ	BPMZBF+8*NLINKS	:# OF FIRST AVAILABLE BUFFER
HBUFN	EQ	8*NCIRCS	:NUMBER OF FIRST HISTORY BUFFER
	SYAD(HBUFN )
LBUFN	EQ	0C*NCIRCS	:LAST LEGAL BUFF # (PLUS 4)

:	CHARACTER BUFFERS:
:	IF CONFIGURATION HAS REBILD ENABLED, THE NUMBER OF BUFFERS REQUIRED
:	IS 3*NCIRCS. IF REBILD = 0, ONLY 2*NCIRCS BUFFERS REQUIRED.

	IF	REBILD
BUFFAC	EQ	3
	ELSE	:NOT REBILD
BUFFAC	EQ	2
	EI 	:REBILD

BB	WS	BUFFAC*NCIRCS	:NEXT CHARACTER OUT PTR
	SYAD(BB    )
BE	WS	BUFFAC*NCIRCS	:LAST CHARACTER IN PTR
	SYAD(BE    )
BBSIZE  EQ	BE-BB
BF	WS	BUFFAC*NCIRCS	:ATTENTION FLAG POINTER
	SYAD(BF    )
BCT	EQ	BF+2		:BYTE COUNT (INTERLEAVED W/ BF)

BUFTIM	WS	NCIRCS		:USED TO TIME NEEDLES IN FASTC UNITS. WHEN
:	NEEDLE COMPLETES CIRCUIT BUILDING, BUFTIM WILL CONTAIN SLOWC
:	TIME THAT CIRCUIT BUILDING WAS COMPLETED. ALSO USED TO TIME
:	OUT PORTS IN LOGIN THAT HAVE SENT FROM TID UP TO BUT NOT
:	INCLUDING SEMI-: OR 'CR'.  AFTER THAT THE SUP TIMES THEM OUT.
:	ALSO USED TO TIME OUT DETACHED PORTS DUE TO OUR DISCOVERY OF
:	'OUT OF DISPATCHER PORTS', ...

	if	bbsize-0ffff
	remark%%Too many circuits enabled.  Impossible configuration.
	Remark%%Assembly aborted.  Turn off rebuild or reduce number
	remark%%passthroughs and dispatcher ports.
killit	eq	1
	ei


	if	macv			:if mac v then SIO stuff goes into seg
	seg.(03)			:3 (our dma segment)
seg3	hs	0			:for memrmk
	ei	:not macv


..simc	macro[
	IF	SILINS
:	>>NOTE--FOLLOWING MUST NOT CROSS 100 BOUNDARY<<
:	A SIO output chain cannot cross 100 boundary, other stuff can
:	note that jump ccws can cross 100 boundary.  The init CCWs are
:	of len 20 starting on a multiple of 20 so a chain will not cross
:	a 100 boundary.  The output ccws use jumps and thus have no worries.
	BND	20		:QUAD WORD BOUNDARY
Q	EQ	0
	RE	SILINS  	:for each line
SOPG|Q| WS	8		:7 CCWS FOR HDLC INITIALIZATION
Q	EQ	Q+1
	ER	:SILINS

Q	EQ	0
	RE	SILINS
SIOD|Q| BS	10*(NCHA|$a q+sylins|)	:the chains for this line
Q	EQ	Q+1
	ER
SIOBLI  WS	4*SILINS	:CCW FOR INPUT
SIOBLR	WS	0C*SILINS	:for Expanded Reset
SIOSTT  WS	4*SILINS	:STATUS BLOCKS
:	note the output buffer is also used for the Line Tester which
:	is why it is now 80 from 42
:	also moved to sio dma area since it should have been here all
:	along and removed the stupid sio duplicate sio logic for doing
:	dloads.
	EI	:SILINS		:DWOBUF is needed for all sync as well
       IF	CHBOOT
CNBRBT	BS	DWLBSZ		:return to boot
CNBREC	BS	DWLBSZ		:boot request which has special data
       EI	:CHBOOT
DWOBUF	BS	(TINTCH-NUMXLT)*DWLBSZ	:OUTPUT for line dloads only
	BS	NUMXLT*XLTPSZ		:output for line tester or dloads

	IF	silins		:more sio stuff
SIBUF	ws	0
q	eq	nlines-silins
      re	silins
.lka|$a q|	BS	.lkz|$a q|	:input area is variable
q	eq	q+1
      er	:silins
SIOXQW	WS	4		:SIO MOTHER BOARD NEEDS EXTRA QUAD WORD###LSH
SIOEND	EQ	.		:END OF SIO DMA AREA
	ei	:silins
]

:	to handle the big we have to find out how big the sio area will be.
:	the way this is done it cannot handle something doing a forward
:	reference to any of the locations in ..simc so watch out!!
	if	silins
qqq	eq	.		:save pc
	..simc
siosiz	eq	.-qqq+20
	org	qqq		:restore pc
	ei	:silins

:	bit of logic to handle large configs.  trouble is that sio dma region
:	is limited to 20000 (2 segs) so idea is to put as many records before
:	the sio stuff then put rest after that (and killing if it is still
:	too many records).  changes to initializing brec and attlin has to call
:	sioiz0 to reinit the line and sioiz0 sees where to set the dma window.

bigcon	eq	0
	if	silins
	if	((nrecds/2)*orcbsz)+siosiz-20000
bigcon  eq	1		:we have the big config
	ei ; ei

:	make sure the SIO areas has left some room for output records.
:	if no space available then config will have to have fewer SIO
:	lines before having room for packets.
      IF	SILINS
       IF	SIOSIZ-20000		:
	remark %%FATAL ERROR:  SIO area overflow.
	remark %Too many SIO lines and/or too many 256KB SIO lines declared.
	remark %Number of SIO lines must be significantly reduced as
	remark %this configuration does not have room to put any packets
	remark %for any of the links.
	remark %   Assembly killed.
	quit 1			:too many assembly errors if continue
       EI
      EI	:SILINS

:	now see how many packets fit before the sio stuff and how many
:	will follow.  Note that if more follow than fit prior then the
:	ones following do not fit and config must be reduced.
	if	bigcon
nrecd0  eq	(20000-siosiz)/orcbsz	:records before sio
nrecd1  eq	(nrecds/2)-nrecd0	:the rest
       if	nrecd1-nrecd0		:half the output has to be in 1st 1/2
	remark %%Too many windows declared for the number of sio lines.
	remark %Reduce by 
	number $A(NRECD-NRECD0)
	remark% d.  Assembly killed.
	killer(1)
       ei	:too big
	else    :not bigcon
nrecd0  eq	nrecds/2
	ei	:bigcon

	if	silins
	bnd	10		:for sio nocopy the len of packet goes
	hs	1		:before each record
	ei	:silins
RECBUF  BS	nrecd0*oRCBSZ   :as many of the output buffers that fit

::	SIBFRL forced to 1 and SIO is put right after the records so don't
::	have to copy from record to sio output area.  simply give the address
::	of the record buffer and insert the count and transmit from the the
::	record buffers.						###sdw

:	declare input areas for sio and line tester and dload and such
..simc
	if	silins
	SYAD(SIBUF )
	SYAD(SIOSTT)
	ei	:silins

:	if these are output records then must be aligned with len HW
:	on quadword prior to record.  11/11/93
       IF	BIGCON
	BND	10
	HS	1			:len of sio output position
       EI	:BIGCON

RECBU1	BS	0			:start of rest of records

       IF	BIGCON
	BS	NRECD1*ORCBSZ   	:rest of the output records
       EI	:BIGCON

:	according to bigcon and NRECD1/NRECD0 calculations the following
:	can never happen.
      IF	SILINS			:only if sio
       IF	SIOEND-RECBUF-20000	:sio isn't fitting
	remark %%Fatal Error.  Record buffers are not all within one
	remark%%SIO DMA region.  Serious code problem.  Please Panic.
	killer(1)
       EI
      EI	:silins

	bs	(nrecds/2)*recbsz	:the input records

:	general output rotor is set up to emulate the SIO CCWs.  the first
:	and third rotors are used for output.  The second and fourth rotors
:	are used to jump to the third and first rotors, respectively.  This
:	allows putting the output rotors (1,3) the same distance (16 bytes)
:	and linked the same as the SIO CCWs.  So the output logic can be
:	largely done without caring about sync and SIO.
	BND	10
OROTOR  BS	4*8*(NLINES-SILINS)	:general output rotor

SDSC	BS	NLINES*SDBSZ	:RESET DATA BUFFERS

	if	macv			:restore to seg 0 for rest of data
:	Bufferlet Area at end of dma segment
	ORG	(./CBSZ)*CBSZ+CBSZ
	HS	1
CHRBU0  HS	0		:for dma segment bufferlets
	SYAD(CHRBU0)
	seg.(0)			:restore putting data into seg 0
	ei	:macv

:	buffers for sending downline load records and receiving the
:	echo from the neighbor
DWIBUF	BS	TINTCH*40	:DOWNLINE-LOAD BUFFERS - INPUT

::	Generate link descriptor block space for all link types		###ev
Q	EQ	0
KDSC	BS	0
	SYAD(KDSC  )
	RE	(NLINKS-1)		:For all except last link, allocate
	BS	KDSZ			:or regular TII link size.
Q	EQ	Q+1			:Next link please
	ER
KDLST	BS	KDSZ			:Last link begins here



KNNLAT	HS	NLINKS			:USED BY LNCHCK TO DETERMINE MAX NUMBER
					:OF LINES PER LINK TO DETACH
RTPAGE	HS	NLINKS			:CHANNEL PAGE #'S
RMPAGE	HS	NLINKS
LKOVLD	HS	NLINKS			:LINK OVERLOAD COUNTERS
LKSTCT	HS	NLINKS			:LINK SATURATED COUNTERS
SNPTYP	HS	NLINKS			:LINK SNIP TYPE IF NON-ZERO
MASTKN	BS	NLINKS			:MASTER/SLAVE INDICATOR FOR T-II LINKS
LKZFKN	HS	NLINKS			:# OF CHANNEL 0 FLAG FOR EACH LINK
	SYAD(LKZFKN)
TBDPKN	HS	NLINKS+1		:START OF TABLES FOR EACH LINK (EXTRA
					:ONE NEEDED BY BUBBLE)
EBDPKN	HS	NLINKS			:END OF TABLES FOR EACH LINK
FLDPKN	HS	NLINKS			:START OF FLAGS FOR EACH LINK
LKAPND	HS	NLINKS			:PTR TO LAST HW OF ACTIVE PORT ARRAY
LKCSND	HS	NLINKS			:PTR TO LAST HW IN CHAN SUSP ARRAY
LKNEDS	HS	NLINKS			:NO. OF TIMES NEEDLE GOBBLED BY ZAPPER

::	CHS1, CHS2:
::		are used to cause a suspended channel (CHS) to become
::		available 30-60 seconds after a zapper has traveled.  When
::		CHS is reset, CHS1 is set.  Every 30 seconds, CHS2 is OR'd
::		into CHS and CHS1 is copied into CHS2.  Same layout as CHS.

	WS	0		:ENSURE WORD ALIGNMENT
	BS	ACPSZP		:CORRESPOND TO NEGATIVE CHS
CHS1	HS	0		:Center (negative below here, positive above)
	BS	ACPSZP		:CORRESPOND TO POSITIVE CHS

	WS	0
	BS	ACPSZP
CHS2	HS	0		:Center (negative below here, positive above)
	BS	ACPSZP

BPSVCP	WS	TCHANS/20	:COPY OF RECEIVED BP FLAGS (UPDATE T-PUT COUNT)
PRIRTY	WS	ENDZFL/20	:PRIORITY FLAGS (for all ports)
CMDCTS	WS	TCHANS/20	:COMMAND CIRCUITS
GUSH	WS	TCHANS/20	:SET FOR CHANNELS WITH DATA GUSHING IN
EGUSH	EQ	GUSH+TCHANS/8
       if	aplybp
ABPXCP	WS	TCHANS/20	:1 if transmit chn NOT actively BPed
				:ie 0 if neighbor sent apply BP
ABPVCP	WS	TCHANS/20	:1 if receive chn actively backpressured
				:ie. nc sent apply bp to neighbor
XGUSH	ws	tchans/20	:set to indicate transmitted recently
       ei	:applybp

:	Misc. bit arrays indexed by channel number

TRCHAN	HS	ENDZFL/10	:ARRAY FOR CHARACTER TRACING BY CHANNEL
	if	autrac
atrchn	HS	ENDZFL/10	:array for trchan bits sets by criteria
	ei	:autrac

NEEDLE	HS	TCHANS/10	:ARRAY TO RECORD NEW NEEDLE ON LINK CHANNEL

scratc	hs	tchans/10	:a scratch array for aranding various stuff

	IF	REBILD
:
:	NOTE THAT THERE IS ONLY A SINGLE 'SEQN' ARRAY, AND THE 'XSEQN',
:	'VSEQN' AND 'HSEQN' REDEFINITIONS ARE ONLY TO AVOID CONFUSION.
:
:	ALSO NOTE THAT SEQN IS A FULL-WORD ARRAY, SINCE BUFFER-NUMBERS
:	ARE DIVISIBLE BY 4. HOWEVER, NO GOOD USE HAS BEEN FOUND FOR THE UPPER
:	HW SINCE SEQUENCE NUMBERS ARE HW VALUES. THIS STORAGE COULD BE
:	COMPRESSED AT THE EXPENSE OF FREQUENTLY DIVIDING BUFFER NUMBER BY 2 AND
:	THEN RESTORING.
SEQN	WS	3*NCIRCS	:CHARACTER SEQUENCE #
	SYAD(SEQN  )
XSEQN	EQ	SEQN		:REDEFINITION - XMITTED SEQUENCE NUMBER
VSEQN	EQ	SEQN		:REDEFINITION - RECEIVED SEQUENCE NUMBER
HSEQN	EQ	SEQN		:REDEFINITION - HISTORY BUFFER SEQ NUMBER
HBSEQN	EQ	HSEQN+HBUFN	:CONVENIENCE CONSTANT
XBF	EQ	6
HBF	EQ	7		:R6,R7 USED IN CRQREB, CRQINT CODE
				: SPLIT ACROSS BUFFERLET

:	REBUILDABLE TERMINATION VARIABLES:

RBASE	EQ	.-HBUFN		:DESTINATION BASE
	SYAD(RBASE )
RHOSTN	EQ	RBASE+2		:DESTINATION HOST
	SYAD(RHOSTN)
	WS	NCIRCS
RNFLAG	EQ	.-HBUFN		:NEEDLE FLAGS
	SYAD(RNFLAG)
RHBSZ	EQ	RNFLAG+2	:SIZE OF HISTORY BUFFER
	SYAD(RHBSZ )
	WS	NCIRCS
RINVC	EQ	.-HBUFN		:INVOICE NUMBER INDEXED BY BUFFER NUMBER
	WS	NCIRCS

RBIBUF	EQ	RBASE		:TEMPORARY USE BY CRQREB
	SYAD(RBIBUF)
RBVSEQ	EQ	RINVC		:					###GT
	SYAD(RBVSEQ)
RBHIS	EQ	RHOSTN		:HIST BFR ASSOCIATED WITH RBIBUF	###CY
	SYAD(RBHIS )
RBKEY	EQ	HSEQN		:INVOICE ASSOCIATED WTIH RBIBUF		###CY
	SYAD(RBKEY )
	EI 	:REBILD

	SUBTTL	DATA (SEGMENT 4 - KERNEL Communications)

::*********************************************************************
::
::	SEGMENT 4 - KERNEL Communication Area
::
::*********************************************************************

       if	ikernl		:have isis KIO ports
:	KERNEL COMMUNICATION AREA
NEWLOG	WS	(NKU+1F)/20	:NEW LOGIN FLAGS (1/PORT)
	SYAD(NEWLOG)
KOF	WS	(NKU+1F)/20	:PORTS THAT HAVE CHARS FOR OUTPUT
KOFF	WS	(NKU+1F)/20	:TO OVERRIDE BACKPRESSURE
KPARMS	WS	4		:PARAMETER AREA FOR LOGON/ZAP SVC
KRINGS	BS	NKU*(KBSZ+4)*2	:KERNEL RINGS AREA
KQ	EQ	0		:POINTER OFFSET

:	DEFINE KERNEL RING STRUCTURE

Q	EQ	.		:REMEMBER WHERE WE ARE
	ORG 	0		:DEFINE KERNEL RING STRUCTURE
	BS	KBSZ		:OUTPUT RING (FROM KERNEL)
KOB	HS	0		:RING LABEL POINTS PAST END OF RING
NIO	HS	1		:OUT BUFF IN PTR (KERNEL INX)
NOO	HS	1		:OUT BUFF OUT PTR (NODE INX)
	BS	KBSZ		:INPUT RING (TO KERNEL)
KIB	HS	0		:RING LABEL POINTS PAST END OF RING
NII	HS	1		:IN BUFF IN PTR (NODE INX)
NOI	HS	1		:IN BUFF OUT PTR (KERNEL INX)
	ORG	Q		:GO BACK TO THE REAL WORLD
	WS	0
       ei	:ikernl		:have isis KIO ports

S4END	hs	0

	SUBTTL	DATA (SEGMENT 5 - Supervisor Communication Area)

::*********************************************************************
::
::	SEGMENT 5 - Supervisor Communication Area
::
::*********************************************************************

:	a little useful macro to define negative sup rings
.suprg	macro(base,size,name,fill,empty)[
base	HS	0		:BASE OF RING
	SYAD(base)
	HS	size/2		:RING DATA 
name	HS	0		:THE RING'S NAME
fill	HS	1		:FILL INDEX FOR RING
	SYAD(fill)
empty	HS	1		:EMPTY INDEX FOR RING
	SYAD(empty)
]
      IF	SUPER   	:ISIS supe shares in seg C now  	###sdw
	SEG.(0C)
      EI	:SUPER

:	SUPERVISOR COMMUNICATION AREA

	IF	SUPER

:	ring input/output order is reversed in SPLIT vs normal sup.

       if	split
SIRX	bs	8		:SIO status of each RC motherboard
SIRXMY	eq	sirx+srmadr-90	:Status of the mboard nc is using

	.suprg(SOBBSE,SUPBSZ,SOB,NISO,NOSO)	:sup data output ring
	.suprg(SIBBSE,SUPBSZ,SIB,NISI,NOSI)	:sup data input ring

	.suprg(SOBPBS,SOBPSZ,SOBP,NISOBP,NOSOBP) :sup output backpressure ring
	.suprg(SIBPBS,SIBPSZ,SIBP,NISIBP,NOSIBP) :sup input backpressure ring

	.suprg(SOCBSE,SOCSZ,SOC,NISOC,NOSOC)	:sup output control ring
	.suprg(SICBSE,SICSZ,SIC,NISIC,NOSIC)	:sup input control ring

       else	:normal isis sup
	WS	1		:RINGS START AFTER 1 WORD INTO SEGMENT!
	.suprg(SIBBSE,SUPBSZ,SIB,NISI,NOSI)	:sup data input ring
	.suprg(SOBBSE,SUPBSZ,SOB,NISO,NOSO)	:sup data output ring

	.suprg(SIBPBS,SIBPSZ,SIBP,NISIBP,NOSIBP) :sup input backpressure ring
	.suprg(SOBPBS,SOBPSZ,SOBP,NISOBP,NOSOBP) :sup output backpressure ring

	.suprg(SICBSE,SICSZ,SIC,NISIC,NOSIC)	:sup output control ring
	.suprg(SOCBSE,SOCSZ,SOC,NISOC,NOSOC)	:sup input control ring
       ei	:split
	kill	.suprg

S5end	hs	0

	SEG.(0)
	EI 	:SUPER

	SUBTTL	DATA (SEGMENTS 6,7,8,9 - IOTAB and Bufferlets)

::*********************************************************************
::
::	SEGMENT 6,7,8,9 - BULK STORAGE (BUFFERLETS AND IOTAB)
::
::*********************************************************************

:	PERMUTER TABLES AND CHARACTER BUFFERLETS:

:	THESE MUST CORRESPOND EXACTLY TO THE ATTENTION FLAGS DEFINED
:	PREVIOUSLY.

IOTAB	HS	20			:NOTE FIRST 20 CHANNS UNUSED
	SYAD(IOTAB )
LIOTAB	HS	10			:LEPRECHAUN PERMUTER TABLE
INTTAB	HS	10			:INTERNAL HOST PERMUTER TABLE
KIOTAB	HS	((NKU+1F)/20)*20	:KERNEL PERMUTER TABLE
SIOTAB	HS	NSP			:SUPER PERMUTER TABLE
DIOTAB	HS	((NDP+1F)/20)*20	:DISPATCHER PERMUTER TABLE
NIOTAB	HS	TCHANS			:LINK PERMUTER TABLES
	SYAD(NIOTAB)
IIOTAB	HS	LKSIZE*8		:ILC PERMUTER TABLES	###sln
BIOTAB	HS	LKSIZE*8		:BPM PERMUTER TABLES	###sln
CIOTAB	HS	20			:DETACHED CIRCUITS

BPSCNT	HS	TCHANS			:LINK BACK PRESSURE COUNTERS
	SYAD(BPSCNT)

HISTBF	BS	HISTSZ			:HISTORY BUFFER
	IF	T2GATE
GDLGTB	HS	NDP		:Dummy permuter table for Gateway log-ins
GLGCNT	BS	NDP		:Log on char count storage I-net to H-net
	EI	:T2GATE

DLYBSE	HS	DLYBSZ*TINTCH/2	:START OF DATA BLOCKS FOR DELAY MEASUREMENT

:	DEFINE RINGS FOR NODE<-->ISIS DISPATCHER COMMUNICATIONS

DIRING	WS	0		:Dispatcher input ring (node==>ISIS).
	SYAD(DIRING)		: Structure required by ISIS.
DRIF	HS	1		:Fill index (node indexed)
DRIE	HS	1		:Empty index (ISIS indexed)
DIRNG	BS	DRSZ		:The ring itself

DORING	WS	0		:Dispatcher output ring (ISIS==>node).
	SYAD(DORING)		: Structure required by ISIS.
DROF	HS	1		:Fill index (ISIS indexed)
DROE	HS	1		:Empty index (node indexed)
DORNG	BS	DRSZ		:The ring itself

DHSTIX	HS	NDP		:Host # associated with each Dispatcher port
	SYAD(DHSTIX)

	if	1-t2gate
dlgsts  bs	ndp		:logon status for each port
	ei

LDNEVT  EQ	9		:9 table entries (see LDERTB in Linker)  ###sdw

LDTIME	WS	0
Q	EQ	0
	RE	LDNEVT
LDTIM|Q| WS	NLINES		:ONE LDTIMx ARRAY PER EVENT
Q	EQ	Q+1
	ER

::  allow counting of needles, logon rejects and input and output chars
::  for supervisor.

       IF 	SUPWAT
	WS	0
supwbg	hs	0			: start of sup watch data
SUPNED	HS	(NSP+4)*2		: total needles origing on this node
SUPCPO	HS	(NSP+4)*2		: total chars from sup
SUPCPI	HS	(NSP+4)*2		: total chars to supe
SUPREJ	HS	(NSP+4)*2		: number of type 0d msgs from supe
SUPILC	WS	NSP+4			: link count of needles starting here
SUPDLC	WS	NSP+4			: dest link count
SUPDND	HS	(NSP+4)*2		: dest needles for this nde
SUPIND	HS	NSP+4			: internal circuits for this node
supwen	hs	0			: end of sup watch data
       EI	:SUPWAT

:	to display GMT in SR cmd requires setting up parallel rings twice
:	as big as sup backpressure rings (each msg in bp ring is a hw while
:	gmt requires a fw).  no ring pointer needed as will use double
:	indexing of pointer into backpressure ring

       if	sr.gmt
spgmtr	hs	10*2		:need reg save area for calling gmtcal
	HS	SOBPSZ		:BACKPRESSURE FROM SUP
SOBPGM	HS	0
	HS	SIBPSZ		:BACKPRESSURE FROM NODE
SIBPGM	HS	0
       ei	sr.gmt

::**********************************************************************
::
::	X4TBBG	table used by X.409 parse logic to save information on
::		elements already scanned.
::
::**********************************************************************

       IF	LOGII
:	table into which parser puts info on each element
	HS	0		:ensure alignment
X4TBBG  BS	X4NENT*X4TBSZ   :store X.409 element info by parser
X4TBEN  HS	0		:end of table
	BS	X4TBSZ  	:extra one for overflow


::**********************************************************************
::
::	X4TBBG	table used by X.409 parse logic to save information on
::		elements already scanned.
::
::**********************************************************************

:	table for creating X.409 elements
	HS	0
X4CTBG  BS	X4NENT*X4CTSZ	:an entry for each element in contruction
	EI	:LOGII


 	SUBTTL	DATA (SYNC Input rings)

::*********************************************************************
::
::	SYNC-LINE INPUT BUFFER
::
::*********************************************************************

	if	sylins
SVNTIP	HS	1		:BUFFER INPUT POINTER
SVNTBF	BS	SVNBSZ		:SYNC-LINE INPUT BUFFER
	BS	(sylins-1)*(2+SVNBSZ)
	ei	:sylins

SBEND	hs	0

	SUBTTL	DATA (Table Storage)

::*********************************************************************
::
::	Table Storage
::
::*********************************************************************

SEGCRH	HS	0

CRYPRB	WS	0		:CRYPTO BUFFER FOR PASSING MESSAGES TO XRAY
	BS	CRYPRS

:	space for the audit log if enabled
       if	audsiz
AUDPRB	WS	0
	BS	AUDSIZ
       ei	:audsiz

:	space for the performance log if enabled
       if	pl.num
PL.PRB	WS	0
	BS	pl.num*pl.siz
       ei	:pl.num


::	STORE PACKETS ON CRASH
      IF	PKTSAV		:					###wjl
PCKTSZ	EQ	NRECDS*RECBSZ	:THE SIZE OF ALL THE PACKETS		###LSH
PCKTSV	WS	0		:					###LSH
	BS	PCKTSZ		:SAVE AREA FOR PHYSICAL RECORD BUFFERS
	SYAD(PCKTSV)		:(SAVED ON CRASH)
      EI	:PKTSAV

	IF	SILINS
	DEFAULT(PKSVSZ,400)	:DEFAULTED 400X BYTES
PAKSAV	HS	0
	SYAD(PAKSAV)
	BS	PKSVSZ
	EI	:SILINS			:THE LAST WORD IS THE CALLER'S ADDR.

	DEFAULT(BUFZSZ,400)
BUFZSV	WS	0		:###LSH
	BS	BUFZSZ		:SAVE AREA FOR A BUFFER TO BE ZAPPED
	SYAD(BUFZSV)		:FOR DEBUGGING.
	IF	PRIMSG
CRYPPB	WS	0
	BS	CRYPPS
	EI	:PRIMSG
	IF	DB.TRC		:OPTION(UTRC) in Tymfile		###wjl
TRSTAB	WS	0		:JUMP TRACE TABLE - SAVED ON CRASH
	BS	TRTBSZ
	EI	:DB.TRC
TRRING	WS	0
	SYAD(TRRING)
	BS	TRRSIZ		:CHARACTER TRACE RING
	if	1-autrac
TRIXSV	HS	1		:SAVE AREA FOR TRRIX (SAVED ON CRASH)
	SYAD(TRIXSV)
TRRSAV	WS	0
	BS	TRRSIZ		:SAME FOR TRRING
	SYAD(TRRSAV)
	ei	:1-autrac
DIRSAV	HS	0
	BS	DRSZ+4		:DIRING...
DORSAV	HS	0
	BS	DRSZ+4		:AND DORING

::	DISPATCHER RINGS DUMP ROUTINE STORAGE AREAS	###wjl
:	-------------------------------------------
IRING	WS	0		:STORAGE FOR DIRING OR DIRSAV
	BS	DRSZ+4
ORING	WS	0		:STORAGE FOR DORING OR DORSAV
	BS	DRSZ+4

RSEGC	HS	0	:SEGC INITED TO -1 UP TO THIS POINT, TO 0 AFTER HERE

	IF	DB.TRC		:OPTION(UTRC) in Tymfile		###wjl
TRSAVE	HS	6		:REG SAVE AREA FOR TRACE ROUTINE
TRCBEG	HS	2		:BEGINNING OF TRACE AREA
	SYAD(TRCBEG)
TRCEND	HS	2		:END OF TRACE AREA
TRCRFL	HS	1		:FLAG INDICATES IF PREVIOUS TABLE ENTRY WAS
				:IN RANGE (-1)
TRCRRQ	HS	1		:XRAY SETS TO -1 TO REQUEST SPECIAL TRACER
	SYAD(TRCRRQ)
TRNDEX  HS	1		:INDEX INTO TRACE TABLE
	SYAD(TRNDEX)
TRCTAB	BS	TRTBSZ
	SYAD(TRCTAB)
	EI	:DB.TRC


:	THE STORAGE FOR THE DEBUGGER		###LSH

HSUMRK	EQ	0BBBB		:HISTORY RING MARKER

	DEFAULT(LNFSIZ,400)	:DEFAULT RING SIZE FOR NON-SOLO CONSAT
	DEFAULT(CBZSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(BFSSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(LPGSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(LNKSIZ,1000)	:DEFAULT (extra big for interesting packets)

SAVSIZ	EQ	LNFSIZ		:DEFINE SAVSIZ AS THE LARGEST SIZE
	IF	CBZSIZ-SAVSIZ	:IF CBZSIZ IS BIGGER
SAVSIZ	EQ	CBZSIZ		:SAVSIZ = CBZSIZ
	EI
	IF	BFSSIZ-SAVSIZ	:IF BFSSIZ IS BIGGER
SAVSIZ	EQ	BFSSIZ		:SAVSIZ = BFSSIZ
	EI	
	IF	LPGSIZ-SAVSIZ	:IF LPGSIZ IS BIGGER
SAVSIZ	EQ	LPGSIZ		:SAVSIZ = LPGSIZ
	EI	
	IF	LNKSIZ-SAVSIZ	:IF LNKSIZ IS BIGGER
SAVSIZ	EQ	LNKSIZ		:SAVSIZ = LNKSIZ
	EI	
	

	IF	LNFDBG		:LOGON/LOGOFF DEBUGGER
LNFPTR	HS	1		:RING POINTER
	SYAD(LNFPTR)
LNFHST	BS	LNFSIZ		:LOGON/LOGOFF HISTORY RING
	SYAD(LNFHST)
	EI	:LNFDBG

	IF	CBZDBG		:CIRCUIT BUILDING/ZAPPING DEBUGGER
CBZPTR	HS	1		:RING POINTER
	SYAD(CBZPTR)
CBZHST	BS	CBZSIZ		:CIRCUIT BUILDING/ZAPPING HISTORY RING
	SYAD(CBZHST)
	EI	:CBZDBG

	IF	BFSDBG		:BUFFER STRUCTURE DEBUGGER
BFSPTR	HS	1		:RING POINTER
	SYAD(BFSPTR)
BFSHST	BS	BFSSIZ		:BUFFER STRUCTURE HISTORY RING
	SYAD(BFSHST)
	EI	:BFSDBG

	IF	LPGDBG		:LEP/LOGGER DEBUGGER
LPGPTR	HS	1		:RING POINTER
	SYAD(LPGPTR)
LPGHST	BS	LPGSIZ		:LEP/LOGGER HISTORY RING
	SYAD(LPGHST)
	EI	:LPGDBG

	IF	LNKDBG		:LINE/LINK DEBUGGER
LNKPTR	HS	1		:RING POINTER
	SYAD(LNKPTR)
LNKHST	BS	LNKSIZ		:LINK/LINE HISTORY RING
	SYAD(LNKHST)
	EI	:LNKDBG


	IF	DBGON		:IF ANY DEBUGGER OPTION ON
SAVHST	BS	SAVSIZ		:TEMP. STORE THE DATA FROM A RING TO
	EI	:DBGON

       IF	XRYRMK  	:histogram of packetsizes		###SDW
XRMKNE  HS	1		:neighbor to monitor
XRMKHS  HS	$A128/2*4	:
      EI	:XRYRMK

:	THE END OF STORAGE FOR DEBUGGER		###LSH

DEFAULT(SWITIM,0)		:SWITCH MAX PROCESS TIME debug switch	###wjl 
	IF	SWITIM		:					###wjl
PSVHWM	HS	20		:save area for PROHWM, saved at wrap time##wjl
	SYAD(PSVHWM)		:					###wjl
	EI	:SWITIM		:					###wjl

SCEND	HS	0

:	Bufferlet Area
	ORG	(./CBSZ)*CBSZ+CBSZ
	HS	1
CHRBUF  HS	0
	SYAD(CHRBUF)

	SUBTTL	DATA (SEGMENT 0D)

::*****************************************************************
::
::	TEXT is collected here to make it easier to find the label
::		connected to the text and reduce the need for RX3 jumps
::		by routines having to jump over text blocks.	###sdw
::
::*****************************************************************

	SEG.(a.xray)		:put text in segment with some free room###sdw

EXMG1	SC	/"8D"8Aplease see your representative"8D"8Aif you are having trouble logging in/
EXMG2	SC	/"8D"8Abad mud/
EXMG3	SC	/"8D"8Acircuits busy/
EXMG4	SC	/"8D"8Ahost not available thru net/
EXMG5	SC	/"8D"8Ahost out of ports/
EXMG6	SC	/"8D"8Ahost down/
EXMG7	SC	/"8D"8Ahost shut/
EXMG8	SC	/"8D"8Atry again in 2 minutes/
EXMG9	SC	/"8D"8Aaccess not permitted/
EXMG10	SC	/"8D"8Ano host specified/
EXMG11	SC	/"8D"8Abad host number/
EXMG12	SC	/"8D"8Amud error/
	IF	T2GATE
EXMGDL  HC	XMGDL
EXMG13	EQ	EXMGDL+1
	AC	/"8D"8Aplease see your representative/
	AC	/"8D"8Aif you are having trouble logging in/
	AC	/"8D"8Ainter-link cleared from /
QQQ	EQ	0			:assume not ISISN
Q	EQ	.
	ORG	Q-1
	IF	\ISISN
QQQ	EQ	1			:ISISN true so make NETNAM true
QQ	EQ	.
	ORG	Q-1
	BC	0
	ORG	Q-1
	BC	A0			:make a SC string look like a AC
	ORG	QQ
	ELSE
	ORG	Q			:no worry about SC that should be AC
	IF	NETNAM
	INAME()
	ELSE    :NETNAME
	AC	/ISIS NETWORK/
	EI	:NETNAM
	EI	:ISISN
	AC	/ to /
Q	EQ	.
	IF	\HOMEN
	ORG	Q-1
	BC	0
	ORG	Q-1
	BC	A0			:make a SC string look like a AC
	ORG	QQ
	ELSE
	ORG	Q			:no worry about SC that should be AC
	IF	NETNAM
	HNAME()
	ELSE    :NETNAME
	AC	/HOME NETWORK/
	EI	:NETNAM
	EI	:HOMEN
	AC	/"8D"8A/
XMGDL	EQ	.-EXMG13-1
	IF	QQQ			:was ISISN defined?
NETNAM  EQ	1			:if so then we have netnames
	EI	:QQQ
	EI	:T2GATE

EXLGTB	HS	0		:LOOK UP TABLE
Q	EQ	1		:START AT 1
	RE	$A 12
	HC	EXMG|$AQ|-SEGD  :put in SEG D 9/27/87   		###sdw
Q	EQ	Q+1
	ER

	IF	1-INFLGT
:	THE FOLLOWING MESSAGE INCLUDES A SUPER HANG, AND A HANG
PSRMSG	SC	/"03"12"12"8D"8Aplease see your representative"8D"8Aif you are having trouble logging in"03"12"11/
	EI	:1-INFLGT

	IF	T2GATE
::Address tables for Log-on response messages to callers for Gateway

LSMS27	WC	LSMS0	:08 - Continue
	WC	LSMS12	:09 - P.L.I.
	WC	LSMS22	:0A - error, type username
	WC	LSMS32	:0B - error, type password
	WC	LSMS42	:0C - user name
	WC	LSMS52	:0D - password
	WC	LSMS0	:0E - 
	WC	LSMS0	:0F - 
	WC	LSMS0	:10 - send Sup specified string
	WC	LSMS0	:11 - 
	WC	LSMS0	:12 - 
	WC	EXMG13	:13 - please se your rep.
	WC	EXMG2	:14 - bad mud
	WC	EXMG3	:15 - circuits busy
	WC	EXMG4	:16 - host not avail thru net
	WC	EXMG5	:17 - host out of ports
	WC	EXMG6	:18 - host down
	WC	EXMG7	:19 - host shut
	WC	EXMG8	:1A - try again
	WC	EXMG9	:1B - access not permitted
	WC	EXMG10	:1C - no host specified
	WC	EXMG11	:1D - bad host number
	WC	EXMG12	:1E - mud error
LSMSZ	EQ	.-LSMS27
::The Ascii table is below
LSMS	WC	LSMS0,LSMS1,LSMS2,LSMS3,LSMS4,LSMS5,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG13,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::The Half Duplex table is below
LSMSH	WC	LSMS0,LSMS1,LSMS2,LSMSC,LSMS4,LSMSE,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG13,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
LSMSTZ	EQ	.-LSMS27
::Same tables as above except for transparent Log-ons
LSM27T	WC	LSMS0,LSMS1T,LSMS2T,LSMS32,LSMS4T,LSMS52,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::Ascii
LSMST	WC	LSMS0,LSMS1T,LSMS2T,LSMS3,LSMS4T,LSMS5,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::Half Duplex
LSMSHT	WC	LSMS0,LSMS1T,LSMS2T,LSMSC,LSMS4T,LSMSE,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::End of address tables for log-on responses from Supervisor
LSMS0	BC	0;
	HS	0
LSMS12	SC	/please log in: "05/;
LSMS22	SC	/error, type user name: "05/;


	HC	ZMS32
LSMS32	EQ	.-1
	AC	/error, type password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/"05/
ZMS32	EQ	.-LSMS32-1;

LSMS42	SC	/user name: "05/;

	HC	ZMS52
LSMS52	EQ	.-1
	AC	/password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/"05/
ZMS52	EQ	.-LSMS52-1;

	IF	NETNAM
	HS	0
I.NAME(ISISN)			:PRIMARY ISIS NET NAME;
	HS	0
H.NAME(HOMEN)			:SECONDARY HOME NET NAME;
	ELSE	:NETNAM NOT DEFINED, DEFAULT NAMES
	HS	0
ISISN	SC	/ISIS NETWORK/	:PRIMARY ISIS NET NAME;
	HS	0
HOMEN	SC	/HOME NETWORK/	:SECONDARY HOME NET NAME;
	EI	:NETNAM
	HS	0


:	text msgs for failed logon attempt
:	the third field is used to set a bit in the appropiate array

.LGTXT(LTX000,please log in: )
.LGTXT(LTX001,username: )
.LGTXT(LTX002,error"2C type username: )
.LGTXT(LTX003,password: )
.LGTXT(LTX004,error"2C type password: )

LSMS1   EQ	LTX000  		:equate log I msgs to same LOG II msg
LSMS2   EQ	LTX002  		:error type uname
LSMS3   EQ	LTX004  		:error type password
LSMS4   EQ	LTX001  		:username
LSMS5   EQ	LTX003  		:password


.LGTXT(LTX0T0,circuit cleared)  	:transparent not allowed
.LGTXT(LTX0T1,username missing)
.LGTXT(LTX0T2,bad user name)
.LGTXT(LTX0H3,"8D"8Apassword:"8d"8a"ff###############"8D+++++++++++++++"8DOOOOOOOOOOOOOOO"8D)
.LGTXT(LTX0H4,"8D"8Aerror"2C type password:"8d"8a"0ff###############"8D+++++++++++++++"8DOOOOOOOOOOOOOOO"8D)

LSMS1T  EQ	LTX0T0  		:circuit cleared msg
LSMS2T  EQ	LTX0T2  		:bad user name
LSMS4T  EQ	LTX0T1  		:username missing
LSMSE   EQ	LTX0H3  		:HDX text
LSMSC   EQ	LTX0H4  		:HDX text

       IF	LOGII   		:only for LOG II gateway

:	text msgs for node code reject logon 
.LGTXT(LTX100,"8D"8AGateway internal error type 24"5C00)
.LGTXT(LTX101,"8D"8AGateway internal error type 24"5C01)
.LGTXT(LTX102,"8D"8AGateway internal error type 24"5C02)

	EI	:LOG II

.LGTXT(LTX103,"8d"8Ainter"2Dlink lost"2C please try again in a few minutes)

:	some of the general use text msgs
       IF	1-NETNAM	:if netname then these are already defined
.LGTXT(ISISN,ISIS NETWORK)
.LGTXT(HOMEN,HOME NETWORK)
       EI	:NETNAME
.LGTXT(TO, to )
.LGTXT(FROM, from )
.LGTXT(GNONET,"8D"8Aunable to complete inter"2Dlink...try again in a few minutes)
.LGTXT(GNETOK,"8D"8Ainter"2Dlink established)
.LGTXT(GNGONE,"8D"8Ainter"2Dlink cleared)


       EI	:T2GATE

	SUBTTL	DATA (SEGMENT E)

::*********************************************************************
::
::	SEGMENT E - Control Table Area (CTA)
::
::*********************************************************************

	SEG.(0E)
	ORG	sege

:	SEGMENT/SECTION PROTECTION BIT MASKS
P.ZERO	EQ	0	:SECTION not present
P.EXEC	EQ	1	:execution access permitted
P.WRIT	EQ	2	:write access permitted
P.READ	EQ	4	:read allowed (required for others)

:	PROTECTION FOR EACH SECTION/SEGMENT

:	by default make each seg a possible data seg
q	eq	0
	re	$a14
APROT|q|	EQ	P.READ!P.WRIT	:then a possible data seg
q	eq	q+1
	er

:	convert the following segs to code segs
aprot|a.code|	EQ	P.READ!P.EXEC	:will run code in that seg
       if	1-swtchr		:switcher only uses 1 seg for code
aprot|a.code+1|	EQ	P.READ!P.EXEC	:will also run code in this seg
       ei
APROT|a.xray|	EQ	P.READ!P.EXEC


:	CONTROL TABLE AREA:
CTA	WS	0		:ISIS CONTROL TABLE AREA
DCNTRL	WC	CNTRL		:DISPATCHER CONTROL FLAGS
CHKDAT				:put seg sizes in later
	re	$A 15
	WC	0
	er
	HC	0E		:NPROT - count of usable protection bytes
	BC	APROT0,APROT1,APROT2,APROT3 :PROT - memory protection
	BC	APROT4,APROT5,APROT6,APROT7
	BC	APROT8,APROT9,APROTA,APROTB
	BC	APROTC,APROTD
ISTART	WC	NSTART		:job execution start address
DSTART	WC	XRAY		:DDT execution start address
	WC	CONSOL+2	:STATUS - pointer to front-panel display cell
GATCTA	WC	HTBLPT		:host table pointer
	WC	PTBLPT		:port table pointer
	WC	PTABLE		:termination table pointer
	WC	DORING		:Dispatcher's output (note reversed convention)
	WC	DIRING		:Dispatcher's input ring
	WC	0		:(unused)
	WC	0		:(unused)
	WC	PCBPNT		:project code bits pointer
	WC	0		:(unused)
	HC	MAXHST		:maximum number of hosts
	HC	NDP-1		:maximum number of ports
	HC	DRSZ		:Dispatcher ring sizes
	HC	DRSZ		:
CTANOD	HS	1		:slot number filled in by ISIS
	HC	VERREV		:version number and revision level
	WC	0		:pointer to Alfred block
	WC	0		:(unused)
	HC	0		:(unused)
	HC	PRODID		:product id
	HC	0		:patch version number
	HC	ctl.no		:QA (Control) Release Number
	WC	0		:(unused)
	WC	0		:(unused)
qq	CURGMT
	gentim(qq)
	bc	qqqmon,qqqday,qqqyr,qqqhrs,qqqmin,qqqsec :GENTIM
       IF	MACV*(DMAAVL)	:dma region specified
DMASEG	HC	1000		:it is seg 3
       ELSE
	HC	0
       EI	:macv
	WS	10		:reserved for future ISIS-II expansion

::******************************************************************
::
::	GATEWAY/NODECODE differences for CTA
::
::******************************************************************

      IF	T2GATE

:	Gateway's tables differ from NodeCode's
G.HTBL	HC	IHOST		:Gateway uses IHOST only (fixed for now)
G.UTBL	HC	NDP		:maximum port number
PTABLE	HS	NDP		:table of ports for Dispatcher
G.PCTB	HC	4,0,0,10,0,0,0,0
	HC	4,0,0,10,0,0,0,0	:Project Code terminator bits
DESCRI	AC	/TYMNET-II GATEWAY/	:slot description string...
	BC	0			:...null terminated
::	Gateway's CTA differs from NodeCode's.
::	Re-define the following symbols used in the CTA.
CNTRL	EQ	892			:control flags
HTBLPT	EQ	G.HTBL			:host table pointer
PTBLPT	EQ	G.UTBL			:user port table pointer
PCBPNT	EQ	G.PCTB			:project code bits pointer
MAXHST	EQ	1			:maximum number of hosts
VERREV	EQ	GT.VER			:version number and revision level
PRODID	EQ	8B			:Gateway product id

      ELSE	:NodeCode

:	NodeCode's tables differ from Gateway's
HTBL	WC	0
PTABLE	HS	NDP			:permuter table

::	NodeCode's CTA differs from Gateway's.
::	Re-define the following symbols used in the CTA.
DESCRI	AC	/TYMNET-II NODE CODE/	:slot description string...
	BC	0			:...null terminated
CNTRL	EQ	80			:control flags
HTBLPT	EQ	HTBL			:host table pointer
PTBLPT	EQ	HTBL			:port table pointer
PCBPNT	EQ	0			:project code bits pointer
MAXHST	EQ	0			:maximum number of hosts
VERREV	EQ	((VERSION*4)&0FF00)!(REVLEV)	:version/revlev
PRODID	EQ	38			:NC product id

      EI	:T2GATE

::*****************************************************************
::
::	ASCB:	Alfred-68K Slot Control Block
::	The ASCB defines the slot fields for Alfred-68K slot-related
::	functions.  It is pointed to by the slot's CTA table.  This
::	pointer and the context pointer are the only CTA entries
::	that relate to Alfred-68K.
::
::*****************************************************************

:	DISABLE POINTERS UNTIL IMPLEMENTED
ASCB	WC	0		:SLTSYM - pointer to slot symbol table
	WC	0		:ALCMD - pointer to slot extended command table


SESIZE	EQ	.-SEGE

	SUBTTL	DATA (SEGMENT F)

::*********************************************************************
::
::	SEGMENT F - ISIS only
::	1.  Merlin uses symbols defined below.
::	2.  ISIS Data Area, the "real" SEGF, is mapped to low-core.
::	IDA symbols (FASTC, SLOWC, TEMPER, VOLTS, LO.CLK) are defined
::	earlier using EQs.
::
::*********************************************************************

::	T-II Gateway will not need Merlin checking on this.
	IF	(1-T2GATE)		:Gateway does not use Merlin checks

	SEG.(0F)
	ORG	segf

:	DEFINE CRITICAL PARAMETERS FOR MERLIN EDITS
NODEVR	EQ	VERSION&0FFF	:NODE'S VERSION NUMBER

	HC	NDEFN		:NUMBER OF DEFINED SYMBOLS
	SYMDEF(NODEVR)
NDEFN	EQ	NDEF

	HC	NREFN		:NUMBER OF REFERENCE SYMBOLS
	SYMREF(NDP,2,NDP,NDP)
	SYMREF(NSLOT,2,NSLOT,NSLOT)
	SYMREF(HST0,2,HST0,HST0)
	SYMREF(MICRO,2,MICRO,MICRO)
	SYMREF(MACHNM,2,MACHNM,MACHNM)
	SYMREF(ISISVR,2,$A600,$A9999)
	SYMREF(NKU,2,NKU-1,NKU-1)
NREFN	EQ	NREF
SFSIZE	EQ	.-SEGF
	EI	:(1-T2GATE)



	ENDMO.(DATA)
	EI 	:1-KILLIT
	KILMSG(DATA)

:	***NOTHING PAST THIS POINT***

	
	SUBTTL  EXEC

:			***** *   * *****  ***
:			*      * *  *     *   *
:			***     *   ***   *
:			*      * *  *     *   *
:			***** *   * *****  ***

::#####################################################################
::
::	MODULE:		EXEC
::
::	FUNCTION:	PROCESS EXECUTIVE AND OTHER SUPPORT SOFTWARE
::			FOR TYMNET-II NODE CODE. 
::
::	SUBTTLS:	Read/only data
::			NSTART - Init routine for node code
::			EXEC - Process, schedule, dispatch and dismiss
::			Process execution statistics
::			Various dismiss methods for various processes
::			SPIDER - Schedule RMAKE, RTD, DISPI, SUP and SWITCH
::			Periodic processes
::			Utility routines
::			OOPS - Software error handler
::			CRYPTO - Diagnostic message generator
::			
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

::*********************************************************************
::
::	EXEC READ/ONLY DATA -- EQUATES, CONSTANTS AND DATA AREAS
::
::*********************************************************************

	SEG	a.code		:SEGMENT 1 DATA CONTINUES HERE
	HS	0

:	DB.SD1 is a switch that enables calls to D.SDW on R8 from many
:	places in SPIDER.  It is to be used to trap various corruptions.

:	code to crash if bufferlet usage becomes inaccurate
       IF	DB.SD1			:debugging switch
D.SDW	LI	R5,LBUFN		:how many bflets to search
	LIS	R6,0			:counter of BCT in history bflets
D.SDW1	LHL	R3,BCT,R5,		:BCT for this history buffer
	JEFS	D.SDW2
	AHI	R3,CBSZ-CBPTSZ-1	:correct count to number of bflets
	AR	R6,R3			:increment count of in use
D.SDW2	SIS	R5,4			:do next buffer
	JGEBS	D.SDW1
	L	R5,BFLTSV		:so it will be in crash regs
	CR	R6,R5
	JER	R8			:not corrupted
	HC	0			:counts wrong so crash

       EI	:DB.SD1

:	example of code to find bflet pointer corruption
	if	0
:	debug logic to immediately crash upon bufferlet pointer corruption
       if	dmaavl*macv		:if macv and split buffers
d.sdw	li	r5,chrbuf/cbsz
	li	r6,(chrbuf+cbsz*nbflet)/(1^cbszl)
	li	r3,(chrbu0/cbsz)	:minimal of 
	li	r4,(lbfnm0)		:stupid nad (only 1 forward ref in an expr)
	LA	R1,CHRBUF-2,,		:ADDRESS OF ZEROETH BUFFERLET
	LI	R2,(NBFLET-1)*cbsz	:USE FW FOR A BIG POOL##AL
d.sdw1	lhl	R0,0,r2,R1		:STORE # OF FOLLOWING BFLET
	jefs	d.sdw3
	cr	r0,r6
	jgfs	d.sdw2			:if too big then crash now
	cr	r0,r3
	jlfs	d.sdw2
	cr	r0,r5
	jgefs	d.sdw3
	cr	r0,r4
	jgfs	d.sdw2
d.sdw3	shi	R2,CBSZ
	JGBS	d.sdw1
	jfs	d.sdw4
d.sdw2	hc	0	
d.sdw4	LA	R1,CHRBU0-2,,		:ADDRESS OF ZEROETH BUFFERLET
	LI	R2,(NBFLE0-1)*cbsz	:USE FW FOR A BIG POOL##AL
d.sdw5	lhl	R0,0,r2,R1		:STORE # OF FOLLOWING BFLET
	jefs	d.sdw6
	cr	r0,r6
	jgbs	d.sdw2			:if too big then crash now
	cr	r0,r3
	jlfs	d.sdw7
	cr	r0,r5
	jgefs	d.sdw6
	cr	r0,r4
	jgfs	d.sdw7
d.sdw6	shi	R2,CBSZ
	JGBS	d.sdw5
	jr	r8
d.sdw7	hc	0
       else	:not macv
d.sdw	li	r5,chrbuf/cbsz
	li	r6,(chrbuf+cbsz*nbflet)/(1^cbszl)
	LA	R1,CHRBUF-2,,		:ADDRESS OF ZEROETH BUFFERLET
	LI	R2,(NBFLET-1)*cbsz	:USE FW FOR A BIG POOL##AL
d.sdw1	lhl	R0,0,r2,R1		:STORE # OF FOLLOWING BFLET
	jefs	d.sdw6
	cr	r0,r6
	jlfs	.+4			:if too big then crash now
d.sdw2	hc	0	
	cr	r0,r5
	jlbs	d.sdw2
d.sdw6	shi	R2,CBSZ
	JGBS	d.sdw1
	jr	r8
       ei	:macv and dma
	ei	:0

::*********************************************************************
::
::	INITIAL PROCESS P-COUNTERS, PRIORITIES, AND FREQUENCIES
::
::	NOTE:   Any changes in this list requires changing the NS command
::		list of jobs with percent and max time.			###sdw
::*********************************************************************

Q	EQ	1F

QEXECZ	WS	0	:BUFFER ZAPS GET THE HIGHEST PRIORITY
	WC CKZB					;PCKZB	EQ	Q;Q EQ Q-1

	WC SYLVSP	;TSYLVR EQ T016MS	;PSYLVR EQ	Q;Q EQ Q-1

	WC SPIDER	;TSPIDR EQ 0		;PSPIDR EQ	Q;Q EQ Q-1

	WC SWITCH	;TSWICH EQ T032MS	;PSWICH EQ	Q;Q EQ Q-1

	WC g125ms	;tg125m EQ T125MS	;pg125m EQ	Q;Q EQ Q-1

	WC	G250MS	;TG250M	EQ T250MS	;PG250M	EQ	Q;Q EQ	Q-1

	WC G500MS	;TG500M EQ T500MS	;PG500M EQ	Q;Q EQ Q-1

	WC DWLIN	;TDWLIN EQ 0		;PDWLIN EQ	Q;Q EQ Q-1

	WC DLYSRC	;TDLYSR EQ 0		;PDLYSR EQ	Q;Q EQ Q-1

	WC XRYSCH	;TXRAY  EQ 0		;PXRAY	EQ	Q;Q EQ Q-1

	WC G01SEC	;TG01SC EQ T01SEC	;PG01SC EQ	Q;Q EQ Q-1

	WC G02SEC	;TG02SC EQ T02SEC	;PG02SC EQ	Q;Q EQ Q-1

	WC G04SEC	;TG04SC EQ T04SEC	;PG04SC EQ	Q;Q EQ Q-1

	WC G08SEC	;TG08SC EQ T08SEC	;PG08SC EQ	Q;Q EQ Q-1

	WC G30SEC	;TG30SC EQ T30SEC	;PG30SC EQ	Q;Q EQ Q-1

	WC G01MIN	;TG01MN EQ T01MIN	;PG01MN EQ	Q;Q EQ Q-1

	WC G02MIN	;TG02MN EQ T02MIN	;PG02MN EQ	Q;Q EQ Q-1

	WC G04MIN	:4 MINUTE ROUTINE	;PG04MN	EQ	Q;Q EQ Q-1

	WC	MSHRNK				;PGMSRK	EQ	Q;Q EQ Q-1

	RE 20-(.-QEXECZ)/4
	WC EXCRH; NOLIST; ER; LIST

::*********************************************************************
::
::	INITIAL PROCESS SCHEDULE:
::
::*********************************************************************

SCHTBZ	WC 1^PGMSRK			:T08MIN
	WC 1^PG04MN			:T04MIN
	WC 1^PG02MN			:T02MIN
	WC 1^PG01MN			:T01MIN

	WC 1^PG30SC			:T30SEC
	WC 0				:T16SEC (ELSE)
	WC 1^PG08SC			:T08SEC
	WC 1^PG04SC			:T04SEC

	WC 1^PG02SC			:T02SEC
	WC 1^PG01SC			:T01SEC
	WC 1^PG500M			:T500MS
	WC	1^PG250M		:T250MS .. Apply Backpressure
	WC 1^pg125m			:T125MS...UNUSED
	WC 1^PSWICH			:T032MS...SWITCH
	WC 1^PSYLVR			:TSYLVR = 16MS

::*********************************************************************
::
::	SIOINT:
::	A brief description of the initialization routine is as follows:
::	do a channel reset, reset external status latches, set SDLC
::	mode, reset external status latches, rcv interrupt disable,
::	null, set: (DTR, TX 8 bits/char, Tx enable, RTS, Tx CRC enable),
::	reset Tx CRC generator, enter flag char 7E, reset external 
::	status latches, set: (Rx 8 bits/char, enter hunt phase, Rx 
::	CRC enable, Rx enable), stop.
::
::*********************************************************************

	IF	SILINS
SIOINT	WC	30018,31420,31100,303D8,305EB	:CHANNEL RESET,30018,ADDED#JHL
	WC	3877E			:HDLC INITIALIZATION PROGRAM	###TZ
	IF	HMICRO			:HDLC Micro			###wjl
	WC	613D9,0
	ELSE	:ENGINE
	WC	313D9,0
	EI	:HMICRO
SIOBYT	eq	.-sioint		:length of initialization
	EI	:SILINS

:	start is len,header, 80 is boot dump req, and 1454 is address
	if	chboot
cnbre1	hc	42,3232,8000,1454	:first 6 bytes of 42x byte bootmsg
	hc	4541,5254,48a0,46c9,52d3,54a1	:random data to ensure boot
	hc	6df9,20cc,6946,65a0,49d3,4d79,4ff7,4eae :response is not same
	hc	69a0,41ed,20e1,2066,72e5,6520,4dc1,4eae :as the request
	hc	5344,0f7a0,4953,4965,0f2e5,4321,5678

:	start is as above, but type 00 is start and 5a is return to boot
cnbre2	hc	42,3232,0000,005a	:first 6 bytes of 42x byte bootmsg
	hc	4541,5254,48a0,46c9,52d3,54a1	:random data to ensure boot
	hc	6df9,20cc,6946,65a0,49d3,4d79,4ff7,4eae :response is not same
	hc	69a0,41ed,20e1,2066,72e5,6520,4dc1,4eae :as the request
	hc	5344,0f7a0,4953,4965,0f2e5,4321,5678
	ei	:chboot

::*********************************************************************
::
::	MACHID:	DEFINE MACHID FOR CONSOLE DISPLAY.
::		UPPER HALFWORD HAS DECIMAL FORMAT HOST NUMBER,
::		LOWER HALFWORD HAS OCTAL FORMAT MACHINE NUMBER.
::
::*********************************************************************

	RA	8		:SET OCTAL RADIX
MACHID	BC	0
	BC	((MACHNM&70000)^-14)
	BC	((MACHNM&7000)^-5)+((MACHNM&700)^-6)
	BC	((MACHNM&70)^1)+(MACHNM&7)
	RA	0		:RESTORE HEX RADIX

	SUBTTL	EXEC (NSTART)

::*********************************************************************
::
::	NSTART:		INITIAL ROUTINE RUN IN THE NODE CODE
::	FUNCTION:	INITIALIZES ALL DATA AREAS AND VARIABLES FOR
::		THE NODE CODE AND THEN JUMPS TO THE MAIN NODE CODE EXEC
::		LOOP (EXEC)
::
::*********************************************************************

NSTART	LIS	R0,0
	STH	R0,DRIF,,		:INITIALIZE DISPATCHER RING POINTERS
	STH	R0,DRIE,,
	STH	R0,DROF,,
	STH	R0,DROE,,
	LA	R0,FAIL			:R0 = ADDR of trap-block
	SVC	SYS,0			:Restart Syscall
	HC	0,0			:non-skip return = ADDR not valid

	IF	SUPER*(1-split)		:not for split sup
	IF	\MSLOT			:NOT FOR SUPS USING ISRS
	ELSE	:\MSLOT
	SVC	SYS,$A 24		:FREEZE SUP
	EI	:\MSLOT
	EI	:SUPER

:	NOW BEGIN CLEARING THE SEGMENTS
:	First clear the upto, but NOT including the crash info	###07/30/93
	LHI	R1,CLSEG0		:start clearing from CLSEG0	###jhl
	LHL	R2,CRHCNT		:if crash count zero, clear all
	JNFS	NST04			:else, clear around host tables
	LI	R2,(SEGCRH-CLSEG0)/2	:clear to start of crash info
	JFS	NST08			:branch to do one fell clear
NST04	LHI	R2,(HOSTN-CLSEG0)/2	:clear up to host tables
	JAL	R8,HCLEAR		:there is info in host tables
					:that we must not lose		###jhl
	LHI	R1,NEWSUP		:resume clearing after host tables
	LI	R2,(SEGCRH-NEWSUP)/2	:assumes NEWSUP doesn't move

NST08	JAL	R8,HCLEAR		:clear rest of seg 0

	LA	R1,SCEND,,		:CLEAR FROM SCEND TO THE END	###LSH
	LI	R2,((CHRBUF-SCEND)+RCBFSZ)/2	:OF BUFFERLET AREA
	JAL	R8,HCLEAR

:	now reset values of available ports to max for each host
	LHI	R10,NHOSTS-1		:init index into HW arrays
NSTH05	LHL	R1,HMAXP,R10,R10	:read host entries for max ports
	JEFS	NSTH10			:nothing doing if zero
	STH	R1,HSTPTA,R10,R10	:here's a value to move
NSTH10	SIS	R10,1			:decrement index to next host entry
	JGEBS	NSTH05			:loop for all possible entries	###jhl

	TS	SYLINT			:TO START SYNC SPEEDCALC	###OAS

	IF	TSTSZE
	TS	TSLINE			:TURN OFF LINE-LEVEL TRACING	###OAS
	EI	:TSTSZE

	LIS	R1,1			:TURN OFF AUTO CRYPTO DISPLAY FOR TTY 
	LHI	R2,CRYMOD
	STH	R1,XUBLK,R2,

	L	R10,SLOWC,,		:###OAS
	ST	R10,NODSLC		:SEE COMMENT IN DATA AT NODSLC DEFN


	LHL	R10,CRHCNT
	AIS	R10,1
	STH	R10,CRHCNT
	STH	R10,CRCNT		:CRASH TABLE'S COUNT

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LI	R10,TRACER
	ST	R10,TRPSW+8		:POINTER TO JUMP TRACE
	EI	:DB.TRC

	LHL	R0,CRYPRI		:INITIALIZE CRYPTO POINTER FOR TTY
	LI	R1,TTYXD		:TTY USER BLOCK
	STH	R0,CRYPTU,R1

	IF	(1-T2GATE)		:GET HOSTS STATUS		
	 IF     1-NCSLOT			:special to let NC run in slot 1
	LHI	R0,INHTRQ^8		:HOST STATUS REQUEST MESSAGE	###jhl
	STH	R0,DIRNG+2,,		:STORE PORT #0/MESSAGE
	LHI	R0,INNOSP^8		:NO SUP MESSAGE			###jhl
	STH	R0,DIRNG+6,,
	LIS	R0,8
	STH	R0,DRIF,,		:SAVE FILL POINTER
	 EI     :1-NCSLOT
	ELSE	:T2GATE	
	LIS	R3,HDOWN		:Pass host down during init.
	JAL	R10,GHSTST,,		:Send to dispatcher
	JAL	R10,GHSTCT,,
	LIS     R1,1			:###sdw
	STB     R1,G0DFG		:init that we have an ISIS supe
	EI	:T2GATE	
	
	LHL	R0,CRHCNT		:TEST CRASH COUNT
	SIS	R0,1			:IF 1, WE'RE INITIALIZING FOR 1ST TIME
	JG	NST50			:NO, RESTART, LEAVE SEG C ALONE

:	INITIALIZING FOR THE FIRST TIME - INITIALIZE SEGMENT 'CRASH'
	LA	R1,SEGCRH,,		:initialize crash info stuff
	LI	R2,(RSEGC-SEGCRH)/2	:FIRST PART OF SEG Crash TO -1
	LCS	R0,1
	JAL	R8,HCSET		:CLEAR SEGMENT CRASH
	LA	R1,RSEGC,,		:REST OF SEG CRASH TO 0
	LI	R2,(SCEND-RSEGC)/2
	JAL	R8,HCLEAR
       if	pl.num
	lcs	r0,1
	sth	r0,pl.tim		:mark that GMT is not known yet
	srls	r0,1
	st	r0,pt.exe+pl.cur	:set max exec to max value
       ei	:pl.num

	LIS	R0,0
	STH	R0,CRYPRI

:	Put the XRAY symbol table in (approximate) alphabetical order.
	JAL	R11,XWRITE,,		:Need to write to segment D
	LIS	R2,0
NST60	LHI	R1,ADRESZ,R2
NST61	L	R10,SYMTBL,R1,
	C	R10,SYMTBL,R2,
	JGE	NST62

	LM	R14,SYMTBL,R2,
	lhl	r13,SYMTBL+8,R2,
	L	R11,SYMTBL+4,R1,
	LHL	R12,SYMTBL+8,R1,
	STM	R14,SYMTBL,R1,
	sth	r13,SYMTBL+8,R1,
	ST	R10,SYMTBL,R2,
	ST	R11,SYMTBL+4,R2,
	STH	R12,SYMTBL+8,R2,

NST62	AHI	R1,ADRESZ
	CLHI	R1,SYMTSZ
	JL	NST61

NST68	AHI	R2,ADRESZ
	CLHI	R2,SYMTSZ-ADRESZ
	JL	NST60

	LIS	R0,0			:###TZ
	STH	R0,CRHCNT
	JAL	R10,CTENTR,,
	LIS	R0,1
	STH	R0,CRHCNT		:###TZ

	LIS	R0,0			:re-initialize
	STH	R0,CSMCNT		:crash summary count		###wjl

	JAL	R11,XPRTKT,,		:Protect segments 1 and D

:	INIT CRASH TABLE STUFF
	LHI	R1,MACHNM
	STH	R1,NODENU	
	LIS	R1,9			:T-II NODE TYPE
	STH	R1,NODETY
	LIS	R1,CTBVER
	STH	R1,TABVER
	LHL	R1,VERSSV+2,,
	STH	R1,CODVER

:	INITIALIZE ISIS KERNEL RING POINTERS
NST50	IF	(1-T2GATE)
	LCS	R0,1			:SET POINTERS TO -1
	LIS	R1,0			:KERNEL PORT OFFSET
	LHI	R2,NII			:IN POINTER (FOLLOWED BY NOI)
NST02	ST	R0,KRINGS,R2,R1		:INITIALIZES IN AND OUT POINTERS
	AHI	R1,2*(KBSZ+4)		:SIZE OF PORT'S RING AREA
	CLHI	R1,NKU*(2*(KBSZ+4))
	JLBS	NST02
	EI	:(1-T2GATE)

	IF	SUPER*(1-split)		:not for split
	IF	\MSLOT			:NOT FOR SUPS USING ISRS
	ELSE	:\MSLOT
	SVC	SYS,$A 25		:Thaw the Sup Syscall
	EI	:\MSLOT
	EI	:SUPER


       IF	NLINES-SILINS		:initialize the sync rotors
	LHI     R0,NLINES-SILINS
	LA	R1,OROTOR,,		:address of first rotor
	LHI     R2,10,R1		:address of third rotor
NST010  ST	R1,0C,R2		:the jump address
	ST	R2,0C,R1		:jump address set up
	AHI     R1,20
	AHI     R2,20			:for next line
	SIS     R0,1
	JGBS    NST010			:do all sync lines
       EI	:any sync lines


	IF	SILINS

:	INITIALIZE SIO LINES
	LHI	R13,(NLINES-SILINS)*2
NST070	LA	R1,SIOINT	:pointer to initialization prog
	L	R2,SIOIPG,R13,R13	:where to put initialization prog
	LHI	R3,siobyt		:8 words
	JAL	R8,BCMOVE		:copy orig to dest
	AIS	R13,2
	CLHI	R13,NLINES*2
	JLBS	NST070			:for all lines

	LIS	R1,0			:NOW PREPARE ALL OTHER CCWS
	LI	R12,200^10		:init output state to completed
	LIS	R14,0
	LIS	R15,0			:not used
	LHI	R2,(NLINES-SILINS)*2	:USE R2 AS 1ST SIO LN ##AL

SIOIZP	lhl	r6,sibufw,r2		:get sio input size before wrapping
	ahi	r6,siofsz+2		:size of input area
	srls	r6,1			:set up for CCW (size/2)
	OI	R6,30000		:the input area CCW command
	lhl	r7,sibufp,r2		:offset from sibuf
	ai	r7,sibuf		:convert to address of input area
	srls	r7,4			:divide by 16
	ni	r7,0ffff		:force it into a hw
	OI	R7,10000		:INPUT CCW WITH POINTER TO BUFFER
	LHI	R5,7C			:SIZE OF RESET PATTERN
:	RESET PATTERN MADE LONG TO ALLOW ACCURATE LINE SPEED CALCULATION
:	BUT ONLY FIRST 1C BYTES HAVE USEFUL DATA ###wjl
	L	R9,SIOBLA,R2,R2		:address of output CCW
	LR	R13,R9
	SRLS    R13,4			:CCW/4
	ni	r13,0ffff		:prevent wrap out if macv
	LIS     R10,0
sioizq	AIS     R13,1			:address of next CCW for chaining
	STM     R12,0,R9,R10
	AHI	R10,10			:setup next CCW offset
	clh	r10,sionch,r2		:offset to last CCW
	jlbs	sioizq			:for all except last CCW
	LR	R13,R9			:last CCW chains to first CCW
	SRLS    R13,4
	ni	r13,0ffff		:prevent wrap out if macv
	STM     R12,0,R9,R10		:save CCW block

	LIS     R10,0
	STB     R10,SIOTB,R2		:no active transmitting
	STB     R10,SIOFB,R2		:first CCW is free
	ST	R6,SIOBLI,R1,		:CCW for input
	ST	R7,SIOBLI+8,R1,
	li	r6,5^10+siofsz/2	:max size of an sio record
	ST	R6,SIOBLI+4,R1,		:note that siobli+0c is stop ccw
	LR	R3,R1
	AR	R3,R1			:FOR 30H BLK IN XRESET
	AR	R3,R1			:FOR 30H BLK IN XRESET
	STH	R5,SIOBLR,R3,		: for Expanded reset ##AL
:	increment values for next set of stores

	AIS	R2,2			:INC LN ##AL
	AHI	R1,10			:increment block offset for next line
	CLHI	R2,2*NLINES		:check the range
	JL	SIOIZP			:OK to do another set of stores
	EI	:SILINS

	JAL	R10,IZLNKR		:INIT LINKER

       if	super
	IF	SPLIT
	JAL	R10,IZSIRG,,		:INITIALIZE SIO RING CARD
	JAL	R10,SIRCNV,,		:report SIO RING status
	EI	:SPLIT
	JAL	R8,IZSUP,,		:INITIALIZE SUPERVISOR INTERFACE FIELDS
       ei	:super

	JAL	R10,IZSWIT,,		:INIT SWITCH
	JAL	R10,IZEXEC		:INIT EXEC
	L	R0,FASTC,,		:SAVE FASTC TIME FOR
	ST	R0,SYLTIM		: SYNC OVERRUN CALCULATION

:	if split dismiss for 30 seconds so sup will know base went away and
:	is now coming back
       if	split
	svc	dismis,$a 30
       ei	:split

	if	tii.fg
	la	r0,sylver
	svc     sys,1			:run syvler in foreground
	ei

	IF	SPAM			:				###dmj
	L	R0,SLOWC,,		:INITIALIZE TIMERS		###dmj
	AI	R0,$A60			:ADVANCE 60 SECONDS		###dmj
	ST	R0,MTRTIM		:INITIALIZE MEASUREMENT TIMER   ###dmj
	ST	R0,SPSYNC		:SET UP SPAM SYNC TIME		###dmj
	LCS     R0,1			:SET NEGATIVE ADDRESS		###dmj
	SVC     SYS,$A 53		:TELL SPAM TO RE-INITIALIZE     ###dmj
	HC	0,0							###dmj
	LIS     R0,0							###dmj
	STH     R0,SPMINI		:RESET SPAM INITIALIZE FLAG     ###dmj
	EI	(SPAM)			:				###dmj

	IF	DB.DEB
	L	R0,FASTC,,		:SAVE FASTC TIME FOR
	ST	R0,RMKTIM		: AND RMAKE INTERVAL CALCULATIONS
	EI	:DB.DEB

	L	R0,SLOWC,,		:SAVE SLOWC TIME FOR XRAY TO DISPLAY
	ST	R0,GMTSLC		:RESET BASE SLOWC


	J	EXEC			:AND BEGIN EXECUTING

	SUBTTL	EXEC (IZEXEC - Initialize the EXEC segment)

::*********************************************************************
::
::	SUBROUTINE:	IZEXEC:
::	FUNCTION:	INIT THE EXEC SEGMENT
::	CALLING SEQ:	JAL	R10,IZEXEC
::
::*********************************************************************

IZEXEC	LH	R0,VERSSV+2		:SET THE VERSION AND NODE #'S
	STH	R0,VERSID
	LHI	R0,MACHNM
	STH	R0,NODEID

	LA	R1,SCHTBZ		:INIT THE SCHEDULE TABLE
	LA	R2,SCHTAB
	LHI	R3,40
	JAL	R8,BCMOVE

	LA	R1,QEXECZ		:INIT THE PROCESS P-COUNTER TABLE
	LA	R2,QEXEC
	LHI	R3,80
	JAL	R8,BCMOVE

	L	R0,SLOWC,,		:INITIALIZE TIME TO COMPUTE AVERAGE
	ST	R0,EXLTLA		: # OF EXEC LOOP ITERATIONS PER SECOND
	LHI	R0,7FFF			:INSURE LOW-WATER MARK DOESN'T START
	STH	R0,EXLALW		: TOO LOW...
	L	R0,FASTC,,
	ST	R0,EXTIME		:MAKE TIME SINCE LAST EXEC REASONABLE

	L	R0,FASTC,,		:SCHEDULING DUE TIMES
	AHI	R0,RATE			:BEGIN 1 SEC FROM NOW
	ST	R0,DUESCH
	LHI	R0,1F-PSYLVR		:DON'T SCHEDULE SYLVER
	RBT	R0,TSYLVR		: --IT'S THE FOREGROUND

	JR	R10

	SUBTTL	EXEC (Process schedule, dispatch and dismiss)

::*********************************************************************
::
::	EXEC:	DISPATCHES TO PROCESS OF HIGHEST PRIORITY
::
::*********************************************************************

EXE2	LA	R3,EXEHWM		:POINT TO FIELDS TO RECORD
	JAL	R0,EXMTIM		:GO MEASURE TIME THROUGH EXEC LOOP



:	THE ISIS EXEC LOOP MAINTAINS ITS OWN TIME-OUT LIST. EVERY
:	1/8 SEC THE EXEC LOOP OR'S THE APPROPRIATE TIMEOUT
:	LOCATIONS T125MS-T08SEC INTO THE RUN QUEUE SQUEUE.
:
:	It does this by using the number of right-most 0-bits in EISECC
:	(which it increments every 125 ms) to select which timeout-period
:	bit to OR into the SQUEUE bit-array.  Thus only one get selected
:	on each pass, but all run at the appropriate rate, without imposing
:	bursts of load on the CPU.
:
:	NOTE THAT THE MOST FREQUENT PROCESS RUNS EVERY 1/8 SECOND

       IF	1-swtchr		:if no other slots then no need to 
					:dismiss since no other BG matters
	SVC	FAST,0			:DISMISS TO ISIS KERNEL

	LA	R3,EXDHWM		:POINT TO FIELDS TO RECORD
	JAL	R0,EXMTIM		:GO MEASURE TIME DISMISSED
       EI	:SWTCHR
:	do a quick verify that seg E and seg F are still there which
:	is meant to fix a problem of mac set corruptions not being detected
:	and node code running in a greatly crippled state.  The crash must
:	be an illegal instruction in order to get isis to check the mac sets
:	for corruptions
:	I was a real bonehead and originally put this in the 1 sec logic
:	completely misses the point that if seg F goes away then none of the
:	periodic routines run.

: JTGD modified this apparent SDW remnant of debugging code to preserve
: information in registers

	li	r0,cntrl
	L	r5,dcntrl,,		:make sure control bits remain the same
	cr	r0,r5
	jefs	exe203
	hc	0
exe203	lhl	r0,segf+2,,		:rate is never going to chance
	lhi	r5,rate			:pickup constant	###sln
	cr	r0,r5
	jefs	exe205
	hc	0
exe205

:::

	LIS     R5,1
	AM	R5,EXLCNT		:COUNT EXEC LOOPS

EXIDL	LHI	R0,1F-PSPIDR		:SCHEDULE SPIDER 
	SBT	R0,SQUEUE

:	schedule 1/8 logic to run 8 times a sec even if we enterred EXEC
:	a few hundrediths of a second late each time.  Before we would
:	schedule exec to run 1/8 from present so if few hundrediths late
:	they accumulate and might average out to only 7.5 times per second.
EXEC	L	R1,FASTC,,		:EVERY 16 TIKS, SCHEDULE SYLVER
       if	1-tii.fg		:only if sylver is in BG
	l	r0,syvsch		:sched syvler 
	sr	r0,r1			:
	jgfs    execsy
	lhi     r0,1f-psylvr
	sbt     r0,squeue
execsy
       ei	:tii.fg
	L	R0,DUESCH		:SCHED EVERYTHING EVERY 1/8 SEC
	SR	R0,R1			:DUESCH IS NEXT FASTC SCHEDULE TIME
	JG	EXE4			:1/8 SEC HAS NOT YET ELAPSED
	AHI     R0,RATE/8,R1		:GET NEW DUE TIME (- POSSIBLE OVERRUN)

	ST	R0,DUESCH		:AND STORE INTO DUESCH
	LH	R0,EISECC		:EISECC IS INCREMENTED EVERY 1/8 SEC
	AIS	R0,1
	STH	R0,EISECC
	L	R2,T125MS		:SCHED THESE PROCESSES
	O	R2,SQUEUE
	ST	R2,SQUEUE
	LA	R1,T125MS		:NOW SCHEDULE THE REST
	LA	R2,T08MIN
EXE5	CR	R1,R2			:AT END OF TIMEOUT LIST?
	JEFS	EXE4			:YES
	SIS	R1,4			:MOVE TO NEXT TIMEOUT LOCATION
	SRHLS	R0,1
	JNCBS	EXE5			:NOT TIME TO SCHEDULE THIS ONE
	L	R2,0,R1			:FOUND A PROCESS - READ THE TABLE ENTRY
	O	R2,SQUEUE		:MERGE WITH CURRENT RUN QUEUE
	ST	R2,SQUEUE

EXE4	L	R1,SQUEUE		:PICKUP RUN QUEUE
	JFFO	R1,EXE6
	UPSW	EXEPSW

EXE6	ST	R1,SQLAST		:SAVE CURRENT STATE OF QUEUE
	SLHLS	R2,2
	STH	R2,PROCID		:SAVE IT
	LIS	R0,1
	AM	R0,PROCNT,R2		:COUNT EXECUTIONS FOR EACH PROCESS
	L	R0,FASTC,,
	ST	R0,PROTIM,R2		:SAVE PROCESS EXECUTION BEGIN TIME
	L	R0,QEXEC,R2		:DISPATCH TO PROCESS
	JR	R0

	SUBTTL	EXEC (Process execution statistics)

::*********************************************************************
::
::	SUBROUTINE:	EXMTIM:
::	FUNCTION:	RECORD INTERVAL, EITHER EXEC LOOP TIME OR DISMISS TIME
::	CALLING SEQ:	JAL	R0,EXMTIM
::	INPUT:		R3 POINTS TO HIGH-WATER MARK FIELD
::			R4 POINTS TO HISTOGRAM
::	Returns:	R5 contains 1 (Used by callers for counting)
::
::*********************************************************************

EXMTIM	L	R1,FASTC,,		:MEASURE TIME, MAKE MARK IN HISTOGRAM
	LR	R2,R1
	S	R1,EXTIME		:COMPUTE TIME SINCE LAST EXEC OF EXMTIM
	ST	R2,EXTIME		:AND SAVE CURRENT TIME FOR NEXT TIME

	CLH	R1,0,R3			:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXMT10			:NO
	STH	R1,0,R3			:YES - SAVE IT

:	MAKE HISTOGRAM ENTRY. FULLWORD COUNTER RECORDS FASTC/4 UNITS.
EXMT10	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	EXCAVG:
::	FUNCTION:	COMPUTE AVERAGE NUMBER OF EXEC LOOPS/SECOND.
::			RECORD NEW HIGHS AND LOWS AS APPROPRIATE.
::	CALLING SEQ:	JAL	R10,EXCAVG
::
::*********************************************************************

:	REFRESH COUNTERS FOR RMK ITERATIONS AND RMK CALLS FOR NO RECORD MADE.
EXCAVG	jal	r9,gmtcal,,		:set up gmtnow for knowing time
	l	r8,gmtnow		:get the time
	LIS	R1,0
	l	r2,rtdlrr
	st	r1,rtdlrr
	st	r2,rtdlrs		:logical records torn

	L	R1,SLOWC,,
	LR	R2,R1
	S	R1,EXLTLA		:COMPUTE TIME SINCE LAST AVERAGE TAKEN
	ST	R2,EXLTLA		: AND SAVE CURRENT TIME FOR NEXT TIME

       if      super
	LIS	R3,0			:R3 & R2 ARE 64-BIT COUNT OF
	L	R2,supicc		: input cps from supe
	ST	R3,supicc
	DHR	R2,R1			:COMPUTE AVERAGE/SECOND
	ST	R3,suicct		: AND SAVE
	CL	R3,suiccw		:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXCA10			:NO
	ST	R3,suiccw		:YES - SAVE IT
	st	r8,sup.it		:save time
exca10	LIS	R3,0			:R3 & R2 ARE 64-BIT COUNT OF
	L	R2,supocc		: input cps from supe
	ST	R3,supocc
	DHR	R2,R1		  	:COMPUTE AVERAGE/SECOND
	ST	R3,suocct		: AND SAVE
	C	R3,suoccw		:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXCA15			:NO 
	ST	R3,suoccw		:YES - SAVE IT
	st	r8,sup.ot		:save time
exca15	LIS	R3,0			:R3 & R2 ARE 64-BIT COUNT OF
	L	R2,kericc		: input cps from supe
	ST	R3,kericc
	DHR	R2,R1			:COMPUTE AVERAGE/SECOND
	ST	R3,kricct		: AND SAVE
	CL	R3,kriccw		:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXCA17			:NO
	ST	R3,kriccw		:YES - SAVE IT
	st	r8,ker.it		:save time
exca17	LIS	R3,0			:R3 & R2 ARE 64-BIT COUNT OF
	L	R2,kerocc		: input cps from supe
	ST	R3,kerocc
	DHR	R2,R1			:COMPUTE AVERAGE/SECOND
	ST	R3,krocct		: AND SAVE
	CL	R3,kroccw		:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXCA20			:NO
	ST	R3,kroccw		:YES - SAVE IT
	st	r8,ker.ot		:save time
       ei	:super

EXCA20	LIS	R3,0			:R3 & R2 ARE 64-BIT COUNT OF
	L	R2,EXLCNT		: EXEC LOOP ITERATIONS
	ST	R3,EXLCNT		:REFRESH CNT FOR NEXT AVERAGING PERIOD
	DHR	R2,R1			:COMPUTE AVERAGE/SECOND
	STH	R3,EXLAVG		: AND SAVE
	CLH	R3,EXLAHW		:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXCA60			:NO
	STH	R3,EXLAHW		:YES - SAVE IT

:	Compare with low water mark in case we just did an NSZ.
EXCA60	CLH	R3,EXLALW		:NEW LOW-WATER MARK?
	JGER	R10			:NO - RETURN
	STH	R3,EXLALW		:YES - SAVE IT AND
	JR	R10			:RETURN

	SUBTTL	EXEC (Dismiss)

::*********************************************************************
::
::	EXDISM:/EXDIS:/EXYLDM:/EXYLD:  DISMISS METHODS FOR VARIOUS PROCESSES.
::
::*********************************************************************

:	Scheduled task may want to dismiss and yield to a higher
:	priority task if one is waiting, run again if not, or dismiss
:	and allow a lower priority task to run.  
:	Independent of either of these options, the dismissing task may
:	want to resume execution in its next scheduled time slot at the
:	top of the task, in which case no update of the PC in QEXEC is
:	needed, or it may want to resume at the point where it left off,
:	in which case an update the the PC table QEXEC is in order.
:	The fifth of these dismiss routines enables a mechanism from the
:	quarter second logic to schedule various of a sequence of
:	subtasks based upon the dismissing subtask updating a cell called
:	CSNEXT.

EXCRH	CRASH.(.EXCRH,R10)		:NON-EXISTENT PROCESS

:	Dismiss without changing p-counter
EXDISM	LHL	R2,PROCID		:DISMISS WITHOUT CHANGING P-COUNTER
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	SRLS	R2,2
	RBT	R2,SQUEUE
	J	EXEC

:	Here to dismiss - Update p-counter
EXDIS	LHL	R2,PROCID		:HERE TO DISMISS - UPDATE P-COUNTER
	ST	R0,QEXEC,R2
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	SRHLS	R2,2			:CLEAR RUN BIT
	RBT	R2,SQUEUE
	J	EXEC

:	Here to yield - Don't update pc...and don't clear run bit
EXYLDM	LHL	R2,PROCID		:HERE TO YIELD - DON'TUPDATE PC...
					:AND DONT CLEAR RUN BIT
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	J	EXEC

:	Here to yield - Update pc...but don't clear run bit
:	as noted by j kopf going through all of exec to find that nothing
:	happened is sort of expensive (all the stuff of finding that the
:	old job is the new job as if there wasn't an old job).  Note: thbat
:	anything based off of time has to be here as well as EXEC.
EXYLD	L	R1,FASTC,,		:EVERY 16 TIKS, SCHEDULE SYLVER
       if	1-tii.fg		:only if sylver is in BG
	l	r2,syvsch		:sched syvler 
	sr	r2,r1
	jlefs	exyld1			:have soemthing to yeild to
       ei	:tii.fg
	L	R2,DUESCH		:SCHED EVERYTHING EVERY 1/8 SEC
	SR	R2,R1			:DUESCH IS NEXT FASTC SCHEDULE TIME
	Jlefs	Exyld1			:1/8 SEC HAS NOT YET ELAPSED
	l	r2,sqlast		:and see if an event caused something
	x	r2,squeue		:else to get scheduled
	jer	r0			:nothing to yield to so return
exyld1	LHL	R2,PROCID		:HERE TO YIELD - UPDATE PC...
	ST	R0,QEXEC,R2		:BUT DONT CLEAR RUN BIT
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	J	EXEC

	IF	DB.TRC
EXEPSW	WC	1000,EXE2		:ENABLE UPSW TRACE OPTION
	SYAD(EXEPSW)
	ELSE	:NOT DB.TRC
EXEPSW	WC	0,EXE2			:NORMAL MODE, NO TRACE
	EI	:DB.TRC
	
::*********************************************************************
::
::	SUBROUTINE:	CPRHWM:
::	FUNCTION:	COMPUTE PROCESS HIGH-WATER MARK.
::			THIS ROUTINE DETERMINES IF THE HIGH-WATER MARK
::			FOR A PROCESS HAS BEEN EXCEEDED, AND STORES A
::			NEW VALUE IF TRUE.
::	CALLING SEQ:	JAL	R8,CPRHWM
::	INPUT:		R2 = CURRENT PROCESS NUMBER
::	DESTROYED:	R1
::
::*********************************************************************

CPRHWM	L	R1,FASTC,,
	S	R1,PROTIM,R2		:COMPUTE PROCESS EXECUTION TIME
	AM	R1,PACTIM,R2		:AND ADD TO PROCESS TIME ACCUMULATOR
	C	R1,PROHWM,R2		:NEW HIGH-WATER MARK?
	JLER	R8			:NO
	ST	R1,PROHWM,R2		:YES - SAVE
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	MPRTIM:
::	FUNCTION:	SAVES THE CUMMULATIVE TIMES SPENT IN THE DIFFERENT
::			PROCESSES INTO PSVTIM, ZEROES OUT THE ACCUMULATORS
::			PACTIM, AND RETURNS.
::	CALLING SEQ:	JAL	R10,MPRTIM  CALLED BY THE 1-MINUTE PROCESS.
::
::*********************************************************************

MPRTIM	LIS	R0,0			:TO CLEAR ACCUMULATORS
	LHI	R1,1F*4			:MAX NUMBER OF PROCESSES
	LHI	R3,1F*2
MPRTI1	L	R2,PACTIM,R1
	STH	R2,PSVTIM,R3		:SAVE THE TIMES SPENT IN EACH PROCESS
	ST	R0,PACTIM,R1		:AND ZERO OUT ACCUMULATOR
	SIS	R1,4			:DECREMENT INDEX
	SIS	R3,2
	JGEBS	MPRTI1			:AND LOOP BACK IF MORE
	JR	R10			:RETURN

	SUBTTL	EXEC (SPIDER - Schedule RMAKE, RTD, DISPI, SUP and SWITCH)

::*********************************************************************
::
::	PROCESS:	SPIDER:
::	FUNCTION:	Main Node Code data handling process.
::			Schedules RMAKE, RTD, DISPI, SUP and SWITCH.
::	SCHEDULED:	Every pass through the top of the EXEC loop.
::
::*********************************************************************

:	exec calls here to ensure syvler has a high enough line input
:	service rate.
sylvsp  if	1-tii.fg
	jal     r10,sylver
	ei	:tii.fg
	j	exdism			:and done

SPIDER	IF	SUPER
	JAL	R10,SUPOUT,,		:MOVE OUTBOUND SUP DATA
	if	db.sd1
	jal	r8,d.sdw
	ei
	EI	:SUPER

	IF	1-T2GATE		:Gateway has no Kernel I/O	
	JAL	R10,KEROPS,,		:MOVE OUTBOUND KERNEL DATA
	if	db.sd1
	jal	r8,d.sdw
	ei
	EI	:1-T2GATE

	if	1-ncslot		:if then nothing to do
	JAL	R10,DISOUT,,		:MOVE OUTBOUND DISPATCHER DATA
	JAL     R0,EXYLD
	ei	:1-ncslot

	if	1-tii.fg		:don't do if have FG
	JAL     R10,SYLVER		:RUN SYLVER AS PART OF SWITCH
	ei
	if	db.sd1
	jal	r8,d.sdw
	ei

	lhi     r2,lksize-4
SPD2	L	R3,ALINKS,R2		:COPY ALINKS TO LKMAKE
	ST	R3,LKMAKE,R2
	sIS	R2,4
	Jgebs	SPD2

:	following sets the the bits to service each line (for rmake)
q	eq	nlines
qqqq    eq	0
	re	(nlines+0f)/10
qq	eq	80000000
qqq     eq	0
	if	q-0f
	re	10
qqq     eq	qqq+qq
qq	eq	qq^-2
	er
	else    :not q-0f
	re	q
qqq     eq	qqq+qq
qq	eq	qq^-2
	er
	ei
	li	r2,qqq
	st	r2,linsvd+qqqq
qqqq    eq	qqqq+4
q	eq	q-10
	er


SPDRTD  J	RTEAR,,

SPDRMK	JAL     R0,EXYLD		:no longer call EXYLD inside RTEAR
	if	db.sd1
	jal	r8,d.sdw
	ei
	J	RMAKE,,			:do RMAKE

:	SPIDE1 is where EFFEXC RMAKE returns
SPIDE1  JAL     R0,EXYLD		:see if anything else came up before
					:doing rtear/rmake again

:	returning back to RTEAR is not a great idea.  because we are not
:	reenabling rmake we will tear packets and be unable to ack them
:	since rmake has already run for every link and is not allowed to run
:	again.  Also, returning back to exec and doing a dismiss will cause
:	rtear to be run just a bit later.  Under load testing this change
:	caused retransmissions to drop to zero (from hundred) and improve
:	delay and no drop in CPS.				###sdw

	JAL     R10,SIOUT		:DO LINE OUTPUT

	IF	1-T2GATE		:Gateway has no Kernel I/O	
	JAL	R10,KERIPS,,		:MOVE INBOUND KERNEL DATA
	EI	:1-T2GATE
	if	db.sd1
	jal	r8,d.sdw
	ei

       IF	1-ncslot		:if switcher then never data to dispi
	JAL	R10,DISIN,,		:MOVE INBOUND DISPATCHER DATA
       EI	:1-ncslot

	IF	T2GATE
	JAL	R10,GDB3IN,,
	EI	:T2GATE

       if	super
	jal	r10,spibps,,		:read sup backpressure rings
	JAL	R10,SUPIN,,		:MOVE INBOUND SUP DATA (to sup)
       ei	:super

:	do buffer histogram at end of moving data so that histogram is a
:	record of data left after the moving is complete.

	IF	REBILD
	L	R1,HBFTSV		:GET CURRENT CHAR CNT IN HIST BUFS#OAS
	C	R1,HBFTMX		:NEW PEAK			###OAS
	JLEFS	BIDBL2			:NO				###OAS
	ST	R1,HBFTMX		:YES, UPDATE MAX		###OAS
BIDBL2	EI	:REBILD

	L	R1,BFLTSV		:GET CURRENT COUNT OF BUFFERLETS IN USE
	C	R1,BFLTMX		:NEW PEAK?
	JLEFS	SPD5			:NO
	ST	R1,BFLTMX		:YES, STORE NEW PEAK
SPD5	LIS	R2,1
	SRL	R1,ISCALE		:SCALE DOWN ACCORDING TO TOTAL B'LETS
	NHI     R1,07			: ALLOCATED
	AHM	R2,BFLTHS,R1,R1		:INCREMENT APPROPRIATE CELL

      IF        tii.fg			:put a foreground governor on switch
	TS	GOVSWI			:oonly do switch 40 times a second
	JNFS    SPD6			:skip switch this time		###sdw
      EI	:tii.fg

	LHI	R1,01F-PSWICH		:SCHEDULE SWITCH
	SBT	R1,SQUEUE
SPD6	LA	R0,SPIDER
	J	EXDIS			:AND RETURN TO EXEC LOOP

SWIRET	HS	0			:SWITCH RETURNS HERE
	IF	DB.DEB
	L	R0,ALINKS		:ANY ACTIVE LINKS?
	JNFS	SPIDE2			:YES
	L	R0,FASTC,,		:NO - DON'T WANT RMAKE HIGH-WATER MARK
	ST	R0,RMKTIM		: BASED	ON NO LINKS ACTIVE...
	EI	:DB.DEB

SPIDE2	LA	R0,SWITCH,,
	J	EXDIS			:RETURN TO EXEC LOOP

	SUBTTL	EXEC (Periodic processes)
::**********************************************************************
::
::	PROCESS:	G125MS
::	FUNCTION:	1/8 seconds bp relief if lucky
::
::**********************************************************************

g125ms	lhl	r1,glinkr		:any reason to call linker?
	jefs	g125m1			:nothing doing
	j	linker			:it returns to g125m1 regardless
g125m1
	lhl	r0,g125bp
	ais	r0,1
	sth	r0,g125bp
	thi	r0,3			:do normal bp still twice a sec	
	jnfs	g125m3
	JAL	R10,BPMX,,		:normal BACKPRESSURE links and KIO
	jfs	g125m4

g125m3
	if	nlinks-20		:if packets have room
	l	r0,alinks+4
	st	r0,bpmtiq+4
	ei
	l	r0,alinks
	st	r0,bpmtiq
g125m4	LHL	R0,XRYRUN		:DOES XRAY WANT TO DUMP OUTPUT?
	JEFS	G125M6			:NO
	LHI	R0,01F-PXRAY		:YES, SCHEDULE IT
	SBT	R0,SQUEUE
	LHL	R0,XUSIUA		:PUT EVERY XRAY USER
	STH	R0,XQUEM		:INTO THE QUEUE
G125M6
       if	1-ncslot
	JAL	R10,DISBPS,,		:relieve applied bp
       ei	:1-ncslot
	la	r0,g125ms		:linker may dismiss
	j	exdis

::**********************************************************************
::
::	PROCESS:	G250MS
::	FUNCTION:	relieving bp earlier allows applying bp earlier
::			which reduces amount of memory needed for buffering
::
::**********************************************************************

G250MS
	IF	SUPER
	JAL	R10,SUPBPS,,		:RELIEVE BACKPRESSURE ON SUP PORTS
	EI	:SUPER
	J	EXDISM

::*********************************************************************
::
::	PROCESS:	G500MS:
::	FUNCTION:	HALF-SECOND LOGIC
::
::*********************************************************************

G500MS	JAL	R10,CKOVLD,,		:CHECK FOR OVERLOADED LINKS
       if	aplybp
	jal	r10,abpmx,,		:restore xmit authority
       ei	:aplybp
	L	R8,XDDTAD		:XDDT job wants us to do something#sdw
	JEFS    G500M2			:nothing to do
	JAL     R11,XWRITE,,		:allow XRAY routine to write to data
	JALR    R8,R8			:go on R8 and put return in R8
	JAL     R11,XPRTKT,,		:restore write protection
	LIS     R0,0			:clear address
	ST	R0,XDDTAD		:did the job
G500M2	LA	R0,G500MS		:NECESSARY BECAUSE XRAY MAY DISMISS
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G01SEC:
::	FUNCTION:	ONE SECOND LOGIC
::
::*********************************************************************

:	Have sio only send 1 resets packets per second.  Logic is to set a
:	a bit every second which is reset whenever a reset packet is sent
:	and the reset packet can only be sent when the bit is sent.     ###sdw
G01SEC	LIS     R1,LNSIZE-4     :LNSIZE is bit array size (rounded to words)
	LCS     R0,1
G01PRS  ST	R0,SIORPC	:pace resets
	SIS     R1,4
	JGEBS   G01PRS

:	check if ready to switch back from old style reset to expanded resets
	JAL     R10,ESRLIN

:	SPAM issues SVC immediately after value changes			###sdw
	IF	SPAM							###dmj
	LH	R0,SPMINI		:GET SPAM INITIALIZE FLAG	###dmj
	JN	SPMXIT			:SKIP IF ALREADY INITIALIZED    ###dmj
	L	R0,SLOWC,,		:FETCH CURRENT FASTC TIME	###dmj
	C	R0,SPSYNC		:TIME TO SYNCHRONIZE SPAM?	###dmj
	JL	SPMXIT			:NO, NOT YET			###dmj
	LA	R0,NS.PCO,,		:Address of physical CPS stats  ###dmj
	SVC     SYS,$A 53		:Inform Kernel of address	###dmj
	HC	0,0			:Immediate return - invalid addr###dmj
	LCS     R0,1
	STH     R0,SPMINI		:SET SPAM INITIAILIZED FLAG     ###dmj
SPMXIT  EQ	.			:				###dmj
	EI	(SPAM)			:				###dmj
	L	R0,SLOWC,,
	C	R0,MTRTIM		:RUN PERFORMANCE MEASUREMENT LOGIC?
	JL	G01PER			:NO
GOPFM	AHI	R0,$A60			:YES, 60 SECONDS FROM NOW
	ST	R0,MTRTIM
	JAL	R10,EXCAVG		:COMPUTE EXEC LOOP AVERAGE
	JAL	R10,MTRFIC,,		:MEASURE LINK TRAFFIC
	JAL	R10,MPRTIM		:MEASURE TIME SPENT IN EACH PROCESS
       if	pl.num
	jal	r10,plcalc,,		:run performance log saver
       ei	:pl.num
	JAL	R10,LKVOLT		:TEST FOR LINKS OVERLOADED

:	SCHEDULE LDRPRT SYNCHRONOUSLY WITH MTRFIC FOR KS PKT STATS	###JHL
:	LDRINT is a Tymfile parameter when can be used to specify
:	line diagnostic reporting interval in testing environment.
	DEFAULT(LDRINT,4)		:LDRINT Tymfile parameter	###wjl
	LIS	R0,1			:SCHEDULE LDRPRT EVERY LDRINT MINS.
	AHM	R0,LDRTIM		:BUMP THE COUNTER
	JL	G01PER			:STILL NEG--DON'T RUN LDRPRT
	LCS	R0,LDRINT		:REINIT THE SCHEDULING CELL	###wjl
	STH	R0,LDRTIM		:STORE A MINUS LDRINT THERE
	JAL	R10,LDRPRT		:RUN LINE DIAGNOSTICS

:	LDRPRT WAS SCHEDULED FROM G04MIN BEFORE 5.02			###JHL
G01PER	L	R1,LINSPT
	JEFS	G01PE1
	NI	R1,SYNLNA		:NO SIO LINES
	JEFS	G01PE1
	ST	R1,LINSPD		:ALERT SYLVER TO PREFORM LINE SPEED
					: CALC'S FOR LINES REQUESTED
	LIS	R1,0			:RESET SPEED REQUEST BITS
G01PE1	ST	R1,LINSPT
	LIS	R1,1
	AM	R1,S1SLOC		:INCREMENT OCCURRENCES OF 1-SEC LOGIC
	LHL	R1,S1SLOC+2

:	CONSOLE OUTPUT IS DONE IN ISIS KERNEL
	THI	R1,3			:EVERY 4 SECONDS WANT TO FLASH 'MACHID'
	JN	G01SE0			:..NOT THIS TIME		###wjl
	IF	(1-T2GATE)		:				###wjl
	LHL	R0,MACHID		:HO digit of node number	###wjl
	STB	R0,KDISP+1		:ISIS ver 5 (and for us)	###wjl
	SVC	SYS,$A40		:				###wjl
	EI	:(1-T2GATE)		:				###wjl
	LI	R0,0A0000		:SWITCHER DISPLAYS A 'A'
	ST	R0,CONSOL+4
	L	R0,MACHID		:MAN-READABLE HOST, NODE NUMBER DISPLAY
	J	G01SE2			:DISPLAY COMPUTED, BRANCH

G01SE0	LHL	R0,CRHCNT		:COMPUTE CONSOLE DISPLAY
	THI	R0,0FFF0		:CRASH COUNT GREATER THAN 15D?
	JEFS	G01SE5			:NO
	LIS	R0,0F			:YES, JUST DISPLAY 15D
G01SE5	SLHLS	R0,4			:SHIFT UP ONE NIBBLE
	LH	R1,TVRSUP
	EXHR	R1,R1
	ST	R1,CONSOL+4		:STORE SUP NUMBER FOR CONSOL DISPLAY

	IF	1-T2GATE		:Gateway has no Kernel I/O	
	LHL	R1,KDISP
	ELSE	:NOT (1-T2GATE)
	LHL	R1,CONSOL+2
	EI	:1-T2GATE
	THI	R1,0F
	JNFS	G01SE1

	IF	SUPER			:EVERY 4 SEC UPDATE NETWORK STATUS
	AH	R0,TVRSTT		: DISPLAY
	ELSE	:not SUPER
	AIS	R0,1
	LH	R1,TVRSUP		:IS NODE IN THE NET?
	JEFS	G01SE1			:NOT IN NET
	AIS	R0,1			:STATUS OF '2' FOR NODE IN THE NET
	EI	:SUPER

G01SE1	LB	R1,HNPORT+1		:NUMBER OF TERMINATIONS ON KERNEL HOST
	EXBR	R1,R1			:INCLUDE TERMINATIONS
	OR	R0,R1			: IN WORKING DISPLAY
	LHL	R1,PASTHR
	EXHR	R1,R1			:# PASSTHROUGHS IN HIGH-ORDER HALFWORD
	OR	R0,R1			: OF CONSOLE DISPLAY
	IF	(1-T2GATE)		:Gateway does not use		
	SVC	SYS,$A40		:DISPLAY CRASH COUNT, STATUS
	STB	R0,KDISP+1		:CRASH COUNT, NET STATUS FLASHER
	SRLS	R0,8			:PASSTHRU, PORT COUNTS TO LO-ORDER HW
	EI	:(1-T2GATE)
G01SE2	ST	R0,CONSOL		:CONSOLE OUTPUT DONE IN 'SCHED' ROUTINE
					:IF NOT ISIS, ELSE HANDLED BY ISIS KERN

G01SE3	LA	R0,G01SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G02SEC:
::	FUNCTION:	TWO-SECOND LOGIC
::
::*********************************************************************

G02SEC	JAL	R10,G02SLK		:TEST FOR INOPERATIVE LINES
       if	ncslot			:if no isis slots
	lhl     r0,drof,,
	sth     r0,droe,,		:empty the ring (some error message?)
	ei	:ncslot
	IF	SILINS
	JAL	R10,SIOIZ		:SEE IF ANY SIO LINES NEED INIT
	EI	:SILINS

G02BL2	LIS	R0,0			:UPDATE BUFFERLET USAGE HISTOGRAMS
	LHI	R1,2*NSTEPS-2		:HW INDEX FOR UP TO 8 SAMPLES OF BFLTHS
G02BL1	LHL	R2,BFLTHS,R1		:GET NEXT HISTOGRAM
	STH	R0,BFLTHS,R1		:CLEAR LITTLE HISTOGRAM
	AM	R2,BFLTHG,R1,R1		:AND ADD INTO BIG HISTOGRAM
	JLFS	G02BLT			:HISTOGRAM WRAPPED, CLEAR IT
	SIS	R1,2			:DECREMENT INDEX
	JGEBS	G02BL1			:AND REPEAT
	J	EXDISM

G02BLT	LHI	R1,2*NSTEPS-2		:CLEAR OUT BIG HISTOGRAM
G02BL3	ST	R0,BFLTHG,R1,R1
	SIS	R1,2
	JGEBS	G02BL3
	J	EXDISM

::*********************************************************************
::
::	PROCESS:	G04SEC:
::	FUNCTION:	4-SECOND LOGIC
::
::*********************************************************************

G04SEC	JAL	R10,LNCHCK		:CHECK FOR NO RECORDS RECEIVED

:	Check if LEP requested a Down Load (go to boot)
	IF	1-T2GATE		:no down line loading for GW
	LH	R0,DLDFLG		:DID LEP REQUEST A NODE BOOT?
	JGE	G04S00			:NO
	SIS	R0,1			:DECREMENT FLAG
	STH	R0,DLDFLG		:AND RESTORE IT
	AIS	R0,2			:FIRST TIME G04SEC HAS NOTICED THIS?
	JEFS	G04S00			:YES, DEFER BOOT FOR NEXT 4-SEC PERIOD
	LIS	R0,0			:FLAG MUST HAVE BEEN -2...CLEAR IT
	STH	R0,DLDFLG
	SVC	SYS,$A39
	EI	:1-T2GATE		:##al

G04S00
G04SE1	LA	R0,G04SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G08SEC:
::	FUNCTION:	8-SECOND LOGIC
::
::*********************************************************************

G08SEC	IF	SUPER
	JAL	R10,SUPCIN,,		:TEST FOR LAZY SUPER
	EI	:SUPER
	IF	BFLTMR			:buffer delay timing by spec char pairs
	LHL	R0,BFDSCH,,		:###JHL
	SIS	R0,1			:decrement scheduling cell
	JGFS	G08S10			:spring when reaches zero, and reset it
	JAL	R10,BFRUPD		:update the array for sending pairs
	LIS	R0,BFDFRQ		:reset to top value
G08S10	STH	R0,BFDSCH,,		:store current value
	EI	:BFLTMR			:###jhl
	IF	T2GATE
:	don't count port 0 when counting dispatcher ports		###sdw
	LHI	R5,DISZFL+1		:Start at dispatcher range
	LHI	R1,NDP-1		:and check all the dispatcher ports
	JAL	R10,CNTPRT,,		:Count available ports	###ev
	STH	R3,GAVPTS		:and store new available port count
	LB	R1,G0DFG		:have Inet supe?
	JEFS    G08S22			:nope
	LHL     R1,TVRBUF		:have Hnet supe?
	JN	G08S23			:skip if yes
G08S22  LIS     R3,2			:save host is shut
	CLB     R3,HSTAT		:what was old status
	JE	G08S26			:nope already reported shut
	STB     R3,HSTAT		:save new
	JAL     R10,GHSTST,,		:report as shut
	JAL     R10,SUP11,,		:to both supes
	JFS     G08S26
G08S23	JAL	R10,GCKPST,,		:report msg to disp. port 0
					: (Inet sup) if changed. Report
G08S26
	EI	:T2GATE##AL		: to Inet sup if out of port.
:	check KIO circuits for those that have not gotten a zap ack in
:	a reasonable length of time
       if	1-t2gate		:gateway does not have KIO
	lhi	r12,nku*2-2		:for all KIO ports
g08s30	lh	r0,kzptim,r12		:waiting for a zap ack?
	jnfs	g08s32			:yes, check it out
g08s31	sis	r12,2			:no, service next port
	jgebs	g08s30
	j	g08s40			:done all ports
	default(kzpwat,$a 25)

g08s32	sh	r0,slowc+2,,		:minus current time
	ahi	r0,kzpwat		:plus timeout
	lhr	r0,r0			:fix up extended bits
	jg	g08s31			:not expired yet
	lhl	r2,kiotab,r12,		:get buffer number
	nhi	r2,-4
	jefs	g08s34			:not there, somehow already cleared
	lhl	r0,bf,r2,		:should be zero if got a zapper in
	jefs	g08s35
g08s34	lis	r0,0			:here to cancel timeout
	sth	r0,kzptim,r12
	j	g08s31			:check next port
:	outgoing circuit is cleared
g08s35	xhi	r2,4			:buffer for outgoing to zap that half
	jal	r9,zapv,,		:apparently isis forgot to zap it
	lr	r0,r12
	srls	r0,1			:get kio port number	
	jal	r8,crypto		:make a report
	 hc	crye4f
	j	g08s34			:cancel timeout and check next
g08s40
       ei	:t2gate
	LA	R0,G08SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G30SEC:
::	FUNCTION:	30-SECOND LOGIC
::
::*********************************************************************

G30SEC	JAL	R0,CHSUPD,,		:UPDATE CHS ARRAY
	JAL	R10,DETOUT,,		:CHECK DETACHED PORTS
	if	chboot
	jal	r10,cnboot		:check if neighbor in boot
	ei	:chboot
	J	EXDISM

::*********************************************************************
::
::	PROCESS:	G01MIN:
::	FUNCTION:	1-MINUTE LOGIC
::
::*********************************************************************

G01MIN	LHL	R0,FASTC+2,,		:MEASURE INTERVAL, 1-MIN EXECUTIONS
	LHL	R1,MINSAV
	STH	R0,MINSAV
	SR	R0,R1
	JGEFS	G01MI2
	AI	R0,10000
G01MI2	STH	R0,MININT
	LHI	R0,-NR.DGN*6		:RE-INIT NETDGN COUNTER WHICH THROTTLES
	ST	R0,NETDCT		:DIAG NODE REPORTS (NR.DGN) AT 6/MIN
	JAL	R10,G01MLS		:REINSTATE SUSPENDED LINES

	IF	REBILD
	JAL	R10,CRTOUT,,		:PROCESS CIRCUIT TIMEOUTS
	JAL	R10,RBDOUT,,		:REBUILD TIME-OUT		###GT
	EI	:REBILD

:	CLEAR ACTIVITY COUNTERS
	LIS	R0,0
	IF	(1-T2GATE)		:Exclude for Gateway
	LHI	R1,(NUSLT-1)*2		:					###LH
G01MI4	STH	R0,SCLCNT,R1		:CLEAR CIRCUITS/MINUTE COUNT FOR SLOT
	STH	R0,SMLCNT,R1		:CLEAR SLOT REPORTS/MIN COUNT FOR SLOT
	SIS	R1,2
	JGEBS	G01MI4
	EI	:(1-T2GATE)		:end exclude, Gateway
	IF	RESHST
	LHI	R1,(NHOSTS-1)*2
G01MI6	STH	R0,HCTSCT,R1		:CLEAR CIRCUITS/MINUTE COUNT FOR HOST
	SIS	R1,2
	JGEBS	G01MI6
	LHI	R1,(((NHOSTS+0F)/10)*2)-2
G01MI8	STH	R0,RESHMS,R1		:CLEAR ARRAY WHICH THROTTLES NODE RPTS
	SIS	R1,2
	JGEBS	G01MI8
	EI	:RESHST
:	for gateway do host costing
	if	t2gate
:	base cost=(#circuits+link saturated count)/4+60-exec rate (if exec<60)
:	inet cost=base cost+INCOST+Overloadcount*4
:	hnet cost=basecost+HNCOST
	if	lodcst			:if cost via load is not disabled
	lhi	r0,ndp-1
	sh	r0,gavpts		:ava-free is used
	lhi	kn,(nlinks-1)*2		:count sats and overloads
	lis	r1,0			:sats
	lis	r2,0			:overloads
g01mcs	l	kd,kdkn,kn,kn
	lb	r3,nlat,kd		:any lines attached?
	jefs	g01mc1
	ah	r1,ks.sat,kd
	ah	r2,ks.ovl,kd
g01mc1	sis	kn,2
	jgebs	g01mcs			:all links
	ar	r1,r0			:sats and circuits of base
	srls	r1,2			:divide by 4
	lhi	r0,$a 60
	sh	r0,exlavg		:exec rate
	jgefs	g01mc2
	lis	r0,0
g01mc2	ar	r1,r0			:r1 is now base cost
	lhi	r14,hncost,r1		:hnet cost value
	slls	r2,2			:overload*4
	ahi	r1,incost,r2		:inet host cost value
	else	:lodcst			 only want circuits for costing
	lhi	r1,ndp-1
	sh	r1,gavpts		:ava-free is used
	srls	r1,2			:over 4
	lhi	r14,hncost,r1		:hnet cost value
	ahi	r1,incost		:inet host cost value
	ei	:lodcst
	clhi	r1,0ff			:make sure didn't wrap
	jlefs	g01mc6
	lhi	r1,0ff
g01mc6	clh	r1,hcosti		:a new inet cost?
	jefs	g01mc3
	sth	r1,hcosti		:save it away
	jal	r10,ghstct,,		:send it to inet
g01mc3	clhi	r14,0ff
	jlefs	g01mc5
	lhi	r14,0ff			:max value
g01mc5	clh	r14,hcosth		:a new value?
	jefs	g01mc8			:no so no report
	sth	r14,hcosth
	LI	R1,HHOST^10,r14		: H-net host # | host cost
	ST	R1,SUPMBF		:and store in sup mesage buffer
	LHI	R5,NCHCST		:Get message subtype 88
	JAL	R10,GSP14H,,		:and send it to sup
g01mc8
	ei	:t2gate
	LA	R0,G01MIN
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G02MIN:
::	FUNCTION:	TWO-MINUTE LOGIC
::
::*********************************************************************

G02MIN	JAL	R10,SUP0B,,		:send Resources Report to Sup	###wjl
:	TEST FOR RECENT TAKEOVER. WE WANT TO REPORT NODE'S LINE RESOURCES
:	2 - 4 MINUTES FOLLOWING TAKEOVER...
	LH	R0,TAKOVR		:CELL SET NEGATIVE WHEN TAKEN OVER
	JE	G02MEX			:NO RECENT TAKEOVERS
	JGFS	G02M20			:2 - 4 MINUTES AGO, MAKE REPORTS
	LIS	R0,1			:0 - 2 MINUTES AGO, SET CELL POSITIVE
	STH	R0,TAKOVR		: FOR NEXT TIME
	J	G02MEX

G02M20	LIS	R0,0
	STH	R0,TAKOVR
	LHL	R0,TVRBUF		:GOT A SUP?
	JE	G02MEX			:NO - DON'T BUFFER THESE...
:	MAKE NODE REPORT TO INDICATE NUMBERS OF--SIO LINES, SYNC LINES,
:	XLINKS, AND TOTAL LINKS.
	LI	R0,(SILINS^18)+((NLINES-SILINS)^10)+(XLINKS^8)+(NLINKS)+80808080
	ST	R0,SUPMBF+2
	LHI	R0,NR.SSX		:REPORT TYPE - NETWORK RESOURCES
	STH	R0,SUPMBF
	JAL	R10,SUP12,,

:	NOW REPORT PORTS AND PASSTHROUGHS
	LI	R0,(NDP^10)+(NPTHR)+80008000
	ST	R0,SUPMBF+2
	LHI	R0,NR.PPT
	STH	R0,SUPMBF		:REPORT TYPE - PORTS AND PASSTHROUGHS
	JAL	R10,SUP12,,
:	REPORT UNUSED LINES...BIT ARRAY, 0 BIT FOR UNUSED
	LCS	R0,1
	ST	R0,SUPMBF+2		:ASSUME ALL LINES USED
	LHI	LN,NLINES-1
G02M22	LHL	R0,NGSVLN,LN,LN
	JNFS	G02M24			:LINE USED
	RBT	LN,SUPMBF+2		:INDICATE THIS LINE UNUSED
G02M24	SIS	LN,1
	JGEBS	G02M22
	LHI	R0,NR.UNL
	STH	R0,SUPMBF		:UNUSED LINES REPORT
	JAL	R10,SUP12,,
:	REPORT FOR EACH USED LINE:
:		HWXSSSSSLLLLLLLLUNNNNNNNNNNNNNNN
:	WHERE H = 1 FOR SIO LINES, 0 FOR SYNC
:	W = 1 FOR T-I WS8
:	X = 1 FOR SATELLITE LINK, 0 FOR TERRESTRIAL
:	SSSSS = LINK SPEED
:	LLLLLLLL = LINE NUMBER
:	U = 1 IF LINE UP, ELSE 0
:	NNNNNNNNNNNNNNN = NEIGHBOR NUMBER
	LHI	LN,NLINES-1
G02M30	LHL	R0,NGSVLN,LN,LN
	JE	G02M50			:LINE UNUSED
	STH	R0,SUPMBF+4		:NEIGHBOR, + 8000 IF UP
	SLLS	LN,1
	L	KD,KDLN,LN,LN		:GET LINK DESCRIPTOR
	JGFS	G02M32			:LINK UP
	SRLS	LN,1
	LHI	R0,80			:LINK NOT UP, ASSUME SIO LINE
	JFS	G02M34
G02M32	SRLS	LN,1
	LB	R0,KSPD,KD		:LINK TYPE, SPEED + 80
G02M34	LHI	R1,-(NLINES-SILINS),LN
	JGEFS	G02M40			:SIO LINE
	NHI	R0,7F			:SYNC LINE, TURN OFF HI-ORDER BIT
G02M40	EXBR	R0,R0
	OI	R0,(NR.LNR^10)+80,LN	:NODE REPORT TYPE, LINE # + 80
	ST	R0,SUPMBF
	JAL	R10,SUP12,,
G02M50	SIS	LN,1			:DO FOR ALL LINES
	JGE	G02M30
:	REPORT TIILNK NEIGHBORS NOT UP...SAME FORMAT AS ABOVE, BUT THE
:	LINE NUMBER FIELD IS -1.
	LHI	KN,NLINKS-1
G02M60	SLLS	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR ADDRESS
	SRLS	KN,1
	LHL	R0,ONDID,KD		:IS THIS AN XLINK?
	JE	G02M70			:YES - IGNORE
	LB	R1,NLAT,KD		:IS LINK UP?
	JNFS	G02M70			:YES - DON'T REPORT
:	GOT TIILNK LINK WITH NO LINES ATTACHED - REPORT IT
	STH	R0,SUPMBF+4		:NEIGHBOR NUMBER
	LB	R1,KSPD,KD		:MAYBE LINK SPEED ALREADY DEFINED
	EXBR	R1,R1
	OI	R1,(NR.LNR^10)+0FF	:REPORT TYPE, LINE # FF
	ST	R1,SUPMBF
	JAL	R10,SUP12,,		:MAKE NODE REPORT
G02M70	SIS	KN,1
	JGE	G02M60			:DO FOR ALL LINKS
G02MEX	LA	R0,G02MIN
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G04MIN:
::	FUNCTION:	FOUR MINUTE LOGIC
::			CALLS LINE DIAGNOSTIC REPORTING PROCESS AND
::			TESTS INTERNAL HOST CRQS FOR TIMEOUTS
::
::*********************************************************************

G04MIN	JAL	R10,CKTCON,,		:TEST FOR CIRCUIT BUILDING ERRORS
:	send old style resets on inactive lines to bring up stubborn 5.10
:	neighbors							###sdw
	JAL     R10,OSRLIN		:send old style resets
	JAL	R11,INTTIM,,		:CHECK TIMEOUT ON INTERNAL HOST PORTS
	JAL	R11,TEMPRP,,		:TEST FOR TEMP IN ACCEPTABLE RANGE#JHL

:	PERFORM ACCOUNTING - EVERY 16 MIN FOR GATEWAY
	IF	ACCT			:GATEWAY accounting
	LHL	R0,AA20MN		:Is it time for 20 minute accounting?
	JEFS	G16MIN			:Yes
	AIS	R0,1			:No, Decrement counter (yes decrement!)
	STH	R0,AA20MN
	JFS	g04mi4			:continue on to other 4 min stuff
:	Accounting 16 minute report
G16MIN	LCS	R0,4			:Init counter to -4
	STH	R0,AA20MN
	JAL	R11,AATIME,,		:Perform periodic accounting
	EI	:ACCT

g04mi4
	if	chboot	
	lhl	r0,s16min		:sched 16 minutes
	ais	r0,1
	sth	r0,s16min		:another 4 minute period
	thi	r0,3			:eq 0 modulo 4?
	jnfs	g04mi5
	if	nlines-20
	lcs	r0,1
	ST	R0,cnbtgo		:lines to send out boot records
	li	r0,@(1^(40-nlines)-1)
	st	r0,cnbtgo+4
	else	:not lots of lines
	li	r0,@(1^(20-nlines)-1)
	st	r0,cnbtgo
	ei	:nlines-20
g04mi5
	ei	:chboot
q	eq	0
	lis	r0,0			:reenable reporting of any link
	re	(nlines+7)/8		:down since neighbor on BGUY list
	sth	r0,xrbguy+2*q		:ie one msg per line every 4 min
q	eq	q+1
	er

	J	EXDISM			:Dismiss to Exec loop



	SUBTTL  EXEC (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	BCMOVE:
::	FUNCTION:	MOVE N BYTES OF DATA FROM SOURCE TO DESTINATION
::	CALLING SEQ:	JAL	R8,BCMOVE
::	INPUT:		R1 = SOURCE ADDR
::			R2 = DESTINATION ADDR
::			R3 = BYTE COUNT
::	DESTROYED:	R0 = SCRATCH
::
::*********************************************************************

BCMOVE	LB	R0,0,R1			:MOVE BYTES
	AIS	R1,1
	STB	R0,0,R2
	AIS	R2,1
	SIS	R3,1
	JGBS	BCMOVE
	JR	R8

::*********************************************************************
::
::	SUBROUTINES:	HCLEAR:/HCSET:
::	FUNCTION:	SET N HALF-WORDS TO ZERO OR TO CONTENTS OF R0
::	CALLING SEQ:	R8 = LINK
::	INPUT:		R0 = CONSTANT
::			R1 = DESTINATION ADDR
::			R2 = HW COUNT
::
::*********************************************************************

HCLEAR	LIS	R0,0
HCSET	STH	R0,0,R1			:SET HALF-WORDS
	AIS	R1,2
	SIS	R2,1
	JGBS	HCSET
	JR	R8

	SUBTTL	EXEC (OOPS - Software error handler)

::*********************************************************************
::
::	SUBROUTINE:	OOPS:
::	FUNCTION:	Software error handler
::	CALLING SEQ:	CALL TO OOPS IS SET UP BY THE CRASH MACRO.
::			CALL TO OOPS WILL BE RX1/2 OR RX3 AS REQUIRED.
::	THE CRASH DATA ARE SET UP BY THE CRASH MACRO TO FOLLOW IMMEDIATELY THE
::	JAL,OOPS, AND CONSIST OF 1 OR 2 HW'S, AS FOLLOW:
::		FIRST HW = xxyy
::		WHERE: xx IS A 7-BIT (EVEN) SUBTYPE CODE, WITH THE LO BIT SET
::			IF ANY SPECIAL REGISTERS WERE SPECIFIED IN THE CRASH
::			MACRO CALL.
::			yy IS AN 8-BIT COMMON CRASH CODE
::		2ND HW = aabb ONLY IF THE LO BIT OF xx IS SET.
::			 ELSE IT ISN'T THERE.
::		WHERE: aa AND bb ARE REGISTER NO'S*4
::			aa IS ALWAYS MEANINGFUL
::			bb IS MEANINGFUL ONLY IF NON-0.
::		WE ALWAYS SAVE BOTH REGISTERS JUST BECAUSE IT TAKES LESS CODE.
::
::*********************************************************************

OOPS	ST	R0,CRSHAD		:Save crash address
	LR	R1,R0			:Get crash address to index register
	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LIS	R0,1			:STOP TRACER HARD
	STH	R0,TRCRRQ,,
	EI	:DB.TRC
	LHL	R1,0,R1			:Get offset to crash code
	jnfs	oops1
	lhi	r1,0fe63		:debugging crash code
oops1	STH	R1,CRSHID		:Save crash code
					:Continue...fall through
	jfs     sfail1

:	GET HERE FROM 'FAIL' FOR FAULTS DETECTED BY THE ISIS DISPATCHER
:	OR KERNEL, OR FALL THROUGH FROM 'OOPS'. SAVES REGISTERS,
:	COPIES POSSIBLE UPSW TRACE DATA TO 'TRSTAB', AND RESTARTS NODE
:	IF CRSTOP=0.  
SFAIL	STM	R0,ERRREG		:SAVE ALL REGISTERS
sfail1	JAL	R9,GMTCAL,,		:RETURNS TIME (GMT+FASTC) IN GMTNOW
	L	R2,GMTNOW
	ST	R2,CRSHTM		:SAVE IT
	JAL	R10,CTENTR		:MAKE CRASH TABLE ENTRIES
	UPSW	NOTRAC			:INSURE TRACE NOT ON, PROCEED AT SFAIL2

:	ENTRY POINT FOR MAC ERRORS AND ILLEGAL INSTRUCTIONS DETECTED BY
:	THE PRIVELEGED CODE IN A SOLO MACHINE.

SFAIL2	L	R0,CRSHAD		:CRASH ADDR IN HW2&3 OF CRYPTO REPORT
	ST	R0,CRYSBF
	LHL	R0,CRSHID		:CRASH ID IN HW1
	JAL	R8,CRYPTO
	HC	CRYE00			:MESSAGE = CRASH

SFAIL3	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LHI	R1,TRTBSZ-2		:SET UP INDEX REG FOR TRSTAB.
:	MOST RECENT JUMP ADDRESS WILL BE LAST ENTRY IN TRSTAB.
	LR	R3,R1			:ALSO USEFUL AS WRAP MASK
	LHL	R2,TRNDEX,,		:REAL-TIME TRCTAB INDEX
SFAIL4	LHL	R15,TRCTAB,R2,		:GET CURRENT TRCTAB ENTRY AND
	STH	R15,TRSTAB,R1,		: STORE IN SAVE TABLE
	SIS	R2,2			:DECREMENT, AND
	NR	R2,R3			: MASK FOR WRAP
	SIS	R1,2
	JGEBS	SFAIL4			:FILL IN ALL ENTRIES
	EI	:DB.TRC

	if	1-autrac
	LA	R1,TRRING+TRRSIZ-2,,	:LAST SOURCE HW
	LA	R2,TRRSAV+TRRSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(TRRSIZ/2-1)	:NUMBER OF HW'S TO MOVE INDICATOR
	COPY	R1,R3			:SAVE TRRING--"COPY" MICROINSTRUCTION
	LHL	R1,TRRIX		:AND INDEX
	STH	R1,TRIXSV,,
	ei	:1-autrac

       IF	1-ncslot		:NO NEED IF SWITCHER
	LA	R1,DIRING+DRSZ+2,,
	LA	R2,DIRSAV+DRSZ+2,,
	LI	R3,10*(DRSZ/2+1)
	COPY	R1,R3			:SAVE DIRING
	LA	R1,DORING+DRSZ+2,,
	LA	R2,DORSAV+DRSZ+2,,
	LI	R3,10*(DRSZ/2+1)
	COPY	R1,R3			:AND DORING
       EI	:ncslot

:	STORE PACKETS ON CRASH - COPY 1000 BYTES EACH TIME
	IF	PKTSAV			:SAVE PACKETS ON CRASH	###LSH
	L	R3,RECBUF,,
	ST	R3,PCKTSV,,		:do 1st hw so avoid problem with copy
	LI	R3,10*(PCKTSZ/2-2)	:TOTAL BYTES TO BE COPIED
	LA	R1,RECBUF,,		:LAST SOURCE HW
	LA	R2,PCKTSV,,		:LAST DESTINATION HW
	COPY	R1,R3
	EI	:PKTSAV			:			###LSH

	LM	R0,ERRREG		:RESTORE REGS IN CASE WE STOP ON CRASH

	LH	R1,CRTYPE		:HARDWARE OR SOFTWARE?		###TZ
	JGEFS	SFAIL7			:SOFTWARE			###TZ
	LB	R0,CRACTN		:HARDWARE, LOOK AT H-WARE FIELD
	STH	R0,CRTYPE		:RESET CRASH TYPE		###TZ
	JFS	SFAIL8
SFAIL7	LB	R0,CRACTN+1		:SOFTWARE, LOOK AT SOFTWARE FIELD
SFAIL8	LR	R0,R0
	JE	RESTRT			:CRACTN = 0 => RESTART

      IF	T2GATE			:Gateway can only restart or halt.
	J	CRPACH			:then halt it
      ELSE	:not T2GATE
	SIS	R0,1
	JNFS	SFAILA

:	CRACTN = 1 => STOP NODECODE,  (LOOP) ON CRASH
SFAIL9	SVC	FAST,0			:DISMISS TO ISIS KERNEL SO OTHER SLOTS
	JBS	SFAIL9			: HAVE A CHANCE

SFAILA	SIS	R0,1
	JNFS	CRPACH			:CRACTN > 2, PROVIDE PATCH AREA
:	EFFECTIVE FOR SFTWR CRASH ONLY AS HDW WOULD HAVE HALTED IN ANERNT.

:	CRACTN = 2 => BOOT MACHINE

	SVC	SYS,$A39
	J	.			:LOOP TILL TIMER TAKES EFFECT
      EI	:T2GATE

:	CRACTN = 0 => RESTART
RESTRT	UPSW	NSTPSW			:RESTART NODE CODE, POSSIBLY WITH TRACE
	SYAD(RESTRT)	

:	CRACTN = 3 => HALT
CRPACH	SVC	SYS,$A32		:TRUELY HALT THE NODE CODE	###GT
					: - ONLY TO BE USED IN APSS SYSTEMS SO
					: THAT THE ISRM WILL UNSUSPEND THE
					: BACK-UP NODE CODE		###GT

NOTRAC	WC	0,SFAIL2		:TURN OFF TRACE FOR COPY OF TABLE

	IF	DB.TRC
NSTPSW	WC	1000,NSTART		:RESTART NODE CODE WITH UPSW TRACE
	ELSE	:NOT DB.TRC
NSTPSW	WC	R0,NSTART		:RESTART NODE CODE WITHOUT TRACE
	EI	:DB.TRC



::*********************************************************************
::
::	SUBROUTINE:	CTENTR:
::	FUNCTION:	MAKE AN ENTRY IN THE COMMON CRASH SUMMARY TABLE
::			AND IN DETAIL TABLE IF APPROPRIATE.
::	CALLING SEQ:	JAL	R10,CTENTR
::
::*********************************************************************

:	THE SUMMARY TABLE IS A PUSH-DOWN STACK WITH ROOM FOR 16d
:	ENTRIES.  WE WILL MAKE AN ENTRY IN THIS TABLE FOR EVERY CRASH UNTIL
:	THE FIRST CRASH NOT YET REPORTED TO THE SUPERVISOR REACHES THE BOTTOM
:	OF THE LIST.  AT THAT POINT WE STOP PUSHING THE STACK DOWN AND SIMPLY
:	ENTR ANY NEW CRASHES AT THE TOP.  THIS PRESERVES THE ORIGINAL CRASH
:	FOR REPORTING TO THE SUP.  WHEN THE NODE COMES BACK INTO THE NET FROM
:	A CRASH, WE WILL REPORT THIS 'OLDEST' CRASH (IF ANY) AS WELL AS THE
:	MOST RECENT CRASH. SIMILARLY, ENTRIES ARE MADE IN THE DETAIL TABLE ONLY
:	FOR THE CRASH OF INTEREST FOLLOWING A LOAD AND FOR THE FIRST MOST
:	RECENT CRASH OF INTEREST THAT OCCURED WHILE THE NODE WAS IN THE NET.

CTENTR	LHI	R1,((CS.NEN-1)*CS.SIZ)	:POINT TO LAST ENTRY IN SUMMARY TABLE
CTE10	LM	R12,CSMTBL-CS.SIZ,R1	:GET PREVIOUS ENTRY
	STM	R12,CSMTBL,R1		:MOVE IT DOWN ONE ENTRY
	SHI	R1,CS.SIZ		:POINT TO NEXT ENTRY UP
	JGBS	CTE10			:NO, CONTINUE
:	STACK PUSHED, NOW MAKE NEW ENTRY
	LM	R12,CRHCNT		:COUNT,ID,PSD,TIME
	STM	R12,CSMTBL		:MAKE ENTRY
	LIS	R3,1			:increment			###wjl
	AHM	R3,CSMCNT		:count of summary table entries	###wjl
:	NEW ENTRY MADE, NOW MAKE DETAILED ENTRY IF APPROPRIATE.
	THI	R12,0E			:FOR ISIS, MAKE DETAIL ENTRY IF ID >1.
	JER	R10
	lhr	r3,r12			:get crash id
	chi	r3,.xrysn		:is it the crash by xray cmd?
	jer	r10			:yes, don't put into detail table
	LHL	R3,CSMCNT		:ANY ENTRIES?			###GT
	JER	R10			:NO, DON'T MAKE ANY ENTRIES
					: IN DETAIL TABLE		###GT
	LIS	R3,1			:				###GT
	AHM	R3,CDTCNT		:COUNT OF DETAIL ENTRIES	###GT
	LHL	R3,CDTPTR		:POINTER TO NEXT DETAIL ENTRY AREA
CTE20	STM	R12,CDTTBL,R3		:COUNT, CODE, PSD, TIME

	LA	R0,ERRREG+3E		:FOR COPY - LAST SOURCE HW
	LA	R1,CDTTBL+CD.RSF+3E,R3	:FOR COPY - LAST DESTINATION HW
	LHI	R2,1F0			:FOR COPY - NO. OF HW'S -1 * 10
	COPY	R0,R2			:MOVE CONTENTS OF USER REGISTER SET
					:INTO CRASH TABLE.

	LR	R3,R3			:FIRST ONE?
	JNR	R10			:NO
	LHI	R3,CD.SIZ		:YES,POINT TO SECOND
	STH	R3,CDTPTR
	JR	R10			:RETURN

	SUBTTL	EXEC (CRYPTO - Diagnostic message generator)

::*********************************************************************
::
::	SUBROUTINE:	CRYPTO:
::	FUNCTION:	SENDS A CRYPTOGRAM TO XRAY
::	CALLING SEQ:	JAL	R8,CRYPTO
::			HC	CRYExx	:CRYPTO NUMBER AND MESSAGE FLAGS
::	INPUT:		R0=HW0 & HW1 OF CRYPTOGRAM DATA
::			CRYSBF=HW2,HW3 OF CRYPTOGRAM DATA
::
::*********************************************************************

:	STORES A CRYPTOGRAM AS FOLLOWS: FW OF GMT, LO HW OF FASTC, HW OF
:	FLAGS AND MESSAGE TYPE (CRYEnn), 4 HW'S OF DATA.

:	ENTRY POINT WHEN R0 NOT SET UP
CRYPT0	L	R0,CRYSBF+4		:CRYPTO ASSUMES R0 HAS SOME DATA

CRYPTO	ST	R1,CRYSAV+4		:SAVE R1 IMMEDIATELY
	LB	R1,1,R8			:GET CRYPTO NUMBER
	TBT	R1,CRYARY		:SEE IF THIS MESSAGE IS DESIRED
	JN	CRYPNO			:NO, DO NOT DISPLAY IT

	LB	R1,0,R8			:GET MESSAGE FLAGS
	NHI	R1,0F			:ISOLATE MESSAGE CLASS
	JEFS	CRYPTX			:CLASS 0 IS ALWAYS DISPLAYED

	LHL	R1,CRYPCL,R1,R1		:GET FLAG FOR THIS CLASS
	JNFS	CRYPTX			:DISPLAY IF NOT ZERO

CRYPNO	L	R1,CRYSAV+4		:NO DISPLAY, RESTORE R1
	J	2,R8			:AND RETURN PAST CRYPTO DATA

CRYPTX	LHL	R1,0,R8			:CRYPTO MESSAGE NO. AND FLAGS
	AIS	R8,2			:SET UP TO RETURN PAST CRYPTO DATA HC
	
:	CRYPT1 IS ENTRY POINT FOR WHEN MESSAGE FLAGS ARE SUPPLIED IN R1
:	INSTEAD OF IN THE HALFWORD FOLLOWING THE CALL TO CRYPTO
CRYPT1	STM	R2,CRYSAV+8		:SAVE WORK REGS
	ST	R0,CRYSAV		:	AND CRYPTO DATA
	LHL	R2,CRYPRI		:Get pointer into regular buffer
	
CRYPT3	LHL	R6,FASTC+2,,		:GET LO HW OF FASTC
	EXHR	R6,R6			:SHIFT TO HO HW
	OR	R6,R1			:COMBINE FASTC
					: WITH CRYPTO NUMBER AND MESSAGE FLAGS
	ST	R6,CRYPRB+CRYFAS,R2,	:STORE IT AWAY
	IF	PRIMSG
	LBR	R3,R1			:GET MEG. # BYTE
	TBT	R3,CRYPRY,,		:SEE IF PRIORITY ON
	JEFS	CRPT31
	LHL	R3,CRYPPI		:STORE TO CRYPPB ALSO
	ST	R6,CRYPPB+CRYFAS,R3,
CRPT31	EI	:PRIMSG
	LR	R6,R1			:SAVE R1			###AL
	JAL	R9,GMTCAL,,		:GET CURRENT GMT AT GMTNOW
	LR	R1,R6			:RESUME R1			###AL
	L	R6,GMTNOW		:GET IT AND
	ST	R6,CRYPRB+CRYGMT,R2,	:STORE IT AWAY
	ST	R0,CRYPRB+CRYHW0,R2,	:STORE CRYPTO DATA HW0&1
	L	R4,CRYSBF		:USE R4				###AL
	ST	R4,CRYPRB+CRYHW2,R2,	:HW2&3
	IF	PRIMSG
	LBR	R5,R1			:GET MEG. # BYTE
	TBT	R5,CRYPRY,,		:SEE IF PRIORITY ON
	JE	CRPT32
	LHL	R3,CRYPPI		:RESUME INDICATER
	ST	R6,CRYPPB+CRYGMT,R3,	:STORE IT AWAY
	ST	R0,CRYPPB+CRYHW0,R3,	:STORE CRYPTO DATA HW0&1
	ST	R4,CRYPPB+CRYHW2,R3,	:HW2&3

	AHI	R3,10
	NHI	R3,CRYPPS-1		:Update crypto message index
	STH	R3,CRYPPI
CRPT32	EI	:PRIMSG

	AHI	R2,10
	ci	r2,cryprs		:at end of ring?
	jlfs	crpt35
	lis	r2,0			:wrapped back to start
crpt35	nhi	r2,-10			:in case of crash or corruption, resync
	STH	R2,CRYPRI

CRYPT6	LHL	R14,INTXRF		:REMOTE XRAY USER?
	JEFS	CRYPT9			:NO
	LHI	R14,01F-PXRAY		:YES,SCHEDULE XRAY
	SBT	R14,SQUEUE
	LHL	R14,XUSIUA		:PUT ALL XRAY USERS
	STH	R14,XQUEM		:INTO MASTER QUEUE
CRYPT9	LM	R0,CRYSAV		:RESTORE WORK REGS
	JR	R8			:RETURN
	
CRYARY	HS	10		:INDIVIDUAL BITS ENABLE DISPLAY OF
				:INDIVIDUAL CRYPTO MESSAGES

CRYPCL	HS	0		:CLASSES OF CRYPTO MESSAGES
CRYDEF	HC	1		:CLASS 0 ALWAYS DISPLAYS
	SYAD(CRYDEF)
CRYDIS	HC	DB.CIR		:CLASS 1 - CIRCUIT BUILT, ZAPPED
	SYAD(CRYDIS)
	HC	0
REBDIS	HC	0		:CLASS 3 - REBUILD EVENTS
	SYAD(REBDIS)
	HC	0	:CLASS 4
	HC	0	:CLASS 5
	HC	0	:CLASS 6
	HC	0	:CLASS 7
	HC	0	:CLASS 8
	HC	0	:CLASS 9
	HC	0	:CLASS A
	HC	0	:CLASS B
	HC	0	:CLASS C
	HC	0	:CLASS D
	HC	0	:CLASS E
	HC	0	:CLASS F

	SUBTTL	EXEC

::*********************************************************************
::
::	SUBROUTINE:	HSTORY:
::	FUNCTION:	SAVES EVENT IN HISTORY BUFFER
::	CALLING SEQ:	JAL	R8,HSTORY
::	INPUT:		R0 = EVENT (PRESERVED)
::	DESTROYED:	R1
::
::*********************************************************************

HSTORY	LHL	R1,HISTI
	STH	R0,HISTBF,R1,
	AIS	R1,2
	NHI	R1,HISTSZ-1
	STH	R1,HISTI
	JR	R8



	ENDMO.(EXEC)

:	***END EXEC***

	EI	:1-KILLIT

	KILMSG(EXEC)

:	***NOTHING PAST THIS POINT***


	SUBTTL	SWTCH2

:		 **** *   * *****  ***  *   *  ***
:		*     *   *   *   *   * *   * *   *
:		 ***  * * *   *   *     *****   *
:		    * ** **   *   *   * *   *  *
:		****  *   *   *    ***  *   * *****

::#####################################################################
::
::	MODULE:		SWTCH2
::
::	FUNCTION:	Circuit building and command channel
::			communications processes.
::
::	REGISTER CONVENTIONS:
::
::	SUBTTLS:	IZSWIT:  Switch initialization
::			SWITCH:  Switch exec
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA	0
	SEG	a.code

::*********************************************************************
::
::	TABLE:		KDKN:
::	FUNCTION:	LINK DESCRIPTORS INDEXED BY LINK NUMBER
::
::*********************************************************************
Q	EQ	KDSC
R	EQ	0
KDKN	WS	0			:LINK POINTERS BY DIFFERENTIAL SIZE
	RE	NLINKS
	WC	Q
	IF	\K.S|$A R|		:IF THIS LINK IS STARLINK
Q	EQ	Q+SKDSZ			:STRLNK DESCRIPTOR SIZE
	ELSE	\T.OH|$A R|
Q	EQ	Q+TNKDSZ		:ELSE TUNNEL LINK SIZE
	ELSE
Q	EQ	Q+KDSZ			:ELSE TII LINK SIZE
	EI
R	EQ	R+1
	ER
	SYAD(KDKN  )

::*********************************************************************
::
::	TABLE:		HMSK:
::	FUNCTION:	HALFWORD MASK ARRAY
::			YIELDS HC 8000,4000,2000,ETC...
::
::*********************************************************************

HMSK	HS	0
Q	EQ	8000
	RE	10
	HC	Q
Q	EQ	Q^-1
	ER

::*********************************************************************
::
::	TABLE:		WMSK:
::	FUNCTION:	WORD MASK BIT ARRAY
::
::*********************************************************************

WMSK	WS	0			:WORD MASK BIT ARRAY
	NOLIST
	RE	20
	WC	1^(1F-(.-WMSK)/4)
	ER				:80000000,40000000,20000000, ETC.
	LIST

	SUBTTL	SWTCH2 (IZSWIT - Switch initialization)

::*********************************************************************
::
::	SUBROUTINE:	IZSWIT:
::	FUNCTION:	Initializes SWITCH
::	CALLING SEQ:	JAL	R10,IZSWIT
::
::*********************************************************************

DEAD	EQ	0DEAD			:for BF entry, etc.	###jhl

:	Init CHNMAP.  CHNMAP is a FW array used by the TRACE logic to
:	figure out where circuits are headed.  The HO HW is the absolute
:	channel of relative channel 0 for the channel range.  The LO HW
:	is an index into CHNMPD (if positive, otherwise it is a flag for
:	terminating circuits).

:	Init CHNMAP for internal control (ILC, BPM) channels (CHNMPD index=-6)
IZSWIT	LI	R0,LNKLFL^10+0FFFA
	ST	R0,CHNMAP		:ILC, BPM CIRCUITS (INT CONTROL CIRCS)

:	Init CHNMAP for link channels (CHNMPD index=2*link#)
	LI	R0,LNKLFL^10+2*(NLINKS-1)
	LIS	R1,4
IZSWA	ST	R0,CHNMAP,R1		:LEFT HALF CHANNEL 0 #,
					: RIGHT HALF CHNMPD INDEX
	SIS	R0,2
	AIS	R1,4
	CLHI	R1,4*NLINKS		:DONE ALL LINKS?
	JLEBS	IZSWA			:NO - CONTINUE

:	Init CHNMAP for dispatcher ports (CHNMPD index=-3)
	LI	R0,DISZFL^10+0FFFD	:DISPATCHER PORTS (-3)
	ST	R0,CHNMAP,R1
	AIS	R1,4

:	Init CHNMAP for sup ports (CHNMPD index=-2)
	IF	SUPER
	LI	R0,SUPZFL^10+0FFFE	:SUP PORTS (-2)
	ST	R0,CHNMAP,R1
	AIS	R1,4
	EI	:SUPER

:	Init CHNMAP for kernel and internal ports (CHNMPD index=HST0)
	LI	R0,INTZFL^10+8000+HST0
	ST	R0,CHNMAP,R1
	AIS	R1,4

:	Init CHNMAP for internal host ports (CHNMPD index=-4),
:	LEP ports  (CHNMPD index=-5), transient	state ports (CHNMPD index=-7)
	LI	R14,LEPZFL^10+0FFFB	:COMMAND CIRCUIT (-5)
	LI	R15,0FFF9		:TRANSIENT STATE (-7)
	STM	R14,CHNMAP,R1

:	Init downline load cells (DWTEST, DWLDSP)
	LIS	R0,1
	STH	R0,DWTEST		:INITIALIZE DWLIN SEMAPHORE
	LIS	R0,0
	ST	R0,DWLDSP		:CLEAR DWL DISPATCH ARRAY
	ST	R0,DWLDSP+4

:	Init various bit arrays and pointers, link by link
	LHI	R0,LNKZFL		:FIRST CHANNEL NUMBER FOR NETWORK LINKS
	LIS	R1,0
	lis     r2,0
	LHI	R7,LNKACP-2,		:LAST HW BEFORE ACP ARRAY
	LHI	R8,LNKCHS-2,		:LAST HW BEFORE CHS ARRAY
	LHI	R3,-2*NLINKS		:LINK FIELD INDEX
IZSWB	STH	R0,LKZFKN+2*NLINKS,R3,	:ABSOLUTE CHANNEL FOR RELATIVE CHAN 0
	STH	R2,TBDPKN+2*NLINKS,R3,	:START OF TABLES..
	STH	R2,EBDPKN+2*NLINKS,R3,	:..END OF TABLES
	STH	R1,FLDPKN+2*NLINKS,R3,	:START OF FLAGS FOR THIS LINK
	STH	R7,LKAPND+2*NLINKS,R3,	:LAST HW IN ACP ARRAY
	STH	R8,LKCSND+2*NLINKS,R3,	:LAST HW IN CHS ARRAY
	srls    r0,3
	ah	r0,lnkngr+2*nlinks,r3   :offset to next link's start
	slls    r0,3
	ah	r1,lnkngr+2*nlinks,r3   :flags offset
	srls    r2,4
	ah	r2,lnkngr+2*nlinks,r3
	slls    r2,4
	ah	r7,lnkngr+2*nlinks,r3   :acp
	ah	r8,lnkngr+2*nlinks,r3   :chs
	AIS	R3,2			:DO FOR ALL LINKS
	JL	IZSWB

	LHI	R3,-ACPSZP*4		:1/2 ARRAY SIZE, FULLWORD INDEX
	LCS	R1,1

:	Init ACP and CHS (to 1's to indicate channels available).
:	Note ACP and CHS must be contiguously allocated.
IZSWC	ST	R1,ACPBSE+ACPSZP*4,R3,	:SET ACP, CHS TO -1
	AIS	R3,4
	JLBS	IZSWC

:	Init table space
	LHI	R0,TCHANS*2		:END OF TABLE SPACE
	STH	R0,TBDPKN+2*NLINKS,,
	LHI	R0,TCHANS/80
	STH	R0,NUMPAG,,		:NUMBER OF FREE PAGES

	LHI	R1,DEAD			:LINK AVAILABLE BUFFER PAIRS
	LHI	R2,CIRZBF
	STH	R2,FREELB		:HEAD OF FREE PAIR LIST

:	Init buffer linkages (using BB), BF's to "DEAD",
:	free buffer pair list (FREELB).
IZSW1	AIS	R2,8
	STH	R2,BB-8,R2,		:BB USED FOR CHAINING
	STH	R1,BF-8,R2,		:ATTENTION FLAGS SET TO 'DEAD'
	STH	R1,BF-4,R2,
	LR	R3,R2
	SRHLS	R3,1
	IF	REBILD
	STH	R1,BF+HBUFN-4,R3,
	EI	:REBILD
	CI	R2,8*NCIRCS
	JN	IZSW1

	LIS	R0,0			:LAST PAIR GETS A ZERO
	STH	R0,BB-8,R2,
	STH	R1,BF-8,R2,


:	Init bufferlet chain and free bufferlet list (FREELT).
:	Bufferlets are 64d bytes long (CBSZ-2)--the last HW links to the next
:	bufferlet, the previous 62 bytes are for data.  Linking is done
:	via bufferlet number, bufferlet address divided by bufferlet size.
:	The actual address of a bufferlet is computed by shifting its number
:	by CBSZL and adding 2 to get first data location and adding CBSZ
:	to get it's pointer.  This may seem pointlessly complicated, but
:	buffering is a serial function from first char to last char so
:	it is easier to have pointer at end of buffer (already there from
:	either writing or getting) and buffer address point to beginning
:	(actually hw prior which is why 2 is added) of bufferlet.  Saves
:	instructions this way when using bufferlets.
:	Since FW arithmetic is used, bufferlet storage can span segment
:	boundaries.
:	For MAC V with specified DMA region the DMA region will usually
:	not be specified exactly.  In such cases then use extra memory for
:	bufferlets.  Note that all this requires is proper initialization
:	since bflets buffer number 0 is address 0 and so as long as
:	one contigious block of bufflets is correctly linked to the other
:	block of bufferlets then no buffer routine would ever notice
:	something ricky happened.

	li	r0,(chrbuf-cbptsz)/(1^cbszl) :number of zereoth bflet
	STH	R0,FREELT		:HEAD OF THE FREE LIST
	ahi	r0,cbsz/(1^cbszl)	:number of 1st bflet
	LA	R1,CHRBUF,,		:ADDRESS OF ZEROETH BUFFERLET
	LI	R2,NBFLET-1		:USE FW FOR A BIG POOL##AL

IZSW2	STH	R0,CBSZ-cbptsz,R1	:STORE # OF FOLLOWING BFLET
	AHI	R1,CBSZ
	AHI	R0,cbsz/(1^cbszl)
	SIS	R2,1
	JGBS	IZSW2

	if	macv*dmaavl		:if macv has a specified dma region
	li	r2,nbfle0		:how many seg 0 bufferlets
	je	izsw23			:none so skip
	li	r0,(chrbu0-cbptsz)/(1^cbszl) :number 0th seg 0 bflet
	sth	r0,cbsz-cbptsz,r1	:store into last of normal bflet area
	la	r1,chrbu0,,		:address of start of seg 0 bflets
	AHI	R0,cbsz/(1^cbszl)
	LI	r2,nbfle0-1

IZSW22	STH	R0,CBSZ-cbptsz,R1	:STORE # OF FOLLOWING BFLET
	AHI	R1,CBSZ
	AHI	R0,cbsz/(1^cbszl)
	SIS	R2,1
	JGBS	IZSW22
	ei	:second block of bufferlets
		

izsw23	LIS	R0,0			:LAST BUFFERLET LINK GETS A 0
	STH	R0,CBSZ-cbptsz,R1

:	Schedule CKZB to fill reserve tank first thing
	LHI	R0,1F-PCKZB
	SBT	R0,SQUEUE		:FILL RESERVE TANK

:	Init CRQ buffer flag (BB=0)
	LHI	R0,CRQZFL		:INIT CRQ BUFFER FLAG
	STH	R0,BB,,

:	Build sup circuit to LEP
	IF	SUPER
	JAL	R9,SUPCRQ,,		:BUILD CIRCUIT FROM SUP TO LEP
	EI	:SUPER

:	Init downlin load channels (DWLNUM)
	LCS	R0,1			:INIT DOWN-LINE LOAD 
	LIS	R1,TINTCH-1
IZSDWL	STH	R0,DWLNUM,R1,R1
	SIS	R1,1
	JGEBS	IZSDWL


:	Init PLI message count (-1=nada)
	STH	R0,PLICNT		:INIT PLI MESSAGE

:	Init (-1) the sup NOP flag to idle
	STH	R0,LEPNPF		:INIT SUP NOP FLAG TO IDLE STATE

:	Init (-1) SUPIBF to indicate no diagnostic node	reports formatted
	STH	R0,SUPIBF		:NO DIAGNOSTIC NODE REPORTS FORMATTED

:	EXPANDED HOST TABLES FOR PROPER HOST INFORMATION MAINTENANCE
	LHI	R0,HST0			:STORE KERNEL HOST NO.		###OAS
	STH	R0,HOSTN		:INTO FIRST ENTRY IN HOST # TABLE##OAS
	lis	r0,0
	sbt	r0,hstflg		:indicate host is up and taken
       IF	MXPNM
	LHI     R0,MXPNM		:NSR 1094 report kernel host with
	STH     R0,HSTKEY,,		:it's host key
       EI	:MXPNM
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	ST	R0,HSTTIM		:STORE IN FIRST ENTRY OF HOST TIME#OAS
	LHI	R0,NKU			:ANY KERNEL PORTS?		###OAS
	JNFS	IZSSI3			:YES, INDICATE HOW MANY PORTS	###OAS
	LIS	R0,2			:NO, INDICATE 2 PORTS		###OAS
IZSSI3	STH	R0,HSTPTA		:IN PORTS AVAILABLE ARRAY	###OAS

	IF	SUPER
	LHI	R0,SUPTYP		:SUPERVISOR PID			###OAS
	ELSE	SPLIT	
	LHI	R0,SKERTY		:SPLIT SUPERVISOR PID	###OAS	###wjl
	ELSE	SWTCHR
	LHI	R0,TIITYP		:ASSUME TII PID			###OAS
	ELSE	:none of the above
	LHI	R0,I2ISTP		:ISIS PID			###OAS
	EI	:SPLIT
	STB	R0,HSTYPE		:STORE KERNEL HOST TYPE

:	Clear accounting flags (ACT7, ACTLST)
	LCS	R0,1			:CLEAR ACCOUNTING FLAGS
	ST	R0,ACT7lo+0
	ST	R0,ACT7lo+4
	ST	R0,ACT7lo+8
	ST	R0,ACT7hi+0
	ST	R0,ACT7hi+4
	ST	R0,ACT7hi+8
	LIS	R0,8			:SET INDEX TO INVALID
	STB	R0,ACTLST

:	initialize the xray user names to uppercase
	li	r0,xsgdwa		:need to write to seg d ###sln
	svc     sys,11
	lis     r1,0			:index into tables
izxrgg  lis     r2,0			:index to char
izxrg2  lb	r0,xraygg+xggnam,r1,r2  :get char
	ohi     r0,80
	clhi    r0,0e1			:lower case?
	jlfs    izxrg1
	clhi    r0,0fa			:lc z?
	jgfs    izxrg1
	nhi     r0,0df			:make uppercase
	stb     r0,xraygg+xggnam,r1,r2
izxrg1  ais     r2,1			:next char
	clhi    r2,0c			:upto 12 (D) chars
	jle     izxrg2			:next char
	ahi     r1,xggsiz		:next entry
	clhi    r1,xgglen		:all entries done?
	jl	izxrgg
	li	r0,xsgdwp		:### sln
	svc     sys,11			:restore protect to seg d ###sln

:	Set threshhold for reporting circuit errors.
	LHI	R0,RPTHCE
	STH	R0,NC.THS		:SET REPORT THRESHOLD FOR CIRC ERRORS

:	Return when done
	JR	R10			:RETURN

	SUBTTL	SWTCH2 (SWITCH - Switch exec)

::*********************************************************************
::
::	PROCESS:	SWITCH:
::	FUNCTION:	Switch exec loop dispatches to various sub-processes
::		based on their attention flags:
::		LEP    - process data on a command channel
::		CRQ    - complete second half of circuit building process
::		LOGGER - process ports currently in login mode
::		INTHST - process data for internal hosts
::		DETCIR - detached circuit processing
::
::*********************************************************************

:	DUMMY DEBUG PROCESS NUMBERS FOR SWITCH SUBPROCESSES		###wjl
:	FORM PROCESS NUMBER * 4 FOR FW INDEX INTO PROTIM, PACTIM,	###wjl
:	PROHWM, PSVTIM ARRAYS ALLOWING USE OF CPRHWM AND MPRTIM ROUTINES###wjl
	IF	SWITIM			:SWITCH MAX PROCESS TIME debug	###wjl
PLAST	EQ	(1F-PGMSRK)^2		:last Process number * 4	###wjl
PLEP	EQ	PLAST+4			:dummy debug Process # for LEP	###wjl
PCRQ	EQ	PLEP+4			:CRQ				###wjl
PLOGGR	EQ	PCRQ+4			:LOGGER				###wjl
PINTHS	EQ	PLOGGR+4		:INTHST				###wjl
PASYLO	EQ	PINTHS+4		:ASYLOU				###wjl
PLGGO	EQ	PASYLO+4		:LGGO				###wjl
PDETCR	EQ	PLGGO+4			:DETCIR				###wjl
	EI	:SWITIM			:				###wjl


SWITCH	HS	0
	if	db.sd1
	jal	r8,d.sdw
	ei

:	See if foreground formatted a diagnostic node report (SUPIBF>=0).
:	If so call NETDGN to send node report and cryptogram.
:	Else skip to SWINOP.
	IF	(1-T2GATE)		:###EV
	TS	SUPIBF			:ANY WORK TO DO?
	JLFS	SWINOP			:NO
	L	R8,SUPIBF+2		:GET MESSAGE AND MOVE TO
	ST	R8,SUPMBF+2		:PROPER BUFFER
	SRL	R8,18			:SET UP DIAGNOSTIC SUB-TYPE
	JAL	R9,NETDGN,,		:SEND CRYPTOGRAM, NODE REPORT
	EI	:(1-T2GATE)		:###EV

:	If supe NOP command is throttle (LEPNPF>=0), then go see if output has
:	been drained enough to continue	artificial load to supe (LEPNP4).
:	Else continue.
SWINOP	IF	SWITIM			:				###wjl
	LHI	R2,PLEP			:load LEP dummy debug process id (*4)
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	TS	LEPNPF			:IS SUP NOP COMMAND THROTTLED?
	JGE	LEPNP4,,		:YES - SEE IF OUTPUT DRAINED ENOUGH TO
					:CONTINUE ARTIFICIAL LOAD TO SUP

:	If any supe command data for LEP, go there and process it.
:	Else continue at SWICRQ.
SWILEP	LB	R1,LEPFLG,,		:PROCESS SUP COMMANDS
	JEFS	SWICRQ			:NO DATA FROM SUPERVISOR
	jal	r10,lep,,
	if	db.sd1
	jal	r8,d.sdw
	ei

:	If any needles have come in through LEP or RTD into CRQBUF,
:	go to CRQ to handle them.  Else continue at SWILOG.
SWICRQ	IF	SWITIM			:				###wjl
	LHI	R2,PLEP			:load LEP dummy debug process id (*4)
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	LHL	R0,BCT,,		:HERE IF SWIVSV = 0. PROCESS NEEDLES
	JE	SWILOG			:NO CIRCUITS TO BUILD		###wjl

	IF	SWITIM			:				###wjl
	LHI	R2,PCRQ			:load CRQ dummy debug process id (*4)
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	CRQ,,			:HANDLE NEEDLES FOR HALF-BUILT CIRCUITS

:	Yield after CRQ is done
CRQRET	IF	SWITIM			:				###wjl
	LHI	R2,PCRQ			:load CRQ dummy debug process id (*4)
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	if	db.sd1
	jal	r8,d.sdw
	ei
	JAL	R0,EXYLD		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

:	If any login input data waiting to be processed	(LOGBUF), go to LOGGER.
:	Else continue at SWIINT.
SWILOG	
       if	1-NCSLOT
	LHL	R0,BCT+4,,		:PROCESS PORTS IN LOGIN MODE
	JE	SWIINT			:NO PORTS CURRENTLY IN LOGIN MODE##wjl


	IF	SWITIM			:				###wjl
	LHI	R2,PLOGGR		:load LOGGER dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	LOGGER,,		:LOOK FOR LOGIN STRING FROM LOCAL PORT

:	Yield after LOGGER runs
LOGRET	IF	SWITIM			:				###wjl
	LHI	R2,PLOGGR		:load LOGGER dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

       EI	:1-NCSLOT

:	If any data for internal hosts, go to INTHST to process it.
:	Else continue at SWIALO.
SWIINT	LHL	R2,INTFLG,,		:PROCESS DATA FOR INTERNAL HOST
	JE	SWIALO			:NO INTERNAL HOST ACTIVITY	###wjl


	IF	SWITIM			:				###wjl
	LHI	R2,PINTHS		:load INTHST dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	INTHST,,		:LOOK FOR DATA FOR AN INTERNAL HOST

:	Yield after INTHST runs
INTRET	IF	SWITIM			:				###wjl
	LHI	R2,PINTHS		:load INTHST dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD		:ALLOW HIGHER-PRIORITY PROCESS TO RUN


:	If any data for detached ports, go to DETCIR to	handle.
:	Else return to EXEC via SWIRET.
SWIALO	L	R2,DETFLG,,		:DATA FROM A DETACHING PORT?
	JE	SWIRET		:NO - RETURN TO EXEC


	IF	SWITIM			:				###wjl
	LHI	R2,PDETCR		:load DETCIR dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	DETCIR,,		:YES - EXAMINE AND PROCESS

:	Yield after DETCIR runs.  Then return to EXEC via SWIRET.
DETRET	
	IF	SWITIM			:				###wjl
	LHI	R2,PDETCR		:load DETCIR dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

					:no EXYLD since doing return anyway#sdw


	J	SWIRET


	ENDMO.(SWTCH2)

	EI	:1-KILLIT

	KILMSG(SWTCH2)

:	***NOTHING PAST THIS POINT***

	SUBTTL	LINKER

:		*     ***** *   * *   * ***** ****
:		*       *   **  * *  *  *     *   *
:		*       *   * * * ***   ***   ****
:		*	*   *  ** *  *  *     *  *
:		***** ***** *   * *   * ***** *   *

::#####################################################################
::
::	MODULE:	 LINKER
::
::	FUNCTION:  Creates, monitors, maintains, and tears down links
::		to neighbor nodes.	###OSF 5/77
::
::	REGISTER CONVENTIONS:
::		CD  = R13	:pointer to record Descriptor
::		KD  = R15	:pointer to linK Descriptor
::		KN  = R11	:linK Number
::		LN  = R14	:Line Number
::		SD  = R12	:pointer to reset Data buffer
::
::	ROUTINES:
::		IZLNKR - LINKER segment initializer
::		SIOIZ  - Initiialize SIO lines
::		SIQURY - Query SIO status			###LSH
::		LKVOLT - Test for network links overloaded or saturated
::		LINKER - Detach, attach scheduler
::		LNCHCK - 4 sec test for records received on lines
::		LDRPRT - Diagnostics and reporting
::		ATTLIN - Line attach logic
::		DETLIN - Line detach logic
::		SYLVER - Dispatcher for input on sync lines
::			 SIO input processor
::			 SIO output processor
::			 Sync input processor
::
::#####################################################################

:	SYNC LINE FORMATS
:
:	TYMNET-II:
:
:	HEADER:		00TTSSSSAAAAAAAANNNNNNNN
:	NEW LINK RESET:	001100001010PPPP + NODE #
:	NEW LINE RESET:	001100001011PPPP + NODE # OR KEY
:	NULL:		0011000001101001 + 78AB + CHECKSUMS
:	DOWNLINE LOAD:	0011001000110010
:
:	T-II Expanded Reset Packet:###wjl
:
:	New Link Reset: 001100111010PPPP + NODE # +VERSION+NETID+SUBNET+
:			WSIZ+LN+HST0+RSRSN+KSPD+KATTR+DIALUP + CHECKSUMS
:	New Line Reset: 001100111011PPPP + NODE # OR KEY +(same as new link)
:
:	WHERE:	X=1 IF FROM SLAVE
:		S=HW COUNT OR LENGTH FACTOR
:		N=RECORD #
:		A=ACKNOWLEDGEMENT
:		P=PING-PONG COUNT
:		TT=10 IF FROM MASTER, 01 FROM SLAVE

	IF	1-KILLIT		:TO ASSEMBLE OR NOT TO ASSEMBLE
	BEGMO.

	SUBTTL	LINKER (Read-only data)

	SEG	a.code
	SETRAD(0A)			:set decimal radix


Q	EQ	0
NEIKN	HS	0
	SYAD(NEIKN )
	RE	NLINKS			:NEIGHBORS ON LINKS
	IF	\NEI|Q|
	HC	NEI|Q|
	ELSE
	HC	0
	EI
Q	EQ	Q+1
	ER


:	Normal nodes only get window size - special get other parameters ###ev
Q	EQ	0
WSZKN	HS	0
	RE	NLINKS
	HC	WSIZ|Q|
Q	EQ	Q+1
	ER


:	space link tables at startup so bubbles don't have to move other
:	link tables about.
q       eq      0
qq      eq      0       	:make sure have enough table space
lnkngr  hs      0
	re      nlinks
	if      \kngr|q|
	hc      2*kngr|q| 	:2*to make 8 groups into 16 bytes for 128 bits
qq      eq      qq+2*kngr|q|
	else    :not defined
	hc      $0 10   	:give default spacing
qq      eq      qq+$010
	ei
q       eq      q+1
	er	:nlinks
syad(LNKNGR)

	if      8*qq-tchans+1
	Remark%%TIILNKs define more groups than available channels.
	remark%%Fatalistic error.  Assembly aborted.
	quit
	ei

:	the desired retransmisstion delay for this link (needed for that
:	darn atc to act like a 2.4's retran logic and maybe testing will
:	reveal other values work better for other lines as well).

q	eq	0
lnkrtr	hs	0
	re	nlinks
	if	\rdel|q|
	hc	rdel|q|
	else
	hc	0		:for xlinks
	ei
q	eq	q+1
	er
syad(LNKRTR)

:	save assembly time windowsize since xray WZ cmd can change the
:	windowsize in WSZKN.  prevents XRAY user from setting windowsize
:	larger than number of available record descriptors.

XWSZKN	HS	0
Q       EQ      0
	RE      NLINKS
	HC      WSIZ|Q|
Q       EQ      Q+1
	ER

:	TYM FILE DECLARATION MAY INCLUDE LINK SPEEDS FOR SELECTED
:	LINKS.  THIS OPTION IS PROVIDED DUE TO THE NODE'S DIFFICULTY
:	COMPUTING LINE SPEEDS ON FAST SIO LINES.  A CONFIGURATION LINK
:	SPEED IS PRESENT IF THE SYMBOL 'KNSP|#|' IS DEFINED FOR LINK
:	NUMBER #.

:	init bit array by setting symbols that will be used
ibarra	macro(name,size)[
.q	eq	0
	re	$0 (size+1f)/20
name|.q| eq	0
.q	eq	.q+1
	er
]

:	set bit in array of name|0-f|
barray	macro(name,val)[
.q	eq	$0 val/20
.qq	eq	$0 val-(20*.q)
name|$0 .q| eq	$0 name|.q|!(1^(1f-.qq))
]

:	make the bit array into memory
mbarra	macro(name,size)[
.q	eq	0
	re	$0 (size+1f)/20
	wc	name|.q|
.q	eq	.q+1
	er
]

	ibarra(qqq,nlinks)		:values for links with defined speeds
	ibarra(qqqqq,nlinks)		:values for links with sat set
	ibarra(qqqqa,nlinks)		:values for links with apply bp set
	ibarra(qqqqc,nlinks)		:values for links with SWCKSM set

	KILL	.RELOP			:stupid macro to get around RE loop
					:limitation of 640 chars.
.RELOP	MACRO[
	IF	\KNSP|Q|		:THIS INDICATES HIGH SPEED CONFIGURED
	if	knsp|q|-31		:is value bigger than 1f? (5 bits)
qqx	eq	$0 1f			:max for reporting
	else	:
qqx	eq	knsp|q|			:temp holding value
	ei
	barray(qqq,q)			:speed set for this link
	IF	\KSAT|Q|		:didn't define KSAT|Q|
KSAT|Q|	EQ	KSAT|Q|!(qqx)		:ADD SPEED TO LINK SPEED FIELD
	EI	:\KSAT|Q|
	EI	:\KNSP|Q|

	IF	\KSAT|Q|		:###jhl
	IF	KSAT|Q|&$020		:IF SAT BIT SET IN KSAT BYTE
	barray(QQQQQ,q)			:SET SAT BIT FOR THIS LINK
	EI	:KSAT|Q|&$040
	EI	:\KSAT|Q|		:###jhl

      IF	\XABP|Q|
       IF	XABP|Q|			:only if set
	BARRAY(QQQQA,Q)			:apply bp set for this link
       EI
      EI

      IF	\XSWC|Q|
       IF	XSWC|Q|			:only if set
	BARRAY(QQQQC,Q)			:software chekcsums for this link
       EI
      EI
]

Q	EQ	0		:LINK NUMBER

	RE	NLINKS
	.RELOP			:do all for each link
Q	EQ	Q+1			:CHECK ALL LINKS
	ER


KNCNSP	WS	0			:BIT SET IF LINK SPD DEFINED BY CONFIG
	mbarra(qqq,nlinks)
KNCNST	WS	0			:bit set if satellite link
	mbarra(qqqqq,nlinks)

KNSAT	HS	0
Q	EQ	0
	RE	NLINKS
	DEFAULT(KSAT|Q|,$0 80)
	BC	KSAT|Q|&($0@40)		:not with apply bit
Q       EQ      Q+1
	ER

:	saves real link speed (needed to distinguish between ms and 256 kb
knrspd	bs	0		
q	eq	0
	RE	NLINKS
	if	\knsp|q|		:only if defined
	bc	knsp|q|			:the actual link speed given in tiilnk
	else
	bc	0			:none set
	ei
Q       EQ      Q+1
	ER

       if	aplybp
KNa.bp	WS	0			:BIT SET IF apply bp wanted
	mbarra(qqqqa,nlinks)
       ei	:aplybp

       IF	S.CKSM
KNS.CK	WS	0
	MBARRA(QQQQC,NLINKS)
       EI	:S.CKSM

	setrad(0)			:RESTORE HEX RADIX

	HS	0

:	following is to remove a MH ccdsz and make it a table lookup.
:	for sio lines it is about 3% of cpu.
	ra      0a
q       eq      0
qq      eq      0
	re      nlinks
	if      wsiz|qq|-q
q       eq      wsiz|qq|
	ei
qq      eq      qq+1
	er			:largest of the windows is q
CCDSZ	hs      0
qq      eq      0
	re      q
	hc      qq*cdsz
qq      eq      qq+1
	er

	ra      0
TTRSET	WS	0			:TYMNET-II INITIAL RESET PATTERN
	HC	TTRSHD			:HEADER
	HC	MACHNM			:NODE NUMBER
	HC	TTRSHD%MACHNM		:VERT CHKSM
	HC	TTRSHD^2%MACHNM^1%TTRSHD%MACHNM	:DIAG. CKSUM

VERCOM	EQ	((VERSION&0FFF)^10)!((@(VERSION&0FFF))&0FFFF)		:###wjl

Q	EQ	0			:DISPLACEMENT OF INPUT BUFFERS
SVBDIS	RE	NLINES
	HC	Q;Q EQ Q+2+SVNBSZ
	ER

Q	EQ	SDSC			:RESET BUFFER PTRS BY LINE #
	WS	0
SDLN	RE	NLINES
	WC	Q;Q EQ Q+SDBSZ
	ER
	SYAD(SDLN  )			:frequently needed      	###sdw
:	SET UP ARRAYS AND COUNTERS FOR SIO LINES

	IF	SILINS

Q	EQ	(NLINES-SILINS)		:FIRST SIO LINE NUMBER
SIBUFP	EQ	.-q*2
	SYAD(SIBUFP)			:	SIO AREAS
	RE	SILINS
	HC	.lka|$a q|-sibuf
Q	EQ	Q+1
	ER

:	sio max packet size is given as 82x bytes so point to wrap is 84
:	bytes from the end
Q	EQ	(NLINES-SILINS)		:FIRST SIO LINE NUMBER
SIBUFW	EQ	.-q*2			:pointer address before wrapping
	RE	SILINS
	HC	.lkz|$a q|-(siofsz+2)	:input buffer wrap point for each line
Q	EQ	Q+1
	ER

.lsped	macro[
	if	$a 1-(512%qq)		:ms
qqq	eq	1f
	else	$a 1-(31%qq)		:ms
qqq	eq	1f
	else	$a 1-(256%qq)		:256
qqq	eq	6a
	else	$a 1-(192%qq)		:192
qqq	eq	50
	else	$a 1-(128%qq)		:128
qqq	eq	35
	else	$a 1-(72%qq)		:72
qqq	eq	1e
	else	$a 1-(64%qq)		:64
qqq	eq	1b
	else	$a 1-(56%qq)		:56
qqq	eq	17
	else	$a 1-(48%qq)		:48
qqq	eq	14
	else	$a 1-(38%qq)		:38
qqq	eq	10
	else	$a 1-(28%qq)		:28
qqq	eq	0c
	else	$a 1-(19%qq)		:19.2
qqq	eq	08
	else	$a 1-(14%qq)		:14.4
qqq	eq	06
	else	$a 1-(9%qq)		:9.6
qqq	eq	04
	else	$a 1-(7%qq)		:7.2
qqq	eq	03
	else	$a 1-(4%qq)		:4.8
qqq	eq	02
	else	$a 1-(2%qq)		:2.4
qqq	eq	01
	else				:not defined
qqq	eq	0
	ei
]

:	the line speed for each sio line (if declared)
Q	EQ	(NLINES-SILINS)		:FIRST SIO LINE NUMBER
SILSPD	EQ	.-q*2			:line speed in LU macro
	RE	SILINS
	default(.lks|$a q|,0)
qq	eq	.lks|$a q|
	.lsped()		: get around nad 640 in a repeat loop limit
	HC	qqq		:
Q	EQ	Q+1
	ER
	kill	.lsped

:	SIO BUFFERS ARE RELOCATED TO SEG 2, SO FULLWORDS ARE NEEDED
:	TO STORE ADDRESSES		:###LSH
Q	EQ	(NLINES-SILINS)*2	:FIRST SIO LINE NUMBER
	WS	0			:force to FW boundary!		###wjl
SIOIN	EQ	.-Q*2			:INPUT CCW BLOCK ADDRESSES
R	EQ	0
	RE	SILINS
	WC	SIOBLI+R
R	EQ	R+10
	ER

SIORSP	EQ	.-Q*2			:RESET BUFFER POINTERS
R	EQ	0
	RE	SILINS
	WC	SIOBLR+R
R	EQ	R+30			:larger SIO reset buffer needed
	ER

	SYAD(SIOIN )
	SYAD(SIORSP)			:pair of useful symbols
      EI	:SILINS

SIOBLA	WS	0			:address where output rotor/CCW
					:set/pair starts
      IF	sylins			:do sync lines first
Q	EQ	0
	RE	sylins
	WC	OROTOR+Q*20		:rotor is 32d bytes per line
Q	EQ	Q+1
	ER
      EI	:sylins
      IF	SILINS			:address of first CCW for each line
Q       EQ      0
	RE      SILINS
	WC      SIOD|Q|
Q       EQ      Q+1
	ER
      EI	:SILINS
	SYAD(SIOBLA)		:useful address

:	SIONCH is the address of the last rotor/CCW for the line.  It
:	must be a power of 2 minus 10 (ie 10, 30 or 70)
SIONCH	HS	0
Q	EQ	0
      IF	sylins			:do sync lines first
	RE	sylins
	HC	20-10			:rotor is 32d bytes per line
Q	EQ	Q+1
	ER
      EI	:sylins
      IF	SILINS			:address of first CCW for each line
	RE      SILINS
	HC	(ncha|$a q|*($010-0))-10	:all except the last ccw
Q       EQ      Q+1
	ER
      EI	:SILINS

dwobla
q	eq	0
	if	tintch-numxlt	:in case all are line tester possible
	re	tintch-numxlt
	hc	q		:size of load only chns
q	eq	q+DWLBSZ
	er
	ei
	re	numxlt
	hc	q		:size of line tester possibles
q	eq	q+xltpsz
	er

      IF	SILINS
	WS      0
SIOIPG  EQ      .-((NLINES-SILINS)*4)   :access by line # (not sio relative)
Q       EQ      0
	RE      SILINS
	WC      SOPG|Q|
Q       EQ      Q+1
	ER

	EI	:SILINS

STRTYP	EQ	0C			:STARLINK LINK TYPE
DWICNT	EQ	1F0		:Count of halfwords for DWL input transfer

	SUBTTL	LINKER (IZLNKR - LINKER segment initializer)

::*********************************************************************
::
::	SUBROUTINE:	IZLNKR:
::	FUNCTION:	LINKER segment initializer
::	CALLING SEQ:	JAL	R10,IZLNKR	Called from NSTART. 
::	CALLS:		JAL	R9,GFRCHN
::			JAL	R8,HCSET
::			JAL	R9,RSTSTR
::			JAL	R8,HCLEAR
::
::*********************************************************************

IZBREC	STH	R1,RLNK,CD		:RLNK POINTS TO NEXT REC DESCR IN CHAIN
	ST	R2,BREC,CD		:BREC POINTS TO RECORD DATA BUFFER
	LR	CD,R1			:ADVANCE TO NEXT RECORD DESCRIPTOR
	AHI	R1,CDSZ
	Ar	R2,r8			:ADVANCE TO NEXT DATA BUFFER
	SIS	R3,1			:REPEAT IF MORE RECORDS LEFT
	JGbs	izbrec
	jr	r9			:done

IZLNKR	ST	R10,IZLNLR		:SAVE LINK REGISTER

	lcs     r0,1
qq      eq      0
	re      lksize/4
	st      r0,borzap+qq    	:init borzap so links can talk  ###sdw
qq      eq      qq+4
	er

::Now link the Record Descriptors together for each link
	LI	CD,CDSC			:LINK THE RECORD DESCRIPTOR CHAIN
	STH	CD,FREELR
	LI	R1,CDSZ+CDSC
	La	R2,recbuf,,		:output buffers
	LHI	R3,nrecd0		:those before sio dma
	lhi	r8,orcbsz		:size of buffer
	jal	r9,izbrec
	LI	R2,RECBU1		:rest of out and input
       if	bigcon
	LHI	R3,nrecd1		:those after sio dma
	lHI	R8,oRCBSZ		:ADVANCE TO NEXT DATA BUFFER
	jal	r9,izbrec
       ei 	:bigcon
	lhi	r3,nrecds/2		:the input buffers
	lhi	r8,recbsz
	jal	r9,izbrec

	LCS	R0,1			:LAST RECORD GETS A -1 IN RLNK
	SHI	CD,CDSZ
	STH	R0,RLNK,CD
       IF	 LNKDBG  		:				###sdw
	STH	R0,PSLNUM		:PAKET SAVE FLAG INIT TO 0FFFF ###AL
       EI 	:LNKDBG

:	THE RECORD DESCRIPTORS ARE ALL CHAINED. NEXT, ASSIGN 'WSIZE'
:	RECORD DESCRIPTORS TO EACH LINK FOR INPUT AND OUTPUT. THE 'RLNK'
:	FIELD OF THE LAST RECORD DESCRIPTOR ASSIGNED ON A LINK IS SET
:	TO POINT BACK TO THE FIRST RECORD DESCRIPTOR, FORMING A CLOSED
:	RING OF 'WSIZE' RECORD DESCRIPTORS.
::	LHI	KD,KDLST		:INIT LINK DESCRIPTORS

:	start to initialize every KD


	LHI	R8,2*(NLINKS-1)		:2*LAST LINK #
IZLN2	L	KD,KDKN,R8,R8		:GET LINK DESCRIPTOR POINTER
	LHL	R1,XWSZKN,R8		:can't be changed by xray WZ cmd
	NHI	R1,0FF  		:other byte has tunnel stuff
	JE	IZLN4			:no windows, skip
:	do all output windows first since they have to be within 2 segs of
:	the end of the sio DMA region.  the input windows (when bigcon)
:	can safely continue beyond the SIO DMA region.
	JAL	R9,GFRCHN		:GET ANOTHER STRING
	STH	R2,OSEC,KD
	STH	R2,RLNK,R3
IZLN4	STB	R1,WSIZ,KD
	LHL	R1,NEIKN,R8		:GET THE NODE #
	STH	R1,NDID,KD		:SAVE IT
	STH	R1,ONDID,KD
	LR	R1,R8			:GET LINK NUMBER TO R1
	SRLS	R1,1
	STB	R1,LKNM,KD		:STORE LINK # FOR CONVENIENCE
	LB	R0,KNSAT,R1
	STB	R0,KSPD,KD		:INIT KSPD, INCLUDES SATELLITE BIT IF 


SIZL50	SIS	R8,2			:Decrement HW index
	JGE	IZLN2

	LHI	R8,2*(NLINKS-1)		:2*LAST LINK #
IZLN41	L	KD,KDKN,R8,R8		:GET LINK DESCRIPTOR POINTER
	LHL	R1,XWSZKN,R8		:can't be changed by xray WZ cmd
	NHI	R1,0FF  		:other byte has tunnel stuff
	JE	IZLN42			:no windows, skip
	JAL	R9,GFRCHN		:GET STRING OF RECORDS FROM FREE LIST
	STH	R2,ISEC,KD		:ISEC PTS TO START OF CHAIN
	STH	R2,RLNK,R3		:LAST LINK NOW PTS TO FIRST REC
izln42  sis	r8,2
	jge     izln41


::Continue with sync line and SIO initialization
	if	sylins
	LHI	R0,SYLMRK-SEG1		:INIT SYLVER P-COUNTERS
	LA	R1,QSYLVR
	LHI	R2,sylins
	JAL	R8,HCSET
	ei	:sylins

	LHI	R11,NETID
	LHI	LN,(NLINES-1)*2		:reset all lines
IZLN3	STH	R11,LNETID,LN		:init NETID for all lines
	JAL	R9,RSTSTR

	if	sylins
	LHL	R1,SVBDIS,LN		:IGNORE ANY DATA IN INPUT BUFF
	LCS	R0,4
	NH	R0,SVNTIP,R1,
	STH	R0,SVNTOP,LN
	ei	:sylins

	SIS	LN,2
	JGE	IZLN3			:##AL

	LA	R1,BGLIST		:CLEAR OUT BAD GUY LIST
	LHI	R2,BGLSIZ+MRESTZ	: AND RESET LIST
	JAL	R8,HCLEAR
:	init line test to nothing active.  Remember tty xray is considered
:	internal host chn 10 and so have to clear it as well
	lhi	r1,tintch*2
	lcs	r0,1
izln85	sth	r0,xltlnm,r1
	sis	r1,2
	jgebs	izln85

:	copy boot records to sio dma region
	if	chboot

	if	nlines-20
	lcs	r0,1
	ST	R0,cnbtgo		:lines to send out boot records
	li	r0,@(1^(40-nlines)-1)
	st	r0,cnbtgo+4
	else	:not lots of lines
	li	r0,@(1^(20-nlines)-1)
	st	r0,cnbtgo
	ei	:nlines-20

	la	r0,cnbre1+40
	la	r1,cnbrec+40,,
	lhi	r2,DWLPSZ*8-10
	copy	r0,r2
	la	r0,cnbre2+40
	la	r1,cnbrbt+40,,
	lhi	r2,DWLPSZ*8-10
	copy	r0,r2
:	checksum boot request
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators
	lhi	r0,-3c
	la	r8,cnbrec+4,,
	CKSUM	R2,R8			:calculate checksum
	STH	R2,cnbrec+DWLPSZ-2,,	:save vertical checksum
	STH	R3,cnbrec+DWLPSZ,,	:save horizontal checksum
:	and for return to boot
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators
	lhi	r0,-3c
	la	r8,cnbrbt+4,,
	CKSUM	R2,R8			:calculate checksum
	STH	R2,cnbrbt+DWLPSZ-2,,	:save vertical checksum
	STH	R3,cnbrbt+DWLPSZ,,	:save horizontal checksum
	ei	:chboot
	L	R10,IZLNLR		:RESTORE LINK REGISTER
	JR	R10

	SUBTTL	LINKER (SIOIZ - Initialize SIO lines)

	IF	SILINS

::*********************************************************************
::
::	SUBROUTINE:	SIOIZ:
::	FUNCTION:	Initialize SIO lines
::	CALLING SEQ:	JAL	R10,SIOIZ	Called from G02SEC.
::	CALLS:		JAL	R10,SIOIZ0
::
::*********************************************************************

:	SIOIZ IS CALLED FROM THE TWO-SECOND ROUTINE AND POLLS ALL SIO
:	LINES LOOKING FOR LINES WHICH HAVE HAD AN INTERRUPT AND NEED TO
:	BE RESTARTED.  THE INDICATION THAT AN SIO LINE NEEDS
:	RE-INITIALIZATION IS BASED ON A NON-ZERO VALUE IN SIOSTT+8.  IF
:	AN SIO INTERRUPT HAS OCCURRED, THE SIOSTT+8 VALUE IS THE STATUS
:	SENSED IN THE INTERRUPT ROUTINE.

SIOIZ	LHI	LN,SBASE		:CHECK ALL SIO LINES
	ST	R10,SIOIZL		:SAVE RETURN
SIOIZZ	JAL	R10,SIOIZ0		:ATTEMPT TO INITIALIZE LINE
	AIS	LN,2			:ADVANCE TO NEXT LINE
	CLHI	LN,NLINES*2		:ALL DONE?
	JLBS	SIOIZZ			:NO, LOOP ON
:	some logic to save running hdlc cksum errors.  the one byte field
:	wraps too often
	lis	ln,0
	la	r3,siostt+ss.crc,,	:address of hdlc cksum errors
sizxlt	lb	r2,0,r3			:get byte of cksum errors
	lh	r1,xlthdo,ln		:get prev
	sth	r2,xlthdo,ln		:make prev
	sr	r2,r1			:get diff
	jgefs	sizxl1			:didn't wrap
	ahi	r2,100			:unwrap back to pos
sizxl1	ahm	r2,siohcr,ln		:new cksum errors
	ahi	r3,10			:status area for next line
	ais	ln,2
	clhi	ln,silins*2
	jl	sizxlt			:count for next line
	L	R10,SIOIZL		:YES, RECOVER LINK
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SIOIZ0:
::	FUNCTION:	Initialize SIO lines
::	CALLING SEQ:	JAL	R10,SIOIZ0
::	INPUT:		LN = 2*Line Number
::	CALLS:		JAL	R8,CRYPTO
::			HC	xxxx
::
::*********************************************************************

:	SIOIZ0 WILL INITIALIZE THE SIO LINE INDICATED BY LN IF THE
:	STATUS HW AT SIOSTT+8 IS NON-ZERO. THE INITIALIZATION CONSISTS
:	OF ISSUING CONNECT, START OUTPUT,AND START INPUT SVC'S.
:
:	SIOIZ0 IS FIRST INVOKED AT NODE STARTUP TIME (NSTART CALLS IZLINKR
:	CALLS RSTSTR CALLS SIOIZ0). RSTSTR WRITES A -3 INTO SIOSTT TO
:	CAUSE INITIALIZATION WITHOUT GENERATING CRYPTO MESSAGES

:	SIOIZT - SIO INITIALIZATION TIME EQUATE				###wjl
:	USED BELOW AS TIME TO WAIT FOR INITIALIZATION TO COMPLETE	###wjl
:	>>NOTE THAT SIOIZT MAY BE SET IN THE TYMFILE<<			###wjl
::
	IF	TSI
	DEFAULT(SIOIZT,$A 20)   :20ms for TSI and PICO
	ELSE    HMICRO
	DEFAULT(SIOIZT,$A 20)   :20 ms for HMICRO
	ELSE    :engine
	DEFAULT(SIOIZT,$A 9)    :9 ms for engine
	EI	:TSI/HMICRO/ENGINE
SIOIZT  EQ      SIOIZT*RATE/($A1000)+1 :number of fastc ticks +1 for rounding


SIOIZ0	LA      R1,SIOINT		:pointer to initialization prog
	L	R2,SIOIPG,LN,LN		:where to put initialization prog
	LHI     R3,8*4			:8 words
	lr      r6,r8			:just in case anything cares
	JAL     R8,BCMOVE		:copy orig to dest
	lr      r8,r6			:restore in case
	LHI	R6,MSBASE,LN	:SET R6 TO 2*(RELATIVE SIO LINE NUMBER)
	SLLS	R6,3		:AND MULTIPLY BY 8
	LR	R3,R6		:R3 = 16*(RELATIVE SIO LINE NUMBER)
	LI	R2,SIOEND	:POINT TO END OF SIO DMA AREA
	AI	R3,SIOSTT	:POINTER TO CURRENT STATUS AREA

:	THE HALFWORD AT SIOSTT+8 IS NON-ZERO IF SIO INITIALIZATION IS
:	REQUIRED.  IF AN SIO INTERRUPT IS TAKEN, THE INTERRUPT ROUTINE
:	STORES THE POSITIVE STATUS WORD IN SIOSTT+8, SINCE
:	RE-INITIALIZATION IS NECESSARY AFTER AN SIO INTERRUPT.  IF THE
:	SOFTWARE DECIDES TO INITIALIZE, IT STORES A NEGATIVE VALUE INTO
:	SIOSTT+8.

SIOIZ2	LH	R1,8,R3		:SEE IF INITIALIZATION REQUIRED
	JER	R10		:NO, RETURN TO CALLER

	CLHI	R1,0FFFF	:BAD SIO RECORD LENGTH?			###OAS
	JE	SIOIZ8		:YES - SIOSTT+8 SET TO -1 IN SIORIN	###OAS
				:SEND CRYPTO MSG 53 AND INIT		###OAS
	CLHI	R1,0FFFE	:NO RECS RECEIVED FOR 4 SECS?		###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -2 IN LNCHCK	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	CLHI	R1,0FFFD	:LINE GONE TO RESET STATE?		###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -3 IN RSTSTR	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	CLHI	R1,0FFFC	:DMA TIME OUT?				###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -4 IN G01SEC	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	CLHI	R1,0FFFB	:RE-INIT DUE TO PORT SWITCH?
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -5 IN SIOIZ0
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
       if	bigcon
	clhi    r1,0fff0	:do init for dma window resetting
	je      siozd1  	:of course no crypto msg
       ei 	:bigcon
	IF	HMICRO		:HDLC micro only			###wjl
	CLHI	R1,0FFFA	:re-init due to software init timeout?	###wjl
	JE	SIOIZC		:yes - SIOSTT+8 set to -6 in SIOIZ0	###wjl
	EI	:HMICRO		:					###wjl

:	NOT A SOFTWARE "INTERRUPT" BUT A REAL ONE, SIOSTT+8 CONTAINS
:	4 NIBBLES OF - INTERRUPT STATUS, PORT #, 0, CONDITION CODE.

SIOIZ3	LHL	R8,NGSVLN,LN	:REAL INTERRUPT...GET LAST NEIGHBOR ON LINE
SIOIZY	LR	R0,R1		:R0 = INT. STAT, PORT#, 0, MBOARD STAT.	###OAS
	LR	R1,LN		:GET LINE#*2
	SLLS	R1,0F		:SHIFT TO HO HW
	OR	R1,R8		:COMBINE LINE# AND LAST NEIGHBOR
	ST	R1,CRYSBF	:FOR HW3&4 OF CRYPTO REPORT		###OAS
	LR	R1,R0		:R1 = STAT - PORT - 0 - CC		###OAS
	NI	R1,0000F000	:R1 = STAT - 0 - 0 - 0			###OAS
	SLLS	R1,4		:MOVE STATUS TO HO HW			###OAS
	NHI	R0,000F		:R0 = CC				###OAS
	OR	R0,R1		:AND COMBINE FOR CRYPTO HW1 & 2		###OAS
	JAL	R8,CRYPTO	:SEND CRYPTOGRAM
	HC	CRYE1D		:INDICATE SIO LINE INITIALIZATION

:	JUMP BACK HERE FROM SIOIZ8 or SIOIZC
:	SOFTWARE-INDUCED SINGLE LINE INITIALIZATION
SIOIZ4
       if	bigcon
	l	r0,kdln,ln,ln   :is this line connected?
	jg      siozd0  	:yes, make sure dma is correct
       ei 	:bigcon
	LIS	R0,0		:CLEAR OUT INITIALIZATION CONDITION
	STH	R0,8,R3
	LR	R0,LN		:SIO LINE NUMBER * 2
	LA	R1,RECBUF,,     :start of sio dma region
:	entry for siozd1 (reseting sio dma region)
sioiz5	SRLS	R0,1		:LINE NUMBER
	SVC	IO,90		:CONNECT SIO LINE. R0,R1,R2,R3 = PARAMETERS
	JAL	R12,SVCE39	:ERROR, CRASH
	LH	R8,0,R3		:SEE IF PORT AVAILABLE			###OAS
	CLHI	R8,0FFFF	:IF FFFF PORT NOT AVAILABLE
	JN	SIOPT1		:PORT AVAILABLE
	LCS	R8,5		:FLAG -5 IN SIOSTT+8 TO CAUSE
	STH	R8,8,R3		:RE-INIT TO OCCUR
	SBT	R0,SIOPTA	:FLAG PORT AS UNAVAILABLE
	JNFS	SIOPT2		:PREVIOUSLY FLAGGED, NO CRYPTO MESSAGE
	JAL	R8,CRYPTO	:REPORT SIO PORT UNAVAILABLE, R0 = LINE#
	HC	CRYE72
	JFS	SIOPT2		:AND CONTINUE
SIOPT1	RBT	R0,SIOPTA	:FLAG PORT AS AVAILABLE
	L	R1,SIOIPG,LN,LN :initialize the line driver
	SVC	IO,0B0		:START OUTPUT - R1 CONTAINS CCW ADDRESS
	JAL	R12,SVCE3B	:ERROR, CRASH
SIOPT2	HS	0		:SKIP OUT SVC DUE TO PORT UNAVAILABLE	###OAS
SIOIZ6	HS	0
:	instead of have the machine loop for a period of time, just put
:	sio status of a line which still has to completed initialization###sdw
	sbt     ln,sionog
	LHI	R8,SIORWT-SEG1  :the wait for connect output to complete state
	CH	R8,SIOTST,LN    :are we already in wait state?
	JEFS    SIOIZG  	:don't let saved state be wait state
	LHL	R4,SIOTST,LN    :get current state
	STH	R4,SIOTSV,LN    :save it
	STH	R8,SIOTST,LN    :new state is wait
SIOIZG  L	R4,FASTC,,	:set how long to wait
	AHI	R4,SIOIZT 	:fastc ticks to wait
	ST	R4,SIOTIM,LN,LN :when initializtion will be finished    ###sdw
	LCS	R8,1
	LHL	R4,SIBUFP,LN	:GET RELATIVE INPUT BUFFER ADDRESS
	STH	R8,SIBUF,R4,	:	AND STORE A -1 IN FIRST HALFWORD (MEANS
	LIS	R4,0
	STH	R4,SIBUFN,LN	:SET INDEX TO BEGINNING

	L	R6,SIOBLA,LN,LN :address of CCW block   		###sdw

	LHI	R7,200
	lhl	r1,sionch,ln	:get last chain for this line
sioizh	STH	R7,0,R6,R1	:store not busy in all CCWs
	shi	r1,10		:point to previous chain
	jgebs	sioizh		:do all chains

	LIS	R7,0
	STB	R7,SIOTB,LN     :no active CCWs yet
	STB	R7,SIOFB,LN
	JR	R10		:RETURN


:	REPORT SIO BAD RECORD LENGTH TO XRAY
SIOIZ8	LR	R0,LN
	SLLS	R0,0F			:ALIGN LINE NUMBER IN UPPER HW,
	LHL	R8,NGSVLN,LN		:	NEIGHBOR NUMBER IN LOWER HW
SIOIZB	OR	R0,R8			:R0 set up for call to CRYPTO
	LHL	R8,BADSLN,LN		:length of bad record for this line
	ST	R8,CRYSBF		:STORE FOR CRYPTOGRAM
	JAL	R8,CRYPTO,,		:BAD SIO RECORD LENGTH
	HC	CRYE53
	J	SIOIZ4

:	REPORT SIO INITIALIZATION SOFTWARE TIMEOUT TO XRAY		###wjl
       IF	HMICRO		:HDLC micro only			###wjl
SIOIZC	LR	R0,LN		:get line#*2				###wjl
	SRLS	R0,1		:line#					###wjl
	SBT	R0,SIOIGN	:flag for no crypto next time		###wjl
	JN	SIOIZ4		:previously flagged?			###wjl
	JAL	R8,CRYPTO	:report SIO init software timeout	###wjl
	HC	CRYE7B		: R0=line#				###wjl
	J	SIOIZ4		:continue...				###wjl

       EI	:HMICRO		:					###wjl

:	if bigcon then the location of the output sectors for this link
:	have to be within 2 segments of the other end of the SIO dma region.
       if	bigcon
siozd0  l       kd,kdln,ln,ln   :get link descriptor
siozd1  lis	r0,0
	sth	r0,8,r3 	:clear sio reinit
	lhl	r1,osec,kd	:kd set up since called from attlin
	lb	r2,wsiz,kd
	sis	r2,1
siozd2  lhl	r1,rlnk,r1
	sis	r2,1
	jgbs    siozd2
	l	r2,brec,r1
	ci	r2,sioend		:does it end before SIO stuff
	jgfs    siozd3
	li	r2,sioend		:nope, use sioend
	jfs     siozd4
siozd3  ahi	r2,100
	nhi	r2,-10  		:sio likes quadword
siozd4  lhl	r1,osec,kd		:do start of output record
	l	r1,brec,r1
	ci	r1,sopg0		:start of SIO area
	jgfs    siozd5
	nhi	r1,-10
	jfs     siozd6
siozd5  li	r1,sopg0
siozd6  lr	r0,ln
	j       sioiz5
       ei 	:bigcon

::*********************************************************************
::
::	ABNORMAL RETURN FROM SIO SVC'S FOR CONNECT, OUTPUT AND INPUT
::
::	RETURN CODES IN HO HW OF R0
::
::	ISIS -- CONNECT MBOARD	SVC IO,090
::		IMPROPER REGISTER USAGE		RC=0001
::		LU RANGE CHECK			RC=0002
::		NULL LU POINTER			RC=0002
::		BAD DEVICE TYPE			RC=0002
::		MBOARD RC=8, 35MS TIMEOUT	RC=0003
::		MBOARD RC=4, MBOARD ERROR	RC=0004
::		CCW NOT ON BND10		RC=0005
::		INVALID RETURN ADDRESS		RC=0005
::
::	ISIS -- OUTPUT, INPUT SIO  SVC IO,0B0	SVC IO,0A0
::		SAME RETURN CODES AS ABOVE, BUT IN ADDITION
::		SVC IO,090 NOT ISSUED YET	RC=0002
::*********************************************************************

SVCE39	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZC			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV39C)			:ALL OTHER RETURN CODES, CRASH	###OAS
svc73b	lr	ln,r5			:set up LN for error routines
	jfs	svce3b
svc53b	lr	r0,r5			:svc was called with r5 as line #
	nhi	r5,7fff			:get line # in case we don't crash
SVCE3B	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE FROM HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZO			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV3BC)			:ALL OTHER RETURN CODES, CRASH	###OAS

SVCE3A	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZI			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV3AC)			:ALL OTHER RETURN CODES, CRASH	###OAS

	EI	:SILINS


	SUBTTL	LINKER (LKVOLT - Test for links overloaded)

::*********************************************************************
::
::	SUBROUTINE:	LKVOLT:
::	FUNCTION:	Test for network links overloaded or saturated
::	CALLING SEQ:	JAL	R10,LKVOLT	Called from G01SEC.
::	CALLS:		JAL	R10,SUP14,,	:to make overload reports
::			JAL	R8,CRYPTO
::			HC	xxxx
::
::*********************************************************************

:	TEST FOR NETWORK LINKS OVERLOADED (ALL ACTIVE CHANNELS NOT
:	BEING SERVICED FREQUENTLY ENOUGH) OR LINK SATURATED
:	(OUT OF BANDWIDTH). REPORT TO SUP IF THRESHOLD EXCEEDED.
:
:	COMPARE LINK LOAD COUNTS TO REPORTING THRESHOLDS, AND MAKE
:	REPORT IF THRESHOLDS EXCEEDED.  OVERLOAD COUNTS ARE MAINTAINED
:	IN LKOVLD, AND LINK SATURATED COUNTS IN LKSTCT.  BOTH LKOVLD AND
:	LKSTCT ARE UPDATED BY THE 'CKOVLD' ROUTINE WHICH RUNS EVERY 1/2
:	SECOND.
:
:	LINK NUMBER IN KN, LINK DESCRIPTOR IN KD.

:	PATCHABLE THRESHOLD REFERENCE VALUES
LKOVCT	HC	LKOVTH
	SYAD(LKOVCT)			:OVERLOAD THRESHOLD
LKSATC	HC	LKSTTH
	SYAD(LKSATC)			:SATURATED THRESHOLD

LKVOLT	ST	R10,LNKRET		:SAVE RETURN LINK
	LHI	KN,NLINKS		:LINK NUMBER - SCAN ALL LINKS
	LIS	R12,0			:FOR REFRESHING COUNTERS
	LHI	R7,8000			:R7 FOR OR'ING HI-ORDER BIT OF HALFWORD

LKOV02	SIS	KN,1			:TEST ALL LINKS
	JL	LKOVXT			:DONE

	TBT	KN,ALINKS		:ACTIVE LINK?
	JEBS	LKOV02			:NO
	AR	KN,KN
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR ADDRESS
	SRLS	KN,1
	LB	R0,NLAT,KD		:ANY LINES ATTACHED?
	JEBS	LKOV02			:NO - LINK NOT UP
	LHL	R1,LKSTCT,KN,KN		:GET LAST MINUTE'S SATURATED COUNT
	STH	R1,KS.SAT,KD		:	AND SAVE IN LINK DESCRIPTOR
	LHL	R1,LKOVLD,KN,KN		:GET LAST MINUTE'S OVERLOAD COUNT
	STH	R1,KS.OVL,KD		:	AND SAVE IN LINK DESCRIPTOR
	STH	R12,LKOVLD,KN,KN	:CLEAR COUNTER FOR NEXT MINUTE
	CLH	R1,LKOVCT		:OVERLOAD THRESHOLD EXCEEDED?
	JLE	LKOV06			:NO -  CHECK LINK SATURATED COUNT

:	REPORT LINK OVERLOAD TO SUP...
	LHI	R5,LKOVMS		:TYPE 14, SUBTYPE LKOVMS
LKOV04	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER FOR REPORT
	JE	LKOV02			:(IF ZERO, LINK NOT UP)
	STH	R0,CRYSBF+2		:STORE NEIGHBOR # FOR CRYPTO	###OAS
	OR	R0,R7
	STH	R0,SUPMBF		:STORE NEIGHBOR NUMBER FOR REPORT
	OR	R1,R7
	STH	R1,SUPMBF+2		:AND NUMBER OF OCCURRENCES
	LIS	R6,2			:INDICATE 2 HALFWORDS
	JAL	R10,SUP14,,		:REPORT LINK CONDITION TO SUPERVISOR
	LR	R0,R1			:SAVE COUNT FOR CRYPTO		###OAS
	NHI	R0,7FFF			:STRIP OFF HO BIT		###OAS
	CLHI	R5,LKOVMS		:CHECK WHICH CRYPTO TO SEND	###OAS
	JNFS	LKOV08			:SEND SATURATED			###OAS
	JAL	R8,CRYPTO		:LINK OVERLOAD			###OAS
	HC	CRYE36			:				###OAS
	LIS	R12,0			:RECOVER R12 IN CASE MESSED UP	###OAS
	JFS	LKOV06			:				###OAS

LKOV08	JAL	R8,CRYPTO		:LINK SATURATED			###OAS
	HC	CRYE37			:				###OAS

LKOV06	LHL	R1,LKSTCT,KN,KN		:NUMBER OF LINK SATURATED OCCURRENCES
	STH	R12,LKSTCT,KN,KN	:CLEAR COUNTER
	CLH	R1,LKSATC		:SATURATED THRESHOLD EXCEEDED?
	JLE	LKOV02			:NO

:	REPORT LINK SATURATED TO SUP
	LHI	R5,LKSTMS		:TYPE 14, SUBTYPE LKSTMS
	J	LKOV04
LKOVXT	L	R10,LNKRET
	JR	R10			:RETURN

	SUBTTL	LINKER (Trace-sync set-up subroutines)

	IF	TSTSZE

::*********************************************************************
::
::	SUBROUTINE:	TSFUAL:
::	FUNCTION:	Check if tracing desired on unassigned line...
::	CALLING SEQ:	JAL	R2,TSFUAL
::	INPUT:		R4  = Header HW
::	PRESERVED:	R15
::	CALLS:		JAL	R0,TSFMRK
::
::*********************************************************************

:	COMMON FOR SYNC AND SIO LINES.
TSFUAL	CLH	LN,TSLINE		:TRACING ON THIS LINE DESIRED?
	JNR	R2			:NO, RETURN
	ST	R15,TSRSVE		:SAVE LINK REGISTER
	JAL	R0,TSFMRK		:SET UP ENTRY
	STH	R4,TSFTBL+2,R15		:STORE THE ENTRY (HEADER HALFWORD)
	LIS	R0,0
	STB	R0,TSFTBL+4,R15		:CLEAR RECN FIELD		###OAS
	LIS	R0,TS.UAL		:ENTRY - UNASSIGNED LINE
	STB	R0,TSFTBL,R15
	L	R15,TSRSVE
	JR	R2

:	TSFMRK (FOR FOREGROUND) AND TSBMRK (FOR BACKGROUND) SET UP EVENT
:	ENTRIES FOR CALLING PROCESS.  FASTC AND THE LINE NUMBER ARE
:	STORED, AND THE ENTRY INDEX REGISTER IS RETURNED (R15 FOR
:	FOREGROUND, R7 FOR BACKGROUND).

::*********************************************************************
::
::	SUBROUTINE:	TSFMRK:
::	FUNCTION:	Set up foreground event entry
::	CALLING SEQ:	JAL	R0,TSFMRK
::	INPUT:		LN  = Line Number*2
::	OUTPUT:		R15 = New entry index
::	PRESERVED:	LN  = Line Number*2
::
::*********************************************************************

TSFMRK	ST	R0,TSRSVE+4		:SAVE RETURN ADDRESS
	LHL	R15,TSFPTR
	AIS	R15,TSESZE		:COMPUTE NEW ENTRY ADDRESS
	NHI	R15,TSTSZE-1		:	(ALLOW FOR WRAP)
	STH	R15,TSFPTR
	L	R0,FASTC,,
	ST	R0,TSFTBL+4,R15		:STORE FASTC TIME
	SRLS	LN,1			:FORM TRUE LINE NUMBER
	STB	LN,TSFTBL+1,R15		:STORE LINE NUMBER
	AR	LN,LN			:RECOVER 2*LINE NUMBER
	L	R0,TSRSVE+4
	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TSBMRK:
::	FUNCTION:	Set up background event entry
::	CALLING SEQ:	JAL	R8,TSBMRK
::	INPUT:		LN  = Line Number*2
::	OUTPUT:		R7  = New entry index
::	PRESERVED:	LN  = Line Number*2
::
::*********************************************************************

TSBMRK	LHL	R7,TSBPTR
	AIS	R7,TSESZE		:COMPUTE NEW ENTRY ADDRESS
	NHI	R7,TSTSZE-1		:	(ALLOW FOR WRAP)
	STH	R7,TSBPTR
	L	R9,FASTC,,
	ST	R9,TSBTBL+4,R7		:STORE FASTC TIME
	SRLS	LN,1			:FORM TRUE LINE NUMBER		###OAS
	STB	LN,TSBTBL+1,R7		:STORE TRUE LINE NUMBER		###OAS
	AR	LN,LN			:RECOVER 2*LINE NUMBER		###OAS
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TSNSPK:
::	FUNCTION:	Save most recent packets when link goes out.
::	CALLING SEQ:	JAL	R8,TSNSPK
::	INPUT:		KD  = linK Descriptor
::	DESTROYED:	All Preserved
::
::*********************************************************************

TSNSPK
       IF	 LNKDBG
	STM	R0,REGST		:save regs for LINK/line debugger
	JAL	R14,TSIDB1,,		:save input packets
	JAL	R14,TSODB1,,		:save output packets
	LM	R0,REGST		:				###sdw
       EI 	:LNKDBG
	JR	R8

	EI	:TSTSZE

	SUBTTL	LINKER (LINKER - Detach, attach scheduler)

::*********************************************************************
::
::      SUBROUTINE:     OSRLIN 
::      FUNCTION:	send Old Style Resets on idle LINes for a sec
::      CALLING SEG:    on R10 from 4 minute logic
::      Solve problem with 5.10 neighbors.  They will   		###sdw
::      stop sending resets and we will send them only new style resets and
::      thus the line never comes up.  So every four minutes we will simply
::      send an old style reset and then next time to 1sec we go back to
::      expanded reset.  We set bits for the 1 sec logic to find and retunr
::      to expanded reset packet if we don't start ping/ponging on old style
::	reset.
::*********************************************************************

OSRLIN  ST	R10,OSRLSV		:save link reg
	LHI     LN,NLINES*2-2		:for each line 
OSRLI2  L	SD,SDLN,LN,LN		:get reset descriptor
	L       KD,KDLN,LN,LN		:see if link up
	JG      OSRLI1  		:is up (no send it reset)
	lhl	r0,intacp,,		:maybe a dline load going on
	xhi	r0,-1
	sth	r0,osrtmp
osrl03  lhl	r0,osrtmp
	jffoh   r0,osrl05
	j       osrl07  		:have to check out active ports
osrl05  sth	r0,osrtmp
	rbt	r1,osrtmp		:only do port once
	CLH     LN,DWLNUM,R1,r1 	:get number of line being loaded
	JE      OSRLI1  		:in progress, skip this line
	jbs     osrl03
osrl07	lr	r1,ln
	srls	r1,1
	tbt	r1,xltact		:running a line test?
	jn	osrli1			:don't interupt our test
	LHL	R0,RSTIM,SD		:see if reset sequence in progress
	JEFS    OSRLI3  		:not in progress
	SH	R0,SLOWC+2,,		:see if should have timed out
	LHR	R0,R0			:worry about high bit
	JG      OSRLI1  		:timer still going
	JFS     OSRLI5  		:and send old style reset
OSRLI3	TBT	R1,LNSUSC		:is line suspended?
	JN      OSRLI1  		:suspended is okay, next line

OSRLI5  L	SD,SDLN,LN,LN		:get reset descriptor
	JAL	R9,RSTSTR		:restart reset process
	LHI	R4,TTRSHD		:existing instructions
	STH	R4,XRSTP,SD		:old reset header stored
	LHI	R0,MACHNM		:new logic: construct old reset packet
	STH	R0,XRSTP+2,SD
	L	R0,TTRSET+4		:write old reset packet data
	ST	R0,XRSTP+4,SD
	LI	R0,VERCOM
	ST	R0,XRSTP+8,SD
	LHI	R3,XSDSZ-10
	LCS	R2,1			:overwrite old data
OSRLI7  ST	R2,XRSTP+0C,SD,R3
	SIS	R3,4
	JGEBS   OSRLI7
       IF	 SILINS
	CLHI    LN,(NLINES-SILINS-1)*2  :sio lines have another reset xmit buf
	JLE     OSRLI9
	L	R6,SIORSP,LN,LN
	L	R0,XRSTP,SD		:copy reset packet
	ST	R0,2,R6 		:first HW is count for SIO packet
	LI	R0,VERCOM
	ST	R0,6,R6
       EI 	:SILINS
:	now will send old style resets.  Must make sure we only do it for
:	a second.  So set a bit for this line for 1sec logic to find!
OSRLI9  LR	R1,LN
	SRLS	R1,1			:make it a line number
	SBT	R1,OSRLIR		:tell 1sec about this
	RBT	R1,OSRLIH		:extra careful on history
	LHI	R1,TXRSHD		:if don't receive a response
	STH	R1,VRSTP,SD		:then last received is this

:	next line or exit.
OSRLI1  SIS     LN,2			:next line
	JGE     OSRLI2
	L	R10,OSRLSV		:restore link
	JR	R10


::**********************************************************************
::
::      SUBROUTINE:     ESRLIN
::      FUNCTION:	to resume sending Expanded Reset packets after OSRLIN
::			sent a few old style reset packets.
::      CALLING SEQ:    on R10 from 1 sec logic.
::      or so of old style resets is sent.  Note that ESR is expanded reset.
::      This routine is completely dependent on OSRLIN.  Notice that when we
::      sent the OSR we put a ESR header in received reset buffer.  So if
::      1sec logic finds an OSR header then we have received an OSR packet
::      from neighbor and we don't interfere.  If no packet received we
::      store an ESR header since we want to return to sending ESR packets
::      and RESET XSRTBT since that will be detected in ATTLIN as an abort
::      and then setting LINATT is needed to run ATTLIN for this line.
::      and OSR is old style resets.
::************************************************************************

ESRLIN  LHI	R2,LNSIZE-4		:do each line
ESRLI1  L	R0,OSRLIH,R2,		:port ready to go to back to ESRs?
	JN      ESRLI4
	SIS	R2,4
	JGEBS   ESRLI1
	LHI	R2,LNSIZE-4		:update history before exiting
	LIS	R1,0			:and clear current
ESRLI3  L	R0,OSRLIR,R2
	ST	R0,OSRLIH,R2
	ST	R1,OSRLIR,R2		:clear current
	SIS	R2,4
	JGEBS   ESRLI3  		:for all lines
	JR	R10			:and done

:	idle line which we sent an old style reset
ESRLI4  JFFO	R0,ESRLI5
ESRLI5  SLLS	R2,3
	LR      LN,R1
	AR      LN,R2			:make real line number
	RBT     LN,OSRLIH		:done for this line
	AR      LN,LN			:make 2*line number
	L	SD,SDLN,LN,LN		:get reset descriptor
	LHL	R4,VRSTP,SD		:see if received OSR
	NHI	R4,0FFE0		:remove any sequence or second line
	CLHI	R4,TTRSHD		:we had put an ESR header there
	JE      ESRLIN  		:so we must have received a good reset
	LR	R1,LN
	SRLS	R1,1
	tbt	r1,xltact		:running a line test?
	jn	esrlin			:don't interupt our test
	SBT	R1,LINATT		:make it think it got a reset packet
	LHI	R1,TXRSHD		:but different than last send
	STH	R1,VRSTP,SD
	RBT     LN,XRSTBT		:make it find a switch from OSR to ESR
	ts	glinkr			:sched linker
:	LHI	R0,1F-PLINKR
:	SBT	R0,TLINKR
	J       ESRLIN  		:next line

::*********************************************************************
::	Subroutine:	CNBOOT:
::	FUNCTION:	see if neighbors are in boot
::	CALLING SEQ:	on R10 from g30sec
::	What this does is put in a special transmitter which requests a
::	boot dump request if the current transmitter is in boring ping
::	reset state and not expecting anything in return.
::	RETURNS:  on R10
::*********************************************************************

	default(cnbtim,1*rate)	:send out max of 1 secs of boot requests

	if	chboot			:do we even want to check?

cnboot	lhi	r0,cnbtgo+lnsize-2	:address of last hw of cnboot
	lr	r1,r0			:check against self
	lhi	ln,(lnsize*8)-1		:all lines to check
	arand	r0,ln
	jfs	cnbo02
	jr	r10			:done

cnbo02	rbt	ln,cnbtgo
	rbt	ln,cnbrsp
	lhl	r0,siotst,ln,ln
	ci	r0,siorr-seg1		:is current state pinging out resets?
	jn	cnboot			:if not then neighbor probably alive
	lhi	r0,siobot-seg1
	sth	r0,siotst,ln,ln
	l	r0,fastc,,
	ahi	r0,cnbtim		:add in how long to send out boot
	ar	ln,ln
	st	r0,siotim,ln,ln		:save quitting time for siobot
	j	cnboot
	ei	:chboot

::*********************************************************************
::
::	PROCESS:	LINKER:
::	FUNCTION:	Detach, attach scheduler
::	CALLING SEQ:	LINKER is scheduled every 125 ms as a result of
::	a request for services (ie, when a reset is detected on any line)
::	and hara-kiri's when all its processing is done.
::	SUB-PROCESSES:	DETLIN, ATTLIN, 
::	RETURNS:	J	g125m1
::
::*********************************************************************

:	ATTACHES NEWLY IDENTIFIED LINES TO EXISTING LINKS, OR, IF NO
:	LINKS EXIST TO THAT NEIGHBOR, CREATES ONE.  DETACHES FROM LINKS
:	LINES THAT HAVE GONE RESET, TEARING DOWN LINK IF NO ATTACHED LINES
:	REMAIN.

LINKER	jal	r10,detlin		:see if it has anything to do

	LIS	R2,0
LINKR2	L	R3,LINATT,R2		:COPY LINATT TO LINKAS
	ST	R3,LINKAS,R2
	AIS	R2,4
	Chi	R2,LNSIZE
	JL	LINKR2

	jal	r10,attlin

	LIS	R2,0
	LIS	R3,0
LNKD2	O	R3,LINATT,R2		:CHECK ARRAY
	O	R3,LINDET,R2
	AIS	R2,4
	Chi	R2,LNSIZE
	JLbs	LNKD2
	LR	R3,R3			:ANY BITS SET ?
	JeFS	LNKDIS
	lcs	r3,1
LNKDIS	sth	r3,glinkr		:store 0 if linker has nothing to do
	J	g125m1			:return to 1/8 sec routime

	SUBTTL	LINKER (Periodic processes)

::*********************************************************************
::
::	SUBROUTINE:	G02SLK:
::	FUNCTION:	Two-second logic for the LINKER segment
::	CALLING SEQ:	JAL	R10,G02SLK	Called from G02SEC.
::
::*********************************************************************

G02SLK	LIS	R2,0
G02SL2	L	R0,INHRLS,R2		:CLEAR RESET INHIBIT (EVERY 2 SECS)
	N	R0,INHRST,R2
	X	R0,INHRST,R2
	ST	R0,INHRST,R2
	ST	R0,INHRLS,R2
	AIS	R2,4
	Chi	R2,LNSIZE
	JL	G02SL2
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	G01MLS:
::	FUNCTION:	1-minute logic to examine lines suspended and
::			reinstate if appropriate.
::	CALLING SEQ:	JAL	R10,G01MLS	Called from G01MIN.
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R8,GMTLIN,,
::
::*********************************************************************

G01MLS	LIS	R5,0			:R5 = INDEX INTO ARRAY
G01ML1	L	R0,LNSUSO,R5
	JFFO	R0,G01ML2		:BIT SET
	AIS	R5,4			:NEXT WORD
	CLI	R5,LNSIZE		:DONE ?
	JLBS	G01ML1
	J	G01ML4			:NO MORE
G01ML2	RBT	R1,LNSUSO,R5		:FIRST BIT FOUND
	SLLS	R5,3			:FORM LINE NO.
	OR	R1,R5
	SRLS	R5,3			:RESTORE ###SHM
	SLLS	R1,1
	L	R0,KDLN,R1,R1		:LINK DESCRIPTOR INDEX FOR THIS LINE
	SRLS	R1,1
	AIS	R0,1			:IF -1, LINE IS SUSPENDED
	JN	G01ML1			:LINE NOT SUSPENDED
	LCS	R0,2
	SLLS	R1,1
	ST	R0,KDLN,R1,R1		:LINE WILL NOW LISTEN FOR RESETS
	SRLS	R1,1
	LR	LN,R1			:LINE NO. FOR GMTLIN
	AR	LN,LN			:*DOUBLED
	JAL	R8,GMTLIN,,		:*GET TIME
	J	G01ML1
G01ML4	LIS	R2,0
G01ML5	L	R0,LNSUSC,R2		:COPY LNSUSC TO LNSUSO
	ST	R0,LNSUSO,R2
	LIS	R0,0
	ST	R0,LNSUSC,R2		:CLEAR LNSUSC
	AIS	R2,4
	CI	R2,LNSIZE
	JL	G01ML5
	JR	R10			:RETURN

	SUBTTL	LINKER (LNCHCK - 4 sec test for records received on line)

::*********************************************************************
::
::	SUBROUTINE:	LNCHCK:
::	FUNCTION:	Tests for records received on all lines.
::	CALLING SEQ:	JAL	R10,LNCHCK	Called from G04SEC.
::	CALLS:		JAL	R8,TSBMRK
::			JAL	R8,TSNSPK
::			JAL	R10,KSPEED
::			JAL	R10,SUP13,,
::			JAL	R10,SUP12,,
::			JAL	R8,CRYPTO
::			HC	CRYE1E
::			JAL	R10,SIOIZ0
::
::*********************************************************************

:	********RUNS EVERY 4 SECONDS********

:	FOR ACTIVE CHANNELS IN ADDITION TO ZERO AND ONE (ILC).

:	FOR T-II LINK WITH MULTIPLE LINES, ALL LINES BUT ONE MAY BE
:	DETACHED EACH TIME THROUGH LNCHCK.  FOR SINGLE-LINE LINK, LINK
:	OUT REPORT IS MADE TO SUPERVISOR FIRST FOUR-SECOND INTERVAL WITH
:	NO RECORDS RECEIVED.  FOUR-SECOND GAPS ARE REPORTED TO XRAY, AND
:	CIRCUITS ARE ACTUALLY ZAPPED (AND RESETS EMITTED) ONLY AFTER
:	MULTIPLE FOUR-SECOND GAPS.
LNCHCK	ST	R10,LNCHLR		:SAVE LINK REG
	LHI	KN,2*(NLINKS-1)
LNCH04	L	KD,KDKN,KN,KN		:LINK DESCRIPTOR
	LB	R0,NLAT,KD		:NUMBER OF LINES ATTACHED TO THIS LINK
	SIS	R0,1
	JnFS	LNCH06			:SINGLE-LINE LINK - SET KNNLAT TO -1
	sis	r0,1
LNCH06	STH	R0,KNNLAT,KN,		:MAX NUMBER OF LINES TO BE DETACHED
					:	THIS EXECUTION OF LNCHCK
	SIS	KN,2
	JGE	LNCH04			:DO FOR ALL LINKS

	LHI	LN,NLINES-1		:TEST ALL LINES FOR GOOD RECS RECEIVED
LNCH1	lr	r1,ln
	ar	r1,r1
	L	KD,KDLN,r1,r1		:IS THIS LINE ATTACHED?
	JL	LNCH4			:NO			       ###SHM

	LB	KN,LKNM,KD		:GET LINK NUMBER
	LIS	R0,1			:NO RECS ON LINE?
	RBT	LN,LNGREC
	JE	LNCH6			:NO RECORD RECEIVED ON LINE
	LIS	R0,4			:BORI ZAP?
	TBT	KN,BORZAP
	Jefs	LNCH3			:'BORI ZAP', DETACH
	LIS	R0,2
	TBT	KN,LKGREC		:GOOD RECORD RECEIVED ON LINK?
	JN	LNCH2			:YES, LINE OK.			###TZ
	TBT	KN,OLDKGR		:ANY GOOD RECORDS ON LINK LAST
					:	TIME THRU?		###TZ
	JE	LNCH6			:NO, DETACH THIS LINE		###TZ
	J	LNCH2			:OTHERWISE, LET IT LIVE		###TZ
LNCH3	STB	R0,DREASN,LN		:SAVE REASON FOR OUTAGE
	LH	R1,KNNLAT,KN,KN
	SIS	R1,1			:DECREMENT NUMBER OF LINES DETACHED
	STH	R1,KNNLAT,KN,KN		:	THIS EXECUTION OF LNCHCK...
	LB	R1,NLAT,KD		:IS THIS SINGLE-LINE LINK?
	SIS	R1,1
	JNFS	LNCH22			:MULTIPLE LINES, LINK NOT GOING OUT,YET
	STH	R1,KFROZN,KD		:LINK IS GOING OUT...NO LONGER FROZEN
	IF	NGRDTM-1
	LB	R8,LTYP,LN,LN		:NON-4SEC REPORT, ZERO THE COUNT
	JEFS	LNCH31			:SPECIFIC LINE ONLY		###AL
	STB	R1,LCRPCT,LN,
LNCH31	EI	:NGRDTM-1
LNCH22	SBT	LN,LINDET		:DETACH THIS LINE

	IF	TSTSZE
	LHL	R8,NDID,KD
	CLH	R8,TSLINK		:IS THIS LINK OF INTEREST?
	JN	LNCHTX			:NO - NO TRACING
	SLLS	LN,1			:YES - SET UP LINE NUMBER*2 FOR
	JAL	R8,TSBMRK		:	CONSISTENCY AND MAKE NEW ENTRY
	SRLS	LN,1
	STB	R0,TSBTBL+4,R7		:STORE DETACH REASON
	LHL	R8,LRT,KD
	STH	R8,TSBTBL+2,R7		:STORE 'LAST RECORD TORN'
	LHI	R8,TS.DET
	STB	R8,TSBTBL,R7		:STORE ENTRY TYPE
	LIS	R8,0
	lb	r0,nlat,kd		:keep on tracing if mline link
	sis	r0,1
	jnfs	tslb31
	STH	R8,TSLINK		:INHIBIT FURTHER TRACING OF THIS LINK
tslb31	AIS	R7,TSESZE
	NHI	R7,TSTSZE-1		:ADVANCE INDEX TO NEXT ENTRY AND
	ST	R8,TSBTBL,R7		:	CLEAR FOR EASE IN FINDING
	ST	R8,TSBTBL+4,R7		:	END OF TRACE
	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT
LNCHTX	EI	:TSTSZE
	LCS	R0,1			:PUT LINE IN LIMBO FIRST
	SLLS	LN,1
	ST	R0,KDLN,LN,LN
	SRLS	LN,1

:	IDLE THE LINE
	LHI	R0,SIOIDL-SEG1
	STH	R0,SIOTST,LN,LN		:INITIALIZE OUTPUT STATE

	ts	glinkr			:tell linker to run
	if	sylins
	clhi	ln,sylins
	jgefs	lnch2
	LHI	R0,SYLMRK-SEG1		:SO SYLVER DOESN'T GET CONFUSED
	STH	R0,QSYLVR,LN,LN
	ei	:sylins
LNCH2	LHI	R0,LNCKTM	:INITIALIZE CONFSG, SO WE CAN DETECT
				:WHEN A LINK GOES LNCKTM TIMES OF
				:4-SECONDS WITH NO RECORDS RECEIVED.	###LH
	STH	R0,CONFSG,LN,LN	
LNCH2B	IF	NGRDTM-1
	LB	R0,LTYP,LN,LN		:NON-4SEC REPORT, ZERO THE COUNT
	JEFS	LNCH2C			: WHENEVER RECVED A GOOD DATA	###AL
	LIS	R0,0
	STB	R0,LCRPCT,LN
LNCH2C	EI	:NGRDTM-1
	LH	R0,KFROZN,KD		:IS LINK CURRENTLY FROZEN?
	JE	LNCH4			:NO
:	GOOD RECORD RECEIVED FOR LINK WHICH HAS BEEN REPORTED FROZEN TO
:	SUPERVISOR. REPORT LINE ATTACH WITH PROPER LINK SPEED.
	JAL	R10,KSPEED		:RE-COMPUTE LINK SPEED
	LB	R4,KSPD,KD
	NHI	R4,1F			:ISOLATE LINK SPEED
	AHI	R4,13C0			:T-II NEIGHBOR, REPORT NEW LINE ATTACH
LNCH34	AR	LN,LN			:SUP13 EXPECTS LN TO BE LINE NUMBER * 2
	JAL	R10,SUP13,,		:SEND NEW LINE/LINK REPORT TO SUP
LNCH35	SRLS	LN,1
	LIS	R0,0
	STH	R0,KFROZN,KD		:THAW LINK
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER FOR NODE REPORT
	LHL	R0,ANCHN,KD
	OHI	R0,8000			:INCLUDE NUMBER OF CIRCUITS SAVED
	STH	R0,SUPMBF+4
	LHI	R0,NR.LTH
	STH	R0,SUPMBF		:INDICATE LINK THAW NODE REPORT
	JAL	R10,SUP12,,		:SEND NODE REPORT
LNCH4
	SIS	LN,1
	JGE	LNCH1
	LIS	R2,0
LNCH42	L	R0,LKGREC,R2		:UPDATE OLD LKGREC
	ST	R0,OLDKGR,R2
	LIS	R0,0
	ST	R0,LKGREC,R2		:CLEAR LKGREC
	AIS	R2,4
	Chi	R2,LKSIZE
	JL	LNCH42
	L	R10,LNCHLR		:RESTORE LINK REG AND
	JR	R10			:	RETURN

:	NO RECORDS RECEIVED ON LINE THIS PAST 4-SECOND INTERVAL.
:	INCREMENT NUMBER OF CONSECUTIVE 4-SECOND GAPS, AND TEST FOR
:	DETACH/REPORTING ACTION TO BE TAKEN.
LNCH6	LH	R1,KNNLAT,KN,KN		:IF MULTI-LINE LINK, DECREMENT
	JLFS	LNCH62			:SINGLE-LINE LINK
	SIS	R1,1
	JL	LNCH4		:ALREADY DETACHED MAX NUMBER OF LINES THIS LINK
	J	LNCH3		:GO DETACH THIS LINE
LNCH62
:	REPORT LINK FROZEN TO SUPERVISOR, BUT DO NOT ZAP CIRCUITS OR
:	DETACH LINE.  THIS PREVENTS SUP FROM BUILDING NEW CIRCUITS OVER
:	LINK WHILE WE GIVE IT MORE TIME TO RECOVER.

	IF	NGRDTM-1
	LB	R4,LTYP,LN,LN		:NON-4SEC REPORT, CHECK CT=NGRDTM-1
	JE	LNCH63			:SPECIFIC LINE ONLY		###AL
	LB	R4,LCRPCT,LN
	LHI	R8,NGRDTM
	SIS	R8,1
	CLR	R4,R8
	JN	LNCH70
LNCH63	EI	:NGRDTM-1
	TS	KFROZN,KD	:HAVE WE REPORTED LINK OUT TO SUPERVISOR?
	JL	LNCH70		:YES - LINK FROZEN
	LHI	R4,80		:SET LINK SPEED TO 0 FOR REPORT TO SUPERVISOR
	STB	R4,KSPD,KD	:	(INDICATES FROZEN LINK)
	LHI	R4,13A1		:INDICATE LINE DETACHED DUE TO NO
				:	RECORDS RECEIVED
	AR	LN,LN		:SUP13 EXPECTS LN TO BE LINE NUMBER * 2
	JAL	R10,SUP13,,	:SEND REPORT TO SUP (WITH LINK SPEED = 0)
LNCH64	SRLS	LN,1

:	NOW SEND NODE REPORT INDICATING LINK FROZEN

	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER
	OHI	R0,8000
	STH	R0,SUPMBF+2
	LHI	R0,10+8000
	STH	R0,SUPMBF+4		:NUMBER OF SECONDS BEFORE DETACH
	LHI	R0,NR.LFR
	STH	R0,SUPMBF		:INDICATE LINK FROZEN NODE REPORT
	JAL	R10,SUP12,,		:SHIP NODE REPORT TO SUPER

:	4-SECOND INTERVAL WITH NO GOOD RECORDS. SEE IF LNCKTM 
:	CONSECUTIVE OCCURRENCES OF FOUR SECONDS WITH NO RECORDS RECEIVED
:	(4 * LNCKTM SECONDS) 
LNCH70	LIS	R0,1		:R0 CONTAINS REASON FOR LINE DETACHMENT	###LH
				:REASON 1 ==> NO RECORDS RECEIVED.	###LH
	LCS	R8,1		:					###LH
	AHM	R8,CONFSG,LN,LN :CHECK IF HAS REACHED CONSECUTIVE 	###LH
				:4-SECONDS GAPS LIMIT.			###LH
	JLE	LNCH3		: YES, --- DETACH LINE			###LH

	AHM	R0,FOURSG,LN,LN	: NO, KEEP COUNT OF CONSECUTIVE		###LH
LCH70B				: 4-SECONDS GAPS.			###LH
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER
	LR	R0,LN			:LINE NUMBER
	EXHR	R0,R0			:ALIGNED IN UPPER HW
	OR	R0,R8			:*COMBINE W NEIGHBOR NUMBER
	ST	R0,CRYSBF		:*SAVE FOR CRYPTO
	IF	NGRDTM-1		:REPORT THE 4-SEC MSG BY NGRDTM
	LB	R9,LTYP,LN,LN		: FOR SPECIFIC LINE ONLY	###AL
	JE	LCH70C
	LB	R9,LCRPCT,LN		:CHECK COUNT IF MEET NGRDTM
	AIS	R9,1			:INCREASE COUNT BY 1
	STB	R9,LCRPCT,LN
	LHI	R0,NGRDTM		:DISPLAY FORMAT IN BYTE DECIMAL
	CLR	R9,R0
	JN	LCH70D
	SLLS	R0,2			:DISPLAY THE REAL NO. OF SECS
	LIS	R4,0			:ZERO OUT THE COUNT
	STB	R4,LCRPCT,LN
	JAL	R8,CRYPTO	
	HC	CRYE7D
	JFS	LCH70D
LCH70C	EI	:NGRDTM-1
	LIS	R0,0			:*NO DATA
	JAL	R8,CRYPTO	
	HC	CRYE1E
LCH70D
:	IF SIO LINE HAS GONE FOUR SECONDS WITH NO RECORDS RECEIVED,
:	MAYBE IT NEEDS TO BE RE-INITIALIZED...

	IF	SILINS
	LR	R9,LN
	SHI	R9,(NLINES-SILINS)	:COMPUTE RELATIVE SIO LINE NUMBER
	JL	LNCH4			:NOT AN SIO LINE
	SLLS	R9,4			:SIO LINE * 10
	LCS	R0,2
	STH	R0,SIOSTT+8,R9,		:INDICATE INITIALIZATION DUE TO NO RECS
	AR	LN,LN
	JAL	R10,SIOIZ0		:RE-INITIALIZE SIO LINE
	SRLS	LN,1
	EI	:SILINS

	J	LNCH4

	SUBTTL	LINKER (LDRPRT - Diagnostics and reporting)

::*********************************************************************
::
::	TABLE:		LDERTB:
::	FUNCTION:	Line Diagnostic Event/Reporting Table.
::
::*********************************************************************

:	EACH ELEMENT HAS FIVE FIELDS, AS FOLLOWS:
:	EVENT,TOTAL(TRANSMIT OR RECEIVE),MSG TYPE,SHIFT FACTOR,REPORT TIME
:	FOLLOWED BY A JAL TO CRYPTO, A HW OF CRYPTO FLAGS/TYPE, AND A
:	RETURN VIA R11 TO THE CALLER.
::
::	TABLE:		LDTIME:
::	FUNCTION:	USED TO CONTROL THE FREQUENCY OF LINE
::		DIAGNOSTIC REPORTING TO THE SUPERVISOR.  EACH ARRAY LDTIMx
::		RECORDS THE TIME (IN TIK4MN UNITS) THAT THE LAST REPORT WAS
::		MADE.  IF 2 CONSECUTIVE REPORTS ARE MADE, THEN SKIP 3
::		OCCURRENCES OF LDRPRT BEFORE REPORTING AGAIN.  WHEN A EVENT
::		THRESHOLD HAS BEEN EXCEEDED, TEST THE LDTIMx FIELD:
::
::	1. IF TIME OF LAST REPORT = CURRENT TIME MINUS 1, SET LDTIMx TO
::	    CURRENT TIME + 3.
::	2. IF LDTIMx IS LESS THAN CURRENT TIME MINUS 1, SET LDTIMx TO CURRENT
::	    TIME.
::	3. IF LDTIMx IS GREATER THAN OR EQUAL TO CURRENT TIME, MAKE NO REPORT.
::

LDERTB	HC	LINERR,RCRCVD,NR.BRI+06,LDTIM0-LDTIME :BAD BORI
	JAL	R8,CRYPTO
	HC	CRYE41
	JR	R11
LDTESZ	EQ	.-LDERTB		:LDERTB ELEMENT SIZE
	HC	BADACK,RCRCVD,NR.ACK+10,LDTIM1-LDTIME :BAD ACKS
	JAL	R8,CRYPTO
	HC	CRYE42
	JR	R11
	HC	BADRCN,RCRCVD,NR.RCN+10,LDTIM2-LDTIME :BAD RECORD NUMBERS
	JAL	R8,CRYPTO
	HC	CRYE43
	JR	R11
	HC	BADCSM,RCRCVD,NR.CHS+06,LDTIM3-LDTIME :BAD CHECKSUMS
	JAL	R8,CRYPTO		 	: (PACKET W/ GOOD BORI)
	HC	CRYE44
	JR	R11
	HC	RCRXMT,RCRCVD,NR.RTR+03,LDTIM4-LDTIME :RETRANSMISSIONS RECEIVED
	JAL	R8,CRYPTO
	HC	CRYE45
	JR	R11
	HC	TRRXMT,RCTRNS,NR.RTS+03,LDTIM5-LDTIME :RETRANSMISSIONS SENT
	JAL	R8,CRYPTO
	HC	CRYE46
	JR	R11
	HC	FOURSG,RCRCVD,NR.4SG+10,LDTIM6-LDTIME :FOUR SECOND GAP W/ NO RECORDS
	JAL	R8,CRYPTO
	HC	CRYE47
	JR	R11
	HC	LCROSS,RCRCVD,NR.CRS+10,LDTIM7-LDTIME :LINE CROSS-TALK
	JAL	R8,CRYPTO
	HC	CRYE48
	JR	R11
	HC	SPACNG,RCRCVD,NR.SPC+10,LDTIM8-LDTIME :SPACING ON INPUT
	JAL	R8,CRYPTO
	HC	CRYE49
	JR	R11
:LDNEVT	EQ	(.-LDERTB)/LDTESZ 	:NUMBER OF TABLE ELEMENTS
:	number of table entries is now maintained in DATA       	###sdw
	HC	0			:END OF TABLE INDICATION


::*********************************************************************
::
::	SUBROUTINE:	LDRPRT:
::	FUNCTION:	Line diagnostic detection and reporting routine.
::	CALLING SEQ:	JAL	R10,LDRPRT	Called from G01SEC.
::	DESTROYED:	R4, R5, R6, R12, R13, R15
::	CALLS:		JAL	R0,SVCE38	:IF ISIS
::			JAL	R10,SUP12,,
::			JAL	R11,LDERTB+8,R6	:JAL R8,CRYPTO for line/event
::			JAL	R12,SVCE0F	:solo
::			JAL	R10,SIOSUR
::
::*********************************************************************

:	LINE EVENTS ARE COMPARED TO A THRESHOLD BASED ON NUMBER OF PACKETS
:	TRANSMITTED OR RECEIVED, AND REPORTED IF THRESHOLD EXCEEDED.  IN
:	ADDITION, REPORTS ARE THROTTLED FROM EXCESSIVE IDENTICAL
:	CONDITION REPORTING.
:
:	R10 = LINK
:	LN = 2*LINE #
:	R15 = 4-MINUTE TICKER (INCREMENTS EACH TIME THRU)
:	R6 = EVENT INDEX
:	R5 = POINTER TO EVENT ARRAY
:	R4 = POINTER TO TOTAL ARRAY (PACKETS SENT/RECEIVED)
:	R13 = SHIFT FACTOR FOR DETERMINING EVENT THRESHOLD
:	R12 = MSG TYPE FOR REPORT TO SUP
:
:	DIAGNOSTIC REPORTS ARE GENERAL 'REPORT TO LOG' FORMAT, WITH
:	3 HALFWORDS OF INFORMATION, AS FOLLOWS:
:
:	EVENT REPORT:
:	*HW1* TTLL
:	*HW2* NNNN+8000 IF LINE ATTACHED, ELSE NNNN FOR LAST NEIGHBOR ON
:		LINE (0 IF LINE NEVER ATTACHED)
:	*HW3* EEEE
:	WHERE TT IS MESSAGE TYPE, LL IS LINE NUMBER, NNNN IS NEIGHBOR NUMBER,
:		AND EEEE IS NUMBER OF EVENT OCCURRENCES.
:
:	IF AN EVENT REPORT IS MADE, IT IS USEFUL FOR ANALYSIS PURPOSES
:	TO KNOW THE TOTAL NUMBER OF PACKETS SENT/RECEIVED OVER REPORTING
:	PERIOD.  AFTER EVENT REPORTS (IF ANY) HAVE BEEN SENT, TOTAL
:	REPORTS ARE SENT FOR THOSE LINES WHICH REPORTED EVENTS.

:	TOTAL REPORT:
:	*HW1* 80LL
:	*HW2* RRRR
:	*HW3* TTTT
:
:	WHERE 80 IS THE MESSAGE TYPE, LL IS LINE NUMBER, RRRR IS TOTAL
:	NUMBER OF PACKETS RECEIVED OVER REPORTING PERIOD, AND TTTT IS
:	NUMBER OF PACKETS TRANSMITTED.

SVCE38	CRASH.(.SV38C,R5)

LDRPRT	LHI	LN,NLINES-SILINS-1
	ST	R10,LDRGSV		:SAVE LINK REGISTER
	L	R15,TIK4MN
	AIS	R15,1			:INCREMENT TICKER
	ST	R15,TIK4MN

:	LDARLN IS AN ARRAY OF 16-BIT ARRAYS, ONE HW FOR EACH LINE. EVERY 4
:	MINUTES WHEN WE COME HERE WE RESET THE 'NEXT' BIT IN EACH ARRAY. THEN
:	BELOW, IF THERE ARE ANY ERRORS TO REPORT TO THE SUP, THIS BIT GETS SET
:	AGAIN. THUS, FOR EACH LINE THE CORRESPONDING BIT-ARRAY HAS A 1-BIT FOR
:	EACH OF THE PRECEDING 4-MINUTE INTERVALS DURING WHICH ERRORS OCCURED.
:	THIS IS USED IN THE ND DISPLAY TO GIVE A ROUGH SENSE OF ERRORS ON
:	EACH LINE DURING THE PREVIOUS HOUR.
	LHI	R4,(((NLINES+1)/2)*4)-4	:POINT TO THE LAST FW IN LDARLN
					: SO WE CAN FIGURE WHEN WE'RE THRU
LDRP04	L	R6,LDARLN,R4		:GET 2 HW BIT ARRAYS
	SRHLS	R6,1			:RESET OLDEST BIT FOR 1 LINE
	EXHR	R6,R6			:SET UP SECOND LINE
	SRHLS	R6,1			:RESET OLDEST BIT FOR 2ND LINE
	EXHR	R6,R6			:SWITCH THEM BACK
	ST	R6,LDARLN,R4		:STORE THEM AWAY
	SIS	R4,4			:REPEAT TILL DONE
	JGEBS	LDRP04
	LIS	R6,0
LDRP10	LHL	R5,LDERTB,R6		:POINTER TO ERROR COUNT ARRAY
	JE	LDRP50			:END OF TABLE
:	INITIALIZE REGISTERS WITH POINTERS, SHIFT VALUE & MSG TYPE BEFORE
:	ENTERING INNER LOOP
	LHL	R4,LDERTB+2,R6		:# PACKETS TRANSMIT/RECEIVED ARRAY
	LB	R13,LDERTB+5,R6		:SHIFT FACTOR. NOTE THAT A SHIFT
					:FACTOR OF 10 INDICATES THRESHOLD OF 0
	LB	R12,LDERTB+4,R6		:MESSAGE TYPE FOR SUP REPORT
	EXBR	R12,R12			:ALIGN FOR REPORT
	LHI	LN,(NLINES-1)*2		:LINE NUMBER * 2 INDEX
LDRP20	LHL	R0,0,R5,LN		:GET NUMBER OF EVENTS
	LHL	R1,0,R4,LN		:	AND TOTAL NUMBER OF PACKETS
	SRL	R1,0,R13		:COMPUTE REPORTING THRESHOLD
	CR	R0,R1			:# EVENTS > THRESHOLD?
	JLE	LDRP40			:NO
	CLHI	R0,1
	JLE	LDRP40			:DON'T REPORT SINGLE EVENT

	LIS	R3,0			:POINTER TO HO BIT IN LD ARRAY
	SBT	R3,LDARLN,LN		:SET BIT INDICATING LD REPORT WOULD
					: HAVE BEEN SENT TO SUPE
:	SEE IF WE SHOULD THROTTLE REPORTING
	LHL	R11,LDERTB+6,R6 	:get address of LDTIMx
	AI	R11,LDTIME		:make actual address    	###sdw
	AR	LN,LN			:FW INDEX
	L	R3,0,R11,LN		:GET TIME OF LAST REPORT
	SR	R3,R15			:IF TIME OF LAST REPORT .GE. CURRENT
	JGE	LDRP38			: TIME, WE'RE THROTTLED FOR THIS EVENT
					: ON THIS LINE			###wjl
	LR	R10,R15			:R10 IS NEW REPORT TIME
	AIS	R3,1			:TEST FOR CONSECUTIVE REPORTS
	JLFS	LDRP30			:NO
	AIS	R10,3			:THROTTLE REPORTS FOR 3 REPORT PERIODS
LDRP30	ST	R10,0,R11,LN		:SET NEW 'TIME OF LAST REPORT'
	SRLS	LN,1			:RESTORE HW INDEX
	LHL	R7,NGSVLN,LN
LDRP32	STH	R7,SUPMBF+2		:NEIGHBOR NUMBER
	STH	R7,CRYSBF+2		:DITTO FOR CRYPTO BUFFER
	STH	R0,SUPMBF+4		:NUMBER OF EVENTS
	LR	R0,LN
	SRLS	R0,1			:LINE NUMBER
	SBT	R0,LDTARY		:INDICATE REPORT SENT FOR THIS LINE
	STH	R0,CRYSBF		:LINE# FOR CRYPTO
	OR	R0,R12
	STH	R0,SUPMBF		:MSG TYPE, LINE NUMBER
	JAL	R10,SUP12,,		:REPORT LINE DIAGNOSTIC TO SUP
	LHL	R0,0,R5,LN		:NO. EVENTS (AGAIN) FOR CRYPTO
	JAL	R11,LDERTB+8,R6		:JAL R8,CRYPTO FOR THIS LINE AND EVENT
	AR	LN,LN
LDRP38	SRLS	LN,1			:###wjl
LDRP40	CI	R5,TRRXMT		:this one has a history to worry about	
	JN      LDRP41  		:others to be simply cleared
	LHL	R0,TRRXMT,LN		:this value is about to be cleared
	LHL	R1,KL.TRF,LN		:keep same distance between old and new
	SR	R1,R0			:if new=>0 then hist=>hist-new
	STH	R1,KL.TRF,LN		:and done   ###sdw
LDRP41	LIS	R0,0
	STH	R0,0,R5,LN		:CLEAR EVENT COUNTER
	SIS	LN,2
	JGE	LDRP20			:MORE LINES TO CHECK FOR THIS EVENT
	AHI	R6,LDTESZ		:ADVANCE TO NEXT EVENT ARRAY
	J	LDRP10

:	THE FOLLOWING LOGIC QUERIES THE SIO CARD TO SEE IF ANY INTERNAL
:	ERRORS HAVE BEEN DETECTED. WE MUST MAINTAIN COUNTS FROM THE LAST
:	SIO CARD QUERY SINCE MOTHER BOARD'S COUNTS ARE CUMULATIVE.
:	R6 = SIO LINE NUMBER*2
:	R7 = SIOQRY POINTER (ADDRESS TO STORE SIO STATUS IN)

LDRP500	HS	0
	IF	SILINS
	LHI	LN,(NLINES-SILINS)*2	:NODE CODE LINE NUMBER
	LIS	R6,0			:SIO LINE NUMBER
	LA	R7,SIOSTT,,		:POINT TO SIO STATUS BLOCKS	###wjl

:	the previous logic would look at the sio status every 4 minutes to
:	get the running hdlc cksum error count.  Trouble is that it is only a
:	byte and in 4 minutes a messy line can easily wrap the counter and
:	we would never notice.  So now the hdlc cksm is gotten from the sio
:	status every 4 secs and put in siohcr			###sdw
LDRP52	lh	R0,siohcr,R6		:GET COUNT OF HDLC CHECKSUM ERRORS#sdw
	LR	R1,R0
	SH	R0,SIOHCK,R6		:GET DIFFERENCE FROM LAST STATUS PERIOD
	lhr	r0,r0			:hw
	JE	LDRP54			:NO CHECKSUM ERRORS THIS LINE	###wjl
	STH	R1,SIOHCK,R6		:SAVE NEW COUNT
	lhl	r8,rcrcvd,ln		:see if breaks threshhold
	srls    r8,7			:over 128
	cr	r0,r8			:hdlc cksum error>= packets/128 ?
	jl      ldrp54  		:nope, not bad enough to log
	JAL	R10,SIOSUR		:SET UP NODE REPORT
	JAL	R8,CRYPTO,,		:REPORT TO CRYPTO-COUNT IN R0, LINE,
	HC	CRYE4A			: NEIGHBOR WERE SET UP IN SIOSUR
	LHI	R0,NR.HCK,R1
	STH	R0,SUPMBF		:INDICATE ERROR TYPE, LINE #
	JAL	R10,SUP12,,		:LINE DIAGNOSTIC NODE REPORT TO SUP
LDRP54	LHL	R0,SS.ABR,R7		:only positive values meaningful###wjl
	SRLS	R0,4			:ISOLATE SIO HDLC ABORT COUNTER
	LR	R1,R0
	SH	R0,SIOHAB,R6		:DIFFERENT THAN LAST TIME?
	NHI	R0,0FFF			:only 3 nibbles are meaningful	###wjl
	JE	LDRP58			:NO INCREASE			###wjl
	STH	R1,SIOHAB,R6		:SAVE NEW COUNT
	JAL	R10,SIOSUR		:SET UP NODE REPORT
	JAL	R8,CRYPTO,,		:CRYPTO REPORT-R0 IS COUNT, LINE &
	HC	CRYE4B			: NEIGHBOR WERE SET UP IN SIOSUR
	LHI	R0,NR.HAB,R1
	STH	R0,SUPMBF		:INDICATE ERROR TYPE, LINE #
	JAL	R10,SUP12,,		:SEND NODE REPORT TO SUP
LDRP58	AHI	R7,10
	AIS	R6,2			:BUMP INDEX REGS
	AIS	LN,2
	CLHI	LN,NLINES*2		:DONE ALL SIO LINES?
	JL	LDRP52			:NO - CONTINUE
	J	LDRP60			:YES - REPORT PACKET TOTALS

::*********************************************************************
::
::	SUBROUTINE:	SIOSUR:
::	FUNCTION:	SET UP NODE REPORT FOR SIO LINE ERROR
::	CALLING SEQ:	JAL	R10,SIOSUR
::	DESTROYED:	R1
::
::*********************************************************************

SIOSUR	OHI	R0,8000			:###wjl
	STH	R0,SUPMBF+4		:SAVE COUNT 
	LHL	R1,NGSVLN,LN
	STH	R1,SUPMBF+2		:REPORT NEIGHBOR ON LINE
	STH	R1,CRYSBF+2		: AND SAVE FOR CRYPTO
	LR	R1,LN
	SRLS	R1,1			:LINE NUMBER
	SBT	R1,LDTARY		:REPORT PACKET TOTALS FOR THIS LINE
	STH	R1,CRYSBF		:LINE# FOR CRYPTO
	XI	R0,8000			:COUNT FOR CRYPTO, NO HOB	###wjl
	JR	R10			:RETURN
	EI	:SILINS

:	Clear PACKET TOTAL FIELDS AND REPORT TOTALS FOR LINES WHICH
:	REPORTED EVENTS.
LDRP60	LHI	R4,NLINES-1
	LHI	LN,(NLINES-1)*2
LDRP62	RBT	R4,LDTARY		:CLEAR AND TEST BIT...
	JE	LDRP70			:...NO REPORTS MADE FOR THIS LINE

:	REPORT PACKET TOTALS FOR INTERESTED OBSERVER
	STH	R4,CRYSBF		:LINE# FOR CRYPTO
	LHL	R0,NGSVLN,LN		:NEIG# FOR CRYPTO
	STH	R0,CRYSBF+2
	LHI	R0,NR.SRT		:MSG TYPE FOR REPORTING TOTAL SENT&RCVD
	OR	R0,R4			:COMBINE LINE NUMBER WITH MESSAGE TYPE
	STH	R0,SUPMBF
	LH	R0,RCRCVD,LN		:TOT # PACKETS RECEIVED
	STH	R0,SUPMBF+2
	STH	R0,CRYSBF+4		:FOR CRYPTO
	LR	R10,R0			:(SAVE NUMBER OF PACKETS RECEIVED)
	LH	R0,RCTRNS,LN		:TOT # PACKETS TRANSMITTED
	STH	R0,SUPMBF+4
	STH	R0,CRYSBF+6		:FOR CRYPTO
	AR	R10,R0			:IF TOTAL PACKETS RECEIVED AND SENT
	JEFS	LDRP70			: =0, DO NOT MAKE TRIVIAL NODE REPORT
	JAL	R10,SUP12,,		:REPORT TOTALS TO SUP
	JAL	R8,CRYPT0,,
	HC	CRYE40
LDRP70	STH	R5,RCRCVD,LN		:CLEAR # PACKETS RECEIVED
	STH	R5,RCTRNS,LN		: AND NUMBER PACKETS TRANSMITTED
	STH	R5,KL.RRF,LN		: AND REF CNTR FOR MTRFIC STATS	###JHL
	SIS	R4,1
	SIS	LN,2
	JGE	LDRP62			:CONTINUE
	L	R10,LDRGSV		:RESTORE LINK REG
	JR	R10			:RETURN


	SUBTTL	LINKER (ATTLIN - Line attach logic)

::*********************************************************************
::
::	SUB-PROCESS:	ATTLIN:
::	FUNCTION:	Identifies and Attaches Lines.  Scheduled by LINKER
::	CALLING SEQ:	Jal	r10,ATTLIN
::	CALLS:		JAL	R9,FNDLNK
::			JAL	R8,WCI
::			JAL	R9,RSTSTR
::			JAL	R8,ATTMCL
::			JAL	R10,SUP12
::			JAL	R8,CRYPTO
::			JAL	R8,GMTLIN
::			JAL	R10,KSPEED
::			JAL	R10,SUP13
::			JAL	R8,TSBMRK
::			JAL	R11,LNKCON
::			JAL	R9,CLRCHN
::	RETURNS:	Jr	r10
::
::*********************************************************************

ATTLIN	st	r10,detsav
	jfs	attl98
attlnx	jal	r0,exyld		:here for next line
attl98	lhi	ln,(((nlines-1)/10)*10)!0f
	lhi	r0,2*((nlines-1)/10)+linkas
	lr	r1,r0
	arand	r0,ln
	jfs	attl99
	l	r10,detsav
	jr	r10

attl99	rbt	ln,linkas		:mark line as serviced
	AR	LN,LN
	L	SD,SDLN,LN,LN		:RESET BUFF PTR
:	Problem of putting wrong reset in front of a reset packet.  Problem
:	is that logic assumes that any subsequent resets are of same type as
:	original reset.  Solution is to consider different type of reset an
:	error and go back to sending sending initial resets of same type
:	we just received.

	LH	R4,VRSTP,SD
	NHI	R4,0FFE0		:reset type (expanded or old is left)
	LH	R3,XRSTP,SD		:make sure sending same type that
	NHI	R3,0FFE0		: is being received
	CR	R3,R4			:same type
	JN	ATTLD4			:no, start over
	CLHI	R4,TXRSHD		:new reset?
	JNFS    ATT100
	SBT     LN,XRSTBT		:indicate new reset received
	JE      ATTLD4  		:***previous wasn't
	JFS     ATT101  		:check timout
ATT100  RBT     LN,XRSTBT		:got an old reset
	JN      ATTLD4  		:
ATT101	LHL	R3,RSTIM,SD		:IF FIRST TIME, SET TIMEOUT
	JN	ATTLI1			:NOT FIRST TIME
	LH	R4,VRSTP,SD		:get Received Reset Header 
	NHI	R4,0FFE0		:mask off 'subsequent & count' bits
	CLHI	R4,TXRSHD		:compare with Expanded Reset Header
	JN	ATT001			:no, must be old version
:	if apply BP then must respond to neighbor's request to receive
:	active bp msgs.  Easiest is to on first reset to put it into the
:	resets we will be transmitting.
:	Code simplified here ###10/10/93
      IF	APLYBP			:set bits we are acking in reset
        L       R1,VKATTR,SD            :get received attributes
        THI     R1,LK.RAB               :did other end request active BP?
        JEFS    ATT102                  :other end did not request
        OHI     R1,LK.RAB+LK.SAB        :request and ack request
ATT102  O       R1,XKATTR,SD            :combine with existing attributes
	ST	R1,XKATTR,SD		:save into transmitted reset
       IF	 SILINS
	CLHI	LN,(NLINES-SILINS-1)*2	:sio lines have another reset xmit buf
	JLEFS	ATT105
	L	R6,SIORSP,LN,LN
	ST	R1,(XKATTR-VSDSZ)+2,R6	:save into transmitted sio reset
ATT105
       EI	:SILINS
      EI	:APLYBP
	SBT	LN,XRSTBT		:yes, set bit indexed by LN*2
	L	R1,VNDID,SD		:get FW Machine Number from Reset
	JFS	ATT002
ATT001	RBT	LN,XRSTBT		:reset bit for old version
	LR	R1,LN
	AIS	R1,1			:bit indexed by (LN*2)+1
	RBT	R1,XRSTBT		:reset bit for first time 
	LH	R1,VRSTP+2,SD		:1st RESET, GET MACHINE # FROM RESET
ATT002	JLE	ATTLD4			:NOT A VALID NODE NUMBER
	CLHI	R1,MACHNM		:ARE WE TALKING TO OURSELVES?
	JN	ATPT00			:no				###wjl

:	CROSS-TALK ERROR - CARELESS CONFIGURATION OR HARDWARE PROBLEM
:	INCREMENT COUNTER AND TIME-OUT LINE

	LIS	R0,1
	AHM	R0,LCROSS,LN		:NOTE CROSS-TALK ON THIS LINE
	J	ATTLD4

:	VERIFY THAT LINK PERMUTER TABLE SPACE IS AVAILABLE BEFORE
:	ENTERING ATTACH PROCESS.  NOTE THAT ADDITIONAL P.T.  SPACE IS
:	NOT REQUIRED FOR MULTI-LINE ATTACH.
ATPT00	LHI	R8,(NLINES-1)*2
ATPT10	LH	R0,NGSVLN,R8	:SEE IF NEIGHBOR NUMBER IN RESET MATCHES
				:	ONE THAT IS ALREADY ATTACHED
	JLFS	ATPT30		:NEGATIVE IF LINE ATTACHED TO SOME LINK
ATPT20	SIS	R8,2
	JGEBS	ATPT10		:SCAN ALL LINES
:	RESET IS FOR NEW LINK - SEE IF AT LEAST 2 PAGES OF PERMUTER TABLES
:	ARE AVAILABLE FOR LINK INITIALIZATION
	LH	R0,NUMPAG	:NUMBER OF AVAILABLE PAGES
	SIS	R0,2
	JGEFS	ATPTND		:ENOUGH TO COMPLETE INITIALIZATION
	LIS	R0,NR.NPT	:indicate not enough permuter table space##wjl
	JAL	R7,ATTNR	:report to sup log			###wjl
	J	ATTDIE		:SUSPEND LINE				###wjl
ATPT30	NHI	R0,7FFF		:FOUND ATTACHED LINE. SEE IF RESET'S NEIGHBOR
	CR	R0,R1		:	MATCHES FOR POTENTIAL MULTI-LINE LINK
	JNBS	ATPT20		:NO

ATPTND	STH	R1,NGSVLN,LN	:SAVE MACHINE NUMBER FROM RESET
	LH	R4,VRSTP,SD	:RESET HEADER
:	this NHI added to ensure that all reset sequences start with reset
:	zero.  Telematics would send sequence that caused NC to see 33A1 as
:	the initial reset which is wrong.			08/19/93
	NHI	R4,0FFF0		:mask off 'count' bits
	CLHI	R4,TTRSHD		:Original T-II Reset Header?
	JN	ATTL00			:jump if Expanded Header received
	L	R0,TTRSET+4
	ST	R0,XRSTP+4,SD		:store CKSUM
	LI	R0,VERCOM		:VERSION and Complement
	ST	R0,XRSTP+8,SD		:for backwards compatability!
	LCS	R2,1			:store FFFFs over remainder...	###wjl
	LHI	R3,XSDSZ-10		:byte count-4			###wjl
ATTLI3	ST	R2,XRSTP+0C,SD,R3	:store one word at a time	###wjl
	SIS	R3,4			:back up a FW at a time		###wjl
	JGEBS	ATTLI3			:loop till done			###wjl

	IF	SILINS
	CLHI	LN,(NLINES-SILINS-1)*2
	JLEFS	ATTL00			:skip if not SIO line
	L	R2,SIORSP,LN,LN		:get SIO Reset Buffer Pointer
	ST	R0,6,R2			:store VERSION and Complement
	EI	:SILINS			:for backwards compatibility!

ATTL00	CLHI	R1,MACHNM	:TEST FOR NEIGHBOR WITH HIGHER MACHINE NUMBER
	JG	ATTA4		:YES - THAT MAKES US THE SLAVE FOR THIS LINK

	JAL	R8,ATTADD	:NO - WE'RE MASTER, add neighbor to MRESET##wjl

:	TEST FOR SUBSEQUENT LINE ON EXISTING LINK.  IF LINK UNDEFINED OR
:	IF NUMBER OF LINES ON LINK=0, THEN THIS IS THE FIRST LINE ON
:	THAT LINK.
:					First Line	Subsequent Line
:	Original T-II Reset Header	30A0 (TTRSHD)	30B0 (TSRSHD)
:	Expanded Reset Header		33A0 (TXRSHD)	33B0 (TYRSHD)

	CLHI	R4,TTRSHD		:Original T-II Reset Header?
	JEFS	ATTA4			:yes
	LHI	R4,TXRSHD		:No, assume Expanded Reset for New Link

ATTA4	JAL	R9,FNDLNK,,		:SEE IF LINK EXISTS
	SKIPAD(ATTA5)			:immediate return, LINK UNDEFINED###wjl
	CLHI	R4,TTRSHD		:+4 return, Original T-II Reset Header?
	JE	ATTL01			:yes, skip WSIZ and KSPD
       if	aplybp
	lis	r8,0			:default value
	tbt	kn,kna.bp		:should it request apply bp?
	jefs	atta42
	lis	r8,lk.rab		:request apply bp
atta42	o	r8,xkattr,sd		:add into whatever else is set
	st	r8,xkattr,sd
       ei	:aplybp
	LB	R7,WSIZ,KD		:get Window Size
	STB	R7,XWSIZ,SD		:store it in xmit reset pattern
	LB	R9,KSPD,KD		:get Link Speed for Sat Bit
	STB	R9,XKSPD,SD		:store Link Capability for xmit

	IF	SILINS
	CLHI	LN,(NLINES-SILINS-1)*2
	JLE	ATTL01			:skip if not SIO line
	L	R1,SIORSP,LN,LN		:get SIO Reset buffer Pointer
	STB	R7,(XWSIZ-VSDSZ)+2,R1	:-offset for Received Pattern Size,
       if	aplybp
	st	r8,(xkattr-vsdsz)+2,r1
       ei	:aplybp
	STB	R9,(XKSPD-VSDSZ)+2,R1	:+HW storage for SIO Reset Buffer Size
	EI	:SILINS

ATTL01	LB	R7,NLAT,KD		:GET NUMBER OF LINES ATTACHED TO LINK
	JNFS	ATTA46			:NONZERO - MULTILINE LINK
:	initialize values for the link that change during the reset process
	rbt	kn,noshrk		:default shrinks enabled
       if	aplybp
	rbt	kn,XACTBP		:default to normal bp relief logic
	rbt	kn,VACTBP		:default to normal bp relief logic
       ei	:aplybp
:	the following used to be a jump to ATTA5 and was changed to ATTA6.
:	Reason being that this first received we got can be an 33A1 if
:	we are the slave which means we will respond with 33A2 instead of
:	33A1.  If we got here then were are expanded resets single link
:	and thus have no need to store the received reset as stored value
:	has to be okay.				8/01/93
	J	ATTA6			:single link logic

:	multiline link logic
atta46	LHL	R2,TBDPKN,KN,KN		:GET CHANNEL ZERO
	LHL	R2,NIOTAB,R2,		:	BUFFER NUMBER AND
	NHI	R2,-4			:	MASK OFF SPEED BITS
	XHI	R2,4			:SET UP OUTBOUND BUFFER INDEX
:	LINK'S CHANNEL ZERO EXISTS FOR INTER-LINK CONTROL. SEND NEIGHBOR
:	'FASTC' AS SECURITY KEY FOR BRINGING UP SUBSEQUENT LINE ON LINK.
	LIS	R1,6			:CHARACTER COUNT
	JAL	R8,WCI,,
	LIS	R1,1			:MESSAGE TYPE FOR SENDING KEY
	JAL	R8,WCI,,
	LH	R1,FASTC,,		:FIRST 2 BYTES OF KEY
	STH	R1,RESETE,LN		:SAVE HERE FOR STEP 'E'
	EXBR	R1,R1
	JAL	R8,WCI,,		:DEPOSIT KEY 1 BYTE AT A TIME
	EXBR	R1,R1
	JAL	R8,WCI,,
	LH	R1,FASTC+2,,		:NEXT 2 BYTES OF KEY
	STH	R1,RESETF,LN		:SAVE HERE FOR STEP 'F'
	EXBR	R1,R1
	JAL	R8,WCI,,
	EXBR	R1,R1
	JAL	R8,WCI,,
	LR	R2,LN			:RESTORE R2 TO ACTUAL LINE NUMBER
	SRLS	R2,1

	CLHI	R4,TTRSHD		:check for original T-II Reset Header
	JNFS	ATTL02			:no, must be Expanded Reset header

	LHI	R4,TSRSHD		:RESET HEADER FOR SUBSEQUENT LINE
	JFS	ATTA5
ATTL02	LHI	R4,TYRSHD		:Expanded Reset Header for Subseq Line

ATTA5	TBT	LN,XRSTBT		:Expanded Reset received?
	JEFS	ATT004			:no
	STH	R4,XRSTP,SD		:yes, store header only
	JFS	ATTA6

ATT004	EXHR	R4,R4
	OHI	R4,MACHNM		:INCLUDE MACHINE NUMBER
	ST	R4,XRSTP,SD		:FIRST 32 BITS OF RESET

ATTA6	LH	R3,SLOWC+2,,		:START TIMER FOR RESET SEQUENCE
	AHI	R3,$A40			:must complete within 40 seconds
:	(INCREASED FROM 20 SECONDS TO ALLOW 2.4 LINES TO ATTACH)
	JNFS	ATTA7
	AIS	R3,1			:FORCE NON-ZERO SO WON'T BE INTERPRETED
					: AS FIRST RESET
ATTA7	STH	R3,RSTIM,SD

:	HERE IF NOT FIRST TIME - CHECK TIMEOUT 
ATTLI1	LH	R1,SLOWC+2,,		:CHECK TIMEOUT
	SR	R1,R3
	LHR	R1,R1
	JL	ATTLI4
	jfs	attld4			:restart reset logic

::  check to issue crypto message for bad-guy list
ATTLD2	SBT	LN,XRBGUY		: should we report it for this line?  
	JNFS	ATTLD4			: no, already reported
	LR	R0,R1			: get neighbor # in R0 for crypto
	JAL	R8,CRYPTO		: report to crypto log
	 HC	CRYE4C			:  (Line's not coming up due to bad-guy


ATTLD4	JAL	R9,RSTSTR		:TIMEOUT OR OTHER ERROR, ABORT
:	Nodes with 'old' reset code may 'suspend' line during multi-line###wjl
:	reset or if out of link descriptors.  After suspension they will###wjl
:	remain in 'single-reset' state.  As they will not recognize 33A0###wjl
:	as a reset they will never send another reset!!  To avoid this,	###wjl
:	store a 30A0.  It is not necessary to store the entire pattern	###wjl
:	as even an abort will cause the node to begin 'streaming' resets,##wjl
:	which will allow recovery. Note that R6 is required and is set up##wjl
:	in RSTORE (called by RSTSTR).					###wjl
	LH	R4,VRSTP,SD		:test for old type reset received##wjl
	NHI	R4,0FFE0		:mask off 'subsequent'&count bits##wjl
	CLHI	R4,TXRSHD		:compare with 'expanded' reset	###wjl
	JE	ATTL05			:new version reset...		###wjl

:	Make data in reset packet always match the reset header.	###sdw
:	Before if an error was found then the old style reset header would
:	be put in front of a new style reset packet.  Possible for both nodes
:	to be in this error condition and never exit since neighbor is sending
:	bad packet, which is error so send bad packet, and get it back and so
:	on.
:	Previous patch used R6 instead of SD to change it in SIO buffer if
:	SIO port, but both reset buffers should match.
:	For SIO buffer the remaining is not set to FFFF since only used for
:	sync to prevent false indication of new data.
	LHI	R4,TTRSHD		:existing instructions
	STH	R4,XRSTP,SD		:old reset header stored
	LHI	R0,MACHNM		:new logic: construct old reset packet
	STH	R0,XRSTP+2,SD
	L	R0,TTRSET+4,,		:write old reset packet data
	ST	R0,XRSTP+4,SD
	LI	R0,VERCOM
	ST	R0,XRSTP+8,SD
	LHI	R3,XSDSZ-10
	LCS	R2,1			:overwrite old data
ATT090  ST	R2,XRSTP+0C,SD,R3
	SIS	R3,4
	JGEBS   ATT090
       IF	 SILINS
	CLHI    LN,(NLINES-SILINS-1)*2  :sio lines have another reset xmit buf
	JLE     ATTL05,,
	L	R6,SIORSP,LN,LN
	L	R0,XRSTP,SD		:copy reset packet
	ST	R0,2,R6 		:first HW is count for SIO packet
	LI	R0,VERCOM
	ST	R0,6,R6
       EI 	:SILINS
ATTL05	LHL	R1,NGSVLN,LN		:REMOVE NEIGHBOR NUMBER FROM MRESET
	NHI	R1,7FFF
	JAL	R8,ATTMCL
	J	attlnx

::	Here, if reset is not timed out
ATTLI4	LHL	R0,RSCNT,SD		:NEEDED BELOW
	LHL	R1,VRSTP,SD		:NEEDED BELOW
	LR	R2,LN			:get line #
	SRLS	R2,1			:line number * 1		###sdw
	RBT	R2,VRSTDL		:TYMNET-II - DID WE GET A RESET?
	JE	ATTLD6			:WE DONT HAVE A RESET

	TBT	LN,XRSTBT		:Expanded Reset Header?
	JE	ATTL03			:no
      if	aplybp			:set bits we are acking in reset
	l	r2,vkattr,SD		:get received attributes
	nhi	r2,lk.rab		:did other end request active BP?
	slls	r2,1			:pass on setting in the bit
	jefs	att092			:other end did not request
	ohi	r2,lk.rab		:if other end requests then we request
att092	o	r2,xkattr,sd		:combine with existing attributes
	st	r2,xkattr,sd		:save into transmitted reset
       IF	 SILINS
	CLHI	LN,(NLINES-SILINS-1)*2	:sio lines have another reset xmit buf
	JLEFS	ATT093
	L	R6,SIORSP,LN,LN
	st	r2,(xkattr-vsdsz)+2,r6		:save into transmitted sio reset
att093
       ei	:silins
      ei	:aplybp
	CLHI	R1,TYRSHD+0E		:Expanded Reset for Subseq Line +0E?
	JL	ATTLW2			:still working or not Subsequent Line
	JE	ATTLW1			:Subsequent Line - Step 0E
	JFS	ATTL04			:Subsequent Line - Step 0F

ATTL03	CLHI	R1,TSRSHD+0E	:HAS PING-PONG COUNT FOR SUBSEQUENT LINE
				:	ADVANCED TO STEP 'E'?
	JL	ATTLW2		:STILL WORKING OR NOT SUBSEQUENT LINE...
	JE	ATTLW1		:YES - RESET STEP 'E'
ATTL04	HS	0		:SUBSEQUENT LINE, RESET STEP 'F'
	LH	R1,VRSTP+2,SD	:GET 2ND 2 BYTES OF KEY RECEIVED OVER NEW LINE
	CLH	R1,RESETF,LN	:AND COMPARE TO KEY WE SENT OVER EXISTING LINK
	JN	ATTDIE		:MISMATCH - SECURITY VIOLATION OR DUMB NEIGHBOR
	LIS	R1,0F		:SET UP FOR PING-PONG COUNT OF 0F
	J	ATTLW3
ATTLW1	HS	0		:STEP 'E' - RESET SHOULD CONTAIN FIRST 2 BYTES
				:OF KEY SENT OVER LINK--SAVED IN RESETE
	LH	R1,VRSTP+2,SD	:GET FIRST 2 BYTES OF KEY RCV'D OVER LINE AND
	CLH	R1,RESETE,LN	:COMPARE TO KEY WE SENT OVER EXISTING LINK
	JN	ATTDIE		:MISMATCH - MAYBE SLOW LINK RESPONSE OR 
				:	SECURITY VIOLATION
	LIS	R1,0E		:SET UP FOR PING-PONG COUNT OF 0E
	J	ATTLW3
ATTLW2	LHL	R2,NGSVLN,LN	:GET NEIGHBOR NUMBER			###cwc

	TBT	LN,XRSTBT		:Expanded Reset received?
	JEFS	ATT006			:no
	CL	R2,VNDID,SD		:yes, compare to FW from reset
	JFS	ATT008
ATT006	CLHI	R0,1			:expecting first reset?
	JLEFS	ATT010			:yes
	LCS	R3,1			:no
	ST	R3,XRSTP+4,SD		:store marks over checksum
ATT010	CLH	R2,VRSTP+2,SD		:COMPARE TO WHAT WE GOT FROM RESET
ATT008	JN	ATTLD4			:INCONSISTENT - MAYBE LINE NOISE
	NHI	R1,0F			:MASK OUT PING-PONG COUNT
ATTLW3	LHL	R2,NGSVLN,LN		:GET NEIGHBOR NUMBER
	CLHI	R2,MACHNM		:DISPATCH ON MASTER/SLAVE
	JL	ATMAST			:WE'RE MASTER
	LR	R0,R0			:SLAVE, IF IN STATE 0...
	JNFS	ATNEXT
	LR	R1,R1			:ACCEPT A 0 OR A 1
	JE	ATTLD3			:Check number of initial resets
	LIS	R0,1			:TRY FOR A 1
ATNEXT	CR	R0,R1			:DID WE GET WHAT WE EXPECTED
	JN	ATTLD4			:NO, RESTART
	AIS	R0,1			:INCREMENT EXPECTED RESPONSE
	STH	R0,RSCNT,SD
	CLHI	R0,3			:TIME TO REQUEST SPEED CALCULATION?
	JNFS	ATNX01
	LR	R1,LN
	SRLS	R1,1			:GET LINE NO.
	SBT	R1,LINSPT		:REQUEST LINE SPEED CALC (SEE G01SEC)
ATNX01	LHL	R0,XRSTP,SD		:				###cwc
	AIS	R0,1			:INCREMENT PING-PONG COUNT
	STH	R0,XRSTP,SD
	CLHI	R0,TSRSHD+0E	:HAVE WE ADVANCED TO STEP 'E' OF RESET SEQUENCE
				: FOR SUBSEQUENT LINE ON LINK?
	JL	ATTLD3		:NO - NEW LINK OR STILL INCREMENTING PING-PONG

	NHI	R0,0F0FF		:mask out expanded vs. t-ii bits
	CLHI	R0,TSRSHD+0E		:Step 0E, Subsequent Line?
	JL	ATTLD3			:no, Expanded new Link or incrementing

	LHL	R1,NGSVLN,LN		:GET NEIGHBOR NUMBER AND	###cwc
	JAL	R9,FNDLNK,,		:	SET UP LINK DESCRIPTOR
	SKIPAD(ATTLD4)			:NOT FOUND - LINK WENT DOWN OR...?##wjl
	LH	R2,RKEY,KD		:+4 return, ASSUME STEP 'E'

	CLHI	R0,TSRSHD+0E		:step 0E?

	JEFS	ATNX02			:YES - STEP 'E'
	LH	R2,RKEY+2,KD		:NO - STEP 'F'
ATNX02	STH	R2,XRSTP+2,SD		:STORE 2 BYTES OF KEY IN RESET XMIT BUF
	J	ATTLD3			:GO TRANSMIT RESET

ATMAST	LR	R0,R0			:MASTER, IF IN STATE 0...
	JE	ATTNXT			:RETURN A 0
	CLHI	R0,2			:IF IN STATE 2, IGNORE 0'S
	JNFS	ATMAS1
	LR	R1,R1
	JE	attlnx
ATMAS1	AIS	R1,1			:ELSE EXPECT WHAT WE SENT LAST
					:REDUCE PING-PONG COUNT TO 4

	CLHI	R1,10			:IF WE GOT FINAL COUNT...
	JE	ATTLN8			:ATTACH
	J	ATNEXT

ATTNXT	TBT	LN,XRSTBT		:Expanded Reset received?
	JNFS	ATT012			:Yes
	LR	R0,LN			:No, we want to send two 30A0's.
	AIS	R0,1			:(LN*2)+1
	TBT	R0,XRSTBT		:Have we already sent a 30A0?
	JEFS	ATT014			:No, don't bump count yet.
ATT012	LIS	R0,1
	STH	R0,RSCNT,SD		:SET RESET COUNT TO 1
	JFS	ATTLD3			:				###wjl

ATT014	SBT	R0,XRSTBT		:Remember to bump count next time

::
:	PREPARE RESET FOR TRANSMISSION
ATTLD3	HS	0			:PREPARE RESET FOR XMIT
	LHI	R0,SIORS-SEG1		:SET SINGLE RESET STATE
      IF	SILINS
	LHL	R6,SIOTST,LN		:get current state
	CLHI	R6,SIORWT-SEG1  	:is still initing?
	JNFS    ATT016  		:no
	STH	R0,SIOTSV,LN		:after init go to single reset
	JFS     ATT017
      EI	:SILINS
ATT016	STH	R0,SIOTST,LN
ATT017					:don't overwrite wait state

	IF	SILINS			:SIO LINE ??
	CLHI	LN,(NLINES-SILINS-1)*2
	JLE	ATTL3A			:SKIP IF NOT SIO LINE
	L	R6,SIORSP,LN,LN		:get SIO Reset Buffer Pointer
	lhi	r0,7c
	sth	r0,0,r6			:save length of reset
	SHI	R6,VSDSZ-2		:-offset for Received Pattern Size
	L	R0,XRSTP,SD		:MOVE RESET PATTERN to SIO Reset Buffer
	ST	R0,XRSTP,R6		:+HW storage for SIO Reset Buffer Size
	JAL	R5,CCKSUM		:calculate and store checksum for xmit
	J	attlnx
	EI	:SILINS

:	SEND SYNC LINE RESET
ATTL3A	TBT	LN,XRSTBT		:expanded reset?		###wjl
	JEFS	ATT005			:no				###wjl
	LR	R6,SD			:CCKSUM needs Reset Buffer Ptr in R6
	JAL	R5,CCKSUM		:calculate and store checksum for xmit
ATT005	J	attlnx

:	HERE TO SUSPEND LINE AND IGNORE FOR 'KDIGTM' SECONDS
ATTDIE	LHL	R2,NGSVLN,LN		:get neighbor number		###wjl
	CLHI	R2,MACHNM		:dispatch on master/slave	###wjl
	JLFS	ATTD00			:we're master			###wjl
	LIS	R1,0			:slave should clear		###wjl
	STH	R1,RSTIM,SD		: reset timeout			###wjl
	JFS	ATTDIT			:				###wjl
ATTD00	LHI	R1,KDIGTM
	AHM	R1,RSTIM,SD
ATTDIT	LIS	R1,0
	STH	R1,RSCNT,SD		:CLEAR RESET COUNT
	LHL	R1,XRSTP,SD		:clear count from reset pattern	###wjl
	NHI	R1,3FB0			:so we start from zero		###wjl
	STH	R1,XRSTP,SD		:				###wjl
	LCS	R1,1			:CAUSE 'SYLUAL'
	ST	R1,KDLN,LN,LN		: TO IGNORE ANY RECEIVE DATA
	LR	R0,LN
	SLLS	R0,0F			:GET LINE NUMBER IN UPPER HALFWORD AND
	LHL	R8,NGSVLN,LN		: GET NEIGHBOR NUMBER
	OR	R0,R8			: COMBINE AND
	ST	R0,CRYSBF		: SAVE FOR CRYPTO
	LHI	R0,KDIGTM		:NO. SEC'S SUSPENDED
	JAL	R8,CRYPTO		:REPORT TO XRAY
	HC	CRYE20			:	(LINE SUSPENDED)
	LR	R0,LN
	SRLS	R0,1			:LINE NUMBER
	SBT	R0,LNSUSC		:INDICATE LINE SUSPENDED AND
	RBT	R0,LINATT		:	END LINE ATTACH PROCESS...
	JAL	R8,GMTLIN		:SET TIME
	J	attlnx

:	HERE IF WE DID'T GET A RESET
ATTLD6	LHL	R2,NGSVLN,LN		:IF WE'RE SLAVE AND HAVE SENT
	CLHI	R2,MACHNM		:...FINAL RESET, ATTACH
	JL	attlnx

	CLHI	R0,10
	JN	attlnx

	LHL	R0,SIOTST,LN		:GET CURRENT STATE	###cwc
	CLHI	R0,SIOIDL-SEG1		:IDLING?
	JN	attlnx			:NO, DONE

:	LINE HAS GONE THRU RESET PROCEDURE, NOW LOCATE CORRESPONDING
:	LINK AND COMPLETE ATTACHMENT.
ATTLN8	LHI	R5,(BGLSIZ-1)*2
	LHL	R1,NGSVLN,LN		:GET NEIGHBOR NUMBER
ATTL06	CLH	R1,BGLIST,R5		:check bad guy list 
	JE	ATTLD2
	SIS	R5,2
	JGEBS	ATTL06

	TBT	LN,XRSTBT		:Expanded Reset Header?
	JEFS	ATTL17			:no
	LHL	R0,VNETID,SD		:get received NETID
	CLH	R0,XNETID,SD		:compare with xmitted NETID
	JE	ATTL07	
	JAL	R10,ATTNID		:not equal!			###AL
	J	ATTLD4

attl17  lh	r0,vrstp+4,sd		:any version present?
	je      attl07  		:nope, something old
	lh	r9,vrstp+6,sd		:get 1s complement
	xr	r9,r0			:verify version
	ais	r9,1
	jn	attl07	 		:some garbage, not a version
	clhi    r0,$8 520		:this neighbor 5.20 or later?
:	the link is suspende to force it out of old style resets.
	jlfs	attl07  		:neighbor only knows old style
	lhi	r0,txrshd
	sth	r0,vrstp,sd		:make sure send out expanded
	jal	r9,rststr
	lh	r1,ngsvln,ln
	nhi	r1,7fff
	jal	r8,attmcl
	j       attdie  		:next time on expanded resets

ATTL07	JAL	R9,FNDLNK,,		:neighbor number (preserved) in R1
	SKIPAD(ATLN8A)			:immed return, nonexistent link	###wjl
	LB	R7,NLAT,KD		:+4 return, R7 used in ATTCLR	###wjl
	JE	ATLN8D			:SKIP IF NEW LINK COMING UP

:	SUBSEQUENT LINE ON LINK...CHECK IT OUT
	LH	R0,VRSTP,SD		:GET RESET HEADER BACK
	CLHI	R0,TTRSHD+0F		:TYMNET-II HEADER FOR NEW LINK?
	JE	ATTLD4		:YES, MUST USE TSRSHD HEADER FOR SUBSEQ LINE

	CLHI	R0,TXRSHD+0F	:T-II Expanded Reset Header for new link?
	JE	ATTLD4		:yes, must use TYRSHD for subsequent line
	J	ATTL08		:no KD update or WSIZ match down needed

:	FIND AN AVAILABLE LINK DESCRIPTOR
ATLN8A	LR	R0,R1			:save neighbor number		###wjl
	JAL	R9,FNDLNZ,,		:find free link descriptor	###wjl
	SKIPAD(ATLN8B)			:immed return, no link descriptor##wjl
	LR	R1,R0			:+4 return, restore neighbor #	###wjl
	STH	R1,NDID,KD		:found a link descriptor 
	LIS	R7,0			:R7 used below for call to ATTCLR##wjl
	JFS	ATLN8D

:	NO LINK DESCRIPTOR AVAILABLE - MAKE NODE REPORT TO SUP AND SUSPEND
ATLN8B	LR	R1,R0			:restore neighbor number	###wjl
	LIS	R0,NR.NKD		:indicate no link descriptor	###wjl
	JAL	R7,ATTNR		:report to sup log		###wjl
	J	ATTDIE			:SUSPEND LINE

:	WE HAVE THE LINK DESCRIPTOR
ATLN8D	TBT	LN,XRSTBT		:check for Expanded Reset Header
	JE	ATTL08			:no KD update or WSIZ matchdown
	L	R0,VVERNO,SD
	ST	R0,KVERNO,KD		:store VERNO and NETID
	L	R0,VHOST0,SD
	ST	R0,KHOST0,KD		:store neighbor's HOST0
	LB	R0,VLINE,SD
	STB	R0,KLINE,KD		:store neighbor's LINE
	JAL	R8,ATTWSZ		:check for WSIZ matchdown	###wjl
	l	r1,vkattr,sd		:get link attributes
	st	r1,lkattr,kd		:save into link descriptor
	lb	r8,lknm,kd		:get link number
       if	aplybp
	thi	r1,lk.rab		:neighbor request active BP?
	jefs	attrab			:no, don't set
	sbt	r8,XACTBP		:and this link sends active BP
attrab	thi	r1,lk.sab		:did other end respond to our request?
	jefs	attsab			:no, don't set
	sbt	r8,VACTBP		:and this link gets no active BP
       ei	:aplybp
attsab	thi	r1,lk.shk		:does neighbor (naima) not want skrinks
	jefs	attl08
	sbt	r8,noshrk		:and this link gets no shrinks

:	CLEAR LINE STATISTICS - R7 has number of lines on the link
ATTL08	JAL	R8,ATTCLR		:R7 required for setup		###wjl
	TBT	LN,XRSTBT		:Expanded reset Header?	
	JNFS	ATTL09			:neighbor version entered above
	TS	KVERNO,KD		:ASSUME NEIGHBOR VERSION NUMBER NOT KNOWN
ATTL09	ST	KD,KDLN,LN,LN		:SET LINK PTR FOR LINE
	ST	KD,KDSVLN,LN,LN		:SAVE IT IN CASE IT RESETS
	LHL	R1,NGSVLN,LN		:get neighbor number
	JAL	R8,ATTMCL		:REMOVE NEIGHBOR NUMBER FROM MRESET
	LHI	R1,8000,R1		:SAVE THE CURRENT NEIGHBOR NUMBER
	STH	R1,NGSVLN,LN

	STM	R0,SIOREG		:save registers 		###sdw
	JAL	R7,BSIOST		:setup line rotation for each line##sdw
	LM	R0,SIOREG		:restore registers      	###sdw
:	INITIALIZE CONFSG SO WE CAN DETECT WHEN A LINE GOES LNCKTM TIMES
:	OF 4-SECONDS GAPS WITH NO GOOD RECORD.		###LH
	LHI	R1,LNCKTM
	STH	R1,CONFSG,LN	

	JAL	R8,ATTACT		:mark line as active		###wjl
	JAL	R10,KSPEED		:DETERMINE THE SPEED OF THIS LINK
:	the following allows tymfile setting of retrans delay if set or
:	uses the line speed if not specified
	lb	r10,lknm,kd
	lhl	r10,lnkrtr,r10,r10	:pick off desired line tracing
	jnfs	attl30			:use line speed (the default)
	lhl	r10,baudrt,ln
attl30	lhl	r10,rtrwat,r10,r10	:pacing according to line speed
	sth	r10,rtrdel,ln		:and save for use in ccwrtr

:	NOTIFY SUPERVISOR OF NEW LINE/LINK
	SIS	R7,1			:IS THIS A NEW LINK?
	JGFS	ATLNR1			:NO, MORE THAN 1 LINE, SUBSEQ LN ATTACH
	LHI	R4,13E0			:MESSAGE TYPE FOR NEW LINK REPORT
	LB	R0,KSPD,KD		:INCLUDE LINK SPEED IN REPORT	###OAS
	NHI	R0,001F			:MASK OFF SATELLITE BITS	###OAS
	AR	R4,R0			:				###OAS
	J	ATLNR2

:	report new link to supe
ATLNR1	LHI	R4,13C0			:MESSAGE TYPE FOR NEW LINE REPORT
	LHL	R0,BAUDRT,LN		:CHECK IF LINE IS HIGH SPEED	###OAS
	TBT	KN,KNCNSP		:IS SPEED SPECIFIED IN TYMFILE?
	JEFS	ATLNR9			:NO, REPORT CALCULATED SPEED
	LB	R0,KSPD,KD		:HIGH SPD AND SPECIFIED, USE LINK SPEED
	NHI	R0,1F			:ISOLATE SPEED BITS
ATLNR9	AR	R4,R0			:INCLUDE IN REPORT
ATLNR2	JAL	R10,SUP13,,		:NOTIFY SUPERVISOR OF NEW LINE/LINK

:	THE 5TH AND 6TH HALFWORDS IN A RESET FROM THE NEIGHBOR MAY HAVE
:	THE NEIGHBOR'S VERSION NUMBER AND THE VERSION NUMBER COMPLEMENT.
:	THE COMPLEMENT IS TESTED. If -1, the Version is stored in the KVERNO
:	field of the Link Descriptor. If not, FFFF was stored above. THIS MAY
:	OCCUR BECAUSE VERSIONS OF NODE CODE PRIOR TO 5.00 DID NOT
:	PROVIDE THEIR VERSION NUMBER.
	LH	R0,VRSTP+4,SD	:GET POTENTIAL VERSION NUMBER FROM RESET
	JEFS	ATLN9A		:0 NOT LEGAL VERSION, DON'T LET SPACING FOOL US
	LH	R1,VRSTP+6,SD	:VERSION NUMBER COMPLEMENT
	XR	R1,R0		:VERIFY THAT VERSION WAS PRESENT IN RESET
	AIS	R1,1
	JNFS	ATLN9A		:NOPE - OLD VERSION IN NEIGHBOR
	STH	R0,KVERNO,KD	:YES - SAVE VERSION NUMBER IN LINK DESCRIPTOR
ATLN9A	lh	r0,kverno,kd	:if verno is -1 then it must be an atc
	jgfs	attl64
	lb	r10,lknm,kd
	lhl	r10,lnkrtr,r10,r10	:pick off desired line tracing
	jnfs	attl64			:if specified then don't auto config
	lhl	r10,rtrwat+2		:get big pacing value for atcs
	sth	r10,rtrdel,ln		:and save for use in ccwrtr
attl64
:	SET ACTIVE OUTPUT STATE 
	LHI	R0,SIOTT-SEG1
	STH	R0,SIOTST,LN

	IF	TSTSZE
	JAL	R10,ATTTST		:see if we're tracing this link	###wjl
	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER * 2
	SLLS	R0,0F			:HI-ORDER HW NOW HAS LINE NUMBER
	AH	R0,NDID,KD		:INCLUDE NEIGHBOR NUMBER
	ST	R0,CRYSBF		:SAVE FOR CRYPTO
	LB	R0,NLAT,KD		:NO. OF LINES ON LINK
	JAL	R8,CRYPTO		:SEND CRYPTOGRAM FOR
	HC	CRYE16			:	NEW LINE ATTACHED
	JAL	R8,GMTLIN		:STORE TIME

       if	bigcon
	stm	r0,sioreg
	clhi    ln,sbase
	jlfs    atlnr7
	lhi	r6,msbase,ln
	slls    r6,3
	ai	r6,siostt
	lhi	r0,-10  		:tell sioiz0  that this is dma init
	sth	r0,8,r6
	jal	r10,sioiz0
atlnr7
	lm	r0,sioreg
       ei 	:bigcon


:	TEST FOR SUBSEQUENT LINE ATTACH OR NEW LINK
	LB	R7,NLAT,KD		:GET NUMBER OF LINES ON LINK
	SIS	R7,1			:IF ONE LINE, THIS IS A NEW LINK
	JEFS	ATTLNK			:NEW LINK - SET IT UP

	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
	J	attlnx

:	NEW LINK HAS BEEN CREATED, INITIALIZE IT
ATTLNK	LH	R0,NDID,KD
	LR	R6,R0
	STH	R0,CHNMPD,KN,KN		:SET UP CHANNEL MAP FOR TRACE LOGIC
	LHI	R0,WBORIM		:TYM-II - SET EXPECTED BORI
	CHI	R6,MACHNM
	JGFS	ATTL20			:.+6
	LHI	R0,WBORIS
ATTL20	STB	R0,BORI,KD
	LHI	R0,0FF			:SET ACK MASK
	STH	R0,AMSK,KD

	LCS	R0,1			:INIT OTHER VARIABLES
	ST	R0,LRT,KD		:SET LRT,LAS,LRM,LAR TO -1
	ST	R0,LRM,KD
	LHL	R2,OSEC,KD		:SET NRXM=OSEC
	STH	R2,NRMK,KD		:SO WILL NEXT REC MADE
	LB	R1,WSIZ,KD		:SET REC #'S TO -WSIZ TO -1
	JAL	R9,CLRCHN
	LHL	R2,ISEC,KD
	STH	R2,NRTR,KD
	JAL	R9,CLRCHN
	JAL	R8,GMTLIN		:SET TIME

	JAL	R10,NEWLNK		:SPIDER WILL COMPLETE INITIALIZING
	LR	R2,LN			:LN MAY BE USED BY LNKCON##AL
	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
	LR	LN,R2			:GET LN BACK##AL

	J	attlnx

:	Reset received for potential new link, but neighbor
:	has different NETID.  Add neighbor (in R1) to list of neighbors,
:	report to SUP Log, make CRYPTO Log entry, and remove neighbor number
:	from list of neighbors	currently engaged in reset sequence (MRESET).

ATTNID	CLH	R1,BNETID,LN		:same as before?
	JER	R10			:yes, make no report
	STH	R1,BNETID,LN		:save neighbor with error
	OHI	R0,8000			:avoid escapes
	STH	R0,SUPMBF+4		:include neighbor's NETID in HW2
	LR	R1,LN			:line number*2
	SRHLS	R1,1			:line number
	OHI	R1,8000
	STH	R1,SUPMBF+2		:include line number in HW1
	LHI	R0,NR.NID
	STH	R0,SUPMBF		:indicate NETID mismatch in HW0
:	R10 is our link register and we are letting supe12 return for us#sdw
	J	SUP12,, 		:send message to Sup and CRYPTO Logs

::*********************************************************************
::
::	SUBROUTINE:	ATTADD:
::	FUNCTION:	ADD NEIGHBOR NUMBER TO MRESET, (LIST OF NEIGHBORS
::			CURRENTLY ENGAGED IN RESET SEQUENCE)
::	CALLING SEQ:	JAL	R8,ATTADD
::	INPUT:		R1 = NEIGHBOR NUMBER
::
::*********************************************************************

:	WE'RE MASTER. SEE IF ANOTHER RESET TO THIS NEIGHBOR IS IN PROGRESS
ATTADD	LHI	R5,-MRESTZ*2		:MRESET INDEX
ATTA1	CLH	R1,MRESET+MRESTZ*2,R5	:
	JE	attlnx			:YES, DONT BEGIN ANOTHER RESET SEQUENCE
	AIS	R5,2			:
	JLBS	ATTA1			:SCAN ALL ENTRIES IN MRESET

:	NO RESET SEQUENCE CURRENTLY IN PROGRESS.  STORE NEIGHBOR NUMBER
:	IN MRESET TO PREVENT MULTIPLE SIMULTANEOUS RESET SEQUENCES TO
:	SAME NEIGHBOR.
	LHI	R5,-MRESTZ*2		:MRESET INDEX
ATTA2	LH	R6,MRESET+MRESTZ*2,R5	:SEARCH FOR ZERO ENTRY
	JEFS	ATTA3			:GOT ONE
	AIS	R5,2			:
	JLBS	ATTA2			:SCAN ALL ENTRIES IN MRESET
	J	attlnx			:MRESET TABLE FULL. TRY AGAIN LATER...

ATTA3	STH	R1,MRESET+MRESTZ*2,R5	:STORE NEIGHBOR NUMBER IN MRESET
	JR	R8			:return				###wjl

::*********************************************************************
::
::	SUBROUTINE:	ATTMCL:
::	FUNCTION:	REMOVE NEIGHBOR NUMBER FROM MRESET, (LIST OF
::			NEIGHBORS CURRENTLY ENGAGED IN RESET SEQUENCE)
::	CALLING SEQ:	JAL	R8,ATTMCL
::	INPUT:		R1  = NEIGHBOR NUMBER
::
::*********************************************************************

ATTMCL	LHI	R5,-MRESTZ*2		:MRESET INDEX
ATTMC1	CLH	R1,MRESET+MRESTZ*2,R5
	JEFS	ATTMC2			:NEIGHBOR NUMBER MATCH
	AIS	R5,2
	JLBS	ATTMC1			:SCAN ALL ENTRIES IN MRESET
	JR	R8			:NEIGHBOR NUMBER NOT IN LIST
ATTMC2	LIS	R0,0
	STH	R0,MRESET+MRESTZ*2,R5	:ZERO ENTRY
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	ATTNR:
::	FUNCTION:	MAKE NODE REPORT TO SUPERVISOR LOG
::	CALLING SEQ:	JAL	R7,ATTNR
::
::*********************************************************************

ATTNR	STH	R0,SUPMBF		:INDICATE TYPE OF NODE REPORT
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER FROM RESET IN HW2
	LR	R0,LN
	SRLS	R0,1
	OHI	R0,8080			:OR'ING 80'S MEANS NO ESCAPES NECESSARY
	STH	R0,SUPMBF+4		:LINE NUMBER IN HW3
	JAL	R10,SUP12,,		:SEND MESSAGE TO SUPERVISOR LOG
	JR	R7			:				###wjl


::*********************************************************************
::
::	SUBROUTINE:	ATTWSZ:
::	FUNCTION:	DETERMINE IF WINDOW SIZE MATCHDOWN IS REQUIRED
::			if it is, call MCHDWN
::	CALLING SEQ:	JAL	R8,ATTWSZ
::	DESTROYED:	R1 - R4 and R9   R0 and R6 as well
::*********************************************************************

ATTWSZ	LB	R1,VWSIZ,SD		:get received window size
	CLB	R1,XWSIZ,SD		:compare with transmitted window size
	JGER	R8			:VWSIZ is > or = XWSIZ, no problem

	JAL	R9,MCHDWN		:R2 stored in RLNK of last buffer
	STB	R1,WSIZ,KD		:set window size for this link
	LHI	R0,NR.WSZ		:send Node Report to Sup log
	STH	R0,SUPMBF		:indicate WSIZ match down in HW0
	LR	R0,LN			:line number * 2
	SRLS	R0,1			:line number
	OHI	R0,8000			:avoid escapes
	STH	R0,SUPMBF+2		:include line number in HW1
	OHI	R1,8000			:
	STH	R1,SUPMBF+4		:include neighbor's WSIZ in HW2
	ST	R8,ATTSAV		:save return
	JAL	R10,SUP12,,		:send message to Sup and CRYPTO Logs
	L	R8,ATTSAV		:restore return
	JR	R8			:

::*********************************************************************
::
::	SUBROUTINE:	ATTCLR:
::	FUNCTION:	CLEAR LINE STATISTCS, INCREMENT NUMBER OF LINES
::			ATTACHED TO LINK, INDICATE LINK NOT FROZEN
::	CALLING SEQ:	JAL	R8,ATTCLR
::	INPUT:		R7 = NUMBER OF LINES ATTACHED
::			LN = LINE NUMBER * 2
::			KD = LINK DESCRIPTOR
::
::*********************************************************************

ATTCLR	LIS	R0,0			:CLEAR LINE STATISTICS
	STH	R0,LINERR,LN
	STH	R0,BADACK,LN
	STH	R0,BADRCN,LN
	STH	R0,BADCSM,LN
	STH	R0,RCRXMT,LN
	STH	R0,RCRCVD,LN
	STH	R0,LCROSS,LN
	STH	R0,RCTRNS,LN
	sth	r0,kl.rrf,ln
	STH	R0,TRRXMT,LN
	STH	R0,KL.TRF,LN
	AIS	R7,1			:INCREMENT
	STB	R7,NLAT,KD		:NUMBER OF ATTACHED LINES THIS LINK
	STH	R0,KFROZN,KD		:INDICATE LINK NOT FROZEN
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	ATTACT:
::	FUNCTION:	MARK LINE AS ACTIVE
::	CALLING SEQ:	JAL	R8,ATTACT
::
::***********************************************************************

ATTACT	LR	R1,LN
	SRLS	R1,1			:GET ACTUAL LINE NUMBER
	LIS	R0,0
	STB 	R0,DREASN,R1
	SBT	R1,ALINES		:LINE ACTIVE NOW
	RBT	R1,LINATT
	SBT	R1,INHRST		:PREVENT DETACHMENT BY STRAY RESETS
	SBT	R1,LNGREC		:PREVENT IMMEDIATE DETACH BY LNCHCK
	if	chboot
	rbt	r1,cnbtya		:neighbor cannot be in boot
	ei	:chboot
	SBT	KN,LKGREC
	JR	R8

::*********************************************************************
::	SUBROUTINE:	ATTTST:
::	FUNCTION:	DETERMINE IF TRACING ON LINK
::	CALLING SEQ:	JAL	R10,ATTTST
::
::*********************************************************************
ATTTST	
      IF	TSTSZE
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R8,TSLINK		:	SEE IF WE'RE TRACING THIS LINK
	JNR	R10			:NO - CONTINUE
	JAL	R8,TSBMRK		:YES - SET UP NEW EVENT ENTRY
	LHI	R8,TS.ATT
	STB	R8,TSBTBL,R7		:STORE ENTRY TYPE
	LB	R8,NLAT,KD
	STH	R8,TSBTBL+2,R7		:SAVE NUMBER OF LINES CURRENTLY ON LINK
      EI	:TSTSZE
	JR	R10

	SUBTTL	LINKER (DETLIN - Line detach logic)

::*********************************************************************
::
::	SUB-PROCESS:	DETLIN:
::	FUNCTION:	Detaches lines placed in limbo after a valid
::	reset is detected.  Scheduled by LINKER.
::	CALLING SEQ:	JAL	R10,DETLIN
::	CALLS:		JAL	R9,RSTSTR
::			JAL	R10,KSPEED
::			JAL	R8,CRYPTO
::			JAL	R8,GMTLIN
::			JAL	R10,TRLINK
::			JAL	R11,LNKCON
::	RETURNS:	Jr	r10
::
::*********************************************************************

DETLIN	st	r10,detsav
detli0	lhi	ln,(((nlines-1)/10)*10)!0f
	lhi	r0,2*((nlines-1)/10)+lindet
	lr	r1,r0
	arand	r0,ln
	jfs	detli1
	l	r10,detsav
	jr	r10

detli1	rbt	ln,lindet		:mark line as serviced
	AR	LN,LN

	JAL	R9,RSTSTR		:PUT LINE IN RESET MODE
	L	KD,KDSVLN,LN,LN		:RETRIEVE PTR TO FORMER LINK
	LIS	R0,0			:RESET HI-ORDER BIT OF THIS FOR PROBE
	RBT	R0,NGSVLN,LN
	JAL	R7,BSIOST		:setup line rotation for each line##sdw

	LB	R7,NLAT,KD		:DECREMENT ATTACHED-LINE COUNT
	SIS	R7,1			:R7=0 IF LINK MUST BE TORN
	STB	R7,NLAT,KD
	JAL	R10,KSPEED		:RECOMPUTE LINK SPEED
	LR	R4,LN
	SRLS	R4,1			:GET ACTUAL LINE NUMBER IN R4
	LB	R4,DREASN,R4		:GET REASON FOR OUTAGE IN R4
	LR	R7,R7			:ANY LINES LEFT FOR THIS LINK?
	JNFS	DETLN2			:YES - LINK NOT OUT, REPORT LINE DETACH
	AHI	R4,1380			:REPORT LINK OUT TO SUPERVISOR
	LIS	R0,0			:	AND INSURE LINK NOT MARKED AS
	STH	R0,KFROZN,KD		:	FROZEN
	JFS	DETLN3
DETLN2	AHI	R4,13A0			:REPORT LINE DETACH TO SUPERVISOR
DETLN3	JAL	R10,SUP13,,		:SEND MSG TO SUP
	LR	R1,LN
	SRLS	R1,1			:GET ACTUAL LINE NUMBER IN R1
	if	chboot
	sbt	r1,cnbtgo		:see if neighbor went to boot
	ei	:chboot
	LB	R0,DREASN,R1		:TELL XRAY, REASON ON LEFT
	EXHR	R1,R1			:LINE NUMBER IN HO HW
	LHL	R8,NGSVLN,LN		:NEIGHBOR NUMBER
	OR	R1,R8			:COMBINE AND
	ST	R1,CRYSBF		: SAVE FOR CRYPTO
	JAL	R8,CRYPTO
	HC	CRYE04			:LINE DETACHED
	JAL	R8,GMTLIN		:SET TIME
	LR	R7,R7
	JNfs	DETLN5			:NLAT > 0, LINK NOT GOING DOWN
	JAL	R10,TRLINK		:NON STR LINE TEAR LINK ##AL

DETLN5	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
	jal	r0,exyld		:maybe yield
	J	detli0

	SUBTTL	LINKER (Attach/Detach subroutines)

::*********************************************************************
::
::	SUBROUTINE: BSIOST
::	FUNCTION: setup SIOROR/SIOROT for multiline sio links
::      CALLING SEQ: link on R4
::	INPUT: KD of link gaining/losing line, uses NGSVLN
::	OUTPUT: SIOROR/SIOROT for multiline links
::								###sdw
::*********************************************************************

:	setup list of lines
:	search all lines and those that have the same neighor as this link
:	are put in the list.  The list pointer is set to 0 to prevent a
:	list shrinkage from leaving the pointer out of range.
BSIOST	LIS	R4,0			:check all lines
	LCS	R3,1			:found no other lines yet
	LIS	R2,0			:pointer within line list
BSIOS0  LH	R1,NGSVLN,R4,
	JGFS    BSIOS2  		:high bit set if link up
	NHI	R1,7FFF 		:make it into neighbor #
	CLH	R1,NDID,KD		:on our link?
	JEFS    BSIOS3  		:yes
BSIOS2  AIS	R4,2
	CLHI	R4,NLINES*2		:all lines
	JLBS    BSIOS0
	JR	R7			:checked all lines

BSIOS3  LR	R3,R3			:first line for link?
	JGEFS   BSIOS4  		:jump if not
	LR	R3,KD			:get link descriptor
	STB	R2,SIOROR,KD		:point to first line in list
BSIOS4  STB	R4,SIOROT,KD,R2 	:put into list
	AIS	R2,1
	J       BSIOS2


::*********************************************************************
::
::	SUBROUTINE:	GMTLIN:
::	FUNCTION:	Set time of line attach or detach
::	CALLING SEQ:	JAL	R8,GMTLIN
::	INPUT:		LN  =Line number*2
::	CALLS:		JAL	R9,GMTCAL
::
::*********************************************************************

GMTLIN	JAL	R9,GMTCAL,,		:GET CURRENT TIME
	L	R0,GMTNOW		:AND
	ST	R0,LINTIM,LN,LN		:STORE IT
	JR	R8			:RETURN TO THE SOURCE



::*********************************************************************
::
::	SUBROUTINE:	RSTSTR:/RSSCLP:
::	FUNCTION:	Forces line to transmit stream of resets with ping-pong
::	count set to 0.  This is the normal state of lines that have been
::	detached but are not yet in process of identification.
::	Entry point RSTSTR is used for T-II reset initiation.  Entry point
::	RSSCLP is used for SCLP reset initiation.
::	CALLING SEQ:	JAL	R9,RSTSTR
::	PRESERVED:	R11= NETID (preserved for IZLNKR)
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R6,R7,R8,R10
::	CALLS:		JAL	R7,RSTORE
::			JAL	R10,SIOIZ0
::			JAL	R0,SVCE32
::			JAL	R0,SVCE30
::
::*********************************************************************
:	ENTRY POINT FOR T-II RESET INITIATION
RSTSTR 
	LHI	R0,TXRSHD		:get T-II initial reset header	###wjl
	STH	R0,RSRSHD		:store it for RSTORE		###wjl
RSTS02	L	SD,SDLN,LN,LN		:PTR TO RESET BUFF
	LCS	R0,2			:SET RESET MODE FLAG
	ST	R0,KDLN,LN,LN
RSTSA2	LR	R6,SD			:RSTORE needs Reset Buff Ptr in R6
	JAL	R7,RSTORE		:store Xmit Reset Pattern

	IF	SILINS
	LR	R1,LN
	SRLS	R1,1			:actual Line Number 
	CLHI	R1,NLINES-SILINS-1	:SIO Line?
	JG	RSTSIO			:yes - jump
	EI	:SILINS

	if	sylins
:	SET UP FOR SYNC SVCs
	LR	R1,LN			:set R1=Line Number
	SRLS	R1,1

:	CONNECT SYNC LINE I/O, AND RAISE DTR AND RTS SIGNALS.
					:GET LINE NUMBER * 2
	L	R2,SIOBLA,LN,LN		:R2 NOW POINTS TO ENTRY FOR THIS LINE
	LIS	R8,4			:COMMAND TO RAISE RTS
	STH	R8,0,R2
	LIS	R8,9			:COMMAND TO RAISE DTR
	STH	R8,8,R2
	LIS	R8,0			:COMMAND TO STOP OUTPUTTING
	STH	R8,10,R2
:		(POINTED TO BY R2).  R1 = LOGICAL UNIT NUMBER (LINE NUMBER).
	SVC	IO,20+R1		:PROCESS COMMANDS IN ROTOR
	JAL	R0,SVCE32		:ERROR, CRASH 

:	while the sync raise signals svcs are supposed to complete
:	immediately, give them a moment (until foreground runs)
	LHI	R0,SIORR-SEG1		:go t continous reset state
	STH	R0,SIOTSV,LN		:after initialization completes
	LHI	R0,SYNRWT-SEG1  	:setup sync wait state
	STH	R0,SIOTST,LN

	LHL	R2,SVBDIS,LN	:GET THIS LINE'S DISPLACEMENT INTO SYNC INPUT
	LA	R2,SVNTIP,R2,	: BUFFERS AND ADD TO BUFFER POOL START ADDRESS
	LHI	R3,SVNBSZ		:SYNC INPUT BUFFER SIZE
	SVC	IO,01			:CONNECT SYNC INPUT
	JAL	R0,SVCE30		:ERROR, CRASH
	J	RSTST2			:SKIP FOR SYNC LINE
	ei	:sylins

:	PROCESS SIO LINE
	IF	SILINS
RSTSIO	LHI	R0,SIORR-SEG1
	STH	R0,SIOTST,LN		:for SIOIZ0 to save while it waits
	LR	R2,LN
	SHI	R2,(NLINES-SILINS)*2
	SLLS	R2,3			:COMPUTE RELATIVE SIO LINE NUMBER * 10
	LCS	R0,3			:INDICATE SIO LINE BEING RE-INITIALIZED
	STH	R0,SIOSTT+8,R2,		: DUE TO LINE GOING TO RESET STATE
	JAL	R10,SIOIZ0		:INITIALIZE SIO LINE
	L	SD,SDLN,LN,LN		:RESTORE POINTER TO RESET BUFFER
	LIS	R0,0
	STH	R0,BAUDRT,LN		:CLEAR LINESPEED FOR DETECTING
				:CALCULATED MAXIMUM VALUE OVER 16d RESETS###OAS

RSTSDD	L	R6,SIORSP,LN,LN		:SIO RESET POINTER
	lhi	r7,7c
	sth	r7,0,r6
	SHI	R6,VSDSZ-2		:-offset for received Pattern Size
	JAL	R7,RSTORE		:+HW storage for SIO Reset Buffer Size
	LR	R1,LN
	SRLS	R1,1			:restore R1 = actual Line Number
	EI	:SILINS

RSTST2	RBT	R1,ALINES		:MARK THE LINE AS NO LONGER ACTIVE
	RBT	R1,INHRST		:MAKE SURE RESETS SEEN
	RBT	R1,LINATT		:END ATTACHING PROCESS
	LIS	R0,0			:RESET THE RESET COUNT
	STH	R0,RSCNT,SD
	STH	R0,RSTIM,SD
	JR	R9

SVCE32	CRASH.(.SV32C,R5)
SVCE30	CRASH.(.SV30C,R5)

::*********************************************************************
::
::	SUBROUTINE:	RSTORE:
::	FUNCTION:	Stores Reset Pattern for Transmit
::	CALLING SEQ:	JAL	R7,RSTORE
::	INPUT:		R6 =Pointer to reset buffer
::			RSRSHD must be setup with either T-II or SCLP
::			reset header prior to call
::	DESTROYED:	R0, R1, R2, R3
::	CALLS:		JAL	R5,CCKSUM
::
::*********************************************************************

RSTORE	LHL	R0,RSRSHD		:set the initial pattern	###wjl
	STH	R0,XRSTP,R6		:store Expanded Reset Header
	LI	R0,MACHNM
	ST	R0,XNDID,R6		:store Machine Number
	LHI	R0,(VERSION&0FFF)
	STH	R0,XVERNO,R6		:store VERSION
	LHL	R0,LNETID,LN
	STH	R0,XNETID,R6		:store NETID
	LHI	R0,SUBNET
	STH	R0,XSUBNT,R6		:store SUBNET
	LIS	R0,8			:ATTLIN will fill in WSIZ
	STB	R0,XWSIZ,R6		:for TIILNK during ping-pong
	LR	R2,LN			:Line Number*2
	SRLS	R2,1			:actual Line Number
	STB	R2,XLINE,R6		:store Line Number
	LI	R0,HST0
	ST	R0,XHOST0,R6		:store Kernel Host Number
	LB	R0,RREASN,R2		:**Reason for Reset to be
	STB	R0,XRSRSN,R6		:implemented later**
	LIS	R0,0			:ATTLIN will fill in TIILNK
	STB	R0,XKSPD,R6		:Capabilities during ping-pong
	ST	R0,XKATTR,R6		:implemented later**
	LI	R0,DIALUP		:**Dial-up Number to be
	ST	R0,XDIAL,R6		:implemented later**
	JAL	R5,CCKSUM		:calculate and store checksum
	JR	R7


::*********************************************************************
::
::	SUBROUTINE:	CCKSUM:
::	FUNCTION:	Calculate and store checksum for reset pattern
::	CALLING SEQ:	JAL	R5,CCKSUM
::	INPUT:		R6 = Pointer to reset buffer
::	DESTROYED:	R0, R1, R2, R3
::
::*********************************************************************


CCKSUM	LI	R0,-VSDSZ		:negative byte count in R0
	LA	R1,XRSTP,R6		: starting address
	LIS	R2,0			: clear accumulators
	LIS	R3,0			: for CKSUM instruction
	CKSUM	R2,R1			:calculate checksum
	STH	R2,XCKSUM,R6		:store vertical checksum
	STH	R3,XCKSUM+2,R6		:store diagonal checksum
	JR	R5

::*********************************************************************
::
::	SUBROUTINE:	KSPEED:
::	FUNCTION:	Computes the speed of a given link from the
::			speed of its attached lines.
::	CALLING SEQ:	JAL	R10,KSPEED
::
::*********************************************************************

:	THIS ROUTINE REWRITTEN TO CORRECT A BUG FROM VERSION 4.	###jhl 4/83
:	LOGIC CHANGED TO AVOID MISCONFIGURATION  		###OAS 2/83

KSPEED	LB	R1,LKNM,KD		:GET LINK NUMBER
	TBT	R1,KNCNSP		:WAS LINK SPD SPEC IN TYMFILE?
	Jefs	KSPEE0			:YES, USE IT
	lb	r3,knrspd,r1		:get 'real' speed (beyond MS)
	stb	r3,kspdrr,kd		:and save 'real' link speed
	LB	R0,KNSAT,R1		:GET speed/sat of tiilnk
	j	kspee5

:	SPEED NOT SPECIFIED IN TYMFILE.  USE THE CALCULATED LINK SPEED.
KSPEE0	LIS	R0,0			:INITIALIZE CUMULATIVE SPEED COUNTER
	LIS	R4,0			:our 'real' link speed counter
	LHI	R1,2*NLINES-2		:COUNT BACKWARDS THROUGH THE LINES
KSPEE1	L	R3,KDLN,R1,R1		:IS THE LINE ATTACHED TO THIS LINK?
	CR	R3,KD
	JNFS	KSPEE3			:IF NOT, GET PREVIOUS LINE
	AH	R0,BAUDRT,R1		:ELSE ADD IN THE LINE SPEED
	ah	r4,baudrr,r1		:add in 'real' line speed
KSPEE3	SIS	R1,2			:STEP BACK TO PREVIOUS LINE
	JGEBS	KSPEE1			:LOOP AS LONG AS THERE ARE LINES

	stb	r4,kspdrr,kd		:and save 'real' link speed
	CLHI	R0,1F			:HAS ACCUMULATED SPEED OVERFLOWED?
	JLFS	KSPEE4			:NO--IT'S OK
	LHI	R0,1F			:ELSE SET IT TO MAX
KSPEE4	LB	R1,LKNM,KD		:GET THE LINK NUMBER SET UP

:	RESTORE PROPER BITS WITH RESPECT TO SAT AND TI WS 8.
	LB	R3,KNSAT,R1		:GET KSAT<LINK #>
	NHI	R3,0E0			:STRIP SPEED BITS
	OR	R0,R3			:MIX FLAGS AND SPEED
KSPEE5	STB	R0,KSPD,KD		:STORE IN LINK DESCRIPTOR
:	have set speeds.  Now set index so mtrfic can do quick lookup of
:	all speeds.  values here must match in kspcpf table in xray
	lb	r4,kspdrr,kd
	clhi	r4,16			:first part of table is normal
	jlefs	kspee8
	lis	r3,0			:index into the special values
kspee6	clh	r4,kspeet,r3,r3		:found our closest speed yet?
	jlefs	kspee7			:yes, set up then save index
	ais	r3,1			:check next line speed
	jbs	kspee6
kspee7	lhi	r4,16,r3		:(the 22d in kspcpf)
kspee8	stb	r4,kspdmt,kd		:save index
	JR	R10

:  line speeds:	56 64 72 ms 128 192 256 (and beyond)
kspeet	hc	17,1c,1e,2a,42,5c,7fff
::*********************************************************************
::
::	SUBROUTINE:	LSPEEZ:
::	FUNCTION:	Initializes input pointers for line speed calculations
::	CALLING SEQ:	JAL	R8,LSPEEZ
::	INPUT:		R13 = Bit array for sync lines requesting line
::				speed computation
::
::*********************************************************************

	if	sylins
LSPEEZ	JFFO	R13,LSPEZ1		:YIELDS LINE NO. IN R14 (LN)
	JR	R8			:ALL DONE
LSPEZ1	SLLS	LN,1			:2 * LINE NO.
	LHL	R3,SVBDIS,LN		:COMPUTE <POSITION>
	LH	R3,SVNTIP,R3,
	STH	R3,LNRPOS,LN		:UPDATE POSITION
	X	R13,WMSK,LN,LN		:TURN OFF THAT BIT
	J	LSPEEZ			:DO NEXT ONE
	ei	:sylins

::*********************************************************************
::
::	SUBROUTINE:	LSPEED:
::	FUNCTION:	Computes speed of line from the rate at which
::			data is being received at the interrupt buffers.
::	CALLING SEQ:	JAL	R8,LSPEED
::	INPUT:		R13 = bit array of lines requesting speed calculation
::			R4  =  FASTC interval to measure over
::
::*********************************************************************

	if	sylins
LSPEED	JFFO	R13,LSPEE1		:YIELDS LINE NO. IN R14 (LN)
	ST	R13,LINSPD		:RESET LINE SPEED REQUEST BITS
	JR	R8			:ALL DONE
LSPEE1	SLLS	LN,1			:2 * LINE NO.
	LHL	R3,SVBDIS,LN		:COMPUTE <DELTA POSITION>
	LH	R2,SVNTIP,R3,
	LH	R3,LNRPOS,LN
	STH	R2,LNRPOS,LN		:UPDATE POSITION
	SR	R2,R3
	JGFS	LSPEE3
	AHI	R2,SVNBSZ
LSPEE3	SLLS	R2,2			:TIMES 4
	DHR	R2,R4
	CLHI	R3,0F			:DON'T LET IT OVERFLOW
	JLEFS	LSPEE2			:O.K.
	LIS	R3,0F			:MAX VALUE...
LSPEE2	LB	R3,LSPEET,R3
	STH	R3,BAUDRT,LN		:save calculated line speed
	STH	R3,BAUDRR,LN		:is also 'real' line speed
	X	R13,WMSK,LN,LN		:RESET THAT BIT
	J	LSPEED			:DO NEXT ONE
	ei	:sylins

:		2.4   4.8  7.2 9.6  14.4  19.2
LSPEET	BC	1,1,1,2,2,2,3,4,4,4,6,6,6,8,8,8	:ADD 14.4 		###OAS

::*********************************************************************
::
::	SUBROUTINE:	LNKCON:
::	FUNCTION:	Consistency check for line and link fields.
::	CALLING SEQ:	JAL	R11,LNKCON
::	INPUT:		KD = Expects valid linK Descriptor
::	DESTROYED:	R12, R13, R14 (LN)
::
::*********************************************************************

:	ALL LINE FIELDS ARE EXAMINED FOR INDICATIONS OF BEING ATTACHED
:	TO THE LINK LAST OPERATED ON (THE CALLING ROUTINE PASSES A
:	VALID LINK DESCRIPTOR INDEX).  THE LINK DESCRIPTOR VALUES ARE
:	COMPARED TO THE	CUMULATIVE LINE FIELD VALUES, AND THE NODE IS
:	CRASHED IF AN INCONSISTENCY IS DISCOVERED.

	IF	DB.TSN

LNKCON	LIS	R12,0		:R12 COUNTS THE NUMBER OF LINES ASSOCIATED
				:	WITH THIS LINK.
	LHI	LN,(NLINES-1)*2		:SCAN ALL LINES
LNKC10	LH	R13,NGSVLN,LN		:GET NEIGHBOR NUMBER FOR LINE
	JGE	LNKC20			:HI-ORDER BIT SHOULD BE SET FOR
	NHI	R13,7FFF		: ATTACHED LINE
	CLH	R13,NDID,KD		:LINE NEIGHBOR # = LINK NEIGHBOR #?
	JN	LNKC20			:NO - THIS LINE ATTACHED TO DIFFERENT
					:  LINK
	LR	R13,LN
	SRLS	R13,1			:GET ACTUAL LINE NUMBER
	TBT	R13,ALINES		:IS LINE MARKED AS ACTIVE?
	JE	OP1663			:NO - IT SHOULD BE ACTIVE

	SLLS	LN,1
	L	R13,KDSVLN,LN		:COMPARE KD TO THIS LINE'S KDSVLN
	SRLS	LN,1
	CLR	R13,KD			:EQUAL?
	JN	OP1463			:NO - CRASH...

	AIS	R12,1			:INCREMENT COUNT OF LINES ATTACHED TO
					: LINK
LNKC20	SIS	LN,2			:CHECK ALL LINES
	JGE	LNKC10

:	ALL LINES SCANNED. NOW VERIFY THAT TOTAL NUMBER OF LINES
:	DISCOVERED EQUALS 'NLAT' LINK COUNT, AND THAT LINK IS ACTIVE IF
:	NLAT > 0.  
	LB	R13,NLAT,KD		:LINK FIELD FOR # OF LINES ATTACHED
	CLR	R13,R12			:COMPARE TO SUM OF LINE FIELDS FOR LINK
	JN	OP1863			:NOT EQUAL - CRASH

	LB	R13,LKNM,KD		:GET LINK NUMBER
	TBT	R13,ALINKS		:IS LINK ACTIVE?
	JN	LNKC30			:YES
	LR	R12,R12			:NO - NUMBER OF LINES SHOULD EQUAL 0
	JER	R11			:O.K.
	TBT	R13,BORZAP		:DON'T CRASH IF LINK BORI-ZAPPED...
	JeR	R11
	CRASH.(.LKER0,R0)
LNKC30	LR	R12,R12			:ACTIVE LINK SHOULD HAVE # OF LINES > 0
	JNR	R11			:O.K.

OP1263	CRASH.(.O1263,R0)
OP1463	CRASH.(.O1463,R0)
OP1663	CRASH.(.O1663,R0)
OP1863	CRASH.(.O1863,R0)

	EI	:DB.TSN

::*********************************************************************
::
::	SUBROUTINE:	SIPKSV:			###AL
::	FUNCTION:	Save SIO line bad packets received 
::	CALLING SEQ:	JAL	R9,SIPKSV
::	INPUT:		R11,R13 are pointers for SIBUF, LN(R14) is line#
::	DESTROYED:	R0,R8
::
::*********************************************************************

       IF	 SILINS
SIPKSV  			:save packets into debugger     	###sdw
       IF	 LNKDBG  	:for link/line debugger
	STM	R0,RGST 	:save regs into foreground save area
	JAL	R14,SIPDB1,,    :the debugger routine
	LM	R0,RGST 	:restore regs
       EI 	:LNKDBG

	JR	R9		:that's it      			###sdw
       EI	:SILINS

	SUBTTL	LINKER (SYLVER - Dispatcher for input on sync lines)

::*********************************************************************
::
::	PROCESS:	SYLVER:
::	FUNCTION:	Sync and SIO data handlers
::	CALLING SEQ:	SYLVER IS SCHEDULED TO BE RUN EACH 16 MILLISECONDS
::	OR EACH TIME THROUGH THE EXEC LOOP -- WHICHEVER IS MORE FREQUENT.
::
::		A SET OF ROUTINES PROCESS THE DATA RECEIVED ON THE NETWORK
::	SYNC LINES, MOVE THE DATA FROM THE INPUT RINGS TO SECTOR BUFFERS,
::	ALIGN THE DATA, PERFORM CHECKSUMMING, AND HANDLE SEQUENCING AND
::	ACKNOWLEDGING PACKETS.  EACH LINE 'CONTROL BLOCK' CONTAINS THE ADDRESS
::	OF THE CURRENTLY ACTIVE 'ROUTINE' AT QSYLVER.
::	THERE ARE THREE POSSIBLE ENTRY POINTS:
::	SYLMRK -- SEARCH FOR START BIT (BORI)
::	SYWAIT -- WAITING FOR RECEPTION OF COMPLETE DATA RECORD
::	SYLDWT -- WAITING FOR RECEPTION OF COMPLETE DOWNLINE LOAD RECORD
::
::		Then fall through to process I/O on SIO lines (if any).
::	
::	REGISTER USAGE:
::	R0  -- WORK REGISTER
::	R1  -- WORK REGISTER
::	R11 -- INPUT DATA LEAD POINTER
::	R12 -- INPUT DATA TRAILING POINTER
::	R13 -- INPUT RING ADDRESS
::	R14 -- LINE NUMBER X 2
::	R15 -- LINK DESCRIPTOR ADDRESS
::
::	CALLS:	JAL	R8,LSPEEZ
::
::*********************************************************************

SYLVER	HS	0			:IF ISIS, THIS IS FOREGROUND
       if	tii.fg
	svc     fast,0
       else     :if run from BG then sylver is a routine
	ST	R10,dssvrt
       ei 	:tii.fg
	LIS	R0,0
	STH	R0,GOVSWI


:	RECORD INTERVAL BETWEEN SYLVER EXECUTIONS IN HISTOGRAM AND TEST
:	FOR NEW SYLVER INTERVAL HIGH-WATER MARK.
	LIS	R0,1
	AHM	R0,SYLXEC		:INCREMENT COUNT OF SYLVER ECECUTIONS
	L	R2,FASTC,,
       if	1-tii.fg		:only if no fg
	lr	r1,r2
	ahi	r1,rate/32		:give it 50d shots a second
	st	r1,syvsch		:when to run again
       ei 	:tii.fg
	LR	R1,R2
	S	R2,SYLTIM		:COMPUTE TIME SINCE SYLVER LAST RAN
	ST	R1,SYLTIM		: AND SAVE CURRENT FASTC FOR NEXT TIME
	JL	SYLV00			:IF FASTC WRAP, SKIP, DON'T CRASH!
	LR	R4,R2			:SAVE SYLVER INTERVAL:*Z
	CLH	R2,SYLHWM		:DOES SYLVER INTERVAL EXCEED PREVIOUS
					:	HIGH-WATER MARK?
	JLEFS	SYLS00			:NO
	STH	R2,SYLHWM		:YES - SAVE

SYLS00	HS	0		:COMPUTE LINE SPEED FOR ANY LINES REQUESTED
	if	sylins
	L	R13,LINSPD	:BIT SET IN LINSPD EVERY SEC FOR EACH SYNC LINE
				: WHICH HAS RECEIVED 2 GOOD RESETS
	JE	SYLV00			:NONE
	LH	R3,SYLINT		:HAVE WE GOT A GOOD INTERVAL,15-100 MS?
	JL	SYLS03			:NOPE, HAVEN'T EVEN STARTED YET.
	AH	R4,SYLINT		:SEE IF WE'VE GOT A GOOD INTERVAL
	CLHI	R4,9			:MUST BE < 15 MS
	JLFS	SYLS02
	CLHI	R4,3C			:MUST BE < 100 MS
	JGEFS	SYLS03
	JAL	R8,LSPEED		:OK, GO MEASURE
	TS	SYLINT			:INDICATE NO MEASUREMENT IN PROGRESS
	JFS	SYLV00

SYLS02	STH	R4,SYLINT		:TRY AGAIN NEXT TIME
	JFS	SYLV00

SYLS03	HS	0			:TOO MUCH OR JUST STARTING
	LIS	R4,0			:START OVER
	STH	R4,SYLINT
	JAL	R8,LSPEEZ		:INITIALIZE INPUT POINTER POSITIONS
	ei	:sylins

SYLV00	HS	0
	if      sylins			:if sync lines
	LHI	LN,(sylins-1)*2		:PROCESS ALL SYNC LINES
	ELSE	SILINS			:CHECK IF NO LINES AT ALL	###OAS
	j       sylrtx  		:no sync lines
	EI	:SILINS

	if	sylins
SYLV01	LHL	R13,SVBDIS,LN		:RELATIVE START OF INPUT RING
	LHL	R11,SVNTIP,R13,		:RAW DATA LEAD POINTER
	LA	R13,SVNTBF,R13,		:INPUT RING FULL ADDRESS
	LHL	R12,SVNTOP,LN		:INPUT DATA TRAIL POINTER
	LHL	R1,QSYLVR,LN		:GET ROUTINE ADDRESS
	J	SEG1,R1,,		:GO TO IT

:	GENERAL EXIT POINT FOR SYNC LINE INPUT PROCESSOR. LOOP
:	BACK IF THERE ARE MORE SYNC LINES, OR ELSE FALL THROUGH
:	TO PROCESS I/O ON SIO LINES (IF ANY)

SYLRET	STH	R12,SVNTOP,LN		:SAVE TRAIL POINTER
	SIS	LN,2			:TRY NEXT LINE
	JGE	SYLV01			:LOOP BACK IF THERE IS A NEXT LINE
       IF	 1-SILINS		:IF NO SIO
	J       SDSMISS 		:QUIT
       EI 	:
	ei	:sylins

	SUBTTL	LINKER (SYLVER - SIO input processor)

::*********************************************************************
::
::	ROUTINE:	SYLRTX:
::	FUNCTION:	SCAN FOR INPUT AND OUTPUT TASKS TO BE PERFORMED
::			ON ALL SIO LINES.
::	CALLING SEQ:	Fall through from SYLVER loop above.  DO ALL INPUT
::	FOR A GIVEN LINE (UNTIL BYTE COUNT IS NEGATIVE), THEN DISPATCH TO
::	OUTPUT STATE (SIOUT) TO SEE WHAT THERE IS TO DO.
::	SYNC lines:  input has already been done, so only do output.  The
::		change is to start from line 0 instead of the first SIO
::		line.
::	CALLS:		JAL	R9,NETDGN
::			JAL	R0,TSFMRK
::			JAL	R8,TSNSPK
::			JAL	R2,TSFUAL
::	RETURNS:	JL	SIOUT
::
::*********************************************************************

	IF	SILINS
SYLRTX	lis	r0,0
	sth	r0,rtdgov
	LHI	LN,(NLINES-SILINS)*2	:PROCESS ALL SIO LINES, FROM TOP DOWN
SIO1	LHL	R13,SIBUFP,LN		:GET POINTER TO INPUT BUFFER
	LH	R11,SIBUFN,LN		:OFFSET OF NEXT EXPECTED RECORD
	l       r0,fastc,,
	s       r0,rtdgvt       	:time to govern rtd from sio input?
	jlefs   SIOI1
	ts      rtdgov  		:in some danger of sio input wrap

SIOI1	LH	R10,SIBUF,R13,R11	:GET THE BYTE COUNT
	JGEFS   SIOI01  		:something arrived
	AIS     LN,2
	CLHI    LN,NLINES*2
	JL	SIO1			:service next line
	l       r0,fastc,,
	ahi     r0,siothr       	:time to danger of sio input wrap
	st      r0,rtdgvt
	J       SDSMIS  		:else dismiss
SIOI01	je	sioi2			:go to next if zero
:	JE	SIOBER			:not really an error condition
:	LH	R10,SIBUF,R13,R11	:GET THE BYTE COUNT
	CLHI	R10,(siofsz+2)		:GREATER THAN MAX RECORD SIZE?
	JG	SIOBER			:YES - ERROR
	LB	R0,SIBUF+2,R11,R13	:IF FIRST BYTE OF DATA IS ZERO
	JE	SIOI2			:GARBAGE RECEIVED

:	COMPLETE RECORD RECEIVED
:	FIRST SEE IF THIS SIO LINE IS BEING USED FOR A DOWNLINE LOAD

	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	jg	sii14			:faster than testing bits
	TBT	LN,DWLDSP		:IS LN ON DWL LIST?
	JN	SIODWL			:YES, BRANCH AWAY TO SERVICE
	if	chboot
	lhl	r8,siotst,ln
	ci	r8,siobot-seg1		:sending boot requests
	je	cnbrcv			:are we expecting boot responses. yes
	ei	:chboot

	lr	r0,ln
	srls	r0,1
	tbt	r0,xltact
	jn	xlsi00			:line test data

sii14	LR	R0,R10			:R0= BYTE COUNT	###LSH
					:REGULAR LINE
	LIS	R1,7			:FIND RECORD SIZE MOD 8
	NR	R1,R0			:ZERO MOD8 MEANS SOFTWARE ###LSH
	JE	SIOI3			:CHECKSUMS RECEIVED
	SIS	R1,4			:FOUR MOD8 MEANS NO SOFTWARE
	JE	SIOI4			:CHECKSUMS

	CLHI	R10,DWLPSZ		:might it be a DWL record?
	JE	SIOI2			:if so then ignore
	LIS	R0,1			:BAD RECORD SIZE -- NOTE IT
	AHM	R0,SIOBRS
	JAL	R9,SIPKSV		:SAVE 28 BYTES OF THIS BAK PACKET

:	RE-INITIALIZE SIO INTERFACE IF BAD RECORD SIZE...
:	SETTING SIOSTT+8 TO NON-ZERO VALUE CAUSES SIOIZ TO INITIALIZE.
:	NOTE--SIOIZ IS CALLED FROM THE TWO SECOND LOGIC.

SIORIN	LR	R9,LN
	SHI	R9,(NLINES-SILINS)*2	:GET RELATIVE (SIO LINE NUMBER)*10
	SLLS	R9,3
	TS	SIOSTT+8,R9,		:-1 INDICATES SOFTWARE INITIALIZATION
	STH	R10,BADSLN,LN		:save length of bad SIO packet

:	ADVANCE TO NEXT RECORD

SIOI2	LCS	R0,1			:CLEAR COUNT IN CASE FIRST 1/2
	STH	R0,SIBUF,R13,R11	:	WORD IN BUFFER
	AR	R11,R10			:ADVANCE INPUT INDEX
	AIS	R11,3			
	NHI	R11,7FFE		:ALIGN TO HALFWORD BOUNDARY
	CLH	R11,SIBUFW,LN		:ROOM FOR ANOTHER RECORD?
	JLFS	SIOI25			:YES, SKIP
	LIS	R11,0			:NO, GO BACK TO BEGINNING
SIOI25	STH	R11,SIBUFN,LN
	J	SIOI1

:	ERROR DETECTED IN FIRST HALFWORD OF SIO BUFFER - COUNT TOO LARGE
:	OR ZERO. INCREMENT ERROR COUNT, SAVE SOME REGISTERS.

SIOBER	LIS	R7,1			:INCREMENT COUNT OF BUFFER ERRORS
	AHM	R7,SIOECT

       IF	 LNKDBG  		:link debugger may save some stuff
	STM	R0,RGST
	JAL	R14,SIBDB1,,
	LM	R0,RGST
       EI	:LNKDBG						###sdw
:	FORMAT DIAGNOSTIC NODE REPORT AND CRYPTOGRAM
:	DON'T CALL NETDGN FROM HERE SINCE WE ARE IN FOREGROUND. FORMAT
:	MESSAGE IN SUPIBF, WITH FIRST HALFWORD USED AS SEMAPHORE FOR
:	SWITCH.  
	srls	ln,1			:make into actual line num
	STB	LN,SUPIBF+3		:SAVE LINE NUMBER
	slls	ln,1			:restore to ln*2
	OHI	R10,8000
	STH	R10,SUPIBF+4		:REPORT BAD COUNT IN BUFFER###sn###wjl
	LIS	R8,DR.SIO
	STB	R8,SUPIBF+2		:DIAGNOSTIC SUB-TYPE FOR SIO ERROR
	STH	R8,SUPIBF		:ALERT SWITCH THAT NODE REPORT WAITING
	J	SIOI2			:GO RE-INITIALIZE SIO HARDWARE

:	COME HERE TO CHECK SOFTWARE CHECKSUMS

SIOI3	LIS	R2,0			:CLEAR ACCUMULATORS	###LSH
	LIS	R3,0
	LIS	R0,4			:NEGATIVE BYTE COUNT IN R0
	SR	R0,R10
	LA	R9,SIBUF+2,R13,R11	:POINT TO BEGINNING OF DATA
	LR	R1,R9			:VERS 18 MICROCODE SMASHES R2 OF CKSUM
	CKSUM	R2,R1			:CKSUM PACKET, STARTING AT R1 ADDRESS
	XH	R2,-4,R10,R9		:COMPARE CALCULATED AND RECEIVED
	XH	R3,-2,R10,R9		:CHECKSUMS

	OR	R3,R2
	LHR	R3,R3			:###LSH
	JE	SIOI4			:GOOD CHECKSUM...
	LIS	R0,1			:SIO CARD SLIPPED US A BAD ONE
	AHM	R0,SIOBCS
	AHM	R0,BADCSM,LN		:RECORD BAD CHECKSUM

	IF	TSTSZE			:IF SYNC TRACING ENABLED
	Lr	kd,kd			:LINK DESCRIPTOR ADDRESS
	JL	TSLB15			:UNASSIGNED LINE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB15			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	LHL	R4,SIBUF+2,R11,R13	:GET RECORD HEADER IN R4
	LB	R0,SIBUF+4,R11,R13	:GET RECORD NUMBER
	LH	R2,LAS,KD
	SHI	R2,07F
	SR	R0,R2			:GET CURRENT 1/2 WORD
	LBR	R0,R0			:	RECORD NUMBER TO R2
	AR	R2,R0
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.CSE
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (CHECKSUM ERROR)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB15	EI	:TSTSZE

	J	SIOI2			:###LSH

:	RECORD RECEIVED WITH GOOD CHECKSUM -- SEE WHAT IT CONTAINS

SIOI4	LHL	R4,SIBUF+2,R11,R13	:GET RECORD HEADER IN R4
	Lr	KD,kd			:LINK DESCRIPTOR ADDRESS
	JL	SILUAL			:HANDLE RECORD ON UNASSIGNED LINE

	EXBR	R0,R4			:ISOLATE BORI
	NHI	R0,0F0
	CLB	R0,BORI,KD		:GOOD BORI?
	JN	SIOI7			:NO

	EXBR	R1,R4			:GET BYTE COUNT
	NHI	R1,0F			:	VIA TABLE LOOKUP
	LB	R1,SYTWCN,R1
	LR	R0,R10			:COMPARE RECEIVED RECORD SIZE
	SR	R0,R1			:	AGAINST EXPECTED SIZE
	JEFS	SIOI41
					:REGULAR LINE
	SIS	R0,4			:ALLOW FOR SOFTWARE CHECKSUMS
	JEFS	SIOI41			:SKIP IF VALID COUNTT

	LIS	R0,1			:INC BAD SIZE COUNTER
	AHM	R0,SIOMIS
	J	SIOI2

SIOI41	LB	R0,SIBUF+4,R11,R13	:GET RECORD NUMBER
	LH	R2,LAS,KD
	SHI	R2,07F
	SR	R0,R2			:GET CURRENT 1/2 WORD 
	LBR	R0,R0			:	RECORD NUMBER TO R2
	AR	R2,R0
	LB	R5,WSIZ,KD		:GET NUMBER OF SECTORS
	LHL	R6,ISEC,KD		:SECTOR 0 DESCRIPTOR ADDRESS
	LR	R0,R2
	SH	R0,RECN,R6		:DISTANCE TO SECTOR 0
	LHR	R0,R0
	JGEFS	SIOI45			:AHEAD OF SECTOR 0
	AR	R0,R5			:ADJUST FOR WRAP AROUND
SIOI45	CR	R0,R5			:TOO FAR AHEAD?
	JLFS	SIOI46			:NO
	SR	R0,R5			:YES, BACK UP

SIOI46	lr	r9,r0
	lhl	r0,ccdsz,r9,r9  	:get rel sector address
:	MH	R0,CCDSZ		:GET RELATIVE SECTOR ADDRESS
	AR	R6,R0			:CORRECT SECTOR DESC ADDR TO R6
	LR	R0,R2			:MOVE REC # TO R0
	SH	R0,LRT,KD		:IS THIS REC # .LE. LAST REC TORN?
	LHR	R0,R0
	JLE	SIOI6			:YES, THIS REC IS A RETRANSMISSION

	CR	R0,R5			:IS REC # .LE. LRT + WSIZ?
	JLE	SIOI5			:YES, OK

:	BAD RECORD NUMBER RECEIVED

SRXB00	LB	R0,NLAT,KD		:IF MULTIPLE-LINE LINK, DON'T COUNT
	CLHI	R0,1			:	BAD RECORD NUMBER...
	JNFS	SIOI48
	AHM	R0,BADRCN,LN		:INC BAD RECORD COUNTER
	JAL	R9,SIPKSV		:SAVE THIS BAD PACKET ##AL
SIOI48	IF	TSTSZE			:IF SYNC EVENT TRACING ENABLED
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB14			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BRN
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD RECORD NUMBER)
	STH	R4,TSFTBL+2,R15		:STORE RECORD HEADER
	STB	R2,TSFTBL+4,R15		:	AND PACKET RECORD NUMBER
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:THIS 'LHL' TO A 'STH' TO TERMINATE
					:TRACING AND EXAMINE HISTORY
					:PRIOR TO BAD RECORD OCCURRENCE.
	L	R15,TSRSVE
TSLB14	EI	:TSTSZE

	J	SIOI2

:	COPY THE DATA TO THE INPUT SECTOR (IF NOT RETRANSMISSION)

SIOI5	CLH	R2,RECN,R6		:WAS RECORD RECEIVED?
	JE	SIOI6			:YES, NOTE RETRANSMISSION
	if      1-tii.fg		:can only do if no foreground
	clh	r6,nrtr,kd		:this the next record to tear?
	jnfs	sioi52	 		:no, copy it
	lh	r0,RTDGOV
	je      siortd  		:prevent oursevles from getting
	 				:overwhelmed and not servicing
	 				:everything else.
       ei 	:tii.fg

:	NOW COPY THE DATA
:	Changed to copy before setting okay to tear since if interupted before
:	copy completed then tear does not get a valid packet    	###sdw

sioi52	LA	R7,SIBUF,R11,R13	:SET R7 TO ADDRESS OF LAST
	AR	R7,R1			:	HALFWORD OF SOURCE
	L	R8,BREC,R6		:SET R8 TO ADDRESS OF LAST
	ahi	R8,-2,R1	:	HALFWORD IN DESTINATION BUFFER
	SLLS	R1,3			:NUMBER OF HALFWORDS * 8
	SIS	R1,1			:	MINUS 1
	COPY	R7,R1			:COPY THE DATAF			 ###%cc
	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1
	SBT	R0,LNGREC		:NOTE GOOD REC REC'D ON LINE
	
	LB	R3,LKNM,KD		:GET LINK NUMBER
	STH	R2,RECN,R6		:GIVE RECORD TO SECTOR
	SBT	R3,LKTEAR		:"SCHEDULE RTD
	SBT	R3,LKGREC		:NOTE GOOD REC ON LINK
	LIS	R0,1			:BUMP COUNT OF GOOD
	AHM	R0,RCRCVD,LN		:	RECS RECEIVED ON THIS LINE

	LHL	R0,FASTC+2,,		:GET CURRENT TIME
	STH	R0,INTIME,r6		:RECORD TIME OF PACKET ARRIVAL
SIOI15	LH	R2,SIBUF+2,R11,R13	:UPDATE LAST ACK RECEIVED
	LHL	R1,LAR,KD		:GET LAST ACKNOWLEDGEMENT
	SR	R2,R1			:IS NEW ACKNOLWEDGMENT
	LBR	R2,R2			:	WITHIN THE ALLOWABLE
	CLB	R2,WSIZ,KD		:	WINDOW SIZE?
	JG	SIOI5A			:NO, INC ERROR COUNTER
	AHM	R2,LAR,KD		:YES UPDATE LAR

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB16			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	LHL	R2,RECN,R6		:GET RECORD NUMBER
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LHI	R0,TS.REC
	STB	R0,TSFTBL,R15		:STORE EVENT (GOOD RECORD RECEIVED )
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB16	EI	:TSTSZE

	J	SIOI2

SIOI5A	LB	R0,NLAT,KD		:TEST FOR MULTI-LINE LINK -- BAD ACKS
	sis	R0,1			: CAN OCCUR DUE TO SHORTER PACKET
	JgFS	SIOI5B			: OVERTAKING PRIOR TRANSMISSION
	lis	r0,1			: - DON'T COUNT IT...
	AHM	R0,BADACK,LN

SIOI5B	IF	TSTSZE			:IF SYNC EVENT TRACE ENABLED
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:TEST FOR LINK OF INTEREST
	JN	TSLB20			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BAK
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD ACK)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER 
	LR	R1,R15			:SAVE INDEX REGISTER AND
	L	R15,TSRSVE		:	RESTORE R15 (KD)
	LH	R0,LAR,KD		:GET LAST ACK RECEIVED AND
	STB	R0,TSFTBL+4,R1		:	STORE IN EVENT ENTRY	###OAS
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:THIS 'LHL' TO A 'STH' TO TERMINATE
					: TRACING AND EXAMINE HISTORY
					: PRIOR TO BAD ACK OCCURRENCE.  
TSLB20	EI	:TSTSZE
	J	SIOI2

:	this is sort of RTEAR.  All that is done is to call RTD for
:	a packet but the packet is torn from the sio input buffer instead
:	of copying it somewhere else and making rtear figure out there is
:	a packet waiting.  besides cutting down delays it requires less
:	cpu.

siortd  hs      0			:move it straight from SIO input
	LR	R0,LN			:GET LINE NUMBER
	SRLS	R0,1
	SBT	R0,LNGREC		:NOTE GOOD REC REC'D ON LINE
	
	STH	R2,RECN,R6		:GIVE RECORD TO SECTOR
	LIS	R0,1			:BUMP COUNT OF GOOD
	AHM	R0,RCRCVD,LN		:	RECS RECEIVED ON THIS LINE

	LH	R2,SIBUF+2,R11,R13	:UPDATE LAST ACK RECEIVED
	LHL	R3,LAR,KD		:GET LAST ACKNOWLEDGEMENT
	SR	R2,R3			:IS NEW ACKNOLWEDGMENT
	LBR	R2,R2			:	WITHIN THE ALLOWABLE
	CLB	R2,WSIZ,KD		:	WINDOW SIZE?
	Jlefs	srtd05			:NO, INC ERROR COUNTER
SIOI5A	LB	R0,NLAT,KD		:TEST FOR MULTI-LINE LINK -- BAD ACKS
	sis	R0,1			: CAN OCCUR DUE TO SHORTER PACKET
	JgFS	srtd06			: OVERTAKING PRIOR TRANSMISSION
	lis	r0,1			: - DON'T COUNT IT...
	AHM	R0,BADACK,LN
	jfs	srtd06			:and don't update lar

srtd05	AHM	R2,LAR,KD		:YES UPDATE LAR
srtd06
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	srtd10			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	LHL	R2,RECN,R6		:GET RECORD NUMBER
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LHI	R0,TS.REC
	STB	R0,TSFTBL,R15		:STORE EVENT (GOOD RECORD RECEIVED )
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
srtd10	EI	:TSTSZE

	stm	r10,srtdsv
	la      prd,sibuf+5,r11,r13     :address within siobuffer of data
	lb      kn,lknm,kd
	TBT	KN,BORZAP		:IS LINK AWAITING BORI ZAP?
:	borzap inverted by sdw
	je	srtdex			:don't tear packets for this link
	SBT	kn,LKGREC		:NOTE GOOD REC ON LINK
	st      prd,srtdsp		:save start of data for trace cmd
	lr      prc,r1  		:make regs what they should be
	lr      cd,r6
	AIS	PRC,4			:INCLUDE CHECKSUM AND COUNT
	AM	PRC,KS.PCI,KD		:COUNT PACKET CHARACTERS INPUT
	SIS	PRC,7			:DON'T INCLUDE CHECKSUM, HEADER FOR RTD

:	> > > > > > > > > > > > > > > > >
	JAL	R9,RTD			: go tear down
:	< < < < < < < < < < < < < < < < <

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND 
	CLH	R0,TSLINK		: TEST FOR LINK OF INTEREST
	JN	srtdRT			:NO - CONTINUE
	JAL	R8,TSBMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RTD		:GET EVENT TYPE (RECORD TORN)
	STB	R0,TSBTBL,R7		: AND STORE IN ENTRY
	l	r8,srtdsp		: get back prd (+3) of start
	sis	r8,3
	LHL	R0,0,R8		:GET HEADER HALFWORD
	STH	R0,TSBTBL+2,R7		: AND STORE
	LB	R0,2,R8
	STB	R0,TSBTBL+4,R7		:THIRD BYTE RECORD NUMBER
	LHL	R0,LAS,KD
	STB	R0,TSBTBL+1,R7		:STORE LAST ACK SENT
srtdRT	EI	:TSTSZE

	LHL	R1,RLNK,CD		:INDEX NRTR
	STH	R1,NRTR,KD
	lh	r0,lrt,kd		:inc last record torn
	ais	r0,1
	sth	r0,lrt,kd
	ais	r0,1			:+1 is next record to tear
	lhr	r0,r0			:see if next record already there
	clh	r0,recn,r1		:next there?
	jnfs    srtdex  		:nope
	sbt     kn,lktear		:yes

srtdex  lm	r10,srtdsv		:restore registers
	j       sioi2			:and continue


:	NOTE RETRANSMISSION

SIOI6	LR	R0,LN
	SRHLS	R0,1			:GET TRUE LINE NUMBER
	SBT	R0,LNGREC		:NOTE GOOD REC RECVD ON LINE
					:ADDED 10/30/83 OMAR
	LIS	R0,1			:INC RETRANSMISSION COUNTER
	AHM	R0,RCRXMT,LN
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB13			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RXC
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	STH	R4,TSFTBL+2,R15		:STORE FIRST 2 BYTES OF HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB13	EI	:TSTSZE


	J	SIOI15			:GO UPDATE LAR

:	RECORD WITH BAD BORI RECEIVED ON ASSIGNED LINE
:	CHECK IT OUT

SIOI7	NHI	R4,0F0EF		:mask out 'count code', 'subseq' bit
	CLHI	R4,TTRSHD		:IS THIS ANY KIND OF TYMNET-II RESET?
	JE	SILRAL			:YES, GO TREAT IT
::Get full word header preserved in R4
	L	R4,SIBUF+2,R11,R13	:GET FULL WORD
	CLI	R4,TWDMHD		:DUMMY RECORD?
	JN	SIOI8			:NO, ERROR
:	DUMMY RECEIVED ON ATTACHED LINE	
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB12			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:MAKE NEW EVENT ENTRY
	LIS	R0,TS.DUM
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE
	LIS	R0,0
	STH	R0,TSFTBL+2,R15		:NO DATA FOR HEADER FIELD
	L	R15,TSRSVE		:RESTORE R15
TSLB12	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1			:NOTE GOOD REC REC'D ON LINE
	SBT	R0,LNGREC
	J	SIOI2			:DONE

:	GARBAGE RECEIVED ON ATTACHED LINE -- NOTE LINE ERROR

SIOI8	LIS	R0,1			:INC CONTER
	AHM	R0,LINERR,LN
	J	SIOI2

:	RESET RECEIVED ON ATTACHED LINE -- HANDLE IT

SILRAL	LR	R1,LN
	SRHLS	R1,1			:GET LINE NUMBER
	TBT	R1,INHRST		:RESET INHIBITED?
	JN	SIOI2			:YES, IGNORE IT

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB19			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RST
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (RESET RECEIVED)
	L	R0,SIBUF+2,R11,R13	: GET 4 BYTES OF RESET AND
SILRA2	STh	R0,TSFTBL+2,R15		: STORE 
	exbr	r0,r0
	STb	R0,TSFTBL+4,R15		: STORE (don't clobber fastc
	NHI	R15,TSTSZE-1		:ADVANCE TO NEXT ENTRY AND CLEAR
	LIS	R0,0			:	IT TO EASE FINDING END OF
	ST	R0,TSFTBL,R15		:	TRACE HISTORY
	ST	R0,TSFTBL+4,R15
	lb	r15,nlat,kd		:don't stop tracing if not last line
	sis	r15,1			:on the link
	jgfs	tslb30
	STH	R0,TSLINK		:INHIBIT FURTHER TRACING
tslb30	L	R15,TSRSVE
	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT

TSLB19	EI	:TSTSZE

	LCS	R0,1		
	ST	R0,KDLN,LN,LN		:PUT LINE IN LIMBO
	LHI	R0,SIOIDL-SEG1		:TURN OFF OUTPUT
	STH	R0,SIOTST,LN
	SBT	R1,LINDET		:TELL LINKER TO DETACH
	LIS	R0,3
	STB	R0,DREASN,R1		:SET DETACH REASON
	ts	glinkr
:	LHI	R0,1F-PLINKR		:AND 'SCHEDULE' LINKER
:	SBT	R0,TLINKR
	J	SIOI2			:DONE

:	DATA RECEIVED ON UNASSIGNED LINE -- CHECK FOR RESET
SILUAL	HS	0

	IF	TSTSZE
	JAL	R2,TSFUAL		:IS THIS LINE OF INTEREST?
	EI	:TSTSZE
	AIS	KD,1			:IF LINK ADDRESS = -1, FORGET
	JE	SIOI2			:	IT. LINK STILL IN DETACH
	LR	R2,LN			:GET LINE NUMBER
	SRHLS	R2,1
	TBT	R2,INHRST		:RESET INHIBITED?
	JN	SIOI2			:YES, IGNORE THIS
	L	R5,SDLN,LN,LN		:GET RESET BUFFER ADDRESS
	NHI	R4,0FFE0		:MASK OUT 'subseq' bit and count###wjl
	CLHI	R4,TXRSHD		:Is it an Expanded reset?
	JN	SILU02			:no, check for old T-II Reset
	AHI	R5,VSDSZ-2		:address of last destination HW to R1+1
	LA	R4,(SIBUF+2)+(VSDSZ-2),R11,R13 :address of last source HW to R1
	LHI	R1,10*((VSDSZ/2)-1)	:10*(number of HW'S -1)
	COPY	R4,R1			:copy Reset from temporary storage
	J	SILU04

SILU02	CLHI	R4,TTRSHD		:IS IT A T-II RESET?		###wjl
	JN	SIOI2			:NO, FORGET IT
	L	R4,SIBUF+2,R11,R13	:GET FIRST FULLWORD OF RECORD
	ST	R4,VRSTP,R5		:SAVE FOR LINKER
	L	R0,SIBUF+6,R11,R13	:NEXT FULLWORD MAY CONTAIN 
	ST	R0,VRSTP+4,R5		:	NEIGHBOR VERSION NUMBER

SILU04	SBT	R2,VRSTDL		:TELL LINKER TO LOOK AT IT
	SBT	R2,LINATT
	ts	glinkr
:	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
:	SBT	R0,TLINKR
	J	SIOI2			:DONE

:	received data on a line test line
xlsi00	lis	r0,1			:a packet received
	am	r0,xltpkr,ln,ln
	lb	r0,sibuf+2,r11,r13	:header byte
	clhi	r0,32			:look like sent by a line tester?
	jn	sioi2
	lb	r0,sibuf+3,r11,r13	:length byte
	ais	r0,4
	cr	r0,r10			:does data len and packet len jive?
	jn	sioi2			:no, don't check checksums
	LIS	R2,0			:CLEAR ACCUMULATORS	###LSH
	LIS	R3,0
	LIS	R0,4			:NEGATIVE BYTE COUNT IN R0
	SR	R0,R10
	LA	R9,SIBUF+2,R13,R11	:POINT TO BEGINNING OF DATA
	LR	R1,R9			:VERS 18 MICROCODE SMASHES R2 OF CKSUM
	CKSUM	R2,R1			:CKSUM PACKET, STARTING AT R1 ADDRESS
	XH	R2,-4,R10,R9		:COMPARE CALCULATED AND RECEIVED
	XH	R3,-2,R10,R9		:CHECKSUMS

	OR	R3,R2
	LHR	R3,R3			:###LSH
	JE	SIOI2			:GOOD CHECKSUM...so done
	lis	r0,1
	am	r0,xltcse,ln,ln		:a checksum error, bad HW?
	j	sioi2			:and done

:	receiving boot records in response to nc sending them out
	if	chboot
cnbrcv	LHL	R0,SIBUF+2,R11,R13	:FIRST HALFWORD OF DATA
	CLHI	R0,DWNLHD		:DWL HEADER?
	JN	SIOI2			:NO, IGNORE THE RECORD (GARBAGE?)
	CLHI	R10,DWLPSZ		:CORRECT BYTE COUNT?
	JN	SIOI2			:NO, IGNORE THE RECORD (GARBAGE?)
	l	r0,sibuf+2+3e,r11,r13	:check vrc and drc
	c	r0,cnbrec+40,,		:same data as we sent?
	je	sioi2			:yes line in loopback
	lr	r0,ln	
	srls	r0,1
	sbt	r0,cnbtya		:neighbor is in boot
	sbt	r0,cnbrsp		:need to send return to boot records
	l	r0,fastc,,
	ahi	r0,cnbtim		:give us time to send restarts
	st	r0,siotim,ln,ln		:save quitting time for siobot
	j	sioi2
	ei	:chboot

:	DOWNLINE LOAD ON SIO LINE

SIODWL	LHL	R0,SIBUF+2,R11,R13	:FIRST HALFWORD OF DATA
	LIS	R6,1
	AHM	R6,DWLCLI
	CLHI	R0,DWNLHD		:DWL HEADER?
	JN	SIOI2			:NO, IGNORE THE RECORD (GARBAGE?)
	CLHI	R10,DWLPSZ		:CORRECT BYTE COUNT?
	JN	SIOI2			:NO, IGNORE THE RECORD (GARBAGE?)
	LIS	R1,0
SIODW1	CLH	LN,DWLNUM,R1		:FIND THE INTERNAL HOST CHANNEL INDEX
	JEFS	SIODW2
	AIS	R1,2
	CLHI	R1,TINTCH*2
	JLBS	SIODW1
SIODW2	LH	R6,DWBUSY,R1		:TEST BUFFER BUSY FLAG
	JL	SIOI2			:<0 MEANS DWLIN IS USING DWIBUF
	LR	R5,R1			:NONE OF ABOVE, SO ALL CLEAR. FORM
	SLLS	R5,5			:DWIBUF OFFSET (64 x R1)
	LA	R2,SIBUF+DWLPSZ,R11,R13	:LAST SOURCE HALFWORD
	LA	R3,DWIBUF+DWLPSZ-4,R5,	:LAST DESTINATION HALFWORD
	LHI	R4,(DWLPSZ-4)*8			:HALFWORD COUNT=(20 - 1) x 10
	COPY	R2,R4			:				###%cc
	LHI	R0,-1000		:MARK DWIBUF FULL
	STH	R0,DWBUSY,R1		:BY SETTING DWBUSY NEGATIVE
	SRLS	R1,1
	SBT	R1,DWQUEU		:TELL DWLIN THERE IS A RECORD HERE
	LHI	R0,01F-PDWLIN
	SBT	R0,SQUEUE		:SCHEDULE DWLIN
	J	SIOI2			:AND RETURN




	SUBTTL	LINKER (SIO M-board report routines)


::*********************************************************************
::
::	SUBROUTINE:	SIOBZY:
::	FUNCTION:	M-BOARD TIMEOUT. GENERATE A SUP REPORT AND CRYPTO
::			MESSAGE AND RETURN.
::	CALLING SEQ:	JAL	R12,SVCExx
::	INPUT:		DIFFERENT SVC'S ARE DISTINGUISHED BY THE VALUE IN R8
::	PRESERVED:	All registers
::	CALLS:		JAL	R9,NETDGN
::
::*********************************************************************

SIOBZS	LIS	R8,DR.SZS		:GET MESSAGE TYPE - INDICATE SVC STATUS
	JFS	SIOBZY
SIOBZO	LIS	R8,DR.SZO		:...OUTPUT
	JFS	SIOBZY
SIOBZI	LIS	R8,DR.SZI		:...INPUT
	JFS	SIOBZY
SIOBZC	LIS	R8,DR.SZC		:...CONNECT

SIOBZY	STM	R0,SBZSAV		:SAVE OFF REGISTERS (ESPECIALLY R9)
	LHL	R2,NGSVLN,LN		:NEIGHBOR LAST ATTACHED TO THIS LINE
	STH	R2,SUPMBF+4
	SRLS	R14,1			:TRUE LINE NUMBER
	STB	R14,SUPMBF+3
	JAL	R9,NETDGN,,		:MAKE REPORT TO SUP AND XRAY
	LM	R0,SBZSAV		:RECOVER REGISTERS
	JR	R12			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	SIOXXX:
::	FUNCTION:	MBOARD RC=4, ERROR. MAKE CRYPTO REPORT TO XRAY.
::	CALLING SEQ:	JAL	R12,SVCExx
::	INPUT:		LN  = R14
::	CALLS:		JAL	R8,CRYPTO
::			HC	CRYE70
::	###OAS 3/83
::*********************************************************************

SIOXXX	LR	R2,LN			:LINE NUMBER			###OAS
	SLLS	R2,0F			:IN HO HW			###OAS
	LHL	R8,NGSVLN,LN		:NEIGHBOR NUMBER		###OAS
SIOX2	OR	R2,R8			:IN LO HW			###OAS
	ST	R2,CRYSBF		:STORE FOR CRYPTOGRAM		###OAS
	JAL	R8,CRYPTO		:SIO ERROR			###OAS
	HC	CRYE70			:				###OAS
	JR	R12			:RETURN TO SVC CALLER		###OAS

      EI	:SILINS			:SIO input

	SUBTTL	LINKER (SYLVER - SIO output processor)

::*********************************************************************
::
::	ROUTINE:	SIOUT:
::	FUNCTION:	OUTPUT HANDLER ROUTINES FOR ALL LINES
::	CALLING SEQ:	JUMP HERE FROM SYLRTX (PART OF SYLVER LOOP)
::			WHEN BYTE COUNT NEGATIVE.
::	CALLS:		DISPATCH TO APPROPRIATE OUTPUT ROUTINE.
::			EACH LINE'S OUTPUT STATE IS DEFINED BY THE
::			ROUTINE WHOSE ADDRESS IS STORED AT 'SIOTST'.
::
::	THE POSSIBLE OUTPUT STATES ARE:
::
::	SIOIDL	-- IDLE (GO IMMEDIATELY TO NEXT LINE)
::	SIOTT	-- returning CCWs on an unserviced line (lines are normally
::		   in rmake so probably a multiline link)
::	SIORR	-- SEND REPEATED RESETS TO MAKE NEIGHBOR AWARE OF PRESENCE
::	SIORS	-- SEND SINGLE RESET FOR RESET SEQ AND SPEED CLOCKING	
::	SIORT	-- CLOCK IN THE LINE SPEED PATTERN AND GO TO SIOIDL	
::	XLTSND	-- transmitter for line tester
::	SIOBOT	-- transmitter to see if neighbor is in boot
::
::	note: for v5.35 the service logic was redone and this logic serves
::		both SYNC and SIO lines.
::
::	RETURNS:	to caller via r10
::
::*********************************************************************

SIOUT	ST	R10,DSSVRT		:save caller
SIOO01  la	r0,2*((nlines-1)/8)+linsvd
	lr	r1,r0
	lhi     ln,(((nlines*2-2)/10)*10)!0f
	arand   r0,ln			:find an unserviced line
	jfs     sioo02
	l	r10,dssvrt
	jr	r10
sioo02  rbt     ln,linsvd
	TS      SIOROS  		:handle if first sio line is dead

:	SIOTST IS OUTPUT STATE FOR REGULAR LINE
:
SO22	TS      SIOROL  		:init as not switching multiline###sdw
	LR	R0,LN			:test if SIO line is alive
	SRLS	R0,1
	TBT	R0,SIOPTA		:if set then no can issue output svcs
	JN      SIOIDL  		:				###sdw
	LHL	R1,SIOTST,LN		:GET ROUTINE ADDRESS	###LSH
	J	SEG1,R1,,		:GO TO IT

::*********************************************************************
::
::	OUTPUT STATE:	SIOTT -	return ccws on unserviced lines
::
::*********************************************************************

SIOTT	lis	r8,0			:only do this line
	lr	r5,ln			:set up for ccwe.a
	l	kd,kdln,ln,ln		:get link desc
	if	multln			:only check the one line
	lis	r8,0
	ei
	jal	r9,ccwe.a		:return CCWs (non link entry)
	j       sioidl  		:no free ccws
	ts      idle,kd
	j	sioidl			:and done


::************************************************************
::	xltsnd	Line Tester transmitter
::************************************************************

xltsnd	l	r0,slowc,,
	s	r0,xltent,ln,ln		:time to end the test?
	jl	xltsn1
:	end the line test
	lr	r0,ln
	srls	r0,1
	rbt	r0,xltact		:test no longer running
	lcs	r0,1
	lhl	r1,xltchn,ln		:clear chn by line (links the two)
	rbt	r1,xltcha		:block now free
	sth	r0,xltlnm,r1,r1		:clear line number this guy is running
	lhi	r0,siorr-seg1		:back to resets
	sth	r0,siotst,ln
	j	sioidl

xltsn1	L	R7,SIOBLA,ln,ln		:start of ccw block
	LB	R6,SIOTB,ln		:transmitting CCW
	CLB	R6,SIOFB,ln		:all full or all empty
	JE	xlts.F			:check out which of the two
:	here to check a ccw
xltsH0	LH	R0,0,R6,R7		:status of oldest sending CCW
:	status of 200 (completed) or 100 (completed and jumped) for SIO
:	and status of 0000 (completed) for sync.  Status of 1 if still
:	sending (both SIO and Sync).  Thus, check low byte to see if 
:	this ccw is done.
	LBR	R1,R0			:completed?
	JEFS	xltsH1			:yes
xltsHX	STB	R6,SIOTB,ln		:store oldest transmitting CCW
	J	xlts00			:some CCWs are free

:	here to return a CCW which mean we must also check for a chain
xltsH1
       if	sylins
	if	silins
	CLHI	ln,(sylins)*2		:is it a sync line
	JGEFS	xltsH2			:no, an SIO line
	ei	:silins
	LH	R0,8,R6,R7		:get status of the chain
       ei	:sylins
xltsH2	AHI	R6,10			:check next one
	nh	r6,sionch,ln		:stay within line's ccws
	CLB	R6,SIOFB,ln		:is next CCW a free CCW?
	JE	xltsHX			:yes, thus a single, so done
:	here to check the status of the chain
       if	silins
	if	sylins
	CLHI	ln,(SyLINS)*2
	JL	xltsSY			:do sync there
	ei	:sylins
:	here to check SIO chain
	SHI	R0,100			:jump succeeded?
	JE	xltsH0			:yes, see if next ccw is also free
	STB	R6,SIOTB,ln		:did return upto this point
	lr	r5,ln
	SRLS	R5,1			:make line# *1
	AR	R6,R7			:address of CCW in r6
	LIS	R0,1
	STH	R0,0,R6			:store jump command
	SVC	IO,0B0+R5		:do output
	JAL	R12,SVC53B		:crash if bad
	J	xlts00			:and no more ccws tocheck
       ei 	:silins

:	here to see if a sync chain succeeded
	if	sylins
xltsSY	LR	R0,R0			:see if chain completed
	JE	xltsH0			:0 is completed
	STB	R6,SIOTB,ln		:did free upto here
	lr	r5,ln
	SRLS	R5,1
	AR	R6,R7			:make address
	LIS	R0,1
	STH	R0,0,R6
	SVC	IO,20+R5		:sync output svc
	JAL	R12,SVCE32
	J	xlts00			:and no more ccws to check
       ei	:sylins
:	here if CCW is either full or empty.  Check CCW before current
:	pointer, if it is transmitting then we have a transmitting chain.
:	If it isn't transmitting then either previously we had no output
:	or a complete chain completely unwound.  Either way we have no
:	active CCWs.
xlts.F	LR	R1,R6
	ahi	R1,10			:if a chain then next is the start
	nh	r1,sionch,ln		:wrap if needed
	LB	R0,1,R1,R7		:get it's status
	jefs	xlts00			:ccw list is empty
	LHL	R0,0,R6,R7		:get status of oldest sending
	LBR	R1,R0			:is it still sending?
	JE	xltsH1			:unwind the chain
	j	sioidl			:both CCWS still sending

:	got here after checking ccws and have a free ccw/rotor
xlts00	lh	r0,fastc+2,,		:see if time to try to send one
	sh	r0,xlttim,ln
	jl	sioidl			:have to wait
	ah	r0,xltrat,ln		:when to go again and don't drift
	ahm	r0,xlttim,ln		:when to run again

:	test still running so send something out
	lh	r8,xltchn,ln		:get internal chn doing test
	tbt	r8,xl2047		:doing the 2047 for this line?
	je	xlts10
:	since 2047 is constantly different data then can't chain since
:	with the one output area then packet being transmitted is getting
:	rewritten by the setup for the second.  Thus, have to be idle.
	lb	r0,siofb,ln
	clb	r0,siotb,ln
	jn	sioidl
	lhl	r8,xltchn,ln		:get chn number
	lhl	r8,dwobla,r8,r8
	ai	r8,dwobuf		:address of output data
	lh	r7,xltsiz,ln		:get size of data to be sent
       if	silins
	if	sylins
	clhi    ln,(sylins)*2
	jlfs	xlts07
	ei	:sylins
	ais	r8,2			:sio lines start with len for ccw output
	ei	:silins

xlts07	lis	r6,2			:start count at 2 for header
:	ed mooring's 2047 pattern generator.
	lhl	r3,xl204p,ln		:get current seed
xlts08	lr	r2,r3
	lr	r1,r3			:working copies of current seed
	srls	r1,3			:value of pattern	
	srls	r2,1
	xr	r2,r1
	lbr	r2,r2
	slls	r3,8
	or	r3,r2
	nhi	r3,$a 2047
	jnfs	xlts09
	lhi	r3,$a 2047
xlts09	stb	r1,0,r8,r6
	ais	r6,1			:another byte done
	cr	r6,r7			:finished?
	jl	xlts08			:nope, do next byte
	sth	r3,xl204p,ln		:save current seed
					:and fall down and do checksum
:	do checksum
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators
 	LIS	R0,0
	SR	R0,R7			:negative count for microcode

:	the checksum instruction updates the source register every 32
:	halfwords or so. (if current address ANDed with 3E is 0 then
:	address register is updated). so save start address in R6.
	lr	r6,r8
	CKSUM	R2,R8			:calculate checksum
	STH	R2,0,R7,R6		:save vertical checksum
	STH	R3,2,R7,R6		:save horizontal checksum
:	now can send it out
xlts10	lis	r1,1
	am	r1,xltpks,ln,ln		:another packet sent
	lh	r0,xltchn,ln		:get internal chn doing test
	lhl	r1,xltchn,ln		:get chn number
	lhl	r0,dwobla,r1,r1
	ai	r0,dwobuf		:address of output data
	lh	r7,xltsiz,ln		:get size of data to be sent
	lb	r1,siofb,ln
	a	r1,siobla,ln,ln 	:get address

       if	silins
	if	sylins
	clhi    ln,(sylins)*2
	jl      xlts30
	ei	:sylins
	lh	r4,xltsiz,ln		:get size of data to be sent
	ais	r4,4			:size of checksums
	lr	r5,r0
	sth	r4,0,r5			:give it the packet length
	srls	r5,4
	STH	R5,2,R1			:###LSH
:	WRITE OUTPUT PROGRAM INTO LINE'S CCW BLOCK 
:	(SEE DEVICE.DOC SEC 1.3.3 FOR DESCRIPTION OF CHANNEL PROGRAMS)

	LIS	R0,0			:MAKE A STOP COMMAND
	STH	R0,4,R1			:PUT IT AFTER OUTPUT COMMAND
	LIS	R0,1			:MAKE AN OUTPUT COMMAND
	STH	R0,0,R1			:AND STORE IT
	lb	r3,siofb,ln
	clb	r3,siotb,ln
	jefs    xlts25			:none currently sending
	shi	r3,10			:get previous ccw
	nh	r3,sionch,ln		:stay within ccw chain
	lis	r0,2			:the jump command
	a	r3,siobla,ln,ln
	sth	r0,4,r3 		:do a jump command to previous ccw
	j	xlts50

:	START OUTPUT CCW PROGRAM
xlts25	LR	R0,LN			:LINE NUMBER * 2
	SRLS	R0,1			:LINE NUMBER
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRSH
	j	xlts50
      EI	:SILINS

:	send it on the sync line
       if	sylins
xlts30	ST	R0,4,R1			:write it to rotor
	lh	r5,xltsiz,ln		:get size of data to be sent
	ais	r5,4			:size of checksums
	STH	R5,2,R1
:	Do Sync Line Output

	LIS	R0,0			:put stop after command
	STH	R0,8,R1			:clear the jump rotor
	LIS	R0,1			:make an output command
	STH	R0,0,R1			:store it into rotor
	lb	r3,siofb,ln
	clb	r3,siotb,ln		:output in progress?
	jefs    xlts34			:if equal then no
	xhi	r3,10			:flip to other handler
	lis	r0,2
	a	r3,siobla,ln,ln
	sth	r0,8,r3			:do a jump command to previous ccw
	jfs	xlts50
:	not chaining
xlts34	LR	R0,LN
	SRLS	R0,1			:do force output SVC
	SVC	IO,20+R0
	JAL	R0,SVCE32		:error handler
       ei	:sylins

:	common logic for both sync and SIO lines. 
:	update the pointer to the next free rotor/CCW.

xlts50	LB	R5,SIOFB,LN		:bump up free port
	ahi	R5,10			:point to other CCW
	nh	r5,sionch,ln		:wrap if needed
	STB	R5,SIOFB,LN		:and fall through to try to send more
	j	sioidl			:sent our data

::************************************************************
:	siobot	send boot dump requests to neighbor to see if neigbor is
:		in boot
::************************************************************

	if	chboot
siobot	lr	r7,ln			:we are going to need ln*1
	srls	r7,1
	l	r0,siotim,ln,ln		:see if time expired
	c	r0,fastc,,
	jge	siobo1			:stiil have time
	sbt	r7,cnbrsp		:get a good response
	jn	siobo0			:got something back
	rbt	r7,cnbtya		:must not have got anything back
	l	r0,fastc,,
	ahi	r0,cnbtim		:give us time to send restarts
	st	r0,siotim,ln,ln		:save quitting time for siobot
	j	sioidl			:and send restarts for a while
siobo0	lhi	r0,siorr-seg1
	sth	r0,siotst,ln		:restore ping resets
	j	sioidl

siobo1	l	r1,siobla,ln,ln
	if	sylins
	if	silins
	CLHI	LN,(NLINES-SILINS)*2	:SIO or sync line?
	JGE	SIObo4			:SIO line
	ei	:silins
:	for sync line, make sure previous output has completed before
:	trying to send reset.  Must check the first jump rotor (+8) since
:	line initialization uses it to bring up DSR.			###sdw

	LHL	R0,0,R1			:current output command
	JN	SIOIDL			:not 0, still transmitting
	LHL	R0,8,R1			:for all rotors that might be sending
	JN	SIOIDL
	LHL	R0,10,R1		:and other main ouput rotor
	JN	SIOIDL

:	save caller's desired state and send the reset packet.
	la	r2,cnbrec+2,,		:get address of the boot record
	tbt	r7,cnbrsp		:are we to send back to boot?
	jefs	siobo3			:no
	la	r2,cnbrbt+2,,		:drop him back to boot
siobo3	ST	R2,4,R1			:write address of data to rotor
	LHI	R3,DWLPSZ		:how much to transmit(size of bootrec)
	STH	R3,2,R1			:write length of reset to rotor
	LIS	R3,1			:output command
	STH	R3,0,R1
	LR	R0,r7
	SVC	IO,20+R0		:force output
	JAL	R0,SVCE32		:error
	J	SIOIDL			:done for now
	ei	:sylins

:	send reset on SIO line if transmitter idle
siobo4
      IF	SILINS
	LB	R0,0,R1			:CHECK STATUS OF OUTPUT
	JE	SIOIDL			:CURRENT BLOCK IS BUSY
	SIS	R0,1
	JE	SIOIDL			:###wjl
	lhi	r2,cnbrec/10		:quadword address of boot record
	tbt	r7,cnbrsp		:have we gotten a good response?
	jefs	siobo5			:no
	lhi	r2,cnbrbt/10		:drop him back to boot
siobo5	EXHR	R2,R2			:STORE BOTH ADDRESS AND
	ST	R2,2,R1			:FOLLOWING STOP COMMAND
	LIS	R0,1			:SET OUTPUT COMMAND
	STH	R0,0,R1
	LR	R0,LN			:LINE NUMBER * 2
	SRLS	R0,1			:LINE NUMBER
	TBT	R0,SIOPTA		:IS PORT AVAILABLE?		###OAS
	JNFS	siobo7			:NO, SKIP SVC
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRASH
siobo7
      EI	:SILINS
	J	SIOIDL

	ei	:chboot

::************************************************************
:	ccwsnd  send packet (called from rmake)
::************************************************************

ccwsnd	lhl	r5,rmlnsv		:get line number
	sth	r5,lnidle,kd		:link has a line sending stuff
	lb	r1,siofb,r5
	a	r1,siobla,r5,r5 	:get output ccw address
	l	r2,brec,cd
	Lh	R7,ERECsz,CD		:GET RECORD BYTE COUNT BY SUBTRACTING

    if	sylins
      IF	SILINS			:check is to do SIO lines
	CLHI	R5,(sylins)*2		:sio line?
	JGE	ccws10			:yes
      EI	:SILINS

:	sync line, first put ack into record then do checksum, the put
:	address and length of record into rotor, then jump to common 
:	statistics area.

	LHL	R3,LRT,kd		:put ack into packet
	STH	R3,LAS,kd		:remember that we sent it
	STB	R3,1,R2			:second byte is ack

:	sync line, write length and address to rotor
	ST	R2,4,R1			:save address of data
	AIS	R7,4			:include size of checksum
	STH	R7,2,R1			:store length including cksum
	SIS	R7,4			:back to length of packet

:	sync line, do checksum
	LR	R6,R2			:make copy of start of packet
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators
	LIS	R0,0
	SR	R0,R7			:negative count for microcode

:	the checksum instruction updates the source register every 32
:	halfwords or so. (if current address ANDed with 3E is 0 then
:	address register is updated). so save start address in R6.
	LR	R8,R6			:make copy of start for checksum
	CKSUM	R2,R8			:calculate checksum
	STH	R2,0,R7,R6		:save vertical checksum
	STH	R3,2,R7,R6		:save horizontal checksum

:	Do Sync Line Output

	LIS	R0,0			:put stop after command
	STH	R0,8,R1			:clear the jump rotor
	LIS	R0,1			:make an output command
	STH	R0,0,R1			:store it into rotor
	lb	r3,siofb,r5
	clb	r3,siotb,r5		:output in progress?
	jefs    ccws34			:if equal then no
	xhi	r3,10			:flip to other handler
	lis	r0,2
	a	r3,siobla,r5,r5
	sth	r0,8,r3 		:do a jump command to previous ccw
	j       ccws60
ccws34	LR	R0,r5
	SRLS	R0,1			:do force output SVC
	SVC	IO,20+R0
	JAL	R0,SVCE32		:error handler
	J	ccws60			:common statistics area
    ei		:sylins

      IF	SILINS

ccws10	LH	R3,LRT,kd		:UPDATE LAS
	STH	R3,LAS,kd
	STB	R3,1,R2 		:PUT ACK IN OUTPUT RECORD

	LR	R3,R2
	SRLS	R3,4			:SHIFT 4 BITS RIGHT FOR SIO CCW
	STH	R3,2,R1 		:put address/10 into the CCW

:	the configurable software checksum logic which does not exist
:	unless requested for a link and then is calculated only for those
:	requested links.  All must put len of packet into HW preceding
:	BORI.

       IF	1-S.CKSM		:not doing SW checksums
	SIS	R2,2			:point to SIO frame length
	STH	R7,0,R2 		:STORE BYTE COUNT       ###LSH
       ELSE	:S.CKSM	
	LR	R6,R2			:copy of start of packet for SW CKSMs

:	if doing checksums for any SIO lines
	LB	R2,LKNM,KD		:GET LINK NUMBER
	TBT	R2,KNS.CK		:software checksums for this link?
	JEFS	CCWS15
	LIS	R0,0
	SR	R0,R7			:negative count for microcode
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators

:	the checksum instruction updates the source register every 32
:	halfwords or so. (if current address ANDed with 3E is 0 then
:	address register is updated). so save start address in R6.
	LR	R8,R6			:make copy of start for checksum
	CKSUM	R2,R8			:calculate checksum
	STH	R2,0,R7,R6		:save vertical checksum
	STH	R3,2,R7,R6		:save horizontal checksum
	AIS	R7,4			:add length of checksum
CCWS15	SIS	R6,2			:point to length of frame
	STH	R7,0,R6 		:STORE BYTE COUNT       ###LSH

       EI	:S.CKSM

:	WRITE OUTPUT PROGRAM INTO LINE'S CCW BLOCK 
:	(SEE DEVICE.DOC SEC 1.3.3 FOR DESCRIPTION OF CHANNEL PROGRAMS)

	LIS	R0,0			:MAKE A STOP COMMAND
	STH	R0,4,R1			:PUT IT AFTER OUTPUT COMMAND
	LIS	R0,1			:MAKE AN OUTPUT COMMAND
	STH	R0,0,R1			:AND STORE IT
	lb	r3,siofb,r5
	clb	r3,siotb,r5
	jefs    ccws45			:not a chain
	shi	r3,10			:get previous ccw
	nh	r3,sionch,r5		:wrap within ccw list
	lis	r0,2
	a	r3,siobla,r5,r5
	sth	r0,4,r3 		:do a jump command to previous ccw
	jfs     ccws60

:	START OUTPUT CCW PROGRAM
ccws45	LR	R0,r5			:LINE NUMBER * 2
	SRLS	R0,1			:LINE NUMBER
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVC73B		:ERROR, CRSH

      EI	:SILINS

:	sync and SIO common statistics and bookkeeping
:	common logic for both sync and SIO lines.  For multline links
ccws60  lb	r3,siofb,r5
	ahi	r3,10			:update pointerto free ccw
	nh	r3,sionch,r5		:stay within this line's list
	stb	r3,siofb,r5
       if	multln  		:multi line code
	lb	r3,sioror,kd    
	ais	r3,1
	clb	r3,nlat,kd
	jlfs    ccws64
	lis	r3,0
ccws64  stb	r3,sioror,kd		:line rotation
       ei 	:multln
	lis	r3,1
	ahm	r3,rctrns,r5		:another packet sent
	sth	r3,llxm,cd		:mark packet as sent
	jr	r9


:	have wrapped around to start of window and have to retransmit

ccwrtr  lr      ln,r5
	tbt	r5,sionog
	jnr	r9			:line not free
	lb      r5,siofb,ln
	clb     r5,siotb,ln     	:line already transmitting?
	jnr     r9
	st	r9,ccwdsv
	LHL	R5,NRmk,KD		:DESCRIPTOR ADDR OF NEXT REC TO XMIT

:	frequently we sent a retransmissio due to closing the window and
:	having a neighbor which is slow to ack so give slight pause between
:	closing the window and resending the packet since takes real time
:	to send a packet so make sure it has to be done before doing it.###sdw
	SBT     KN,SIOBTR		:set retransmission bit 	###sdw
	JEFS    ccwrt1  		:previous wasn't retransmission ###sdw
	L	R10,SIOBTT,kd		:get time to send next retr     ###sdw
	s	r10,fastc,,		:get current time       	###sdw
	jgr	r9			:no, wait until time    	###sdw

ccwrt1  L	R10,FASTC,,		:get current time       	###sdw
	ah      r10,rtrdel,ln		:make sure other line finished outtput
					:before sending another rxmission
					:and just a good pacing rate
	ST	R10,SIOBTT,kd		:save time to do retransmission ###sdw
	LIS	R7,1			:YES - COUNT RETRANSMISSIONS
	AHM	R7,TRRXMT,LN		:	BY LINE

	lb	r1,siofb,ln		:get address of CCW
	a	r1,siobla,ln,ln
	sth     ln,lnidle,kd		:link has a line sending stuff
	lr	r4,kd			:for usage
	JAL	R10,SIOSND		:START OUTPUTTING THE RECORD
	if	sylins			:if both then have to worry
	if	silins
	clhi    ln,(sylins)*2
	jgefs	siot4	  		:send it on the sio line
	ei	:silins
	
SIOT3S	LIS	R0,0			:put stop after command
	STH	R0,8,R1			:clear the jump rotor
	LIS	R0,1			:make an output command
	STH	R0,0,R1			:store it into rotor
	LR	R0,LN
	SRLS	R0,1			:do force output SVC
	SVC	IO,20+R0
	JAL	R0,SVCE32		:error handler
	if	silins
	Jfs	SIOPT4			:rejoin mutual code	
	ei	:silins
       ei	:sylins

      IF	SILINS			:only for SIO lines
SIOT4	LIS	R0,0			:MAKE A STOP COMMAND
	STH	R0,4,R1			:PUT IT AFTER OUTPUT COMMAND
	LIS	R0,1			:MAKE AN OUTPUT COMMAND
	STH	R0,0,R1			:AND STORE IT

:	START OUTPUT CCW PROGRAM
	LR	R0,LN			:LINE NUMBER * 2
	SRLS	R0,1			:LINE NUMBER
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRSH
      EI	:SILINS

:	common logic for both sync and SIO lines.  For multline links
:	update the queue of next line to service.  For all lines update
:	the output status, and update the pointer to the next free
:	rotor/CCW.							###asq

SIOPT4	HS	0
       if	multln
	JAL	R10,BSIOTR		:update pointer to next line    ###sdw
       ei 	:multln

	LB	R5,SIOFB,LN		:bump up free port
	AHI	R5,10			:point to next CCW
	nh	r5,sionch,ln		:wrap if needed
	STB	R5,SIOFB,LN		:and fall through to try to send more
	l	r9,ccwdsv
	jr	r9			:done, return


	DEFAULT(RTRPAC,RATE/$A13) 	:wait 13th between retransmissions#sdw
rtrwat  hc      0       		:line speed 0 is of a down neighbor
q       eq      0
	re      1f      		:number of line speeds
q       eq      q+1     		:avoid the 0 case
       if	(12c/q)-rtrpac  	:use time to send if bigger than defaul
	hc      (12c/q)
       else
	hc      rtrpac
       ei
      er
syad(RTRWAT)


::*********************************************************************
::
::	SUBROUTINE:	SIOSND:
::	FUNCTION: SIO lines:	ROUTINE TO SET UP TO TRANSMIT A DATA RECORD.
::			MOVES IT FROM THE SECTOR TO AN OUTPUT BUFFER.
::			SETS UP THE APPROPRIATE HEADER, CALCULATES CHECKSUMS,
::			AND UPDATES LAS IN THE LINK DESCRIPTOR.
::		  SYNC lines:	Routine to set up to transmit a data record.
::			Put ack into packet, do checksum, write len and
:			address into rotor do mutual link/line statistics.
::	CALLING SEQ:	JAL	R10,SIOSND
::	INPUT:		R1 = POINTER TO rotor/CCW BLOCK TO OUTPUT NEXT RECORD
::			R5 = POINTER TO RECORD DESCRIPTOR
::
::*********************************************************************

SIOSND	Lh	R7,ERECsz,R5		:GET RECORD BYTE COUNT BY SUBTRACTING
	L	R2,BREC,R5		:BEGINNING POINTER 

    if	sylins
      IF	SILINS			:check is to do SIO lines
	CLHI	LN,(NLINES-SILINS)*2	:sio line?
	JGE	SIOSN1			:yes
      EI	:SILINS

:	sync line, first put ack into record then do checksum, the put
:	address and length of record into rotor, then jump to common 
:	statistics area.

	LHL	R3,LRT,kd		:put ack into packet
	STH	R3,LAS,kd		:remember that we sent it
	STB	R3,1,R2			:second byte is ack

:	sync line, write length and address to rotor
	ST	R2,4,R1			:save address of data
	AIS	R7,4			:include size of checksum
	STH	R7,2,R1			:store length including cksum
	SIS	R7,4			:back to length of packet

:	sync line, do checksum
	LR	R6,R2			:make copy of start of packet
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators
	LIS	R0,0
	SR	R0,R7			:negative count for microcode

:	the checksum instruction updates the source register every 32
:	halfwords or so. (if current address ANDed with 3E is 0 then
:	address register is updated). so save start address in R6.
	LR	R8,R6			:make copy of start for checksum
	CKSUM	R2,R8			:calculate checksum
	STH	R2,0,R7,R6		:save vertical checksum
	STH	R3,2,R7,R6		:save horizontal checksum
	if	silins
	J	SIOHS2			:common statistics area
	ei	:silins
    ei		:sylins

      IF	SILINS

SIOSN1	LH	R3,LRT,kd		:UPDATE LAS
	STH	R3,LAS,kd
	STB	R3,1,R2 		:PUT ACK IN OUTPUT RECORD

	LR	R3,R2
	SRLS	R3,4			:SHIFT 4 BITS RIGHT FOR SIO CCW
	STH	R3,2,R1 		:put address/10 into the CCW

:	the configurable software checksum logic which does not exist
:	unless requested for a link and then is calculated only for those
:	requested links.  All must put len of packet into HW preceding
:	BORI;

       IF	1-S.CKSM		:not doing SW checksums
	SIS	R2,2			:point to SIO frame length
	STH	R7,0,R2 		:STORE BYTE COUNT       ###LSH
       ELSE	:S.CKSM	
	LR	R6,R2			:copy of start of packet for SW CKSMs

:	if doing checksums for any SIO lines
	LB	R2,LKNM,KD		:GET LINK NUMBER
	TBT	R2,KNS.CK		:software checksums for this link?
	JEFS	SIOSN4
	LIS	R0,0
	SR	R0,R7			:negative count for microcode
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators

:	the checksum instruction updates the source register every 32
:	halfwords or so. (if current address ANDed with 3E is 0 then
:	address register is updated). so save start address in R6.
	LR	R8,R6			:make copy of start for checksum
	CKSUM	R2,R8			:calculate checksum
	STH	R2,0,R7,R6		:save vertical checksum
	STH	R3,2,R7,R6		:save horizontal checksum
	AIS	R7,4			:add length of checksum
SIOSN4	SIS	R6,2			:point to length of frame
	STH	R7,0,R6 		:STORE BYTE COUNT       ###LSH

       EI	:S.CKSM
      EI	:SILINS

:	sync and SIO common statistics and bookkeeping

SIOHS2	LIS	R0,1			:MARK RECORD AS BEING SENT
	STh	R0,LLXM,R5		
	AHM	R0,RCTRNS,LN		:UPDATE NUMBER OF RECORDS SENT
:	R5 has record descriptor R4 has link descriptor pointer		###jhl
	LH	R7,FASTC+2,,		:GET CURRENT TIME
	LH	R8,PKTTIM,r5		:GET TIME PACKET WAS MADE OR RE-XMITTED
	STH	R7,PKTTIM,r5		:STORE BACK CURRENT TIME
	SR	R7,R8			:COMPUTE TIME IN QUEUE
	JGEFS	SIOS10			:NO WRAP
	AI	R7,10000
SIOS10	AM	R7,KS.PQC,kd		:ADD CURRENT DELAY INTO RUNNING COUNT
					: -- end --			###jhl
	JR	R10			:RETURN TO CALLER


::*********************************************************************
::
::	SUBROUTINE: BSIOTR
::	FUNCTION: updates pointer to next to service on multiline line
::	CALLING SEQ:   R10
::	INPUT: R4 (link descriptor), SIOROR, NLAT
::	OUTPUT: SIOROR points to next line
::
::*********************************************************************

:	BSIOTR - links on r10 and is called from SIOT4 and SION5
BSIOTR	LB	R9,NLAT,R4		:multi line link
	SIS	R9,1
	JER	R10
	LB	R7,SIOROR,R4		:current line #
	AIS	R7,1
	CR	R7,R9			:don't past end of list
	JLEFS   BSIOT2  		:still within list
	LIS	R7,0
BSIOT2  STB	R7,SIOROR,R4		:save pointer
	JR	R10


::*********************************************************************
::
::	SUBROUTINE: BSIOSW
::	FUNCTION: services the next line on the multiline's  rotation
::	CALLING SEQ: R10
::	INPUT: LN, SIOROR, SIOROT, R4 (link descriptor)
::	OUTPUT: returns if not switching line, else goes to state (SIOTST)
::	       of the other line on the multiline sio link.
::								###sdw
::*********************************************************************

BSIOSW	LB	R6,NLAT,R4		:number of attached lines
	SIS	R6,1
	JER	R10			:not multiline
	LB	R5,SIOROR,R4		:pointer within list
	LB	R6,SIOROT,R4,R5 	:next line to send a packet on
	CR	R6,LN			:different line than current?
	JER	R10			:no, nothing special to do

:	section for switch line
	LH	R0,SIOROL		:line already saved?
	JGEFS   BSIOW3  		:yes, don't overwrite
	STH     LN,SIOROL		:save original line
BSIOW3  LR      LN,R6			:other line gets the data
	LHL	R6,SIOTST,LN
	J       SEG1,R6,		:do other line

:	this checks to see if the link has has a line with a free
:	ccw/rotor after returning any ccws/rotors that have completed to
:	the free state

       if	multln  		:this is multi line logic
CCWCHK  LB	R8,NLAT,KD		:get number of attached lines
ccwe.0  LB	R5,SIOROR,KD
	LB	R5,SIOROT,R5,KD 	:get line number
       else     :not supporting multi
CCWCHK  HS      0
CCWE.0  LB      R5,SIOROT,KD    	:just get line number
       ei 	:multln
:	entry with line already in r5 (must enter with r10<1)
ccwe.a  tbt	r5,sionog		:line not being initialized?
	jnr	r9
	rbt	r5,linsvd		:this line was serviced
	lh	r7,lnidle,kd		:was link's line idle?
	jl      4,r9			:yes, so nothing to check
	L	R7,SIOBLA,R5,R5		:start of ccw block
	LB	R6,SIOTB,R5		:transmitting CCW
	CLB	R6,SIOFB,R5		:all full or all empty
	JE	CCWE.F			:check out which of the two
:	here to check a ccw
CCWCH0	LH	R0,0,R6,R7		:status of oldest sending CCW
:	status of 200 (completed) or 100 (completed and jumped) for SIO
:	and status of 0000 (completed) for sync.  Status of 1 if still
:	sending (both SIO and Sync).  Thus, check low byte to see if 
:	this ccw is done.
	LBR	R1,R0			:completed?
	JEFS	CCWCH1			:yes
CCWCHX	STB	R6,SIOTB,R5		:store oldest transmitting CCW
	J	4,r9			:some CCWs are free
:	here to return a CCW which mean we must also check for a chain
CCWCH1
	if	sylins
	if	silins
	CLHI    R5,(NLINES-SILINS)*2    :is it a sync line
	JGEFS	CCWCH2			:no, an SIO line
	ei	:silins
	LH	R0,8,R6,R7		:get status of the chain
	ei	:sylins
CCWCH2	AHI	R6,10			:is the next ccw our free ccw?
	nh	r6,sionch,r5		:stay within line's output list
	CLB	R6,SIOFB,R5		:A single or a chain?
	JE	CCWCHX			:single, so done
:	here to check the status of the chain
       if	silins
	if	sylins
	CLHI	R5,(NLINES-SILINS)*2
	JL	CCWCSY			:do sync there
	ei	:sylins
	SHI	R0,100			:jump succeeded?
	JE	CCWCH0			:yes, check next ccw
	STB	R6,SIOTB,R5		:did return upto this point
	SRLS	R5,1			:make line# *1
	AR	R6,R7			:address of CCW in r6
	LIS	R0,1
	STH	R0,0,R6			:store jump command
	SVC	IO,0B0+R5		:do output
	JAL	R12,SVC53B		:crash if bad
	ar	r5,r5			:restore r5
	J	4,R9			:and no more ccws tocheck
       ei 	:silins

:	here to see if a sync chain succeeded
	if	sylins
CCWCSY	LR	R0,R0			:see if chain completed
	JE	CCWCH0			:0 is completed
	STB	R6,SIOTB,R5		:did free upto here
	SRLS	R5,1
	AR	R6,R7			:make address
	LIS	R0,1
	STH	R0,0,R6
	SVC	IO,20+R5		:sync output svc
	JAL	R12,SVCE32
	ar	r5,r5			:restore r5
	J	4,R9			:and no more ccws to check
	ei	:sylins

:	here if CCW is either full or empty.  Check CCW before current
:	pointer, if it is transmitting then we have a transmitting chain.
:	If it isn't transmitting then either previously we had no output
:	or a complete chain completely unwound.  (chain would have unwound
:	since ccw before current free ccw is the most recent ccw and thus
:	if it is finished transmitting than all older than it would have
:	also finished).  If was idle or chain completely unwound then we
:	have no active CCWs.
CCWE.F	LR	R1,R6
	SHI	R1,10			:get CCW prior to current
	nh	r1,sionch,r5		:stay within ccws
	LB	R0,1,R1,R7		:get it's status
	Jnfs	ccwe.4			:not sending, so all idle
       if	multln  		:some more multi line code
	lb	r0,nlat,kd
	sis	r0,1
	jnfs    ccwe.3
       ei 	:multln
	ts      lnidle,kd		:link has no lines sending data
ccwe.3  j       4,r9
ccwe.4	LHL	R0,0,R6,R7		:get status of oldest sending
	LBR	R1,R0			:is it still sending?
	JE	CCWCH1			:unwind the chain
       if	multln  		:code for multi line
	sis	r8,1			:check all lines for this link
	jler    r9
	lb	r5,sioror,kd
	ais	r5,1
	clb	r5,nlat,kd
	jlfs    ccwe.2
	lis	r5,0
ccwe.2  stb	r5,sioror,kd		:try another line
	j       ccwe.0
       else     :only single line links
	jr      r9
       ei 	:multln



::*********************************************************************
::
::	OUTPUT STATE:	SIORT -- WAIT FOR RESET TO FINISH BEING SENT.
::	EACH TIME A PING-PONG RESET IS SENT, IT'S OUTPUT TIME IS
::	IS CLOCKED FOR LINE SPEED CALCULATION.  DUE TO THE POLLING
::	OF SIO FOR OUTPUT COMPLETE (WITHIN THE SYLVER LOOP), THERE
::	ARE ALWAYS OCCURENCES OF LATE OBSERVENCE OF OUTPUT COMPLETE.
::	FOR THE 16d RESETS CLOCKED DURING THE RESET SEQUENCE, THE
::	FASTEST CLOCKED SAMPLE IS USED FOR THE LINE SPEED CALCULATION
::	IN AN ATTEMPT TO SOMEWHAT ALLEVIATE THE INACCURACIES IN
::	CALCULATING LINE SPEEDS OF 28.8 AND GREATER.  NOTE -
::	THIS PROBLEM BECOMES MORE APPARENT ON HEAVILY LOADED NODES.
::	As this always is running in the Background it is possible that
::	a heavily loaded node will not have an accurate determination.
::	The speed can be set in the tiilnk in such cases.
::	Note:  The line attach logic sets this state for both SIO and sync
::	lines.  Sync lines calculate line speed by checking the rate of
::	sync input so sync lines skip over the line speed calculation
::	once previous output of reset packet has completed.  It has to
::	wait for previous output to complete since Line Attach logic
::	checks current state.
::
::*********************************************************************

SIORT	HS	0			:###LSH
	if	sylins
      IF	SILINS
	CLHI	LN,(NLINES-SILINS)*2	:sync line speed is done on input
	JGE	SIOR17			:sio line needs line speed guess
      EI	:SILINS
	L	R1,SIOBLA,LN,LN		:see if reset completed trasmitted
	LHL	R0,0,R1
	JN	SIOIDL			:0 is command completed
	J	SIOR19			:done, but skip over line speed stuff
	ei	:sylins
      IF	SILINS
SIOR17	L	R1,SIOBLA,LN,LN 	:CCW address
	LB	R0,0,R1			:STATUS 2 MEANS "FINISHED"
	SIS	R0,2			:IF IT'S NOT A 2 THEN RETURN 
	JN	SIOIDL			:	TO SERVICE NEXT LINE
	LH	R1,FASTC+2,,		:CALCULATE TIME SINCE OUTPUT
	SH	R1,LNRTIM,LN		:WAS STARTED
	LHR	R1,R1			:ADJUST TO HALFWORD VALUE

	JGEFS	SIOR18			:CHECK FOR NEGATIVE INDEX
	LIS	R1,0			:DON'T LET IT GO BELOW 0
SIOR18	LIS	R2,1			:ASSUME SLOWEST SPEED
	CLHI	R1,0C4			:IF RESET TOOK OVER C4 CLOCK TICKS,
	JGEFS	SIOR1C			:IT'S 2.4KB, REPORT VALUE 01
	LB	R2,SIOSPD,R1,		:GET SIO LINE SPEED FROM TABLE
SIOR1C	LHL	R1,BAUDRT,LN		:GET PREVIOUS SPEED CALCULATION
	CLR	R2,R1			:IF NEW CALC IS FASTER, USE IT
	JLEFS	SIOR19			:OTHERWISE LEAVE PREVIOUS CALC
	STH	R2,BAUDRT,LN		:SAVE THE LINE SPEED
	lhl	r0,silspd,ln		:get configured line speed
	jefs	sior1e			:not declared, use calculated as real
	lr	r2,r0			:use configured as 'real'
sior1e	STH	R2,BAUDRR,LN		:SAVE THE 'real' LINE SPEED
      EI	:SILINS
SIOR19	LHI	R0,SIOIDL-SEG1		:GO TO THE IDLE STATE
	STH	R0,SIOTST,LN
	J	SIOIDL

::*********************************************************************
::
::	TABLE:	 SIOSPD - INDEXED BY THE NUMBER OF FASTC CLOCK TICKS
::	TO TRANSMIT A 1000d-BIT RESET PACKET. THE TABLE VALUE IS SAVED
::	IN 'BAUDRT', THE LINE SPEED ARRAY.
::
::		600d/FASTCTICKS = KBS/SEC	
::
::	!! THIS TABLE ASSUMES RATE = $A 600 !!
::
::*********************************************************************

SIOSPD	HS	0
	NOLIST
	RE	0A-00; BC 1F; ER	:00 - 09, MS	 (UP     - 66.6 KB)
	RE	0D-0A; BC 17; ER	:0A - 0C, 56  KB (60  KB - 50   KB)
	RE	10-0D; BC 14; ER	:0D - 0F, 48  KB (46  KB - 40   KB)
	RE	15-10; BC 10; ER	:10 - 14, 38.4KB (37.5KB - 30   KB)
	RE	1C-15; BC 0C; ER	:15 - 1B, 28.8KB (28.5KB - 22.2 KB)
	RE	27-1C; BC 08; ER	:1C - 26, 19.2KB (21.4KB - 15.78KB)
	RE	36-27; BC 06; ER	:27 - 35, 14.4KB (15.0KB - 11.3 KB)
	RE	48-36; BC 04; ER	:36 - 47,  9.6KB (11.1KB - 8.4  KB)
	RE	63-48; BC 03; ER	:48 - 62,  7.2KB ( 8.3KB - 6.1  KB)
	RE	0C4-63; BC 02; ER	:63 - C3,  4.8KB (6.06KB - 3.07 KB)
	RE	0C5-0C4; BC 01; ER	:0C4 - UP, 2.4KB (3.06KB -    DOWN)
	HS	0
	LIST

::**********************************************************************
::
::      OUTPUT STATE:   SIORWT -  waiting for SIO connect input to complete
::      SIORWT  wait give SIO connect output enough time to initialize
::	       After time is up then connect output and restore prior
::		sio state.						###sdw
::**********************************************************************

SIORWT
      IF	SILINS
	L	R0,SIOTIM,LN,LN 	:get time when wait is over
	C	R0,FASTC,,		:to current time		###sdw
	JGE     SIOIDL  		:not yet
       IF	 HMICRO  		:only on HDLC mic can we notice timout
	L	R8,SIOIPG,LN,LN		:address of init prog for this line
	LHL	R4,18,R8		:address of last CCW
	LHI	R0,6			:restore command in init program###sdw
	STH	R0,18,R8
	CLHI	R4,0200			:finish output? 		###sdw
	JE	SIORW2			:connect output successful      ###sdw
	LCS	R8,6			:didn't complete, flag as timout##sdw
	LHI	R3,MSBASE,LN		:back to SIO line number	###sdw
	SLLS	R3,3			:times 8 (now 16*sio line #)    ###sdw
	STH	R8,8,R3			:will be retried in 2 secs      ###sdw
	LR	R0,LN			:get real line #		###sdw
	SRLS	R0,1
	SBT	R0,SIOPTA		:flag port unavailable		###sdw
	JFS	SIORW3			:don't quit since want to restore state
SIORW2	LR	R0,LN			:real line #    		###sdw
	SRLS	R0,1			:from line # * 2 to line #
	RBT	R0,SIOIGN		:let crpypto report reinits     ###sdw
SIORW3
	EI	:HMICRO
	L	R1,SIOIN,LN,LN	:POINT TO INPUT CCW BLOCK ADDRESS
	LR	R0,LN			:have 2*line #  		###sdw
	SRLS	R0,1			:make it real line number       ###sdw
	TBT	R0,SIOPTA	:IS SIO PORT AVAILABLE ?		###OAS
	JNFS	SIORW5		:NO, SKIP SVC
	SVC	IO,0A0		:START INPUT
	JAL	R12,SVCE3A	:ERROR CRASH
SIORW5	LHL	R1,SIOTSV,LN		:restore former state   	###sdw
	STH	R1,SIOTST,LN		:to current state       	###sdw
	rbt     ln,sionog		:line nowusable
      EI	:SILINS
	J       SIOIDL

::**********************************************************************
::
::      OUTPUT STATE:   SYNRWT -  let sync signals DTR and RTS stabilize
::	       before going on with other SVCs.  Restore saved output
::	       state and clear rotor commands.  Note that ISIS does not
::		write 0 indicating that is completed a command if the
::		sync line does not support DTR and DSR so we must clear it.
::									###sdw
::**********************************************************************

SYNRWT
	if	sylins
	LH	R0,SIOTSV,LN		:get previous state
	STH	R0,SIOTST,LN		:set it as current state
	L	R1,SIOBLA,LN,LN 	:clear any remnants of command
	LIS	R0,0
	STH	R0,0,R1 		:clear command fields
	STH	R0,8,R1
	STH	R0,10,R1
	STH	R0,18,R1		:no leftover garbage to confuse
	rbt     ln,sionog
	ei	:sylins
	J       SIOIDL

::*********************************************************************
::
::	OUTPUT STATE:	SIORS - SEND SINGLE RESET FOR PING-PONG SEQ AND
::				 SPEED CLOCKING
::
::*********************************************************************

SIORS	LHI	R9,SIORT-SEG1		:CHANGE TO SIORT TO CLOCK SPEED
	J	SIOR1			:FINISH PREV OUTPUT, SEND RESET

::*********************************************************************
::
::	OUTPUT STATE:	SIORR - SEND CONTINUOUS STREAM OF RESETS
::
::*********************************************************************

SIORR   LR	R9,LN
	SRLS	R9,1			:make R9 into line number
	RBT	R9,SIORPC		:bits set every 1 second by G01SEC
	JE      SIOIDL  		:already send reset for this second
	LHI	R9,SIORR-SEG1		:MAINTAIN SAME STATE

::*********************************************************************
::
::	COMMON SIO OUTPUT:
::	WAIT FOR PREVIOUS OUTPUT TO COMPLETE BY DISMISSING TO SIOIDL.
::	WHEN COMPLETE, CHANGE SIO OUTPUT STATE AS INDICATED BY R9 AND
::	START NEW OUTPUT.  ALSO MARK RESET OUTPUT START TIME.
::
::*********************************************************************

SIOR1	L	R1,SIOBLA,LN,LN
	if	sylins
	if	silins
	CLHI	LN,(NLINES-SILINS)*2	:SIO or sync line?
	JGE	SIOR4			:SIO line
	ei	:silins
:	for sync line, make sure previous output has completed before
:	trying to send reset.  Must check the first jump rotor (+8) since
:	line initialization uses it to bring up DSR.			###sdw

	LHL	R0,0,R1			:current output command
	JN	SIOIDL			:not 0, still transmitting
	LHL	R0,8,R1			:for all rotors that might be sending
	JN	SIOIDL
	LHL	R0,10,R1		:and other main ouput rotor
	JN	SIOIDL

:	save caller's desired state and send the reset packet.
	STH	R9,SIOTST,LN		:maybe changing state
	L	R2,SDLN,LN,LN		:get address of reset descriptor
	AHI	R2,XRSTP		:now start of transmitted reset packet
	ST	R2,4,R1			:write address of data to rotor
	LHI	R3,XSDSZ		:how much to transmit
	STH	R3,2,R1			:write length of reset to rotor
	LIS	R3,1			:output command
	STH	R3,0,R1
	LR	R0,LN
	SRLS	R0,1			:got line number * 1
	SVC	IO,20+R0		:force output
	JAL	R0,SVCE32		:error
	J	SIOIDL			:done for now
	ei	:sylins

:	send reset on SIO line if transmitter idle
SIOR4
      IF	SILINS
	LB	R0,0,R1			:CHECK STATUS OF OUTPUT
	JE	SIOIDL			:CURRENT BLOCK IS BUSY
	SIS	R0,1
	JE	SIOIDL			:###wjl
	STH	R9,SIOTST,LN		:MAYBE CHANGE STATE
	L	R2,SIORSP,LN,LN		:QUADWORD PNTR TO RESET PATTERN
	SRLS	R2,4
	ni	r2,0ffff		:in case macv with 6 byte address
	EXHR	R2,R2			:STORE BOTH ADDRESS AND
	ST	R2,2,R1			:FOLLOWING STOP COMMAND
SIR12	LIS	R0,1			:SET OUTPUT COMMAND
	STH	R0,0,R1
	LR	R0,LN			:LINE NUMBER * 2
	SRLS	R0,1			:LINE NUMBER
	TBT	R0,SIOPTA		:IS PORT AVAILABLE?		###OAS
	JNFS	SIOPT6			:NO, SKIP SVC
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRASH
SIOPT6	LH	R0,FASTC+2,,		:SAVE TIME FOR SPEED CALCULATION
	STH	R0,LNRTIM,LN
      EI	:SILINS

:	LOOP TIL ALL SIO LINES CHECKED
SIOIDL	J	SIOO01			:CONTINUE

:	DISMISS SYLVER TO ISIS OR EXEC LOOP

SDSMIS	HS	0
	if      tii.fg  	:if foreground
	j       sylver  	:goto back and do it again (after a dismiss)
       else     :sylver called from BG
	l	r10,dssvrt
	jr	r10
       ei 	:tii.fg

	SUBTTL	LINKER (SYLVER - Sync input processor)

::*********************************************************************
::
::	ENTRY POINT:	SYLMRK:
::	FUNCTION:	COME HERE TO SEARCH FOR BEGINNING OF FRAME
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R9,NETDGN
::			JAL	R0,TSFMRK
::			JAL	R2,SYALGN
::	RETURNS:	J	SYLRET
::
::*********************************************************************

	if	sylins
SYLMRK	SCAN	R11,R13		:for normal engine			###%cc
	JFS	SYLHIT			:FOUND 'START BIT'
	J	SYLRET			:NOT YET, TRY NEXT LINE

:	FOUND START OF RECORD -- GUARANTEED AT LEAST 16 BYTES OF
:	DATA IN THE INPUT RING

SYLHIT	LHL	R3,0,R13,R12		:GET FIRST HALFWORD OF RAW DATA
	LCS	R1,1			:SET UP MASK
	XR	R1,R3			:SET MARK BITS TO ZERO

	JFFOH	R1,SYMK10		:GET LEFT SHIFT COUNT TO R2
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
:	SYNC RING SCAN INSTRUCTION INDICATES ZERO BIT FOUND, BUT LOAD
:	HALF-WORD YIELDS ALL ONES...FORMAT DIAGNOSTIC NODE REPORT.
:	WE CAN'T CALL REPORTING ROUTINE SINCE WE ARE IN FOREGROUND. SET
:	UP RELEVANT DATA IN WORK AREA - SWITCH WILL TEST SEMAPHORE (SUPIBF).
	srls	ln,1
	STB	LN,SUPIBF+3		:SAVE LINE NUMBER
	slls	ln,1
	STH	R13,SUPIBF+4		:ROUGH POINTER TO PROBLEM AREA
	LIS	R8,DR.SYM
	STB	R8,SUPIBF+2		:DIAGNOSTIC SUB-TYPE FOR SYNC SCAN ERR
	STH	R8,SUPIBF		:POSITIVE VALUE MEANS MSG READY TO SHIP
	EI	:DB.DEB

SYMK10	AIS	R12,2			:INC TRAILING POINTER
	NHI	R12,SVNBSZ-2		:CORRECT FOR WRAP AROUND
	LHL	R4,0,R13,R12		:PICK UP NEXT 16 BITS
	LR	R5,R3			:COPY OF FIRST 16 BITS
	SLL	R5,0,R2			:LEFT ALIGN THE BITS
	LIS	R10,0F			:GET COMPLEMENT OF LEFT
	SR	R10,R2			:	SHIFT COUNT TO R10
	SRL	R4,1,R10		:ALIGN REST OF BITS
	OR	R4,R5			:R4 CONTAINS HEADER
	NI	R4,0FFFF		:	HALFWORD -- RIGHT ALIGNED
	JNFS	SYMK12
	LIS	R0,1			:GOT 16 BITS OF ZEROES - INDICATE
	AHM	R0,SPACNG,LN		:	SPACING DETECTED ON INPUT
	J	SYNEXT

SYMK12	L	KD,KDLN,LN,LN		:GET LINK DESCRIPTOR ADDRESS
	JL	SYLUAL			:GO TREAT RECORD ON UNASSIGNED LINE
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB01			:NO
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	STH	R4,TSFTBL+2,R15		:STORE POTENTIAL HEADER
	LIS	R0,TS.HDR
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	L	R15,TSRSVE		:RESTORE R15
TSLB01	EI	:TSTSZE

:	RECORD RECEIVED ON ATTACHED TYMNET-II LINK.
:	REGISTER 4 CONTAINS FIRST HALFWORD OF HEADER -- RIGHT ALIGNED.

SYBT2	EXBR	R0,R4			:ISOLATE BORI
	NHI	R0,0F0			:
	CLB	R0,BORI,KD		:IS IT BORI?
	JN	SYBT22			:NO, SKIP

:	TYMNET II RECORD RECEIVED. NOT RESET OR NULL.
:	MAKE SURE ALL THE DATA IS IN INPUT RING.

	EXBR	R1,R4			:EXTRACT BYTE COUNT INDEX
	NHI	R1,0F
	LB	R1,SYTWCN,R1		:GET ACTUAL COUNT FROM TABLE

:	SEE IF COMPLETE RECORD HAS BEEN RECEIVED

SYLCHK	LR	R0,R11			:COPY OF LEAD POINTER
	SR	R0,R12			:RECEIVED COUNT=LEAD-TRAIL
	JGEFS	SYCH10			:SKIP IF NO WRAP AROUND
	AHI	R0,SVNBSZ		:CORRECT FOR WRAP AROUND

SYCH10	SIS	R0,8			:NEED TWO WORDS BEYOND EOR
	CR	R0,R1			:GOT THEM?
	JG	SYWT20			:YES
					:NO, DONE FOR NOW

:	SAVE COUNT, SHIFT, HEADER, AND SET TO WAIT FOR RECEPTION
:	OF COMPLETE RECORD

SYLSAV	STH	R1,SYBCNT,LN		:SAVE BYTE COUNT
	STH	R10,SYLSHF,LN		:SAVE LEFT SHIFT -- COMPLEMENTED
	STH	R4,SYHEDR,LN,LN		:SAVE ALIGNED HEADER
	STH	R3,SYHEDR+2,LN,LN	:SAVE FIRST 16 BITS RAW DATA
	LHI	R0,SYWAIT-SEG1		:SET 'STATE'
	STH	R0,QSYLVR,LN
	J	SYLRET			:DONE

:	CHECK FOR EXPANDED RESET 
SYBT22	CLHI	R4,TXRSHD		:Expanded Reset header?
	JN	SYBT25			:no
	JAL	R9,SYLXRS		:yes, store Reset in SYSTOR
	L	KD,KDLN,LN,LN		:restore link descriptor address
	LHL	R0,NDID,KD		:get neighbor # from link descriptor
	CL	R0,SYSTOR+2		:compare to FW following Reset header
	JE	SYLRAL			:equal-reset received on attached line 
	J	SYLERR			:no - line error

::*********************************************************************
::
::	SUBROUTINE:	SYLXRS:
::	FUNCTION:	Check to see if complete Expanded Reset has been
::			received and move to temporary storage.
::	CALLING SEQ:	JAL	R9,SYLXRS  Called from SYBT22 for reset
::			on assigned line and from SYLUAL for reset on
::			unassigned line.
::	INPUT:		R3, R4, R10, R11, R12, LN
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::
::*********************************************************************

:	CHECK TO SEE IF COMPLETE EXPANDED RESET HAS BEEN RECEIVED
SYLXRS	EXBR	R1,R4			:extract byte count index
	NHI	R1,0F
	LB	R1,SYTWCN,R1		:get actual count from table
	LR	R0,R11			:make copy of lead pointer
	SR	R0,R12			:received count = lead-trail
	JGEFS	SYLX02			:skip if no wrap around
	AHI	R0,SVNBSZ		:correct for wrap around
SYLX02	SIS	R0,8			:need 2 words beyond EOR
	CR	R0,R1			:got them?
	JG	SYLX04			:yes

:	NO, SAVE RETURN, SHIFT, HEADER, AND SET TO WAIT FOR COMPLETION.
	ST	R9,SYLLNK,LN,LN		:save return
	STH	R1,SYBCNT,LN		:save byte count
	STH	R10,SYLSHF,LN		:save left shift -- complemented
	STH	R4,SYHEDR,LN,LN		:save aligned header
	STH	R3,SYHEDR+2,LN,LN	:save 1st 16 bits raw data
	LHI	R0,SRWAIT-SEG1		:set 'state'
	STH	R0,QSYLVR,LN
	J	SYLRET			:done for now

::*********************************************************************
::
::	ENTRY POINT:	SRWAIT:
::	FUNCTION:	Check to see if complete Expanded Reset has been
::			received
::	CALLING SEQ:	LHL	R1,QSYLVER,LN
::			J	SEG1,R1,,
::	INPUT:		R11, R12, LN
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::	RETURNS:	JLE	SYLRET
::
::*********************************************************************

SRWAIT	LR	R0,R11			:make copy of lead pointer
	SR	R0,R12			:received count = lead-trail
	JGEFS	SRWA02			:skip if no wrap around
	AHI	R0,SVNBSZ		:correct for wrap around
SRWA02	SIS	R0,8			:need 2 words beyond EOR
	CH	R0,SYBCNT,LN		:got them?
	JLE	SYLRET			:not yet

	LHI	R0,SYLMRK-SEG1		:yes, next time look for start
	STH	R0,QSYLVR,LN		: of new record
	LHL	R4,SYHEDR,LN,LN		:get aligned HW of header
	LHL	R3,SYHEDR+2,LN,LN	:get 1st HW of raw data
	LHL	R10,SYLSHF,LN		:get left shift count (complemented)
	L	R9,SYLLNK,LN,LN		:get return
	LHL	R1,SYBCNT,LN

:	MOVE EXPANDED RESET INTO TEMPORARY STORAGE
SYLX04	SRHLS	R1,1			:convert to halfword count
	AIS	R1,1			:move VRC also
:	since we looked up the size we know it is legal
:	CLHI	R1,SYSTSZ		:compare with sync storage size
:	JG	SYLERR			:future reset may be too large for us
	LA	R8,SYSTOR		:put data in temp storage
	JAL	R2,SYALGN		:move the data
	JN	SYLERR			:CC<>0 => bad checksum
	JR	R9			:return

:	MUST BE SHORT RECORD -- ALIGN IT AND LOOK FOR POSSIBLE RECORD TYPES

SYBT25	LIS	R1,3			:MOVE 4 HALFWORDS
	LA	R8,SYSTOR		:STORE IN TEMPORARY AREA

	JAL	R2,SYALGN		:MOVE THE DATA

	JN	SYLERR			:BAD CHECKSUM

:	GOOD CHECKSUMS -- R4 STILL HAS FIRST HALFWORD

SYBT27	LHL	R0,NDID,KD		:GET NEIGHBOR # FROM LINK DESCRIPTOR
	CLH	R0,SYSTOR+2		:COMPARE TO HW FOLLOWING RESET HEADER
	JE	SYLRAL			:RESET RECEIVED ON ATTACHED LINE
SYBT28	L	R4,SYSTOR		:GET FIRST 32 BITS OF DATA
	CLI	R4,TWDMHD		:DUMMY RECORD?
	JN	SYLERR			:NO - LINE ERROR

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB02			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:MAKE NEW EVENT ENTRY
	LIS	R0,TS.DUM
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE
	LIS	R0,0
	STH	R0,TSFTBL+2,R15		:NO DATA FOR HEADER FIELD
	L	R15,TSRSVE		:RESTORE R15
TSLB02	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1
	SBT	R0,LNGREC		:SET GOOD REC REC'D FLAG
	J	SYNEXT			:CHECK FOR MORE TO DO

::*********************************************************************
::
::	ENTRY POINT:	SYWAIT:
::	FUNCTION:	COME HERE TO SEE IF ENTIRE PHYSICAL RECORD
::			IS IN THE RING YET
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R9,SYFORM
::			JAL	R0,TSFMRK
::			JAL	R8,TSNSPK
::	RETURNS:	J	SYLRET
::
::*********************************************************************

SYWAIT	LR	R0,R11			:COPY LEAD POINTER
	SR	R0,R12			:BYTE COUNT=LEAD-TRAIL
	JGEFS	SYWT10			:ADJUST FOR WRAP AROUND
	AHI	R0,SVNBSZ

SYWT10	SIS	R0,8			:NEED TWO FULL WORDS AFTER EOR
	CH	R0,SYBCNT,LN		:GOT ENOUGH DATA?
	JLE	SYLRET			:NOT YET

	LHI	R0,SYLMRK-SEG1		:YES, NEXT TIME LOOK FOR
	STH	R0,QSYLVR,LN		:	START OF NEW RECORD

	LHL	R4,SYHEDR,LN,LN		:GET ALIGNED HALFWORD
	LHL	R3,SYHEDR+2,LN,LN	:FIRST HALFWORD OF RAW DATA
	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	SYNEXT			:LINK WENT OUT WHILE WE WERE WAITING...
	LHL	R1,SYBCNT,LN		:GET BYTE COUNT
	LHL	R10,SYLSHF,LN		:LEFT SHIFT COUNT (COMPLEMENTED)

SYWT20	SRHLS	R1,1			:CONVERT TO HALFWORD COUNT
	AIS	R1,1			:MOVE VRC ALSO

:	ALL DATA RECEIVED FOR RECORD ON TYMNET II LINK

SYFOT2	LHL	R0,0,R13,R12		:RECORD NUMBER IS THE BYTE
	LR	R2,R12			:FOLLOWING THE HALFWORD WE'VE ALREADY
	AIS	R2,2			:ALIGNED. EXTRACT ANOTHER HALFWORD
	NHI	R2,SVNBSZ-2		:HERE -- BUT DON'T MODIFY NORMAL
	LHL	R2,0,R13,R2		:POINTERS.
	EXHR	R0,R0
	OR	R0,R2
	SRL	R0,9,R10
	LBR	R0,R0			:R0=REC # -- RIGHT ALIGNED

	LH	R2,LAS,KD		:GET LAST ACK SENT
	SHI	R2,07F
	SR	R0,R2
	LBR	R0,R0
	AR	R2,R0			:R2= REC # -- SIGN EXTENDED

	JAL	R9,SYFORM

	IF	TSTSZE
	LR	R1,R4			:PRESERVE HEADER
	EI	:TSTSZE
	LH	R2,LAR,KD		:LAST ACK RECEIVED
	SR	R4,R2			:ACK OK IF
	LBR	R4,R4			:	LAR<=ACK<=LAR+WSIZ
	CLB	R4,WSIZ,KD		:IS ACK OK?
	JGFS	SYLBAK			:NO

:	GOOD ACK RECEIVED -- UPDATE 'NEXT REC TO XMIT'

SYLGDK	AR	R2,R4			:GET MOST RECENT ACK
	STH	R2,LAR,KD		:AND UPDATE LAR FIELD
	J	SYNEXT			:CONTINUE WITH NEXT PACKET OR LINK

:	BAD ACK REC'D -- RECORD AND FINISH UP

SYLBAK	HS	0
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB10			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BAK
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD ACK)
	STH	R1,TSFTBL+2,R15		:STORE PACKET HEADER (SAVED IN R1)
	LR	R1,R15			:SAVE INDEX REGISTER AND
	L	R15,TSRSVE		:	RESTORE R15 (KD)
	LH	R0,LAR,KD		:GET LAST ACK RECEIVED AND
	STB	R0,TSFTBL+4,R1		:	STORE IN EVENT ENTRY	###OAS
	LIS	R0,0		:PROVIDE OPPORTUNITY TO PATCH THIS 'LHL' TO A
	LHL	R0,TSLINK	: 'STH' TO TERMINATE TRACING AND EXAMINE
				: HISTORY PRIOR TO BAD ACK OCCURRENCE.
TSLB10	EI	:TSTSZE
	LB	R0,NLAT,KD		:BAD ACKS CAN OCCUR LEGITIMATELY ON
	SIS	R0,1			: MULTI-LINE LINKS IF SUBSEQUENT SHORT
	JG	SYNEXT			: PACKET OVERTAKES PRIOR PACKET W/ OLD
					: ACK. DON'T COUNT...
	LIS	R0,1
	AHM	R0,BADACK,LN		:RECORD OCCURRENCE OF BAD ACK
	J	SYNEXT			:GO LOOK FOR NEXT RECORD

:	RESET RECEIVED ON EITHER T-II OR T-I ATTACHED LINE.
:	PUT LINE IN LIMBO AND TELL LINKER TO DETACH IT.

SYLRAL	LR	R1,LN			:GET LINE NUMBER
	SRHLS	R1,1
	TBT	R1,INHRST		:RESET INHIBITED?
	JN	SYNEXT			:YES

	LCS	R0,1			:NO, PUT LINE IN LIMBO
	ST	R0,KDLN,LN,LN
	LHI	R0,SIOIDL-SEG1		:set idle transmit state
	STH	R0,SIOTST,LN
	SBT	R1,LINDET		:TELL LINKER TO DETACH
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB09			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RST
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (RESET RECEIVED)
:	DETERMINE(* WHETHER TYMNET-I OR*) TYMNET-II LINK.(*T-I*)RESET
:	HEADER(*IS IN R4,*) T-II IS IN 'SYSTOR'.
	L	R0,SYSTOR		:NO, TYMNET-II - GET 4 BYTES OF RESET 
	ST	R0,TSFTBL+2,R15		:AND STORE (CLOBBER HI-ORDER
					:HALFWORD OF FASTC) 
TSLB08	AIS	R15,TSESZE
	NHI	R15,TSTSZE-1		:ADVANCE TO NEXT ENTRY AND CLEAR
	LIS	R0,0			:	IT TO EASE FINDING END OF
	ST	R0,TSFTBL,R15		:	TRACE HISTORY
	ST	R0,TSFTBL+4,R15
	STH	R0,TSLINK		:INHIBIT FURTHER TRACING
	L	R15,TSRSVE

	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT

TSLB09	EI	:TSTSZE
	LIS	R0,3			:SET DETACH REASON
	STB	R0,DREASN,R1
	ts	glinkr
:	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
:	SBT	R0,TLINKR
	JFS	SYNEXT

:	COME HERE WHEN 'NOISE' SEEN ON LINE

SYLERR	LIS	R0,1			:INC COUNTER
	AHM	R0,LINERR,LN		:INC ERROR COUNTER

:	COME HERE TO LOOK AT NEXT HALFWORD
:	R3 CONTAINS LAST HALFWORD OF RAW DATA
:	R10 CONTAINS LEFT SHIFT FACTOR -- COMPLEMENTED

SYNEXT	LCS	R1,1			:SET TO MASK BITS ALREADY USED
	SLL	R1,1,R10		
	LHL	R3,0,R13,R12		:GET LAST 1/2 WD LOOKED AT
	OR	R3,R1			:SET THEM TO MARKS
	STH	R3,0,R13,R12		:AND STORE FOR POSTERITY
	J	SYLMRK			:GO LOOK FOR NEW RECORD

:	DATA RECEIVED ON UNASSIGNED LINE -- SEE IF IT IS RESET,
:	DOWNLINE LOAD DATA, OR GARBAGE.  R4 contains first HW of Header.

SYLUAL	HS	0
	IF	TSTSZE
	JAL	R2,TSFUAL		:TEST IF THIS LINE IS OF INTEREST
	EI	:TSTSZE
	AIS	KD,1			:IF LINE IN LIMBO
	JE	SYNEXT			:	JUST IGNORE

	TBT	LN,DWLDSP		:IS THIS A DWL LINE?
	JN	SYLDLL			:YES, SKIP
	if	chboot
	lhl	r0,siotst,ln		:
	chi	r0,siobot-seg1		:is it seeing if neighbor is in boot?
	je	syldll	
	ei	:chboot
	lr	r0,ln
	srls	r0,1
	TBT	r0,xltact		:is this a line test line?
	JN	syltst			:YES, SKIP

	LR	R0,R4			:copy header halfword
	NHI	R0,0FFE0		:mask out 'subseq' bit, ping pong count
	CLHI	R0,TXRSHD		:'new link' Expanded reset?
	JN	SYLRES			:no
SYLU02	JAL	R9,SYLXRS		:store Reset in SYSTOR
	LR	R2,LN			:Line Number*2
	SRHLS	R2,1
	TBT	R2,INHRST		:reset inhibited?
	JN	SYNEXT			:yes
	L	R5,SDLN,LN,LN		:ok, get Reset descriptor address
	AHI	R5,VSDSZ-2		:address of last destination HW to R1+1
	LA	R4,SYSTOR+(VSDSZ-2)	:address of last source HW to R1
	LHI	R1,10*((VSDSZ/2)-1)	:10*(numberof HW's -1)
	COPY	R4,R1			:copy Reset from temporary storage
	J	SYLR02
SYLRES
SYLUA5	LIS	R1,6			:MOVE 6 HALFWORDS OF RESET INTO SYSTOR
	LA	R8,SYSTOR		:PUT DATA IN TEMP STORAGE
	JAL	R2,SYALGN		:MOVE THE DATA
	LR	R0,R4			:COPY HEADER HALFWORD
	NHI	R0,0FFF0		:MASK OUT PING PONG COUNT
	CLHI	R0,TTRSHD		:TYMNET-II NEW LINK RESET?
	JE	SYLRDL			:YES
	CLHI	R0,TSRSHD		:TYMNET-II SUBSEQUENT LINE RESET?
	JEFS	SYLRDL			:YES
	L	R4,SYSTOR		:NO TRY T-II NULL RECORD
	CLI	R4,TWDMHD		:MIGHT RECEIVE WHILE WAITING ON LINKER
	JN	SYLERR			:NO, MUST BE NOISE
	J	SYNEXT			:YES, IGNORE IT

:	RESET RECEIVED

SYLRDL	LR	R2,LN			:LINE NUMBER
	SRHLS	R2,1
	TBT	R2,INHRST		:RESET INHIBITED?
	JN	SYNEXT			:YES
	L	R5,SDLN,LN,LN		:NO, RESET DESCRIPTOR ADDRESS
	L	R4,SYSTOR		:SAVE FIRST WORD OF RESET FOR LINKER
	ST	R4,VRSTP,R5		:SAVE FOR USE BY LINKER
	L	R0,SYSTOR+8		:NEIGHBOR VERSION NUMBER FROM RESET,
	ST	R0,VRSTP+4,R5		:	IF PRESENT

SYLR02	SBT	R2,VRSTDL		:TELL LINKER TO LOOK AT IT
	SBT	R2,LINATT		:AND TO ATTACH THE LINE
	ts	glinkr
:	LHI	R0,01F-PLINKR		:AND SCHEDULE THE LINKER
:	SBT	R0,TLINKR
	J	SYNEXT

:	DATA RECEIVED ON LINE BEING DOWNLINE LOADED

SYLDLL	CLHI	R4,DWNLHD		:DOWNLINE LOAD HEADER?
	JN	SYNEXT			:NO, IGNORE IT

	STH	R10,SYLSHF,LN
	LHI	R0,SYLDWT-SEG1		:AND SET TO WAIT FOR DATA
	STH	R0,QSYLVR,LN

::*********************************************************************
::
::	ENTRY POINT:	SYLDWT:
::	FUNCTION:	COME HERE WHEN WE ARE WAITING FOR THE TARGET MACHINE
::			TO COMPLETE TRANSMISSION OF A DWL RECORD.
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::	RETURNS:	J	SYLRET
::
::*********************************************************************

SYLDWT	LR	R0,R11			:COPY OF LEAD POINTER
	SR	R0,R12			:WAIT FOR 42+8 BYTES
	JGEFS	SYLDW5			:SKIP IF NO WRAP
	AHI	R0,SVNBSZ
SYLDW5	SIS	R0,8
	CHI	R0,DWLPSZ		:GOT ALL THE DATA?
	JLE	SYLRET			:NO

	LHI	R0,SYLMRK-SEG1		:YES, NEXT TIME LOOK FOR NEW PACKET
	STH	R0,QSYLVR,LN
	LHL	R10,SYLSHF,LN		:GET SHIFT COUNT
:	setup for call to syalgn
	LHL	R3,0,R13,R12		:SKIP OVER SYNCS
	AIS	R12,2			:BY RESETTING R3 AND
	NHI	R12,SVNBSZ-2		:INCREMENTING TRAIL POINTER
	LHI	R1,20			:MOVE 32 HALFWORDS
	if	chboot
	lhl	r8,siotst,ln
	ci	r8,siobot-seg1		:is this a response to one we sent?
	je	syldw9			:yes, so ignore it
	ei	:chboot
	LIS	R8,1
	AHM	R8,DWLCLI

	LIS	R4,TINTCH-1
SYLDW6	CLH	LN,DWLNUM,R4,R4		:GET DWL LINE INDEX
	JEFS	SYLDW8			:FOUND IT
	SIS	R4,1
	JGEBS	SYLDW6			:HAVEN'T FOUND IT, KEEP LOOKING
	J	SYNEXT			:DLL LINE NOT THERE, PRESUMED ZAPPED
SYLDW8	LH	R8,DWBUSY,R4,R4		:R8<0 MEANS DONT STORE
	JL	SYLDW7			:-1000 MEANS BUFFER IS BUSY
	SLLS	R4,6			:FORM DWIBUF OFFSET (64 X R4)
	LA	R8,DWIBUF,R4,		:SET BUFFER ADDRES
	SRLS	R4,6			:RESTORE R4

	JAL	R2,SYALGN

	LHI	R0,-1000		:MARK BUFFER BUSY
	STH	R0,DWBUSY,R4,R4
	LHI	R0,01F-PDWLIN		:AND SCHEDULE TEAR DOWN OF
	SBT	R0,SQUEUE		:DOWNLINE RECORD BY DWLIN
	SBT	R4,DWQUEU		:SET BIT IN DWL JOB QUEUE FOR DWLIN
	J	SYNEXT

SYLDW7	JAL	R2,SYALGN
	J	SYNEXT

	if	chboot
syldw9	la	r8,systor
	jal	r2,syalgn
	l	r0,systor+3e		:checksums for it
	c	r0,cnbrec+40,,		:against those in our test packet
	je	synext			:line is probably in loopback
	lr	r0,ln	
	srls	r0,1
	sbt	r0,cnbtya		:neighbor is in boot
	sbt	r0,cnbrsp		:need to send return to boot records
	j	synext
	ei	:chboot

::*********************************************************************
::
::	SUBROUTINE:	SYLTST
::	FUNCTION:	Check to see if complete line test block
::			received and move to temporary storage.
::	CALLING SEQ:	From sylual finding a line test
::	INPUT:		R3, R4, R10, R11, R12, LN
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::
::*********************************************************************

:	CHECK TO SEE IF complete line test packet HAS BEEN RECEIVED
syltst	lr	r0,r4
	nhi	r0,0ff00
	chi	r0,3200			:start properly?
	jn	sylts6
	lBR	R1,R4			:extract byte count index
	CLHI	R1,80			:compare with max LT test packet
	JG	sylts6			:must be garbage since too big
	LR	R0,R11			:make copy of lead pointer
	SR	R0,R12			:received count = lead-trail
	JGEFS	sylts0			:skip if no wrap around
	AHI	R0,SVNBSZ		:correct for wrap around
sylts0	SIS	R0,8			:need 2 words beyond EOR
	CR	R0,R1			:got them?
	JG	sylts4			:yes

:	NO, SAVE RETURN, SHIFT, HEADER, AND SET TO WAIT FOR COMPLETION.
	ST	R9,SYLLNK,LN,LN		:save return
	STH	R1,SYBCNT,LN		:save byte count
	STH	R10,SYLSHF,LN		:save left shift -- complemented
	STH	R4,SYHEDR,LN,LN		:save aligned header
	STH	R3,SYHEDR+2,LN,LN	:save 1st 16 bits raw data
	LHI	R0,syltwt-SEG1		:set 'state'
	STH	R0,QSYLVR,LN
	J	SYLRET			:done for now

::*********************************************************************
::
::	ENTRY POINT:	syltwt:
::	FUNCTION:	Check to see if complete line test packet has been
::			received
::	CALLING SEQ:	LHL	R1,QSYLVER,LN
::			J	SEG1,R1,,
::	INPUT:		R11, R12, LN
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::	RETURNS:	JLE	SYLRET
::
::*********************************************************************

syltwt	LR	R0,R11			:make copy of lead pointer
	SR	R0,R12			:received count = lead-trail
	JGEFS	syltw0			:skip if no wrap around
	AHI	R0,SVNBSZ		:correct for wrap around
syltw0	SIS	R0,8			:need 2 words beyond EOR
	CH	R0,SYBCNT,LN		:got them?
	JLE	SYLRET			:not yet

	LHI	R0,SYLMRK-SEG1		:yes, next time look for start
	STH	R0,QSYLVR,LN		: of new record
	LHL	R4,SYHEDR,LN,LN		:get aligned HW of header
	LHL	R3,SYHEDR+2,LN,LN	:get 1st HW of raw data
	LHL	R10,SYLSHF,LN		:get left shift count (complemented)
	L	R9,SYLLNK,LN,LN		:get return
	LHL	R1,SYBCNT,LN

:	see if received packet is good
sylts4	SRHLS	R1,1			:convert to halfword count
	LA	R8,SYSTOR		:put data in temp storage
	JAL	R2,SYALGN		:move the data
	JN	sylts6			:CC<>0 => bad checksum
	lis	r0,1			:is good so count it
	am	r0,xltpkr,ln,ln
	j	synext			:and done

sylts6	lis	r0,1			:count another bad packet
	am	r0,xltcse,ln,ln
	j	synext			:and done

::*********************************************************************
::
::	SUBROUTINE:	SYFORM:
::	FUNCTION:	PERFORMS CHARACTER FRAMING AND RECORD CHECKSUMMING
::			FOR SYLVER.
::	REGISTERS ON ENTRY:
::		R2  -- RECORD SEQUENCE NUMBER
::		R3  -- RAW DATA POINTED TO BY R12
::		R9  --*RETURN ADDRESS
::		R10 --*ALIGNMENT SHIFT FACTOR (COMPLEMENT)
::		R11 --*RELATIVE INPUT DATA LEAD POINTER
::		R12 --*RELATIVE INPUT DATA TRAIL POINTER
::		R13 --*START OF INPUT RING 
::		R14 --*LINE NUMBER X 2
::		R15 --*LINK DESCRIPTOR ADDRESS
::	* MUST BE PRESERVED ON RETURN (NOTE--R5 AND R11 RETURNED
::		IN UPDATED FORM)
::	REGISTER USAGE:
::		R0  -- WORK REGISTER
::		R1  -- NUMBER OF HALFWORDS TO MOVE
::		R2  -- RECORD SEQUENCE NUMBER
::		R3  -- FIRST 16 BITS OF RAW DATA
::		R5  -- VERTICAL CHECKSUM ACCUMULATOR
::		R6  -- SECTOR RECORD DESCRIPTOR ADDRESS
::		R7  -- DIAGONAL CHECKSUM ACCUMULATOR
::		R8  -- TARGET SECTOR ADDRESS (PHYSICAL RECORD BUFFER)
::		R9  -- RETURN ADDRESS
::		R10 -- ALIGNMENT SHIFT FACTOR (COMPLEMENTED)
::		R11 -- RELATIVE LEAD POINTER
::		R12 -- RELATIVE TRAIL POINTER
::		R13 -- START OF INPUT RING
::		R14 -- LINE NUMBER X 2
::		R15 -- LINK DESCRIPTOR ADDRESS
::	CALLS:	JAL	R0,TSFMRK
::		JAL	R2,SYALGN
::
::*********************************************************************

SYFORM	LB	R5,WSIZ,KD		:GET # SECTORS AVAILABLE
	LHL	R6,ISEC,KD		:SECTOR 0 PHYS REC DESCRIPTOR ADDR
	LR	R0,R2			:COPY OF RECORD NUMBER
	SH	R0,RECN,R6		:WE ARE THIS MANY AHEAD OR
	LHR	R0,R0			:	BEHIND SECTOR 0
	JGEFS	SYFR10			:AHEAD OF SECT 0 -- SKIP

	AR	R0,R5			:CORRECT FOR WRAP AROUND
SYFR10	CR	R0,R5			:TOO FAR AHEAD
	JLFS	SYFR12			:NO, SKIP
	SR	R0,R5			:YES, BACK UP

SYFR12
	lr	r8,r0
	lhl	r0,ccdsz,r8,r8  	:get rel sector address
:	MH	R0,CCDSZ		:GET RELATIVE SECTOR ADDRESS
	AR	R6,R0			:SECTOR ADDRESS TO R6

:	CHECK RECORD NUMBER FOR VALIDITY AND FOR RETRANSMISSION

	Lcs	R8,1			:ASSUME BAD REC -- SET 'DON'T STORE'
	LR	R0,R2			:COPY RECORD #
	SH	R0,LRT,KD		:LRT < REC # ?
	LHR	R0,R0			:	(NOTE--LRT = LAST REC TORN)
	JG	SYFR20			:YES, SKIP

:	RECEIVED RETRANSMISSION -- NOTE IT

SYFR15	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB03			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RXC
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	STH	R4,TSFTBL+2,R15		:STORE FIRST 2 BYTES OF HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB03	EI	:TSTSZE
	LIS	R0,1
	AHM	R0,RCRXMT,LN		:INC RETRANSMISSION REC'D COUNT
	J	SYFR30			:AND GO 'MOVE' THE DATA

SYFR20	CR	R0,R5			:REC # <= LRT+WSIZ ?
	IF	TSTSZE
	JLE	SYFR25			:YES, GOOD RECORD NUMBER
	ELSE	:NOT TSTSZE
	JLEFS	SYFR25			:RECORD NUMBER O.K.
	EI	:TSTSZE

:	BAD RECORD NUMBER (TOO HIGH) -- NOTE IT

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB04			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BRN
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD RECORD NUMBER)
	STH	R4,TSFTBL+2,R15		:STORE RECORD HEADER
	STB	R2,TSFTBL+4,R15		:	AND PACKET RECORD NUMBER
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:	THIS 'LHL' TO A 'STH' TO
					:	TERMINATE TRACING AND
					:	EXAMINE HISTORY PRIOR TO
					:	BAD RECORD OCCURRENCE.  
	L	R15,TSRSVE
TSLB04	EI	:TSTSZE
	LB	R0,NLAT,KD		:BAD RECORD # CAN OCCUR ON MULTI-LINE 
	SIS	R0,1			:LNKS IF SUBSEQUENT SHORT PKT OVERTAKES
	JGFS	SYFR30			:PRIOR PKT. DON'T COUNT THIS ONE

	LIS	R0,1
	AHM	R0,BADRCN,LN		:INC BAD RECORD COUNTER
	JFS	SYFR30			:AND GO 'MOVE' THE DATA

SYFR25	CLH	R2,RECN,R6		:SEE IF REC ALREADY REC'D
	JE	SYFR15			:YES, GO NOTE IT
	L	R8,BREC,R6		:GET PHYSICAL REC BUFFER ADDRESS

:	SET UP TO ALIGN DATA AND DO BLOCK CHECKS
	
SYFR30	ST	R2,SYSTOR		:SAVE REC # ACROSS CALL
	JAL	R2,SYALGN		:MOVE THE DATA AND CHECKSUM IT

	IF	1-TSTSZE
	JEFS	SYFR40			:SKIP IF GOOD CHECKSUM
	ELSE	:TSTSZE
	JE	SYFR40			:O.K. CHECKSUM CONDITION CODE RETURNED

:	PACKET RECEIVED WITH BAD CHECKSUM
SYFR37	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB05			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.CSE
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (CHECKSUM ERROR)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	LHL	R2,SYSTOR+2
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	LIS	R0,0
	NOP	R0,TSLINK		:PATCH TO 'STH' TO TERMINATE TRACE HERE
	L	R15,TSRSVE
TSLB05	EI	:1-TSTSZE
	LIS	R0,1
	AHM	R0,BADCSM,LN		:INC BAD CHECKSUM COUNTER
	J	SYNEXT			:AND SKIP TO NEXT LINE

:	GOOD CHECKSUM	-- RELEASE DATA TO RTD

SYFR40	LR	R8,R8			:SEE IF RECORD STORED
	JLR	R9			:NO, SIMPLY RETURN
	LR	R0,LN
	SRHLS	R0,1			:SET BIT INDICATING GOOD
	SBT	R0,LNGREC		:	REC RECEIVED ON LINE

	L	R2,SYSTOR		:RETRIEVE SAVED RECORD NUMBER
	STH	R2,RECN,R6		:REC # TO RECORD DESCRIPTOR

	LHL	R0,FASTC+2,,		:GET CURRENT TIME
	STH	R0,INTIME,r6		:AND RECORD TIME OF PACKET ARRIVAL

	LB	R1,LKNM,KD		:GET LINK NUMBER
	SBT	R1,LKGREC		:NOTE GOOD REC REC'D ON LINK
	SBT	R1,LKTEAR		:'SCHEDULE' RTD

	LIS	R0,1			:INC COUNT OF GOOD
	AHM	R0,RCRCVD,LN		:	RECORDS REC'D ON THIS LINE
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JNR	R9			:NO - DONE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LHI	R0,TS.REC
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (GOOD REC RECEIVED)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	LHL	R2,RECN,R6
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB06	EI	:TSTSZE
	JR	R9			:DONE

::*********************************************************************
::
::	SUBROUTINE:	SYALGN:
::	FUNCTION:	ACTUALLY PERFORMS THE CHARACTER ALIGNMENT,
::			MOVING, AND CHECKSUMMING.
::	CALLING SEQ:	JAL	R2,SYALGN
::	INPUT:		R1  -- NUMBER OF HALFWORDS TO MOVE
::			R2  -- RETURN ADDRESS
::			R3  -- FIRST 16 BITS OF RAW DATA
::			R8  -- WHERE TO STORE DATA (IF NEG -- NO STORE)
::			R10 -- ALIGNMENT SHIFT FACTOR
::			R11 -- INPUT LEAD POINTER
::			R12 -- INPUT TRAIL POINTER
::			R13 -- INPUT RING ADDRESS
::	OUTPUT:		R12 -- NEW TRAIL POINTER
::	DESTROYED:	R0,R1,R3,R5,R7,R8
::	ALSO:		CC=0 => GOOD CHECKSUMS
::			CC<>0 => BAD CHECKSUMS
::
::*********************************************************************

SYALGN	LIS	R5,0			:SET VRC AND DRC ACCUMULATORS
	LIS	R7,0
	ALIGN 	R13,R12			:				###%cc
	EXHR	R0,R3			:BUILD DRC
	LHL	R3,0,R13,R12
	OR	R0,R3			:	
	SRL	R0,1,R10		:GOT CALCULATADED DRC IN R0
	XR	R7,R0			:XOR IT WITH RX'ED DRC IN LO HW R7
	OR	R7,R5			:INCLUDE VRC
	LHR	R7,R7			:CHECKSUMS GOOD IF RIGHT HALF OF R7
	JR	R2			:	IS ZERO.  SET CONDITION CODE

	ei	:sylins

	SUBTTL	LINKER (Miscellaneous subroutines...)

::*********************************************************************
::
::	TABLE:		SYTWCN:
::	FUNCTION:	TYMNET II BYTE COUNT TRANSLATION TABLE -
::			COUNT VALUE RECEIVED IN TYMNET-II PACKET HEADER IS
::			INDEX INTO THIS TABLE.  THE VALUE IN THE TABLE
::			IS THE NUMBER OF BYTES IN THE PACKET, INCLUDING
::			THE HEADER BUT NOT THE CHECKSUMS.
::
::*********************************************************************

SYTWCN	BC	04,0C,14,1C,24,2C,34,3C,44,4C,54,5C,64,6C,74,7C

::*********************************************************************
::
::	SUBROUTINE:	GFRCHN:
::	FUNCTION:	RETURNS CHAIN OF N FREE RECORD BUFFERS.
::	CALLING SEQ:	JAL	R9,GFRCHN
::	INPUT:		R1 = # BUFFS
::	OUTPUT:		R2 = RETURNS PTR TO FIRST BUFFER
::			R3 = RETURNS PTR TO LAST
::	PRESERVED:	R1
::	DESTROYED:	R4
::
::*********************************************************************

GFRCHN	LR	R4,R1
	LHL	R2,FREELR
	JLFS	GFRERR			:FREE LIST EMPTY		###wjl
	LR	R3,R2
	JFS	GFRC2
GFRC1	LHL	R3,RLNK,R3
	JLFS	GFRERR			:				###wjl
GFRC2	SIS	R4,1
	JGBS	GFRC1

	LHL	R4,RLNK,R3		:NEW TOP OF FREE LIST
	STH	R4,FREELR
	JR	R9			:				###wjl

GFRERR	HC	0	:this should have been prevented at assembly	###wjl

::*********************************************************************
::
::	SUBROUTINE:	MCHDWN
::	FUNCTION:	Matches down window size
::	CALLING SEQ:	JAL	R9,MCHDWN
::	INPUT:		R1 = number of buffers, i.e. window size
::			R2 = pointer to first buffer
::	OUTPUT:		R3 = returns pointer to last buffer
::	PRESERVED:	R1 (wsz)
::	DESTROYED:	R4
::
::*********************************************************************

MCHDWN	LHL	R3,ISECSV,KD		:a broken ISEC chain?
	JEFS    MCHD00
	LHL	R4,ISECS1,KD		:get address of broken chain
	STH	R4,RLNK,R3
	LIS	R3,0			:no broken chains
	STH	R3,ISECSV,KD		:chain fixed
MCHD00  LHL	R3,OSECSV,KD		:broken output sector chain
	JEFS    MCHD01  		:no break
	LHL	R4,OSECS1,KD
	STH	R4,RLNK,R3		:restored OSEC chain
	LIS	R3,0			:chain no longer broken
	STH	R3,OSECSV,KD
MCHD01	LHL	R2,ISEC,KD		:match down input window first  ###sdw
	LR	R4,R1			:preserve number of buffers (WSIZ)
	LR	R3,R2			:preserve pointer to first buffer
	JFS	MCHD04
MCHD02	LHL	R3,RLNK,R3		:get pointer to next buffer
MCHD04	SIS	R4,1			:decrement count
	JGBS	MCHD02			:done?
	LHL	R4,RLNK,R3		:address of the broken piece
	CR	R4,R2			:loop back to start?
	JE      MCHD10  		:nothing to break
	STH	R3,ISECSV,KD		:where it was broken
	STH	R4,ISECS1,KD
	STH	R2,RLNK,R3		:yes, store pointer to first buffer

:	now do output sector side
MCHD10  LHL	R2,OSEC,KD		:match down output window       ###sdw
	LR	R4,R1			:preserve number of buffers (WSIZ)
	LR	R3,R2			:preserve pointer to first buffer
	JFS	MCHD14
MCHD12	LHL	R3,RLNK,R3		:get pointer to next buffer
MCHD14	SIS	R4,1			:decrement count
	JGBS	MCHD12			:done?
	LHL	R4,RLNK,R3		:address of the broken piece
	CR	R4,R2			:end point to start?
	JE      MCHD20  		:yes, no break to make
	STH	R3,OSECSV,KD		:where output chain was broken
	STH	R4,OSECS1,KD		:
	STH	R2,RLNK,R3		:and shorten chain (the match down)
MCHD20					:done with outpt sector
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CLRCHN:
::	FUNCTION:	INITIALIZES CHAIN OF RECORD BUFFERS.
::	CALLING SEQ:	JAL	R9,CLRCHN
::	INPUT:		R1 = # BUFFS
::			R2 = PTR TO FIRST BUFFER
::	PRESERVED:	R1
::	DESTROYED:	R0, R3
::
::*********************************************************************

CLRCHN	LIS	R0,0
	SR	R0,R1			:R0 = - # OF SECTORS
	LIS	R3,0
CLRC1	STH	R0,RECN,R2
	STh	R3,LLXM,R2		:CLEAR LLXM
	LHL	R2,RLNK,R2
	AIS	R0,1
	JLBS	CLRC1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	BFRUPD:
::	FUNCTION:	Routine to copy ACP array to BFDARY (buffer
::			delay array) for the purpose of scheduling the
::			sending of buffer delay timing pairs (COMETS--0314).
::			Scheduled from the 30 second logic in EXEC, if
::			BFLTMR assembly switch is non-zero.
::	CALLING SEQ:	JAL	R10,BFRUPD
::
::*********************************************************************

	IF	BFLTMR

BFRUPD	LA	R0,ILCACP-2,,	:pointer to last halfword of source
	LA	R1,BFDEND-2,,	:pointer to last halfword of destination
	LI	R2,10*(((ILCACP-LNKACP)/2)-1)	:number of hw's, etc
	COPY	R0,R2		:copy the bit array of active channels
	JR	R10

	EI	:BFLTMR

::*********************************************************************
::
::	SUBROUTINE:	TEMPRP:
::	FUNCTION:	CHECK REPORTED TEMPERATURE AND REPORT IF IT IS NOT IN
::			THE ACCEPTABLE RANGE.  CALLED FROM G04MIN.
::	CALLING SEQ:	JAL	R11,TEMPRP
::	DESTROYED:	R1
::
::*********************************************************************

TEMPRP	LH	R1,TMCHFG	:CHECK FLAG TO DISABLE TEMP CHECK
	JNR	R11		:IF SET NON-ZERO (BY USER) DON'T BOTHER
	LB	R1,TEMPER,,	:READ TEMPERATURE
	CHI	R1,TOOHOT	:IS TEMP TOO HIGH?
	JGFS	TMPRPT		:TRY TO SEND REPORT

:	NO REPORT NECESSARY, BUT CHECK INHIBIT FLAG IN CASE IT'S 
:	TIME TO CLEAR IT.
	LH	R1,INHTMP	:READ INHIBIT FLAG
	JGER	R11		:NEGATIVE VALUE INHIBITS
TMPR10	AIS	R1,1		:IF SET, THEN MARK ANOTHER PASS
	STH	R1,INHTMP	:UPDATE INHIBIT FLAG
	JR	R11

:	TEMPERATURE OUT OF RANGE.  SEE IF WE SHOULD REPORT IT.
TMPRPT	LH	R1,INHTMP	:READ INHIBIT FLAG
	JN	TMPR10		:IF NEG, THEN WE'RE INHIBITED
:	IF NOT INHIBITED, SET INHIBIT DELAY AND SEND THE REPORT
	LCS	R1,DLYTMP	:DELAY 14 MORE CALLS--ONE HOUR.	
	STH	R1,INHTMP	:THIS IS INC'ED EACH CALL
:	SEND THE REPORT TO SUP'S LOG
	LHI	R1,NR.TMP	:NODE REPORT #2E 
	STH	R1,SUPMBF	:STORE FOR SUP12 TO FIND
	LB	R1,TEMPER,,	:READ BYTE CONTAINING TEMPERATURE
	ST	R1,SUPMBF+2	:STORE IN REST OF 48 BITS OF MSG BUFFER
	JAL	R10,SUP12,,	:CALL ROUTINE TO SEND TO SUP LOG
EXIT	JR	R11		:RETURN TO G04MIN			###JHL	

	ENDMO.(LINKER)
	EI	:1-KILLIT
	KILMSG(LINKER)
:	***NOTHING PAST THIS POINT***

	SUBTTL	XHOSTS

:		*   * *   *  ***   ***  *****  ***
:		 * *  *   * *   * *       *   *
:		  *   ***** *   *  ***    *    ***
:		 * *  *   * *   *     *   *       *
:		*   * *   *  ***  ****    *   ****

::#####################################################################
::
::	MODULE:	 XHOSTS
::
::	FUNCTION:  Interfaces to kernel and supervisor processes.
::
::	REGISTER CONVENTIONS:
::		CD  = R13	:pointer to reCord Descriptor
::		CHN = R5	:CHannel Number
::		KP  = R7	:Kernel Port buffer offset
::		LRC = R14	:Logical Record byte Count
::		PRC = R10	:Physical Record byte Count
::		PRD = R12	:Pointer to Record Data
::		TC  = R15	:for TrunCating ring pointers (power of 2 mask)
::		TYC = R11	:holds magic constant (03 or 07)
::
::	ROUTINES:
::		IZSIRG - Initialize SIO ring
::		KERIPS - Moves data into kernel port buffers
::		KEROPS - Processes kernel data destined into network
::		KxROOM - Kernel utility routines
::		SUPIN  - Moves characters to the sup input buffers
::		SUPOUT - Moves characters from the sup output buffer into net
::		SxROOM - Sup process utility routines
::
::	SWITCHES:
::		IKNRNG - ISIS kernel negative ring structure
::			 Code only runs in verion 6+ of ISIS.
::			 Switch is no longer used, but assumed true.	###sdw
::		RESHST - Restricted host (ISIS only)
::		SPLIT  - Split sup (SIO ring) configuration
::		SUPER  - Supervisor node
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.
	SEG	a.code
	IF	(1-T2GATE)	:Gateway does not use XHOSTS

::*********************************************************************
::
::	XHOSTS PARAMETERS:
::
::*********************************************************************

:	define SSCALE for histogram shift facter for sup data ring

     if	super
SSCALE	EQ	0
Q	EQ	20		:8 word entries in table
      RE	10		:biggest SUPBSZ is a HW
       IF	SUPBSZ-Q
Q	EQ	Q*2
SSCALE	EQ	SSCALE+1
       EI
      ER

:	define SBSCAL for histogram shift facter for sup backpressure ring

SBSCAL	EQ	0
Q	EQ	20		:8 word entries in table
      RE	10		:biggest sibpsz is a HW
       IF	SIBPSZ-Q
Q	EQ	Q*2
SBSCAL	EQ	SBSCAL+1
       EI
      ER
     ei		:super

::*********************************************************************
::
::	KPRMAP:	 FW POINTERS TO PORTS' RING AREAS
::
::*********************************************************************

KPRMAP	WS	0			:FW POINTERS TO PORTS' RING AREAS
Q	EQ	0
	RE	NKU			:ONE FOR EACH PORT
	WC	KRINGS+((KBSZ+4)*2*Q)
Q	EQ	Q+1
	ER	:NKU

	SUBTTL	XHOSTS (KERIPS - Move network data into kernel)

::*********************************************************************
::
::	SUBROUTINE:	KERIPS:
::	FUNCTION:	Moves data into kernel port buffers.
::	CALLING SEQ:	JAL	R10,KERIPS
::	CALLS:		KERIN with port # in R5
::	RETURNED:	KERIN returns at KRSNXT
::
::*********************************************************************


KERIPS	ST	R10,XHSVRT		:SAVE RETURN ADDRESS

KRSI20	LHI	R4,NKU/10*2		:number of bytes (mult of 2) for NKU
KRSI21  Lhl	R0,KERFLG,R4		:set up serviced array
	STh	R0,KERSVD,R4
	SIS	R4,2
	JGEBS	KRSI21  		:handle whatever number of ports
krsi22	lhi	chn,(((nku-1)/10)*10)!0f	:number of bits to search
	lhi	r3,2*((nku-1)/10)+kersvd
	lr	r4,r3			:address of bits
	arand	r3,r5			:find port to service
	jfs	kerin
:	if none then skip to XHRET
XHRET	L	R10,XHSVRT		:RETURN TO SPIDER
	JR	R10
krsnxt	jal	r0,exyld,,
	j	krsi22

::*********************************************************************
::
::	SUB-PROCESS:	KERIN
::	FUNCTION:	MOVES DATA INTO ISIS OR SUP KERNEL FROM NETWORK
::	CALLING SEQ:	from KERIN		Dispatched based on
::			KIO port in R5		buffered data requesting
::						output to the kernel.
::	CALLS:		JAL	R9,KIROOM
::			JAL	R8,PCIS
::			JAL	R8,PCI
::			JAL	R8,GCI
::			JAL	R8,CBCCT
::			JAL	R8,NEDTIM
::			JAL	R9,ZAPX
::			JAL	R9,CRQHCR
::			JAL	R8,WCI
::			JAL	R9,KCROOM
::			JAL	R8,WCD
::			JAL	R10,SUP12
::			JAL	R9,ZAPV
::	RETURNS:	to KRSNXT
::
::*********************************************************************

KERIN	rbt	chn,kersvd,,		:port serviced
	LIS	TYC,3			:TO TEST FOR CONTROL CHAR
	LR	KP,CHN			:SAVE CHANNEL NUMBER

	LHL	R2,KIOTAB,CHN,CHN	:PERMUTER TABLE ENTRY, ISIS KERNEL

	NHI	R2,-4			:MASK OUT GOUGING BITS
	JNFS	KERI20
	CRASH.(.KERI0)
KERI20	XHI	R2,4			:FLIP TO INBOUND BUFFER INDEX
	JAL	R9,KIROOM		:COMPUTE SPACE AVAILABLE IN RING FOR
					: THIS PORT
	SIS	LRC,2			:ALLOW FOR CHARACTER PAIRS
	JG	KERI22			:ROOM AVAILABLE, SET UP TRANSFER
:	NO ROOM IN PORT'S RING, CHECK FOR ZAPPER OR GOBBLER
	JAL	R8,PCIS,,		:PEEK AT NEXT CHARACTER
	SIS	R1,3			:ZAPPER OR GOBBLER?
	JN	krsnxt			:NO - WE'LL WAIT FOR ROOM IN RING
	JAL	R8,PCI,,		:PEEK AT SECOND CHAR OF 03-PAIR
	CLHI	R1,GOBBL&0FF		:GOBBLER?
	JE	krsnxt			:YES, WAIT FOR ROOM IN RING
	J	KEIZAP			:NO, IT'S A ZAPPER, SO GO ZAP
KERI22	JAL	R8,CBCCT,,		:COMPUTE MINIMUM (BUFF CNT, RING SPACE)
	CR	R1,LRC
	JGEFS	KERI24
	LR	LRC,R1
KERI24	LR	CD,LRC			:NUMBER OF CHARACTERS TO MOVE

KERI30	JAL	R8,GCI,,		:GET CHAR
	CR	R1,TYC			:TYMNET CONTROL CHARACTER?
	JLE	KEITYM
KERI40	STB	R1,KIB,KP,PRD		:PUT AWAY
	AIS	PRD,1			:ADVANCE RING POINTER
	JLFS	KERI42			:NEGATIVE INDEX
	SHI	PRD,KBSZ		:WRAP RING...

KERI42	SIS	CD,1
	JGBS	KERI30

:	moved chars, now exit
	STH	PRD,NII,KP,		:STORE AWAY POINTER
	AM	LRC,KERICC		:CNT OF CHARS INTO KERNEL
       if	supwat
	ar	chn,chn			:make into hw index
	am	lrc,kerict,chn,chn	:running count by port
	srls	chn,1			:restore
       ei	:supwat
       IF	INTACC		:###EV
	LHI	R3,KERZFL-MNACHN,R5	:port into accounting port
	LR	R0,LRC			:Set up character count
	JAL	R8,AARDIC,,		: and accumulate input characters
       EI	:INTACC		###EV
	RBT	CHN,KERNWL		:SET NEWLOG IF NEEDED
	JE	krsnxt

:	GOT NEW LOGON INTO KERNEL
	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME, RECORD CIRC TIME

:	INFORM KERNEL OF NEW LOGIN
:	SET UP PARAMETERS FOR KERNEL LOGON SVC. 3 FW'S AT KPARMS, AS:
:	FW1 = ADDRESS OF PORT'S RING AREA
:	FW2 = PORT'S BIT INDEX (RELATIVE TO 0) INTO KOF ARRAY
:	FW3 = PORT'S BIT INDEX (RELATIVE TO 0) INTO KOFF ARRAY
:	HW4 = Port number (relative to 0) (only used if svc 62d is used)
:	SVC KIO,$A 32 does not have any return codes
:	SVC KIO,$A 62 has the following return codes
:		Return Code in R0:
:			0 = Successful
:			1 = Invalid parameter block address
:			2 = Port in use and also for this response
:				R1 = Slot number of owner of this port #
:				R2 = Virtual address of ring address
:			3 = Port number out of range
:			4 = Invalid ring addresses
:			5 = Rings cross segment boundary
:			6 = Invalid address pointer KOF
:			7 = Invalid address pointer KOFF

	LA	R0,KOF,,		:GET ADDRESS OF DATA AVAILABLE ARRAY
	SLLS	R0,3			:8-BIT INDEX
	AR	R0,CHN			:PLUS KERNEL PORT NUMBER
	ST	R0,KPARMS+4,,		:SECOND PARAMTER FW
	LA	R0,KOFF,,		:GET ADDRESS OF RELIEVE B/P ARRAY
	SLLS	R0,3			:8-BIT INDEX
	AR	R0,CHN			:PLUS KERNEL PORT NUMBER
	ST	R0,KPARMS+8,,		:THIRD PARAMETER FW
	ST	KP,KPARMS,,		:RING AREA POINTER - FIRST PARAMETER FW
	STH	CHN,KPARMS+0C,,		:4th is port number
	LCS	PRD,1			:indicate trying new
:	reentry if SVC 62 failed and now trying SVC 36
KERI48	LA	R0,KPARMS,,
	LR	R3,R2			:save R2 in case new SVC 62d
       IF	KSVC62
	LR	PRD,PRD			:trying SVC 62 or 36
	JGEFS	KERI49			:try old
	SVC	SYS,$A62		:declare port to kernel
	NOPR	0,0			:padding
	JFS	KLFAIL			:kernel refused logon
	J	KRSNXT			:done with this guy
       EI	:KSVC62

:	trying SVC 36 old style connect.  To be used if something else
:	may connect to KIO on machine (such as ISRM) or if SVC 62 failed
:	due to port in use.
KERI49	SVC	SYS,$A36		:declare port to kernel
	NOPR	0,0			:padding
	JFS	KLFA30			:kernel refused logon
					: detach port, send msg
	J	KRSNXT			:done with this guy
KLFA30	J	KLFA31			:handle connect failure for SVC 36

:	The connect SVC failed for SVC 62.  If reason was NOT port in use
:	then just give reason and zap.  If port was in use then see if
:	this port is use by NC and if so then issue ZAP SVC for it.  If
:	this port is in use by other slot or has same port number as some
:	other port belonging to NC then something is messed up.  Best thing
:	to do is to give them the reason, make a crypto log and use old
:	SVC to connect (basically force isis to connect).  This lets
:	support in to try to figure out what happened and maybe take down
:	this machine (probably a sup base) gracefully.  ###10/08/93
       IF	KSVC62
KLFAIL	LR	PRD,R0			:save reason
	LR	R6,R2			:save KIO block address in case err 2
	LR	R7,R1			:save slot that owns ring in case err 2
	LR	R2,R3			:get buffer number back
	XHI	R2,4			:IF NOT AVAILABLE, JUST ZAP
	LA	R4,KSVCM0,,		:get standard start of reason
	JAL	R9,BUFCAN,,
	LR	R1,PRD
	AHI	R1,30			:convert reason into the number
	JAL	R9,WCIE,,		:send it to user (use WCIE in case
					: ISIS returned an invalid reason
	CLHI	PRD,7			:check if valid reasons
	JG	KLFAI1			:if invalid then skip reasons
	LR	PRD,PRD			:see if zero
	JEFS	KLFAI1			:not valid reason
	LHL	R4,KSVCMS,PRD,PRD
	AI	R4,SEG1			:get address of the message to be printed
	JAL	R9,BUFCAN,,
KLFAI1	CLHI	PRD,2			:is it 'port in use'?
	JN	KLFA33			:no, do final clean up
:	if port in use then do crypto msgs.  msg 56 is info on our port which
:	is followed by msg 57 which is info on the KIO port that is already
:	active which has our port number.
	L	R0,KPARMS,,		:get address of our kio port
	ST	R0,CRYSBF		:store for crypto log
	LHL	R0,KPARMS+0C,,		:get our kio port number
	EXHR	R0,R0			:move port to high HW
	OH	R0,CTANOD,,		:add in our slot number
	JAL	R8,CRYPTO,,		:store info on our kio port
	 HC	CRYE56

:	now save info on kio port that isis said already is using our port number
	LHL	R0,KPARMS+0C,,		:get port number
	EXHR	R0,R0			:port number to high HW
	OR	R0,R7			:add in slot owner
	ST	R6,CRYSBF		:save address of ring in their memory
	JAL	R8,CRYPTO,,		:save info on other kio port
	 HC	CRYE57
	LR	R7,R7			:is ring owned by slot 0?
	JNFS	KLFAI4			:no, owned by other so do old connect
	C	R6,KPARMS,,		:if address matches then ring in use
	JE	KLFAI6			:isis says this ring is already used
:	here if port in use and either port number or address does not
:	match that of this ring.  Use old KIO connect.
KLFAI4	LA	R4,KSVCMF,,		:tell them retrying
	JAL	R9,BUFCAN,,
	LIS	PRD,1			:indicate to use old style SVC
	J	KERI48			:try connect with SVC 36
	
:	Here if ISIS said this ring was already in use.  So issue Zap Ring
:	SVC and hope ISIS frees up this port for the next logon.  We zap our
:	KIO user since it is risky to immediately reuse a port after zapping
:	it.
KLFAI6	LH	PRD,NOI,KP,		:KERNEL INDEX (empty rings on reject)
	STH	PRD,NII,KP,		:NODE INDEX
	LR	R0,KP			:port's ring area pointer in R0 for svc
	SVC	SYS,$A37		:zap kernel port (the one in use)
	NOPR	0			:padding
	JFS	KLFA33			:kernel wouldn't zap port
	JFS	KLFA33			:and now zap our own user

       EI	:KSVC62

:	Handler for connect failure for SVC 36
KLFA31	XHI	R2,4			:IF NOT AVAILABLE, JUST ZAP
	LA	R4,DETM03,,
	JAL	R9,BUFCAN,,
:	common logic for connect failure
KLFA33	LH	PRD,NOI,KP,		:KERNEL INDEX (empty rings on reject)
	STH	PRD,NII,KP,		:NODE INDEX
	LHI	R1,ZAPPN		:nongobbling zapper
	JAL	R9,ZAPX,,
	J	KRSNXT			:and all done


:	here on first char of char pair
KEITYM	JE	KEIT03			:03-TYPE PAIR?  Nope,
	STB	R1,KIB,KP,PRD		:PUT AWAY first char of pair
	AIS	PRD,1			:ADVANCE RING POINTER
	JLFS	keity0			:NEGATIVE INDEX
	SHI	PRD,KBSZ		:WRAP RING...
keity0	JAL	R8,GCI,,		:01,02 CHAR PAIR
KEITY1	SIS	CD,1
	JN	KERI40			:second char exceeds KIROOM to move
	AIS	LRC,1			:bump up moved count
	J	KERI40

KEIT03	JAL	R8,GCI,,		:TEST FOR GOBBLER
	CLHI	R1,GOBBL&0FF
	JNFS	KEIZAP			:if not gobble then must be a zapper
	LIS	R1,2			:T-I GOBBLER
	LIS	LRC,1			:MESSAGE IS SHORTER
	J	KEITY1
KEIZAP	LR	R0,KP			:PORT'S RING AREA POINTER IN R0 FOR SVC
	SVC	SYS,$A37		:ZAP KERNEL PORT
	NOPR	0			:PADDING
	JFS	KZFAIL			:KERNEL WOULDN'T ZAP PORT
	J	KPZAP			:GO ZAP IT

:	ZAP NOT Accepted by kernel so SEND SUP AND CRYPTO MSGS
KZFAIL	LHI	R0,NR.KZF		:KERNEL ZAP FAILED NODE REPORT TO SUP
	STH	R0,SUPMBF
	LR	R0,CHN
	OHI	R0,8000			:MASK OUT HW2 AND SET HO BIT OF HW3
	ST	R0,SUPMBF+2		:KERNEL PORT #
	lr	r6,r2			:save buffer # for ZAPV
	JAL	R10,SUP12,,
	lr	r2,r6			:restore buffer # for ZAPV
:	removed following line since just because kernel declined to zap
:	is no reason to not do accounting
:	J	KPZAP1

:	use zap ack so don't call ZAPV, but wait for zapper from ISIS.
KPZAP
:	JAL	R9,ZAPV,,		:use KIO zap ack
	lhl	r0,slowc+2,,
	sth	r0,kzptim,chn,chn	:save time of zap to check for zap ack
	IF	INTACC		:###EV
	LHI	R3,KERZFL-MNACHN,R5	:port into accounting port
	LIS	R0,AALR03		:Normal disconnect from Network
	JAL	R8,AARLO,,		:Perform final accounting
	EI	:INTACC		###EV
KPZAP1	RBT	CHN,NEWLOG,,		:IF WE'RE ZAPPING A NEW LOGIN,
	J	krsnxt			:ALL DONE

	SUBTTL	XHOSTS (KEROPS - Move KERNEL data out into network)

::*********************************************************************
::
::	SUBROUTINE:	KEROPS:
::	FUNCTION:	Process KERNEL data destined into network.
::	CALLING SEQ:	JAL	R10,KEROPS
::	CALLS:		KEROUT which then calls:
::			JAL	R9,GOBBLN
::			JAL	R9,KCROOM
::			JAL	R9,ZAPHRD
::			JAL	R9,ZAPV
::
::*********************************************************************

KEROPS	ST	R10,XHSVRT		:SAVE RETURN ADDRESS
	LHI	R4,NKU/10*2		:handle multiword bit arrays
KERO12	Lh	R0,KOF,R4,		:PORTS W/ CHARS FOR BUFFERS
	Nh	R0,KERBPX,R4		:MASK OUT BP'ED PORTS
	Oh	R0,KOFF,R4,		:UNLESS BP OVERRIDE
	STh	R0,KERSVD,R4
	SIS	R4,2
	JGEBS	KERO12
kero22	lhi	chn,(((nku-1)/10)*10)!0f	:number of bits to search
	lhi	r3,2*((nku-1)/10)+kersvd
	lr	r4,r3			:address of bits
	arand	r3,r5			:find port to service
	jfs	kerout
:	if none then skip to XHRET
KEROXT	L	R10,XHSVRT		:RETURN TO SPIDER
	JR	R10
kernxt	jal	r0,exyld,,
	j	kero22

::*********************************************************************
::
::	SUB-PROCESS:	KEROUT
::	FUNCTION:	HANDLE KOB OUTPUT DATA
::	CALLING SEQ:	LA	R3,KERSVD	Dispatched based on data
::	INPUT:		R5 = CHANNEL NUMBER
::	CALLS:		JAL	R8,WCI
::			JAL	R9,GOBBLE
::
::*********************************************************************


KEROUT	LIS	TYC,3
	rbt	chn,kersvd,,		:THIS PORT SERVICED
	RBT	chn,KOF,,		:THIS PORT SERVICED
	RBT	chn,KOFF,,
	LR	KP,CHN
	JAL	R9,KOROOM		:COMPUTE # OF CHARACTERS IN RING BUFFER
	LR	LRC,LRC
	JE	kernxt			:NO DATA - RETURN

	LHL	R2,KIOTAB,CHN,CHN
	NHI	R2,-4
	JNFS	KERO3			:port inactive so equal ring pointers
	LHL	R0,NIO,KP,		:and quit
	STH	R0,NOO,KP,
	J	kernxt

KERO3	LR	CD,LRC			:# CHARS TO MOVE
KERO2	LB	R1,KOB,KP,PRD		:GET CHAR
KERO4	AIS	PRD,1
	JLFS	KERO42
	SHI	PRD,KBSZ		:NEGATIVE RING WRAP

KERO42	CR	R1,TYC
	JGFS	KERO7			:TYMNET CONTROL TEST
	J	KEOTYM
kero7	JAL	R8,WCI,,		:PUT CHARACTER FROM KERNEL INTO BUFFER
KERO6	SIS	CD,1
	JGBS	KERO2

KERO5	STH	PRD,NOO,KP,
	AM	LRC,KEROCC		:CNT OF CHARS OUT OF KERNEL
       if	supwat
	ar	chn,chn
	am	lrc,keroct,chn,chn	:count chars by port
	srls	chn,1
       ei	:supwat
       IF	INTACC		:###EV
	LHI	R3,KERZFL-MNACHN,R5	:port into accounting port
	LR	R0,LRC			:Set up count
	JAL	R8,AARDOC,,		: and accumulate output characters
       EI	:INTACC		###EV
	LHL	R3,BCT,R2,		:SET BACKPRESSURE IF BUFFER FULL
	LIS	R1,3
	NH	R1,KIOTAB,CHN,CHN
	CLH	R3,CIRSPK,R1,R1
	JL	kernxt
	RBT	CHN,KERBPX
	J	kernxt

KEOTYM	JE	KEOZAP			:03 IS ZAPPER
	CLHI	R1,2
	JE	KEOGO1			:02 IS GOBBLER
	jal	r8,wci,,
	LB	R1,KOB,KP,PRD		:00,01,02 CHAR PAIR
	SIS	CD,1			:JUST PASS IT ON
	AIS	PRD,1
	JL	KERO7
	SHI	PRD,KBSZ		:NEGATIVE RING WRAP
	J	KERO7

KEOT03	LB	R1,KOB,KP,PRD		:03-TYPE PAIR
	AIS	PRD,1
	JLFS	KEOT3A
	AHI	PRD,-KBSZ

KEOT3A	CLHI	R1,GOBBL&0FF
	JE	KEOGOB
KEOZAP	JAL	R9,ZAPHRD,,		:ZAPPER
	lis	r0,0
	sth	r0,kzptim,chn,chn	:not waiting for a zap ack
	IF	INTACC		:###EV
	LHI	R3,KERZFL-MNACHN,R5	:port into accounting port
	LIS	R0,AALR02		:Normal disconnect from Kernel
	JAL	R8,AARLO,,		:Perform final accounting
	EI	:INTACC		###EV
	SHI	LRC,-2,CD		:TERMINATE THE MESSAGE HERE
	LHL	R0,NII,KP,
	STH	R0,NOI,KP,
	J	KERO5

KEOGOB	SIS	CD,1			:GOBBLER
KEOGO1	JAL	R9,GOBBLE,,		:GOBBLER  -- ***NOTE!! GOBBLE IS CALLED
					: INSTEAD OF GOBBLN HERE BECAUSE IT
					: SEEMS UNLIKELY THAT NEEDLES OR SQFIXS
					: WILL BE GOBBLED BY THE KERNEL HOST.
	J	KERO6

	SUBTTL	XHOSTS (Kernel utility routines)

:	THE FOLLOWING SUBROUTINES ARE FOR HANDLING THE NEGATIVE INDEXED
: 	FORMAT FOR THE KERNEL INTERFACE RINGS. THERE ARE 6 RINGS:
:
:	KIB - DATA RING, NODE-->KERNEL
:		NII LEAD POINTER, NODE INDEXED
:		NOI TRAIL POINTER, KERNEL INDEXED
:
:	KOB - DATA RING, KERNEL-->NODE
:		NIO LEAD POINTER, KERNEL INDEXED
:		NOO TRAIL POINTER, NODE INDEXED
:
:	NEWLOG - PASS PORT NUMBERS OF NEW LOGINS, NODE-->KERNEL
:		NEWLOG-4 LEAD POINTER, NODE INDEXED
:		NEWLOG-2 TRAIL POINTER, KERNEL INDEXED
:
:	KOF - BIT ARRAY INDICATING DATA AVAILABLE, KERNEL-->NODE
:		KOF-4 LEAD POINTER, KERNEL INDEXED
:		KOF-2 TRAIL POINTER, NODE INDEXED
:
:	KCNTLI - CONTROL RING FOR GOBBLERS AND ZAPPERS, NODE-->KERNEL
:		KCNTLI-4 LEAD POINTER, NODE INDEXED
:		KCNTLI-2 TRAIL POINTER, KERNEL INDEXED
:
:	KCNTLO - CONTROL RING FOR GOBBLERS AND ZAPPERS, KERNEL-->NODE
:		KCNTLO-4 LEAD POINTER, KERNEL INDEXED
:		KCNTLO-2 TRAIL POINTER, NODE INDEXED
:

:	THE 'ROOM' SUBROUTINES DETERMINE THE SPACE AVAIABLE FOR INPUT
: 	RINGS (NODE-->KERNEL), OR COMPUTE THE AMOUNT OF DATA WAITING FOR
: 	OUTPUT RINGS (KERNEL-->NODE). ALL SUBS LINK ON R9, RETURN PRD AS THE
: 	NODE'S RING INDEX, AND LRC AS THE LENGTH. THE DATA RING ROUTINES LOAD
: 	R7 WITH THE RELATIVE DISPLACEMENT OF THE RING FOR THE CHAN OF INTEREST.

::*********************************************************************
::
::	SUBROUTINE:	KIROOM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN INPUT RING.
::	CALLING SEQ:	JAL	R9,KIROOM
::	INPUT:		KP  = R7 = CHANNEL NUMBER
::			CHN = R5 = CHANNEL NUMBER TIMES 2 FOR SOLO.
::
::*********************************************************************

KIROOM	SLLS	KP,2			:FW INDEX
	L	KP,KPRMAP,KP		:PORT RING DISPLACEMENT
	LH	PRD,NII,KP,		:NODE INDEX
	LH	LRC,NOI,KP,		:KERNEL INDEX
	SHI	LRC,2,PRD		:COMPUTE SPACE LEFT IN RING
	JGER	R9
	AHI	LRC,KBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	KOROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN RING BOUND FOR NETWORK.
::	CALLING SEQ:	JAL	R9,KOROOM
::	INPUT:		R2  = CHANNEL NUMBER
::			CHN = R5 = CHANNEL NUMBER TIMES 2 FOR SOLO
::
::*********************************************************************

KOROOM	SLLS	KP,2
	L	KP,KPRMAP,KP,
	LH	PRD,NOO,KP,		:NODE INDEX
	LH	LRC,NIO,KP,		:KERNEL INDEX
	SR	LRC,PRD			:COMPUTE AMOUNT OF DATA IN RING
	JGER	R9
	AHI	LRC,KBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN


	SUBTTL	XHOSTS (SUPIN - Moves network data into supervisor)

:	1 - Data ring data format (SIB/SOB)
:
:	  A - Sup port data of the form
:
:	    2 bytes Channel Number, 2 bytes Data Byte Count, N bytes Data
:
:	  B - Special case channel number zero
:
:	    Input to Supervisor
:	    2 bytes 0, 2 bytes 0002, 2 bytes Channel Number to be Zapped
:	    2 bytes 0, 2 bytes 0002, 2 bytes Sup # + 8000 - Sleeping Pill
:
:	    Output by Supervisor
:	    2 bytes 0, 2 bytes 0002, 2 bytes Chan # + 8000 to be Zapped
:	    2 bytes 0, 2 bytes 0002, 2 bytes w/o 8000 bit set - Going to Sleep
:
:	  C - Special case channel number one, to Sup only, indicating
:	    control character(s) other than zapper found going to Sup
:
:	    2 bytes 1,
:	    2 bytes of Byte Count,
:	    2 bytes Message Type + 0880 where Message Type
:		0 = Black Ball
:		1 = Gobbler
:		2 = Other Invalid Pair or Unpaired Control Character,
:	    2 bytes Offending Channel Number,
:	    2 bytes Invalid Pair (if present)
:
:	2 - Control ring data format (SIC/SOC)
:
:	    Output by Supervisor
:	    2 bytes Status Code
:	    	FFFF - Sup Sleeping
:	    	0001 - Sup Awake
:
:	    Input to Supervisor
:	    2 bytes Sup Port Zero Offset to Node Code Absolute Channel 0,
:	    2 bytes Node Number + 8000
:
:	3 - Backpressure control ring data format (SIBP/SOBP)
:
:	    2 bytes Channel Number - Relieve Backpressure
:	    2 bytes Channel Number + 8000 - Apply Backpressure

::*********************************************************************
::
::	SUBROUTINE:	SUPIN:
::	FUNCTION:	Moves characters into the sup input data ring (SIB)
::	CALLING SEQ:	JAL	R10,SUPIN
::	CALLS:		JAL	R9,SIROOM
::			JAL	R8,CBCCT
::			JAL	R8,GCLAST
::			JAL	R8,GCRET
::			JAL	R0,EXYLD
::			JAL	R8,GCI
::			JAL	R8,CBCLR
::			JAL	R9,ZAPV
::
::*********************************************************************

	IF	SUPER

sup.hw  eq      (nsp+0f)/10*2           :number of HWs*2 for sup bit arrays

SUPIN	ST	R10,XHSVRT		:SAVE RETURN
       if	split
	jal	r9,sirstt		:check sio ring status
	 j	xhret			:dead so avoid routine
       ei	:split
	lhl	chn,schnsv		:start where left off
	jnfs	supi01			:left off with some unserviced
	lhi	chn,sup.hw*8-1		:number of chns to scan
	jfs	supi01
:	come here to find another chn to service
supgrp	lhl	chn,schnsv		:start where left off
supi01	ohi     chn,0f                  :scan all bits in last hw
	lr	r2,chn
	srls	r2,3			:convert bits to bytes
	la      r3,supflg-1,r2,         :address of last hw (r2 is odd)
	la	r4,supsvd-1,r2,
	arand	r3,r5			:find match
	jfs	supi02			:got one
:	serviced all ports, set up servicable ports array
	la	r0,supbpv+sup.hw-2,,	:last HW of BPed arrays
	la	r1,supsvd+sup.hw-2,,	:last HW of service array
	lhi	r2,sup.hw*8-10		:number of bits - 10 to copy
	copy	r0,r2			:move bits quickly
	lis	r0,0			:mark all chns as serviced
	sth	r0,schnsv		:last chn serviced
	j	supixt			:none, exit

:	got a port to service
supi02	sth     chn,schnsv		:save last chn serviced
	JAL	R9,SIROOM		:ANY ROOM IN SIB RING?
	CLHI	PRC,8			:NEED AT LEAST 8 BYTES
	JLE	supixt			:DISMISS FROM SUPIN
SUPI22	RBT	CHN,SUPSVD,,		:THIS PORT SERVICED
	LHL	R2,SIOTAB,CHN,CHN	:CORRESPONDING BUFFER #
	NHI	R2,-4			:STRIP SPEED BITS
	JNFS	SUPI30
	CRASH.(.SUPIC)
SUPI30	XHI	R2,4			:DATA IS IN COMP BUFFER
	JAL	R8,CBCCT,,		:# OF CHARS IN BUFFER
	LHI	LRC,-6,PRC		:# OF CHARS THAT MAY BE MOVED IN
	CR	R1,LRC			:COMPUTE LEAST OF ABOVE
	JGEFS	SUPI32
	LR	LRC,R1			:LRC HAS IT
SUPI32	LHI	R1,200			:MOVE ONLY THESE AT ONE TIME
	CR	R1,LRC
	JGEFS	SUPI34
	LR	LRC,R1
SUPI34	LR	CD,LRC			:# OF CHARS TO MOVE
	JNFS	SUPI36
	CRASH.(.SUPI0)
SUPI36	LR	R11,PRD			:SAVE POINTER TO RECORD HEADER
	AIS	PRD,4			:INDEX PRD TO START OF DATA
	JLFS	SUPI38
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP

SUPI38	JAL	R8,GCI,,
	CLHI	R1,3			:test for TYMNET control pairs
	JGFS	SUPI70			:greater than 3 is data
	J	SUITYM			:jump to control pair handler
SUPI70	STB	R1,SIB,PRD,		:here for data character handler
	AIS	PRD,1
	JLFS	SUPI72
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUPI72	SIS	CD,1
	JG	SUPI38			:do another char

SUPI80	LR	R1,R11			:RESTORE POINTER TO LOGICAL REC HEADER
	STH	CHN,SIB,R1,		:STORE CHANNEL NUMBER
	AIS	R1,2
	JLFS	SUPI82
	SHI	R1,SUPBSZ		:NEGATIVE RING WRAP
SUPI82	STH	LRC,SIB,R1,		:STORE LOGICAL RECORD COUNT
	AM	LRC,SUPICC		:COUNT OF CHARS INTO SUP
       IF	SUPWAT
	AR	R5,R5			: 2*chn #
	AM	LRC,SUPCPI,R5,R5	: save cps to supe per port
	SRLS	R5,1			: restore chn
       EI	:SUPWAT
	THI	LRC,1			:ADD ZERO PAD IF ODD LRC
	JEFS	SUPI90
	LIS	R1,0
	STB	R1,SIB,PRD,
	AIS	PRD,1
	JLFS	SUPI84
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP

SUPI84	AIS	LRC,1

SUPI90	AIS	LRC,4			:TOTAL # OF CHARS INSERTED
	AH	LRC,NISI,,		:INCREMENT SIB LEAD POINTER
	JLFS	SUPI92
	SHI	LRC,SUPBSZ		:NEGATIVE RING WRAP
SUPI92	STH	LRC,NISI,,		:UPDATE POINTER, DONE WITH LOGICAL REC

	JAL	R0,EXYLD,,		:ALL DONE, YIELD BETWEEN TRANSFERS
	J	SUPGRP

:	control pair handler
SUITYM	JE	SUICTL			:IF 03 DETECTED - TEST FOR ZAPPER
	LR	R1,R1			:NOT 03 - IS IT AN ESCAPE?
	JN	SUIINV			:NO - INVALID CHARACTER PAIR DETECTED

	jal	r8,gci,,		:ESCAPE, GET NEXT CHAR
SUITY2	SIS	CD,1			:is it last char of msg? 
	JLE	SUPI70			:not last
	SIS	LRC,1			:escape affects message length
	J	SUPI70			:write char w/o escape into ring

:	DETECTED 03 CHARACTER ON COMMAND CIRCUIT. GET NEXT CHARACTER AND
:	TEST FOR A ZAPPER.
SUICTL	LR	R3,R3			:ANY MORE CHARACTERS IN BUFFER?
	JE	SUIINV			:NO, INVALID SINCE 03'S TRAVEL IN PAIRS
	ST	R3,BB,R2,
	JAL	R8,GCI,,		:GET NEXT BYTE
	LIS	R0,1			:SET R0 FOR GOBBLER DETECTED (SUICH1)
	CLHI	R1,GOBBL&0FF		:IS IT A GOBBLER?
	JL	SUIZAP			:NO, ITS A ZAPPER
	JE	SUICH1			:GOBBLER (R0 ALREADY SET UP)
	OHI	R1,300
	STH	R1,SUICHR		:INVALID 03 CHR PAIR - SAVE IT
	LIS	R0,2			:INDICATE INVALID CHARACTER PAIR AND
	J	SUICH1			: GO FORMAT CHANNEL 1 MESSAGE TO SUP

:	SOME KIND OF INVALID NETWORK CHARACTER DETECTED. DETERMINE WHAT
:	KIND, AND FORMAT CHANNEL 1 MESSAGE TO SUPERVISOR.
SUIINV	EXBR	R1,R1
	STH	R1,SUICHR		:SAVE FIRST CHARACTER OF PAIR
	LHL	R3,bct,r2,			:ANY MORE CHARACTERS IN BUFFER?
	JE	SUIN10			:NO, SECOND CHAR OF PAIR NOT PRESENT
	JAL	R8,GCI,,
	STB	R1,SUICHR+1		:SAVE SECOND CHARACTER OF PAIR
	LHL	R1,SUICHR
	CLHI	R1,01FD			:WAS CHAR PAIR BLACK BALL (BUFFER ZAP)?
	JNFS	SUIN10			:NO
	LIS	R0,0			:YES - INDICATE BLACK BALL DETECTED
	STH	R0,SUICHR		: ON COMMAND CIRCUIT
	JFS	SUICH1			: AND GO FORMAT CHAN 1 MESSAGE TO SUP
SUIN10	LIS	R0,2			:SHOW UNKNOWN INVAL CHAR PAIR DETECTED

:	FORMAT CHANNEL 1 MESSAGE TO SUPERVISOR. ROUTINE ENTERED WITH MESSAGE
:	TYPE IN R0 - 0 FOR BLACK BALL, 1 FOR GOBBLER, 2 FOR OTHER INVALID
:	CHARACTER PAIR. FIRST HW IS 088x, WHERE x IS THE MESSAGE TYPE. SECOND
:	HW CONTAINS THE OFFENDING PORT NUMBER. THIRD HW (IF PRESENT) HAS THE
:	CHARACTER PAIR DETECTED. REGISTER PRD IS SET TO POINT BACK TO BEGINNING
:	OF CURRENT RECORD, WHICH IS WRITTEN OVER.
SUICH1	LR	PRD,R11			:POINT BACK TO RECORD BEGINNING
	LR	LRC,R0			:GET MESSAGE TYPE AND
	LB	LRC,SUIC1S,LRC		: COMPUTE LENGTH OF MESSAGE
	LIS	R1,1
	STH	R1,SIB,PRD,		:CHANNEL 1 MESSAGE
	AIS	PRD,2
	JLFS	SUIC10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUIC10	STH	LRC,SIB,PRD,		:LENGTH OF MESSAGE
	AM	LRC,SUPICC		:INCREMENT COUNT OF CHARACTERS TO SUP
	AIS	PRD,2
	JLFS	SUIC20
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUIC20	OHI	R0,0880
       IF	CBZDBG			:trace event which causes supe to zap
	STM	R0,REGST		:save all regs
	JAL	R14,SUIDB1,,		:log this msg
	LM	R0,REGST		:restore all regs
       EI	 :CBZDBG
	STH	R0,SIB,PRD,		:STORE MESSAGE TYPE
	AIS	PRD,2
	JLFS	SUIC30
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUIC30	STH	CHN,SIB,PRD,		:STORE OFFENDING CHANNEL NUMBER
	AIS	PRD,2
	JLFS	SUIC40
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUIC40	CLHI	LRC,4			:IS THERE MORE FOR THIS MESSAGE?
	JLEFS	SUIC90			:NO
	LHL	R1,SUICHR		:YES - GET NEXT 2 BYTES
	STH	R1,SIB,PRD,		: AND STORE
	AIS	PRD,2
	JLFS	SUIC90
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUIC90	STH	CHN,SUERCH		:SAVE OFFENDING CHANNEL NUMBER
	STH	R0,SUERTP		: AND ERROR TYPE
	JAL	R8,CBCLR,,		:CLEAR BUFFER (index in R2)
	J	SUPI90			:DONE

:	zapper
SUIZAP	JAL	R9,ZAPV,,		:ZAPPER
	LR	PRD,R11
	AIS	PRD,4			:POINT TO BEGINNING OF DATA AREA
	JLFS	SUIZ10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUIZ10	RBT	CHN,SUPBPX,,		:NO MORE DATA FLOW ON THIS CHANNEL
	STH	CHN,SIB,PRD,		:SEND ZAPPER MESSAGE ON CHANNNEL 0
	AIS	PRD,2
	JLFS	SUIZ20
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUIZ20	LIS	CHN,0
	LIS	LRC,2			:MESSAGE LENGTH
	J	SUPI80

:	SUPIN pre exit to store histogram info on the sup ring
supixt	LH	R3,NISI,,		:FILL :how much in RING
	SH	R3,NOSI,,		:EMPTY some stattics
	JGEFS	supix1
	AI	R3,SUPBSZ
supix1	CH	R3,SUPICP		:new max amoung in ring
	JLEFS	supix2
	STH	R3,SUPICP		:
supix2	SRHL	R3,SSCALE		:make histogram entry
	NHI	R3,1C			:keep it in range
	LIS	R0,1
	AM	R0,SPIHGM,R3
	JGEFS	supix5			:zero all when use 32nd bit
	LIS	R0,0
	LHI	R1,1C			:zero all entries
supix3	ST	R0,SPIHGM,R1,
	SIS	R1,4			:clear histogram
	JGEBS	supix3
supix5	j	xhret

::*********************************************************************
::
::	TABLE:	   SUIC1S:
::	FUNCTION:  LENGTHS FOR CHANNEL 1 MESSAGES, ORDERED BY MESSAGE TYPE
::
::*********************************************************************

SUIC1S	BC	6,4,6,0

	EI	:SUPER

	SUBTTL	XHOSTS (SUPOUT - Moves sup data out into network)

::*********************************************************************
::
::	SUBROUTINE:	SUPOUT:
::	FUNCTION:	Moves data from sup output data ring (SOB) into network
::	CALLING SEQ:	JAL	R10,SUPOUT
::	CALLS:		JAL	R9,SOROOM
::			JAL	R8,WCI
::			JAL	R9,SIBPRM
::			JAL	R0,EXYLD
::			JAL	R9,ZAPHRD
::			JAL	R10,SCQZAP
::			JAL	R8,CRYPTO
::
::*********************************************************************

	IF	SUPER

SUPOUT	ST	R10,XHSVRT		:save return
       if	split
	jal	r9,sirstt		:check sio ring status
	 j	xhret			:dead so avoid routine
       ei	:split
	LH	R3,NISO,,		:FILL: gather some statistics
	SH	R3,NOSO,,		:EMPTY: how much in RING
	JGEFS	SUPOU1
	AI	R3,supbsz
SUPOU1	CH	R3,SUPOCP		:new max amoung in ring
	JLEFS	SUPOU2
	STH	R3,SUPOCP		:
SUPOU2	SRHL	R3,SSCALE		:now make histogram entry
	NHI	R3,1C			:keep in in range
	LIS	R0,1
	AM	R0,SPOHGM,R3
	JGE	supo03			:zero all when use 32nd bit
	LIS	R0,0
	LHI	R1,1C			:zero all entries
SUPOU3	ST	R0,SPOHGM,R1,
	SIS	R1,4			:clear histogram
	JGEBS	SUPOU3

	jfs	supo03

SUONXT	LB	R1,LEPFLG,,		:process msg from our sup as it arrives
	JEFS	supo03			:NO DATA FROM SUPERVISOR
	jal	r10,lep,,
supo03	JAL	R9,SOROOM		:COMPUTE AMOUNT OF DATA IN SOB RING
	LR	PRC,PRC
	JE	XHRET			:NO DATA, RETURN TO SPIDER

	LHL	CHN,SOB,PRD,		:GET THE PORT #
	JE	SUZERO			:PORT 0 MESSAGE
	AIS	PRD,2
	JLFS	SUPO10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUPO10	LHL	LRC,SOB,PRD,		:# OF DATA BYTES TO MOVE
	AM	LRC,SUPOCC		:COUNT OF CHARS FROM SUP

:	sup monitoring stats by message type.
       IF	SUPWAT			:				###HFT
	AR	R5,R5
	AM	LRC,SUPCPO,R5,R5	: count chars by port
	SRLS	R5,1
	LR	R8,PRD
	AIS	R8,4			: get to msg type
	JLFS	SUPO12
	SHI	R8,SUPBSZ		: negative ring wrap

::  get msg type
SUPO12	LB	R1,SOB,R8,		: msg type
	SIS	R1,0E			: type 0E - response to aux circuit req
	JEFS	SUPO14
	AIS	R1,1			: normal log response,<= type 0D
	JNFS	SUPO16
SUPO14	LIS	R1,1			: count it
	AR	R5,R5
	AM	R1,SUPREJ,R5,R5
	SRLS	R5,1
	J	SUPO28

SUPO16	AIS	R1,0D-9			: needle(type 9)?
	JN	SUPO28			: no
	LIS	R1,1			: yes, it is needle.
	AR	R5,R5
	AM	R1,SUPNED,R5,R5 	: count it
	LB	R0,SOB+1,R8,		: get link count
	NHI	R0,7F			: knock off high bit
	JNFS	SUPO18
	AHM	R1,SUPIND,R5,		: internal circuits
	SRLS	R5,1
	J	SUPO28			: don't do dest stuff since is orig

SUPO18	AM	R0,SUPILC,R5,R5		: link count for orig node
	SRLS	R5,1
	AIS	R8,0C			: get to needle list
	JLFS	SUPO20
	SHI	R8,SUPBSZ		: negative ring wrap
SUPO20	LIS	R4,0			: sort of error, don't count it
SUPO22	LH	R3,SOB,R8,		: get next neighbor
	JLFS	SUPO26			: got host so last was node
	LR	R4,R3			: save last node number
	AIS	R8,2			: look for next node number
	JLBS	SUPO22
	SHI	R8,SUPBSZ		: negative ring wrap
	JBS	SUPO22 

SUPO26	CLHI	R4,NSP+2+400		: valid node #?
	JGFS	SUPO28			: no, ignore it (error of some sort)
	SHI	R4,3FE			: convert to internal port #
	AR	R4,R4
	AM	R0,SUPDLC,R4,R4		: link count as destination
	AM	R1,SUPDND,R4,R4		:  and a destination needle
SUPO28	
       EI	:SUPWAT	

	AIS	PRD,2
	JLFS	SUPO30
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
:	FORCE SIZE TO HW BOUNDARY AND SAVE IN PRC. WILL UPDATE NOSO
: 	WHEN DONE EMPTYING THIS LOGICAL RECORD.
SUPO30	LHI	PRC,5,LRC		:LRC + 4-BYTE HEADER,
	NHI	PRC,-2			: ROUNDED UP IF NECESSARY

	LHL	R2,SIOTAB,CHN,CHN	:GET BUFF #
	NHI	R2,-4
	JE	SUOER1			:UNASSIGNED CHANNEL - IGNORE
:	following len logic is to allow passing of large msgs.  If
:	msg len will end up (after escaping) under 100x bytes then it
:	has an escape byte and a byte of len.  If the len is between 100
:	and 600x after escaping then escape both bytes of len.  If len>600x
:	then don't escape 1st byte since if escaped it would look like a
:	msg of 6 bytes (which is the smallest legal msg).		###sdw
	LR	CD,LRC			:save from sup msg length
	LIS	R1,0			:WRITE THE LEADING ESCAPE FOR BYTE CNT
	JAL	R8,WCI,,
	CLHI	LRC,400 		:very large msg?
	JLFS	SUPO33  		:nope
	AIS	LRC,1			:one more length byte for 3 byte length
	L	R11,BE,R2,		:1st byte not escaped
	J	SUPO36
SUPO33	JAL	R8,WCI,,		:SAVE SPACE FOR BYTE COUNT
	AIS	LRC,2			:two length bytes for 4&2 byte lengths
	L	R11,BE,R2,		:POINTER TO BYTE COUNT
	CLHI	LRC,0C0 		:two byte len (with escapes)?
	JLFS	SUPO45  		:nope just one byte len
SUPO36  JAL	R8,WCI,,  		:escape low byte
	JAL	R8,WCI,,
	AIS	LRC,2			:two more length bytes for 4&3 byte len
	AI	R11,80000000		:and mark this as a HW of len
SUPO45	LB	R1,SOB,PRD,		:GET BYTE
	AIS	PRD,1
	JLFS	SUPO48
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUPO48	CLHI	R1,4			:DOES IT NEED TO BE ESCAPED?
	JGEFS	SUPO50
	EXBR	R1,R1			:YES
	JAL	R8,WCI,,
	EXBR	R1,R1
	AIS	LRC,1			:BYTE COUNT IS AFFECTED
SUPO50	JAL	R8,WCI,,
	SIS	CD,1
	JG	SUPO45			:get another byte

:	following finishes the different types of len			###sdw
	LR	R3,R11
	TI	R11,80000000		:is this a long len?
	JEFS	SUPO54  		:nope
	NI	R3,7FFFFFFF		:make back into address
	EXBR	LRC,LRC
	STB	LRC,0,R3		:save hign byte of len
	EXBR	LRC,LRC
	JAL	R8,NCI,,  		:advance over escape byte
	JAL	R8,NCI,,  		:point to low byte of len
SUPO54	STB	LRC,0,R3		:SET THE FINAL BYTE COUNT
	LHL	R0,BCT,R2,		:BACKPRESSURE SUP IF BUFF TOO FULL
	lis	r9,3
	nh	R9,SIOTAB,CHN,CHN	:GET BUFF #
	clh	r0,cirspk,r9,r9
	JL	SUPO66			:DON'T BACKPRESSURE

:	backpressure sup (SIBP)
SUPO60	LR	R0,PRC			:SAVE RECORD LENGTH,
	JAL	R9,SIBPRM		: SET UP SIBP POINTERS,
	LR	PRC,PRC			: AND TEST FOR ROOM IN SIBP RING
	JLE	SUPO65			:NO ROOM, DON'T APPLY BACKPRESSURE
	LR	R9,CHN
	OHI	R9,8000			:CHN+8000 TO TURN BACKPRESSURE ON
	STH	R9,SIBP,PRD,		:APPLY BACKPRESSURE FOR THIS CHANNEL
       if	sr.gmt			:if saving time of sending BP msg
	stm	r0,spgmtr,,		:save regs
	jal	r9,gmtcal,,
	l	r2,gmtnow
	st	r2,sibpgm,prd,prd	:save time in gmt
	LM	r0,spgmtr,,		:restore regs
       ei	:sr.gmt
	AIS	PRD,2
	JLFS	SUPO62
	SHI	PRD,SIBPSZ		:NEGATIVE RING WRAP
SUPO62	STH	PRD,NISIBP,,		:UPDATE LEAD POINTER
	RBT	CHN,SUPBPX,,		:BACKPRESSURE APPLIED THIS CHANNEL
supo65	LR	PRC,R0			:RESTORE PRC

:	DONE WITH THIS RECORD - UPDATE NOSO...
SUPO66	AH	PRC,NOSO,,		:SOB TRAIL POINTER
	JLFS	SUPO70
	SHI	PRC,SUPBSZ		:NEGATIVE RING WRAP
SUPO70	STH	PRC,NOSO,,

	JAL	R0,EXYLD,,		:YIELD AFTER TRANSFER
	J	SUONXT			:ALL DONE W/ THIS PORT

:	port 0 message
SUZERO	AIS	PRD,4			:PORT 0 MESSAGE
	JLFS	SUZER1
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
SUZER1	LHL	CHN,SOB,PRD,		:THIS IS THE ZAPPED CHANNEL
	LIS	PRC,6			:RECORD SIZE 6, UPDATE NOSO IN 'SUPO52'
	THI	CHN,8000		:TEST FOR SPECIAL MESSAGE
	JN	SUOSLP			:SLEEP MESSAGE

:	sup zap
SUOZAP	LHL	R2,SIOTAB,CHN,CHN	:ZAPPER
	NHI	R2,-4
	JE	SUOER2			:UNASSIGNED CHANNEL, IGNORE
	JAL	R9,ZAPHRD,,
	J	SUPO60			:AND BACKPRESSURE CHANNEL

:	sup has gone to sleep
SUOSLP	STH	PRC,XHPRCS		:SAVE PRC
	LIS	R0,4			:SAVE SUP STATE in crypto
	jal	r8,crypto,,		:report it
	 hc	crye3d
	JAL	R10,SCQZAP		:ZAP ALL COMMAND CIRCS FROM SUP INTERF
	LHL	PRC,XHPRCS
	LIS	R0,4			:SET SUP STATE
	STH	R0,TVRSTT
	J	SUPO66			:ALL CIRCUITS ZAPPED, UPDATE NOSO

:	CRYPTO 24: SUP DATA ON UNASSIGNED CHN
SUOER1	LR	R0,CHN			:SUP SENT DATA ON UNASSIGNED PORT
	JAL	R8,CRYPTO,,		:REPORT TO XRAY WITH CHANNEL NUM IN R0
	 HC	CRYE24
	J	SUPO66			:GO UPDATE NOSO AND DISMISS

:	CRYPTO 25: SUP ZAP ON UNASSIGNED CHN
SUOER2	LR	R0,CHN			:SUP SENT ZAPPER ON UNASSIGNED PORT
	JAL	R8,CRYPTO,,		:REPORT TO XRAY WITH CHANNEL NUM IN R0
	HC	CRYE25
	J	SUPO66

	EI	:SUPER

	SUBTTL	XHOSTS (Sup process utility routines)

:	THE FOLLOWING SUBROUTINES ARE FOR HANDLING THE NEGATIVE
: 	INDEXED FORMAT FOR THE SUPERVISOR INTERFACE RINGS.
: 	THERE ARE 6 RINGS:
:
:	SIB - DATA RING, NODE-->SUP
:		NISI LEAD POINTER, NODE INDEXED
:		NOSI TRAIL POINTER, SUP INDEXED
:
:	SOB - DATA RING, SUP-->NODE
:		NISO LEAD POINTER, SUP INDEXED
:		NOSO TRAIL POINTER, NODE INDEXED
:
:	SIBP - BACKPRESSURE RING, NODE-->SUP
:		NISIBP LEAD POINTER, NODE INDEXED
:		NOSIBP TRAIL POINTER, SUP INDEXED
:
:	SOBP - BACKPRESSURE RING, SUP-->NODE
:		NISOBP LEAD POINTER, SUP INDEXED
:		NOSOBP TRAIL POINTER, NODE INDEXED
:
:	SIC - CONTROL RING, NODE--SUP
:		NISIC LEAD POINTER, NODE INDEXED
:		NOSIC TRAIL POINTER, SUP INDEXED
:
:	SOC - CONTROL RING, SUP-->NODE
:		NISOC LEAD POINTER, SUP INDEXED
:		NOSOC TRAIL POINTER, NODE INDEXED
:
:	THE 'ROOM' SUBROUTINES DETERMINE THE SPACE AVAILABLE FOR INPUT
: 	RINGS (NODE-->SUP), OR COMPUTE THE AMOUNT OF DATA WAITING FOR
: 	OUTPUT RINGS (SUP-->NODE). ALL SUBS LINK ON R9, RETURN PRD AS THE
: 	NODE'S RING INDEX, AND PRC AS THE LENGTH.

	IF	SUPER

::*********************************************************************
::
::	SUBROUTINE:	SIROOM:
::	FUNCTION:	COMPUTE AMOUNT OF SPACE AVAILABLE IN SIB
::	CALLING SEQ:	JAL	R9,SIROOM
::
::*********************************************************************

SIROOM	LH	PRD,NISI,,		:NODE INDEX
	NEGTST(NOP,,NISI,0)		:IF DB.DEB, INSURE NEG RING POINTERS
	LH	PRC,NOSI,,		:SUP INDEX
	NEGTST(NOP,,NOSI,0)
	IF	DB.DEB
	STH	PRD,SRNRPS		:SAVE USEFUL VALUES
	STH	PRC,SRNPRS
	EI	:DB.DEB
	SHI	PRC,2,PRD		:COMPUTE SPACE LEFT IN RING
	JGER	R9
	AHI	PRC,SUPBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SOROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA AVAILABLE IN SOB
::	CALLING SEQ:	JAL	R9,SOROOM
::
::*********************************************************************

SOROOM	LH	PRD,NOSO,,		:NODE INDEX
	NEGTST(NOP,,NOSO,0)		:IF DB.DEB, INSURE NEG RING POINTERS
	LH	PRC,NISO,,		:SUP INDEX
	NEGTST(NOP,,NISO,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA IN RING
	JGER	R9
	AHI	PRC,SUPBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

:	THE FOLLOWING ROUTINES APPLY ONLY TO THE NEGATIVE INDEX SUPERVISOR
:	INTERFACE SINCE THE RINGS REFERENCED DO NOT EXIST OTHERWISE.

::*********************************************************************
::
::	SUBROUTINE:	SIBPRM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN SIBP RING
::	CALLING SEQ:	JAL	R9,SIBPRM
::
::*********************************************************************

SIBPRM	LH	PRD,NISIBP,,		:NODE INDEX
	NEGTST(NOP,,NISIBP,0)
	LH	PRC,NOSIBP,,		:SUP INDEX
	NEGTST(NOP,,NOSIBP,0)
	SHI	PRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	PRC,SIBPSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SOBPRM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN SOBP RING
::	CALLING SEQ:	JAL	R9,SOBPRM
::
::*********************************************************************

SOBPRM	LH	PRD,NOSOBP,,		:NODE INDEX
	NEGTST(NOP,,NOSOBP,0)
	LH	PRC,NISOBP,,		:SUP INDEX
	NEGTST(NOP,,NISOBP,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	PRC,SOBPSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SICROM:
::	FUNCTION:	COMPUTE AMOUNT OF SPACE AVAILABLE IN SIC RING
::	CALLING SEQ:	JAL	R9,SICROM
::
::*********************************************************************

SICROM	LH	PRD,NISIC,,		:NODE INDEX
	NEGTST(NOP,,NISIC,0)
	LH	PRC,NOSIC,,		:SUP INDEX
	NEGTST(NOP,,NOSIC,0)
	SHI	PRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	PRC,SICSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SOCROM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA WAITING IN SOC RING
::	CALLING SEQ:	JAL	R9,SOCROM
::
::*********************************************************************

SOCROM	LH	PRD,NOSOC,,		:NODE INDEX
	NEGTST(NOP,,NOSOC,0)
	LH	PRC,NISOC,,		:SUP INDEX
	NEGTST(NOP,,NISOC,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	PRC,SOCSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN


::********************************************************************* 
::
::	SUBROUTINE:	IZSIRG		(Split Sup only)
::	FUNCTION:	Issues SVC57 to connect the 3 rings pairs used in 
::			SIO ring interface.  These are data, control, and 
::			backpressure rings.  After SVC57 is issued, this
::			routine doublechecks whatever returned by ISIS
::			matches what we think should be, such as the
::			pointers to where the rings addresses and sizes.
::			Other initializations are done here such as
::			resetting the fill cursors of all rings.  Crypto
::			messages will be logged according to whether
::			the ring connect is successful or not.
::
::			Called from init (Initializes SWITCH), and from
::			SIRSTT if ring status changes from down to up.
::
::	CALLING SEQ:	JAL	R10,IZSIRG
::	DESTROYED:	R0-R5 and R8
::	CALLS:		SVC SYS,$A 57 
::			JAL	R8,CRYPTO
::
::	SVC SYS,$A 57 has the following register usage:
::	 SVC Input -	r0 = slot segment # specify which segment to be used 
::				for shared memory purpose.  
::			r1 = Slot logical unit # 
::  
::	 SVC Output - 	r0 = status (0=successful, 1=bad log unit #, 
::				 2=no shared mem seg selected, 
::			  	 3=seg select err, for a seg already in use) 
::			r1 = SIO Ring input starting address 
::			r2 = SIO Ring input ring size 
::			r3 = SIO Ring output ring size
::			r4 = Shared mem seg # selected) 
::  
:: 	NC lays out its rings (data, backpressure, & control i/o rings) in 
::	its memory & has ISIS map it to the NC specified segment.  
::
::*********************************************************************

       IF	SPLIT

SRNADR	WC	sobbse,sobpbs,socbse
SRORSZ	HC	supbsz,sobpsz,socsz
SRIRSZ	HC	supbsz,sibpsz,sicsz

IZSIRG	LIS	R0,0
	STB	R0,SPLCON		: mark shared mem as not being up

	LIS	R4,0			: LU index of the data ring
	LIS	R0,A.SUP		: seg 0C is for shared mem

IZSIR2	LR	R1,R4			: LU # in R1
	SVC	SYS,$A 57		: Issue SIO Ring connect

       IF	DB.DEB
	SLLS	R4,6			: R4 * 64
	STM	R0,S57SAV,R4		: save all registers for all 3 SVCs
	SRLS	R4,6			: restore R4
       EI	:DB.DEB

	LR	R0,R0			: bad SIO Ring connect?
	JN	IZSIR8			: go handle bad connect response

:	Ring Connected, double check parameters returned to us by ISIS
	LR	R5,R4			:save R4 as LU index
	AR	R5,R5			: Offset to index in ring tables
	LHI	r0,84			: ring address mismatch err
	CL	R1,SRNADR,R5,R5		:  same as address NC expected?
	JN	IZSIR8			: inconsistency found in ring addr

	AIS	R0,1			: errcode (85) for input ring size
	CLH	R2,SRIRSZ,R5		: same size NC expected?
	JN	IZSIR8			: nope. found in input ring size
	AIS	R0,1			: errcode (86) for ouput ring size

	CLH	R3,SRORSZ,R5		: same size NC expected?
	JN	IZSIR8			: inconsis. found in output ring size

:	loop around and do another ring if not yet done
	LCS	R0,1			:specify seg is same as last svc call
	AIS	R4,1			: increment LU #
	CHI	R4,03			: have we done it for all 3 rings?
	JL	IZSIR2			: no, continue the 3 ring circus

:	set pointers equal (mainly in case of restart)
	JAL	R8,IZSUP		:	
	LIS	R5,1			: things are cool, now set 
	STH	R5,SPLCON		:  shared memory connected flag = 1
	JAL	R8,CRYPTO,,		: and send cryptogram
	 HC	CRYE3A			: (SIO Ring connect successful)
	JR	R10			: initialization complete return to caller

:  	SIO Ring Connect SVC57 failed, reason in R0 and LU in R4
:	As this is a mismatch with ISIS, it is not a recoverable situation
IZSIR8	EXHR	R4,R4			: Get Ring LU into HW0
	OR	R0,R4			: combine with error code
	JAL	R8,CRYPTO,,		: codes 1-3 are isis failures
	 HC	CRYE78			: and 84+ are nc detected
	CRASH.(.IZSIR)


       EI	:SPLIT

::*********************************************************************
::
::	SUBROUTINE:	SIRSTT		(SPLIT SUP ONLY)
::	FUNCTION:	Check for status change for SIO Ring card
::			SIO MB status Halfwords are stored in SIRX,
::			send Cryptogram for each status change, and test
::			for up/down conditions to set SIRFLG.
::
::			Set status 'UP' or 'DOWN' via SIRFLG 
::			(local translated flag) according to what ISIS has
::			indicated in SIRX.  SIRFLG could be:
::			 0 => down (if real SIO stat = -1 or 30)
::		       	-1 => up   (if real SIO stat = 70)
::		       	3f => ring pair mismatch (if real SIO stat = 20)
::			3E => unknown status
::
::
::	CALLING SEQ:	JAL	R9,SIRSTT
::	DESTROYED:	R0-R5, R8, and R10
::	CALLS:		JAL	R8,CRYPTO
::			JAL	R10,SPLSIO
::			JAL	R10,SCQZAP
::	RETURNS:	+0 if a change (caller may want to know)
::			+4 if status is same as before
::
::*********************************************************************

       IF	SPLIT

SIRSTT	LB	R0,SIRXMY,,		:Get stat for my SIO MB
	CLB	R0,SIRXOL		: same stat as the before
	jnfs	SIRST1			:we have a change
	clhi	r0,70			:is same state the up state?
	JE	4,R9			: yes, return +4
	jr	r9			:no down

SIRST1	JAL	R8,CRYPTO,,		:no, send cryptogram with new status
	 HC	CRYE3B			: SIO RING INTERRUPT - STATUS msg

:	Update SIO MB Status and Translate status to NC SIO Ring Status
	JAL	R10,SIRCNV		: get translated ring status
	LR	R1,R1			: is ring up (up = -1)
	JGEFS	SIRST4			: status = not up
:	RING UP: do not call izsirg now, it is too late as ring is up and
:	active.  and may have important data
:	JAL	R10,IZSIRG		: status = up, init SIO ring interface
	J	4,R9			: as it must have prev been down

:	ring is down (null return)
SIRST4	jal	r8,izsup		:ring down count it all as read
	lr	r10,R9			: return to routine in R9.
	J	SCQZAP			: zap SUP circuits immediately
       EI	:SPLIT

::*********************************************************************
::
::	SUBROUTINE:	SIRCNV	SIo Rng status CoNVert (SPLIT SUP ONLY)
::	FUNCTION:	Updates SIO MB Status in SIRXOL and Translates it to
::			NC SIO Ring Status.  Called only when SIO card first
::			comes up (by init) or if status	changes from down to
::			up (by SIRSTT).
::			
::			Records status 'UP' or 'DOWN' via SIRFLG 
::			(local translated flag) according to MB status
::			stored in SIRX.
::
::		Card Status			Ring Status
::		 -1 or 30			 0 => down
::	       	    70				-1 => up
::		    20			3F => ring pair mismatch (like down)
::		 any others			 0 => down
::			
::			Called from init after SPLSIO (initialization of 
::			Split Sup), and from SIRCIN (xhosts).
::
::	CALLING SEQ:	JAL	R10,SIC2RS
::	DESTROYED:	R0,R1
::	CALLS:		JAL	R8,CRYPTO
::	RETURNS:	R1 = translated SIO Ring Status	
::
::*********************************************************************

       IF	SPLIT

SIRCNV	LB	R0,SIRXMY,,		: get status for my SIO MB
	STB	R0,SIRXOL		: update status

:	if status = 70 then SIO card is up and set SIO ring stat to -1 
	LCS	R1,1			: load xlated stat = -1
	CLHI	R0,SIRUP		: SIO Card up?
	JE	SIRCN7			: yes, update xlated status

:	if status = 20 then SIO ring mismatch and set SIO ring stat to 3f
	LHI	R1,STSRM0		: load xlated stat=3f
	CLHI	R0,SIRRM0		: Ring pair mismatch for ring 0?
	JEFS	SIRCN4			: yes, update xlated status

:	if status = 0 then Sup not loaded and set SIO ring stat to 0
	LIS	R1,0			: load in xlated status, 0=down
	CLHI	R0,SIRINT		: SIO Card in init state?
	JEFS	SIRCN4			: yes, update xlated status

:	if R0 = 30 then SIO card is down and set SIO ring stat to 0
	CLHI	R0,SIRDWN		: SIO Card down?
	JEFS	SIRCN4			: yes, update xlated status

:	if R0 = unknown value then consider SIO ring down
	LHI	R1,3E			:remember bad status

SIRCN4	JAL	R8,CRYPTO,,		: log crypto message
	 HC	CRYE3C			: 3C msg = SIO RING IS DOWN

SIRCN7	STH	R1,SIRFLG		: save ring status
	JR	R10			: return

       EI	:SPLIT


::*********************************************************************
::
::	SUBROUTINE:	IZSUP:
::	FUNCTION:	INITIALIZE FIELDS FOR SUP INTERFACE
::	CALLING SEQ:	JAL	R8,IZSUP
::
::*********************************************************************

:	INITIALIZE NEGATIVE RING POINTERS.  If split then can only equate
:	ring pointers for rings sending data to NC.  If normal sup then
:	can set all ring pointers to initial values

IZSUP	HS	0
     if		split
	LH	R4,NISO,,		:fill cursor for SUP->NC data ring
       IF	DB.DEB
	STH	R4,SIOSAV
	LH	R0,NOSO,,
	STH	R0,SIOSAV+2
       EI	:DB.DEB
	STH	R4,NOSO,,		:  equate it to empty cursor

	LH	R4,NISOBP,,		:fill cursor for SUP->NC bp ring
       IF	DB.DEB
	STH	R4,SIOSAV+4
	LH	R0,NOSOBP,,
	STH	R0,SIOSAV+6
       EI	:DB.DEB
	STH	R4,NOSOBP,,		:  equate it to empty cursor

	LH	R4,NISOC,,		:fill cursor for SUP->NC control ring
       IF	DB.DEB
	STH	R4,SIOSA2
	LH	R0,NOSOC,,
	STH	R0,SIOSA2+2
       EI	:DB.DEB
	JR	R8
    else	:not split
	STH	R4,NOSOC,,		:  equate it to empty cursor
	LHI	R0,-SUPBSZ
	STH	R0,NISI,,		:INIT SIB POINTERS
	STH	R0,NOSI,,

	STH	R0,NISO,,		:INIT SOB POINTERS
	STH	R0,NOSO,,

	LHI	R0,-SIBPSZ
	STH	R0,NISIBP,,		:INIT SIBP POINTERS
	STH	R0,NOSIBP,,

	STH	R0,NISOBP,,		:INIT SOBP POINTERS
	STH	R0,NOSOBP,,

	LHI	R0,-SICSZ
	STH	R0,NISIC,,		:INIT SIC POINTERS
	STH	R0,NOSIC,,

	STH	R0,NISOC,,		:INIT SOC POINTERS
	STH	R0,NOSOC,,

	JR	R8			:RETURN

       ei	:1-split

::*********************************************************************
::
::	SUBROUTINE:	SUPBPS:
::	FUNCTION:	RELIEVE BACKPRESSURE ON SUP PORTS THAT HAVE
::			SUFFICIENTLY LOW CHARACTER COUNTS
::	CALLING SEQ:	JAL	R10,SUPBPS
::			JAL	R9,SIBPRM
::			JAL	R9,SOBPRM
::
::*********************************************************************

SUPBPS	ST	R10,XHSVRT		:SAVE RETURN ADDRESS
       if	split
	jal	r9,sirstt		:check sio ring status
	 j	xhret			:dead so avoid routine
       ei	:split
	LHI	R7,((sup.hw+1)/2)*2-4

:	set up array with ports needing service
	LCS	R1,1
SUPB10	L	R0,SUPBPX,R7,		:PORTS/BITS ARE RESET IF BACKPRESSURED
	O	R0,SUPACP,R7,		:PORTS ACTIVE IF RESET
	XR	R0,R1			:SET IF ACTIVE .AND. BACKPRESSURED
	ST	R0,scratc,r7,		:USED AS TEMP STORAGE
	sis	r7,4
	jgebs	supb10
	lhi	r5,sup.hw*8-1		:then quickly check array
	jfs	supb16

:	search array of ports needing service
supb15	lhl	r5,bchnsv
	ohi	r5,0f			:scan all bits in last hw
supb16	lr	r2,r5
        srls	r5,3			:convert bits to bytes
	la      r3,scratc-1,r5,		:address of last hw (r5 is odd)
	lr	r4,r3
	arand	r3,r2			:find match
	jfs	supb20			:got one
	j	supb40			:no more chns needing service

SUPB20	sth	r2,bchnsv		:remember where left off search
	RBT	R2,scratc,,		:reset serviced array
	LHL	R3,SIOTAB,R2,R2
	LR	R6,R3			:SAVE CIRCUIT SPEED
	NHI	R3,-4			:R3=BUFF #
	JE	SUPB15			:IDLE CHANNELS REMAIN BP'ED
	NHI	R6,3			:SPEED BITS
	LHL	R6,CIRSPK,R6,R6		:SPEED
	CLH	R6,BCT,R3,
	JL	SUPB15			:PORT MUST REMAIN BP'ED
:	SEND CHANNEL NUMBER OVER SIBP RING TO RELEASE BACKPRESSURE
	JAL	R9,SIBPRM		:IS THERE ROOM IN SIBP?
	LR	PRC,PRC
	JLE	SUPB40			:NO ROOM, PROCEED NO FURTHER
	STH	R2,SIBP,PRD,		:RELEASE BACKPRESSURE FOR THIS CHANNEL
       if	sr.gmt			:if saving time of sending BP msg
	stm	r0,spgmtr,,		:save regs
	jal	r9,gmtcal,,
	l	r2,gmtnow
	st	r2,sibpgm,prd,prd	:save time in gmt
	lm	r0,spgmtr,,		:save regs
       ei	:sr.gmt
	AIS	PRD,2
	JLFS	SUPB22
	SHI	PRD,SIBPSZ		:NEGATIVE RING WRAP
SUPB22	STH	PRD,NISIBP,,		:UPDATE SIBP LEAD POINTER
	SBT	R2,SUPBPX,,		:INDICATE THIS CHANNEL'S BP RELEASED
	J	SUPB15

:	now do histogram of backpressure ring
supb40					:and relieve bp is done
	LH	R3,NISIBP,,		:FILL: how much in RING
	SH	R3,NOSIBP,,		:EMPTYgather some statistics
	JGEFS	supb51
	AI	R3,SIBPSZ
supb51	CH	R3,SIBCP		:new max amoung in ring
	JLEFS	supb52
	STH	R3,SIBCP		:
supb52	SRHL	R3,SBSCAL		:make histogram entry
	NHI	R3,1C			:keep it in range
	LIS	R0,1
	AM	R0,SIBHGM,R3
	JGEFS	supb55			:zero all when use 32nd bit
	LIS	R0,0
	LHI	R1,1C			:zero all entries
supb53	ST	R0,SIBHGM,R1,
	SIS	R1,4			:clear histogram
	JGEBS	supb53
supb55	j	xhret


::*********************************************************************
::
::	SUBROUTINE:	SPIBPS:
::	FUNCTION:	Read sup backpressure rings.  Find out which ports
::			are now backpressured and which are released.  Must
::			be read frequently since we do not want this ring
::			to get full.
::
::			called from SPIDER before it calls SUPIN
::
::	CALLING SEQ:	JAL	R10,SPIBPS
::	CALLS:		JAL	R9,SOBPRM
::
::*********************************************************************

:	GET SUP BACKPRESSURE DATA FROM SOBP RING. CHANNEL NUMBER
: 	RELEASES BACKPRESSURE, CHANNEL NUMBER + 8000 APPLIES BACKPRESSURE.


SPIBPS	st	r10,xhsvrt
       if	split
	jal	r9,sirstt		:check sio ring status
	 j	xhret			:dead so avoid routine
       ei	:split
	LH	R3,NISOBP,,		:FILL: gather some statistics
	SH	R3,NOSOBP,,		:EMPTY: how much in RING
	JGEFS	spib10
	AI	R3,SOBPSZ
spib10	CH	R3,SOBCP		:new max amoung in ring
	JLEFS	spib12
	STH	R3,SOBCP		:
spib12	SRHL	R3,SBSCAL		:make histogram entry
	NHI	R3,1C			:keep it in range
	LIS	R0,1
	AM	R0,SOBHGM,R3
	JGEFS	spib20			:zero all when use 32nd bit
	LIS	R0,0
	LHI	R1,1C			:zero all entries
spib15	ST	R0,SOBHGM,R1,
	SIS	R1,4			:clear histogram
	JGEBS	spib15
spib20	JAL	R9,SOBPRM		:ANY DATA IN SOBP RING?
	LR	PRC,PRC
	JLE	XHRET			:NO - RETURN
       if	sr.gmt			:if saving time of getting msg
	jal	r9,gmtcal,,
	l	r2,gmtnow
	st	r2,sobpgm,prd,prd	:save time
       ei	:sr.gmt
	LH	CHN,SOBP,PRD,		:GET NEXT ENTRY FROM SOBP RING
	JLFS	spib26			:APPLY BACKPRESSURE
	IF	DB.DEB
	CLHI	CHN,NSP			:INSURE VALID CHANNEL NUMBER
	JLFS	spib24			:O.K.
	DBOOPS				:SUP PASSED US INVALID CHANNEL NUMBER
	EI	:DB.DEB
spib24	SBT	CHN,SUPBPV,,		:RELEASE BACKPRESSURE FOR THIS CHANNEL
	JFS	spib30
spib26	NHI	CHN,7FFF		:STRIP HI-ORDER BIT
	IF	DB.DEB
	CLHI	CHN,NSP			:INSURE VALID CHANNEL NUMBER
	JLFS	spib28			:O.K.
	DBOOPS				:SUP PASSED US INVALID CHANNEL NUMBER
	EI	:DB.DEB
spib28	RBT	CHN,SUPBPV,,		:APPLY BACKPRESSURE FOR THIS CHANNEL
	RBT	CHN,SUPSVD,,		:absolutely prevent service
spib30	AIS	PRD,2
	JLFS	spib35
	SHI	PRD,SOBPSZ		:NEGATIVE RING WRAP
spib35	STH	PRD,NOSOBP,,		:UPDATE SOBP TRAIL POINTER
	J	spib20			:LOOK FOR MORE SOBP WORK

::*********************************************************************
::
::	SUBROUTINE:	SUPCIN:
::	FUNCTION:	TEST OF SUPER STATUS (called each 8 seconds)
::	CALLING SEQ:	JAL	R10,SUPCIN
::	CALLS:		JAL	R9,SOCROM
::			JAL	R10,SCQZAP
::			JAL	R9,SICROM
::
::*********************************************************************

:	SUPERVISOR SENDS STATUS THRU SOC CONTROL RING. HALFWORD ENTRIES
: 	ARE -1 FOR SUP SLEEPING, 1 FOR SUP AWAKE. IF NO NEW ENTRIES IN RING
: 	EACH 8 SECONDS, CONSIDER SUP FROZEN (OR SICK).


SUPCIN	ST	R10,XHSVRT		:SAVE RETURN ADDRESS
       if	split
	jal	r9,sirstt		:check sio ring status
	 j	xhret			:dead so avoid routine
       ei	:split
	JAL	R9,SOCROM		:ANY DATA IN SOC CONTROL RING?
	LR	PRC,PRC
	JLE	SUPC40			:NO DATA, SUP NOT UPDATING SOC RING

	LHL	R0,SUPSTO		:Got data.  Had SUP stop talking 
	JEFS	SUPC05			: the last time we checked?
	LIS	R0,0			: yep, send this message
	STH	R0,SUPSTO
	JAL	R8,CRYPTO,,		: SUP'S COMMUNICATING AGAIN msg
	 HC	CRYE3E

SUPC05	LH	R0,SOC,PRD,		:GET ENTRY FROM RING
	JLFS	SUPC20			:SLEEPING SUP
	IF	DB.DEB
	SIS	R0,1
	JEFS	SUPC10			:ENTRY = 1, SUP AWAKE
	DBOOPS				:INVALID CONTROL RING ENTRY FROM SUP
	EI	:DB.DEB
SUPC10	LIS	R0,5			:STATUS FOR AWAKE SUP...
	JFS	SUPC30
SUPC20	IF	DB.DEB
	AIS	R0,1			:INSURE VALID CONTROL RING ENTRY
	JEFS	SUPC22			:O.K.
	DBOOPS				:INVALID CONTROL RING ENTRY FROM SUP
	EI	:DB.DEB
SUPC22	LIS	R0,4			:STATUS FOR SLEEPING SUP...
SUPC30	STH	R0,TVRSTT		:SAVE SUP STATUS
	AIS	PRD,2
	JLFS	SUPC32
	SHI	PRD,SOCSZ		:NEGATIVE RING WRAP
SUPC32	STH	PRD,NOSOC,,		:UPDATE SOC TRAIL POINTER
	JAL	R9,SOCROM		:ANY MORE ENTRIES IN SOC RING?
	LR	PRC,PRC
	JLE	SUPC50			:NO - GO UPDATE SIC CONTROL RING
	J	SUPC05			:YES - EMPTY SIC RING

:	SUP DEAD (no msg from sup)
SUPC40	LIS	R0,3			:NO ENTRIES FROM SUP
	CLH	R0,TVRSTT		:WAS IT ALREADY FROZEN?
	JEFS	SUPC42			:YES
	sth	r0,supsto		:remember it had
	jal	r8,crypto,,		:saving r0 = 3 into crypto msg
	 hc	crye3d
	STH	R0,TVRSTT		:NO - SAVE SUP STATUS AND
	JAL	R10,SCQZAP		: ZAP ALL COMMAND CIRCUITS
SUPC42

:	PUT NODE NUMBER, ABSOLUTE CHANNEL NUMBER OF INTERFACE IN SIC RING
SUPC50	JAL	R9,SICROM		:ANY ROOM IN SIC?
	CLHI	PRC,4
	JLE	XHRET			:NO
	LHI	R0,SUPZFL		:SUP CHANNEL 0 ABSOLUTE CHANNEL NUMBER
	STH	R0,SIC,PRD,
	AIS	PRD,2
	JLFS	SUPC60
	SHI	PRD,SICSZ		:NEGATIVE RING WRAP
SUPC60	LHI	R0,MACHNM+8000		:NODE NUMBER + 8000
	STH	R0,SIC,PRD,
	AIS	PRD,2
	JLFS	SUPC70
	SHI	PRD,SICSZ		:NEGATIVE RING WRAP
SUPC70	STH	PRD,NISIC,,		:UPDATE SIC LEAD POINTER
	J	XHRET			:DONE

::*********************************************************************
::
::	SUBROUTINE:	SCQZAP:
::	FUNCTION:	ZAP ALL COMMAND CIRCUITS from sup towards net
::	CALLING SEQ:	JAL	R10,SCQZAP
::	CALLS:		JAL	R9,ZAPX
::			JAL	R8,CRYPTO
::
::*********************************************************************

SCQZAP	L	R0,FASTC,,		:SAVE FASTC
	ST	R0,FASSAV
	LHI	R6,NSP-1		:ZAP ALL CIRCUITS...
SCQZA1	LHL	R2,SIOTAB,R6,R6
	NHI	R2,-4
	JEFS	SCQZA2
	JAL	R9,ZAPHRD,,		:SEND A ZAPPER OUT
	RBT	R6,SUPBPX,,
SCQZA2	SIS	R6,1
	JGEBS	SCQZA1

	LIS	R0,0
	JAL	R8,CRYPTO,,		:SUP STOP
	HC	CRYE06
	JR	R10

	EI	:SUPER

	EI	:(1-T2GATE)		:Gateway doesn't use XHOSTS
	ENDMO.(XHOSTS)
	EI	:1-KILLIT
	KILMSG(XHOSTS)
:	***NOTHING PAST THIS POINT***

	SUBTTL  YAKYAK

:		*   *   *   *   * *   *   *   *   *
:		 * *   * *  *  *   * *   * *  *  *
:		  *   ***** ***     *   ***** ***
:		  *   *   * *  *    *   *   * *  *
:		  *   *   * *   *   *   *   * *   *

::#####################################################################
::
::	MODULE:	   Y A K   Y A K
::
::	FUNCTION:  Process data destined for or arriving from neighbor nodes
::
::	REGISTER CONVENTIONS:
::		R0,R1		=  Work Registers
::		R2	=  Buffer number * 4  (Buffer Index)
::		R3	=  "In" pointer for buffer (BE)
::		R4	=  Work Register
::		R5	=  Channel Index (2* Channel Number)  (CHN)
::		R6	=  Relative start of 1/2 wd tables for this link 
::			   (IOTAB  Pointer)
::		R7	=  Relative start of bit arrays for this link
::			   (FLAGS Pointer)
::		R8,R9	=  Link and Work registers
::		R10	=  Physical Record Byte Count (PRC)
::		R11	=  Link Number (KN)
::		R12	=  Index into Physical Record (PRD)
::		R13	=  Record Descriptor Address (CD), also working LRC
::		R14	=  Logical Record Byte count (LRC)
::		R15	=  Link Descriptor address (KD)
::
::	SUBPROCESSES:	RTEAR  RMAKE
::	SUBROUTINES:	RTD RMK  ILC  BPMX
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

	SEG	a.code

	SUBTTL	YAKYAK (BPMX - Send backpressure)

::*********************************************************************
::
::	SUBPROCESS:	BPMX
::	LOGICALLY PART OF BPM, THIS ROUTINE IS ENTERED FROM THE
::	HALF-SECOND LOGIC AND UPDATES THE BACKPRESSURE BITS ON ALL EXISTING
::	LINKS.
::
::*********************************************************************

BPMX	ST	R10,BPMXSR		:SAVE RETURN (IN CASE WE YIELD)
	LHI	R2,LKSIZE-4
BPMX2	L	R3,ALINKS,R2		:COPY ALINKS TO BPMTII 
	ST	R3,BPMTII,R2		:tell RMK time for packet of BP relief
	SIS	R2,4
	JGEBS	BPMX2

	LHI	R4,NKU-1		:UPDATE KERNEL BPS BITS
BPMXK1	LHL	R2,KIOTAB,R4,R4		:BUFF #
	LIS	R1,3			:LOAD BP INDEX
	NR	R1,R2
	NHI	R2,-4
	JEFS	BPMXK2			:NO CIRCUIT, OK TO RELIEVE BP
	LHL	R3,BCT,R2,		:SET BIT IF CNT<BP CONSTANT
	CLH	R3,CIRSPB,R1,R1
	JGFS	BPMXGT
BPMXK2	SBT	R4,KERBPX
BPMXGT	SIS	R4,1
	JGE	BPMXK1

	L	R10,BPMXSR
	JR	R10			:ALL DONE, RETURN TO G500MS

	SUBTTL	YAKYAK (ABPMX - Do metering on active BP circuits)

::*********************************************************************
::
::	SUBROUTINE:	ABPMX
::	FUNCTION:	As active Backpressure must periodically restore
::	xmit authority (as it supports tclass transmit limits).  so on
::	those circuits that sent data (XGUSH) and are not backpressured
::	(ABPVCP) then put tclass in BPSCNT and set LNKBPV.
::
::	CALLING SEQ:	JAL  R10,ABPMX  (called from 1/2 sec logic)
::	INPUT:		none
::	RETURNS:	JR   R10
::
::*********************************************************************

       if	aplybp
abpmx	li	chn,tchans-1		:scan all bits in last hw
abpmx0	ohi	chn,0f			:last bit searched	
	lr	r2,chn
	srls	r2,3			:convert bits to bytes
	la      r3,abpvcp-1,r2,         :address of last hw (r2 is odd)
	la	r4,xgush-1,r2,
	arand	r3,r5			:find match
	jfs	abpmx1			:got one
	jr	r10			:and done
:	got a chn, note CHN is link chn and not absolute
abpmx1	rbt	chn,xgush,,		:chn serviced
	lis	r1,3			:get tclass bits
	nh	r1,niotab,chn,chn
	lhl	r1,cirspk,r1,r1		:get tclass value
	tbt	chn,prirty+lnkzfl/8,,	:if pririty give it 4* val
	jefs	abpmx2
	slls	r1,2			:mult by 4
abpmx2	sth	r1,bpscnt,chn,chn	:save transmit limit
	sbt	chn,lnkbpv,,		:and set bit indicate room to send
	j	abpmx0			:and do next chn
       ei	:aplybp

	SUBTTL	YAKYAK (NEWLNK)

::*********************************************************************
::
::	SUBROUTINE:	NEWLNK
::	FUNCTION:	Determine if we are master or slave for new link.
::	If we are master, adjust LKAPND, LKCSND for channel scan to point to
::	link area in negative ACP, CHS arrays. That causes the FNDKNC routine
::	to find a new channel starting from the highest and working down.
::
::	CALLING SEQ:	JAL  R10,NEWLNK  (called from  ATTLN6 (LINKER))
::	INPUT:		KD
::	CALLS:		JAL  R8,BUBBLE,,
::			JAL  R8,HCLEAR,,
::			JAL  R9,CRQFCR,,
::			JAL  R8,CRYPTO,,
::			JAL  R10,SUP12,,
::	RETURNS:	JR   R10
::
::*********************************************************************

NEWLNK	ST	R10,NEWLNR		:SAVE RETURN
	LB	KN,LKNM,KD		:GET LINK NUMBER
	sbt	kn,borzap		:remove any pending outage
	TS	PASTHC			:maybe no longer deadended
	LIS	R0,1
	STB	R0,MASTKN,KN,		:ASSUME WE ARE THE MASTER
	LHL	R0,NDID,KD
	CLHI	R0,MACHNM		:HIGHER MACHINE # IS MASTER FOR T-II
	JL	NLMS10			:OURS IS HIGHER
	LIS	R0,0			:NEIGHBOR'S NUMBER IS HIGHER - SET
	STB	R0,MASTKN,KN,		:MASTKN TO 0, INDICATE WE ARE THE SLAVE
:	IF THIS LINK USED TO BE UP WITH US AS MASTER, THEN WE MUST REVERSE THE
:	POLARITY OF LKAPND, LKCSND.
	LHI	R0,ACP
	SH	R0,LKAPND,KN,KN		:SEE IF POINTER IN POSITIVE ACP
	JL	NLMS20			:YES - NO ADJUSTMENT NECESSARY
	SLLS	R0,1			:ADD (DISTANCE*2) TO CURRENT NEGATIVE
	SIS	R0,4			: POINTER, MINUS 4 TO GET PROPER
	AHM	R0,LKAPND,KN,KN		: POSITIVE ACP, CHS POINTERS
	AHM	R0,LKCSND,KN,KN
	J	NLMS20
NLMS10	LHL	R0,LKAPND,KN,KN
	SHI	R0,ACP			:DETERMINE DISTANCE FROM ACP
	JLFS	NLMS20			:POINTER ALREADY WEST OF ACP
	SLLS	R0,1			:DIFFERENCE TIMES 2
	LCS	R1,4			: MINUS 4
	SR	R1,R0			:REVERSE POLARITY AND
	AHM	R1,LKAPND,KN,KN		: ADJUST
	AHM	R1,LKCSND,KN,KN

NLMS20	JAL	R8,BUBBLE,,		:GET NEW HALF-PAGE OF PERMUTER TABLE
	SKIPAD(NEWLN7)			:COULDN'T ALLOCATE P.T., TAKE LINK DOWN
NEWLN0	LIS	R0,0			:+4 RETURN, CLEAR PAGE #
	STH	R0,RTPAGE,KN,KN
	STH	R0,RMPAGE,KN,KN
	STH	R0,LKSTCT,KN,KN		:CLEAR LINK SATURATED COUNTER
	STH	R0,LKOVLD,KN,KN		:CLEAR OVERLOAD COUNTER
	STH	R0,SNPTYP,KN,KN		:CLEAR LINK SNIP TYPE FIELD
					: (0 IF NO LINK SNIP)
	STH	R0,SHSTAT,KD		:CLEAR SHRINK STATE (SHSTAT, NEDSUS)
	STH	R0,NEDOUT,KD		:CLEAR NUMBER OF NEEDLES OUTSTANDING
	sth	r0,suschn,kd		:bubble due had 0 suspended chns
	LHI	R2,KSSZ^-1		:HW SIZE OF LINK STATISTICS AREA###OAS
	LA	R1,KS.PCO,KD		:START ZEROING AT KS.PCO OF KD	###OAS
	JAL	R8,HCLEAR,,		:CLEAR LINK STATISTICS		###OAS
	LHI	R0,0C000		:SET BP FLAGS FOR CHN 0 & CHN 1
	LHL	R6,FLDPKN,KN,KN		:START OF ARRAYS FOR THIS LINK
	STH	R0,LNKBPV,R6,
	STH	R0,BPSVCP,R6,

NEWLN1	LR	R2,KN			:COMPUTE # OF CORRESPONDING ILC BUFF
	SLLS	R2,3			:IT'S ILCZBF+8*KN
	LHI	R2,ILCZBF,2
	LIS	R3,3			:BUILD CIRCUIT TO ILC - R3=SPEED
	LHI	CHN,ILCZFL,KN		:R4, CHN ARE ABSOLUTE PORT #'S
	LHL	R4,LKZFKN,KN,KN
	JAL	R9,CRQFCR,,		:BUILD CIRC
	AIS	R4,1			:YES, INCREMENT TO CHAN 1 OF THIS LINK
	RBT	R4,ACP,,		:PREVENT CHANNEL FROM BEING USED DUE
:	TO SPECIAL LOGIC IN RMAKE, RTD FOR CHANNELS 0 & 1.
	LCS	R0,1
	SR	R0,R4			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		: FLAG THAT ALSO
NEWLN4	SBT	KN,ALINKS		:LINK NOW ACTIVE
	LHL	R0,NALINK		:UPDATE ACTIVE LINK COUNT
	AIS	R0,1
	CLH	R0,MXLINK		:A NEW HIGH FOR # OF ACTIVE LINKS?
	JLEFS	NEWMXL			:NO
	STH	R0,MXLINK		:YES, STORE NEW PEAK VALUE
NEWMXL	STH	R0,NALINK		:STORE NUMBER OF ACTIVE LINKS
	LIS	R0,2
	STH	R0,ANCHN,KD		:CHANNELS 0 & 1 IN USE, MARK AS ACTIVE

	LR	R0,KN
	EXHR	R0,R0			:LINK # TO UPPER HW
	OH	R0,NDID,KD		: NEIGHBOR NUMBER IN LOWER HALF
	ST	R0,CRYSBF
	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT TO XRAY
	HC	CRYE01
	L	R10,NEWLNR		:ALL DONE
	JR	R10

:	NO PERMUTER TABLES FOR NEW LINK
NEWLN7	LR	R0,KN
	EXHR	R0,R0			:LINK NUMBER IN UPPER HALF,
	OH	R0,NDID,KD		: NEIGHBOR NUMBER IN LOWER HALF
	ST	R0,CRYSBF
	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT TO XRAY
	HC	CRYE03

:	REPORT 'NO PERMUTER TABLES' TO SUPERVISOR LOG
NEWLN8	LR	R0,LN			:##TZ
	SRLS	R0,1
	OHI	R0,8080
	STH	R0,SUPMBF+4		:REPORT INCLUDES 'ESCAPED' LINE NUMBER
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	LIS	R0,NR.NPT
	STH	R0,SUPMBF		:INDICATE TYPE OF NODE REPORT
	JAL	R10,SUP12,,		:REPORT NO P.T. TO SUP LOG
:	FORCE LINK TO GO OUT SINCE NO CIRCUITS CAN BE BUILT
:	borzap inverted by sdw
	rBT	KN,BORZAP		:TAKE LINK OUT
	L	R10,NEWLNR		:GET RETURN ADDRESS		##TZ
	JR	R10			:AND RETURN			##TZ

	SUBTTL	YAKYAK (TRLINK)

::*********************************************************************
::
::	SUBROUTINE:	TRLINK:
::	FUNCTION:	Link tear down logic.  Link neighbor number and
::	machine number are placed in Fat Zapper message.  Buffers are 
::	cleared and replaced with a Fat Zapper for each circuit on the link.
::	The type of circuit is counted.  If a Link Snip has occurred, the 
::	reason is recorded and diagnostics are sent.  Link Permuter Table
::	space is returned to the Permuter Table Free Pool.
::
::	CALLING SEQ:	JAL  R10,TRLINK  (from DETLIN (LINKER))
::					&(from LEPRKD (LEP0F))
::	INPUT:		KD
::	CALLS:		JAL  R8,CBCLR
::			JAL  R10,TRCR02
::			JAL  R9,W2CI
::			JAL  R10,SUP12
::			JAL  R8,CRYPTO
::	RETURNS:	JR  R10
::
::*********************************************************************
TRLINK	ST	R10,NEWLNR		:SAVE RETURN
	LB	KN,LKNM,KD		:GET LINK NUMBER
:	borzap inverted by sdw
	sBT	KN,BORZAP		:let link come back up later
	rbt	kn,noshrk		:default shrinks enabled
       if	aplybp
	rbt	kn,XACTBP		:default to normal bp relief logic
	rbt	kn,VACTBP		:default to normal bp relief logic
       ei	:aplybp
	TBT	KN,ALINKS		:TEST FOR ACTIVE LINK 		###GT
	JEFS	TRLIN0			:IF LINK NOT ACTIVE, DON'T UPDATE COUNT
	LCS	R0,1			:UPDATE LINK COUNT
	AHM	R0,NALINK
TRLIN0	LIS	R0,0
	STH	R0,ZAPCNT		:INIT COUNT OF CIRCUITS ZAPPED DUE TO
	STH	R0,CMDZCT		: LINK OUT AND COMMAND CIRCUITS ZAPPED
	LHL	R6,TBDPKN,KN,KN
	LHL	R7,FLDPKN,KN,KN		:BEGINNING OF LINK'S BIT ARRAYS
	LHL	CHN,NCHN,KD		:NUMBER OF CHANNELS ALLOCATED TO LINK
	AR	CHN,CHN			: * 2...


	LHL	R0,NDID,KD
	EXHR	R0,R0
	OHI	R0,MACHNM		:NODE PAIR CAUSING CRQ'S TO BE ZAPPED
	ST	R0,RFAT			:(PASSED WITH FAT ZAPPERS)
TRLIN1	LHL	R2,NIOTAB-2,R6,CHN 	:GET CIRCUIT'S BUFFER INDEX
	NHI	R2,-4
	JE	TRLIN3			:NO CIRCUIT THIS CHANN
	CLHI	R2,CIRZBF		:IF AN INTERNODE CIRCUIT...
	JGEFS	TRLIN2			:JUST CLEAR IT
	JAL	R8,CBCLR,,
	XHI	R2,4
	JAL	R8,CBCLR,,
	LIS	R0,0
	STH	R0,NIOTAB-2,R6,CHN
	J	TRLIN3

TRLIN2	LHI	R1,ZAPPF
       if	t2gate			:internal accounting is done in inthst
	lis	r0,aalr03
	sth	r0,aareas
       ei	:
	JAL	R10,TRCR02,,		:INITIATE FAT ZAPPER
					: UNLESS WE'RE TERMINATION
       if	t2gate
	lis	r0,0
	sth	r0,aareas
       ei 
	LH	R0,TRCSV2		:FAT ZAPPER?
	JLFS	TRLINF			:NO
	LH	R0,BF,R2,		:BUFFER RETURNED?
	JLFS	TRLINF			:YES - CAN'T WRITE INTO IT...
	LHL	R1,RFAT
	JAL	R9,W2CI,,		:PASS OFFENDING NODE PAIR
					: BEHIND FAT ZAPPER
	LHL	R1,RFAT+2
	JAL	R9,W2CI,,

TRLINF	LIS	R0,1
	AHM	R0,ZAPCNT		:ANOTHER CIRCUIT ZAPPED
	LR	R1,CHN
	SIS	R1,2
	SRLS	R1,1			:RELATIVE CHANNEL THIS LINK
	TBT	R1,CMDCTS,R7,		:IS THIS A COMMAND CIRCUIT?
	JEFS	TRLIN3			:NO
	AHM	R0,CMDZCT		:YES - COUNT IT FOR REPORT
TRLIN3	SIS	CHN,2			:DECREMENT TO NEXT CHANNEL
	JG	TRLIN1

:	DONE ZAPPING LINK'S CIRCUITS...NOW DO LINK-OUT BOOKKEEPING
	LHL	R0,SNPTYP,KN,KN		:WAS THIS LINK BORI-ZAPPED?
	JE	TRLIN4			:NO
	STH	R0,SUPMBF+4		:YES - SAVE REASON FOR REPORT
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER,
	OI	R0,(NR.SNP^10)+8000	: COMBINE WITH REPORT TYPE
	ST	R0,SUPMBF
	JAL	R10,SUP12,,		:SEND LINK SNIP NODE REPORT AND CRYPTO
	LIS	R0,1
	AHM	R0,LSNIPS		:COUNT LINK SNIPS

TRLIN4	LR	R0,KN
	EXHR	R0,R0			:GET LINK NUMBER IN HI-ORDER HW
	OH	R0,NDID,KD		: AND COMBINE WITH NEIGHBOR NUMBER
	ST	R0,CRYSBF
	JAL	R8,CRYPTO,,
	HC	CRYE02			:REPORT LINK OUT TO XRAY
	LHL	R10,ZAPCNT		:DID WE ZAP ANY USER CIRCUITS?
	JE	TRLINZ			:NO - DON'T MAKE TRIVIAL REPORT TO LOG
	OHI	R10,8000
	STH	R10,SUPMBF+4
	OHI	R0,8000
	STH	R0,SUPMBF+2		:REPORT NEIGHBOR # FOR ZAPPED CIRCUITS
	STH	KN,SUPMBF+6		:SAVE LINK NUMBER FOR CRYPTOGRAM
	LIS	R0,NR.PLI
	STH	R0,SUPMBF		:SIMILAR TO TYMNET-I NPLI PROBE REPORT
	JAL	R10,SUP12,,		:MAKE NODE REPORT TO SUP LOG
	LHL	R0,CMDZCT		:COUNT OF COMMAND CIRCUITS ZAPPED
	JEFS	TRLINZ			:NONE
	OHI	R0,8000
	STH	R0,SUPMBF+4
	LHI	R0,NR.CCZ		:COMMAND CIRCUIT ZAP COUNT NODE REPORT
	STH	R0,SUPMBF
	JAL	R10,SUP12,,
TRLINZ
	LH	R0,ONDID,KD		:ONDID IS ZERO IF THIS IS AN XLINK,
	STH	R0,NDID,KD		: US TO RELEASE XLINK LINK DESCRIPTOR
TRLNZ1
:	GIVE UP PERMUTER TABLE SPACE. PERMUTER TABLE SPACE IS ALLOCATED
:	IN HALF-PAGES. T-I AND T-1.5 LINKS MAY HAVE ADJUSTED NCHN DOWN DUE
:	TO RECEIPT OF BACKPRESSURE RECORD FROM NEIGHBOR (SEE BPMV).
:	DETERMINE THE NUMBER OF HALF-PAGES ALLOCATED FOR T-I OR T-1.5 LINK,
:	SO THAT THE SAME NUMBER MAY BE FREED UP.

	LHL	R10,NCHN,KD
	JEFS	TRLIN5			:# OF CHANNELS NOT YET DETERMINED
	THI	R10,7F			:NUMBER CHANNELS MULTIPLE OF 80?
	JEFS	TRLIN7			:YES
TRLIN5	TBT	KN,ALINKS		:IS LINK ACTIVE, IF NCHN = 0?	###GT
	JEFS	TRLIN7			:IF NCHN=0 & LINK NOT ACTIVE, THERE ARE
					:NO HALF-PAGES TO FREE UP 	###GT
::	LHL	R10,NCHKN,KN,KN		:NO - DETERMINE NUMBER OF HALF-PAGES
					:This T-I stuff not used 	###ev
	CLHI	R10,80			:	ALLOCATED BY NEWLNK
	JGFS	TRLIN6			:2 HALF-PAGES ALLOCATED IF NCHKN > 80
	LHI	R10,80			:1 HALF-PAGE ALLOCATED - SET # CHANS=80
	JFS	TRLIN7
TRLIN6	LHI	R10,100			:SET # CHANS TO 100 SINCE 2 HALF-PAGES
					:ALLOCATED TO LINK WITH >8 GROUPS
TRLIN7	LIS	R0,0
	SR	R0,R10			:GET NEGATIVE NUMBER OF CHANNELS IN R0
	LR	R3,R0
	SRA	R3,3			:# OF CHANS/8 = BYTE DISPLACEMENT FOR
					:LINK BIT ARRAYS
	AR	R0,R0			:FOR HALFWORD POINTER FIELD
	AHM	R0,EBDPKN,KN,KN		:DECREMENT END OF PERMUTER TBLE POINTER
	LB	R0,MASTKN,KN,		:ARE WE MASTER ON THIS LINK?
	JNFS	TRLIN8			:YES, END PTR STAYS THE SAME
					: FOR NEG. ACP, CHS
	AHM	R3,LKAPND,KN,KN		:DECREMENT ACP END AND
	AHM	R3,LKCSND,KN,KN		: CHS END
TRLIN8	LR	R0,R10			:NUMBER OF CHANNELS DIVIDED BY 128
	SRLS	R0,7			: YIELDS # OF HALF PAGES BEING RETURNED
	AHM	R0,NUMPAG		: TO PERMUTER TABLE FREE POOL
	LIS	R0,0
	STH	R0,NCHN,KD		:NO CHANNELS FOR OUT LINK
	RBT	KN,ALINKS		:NOW WE CAN DECLARE LINK OUT	###GT
:	here to restore windowsize.  Could be reduced from original by
:	matchdown or xray WZ cmd.  XRAY WZ cmd size could be reduced
:	further by a matchdown.					###sdw
	LHL	R1,WSZKN,KN,KN		:get original window size
	CLB	R1,WSIZ,KD		:is current okay?
	JE	TRLINW			:yes, nothing to do
	STB	R1,WSIZ,KD		:is link's window size
	JAL	R9,MCHDWN		:specified may be less than original
TRLINW
	 				:and restore if matchdown occurred
	L	R10,NEWLNR
	JR	R10


	SUBTTL	YAKYAK (SHRINK - Link shrink logic)

::*********************************************************************
::
::	SUBROUTINE:	SHRINK
::	FUNCTION:	Gives up half-page of permuter table space.  
::	Starting from highest channel on link, move permuter table entry
::	to lowest available channel.  Adjust necessary pointers, and 
::	report to Xray and Supervisor logs.
::	CALLING SEQ:	J SHRINK  (called from RTDP4A  shrink cmd or req)
::	INPUT:		KD,KN
::	PRESERVED:	R10
::	DESTROYED:	R-0,1,2,3,4,5,14,15.
::	CALLS:		JAL  R10,SUP12L
::	RETURNS:	J RTDXIT
::
::*********************************************************************

shrk00	stm	r0,shrksv		:save regs
	j	shrk04

SHRINK	stm	r0,shrksv		:save all regs
	LH	R0,NDID,KD		:TEST FOR WHETHER WE'RE MASTER
	CLHI	R0,MACHNM		: OR SLAVE ON THIS LINK
	JLfs	shrk01			:MASTER
	LIS	R0,1			:WE'RE THE SLAVE...
	STB	R0,SHSTAT,KD		:TELL RMAKE TO ACKNOWLEDGE SHRINK
	Jfs	shrk04			: AND GO DO IT
shrk01	LB	R0,SHSTAT,KD		:WE'RE THE MASTER...
	JN	4,r8			:IGNORE IF SOMETHING IN PROGRESS
	LIS	R0,2			:TELL RMAKE
	STB	R0,SHSTAT,KD		: TO SEND SHRINK COMMAND TO NEIGHBOR
	J	4,r8			:NOTHING MORE IN THIS PACKET
shrk04	LHL	R0,NCHN,KD		:GET # OF CHANNELS ALLOCATED THIS LINK
	CLHI	R0,80			:DO WE HAVE MORE THAN 1 HALF-PAGE?
	jler	r8			:bad error, snip link
SHRK0	LHL	R1,TBDPKN,KN,KN		:R1 ==> BOTTOM OF LINK'S TABLE SPACE
	AIS	R1,2			:SKIP CHANNELS 0 AND 1
	LHL	R3,EBDPKN,KN,KN		:END OF IOTAB FOR THIS LINK
	J	SHRK2
SHRK1	THI	R3,0FF			:HALF PAGE BOUNDARY?
	JN	SHRK2			:NO - CONTINUE
	STH	R3,EBDPKN,KN,KN		:YES - DONE WITH SHRINK
	LHI	R0,-80
	AHM	R0,NCHN,KD		:DECREMENT # OF AVAILABLE CHANS ON LINK
	LHI	R0,-10			:# OF BYTES IN BIT ARRAY FOR 1/2 PAGE
	LB	R3,MASTKN,KN,		:ARE WE MASTER ON THIS LINK?
	JNFS	SHRK1A			:YES,NO NEED TO ADJUST ACP,CHS POINTERS
	AHM	R0,LKAPND,KN,KN
	AHM	R0,LKCSND,KN,KN
SHRK1A	LIS	R0,1
	AHM	R0,NUMPAG		:INCREMENT NUMBER OF PAGES AVAILABLE
	LIS	R0,NR.SHK		:INDICATE TYPE OF REPORT
	JAL	R10,SUP12L,,		:MAKE LINK SHRINK REPORT TO SUP LOG

:	When a link has lots of suspended chns then it bubbles
:	since no chns are free and not suspended, and then it will shrink
:	immediately since the link only has a few active chns.  This can
:	continue to happen until the suspension ends (60seconds).  
:	Solution:  Since the chn is suspended to prevent the classic outgoing
:	zap, outgoing needle and incoming zap which would then clear the
:	needle when the other end was clearing the same circuit we zapped
:	but the shrink logic suspends the link so we know that this timing
:	problem cannot happen, so the shrink logic might as well take advantage
:	and clear the suspended arrays for that link.
	lhl	r4,lkzfkn,kn,kn 	:chn 0
	lhl	r5,nchn,kd		:last chn
	srls	r4,3			:byte offset
	srls	r5,3			:byte count
	lr	r0,r4
	lis	r3,0			:for negative chs
	sr	r3,r0			:have high end of neg
	sr	r3,r5			:have lower end of neg
	lis	r0,0			:for clearing CHS1, CHS2
	lcs	r1,1			:for clearing CHS
shrk19	st	r1,chs-4,r4,r5
	st	r1,chs,r3,r5
	st	r0,chs1-4,r4,r5
	st	r0,chs2-4,r4,r5
	st	r0,chs1,r3,r5
	st	r0,chs2,r3,r5		:all of them, pos and neg
	sis	r5,4
	jg	shrk19			:clear for all words
	lm	r0,shrksv		:restore all regs
	j	4,r8			:successful return

SHRK2	SIS	R3,2			:DECREMENT TO NEXT CHANNEL
	LHL	R2,NIOTAB,R3,		:GET NEXT CHANNEL
	JE	SHRK1			:NULL ENTRY, NO MAPPING REQUIRED
SHRK3	AIS	R1,2			:WORKING FROM BOTTOM UP,
					: LOOK FOR NEW HOLE TO FILL
	LH	R0,NIOTAB,R1,
	JNBS	SHRK3			:ENTRY IN USE

:	FOUND AVAILABLE IOTAB ENTRY. MOVE BUFFER NUMBER AND SPEED BITS
:	TO NEW ENTRY, AND ADJUST BPSCNT, BF, AND ALL ATTENDANT BIT ARRAYS
:	FOR THIS CHANNEL.

	STH	R2,NIOTAB,R1,		:MOVE ENTRY FROM RETIRING HALF PAGE
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:CLEAN UP BEHIND OURSELVES
	LH	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R1,
	NHI	R2,-4			:ISOLATE BUFFER NUMBER
	XHI	R2,4			:GET BUFFER INDEX
	LH	R0,BF,R2,		: WHICH POINTS TO THIS IOTAB ENTRY
	JEFS	SHRK4			:DO NOT CHANGE IF 0
	LR	R4,R3			:COMPUTE GAP BETWEEN RETIRING IOTAB
	SR	R4,R1			: ENTRY AND NEW ENTRY
	SRLS	R4,1
	SR	R0,R4			:ADJUST BF BY CHANNEL DISPLACEMENT
	STH	R0,BF,R2,
	
:	THE FOLLOWING CODE RESETS THE BIT IN THE OLD POSITION, AND
:	SETS OR RESETS THE NEW CHANNEL BIT ARRAY AS NEEDED.

SHRK4	LR	R4,R1
	SRLS	R4,1			:NEW CHANNEL NUMBER
	LR	R5,R3
	SRLS	R5,1			:OLD CHANNEL NUMBER
	RBT	R5,GUSH,,			:RESET OLD GUSH
	jefs	shrk42
	sbt	r4,gush,,
SHRK42	RBT	R5,LNKFLG,,
	JEFS	SHRK43
	SBT	R4,LNKFLG,,
	JFS	SHRK44
SHRK43	RBT	R4,LNKFLG,,

SHRK44
	RBT	R5,LNKBPV,,
	JEFS	SHRK45
	SBT	R4,LNKBPV,,
	JFS	SHRK46
SHRK45	RBT	R4,LNKBPV,,

SHRK46	RBT	R5,CHSRVD,,
	JEFS	SHRK47
	SBT	R4,CHSRVD,,
	JFS	SHRK48
SHRK47	RBT	R4,CHSRVD,,

SHRK48	RBT	R5,BPSVCP,,
	JEFS	SHRK49
	SBT	R4,BPSVCP,,
	JFS	SHRK50
SHRK49	RBT	R4,BPSVCP,,

SHRK50	RBT	R5,PRIRTY+lnkzfl/8,,
	JEFS	SHRK51
	SBT	R4,PRIRTY+lnkzfl/8,,
	JFS	SHRK52
SHRK51	RBT	R4,PRIRTY+lnkzfl/8,,

SHRK52	RBT	R5,CMDCTS,,
	JEFS	SHRK53
	SBT	R4,CMDCTS,,
	JFS	SHRK54
SHRK53	RBT	R4,CMDCTS,,

SHRK54	RBT	R5,NEEDLE,,		:I THINK THIS FIXES A BUG	###TZ
	JEFS	SHRK55
	SBT	R4,NEEDLE,,
	JFS	SHRK56
SHRK55	RBT	R4,NEEDLE,,

SHRK56	SBT	R5,LNKACP,,
	JEFS	SHRK57
	SBT	R4,LNKACP,,
	JFS	SHRK58
SHRK57	RBT	R4,LNKACP,,

SHRK58	SBT	R5,LNKCHS,,
	JEFS	SHRK59
	SBT	R4,LNKCHS,,
	JFS	SHRK60
SHRK59	RBT	R4,LNKCHS,,

SHRK60
       if	aplybp
	RBT	R5,ABPXCP,,		:receiving is not backpressured
	JEFS	SHRK61
	SBT	R4,ABPXCP,,
	JFS	SHRK62
SHRK61	RBT	R4,ABPXCP,,

SHRK62	SBT	R5,ABPVCP,,		:sending is not backpressured
	JEFS	SHRK63
	SBT	R4,ABPVCP,,
	JFS	SHRK64
SHRK63	RBT	R4,ABPVCP,,
SHRK64
       ei	:aplybp

:	DETERMINE MAGNITUDE FROM BEGINNING OF ARRAY AND ADJUST ACP, CHS
:	IN NEGATIVE DIRECTION.

SHRK80	STM	R14,LNKRGS		:USE R14, R15 AS WORK REGS
	LCS	R14,1
	SR	R14,R4			:NEGATIVE NEW CHANNEL NUMBER
	LCS	R15,1
	SR	R15,R5			:NEGATIVE OLD CHANNEL NUMBER
	SBT	R15,EKNACP,,
	JEFS	SHRK81
	SBT	R14,EKNACP,,
	JFS	SHRK82
SHRK81	RBT	R14,EKNACP,,

SHRK82	SBT	R15,EKNCHS,,
	JEFS	SHRK83
	SBT	R14,EKNCHS,,
	JFS	SHRK84
SHRK83	RBT	R14,EKNCHS,,

SHRK84	LM	R14,LNKRGS
	J	SHRK1

	SUBTTL  YAKYAK (RMKBP - RMAKE backpressure relief records)


::*********************************************************************
::
::	SUBROUTINE:	RMKBP and RMKBPP
::	FUNCTION:	RMKBP and RMKBPP make the logical records for
::			backpressure relief.  Called directly from rmake
::			and returns directly.  Calls Apply/release BP if
::			that type of link.  
::			rmkbpp is called 8 times a second to give priority
::			circuits extra cps capability.
::
::	CALLING SEQ:	JAL R9,RMKBP   JAL R9,RMKBPP
::	INPUT:		R7 (pointer to link flags), KD, PRC, PRD
::	DESTROYED:	R0,R1,R2,R3,R5
::	CALLS:	
::	RETURNS:	null return means could not fit all bp message in
::			this packet and so it should be rescheduled by the
::			caller.
::			+4 return means everything went okay
::
::*********************************************************************

	if	1-fstdat		:if not enabled then just make an
					:empty bp record to keep window
					:moving
rmkbpp
       if	aplybp
	tbt	kn,XACTBP		:is link sending apply bp?
	jn	4,r9			:yes, exit
       ei	:aplybp
	LHI	R0,0C0			:L.R. HEADER FOR BACKPRESSURE RECORD
	STB	R0,0,PRD		:L.R. COUNT=0 IS O.K., FORCES TRAFFIC
					: ON LIGHTLY LOADED LINK
	AIS	PRD,1
	SIS	PRC,1
	j	4,r9			:and done with empty bp relief
       ei	:1-fstdat

:	if apply backpressure logic is enabled then RMKSBP and RMKABP are
:	called from RMKBP
:	the reseting of BPMTIQ in RMKBP (normal bp relief) is because
:	that both BPMTII and BPMTIQ can be set if we have not been able
:	to make bp msgs for a long enough period of time.  As normal is
:	called before priority and servicing normal removes need to service
:	priority, BPMTIQ is reset.	07/30/93
RMKBP	RBT	KN,BPMTIQ		:cancel possible priority service
       if	aplybp
	tbt	kn,XACTBP		:is link sending apply bp?
	jefs	rmkbp0
rmkbpa	jal	r8,rmksbp		:send any needed release BP msgs
	 jr	r9			:packet is now full
	 nopr	0,0
	lr	r8,r9			:return to caller after doing routine
	j	rmkabp			:send any needed set BP msgs
       ei	:aplybp

rmkbp0	la	r0,gush-2,r7,		:porting needing service

       if	fstdat
	jfs	rmkbp1
rmkbpp
       if	aplybp
	tbt	kn,XACTBP		:is link sending apply bp?
	jnbs	rmkbpa			:yes, do it
       ei	:aplybp
	la	r0,prirty-2+lnkzfl/8,r7, :must be priority and gush
       ei	:fstdat
RMKBP1	LHL	LRC,NCHN,KD		:MAX # OF CHANNELS ON LINK DIVIDED BY 8
	lr	r2,lrc
	sis	r2,1			:how many bits to service
	sth	r2,rmtsr4		:how may chns to service
	sis	r2,0f			:now how many bits to copy
	SRLS	LRC,3			: = # OF BYTES IN LINK ARRAYS (ie GUSH)
	la	r1,scratc-2,r7,lrc	:get dest address
	ar	r0,lrc			:orig address -2
	copy	r0,r2			:move the bits
	LR	R4,PRD			:POINTER TO BACKPRESSURE HEADER
	LHI	R0,0C0			:L.R. HEADER FOR BACKPRESSURE RECORD
	STB	R0,0,PRD		:L.R. COUNT=0 IS O.K., FORCES TRAFFIC
					: ON LIGHTLY LOADED LINK
	AIS	PRD,1
	SIS	PRC,1
RMKB1	LHL	R2,RMTSR4		:last chn serviced for this link
	OHI	R2,0F			:search from this HW
	LR	R1,R2
	SRLS	R1,3			:make into # HWs -1
	LA	R0,gush-1,R1,R7		:data present flags
	LA	R1,scratc-1,R1,R7	:chns not yet serviced or BPed flags
	ARAND	R0,R2			:ARRAYAND RETURNS HIGHEST NONZERO
	jfs	rmkb3			:where to go on a hit
	J	4,r9			:ALL DONE WITH BACKPRESSURE RECORD

RMKB3	rbt	r2,scratc,r7,		:serviced bit
	sth	r2,rmtsr4
	lr	CHN,r2			:CHANNEL NUMBER
	ar	r2,r2			:2 * CHANNEL NUMBER
	LH	R2,NIOTAB,R6,r2		:PERMUTER TABLE ENTRY
	LIS	R1,3
	NR	R1,R2			:ISOLATE SPEED BITS IN R1
	xr	R2,r1			:BUFFER INDEX IN R2
	LHL	R0,BCT,R2,		:GET BUFFER BYTE COUNT
	CLH	R0,CIRSPB,R1,R1		: AND COMPARE TO CHANNEL CIRCUIT SPEED
	JG	RMKB6			:BCT GREATER, DON'T RELIEVE BACKPRESSUR
	RBT	CHN,GUSH,R7,		:O.K. TO RELIEVE BACKPRESSURE
	EXBR	R1,CHN
 	CLB	R1,RMPAGE,KN,KN		:ARE WE CHANGING PAGES?
	JE	RMKB5			:NOPE - STILL ON SAME ONE
	STB	R1,RMPAGE,KN,KN		:YES - SAVE NEW PAGE NUMBER
	OHI	R1,80
	STB	R1,0,PRD		:INSERT PAGE CHANGE COMMAND
	AIS	PRD,1
	SIS	PRC,1
RMKB4	LHI	R1,0C1			:BACKPRESSURE HEADER, LENGTH 1
	STB	R1,0,PRD
	STB	CHN,1,PRD		:CURRENT CHANNEL RELIEVING BACKPRESSURE
	SIS	PRC,2
	LR	R4,PRD			:R4 POINTS TO NEW B.P. RECORD HEADER
	AIS	PRD,2
	Jfs	RMKB6
RMKB5	LB	R0,0,R4			:GET BACKPRESSURE HEADER
	AIS	R0,1			:INCREMENT SIZE FIELD
	THI	R0,20			:IF IS MAX SIZE - TEST FOR OVERFLOW
	JN	RMKB4			:YES, CLOSE OFF RECORD, START NEW ONE
	STB	R0,0,R4			:STORE HEADER BACK WITH UPDATED COUNT
	STB	CHN,0,PRD		:CURRENT CHANNEL RELIVING BACKPRESSURE
	AIS	PRD,1
	SIS	PRC,1
RMKB6	L	R0,RTMT1		:GET WORKING GUSH BACK
	CLHI	PRC,3			:ROOM FOR PAGE CHANGE, HEADER, CHANNEL?
	JGE	RMKB1			:YES - CONTINUE
	Jr	r9			:null return is for rescheduling

::*********************************************************************
::
::	SUBROUTINE:	RMKABP
::	FUNCTION:	Makes the logical records for apply backpressure.
::			It is much like RMKBP.  It checks those ports that
::			have sent NC data since last time we ran (GUSH) and
::			sees if they should have backpressure applied.  If
::			so then it sets ABPXCP to indicate backpressure has
::			been applied.  This should be called AFTER RMKSBP
::			(release backpressure) as it checks all ports with
::			ABPXCP and thus a port backpressured here would then
::			be checked over there.  That would be a waste.  
::	CALLING SEQ:	JAL R8,RMKSBP
::	INPUT:		R7 (pointer to link flags), KD, PRC, PRD
::	DESTROYED:	R0,R1,R2,R3,R5
::	CALLS:	
::	RETURNS:	null return means could not fit all bp message in
::			this packet and so it should be rescheduled by the
::			caller.
::			+4 return means everything went okay
::
::*********************************************************************

       if	aplybp

rmkabp	LHL	LRC,NCHN,KD		:MAX # OF CHANNELS ON LINK DIVIDED BY 8
	lr	r2,lrc
	sis	r2,1			:how many bits to service
	sth	r2,rmtsr4		:how may chns to service

	LHI	R0,0E2			:L.R. HEADER FOR BACKPRESSURE RECORD
	STB	R0,0,PRD		:L.R. COUNT=0 IS O.K., FORCES TRAFFIC
					: ON LIGHTLY LOADED LINK
	AIS	PRD,1
	lis	r0,0
	stb	r0,0,prd		:start with len of 0
	LR	R4,PRD			:POINTER TO BACKPRESSURE LEN field
	ais	prd,1			:point to where to put chn
	SIS	PRC,2			:two bytes of header
rmkab1	LHL	R2,RMTSR4		:last chn serviced for this link
	OHI	R2,0F			:search from this HW
	LR	R1,R2
	SRLS	R1,3			:make into # HWs -1
	LA	R0,gush-1,R1,R7		:data arrived flags
	LR	R1,R0			:looking for data arrived
	ARAND	R0,R2			:ARRAYAND RETURNS HIGHEST NONZERO
	jfs	rmkab3			:where to go on a hit
	ais	r4,1			:see if empty
	cr	prd,r4
	Jn	4,r8			:ALL DONE WITH BACKPRESSURE RECORD
	ais	prc,1			:record will be len 1 instead of 2
	lhi	r1,0c0			:a null normal bp record
	sis	prd,2
	stb	r1,0,prd		:save it into record
	ais	prd,1
	j	4,r8			:and done

rmkab3	rbt	r2,gush,r7,		:have checked this chn
	sth	r2,rmtsr4
	lr	CHN,r2			:CHANNEL NUMBER
	ar	r2,r2			:2 * CHANNEL NUMBER
	LH	R2,NIOTAB,R6,r2		:PERMUTER TABLE ENTRY
	LIS	R1,3
	NR	R1,R2			:ISOLATE SPEED BITS IN R1
	xr	R2,r1			:BUFFER INDEX IN R2
	LHL	R0,BCT,R2,		:GET BUFFER BYTE COUNT
	CLH	R0,CIRSPB,R1,R1		: AND COMPARE TO CHANNEL CIRCUIT SPEED
	JL	rmkab6			:BCT less, DON'T apply BACKPRESSUR
	SBT	CHN,ABPXCP,R7,		:mark bp applied
	jn	rmkab6			:already BPed, so can exit
	EXBR	R1,CHN
 	CLB	R1,RMPAGE,KN,KN		:ARE WE CHANGING PAGES?
	JE	rmkab5			:NOPE - STILL ON SAME ONE
	STB	R1,RMPAGE,KN,KN		:YES - SAVE NEW PAGE NUMBER
	OHI	R1,80
	clhi	prd,1,r4		:about to send 0 len msg?
	jnfs	rmkab4
	sis	prd,2			:yes, so back up and just send page
	ais	prc,2			: change
rmkab4	STB	R1,0,PRD		:INSERT PAGE CHANGE COMMAND
	AIS	PRD,1
	SIS	PRC,1
	LHI	R1,0E2			:apply BACKPRESSURE HEADER
	STB	R1,0,PRD
	lis	r1,1			:length
	STB	R1,1,PRD		:store current len (1)
	STB	CHN,2,PRD		:CURRENT CHANNEL RELIEVING BACKPRESSURE
	SIS	PRC,3
	Lhi	R4,1,PRD		:R4 POINTS TO NEW B.P. len field
	AIS	PRD,3
	Jfs	rmkab6
rmkab5	LB	R0,0,R4			:GET BACKPRESSURE HEADER
	AIS	R0,1			:INCREMENT SIZE FIELD
	STB	R0,0,R4			:STORE HEADER BACK WITH UPDATED COUNT
	STB	CHN,0,PRD		:CURRENT CHANNEL RELIVING BACKPRESSURE
	AIS	PRD,1
	SIS	PRC,1
rmkab6	CLHI	PRC,4			:ROOM FOR PAGE CHANGE, HEADER, CHANNEL?
	JGE	rmkab1			:YES - CONTINUE
	Jr	r8			:null return is for rescheduling

       ei	:aplybp


::*********************************************************************
::
::	SUBROUTINE:	RMKSBP
::	FUNCTION:	Releases backpressure for ports with backpressure
::			applied in RMKABP.  Very similar to RMKABP except
::			send msg condition is reversed and different
::			criteria for servicing ports.
::	CALLING SEQ:	JAL R8,RMKSBP
::	INPUT:		R7 (pointer to link flags), KD, PRC, PRD
::	DESTROYED:	R0,R1,R2,R3,R5
::	CALLS:	
::	RETURNS:	null return means could not fit all bp message in
::			this packet and so it should be rescheduled by the
::			caller.
::			+4 return means everything went okay
::
::*********************************************************************

       if	aplybp

rmksbp	la	r0,ABPXCP-2,r7,		:BP applied
	LHL	LRC,NCHN,KD		:MAX # OF CHANNELS ON LINK DIVIDED BY 8
	lr	r2,lrc
	sis	r2,1			:how many bits to service
	sth	r2,rmtsr4		:how may chns to service
	sis	r2,0f			:now how many bits to copy
	SRLS	LRC,3			: = # OF BYTES IN LINK ARRAYS (ie GUSH)
	la	r1,scratc-2,r7,lrc	:get dest address
	ar	r0,lrc			:orig address -2
	copy	r0,r2			:move the bits
	LHI	R0,0E3			:L.R. HEADER FOR BACKPRESSURE RECORD
	STB	R0,0,PRD		:L.R. COUNT=0 IS O.K., FORCES TRAFFIC
					: ON LIGHTLY LOADED LINK
	AIS	PRD,1			:point to len
	lis	r0,0			:starting count is 0
	STB	R0,0,PRD		:
	LR	R4,PRD			:POINTER TO BACKPRESSURE HEADER
	AIS	PRD,1			:point to first free
	SIS	PRC,2			:header is two bytes
rmksb1	LHL	R2,RMTSR4		:last chn serviced for this link
	OHI	R2,0F			:search from this HW
	LR	R1,R2
	SRLS	R1,3			:make into # HWs -1
	LA	R0,ABPXCP-1,R1,R7	:port already bped flags
	LA	R1,scratc-1,R1,R7	:chns not yet serviced or BPed flags
	ARAND	R0,R2			:ARRAYAND RETURNS HIGHEST NONZERO
	jfs	rmksb3			:where to go on a hit
	ais	r4,1			:remove empty if present
	cr	prd,r4			:any chns in record?
	jn	4,r8			:not empty
	sis	prd,2			:empty, so back up pointer
	ais	prc,2			:and increase count of until end
	j	4,r8			:now done with Backpress Record

:	have a chn that may need to have bp applied
rmksb3	rbt	r2,scratc,r7,		:serviced bit
	sth	r2,rmtsr4
	lr	CHN,r2			:CHANNEL NUMBER
	ar	r2,r2			:2 * CHANNEL NUMBER
	LH	R2,NIOTAB,R6,r2		:PERMUTER TABLE ENTRY
	LIS	R1,3
	NR	R1,R2			:ISOLATE SPEED BITS IN R1
	xr	R2,r1			:BUFFER INDEX IN R2
	LHL	R0,BCT,R2,		:GET BUFFER BYTE COUNT
	CLH	R0,CIRSPB,R1,R1		: AND COMPARE TO CHANNEL CIRCUIT SPEED
	JG	rmksb6			:BCT less, DON'T apply BACKPRESSUR
	RBT	CHN,ABPXCP,R7,		:mark bp released
	EXBR	R1,CHN
 	CLB	R1,RMPAGE,KN,KN		:ARE WE CHANGING PAGES?
	JE	rmksb5			:NOPE - STILL ON SAME ONE
	STB	R1,RMPAGE,KN,KN		:YES - SAVE NEW PAGE NUMBER
	OHI	R1,80
	clhi	prd,1,r4		:about to send 0 len msg?
	jnfs	rmksb4
	sis	prd,2			:yes, so back up and just send page
	ais	prc,2			: change
rmksb4	STB	R1,0,PRD		:INSERT PAGE CHANGE COMMAND
	AIS	PRD,1
	SIS	PRC,1
	LHI	R1,0E3			:release BACKPRESSURE HEADER
	STB	R1,0,PRD
	lis	r1,1			:current len
	STB	R1,1,PRD		:store current len (1)
	STB	CHN,2,PRD		:CURRENT CHANNEL RELIEVING BACKPRESSURE
	SIS	PRC,3
	Lhi	R4,1,PRD		:R4 POINTS TO NEW B.P. len field
	AIS	PRD,3
	Jfs	rmksb6
rmksb5	LB	R0,0,R4			:GET BACKPRESSURE HEADER
	AIS	R0,1			:INCREMENT SIZE FIELD
	STB	R0,0,R4			:STORE HEADER BACK WITH UPDATED COUNT
	STB	CHN,0,PRD		:CURRENT CHANNEL RELIVING BACKPRESSURE
	AIS	PRD,1
	SIS	PRC,1
rmksb6	CLHI	PRC,4			:ROOM FOR PAGE CHANGE, HEADER, CHANNEL?
	JGE	rmksb1			:YES - CONTINUE
	Jr	r8			:null return is for rescheduling

       ei	:aplybp

	SUBTTL	YAKYAK (CHRTRC - Character Trace)

::*********************************************************************
::
::	SUBROUTINE:	CHRTRC:
::	FUNCTION:	CHARACTER TRACE ROUTINE.
::	CALLED BY RTD OR RMAKE TO RECORD DATA
::	TRAVELING ON A CHANNEL WITH A SET BIT IN 'TRCHAN' BIT ARRAY. THE
:: 	CALLING ROUTINE PASSES THE I/O INDICATOR IN R0 (-2 IF
::	RTD, -1 IF RMAKE), THE ABSOLUTE CHANNEL NUMBER IN R1, THE POINTER
::	TO THE LOGICAL RECORD IN R9, AND THE LOGICAL RECORD COUNT IN LRC.
::
::	RTD AND RMAKE CALL CHRTRC FOR EACH LOGICAL RECORD DETECTED FOR CHANNELS
:: 	BEING TRACED. THE CHRTRC ENTRY CONSISTS OF A FIXED LENGTH HEADER AND
:: 	VARIABLE LENGTH DATA (BASED ON LRC). THE HEADER FORMAT IS AS FOLLOWS:
::		HW1 - I/O INDICATOR
::		HW2 - ABSOLUTE CHANNEL NUMBER
::		HW3 - FASTC
::		HW4 - LOGICAL RECORD LENGTH (LRC)
:: 	AND IS FOLLOWED BY THE DATA. EACH ENTRY BEGINS ON A DOUBLEWORD BOUNDARY
:: 	IN 'TRRING', WHICH IS A CIRCULAR RING INDEXED BY 'TRRIX'.  if the
::	traced chn is a link chn then check and see if it is a command
::	circuit and if so then mark it for detection in display logic.
::
::	CALLING SEQ:	JAL  R10,CHRTRC
::	INPUT:		R0,R1,R9,LRC
::	PRESERVED:	R1,R9,LRC
::	DESTROYED:	R0
::	RETURNS:	JR  R8
::
::*********************************************************************

CHRTRC	SYAD(CHRTRC)
	NOPR	0,R8			:PATCH TO '0308' TO TURN OFF TRACE
	STM	PRD,TRREGS		:SAVE SOME REGS
	LHI	TC,TRRSIZ-1		:POWER OF 2 RING WRAP MASK
	LHL	PRD,TRRIX		:GET CURRENT RING INDEX
	STH	R0,TRRING,PRD,		:STORE I/O INDICATOR AND
	clhi	r1,lnkzfl		:is it a link chn?
	jlfs	chrt08			:no, too small
	tbt	r1,cmdcts-(lnkzfl/8),,	:is it a cmd circuit?
	jefs	chrt08			:not a cmd cir
	ohi	r1,8000			:mark it as a cmd cir
chrt08	STH	R1,TRRING+2,PRD,	: ABSOLUTE CHANNEL NUMBER
	LH	R0,FASTC+2,,
	STH	R0,TRRING+4,PRD,	:STORE CURRENT TIME
	STH	LRC,TRRING+6,PRD,	:STORE LOGICAL RECORD LENGTH
	AIS	PRD,8
	NR	PRD,TC

:	NOW MOVE LOGICAL RECORD TO TRRING. MUST MOVE A BYTE AT A TIME
:	SINCE HALFWORD ALIGNMENT NOT GUARANTEED.

CHRT10	LB	R0,0,R9			:GET BYTE FROM LOGICAL RECORD AND
	STB	R0,TRRING,PRD,		: MOVE IT TO RING
	AIS	R9,1
	AIS	PRD,1			:INCREMENT POINTERS
	NR	PRD,TC
	SIS	LRC,1			:DECREMENT COUNT
	JGBS	CHRT10			:MORE TO DO...

	AIS	PRD,7			:ROUND INDEX UP TO NEXT DOUBLEWORD BND
	NHI	PRD,TRRSIZ-8
	STH	PRD,TRRIX		:SAVE TRRING INDEX
	lhl	r0,xtdato		:any ports doing auto display
	jefs	chrt98
	lhi	r0,1f-pxray
	sbt	r0,squeue		:msg arrived, sched xray to disp it
	lhl	r0,xusiua
	sth	r0,xquem,,
chrt98
	LM	PRD,TRREGS		:RESTORE REGS AND
	JR	R8			: RETURN

	SUBTTL	YAKYAK (CHKTRM - Character Trace)

::*********************************************************************
::
::	SUBROUTINE:	CHKTRM
::	FUNCTION:	Pre-processor for SQFIX and SQACK network quads.
::	read network quad from buffer, adjust LRC and PRD, test for
::	terminating circuit.  Skip return if termination, immediate return
::	if pass-thru.
::	CALLING SEQ:	JAL  R9,CHKTRM
::	INPUT:		PRD
::	OUTPUT:		R4 = FW following network character pair
::	DESTROYED:	R1
::	RETURNS:	JN   4,R9	: Termination
::			SKIP(0,R9)	: Passthrough
::
::*********************************************************************

CHKTRM	LB	R1,0,PRD		:COLLECT NEXT TWO BYTES FROM PACKET
	LB	R4,1,PRD
	EXBR	R1,R1
	OR	R4,R1			:ASSEMBLE HW DATA INTO R4
	EXHR	R4,R4			:SHIFT INTO UPPER HW		###GT
	LB	R1,2,PRD		:NOW THE LOWER HW		###GT
	EXBR	R1,R1			:				###GT
	OR	R4,R1			:				###GT
	LB	R1,3,PRD		:				###GT
	OR	R4,R1			:				###GT
	AIS	PRD,4			:ADVANCE PRD BEYOND THE CHARACTER QUAD
	SIS	LRC,4			:ADJUST COUNT,BYTES LEFT IN LOGICAL REC
	LR	R1,R2			:MOVE BUFFER NUMBER OVER TO R1
	SRLS	R1,3			:DIVIDE BUFF # BY 8 FOR CRQ ARRAY INDEX
	TBT	R1,CRQEND		:TEST FOR ENDPOINT ON THIS NODE
	JN	4,R9			:A TERMINATION - SKIP RETURN	###wjl
	SKIP(0,R9)			:A PASSTHRU - IMMEDIATE RETURN	###wjl

	SUBTTL	YAKYAK (Dispatch Tables/Common Crashh locations)

::*********************************************************************
::
::	PFMRTD:	DISPATCH TABLE FOR PERFORMANCE MONITORING CONTROL CHARACTERS
::		MOVING ON PASSTHROUGHS, DETECTED IN RTEAR
::
::*********************************************************************

PFMRTD	WC	RTDXLA		:XLAX	   03-20
	WC	RTDXAK		:XLAX ACK  03-21
	WC	RTDALL		:TIMER	   03-22
	WC	RTDALL		:TIMER ACK 03-23
	WC	RTDALL		:REJECT	   03-24
	WC	RTDALL		:WILD CARD 03-25
	WC	RTDALL		:WILD CARD 03-26
	WC	RTDALL		:WILD CARD 03-27
	WC	RTDALL		:WILD CARD 03-28
	WC	RTDREJ		:LOG II (illegal for perf to receive) 0329
	WC	RTDREJ		:LOG II (illegal for perf to receive) 032A
	WC	RTDREJ		:LOG II (illegal for perf to receive) 032B
PFMRTZ	EQ	(.-PFMRTD)/4	:NUMBER OF DEFINED PERFORMANCE MONITORING CHARS

::*********************************************************************
::
::	PFMTRM:	DISPATCH TABLE FOR PERFORMANCE MONITORING CHARACTER PAIRS
::		ARRIVING AT THE TERMINATING END OF A CIRCUIT
::		(INTERNAL OR TO A T-1 NODE)
::
::*********************************************************************

PFMTRM	WC	RTDXL1		:XLAX		03-20
	WC	RTDSNK		:XLACK ACK	03-21
	WC	RTDTM1		:TIMER		03-22
	WC	RTDSNK		:TIMER ACK	03-23
	WC	RTDSNK		:REJECT		03-24
	WC	RTDREJ		:WILD CARD	03-25
	WC	RTDREJ		:WILD CARD	03-26
	WC	RTDREJ		:WILD CARD	03-27
	WC	RTDREJ		:WILD CARD	03-28
	WC	RTDREJ		:LOG II NEEDLE  03-29
	WC	RTDREJ		:Log 2 body	03-2A
	WC	RTDREJ		:Log 2 tail	03-2B
PFMMAX	EQ	PFMRTZ+1F	:UPPER LIMIT OF VALID PERF MONITORING CHARS
PFMRTB	EQ	PFMRTD-80	:PFMRTD ADDRESS WITH PERF. MONITOR BIAS REMOVED
PFMTRB	EQ	PFMTRM-80	:SAME FOR TERMINATION DISPATCH TABLE

::*********************************************************************
::
::	NEGBCR:	COMMON CRASH LOCATION FOR BFLTSV (BUFFERLET CHARS IN USE COUNT)
::	DETECTED NEGATIVE. ROUTINE IS CALLED BY JAL R7, SO R7 CONTAINS
::	THE LOCATION OF THE CRASH CAUSE. ###OAS
::
::*********************************************************************

NEGBCR	CRASH.(.NEGBF)

::*********************************************************************
::
::	NEGHCR:	COMMON CRASH LOCATION FOR HBFTSV
::	(HIST BUFFERLET CHARS IN USE COUNT) DETECTED NEGATIVE.
::	ROUTINE IS CALLED BY JAL R7, SO R7 CONTAINS
::	THE LOCATION OF THE CRASH CAUSE. ###OAS
::
::*********************************************************************

NEGHCR	CRASH.(.NEGHB)

	SUBTTL	YAKYAK (RTEAR - Record TEARdown)

::*********************************************************************
::
::	SUBPROCESS:	RTEAR:
::	FUNCTION:	RTEAR checks to see if a link is awaiting a BORI
::	Zap.  If not, it looks up the length of the packet based on PRD.
::	Then it points to the first logical record and calls RTD.
::	It returns to update LRT and make entries in the Sync Line Trace
::	Table.  A check is made to provide equal link service.  
::	CALLING SEQ:	J RTEAR  (called directly from SPIDER)
::	INPUT:		R2 contains link number
::	CALLS:		JAL  R9,RTD
::			JAL  R8,TSBMRK
::	RETURNS:	J    spdrmk
::
::*********************************************************************

xicrtd	hc	ticrtd			:rtd time limit
	syad(XICRTD)

rtears	lhi	r0,2*((nlinks-1)/10)+lktear
	lhi	r1,2*((nlinks-1)/10)+borzap	:dont consider links going down
	lhi	kn,(((nlinks-1)/10)*10)!0f
	sth	kn,didall		:have serviced each link once
	arand	r0,kn			:find an unserviced link
	jfs	rtearj			:link serviced, but can do it again 
	j	spdrmk,,

RTEAR	LIS	R0,0			:check all links before checking time
	STH	R0,DIDALL		:to ensure equal minimum service
	L	R0,FASTC,,		:get time
	AH	R0,XICRTD		:number of ticks for RTEAR	###sdw
	ST	R0,DIDTIM
RTEARJ	HS	0			:tear more than 1 packet per link if
	 				:time permits
Q	EQ	0			:set to service all links
	 RE	LKSIZE/4
	L	R0,LKTEAR+4*Q		:links with data
	ST	R0,LKSRVD+4*Q		:just a few STs, not worth a loop
Q	EQ	Q+1
	 ER
rtear5	L	R0,FASTC,,
	S	R0,DIDTIM		:time for us to dismiss
	jle	rtear0			:continue making packets
	lh	r1,didall		:everyone get serviced?
	jg	spdrmk,,		:yes, return to spider
	jal	r0,exyld,,		:no, come on back after doing whatever
	ts	didall			:negative, took timout
	lh	r0,xicrtd
	a	r0,fastc,,		:next timeout expiring
	st	r0,didtim
:	do each link before doing any link again, thus it the service array is
:	0 then check original to see if any serviced have more data.
:	using arands is a whole lot faster than searching for a nonzero
:	word to then jump to a jffo.

rtear0	lhi	r0,2*((nlinks-1)/10)+lksrvd
	lhi	r1,2*((nlinks-1)/10)+borzap
	lhi	kn,(((nlinks-1)/10)*10)!0f
	arand	r0,kn			:find an unserviced link
	jfs	rtearw
	lh	r0,didall
	jge	rtears			:didn't take a timout
	j	spdrmk,,
rtearw	rbt	kn,lksrvd
	lr	r1,KN
	ar	r1,r1
	L	KD,KDKN,r1,r1		:GET DESCRIPTOR POINTER
	LHL	CD,NRTR,KD		:PTR TO NEXT RECORD TO TEAR
	LH	R1,LRT,KD		:IF REC # = LRT+1, WE HAVE A RECORD
	AIS	R1,1
	CHVR	R1,R1
	CLH	R1,RECN,CD
	JEFS	RTEAR1
RTEARZ	RBT	KN,LKTEAR		:NO MORE, MARK THIS LINK AS SERVICED
	J	RTEARE			:see if we are done

RTEAR1	LH	R0,FASTC+2,,		:CURRENT TIME
	SH	R0,INTIME,cd		:GET INTERVAL BETWEEN SYLVER AND NOW
	JGEFS	RPERF1			:NO WRAP
	AI	R0,10000
RPERF1	AM	R0,KS.SRC,KD		:AND ADD INTO RUNNING SUM
	L	PRD,BREC,CD		:TYMNET-II - PTR TO RECORD
	Lb	PRC,0,PRD		:SET PRC=PHYS BYTE CNT
	NHI	PRC,0F
	LB	PRC,SYTWCN,PRC
	AIS	PRC,4			:INCLUDE CHECKSUM AND COUNT
	AM	PRC,KS.PCI,KD		:COUNT PACKET CHARACTERS INPUT
	SIS	PRC,7			:DON'T INCLUDE CHECKSUM, HEADER FOR RTD
	AIS	PRD,3			:INDEX PRD TO FIRST LOG REC

:	> > > > > > > > > > > > > > > > >
	JAL	R9,RTD			: go tear down
:	< < < < < < < < < < < < < < < < <

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND 
	CLH	R0,TSLINK		: TEST FOR LINK OF INTEREST
	JN	RTEART			:NO - CONTINUE
	JAL	R8,TSBMRK,,		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RTD		:GET EVENT TYPE (RECORD TORN)
	STB	R0,TSBTBL,R7		: AND STORE IN ENTRY
	L	R8,BREC,CD
	LHL	R0,0,R8		:GET HEADER HALFWORD
	STH	R0,TSBTBL+2,R7		: AND STORE
	LB	R0,2,R8
	STB	R0,TSBTBL+4,R7		:THIRD BYTE RECORD NUMBER
	LHL	R0,LAS,KD
	STB	R0,TSBTBL+1,R7		:STORE LAST ACK SENT
RTEART	EI	:TSTSZE
	LHL	R2,RLNK,CD		:INDEX NRTR
	STH	R2,NRTR,KD		:r2 is CD for next packet to tear

	LH	R1,LRT,KD
	AIS	R1,1
	sth	r1,lrt,kd		:RECORD TORN, UPDATE LRT
	ais	r1,1			:IF REC # = LRT+1, WE HAVE A RECORD##TZ
	CHVR	R1,R1			:##TZ
	CLH	R1,RECN,r2		:DO WE HAVE ANOTHER RECORD?	##TZ
	JEFS	RTEARE			:YES, CONTINUE			##TZ
	RBT	KN,LKTEAR		:MARK THIS LINK COMPLETED	##TZ
RTEARE	LHL	R0,SQUEUE
	THI	R0,1^(pckzb-10) 	:buffer zap pending?
	JE	RTEAR5
	JAL	R0,EXYLD,,		:go do bufzap
	J	RTEAR5			:back to another link

	SUBTTL	YAKYAK  (RTD)

::*********************************************************************
::
::	SUBROUTINE:	RTD
::	FUNCTION:	Tears down all logical records in a physical 
::	record.  If logical records exist in a packet, RTD does a range
::	check on the channel number.  If chan # in range then checks 
::	throughput level and updates counter and does trace if necessary.
::	Then RTD copies from logical record to buffer, detects special
::	characters and link control messages, and acts accordingly.  
::	Shrinks the link if necessary.  Processes incoming  needles.
::	Bubbles if necessary.  If serious errors occur, the link
::	will be snipped.
::	CALLING SEQ:	JAL  R9,RTD
::	INPUT:		R2(KN) = Link Number
::			R10(PRC) = Physical Record byte count
::			R12(PRD) = Pointer to Physical Record
::		
::	CALLS:		JAL  R8,CHRTRC	: Make trace entry in TRRING
::			JAL  R9,W2CI	: Write 2 chars into buffer
::			JAL  R8,WCFRST	: Chain first bufferlet into buffer
::			JAL  R7,NEGBCR	: Crash
::			JAL  R0,BUFZAP	: Zap buffer specified by R2
::			JAL  R0,WRE	: Link reserve tank to freelist
::			JAL  R9,RSTRIP	: Return bufferlets to free pool
::			JAL  R9,GOBBLN	: Eat buffer, put Gobbler in
::			JAL  R8,WCI	: Write character into bufffer
::			JAL  R8,WCD	: Prefix character into buffer
::			JAL  R10,SUP12L	: Node report Bubble or Shrink
::			JAL  R8,CRYPTO	: Generate Xray diagnostic
::			JAL  R9,ZAPXNG	: Nongobbling Zapper detected
::			JAL  R9,ZAPHRD	: Force hard zap of circuit
::			JAL  R8,GFCBUF	: Get buffer index from FREELB
::			JAL  R9,CRQHCR	: Create half a circuit
::			JAL  R10,TRCIRC	: Tear circuit & reqest rebuild
::			JAL  R10,SUP08	: T-I Zapper sent or received
::			JAL  R8,PCIS	: Peak at first character
::			JAL  R8,PCI	: Peak at next character
::			JAL  R8,CBCLR	: Clear a buffer
::			JAL  R8,SPEED	: Expedite Zappers and Gobblers
::			JAL  R9,CHKTRM	: Test for terminating circuit
::			JAL  R8,RBFLTS	: 
::			JAL  R8,RETBLT	: Return first bbflt to free list
::			JAL  R9,RBCOUT	:
::			JAL  R7,NEGHCR	: Crash
::			JAL  R10,TRCRFT	: Tear circuit and request rebuild
::			JAL  R9,CRQALT	: Signal CRQ of Needle
::			JAL  R9,PHWI	: Peek at next halfword
::			JAL  R8,WCNXT	: Chain another bufferlet
::			JAL  R8,BUBBLE	: Link Bubble
::
::	RETURNS:	JR  R9
::
::*********************************************************************


RTD	ST	R9,RTMXSV		:SAVE RETURN
	LHL	R6,TBDPKN,KN,KN		:PTR TO IOTAB FOR THIS LINK
	LHL	R7,FLDPKN,KN,KN		:POINT TO HALFWORD WHERE THIS LINK'S
					: FLAGS BEGIN

RTD1	CLHi	PRC,1		:IS PACKET RECORD COUNT DEPLETED?
	JL	RTDXIT			:YES, NO MORE LOGICAL RECS IN PACKET
:	PROCESS THIS RECORD 
	LB	LRC,0,PRD		:GET LOGICAL REC COUNT
	JE	RTDXIT			:END-OF-PACKET INDICATION
	LB	CHN,1,PRD		:GET CHANNEL NUMBER FROM PACKET
	AIS	PRD,2			:BUMP PTR PAST CHAN # AND COUNT.
	THI	LRC,80			:IF LRC>7F, IT'S A PRIORITY MESSAGE
	JN	RTDPRI			:YES
	lis	r0,1
	am	r0,rtdlrr		:logical records torn

	SHI	PRC,2,LRC		:NEW PRC = OLD PRC-LRC-2
	AH	CHN,RTPAGE,KN,KN	:ADD CHANNEL PAGE #

:	CONSISTENCY CHECK - RANGE CHECK CHANNEL NUMBER
	LHL	R0,EBDPKN,KN,KN		:GET END OF TABLES POINTER AND
	SR	R0,R6			: SUBTRACT BEGINNING OF TABLE ADDRESS
	SRLS	R0,1			:NUMBER OF CHANNELS THIS LINK
	CR	CHN,R0
	JGE	RTDBIG			:CHANNEL NUMBER TOO LARGE,
					: INVESTIGATE FURTHER

:	GOT A LOGICAL RECORD WITH A REASONABLE CHANNEL NUMBER. PROCEED
:	WITH LOGICAL RECORD TEARDOWN

:	SEE IF DATA 'GUSHING' OR 'TRICKLING' IN FOR THIS CHANNEL...
RTD01	sbt	chn,gush,r7,		:always gushing
	AR	CHN,CHN			:make halfword channel index	###wjl
RTD04	AM	LRC,KS.LCI,KD		:COUNT LOGICAL CHARACTERS INPUT
RTD15	LHL	R2,NIOTAB,R6,CHN	:DESTINATION BUFFER # FOR THIS CHANNEL
	NHI	R2,-4			:STRIP OUT THE CIRCUIT SPEED BITS
	JE	RTDUAC			:UNASSIGNED CHANNEL
					: - EITHER NEEDLE OR BAD DATA
RTD6	HS	0			:				###GT
	IF	REBILD
	AM	LRC,VSEQN,R2,		:UPDATE THE RECEIVE SEQUENCE NUMBER
	EI	:REBILD			: - NOTE THAT NEEDLES ARE NOT COUNTED

:	TEST FOR CHARACTER TRACING FOR THIS CHANNEL
	LHL	R1,BF,R2,		:DESTINATION ABSOLUTE CHANNEL NUMBER
	TBT	R1,TRCHAN,,		:TRACING DESIRED?
	JEFS	RTD610			:NO
:	TRACING FOR THIS CHANNEL. R9 SHOULD POINT TO BEGINNING OF LOGICAL
:	RECORD, R0=-2 INDICATES RECORDING DATA INTO NODE...
	LR	R9,PRD			:POINT TO FIRST BYTE OF DATA
	LCS	R0,2			: -2 =>INPUT
	JAL	R8,CHRTRC		:MAKE TRACE ENTRY FOR THIS LOGICAL REC

RTD610	HS	0
	IF	BFLTMR			:check for sending of buff timing pairs
	LHL	R1,BF,R2,		:scheduled by dest chan #
	SHI	R1,LNKZFL		:schedule array is for link chans only
	JLE	RTD620			:don't do it if bound for internal chn
	SBT	R1,BFDARY,,		:set and test scheduling bit
	JN	RTD620			:set (inactive) already,no pair for now
	TBT	R1,CMDCTS,,		:don't send pair on a cmd channel
	JNFS	RTD620
:	send a buffer delay timimg pair (COMET)
	LHI	R1,COMET
	JAL	R9,W2CI			:put pair in buffer (no escapes)
	LHL	R1,FASTC+2,,
	JAL	R9,W2CI			:followed by halfword of FASTC
RTD620	EI	:BFLTMR
	L	R3,BE,R2,		:LOAD THE BUFFER IN POINTER
	JNFS	RTD2			:BUFFERLET ALREADY ALLOCATED
	JAL	R8,WCFRST		:EMPTY BUFFER, GET FIRST BUFFERLET
	SIS	R3,1			:SET UP R3 (BE) FOR MICROCODE

:	HERE TO PROCESS A LOGICAL RECORD
:
:	RTD COPY MICROINSTRUCTION:
:		R1  = scratch
:		R14 = LRC = byte count of characters to move
:		R12 = PRD = address of the logical record
:		R3  = BE (address of the last character input)
:	NOTE THAT THE RTD COPY INSTRUCTION WAITS UNTIL IT HAS 2 BYTES
:	TO MOVE BEFORE IT ACTUALLY WRITES INTO THE BUFFERLET. THIS
:	MEANS THAT IF A SPECIAL CHARACTER IS ALSO THE LAST CHAR IN A
:	LOGICAL RECORD, IT MUST BE EXPLICITLY STORED WITH A STB INSTRUCTION
:	SINCE THE MICROCODE MAY NOT HAVE DONE SO.
:
:START	LB	RA,0,PRD	:GET NEXT BYTE 
:	INC	PRD	:ADVANCE PRD TO NEXT BYTE IN RAW PACKET (PRD=R12)
:	INC	BE		:ADVANCE BE TO SLOT WHERE BYTE WILL GO
:	END OF BUFFERLET?
:	YES => GET NEXT ONE, PROCEED AT 'NEXT'
:NEXT	'STORE' RA,0,BE		:STORE ONLY ON EVEN BE, USING HW WRITE
:	SPECIAL CHAR? (0-3)
:	IF YES, BRANCH OUT
:	DEC	LRC		:DECREMENT COUNT OF RAW BYTES REMAINING
:	LRC=0?
:	IF NOT, GOTO START
:	ELSE DONE

RTD2	LHL	R0,0,R3			:SET UP SCRATCH REGISTER
	EXHR	R0,R0			: FOR THE MICROCODE
	LHL	R1,0,PRD
	OR	R1,R0

RTD2A	HC	3B1E			:RTD Copy 1 - SCRATCH REG, BYTE COUNT 
RTD2B	HC	3C1E			:RTD Copy 2 - RESUME PROCESSING HERE
	HC	RTDNXT-RTD2B		:TO GET NEXT BUFFERLET
	HC	RTDC00-RTD2B		:TO HANDLE CHARACTER PAIRS
	HC	RTDC01-RTD2B		:TO HANDLE PREFIX CODES
	HC	RTDC2-RTD2B		:TO HANDLE GOBBLERS
	HC	RTDC3-RTD2B		:TO HANDLE ZAPPERS

:	WE'VE TORN DOWN A LOGICAL RECORD
RTD3 	ST	R3,BE,R2,		:COME HERE WHEN DONE -- SAVE END ADDR
	IF	DB.DEB
	LR	R2,R2			:VERIFY BUFFER INDEX INTEGRITY
	JN	RTD1			:NON-ZERO - MUST BE GOOD...
	DBOOPS
	ELSE	:NOT DB.DEB
	J	RTD1			:DONE WITH THIS LOGICAL RECORD
	EI	:DB.DEB


:	HERE TO SET UP A NEW BUFFERLET
RTDNXT	JAL	R8,NXTBLT
	IF	DB.DEB
	J	RTD2B
	ELSE	:
	JBS	RTD2B
	EI	:DB.DEB

::*********************************************************************
::
::	SUBROUTINE:	NXTBLT:
::	FUNCTION:	ALSO USED BY HISTORY-MAKER IN RMAKE
::	CALLING SEQ:	JAL	R8,NXTBLT
::
::*********************************************************************

NXTBLT	THI	R3,CBSZ-1		:REALLY END OF BLFET?
	JNR	R8			:nope, return
	LHI	R0,CBSZ-cbptsz		:COUNT OF BYTES IN BUFFERLET

	IF	REBILD
	CI	R2,HBUFN		:IS R2 A HISTORY BUFFER INDEX	###OAS
	JLFS	RTDNX0			:NO				###OAS
	AM	R0,HBFTSV		:YES, UPDATE HISTORY BUFFER COUNT##OAS
	JGEFS	RTDNX0			:CHECK FOR HBFTSV GOING <0	###OAS
	JAL	R7,NEGHCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RTDNX0	EI	:REBILD
	AM	R0,BFLTSV		:UPDATE COUNT OF BUFFERLETS IN USE
	JGEFS	RTDNX9			:CHECK FOR BFLTSV GOING <0	###OAS
	JAL	R7,NEGBCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RTDNX9	AHM	R0,BCT,R2,		: AND COUNT FOR THIS BUFFER
	JG	RTDNX2			:BCT < 32K
	LHL	R0,BCT,R2,
	CI	R0,0ffff-cbsz		:ARE WE IN DANGER OF OVERFLOW?
	JL	RTDNX2			:NO
	STM	R0,REGST		:STORE REGS 			###LSH
	JAL	R14,BFZDB2,,		:SAVE SOME DATA FOR DEBUGGING	###LSH
					:BEFORE WE ZAP THE BUFFER 	###LSH 
	LM	R0,REGST		:RESTORE REGS			###sdw
	JAL	R0,BUFZAP,,		:YES - ZAP BUFFER
	L	R3,BE,R2,		:SET UP R3 FOR RE-ENTRY OF RTD INSTRUCT
	JR	R8			:GO CONTINUE PROCESSING

RTDNX2	LHL	R0,FREELT		:NEXT FREE BUFFERLET, PLEASE
	JNFS	RTDNX4			:SKIP IF SOMETHING THERE
	JAL	R0,WRE			:GET RESERVE TANK
	JBS	RTDNX2
RTDNX4	STH	R0,0,R3			:LAST 1/2 WD OF BUFFERLET IS LINK
	LR	R3,R0			:CURRENT BUFFERLET ADDRESS
	SLLS	R3,CBSZL		:SHIFT APPROPRIATELY
	ais	R3,CBPTSZ		:ADD IN START OF BUFFERLET AREA
	LHL	R0,CBSZ-cbptsz,R3	:NEXT BFLET FROM FREE LIST
	STH	R0,FREELT		:IS NOW FIRST IN QUEUE
	JR	R8			:GO CONTINUE PROCESSING
::
::
::***********************************************************************

:	HERE ON 02 CHARACTER DETECTION  (an ignored char pair)
:	passed on if middle node and eaten at termination
RTDC2	LIS	R0,2			:SET UP R0 FOR RTDIG
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1
	lr	r8,r2
	srls	r8,3
	tbt	r8,crqend		:a termination?
	je	rtdig			:no, just pass it along
	SIS	LRC,1			:DECREMENT LRC TO ACCOUNT FOR 02 CHAR
	AIS	PRD,1			:PRD ==> 1ST CHAR BEYOND 02-XX PAIR
	SIS	LRC,1			:DEC LRC, ACCNT FOR 2ND CHAR IN 02 PAIR
	jal	r9,rstrip
	j	pfmout			:and proceed on
	
:	HERE ON 00 CHARACTER

RTDC00	LIS	R0,0			:SET UP R0 IN CASE WE GO TO RTDIG
	JFS	RTDC0X

:	COME HERE FOR 01 CHARACTER

RTDC01	LIS	R0,1			:IN CASE WE GO TO RTDIG

RTDC0X	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1.

	ST	R3,BE,R2,		:SAVE END POINTER
	STB	R0,0,R3			:STORE 1ST CHAR OF PAIR
:	NOTE:  R3 WAS ALREADY INC'D BY MICROCODE

	LB	R1,0,PRD		:GET NEXT CHAR (MICROCODE INC'D PRD)
	AIS	PRD,1
	JAL	R8,WCI			:STORE THE CHAR
	SIS	LRC,2			:DECREMENT COUNT FOR BOTH CHARACTERS

RTDTY1	L	R3,BE,R2,		:RESTORE BE POINTER
	LR	LRC,LRC			:DONE WITH LOGICAL RECORD?
	JG	RTD2			:MORE TO DO FOR THIS CHANNEL
	JE	RTD3			:DONE WITH THIS CHANNEL
:	NEIGHBOR SPLIT CHARACTER PAIR...SNIP THE LINK
	LIS	R0,LS.SCP		:INDICATE SPLIT CHARACTER PAIR RECEIVED
	J	RTDSNP			:GO SNIP THE LINK

:	HERE TO CONTINUE AS IF SPEC CHARACTER HADN'T BEEN DETECTED

RTDIG	SIS	LRC,1			:DECR LRC SINCE MICROCODE DIDN'T
	JG	RTD2A			:MORE FOR THIS CHANNEL, GO DO IT

	STB	R0,0,R3
	J	RTD3			:GO FINISH UP


:	HERE ON 03 CHAR DETECTION (T-1 ZAPPERS, T-2 NETWORK CONTROL CHARACTERS)
:	R3	POINTS TO SLOT FOR '03' CHARACTER (BE)
:	LRC	HAS NOT BEEN DECREMENTED TO REFLECT '03'
:	PRD	POINTS TO SECOND CHARACTER IN 03-XX PAIR

RTDC3	LIS	R0,3			:SET UP R0 FOR RTDIG
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1
	SIS	LRC,1			:DECREMENT LRC TO ACCOUNT FOR 03 CHAR
	LB	R4,0,PRD		:TYM-II, CHECK SECOND CHAR
	AIS	PRD,1			:PRD ==> 1ST CHAR BEYOND 03-XX PAIR
	SIS	LRC,1			:DEC LRC, ACCNT FOR 2ND CHAR IN 03 PAIR
	CLHI	R4,01F			:IS CHAR A ZAPPER? ( 0301 TO 031F )
	JLE	RTDZPR			:YES
       IF	LOGII			:LOG II needle is in perf range
	CLHI	R4,NEEDBD&0FF		:r3 still has buf adr that we must save
	JE	RTDNBD			:needle body char
	CLHI	R4,NEEDTL&0FF
	JE	RTDNTL			:we have a needle tail
       EI	:LOGII
	CLHI	R4,03F			:IS CHAR A PERF MONITOR? (0320 TO 033F)
	JLE	RTDPFM			:YES

:	HERE IF INVALID 03 CHARACTER PAIR...

BADCTL	st	r3,be,r2,
	JAL	R9,GOBBLN,,		:CLEAR BUFFER OF SUSPICIOUS DATA
	LIS	R0,LS.I3P		:INDICATE LINK SNIP REASON
	J	RTDSNP			:INVALID 03 CHARACTER PAIR - SNIP LINK

:	HERE FOR TYMNET-II ZAPPER-LIKE CHARACTER PAIRS (03-01 TO 03-1F)

RTDZPR	SLLS	R4,2			:FW indexing			###wjl
	L	R1,RTDZTB,R4,		:GET DISPATCH ADDRESS		###wjl
	SRLS	R4,2			:restore character		###wjl
	AHI	R4,300			:ROUTINES EXPECT WHOLE 03-CHAR PAIR
	JR	R1			:GO HANDLE NETWORK 03-CHAR PAIR	###wjl

::	HERE FOR PERFORMANCE MONITORING CHARACTER PAIRS (03-20 TO 03-3F)
::	THESE CHARACTER PAIRS !! MUST !! BE THE FIRST IN THE LOGICAL
::	RECORD. THIS PROPERTY IS GUARANTEED BY RMAKE.
::
::	THE PERFORMANCE-MONITORING LOGIC FIRST UNCONDITIONALLY STRIPS OUT
::	THE 03-XX CHARACTER PAIR, AND RETURNS TO THE FREE-LIST ANY BUFFERLET
::	THAT MAY HAVE BEEN ALLOCATED TO STORE THE PAIR. SUBSEQUENTLY,
::	ANOTHER 03-XX CHARACTER PAIR MAY BE WRITTEN INTO THE BUFFER BY
::	A SPECIFIC ROUTINE (IE, RTDXAK).

RTDPFM	CLHI	R4,PFMMAX		:MAKE SURE THE CHAR PAIR IS IN RANGE
	JG	BADCTL			:NO, BAD CONTROL CHARACTER
	JAL	R9,RSTRIP		:POSSIBLY DEALLOCATE A BUFFERLET
	LHL	R0,BF,R2,		:GET OTHER CHANNEL NUMBER
	LR	R1,R2
	SRLS	R1,3			:TEST FOR TERMINATION
	TBT	R1,CRQEND		:IF TERMINATION, THE BIT WILL BE SET
	JNFS	RTDPF3			:TERMINATION - T-I OR INTERNAL
	SLLS	R4,2			:FW indexing			###wjl
	L	R1,PFMRTB,R4,	 	:PASSTHROUGH, GET DISPATCH ADDR	###wjl
	SRLS	R4,2			:restore character		###wjl
	JR	R1			:AND JUMP			###wjl

RTDPF3	HS	0
	IF	REBILD
	LCS	R1,2			:TERMINATION, BACK UP SEQUENCE NUMBER
	AM	R1,VSEQN,R2,
	EI	:REBILD
	SLLS	R4,2			:FW indexing			###wjl
	L	R1,PFMTRB,R4,		:GET DISPATCH ADDRESS		###wjl
	SRLS	R4,2			:restore character		###wjl
	JR	R1			:AND JUMP			###wjl

:	XLAX CHARACTER PAIR - PASSTHROUGH 

RTDXLA	SBT	R0,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE
	LHI	R1,XLAX			:PASS ON XLAX CHARACTER PAIR
	JAL	R8,WCD
	LIS	R1,3
	JAL	R8,WCD
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	XLAX CHARACTER PAIR - TERMINATION OR T-1 NEIGHBOR

RTDXL1	XHI	R2,4			:TERMINATION, GET OTHER BUFFER
	LHI	R1,XLACK		:REFLECT XLAX ACK CHAR PAIR
	JAL	R8,WCD			:PREFIX INTO BUFFER
	LIS	R1,3
	JAL	R8,WCD
	SRLS	CHN,1			:GET TRUE CHANNEL NUMBER
	SBT	CHN,BPSVCP,r7,		:OVERRIDE BACKPRESSURE
	ar	CHN,chn			:RESTORE CHN
	XHI	R2,4			:AND BUFFER NUMBER
	J	PFMOUT			:AND CONTINUE WITH TEARDOWN

:	XLACK CHARACTER PAIR - PASSTHROUGH

RTDXAK	SBT	R0,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE
	LHI	R1,XLACK		:PASS ON XLACK CHARACTER PAIR
	JAL	R8,WCD			:PREFIX INTO BUFFER
	LIS	R1,3
	JAL	R8,WCD
	J	PFMOUT			:AND CONTINUE WITH TEARDOWN

:	GENERAL TERMINATION POINT NOTES TIME OF ARRIVAL OF CHAR PAIR
RTDSNK	L	R0,FASTC,,		:GET CURRENT TIME
	STH	R4,PFMTYP		:STORE THE PERFORMANCE MONITORING CHAR
	CLHI	R4,XLACK&0FF		:XLAX ACK?			##TZ
	JNFS	RTDSNT
	ST	R0,ARRIVX		:XLAX ACK TIME
	J	PFMOUT			:DONE

:	MUST BE TIMER ACK
RTDSNT	ST	R0,ARRIVT		:RECORD TIME OF ARRIVAL TIMER ACK
	J	PFMOUT			:DONE				##TZ

:	GENERAL ALL-PASS ROUTINE SIMPLY PASSES ALL 03-XX PAIRS ALONG

RTDALL	LHI	R1,300,R4		:FORM 03-XX CHAR PAIR (2ND CHAR IN R4)
	JAL	R9,W2CI			:DEPOSIT INTO BUFFER
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	TIMER CHARACTER PAIR - TERMINATION

RTDTM1	XHI	R2,4			:HERE IF TERMINATION,FLIP TO OTHER CHAN
	LIS	R1,3
	JAL	R8,WCI			:DEPOSIT 03
	LHI	R1,TIMACK
	JAL	R8,WCI			:AND TIMER ACK CHARACTER
	XHI	R2,4			:FLIP BACK TO ORIGINAL BUFFER
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	REJECT - HERE WHEN AN UNRECOGNIZED PERFORMANCE MONITORING PAIR
:	IS RECEIVED ON A CRQ THAT TERMINATES AT THE NODE (EITHER INTERNALLY
:	OR TO A T-1 NEIGHBOR). A REJECT CHARACTER PAIR IS SENT BACK TO THE
:	ORIGINATING END
RTDREJ	LIS	R1,3			:FORM 03
	XHI	R2,4			:FLIP TO OTHER BUFFER
	JAL	R8,WCI			:DEPOSIT 03
	LHI	R1,REJECT
	JAL	R8,WCI			:AND REJECT
	XHI	R2,4			:BACK TO ORIGINAL BUFFER
	J	PFMOUT			:CONTINUE TEARDOWN

:	CONTINUE WITH TEARDOWN OF LOGICAL RECORD AFTER PROCESSING
:	A PERFORMANCE-MONITORING CHARACTER PAIR, SQFIX QUAD OR SQACK QUAD

PFMOUT	LR	LRC,LRC			:MORE DATA IN LOGICAL RECORD?
	JE	RTD1			:NO, 03-XX CHAR PAIR (OR QUAD) WAS LAST
	JG	RTD610			:CONTIN WITH RTD COPY INSTRUCT FOR CHAN
	LIS	R0,LS.S3P		:LRC NEGATIVE, SPLIT 03-CHAR PAIR
	J	RTDSNP			:SNIP THE LINK...

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDIGN:  IGNORE
::
::*********************************************************************

RTDIGN	AR	PRD,LRC			:IGNORE REST OF RECORD
	J	RTD1			:BACK TO TOP OF RTD
					:--IS THERE ANOTHER RECORD?

::*********************************************************************
::
::	HANDLE LINK CONTROL MESSAGE:
::	WE COME HERE IF HIGH ORDER BIT SET IN LOGICAL RECORD COUNT.
::	LINK CONTROL MSG FORMATS ARE:
::	80-BF	PAGE CHANGE
::	C0-DF	BACKPRESSURE RELEASE(LOW 5 BITS HAVE COUNT OF NUMBER
::		OF CHANNELS TO BE RELIEVED.  REL CHNL #'S FOLLOW IN 
::		BYTES.)
::	E0	SHRINK CMD, IF WE'RE SLAVE. REQUEST, IF WE'RE MASTER.
::	E1	SHRINK ACK (OUR SLAVE HAS SHRUNK, SO WE FOLLOW)
::	E2	apply backpressure
::	E3	release backpressure
::	NOTE--SLAVE DOES THE SHRINK BEFORE THE MASTER.
::	OTHER MSG'S UNKNOWN--SNIP THE LINK.
::
::*********************************************************************

RTDPRI	SIS	PRC,1			:DECREMENT PHYSICAL RECORD COUNT
	SIS	PRD,1			:BACK UP PRD SINCE 'RTD1' ASSUMED
					: LOGICAL RECORD HEADER LENGTH 2
	THI	LRC,40			:LRC CONTAINS CMD BYTE,
					: TEST FOR PAGE CHANGE
	JNFS	RTDP1			:NO
	NHI	LRC,3F			:PAGE CHANGE - ISOLATE NEW PAGE (BANK)
	STB	LRC,RTPAGE,KN,KN	: AND SAVE
	J	RTD1
RTDP1	THI	LRC,20			:TEST FOR BACKPRESSURE RELEASE
	JN	RTDP3			:NO
	NHI	LRC,1F			:BACKPRESSURE REC, ISOLATE LOGICAL REC
:	COUNT AND ADJUST PHYSICAL RECORD COUNT ACCORDINGLY
	SR	PRC,LRC
	LH	R0,RTPAGE,KN,KN		:GET CURRENT PAGE NUMBER. NOTE THAT
:	PAGE NUMBER IS LOADED INTO HI-ORDER BYTE OF HALFWORD.

:	COMPUTE MAXIMUM CHANNEL NUMBER FOR THIS LINK
	LHL	R8,EBDPKN,KN,KN		:GET END OF TABLES ADDRESS AND
	SR	R8,R6			: SUBTRACT BEGIN ADDRESS
	SRLS	R8,1			:NUMBER OF CHANNELS THIS LINK
RTDP2	SIS	LRC,1			:COUNTER OF # CHNLS TO RELIEVE
	JL	RTD1			:DONE WITH BACKPRESSURE LOGICAL RECORD
	LB	R1,0,PRD		:GET NEXT BYTE FROM RECORD
	AIS	PRD,1			:INC TO READ NEXT CHANNEL # NEXT PASS
	STBR	R1,R0			:COMBINE PAGE NUMBER WITH RELATIVE
:	CHANNEL TO GET LINK'S ABSOLUTE CHANNEL NUMBER
	CR	R0,R8			:RANGE CHECK CHANNEL NUMBER
	JLFS	RTDP2A			:CHN # OK--SET BITS IN BIT ARRAYS
:	BACKPRESSURE RELIEVED FOR CHANNEL OUT OF OUR RANGE.
	LIS	R0,LS.BPC
	J	RTDSNP			:CHANNEL NUMBER OUT OF RANGE, SNIP LINK

RTDP2A	SBT	R0,LNKBPV,R7,		:INDICATE BACKPRESSURE RECEIVED...
	LIS	R1,3			:YES , GET CIRCUIT SPEED BITS
	LR	R3,R0
	AR	R3,R3			:get 2* chn #
	NH	R1,NIOTAB,R6,R3		: FROM PERMUTER TABLE ENTRY
	LHL	R1,CIRSPK,R1,R1		:GET APPROPRIATE COUNT
	STH	R1,BPSCNT,R6,R3		:AND UPDATE COUNT FOR THIS CHANNEL
	J	RTDP2			:LOOP TO SERVICE REST OF CHANNELS

RTDP3	NHI	LRC,1F			:LINK MESSAGE
	JE	RTDP4			:SHRINK COMMAND OR REQUEST
       if	aplybp			:look for e2 & e3
	clhi	lrc,2			:apply bp?
	je	rtdp5
	clhi	lrc,3			:release bp?
	je	rtdp6
       ei	:aplybp
	SIS	LRC,1			:TEST FOR SHRINK ACKNOWLEDGE
	JEFS	RTDP3A			:YES
	LIS	R0,LS.UCR		:NO - UNKNOWN CONTROL RECORD RECEIVED
	J	RTDSNP			:SNIP LINK

RTDP3A	LIS	R0,0			:SLAVE ACKED SHRINK, NOW OUR TURN
	STB	R0,SHSTAT,KD		:THAW RMAKE
	jal	r8,shrk00		:and do the shrink
	j	rtdp4c			:some error, snip link
	j	rtdxit			:finished

:	GOT SHRINK COMMAND (OR REQUEST, IF NEIGHBOR IS SLAVE)
RTDP4	LHL	R0,NCHN,KD		:SHOULD WE EVEN CONSIDER SHRINK?
	CLHI	R0,80			:NEED MORE THAN 1/2 PAGE TO SHRINK
	JGFS	RTDP4A			:GOT IT
rtdp4c	LIS	R0,LS.SNC		:UNREASONABLE SHRINK REQUEST IF ONLY
	J	RTDSNP			: 80 CHANS ALLOCATED - SNIP THE LINK

RTDP4A	LH	R0,NEDOUT,KD		:ANY NEEDLES OUTSTANDING FOR THIS LINK?
	JN	RTDP4D			:YES, DEFER SHRINK
					: UNTIL NEEDLES PROCESSED BY RMAKE
	STB	R0,NEDSUS,KD		:CLEAR SHRINK SUSPENDED INDICATION
	jal	r8,shrink		:do the shrink
	j	rtdp4c			:some error, snip link
	j	rtdxit			:finished


::	WE RECEIVED SHRINK COMMAND/REQUEST FROM NEIGHBOR, BUT NEEDLES
:: FROM CRQ HAVE NOT YET BEEN PROCESSED BY RMAKE. WE MUST WAIT UNTIL
:: RMAKE PROCESSES ALL NEEDLES OUTSTANDING BEFORE SHRINKING LINK SO
:: THAT NEIGHBOR'S PERMUTER TABLES WILL MATCH OURS. WE STORE A NON-ZERO
:: VALUE IN 'NEDSUS' TO INDICATE SHRINK SUSPENDED UNTIL OUTSTANDING
:: NEEDLES PROCESSED BY RMAKE, AND EXIT RTD WITHOUT INCREMENTING 'LRT'
:: SO THAT WHEN RMAKE DRAINS OUTSTANDING NEEDLES it will then know
:: to call shrink.

RTDP4D	lis	r0,1
	STB	R0,NEDSUS,KD	:NON-ZERO VALUE INDICATES SHRINK SUSPENDED
	J	rtdxit	


:	RTDP5	handle the apply bp msg.  Toss if no forward going chn as
:		that means zap is in somewhere waiting to be xmitted.
:		reduce bpscnt to 10 (in case gobbler is in buffer) and
:		reset abpvcp to indicate bped
: Note that page number is loaded into hi-order byte of R0
       if	aplybp
rtdp5	tbt	kn,vactbp		:is this a legal msg?
	jnfs	rtdp51
	lhi	r0,ls.pr2		:snip link
	j	rtdsnp
rtdp51	lb	lrc,0,prd		:get len
	ais	prd,1			:point to chn number
	sr	prc,lrc			:count this record as processed
	sis	prc,1
	LH	R0,RTPAGE,KN,KN		:GET CURRENT PAGE NUMBER.
:	COMPUTE MAXIMUM CHANNEL NUMBER FOR THIS LINK
	LHL	R8,EBDPKN,KN,KN		:GET END OF TABLES ADDRESS AND
	SR	R8,R6			: SUBTRACT BEGIN ADDRESS
	SRLS	R8,1			:NUMBER OF CHANNELS THIS LINK
RTDP52	SIS	LRC,1			:COUNTER OF # CHNLS TO RELIEVE
	JL	RTD1			:DONE WITH BACKPRESSURE LOGICAL RECORD
	LB	R1,0,PRD		:GET NEXT BYTE FROM RECORD
	AIS	PRD,1			:INC TO READ NEXT CHANNEL # NEXT PASS
	STBR	R1,R0			:COMBINE PAGE NUMBER WITH RELATIVE
:	CHANNEL TO GET LINK'S ABSOLUTE CHANNEL NUMBER
	CR	R0,R8			:RANGE CHECK CHANNEL NUMBER
	JLFS	RTDP54			:CHN # OK--SET BITS IN BIT ARRAYS
:	BACKPRESSURE RELIEVED FOR CHANNEL OUT OF OUR RANGE.
	LHI	R0,LS.BPA
	J	RTDSNP			:CHANNEL NUMBER OUT OF RANGE, SNIP LINK

RTDP54	LR	R3,R0
	AR	R3,R3			:get 2* chn #
	LH	R1,NIOTAB,R6,R3		: get buffer number
	nhi	r1,-4
	lh	r1,bf,r1,		:is there an ongoing circuit?	
	je	rtdp52			:no, don't bp a zapper
	RBT	R0,abpvcp,R7,		:INDICATE BACKPRESSURE applied
	lhi	r1,10			:if gobbler in buff let it pass
	STH	R1,BPSCNT,R6,R3		:AND UPDATE COUNT FOR THIS CHANNEL
	J	RTDP52			:LOOP TO SERVICE REST OF CHANNELS
       ei	:aplybp

:	RTDP6	handle the release bp msg.  Set abpvcp as bp is released
:		and set lnkbpv and bpscnt.
: Note that page number is loaded into hi-order byte of R0
       if	aplybp
rtdp6	tbt	kn,vactbp		:is this a legal msg?
	jnfs	rtdp61
	lhi	r0,ls.pr3		:snip link
	j	rtdsnp

rtdp61	lb	lrc,0,prd		:get len
	ais	prd,1			:point to chn number
	sr	prc,lrc			:count this record as processed
	sis	prc,1
	LH	R0,RTPAGE,KN,KN		:GET CURRENT PAGE NUMBER.
:	COMPUTE MAXIMUM CHANNEL NUMBER FOR THIS LINK
	LHL	R8,EBDPKN,KN,KN		:GET END OF TABLES ADDRESS AND
	SR	R8,R6			: SUBTRACT BEGIN ADDRESS
	SRLS	R8,1			:NUMBER OF CHANNELS THIS LINK
rtdp62	SIS	LRC,1			:COUNTER OF # CHNLS TO RELIEVE
	JL	RTD1			:DONE WITH BACKPRESSURE LOGICAL RECORD
	LB	R1,0,PRD		:GET NEXT BYTE FROM RECORD
	AIS	PRD,1			:INC TO READ NEXT CHANNEL # NEXT PASS
	STBR	R1,R0			:COMBINE PAGE NUMBER WITH RELATIVE
:	CHANNEL TO GET LINK'S ABSOLUTE CHANNEL NUMBER
	CR	R0,R8			:RANGE CHECK CHANNEL NUMBER
	JLFS	rtdp64			:CHN # OK--SET BITS IN BIT ARRAYS
:	BACKPRESSURE RELIEVED FOR CHANNEL OUT OF OUR RANGE.
	LHI	R0,LS.BPR
	J	RTDSNP			:CHANNEL NUMBER OUT OF RANGE, SNIP LINK

rtdp64	SBT	R0,abpvcp,R7,		:INDICATE BACKPRESSURE released
	SBT	R0,LNKBPV,R7,		:INDICATE okay to send
	RBT	R0,XGUSH,R7,		:it has had bp restored
	LIS	R1,3			:YES , GET CIRCUIT SPEED BITS
	LR	R3,R0
	AR	R3,R3			:get 2* chn #
	NH	R1,NIOTAB,R6,R3		: FROM PERMUTER TABLE ENTRY
	LHL	R1,CIRSPK,R1,R1		:GET APPROPRIATE COUNT
	STH	R1,BPSCNT,R6,R3		:AND UPDATE COUNT FOR THIS CHANNEL
	j	rtdp62
       ei	:aplybp

	SUBTTL	YAKYAK (RTD - ZAPPERS, GOBBLERS, NEEDLES, T-I SUP RECS)

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDNGZ:  NON-GOBBLING ZAPPER (0303)
::	FUNCTION:		TEAR DOWN CIRCUIT BUT DON'T CLEAR BUFFER
::
::*********************************************************************

:	MICROCODE HAS INCREMENTED 'BE' (R3) SO THAT NEXT BYTE SHOULD
: BE STORED WHERE R3 CURRENTLY POINTS. THIS ONLY MATTERS FOR NON-GOBBLING
: ZAPPERS SINCE OTHERS WILL CLEAR BUFFER BEFORE DEPOSITING ZAPPER CHARACTER
: PAIR.

RTDNGZ	ST	R3,BE,R2,		:SAVE CURRENT BE, POINTS TO SLOT FOR 03
	LIS	R1,3			:STORE 1ST BYTE OF NON-GOBBLING ZAPPER
	STB	R1,0,R3			: R3 ALREADY INCREMENTED
     if		t2gate
	lis	r0,aalr03
	sth	r0,aareas
     ei
	JAL	R9,ZAPXNG,,		:ZAP WITHOUT CLEARING BUFFER
	J	RTDZP2			: AHEAD OF IT

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDZPH:  HARD ZAPPER (0301)
::	FUNCTION: TEAR DOWN CIRCUIT, CLEAR BUFFER, DON'T ATTEMPT REBUILD
::		IF A HARD ZAPPER IS RECEIVED, THE CIRCUIT IS NOT REBUILDABLE.
::		THEREFORE IT IS QUITE PERMISSIBLE TO CLEAR OUT THE NEEDLE
::		TO AVOID THE OVERHEAD OF REQUESTING REBUILD FOR THESE CIRCUITS.
::
::*********************************************************************

RTDZPH	JAL	R9,RSTRIP		:UNCONDITIONALLY STRIP OUT NEW BUFFERLT
	IF	T2GATE
	LHL	R0,BF,R2,		:find destination chan numb
	CLHI	R0,DISZFL
	JL	GTZ006
	CLHI	R0,DISZFL+NDP		:If dispatcher, then account reason
	JGE	GTZ006
	AHI	R0,-DISZFL		:Get relativie port
	TBT	R0,GDSTPT		:and if we are a destination
	JEFS	GTZ002			:we will do accounting
	LHI	R0,AALR03
	JFS	GTZ004
GTZ002	LIS	R0,0
GTZ004	STH	R0,AAREAS		:Otherwise no accounting
GTZ006	EI	:T2GATE
	JAL	R9,ZAPHRD,,		:HARD-ZAP THE CIRCUIT
RTDZP2	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT ZAPPER PASSED
	J	RTDIGN

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDNAC:  NEEDLE POINT ON ASSIGNED CHANNEL
::	FUNCTION:	HARD-ZAP IN BOTH DIRECTIONS
::
::*********************************************************************

RTDNAC	JAL	R9,RSTRIP		:UNCONDITIONALLY STRIP OUT NEW BUFFERLT
	JAL	R9,ZAPHRD,,		:NEEDLE ON ASSIGNED CHANNEL
	JAL	R8,GFCBUF		:ZAP CIRCUIT IN BOTH DIRECTIONS
	SKIPAD(RTDOOB)			:immed. return - out of buffers!###wjl
	SRHLS	CHN,1			:+4 return - got a buffer	###wjl
	AH	CHN,LKZFKN,KN,KN
	JAL	R9,CRQHCR,,
	XHI	R2,4
	LHI	R1,ZAPPH
	EXBR	R1,R1
	JAL	R8,WCI
	EXBR	R1,R1
	JAL	R8,WCI
	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LR	R0,CHN
	SH	R0,LKZFKN,KN,KN		:GET BACK RELATIVE CHAN FOR THIS LINK
	LHL	R8,NDID,KD		:NEIGHBOR#
	STH	R8,CRYSBF+2		:SAVE FOR CRYPTO
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM FOR NEEDLE ON
	HC	CRYE29			: ASSIGNED CHANNEL
	J	RTDIGN

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDZPS:  SOFT ZAPPER (0302)
::	FUNCTION:		HANDLE SOFT ZAPPER ON TYMNET-II CHANNEL
::
::*********************************************************************

RTDZPS	ST	R10,RTMT1		:SOFT ZAPPER
	ST	R3,BE,R2,		:SAVE CURRENT BE, POINTS TO SLOT FOR 03
	IF	REBILD
	LCS	R0,2			:BACK UP RECEIVE SEQUENCE NUMBER
	AM	R0,VSEQN,R2,		: - ZAPPERS ARE NOT COUNTED
	EI	:REBILD
	LR	R1,R4
       if	t2gate
	lis	r0,aalr03
	sth	r0,aareas
       ei
	JAL	R10,TRCIRC,,		:TEAR DOWN CIR, MABYE REQUEST REBUILD
       if	acct
	lis	r0,0
	sth	r0,aareas
       ei
	L	R10,RTMT1
	J	RTDZP2			:GO DECREMENT ACTIVE CHANS, SAVE TIME

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDGOB:  GOBBLER (0308)
::	FUNCTION:		CLEAR BUFFER AND PASS GOBBLER ALONG
::
::*********************************************************************

RTDGOB	JAL	R9,RSTRIP		:UNCONDITIONALLY STRIP OUT NEW BUFFERLT
	JAL	R9,GOBBLN,,		:GOBBLER
	J	RTDTY1

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDFGB:  FAT GOBBLER (0309)
::	FUNCTION:  6-WORD NETWORK CONTROL, THE FULLWORD FOLLOWING
::	THE 03-XX CONTAINS THE NEW SEQUENCE NUMBER.
::	CLEAR BUFFER EXCEPT FOR NEEDLES AND SEQUENCE FIXES.
::	IF PASSTHRU, PASS FAT GOBBLER ON.
::	IF TERMINATION, SHRINK FAT GOBBLER INTO SKINNY ONE AND ADJUST THE
::	VSEQN ACCORDING TO THE FW OF DATA.
::
::*********************************************************************

RTDFGB	JAL	R9,RSTRIP		:UNCONDITIONALLY STRIP OUT NEW BUFFERLT
	LHL	R8,BCT,R2,		:IS BUFFER EMPTY?
	JE	RTFGB1			:YES, DON'T CHECK FOR NEEDLES/SQFIX
	JAL	R8,PCIS			:CHECK BUFFER FOR NEEDLES & SQFIX
	SIS	R1,3			:03-CHARACTER PAIR?
	JN	RTFGB1			:NO
	JAL	R8,PCI			:YES - CHECK NEXT BYTE

       IF	LOGII			:handle LOG II needles		###sdw
	CLHI	R1,NEEDHD&0FF		:LOG 2 Needle Head		###sdw
	JE	RTFGB2			:YES - DON'T GOBBLE		###GT
	CLHI	R1,NEEDBD&0FF		:LOG 2 Needle body (what is written
					: in buff until rest of logii arrives
	JEFS	RTFGB2			:YES - DON'T GOBBLE		###GT
        CLHI    R1,NEEDCV&0FF           :converted LOG II needle for DISPI
	JEfs	RTFGB2			:YES - don't Gobble data
       EI	:LOGII
	CLHI	R1,NEEDP&0FF		:NEEDLE POINT?			###GT
	JEFS	RTFGB2			:YES - DON'T GOBBLE		###GT
	CLHI	R1,SQFIX&0FF		:SEQUENCE FIX?			###GT
	JEFS	RTFGB2			:YES - DON'T GOBBLE		###GT
RTFGB1	JAL	R8,CBCLR		:UNCONDITIONALLY CLEAR OUT THE BUFFER
RTFGB2	LHL	R3,BF,R2,		:GET THE ONGOING CHANNEL NUMBER
	JAL	R9,CHKTRM		:CHECK FOR TERMINATION
	SKIPAD(RTPFGB)			:IMMED, PASSTHRU, PASS GOBBLER ALONG
	JAL	R9,GOBBLN,,		:+4, TERMINATION - WRITE IN A GOBBLER
	IF	REBILD
	AHI	R4,2,LRC		:FORM THE NEW SEQUENCE NUMBER	###GT
	ST	R4,VSEQN,R2,		:(R4 SET UP IN CHKTRM)		###GT
	EI	:REBILD
	J	PFMOUT			:AND PROCEED WITH RECORD TEARDOWN

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDSQK:  SEQUENCE NUMBER ACK (030C)
::	FUNCTION:	SENT BY FAR END IN RESPONSE TO A
::	SQFIX CHARACTER PAIR. SIMPLY PASSES ALONG QUAD IF A PASSTHRU, ELSE
::	PRUNES HISTORY BUFFER ON BASIS OF HW SEQUENCE NUMBER FOLLOWING
::	THE CHARACTER PAIR.
::	EXPECTS R2 = BUFFER NUMBER, R3 = SLOT FOR '03' CHARACTER
::
::*********************************************************************

RTDSQK	JAL	R9,RSTRIP		:POSSIBLY DE-ALLOCATE
					: A NEWLY-ACQUIRED B'LET
	JAL	R9,CHKTRM		:DECIDE - TERMINATION OR PASSTHRU?
	SKIPAD(RTKSQP)			:IMMED, PASSTHRU - JUST PASS QUAD ALONG
	IF	REBILD
	TBT	R1,CRQBSY		:IS REBUILD ENABLED FOR THIS CHANNEL?
	JE	PFMOUT			:NO, MUST HAVE BEEN TURNED OFF IN RMAKE
	SBT	R1,SQFIXV		:NOTE REBUILD QUAD RECEIVED
					: (R1 SETU IN CHKTRM)
	LCS	R0,6			:BACK UP VSEQN BY 6, SQACKS DON'T COUNT
	AM	R0,VSEQN,R2,		:VSEQN WAS ADVANCED BY 'LRC' AT RDT15
	SLLS	R1,2			:GET HISTORY BUFFER NUMBER
	LHL	R0,REBDIS,,		:DISPLAY THIS ACTIVITY?
	JE	RTDSQY			:NO
	L	R0,HBSEQN,R1,		:GET CURRENT HISTORY BUFFER SEQ#
	ST	R0,CRYSBF
	LR	R3,R4			:PRESERVE R4
	NHI	R3,0FFFF		:MASK OUT HO HW
	LHL	R0,BF,R2,		:GET DESTINATION CHANNEL
	EXHR	R0,R0
	OR	R0,R3			:COMBINE WITH DATA
	JAL	R8,CRYPTO,,		:AND REPORT
	HC	CRYE66
RTDSQY	S	R4,HBSEQN,R1,		:GET NUMBER OF CHARACTERS OUTSTANDING
	JLE	PFMOUT			:NO PRUNING POSSIBLE HERE
					: - CONTINUE TEARDOWN
	STH	R2,BUFSAV		:save original buffer index
	LI	R2,HBUFN,R1		:form the associated history buffer #
	LR	R0,R4			:tell routine how many to remove
	JAL	R8,RTBFTS		:return all R4 number of chars
	AM	R0,HSEQN,R2,		:R0 gets number of chars returned
	LHL	R2,BUFSAV		:RESTORE ORIGINAL BUFFER INDEX
	EI	:REBILD
	J	PFMOUT			:CONTIUE TEARDOWN

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDSQF:  SEQUENCE NUMBER FIX (030B)
::	FUNCTION:	IF NOT TERMINATION, JUST PASS ON
::	6-WORD NETWORK CONTROL. OTHERWISE TEST FOR SEQUENCE NUMBERS EQUAL.
::	EXPECTS R4 TO CONTAIN THE SQFIX DATA WORD.
::
::*********************************************************************

RTDSQF	JAL	R9,RSTRIP		:POSSIBLY DE-ALLOCATE
					: NEWLY-ACQUIRED B'LET
	JAL	R9,CHKTRM		:SEE IF PASSTHRU OR TERMINATION
	SKIPAD(RTDSQP)			:IMMED, PASSTHRU		###wjl
					: - SIMPLY MOVE THE NETWORK QUAD ALONG
	IF	REBILD
	LR	R4,R4			:SEQ NO. RETURNED IN R4		###GT
	JGEFS	RTDSQ1			:NOT -1				###GT
	JAL	R9,RBCOUT,,		:SEQN=-1 IS A NAK, DISABLE REBUILD#GT
	J 	PFMOUT			:CONTINUE WITH RECORD TEARDOWN
RTDSQ1	SBT	R1,SQFIXV		:NOTE SQF QUAD RECEIVED
					: (R1 SET UP IN CHKTRM)
	LR	R4,R4			:CHECK SEQN NO. AGAIN		###GT
	JNFS	RTDSQ3			:CONTINUE IF NE 0		###GT
	J 	RTDSQ2			:SQFIX 0 IS A SPECIAL CASE - DON'T
					:FIX UP SEQUENCE NUMBERS
RTDSQ3	LHL	R9,BF,R2,
	CLHI	R9,CRQZFL		:STUB, INTERCEPT, NEW CIRCUIT?
	JLE	RTDSQ2			:YES, IGNORE SQF, CRQ NOT FINISHED###CY
	LR	R9,R1			:SAVE REBUILD BUFFER BIT ARRAY INDEX
	LHI	R1,SQACK		:BOUNCE BACK SEQUENCE # WITH A SQACK
	XHI	R2,4			:THE OTHER BUFFER
	JAL	R9,W2CI
	LR	R1,R4			:SEQUENCE NUMBER (R4 SET UP IN CHKTRM)
	EXHR	R1,R1			:UPPER HW OF SEQUENCE NUMBER	###GT
	JAL	R9,W2CI			: (UPPER HW)
	EXHR	R1,R1			:LOWER HW OF SEQUENCE NUMBER	###GT
	JAL	R9,W2CI
	XHI	R2,4			:BACK TO THIS BUFFER
	LR	R0,R4			:VERIFY VSEQN INTEGRITY, R4 CONTAINS
	S	R0,VSEQN,R2,		:OLD VSEQN,PRIOR TO RTD15 UPDATE BY LRC
	AI	R0,6,LRC		:LRC HAS ALREADY BEEN REDUCED BY 6###GT
	JE	RTDSQ2			:OK, REBUILD STILL IN SYNC FOR THIS CRQ

	AM	R0,VSEQN,R2,		:ERROR,
					: PRESUME MOST RECENT SQFIX IS CORRECT
	NI	R0,0FFFF		:STRIP POSSIBLE SIGN EXTENSION
	STH	R0,SUPMBF+4		:STORE AWAY THE ERROR COUNT
	STH	R2,SUPMBF+2		:AND THE BUFFER NUMBER
	LHI	R1,NR.SQF		:MESSAGE TYPE - SQFIX ERROR
	STH	R1,SUPMBF
	STM	R0,TRREGS		:PRESERVE REGISTERS THROUGH SUP12 CALL
	JAL	R10,SUP12,,
	LM	R0,TRREGS
	LHL	R1,BF,R2,		:GET DESTINATION CHANNEL,
	EXHR	R0,R0			: ALIGN SQF DIFFERENCE IN UPPER R0,
	OR	R0,R1			: AND COMBINE
	JAL	R8,CRYPTO,,		:ADVISE XRAY - SQF ERROR
	HC	CRYE63

RTDSQ2	LCS	R0,6			:REDUCE VSEQN BY 6
					: SINCE SQFIX'S DON'T COUNT
	AM	R0,VSEQN,R2,
	LHL	R0,REBDIS,,		:DISPLAY SQF ACTIVITY?
	JE	PFMOUT			:NO, CONTINUE WITH LOGICAL REC TEARDOWN
	ST	R4,CRYSBF		:SAVE FOR XRAY (DISPLAY SQF # RECVD)
	LHL	R0,BF,R2,
	EXHR	R0,R0			:NOW GET CHANNELS FOR DISPLAY
	XHI	R2,4
	OH	R0,BF,R2,
	XHI	R2,4
	JAL	R8,CRYPTO,,
	HC	CRYE65
	EI	:REBILD
	J	PFMOUT			:CONTINUE WITH LOGICAL RECORD TEARDOWN

:	RTDSQP:
:	RTPFGB:
:	RTKSQP:
:	PASS SQACK, FAT GOBBLER OR SQFIX ALONG.  R4 = HW OF DATA

RTPFGB	LHL	R3,BF,R2,		:GET THE ONGOING CHANNEL NUMBER
	JAL	R8,SPEED,,		:SPEED THINGS UP, CLEAR BACKPRESSURE
	LHI	R1,GOBBF		:ENTRY POINT FROM RTDFGB
	JFS	RTDSQZ
RTKSQP	LHI	R1,SQACK		:ENTRY POINT FROM RTDSQK - SET UP R1
	JFS	RTDSQZ
RTDSQP	LHI	R1,SQFIX		:ENTRY POINT FROM RTDSQF - SET UP R1
RTDSQZ	JAL	R9,W2CI		:SQF OR SQFIX PASS-THROUGH	###LH
	LR	R1,R4			:SQACK OR SQFIX DATA
	EXHR	R1,R1			:UPPER HW			###GT
	JAL	R9,W2CI		:				###LH
	EXHR	R1,R1			:LOWER HW			###GT
	JAL	R9,W2CI		:			###LH	###GT
	J	PFMOUT

::*********************************************************************
::
::	SUBROUTINE:	RSTRIP:
::	FUNCTION:	RSTRIP returns to free pool bufferlets that may
::	have been allocated by the RTD microcode in response to some 03
::	character pair that is	not to be written into the circuit buffer
::	(i.e. seq number acks).
::
::	This routine is necessary because the RTD microcode instruction
::	exits to allocate a new bufferlet before it exits for an 03-XX
::	character pair. Thus, an 03-XX char pair may trigger a bufferlet
::	allocation even though it may not actually be written into the 
::	bufferlet.
::
::	CALLING SEQ:	JAL  R9,RSTRIP
::	INPUT:		R2 = Buffer Number
::			R3 = Working 'BE'
::	DESTROYED:	R0,R3,R8
::	CALLS:		JAL  R8,CBCLR,,
::			JAL  R7,NEGBCR
::			JAL  R7,NEGHCR
::	RETURNS:	JR  R9
::
::*********************************************************************

RSTRIP	CL	R3,BB,R2,		:HAS 1ST BUFFERLET JUST BEEN ALLOCATED?
	JNFS	RSTRI1			:NOT FIRST BUFFERLET
	JAL	R8,CBCLR		:WE'RE NOT GOING TO USE BUFFRLT,DISCARD
	JR	R9			:RETURN
RSTRI1	LR	R0,R3			:IF RUNNING 'BE' IS
	NHI	R0,CBSZ-1		: EQUAL TO pointer size MOD 10,
	SIS	R0,cbptsz		: THEN WE'VE JUST ACQUIRED NEW BUFFERLT
	JGR	R9			:NO, GO AWAY
:	SPLICE NEW BUFFERLET BACK INTO FREE LIST, AND DECREMENT
:	BUFFER COUNTS
	LHL	R0,FREELT
	STH	R0,CBSZ-cbptsz,R3	:THIS BUFFERLET NOW 1ST IN LINKED LIST
	SRLS	R3,CBSZL		:BUFFERLET INDEX
	STH	R3,FREELT		:FREE LIST ==> BUFFRLT WE'RE DISCARDING
	LHI	R0,cbptsz-CBSZ		:less bufferlets in use
	AHM	R0,BCT,R2,		:DON'T COUNT THIS BUFFERLET
	AM	R0,BFLTSV
	JGEFS	RSTRI9			:CHECK FOR BFLTSV GOING <0	###OAS
	JAL	R7,NEGBCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RSTRI9	HS	0
	IF	REBILD
	CI	R2,HBUFN		:IS R2 A HISTORY BUFFER INDEX	###OAS
	JLFS	RSTRI2			:				###OAS
	AM	R0,HBFTSV		:YES, UPDATE HISTORY BUFFER COUNT##OAS
	JGEFS	RSTRI2			:CHECK FOR HBFTSV GOING <0	###OAS
	JAL	R7,NEGHCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RSTRI2	EI	:REBILD

	JR	R9			:DONE

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDZPF:	 FAT ZAPPER (0304)
::	FUNCTION:	6-BYTE NETWORK CONTROL, SOFT ZAPPER FOLLOWED BY
::	OFFENDING NODE PAIR WHOSE LINK FAILED AND CAUSED ALL THIS...
::
::*********************************************************************

RTDZPF	ST	R10,RTMT1		:PRESERVE R10 (PRC)
	JAL	R9,RSTRIP		:FREE UP ANY NEWLY-ACQUIRED BUFFERLET
	IF	REBILD
	LCS	R0,6
	AM	R0,VSEQN,R2,		:BACK UP SEQUENCE #, DON'T COUNT ZAPPER
	EI	:REBILD			:###GT
	LR	R1,R4			:TRCIRC EXPECTS RELEVANT ZAPPER IN R1
       if	t2gate
	lis	r0,aalr03
	sth	r0,aareas
       ei
	JAL	R10,TRCRFT,,		:TEAR DOWN CIRC, CHECK FOR TERMINATION
       if	t2gate
	lis	r0,0
	sth	r0,aareas
       ei
	L	R10,RTMT1
	LCS	R0,1
	AHM	R0,ANCHN,KD		:ONE LESS CHANNEL THIS LINK
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT ZAPPER PASSED
	LH	R0,TRCSV2		:DEPOSIT 'FAT' IN BUFFER?
	JL	RTFZ10			:NO, REBUILD REQUEST MADE
	LH	R0,BF,R2,		:WAS BUFFER RETURNED		###CY
	JL	RTFZ10			:DON'T WRITE INTO IT IF SO	###CY
	LB	R4,0,PRD
	LB	R1,1,PRD		:GET NEXT TWO BYTES
	EXBR	R4,R4
	OR	R1,R4			:FIRST NODE NUMBER FOLLOWING FAT ZAPPER
	JAL	R9,W2CI
	LB	R4,2,PRD
	LB	R1,3,PRD
	EXBR	R4,R4
	OR	R1,R4			:SECOND NODE # FOLLOWING FAT ZAPPER
	JAL	R9,W2CI
RTFZ10	AIS	PRD,4			:ADJUST RECORD POINTER PAST 'FAT'
	J	RTD1

:	HERE FOR DATA ON AN UNASSIGNED CHANNEL
:	TEST FOR CHARACTER TRACING FOR chn 0 (wanting needle tracing)
RTDUAC	Lis	R1,0			:DESTINATION ABSOLUTE CHANNEL NUMBER
	TBT	R1,TRCHAN,,		:TRACING DESIRED?
	JEFS	RTDua0			:NO
:	TRACING FOR THIS CHANNEL. R9 SHOULD POINT TO BEGINNING OF LOGICAL
:	RECORD, R0=-2 INDICATES RECORDING DATA INTO NODE...
	LR	R9,PRD			:POINT TO FIRST BYTE OF DATA
	LCS	R0,2			: -2 =>INPUT
	JAL	R8,CHRTRC		:MAKE TRACE ENTRY FOR THIS LOGICAL REC

rtdua0	LB	R0,0,PRD		:T-II - IS IT A NEEDLE?
	EXBR	R0,R0
	LB	R1,1,PRD
	AR	R1,R0
       IF	LOGII			:handle LOG II needles		###sdw
	CLHI	R1,NEEDHD		:LOG 2 Needle Head		###sdw
	JE	RTDNHD
       EI	:LOGII
	CLHI	R1,NEEDP
	JN	RTDUA2			:NOT A NEEDLE - REPORT AND TOSS

:	HERE WHEN A NEEDLE ARRIVES ON AN UNASSIGNED CHANNEL
RTDUAN	LIS	R0,1
	AHM	R0,ANCHN,KD		:INCREMENT NUMBER OF ACTIVE CHANNELS
RTDUA1	JAL	R8,GFCBUF		:SAVE DATA FOR CRQ
	SKIPAD(RTDOOB)			:immed. return - out of buffers!###wjl
	SRHLS	CHN,1			:+4 return, ok - COMPUTE ABSOLUTE CHN #
       if	aplybp			:set xmit bp type
	tbt	kn,vactbp		:apply/release logic on the link?
	jefs	rtdua3			:nope
	sbt	chn,abpvcp,r7,		:start off with bp released
       ei	:aplybp
rtdua3	AH	CHN,LKZFKN,KN,KN
	JAL	R9,CRQHCR,,		:BUILD 'HALF CIRCUIT'
	SH	CHN,LKZFKN,KN,KN
	SLHLS	CHN,1
	LHI	R0,CIRSP0		:GIVE IT SOME TRANSMIT CAPACITY
	STH	R0,BPSCNT,R6,CHN

	LR	R1,R2
	SRLS	R1,1			:SET UP BUFTIM INDEX
	L	R0,FASTC,,
	ST	R0,BUFTIM,R1,		:TIME THAT NEEDLE ORIGINATES IN NODE

	JAL	R9,CRQALT,,		:ALERT CRQ OF NEEDLE AND...
	LHI	R1,NEEDP		:INSERT NEEDLE POINT INTO BUFFER
	JAL	R9,W2CI
	AIS	PRD,2			:ADVANCE PRD PAST THE NEEDLE POINT
	LB	R0,0,PRD		:GET LENGTH ESCAPE		###GT
	EXBR	R0,R0			:				###GT
	LB	R1,1,PRD		:LENGTH OF NEEDLE		###GT
	LR	R4,R1			:SAVE TEMPORARILY		###GT
	AR	R1,R0			:				###GT
	JAL	R9,W2CI			:INSERT INTO BUFFER		###GT
	AIS	PRD,2			:ADVANCE PRD PAST 2 BYTES	###GT
	SIS	R4,4			:NEEDLE LENGTH - 4		###GT
	SIS	LRC,4			:DECR LRC TO ACCOUNT FOR NEEDLE+COUNT
RTDU10	LB	R1,0,PRD		:GET A BYTE			###GT
	JAL	R8,WCI		:WRITE INTO BUFFER		###GT
	AIS	PRD,1			:ADVANCE PRD PAST THIS BYTE	###GT
	SIS	LRC,1			:DECREMENT LRC TO ACCOUNT FOR BYTE#GT
	SIS	R4,1			:COPY OVER THE WHOLE NEEDLE	###GT
	JGBS	RTDU10
	
	JAL	R8,PCIS		:SKIP OVER NEEDLE POINT		###GT
	JAL	R8,PCI
	JAL	R8,PCI		:JUMP OVER ESCAPED LENGTH	###GT
	JAL	R8,PCI
	JAL	R8,PCI		:SKIP OVER LINK COUNT		###GT
	JAL	R8,PCI
	LIS	R5,5			:5 HALF-WORDS TO SKIP OVER	###GT
RTDU11	JAL	R9,PHWI			:SKIP OVER INVOICE #,FLAGS	###GT
	SIS	R5,1			:REQUESTING NODE AND PORT#	###GT
	JGBS	RTDU11
RTDU12	JAL	R9,PHWI			:SKIP OVER 'CREAMED' NODE #'S	###GT
	CI	R1,0FFFF		:= -1?				###GT
	JEBS	RTDU12
	TI	R1,8000			:ARE WE THE TERMINATION NODE?	###GT
	JEFS	RTDU13			:NO - CARRY ON			###GT
	LR	R4,R2			:YES - SET BIT FOR TERMINATION	###GT
	SRHLS	R4,3
	SBT	R4,CRQEND
RTDU13	LR	LRC,LRC			:ANY DATA LEFT TO COPY?		###GT
	JE	RTD1			:NO, DONE WITH THIS LOGICAL RECORD#GT
	J	RTD6			:YES, REPEAT PASS THRU RTD TO COPY DATA

::	LOG II needle received.  Do normal needle stuff, but write NEEDBD
::	instead of NEEDHD so CRQ won't process needle until all there.  Also
::	allows CRQ to timout needles which never receive the end.

       IF	LOGII			:only for LOG 2
RTDNHD	JAL	R8,GFCBUF		:get a buffer to put it
	SKIPAD(RTDOOB)			:die if no buffers
	LIS	R0,1
	AHM	R0,ANCHN,KD		:another chn is use on this link
	SRHLS	CHN,1			:get real CHN number
       if	aplybp			:set xmit bp type
	tbt	kn,vactbp		:apply/release logic on the link?
	jefs	rtdnh1			:nope
	sbt	chn,abpvcp,r7,		:start off with bp released
       ei	:aplybp
rtdnh1	AH	CHN,LKZFKN,KN,KN
	JAL	R9,CRQHCR,,		:build half circuit
	LHL	R0,IOTAB,CHN,CHN	:make sure relieve backpressure
	OHI	R0,3			:to get entire needle
	STH	R0,IOTAB,CHN,CHN
	SH	CHN,LKZFKN,KN,KN
	SLHLS	CHN,1			:get back link CHN #
	LHI	R0,CIRSP0		:allow us to send zap if goes wrong
	STH	R0,BPSCNT,R6,CHN
	LR	R1,R2			:save time needle arrived
	SRLS	R1,1			:FW index
	L	R0,FASTC,,
	ST	R0,BUFTIM,R1,
	JAL	R9,CRQALT,,		:tell CRQ to look for Needle
	LHI	R1,NEEDBD		:write body (not head) so CRQ knows
	JAL	R9,W2CI 		:to check for timout
	SIS	LRC,2			:two chars is needhd size
	AIS	PRD,2			:and point past needle point
	J	RTDTY1			:exit for char pairs

:	Needle body arrives on assigned chn.  If not termination then CRQ
:	has enough to process it.  If termination then CRQ must wait for tail.

RTDNBD	LIS	R0,03			:first half of needle
	STB	R0,0,R3 		:setup by the microcode
	ST	R3,BE,R2,		:save pointer
	LHI	R1,NEEDBD&0FF		:finish putting needle body
	JAL	R8,WCI
	L	R3,BB,R2,		:set up for look for termination node
	JAL	R9,PHWI			:get past needle point
	LHI	R4,ID.NNL		:any needle node list
	JAL	R7,X4PARS,,
	SKIPAD(RTDPB1)			:not there- termination
	LR	R0,R0			:any entries in list?
	JNFS	RTDPB2
RTDPB1	LR	R4,R2			:skip if not termination
	SRLS	R4,3			:make bit array
	SBT	R4,CRQEND
	J	RTDPB4			:for terms let needle tail write HEAD
RTDPB2	JAL	R9,G2CI			:remove needbd (it tells crq to wait)
	LHI	R1,NEEDHD		:and needhd tells crq to process it
	JAL	R8,WCD
	EXBR	R1,R1			:write NEEDHD (tell CRQ to process
	JAL	R8,WCD
RTDPB4	LHL	R6,TBDPKN,KN,KN 	:restore clobbered regs
	LHL	R7,FLDPKN,KN,KN 	:restore clobbered regs
	J	RTDTY1			:standard reentry for char pairs

:	RTDNTL  got needle tail on a termination.  Thus, needle is sitting
:		in buffer waiting for CRQ if we are termination.  If
:		passthrough then needle tail just passes through.

RTDNTL
       if	rebild
	lis	r0,0
	st	r0,vseqn,r2,		:after needle tail is start of real data
       ei	:rebild
	LIS	R0,03			:write needle tail
	STB	R0,0,R3
	ST	R3,BE,R2,		:save pointer
	LHI	R1,NEEDTL&0FF
	JAL	R8,WCI
	LR	R1,R2			:if we are termination
	SRLS	R1,3
	TBT	R1,CRQEND		:termination?
	JE	RTDTY1			:nope done
	JAL	R9,G2CI 		:tell CRQ whole needle has arrived
	LHI	R1,NEEDHD
	JAL	R9,WCD
	EXBR	R1,R1
	JAL	R8,WCD			:write CRQ go (needle head)
	J	RTDTY1

       ELSE	:not LOG II
RTDNBD	EQ	RTDALL
RTDNTL	EQ	RTDREJ		:reject unless LOG II

       EI	:LOGII


::	DATA RECEIVED ON UNASSIGNED CHANNEL FROM NETWORK NEIGHBOR.
::	REPORT TYPE 2 MESSAGE TO SUP LOG, WITH HIGH-ORDER BIT OF THIRD
::	HALFWORD SET IF DATA IS A ZAPPER. REPORT TO XRAY WITH NEIGHBOR
::	AND CHANNEL NUMBER. DISCARD DATA RECEIVED.

RTDUA2	LR	R0,CHN
	SRLS	R0,1			:SET UP TYPE 2 NODE REPORT
	RBT	R0,LNKCHS,R7,		:DON'T REPORT
					: IF ZAPPER RECENTLY TRAVELLED
	JE	RTDIGN			:CHANNEL SUSPENDED
	STH	R0,SUPMBF+4		:CHANNEL NUMBER IN HW 3
	LIS	R1,NR.UAC
	STH	R1,SUPMBF		:INDICATE TYPE 2
	LHL	R1,NDID,KD
	STH	R1,CRYSBF+2
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER IN HW 2
	LB	R1,0,PRD		:GET DATA RECEIVED AND
	SIS	R1,3			: TEST FOR ZAPPER
	JNFS	RTDUA4			:NO
	SBT	R1,SUPMBF+4		:YES - SET HI-ORDER BIT IN HW 3
	JAL	R8,CRYPTO,,		:REPORT ZAPPER ON UNASSIGNED CHANNEL
	HC	CRYE09
	JFS	RTDUA6
RTDUA4	JAL	R8,CRYPTO,,		:REPORT DATA ON UNASSIGNED CHANNEL
	HC	CRYE28
RTDUA6	ST	R10,RTMT1
	JAL	R10,SUP12,,		:SEND REPORT TO SUP LOG
	LIS	R0,NR.CTM		:NOW REPORT TIME SINCE CHAN WAS ZAPPED
	STH	R0,SUPMBF		:NODE REPORT TYPE
	LH	R0,SLOWC+2,,		:CURRENT TIME MINUS
	SH	R0,BPSCNT,R6,CHN	: TIME THAT ZAPPER PASSED YIELDS # OF
	STH	R0,SUPMBF+2		: SECONDS THAT CHAN HAS BEEN UNASSIGNED
	JAL	R10,SUP12,,		:REPORT IT TO SUP LOG
	L	R10,RTMT1
	IF	DB.DEB
	LB	R0,0,PRD		:WAS DATA A ZAPPER?
	SIS	R0,3			:(IF SO, IT COULD HAVE GOBBLED NEEDLE)
	JE	RTDIGN			:O.K.
	DBOOPS				:CAN'T EXPLAIN IT FROM T-II NEIGHBOR...
	EI	:DB.DEB
	J	RTDIGN			:IGNORE DATA ON UNASSIGNED CHANNEL

::	RTDSNP
::	ERROR DETECTED IN PACKET FROM NEIGHBOR - SNIP THE LINK. SET 'BORI ZAP'
::	BIT TO CAUSE LINK TO GO OUT NEXT EXECUTION OF LNCHCK. SAVE LINK SNIP
::	REASON IN SNPTYP FOR NODE REPORT IN TRLINK, AND DON'T TEAR ANY MORE
::	PACKETS FOR THIS LINK.

:	entry for error return from GFCBUF when out of buffers		###wjl
RTDOOB	LHI	R0,LS.OOB		:out of buffers			###wjl

RTDSNP
      IF	DB.SNP			:if crash on link snip
	DBOOPS				:then crash
       ELSE
	STH	R0,SNPTYP,KN,KN		:SAVE REASON FOR LINK SNIP
:	borzap inverted by sdw
	rBT	KN,BORZAP		:AND TAKE LINK OUT

:	SAVE SOME USEFUL DATA
	LHL	CD,NRTR,KD		:RECORD DESCRIPTOR INDEX
	LHL	R9,RECN,CD		: AND RECORD NUMBER
       IF	LNKDBG			:save regs for link snip	###sdw
	STM	R0,REGST		:save regs debugger
	JAL	R14,RTSDB1,,		:RTD snip debugger #1
	LM	R0,REGST
	JAL	R14,RTSDB2,,		:save offending packedt debugger
	LM	R0,REGST		:				###sdw
       EI	:LNKDBG
	J	RTEARZ			:DONE WITH THIS LINK...
      EI	DB.SNP

:	GOT CHANNEL NUMBER GREATER THAN MAX NUMBER ALLOCATED. IF CHN IS
:	GROSSLY HIGHER THAN CURRENT MAX, SOMETHING WRONG. OTHERWISE, T-II
:	NEIGHBOR MUST WANT US TO BUBBLE THE LINK.

RTDBIG	STH	CHN,RTMT3
	SR	CHN,R0
	CLHI	CHN,80			:HOW MUCH OVER IS IT?
	JLFS	RTD1C			:A LITTLE
RTD1B	LIS	R0,LS.COR		:CHANNEL OUT OF RANGE
	J	RTDSNP			:ERROR IN PACKET FROM NEIGHBOR
					: - SNIP THE LINK

:	CHN PROBABLY CARRIES NEEDLE FROM NEIGHBOR WHO JUST BUBBLED.
:	INCREASE CHANNEL ALLOCATION FOR THIS LINK.
RTD1C
:	ONLY BUBBLE FOR NEEDLES
	LB	R0,0,PRD
	EXBR	R0,R0
	LB	R1,1,PRD		:GET FIRST 2 BYTES OF LOGICAL RECORD TO
	AR	R1,R0			: CHECK FOR NEEDLE POINT
       IF	LOGII			:handle LOG II needles		###sdw
	CLHI	R1,NEEDHD		:LOG 2 Needle Head		###sdw
	JE	RTD1D
       EI	:LOGII
	CLHI	R1,NEEDP
	JEFS	RTD1D			:NEEDLE POINT - WE'LL BUBBLE LINK...

:	BAD CHANNEL NUMBER FROM NEIGHBOR
	LHI	R0,LS.BOD		:bubbling and not a needle
	J	RTDSNP			:BAD CHANNEL NUMBER, SNIP LINK

RTD1D	STH	PRC,RTMT3+2		:SAVE PHYS RECORD COUNT (R10)
	jal	r8,cntsus,,		:count suspended chn on this link
	JAL	R8,BUBBLE,,		:FIND P.T. BUBBLE, ALLOCATE MORE CHANS
	SKIPAD(RTD1E)			:immed, NO P.T. SPACE, TAKE LINK DWN
	LHL	R6,TBDPKN,KN,KN		:+4 ret, POSSIBLY NEW TABLES POINTERS
	LHL	R7,FLDPKN,KN,KN
	LHL	PRC,RTMT3+2		:RESTORE REGS
	LHL	CHN,RTMT3
	AR	CHN,CHN			:2*CHANNEL USEFUL INDEX
	J	RTDUAN			:GO HANDLE NEEDLE

:	OUT OF PERMUTER TABLE SPACE
RTD1E	RBT	KN,LKTEAR		:DO NO MORE FOR THIS LINK
	L	R10,RTMXSV		:CAUSE TRLINK TO EXIT RTD
	ST	R10,NEWLNR
	J	NEWLN8			:REPORT NO P.T. TO SUP LOG,
					: TEAR DOWN LINK

::*********************************************************************
::
::	RTDZTB:
::	DISPATCH TABLE FOR TEARING NETWORK 03-CHARACTER PAIRS
::
::*********************************************************************

RTDZTB	WC	RTDIGN		:0300 RESERVED - IGNORE
	WC	RTDZPH		:0301 ZAPPH - HARD ZAPPER
	WC	RTDZPS		:0302 ZAPPS - SOFT ZAPPER
	WC	RTDNGZ		:0303 ZAPPN - NON-GOBBLING ZAPPER
	WC	RTDZPF		:0304 ZAPPF - FAT ZAPPER
	WC	RTDZPS		:0305 RESERVED - SOFT ZAPPER
	WC	RTDZPH		:0306 RESERVED - HARD ZAPPER
	WC	RTDZPH		:0307 RESERVED - HARD ZAPPER
	WC	RTDGOB		:0308 GOBBL - GOBBLER
	WC	RTDFGB		:0309 GOBBF - FAT GOBBLER
	WC	BADCTL		:030A UNUSED, RESERVED
	WC	RTDSQF		:030B SQFIX - REBUILD SEQUENCE NUMBER FIX
	WC	RTDSQK		:030C SQACK - REBUILD SEQUENCE NUMBER ACK
	WC	RTDGOB		:030D RESERVED - GOBBLER
	WC	RTDGOB		:030E RESERVED - GOBBLER
	WC	RTDGOB		:030F RESERVED - GOBBLER
	WC	RTDNAC		:0310 NEEDP - NEEDLE
	WC	BADCTL		:0311 NEEDE - NEEDLE EYE
	WC	BADCTL		:0312 TILIM - MESSAGE FOR PORT IN LOGIN MODE
	WC	BADCTL		:0313 LOGRR - LOGON ERROR
	WC	RTDNAC		:0314 RESERVED - NEEDLE
	WC	RTDNAC		:0315 RESERVED - NEEDLE
	WC	RTDNAC		:0316 RESERVED - NEEDLE
	WC	RTDNAC		:0317 RESERVED - NEEDLE
	WC	RTDNAC		:0318 RESERVED - NEEDLE
	WC	RTDNAC		:0319 RESERVED - NEEDLE
	WC	RTDNAC		:031A RESERVED - NEEDLE
	WC	RTDNAC		:031B RESERVED - NEEDLE
	WC	RTDNAC		:031C RESERVED - NEEDLE
	WC	RTDNAC		:031D RESERVED - NEEDLE
	WC	RTDNAC		:031E RESERVED - NEEDLE
	WC	RTDNAC		:031F RESERVED - NEEDLE

	SUBTTL	YAKYAK (RMAKE - Record assembly)

::*********************************************************************
::
::	SUBPROCESS:	RMAKE:
::	FUNCTION:	RMAKE checks to see if a Bori Zap is pending.  If
::	not, it checks WSIZE to see if its ok to make a record.  If so it 
::	finds the Next Record to Make descriptor (NRMK), and dispatches
::	based on link type.  It loads the address of the record data buffer
::	to fill and calls RMK.  After logical data is assembled into the 
::	record buffer, RMAKE puts on the header and fills the frame to a
::	doubleword boundry.  The count field is filled in, and the  end of 
::	record pointer is updated.  Total characters is recorded and the 
::	BORI is inserted.  LRM is incremented and the trace tables are 
::	updated.  NAS is updated and the RECN is inserted, releasing the 
::	frame to the Sync transmitter.  If a serious error occurs, the
::	link will be snipped.
::	CALLING SEQ:	J RMAKE  (called directly from SPIDER)
::	INPUT:		R2 contains link number
::	CALLS:		JAL  R9,RMK
::			JAL  R8,TSBMRK
::	RETURNS:	J    spide1
::
::*********************************************************************

xicrmk	hc	ticrmk			:rmake time limit
	syad(XICRMK)
:	cheap little organizational optimization
rmkas5	la	r0,2*((nlinks-1)/10)+lkmake
	lr	r1,r0
	lhi	r2,(((nlinks*2-2)/10)*10)!0f
	sth	r2,didall		:serviced each link once
	arand	r0,r2			:find an unserviced link
	jfs	rmaks2			:link serviced, but can do it again 
	j	spide1,,

:	RMAKE - the real thing - redone to include output when doing packet
:	and not making if no free ccw/rotor to send and a fair bit of
:	careful coding to work wonderfully under great load and take
:	minimal cpu time.

:	run RMAKE for all links and don't consantly be checking EXEC (EXYLD).
:	(Only higher job is bufzap and RMAKE removes data from buffers)
RMAKE	L	R0,FASTC,,		:calculate time to dismiss
	AH	R0,XICRMK
	ST	R0,DIDTIM		:and when we expire
	LIS	R0,0			:make sure service all links this time
	STH	R0,DIDALL		:service all links equally
RMAKS2	HS	0			:here to do do links wanting to be
	 				:serviced again
Q	EQ	0
	 RE	LKSIZE/4
	L	R0,LKMAKE+4*Q		:links wanting service
	ST	R0,LKSRVD+4*Q
Q	EQ	Q+1			:just a couple of ST (32 links per ST)
	 ER

	IF	DB.DEB
:	DETERMINE HIGH-WATER MARK FOR INTERVAL BETWEEN RMAKE EXECUTIONS
	L	R0,FASTC,,
	LR	R3,R0			:GET CURRENT TIME AND COMPUTE
	S	R0,RMKTIM		:INTERVAL SINCE LAST RMAKE EXECUTION
	ST	R3,RMKTIM		:SAVE CURRENT TIME
	CLH	R0,RMKHWM		:IS THIS A NEW HIGH-WATER MARK?
	JLEFS	RMAKT1			:NO
	STH	R0,RMKHWM		:YES - SAVE
RMAKT1	EI	:DB.DEB

:	exec optimization comes here to service next link or maybe same link
:	gets another packet.  but first check and see if we've expired  ###sdw
RMAKS0	L	R0,FASTC,,		:time up?
	S	R0,DIDTIM		:any time left
	jle	rmaks4			:time to still make packets
	lh	r1,didall		:everyone get serviced?
	jg	spide1,,		:yes, return to spider
	jal	r0,exyld,,		:no, come on back after doing whatever
	ts	didall			:negative, took timout
	lh	r0,xicrmk
	a	r0,fastc,,		:next timeout expiring
	st	r0,didtim
:	do each link before doing any link again, thus it the service array is
:	0 then check original to see if any serviced have more data.

rmaks4	lhi	r0,2*((nlinks-1)/10)+lksrvd
	lhi	r1,2*((nlinks-1)/10)+borzap
	lhi	r2,(((nlinks-1)/10)*10)!0f
	arand	r0,r2			:find an unserviced link
	jfs	rmaks3
	lh	r0,didall		:get timed out on first pass?
	jge	rmkas5			:no, try for more packets
	j	spide1,,		:yes, let something else run

rmaks3	rbt	r2,lksrvd

	LR	KN,R2			:LINK NUMBER TO MAKE LINK DESCRIPTOR
	AR	R2,r2
	L	KD,KDKN,R2,R2

	JAL	R9,CCWCHK		:see if any free CCWs
	J	RMAKEB			:nope backloged
	STH	R5,RMLNSV		:save line to output on

	LB	R1,WSIZ,KD		:IF LRM<LAR+WSIZ, MAKE RECORD
	AH	R1,LAR,KD
	SH	R1,LRM,KD
	CHVR	R1,R1
	JGFS	RMAKE2			:GO MAKE RECORD
	jal	r9,ccwrtr		:send retransmission
RMAKEB	LIS	R0,1			:backlogged
	AHM	R0,KS.BAK,KD		:INC COUNT OF BACKLOG EVENTS
RMAKE1	RBT	KN,LKMAKE		:CAN'T HACK IT, MARK LINK AS SERVICED
	J	rmaks4			:look for next link

:	THERE IS A RECORD TO MAKE.  MAKE THE RECORD
RMAKE2	LHL	CD,NRMK,KD		:POINT TO RECORD DESCRIPTOR

:	HERE TO MAKE A FRAME FOR A T-II LINK

	L	PRD,BREC,CD		:T-II - GET POINTER TO SEG2 DATA BUFFER
:	Begin Scope of PRD containing POINTER to next char in buffer ##JOK
	ais	PRD,3			:where to put logical records
					: RESERVE 3 BYTES FOR HDR
	LHI	PRC,$A121		:MAKE UP TO 121 DATA BYTES FRAME
					: - LEAVE 3 BYTES FOR HEADER
					: AND 4 BYTES FOR CHECKSUM

:	> > > > > > > > > > > > > > > > > 
	JAL	R9,RMK			:GO MAKE A FRAME
:	< < < < < < < < < < < < < < < < < 

:	histogram of packetsize 
       IF	XRYRMK			:monitor packetsize		###sdw
	LHL	R0,NDID,KD		:for this neighbor?
	CLH	R0,XRMKNE,,		:the desired neighbor
	JNFS	XRMK01
	LR	R1,PRC
	NHI	R1,-2			:nearest even packetsize
	lis	r0,1
	AM	R0,XRMKHS,R1,R1 	:another histogram entry
XRMK01
      EI	:XRYRMK

	CLHI	PRC,$A121		:DID RMK MAKE A FRAME?
	jefs	RMAK2A			:no, check if need null record
	j	rmakw3			:more often don't make than make

RMAK2A	LHL	R0,LRT,KD		:MAKE NULL REC
	SH	R0,LAS,KD		: IF UNACKED FRAMES OUTSTANDING
	lhr	r0,r0
	SIS	R0,TH.ACK		:MORE THAN THRESHOLD FRAMES UN-ACKED?
	jgfs	rmaknl			:time for a null packet

RMAKNO	LIS	R0,1			:NO RECORD MADE,
	Am	R0,KS.NPC,KD		:LINK-BY-LINK COUNT OF NO RECORDS MADE
	RBT	KN,LKMAKE		:MARK LINK AS SERVICED
	ts	idle,kd		 	:line is idle right now
	J	RMAKS0

:	MAKE NULL RECORD
RMAKNL	LIS	R0,0			:YES, NULL REC, LRC=0, CHN=0
	STB	R0,0,PRD
	STB	R0,1,PRD
	AIS	PRD,2
	SIS	PRC,2			: null record now 5-bytes long

RMAKW3	LIS	R0,0			:FILL OUT FRAME TO MULTIPLE OF 8 BYTES
	STB	R0,0,PRD		:3 ZERO BYTES TO INDICATE END OF FRAME
	STH	R0,1,PRD
	STh	R0,LLXM,CD		:CLEAR RETRANSMISSION FLAG

:	End Scope of PRD containing POINTER to next char in buffer ##JOK

	nhi	prc,-8
	LHI	R1,80			:NUMBER OF BYTES IN PACKET JUST MADE
	SR	R1,PRC			:INCLUDE CHECKSUM AND
	AM	R1,KS.PCO,KD		: COUNT PACKET CHARACTERS OUTPUT

	SIS	R1,4			: excluding cksum
	sth	r1,erecsz,cd		: size of record
	SRLS	R1,3			:DISCARD LAST 3 BITS (SHOULD ALL BE 0)
	LB	R0,BORI,KD		:GET EXPECTED BORI
	XHI	R0,30,r1		:COMPLEMENT MASTER/SLAVE FIELD
	EXBR	R0,R0
	LH	R1,LRM,KD		:(DIGRESS TO INDEX LRM)
	AIS	R1,1
	STH	R1,LRM,KD
	L	R9,BREC,CD		:PUT AWAY HEADER
	STH	R0,0,R9		: put away header
	STB	R1,2,R9		:INSERT TRUNCATED REC #

	IF	TSTSZE
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R8,TSLINK		: TEST FOR LINK OF INTEREST
	JN	RMAKET			:NO - CONTINUE
	JAL	R8,TSBMRK,,		:SET UP NEW EVENT ENTRY
	LIS	R8,TS.MAK		:GET EVENT TYPE,
	STB	R8,TSBTBL,R7		: AND STORE IN EVENT ENTRY
	STH	R0,TSBTBL+2,R7		:STORE RECORD HEADER
	STB	R1,TSBTBL+4,R7		:STORE PACKET RECORD NUMBER
	LHL	R8,LAS,KD
	STB	R8,TSBTBL+1,R7		:STORE LAST ACK SENT
	LHL	R8,LRT,KD
	STB	R8,TSBTBL+3,R7		:STORE 'LRT' SINCE ACK FIELD LEFT BLANK
					:FOR INTERRUPT ROUTINE TO FILL IN...
RMAKET	EI	:TSTSZE
	LHL	R0,LRT,KD		:WE'LL BE ACKING THIS
	STH	R0,NAS,KD
	LHL	R0,LRM,KD		:GET RECORD NUMBER
	LHL	R1,FASTC+2,,		:GET CURRENT TIME
	STH	R1,PKTTIM,cd	 	:AND STORE AWAY FOR INTERRUPT ROUTINE

::	A RECORD BUFFER NEED NOT BE MARKED BUSY WHILE BEING FILLED. IT BEARS A 
::	RECD # THAT IS LESS THAN LAR AND THEREFORE WILL NOT BE XMITTED.
	
	STH	R0,RECN,CD		:RELEASE RECORD TO SYNC XMITTER
	LHL	R2,RLNK,CD		:INDEX NRMK TO NEXT REC
	STH	R2,NRMK,KD

:	and now send the packet     must have KD,KN,CD.  Also r9 as BREC
	jal	r9,ccwsnd

	rbt	kn,siobtr		:last packet sent was not retransmiss
	SIS	PRC,0A			:did packet have more room?
	JL	RMAKS0			:link still has data waiting	###sdw
	RBT	KN,LKMAKE		:did all data->link serviced	###sdw
	J	RMAKS0			:look for next free link

::	RMKSNP:
::	SOMETHING WENT WRONG. SNIPPING THE LINK IS LESS PAIN THAN CRASHING
::	NODE, AND PROBABLY ELIMINATES EXPOSURE TO POTENTIAL CROSSED CIRCUITS
::	EVEN IF WE DON'T REALLY KNOW WHAT'S GOING ON...
::
::	THE LINK SNIP REASON IS PASSED ON R0. SET THE BIT FOR THIS LINK
::	IN THE BORI ZAP ARRAY. TRLINK WILL MAKE REPORTS TO SUP LOG AND XRAY
::	AFTER ZAPPING ALL CIRCUITS ON LINK.
:	borzap inverted by sdw

RMKSNP
      IF	DB.SNP			:crash on link snip
	DBOOPS				:crash
      ELSE	:not DB.SBP (normal)
	rBT	KN,BORZAP		:LNCHCK WILL TAKE LINK OUT
	rbt	kn,lkmake
	STH	R0,SNPTYP,KN,KN		: AND TRLINK WILL KNOW WHY
       IF	LNKDBG			:save REGS for debugger
	STM	R0,REGST
	JAL	R14,RMSDB1,,		:RMK SNIP DEBUGGER #1		###sdw
	LM	R0,REGST
       EI	:LNKDBG
	J	RMAKS0			:THAT'S ALL FOR THIS LINK
      EI	:DB.SNP

	SUBTTL	YAKYAK (RMK)

::*********************************************************************
::
::	SUBROUTINE:	RMK:
::	FUNCTION:	RMK assembles data from buffers which have been
::	flagged as needing attention.  If link undergoing shrink process,
::	RMAKE is frozen, return.  Otherwise, see if backpressure need be 
::	relieved.  Find next channel to service, range check channel number
::	and see if page change need be sent.  Get outbound buffer pointer
::	and dispatch based on link type.  See if # of chars in buffer will 
::	fit into frame, and if so copy from buffer to output record.  Count
::	logical characters output and update BPSCNT. Insert channel  number
::	and logical count into packet.  Trace channel if desired.  Make 
::	more packets if at least ten bytes remain in the frame.  Restore
::	record pointer and return to RMAKE.  If serious errors occur,
::	snip the link.
::	CALLING SEQ:	JAL  R9,RMK
::	INPUT:		KD   -- Link Descriptor address
::			KN   -- Link Number
::			PRD  -- Pointer to Physical Record
::			PRC  -- Physical Record byte count
::
::*********************************************************************
::
::	THIS ROUTINE ASSEMBLES DATA FROM BUFFERS WHICH HAVE BEEN
::	FLAGGED AS NEEDING ATTENTION.  THE DATA FROM THE BUFFER
::	IS BUILT INTO A LOGICAL RECORD WITHIN A PHYSICAL RECORD
::	WHICH IS TO BE TRANSMITTED ACROSS A LINK.  EACH TIME
::	THROUGH RMK, IT TRIES TO BUILD ONE PHYSICAL RECORD.
::
::	LNKFLG  -- IS THE ARRAY OF FLAGS INDICATING WHICH BUFFERS
::			NEED ATTENTION.
::
::	LNKBPV  -- IS THE ARRAY OF FLAGS INDICATING WHICH CHANNELS
::			RECEIVED BACKPRESSURE RELIEF.
::
::	CHSRVD  -- IS A WORKING COPY OF THE BACKPRESSURE ARRAY.
::			IT IS USED TO INSURE THAT CHANNELS ARE SERVICED
::			IN A ROUND ROBIN FASHION.
::
::	BPSVCP  -- IS AN ARRAY WHICH INDICATES WHETHER OR NOT THE
::			BACKPRESSURE COUNT FOR A CHANNEL SHOULD BE
::			RESET. 
::
::	PRIRTY  -- ARRAY WHICH INDICATES PRIORITY CHANNELS
::
::	GUSH	-- ARRAY INDICATING MUCH TRAFFIC (AT LEAST 8 CHARACTERS)
::			RECEIVED SINCE LAST BACKPRESSURE RELIEF and are
::			not yet bp relieved.
::
::**********************************************************************

RMK	ST	R9,RTMXSV		:SAVE RETURN ADDRESS

	LHL	R2,NCHN,KD		:MAX # OF CHANNELS (DYNAMIC FOR T-II)
	SIS	R2,1			:MINUS 1
	STH	R2,RMTSR4		:where to start searching for chns
	STH	R2,RMRFLG		:a positive value so KS.RRC is correct
	LHL	R6,TBDPKN,KN,KN		:START OF 1/2 WD TABLES FOR LINK
	LHL	R7,FLDPKN,KN,KN		:START OF FLAGS FOR LINK
	LHI	R0,0C000		:ALWAYS LOOK AT CHANNELS 0 AND 1
	OH	R0,CHSRVD,R7,
	STH	R0,CHSRVD,R7,
	LB	R0,SHSTAT,KD		:TEST SHRINK STATE
	JEfs	RMKB0			:NO SHRINK ACTIVITY
	j	rmkshk

RMKB0	RBT	KN,BPMTII		:TIME TO SEND BACKPRESSURE RELIEF REC?
	JEFS	RMKNCH			:NO
:	+0 return means lack of room.  +4 return means all is okay
	Jal	r9,RMKBP		:yes, send bp relief record
	sbt	kn,bpmtii		:+0 return= then reschedule
					:+4 return=it completed
	CLHI	PRC,0A			:AT LEAST 10 BYTES LEFT IN FRAME?
	JGEfs	RMKNCH			:YES, LOOK FOR MORE records TO MAKE
	J	RMKXIT			:NO, EXIT RMK

:	FIND NEXT CHANNEL TO SERVICE. SCAN FOR CHANNEL WITH BUFFER FLAG
:	SET AND 'CHSRVD' SET.

RMKNCH	LHL	R2,RMTSR4		:last chn serviced for this link
	OHI	R2,0F			:search from this HW
	LR	R1,R2
	SRLS	R1,3			:make into # HWs -1
	LA	R0,LNKFLG-1,R1,R7	:data present flags
	LA	R1,CHSRVD-1,R1,R7	:chns not yet serviced or BPed flags
	ARAND	R0,R2			:ARRAYAND RETURNS HIGHEST NONZERO
					: BIT NUMBER IN R2
	JFS	RMKHIT			:ARRAYAND RESULT WAS NONZERO
	J	RMK3			:ARRAYAND RESULT WAS ZERO,
					: DONE WITH THIS LINK

:	FOUND CHANNEL WHICH NEEDS AND IS ALLOWED SERVICE

RMKHIT	STH	R2,RMTSR4		:last chn checked
	RBT	R2,CHSRVD,R7,		:chn is now serviced
       if	aplybp
	sbt	r2,xgush,r7,		:chn sent data out
       ei	:aplybp
	LR	CHN,R2			:SET UP LINK RELATIVE  CHANNEL NUMBER
	AR	CHN,CHN			:CHANNEL NUMBER*2

:	SEE IF PAGE CHANGE NEEDED

	EXBR	R1,R2			:GET PAGE NUMBER
	LBR	R1,R1
	CLB	R1,RMPAGE,KN,KN		:NEED PAGE CHANGE?
	JEFS	RMHIT3			:NO, CHANNEL IN RANGE OF CURRENT PAGE
	STB	R1,RMPAGE,KN,KN		:YES - SAVE NEW PAGE NUMBER
	AHI	R1,80			:INSERT PAGE CHANGE RECORD
	STB	R1,0,PRD		: INTO PACKET

	AIS	PRD,1			:INCREMENT PHYSICAL RECORD POINTER
	SIS	PRC,1			:DECREMENT PHYSICAL RECORD BYTE COUNT

	SUBTTL	YAKYAK (RMK - Tymnet-II link)

RMHIT3	LHL	R2,NIOTAB,R6,CHN	:NOW GET PERMUTER TABLE ENTRY
	NHI	R2,-4			:MASK OUT SPEED BITS
	JNFS	RMHIT8			:MUST BE NONZERO
	IF	DB.DEB
	DBOOPS				:ERROR - ZERO ENTRY IN PERMUTER TABLE
	ELSE	:NOT DB.DEB
	lhl	r2,rmtsr4		:check arand instruction
	lhi	r0,ls.arc		:guess arand trouble
	tbt	r2,lnkflg,r7,		:make sure data present was set
	jefs	rmhit7			:it wasn't so arand messed up
	LHI	R0,LS.ZPT		:DON'T KNOW HOW, BUT WE GOT A NULL
rmhit7	J	RMKSNP			: PERMUTER TABLE ENTRY - SNIP THE LINK
	EI	:DB.DEB

RMHIT8	XHI	R2,4			:FLIP TO OUTBOUND BUFFER #


::	HERE TO PROCESS LOGICAL RECORDS TO TRANSMIT
::	ON A TYMNET II LINK
::
::	DETERMINE LRC, THE NUMBER OF BYTES TO BE PUT INTO THE RECORD.
::	THIS WILL BE THE MINIMUM OF:
::	1.	CBCCT(BUFFER)	# OF CHARACTERS IN BUFFER
::	2.	BPSCNT(CHAN)	# OF CHARS ALLOWED BY BACKPRESSURE. THIS
::				VALUE IS NEVER LESS THAN 8 - SEE RMK12
::	3.	PRC-2		SPACE LEFT IN PACKET - AT LEAST 10 (RMK17)

RMKTW	LHL	LRC,BPSCNT,R6,CHN
	thi	lrc,-8
	jnfs	rmktw1
	J	RMKBRZ			:it knows to return to rmktw1

RMKTW1	JAL	R8,CBCCT		:CBCT - Compute BCT (GET BUFFER COUNT)
	CR	R1,LRC			:WHICH IS SMALLER?
	JGEFS	RMK10			:BPSCNT,LRC LIMITED BY BACKPRESSURE
	LR	LRC,R1			:CHRCNT,LRC LIMITED BY CHARS AVAILABLE
RMK10	CLHI	LRC,-2,PRC		:WILL ALL BYTES FIT IN PHYSICAL PACKET?
	JLEfs	RMKP3			:YES
	LHI	LRC,-2,PRC		:NO,LRC LIMITED BY SPACE LEFT IN PACKET

::	LOGICAL RECORD SIZE IS RESTRICTED BY SPACE LEFT IN PACKET. IF
:: 	LRC LESS THAN THRESHOLD, GIVE THIS CHANNEL ANOTHER TURN.

	CLHI	LRC,T2SRVS
	Jgfs	RMKP3			:THIS CHAN GETS 1ST TRY AT NEXT PACKET
	LR	R0,CHN
	SRLS	R0,1			:GET ACTUAL CHAN NO. INTO R0
	SBT	R0,CHSRVD,R7,		:NEXT TURN WILL GO TO PRIORITY CHANNEL

::	IF BACKPRESSURE RESTRICTION COUNT (BPSCNT) DECREMENTS TO 8 OR LESS,
::	CHSRVD BIT WILL BE RESET IN RMK12.

RMKP3	LR	CD,LRC			:CD (R13) USED AS A WORKING COPY OF LRC
	JNFS	RMK16A
	IF	DB.DEB
	DBOOPS				:NO ZERO LENGTH RECORDS
	ELSE	:NOT DB.DEB
	lhl	r2,rmtsr4		:check arand instruction
	lhi	r0,ls.arc		:guess arand trouble
	tbt	r2,lnkflg,r7,		:make sure data present was set
	jefs	rmkp31			:it wasn't so arand messed up
	LHI	R0,LS.EBF		:INDICATE EMPTY BUFFER FOR ACTIVE CHAN
rmkp31	J	RMKSNP			: AND GO SNIP THE LINK
	EI	:DB.DEB

RMK16A	AIS	PRD,2			:INDEX TO START OF DATA
	L	R3,BB,R2,		:GET CHARACTER OUT PTR
	JNFS	RMK5
	CRASH.(.RMEB0)

RMK5	SIS	PRD,1			:BACK UP TO LAST BYTE STORED
RMK5C	LHL	R0,0,PRD		:SET UP R1 AS SCRATCH
	EXHR	R0,R0			: REGISTER FOR THE
	LHL	R1,0,R3			: MICROCODE
	OR	R1,R0

::	RMAKE MICROCODE INSTRUCTION
::	R1 = scratch
::	CD = WORKING COPY OF LRC, # OF BYTES TO COPY
::	R12 = PRD  => POINTER TO OUTPUT RECORD
::	R3 = BB (address of next character to be output)
RMK5A	HC	0E1D			:RMAKE Copy 1 - SCRATCH REG, COUNT
RMK5B	HC	0F1D			:RMAKE Copy 2 - CONTINUATION ADDRESS
	HC	RMKNXT-RMK5B		:TO RELEASE EMPTY BUFFERLET
	HC	RMKC00-RMK5B		:TO HANDLE CHARACTER PAIR
	HC	RMKC01-RMK5B		:TO HANDLE PREFIX CHARACTER
	HC	RMKC02-RMK5B		:TO HANDLE GOBBLERS
	HC	RMKC03-RMK5B		:TO HANDLE GOBBLERS/ZAPPERS

	IF	DB.DEB	
	JFS	RMK5XT			:IN CASE UPSW TRACE ENABLED
	EI	:DB.DEB

:	DONE WITH RMAKE COPY FOR THIS CHANNEL
RMK5XT	AIS	PRD,1			:INCREMENT PRD TO NEXT LOGICAL RECORD
					: LOCATION (OR END OF PACKET)
	IF	DB.DEB
	LR	R2,R2			:VERIFY BUFFER INDEX STILL O.K.
	JNFS	RMK5OK			:NON-ZERO - MUST BE O.K....
	DBOOPS				:DEFINITELY NOT O.K.
	EI	:DB.DEB
RMK5OK	LHI	R0,-1,R3		:BACK UP BB POINTER
	CL	R0,BE,R2,		:BUFFER EMPTY?
	JNfs	RMKIG5			:NO, SKIP
	JAL	R8,GCLAST		:YES, RETURN LAST BUFFERLET
	J	RMK12			:RETURN TO MAINLINE

RMKIG5	ST	R3,BB,R2,
	J	RMK12

:	HERE TO RELEASE EMPTY BUFFERLET AND GET NEXT ONE
RMKNXT	LHI	R4,-1,R3		:MICROCODE INC'D POINTER
	CL	R4,BE,R2,		:BUFFER EMPTY?
	JNFS	RMKNX5			:NO, JUST BUFFERLET
	JAL	R8,GCLAST		:YES
	LIS	R3,0			:FLAG R3
	J	RMK5B

RMKNX5	THI	R3,CBSZ-1		:really end of bflet?
	JN	RMK5B			:nope, put the char
RMKNX7	JAL	R8,GCRET		:FREE ONE BUFFERLET
	L	R3,BB,R2,
	J	RMK5B			:CONTINUE

:	COME HERE ON 00,01 AND 02 CHARACTER PAIRS
RMKC00	LIS	R0,0			:CREATE THE '00'
	JFS	RMKC0X

RMKC01	LIS	R0,1			:CREATE THE '01'
	JFS	RMKC0X

RMKC02	LIS	R0,2			:CREATE THE '02'

RMKC0X	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RMKIG			: CHANNELS 0 AND 1

	SIS	CD,1			:ROOM IN LOGICAL RECORD FOR BOTH BYTES?
	JG	RMKC0Z			:YES, GO STORE THEM

:	NO ROOM FOR CHARACTER PAIR IN LOGICAL RECORD. DECREMENT
:	LRC, AND PUT CHARACTER BACK IN BUFFER.

	SIS	LRC,1			:LOGICAL RECORD SHORTER THAN EXPECTED
	JGFS	RMKC0Y
	CRASH.(.RMZLR)
RMKC0Y	LR	R1,R0			:GET THE CHAR TO R1
	ST	R3,BB,R2,		:SET UP BB FOR CALL TO WCD
	JAL	R8,WCD			:PUT CHAR BACK IN BUFFER
	J	RMK12			:DONE WITH LOGICAL RECORD

RMKC0Z	STB	R0,0,PRD		:STORE THE FIRST CHARACTER
	ST	R3,BB,R2,		:SET UP FOR CALL TO GCI
	JAL	R8,GCI			:GET THE SECOND CHARACTER
	L	R3,BB,R2,		:GET THE NEW POINTER
	AIS	PRD,1			:INCREMENT PACKET POINTER
	STB	R1,0,PRD		: AND STORE SECOND CHARACTER
	AIS	PRD,1
	SIS	CD,1			:ADJUST COUNT FOR SECOND CHARACTER
RMKCZZ	LR	CD,CD			:ENTRY POINT FROM RMK3TB, CHECK AGAIN
	JN	RMK5			:MORE DATA TO MAKE - GO DO IT
					: (R3 ALREADY SET UP)
	J	RMK12			:DONE WITH THIS LOGICAL RECORD

:	COME HERE TO IGNORE SPECIAL CHARACTERS -- ALSO EXIT AREA

RMKIG	SIS	CD,1			:DECREMENT COUNT SINCE MICROCODE DIDN'T
	JG	RMK5A			:MORE TO DO
	STB	R0,0,PRD		:IN CASE MICROCODE DIDN'T STORE IT
	J	RMK5XT			:GO FIX R12, (PRD), TEST FOR EMPTY BUFF

::	COME HERE ON '03' CHARACTER PAIRS -- TYMNET II
::	R3 = POINTER TO SECOND CHAR IN 03-XX PAIR
::	R12 (PRD)  = POINTER TO BYTE IN PHYSICAL RECORD JUST 'FILLED' WITH 03
::	CD HAS NOT BEEN DECREMENTED TO REFLECT THE 03 CHARACTER
::	03 CHAR HAS BEEN WRITTEN TO PHYSICAL RECORD ONLY IF R12 (PRD) IS EVEN

RMKC03	LIS	R0,3			:CREATE A '03' 
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RMKIG			: CHANNELS 0 AND 1
	SIS	CD,1			:ROOM FOR 03-XX CHAR PAIR
					: IN LOGICAL RECORD?
	JGFS	RMKC3A			:YES - HANDLE 03-CHARACTER PAIR
	SIS	LRC,1			:NO, LOGICAL REC WILL BE SHORTER
					: THAN EXPECTED
	JG	RMKC0Y			:RETURN 03 TO BUFFER,
					: FINISH LOGICAL RECORD
	l	r0,be,r2,		:helpful in debugging
	CRASH.(.RMZL3)
RMKC3A	LB	R1,0,R3			:LOOK AT 2ND CHARACTER
	CLHI	R1,20			:PERFORMANCE MONITORING OR HIGHER?
	JGEFS	RMKC3B			:YES, STUDY FURTHER
	CLHI	R1,NEEDP&0FF		:IS IT A NEEDLE?
	JE	RMKNEE			:YES, GO PROCESS NEEDLE
	IF	BFLTMR			:possibility of a bfr timer? ###jhl
	CLHI	R1,COMET&0FF
	JE	RMKBFD			:if so, jump to COMET-handler
	EI	:BFLTMR
	JL	RMK03N			:0300-030F, NETWORK CHARACTER PAIR
	J	RMKC0Z			:NONE OF ABOVE, JUST PASS CHAR ON

RMKC3B	CLHI	R1,3F			:pass all above 3f
	JG	RMKC0Z			:not a perfomance monitor
       IF	LOGII
	CLHI	R1,NEEDHD&0FF		:needle head
	JL	RMKPFM			:not a needle, must be perf mon car
	JE	RMKNHD			:LOG II needle
	CLHI	R1,NEEDTL&0FF		:(032b) needle tail
	JG	RMKPFM			:a perfomance monitor char
	J	RMKC0Z			:put needle char in logical record
       ELSE	:not logII
	J	RMKPFM			:20-3F are perfomance monitoring
       EI	:LOGII

       IF	LOGII
:	do needle housekeeping for LOG II needle
RMKNHD	ST	R3,BB,R2,		:char was read from buffer
	LIS	R0,1			:more active channels on the link
	AHM	R0,ANCHN,KD
	LR	R0,CHN
	SRLS	R0,1			:chn # (from times 2)
       if	aplybp			:set xmit bp type
	TBT	KN,VACTBP		:apply/release logic on the link?
	JEFS	RMKNH1			:nope
	SBT	R0,ABPVCP,R7,		:start off with bp released
       ei	:aplybp
rmknh1	RBT	R0,NEEDLE,R7,
	JNFS	RMKNH2			:was a needle for this chn
	LR	R9,R0
	CRASH.(.RMKNE)
RMKNH2	JAL	R8,NEDTIM,,		:save needle travel time
	LH	R8,NEDOUT,KD		:one fewer outstanding needle
	JGFS	RMKNH3			:must be positive
	CRASH.(.RMNER)
RMKNH3	SIS	R8,1
	STH	R8,NEDOUT,KD
	JNFS	RMKNH4			:now at no outstanding needles?
	LB	R0,NEDSUS,KD		:IS THERE A SHRINK SUSPENDED?
	JEFS	RMKNH4			:NO
	lis	r0,0
	stb	r0,nedsus,kd		:remove suspension

::	THERE WAS A SHRINK SUSPENDED AND NO NEEDLES ARE NOW OUTSTANDING.
	jal	r8,shrink		:so do the shrink
	j	rmkzp8			:shrink snip is +0 return
					:+4 is okay
RMKNH4	L	R3,BB,R2,		:restore the destroyed
	LIS	R0,3
	LHI	R1,NEEDHD&0FF
	J	RMKC0Z			:continue processing

       EI	:LOGII

::	RMKNEE
::	PROCESS NEEDLE

RMKNEE	ST	R3,BB,R2,		:SAVE BB
	JAL	R8,NCI			:SKIP A CHAR
	JAL	R8,NCI			:SKIP ANOTHER
	JAL	R8,PCI			:PEEK AT THIS ONE -- BYTE COUNT IN R1
	CLHI	R1,-2,PRC		:WILL IT FIT IN THIS RECORD?
	JG	RMKNE5			:NO, BACK UP

	LIS	R0,1
	AHM	R0,ANCHN,KD		:INCREMENT NUMBER OF ACTIVE CHANNELS
	LR	R0,CHN
	SRLS	R0,1			:RELATIVE CHANNEL NUMBER
       IF	APLYBP			:set xmit bp type
	TBT	KN,VACTBP		:apply/release logic on the link?
	JEFS	RMKNE1			:nope
	SBT	R0,ABPVCP,R7,		:start off with bp released
       EI	:APLYBP
RMKNE1	RBT	R0,NEEDLE,R7,		:INDICATE NEEDLE HANDLED
	JNFS	RMKNE4
	LR	R9,R0			:PRESERVE ABSOLUTE CHANNEL NUMBER 
	CRASH.(.RMKNE)

::	DECREMENT NUMBER OF NEEDLES OUTSTANDING BETWEEN CRQ AND RMAKE.
:: 	IF NEDOUT=0 AND NEDSUS<>0, THEN A LINK SHRINK HAS BEEN SUSPENDED
::	AND SHOULD BE RE-SCHEDULED.
::	had to reorder code here since shrink must occur after set and
::	reset all associated bits (NEEDLE).

RMKNE4	LH	R8,NEDOUT,KD		:NUMBER OF NEEDLES OUTSTANDING
	JGFS	RMKNE2			:SHOULD BE POSITIVE
	CRASH.(.RMNER)
RMKNE2	SIS	R8,1
	STH	R8,NEDOUT,KD		:NEW COUNT OF NEEDLES OUTSTANDING
	JNFS	RMKNE3			:OTHERS STILL TO PROCESS
	LB	R0,NEDSUS,KD		:IS THERE A SHRINK SUSPENDED?
	JEFS	RMKNE3			:NO
	lis	r0,0
	stb	r0,nedsus,kd		:remove suspension
::	THERE WAS A SHRINK SUSPENDED AND NO NEEDLES ARE NOW OUTSTANDING.
	jal	r8,shrink		:so do the shrink
	j	rmkzp8			:shrink snip is +0 return
					:+4 is okay
RMKNE3	LR	LRC,R1			:INSURE LOGICAL RECORD COUNT
					: INCLUDES ENTIRE NEEDLE
	LHI	CD,-1,LRC		:SUBTRACT 1 FOR '03' CHARACTER
	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME, SET CIRCUIT TIME
	L	R3,BB,R2,		:RESTORE BB
	LIS	R0,3			:CREATE FIRST CHARACTER AGAIN
	J	RMKC0Z


RMKNE5	LIS	R1,3			:NEEDLE WON'T FIT -- BACK UP
	JAL	R8,WCD			:PUT '03' BACK IN BUFFER

::	ARTIFICIALLY EXTEND LENGTH OF PACKET BY STORING A COUPLE OF EXTRA
::	NULLS. IF LAST THING IN PACKET WAS PAGE CHANGE COMMAND TO HANDLE NEEDLE
::	CHANNEL, NEIGHBOR'S RTD WILL NOT NOTICE IT DUE TO TEST IN RTD1 ASSUMING
::	3 OR MORE CHARACTERS IN LOGICAL RECORD.

	LIS	R1,0
	STB	R1,-2,PRD,		:NGHBR INTERPRETS NULLS AS END-OF-PACKT
	STB	R1,-1,PRD,
	SIS	PRC,2			:MAKE PACKET COUNT CONSISTENT

	SRLS	CHN,1			:GET CHANNEL NUMBER
	SBT	CHN,CHSRVD,R7,		:NEEDLE WILL BE 1ST REC IN NEXT PACKET
	J	RMKXIT

	IF	BFLTMR			:if buffer timer pairs enabled?
:	This is the COMET (0314) handler.	
RMKBFD	ST	R3,BB,R2,
	JAL	R8,GCI			:read out the 14 (03 already out)
	JAL	R8,GCI			: followed by two consecutive
	LR	R4,R1			: bytes of FASTC
	EXBR	R4,R4			:they're unescaped, so we write our
	JAL	R8,GCI			: own retriever
	AR	R1,R4			:put the result in R1
	LHL	R0,FASTC+2,,		:what time is it now?
	SR	R0,R1			:difference into R0
	AHM	R0,BDLACC,KD		:add into halfword accumulator
	LHL	R0,BDLCNT,KD
	AIS	R0,1			:and bump the frequency counter
	STH	R0,BDLCNT,KD
:	adjust the buffer pointers and counters?
	L	R3,BB,R2,		:restore BB to R3
	SIS	CD,3			:adjust char out count for these 3 char
	SIS	LRC,4			:adjust LRC to ignore four timing chars
	LR	CD,CD			:TEST CODE
	JE	RMK12			:TEST CODE
	J	RMK5			:restart the RMKCOPY instructions
	EI	:BFLTMR

::	RMK12:
::	RECORD TRAFFIC STATISTICS AND UPDATE BACKPRESSURE FOR CHANNEL.
::	INSERT LOGICAL RECORD COUNT FIELD AND HEADER.
::	IF REBUILD IS ENABLED AND THE CIRCUIT IS A TERMINATION COPY
::	USER DATA INTO THE CIRCUIT'S HISTORY BUFFER.
::	EXPECTS PRD TO POINT BEYOND LAST DATA BYTE IN RECORD, LRC=BYTE COUNT

RMK12	LR	LRC,LRC			:NO ZERO LENGTH RECORDS
	JNFS	RMK122
	LHI	R0,LS.ZLR		:INDICATE ATTEMPT TO MAKE ZERO-LENGTH
	J	RMKSNP			: RECORD AND GO SNIP THE LINK

RMK122	AM	LRC,KS.LCO,KD		:COUNT LOGICAL CHARACTERS OUTPUT
	LIS	R3,1			:TO INCREMENT LOGICAL RECD FIELD###jhl
	AHM	R3,KS.LRM,KD		:ADD IT INTO LAST MINUTE'S COUNT###jhl

	SHI	PRC,2,LRC		:NOW UPDATE PRC
	LHL	R3,BPSCNT,R6,CHN	:UPDATE CHAN BACKPRESSURE COUNT LIMIT
	SR	R3,LRC			:SUBTRACT OUT CURRENT LOGICAL REC SIZE
	sth	r3,bpscnt,r6,chn
	SRLS	CHN,1			:GET ACTUAL CHANNEL NUMBER

	sis	R3,8			:NEW BACKPRESSURE LIMIT >8 BYTES?
	JGFS	RMK13			:OK. ELSE MARK BACKPRSR LIMIT EXHAUSTED
	RBT	CHN,LNKBPV,R7,		:BY CLEARING CHAN'S BACKPRESSURE FLAG
	RBT	CHN,CHSRVD,R7,		:ENSURE CHAN NOT SERVICED AGAIN UNTIL 
					:NGHBR REFRESHES BACKPRESSURE RESTRICTN
RMK13	LR	R9,PRD			:FORM THE LOGICAL RECORD HEADER
	SR	R9,LRC			:COMPUTE POINTR TO BEGIN OF LOGICAL REC
	STB	CHN,-1,9,		:INSERT CHANNEL NUMBER AND
	STB	LRC,-2,9,		: LOGICAL REC COUNT (DATA BYTES ONLY)

	XHI	R2,4			:FLIP TO OTHER BUFFER
	LH	R1,BF,R2,		:GET SOURCE ABSOLUTE CHANNEL NUMBER
	JLFS	RMK132			:BUFFER RETURNED
					: DUE TO ZAPPER BEING PROCESSED
	TBT	R1,TRCHAN,,		:TRACING DESIRED FOR THIS CHANNEL?
	JEFS	RMK132			:NO
	LCS	R0,1			:YES, INDICATE TRACING OUTBOUND DATA
	JAL	R8,CHRTRC		:MAKE ENTRY IN TRACE TABLE

	IF	REBILD
	LR	R9,PRD
	SR	R9,LRC			:RESTORE R9
	EI	:REBILD

RMK132	XHI	R2,4			:RESTORE BUFFER INDEX

::	CREATE HISTORY USING RTD MICROINSTRUCTION FOR TERMINATING 
::	CHANNELS WITH REBUILD ENABLED.
::
::	THE HISTORY BUFFER RULES ARE: ONLY DATA THAT THE USER WILL
::	RECEIVE GOES INTO THE BUFFER. SQACKS, SQFIXS AND NEEDLES
::	DON'T MAKE HISTORY. FAT GOBBLERS ARE CONVERTED TO NORMAL
::	GOBBLERS AND SAVED.
::
::	NOTE!!! THAT R4 PRESERVES THE BUFFER NUMBER FOR RMHFIN!!!

	IF	REBILD
	LR	R4,R2			:SAVE THE OUTBOUND BUFFER NUMBER IN R4
	SRLS	R2,3			:FORM REBUILD BIT ARRAY INDEX
	TBT	R2,CRQBSY		:IS REBUILD ENABLED HERE?
	JE	RMK17			:NO, SKIP ALL THIS STUFF
	AR	R2,R2			:YES, FORM THE HISTORY BUFFER NUMBER
	AI	R2,HBUFN,R2		:BY ADDING IN THE BASE HISTORY BUFFER #
	SR	PRD,LRC			:BACK UP PRD TO 1ST BYTE OF DATA IN REC
	LR	CD,LRC			:MICROCODE USES CD FOR WORKING BYTE CNT
	
::	RMHIST
::	INITIAL ENTRY POINT TO PERFORM RTD MICROCOPY, AND ALSO CONTINUATION
::	POINT AFTER PROCESSING SPECIAL CHARACTER PAIRS

RMHIST	L	R3,BE,R2,		:CURRENT HISTORY BUFFER 'IN' POINTER
	JNFS	RMHIS1			:BUFFERLET ALREADY ALLOCATED
	JAL	R8,WCFRST		:GET A BUFFERLET
	SIS	R3,1			:INITIALIZE R3 (BE) FOR MICROCODE

RMHIS1	LHL	R0,0,R3			:SET UP SCRATCH REGISTER
	EXHR	R0,R0
	LHL	R1,0,PRD
	OR	R1,R0

RMKHSA	HC	3B1D		:RTD Copy 1 - USING R1=SCRATCH, CD=COUNT
RMKHSB	HC	3C1D		:RTD Copy 2 - HERE AFTER GETTING NEW BUFFERLET
	HC	RMKHSN-RMKHSB		:TO GRAB ANOTHER BUFFERLET
	HC	RMKHS0-RMKHSB		:TO HANDLE ESCAPED CHARACTERS
	HC	RMKHS1-RMKHSB		:PREFIX CODES
	HC	RMKHS2-RMKHSB		:T-I GOBBLERS?
	HC	RMKHS3-RMKHSB		:T-II 03-XX CHAR PAIRS AND QUADS

:	DONE WITH RTD
	ST	R3,BE,R2,		:DONE - STORE BUFFERLET END POINTER
	J	RMHFIN			:GO HANDLE XSEQN UPDATES, SQFIXS, ETC.

:	HERE TO GET A NEW BUFFERLET
RMKHSN	JAL	R8,NXTBLT		:GET ANOTHER BUFFERLET
	JBS	RMKHSB			:RESUME PROCESSING

::	HERE TO HANDLE 00 AND 01 CHARACTER PAIRS. PASS THE CHARACTER PAIR ALONG.
::
::	THE 03-XX CHARACTER PAIR CODE TRANSFERS TO 'RMHSPA' IF IT DETERMINES
::	THAT THE CHARACTER PAIR IN QUESTION CAN BE HANDLED AS A PPREFIX CODE.

RMKHS0	LIS	R1,0			:PASS ON THE 00
	JFS	RMHSPA
RMKHS1	LIS	R1,1			:PASS ON THE 01
RMHSPA	ST	R3,BE,R2,		:STORE 'BE' - NEEDED FOR 'WCI' CALL
	STB	R1,0,R3			:STORE AWAY THE 00, 01, OR 03
	LB	R1,0,PRD		:NEXT BYTE (MICROCODE INCREMENTED PRD)
	JAL	R8,WCI			:WRITE IT INTO THE HISTORY BUFFER
	AIS	PRD,1			:ADVANCE PRD TO DATA BEYOND CHAR PAIR
	SIS	CD,2			:REDUCE REMAINING BYTE COUNT BY 2
	JG	RMHIST			:MORE DATA IN LOGICAL RECORD - CONTINUE
	JE	RMHFIN			:NO MORE DATA IN LOGICAL REC, FINISH UP
	CRASH.(.RMKHS)			:NEGATIVE LOGICAL RECORD COUNT

RMKHS2	CRASH.(.RMHS2)			:ILLEGAL 02 FOR HISTORY BUFFER	###TZ

::	RMKHS3:
::	HERE TO HANDLE 03-XX CHAR PAIRS BOUND FOR THE HISTORY BUFFER.
::	REBUILD CONTROL QUADS (SQFIX, SQACK) AND NEEDLES DO
::	NOT GO INTO THE HISTORY BUFFER AND DO NOT ADVANCE XSEQN.
::	FAT GOBBLERS ARE SHRUNK AND STORED AS NORMAL GOBBLERS. OTHER
::	03 PAIRS ARE TREATED AS DATA.

RMKHS3	LB	R0,0,PRD		:SEE WHAT THE NEXT CHARACTER MIGHT BE
       if	logii
	clhi	r0,needtl&0ff		:is it needle tail?
	je	rmhsnt
       ei	:logii
	CLHI	R0,SQFIX&0FF		:IS IT A SQFIX?
	JE	RMHS3A			:YES
	CLHI	R0,SQACK&0FF		:OR A SQACK
	JE	RMHS3A			:YES
	CLHI	R0,20			:A PERFORMANCE MONITORING CHARACTER?
	JGE	RMHSPM			:YES, EXTRACT IT
	CLHI	R0,NEEDP&0FF		:OR A NEEDLE?
	JEFS	RMHSNE			:YES, A NEEDLE
	CLHI	R0,GOBBF&0FF		:A FAT GOBBLER?
	JEFS	RMHSFG			:YES, SHRINK IT
RMHS3B	LIS	R1,3			:NONE OF ABOVE - SOME HARMLESS 03-XX
	J	RMHSPA			: PAIR OR SHRUNKEN FAT GOBBLER.
					: PASS IT ON INTO BUFFER
RMHSNE	AHI	PRD,-1,LRC		:NEEDLE, RESTORE PRD TO POINT BEYOND
	JAL	R9,RSTRIP		:FREE UP POSSIBLY ALLOCATED BUFFERLET
	J	RMK17			:AND GO ON TO NEXT LOGICAL RECORD

RMHSFG	LIS	R1,3			:FAT GOBBLER - SHRINK IT. FORM THE '03'
	STB	R1,0,R3			:AND STUFF IT INTO BUFFERLET
	LIS	R1,8			:DO THE SAME FOR THE '08''
	ST	R3,BE,R2,		:SET UP 'BE' FOR WCI CALL
	JAL	R8,WCI			:WRITE THE 08 INTO HISTORY BUFFER
	AIS	PRD,5			:ADVANCE PRD BEYOND THE LAST 'FAT' BYTE
	SIS	LRC,4			:ADJUST LRC - ADVANCE XSEQN ONLY BY 2
	SIS	CD,6			:ALSO REDUCE THE WORKING BYTE COUNT
RMHSP1	JG	RMHIST			:MORE DATA
	JE	RMHFIN			:ALL DONE
	CRASH.(.RMHS4)
:	this rstrip was left out.  needed since bflet may have been allocated
RMHSPM	jal	r9,rstrip		:doesn't make history
rmhsp2	AIS	PRD,1			:ADVANCE PRD BEYOND PERF. MONITOR
	SIS	LRC,2
	SIS	CD,2
	JBS	RMHSP1

:	this is a bit of an ouch.  bug is logii needle head and body can
:	be written into history bufferlets.  As the needle does not travel
:	as a contigious block there is no easy way to not put data from
:	the needle head and body into the history bufferlets.  As needle
:	tail follows head and body then all needle tail has to do is empty
:	the history bufferlets and reset seqn number back to zero.  ie
:	pretend the needle data was never written to history bufferlets
       if	logii
rmhsnt	jal	r8,cbclr		:empty history bufferlets
	lis	r0,0			:seqn number of start of session
	st	r0,seqn,r2,		:nothing ever in bufferlets
	st	r0,xseqn,r4,		:no seq ever sent out
	lr	lrc,cd			:don't count needle body data in xseqn
	j	rmhsp2			:finished with needle tail
       ei	:logii

RMHS3A	JAL	R9,RSTRIP		:SOME 03-XX QUAD THAT WON'T MAKE HSTORY
	SIS	LRC,6			:SO QUAD DOESN'T ADVANCE XSEQN
	AIS	PRD,5			:ADVANCE PRD BEYOND THE CHARACTER QUAD
	SIS	CD,6			:REDUCE REMAINING BYTE COUNT BY 4
	JG	RMHIST			:MORE DATA IN LOGICAL RECORD - CONTINUE
	JEFS	RMHFIN			:NO MORE DATA IN LOGICAL RECORD
					: - FINISH UP
	CRASH.(.RMHS3)

:	FINISH UP. R4=ORIGINAL OUTBOUND BUFFER, LRC=LOGICAL REC COUNT
:	ADJUSTED FOR 03-XX CHARACTER QUADS. PRD POINTS BEYOND THE LAST BYTE
:	IN THE LOGICAL RECORD JUST MADE. PRUNE BACK THE HISTORY
:	BUFFER IF NEEDED, AND ADD THE MODIFIED LRC INTO XSEQN.

RMHFIN	LHI	CD,CBSZ-cbptsz		:HIST BUFFER EXCEED ALLOCATED MAXIMUM?
	LH	R1,BCT,R2,		:CURRENT APPROXIMATE BUFFER SIZE
	LHL	R0,RHBSZ,R2,		:MAXIMUM ALLOWED SIZE (FROM LEP OR CRQ)
	SR	R1,R0			:FORM THE DIFFERENCE BETWEEN THEM
	SR	R1,CD			:could have 2 bflets for 2 chars
	JLEFS	RMKFI1			:none to remove
	LR	R0,R1			:count to remove
	JAL	R9,RTBFTA		:approximate since not split char pair
	AM	R0,SEQN,R2,		:r0 gets actual number returned

::	SEND A SQFIX TO THE OTHER END IF AT LEAST 'SQNUMB' CHARS HAVE
::	BEEN SENT SINCE LAST SQFIX

RMKFI1	L	R0,XSEQN,R4,		:GET THE LATEST SEQUENCE NUMBER
	AM	LRC,XSEQN,R4,		:AND UPDATE IT BY OUTGOING COUNT
	X	R0,XSEQN,R4,		:TEST IF TIME FOR A SQFIX	###GT
	THI	R0,SQNUMB		:IF WE'VE PASSED SQNUMB HEX BYTES
	JE	RMK17			:NO, NOT TIME YET

	LR	R2,R4			:SET R2=BUFFER NUMBER FOR WCD CALL
	SRLS	R4,3			:TIME. CHECK IF ANY SQACKS HAVE COME IN
	TBT	R4,CRQBSY		:YES, AT LEAST ONE HAS. SEND A SQFIX
	JE	RMK17			:DISABLE REBUILD, CARRY ON WITH RMAKE

RMKFI3	L	R1,XSEQN,R2,		:GET LATEST XMIT SEQUENCE NUMBER
	LHL	R0,REBDIS,,		:DISPLAY SQF ACTIVITY?
	JEFS	RMKFI5			:NO
	ST	R1,CRYSBF		:DISPLAY SEQN SENT
	LHL	R0,BF,R2,		:CHANNEL #
	JAL	R8,CRYPTO,,		:LOG THIS###OAS(MAKE RX3)
	HC	CRYE6F
RMKFI5	JAL	R8,WCD			:PREFIX IT IN A BYTE AT A TIME
	EXBR	R1,R1			:LOW ORDER HW FIRST		###GT
	JAL	R8,WCD
	EXHR	R1,R1			:THEN HIGH ORDER HW		###GT
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD
	LHI	R1,SQFIX
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD

	EI	:REBILD

RMK17	CLHI	PRC,0A			:AT LEAST 10 BYTES LEFT IN FRAME?
	JGE	RMKNCH			:YES, LOOK FOR MORE records TO MAKE
	J	RMKXIT			:NO, EXIT RMK

::	RMK03N:
::	PROCESS NETWORK 03-XX CHARACTER PAIR.
::	STORE THE '03'CHARACTER INTO THE LOGICAL RECORD. EXTRACT THE
::	SECOND BYTE OF THE PAIR WITH A GCI CALL AND STORE IT TOO.
::	ADVANCE 'PRD' TO POINT BEYOND THE PAIR. ADJUST 'CD'. FINALLY,
::	DISPATCH ON CHAR PAIR TYPE TO SEE IF YOU'VE DONE THE RIGHT THING.

RMK03N	STB	R0,0,PRD		:MAKE SURE THE '03' WAS STORED
	AIS	PRD,1			:ADVANCE PRD TO CHAR FOLLOWING THE '03'
	ST	R3,BB,R2,		:NOW REMOVE THE SECOND CHARACTER...
	JAL	R8,GCI			:...USING A GCI CALL
	SIS	CD,1			:DEC WORKING LRC TO ACCNT FOR CHAR PAIR
	STB	R1,0,PRD		:COPY SECOND CHAR INTO OUTPUT RECORD
	AIS	PRD,1			:ADVANCE PRD BEYOND CHAR PAIR
	SLLS	R1,2			:FW indexing			###wjl
	L	R8,RMK3TB,R1,		:GET DISPATCH ADDR BASED ON 2ND ###wjl
	SRLS	R1,2			:				###wjl
	JR	R8			: BYTE OF 03-PAIR		###wjl


::	RMKGOB:
::	GOBBLER. IF THIS END IS A TERMINATION AND THE NEIGHBOR CAN HANDLE IT
::	AND REBUILD IS ENABLED CHANGE THE GOBBLER TO A FAT GOBBLER BY FORCING
::	LRC TO 6, AND STUFF THE CURRENT XSEQN BEHIND THE FAT GOBBLER.
::	NOTE THAT THIS XSEQN GOES UP TO, BUT DOES NOT INCLUDE, THE
::	FAT GOBBLER ITSELF.
::	ALSO NOTE THAT FAT GOBBLERS LEAVE THEIR ORIGINATING NODE
::	IN THEIR OWN LOGICAL RECORD, WITH NO ACCOMPANYING DATA.
::	IF THE FAT WON'T DO, PASS THE SKINNY GOBBLER ON UNMOLESTED.

RMKGOB	HS	0
	IF	REBILD
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE REBUILD STUFF?
	JLE	RMKCZZ			:NO, PASS ON THE GOBBLER
	JAL	R9,RMKFCH		:MAKE SURE GOBBLER IS FIRST CHARACTER
					:if not J RMK12, GET IT NEXT TIME###wjl
	LR	R0,R2
	SRLS	R0,3			:IS THIS A TERMINATING CHANNEL?
	TBT	R0,CRQEND
	JE	RMKCZZ			:NO, NOT A TERMINATION
	LIS	LRC,6			:YES - FORCE LRC TO 6
	L	R0,XSEQN,R2,		:GET THE LATEST XMIT SEQUENCE NUMBER
	STB	R0,3,PRD		:STORE AWAY THE LOWER BYTE
	EXBR	R0,R0
	STB	R0,2,PRD		:AND THEN THE UPPER BYTE
	EXHR	R0,R0			:NOW THE HIGH ORDER HW		###GT
	STB	R0,1,PRD		:				###GT
	EXBR	R0,R0
	STB	R0,0,PRD
	LIS	R0,9			:GOBBF&0FF BUT NAD WOULD CHOKE
	STB	R0,-1,PRD,		:CHANGE NORMAL GOBBLER TO FAT GOBBLER
	AIS	PRD,4			:ADVANCE PRD BEYOND THE 4 XSEQN BYTES
	J	RMK12			:TERMINATE LOGICAL RECORD BUILDING HERE
	ELSE	
	J	RMKCZZ			:NO REBUILD - PASS GOBBLER ON
	EI	:REBILD

:	RMKFGB:
:	FAT GOBBLER. STORE NEXT 4 BYTES (XSEQN) BEHIND FAT GOBBLER.

RMKFGB	JAL	R9,RMKFCH		:TEST FOR 1ST CHARACTER IN LOGICAL REC
					:if not J RMK12, GET IT NEXT TIME##GT
	JAL	R9,G2CI			:GET COUNT FROM BUFFER
	STH	R1,SQNSAV		:SAVE HO HALFWORD		###GT
	JAL	R9,G2CI
	LHL	R0,SQNSAV		:RESTORE HO OF SEQN
	EXHR	R0,R0
	OR	R1,R0			:AND SAVE IN R1				
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE FAT GOBBLERS?
	JGFS	RMKRBC			:YES				###wjl
RMKFG0	SIS	LRC,4			:NO, OLD VERSION
					: - LRC IS 4 LESS WITHOUT FAT
	LHI	R0,GOBBL		:CHANGE FAT GOBBLER TO NORMAL
	STB	R0,-1,PRD,		: GOBBLER IN PACKET
	JFS	RMKRC2
:	COMMON ENTRY POINT FOR CHARACTER-QUADS
RMKRBC	STB	R1,3,PRD		:STORE BUFFER DATA INTO PACKET
	EXBR	R1,R1
	STB	R1,2,PRD
	EXHR	R1,R1			:UPPER HW			###GT
	STB	R1,1,PRD
	EXBR	R1,R1
	STB	R1,0,PRD
	AIS	PRD,4			:INCREMENT RECORD POINTER AND
RMKRC2	SIS	CD,4			: DECREMENT LOGICAL RECORD WORKING CNT
	JE	RMK12			:DONE WITH NETWORK QUAD
	L	R3,BB,R2,		:MORE DATA - LOAD UP BB
	J	RMK5			: AND GO FINISH LOGICAL RECORD

:	RMKSQF:
:	SQF QUAD. JUST PASS IT ON IF NEIGHBOR CAN HANDLE IT

RMKSQF	JAL	R9,RMKFCH		:TEST FOR 1ST CHARACTER IN LOGICAL REC
					:if not J RMK12, GET IT NEXT TIME##wjl
	JAL	R9,G2CI			:GET SQF SEQUENCE NUMBER
	STH	R1,SQNSAV		:SAVE HO HALFWORD		###GT
	JAL	R9,G2CI			:LOWER HW OF SEQUENCE NUMBER
	LHL	R0,SQNSAV		:RESTORE
	EXHR	R0,R0			:PUT IN HIGH ORDER HW
	OR	R1,R0
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE SQF CHARACTERS?
	JG	RMKRBC			:YES - JUST PASS SQF QUAD ON...	###wjl

::	OLD VERSION NEIGHBOR - DON'T PASS ON THE SQF
::	SEND BACK A NAK USING SEQN=-1 SO WE DISABLE REBUILD
::	IMMEDIATELY INSTEAD OF WAITING FOR THE TIMEOUT

RMKOVR	LR	R4,R2			:SAVE R2			###GT
	SRHLS	R4,3
	TBT	R4,CRQEND		:IS THIS A TERMINATION?
	JN	RMKOV3			:DON'T SEND A NAK TO OURSELVES!
	XHI	R2,4			:FLIP TO OTHER BUFFER		###GT
	LHI	R1,SQFIX		:SEND BACK A SQFIX		###GT
	JAL	R9,W2CI
	LCS	R1,1			:SEND OUT A FULL-WORD OF -1
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	XHI	R2,4			:RESTORE BUFFER INDEX
RMKOV3	SIS	PRD,2			:DECREMENT PRD PAST 03-PAIR
	SIS	CD,4			:MORE DATA IN LOGICAL RECORD?	###GT
	JEFS	RMKOV2			:NO - CANCEL LOGICAL RECORD
	SIS	LRC,6			:ADJUST LRC SINCE IGNORING SQF QUAD
	JGFS	RMKOV1
	CRASH.(.RMZL0)
RMKOV1	L	R3,BB,R2,		:RESTORE BB AND
	J	RMK5			: GO FINISH LOGICAL RECORD
RMKOV2	SIS	PRD,2			:BACK UP TO LOGICAL RECORD BEGINNING
	J	RMKNCH			:GO FIND NEW CHANNEL WITH WORK

::*********************************************************************
::
::	SUBROUTINE:	RMKFCH:
::	FUNCTION:	TEST FOR 03-XX PAIR FIRST CHARS IN LOGICAL RECORD.
::	CALLING SEQ:	JAL	R9,RMKFCH
::	INPUT:		R1 = SECOND CHARACTER IN 03-XX PAIR.
::	CALLS:		JAL	R8,WCD
::	RETURNS:	RETURN IF TRUE, ELSE PUT 03-XX PAIR BACK
::			IN BUFFER AND J RMK12
::
::*********************************************************************

RMKFCH	CLHI	LRC,2,CD		:IS THIS FIRST DATA IN LOGICAL RECORD?
	JER	R9			:YES - RETURN			###wjl

	SHI	LRC,2,CD		:LRC NOW COUNT OF ALL CHARS BEFORE SQF
	JAL	R8,WCD			:REPLACE 2ND BYTE (IN R1) OF SQF PAIR
	LIS	R1,3
	JAL	R8,WCD			:REPLACE FIRST BYTE OF PAIR
	SIS	PRD,2			:UNDO INCREMENTS OF PRD
	J	RMK12			: AND J RMK12			###wjl

::
::*********************************************************************

::	RMKFZP
::	FAT ZAPPER. STORE NEXT FOUR BYTES (NODE PAIR) INTO PACKET 
::	PRIOR TO ZAPPING LAST HALF OF CIRCUIT.

RMKFZP	JAL	R9,RMKFCH		:TEST FOR FIRST CHAR IN LOGICAL REC
					:if not J RMK12, GET IT NEXT TIME###GT
	JAL	R9,G2CI			:GET FIRST TWO BYTES
	STB	R1,1,PRD		: AND STORE IN PACKET
	EXBR	R1,R1
	STB	R1,0,PRD
	JAL	R9,G2CI			:AND SECOND PAIR...
	STB	R1,3,PRD
	EXBR	R1,R1
	STB	R1,2,PRD
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE FAT ZAPPERS?
	JGFS	RMKFZ2			:YES				###wjl
RMKFZ9	LHI	R0,ZAPPH		:NO, OLD VERSION - MAKE ZAPPER HARD
	STB	R0,-1,PRD,		: IN PACKET TO NEIGHBOR
	SIS	LRC,4			:NO NODE PAIR FOLLOWING ZAPPER...
	JFS	RMKFZ4
RMKFZ2	AIS	PRD,4			:INCREMENT RECORD POINTER
RMKFZ4	SIS	CD,4			: AND DECREMENT COUNT

::	RMKZAP
::	PROCESS ZAPPER ON TYMNET-II CHANNEL. ZAP 2ND HALF OF CIRCUIT,
::	DECREMENT NUMBER OF ACTIVE CHANNELS THIS LINK, AND TEST FOR ZAPPING
::	CIRCUIT IN THE PROCESS OF BEING BUILT.

RMKZAP	SR	LRC,CD
	JAL	R9,ZAPV,,		:NOW ZAP CIRC
	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT CHANNEL ZAPPED
	LR	R0,CHN
	SRLS	R0,1			:RELATIVE CHANNEL NUMBER
	RBT	R0,NEEDLE,R7,		:DID WE ZAP A NEEDLE?
	JE	RMK12			:NO - CONTINUE
::	WE ZAPPED A BUFFER WHICH CONTAINED A NEEDLE NOT YET PROCESSED
::	BY RMAKE. DECREMENT 'NEDOUT' TO MAINTAIN CONSISTENCY.
	LH	R8,NEDOUT,KD
	JGFS	RMKZP2			:IT'D BETTER BE POSITIVE
	CRASH.(.RMNE0)
RMKZP2	sis	r8,1			:DON'T HOLD UP SHRINK DUE TO NEEDLE...
	sth	R8,NEDOUT,KD		:NEW COUNT OF NEEDLES OUTSTANDING
	JNFS	RMKzp3			:OTHERS STILL TO PROCESS
	LB	R0,NEDSUS,KD		:IS THERE A SHRINK SUSPENDED?
	JEFS	RMKzp3			:NO

::	THERE WAS A SHRINK SUSPENDED AND NO NEEDLES ARE NOW OUTSTANDING.
	lis	r0,0
	stb	r0,nedsus,kd		:remove suspension
	jal	r8,shrink		:so do the shrink
	j	rmkzp8			:shrink snip is +0 return
					:+4 is okay
rmkzp3	LIS	R9,1
	AHM	R9,LKNEDS,KN,KN		:INDICATE NEEDLE GOBBLED
	LR	R0,CHN			:CHAN#*2
	SRLS	R0,1
	LHL	R8,NDID,KD
	STH	R8,CRYSBF+2
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM TO XRAY
	HC	CRYE0E			:(NEEDLE GOBBLED)
	J	RMK12

rmkzp8s	LIS	R0,LS.SNC		:NO - NOTHING TO SHRINK
	J	RmkSNP			:SNIP THE LINK


::	RMKPFM
::	PROCESS PERFORMANCE MONITORING CHARACTERS  ( 03 20 TO 03 3F )
::	THESE CHARS MUST BE THE FIRST CHARS IN THE OUTBOUND LOGICAL RECORD.
::	THE XLAX AND XLAX-ACK CHARS ARE PREFIXED INTO THE CHANNEL
::	BUFFER IN RTEAR, SO WILL ALWAYS BE AT THE TOP OF THE BUFFER,
::	BUT THE TIMER AND TIMER ACK CHARS MAY OCCUR ANYWHERE IN THE
::	BUFFER
::	ON ENTRY:
::	LRC	=	FINAL BYTE COUNT OF LOGICAL RECORD BEING MADE
::	CD	=	WORKING COPY OF LRC, DECREMENTED TO REFLECT '03' CHAR
::	R3	=	POINTS TO SECOND CHAR IN 03-XX CHAR PAIR
::	R1	=	SECOND CHAR IN 03-XX CHAR PAIR
::	R0	=	'03' CHAR IN CASE BRANCH TO RMKC0Z IS TAKEN

RMKPFM	CLHI	R1,PFMMAX		:VALID CHARACTER?
	JLEFS	RMKPF1			:YES
	CRASH.(.RMPER)
RMKPF1	LHI	R1,1,CD			:IS THIS FIRST BYTE IN LOGICAL RECORD?
	CR	LRC,R1			:IF CD+1 = LRC, THIS IS FIRST BYTE
	JE	RMKC0Z			:YES, PASS THE CONTROL CHAR ALONG
	SR	LRC,R1			:ELSE STOP BUILDING LOGICAL RECORD.
					: GET NEW LRC
	LIS	R1,3			:CREATE '03' FOR 03-XX PAIR
	ST	R3,BB,R2,		:SET UP BB FOR CALL TO WCD
	JAL	R8,WCD			:RESTORE 03 CHARACTER INTO BUFFER
	J	RMK12			:DONE WITH THIS LOGICAL RECORD

::*********************************************************************
::
::	TABLE:		RMK3TB:
::	FUNCTION:	DISPATCH TABLE FOR RMK 03-XX CHARACTER PAIRS
::
::*********************************************************************

RMK3TB	WC	RMKCZZ		:0300 RESERVED				###GT
	WC	RMKZAP		:0301 ZAPPH - HARD ZAPPER
	WC	RMKZAP		:0302 ZAPPS - SOFT ZAPPER
	WC	RMKZAP		:0303 ZAPPN - NON-GOBBLING ZAPPER
	WC	RMKFZP		:0304 ZAPPF - FAT ZAPPER
	WC	RMKCZZ		:0305 RESERVED				###GT
	WC	RMKCZZ		:0306 RESERVED				###GT
	WC	RMKCZZ		:0307 
	WC	RMKGOB		:0308 GOBBL - GOBBLER
	WC	RMKFGB		:0309 GOBBF - FAT GOBBLER
	WC	RMKCZZ		:030A UNUSED - PASS IT ON
	WC	RMKSQF		:030B SQFIF - REBUILD SEQ NUMBER FIX
	WC	RMKSQF		:030C SQACK - REBUILD SEQYENCE NUMBER ACK
	WC	RMKCZZ		:030D RESERVED
	WC	RMKCZZ		:030E RESERVED
	WC	RMKCZZ		:030F RESERVED

	SUBTTL  YAKYAK (RMKBRZ - rmake give transmit capability)

:	RMKBRZ  called directly from rmk and returns to RMKTW
:	HERE WHEN BPSCNT=0 FOR CHANNEL WE'RE ABOUT TO BUILD
:	LOGICAL RECORD FOR. LEGITIMATE ONLY FOR CHANNELS 0 & 1.
RMKBRZ	CLHI	CHN,2
	JLEFS	RMKBR0			:chn 0,1 have no limit
	SRLS	CHN,1			:make CHN*1
	RBT	CHN,BPSVCP,R7,		:if this node wanted to give output cap
	jnfs	RMKBR1			:nope, snip link
:	if count 0 then something illegal so snip
	LHI	R0,LS.BPZ		:INDICATE BPSCNT = 0
	J	RMKSNP			: AND SNIP THE LINK

RMKBR1	AR	CHN,CHN 		:back to chn*2
RMKBR0	LIS	R3,3
	NH	R3,NIOTAB,R6,CHN	:get speed bits
	LHL	R3,CIRSPK,R3,R3
	STH	R3,BPSCNT,R6,CHN
	J	RMKTW

	subttl  YAKYAK (RMK3 - rmk found no chn needing service)

:	RMK3	called directly from RMK and either exits or returns

::	RMK3
::	ALL CHANNELS ON THIS LINK HAVE BEEN SCANNED. COPY THE CURRENT
::	BACKPRESSURE FLAGS INTO THE CHANNEL SERVICE ARRAY FOR THE NEXT
::	EXECUTION OF RMAKE ON THE LINK

RMK3	LHL	R2,NCHN,KD		:NUMBER OF BITS
	SHI	R2,10			:(NUMBER OF 1/2 WDS -1)*10
	lr	r1,r2
	srls	r1,3
	LA	R0,LNKBPV,R1,r7		:PTR TO LAST HW IN BACKPRESSURE ARRAY
	LA	R1,CHSRVD,R1,R7		:MOVE BP ARRAY TO SERVICE ARRAY
	COPY	R0,R2			:MOVE THE ARRAY
					: (R0=SOURCE, R1=DEST., R2=LEN.)
	TS	RMRFLG			:only count 1 round robin per RMK call
	JLFS	RMK301			:already counted RR
	RBT	KN,LKRR			:NOTE ROUND ROBIN COMPLETED FOR LINK
	LIS	R1,1
	AM	R1,KS.RRC,KD		:INCREMENT ROUND-ROBIN COUNT FOR LINK
RMK301	TS	RMKFLG,KD		:if didn't look at every chn
	JE	RMKNCH			:GO LOOK FOR NEXT CHANNEL
	rbt	kn,bpmtiq		:send bp in spare packet room more
	jefs	rmkex1			:often than 1/2 sec (like 1/8 sec)
	clhi	prc,$a20		:don't start unless we have bandwidth
	jlfs	rmkex1			:to spare
:	+0 return means lack of room.  +4 return means all is okay
	jal	r9,rmkbpp		:for priority circuits
	sbt	kn,bpmtiq		:+0 return=ran out of room, reschedule
	JFS	RMKEX1			:serviced all chns (this and last time)

:	GENERAL EXIT POINT

RMKXIT	LIS	R0,0
	STH	R0,RMKFLG,KD		:didn't service all chns this pass
RMKEX1	LHL	CD,NRMK,KD		:RESTORE CD (RECORD DESCRIPTOR ADDRESS)
	L	R9,RTMXSV		:	AND GET RETURN ADDRESS
	JR	R9			:RETURN TO CALLER

	subttl  YAKYAK (RMKSHK - rmake part of link shrinks)

:	rmkshk  called directly from rmake and returns directly
:		handles rmake waiting on shrink activity
:
rmkshk
	SIS	R0,2			:RMAKE FROZEN?
	JGR	R9			:YES,WAITING FOR NEIGHBOR TO ACK SHRINK
	JE	RMKSH2			:SEND SHRINK COMMAND OR REQUEST,
					: DEPENDING ON WHETHER WE ARE MASTER
					: OR SLAVE
	LHI	R1,0E1			:SHSTAT=1, SEND SHRINK ACKNOWLEDGE
RMKSH1	LIS	R0,0
	STB	R0,SHSTAT,KD		:THAW RMAKE
	STB	R1,0,PRD		:SEND SHRINK REQUEST/ACKNOWLEDGE
	STB	R0,1,PRD		:PACKET < 2 BYTES WON'T GET NOTICED
	AIS	PRD,2
	SIS	PRC,2			:INCR CURRENT POINTER, DECR PACKET CNT
	JR	R9			:SHRINK COMMANDS TRAVEL BY THEMSELVES
RMKSH2	LHI	R1,0E0			:SHRINK REQUEST/COMMAND
	LH	R0,NDID,KD
	CLHI	R0,MACHNM		:ARE WE SLAVE ON THIS LINK?
	JG	RMKSH1			:YES - SEND SHRINK REQUEST TO MASTER
	STB	R1,0,PRD		:NO - SEND SHRINK COMMAND TO SLAVE
	LIS	R0,0
	STB	R0,1,PRD		:MAKE 2-BYTE RECORD
	AIS	PRD,2
	SIS	PRC,2
	LIS	R0,3			:FREEZE RMAKE UNTIL SLAVE RESPONDS WITH
	STB	R0,SHSTAT,KD		: SHRINK ACKNOWLEDGE
	JR	R9

	SUBTTL	YAKYAK (ILC - Inter-Link Control)

::*********************************************************************
::
::	SUBROUTINE:	ILC
::	FUNCTION:	Process Channel 0 messages received from neighbor.
::	CALLING SEQ:	J  ILC  (called directly from RTDXIT as part of
::				 RTD end processing.)
::	INPUT:		KD,R6
::	DESTROYED:	R1,R2,R3,R5,R8,R9,R10
::	CALLS:		JAL  R8,PCI
::			JAL  R8,CBCCT
::			JAL  R9,ZAPV
::			JAL  R10,TRACE
::	RETURNS:	JL   ILCRET  (returns from ILC process and goes
::					directly via  J  BPMV to process
::					backpressure received from neighbor.)
::
::*********************************************************************

ILC
RTDXIT	EQ	ILC			:PROCESS ANY ILC MESSAGE RECEIVED
	LHL	R2,NIOTAB,R6,		:ILC BUFFER
	NHI	R2,-4
	JNFS	ILC02			:GOT BUFFER NUMBER
	LIS	R0,LS.ILC		:PERMUTER TABLE ENTRY 0
	J	RTDSNP			:SNIP LINK, INDICATE CHN 0 PROBLEM

ILC02	LHL	R0,BCT,R2,
	JNFS	ILC03			:BUFFER IS EMPTY
:	RETURN FROM ILC PROCESS
ILCRET	L	R9,RTMXSV		:EXIT
	JR	R9

ILC03	JAL	R8,PCIS			:BYTE COUNT
	LR	LRC,R1
	JAL	R8,CBCCT		:CHARS IN BUFF
	CLHI	R1,2			:MUST BE AT LEAST 2 BYTES IN BUFFER
	JLBS	ILCRET			:not enough for a msg to exist
	CR	R1,LRC
	JGEFS	ILC05			:have enough in buffer

:	code to detect and snip link if waiting msg is invalid.  code
:	is not later under msg type since bad byte count could delay
:	msg processing for quite a while until enough data built up.
	JAL	R8,PCIS			:set up to get second char	
	JAL	R8,PCI			:get msg type
	CLHI	R1,ILCDMX
	JL	ILCRET			:type is valid so done for now
ILC04	LHI	R0,LS.IL2		:invalid ILC msg link snip reason
	J	RTDSNP

:	continue to process a recieved ILC msg
ILC05	JAL	R8,GCI			:DISCARD BYTE COUNT
	JAL	R8,GCI			:GET MESS TYPE
	CLHI	R1,ILCDMX		:must be legal
	JGEBS	ILC04			:UNKNOWN TYPE, snip link
	SLLS	R1,2			:FW indexing
	L	R1,ILCDIS,R1		:DISPATCH
	JR	R1			:				###wjl

ILCSKP	LHI	R5,-2,LRC		:DISCARD MESSAGE
ILCSK1	LH	R0,BCT,R2,		:FOR GARBAGE MESSAGE,
					: DON'T TRUST BYTE COUNT
	JE	ILCRET			:AVOID GCI CRASH...
	JAL	R8,GCI
	SIS	R5,1
	JGBS	ILCSK1
	J	ILC

ILCZAK	lhi	r0,ls.zpv		:ilc zap ack link snip reason
	J	rtdsnp

ILCTRC	CLHI	LRC,40			:TRACE
	JGE	ILCSKP			:TRACE TOO BIG, IGNORE
	SIS	LRC,1
	LIS	R1,03
	LIS	PRD,0
	JFS	ILCTRL			:COPY TRACE TO LEPMES BUFFER
ILCTR1	JAL	R8,GCI
ILCTRL	STB	R1,LEPMES,PRD
	AIS	PRD,1
	SIS	LRC,1
	JGBS	ILCTR1
	SIS	PRD,2
	LHL	CHN,LKZFKN,KN,KN	:COMPUTE ABS CHANN #
	AH	CHN,LEPMES,PRD
	NHI	CHN,7FFF
	STM	KN,TRREGS		:SAVE IMPORTANT REGS
	JAL	R10,TRACE,,		:DO CIRCUIT TRACE
	LM	KN,TRREGS
	J	ILC

:	GET 32-BIT KEY USED IN MULTI-LINE RESET
ILCKEY	SIS	LRC,6			:EXPECT LENGTH OF 6
	JN	ILCSKP			:INVALID LENGTH - NEIGHBOR FAULT?

	LCS	R9,4
ILCKY1	JAL	R8,GCI			:GET NEXT KEY BYTE AND
	STB	R1,RKEY+4,KD,R9		: AND STORE IN LINK DESCRIPTOR
	AIS	R9,1
	JLBS	ILCKY1			:GET ALL 4 BYTES
	J	ILC			:DONE

::********************************************************************
::
::	TABLE:		ILCDIS:
::	FUNCTION:	DISPATCH TABLE FOR ILC MESSAGES RECEIVED FROM NEIGHBOR
::
::********************************************************************

ILCDIS	WC	ILCSKP,ILCKEY,ILCZAK,ILCTRC
ILCDMX	EQ	(.-ILCDIS)/4

RMKEND	HS	0			:DEFINE END OF RMAKE FOR MACERR OPTION

	ENDMO.(YAKYAK)
	EI	:1-KILLIT
	KILMSG(YAKYAK)

:	***NOTHING PAST THIS POINT***

	SUBTTL	DISPI

       if	1-ncslot		:no dispatcher if switcher

:		****  *****  **** ****  *****
:		*   *   *   *     *   *   *
:		*   *   *    ***  ****    *
:		*   *   *       * *       *
:		****  ***** ****  *     *****

::#####################################################################
::
::	MODULE:		DISPI
::
::	FUNCTION:	INTERFACE TO THE ISIS DISPATCHER.
::
::	REGISTER CONVENTIONS:
::		TYC	= R11	:HOLDS MAGIC CONSTANT (03 OR 07)
::		TC	= R15	:FOR TRUNCATING RING POINTERS
::		PRD	= R12	:POINTER TO RECORD DATA
::		PRC	= R10	:PHYSICAL DITTO
::		CHN	= R5	:CHANNEL NUMBER
::		LRC	= R14	:LOGICAL RECORD BYTE COUNT
::		CD	= R13	:WORKING COUNT
::
::	SUBTTLS:
::	  	DISPI (TABLES)
::		DISPI (DISIN - MOVE DATA INTO DISPATCHER FROM NETWORK)
::		DISPI (DISOUT - MOVE DATA OUT OF DISPATCHER INTO NETWK)
::		DISPI (DSZERO - INTRA-ISIS COMUNICATIONS, RPORT = 0)
::		DISPI (UTILITY ROUTINES)
::		DISPI (CONSAT - LOGCHR)
::
::#####################################################################		

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE
	BEGMO.
	SEG	a.code
:	SUBTTL  DISPI (TABLES)

	IF	(1-T2GATE)	:Not used for Gateway configuration

::*********************************************************************
::
::	TABLE:		SCLTBL:
::	FUNCTION:	DEFINE LIMITS FOR NUMBER OF CIRCUITS/MINUTE 
::			AND NUMBER OF MESSAGES/MINUTE FOR EACH SLOT.
::
::*********************************************************************

:	CIRCUIT ACTIVITY LIMITS
SCLTBL	HS	0
	SYAD(SCLTBL)
Q	EQ	1
	RE	NUSLT
	HC	SCLT|$0Q|
Q	EQ	Q+1
	ER

::*********************************************************************
::
::	TABLE:		SMLTBL:
::	FUNCTION:	DEFINE SLOT REPORT LIMIT FOR EACH SLOT.
::
::*********************************************************************

SMLTBL	HS	0
	SYAD(SMLTBL)
Q	EQ	1
	RE	NUSLT
	HC	SMLT|$0Q|
Q	EQ	Q+1
	ER

::*********************************************************************
::
::	TABLES:		GHSTTB, GSHSTB, GCHSTB
::	FUNCTION:	IF RESTRICTED HOSTS HAVE BEEN DEFINED, SET UP
::			TABLES TO DEFINE HOST NUMBERS (GHSTTB),
::			HOST/SLOT RESTRICTIONS (GSHSTB),  AND
::			CIRCUITS PER MINUTE LIMITS (GCHSTB).
::
::*********************************************************************

	EI	:(1-T2GATE)	: end Gateway exclusion

:	define DSCALE for histogram shift facter

DSCALE	EQ	0
Q	EQ	20		:8 word entries in table
	RE	10		:biggest DRSZ is a HW
       IF	DRSZ-Q
Q	EQ	Q*2
DSCALE	EQ	DSCALE+1
       EI
	ER

	IF	RESHST

:	DEFINE ALL RESTRICTED HOSTS
GHSTTB	HS	0
	SYAD(GHSTTB)
Q	EQ	0
	RE	RESHST
	HC	GHST|$0Q|	:HOST NUMBER
Q	EQ	Q+1
	ER


:	DEFINE LEGAL SLOTS FOR EACH RESTRICTED HOST
GSHSTB	WS	0
	SYAD(GSHSTB)
Q	EQ	0
	RE	RESHST
	WC	GSHS|$0Q|	:BIT SET FOR LEGAL SLOT
Q	EQ	Q+1
	ER

:	DEFINE ACTIVITY LIMITS FOR EACH RESTRICTED HOST
GCHSTB	HS	0
	SYAD(GCHSTB)
Q	EQ	0
	RE	RESHST
	HC	GCHS|$0Q|	:CIRCUITS/MINUTE LIMIT FOR THIS HOST
Q	EQ	Q+1
	ER

	EI	:RESHST

:	bit assignments in psuedo needle request after local key
PSNIIX	EQ	8000		:pseudo needle request for IIX circuit
PSNELS	EQ	4000		:pseudo needle request for ext login status
PSNUUN	EQ	2000		:pseudo needle request for UUN

:	some local equates for immediate values
RDSPBP	EQ	0A100		:ring cmd to relieve backpressure
SDSPBP	EQ	0A000		:ring cmd to set backpressure
GRTLGN	EQ	0B600		:tell slot of successful logon
SUPRHNG	EQ	0B800		:super-(HDX) hang
XMTCAP	EQ	0B900		:ring cmd to set XMT capacity
UNUSNO	EQ	0C100		:universal user number (sup to slot)
DM.ISN	EQ	0C2		:LOG II needle
DM.RCR	EQ	0C3		:log II logon respone RCRI
DM.ICS	EQ	0C4		:subsequent log II logon data
DM.ASL	EQ	0C5		:assign log ii logon port
DM.LGS	EQ	0C6		:log II logon success
DM.ECR	EQ	12		:port 0 logII reject logon port

	SUBTTL	DISPI (DISIN - Move data into dispatcher from network)

::*********************************************************************
::
::	SUBPROCESS:	DISIN:
::	FUNCTION:	MOVES DATA FROM THE NETWORK INTO THE DISPATCHER
::			RING.
::	CALLING SEQ:	JAL	R10,DISIN  Called from SPIDER.
::		Dispatched based on buffered data requesting output to
::		the Dispatcher.  Yields after processing each requesting
::		port, passes control to next subprocess when no more
::		data is present or there is no room in the Dispatcher
::		bound data ring, or if neither of the two previous
::		events occur within 61 MS.
::
::*********************************************************************

DISIN	ST	R10,DSSVRT		:SAVE RETURN
:	PREVENT HOGGING CPU IN DISPATCHER PROCESS. DIDTIM WILL CONTAIN
:	FASTC TIME TO DISMISS BACK TO SPIDER EVEN IF WORK TO DO.
	L	R0,FASTC,,
	AHI	R0,TICDSI		:Run for only as long as assigned##sdw
XICDSI	EQ	.-2			:able to change tics from xray symbol
	SYAD(XICDSI)			:table
	ST	R0,DIDTIM
	lhi	r0,dis.hw*8-1		:number of chns to search
	sth	r0,ds.chn

:	RETURN HERE AFTER SERVICING EACH CHANNEL, AND YIELD EITHER IF
:	HIGHER PRIORITY TASK HAS BEEN SCHEDULED, OR IF OUR TIME SLICE IS UP.
:	Don't yield to EXEC, this is a high priority process and the only
:	job which is important enough to interupt us is bufzap, but since
:	DISIN empties buffers of data then have nothing to yield to	###sdw
DSINXT	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	DSINX1			:YES - CONTINUE FILLING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DIDISM
	J	DSIORT			:..RETURN

DSINX1
	LHI	TC,DRSZ-1
	LH	PRD,DRIF,,		:COMPUTE ROOM AVAILABLE
	LH	PRC,DRIE,,
	SR	PRC,PRD			:DRIE - DRIF
	JGFS	DISI05			:NO RING WRAP
	AI	PRC,DRSZ		:RING WRAP
:	minimum size is big enough so that don't have to worry about wrapping
:	ring when handling a port's signals and data.  Also, due to XICDSI if
:	the ring is nearly full then something else is broken and dispatcher
:	buffering is a real risk.
DISI05	CLHI	PRC,100			:MINIMUM ROOM CONSIDERED
	JLE	DSIORT			:PRC = no room available

:	LOCATE PORTS WITH INBOUND DATA

dis.hw	eq	(ndp+0f)/10*2		:number of HWs*2 for disp bit arrays

DISI10	lhl	r5,ds.chn		:get next chn to service
	ohi	r5,0f			:round up to next hw
	lr	r1,r5
	srls	r1,3			:make it into hw
	la	r3,dissvd-1,r1		:address to start searching
	la	r4,disflg-1,r1, 	:ports with data
	arand	r3,r5			:quickly search for both set
	kill	disi12
	jfs	disi12			:got one
	la	r0,disbpv+dis.hw-2	:last HW of BPed arrays
	la	r1,dissvd+dis.hw-2	:last HW of service array
	lhi	r2,dis.hw*8-10		:number of bits - 10 to copy
	copy	r0,r2			:move bits quickly
	jfs	dsiort			:none, exit
disi12	j	disi15			:service port
:	HERE TO RETURN MAIN
DSIORT	LHL	R3,DRIF,,		:gather some statistics
	SH	R3,DRIE,,		:how much in RING
	JGEFS	DSIOR1
	AI	R3,DRSZ
DSIOR1	CH	R3,DISICP		:new max amoung in ring
	JLEFS	DSIOR2
	STH	R3,DISICP		:
DSIOR2	SRHL	R3,DSCALE		:make histogram entry
	NHI	R3,1C			:keep it in range
	LIS	R0,1
	AM	R0,DSIHGM,R3
	JGEFS	DSIOR5			:zero all when use 32nd bit
	LIS	R0,0
	LHI	R1,1C			:zero all entries
DSIOR3	ST	R0,DSIHGM,R1,
	SIS	R1,4			:clear histogram
	JGEBS	DSIOR3
DSIOR5	L	R10,DSSVRT	
	JR	R10

:	THIS IS THE MAIN WORK LOOP-- MOVE DATA FROM BUFFERLETS INTO RING
:	FOR THE PORTS MARKED IN R1'S BIT ARRAY.
DISI15	RBT	CHN,DISSVD		:THIS PORT SERVICED
	sth	chn,ds.chn		:for a quck dsinxt logic
	LHL	R2,DIOTAB,CHN,CHN	:IOTAB ENTRY (OUTBOUND BUFF #)
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER NUMBER
	JNFS	DISI17
	CRASH.(.DISI0)			:DISPI FOUND NO DISPATCHER CIRCUIT
	J	DISI10			:GO TO SEE NEXT PORT

DISI17	XHI	R2,4			:SWITCH TO DISPI INBOUND BUFFER #
:	fix the bug of shortening records by 1 byte per escape. 	###sdw
:	And setup easier since don't have to calculate buffer size
	L	R3,BCT,R2,	 	:make sure data is in buffer
	JE	DISI10			:gateway kludge 0264 crash fix
	LHL	LRC,DIXLIM,CHN,CHN	:transmit limit
	sth	lrc,dixlft		:for multiple messages

:	multiple messages per pass return here
disi20	STH	CHN,DIRNG,PRD,
	STH	PRD,RPSAV		:write chn and where it to put len
	AIS	PRD,3


::**********************************************************************
::  if receiving unescaped data then use RMK instruction to rip the
::  data in buffs to ring.
::   o  don't do if less than 5 chars (overhead not worth it)
::   o	the first byte in the buffer is not a data char.
::   o  if going to wrap then just use rmk to about end of ring, (don't
::	worry about shrinkage due to escaped chars) finish msg and
::	could continue sending with another msg (probably byte by byte)
::	playing with counts when unescaping data is a mess when having
::	to worry about wrapping.
::
::**********************************************************************

       if	cmpnul
	tbt	chn,rcvesc		: receiving 04-07 as signals?
	je	disi50			: yes, can't use rmk
	JAL	R8,CBCCT		: CBCT - Compute BCT (get buffer count)
	CLHI	R1,5			: don't bother if less than 6 chars
	JL	DISI50			:  are available, to be moved
	li	r10,-drsz+5,prd		: prd+minsize-ringsize >= 0 ?
	JGE	DISI50			: too small to bother with
	L	R3,BB,R2,		: set up pointer to first char
	LB	R0,0,R3			: peek at the first char
	JEFS	disi21			: ok if escaped...
	SIS	R0,3			:  ...but not if special
	JLE	DISI50			: for these, use normal handling

:	going to use RMK instruction to move data. 

disi21	ai	prd,dirng		: point to where to store
	CR	R1,LRC			: is our limit chars or space?
	JGEFS	disi22			: space
	LR	LRC,R1			: LRC limited by chars avail
disi22	sis	r10,4			: len must not be past end of ring
	ar	r10,lrc			: subtract 5 added above and add len
	jlefs	disi24			: still not bigger than DRSZ
	sr	lrc,r10			: reduce by excess
disi24	LR	CD,LRC			: CD is our working reg of len

:	Have lots of entries due to oddities of RMK instructions
disi25	L	R3,BB,R2,		:GET CHARACTER OUT PTR
	SIS	PRD,1			:BACK UP TO LAST BYTE STORED
disi26	LHL	R0,0,PRD		:SET UP R1 AS SCRATCH
	EXHR	R0,R0			: REGISTER FOR THE
	LHL	R1,0,R3			: MICROCODE
	OR	R1,R0

::	RMAKE MICROCODE INSTRUCTION
::	R1 = scratch
::	CD = WORKING COPY OF LRC, # OF BYTES TO COPY
::	R12 = PRD  => POINTER TO OUTPUT RECORD
::	R3 = BB (address of next character to be output)
disi27	HC	0E1D			:RMAKE Copy 1 - SCRATCH REG, COUNT
disi28	HC	0F1D			:RMAKE Copy 2 - CONTINUATION ADDRESS
	HC	disi35-disi28		:TO RELEASE EMPTY BUFFERLET
	HC	disi40-disi28		:TO HANDLE CHARACTER PAIR
	HC	disi41-disi28		:TO HANDLE PREFIX CHARACTER
	HC	disi42-disi28		:To handle 02 char (unused)
	HC	disi43-disi28		:TO HANDLE GOBBLERS/ZAPPERS

:	DONE WITH RMAKE COPY FOR THIS CHANNEL
disi30	AIS	PRD,1			:INCREMENT PRD TO NEXT BYTE
	LHI	R0,-1,R3		:BACK UP BB POINTER
	CL	R0,BE,R2,		:BUFFER EMPTY?
	JNfs	disi32			:NO, SKIP
	JAL	R8,GCLAST		:YES, RETURN LAST BUFFERLET
	J	disi48			:done with current message

disi32	ST	R3,BB,R2,		:save current BE
	J	disi48			:and done with message

:	HERE TO RELEASE EMPTY BUFFERLET AND GET NEXT ONE
disi35	LHI	R4,-1,R3		:MICROCODE INC'D POINTER
	CL	R4,BE,R2,		:BUFFER EMPTY?
	JNFS	disi36			:NO, JUST BUFFERLET EMPTY
	JAL	R8,GCLAST		:return our last bufferlet
	LIS	R3,0			:flag R3 for RMK which will still do
	J	disi28			:char checking in continuation

disi36	THI	R3,CBSZ-1		:really end of bflet?
	JN	disi28			:nope, put the char
	JAL	R8,GCRET		:FREE ONE BUFFERLET
	L	R3,BB,R2,
	J	disi28			:CONTINUE

:	for '00' unescape it (get next char and put it in current position)
DISI40	st	r3,bb,r2,		:update BB to current char
	jal	r8,gci			:get second char of the pair
	stb	r1,0,prd		:that is our data char
	ais	prd,1
	sis	cd,1			:if last byte then len was limited
	je	disi48			:by room and msg size is unchanged
:	found the escape char in the middle of a message
	sis	lrc,1			:message is going to be one shorter
	sis	cd,1			:msg going to be one shorter (might
					: be limited by chars in buffer)
	jg	disi25			:do RMK setup again
	j	disi48			:done with message

:	COME HERE ON 01,02 and 03 CHARACTER PAIRS
DISI41	LIS	R1,1			:CREATE THE '01'
	JFS	DISI44

DISI42	LIS	R1,2			:CREATE THE '02'
	JFS	DISI44

DISI43	LIS	R1,3			:CREATE THE '03'
:	we got a control char. return regs and buffers to normal states
:	and call dsitym to close dispatcher message and process signal.
disi44	st	r3,bb,r2,		:save current BB
	si	prd,dirng		:restore prd to cursor
	j	dsitym

:	reached end of message (exhausted count).
disi48	si	prd,dirng		:restore prd to cursor
	J	DISI79			:finish off data msg and do next chn
:	jal	r7,disi80		:close off message
:	j	disi92			:see if more message should be sent

       ei	:cmpnull

:	entry for move byte by byte.  Expect R2, CHN and LRC (max msg size)
:	PRD, and that's it.
disi50	lis	tyc,7			:in case killed (like in accounting)
       if	cmpnul
	tbt	chn,rcvesc		:what are we escaping?
	jefs	disi53
	lis	tyc,3			:only 00-03
       ei	:cmpnul	
disi53	LA	R8,DISI61		:to return bufferlet
	JFS	disi58

:	secondary jump, to make all jumps in work loop a short form jump
disi55	J	DSITYM			:handle escapes and such

:	continue final setup
disi58	LR	CD,LRC

:	the main work loop
DISI60	HC	3812			:GCI R1,R2
	HC	BE-BB			:size of BB
	HC	GCIERR-DISI60		:error
	HC	BB/4			:address of BB
	HC	GCRET-DISI60		:to return a buffler
	HC	DISI64-DISI60		:last char
DISI61	CR	R1,TYC			:escaped char?
	JLEBS	disi55			:yes handle signal & escapes
DISI70	STB	R1,DIRNG,PRD,		:put char into ring
	AIS	PRD,1
	NR	PRD,TC			:bump up ring pointer
	SIS	CD,1
	JGBS	DISI60			:get another char
	JFS	DISI66			:done

:	emptied bufferlets of all data
DISI64	JAL	R8,GCLAST		:return last bufferlet
	CR	R1,TYC			:control char?
	JLE	DSITYM
DISI67	STB	R1,DIRNG,PRD,		:store char (when last char)
	AIS	PRD,1			:bump up ring (range check next)
	SIS	CD,1			:did move a char

DISI66	SR	LRC,CD			:for how many chars read
					:and done

disi79	la	r7,dsinxt		:for done data return to dsinxt
:	DISI80	is used to finish off any variable len msg with byte len


DISI80	LHL	R1,RPSAV		:GET POINTER TO BYTE CNT (TYPE)
	STB	LRC,DIRNG+2,R1,		:THE COUNT IS THE TYPE IF A DATA MSG
      IF	t2gate			:do accounting
	TBT	CHN,GORGPT		:origination port?
	JN	DISI88			:return to normal handling
	LR	R0,LRC			:get count of chars moved
	LHI	R3,DISZFL-MNACHN,CHN	:get relative accounting port
	JAL	R8,AARDIC,,		:count the chars
       EI	:t2gate			:and done
:	identical as disi90 (for closing off messages) but this is an end of
:	a data messages reached by either running out of data or transmit.
:	thus, no reason to check to see if can put another message or fiddle
:	with running transmit limit.					###sdw
:	in other words, a whole lot more efficient than DMM.SW as proposed.
DISI88	AM	LRC,DISICC		:CHARS INTO DISPATCHER
	AIS	PRD,3			:ROUND OFF POINTER
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,
	jr	r7			:and exit

DISI90	AM	LRC,DISICC		:CHARS INTO DISPATCHER
	AIS	PRD,3			:ROUND OFF POINTER
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,
:	here to see if another message to follow the signal
disi92	lhl	r2,dsi.r2		:restore R2 (maybe clobbered)
	lhl	r0,bct,r2,		:anything to send?
	je	dsinxt			:nope, try next port
	lh	lrc,dixlft
	sis	lrc,8			:signals don't tell size so guess size
	jle	dsinxt
	sth	lrc,dixlft		:remaining xmit
	lh	r1,drie,,
	sr	r1,prd
	jgefs	disi97
	ai	r1,drsz
disi97
	shi	r1,100
	jge	disi20			:put another message
	j	dsiort			:and done with input for now

::*********************************************************************
::
::	SUBROUTINE:	DSITYM:
::	FUNCTION:	HANDLE NETWORK CONTROL CHAR PAIRS
::
::*********************************************************************

DSITYM	lr	r1,r1			:escape char?
	JNFS	DSITY1			:BRANCH IF NOT
:	GOT ESCAPE CHAR.
	JAL	R8,GCI			:GET ESCAPED CHAR
	LA	R8,DISI61		:restore release bufferlets reg
	LHL	R0,BCT,R2,		:see if any chars left
	JN	DISI70			:reenter in the loop
	J	DISI67			:put char and finish

:	OTHER CONTROL CHAR.
DSITY1	sth	r2,dsi.r2		:save r2 for disi90
	SR	LRC,CD			:OTHER CONTROL -  END CURRENT RECORD
	JE	DSITY2			:NO RECORD HAS BEEN STARTED
	lh	r0,dixlft		:room for multiple messages
	sr	r0,lrc
	jgfs	dsity4			:there is room
dsity3	jal	r8,wcd
	j	disi79			:and exit
:	here for signal following a data message and have xmit license to
:	send it.
dsity4	sth	r0,dixlft		:and save remaining xmit
	lr	r6,r1			:save signal for a moment
	jal	r7,disi80		:close off data message
	lr	r1,r6			:restore signal
	sth	chn,dirng,prd,		:set up for signal message
	sth	prd,rpsav
	ais	prd,3

:	DISPATCH ON CONTROL  CHARACTER CODE
DSITY2	SLLS	R1,2			:FW indexing			###wjl
	L	R1,DSITAB,R1,		:				###wjl
	JR	R1			:				###wjl


::*********************************************************************
::
::	SUBROUTINE:	DSITII:
::	FUNCTION:	HANDLE 03 CONTROL PAIRS
::
::*********************************************************************

DSITII	JAL	R8,GCI			:T-II CONTROL, GET NEXT CHR
	CLHI	R1,DSPMAX		:check range
	JGE	DSINXT			:ignore if too high
	SLLS	R1,2			:FW indexing			###wjl
	L	R8,DSPTBL,R1,		:get dispatch value		###wjl
	JR	R8			:and jump to handler		###wjl

::*********************************************************************
::
::	DSPTBL:	DISPATCH TABLE FOR 03 PAIR	
::
::*********************************************************************

DSPTBL	WC	DSINXT		:0300 unknown 03-pair
	WC	DSIZAP		:0301 hard zapper
	WC	DSIZAP		:0302 soft zapper
	WC	DSINGZ		:0303 non-gobbling zapper 		###wjl
	WC	DSIZAP		:0304 fat zapper
	WC	DSINXT		:0305
	WC	DSINXT		:0306
	WC	DSINXT		:0307
	WC	DSIGOB		:0308 GOBBLER
	WC	DSINXT		:0309
	WC	DSINXT		:030A
	WC	DSINXT		:030B
	WC	DSINXT		:030C
	WC	DSINXT		:030D
	WC	DSINXT		:030E
	WC	DSINXT		:030F
       IF	T2GATE		:Gateway has several variations
	WC	DSINXT		:Gateway Needle handler	###EV
	WC	DSINXT		:Successful circuit request for Gateway
	WC	DSITIL		:0312 used for Gateway only  for B8 translation
	WC	DSINXT		:0313 Not used for Gateway
       ELSE	:NOT GATEWAY
	WC	DSINDP		:0310 NEEDLE POINT
	WC	DSINDY		:0311 NEEDLE EYE
	WC	DSITIL		:0312 message for terminal in login mode
	WC	DSILRR		:0313 error in circuit request
      EI	:T2GATE
      IF	LOGII		:several new routines
	WC	DSINXT		:0314 COMET (not used)
	WC	RCRI		:0315 SUPE generated RCRI
	WC	RCRINC		:0316 NC generated RCRI
	WC	LGSC		:0317 Logon Success (LOG II needle eye)
      IF	T2GATE		:gateway doesn't worry about converted needles
	WC	DSINXT		:0318
      ELSE	:not T2GATE (node code)
	WC	ISNCVN		:0318 Log I to be delivered as LOG II needle
      EI	:T2GATE
	WC	DSINXT		:0319
	WC	DSINXT		:031A
	WC	DSINXT		:031B
	WC	DSINXT		:031C
	WC	DSINXT		:031D
	WC	DSINXT		:031E
	WC	DSINXT		:031F
	WC	DSINXT		:0320
	WC	DSINXT		:0321
	WC	DSINXT		:0322
	WC	DSINXT		:0323
	WC	DSINXT		:0324
	WC	DSINXT		:0325
	WC	DSINXT		:0326
	WC	DSINXT		:0327
	WC	DSINXT		:0328
      IF	T2GATE		:gateway only does needle bodies
	WC	DSINXT		:0329 LOG II needle head is ignored (gateway)
	WC	GDBODY		:032A LOGII needle body
      ELSE	:not T2GATE (node code)
	WC	ISN		:0329 Log II needle
      EI	:T2GATE
      EI	:LOGII
DSPMAX	EQ	(.-DSPTBL)/4

::*********************************************************************
::
::	TABLE:		B4CODE:
::	FUNCTION:
::		TABLE TRANSLATES SUP CODES FOR TALKING TO TERMINAL
::		IN LOGIN MODE INTO ISIS CODES FOR B4 MESSAGE.  
::
::		SUP MSG 0D --> NODE CODE MSG 0312 --> ISIS MSG B4xx
::
::		SUP CODES START WITH 8. SUP CODES 11 AND 12 TRANSLATE
::		TO HANG (B8) AND SUPER-HANG (AF).  SUP CODES E, F, AND 10
::		ARE NOT USED (A 10 CODE IS CONVERTED TO 8 IN LEP).
::
::*********************************************************************
	IF	T2GATE
B4CODE	HC	0B400,0B401,0B402,0B403,0B404,0B405,0,0,0,09E00,0B800
	HC	0B408,0B409,0B40A,0B40B,0B40C,0B40D,0B40E,0B40F,0B410
	HC	0B411,0B412,0B413
	ELSE
B4CODE	HC	0B400,0B401,0B402,0B403,0B404,0B405,0,0,0,0AF00,0B800
	HC	0B408,0B409,0B40A,0B40B,0B40C,0B40D,0B40E,0B40F,0B410
	HC	0B411,0B412,0B413
	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DSITIL:
::	FUNCTION:	0312 - MESSAGE FOR TERMINAL IN LOGIN MODE.
::				---> ISIS MSG B4
::*********************************************************************

DSITIL	JAL	R8,GCI			:CODE BYTE
	LR	R7,R1			:SAVE IT
	NHI	R1,0E0			:ISOLATE SPECIAL BITS
	NHI	R7,1F			:ISOLATE CODE
	SIS	R7,8			:SUP CODES BEGIN WITH 8
	LHL	R7,B4CODE,R7,R7		:TRANSLATE FOR ISIS
	OR	R1,R7			:BLEND SPECIAL BITS BACK IN
	STH	R1,DIRNG-1,PRD,
	J	DISI90

	IF	1-T2GATE		:Gateway does not use the following
::*********************************************************************
::
::	SUBROUTINE:	DSINDP:
::	FUNCTION:	0310 - NEEDLE POINT
::
::*********************************************************************

DSINDP	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME,
					: RECORD NEW CIRCUIT TIME
	LHI	R0,28
	JAL	R8,DIROOM		:SEE IF 28 BYTES AVAILABLE IN RING
	STH	CHN,DSICHN		:SAVE NEW NEEDLE CHN NUMBER
	LIS	R1,0			:SEND A TYPE '0'
	STB	R1,DIRNG-1,PRD,
	AIS	PRD,1			:SKIP ONE BYTE FOR LENGTH
	NR	PRD,TC			:WRAP RING POINTER IF NECESSARY
	JAL	R9,GCIE
	JAL	R9,GCIE			:DISCARD BYTE AND LINK CNTS
	JAL	R9,GHWI
	STH	R1,DIRNG,PRD,		:INVOICE # (ONE WORD LONG)
	JAL	R9,GHWI
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	JAL	R9,GHWI			:SAVE NEEDLE FLAGS
	STH	R1,DSINFL
	JAL	R9,GHWI			:SAVE CICUIT ORIGINATING NODE
	STH	R1,DSINOD
	JAL	R9,GHWI			:AND ORIGINATING PORT #
	STH	R1,DSIPRT
DSIND5	JAL	R9,GHWI			:SLEW OVER 'CREAMED' STUFF
	CI	R1,0FFFF
	JEBS	DSIND5			:.-0A
	NHI	R1,7FFF
	STH	R1,DIRNG,PRD,		:THIS IS DESTINATION HOST #
:	SAVE DESTINATION HOST FOR THIS CIRCUIT (CHN)
	STH	R1,DHSTIX,CHN,CHN	:SAVE FOR TRACE
	JAL	R8,GCI			:TID
	LR	R5,R1			:MUST HOLD IT

	JAL	R9,GCIE			:GET FIRST BYTE AFTER TID AND
	LR	R6,R1			: SAVE IT
	JAL	R9,GHWI			:GET NEXT 2 BYTES
:	deleted code for old supe which is older than 1983 and is no more##sdw
	STH	R1,DSIHST		:SAVE ORIGINATING HOST NUMBER

	LHL	R1,DSINOD		:ORIGIN NODE
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	LHL	R0,DSIPRT		:ORIGIN PORT
	NHI	R0,7FFF			:STRIP HOB,JUST IN CASE,T-I FOR EXAMPLE
	CLHI	R1,MACHNM		:SET HI-ORD BIT IF INTERNAL CIRC
	JNFS	DSIND3
	CLHI	R0,DISZFL
	JLFS	DSIND3
	CLHI	R0,DISZFL+NDP
	JGEFS	DSIND3
	AHI	R0,8000-DISZFL		:IT IS INTERNAL CIRC, SET HI-ORD BIT
DSIND3	STH	R0,DIRNG+2,PRD, 	:ORIGINATING PORT NUMBER
	LHL	R0,DSIHST
	NHI	R0,7FFF			:STRIP HIGH-ORDER BIT		###GT
	STH	R0,DIRNG,PRD,		:CIRCUIT ORIGIN HOST NUMBER
	AIS	PRD,4
	NR	PRD,TC
	LIS	R0,0
	STH	R0,DIRNG,PRD,		:NEXT TWO BYTES UNUSED
	LHL	R1,DSINFL		:GET NEEDLE FLAGS AND
	NHI	R1,30			: ISOLATE GOUGING BITS
	SRLS	R1,4			:RIGHT-JUSTIFY GOUGING BITS AND
	OHI	R1,80			: OR WITH 80 TO INDICATE FIELD PRESENT
	STH	R1,DIRNG+2,PRD,		:STORE CIRCUIT GOUGING LEVEL
					: (THROUGHPUT CLASS)
	AIS	PRD,4
	NR	PRD,TC

:	TEST NEEDLE FLAGS TO SEE IF DESTINATION HOST IS 'SMART'. IF NF.SMC
:	BIT IN NEEDLE FLAGS IS SET, TURN ON HIGH-ORDER BIT OF DIALECT CODE FOR
:	SLOT.
	IF	MXPNM			:ISIS-MXP EXPECTS A NODE #IN THIS ###GT
	LHI	R0,MACHNM		:FIELD + 'I' BIT		###GT
	LHL	R1,DSINFL		:GET NEEDLE FLAGS		###GT
	THI	R1,NF.SMC		:SMART CIRCUIT?			###GT
	JEFS	DSND30			:NO, DUMB HOST OR NOT REQUESTED	###GT
	OHI	R0,8000			:INDICATE HIQ HOST		###GT
	ELSE				:NON-MXP			###GT
	LHL	R1,DSINFL		:GET NEEDLE FLAGS
	THI	R1,NF.SMC		:SMART CIRCUIT?
	JEFS	DSND30			:NO - DUMB HOST OR NOT REQUESTED...
	LHI	R0,8000			:INDICATE HIQ HOST
	EI	:MXPNM							###GT
DSND30	STH	R0,DIRNG,PRD,		:FORMERLY DIALECT CODE,
					: INDICATE HIQ HOST
	STB	R5,DIRNG+2,PRD,		:TID

	LR	R5,PRD			:SAVE THIS
	AIS	PRD,4
	NR	PRD,TC			:POINTS TO START OF USER NAME
	TS	DSITLG			:POSITIVE IF TRANSPARENT LOGIN
					: (ASSUME NOT)

	LIS	LRC,0			:COMPUTE LENGTH OF USER NAME
	JAL	R8,GCI			:GET 1ST CHAR (MIGHT BE "?" FOR
	CLHI	R1,0BF			: TRANSPARENT LOGIN)
	JN	DSIND4			:NOT A "?", SKIP IT
	STB	R1,DIRNG,PRD,		:SAVE THE "?"
	STH	R1,DSITLG		:FLAG AS TRANSPARENT LOGIN

	LHL	R1,DSINFL		:GET NEEDLE FLAGS AND
	SRLS	R1,4			: ISOLATE CIRCUIT SPEED BITS
	NHI	R1,3			: (ALSO KNOWN AS GOUGING BITS)
	AHI	R1,81			: CONVERT TO CTRL-A -> CTRL-D
	AIS	PRD,1			:BUMP RING POINTER
	NR	PRD,TC
	AIS	LRC,1			:INCLUDE GOUGING CHAR WE'RE INSERTING
	JFS	DSIND4
DSIND1	JAL	R8,GCI
DSIND4	AIS	LRC,1
	STB	R1,DIRNG,PRD,
	AIS	PRD,1
	NR	PRD,TC
	CLHI	R1,80!ASCSMC		:TERMINATOR? ASCII SEMI-COLON 0BB
	JEFS	DSIND2
	CLHI	R1,80!ASCCR		:TERMINATOR? ASCII CARRIAGE RETURN 8D
	JNBS	DSIND1
DSIND2	LR	R1,PRD
	SR	R1,R5			:LENGTH OF USER NAME
	SIS	R1,4
	NR 	R1,TC
	STB	R1,DIRNG+3,R5,		:SIZE OF USERNAME

:	IF THE SUPERVISOR SENDS AN ODD-LENGTH USER NAME, IT WILL PAD THE
:	USER NAME WITH AN ESCAPE CHARACTER FOR EVEN HALFWORD
:	ALIGNMENT. WE MUST STRIP THE ESCAPE CHARACTER FROM THE USER
:	NAME, IF PRESENT, BEFORE PASSING IT TO THE SLOT. IF THE LOGIN
:	IS TRANSPARENT, WE INSERTED A CHARACTER, AND MUST THEREFORE
:	TEST FOR AN EVEN LENGTH USER NAME INSTEAD OF ODD.
	TS	DSITLG			:IS THIS A TRANSPARENT LOGIN?
	JGFS	DIES10			:YES - EVEN LENGTH NEEDS ESCAPE REMOVED
	THI	R1,1			:NORMAL LOGIN - ODD LENGTH USER NAME?
	JE	DIESCX			:NO, EVEN LENGTH, NO ESCAPE REMOVAL
	JFS	DIES20			:YES - TOSS ESCAPE

DIES10	THI	R1,1			:TRANSPARENT LOGIN
					: - EVEN LENGTH USER NAME?
	JNFS	DIESCX			:NO - ESCAPE REMOVAL NOT REQUIRED

:	REMOVE ESCAPE FROM USER NAME
DIES20	LH	R0,BCT,R2,		:EXTRA CARE, NO
	JEFS	DIESCX			: GCI CRASH
	JAL	R8,GCI
	LR	R1,R1			:ESCAPED ESCAPE?
	JNFS	DIESCX			:NO
	JAL	R8,GCI

DIESCX	LHL	R5,RPSAV		:POINTS TO START OF MESSAGE
	LHI	LRC,-1,PRD
	NHI	LRC,DRSZ-4
	SR	LRC,R5
	NR	LRC,TC
	STB	LRC,DIRNG+3,R5,		:LENGTH
	AIS	PRD,3
	NHI	PRD,DRSZ-4
	LHL	CHN,DSICHN		:NEW NEEDLE CHN NUMBER
	RBT	CHN,DISBPX		:send BP relief to port
	JAL	R9,DIXCAP		:GIVE IT XMIT CAPACITY
       if	cmpnul
	rbt	chn,nulcom		:not in null compression mode
	rbt	chn,rcvesc		:not rcving 04-07 as data
	rbt	chn,sndesc		:not sending 04-07 unescaped
	xhi	r2,4			:send to origination
	lhi	r1,01e0			:do you want to compress?
	jal	r9,w2ci			:back to orig
	xhi	r2,4			:restore buffer
       ei	:cmpnul
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSINDY:
::	FUNCTION:	0311  - NEEDLE EYE	---> ISIS MSG B6
::
::	NEEDLE EYE RECEIVED FROM LEP, INFORM REQUESTING SLOT THAT CIRCUIT
::	IS COMPLETE. SEND 0B6x0 MESSAGE IF NOT SMART CIRCUIT, ELSE 0B6x1. IF
::	THIS IS INTERNAL CIRCUIT, x IS 8 - OTHERWISE, x IS 0.
::
::*********************************************************************

DSINDY	JAL	R9,GHWI			:GET NEEDLE FLAGS
	LIS	R9,0
	LHR	R1,R1			:NEGATIVE IF NOT INTERNAL CIRCUIT
	JLFS	DSNY04
	AHI	R9,80			:INDICATE INTERNAL CIRC TO DISPATCHER
DSNY04	THI	R1,NF.SMC		:SMART CIRCUIT?
	JEFS	DSNY10			:NO
	AIS	R9,1			:YES - 0B6x1 BACK TO SLOT
DSNY10	LR	R6,R1			:SAVE NEEDLE FLAGS
	LHI	R1,0B600,R9
	STH	R1,DIRNG-1,PRD,		:'B6' + IIX, INTERNAL CIRC INDICATIONS
	AIS	PRD,1
	NR	PRD,TC			:FOLLOW W/ INVOICE #
	JAL	R9,GHWI
	STH	R1,DIRNG,PRD,
	JAL	R9,GHWI
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4			:advance ring ptr one word
	NR	PRD,TC
	LIS	R0,0
	ST	R0,DIRNG,PRD,		:ORIGIN HOST #
	AIS	PRD,4			:advance ring ptr another word
	NR	PRD,TC
	LR	R1,R6			:GET NEEDLE FLAGS BACK
	SRLS	R1,4			: AND ISOLATE SPEED BITS
	NHI	R1,3
	JAL	R9,DIXCAB		:GO TELL SLOT BACKPRESSURE LIMIT
					: (B9 msg)
	XHI	R2,4			:ENABLE NEEDLE TO TRAVEL
	JAL	R9,CRQALT,,		: BY ALERTING CRQ
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSILRR
::	FUNCTION:	0313 - LOGIN ERROR
::			NODE CODE MSG 0313 ---> ISIS MSG   B5
::
::*********************************************************************

DSILRR	SIS	PRD,3			:LOGON FAILURE, SEND 'B5' MSG TO SLOT
	LHI	R1,0B500
	STH	R1,DIRNG+2,PRD,
	JAL	R8,GCI			:GET ERROR CODE
	NHI 	R1,ASC7BT		:STRIP OFF THE HOB (SET BY SUPERVISOR)
	STB	R1,DIRNG+3,PRD,		:AND MOVE INTO RING
	AIS	PRD,4
	NR	PRD,TC
	STH	CHN,DIRNG,PRD,		:FOLLOW WITH ZAPPER
	LHI	R1,09F00
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	SBT	CHN,DISZNK		:AWAITING ZAPPER ACK
	J	DISI90

	SUBTTL	DISPI (DISIN - RCRI Log II response to terminal in logon mode)

::*************************************************************
:
:	RCRI	writes logon response to dispatcher.  Have to remove
:	(0316)  our orig port, change ID and flagsID, and see if supe
:		sent MO saying this is end of logon session.
:
::*************************************************************

       IF	LOGII

RCRI	SIS	PRD,1			:given PRD of odd byte
	LHI	R1,DM.RCR^8		:isis msg type C3 is RCRI
	STH	R1,DIRNG,PRD,
	AIS	PRD,2
	NR	PRD,TC
	JAL	R9,GHWI 		:get length of MOs
	LR	PRC,R1			:save it so we know when to end
	STH	PRD,RPSAV		:save where to write len
	LIS	LRC,0			:start off with none written
	AIS	PRD,2
	LR	R0,PRC
	JAL	R8,DIROOM		:make sure enough room

	JAL	R8,X4CRIZ,,		:init table
	LHI	R4,IDRCRI+MO.AC2
	JAL	R8,X4CCID,,
	LHI	R4,RMOID		:rmo
	JAL	R8,X4CCID,,
	L	R3,BB,R2,,		:start of RCRM
	LHI	R4,ID.RMF		:RCRM flags
	JAL	R7,X4PARS,,
	SKIPAD(RCRI10)
	LHI	R4,ID.RIF+MO.A2 	:RCRI flags
	JAL	R8,X4CBID,,		:len in r0, data in buffer
RCRI10	JAL	R8,X4FXCN,,		:finished with RMO
	LHI	R4,ID.SRJ		:supe rejecting it?
	JAL	R7,X4PARC,,		:continue parsing
	SKIPAD(RCRI15)
	LIS	R0,1
	JFS	RCRI16
RCRI15	LIS	R0,0
RCRI16	STH	R0,ICRMS1		:save whether we are to zap
	LHI	R4,(MO.C^8)+(SMOID&IDBITS)  :the way the table stores a SMOID
	LA	R6,X4TBBG,,		:find SMO element
RCRI20	AHI	R6,X4TBSZ
	CH	R4,X4T.AP,R6
	JNBS	RCRI20
	L	R3,X4T.DB,R6		:address of beginning of data
	LHL	R0,X4T.LN,R6		:len of SMO
	LHI	R4,SMOID
	JAL	R8,X4CBID,,		:put entire smoset into table
	JAL	R8,X4FXCN,,		:finish RCRI constructor
	JAL	R8,X4CDWR,,		:write element to dispatcher
	JAL	R8,CBCLR		:and nothing in the buffer

	LHL	R1,RPSAV
	STH	LRC,DIRNG,R1,		:save len of written MO
	LH	R0,ICRMS1		:are we to zap this guy?
	JE	DISI90			:no, we are done
	LR	R6,R2			:this port is to be zapped
	XHI	R6,4
	JAL	R9,LOGCLR		:clear it from logsup buffer
	LHI	R1,ZAPPN		:no gobble zapper
	JAL	R9,ZAPX,,		:and this one is zapped
	J	DISI90

       EI	:LOGII

	SUBTTL	DISPI (DISIN - LGSC Log II logon success message)

::****************************************************************
:
:	LGSC	logon successful.  Immediately following the char pair
:	(0317)	is a char to indicate whether this is an internal circuit.
:		After that touch of work, just copy however many bytes
:
::****************************************************************

       IF	LOGII

LGSC	SIS	PRD,1			:back to the type byte
	LHI	R1,DM.LGS		:msg is a LGSC
	STB	R1,DIRNG,PRD,
	JAL	R9,GCIE 		:indication of LOG II intranode
	LR	R1,R1
	JEFS	LGSC04
	XHI	R2,4			:internal alerts CRQ of needle after
	JAL	R9,CRQALT,,		:sending LGSC (ISIS dispatcher depends
	XHI	R2,4			:on receiving LGSC then ISN if internal
	LIS	R1,1			:only bit set is of internal
LGSC04	STB	R1,DIRNG+1,PRD,
	AIS	PRD,2
	NR	PRD,TC
	LIS	LRC,0			:start with len of 0
	JAL	R9,GHWI 		:get len of LGSC
	LR	PRC,R1			:workin copy of len
	STH	R1,DIRNG,PRD,
	AIS	PRD,2
	NR	PRD,TC

LGSC10	JAL	R9,GCIE 		:copy rest of MOs
	JAL	R8,X4DWCH
	SIS	PRC,1
	JGBS	LGSC10

	J	DISI90			:and exit

       EI	:LOGII

	SUBTTL	DISPI (DISIN - ISN  Log II needles)

::*****************************************************************
::
::	ISNCVN  handle logII converted heads.  It is a LOGI needle body
::	(0318)	which may not all be there.  Make sure it is all there before
::		entering mainline ISN (before go mainline write that this
::		is not an internal needle.
::
::	First have to make sure that len is there, then since the length
::	does not count itself must GHWI len, then do CBCCT to find if all
::	of ISN is there.  Can't change that order!!!
::
::*****************************************************************

       IF	LOGII

ISNCVN	LR	R1,R2			:have timout on ISN data arriving
	SRLS	R1,1			:gobbler may prevent ISN from arriving
	L	R0,BUFTIM,R1,		:has slowc (NEDTIM in CRQ)
	AHI	R0,$A60 		:if can't make it in a minute 
	C	R0,SLOWC,,		:then never will
	JGE	ISNCV4			:don't give up yet
	JAL	R8,CBCLR		:no data to dispatcher
	XHI	R2,4			:zap back to orig
	JAL	R9,ZAPHRD,,		:clear circuit
	LCS	R0,1
	STH	R0,DHSTIX,CHN,CHN	:clear host entry
	J	DSINXT			:done with this port
ISNCV4	JAL	R8,CBCCT		:ISN arrive yets?
	CLHI	R1,4			:length arrive?
	JL	ISNCV0			:no, must wait for len to arrive
       IF	NDREAD&CBZDBG
	STM	R0,REGST
	JAL	R14,NEDDB1,,
	LM	R0,REGST
       EI	:NDREAD&CBZDBG

	JAL	R9,GHWI 		:len of body (len not part of body)
	LR	R10,R1			:save len of ISN
	JAL	R8,CBCCT		:note BCT is changed from above CBCCT
	CR	R1,R10			:BCT contain whole needle?
	JGE	ISNCV1			:ISN contents has arrived
:	complete ISN hasnot arrived
	LR	R1,R10			:got it, now return it
	JAL	R9,WCDE 		:write back len
	EXBR	R1,R1
	JAL	R9,WCDE
	xhi	r2,4			:flip to link chn's buffer
:	make sure that the reason that the needle didn't arrive was not due
:	backpressure limits.						###sdw
	lhl	r1,bf,r2,		:receiving chn #
	xhi	r2,4			:restore to Dport buffer
	lis	r0,3
	oh	r0,iotab,r1,r1		:class d
	sth	r0,iotab,r1,r1		:saved
ISNCV0	LHI	R1,NEEDCV
	JAL	R8,WCD			:so we reenter same place next time
	EXBR	R1,R1
	JAL	R8,WCD
	J	DSINXT			:nothing written
:	restore the circuit to original tclass.
ISNCV1	xhi	r2,4			:to link chn buffer
	lhl	r1,bf,r2,
	xhi	r2,4			:restore to dispi
	lis	r0,3			:speed bits
	nh	r0,diotab,chn,chn	:the circuit's actual tclass
	or	r0,r2			:receiving buffer is our buffer
	sth	r0,iotab,r1,r1		:saved
	sis	prd,1			:existing
	LHI	R1,DM.ISN^8		:ISN and not internal
	STH	R1,DIRNG,PRD,
	AIS	PRD,2
	NR	PRD,TC
	J	ISN030			:go mainline


::	ISN	takes LOG II needle head and body and sends ISN.  Must
::	(0329)	check needle head if internal to set a bit.  Then eat
::		upto body, get len of body and just copy to ring.

ISN	SIS	PRD,1			:move back to type
	LHI	R1,DM.ISN^8		:ISN needle msg
	STH	R1,DIRNG,PRD,
	L	R3,BB,R2,		:init for PARSE
	LHI	R4,ID.NCF		:looking for flags
	JAL	R7,X4PARS,,
	SKIPAD(ISN008)
	JAL	R9,PCIE 		:number of unused bits
	JAL	R9,PCIE 		:bit flags
	THI	R1,L2F.IC		:internal?
	JEFS	ISN008
	LIS	R0,1			:tell ISIS this is an internal
	STB	R0,DIRNG+1,PRD,
ISN008	AIS	PRD,2			:move pointer to len pos
	NR	PRD,TC
ISN010	JAL	R8,GCI			:eat needle head
	SIS	R1,3			:char pair?
	JGBS	ISN010			:just more of the needle head
	JEFS	ISN014			:CRQ made sure it is a correct needle
	JAL	R8,GCI			:get second half of escaped char
	JBS	ISN010			:

ISN014	JAL	R8,GCI			:eat 2nd byte of 032A signal
	JAL	R9,GHWI 		:get len
	LR	PRC,R1			:setup like ISNCVN

:	the needle body logic is the some for natural and converted log ii
:	needles so ISN030 is where the converted needle logic enters
ISN030	STH	PRD,RPSAV		:save where to put len
	LIS	LRC,0			:init len to 0
	ST	LRC,DIRNG,PRD,		:clear ISIS use HW (and len)
	AIS	PRD,4
	NR	PRD,TC
	AIS	LRC,2			:the two len bytes don't count as len
	LR	R0,PRC
	JAL	R8,DIROOM		:make sure enough for ISN
ISN040	JAL	R8,GCI			:PRC is phys len go must do phys get
	CLHI	R1,3			:network control pair?
	JLEFS	ISN044
ISN042	JAL	R8,X4DWCH		:write char to dispatcher ring
	SIS	PRC,1			:one fewer byte in buffer
	JGBS	ISN040
	J	ISNEXI

ISN044	LR	R1,R1			:an escape?
	JNFS	ISN048
	JAL	R8,GCI
	SIS	PRC,1			:escaped char took 2 bytes in buffer
	JBS	ISN042			:get the escaped char

ISN048	CLHI	R1,3			:did a zapper catch the needle?
	JN	ISN060			:no, but something else did
	JAL	R8,GCI			:what type of 03 char?
	CLHI	R1,ZAPPN%0FF		:zapper type?
	JG	ISN060			:no, so zap
	JAL	R9,ZAPV,,		:zap 2nd half of circuit
	J	DSINXT			:had nothing to put in dispatcher

ISN060	JAL	R8,CBCLR		:remove any data so nothing gets
					:written to dispatcher since no needle
	XHI	R2,4			:and zap the circuit
	JAL	R9,ZAPHRD,,
	J	DSINXT			:and no dispatcher message

ISNEXI	LHL	R1,RPSAV		:where to write len
	STH	LRC,DIRNG,R1,		:write len
	RBT	CHN,DISBPX		:cause DISBPS to send BP relief
       if	cmpnul
	rbt	chn,nulcom		:not in null compression mode
	rbt	chn,rcvesc		:not rcving 04-07 as data
	rbt	chn,sndesc		:not sending 04-07 unescaped
	xhi	r2,4			:send to origination
	lhi	r1,01e0			:do you want to compress?
	jal	r9,w2ci			:back to orig
	xhi	r2,4			:restore buffer
       ei	:cmpnul
	AIS	PRD,3
	NHI	PRD,DRSZ-4		:end of this message
	JAL	R9,DIXCAP		:give it transmit capability
	J	DISI90

       EI	:LOGII

	SUBTTL	(DISPI) -DISIN - RCRINC Node Code generated Log2 Logon Failures

::*****************************************************************
::
::	RCRINC	Node code generated rejects to Log2 logons
::		(0315)
::
::*****************************************************************

       IF	LOGII

RCRINC	JAL	R8,GCI			:get reject reason
	LR	R6,R1
	LHI	R0,4+16 		:RCRI followed by zap
	JAL	R8,DIROOM		:make sure room for detach
	SIS	PRD,1			:back to type byte
	LHI	R1,ISRCRI^8		:type C3 in high byte
	STH	R1,DIRNG,PRD,		:RCRI
	AIS	PRD,2
	NR	PRD,TC
	LIS	R1,0
	JFS	ICRSN2
ICRSN1	AIS	PRD,1
	NR	PRD,TC			:copy RCRI to buff
ICRSN2	LB	R0,ICRSRM,R1
	STB	R0,DIRNG,PRD,		:copy canned RCRI
	AIS	R1,1
	CLHI	R1,ICRSRZ		:finished with canned part?
	JLEBS	ICRSN1
	STB	R6,DIRNG,PRD,		:last byte is for the reason
	AIS	PRD,3			:now put detach
	NHI	PRD,DRSZ-4		:put on proper boundary
	STH	CHN,DIRNG,PRD,		:write zap
	LHI	R1,ISDTCH^8		:and detach circuit
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	LHI	LRC,ICRSRZ+4		:how many chars moved
	JAL	R8,CBCLR		:nothing else to Dispi
	RBT	CHN,DISBPV
	XHI	R2,4
	JAL	R8,CBCLR
	LIS	R1,3			:write zap towards logger
	JAL	R8,WCI
	LIS	R1,1
	JAL	R8,WCI
	SBT	CHN,DISZNK		:and expect zap ack
	J	DISI90			:completed reject

ICRSRM	BC	00,10,7F,32,0D,30,05,5F :RCRI ID, len, RMO id, len
	BC	3E,02,07,00,31,04,5F,24,01 :RCRI flags, SMOseq id,len
					:and reject value will follow
ICRSRZ	EQ	.-ICRSRM		:size of msg

       EI	:LOGII

	EI	:1-T2GATE		:End of Gateway non-use section

	SUBTTL	DISPI (DISIN - Move data into Dispatcher form Network)

::*********************************************************************
::
::	SUBROUTINE:	DSINGZ:
::	FUNCTION:	0303 - NON-GOBBLING ZAPPER
::
::*********************************************************************

DSINGZ	HS	0
	IF	IDTACH				:ISIS Detach		###wjl
	SBT	CHN,DISZNK		:Indicates waiting for Zap Ack
	LHI	R1,ISDTCH		:Put Detach (9E) into ring
	J	DSIMES
	EI	:IDTACH			:else fall thru to Zap		###wjl

::*********************************************************************
::
::	SUBROUTINE:	DSIZAP
::	FUNCTION:	0301 - HARD ZAPPER
::			0302 - SOFT ZAPPER
::			0304 - FAT ZAPPER
::
::*********************************************************************

DSIZAP	SBT	CHN,DISZNK		:INDICATES WE'RE AWAITING ZAP ACK
       IF	T2GATE
	RBT	CHN,DISFLG		:Kludge fix for 3E63 crash (testing)
       ELSE	:not gateway
	lhl	r1,bf,r2,		:get what should be our chn number
	clhi	r1,diszfl,chn		:does it match our chn number
	jnfs	dsiza1			:no, a mess up so die now
	lr	r1,r2
	xhi	r1,4			:get other buffer number
	lhl	r1,bf,r1,		:get other chn number
	jefs	dsiza2			:it must be zero 
dsiza1	crash.(.disza)			:crash here instead of when get

       EI	:1-T2GATE
					: ZAPACK and take 6863 crash in ZAPV
dsiza2	LHI	R1,ISZAPR		:PUT ZAPPER (09F) IN RING
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIGOB:
::	FUNCTION:	0308 - GOBBLER
::			NODE CODE MSG 0308 ---> ISIS MSG  0A2
::
::*********************************************************************

DSIGOB	tbt	chn,disgob		:did gobbler use SPEED to override bp?
	jefs	dsigo1
	rbt	chn,disbpv		:if so then restore bp
dsigo1	LHI	R1,ISGBLR		:GOBBLER 0A2
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIRBL:
::	FUNCTION:	06 - RED BALL
::			NODE CODE MSG 06 ---> ISIS MSG 0AA
::
::*********************************************************************

DSIRBL	LHI	R1,ISRDBL		:RED BALL 0AB
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIGBL:
::	FUNCTION:	05 - GREEN BALL
::			NODE CODE MSG 05 ---> ISIS MSG 0AA
::
::*********************************************************************

DSIGBL	LHI	R1,ISGRBL		:GREEN BALL 0AA
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIEDM:
::	FUNCTION:	07 - ENTER DEM
::			NODE CODE MSG 07 --->  ISIS MSG 0A6
::
::*********************************************************************

DSIEDM	LHI	R1,ISEDEM		:EDEM 0A6
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSILDM:
::	FUNCTION:	04 - LEAVE DEM
::			NODE CODE MSG 04 --->  ISIS MSG 0A7
::
::*********************************************************************

DSILDM	LHI	R1,ISLDEM		:LDEM 0A7
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSITMC:
::	FUNCTION:	HANDLE 01 CONTROL PAIRS
::
::*********************************************************************

DSITMC	JAL	R8,GCI			:01 PAIR, GET SECOND CHAR
	LR	R4,R1			:SAVE SECOND BYTE
	SRHLS	R1,4			:DISPATCH ON HI-ORDER 4 BITS
	SLLS	R1,2			:FW indexing			###wjl
	L	R3,DSITMP,R1,		:				###wjl
	SRLS	R1,2			:restore index, used below	###wjl
	SIS	PRD,3			:BACK UP POINTER
	JR	R3			:				###wjl

::*********************************************************************
::
::	TABLE:		DSITMP:
::	FUNCTION:	01 CONTROL PAIRS DISPATCH TABLE
::
::*********************************************************************

DSITMP	WC	DSIT08,DSICMP,DSIT02,DSIT08
	WC	DSIT08,DSIT08,DSIT08,DSIT08
	WC	DSIT08,DSIT09,DSIT0A,DSIT0A
	WC	DSIT0C,DSIT0C,DSIT0E,DSIT0F


::*********************************************************************
::
::	SUBROUTINE:	DSICMP  - EXPAND NULLS
::	FUNCTION:	HANDLE 011x CONTROL PAIRS - the null compression
::
::*********************************************************************

:	enter here with PRD pointing to start of msg, but chn has been
:	put so we don't have to do that.  Make sure there is room,
:	if not then return signal to buffer.  If room then write len
:	and chunks of zeroes and write out mesage.

       if	1-cmpnul
dsicmp	eq	DSINXT			:if not defined then ignore (old logic)
       else	:cmpnul			:were are doing compression
dsicmp	nhi	r4,0f			:type field (count-2)
	ais	r4,2			:actual number of nulls
	clh	r4,dixlft		:room to send on this port?
	jlefs	dsicm1
	lhi	r1,0110-2,r4		:restore compression char count
	jal	r8,wcd			:back into the buffer it goes
	exbr	r1,r1			:get back 01
	jal	r8,wcd
	j	dsinxt			:done with this port for now

:	have room to expand compression.
dsicm1	lis	r0,0			:our nulls
	lr	lrc,r4			:length value for stats and such
	stb	r4,dirng+2,prd,		:store length
	stb	r0,dirng+3,prd,		:store a null
	sis	r4,1			:one null sent
	ais	prd,4
	nr	prd,tc
:	we are now on a fw boundary
dsicm2	st	r0,dirng,prd,		:store a word of nulls
	ais	prd,4			:bump to next word
	nr	prd,tc			:wrap ring if needed
	sis	r4,4			:that many more done
	jgbs	dsicm2			:not done yet
	j	disi90			:bump ring pointers to finish msg
       ei	:cmpnul


::*********************************************************************
::
::	SUBROUTINE:	DSIT02  - alternate ball signals
::	FUNCTION:	HANDLE 012x CONTROL PAIRS - various balls
::
::*********************************************************************

       if	1-cmpnul
DSIT02	EQ	DSINXT			:not defined, ignored
       else	:cmpnul
DSIT02	NHI	R4,0F			:TYPE 2 - BALLS
	LB	R1,DTM02,R4		:get type from table
	je	dsinxt			:undefined type, ignore
	AIS	PRD,3
	J	DSIMES

::*********************************************************************
::
::	TABLE:		DTM02:
::	FUNCTION:	TRANSLATE NODE CODE 012x PAIRS TO ISIS MSG
::
::*********************************************************************

DTM02	BC	0A7	:20 - LDEM
	BC	0AA	:21 - Green Ball
	BC	0AB	:22 - Red Ball
	BC	0A6	:23 - EDEM
	BC	0,0,0,0,0,0,0,0,0,0,0,0	:TYPE 24-2F - IGNORED

       ei	:cmpnul

::*********************************************************************
::
::	SUBROUTINE:	DSIT08
::	FUNCTION:	HANDLE 010x, 011x, 012x, 013x, 014x, 015x, 016x,
::			017x, AND 018x CONTROL PAIRS
::
::*********************************************************************

DSIT08	LB	R3,DTM08,R1		:HERE FOR TYPES 0 - 8
DSIT8A	LB	R0,DTM80,R3		:R3 IS PTR TO SECOND TABLE
	THI	R0,80			:IF 80, WERE DONE
	JN	DISI90
	NR	R0,R4			:R0 IS TRUNCATED VALUE
	LB	R1,DTM80+1,R3		:R1 IS SHIFT COUNT FOR R4
	SRHL	R4,0,R1
	LB	R1,DTM80+2,R3		:R1 IS ISIS CODE # (N)
	EXBR	R0,R0
	AR	R0,R1
	JAL	R10,DSITSM		:SEND B1 MESSAGE
	AIS	R3,3
	J	DSIT8A			:AND REPEAT

:	IN THE FOLLOWING TABLE EACH ENTRY CONSISTS OF 3 1-BYTE ELEMENTS:
:	BYTE 1 - MASK FOR INCOMING DATA
:	BYTE 2 - NUMBER OF BITS TO SHIFT
:	BYTE 3 - THE ISIS-II MESSAGE NUMBER

:	EACH ARRAY IS COMPOSED OF AN INTEGRAL NUMBER OF 3-BYTE ENTRIES,
:	AND IS TERMINATED WITH AN '80'.
:	Each triple in the array describes how to process the
:	corresponding subfield, described by the "mask" entry, of the
:	"x" listed below.
:	See CIRCUIT PROTOCOL document, App. I, for description of these
:	messages.

DTM80	BC	80				:for 010x pairs (nothing)
DTM81	BC	80				:for 011x pairs (nothing)
DTM82	BC	80				:for 012x pairs (nothing)
DTM83	BC	7,3,5,80			:for 013x pairs
DTM84	BC	1,1,0A,7,3,0A,80		:for 014x pairs
DTM85	BC	0F,4,0B,80			:for 015x pairs
DTM86	BC	0F,4,0A,80			:for 016x pairs
DTM87	BC	0F,4,9,80			:for 017x pairs
DTM88	BC	0F,4,6,80			:for 018x pairs
Q	EQ	DTM80
DTM08	BC	DTM80-Q,0,DTM82-Q,DTM83-Q
	BC	DTM84-Q,DTM85-Q,DTM86-Q,DTM87-Q,DTM88-Q

::*********************************************************************
::
::	SUBROUTINE:	DSIT09:
::	FUNCTION:	HANDLE 019x CONTROL PAIRS
::
::*********************************************************************

DSIT09	LIS	R1,0F			:TYPE 9 - RANDOM BULLSHIT
	NR	R1,4
	LB	R3,DTM09,R1		:POINTS TO LIST OF CODES
DSIT9A	LB	R0,DTM90,R3		:POINTS TO CODE BYTE
	THI	R0,80
	JN	DISI90
	JAL	R10,DSITQM		:SEND MESSAGE
	AIS	R3,1
	J	DSIT9A

DTM90	BC	3,2,1,0,80
DTM91	BC	4,5,80
DTM92	BC	6,7,80
DTM93	BC	9,8,80
DTM94	BC	0A,80
DTM95	BC	0B,80
DTM96	BC	0A,80
DTM97	BC	9,80
DTM98	BC	6,80

Q	EQ	DTM90
DTM09	BC	DTM90-Q,DTM91-Q,DTM92-Q,DTM93-Q
	BC	DTM94-Q,DTM95-Q,DTM96-Q,DTM97-Q,DTM98-Q

::*********************************************************************
::
::	SUBROUTINE:	DSIT0A:
::	FUNCTION:	HANDLE 01Ax, 01Bx CONTROL PAIRS.
::	
::*********************************************************************

DSIT0A	SRHLS	R4,1			:TYPE A - QUERY BITS
	NHI	R4,0F
	LB	R0,DTM0A,R4		:GET CODE
	JAL	R10,DSITQM
	J	DISI90

:	THIS TABLE IS ARRANGED IN 'NETWORK MESSAGE' ORDER TO CONVERT TO ISIS
DTM0A	BC	0,1,3,2,8,7,0C,4,0D,0E,10,11,12,13,0,0

::*********************************************************************
::
::	SUBROUTINE:	DSIT0C:
::	FUNCTION:	HANDLE 01Cx, 01Dx CONTROL PAIRS.
::
::*********************************************************************

DSIT0C	LIS	R1,1			:TYPE C - SET/RESET BIT PARAMETER
	NR	R1,R4			:BIT VALUE (0/1) IN R1
	SRHLS	R4,1
	NHI	R4,0F
	LB	R0,DTM0A,R4		:CODE ('N') IN RIGHT BYTE
	EXBR	R1,R1
	AR	R0,R1
	JAL	R10,DSITSM		:send a B1 message
	J	DISI90


::*********************************************************************
::
::	SUBROUTINE:	DSIT0E:
::	FUNCTION:	HANDLE 01Ex CONTROL PAIRS negotiate msgs
::
::*********************************************************************

       if	cmpnul
DSIT0E	NHI	R4,0F			:TYPE E - BALLS
	lb	r1,dtm0e,r4		:get code
	je	dsinxt			:not used, ignore
	j	dsit0e,r1		:there, handle it

:	01E0 handler - query ability to compress.  respond with 01E1 YES!
DSITE0	tbt	chn,nulcom		:if already in compress mode then
	jn	dsinxt			:this is second time which do not yet
					:have any meaning
	lhi	r1,01E1			:the yes!
	xhi	r2,4			:send back to other end
	jal	r9,w2ci
	xhi	r2,4			:Once said yes, nul compress is on
	sbt	chn,nulcom		:nul compression enabled for this port
					:and send 04-07 signals as 01:2x
	j	dsinxt			:no msg being sent

:	01E1 handler, got a yes to compress so enable it
DSITE1	sbt	chn,nulcom		:nul compression enabled for this port
					:and send 04-07 signals as 01:2x
	sbt	chn,rcvesc		:any 04-07 we get is data
	lhi	r1,01E2			:the yes!
	xhi	r2,4			:send back to other end
	jal	r9,w2ci
	xhi	r2,4			:Once said yes, nul compress is on
					:fall through to set
	j	dsinxt			:no msg being sent

:	01E2 handler - we can send unescaped and expect to get unescaped
DSITE2	sbt	chn,sndesc		:send unescaped
	sbt	chn,rcvesc		:expect to get unescaped
	lhi	r1,01E3			:the yes!
	xhi	r2,4			:send back to other end
	jal	r9,w2ci
	xhi	r2,4			:Once said yes, nul compress is on
	j	dsinxt			:no msg being sent

:	01E3 handler - we can send unescaped
DSITE3	sbt	chn,sndesc		:send unescaped
	j	dsinxt			:no msg being sent


DTM0E	BC	DSITE0-DSIT0E,DSITE1-DSIT0E,DSITE2-DSIT0E,DSITE3-DSIT0E
	bc	0,0,0,0
	bc	0,0,0,0
	bc	0,0,0,0

       else	:not cmpnul
DSIT0E	eq	DSINXT
       ei	:cmpnul

::*********************************************************************
::
::	SUBROUTINE:	DSIT0F:
::	FUNCTION:	HANDLE 01Fx CONTROL PAIRS
::
::*********************************************************************

DSIT0F	NHI	R4,0F			:TYPE F - BALLS
	LB	R1,DTM0F,R4
	AIS	PRD,3
	CLHI	R4,01			:IS IT HANG OR HDX HANG?
	JG	DSIMES			:NO
	SBT	CHN,DISHNG		:YES - REMEMBER WE SENT IT (INFO ONLY)
	J	DSIMES

::*********************************************************************
::
::	TABLE:		DTM0F:
::	FUNCTION:	TRANSLATE NODE CODE 01Fx PAIRS TO ISIS MSG
::
::*********************************************************************

DTM0F	BC	0AF	:F0 - HANG UP
	BC	0B8	:F1 - HDUX HANG
	BC	0A8	:F2 - ENTER TRANSPARENCY
	BC	0A9	:F3 - LEAVE DITTO
	BC	0BC	:F4 - ENTER ALTERNATE DEVICE MODE
	BC	0BD	:F5 - LEAVE ALTERNATE DEVICE MODE
	BC	0BF	:F6 - ENTER IIX EXCHANGE
	BC	0C0	:F7 - LEAVE IIX EXCHANGE
	BC	0,0,0	:F8 - FA - ZIP
	BC	0AE	:FB - BREAK
	BC	0A5	:FC - GREY BALL
	BC	0A4	:FD - BLACK "
	BC	0AD	:FE - ORANGE "
	BC	0AC	:FF - YELLOW

::*********************************************************************
::
::	SUBROUTINE:	DSIMES:
::	FUNCTION:	PUTS UP TO 3 CHARS IN RING.
::
::*********************************************************************

DSIMES	SIS	PRD,1			:PUTS UP TO 3 CHARS IN RING...
	NR	PRD,TC			:FIRST ONE IS TYPE
	LIS	LRC,0
	LR	R1,R1
DSIME1	JE	DISI90
	STB	R1,DIRNG,PRD,
	AIS	PRD,1
	NR	PRD,TC
	AIS	LRC,1
	SRHLS	R1,8
	JNBS	DSIME1
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSITSM:
::	FUNCTION:	SEND SET PARAMETER MESSAGE
::
::*********************************************************************

:	sends:  chn, count, /B1/N/, /value/, where "/"'s enclose bytes
DSITSM	STH	CHN,DIRNG,PRD,		:SEND SET PARAM MESSAGE
	LHI	R1,ISSPRM		:SEND ISIS SET PARAMETER (0B1)
	STB	R1,DIRNG+2,PRD,		:PUT IT IN THE RING
	STB	R0,DIRNG+3,PRD,		:VALUE/'N' IN R0
	AIS	PRD,4			:advance the ring pointer a Wordsworth
	NR	PRD,TC			:check for ring wrap
	EXBR	R0,0			:get the second byte
	STB	R0,DIRNG,PRD,		:put it in the ring
	AIS	PRD,4			:advance another Wordsworth
	NR	PRD,TC			:check for another wrap
	JR	R10			:and blow this scene

::*********************************************************************
::
::	SUBROUTINE:	DSITQM:
::	FUNCTION:	SEND QUERY PARAMETER MESSAGE
::
::*********************************************************************

DSITQM	STH	CHN,DIRNG,PRD,		:SEND QUERY PARAM MESSAGE
	LHI	R1,ISQPRM		:ISIS QUERY PARAMETER (0B0)
	STB	R1,DIRNG+2,PRD,
	STB	R0,DIRNG+3,PRD,		:'N' IN R0
	AIS	PRD,4
	NR	PRD,TC
	JR	R10

::*********************************************************************
::
::	TABLE:		DSITAB:
::	FUNCTION:	NETWORK CONTROL CODES DISPATCH TABLE
::
::*********************************************************************

DSITAB	WC	DSINXT,DSITMC,DSINXT,DSITII
	WC	DSILDM,DSIGBL,DSIRBL,DSIEDM

	SUBTTL	DISPI (DISOUT - Move data out of dispatcher into network)

:	THE FOLLOWING SYMBOL IS USED AS A BASE ADDRESS TO ALLOW ROUTINE
:	ADDRESSES TO BE STORED AS HALF-WORDS IN TABLE DSOMTB
SEG1.1	HS	0

::*********************************************************************
::
::	SUBPROCESS:	DISOUT:
::	FUNCTION:	MOVES DATA FROM DISPATCHER INTO NETWORK
::	CALLING SEQ:	JAL	R10,DISOUT
::
::*********************************************************************

DISOUT	ST	R10,DSSVRT		:SAVE RETURN
:	DON'T SPEND FOREVER EMPTYING DISPATCHER RING. DIDTIM WILL CONTAIN
:	FASTC TIME TO RETURN BACK TO SPIDER EVEN IF WORK IS LEFT OVER.
	L	R0,FASTC,,
	AHI	R0,TICDSO		:assigned max time (7d ticks)	###sdw
XICDSO	EQ	.-2			:able to change from xray symbol table
	SYAD(XICDSO)
	ST	R0,DIDTIM
	LHL	R3,DROF,,		:gather some statistics
	SH	R3,DROE,,		:how much in RING
	JGEFS	DISOU1
	AI	R3,DRSZ
DISOU1	CH	R3,DISOCP		:new max amoung in ring
	JLEFS	DISOU2
	STH	R3,DISOCP		:
DISOU2
	CLHI	R3,DRSZ-9D		:to be buffering so do something
	JLFS	DISOU4			:special to stop dispatcher buffering
	JAL	R10,DSODBF		:				###sdw
DISOU4
	SRHL	R3,DSCALE		:now make histogram entry
	NHI	R3,1C			:keep in in range
	LIS	R0,1
	AM	R0,DSOHGM,R3
	JGEFS	DSONXT			:zero all when use 32nd bit
	LIS	R0,0
	LHI	R1,1C			:zero all entries
DISOU3	ST	R0,DSOHGM,R1,
	SIS	R1,4			:clear histogram
	JGEBS	DISOU3

:	RETURN HERE AFTER SERVICING EACH CHANNEL, AND YIELD EITHER IF
:	HIGHER PRIORITY TASK HAS BEEN SCHEDULED, OR IF OUR TIME SLICE UP.
DSONXT	LIS	R0,1F-PCKZB		:only worry is buffer zap
	TBT	R0,SQUEUE
	JEFS	DSONX0			:not a pending buffer zap
	JAL	R0,EXYLD,,		:yield to buff zap
DSONX0	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	DSONX2			:YES, CONTINUE EMPTYING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DODISM
DSONX1	L	R10,DSSVRT		:exit for DISOUT
	JR	R10			:return to SPIDER

DSONX2	LHI	TC,DRSZ-1		:SET CONSTANTS
	LHL	PRD,DROE,,		:COMPUTE # CHARS TO MOVE OUT OF DISPI
	LHL	PRC,DROF,,
	SR	PRC,PRD			:DROF - DROE
	NR	PRC,TC
	JEBS	DSONX1			:ALL DONE, DORNG  IS EMPTY

	LHL	CHN,DORNG,PRD,		:CHANNEL #  (RPORT)

:	INTRA-ISIS COMUNICATIONS, IF RPORT IS ZERO.
	JE	DSZERO			:SPECIAL CONTROL CHANNEL

:	FOR ALL RPORT IS NOT ZERO
	CLHI	CHN,NDP			:CHN = REL DISPI CHN #
	JLFS	DSONX3			:VALID DISPATCHER PORTS ONLY
	CRASH.(.DISO0)
DSONX3	LHL	R2,DIOTAB,CHN,CHN	:GET DISPI OUTBOUND BUFFER #
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER #
	JNFS	DSONX4			:GO AHEAD, THE CIRCUIT IS THERE

	JAL	R8,DISKIP		:SKIP OVER DATA
					: ON UNASSIGNED DISPATCHER PORT
	J	DSONXT			:PROCESS NEXT CHANNEL

DSONX4	LB	LRC,DORNG+2,PRD,	:CHARACTER COUNT (TYPE)
	AIS	PRD,3
	NR	PRD,TC			:POINTS TO LAST BYTE OF WORD
	LHI	R1,-9E,LRC		:IS IT DATA

:	IT IS CONTROL MESSAGE, IF TYPE >= 9E
	JGE	DSOCTL			:NO, CONTROL MESSAGE

:	IT IS DATA ONLY, IF TYPE <= 9D
	LR	CD,LRC			:MOVE THESE MANY

	IF	T2GATE
::				Accounting here so we get only data characters
	TBT	CHN,GORGPT		:Should we count these ? 
	JNFS	DSONX6			:This is an origin port - no count
	LR	R0,LRC			:Get count
	LHI	R3,diszfl-mnachn,CHN	:Make an accounting index
	JAL	R8,AARDOC,,		:Now add to accumulator
DSONX6
	EI	:T2GATE

   IF	cmpnul				: only if nonescaping
	tbt	chn,sndesc		: are we escaping 04-07?
	je	dsonx8			:nope, call old logic

::************************************************************
::	if not escaping 04-07 then we can use RTD microcode to rip through
::	the data message.
::************************************************************

DISO08	clhi	cd,4			: don't bother if less than 4 chars
	jl	dsonx8			: too much setup for tiny msgs

	lis	r10,0			: default to no part wrapped
	LI	R8,-DRSZ,PRD		: prd + msglen - ringsize > 0 ?
	ar	r8,cd			: 
	JLEFS	DISO10			: will ring fold within this message?
	SR	CD,r8			: yes...# to move BEFORE fold
	lr	r10,r8			: r10 = bytes wrapped at beg of ring
DISO10	L	R3,BE,R2,		: load the buffer in-pointer
	JNFS	DISO12			: bufferlet already allocated
	JAL	R8,WCFRST		: Empty buffer, get first bufferlet
	SIS	R3,1			: Set up R3 (BE) for microcode
DISO12	AI	PRD,DORNG		: convert cursor to pointer

:
:	RTD COPY MICROINSTRUCTION:
:		R1  = scratch
:		R13 = CD = byte count of characters to move
:		R12 = PRD = address of the logical record
:		R3  = BE (address of the last character input)
:	NOTE THAT THE RTD COPY INSTRUCTION WAITS UNTIL IT HAS 2 BYTES
:	TO MOVE BEFORE IT ACTUALLY WRITES INTO THE BUFFERLET. THIS
:	MEANS THAT IF A SPECIAL CHARACTER IS ALSO THE LAST CHAR IN A
:	LOGICAL RECORD, IT MUST BE EXPLICITLY STORED WITH A STB INSTRUCTION
:	SINCE THE MICROCODE MAY NOT HAVE DONE SO.
:
:START	LB	RA,0,PRD	:GET NEXT BYTE 
:	INC	PRD	:ADVANCE PRD TO NEXT BYTE IN RAW PACKET (PRD=R12)
:	INC	BE		:ADVANCE BE TO SLOT WHERE BYTE WILL GO
:	END OF BUFFERLET?
:	YES => GET NEXT ONE, PROCEED AT 'NEXT'
:NEXT	'STORE' RA,0,BE		:STORE ONLY ON EVEN BE, USING HW WRITE
:	SPECIAL CHAR? (0-3)
:	IF YES, BRANCH OUT
:	DEC	CD		:DECREMENT COUNT OF RAW BYTES REMAINING
:	CD=0?
:	IF NOT, GOTO START
:	ELSE DONE

DISO14	LHL	R0,0,R3			:SET UP SCRATCH REGISTER
	EXHR	R0,R0			: FOR THE MICROCODE
	LHL	R1,0,PRD
	OR	R1,R0

DISO17	bc	3B,r1^4+cd		:RTD Copy 1 - SCRATCH REG, BYTE COUNT 
DISO18	bc	3C,r1^4+cd		:RTD Copy 2 - RESUME PROCESSING HERE
	HC	DISO25-diso18		:TO GET NEXT BUFFERLET
	HC	DISO30-diso18		:TO HANDLE 00 (compress or escape it)
	HC	DISO41-diso18		:TO HANDLE 01 (escape it)
	HC	DISO42-diso18		:TO HANDLE 02 (escape it)
	HC	DISO43-diso18		:TO HANDLE 03 (escape it)

:	WE'VE exhausted our count.  is this a wrapped msg with more waiting
:	at start of ring?
diso19	ST	R3,BE,R2,		: done -- save end addr
	LR	CD,R10			: a wrapped msg?
	JLE	DISO50			: no...done with this message
	SI	PRD,DRSZ		: back to start of ring
	LIS	R10,0			: no wrapped msg waiting
	J	DISO14			: move it

::  End-Of-Bufferlet
DISO25	JAL	R8,NXTBLT,,		: get another bufferlet
	j	diso18			: continue (do char type, char cnt in
					: the rtd microcode)

::  special Control-Characters (00-03) detected...escape it

:	we got a null, compression enabled, so try to compress
DISO30	SI	prd,DORNG		:restore PRD to cursor
	nr	prd,tc			:just in case 
	ar	cd,r10			:add in wrapped portion if any
	clhi	cd,2			:is it last byte in msg?
	jle	diso39
	lb	r0,dorng,prd,		:get next char (2nd char)
	jn	diso39
	AIS	PRD,1			:point to third char
	NR	PRD,TC			:wrap if needed
	lis	r4,0			:count (-2) of nulls found so far
	sis	cd,2			:count the two chars read
	jlefs	diso35			:all read so done
diso34	LB	R0,DORNG,PRD,		:see if another char is null
	jnfs	diso35			:write compress msg if not
	AIS	PRD,1			:is null, so another char read
	NR	PRD,TC			:handle ring wrap if needed
	ais	r4,1			:count of nulls found so far
	sis	cd,1			:one less char in msg
	jlefs	diso35			:finished reading msg
	clhi 	r4,0f			:at max range of compress msg?
	jlbs	diso34			:no, get another
:	write compression signal (011x where x is count in r4)
diso35	lis	r1,01			:the 01 of signal
	stb	r1,0,r3			:r3 and buffer was left open
	st	r3,be,r2,		:make BE correct
	lhi	r1,10,r4		:second part of signal
	jal	r8,wci			:write it
	lr	cd,cd			:any msg left
	jg	diso08			:start all over (cd is unwrapped cnt)
	j	diso51

:	pass the single null along.
diso39	lis	r1,0			:store the null
	stb	r1,0,r3
	st	r3,be,r2,
	jal	r8,wci
	sis	cd,1			:count the char moved
	jle	diso51			:exit all moved (included any wrapped) 
	j	diso08			:start all over (cd is unwrapped cnt)

:	char pairs 01-03 are easy to escape
diso41	lis	r1,1			: 01 found
	jfs	diso44
diso42	lis	r1,2			: 02 found
	jfs	diso44
diso43	lis	r1,3			: 03 found
:	now that have got type, save it
diso44	LIS	R0,00			: stuff a 00 to escape
	STB	R0,0,R3			: where we already have the char
	ST	R3,BE,R2,		: save the pointer to that char
	JAL	R8,WCI			: ..and put the char needing esc away
	L	R3,BE,R2,		: restore R3
	SIS	CD,1			: count the char transfered
	jg	diso14
	J	DISO19			: see if end of msg at common routine

::****************************************
:	done with rtd copy, restore prd to cursor from pointer
diso50	si	prd,dorng,		:fix up prd
diso51					:exit with prd already corrected
	j	diso6			:back to common code after moving msg

     ei		:cmpnull

DSONX8	LIS	TYC,7			:now depends on the chn
       if	cmpnul
	tbt	chn,sndesc		:what are we escaping?
	jefs	dsonx9
	lis	tyc,3			:only 00-03
       ei	:cmpnul	
dsonx9

:	LOOP TO MOVE DATA FROM DORING TO BUFFER
 
:	the inline WCI microcode is faster than calling the routine
:	or using the equivalent instructions inline

	LA	R8,DISO3		:SET UP RETURN ADDRESS FOR EXCEPTIONS

DISO1	LB	R1,DORNG,PRD,		:MOVE DATA FROM DORING
	AIS	PRD,1
	NR	PRD,TC			:INCREMENT RING POINTER
	CR	R1,TYC			:DO WE NEED TO ESCAPE?
	JLEFS	DISO4			:YES - PRECEDE WITH ESCAPE CHAR (00)
DISO2	HC	3912			:WCI R1=CHAR, R2=BUFFER INDEX
	HC	BE-BB			:SIZE OF BB STORAGE
	HC	WCIERR-DISO2		:HERE ON INVALID BUFFER NUMBER
	HC	BE/4			:ADDRESS OF BE STORAGE/4
	HC	WCNXT-DISO2		:HERE TO CHAIN IN ANOTHER BUFFERLET
	HC	WCFRST-DISO2		:HERE TO GET FIRST BUFFERLET
DISO3	EQ	.			:EXCEPTION RETURN POINT
	SIS	CD,1			:DONE?
	JGBS	DISO1			:NO - CONTINUE
	jfs	diso6

DISO4
       if	cmpnul
	lr	r1,r1			:is it a null
	je	dsocmp			:yes, try compressing it
       ei	cmpnul
diso5	AIS	LRC,1			:ADJUST INPUT CHARA COUNT
	EXBR	R1,R1
	JAL	R8,WCI			:WRITE '00' ESCAPE
	EXBR	R1,R1			:RESTORE ORIGINAL CHARACTER
	LA	R8,DISO3		:RETORE RETURN ADDRESS FOR EXCEPTIONS
	J	DISO2

diso6	LHL	R1,DIOTAB,CHN,CHN	:SET BACKPRESSURE IF NEEDED
	NHI	R1,3			:READ GOUGING LEVEL BITS FROM IOTAB
	LHL	R0,BCT,R2,		:READ BCT FOR THE BUFFER
:	reduce buffering by taking into account the latency of apply
:	backpressure.  slot has a good chance of sending us data after we
:	ask it to stop.
	tbt	chn,prirty+diszfl/8,,	:is this a priority circuit?
	jefs	diso7
	srls	r0,1			:give extra buffering to priority cirs
diso7	CLH	R0,disSPK,R1,R1		:COMPARE BCT WITH GOUGING LEVEL MAX
	JLFS	DSOTBP			:IF BCT LESS THEN NO BP MSG TO ISIS

:	WE'VE MOVED MORE THAN BP MAX
       IF	T2GATE			:don't BP chars in logger buffer##sdw
	TBT	CHN,LOGING		:if set then logon chars
	JNFS	DSOTBP
       EI	:T2GATE
	RBT	CHN,DISBPX		:ELSE WE'VE MOVED MORE THAN BP MAX
	LIS	R0,4			:WAIT FOR ROOM IN ISIS INPUT RING
	JAL	R8,DIROOM
	LHI	R1,SDSPBP		:SEND ONE WORD MSG TO ISIS--SET BP
	JAL	R8,DIRMES

DSOTBP	AM	LRC,DISOCC		:INC CHAR COUNT
DSOIRP	AIS	PRD,3			:TRUNCATE POINTER
	NHI	PRD,DRSZ-4
	STH	PRD,DROE,,
	J	DSONXT			:REPEAT

       if	cmpnul
:	compress nulls.  playing a slight game as we will pretend we did
:	not read the next nonnull char.
:	when we get here PRD has been incremented to next byte, cd does
:	not reflect having read the null.  Thus, we must return with CD
:	being one position behind that of PRD.  
dsocmp	tbt	chn,nulcom		:is this port compressing?
	je	diso5			:no continue
	clhi	cd,2			:must be more data to find
	jl	diso5			:write escaped null
	LB	R0,DORNG,PRD,		:is next byte also null
	jn	diso5			:no, put single null and continue
	AIS	PRD,1
	NR	PRD,TC			:count char as read
	lis	r4,0			:count (-2) of nulls found so far
	sis	cd,2			:CD is now in sync with PRD
	jlefs	dsocm7			:all read so done
dsocm6	LB	R0,DORNG,PRD,		:see if another char is null
	jnfs	dsocm7			:write compress msg if not
	AIS	PRD,1			:is null, so another char read
	NR	PRD,TC			:handle ring wrap if needed
	ais	r4,1			:count of nulls found so far
	sis	cd,1			:one less char in msg
	jlefs	dsocm7			:finished reading msg
	clhi 	r4,0f			:at max range of compress msg?
	jlbs	dsocm6			:no, get another
dsocm7	ais	cd,1			:unread a char so diso3 is okay
	lhi	r1,0110,r4		:make compress message
	jal	r9,w2ci			:send it
	la	r8,diso3		:restore r8
	j	diso3			:get next char (if there)
       ei	:cmpnul

::*********************************************************************
::
::	SUBROUTINE:	DSOCTL:
::	FUNCTION:	HANDLE ISIS CONTROL MESSAGES  ( >= 9E )
::
::*********************************************************************

DSOCTL	LIS	LRC,0
	CLHI	R1,DSODMX		:IF TYPE > MAX...
	JLFS	DSOCT2
DSOCRH	CRASH.(.DSOC0)

DSOCT2	TBT	R1,DSOMBA		:1=EASY, 0=HARD TO CONVERT
	JE	DSOCT1			:HARD, FANOUT BY TYPE##AL

:	EASY TO CONVERT
	LHL	R1,DSOMTB,R1,R1		:TRANSLATE THE REST

	IF	T2GATE
	TBT	CHN,LOGING		:For Gateway, login  handler
	JEFS	DSOMS1			:Not log-in - just proceed
	CI	R1,0FF01		:Or a yellow ball	###jk
	JEFS	GDCM02
DSOMS1	LR	R1,R1
	EI	:(T2GATE)

DSOMES	JE	DSOTBP			:ALL DONE
	JAL	R8,WCI
	SRHLS	R1,8
	JBS	DSOMES

:	DISPATCH ON TYPE
DSOCT1	LHL	R1,DSOMTB,R1,R1	
	J	SEG1.1,R1

	IF	T2GATE
GDCM02	XHI	R2,4			:Flip again
	LHI	R1,01
	JAL	R8,WCI
	LHI	R1,0FE
	JAL	R8,WCI			:bounce orange ball
	XHI	R2,4			:Flip back
	J	DSOTBP
	EI	:(T2GATE)

::*********************************************************************
::
::	SUBROUTINE:	DSODET:
::	FUNCTION:	9E  -  DETACH
::
::*********************************************************************

DSODET	HS	0
	IF	IDTACH			:ISIS Detach			###wjl
	IF	T2GATE
	JAL	R8,GBYHOM,,
	EI	:T2GATE
	LHL	R0,BF,R2,		:ZAPPER
	JE	DSOIRP			:IGNORE IF WAITING FOR ZAK
	RBT	CHN,DISHNG		:IF WE SENT HANG, ZAPPER CLEARS
	LHI	R1,ZAPPN		:Non-Gobbling Zapper (0303)
       if	t2gate
	lis	r0,aalr02
	sth	r0,aareas
       ei
	JAL	R9,ZAPXN,,		:ZAP circuit, do not CBCLR
	J	DSOZ10			:GO CLEAR HOST ENTRY,
					: DECREMENT PORT COUNT
	ELSE	:not IDTACH
	J	DSOZAP			:handle like a zapper		###sdw
	EI	:IDTACH	###wjl

::*********************************************************************
::
::	SUBROUTINE:	DSOZAP:
::	FUNCTION:	9F - ZAPPER
::
::*********************************************************************

DSOZAP	LHL	R0,BF,R2,		:ZAPPER
	JE	DSOIRP			:IGNORE IF WAITING FOR ZAK
	RBT	CHN,DISHNG		:IF WE SENT HANG, ZAPPER CLEARS

	IF	T2GATE
	TBT	CHN,GDSTPT
	JE	GSOZA4
	LHI	R1,AALR02		:Log out by host
	STH	R1,AAREAS		:Store reason for accounting	
	JAL	R8,GBYHOM,,		:Send "inter-link cleared" if appr.

	LR	R4,CHN
	JAL	R10,GSOZW7,,
	SKIPAD(GSOZA6)			:IMMED, PORT DETACHED		###wjl
GSOZA4	LIS	R1,0			:+4
	STH	R1,AAREAS		:Zap not counted if origin port
GSOZA5	JAL	R9,ZAPHRD,,		:NOT DETACHED, MUST HARD ZAP
GSOZA6	HS	0
	ELSE	:NOT T2GATE
	JAL	R9,ZAPHRD,,		:ZAP
	EI	:T2GATE
	J	DSOZ10			:GO CLEAR HOST ENTRY,
					: DECREMENT PORT COUNT

::*********************************************************************
::
::	SUBROUTINE:	DSOSBP:
::	FUNCTION:	A0 - SET BACKPRESSURE
::
::*********************************************************************

DSOSBP	RBT	CHN,DISBPV		:SET BACKPRESSURE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSORBP:
::	FUNCTION:	A1 - RELEASE BACKPRESSURE
::
::*********************************************************************

DSORBP	SBT	CHN,DISBPV		:RELEASE BACKPRESSURE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOGOB:
::	FUNCTION:	A2 - GOBBLER
::
::*********************************************************************

DSOGOB	JAL	R9,GOBBLN,,		:GOBBLER, DON'T GOBBLE NEEDLE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOEDE:
::	FUNCTION:	A6 - EDEM  to 07 or 01:23 depending
::
::*********************************************************************

DSOEDE	lis	r1,7			:old style EDEM signal
	jfs	dsold1			:LDEM has same logic


::*********************************************************************
::
::	SUBROUTINE:	DSOLDE:
::	FUNCTION:	A7 - LDEM  to 04 or 01:20 depending
::
::*********************************************************************

DSOLDE	lis	r1,4
DSOLD1
       if	cmpnul
	tbt	chn,nulcom		:is null compression enabled?
	jefs	dsold2
	ahi	r1,0120-4		:convert to new signal
	jal	r9,w2ci
	J	DSOIRP			:and done
       ei	:cmpnul
dsold2	jal	r8,wci			:not comp null, just write char
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOGRN:
::	FUNCTION:	AA - Green Ball  to 05 or 01:22 depending
::
::*********************************************************************


DSOGRN	lis	r1,05			:our signal char
	jfs	dsore1			:red ball has same logic so use it

::*********************************************************************
::
::	SUBROUTINE:	DSORED:
::	FUNCTION:	AB - Red Ball  to 06 or 01:23 depending
::
::*********************************************************************


DSORED	lis	r1,06
dsore1	
       if	t2gate
	tbt	chn,loging		:if gateway loging mode then
	je	dsold1			:echo GB/RB back to orig
	xhi	r2,4
       if	cmpnul			:we know we can receive new signal
	tbt	chn,nulcom		:are we compressing?
	jefs	dsore3			:no, other end will not understand
	ahi	r1,0120-4		:make to new 01 msg
	jal	r9,w2ci
	j	dsoirp
       ei	:cmpnul
dsore3	jal	r8,wci
	xhi	r2,4
	j	dsoirp
       else	:not t2gate
	j	dsold1
       ei	:t2gate

::*********************************************************************
::
::	SUBROUTINE:	DSOQPR:
::	FUNCTION:	B0 - QUERY FIELD PARAMETER
::
::*********************************************************************

DSOQPR	LB	R1,DORNG,PRD,		:QUERY FIELD PARAMETER
	NHI	R1,1F
	LB	R1,TQPR,R1		:GET SECOND BYTE OF CORRESPONDING...
	JE	DSOTBP			:DON'T SEND OUT 01-00 PAIRS	###GT
DSOQP1	EXBR	R1,R1			:...01 PAIR
	AIS	R1,1
	J	DSOMES			:SEND PAIR

::*********************************************************************
::
::	SUBROUTINE:	DSOSPR:
::	FUNCTION:	B1 - SET FIELD PARAMETER
::
::*********************************************************************

DSOSPR	LB	R1,DORNG,PRD,		:SET FIELD PARAMETER
	AIS	PRD,1
	NR	PRD,TC
	LB	R0,DORNG,PRD,		:FIELD VALUE
	AIS	PRD,4
	NR	PRD,TC
	NHI	R1,1F			:RESTRICT INDEX (0-31d)
	CLHI	R1,5			:TEST FOR B1/05 MSG
					: (SET INPUT BAUD RATE) AND BYPASS DUE
	JE	DSOTBP			: TO AMBIGUOUS TREATMENT BY TYMSATS
	LB	R4,TSPRM,R1		:GET THE VALUE MASK
	NR	R0,R4			:PREVENTS FIELD OVERFLOW
	LB	R1,TSPR,R1		:SECOND BYTE OF 01 PAIR
	JE	DSOTBP			:DON'T SEND OUT 01-00 PAIRS	###GT
	OR	R1,R0			:INSERT VALUE
	J	DSOQP1			:SEND PAIR

	IF	1-T2GATE		:Gateway does not get B3 chars
::*********************************************************************
::
::	SUBROUTINE:	DSOLGC:
::	FUNCTION:	B3 - LOGON CHAR
::
::*********************************************************************

DSOLGC	LB	R1,DORNG,PRD,		:GET LOGON CHARACTER FOR LOGCHR
	JAL	R11,LOGCHR		:JUMP TO LOGIN CHAR PROCESSING ROUTINE
	SKIPAD(DSOLG1)			:RETURNS HERE IF PORT NOT IN LOGIN MODE
	SKIPAD(DSOLG3)			:RETURNS HERE IF LOGIN BUFFER FULL
	J	DSOTBP			:RETURNS HERE IF ALL IS WELL

:	GOT LOGIN CHARACTER FROM DISPATCHER PORT NOT IN LOGIN MODE.
:	COUNT OCCURRENCE, AND UPDATE RING POINTER PAST ILLEGAL MESSAGE.
DSOLG1	LIS	R0,1
	AHM	R0,DOILLG		:NUMBER OF ILLEGAL LOGIN CHARACTERS
	J	DSOIRP			:BYPASS THIS MESSAGE

:	LOGIN BUFFER FULL. SEND USER 'TOO MANY CHARS' MSG AND 'PLS  SEE REP'
:	MESSAGE AND HANG PORT
DSOLG3	LIS	R0,4			:SEND 'SUPER HANG' (FOR HDX TERMS)
	JAL	R8,DIROOM
	LHL	R10,DRIF,,
	STH	CHN,DIRNG,R10,
	LHI	R0,0B800		:PORT # + SUPER HANG
	STH	R0,DIRNG+2,R10,
	AIS	R10,4
	NR	R10,TC
	STH	R10,DRIF,,
	LA	R1,TOMANY		:BUFFER FILLED MESSAGE
	JAL	R8,DIMMES		:TELL USER
	LA	R1,EXMG1,,		:SEND PLS SEE REPRES... MSG
	JAL	R8,DIMMES		: TO USER
	LIS	R0,4			:SEND HANG
	JAL	R8,DIROOM
	LHL	R10,DRIF,,
	STH	CHN,DIRNG,R10,
	LHI	R0,0AF00		:PORT # + HANG
	STH	R0,DIRNG+2,R10,
	AIS	R10,4
	NR	R10,TC
	STH	R10,DRIF,,
	J	DSOTBP			:CONTINUE
	EI	:1-T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DSOHNG:
::	FUNCTION:	B8 - SUPER HANG CHAR PAIR
::
::*********************************************************************
DSOHNG	LI	R1,0F101		:SUPERHANG CHAR PAIR
	IF	T2GATE
	JAL	R9,GDOMES,,		:Forward it
	LHI	R1,09F00
	JAL	R8,DIRMES		:but Zap circuit backwards
	RBT	CHN,DISZNK
	RBT	CHN,LOGING
	RBT	CHN,DISFLG
	LA	R4,EXMG1,,
	JAL	R9,BUFCAN		:Send "pls see yr rep"
	TBT	CHN,GTTRNS
	JN	GDSOH4
	LA	R4,GNGONE,,		:if not Xparent, "inter link cleared"
	JAL	R9,BUFCAN
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF
	JAL	R9,BUFCAN
GDSOH4	LHI	R1,AALR02		:accounting reason
	STH	R1,AAREAS,,		:do accounting for logon zaps	###sdw
	LHI	R1,ZAPPN		:then Non Gobbling Zapper forward
	JAL	R9,ZAPX,,
	J	DSOTBP			:next port
	ELSE	:NOT T2GATE
	J	DSOMES			:otherwise send it and continue
	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DSOSXL:
::	FUNCTION:	B9 - SET XMT LIMIT
::
::*********************************************************************

DSOSXL	LB	R1,DORNG,PRD,		:SET XMIT LIMIT
	STH	R1,DIXLIM,CHN,CHN
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOZAK:
::	FUNCTION:	BB - ZAP ACK
::
::*********************************************************************

DSOZAK	HS	0
	IF	T2GATE
	TBT	CHN,DISZNK		:Should be zero if log-in mode
	JN	DSOZ05
	JAL	R9,GLZPV,,
	JFS	DSOZ10
	EI	:T2GATE


DSOZ05	XHI	R2,4			:FLIP TO INBOUND BUFFER INDEX AND
	JAL	R9,ZAPV,,		: ZAP SECOND HALF OF CIRCUIT
	RBT	CHN,DISZNK		:NO LONGER AWAITING ZAPPER ACK

DSOZ10	HS	0
	IF	T2GATE
	RBT	CHN,LOGING		:Disable possible login service
	RBT	CHN,DISFLG		:Kludge fix for 3E63 crash
	EI	:T2GATE			:###ev
	LCS	R0,1
	STH	R0,DHSTIX,CHN,CHN	:CLEAR HOST ENTRY (-1 INDICATES ITS
					:BEEN USED BEFORE, 0 FOR NEVER USED)
	J	DSOIRP			:DONE

::*********************************************************************
::
::	SUBROUTINE:	DSOZWR:
::	FUNCTION:	BE - ZAP WITH REASON
::
::	REASON 0 = HOST OUT OF PORTS
::	INPUT MESSAGE FORMAT:
::		|PORT...! BE :REASON|{0000! 05 : -- |7MG,VALUE..|}
::
::	FOR THE NEW ISIS, CHECK THAT REASON IS REALLY 0, AND DO
:: 	NOT ASSUME THAT ACCOUNTING MESSAGE FOLLOWS IMMEDIATELY,
::	CHECK HOST RELATED ERRORS, SEND MESSAGE TO ERROR LOGGER
::	BUT DO NOT SEND ACCOUNTING MESSAGES.
::
::*********************************************************************

DSOZWR	LR	R4,CHN			:SAVE 'OLD' CHAN #
	LB	R0,DORNG,PRD,		:GET THE REASON FOR THIS ZAP
	JE	DSOZW2			:ZERO IS OK

:	DISPLAY ERROR IN CRYPTO LOG

	JAL	R8,CRYPTO,,		:LOG THIS REASON AS AN ERROR
	HC	CRYE73
	J	DSOIRP			:AND IGNORE THE MESSAGE

:	FIND HOST NUMBER TO CHECK FOR REALLY OUT OF PORTS
DSOZW2	LHL	R1,DHSTIX,R4,R4		:GET HOST NUMBER
	JAL	R9,FNDHST,,		:FIND HOST INDEX (HN)
	SKIPAD(DSOZW7)			:NO HOST, ASSUME PORTS REPORTED 'FULL'
	LHL	R0,HSTPTA,HN,HN		:+4 return - PORTS REPORTED AS FULL?
	JE	DSOZW7			:YES
:	NO--SEND NODE REPORT
	STH	R0,SUPMBF+2		:# OF PORTS REPORTED AVAIL LAST
	LIS	R0,0			:SET PORT ARRAY TO 0
	STH	R0,HSTPTA,HN,HN		: (THAT'S WHAT WE'RE TELLING SUP)

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHHOPT		:set host out of ports bit
	STB	R0,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

	LHI	R0,NR.NRJ		:NEEDLE REJECT (HOST OUT OF PORTS)
	STH	R0,SUPMBF
	LHL	R0,HOSTN,HN,HN		:HOST #
	OHI	R0,8000
	STH	R0,SUPMBF+4
	JAL	R10,SUP12,,		:REPORT TO SUP LOG

	LHL	R0,HOSTN,HN,HN		:GET HOST #
	OHI	R0,8000
	STH	R0,SUPMBF
	LHI	R5,8F			:OUT OF PORTS
	LIS	R6,1			:1 HALFWORD TO BE SENT
	LIS	R2,1
	JAL	R10,SUP14,,		:SEND OUT OF PORTS MSG TO SUP

:	DETACH CIRCUIT. REMOVE DISPATCHER PERMUTER TABLE ENTRY FROM DIOTAB,
:	FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB (STARTING WITH
:	DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS FOR SENDING
:	APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING OUT CIRCUIT
:	IF NO ORANGE BALL RETURNED. TEXT TO USER IS DETERMINED BY VALUE STORED
:	IN DETMTY BYTE ARRAY.

:	DONE WITH ACCT. DETACH PORT
DSOZW7	LHL	R2,DIOTAB,R4,R4		:GET EXISTING PERMUTER TABLE ENTRY TO
	NHI	R2,-4			: MOVE TO CIOTAB.
	je	dsoirp			:all clear no needto detach
:	FIND NEXT AVAILABLE CHANNEL TO DETACH PROCESS...
	L	R4,DETACP,,		:DETACH PORT AVAILABLE ?
	JFFO	R4,DSOZW8		:FOUND ONE
	J	DSOZAP			:NO DETACH PORTS, ZAP CIRC TO NETWORK

DSOZW8	HS	0
:	CAUSE ZAPX TO PUT CR/LF INTO BUFFER INSTEAD OF ZAPPER. THIS WILL
:	CAUSE DISPATCHER PORT TO BE FREED UP WITHOUT ZAPPING EXISTING CIRCUIT.
       if	t2gate
	lis	r0,aalr02
	sth	r0,aareas
       ei
	LHI	R1,0D0A			:MAKE ZAPX PUT 'CRLF' INTO BUFFER
	JAL	R9,ZAPX,,		:'ZAP' THE DISPI SIDE OF CIR.
:	STORE 'DETACH REASON' INTO DETMTY BYTE ARRAY
	LIS	R0,2			:INDICATE HOST OUT OF PORTS, DETECTED
	STB	R0,DETMTY,CHN		: BY SLOT WHICH SENT 'BE' MESSAGE

	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER AND
	JAL	R9,CRQHCR,,		:BUILD 2ND HALF OF CKT TO DETACH PROCES
:	SEND NEEDLE POINT TO DETACH PROCESS TO ALERT IT TO NEW PORT.
	XHI	R2,4			:INDEX FOR BUFF TOWARDS DETACH PROCESS
	LIS	R1,3
	JAL	R8,WCI
	LHI	R1,NEEDP
	JAL	R8,WCI			:WRITE NEEDLE POINT IN BUFFER
	J	DSOIRP			:CONTINUE

TOMANY	SC	/"8D"8Atoo many login characters/
LSMX08	SC	/"8D"8Aplease see your representative/
	SC	/"8D"8Aif you are having trouble logging in/


	SUBTTL  DISPI (X.409 DISOUT UTILITIES)

       IF	LOGII

::*********************************************************************
::
::	SUBROUTINE:	X4DWCH/X4DW2C
::	FUNCTION:	write 1 (XDWCH) or 2 (XWDWC2) bytes in R1 to 
::			dispatcher ring
::	CALLING SEQ:	link on R8
::	INPUT:	  PRD, R1
::	OUTPUT:	 PRD to next free position
::
::*********************************************************************

X4DWCH	STB	R1,DIRNG,PRD,		:save char
	AIS	PRD,1
	NR	PRD,TC
	AIS	LRC,1			:count of length written
	JR	R8

X4DW2C	EXBR	R1,R1			:write 2 chars to dispatcher
	JAL	R8,X4DWCH
	EXBR	R1,R1
	JAL	R8,X4DWCH
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	X4DWLN
::	FUNCTION:	write number in R4 to dispatcher as x.409 len
::	CALLING SEQ:	link on R9
::	INPUT:		PRD, R4
::	OUTPUT:	 PRD to next free position
::
::*********************************************************************

X4DWLN	CLHI	R4,MO.LFM		:test if long form
	JLE	X4DWL2			:short form
	CLHI	R4,100			:how long
	JGEFS	X4DWL1			:jump if 2 bytes for len
	LHI	R1,MO.LFM+1		:len of len
	JAL	R8,X4DWCH
	JFS	X4DWL2
X4DWL1	LHI	R1,MO.LFM+2		:len of len
	JAL	R8,X4DWCH
	EXBR	R1,R4			:leading byte
	JAL	R8,X4DWCH
X4DWL2	LR	R1,R4			:low byte
	JAL	R8,X4DWCH
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	X4DGCH
::	FUNCTION:	 get char from dispatcher into R1
::	CALLING SEQ:	link on R9
::	INPUT:		PRD, PRC (number more chars to read)
::	OUTPUT:	 PRD to next free position, R1 with char, PRC
::
::*********************************************************************

X4DGCH	LB	R1,DORNG,PRD,		:get the char
	AIS	PRD,1
	NR	PRD,TC			:advance pointer
	SIS	PRC,1			:reduce count to move
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	X4DGLN - get len of element
::	SUBROUTINE:	X4DGNM - get number from element
::	FUNCTION:	get number from dispatcher into R4
::	CALLING SEQ:	link on R13
::	INPUT:		PRD, PRC, also for X4DGNM R0 has len of number
::	OUTPUT:	 PRD to next free position, R4 with len/number
::
::*********************************************************************

X4DGLN	JAL	R9,X4DGCH
	LR	R4,R1			:setup for potential quick exit
	THI	R4,MO.LFM		:long form?
	JER	R13			:just a simple short form
	LHI	R0,-MO.LFM,R4		:how many bytes the length is
X4DGNM	LIS	R4,0
X4DGN1	JAL	R9,X4DGCH		:get another char
	OR	R4,R1			:add it to running total
	SIS	R0,1			:done yet?
	JER	R13			:yes
	SLLS	R4,8			:open up space for next byte
	JBS	X4DGN1
       EI	:LOGII

	SUBTTL  DISPI (INTRANODE MSG 11 - ICRM Log 2 circuit request)


       IF	1-T2GATE	:following log II stuff is NC specific


:*******************************************************************
:
:	ICRM	handles LOG2 ICRM message (much like a normal PSN request)
:		Comes in on port 0.  Basic Logic is to read ICRM RMOs,
:		saving/checking their data, and writing them back in the
:		NCRM format.  This includes inserting the origination port
:		number.  Format checks on the data are all IDs upto the
:		SMOset are tested for being in correct order.  The RMOset
:		length must be correct and the SMOset length must correspond
:		to the overall (ICRM id) length.  The ICRM id length is checked
:		in LOGSUP when the message is copied to the SUPE's buffer.
:		This routine also calls either ASLP (assign logon port) or
:		ECRI (reject-with the reason).
:*******************************************************************

       IF	LOGII

ICRM	LHI	R0,1A			:room for the ECRI/ASLP?
	JAL	R8,DIROOM	 	:returns when there is room
	LIS	R0,0
	STH	R0,CQNBUF		:if nonzero then our buffer #
	LB	R0,DORNG+3,PRD, 	:cont,subseq,aux bits
	STH	R0,ICRMSB		:ICRM save for bits
	AIS	PRD,4
	NR	PRD,TC
	LHL	PRC,DORNG,PRD,		:length of ICRM
	LHL	R8,DORNG+2,PRD, 	:dispatcher key (only use low byte)
	STH	R8,DORDKY		:save it for response
	NHI	R8,0FF			:get low byte of diskey
       IF	MXPNM			:MXP has funny diskey
	SLLS	R8,4
	EXBR	R7,R8
	OR	R8,R7
	NHI	R8,0FF			:R8 has slot number
       ELSE
	SRLS	R8,2			:normal diskey is 4*slot#
       EI
	THI	R0,L2F.SQ		:is this a subsequent ICRM msg?
	JN	ICRM80
	RBT	R8,SLTRJT		:init to not reject subsequent pieces
	AR	R8,R8
	STH	R8,DORSLT		:save slot *2 (*2 is same as LOG I)
	AIS	PRD,6			:done with len, diskey, skip local key
	NR	PRD,TC			:wrap ring (was not here until 4/93)
	SIS	PRC,4
	LHL	R0,DORNG-2,PRD, 	:local key (okay to -2 since HW alig
	STH	R0,DORLKY
	LHL	R0,TVRBUF		:do we have a supe?
	JE	ECRIX0			:nope, reject reason 0
	LB	R0,NEWSUP		:what type of supe?
	JE	ECRIX7			:a log 2 supe?
	JAL	R7,DSZT90		:check circuits per minute
	SKIPAD(ECRIX5)
	LHI	R5,DISZFL+1		:find ourselves a dispatcher chn
	LHI	R1,NDP-1
	JAL	R9,FNDCHN,,
	SKIPAD(ECRIX1)			:no chns is reject reason 1
	SHI	R5,DISZFL		:we want rel dispatcher chn
	JAL	R8,GFCBUF		:get a place to put the MOs
	SKIPAD(ECRIX3)			:no buffers is reject reason 3
	STH	R2,CQNBUF		:save our buffer number
	SBT	CHN,DISLG2		:this port is doing log 2 login
	LR	PRC,PRC 		:any MOs with ICRM header?
	JGFS	ICRM21
	LIS	R0,0
	SBT	R0,ICRMSB		:mark that this one has no MOs
	JFS	ICRM24

ICRM21	JAL	R9,XCRM 		:handle all of the MO stuff
	SKIPAD(ECRI)			:error number in R5

ICRM24	AHI	CHN,DISZFL		:back to real chn #
	JAL	R9,CRQHCR,,		:build half circuit
	LIS	R0,1			:tell LOGIN to avoid aux logic
	JAL	R8,LOGIN
	SKIPAD(ECRIX0)			:should never happen, checked above
	SHI	CHN,DISZFL		:Back to relative chn#
	SBT	CHN,DISBPV		:release backpressure
       if	cmpnul
	rbt	chn,nulcom		:compress starts of disabled
	rbt	chn,rcvesc		:not rcving 04-07 as data
	rbt	chn,sndesc		:not sending 04-07 unescaped
       ei	:cmpnul
	LHI	R0,INXLIM		:transmit limit
	STH	R0,DIXLIM,CHN,CHN

:	Now write ASLP - everything we care about is fine.
	LHL	R6,DRIF,,		:time to write ASLP
	STH	CHN,DIRNG,R6,		:chn, C5, 0, dkey, lkey
	LHI	R1,DM.ASL^8
	STH	R1,DIRNG+2,R6,
	AIS	R6,4
	NR	R6,TC
	LHL	R1,DORDKY		:dispatcher key
	STH	R1,DIRNG,R6,
	LHL	R1,DORLKY
	STH	R1,DIRNG+2,R6,		:write local key
	AIS	R6,4
	NR	R6,TC
	STH	R6,DRIF,,		:ASLP now written

	LHL	R1,HNPORT		:increment number ports in use
	AIS	R1,1
	STH	R1,HNPORT
	CLHI	R1,MXPORT
	JLEFS	ICRM50			:new high of ports in use
	STH	R1,MXPORT
ICRM50	LHL	R8,DORSLT		:do in use per slot
	LIS	R1,1
	AHM	R1,SCLCNT-2,R8		:another in use

ICRM98	LIS	R0,0
	LHL	R8,DORSLT		:slot#*2
	STH	R0,DORCHN,R8		:mark we finished message
	LHI	R1,LOGXMT+LG.TID	:tell logger ready to go and 1st msg
	STH	R1,BF,R2,
	LH	R0,ICRMSB		:handle potential continue message
	JGEFS	ICRM99
	LHI	R1,10+LG.TID+LOGNDC	:impossible start marks no XCRM rcv
	J	DSOIRP
ICRM99	THI	R0,L2F.PT		:more to come?
	JE	DSOIRP			:done
	LHI	R1,10+LOGSUP+LG.TID	:we are not ready to send
	STH	R1,BF,R2,		:and tell logger that
	STH	CHN,DORCHN,R8		:mark that we are expecting more pieces
	J	DSOIRP			:finally done with ICRM

:	This handles the relatively simple case of later pieces of a message.
:	They can either be continues of a successful request (already sent em
:	an ASLP) in which this data is just copied to the buffer.  Or this
:	could be later pieces of a rejected (ECRI already sent) in which case
:	we just skip over this ISIS message

ICRM80	TBT	R8,SLTRJT		:rejecting it?
	JEFS	ICRM90
	AR	PRD,PRC 		:gobble message
	J	DSOIRP			:done with message

ICRM90	LHL	CHN,DORCHN,R8,R8	:get back our chn #
	JE	ECRI8X			:we have no record of the 1st piece
	LHL	R2,DIOTAB,CHN,CHN	:get back our buffer #
	AIS	PRD,6			:point to MOs
	NR	PRD,TC
	SIS	PRC,4
	AR	R8,R8
	STH	R8,DORSLT
	JAL	R9,XCRM 		:go make XCRM if all there
	SKIPAD(ICRS94)
	J	ICRM98			:copy data and handle more cont



::*******************************************************************
:
:	ECRIXn  returns ECRI with error code n.  All codes except 3
:		must also return the buffer pair.
:		Must skip over rest of ICRM and set up to gobble any
:		subsequent pieces of this message.
:		Routine is alternate exit (instead of ASLP) from ICRM
::*******************************************************************

ECRIX0	LIS	R5,0
	J	ECRI

ECRIX1	LIS	R5,1			:No dispatcher chns
	J	ECRI

: ECRIX2	:No node code, not returned by NC

ECRIX3	LIS	R5,3			:no buffers ava
	J	ECRI

:ECRIX4	handled by DSZT80 when it rejects (circuits/min exceeded by host
ECRIX5	LIS	R5,5
	J	ECRI

ECRIX6	LIS	R5,6			:slot not licensed for aux reqs
	J	ECRI

ECRIX7	LIS	R5,7			:no LOG II supe
	J	ECRI

ECRI8X	LIS	R5,8			:bad form before we got any buffers
	JFS	ECRI

ECRIX8	LIS	R5,8			:bad form of ICRM

ECRI	LHL	R2,CQNBUF		:any buffer to return
	JEFS	ECRI02			:if 0 then no buffer
	JAL	R8,RFCBUF		:return buffer pair
ECRI02	LHL	R0,DORSLT
	SLLS	R0,1			:make slot #
	SBT	R0,SLTRJT		:reject all subsequent partials
	LHL	R6,DRIF,,		:fill pointer
	LHI	R0,DM.ECR^8		:first word of ECRI
	ST	R0,DIRNG,R6,		:write port 0 type 12 no continue
	AIS	R6,4
	NR	R6,TC
	LIS	R0,0D			:message size
	STH	R0,DIRNG,R6,
	LHL	R0,DORDKY		:get dispatcher key
	STH	R0,DIRNG+2,R6,
	AIS	R6,4
	NR	R6,TC
	LHL	R0,DORLKY		:get local key
	STH	R0,DIRNG,R6,
	LHI	R0,MO.AC2+IDECRI	:ECRI
	STH	R0,DIRNG+2,R6,
	AIS	R6,4
	NR	R6,TC
	LI	R0,ECRIM0		:smo, len
	ST	R0,DIRNG,R6,
	AIS	R6,4
	NR	R6,TC
	LHI	R0,ECRIM1		:reject code Id and len
	STH	R0,DIRNG,R6,
	STB	R5,DIRNG+2,R6,		:and store the reason
	AIS	R6,4
	NR	R6,TC
	STH	R6,DRIF,,		:and update pointer

:	Done with writing ECRI, just gobble ICRM and will be done

	LHL	PRD,DROE,,		:get back to start of message
	AIS	PRD,6
	NR	PRD,TC			:point to right after mesage size
	LHL	R0,DORNG-2,PRD, 	:get message size
	AR	PRD,R0
	J	DSOIRP			:and we are done

ECRIM0	EQ	06^18+SMOID^10+04^8+MO.A1+IDBITS :length smo element
ECRIM1	EQ	ID.ERC^8+01		:reject ID and len

       EI	:LOGII

	SUBTTL DISPI (TYPE C4 - ICRS Logon information for LOG II logon)


::***********************************************************
:
:	ICRS	Handles LOG2 supplemental messages.  Writes in
:		RMOset with bit for second msg to supe and dispatcher
:		chn #.  Only check is overall ICRS length and SMO length
:		end up at the same point.
:
::***********************************************************

       IF	LOGII
NCRLHD	SC	/"30"09"5A"00"02/	:RMOseq upto chn # for CHN>100
NCRSHD	SC	/"30"08"5A"00"01/	:same but for chn #<100
NCRMTL	SC	/"5F"3D"00"02"06"40/	:then the NCRM flags

ICRS	LB	R0,DORNG,PRD,		:get bits of continue, subseqent
	STH	R0,ICRMSB		:save them
	AIS	PRD,1			:bump to len field
	NR	PRD,TC
	LHL	PRC,DORNG,PRD,		:get size of message
	AIS	PRD,2			:update pointer, no NR since on HW
	LHL	R1,BF,R2,		:make sure port in proper login mode
	TBT	CHN,DISLG2		:Make sure this one started as LOG 2
	JE	ICRSR1			:this guy started LOG1 and now LOG2?
	CLHI	R1,10+LOGNDC+LG.TID	:ICRS with XCRM MOs?
	JE	ICRS90			:yes, handle specially
	CLHI	R1,10+LOGSUP		:better in login mode with ready supe
	JN	ICRSR0			:reject, wrong time for ICRS
	THI	R0,L2F.SP		:is this a subsequent piece?
	JN	ICRS60			:handle subsequent piece
	LHL	R1,DORNG,PRD,		:get ICRS ID
	CLHI	R1,MO.AC2+IDICRS	:make sure it is ICRS id
	JN	ICRSR2			:reject ICRS
	AIS	PRD,2
	NR	PRD,TC
	SIS	PRC,2
	LHI	R1,MO.AC2+IDNCRM	:NCRM ID
	JAL	R9,W2CI
	JAL	R13,X4DGLN		:get length of ICRS
	LR	R1,R4			:make sure ICRS element and SMO end ok
	SR	R1,PRC
	STH	R1,ICRMS2		:compare against smo len
	AIS	R4,0A			:make room for RMOseq
	CLHI	CHN,100 		:need extra for larger chn#
	JLFS	ICRS10
	AIS	R4,1			:chn# requires 2 bytes
ICRS10	JAL	R9,X4BWLN,,		:write new length
	LA	R4,NCRSHD		:address of NCRM header for ICRS
	CLHI	CHN,100
	JLFS	ICRS12
	LA	R4,NCRLHD		:NCRM RMO, bits and org port ID&len
ICRS12	JAL	R9,BUFCAN
	LR	R1,CHN
	CLHI	CHN,100 		:two bytes of writing?
	JLFS	ICRS14			:nope
	JAL	R9,WHWI 		:write two byte CHN
	JFS	ICRS15
ICRS14	JAL	R9,WCIE 		:write one byte CHN#
ICRS15	LA	R4,NCRMTL		:then come NCRM flags
	JAL	R9,BUFCAN

:	check for SMOset and compare it's length vs msg length
	JAL	R9,X4DGCH		:get SMO id
	CLHI	R1,SMOID		:SMOID is 30
	JN	ICRSR2
	JAL	R8,WCI			:write it
	JAL	R13,X4DGLN		:length of SMO
	LR	R1,R4
	SR	R1,PRC
	CLH	R1,ICRMS2		:SMOset end same place as ICRS element
	JN	ICRSR2			:error, reject
	JAL	R9,X4BWLN,,		:write len back to buffer

:	now ready for just copy from ring into buffer
:	Also, point of entry for subsequent pieces

ICRS60	LB	R1,DORNG,PRD,		:copy rest of data
	JAL	R9,WCIE
	AIS	PRD,1
	NR	PRD,TC			:this a just X4DGCH but faster
	SIS	PRC,1
	JGBS	ICRS60

:	setup to handle partial
	LHL	R0,ICRMSB		:get back ICRS msg flags
	THI	R0,L2F.PT
	JN	DSOIRP			:still waiting for end of ICRS
	LHI	R1,LOGXMT		:tell logger we are ready to send
	STH	R1,BF,R2,
	J	DSOIRP			:return to mainline

ICRS90	JAL	R9,XCRM 
	SKIPAD(ICRS94)			:if error
	J	ICRM98			:set BF for XCRM (not yet sent to SP

ICRS94	LB	R6,ICRSTB,R5		:convert error code
	J	ICRSRJ

ICRSTB	BC	0,0,0,0,0,5,4,0,4	:cir min host and bad XCRM form
	HS	0


:	handle case of NC found bad form.
:	do it by sending RCRI with reject reason back to slot,
:	followed by the detach msg, and send a zapper towards LOGGER
:	LOGGER will take the zapper, convert it for DISLG2 ports into
:	a NCRM with a log zap smo.  LEP will get the RCRM with the log
:	zap ack and then we clean out port and buffers.

ICRSR0	LIS	R6,0			:reject, they didn't wait for RCRI
	J	ICRSRJ

ICRSR1	LIS	R6,1			:started as LOG 1 and sent log 2
	JFS	ICRSRJ

ICRSR2	LIS	R6,2			:bad form

:	for a ICRS reject we clear the offending msg from our buffer
:	and send error back to the port. (as if nothing happened).
ICRSRJ	AR	PRD,PRC 		:eat whatever left of msg
	JAL	R8,CBCLR		:clear msg (whatever written)
	LHL	R7,DRIF,,		:get ring pointer
	STH	CHN,DIRNG,R7,		:write chn #
	LHI	R0,ISRCRI^8		:type C3 RCRI
	STH	R0,DIRNG+2,R7,
	AIS	R7,4
	NR	R7,TC
	LIS	R1,0			:setup to send reject msg
	JFS	RCRIJ2
RCRIJ1	AIS	R7,1
	NR	R7,TC			:bump up pointer
RCRIJ2	LB	R0,ICRSRM,R1		:get fixed part of msg
	STB	R0,DIRNG,R7,
	AIS	R1,1			:offset into msg
	CLHI	R1,ICRSRZ		:done with it?
	JLEBS	RCRIJ1			:nope, get another
	STB	R6,DIRNG,R7,		:reject reason
	AIS	R7,1+3			:1 for byte written, 3 for end of msg
	NHI	R7,DRSZ-4		:finished with msg
	STH	R7,DRIF,,		:store ring pointer
	J	DSOIRP



::*****************************************************************
:	XCRM	subroutine which processes the X.409 IcRM msg.
:		skip +4 return if all ok,  normal if error and error
:		code in R6.  code expects len in PRC, pos in PRD and
:		buffer in R2, dispi chn # in r5
::*****************************************************************


XCRM	ST	R9,ICRMS3
XCRM01	LB	R1,DORNG,PRD,		:copy data into buffer for parsing
	JAL	R9,WCIE
	AIS	PRD,1
	NR	PRD,TC			:this a just X4DGCH but faster
	SIS	PRC,1
	JGBS	XCRM01

	LHL	R0,ICRMSB		:is there more to come?
	THI	R0,L2F.PT		:not done yet bit
	JN	XCRM99

	JAL	R8,X4CRIZ,,		:initialize mo create table
	L	R3,BB,R2,
	ST	R3,ELEPOS		:setup primitive X.409 parse routines
	LIS	R0,2
	JAL	R9,X4NXID,,		:get ICRM id
	LHI	R4,IDNCRM+MO.AC2
	JAL	R8,X4CCID,,		:enter the constructor
	JAL	R9,X4NXID,,		:Parse out RMO
	LHI	R4,RMOID
	JAL	R8,X4CCID,,		:then comes RMO construction
	LR	R1,CHN
	LHI	R4,ID.PRT+MO.A1 	:first comes our port number
	JAL	R8,X4CRID,,		:enter into create table
	JAL	R9,X4NXID,,		:get ICRM flags
	LR	R4,R3			:save pointer to start of data
	CLHI	R0,2			:only worry unused bits for first byte
	JGFS	XCRM05
	LB	R0,0,R3 		:get unused bits
	JNFS	XCRM03			:Not escaped
	JAL	R8,NCI
	LB	R0,0,R3
XCRM03	SIS	R0,6			:indicate at least 2 bits in use
	JLEFS	XCRM05			: since we use bit 1
	LIS	R0,6			:mark that bit 1 is used
	STB	R0,0,R3
XCRM05	LR	R3,R4
	JAL	R9,PCIE 		:skip over byte of unused bits
	LB	R0,0,R3 		:the first byte of bits
	JNFS	XCRM07
	JAL	R8,NCI
	LB	R0,0,R3 		:in case escaped
XCRM07	NHI	R0,@L2F.SQ		:make sure subsequent bit is reset
	STB	R0,0,R3
	RBT	CHN,DISAUX		:guess not aux request
	THI	R0,L2F.AX		:aux cir request?
	JEFS	XCRM10			:not aux request
	LH	R0,ICRMSB		:get back our saved bits
	THI	R0,L2F.DL		:aux request have dispatcher license?
	JE	XCRMX6			:nope, reject
	SBT	CHN,DISAUX		:set aux bit
XCRM10	LHL	R0,X4NXVL+2		:get len of buffer data
	LR	R3,R4			:get address of start of buffer data
	LHI	R4,ID.NMF+MO.A2 	:NCRM flags are known okay
	JAL	R8,X4CBID,,		:write element with data in buffer

	JAL	R9,X4NXEL,,		:move upto end of flags element
	JAL	R9,X4NXID,,		:parse OHOST id element
	LHI	R4,ID.OHS
	CLB	R4,X4NXVL+1		:make sure is OHOSt id
	JN	XCRMX8			:error if not
	LHI	R4,ID.OHS+MO.A1
	JAL	R8,X4CBID,,		:put it into create table
	L	R3,ELEPOS		:adress of x.409 data
	JAL	R7,X4GTNM,,
	STH	R4,DORHST		:save host number
	STH	R4,DHSTIX,CHN,CHN	:for tracing
	LR	R13,R2			:save our buffer #
	IF	RESHST
	LCS	HN,1			:IF NEGATIVE, HOST NOT FOUND,SEE DSZ07C
	LR	R1,R4
	JE	XCRM13			:HOST 0 NOT DEFINED
	JAL	R9,FNDHST,,		:DO WE KNOW ABOUT THIS HOST?
	SKIPAD(XCRM13)			:immed, NO - SKIP ORIGIN HOST EDIT#wjl
	LH	R0,HCTSM,HN,HN		:+4, GET CIRCS/MIN LIMIT FOR THIS HOST
	JLFS	XCRM13			:NO EDITING DESIRED
	CLH	R0,HCTSCT,HN,HN		:LIMIT EXCEEDED?
	JGFS	XCRM13			:okay to attempt circuit build
	JLFS	XCRM14			:only report when just reach limit
	JAL	R7,DSZT96		:report limit exceeded
XCRM14	LIS	R5,5			:ECRI reason 5 for log 2
	J	XCRMRG
	EI	:RESHST

XCRM13	LR	R2,R13			:get back buffer #

	JAL	R9,X4NXEL,,
	JAL	R9,X4NXID,,		:Get CCT id
	LHI	R1,ID.CCT
	CLB	R1,X4NXVL+1		:was that the found ID?
	JN	XCRMX8
	LHI	R4,ID.CCT+MO.A1 	:cct ID
	JAL	R8,X4CBID,,
	JAL	R8,X4FXCN,,		:finished with RMO constructor

	JAL	R9,X4NXEL,,
	JAL	R9,X4NXID,,		:get to SMOset ID
	LHI	R1,SMOID&1F		:test if ID correct
	CLB	R1,X4NXVL+1
	JN	XCRMX8
	LHI	R4,SMOID
	JAL	R8,X4CBID,,		:do like a huge element
	JAL	R8,X4FXCN,,		:finished with NCRM constructor

	JAL	R8,CBCCT
	LR	R13,R1
	JAL	R8,X4CBWR,,		:write NCRM into buffer
	LR	R0,R13
	JAL	R8,RTBFTS		:eveything before NCRM
       IF	RESHST			:count for hosts with restrictions
	LIS	R1,1
	LR	HN,HN			:host known to us?
	JLFS	XCRM54
	AHM	R1,HCTSCT,HN,HN
XCRM54
       EI

XCRM99	L	R9,ICRMS3		:get link register
	J	4,R9			:successful XCRM msg

XCRMX8	LIS	R5,8
	JFS	XCRMRG

XCRMX6	LIS	R5,6
XCRMRG	L	R9,ICRMS3		:got error codes, now return
	SKIP(0,R9)

       EI	:LOGII

       EI	:1-T2GATE	(began before ICRM)


::*********************************************************************
	::
::	TABLE:		DSOMTB:
::	FUNCTION:	DISPATCH TABLE FOR PORT SIGNALS FROM ISIS
::	NOTE: SYMBOL SEG1.1 IS DEFINED AT BEGINNING OF DISOUT TO ALLOW
::	ROUTINE ADDRESS TO BE STORED AS HALF-WORDS
::
::*********************************************************************

DSOMTB	HC	DSODET-SEG1.1	:9E - DETACH				###wjl
				:ISIS makes 9E into YB, wait for OB, ZAP.
	HC	DSOZAP-SEG1.1	:9F - ZAPPER
	HC	DSOSBP-SEG1.1	:A0 - SET BACKPRESSURE
	HC	DSORBP-SEG1.1	:A1 - RELEASE BP
	HC	DSOGOB-SEG1.1	:A2 - GOBBLER
	HC	DSOIRP-SEG1.1	:A3 - REVERSE GOBBLER (UNUSED)
	HC	0FD01		:A4 - BLACK BALL
	HC	0FC01		:A5 - GREY BALL
	HC	DSOEDE-SEG1.1	:A6 - EDEM
	HC	DSOLDE-SEG1.1	:A7 - LDEM
	HC	0F201		:A8 - ENTER TRM
	HC	0F301		:A9 - LEAVE TRM
	HC	DSOGRN-SEG1.1	:AA - GREEN BALL
	HC	DSORED-SEG1.1	:AB - RED BALL
	HC	0FF01		:AC - YELLOW BALL
	HC	0FE01		:AD - ORANGE BALL
	HC	0FB01		:AE - BREAK DETECTED
	HC	0F001		:AF - HANG UP
	HC	DSOQPR-SEG1.1	:B0 - QUERY PARAMETER
	HC	DSOSPR-SEG1.1	:B1 - SET PARAMETER
	IF	T2GATE
	HC	GDB2-SEG1.1	:B2 - PSEUDO NEEDLE 
	HC	DSOCRH-SEG1.1	:B3 - LOGON CHAR
	HC	GDB4-SEG1.1	:B4 - LOGON STATUS 
	HC	GDB5-SEG1.1	:B5 - LOGON FAILURE 
	HC	GDB6-SEG1.1	:B6 - SUCCESSFUL LOGON 
	HC	DSOCRH-SEG1.1	:B7 - ADDENDUM TO ACCOUNTING
	ELSE
	HC	DSOCRH-SEG1.1	:B2 - PSEUDO NEEDLE (ILLEGAL)
	HC	DSOLGC-SEG1.1	:B3 - LOGON CHAR
	HC	DSOCRH-SEG1.1	:B4 - LOGON STATUS (ILLEGAL)
	HC	DSOCRH-SEG1.1	:B5 - LOGON FAILURE (ILLEGAL)
	HC	DSOCRH-SEG1.1	:B6 - SUCCESSFUL LOGON (ILLEGAL)
	HC	DSZACC-SEG1.1	:B7 - ADDENDUM TO ACCOUNTING
	EI	:T2GATE
	HC	DSOHNG-SEG1.1	:B8 - SUPERHANG
	HC	DSOSXL-SEG1.1	:B9 - SET XMIT LIMIT
	HC	DSOIRP-SEG1.1	:BA - END OF BREAK
	HC	DSOZAK-SEG1.1	:BB - ZAP ACK
	HC	0F401		:BC - ENTER ALTERNATE DEVICE MODE
	HC	0F501		:BD - LEAVE ALTERNATE DEVICE MODE
	HC	DSOZWR-SEG1.1	:BE - ZAP WITH REASON
	HC	0F601		:BF - ENTER IIX EXCHANGE
	HC	0F701		:C0 - LEAVE IIX EXCHANGE
      IF	LOGII		:only legal if LOG II
       IF	1-T2GATE	:different list for gateway
	HC	DSOCRH-SEG1.1	:C1 UUN (never received by NC)
	HC	DSOCRH-SEG1.1	:C2 ISN (never received by NC)
	HC	DSOCRH-SEG1.1	:C3 RCRI (never received by NC)
	HC	ICRS-SEG1.1	:C4 ICRS (more LOGII logon data)
       ELSE	:1-T2GATE	:gateway's list of ISIS msgs
	HC	DSOCRH-SEG1.1	:C1 UUN (never received by gateway)
	HC	GDISN-SEG1.1	:C2 ISN (LOG II needle in for gateway)
	HC	GDRCRI-SEG1.1	:C3 RCRI (circuit building status)
	HC	DSOCRH-SEG1.1	:C4 ICRS (logon data msg never received by gate
	HC	GDASLP-SEG1.1	:C5 ASLP (assigns logon port)
	HC	GDLGSC-SEG1.1	:C6 LGSC (logon successful)
       EI	:1-T2GATE
      EI	:LOGII
DSODMX	EQ	(.-DSOMTB)/2

::*********************************************************************
::
::	TABLE:	DSOMBA:
::	FUNCTION:	
::
::	THE FOLLOWING BIT ARRAY INDICATES WHICH DSOMTB ENTRIES CONTAIN
::	THE ACTUAL MAPPING CHARACTERS, AND WHICH HAVE ROUTINE ADDRESSES TO
::	HANDLE THE MAPPING FUNCTION. THE ARRAY IS RELATIVE TO MESSAGE TYPE
::	9E, AND THE ONE BITS REPRESENT ENTRIES WHICH CONTAIN THE CHARACTER.
::
::*********************************************************************

DSOMBA	BC	03	:9E-A5
	BC	033	:A6-AD
	BC	0C0	:AE-B5
	BC	03	:B6-BD
	BC	60	:(BE-C5) BIT ARRAY FOR 'TRIVIAL CONVERSION'

::*********************************************************************
::
::	TABLES:		TQPR,  TSPR,  TSPRM.
::	FUNCTION:
::
::	THE FOLLOWING 3 TABLES ARE ARRANGED IN ISIS MESSAGE ORDER
::	AND ARE USED TO TRANSLATE 'SET TERMINAL' TYPE MESSAGES
::
::*********************************************************************

:	QUERY TERMINAL PARAMETERS
TQPR	BC	0A0,0A2,0A6,0A4	:DSOQPR TABLE
	BC	0AE,093,098,0AA
	BC	0A8,097,096,095
	BC	0AC,0B0,0B2,094
	BC	0B4,0B6,0B8,0BA
	BC	0,0,0,0		:ADDITIONAL 0'S FOR FILLER ONLY
	BC	0,0,0,0
	BC	0,0,0,0

:	SET TERMINAL PARAMETERS
TSPR	BC	0C0,0C2,0C6,0C4	:DSOSPR TABLE
	BC	0CE,030,080,0CA
	BC	0C8,070,060,050
	BC	0CC,0D0,0D2,040
	BC	0D4,0D6,0D8,0DA
	BC	0,0,0,0		:ADDITIONAL 0'S FOR FILLER ONLY
	BC	0,0,0,0
	BC	0,0,0,0

TSPRM	BC	01,01,01,01	:DSOSPR MASKS
	BC	01,0F,0F,01
	BC	01,0F,0F,0F
	BC	01,01,01,0F
	BC	01,01,01,01
	BC	01,01,01,01	:ADDITIONAL 01'S FOR FILLER ONLY
	BC	01,01,01,01
	BC	01,01,01,01

	SUBTTL	DISPI (DSZERO - Intra-ISIS Comunications, RPORT = 0)

::*********************************************************************
::
::	SUBROUTINE:	DSZERO:
::	FUNCTION:	PROCESS COMMANDS ON CHANNEL 0.
::			INTRA-ISIS COMUNICATIONS.
::
::*********************************************************************

DSZERO	LB	R1,DORNG+2,PRD,		:CHANNEL ZERO MESSAGE, GET TYPE
	CLHI	R1,DSZETL		:TEST NOT NECESSARY IF ISIS WORKING OK
	JLFS	DSZER1
	CRASH.(.DSZE0)
DSZER1	SLLS	R1,2			:FW indexing			###wjl
	L	R1,DSZETB,R1,		:DISPATCH			###wjl
	JR	R1			:				###wjl

::*********************************************************************
::
::	SUBROUTINE:	DSZTLG:
::	FUNCTION:	07 - PSEUDO NEEDLE REQUEST
::			NORMAL CIRCUIT-BUILDING REQUEST
::
::*********************************************************************
	IF	(1-T2GATE)		:Not used for Gateway
DSZTLG	
	JAL	R10,DSZATS		:NORMAL CIRCUIT REQUEST - SET UP
	SKIPAD(DSZ07B)			:IMMED, SOME FAILURE (SEE DSZATS)###wjl
	LHL	R1,DORHST		:+4, GET HOST NUMBER (SET UP IN DSZATS)
	OHI	R1,8000			:PREPARE FOR SUP MESSAGE
	JAL	R9,WHWI			:WRITE INTO LOGIN BUFFER
	LB	R1,DORNG,PRD,		:GET THE TID
	JAL	R8,WCI			:SEND IT TO THE LOG ON BUFFER
	LR	R0,R1			:GET TID FOR LOGIN ROUTINE

	JAL	R8,LOGIN
	SKIPAD(DSZ07B)			:immed return, NO SUP, ZAP IT	###wjl
	LH	R0,DORSIQ		:+4, SEE IF SIQ SET FOR THIS CIRCUIT
	JGEFS	DZ0710			:NO
:	CIRCUIT HAS SIQ SET, IS 'SMART'. SET GOUGING BIT IN IOTAB FOR
:	THIS CIRCUIT SO LOGGER CAN INFORM SUP OF SMART CIRCUIT.
	XHI	R2,4
	LHL	R4,BF,R2,		:GET ORIGINATION CHANNEL
	LHL	R1,IOTAB,R4,R4
	AIS	R1,1			:'GOUGING' BIT FOR PORT IN LOGIN MODE
	STH	R1,IOTAB,R4,R4		: MEANS SMART CIRCUIT

DZ0710	SHI	CHN,DISZFL		:RELATIVE PORT #
					:RELATIVE DISPI CHANNEL #
       IF	LOGII			:note that dispi chn is LOGI
	RBT	CHN,DISLG2		:not a LOG II login attempt
       EI	:LOGII			:
	RBT	CHN,DISELS		:EXTENDED LOG-IN STATUS
	THI	R0,PSNELS		:TEST ELS BIT
	JEFS	DZ0711			:NO
	SBT	CHN,DISELS		:else set bit in ELS bit array
DZ0711	RBT	CHN,DISAUX		:INDICATE NORMAL LOGON
	lis	r1,1			:the PLI logon status
	stb	r1,dlgsts,chn,		:save current logon status

:	PSEUDO NEEDLE REQUEST O.K. AND CHANNEL ASSIGNED. RETURN
:	PSEUDO NEEDLE TO REQUESTING SLOT.  This is also for AUX Circuit
:	requests
DSZ07C	LHL	R1,HNPORT		:INCREMENT NUMBER OF HOST PORTS IN USE
	AIS	R1,1
	CLH	R1,MXPORT		:IS THIS A NEW PEAK?
	JLEFS	DSZMPX			:NO
	STH	R1,MXPORT		:YES, RECORD IT
DSZMPX	STH	R1,HNPORT
	LH	R1,DORHST		:GET ORIG. HOST #
	STH	R1,DHSTIX,CHN,CHN	:SAVE IT FOR PROBE TRACE REPORTING
	LHI	R1,0B2			:'B2' MESSAGE - PSEUDO NEEDLE

DSZ07A	LHL	R6,RPSAV		:POINTS TO START OF MESSAGE
	STB	R1,DIRNG+2,R6,		:MESSAGE TYPE (0B2 OR OTHER)
	STH	CHN,DIRNG,R6,		:RELATIVE DISPI CHANNEL #
	AIS	R6,8
	NR	R6,TC			:UPDATE POINTER
	STH	R6,DRIF,,
	LHL	R8,DORSLT		:CIRCUIT ORIGINATING SLOT (SLOT# * 2)
	LIS	R1,1
	AHM	R1,SCLCNT-2,R8		:INCREMENT NUMBER OF CIRCUITS THIS SLOT
	IF	RESHST
	LR	HN,HN			:IS THIS HOST KNOWN TO US?
	JL	DSOIRP			:NO - EXIT
	AHM	R1,HCTSCT,HN,HN		:INCREMENT NUMBER OF CIRCUITS THIS HOST
	EI	:RESHST
	J	DSOIRP			:ALL DONE

:	REJECT LOGON
DSZ07B	LIS	R1,9			:REJECT LOGON (RETURN TYPE '9')
	LIS	CHN,0			:CHANNEL 0 MESS
	J	DSZ07A

::*********************************************************************
::
::	SUBROUTINE:	DSZALG:
::	FUNCTION:	08 - AUX CIRCUIT REQUEST
::
::*********************************************************************

DSZALG	JAL	R10,DSZATS		:AUX CIRCUIT REQUEST - SET UP
	SKIPAD(DSZ08C)			:IMMED, FAILURE, REJECT		###wjl
	LB	LRC,DORNG,PRD,		:# CHARS IN STRING
	AIS	PRD,1			:START OF STRING
DSZ08A	LB	R1,DORNG,PRD,		:MOVE STRING
	AIS	PRD,1
	NR	PRD,TC
	OHI	R1,80			:ESCAPE ALL
	JAL	R8,WCI
	SIS	LRC,1
	JGBS	DSZ08A
:	IF LAST BYTE NOT CR OR SEMI-COLON, APPEND CR TO USER NAME
	CLHI	R1,8D			:= <CR> ?
	JEFS	DSZ08B			:YES, GO AHEAD
	CLHI	R1,0BB			:= "SEMI-:" ?
	JEFS	DSZ08B			:YES, GO AHEAD
	LHI	R1,8D			:APPEND A <CR> TO
	JAL	R8,WCI			: THE LOG IN STRING
DSZ08B	LIS	R0,0			:INITIATE LOGIN - AUX MODE
	JAL	R8,LOGIN
	SKIPAD(DSZ07B)			:immed ret, NO SUP, REJECT LOGON###wjl
	SHI	CHN,DISZFL		:+4 return, RELATIVE PORT #
	SBT	CHN,DISAUX		:INDICATE AUX LOGON
	J	DSZ07C


DSZ08C	LB	LRC,DORNG,PRD,		:REJECT, SKIP TO END OF MESS
	AHI	PRD,1,LRC
	J	DSZ07B			:AND REJECT LOGON

::*********************************************************************
::
::	SUBROUTINE:	DSZATS:
::	FUNCTION:	SETUP ROUTINE FOR CIRCUIT REQUEST
::	CALLING SEQ:	JAL	R10,DSZATS
::	RETURNS:	IMMEDIATE - reject
::			+4 - ok
::
::*********************************************************************

DSZATS	LIS	R0,8			:SET UP TO RETURN NEEDLE OR REJECT
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:INPUT RING POINTER
	STH	R6,RPSAV		:SAVE IT FOR FILLING IN LATER
	LB	R8,DORNG+3,PRD,		:KEY (SLOT NUMBER * 4)
	STB	R8,DIRNG+3,R6,
	IF	MXPNM			:ISIS-MXP EXPECTS A DIFF KEY 	###GT
					: ( = SLOT #, MACHINE #)	###GT
	SLLS	R8,4			:SHIFT LO 4 BITS TO UPPER 4 BITS###GT
	EXBR	R7,R8			:MOVE UPPER 4 BITS TO LO 4 BITS	###GT
	OR	R8,R7			:FORM A SLOT # (MACH #, SLOT #)	###GT
	NHI	R8,0FF			:SAVE LOWER BYTE		###GT
	SLLS	R8,1			:FORM HALFWORD INDEX		###GT
	ELSE				:OLD-FASHIONED ISIS HAS KEY=SLOT # * 4
	SRLS	R8,1
	EI	:MXPNM			:MXP DIFFERENCE ENDS HERE
	STH	R8,DORSLT		:SAVE SLOT NUMBER * 2
	AIS	R6,4
	NR	R6,TC
	AIS	PRD,4
	NR	PRD,TC			:NOW POINTS TO LOCAL KEY
	LHL	R1,DORNG,PRD,		:KEY
	STH	R1,DIRNG,6,
	LHL	R1,DORNG+2,PRD,		:HI-ORDER BIT OF 'DIALECT' FIELD
	STH	R1,DORSIQ		: IS SIQ
	LIS	R1,0
	STH	R1,DIRNG+2,6,
	AIS	R6,4
	NR	R6,TC			:PUT AWAY POINTER
	AIS	PRD,4			:POINT PRD TO ORIGINATING HOST #
	NR	PRD,TC
	LHL	R1,DORNG,PRD,		:GET ORIGINATING HOST,
	STH	R1,DORHST		: AND SAVE FOR 'LOGIN'
	AIS	PRD,2			:PRD NOW POINTS TO TID OR BYTE COUNT
	JAL	R7,DSZT80		:check circuits/min for slot/host###sdw
	SKIPAD(DSZEXI)			:(immediate return) rejected	###sdw
	LHI	R1,NDP-1		:FIND A FREE CHANNEL
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN,,
	SKIPAD(DSZEXI)			:(immediate return) REJECT	###wjl
	JAL	R8,GFCBUF,,		:(+4 return) GET BUFFER	
	SKIPAD(DSZEXI)			:(immediate return) REJECT	###wjl
	JAL	R9,CRQHCR,,		:(+4 return) BUILD HALF CIRCUIT
	LHI	R1,-DISZFL,CHN		:R1 = REL. DISPI CHN #
	SBT	R1,DISBPV		:RELEASE BP
       if	cmpnul
	rbt	r1,nulcom		:compress starts of disabled
	rbt	r1,rcvesc		:not rcving 04-07 as data
	rbt	r1,sndesc		:not sending 04-07 unescaped
       ei	:cmpnul
	LHI	R0,INXLIM
	STH	R0,DIXLIM,R1,R1		:TRANSMIT LIMIT PER PORT.
	J	4,R10			:ALL OK


:	subroutne linking on R7 to checks host and slot circuits/min limits
:	enterred at either dszt80 or  dszt90

DSZT80					:Make circuits/min a subroutine
	IF	RESHST
	LCS	HN,1			:IF NEGATIVE, HOST NOT FOUND,SEE DSZ07C
	LR	R1,R1
	JE	DSZT90			:HOST 0 NOT DEFINED
	JAL	R9,FNDHST,,		:DO WE KNOW ABOUT THIS HOST?
	SKIPAD(DSZT90)			:immed, NO - SKIP ORIGIN HOST EDIT#wjl
	LH	R0,HCTSM,HN,HN		:+4, GET CIRCS/MIN LIMIT FOR THIS HOST
	JLFS	DSZT90			:NO EDITING DESIRED
	CLH	R0,HCTSCT,HN,HN		:LIMIT EXCEEDED?
	JG	4,R7			:okay to attempt circuit build
	JE	DSZT96			:report limit exceeded
	SKIP(0,R7)
	EI	:RESHST
DSZT90	LHL	R1,DORSLT
	LH	R0,SCLTBL-2,R1		:GET LIMIT FOR CIRCS/MINUTE THIS SLOT
	JL	4,R7			:NO CHECKING DESIRED
	CLH	R0,SCLCNT-2,R1		:LIMIT EXCEEDED?
	JG	4,R7			:limit not exceeded
	JEFS	DSZT96
	SKIP(0,R7)

DSZT96	OHI	R1,8000
	STH	R1,SUPMBF+4		:HOST NUMBER + 8000
	LHL	R8,DORSLT
	SRLS	R8,1
	OHI	R8,8000			:SLOT NUMBER + 8000
	STH	R8,SUPMBF+2
	LHI	R8,NR.CLE
	STH	R8,SUPMBF		:INDICATE HOST/SLOT CIRC LIMIT EXCEEDED
	LR	R6,R10			:save R10
	JAL	R10,SUP12,,		:MAKE REPORT TO SUP LOG
	LR	R10,R6
	SKIP(0,R7)	 		:Done with report to SUP


DSZEXI	SKIP(0,R10)			:immediate return		###wjl

	EI	:(1-T2GATE)		: All of above not used for Gateway

::*********************************************************************
::
::	SUBROUTINE:	DSZHSH:
::	FUNCTION:	10 - EXTENDED REPORT HOST STATUS
::	FORMAT:
::		--------.-------.-------.--------
::		|	0       |  10   |  key  |
::		|-------.-------.-------.-------|
::		|  Host number  | number/ports  |
::		|-------.-------.-------.-------|
::		|    RH No.     |status | H key |
::		|-------.-------.-------.--------
::		|xstatus|  PID |
::		-----------------
::	Status currently specifies these parameters:
::		The low 2 bits specify one of 4 host states:
::			0	host answered
::			1	host down
::			2	host shut (but up)
::			3	host gone
::		The next bit (mask x04) specifes if H key is meaningful.
::		The high order bit (mask x80) specifies if this is a LOG II
::		capable host.
::
::	Xstatus, the eXtended status byte currently specifies:
::		I O D P C C 0 0
::		I	Host I/Q (HIQ)
::		O	Originate only
::		D	Destination only
::		P	Proxy host
::		C C	Collect-call capability:
::			0	never accept collect calls
::			1	only accept collect calls
::			2	leave the decision to the destination host
::			3	unused
::		0 0	Unused
::	MESSAGE FROM HOST WHICH INCLUDES HOST STATUS, HIQ, AND HID.
::	HOST STATUS PROCESSING IS THE SAME AS FOR THE TYPE 04 ISIS
::	MESSAGE FOR REPORTING HOST STATUS ONLY.  THE CELL 'DSOHYP' IS
::	SET TO -1 FOR TYPE 10 MESSAGE, 0 FOR TYPE 04 MESSAGE SO COMMON
::	LOGIC CAN BE USED.
::
::	THE NODE-TO-SUPERVISOR MESSAGE, TYPE 11, MAY INCLUDE HOST STATUS,
::	HIQ, AND HID.  THE FORMAT OF THE FIRST HALFWORD OF THE MESSAGE
::	INDICATES THE MESSAGE CONTENTS TO THE SUPERVISOR. THE FIRST HALFWORD IS
::			[11,X0+STATUS],
::	WHERE X IS DEFINED BY THE FOLLOWING EQUATES:
::
::*********************************************************************

HS.ANS	EQ	0	:host answered
HS.DWN	EQ	1	:host down
HS.SHT	EQ	2	:host shut (but up)
HS.GNE	EQ	3	:host gone

HS.HID	EQ	80	:HID PRESENT IF 0.  6-BYTE MSG WITH HID, ELSE 4 BYTES.
HS.SET	EQ	40	:SET IF HS.HID NOT SET (TO PREVENT ESCAPING)
HS.STS	EQ	20	:IGNORE HOST STATUS BITS IF 1 (NO CHANGE IN STATUS)
HS.HIQ	EQ	10	:HIQ FLAG.  SMART HOST IF 1, ELSE DUMB.

	IF	(1-T2GATE)		:Gateway will not receive following

DSZHSH	TS	DSOHYP			:this message from slot has extra hw
	JFS	DZHS02			: containing HIQ & HID data for host

::*********************************************************************
::
::	SUBROUTINE:	DSZHST:
::	FUNCTION:	04 - REPORT HOST STATUS
::
::*********************************************************************

DSZHST	LIS	R2,0			:INDICATE PROCESSING TYPE 04 MESSAGE
	STH	R2,DSOHYP

:	COMMON LOGIC FOR TYPE 10 AND 04 MESSAGES

DZHS02	LB	R2,DORNG+3,PRD,		:SAVE KEY IN R2
	AIS	PRD,4
	NR	PRD,TC			:REPORT HOST STATUS
	LHL	R1,DORNG,PRD,		:HOST #
	JAL	R9,FNDHST,,		:LOCATE HOST ENTRY
	SKIPAD(DZHS50)			:NO ENTRY IN HOSTN TABLE.  MAKE ONE.

:	Found the host in HOSTN.  VERIFY THAT THE HOST KEY (4*SLOT #) MATCHES.
	CLB	R2,HSTKEY,HN		:+4 return
	JE	DZHS04			:BRANCH IF KEY MATCHES

	LB	R0,HSTAT,HN		:KEY DOESN'T MATCH. INCUMBENT HOST DWN?
	SIS	R0,1			:status 1 is "down"
	JE	DZHS03			:yes, host down			###wjl
	TBT	HN,HSTFLG		:reporting for the first time?	###wjl
	JN	DZHS70			:NO, REJECT THE PRETENDER

:	Old host coming up in new slot, but OK because old host is down or
:	host is reporting for the first time.  Do not report as "imposter" host
	LIS	R0,0			:				###wjl
DZHS03	STH	R0,HOSTN,HN,HN		:clear HOSTN table entry for old host
	STB	R0,HSTAT,HN		:clear host status		###LH

:	CLEAR EXPANDED HOST STAUTS FIELDS
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	STB	R0,HSTATN,HN		:clear expanded host status entry###LH
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY AND clear it.	 ###LH
	SRLS	HN,1			:RESTORE HN			###OAS

	J	DZHS50			:Install the new guy.  When that is
					:done, return here (to DZHS04)

:	Host status msg in proper slot (key matches),
:	or after an entry has been made for new host.  Process it.

DZHS04	SBT	HN,HSTFLG		:SET FLAG INDICATING GOT HOST STATUS
					:REPORT FROM ISIS.		###LH
	LHL	R1,DORNG+2,PRD,		:GET # OF PORTS
	NHI	R1,0FFF

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	JEFS	DZHS07			:OUT OF PORTS			###OAS
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R0,0FF-EHHOPT		:reset host out of ports bit	###JHL
	STB	R0,HSTATN,HN		:TO INDICATE PORTS AVAILABLE	###OAS
	JFS	DZHS08
DZHS07	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHHOPT		:set host out of ports bit	###jhl
	STB	R0,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

DZHS08	AIS	PRD,4
	NR	PRD,TC
	STH	R1,HMAXP,HN,HN		:SAVE MAXIMUM PORTS
	STH	R1,HSTPTA,HN,HN		:SAVE PORTS AVAILABLE
	LB	R0,DORNG+2,PRD,		:NEW STATUS, IS IT ANSWERING?
	NHI	R0,3			:CLEAR 'H KEY' BIT

	JN	DZHS06			:branch if not answering now
					:(gone,down, or shut)
	LB	R1,HSTAT,HN		:Host answering, then check what it was
	THI	R1,1
	JE	DZHS06			:don't report shut if it was already
					: shut or answered.

:	Report Host shut first if it was gone or down.
:	Host answering, and he hasn't been through the SHUT stage yet.
:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOSTS STATUS)
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R1,0FF-EHSTTS		:AND STRIP OFF OLD STATUS BITS	###OAS
	OHI	R1,EHSHUT		:set status "shut"
	STB	R1,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY, STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LIS	R0,HS.SHT		:REPORT HIM SHUT FIRST		###wjl
	STB	R0,HSTAT,HN
	JAL	R10,SUP1A,,		:SEND NODE-TO-SUP MSG 1AN###GT ###LH
	LIS	R0,0			:pretend status "answered" to gen
					:another host status message "answered"

:	SET UP FOR REPORT:  SEND NODE-TO-SUP MESSAGE, TYPE 11, HOST STATUS.
:	THE FIRST HALFWORD OF THE HOST STATUS REPORT IS OF THE FORMAT
:	[11,X0+STATUS]. THE LO-ORDER BYTE OF THIS HALFWORD IS ASSEMBLED
:	IN R14 FOR THE CALL TO SUPHS, WHICH ACTUALLY MAKES THE REPORT.
:	Each of the following states come here:
:	(1) Host is not answering now (gone,down, or shut).
:	(2) Host is answering and it was answered, too.
:	(3) Host is answering and has been through the SHUT stage already.

DZHS06	LHI	R14,1100+HS.HID		:INITIAL VALUE
					: - STATUS PRESENT, HOST ID (HID)
					:NOT PRESENT, HOST IQ (HIQ) DUMB...
       IF	LOGII			:LOG II may set log2 capable bit
	LR	R1,PRD			:get ahead and do CC bits before
	AIS	R1,4			:sending the 1A msg.
	NR	R1,TC			:get r1 to point to byte with CC bits
	LB	R3,DORNG,R1,		:get byte with CC bits
	NHI	R3,1C			:remove all other bits
	LB	R1,HSTAT3,HN
	NHI	R1,@1C			:remove CC bits from saved
	OR	R3,R1			:combine new CC bits with old other
	STB	R3,HSTAT3,HN		:save it away
	LB	R1,DORNG+2,PRD, 	:get status bits
	NHI	R1,80			:LOG2 capable bit
	SRLS	R1,1			:Bits are now 0L000000
	LB	R3,HSTAT3,HN		:get old status
	NHI	R3,@40			:knock off LOG II bit
	OR	R1,R3			:get new status
	LB	R3,HSTAT3,HN		:get old status (check for change)
	STB	R1,HSTAT3,HN		:save new status
	CR	R1,R3			:status changed?
	JEFS	DZHS13			:no log II status change
:	this store forces a different status to be found and thus msg to sup
	STB	R0,HSTAT,HN	 	:save host status
	J	DZHS15			:report new LOG II status
       EI	:LOGII
DZHS13	CLB	R0,HSTAT,HN		:HAS THE HOST STATUS CHANGED?
	JN	DZHS10			:YES - NEED TO REPORT HOST STATUS
	LH	R1,DSOHYP		:IS HYPE FIELD PRESENT? (type 10 msg)
	JE	DZHS40			:NO HYPE, NO STATUS CHANGE - NO REPORT!


	J	DZHS11			:NO STATUS CHANGE,
					: BUT NEED PRESENT HYPE		###LH

:	HERE FOR HOST STATUS CHANGE

DZHS10	LB	R1,HSTAT,HN		:SEND A '1A' REPORT TO SUP FIRST###GT
					:IF PREVIOUS STATUS WAS 'GONE'	###GT
	STB	R0,HSTAT,HN		:SAVE NEW HOST STATUS
	SIS	R1,3			:CHECK FOR 'GONE'		###GT
	JNFS	DZHS12			:PREVIOUS STATUS WAS NOT 'GONE' - JUST
					:CONTINUE			###LH
DZHS15	JAL	R10,SUP1A,,		:SEND MESSAGE '1A' TO SUP	###GT
DZHS11	OHI	R14,HS.STS		:SUP WILL IGNORE HOST STATUS	###LH

DZHS12	LB	R0,HSTAT,HN		:RESTORE HOST STATUS		###LH
	OR	R14,R0			:COMBINE HOST STATUS WITH WORKING
					: HEADER			###LH

:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOST STATUS)
	SLLS	R0,6			:MOVE HSTAT (BITS 6,7)
					: TO HSTATN (BITS 0,1)
	LB	R1,HSTATN,HN		:GET HSTATN			###OAS
	NHI	R1,0FF-EHSTTS		:strip off old status bits
	OR	R1,R0			:COMBINE			###OAS
	STB	R1,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY AND STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LH	R4,DSOHYP		:HYPE FIELD PRESENT?
					:NO, IT IS ISIS MESSAGE TYPE 04
	JE	DZHS30			:REPORT HOST STATUS ONLY

:	PROCESS HIQ AND HID FOR ISIS MESSAGE TYPE 10
	LR	R4,PRD			:TEMP RING POINTER, PRESERVES PRD...
	AIS	R4,4
	NR	R4,TC			:ADVANCE RING POINTER
	LH	R4,DORNG,R4,		:GET HYPE FIELD
:	THE COMBINATION OF HIQ AND HID IS CALLED HYPE. THE HI-ORDER BIT OF
:	HYPE IS HIQ, THE LO-ORDER BYTE IS HID.
	JE	DZHS30			:NO HIQ OR HID - GO REPORT STATUS
	JG	DZHS20			:NO HIQ - DUMB HOST
	OHI	R14,HS.HIQ		:INDICATE SMART HOST

:	SET IIX BIT IN HSTATN (USED FOR EXPANDED HOST STATUS)
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHIIX		:set IIX bit in HSTATN
	STB	R0,HSTATN,HN		:TO INDICATE HOST IIX		###OAS

:	PROCESS ORG/DEST BITS (USED FOR EXPANDED HOST STATUS)
DZHS20	LR	R0,R4
	NHI	R0,6000			:ISOLATE ORG/DEST ONLY BITS (1/2)###OAS
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS
	NHI	R1,0FF-EHORGN-EHDSTN	:strip off org/dest bits
	SRLS	R0,0B			:GET 1,2 OF HO BYTE INTO 4,5 OF LO BYTE
	OR	R1,R0			:AND COMBINE WITH		###OAS
	STB	R1,HSTATN,HN		:PREVIOUS EXPANDED HOST STATUS	###OAS
	NHI	R0,EHORGN+EHDSTN	:only the ORIG/DEST bits	###sdw
	OR	R14,R0			:add them to the header 	###sdw
	CLHI	R0,EHORGN+EHDSTN	:dest only and org only?
	JNFS	DZHS21			:if both, pretend not org only

:	ORIGIN ONLY HOST, SEND OUT OF PORTS MESSAGE TO SUPERVISOR
	LHL	R1,HOSTN,HN,HN		:GET HOST NUMBER FOR SUP REPORT	###OAS
	STH	R1,SUPMBF
	LHI	R5,8F			:SEND HOST OUT OF PORTS		###OAS
	JAL	R10,SUP14,,		:TO SUPERVISOR			###OAS

:	PROCESS PROXY HOST AND COLLECT-CALLS BITS (3,4,5)		###wjl
DZHS21	LR	R0,R4			:get Hype field back		###wjl
	NHI	R0,1C00			:isolate Proxy & CC bits (3,4,5)###wjl
	SRLS	R0,8			:3,4,5 of HO byte to 3,4,5, of LO byte
	LB	R10,HSTAT3,HN		:only change bits 3,4,5 	###sdw
	NHI	R10,@1C 		:LOG II (bit 1) was done above	###sdw
	OR	R0,R10
	STB	R0,HSTAT3,HN		:store for SUP 1A and SUP 19 msg###wjl

	NHI	R4,0FF			:ISOLATE HID
	JEFS	DZHS30			:DON'T HAVE HID IF ZERO

:	PROCESS HOST ID (USED FOR EXPANDED HOSTS STATUS)
	STB	R4,HSTYPE,HN		:STORE HOST TYPE		###OAS

	XHI	R14,HS.HID+HS.SET 	:INDICATE HOST ID PRESENT, SET
					:HS.SET BIT TO PREVENT ESCAPING

:	SEND HOST STATUS REPORT (SUP 11) TO SUP

DZHS30	JAL	R10,SUPHS,,		:MAKE REPORT TO SUP. HEADER BYTE IN R14
					: HID IN R4
	LHL	R0,HOSTN,HN,HN
	STH	R0,CRYSBF+2
	LB	R0,HSTAT,HN
	JAL	R8,CRYPTO,,
	HC	CRYE15			:CHANGE IN HOST STATUS

:	REPORT MULTI-BASE HOST KEY IF PRESENT AND HOST ANSWERED OR SHUT
DZHS40	LB	R0,HSTAT,HN		:HOST ANSWERED ?
	JEFS	DZHS42			:YES
	CLHI	R0,2			:MULTI-BASE HOST KEY VALID IF HOST SHUT
	JN	DZHS44			:NOT ANSWERED OR SHUT

:	HERE IF HOST IS ANSWERED OR SHUT

DZHS42	LIS	R0,5			:TEST 5TH BIT IN STATUS FOR 'SEND KEY'
	TBT	R0,DORNG+2,PRD,		: (BIT SET FOR SENDING IT)
	JE	DZHS46			: (RESET FOR NOT SENDING)
	LB	R0,DORNG+3,PRD,		:HOST KEY = 0 ?
	STH	R0,SUPMBF+2		:SAVE KEY

:	PROCESS MULTI-BASED HOST KEY (USED FOR EXPANDED HOST STATUS)
	STB	R0,HSTMBK,HN		:STORE MULTI BASED HOST KEY	###OAS

	LHI	R5,8C			:TELL SUP IT'S HOST # & KEY
	LIS	R1,0			:SENT BY NODE CODE
	LIS	R6,2			:2 HALFWORDS OF DATA IN SUPMBF
	LHL	R0,HOSTN,HN,HN		:GET HOST NUMBER
	STH	R0,SUPMBF		:SEND TO SUP
	JAL	R10,SUP14,,		:SEND MESSAGE
	J	DZHS46

:	HERE IF HOST NOT ANSWERED OR SHUT, STATUS IN R0

DZHS44	SIS	R0,3			:IS HOST GONE?
	JN	DZHS46			:NO

:	HERE IF HOST IS GONE, CLEAR ENTRY FOR THIS HOST

	STH	R0,HOSTN,HN,HN		:YES, CLEAR ENTRY
	STB	R0,HSTAT,HN		:CLEAR STATUS			###LH

:	CLEAR FIELDS USED FOR EXPANDED HOST STATUS
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	STB	R0,HSTATN,HN		:CLEAR EXTENDED HOST STATUS	###LH
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY AND CLEAR IT	###LH
	SRLS	HN,1			:RESTORE HN			###OAS

:	COMES HERE IF HOST IS DOWN, OR EVERTHING IS DONE.

DZHS46	AIS	PRD,4
	LH	R0,DSOHYP		:HOW LONG WAS MESSAGE FROM SLOT?
	JE	DSOIRP			:NOT LONG - 04 MESSAGE
	AIS	PRD,2			:LONG, TYPE 10 MESSAGE HAS EXTRA HW
	J	DSOIRP			:DONE, RETURN TO MAIN LOOP

:	HERE IF HOST STATUS REPORT FOR AN UNKNOWN HOST. MAKE AN ENTRY
:	FOR HOST AND MARK STATUS AS GONE.

DZHS50	JAL	R9,FNDHSL,,		:LOCATE A FREE ENTRY
	J	DZHS52			:THERE ISN'T ONE, REJECT THIS HOST
	LHL	R1,DORNG,PRD,		:RESTORE HOST #

	IF	RESHST
	JAL	R9,VRHOST		:VERIFY THIS HOST
	J	DZHS54			:NOT A VALID HOST FOR THIS NODE OR SLOT
	EI	:RESHST

	STH	R1,HOSTN,HN,HN		:ENTER HOST #
	STB	R2,HSTKEY,HN		:SAVE SLOT# * 4, NON-MXP CONFIGURATIONS
					:SLOT #, MACHINE #, MXP CONFIGURATIONS

:	CLEAR FIELDS USED FOR EXPANDED HOST STATUS
	LIS	R0,0
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	LHI	R0,EHGONE		:set status bits to "gone"
	STB	R0,HSTATN,HN		:TO INDICATE GONE STATUS	###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY AND STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LIS	R0,HS.GNE		:CALL HIM GONE			###wjl
	STB	R0,HSTAT,HN		:AFTER MADE AN ENTRY FOR THE NEW HOST
	J	DZHS04			:AND PROCEED IT

:	REJECT HOST DUE TO MAX NUMBER ALREADY UP ON THIS NODE.

DZHS52	LIS	R9,0			:ERROR TYPE 0
	IF	RESHST
	J	DZHS60

:	REJECT HOST DUE TO NOT LEGAL RESTRICTED HOST

DZHS54	SBT	HN,RESHMS		:NODE REPORT BEEN SENT YET?
	JN	DZHS56			:YES - NO NEED TO SEND ANOTHER...
	LR	R6,R1
	LR	R7,R2			:SAVE SOME REGS
	OHI	R1,8000
	STH	R1,SUPMBF+4		:HOST NUMBER + 8000
	IF	1-MXPNM			:NON-MXP			###GT
	SRLS	R2,2
	EI	:1-MXPNM						###GT
	OHI	R2,8000
	STH	R2,SUPMBF+2		:SLOT NUMBER + 8000
	LHI	R1,NR.INH
	STH	R1,SUPMBF		:INDICATE INVALID RESTRICTED HOST
	JAL	R10,SUP12,,		:MAKE REPORT TO SUP LOG
	LR	R1,R6
	LR	R2,R7			:RESTORE REGS
DZHS56	LIS	R9,3			:ERROR TYPE '3'
	EI	:RESHST

DZHS60	EXBR	R9,R9			:REJECT HOST, R9 = ERROR * 100x
	LIS	R0,8			:MESSAGE SIZE
	JAL	R8,DIROOM		:GET ROOM FOR ISIS MSG
	LR	R0,R9			:SAVE ERROR NUMBER
	LHL	R9,DRIF,,		:GET FILL POINTER
:	OHI	R2,0B00			:CREATE '0B' MESSAGE, KEY ALREADY IN R2
	OHI	R2,INHTRJ^8		:CREATE '0B' MESSAGE, KEY ALREADY IN R2
	ST	R2,DIRNG,R9,		:SAVE 1ST 4 BYTES OF MSG
	AIS	R9,4			: /
	NR	R9,TC			:/

	EXHR	R1,R1			:'HOST #', '0000'
	AR	R1,R0			:'HOST #', 'ERR', '00'
	ST	R1,DIRNG,R9,		:SAVE 2ND 4 BYTES
	AIS	R9,4			: /
	NR	R9,TC			:/
	STH	R9,DRIF,,		:SAVE BACK THE INDEX
	AIS	PRD,4			:UPDATE OUTPUT EMPTY POINTER
	NR	PRD,TC
	J	DZHS46			:DONE WITH THIS MESSAGE

:	IMPOSTER HOST...HOST COMING UP ON A SLOT, ALREADY EXISTS IN
:	ANOTHER SLOT. SEND NODE REPORT AND REJECT THIS HOST.
DZHS70	STH	R2,DORSLT		:SAVE KEY FROM ISIS		###GT
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R2,2			:ACTUAL SLOT NUMBER
	ELSE				:MXP -  HAVE TO SWAP NIBBLES	###GT
	SLLS	R2,4			:SHIFT LOWER 4 NIBBLES UP	###GT
	EXBR	R4,R2			:MOVE UPPER 4 BITS TO LO NIBBLE ###GT
	OR	R2,R4			:MAKE A NEW SLOT #		###GT
	NHI	R2,0FF			:MASK OFF UNWANTED BITS		###GT
	EI	:1-MXPNM						###GT
	STB	R2,SUPMBF+3		:SAVE NEW SLOT KEY (BAD GUY)
	LB	R9,HSTKEY,HN		:SAVE OLD SLOT KEY (GOOD GUY)
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R9,2
	ELSE				:MXP - HAVE TO SWAP NIBBLES	###GT
	SLLS	R9,4			:SHIFT LOWER 4 NIBBLES UP	###GT
	EXBR	R4,R9			:MOVE UPPER 4 BITS TO LO NIBBLE ###GT
	OR	R9,R4			:MAKE A NEW SLOT #		###GT
	NHI	R9,0FF			:MASK OFF UNWANTED BITS		###GT
	EI	:1-MXPNM						###GT
	STB	R9,SUPMBF+2		:HW2 CONTAINS OLD SLOT, OFFENDING SLOT
	LH	R9,HOSTN,HN,HN		:STORE HOST NUMBER + 8000 IN HW3
	OHI	R9,8000
	STH	R9,SUPMBF+4
	LIS	R9,NR.HIM		:INDICATE IMPOSTER HOST,
	STH	R9,SUPMBF		: DETECTED BY NODE
	JAL	R10,SUP12,,		:SEND NODE REPORT
	LHL	R2,DORSLT		:RESTORE R2 - THE ISIS KEY	###GT
	LIS	R9,2			:GET ERROR NUMBER FOR SLOT MSG
	LH	R1,HOSTN,HN,HN		:GET HOST NUMBER
	J	DZHS60			:GO REJECT HOST

	IF	RESHST

::*********************************************************************
::
::	SUBROUTINE:	VRHOST:
::	FUNCTION:	VERIFY RESTRICTED HOST
::	CALLING SEQ:	JAL	R9,VRHOST
::	INPUT:		R1 = HOST NUMBER
::			R2 = REQUESTING SLOT NUMBER*4 IN R2.
::	RETURNS:	TEST FOR HOST NUMBER ENTRY IN GHSTTB TABLE.
::			IF NOT FOUND, OR IF FOUND BUT NOT LEGAL FOR REQUESTING
::			SLOT, DO NON-SKIP RETURN.
::
::*********************************************************************

VRHOST	LHI	R3,(RESHST-1)*2		:HW TABLE, 1 ENTRY EACH RESTRICTED HOST
VRHS10	CLH	R1,GHSTTB,R3		:ENTRY FOUND?
	JEFS	VRHS20			:YES
	SIS	R3,2
	JGEBS	VRHS10
	JR	R9			:ENTRY NOT FOUND - NON-SKIP RETURN

VRHS20	HS	0
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R2,2			:CONVERT TO ACTUAL SLOT NUMBER
	EI	:1-MXPNM						###GT
	SLLS	R3,1			:MAKE FULLWORD INDEX
	LA	R4,GSHSTB,R3		:POINT TO GSHSnn ENTRY
	TBT	R2,0,R4			:IS HOST LEGAL FOR THIS SLOT?
	JEFS	VRHS30			:NO
	SRLS	R3,1
	LHL	R0,GCHSTB,R3		:GET CIRCUITS/MINUTE LIMIT
	STH	R0,HCTSM,HN,HN		: AND SAVE
	AIS	R9,4			:SKIP RETURN...
VRHS30	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SLLS	R2,2			:RESTORE R2
	EI	:1-MXPNM						###GT
	JR	R9			:RETURN
	EI	:RESHST

::*********************************************************************
::
::	SUBROUTINE:	DSZLGR:
::	FUNCTION:	03 - REPORT TO SUPERVISOR'S LOG
::	FORMATS:
::		--------.-------.-------.--------
::		|	0	|   03  |  key  |
::		|-------.-------.-------+-------|
::		|     DATA2	| R TYP | DATA1 |	R TYP:	Report Type
::		|-------.-------+-------+--------
::		|PROD ID|				PROD ID:  Product ID
::		---------
::
::			12 - ERROR LOG REPORT
::		[1280][ HW1][ HW2][ HW3]
::	This is the generic format for node reports.  HW1 can either be
::	[ss,xx] where ss = Slot number and xx = Product ID or [00,xx]
::	xx = node report type.  HW2 and HW3 are data.
::
::*********************************************************************

DSZLGR	LB	R1,DORNG+3,PRD,		:REPORT TO SUP'S LOG
	AIS	PRD,4
	NR	PRD,TC
	CLHI	R1,0FF			:KERNEL REPORT IF KEY = FF	###LH
	JE	DSZKER			:JUMP TO REPORT, DO NOT NEED TO CHECK
					:IF REPORT LIMIT EXCEEDED OR NOT###LH

	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R1,2			:GET ACTUAL SLOT NUMBER
	ELSE				:MXP				###GT
	SLLS	R1,4			:THE KEY = SLOT#, MACHINE #	###GT
	EXBR	R0,R1			:NEED TO SWAP NIBBLES		###GT
	OR	R1,R0			:AND OR INTO PLACE		###GT
	NHI	R1,0FF			:EXTRACT UPPER NIBBLE		###GT
	EI	:1-MXPNM		: TO FORM MACHINE #, SLOT #	###GT

	STB	R1,SUPMBF		:ACTUAL SLOT #
	SLLS	R1,1			:SLOT HALFWORD INDEX
	LH	R0,SMLTBL-2,R1		:GET SLOT'S SLOT REPORT LIMIT
	JLFS	DSZLG2			:NO LIMIT
	AIS	R0,1
	LIS	R10,1
	AHM	R10,SMLCNT-2,R1		:INCREMENT COUNT OF SLOT RPTS FOR SLOT
	CLH	R0,SMLCNT-2,R1		:IS LIMIT EXCEEDED?

	JLE	DSZLG4			:YES - SEND SLOT REPORT LIMIT EXCEEDED
					: - 1E MESSAGE TO SUP

	J	DSZLG2			:NO - SEND SLOT REPORT TO SUP	###LH

:	KEY - FF (KERNEL)

DSZKER	STB	R1,SUPMBF		:KEY - FF (KERNEL)		###LH

:	SEND SLOT OR KERNEL REPORT TO SUP

DSZLG2	L	R0,DORNG,PRD,
	EXHR	R0,R0			:GET THE HALFWORDS IN ORDER
	AIS	PRD,4
	NR	PRD,TC
	ST	R0,SUPMBF+2
	LB	R0,DORNG,PRD,
	AIS	PRD,4
	NR	PRD,TC
	STB	R0,SUPMBF+1
	JAL	R10,SUP12,,
	J	DSOIRP

DSZLG4	JL	DSZLG6			:PAST THRESHOLD - JUST CLEAN UP

:	SEND LIMIT EXCEEDED REPORT TO SUP
	SIS	R0,1
	STH	R0,SUPMBF+4		:EQUAL THRESHOLD - MAKE NODE REPORT
	SRLS	R1,1			:GET ACTUAL SLOT NUMBER,
	OHI	R1,8000			:REDUCE NETWORK ESCAPES,
	STH	R1,SUPMBF+2		:AND STORE
	LHI	R0,NR.SML
	STH	R0,SUPMBF		:INDICATE SLOT REPORT LIMIT EXCEEDED
	JAL	R10,SUP12,,		:AND SEND NODE REPORT TO SUPERVISOR

DSZLG6	AIS	PRD,8			:NO REPORT SENT - ADVANCE
	NR	PRD,TC			:RING POINTER PAST MESSAGE
	J	DSOIRP

DSZHAV	AIS	PRD,4
	NR	PRD,TC			:HOST AVAILABILITY
	L	R7,DORNG,PRD,		:HOST #, PORTS
	AIS	PRD,8
	NR	PRD,TC
	LHL	R2,TVRBUF
	JE	DSOIRP			:NO SUP
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LHI	R1,140F
	THI	R7,0FFF
	JEFS	DSZL10
	AIS	R1,1
DSZL10	JAL	R9,WHWI			:HEADER
	EXHR	R1,R7
	JAL	R9,WHWI			:HOST #
	J	DSOIRP
::*********************************************************************
::
::	SUBROUTINE:	DSZHPA:
::	FUNCTION:	REPORT HOST PORT AVAILABILITY
::
::*********************************************************************

DSZHPA	LIS	R6,1			:HOST PORT AVAILABILITY
	AIS	PRD,4
	NR	PRD,TC
	LHL	R1,DORNG,PRD,		:HOST #
	JAL	R9,FNDHST,,		:FIND HOST (HN IS INDEX)
	SKIPAD(DSZHP1)			:immed ret, NOT FOUND, SKIP IT	###wjl
	STH	R1,SUPMBF		:+4 return
	LHI	R5,8F			:HOST OUT OF PORTS (MSG SUBTYPE)
	LHL	R0,DORNG+2,PRD,		:GET # AVAILABLE
	STH	R0,HSTPTA,HN,HN		:SAVE IN PORT AVAILABLE

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	JEFS	DSZH10
	LHI	R5,90			:HOST HAS PORTS (MSG SUBTYPE)	###OAS
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R1,0FF-EHHOPT		:reset host out ports bit,we have ports
	STB	R1,HSTATN,HN		:TO INDICATE PORTS AVAILABLE	###OAS
	JFS	DSZH11

DSZH10	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R1,EHHOPT		:set host out of ports bit
	STB	R1,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

DSZH11	AIS	PRD,8
	NR	PRD,TC
	JAL	R10,SUP14,,
	J	DSOIRP

DSZHP1	AIS	PRD,8			:UPDATE RING POINTER
	NR	PRD,TC
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSZHCS:
::	FUNCTION:	0C - REPORT HOST COST
::
::*********************************************************************

DSZHCS	LHI	R5,88			:HOST COST
	LIS	R6,2			:SUP14 PARAMETER
	AIS	PRD,4
	NR	PRD,TC
	L	R0,DORNG,PRD,
	ST	R0,SUPMBF
	AIS	PRD,8
	NR	PRD,TC

:	UPDATE HSTCST (USED FOR EXPANDED HOST STATUS)
	LR	R1,R0
	EXHR	R1,R1			:ISOLATE			###OAS
	NHI	R1,7FFF			:HOST NUMBER IN R1		###OAS
	JAL	R9,FNDHST,,		:AND FIND HOST TABLE INDEX	###OAS
	SKIPAD(DSOIRP)			:NOT FOUND, IGNORE MESSAGE	###OAS
	LR	R1,R0			:+4 return
	NHI	R1,00FF			:ISOLATE HOST COST AND		###OAS
	STB	R1,HSTCST,HN		:STORE IN HOST COST TABLE	###OAS

	JAL	R10,SUP14,,
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSZACC:
::	FUNCTION:	PROCESS ISIS MESSAGE B7 - ADDENDUM TO ACCOUNTING
::			& INTRA-ISIS MESSAGE 05 - REPORT ACCOUNTING
::
::*********************************************************************

DSZACC	LHI	R5,89
	LIS	R6,2
	AIS	PRD,4
	NR	PRD,TC			:ACCOUNTING MESSAGE
	L	R0,DORNG,PRD,
	AIS	PRD,4
	NR	PRD,TC
	ST	R0,SUPMBF
	LIS	R1,4			:SET FLAG TO INDICATE DISPI SENDING
	JAL	R10,SUP14,,		: ACCT REC.
	J	DSOIRP			
	EI	:(1-T2GATE)		:End of Gateway non-use section


::*********************************************************************
::
::	SUBROUTINES:	DSZK04,DSZK08,DSZK0C
::	FUNCTION:	TO SKIP OVER UNDECODED MESSAGES
::
::*********************************************************************

DSZK04	LIS	R0,4			:TO SKIP OVER UNDECODED MESSAGES
	JFS	DSZKIL
DSZK08	LIS	R0,8
	JFS	DSZKIL
DSZK0C	LIS	R0,0C
DSZKIL	AH	R0,DROE,,
	NHI	R0,DRSZ-4
	STH	R0,DROE,,
	J	DSONXT

::*********************************************************************
::
::	SUBROUTINE:	DSIOER:
::	FUNCTION:	COME HERE FOR MESSAGES RECEIVED FROM THE
::			DISPATCHER WHICH ARE ONLY VALID GOING TOWARDS
::			THE DISPATCHER.
::
::*********************************************************************

DSIOER	CRASH.(.DSIO0)

::*********************************************************************
::
::	TABLE:		DSZETB:
::	FUNCTION:	DISPATCH TABLE FOR CHANNEL ZERO MESSAGES 
::			FROM ISIS.
::
::*********************************************************************

      IF	T2GATE		:Gateway dispatch table for port 0 messages

				:SUBTYPE
DSZETB	WC	DSZK04		:00 - DISCONNECT (IGNORED)
	WC	DSZK04		:01 - RESTART INTERFACE (IGNORED)
	WC	G02NUP		:02 - TAKEOVER MESSAGE ##AL
	WC	DSIOER		:03 - LOG REPORT
	WC	DSIOER		:04 - HOST STATUS
	WC	DSIOER		:05 - ACCOUNTING
	WC	DSZK08		:06 - TIME 
	WC	DSIOER		:07 - TERMINAL LOGIN
	WC	DSZK0C		:08 - AUX LOGIN
	WC	GLZ9		:09 - REJECT LOGON 
	WC	DSIOER		:0A - REPORT HOST PORT AVAILABILTY
	WC	DSZHUA		:0B - HOST UNACCEPTABLE
	WC	DSIOER		:0C - HOST COST
	WC	G0DNSP		:0D - NO SUP ##AL
	WC	DSIOER		:0E - 1-DOWN 	:Illegal at this time
	WC	DSIOER		:0F - REPORT ALL HOSTS 
	WC	DSIOER		:10 - HOST STATUS AND TYPE(ILLEGAL)
       IF	LOGII		:following only for logii gateway
	WC	DSIOER		:11 - ICRM (ILLEGAL)
	WC	GDECRI		:11 - ECRI - LOG II PSUEDO NEEDLE REJECT
       EI	:LOGII
DSZETL	EQ	(.-DSZETB)/4

      ELSE	:not T2GATE	:NodeCode dispatch table

DSZETB	WC	DSZK04		:00 - DISCONNECT (UNUSED)
	WC	DSZK04		:01 - RESTART INTERFACE (UNUSED)
	WC	DSZK04		:02 - TAKEOVER MESSAGE (N/A)
	WC	DSZLGR		:03 - LOG REPORT
	WC	DSZHST		:04 - HOST STATUS
	WC	DSZACC		:05 - ACCOUNTING
	WC	DSZK08		:06 - TIME (N/A)
	WC	DSZTLG		:07 - TERMINAL LOGIN
	WC	DSZALG		:08 - AUX LOGIN
	WC	DSZK08		:09 - REJECT LOGON (N/A)
	WC	DSZHPA		:0A - REPORT HOST PORT AVAILABILTY
	WC	DSZK08		:0B - HOST UNACCEPT (N/A)
	WC	DSZHCS		:0C - HOST COST
	WC	DSIOER		:0D - NO SUP (ILLEGAL)
	WC	DSIOER		:0E - 1-DOWN (PLITEXT) (ILLEGAL)
	WC	DSIOER		:0F - REPORT ALL HOSTS (ILLEGAL)
	WC	DSZHSH		:10 - HOST STATUS AND HYPE
       IF	LOGII
	WC	ICRM		:11 - LOG2 CIRCUIT REQUEST
       EI	:LOGII
DSZETL	EQ	(.-DSZETB)/4

      EI	:not T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DISKIP:
::	FUNCTION:	SKIP OVER DISPATCHER MESSAGE.
::			EXPECT PRD POINTING TO PORT #, UPDATES DROE.
::	CALLING SEQ:	JAL	R8,DISKIP RETURNS TO DSONXT WHEN DONE
::
::*********************************************************************

DISKIP	NHI	PRD,DRSZ-4		:MAKE SURE PRD IS OK
	LB	R1,DORNG+2,PRD,		:GET TYPE
::Point of departure for Gateway Needle
	IF	T2GATE
	JE	GNEDIN,,		:Needle front end process for Gateway
	CLHI	R1,0B2		:Only other legal from this caller is B2
	JE	GDB2,,			:Go to the Gateway B2 handler
       IF	LOGII			:log 2 gateways have ISNs and ASLPs
	CLHI	R1,DM.ASL		:ASLP
	JE	GDASLP,,
	CLHI	R1,DM.ISN
	JE	GDISN,, 	:ISN needle
       EI	:LOGII
	ELSE
	JE	DSKP2			:NEEDLE (GROSSLY ILLEGAL)
	EI	:T2GATE
	CLHI	R1,DTDAT
	JG	DSKP3			:SOME CONTROL MESS
	LHI	R0,6,R1
	NHI	R0,DRSZ-4
DSKP1	AR	PRD,R0							###AL
	NHI	PRD,DRSZ-4		:INDEX PRD			###AL
	STH	PRD,DROE,,		:UPDATE DROE
	j	dsonxt			:message flushed
DSKP2	LB	R0,DORNG+3,PRD,		:NEEDLE, GET ADDIT LENGTH
	AIS	R0,4			:OVERALL LENGTH
	JBS	DSKP1
DSKP3	CLHI	R1,DTCON		:TYPE TOO LARGE
	JLEFS	DSKP4
	CRASH.(.DSKP0)
DSKP4	LIS	R0,4
	SHI	R1,0B1
	JL	DSKP1
	LB	R0,DSKPLN,R1		:OVERALL LENGTH
	J	DSKP1

DSKPLN	BC	8,8,4,4,4,0C,8,4,4,4,4,4,4,4,4,4	:TYPES B1 - DTCON
	HS	0			:INSURE HW ALIGNMENT

	SUBTTL	DISPI (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	DIRMES:
::	FUNCTION:	SEND A 1-WORD MESSAGE
::	CALLING SEQ:	JAL	R8,DIRMES
::	INPUT:		R1 = 2 BYTES DATA
::			CHN = CHANNEL #
::	DESTROYED:	R3
::
::*********************************************************************

DIRMES	LHL	R3,DRIF,,		:INPUT PTR
	STH	CHN,DIRNG,R3,
	STH	R1,DIRNG+2,R3,
	AIS	R3,4
	NHI	R3,DRSZ-4
	STH	R3,DRIF,,
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	DIROOM:
::	FUNCTION:	DISMISSES UNTIL SPACE MADE IN THE INPUT RING.
::	CALLING SEQ:	JAL	R8,DIROOM
::	INPUT:		R0 = SPACE REQUESTED
::	DESTROYED:	R3
::
::*********************************************************************

DIROOM	LH	R3,DRIE,,		:COMPUTE EXISTING SPACE
	SH	R3,DRIF,,
	JGFS	DIRO10
	AI	R3,DRSZ			:ALLOW FOR RING WRAP
DIRO10	SIS	R3,4			:FILL MAY ONLY GET WITHIN 4 OF EMPTY
	CR	R0,R3			: POINTER
	JLER	R8			:ENOUGH SPACE--RETURN TO CALLER
	SVC	DISMIS,0		:NOT ENOUGH, DISMISS
	J	DIROOM

::*********************************************************************
::
::	SUBROUTINE:	DIMMES:
::	FUNCTION:	MGVES CANNED MESSAGES TO DISPATCHER INPUT
::			RING. (TOWARD APPLICATION SLOTS)
::			DATA STRING IN THE FORMAT (n/B1/B2/..  ../Bn)
::
::	CALLING SEQ:	JAL	R8,DIMMES
::	INPUT:
::			R1 = ADDRESS OF MESSAGE
::			CHN = CHANNEL NUMBER
::	REGISTER USAGE:	
::			R0 = CHARACTER BEING MOVED
::			R3 = LENGTH OF STRING
::			R14 = WORK REGISTER
::			R15 = DRIF ( DISPI INPUT RING FILL POINTER)
::
::*********************************************************************

DIMMES	STM	R14,DIMMSV		:SAVE WORKING REGISTERS
	LR	R14,R8			:SAVE RETURN REGISTER
	LB	R0,0,R1			:GET LENGTH
	AIS	R0,6			:ALLOW FOR MAXIMUM MESSAGE SIZE
	JAL	R8,DIROOM		:WAIT FOR ROOM
	LHL	R15,DRIF,,		:GET FILL POINTER
	STH	CHN,DIRNG,R15,		:SAVE PORT NUMBER INTO MESSAGE
	LB	R3,0,R1			:GET MESSAGE LENGTH
	STB	R3,DIRNG+2,R15,		:SAVE LENGTH
	AIS	R15,3			:ADD LENGTH FOR PORT AND LEN.
DIMME1	LB	R0,1,R1			:GET CHARACTER
	STB	R0,DIRNG,R15,		:PUT IT IN RING
	AIS	R1,1			:UPDATE MESSAGE POINTER
	AIS	R15,1			:MOVE FILL POINTER
	NHI	R15,DRSZ-1
	SIS	R3,1			:DONE?
	JNBS	DIMME1			:NO, CONTINUE
	AIS	R15,3
	NHI	R15,DRSZ-4
	STH	R15,DRIF,,		:DONE
	LR	R8,R14			:RESTORE LINK REG
	LM	R14,DIMMSV		:RESTORE WORKING REGS
	JR	R8			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	DIXCAP:
::	FUNCTION:	TO GIVE NEW CIRCUITS SOME XMIT CAPACITY.
::	CALLING SEQ:	JAL	R9,DIXCAP
::
::*********************************************************************

DIXCAP	LIS	R1,3			:GET CIRCUIT SPEED
	NH	R1,DIOTAB,CHN,CHN
DIXCAB	LHL	R1,CIRSPK,R1,R1
	CLHI	R1,09E			:0FF IS MAX ALLOWED BY MESS FORMAT
	JLFS	DIXC10
	LHI	R1,09D
DIXC10	AHI	R1,XMTCAP
	STH	CHN,DIRNG,PRD,
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	DISBPS:
::	FUNCTION:	RELIEVE BACKPRESSURE ON DIS PORTS THAT HAVE
::			SUFFICIENTLY LOW CHARACTER COUNTS.
::	CALLING SEQ:	JAL	R10,DISBPS  (from 1/8 second logic)
::
::*********************************************************************

:	rewritten 11/19/87 to not call DIROOM which will dismiss NC 
:	(SVC FAST,0) when no room in ring.  When no room just quit and
:	do it next 1/8 second						###sdw


DISBPS	LIS	R4,0			:UPDATE DISBPS BITS
	Lhi	R7,((ndp+1f)/20)*4-4

DISBP1	L	R0,DISBPX,R7		:PORTS (BITS) ARE RESET IF BACKPRESSURD
	O	R0,DISACP,R7,		:PORTS ACTIVE IF RESET
	LCS	R1,1
	XR	R1,R0			:BITS SET IF BP'D .AND. ACTIVE
	st	r1,scratc,r7,
	or	r4,r1			:accumlate BPed ports
	sis	r7,4			:next word
	jgebs	disbp1
	lr	r4,r4			:any ports BPed?
	jer	r10			:none so can quit early
	Lhi	R7,(ndp-1)!1f		:ports to service (20 ndp is 0-1f)
	sth	r7,sbptmp		:save it

disbp2	LHL	R2,sbptmp		:last port serviced
	OHI	R2,0F			:search from this HW
	LR	R1,R2
	SRLS	R1,3			:make into # bytes -1
	LA	R0,scratc-1,R1,		:bped ports
	lr	r1,r0			:make a copy
	ARAND	R0,R2			:ARRAYAND RETURNS HIGHEST NONZERO
					: BIT NUMBER IN R2
	JFS	disbp4			:ARRAYAND RESULT WAS NONZERO
	Jr	r10			:ARRAYAND RESULT WAS ZERO,
					: DONE WITH THIS LINK


DISBP4	RBT	R2,scratc,,		:port serviced
	sth	r2,sbptmp
	LHL	R3,DIOTAB,R2,R2
	LR	R6,R3			:SAVE CIRCUIT SPEED
	NHI	R3,-4			:R3=BUFF #
	JE	DISBP2			:IDLE CHANNELS REMAIN BP'ED
	NHI	R6,3			:SPEED BITS
	LHL	R8,bct,r3,		:SPEED
	tbt	r2,prirty+diszfl/8,,	:is this a priority circuit?
	jefs	DISBP5
	srls	r8,1			:give extra buffering to priority cirs
DISBP5	CLH	R8,disspk,r6,r6
	jge	DISBP2			:PORT MUST REMAIN BP'ED
	LH	R8,DRIF,,		:fill pointer
	LH	R3,DRIE,,		:fill+new size must be < empty or wrap
	SR	R3,R8			:occurs
	JGFS	DISBP6
	AI	R3,DRSZ 		:
DISBP6	SIS	R3,4+4			:4 for msg 4 to keep ring from wrapping
	JLER	R10			:if no room then wait till next 1/2 sec
	SBT	R2,DISBPX
	STH	R2,DIRNG,R8,		:store chn number
	LHI	R2,RDSPBP		:0A1 release BP
	STH	R2,DIRNG+2,R8,
	AIS	R8,4
	NHI	R8,DRSZ-4
	STH	R8,DRIF,,
	J	DISBP2

:	we have enough latency to be able to set and release a little earlier
:	than on links.  nice way to reduce buffering
DISSPK	HC	CIRSP0*2/3		:CIRCUIT SPEEDS
	HC	CIRSP1*2/3
	HC	CIRSP2*2/3
	IF	1-\SUPGCS	:ALLOW FOR MODIFICATION OF LEVEL 3 GOUGE SPEED
	HC	CIRSP3*2/3
	ELSE	:LEVEL 3 GOUGE OPTION SPECIFIED
	HC	SUPGCS*2/3
	EI	:1-\SUPGCS

::*********************************************************************
::
::	SUBROUTINE:	DSODBF						###SDW
::	FUNCTION:	SET BACKPRESSURE ON ALL PORTS.  CALLED ONLY
::			WHEN INPUT RING IS GETTING OVERRUN AND DISPATCHER
::			IS PROBABLY BUFFERING WHICH ADDS HEAVY OVERHEAD
::			WHICH MAKES IT IMPOSSIBLE FOR NC TO GET THE TIME
::			TO RECOVER FROM THE OVERRUN.  BACKPRESSURING ALL
::			PORTS GIVES NC A CHANCE TO EMPTY THE RING AND
::			THUS END THE DISPATCHER'S BUFFERING.  TESTING HAD
::			SHOWN NC RECEIVING 50KCPS AND THEN DISPATCHER BUFFERING
::			AND DROPPED TO 18KCPS AND HAD TO CHANGE TPUT HOST
::			TO SEND ONLY 15KCPS BEFORE THE BUFFERING WENT AWAY.
::			ALSO, FIELD HAS SEEN NODES D-BUFFERING FOR HOURS.
::	CALLING SEQ:	JAL	R10,DSODBF  (from DISOUT)
::
::*********************************************************************

DSODBF	STM	R0,DSOREG		:save our registers
	LIS	R4,0
	LIS	R7,0
DSODB1	L	R0,DISACP,R7,		:0 if active
	LCS	R1,1			:flip to 1 if active
	XR	R0,R1
	N	R0,DISBPX,R7		:set if not BPed
	ST	R0,SBPTMP		:continue with these ports
DSODB3	L	R0,SBPTMP		:reenter after doing a port
	JFFO	R0,DSODB5
	AIS	R7,4
	AHI	R4,20			:our port group
	CLHI	R4,NDP
	JL	DSODB1			:another group of ports to do
DSODB4	LM	R0,DSOREG		:exit
	JR	R10			:done

DSODB5	RBT	R1,SBPTMP		:port serviced
	LH	R8,DRIF,,		:fill pointer
	LH	R3,DRIE,,		:fill+new size must be < empty or wrap
	SR	R3,R8			:occurs
	JGFS	DSODB7
	AI	R3,DRSZ 		:
DSODB7	SIS	R3,4+4			:4 for msg 4 to keep ring from wrapping
	JLE	DSODB4			:if no room then wait till next 1/2 sec
	AR	R1,R4			:make into a real DPORT
	RBT	R1,DISBPX		:note port BPed
	STH	R1,DIRNG,R8,		:store chn number
	LHI	R2,SDSPBP		:0A0 release BP
	STH	R2,DIRNG+2,R8,
	AIS	R8,4
	NHI	R8,DRSZ-4
	STH	R8,DRIF,,
	J	DSODB3



	SUBTTL	DISPI (LOGCHR)

	SEG	a.code

:	BIT ARRAY TO INDICATE LOGON ESCAPE CHARACTERS (1B-1F,7B-7E)

DLMESC	HC	0000,001F,0000,0000,0000,0000,0000,001E

::*********************************************************************
::
::	SUBROUTINE:	LOGCHR:
::	FUNCTION:	PROCESS CHARACTERS COMING FROM PORTS IN LOGIN
::			MODE.
::			THIS ROUTINE IS USED BOTH BY DISPI AND THE
::			CONSAT (ASYNC) MODULE.
::	CALLING SEQ:	JAL	R11,LOGCHR
::	INPUT:		R1 = CHAR FROM PORT IN LOGIN MODE
::			R2 = OUTBOUND BUFFER #
::	RETURNS:	IMMEDIATE IF PORT NOT IN LOGIN MODE
::			+4 IF LOGIN BUFFER FULL
::			+8 IF EVERYTHING OK
::
::*********************************************************************

:	VERIFY PORT IN LOGIN MODE, AND TOSS CHARACTER IF NOT
LOGCHR	LHL	R0,BF,R2,
	CLHI	R0,LOGMAX		:RANGE CHECK BUFFER FLAG
	JG	LOGEX0			:immed ret, NOT IN LOGIN MODE	###wjl
	CLHI	R0,LOGMIN
	JL	LOGEX0			:immed ret, NOT IN LOGIN MODE	###wjl

	OHI	R1,80			:SET HOB OF CHARACTER
	TBT	R1,DLMESC-10		:IS CHARACTER AN ESCAPE ?
	JN	LOGBAD			:YES, HANDLE ESCAPE
	LR	R6,R1			:SAVE LOGON CHARECTER
	CHI	R6,8D			:= 'CR' ?
	JE	LOGCH0			:YES, SET NODE CODE TO OK
	CHI	R6,0BB			:= "SEMI-:" ?
	JE	LOGCH0			:yes, process it, else put ti and return

	JAL	R8,WCI			:R1=CHAR, R2=BUFFER #*4
	LIS	LRC,1
	JAL	R8,CBCCT		: *REMOVE WHEN SUP GOES TO 56 CHARS*
	CHI	R1,$A48			: > 48 CHARS ?
	JG	LOGCHA			:ZAP BUFFER, SEND MESSAGE TO USER
	j	8,r11			:done

:	SET BF TO 'NODE CODE = YES' IF CHARACTER IS CR OR SEMI-:
LOGCH0	HS	0
       if	1-t2gate		:not for gateways
	lb	r0,dlgsts,chn,		:what is logon status
	tbt	r0,dlgstk		:okay to not send to sup?
	je	logch5			:nope supe must make state change
	l	r3,bb,r2,		:set up for peeking
	LIS	R0,0F
	TBT	R0,BF,R2,		:IS TID IN THE BUFFER?
	JEFS	LOGch2			:NO
	JAL	R9,PHWI 		:YES, GET HOST NUMBER
	JAL	R8,PCI			:ALSO GET TID

logch2	lb	r1,0,r3 		:look at next char
	NHI	R1,7F			:STRIP OFF MSB
	CLHI	R1,01F			:CONTROL CHARACTER?
	Jg	logch5			:a real char so send to sup
	c	r3,be,r2,		:checked all chars?
	jefs	logch3			:yes, so can handle locally
	jal	r8,nci			:move r3 to next char
	j	logch2			:get next char
LOGch3
	xhi	r2,4			:flip buffer back towards dispi
	lhi	r1,tilim		:logon status (B4 msg)
	jal	r9,w2ci
	lhi	r1,04c			:'username' status
	jal	r8,wci
	xhi	r2,4			:convert back to logger direction
	j	8,r11			:and done
	ei	:1-t2gate
logch5	lr	r1,r6			:get back char
	jal	r8,wci			:and put it so sup will get it
	LHL	R8,BF,R2,		:GET BF
	OHI	R8,LOGNDC		:SET 'NODE CODE = OK' BIT
	STH	R8,BF,R2,
	J	8,R11			:CONTINUE WITH +8 RETURN

:	BUFFER OVERFLOW, ZAP BUFFER, TELL USER

LOGCHA	LIS	R1,0			:SET TO 0 FOR NO ESC CHAR

LOGBAD	LIS	R0,0			:COMMON ENTRY POINT FOR ESCAPE
					: & BUFFER FULL
	ST	R0,DSOLGH		:CLEAR TEMPORARY SAVE AREA
	STB	R1,DSOLGH+3		:STORE R1 (EITHER ESCAPE CHAR OR 0)
	LIS	R0,0F
	TBT	R0,BF,R2,		:IS TID IN THE BUFFER?
	JEFS	LOGBA1			:NO
	JAL	R9,GHWI			:YES, GET HOST NUMBER
	STH	R1,DSOLGH		:AND SAVE IT
	JAL	R8,GCI			:ALSO GET TID
	STB	R1,DSOLGH+2		:SAVE IT ALSO
LOGBA1	LB	R1,DSOLGH+3		:ESCAPE OR BUFFER FULL?
	JE	LGFULL			:BUFFER FULL, GO CLEAR IT

LOGES2	LHL	R0,BCT,R2,		:ESCAPE TYPED...ANYTHING IN BUFFER?
	JEFS	LOGES1			:NO, BUFFER EMPTY
	JAL	R9,GCIE			:YES, GET A CHARACTER, ESCAPE STRIPPED
	NHI	R1,7F			:STRIP OFF MSB
	CLHI	R1,01F			:CONTROL CHARACTER?
	JGBS	LOGES2			:NO, GET ANOTHER CHARACTER
	SBT	R1,DSOSPC		:CONTROL CHARACTER, NOTE IT
	JBS	LOGES2			:AND KEEP EMPTYING BUFFER
LOGES1	LHL	R1,DSOLGH		:GET HOST NUMBER
	JEFS	LOGES6			:NO HOST NUMBER IN BUFFER
	JAL	R9,WHWI			:DEPOSIT HOST NUMBER
	LB	R1,DSOLGH+2
	JAL	R8,WCI			:AND TID
LOGES6	LHL	R3,DSOSPC		:SEND SUP ALL CONTROL CHARACTERS
	JFFOH	R3,LOGES4		:find a control char		###sdw
	JFS	LOGES3			:no more control char		###sdw
LOGES4	RBT	R4,DSOSPC		:THIS ONE DONE
	LHI	R1,80,R4		:YES, APPEND 80-BIT...
	JAL	R8,WCI			:AND, WRITE IT IN
	JBS	LOGES6			:LOOP OVER ALL CINTROL CHARACTERS
LOGES3
	if	1-t2gate
	lb	r0,dlgsts,chn,		:get current logon status
	tbt	r0,dlgstk		:at PLI, username or error type uanme?
	je	loges7			:nope, have to send to supe
	xhi	r2,4			:flip buffer back towards dispi
	lhi	r1,tilim		:logon status (B4 msg)
	jal	r9,w2ci
	lhi	r1,0e9			:pli status
	jal	r8,wci
	xhi	r2,4			:convert back to logger direction
	j	8,r11			:and done
dlgstk	bc	61,0,0,0,0,0,0,0	:status 1,2,4 are okay to not send to sup
	ei	:1-t2gate

loges7	LB	R1,DSOLGH+3		:GET THE ESCAPE CHAR
	JAL	R8,WCI			:AND WRITE IT IN
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	J	8,R11			:DO A +8 RETURN

LGFULL	JAL	R8,CBCLR		:CLEAR BUFFER
	LHL	R1,DSOLGH		:IS HOST NUMBER IN BUFFER
	JEFS	LOGEX4			:NO, DO A +4 RETURN		###wjl
	JAL	R9,WHWI			:YES, REDEPOSIT IT
	LB	R1,DSOLGH+2		:AND ALSO THE TID
	JAL	R8,WCI
LOGEX4	SKIP(4,R11)			:+4 return			###wjl

LOGEX0	SKIP(0,R11)			:immediate return		###wjl

::	Log-in  Error messages for Gateway (terminal in Log-in mode)
LFER08	SC	/out of origination ports/

	ENDMO.(DISPI)
	EI	:1-KILLIT
	KILMSG(DISPI)

       ei	:1-ncslot		:no dispatcher if switcher

:	***NOTHING PAST THIS POINT***


	SUBTTL BUFF

:			****   *   * ***** *****
:			*   *  *   * *     *
:			****   *   * ***   ***
:			*   *  *   * *     *
:			****    ***  *     *

::#####################################################################
::
::	MODULE:		BUFF
::
::	FUNCTION:	CHARACTER BUFFER ROUTINES
::
::	REGISTER CONVENTIONS:
::		R0=SCRATCH
::		R1=CHARACTER TO OR FROM BUFFER. ALSO SCRATCH.
::		R2=BUFFER # (MULTIPLE OF 4)
::		R3=SCRATCH
::		R8=LINK
::	SUBTTLS:
::		WCI - Write character into a buffer
::		GCI - Get character from a buffer
::		CBCLR - Clear a buffer
::		CKZB - Refill bufferlet reserve tank
::		Utilities
::		GFCBUF/RFCBUF - Get/Return free character buffer pair)
::		Copy message into a buffer
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG	a.code

::*********************************************************************
::
::	SUBROUTINE:	WCI:
::	FUNCTION:	Write character into buffer
::	CALLING SEQ:	JAL	R8,WCI
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::
::*********************************************************************

WCI	CLHI	R2,4			:TEST FOR BUFFER NUMBER 0 OR 1
	JGFS	WCI0			:OK
	CRASH.(.WCIC0)			:Crash if buffer index 0 or 4.


WCI0	HS	0
:	Check buffer's BF, crash if negative. Else to WCI1.
	IF	DB.DEB
	LH	R0,BF,R2,		:EDIT BUFFER'S BF
	JGEFS	WCI1
	DBOOPS				:SPECIAL OOPS CALL
	EI	DB.DEB

WCI1	HS	0			:Here to do a WCI.
:	WCI instruction.  Takes us to WCIERR if bad buffer index, to WCNXT
:	to fetch another bufferlet, to WCFRST to get the first bufferlet.
:	Falls through when done, and we return to caller (R8).
WCI2	HS	0			:WCI INSTRUCTION
	HC	3912			:R1=CHAR, R2=BUFFER INDEX

	HC	BE-BB			:SIZE OF BB STORAGE
	HC	WCIERR-WCI2		:HERE ON INVALID BUFFER NUMBER
	HC	BE/4			:ADDRESS OF BE STORAGE/4
	HC	WCNXT-WCI2		:HERE TO CHAIN IN ANOTHER BUFFERLET
	HC	WCFRST-WCI2		:HERE TO GET FIRST BUFFERLET

	JR	R8			:DONE

:	Crash due to bad buffer index detected by WCI.
WCIERR	CRASH.(.WCIC1)

::*********************************************************************
::
::	WCFRST:	Chain the first bufferlet into a buffer.
::	Set BCT to 1, bump the count of bufferlets in use (by 14d),
::	set the buffers attention flag (NFLAGS).
::
::*********************************************************************

WCFRST	LIS	R3,1			:FIRST BFLET, SET CHRCNT=1
	STH	R3,BCT,2,
	lhi	R3,cbsz-cbptsz
	AM	R3,BFLTSV		:INCREMENT COUNT OF BUFFERLETS IN USE
	JGEFS	WCFRS9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCFRS9	HS	0
	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCFRS1			:NO				###OAS
	AM	R3,HBFTSV		:YES, INCREMENT COUNT		###OAS
	JGEFS	WCFRS1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCFRS1	EI	:REBILD

	LH	R3,BF,R2,		:SET ATTN FLAG
	SBT	R3,NFLAGS

:	Get a bufferlet from the free list (FREELT). If one is there,
:	continue at WCFRS0.  If not, call WRE to get the reserve tank,
:	then jump back here and try again.
WCFRS0	LHL	R3,FREELT		:GET BFLET FROM FREE LIST
	JNFS	WCFRS2
	JAL	R0,WRE
	JBS	WCFRS0

:	Got a free bufferlet to chain.  Point BB to it, put its link pointer
:	in FREELT, put the character into it, set up BE, and return to the WCI
:	caller.
WCFRS2	SLLS	R3,CBSZL		:COMPUTE ADDR OF FIRST SLOT
	AIs	R3,cbptsz
	ST	R3,BB,R2,		:IT'S ALSO THE NEW OUT PTR
	LHL	R0,CBSZ-2,R3		:UPDATE FREE LIST
	STH	R0,FREELT
	STB	R1,0,R3			:PUT AWAY BYTE
	ST	R3,BE,R2,		:RESTORE PTR
	JR	R8

::*********************************************************************
::
::	WCNXT:	Chain another bufferlet to a buffer.
::	Bump the count of bufferlets in use (BFLTSV), bump BCT by 14d.
::	If BCT<32K, continue at WCNXT0.  Else if BCT<0FFF0, continue at WCNXT0.
::	Else call BUFZAP to zap the buffer because we're in danger of
::	overflowing BCT.  If the buffer we zapped was a history buffer (there
::	is nothing--i.e., no black ball--in it) continue at WCFRST.
::	Else continue at WCNXT2.
::
::*********************************************************************

WCNXT	THI	R3,CBSZ-1		:is this 16d boundary end of bflet?
	JEFS	WCNX00
	STB	R1,0,R3			:put the char
	ST	R3,BE,R2,
	JR	R8

WCNX00	lhi	R0,cbsz-cbptsz		:CHAIN ANOTHER BFLET - INC CNT
	AM	R0,BFLTSV		:INCREMENT NUMBER OF BUFFERLETS IN USE
	JGEFS	WCNXT9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
       IF	1-REBILD		:need to slip in a nearby label
WCNXT4	J	WCNXT5
       EI

WCNXT9	HS	0
       IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCNX33			:NO				###OAS
	AM	R0,HBFTSV		:YES,INCREMENT COUNT		###OAS
	JGEFS	WCNX33			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCNXT4	J	WCNXT5
WCNX33	EI	:REBILD

	AHM	R0,BCT,R2,		:AND BCT FOR THIS BUFFER
	Jlbs	WCNXT4			:BCT < 32K

:	Here if BCT not too big.  Get the next bufferlet from the free list.
:	If one is there, continue at WCNXT1.  Else call WRE to get the reserve
:	pool and come back here to try again.
WCNXT0	LHL	R0,FREELT		:LINK TO NEXT BUFFERLET IN CHAIN
	JNFS	WCNXT1			:LINK ADDRESS<>0,BUFFERLET CHAIN INTACT
	JAL	R0,WRE			:FREE POOL EMPTY, GET LINK ADDRESS FROM
	JBS	WCNXT0			:RESERVE POOL AND SCHEDULE 'CKZB' TO
					:REFILL RESERVE POOL, ZAPPING A BUFFER
					:IF NECESSARY.

:	Here after successfully chaining in another bufferlet.
:	Set up link, update FREELT.
WCNXT1	STH	R0,0,R3			:R3 PTS TO LINK SLOT
	LR	R3,R0			:COMPUTE NEW IN PTR
	SLLS	R3,CBSZL
	AIs	R3,cbptsz
	LHL	R0,CBSZ-2,R3
	STH	R0,FREELT

:	Got a bufferlet, bookkeeping done. Now store away the character
:	and update BE.  Then return to WCI caller.
WCNXT2	STB	R1,0,R3			:STORE THE CHAR
	ST	R3,BE,R2,
	JR	R8

:	here if bct in danger of overflow
wcnxt5	LHL	R0,BCT,R2,
	CI	R0,0FFFE-cbsz		:ARE WE IN DANGER OF BCT OVERFLOW?
	JL	WCNXT0			:NO
	STM	R0,REGST		:STORE REGS			###LSH
	JAL	R14,BFZDB2,,		:STORE SOME DATA FOR DEBUGGING	###LSH
					:BEFORE WE ZAP THE BUFFER		###LSH
	LM	R0,REGST		:RESTORE REGS			###sdw
	JAL	R0,BUFZAP		:YES - ZAP BUFFER
	L	R3,BE,R2,		:SET UP BE
	JN	WCNXT2			:AND GO STORE CHARACTER
	J	WCFRST			:MUST BE HIST BUFF,NO BLACK BALL IN IT


::*********************************************************************
::
::	SUBROUTINE:	WRE:
::	FUNCTION:	Link the reserve tank into the free list.
::			Called when free list found empty.
::	CALLING SEQ:	JAL	R0,WRE
::	DESTROYED:	NO REGISTERS
::
::*********************************************************************

WRE	HS	0			:Get the reserve tank pointer.

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,WREDB1,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG

	ST	R0,WRERET		:IN ORDER TO SAVE ON REGISTERS
	LHL	R0,FREELT		:MAKE SURE WE SHOULD BE HERE
	JEFS	WRE0
	CRASH.(.WREFL)
WRE0	lhl	r0,freelf		:get from list
	jefs	wre1			:now have two lists, one for getting
	sth	r0,freelt		:one for putting and when get is
	lis	r0,0			:enpty then get putting chain
	sth	r0,freelf		:this to to make debugging crashes
	l	r0,wreret		:easier
	jr	r0
wre1	LH	R0,REBL
	JNFS	WRE2
	CRASH.(.WRECR)			:Crash if reserve tank empty
				:unreasonable drain on bufferlet storage

:	Link reserve tank into bufferlet free list.  Schedule CKZB (highest
:	priority) to refill the reserve tank, zapping buffers if necessary.
:	Then return.
WRE2	STH	R0,FREELT
	LIS	R0,0
	STH	R0,REBL
	LHI	R0,1F-PCKZB		:SCHEDULE REFILL OF RESERVE TANK
	SBT	R0,SQUEUE		:A HIGH PRIORITY PROCESS
	L	R0,WRERET

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,WREDB2,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG

	JR	R0

::*********************************************************************
::
::	SUBROUTINE:	WCD:
::	FUNCTION:	Prefix a character to a buffer
::	CALLING SEQ:	JAL	R8,WCD
::
::*********************************************************************

:	If buffer empty, go handle same as WCI (WCFRST).
WCD	L	R3,BB,R2,		:USE THE IN PTR
	JE	WCFRST			:EMPTY BUFF, SAME AS A WCI

:	If no room in first bufferlet, go get another one (WDNXT).
	SIS	R3,1			:BACK UP PTR
	THI	R3,CBSZ-cbptsz		:OFF THE BUFFER?
	JEFS	WDNXT			:YES, GET ANOTHER BUFFERLET

:	Otherwise, store the character and update BB, then return to caller.
	STB	R1,0,R3			:NO, JUST STORE BYTE
	ST	R3,BB,R2,		:AND UPDATE 'BB'
	JR	R8

:	Prefix a bufferlet in order to prefix a char.
:	Increment BCT and bufferlets-in-use count.
WDNXT	lhi	R0,CBSZ-cbptsz		:PREFIX A BUFFERLET, INC BCT FIELD
	AHM	R0,BCT,R2,
	AM	R0,BFLTSV		:UPDATE COUNT OF BUFFERLETS IN USE
	JGEFS	WCD09			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCD09	HS	0
	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCD01			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	WCD01			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCD01	EI	:REBILD

	SRLS	R3,CBSZL
	STH	R3,WCDSAV		:SAVE BUFFERLET #		###GT

:	Get free list pointer. If something there, continue at WDNXT1.
WDNXT0	LHL	R3,FREELT		:LINK TO NEXT BUFFERLET IN CHAIN
	JNFS	WDNXT1			:LINK ADDRESS<>0,BUFFERLET CHAIN INTACT

:	Else call WRE to get reserve pool, then back to WDNXT0.
	JAL	R0,WRE			:FREE POOL EMPTY, GET LINK ADDRESS FROM
	JBS	WDNXT0			:RESERVE POOL AND SCHEDULE 'CKBZ' TO
					:REFILL RESERVE POOL, ZAPPING A BUFFER
					:IF NECESSARY.

:	Got a free bufferlet. Store the character at the end of the bufferlet,
:	update FREELT, and chain old first bufferlet to this one. Update BB and
:	return to caller.
WDNXT1	SLLS	R3,CBSZL		:MAKE PTR TO LAST BYTE
	AhI	R3,CBSZ-cbptsz+1
	STB	R1,0,R3			:PUT AWAY BYTE
	LHL	R0,1,R3			:GET THE LINK
	STH	R0,FREELT		:NEW HEAD OF LIST
	LHL	R0,WCDSAV		:RESTORE THE BUFFERLET # FOR LINK###GT
	STH	R0,1,R3			:CHAIN TO OLD BUFFLET
	ST	R3,BB,R2,		:SAVE NEW PTR
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	WHWI:
::	FUNCTION:	Write a HW from R1 into a buffer (index in R2),
::			escaping bytes 00-03.
::	CALLING SEQ:	JAL	R9,WHWI
::	INPUT:		R1 = HW
::			R2 = BUFFER INDEX
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4
::
::*********************************************************************

WHWI	EXBR	R1,R1
	THI	R1,0FC			:ESCAPE CHARACTERS 0 - 3
	JNFS	WHW1
	SLLS	R1,8
	JAL	R8,WCI
	SRLS	R1,8
WHW1	JAL	R8,WCI
	EXBR	R1,R1
	THI	R1,0FC
	JNFS	WHW2
	SLLS	R1,8
	JAL	R8,WCI
	SRLS	R1,8
WHW2	JAL	R8,WCI
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	WHWI0:
::	FUNCTION:	Same as WHWI but requires buffer index (R2) of 0 or 4.
::			Used by CRQ and LOGGER.
::	CALLING SEQ:	JAL	R9,WHWI0
::	INPUT:		R1 = HW
::			R2 = BUFFER INDEX
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,WCI0
::
::*********************************************************************

WHWI0	clhi	r2,4
	jlefs	WHWI00			:valid buffer index
	crash.(.whwi0)			:invalid buffer index
WHWI00	EXBR	R1,R1			:DO LEFT BYTE FIRST
	JAL	R8,WCI0			:WRITE INTO BUF
	EXBR	R1,R1			:GET 2ND BYTE INTO LOW-ORDER POSITION
	JAL	R8,WCI0
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	WCIE:
::	FUNCTION:	Write a character (from R1), escaped if necessary, into
::		a buffer (index in R2).
::	CALLING SEQ:	JAL	R9,WCIE
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4. 
::
::*********************************************************************

WCIE	THI	R1,0F8			:is it in the 0-7 range?
	JNFS	WCIE1
	EXHR	R1,R1			:if yes, shift zero to low byte
	JAL	R8,WCI			:and write in an escape
	EXHR	R1,R1			:get the data back back to low byte
WCIE1	JAL	R8,WCI			:write data byte to buffer
	JR	R9			:and return

::*********************************************************************
::
::	SUBROUTINE:	WCDE:
::	FUNCTION:	Prefix a character (from R1), escaped if necessary,
::			into a buffer (index in R2).
::	CALLING SEQ:	JAL	R9,WCDE
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::	DESTROYED:	R8
::	CALLS:		JAL	R8,WCD
::
::*********************************************************************

WCDE	JAL	R8,WCD
	THI	R1,0F8
	JNR	R9
	EXHR	R1,R1
	JAL	R8,WCD
	EXHR	R1,R1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	W2CI:
::	FUNCTION:	Write 2 characters (from R1), without escaping, into a
::		buffer (index in R2).
::	CALLING SEQ:	JAL	R9,W2CI
::	INPUT:		R1 = 2 CHARACTERS
::			R2 = BUFFER INDEX
::	DESTROYED:	R8
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4.
::
::*********************************************************************

W2CI	EXBR	R1,R1			:HIGH-ORDER BYTE GOES FIRST
	JAL	R8,WCI
	EXBR	R1,R1
	JAL	R8,WCI			:WRITE SECOND BYTE
	JR	R9			:AND RETURN

	SUBTTL	BUFF (GCI - Get character from a buffer)

::*********************************************************************
::
::	SUBROUTINE:	GCI:
::	FUNCTION:	Get a byte of data from a buffer.
::	CALLING SEQ:	JAL	R8,GCI
::	INPUT:		R2 = BUFFER NUMBER X 4
::	OUTPUT:		R1 = CONTAINS THE CHARACTER
::	DESTROYED:	R0, R3
::	PRESERVED:	ALL OTHERS
::
::*********************************************************************

:	Normal entry point.  Make sure not using buffer	index 0 or 4.
:	(CRQ and LOGGER enter at GCI0).
GCI	CLHI	R2,4			:TEST FOR BUFFER NUMBER 0 OR 1
	JGFS	GCI0			:OK
	CRASH.(.GCICR)			:Illegal use of buffer 0 or 4 at GCI


:	Entry point for CRQ, LOGGER using buffer index 0, 4.
:	Fall thru here for valid regular GCI buffer index.
GCI0	HS	0
:	Edit buffer's BF. Crash if negative.  Else continue at GCI1.
	IF	DB.DEB
	LH	R1,BF,R2,		:EDIT BUFFER'S BF
	JGEFS	GCI2
	DBOOPS
	EI	:DB.DEB

:	GCI instruction takes us to GCIERR on empty buffer or invalid buffer
:	index, to GCRET to return empty bufferlet, to GCLAST when buffer is
:	empty.  Otherwise, fall thru, check for buffer tracing, and return.
GCI2	HC	3812			:GCI  R1,R2
	HC	BE-BB			:SIZE OF BB STORAGE
	HC	GCIERR-GCI2		:HERE ON EMPTY OR INVALID BUF #
	HC	BB/4			:ADDRESS OF BB STORAGE /4
	HC	GCRET-GCI2		:HERE TO RETURN EMPTY BUFFERLET
	HC	GCLAST-GCI2		:HERE TO CLEAR EMPTY BUFFER

	JR	R8			:DONE

:	Here from GCI instruction for bad buffer index or empty buffer.
GCIERR	CRASH.(.GCIC0)

::*********************************************************************
::
::	GCLAST:	Here when GCI empties a buffer.
::
::*********************************************************************

:	Clear BB, BE, BCT and reset attention flag.
:	Decrement count of bufferlets in use.
:	Link to and update FREELT.
GCLAST	LIS	R0,0			:LAST CHAR - CLEAR THE BUFFER
	ST	R0,BB,R2,		:SET BOTH PTRS TO 0
	ST	R0,BE,R2,
	STH	R0,BCT,R2,
	LH	R0,BF,R2,		:CLEAR ATTN FLAG
	RBT	R0,NFLAGS
	AHI	R3,CBSZ-1		:INDEX PTR TO LINK
	NHI	R3,-cbsz
	lhi	R0,cbptsz-cbsz		:negative number of data bytes in bflt
	AM	R0,BFLTSV		:DECREMENT NUMBER OF BUFFERLETS IN USE
	JGEFS	GCLAS9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCLAS9
	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	GCLAS1			:NO				###OAS
	AM	R0,HBFTSV		:YES, INCREMENT COUNT		###OAS
	JGEFS	GCLAS1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCLAS1	EI	:REBILD

	LHL	R0,FREELf
	STH	R0,0,R3
	SIS	R3,1			:put into correct area for shifts
	SRLS	R3,CBSZL
	STH	R3,FREELf
	JR	R8			:RETURN TO CALLER

::*********************************************************************
::
::	GCRET:	GCI emptied a bufferlet. Return it to the free list.
::
::*********************************************************************

:	Decrement BCT and bufferlet-in-use count.
:	Return bufferlet and link to FREELT.
GCRET	THI	R3,CBSZ-1		:TRUE END OF BFLET?
	JEFS	GCRE00			:yes, return it
	ST	R3,BB,R2,
	JR	R8			:and done
GCRE00	LHI	R0,cbptsz-cbsz		:RETURN A BFLET - DEC CNT
	AHM	R0,BCT,R2,
	AM	R0,BFLTSV		:DECREMENT COUNT OF BUFFERLETS IN USE
	JGEFS	GCRET9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCRET9
	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	GCRET1			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	GCRET1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCRET1	EI	:REBILD

	LHL	R0,0,R3			:GET LINK
	SLLS	R0,CBSZL			:COMPUTE PTR
	AIs	R0,cbptsz
	ST	R0,BB,R2,
	LHL	R0,FREELf		:PREFFIX BUFF TO LIST
	STH	R0,0,R3
	sis	R3,1			:COMPUTE BFLET #
	SRLS	R3,CBSZL
	STH	R3,FREELf
	JR	R8			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	GHWI:
::	FUNCTION:	Assemble a HW (no escapes) in R1 from a buffer.
::		Buffer must contain a HW of data or we'll crash in GCI.
::	CALLING SEQ:	JAL	R9,GHWI
::	DESTROYED:	R0, R3, R4
::
::*********************************************************************

GHWI	JAL	R8,GCI			:GET CHAR
	LR	R1,R1
	JNFS	GHWI10
	JAL	R8,GCI			:ESCAPED CHAR
GHWI10	LR	R4,R1
	EXBR	R4,R4
	JAL	R8,GCI			:SECOND CHAR
	LR	R1,R1
	JNFS	GHWI20			:###jhl
	JAL	R8,GCI
GHWI20	AR	R1,R4			:###jhl
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	GHWI0:
::	FUNCTION:	Same as GHWI but buffer index must be 0 or 4.
::	CALLING SEQ:	JAL	R9,GHWI0
::	INPUT:		R2 = VALID BUFFER INDEX
::	OUTPUT:		R1 = HALFWORD
::	DESTROYED:	R0, R3, R4, R8
::	CALLS:		JAL	R8,GCI0
::
::*********************************************************************

GHWI0	clhi	r2,4
	jlefs	GHWI00			:valid buffer index
	crash.(.ghwi0)			:invalid buffer index
GHWI00	JAL	R8,GCI0			:GET CHARACTER
	LR	R4,R1
	EXBR	R4,R4			:MOVE FIRST BYTE TO HI-ORDER POS. OF HW
	JAL	R8,GCI0
	AR	R1,R4			:COMBINE FIRST AND SECOND CHARACTERS
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	GCIE:
::	FUNCTION:	Get a character (returned in R1) from a buffer
::			(index in R2),	stripping escapes.
::	CALLING SEQ:	JAL	R9,GCIE
::	INPUT:		R2 = VALID BUFFER INDEX  Crashes if R2=0 or 4.
::	OUTPUT:		R1 = CHARACTER
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,GCI
::
::*********************************************************************

GCIE	JAL	R8,GCI			:GET CHAR (UNESCAPED)
	LR	R1,R1
	JNR	R9
	JAL	R8,GCI
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	G2CI:
::	FUNCTION:	Get 2 characters (into R1) from a buffer (index in R2),
::			without stripping escapes.
::	CALLING SEQ:	JAL	R9,G2CI
::	INPUT:		R2 = VALID BUFFER INDEX  Crashes (in GCI) if R2=0 or 4.
::	OUTPUT:		R1 = 2 CHARACTERS
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,GCI
::
::*********************************************************************

G2CI	JAL	R8,GCI
	LR	R4,R1
	EXBR	R4,R4			:FIRST CHARACTER IN HIGH-ORDER BYTE
	JAL	R8,GCI
	OR	R1,R4			:COMBINE BOTH CHARACTERS
	JR	R9			:AND RETURN

	SUBTTL	BUFF (PCI - Peek at first character in a buffer)

::*********************************************************************
::
::	SUBROUTINE:	PCIS:/PCI:/NCI:
::	FUNCTION:	ENTRY POINTS:
::		PCIS -	Peek at the first character in a buffer.
::		PCI  -	Peek at (the next) character in a buffer.
::			R3 must contain a legal pointer into the buffer,
::			else garbage is returned.  Before calling PCI,
::			set up R3 to point to desired position in buffer,
::			or use PCIS for first character, PCI for subsequent
::			characters in sequence.  R3 must stay in tact from
::			PCIS to last PCI.  
::		NCI  -	Same as PCI, but does not peek at character,
::			just increments pointer into buffer.
::
::*********************************************************************

:	Init R3 to point to first character in buffer (BB).
PCIS	L	R3,BB,R2,		:INIT PCI

:	Enter here if R3 already set up.
:	(Either by caller or by previous call to PCIS)
PCI	LB	R1,0,R3			:GET THE CHARACTER

:	Enter here to increment pointer into buffer (R3) by one position,
:	without peeking at characters.
NCI	lr	r3,r3			:crash if looking into an empty buf
	jnfs	nci02
	crash.(.NCI02)			:called to peek at an empty buffer
nci02	AIS	R3,1			:INC PTR
	THI	R3,CBSZ-1
	JNR	R8
	LHL	R3,0,R3			:MOVE TO NEXT BUFFERLET
	SLLS	R3,CBSZL
	AIs	R3,2
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	PCIE:
::	FUNCTION:	Peek at next (escaped) character in buffer.
::			Same as PCI, but strips escapes.
::	CALLING SEQ:	JAL	R9,PCIE
::	CALLS:		JAL	R8,PCI
::
::*********************************************************************

:	PCI a char.  If 00, PCI another and return. Else just return.
PCIE	JAL	R8,PCI			:PEEK AT NEXT CHARACTER
	LR	R1,R1			:ESCAPE?
	JNR	R9			:NO - RETURN 
	JAL	R8,PCI			:YES - GET ESCAPED CHARACTER AND
	JR	R9			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	PHWI:
::	FUNCTION:	Peek at next HW (returned in R1) in a buffer, stripping
::		escapes.  R3 must contain a valid pointer into the buffer
::		(see PCI).  There must be a HW of data in the buffer, or
::		garbage is returned.
::	CALLING SEQ:	JAL	R9,PHWI
::	INPUT:		R3 = VALID BUFFER POINTER
::	OUTPUT:		R1 = HW
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,PCI
::
::*********************************************************************

PHWI	JAL	R8,PCI			:GET A CHAR
	LR	R1,R1			:TEST FOR ESCAPE CHAR '00'
	JNFS	PHWI1			:SKIP ANOTHER READ IF NOT ESC-PAIR
	JAL	R8,PCI			:READ SECOND OF PAIR IF ESCAPED CHAR
PHWI1	LR	R4,R1			:SAVE CHAR IN REG 4
	EXBR	R4,R4			:PUT IN 2ND BYTE FROM RIGHT FOR LATER
	JAL	R8,PCI			:GET NEXT CHARACTER
	LR	R1,R1			:TEST FOR ESCAPE CHARACTER
	JNFS	PHWI2			:SKIP ANOTHER READ IF NOT ESCAPE-PAIR
	JAL	R8,PCI			:READ SECOND OF PAIR IF ESCAPED
PHWI2	AR	R1,R4			:COMBINE SECOND BYTE WITH FIRST IN R1
	JR	R9			:RETURN TO CALLING ROUTINE

::*********************************************************************
::
::	SUBROUTINE:	CHWI:
::	FUNCTION:	RETURNS A HALF-WORD IN R1 AND REPLACES IT WITH 'FFFF'.
::	CALLING SEQ:	JAL	R9,CHWI
::	DESTROYED:	R0
::	CALLS:		JAL	R8,NCI
::
::*********************************************************************

CHWI	LCS	R0,1
	LB	R4,0,R3			:GET A CHARACTER
	JNFS	CHWI1			:IT IS NOT BEING ESCAPED, SKIP
	JAL	R8,NCI			:ESCAPED, INC PTR, GET NEXT CHAR###CY
	LB	R4,0,R3
CHWI1	STB	R0,0,R3			:REPLACE IT W/ 'FF'
	EXBR	R4,R4
	JAL	R8,NCI			:INC PTR				###CY
	LB	R1,0,R3			:AND REPEAT
	JNFS	CHWI2
	JAL	R8,NCI			:###CY
	LB	R1,0,R3
CHWI2	STB	R0,0,R3
	JAL	R8,NCI			:###CY
	AR	R1,R4
	JR	R9

	SUBTTL	BUFF (CBCLR - Clear a buffer)

::*********************************************************************
::
::	SUBROUTINE:	CBCLR: / GLBCLR:
::	FUNTION:	Clear a buffer (index in R2), reset its attention flag.
::			Crashes if R2 not a valid buffer index, or if buffer's
::			BF is negative.
::	CALLING SEQ:	JAL	R8,CBCLR
::	INPUT:		R2 = VALID BUFFER INDEX
::	DESTROYED:	R0, R3
::
::*********************************************************************
::GLBCLR avoids possible complications by not resetting the BF, which is 
::actually marked as Log-in state - therefore not a real BF, therfore avoiding
::a wild reset of some bit somewhere between 10 and 17.

	IF	T2GATE
:	Special section for Gateway 1/2 circuits
GLBCLR	THI	R2,3			:LEGAL BUFF?
	JE	GBCLR1
	CRASH.(.CBCLC)
GBCLR1	LH	R3,BF,R2,		:GET ABSOLUTE CHANNEL NUMBER 
	JGE	GBCLR2
	CRASH.(.CBCL0)
GBCLR2	L	R3,BE,R2,		:GET BUFFER FILL POINTER
	JER	R8			:ZERO, BUFFER EMPTY. RETURN
	J	GLBC01		:continue with clearing process
	EI	:T2GATE


CBCLR	HS	0
	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CBCDB1,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG

	THI	R2,3			:LEGAL BUFF?
	JE	CBCLR1
	CRASH.(.CBCLC)
CBCLR1	LH	R3,BF,R2,		:GET ABSOLUTE CHANNEL NUMBER 
	JGE	CBCLR2
	CRASH.(.CBCL0)
CBCLR2	RBT	R3,NFLAGS		:CLEAR ATTN FLAG
	L	R3,BE,R2,		:GET BUFFER FILL POINTER
	JER	R8			:ZERO, BUFFER EMPTY. RETURN

:	If the buffer is empty, just RETURN.  Otherwise, chain the first
:	bufferlet to the free list, clear BB, BE, and BCT, decrement
:	bufferlets-in-use count, then RETURN.
GLBC01	AHI	R3,CBSZ-1		:MAKE PTR TO BFRLT LINK
	NHI	R3,@(CBSZ-1)
	LHL	R0,FREELf		:INSERT HEAD OF LIST
	STH	R0,0,R3
	L	R3,BB,R2,		:COMPUTE # OF FIRST BUFFERLET
	SIs	R3,2
	SRLS	R3,CBSZL
	STH	R3,FREELf

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CBCDB2,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG

	LIS	R0,0			:CLEAR BOTH PTRS
	ST	R0,BE,R2,
	ST	R0,BB,R2,
	LHL	R3,BCT,R2,		:BCT=14*N-13,N=NUMBER OF B'LETS CHAINED
	ahi	R3,CBSZ-1-cbptsz	:R3 NOW = 14*(NUMBER OF B'LETS CHAINED)
	STH	R0,BCT,R2,		:ZERO OUT THE BCT COUNT
	SR	R0,R3			:FORM 2'S COMPLEMENT OF R0 R3???

	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	CBCLR3			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	CBCLR3			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
CBCLR3	EI	:REBILD

	AM	R0,BFLTSV		:DECREMENT THE NUMBER OF B'LETS IN USE
	JGER	R8			:				###TZ
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS


	SUBTTL	BUFF (CKZB - Refill bufferlet reserve tank)

::*******************************************************************
::
::	PROCESS:	CKZB:
::	FUNCTION:	Refill bufferlet reserve tank.
::		Highest priority process in the node code.  Gets scheduled
::		whenever the reserve tank is linked into the free list.  We
::		must recover 80x bufferlets to refill the reserve tank. If
::		they are not available, we will zap buffers until they are.
::
::*********************************************************************

:	Init R1 to 80 (number of free bufferlets required to refill reserve
:	tank).  Get the free list pointer in R3, continue at REB3.
CKZB	LHL	R3,FREELt		:Free list pointer to R3
	je	ckzb00
ckzb04	lr	r1,r3			:pointer to first bflet in chain
	jfs	ckzb05
ckzb01	cr	r1,r3			:somehow a bflets circuluraly linked?
	jnfs	ckzb05
	crash.(.ckzb0)			:deadly sin
ckzb05	LR	R2,R3
	SLLS	R2,CBSZL
	LHL	R3,CBSZ,R2
	Jnbs	ckzb01
	lhl	r1,freelf
	sth	r1,cbsz,r2		:combine chains
	lhl	r2,freelt
	sth	r2,freelf
	sth	r3,freelt
ckzb00	LHI	R1,$a 40		:one bufferlet for each possible logical record
CKZB0	LHL	R3,FREELf		:Free list pointer to R3
	JFS	REB3			:Skip on first pass

:	Get the current bufferlet's link pointer to R3.
REB2	LR	R2,R3
	SLLS	R2,CBSZL
	LHL	R3,CBSZ,R2

:	If R3 is 0 (last bufferlet), go to REBZ to zap another buffer.
:	Else decrement R1 by 1 and back to REB2 until R1 is 0
:	(80 bufferlets found).
REB3	JE	REBZ
	SIS	R1,1
	JGBS	REB2

:	Got enough bufferlets. Link them into the reserve tank (REBL),
:	update FREELT, and DISMISS to EXEC.
	STH	R1,CBSZ,R2		:storing 0 at end of chain
	LHL	R1,FREELf		:80 BUFFERLETS FOUND,
	STH	R1,REBL			:LINK THEM INTO RESERVE TANK
	STH	R3,FREELf
	
	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CKZDB1,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG

	J	EXDISM,,

:	ZAP A BUFFER, AND RETURN TO CKBZ TO TRY AGAIN TO REFILL RESERVE TANK.

:	Find the biggest buffer (based on BCT) and call BUFZAP to zap it and
:	report to sup.  Then back to CKZB to finish refilling reserve tank.
REBZ	LI	R1,BBSIZE-4		:ZAP BIGGEST BUFFER, MAKE MORE STORAGE
	LIS	R7,0
REBZ1	LHL	R0,BCT,R1,
	CLR	R7,R0
	JGEFS	REBZ2
	LR	R7,R0			:LARGEST COUNT SO FAR
	LR	R2,R1			:AND BUFFER INDEX
REBZ2	SIS	R1,4
	JGEBS	REBZ1
:	R2 CONTAINS INDEX FOR BUFFER WITH LARGEST COUNT. ZAP IT.
	STM	R0,REGST		:STORE REGS			###LSH
	JAL	R14,BFZDB2,,		:STORE SOME DATA FOR DEBUGGING	###LSH
					:BEFORE WE ZAP THE BUFFER 	###LSH
	LM	R0,REGST		:RESTORE REGS			###sdw
	JAL	R0,BUFZAP		:ZAP BUFFER, REPORT TO SUP

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,RBZDB1,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG

	J	CKZB00

::*********************************************************************
::
::	SUBROUTINE:	BUFZAP:
::	FUNCTION:	Zap the buffer specified by R2.
::	ZAP BUFFER SPECIFIED BY BUFFER INDEX IN R2. CLEAR BUFFER, AND PLACE
::	BLACK BALL INTO BUFFER TO NOTIFY DESTINATION THAT
::	DATA HAVE BEEN LOST. MAKE REPORT TO SUPERVISOR.
::	CALLING SEQ:	JAL	R0,BUFZAP
::	INPUT:		R2 = BUFFER INDEX
::	PRESERVED:	ALL OTHER REGISTERS
::	CALLS:		JAL	R8,CBCCT
::			JAL	R8,CBCLR
::			JAL	R9,W2CI
::			JAL	R10,SUP12
::
::*********************************************************************

:	Get and save (R4) the exact buffer byte count, then clear the buffer.
BUFZAP	STM	R0,BFZPRS		:PRESERVE CONTEXT
	JAL	R8,CBCCT
	LR	R4,R1			:SAVE EXACT BUFFER COUNT
	JAL	R8,CBCLR		:CLEAR BUFFER

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LR	R8,R4			:BUFFER COUNT
	JAL	R14,BFZDB1,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG

:	If we're zapping a history buffer, update HSEQN by the count of
:	characters clear (R4)--total pruning.
:	Go to BUFZP4 to bypass putting a black ball in.
	IF	REBILD
	CI	R2,HBUFN		:HISTORY BUFFER?
	JLFS	BUFZP2			:NO - GARDEN VARIETY
	AM	R4,HSEQN,R2,		:YES - TOTAL PRUNING! ADVANCE HIST SEQ#
	JFS	BUFZP4			:BYPASS BLACK BALL
	EI	:REBILD

:	Not a history buffer, so put a black ball in buffer to inform
:	destination of data loss.
BUFZP2	LHI	R1,01FD			:BLACK BALL
	JAL	R9,W2CI

:	Inform supe and CRYPTO of buffer zap, bump count of buffer zaps,
:	return to caller.
BUFZP4	LIS	R0,NR.BFZ		:BUFFER ZAP NODE REPORT
	STH	R0,SUPMBF
	STH	R2,SUPMBF+2		:BUFFER INDEX
	STH	R4,SUPMBF+4		:BUFFER COUNT
	XHI	R2,4			:FLIP BUFFER
	LHL	R0,BF,R2,		:GET GUILTY CHANNEL
	STH	R0,SUPMBF+6		:AND STORE FOR XRAY DISPLAY
	XHI	R2,4			:RECOVER BUFFER
	JAL	R10,SUP12,,		:NODE REPORT AND CRYPTOGRAM
	LIS	R0,1
	AHM	R0,BZAPCT		:COUNT BUFFER ZAPS
	LM	R0,BFZPRS
	JR	R0			:RETURN

	SUBTTL	BUFF (Utilities)


::*********************************************************************
::
::	SUBROUTINE:	RTBFTS:
::	FUNCTION:	ReTurn BufFerleTS  removes the number of chars
::		specified in R0 from buffer in R2.  Returns actual
::		number chars removed in R0.  Destroys R0 and R3.  Much
::		more efficient than either using a GCI per char or
::		repeatedly calling a similar routine that only returns
::		a bflet at a time (which removed between 1 and 14 chars
::		per bflet).				###sdw
::
::*********************************************************************

RTBFTS	ST	R4,R4RBFT	:save a reg
	STH	R0,R0RBFT	:save count to remove
	ST	R1,R1RBFT	:save R1
	cbcctm(r4,r2,r1)	: CBCCT R4,R2   (r1 is scratch)
	CR	R4,R0		:have enough (r4) to return asked amount? (r0)
	JG	RTBFT1		:jump if enough
	ST	R8,R0RBFT	:just empty it
	JAL	R8,CBCLR
	L	R8,R0RBFT	:save regs as use normal empty
	LR	R0,R4		:restore count removed
	L	R1,R1RBFT
	L	R4,R4RBFT
	JR	R8		:handle the complete empty case

RTBFT1	L	R3,BB,R2,	:get start
	LR	R1,R3		:get copy to calc how many in 1st buflet
	AHI	R1,CBSZ-1	:bump up to pointer plus a byte
	NHI	R1,-CBSZ	:knock of a bit and get pointer
	SR	R3,R1		:R3 gets negative count of chars in 1st buflet
	AR	R0,R3		:that many already read
	JL	RTBFT7		:all chars to remove were in first bufferlet
	LIS	R4,0		:count how many bflets removed for BCT
RTBFT2	LR	R3,R1		:repeat for next buflet
	LHL	R1,0,R3		:get next pointer to next buflet
	SLLS	R1,CBSZL	:make pointer into address
	AHI	R1,CBSZ
	SHI	R4,CBSZ-CBPTSZ	:another bflet returned
	SHI	R0,CBSZ-CBPTSZ	:reduce count of how many to remove
	JGEBS	RTBFT2		:new BB will be in next buflet
	AHM	R4,BCT,R2,	:r0 is BCT by buflet
	AM	R4,BFLTSV
	JGEFS	RTBFT4
	JAL	R7,NEGBCR,,	:crash if in use goes negative
RTBFT4	HS	0
      IF REBILD			:rebuild's in use
	CI	R2,HBUFN	:history buff?
	JLFS	RTBFT5		:nope
	AM	R4,HBFTSV	:fewer history in use
	JGEFS	RTBFT5
	JAL	R7,NEGHCR,,	:crash if neg
RTBFT5	HS	0
      EI  :REBILD
	LHL	R4,FREELF	:chain 1st free to end of chain we're returning
	STH	R4,0,R3
	L	R4,BB,R2,	:1st free will is buflet number of what was BB
	AHI	R4,CBSZ-1	:make the address into pointer
	NHI	R4,-CBSZ
	SIS	R4,2
	SRLS	R4,CBSZL	:now a pointer
	STH	R4,FREELF	:newest free
RTBFT7	AR	R1,R0		:R1 is end of bflet, R4 is chars from end
	ST	R1,BB,R2,	:save new bb
	LHL	R0,R0RBFT	:get how many removed
	L	R1,R1RBFT	:restore a couple of regs
	L	R4,R4RBFT
	JR	R8		:nicely done

::*********************************************************************
::
::	SUBROUTINE:	RTBFTA:
::	FUNCTION:
::	returns number of chars in R0 plus however many to ensure that
::	first char in buff could not be a second char of a char pair
::	Can't allow potential split char be intepreted as a first char
::	of a pair since this probably would make an invalid char pair.
::
::*********************************************************************

RTBFTA	JAL	R8,RTBFTS	:remove specified number of char
	LHL	R1,BCT,R2,
	JER	R9
	JAL	R8,PCIS
	SIS	R1,3
	JGR	R9		:no problem
	LIS	R4,1		:count how many extra read
	JFS	RTBFA2
RTBFA1	JAL	R8,PCIS
	SIS	R1,3
	JGFS	RTBFA3
	AIS	R4,1
RTBFA2	JAL	R8,GCI		:take out the offending char
	LHL	R1,BCT,R2,
	JGBS	RTBFA1		:make sure buffer not empty
RTBFA3	LHL	R0,R0RBFT	:get back R0 from RTBFTS
	AR	R0,R4		:and extra chars
	L	R4,R4RBFT
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CBCCT:
::	FUNCTION:	Compute the (exact) count (returned in R1) of bytes in
::			a buffer (index in R2).
::	CALLING SEQ:	JAL	R8,CBCCT
::	INPUT:		R2 = BUFFER NUMBER * 4
::	OUTPUT:		R1 = CHARACTER COUNT
::
::*********************************************************************


:	CBCCT:
:	RETURNS COUNT OF CHARACTER IN BUFFER. (IN R1)
:	***NOTE THAT THE MAXIMUM # CHARACTERS ALLOWED IN A BUFFER
:	IS 2^15-1 (I.E., HI ORDER BIT OF COUNT MUST BE 0). OTHERWISE AN
:	OVERFLOW WILL RESULT.****	:?? should be FFF0  ??		###wjl

CBCCT	LHL	R0,BB+2,R2,
	NHI	R0,CBSZ-1
	LHL	R1,BE+2,R2,
	NHI	R1,CBSZ-1
	SR	R1,R0
:					:was	AH	R1,BCT,R2,	###wjl
	LHL	R0,BCT,R2,		:for BCT > 7FFF			###wjl
	AR	R1,R0			:  will cause crash		###wjl
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	SNDFX0:
::	FUNCTION:	Write a SQFIX with a count of 0 into a buffer
::		(index in R2).
::		This special sextet is sent immediately behind a needle to
::		determine whether a new circuit is rebuildable.  If it is,
::		the destination node will respond with a SQACK with a count 
::		of 0 before sending any data.  If we don't get a SQACK0 
::		before any data, we know the circuit is not rebuildable..
::	CALLING SEQ:	JAL	R9,SNDFX0
::	INPUT:		R2 = BUFFER INDEX
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,WCI
::
::*********************************************************************

	IF	REBILD

SNDFX0	LR	R4,R3			:SAVE R3			###GT
	LIS	R1,3			:SEND BACK A SQFIX 0		###GT
	JAL	R8,WCI
	LIS	R1,SQFIX&0FF
	JAL	R8,WCI			:TO DETERMINE REBUILDABILITY	###GT
	LIS	R1,0			:SEQUENCE NUMBER = 0
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	LR	R3,R4			:RESTORE R3
	JR	R9			:RETURN

	EI	:REBILD

	SUBTTL	BUFF (GFCBUF/RFCBUF - Get/Return free character buffer pair)

::*********************************************************************
::
::	SUBROUTINE:	GFCBUF:
::	FUNCTION:	Grab-Free-Character-BUFfer
::	CALLING SEQ:	JAL	R8,GFCBUF
::	OUTPUT:		R2 = BUFFER #
::	DESTROYED:	R0
::
::*********************************************************************

:	Get buffer index from FREELB, crash if 0, or if <CIRZBF, or if >HBUFN-8
GFCBUF	HS	0

	IF	BFSDBG			:DEBUGGER			###LSH
	STM	R0,REGST
	JAL	R14,GFCDB1,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG		

	LHL	R2,FREELB		:GET THE BUFF #
	JE	OP8063			:NONE, COMPLAIN
	CLHI	R2,CIRZBF		:RANGE CHECK BUFFER NUMBER
	JL	OP8263			:TOO LOW
	CI	R2,HBUFN-8
	JG	OP8263			:TOO HIGH

:	Get linked buffer (via BB), crash if <CIRZBF, or if >HBUFN-8,
:	or if not multiple of 4.
	LHL	R0,BB,R2,		:UPDATE FREE LIST
	JE	GFCEXI			:immediate return - out of buffers!#wjl
	CLHI	R0,CIRZBF		:RANGE CHECK LINKED BUFFER NUMBER
	JL	OP8463			:(NEW HEAD OF FREE LIST)
	CI	R0,HBUFN-8
	JG	OP8463
	THI	R0,3			:BETTER BE A BUFF #
	JN	OP8663			:NOT

:	BUFFER EDITS COMPLETE - STORE NEW HEAD OF FREE LIST
:	Got good free buffer and linked buffer index.
:	Update the free list, clear the new buffers' BFs and BB
:	(also history buffer's BF if REBILD).
:	Skip +4 RETURN.
	STH	R0,FREELB
	LIS	R0,0			:CLEAR THE ATTN FLAG
	STH	R0,BF,R2,
	STH	R0,BF+4,R2,

	IF	REBILD
	SRHLS	R2,1
	STH	R0,BF+HBUFN,R2,
	SLHLS	R2,1
	EI	:REBILD

	STH	R0,BB,R2,

	IF	\TZ.TST
	DBCRY.(TZ.TST,R2,R8)
	EI	:TZ.TST

	J	4,R8			:SKIP RETURN

GFCEXI	SKIP(0,R8)			:immediate return		###wjl

OP8063	CRASH.(.GFCR0)			:out of buffers
OP8263	CRASH.(.GFCR1)			:free list pointer out of range
OP8463	CRASH.(.GFCR2)			:linked buffer pointer out of range
OP8663	CRASH.(.GFCR3)			:bad buffer index, not mult of 4

::**********************************************************************
::
::	SUBROUTINE:	RFCBUF:
::	FUNCTION:	RETURNS A BUFFER PAIR TO THE FREE LIST.
::			USES 'BB' AS LINK IN FREE BUFFER CHAIN.
::			SETS 'BF' TO 'DEAD' TO INDICATE BUFF NOT IN USE.
::	CALLING SEQ:	JAL	R8,RFCBUF
::	INPUT:		R2 = BUFFER #
::
::*********************************************************************

RFCBUF	STH	R2,RFCSAV		:SAVE BUFFER #
	NHI	R2,-8			:USE LOW ORDER HALF of pair (even bfr)

	IF	BFSDBG			:DEBUGGER			###LSH
	STM	R0,REGST
	JAL	R14,RFCDB1,,
	LM	R0,REGST		:restore regs
	EI	:BFSDBG		

	CLHI	R2,CIRZBF		:RANGE CHECK BUFFER # BEING RETURNED
	JL	OP8863			:ERROR - TOO LOW
	CI	R2,HBUFN-8
	JG	OP8863			:TOO HIGH
	LR	R1,R8			:SAVE LINK
	JAL	R8,CBCLR,,		:DON'T TAKE ANY BUFFERLETS WITH IT
	LHL	R0,FREELB
	STH	R0,BB,R2,
	STH	R2,FREELB

	IF	\TZ.TST
	DBCRY.(TZ.TST,R2,R1)
	EI	:

	IF	REBILD
	LIS	R0,0			:CLEAR OTHER VARIABLES
	ST	R0,SEQN,R2,
	ST	R0,SEQN+4,R2,
	EI	:REBILD

	XHI	R2,4			:CLEAR OTHER HALF

	JAL	R8,CBCLR,,

	LHI	R3,DEAD			:SET BF'S TO 'DEAD'
	STH	R3,BF-4,R2,
	STH	R3,BF,R2,

	SRHLS	R2,1			:CLEAR HISTORY BUFF VARIABLES
	LR	R0,R2
	SRHLS	R0,2			:REBUILD TIMEOUTS

	RBT	R0,CRQEND		:CIRCUIT NO LONGER AN ENDPOINT

	IF	REBILD
	RBT	R0,SQFIXV		:CLEAR REBUILD-QUADS-RECEIVED ARRAY 
	RBT	R0,REBTMO
	RBT	R0,REBTMI
	if	mortim
	rbt	r0,rebtm1
	rbt	r0,rebtm2
	ei	:mortim
	RBT	R0,CRQBSY		:CIRCUIT NO LONGER IN USE
	RBT	R0,SQFTMO		:NO REBUILD			###GT
	RBT	R0,SQFTMI
	NHI	R2,-4
	AI	R2,HBUFN
	JAL	R8,CBCLR,,
	LIS	R0,0
	ST	R0,HSEQN,R2,
	ST	R0,RINVC,R2,
	STH	R0,RNFLAG,R2,
	STH	R0,RHOSTN,R2,
	STH	R0,RBASE,R2,
	STH	R0,RHBSZ,R2,
	EI	:REBILD

	LHL	R2,RFCSAV
	LR	R8,R1
	JR	R8

OP8863	CRASH.(.RFCR0)

	SUBTTL	BUFF (Copy message into a buffer)

::*********************************************************************
::
::	SUBROUTINE:	BUFCAN:
::	FUNCTION:	Copy a canned message (address in R4) into a buffer
::		(index in R2).  First byte of message must be byte count.
::	CALLING SEQ:	JAL	R9,BUFCAN
::	INPUT:		R2 = BUFFER INDEX
::			R4 = ADDRESS
::	DESTROYED:	R1, R4, R5, R8
::	CALLS:		JAL	R8,WCI
::
::*********************************************************************

BUFCAN	ST	R5,BURSAV		:Save reg 5 (CHN)
	LB	R1,0,R4			:GET LENGTH
	JER	R9			:ZERO COUNT, RETURN
	LIS	R5,1			:COMPUTE NEG. INDEX
	SR	R5,R1
	AR	R4,R1			:COMPUTE END OF STRING

BUFCA1	LB	R1,0,R4,R5		:GET DATA BYTE
	JAL	R8,WCI			:WRITE IT INTO BUFFER
	AIS	R5,1			:NEXT BYTE
	JLEBS	BUFCA1			:CONTINUE LOOP
	L	R5,BURSAV		:Restore reg 5 (CHN)
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	MERGE:/PREFIX:/MOVE:
::	ENTRY POINTS:
::		MERGE:	USED DURING REBUILD PROCESS.
::		ANY USER BYTES THAT MAY HAVE ACCUMMULATED IN THE OUTBOUND
::		BUFFER (NOW CONNECTED TO A 'STUB') ARE COPIED OVER BYTE
::		BY BYTE INTO THE CORRESPONDING HISTORY BUFFER, BEHIND THE
::		HISTORY DATA ITSELF. THEN THE H-BUFFER DESCRIPTOR (BB,
::		BE, BF, BCT, SEQN) IS COPIED INTO THE S-BUFFER DESCRIPTOR,
::		AND IS ITSELF CLEARED.	THE RESULT IS AN EMPTY HISTORY
::		BUFFER AND AN OUTPUT BUFFER CONTAINING HISTORY DATA FOLOWED
::		BY SUBSEQUENT USER DATA.
::		IN THE EVENT THAT THE OUTPUT BUFFER CONTAINS A GOBBLER,
::		THE HISTORY BUFFER IS SIMPLY CLEARED.
::		R6 = OUTBOUND BUFF #
::		R7 = HISTORY BUFF (COMPUTED FROM R6)
::		PREFIX:
::		CONTENTS OF BUFFER IN R7 TO THE CONTENTS OF BUFFER IN R6.
::		SOURCE BUFFER IS CLEARED.
::		R6 = DESTINATION
::		R7 = SOURCE (CLEARED)
::		MOVE:
::		MOVES ALL DATA IN BUFFER GIVEN IN R7 TO BUFFER GIVEN IN R6.
::		R6 = DESTINATION
::		R7 = SOURCE
::
::*********************************************************************

	IF	REBILD

MERGE	LR	R7,R6			:COMPUTE HB #
	SRHLS	R7,1
	NHI	R7,-4
	AI	R7,HBUFN
	LHL	R1,BCT,R7,
	JER	R9			:HISTORY BUFFER IS EMPTY
	LR	R2,R6			:IF GOBBLER IN OB, CLEAR HB
	L	R3,BB,R2,
	JE	MERGE4			:TEST FOR GOBBLER IN OB

	JAL	R8,PCI			:IF A GOBBLER IN OB, CLEAR HB...###OAS
	CLHI	R1,3
	JN	MERGE4
	JAL	R8,PCI
	CLHI	R1,GOBBL&0FF
	JN	MERGE1
	LR	R2,R7			:CLEAR HB (CONTENTS IRRELEVANT)
	JAL	R8,CBCLR
	L	R1,SEQN,R6,		:MAINTAIN INTEGRITY OF SEQUENCE
	ST	R1,SEQN,R7,
	JR	R9
merge1	clhi	r1,sqfix&0ff		:is it a sqfix?
	jnfs	merge4
	jal	r8,gci			:yes, good reasons to not copy it
	jal	r8,gci			:eat sqfix
	jal	r8,gci			:and four bytes of sequence: 1
	jal	r8,gci			:2
	jal	r8,gci			:3
	jal	r8,gci			:4  and continue
MERGE4	ST	R9,SPLSV1		:SAVE LINK
	JAL	R9,APPEND		:EMPTY DATA IN OB AND WRITE IT INTO HB
	L	R9,SPLSV1
MERGE3	LR	R2,R6			:NOW CLEAR OB
	JAL	R8,CBCLR
	LIS	R0,0
	L	R1,BB,R7,		:MOVE EVERYTHING FROM HB TO OB
	ST	R1,BB,R6,
	ST	R0,BB,R7,
	L	R1,BE,R7,
	ST	R1,BE,R6,
	ST	R0,BE,R7,
	LHL	R1,BF,R7,
	STH	R1,BF,R6,
	STH	R0,BF,R7,
	LHL	R1,BCT,R7,
	STH	R1,BCT,R6,
	STH	R0,BCT,R7,
					:correct bug of history in use number
	AHI	R1,CBSZ-1-CBPTSZ :BCT to a mult of 14d (HW pointer, 1st char)
	CI	R6,HBUFN	:dest history buffer?
	JLFS	MERG8		:nope
	AM	R1,HBFTSV	:bump up its in use
	JGEFS	MERG8		:in use still ok
	JAL	R7,NEGHCR,,	:went negative
MERG8	CI	R7,HBUFN	:one losing the chars a hist buff?
	JLFS	MERG9		:nope
	SR	R0,R1		:get a count to reduce the number
	AM	R0,HBFTSV	:little bit smaller
	JGEFS	MERG9
	JAL	R7,NEGHCR,,	:history went negative
MERG9	LIS	R0,0		:restore reg.
	L	R1,SEQN,R7,
	ST	R1,SEQN,R6,
	JR	R9


PREFIX	EQ	MERGE4
MOVE	EQ	MERGE3

	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	TRUNC:
::	FUNCTION:	REMOVES CHARS FROM BUFFER UNTIL 'BE'=CONTENTS OF R3.
::	CALLING SEQ:	JAL	R9,TRUNC
::	INPUT:		R2 = BUFF #
::			R3 = FULL WORD PTR TO CHARACTER
::
::*********************************************************************

TRUNC	LR	R6,R3
TRUNC1	LHL	R0,BCT,R2,		:BUFF EMPTY
	JER	R9
	JAL	R8,GCI		:REMOVE A CHAR
	CL	R6,BB,R2,
	JNBS	TRUNC1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	APPEND:
::	FUNCTION:	DOES A BYTE-BY-BYTE COPY OF SOURCE (R6) BUFFER
::		INTO DESTINATION (R7) BUFFER, LEAVING THE SOURCE BUFFER EMPTY
::	CALLING SEQ:	JAL	R9,APPEND
::	INPUT:		R6 = SOURCE
::			R7 = DESTINATION
::
::*********************************************************************

APPEND	LHL	R0,BCT,R6,		:SOURCE EMPTY?
	JER	R9			:YES, EXIT
	LHL	R1,BCT,R7,		:any in destination?
	JE	APPEN6			:no, just move buffers as a group
:	reverse copy appears to have a bug.  plus it isn't really needed
:	with forward copy being so fast as most that could be in dest is
:	dispi backpressure limit so worst case isn't that bad.
:	SRLS	R1,apprat		:divide dest BCT by 16
:	CR	R0,R1			:if dest much smaller than source?
:	JL	APPEN3			:if yes then empty from the smaller

	stm	r12,appnsv		:save regs (r12 is prd, r14 is lrc)
	lhl	r15,bct,r6,
	sis	r15,1			:count is multiples of bflets left
spli00	l	prd,bb,r6,
	lr	r15,r15			:at last bufferlet?
	jgfs	spli03
	l	lrc,be,r6,		:end-start
	sr	lrc,prd			:amount in this bflet is to be moved
	ais	lrc,1			:pointers are equal when 1 char in buf
	jfs	spli05
spli03	lhi	lrc,cbsz		:end of buf minus curr address
	sr	lrc,prd
	nhi	lrc,cbsz-1		:remove extra bits
spli05	lr	r2,r7
	L	R3,BE,R2,		:LOAD THE BUFFER IN POINTER
					:must be there
:	RTD COPY MICROINSTRUCTION:
:		R1  = scratch
:		R14 = LRC = byte count of characters to move
:		R12 = PRD = address of the logical record
:		R3  = BE (address of the last character input)
:	NOTE THAT THE RTD COPY INSTRUCTION WAITS UNTIL IT HAS 2 BYTES
:	TO MOVE BEFORE IT ACTUALLY WRITES INTO THE BUFFERLET. THIS
:	MEANS THAT IF A SPECIAL CHARACTER IS ALSO THE LAST CHAR IN A
:	LOGICAL RECORD, IT MUST BE EXPLICITLY STORED WITH A STB INSTRUCTION
:	SINCE THE MICROCODE MAY NOT HAVE DONE SO.

	LHL	R0,0,R3			:SET UP SCRATCH REGISTER
	EXHR	R0,R0			: FOR THE MICROCODE
	LHL	R1,0,PRD
	OR	R1,R0

spli11	HC	3B1E			:RTD Copy 1 - SCRATCH REG, BYTE COUNT 
spli12	HC	3C1E			:RTD Copy 2 - RESUME PROCESSING HERE
	HC	spliNX-spli12		:TO GET NEXT BUFFERLET
	HC	spliC0-spli12		:TO HANDLE CHARACTER PAIRS
	HC	spliC1-spli12		:TO HANDLE PREFIX CODES
	HC	spliC2-spli12		:TO HANDLE GOBBLERS
	HC	spliC3-spli12		:TO HANDLE ZAPPERS

:	WE'VE move one bflet over or completely done
spli20	ST	R3,BE,R2,		:COME HERE WHEN DONE -- SAVE END ADDR
	lr	r3,prd			:bflet we are returning
	lr	r2,r6			:source bflet
	shi	r15,cbsz-2		:how much more to copy?
	jlfs	spli25			:this was a full bflet
	jal	r8,gcret		:return a bflet
	j	spli00			:do next bflet
spli25	ahi	r3,cbsz-1		:round up to    ###jay
	nhi	r3,-cbsz		:  link field   ###jay
	jal	r8,gclast		:return last buflet	
	lm	r12,appnsv
	Jr	r9			:DONE WITH THIS copy

:	HERE TO SET UP A NEW BUFFERLET
spliNX	JAL	R8,NXTBLT,,
	J	spli12

:	the kickouts for the special characters.  leave r1 the scratch
:	register alone cause then can reenter rtd and will continue along.
:	but load r0 with the char cause otherwise don't know what the char
:	was and have to know what the char is if this was last char.
spliC0	LIS	R0,0			:COME HERE FOR 00 CHARACTER
	JFS	spli40

spliC1	LIS	R0,1			:COME HERE FOR 01 CHARACTER
	jfs	spli40

spliC2	LIS	R0,2			:COME HERE FOR 02 CHARACTER
	Jfs	spli40

spliC3	LIS	R0,3			:COME HERE FOR 03 CHARACTER

:	HERE TO CONTINUE AS IF SPEC CHARACTER HADN'T BEEN DETECTED

spli40	SIS	LRC,1			:DECR LRC SINCE MICROCODE DIDN'T
	JG	spli11			:MORE FOR THIS CHANNEL, GO DO IT

	STB	R0,0,R3
	J	spli20			:GO FINISH UP

:	no dest data, just swap bflet pointers
APPEN6	L	R0,BB,R6,		:move buflets from source to dest
	ST	R0,BB,R7,		:and we know dest was empty
	L	R0,BE,R6,
	ST	R0,BE,R7,		:BB, BE, and will do BCT
	LH	R0,BF,R6,		:and mark buffer as empty
	RBT	R0,NFLAGS
	LH	R0,BF,R7,
	SBT	R0,NFLAGS		:and other now has data
					:and get BCT to fix history in use
	LHL	R0,BCT,R6,
	STH	R0,BCT,R7,		:all dest pointers ok
	AHI	R0,CBSZ-1-CBPTSZ	:2 for pointer and 1 for first char

SPLIC9	HS	0			:standard HBUF in use and clear source
					:section of code
     IF REBILD
	CI	R7,HBUFN		:dest a hist buff?
	JLFS	APPEN7			:nope, normal buff
	AM	R0,HBFTSV		:yes, more history bytes in use
APPEN7	CI	R6,HBUFN		:source a hist buff?
	JLFS	APPEN8			:nope
	LIS	R1,0			:we need to subtract
	SR	R1,R0			:get a negative BCT
	AM	R1,HBFTSV		:reduce count in use
	JGEFS	APPEN8			:make sure didn't go negative
	JAL	R7,NEGHCR,,		:crash if went neg
     EI  :REBILD
APPEN8	LIS	R0,0			:clear out source
	STH	R0,BCT,R6,
	ST	R0,BB,R6,
	ST	R0,BE,R6,
	JR	R9			:DONE

::*****************************************************
: GCD   gets char from other end of buffer.  the end which WCI writes to.
:	links on R8
:	input:  R2 is buffer number
:	trashes: R0 and R3 (normal buffer trashed regs).

GCD	L	R3,BE,R2,		:end of buffer
	JNFS	GCD1			:not empty
	JAL	R0,OOPS,,
	JR	R8
GCD1	LB	R1,0,R3			:get the char
	CL	R3,BB,R2,		:last char?
	JE	GCLAST			:BE=BB so empty and use existing
	SIS	R3,1			:back up BE
	ST	R3,BE,R2,		:save it
	THI	R3,CBSZ-cbptsz		:if BFlet empty then nibble =1 so
	JNR	R8			:bflet still has data

:cute little fall through.  must return bufferlet but all we have is
:last entry of linked buffer list.  so must go to start and look for
:the link that points to our current position.

GCDRET	AHI	R3,CBSZ-1		:move it up to the pointer
	LHL	R0,FREELF		:insert our buffer to start of free
	STH	R0,0,R3			:link all free to our buflet
	SIS	R3,2			:make r3 a buf number
	SRLS	R3,CBSZL		:now it is buf number
	STH	R3,FREELF		:put it on free list
	LR	R0,R3			:use R0 so R3 can be used for index
	L	R3,BB,R2,		:get start of list
	AHI	R3,CBSZ-CBPTSZ		:get pointer location
	NHI	R3,-CBSZ		:got it (it sits on quad word bound)
	STH	R1,GCDSV		:save character
	LHL	R1,BCT,R2,		:limit number of buffers to search
GCD2	CLH	R0,0,R3			:R0 is buffer just emptied
	JE	GCD3			:found link
	LHL	R3,0,R3			:get next pointer
	SLLS	R3,CBSZL		:make into address
	AHI	R3,CBSZ			:now is address of the next pointer
	SHI	R1,CBSZ-CBPTSZ		:limit on search
	JGEBS	GCD2			:loop until find link
	CRASH.(.GCD0)			:buffer chains are messed up

GCD3	LH	R1,GCDSV		:restore char
	SIS	R3,1			:adjust to end of bflet
	ST	R3,BE,R2,		:save new end
	LHI	R0,CBPTSZ-CBSZ
	AHM	R0,BCT,R2,		:knock down BCT
	AM	R0,BFLTSV		:knock bytes in use
     IF REBILD
	JGEFS	GCD4			:count still ok
     ELSE
	JGER	R8			:not rebuild have nothing else to do
     EI		:REBILD
	JAL	R7,NEGBCR,,		:crash if not negative
      IF REBILD
GCD4	CI	R2,HBUFN		:history buffer?
	JLR	R8			:done
	AM	R0,HBFTSV
	JGER	R8			:done
	JAL	R7,NEGHCR,,		:crash r7 being location
      EI	:REBILD



::*********************************************************************
::
::	SUBROUTINE:	PURGE:
::	FUNCTION:	REMOVES CHARACTERS FROM SOURCE BUFFER UNTIL CHAR
::		BEARING A GIVEN SEQ # IS AT FRONT OF BUFFER.
::	CALLING SEQ:	JAL	R9,PURGE
::	INPUT:		R2 = BUFF #
::			R4 = SEQN OF FIRST CHAR IN BUFFER
::			R5 = SEQN OF FIRST CHAR AFTER PURGE
::	RETURNS:	TAKES IMMED RETURN IF DATA HAS BEEN LOST.
::			ELSE +4 RETURN
::
::*********************************************************************

	IF	REBILD

PURGE	SR	R4,R5			:FORM -(NUMBER OF EXCESS CHARACTERS)
	JE	4,R9			:NO EXCESS CHARACTERS, DO SKIP RETURN
	JG	PUREXI			:DESIRED DATA NOT IN H-BUFFER	###wjl
					: - DATA LOST!
PURG1	LHL	R0,BCT,R2,		:DATA IN BUFFER?
	JEFS	PUREXI			:NO, LOST DATA, DO NON-SKIP RETURN#wjl
	LIS	R0,0			:r0 is going to be how many to purge
	SR	R0,R4			:how many to purge
	LR	R4,R0			:save a copy for ourselves
	JAL	R8,RTBFTS		:return chars
	CR	R0,R4			:r0 is how many actually purged
	JNFS	PUREXI			:not able to return requested #	###wjl
	ST	R5,SEQN,R2,		:bump number purged
	J	4,R9			:routine by ###sdw

PUREXI	SKIP(0,R9)			:immediate return		###wjl

	EI	:REBILD


	SUBTTL  BUFF (LOG II character scan)


::*****************************************************************
::
::	IGPCIE  special peek of buffers.  Gets a char and saves how
::		many chars read so X.409 parse routine knows where it
::		is it in the X.409 element.
::		IGPCIE will count each char read at ELEDIS.
::
::		Links on R9, trashes  r8.  New BFposition in R3.
::		Char in R1.
::
::*****************************************************************

       IF	LOGII

IGPCIE	LIS	R1,1			:eount how many read
	AHM	R1,ELEDIS		:to figure out where messages end
IGPCIO	JAL	R8,PCI			:other entry does not update count
	LR	R1,R1			:escaped char?
	JNR	R9			:nope so done
	JAL	R8,PCI			:get the escaped char
	JR	R9			:and done
       EI	:LOGII
	ENDMO.(BUFF)
	EI	:1-KILLIT
	KILMSG(BUFF)

:	***NOTHING PAST THIS POINT***

	SUBTTL	LOGSUP

:			*      ***   ***   ***  *   * ****
:			*     *   * *     *     *   * *   *
:			*     *   * *  **  ***  *   * ****
:			*     *   * *   *     * *   * *
:			*****  ***   ***  ****   ***  *

::#####################################################################
::
::	MODULE:		LOGSUP
::
::	SUBTTLS:	LOGGER - Process data to sup in login mode
::			SUP message generators
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG	a.code

::*********************************************************************
::
::	SUBPROCESS:	LOGGER:
::	FUNCTION:	Process ports in login mode.
::	SCHEDULED:	Runs off SWITCH exec loop, based on presence of
::			data in LOGBUF.
::		LOGGER processes data from ports in login mode (ISIS)
::		toward the supervisor.  It does not use the 
::		usual attention-flag scheme to detect which login buffers
::		have data ready to go.  This is because login data is not
::		necessarily "ready to go" simply because it is available
::		in a buffer.  Instead, the process which fills the login
::		buffer monitors the input for 1) a login-string terminator
::		(semi-:or CR), 2) an escape, or 3) overflow (a login-string
::		may not be longer than 55d bytes).  When one of these is
::		detected, the filling process marks the buffer ready for
::		LOGGER service by writing the login-buffer's index into
::		LOGBUF (as an escaped HW).  LOGGER's attention gets flagged
::		by the presence of something in LOGBUF.  For related reasons,
::		a login-buffer's BF is never a channel number in the regular
::		sense.  Instead, it is a value between 10 (LOGMIN) and 17
::		(LOGMAX).  This value defines the current state of the login-
::		buffer, as follows:
::			10-bit :port is in login mode.
::			01-bit :(LG.TID) TID is in the login buffer (i.e.,
::				 hasn't been sent to the supe yet.
::			02-bit :(LOGNDC) node code is ready to transmit 
::				 login data.
::			04-bit :(LOGSUP) supe is ready to accept login data.
::
::*********************************************************************

IIXLOG	EQ	1	:bit of IOTAB entry set for IIX circuit request	###jhl
LGCHMX	EQ	$A 48	:Maximum characters allowed for login
:	Start out by appending a marker (0 HW) to the contents of LOGBUF.
:	We will cycle thru LOGBUF looking for login-buffer numbers.
:	We will service each buffer once, and when we get to the marker 
:	we'll know that we're through.
       if       1-NCSLOT                :NO LOGGER IF NO DISPATCHER

LOGGER	LIS	R2,0			:PUT A MARKER IN THE LOGGER LIST
       if       loglim
        lhl     r0,logout       :count last time through of ports waiting
        sth     r0,logouo       :tells us how many can add this time
        sth     r2,logout       :count of outstanding logon requests to sup
       ei       :loglim

:	Write marker to LOGBUF (first pass) or return buffer just serviced
:	to LOGBUF (if it still needs LOGGER service).  Jumping to here from
:	below has the effect of returning the current buffer to the LOGGER
:	list before going on to the next login-buffer.
LOG1	LR	R1,R2			:RETURN CURRENT PORT TO LOGGER LIST
	LIS	R2,LOGBUF
	JAL	R9,WHWI0

:	Get the next buffer index from LOGBUF. If its our 0-marker,
:	RETURN via LOGXIT. Otherwise, check its BF to make sure its a valid
:	login-buffer (LOGMIN<=BF<=logmax).  If it is, skip to LOG7.
:	Jumping here from below has the effect of removing the current buffer
:	from the LOGGER list.
LOG0	LIS	R2,LOGBUF		:PROCESS NEXT PORT
	JAL	R9,GHWI0
	LR	R2,R1			:THIS IS THE BUFFER W/ CHARS FOR SUP
	JE	LOGXIT,,		:MARKER, WE'RE DONE

	LHL	R1,BF,R2,		:INSURE WE'RE REALLY IN LOGIN
	CLHI	R1,LOGMIN		:TEST FOR VALID LOG IN MODE
	JLFS	LOG8
	CLHI	R1,LOGMAX
	JLE	LOG7			:YES WE ARE IN LOGIN MODE
:	INVALID LOGGER BF. REPORT TO XRAY AND REMOVE OFFENDING BUFFER
:	NUMBER FROM THE LOGGER LIST.
:	Found an invalid BF (not in login mode) for a buffer in LOGBUF.
:	Report to crypto (CRYE23) and go on to the next entry (LOG0) without
:	putting this buffer back into LOGBUF.
LOG8	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,0			:CASE # 0
	JAL	R14,LGGDB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	EXHR	R0,R2			:###TZ
	OR	R0,R1			:###TZ
	JAL	R8,CRYPTO,,		:REPORT WITH BAD BUFFER INDEX, BF IN R0
	HC	CRYE23
	J	LOG0			:JUMPING TO LOG0 HAS THE EFFECT OF
					:REMOVING BUFFER # FROM LOGGER LIST.
:	Found a login-buffer with a valid BF.  Check to see if we have a sup
:	circuit and if we have not had a recent takeover.  If both are ture,
:	continue.  Else, go zap the login circuit (LOGZAP).  We can't
:	process logins if there is no sup, and we can't continue to process
:	logins if there a possibility that a new supe is taking us over.
LOG7	LHL	R0,TVRBUF		:IS THERE A SUP?
	JE	LOGZAP,,		:NO, ZAP CIRCUIT
	LHL	R0,LOGZPF		:HAS THERE BEEN A TAKEOVER?
	JN	LOGZAP,,		:YES, ZAP CIRCUIT

:	If the INFinite-LoGin-Timer flag is not set, we have to see if the
:	login-circuit has timed out.  If the TID has already been sent to the
:	sup, we let the sup handle the timeout (skip to LOG9).  Otherwise,
:	we check for timeout by seeing if we've passed the SLOWC time that was
:	saved in BUFTIM when the login was initiated (timeout is 120d seconds).
	IF	1-INFLGT
	LHL	R1,BF,R2,		:GET BUFFER FLAG
	THI	R1,LG.TID		:TID IN BUFFER ?
	JE	LOG9			:NO, SUP WILL TIME THIS ONE OUT

	SRLS	R2,1			:COMPUTE BUFTIM INDEX
	NHI	R2,-4
	L	R0,BUFTIM,R2,		:HAS THIS CIRCUIT TIMED OUT?
	SLLS	R2,1			:RESTORE BUFFER #
	S	R0,SLOWC,,		:(BUFTIM HAD START TIME + 120d)
	JG	LOG9			:NOT YET

:	HAVE DISPI (IN) SEND:
:		SUPER HANG (ISIS B8) (FOR HDX TERMINALS)
:		TEXT "PLEASE SEE YOUR REPRE..."
:		HANG (ISIS AF)  (NORMAL HANG)
:	Login-circuit timed out.  Send "please see your Rep"
:	(with HANG and HDX-HANG) to port.  Then go service the next
:	login-buffer (LOG0) without putting this one back in the LOGGER list
:	(LOGBUF).

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,2			:CASE # 2
	JAL	R14,LGGDB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	XHI	R2,4			:OTHER BUFFER

	IF	T2GATE
	LHL	R5,BF,R2,
	SHI	R5,DISZFL		:Get dispatcher port
	LA	R1,PSRMSG,,
	JAL	R8,DIMMES		:Output "pls see your rep.."
	TBT	R5,GTTRNS
	JN	GLOG7
	LA	R1,GNGONE,,
	JAL	R8,DIMMES
	DROUTE(ISISN,HOMEN)		:If non-transparent send
	LA	R1,CRLF			:"inter-link cleared .."
	JAL	R8,DIMMES
GLOG7	LHI	R1,09E00		:In either case zap circuit
	JAL	R8,DIRMES
	LIS	R1,0			:and let dispatcher Zapper ack
	XHI	R2,4			:return logon circuitry
	STH	R1,BF,R2,		:Set bf to Zero for RFCBUF
	SBT	CHN,DISZNK		:And set up for Zapv to clean up

	ELSE	:NOT T2GATE
         IF     LOGII                   :rejecting a LOG II request?
        LHL     CHN,BF,R2,              :get chn #
        SHI     CHN,DISZFL
        TBT     CHN,DISLG2              :a log 2 request?
        JEFS    LOG007                  :nope do normal
        LHI     R1,L2NRJT               :NC generated log 2 reject
        JAL     R9,W2CI
        LIS     R1,4                    :reason being timout
        JAL     R8,WCI
        J       LGZPCN                  :leading to a zap
         EI     :LOGII
:	timeout a regular port (timout a logon attempt)
LOG007	LA	R4,PSRMSG,,		:ADDRESS OF Please See your...(W/HANGS)
	JAL	R9,BUFCAN		:OUTPUT MESSAGE TO BUFFER
	EI	:T2GATE

	J	LOG0			:REMOVE THIS BUFFER FROM LIST
	EI	:1-INFLGT

:	Here for login-buffer that has not timed out.
:	If the supe and node code bits are both set in the buffer's BF,
:	we continue.  Otherwise, we go on to the next buffer (LOG1) and
:	return this buffer to the LOGGER list.
LOG9	HS	0
       IF       T2GATE
        J       GLOG9,,                 :go to separate gateway lgosup
CRLF    SC      /"8D"8A/
        GL      GLOG9,LOGZAP,LOGXIT     :for gateway in gatway module
      ELSE      :otherwise use normal logsup which is not gateway
	LHL	R1,BF,R2,		:ARE WE IN XMIT MODE (SUP & NC)
        if      loglim
        thi     r1,logsup               :waiting for a response?
        jnfs    log9sw
        lis     r0,1
        ahm     r0,logout               :waiting for supe response
        j       log1                    :and not ready for another by def
log9sw
        ei      :loglim
	NHI	R1,@LG.TID		:(TID DOESN'T COUNT)
	CLHI	R1,LOGXMT
	JN	LOG1			:NO, BACK TO THE LIST

:	Here for buffer with BF set ready to transmit.
:	If there is data in the buffer, continue.  Otherwise,
:	go on to next buffer (LOG1).
	LHL	R1,BCT,R2,
	JLE	LOG1			:RETURN TO LOGGER LIST
:       basic idea with loglim is to limit how many messages we send to
:       the sup before getting a response.  reason is that if the supe is
:       being real slow it makes it worse to be sending up lots of logon
:       requests especially if the person might be zapping their circuit
:       before even getting a response.  so don't overwhelm the sup and
:       handle the impatient users at the node and don't even bother the
:       the sup.  the coding is simple.  have two counts.  logout and logouo.
:       logout is how many ports are waiting for a response right now
:       and is a running count (not accurate until scanned all ports).
:       logouo is logout of last time through (so has an accurate count
:       except for those ports which got a response between last time and
:       now so it adds a slight lag for freeing up when hit threshold but
:       that doesn't seem like a bad idea) and also add new ports to logouo
:       so can stop is several ports have data to send.
       if       loglim
        lhl     r0,logouo               :too many waiting already?
        clhi    r0,loglim               :about to exceed limit?
        jg      log1                    :don't overwhelm supe
        lis     r0,1
        ahm     r0,logout               :and count it as out
        ahm     r0,logouo               :one fewer that can send this time
       ei       :loglim

LOG10	HS	0			:Found a login-buffer with data in it.
       IF       LOGII                   :log 2 logon data gets special handlng
        XHI     R2,4
        LHL     CHN,BF,R2,              :so find if it is a log 2 dport
        XHI     R2,4                    :back to logon chars
        SHI     CHN,DISZFL
        TBT     CHN,DISLG2              :a log 2 request
        JE      LOG101                  :not a log 2 request

:       this is a log 2 request.  Thus in the buffer should be a complete
:       NCRM.  All we have to do is add the node #, type and length and
:       copy the NCRM into the supe's buffer.

        LR      R6,R2                   :handle log 2
        LHL     R2,TVRBUF               :get supe buf
        LR      R7,R2                   :make a copy to prepare for copy
        LHI     R1,MACHNM
        JAL     R9,WHWI                 :our node #
        LHI     R1,0880                 :NCRM is type 8 msg | unused byte of 80
        JAL     R9,W2CI
        IF      LPGDBG
        L       R9,BE,R2,
        ST      R9,LPGSSV               :before start of new data
        EI      :LPGDBG
        LR      R2,R6                   :check for a zapper now
        JAL     R8,PCIS
        SIS     R1,3                    :zapper gets converted to NCRM zap msg
        JN      L2G400                  :not a zapper, no worries
        JAL     R8,CBCLR                :is a zap, clear buffer
        LR      R2,R7                   :send logon zap to supe
        CLHI    CHN,100                 :does chn require 1 or 2 bytes
        JLFS    L2G020
        LA      R4,NCRLZM               :requires the long zap msg
        JFS     L2G021
L2G020  LA      R4,NCRSZM               :takes the shorter (1 byte for chn) msg
L2G021  LB      R1,3,R4                 :get Len of X.409 msg
        AIS     R1,3                    :add in length of header of len
        JAL     R9,WHWI                 :write len of zapper NCRM
        JAL     R9,BUFCAN               :put it
        LR      R1,CHN                  :prepare chn # for writing
        CLHI    CHN,100                 :now ready to write chn #
        JLFS    L2G050
        JAL     R9,WHWI                 :write chn #
        JFS     L2G054
L2G050  JAL     R9,WCIE                 :write 1 byte chn number
L2G054  LA      R4,NCRMZE               :the second half of the zap msg
        JAL     R9,BUFCAN               :SMOSET with zap indication
        LR      R2,R7

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,6			:CASE # 6
	JAL	R14,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
	JAL	R14,LGGDB3,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	LR	R2,R6
	LHI	R1,LOGMIN		:set not send since sent zapper
	STH	R1,BF,R2,
        LHI     R1,ZAPPH
        JAL     R9,W2CI                 :leave a zapper in the buffer
	J	LOG1			:PUT HIM BACK ON QUEUE

:       strings of NCRM msgs, NCRxZM is before chn #, NCRMZE after chn #
NCRMZE  SC      /"5F"3D"00"02"06"40"31"00"03"4B"00"01"FF/
NCRLZM  SC      /"7F"3C"10"30"09"5A"00"02/ :NCRM id, len, RMOseq,len, CHN ID
NCRSZM  SC      /"7F"3C"0F"30"08"5A"00"01/ :same as above except for chn<100

L2G400  L       R3,BB,R6,
        ST      R3,ELEPOS               :start of first position
        JAL     R9,X4NXID,,             :get len of element into R0
        CLHI    R0,80
        JLFS    L2G402                  :what is len of len
        CLHI    R0,100                  :was three bytes
        JLFS    L2G401
        AIS     R0,1                    :for len 3
L2G401  AIS     R0,1                    :for len 2
L2G402  AIS     R0,3                    :two for id, 1 for len
        LR      R1,R0
        LR      R2,R7
        JAL     R9,WHWI                 :write it as halfwords
        JAL     R9,APPEND               :now just append the NCRM data


        LHI     R1,LG.SNT               :waiting for supe response
        LR      R2,R6                   :get back dport buffer
        STH     R1,BF,R2,

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,5			:CASE # 5
	JAL	R14,LGGDB2,,
        LHL     R2,TVRBUF
	JAL	R14,LGGDB3,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG
	
        J       LOG1                    :keep on logger list
       EI       :LOGII

LOG101	LR	R6,R2			:MOVE CHARS TO THE LEP BUFFER
	LHL	R10,BF,R2,		:GET LOGIN STATUS (16 OR 17 HEX)

:	Get the login status from BF and convert to proper sup message type
:	(0E=login string continuation, 0F=TID+login string).  
:	Create a login string message in the sup buffer (TVRBUF)
:	get logon status from BF and convert to NEW or not depending on TID
:	in buffer or not.  Send a type 0C message in either case.
LOG11	SIS	R10,08			:CONVERT TO MESSAGE TYPE (0E OR 0F HEX)
	LHL	R2,TVRBUF		:init R2 to hold to-SUP buffer number
	LR	R7,R2			:R7 holds sup buffer while we work
	LHI	R1,MACHNM+8000		:MAKE SUP RECORD
	JAL	R9,WHWI
	LR	R1,R10			:MESSAGE TYPE '0E' OR '0F'
	JAL	R8,WCI

	IF	LPGDBG 			:DEBUGFGER		###LSH 
	L	R1,BE,R7,
	ST	R1,LPGSSV		:save ptr to use in cpying data
	EI	:LPGDBG

	LIS	R1,0
	JAL	R8,WCI			:ASSUME CHAR COUNT NEEDS ESCAPING
	JAL	R8,WCI			:ESCAPED CHAR CNT WILL GO HERE IN BUFF
	L	R10,BE,R2,		:SAVE POINTER TO IT
	LR	R1,R6
	XHI	R1,4			:GET THE PORT #
	LHL	R1,BF,R1,
	OHI	R1,8000			:SET FOR SUP
	JAL	R9,WHWI
	LHI	LRC,80			:NUMB OF CHARACTERS TO BE SENT.
:	80-bit means not SIQ circuit. May be reset below.
		
:	If the TID is still in the buffer, include the host number.
:	Else skip to LOG3.
	LIS	R2,0F			:LAST (TID) BIT IN HW
	TBT	R2,BF,R6,		:TID WAITING TO BE SENT ?
	JE	LOG3			:NO, SKIP HOST NUMBER
:	If we're sending the intial login string (msg type 0F),
:	we have to check for a smart (SIQ) circuit and inform the sup if so.
:	We know a circuit is SIQ if the LO bit of the orginating channel's
:	permuter table entry is set (i.e., the LO gouging bit).  We tell
:	the supe a circuit is SIQ by resetting the HO bit of the count field
:	(1 byte) in the type-0F message.
	XHI	R6,4
	LHL	R9,BF,R6,		:GET ORIGINATING CHANNEL
	XHI	R6,4
	LHL	R0,IOTAB,R9,R9		:PERMUTER TABLE ENTRY FOR CIRCUIT ORIG
	THI	R0,IIXLOG		:SIQ CIRCUIT?
	JEFS	LOG9SQ			:NO
	LIS	LRC,0			:ABSENCE OF 80 BIT INDICATES SIQ TO SUP
:	Type 0F msg. Include host number+8000.
LOG9SQ	LR	R2,R6			:GET PORT BUFFER
	JAL	R9,GHWI			:GET 8000+HOST NUMBER
	LR	R2,R7			:GET SUP BUFFER
	JAL	R9,WHWI			:WRITE HOST NUMBER

:	Supe message header complete.  Now append login string from login
:	buffer to it (escaping as necessary) until login buffer is depleted or
:	a terminator or escape char is detected.  (See LOGDLM for escape
:	characters-- there are several.)  Bump the count in LRC as we go.
:	Skip to LOG05 if the buffer empties.
LOG3	LR	R2,R6			:port buffer
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG05			:IT'S EMPTY NOW
	JAL	R8,GCI			:read out a byte
	LR	R2,R7			:sup buffer
	JAL	R9,WCIE
	AIS	LRC,1			:INC STRING COUNT (don't count escapes)
	AIS	R4,1			:STOP WHEN CR, SEMI-:, OR ESC IS FOUND
	TBT	R1,LOGDLM-10		:DELIMITER = 'CR', "SEMI-:", 'ESC' ?
	JE	LOG3			:no, continue at top of loop
	J	LOG4

:	Detected terminator (semi-:, CR) or escape in login string.
:	Complete supe message, mark BF for TID sent and waiting for response
:	from sup (ie, node code and sup not ready).  Go on to next buffer(LOG1)

LOG4	STB	LRC,0,R10		:CR OR SEM--PUT AWAY COUNT
	LR	R2,R6			:get user buffer
	LHI	R1,LG.SNT		:SET NO TID, SUP NO LONGER READY,
	STH	R1,BF,R2,		:	NODE CODE NO LONGER READY

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,4			:CASE # 4
	JAL	R14,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
	JAL	R14,LGGDB3,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG
	
	J	LOG1

:	Login buffer emptied while we were transfering it to the sup buffer.
:	Close out the supe message, mark the login buffer's BF to show TID has
:	been sent, then go on to next buffer (LOG1).
LOG05	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,3			:CASE # 3
	JAL	R14,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
	JAL	R14,LGGDB3,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	STB	LRC,0,R10		:EMPTY BUFF - PUT AWAY COUNT
	LR	R2,R6
	LHI	R1,LGSN.T		:SET SUP & NC = Y, TID = N
	STH	R1,BF,R2,
	J	LOG1			:PUT HIM BACK ON QUEUE

:	(CR) (ESC,FS,GS,RS,US) (SEMI:) ({,|,},TILDA)
:	Bit array (80x bits) marks ASCII codes that are to be considered
:	"escapes" in a login string.
LOGDLM	HC	0004,001F,0000,0010,0000,0000,0000,001E

::	Here to zap a login circuit because LOGGER found no sup or recent
::	takeover (in either case we can't process any more login data now,
::	and because we can't be sure of the status of any login data 
::	already sent to the (a) sup, we have to ask every one to start over
::	again).  We zap a port in login mode by sending it a
::	login-error-character-pair (0313).  If ISIS, DISPI will send the
::	dispatcher a B5 message and a zapper, and will call ZAPV when it gets
::	the corresponding zapper ack.  In a CONSAT, the port will be hung and
::	a zapper sent back to the node code by ASYNC.
::	For Gateway, we must send a zapper (to invoke an ISIS detatch)
::	and let the zap ack invoke Zapv to clear circuit - because we are not
::	talking to a terminal in Log-in mode, but to an active circuit in
::	another network.
LOGZAP	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,1			:CASE # 1
	JAL	R14,LGGDB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	XHI	R2,4			:ZAP CIRCUIT
         IF     LOGII
        LHL     CHN,BF,R2,              :zapping a log 2 port?
        SHI     CHN,DISZFL
        TBT     CHN,DISLG2              :log 2 circuit request?
        JE      LGZA3                   :nope do normal
        LHI     R1,L2NRJT               :log 2 circuit reject
        JAL     R9,W2CI
        LIS     R1,03
        JAL     R8,WCI                  :with lost supe as reason
        J       LGZPCN                  :and finish
         EI     :LOGII
LGZA3	LIS	R1,3
	JAL	R8,WCI			:LOGRR (0313) ACTS AS ZAPPER
	LHI	R1,LOGRR&0FF		:(SENT TOWARDS CIRCUIT ORIGINATOR)
	JAL	R8,WCI
	LIS	R1,0			:ISIS unable to complete request###wjl
	JAL	R8,WCI			:ERROR CODE
LGZPCN	XHI	R2,4			:Continuation point in either case

:	Set this guy's BF back to 0 (nothing doing) and go on to the next
:	buffer (LOG0).
	LIS	R1,0			:ZERO BUFFER FLAG
	STH	R1,BF,2,
	
	J	LOG0			:DONT PUT HIM BACK

:	LOGGER exit point.  Mark the 'has-ther-been-a-recent-takeover" flag
:	to "no" before returning to SWITCH exec loop (LOGRET).
LOGXIT	LIS	R0,0			:FORCE THIS TO NORMAL STATE
	STH	R0,LOGZPF
	J	LOGRET,,

       EI       :T2GATE :the not gateway section

       EI       :1-NCSLOT


::*********************************************************************
::
::	SUBROUTINE:	LOGCLR:
::	FUNCTION:	Remove a login-buffer (index in R6) from the
::		LOGGER list (LOGBUF).
::		Starts by appending a marker (HW 0) into LOGBUF,
::		then searching thru LOGBUF for the specified buffer index.
::		It is removed, the marker is removed, and we RETURN to the
::		caller only after reaching the end of list.
::	CALLING SEQ:	JAL	R9,LOGCLR
::	DESTROYED:	R1
::	CALLS:		JAL	R9,WHWI0
::			JAL	R9,GHWI0
::
::*********************************************************************

LOGCLR	ST	R9,LGCSAV		:SAVE LINKER REGISTER		###LSH
	ST	R2,LOGTBF
	LIS	R2,LOGBUF
	LIS	R1,0
LOGCL1	JAL	R9,WHWI0		:WRITE MARKER
LOGCL2	JAL	R9,GHWI0		:GET NEXT ENTRY
	LR	R1,R1			:END OF MARKERS?
	JEFS	LOGCL3			:YES, WE'RE DONE
	CR	R1,R6			:MARKER MATCH?
	JEBS	LOGCL2			:THIS IS IT, DONT PUT IT BACK
	JBS	LOGCL1
LOGCL3	L	R9,LGCSAV		:RESTORE LINKER REGISTER	###LSH
	L	R2,LOGTBF
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	LOGIN:
::	FUNCTION:	Initiates login process for a dispatcher or CONSAT port
::	CALLING SEQ:	JAL	R8,LOGIN
::	INPUT:		R0 = TID (0 if aux circuit)
::			R2 = login input buffer
::			R5 = CHN = absolute channel number of the login port
::	RETURNS:	Does skip+4 return if successful,
::			straight return if no sup. 
::
::*********************************************************************

       IF       1-ncslot

:	If there is no sup, call ZAPHRD to zap the login circuit,
:	then do straight return.  Otherwise, continue at LOGI1.
LOGIN	HS	0

	IF	LNFDBG		:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LINDB1,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LNFDBG

	ST	R8,LOGSAV		:SAVE RETURN
	STB	R0,LOGTID		:SAVE TID
	STH	R2,LOGTBF		:AND A REG
	LHL	R3,TVRBUF		:IS THERE A SUP?
	JGFS	LOGI1			:YES
LOGI2	JAL	R9,ZAPHRD		:NO SUP, ZAP (FROM REQUESTING PORT)
	L	R8,LOGSAV		:AND TAKE IMMEDIATE RETURN
	SKIP(0,R8)			:				###wjl

:	We have a sup.  Put the login buffer index into LOGBUF so LOGGER will
:	process the data.  If the TID is 0, got to LOGAUX to set up for
:	aux circuit login.  Otherwise, mark the login status (BF) to indicate
:	sup OK, TID in buffer, node code not OK.  Go to LOGIEX to finish up.
LOGI1	LR	R1,R2			:PUT HIM ON LOGGER LIST
	LIS	R2,LOGBUF
	JAL	R9,WHWI0
	LB	R0,LOGTID		:TID=0 (AUX CIR ?)
	JEFS	LOGAUX			:YES,
	LHI	R0,LGST.N		:SUP=Y, TID=Y, NODE CODE=N
	STH	R0,BF,R1,		:SET BF TO LOGIN
	J	LOGIEX			:EXIT, RESTORING REGS.

:	Here because TID is 0 -- aux circuit login.
:	Set login status bits (BF) to indicate supe not OK,
:	TID not in buffer, node code OK.
LOGAUX	HS	0
       IF       1-T2GATE                :gateway never does aux login
	LHI	R0,LGN.ST		:AUX LOGIN -SUP=WAIT, NC=OK, TID =NONE
	STH	R0,BF,R1,
:	Build the aux circuit request in the supe buffer, as follows:
:		8000+node#
:		1081 (or 1001 if ISIS SIQ circuit)
:		8000+channel#
:		8000+requesting host#
	LHL	R2,TVRBUF
	LHI	R1,MACHNM+8000		:REQUEST AUX CIRCUIT
	JAL	R9,WHWI
	LHI	R1,1081			:TYPE,ETC
:	IF SIQ CIRCUIT, INDICATE TO SUP BY ABSENCE OF 80 BIT
	LH	R0,DORSIQ		:SIQ CIRCUIT?
	JGEFS	LOGAX1			:NO
	LHI	R1,1001			:YES - INDICATE SMART SOURCE TO SUP
LOGAX1	JAL	R9,WHWI
	LR	R1,CHN			:PORT #
	OHI	R1,8000
	JAL	R9,WHWI
	LHL	R1,DORHST		:ADD HOST NUMBER TO 
	OHI	R1,8000			:AUX CIRCUIT REQUEST
	JAL	R9,WHWI

       EI       :1-T2GATE

:	Common exit point for regular and aux logins.
:	Set up buffer timeout (BUFTIM, 2 min.), and skip+4 return for all OK.
LOGIEX	L	R8,LOGSAV		:RESTORE LINK
	LH	R2,LOGTBF		:AND BUFFER #

	SRLS	R2,1			:SET UP BUFTIM INDEX
	L	R9,SLOWC,,		:SET UP 2-MINUTE WARNING IN CASE WE
	AHI	R9,$A120		:WANT TO TIME THIS LOGIN OUT
	ST	R9,BUFTIM,R2,
	SLLS	R2,1

	J	4,R8			:SKIP RETURN, ALL OK

       EI       :1-ncslot

	SUBTTL	LOGSUP (Sup message generators)

::*********************************************************************
::
::	SUBROUTINE:	SUP0B:
::	FUNCTION:	Resources Report to Sup
::	CALLING SEQ:	JAL	R10,SUP0B    Called from 2-MINUTE LOGIC
::			and from CRQ when node goes out of passthroughs
::
::*********************************************************************

SUP0B	LHL	R2,TVRBUF		:REPORT AVAILABLE PASSTHRUS
	JER	R10			:no sup--can't report
	lh	r1,pasthc		:no changes since last report 
	jer	r10			:which is different that having
	lis	r1,0			:same value (sup subtracts one and
	sth	r1,pasthc		:doesn't know about zaps)
	LHI	R1,8000+MACHNM		:else write our node #
	JAL	R9,WHWI
	LHI	R1,0B80			:write our messge type
	JAL	R9,WHWI
:	if but one link then make life easy for the sup and report no
:	passthroughs
	lhl	r1,nalink
	sis	r1,1
	jgfs	sup0b3			:just the one link so 0 passthroughs
	lhi	r0,npasth		:if 0 defined then will never change
	sth	r0,pasthc		:change if new link comes up
	j	sup0b6			:have 0 since have but one link

sup0b3	LHI	R1,NPASTH		:number of total possible passthroughs
	SH	R1,PASTHR		:minus number of used passthroughs
	JGEFS	SUP0B4			:a neg check is expecting the worst
	LIS	R1,0			:report none left--an understatement
	jfs	sup0b6			:have 0 since have none free
:	to handle no shrink support which means could run out of chns
:	before running out of circuits, make sure have enough chns
sup0b4	l	r0,noshrk		:any links not doing shrinks?
       if	nlinks-20
	o	r0,noshrk+4		:handle if more than 32 links
       ei
       if	nlinks-40
	o	r0,noshrk+8		:handle if more than 64 links
       ei
	jefs	sup0b6			:none, just use circuits count
	lhl	r0,numpag		:number of free pages
	slls	r0,6			:multiply by 128/2 = 64
	cr	r0,r1			:which is our limiting factor
	jgfs	sup0b6			:limited by free circuits 
	lr	r1,r0			:limited by num of chns

SUP0B6	STH	R1,PTHRPD		:store # Passthrus reported available
	JAL	R9,WHWI			:tell the sup our conclusion
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP11:
::	FUNCTION:	REPORT HOST STATUS
::	CALLING SEQ:	JAL	R10,SUP11
::	INPUT:		R13 = HN = HOST # (NOT FOR GATEWAY)
::
::*********************************************************************

SUP11	LHL	R2,TVRBUF		:THE USUAL
	JER	R10
	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	IF	T2GATE			:GATEWAY SUP11 REPORT TO HNET
	LB	R1,HSTAT
	AHI	R1,1190			:Report as IIX Gateway
	ELSE
        LB      R4,HSTATN,HN            :get ORIG/DEST only bits        ###SDW
        SRLS    R4,1                    :move from bits 4,5 to 5,6      ###SDW
        NHI     R4,0C                   :mask off other bits            ###SDW
	LB	R1,HSTAT,HN		:STATUS BITS, MESS #
	AHI	R1,1180
        OR      R1,R4                   :and ORIG/DEST only bits        ###sdw
	EI	:T2GATE ##AL
	JAL	R9,WHWI
	IF	T2GATE			:GATEWAY RPT TO HNET
	LHL	R1,HOSTN		:ONLY ONE GW SLOT HOST
	ELSE
	LHL	R1,HOSTN,HN,HN		:HOST #
	EI	:T2GATE ##AL
	OHI	R1,8000			:PLUS 8000X
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP1A:
::	FUNCTION:	REPORT HOST STATUS IN NEW FORMAT FOR MXP SYSTEMS
::			INCLUDING MACHINE # AND SLOT #
::	CALLING SEQ:	JAL	R10,SUP1A
::	INPUT:		R13 = HN = HOST #
::	FORMAT:
::	[1A,STATUS] where STATUS is 8 bits long, STATUS = 100P CCXY
::		P = Proxy host
::		CC= collect-calls
::			00 = never accept collect-calls
::			01 = only accept collect calls
::			10 = leave the decision to the destination host
::			11 = unused
::		XY= Status
::			00 = answered
::			10 = shut
::			01 = down
::			11 = gone
::	[8080] - if LOGII then 1L001000 - Log2
::	[8000 + Host #]
::	[80 + MXP machine #, 80 + Host slot]
::*********************************************************************

SUP1A	LHL	R2,TVRBUF		:IS THERE A SUPERVISOR?
	JER	R10			:DON'T BOTHER IF NOT
	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LB	R1,HSTAT,HN		:STATUS BITS
	LB	R0,HSTAT3,HN		:Log2, Proxy, CC bits (1,3,4,5)	###wjl
	OR	R1,R0			:combine			###wjl
	AHI	R1,1A80			:+ MESSAGE NUMBER (NEW)
	JAL	R9,WHWI
	LHI	R1,8080			:FOR FUTURE USE
	JAL	R9,WHWI
	LHL	R1,HOSTN,HN,HN		:HOST NUMBER
	OHI	R1,8000			:SET 8000 BIT
        JAL     R9,WHWI			:###LH
	LB	R1,HSTKEY,HN		:GET SLOT# * 4 IF NON-MXP (00SS)
					:    SLOT#,MACHINE# IF MXP (00SM)
        IF      MXPNM			:IF MXP, CONVERT (00SM) TO (0M0S)
	EXBR	R0,R1			:R0 = (SM00)
        NHI     R0,0F00         	:R0 = (0M00)
        SRHLS   R1,4            	:R1 = (000S)
	OR	R1,R0			:R1 = (0M0S)
        ELSE	:not MXPNM		:IF NON-MXP, COMPUTE SLOT#
        SRHLS   R1,2	           	:(TRUE SLOT#, NOT SLOT# * 4)
        EI      :MXPNM
	OHI	R1,8080			:SEND SLOT# (00SS) + 8080 IF NON-MXP
	                               	:SEND MACHINE#,SLOT# (0M0S) + 8080 IF
        	                       	:MXP MACHINE			###LH
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUPHS:
::	FUNCTION:	SEND HOST STATUS REPORT TO SUP WHICH MAY
::			CONTAIN HIQ, HID DATA.
::	CALLING SEQ:	JAL	R10,SUPHS
::	INPUT:		R4  = HID
::			R13 = HOST #
::			R14 = MESSAGE HEADER
::
::*********************************************************************

SUPHS	LHL	R2,TVRBUF		:IS THERE A COMMAND CIRCUIT?
	JER	R10			:NO
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI			:IDENTIFY OURSELVES
	LR	R1,R14
	JAL	R9,WHWI			:SEND MESSAGE HEADER
	LHL	R1,HOSTN,HN,HN
	OHI	R1,8000			:HOST NUMBER + 8000
	JAL	R9,WHWI
	LR	R1,R4
	JER	R10			:NO HID, DONE WITH MESSAGE
	OHI	R1,8000
	JAL	R9,WHWI			:HID + 8000
	JR	R10			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SUP12:
::	FUNCTION:	REPORTS TO SUP'S LOG.
::	CALLING SEQ:	JAL	R10,SUP12
::	DESTROYED:	R0, R1, R2, R3, R8, R9
::
::*********************************************************************

:	COMMAND CIRCUIT EXISTS IF TVRBUF<>0 (TVRBUF CONTAINS COMMAND CIRCUIT
:	BUFFER INDEX) AND AN ENTRY IN LIOTAB MATCHES IT (TVRBUF MAY BE
:	NON-ZERO IF UPSTREAM LINK JUST WENT OUT AND LEP HAS NOT YET
:	PROCESSED THE ZAPPER FROM TRLINK). IF THERE IS NO COMMAND CIRCUIT,
:	TEST FOR LINE DIAGNOSTIC MESSAGE, CHARACTERISED BY THE 8000 BIT
:	SET IN SUPMBF. IF NOT A LINE DIAGNOSTIC, STORE REPORT TO LOG IN
:	'NCCBUF' BUFFER TO BE SENT TO SUP FOLLOWING NODE'S TAKEOVER.

SUP12	LHL	R2,TVRBUF		:GOT A COMMAND CIRCUIT?
	JEFS	SUP12B			:NO
	LHI	R1,NLQ-1		:MAYBE - SEE IF ANY LEP P.T. ENTRIES
:	ARE EQUAL TO THE CONTENTS OF TVRBUF, AND THEREFORE POINT TO ACTIVE SUP
SUP12A	LHL	R0,LIOTAB,R1,R1
	NHI	R0,-4
	CR	R0,R2			:UPSTREAM POINTER?
	JEFS	SUP12C			:YES - GOT A COMMAND CIRCUIT
	SIS	R1,1
	JGEBS	SUP12A			:KEEP CHECKING

:	NO COMMAND CIRCUIT PRESENT...
SUP12B	LH	R2,SUPMBF		:IS THIS A LINE DIAGNOSTIC?
	JLR	R10			:YES, RETURN
	LIS	R2,NCCBUF		:NO - STORE TYPE 12 MSG IN TEMP BUFFER
SUP12C	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LHI	R1,1280
	JAL	R9,WHWI
	LHL	R1,SUPMBF
	JAL	R9,WHWI			:48 BITS OF MESSAGE
	LHL	R1,SUPMBF+2
	JAL	R9,WHWI
	LHL	R1,SUPMBF+4
	JAL	R9,WHWI

:	FORMAT CRYPTOGRAM FOR XRAY LOG
SUP12D	LHL	R4,SUPMBF		:GET NODE REPORT TYPE
	CLHI	R4,NRMPNE		:DO WE WANT TO SEND CRYPTOGRAM?
	JG	NRCREX			:NO - EXIT
	SLLS	R4,2
	LH	R1,NRMPTB-4,R4		:GET MAPPING ENTRY
	JL	NRCREX			:NO FORMATTING DESIRED
	LB	R1,NRFMTB-1,R1		:GET MAPPING ARRAY ADDRESS
NRCR10	LB	R8,NRMPBS,R1		:GET SOURCE DISPLACEMENT
	JEFS	NRCR20			:DONE WITH THIS CRYPTOGRAM
	LB	R9,NRMPBS+2,R1		:GET MASK
	LB	R3,SUPMBF,R8		:GET SOURCE BYTE AND
	NR	R3,R9			:MASK OUT UNWANTED BITS
	LB	R9,NRMPBS+1,R1
	STB	R3,CRYSBF,R9		:STORE FOR CRYPTOGRAM
	AIS	R1,3
	JBS	NRCR10
NRCR20	LHL	R1,NRMPTB-2,R4		:GET CRYPTO NUMBER AND MESSAGE FLAGS
	L	R0,CRYSBF+4
	JAL	R8,CRYPT1,,		:SEND CRYPTOGRAM
NRCREX	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	TABLE:		NRMPTB
::	FUNCTION:	DEFINE MAPPING BETWEEN NODE REPORTS AND CRYPTOGRAMS
::
::*********************************************************************

:	EACH ENTRY IS 2 HALFWORDS LONG, WITH A FORMAT VALUE AND A CRYPTO VALUE.
:	BOTH ENTRY FIELDS ARE -1 IF NO CRYPTOGRAM IS TO BE GENERATED.
:	THE FORMAT VALUE PROVIDES AN INDEX INTO THE 'NRFMTB' TABLE WHICH
:	DIRECTS THE FORMATTING OF CRYPTOGRAMS BASED ON THE DATA IN THE NODE
:	REPORT. THE NRMPTB ENTRIES ARE ORDERED BY NODE REPORT NUMBER.
:
:	Six DIFFERENT MAPPINGS OF SUP DATA TO CRYPTO DATA ARE OFFERED.
:	FOR REFERENCE, THE SUP12 ROUTINE EXPECTS up to 4 HW OF DATA IN SUPMBF.
:	THESE ARE REFERRED TO AS SUP HW0 TO SUP HW3. CRYPT1 EXPECTS UP
:	TO 4 HW STARTING AT CRYSBF. THESE ARE REFERRED TO AS CRY HW0 TO
:	CRY HW3.
:
:	SUPMBF HW0 contains NR.### and is preceeded by 1280.
:	SUPMBF HW1 and HW2 contain data for the Sup as explained below.
:	SUPMBF HW3 may contain additional data for CRYPTO message.
:	CRYSBF contains data in the following order: HW2 HW3 HW0 HW1 !!
:
:	CRYPTO Equate Codes indicate which HW's contain data.  For example,
:	a code of 5 (0101) indicates HW1 and HW3 contain data.
:
:	MAPS 1 AND 5 ARE BOTH USED FOR A CRYEXX CODE OF 5. THE REASON IS 
:	THAT CRY HW3 IS RESERVED FOR EITHER NEIGHBOR NUMBERS OR HOST NUMBERS
:	TO PROVIDE FOR FUTURE SCAN FUNCTIONS FOR A SPECIFIED NEIGHBOR OR
:	HOST. THE NODE REPORT CONVENTION HAS BEEN TO PUT THE NEIGHBOR
:	NUMBER IN SUP HW1 AND THE HOST NUMBER IN SUP HW2 FOR THE VARIOUS
:	DIFFERENT NODE REPORTS. THEREFORE, MAPS 1 AND 5 REVERSE THE FORMATTING
:	OF THOSE TWO FIELDS.
:
:	MAP 1:	SUP HW1 -> CRY HW3	CRYEXX CODE 5XXX
:		SUP HW2 -> CRY HW1
:
:	MAP 2:	SUP HW1 -> CRY HW0	CRYEXX CODE CXXX
:		SUP HW2 -> CRY HW1
:
:	MAP 3:	SUP HW1 -> CRY HW3	CRYEXX CODE 3XXX
:		SUP HW2 -> CRY HW2
:
:	MAP 4:	SUP HW1 -> CRY HW3	CRYEXX CODE 7XXX
:		SUP HW2 -> CRY HW1	:###wjl
:		SUP HW3 -> CRY HW2	:###wjl
:
:	MAP 5:	SUP HW1 -> CRY HW1	CRYEXX CODE 5XXX
:		SUP HW2 -> CRY HW3
:
:	MAP 6:	SUP HW1 -> CRY HW0	CRYEXX CODE CXXX
:		SUP HW2 -> CRY HW1	(SAME AS MAP 2 EXCEPT NO MASKING OF
:					 HI-ORDER BIT)

NRMPTB	HC	1,CRYE5F	:1 - CHANNEL IN USE
	HC	-1,-1		:2 - DATA ON UNASSIGNED CHANNEL
	HC	4,CRYE60	:3 - BUFFER ZAP
	HC	-1,-1		:4 - REMOVE NEIGHBOR RESPONSE
	HC	-1,-1		:5 - ADD NEIGHBOR RESPONSE
	HC	1,CRYE22	:6 - LINK BUBBLE
	HC	1,CRYE21	:7 - LINK SHRINK
	HC	3,CRYE68	:8 - OUT OF PERMUTER TABLE SPACE
	HC	3,CRYE69	:9 - OUT OF LINK DESCRIPTOR SPACE
	HC	4,CRYE4D	:0A- LINK OUT PLI COUNT
	HC	5,CRYE1C	:0B- OUT OF DISPATCHER PORTS
	HC	5,CRYE61	:0C- NEEDLE REJECTED BY SLOT OUT OF PORTS
	HC	5,CRYE62	:0D- IMPOSTER HOST
	HC	-1,-1		:0E- CIRCUIT LIFETIME
	HC	1,CRYE39	:0F- LINK SNIP
	HC	-1,-1		:10- DIAGNOSTIC REPORT
	HC	1,CRYE0A	:11- NO NEIGHBOR
	HC	1,CRYE26	:12- INVALID MACHNM ON COMMAND CIRCUIT
	HC	2,CRYE27	:13- INVALID COMMAND ON COMMAND CIRCUIT
	HC	2,CRYE34	:14- CIRCUIT ERRORS
	HC	2,CRYE35	:15- CIRCUIT INCONSISTENCIES
	HC	1,CRYE51	:16- LINK FROZEN
	HC	1,CRYE52	:17- LINK THAWED
	HC	4,CRYE4E	:18- COMMAND CIRCUIT PLI'S
	HC	-1,-1		:19- NODE CRASH REPORT
	HC	-1,-1		:1A- REPORT SIO, SYNC, XLINKS, NLINKS
	HC	-1,-1		:1B- REPORT PORTS, PASSTHROUGHS
	HC	-1,-1		:1C- REPORT UNUSED LINES
	HC	-1,-1		:1D- LINE/LINK REPORT
	HC	2,CRYE58	:1E- SLOT REPORT LIMIT EXCEEDED
	HC	5,CRYE5B	:1F- INVALID HOST FOR RESTRICTED NODE
	HC	5,CRYE5A	:20- SLOT/HOST CIRCUIT LIMIT EXCEEDED
	HC	-1,-1		:21- CNT OF CIRCUITS ZAPPED DUE TO DLOAD OR BT
	HC	2,CRYE5E	:22- INVALID 03-CHAR PAIR ON COMMAND CIRCUIT
	HC	2,CRYE56	:23- MAC ERROR, SOFT FAILURE
	HC	2,CRYE55	:24- 56KB DIAGNOSTIC - CCW CHAINING TIMEOUT
	HC	2,CRYE58	:25- DATA ON IDLE TYMSAT PORT
	HC	1,CRYE5C	:26- INVALID 03-CHAR PAIR ON T-I CMND CIRCUIT
	HC	1,CRYE5D	:27- T-I SUP RECORD WITH INVALID LENGTH
	HC	2,CRYE57	:28- DMA HARDWARE TIMEOUT CAUSED MAC INTERRUPT
	HC	5,CRYE64	:29- KERNEL PORT ZAP FAILED
	HC	-1,-1		:2A- FIRST ADDENDUM TO CRASH REPORT
	HC	-1,-1		:2B- 2ND ADDENDUM TO CRASH REPORT
	HC	-1,-1		:2C- REPORT KERNEL HOST NUMBER
	HC	-1,-1		:2D- SQFIX ERROR
	HC	-1,-1		:2E- TEMPERATURE OUT OF RANGE
	HC	2,CRYE75	:2F- NETID MISMATCH			###wjl
	HC	2,CRYE76	:30- WSIZ MATCH DOWN			###wjl
	HC	2,CRYE77	:31- XRAY NETID MOD			###wjl
NRMPNE	EQ	(.-NRMPTB)/4	:NUMBER OF NRMPTB ENTRIES

::*********************************************************************
::
::	TABLE:		NRMPBS
::	FUNCTION:	SET OF MAPPING ARRAYS TO CONSTRUCT CRYTPOGRAMS
::			FROM NODE REPORTS.
::
::*********************************************************************

:	EACH MAP CONSISTS OF 3-BYTE ELEMENTS, FOR BYTE-BY-BYTE FORMATTING.
:	THE FIRST BYTE IS THE SOURCE ADDRESS, RELATIVE TO SUPMBF.
:	THE SECOND BYTE IS THE DESTINATION ADDRESS, RELATIVE TO CRYSBF.
:	THE THIRD BYTE IS A MASK, SINCE MANY NODE REPORT FIELDS ARE OR'D WITH
:	8000 TO PREVENT NETWORK ESCAPES.

NRMPBS	HS	0		:BASE ADDRESS FOR MAP ENTRIES.

NRMP01	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 01

NRMP02	EQ	.
	BC	2,4,7F
	BC	3,5,0FF
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 02

NRMP03	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	4,0,7F
	BC	5,1,7F
	BC	0		:END OF MAP 03

NRMP04	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	6,0,0FF		:###TZ
	BC	7,1,0FF		:###TZ
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 04

NRMP05	EQ	.
	BC	2,6,7F
	BC	3,7,7F
	BC	4,2,7F
	BC	5,3,0FF
	BC	0		:END OF MAP 05


NRMP06	EQ	.
	BC	2,4,0FF
	BC	3,5,0FF
	BC	4,6,0FF
	BC	5,7,0FF
	BC	0		:END OF MAP 06

::*********************************************************************
::
::	TABLE:		NRFMTB:
::	FUNCTION:	POINTS TO FORMAT ACTION ARRAY
::			INDEXED BY FORMATTING TYPE
::
::*********************************************************************

NRFMTB	HS	0
	BC	NRMP01-NRMPBS
	BC	NRMP02-NRMPBS
	BC	NRMP03-NRMPBS
	BC	NRMP04-NRMPBS
	BC	NRMP05-NRMPBS
	BC	NRMP06-NRMPBS
	HS	0

::*********************************************************************
::
::	SUBROUTINE:	SUP12L:
::	FUNCTION:	FORMAT LINK BUBBLE/SHRINK NODE REPORT
::
::*********************************************************************

SUP12L	STH	R0,SUPMBF		:ENTERED WITH REPORT TYPE IN R0
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	LHL	R0,NCHN,KD
	OHI	R0,8000
	STH	R0,SUPMBF+4		:CURRENT # OF CHANNELS IN HW3
	ST	R10,RTMT1
	JAL	R10,SUP12,,		:SHIP REPORT TO SUPERVISOR
	L	R10,RTMT1		:RESTORE LINK REG..
	JR	R10			:..AND RETURN

::*********************************************************************
::
::	SUBROUTINE:	NETDGN:
::	FUNCTION:	FORMAT DIAGNOSTIC CRYPTOGRAMS AND NODE REPORTS.
::	CALLING SEQ:	JAL	R9,NETDGN
::	INPUT:		R8 = DIAGNOSTIC SUB-TYPE
::
::*********************************************************************

:	THROTTLE REPORTING IN CASE PATHOLOGICAL CONDITION...
NETDGN	LHI	R0,NR.DGN
	AM	R0,NETDCT		:SHOULD WE THROTTLE DIAGNOSTIC REPORT?
	JGR	R9			:YES - ENOUGH THIS MINUTE

	STH	R0,SUPMBF		:STORE NODE REPORT TYPE
	L	R0,SUPMBF+2		:SET UP R0 FOR CRYPTO (LAST 3 BYTES OF
					:NODE REPORT ALSO USED AS CRYPTO DATA)
	STB	R8,SUPMBF+2		:STORE DIAGNOSTIC SUB-TYPE
	NHI	R8,NTDRTS/4-1		:INSURE VALID VALUE		###wjl
	SLLS	R8,2			:FW indexing			###wjl
	L	R10,NTDRTN,R8,		:GET SUB-TYPE ROUTINE ADDRESS	###wjl
	JR	R10			:DISPATCH			###wjl

NTDSYM	JAL	R8,CRYPTO,,
	HC	CRYE30			:SYNC SCAN ERROR
	J	NTDSNR

NTDSIO	NI	R0,0FFFFFF		:strip out diagnostic sub-type	###wjl
	JAL	R8,CRYPTO,,
	HC	CRYE32			:SIO BUFFER COUNT ERROR
	JFS	NTDSNR

NTDSBZ	NI	R0,0FF0000		:STRIP OUT NEIGHBOR NUMBER
	SRLS	R8,2			:r8 was shifted for the table lookup
	AR	R0,R8			:PUT IN REASON FOR TIMEOUT
	JAL	R8,CRYPTO,,		:M-BOARD TIMEOUT
	HC	CRYE33
	JFS	NTDSNR

NTDSNR	ST	R9,NTDRET
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP
	L	R9,NTDRET		:RESTORE LINK REG AND
	JR	R9			:RETURN

NTDOPS	JAL	R8,CRYPTO,,
	HC	CRYE31			:OOPS - INVALID CALLING ARGUMENT IN R8
	JR	R9


::*********************************************************************
::
::	TABLE:		NTDRTN
::	FUNCTION:	HANDLER ROUTINES, BASED ON SUB-TYPE
::
::*********************************************************************

NTDRTN	WC	NTDSYM,NTDSIO,NTDSBZ,NTDSBZ
	WC	NTDSBZ,NTDSBZ,NTDOPS,NTDOPS
NTDRTS	EQ	.-NTDRTN		:TABLE SIZE

::*********************************************************************
::
::	SUBROUTINE:	SUP13:
::	FUNCTION:	INDICATES CHANGES IN LINK CONDITIONS
::	CALLING SEQ:	JAL	R10,SUP13
::	INPUT:		R4  =  MESSAGE TYPE
::			R14 = LN
::			R15 = KD
::
::*********************************************************************

SUP13	LHL	R2,TVRBUF		:IS THERE A SUP?
	JER	R10
	ST	R4,YAKT1
	LHI	R1,8000+MACHNM
	JAL	R9,WHWI
	LR	R1,R4
	JAL	R9,WHWI
	EXBR	R1,LN
	SRHLS	R1,1
	OHI	R1,8000
	LB	R0,KSPD,KD
	AR	R1,R0
	JAL	R9,WHWI
	LHL	R1,NDID,KD
	OHI	R1,8000
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP14:/SUP14A:
::	FUNCTION:	GENERAL AND SUNDRY MISCELLANEA
::	REGISTER USAGE:
::		R1 - SOURCE OF ACCOUNTING (IF SUBTYPE = 89x)
::			0 FOR NODE CODE, 4 FOR DISPATCHER OR TYMSAT.
::			ALSO USED FOR WCI DATA
::		R2 - SUP BUFFER # (IF SUP IS PRESENT) SUPPLIED BY THIS RTN
::		R3 - SCRATCH, USED BY WCI
::		R4 - PRESERVED.  USED FOR CURRENT 7--- ACCT. RECORD
::		R5 - SUB-TYPE, PROVIDED BY CALLING ROUTINE
::		R6 - LENGTH OF DATA IN HW'S (2 MAXIMUM)
::		R8 - LINK FROM WHWI TO WCI
::		R9 - LINK TO WHWI
::		R10- LINK TO THIS ROUTINE
::
::*********************************************************************

:	SUP14A:
:	ENTRY POINT FOR NODE CODE GENERATED ACCOUTING MESSAGE TO SUP.
:	ENTERED WITH FIRST 2 HALFWORDS ACCOUNTING DATA IN R1.
:	for accounting msgs the logic is not obvious.  when it gets an
:	invoice number it just remembers it.  the invoice number is not
:	sent until accounting data arrives.  Thus, it has to note the source
:	of the accounting data between internal to NC or from dispatcher.

SPTP14	EQ	1400			:sup msg type 14, subtype field empty
NCACCT	EQ	89			:node code generated accounting msg

SUP14A	ST	R1,SUPMBF		:HW1, HW2 OF ACCOUNTING MSG
	LHI	R5,NCACCT		:INDICATE ACCOUNTING MESSAGE,
	LIS	R1,0			:GENERATED BY NODE CODE,
	LIS	R6,2			:2 HALFWORDS LONG

SUP14	ST	R4,YAKT1		:PRESERVE R4
	CLHI	R5,NCACCT		:ACCOUNTING MESSAGE?
	JN	SUP14B			:NO, CONTINUE "NORMALLY"
	LB	R8,SUPMBF		:GET ACCOUNTING DATA TYPE
	NHI	R8,00F0			:GET HIGH ORDER NIBBLE
	CLHI	R8,0070			:TYPE 07?  (CHANGE INVOICE #)
	JE	SUP14C			:YES

:	ACCOUNTING DATA RECEIVED
	THI	R1,0FFFB		:TYPE OF CALL = 0 OR 4 ?
	JEFS	SUP14E			:YES, OK
	CRASH.(.SUPCR)
:	here when have acounting data so send the invoice number if needed.
SUP14E	LB	R8,ACTLST		:WITH LAST 7--- ISSUED
	STB	R1,ACTLST		:(SAVE CURRENT SOURCE AS OLD SOURCE)
	L	R4,ACT7LO,R1		:COMPARE LAST 7--- OF THIS TYPE
	C	R4,ACT7LO,R8
	JNFS	SUP14K			:not eqaul, send invoice
	L	R4,ACT7HI,R1		:COMPARE LAST 7--- OF THIS TYPE
	C	R4,ACT7HI,R8
	JE	SUP14B			:totally the same, no need to send it

:	invoices NOT EQUAL, SEND LAST 7--- OF THIS TYPE, AND DATA REC.
SUP14K	LHL	R2,TVRBUF		:SUP?
	JE	SUP14F			:NO, EXIT
	L	R4,ACT7LO,R1		:first send LSF
SUP14I	LHI	R1,8000+MACHNM		:SEND NODE #
	JAL	R9,WHWI
	LHI	R1,SPTP14+NCACCT	:ACCOUNTING MESSAGE SUB-TYPE
	JAL	R9,WHWI
	EXHR	R1,R4			:GET FIRST HALF OF 7--- RECORD
	JAL	R9,WHWI
	LHR	R1,R4			:SECOND HALF
	JAL	R9,WHWI
SUP14J	LB	R8,ACTLST		:now send LSF 24 bits
	C	R4,ACT7HI,R8		:did we just send the high field?
	JE	SUP14D			:done with invoice, now send the data
	L	R4,ACT7HI,R8		:just sent LSF, now send MSF
	JE	SUP14D			:no MSF so now send the data
	J	SUP14I			:high inequals low as differ msg types

:	here if this is an invoice number for accounting
SUP14C	lb	r8,supmbf		:check if this is a multiple precision
	nhi	r8,0f			:get the indication of multiple prec
	je	sup14m			:not multiple precision
	sis	r8,0e			:0e is the least significant field
	jefs	sup14n
	jg	sup14p
:	got an illegal accounting msg die now is better than dying later after
:	providing a lifetime of free service (messed up accounting)
	crash.(.sup14)

:	here if not a multiple precision so clear out high field
sup14m	lis	r8,0
	st	R8,ACT7HI,r1		:no high message waiting to be sent
:	here for low 24 bits of multiple precision or 24 bits of single prec
sup14n	L	R8,SUPMBF		:GET NEW ACCT MESSAGE
	C	R8,ACT7LO,R1		:= LAST ONE OF THIS TYPE?
	JE	SUP14F			:YES, REDUNDANT MSG, SKIP IT
	ST	R8,ACT7LO,R1		:SAVE 7---
	CLB	R1,ACTLST		:IF THIS 7--- IS FROM THE SAME SOURCE
	JN	SUP14F			:AS THE LAST ONE, WE MUST SET IT TO
	LIS	R8,8			:SOMTHING DIFFERENT OR IT MAY NOT
	STB	R8,ACTLST		:BE SENT
	J	SUP14F			:RESTORE R4 AND EXIT
:	here to handle most significant 8 bits of multiple precision
sup14p	L	R8,SUPMBF		:GET NEW ACCT MESSAGE
	C	R8,ACT7HI,R1		:= LAST ONE OF THIS TYPE?
	JE	SUP14F			:YES, REDUNDANT MSG, SKIP IT
	ST	R8,ACT7HI,R1		:SAVE 7---
	CLB	R1,ACTLST		:IF THIS 7--- IS FROM THE SAME SOURCE
	JN	SUP14F			:AS THE LAST ONE, WE MUST SET IT TO
	LIS	R8,8			:SOMTHING DIFFERENT OR IT MAY NOT
	STB	R8,ACTLST		:BE SENT
	J	SUP14F			:RESTORE R4 AND EXIT

					:(entry for Gateway
GSP14H	lis	r6,2			:always want that subtype
SUP14B	LHL	R2,TVRBUF		:SUP PRESENT? 
	JER	R10			:host cost report to H-net)
SUP14D	LHI	R1,8000+MACHNM
	JAL	R9,WHWI
	LHI	R1,SPTP14		:sup msg type 14, empty subtype field
	AR	R1,R5			:R5 CONTAINS SUBTYPE
	JAL	R9,WHWI
	LHL	R1,SUPMBF  
	JAL	R9,WHWI
	SIS	R6,1
	JLEFS	SUP14F
	LHL	R1,SUPMBF+2
	JAL	R9,WHWI
SUP14F	L	R4,YAKT1
	JR	R10

	ENDMO.(LOGSUP)

	EI	:1-KILLIT

	KILMSG(LOGSUP)

:	***NOTHING PAST THIS POINT***

	SUBTTL	LEP

:			*     ***** ****
:			*     *     *   *
:			*     ****  ****
:			*     *     *
:			***** ***** *

::#####################################################################
::
::	MODULE:		LEP
::
::	FUNCTION:	SUPERVISOR TO NODE COMMANDS
::
::	SUBTTLS:
::		LEP08 - Takeover command
::		LEP09 - Circuit building command
::		LEP0A - LOG II Circuit building command
::		LEP0B - Circuit trace request
::		LEP0C - Sleeping pills
::		LEP0D - Message for ports in login mode
::		LEP0E - Aux circuit message
::		LEP0F - General supervisor commands
::		LEP10 - Port status request
::		LEP11 - Assign channel to TYMNET-I
::		LEP12 - LOG II message for port in login mode
::		LEPZAP - Handle command circuit zapper
::		LEP utilities and tables
::
::#####################################################################

	IF 	1-KILLIT	
	BEGMO.
	SEG	a.code

::*********************************************************************
::
::	SUBPROCESS:	LEP:
::	FUNCTION:	Process data on a command channel.
::	SCHEDULED:	Runs off SWITCH exec loop, based on data being
::			received on a command channel.  If sup base then
::			called after getting a msg for the sup.
::
::*********************************************************************

lepxit	l	r10,lepsvt		:get caller
	jr	r10			:exit lep

:	TYMNET-II LEPRECHAUN
LEP	st	r10,lepsvt		:save address of caller
	lhl	r4,lepflg,,
	jffoh	r4,lep001
	jbs	lepxit
lep001	LHL	R2,LIOTAB,chn,chn	:GET BUFF #
	NHI	R2,-4
	XHI	R2,4
	STH	R2,LEPINB		:SAVE IT

:	ENTRY POINT - RETURN FROM PROCESSING COMMAND
LEP1	LHL	R2,LEPINB		:RETREIVE BUFFER #
	L	R3,BB,R2,		:PEEK AT BYTE COUNT
	JE	lepxit			:BUFFER EMPTY
	JAL	R8,PCI			:SKIP LEADING 0
	CLHI	R1,3			:TEST FOR 03-PAIR (ONLY ZAPPERS)
	JE	LEPZAP			:ZAP SUP CIRCUIT IF IT IS

:	following handles new variable size len fields			###sdw
:       have 3 possible length variations.
:       00 xx for shorter messages where xx is 6 or greater
:       00 yy 00 xx where yyxx is overall length and yy is less than 6
:       yy 00 xx (yy is bigger than 3 to not be a network signal)

	JL	LEP1.0			:otherwise 1st byte is high byte of len
	LR	LRC,R1
	EXBR	LRC,LRC 		:put into high byte
	J	LEP1.5
LEP1.0	LIS	LRC,0			:clear so AR works for 1 byte of len
	JAL	R8,PCI			:get second byte of len
	CLHI	R1,6			:if 2nd byte<6 then it is high byte
	JGEFS	LEP1.6			:we have all of len
	LR	LRC,R1
	EXBR	LRC,LRC 		:put high byte into high byte
LEP1.5	JAL	R8,PCI
	JAL	R8,PCI			:ACTUAL BYTE CNT
LEP1.6	AR	LRC,R1			:SAVE IT
	JAL	R8,CBCCT		:CNT OF CHARS IN BUFF
	CLHI	R1,6			:NEED AT LEAST 6 CHARS IN BUFF
	JL	lepxit
	CR	R1,LRC
	JL	lepxit			:EXIT IF ENTIRE MESS NOT IN BUFF

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LEPDB1,,
	LM	R0,REGST		:restore regs		###sdw
	LR	R5,LRC			:GET BYTE COUNT INTO R5
	JAL	R14,LEPDB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

:subsequent LEP command processing routines assume a length of two
:and subtract that from LRC.  We will subtract and extra byte
:for three byte length messages and an extra two bytes for four
:byte length messages
					:skip over variable length len ###shm
	JAL	R8,GCI			:check first byte
        LR      R1,R1
        JNFS    LEP1.7                  :first byte 0 (escape)
	JAL	R8,GCI			:yes get next byte
        CLHI    R1,6                    :if 2nd byte >= 6 we have all length
        JGEFS   LEP1.8                  :yes done
        SIS     LRC,1                   :sub one byte from lrc for 4 byte len
LEP1.7  SIS     LRC,1                   :sub one byte from lrc for 3&4!
        JAL     R9,GCIE                 :skip next byte and escape
LEP1.8		L	R3,BB,R2,		:PCI needs this
	JAL	R9,PHWI			:GET THE NODE #
	NHI	R1,7FFF
	CLHI	R1,MACHNM
	JN	LEPXMN			:ABORT IF INCORRECT NODE #
	JAL	R8,PCI			:GET THE MESSAGE TYPE
	SIS	R1,8			:DISPATCH
	JL	LEPXCM			:MSG TYPE OUT OF RANGE
	CLHI	R1,LEPDMX
	JGE	LEPXCM			:MSG TYPE OUT OF RANGE
	SLLS	R1,2			:FW indexing			###wjl
	L	R1,LEPDIS,R1,		:GET PTR FROM DISPATCH TYPE 	###wjl
	JR	R1			:AND GO EXECUTE			###wjl

:	ILLEGAL MACHINE NUMBER
LEPXMN	OHI	R1,8000
	STH	R1,SUPMBF+2		:SAVE ILLEGAL NODE # FOR NODE REPORT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R0,NR.XMN		:SET UP FOR NODE REPORT
	JFS	LEPXC2

:	INVALID COMMAND TYPE
LEPXCM	OHI	R1,8000
	AIS	R1,8			:REPLACE BIAS
	STH	R1,SUPMBF+2		:SAVE INVALID COMMAND FOR NODE REPORT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R0,NR.XCM
:	SEND NODE REPORT TO SUP
LEPXC2	STH	R0,SUPMBF		:NODE REPORT TYPE
	LH	R0,LEPXER
	AIS	R0,1			:INCREMENT COUNT OF LEP ERRORS
	STH	R0,LEPXER
	OHI	R0,8000
	STH	R0,SUPMBF+4		:INCLUDE COUNT IN NODE REPORT
	JAL	R10,SUP12		:SEND NODE REPORT
	J	LEPZA4			:OUTPUT CRYPTOGRAM AND EXIT

:	HANDLER ROUTINE FOR UNKNOWN MESSAGE TYPE FROM SUPERVISOR
LEPXT	LHI	R6,-2,LRC		:REMOVE THE COMMAND
LEPXT1	LHL	R0,BCT,R2,		:EXTRA CARE TAKEN FOR UNKNOWN COMMAND
	JE	lepxit			:TO AVOID GCI CRASHES
	JAL	R8,GCI
	SIS	R6,1			:MARK CHAR OF MSG OUT OF BUFFER
	JGBS	LEPXT1			:LOOP FOR NEXT ONE IF THERE IS ONE
	J	LEP1

	SUBTTL	LEP (LEP08 - Type 8:  Takeover command)

::*********************************************************************
::
::	COMMAND:	LEP08:
::	FUNCTION:	PROCESS TAKEOVER COMMANDS (TYPE 8)
::
::*********************************************************************

LEP08	HS	0
:	BEFORE PROCESSING TAKEOVER COMMANDS ON AN ISIS MACHINE, WE FIRST
:	NEED TO VERIFY THAT THE STATUS OF EACH HOST IS CORRECT.
	IF	(1-T2GATE)
	ST	R2,HSTSAV		:SAVE R2

	JAL	R7,CHKHST		:VERIFY THE STATUS OF ALL HOSTS
	L	R2,HSTSAV		:RESTORE R2
	EI	:(1-T2GATE)

:	START TO PROCESS TAKEOVER COMMANDS
	IF	T2GATE			:RPT TO INET SUP IF NESSARY
	LB	R1,G0DFG		:have INET supe?
	JEFS	LP081			:shut until have both supes ###sdw
	LIS	R3,0			:remember is answerred
	STB	R3,HSTAT		:TAKEOVER RESP. MAY RPT HSTAT
	JAL	R10,GHSTST,,
	EI	:T2GATE			:##AL
LP081	JAL	R9,GHWI			:TAKEOVER - GET NODE #

:	OLD SUP REQUIRES TYPE 09 TAKEOVER RESPONSE, NEWSUP TAKES TYPE 19
:	WHICH INCLUDES EXPANDED HOST INFORMATION
	LIS	R8,0			:ASSUME OLD TYPE SUP		###OAS
	THI	R1,8000			:CHECK FOR BIT 0 OF NODE NO. SET###OAS
	JNFS	LEP08S			:SET, OLD TYPE SUPERVISOR	###OAS
	LIS	R8,1			:NOT SET, FLAG AS NEW TYPE SUP	###OAS
LEP08S	STH	R8,NEWSUP		:STORE NEW SUP FLAG		###OAS

	JAL	R8,GCI			:DISCARD TYPE
	JAL	R8,GCI			:GET THE SUP #
       IF	LOGII
	LIS	R0,0			:init not LOG2 supe
	THI	R1,L2F.TK		:LogII supes have bit 2 set
	JEFS	LEP08L
	LIS	R0,1
LEP08L	STB	R0,NEWSUP		:mark it in first byte of newsup
       EI	:LOGII
	NHI	R1,0F			:four bits max for sup number
	LR	PRC,R1
	LHL	R2,TVRBUF		:GET BUFF TOWARDS OLD SUP
	JEFS	LEP08A			:NONE
	LHI	R1,MACHNM+8000		:SEND TAKEOVER NOTICE TO OLD SUP
	JAL	R9,WHWI
	LR	R1,PRC			:NEW SUP #
	AHI	R1,0A80
	JAL	R9,WHWI
LEP08A	LHL	R2,LIOTAB,CHN,CHN	:GET BUFF # (TOWARDS SUP)
	NHI	R2,-4
	STH	PRC,TVRSUP		:SAVE # OF CURRENT SUP
	STH	R2,TVRBUF		:AND UPSTREAM BUFF #

       IF	SUPWAT			: Sup-Watch?
	CLHI	PRC,MACHNM&7		: our own supe?
	JN	LEP08Y			: no
:	following is a fast way to zero out SUPNED, SUPCPI, SUPCPO, 
:	SUPREJ,SUPILC,SUPDLC,SUPDND,SUPIND.  It zeros last hw then
:	copies the whole array from hw to hw-2 and thus moves that
:	zero throughout the whole array.  storing word for each array
:	for 4000+ ports takes 36,000 instructions and not best to take
:	that time when about to do a takeover
	LIS	R0,0 			: clear Supe watch status
	sth	R0,supwen-2,,		: zero last hw of sup watch data
	LA	R0,supwen-2,,		: address of last hw of sup watch data
	LA	R1,supwen-4,,		: the halfword before that
	li	r8,10*((supwen-supwbg)/2-2) :number of bits to move
	copy	r0,r8
       EI	:SUPWAT
LEP08Y
:	CHECK FOR OLD OR NEW SUP (NEW SUP ACCEPTS EXPANDED HOST INFO)
	LHL	R1,NEWSUP		:CHECK FOR OLD OR NEW SUP	###OAS
	JN	LEP08T			:NEW SUP, FORM NEW TAKEOVER RESP###OAS

:	SEND TYPE 09 TAKEOVER RESPONSE TO OLD SUP
	LHI	R1,MACHNM+8000		:NOW SEND TAKEOVER RESPONSE
	JAL	R9,WHWI
	LR	R1,PRC			:SUP #
	AHI	R1,980
	JAL	R9,WHWI
	LH	R1,VERSSV+2,,		:VERSION
	JAL	R9,WHWI
	LH	R1,CRSHAD+2		:CRASH MARK
	JAL	R9,WHWI
	LB	R1,CRHCNT+1		:CRASH COUNT
	EXBR	R1,R1
	OHI	R1,8080			:(BOTH ARE "ESCAPED")
	AH	R1,NALINK		:...& # OF LINKS
	JAL	R9,WHWI
	L	R1,BE,R2,		:				###AL
	ST	R1,NALNKA		:STORE NALINK FLD. PTR ADDR.	###AL
	LHI	R1,80			:LEAVE ROOM FOR # OF HOSTS
	JAL	R8,WCI
	L	R0,BE,R2,		:SAVE PTR TO IT
	ST	R0,YAKT1
	JAL	R8,WCI			:FOLLOWING BYTE ALWAYS 80
	ts	pasthc			:indicate to do a sup0b report
	LHI	R1,NPASTH		:# OF PASSTHRUS
	SH	R1,PASTHR
	JGEFS	LEP810			:MAY BE <0 DUE TO SUP CIRCS
	LIS	R1,4
LEP810	JAL	R9,WHWI

	LIS	KN,0			:NEIGHBOR #'S
:: An additional ckeck for the number of active links and number of neighbors
:: to be matched in the takeover response. If not matched, report CRYPTO and
:: use number of active links as a correct number for both.		###AL
	LHI	R0,0			:				###AL
	STH	R0,TEMPHS		:ZERO THE NUMBER OF NBR COUNT	###AL
LEP08B	SLLS	KN,1
	L	KD,KDKN,KN,KN
	SRLS	KN,1
	LB	R0,NLAT,KD		:DON'T REPORT LINK IF INACTIVE
	JE	LEP08D			:				###wjl
	LH	R1,NDID,KD

	OHI	R1,8000
	JAL	R9,WHWI
LEP08X	LIS	R0,1			:				###AL
	AHM	R0,TEMPHS		:INC. TEMPHS			###AL
LEP08D	AIS	KN,1
	CLHI	KN,NLINKS
	JL	LEP08B
	LHL	R0,TEMPHS		:CHECK IF #NBRS MATCH NALINK	###AL
	CLH	R0,NALINK		:				###AL
	JE	LEP8CC			:IF OK DO NOTHING		###AL
	EXHR	R0,R0			:REPORT CRYPTO. HW0=#NBRS,HW1=NALINK
	AH	R0,NALINK
	JAL	R8,CRYPTO,,
	HC	CRYE74
	LH	R0,TEMPHS		:FORCE TO MATCH #NBRS=NALINK	###AL
	OHI	R0,80			:HO BIT SET IN FORMAT		###AL
	L	R1,NALNKA		:PREVIOUS FLD. ADDR SAVED	###AL
	STB	R0,,R1,			:				###AL
LEP8CC

	LIS	KN,0			:LINK SPEEDS
LEP08C	SLLS	KN,1
	L	KD,KDKN,KN,KN
	SRLS	KN,1
	LB	R0,NLAT,KD		:SKIP INACTIVE LINKS
	JEFS	LEP08E
	LB	R1,KSPD,KD
	OHI	R1,80
	JAL	R8,WCI
LEP08E	AIS	KN,1
	CLHI	KN,NLINKS
	JL	LEP08C

	LIS	HN,0			:HOST DATA
	LHI	R5,80			:TO COUNT HOW MANY HOSTS
LEP08G	LHL	R1,HOSTN,HN,HN		:HOST #
	JEFS	LEP08F			:NONE THERE
	AIS	R5,1
	AHI	R1,8000
	JAL	R9,WHWI
LEP08F	AIS	HN,1
	CLHI	HN,NHOSTS
	JL	LEP08G
	L	R1,YAKT1		:PUT AWAY HOST COUNT
	STB	R5,0,R1
	LIS	HN,0			:SEND STATUS BITS
	LIS	R1,1			:2 BITS/HOST IS DUMB!
LEP08J	LHL	R5,HOSTN,HN,HN		:read host entry
	JEFS	LEP08K			:nothing doing if no host there
	SLHLS	R1,2			:shift R1--make room for next status
	LB	R5,HSTAT,HN		:STATUS IS HI 2 BITS
	AR	R1,R5			:add status bits into the byte
	THI	R1,100			:test for overflow from byte
	JEFS	LEP08K			:branch until it is full
	JAL	R9,WCIE			:BYTE FULL -- write it into buffer
	LIS	R1,1			:reset register for next bunch of stati
LEP08K	AIS	HN,1			:increment pointer to next entry
	CLHI	HN,NHOSTS		:check for end of table
	JL	LEP08J			:there may be more hosts--keep looping
	CLHI	R1,1			:now check for remnants in R1
	JE	LEP08M			:if it's 1, no new info there
LEP820	SLHLS	R1,2			:left adjust any partials	###jhl
	THI	R1,100			:overflow means we're adjusted
	JEBS	LEP820			:keep shifting until overflow	###jhl
	JAL	R9,WCIE			:then write in the final byte of stati

	J	LEP08M

:	SEND TYPE 19 TAKEOVER RESPONSE TO NEW SUP (WITH EXPANDED HOST INFO)
LEP08T	LHI	R1,MACHNM+8000		:SET UP HEADER			###OAS
	JAL	R9,WHWI
	LR	R1,PRC			:GET SUPERVISOR NUMBER		###OAS
	AHI	R1,1980			:FORM NEW TAKEOVER RESP (19)	###OAS
	JAL	R9,WHWI

	LB	R1,CRHCNT+1		:GET CRASH COUNT		###OAS
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	OHI	R1,8080			:ESCAPE BOTH BYTES		###OAS
	AH	R1,NALINK		:AND COMBINE # OF LINKS		###OAS
	JAL	R9,WHWI
	L	R1,BE,R2,		:				###AL
	ST	R1,NALNKA		:STORE NALINK FLD. PTR ADDR.	###AL
	LIS	HN,0			:COUNT NUMBER OF HOSTS		###OAS
	LHI	R1,8000			:TO COUNT HOW MANY HOSTS	###OAS
LEPN8J	LHL	R5,HOSTN,HN,HN		:CHECK HOST TABLE FOR ENTRY	###OAS
	JEFS	LEPN8K			:NONE THERE, DON'T COUNT	###OAS
	AIS	R1,1			:HOST THERE, BUMP COUNT		###OAS
LEPN8K	AIS	HN,1			:BUMP HOST INDEX		###OAS
	CLHI	HN,NHOSTS		:EXCEEDED NUMBER OF ENTRIES	###OAS
	JL	LEPN8J			:NO, CHECK FOR MORE HOSTS	###OAS
	JAL	R9,WHWI			:ALL DONE, WRITE # HOSTS	###OAS

	LH	R1,VERSSV+2,,		:GET VERSION NUMBER		###OAS
	JAL	R9,WHWI	

	LH	R1,CSMTBL+CS.CID	:GET CRASH SUBTYPE,TYPE		###OAS
	JAL	R9,WHWI

	LHI	R1,8080+L2F.NC		:bit 1 says LOGII capable NC	###sdw
	JAL	R9,WHWI

	LHI	R1,NETID		:GET NODE'S NETWORK ID		###OAS
	JAL	R9,WHWI
	LHI	R1,NETMOD		:GET NODE'S NETWORK MODIFIER	###OAS
	JAL	R9,WHWI
	LHI	R1,SUBNET		:GET NODE'S SUBNET NUMBER	###OAS
	JAL	R9,WHWI

	ts	pasthc
	LHI	R1,NPASTH		:GET NUMBER OF POSSIBLE PASSTHRUS##OAS
	JAL	R9,WHWI
	LHI	R1,NPASTH		:COMPUTE AVAILABLE FROM TOTAL	###OAS
	SH	R1,PASTHR		:MINUS CURRENT PASSTHRUS	###OAS
	JAL	R9,WHWI

	LIS	KN,0			:BEGIN LINK CLUSTERS		###OAS
	LIS	R0,0			:INIT TEMPHS CNT FOR #NBRS	###AL
	STH	R0,TEMPHS		:				###AL	
LEPN8B	SLLS	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR		###OAS
	SRLS	KN,1
	LB	R0,NLAT,KD		:CHECK IF LINK ACTIVE		###OAS
	JE	LEPN8D			:NOT ACTIVE, DON'T REPORT	###OAS

	LH	R1,NDID,KD		:GET NEIGHBOR NO.		###OAS

	OHI	R1,8000
	JAL	R9,WHWI

	LHI	R1,0080
	JAL	R8,WCI			:SAVE FOR FUTURE USE AS LINK FLAGS#OAS
	LB	R1,KSPD,KD		:GET LINK SPEED/FLAGS		###OAS
	OHI	R1,0080
	JAL	R8,WCI
LEP08V	LIS	R0,1			:INC. TEMPHS CNT		###AL
	AHM	R0,TEMPHS		:				###AL
LEPN8D	AIS	KN,1			:BUMP LINK INDEX		###OAS
	CLHI	KN,NLINKS		:# LINKS EXCEEDED?		###OAS
	JL	LEPN8B			:NO, LOOK THROUGH MORE LINKS	###OAS
	LHL	R0,TEMPHS		:CHECK IF #NBRS MATCH NALINK	###AL
	CLH	R0,NALINK		:				###AL
	JE	LEP8GG			:IF OK DO NOTHING		###AL
	EXHR	R0,R0			:REPORT CRYPTO. HW0=#NBRS,HW1=NALINK
	AH	R0,NALINK
	JAL	R8,CRYPTO,,
	HC	CRYE74
	LH	R0,TEMPHS		:FORCE TO MATCH #NBRS=NALINK	###AL
	OHI	R0,80			:SET HO BIT IN FORMAT		###AL
	L	R1,NALNKA		:PREVIOUS FLD. ADDR SAVED	###AL
	STB	R0,0,R1			:				###AL

LEP8GG	LIS	HN,0			:BEGIN HOST CLUSTERS		###OAS
LEPN8G	LHL	R1,HOSTN,HN,HN		:CHECK HOST TABLE FOR HOST ENTRIES#OAS
	JE	LEPN8F			:NO HOST AT THIS ENTRY		###OAS

	LB	R1,HSTAT3,HN		:Log2, Proxy, and CC (bits 1,3,4,5)#wjl
	SLLS	R1,03			:r1= 0000 00l0 pcc0 0000		###sdw
	EXBR	R0,R1			:r0= pcc0 0000 0000 00l0
	SLLS	R0,3			:r0= 0000 0000 000l 0000
	OR	R1,R0			:r1= 0000 0000 PCCL 0000
	SLLS	R1,8			:r1= PCCL 0000 0000 0000	###sdw
	JAL	R9,WHWI
	LHL	R1,HOSTN,HN,HN		:RECOVER HOST NUMBER		###OAS
	JAL	R9,WHWI

:	PREPARE TO SEND SLOT NUMBER TO SUP				###LH
	LB	R1,HSTKEY,HN		:GET SLOT# * 4  IF NON-MXP  (00SS)
					:    SLOT#,MACHINE# IF MXP  (00SM)
	IF	MXPNM			:IF MXP, CONVERT (00SM) TO (0M0S)
	EXBR	R0,R1			:R0 = (SM00)
	NHI	R0,0F00 		:R0 = (0M00)
	SRHLS	R1,4			:R1 = (000S)
	OR	R1,R0		 	:R1 = (0M0S)
	ELSE	:NON-MXP, COMPUTE SLOT#
	SRHLS	R1,2			:(TRUE SLOT#. NOT SLOT# * 4)
	EI	:MXPNM
	OHI	R1,8080 		:SEND SLOT# (00SS) + 8080 IF NON-MXP
					:SEND MACHINE#,SLOT# (0M0S) + 8080 IF
					:MXP MACHINE			###LH
	JAL	R9,WHWI
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	IF	T2GATE
	OHI	R1,10			:For Gateway, always IIX	###ev
:	fixed above to OR in 10 (iix bit) from 80 (origination only bit)###sdw
	EI	:T2GATE
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	LB	R0,HSTCST,HN		:GET MULTI-TARGET HOST COST	###OAS
	OR	R1,R0			:COMBINE AND WRITE		###OAS
	JAL	R9,WHWI
	LB	R1,HSTMBK,HN		:GET MUTI-BASED HOST KEY	###OAS
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	IF	T2GATE
	LHI	R0,08B			:Gateway is prodid 8B		###ev
	ELSE
	LB	R0,HSTYPE,HN		:GET HOST TYPE (PID)		###OAS
	EI	:T2GATE
	OR	R1,R0			:COMBINE AND WRITE		###OAS
	JAL	R9,WHWI

LEPN8F	AIS	HN,1			:BUMP HOST INDEX		###OAS
	CLHI	HN,NHOSTS		:MORE HOST ENTRIES?		###OAS
	JL	LEPN8G			:YES, GO CHECK THEM		###OAS

:	FINISHED WITH TAKEOVER RESPONSE, NOW MAKE CRYPTO LOG ENTRY
LEP08M	LR	R0,PRC			:TELL XRAY
	JAL	R8,CRYPTO,,
	HC	CRYE05			:TAKEOVER

	TS	TAKOVR			:FOR DEFERRED TAKEOVER NODE REPORTS

	LIS	R0,0			:CLEAR SUP CHARACTER COUNTS
	ST	R0,SUPICC
	ST	R0,SUPOCC

	IF	(1-T2GATE)		:INFORM DISPATCHER (but not if Gateway)
	LHI	HN,NHOSTS		:TELL SUP OF ALL HOSTS OUT OF PORTS.
LEP08N	SIS	HN,1			:NEXT HOST
	JL	LEP08O			:DONE
	LHL	R0,HOSTN,HN,HN		:GET HOST #
	JEBS	LEP08N			:IF ZERO HE IS GONE
	LHL	R1,HSTPTA,HN,HN		:GET PORTS AVAILABLE
	JNBS	LEP08N			:NOT 0 PORTS, DON'T REPORT
	LIS	R6,1			:TELL SUP 1 HW
	STH	R0,SUPMBF		:SAVE HOST #
	LHI	R5,8F			:HOST OUT OF PORTS MSG
	JAL	R10,SUP14
	J	LEP08N			:CONTINUE

LEP08O	HS	0			:DONE WITH OUT OF PORTS REPORTING
       IF	1-NCSLOT 		:allow NC to run in a slot
	LIS	R0,4
	JAL	R8,DIROOM		:WAIT FOR ROOM
	LHL	PRD,DRIF,,
	LHI	R0,INTKVR^8		:PORT 0 TAKEOVER MESS		###jhl
	AH	R0,TVRSUP		:INCLUDE SUP # IN 'UNUSED' MSG BYTE
       IF	LOGII			:LOG2 supes are reported as 80+num
	LB	R1,NEWSUP		:where we put LOG2 capable indication
	JEFS	LEPL8O
	AHI	R0,L2F.DK		:tell dispathcer LOG II takevoer
       EI	:LOGII
LEPL8O	ST	R0,DIRNG,PRD,
	AIS	PRD,4
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,
       EI	:1-NCSLOT
	EI	:(1-T2GATE)		:###EV
	LHL	R0,BCT+4,,		:ANY PORTS IN LOGIN MODE (IN BUFFER 4)?
	JEFS	LEP08P			:NO
	STH	R0,LOGZPF		:YES, TELL LOGGER TO ZAP THEM ALL

LEP08P	LIS	R6,NCCBUF
	LR	R7,R2
LEP08Q	LHL	R0,BCT,R6,		:ANY DATA IN TEMP STORAGE BUF?
	JEFS	LEP08R			:NO,MAKE KHOST REPORT,PERHAPS CRASH RPT
	LR	R2,R6
	JAL	R8,GCI			:COPY DATA FROM TEMPORARY BUFFER
	LR	R2,R7
	JAL	R8,WCI			:TO NEW COMMAND CIRCUIT BUFFER
	JBS	LEP08Q
LEP08R	LHI	R3,HST0			:GET KERNEL HOST NUMBER
	JAL	R9,HEXDEC,,		:GO DECIMAL
	STH	R3,SUPMBF+2		:AND STORE AWAY
	LHI	R3,VERSIO		:GET VERSION NUMBER
	JAL	R9,HEXOCT,,		:GO OCTAL
	STH	R3,SUPMBF+4		:AND STORE AWAY
	LHI	R3,NR.HVR		:REPORT KERNEL AND VERSION NUMBER
	STH	R3,SUPMBF
	JAL	R10,SUP12
	IF	T2GATE
	LHl	R0,HCOSTh		:Get current cost
	LHI	R1,HHOST		:and H-net host #
	EXHR	R1,R1
	AR	R1,R0			:Make sup message content
	ST	R1,SUPMBF		:and store in sup mesage buffer
	LHI	R5,NCHCST		:Get message subtype 88
	JAL	R10,GSP14H		:and send it to sup
	LB	R1,HSTAT		:have to explicity say shut
	JEFS	LEP9TG			:(shut if no INET supe)
	JAL	R10,SUP11
LEP9TG	HS	0
	EI	:T2GATE
	TS	CREPRT			:CRASH REPORT ALREADY MADE?
	JL	LPCR401			:YES - don't report crash

:	REPORT CRASH WITH:
:	NODE REPORT node# TYPE 19 aabbbbbb
:	where:
:		19 - Node crash report
:		aa = crash reason code
:	    bbbbbb = crash address
:
:	FOLLOWED BY CRASH ADDENDUM REPORT1:
:	NODE REPORT node# TYPE 2A aabbccdd
:	where:
:		2A - First addendum to the node crash report
:		aa = Crash code extension
:		bb = Current crash count
:		cc = Node code version number + 80
:			<0=SWITCHER, 1=ISIS, 2=TYMSAT, 3=GATEWAY>
:		dd = 0	<80 + NO. OF ADDITIONAL CRASH ADDENDUM REPORTS
:			 (TYPE 2B) TO FOLLOW.>
:
:	FOLLOWED BY 0-2 CRASH ADDENDUM REPORTS (CONTENTS OF CRITICAL REGISTERS)
:		(not implemented)

	LIS	R7,0			:INDEX INTO ADDITIONAL CRASH DATA AREA
	LHL	R6,NXTCRP		:GET OFFSET INTO CRASH SUMMARY TABLE
					:FOR NEXT CRASH TO REPORT TO SUP.
	JEFS	LPCR00			:THIS IS THE LATEST CRASH
	LIS	R7,0A			:'OLD' CRASH ADDITIONAL DATA AREA
LPCR00	L	R0,CSMTBL+CS.PSD+4,R6	:CRASH ADDRESS
	LR	R6,R6			:LATEST CRASH?
	JEFS	LPCR10			:YES
	OI	R0,800000		:SET HO BIT OF CRASH ADDRESS TO
					:INDICATE THIS IS AN 'OLD' CRASH
LPCR10	ST	R0,SUPMBF+2		:CRASH ADDRESS TO SUP BUFFER
	LB	R0,CSMTBL+CS.CID+1	:COMMON CRASH CODE		###wjl
	STB	R0,SUPMBF+2		:TO SUP BUFFER
	LHI	R0,NR.CRP		:REPORT TYPE 19
	STH	R0,SUPMBF		:TO SUP BUFFER
	JAL	R10,SUP12

:	Make first addendum to the node crash report  
LPCR20	LB	R0,CSMTBL+CS.CID	:CRASH SUBTYPE CODE
	SLLS	R0,8			:SHIFT IT UP 1 BYTE		###wjl
	LB	R1,CRHCNT+1		:GET CURRENT CRASH COUNT	###wjl
	OR	R0,R1			:COMBINE AND
	EXHR	R0,R0			:SHIFT UP
	LI	R1,8080+((VERSIO&0F000)^-4) :COMBINE WITH HO NIBBLE OF VERSION
	OR	R0,R1			:COMBINE
:	R0 = CRASH SUBTYE<1BYTE>,CRASH COUNT<1BYTE>,VERSION TYPE+80,
:	NUMBER ADDENDA TO FOLLOW+80.
	ST	R0,SUPMBF+2
	LHI	R0,NR.CR1		:REPORT TYPE 2A
	STH	R0,SUPMBF		:to sup buffer			###wjl
	JAL	R10,SUP12		:MAKE REPORT TO SUP
LPCR30	LR	R6,R6			:WAS THIS FOR THE MOST RECENT CRASH?
	JEFS	LPCR40			:YES
	LIS	R7,0			:POINT TO LATEST CRASH
	LIS	R6,0
	STH	R6,NXTCRP		:INDICATE NEXT CRASH TO SEND IS LATEST
	J	LPCR00
LPCR40	HS	0
       IF	1-(REBTAK&REBILD)	:if to resend rebuild requests	###sdw
	J	LEP1			:ALL DONE
       ELSE	:REBTAK			:resend them
	LIS	R5,0			:index into array
LP8RB0	L	R6,REBTMO,R5		:on rebuild timout?
	O	R6,REBTMI,R5		:on either of the rebuild timouts?
	if	mortim
	o	r6,rebtm1,r5
	o	r6,rebtm2,r5
	ei	:mortim
LP8RB2	JFFO	R6,LP8RB1		:got one
	AIS	R5,4			:next group			###sdw
	CLHI	R5,CRQARL		:done with all ports?
	JLBS	LP8RB0
	J	LP8RB9			:done with rebuild resending 
LP8RB1	SLLS	R5,3			:make into real number
	ST	R6,LP8RS1		:save active flags
	RBT	R7,LP8RS1		:this one serviced
	AR	R7,R5
	SRLS	R5,3			:restore index into flags
	SLLS	R7,2			:make buffer index
	AI	R7,HBUFN		:got our history buffer
	LHL	R0,RNFLAG,R7,		:origination?
	JE	LP8RB8			:nope, skip resending
	LHL	R2,TVRBUF		:
	LHI	R1,8000+MACHNM		:make rebuild request supe msg
	JAL	R9,WHWI
	LHI	R1,0D80 		:type 0D
	JAL	R9,WHWI
	LHL	R1,RNFLAG,R7,		:needle flags
	JAL	R9,WHWI
	LHI	R1,8080 		:scratch port number
	JAL	R9,WHWI
	LHL	R1,RBASE,R7,		:base and host #
	JAL	R9,WHWI
	LHL	R1,RHOSTN,R7,
	JAL	R9,WHWI
	LHL	R1,RINVC,R7,		:invoice number
	JAL	R9,WHWI
	LHL	R1,RINVC+2,R7,		:all of invoice number
	JAL	R9,WHWI
	LCS	R1,1			:no idea of which link and node though
	JAL	R9,WHWI
	JAL	R9,WHWI
LP8RB8	L	R6,LP8RS1		:get back bits still to do
	LHI	R0,1F-PCKZB		:see if buffer zap pending
	TBT	R0,SQUEUE		:bzap scheduled?
	JNFS	LP8RB9			:yes, don't write any more
	J	LP8RB2

LP8RB9	J	LEP1			:end of takeover
       EI	:REBTAK

::*********************************************************************
::
::	SUBROUTINE:	CHKHST:
::	FUNCTION:	VERIFY THAT THE STATUS OF EACH HOST IS CORRECT
::	CALLING SEQ:	JAL	R7,CHKHST       CALLED FROM "LEP08"
::
::*********************************************************************

:	BEFORE PROCESSING TAKEOVER COMMANDS ON AN ISIS MACHINE, WE FIRST
:	NEED TO VERIFY THAT THE STATUS OF EACH HOST IS CORRECT.
:
:	CONSIDER THE FOLLOWING SITUATION:
:	IF HOST "A" GOES DOWN DURING A NODE CODE CRASH, ISIS TRIES
:	TO NOTIFY THE NODE CODE OF THE CHANGE IN STATUS, BUT THE NODE CODE
:	IS NOT THERE.
:	
:	THE NODE CODE DOESN'T CLEAR ALL THE HOST TABLES DURING RESTART, 
:	SO AFTER A NODE CODE RESTART, THE NODE CODE STILL HAS ALL
:	THE OLD HOST INFORMATION, AND DOESN'T KNOW THAT HOST "A" IS GONE.
:	HOW CAN THE NODE CODE CHECK IF ANY HOSTS WENT DOWN DURING A NODE
:	CODE CRASH?
:
:	DURING RESTART, NODE CODE SENDS AN "0F" COMMAND TO ISIS
:	REQUESTING HOST STATUS REPORTS FOR ALL HOSTS.  THIS WILL CAUSE
:	A SERIES OF "04" MESSAGES TO BE RETURNED TO THE NODE CODE.
:	THE NODE CODE WILL SET A FLAG, "HSTFLG", TO INDICATE
:	WHICH HOSTS IT HAS RECEIVED HOST STATUS REPORTS FOR FROM ISIS SINCE
:	THE LAST RESTART.  THEREFORE, FOR THOSE HOSTS IN THE HOST TABLE FOR
:	WHICH WE HAVE NOT RECEIVED HOST STATUS REPORTS FROM ISIS AFTER
:	RESTART, WE CAN BE SURE THOSE HOSTS ARE GONE, AND WE NEED TO NOTIFY
:	THE SUP OF THEIR "GONE" STATUS, AND CLEAR THE HOST ENTRY FOR THOSE
:	HOSTS.

	IF	(1-T2GATE)		:###EV

CHKHST	LIS	HN,1			:THE SECOND ENTRY TO HOST TABLE
					:SKIP THE FIRST ENTRY 0, SINCE IT IS
					:KERNEL HOST.
CHKENT	LHL	R1,HOSTN,HN,HN		:CHECK HOST TABLE FOR HOST ENTRIES
	JE	CHKNXT			:NO HOST AT THIS ENTRY, GO CHECK NEXT

:	YES, THERE IS A HOST AT THIS ENTRY.
:	CHECK IF WE RECEIVED A HOST STATUS REPORT FOR THIS HOST SINCE LAST
:	RESTART.
	TBT	HN,HSTFLG		:IS FLAG SET ?
	JN	CHKNXT			:YES,RECEIVED STATUS REPORT SINCE LAST 
					:RESTART, GO CHECK NEXT

:	NO STATUS REPORT RECEIVED SINCE LAST RESTART.
:	THIS HOST GONE, NOTIFY SUP OF STATUS, AND CLEAR ENTRY.
HSTGON	HS	0
       IF	1-ncslot		:CAN'T HAPPEN FOR A SWITCHER
	LIS	R0,HS.GNE		:STATUS IS "GONE"		###wjl
	LHI	R14,1180			:HOST STATUS REPORT WITHOUT TYPE FIELD
	OR	R14,R0			:COMBINE WITH STATUS
	LIS	R4,0			:INDICATING NO PID
	STB	R0,HSTAT,HN		:SAVE HOST STATUS

:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOST STATUS)
	SLLS	R0,6			:MOVE HSTAT (BITS 6,7) TO HSTATN 
					:(BITS 0,1)
	LB	R1,HSTATN,HN		:GET HSTATN
	NHI	R1,0FF-EHSTTS		:STRIP OFF OLD STATUS BITS
	OR	R1,R0			:COMBINE WITH STATUS
	STB	R1,HSTATN,HN		:RESTORE
	JAL	R9,GMTCAL,,		:GET CURRENT GMT
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME ARRAY
	ST	R0,HSTTIM,HN,HN		:STORE CURRENT TIME
	SRLS	HN,1			:RESTORE HN

:	SEND  STATUS REPORT TO SUP
	JAL	R10,SUPHS,,		:SEND [11,80+STATUS] TO SUP
	LHL	R0,HOSTN,HN,HN
	STH	R0,CRYSBF+2
	LB	R0,HSTAT,HN
	JAL	R8,CRYPTO,,
	HC	CRYE15			:CHANGE IN HOST STATUS 
	
:	DELETE THIS HOST FROM HOST TABLE
	LIS	R0,0	
	STH	R0,HOSTN,HN,HN		:CLEAR ENTRY
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)
	STB	R0,HSTAT			:CLEAR HOST STATUS
	STB	R0,HSTATN		:CLEAR EXTENDED HOST STATUS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME ARRAY
	ST	R0,HSTTIM,HN,HN		:CLEAR TIME ARRAY
	SRLS	HN,1			:RESTORE HN
	EI	:ncslot

:	CHECK NEXT HOST ENTRY
CHKNXT	AIS	HN,1			:BUMP HOST INDEX
	CLHI	HN,NHOSTS-1		:MORE HOST ENTRIES?  (EXCEPT KERNEL
					:HOST)
	JLE	CHKENT			:CHECK NEXT ENTRY		###cwc
	JR	R7			:DONE, RETURN

	EI	:(1-T2GATE)

	SUBTTL	LEP (LEP09 - Type 9:  Circuit building command)

::*********************************************************************
::
::	COMMAND:	LEP09:
::	FUNCTION:	PROCESS CIRCUIT-BUILDING REQUESTS (TYPE 9)
::
::*********************************************************************

LEP09	LR	R5,R2			:NEEDLE, SAVE SUP BUFF # AND GET
	JAL	R8,GFCBUF		:A BUFFER PAIR FOR NETWORK-BOUND DATA
	SKIPAD(OP8463)			:immed. return - out of buffers!###wjl
	LR	R7,R2			:+4 return, ok - SAVE IT IN R7

	SRLS	R2,1			:SET UP BUFTIM INDEX
	NHI	R2,-4
	L	R0,FASTC,,		:STORE FASTC TIME THAT
	ST	R0,BUFTIM,R2,		:NEEDLE ORIGINATES IN NODE

	LHI	R6,-2,LRC		:COPY OVER THE REST OF NEEDLE
 

LEP09A	LR	R2,R5			:R5 HAS BUFFER # FROM SUP
	JAL	R8,GCI
	LR	R2,R7			:PUT DATA INTO NEW NET-BOUND BUFFER
	JAL	R8,WCI
	SIS	R6,1			:DECREMENT COUNT
	JGBS	LEP09A			:LOOP FOR ALL THE DATA
:	Next set up the net-bound buffer in the proper format
LEP90C	JAL	R9,GHWI			:REMOVE NODE #
	JAL	R8,GCI			:AND MESSAGE TYPE
	LIS	R1,0			:PRECEDE LINK CNT BY AN ESCAPE
	JAL	R8,WCD
	JAL	R8,WCD			:LEAVE A SLOT FOR BYTE CNT
	L	PRD,BB,R2,		:SAVE PTR TO SAME
	JAL	R8,WCD			:PRECEDE BYTE CNT BY AN ESCAPE
	LHI	R1,NEEDP		:INSERT NEEDLE POINT
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD
	JAL	R8,CBCCT		:GET THE RESULTING BYTE COUNT
	STB	R1,0,PRD		:AND PUT IT AWAY
	STH	R2,CQNBUF		:SAVE THE NET-BOUND BUFF # IN CASE

:	NEEDLE HAS BEEN ASSEMBLED IN BUFFER, NOW PROCESS THE ORIGIN:

	L	R3,BB,R2,		:SET UP FOR PEEK ROUTINES
	JAL	R9,PHWI			:SKIP NEEDLE POINT
	JAL	R9,PHWI			:GET BYTE AND LINK COUNTS
	NHI	R1,7F			:SAVE LINK COUNT
	STH	R1,CQNLK
	JAL	R9,PHWI			:SAVE INVOICE #
	STH	R1,CQINV
	JAL	R9,PHWI
	STH	R1,CQINV+2
	lr	r11,r3			:save address of byte before flags
	JAL	R9,PHWI			:GET THE FLAGS
	LR	R7,R1			:SAVE NEEDLE FLAGS IN R7
	STH	R7,NEDFLG		:	AND IN MEMORY
	JAL	R9,PHWI			:SAVE REQUESTING NODE
	STH	R1,CQNODE
	JAL	R9,PHWI			:GET REQUESTING PORT#
	STH	R1,CQPORT		:SAVE REQUESTING PORT
       if	ncprio			:if nc is using cct29 for priority
	lr	r15,r3			:save r3
	lhl	r0,cqnlk		:skip this if internal circuit
	je	lep919
:	here to set priority bit and force to class D circuit by modifying
:	needle since the sup won't do that for us
lep912	lb	r1,0,r11
	ohi	r1,(nf.pri/100)		:in wrong byte of a hw def
	stb	r1,0,r11
	lr	r9,r3			:save peek position of needle
	lr	r3,r11			:now pointing to first byte of flags
	jal	r8,nci			:point to second byte of flags
	lb	r1,0,r3			:get second byte of flags
	ohi	r1,30			:force to class D
	stb	r1,0,r3			:save modified second byte of flags
	lr	r3,r9			:restore peek position of needle

:	and exit
lep919	lr	r3,r15
       ei	:ncprio			:nc setting of priority bit in needle
	LHL	CHN,CQPORT		:IT'S OUR ABSOLUTE CHAN #

	THI	R7,NF.REB		:IS THIS A REBUILD NEEDLE?
	JN	LEP09R			:YES, A REBUILD IS IN PROGRESS
	LHL	R0,CQNLK		:NO...ORIGINAL CIRCUIT. IS IT INTERNAL?
	JNFS	LEP09G			:NOT INTERNAL, SET UP REBILD PARAMETERS

:	INTERNAL CIRCUIT - SAVE DESTINATION HOST NUMBER TO TEST
:	FOR KERNEL HOST OR XRAY.
	LR	R6,R3			:SAVE BB	
	JAL	R9,PHWI			:NEXT HW IS DESTINATION HOST+8000
	NHI	R1,7FFF
	STH	R1,CQDHST		:INTERNAL CIRCUIT DESTINATION HOST #
	LR	R3,R6			:RESTORE BB (STILL POINTS TO DEST HST)
	IF	REBILD
	J	LEP09N			:NO HISTORY REQUIRED FOR INTERNAL CIRC
	EI	:REBILD

:	INITIALIZE THE VARIABLES ASSOCIATED WITH THE ORIGIN OF A
:	REBUILDABLE CIRCUIT.

LEP09G	HS	0
	IF	REBILD
	ST	R3,TRCSV1		:TEMP STORE,POINTS TO 1ST OF NODE LIST
	JFS	LEP9G2
LEP9G1	STH	R1,CQHOST		:SAVE IN CASE THIS IS THE BASE
LEP9G2	JAL	R9,PHWI			:READ NEXT NODE #
	THI	R1,8000			:IF NEG IT'S HOST #
	JEBS	LEP9G1			:POSSIBLY BASE
	LR	R3,R2			:HOST # IN R1, COMPUTE HIST BUFF #
	SRHLS	R3,1
	AI	R3,HBUFN
	STH	R7,RNFLAG,R3,		:SAVE NEEDL FLAGS, HOST, INVOICE
	STH	R1,RHOSTN,R3,
	LHL	R0,CQHOST
	STH	R0,RBASE,R3,
	L	R0,CQINV
	ST	R0,RINVC,R3,
	LR	R1,R7			:COMPUTE 2*BP CONSTANT* # LINKS-BP
	HSIZE(R1)			:COMPUTE SIZE BASED ON SPEED BITS###CY
	STH	R0,RHBSZ,R3,
	L	R3,TRCSV1		:RESTORE PEEK PTR
	EI	:REBILD

LEP09N	LHL	R6,IOTAB,CHN,CHN	:PORT IS SOME INTERNAL INTERFACE
	NHI	R6,-4			:CHECK THE PORT'S OUTBOUND BUFFER
	JE	LEP09F			:NO PERMTR TABLE ENTRY MADE YET,PROCEED
	LHL	R1,BF,6,		:THERE'S ALREADY A PERMUTER TABLE ENTRY
	CLHI	R1,LOGMIN		:..THE PORT HAD BETTER BE IN LOGIN MODE
	JL	LEP09U			:NOT IN LOGIN MODE,GENERATE DIAGNOSTICS
	CLHI	R1,LOGMAX
	JG	LEP09U			:NOT IN LOGIN MODE...CHANNEL IN USE ERR

LEP9N1	JAL	R9,LOGCLR		:CLEAR BUFF # FROM LOGGER LIST
	LCS	KD,1			:INDICATE T-II TERM

LEP09V	LR	R7,R2			:CHECK FOR 'EARLY ZAP' IN FROM-TERM BFR

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LP9DB1,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	L	R3,BB,R6,		:SET UP FOR A PEEK
	je	lep9v2			:no data to look at
	JAL	R8,PCI
	SIS	R1,3			:BY TESTING FOR AN 03...
	JN	LEP9V2			:NO ZAPPER, APPEND WHATEVER DATA
	JAL	R8,PCI			:SOMETHING IS UP, LOOK AT NEXT BYTE
	CLHI	R1,ZAPPH&0FF		:IS IT A HARD ZAPPER?
	JEFS	LEP9V1			:YES, ZAP CIRCUIT
	CLHI	R1,ZAPPN&0FF		:OR A NON-GOBBLING ZAPPER?
	JN	LEP9V2			:NO, JUST PASS ON WHATEVER IT MAY BE

:	GOT AN 'EARLY ZAPPER' FROM AN ORIGINATING T-1 PORT -
:	MUST CLEAR THE CIRCUIT TO PREVENT DEAD ENDS, SO
:	SEND A NON-GOBBLING ZAPPER AFTER NEEDLE SO THAT THE
:	T-II DESTINATION WILL SEND A NEEDLE ACK TO SUP.

LEP9V1	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R3,1			:CASE # 1
	JAL	R14,LP9DB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	LHI	R1,ZAPPN		:SEND A NON-GOBBLING ZAPPER
	JAL	R9,W2CI
	IF	(1-T2GATE)
	LIS	R0,0			:CLEAR PERMUTER ENTRY
	STH	R0,IOTAB,CHN,CHN
	EI	:(1-T2GATE)		:Gateway uses Zap Ack to clean up

	IF	T2GATE
	LHI	R1,-DISZFL,CHN		:F.T. buf must be dispatcher channel
	RBT	R1,DISFLG,,		:Possible 3E63 crash averted
	SBT	R1,DISZNK		:Prepare for ZAPV
	LR	R0,CHN			:Save absolute channel number
	LR	CHN,R1			:Use rel dispatcher port
	LHI	R1,09F00		:to clear for reuse
	JAL	R8,DIRMES
	LIS	R1,0
	STH	R1,BF,R6,		:Prepare for Zapv to return buffer
	LR	CHN,R0			:Restore absolute channel for crypto
	EI	:T2GATE

	IF	(1-T2GATE)		:Gateway must hold until Zap Ack clears
	SBT	CHN,ACP,,		:FREE THE CHANNEL'S ACP BIT
	LCS	R2,1			:SET NEGATIVE ACP ARRAY ALSO
	SR	R2,CHN
	SBT	R2,ACP,,
	LR	R2,R6			:RETURN ORIGINAL BUFFER
	JAL	R8,RFCBUF
	EI	:(1-T2GATE)
	LR	R2,R7			:ALERT CRQ OF NEEDLE BY WRITING NEEDLE
	JAL	R9,CRQALT		:BUFFER NUMBER INTO BUFFER 0
	JAL	R8,CHFLNK,,		:GO FIND NEIGHBOR
	SKIPAD(LEP9V3)			:immediate return, NOP		###wjl
	SKIPAD(LEP9V3)			:+4 return, NOP			###wjl
LEP9V3	EXHR	R0,CHN			:+8 ret, MOVE CHAN TO UPPER HW OF R0
	OR	R0,R3			:COMBINE WITH T-1 NEIGHBOR NUMBER
	JAL	R8,CRYPTO,,		:REPORT ZAPPER
	HC	CRYE18			:MESSAGE - EARLY ZAPPER
	J	lepxit			:EXIT - CAN DO NO MORE FOR THIS CIRCUIT

:	NO ZAPPER--APPEND DTA IN FROM-TERM BUFFER TO OUR NEW
:	NETWORK-BOUND BUFFER
LEP9V2	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R3,2			:CASE # 2
	JAL	R14,LP9DB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	JAL	R9,APPEND		:NO ZAPPER, APPEND DATA

	LR	R2,R6			:RETURN DATA (FROM-TERM) BUFFER
	JAL	R8,RFCBUF
	LR	R2,R7			:NET-BOUND IS NOW THE RELEVANT BUFFER
LEP09F	JAL	R9,CRQHCR		:BUILD HALF CIRC TO OUR REQUESTING PORT
	LHI	R1,-DISZFL,CHN		:IS REQUESTING PORT A DISPATCHER PORT?
	JL	LEP9F1			:NO, TOO LOW
	CLHI	R1,NDP			:TEST UPPER BOUND
	JGE	LEP9F1			:TOO LARGE, NOT A DISPATCHER PORT
	SBT	R1,DISBPV		:FOR A DISPATCHER PORT,FIRST RELIEVE BP
	LHI	R0,INXLIM		:AND GIVE IT XMIT CAPACITY
	STH	R0,DIXLIM,R1,R1

	IF	T2GATE
	RBT	R1,LOGING		:No longer in Log-in mode
::If IIX circuit - must send IIX reached ##/## host reply
	TBT	R1,GIIXCT
	JE	GASTRT
	LHL	R0,NEDFLG		:Get needle flags
	THI	R0,NF.SMC
	JEFS	GLPNSM			:Not smart
	LA	R4,IIXGRS,,		:Smart
	JFS	GLPSND
GLPNSM	LA	R4,IIXGRD,,
GLPSND	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R9,BUFCAN		:send it
	XHI	R2,4			:Back to sup bound bffer
GASTRT	HS	0
::Circuit initiation  complete -  initiate accounting 
	IF	ACCT
	ST	R2,GASTOR
	LR	R3,CHN
	SHI	R3,MNACHN	:get to account port index
	sbt	r3,aaorig	:this is an origination port
	AAMKPT(r3)		:Get FW pointer to circuit's block
	L	R0,AAINV,R11	:Get previously stored  Invoice number
	ST	R0,ININV	:Store as INET invoice for AASWAP

	JAL	R8,GASTR1,,	:Initiate accounting
	NOP			:Need this 4 bytes for the normal return
	SHI	CHN,DISZFL	:make into dispatcher port  9/1/93
	JAL	R10,AASWAP,,	:and swap invoice numbers
	AHI	CHN,DISZFL	:restore channel number (not actually required
GASKIP	L	R2,GASTOR
	EI	:ACCT

	ELSE	:(1-T2GATE)		:Gate does not send back "needle eye"
	XHI	R2,4			:FLIP TO ISIS-BOUND BUFFER
	LHI	R1,NEEDE		:SEND NEEDLE EYE TO DISPATCHER
	JAL	R9,W2CI
:	SEND NEEDLE FLAGS TO CIRCUIT ORIGINATION WITH NEEDLE EYE. FLAGS
:	INDICATE IIX SMART CIRCUITS, ALSO INTERNAL CIRCUITS.
	LHL	R1,NEDFLG		:NEEDLE FLAGS, FROM CIRCUIT NEEDLE
	OHI	R1,NF.INT		:MAY BE UNNECESSARY, BUT SAFE
	LHL	R0,CQNLK		:IF ZERO LINKS, THIS IS INTERNAL CIRC
	JN	LEP9F0			:NOT INTERNAL - NF.INT LEFT SET
:	DON'T INDICATE INTERNAL CIRCUIT TO ISIS IF DESTINATION HOST
:	IS NOT A DISPATCHER HOST (I.E. KERNEL HOST OR XRAY)...
	LHL	R0,CQDHST
	CLHI	R0,HST0			:KERNEL HOST AS DESTINATION?
	JE	LEP9F0			:YES, DON'T INDICATE ISIS INTERNAL CIRC
	XHI	R1,NF.INT		:INTERNAL CIRCUIT - RESET NF.INT
LEP9F0	JAL	R9,WHWI			:NEEDLE FLAGS TOWARD DISPATCHER INTERFC
	LHL	R1,CQINV
	JAL	R9,WHWI			:APPEND INVOICE #
	LHL	R1,CQINV+2
	JAL	R9,WHWI
	EI	:(T2GATE)	

	IF	T2GATE
	JFS	LEP9F1			:CRQALT done here to outbound circuit
	ELSE
	XHI	R2,4			:RESTORE BUFFER POINTER NET-BOUND###GT
	JFS	LEP9F2			:SKIP CRQALT (WILL BE DONE IN DISPI)
	EI	:T2GATE

LEP9F1	JAL	R9,CRQALT		:ALERT CRQ TO NEEDLE
LEP9F2	SRHLS	R2,3			:MAKE CRQ INDEX			###CY
	SBT	R2,CRQEND		:CIRCUIT ENDPOINT CREATED
	IF	REBILD
	RBT	R2,REBTMO		:CLEAR CRQ TIMEOUT (SEE LEP11)	###CY
	RBT	R2,REBTMI
	if	mortim
	rbt	r2,rebtm1
	rbt	r2,rebtm2
	ei	:mortim
	LHL	R0,CQNLK		:INT CRQ NOT REBUILDABLE	###CY
	JE	lepxit			:				###CY
	SBT	R2,CRQBSY		:REBUILDABLE CIRCUIT IN USE
	RBT	R2,SQFTMO		:CLEAR REBUILD TIMEOUT
	SBT	R2,SQFTMI		:SET REBUILD TIMER
	SLHLS	R2,3			:RESTORE BUFFER INDEX		###GT
	JAL	R9,SNDFX0		:SEND SEQ FIX 0			###CY
	EI	:REBILD

	J	lepxit			:ALL DONE

:	PROCESS ARRIVAL AT ORIGIN OF A REBUILD NEEDLE:

	IF	REBILD

LEP09R	JAL	R9,FNDCRQ,,		:REBUILD NEEDLE, LOCATE CIRCUIT
	SKIPAD(LEP09Z)			:CANNOT MATCH THE INVOICE NUMBER, ABORT
	LHL	R5,CQNFLG		:+4 return, RECOMPUTE HIST BUFF SIZE
	HSIZE(R5)			:BASED ON SPEED BITS		###CY
	STH	R0,RHBSZ,R7,		:R6, R7 WERE SET UP IN FNDCRQ
	JAL	R9,MERGE		:MERGE OUTBOUND AND HISTORY BUFFERS
	LR	R2,R6			:CHECK MERGED OUTBOUND BUFF'S 1ST CHAR
	LHL	R1,BCT,R2,		:NO PEEK EMPTY BUFFER
	JE	LEP09S
	JAL	R8,PCIS			:IT MIGHT BE AN '02' OR '03' RESULTING

	SIS	R1,3		:sequence numbers do not split char pairs and
	JGFS	LEP09S		:since new logic returns exactly as many as
	AIS	R1,1		:seq num thus split pairs stay together.
	JLFS	LEP09S		:old logic returned convient number of bytes

	XHI	R2,4			:FIRST CHAR IS <= 7, NO REBUILD
	JAL	R9,ZAPHRD		:ZAP BACK TOWARDS THE ORIGINATING PORT
	J	LEP1			:AND GO TO NEXT SUP MESSAGE

LEP09S	LHL	R2,CQNBUF		:BUFFER WHERE NEEDLE ASSEMBLED
	XHI	R6,4			:R6=INBOUND BUFFER
	LHL	R1,VSEQN,R6,		:GET COUNT OF CHARS RECEIVED ON CIRC
	JAL	R9,WHWI			:...TELLS FAR END WHAT TO SEND NEXT
	LHL	R1,VSEQN+2,R6,		:LOWER HW OF 32-BIT NUMBER	###GT
	JAL	R9,WHWI
	XHI	R6,4			:FLIP TO OUTBOUND BUFFER...TELLS
	LHL	R1,XSEQN,R6,		: FAR END WHICH CHAR WE'LL SEND NEXT
	JAL	R9,WHWI			:WRITE IT INTO NEEDLE BUFFER
	LHL	R1,XSEQN+2,R6,		:LOWER HW			###GT
	JAL	R9,WHWI
	JAL	R8,CBCCT		:COMPUTE NEW NEEDLE BYTE COUNT
	STB	R1,0,PRD		:AND STORE IN APPROPRIATE NEEDLE FIELD

	JAL	R9,SNDFX0		:SEND A FIX0 BEHIND THE NEEDLE	###GT

	LR	R7,R2			:R7 SOURCE, R6 DEST
	L	R0,SEQN,R6,		:KEEP SEQN S,TRAIGHT
	ST	R0,SEQN,R7,
	JAL	R9,PREFIX		:PREFIX NEEDLE TO OB
	LHL	R2,CQNBUF		:RETURN NEEDLE BUFFER
	JAL	R8,RFCBUF
	LR	R2,R6
	JAL	R9,CRQALT		:ALERT CRQ OF NEEDLE
	SRHLS	R2,3			:CLEAR TIMEOUTS
	SBT	R2,CRQBSY		:RE-ACTIVATE REBUILD PROCESSING
	SBT	R2,CRQEND		:AND NOTE CREATION OF AN ENDPOINT
	RBT	R2,REBTMO
	RBT	R2,REBTMI
	if	mortim
	rbt     r2,rebtm1
	rbt     r2,rebtm2
	ei	:mortim
	RBT	R2,SQFTMO		:CLEAR REBUILD TIMEOUT BIT	###GT
	SBT	R2,SQFTMI		:SET REBUILD TIMEOUT COUNTER	###GT
	J	lepxit			:ALL DONE

	ELSE	:NOT REBILD

LEP09R	J	LEP09Z			:CANNOT REBUILD, NOT ENABLED. ABORT

	EI	:REBILD

LEP09U	ST	R2,LEPSV1		:TYPE 1 MESS TO SUP'S LOG
	JAL	R10,SWRCHU		:FORMAT CHANNEL IN USE NODE REPORT,
					: CIRCUIT LIFETIME NODE REPORT,
					: AND CRYPTOGRAM.
	L	R2,LEPSV1
	J	LEP09Z			:ABORT

:	NO SUCH NEIGHBOR
LEP09H	ST	R2,LEPSV1		:SAVE BUFFER INDEX
:	SEND NODE REPORT FOR 'NO NEIGHBOR'
	LHI	R0,NR.NNE
	STH	R0,SUPMBF		:REPORT TYPE
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER NOT FOUND
	LHL	R0,NEDFLG
	STH	R0,SUPMBF+4		:NEEDLE FLAGS
	JAL	R10,SUP12		:SEND NODE REPORT TO SUPERVISOR LOG
	L	R2,LEPSV1		:RESTORE BUFFER INDEX TO RETURN IT...

LEP09Z	JAL	R8,RFCBUF		:ABORT - RETURN BUFFER
	LIS	R0,1
	AHM	R0,NC.LPE		:COUNT CIRCUIT BUILDING ERRORS IN LEP
	J	LEP1			:AND PROCESS NEXT COMMAND


	SUBTTL LEP (LEP0A - CCN Log II Command Channel Needle)

       IF	LOGII&(1-NCSLOT)	:only if log 2 with dispatcher


::****************************************************************
:
:	LEP0A	Receive CCN (log2 needle data) from supe and convert to
:		a needle that travels along.
:		This needle will be converted into one of the following:
:		a) the NCN needle (the needle with x.409 mos)  
:		b) a log I needle followed by x.409 MOs.  the log I is to
:		  allow backlevel NCs built circuit to LOG II destination.
:		c) a log I needle for log I hosts.
:		Logic is to leave needle in sup buffer and continually peek
:		at it to get whatever needed info.  When completed then we
:		return entire needle via one call to RTBFTS.  Logic has
:		significant differents between log I lep (lep09) since lep09
:		logic is leftover T-I and solo consat code that happens to
:		handle t-II needles.
:
:	Notes: the NEEDBD (032A) and NEEDTL (032B) only travel when there is
:	a needle head.  Thus, case B needles are followed by data which dest
:	has to know is needle body data.  (needle flag does indicate that).
:	All converted needles have username.  This makes it much easier if
:	the destination is XRAY.
:
::****************************************************************

LEP0A	SIS	LRC,2			:LEP1 removed 2 byte len field
	L	R3,BB,R2,		:setup for peeks
	JAL	R9,PHWI 		:node number
	JAL	R9,PHWI 		:type (0A) and unused byte
	JAL	R9,PHWI 		:logical length
	LHI	R4,ID.CNF		:ccn flags id
	JAL	R7,X4PARS,,		:let parser find it
	SKIPAD(.LEPA1)			:ccn error
	JAL	R9,PCIE 		:get byte of unused bits
	JAL	R9,PCIE 		:get only byte of bits we care about
	STB	R1,NEDFLG		:save it (bits in diff places than LG I
	LHI	R4,ID.PRT		:find origination port
	JAL	R7,X4PARC,,		:continue parse
	SKIPAD(.LEPA1)			:error
	JAL	R7,X4GTNM,,		:get chn #
	LR	CHN,R4			:port is rel dispi port
	AHI	R4,DISZFL
	STH	R4,CQPORT		:save absolute port #
:	since X4PARC stores everything except r6 and doesn't need r2,
:	we no longer must retain sup buf (it is in LEPINB if we need it)
	LHL	R2,DIOTAB,CHN,CHN	:get orig's buffer
	NHI	R2,-4			:knock off any speed bits
	JE	.LEPA1			:our buffer must still be there
	LHL	R1,BF,R2,		:port better be in login mode
	CLHI	R1,LOGMIN
	JL	.LEPA1			:error, port lost
	CLHI	R1,LOGMAX
	JG	.LEPA1			:error, port in use
	LR	R6,R2			:logger buff is other direction
	JAL	R9,LOGCLR		:port no longer logging in
LEPA04	LHL	R1,BCT,R2,		:any data in from orig
	JE	LEPA07			:no worry about waiting zappers
	L	R3,BB,R2,		:setup for peek
	JAL	R8,PCI			:get first char in buff
	CLHI	R1,3			:zap or gobbler?
	JN	LEPA07			:no worries
	JAL	R8,PCI,,		:what type of char pair
	CLHI	R1,ZAPMAX&0FF		:zap family?
	JLE	LEP0AZ			:it's a zap
	CLHI	R1,GOBBL&0FF		:gobbler?
	JNFS	LEPA07			:not a worrisome 03 pair
					:remove gobbler since it has gobbled
	JAL	R8,GCI			:everything a gobbler should gobble
	JAL	R8,GCI
	J	LEPA04			:see if anything else after gobbler

LEPA07	JAL	R8,GFCBUF		:a buff to assemble needle
	SKIPAD(.LEPA1)
	LB	R0,NEDFLG		:see if must convert to LOG I needle
	THI	R0,L2F.N2		:term not log2
	JN	LEPA28			:go convert it
	LHI	R4,ID.ISN		:find needle data (ISN MOs)
	JAL	R7,X4PARC,,
	SKIPAD(.LEPA0)			:another ccn error
	XHI	R2,4			:'other' direction for assemblin body
	JAL	R7,X4WTEL,,		:copies element in table to buff
	JAL	R8,CBCCT		:size of body
	JAL	R9,WCDE 		:put len at start
	EXBR	R1,R1
	JAL	R9,WCDE 		:high byte
	XHI	R2,4			:back to net direction
	LB	R0,NEDFLG		:time to test for nasty passthroughs
	THI	R0,L2F.PN		:convert needle head to log I
	JN	LEPA28			:convert head
:	converted needle only has needle eye.  the rest follows as data
	XHI	R2,4			:needle tail at end of buffer
	LHI	R1,NEEDTL		:append needle tail
	JAL	R9,W2CI
	XHI	R2,4			:towards net direction
	LIS	R10,0			:X4WTEL does a running cnt in r10
	LB	R0,NEDFLG
	THI	R0,L2F.IC		:intranode has no list of nodes
	JN	LEPA10
	LHI	R4,ID.NNL		:first in head in needle node list
	JAL	R7,X4PARC,,
	SKIPAD(.LEPA0)			:bad needle form or something
	JAL	R7,X4WTEL,,
LEPA10	LHI	R4,ID.CNF
	JAL	R7,X4PARC,,		:followed by flags
	SKIPAD(.LEPA0)			:has to be there, already found it
	LHI	R4,ID.NCF
	STB	R4,X4T.ID,R6		:the ID we want to write
	JAL	R7,X4WTEL,,
	LHI	R4,ID.TPC		:followed by throughput class
	JAL	R7,X4PARC,,
	SKIPAD(.LEPA0)
	JAL	R9,PCIE 		:and what is our TCLASS?
	STB	R1,NEDFLG+1
	JAL	R7,X4WTEL,,
	LHI	R4,ID.INV		:get invoice number
	JAL	R7,X4PARC,,
	SKIPAD(.LEPA0)
	JAL	R7,X4GTNM,,		:get and save it
	ST	R4,CQINV
	JAL	R7,X4WTEL,,		:put it into head
	LHI	R4,ID.THS		:terminating host number
	JAL	R7,X4PARC,,
	SKIPAD(.LEPA0)
	JAL	R7,X4GTNM,,		:save term host
	STH	R4,CQHOST
	JAL	R7,X4WTEL,,		:add to needle head
	LIS	R0,0
	STH	R0,CQNLK		:init to no links (internal)
	LB	R0,NEDFLG		:intra node circuits have no links
	THI	R0,L2F.IC
	JN	LEPA18
	LHI	R4,ID.LNK
	JAL	R7,X4PARC,,		:number of links circuit takes
	SKIPAD(.LEPA0)
	JAL	R7,X4GTNM,,
	STH	R4,CQNLK		:save it for rebuild HSIZE
	JAL	R7,X4WTEL,,		:add it to head
LEPA18	LR	R1,R10			:retrieve total head size
	JAL	R9,WCDE 		:write 2nd byte of len
	CLHI	R1,MO.LFM
	JL	LEPA1C			:only requires one byte
	CLHI	R1,100			:require len of len
	JL	LEPA1B
	EXBR	R1,R1
	JAL	R9,WCDE 		:write high byte
	LHI	R1,MO.LFM+2		:len of len
	JAL	R8,WCD
	JFS	LEPA1C			:done with two byte long form
LEPA1B	LHI	R1,MO.LFM+1		:len of len
	JAL	R8,WCD
LEPA1C	LHI	R1,NEEDBD		:needle head followed by body
	JAL	R9,W2CI
	LHI	R1,MO.AC2+ID.NCH	:before len comes ID
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD
	LHI	R1,NEEDHD
	JAL	R8,WCD
	EXBR	R1,R1			:write needle head (0329)
	JAL	R8,WCD
	JFS	LEPA30

:	here to make a log I needle (for log I term and log I passthrough)
LEPA28	JAL	R9,LEPACV		:convert needle

:	come here when LOG II needle head or translated needle is in
:	buffer.  Needle body, if present, is in buffer's other direction
:	and any user data is in original buffer (in DIOTAB).

LEPA30	LR	R7,R2			:set current buffer as destination
	LR	R6,R2			:needle body was stored in other side
	XHI	R6,4			:looking for needle body
	JAL	R9,APPEND,,		:append if anything there
	LHL	R6,DIOTAB,CHN,CHN	:do userdata
	NHI	R6,-4			:knock of speed bits
	JAL	R9,APPEND,,		:copy any userdata to end
	LR	R2,R6			:no longer need source buff
	JAL	R8,RFCBUF
	LR	R2,R7			:new buff is now for the circuit
	AHI	CHN,DISZFL		:make real chn number
	JAL	R9,CRQHCR,,		:build with new buff
	SHI	CHN,DISZFL		:back to rel dispi chn #

	LR	R6,R15			:restore parse register
	LR	R2,R7			:time to write Logon success
	LHI	R1,LG2EYE		:write our log 2 needle eye
	XHI	R2,4			:towards dispatcher
	JAL	R9,W2CI

:	internal circuit indication on LGSC tells dispatcher that circuit
:	goes between two other slots and dispatcher will disconnect cir from
:	NC.  circuits to hst0 are to receive dispatcher service like internode
:	circuits so don't tell ISIS that it is intranode.
	LIS	R1,1			:write if internal or not (1=internal)
	LHL	R0,CQHOST		:if internal host, not intra node
	CLHI	R0,HST0
	JEFS	LEPA33			:circuit will still go to NC
	LHL	R0,CQNLK		:no links means internal
	JEFS	LEPA34			:followed by a zero is not internal
LEPA33	XHI	R2,4			:needle heads towards net
	JAL	R9,CRQALT,,		:tell CRQ we have a needle
	XHI	R2,4			:back towards dispi
	LIS	R1,0			:not internal
LEPA34	JAL	R9,WCIE
	LHI	R4,IDLGSC		:find logon successful indication
	JAL	R7,X4PARC,,
	SKIPAD(.LEPA0)			:format error
	LR	R1,R0			:prepare to write len of entire msg
	AIS	R1,2			:len of id and its len
	CLHI	R0,MO.LFM		:two byte len
	JLFS	LEPA37
	AIS	R1,1
	CLHI	R0,100			:three byte len
	JLFS	LEPA37
	AIS	R1,1
LEPA37	JAL	R9,WHWI 		:write a HW of len
	JAL	R7,X4WTEL,,		:write element LGSC
	LR	R4,R2			:save chn buffer
	LHL	R2,LEPINB		:get supe buffer
	LR	R0,LRC			:size of CCN (we have finished with it)
	JAL	R8,RTBFTS		:kill CCN
	LR	R2,R4			:back to circuit's buf
	SRHLS	R2,3			:make it for bit array
	SBT	R2,CRQEND		:termination
	if	rebild
	RBT	R2,REBTMO		:clear stupid timouts
	RBT	R2,REBTMI		:(timout logic not needed for T-II)
	if	mortim
	rbt     r2,rebtm1
	rbt 	r2,rebtm2
	ei	:mortim
	ei	:rebild
	SLHLS	R2,3			:restore R2 to net direction
	IF	REBILD
	LHL	R0,CQNLK		:not for internal circuits
	JE	LEPA40
	SRHLS	R2,3			:make into bit array index again
	SBT	R2,CRQBSY		: rebuildable needle
	RBT	R2,SQFTMO		:set rebuild timout (for ACK to FX0)
	SBT	R2,SQFTMI
	SLHLS	R2,2			:make it for storing rebuild stuff
	AI	R2,HBUFN		:make it the history buffer
	L	R0,CQINV		:get invoice number
	ST	R0,RINVC,R2,		:save it
	LHL	R0,CQHOST		:get dest host
	STH	R0,RHOSTN,R2,
	JAL	R7,LPAFLG		:get log I flags
	STH	R4,RNFLAG,R2,		:save flags in log I format
	JAL	R7,LEPADN		:now find dest node
	STH	R4,RBASE,R2,
	LB	R1,NEDFLG+1		:get speed bits
	SLHLS	R1,4			:move to where HSIZE expects em
	HSIZE(R1)
	STH	R0,RHBSZ,R2,		:completed history stuff
	SI	R2,HBUFN		:make it back buff with needle
	SLHLS	R2,1			:above shift left of 2 cancels right 3
	JAL	R9,SNDFX0
	EI	:REBILD

:	setup dispi stuff
LEPA40	SBT	CHN,DISBPV		:release backpressure
	LHI	R0,INXLIM		:XMIT capability
	STH	R0,DIXLIM,CHN,CHN
:	and now done!
	J	lepxit

:	Gobble needle and return whatever we started
.LEPA0	JAL	R8,RFCBUF		:return buffer
.LEPA1	LHL	R2,LEPINB		:gobble bad needle
	JFS	.LEPA2
.LEPA3	JAL	R8,GCI
.LEPA2	SIS	LRC,1
	JGBS	.LEPA3			:gobble bad needle
	LIS	R0,1
	AHM	R0,NC.LPE		:count another error
	J	LEP1


:	LEPACV	converts LOG2 CCN into log I needle.  Does translation
:		for termnotlog2 (total coversion) and for passthroughnotlog2
:		(log I head to build circuit and log2 body so term host gets
:		ISN).
:	Translates both CCN needle and NCN (NCN head only).  Little
:	trick of using bit 08 (log i term)  of NEDFLG to determine whether to 
:	append username.  (only for case of CCN since NCN has username in body)
:
:	both expect the log2 needle to be in parsed form with r6 setup
:	by X4PARS.  Also, needle written into buffer in R2.
:	trashes r0,r1,r3,r4,r7,r8.  R6 will be different but still
:	will point inside X4PARC table.

LEPACV	ST	R9,LEPAS1		:save it
	LHI	R1,NEEDP
	JAL	R9,W2CI
	LIS	R1,0			:write len
	JAL	R9,W2CI 		:give room for len
	L	R3,BE,R2,		:where to write len
	ST	R3,LEPAS2		:save loc of len
	JAL	R8,WCI			:escape link count
	LHI	R4,ID.LNK		:get number of links
	JAL	R7,X4PARC,,
	SKIPAD(LGCV04)
	JAL	R7,X4GTNM,,		:get the number
	JFS	LGCV06
LGCV04	LIS	R4,0
LGCV06	STH	R4,CQNLK		:save it
	LR	R1,R4
	OHI	R1,80			:80+number of links
	JAL	R8,WCI			:write number of links
	LHI	R4,ID.INV		:now invoice number
	JAL	R7,X4PARC,,
	SKIPAD(.LEPA0)			:fatal error if can't make em pay
	JAL	R7,X4GTNM,,		:get the invoice number
	st	r4,cqinv
	EXHR	R1,R4
	JAL	R9,WHWI 		:write high HW of invoice number
	LR	R1,R4			:then low HW
	JAL	R9,WHWI
	JAL	R7,LPAFLG		:get log2 flags into log I form
					:hw of flags returned in r4
	NHI	R4,@NF.LG2		:assume dest not log 2
	LB	R1,NEDFLG		:get CCN flags to see if dest log 2
	THI	R1,L2F.N2		:destination log 2?
	JNFS	LGCV08			:not a log ii dest
	OHI	R4,NF.LG2		:ISN data follows needle
LGCV08	LR	R1,R4			:write converted needle flags
	JAL	R9,W2CI
	LHI	R1,MACHNM		:requesting node is known
	JAL	R9,WHWI 		:write it
	LR	R1,CHN			:orig port
	AHI	R1,DISZFL		:expect it as relative dispatcher port
	JAL	R9,WHWI 		:write origination port
	ST	CHN,LEPAS3		:save chn# for a free reg
	LHL	R5,CQNLK		:get number of links
	JE	LGCV11			:no node numbers to write
	LHI	R4,ID.NNL
	JAL	R7,X4PARC,,		:find it
	SKIPAD(.LEPA0)			:has to be there
LGCV10	JAL	R9,PCIE 		:get id of octet number
	JAL	R9,PCIE 		:get len of node number
	LR	R0,R1
	JAL	R7,X4GTNM,,		:get this node # into r4
	LR	R1,R4			:move to write it
	lr	r15,r3			:save r3 for pcie
	JAL	R9,WHWI 		:escape if necc
	lr	r3,r15			:restore r3 for pcie
	SIS	R5,1			:couunt of how many till last
	JG	LGCV10
LGCV11	LHI	R4,ID.THS		:find term host
	JAL	R7,X4PARC,,
	SKIPAD(LGCV15)			:might not be there on rebuild needle
	JAL	R7,X4GTNM,,	
	STH	R4,CQHOST
	LR	R1,R4
	OHI	R1,8000 		:lead bit always set
	JFS	LGCV16
LGCV15	LHI	R1,8080 		:value of null host
LGCV16	JAL	R9,WHWI 		:write term host
	JAL	R8,WCI			:write whatever, we just want location
	L	R5,BE,R2,		:where to write CCT, hdx
	LHI	R4,ID.CCT		:now comes CCT
	JAL	R7,X4PARC,,
	SKIPAD(LGCV18)			:who knows if rebuild has this
	JAL	R7,X4GTNM,,
	JFS	LGCV19
LGCV18	LIS	R4,0			:it had no CCT
LGCV19	OHI	R4,0C0			:always with those bits
	STB	R4,0,R5 		:save it
	LHI	R4,ID.HDX		:and set hdx bit
	JAL	R7,X4PARC,,
	SKIPAD(LGCV20)
	JAL	R9,PCIE 		:get indication
	LR	R1,R1
	JEFS	LGCV20  		:not HDX
	LB	R1,0,R5 		:set HDX bit
	OHI	R1,NF.HDX
	STB	R1,0,R5 		:save it with HDX set
::  while x40 bit of second byte of user flags is documented as being the
::  collect call indication, node code versions prior to 5.30 use the bit
::  to support a different type of LOG I needle sent by supes sometime prior
::  to 1983.  thus the x40 bit cannot be used for collect call. 	###sdw

LGCV20	LHI	R1,80			:2nd byte of user flags
	JAL	R8,WCI
	LHI	R4,ID.OHS		:get requesting host
	JAL	R7,X4PARC,,
	SKIPAD(LGCV26)
	JAL	R7,X4GTNM,,
	LHI	R1,8000,R4		:
	JFS	LGCV27
LGCV26	LHI	R1,8080 		:orig host unknown
LGCV27	JAL	R9,WHWI 		:write OHOST

:	now append username, retain parity
:	add null (80) so username len ends up even.  Supe sends it in
:	uname field for log I dest but not for log i passthrough, which
:	doesn't make much sense.
:	Bug fixed at LGCV30 which used to set mark parity for uname ###10/04/93

	LHI	R4,ID.UNM		:get username it
	JAL	R7,X4PARC,,
	SKIPAD(LGCVEX)
	LR	R5,R0			:copy to dec till get to end
	LR	R6,R5			:even/odd indicaton
	LR	R4,R3			:Setup PCIER4
LGCV30	JAL	R9,PCIER4		:get the char
	JAL	R9,WCIE			:write the char with parity saved
	SIS	R5,1
	JGBS	LGCV30			:do all logon chars
	THI	R6,1			:odd len?
	JEFS	LGCVEX			:nope, all done
	LHI	R1,80			:get null
	JAL	R8,WCI			:and write it

LGCVEX	JAL	R8,CBCCT		:how big did needle end up?
	L	R4,LEPAS2		:where len byte goes
	STB	R1,0,R4
	L	CHN,LEPAS3		:restore chn
:	patch to put the data in the password MO immediately after the
:	needle when the destination is LOG I.				###sdw
	LB	R0,NEDFLG		:First make sure dest is LOG I
	THI	R0,L2F.N2		:bit is 1 if dest log I
	JE	LGCVP9			:dest log II, nothing to do
	LHI	R4,ID.PWD		:and if password present
	JAL	R7,X4PARC,,
	SKIPAD(LGCVP9)			:not there so exit
	LR	R6,R0			:get length
	LR	R4,R3			:setup PCIER4
LGCVP2	JAL	R9,PCIER4,,		:get a char
	JAL	R9,WCIE 		:write it
	SIS	R6,1
	JGBS	LGCVP2
	LHI	R1,8D			:supe striped CR off
	JAL	R8,WCI
LGCVP9	L	R9,LEPAS1
	JR	R9

:	LEPADN	finds the destination node in the needle node list
:		links on R7 and trashes the usual (0-9 except r2,chn)

LEPADN	ST	R7,LEPAS1		:save link
	ST	R5,LEPAS2		:save chn#
	LHI	R4,ID.NNL
	JAL	R7,X4PARC,,
	SKIPAD(LEPADX)			:jump to exit
	LHL	R5,CQNLK		:number of links in list
LEPAD2	JAL	R9,PCIE 		:get id of octet string
	JAL	R9,PCIE 		:get len of number
	LR	R0,R1			:save len
	JAL	R7,X4GTNM		:get node number
	SIS	R5,1
	JGBS	LEPAD2
LEPAD3	L	CHN,LEPAS2
	L	R7,LEPAS1
	JR	R7

LEPADX	LIS	R4,0			:mark that node list found
	JBS	LEPAD3

       EI	:LOGII(1-NCSLOT)


:	LPAFLG  does the rather messy task of converting all of LOG 2's
:		flags into the flags field normally present after the
:		invoice number.  Must have R6 setup from X4PARS.  Needed
:		for reporting rebuild stuff to supe and for CRQ parallel
:		processing of LOGI and LOGII needles.
:		trashes r0-r9 except r2 and r5.  r6 will be changed but
:		still setup for X4PARC.
:		Returns bits for both CCN and NCN
:		returns the bits in R4

       IF	LOGII

LPAFLG	ST	R7,LEPAS4		:save link
	ST	CHN,LEPAS5		:save chn
	LHI	R5,8080 		:these always set
	LHI	R4,ID.CNF		:CCN flags?
	JAL	R7,X4PARC,,	
	SKIPAD(LPAF02)
	JFS	LPAF03			:found CCN flags so process it
LPAF02	LHI	R4,ID.NCF		:then try to find NCN flags
	JAL	R7,X4PARC,,
	SKIPAD(LPAF06)			:neither flags found
LPAF03	JAL	R9,PCIE 		:get byte of unused bits
	JAL	R9,PCIE 		:get bits
	THI	R1,L2F.CC		:command circuit
	JEFS	LPAF04
	OHI	R5,NF.CMD		:set command bit
	OHI	R5,NF.PRI		:command circuits are priority too
LPAF04	THI	R1,L2F.RC		:rebuild circuit?
	JEFS	LPAF06
	OHI	R5,NF.REB		:yes
LPAF06	LHI	R4,ID.TPC		:get speed bits
	JAL	R7,X4PARC,,
	SKIPAD(LPAF10)			:if not there then 0
	JAL	R7,X4GTNM
	NHI	R4,3			:only have room for 2 bits
	SLLS	R4,4			:speed bits are 0030
	OR	R5,R4			:add em in
LPAF10	LHI	R4,ID.RIX		:iix capable?
	JAL	R7,X4PARC,,
	SKIPAD(LPAF16)
	JAL	R9,PCIE
	LR	R1,R1
	JEFS	LPAF16
	LHI	R0,NF.SMC		:iix indicator flag
	OR	R5,R0
LPAF16	LHI	R4,ID.IRC		:handle IRC
	JAL	R7,X4PARC,,
	SKIPAD(LPAF20)
	JAL	R7,X4GTNM
	NHI	R4,0F			:only four bits for IRC
	SLLS	R4,0A
	OR	R5,R4
LPAF20	LHI	R4,ID.COS		:batch or interactive?
	JAL	R7,X4PARC,,		:find it
	SKIPAD(LPFA28)
	JAL	R7,X4GTNM
	THI	R4,L2F.BT		: values 0-3 not batch, 4-7 are batch
	JNFS	LPFA28
	LHI	R4,NF.BAT		:batch circuit request
	OR	R5,R4			:add in batch type
LPFA28					:for any other flag finding
	LR	R4,R5			:return flags in R4
	L	CHN,LEPAS5
	L	R7,LEPAS4
	JR	R7

       EI	:LOGII

       IF	LOGII&(1-NCSLOT)


:	LEP0AZ	handles case of got CCN after user zapped circuit.
:		Logic is very simple.  Toss CCN then call ZAPV to clear
:		out circuit (only 1/2 exists).

LEP0AZ	LIS	R0,0
	STH	R0,BF,R2,		:port no longer in logon mode
	XHI	R2,4			:zap towards supe direction
	JAL	R9,ZAPV,,		:clear out circuit
	LHL	R2,LEPINB
	LR	R0,LRC			:toss CCN
	JAL	R8,RTBFTS
	J	lepxit			:and exit

       ELSE	 :not LOGII
LEP0A	EQ	LEPXT			:legal only if LOGII		###wjl
	EI	:LOGII


	SUBTTL	LEP (LEP0B - Type B:  Circuit trace request)

::*********************************************************************
::
::	COMMAND:	LEP0B:
::	FUNCTION:	PROCESS TRACE REQUEST (TYPE 0B)
::
::*********************************************************************

LEP0B	JAL	R9,GHWI			:DISCARD NODE NUMBER,
	JAL	R9,GHWI			:AND TYPE
	LI	R1,03008001		:INIT TRACE HEADER
	ST	R1,LEPMES
	JAL	R9,GHWI			:HOST #
	STH	R1,LEPMES+4
	JAL	R9,GHWI			:PORT #
	STH	R1,LEPMES+6
	LHI	R1,MACHNM
	STH	R1,LEPMES+8
	LIS	PRD,0A			:TRACE NEEDS THIS INITIALIZED

	LHL	R1,LEPMES+4		:RECOVER HOST #
	IF	SUPER
	LHI	CHN,SUPZFL
	CI	R1,0FFFE
	JE	LEP0B1
	EI	:SUPER
	J	LEP0B3			:if not super, then host	###sln

LEP0B1	AH	CHN,LEPMES+6		:CHN=ABSOLUTE PORT #
LEP0B2	NHI	R1,7FFF
	JAL	R10,TRACE		:TRACE WIL REJECT REQUEST IF CHN=0
	J	LEP1			:DONE

LEP0B3	NHI	R1,7FFF			:TRACE FROM A HOST ON THE NODE
	JEFS	LEP0B7			:HOST = 0 IS A WILD-CARD for disp ports
	LIS	CHN,0			:CLEAR CHN IN CASE WE REJECT TRACE REQ
	JAL	R9,FNDHST		:MAKE SURE THE HOST EXISTS
	SKIPAD(LEP0B2)			:CAN'T FIND HOST, REJECT TRACE REQUEST
	LHI	CHN,INTZFL		:+4 return, BASE = FIRST KERNEL PORT
	LR	HN,HN			:IF FNDHST RETURNS WITH INDEX = 0...
	JE	LEP0B1			:IT IS THE KERNEL (HOST0)
LEP0B7	LHI	CHN,DISZFL		:IT'S A DISPATCHER PORT		##TZ
	J	LEP0B1

	SUBTTL	LEP (LEP0C - Type C:  Sleeping pills)

::*********************************************************************
::
::	COMMAND:	LEP0C:
::	FUNCTION:	PROCESS PILLS  (TYPE 0C)
::
::*********************************************************************

LEP0C	HS	0
       IF	SUPER
	JAL	R9,GHWI			:DISCARD NODE # AND TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:GET FIRST BYTE (SUP # + 80)
	IF	SUPER
	LR	R8,R1			:NEW INTERFACE, REPORT OF SENDING SUP #
	NHI	R8,7F
	EI	:SUPER
	LIS	R0,0
	LHL	R1,TVRSTT		:IS SUP FROZEN?
	SIS	R1,3
	JE	lepxit			:SUP FROZEN IGNORE

	JAL	R9,SIROOM,,		:ROOM IN SUP INPUT RING?
	CLHI	PRC,8
	JLE	lepxit			:THIS SUP A HEAVY SLEEPER...
	STH	R0,SIB,PRD,		:CHANNEL 0
	AIS	PRD,2
	JLFS	LEP0C1
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP

LEP0C1	LIS	R0,2			:LRC = 2
	STH	R0,SIB,PRD,
	AIS	PRD,2
	JLFS	LEP0C2
	SHI	PRD,SUPBSZ

LEP0C2	LHI	R0,8000,R8		:PILL WITH SENDING SUP NUMBER
	STH	R0,SIB,PRD,
	LIS	PRD,6			:6-BYTE RECORD
	AH	PRD,NISI,,		:INCREMENT SIB LEAD POINTER
	JLFS	LEP0C3
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
LEP0C3	STH	PRD,NISI,,		:STORE NEW SIB RING INDEX
	EI	:SUPER
	J	lepxit			:IF NOT A SUP'S BASE, JUST EXIT

	SUBTTL	LEP (LEP0D - Type D:  Message for ports in login mode)

::*********************************************************************
::
::	COMMAND:	LEP0D:
::	FUNCTION:	PROCESS LOGIN MESSAGES
::
::*********************************************************************

:	Format of messages is :
:	[node#],[0D,n+flags],[port#],<# chars>,<char>,...,<char>

LEP0D	JAL	R9,GHWI			:DISCARD NODE # AND TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:SAVE FIRST BYTE
	LR	R7,R1
	JAL	R9,GHWI			:ABSOLUTE PORT#
	NHI	R1,7FFF			:strip HOB of port # (ANITAB index)
	LR	CHN,R1			:port # becomes CHN
	LR	R6,R2			:SAVE SUP BUFF #
	LHL	R2,IOTAB,CHN,CHN	:MAKE SURE THAT THE PORT IS THERE
	NHI	R2,-4

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LPDDB1,,
	LM	R0,REGST		:restore regs		###sdw
	LR	R2,R2
	EI	:LPGDBG

::Departure for Gateway logins
	IF	T2GATE
	JN	GLP0DD,,
	ELSE
	JN	LEP0DD			:YES, PROCEED
	EI	:T2GATE
LEP0D4	LR	R2,R6			:NO CIRCUIT OR CKTKEY DOESN'T MATCH
	CLHI	R7,10			:IS THERE ADDIT STUFF? (R7 is n+flags)
	JN	LEP1			:NO, GO BYE
	JAL	R8,GCI			:CHAR COUNT
	LR	R1,R1			:is it escaped?
	JNFS	LEPD10			:non-zero means not escaped
	JAL	R8,GCI			:if escaped, second byte is the count
LEPD10	LR	LRC,R1			:count becomes log record count
LEPD20	JAL	R8,GCI			:read out a data byte
	SIS	LRC,1			:	and decrement counter
	JGBS	LEPD20			:go while we have it
	J	LEP1			:return when we don't no more

       IF	1-T2GATE	:this section not for gateway

LEP0DD	XHI	R2,4			:flip to port bound buffer(.ALBUF+4)
	LHI	R1,TILIM		:SEND 03-12  PAIR TO PORT IN LOGIN
	JAL	R9,W2CI
	LR	R1,R7			:GET CODE BYTE, e.g n + flags
	lr	r0,r1
	sis	r0,8			:remove bias
	nhi	r0,1f			:only save type
	stb	r0,dlgsts-diszfl,chn,	:store curent logon status
	NHI	R7,1F			:mask down to five bits in work reg 7
	TBT	R7,EXLGMG		:EXPAND LOGIN MESSAGE ?
	JE	LEP0DE			:NO
	SHI	CHN,DISZFL		:RELATIVE CHANNEL NO.
	TBT	CHN,DISELS		:CHECK ELS BIT - IF SET, NO TEXT
	JN	LEP0DF			:NO TEXT
	J	LEP0D3			:SEND TEXT
LEP0DE	CLHI	R7,10			:NO
	JEFS	LEP0DG			:IF 10, THERE'S ADDITIONAL STUFF
LEP0DF	JAL	R8,WCI			:WRITE CODE STATUS BYTE IN TO PORT
	J	LEP0DA
LEP0DG	XHI	R1,18			:MAKE IT INTO A $2 XXX01000
	JAL	R8,WCI

       EI	:1-T2GATE

::A reentry point for Gateway log-ins
GLPEI4	LR	R7,R2			:PORT INPUT BUFF SAVE(.ALBUF+4, solocs)
	LR	R2,R6			:BYTE COUNT OF STRING FROM R6(LEP buff)
	JAL	R8,GCI			:GET (ESCAPED) LENGTH
	LR	R1,R1			:is it escaped?
	JNFS	LEPD30
	JAL	R8,GCI			:else second byte is count
LEPD30	LR	LRC,R1			:write count to buffer (R6)
LEP0DB	LR	R2,R6			:R6 is LEP buffer
	JAL	R8,GCI			:move string from LEP buffer to port
	LR	R2,R7			:R7 is port input buffer
	JAL	R8,WCI
	SIS	LRC,1
	JGBS	LEP0DB
	LR	R2,R6			:KLUDGE TO CIRCUMVENT SUP BUG
	LH	R1,BCT,R2,		:INSURE BUFFER NOT EMPTY
	JEFS	LEP0D1
	JAL	R8,GCI
	CLHI	R1,80			:REMOVE FOLLOWING NULL, IF ANY
	JEFS	LEP0D1
	JAL	R8,WCD
LEP0D1	LR	R2,R7
::	Gateway log-on response processing reenters here
:	INDICATE THAT SUP HAS SAID 'GO AHEAD'
LEP0DA	XHI	R2,4			:GET OPPOSITE BUFFER
	LH	R1,BF,R2,		:GET CURRENT BUFFER FLAG
	CLHI	R1,LOGMIN		:VERIFY IN LOGIN MODE
	JL	LEP1
	CLHI	R1,LOGMAX
	JG	LEP1			:OUT OF RANGE
	OHI	R1,LOGSUP		:SET SUP 'OK' BIT
	STH	R1,BF,R2,
	J	LEP1			:ALL DONE

:	EXPAND CANNED MESSAGE
LEP0D3	SHI	R7,13			:FIRST MESSAGE IS 13X
	LHL	R7,EXLGTB,R7,R7		:GET TABLE ENTRY		###CY
	LA	R7,SEGD,R7,		:changed to seg D	9/27/87	###sdw
	LB	LRC,0,R7
	NHI	R1,0E0			:MSG TYPE="SEND NO MESSAGE"(CONTINUE)
	OHI	R1,8			:EMPTIERS EXPECT BIAS OF 8
	JAL	R8,WCI
	LHI	R1,8D			:KLUDGE TO SIMULATE SUP MESSAGE WITH
	JAL	R8,WCI			:EXTRA CARRIAGE-RETURN
LEP0D2	LB	R1,1,R7			:GET CHARACTER
	JAL	R8,WCI
	AIS	R7,1			:NEXT CHAR.
	SIS	LRC,1
	JGBS	LEP0D2			:LOOP
	LHI	R1,8D8A			:INSERT TRAILING CARRIAGE-RETURN,
	JAL	R9,WHWI			:LINE-FEED...
	J	LEP0DA			:MESSAGE COPIED

EXLGMG	HC	0000,1FFE (13-1E)	:EXPAND LOGIN MESSAGE

	SUBTTL	LEP (LEP0E - Type E:  Aux circuit message)
::*********************************************************************
::
::	COMMAND:	LEP0E:
::	FUNCTION:	PROCESS AUX CIRCUIT MESSAGE (TYPE E)
::
::*********************************************************************

       IF	T2GATE			:not used for gateway		###sdw
LEP0E	EQ	LEPXT			:just gobble if msg found
       ELSE

LEP0E	JAL	R9,GHWI			:DISCARD NODE & TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:GET SUBTYPE
	LR	R7,R1
	JAL	R9,GHWI			:PORT #
	LR	CHN,R1
	NHI	CHN,7FFF		:RESET HI-ORD BIT
	LHL	R2,IOTAB,CHN,CHN
	NHI	R2,-4
	JE	LEP1			:NO SUCH CIRCUIT
	LHL	R1,BF,R2,		:MAKE SURE ITS IN LOGIN
	CLHI	R1,LOGMIN
	JL	LEP1
	CLHI	R1,LOGMAX
	JG	LEP1
	CLHI	R7,80			:DO WE SEND REST OF LOGIN
	JN	LEP0EZ			:ERROR
	LH	R0,BF,R2,		:GET OLD FLAG,
	OHI	R0,LOGSUP		:SET SUP 'OK' BIT
	STH	R0,BF,R2,
	J	LEP1

LEP0EZ	XHI	R2,4			:SOME ERROR
	LIS 	R1,3
	JAL	R8,WCI			:RETURN LOGRR MESSAGE
	LHI 	R1,LOGRR&0FF
	JAL	R8,WCI
	LR 	R1,R7
	JAL	R8,WCI			:FOLLOWED BY ERROR CODE
	LIS	R0,0
	XHI	R2,4
	STH	R0,BF,R2,		:CLEAR BUFFER FLAG
	LR	R6,R2
	JAL	R9,LOGCLR		:REMOVE ENTRY FROM LOGGER LIST
	J	LEP1			:ALL DONE

       EI	:T2GATE

	SUBTTL	LEP (LEP0F - Type F:  General supervisor commands)

::*********************************************************************
::
::	COMMAND:	LEP0F:
::	FUNCTION:	PROCESS GENERAL SUP COMMANDS (TYPE F)
::
::*********************************************************************

LEP0F	JAL	R9,LEPGMS		:COPY MESSAGE TO BUFFER
	LB	R1,LEPMES+1
	SHI	R1,88			:RANGE CHECK 0F SUBTYPE
	JL	LEP1			:ERROR - TOO LOW
	CLHI	R1,LEPN0F
	JG	LEP1			:ERROR - TOO HIGH
	SLLS	R1,2			:FW indexing			###wjl
	L	R1,LEP0FT,R1,		:				###wjl
	JR	R1			:				###wjl

::*********************************************************************
::
::	SUBTYPE:	LEPHTM:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 08:  SEND HOST GMT
::
::*********************************************************************

:	GET SUP TIME FOR NODECODE AND/OR ISIS.
LEPHTM	TS	GETGMT			:GET GMT FOR NODE CODE ONLY IF WE ARE
					:BEING TAKEN OVER AFTER CRASH, GMTGET=0
	JL	LEPHT1			:DON'T BOTHER, GO DO ISIS.

	L	R1,SLOWC,,		:SLOWC BASE TIME.
	ST	R1,GMTSLC		:STORE IT.
	ST	R1,SUPSLC		:FOR CRASH TABLES
	L	R1,LEPMES+4		:GET GMT IN HEX SEC'S
	ST	R1,SUPTIM		:FOR CRASH TABLES
:	NOW WE REDUCE R1 (HEX GMT) TO THE NO. OF SEC'S SINCE THE
:	BEGINNING OF THE CURRENT YEAR, PLUS A DAY'S WORTH.  THIS SO THAT
:	DAY 0 MEANS WE HAVEN'T YET GOTTEN GMT FROM THE SUP.
	SI	R1,$A((1992-1973)*365*24*3600)+(((1992-1972)/4)*24*3600) :R1= NO. SEC'S SINCE START
					:OF 1992 (A LEAPYEAR BOUNDARY)
:	FOR EFFICIENCY, PRECEDING LINE SHOULD BE MODIFIED AFTER EVERY LEAPYEAR.
:	NOTE: THIS WILL GO WRONG IN THE YEAR 2000. BEWARE!
LEPHT7	CI	R1,$A(4*365*24*3600)+(24*3600)	:HAS A LEAPYEAR PASSED SINCE?
	JLEFS	LEPHT2			:NO, SO SKIP
	SI	R1,$A(4*365*24*3600)+(24*3600)	:ADJUST FOR QUADYEAR PASSED
	JBS	LEPHT7			:AND CHECK AGAIN
LEPHT2	LIS	R0,1			:IF R0 GOES TO 4 (WRAPS TO 0) = LEAP YR
	LI	R6,$A(365*24*3600)	:SEC'S IN NORMAL YEAR
LEPHT5	CR	R1,R6			:HAS A YEAR PASSED?
	JLEFS	LEPHT6			:NO, SO SKIP
	LBR	R0,R0			:LEAPYEAR?
	JEFS	LEPHTC			:YES, MUST BE LAST DAY OF LEAPYEAR,SKIP
	AIS	R0,1			:A YEAR CLOSER TO A LEAPYEAR
	NHI	R0,3			:MOD 4
	SR	R1,R6			:ADJUST FOR NORMAL YEAR PASSED
	JBS	LEPHT5			:CHECK AGAIN
LEPHT6	LBR	R0,R0			:LEAPYEAR?
	JNFS	LEPHT4			:NO, SKIP
LEPHTC	AI	R6,$A24*3600		:ADD A DAY'S WORTH FOR CURRENT LEAPYEAR
LEPHT4	AI	R6,$A24*3600		:SEE NEXT COMMENT
	AI	R1,$A24*3600		:ADD DAY'S WORTH OF SEC'S, WHEN CONVERT
					:TO HUMAN FORM WE NEVER GET A DAY 0
					:UNLESS HAVEN'T BEEN HERE TOP GET GMT
	ST	R1,GMTHEX		:BASE GMT HEX SEC'S:GMTSLC
	SLLS	R1,7			:FORMAT FOR GMTCNV
	ST	R1,XLCRSH		:TIME OF LAST CRASH FOR ND DISPLAY
	ST	R6,CYRMAX		:MAX SEC'S IN CURRENT YEAR
	STH	R0,CYRCOD		:CURRENT YEAR TYPE (0-3) 0=LEAPYEAR
	L	R0,XFIRST		:IS THIS THE FIRST TAKEOVER SINCE LOAD?
	JNFS	LEPHTD			:XFIRST ALREADY HAS 1ST TAKEOVER TIME
	ST	R1,XFIRST		:YES, STORE FIRST TAKEOVER TIME
	L	R1,SUPTIM		:GET UNADULTERATED TAKE TIME
	ST	R1,TAKETI		:FOR CRASH TABLE

:	SOME LINES CAME UP BEFORE TAKEOVER, SO THEY HAVE ATT TIMES THAT
:	ARE NOT GMT. WE NOW ADJUST THEM TO GMT.
LEPHTD	LHI	R6,(NLINES-1)*4		:CHECK EACH LINE - FW INDEX
LEPHT8	L	R0,LINTIM,R6		:GET TIME FOR LINE
	JEFS	LEPHT9			:IF 0 IGNORE
	SRLS	R0,7			:ADJUST FROM GMTCNV FORMAT
	L	R1,GMTHEX		:GET BASE GMT
	SR	R1,R0			:FIND GMT FOR LINE
	CI	R1,$A24*3600		:IF < 1 DAY, TIME IS IN PREVIOUS YEAR
	JLFS	LEPHTA			:GO FIGURE
LEPHTB	SLLS	R1,7			:GMTCNV FORMAT
	ST	R1,LINTIM,R6		:STORE LINE GMT
LEPHT9	SIS	R6,4			:NEXT LINE
	JGE	LEPHT8			:IF ANY MORE

	JFS	LPHTM1			:CONTINUE

LEPHTA	AI	R1,$A365*24*3600	:ASSUME PREV YEAR NORMAL
	LHL	R0,CYRCOD		:CURRENT YEAR CODE
	SIS	R0,1			:PREV YEAR LEAPYEAR IF/ONLYIF CYRCOD=1
	JNBS	LEPHTB			:GMT OK
	AI	R1,$A24*3600		:ADD FOR LEAPYEAR
	J	LEPHTB

:	SOME HOSTS REPORTED STATUS BEFORE TAKEOVER, SO THEY HAVE HOST
:	STATUS TIMES THAT ARE NOT GMT. WE NOW ADJUST THEM TO GMT.
:	(USED FOR EXPANDED HOST STATUS)
LPHTM1	LHI	R6,0			:HW INDEX INTO HOST TABLES
LPHTM8	LHL	R0,HOSTN,R6		:CHECK FOR HOST ENTRY
	JE	LPHTM9			:NO ENTRY, SKIP
	L	R0,HSTTIM,R6,R6		:GET HOST STATUS TIME FOR ADJUSTMENT
	SRLS	R0,7			:ADJUST FROM GMTCNV FORMAT
	L	R1,GMTHEX		:GET BASE GMT
	SR	R1,R0			:FIND GMT FOR HOST
	CI	R1,$A24*3600		:IF < 1 DAY, TIME IS IN PREVIOUS YEAR
	JLFS	LPHTMA			:GO FIGURE
LPHTMB	SLLS	R1,7			:GMTCNV FORMAT
	ST	R1,HSTTIM,R6,R6		:STORE HOST GMT
LPHTM9	AIS	R6,2			:NEXT HOST TABLE HW INDEX
	CLHI	R6,NHOSTS^1		:AT END OF HOSTS TABLES
	JL	LPHTM8			:IF ANY MORE HOSTS
	JFS	LEPHT1			:CONTINUE
LPHTMA	AI	R1,$A365*24*3600	:ASSUME PREV YEAR NORMAL
	LHL	R0,CYRCOD		:CURRENT YEAR CODE
	SIS	R0,1			:PREV YEAR LEAPYEAR IF/ONLYIF CYRCOD=1
	JN	LPHTMB			:GMT OK
	AI	R1,$A24*3600		:ADD FOR LEAPYEAR
	J	LPHTMB

LEPHT1	IF	(1-T2GATE)		:ONLY APPLIES TO DISPATCHER HOSTS
       IF	1-NCSLOT 		:allow NC to run as slot
	LIS	R0,8			:WAIT FOR ROOM
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:get the fill pointer
	LHI	R1,INSTTM^8		:TIME MESSAGE			###jhl
	ST	R1,DIRNG,R6,		:put it in the ring
	AIS	R6,4
	NHI	R6,DRSZ-4
	L	R1,LEPMES+4		:GMT
	ST	R1,DIRNG,R6,
	AIS	R6,4
	NHI	R6,DRSZ-4
	STH	R6,DRIF,,
       EI	:1-NCSLOT
	EI	:(1-T2GATE)		:###EV
       if	swtchr			:if switchr pass gmt to isis via svc
	lhl	r0,verno,,		:first see if isis supports the svc
	clhi	r0,$a1400		:v14 or later
	jl	lep1			:nope, exit
	lis	r0,1			:telling isis gmt
	L	R1,LEPMES+4		:GMT
	svc	sys,$a 60		:tell isis gmt via svc
       ei	:swtchr
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPBRZ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 09: STOP TALKING TO NODE
::
::*********************************************************************

LEPBRZ	LHL	R1,LEPMES+2		:LOAD NEIGHBOR NUMBER
	JAL	R9,FNDLNK,,		:ZAP LINK IF UP
	SKIPAD(LEPB10)			:immediate return		###wjl
:	borzap inverted by sdw
	rBT	KN,BORZAP		:+4 return
LEPB10	NHI	R1,7FFF 		:RESET HIGH-ORDER BIT		###wjl
	LHI	R5,(BGLSIZ-1)*2
LEPB30	LH	R0,BGLIST,R5
	JEFS	LEPB20			:IF NO ENTRY, GO MAKE ENTRY
	CR	R1,R0			:SEE IF THIS A DUPLICATE	###wjl
	JEFS	LEPB40			:DUPLICATE, SO RETURN		###wjl
	SIS	R5,2			:PREPARE TO CHECK NEXT ENTRY OR
	JGBS	LEPB30			:IF LIST FULL, REUSE FIRST ENTRY
LEPB20	STH	R1,BGLIST,R5		:MAKE ENTRY IN BAD GUY LIST
LEPB40	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPBRU:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0A: START TALKING TO NODE
::
::*********************************************************************

LEPBRU	LHL	R1,LEPMES+2		:LOAD NEIGHBOR NUMBER
	JAL	R9,FNDLNK,,		:FIND LINK
	SKIPAD(LEPBR2)			:TRLINK HAS PROBABLY RESET BORZAP##wjl
:	borzap inverted by sdw
	sBT	KN,BORZAP		:+4 ret, PROBABLY REDUNDANT, BUT SAFE
LEPBR2	NHI	R1,7FFF 		:RESET HIGH-ORDER BIT		###wjl
	LIS	R0,0
	LHI	R5,(BGLSIZ-1)*2
LEPBR6	CLH	R1,BGLIST,R5
	JNFS	LEPBR4
	STH	R0,BGLIST,R5		:REMOVE ENTRY FROM BAD GUY LIST
LEPBR4	SIS	R5,2
	JGEBS	LEPBR6
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPRBJ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0B:  REBUILD ABORTED
::
::*********************************************************************

	IF	REBILD

LEPRBJ	L	R1,LEPMES+2		:REB REJECT - GET INVOICE #
	ST	R1,CQINV
	JAL	R9,FNDCRQ		:LOCATE CIRCUIT
	SKIPAD(LEPRBX)			:immed ret, CIRCUIT NOT FOUND	###wjl
	LR	R2,R6			:+4 return, RETURNS OUTBOUND BUFF IN R6
       if	t2gate!acct
	lis	r0,aalr03
	sth	r0,aareas
       ei
	XHI	R2,4			:INBOUND BUFF
	JAL	R9,ZAPHRD		:BYEBYE CIRCUIT
       if	t2gate!acct
	lis	r0,0
	sth	r0,aareas
       ei
LEPRBX	J	lepxit

	ELSE	:NOT REBILD

:	DESTINATION NODE WITH NO REBUILD CAPABILITY RECEIVED A REBUILD
:	REJECT COMMAND FROM SUPERVISOR AND DOES NOT KNOW HOW TO HANDLE
:	THE COMMAND...			:###wjl
LEPRBJ	J	lepxit			:###wjl
	EI	:REBILD

::*********************************************************************
::
::	SUBTYPE:	LEPDLL:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0C:  DLOAD COMMAND (GO TO BOOT)
::
::*********************************************************************

LEPDLL	LHL	R0,HNPORT		:# OF ACTIVE PORTS (TYMSAT+KERNEL+ISIS)
	OHI	R0,8000
	STH	R0,SUPMBF+2		:FORMAT FOR REPORT TO SUPERVISOR LOG
	LHL	R0,PASTHR
	OHI	R0,8000			:NUMBER OF PASSTHROUGHS + 8000
	STH	R0,SUPMBF+4
	LHI	R0,NR.DLD		:NODE REPORT TYPE
	STH	R0,SUPMBF
	JAL	R10,SUP12		:SEND THE REPORT
	TS	DLDFLG			:SET DLOAD FLAG FOR THE 4-SECOND LOGIC
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPZLI:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0D:  LOGIN ZAPPER CONFIRMATION
::
::*********************************************************************

LEPZLI	LHL	CHN,LEPMES+2		:ZAPPER CONFIRMATION ON LOGIN
	NHI	CHN,7FFF		:PORT #

:	same logic for log II log zap confirmation			###sdw
LEPZL3	LHL	R2,IOTAB,CHN,CHN	:GET CHN'S OUTBOUND BUFFER
	NHI	R2,-4

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LPZDB1,,
	LM	R0,REGST		:restore regs		###sdw
	LR	R2,R2
	EI	:LPGDBG

	JE	LEP1			:NOTHING THERE
	LHL	R1,BF,R2,		:entry point for LOG II logon zap acks
	CLHI	R1,LOGMIN		:HAS NEEDLE BEEN SENT DOWN YET  ??
	JL	LEPZL0		
	CLHI	R1,LOGMAX
	JLE	LEPZL1

:	NEEDLE HAS BEEN SENT DOWN ALREADY	###LSH
:	ZAP IN BOTH DIRECTIONS
LEPZL0	LHI	R1,ZAPPN		:NON-GOBBLING TYPE ZAPPER
	JAL	R9,ZAPX			:CLEAR HALF CIRCUIT (TO DISPATCHER)
					: AND SEND ZAP DOWN TO HOST
	JAL	R8,GFCBUF		:GET ANOTHER BUFFER PAIR
	SKIPAD(OP8463)			:immed. return - out of buffers!###wjl
	JAL	R9,CRQHCR		:+4, BUILD HALF CIRCUIT (TO DISPATCHER)
	XHI	R2,4			:SWITCH TO CHN'S INCOMING BUFFER
	JAL	R9,ZAPHRD		:SEND ZAP TO DISPATCHER

	J	LEP1

:	NEEDLE HAS NOT BEEN SENT YET.  WE CAN RETURN BUFFER, AND
:	STOP CIRCUIT RIGHT HERE.

LEPZL1	LIS	R0,0
	STH	R0,IOTAB,CHN,CHN	:CLEAR PERMUTER TABLE
	LR	R6,R2
	JAL	R9,LOGCLR		:REMOVE FROM LIST
	SBT	CHN,ACP,,		:MARK PORT AS AVAILABLE
	LCS	R0,1
	SR	R0,CHN
	SBT	R0,ACP,,		:NEGATIVE ACP MARKED AS AVAILABLE
	JAL	R8,RFCBUF		:RETURN BUFFER PAIR
	IF	T2GATE
	SHI	CHN,DISZFL		:make dispatcher port (relative chn)
	LHI	R1,9F00
	JAL	R8,DIRMES		:and free up port for dispatcher use
	EI	:T2GATE
	J	LEP1


::*********************************************************************
::
::	SUBTYPE:	LEPSPR:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0E:  SYNC PORT REQUEST
::
::*********************************************************************

LEPSPR	JAL	R10,SUPMHD		:SYNC LINE REPORT
	LHI	R1,148D			:RETURN TYPE '14'
	JAL	R9,WHWI
	LHI	R1,NLINES+8080
	JAL	R9,WHWI
	LIS	R5,0
LEPSP1	LHL	R1,NGSVLN,R5,R5
	NHI	R1,0BFFF		:ERRONEOUS NGHBR NOT REPORTED AS SIO
	IF	SILINS
	CLHI	R5,NLINES-SILINS
	JLFS	LEPS20
	OHI	R1,4000
LEPS20	HS	0
	EI	:SILINS
	JAL	R9,WHWI
	AIS	R5,1
	CLHI	R5,NLINES
	JLBS	LEPSP1
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPLSP:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0F:  LINK SPEED REQUEST
::
::*********************************************************************

LEPLSP	JAL	R10,SUPMHD		:LINK SPEED REQUEST 0F/0F
	LHI	R1,148E
	JAL	R9,WHWI
	LHL	R1,LEPMES+2		:GET NEIGHBOR IN QUESTION
	NHI	R1,7FFF
	JAL	R9,WHWI			:RETURN #
	JAL	R9,FNDLNK
	SKIPAD(LEPLS1)			:immed return, NO SUCH NEIGHBOR	##wjl
	LB	R1,KSPD,KD		:+4 return
	NHI	R1,7F
	JNFS	LEPL10
LEPLS1	LCS	R1,1			:LINK IS DOWN
LEPL10	JAL	R9,WHWI
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPHRJ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 10:  HOST REJECT COMMAND
::
::*********************************************************************

LEPHRJ	HS	0			:HOST REJECT MESSAGE,SENT TO DISPATCHER
       IF	1-NCSLOT
	LIS	R0,8			:CHECK FOR ENOUGH ROOM
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:GET FILL INDEX FOR RING
	LHL	R1,LEPMES+2		:GET HOST NUMBER
	NHI	R1,7FFF
	CLHI	R1,HST0			:KERNEL HOST NUMBER?
	JE	LEPHR9			:YES, handle it
	JAL	R9,FNDHST		:RETURNS HN AS HOST # INDEX
	SKIPAD(LEP1)			:immed, REJECT A HOST WE DON'T HAVE#wjl
	LB	R0,HSTKEY,HN		:+4 return, "KEY" (4*SLOT #)
	AHI	R0,0B00			:TYPE B MSG - REJECT
	ST	R0,DIRNG,R6,		:INTRA-ISIS MSG ON RPORT 0 (UPPER HW)
	AIS	R6,4			:UPDATE POINTER
	NHI	R6,DRSZ-4
:	RETURN HOST NUMBER, ERROR REASON=1 FOR HOST REJECT BY SUPERVISOR
	EXHR	R1,R1			:HOST NUMBER IN UPPER HALFWORD,
	AHI	R1,0100			:REASON=01 IN FOLLOWING BYTE
	ST	R1,DIRNG,R6,		:PUT IT AWAY TOWARDS OFFENDING SLOT
	AIS	R6,4
	NHI	R6,DRSZ-4		:UPDATE POINTER
	STH	R6,DRIF,,
	LIS	R0,0
	STH	R0,HOSTN,HN,HN		:CLEAR HOST ENTRY

:	CLEAR EXPANDED HOST STATUS INFORMATION
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R0,00C0			:CLEAR BITS 2,3,4,5 OF LO BYTE	###OAS
	STB	R0,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY,STORE CURRENT TIME#OAS
	SRLS	HN,1			:RESTORE HN#			###OAS
       EI	:1-NCSLOT
	J	LEP1

:	here if rejected host is our kernel host.  If gateway then crash
:	otherwise ignore (taking any action might be worse than not doing
:	anything					###10/18/93
       IF	1-T2GATE
LEPHR9	EQ	LEP1			:ignore msg
       ELSE	:gateway
LEPHR9	LIS	R0,1			:get error code (1 is reject by sup
	STH	R0,CRYSBF		:save for crypto message
	LHI	R0,HST0			:rejected host number
	JAL	R8,CRYPTO,,		:send crypto message
	 HC	CRYE3F			:
	CRASH.(.DISHH)			:gateway crash with reject HHOST
       EI	:1-T2GATE

::*********************************************************************
::
::	SUBTYPE:	LEPBGL:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 11:  REPORT BAD-GUY LIST
::
::*********************************************************************

LEPBGL	JAL	R10,SUPMHD		:REPORT THE BAD GUYS LIST  (14/12)
	LHI	R1,1492			:TYPE 14, SUBTYPE 12
	JAL	R9,WHWI
	LHI	R1,8080
	LHI	R5,(BGLSIZ-1)*2
LEPBG1	LH	R0,BGLIST,R5		:COUNT HOW MANY ON LIST
	JEFS	LEPBG4
	AIS	R1,1
LEPBG4	SIS	R5,2
	JGEBS	LEPBG1
	JAL	R9,WHWI
	LHI	R5,(BGLSIZ-1)*2
LEPBG2	LH	R1,BGLIST,R5		:NOW SEND THEM IN
	JEFS	LEPBG6
	OHI	R1,8000
	JAL	R9,WHWI
LEPBG6	SIS	R5,2
	JGEBS	LEPBG2
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPRKD:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 12:  REMOVE NEIGHBOR
::
::*********************************************************************

:	NEIGHBOR NUMBER TO REMOVE IS IN LEPMES+2. RESPONSE IS A REPORT TO
:	LOG (TYPE 12), WITH 3 HALFWORDS, AS FOLLOWS:
:	*HW1* 4 (SUBTYPE 4)
:	*HW2* NEIGH # + 8000
:	*HW3* STATUS + 8080
:		=1 FOR NEIGHBOR NUMBER REMOVED
:		=2 FOR NEIGHBOR NUMBER NOT FOUND

LEPRKD	LHL	R1,LEPMES+2
	STH	R1,SUPMBF+2		:SAVE NEIGHBOR NUMBER FOR RESPONSE
	NHI	R1,7FFF
	JAL	R9,FNDLNK		:GET LINK DESCRIPTOR FOR THIS NEIGHBOR
	SKIPAD(LEPRK4)			:immediate return, NOT FOUND	###wjl
	LB	R7,NLAT,KD		:+4, ANY LINES ATTACHED TO THIS LINK?
	JEFS	LEPRK2			:NO - LINK DOWN

:	LINK TO BE REMOVED IS UP - TEAR IT DOWN
	JAL	R10,TRLINK,,		:ZAP CIRCUITS, MARK LINK INACTIVE
	LHI	R4,13A4			:REPORT LINK OUT BY COMMAND
:	(NOTE R7=0 FROM TRLINK, WHICH DETERMINES LINK STATUS IN SUP13)
	JAL	R10,SUP13		:REPORT LINK DOWN TO SUP

LEPRK2	LIS	R0,1			:INDICATE NEIGHBOR NUMBER REMOVED
	JFS	LEPRK6
LEPRK4	LIS	R0,2			:INDICATE NEIGHBOR NUMBER NOT FOUND
LEPRK6	STH	R0,SUPMBF+4		:(HW3)
	LIS	R0,NR.RLK
	STH	R0,SUPMBF		:REPORT TO LOG, SUBTYPE 4
	JAL	R10,SUP12
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPAKD:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 13:  ADD NEIGHBOR
::
::*********************************************************************

:	NEIGHBOR NUMBER TO ADD IS IN LEPMES+2. DESIRED WINDOW SIZE + 8000 IS
:	IN LEPMES+4. IF SPECIFIED WINDOW SIZE IS 0, THEN ANY AVAILABLE LINK
:	WILL DO. RESPONSE IS A REPORT TO LOG (TYPE 12), WITH 3 HALFWORDS,
:	AS FOLLOWS:
:	*HW1* 5 (SUBTYPE 5)
:	*HW2* NEIGH # + 8000
:	*HW3* STATUS
:		=8000 + WSIZ IF NEIGHBOR ADDED
:		=FF00 + WSIZ IF LINK SPACE AVAILABLE BUT NO WSIZ MATCH
:		=FFFF IF NO LINK SPACE AVAILABLE

LEPAKD	LIS	R0,NR.ALK		:SET UP RESPONSE MESSAGE
	STH	R0,SUPMBF		: (REPORT TO LOG, SUBTYPE 5)
	LHL	R2,LEPMES+4
	STH	R2,SUPMBF+4		:SAVE WINDOW SIZE + 8000
	NHI	R2,7FFF
	LIS	R3,0			:R3 IS FLAG FOR ANY LINK FOUND
	LHL	R1,LEPMES+2
	STH	R1,SUPMBF+2		:NEIGHBOR # + 8000
	NHI	R1,7FFF
	STH	R1,LEPMES+2		:STORE BACK FOR LEPBRU (8000 BIT OFF)
:	SCAN ALL LINKS FOR AVAILABLE LINK DESCRIPTOR
	LHI	KN,NLINKS-1
LEPAK2	SLLS	KN,1
	L	KD,KDKN,KN,KN
	SRLS	KN,1
	LH	R0,NDID,KD		:IS LINK SPACE FREE?
	JNFS	LEPAK4			:NO
	LR	R2,R2			:YES - WSIZ SPECIFIED?
	JE	LEPAK6			:NO - ANY SIZE WILL DO
	CLH	R2,WSIZ,KD		:TEST FOR MATCH ON WINDOW SIZE
	JEFS	LEPAK6			:YES - ADD NEIGHBOR TO THIS LINK
	LCS	R3,1			:FLAG FOR LINK FOUND BUT WSIZ MISMATCH
LEPAK4	SIS	KN,1
	JGE	LEPAK2			:SCAN ALL LINKS
:	ALL LINK DESCRIPTORS EXAMINED - NO MATCH FOUND
	STB	KN,LEPMES+4		:INDICATE NEIGHBOR NOT ADDED
	LR	R3,R3			:DID WE REJECT DUE TO WSIZ MISMATCH?
	JLFS	LEPAK5			:YES - RETURN REQUESTED WINDOW SIZE
	STB	KN,LEPMES+5		:NO, ABSOLUTELY NO LINK SPACE AVAILABLE
LEPAK5	JAL	R10,SUP12		:REPORT TO LOG
	J	LEPBRU			:INSURE NEIGHBOR NOT ON BAD GUY LIST

LEPAK6	STH	R1,NDID,KD		:RESERVE LINK DESCRIPTOR FOR THIS NGHBR
	STH	R1,ONDID,KD
	JBS	LEPAK5			:REPORT AND CLEAN BAD GUY LIST

::*********************************************************************
::
::	SUBTYPE:	LEPNOP:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 14:  SUP NOP COMMAND -
::			TIMING DIAGNOSTIC REQUEST
::	FORMAT:	[0F,n+80]    where n=14
::		[time
::		 time]       Sup data to return intact
::		[8000+count] Return count messages
::*********************************************************************

:	THE SUP NOP COMMAND IS USED TO TIME ROUND TRIP OF SUP MESSAGES TO
:	INDIVIDUAL NODES BY PASSING AND HAVING RETURNED ITS OWN 'FASTC'. IN
:	ADDITION, AN ARTIFICIAL LOAD CAN BE CREATED SINCE THE THIRD HALFWORD
:	CONTAINS A LOOP COUNTER. THE LOOP COUNTER INDICATES THE NUMBER OF
:	RESPONSES TO RETURN FOR THIS COMMAND. RESPONSE IS A TYPE 14,
:	SUBTYPE 15, WITH 5 HALFWORDS, AS FOLLOWS:
:	*HW1* SUP FASTC
:	*HW2* SUP FASTC+2
:	*HW3* DECREMENTING LOOP COUNTER
:	*HW4* NODE FASTC
:	*HW5* NODE FASTC+2

LEPNOP	LHL	R15,LEPMES+6		:GET LOOP COUNTER AND
	NHI	R15,7FFF		:ISOLATE
	JE	LEP1			:SUP GENERATING ONE-WAY LOAD DOWNSTREAM

	L	R0,LEPMES+2		:MOVE SUP FASTC TO SAVE AREA IN
	ST	R0,LEPNSF		:CASE WE INTERRUPT TO OBSERVE BP LIMIT

:	NUMBER OF RESPONSE MESSAGES IS BASED ON LOOP COUNTER IN R15
LEPNP2	JAL	R10,SUPMHD		:SET UP MESSAGE HEADER
	LHI	R1,1415
	JAL	R9,WHWI			:TYPE 14, SUBTYPE 15
	LHL	R1,LEPNSF
	JAL	R9,WHWI			:RETURN SUP FASTC
	LHL	R1,LEPNSF+2
	JAL	R9,WHWI			:AND FASTC+2
	LR	R1,R15
	OHI	R1,8000			:INCLUDE LOOP COUNTER
	JAL	R9,WHWI
	LHL	R1,FASTC,,
	JAL	R9,WHWI			:RETURN NODE FASTC
	LHL	R1,FASTC+2,,
	JAL	R9,WHWI			:AND FASTC+2
	SIS	R15,1			:DECREMENT LOOP COUNTER
	JLE	lepxit			:DONE
	LHL	R0,BCT,R2,
	CLHI	R0,CIRSP3		:HAVE WE REACHED BACKPRESSURE LIMIT?
	JLE	LEPNP2			:NO - CONTINUE
	ST	R15,LEPNPF		:YES - COME BACK FROM 'SWITCH'
:	TO CHECK FOR OUTPUT DRAINED. HIGH-ORDER HW FLAGS BRANCH TO LEPNP4.
	J	lepxit

:	CONTINUATION POINT FOR SUP NOP PROCESS
LEPNP4	LHL	R15,LEPNPF+2		:RESTORE LOOP COUNTER
	J	LEPNP2

	SUBTTL	LEP (LEP10 - Type 10:  Port status request)

::*********************************************************************
::
::	COMMAND:	LEP TYPE 10:
::	FUNCTION:	PORT STATUS REQUEST
::
::*********************************************************************

LEP10	JAL	R9,GHWI			:DISCARD NODE & TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:PORT GROUP #
	LR	R15,R1			:TO REG 15
	JAL	R9,GHWI			:HOST #
	LR	R14,R1			:TO REG 14
	JAL	R10,SUPMHD		:CREATE HEADER
	LHI	R1,148B
	JAL	R9,WHWI
	LR	R1,R14			:HOST #
	JAL	R9,WHWI

:	TEST FOR LINK PORT STATUS REQUEST
:	IF 40 BIT OF PORT GROUP BYTE SET R14 = NODE#
	THI	R15,40
	JN	L10LNK			:YES, LINK PORT STATUS REQUEST

	LR	R1,R14			:GET HOST #
	NHI	R1,7FFF			:CLEAR HI-ORD BIT
	JNFS	LEP10A			:IF HOST <> 0 SKIP

:	HOST = 0, REPORT ALL DISPATCHER PORTS IN USE
	LHI	R6,(NDP+7)/8		:NUMBER OF BYTES OF ACP TO CHECK
	LA	R7,DISACP,,		:GET START ADDR OF DISPATCHER ACP ARRAY
	J	LEP10C			:PROCESS

LEP10A	CLHI	R1,7FFE			:IS IT THE SUP?
	JE	LEP10E

	JAL	R9,FNDHST		:HOST, FIND IT
	SKIPAD(LEP10G)			:immed ret, WE DONT KNOW HIM	###wjl
	CLHI	R1,HST0			:+4 return, HOST = KERNEL ?
	JN	LEP10D			:NO,REPORT DISPATCHER HOST PORTS IN USE
	LHI	R6,(10+NKU+07)/8	:YES, SET UP # OF PORTS (internal+KIO
	LHI	R7,INTACP,		:SET UP START OF internal PRTS

:	REPORT ACTIVE PORTS BY SENDING SUP COMPLEMENTED 'ACP' ARRAY
:	SO THAT AN ACTIVE PORT IS INDICATED BY A BIT SET
LEP10C	LIS	R5,8
	NHI	R15,3F
	LR	R1,R15			:RESPOND WITH
	OHI	R1,8080			:PORT GROUP + 8080
	SLLS	R15,4			:GET NUMBER OF BYTES OFFSET FOR GROUP
					:16d BYTES PER GROUP
	AR	R7,R15			:ADD TO EXISTING OFFSET
	CI	R7,DISACP+(NDP+7)/8
	JGE	LEP10X			:INVALID, COMPUTED ADDRESS OUT OF RANGE

	JAL	R9,WHWI			:ADDR OK, SEND PORT GROUP +8080 TO SUP
	SR	R6,R15			:GET MAX # OF NON-ZERO BYTES TO SEND
	LCS	R10,1			:COMPLEMENT ACP SO 1'S FOR ACTIVE PORTS
LEP10F	LHL	R1,0,R7			:GET A PORT GROUP
	XR	R1,R10			:MAKE ACTIVE PORTS ONES
	LR	R6,R6			:ZERO PAD IF NEEDED
	JGFS	LEP10H
	LIS	R1,0
LEP10H	JAL	R9,WHWI
	AIS	R7,2			:GO TO NEXT GROUP
	SIS	R6,2
	SIS	R5,1
	JGBS	LEP10F
	J	LEP1			:ALL DONE

:	RETURN PORTS IN USE BY SPECIFIED HOST
LEP10D	LR	R14,R1			:SAVE HOST NUMBER
	LR	R1,R15			:REQUESTED PORT GROUP 
	OHI	R1,8080			:+ 8080
	JAL	R9,WHWI			:RETURN PORT GROUP NUMBER
	NHI	R15,3F			:ISOLATE RELEVANT BITS AND
	EXBR	R15,R15			:COMPUTE HW OFFSET FOR PORTS TO EXAMINE

L10D10	CLHI	R15,NDP*2		:OUT OF RANGE FOR DISPATCHER PORTS?
	JGE	L10D40			:YES - MARK REMAINING PORTS UNUSED...
	LIS	R1,0			:R1 CARRIES 1 BIT FOR EACH PORT IN USE
	LIS	CHN,0			:INIT CHN FOR THIS GROUP OF 10
L10D20	LHL	R0,DHSTIX,R15,CHN	:GET HOST # FOR CIRCUIT ON THIS PORT
	CR	R0,R14			:IS THIS THE HOST SPECIFIED?
	JNFS	L10D30			:NO
	OH	R1,HMSK,CHN,		:YES - TURN ON BIT FOR THIS PORT
L10D30	AIS	CHN,2
	THI	CHN,1E			:DONE WITH THIS GROUP OF 10?
	JNBS	L10D20			:NO
	JAL	R9,WHWI			:YES - PASS IT ON

	AHI	R15,20			:INCREMENT TO NEXT GROUP OF 10 PORTS
	THI	R15,0FE			:DONE WITH PSTAT?
	JN	L10D10			:NO
	J	LEP1			:YES - RETURN TO LEP COMMAND PROCESSOR

:	PAD REMAINING PORT ENTRIES WITH ZEROS
L10D40	LIS	R1,0
	JAL	R9,WHWI			:UNUSED PORTS...
	AHI	R15,20
	THI	R15,0FE			:DONE?
	JNBS	L10D40			:NO
	J	LEP1			:YES - RETURN

LEP10E	LA	R7,SUPACP,,		:SUPERVISOR ACP ADDRESS
	LHI	R6,(NSP+07)/8		:# OF GROUPS
	J	LEP10C

:	PORT STATUS REQUEST IS FOR LINK. FIND LINK DESCRIPTOR, 
:	ACP OFFSET, AND NUMBER OF CHANNELS TO SCAN.
L10LNK	LR	R10,R15			:GET PORT GROUP BYTE AND
	NHI	R10,3F			:ISOLATE PORT GROUP NUMBER
	LR	R1,R14			:GET NODE NUMBER AND
	NHI	R1,7FFF			:MASK OUT HIGH-ORDER BIT
	JAL	R9,FNDLNK		:FIND LINK DESCRIPTOR FOR THIS NEIGHBOR
	SKIPAD(LEP10G)			:immed, NEIGHBOR DOES NOT EXIST	###wjl
	TBT	KN,ALINKS		:+4 return, IS LINK ACTIVE?
	JE	LEP10G			:NO, SEND REPORT TO SUP

	LHL	R7,FLDPKN,KN,KN
	LA	R7,LNKACP,R7,		:ADDRESS OF ACP ARRAY FOR THIS LINK
	LHL	R6,NCHN,KD		:NUMBER OF CHANNELS ASSIGNED TO LINK
	SRLS	R6,3			:NCHN/8 = # BYTES OF ACP FOR THIS LINK

	LR	R15,R10			:RESTORE R15 FOR PSTAT RESPONSE, LEP10C
	SLLS	R10,4			:PORT GROUP*10=BYTE DISPLACMNT INTO ACP
	LR	R9,R6			:NUMBER OF BYTES OF ACP ARRAY TO SCAN
	SR	R9,R10			:MINUS PORT GROUP OFFSET IS POSTIVE?
	JG	LEP10C			:GO FORMAT PSTAT RESPONSE

LEP10X	OHI	R1,200			:ARRAY OUT OF RANGE,
	JFS	LEP10V			: SEND 8080+200+ARRAY#
LEP10G	LHI	R1,8180			:NODE/HOST UNKNOWN,
					: SEND 8080+100+PORT ARRAY#
	NHI	R15,3F			:EXTRACT PORT ARRAY NUMBER
	OR	R1,R15			:INCLUDE PORT ARRAY NUMBER INTO R1
LEP10V	JAL	R9,WHWI			:SEND ERROR RESPONSE TO SUP
	LIS	R5,8			:SEND 8 HW OF 1'S
	LCS	R1,1
LEP10B	JAL	R9,WHWI			:RETURN -1 FOR PORT GROUP #
	SIS	R5,1
	JGBS	LEP10B
	J	LEP1

	SUBTTL	LEP (LEP11 - Type 11:  Assign channel to TYMNET-I)

::*********************************************************************
::
::	COMMAND:	LEP11:
::	FUNCTION:	04-APR-87 UNUSED AT THIS TIME
::
::*********************************************************************

LEP11	EQ	LEPXT		:go to the gobble msg routine


	SUBTTL  LEP (LEP12 - RCRM - Log II login response)

::*********************************************************
:
:	LEP12	The reponse/reject logon message (NCRM).
:		Idea is to pass it to dispatcher unchanged unless
:		it is a logon zapper ack.  If it is the zap ack then
:		we can finally set that port to be reused
::*********************************************************

       IF	LOGII&(1-NCSLOT)	:only if LOG 2 Dispatcher

LEP12
	JAL	R9,GHWI 		:remove node #
	JAL	R9,GHWI 		:remove type (12) and unused byte
	L	R3,BB,R2,		:setup for peek
	JAL	R9,PHWI 		:get logical (not counting escs) len
	LHI	LRC,2,R1		:save it (in R14) PWHI returns it in r1
	LHI	R4,ID.PRT		:get our chn number first
	JAL	R7,X4PARS		:find chn #
	SKIPAD(LEP12A)			:crash if no chn
	JAL	R7,X4GTNM		:get the chn
	LR	CHN,R4			:put chn in normal register
	LR	R11,R2			:save supe's buffer #
	LHL	R2,DIOTAB,CHN,CHN	:get port's buffer #
	NHI	R2,-4			:knock off any speed bits
	JNFS	LEP12B			:make sure a buffer is there
	LR	R2,R11			:gobble supe msg
LEP12A	JAL	R9,GCIE 		:we have a logical len
	SIS	LRC,1			:another logical char read out
	JGBS	LEP12A			:gobble our lep 12 msg
	LIS	R0,1
	AHM	R0,NC.LPE		:another lep error
	J	LEP1

LEP12B	XHI	R2,4
	LHI	R4,ID.RMF		:find our flags
	JAL	R7,X4PARC,,		:continue parse
	SKIPAD(LEP12A)			:gobble msg if no rcrm flags
	JAL	R9,PCIE 		:get the number of unused bits
	JAL	R9,PCIE 		:the first byte of the bits
	THI	R1,L2F.ZA		:is this a zapper ack?
	JN	LEP12Z			:joins LEP type 0F subtype 0D of
					:logon zapper confirmation (LEPZLI)
	LHI	R1,L2SRJT		:message for log 2 terminal
	JAL	R9,W2CI
	LR	R7,R2			:make a copy of the term buffer
LEP12D	LR	R2,R11			:get supe buff back
	JAL	R9,GCIE 		:get 1st char
	LR	R2,R7			:get term buff back
	JAL	R9,WCIE
	SIS	LRC,1
	JGBS	LEP12D			:copy it all
	XHI	R2,4
	LH	R1,BF,R2,		:make sure port still in login mode
	CLHI	R1,LOGMIN		:
	JL	LEP1			:too low, just return
	CLHI	R1,LOGMAX		:
	JG	LEP1			:too big, just return (let it fix itself
	OHI	R1,LOGSUP		:supe ready to receive
	STH	R1,BF,R2,
	J	LEP1


:	zap circuit after gobbling rest of this msg
LEP12Z	LR	R2,R11			:lep buffer
LEP12Y	JAL	R9,GCIE 		:gobble the zap ack msg
	SIS	LRC,1
	JGBS	LEP12Y
	AHI	CHN,DISZFL		:get back to absolute chn
	J	LEPZL3			:goto log I log zap ack logic

       ELSE	:not LOGII
LEP12	EQ	LEPXT			:if not LOG2 then illegal msg	###wjl
       EI	:LOGII

	SUBTTL	LEP (LEPZAP:  Handle command circuit zapper)

::*********************************************************************
::
::	LEPZAP:
::	FUNCTION:	PROCESS ZAPPERS ARRIVED ON COMMAND CIRCUITS
::
::*********************************************************************

LEPZAP	HS	0			:ZAPPER ON COMMAND CIRCUIT

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LEPDB1,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	LHI	R0,LEPZFL,CHN		:GET ABSOLUTE CHANNEL NUMBER AND
	RBT	R0,TRCHAN,,		:TURN OFF TRACING FOR THIS CHANNEL
	JAL	R8,PCI
	CLHI	R1,GOBBL&0FF		:TEST FOR ZAPPER
	JL	LEPZA2			:YES - COMPLETE CIRCUIT TEARDOWN
:	AN 03-CHARACTER PAIR WHICH IS NOT A ZAPPER IS RATHER ANOMALOUS...
:	ZAP COMMAND CIRCUIT, AND ISSUE NODE REPORT
	OI	R1,0FFFF0300
	ST	R1,SUPMBF+2		:SHOW WHAT WE GOT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R1,NR.I3C
	STH	R1,SUPMBF		:INDICATE INVALID 03-CHARACTER PAIR
	JAL	R10,SUP12		:SUP12 WILL BUFFER NODE REPORT
	JFS	LEPZA3			: UNTIL RE-TAKEN
LEPZA2
	JAL	R9,ZAPV			:GOT A ZAPPER - TEAR DOWN CIRCUIT
LEPZA3	IF	SUPER			:IF FROM OUR SUP, REBUILD CIRC
	LHL	R0,LIOTAB,,
	JNFS	LEPZA4
	JAL	R9,SUPCRQ
	EI	:SUPER
LEPZA4	LHL	R4,TVRBUF		:IS IT FROM REIGNING SUP?
	XHI	R4,4
	CLH	R4,LEPINB
	JN	lepxit			:NO, EXIT
	IF	T2GATE			:RPT TO INET SUP HST SHUT ##AL
	LIS	R3,HSHUT
	STB	R3,HSTAT		:we are shut
	JAL	R10,GHSTST,,		:HST STATUS TO INET SUP
	EI	:T2GATE
	LHL	R0,TVRSUP		:GET CURRENT SDUPERVISOR NUMBER
	JAL	R8,CRYPTO,,		:TELL XRAY
	HC	CRYE07			:MESSAGE = SUP CRQ LOST
	LIS	R0,0			:YES, NO MORE SUPER
	STH	R0,TVRBUF
	STH	R0,TVRSUP
	IF	(1-T2GATE)
       IF	1-NCSLOT 		:allow NC to run as a slot
	LIS	R0,8			:ROOM FOR NO SUP MSG
	JAL	R8,DIROOM,,
	LHI	R0,INNOSP^8		:NO SUP MESSAGE			###jhl
	LHL	R8,DRIF,,		:GET FILL POINTER
	ST	R0,DIRNG,R8,		:SAVE IT
	AIS	R8,4			:BUMP INDEX
	NHI	R8,DRSZ-1		:FIX WRAP
	STH	R8,DRIF,,
       EI	:1-NCSLOT
	EI	:(1-T2GATE)		:###EV

	J	lepxit

	SUBTTL	LEP (Utilities and tables)

::*********************************************************************
::
::	SUBROUTINE:	LEPGMS:
::	FUNCTION:	COPIES LEP MESSAGES TO INTERMEDIATE BUFFER
::	CALLING SEQ:	JAL	R9,LEPGMS
::
::*********************************************************************

LEPGMS	LA	R4,LEPNOD
	LHI	R6,-2,LRC
LEPGM1	JAL	R8,GCI
	LR	R1,R1
	JNFS	LEPG10
	JAL	R8,GCI
	SIS	R6,1
LEPG10	STB	R1,0,R4
	AIS	R4,1
	SIS	R6,1
	JGBS	LEPGM1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	SUPMHD:
::	FUNCTION:	CREATE A SUP MESSAGE HEADER
::	CALLING SEQ:	JAL	R10,SUPMHD
::
::*********************************************************************

SUPMHD	LHL	R2,TVRBUF
	JE	LEP1			:NO SUP, ABORT
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	JR	R10

::*********************************************************************
::
::	TABLE:		LEPDIS:
::	FUNCTION:	LEP DISPATCH TABLE
::
::*********************************************************************

LEPDIS	WC	LEP08,LEP09,LEP0A,LEP0B
	WC	LEP0C,LEP0D,LEP0E,LEP0F
	WC	LEP10,LEP11,LEP12
LEPDMX	EQ	(.-LEPDIS)/4		:NUMBER OF VALID LEP COMMANDS

::*********************************************************************
::
::	TABLE:		LEP0FT:
::	FUNCTION:	LEP0F SUBTYPE DISPATCH TABLE
::
::*********************************************************************

LEP0FT	WC	LEPHTM,LEPBRZ,LEPBRU,LEPRBJ
	WC	LEPDLL,LEPZLI,LEPSPR,LEPLSP
	WC	LEPHRJ,LEPBGL,LEPRKD,LEPAKD
	WC	LEPNOP
LEPN0F	EQ	(.-LEP0FT)/4	:NUMBER OF LEP 0F TYPE COMMANDS

	ENDMO.(LEP)
	EI	:1-KILLIT
	KILMSG(LEP)

:	***NOTHING PAST THIS POINT***

	SUBTTL	CRQ

:			 ***  ****   ***
:			*   * *   * *   *
:			*     ****  *   *
:			*   * *  *  *  **
:			 ***  *   *  ****
:					 *

::#####################################################################
::
::	MODULE:		CRQ
::
::	FUNCTION:	Circuit building, teardown, timeout, detach,
::		and trace routines.
::
::	SUBTTLS:
::		CRQ - Second half circuit building
::		Circuit building routines
::		Utilities
::		DETCIR - Handle data for 'Detached Ports'
::		TRACE - Circuit tracing logic
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG	a.code

::*********************************************************************
::
::	SUBPROCESS:	CRQ:
::	FUNCTION:	Completes the "second half" of the circuit-building
::			process.
::	SCHEDULED:	Like LOGGER, gets called when there is something in its
::		buffer (CRQBUF) by SWITCH.  Returns to SWITCH (CRQRET) when
::		done.
::		When LEP or RTD writes a needle into a buffer, it writes
::		the buffer's index into CRQBUF via CRQALT.  CRQ makes one
::		pass through this list of buffers, servicing as appropriate.
::
::*********************************************************************

:	Write a 00 marker into CRQBUF.  When we come to it,
:	we'll know we're thru.
CRQ	LIS	R2,0			:PUT A 0 MARKER IN THE CRQ BUFFER

:	Come back here to put a buffer back in CRQBUF for further processing
:	next time around.
CRQ10
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
	LR	R1,R2			:WRITE THE BUFFER # IN R2 INTO CRQBUF
	LIS	R2,CRQBUF		:R1=0 ON FIRST PASS, BUFFER # OTHERWISE
	JAL	R9,WHWI0,,		:WHWI0 ALLOWS USE OF BUFFER # 0

:	Come here to get the next buffer that needs service.
:	If it's our 0-marker, we're done, go to CRQRET.
CRQ20	LIS	R2,CRQBUF		:PROCESS NEXT BUFFER IN THE LIST
	JAL	R9,GHWI0		:BUFF IN WHICH NEEDLE IS ASSEMBLED
	LR	R2,R1
	JE	CRQRET,,		:IF THE 0 MARKER, WE'RE DONE

:	DO RANGE CHECK TO INSURE VALID BUFFER NUMBER
:	Buffer index must be in range (>=CIRZBF, <=HBUFN-8).
:	If not, crash. Else, continue at CRQ40.
	CLHI	R2,CIRZBF
	JLFS	CRQ30			:ERROR - TOO LOW
	CI	R2,HBUFN-8
	JLEFS	CRQ40			:BUFFER NUMBER O.K.
CRQ30	CRASH.(.CRQCR)			:Bad buffer index in CRQBUF

CRQ40	STH	R2,CQNBUF		:SAVE THE NEEDLE BUFF #
	IF	NDREAD
        IF      CBZDBG                  :use debugger rings instead of buffers
        STM     R0,REGST                :save all registers
        JAL     R14,NEDDB1,,            :save needle in debugger ring
        GL      NEDDB1
        LM      R0,REGST
        EI      :CBZDBG
        EI      :NDREAD

:	If the buffer's BF is marked for "intercept" (=INCPFL),
:	go handle at CRQINT.
	IF	REBILD
	LHL	R0,BF,R2,		:IF BF=INCPFL, IT'S AN 'INTERCEPT'
	CLHI	R0,INCPFL
	JE	CRQINT
	EI	:REBILD
:	If 1st byte in buffer not a possible needle point (03xx),
:	go to garbage-handler (CRQER1).
	JAL	R8,PCIS			:TEST FOR NEEDLE POINT
	CLHI	R1,NEEDP/100		:DO WE START WITH "03
	JN	CRQER1			:GARBAGE
	JAL	R8,PCI			:GOT AN 03 - LOOK AT NEXT BYTE
:	If 1st HW in buffer not a needle point (0310), go to CRQZOG.
       IF       LOGII                   :look for LOG II needles
        CLHI    R1,NEEDBD&0FF           :needle in waiting?
        JE      CRQLWT                  :test it for timout
        CLHI    R1,NEEDHD&0FF           :complete LOG II needle
        JE      CRQLG2                  :process it
       EI       :LOGII
	CLHI	R1,NEEDP&0FF		:IS IT "10
	JN	CRQZOG			:NOT NEEDLE POINT,SOME OTHER 03-XX PAIR
:	Got a needle point (via peeks only so far).
:	It should look like this in the buffer:
:		[0310]
:		[00cc] - byte count
:		[00ll] - link count
:		[iiii]
:		[iiii] - invoice number
:		[ffff] - 8080+flags
:		[nnnn] - origin node#
:		[pppp] - requesting port#
:		[mmmm] - node list (several of these HW's)
:	Get and save off these quantities via peeks
:	(i.e., leave the buffer as is).
	JAL	R8,PCI			:GOT NEEDLE - SKIP OVER LENGTH ESCAPE
	JAL	R8,PCI			:BYTE COUNT
	STH	R1,CQNSZ		:SAVE IT
	JAL	R8,PCI			:GET ESCAPE FOR LINK COUNT
	JAL	R8,PCI			:READ LINK COUNT
	NHI	R1,7F			:MASK HIGH ORDER BIT
	STH	R1,CQNLK		:AND SAVE LINK COUNT
	JAL	R9,PHWI			:READ 4 BYTES OF INVOICE #,HW AT A TIME
	STH	R1,CQINV		: AND STORE FOR LATER
	JAL	R9,PHWI			:READ SECOND HALFWORD
	STH	R1,CQINV+2		: AND STORE FOR LATER
	JAL	R9,PHWI			:GET FLAGS
	LR	R7,R1			:SET R7=FLAGS (+8080)
	STH	R1,CQNFLG		:SAVE THEM TOO
	JAL	R9,PHWI			:READ AND SAVE REQUESTING NODE
	STH	R1,CQNODE
	JAL	R9,PHWI			:READ AND SAVE REQUESTING PORT
	STH	R1,CQPORT

:	Now go through the node list, ignoring FFFF's (nodes already processed
:	by other nodes) until we find one that is not FFFF.  If the 8000 bit
:	is set, it should be us, go to CRQTRM.  If not, see if it's for an
:	active neighbor. If not (either active or a neighbor), go zap
:	the needle (CRQNNE).
CRQ50	LR	R5,R3			:SLEW OVER 'CREAMED' NODE #'S
	JAL	R9,PHWI			:READ NEXT NODE NUMBER
	CI	R1,0FFFF		:ALREADY PROCESSED AT ANOTHER NODE?
	JEBS	CRQ50			:IF -1, IT WAS CROSSED OFF
:	if tracing then this is the easiest place to save all info needed to
:	determine if this needle fits the auto trace criteria.  note that we 
:	cannot enable tracing until end of crq when we know both chn numbers.
	if	autrac
	lh	r9,autrun,,		:is trace even running
	je	crq521			:no so save the effort
	stm	r0,regst
	ti	r1,8000			:are we dest node?
	jefs	crq505
	lhi	r5,machnm
	jfs	crq510
crq505	ti	r1,8000			:term host?
	jnfs	crq510			:yes
	lr	r5,r1			:save previous node number
	jal	r9,phwi
	ti	r1,8000
	jebs	crq505
crq510	nhi	r1,7fff			:save actual host
	sth	r1,cqhost		:normally saved only at destination
	sth	r5,cqdnod		:dest node
	JAL	R9,PCIE			:This is TID
	nhi	r1,3f
	STB	R1,CQTID		:Save for matching purposes
	JAL	R9,PCIE			:rest of user flags
	JAL	R9,Phwi			:WHICH MAY BE ESCAPED
	nhi	r1,7fff
	sth	r1,cqohst
	LIS	R4,0			:COUNT USERNAME CHARS
	ST	R4,XUTMP		:CLEAR TEMP USERNAME AREA
	ST	R4,XUTMP+4		:FOR 12(D) CHARS
	ST	R4,XUTMP+8
	thi	r7,nf.cmd!nf.reb	:neither of these have usernames
	jn	crq520
	JAL	R8,PCI
	CLHI	R1,0A1			:= "!" ?
	JNFS	CRQ515
CRQ513	JAL	R8,PCI
CRQ515	NHI	R1,7F			:REMOVE MSB
	CLHI	R1,3B			:SEMICOLON?
	JEFS	CRQ520			:YES
	CLHI	R1,0D			:CARRIAGE RETURN
	JEFS	CRQ520			:YES
	STB	R1,XUTMP,R4		:USER NAME FOR VALIDATION
	AIS	R4,1			:BUMP CHAR COUNT
	CLHI	R4,0C			:UP TO 12(D) CHARS
	Jl	CRQ513			:LOOP UNTIL ALL USERNAME IS IN

CRQ520	lhl	r0,cqnflg		:get flags
	srls	r0,4			:save gouging and cost table
	nhi	r0,7
	stb	r0,cqgoug		:for later checking
	lm	r0,regst
crq521
	ei	:autrac
	TI	R1,8000			:ARE WE THE TERMINATION NODE?
	JN	CRQTRM			:YES--HIGH BIT SET 

CRQNOD	JAL	R9,FNDLNK		:FOR T-II NEIGHBOR - LOCATE LINK
	SKIPAD(CRQNNE)			:immed, NOT THERE, ZAP NEEDLE	###wjl
CRQ60	TBT	KN,ALINKS		:+4 ret, FOUND THE LINK, IS IT ACTIVE?
	JE	CRQNNE			:NOPE, ZAP NEEDLE

:	Got a needle for an active neighbor.
:	Check for shrink activity on link (SHSTAT) and if true (RMAKE frozen),
:	return this buffer to CRQBUF for later handling (go to CRQ10).
	LH	R0,SHSTAT,KD		:ANY SHRINK ACTIVITY?
	JN	CRQ10			:YES - RETURN BUFFER BACK TO CRQ LIST

:	EDITS COMPLETE ON DESTINATION LINK. CREAM NEIGHBOR NUMBER IN NEEDLE...
CRQ62	LR	R3,R5			:POINTER TO NEIGHBOR # ENTRY IN NEEDLE
	JAL	R9,CHWI			:STORE 'FFFF', CREAMS NEEDLE ENTRY

:	Find an available channel (JAL FNDKNC). If none, go to CRQER2.
CRQ64	LHL	R1,NCHN,KD		:NUMBER OF CHANNELS ON LINK
	JAL	R9,FNDKNC		:FIND AVAILABLE CHANNEL (RETURNS IN CHN)
	SKIPAD(CRQER2)			:immed return, OUT OF CHANNELS	###wjl

:	New channel better be available (IOTAB=0). If not,
:	go zap needle at CRQCHU.
CRQ70	LHL	R0,IOTAB,CHN,CHN	:+4 return, IS THERE A CIRCUIT THERE?
	JN	CRQCHU			:YES, ZAP NEEDLE

:	Got a good channel.  Bump count of circuits completed (NC.CRC) and
:	build the last half of the circuit.
CRQ72	LIS	R3,1
	AHM	R3,NC.CRC		:COUNT CIRCUITS COMPLETED

:	BUILD LAST HALF OF CIRCUIT...
:	Set up our BF and get the speed bits from the needle into R1.
:	If the source channel is not a link neighbor, go on to CRQ80.
	STH	CHN,BF,R2,		:STORE ONGOING CHANNEL NUMBER INTO BF

	IF	CBZDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CRQDB1,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:CBZDBG

	XHI	R2,4			:FLIP TO ONGOING CHANNEL'S BUFFER
	LHL	R3,BF,R2,		:READ INCOMING CHANNEL NUMBER INTO R3
	LR	R1,R7			:GET THE SPEED BITS FROM NEEDLE
	SRHLS	R1,4
	NHI	R1,3
	RBT	R3,PRIRTY,,		:default if not priority
	RBT	CHN,PRIRTY,,
	THI	R7,NF.PRI		:TEST FOR PRIORITY CIRCUIT
	JEFS	CRQ74			:NOT A PRIORITY CIRCUIT
	SBT	R3,PRIRTY,,		:indicate both directions is priority
	SBT	CHN,PRIRTY,,
CRQ74	CLHI	R3,LNKLFL		:IS INCOMING CIRCUIT FROM A NEIGHBOR?
	JGE	CRQ770			:NO, INTERNAL, SKIP NETWORK BOOKKEEPING
	CLHI	R3,LNKZFL
	JL	CRQ770
:	Needle came from a neighbor, need to set/reset various bits for the
:	incoming channel, some of them depending on needle flags.
	SBT	R3,BPSVCP-LNKZFL/8,,	:ENABLE RMAKE SERVICE OF THIS CHANNEL
	SBT	R3,LNKBPV-LNKZFL/8,,
	RBT	R3,CMDCTS-LNKZFL/8,,
        lhi     r0,200
        sth     r0,bpscnt-2*lnkzfl,r3,r3 :store xmit capability
	THI	R7,NF.CMD		:TEST FOR COMMAND CIRCUIT
	JEFS	CRQ76			:NOT A COMMAND CIRCUIT
	SBT	R3,CMDCTS-LNKZFL/8,,
:	if the other channel is for a link then this a passthrough.
:	inc the passthru count and other passthrough bookkeeping
CRQ76	CLHI	CHN,LNKZFL		:IS IT TOWARDS A NEIGHBOR?
	JL	CRQ80			:NO
	CLHI	CHN,LNKLFL
	JGE	CRQ80
	thi	r7,nf.cmd		:passthrough a cmd cir?
        jefs    crq765
        lis     r0,1
        ahm     r0,nbrcmd               :count cmd cir that are passthroughs
CRQ765	LHL	R0,PASTHR		:INCREMENT PASSTHROUGH COUNT
	AIS	R0,1
	CLH	R0,MXPASS		:NEW HIGH FOR # OF PASSTHRUS?
	JLEFS	CRQMPS			:NO
	STH	R0,MXPASS		:YES, STORE THE NEW PEAK
CRQMPS	ts	pasthc			:indicate a change to number of pthrus
	STH	R0,PASTHR
	jfs	crq78
:	fall down to here if originated on this node
:	do various bits to for outgoing chn
crq770	CLHI	CHN,LNKZFL		:IS IT TOWARDS A NEIGHBOR?
	JL	CRQ80			:NO
	CLHI	CHN,LNKLFL
	JGE	CRQ80
CRQ78	SBT	CHN,CHSRVD-LNKZFL/8,,	:MAKE SURE NEEDLE TRAVELS
	SBT	CHN,BPSVCP-LNKZFL/8,,
	RBT	CHN,CMDCTS-LNKZFL/8,,
:	Inc NEDOUT (count of needles outstanding between CRQ and RMAKE).
:	(Can't let a shrink occur while this is true.)
	LIS	R0,1			:INCREMENT # OF NEEDLES OUTSTANDING
	AHM	R0,NEDOUT,KD		:BETWEEN CRQ AND RMAKE

	SBT	CHN,NEEDLE-LNKZFL/8,,	:NEW NEEDLE FOR THIS CHANNEL
	SBT	CHN,lnkbpv-LNKZFL/8,,	:make sure needle can travel
	THI	R7,NF.CMD		:TEST FOR A COMMAND CIRCUIT
	JEFS	CRQ80			:NOT A COMMAND CIRCUIT
	SBT	CHN,CMDCTS-LNKZFL/8,,

:	Here after bookkeeping done for needle from one neighbor to another,
:	or from neighbor to internal termination.
CRQ80	LHL	R0,IOTAB,R3,R3		:GET THE INCOMING BUFFER NUMBER
	OR	R0,R1			:OR IN THE SPEED BITS
	STH	R0,IOTAB,R3,R3
:	Merge the speed bits (R1) from the needle flags into
:	the incoming channels IOTAB and complete the IOTAB entry
:	for the outgoing channel.  Mark the new channel active (+/-ACP),
:	report "circuit built" to CRYPTO (CRYE0B), set the inbound buffer's
:	attention flag if appropriate, and return to mainline via CRQ20.
CRQ83	AR	R1,R2			:MERGE SPEED BITS INTO OUTGOING BUFFER
	STH	R1,IOTAB,CHN,CHN	:AND COMPLETE THE PERMUTER TABLE ENTRY
	RBT	CHN,ACP,,		:ACTIVE PORT
::Report International Record Carrier for Inet login to Hnet link here!
	IF	T2GATE
	IF	IRC
	CHI	R3,DISZFL
	JL	CRQ84			:SKIP IF NOT USER CIRCUIT
	CHI	R3,DISZFL+NDP
	JG	CRQ84
	SHI	R3,DISZFL
	LR	R8,R3			:SAVE TO R8 FOR LATER USE
	LR	R3,CHN			:ABSOLUTE CHAN# TO HNET LINK
	JAL	R9,FCHLNK		:FIND LINK#
        GL      FCHLNK
	SKIPAD(CRQ84)			:immediate return, ERR RETURN	###wjl
        LR      R1,R0			:+4 ret, cannot index off of R0 ###sdw
	LB	R0,IRCTBL,R1		:FIND IRC VALUE FOR THIS LINK
	JE	CRQ84			:SKIP IF NO VALUE
	STB	R0,GB7REA		:STORE INTO CANNED MSG.
	STH	R8,GB7PRT		:R8 IS IRC REPORT DISP. RRT
	LHI	R1,0E00E		:MSG.# IS 14 FOR IRC LOCATN
	STH	R1,GB7INV		:Store anew message
	LIS	R1,0
	STB	R1,GB7INV+2		:(may have been previously used)
	LA	R1,GDB7M		:IRC REPORT
	LHI	R3,GDB7L		:LENGTH BYTE
	JAL	R8,DIZSMS,,		:REPORT TO INET SUP AT PORT 0
        GL      DIZSMS
CRQ84		
	EI	:IRC

	EI	:T2GATE

	if	autrac
	lh	r0,autrun,,
	jefs	crq842
	stm	r0,regst
	jal	r9,acktrc,,		:see if tracing should be enabled
	lm	r0,regst
crq842
	ei	:autrac

	LCS	R0,1
	SR	R0,CHN
	RBT	R0,ACP,,		:MARK NEGATIVE ACP AS WELL
	LHL	R0,BF,R2,		:CRYPTO - ONE OF THE PORTS
	tbt	r0,trchan,,		:is it being traced?
	je	crq105
:	needle needs to be traced if our traced port is not handled by RMK
:	which means the destination chn needs to be checked
	lr	r8,r2
	XHI	R8,4
	LHL	R8,BF,R8,		:THE destination channel
	clhi	r8,lnkzfl
	jlfs	crq104			:too low for lnk chn
	clhi	r8,lnklfl
	jlfs	crq105
crq104	xhi	r2,4			:to the buffer with the needle
	lr	r3,r0			:chn being traced
	lcs	r4,2			:input data
	jal	r9,nedtrc		:yes, save this trace data
	xhi	r2,4
	jal	r9,trtime		:save time of needle
crq105	EXHR	R0,R0			:SHIFT UP 
	XHI	R2,4
	LHL	R8,BF,R2,		:THE OTHER PORT
:	outgoing chn was not yet assigned when needle arrived. save trace
:	data
	tbt	r8,trchan,,		:did it come from a traced port?
	jefs	crq107			:nope
	lr	r3,r8			:the chn being traced
	lcs	r4,1			:outputdata
	jal	r9,nedtrc		:put needle data into trace ring
	jal	r9,trtime		:save time of needle
crq107	AR	R0,R8
	JAL	R8,CRYPTO,,
	HC	CRYE0B			:CRYPTO MESSAGE - CRQ BUILT

	LHL	R1,BCT,R2,		:ANYTHING IN BUFF?
	JEFS	CRQ111			:NIX, check passthroughs
	LHL	R1,BF,R2,		:SET ATTN FLAG
	SBT	R1,NFLAGS
CRQ111	LHL	R0,PASTHR               :section moved here from CRQ78  ###sdw
	CLHI	R0,NPASTH		:out of passthroughs?		###wjl
	JL	CRQ20			:no				###wjl
	LHL	R0,PTHRPD		:what was our last report?	###wjl
	JE	CRQ20			:zero=out of passthrus reported	###wjl
	JAL	R10,SUP0B		:make Resources Report to Sup	###wjl
	J	CRQ20			:RETURN TO MAINLINE

:	little subroutine to save data in buffer to the trace ring
nedtrc	STM	r0,regst		:SAVE SOME REGS
	jal	r8,cbcct,,		:get count
	lr	r6,r1			:save count
	l	r3,bb,r2,
nedtr1	lr	r7,r6			:count remaining to do
	shi	r6,$a 119		:max msgg size
	jlefs	nedtr2
	lhi	r7,$a 119
nedtr2	jal	r10,nedtr3		:save it away
	lr	r6,r6			:more to do?
	jgbs	nedtr1
	lm	r0,regst
	jr	r9			:done

trtime	stm	r0,regst
	LHI	TC,TRRSIZ-1		:POWER OF 2 RING WRAP MASK
	LHL	PRD,TRRIX		:GET CURRENT RING INDEX
	STH	R3,TRRING+2,PRD,	: ABSOLUTE CHANNEL NUMBER
	lhi	r0,-3			:for TIME
	STH	R0,TRRING,PRD,		:STORE I/O INDICATOR (time)
	LH	R0,FASTC+2,,
	STH	R0,TRRING+4,PRD,	:STORE CURRENT TIME
	lis	r7,8
	STH	r7,TRRING+6,PRD,	:STORE LOGICAL RECORD LENGTH
	AIS	PRD,8
	NR	PRD,TC

:	get time.  can't use GMT since switchers don't know GMT
	l	r0,gmt,,
	jgfs	trtim3
	l	r0,slowc,,
	s	r0,supslc		:time before takeover
	a	r0,suptim		:sup's time of takeover
trtim3	lis	r7,7
trtim4	lis	r1,0f			:convert to ascii time
	nr	r1,r0
	ohi	r1,30
	clhi	r1,39
	jlefs	trtim5
	ais	r1,7
trtim5	STB	R1,TRRING,r7,prd	: MOVE IT TO RING
	srls	r0,4
	sis	r7,1
	jge	trtim4
	AIS	PRD,8			:INCREMENT POINTERS
	NHI	PRD,TRRSIZ-8
	STH	PRD,TRRIX		:SAVE TRRING INDEX
	lm	r0,regst
	jr	r9

: save needles and any following data into the ring

nedtr3	lr	r7,r7			:is there any data for it to save?
	je	nedtr7			:no, just exit
	LHI	TC,TRRSIZ-1		:POWER OF 2 RING WRAP MASK
	LHL	PRD,TRRIX		:GET CURRENT RING INDEX
	lhl	r0,regst+r3*4+2
	STH	R0,TRRING+2,PRD,	: ABSOLUTE CHANNEL NUMBER
	lhl	r0,regst+r4*4+2
	STH	R0,TRRING,PRD,		:STORE I/O INDICATOR AND
	LH	R0,FASTC+2,,
	STH	R0,TRRING+4,PRD,	:STORE CURRENT TIME
	STH	r7,TRRING+6,PRD,	:STORE LOGICAL RECORD LENGTH
	AIS	PRD,8
	NR	PRD,TC

:	NOW MOVE LOGICAL RECORD TO TRRING. MUST MOVE A BYTE AT A TIME
:	SINCE HALFWORD ALIGNMENT NOT GUARANTEED.
nedtr5	jal	r8,pci
	STB	R1,TRRING,PRD,		: MOVE IT TO RING
	AIS	PRD,1			:INCREMENT POINTERS
	NR	PRD,TC
	SIS	r7,1			:DECREMENT COUNT
	JGBS	nedtr5			:MORE TO DO...
nedtr6	AIS	PRD,7			:ROUND INDEX UP TO NEXT DOUBLEWORD BND
	NHI	PRD,TRRSIZ-8
	STH	PRD,TRRIX		:SAVE TRRING INDEX
	lhl	r0,xtdato		:any ports doing auto display
	jefs	nedtr7
	lhi	r0,1f-pxray
	sbt	r0,squeue		:msg arrived, sched xray to disp it
	lhl	r0,xusiua
	sth	r0,xquem,,
nedtr7
	JR	R10			: RETURN


:	Here from CRQ50 if we are the destination of a needle.
CRQTRM	NHI	R1,7FFF			:TERMINATION - SAVE THE HOST #
	LR	HN,R1
CRQTRL	STH	HN,CQHOST               :entry point for log II logons

:	If it is a REBILD needle, skip to CRQREB.
:	If for an internal circuit,
:	skip to CRQTR3 (no need to make circuit rebuildable).
	IF	REBILD
	THI	R7,NF.REB		:IS REBUILD BIT IN NEEDLE FLAGS SET?
	JN	CRQREB			:YES, THIS IS A REBUILD NEEDLE
	LHL	R0,CQNLK		:IS ORIGIN IN THIS NODE (# LNKS=0)?
	JE	CRQTR3			:YES, CIRCUIT WILL NEVER NEED REBILDING

:	We are the termination of a new circuit that may be rebildable.
:	Save the invoice number for possible REBILD use, compute and save away
:	the max history buffer size (based on gouging level and number of
:	links in circuit), set/reset various REBILD bits, and stuff a SQFX0
:	into the buffer toward the circuit origin.
	LR	R4,R2			:FORM INDEX INTO INVOICE-NUMBER ARRAY
	SRHLS	R4,1			:BASED ON CIRCUIT BUFFER NUMBER
	lhl	r0,cqnode		:helpful in xray qc cmd
	sth	r0,rbase+hbufn,r4,
	lhl	r0,cqport		:helpful in xray qc cmd
	sth	r0,rhostn+hbufn,r4,
	L	R0,CQINV		:RECOVER THE INVOICE NUMBER
	ST	R0,RINVC+HBUFN,R4,	:AND SAVE FOR POSSIBLE FUTURE REBUILD
	LR	R5,R7			:COMPUTE HISTORY BUFFER SIZE
	HSIZE(R5)			:BASED ON THROUGHPUT CLASS	###CY
	STH	R0,RHBSZ+HBUFN,R4,	:STORE AWAY FINAL HISTORY BUFFER SIZE
	SRHLS	R4,2
	SBT	R4,CRQBSY		:MARK CREATION OF A REBUILDABLE CIRCUIT
	SBT	R4,CRQEND		:MARK CREATION OF A CIRCUIT TRMINATION
	RBT	R4,SQFTMO		:CLEAR REBUILD TIMEOUT BIT	###GT
	SBT	R4,SQFTMI		:SET BIT FOR TIMEOUT COUNTER	###GT
	XHI	R2,4			:FLIP TO OTHER BUFFER		###GT
	JAL	R9,SNDFX0		:SEND OUT SQFIX WITH SEQN = 0	###GT
	XHI	R2,4			:RESTORE BUFFER INDEX

	ELSE	:NOT REBILD
	THI	R7,NF.REB		:ZAP REBUILD NEEDLES
	JN	CRQZPN

	EI	:REBILD

:	If this is a command circuit, go to CRQLEP.
CRQTR3	THI	R7,NF.CMD		:IS THIS A COMMAND CIRCUIT?
	JN	CRQLEP			:YES, IT'S FOR THE LEP

:	Must be for a host.  If not HST0, must be ISIS host, go to CRQHS2.
CRQHST	LHL	R0,HNPORT		:INCREMENT NUMBER OF HOST PORTS IN USE
	AIS	R0,1
	CLH	R0,MXPORT		:IS THIS A NEW PEAK?
	JLEFS	CRQH03			:NO
	STH	R0,MXPORT		:YES, RECORD IT
CRQH03	STH	R0,HNPORT

	CLHI	HN,HST0			:CIRCUIT FOR A HOST
	IF	T2GATE
	JN	CRQHSZ			:Gateway should have a match w/HST0
	ELSE
	JN	CRQHS2			:FOR A DISPATCHER HOST
	EI	:T2GATE

:	Needle for internal host
	IF	(1-T2GATE)		:Gateway must save Needle for now
	JAL	R9,TRUNC		:DISCARD NEEDLE
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
	L	R3,BB,R2,		:INTERNAL HOST, CHECK USER NAME
	EI	:(1-T2GATE)		:Gateway discards it next time around
					:and does not need a reload of R3
	JAL	R9,PCIE			:This is TID
	nhi	r1,3f
	STB	R1,CQTID		:Save for Gateway Log-in purposes
	JAL	R9,PCIE			:SKIP OVER TID AND ORIGINATION DATA
	JAL	R9,PCIE			:WHICH MAY BE ESCAPED
	JAL	R9,PCIE
	JAL	R8,PCI
	LIS	R4,0			:COUNT USERNAME CHARS
	ST	R4,XUTMP		:CLEAR TEMP USERNAME AREA
	ST	R4,XUTMP+4		:FOR 12(D) CHARS
	ST	R4,XUTMP+8
	CLHI	R1,0A1			:= "!" ?
	JNFS	CRQH10
CRQH11	JAL	R8,PCI
CRQH10	NHI	R1,7F			:REMOVE MSB
	CLHI	R1,3B			:SEMICOLON?
	JEFS	CRQH12			:YES
	CLHI	R1,0D			:CARRIAGE RETURN
	JEFS	CRQH12			:YES
	CLHI	R4,0C			:UP TO 12(D) CHARS
	JGEBS	CRQH11			:AFTER 12 CHARS, JUST SCAN FOR CR OR ;
	STB	R1,XUTMP,R4		:USER NAME FOR VALIDATION
	AIS	R4,1			:BUMP CHAR COUNT
	J	CRQH11			:LOOP UNTIL ALL USERNAME IS IN

CRQH12	LIS	R8,0			:INIT GG LIST INDEX 
CRQH13	LIS	R9,0			:INIT WORD POINTER INTO XUTMP
CRQH16	L	R1,XRAYGG+XGGNAM,R8,R9	:COMPARE TO GOODGUY LIST
	NI	R1,7F7F7F7F		:CLEAR MSB
	C	R1,XUTMP,R9		:GET USERNAME FROM NEEDLE
	JNFS	CRQH14			:NAME DOESN'T THIS MATCH ENTRY
	AIS	R9,4			:BUMP FW INDEX INTO XUTMP
	chi	r9,0c			:Q.did all 12 chars of gg name###sln
	jlbs	crqh16
	JFS	CRQH15			:Y.NAME MATCH FOUND

CRQH14	AHI	R8,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R8,XGGLEN		:END OF GGLIST?
	JL	CRQH13			:NO, CHECK NEXT GGLIST ENTRY
       IF	T2GATE
	J	GCRTRM			:If no match and Gateway - user circuit
       ELSE	:not T2GATE		:No Kernel stuff for Gateway
	J	CRQHS1			:NOT AN INTERNAL HOST
       EI	:T2GATE

CRQH15	LR	R4,R8			:BOUND FOR INTHST PROCESSING
					:SET UP INTUSR AS GGLIST INDEX
:	reentry for log II code if log ii intt host (currently flase)
CRQHS5	lb	r1,xraygg+xggprv,r4,	:is this a user of privilege?
	jefs	crqh17			:no, so no check tid
	lb	r1,cqtid		:is this an aux circuit user?
	je	crqzpn
crqh17	LHI	CHN,INTZFL		:FOR INTERNAL HOST
	LHI	R1,TINTCH		:GET TOTAL # OF INTERNAL HOST CHANNELS
CRQHS4	JAL	R9,FNDCHN		:AND FIND AVAILABLE CHANNEL
	SKIPAD(CRQDL1)			:immed return - NO,NONE AVAILABLE###wjl
	LR	R1,CHN			:+4 return - FOUND ONE, GET
	SHI	R1,INTZFL		:RELATIVE INT HOST INDEX
	SLLS	R1,2			:FORM FW INDEX
	ST	R4,INTUSR,R1		:STORE USERNAME
	JAL	R9,TRUNC		:EMPTY NEEDLE BUFF UP TO CURRENT POINTR
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
       IF      T2GATE&LOGII             :LOG II converted needle to XRAY?
        THI     R7,NF.LG2               :Needle body data will follow
        JNFS    CRQH23                  :so don't insert anything before it.
       EI       :T2GATE&LOGII
	LHL	R1,BCT,R2,		:ANYTHING IN THE BUFFER?!
	JNFS	CRQH23			:YES, LEAVE IT THERE TO SET ATTN FLAGS
	LHI	R1,80			:OTHERWISE STORE A NULL IN THE BUFFER
	JAL	R8,WCI,,		:TO CAUSE ATTN FLAGS TO BE SET
CRQH23	JAL	R8,NEDTIM		:TEST NEEDLE TIME, RECORD CIRCUIT TIME
	IF	intACC
	JAL	R8,AASTRT		:circuit is for some internal host
	EI	:intACC

:       Following IIX stuff is since IIX interfaces will not send any data
:       until they receive the select dialect.  Note that gateway XRAY will
:       still not properly handle any further IIX msgs, but that should not
:       have much effect on the user.                           ###sdw
       IF       T2GATE                  :gateway is IIX and must do IIX negoti
        LR      R4,R4                   :do this only for XRAY users
        JE      CRQ70
        LHL     R0,CQNFLG               :test if IIX origination
        THI     R0,NF.SMC               :                               ###sdw
        JE      CRQ70                   :not IIX, nothing to do
        XHI     R2,4
        LHI     R1,01F6                 :the start IIX signal
        JAL     R9,W2CI,,
        LHI     R1,8080                 :the select dialect
        JAL     R9,W2CI,,
        LHI     R1,8081                 :the ascii dialect (just ascii data)
        JAL     R9,W2CI,,
        LHI     R1,01F7                 :the TIIX signal
        JAL     R9,W2CI,,
        XHI     R2,4
       EI       :T2GATE
	J	CRQ70			:CONTINUE WITH CIRCUIT BUILDING
CRQDL1	LIS	R0,0
	JAL	R8,CRYPTO,,
	HC	CRYE2E			:MESSAGE - OUT OF INTERNAL HOST PORTS
	IF	ACCT			:###EV
	L	R1,CQINV		:Supply inv # to accounting
	LIS	R0,AALR07		:and zap reason for addendum
	JAL	R8,AANCZP		:and send to Sup
	EI	:ACCT		
	J	CRQZPN

CRQHS1	IF	1-T2GATE
	LHI	R1,NKU			:# OF KERNEL PORTS
	LHI	CHN,KERZFL
	JAL	R9,FNDCHN		:LOCATE A PORT
	SKIPAD(CRQER3)			:immed return - ALL OUT		###wjl
	LHI	R1,-KERZFL,CHN		:SET NEW LOG FLAG
	SBT	R1,KERNWL,,
:	FIRST 4 CHARS IN BUFFER ARE TID, 80, 8000+ORIG HOST. IF ORIG
:	HOST IS 04-07, KERNEL WILL INTERPRET AS NETWORK CHARACTERS SINCE
:	COMMAND CIRCUITS ONLY ESCAPE 00-03. THEREFORE, IF ORIG HOST IS
:	04-07, WE MUST INSERT AN ESCAPE...

:	COPY USER NAME STRING TO LINEAR ARRAY
	LIS	R7,0			:BYTE INDEX, HAS COUNT WHEN DONE
CRQH10	LH	R0,BCT,R2,
	JEFS	CRQH20			:BUFFER EMPTY - USER NAME COPIED
	JAL	R8,GCI,,
	STB	R1,KERUSR,R7,		:PUT USER NAME IN HOLD AREA
	AIS	R7,1
	JBS	CRQH10

:	USER NAME STRING COPIED
CRQH20	LIS	R6,0
	STB	R6,KERUSR,R7,		:DELIMIT USER NAME WITH NULLS
	STB	R6,KERUSR+1,R7,
	LHL	R1,KERUSR,,
	JAL	R9,WHWI,,		:RESTORE FIRST 2 BYTES BACK IN BUFFER
	LB	R1,KERUSR+2,,
	JAL	R8,WCI,,
	LB	R1,KERUSR+3,,		:GET CRITICAL BYTE
	JEFS	CRQH22			:IF ESCAPE, LO-ORDER 00-03 - O.K.
	CLHI	R1,8
	JGEFS	CRQH22			:VALUE ABOVE ESCAPED CHARACTER
:	WE GOT A 04-07...INSERT ESCAPE FOR KERNEL
	EXBR	R1,R1
	JAL	R8,WCI,,			:WRITE 00 (ESCAPE)
	EXBR	R1,R1
CRQH22	JAL	R8,WCI,,
	SIS	R7,4			:4 BYTES ALREADY STORED
	LIS	R6,4
CRQH30	LB	R1,KERUSR,R6,
	JAL	R8,WCI,,		:RESTORE USER NAME BACK IN BUFFER
	AIS	R6,1
	SIS	R7,1
	JGBS	CRQH30
	IF	intACC
	JAL	R8,AASTRT		:circuit is for some internal host
	EI	:intACC
	LHL	R7,CQNFLG		:RESTORE NEEDLE FLAGS IN R7
	J	CRQ70

	EI	:1-T2GATE

:	FOR HOST OTHER THAN HST0
CRQHS2	LR	R1,HN			:DO WE KNOW THIS GUY
	JAL	R9,FNDHST
	SKIPAD(CRQHSZ)			:immediate return, NO, ZAP	###wjl

:	TEST FOR HOST OUT OF PORTS
	LHL	R1,HSTPTA,HN,HN		:+4, GET # OF PORTS AVAIL, PER LAST MSG
	JE	CRQER6			:NONE, HANDLE HOST OUT OF PORTS

	LHI	R1,NDP-1		:MUST BE A DISPATCHER HOST
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN
	SKIPAD(CRQER4)			:immed - OUT OF DISPATCHER PORTS###wjl
	LHI	R1,-DISZFL,CHN		:+4 return - RELIEVE BACKPRESSURE
	SBT	R1,DISBPV
	SBT	R1,DISBPX               :don't let it send BP relief yet
        lhl     r0,cqhost               :get host number
        sth     r0,dhstix,r1,r1         :store it for probe trace cmd
	LHI	R0,INXLIM		:AND GIVE IT XMIT CAPACITY
	STH	R0,DIXLIM,R1,R1
       IF       LOGII
        LHL     R0,CQNFLG               :get flags
        THI     R0,NF.LG2               :is this a converted needle
        JE      CRQHS3
        LHL     R2,CQNBUF               :need our buffer back
        JAL     R9,G2CI                 :remove converted needle
        JAL     R9,G2CI                 :get len (all we want is needle body)
        LR      R0,R1
        SIS     R0,4                    :removed 0310 and 2 byte len
        JAL     R8,RTBFTS               :converted needle gone
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
        LHI     R1,NEEDCV               :tell DISPI LOGII ISN follows needle
        JAL     R8,WCD                  :needle body may not all be in yet
        EXBR    R1,R1
        JAL     R8,WCD
       EI       :LOGII
CRQHS3	LHL	R2,CQNBUF		:RESTORE NEW CIRCUIT BUFFER INDEX
	JAL	R8,NEDTIM		:COMPUTE NEEDLE TIME, SET CIRCUIT TIME
	J	CRQ72			:BUILD LAST HALF OF CIRCUIT
					:FOR SUPERVISOR STATISTICS

CRQHSZ	LR	R0,HN			:NO SUCH HOST - ZAP
	JAL	R8,CRYPTO,,
	HC	CRYE0D
	J	CRQZPN
:       CRQLWT  In waiting (received head char but not end of needle).
:               Time out needle after 120seconds since LOG II needle
:               passes like data and could get gobbled like data.

       IF       LOGII
CRQLWT  LR      R1,R2                   :get buftim
        SRLS    R1,1
        L       R0,BUFTIM,R1,
        AI      R0,RATE*$A120           :120 seconds after arrival of head
        C       R0,FASTC,,              :if no body yet, probably never
        JG      CRQ10                   :put back in CRQ buffer and wait
        J       CRQZPN                  :otherwise zap it

:       CRQLG2  Process a LOGII Needle.  Get and store CQNFLG, CQINV,
:               CQNLK.  If passthrough then find the link and jump to
:               CRQ64.  If term then find host, CQHOST and go CRQHS2.
:               Remember we are not a LOG II host so LOGII needles are
:               not for XRAY or KERNEL.


CRQLG2	LHI     R4,ID.NCF               :get LOGII form of flags
        JAL     R7,X4PARS,,             :find flags
        SKIPAD(CRQZPN)                  :error, zap it
        JAL     R9,PCIE,,               :unused count
        JAL     R9,PCIE,,               :flags
        STH     R1,NEDFLG               :save in case internal and such
        JAL     R7,LPAFLG               :convert to LOGII flags
        STH     R4,CQNFLG               :save it
        LHI     R4,ID.INV               :get invoice number
        JAL     R7,X4PARC,,             :get it
        SKIPAD(CRQL06)                  :better be there
        JAL     R7,X4GTNM,,
        GL      X4GTNM
        ST      R4,CQINV
CRQL06  LHL     R0,NEDFLG               :internal have no links
        THI     R0,L2F.IC               :internal?
        JN      CRQL08
        LHI     R4,ID.LNK               :number of links
        JAL     R7,X4PARC,,
        SKIPAD(CRQL08)                  :0 if not there
        JAL     R7,X4GTNM,,             :get the number
        JFS     CRQL09
CRQL08  LIS     R4,0                    :internal has no links
CRQL09  STH     R4,CQNLK
        LR      R4,R4
        JE      CRQLTM                  :no links is a log II termination
        LHI     R4,ID.NNL               :where circuit to go to
        JAL     R7,X4PARC,,
        SKIPAD(CRQLTM)                  :not there then LOGII term
        LR      R7,R0                   :len of list
        JAL     R9,PCIE                 :get id 04 of octet string
        JAL     R9,PCIE                 :get len of first number in list
        LR      R0,R1                   :len of node number
        LR      R5,R0
        AIS     R5,2                    :len of node number element and ID
        SR      R7,R5                   :new len of needle list element
        LIS     R4,0
CRQL14  SLLS    R4,8
        JAL     R9,PCIE
        AR      R4,R1                   :node # could be 1 or 2 bytes
        SIS     R0,1
        JGBS    CRQL14
        LR      R1,R4                   :setup FNDLNK
        JAL     R9,FNDLNK               :returns KD, KN
	SKIPAD(CRQNNE)			:immed, NOT THERE, ZAP NEEDLE	###wjl
        TBT     KN,ALINKS               :active link
        JE      CRQNNE                  :neighbor not there
        LH      R0,SHSTAT,KD            :can't pass while shrinking link
        JN      CRQ10                   :put back in CRQ buffer
:       now remove that node number from list.  The list is the first element
:       in the needle.
	JAL	R9,L2CHWI		:needle houskeeping
        J       CRQ64                   :return to mainline CRQ

:       CRQLTM  LOG II terminations.  Just get termhost into HN and goto
:               mainline LEP.  Remember XRAY is not a LOG II host so it
:               can't be for an internal host.

CRQLTM  LHI     R4,ID.THS               :find term host
        JAL     R7,X4PARC,,
        SKIPAD(CRQZPN)                  :if not there what else to do with it?
        JAL     R7,X4GTNM
        LR      HN,R4
       IF       1-T2GATE                :when T2GATE circuit may goto XRAY
        LHL     R7,CQNFLG
        J       CRQTRL
       ELSE     :T2GATE
        L       R3,X4T.LB+X4TBBG,,      :get address after NCN MO's len
        JAL     R9,TRUNC                :remove it
        LHL     R4,X4T.LN+X4TBBG,,      :how many chars long is NCN head
CRQLT1  JAL     R9,GCIE
        SIS     R4,1
        JGBS    CRQLT1                  :eat needle head
        JAL     R8,PCIS                 :now parse needle body
        CLHI    R1,03                   :better be needle body char pair
        JN      CRQZPN
        JAL     R8,PCI
        CLHI    R1,NEEDBD&0FF           :needle body
        JN      CRQZPN
        LHI     R4,ID.UNM               :find username to see if Internal host
        JAL     R7,X4PARS,,
        SKIPAD(GL2TRM)                  :if not there then not for xray
        LIS     R4,0
        ST      R4,XUTMP                :clear uname temp area
        ST      R4,XUTMP+4
        ST      R4,XUTMP+8
CRQLT3  JAL     R9,PCIE                 :get first char of uname
        NHI     R1,7F
        STB     R1,XUTMP,R4             :save username for XRAY check
        AIS     R4,1
        SIS     R0,1                    :count of how long setup by X4PARS
        JLEFS   CRQLT4
        CLHI    R4,0C                   :only room for 12 chars
        JLBS    CRQLT3
CRQLT4  LIS     R8,0                    :this is same as CRQH12-CRQH15
CRQLT5  LIS     R9,0                    :counter into uname
CRQLT6  L       R1,XRAYGG+XGGNAM,R8,R9  :genned in xray unames
        NI      R1,7F7F7F7F             :have high bits set
        CI      R1,XUTMP,R9             :word of uname match?
        JNFS    CRQLT7
        AIS     R9,4
        CR      R9,R4                   :compare all of uname?
        JLBS     CRQLT6			:no-compare more
	lb	r1,xraygg+xggnam,r8,r9	:Q.next byte 00 for end ###sln
	jefs	crqlt8			:Y.name match found
	chi	r9,0c			:Q.did all 12 chars of gg name###sln
        JEFS   CRQLT8			:Y.found uname for XRAY
CRQLT7  AHI     R8,XGGSIZ               :next xray entry
        CLHI    R8,XGGLEN
        JL      CRQLT5
        J       GL2TRM                  :then uname is for normal gateway

CRQLT8  LR      R7,R8                   :save XGG block pointer
        JAL     R9,G2CI                 :remove needbd char pair
        JAL     R9,GHWI                 :get length of body
        LR      R0,R1
        JAL     R8,RTBFTS               :eat body
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
        LR      R4,R7                   :setup r4,r7 for CRQHS5
        LHL     R7,CQNFLG               :prepare to go to normal inthst logic
        OHI     R7,NF.LG2               :ensure converted bit is reset
        XHI     R7,NF.LG2
        STH     R7,CQNFLG
        J       CRQHS5                  :and normal inthst processing


       EI       :T2GATE

       EI       :LOGII

:       For LEP just eat the needle and then connect up.  First thing
:       following the needle will be the takeover command.
CRQLEP	JAL	R9,TRUNC		:LEP CIRCUIT - CLEAR NEEDLE
	LHI	R1,NLQ			:# OF COMM CIRCS
	LHI	CHN,LEPZFL		:BASE COMMAND CIRCUIT
	JAL	R9,FNDCHN		:GET A LEP PORT
	SKIPAD(CRQER5)			:immed - OUT OF COMMAND PORTS	###wjl
	JAL	R8,NEDTIM		:+4 return - RECORD TIME
	if	autrac			:criteria based tracing
	lh	r8,autrun,,
	jnfs	crqle1
	ei
	SBT	CHN,TRCHAN,,		:ENABLE CHARACTER TRACE OF COMMAND CIRC
crqle1	J	CRQ70			:BUILD CIRC

:	SEND NEEDLE ACK TO SUPERVISOR
CRQCHU	HS	0			:CHANNEL IN USE - ZAP NEEDLE
	IF	ACCT		:###EV
	CLHI	HN,HST0			:Is this for an internal host?
	JN	CRQCH1			:If not dont do accounting
	L	R1,CQINV		:Supply inv # to accounting routine
	LI	R0,AALR07		:Provide zap reason
	JAL	R8,AANCZP		:and send to Sup
CRQCH1	EI	:ACCT		
	JAL	R10,SWRCHU		:FORMAT CHANNEL IN USE NODE REPORT,
					:CIRCUIT LIFETIME NODE REPORT, CRYPTO
	J	CRQZPN

:	NO SUCH NEIGHBOR - ZAP CIRCUIT
CRQNNE	LHI	R0,NR.NNE		:SEND NODE REPORT FOR 'NO NEIGHBOR'
	STH	R0,SUPMBF		:REPORT TYPE
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER IN ERROR
	LH	R0,CQNFLG
	STH	R0,SUPMBF+4		:NEEDLE FLAGS
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP LOG
	JFS	CRQZPN			:ZAP CIRCUIT

CRQZPS	LHI	R1,ZAPPS		:SOFT ZAPPER
	JFS	CRQZP2

:	CIRCUIT BUILDING ERROR - ZAP IT
CRQZPN	LIS	R1,1
	AHM	R1,NC.CRZ		:COUNT CRQ CIRCUIT BUILDING ERRORS
	LHI	R1,ZAPPH		:HARD ZAPPER

CRQZP2	LHL	R2,CQNBUF
	XHI	R2,4			:ZAP NEEDLE CIRCUIT (NOTE ZAPPER...
	JAL	R9,ZAPX			:...TRAVELS TOWARDS ORIGIN)
	J	CRQ20

:	ZAPPER, GOBBLER OR OTHER 03-XX PAIR DETECTED IN CRQ BUFFER
:	INSTEAD OF A NEEDLE POINT

CRQZOG	LHI	R0,300
	OR	R0,R1			:FORM THE OFFENDING CHARACTER PAIR
	JAL	R8,CHFLNK,,		:GET THE NEIGHBOR # FROM THE CHANNEL
	SKIPAD(CRQZ02)			:immed return, nghbr isn't there###wjl
	SKIPAD(CRQZ04)			:+4 return, internal termination###wjl
CRQZ02	STH	R3,CRYSBF+2		:+8 return - STORE IT AWAY
	JAL	R8,CRYPTO,,		:REPORT NEEDLE GOBBLED TO XRAY
	HC	CRYE08
	THI	R1,-8			:IS IT A ZAPPER?
	JN	CRQZPN			:GOBBLER OR ??, ZAP TOWARDS CIRC SOURCE
	JAL	R9,ZAPV			:ZAP SECOND HALF OF CIRCUIT...
	LIS	R1,1
	AHM	R1,NC.CRZ		:AND COUNT CRQ ERROR
	J	CRQ20

CRQZ04	LHI	R3,MACHNM		:internal termination		###wjl
	J	CRQZ02			:				###wjl

:	GET HERE FOR A VARIETY OF CIRCUIT BUILDING ERRORS. MAKE
:	CRYPTOGRAM AND ZAP CIRCUIT.

:	NEEDLE POINT GARBAGE
CRQER1	LR	R0,R1			:SAVE FIRST BYTE OF GARBAGED NEEDLE
	EXBR	R0,R0
	JAL	R8,PCI,,		:GET NEXT BYTE AND
	OR	R0,R1			:COMBINE WITH FIRST
	STH	R0,CQNLK		:SAVE REG 0
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE1A			:NEEDLE POINT GARBAGE
	LHL	R0,CQNLK		:RESTORE REG 0
	CLHI	R0,01FD			:IS IT BLACK BALL ?
	JE	CRQZPN			:YES, ZAP CIRCUIT
	CRASH.(.CRQC0)
:	OUT OF CHANNELS TO  T-II LINK
CRQER2	jal	r8,cntsus		:count suspended chns on this link
	JAL	R8,BUBBLE		:ALLOCATE ANOTHER 1/2 PAGE TO LINK
	SKIPAD(CRQE22)			:CAN'T DO IT - OUT OF 1/2 PAGES	###wjl
	LHL	R2,CQNBUF		:+4 return, RESTORE BUFFER NUMBER
	J	CRQ64			:SUCCEEDED - CONTINUE CIRCUIT BUILD
CRQE22	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER		###wjl
	STH	R0,CRYSBF+2		:SAVE FOR CRYPTO
	LIS	R0,0			:NO DATA
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE19			:OUT OF CHANNELS
	J	CRQZPN			:ZAP CIRCUIT

:	OUT OF KERNEL PORTS
CRQER3	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE1B			:NO KERNEL PORTS
	IF	INTACC			:###EV
	L	R1,CQINV		:Supply inv # to accounting
	LI	R0,AALR07		:and zap reason for addendum
	JAL	R8,AANCZP		:and send to Sup
	EI	:INTACC

:	SET UP TO DETACH CIRCUIT. DETACH TYPE 03 INFORMS USER OF NO
:	KERNEL PORTS.
	LIS	R1,3
	JAL	R8,WCI,,		:NEEDLE POINT TRIGGERS 'DETCIR' TO
	LHI	R1,NEEDP&0FF		:SEND TEXT, START TIMER
	JAL	R8,WCI,,
	LR	R7,R2			:(CRQE4B EXPECTS BUFFER INDEX IN R7)
	LIS	R1,3			:DETACH TYPE
	J	CRQER7			:GO DETACH CIRCUIT

:	OUT OF DISPATCHER PORTS -- SEND NODE REPORT, CLOSE ACCOUNTING,
:	AND DETACH CIRCUIT...
CRQER4	LR	R7,R2			:SAVE BUFFER #
	LI	R10,NR.ODP*10000+NDP
	ST	R10,SUPMBF		:NODE ERR # AND # OF DISPI PORTS
	LH	R10,CQHOST		:GET HOST # (FROM NEEDLE)
	OHI	R10,8000		:SET MSB ON HOST #
	STH	R10,SUPMBF+4
	JAL	R10,SUP12		:SEND MESSAGE TO SUP
	L	R1,CQINV		:GET INVOICE NUMBER
	JAL	R10,SUPINV,,		:SEND NODE CODE GEN'D 07-TYPE acst msg
	LIS	R1,0
	STH	R1,DETTSV		:SAVE DETACH MESSAGE TYPE
	LI	R1,0E000000F		:ACCOUNTING MSG
CRQE4B	JAL	R10,SUP14A		:SEND ACCOUNTING ADDENDUM, VALUE=0F
:	CLOSE ACCOUNTING FOR THIS SESSION. SEND TYPE B MSG, CHARACTER
:	COUNT ZERO.
	LI	R1,0B0000000		:FINAL CHAR COUNT (0)
	JAL	R10,SUP14A		:NODE CODE GENERATED ACCOUNTING MSG

	LR	R2,R7			:RESTORE BUFF #

:	DETACH CIRCUIT. FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB 
:	(STARTING WITH DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS
:	FOR SENDING APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING
:	OUT CIRCUIT IF NO ORANGE BALL RETURNED. TEXT TO USER IS DETERMINED BY
:	VALUE STORED IN DETMTY BYTE ARRAY.

	L	R4,DETACP,,		:GET DETACH PROCESS ACTIVE PORT ARRAY
	JFFO	R4,CRQE4A		:ANY PORTS AVAILABLE?
	J	CRQZPN			:NO, JUST ZAP NEW CIRCUIT
:	FOUND ROOM TO DETACH THIS ONE
CRQE4A	LH	R0,DETTSV		:GET DETACH MESSAGE TYPE
	STB	R0,DETMTY,CHN		:AND SAVE IT
	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER
	J	CRQ70			:CONNECT IT UP

:	OUT OF COMMAND PORTS
CRQER5	L	R0,CQINV		:INVOICE NUMBER
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE17			:NO COMMAND PORTS
	J	CRQZPN			:ZAP CIRCUIT

:	HOST OUT OF PORTS
CRQER6	LR	R7,R2			:SAVE BUFFER #
	L	R0,CQINV		:INVOICE NUMBER
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE2F			:ISIS HOST OUT OF PORTS

:	SEND ACCOUNTING RECORDS TO CLOSE ACCTING ON THIS CIRCUIT

	L	R1,CQINV		:GET INVOICE NUMBER
	JAL	R10,SUPINV,,		:SEND 07/INVOICE #

	LIS	R1,1
CRQER7	STH	R1,DETTSV		:SAVE DETACH MESSAGE TYPE
	LI	R1,0E0000007		:0E=CODE,0=MSG,00=SUB-MSG,0007=VALUE,
:	ACCOUTING ADDENDUM TO INDICATE HOST OUT OF PORTS
	J	CRQE4B			:SEND AND FINISH OFF

	IF	REBILD

:	HERE TO PROCESS THE ARRIVAL AT THE TERMINUS OF A REBUILD
:	NEEDLE.

CRQREB	JAL	R9,PHWI,,		:GET SEQN OF CHAR WE SHOULD SEND
	STH	R1,CQXSEQ		:AND SAVE IT
	JAL	R9,PHWI,,		:				###GT
	STH	R1,CQXSEQ+2
	JAL	R9,PHWI,,		:GET SEQN OF CHAR WE'LL GET FIRST
	STH	R1,CQVSEQ		:SAVE THAT, TOO
	JAL	R9,PHWI,,		:				###GT
	STH	R1,CQVSEQ+2
	JAL	R9,TRUNC		:DISCARD NEEDLE DATA UP TO CURRENT 'R3'
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
	JAL	R9,FNDCRQ		:LOCATE CIRCUIT BASED ON INVOICE NUMBER
	SKIPAD(CRQRE1)			:FAILED, MAKE REPORT, ZAP REBUILD CIRC

:	FNDCRQ SUCCESSFUL. R6 (XBF) CONTAINS THE ORIGINAL OUTBOUND BUFFER
:	NUMBER AND R7 (HBF) CONTAINS THE CORRESPONDING HISTORY BUFFER NUMBER.
:	R2 CONTAINS THE NEEDLE BUFFER NUMBER.
CRQRE8	LHL	R5,CQNFLG		:+4 return, RECOMPUTE SIZE OF HIST BUFF
	HSIZE(R5)			:BASED ON SPEED BITS		###CY
	STH	R0,RHBSZ,HBF,		:STORE AWAY NEW HISTORY BUFFER SIZE
	XHI	R2,4			:FLIP OVER TO OUTGOING BUFFER
	LHL	R1,BF,R2,		:GET THE NEEDLE-ENTRY CHANNEL NUMBER
	SRHLS	R5,1			:POSITION SPEED BITS FOR IOTAB  ###CY
	AHM	R5,IOTAB,R1,R1		:SET ENTRY CHAN PERMUTER TBL SPEED BITS
	LR	R2,XBF			:R2=ORIGINAL OUTBOUND BUFFER FOR CSETUP
	JAL	R8,CSETUP		:SET UP REBUILD PARAMETERS FOR CRYPTO
	JAL	R8,CRYPTO,,
	HC	CRYE6A			:MESSAGE - CHAN STATUS
	JAL	R9,CSTUP2		:2ND PORTION OF MESSAGE		###GT
	L	R0,CQVSEQ		:GET CQVSEQ
	ST	R0,CRYSBF		:AND SAVE FOR XRAY
	L	R0,CQXSEQ		:GET CQXSEQ FOR XRAY		###GT
	JAL	R8,CRYPTO,,		:CRQREB REPORT
	HC	CRYE67
CRQREA	JAL	R9,MERGE		:COPY H-BUF TO FRONT OF OUT-BUF.
	LR	R2,XBF			:PURGE REDUNDANT DATA IN OUTBOUND BUFF
	L	R4,XSEQN,XBF,		:SEQUENCE # OF FIRST CHAR IN OUT-BUF
	L	R5,CQXSEQ		:FIRST CHAR OTHER END WANTS TO RECEIVE
	JAL	R9,PURGE		:RECONCILE THEM BY DISCARDING BYTES
	SKIPAD(CRQRE2)			:immed, LOST DATA - DON'T REBUILD, ZAP
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
	L	R0,XSEQN,R6,		:+4, UPDATE SEQN OF HISTORY BUFF###GT
	ST	R0,HSEQN,R7,

:	NOW PROCESS THE OTHER BUFFER PAIR - THE ONE ASSIGNED TO THE
:	REBUILD NEEDLE. IT'S INBOUND BF WILL BE SET TO 'INCPFL' TO
:	INDICATE INTERCEPT MODE. HISTORY DATA FORM THE OTHER END WILL
:	ACCUMMULATE HERE UNTIL THE FIRST NEW CHARACTER ARRIVES.

	LHL	R2,CQNBUF		:INCOMING BUFF ASSIGNED TO REBILD NEEDL
	LR	R7,R2			:COMPUTE IT'S ASSOCIATED HISTORY BUFFER
	SRHLS	R7,1
	NHI	R7,-4
	AI	R7,HBUFN
	XHI	XBF,4			:FORM ORIGINAL INCOMING BUFFER NUMBER
	STH	R6,RBIBUF,R7,		:SAVE IT INDEXED ON NEEDLE HISTORY BUFF
	SRHLS	R6,3			:MAKE CRQ INDEX			###CY
	SBT	R6,REBTMI		:REFRESH CRQ TIMEOUT		###CY
	RBT	R6,REBTMO		:REFRESH CRQ TIMEOUT		###CY
	if	mortim
	rbt	r6,rebtm1
	rbt	r6,rebtm2
	ei	:mortim
	SLHLS	R6,2			:				###CY
	AI	R6,HBUFN		:MAKE HISTORY BUFFER INDEX	###CY
	STH	R6,RBHIS,R7,		:SAVE IN NEEDLE HIST BFR DESCRIPTOR##CY
	L	R0,CQINV		:GET INVOICE NO.		###CY
	ST	R0,RBKEY,R7,		:SAVE IN NEEDLE HIST BFR DESCRIPTOR##CY
	L	R1,CQVSEQ		:GET SEQN OF CHAR THAT FOLOWS NEEDLE#GT
	ST	R1,RBVSEQ,R7,		:SAVE IT INDEXED ON NEEDLE HISTORY BUFF
	AM	R1,VSEQN,R2,		:INIT SEQ# TO EXPECT HISTORY BUFF DATA
	LHI	R1,INCPFL		:SO CRQ KNOWS WE'RE INTERCEPTING
	STH	R1,BF,R2,
	LIS	R3,1
	AHM	R3,NC.CRC		:INCREMENT COUNT OF CRQ'S COMPLETED
	LHL	R7,CQNFLG		:GET NEEDLE FLAGS BACK
	XHI	R2,4
	LHL	R3,BF,R2,		:CHANNEL # OF ENTRY (LINK) CHANNEL
	XHI	R2,4
	SBT	R3,BPSVCP-LNKZFL/8,,
	SBT	R3,LNKBPV-LNKZFL/8,,	:INSURE CHANNEL SERVICE
	RBT	R3,PRIRTY,,
	RBT	R3,CMDCTS-LNKZFL/8,,
        lhi     r1,200
        sth     r1,bpscnt-2*lnkzfl,r3,r3 :ensure it has xmit capability
	THI	R7,NF.PRI		:PRIORITY CIRCUIT?
	JEFS	CRQRE0			:NO
	SBT	R3,PRIRTY,,		:YES - INDICATE SUCH
CRQRE0	THI	R7,NF.CMD		:COMMAND CIRCUIT?
	JE	CRQ10			:NO
	SBT	R3,CMDCTS-LNKZFL/8,,	:YES
	J	CRQ10			:WAIT FOR INTERCEPT LOGIC TO HANDLE

CRQRE1	LR	R0,R0			:FNDCRQ FAILURE - INVOICE# OR STUB?
	JE	CRQRE9			:R0=0, FNDCRQ COULDN'T MATCH INVOICE #

:	GOT A REBUILD NEEDLE FOR AN APPARENTLY GOOD CIRCUIT. PRESUME THAT
:	A FAT ZAPPER IS ON IT'S WAY AND WILL EVENTUALLY ARRIVE. CLEAR OUT
:	THE ORIGINAL CIRCUIT AND MERGE BACK INTO REBUILD LOGIC. NOTE THAT
:	WE MAY GET SOME 'DATA ON UNASSIGNED CHANNEL' ON THE OLD CIRCUIT

	SIS	R6,4			:GET THE ORIGINAL INCOMING BUFER
	LHL	R0,BF,R6,		:GET THE TERMINATING CHANNEL NUMBER
	JAL	R8,CRYPTO,,		:TELL XRAY
	HC	CRYE6C			:MESSAGE = EARLY REBUILD NEEDLE
	LR	R2,R6			:COPY ORIGINAL INCOMING BUFFER	###CY
	LHI	R1,ZAPPS		:SIMULATE ARRIVAL OF A FAT ZAPPER##CY
	JAL	R10,TRCIRC		:AND USE COMMON TEARDOWN LOGIC	###CY
	JAL	R9,FNDCRQ		:CHECK TO SEE IF CRQ IS STILL THERE##CY
	SKIPAD(CRQRE9)			:NOT REBUILDABLE ACCORDING TO TRCIRC#CY
	J	CRQRE8			:+4, HANDLE STUB IN NORMAL FASHION###CY

CRQRE9	L	R0,CQINV		:UNKNOWN REBUILD (INVOICE #)
	JAL	R8,CRYPTO,,
	HC	CRYE13			:MESSAGE - REBUILD REJECT
	J	CRQZPN			:ZAP BACKWARDS ALONG NEEDLE PATH

CRQRE2	XHI	R6,4			:LOST DATA - INBOUND BUFF #
CRQR22	LHL	R0,BF,R6,		:TERMINATION #
	JAL	R8,CRYPTO,,
	HC	CRYE14			:MESSAGE - REBUILD DATA LOST
	J	CRQZPN			:ZAP THE CIRCUIT - NOT SALVAGABLE
CRQRE3	LR	R6,R7			:LOST DATA
	JBS	CRQR22
CRQRE4	JAL	R8,CRYPTO,,		:LOST CRQ WHILE IN INTERCEPT STATE###CY
	HC	CRYE6D
	J	CRQZPN			:ZAP BACK TOWARDS ORIGIN	###CY

:	INTERCEPT -- WAITING FOR HISTORY DATA TO ARRIVE FROM SOURCE TO
:	COMPLETE CIRCUIT. WHEN EXPECTED SEQN ARRIVES, TOSS LEADING DATA
:	AND FUSE NEW CRQ WITH EXISTING CIRCUIT STUB...

CRQINT	LR	R9,R2			:INTERCEPT - GET THE REQUIRED DATA
	SRHLS	R9,1
	NHI	R9,-4
	AI	R9,HBUFN
	L	R4,RBVSEQ,R9,		:GET VSEQN OF FIRST CHARACTER IN NB##GT
	LHL	R7,RBIBUF,R9,		:GET ORIGINAL INBOUND BUFFER NUMBER
	LHL	R1,RBHIS,R9,		:GET ORIG CRQ STUB HISTORY BFR	###CY
	L	R0,RBKEY,R9,		:ALSO GET INVOICE NO.		###CY
	CL	R0,RINVC,R1,		:CONSISTENCY CHECK ORIGINAL CRQ STUB#CY
	JN	CRQRE4			:ABANDON INTERCEPT, TIMED OUT?	###CY
	L	R1,VSEQN,R2,		:GET CURRENT RECEIVE SEQUENCE NUMBER
	S	R1,VSEQN,R7,		:COMPARE TO VSEQN OF THE ORIGINAL CIRC
	JGE	CRQIN1			:INCOMING HIST DATA CAUGHT UP, PROCESS
	JAL	R8,CBCLR,,		:NOT CAUGHT UP YET - DISCARD OLD DATA
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
	L	R1,SEQN,R2,		:THIS'LL NOW BE #1 IN BUFF	###GT
	ST	R1,RBVSEQ,R9,
	J	CRQ10			:DONE PROCESSING REBUILD STUB FOR NOW

CRQIN1	L	R5,VSEQN,R7,		:HIST DATA CAUGHT UP - RECONCILE
	JAL	R9,PURGE		:ORIGINAL IN-BUFFER AND CURRENT IN-BUFF
	SKIPAD(CRQRE3)			:immed, DATA LOST, REJECT REBILD ATTMPT
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
	JAL	R8,CBCCT,,		:+4, UPDATE ORIGINAL IN-BUFFER'S SEQ #
	AM	R1,VSEQN,R7,		:BY EXCESS BYTES LEFT OVER AFTER PURGE
	LR	R6,R2			:COPY CURRENT IN-BUFF>ORIGINAL IN-BUFF
	JAL	R9,APPEND		:THIS ALSO CLEARS THE CURRENT IN-BUFFER
	if	db.sd1
	stm	r0,REGSDW
	jal	r8,d.sdw,,
	lm	r0,REGSDW
	ei
	LR	R2,R6	
	XHI	R6,4			:GET THE NEW NETWORK CHANNEL NUMBER
	LHL	CHN,BF,R6,		:CHN = EXIT PORT #
	LR	R0,R2			:COPY NEEDLE BUFFER NO.		###CY
	SRHLS	R0,3			:MAKE CRQ INDEX			###CY
	TBT	R0,SQFIXV		:HAVE WE SEEN A SEQ-FIX OR ACK?	###CY
	JEFS	CRQINA			:SKIP IF NOT			###CY
	LR	R0,R7			:COPY CRQ STUB BUFFER NO.	###CY
	SRHLS	R0,3			:MAKE CRQ INDEX			###CY
	SBT	R0,SQFIXV		:SET FOR CRQ STUB		###CY
CRQINA	JAL	R8,RFCBUF,,		:RETURN NEEDLE BUFF,NO LONGER NEEDED#CY
	LR	R2,R7			:CONNECT THE ORIGINAL IN-BUFFER TO THE
	JAL	R9,CRQHCR		:NEW NETWORK CHANNEL
	SRHLS	R2,3			:CLEAR TIMEOUTS
	RBT	R2,REBTMO
	RBT	R2,REBTMI
	if	mortim
	rbt	r2,rebtm1
	rbt	r2,rebtm2
	ei	:mortim
	SBT	R2,CRQBSY		:MARK CREATION OF A REBUILDABLE CIRCUIT
	SBT	R2,CRQEND		:MARK CREATION OF A CIRCUIT TERMINATION
	TBT	R2,SQFIXV		:DO WE HAVE FIX OR ACK ALREADY?	###CY
	JNFS	CRQINB			:SKIP IF SO			###CY
	RBT	R2,SQFTMO		:INIT REBUILD TIMEOUT
	SBT	R2,SQFTMI		:SET REBUILD TIMER COUNT
CRQINB	LR	R2,R7			:GET INBOUND BUFFER		###CY
	XHI	R2,4			:SWITCH TO OUTPUT BUFFER NUMBER	###GT
	JAL	R9,SNDFX0,,		:SEND A SQFIX WITH SEQN=0	###GT
	LHL	R6,BF,R7,
	LIS	R8,3
	NH	R8,IOTAB,R6,R6
	AHM	R8,IOTAB,CHN,CHN
	XHI	R7,4			:OUTPUT BUFFER #
	LHL	R0,BCT,R7,		:SET ATTN FLAG IF CHARS IN OB
	JEFS	CRQIN2
	SBT	CHN,NFLAGS
CRQIN2	CLHI	R6,LNKZFL		:IS DESTINATION CHANNEL A LINK CHAN?#CY
	JL	CRQIN3			:NO, NOT A PASSTHROUGH		###CY
	CLHI	R6,LNKLFL		:IS IT GREATER THAN LAST LINK CHAN?##CY
	JGE	CRQIN3			:YES, NOT A PASSTHROUGH		###CY
	CLHI	CHN,LNKZFL		:IS SOURCE CHANNEL A LINK CHANNEL?###CY
	JL	CRQIN3			:NO, NOT A PASSTHROUGH		###CY
	CLHI	CHN,LNKLFL		:IS IT GREATER THAN LAST LINK CHAN?##CY
	JGE	CRQIN3			:YES, NOT A PASSTHROUGH		###CY
	ts	pasthc			:indicate a change to number of pthrus
	LHL	R0,PASTHR		:increment passthrough count	###wjl
	AIS	R0,1			:				###wjl
	STH	R0,PASTHR		:				###wjl
	CLHI	R0,NPASTH		:out of passthroughs?		###wjl
	JLFS	CRQIN3			:no				###wjl
	LHL	R0,PTHRPD		:what was the last report?	###wjl
	JEFS	CRQIN3			:zero=out of passthrus reported ###wjl
	JAL	R10,SUP0B		:make Resources Report to Sup	###wjl
CRQIN3	LR	R2,R7			:MOVE OUTPUT BUFFER TO R2 FOR CSETUP#CY
	JAL	R8,CSETUP		:SET UP REBUILD DATA FOR CRYPTO
	JAL	R8,CRYPTO,,
	HC	CRYE12
	JAL	R9,CSTUP2		:2ND PART OF CRYPTO MESSAGE	###GT
	J	CRQ20

	EI	:REBILD

	IF	T2GATE
::*********************************************************************
::
::	ENTRY POINT:	GCRTRM:	Gateway CiRcuit TeRMination
::	FUNCTION:	Recieves a Needle inbound from HNET, via CRQ.
::			Gets info to send a Type 07 to ISIS, marks 
::			buffer and sets timer.
::	INPUT:		Expects buffer number in R2.
::	CALLS:		JAL	R8,DIZSMS
::			JAL	R9,FNDCHN
::	RETURNS:	Jumps directly to further processing at CRQ20.
::
::*********************************************************************

GCRTRM	CLHI	HN,HHOST	:Sanity check - destination always HHOST
	JN	CRQHSZ		:Some problem - error, zap circuit
GCRL00	LHI	R1,NDP-1
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN	:Just see if ports are available at all
	SKIPAD(CRQER4)		:immed - If not, error.  Zap circuit.	###wjl
GCRL07	LHL	R1,CQNFLG
       IF       LOGII           :A log II converted needle?
        THI     R1,NF.LG2
        JN      GL2CTM          :go handle converted needles
       EI       :LOGII
	STH	R2,GLOKEY	:+4 return, Local Key becomes our buffer number
	THI	R1,NF.SMC	:Is this a smart circuit?
	JE	GCRL08		:No, don't set IIX bit
	LHI	R1,0C000	:IIX and ELS
	J	GCRL09
GCRL08	LHI	R1,04000	:Always ELS, but not IIX
GCRL09	STH	R1,GIXELF	:Store into Typ07 message
	LB	R1,CQTID	:Get TID (CCT)
	NHI	R1,1F		:MASK OUT TO GET TID
	LBR	R1,R1		:Is it 00
	JNfs	GCRL10		:NO
	LHI	R1,GAXTID	:Yes, exchange for Gateway Aux TID
	JFS	GCRL11
GCRL10	LB	R1,CQTID
	ohi	r1,0c0
GCRL11	STB	R1,GHINID	:and store in message
	LA	R1,GDM07M	:Load message address
	LHI	R3,GDM07L	:and length
	JAL	R8,DIZSMS,,	:Send Typ 07 (pseudo needle request)
::Now set up BF to show Log-in state and set timer
	LHI	R0,LGST.N	:(used only as a check)
	STH	R0,BF,R2,,
	SRLS	R2,1
	L	R9,SLOWC,,
	AHI	R9,GLGTMR	:Set up 2 minute time out
	ST	R9,BUFTIM,R2,
	J	CRQ20		:Thats all folks!

       IF       LOGII           :<<<<<<<< all of gateway's log II stuff

::*****************************************************************
:
:       GL2CTM  handles LOG II converted needles (a log I needle with a
:               LOG II body following).  After removing the LOG I needle
:               and adding the needle body control char then this is the
:               same as a normal LOG II needle.  
:               R3=end of log I needle
::*****************************************************************

GL2CTM  JAL     R9,TRUNC
        LHI     R1,NEEDBD               :converted body has no control char
        JAL     R8,WCD
        EXBR    R1,R1
        JAL     R8,WCD                  :now it looks like a LOG II needle bod
                                        :and fall through to normal LOGII
:       GL2TRM  simply write ICRM with no MOs and process needle body
:               after get back ASLP.

GL2TRM  
        LHI     R0,0A                   :len of null ICRM
        JAL     R8,DIROOM,,
        LHL     R6,DRIF,,               :fill pointer
        LHI     R4,DRSZ-1               :wrap preventer
        LHI     R1,1100                 :type port 0, type 11, unused byte
        ST      R1,DIRNG,R6,
        AIS     R6,4
        NR      R6,R4
        LI      R1,00040000             :len and dispatcher key
        ST      R1,DIRNG,R6,
        AIS     R6,4
        NR      R6,R4
        STH     R2,DIRNG,R6,            :use buffer number as local key
        AIS     R6,4
        NR      R6,R4
        STH     R6,DRIF,,               :save msg
        J       CRQ20                   :done

       EI       :LOGII          <<<<<<<<<< end of gateway LOGII stuff

	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINES:	CSETUP:/CSTUP2:
::	FUNCTION:	SET UP REBUILD DATA FOR CRYPTO
::	INPUT:		R2 = BUFFER NUMBER
::		CSETUP RETURNS R0 = CHAN, CRYSBF = HSEQN.
::		CSTUP2 COMPLETES REMAINING PART OF CRYPTO LOG - WRITES
::			VSEQN AND XSEQN. TO BE USED WITH CSETUP ONLY!
::	DESTROYED:	R0, R1
::
::*********************************************************************

	IF	REBILD
CSETUP	LR	R1,R2
	XHI	R1,4			:GET OTHER BUFFER NUMBER	###GT
	LHL	R0,BF,R1,		:CHANNEL			###GT
	SRLS	R1,3
	SLLS	R1,2
	L	R1,HBSEQN,R1,		:HB SEQN NUMBER			###GT
	ST	R1,CRYSBF		:SET UP FOR CRYPTO		###GT
	JR	R8

CSTUP2	L	R0,XSEQN,R2,		:XSEQN NUMBER			###GT
	LR	R1,R2			:				###GT
	XHI	R1,4
	L	R1,VSEQN,R1,		:VSEQN NUMBER			###GT
	ST	R1,CRYSBF
	JAL	R8,CRYPTO,,		:LOG THE SEQUENCE NUMBERS	###GT
	HC	CRYE6E
	JR	R9

	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	SWRCHU:
::	FUNCTION:	FORMAT CHANNEL IN USE NODE REPORT TO SUPERVISOR.
::	CALLING SEQ:	JAL	R10,SWRCHU
::	INPUT:		R5 = CHN = ABSOLUTE CHANNEL NUMBER OF CHANNEL IN USE
::		IF CHANNEL IS TO NEIGHBOR, HW3 CONTAINS RELATIVE CHANNEL
::		NUMBER AND HW2 HAS NEIGHBOR NUMBER.
::		IF CHANNEL NOT TO NEIGHBOR, HW3 CONTAINS ABSOLUTE CHANNEL #,
::		AND HW2 IS SET TO -1.
::	DESTROYED:	R0, R1, R2, R3, R4, R8, R9
::
::*********************************************************************

SWRCHU	ST	R10,CHUSAV		:SAVE LINK REGISTER
	LIS	R0,NR.CHU
	STH	R0,SUPMBF		:INDICATE CHANNEL IN USE NODE REPORT
	CLHI	CHN,LNKZFL		:IS THIS A LINK CHANNEL?
	JL	SWRCU2			:NO
	SH	CHN,LKZFKN,KN,KN	:YES - COMPUTE RELATIVE CHANNEL NUMBER
	STH	CHN,SUPMBF+4
	AH	CHN,LKZFKN,KN,KN	:RESTORE CHN
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	JFS	SWRCU3
SWRCU2	STH	CHN,SUPMBF+4		:ABSOLUTE CHANNEL NUMBER
	LCS	R0,1
	STH	R0,SUPMBF+2		:INDICATE NOT A NEIGHBOR CHANNEL
SWRCU3	STH	R0,CRYSBF+2		:NGHBR# FOR CRYPTO
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP

:	NOW COMPUTE CIRCUIT TIME FOR COMPANION NODE REPORT. HW2 CONTAINS
:	THE LIFETIME OF THE CIRCUIT IN SECONDS, AND HW3 REMAINS THE SAME.
	LHL	R1,IOTAB,CHN,CHN
	SRLS	R1,1			:COMPUTE BUFTIM INDEX
	NHI	R1,-4
	L	R0,SLOWC,,		:GET CURRENT TIME AND
	S	R0,BUFTIM,R1,		:SUBTRACT TIME WHEN CIRCUIT WAS BUILT
	CI	R0,0FFFF		:LONG TIME?
	JLEFS	SWRCH4			:NO
	LCS	R0,1			:YES, EXCEEDS HW RANGE. MAKE MAX VALUE
SWRCH4	STH	R0,SUPMBF+2		:STORE CIRCUIT LIFETIME
	LIS	R0,NR.CTM
	STH	R0,SUPMBF		:INDICATE CIRCUIT LIFETIME NODE REPORT
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP

:	FORMAT CRYPTOGRAM. LOW-ORDER HW CONTAINS CHN, UPPER BYTE HAS
:	CIRCUIT LIFETIME (IN SECONDS).
	LH	R0,SUPMBF+2		:GET CIRCUIT LIFETIME BACK
SWRCH6	SLL	R0,10			:ALIGN TO UPPER BYTE AND
	OR	R0,CHN			:COMBINE WITH CHANNEL
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM FOR
	HC	CRYE10			:CHANNEL IN USE
	L	R10,CHUSAV		:RESTORE R10
	JR	R10

::*********************************************************************
::
::	TABLE:		CIRSPK:
::	FUNCTION:	CIRCUIT SPEED TABLE
::
::*********************************************************************

CIRSPK	HC	CIRSP0
	HC	CIRSP1
	HC	CIRSP2
	IF	1-\SUPGCS	:ALLOW FOR MODIFICATION OF LEVEL 3 GOUGE SPEED
	HC	CIRSP3
	ELSE	:LEVEL 3 GOUGE OPTION SPECIFIED
	HC	SUPGCS
	EI	:1-\SUPGCS

::*********************************************************************
::
::	TABLE:		CIRSPB:
::	FUNCTION:	How much is allowed in the bufferlets when doing
::			backpressure relief.  for low speeds give them an
::			extra bufferlet since big bufferlets allows the
::			error in approximate BCT to be significant
::
::*********************************************************************

CIRSPB	HC	CIRSP0+cbsz
	HC	CIRSP1+cbsz
	HC	CIRSP2
	IF	1-\SUPGCS	:ALLOW FOR MODIFICATION OF LEVEL 3 GOUGE SPEED
	HC	CIRSP3
	ELSE	:LEVEL 3 GOUGE OPTION SPECIFIED
	HC	SUPGCS
	EI	:1-\SUPGCS

	SUBTTL	CRQ (Circuit building routines)

::*********************************************************************
::
::	SUBROUTINE:	CRQFCR:
::	FUNCTION:	BUILD A FULL CIRCUIT
::	CALLING SEQ:	JAL	R9,CRQFCR
::	INPUT:		R2 = BUFF #
::			R3 = SPEED (2 BITS)
::			R4 = ORIGIN PORT #
::			R5 = CHN = DESTINATION PORT NUMBER
::
::*********************************************************************

CRQFCR	NHI	R3,3			:MAKE SURE SPEED IS LEGAL
	STH	R2,IOTAB,R4,R4		:MAKE PERMUTER TABLE ENTRY AND
	AHM	R3,IOTAB,R4,R4		:INCLUDE SPEED BITS
	RBT	R4,ACP,,		:INDICATE ACTIVE PORT
	LCS	R0,1
	SR	R0,R4			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:MARK THAT ACTIVE
	STH	CHN,BF,R2,
	XHI	R2,4
	STH	R2,IOTAB,CHN,CHN	:COMPLEMENTARY PERMUTER TABLE ENTRY
	AHM	R3,IOTAB,CHN,CHN	:WITH SPEED BITS
	RBT	CHN,ACP,,		:FULL CIRCUIT MARKED AS ACTIVE
	LCS	R0,1
	SR	R0,CHN			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:FLAG AS ACTIVE PORT
	STH	R4,BF,R2,
	XHI	R2,4
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CRQHCR:
::	FUNCTION:	CREATES ONE HALF OF A CIRCUIT BY MAKING ENTRY
::		IN PERMUTER TABLE AND SETTING THE ATTENTION FLAG POINTER
::		OF THE CORRESPONDING BUFFER.
::	CALLING SEQ:	JAL	R9,CRQHCR
::	INPUT:		R2 = BUFFER #
::			R5 = CHN = ABSOLUTE CHANNEL #
::
::*********************************************************************

CRQHCR	XHI	R2,4			:THE CHAN # IS THE ATTENTION FLAG
	STH	CHN,BF,R2,
	XHI	R2,4
	STH	R2,IOTAB,CHN,CHN	:THE BUFF # IS THE PERMUTER TABLE ENTRY
	RBT	CHN,ACP,,		:CHANNEL NOW ACTIVE
	LCS	R0,1
	SR	R0,CHN			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:INDICATE ACTIVE PORT

	IF	CBZDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CRHDB1,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:CBZDBG

	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CRQALT:
::	FUNCTION:	SIGNALS CRQ OF NEEDLE BY PUTTING NEEDLE BUFF #
::			IN THE CRQ BUFFER (BUFF 0).
::	CALLING SEQ:	JAL	R9,CRQALT
::	INPUT:		R2 = NEEDLE BUFFER #
::	DESTROYED:	R1, R8
::
::*********************************************************************

CRQALT	ST	R9,CRQASV		:SAVE LINK REG
	CLHI	R2,CIRZBF		:RANGE CHECK BUFFER NUMBER
	JL	CRQAL1			:TOO LOW
	CI	R2,HBUFN-8
	JG	CRQAL1			:TOO HIGH
	LHI	R1,CRQZFL		:SET CRQ ATTN FLAG
	STH	R1,BF,R2,
	LR	R1,R2			:ALERT CRQ FIRST
	LIS	R2,CRQBUF
	JAL	R9,WHWI0,,		:WHWI0 ALLOWS USE OF BUFFER # 0
	LIS	R2,1			:INCREMENT CONSISTENCY COUNT
	AHM	R2,NC.CRQ		: OF CIRCUITS ATTEMPTED
	LR	R2,R1			:RESTORE BUFF #
	L	R9,CRQASV
	JR	R9			:RETURN

CRQAL1	CRASH.(.CRQC2)

::*********************************************************************
::
::	SUBROUTINE:	SUPCRQ:
::	FUNCTION:	BUILDS THE INITIAL CIRCUIT FROM THE SUPERVISOR
::			TO THE LEPRECHAUN OF ITS OWN BASE
::
::*********************************************************************

	IF	SUPER
SUPCRQ	ST	R9,WCDSAV		:SAVE RETURN
	JAL	R8,GFCBUF		:GET A FREE BUFFER PAIR
	SKIPAD(OP8463)			:immed. return - out of buffers!###wjl
	LHI	CHN,SUPER+2		:+4, ok - GET REL CHN FOR SUP INTERFACE
	SBT	CHN,SUPBPV,,		:ENABLE FLOW TOWARDS SUPERVISOR
	AHI	CHN,SUPZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER
	JAL	R9,CRQHCR
	XHI	R2,4			:COMPLEMENTARY BUFFER
	LHI	CHN,LEPZFL
	JAL	R9,CRQHCR
	L	R9,WCDSAV		:RESTORE R9
	JR	R9
	EI	:SUPER

::*********************************************************************
::
::	SUBROUTINE:	TRCRFT:/TRCIRC:
::	FUNCTION:	TEARS DOWN CIRCUIT AND REQUESTS REBUILD IF APROPPRIATE
::	LINK:		R10
::	INPUT:		R1 = ZAPPER (SOFT OR HARD)
::			R2 = BUFFER #
::
::*********************************************************************

:	TRCRFT - ENTRY POINT IF CALLED AS A RESULT OF FAT ZAPPER.
:	'PRD' POINTS TO NODE PAIR (FAT) WHICH FOLLOWS FAT ZAPPER.

TRCRFT	LB	R0,0,PRD
	STB	R0,RFAT			:MUST DO A BYTE AT A TIME SINCE NOT
	LB	R0,1,PRD		:ASSURED OF HALFWORD ALIGNMENT
	STB	R0,RFAT+1
	LB	R0,2,PRD
	STB	R0,RFAT+2
	LB	R0,3,PRD
	STB	R0,RFAT+3
	JFS	TRCR02

:	TRCIRC - ENTRY POINT IF NODE PAIR OF LINK OUTAGE NOT KNOWN.
:	REBUILD REQUEST WILL SEND -1'S IN NODE NUMBER FIELDS.

TRCIRC	LCS	R0,1
	ST	R0,RFAT			:NO FAT
TRCR02	ST	R10,TRCSV1		:SAVE LINK REG
	ST	R2,TRCSV2		:BUFFER INDEX OF CIRCUIT BEING ZAPPED
	CLHI	R1,ZAPPF		:IS IT A FAT ZAPPER?
	JEFS	TRCR10			:YES, REBUILDABLE
	CLHI	R1,ZAPPS		:SOFT ZAPPER REBUILDABLE TOO
	JN	TRCZP1			:NONE OF THE ABOVE
TRCR10	LHL	R0,REBREN,,		:REBUILD REQUESTS ENABLED?
	JE	TRCZPH			:NO, JUST HARD ZAP CIRCUIT
	LHI	R0,1F-PCKZB		:don't send if bzap pending
	TBT	R0,SQUEUE		:bufferzap scheduled
	JN	TRCZPH			:yes, hard zap circuit

	LR	R10,R2			:COMPUTE CIRCUIT #
	SRHLS	R10,3
	LR	R9,R10			:PRESERVE CRQBSY INDEX
	TBT	R9,CRQEND		:ARE WE A TERMINATION?		###GT
	JE	TRCZP1			:NO, PASS SOFT ZAPPER ON

	IF	REBILD			:REQUEST REBILD ONLY IF ENABLED	###gt
	TS	TRCSV2			:INDICATE CALLER SHOULD NOT

:	DEPOSIT NODE PAIR INFORMATION IN CIRCUIT'S BUFFER
	SLHLS	R10,2			:COMPUTE HBUFN			###GT
	AI	R10,HBUFN		:				###GT
	RBT	R9,SQFTMI		:CANCEL ACTIVE REBUILD TIMER	###CY
	RBT	R9,SQFTMO		:				###CY
	RBT	R9,SQFIXV		:NO SEQ FIX OR ACK SEEN ON THIS CRQ##CY
	TBT	R9,CRQBSY		:REBUILD ENABLED FOR THIS CIRCUIT?###CY
	JE	TRCZPH			:NO, MAKE NO REBUILD REQUEST	###CY
	LHL	R0,RNFLAG,R10,		:ARE WE THE CIRCUIT ORIGIN?
	JE	TRCZHC			:NO, CLEAR PERMUTER TABLE ENTRY ONLY
	LHL	R2,TVRBUF		:MAKE REBUILD REQUEST TO SUP
       IF       REBTAK			:if no supe, wait, send it a takeover
        JE      TRCZHC
       ELSE     :just zap it
	JE	TRCZPH			:NO SUP, MUST HARD ZAP CIRCUIT
       EI       :REBTAK
	LHI	R1,8000+MACHNM
	JAL	R9,WHWI,,
	LHI	R1,0D80
	JAL	R9,WHWI,,
	LHL	R1,RNFLAG,R10,		:NEEDLE FLAGS
	JAL	R9,WHWI,,
	LHI	R1,8080			:***TEMP PORT #
	JAL	R9,WHWI,,
	LHL	R1,RBASE,R10,		:BASE & HOST
	JAL	R9,WHWI,,
	LHL	R1,RHOSTN,R10,
	JAL	R9,WHWI,,
	LHL	R1,RINVC,R10,		:INVOICE
	JAL	R9,WHWI,,
	LHL	R1,RINVC+2,R10,
	JAL	R9,WHWI,,
	LHL	R1,RFAT
	JAL	R9,WHWI,,		:NODE PAIR OF LINK WHICH WENT OUT
	LHL	R1,RFAT+2
	JAL	R9,WHWI,,
	LHL	R2,TRCSV2+2		:GET ZAPPER-ENTRY BUFFER INDEX
	XHI	R2,4			:FLIP TO OPPOSITE BUFFER FOR CSETUP
	JAL	R8,CSETUP		:SET UP FOR REBUILD PARAMETERS
	JAL	R8,CRYPTO,,		:REBUILD REQUEST
	HC	CRYE11
	JAL	R9,CSTUP2		:REST OF LOG			###GT

TRCZHC	LHL	R2,TRCSV2+2		:GET BACK THE ZAPPER-ENTRY BUFFER
	LHL	R8,BF,R2,		:GET THE ZAPPER-EXIT CHANNEL NUMBER
	XHI	R2,4			:GET THE OPPOSITE BUFFER NUMBER
	LHL	R3,BF,R2,		:GET THE ZAPPER-ENTRY CHANNEL NUMBER
	CLHI	R8,LNKZFL		:IS ZAPPER-EXIT CHANNEL A TERMINATION?
	JL	TRCZH1			:YES, THIS WASN'T A PASSTHRU	###CY
	CLHI	R8,LNKLFL		:GREATER THAN LAST LINK CHANNEL?###CY
	JGE	TRCZH1			:				###CY
	CLHI	R3,LNKZFL		:TEST THE OTHER CHANNEL
	JL	TRCZH1			:IT TERMINATES, WASN'T A PASSTHRU##CY
	CLHI	R3,LNKLFL		:GREATER THAN LAST LINK CHANNEL?###CY
	JGEFS	TRCZH1			:				###CY
	LCS	R0,1			:THIS WAS A PASSTHRU
	AHM	R0,PASTHR		:DECREMENT COUNT OF ACTIVE PASSTHROUGHS
	ts	pasthc			:indicate a change to number of pthrus
        tbt     r3,cmdcts-(lnkzfl/8),,             :a command circuit?
        jefs    trczh1                  :nope, not one fewer in use
        ahm     r0,nbrcmd               :one fewer in use
:	NOTE CRQREB MUST INCREMENT AGAIN IF STUB REBUILT		###CY

TRCZH1	LIS	R0,0
	STH	R0,IOTAB,R3,R3		:CLEAR PERMUTER TABLE ENTRY
	SBT	R3,ACP,,		:PORT IS  NOW IDLE
	RBT	R3,CHS,,		:SUSPEND CHANNEL		###CY
	SBT	R3,CHS1,,		:		 		###CY
	LCS	R0,1			:ALSO SET NEGATIVE ACP ARRAY	###CY
	SR	R0,R3			:				###CY
	SBT	R0,ACP,,		:				###CY
	RBT	R0,CHS,,		:###CY
	SBT	R0,CHS1,,		:###CY
	RBT	R3,NFLAGS		:FREEZE OUTBOUND BUFFER
	LHI	R0,STUBFL
	STH	R0,BF,R2,		:CORRESPONDING BF IS SET TO STUBFL
	XHI	R2,4
	LR	R0,R2			:SET TIMEOUT
	SRHLS	R0,3
	SBT	R0,REBTMI
	L	R10,TRCSV1		:RESTORE LINK REG
	JR	R10			:RETURN

	EI	:REBILD	###GT

TRCZPH	LHI	R1,ZAPPH		:TO HARD ZAP WHEN NEEDED
	TS	TRCSV2			:PREVENT 'FAT' FROM TRAVELING
	LHL	R2,TRCSV2+2		:TO PASS A ZAPPER ON
	J	TRCZP3			:COMMON EXIT			###GT

:	AVOID CLEARING NEEDLE POINT IN BUFFER				###CY
TRCZP1	LHL	R0,BCT,R2,		:ANYTHING IN BUFFER?		###GT
	JE	TRCZP3			:SKIP IF EMPTY			###GT
	LR	R0,R1			:COPY ZAPPER TYPE		###GT
	JAL	R8,PCIS,,		:PEEK AT 1ST CHAR		###GT
	SIS	R1,3			:IS IT A ZAPPER PAIR?		###GT
	JNFS	TRCZP2			:SKIP IF NOT			###GT
	JAL	R8,PCI,,		:LOOK AT 2ND OF PAIR		###GT
	CLHI	R1,NEEDP&0FF		:CHECK FOR NEEDLE POINT		###GT
	JNFS	TRCZP2			:SKIP IF NOT			###GT
	LR	R1,R0			:RECOVER ZAPPER TYPE		###GT
	JAL	R9,ZAPXN		:ZAP WITHOUT CLEARING BUFFER	###GT
	JFS	TRCZP4			:ALMOST DONE			###GT
TRCZP2	LR	R1,R0			:RECOVER ZAP TYPE		###GT
TRCZP3	JAL	R9,ZAPX			:ZAP 1/2 CRQ			###GT
TRCZP4	L	R10,TRCSV1		:RESTORE RETURN ADDR		###GT
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	ZAPHRD:/ZAPX:/ZAPXN:/ZAPXNG:
::	FUNCTION:	Zaps first half of a circuit.  If the other half
::		is dead, returns the buffer (R2) to the free list.
::		May or may not clear the buffer (R2), depending on type of
::		zapper (R1) or entry point.
::	ENTRY POINTS:
::		ZAPHRD - Zaps circuit (hard zapper).
::		ZAPX   - Zaps circuit (zapper in R1).
::		ZAPXN  - Zaps circuit (zapper in R1), does not CBCLR.
::		ZAPXNG - Zaps circuit (2nd byte of zapper in R1),does not CBCLR
::	LINKS:		R9
::	INPUT:		R2 = buffer index.
::			R1 = zapper (not expected by ZAPHRD).
::	DESTROYED:	R0, R3, R8
::
::*********************************************************************

ZAPHRD	LHI	R1,ZAPPH

:	Enter here with zapper of choice in R1
ZAPX	HS	0
	IF	CBZDBG			:DEBUGGER			###LSH
	STM	R0,REGST
	JAL	R14,ZPHDB1,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:CBZDBG		

	CLHI	R1,ZAPPN		:IF A NON-GOBBLING TYPE...
	JE	ZAPXN			:DONT CLEAR BUFFER

	LR	R2,R2			:R2 = ORIG. BUFFER #.	###LSH
	JLR	R9			:IF BUFFER IS NOT THERE, JUST RETURN

	JAL	R8,CBCLR,,		:ELSE CLEAR THE ORIG. BUFFER FIRST
        IF      T2GATE          :gateway keeps another char count
        LHL     R8,BF,R2,               :               9/15/87 ###sdw
        SHI     R8,DISZFL               :get maybe isis port number
        JLFS    ZAPXN                   :not isis dport
        CLHI    R8,NDP                  :small enough?
        JGEFS   ZAPXN                   :too big
        TBT     R8,LOGING             :for ports in login mode
        JEFS    ZAPXN
        LIS     R3,0            :now the zapper cannot look like an already
        STB     R3,GLGCNT,R8,   :read and known about character pair.  ###sdw
        EI      :T2GATE

:	Enter here to bypass CBCLR.  Deposit zapper (R1) into buffer (R2)
:	and SPEED it along.  R2 = ORIG. BUFFER NUMBER
ZAPXN	LH	R3,BF,R2,		:IS IT DEAD-END OR ZAPPED CIRCUIT?##LSH
	JLE	ZAPX0			:IF YES, DON'T SEND ZAPPER. SKIP.###LSH

	EXBR	R1,R1			:DEPOSIT ZAPPER (ALWAYS A PAIR)	###CY
	JAL	R8,WCI,,
	EXBR	R1,R1

:	ENTRY POINT FOR ESYNC RTD DETECTING NON-GBBLNG ZPPER
ZAPXNG	JAL	R8,WCI,,
	LHL	R3,BF,R2,		:PORT OF ZAPPER EXIT
	JAL	R8,SPEED		:SPEED ZAPPER ALONG

:	Get zapper destination channel # (BF of entry buffer) to R3.
:	Switch R2 to complementary buffer index, get channel # of
:	zapper origin to R8.  If both channels are link channels,
:	decrement passthrough count.  Also, check to see if a
:	termination port and if so then decrement number of ports
:	in use (as displayed in ND cmd and in PL log).
ZAPX0	XHI	R2,4			:R2 = COMP. BUFFER NUMBER
	LHL	R8,BF,R2,		:PORT OF ENTRY
	CLHI	R8,LNKZFL		:lowest link channel
	JGEFS	ZAPX04			:possible passthrough
:	not a possible passthrough, but origination chn could be
:	counted as a PORT.
	CLHI	R8,INTZFL		:lowest Internal channel
	JL	ZAPX2			:if not then still not a pthru
	LCS	R0,1
	AHM	R0,HNPORT		:decrement ports in use
	J	ZAPX2			:and still not a passthrough

:	still possible passthrough
ZAPX04	CLHI	R3,LNKZFL		:DEC PASSTHRU CNT IF APPROPRIATE
	JL	ZAPX2
	CLHI	R3,LNKLFL		:R3 = BF OF ORIG. BUFFER
	JGE	ZAPX2			:R8 = BF OF COMP. BUFFER
	CLHI	R8,LNKLFL
	JGE	ZAPX2
	LCS	R0,1			:PASSTHROUGH CIRCUIT
	AHM	R0,PASTHR		:DECREMENT PASSTHROUGH COUNT
	ts	pasthc			:indicate a change to number of pthrus
        tbt     r8,cmdcts-(lnkzfl/8),,
        jefs    zapx2                   :not a cmd circuit
        ahm     r0,nbrcmd               :was a cmd circuit

:	Skip to here if not passthrough or fall thru after decrementing
:	passthru count.
ZAPX2	HS	0
	IF	T2GATE
::Count a port and send "cleared" message if appropriate
	st	r11,savekn		:save kn from corruption in aarlo
        st      r4,zapxs2               :R4 is needed by inthst zaps
        sth     r3,GASAVE               :is restored soshould be saved
        STH     CHN,GZAPSV              :save some regs to allow some work regs
        STH     R8,GZSAVE
        LIS     R0,0
        STH     R0,GRSAVE+2             :mark no ISIS port known yet
	CLHI	R8,DISZFL               :r8 (channel received zap) ISIS port?
	JGEFS	GZPCX0			:nope too small
        CLHI    R3,DISZFL               :either a Dispatcher port?      ###sdw
        JL      GZPCX6                  :neither a Dport, skip gateway stuff
        J       GZPCX2                  :R2 probably a dport
GZPCX0	CLHI	R8,DISZFL+NDP		:
        JGE     GZPCX2                  :thus r3 is the ISIS port
::Zapper came from I-Net, if not login  we must re-emit zap to clear port
	LHI	R5,-DISZFL,R8		:Get dispatcher port from known BF
        STH     R8,GRSAVE+2             :we have an ISIS port (channel #)
	TBT	R5,LOGING		:Skip if in log-in mode
	JN	GZPCX4
	LHI	R1,09F00
	JAL	R8,DIRMES,,		:Re-issue Zap to clear port
	J	GZPCX4                  :only clear out one ISIS port
GZPCX2	CLHI    R3,DISZFL               :is r3 an ISIS port?
        JL      GZPCX4                  :nope do accounting
        CLHI    R3,DISZFL+NDP           :
        JGE     GZPCX4
        LHI     R5,-DISZFL,R3           :channel to isis port
        TBT     R5,LOGING               :login mode means others does msgs
        JN      GZPCX4                  :account for logon mode zaps    ###sdw
::Now send "inter-link cleared" message if appropriate
	TBT	R5,GORGPT		:and being from the host to terminal
	JE	GZPCX4			:(an I-net to H-net log-in)
	TBT	R5,GTTRNS		:No messages for transparent
	JN	GZPCX4
        XHI     R2,4                    :flip to ISIS (direction of zap)
        ST      R9,GESAVE               :save link reg
        JAL     R8,GCD,,                :remove zapper
        JAL     R8,GCD,,
	LA	R4,GNGONE,,
	JAL	R9,BUFCAN,,
	ROUTE(ISISN,HOMEN)		:put it in the buffer
        LHI     R1,8D8A
        JAL     R9,W2CI,,
        LHI     R1,ZAPPN
        JAL     R9,W2CI,,
        L       R9,GESAVE               :restore link reg
        XHI     R2,4                    :flip to NET (where zap started)
::Now perform Log-out accounting if appropriate
GZPCX4	LHL     R1,GRSAVE+2             :was r8 an ISIS port?
        JEFS    GZPCX5                  :nope
        SHI     R1,DISZFL               :knock down to port
        TBT     R1,GDSTPT               :destination port?
        JEFS    GZPCX5                  :r8 was not dest ISIS port
        LR      R5,R1                   :it was so set it up
GZPCX5	LHI	R3,DISZFL,CHN		:Make absoulute channel
	CLHI	R3,MNACHN
	JL	GZPCX6
	CLHI	R3,MXACHN		:do accounting range check
	JGE	GZPCX6
        TBT     CHN,GDSTPT              :destination port
        JE      GZPCX6                  :nope, no accounting
	LHL	R0,AAREAS		:Load previously stored reason
	JE	GZPCX6			:Skip if no reason
	LHI	R3,-MNACHN,R3		:Make relative accounting port index
	ST	R2,GESAVE		:Better save buffer number
	ST	R9,GRSAVE		:(We are in reg 9 right now)
	JAL	R8,AARLO,,		:Perform accounting logout stuff
	LIS	R0,0
	STH	R0,AAREAS		:Re-init accounting logout reason
	L	R2,GESAVE		:Get back Loretta'
	L	R9,GRSAVE
GZPCX6	LHL	R3,GASAVE		:...and proceed ....
	LHL	R8,GZSAVE		:and continue
	L	R11,SAVEKN		:restore R11/KN
	LHL	CHN,GZAPSV
        l       r4,zapxs2               :restore r4 saved at ZAPX2
	LIS	R0,0
	EI	:T2GATE

	EXHR	R0,R8			:put source chn in high hw
	OR	R0,R3			:AND COMBINE
	JAL	R8,CRYPTO,, 
	HC	CRYE0C			:ENTRY ON LEFT, EXIT ON RIGHT
:	Clear the complementary buffer.  
:	If the zapper entry point is a real channel (>CRQZFL), make sure
:	its IOTAB entry is consistent (i.e., it should be the buffer index
:	we entered with).  If not, crash.
	JAL	R8,CBCLR,,		:CLEAR THE COMPLEMENTARY BUFFER
					:R3 = BF OF COMP. BUFFER
	LHL	R3,BF,R2,		:GET ENTRY PORT (AGAIN)
	CLHI	R3,CRQZFL		:IS THERE AN IOTAB ENTRY?
	JLE	ZAPX1			:NO
	LHL	R0,IOTAB,R3,R3		:MAKE SURE IT'S ALL CONSISTENT
	NHI	R0,-4
	XHI	R0,4
	CR	R2,R0
	JEFS	ZAPX1
	CRASH.(.ZAPCR)
:	Now see if the zapper is traveling toward LOGGER.
:	If not, skip to ZAPX7.
ZAPX1	XHI	R2,4			:R2 = ORIG. BUFFER NUMBER
	LHL	R0,BF,R2,
	CLHI	R0,LOGMIN
	JL	ZAPX7			:NOT TRAVELING TOWARD LOGGER
	CLHI	R0,LOGMAX
	JG	ZAPX7			:NOT TRAVELING TOWARD LOGGER

	IF	T2GATE
::************************************************************
::	If this is a Gateway, we must provide for the case of
::	a log-in from HNET to INET which will find the BF
::	in log-in state and no B2 message having been processed.
::	This is called an Early Zapper, and we must return the 
::	buffer in this case.  If a DIOTAB entry already exists,
::	then we can just pass the Zapper on and let GDB3 find it and
::	return the buffer at that time.
::	INPUT:	R2	=  buffer of inbound (from term)
::first be sure this comes from H-net
	XHI	R2,4
	LHL	R1,BF,R2,
	CLHI	R1,LNKZFL
	JL	GDZ001		:If not from Hnet, go around
	XHI	R2,4		:Return to f. t. buf
	STH	R3,AAR1SV	:save R3 for use later in Zapx7
	STH	R0,AAR2SV	:Save R0 for use in normal zap
	LR	R8,R2		:Load buffer to find complimentary CHN
	LHI	R1,NDP-1	:Number of channels to be considered
	XHI	R8,4		:Now use the complimentary buf # to match
MATCHN	HS	0
	LHL	R0,DIOTAB,R1,R1	:Get a table entry
	CR	R0,R8		:Is it the one we want?
	JN	MATCH8		:No
	LR	R8,R0		:Save it
	XHI	R0,4		:Should be .. let's check
	CR	R0,R2		:Better be equal
	JE	MATCHD		:Yes, found a match  (R1 = relative channel #)
	CRASH.(.FNCHC)		:Problem .. but wed'vd crashed anyway
MATCH8	SIS	R1,1		:End of range yet?
	JG	MATCHN
	J	MATCON		:Could be a problem .. if so we'll crash
MATCHD	LR	CHN,R1		:load  relative channel # discovered
	XHI	R8,4
	LHL	R1,BF,R8,	:Let's see if this is really it
	CLHI	R1,LOGMIN
	Jlfs	MATCH9
	CLHI	R1,LOGMAX
	JLEfs	MATHOK
MATCH9	CRASH.(.ZAPCR)		:Same mess
::Found a match- make sure we are HNET to INET log-on - reset bits etc.
MATHOK	TBT	CHN,GDSTPT		:(this test may not be necessary)##ev
	JE	MATCON
::Continue..expect ZAPPER PASSED IN GDB3 returns buffer 
	LHL	R3,AAR1SV
	J	ZAPX7	:The above will have been executed in lieu
			: of the code below for "normal" node code
			:log-ins, so jump around the following
			:clear tables and expect GDB3 to RFCBUF and Zap prt

::Come here for Hnet login not initiated with B2 response yet
MATCON	HS	0
	LHL	R3,AAR1SV
	LHL	R0,AAR2SV
	J	ZAPX6	:Needle not sent down yet .. return buffer and
			:expect GDB2 to catch this
::If in login mode and not from H-net, come here
GDZ001	HS	0
	XHI	R2,4
			:Fall through here to Inet - Hnet login
	EI	:T2GATE
::	Come here for normal Node Code Log-in processing
:	The needle has not been sent down yet.	The port is in login mode, 
:	and the zapper is traveling toward LOGGER, see if the TID has 
:	been sent to the sup.  If it has, let the zapper go to the sup
:	and RETURN.  The sup will respond with a zapper ack, at which time
:	we will clear the channel and free the buffer.  If TID not yet sent,
:	we can clean things up ourselves without fear of a race condition
:	in reassigning a port which the sup thinks is still in login mode.
	IF	T2GATE
	OHI	R0,LOGSUP		:Gateway only requires bit 4
	ELSE
	OHI	R0,LOGSUP+LOGNDC	:MAKE SURE ZAPPER TRAVELS
	EI	:T2GATE
	STH	R0,BF,R2,
	THI	R0,LG.TID		:HAS TID BEEN SENT TO SUP?
	JER	R9			:YES, SEND ZAPPER TO SUP.
:	ZAPPER CONFIRMATION WILL FREE CHANNEL AND BUFFER (SEE LEPZLI).

::For Gateway we must emit a Zap to free dispatcher port
::Or we will clear tables and return buffer below, in which case we are in 
::log-in mode and must send a Zap to Dispatcher to clear the port for reuse.
	IF	T2GATE
	XHI	R2,4			:Get to-terminal buffer
	LHL	R5,BF,R2,		:Get channel number
        XHI     R2,4                    :restore from terminal buffer
	SHI	R5,DISZFL		:Make into dispatcher port

:  The following test for loging is to take care of INET which logged
:  into HNET and back to INET.  While in login mode the orig INET channel
:  has BF of being in loging mode when in fact the secondary channel is
:  actually sending the B3 messages.  The secondary channel BF are to the
:  orig INET port and of login mode.  The trouble is that a zap on the orig
:  channel while the secondary is in login would notice that is built a
:  circuit (by the loging bit) and that it was in login mode (by BF) and
:  send two zaps back on the origin channel and none one the secondary chann
:  and return the buffers.  Thus, a test for the LOGING bit determines whether
:  this channel is really an INET-HNET (LOGING set) or INET-HNET-INET (loging
:  reset).       ###sdw

        TBT     R5,LOGING               :make sure login port
        JE      ZAPX7                   :###sdw
	LHI	R1,09F00
        STH     R3,GASAVE
	JAL	R8,DIRMES,,		:Send zapper
        LHL     R3,GASAVE               :save R3 and fix link snip ###sdw
	EI	:T2GATE

:	Fall thru to here for the case that port in login mode,
:	zapper is travelling toward LOGGER, and the TID is still in buffer.
:	Remove the buffer from the LOGGER list.  Set the buffer's BF to 0
:	so it will be treated like a dead end below (buffer released).
:	Return the buffer, and stop circuit right here.

ZAPX6	HS	0
	LIS	R0,0			:ZERO BF SO THAT BUFFER GETS RETURNED 
	STH	R0,BF,R2,		:(SEE TEST BELOW)

	J	ZAPX7			:RETURN BUFFER AND INDICATE PORT
					:AVAILABLE. ALSO CLEAR LOGGER LIST##LSH

:	Skip to here for:
:		1.  all the passthrough nodes.
:		2.  ISIS originating node, as long as the needle has been sent
:			 down already.
:		3.  after cleaning up for login port with TID still in buffer
:			 (see ZAPX6).
:	Flip to the complementary buffer and set its BF to 0.
:	Set the zapper entry port's IOTAB entry to 0.  Free the port (ACP),
:	and temporaily suspend it (CHS, CHS1).
ZAPX7	HS	0			:###LSH
        IF      T2GATE
        IF      CBZDBG                  :debug this too (like ZAPV)
	STM	R0,REGST
        JAL     R14,GPZDB2,,
        GL      GPZDB2
	LM	R0,REGST		:restore regs		###sdw
        EI   :CBZDBG
        EI    :T2GATE

	XHI	R2,4			:R2 = COMP. BUFFER NUMBER
	if	autrac
	lhl	r0,bf,r2,
	jefs	zapx72
	rbt	r0,atrchn,,		:tracing enabled by criteria?
	jefs	zapx72
	rbt	r0,trchan,,		:also disable tracing
zapx72
	ei	:autrac
	LIS	R0,0
	STH	R0,BF,R2,		:CLEAR COMPLEMENTARY BUFFER'S BF
	STH	R0,IOTAB,R3,R3		:CLEAR THE PERM TAB ENTRY
	SBT	R3,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R3,CHS,,		:SUSPEND PORT WHILE ZAPPER CLEARS,
	SBT	R3,CHS1,,		:MAKE IT AVAILABLE IN 30-60 SECS
       IF	APLYBP
	CLHI	R3,LNKZFL		:if a link chn
	JLFS	ZAPX75
	CLHI	R3,LNKLFL		:if a link chn
	JGFS	ZAPX75
	RBT	R3,ABPVCP-(LNKZFL/8),,	:stop updating BPSCNT and LNKBPV
       EI	:APLYBP
ZAPX75	LCS	R0,1
	SR	R0,R3			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:BUT TEMPORARILY SUSPENDED
	SBT	R0,CHS1,,		:8-SECOND LOGIC WILL REINSTATE CHANNEL

:	Flip back to the original buffer.  If it doesn't point to a dead-end
:	circuit (BF=0) or circuit stub (BF=STUBFL) then just RETURN.
	XHI	R2,4			:R2 = ORIG. BUFFER NUMBER
	LHL	R0,BF,R2,		:IS THIS A DEAD-END CIRCUIT
	JEFS	ZAPX3			:YES, RETURN BUFFER
	CLHI	R0,STUBFL
	JNR	R9			:NOT A STUB EITHER

:	Dead-end or stub, release buffer, then RETURN.
ZAPX3	ST	R1,YAKT1
	JAL	R8,RFCBUF,,		:RETURN BUFFER
	ST	R9,ZAPXS1		:STORE LINK REGISTER		###LSH
	ST	R6,ZAPXS2		:STORE R6 			###LSH 
	LR	R6,R2			:COPY BUFFER # INTO R6		###LSH
	st	R4,ZAPXS3		:store r4
	JAL	R9,LOGCLR		:REMOVE BUFFER # FROM LOGGER LIST##LSH
	L	R9,ZAPXS1		:RESTORE LINK REGISTER		###LSH
	L	R4,ZAPXS3		:restore r4
	L	R6,ZAPXS2		:RESTORE R6 			###LSH
	L	R1,YAKT1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	ZAPV:
::	FUNCTION:	Zaps the last half of a circuit.
::	CALLING SEQ:	JAL	R9,ZAPV
::
::*********************************************************************

:	See if zapper destination is real circuit.  If so, make sure
:	IOTAB is consistent (crash if not). If not, skip to ZAPV1.
ZAPV	HS	0
	IF	CBZDBG			:DEBUGGER			###LSH
	STM	R0,REGST
	JAL	R14,ZPVDB1,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:CBZDBG		

	LHL	R1,BF,R2,		:GET DESTINATION CHANNEL NUMBER
	CLHI	R1,CRQZFL		:SHOULD WE HAVE AN IOTAB ENTRY?
	JLE	ZAPV1			:NO - CIRCUIT NOT YET BUILT
	if	autrac
	rbt	r1,atrchn,,		:tracing enabled by criteria?
	jefs	zapv02
	rbt	r1,trchan,,		:also disable tracing
zapv02
	ei	:autrac
:	see if this chn is a termination chn (ie a PORT) and if so
:	decrement ports in use.
	CLHI	R1,LNKZFL		:lowest link channel
	JGEFS	ZAPV04			:not a termination chn
	CLHI	R1,INTZFL		:lowest Internal channel
	JLFS	ZAPV04			:not a termination chn
	LCS	R0,1
	AHM	R0,HNPORT		:decrement ports in use

ZAPV04	LHL	R0,IOTAB,R1,R1		:YES, DO CIRCUIT CONSISTENCY CHECK.
					:GET OPPOSITE CHANNEL'S BUFFER INDEX,
	NHI	R0,-4			:STRIP SPEED BITS,
	XHI	R0,4			:COMPUTE COMPLEMENTARY BUFFER INDEX,
	CR	R2,R0			:SHOULD EQUAL BFR INDEX WE ENTERED WITH
	JEFS	ZAPV1			:IOTAB ENTRY CONSISTENT
	CRASH.(.ZAPC0)			:Failed consistency check.
:	Here if circuit not real or if real and consistent.
:	Clear destination channel's IOTAB entry, clear port (ACP),
:	suspend it temporarily (CHS, CHS1).
ZAPV1	LIS	R0,0
	STH	R0,IOTAB,R1,R1		:CLEAR IOTAB ENTRY
	SBT	R1,ACP,,		:PORT NO LONGER IN USE
	RBT	R1,CHS,,		:BUT SUSPENDED TEMPORARILY
	SBT	R1,CHS1,,		:ENABLE REINSTATEMENT BY 30-SEC LOGIC
       IF	APLYBP
	CLHI	R1,LNKZFL		:if a link chn
	JLFS	ZAPV12
	CLHI	R3,LNKLFL		:if a link chn
	JGFS	ZAPV12
	RBT	R1,ABPVCP-(LNKZFL/8),,	:stop updating BPSCNT and LNKBPV
       EI	:APLYBP
zapv12	LCS	R0,1
	SR	R0,R1			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:SUSPENDED FOR BOTH NEGATIVE
	SBT	R0,CHS1,,		: AND POSITIVE

:	Make sure complementary buffer's BF is 0.  Crash if not.

	LR	R1,R2			:COMPLEMENTARY BF BETTER BE 0
	XHI	R1,4
	LHL	R8,BF,R1,
	JEFS	ZAPV2
	CRASH.(.ZAPC1)
:	Everything OK, return buffer and RETURN.
ZAPV2	JAL	R8,RFCBUF,,		:AOK, RETURN BUFFER
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	GOBBLN:/GOBBLE:
::	FUNCTION:	Eat buffer contents, override backpressure,
::			put gobbler into buffer.
::	ENTRY POINTS:	GOBBLN, GOBBLE
::	LINK:		R9
::	INPUT:		R2 =  BUFFER INDEX
::	CALLS:		CBCLR, PCIS, SPEED, AND WCI
::
::*********************************************************************

:	Enter here to ignore gobbler if needle point or SQFIX in buffer.
GOBBLN	jal	r8,cbcct,,
	sis	r1,1			:start may be in buffer
	JlE	GOBBLE			:YES, DON'T CHECK FOR NEEDLE IN BUFFER
	JAL	R8,PCIS,,		:PEEK AT FIRST BYTE
	SIS	R1,3			:POSSIBLE NEEDLE POINT?
	JN	GOBBLE			:NO
	JAL	R8,PCI,,		:YES - CHECK NEXT BYTE
	CLHI	R1,NEEDP&0FF
	JE	gobbl0			:NEEDLE POINT - don't Gobble data
	CLHI	R1,SQFIX&0FF		:SEQUENCE FIX?			###GT
	JEfs	gobbl0			:YES - don't Gobble data
       IF       LOGII
        CLHI    R1,NEEDHD&0FF           :don't eat LOG II needles       ###sdw
	JEfs	gobbl0			:YES - don't Gobble data
        CLHI    R1,NEEDBD&0FF           :LOG II needle before CRQ runs  ###sdw
	JEfs	gobbl0			:YES - don't Gobble data
        CLHI    R1,NEEDCV&0FF           :converted LOG II needle at dispi
	JEfs	gobbl0			:YES - don't Gobble data
       EI       :LOGII

:	Here to gobble.
:	Clear buffer, SPEED it along, deposit gobbler, and RETURN.
GOBBLE	JAL	R8,CBCLR,,		:CLEAR BUFFER
gobbl0	LHL	R3,BF,R2,		:GET GOBBLER DESTINATION CHANNEL AND
:	if speed is going to override dispatcher backpressure, then
:	backpressure must be restored once gobbler is sent along.
	CLHI	R3,DISZFL		:DISPATCHER PORT?
	JLfs	gobbl1			:NO - TOO LOW
	CLHI	R3,DISZFL+NDP		:RANGE CHECK FOR DISPATCHER PORT
	JGEFS	gobbl1			:OUT OF RANGE
	rbt	r3,disgob-diszfl/8	:just in case it was not initialized
	tbt	r3,disbpv-diszfl/8
	jnfs	gobbl1
	sbt	r3,disgob-diszfl/8
gobbl1	JAL	R8,SPEED		:EXPEDITE GOBBLER
	LIS	R1,3			:PUT A GOBBLER IN IT
	JAL	R8,WCI,,		:				###OAS
	LIS	R1,GOBBL&0FF
	JAL	R8,WCI,,		:				###OAS
	JR	R9			:RETURN

	SUBTTL	CRQ (Utilities)

::*********************************************************************
::
::	SUBROUTINE:	CKTCON:
::	FUNCTION:	CIRCUIT CONSISTENCY TESTS.
::	CALLING SEQ:	JAL	R10,CKTCON  CALLED FROM 4-MINUTE LOGIC (G04MIN)
::
::*********************************************************************

:	ALL CIRCUIT ERRORS ARE COUNTED (SUCH AS CHANNEL IN USE, NO NEIGHBOR,
:	ETC.), AND, IF THEIR OCCURRENCES EXCEED A THRESHOLD, ARE REPORTED
:	TO THE PROBE LOG. IN ADDITION, THE NUMBER OF CIRCUITS ATTEMPTED
:	AND COMPLETED BY CRQ ARE COUNTED. IF THE SUM OF CIRCUITS IN ERROR
:	AND CIRCUITS COMPLETED DOES NOT EQUAL THE NUMBER OF CIRCUITS 
:	ATTEMPTED, A CONSISTENCY ERROR NODE REPORT IS GENERATED.

CKTCON	ST	R10,LNKRGS		:SAVE LINK REG
	LHL	R2,NC.LPE		:LEP CIRCUIT BUILDING ERRORS DETECTED
	AH	R2,NC.CRZ		:PLUS # OF CRQ CIRCUIT BUILDING ERRORS
	CLH	R2,NC.THS		:REPORTING THRESHOLD EXCEEDED?
	JL	CKTC10			:NO

	LHI	R0,NR.NCE		:SHOW CIRCUIT BUILDING ERRORS DETECTED
	STH	R0,SUPMBF
	LHL	R0,NC.LPE
	OHI	R0,8000			:NUMBER OF LEP ERRORS (+8000)
	STH	R0,SUPMBF+2
	LHL	R0,NC.CRZ
	OHI	R0,8000			:NUMBER OF CRQ ERRORS (+8000)
	STH	R0,SUPMBF+4
	JAL	R10,SUP12

CKTC10	LHL	R2,NC.CRC		:NUMBER OF CIRCUITS COMPLETED PLUS
	AH	R2,NC.CRZ		:NUMBER OF CIRCUITS IN ERROR
	SH	R2,NC.CRQ		:SHOULD EQUAL # OF CIRCUITS ATTEMPTED
	JE	CKTC40			:IT DOES

:	INTERNALLY DETECTED CONSISTENCY ERROR FOR COUNTING CIRCUITS
:	COMPLETED AND IN ERROR.
	LHI	R0,NR.CKC		:NODE REPORT
	STH	R0,SUPMBF		: FOR CIRCUIT BUILDING CONSISTENCY
	OHI	R2,8000
	STH	R2,SUPMBF+2		:WE ARE OFF BY THIS MANY
	LHL	R0,NC.CER
	AIS	R0,1			:INCREMENT COUNT OF
	STH	R0,NC.CER		: CIRCUIT CONSISTENCY ERRORS DETECTED

	OHI	R0,8000
	STH	R0,SUPMBF+4		:NUMBER OF OCCURRENCES
	JAL	R10,SUP12		:SEND NODE REPORT

CKTC40	LIS	R0,0
	ST	R0,NC.LPE		:CLEAR COUNTERS
	ST	R0,NC.CRZ
	L	R10,LNKRGS

        JR      R10

::*********************************************************************
::
::	SUBROUTINE:	SPEED:
::	FUNCTION:	Expedite zapper or gobbler by overridding backpressure
::			and setting channel service flag.
::	CALLING SEQ:	JAL	R8,SPEED
::	INPUT:		R3 = DESTINATION CHANNEL NUMBER
::
::*********************************************************************

:	Expedite zappers, gobblers.
:	If not dispatcher or link channel, just RETURN.
SPEED	CLHI	R3,DISZFL		:DISPATCHER PORT?
	JLR	R8			:NO - TOO LOW
	CLHI	R3,DISZFL+NDP		:RANGE CHECK FOR DISPATCHER PORT
	JGEFS	SPEED2			:OUT OF RANGE
:	Dispatcher port--override backpressure (DISBPV)
:	and set service flag (DISSVD), then RETURN.
	SBT	R3,DISBPV-DISZFL/8	:OVERRIDE BACKPRESSURE AND
	SBT	R3,DISSVD-DISZFL/8	:INSURE PROMPT SERVICE
	JR	R8
:	Link channel, override backpressure (BPSVCP)
:	and set service flag (CHSRVD), then RETURN.
SPEED2	CLHI	R3,LNKZFL		:LINK CHANNEL?
	JLR	R8			:NO - TOO LOW
	CLHI	R3,LNKLFL		:RANGE CHECK FOR LINK CHANNEL
	JGER	R8			:OUT OF RANGE
	SBT	R3,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE AND
	SBT	R3,CHSRVD-LNKZFL/8,,	:INSURE PROMPT SERVICE
        lhi     r0,200
        sth     r0,bpscnt-2*lnkzfl,r3,r3 :ensure it has xmit capability
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	NEDTIM:
::	FUNCTION:	COMPUTE AMOUNT OF TIME IT TOOK NEEDLE TO
::			COMPLETE TRIP THROUGH NODE.
::	CALLING SEQ:	JAL	R8,NEDTIM
::	INPUT:		R2 = BUFTIM INDEX IS 1/2 BUFFER INDEX
::	DESTROYED:	R0, R1, R3
::
::*********************************************************************

:	BUFTIM FOR THIS CIRCUIT CONTAINS THE FASTC TIME THAT NEEDLE
:	ORIGINATED IN NODE. THIS ROUTINE IS CALLED AS NEEDLE IS TERMINATING
:	CIRCUIT IN NODE. THE DIFFERENCE BETWEEN CURRENT FASTC AND BUFTIM
:	IS THE NUMBER OF FASTC TICKS THAT NEEDLE TOOK TO COMPLETE CIRCUIT
:	IN THIS NODE.

NEDTIM	LR	R1,R2
	SRLS	R1,1			:COMPUTE BUFTIM INDEX
	NHI	R1,-4
	L	R3,FASTC,,		:GET CURRENT TIME AND SUBTRACT
	S	R3,BUFTIM,R1,		:TIME NEEDLE ORIGINATED IN NODE
	CI	R3,10000		:check for halfword overflow	###jhl
	JLFS	NEDT08			:				###jhl
	LHI	R3,$A9999		:corresponds to about 16 2/3 secs##jhl
:	should be converted to msecs somewhere for display
	JFS	NEDT09			:				###jhl
NEDT08	CLH	R3,NEDHWM		:MORE THAN PREVIOUS HIGH-WATER MARK?
	JLEFS	NEDT10			:NO
NEDT09	STH	R3,NEDHWM		:YES - SAVE NEW HIGH-WATER MARK
NEDT10	LIS	R0,1
	AHM	R0,NEDCNT		:COUNT ALL NEEDLES TIMED
	SRLS	R3,2			:HISTOGRAM RECORDS IN FASTC/4 UNITS
	CLHI	R3,NEDTSZ/2		:IS TIME OUTSIDE OF HISTOGRAM RANGE?
	JLFS	NEDT20			:NO
	LHI	R3,NEDTSZ/2-1		:YES - SET TO MAX VALUE
NEDT20	AHM	R0,NEDHST,R3,R3		:RECORD NEEDLE TIME IN HISTOGRAM
	L	R0,SLOWC,,
	ST	R0,BUFTIM,R1,		:RECORD TIME THAT CIRCUIT IS BUILT
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	CHSUPD:
::	FUNCTION:	UPDATE CHS ARRAY.
::	CALLING SEQ:	JAL	R0,CHSUPD
::
::*********************************************************************

:	CHS IS RESET WHEN A ZAPPER TRAVELS ON A CIRCUIT TO
:	SUSPEND THAT CHANNEL UNTIL ZAPPER CLEARS MACHINE. WHEN CHS IS RESET,
:	CHS1 IS SET. THIS CAUSES THE CHANNEL TO BE REINSTATED 30 TO 60 SECONDS
:	LATER BY CHSUPD.

CHSUPD	LHI	R3,-ACPSZP*2		:SIZE OF CHS, CHS1, & CHS2 ARRAYS
	LR	R2,R3			: (POSITIVE AND NEGATIVE)

CHSUP2	L	R1,CHS2+ACPSZP,R3,
	O	R1,CHS+ACPSZP,R3,	:REINSTATE CHANNELS SUSPENDED
	ST	R1,CHS+ACPSZP,R3,
	AIS	R3,4
	JLBS	CHSUP2

CHSUP4	L	R1,CHS1+ACPSZP,R2,	:LATEST CANDIDATES FOR REINSTATEMENT
	ST	R1,CHS2+ACPSZP,R2,	:COPY TO CHS2 TO UPDATE CHS NEXT TIME
	ST	R3,CHS1+ACPSZP,R2,	:CLEAR CHS1 TO ZERO
	AIS	R2,4
	JLBS	CHSUP4
	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	CRTOUT:
::	FUNCTION:	PROCESS CIRCUIT TIME-OUTS
::	CALLING SEQ:	JAL	R10,CRTOUT	Called from 1-minute logic
::
::*********************************************************************

:	Bits set in REBTMI will be timed out next time.
:	Time out circuits whose buffers have bits set in REBTMO this
:	time, and then copy REBTMI into REBTMO.

	if	rebild

CRTOUT	LIS	R7,0			:zap circuits that have timed out
	LIS	R4,0			:word index into bit array,bits by buf#
CRTOU2	L	R1,REBTMO,R7		:get a word of bit flags
        JFFO    R1,CRTO09
        J       CRTOU3
CRTO09	AR	R2,R4			:bit index + word index into bit array
	RBT	R2,REBTMO		:turn off--pay attention only once
	SLHLS	R2,3			:POINTS TO THE RELEVANT BUFFER PAIR
	LHL	R0,BF,R2,		:ZAPPER MUST TRAVEL TOWARDS PORT
	CLHI	R0,CRQZFL		:if in CRQ range OK,
	JGFS	CRTO10			: else look other direction	###JHL
	XHI	R2,4
CRTO10	LHL	R0,BF,R2,		:report port # to XRAY		###jhl
	JAL	R8,CRYPTO,,
	HC	CRYE0F			:MESSAGE = NEEDLE TIMEOUT
       if       t2gate!acct
        lis     r0,aalr03
        sth     r0,aareas
       ei
	JAL	R9,ZAPHRD		:zap the circuit--clean up leftovers
       if       t2gate!acct
        lis     r0,0
        sth     r0,aareas
       ei
	J	CRTOU2			:and check bit array for more
CRTOU3	if	mortim
	l	r0,rebtm2,r7
	st	r0,rebtmo,r7
	l	r0,rebtm1,r7
	st	r0,rebtm2,r7
	L	R0,REBTMI,R7		:move next version of attention flags
	ST	R0,rebtm1,R7		: for subsequent pass
	else
	L	R0,REBTMI,R7
	ST	R0,REBTMO,R7
	ei	mortim
	ST	R1,REBTMI,R7		:clear the next-pass array
	AHI	R4,20			:increment our base buffer #
	AIS	R7,4			:increment our word index
	CLHI	R4,NCIRCS		:check for end of buffer range
	JL	CRTOU2			:do more
	JR	R10			:looked at flags for all buffers,return

	ei	:rebild

::*********************************************************************
::
::	SUBROUTINE:	RBDOUT:
::	FUNCTION:	PROCESS REBUILD TIME-OUTS			###GT
::	CALLING SEQ:	JAL	R10,RBDOUT
::
::*********************************************************************

:	WHEN THE SOURCE SENDS ON A NEEDLE, A SPECIAL SQFIX		###GT
:	(SEQN = 0) IS ALSO SENT. WHEN THE DESTINATION GETS		###GT
:	A NEEDLE, IT ALSO SENDS A SQFIX 0 TOWARDS THE SOURCE.		###GT
:	IF A FIX0 IS NOT RECEIVED ON EITHER END 1-2 MINUTES
:	AFTER A FIX0 IS SENT OUT, THE CIRCUIT WILL BE MARKED
:	AS NOT REBUILDABLE. HISTORY BUFFERS WILL BE CLEARED.

	IF	REBILD
RBDOUT	LIS	R7,0			:LOOK AT ALL CIRCUITS
	LIS	R4,0
RBDOU1	L	R1,SQFTMO,R7		:CHECK FOR CIRCUITS THAT TIMED-OUT
        JE      RBDOU4
        JFFO    R1,RBDOU3
RBDOU3	AR	R2,R4			:GET NUMBER
	RBT	R2,SQFTMO		:RESET TIME-OUT FLAG
	TBT	R2,SQFIXV		:CHECK IF A SQFIX HAS BEEN RECEIVED
	JN	RBDOU1			:YES - THE CIRCUIT IS REBUILDABLE
	SLLS	R2,3			:NO - FLAG AS NOT REBUILDABLE
	JAL	R9,RBCOUT		:RELEASE HISTORY BUFFERS AND LOG
	J	RBDOU1			:CHECK NEXT CIRCUIT
RBDOU4	L	R0,SQFTMI,R7		:PROCESS TIME-OUT
	ST	R0,SQFTMO,R7
	ST	R1,SQFTMI,R7		:CLEAR THIS
	AHI	R4,20			:NEXT SET OF CIRCUITS
	AIS	R7,4
	CLHI	R4,NCIRCS		:ALL DONE?
	JL	RBDOU1			:NOT YET
	JR	R10			:YES - RETURN
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	RBCOUT:
::	FUNCTION:	CLEAN UP AFTER A CIRCUIT IS FLAGGED AS NOT REBUILDABLE
::	CALLING SEQ:	JAL	R9,RBCOUT
::	INPUT:		R2 = BUFFER NUMBER
::
::*********************************************************************

	IF	REBILD
RBCOUT	LR	R1,R2			:SAVE BUFFER INDEX      	###GT
	XHI	R2,4			:GET INCOMING BUFFER
	LHL	R0,BF,R2,,		:GET THE INCOMING CHANNEL NUMBER
	JAL	R8,CRYPTO,,
	HC	CRYE6B			:MESSAGE = REBUILD DISABLED
	XHI	R2,4			:RESTORE BUFFER INDEX
RBCOU1	SRLS	R2,3			:FORM INDEX INTO BIT ARRAY
	RBT	R2,CRQBSY		:INDICATE CIRCUIT NOT REBUILDABLE
	RBT	R2,SQFTMI		:CLEAR REBUILD TIMEOUT		###CY
	RBT	R2,SQFTMO		:				###CY
	SLLS	R2,2			:GET HISTORY BUFFER INDEX
	LI	R2,HBUFN,R2		:FORM HISTORY BUFFER NUMBER
	JAL	R8,CBCLR,,		:CLEAR HISTORY BUFFER
	LIS	R0,0
	ST	R0,RINVC,R2,		:AND INVOICE NUMBER TO PREVENT REBUILDS
	LR	R2,R1			:RESTORE BUFFER INDEX        	###GT
	JR	R9
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	DETOUT:
::	FUNCTION:	DETACH TIMEOUT ROUTINE, RUN EVERY 30 SEC.
::	CALLING SEQ:	JAL	R10,DETOUT
::
::*********************************************************************

DETOUT	L	R4,DETACP,,		:ANY PORTS ACTIVE ?
	XHI	R4,-1			:COMPLEMENT WORD
	JER	R10			:NO, SKIP IT
	ST	R4,DETSVC		:SAVE THOSE NEEDING SERVICE

DETONX	L	R4,DETSVC		:DETACH TIMEOUT NEXT
	JFFO	R4,DETTO2
	JR	R10			:NONE LEFT, RETURN

DETTO2	RBT	CHN,DETSVC		:THIS ONE IS SERVICED
	LHL	R2,CIOTAB,CHN,CHN	:PERMUTER TABLE ENTRY
	SRLS	R2,1			:GET BUFTIM INDEX
	NHI	R2,-4
	L	R1,BUFTIM,R2,		:START TIME
	AHI	R1,$A60			:+ 60 SEC GIVES TIME TO STOP
	C	R1,SLOWC,,		:> NOW ?
	JG	DETONX			:NO, CONTINUE

:	PORT IN DETACH STATE HAS NOT BOUNCED ORANGE BALL IN OVER 60 SECONDS.
:	ZAP CIRCUIT...
	LHL	R2,CIOTAB,CHN,CHN	:GET BUFFER INDEX BACK
	NHI	R2,-4			:MASK OUT GOUGING BITS,
	JAL	R9,ZAPHRD		:AND ZAP CIRCUIT
	J	DETONX			:CONTINUE

	SUBTTL	CRQ  (DETCIR - Handle data for 'Detached Ports')

::*********************************************************************
::
::	SUBPROCESS:	DETCIR:
::	FUNCTION:	CIRCUITS ARRIVING FOR HOSTS OUT OF PORTS
::			ARE DETACHED INSTEAD OF MERELY BEING ZAPPED.
::	SCHEDULED:	Dispatched by SWITCH based on data being
::		detected on port in detached mode.  Returns to SWITCH
::		(DETRET) when done.
::
::*********************************************************************

:	THE TERMINATING HALF OF THE CIRCUIT IS BUILT TO THE DETACH PROCESS,
:	WHICH SUPPORTS $A32 PORTS BEGINNING WITH 'DETZFL'.  THE SETUP FOR
:	THE DETACH PROCESS INCLUDES STORING A VALUE IN THE 'DETMTY' BYTE
:	ARRAY (INDEXED BY CHANNEL) TO SPECIFY THE TEXT TO THE USER, AND
:	PASSING A NEEDLE POINT TO THE NEW CIRCUIT TERMINATION. WHEN DETCIR
:	DETECTS A NEEDLE IT SENDS TEXT TO THE USER FOLLOWED BY A YELLOW BALL,
:	AND STORES THE CURRENT TIME IN BUFTIM. IF AN ORANGE BALL IS RETURNED,
:	WE ZAP THE CIRCUIT (ALL OTHER INPUT IS TOSSED). IF NO ORANGE BALL IS
:	BOUNCED BACK, DETOUT WILL DETECT AND ZAP.

:	FOUND DATA ON A PORT IN 'DETACH' MODE
DETCIR	L	R4,DETFLG,,		:SEE WHICH PORTS NEED ATTENTION
	ST	R4,DETSVC		:SAVE PORTS SERVICED ARRAY

:	PROCESS NEXT PORT
DETNXT	L	R4,DETSVC		:GET PORTS THAT NEED ATTENTION
	JFFO	R4,DETCR2		:FIND FIRST
	J	DETRET,,		:NONE LEFT, EXIT

DETCR2	RBT	CHN,DETSVC		:MARK AS SERVICED
	LHL	R2,CIOTAB,CHN,CHN 	:GET BUFFER INDEX
	NHI	R2,-4
	XHI	R2,4			:POINT TO INCOMING BUFFER
	JFS	DETCR4			:START LOOKING FOR DATA

:	TEST FOR DATA REMAINING
DETCR3	LHL	R1,BCT,R2,		:CHARS LEFT IN BUFFER?
	JE	DETNXT			:NO, TRY NEXT BUFFER
DETCR4	JAL	R8,GCI,,		:GET CHARACTER
	LR	R1,R1			:ESCAPE?
	JNFS	DETCR5			:NO
	JAL	R8,GCI,,		:YES, GET DATA BYTE (AND IGNORE)
	JBS	DETCR3

DETCR5	CLHI	R1,03			:ZAPPER, GOBBLER, NEEDLE?
	JE	DETCR7			:YES
	SIS	R1,01			:PREFIX CODE?
	JN	DETCR3			:NO, KEEP LOOKING
	JAL	R8,GCI,,		:YES, LOOK FOR ORANGE BALL
	CLHI	R1,0FE			:ORANGE BALL?
	JN	DETCR3			:NO, KEEP LOOKING

:	FOUND AN ORANGE BALL, ZAP CIRCUIT BOTH WAYS
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP IT ALL
	J	DETNXT			:LOOK AT NEXT PORT

:	FOUND ZAPPER, GOBBLER, ETC
DETCR7	JAL	R8,GCI,,		:GET SECOND BYTE
	CLHI	R1,NEEDP&0FF		:NEEDLE?
	JEFS	DETCR8			:YES
	CLHI	R1,ZAPPN&0FF		:ZAPPER?
	JG	DETCR3			:NO, KEEP LOOKING
	JAL	R9,ZAPV			:ZAP 2ND HALF
	J	DETNXT			:LOOK AT NEXT PORT


:	FOUND NEEDLE, CLEAR BUFFER, SEND CANNED MESSAGE BACK TO USER
DETCR8	JAL	R8,CBCLR,,		:CLEAR INPUT BUFFER (NEEDLE AND DATA)
        XHI     R2,4                    :POINT OPPOSITE THE NEEDLE JUST READ
	LB	R4,DETMTY,CHN		:GET MESSAGE TYPE
       if       t2gate                  :gateway has no message option
        clhi    r4,0ff
        jefs    detcr9
       ei       :t2gate
	LHL	R4,DETMTB,R4,R4		:GET ADDRESS OF MESSAGE (LESS SEG1)
	AI	R4,SEG1
	JAL	R9,BUFCAN,,		:OUTPUT 'CANNED MESSAGE' TO BUFFER
DETCR9	LIS	R1,1			:OUTPUT YELLOW BALL
	JAL	R8,WCI,,
	LHI	R1,0FF
	JAL	R8,WCI,,

	SRLS	R2,1			:SET UP BUFTIM INDEX - BUFFER
	NHI	R2,-4			:NUMBER TIMES 2
	L	R0,SLOWC,,
	ST	R0,BUFTIM,R2,		:STORE TIME FOR POSSIBLE TIME-OUT

	J	DETNXT			:LOOK AT NEXT PORT

	SUBTTL	CRQ (TRACE - Circuit tracing logic)

::*********************************************************************
::
::	SUBROUTINE:	TRACE:
::	FUNCTION:	CIRCUIT TRACING LOGIC
::	CALLING SEQ:	JAL	R10,TRACE
::	INPUT:		R5 = CHN = ABSOLUTE CHANNEL NUMBER TO BE TRACED
::			REJECTS TRACE REQUEST IF NO CIRCUIT EXISTS
::
::*********************************************************************

TRACE	LHL	R2,IOTAB,CHN,CHN	:IS THERE A CIRCUIT THERE
	NHI	R2,-4
	JE	TRACE6			:NO
	LHL	CHN,BF,R2,		:EXIT PORT #
	LCS	R1,4			:GET HOST OR NODE AND RELATIVE PORT #
TRACE1	AIS	R1,4
	CLH	CHN,CHNMAP,R1
	JLBS	TRACE1
	SH	CHN,CHNMAP,R1
	LHL	R1,CHNMAP+2,R1
	THI	R1,8000			:TEST FOR INTERNAL CIRC, R1 HAS HOB SET
	JN	TRACE4			:YES, INTERNAL TERMINATION

	LHL	R1,CHNMPD,R1		:GET NEIGHBOR NUMBER
	THI	R1,8000			:TEST FOR TERMINATION, C000+NODE#
	JN	TRACE4			:YES

TRACE2	JAL	R9,FNDLNK		:IT'S A T-II NEIGHBOR, MAKE SURE ITS UP
	SKIPAD(TRACE6)			:immed return, NOT FOUND	###wjl
	LHL	R2,LKZFKN,KN,KN		:+4 return, UP, GET IT'S ILC BUFFER #
	LHL	R2,IOTAB,R2,R2
	NHI	R2,-4
	XHI	R2,4
	LIS	R0,1
	AHM	R0,LEPMES+2		:INC THE NODE COUNT
	STH	R1,LEPMES,PRD		:ADD NODE, CHANN TO LIST
	STH	CHN,LEPMES+2,PRD
	LHI	LRC,4,PRD
	LIS	PRD,0			:MOVE MESSAGE TO ILC BUFFER
	LHI	R1,1,LRC		:BYTE COUNT
	JAL	R8,WCI,,
TRACE3	LB	R1,LEPMES,PRD
	JAL	R8,WCI,,
	AIS	PRD,1
	CR	PRD,LRC
	JLBS	TRACE3
	JR	R10

:	TERMINATION, ADD HOST AND PORT #
TRACE4	CI	R1,0FFFD		:THIS A DISPATCHER PORT?(-3 FOR 16BITS)
	JNFS	TRACE7			:NO, SKIP IT
	LHL	R1,DHSTIX,CHN,CHN	:GET HOST NUMBER
	OHI	R1,8000			:WITH MSB SET

TRACE7	STH	R1,LEPMES,PRD		:
	STH	CHN,LEPMES+2,PRD	:<COUNT OF NODES>
	LHI	R1,148A			:GENERAL FUNCTION (14),
	STH	R1,LEPMES		:TRACE RESPON. (0A)+80

	LHI	LRC,4,PRD		:GET SIZE OF LEP MESSAGE
	LIS	PRD,0
	LHL	R2,TVRBUF		:TEST FOR SUP
	JER	R10			:NO ACTIVE SUP, SKIP IT
	LHI	R1,MACHNM+8000		:SEND NODE NUMBER AS 1ST HW
	JAL	R9,WHWI,,
TRACE5	LHL	R1,LEPMES,PRD		:SEND ALL OF LEP MESSAGE
	JAL	R9,WHWI,,
	AIS	PRD,2
	CR	PRD,LRC
	JLBS	TRACE5
	JR	R10

TRACE6	LCS	R1,1
	LCS	CHN,1			:NONEXISTENT CIRCUIT
	J	TRACE4

	IF	LOGII			:some LogII CRQ utilities
::*********************************************************************
::
::	SUBROUTINE:	L2CHWI:	Log 2 Cover HalfWord Immediate
::	FUNCTION:	Covers neighbor number in LogII needle and
::			other housekeeping chores.
::	CALLING SEQ:	JAL	R9,L2CHWI
::	INPUT:		Expects R2 and R3 as pointers
::	PRESERVED:	R7
::	CALLS:		JAL	R9,WCDE/WCD/TRUNC
::	RETURNS:
::
::*********************************************************************

L2CHWI	ST	R9,L2CHSV,,		:store return address

        JAL     R9,TRUNC,,              :clear upto next element	
        LR      R1,R7                   :new len of element (could be 0)
        JNFS    L2CH10                  :zero means no element
        AIS     R5,3                    :2bytes for id, one for 1
        J       L2CH15                  :skip needle element
L2CH10  JAL     R9,WCDE,,               :len 0 is okay (null element)
        LHI     R1,MO.AC1+ID.NNL        :header ID
        JAL     R9,WCDE,,
L2CH15  LHL     R1,X4T.LN+X4TBBG,,      :get overall len of head
        SR      R1,R5
        JAL     R9,WCDE,,               :new len of needle head element
        CLHI    R1,100
        JLFS    L2CH40                  :not 2 byte len
        EXBR    R1,R1
        JAL     R9,WCDE,,               :high byte of 2 byte len
        LHI     R1,MO.LFM+2
        JAL     R8,WCD,,                :and len of len
        JFS     L2CH41
L2CH40  CLHI    R1,MO.LFM               :long form?
        JLFS    L2CH41
        LHI     R1,MO.LFM+1
        JAL     R8,WCD,,                :1 byte long form
L2CH41  LHI     R1,MO.AC2+ID.NCH        :Node Code Needle Head MO
        JAL     R8,WCD,,
        EXBR    R1,R1
        JAL     R8,WCD,,
        LHI     R1,NEEDHD               :write back needle head
        JAL     R8,WCD,,
        EXBR    R1,R1
        JAL     R8,WCD,,
        LHL     R7,CQNFLG               :mainline expects flags in R7

L2CH99	L	R9,L2CHSV		:restore return address
	JR	R9			:and return to caller
::----------------------------------------------------------------------
::	End of some LogII CRQ utilities
::----------------------------------------------------------------------
       EI       :LOGII

	IF	T2GATE
::*********************************************************************
::
::	SUBROUTINE:	GLZPV:	Gateway Login ZaPV
::	FUNCTION:	Used to Zap half a circuit in response to a
::			Zap Ack from dispatcher...or second time around
::			if Zap from Inet is received and aked with 
::			DISZNK set for the channel.
::	CALLING SEQ:	JAL	R9,GLZPV
::	INPUT:		CHN	Relative Dispatcher port
::	RETURNS:	JR	R9
::
::*********************************************************************

GLZPV	HS	0
        IF      CBZDBG                  :debug this too (like ZAPV)
	STM	R0,REGST
        JAL     R14,GPZDB1,,
        GL      GPZDB1
	LM	R0,REGST		:restore regs		###sdw
        EI   :CBZDBG

	LR	R1,CHN
	RBT	R1,DISFLG,,
	AHI	R1,DISZFL		:Make absolute channel #
	LIS	R0,0
	STH	R0,IOTAB,R1,R1		:CLEAR IOTAB ENTRY
	SBT	R1,ACP,,		:PORT NO LONGER IN USE
	RBT	R1,CHS,,		:BUT SUSPENDED TEMPORARILY
	SBT	R1,CHS1,,		:ENABLE REINSTATEMENT BY 30-SEC LOGIC
	LCS	R0,1
	SR	R0,R1			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:SUSPENDED FOR BOTH NEGATIVE
	SBT	R0,CHS1,,		: AND POSITIVE
GLPZV2	JR	R9
	EI	:T2GATE

	ENDMO.(CRQ)

	EI	:1-KILLIT

	KILMSG(CRQ)

:	***NOTHING PAST THIS POINT***

	SUBTTL	INTHST

:		***** *   * ***** *   *  **** *****
:		  *   **  *   *   *   * *       *
:		  *   * * *   *   *****  ***    *
:		  *   *  **   *   *   *     *   *
:		***** *   *   *   *   * ****    *

::#####################################################################
::
::	MODULE:		INTHST
::
::	FUNCTION:	Process data for internal hosts (remote XRAY,
::		downline load, delay measurement processing).
::
::	SUBTTLS:
::		INTHST - Internal host processor
::		Utilities
::		DWLIN - Handle Down-Line Load record from neighbor
::		DLYSRC - Delay measurement source
::		INTTIM - Internal Host Time-Out logic
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	SEG	a.code

:	THE FOLLOWING SYMBOL IS USED AS A BASE ADDRESS TO ALLOW ROUTINE
:	ADDRESSES TO BE STORED AS HALF-WORDS IN INTDSP
SEG1.2	HS	0			:###wjl


::*********************************************************************
::
::	SUBPROCESS:	INTHST:
::	FUNCTION:	INTERNAL HOST PROCESSOR
::	SCHEDULED:	Dispatched by SWITCH based on internal host
::		channels with data requesting service.  Returns to
::		SWITCH (INTRET) when done.
::
::*********************************************************************

:	THE INTERNAL HOST ATTENTION FLAGS START AT INTZFL
:
:	THE INTERNAL HOST PROCESSOR FIRST TESTS THE CHN FOR A ZAPPER,
:	AND COMPLETES THE ZAP IF ONE IS FOUND. ELSE, THE DISPATCH ADDRESS
:	ARRAY INTDSP IS EXAMINED FOR A VALID ( >0 ) ADDRESS, AND A DISPATCH
:	IS DONE ACCORDINGLY.  FOR A ZERO DISPATCH ADDRESS THE CHANNEL IS
:	PRESUMED IN LOGIN MODE AND THE USERNAME IS STRIPPED AND THE FUNCTION
:	BYTE EXAMINED.  CERTAIN USER NAMES REQUIRE NO FUNCTION BYTE.
:	INITIALLY TIMEOUT IS ENABLED ON ALL NEW INTERNAL HOST CHANNELS 
:	BY SETTING THE CORRESPONDING BIT IN INTOUT. SUBSEQUENTLY TIMEOUT
:	IS DISABLED FOR CERTAIN FUNCTIONS.

INTHST	LH	R3,INTFLG,,		:TEST ALL THE FLAGS
	JNFS	INTH10
	CRASH.(.INTCR)
INTH10	STH	R3,INTLST		:SAVE FOR LATER REFERENCE
INTNXT	LH	R3,INTLST		:FIND NEXT CHANNEL WITH WORK
	JFFOH	R3,INTH12	
	J	INTRET,,		:ALL DONE

INTH12	CLHI	R4,TINTCH		:IS THIS A VALID CHANNEL?
	JLFS	INTH16			:YES, GO HANDLE IT
	J	INTRET,,		:NO, ALL DONE

INTH16	RBT	R4,INTLST		:MARK THIS ONE AS DONE
	LHL	R2,INTTAB,R4,R4		:GET OUTBOUND BUFFER NUMBER
	XHI	R2,4			:FLIP TO INCOMING BUFFER
	NHI	R2,-4			:STRIP SPEED BITS
	JAL	R8,PCIS,,		:TEST FOR CONTROL CHAR OR ZAPPER
	CLHI	R1,3			
	JE	INTZAK			:FOUND ONE, INVESTIGATE FURTHER
	clhi	r1,1			:handle signals
	je	intsig
	LHL	R1,INTDSP,R4,R4		:ALREADY GOT ROUTINE ADDRESS?
	JN	SEG1.2,R1,		:YES, (NOTE R1=0 ISN'T VALID)	###wjl
	TBT	R4,INTUSE		:NO, ALREADY STRIPPED USER NAME?
	JN	INTDWL			:YES, GET FUNCTION

:	CODE STRIPS WHOLE USERNAME IN CRQ
INTH20	SBT	R4,INTUSE		:MARK COMPLETION OF LOGIN
	SBT	R4,INTOUT		:ENABLE TIMEOUT UNTIL TOLD OTHERWISE
	LHL	R1,BCT,R2,		:ANY MORE DATA?
	JEFS	INTH22			:NO, EXAMINE USER NAME
	JAL	R8,GCI,,		:YES
	CLHI	R1,80			:IS IT A PAD CHARACTER?
	JEFS	INTH22			:YES, STRIP IT
	JAL	R8,WCD,,		:NO, RESTORE IT

INTH22	LR	R1,R4			:FORM FW INDEX INTO
	SLLS	R1,2			:USERNAME GGLIST INDEX (STORED IN CRQ)
	L	R8,INTUSR,R1		:GET GGLIST INDEX
	JL	INTH60			:INVALID USER, SOLO MACHINE W/O KERNEL
	L	R7,XRAYGG+XGGTAR,R8,	:get user's TARGET address	###wjl
	JR	R7			:dispatch			###wjl

:	code here for handling signals.  yellow and orange balls
intsig	lr	r7,r4			:r4 is trashed by g2ci
	jal	r9,g2ci,,		:get the signal
	lr	r4,r7			:restore internal chnd
	clhi	r1,01fd			:black ball
	jefs	intsi1
	clhi	r1,01ff			:yellow ball
	jnfs	intsi3
intsi1	sis	r1,1			:bounce signal (grey is 01fc, ob 01fe
	xhi	r2,4			:back towards user
	jal	r9,w2ci,,
	j	intnxt			:and done
intsi3
	if	t2gate			:gateway is iix host and has to eat
	clhi	r1,01f6			:response to dialect (siix 80808081)
	jn	intnxt
	lhl	r1,intdsp,r4,r4		:save our main dispatch
	sth	r1,intdss,r4,r4
	lhi	r1,intsi5-seg1.2
	sth	r1,intdsp,r4,r4		:save baby dispatch
	j	intnxt			:and let them get serviced

intsi5	lhi	r1,intsi6-seg1.2
	lhi	r6,80			:first byte of iix
	j	intsi9
intsi6	lhi	r1,intsi7-seg1.2
	lhi	r6,81			:second byte of iix
	jfs	intsi9
intsi7	lhi	r1,intsi8-seg1.2
	lhi	r6,80			:third byte of iix
	jfs	intsi9
intsi8	lhl	r1,intdss,r4,r4		:back to original dispatch
	lhi	r6,81			:fourth byte of iix
intsi9	sth	r1,intdsp,r4,r4		:save new state
	jal	r8,gci,,
	cr	r1,r6			:is it what we expect?
	je	intnxt			:yes so continue
	jal	r8,wcd,,		:put it back
	lhl	r1,intdss,r4,r4		:let normal routines find out what
	sth	r1,intdsp,r4,r4		:it is (like a nongobbling zapper)
	ei	:t2gate
	j	intnxt			:and return to top

::*********************************************************************
::
::	TARGET DISPATCH ADDRESS:  INTXRY:
::	FUNCTION:		  XRAY
::
::*********************************************************************

:	PROCESS REMOTE XRAY
INTXRY	JAL	R7,INTSLT		:get XRAY slot for XRAY user	###wjl
	RBT	R4,INTOUT		:NO TIMEOUT FOR REMOTE X-RAY
	JAL	R8,CBCLR,,		:CLEAR TRAILING DATA
	XHI	R2,4			:GET OUTGOING BUFFER NUMBER
	STH	R2,XRYBFO,XD		:OUTBOUND BUFFER NO. THIS USER
	STH	R4,XUINTH,XD		:INTERNAL HOST CHANNEL#
	STH	R1,XUSLTN,XD		:XRAY USER SLOT NO.
	SBT	R4,INTXRF		:NOTE THE PRESENCE OF REMOTE XRAY

	SBT	R4,XWMFLG		:###TZ
	LHI	R0,REMXRY-SEG1.2	:GET ROUTINE ADDRESS		###wjl
	STH	R0,INTDSP,R4,R4
	LIS	R0,0
	STH	R0,EKOTYP,XD		:INIT TO REMOTE ECHO
	LIS	R0,1
	STH	R0,CRYMOD,XD		:INIT AUTO CRYPTO DISPLAY OFF
	STH	R0,XPOWER,XD
	J	REMXRZ			:JUMP TO INITIALIZE ROUTINE

::*********************************************************************
::
::	TARGET DISPATCH ADDRESS:  INTIIX:
::	FUNCTION:		  IIXRAY
::
::*********************************************************************

INTIIX	J	INTH60			:invalid, no IIXRAY configured	###wjl

::*********************************************************************
::
::	TARGET DISPATCH ADDRESS:  INTDWL:
::	FUNCTION:		  DLOAD
::
::*********************************************************************

INTDWL	JAL	R9,INTGET		:GET FUNCTION BYTE
	CLHI	R1,40			:LINE NUMBER (0-63) ?
	JGE	INTPLI			:NO, THIS ISN'T A DWL COMMAND
	SBT	R4,INTDWF		:MAKE ENTRY INTO DWL ARRAY
	RBT	R4,INTOUT		:NO TIMEOUT
	LHI	R0,DWLOUT-SEG1.2	:STORE ROUTINE ADDRESS		###wjl
	STH	R0,INTDSP,R4,R4
	J	DWLOUT			:GO TO DWL ROUTINE

:	CHECK FOR PLI MESSAGE
INTPLI	CLHI	R1,82			:PLI MESSAGE?
	JN	INTDLY			:NO
	XHI	R2,4			:GET OUTBOUND BUFFER NUMBER
	JAL	R8,WCI,,			:ECHO COMMAND BYTE
	XHI	R2,4
	LCS	R0,1
	STH	R0,PLICNT		:INITIALIZE PLICNT
	LHI	R0,PLIMSG-SEG1.2	:ROUTINE ADDRESS		###wjl
	STH	R0,INTDSP,R4,R4
	J	PLIMSG

:	CHECK FOR DELAY MEASUREMENT
INTDLY	CLHI	R1,44			:ROUND-TRIP DELAY MEASUREMENT?
	JN	INTLPB			:NO, PERHAPS LOOPBACK
	RBT	R4,INTOUT		:YES, NO TIMEOUT HERE
	SBT	R4,INTDSF		:SET THE DELAY CHECK CHANNEL FLAG
	LHI	R0,01F-PDLYSR		:GET SCHEDULE PRIORITY FOR DLYSRC
:       always off of 1/8 sec, dly source determines how often for the circuit
	SBT	R0,T125MS		:AND SCHEDULE DLYSRC OFF TIMEOUT LIST
	LHI	R0,DLYSFL-SEG1.2	:INITIAL ENTRY POINT FOR DLYSRC	###wjl
	STH	R0,INTDSP,R4,R4
       if	rebild
	jal	r9,rbcout		:this is not a rebuildable circuit
       ei	rebild
	J	INTNXT

:	CHECK FOR LOOPBACK
INTLPB	CLHI	R1,4C			:LOOPBACK TEST?
	JNFS	INTEND			:NO,BAD COMMAND. ZAP!
	LHI	R0,LOOPBK-SEG1.2	:				###wjl
	STH	R0,INTDSP,R4,R4		:YES, SET UP FOR LOOPBACK
	RBT	R4,INTOUT		:NO TIMEOUT
       if	rebild
	jal	r9,rbcout		:this is not a rebuildable circuit
       ei	rebild
	J	INTNXT

:	BAD INT HOST FUNCTION BYTE
INTEND	LR	R0,R1
	JAL	R8,CRYPTO,,		:MESSAGE = BAD INT HOST FUNCTION BYTE
	HC	CRYE50
	J	INTZPH			:ZAP THE CIRCUIT


:	DEAL WITH 03-XX CHARACTER PAIR
INTZAK	JAL	R8,GCI,,		:DEAL WITH 03-XX CHARACTER PAIR
	JAL	R8,GCI,,
	CLHI	R1,ZAPPH&0FF		:IS IT A HARD-ZAPPER?
	JE	INTZK1			:YES
       IF       LOGII&T2GATE            :logII converted needle
        CLHI    R1,NEEDBD&0FF           :needle body?
        JN      INTZK0                  :nope, woory about something else
        LHL     R0,BCT,R2,              :make sure len has arrived
        CLHI    R0,2                    :2 means 2 bflets, but body is long
        JGFS    INTZL3
INTZL1  LHI     R1,NEEDBD               :go back and wait for body
        JAL     R8,WCD,,
        EXBR    R1,R1                   :restore removed NEEDHD
        JAL     R8,WCD,,
        J       INTNXT                  :look at this port later
INTZL3  JAL     R9,GHWI,,               :get len
        LR      R4,R1
        JAL     R8,CBCCT,,              :len in buffer
        CR      R4,R1
        JGEFS   INTZL4
        LR      R1,R4                   :write back len
        JAL     R9,WCDE,,
        EXBR    R1,R1
        JAL     R9,WCDE,,               :return and will finish when all ther
        J       INTZL1                  :and write back needle head
INTZL4  LR      R0,R4                   :get count in R0
        JAL     R8,RTBFTS,,             :eat needle body
        LHL     R1,BCT,R2,              :anything in buffer
        JN      INTNXT
        LHI     R1,80
        JAL     R8,WCI,,                :parallel what is done in CRQ
        J       INTNXT
       EI       :LOGII&T2GATE
INTZK0
       IF	IDTACH			:ISIS Detach			###wjl
	CLHI	R1,ZAPPN&0FF		:Is it a Non-Gobbling Zapper?
	JE	INTZK1			:Yes
       EI	:IDTACH							###wjl
	TBT	R4,INTXRF		:NO, IS THIS A REMOTE XRAY CHN?
	JE	INAZ24			:Go do final accounting
	CLHI	R1,GOBBL&0FF		:REM XRAY MAY GET A GOBBLER FROM NAD
	JEFS	INTZK2			:SKINNY GOBBLER
	CLHI	R1,GOBBF&0FF		:OR FAT GOBBLER
	JN	INAZ24			:Go do final accounting
INTZK2	LIS	R1,3			:NAD SENDS GOBBLER INSTEAD OF ^C
	LHL	R2,INTTAB,R4,R4		:SO WE MUST INSERT ^C
	NHI	R2,-4
	XHI	R2,4
	JAL	R9,WCIE,,
	J	INTNXT			:AND RETURN TO MAINLINE
INTZK1	HS	0
	IF	INTACC		
	LR	R3,R4			:Get internal port index 
	LI	R0,AALR03		:Logout reason (zap from user)
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###EV
	JAL	R9,ZAPV			:ZAPPER, ACKNOWLEDGE
	JAL	R10,INTZA1		:GO DO THE CLOSING BOOKKEEPING
	J	INTNXT

INAZ24	HS	0			:Final accounting, circuit reject
	IF 	INTACC		
	LR	R3,R4			:Get internal port index
	LHI	R0,AALR24		:and logout reason
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###EV

INTZPH	JAL	R10,INTZAP
	J	INTNXT

DWAZ19	HS	0			:Here for bad dwl function accounting
	IF	INTACC		
	LR	R3,R4			:Get DWL channel index
	LHI	R0,AALR19		:Logout reason 19 bad DWL function
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###ev
	J	INTZPH			:Now Zap the circuit

::*********************************************************************
::
::	ENTRY POINT:	DWLOUT:
::	FUNCTION:	FORMAT DOWN-LINE LOAD RECORD FOR NEIGHBOR
::	FORMATS A RECORD FOR THE MACHINE BEING LOADED
::	R4	=	ACTIVE DWL CHANNEL INDEX
::	R6	=	2 X R4
::
::*********************************************************************

DWLOUT	JAL	R7,DWLVAL		:determine if line # is valid	###wjl

	LHI	R0,SIOIDL-SEG1		:PUT SIO LINE INTO IDLE STATE
	STH	R0,SIOTST,LN		:BY STORING ADDRESS OF THE IDLE ROUTINE
	LIS	R0,0			:clear any possible condition for sync
	L	R1,SIOBLA,LN,LN		:get output rotor
	STH	R0,0,R1
:	dwldum indicates whether this dload can handle smart acks
	sth	r0,dwldum,ln		:store 0 if don't know
	LR	R1,LN
	SRLS 	R1,1			:IDLE LINE
	RBT	R1,VRSTDL		:INSURE WE STAY IDLE
	RBT	R1,LINATT
	RBT	R1,LINDET
	LIS	R0,0			:INITIALIZE RECORD OUT PTR
	STH	R0,DWLOPT,R6
	STH	R0,DWLCIN
	STH	R0,DWLCOU
	STH	R0,DWLCLI
	STH	R0,DWBUSY,R6		:INPUT BUFFER IS FREE
	LHI	R0,DWLOU2-SEG1.2	:STORE NEW ENTRY ADDRESS	###wjl
	STH	R0,INTDSP,R6
	LHL	R0,BCT,R2,		:ANY MORE BYTES IN BUFFER?
	JE	INTNXT			:NO, DISMISS

::*********************************************************************
::
::	ENTRY POINT:	DWLOU2:
::	FUNCTION:	INTHST DISPATCHES TO HERE AFTER A VALID LINE
::			NUMBER HAS BEEN RECEIVED
::
::*********************************************************************

DWLOU2	SBT	R4,INTACT		:MARK AS ACTIVE TO AVOID TIMEOUT
	LR	R6,R4
	AR	R6,R6
	LHL	LN,DWLNUM,R6		:GET LINE NUMBER

:	note r6 is internal chn *2
	L	R1,SIOBLA,LN,LN		:get address of output ROTOR
	Lb	R0,1,R1			:get status of current output
	JN	INTNXT			:if non zero then still sending
	lhl	r7,dwobla,r4,r4		:get offset
	if	silins
	clhi	ln,(nlines-silins)*2
	jlfs	dwlsi3
	ais	r7,2			:put offset to after the len hw
	ei	:silins
dwlsi3	LHL	PRD,DWLOPT,R6		:GET OUTPUT PTR
	JN	DWLOU1
	JAL	R8,CBCCT,,		:WAIT FOR A FEW BYTES
	SIS	R1,4
	JLE	INTNXT
	JAL	R9,INTGET
	CLHI	R1,32			:WAIT FOR HEADER
	JN	INTNXT
	JAL	R8,GCI,,			:DISCARD NEXT 32
	LHI	R1,3232			:SET HEADER
	STH	R1,DWOBUF,R7,
DWLOU1	JAL	R9,INTGET		:GET NEXT BYTE
	STB	R1,DWOBUF+2,PRD,R7
	AIS	PRD,1
	NHI	PRD,3F
	STH	PRD,DWLOPT,R6
	JN	DWLOU1

:	TARGET MACHINE RECORD ASSEMBLED...SET UP SVC CALL TO TRANSMIT
:	BLOCK. R0=line number, R1= address of rotor.  Notice that the
:	force output SVC just in case any output was still being done
:	by the foreground (the line was put in idle state so fg could
:	only do this to the first downline load record).
	lh	r0,dwldum,ln		:is this the first record?
	jn	dwlsi8			:nope, don't change
:	have to determine if smart of dumber loader.  guess dumb
:	the indication of smart loader is the first load record being
:	to adress 0 and of all zeros.  Since zero compression is standard
:	part of any loader, nothing will ever accidently send an indication
:	of being a smart loader.				sdw
	ts	dwldum,ln		:is dumb loader unless ....
	lh	r1,dwobuf+2,r7,
	clhi	r1,3800		:start of a write command to address 0
	jn	dwlsi8
dwlsi7	lh	R1,DWOBUF+4,PRD,R7
	jn	dwlsi8			:not all zero
	AIS	PRD,1
	clhi	PRD,3a			:38 bytes of data +2 of address
	Jlbs	dwlsi7
	sth	prd,dwldum,ln		:it's a smart loader.  Hello Ed.
	xhi	r2,4			:send message back
	lhi	r1,3232
	jal	r9,w2ci,,
	lhi	r1,0d3			:S for smart loader
	jal	r8,wci,,
	xhi	r2,4			:restore r2
	j	intnxt			:don't bother sending it
dwlsi8	LR	R0,LN
	SRLS	R0,1			:TARGET LINE NUMBER
	L	R1,SIOBLA,LN,LN		:get address of rotor
	LA	R2,DWOBUF,R7,		:POINT TO BLOCK TO BE TRANSMITTED
	LIS	R3,1			:write the output command
	STH	R3,0,R1
	LHI	R3,42			:the length in bytes

	if	sylins
	if	silins
	clhi	ln,(nlines-silins)*2
	jge	dwlsi4			:handle our sio line svc
	ei	:silins
	ST	R2,4,R1			:store address of data into rotor
	STH	R3,2,R1			:byte count to transmit
	SVC	IO,20+R0		:output SVC
	J	SVCR32			:handle error
	j	dwlsi6
	ei	:sylins

:	SIO line have different output SVC
:	note r2 is 2+dwobuf+offset so subtract 2 to put len
	if	silins
dwlsi4	sis	r2,2
	sth	r3,0,r2			:put length of sio dwl
	srls	r2,4			:address/16 for sio
	sth	r2,2,r1			:save address of ccw
	TBT	R0,SIOPTA		:IS SIO PORT AVAILABLE?		###OAS
	JNFS	dwlsi6			:NO, SKIP SVC
	SVC	IO,0B0+r0		:Force M-board output
	JAL	R12,SVCR3B		:ERROR, HANDLE IT		###OAS
	EI	:SILINS

:	handle post sending a record stuff
dwlsi6
	IF	INTACC			
	LHI	R0,42			:Load byte count - expected in R0
	LR	R3,R4			:Internal host port index in wrk reg
	JAL	R8,AARDIC		:Accumulate to INput count to DWload
	EI	:INTACC			:###EV
	SRLS	R6,1
	SBT	R6,INTACT		:MARK LINE AS ACTIVE FOR INTOUT
	LIS	R0,1
	AHM	R0,DWLCOU
	J	INTNXT			:AND GO TO NEXT LINE

	if	sylins
SVCR32	JAL	R0,SVCE32,,		:calls crash
	J	INTNXT			:just in case get returned
	ei	:sylins
	if	silins
SVCR3B	J	SVCE3B,,		:HANDLE SVC ERROR IN LINKER
	ei	:silins

::*********************************************************************
::
::	ENTRY POINT:	PLIMSG:
::	FUNCTION:	PLI MESSAGE
::	RECEIVES A SLOT NUMBER, TYPE BYTE, BYTE COUNT, DATA, AND CHECKSUM
::	FROM A HOST MACHINE. PLICNT SERVES AS A STATE COUNTER AS WELL AS BYTE 
::	COUNT
::
::*********************************************************************

PLIMSG	SBT	R4,INTACT		:NOTE WE ARE ACTIVE FOR TIMEOUT
	LH	R3,PLICNT		:GET PRESENT STATUS FROM PLICNT
	JGE	PLIMS0			:=>0 MEANS TAKING DATA
	CLHI	R3,0FFFC		:-4 MEANS TAKING BYTE COUNT
	JE	PLIMS2
	CLHI	R3,0FFFE
	JE	PLIMS1			:-2 MEANS TAKING TYPE BYTE 
	LIS	R0,0			:FALLTHROUGH MEANS TAKING SLOT#
	STH	R0,PLIXOR		:INITIALIZE CHECKSUM AND
	STH	R0,PLINDX		:CURRENT BYTES RECEIVED COUNT
	JAL	R9,INTGET		:GET SLOT NUMBER
	CLHI	R1,3F			:MAX SLOT NUMBER = 63
	JG	PLAZ19			:Accounting and zap
	STH	R1,PLISLT		:OK, STORE
	LCS	R0,2
	STH	R0,PLICNT		:SET PLICNT TO -2
PLIMS1	JAL	R9,INTGET		:GET THE TYPE BYTE
	LR	R1,R1			:VERIFY THAT ITS 0
	JN	PLAZ19			:Accounting and zap
	LCS	R0,4
	STH	R0,PLICNT		:SET PLICNT TO -4 
PLIMS2	JAL	R9,INTGET		:GET THE BYTE COUNT
	STH	R1,PLICNT		:MESSAGE IS OK. STORE COUNT
PLIMS0	JAL	R9,INTGET		:GET A CHARACTER
	LHL	R3,PLINDX
	CLH	R3,PLICNT		:GOT ALL THE DATA?
	JEFS	PLIMS5			:YES, DEAL WITH CHECKSUM
	STB	R1,PLIDAT,R3		:STORE DATA
	AIS	R3,1			:INCREMENT DATA RECEIVED COUNT
	STH	R3,PLINDX
	LHL	R3,PLIXOR		:PERFORM CHECKSUM
	XR	R3,R1
	STH	R3,PLIXOR
	J	PLIMS0			:AND LOOP BACK
PLIMS5	CLH	R1,PLIXOR		:DO CHECKSUMS MATCH?
	JN	PLAZ19			:Accounting and zap
	XHI	R2,4			:YES, SO ECHO CHECKSUM, ESCAPED
	JAL	R9,WCIE,,
	LHL	R0,PLICNT		:MOVE PLICNT TO PLICN2
	JEFS	PLIMS6			:0-LENGTH MESSAGE--reset from IULMSG
	TS	PLIXOR			:SET PLIXOR TO FFFF TO TURN MESSAGE ON
	STB	R0,PLICN2		:PERMIT USE OF 'BUFCAN' ROUTINE

PLIMS6	HS	0
       IF       1-NCSLOT
	AIS	R0,6			:R0 = LENGTH OF DISPATCHER MESSAGE
	JAL	R8,DIROOM,,		:DISMISS UNTIL THE SPACE IS AVAILABLE
	LHL	R15,DRIF,,		:CURRENT FILL POINTER
	LHL	R3,PLISLT		:SLOT NUMBER
	SLLS	R3,2			:WE WANT 4*SLOT#
	AHI	R3,IN1DWN^8		:R3=<00><00><0E><4*SLOT#>
	ST	R3,DIRNG,R15,,		:FIRST FOUR BYTES OF MESSAGE
	AIS	R15,4
	NHI	R15,DRSZ-1
	LHL	R3,PLICNT
	STH	R3,DIRNG,R15,,		:STORE TYPE AND COUNT
	AIS	R15,2			:INCREMENT FILL INDEX
	NHI	R15,DRSZ-1
	LIS	R2,0			:INITIALIZE PLIDAT INDEX
PLIMS8	SIS	R3,1			:ZERO MESSAGE BYTES LEFT?
	JLFS	PLIMS7			:YES,EXIT
	LB	R1,PLIDAT,R2		:GET NEXT MESSAGE BYTE
	STB	R1,DIRNG,R15,,		:STORE IT INTO THE DISPATCHER RING
	AIS	R15,1			:INCREMENT FILL INDEX
	NHI	R15,DRSZ-1		:AND REDUCE MOD DRSZ
	AIS	R2,1			:INCREMENT PLIDAT INDEX
	JBS	PLIMS8			:AND REPEAT
PLIMS7	AIS	R15,3
	NHI	R15,DRSZ-4		:ROUND FILL POINTER UP TO NEXT WORD
	STH	R15,DRIF,,
	IF	INTACC			
	LHL	R0,PLICNT		:Count of charaters input
	LR	R3,R4			:Get port index in wrk register
	JAL	R8,AARDIC		:Accumulate characters
	EI	:INTACC			:###EV
       EI       :1-NCSLOT
	J	INTNXT			:GO SERVICE NEXT INTHST CHANNEL

PLAZ19	HS	0			:Here for bad dwl function accounting
	IF	INTACC		
	LR	R3,R4			:Get DWL channel index
	LI	R0,AALR19		:Logout reason 19 bad DWL function
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###ev
	J	INTZPH			:Now Zap the circuit

::*********************************************************************
::
::	ENTRY POINT:	REMXRY:
::	FUNCTION:	INTERFACE BETWEEN XRAY AND THE NETWORK.
::	SCANS THE DATA STREAM FOR 'Z' (LOGOUT) OR ^C OR & (BREAK, RESTART XRAY)
::	& RESTARTS XRAY BECAUSE ^C HAS A SPECIAL MEANING FOR NAD IN PDP MODE
::	****	NOTE	****
::	R4 IS NOT EXPLICITLY USED BUT CONTAINS THE INTERNAL HOST PORT INDEX
::	AND IS NEEDED SHOULD THE BRANCH TO INTZPH OCCUR.
::
::*********************************************************************

REMXRY	JAL	R8,CBCCT,,		:GET CHARACTER COUNT 
	LR	R5,R1
	LB	XN,XNINT,R4,
	LHL	XD,XDXN,XN,XN		:GET USER BLOCK POINTER
	LHL	R6,XRYPTF,XD
	IF	INTACC			
	LIS	R14,0			:Init character counter
	EI	:INTACC			:###ev	
REMXR1	LR	R5,R5
	JE	REMXR2			:NO MORE DATA
	AIS	R6,1			:MAKE SURE WE HAVEN'T WRAPPED AROUND
	NHI	R6,XBFSZE-1		:MOD BUFFER SIZE
	CLH	R6,XRYPTE,XD,		:TO EMPTY POINTER
	JE	REMX20			:NO ROOM
	SIS	R6,1			:OK SO RESTORE FILL POINTER AND PROCEDE
	NHI	R6,XBFSZE-1		:MOD BUFFERSIZE
	JAL	R9,GCXRAY		:GET NEXT CHARACTER
	STB	R1,XRYBFI,R6,XD		:AND MOVE TO XRAY BUFFER
	NHI	R1,7F			:STRIP MSB
	CLHI	R1,1A			:UNCONDITIONALLY END SESSION IF ^Z
	JE	AARXLG			:Perform logout accounting
REMXJ1	CLHI	R1,03			:CHECK FOR ^C
	JEFS	REMXZ1			:YES
	CLHI	R1,26			:OR &
	JN	REMXR9			:NO

REMXZ1	HS	0
	IF	INTACC			
	LR	R0,R14			:Expect counts in R0
	LR	R3,R4			:Get port index in work reg
	JAL	R8,AARDIC		:Accumulate characters so far
	EI	:INTACC			:###EV
	XHI	R2,4
	JAL	R9,GOBBLN		:SEND GOBBLER TOWARDS USER

:	ENTRY POINT TO RESTART XRAY
REMXRZ	LHL	R0,XRYPTF,XD		:FLUSH INPUT RING
	STH	R0,XRYPTE,XD
	LHI	R1,01F-PXRAY
	SBT	R1,SQUEUE		:SCHEDULE XRAY OFF EXEC QUEUE
	LHL	XN,XUSLTN,XD		:THIS USER'S XRAY SLOT NO.
	SBT	XN,XQUEM,,		:SET XRAY USER QUEUE
	LHL	XD,XDXN,XN,XN		:RESTORE XRAY USER BLOCK POINTER
	LI	R1,XRAYIS		:INITIAL ADDRESS FOR XRAY USER
	ST	R1,XRYADR,XD,
	J	INTNXT

AARXLG	HS	0			:Perform logout accounting
	IF	INTACC			
	LR	R3,R4			:Get internal port index in wrk reg
	LIS	R0,AALR02		:zap by host
	JAL	R8,AARLO		:Call accounting
	EI	:INTACC			:###EV
	J	INTZPH			:Zap & do closing cleanup

REMXR9	AIS	R6,1			:INCREMENT FILL INDEX
	NHI	R6,XBFSZE-1		:MOD BUFFER SIZE
	SIS	R5,1			:DECREMENT BYTE COUNT INDEX
	IF	INTACC			
	AIS	R14,1			:And add to character count
	EI	:INTACC			:###EV
	J	REMXR1			:AND LOOP BACK

REMX20	SIS	R6,1			:RAN OUT OF ROOM IN INPUT RING,SO
	NHI	R6,XBFSZE-1		:RESTORE FILL POINTER
REMXR2	STH	R6,XRYPTF,XD		:STORE AWAY FILL POINTER
	IF	INTACC			
	LR	R0,R14			:Expects count in R0
	LR	R3,R4			:Get port index in work reg
	JAL	R8,AARDIC		:Accumulate character count
	EI	:INTACC			:###EV
	LHI	R0,01F-PXRAY		:SCHEDULE XRAY OFF EXEC LOOP
	SBT	R0,SQUEUE
	LHL	XN,XUSLTN,XD		:THIS USER'S XRAY SLOT NO.
	SBT	XN,XQUEM,,		:SCHEDULE IN XRAY USER'S QUEUE
	LHL	XD,XDXN,XN,XN		:RESTORE POINTER TO XRAY USER BLOCK
	J	INTNXT			:AND RETURN TO MAINLINE

::*********************************************************************
::
::	ENTRY POINT:	DLYREC:
::	FUNCTION:	RECEIVING END FOR DELAY MEASUREMENT.
::		RECEIVES DATA AS HW OF FASTC, COMPUTES DELAY, STORES INTO
::		DLYTBL, AND DOES MINOR SIGNAL PROCESSING TRAVEL TIME IS STORED
::		IN UNITS OF 8/600 SEC, OR 13.333 MS
::		R2 = BUFFER NUMBER
::		R4 = INTERNAL HOST CHANNEL INDEX
::
::*********************************************************************

DLYREC	LHL	R7,FASTC+2,,		:GET CURRENT TIME
	LR	R6,R4			:SAVE INDEX BEFORE GHWI CLOBBERS IT
DLYRE1	LR	R5,R7			:COPY FASTC OVER
	JAL	R8,CBCCT,,		:GET CHARACTER COUNT IN BUFFER
	SIS	R1,2			:WANT HW OF FASTC (NEVER ESCAPED)
	JL	INTNXT			:NO, NOT ENOUGH DATA. GO AWAY
	jgfs	dlyre2			:3 or more means 2 chars present
	jal	r8,pcis,,		:if two bytes then peek at first
	lr	r1,r1			:if not escaped then two chars exist
	je	intnxt			:is escaped, only 1 char in buff
DLYRE2	JAL	R9,GHWI,,		:GET THE HW 
	CHI	R1,FILLCH		:IS IT A FILL CHARACTER?
	JE	DLYRE1			:YES,GET ANOTHER
	SR	R5,R1			:GOT FASTC, SUBTRACT OUT TRAVEL TIME 
	JGFS	DLYRE3			:NO WRAP-AROUND
	AI	R5,10000		:CORRECT FOR WRAP-AROUND
DLYRE3	LHL	R1,CHNDLY,R6,R6		:CHAN NUMBER TO USER ADDRESS LINK TBL
        AI      R1,DLYBSE               :address this kid's data block  ###sdw
	LHL	R3,DLYPTF,R1		:FILL POINTER FOR THIS TEST
	STH	R5,DLYTBL,R1,R3		:AND STORE INTO DATA TABLE
	AIS	R3,2			:INCREMENT DLYTBL FILL PTR
	NHI	R3,DLYTSZ-1		:AND REDUCE
	STH	R3,DLYPTF,R1
	LHL	R3,DLYAV1,R1		:GET RUNNING AVERAGE
	JEFS	DLYREZ			:0 SO DON'T FILTER
	SRLS	R5,4			:1/16 OF SAMPLE
	SRLS	R3,4			:1/16 OF RUNNING AVERAGE
	SR	R5,R3			:(NEW-OLD)/16
DLYREZ	AHM	R5,DLYAV1,R1		:UPDATE RUNNING AVERAGE (OLD)
	LHL	R5,DLYAV1,R1		:GET R/A#1
	LHL	R3,DLYAV2,R1		:GET R/A#2
	JEFS	DLYREY			:IF 0 DON'T FILTER
	SRLS	R5,3			:1/8 OF R/A#1
	SRLS	R3,3			:1/8 OF R/A#2
	SR	R5,R3			:1/8*(R/A#1 - R/A#2)
DLYREY	AHM	R5,DLYAV2,R1		:UPDATE R/A#2
	J	DLYRE1			:AND RETURN

::*********************************************************************
::
::	ENTRY POINT:	DLYSFL:
::	FUNCTION:
::		THE FIRST two DATA BYTEs RECEIVED ON THE DATA SOURCE
::		CHANNEL IS CONSIDERED TO BE THE HW FILL COUNT FOR THAT
::		CHANNEL. ALL SUBSEQUENT DATA RECEIVED IS CONSIDERED TO
::		BE AN ERROR.
::
::*********************************************************************

DLYSFL	jal	r8,cbcct,,
	sis	r1,3
	jl	intnxt			:not all there yet so wait
	JAL	R9,INTGET		:GET THE HW FILL COUNT
	STB	R1,CHNFIL+1,R4,R4	:first is low order byte	###JHL
	JAL	R9,INTGET		:				###JHL
	STB	R1,CHNFIL,R4,R4		:next is the high order byte	###JHL
        jal     r9,intget               :get rate
        sth     r1,dlyint,r4,r4         :new logic sends rate to destination
	LHI	R0,DLYERR-SEG1.2	:ACCEPT NO MORE DATA HERE	###wjl
	STH	R0,INTDSP,R4,R4
	J	INTNXT

::*********************************************************************
::
::	ENTRY POINT:	DLYERR:
::	FUNCTION:	BIT BUCKET FOR UNWANTED DATA
::
::*********************************************************************

DLYERR	J	INTNXT			:BIT BUCKET FOR UNWANTED DATA

::*********************************************************************
::
::	ENTRY POINT:	LOOPBK:
::	FUNCTION:	CHASES ITS TAIL...
::
::*********************************************************************

LOOPBK	LHL	R10,INTLPF		:GET LOOPBACK BIT ARRAY
	JFFOH	R10,LOOPB1		:FIND INT HOST CHANNEL THAT IS SENDING
	J	LOOPNX			:NOT THERE, PROBABLY ZAPPED
LOOPB1	JAL	R8,CBCCT,,		:GET BYTE COUNT IN OUR INPUT BUFFER
	LR	R10,R1			:AND SAVE IT
	LHL	R11,INTTAB,R11,R11	:GET INPUT BUFFER FOR OTHER SIDE
	NHI	R11,-4			:STRIP SPEED BITS
	LR	R12,R2			:SAVE BUFFER #
LOOPB2	LR	R2,R12
	JAL	R8,GCI,,		:READ ONE CHARACTER FROM OUR IN-BUFFER
	LR	R2,R11
	JAL	R8,WCI,,		:AND WRITE INTO OTHER CHANL'S BUF##AL
	SIS	R10,1			:MORE DATA?
	JGBS	LOOPB2			:YES, GET IT
	J	INTNXT

LOOPNX	JAL	R8,CBCLR,,		:CLEAR ALL DATA THAT HAS NOWHERE TO GO
	J	INTNXT

	SUBTTL	INTHST (Utilities)

::*********************************************************************
::
::	SUBROUTINE:	INTSLT:
::	FUNCTION:	GET AN XRAY SLOT FOR AN XRAY/IIXRAY USER
::	CALLING SEQ:	JAL	R7,INTSLT
::
::*********************************************************************

INTSLT	ST	R7,INTSAV+0A		:save return			###wjl
	LIS	R1,1			:ANY XRAY SLOTS? (SLOT 0 FOR TTY)
INTS10	SBT	R1,XUSIUA
	JN	INTS12			:NOT THIS ONE, GO TRY AGAIN
	STB	R1,XNINT,R4,		:XN INTO ARRAY BY INTERNAL HOST PORT
	LHL	XD,XDXN,R1,R1		:GET POINTER TO USER BLOCK
	STH	R8,XUNAME,XD		:USER GG INDEX INTO XRAYUSER BLOCK
	L	R7,INTSAV+0A		:get return address		###wjl
	JR	R7			:GO PROCESS REMOTE XRAY/IIXRAY	###wjl

INTS12	AIS	R1,1
	CLHI	R1,NXUBLK-1
	JLE	INTS10

:	NO SLOTS EMPTY, CHECK FOR OVERRIDE
	LIS	R1,1			:NO SLOTS EMPTY, CHECK FOR OVERRIDE
INTS20	LHL	XD,XDXN,R1,R1		:GET SLOT USERS XRAY USERBLOCK
	LH	R9,XUNAME,XD		:GET SLOT USERS GOODGUY INDEX
	LB	R9,XRAYGG+XGGOVR,R9,	:GET SLOT USERS OVERRIDE LEVEL
	CLB	R9,XRAYGG+XGGOVR,R8,	:COMPARE WITH REQ USERS OVERRIDE LEVEL
	JL	INTS30			:REQUESTOR OVERRIDES CURRENT SLOT
	AIS	R1,1			:TRY NEXT SLOT
	CLHI	R1,NXUBLK-1		:UNTIL WE RUN OUT
	JLE	INTS20
	J	INTS40			:NO SLOTS, REJECT REQUESTOR

:	REQUESTOR OVERRIDES CURRENT SLOT, ZAP VICTIM
INTS30	STH	R2,INTSAV		:SAVE OUR BUFFER #
	STH	R1,INTSAV+2		:AND OUR SLOT# * 4
	STH	R4,INTSAV+4		:AND OUR INTHOST INDEX
	STH	R8,INTSAV+8		:SAVE GGLIST INDEX
	LHL	XD,XDXN,R1,R1		:GET OUR VICTIM'S POINTER
	IF	INTACC		
	LHL	R3,XUINTH,XD		:Get internal port index (poor guy)
	LHI	R0,AALR26		:and logout reason (tuff luck buddy)
	JAL	R8,AARLO		:Tell Sup this guy is finished
	EI	:INTACC			:###EV
	LHL	R2,XRYBFO,XD		:GET HIS OUT BUFFER #
	LHL	R2,XRYBFO,XD		:GET HIS OUT BUFFER #
        la      r4,detm06,,             :address of overwritten slot
        jal     r9,bufcan,,
        lhi     r1,0303                 :nongobbling zapper
        jal     r9,zapxn,,
        lhl     r4,xuinth,xd,           :the victim
        jal     r10,intza1
INTS34	LHL	R1,INTSAV+2		:RECOVER OUR SLOT# * 4
	LHL	R2,INTSAV		:AND OUR OUT BUFFER#
	LHL	R4,INTSAV+4		:AND OUR INTHOST INDEX
	LHL	R8,INTSAV+8		:RECOVER GGLIST INDEX
	RBT	R1,XUSIUA		:FREE UP THE SLOT
	J	INTS10			:TAKE OVER THE SLOT

:	NO SLOTS AVAILABLE, REJECT REQUESTOR
INTS40	STH	R4,INTSAV+4		:SAVE OUR INTHOST INDEX
        la      r4,detm05,,             :address of out of slots
ints43	lhl     r3,intsav+4
        lhl     r2,inttab,r3,r3
	nhi	r2,-4
	jal     r9,bufcan,,
        lhi     r1,0303                 :nongobbling zapper
        jal     r9,zapxn,,
	LHL	R4,INTSAV+4		:ELSE RECOVER OUR INTHOST INDEX
        jal     r10,intza1
	IF	INTACC		
	LR	R3,R4
	LHI	R0,AALR19		:Get logout reason
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###ev
	J	INTNXT			:BACK TO THE TOP

:       Bad username (target assembled but not available)
INTH60  sth     r4,intsav+4
        la      r4,detm07,,
        j       ints43

::*********************************************************************
::
::	SUBROUTINE:	INTGET:
::	FUNCTION:	GET A BYTE
::	CALLING SEQ:	JAL	R9,INTGET
::
::*********************************************************************

INTGET	LHL	R1,BCT,R2,
	JE	INTNXT			:THIS BUFFER IS EMPTY
	JAL	R8,GCI,,
	LR	R1,R1
	JNR	R9			:UNESCAPED, RETURN
	JAL	R8,GCI,,		:ESCAPED, GET NEXT CHARACTER
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	INTZAP:
::	FUNCTION:	INTZAP ZAPS THE FIRST HALF OF A CRQ AND DOES
::		THE CLEAN-UP OF THE INTERNAL HOST STATUS FLAGS AND ARRAYS
::	LINK:		R10, R11 (R10 PRESERVED IN R11 FOR RETURN LINK)
::	INPUT:		R2 = BUFFER NO.
::			R4 = INTERNAL HOST CHANNEL INDEX
::	DESTROYED:	R0, R1, R3, R8, R9
::
::*********************************************************************

INTZAP	XHI	R2,4			:WE EXPECT THE INBOUND BUFFER NO.
	JAL	R9,ZAPHRD		:SO FLIP  AND ZAP
INTZA1	LIS	R0,0			:ALTERNATE ENTRY POINT FOR INTZAK
	STH	R0,INTDSP,R4,R4		:CLEAR DISPATCH ADDRESS
	RBT	R4,INTUSE		:CLEAR LOGIN OVER BIT
	RBT	R4,INTWRN		:CLEAR TIMEOUT WARNING BIT
	RBT	R4,INTOUT		:CLEAR TIMEOUT ENABLE BIT
					:CLEAR FLAGS FOR SPECIFIC FUNCTIONS
	RBT	R4,INTDSF		:CLEAR DELAY MEASUREMENT SOURCE CHN BIT
	RBT	R4,INTLPF		:CLEAR LOOPBACK CHANNEL BIT
	JNFS	INTZ11			:LOOPBACK FUNCTION, SPECIAL CLEANUP
	RBT	R4,INTXRF		:TEST AND CLEAR REMOTE XRAY BIT
	JEFS	INTZA8
	JAL	R12,REMZAP		:DO CLOSING BOOK KEEPING FOR REM XRAY
	JR	R10

INTZA8	RBT	R4,INTDRF		:CLEAR AND TEST DELAY RECEIVER CHN BIT
	JE	INTZA6
INTZ11	LHL	R1,CHNDLY,R4,R4		:CHN INDEX TO DELAY USER OFFSET TABLE
        AI      R1,DLYBSE               :address this gal's data block  ###sdw
	LCS	R0,1
	STH	R0,DLSTAT,R1		:NOTE THE CHAN ZAPPED IN STATUS FIELD
					:###JHL
	LHL	R3,INTNDX,R4,R4		:READ INDEX FROM ARRAY BY INTHST CHAN#
	AR	R3,R3			:GET HW INDEX FROM BYTE INDEX
	LCS	R0,1			:STORE -1 TO SHOW USED--IDLE INFO ONLY
	ST	R0,DB0USE,R3,R3		:ERASE XRY USRBLK ENTRY FOR INDEX
	STH	R0,INTNDX,R4,R4		:ERASE INDEX ARRAY ENTRY FOR CHAN

INTZA6	RBT	R4,INTDWF		:TEST AND CLEAR DWL BIT
	JER	R10			:DONE
	LR	R11,R10			:Save return register
	LH	LN,DWLNUM,R4,R4		:Get line index (2*line #)
	JL	INTZ15

	J	INTZA5			:For non-Starhub machines
INTZ15	XHI	LN,-1			:INVALID LINE NUMBER, COMLEMENT
	LR	R0,LN			:MOVE LINE # AND REASON TO R0
	LBR	LN,R0			:ISOLATE LINE NUMBER (LOWER BYTE OF LN)
	SRLS	R0,8			:MOVE REASON FOR REJECT TO LOWER BYTE
	J	INTZA4			:MAKE CRYPTO REPORT

INTZA5	RBT	LN,DWLDSP		:RESET DWL DISPATCH ARRAY BIT
	STH	R4,INTCHN		:save R4 from being clobbered	###wjl
	JAL	R9,RSTSTR,,		:PUT LINE BACK IN RESET MODE
	LHL	R4,INTCHN		:recover INTHST channel number	###wjl
	LIS	R0,0			:REASON FOR ZAP = ZAPPER RECEIVED
	SRLS	LN,1			:GET TRUE LINE NUMBER FOR XRAY	###OAS
INTZA4	STH	LN,CRYSBF		:AND STORE AWAY INTO HW3
	JAL	R8,CRYPTO,,
	HC	CRYE2D			:DWL LINE ZAP MESSAGE
	LCS	R0,1
	STH	R0,DWLNUM,R4,R4		:REINITIALIZE DWLNUM TO -1

	JR	R11

::*********************************************************************
::
::	SUBROUTINE:	REMZAP:
::	FUNCTION:	DO CLOSING BOOK KEEPING FOR REMOTE XRAY
::	CALLING SEQ:	JAL	R12,REMZAP
::
::*********************************************************************

REMZAP	LIS	R1,0
	JAL	R11,XWRITE,,		:GET SEG1 WRITE ACCESS
	LB	XN,XNINT,R4,		:SET UP XD
	STB	R1,XNINT,R4,
	LHL	XD,XDXN,XN,XN
:	alt entry for ISIS DDT quitters
REMZAI	JAL	R9,REMTR0,,		:GO RESET ANY TRAPS

:	be careful to not confuse a db in progress with a running delay
:	circuit.  first check and remove db in progress.
	jal	r9,remdb0,,
REMZA3	LHI	R11,TINTCH-2		:SET HW OFFSET TO LOOP DB INDICES
:	DB0USE STARTS A WORD-ARRAY, DLYCHN IS A HW ARRAY, EACH BY DB-INDEX
REMZA4	C	XD,DB0USE,R11,R11	:CLEAR DELAY CIRCUIT IF NECESSARY
	JN	REMZA5			:NOT THIS GUY
	LHL	R6,DLYCHN,R11		:INT HOST CHN # FOR DB-R11
	RBT	R6,INTDRF		:MAKE SURE IT'S BEING USED
	JN	REMZA6			:YES				###JHL
	RBT	R6,INTLPF		:IF NOT, IS IT LOOPBACK CH?
	JE	REMZA5			:JUMP IF CHANNEL NOT IN USE
REMZA6	LIS	R0,0			:CH IN USE--ZAP IT		###JHL
	STH	R0,INTDSP,R6,R6		:CLEAR DISPATCH ADDRESS
	RBT	R6,INTUSE		:CLEAR LOGIN OVER BIT
	RBT	R6,INTWRN		:T/O WARNING
	RBT	R6,INTOUT		:T/O
	RBT	R6,INTLST		:remove from service list       ###sdw
	AHI	R6,INTZFL		:GET ABS CHN NO.
	LHL	R2,IOTAB,R6,R6		:OUT BUFFER
	JE	REMZA5			:ALREADY ZAPPED
	NHI	R2,-4			:STRIP SPEED BITS
	JAL	R9,ZAPHRD		:ZAP DB0 CIRCUIT
	LHL	R6,DLYCHN,R11		:INT HOST CHN # FOR DB-R11
	LCS	R0,1
	ST	R0,DB0USE,R11,R11	:CLEAR XRY USRBLK PTR BY DB-INDEX
	STH	R0,INTNDX,R6,R6		:CLEAR DB-INDEX BY INTHST CHAN #
	LHL	R6,CHNDLY,R6,R6		:DATA AREA POINTER
        AI      R6,DLYBSE               :address this guy's data block  ###sdw
	LCS	R0,2			:INDICATE ZAPPED BY USER
	STH	R0,DLSTAT,R6		:LOGOFF
REMZA5	SIS	R11,2			:STEP BACK TO NEXT DB-INDEX
	JGE	REMZA4			:LOOP THROUGH ALL DB-INDICES
	
REMZA2	JAL	R11,XCLEAN,,		:DO CLOSING CLEANUP
	STH	R0,XPOWER,XD
	LHL	XN,XUSLTN,XD		:GET USER SLOT #
	RBT	XN,XUSIUA		:RESET SLOT IN USE BIT
	RBT	XN,XQUEM,,		:CLEAR HIM FROM
	RBT	XN,XQUEC,,		:XRAY QUEUES
	JAL	R11,XPRTKT,,		:RESTORE SEG1 WRITE PROTECT
	JR	R12

::*********************************************************************
::
::	SUBROUTINE:	GCXRAY:
::	FUNCTION:	GET NEXT CHARACTER FROM REMOTE XRAY CIRCUIT.
::		STRIP ESCAPES, AND TOSS NETWORK CONTROL CHARACTERS.
::		BRANCH TO REMXR2 IF BUFFER EMPTY.
::	CALLING SEQ:	JAL	R9,GCXRAY
::	OUTPUT:		R1 = CHARACTER
::			R5 = DECREMENTED AS NEEDED
::
::*********************************************************************

GCXRAY	LHL	R8,BCT,R2,		:EXTRA CARE, NO GCI CRASH
	JE	REMXR2			:BUFFER EMPTY...
	JAL	R8,GCI,,		:GET NEXT CHARACTER FROM BUFFER
	CLHI	R1,8			:NORMAL CHARACTER?
	JGER	R9			:YES - RETURN
	LR	R1,R1			:ESCAPED CHARACTER?
	JEFS	GCXR00			:YES - GET NEXT
	SIS	R1,1			:NETWORK CHARACTER PAIR?
	JEFS	GCXR10			:YES - ADJUST COUNT IN R5 AND TOSS
	SIS	R5,1			:NO - SOME BALL. IGNORE IT TOO...
	JN	GCXRAY			:MORE TO DO
	J	REMXR2			:NO MORE - UPDATE POINTER
GCXR00	SIS	R5,1			:DEC COUNT SINCE '00' CHAR. TOSSED
	JE	REMXR2			:SHOULDN'T HAPPEN, DON'T TAKE GCI CRASH
	JAL	R8,GCI,,		:GET ESCAPED CHARACTER AND
	JR	R9			:RETURN
GCXR10	LH	R8,BCT,R2,
	JE	REMXR2			:NEXT CHAR. NOT PRESENT...
	JAL	R8,GCI,,		:TOSS IT
	SIS	R5,2			:ADJUST COUNT FOR CHARACTER PAIR
	JG	GCXRAY			:MORE TO DO
	J	REMXR2			:DONE

::*********************************************************************
::
::	SUBROUTINE:	DWLVAL
::	FUNCTION:	DETERMINE IF DLOAD LINE NUMBER IS VALID,
::		UNATTACHED, AND NOT IN DLOAD MODE.  BRANCH TO INTZPH IF NOT.
::	CALLING SEQ:	JAL	R7,DWLVAL
::
::*********************************************************************

DWLVAL	ST	R7,INTSAV+0A		:save return			###wjl
	LR	R6,R4
	AR	R6,R4
	CLHI	R1,NLINES		:IS IT A VALID PORT NUMBER?
	JLFS	dwlva1			:YES IT IS
	XHI	R1,0FEFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6
	J	DWAZ19			:Accounting and zap

dwlva1	LR	LN,R1			:NEED 2*LINE #
	AR	LN,LN
	L	R0,KDLN,LN,LN		:LINE BETTER BE UNATTACHED
	JLFS	dwlva2			:IT IS
	XHI	R1,0FDFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6
	J	DWAZ19			:Accounting and zap

::	Downline load proceeds here for load over downed line
dwlva2	tbt	r1,xltact		:line test active on this line?
	jnfs	dwlva4			:yes, don't allow load
	SBT	LN,DWLDSP		:TEST AND SET THE DWL DISPATCH ARRAY
	JEFS	dwlva3			:IT IS AVAILABLE
dwlva4	XHI	R1,0FCFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6		:AND STORE BACK
	J	DWAZ19			:Accounting and zap

dwlva3
	if	chboot
	rbt	r1,cnbtya		:line being dloaded may not still be
	ei	:chboot			:in boot			###sdw
	XHI	R2,4
	JAL	R9,WCIE,,		:ECHO LINE NUMBER BACK TO HOST
	XHI	R2,4
	LCS	R0,2			:MARK IT IN DOWNLINE MODE
	ST	R0,KDLN,LN,LN
	STH	LN,DWLNUM,R6
	LHI	R0,INTZFL,R4		:TELL XRAY ABOUT NEW DWL CHANNEL
	STH	R1,CRYSBF		:STORE LINE NUMBER FOR CRYPTO
	JAL	R8,CRYPTO,,		:LINE # IN TOP, CHANNEL # IN BOTTOM
	HC	CRYE2C
	L	R7,INTSAV+0A		:get return			###wjl
	JR	R7			:return				###wjl

	SUBTTL	INTHST (DWLIN - Handle Down-Line Load record from neighbor)

::*********************************************************************
::
::	PROCESS:	DWLIN:
::	FUNCTION:	DOWNLINE LOAD RECEIVER
::	SCHEDULED:	Upon demand by SYLVER (SIO and SYNC input processing),
::		to process downline load records echoed to the node from it's
::		loading neighbor on unattached lines.  DWLIN processes one
::		downline load record for each line requiring it, and yields
::		between each one, until no more downline load records are 
::		received by SYLVER, when DWLIN dismisses to the EXEC loop.
::
::*********************************************************************

:	DOWNLINE RECORD TEAR DOWN. RECEIVES A 33-HW RECORD FROM
:	NEIGHBOR BEING LOADED AND SENDS IT ON TO THE HOST PROGRAM.
:	UPON COMPLETION, DWLIN DISMISSES ITSELF FROM THE EXEC JOB QUEUE BY
:	CLEARING ITS BIT IN SQUEUE.  HOWEVER IT DOES SO ONLY PROVIDED THAT
:	LINKER HASN'T CREATED MORE WORK IN THE MEANTIME.

DWLIN	LHL	R3,DWQUEU		:GET DWL JOB QUEUE
	JN	DWLIN3			:NO, CONTINUE
	LHI	R0,01F-PDWLIN
	RBT	R0,SQUEUE		 RESET SQUEUE.
	LHL	R5,DWQUEU		:EXAMINE DWL JOB QUEUE
	JeFS	DWLIN1			:LINKER HAS RUN. SET SQUEQE
	sbt	r0,squeue		:work was slipped in so leave scheded
DWLIN1	LA	R0,DWLIN
	J	EXYLD,,			:AND RETURN TO EXEC

DWLIN3	jffoh	r3,dwlin4
:	 R4 = INTERNAL HOST CHANNEL INDEX
	j	dwlin			:back to top to fallinto exit
DWLIN4	RBT	R4,DWQUEU
	LHL	R2,INTTAB,R4,R4		:BUFFER #
	JE	DWLIN
	NHI	R2,-4
	LHI	R1,3232			:SEND THE SYNCS
	JAL	R9,W2CI,,
	LIS	R6,1
	AHM	R6,DWLCIN,,
	LR	R6,R4
	LIS	PRD,0			:TEAR DOWN RECORD
	SLLS	R6,6			:OBTAIN APPROPRIATE OFFSET (64 X R4)
	LHL	LN,DWLNUM,r4,r4		:GET LINE NUMBER
	lh	r0,dwldum,ln		:is this a smart load?
	jl	dwlin8			:jump the the dump old logic
	lis	prd,0
:	First comes 4 bytes of a byte of write cmd (38) and 3 of address
dwlin5	lb	r1,dwibuf,r6,prd
	jal	r9,wcie,,
	ais	prd,1
	clhi	prd,4
	jlbs	dwlin5
	lhi	prd,3c			:chcksum is last 4 bytes
				:fall into dumb logic for last 4 bytes
:	the dumb old logic
DWLIN8	LB	R1,DWIBUF,PRD,R6	:...AND INDEX INTO DWIBUF
	jal	r9,wcie,,
	AIS	PRD,1
	CLHI	PRD,40
	JLbs	DWLIN8
dwlin7
	IF	INTACC			
	lhi	r0,40			:size for standard dload logic
	lh	r3,dwldum,ln		:is this a smart load?
	jlfs	dwlin9			:jump the the dump old logic
	lhi	r0,8			:size for the smart logic
dwlin9	LR	R3,R4			:Get internal port index in work reg
	JAL	R8,AARDOC		:Accumulate byte count for accounting
	EI	:INTACC			:###EV
	LIS	R0,0			:CLEAR BUSY FLAG
	STH	R0,DWBUSY,R4,R4
	J	DWLIN			:CONTINUE...

	SUBTTL	INTHST (DLYSRC - Delay measurement source)

::*********************************************************************
::
::	PROCESS:	DLYSRC:
::	FUNCTION:	SOURCE OF THE TEST DATA USED IN ROUND-TRIP
::		DELAY MEASUREMENTS.  FILLS ALL REQUESTING CHANNELS WITH
::		THE SPECIFIED NUMBER OF FILL HALF-WORDS.
::	SCHEDULED:	IN INTDLY WHENEVER A DELAY MEASUREMENT IS DETECTED,
::		AND SUBSEQUENTLY RUNS PERIODICALLY OFF THE TIME-OUT LIST.
::
::*********************************************************************

FILLCH	EQ	04141			:this is our fill character

DLYSRC	lis	r0,1
	ahm	r0,dlyrat		:so delay circuits can have diff rates
	LHL	R4,INTDSF		:MAKE SURE THERE IS AT LEAST 1 CHANNEL
	JNFS	DLYSR9			:YES
	LHI	R0,01F-PDLYSR		:NO, SO UN-SCHEDULE DLYSRC
	LHI	R1,3C
DLYSR8	RBT	R0,SCHTAB,R1		:BY CLEARING ALL THE TIMEOUT-LIST BITS
	SIS	R1,4
	JL	EXDISM,,		:CLEARED ALL BITS
	JBS	DLYSR8			:SOME LEFT, LOOP BACK

DLYSR9	LHL	R1,FASTC+2,,		:GET CURRENT TIME
	THI	R1,0FC00
	JE	EXDISM,,		:FASTC REQUIRES ESCAPES...TRY LATER
	THI	R1,0FC
	JE	EXDISM,,		:IT WILL REQUIRE ESCAPES HERE, TOO...

	LR	R10,R1			:SAVE FASTC
DLYSR5	JFFOH	R4,DLYSR3		:GET NEXT CHANNEL
	J	EXDISM,,		:NONE LEFT,RETURN
DLYSR3	XH	R4,HMSK,R5,R5		:MARK AS DONE
        lh      r0,dlyrat
        nh      r0,dlyint,r5,r5         :really time for this port?
        jn      dlysr5                  :nope, next port
	LHL	R2,INTTAB,R5,R5		:GET OUTGOING BUFFER NUMBER
:	subject delay msmt circuits to backpressure from source		###jhl
	LR	R7,R2			:copy buffer index to R7
	NHI	R7,3			:read speed bits
	NHI	R2,-4			:strip speed bits
	LHL	R0,CIRSPB,R7,R7		:if BCT > TP class limit, do nothing
	CLH	R0,BCT,R2,		:compare the BCT for the channel
	JL	DLYSR5			:go to service next channel
:	OK to put more chars in buffer	
	LHL	R6,CFLCNT,R5,R5		:read channel count array
	JN	DLYS10			:if non-zero, take it from there
:	time to start a new barrage of CHNFIL worth of chars
	LHL	R6,CHNFIL,R5,R5		:reset CFLCNT to top value
	STH	R6,CFLCNT,R5,R5
	JAL	R9,WHWI,,		:send FASTC from R1 as a starter
DLYS10	SR	R6,R0			:HW 'to send' count - TP class limit
	JL	DLYS20			:branch if < TP left
:	here if > TP limit left to put in buffer for this message
	STH	R6,CFLCNT,R5,R5		:reset 'to send' count
	LR	R6,R0			:move TP no. of chars into the buffer
	J	DLYS30
:	here if < TP limit left -- end of this message
DLYS20	LHL	R6,CFLCNT,R5,R5		:get 'to send' count 
	LIS	R0,0			:zero out CFLCNT
	STH	R0,CFLCNT,R5,R5
DLYS30	LI	R1,FILLCH		:load fill character
DLYSR6	JAL	R9,WHWI,,		:WRITE IN NEXT FILL HW
	SIS	R6,1
	JGBS	DLYSR6			:LOOP BACK

	LHL	R6,CFLCNT,R5,R5		:this is 'end of msg' test	###jhl
	JN	DLYSR5			:send FASTC only at end of msg	###jhl

	LR	R1,R10			:RECOVER FASTC
	JAL	R9,WHWI,,		:AND PUT INTO END OF PACKET
	J	DLYSR5			:REPEAT

	SUBTTL	INTHST (INTTIM - Internal Host Time-Out logic)

::*********************************************************************
::
::	SUBROUTINE:	INTTIM:
::	FUNCTION:	Internal Host Time-Out logic
::	CALLING SEQ:	JAL	R11,INTTIM	CALLED BY THE 4-MINUTE PROCESS.
::		INTTIM ACTUALLY RUNS EVERY 8 MINUTES THROUGH THE USE OF THE
::		INT8MN CELL
::
::*********************************************************************

:	TIMEOUT IS ENABLED FOR AN INTERNAL HOST CRQ WHEN THE CORRESPONDING
:	BIT IN INTOUT IS SET. SUCH A CRQ KEEPS FROM BEING ZAPPED BY KEEPING
:	ITS BIT IN INTACT SET.
:
:	INTTIM EXAMINES THE INTACT ARRAY AND SETS A BIT IN THE INTWRN
:	ARRAY FOR EACH CRQ THAT HAS NOT BEEN ACTIVE. IF INTWRN HAS
:	ALREADY BEEN SET INTTIM ZAPS THE CRQ.

INTTIM	LCS	R0,1			
	AHM	R0,INT8MN		:DECREMENT CLOCK
	JGR	R11			:NOT TIME TO RUN INTTIM  YET

	ST	R11,INTTSV
	LIS	R1,3			:REINITIALIZE CLOCK
	AHM	R1,INT8MN
	LH	R3,INTACP,,		:EXAMINE ALL INT HOST CHANNELS	###jhl
:	recall that set bits in ACP are inactive channels.
	OH	R3,INTACT		:OR in the active channels
	XR	R3,R0			:EACH 1 => (PORT IN USE) AND (NO DATA)
	NH	R3,INTOUT		:MASK WITH TIMEOUT ENABLE ARRAY
	STH	R3,INTSAV
INTTI2	LHL	R3,INTSAV		:LOOP OVER ALL POSSIBILITIES
	JFFOH	R3,INTTI3
	J	INTTI1			:ALL DONE. RETURN
INTTI3	CLHI	R4,TINTCH		:IS IT WITHIN RANGE?
	JGE	INTTI1			:NO..  ALL DONE,RETURN
	RBT	R4,INTSAV		:FOUND A POSSIBILITY
	SBT	R4,INTWRN		:TEST AND SET ITS WARNING BIT
	JEBS	INTTI2			:WARNING HADN'T BEEN GIVEN.  CONTINUE
	LHL	R2,INTTAB,R4,R4 	:TIME TO ZAP... GET BUFFER NUMBER
	NHI	R2,-4
	XHI	R2,4			:FLIP FOR INTZAP (WANTS INCOMING #)
	JAL	R10,INTZAP		:ZAP AND DO CLOSING BOOK-KEEPING
	LHI	R0,INTZFL		:CRYPTO MESSAGE HAS ABS CHN #
	AR	R0,R4
	JAL	R8,CRYPTO,,
	HC	CRYE2B			:CRYPTO MESSAGE:INT HST TIMEOUT
	J	INTTI2			:CONTINUE...
INTTI1	LIS	R0,0
	STH	R0,INTACT		:CLEAR THE ACTIVE ARRAY
	L	R11,INTTSV
	JR	R11			:RETURN TO EXEC

	ENDMO.(INTHST)
	EI	:1-KILLIT
	KILMSG(INTHST)

:	***NOTHING PAST THIS POINT***


	SUBTTL	UTIL

:			*   * ***** ***** *
:			*   *   *     *   *
:			*   *   *     *   *
:			*   *   *     *   *
:			 ***    *   ***** *****

::#####################################################################
::
::	MODULE:		UTIL
::
::	SUBTTLS:
::		TRACER
::		Measurement routines
::		BUBBLE
::		SHRINK
::		FIND
::		ACCOUNTING
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA 0
	SEG	a.code

::*********************************************************************
::
::	ROUTINE:	TRACER:
::	FUNCTION:	UPSW trace interrupt routine.  If the PSW trace bit is
::		set, the interrupt will send us here just before every jump
::		instruction is executed.  The PSD (with PC=jump destination)
::		has been stored at 10x mac'd (TRPSW) and the trace bit has
::		been turned off.  TRACER runs in set 0F mac'd.  We return 
::		by loading the mainline PSW from TRPSW.  Trace table (TRCTAB)
::		entries are the LO HW's of the jump destination addresses.
::		TRNDEX points to the next entry in the table.  When a node
::		crashes, the trace table is copied into SEGC at TRSTAB where
::		it can be examined at leisure with the XRAY 'TT' command.
::		(TRSTAB is created so that its last entry is the address of
::		of the last jump before the crash.  Trace is turned off when
::		the node crashes.)
::
::		TRACER may only be enabled when the Tymfile OPTION(UTRC) is
::		invoked.  This sets assembly switch (DB.TRC).  Under the
::		DB.TRC switch, the trace bit is set by writing a 1000 at
::		EXEPSW+2.  It is also enabled/disabled by the XRAY 'TR'
::		command, though this causes a special kind of tracing to take
::		place (see below).
::
::		We will do one of 3 things in TRACER, depending on the
::		value of TRCRRQ:
::			1) If it is >0, we will simply return without making
::				a trace table entry.  This allows us to disable
::				tracing while the PSW trace bit is set.
::			2) If it is =0, we will unconditionally make an entry
::				in the trace table.  This is the default state
::				when trace is enabled via DB.TRC or by setting
::				the trace bit in EXEPSW.  When we reach the end
::				of the table, we'll wrap back around to the
::				beginning again.
::			3) If it is <0 (-1), we will make table entries only
::				for jumps which are within, into, or out of a
::				specified address range (TRCBEG to TRCEND).  
::				See XRAY 'TR' command for use of this trace.
::
::*********************************************************************

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl

:	Save some registers which will be clobbered by what follows.
:	TRCRRQ tells us what to do next:
:		If >0, exit via TREND.
:		If =0, do regular trace at TRACR0.
:		If <0, fall through to do special trace-in-range.
TRACER  STM	R13,TRSAVE,,		:SAVE SOME REGISTERS
	LH	R14,TRCRRQ,,		:SPECIAL TRACE REQUEST?
	JG	TREND			:FORCE NO TRACE IF > 0
	JE	TRACR0			:NO

:	Fall thru to here to trace jumps in a specified address range
:	(TRCRRQ set to -1 by 'TR' command).  If the jump destination is
:	in the range (TRCBEG to TRCEND), then make an entry in the trace table.
:	If the jump destination is out of the range and the previous entry
:	was in range, make an entry to show how we left the range.
:	If the jump destination	is in range and the previous entry was
:	out of range, preserve the previous entry to show how we got into
:	the range.

	LHL	R14,TRNDEX,,		:INDEX INTO TRACE TABLE
	L	R15,TRPSW+4		:GET JUMP DESTINATION ADDRESS
	C	R15,TRCBEG,,		:IN RANGE?
	JL	TRACR1			:NO, TOO LOW

	C	R15,TRCEND,,		:UPPER LIMIT
	JGE	TRACR1			:NO, TOO HIGH

	LH	R13,TRCRFL,,		:WAS PREVIOUS ENTRY IN RANGE?
	JLFS	TRACR4			:YES

	AIS	R14,2
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP

TRACR4	STH	R15,TRCTAB,R14,,	:MAKE ENTRY
	TS	TRCRFL,,		:INDICATE THAT LAST ENTRY WAS IN RANGE
	AIS	R14,2			:BUMP INDEX
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP
	STH	R14,TRNDEX,,		:NEW INDEX
TRACR2	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW			:CONTINUE

:	JUMP ADDRESS OUT OF RANGE
TRACR1	STH	R15,TRCTAB,R14,,	:MAKE TABLE ENTRY
	LH	R13,TRCRFL,,		:WAS PREVIOUS ENTRY IN RANGE?
	JGEFS	TRACR3			:NO

	AIS	R14,2			:BUMP INDEX
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP
	STH	R14,TRNDEX,,		:SAVE NEW INDEX
	STH	R14,TRCRFL,,		:INDICATE LAST ENTRY OUT OF RANGE
TRACR3	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW			:CONTINUE

:	Here for regular trace.
TRACR0	LHL	R15,TRPSW+6		:GET BRANCH ADDRESS
	LH	R14,TRNDEX,,		:GET INDEX INTO TRACE TABLE
	AIS	R14,2			:INC TO NEXT ENTRY
	NHI	R14,TRTBSZ-1
	STH	R15,TRCTAB,R14,,	:STORE IN TABLE
	STH	R14,TRNDEX,,		:SAVE INDEX FOR NEXT TIME
        lh      r14,8
        ahi     r14,10
        jn      trend
        lis     r14,1
        sth     r14,trcrrq,,            :stop tracing
        stm     r0,dorsav,,
	J	TREND
	WS	8			:PLACE TO PATCH IN SPECIFIC TESTS

:	Here to restore registers and UPSW back to mainline.
TREND	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW

	EI	:DB.TRC

	SUBTTL 	UTIL (Measurement routines)

::*********************************************************************
::
::	SUBROUTINE:	MTRFIC:
::	FUNCTION:	MEASURES CHARACTER TRAFFIC ON THE NETWORK LINKS.
::	CALLING SEQ:	JAL	R10,MTRFIC	(called from 1sec logic)
::
::*********************************************************************

:	EACH LINK MAINTAINS COUNTS FOR LOGICAL CPS IN AND OUT, PHYSICAL
:	CPS IN AND OUT, RMAKE CALLS IN WHICH NO PACKETS WERE MADE, AND
:	PACKETS MADE. THE RUNNING COUNTS ARE STORED IN
:	THE "LAST MINUTE'S"  LINK DESCRIPTOR FIELD AND COMPARED TO THE
:	"HI-WATER MARK" FIELD. THE SUM  OF ALL LINKS' COUNTS FOR LOGICAL
:	CHARACTERS IS SAVED, AND COMPARED TO HI-WATER MARKS FOR THE NODE.
:
:	IN ADDITION RMAKE STORES THE TIME EACH PACKET IS MADE IN THE AREA
:	PKTTIM, INDEXED BY RECORD NUMBER. THE SYNC INTERRUPT ROUTINE USES THIS
:	VALUE TO COMPUTE HOW LONG THE PACKET WAS QUEUED. A RUNNING COUNT OF
:	PACKET QUEUEING TIMES IS MAINTAINED IN KS.PQC
:	note that gmtcal is called prior to this to set up gmtnow to current
:	time

MTRFIC	LH	R7,SLOWC+2,,		:CURRENT TIME
	LH	R6,MTLTIM		:LAST TIME WE WERE HERE
	STH	R7,MTLTIM
	SR	R7,R6
	CHVR	R7,R7
	STH	R7,MTTINT		:EXACT TIME INTERVAL BETWEEN SAMPLES.
	LHL	R8,FASTC+2,,
	LHL	R6,MTLFST		:LAST FASTC TIME
	STH	R8,MTLFST
	SR	R8,R6
	JGEFS	MTRF03			:CAN'T USE CHVR HERE
	AI	R8,10000		:BECAUSE R8 MAY HAVE 8000 BIT SET
MTRF03	ST	R10,MTRSAV		:save return to free up register###wjl
:	initialize various accumulators
	LIS	R10,0			:sum of all links phys counts output
	LIS	R5,0			:sum of all links phys counts input
	LIS	R0,0
	st	r0,rtdpks		:packets torn
        st      r0,rmklrs               :clear count of logical records made
	st	r0,rmknrs		:clear total calls to rmake
	st	r0,rmkrms		:clear idle count of rmake
	st	r0,ns.swd		:clear sum of software delay
	st	r0,ns.hwd		:clear sum of hardware delay
	LIS	LRC,0			:SUM OF ALL LINKS LOGICAL COUNTS OUTPUT
	LIS	R12,0			:SUM OF ALL LINKS LOGICAL COUNTS INPUT
:	process each link
	LHI	KN,2*(NLINKS-1)		:DO FOR ALL LINKS
MTRF05	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR INDEX
	LB	R1,NLAT,KD		:ANY LINES UP ON THIS LINK?
	JE	MTRF48			:NO, GO DIRECTLY TO THE NEXT LINK
	A	LRC,KS.LCO,KD		:INCREMENT CUMULATIVE COUNTERS
	A	R12,KS.LCI,KD
	A	R10,KS.PCO,KD		:###wjl
	A	R5,KS.PCI,KD		:###wjl
	LIS	R1,4			:UPDATE 4 GROUPS OF COUNTERS,
	LA	R2,KS.PCO,KD		:BEGINNING WITH PCO

MTRF08	L	R3,0,R2			:GET RUNNING COUNT AND
	ST	R3,4,R2			:STORE IN 'LAST MINUTE' FIELD
	ST	R0,0,R2			:CLEAR RUNNING COUNT
	C	R3,8,R2			:NEW HI-WATER MARK?
	JLEFS	MTRF10			:NO
	ST	R3,8,R2			:YES - SAVE IT
	l	r6,gmtnow
	st	r6,0c,r2
MTRF10	AHI	R2,10			:ADVANCE TO NEXT GROUP
	SIS	R1,1			:IF MORE TO DO
	JG	MTRF08
	l	r3,ks.npc,kd		:times nothing to do
	am	r3,rmkrms		:is part of total calls to rmake
	am	r3,rmknrs		:is a call withnothing to do
	st	r3,ks.npm,kd
	st	r0,ks.npc,kd
	LR	R1,R8			:MOVE TIME INTERVAL OVER
	D	R0,KS.RRC,KD		:DIVIDE BY RMAKE R-ROBIN COUNT
	lis	r0,0			:restore r0
	ST	R0,KS.RRC,KD		:CLEAR OUT ROUND ROBIN COUNT
	SRLS	R1,1			:DIVIDE BY 2
	STH	R1,KS.RRT,KD		:AND STORE BACK AVERAGE R-ROBIN DELAY

	LH	R2,LRMSAV,KD		:GET LRM SAVE VALUE
	LH	R3,LRM,KD		:AND LAST REC MADE ON LINK
	STH	R3,LRMSAV,KD		:UPDATE LRMSAV
	SR	R3,R2			:SUBTRACT TO GET NUMBER OF RECORDS MADE
	JGEFS	MTRF13
	AI	R3,10000
MTRF13	STH	R3,KS.PKM,KD		:SAVE NUMBER OF PACKETS MADE
	am	r3,rmkrms		:a call to rmake
	L	R1,KS.PQC,KD		:GET CUMMULATIVE QUEUEING DELAYS
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRF15			:SET ZERO ##AL
	STH	R3,KS.AQU,KD		:STORE 0 DELAY (IN FASTC TICKS)
	JFS	MTRF17
MTRF15	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS MADE
	STH	R2,KS.AQU,KD		:STORE AVERAGE DELAY (IN FASTC TICKS)
MTRF17	ST	R0,KS.PQC,KD		:CLEAR OUT QUEUEING DELAY ACCUMULATOR

	IF	BFLTMR			:for buffer delay timing pairs	###JHL
	LHL	R1,BDLCNT,KD		:read running occurrence counter
	STH	R0,BDLCNT,KD		:start fresh for new minute
	STH	R1,KS.BFC,KD		:save minute count for display
	LHL	R1,BDLACC,KD		:read running delay accumulator
	STH	R0,BDLACC,KD		:start fresh for new minute
	STH	R1,KS.BFD,KD		:save minute count for display
	EI	:BFLTMR			:				###JHL

:	COLLECT LOGICAL RECORDS FOR RECDS/PKT STAT.			###JHL
	LHL	R1,KS.LRM,KD		:GET COUNT OF LOGICAL RECORDS MADE
        am      r1,rmklrs               :count of logical records
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRF20			:SET ZERO ##AL
	STH	R3,KS.LRA,KD		:PUT 0 IF NO LRM
	JFS	MTRF22
MTRF20	LR      R2,R3                   :round instead of truncate
        SRLS    R2,1
        AR      R1,R2                   :add in half the divisor        ###sdw
	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS MADE
	STH	R2,KS.LRA,KD		:QUOTIENT IS AVG RECS/PKT
MTRF22	STH	R0,KS.LRM,KD		:CLEAR COUNT -- START NEXT MINUTE ANEW
	L	R1,KS.PMO,KD		:GET TOTAL NUMBER OF BYTES
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRI24			:SET ZERO ##AL
	STH	R3,KS.ASZ,KD		:RESULT= 0 PACKET SIZE
	JFS	MTRF26
MTRI24	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS
	STH	R2,KS.ASZ,KD		:RESULT=AVERAGE PACKET SIZE
MTRF26	LB	R1,KSPDmt,KD		:FIGURE OUT LINE SPEED IN CPS
	LHL	R6,KSPCPF,R1,R1		:LOOK UP THE CPS RATE IN FASTC	###wjl
	LB	R4,NLAT,KD		:GET NUMBER OF LINES ON LINK
	MHR	R2,R4			:FORM <AVE SIZE>*<NLINES>
	LHR	R6,R6			:DIVIDER CAN'T BE 0
	JNFS	MTRF28			:SET ZERO ##AL
	STH	R2,KS.XMT,KD		:XMIT TIME is 1 fastc per car (or more)
	JFS	MTRF30
MTRF28	DHR	R2,R6			:DIVIDE BY LINK CPS RATE TO GET MEAN
	STH	R3,KS.XMT,KD		: XMIT TIME... THIS RESULT IS IN FASTC
MTRF30	LHL	R1,KS.BAK,KD		:GET BACKLOG COUNT FOR LINK
	STH	R1,KS.BAM,KD		:AND MOVE TO SAVE AREA
	STH	R0,KS.BAK,KD		:CLEAR BACKLOG COUNT

	LH	R2,LRTSAV,KD		:GET OLD LRT VALUE
	LH	R3,LRT,KD		:AND CURRENT VALUE
	STH	R3,LRTSAV,KD		:UPDATE LRTSAV
	SR	R3,R2
	JGEFS	MTRF32
	AI	R3,10000
MTRF32	am	r3,rtdpks		:a packet torn
	L	R1,KS.SRC,KD		:GET CUMMULATIVE SYLVER-RTD DELAYS
	ST	R0,KS.SRC,KD		:AND CLEAR THE ACCUMULATOR
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRF34			:SET ZERO ##AL
	STH	R3,KS.SRA,KD		:STORE 0 DELAY (IN FASTC TICKS)
	JFS	MTRF36
MTRF34	DHR	R1,R3			:GET AVERAGE SYLVER-RTD DELAY IN FASTC
	STH	R2,KS.SRA,KD		:AND SAVE IT
MTRF36	ah	r2,ks.rrt,kd		:get other half of software delay
	l	r6,ks.lmo,kd
	a	r6,ks.lmi,kd		:get total cps
	lis	r1,0			:MR does val in r1 & r2 * r6
	mr	r1,r6			:the sw delay for this link
	am	r2,ns.swd
	lhl	r2,ks.xmt,kd		:components of HW delay
	ah	r2,ks.aqu,kd
	lis	r1,0
	mr	r1,r6			:weight with cps for the link
	am	r2,ns.hwd

MTRF48	SIS	KN,2			:DO FOR ALL LINKS
	JGE	MTRF05
:	done with the link stats, now do stats for each LINE

:	COLLECT MARK, REXMT, AND XMT STATS FOR LINES ON THIS LINK
:	--SHOWN IN KS COMMAND						###JHL
	LHI	R1,(NLINES-1)*2		:				###wjl
MTRF50	L	R2,KDLN,R1,R1		:SEE IF THIS LINE IS ATTACHED	###wjl
	JL	MTRF58			:NEG VALUE SAYS NO
	LHL	R2,LXMSET,R1		:READ CURRENT RUNNING COUNT(MARKING)
	LHL	R3,KL.LRF,R1		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.LRF,R1		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	 = NEW TOTAL
	JGEFS	MTRF52			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
MTRF52	STH	R2,KL.LSV,R1		:SAVE NEW MINUTE'S TOTAL	###wjl
	LHL	R2,TRRXMT,R1		:READ CURRENT RUNNING COUNT(REXMIT)
	LHL	R3,KL.TRF,R1		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.TRF,R1		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	
	JGEFS	MTRF54			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
MTRF54	STH	R2,KL.TSV,R1		:SAVE NEW MINUTE'S TOTAL	###wjl
	LHL	R2,RCTRNS,R1		:READ CURRENT RUNNING COUNT(TRANSMIT)
	LHL	R3,KL.RRF,R1		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.RRF,R1		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	 = NEW TOTAL
	JGEFS	MTRF56			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
MTRF56	STH	R2,KL.RSV,R1,		:SAVE NEW MINUTE'S TOTAL	###wjl
MTRF58	SIS	R1,2			:STEP BACK TO NEXT LOWEST LINE
	JGE	MTRF50			:LOOP UNTIL ALL LINES DONE

	DH	R8,SYLXEC		:DIVIDE TIME INTERVAL BY # SYLVER RUNS
	SRLS	R9,1			:DIVIDE AVERAGE INTERVAL BY 2
	STH	R9,SYLXAV		:AND STORE INTO AVERAGE DELAY CELL
	STH	R0,SYLXEC		:CLEAR COUNT OF SYLVER RUNS

:	SAVE COUNTS FOR ALL LINKS AND TEST FOR NEW HI-WATER MARK
	ST	LRC,TOTCHR		:SAVE TOTAL CHARS OUT
	AM	R12,TOTCHR		:PLUS TOTAL CHARS IN
	lis	r0,0
	lr	r1,lrc
	DR	r0,R7			:CONVERT EACH TO SECONDS
	ST	R1,NSCPSO		:AND SAVE
        c	r1,NSCPHO		:NEW HI-WATER MARK?
	JLEFS	MTRF62			:NO
	ST	R1,NSCPHO		:YES - SAVE
        L       R0,GMTNOW
        ST      R0,ns.otl		:save time
MTRF62	lis	r0,0
	lr	r1,r12
	DR	R0,R7
	ST	R1,NSCPSI		:INPUT COUNT
	C	R1,NSCPHI		:TEST FOR HWM FOR INPUT CHRAS
	JLEFS	MTRF64			:NO
	ST	R1,NSCPHI
        L       R0,GMTNOW
        ST      R0,ns.itl		:save time

:	NODE LINKS' TOTAL PHYSICAL CPS RATES
MTRF64	lis	r0,0
	lr	r1,r10
	DR	R0,R7			:convert physical chars out	###wjl
	ST	R1,NS.PCO		:store HW value in FW location	###wjl
	C	R1,NS.PHO		:new hi-water mark for PCO?	###wjl
	JLEFS	MTRF66			:no				###wjl
	ST	R1,NS.PHO		:yes, save			###wjl
        L       R0,GMTNOW
        ST      R0,ns.otp		:save time
MTRF66	lis	r0,0
	lr	r1,r5
	DR	R0,R7			:convert physical chars in	###wjl
	ST	R1,NS.PCI		:store HW value in FW location	###wjl
	C	R1,NS.PHI		:new hi-water mark for PCI?	###wjl
	JLEFS	MTRF68			:no				###wjl
	ST	R1,NS.PHI		:yes, save			###wjl
        L       R0,GMTNOW
        ST      R0,ns.itp		:save time
MTRF68	LIS	R3,0			:for clearing running counts
        L       R1,DISICC		:current value
        ST      R3,DISICC               :and clear it
        ST      R1,DISICM               :is current min value
        CL      R1,DISICH
        JLFS    MTRF70
        ST      R1,DISICH
        L       R0,GMTNOW
        ST      R0,DISICT
:       same statistics but for output side
MTRF70	L	R1,DISOCC               :current value
        LIS     R3,0
        ST      R3,DISOCC               :and clear it
        ST      R1,DISOCM               :is current min value
        CL      R1,DISOCH
        JLFS    MTRF72
        ST      R1,DISOCH
        L       R0,GMTNOW
        ST      R0,DISOCT
MTRF72	l	r12,totchr		:get total cps
	jnfs	mtrf74			:none, so that is also the delays
	st	r12,ns.hwd		:save delay
	st	r12,ns.swd
	jfs	mtrf76
mtrf74	l	r2,ns.hwd		:total delays weighted by cps
	lis	r1,0
	dr	r1,r12			:get actual HW delay
	st	r2,ns.hwd
	l	r2,ns.swd		:total delays weighted by cps
	lis	r1,0
	dr	r1,r12			:get actual SW delay
	AH	R2,SYLXAV		:and ave delay in seeing data arrive
	st	r2,ns.swd
mtrf76
	L	R10,MTRSAV		:load return			###wjl
	JR	R10			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	PLCALC 
:
::	FUNCTION:	collects the data to be entered into the performance
::			log.  and if time to make an entry into perf log
::			then does so.
::	CALLING SEQ:	JAL	R10,PLCALC
::
::*********************************************************************

       if	pl.num
PLCALC	lh	r3,pl.tim		:do we know when to save?
	jge	plca04			:yes, so can make entry
	lh	r3,getgmt		:don't have gmt, so don't make entry
	jer	r10
:	just got gmt, so determine when we should be making entries so
:	that will eventually make entry on the hour.
	l	r1,slowc,,		:do time determination
	s	r1,gmtslc		:time since got gmt
	a	r1,gmthex		:sec's since start of the year
	lhi	r3,$a60			:we want minutes since start of year
	lis	r0,0			:high reg for 2 reg dividend
	dr	r0,r3			:r1 gets minutes since start of year
	lhi	r3,pl.frq		:the desired frequency
	lis	r0,0
	dr	r0,r3			:divide minutes by frequency
	lhi	r1,pl.frq		:we have pos modulo
	sr	r1,r0			:and are freg - modulo from log time
	sth	r1,pl.tim		:how long until make an entry

:	collect running statistics
plca04	la	r9,pl.ave		:pointer to the accumlator for averages
	lis	r0,1
	am	r0,pl.gmt,r9		:count how many averaged together
	lhl	r0,exlavg		:exec count for last minute
	am	r0,pt.exe,r9
	l	r1,nscpso		:logical cps out
	am	r1,pt.lco,r9
	l	r2,nscpsi		:logical cps in
	am	r2,pt.lci,r9
	l	r3,ns.pco		:physical cps out
	am	r3,pt.pco,r9
	l	r4,ns.pci		:physical cps in
	am	r4,pt.pci,r9
	lhl	r5,hnport		:dispatcher ports
	am	r5,pt.prt,r9
	lhl	r6,pasthr		:number of passthroughs
	am	r6,pt.pth,r9
	lhl	r7,nbrcmd		:number of cmd cts
	lhl	r8,tvrbuf
	jefs	plca05
	ais	r7,1			:including our cmd cir
plca05	am	r7,pt.cmd,r9
	l	r8,ns.hwd		:get hardware delay
	am	r8,pt.hwd,r9
	l	r8,ns.swd		:get software delay
	am	r8,pt.swd,r9
:	done with the making of the averages, now check for peaks
	ahi	r9,pt.siz		:point to min exec entry
	c	r0,pt.exe,r9		:do we have a new one?
	jgfs	plca10			:nope,
	jal	r11,plca90
plca10	ahi	r9,pt.siz		:point to max exec entry
	c	r0,pt.exe,r9		:do we have a new one?
	jlfs	plca15
	jal	r11,plca90		:save it away
plca15
       if	pl.all			:also doing CPS maxs?
	ahi	r9,pt.siz		:point to max Lcps out entry
	c	r1,pt.lco,r9		:do we have a new one?
	jlfs	plca17
	jal	r11,plca90		:save it away
plca17	ahi	r9,pt.siz		:point to max Lcps in entry
	c	r2,pt.lci,r9		:do we have a new one?
	jlfs	plca20
	jal	r11,plca90		:save it away
plca20	ahi	r9,pt.siz		:point to max Pcps out entry
	c	r3,pt.pco,r9		:do we have a new one?
	jlfs	plca22
	jal	r11,plca90		:save it away
plca22	ahi	r9,pt.siz		:point to max Pcps in entry
	c	r4,pt.pci,r9		:do we have a new one?
	jlfs	plca24
	jal	r11,plca90		:save it away
plca24
       ei	:pl.all
:	now see if it is time to put this into the log
	lcs	r1,1
	ahm	r1,pl.tim		:number of interations left
	jgr	r10			:not our time yet
	lhi	r1,pl.frq		:when to collect next
	sth	r1,pl.tim
:	first convert our totals to averages (for that entry)
	lhi	r6,pt.siz-8
	l	r3,pt.gmt+pl.ave	:how many accumulations in averages
plca30	lis	r0,0
	l	r1,pt.exe+pl.ave,r6	:get a stored accumulator
	dr	r0,r3			:make it into a true average
	st	r1,pt.exe+pl.ave,r6	:and save it away
	sis	r6,4
	jgebs	plca30
:	now put averages into log
	l	r1,gmtnow		:get current time
	lhl	r8,pl.ptr		:get pointer into log	
	la	r7,pl.prb,,		:get address of start of log
	l	r0,gmtnow		:get current time
	ohi	r0,7f			:set low bits to indicate AVER
	st	r0,pl.gmt,r7,r8		:store into log
	la	r9,pl.ave
	jal	r11,plca80		:routine to pack an entry in the log
:	after average fix up ring pointer
	ahi	r8,pl.siz		:go to next entry
	clhi	r8,pl.num*pl.siz	:at end of ring?
	jlfs	plca40			:handle wrap
	lis	r8,0
plca40	lhi	r6,80			:current msg indicator (max is 40)
:	now do min/max exec (and other maxs if present)
plca42	srls	r6,1			:next msg type
	ahi	r9,pt.siz		:point to max exec
	clhi	r9,pl.tsz+pl.cur	:done with all temp holding areas
	jge	plca60			:and done!
plca44	l	r0,pt.gmt,r9		:get time of the max event
	jebs	plca42			:entry cleared since already entered
	ni	r0,@7f			:knock of type bits
	lr	r3,r6			:temp holding for event type
	lr	r4,r6			:cur val of msg types matched
	lis	r1,0			:a val for clearing
:	this will find entries with the same time entry and thus the
:	same entry so don't have to store duplicate info if we mark
:	our entry as being for several different types.
       if	pl.all			:if have several maxs
	lr	r5,r9
plca46	ahi	r5,pt.siz		:check next entry
	clhi	r5,pl.tsz+pl.cur	:no more entries to check
	jge	plca54			:done looking for matching entries
	srls	r4,1			:msg type being checked
	l	r2,pt.gmt,r5		:have a time match (ie entry match)
	ni	r2,@7f			:knock of type bits
	cr	r0,r2
	jnbs	plca46			:no, check next
	or	r3,r4			:another msg type for this entry
	st	r1,pt.gmt,r5		:make entry as being enterred
	j	plca46			:check another entry for a match
       ei	:pl.all
plca54	or	r0,r3			:indicate msg type(s) being stored
	st	r0,pl.gmt,r8,r7		:
	jal	r11,plca80		:pack this entry away
	ahi	r8,pl.siz		:go to next entry in log
	clhi	r8,pl.num*pl.siz	:at end of ring?
	jlfs	plca56			:handle wrap
	lis	r8,0
plca56	sth	r8,pl.ptr
	j	plca42			:do another entry

:	have made entries.  Now clear values.
plca60	lis	r0,0
	sth	r0,pl.cur+pl.tsz-2	:put a zero at last position
	la	r1,pl.cur+pl.tsz-2	:get address of last position
	lr	r2,r1
	sis	r2,2			:copy target
	li	r3,(pl.tsz+pt.siz-2)*8-10 :bits -10 to copy (moving 0 bits)
	copy	r1,r3
	lcs	r0,1
	srls	r0,1			:7fff...
	st	r0,pt.exe+pl.cur	:max val for min exec compares
	jr	r10			:and done

:	little subroutine to pack stats at r9 into perf log entry
plca80	l	r1,pt.exec,r9
	sth	r1,pl.exec,r7,r8
:	pack logical cps into 5 bytes with even starting address
	l	r1,pt.lci,r9
	slls	r1,$a12			:only saving 20 bits
	st	r1,pl.lc,r7,r8
	slls	r1,8
	l	r2,pt.lco,r9		:get chars in
	ni	r2,0fffff
	or	r2,r1			:combine
	slls	r2,8			:align for storage
	st	r2,pl.lc+2,r7,r8
:	pack physical cps into 5 bytes with odd starting address
	l	r1,pt.pci,r9
	slls	r1,4
	exhr	r1,r1	
	stb	r1,pl.pc,r7,r8		:store high 8 bits
	ni	r1,0fff00000		:only leave low bits now in high hw
	l	r2,pt.pco,r9		:combine with 20 bits of in
	ni	r2,0fffff		:mask of any excess
	or	r1,r2			:combine
	st	r1,pl.pc+1,r7,r8	:store the 12 of out and 20 of in
:	pack HW/SW delays into 3 bytes with even starting address
	l	r1,pt.hwd,r9
	clhi	r1,1000			:bigger than can store?
	jlfs	plca82
	lhi	r1,0fff
plca82	slls	r1,$a12			:each field is stored as 12 bits
	l	r2,pt.swd,r9
	clhi	r2,1000			:bigger than can store?
	jlfs	plca83
	lhi	r2,0fff
plca83	or	r1,r2			:combine both
	slls	r1,8			:shift for storage
	st	r1,pl.del,r7,r8
:	pack ports (12 bits), passthrough (14 bits), cmd cts (14 bits)
:	into 5 bytes with an odd starting address
	l	r1,pt.prt,r9
	lr	r2,r1
	srls	r1,4			:want 12 bits (in hw) (high 8 bits)
	stb	r1,pl.prt,r7,r8		:store into odd address
	slls	r2,$a14			:want low 4 bits of ports
	o	r2,pt.pth,r9		:combine in passthroughs
	slls	r2,$a14			:make room for cmd cts
	o	r2,pt.cmd,r9		:combine in cmd cts
	st	r2,pl.prt+1,r7,r8	:save it away
	jr	r11			:and done

:	little subroutine to store everything into the entry at r9
plca90	st	r0,pt.exe,r9
	st	r1,pt.lco,r9		:logical cps out
	st	r2,pt.lci,r9		:logical cps in
	st	r3,pt.pco,r9		:physical cps out
	st	r4,pt.pci,r9		:physical cps in
	st	r5,pt.prt,r9		:dispatcher ports
	st	r6,pt.pth,r9		:number of passthroughs
	st	r7,pt.cmd,r9		:number of cmd cts
	l	r8,gmtnow		:already set up in 1 min logic
	st	r8,pt.gmt,r9		:save time of change
	l	r8,ns.swd		:get software delay
	st	r8,pt.swd,r9
	l	r8,ns.hwd		:get hardware delay
	st	r8,pt.hwd,r9
	jr	r11

       ei	:pl.num

::*********************************************************************
::
::	SUBROUTINE:	MAKNDL:
::	FUNCTION:	MAKES A NEEDLE IN ACCORDANCE WITH THE DATA
::			SUPPLIED IN NODLS AND DLYFLG, AND NOTIFYS CRQ
::	CALLING SEQ:	JAL	R10,MAKNDL
::	INPUT:		CHN = ABSOLUTE CHANNEL NUMBER TO BE USED
::			R6  = OFFSET INTO DLYBSE, THE DATA AREA
::
::*********************************************************************

MAKNDL	JAL	R8,GFCBUF,,		:GET A FREE BUFFER PAIR
	SKIPAD(MAKOOB)			:immed. return - out of buffers!###wjl
	LHI	R1,NEEDP		:+4, ok -WRITE NEEDLE POINT INTO BUFFER
	EXBR	R1,R1
	JAL	R8,WCI,,
	EXBR	R1,R1
	JAL	R8,WCI,,
	LIS	R1,0
	JAL	R8,WCI,,		:ESCAPE THE BYTE COUNT
	JAL	R8,WCI,,		:LEAVE SLOT FOR BYTE COUNT
	L	PRD,BE,R2,		:SAVE POINTER TO BYTE COUNT SLOT
	JAL	R8,WCI,,		:ESCAPE THE LINK COUNT
	LHL	R1,NODCNT,R6		:NODCNT = 2X # OF 1-WAY NODES 
	OHI	R1,80
	JAL	R8,WCI,,		:WHICH = TOTAL ROUND TRIP LINK COUNT
	LHI	R1,0FFFF		:DUMMY INVOICE NUMBER
	JAL	R9,WHWI,,
	JAL	R9,WHWI,,
	LHL	R1,DLYFLG,R6		:FLAGS
	JAL	R9,WHWI,,
	LHI	R1,MACHNM		:REQUESTING NODE NUMBER
	JAL	R9,WHWI,,
	LR	R1,CHN			:ABSOLUTE PORT NUMBER
	JAL	R9,WHWI,,
	LHL	R7,NODCNT,R6		:NUMBER OF NODES IN 1-WAY PATH
	JE	MAKND4			:ZERO, SOMEONE WNTS AN INTERNAL PATH
	LIS 	R4,0			:NONZERO, COPY NODE LIST INTO NEEDLE
MAKND1	LHL	R1,NODLST,R6,R4		:GET THE NEXT NODE OFF THE LIST
	JAL	R9,WHWI,,		:AND WRITE INTO NEEDLE
	AIS	R4,2
	CR	R7,R4			:AT END OF LIST?
	JGBS	MAKND1			:NO,LOOP BACK
	SIS	R4,4			:YES,BACK UP TO NEXT-TO-LAST NODE
	JLFS	MAKND3 			:SPECIAL CASE:ONLY 1 NODE IN LIST
MAKND2	LHL	R1,NODLST,R6,R4		:WORK BACKWARDS FOR RETURN PATH
	JAL	R9,WHWI,,
	SIS	R4,2
	JGEBS	MAKND2			:MORE NODES LEFT, LOOP BACK
MAKND3	LHI	R1,MACHNM		:WE ARE THE DESTINAION NODE
	JAL	R9,WHWI,,
MAKND4	LHI	R1,HST0+8000		:AND THE DESTINATION HOST
	JAL	R9,WHWI,,
	LHI	R1,7FFF			:DEPOSIT DUMMY ID'S
	JAL	R9,WHWI,,
	JAL	R9,WHWI,,
	if	1-t2gate
	LIS	R4,0			:index into username
MAKND5	LB	R1,XGGDLA+6,R4,		:get first byte of username
	JEFS	MAKND6
	JAL	R9,WCIE,,		:write it
	AIS	R4,1
	CLHI	R4,$a 12		:max len of stored username
	JLBS	MAKND5
MAKND6	LIS	R1,0D			:CR end of username
	JAL	R8,WCI,,
	else	
        LHI     R1,444C
        JAL     R9,WHWI,,               :DEPOSIT DLOAD USER NAME
        LHI     R1,4F41
        JAL     R9,WHWI,,
        LHI     R1,440D
        JAL     R9,WHWI,,
	ei				:1-t2gate
	JAL	R8,CBCCT,,		:GET THE BYTE COUNT FOR THE NEEDLE
	STB	R1,0,PRD		:AND DEPOSIT INTO ITS SLOT
	JAL	R9,CRQHCR		:BUILD HALF CRQ
	JAL	R9,CRQALT		:ALERT CRQ
	LR	R3,R2
	SRLS	R3,3
	SBT	R3,CRQEND

	LHL	R0,HNPORT		:INCREMENT NUMBER OF HOST PORTS IN USE
	AIS	R0,1
	CLH	R0,MXPORT		:IS THIS A NEW PEAK?
	JLEFS	MAKND7			:NO
	STH	R0,MXPORT		:YES, RECORD IT
MAKND7	STH	R0,HNPORT

        LR      R1,R2
        SRLS    R1,1                    :SET UP BUFTIM INDEX
        L       R0,FASTC,,
        ST      R0,BUFTIM,R1,           :TIME THAT NEEDLE ORIGINATES IN NODE

	JR	R10			:RETURN TO CALLER

MAKOOB	J	OP8463,,		:out of buffers! - crash	###wjl
::*********************************************************************
::
::	SUBROUTINE:	CKOVLD:
::	FUNCTION:	CHECKS ALL ACTIVE LINKS TO SEE WHICH ONES HAVE
::			BEEN OVERLOADED DURING THE PREVIOUS 1/2 SECOND.
::			INCS A COUNTER FOR THOSE WHICH HAVE.
::	CALLING SEQ:	JAL	R10,CKOVLD  CALLED FROM 1/2 SEC LOGIC.
::
::*********************************************************************

CKOVLD	LHI     R2,LKSIZE-4
CKOV2	L	R3,ALINKS,R2		:COPY ALINKS INTO CKOSAV
	ST	R3,CKOSAV,R2
	SIS	R2,4
	JGEBS	CKOV2
	LIS	R3,1			:FOR INCREMENT COUNTERS
	LIS	R0,0			:FOR REFRESHING IDLE ARRAY
	LHI	R5,LKSIZE-4		:R5 = INDEX INTO ARRAY
CKOVA	L	R1,CKOSAV,R5
	JFFO	R1,CKOVC		:ACT ON ACTIVE LINKS
	SIS	R5,4			:NO BITS SET
	JGEBS	CKOVA
	JR	R10			:NO MORE ACTIVE LINKS
CKOVC	RBT	R2,CKOSAV,R5		:FIRST BIT FOUND
        LR      R4,R5                   :preserve R5 for next link      ###sdw
	SLLS	R4,3			:FORM LINK NO.
	AR	R2,R4
	SLLS	R2,1
	L	R4,KDKN,R2,R2		:GET LINK DESCRIPTOR INDEX
	SRLS	R2,1
	SBT	R2,LKRR			:RESET IF ROUND-ROBIN SERVICED FOR 
					: ALL CHANNELS ON LINK
	JEFS	CKOVB			:ALL CHANNELS SERVICED
	AHM	R3,LKOVLD,R2,R2		:BUMP COUNT FOR LINK OVERLOADED
CKOVB	LH	R1,IDLE,R4		:NEGATIVE IF LINK EVER WENT IDLE
					: DURING PAST 1/2 SECOND
	STH	R0,IDLE,R4		:REFRESH CELL, STH DOESN'T ALTER PSW CC
	JL	CKOVA			:LINK NOT SATURATED
	AHM	R3,LKSTCT,R2,R2		:INCREMENT COUNT OF LINK SATURATED
	J	CKOVA

	SUBTTL	UTIL (BUBBLE)

::*********************************************************************
::
::	SUBROUTINE:	BUBBLE:
::	FUNCTION:	THIS ROUTINE IS CALLED WHEN:
::		A)  A NEW LINK IS COMING UP,
::		B)  ADDITIONAL CHANNELS FROM T-II TO T-II ON A LINK ARE NEEDED.
::		    TYMNET-1.5 AND TYMNET-I DO NOT BUBBLE.
::	CALLING SEQ:	JAL	R8,BUBBLE
::	RETURNS:	IMMEDIATE - NO SPACE IS AVAILABLE
::			+4 - BUBBLED
::
::*********************************************************************

:	WHEN THE NEED FOR MORE CHANNELS IS REALIZED, THE FOLLOWING
:	CODE STARTS OUT AT THE LINK NUMBER REQUESTING THE ADDITIONAL
:	CHANNELS AND SCANS TO THE RIGHT (HIGHER MEM ADDR'S) LOOKING
:	FOR AN AREA OF EMPTY PERMUTER TABLE SPACE.  IF IT FINDS SPACE
:	AVAILABLE IT MOVES ANY INTERMEDIATE LINKS INTO THAT SPACE, 
:	LEAVING THE FREE SPACE IMMEDIATELY BEHIND THE EXISTING LINK'S
:	PERMUTER TABLES.  THE LINK'S POINTERS ARE THEN ADJUSTED TO
:	REFLECT THE INCREASED CAPACITY.
:	IF NO SPACE IS FOUND AFTER THE LINK, THE PERMUTER TABLES
:	ARE SEARCHED FROM THE BEGINNING, AGAIN LOOKING FOR FREE SPACE.
:	WHEN THAT FREE SPACE IS FOUND ALL LINKS FROM THAT SPACE TO THE
:	LINK REQUESTING SPACE (INCLUSIVE) ARE SHIFTED LEFT LEAVING 
:	ROOM AGAIN BEHIND THE LINK IN QUESTION.  IT'S POINTERS ARE 
:	AGAIN UPDATED TO INCLUDE AN ADDITIONAL 1/2 PAGE OF P.T.
:	IF NO SPACE IS AVAILABLE THEN THIS ROUTINE TAKES AN ERROR
:	RETURN (NO SKIP).  

:	TRY TO FIND A HALF-PAGE FROM THE PERMUTER TABLE POOL. IF NO HALF-
:	PAGES AVAILABLE, TAKE IMMEDIATE RETURN. IF A HALF-PAGE IS FOUND,
:	INCLUDE IT IN THE DOMAIN OF PERMUTER TABLE SPACE ALLOCATED TO
:	THE LINK 'KN'.
BUBBLE	LR	R5,KN			:START WITH CURRENT LINK, SCAN TO END
BUBL1	LHL	R1,TBDPKN+2,R5,R5	:GET NEXT LINK'S BEGIN POINTER AND
	LHL	R0,EBDPKN,R5,R5		:COMPARE TO THIS LINK'S END POINTER
        SR      R1,R0
	JG	BUBL3			:GREATER - FOUND A BUBBLE
	AIS	R5,1			:INCREMENT LINK INDEX
	CLHI	R5,NLINKS		:END?
	JLBS	BUBL1			:NOT YET

:	REACHED FINAL LINK WITHOUT FINDING A BUBBLE. START FROM BEGINNING
:	AND SCAN UP TO LINK WE ENTERED WITH.
	LIS	R5,0
BUBL2	LHL	R1,TBDPKN+2,R5,R5	:GET NEXT LINK'S BEGIN POINTER AND
	LHL	R0,EBDPKN,R5,R5		:COMPARE TO THIS LINK'S END POINTER
        SR      R1,R0
	JG	BUBL13			:FOUND A BUBBLE
	AIS	R5,1
	CLR	R5,KN			:SCANNED ALL LINKS FOR BUBBLES?
	JLBS	BUBL2			:NO - CONTINUE
	IF	DB.DEB
	LH	R0,NUMPAG		:CONSISTENCY TEST - PAGES AVAIL > 0?
	JEFS	BUBEXI			:NO - O.K.			###wjl
	DBOOPS
	EI	:DB.DEB
BUBEXI	SKIP(0,R8)			:YES, NON-SKIP RETURN - NO BUBBLE FOUND

BUBL3	STH	R5,BUBS1		:SAVE NUMBER OF LINK PRIOR TO BUBBLE
	LHL	R3,EBDPKN,R5,R5
	LHL	R4,TBDPKN+2,R5,R5
	LR	R5,R4
	SR	R5,R3			:COMPUTE SIZE OF EXISTING BUBBLE
	ST	R5,BUBS2		:AND SAVE
	SRLS	R5,1			:NUMBER OF CHANNELS IN BUBBLE
	LR	R1,R3			:GET BEGIN-BUBBLE POINTER, COMPUTE DIST
	LHL	R0,EBDPKN,KN,KN		:BACK TO END OF CURRENT LINK'S TABLES
        SR      R1,R0
	STH	R1,BUBS3		:SAVE FOR POSSIBLE POST-MORTEM

:	BUBS1 -	LINK NUMBER OF LINK PRIOR TO BUBBLE
:	BUBS2 -	BUBBLE SIZE
:	R1 -	# BYTES FROM END OF CURRENT LINK'S TABLES TO BEGINNING OF BUBBL
:	R3 -	POINTER TO BEGINNING OF BUBBLE
:	R4 -	POINTER TO END OF BUBBLE
:	R5 -	NUMBER OF CHANNELS IN BUBBLE

:	ALL TABLES FROM THE END OF THE CURRENT LINK TO THE BEGINNING OF THE
:	BUBBLE MUST BE MOVED SO THAT THE BUBBLE FOLLOWS THE CURRENT LINK (KN).
BUBL4	SIS	R3,2
	SIS	R4,2			:MOVING A HW AT A TIME
	SIS	R1,2			:NUMBER OF BYTES REMAINING TO MOVE
	JL	BUBL5			:DONE

	LHL	R2,NIOTAB,R3,		:MOVING FROM LEFT..
	STH	R2,NIOTAB,R4,		:..TO RIGHT
	JEBS	BUBL4			:NULL ENTRY
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:DON'T LEAVE JUNK BEHIND
	LHL	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R4,		:MOVE BACKPRESSURE RESTRICTION COUNT
	NHI	R2,-4			:ISOLATE BUFFER INDEX FROM P.T. ENTRY
	XHI	R2,4			:BUFFER INDEX POINTS TO P.T. ENTRY
	LH	R0,BF,R2,
	JE	BUBL4			:BF ZERO
	AR	R0,R5			:RE-COMPUTE BF BASED ON NUMBER
	STH	R0,BF,R2,		:OF CHANNELS DIFFERENCE
	SHI	R0,LNKZFL		:CONSISTENCY CHECK TO INSURE BF POINTS
	SLLS	R0,1			:TO CHANNEL JUST MODIFIED
	CR	R0,R4
	JE	BUBL4			:POINTER CONSISTENT WITH NIOTAB INDEX
	CRASH.(.BUBCR)
:	PERMUTER TABLES MOVED...NOW COPY BIT ARRAYS
BUBL5	LH	R5,BUBS1		:GET BACK NUMBER OF LINK PRIOR TO BUBBL
	CLR	R5,KN			:BUBBLE DIRECTLY BEHIND CURRENT LINK?
	JE	BUBL9			:YES, NO TABLES MOVED,
					: SO NO BIT ARRAYS TO COPY
	LHL	R3,EBDPKN,R5,R5
	LHL	R4,TBDPKN+2,R5,R5
	LR	R1,R3			:RE-COMPUTE NUMBER OF TABLE BYTES MOVED
	LHL	R0,EBDPKN,KN,KN		:TO KNOW HOW MUCH OF BIT ARRAYS TO COPY
        SR      R1,R0
	SRLS	R3,4			:SET UP INDEX REGS
	SRLS	R4,4			: FOR COPYING BIT ARRAYS
BUBL6	SIS	R3,4
	SIS	R4,4			:DECREMENT FOR NEXT FULLWORD COPY
	SHI	R1,40			:20 CHANNELS/WORD * 2 BYTES/CHANNEL
	JLFS	BUBL7			:FINISHED BIT ARRAY COPY
	JAL	R2,BUBSUB		:COPY BIT VALUES TO NEW POSITION
	JBS	BUBL6
:	NOW UPDATE POINTERS FOR ALL LINKS WHICH HAD P.T. TABLES MOVED
BUBL7	L	R0,BUBS2		:BUBBLE SIZE
	LR	R1,R0
	SRLS	R1,1			:NUMBER OF CHANNELS MOVED
	LR	R3,R1
	SRLS	R3,3			:NUMBER OF CHANNELS/8 = BYTE
					: DISPLACEMENT FOR LINK BIT ARRAYS
	LHI	R4,1,KN			:LINK NUMBER OF LINK AFTER CURRENT LINK
BUBL8	AHM	R1,LKZFKN,R4,R4		:ADJUST ABS CHANNEL # WHERE LINK BEGINS
	AHM	R0,TBDPKN,R4,R4		:ADJUST ALL TABLE ADDRESS POINTERS BY
        LHL     R6,TBDPKN,R4,R4
	AHM	R3,FLDPKN,R4,R4		: ACTUAL BYTE DISPLACEMENT
	AHM	R0,EBDPKN,R4,R4
	LR	R2,R3			:ASSUME WE'RE SLAVE ON THIS LINK
	LB	R6,MASTKN,R4,		:0 IF SLAVE, 1 IF MASTER
	JEFS	BUBL8C			:SLAVE, ALLOCATE CHANS FROM BOTTOM UP
	LIS	R2,0			:MASTER.  WE USE NEGATIVE ACP, CHS,
	SR	R2,R3			: AND MUST ADJUST POINTERS IN NEGATIVE
					: DIRECTION, CHANNEL SCAN FROM TOP DOWN
BUBL8C	AHM	R2,LKAPND,R4,R4		:POINTER TO LAST HW IN ACP ARRAY
	AHM	R2,LKCSND,R4,R4		:POINTER TO LAST HW IN CHS ARRAY
	AIS	R4,1			:ANY MORE LINKS REQUIRE ADJUSTMENT?
	CLR	R4,R5
	JLE	BUBL8			:YES - CONTINUE

:	ALLOCATE BUBBLE TO CURRENT LINK'S (KN) DOMAIN
BUBL9	LHI	R0,80			:NUMBER OF CHANNELS PER HALF-PAGE
	AHM	R0,NCHN,KD
	LHI	R3,10			:BYTE DISPLACEMENT FOR CHAN BIT ARRAY
	AR	R0,R0
	AHM	R0,EBDPKN,KN,KN
	LB	R0,MASTKN,KN,		:ARE WE MASTER OR SLAVE ON THIS LINK?
	JNFS	BUBL9C			:MASTER
	AHM	R3,LKAPND,KN,KN		:SLAVE - ADJUST END POINTERS
	AHM	R3,LKCSND,KN,KN
BUBL9C	LH	R0,NUMPAG
	SIS	R0,1			:DECREMENT NUMBER OF AVAILABLE PAGES
	STH	R0,NUMPAG
	SIS	R0,2			:RUNNING LOW ON FREE HALF-PAGES?
	JGFS	BUBL10			:NO
	LHI	R0,1F-PGMSRK		:YES - SCHEDULE PROCESS TO SEE
	SBT	R0,SQUEUE		:IF ANY LINKS COULD USE SOME SHRINKING
:	NEW HALF-PAGE ALLOCATED TO LINK. INITIALIZE NIOTAB ENTRIES TO ZERO.
BUBL10	LIS	R0,0
	LHI	R1,40
	LHL	R2,EBDPKN,KN,KN		:END OF TABLES POINTER
BUBL11	ST	R0,NIOTAB-4,R2,		:ZERO PERMUTER TABLE ENTRY
	SIS	R2,4			:WORKING BACKWARDS THROUGH TABLE
	SIS	R1,1			:DONE?
	JGBS	BUBL11			:NO - CONTINUE
:	INITIALIZE FLAGS TO ZERO AND ACP, CHS (POSITIVE AND NEGATIVE) TO
:	ONES. CLEAR GUSH AND TRIKLE.
	LHL	R2,LKZFKN,KN,KN		:CHANNEL 0 FOR LINK (DISTANCE FROM ACP)
	AH	R2,NCHN,KD		:NEW NUMBER OF CHANNELS MINUS 80 POINTS
	SHI	R2,80			:TO NEWLY ACQUIRED HALF-PAGE
	SRLS	R2,3			:DIVIDE BITS/8 FOR BYTE DISPLACEMENT
	LCS	R3,4
	SR	R3,R2			:INDEX FOR NEGATIVE ACP, CHS
	LCS	R4,1
	LIS	R1,4			:HALF-PAGE BIT ARRAY IS 4 WORDS LONG
BUBL12	ST	R0,NFLAGS,R2
	ST	R0,GUSH-LNKZFL/8,R2,
	ST	R0,NEEDLE-LNKZFL/8,R2,
	ST	R0,PRIRTY,R2,
	ST	R0,CMDCTS-LNKZFL/8,R2,
	ST	R4,ACP,R2,
	ST	R4,CHS,R2,		:INDICATE THESE CHANNELS AVAILABLE
	ST	R4,ACP,R3,
	ST	R4,CHS,R3,
	SIS	R3,4
	AIS	R2,4
	SIS	R1,1
	JG	BUBL12
:	TABLES, ARRAYS, AND FLAGS FIXED. RE-COMPUTE CHANNEL MAP.
	LIS	R2,4			:START WITH 2ND ENTRY IN CHNMAP
	LHI	R1,(NLINKS-1)*2		:CHNMAP ORDERED FROM HIGHEST LINK
BUBLF	LHL	R0,LKZFKN,R1,		:GET ABS CHAN # FOR THIS LINK'S CHN 0
	STH	R0,CHNMAP,R2		:STORE IN CHANNEL MAP FOR PROBE TRACE
	AIS	R2,4
	SIS	R1,2
	JGEBS	BUBLF			:DO FOR ALL LINKS

	TBT	KN,ALINKS		:LINK JUST COMING UP?
	JE	4,R8			:YES, MAKE NO REPORT FOR INITIAL BUBBLE
	ST	R8,RTMT2		:SAVE LINK REGISTER FOR CALL TO SUP12
	LIS	R0,NR.BUB		:INDICATE TYPE OF REPORT 
	JAL	R10,SUP12L,,		:REPORT LINK BUBBLE TO SUPERVISOR LOG
	L	R8,RTMT2
	J	4,R8			:SKIP RETURN

:	FOUND A BUBBLE BEFORE CURRENT LINK
BUBL13	STH	R5,BUBS1		:SAVE NUMBER OF LINK PRIOR TO BUBBLE
	LHL	R3,TBDPKN+2,R5,R5	:FIRST HW AFTER BUBBLE
	LHL	R4,EBDPKN,R5,R5		:FIRST HW OF BUBBLE
	LR	R5,R4
	SR	R5,R3			:COMPUTE NEGATIVE BUBBLE SIZE
	ST	R5,BUBS2
	SRA	R5,1			:NEGATIVE NUMBER OF CHANNELS IN BUBBLE
	LHL	R1,EBDPKN,KN,KN		:# OF BYTES TO MOVE IS DIFF BETWEEN
	SR	R1,R3			: END OF CURRENT LINK'S TABLES (KN)
					: AND END OF BUBBLE
	STH	R1,BUBS3		:SAVE FOR INTERESTED OBSERVER

:	BUBS1 -	LINK NUMBER OF LINK PRIOR TO BUBBLE
:	BUBS2 -	NEGATIVE BUBBLE SIZE
:	R1 -	NUMBER OF BYTES TO MOVE
:	R3 -	POINTER TO END OF EXISTING BUBBLE
:	R4 -	POINTER TO BEGINNING OF EXISTING BUBBLE
:	R5 -	NEGATIVE NUMBER OF CHANNELS IN BUBBLE
	SIS	R3,2
	SIS	R4,2
:	MOVE TABLES INTO AREA WHICH IS CURRENTLY A BUBBLE. MEMORY WHICH IS
:	VACATED BY MOVE BECOMES NEW BUBBLE, DIRECTLY BEHIND CURRENT LINK.
BUBL14	AIS	R3,2
	AIS	R4,2
	SIS	R1,2			:MOVED ALL PERMUTER TABLE ENTRIES?
	JL	BUBL15			:YES

	LHL	R2,NIOTAB,R3,		:MOVING FROM RIGHT..
	STH	R2,NIOTAB,R4,		:..TO LEFT
	JEBS	BUBL14			:NULL P.T. ENTRY
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:CLEAN UP BEHIND US
	LH	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R4,		:MOVE BUFFER RESTRICTION COUNT
	NHI	R2,-4
	XHI	R2,4			:GET BF WHICH POINTS TO THIS P.T. ENTRY
	LH	R0,BF,R2,
	JE	BUBL14			:BF ZERO
	AR	R0,R5			:DECREMENT BF, P.T. ENTRY AT LOWER ADDR
	STH	R0,BF,R2,
	SHI	R0,LNKZFL		:TEST CHANNEL # AGAINST NIOTAB INDEX
	SLLS	R0,1
	CR	R0,R4			:INSURE POINTING TO PROPER IOTAB ENTRY
	JE	BUBL14			:O.K.
	CRASH.(.BUBC1)
:	PERMUTER TABLE ENTRIES MOVED...COPY BIT ARRAYS
BUBL15	LH	R5,BUBS1		:GET # OF LINK WHICH WAS BEFORE BUBBLE
	LHL	R3,TBDPKN+2,R5,R5	:SOURCE..
	LHL	R4,EBDPKN,R5,R5		:..DESTINATION
	LHL	R1,EBDPKN,KN,KN
	SR	R1,R3			:RE-COMPUTE NUMBER OF BYTES MOVED
	SRLS	R3,4
	SRLS	R4,4			:BIT ARRAY INDEX
	SIS	R3,4
	SIS	R4,4
BUBL16	AIS	R3,4
	AIS	R4,4			:INCREMENT FOR NEXT FULLWORD COPY
	SHI	R1,40
	JLFS	BUBL17			:FINISHED BIT ARRAY COPY
	JAL	R2,BUBSUB		:COPY BIT VALUES TO NEW POSITION
	JBS	BUBL16
:	NOW DECREMENT POINTERS FOR ALL LINKS WHICH HAD P.T. ENTRIES MOVED
BUBL17	L	R0,BUBS2		:NEGATIVE BUBBLE SIZE
	LR	R1,R0
	SRLS	R1,1			:NEGATIVE NUMBER OF CHANNELS
	LR	R3,R1
	SRLS	R3,3			:NUMBER OF CHANNELS/8 = BYTE
					: DISPLACEMENT FOR LINK BIT ARRAYS
	AIS	R5,1			:INCREMENT R5 TO FIRST LINK MOVED
BUBL18	AHM	R1,LKZFKN,R5,R5		:ADJUST ABS CHAN # WHERE LINK BEGINS
	AHM	R0,TBDPKN,R5,R5		:ADJUST ALL TABLE ADDRESS POINTERS BY
        LHL     R6,TBDPKN,R5,R5
	AHM	R3,FLDPKN,R5,R5		: ACTUAL BYTE DISPLACEMENT
	AHM	R0,EBDPKN,R5,R5
:	DECREMENTING POINTERS IS ACTUALLY MOVING THEM CLOSER TO ORIGIN. IF
:	WE ARE MASTER ON THIS LINK, ACP AND CHS POINTERS SHOULD BE INCREMENTED.
	LR	R2,R3			:ASSUME WE ARE SLAVE
	LB	R6,MASTKN,R5,		:ARE WE MASTER OR SLAVE?
	JEFS	BUB18C			:SLAVE
	LIS	R2,0			:MASTER - CHANGE DIRECTION OF
	SR	R2,R3			:POINTER UPDATE
BUB18C	AHM	R2,LKAPND,R5,R5		:POINTER TO LAST HW IN ACP FOR LINK
	AHM	R2,LKCSND,R5,R5		:POINTER TO LAST HW IN CHS FOR LINK
	AIS	R5,1			:DO FOR ALL LINKS WHICH GOT P.T. MOVED
	CLR	R5,KN
	JLE	BUBL18			:UP TO AND INCLUDING CURRENT LINK
	J	BUBL9

::*********************************************************************
::
::	SUBROUTINE:	BUBSUB:
::	FUNCTION:	COPY BIT ARRAYS
::	CALLING SEQ:	JAL	R2,BUBSUB
::
::*********************************************************************

BUBSUB	L	R0,GUSH,R3,
	ST	R0,GUSH,R4,		:COPY 'GUSH', R3 SOURCE, R4 DESTINATION
	L	R0,LNKFLG,R3,
	ST	R0,LNKFLG,R4,
	L	R0,LNKBPV,R3,
	ST	R0,LNKBPV,R4,
	L	R0,CHSRVD,R3,
	ST	R0,CHSRVD,R4,
	L	R0,BPSVCP,R3,
	ST	R0,BPSVCP,R4,
	L	R0,NEEDLE,R3,
	ST	R0,NEEDLE,R4,
	L	R0,PRIRTY+lnkzfl/8,R3,
	ST	R0,PRIRTY+lnkzfl/8,R4,
	L	R0,CMDCTS,R3,
	ST	R0,CMDCTS,R4,
	L	R0,LNKACP,R3,
	ST	R0,LNKACP,R4,
       if	aplybp
	L	R0,abpvcp,R3,
	ST	R0,abpvcp,R4,
	L	R0,abpxcp,R3,
	ST	R0,abpxcp,R4,
       ei	:aplybp
:	COPY 'NEGATIVE' ACP, CHS. USE R14, R15 AS INDEX REGS FOR OPPOSITE
:	POLARITY.
	STM	R14,LNKRGS		:PRESERVE REGS
	LCS	R14,4
	SR	R14,R3			:NEGATIVE SOURCE
	LCS	R15,4
	SR	R15,R4			:NEGATIVE DESTINATION
	L	R0,EKNACP,R14,
	ST	R0,EKNACP,R15,
	L	R0,EKNCHS,R14,
	ST	R0,EKNCHS,R15,
	LM	R14,LNKRGS
	JR	R2			:RETURN

	SUBTTL	UTIL (SHRINK)

::*********************************************************************
::
::	PROCESS:	MSHRNK:
::	FUNCTION:	SEE IF ANY LINKS NEED P.T. SHRINK
::	SCHEDULED:	Every 8 minutes.  Dismisses to EXEC loop.
::
::*********************************************************************

MSHRNK	lhl	r1,numpag
	sis	r1,2			:r1 =< 0 if shrinking due to no pages
	LHI	R9,4*(NLINKS-1)         :2 links means doing link 0 and link 1
MSHRN1	L	KD,KDKN,R9,
	LH	R0,SHSTAT,KD		:IS SHRINK IN PROGRESS?
	JN	MSHRN3			:YES - ONLY ONE AT A TIME
	LB	R0,NLAT,KD		:IS LINK UP?
	JE	MSHRN3			:NOT IF NO LINES ATTACHED
	LH	R0,NEDOUT,KD		:ARE ANY NEEDLES OUTSTANDING BETWEEN
					: CRQ AND RMAKE?
	JN	MSHRN3			:YES, AVOID POSSIBLE RACE, DEFER SHRINK
	l	r0,lkattr,kd		:does link not support shrinks?
	thi	r0,lk.shk
	JN	MSHRN3			:YES, do not SHRINK on this link
	
:	SEE IF ENOUGH INACTIVE CHANNELS TO CALL FOR SHRINK.
:	IF 4*(# INACTIVE CHANNELS) >= (MAX # CHANNELS)+600,
:	THEN REQUEST A SHRINK FOR THIS LINK
:	formula modified to add number of channels suspended at time of link
:	bubble.  this is to prevent situations of lots of short sessions
:	in which links bubbled due to a few active chns but many suspended
:	chns and then link shrink would occur next time shrink ran (few
:	active chns) and then pretty quickly bubble again due to a buildup
:	of suspended chns.  idea is to count suspended chns when doing a
:	bubble and unless shrinking due to a lack of pages, to add the 
:	suspended chns to the active chns which makes it hard to shrink on
:	links which had many suspended chns when it bubbled.  the count of
:	suspended chn is then reduced by 1/16 each time through shrink so
:	that eventually link will be shrunk.
	LH	R0,NCHN,KD		:3*NCHN-4*ANCHN-600
	CLHI	R0,80
	JLE	MSHRN3			:DON'T CONSIDER LINK WITH ONLY 80 CHANS
	SH	R0,ANCHN,KD
	lr	r1,r1			:shrinking due to a lack of pages?
	jlefs	mshrn2
	sh	r0,suschn,kd		:#of suspended chns
	jlefs	mshrn3			:could wrap to negative free chns
mshrn2	SLLS	R0,2
	SH	R0,NCHN,KD
	SHI	R0,$A 600
	JLFS	MSHRN3
	LIS	R0,2			:LOTS OF SPARE CHANNELS...
	STB	R0,SHSTAT,KD		:DO A SHRINK
MSHRN3	lh	r0,suschn,kd		:reduce by 1/16th regardless
	lr	r1,r0
	xhi	r1,-1			:this makes r1 =-1 if r0 <16
	srls	r1,4
	ar	r0,r1
	lhr	r0,r0			:extend sign bit in case went neg
	jgefs	mshrn4
	lis	r0,0
mshrn4	sth	r0,suschn,kd
	SIS	R9,4
	JGE	MSHRN1			:CHECK ALL LINKS
	J	EXDISM,,		:DONE

::*********************************************************************
::
::	SUBROUTINE:	cntsus:
::	FUNCTION:	counts the number of suspended chns and saves it
::	CALLING SEQ:	JAL	R8,cntsus
::	INPUT:		KD  = link descriptor to count suspended chns
::	OUTPUT:		stores value into suschn,kd
::	PRESERVED:	
::
::*********************************************************************

cntsus	LIS	R3,0			:Init count
	LHL	R4,NCHN,KD		:# channels allocated to this link
	JE	susch8			:none
	SRLS	R4,3			:number of bytes of bits to check
	lb	KN,lknm,KD
	LHL	R5,FLDPKN,KN,KN		:beginning of link's bit arrays
susch1	LH	R0,lnkchs,R5,		:count suspended circuits
	XHI	R0,-1	  		:bits now 1 if suspended
susch2	JFFOH	R0,susch4
	AIS	R5,2	  		:next HW
	SIS	R4,2	  		:reach end yet?
	JGEBS	susch1	 		:do another pair of bytes       ###sdw
	Jfs	susch8	 		:counted them all
susch4	AIS	R3,1	  		:found a set bit
:       R1 now has bit # of set bit (0-F), shift this bit off our hw    ###sdw
	SLL	R0,1,R1			:R1 is one less than needed     ###sdw
	JBS	susch2
susch8	sth	r3,suschn,kd
	jr	r8			:exit

	SUBTTL	UTIL (FIND)

::*********************************************************************
::
::	SUBROUTINE:	FNDHST:
::	FUNCTION:	LOCATES A HOST IN THE HOST TABLES.
::	CALLING SEQ:	JAL	R9,FNDHST
::	INPUT:		R1  = HOST NUMBER
::	OUTPUT:		R13 = HN = HOST INDEX
::	PRESERVED:	R1
::	RETURNS:	IMMEDIATE = NONEXISTENT HOST
::			+4 = HOST FOUND
::
::*********************************************************************

FNDHSL	LIS	R1,0			:>>ENTER HERE TO FIND NEXT FREE ENTRY<<
FNDHST	LHI	HN,NHOSTS-1		:>>ENTER HERE TO FIND A GIVEN HOST<<
FNDHS1	CLH	R1,HOSTN,HN,HN
	JE	4,R9			:FOUND IT, SKIP 4 BYTES
	SIS	HN,1
	JGEBS	FNDHS1
        LR      HN,R1   	        :RESTORE HOST NUMBER AND EXIT  ###LH
	SKIP(0,R9)			:immediate ret, NONEXISTENT HOST##wjl

::*********************************************************************
::
::	SUBROUTINE:	FNDLNK:
::	FUNCTION:	LOCATES THE LINK DESCRIPTOR TO A GIVEN NEIGHBOR.
::			SETS REGISTERS 'KN' AND 'KD' TO THE APPROPRIATE VALUES.
::	CALLING SEQ:	JAL	R9,FNDLNK
::	INPUT:		R1 = NEIGHBOR # (PRESERVED)
::	RETURNS:	SKIP RETURN IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::
::*********************************************************************

FNDLNZ	LIS	R1,0			:>>ENTER HERE TO FIND NEXT FREE ENTRY<<
:	>>ENTER HERE TO FIND A GIVEN LINK D.<<
FNDLNK	LHI	KN,2*(NLINKS-1)		:HIGHEST LINK #
FNDLN1	L	KD,KDKN,KN,KN		:LINK DESCRIPTOR FOR THIS LINK
	CLH	R1,NDID,KD
	JNFS	FNDLN2			:no match, check next link
	SRLS	KN,1			:return with link number
	J	4,R9			:FOUND IT, SKIP 4 BYTES
FNDLN2	SIS	KN,2
	JGEBS	FNDLN1
	SKIP(0,R9)			:NONEXISTENT LINK, TAKE IMMED RETURN

::*********************************************************************
::
::	SUBROUTINE:	FCHLNK:
::	FUNCTION:	LOCATES THE LINK NUMBER TO THE ABSOLUTE CHAN#
::	CALLING SEQ:	JAL	R9,FCHLNK
::	INPUT:		R3 = ABSOLUTE CHAN NUMBER
::	DESTROYED:	R0,R1
::	RETURNS:	SKIP RETURN IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::	OUTPUT:		R0 IS THE LINK#
::
::*********************************************************************

      IF	T2GATE		:T-II Gateway only			###wjl
      IF	IRC		:International record Carrier only	###wjl
FCHLNK	LIS	R0,0		:INIT LINK# 0
	CLH	R3,LKZFKN,,	:TABLE OF ABSOLUTE CHAN# FOR 1ST CHANS
	JL	FCHEXI		:ERR RETURN IF <LNKZFL			###wjl
	CHI	R3,LNKLFL	:MAX CHAN#
	JGFS	FCHEXI		:ERR RETURN IF >LNKLFL			###wjl
	LIS	R1,2		:LINK PTR. TO LKZFKN TABLE
FCK01	CLH	R3,LKZFKN,R1,
	JL	4,R9		:WE GOT IT, GOOD RETURN
	CI	R1,2*TCHANS	:MAX. PTR.
	JE	4,R9		:END OF LAST CHAN#
	AIS	R0,1		:INC. LINK#
	AIS	R1,2		:INC. PTR.
	JBS	FCK01		:TRY NEXT ONE

FCHEXI	SKIP(0,R9)		:immediate return			###wjl
      EI	:IRC
      EI	:T2GATE

::*********************************************************************
::
::      SUBROUTINE:  CHFLNK
::      FUNCTION:    finds the link (returned in r3) from chn (in r5)
::      RETURN:      Links on R8, normal return if can't find neighbor
::                   for chn, +4 is chn is internal, +8 if link chn.
::
:	Fix crash 0007 from corrupted Qexec entry 11x, caused by
:	non-Xray process CRQZOG (needle-point killed by an 03-xx
:	char pair, usually a hard zapper) as follows:
:	  Calling Xray routine CHNLNK/XFNDLK which expects R15 to
:	  be Xray user block for data storage, resulting in random
:	  memory corruption.
:	Also fixed:
:	  CRQZOG does not establish the channel register.
:	  Non-Xray LEP9V1 (T-I early zapper) calls Xray CHNLNK/XFDNLK.
:	  Use own node# on internal termination return from CHNLNK/
:	  XFNDLK (wasn't carried forward from v5.06 patch).
:
::*****************************************************************

CHFLNK	LHL	CHN,BF,R2,		:Get channel# from buffer BF
CHFLN1	LCS	R3,4			:Initial index to CHNMAP
CHFLN2	AIS	R3,4			:Bump to next entry
	CLH	CHN,CHNMAP,R3		:Q.Less than beginning channel
	JLBS	CHFLN2			:Y.Look at next entry
	LHL	R3,CHNMAP+2,R3		:Right chnl range, get data
	THI	R3,8000			:Q.HOB for internal term.
	JN	CHFLN7			:Y.Return as internal term.
	LHL	R3,CHNMPD,R3		:Get link data
	THI	R3,8000			:Q.HOB for T-I neighbor
	JEFS	CHFLN3			:N.Go verify that T-II is up
	NHI	R3,3FFF			:Clear HOB for T-I
	J	8,R8			:Return as found neighbor
CHFLN3	LHI	R1,2*(NLINKS-1)		:Index for links
CHFLN4	LHL	R9,KDKN,R1,		:Get link descriptor
	CLH	R3,NDID,R9		:Q.Neighbor found
	JEFS	CHFLN5			:Y.Return as found neighbor
	SIS	R1,2			:Q.More to check
	JGEBS	CHFLN4			:Y.Go check next entry
	LBR	R1,R0			:Restore R1
	J	CHFLN6			:Return as no neighbor
CHFLN5	LBR	R1,R0			:Restore R1
	J	8,R8			:Return as found neighbor

CHFLN6  SKIP(0,R8)                      :no neighbor at all
CHFLN7  SKIP(4,R8)                      :found internal


::*********************************************************************
::
::	SUBROUTINE:	FNDCRQ:
::	FUNCTION:	LOCATES A GIVEN CIRCUIT FOR CRQ/LEP.
::	CALLING SEQ:	JAL	R9,FNDCRQ
::	OUTPUT:
::		IF INVOICE NUMBER FOUND:
::			R6 = OUTBOUND BUFF #
::			R7 = HISTORY BUFFER #
::		IF INVOICE NUMBER NOT FOUND, R0 = 0
::		IF INVOICE NUMBER FOUND BUT BF ISN'T A STUB, R0 = -1
::	DESTROYED:	R0, R1
::	RETURNS:	IMMEDIATE RETURN IF BUFFER NOT FOUND
::			+4 SKIP RETURN IF A MATCH IS FOUND
::
::*********************************************************************

:	FNDCRQ STEPS THROUGH ALL HISTORY BUFFER NUMBERS, BEGINNING AT HBUFN,
:	LOOKING FOR A BUFFER WHOSE INVOICE NUMBER MATCHES CQINV AND WHOSE
:	BF IS A STUB. SKIP RETURNS IF A MATCH IS FOUND, ELSE IMMEDIATE RETURN

	IF	REBILD
FNDCRQ	L	R1,CQINV		:SEARCH ON INVOICE #
	LIS	R0,0			:SET R0=0, INDICATE INVOICE # NOT FOUND
	LI	R7,LBUFN-HBUFN-4	:START AT LAST HISTORY BUFFER
FNDCR1	CL	R1,RINVC+HBUFN,R7,	:DOES IT'S INVOICE NUMBER MATCH CQINV?
	JEFS	FNDCR2			:YES, POSSIBLE MATCH
	SIS	R7,4			:NO, ADVANCE TO NEXT BUFFER
	JGEBS	FNDCR1			:KEEP LOOKING IF MORE LEFT
	SKIP(0,R9)			:AT END OF HISTORY BUFFERS, NO MATCH.
					: RETURN
FNDCR2	LCS	R0,1			:SET R0= -1 TO INDICATE INVOICE # FOUND
	LR	R6,R7			:COMPUTE OUTBOUND BUFF #
	AI	R7,HBUFN		:AND THE ABSOLUTE HISTORY BUFFER NUMBER
	SLHLS	R6,1
	LHL	R1,BF,R6,		:CHECK FOR STUB AT THE OTHER END
	CLHI	R1,STUBFL
	JE	4,R9			:YES, THIS IS A GOOD STUB... RETURN
	AIS	R6,4			:NO, ARE WE LOOKING AT WRONG SIDE...
	LHL	R1,BF,R6,
	CLHI	R1,STUBFL
	JE	4,R9			:FOUND THE STUB, RETURN
	SKIP(0,R9)			:CAN'T FIND A STUB, RETURN WITH R0= -1
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	FNDCHN:
::	FUNCTION:	LOCATES A FREE PORT
::	CALLING SEQ:	JAL	R9,FNDCHN
::	INPUT:		R5 = INITIAL CHANNEL # (CHN)
::			R1 = # OF CHANNELS TO SEARCH
::	DETROYED:	R0
::	RETURNS:	SKIPS IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::
::*********************************************************************
fagain	ais	CHN,1	
FNDCHN	LHL	R0,IOTAB,CHN,CHN	:IS THIS CHANNEL FREE?
	Jefs	FNDCH2			:yes
	AIS	CHN,1
	SIS	R1,1
	JGbs	FNDCHN
	SKIP(0,R9)			:immed ret - NO FREE PORT FOUND	###wjl

FNDCH2	TBT	CHN,ACP,,		:YES - ACP SHOULD BE CONSISTENT
	JEfs	FNDCRS			:ACP INDICATES CHANNEL NOT AVAILABLE,
					: - OOOPS!
	LCS	R0,1			:CHECK NEGATIVE ACP ARRAY
	SR	R0,CHN
	TBT	R0,ACP,,
	Jnfs	FNDch0			:WHY IS CHANNEL NOT AVAILABLE??
FNDCRS	CRASH.(.FNCHC)
fndch0	LR	R0,R2
	LHI	R2,-DISZFL,CHN		:CHECK IF DISPATCHER PORT
	JGEFS	FNDCH1			:YES - CHECK ISIS
	LR	R2,R0
	J	4,R9			:NO - RETURN
FNDCH1	LHL	R2,PTABLE,R2,R2,	:CHECK ISIS PERMUTER TABLE
	JNFS	FNDCH9			:ISIS INDICATES CHANNEL IN USE
	LR	R2,R0			:PRESERVE R2
	J	4,R9			:TAKE OK RETURN
:	isis dispatcher according to seg e says port is in use and nc has
:	cleared it.  unclear if it is an isis bug or just undocumented
:	behaivor that eventually corrects itself.  if not debugging then
:	just use next port and if debugging then crash if port wasn't
:	recently zapped.
FNDCH9
       if	db.chn
	tbt	chn,chs,,		:if was just zapped then give isis
	je	fagain			:time to clear it so just try next chn
	CRASH.(.FNCH1)			:node code must have messed it up
       else	:not debugging so use next free port
	j	fagain			:continue search for a free port
       ei

::*********************************************************************
::
::	SUBROUTINE:	FNDKNC:
::	FUNCTION:	FIND CHANNEL FOR LINK.
::	CALLING SEQ:	JAL	R9,FNDKNC
::	RETURNS:	IMMEDIATE = NO CHANNEL FOUND
::			+4 = CHANNEL FOUND
::
::*********************************************************************

:	CHANNEL IS AVAILABLE IF ACP .AND. CHS ARE SET. ARRAYAND
:	INSTRUCTION IS USED TO SCAN ACP AND CHS BIT ARRAYS.
:	EACH LINK PROVIDES POINTER TO LAST HALFWORD IN ARRAY. NCHN (NUMBER OF
:	CHANNELS ALLOCATED TO LINK) PROVIDES THE BIT COUNT FOR THE ARRAYAND.
:	THE BYTE ARRAY MASTKN INDICATES WHETHER WE ARE MASTER OR SLAVE ON THIS
:	LINK. IF WE ARE SLAVE, POINTERS DIRECT US TO THE 'POSITIVE' ACP AND CHS
:	WHERE WE SCAN FROM THE BOTTOM UP. IF WE ARE MASTER, POINTERS ARE TO
:	'NEGATIVE' ACP AND CHS, AND WE SCAN FROM THE TOP DOWN WITH REGARD TO
:	CHANNEL NUMBERS.

FNDKNC	STM	R14,LNKRGS		:SAVE WORK REGS
	LHL	R14,LKAPND,KN,KN	:LAST HW IN ACP ARRAY
	LHL	R15,LKCSND,KN,KN	:LAST HW IN CHS ARRAY

	SIS	R1,1			:NUMBER OF CHANNELS MINUS 1
	ARAND	R14,R1			:ARRAYAND, POINTERS IN R14, R15,
					: COUNT IN R1
	JFS	FNDC10			:GOT A HIT
	J	FNDC40			:NO CHANNELS AVAILABLE
FNDC10	LM	R14,LNKRGS		:RESTORE REGISTERS.
	LB	R0,MASTKN,KN,		:ARE WE THE MASTER ON THIS LINK?
	JNFS	FNDC20			:YES
	LR	CHN,R1			:NO, SINCE WE WORK FROM BOTTOM UP,
	JFS	FNDC30			: R1 HAS LINK RELATIVE CHANNEL NUMBER
FNDC20	LHL	CHN,NCHN,KD		:NUMBER OF CHANNELS ALLOCATED TO LINK
	SIS	CHN,1			:CHN HAS HIGHEST ALLOCATD CHAN FOR LINK
	SR	CHN,R1			:HIGHEST AVAILABLE CHANNEL
FNDC30	AH	CHN,LKZFKN,KN,KN	:CONVERT TO ABSOLUTE CHANNEL
	LH	R0,IOTAB,CHN,CHN	:IS CHANNEL REALLY FREE?
	JE	4,R9			:YES - SKIP RETURN
	CRASH.(.FNCH0)
FNDC40	LM	R14,LNKRGS		:RESTORE REGS
	SKIP(0,R9)			:NORMAL RETURN FOR NO CHANNEL FOUND


::*********************************************************************
::
::	SUBROUTINE:	CNTPRT	(CouNT PoRT)
::	FUNCTION:	Counts number of available ports in a port range
::	CALLING SEQ:	JAL	R10,CNTPRT
::	INPUT:		R5	=	Beginning of range
::			R1	=	Number of ports to consider
::	OUTPUT:		R3	=	Number of available ports
::	RETURNS:	JR	R10
::
::*********************************************************************

CNTPRT	LIS	R3,0			:Intitialize counter
CNT00	LHL	R0,IOTAB,CHN,CHN	:Check table entry
	JNFS	CNT01			:If not empty, don't count
	AIS	R3,1			:Else equal to zero - available
CNT01	AIS	CHN,1			:Next channel
	SIS	R1,1			:Done yet?
	JGBS	CNT00			:Check again
	JR	R10			:RETURN


	SUBTTL	UTIL (ACCOUNTING)
::*********************************************************************
::
::	SUBROUTINE:	SUPINV:
::	FUNCTION:	Handles sending to sup upto 32 bits of invoice number
::	CALLING SEQ:	JAL  R10,SUPINV
::	INPUT:		R1 invoice number
::	DESTROYED:	
::	CALLS:		jal	r10,SUP14A
::
::*********************************************************************

SUPINV	ti	r1,0FF00^10	:test and see if it has more than 24 bits?
	jnfs	supin2
	oi	r1,07000^10	:make into send invoice number
	j	sup14a,,	:let sup14a return

supin2	st	r1,actsv2	:save invoice number
	st	r10,actsv1	:save link reg
	ni	r1,00FFFFFF	:isolate lower 24 bitss
	oi	r1,7E00^10
	jal	r10,sup14a,,
	lb	r1,actsv2	:get high 8 bits of inv
	oi	r1,7F00^10
	l	r10,actsv1	:restore link reg
	j	sup14a,,	:let it return to caller


	IF	ACCT

::*********************************************************************
::
::	SUBROUTINE:	AASTRT:
::	FUNCTION:	Initiates session accounting - puts invoice 
::			number in circuit accounting block - puts
::			zeroes in count fields.
::	CALLING SEQ:	JAL  R8,AASTRT
::	INPUT:		CHN = terminating channel number
::	DESTROYED:	R3, R11, R0
::	CALLS:		macro aamkpt	:Make pointer to accounting block
::
::*********************************************************************

AASTRT	LR	R3,CHN		:Terminating channel # (CHN is R5)
	CLHI	R3,MNACHN	:Compare with  lowest accountable chn#
	JLfs	AASER1		:If lower, is channel error
	CLHI	R3,MXACHN	:Compare with max  accountable channel
	JLfs	AASPR1		:If within, process!
AASER1	JR	R8		:Posssibly add some error stuff  ###ev

AASPR1	SHI	R3,MNACHN	:Make accounting port index from chn #
	rbt	r3,aaorig	:it is a destination so send cnts
	aamkpt(r3)		:Get FW pointer to circuit's block
:	Entry point for Gateway start
GASTR1	LIS	R0,0
	ST	R0,AAICMS,R11	:Init to zeroes
	ST	R0,AAOCMS,R11	:Init to zeroes
	STH	R0,AAOCLS,R11
	STH	R0,AAICLS,R11
	L	R0,CQINV
	ST	R0,AAINV,R11	:Store Invoice number
	JR	R8		:###wjl

::*********************************************************************
::
::	SUBROUTINE:	aamkpt
::	FUNCTION:	Gets a fullword pointer to the accounting block
::			from the array of pointers AABPNT.
::	CALLING SEQ:	JAL	R9,aamkpt
::	INPUT:		R3 = Terminating port index
::	OUTPUT:		R11 = Fullword pointer to accounting block
::	DESTROYED:	R3
::	RETURNS:	JR	R9
::*********************************************************************
:	obsoleted as now just a macro
:
:aamkpt	lr	r11,r3		:table are by fullword
:	SLLS	R11,2		:Make fullword index
:	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	AARDIC:
::	FUNCTION:	Receive an incremental data count into a
::			host process and accumulate it in the AAIC field
::			for that circuit's accounting block.
::	CALLING SEQ:	JAL	R8,AARDIC
::	INPUT:		R0 =  Count to accumulate in AARDIC
::			R3 =  Internal host port index
::	DESTROYED:	R0, R3, R9, R11
::	CALLS:		macro aamkpt
::	RETURNS:	JR	R8
::
::*********************************************************************

AARDI1	LIS	R0,1		:Entry point for adding only one char
AARDIC	AAMKPT(R3)		:Get FW pointer to circuit's block
	AHM	R0,AAICLS,R11	:Add to count
	JNCR	R8		:didn't wrap
	LIS	R0,1		:wrapped so add to MSF field
	AM	R0,AAICMS,R11	:Add to count of MSF 32 bits
	JR	R8		:And return

::*********************************************************************
::
::	SUBROUTINE:	AARDOC:
::	FUNCTION:	Receive an incremental data count out of a
::			host process and accumulate it in the AAOC field
::			for that circuit's accounting block.
::	CALLING SEQ:	JAL	R8,AARDOC
::	INPUT:		R0 =  Count to accumulate in AARDOC
::			R3 =  Port index
::	DESTROYED:	R0, R3, R9, R11
::	CALLS:		macro aamkpt
::	RETURNS:	JR	R8
::
::*********************************************************************

AARDO1	LIS	R0,1		:Entry point for adding only one char
AARDOC	AAMKPT(R3)		:Get FW pointer to circuit's block
	AHM	R0,AAOCLS,R11	:Add to LSF count
	JNCR	R8		:didn't wrap
	LIS	R0,1		:add in a wrap
	AM	R0,AAOCMS,R11	:Add to MSF count
	JR	R8		:And return

::**********************************************************************
::
::	SUBROUTINE:	AANCZP:
::	FUNCTION:	Receives Node Code Zap reason and sends it.
::	CALLING SEQ:	JAL	R8,AANCZP
::	INPUT:		R1 = Invoice number from CQINV
::			R0 = Logout reason, for Addendum message
::	CALLS:		macro aamkpt	:Make pointer to acct. blk
::			JAL	R9,AAPIR	:Provides and sends inv #
::			JAL	R9,AADNDM	:Sends Addendum to accounting
::	RETURNS:	JR	R8
::
::*********************************************************************

AANCZP	STM	R1,AARGSV	:Save registers here
	ST	R0,AAREAS	:Save logout reason for AADNDM
	JAL	R9,AAPIR	:Provides and sends invoice number
	L	R0,AAREAS	:Get logout reason for Adendum message
	JAL	R9,AADNDM	:Sends Addendum to accounting
	LM	R1,AARGSV	:Restore registers here
	JR	R8

::**********************************************************************
::
::	SUBROUTINE:	AARLO:
::	FUNCTION:	Receives logout reason and sends final counts.
::	CALLING SEQ:	JAL	R8,AARLO
::	INPUT:		R3 = Internal host port index
::			R0 = Logout reason, for Addendum message
::	CALLS:		macro aamkpt	:Make pointer to acct. blk
::			JAL	R9,AstIR	:Sends invoice number
::			JAL	R9,AACNTS	:Sends input and output counts
::			JAL	R9,AADNDM	:Sends Addendum to accounting
::	RETURNS:	JR	R8
::
::*********************************************************************

AARLO	STM	R1,AARGSV	:Save registers here
	ST	R0,AAREAS	:Save logout reason for AADNDM
	aamkpt(r3)		:Get FW pointer to circuit's block
	JAL	R9,AstIR	:Sends invoice number
	skipad(aarlo9)		:no invoice number so exit
	JAL	R9,AACNTS	:Sends input and output counts
	LIS	R0,0		:Now to reset inv # area
	ST	R0,AAINV,R11
	L	R0,AAREAS	:Get logout reason for Adendum message
	JAL	R9,AADNDM	:Sends Addendum to accounting
	LM	R1,AARGSV	:Restore registers here
aarlo9	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	AstIR
::	FUNCTION:	Makes an Invoice record and sends it if necessary
::	CALLING SEQ:	JAL	R9,AstIR
::			JAL	R9,AAPIR	: Entry for Inv # provided
::	INPUT:		R11 = Pointer to circuit's Accounting block
::			or    R1 = Invoice number from CRQ routine
::	CALLS:		JAL	R10,SUP14A
::	RETURNS:	JR	R9	:Normal return
::			JE	R8	:ERROR -- skip accounting if
::					 inv # is zero
::
::*********************************************************************

AstIR	L	R1,AAINV,R11	:Get invoice number
        JNFS    AAPIR           :okay, do accouting
	skip(0,r9)
:	no need to worry about sending an unneeded invoice number since
:	sup14a filters invoice number automatically.
AAPIR	ST	R9,AAR1SV	:Save return address
	JAL	R10,supinv	:to send invoice to Supervisor
	L	R9,AAR1SV	:Restore return address
	J	4,R9		:  .. and return

::*********************************************************************
::
::	SUBROUTINE:	AACNTS:
::	FUNCTION:	Gets input and output counts and sends to Sup
::	CALLING SEQ:	JAL	R9,AACNTS
::	INPUT:		R11 = Pointer to circuit's accounting block
::	CALLS:		JAL	R10,SUP14A
::	RETURNS:	JR	R9
::
::*********************************************************************

AACNTS	ST	R9,AAR1SV	:Save return register
	L	R1,AAICMS,R11	:get MSF
	EXHR	R1,R1		:move low 8 bits to high HW
	TI	R1,0FF00FFFF	:need to send multiple precision?
	JNFS	AACNT1
:	single precision
	LHL	R10,AAICLS,R11	:combine with 16 bits of LSF
	OI	R1,80^18,R10	:formulate message
	J	AACNT2		:send it

:	multiple precision
AACNT1	NI	R1,0FF^10	:leave only bits 16-24 of LSF
	LHL	R10,AAICLS,R11	:combine with 16 bits of LSF
	OI	R1,8E^18,R10	:formulate message
	JAL	R10,SUP14A,,	:and send to Sup 
	L	R1,AAICMS,R11	:get MSF 32 bits
	SRLS	R1,8		:reduce to MSF 24 bits
	OI	R1,8F^18	:formulate message
AACNT2	JAL	R10,SUP14A,,	:and send to Sup 

:	did Input char count.  now do Output char count
	L	R1,AAOCMS,R11	:get MSF
	EXHR	R1,R1		:move low 8 bits to high HW
	TI	R1,0FF00FFFF	:need to send multiple precision?
	JNFS	AACNT4
:	single precision
	LHL	R10,AAOCLS,R11	:combine with 16 bits of LSF
	OI	R1,90^18,R10	:formulate message
	J	AACNT5		:send it

:	multiple precision
AACNT4	NI	R1,0FF^10	:leave only bits 16-24 of LSF
	LHL	R10,AAOCLS,R11	:combine with 16 bits of LSF
	OI	R1,9E^18,R10	:formulate message
	JAL	R10,SUP14A,,	:and send to Sup 
	L	R1,AAOCMS,R11	:get MSF 32 bits
	SRLS	R1,8		:reduce to MSF 24 bits
	OI	R1,9F^18	:formulate message
AACNT5	JAL	R10,SUP14A,,	:and send to Sup 

	L	R9,AAR1SV	:Restore return register
	JR	R9		:and return


::*********************************************************************
::
::	SUBROUTINE:	AADNDM:
::	FUNCTION:	Sends Addendum to Accounting message
::	CALLING SEQ:	JAL	R9,AADNDM
::	INPUT:		R0 = logout reason for Addendum message
::			R11= pointer to crcuit's accounting block
::	CALLS:		JAL	R10,SUP14A,,
::	RETURNS:	JR	R9
::
::*********************************************************************

AADNDM	ST	R9,AAR1SV	:Save return address
	LI	R1,0E0000000	:Load Addendum message type 
	OR	R1,R0		:Put in logout reason
	NI	R1,0F0FFFFFF	:Ensure Addendum subtype zero
	JAL	R10,SUP14A,,	:Send to Sup
	L	R9,AAR1SV	:Restore return
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	AATIME:
::	FUNCTION:	Provides periodic reporting of accounting
::	CALLING SEQ:	JAL	R11,AATIME,,
::	CALLS:		macro aamkpt
::			JAL	R9,AAPIR
::			JAL	R9,AACNTS
::	RETURNS:	JR	R11
::
::*********************************************************************

AATIME	ST	R11,AAR2SV		:Save return
	LHI	R3,NACCTS-1		:R3 used for  port index
AATM01	ST	R3,AASVCT		:Got to save R3
	tbt	r3,aaorig		:is it an origination port?
	JNfs	AATM02			:If so, skip reporting
	aamkpt(r3)			:Get FW pointer to circuit's block
	L	R1,AAINV,R11		:Check inv # - see if active	
	JEFS	AATM02			:If inactive go to next port
	JAL	R9,AAPIR		:Else make invoice record
	JAL	R9,AACNTS		:  ... and send counts
AATM02	L	R3,AASVCT		:What was that count of ports?
	SIS	R3,1			:Decrement counter to nxt port ndx
	JGE	AATM01			:Repeat until port 0 completed
	L	R11,AAR2SV		:Restore return
	JR	R11

::*********************************************************************
::
::	SUBROUTINE:	AASWAP:
::	FUNCTION:	Swaps invoice numbers between networks
::	CALLING SEQ:	JAL	R10,AASWAP,,
::	INPUT:		CHN	=  Relative Dispatcher port to send
::			ININV	=  Invoice number from INET
::	CALLS:	AstIR,SUP14A,DIZSMS
::	DESTROYED:	R8,R9,R1,R3,R4
::	RETURNS:
::
::*********************************************************************

	IF	T2GATE

AASWAP	ST	R10,AAR2SV		:SAVE RETURN
        STH     CHN,GB7PRT		:SAVE CHN

:	SEND DATA TO HNET, first is LSF
	JAL	R9,AstIR		:SEND INVOICE RECORD
	skipad(aaswa9)			:no invoice number so exit
	L	R1,ININV		:GET PRIMARY INVOICE#
	ni	r1,000FFFFFF		:mask off MSF 8 bits (if present)
	OI	R1,0E9000000		:ADD ACCT MSG TYPE
	JAL	R10,SUP14A,,		:Send to HNET sup
:	next send MSF if needed
	LB	R1,ININV		:get MSF 8 bits (if 32 bits invoice)
	JEFS	AASWA2			:not there so no send MSF msg
	OI	R1,0EB000000		:ADD ACCT MSG TYPE
	JAL	R10,SUP14A,,		:Send to HNET sup

:	NOW SEND DATA TO INET, first send LSF
AASWA2	LHL	CHN,GB7PRT		:for insertion into message
	L	R4,AAINV,R11		:GET SECONDARY NET INVOICE#
	OI	R4,0E9000000		:ADD MSG TYPE
	ST	R4,GB7INV		:STORE IN CANNED MSG
	LA	R1,GDB7M		:ADDR OF CANNED MSG
	LHI	R3,GDB7L
	JAL	R8,DIZSMS,,		:Output to dispatcher
:	next send MSF if present
	LB	R4,AAINV,R11		:GET MSF 8 bits for SECONDARY NET INVOICE
	JEFS	AASWA9			:send MSF if nonzero
	OI	R4,0EB000000		:ADD ACCT MSG TYPE
	ST	R4,GB7INV		:STORE IN CANNED MSG
	LA	R1,GDB7M		:ADDR OF CANNED MSG
	LHI	R3,GDB7L
	JAL	R8,DIZSMS,,		:Output to dispatcher
aaswa9	L	R10,AAR2SV		:RESTORE RETURN
	JR	R10			:RETURN
	EI	:T2GATE	

        ELSE    :not ACCT

:       Gateway has numerous calls to accounting not under the ACCT switch.
:       provide a null routine to prevent assembly errors               ###sdw
aardoc
AARLO
AARDIC  JR      R8                      :nothing to do when no accouting

	EI	:ACCT

        SUBTTL X.409 UTILITY ROUTINES
       IF       LOGII

::*****************************************************************
::
::      X4GTLN  Get x.409 length.  Return it in R0.  caller should
::              make sure R3 points to a length field.  
::
::              Links on R9.  Calls IGPCIE.
::
::*****************************************************************

X4GTLN  ST      R9,GTLNSV               :save link reg
        LIS     R0,0                    :clear it for ORing
X4GTL0  JAL     R9,IGPCIE,,             :get first byte of len
        CLHI    R1,MO.LFM+1             :more to follow?
        JLFS    X4GTL2                  :done (have len byte)
        JEFS    X4GTL1                  :short form (just a byte of length)
        JAL     R9,IGPCIE,,             :do two len bytes
        EXBR    R0,R1                   :move len to high byte
X4GTL1  JAL     R9,IGPCIE,,             :last byte of len
X4GTL2  OR      R0,R1                   :make it len field
        L       R9,GTLNSV
        JR      R9



::***************************************************
:
:       X4WTEL  writes element pointed to by R6 from the parse table
:               to buffer in R2.  Links on R7.
::***************************************************

X4WTEL  ST      R7,X4WTSV               :save link register
        LB      R1,X4T.ID,R6            :get ID
        LB      R0,X4T.AP,R6            :get application/constructor bits
        CLHI    R1,IDBITS               :one or two byte header
        JLFS    X4WTE2
        EXBR    R0,R0                   :move bits to high byte
        AHI     R0,IDBITS^8             :add in two byte indicator
        AR      R1,R0                   :add to ID
        JAL     R9,W2CI,,
        AIS     R10,2                   :count of written chars
        JFS     X4WTE3
X4WTE2  AR      R1,R0                   :add in bits
        JAL     R9,WCIE,,
        AIS     R10,1                   :count of written chars
X4WTE3  LHL     R4,X4T.LN,R6            :get len of MO
        AR      R10,R4
        AIS     R10,1                   :min len of len
        CLHI    R4,80
        JLFS    X4WTE4
        AIS     R10,1                   :min len of len is now 2
        CLHI    R4,100                  :two byte long form?
        JLFS    X4WTE4
        AIS     R10,1
X4WTE4  JAL     R9,X4BWLN               :write len to buffer
        LR      R7,R4                   :null element?
        JEFS    X4WTEX                  :if yes then no data to copy
        L       R4,X4T.DB,R6            :where data begins
X4WTE6  JAL     R9,PCIER4               :PCIE that uses R4 instead of R3
        JAL     R9,WCIE,,
        SIS     R7,1
        JGBS    X4WTE6
X4WTEX  L       R7,X4WTSV
        JR      R7                      :done

::*************************************************
:
:       PCIR4   gets escapaed char in r1 from buffer address contained in
:		r4 and 	updates r4 to next position in bufferlet.
:		Links on r9 and trashes r8
::*************************************************

PCIER4  JAL     R8,PCIR4
        LR      R1,R1
        JNR     R9
        JAL     R8,PCIR4
        JR      R9

::*************************************************
:
:       PCIR4   gets char in r1 from buffer address contained in r4 and
:		updates r4 to next position in bufferlet
:		Links on r8
::*************************************************

PCIR4   LB      R1,0,R4                 :get char
        AIS     R4,1
        THI     R4,CBSZ-1               :at end of bflet?
        JNR     R8
        LHL     R4,0,R4                 :get next bflet
        SLLS    R4,CBSZL
        ais     R4,cbptsz
        JR      R8

::*************************************************
:
:       X4GTNM  gets R0 bytes and gets it as a number (right justified)
:               returns number in r4.  links on r7, trashes r0,r1,r8,r9
::*************************************************

X4GTNM  LIS     R4,0
X4GTN1  SLLS    R4,8                    :move current over a byte
        JAL     R9,IGPCIE,,             :get first byte of number
        AR      R4,R1
        SIS     R0,1
        JGBS    X4GTN1
        JR      R7


::*****************************************************************
::
::      X4PARS  Parse X.409.  Searchs from current R3 bufadr to
::              the end of the first element.  Thus, R3 should point
::              to a constructor or this is a waste.  Creates a table
::              of parsed elements indexed by R6.  Table contains all
::              elements upto and including the found element.
::
::              Link on R7.  Trashes R0, R1, R8, R9.  R3 points to
::              data after length.  R0 has the length.  R6 points to
::              table containing ID, len, address, relative position
::              and the application/constructor bits.
::              Note: that IDs 10,11 are parsed for being application
::              IDs and not universal.  Thus, it cannot find the RMO or
::              SMO ids, but it can find the ID.NNL (app MO-11).
::*****************************************************************

X4PARS  LIS     R0,0
        ST      R0,X4TBPT               :init pointer
        STH     R0,ELEDIS               :first element has pos 0
        LA      R6,X4TBBG,,             :address of start fo table
        ST      R3,ELEPOS               :Tell X4NEXT where to begin
X4PRS0  ST      R3,X4T.BB,R6            :put address in table
        LHL     R0,ELEDIS               :dis from start of ID
        STH     R0,X4T.DI,R6            :Distance of Id
        JAL     R9,X4NXID               :get the next ID and length
        STH     R0,X4T.LN,R6            :save the length
        LHL     R1,ELEDIS               :save the displacement into table
        STH     R1,X4T.DD,R6            :dis from start of data (this+len=nxtid
        L       R1,X4NXVL               :get bits, ID, LEN
        ST      R1,X4T.AP,R6            :store bits, ID, LEN
        ST      R3,X4T.DB,R6            :address within Buffer of ele's Data
        L       R1,X4NXVL+4             :address within Buffer of ele's Length
        ST      R1,X4T.LB,R6
        ST      R6,X4TBPT               :pointer to deepest element read
        LB      R1,X4NXVL+1             :get the ID
        CR      R4,R1                   :match the ID looking for?
        JNFS    X4PRS1                  :not a match
        LHI     R1,MO.C                 :make sure it isn't a universal constr
        CLB     R1,X4T.AP,R6
        JN      4,R7                    :a smo or rmo

X4PRS1  JAL     R9,X4NXEL               :get next element
        ST      R3,X4T.EB,R6            :address of end of element
        LHL     R1,ELEDIS               :end of this constructor?
        SH      R1,X4TBBG+X4T.LN,,      :length of this construction
        SH      R1,X4TBBG+X4T.DD,,      :and dis to the above len
        JGEFS   X4PRS4                  :done if cur pos > length of constr
        CI      R6,X4TBEN               :end of table?
        JE      X4PRS0                  :last entry in full table is for cur ID
        AHI     R6,X4TBSZ
        J       X4PRS0                  :next table entry for next MO

X4PRS4  SKIP(0,R7)

::*****************************************************************
::
::      X4PARC  Sste function as X4PARS except it checks the table entries
::              before continuing search.
::
::*****************************************************************

X4PARC  LA      R6,X4TBBG,,             :get address of beginning of table
        C       R6,X4TBPT               :compare to pointer
        JG      X4PARS                  :no table entries, do parse from scratch
X4PRC1  CLB     R4,X4T.ID,R6            :this ID what we looking for?
        JNFS    X4PRC3
        LHI     R1,MO.C
        CLB     R1,X4T.AP,R6            :make sure not RMO/SMO
        JEFS    X4PRC3                  :(they have sste ID as ID.NNL & ID.REV)
        L       R3,X4T.DB,R6            :get R3 (address of data)
        LHL     R0,X4T.LN,R6            :get length
        J       4,R7                    :found match in table

X4PRC3  AHI     R6,X4TBSZ               :next entry in table
        C       R6,X4TBPT               :compare to present pointer
        JLE     X4PRC1                  :next entry in tble
        SHI     R6,X4TBSZ
        LHL     R3,X4T.LN,R6            :don't continue if constructor
        AH      R3,X4T.DD,R6            :is fully parsed in table
        SH      R3,X4TBBG+X4T.LN,,      :R3 had pos of end of last element
        SH      R3,X4TBBG+X4T.DD,,      :and subtracting pos of end of constr
        JLFS    X4PRC5
        SKIP(0,R7)                      :last element already in table
X4PRC5  L       R3,X4T.DB,R6            :and be setup for normal parse logic
        J       X4PRS1                  :and continue with normal parse logic

::*****************************************************************
::
::      X4NXID  it and X4NXEL are like bookends.  X4NXID gets the ID and
::              length and stores it.  X4NXEL takes this info and finds the
::              next potentially interesting MO.
::
::*****************************************************************

X4INUN  HC      0,0C000,0,0             :look inside SET and SEQUENCE constr
X4INAP  HC      4000                    :these appl constructor MOs have
        HC      0005                    :other MOs which we are to look at
        HC      2020                    :id.nch id.ccn
        HC      2AB8                    :id.dis and the xCRI, xCRM, ICRS series
        HC      8000                    :ID.NDT  40-4F
        HC      0,0,0,0,0,0,0,0,0,0     :no other appl constructors known

X4NXID  ST      R9,X4NXSV               :save link reg
        L       R3,ELEPOS               :start from where X4NXEL left off
        JAL     R9,IGPCIE,,             :get ID
        LR      R0,R1                   :save high bits
        NHI     R1,IDBITS               :get ID bits
        CLHI    R1,1F                   :ID here or in next
        JLFS    X4NXI1                  :>1f means ID is next char
        JAL     R9,IGPCIE,,             :get the ID
X4NXI1  NHI     R0,@IDBITS              :make it only application bits
        STB     R0,X4NXVL
        STB     R1,X4NXVL+1             :store the bits and ID
        ST      R3,X4NXVL+4             :save address of length
        JAL     R9,X4GTLN               :get the length field
        STH     R0,X4NXVL+2             :and save length
        ST      R3,ELEPOS               :tell X4NXEL where we left off
        L       R9,X4NXSV
        JR      R9

X4NXEL  ST      R9,X4NXSV               :save our link reg
        L       R3,ELEPOS               :take up where X4NXID left off
        LB      R1,X4NXVL               :get appl bits
        THI     R1,MO.C                 :is this a constructor?
        JN      X4NXE3                  :check if we care about dis one
X4NXE0  LHL     R0,X4NXVL+2             :get len of curr ele
X4NXE1  SIS     R0,1                    :read that many and to get to next ele
        JLFS    X4NXE2                  :and done
        JAL     R9,IGPCIE,,
        JBS     X4NXE1

X4NXE2  ST      R3,ELEPOS               :tell X4NXID where we left off
        L       R9,X4NXSV
        JR      R9

X4NXE3  LB      R0,X4NXVL+1             :get ID back
        THI     R1,MO.A                 :40 is application MOs
        JEFS    X4NXE4                  :some universal MO
        TBT     R0,X4INAP               :interesting application?
        JN      X4NXE2                  :yes, let X4PARS find MOs
        J       X4NXE0                  :no gobble entire construction
X4NXE4  TBT     R0,X4INUN               :univ constr contain interesting MOs?
        JN      X4NXE2                  :yes
        J       X4NXE0

::*****************************************************************
:
:       X4CRIZ  initialize X.409 MO creation table.  The table
:               has the ID with header bits, data length, length
:               of header (len of len and ID) and a word of data.
:               The word of data either contains the MO data or the
:               address of the data (either in bufferlets or normal).
:
::*****************************************************************

X4CRIZ  LA      R6,X4CTBG-X4CTSZ,,      :pointer when table empty
        ST      R6,X4CPTR               :save create table's pointer
        LHI     R1,X4CTSZ*X4NENT-4      :all of table
        LIS     R0,0
X4CRZ1  ST      R0,X4CTBG,R1,
        SIS     R1,4
        JGBS    X4CRZ1
        JR      R8

::*****************************************************************
:
:       X4CRID  X.409 create MO from Register.  ID in R4, R1 has
:               data.  Length is calculated from how many leading
:               zeros in R1.  R1 is corrupted (shifted left).
::*****************************************************************

X4CRID  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        LIS     R0,4            :max number of bytes in a register
X4CRI2  TI      R1,0FF000000    :high byte nonzero?
        JNFS    X4CRI4          :yes, save len
        SLLS    R1,8            :try next byte in r1
        SIS     R0,1            :len is also shorter
        JGBS    X4CRI2
        LIS     R0,1            :if r1=0 then still have len 1
X4CRI4  STH     R0,X4CLEN,R6    :save len of this element
        STH     R4,X4CID,R6     :Save ID of this element
        ST      R1,X4CDTA,R6    :save the data for this element
        LIS     R4,X4C.DT       :indicate that the data is in table
X4CRI6  STB     R4,X4CFLG,R6    :save what type is in data field
        LIS     R0,2            :min len of len and ID
        LHI     R4,100
        CLH     R4,X4CID,R6     :one or two byte ID
        JGFS    X4CRI7          :one byte
        AIS     R0,1            :Id took two bytes
X4CRI7  CLH     R4,X4CLEN,R6    :one or two bytes of len
        JGFS    X4CRI8
        AIS     R0,2
        JFS     X4CRI9
X4CRI8  SRHLS   R4,1            :len >=80
        CLH     R4,X4CLEN,R6
        JGFS    X4CRI9
        AIS     R0,1
X4CRI9  STB     R0,X4CHLN,R6    :save len of header
        JR      R8

::*****************************************************************
:
:       X4CMID  put entry into MO create table.  r4 has ID.  R0 has
:               length of data.  R1 has address where data begins.
:               The actual address used is after leading zeros are
:               skipped over.
::*****************************************************************

X4CMID  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        STH     R4,X4CID,R6     :save ID
X4CMI1  LB      R4,0,R1         :skip over leading zeros
        JNFS    X4CMI2
        AIS     R1,1
        SIS     R0,1            :len is shorter too
        JGBS    X4CMI1
        ST      R4,X4CDTA,R6    :store zero as data
        LIS     R0,1
        STH     R0,X4CLEN,R6
        J       X4CRI6          :finish as a register create element
X4CMI2  STH     R0,X4CLEN,R6    :save len
        ST      R1,X4CDTA,R6    :save address of data
        LIS     R4,X4C.MM       :mark that data is in memory
        J       X4CRI6

::*****************************************************************
:
:       X4CBOL  create true boolean element.  preprocessor for
:               X4CBOL.  Link on R8. trash r0,r1,r3
:
::*****************************************************************

X4CBOL  LA      R1,X4CBOV       :load address of FF
        LIS     R0,1            :length of 1
        J       X4CMID

X4CBOV  HC      -1              :FF for boolean element



::*****************************************************************
:
:       X4CBID  Address of data is in bufferlets.  R4 is ID.
:               R3 is address in buffers.  R0 is len.  Data is
:               NOT checked for leading zeros.
:
::*****************************************************************

X4CBID  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        STH     R4,X4CID,R6
        ST      R3,X4CDTA,R6
        STH     R0,X4CLEN,R6
        LIS     R4,X4C.BF       :mark that data is address into bufflet
        J       X4CRI6

::*****************************************************************
:
:       X4CCID  create entry for constructor.  R4 has ID.  Everything
:               else (ie len) will be calculated later
::*****************************************************************

X4CCID  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        STH     R4,X4CID,R6     :save ID
        LIS     R4,X4C.UC       :mark as unfinished constructor
        STB     R4,X4CFLG,R6    :mark this is a constructor
        JR      R8

::*****************************************************************
:
:       X4CNUL  create entry for null element (len of 0)
::*****************************************************************

X4CNUL  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        STH     R4,X4CID,R6
        LIS     R4,0
        STH     R4,X4CLEN,R6
        J       X4CRI6          :finish off with header

::*****************************************************************
:
:       X4FXCN  finish constructor.  Link on R8.
:               The constructor is considerred to be from the end
:               back to the last unfinished constructor
::*****************************************************************

X4FXCN  LIS     R0,0            :len of constructor
        L       R6,X4CPTR       :last entry in table
        LIS     R1,1            :bit if unfinished constructor
X4FXC1  CLB     R1,X4CFLG,R6    :is this the unfini construct
        JE      X4FXC7          :yes, prepare for exi
        LB      R4,X4CHLN,R6    :add in len of len and id
        AR      R0,R4
        LB      R4,X4CFLG,R6    :test if finished con (don't do its len)
        THI     R4,X4C.CC       :completed constructor?
        JNFS    X4FXC2
        AH      R0,X4CLEN,R6    :add in len of element
X4FXC2  SIS     R6,X4CTSZ       :back upto previous element
        CI      R6,X4CTBG       :end of table?
        JGE     X4FXC1
        JR      R8              :done with no constructor found
X4FXC7  STH     R0,X4CLEN,R6    :save len
        LIS     R4,X4C.CC       :mark as finished constructor
        J       X4CRI6          :do len of len and id (mark if fini con also)

::*****************************************************************
:
:       X4CDWR  write MOs in table into dispatcher.  Link on R8
:               r0, r1, r3, r4 ,r9 trashed.
::*****************************************************************

       IF       1-NCSLOT

X4CDWR  ST      R8,X4CWSV
        LA      R6,X4CTBG,,     :start of table
X4CDW1  LHL     R1,X4CID,R6     :get id
        THI     R1,0FF00        :two byte id?
        JEFS    X4CDW2
        EXBR    R1,R1
        JAL     R8,X4DWCH,,     :write char to dispi
        EXBR    R1,R1           :back to low byte
X4CDW2  JAL     R8,X4DWCH,,     :write ID
        LHL     R4,X4CLEN,R6    :get len
        JAL     R9,X4DWLN,,     :write len to dispi
        LB      R1,X4CFLG,R6    :where is our data?
        JNFS    X4CDW4          :if 0 then in data field
        LIS     R3,0
X4CDW3  SIS     R4,1
        JL      X4CDW9          :all data copied (handle null element too)
        LB      R1,X4CDTA,R6,R3 :data byte
        JAL     R8,X4DWCH,,     :write to dispi
        AIS     R3,1
        JBS     X4CDW3

X4CDW4  THI     R1,X4C.CC       :finished constructor?
        JN      X4CDW9          :it's data is other entries
        THI     R1,X4C.BF       :data in buffer?
        JN      X4CDW7
        THI     R1,X4C.MM
        JE      X4CDW9          :only other legal is data in memory
        L       R3,X4CDTA,R6    :get address of data
        LIS     R4,0            :offset into data
X4CDW5  CLH     R4,X4CLEN,R6    :done?
        JGE     X4CDW9          :done with element
        LB      R1,0,R3,R4      :get data byte
        JAL     R8,X4DWCH,,
        AIS     R4,1
        JBS     X4CDW5

X4CDW7  LIS     R4,0            :count of how many read
        L       R3,X4CDTA,R6
X4CDW8  CLH     R4,X4CLEN,R6    :done?
        JGE     X4CDW9
        JAL     R8,PCI,,        :ignore signals
        CLHI    R1,7
        JG      X4CD12
        CLHI    R1,4
        JGE     X4CDW8          :signal 4-7 are one byte long
        LR      R1,R1
        JEFS    X4CD11
        JAL     R8,PCI,,
        J       X4CDW8          :two byte signal
X4CD11  JAL     R8,PCI,,
X4CD12  JAL     R8,X4DWCH,,     :write char from buffer to dispi
        AIS     R4,1
        J       X4CDW8
X4CDW9  AIS     R6,X4CTSZ       :do next entry
        C       R6,X4CPTR       :completely done?
        JLE     X4CDW1          :do element
        L       R8,X4CWSV       :get back link
        JR      R8

       EI       :1-NCSLOT

::*********************************************************************
::
::	SUBROUTINE:     X4BWLN
::	FUNCTION:       write number in R4 as len into buffer in R2
::	CALLING SEQ:    link on R9
::	INPUT:          R2, R4
::      DESTROYED:      R0, R1, R3, R8
::
::*********************************************************************


X4BWLN  ST      R9,GTLNSV               :save link register
        CLHI    R4,MO.LFM-1             :short form?
        JLE     X4BWL6                  :yes, short form
        CLHI    R4,100                  :one or two bytes of long form
        JGEFS   X4BWL2                  :long long form
        LHI     R1,MO.LFM+1
        JAL     R8,WCI,,
        JFS     X4BWL6
X4BWL2  LHI     R1,MO.LFM+2             :two byte of long form
        JAL     R8,WCI,,
        EXBR    R1,R4                   :write high byte first
        JAL     R9,WCIE,,
X4BWL6  LR      R1,R4                   :last byte of length
        JAL     R9,WCIE,,
        L       R9,GTLNSV               :retrieve link reg
        JR      R9


::*****************************************************************
:
:       X4CBWR  writes MOs enterred in MO creation table.  link on r8
:               trash r0,r1,r3,r4,r6,r9
::*****************************************************************

X4CBWR  ST      R8,X4CWSV       :save link reg
        ST      R5,X4CWS1       :save a scratch reg
        LA      R6,X4CTBG,,     :start of table
X4CBW1  LHL     R1,X4CID,R6     :get id
        THI     R1,0FF00        :two byte id?
        JEFS    X4CBW2
        EXBR    R1,R1
        JAL     R9,WCIE,,       :write char to buffer
        EXBR    R1,R1           :back to low byte
X4CBW2  JAL     R9,WCIE,,       :write ID
        LHL     R4,X4CLEN,R6    :get len
        JAL     R9,X4BWLN       :write len to buffer
        LB      R1,X4CFLG,R6    :where is our data?
        JNFS    X4CBW4          :if 0 then in data field
        LIS     R5,0
X4CBW3  SIS     R4,1
        JL      X4CBW9          :all data copied (handle null element too)
        LB      R1,X4CDTA,R6,R5 :data byte
        JAL     R9,WCIE,,       :write to buffer
        AIS     R5,1
        JBS     X4CBW3

X4CBW4  THI     R1,X4C.CC       :finished constructor?
        JN      X4CBW9          :it's data is other entries
        THI     R1,X4C.BF       :data in buffer?
        JN      X4CBW7
        THI     R1,X4C.MM       :data in memory
        JE      X4CBW9          :only other legal is data in memory
        L       R5,X4CDTA,R6    :get address of data
        LIS     R4,0            :offset into data
X4CBW5  CLH     R4,X4CLEN,R6    :done?
        JGE     X4CBW9          :done with element
        LB      R1,0,R4,R5      :get data byte
        JAL     R9,WCIE,,
        AIS     R4,1
        JBS     X4CBW5

X4CBW7  LIS     R5,0            :count of how many read
        L       R4,X4CDTA,R6
X4CBW8  CLH     R5,X4CLEN,R6    :done?
        JGE     X4CBW9
        JAL     R8,PCIR4,,      :ignore signals
        CLHI    R1,7
        JG      X4CB12
        CLHI    R1,4
        JGE     X4CBW8          :signal 4-7 are one byte long
        LR      R1,R1
        JEFS    X4CB11
        JAL     R8,PCIR4,,
        J       X4CBW8          :two byte signal
X4CB11  JAL     R8,PCIR4,,
X4CB12  JAL     R9,WCIE,,       :write char from buffer to buffer
        AIS     R5,1
        J       X4CBW8
X4CBW9  AIS     R6,X4CTSZ       :do next entry
        C       R6,X4CPTR       :completely done?
        JLE     X4CBW1          :do element
        L       R5,X4CWS1       :restore scratched reg
        L       R8,X4CWSV       :get back link
        JR      R8



       EI       :LOGII

	ENDMO.(UTIL)
	EI	:1-KILLIT
	KILMSG(UTIL)

:	***NOTHING PAST THIS POINT***

        SUBTTL GATWAY (Gateway Dispatcher routines)

:       ****     *    ***** *   *    *    *   *
:      *        * *     *   *   *   * *    * *
:      *  **   *****    *   *   *  *****    *
:      *   *   *   *    *   * * *  *   *    *
:       ****   *   *    *    * *   *   *    *

::####################################################################
::
::	MODULE:		GATWAY
::
::	SUBTTLS:
::		GATWAY (Gateway Dispatcher routines)
::		GATWAY (RCRINC Node Code generated Log2 Logon Failures)
::		GATWAY (Logon successfully built to HNET)
::
::####################################################################

        IF      1-KILLIT
        BEGMO.
        SEG	a.code

::*********************************************************************
::
::		Miscellaneous Gateway Utility routines
::		GDOMES:	GBYHOM:
::
::*********************************************************************

CRLF    SC      /"8D"8A/                :redefined to avoid needless RX3s

	IF	T2GATE
GDOMES	LR	R1,R1
GDOM1	JE	GDOM8
	JAL	R8,WCI,,
	SRHLS	R1,8
	JBS	GDOM1
GDOM8	JR	R9

::********************

GBYHOM	ST	R8,GDSAVE		:Save return 
	TBT	CHN,GORGPT		:Should be destination
	JE	GBYSKP			:from terminal and
	TBT	CHN,LOGING		:not in log-in mode and
	JN	GBYSKP			:not a transparent circuit
	TBT	CHN,GTTRNS		:if we're going to send the
	JN	GBYSKP			:"inter-link cleared" message
	LA	R4,GNGONE,,		:back to the terminal
	JAL	R9,BUFCAN,,
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF
	JAL	R9,BUFCAN,,
	L	R8,GDSAVE
GBYSKP	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	GSOZW7:
::	FUNCTION:	DETACH CIRCUIT.
::	REMOVE DISPATCHER PERMUTER TABLE ENTRY FROM DIOTAB,
::	FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB (STARTING WITH
::	DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS FOR SENDING
::	APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING OUT CIRCUIT
::	IF NO ORANGE BALL RETURNED.
::
::*********************************************************************

:	DONE WITH ACCT. DETACH PORT
GSOZW7	LHL	R2,DIOTAB,R4,R4		:GET EXISTING PERMUTER TABLE ENTRY TO
	NHI	R2,-4			: MOVE TO CIOTAB.
:	FIND NEXT AVAILABLE CHANNEL TO DETACH PROCESS...
        lis     r3,8			:gateway has a no message option
        tbt     chn,gttrns		:if trans then no message
        jefs    gsozp1
        lcs     r3,1
gsozp1	L	R4,DETACP,,		:DETACH PORT AVAILABLE ?
	JFFO	R4,GSOZW8		:FOUND ONE
	J	4,R10			:NO DETACH PORTS, ZAP CIRC TO NETWORK

:	CAUSE ZAPX TO PUT CR/LF INTO BUFFER INSTEAD OF ZAPPER. THIS WILL
:	CAUSE DISPATCHER PORT TO BE FREED UP WITHOUT ZAPPING EXISTING CIRCUIT.
GSOZW8	LHI	R1,0D0A			:MAKE ZAPX PUT 'CRLF' INTO BUFFER
        stb     r3,detmty,chn
	JAL	R9,ZAPX			:'ZAP' THE DISPI SIDE OF CIR.
	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER AND
	JAL	R9,CRQHCR		:BUILD 2ND HALF OF CKT TO DETACH PROCES

:	SEND NEEDLE POINT TO DETACH PROCESS TO ALERT IT TO NEW PORT.
	XHI	R2,4			:INDEX FOR BUFF TOWARDS DETACH PROCESS
	LIS	R1,3
	JAL	R8,WCI,,
	LHI	R1,NEEDP
	JAL	R8,WCI,,		:WRITE NEEDLE POINT IN BUFFER
        SHI     CHN,DETZFL              :restore channel number		 ##sdw
	SKIP(0,R10)			:IMMEDIATE RETURN - CONTINUE	###wjl





::*********************************************************************
::
::	POINT OF DEPARTURE:	GDB2:	Gateway Dispatcher B2 Message	
::	FUNCTION:		Gateway gets a B2 (pseudo needle) on
::			CHN in response to a request for a Log-in.  It
::			sets up the buffer and arrays with given CHN, and
::			if transparent log-on will send username in B3
::			messages  to dispatcher
::	CALLING SEQ:	Jump to from DISKIP.  for Gateway only.
::	INPUT:		CHN	=  relative dispatcher port number
::			PRD	=  pointer to message in ISIS ring 
::			R2	=  buffer number gotten from the Local Key
::				   field in B2.  Must be in Log-on state. 
::	CALLS:		JAL	R8,GCI
::			JAL	R9,GHWI
::			macro AAMKPT
::			JAL	R8,WLOCDR
::			JAL	R9,BUFCAN,,
::			JAL	R9,ZAPV1
::	RETURNS:	Jumps directly to DSOIRP to continue Dispatcher  pro.
::
::*********************************************************************

:       Little routine for LOG I and LOG II gateway to setup chn
GDB2FG	LHL	R0,BF,R2,	:Now get Flag pointer for this buffer
	CLHI	R0,LOGMAX	:Should be marked as a Log-in buffer
	JG	DSOCRH,,
	CLHI	R0,LOGMIN
	JL	DSOCRH,,
::                      We are in Log-in mode.  Is there really a circuit?
	XHI	R2,4
	LHL	R0,BF,R2,	:Get Hnet channel number
	JLE	DSOIRP,,	:If dead, just flush this
	XHI	R2,4		:Return to F.T. buffer
	LHI	R0,LGSNT.	:Mark as TID accepted by Sup
	STH	R0,BF,R2,	:for future processing / timeout
	SBT	CHN,LOGING
	SBT	CHN,GDSTPT	:This is a circuit destination.
	RBT	CHN,GORGPT
	SBT	CHN,DISBPV	:Relieve backpressure
	SBT	CHN,DISBPX	:and we haven't BPed mr dispatcher
	SBT	CHN,LOGDAT	:allow log-on processing to begin
	SBT	CHN,GLGDAT	:first delimiter not yet sent
::                      Initialize the rest of the arrays
	RBT	CHN,GTAUX
	RBT	CHN,GTHDX
	SBT	CHN,GTASCI
	SBT	CHN,GTECHO
	SBT	CHN,GTLGEC
	RBT	CHN,GTTRNS
	RBT	CHN,GIIXCT
       if	cmpnul
	rbt	chn,nulcom		:compress starts of disabled
       ei	:cmpnul
	LIS	R0,0
	STB	R0,GLGCNT,CHN,	:Init logon character counter

::                      Install a scratch table entry for future reference
	STH	R2,GDLGTB,CHN,CHN	:and store it in our scratch table

::              Connect dispatcher port IOTAB to outbound (to terminal) buffer
::      We mark the IOTAB so that our CHN will not be selected for another
::      circuit.  We must keep track of login and complete circuit.
	AHI	CHN,DISZFL	:Make absolute channel number
	XHI	R2,4		:flip to outbound buffer #
	STH	R2,IOTAB,CHN,CHN	:chan marked as in use
	RBT	CHN,ACP,,	:Reset ACP bits
	LCS	R0,1
	SR	R0,CHN
	RBT	R0,ACP,,
        SHI     CHN,DISZFL              :back to disp chn number
::                      Turn on output to the Network
	LHL	R3,BF,R2,		:Get the channel number
	SBT	R3,BPSVCP-LNKZFL/8,,	:Enable RMAKE service of this channel
	SBT	R3,LNKBPV-LNKZFL/8,,
	RBT	R3,PRIRTY,,
	RBT	CHN,PRIRTY+DISZFL/8,,	:set it for dispatcher chn as well
	RBT	R3,CMDCTS-LNKZFL/8,,
       if	aplybp
	sbt	r3,abpvcp-LNKZFL/8,,	:backpressure not received
	rbt	r3,abpxcp-LNKZFL/8,,	:backpressured not transmitted
       ei	:aplybp
        lhi     r1,200
        sth     r1,bpscnt-2*lnkzfl,r3,r3
	XHI	R2,4		:Now get from terminal buffer 
	LHI	R0,INXLIM
	STH	R0,DIXLIM,CHN,CHN	:7/29/86	###EV
        JR      R8              :done with setup

::*****************************************************************
:       the actual GDB2 routine - Gateway handler for Pseudo Needle (type B2)
::*****************************************************************

GDB2	AIS	PRD,4
	NR	PRD,TC		:Advance pointer to Local Key
	LHL	R2,DORNG,PRD,	:Get Local Key
	AIS	PRD,2
	NR	PRD,TC		:Fix up pointer
        JAL     R8,GDB2FG       :initialize flags for chn and build circuit
       IF       LOGII
        RBT     CHN,DISLG2      :not a LOG II login
       EI       :LOGII
::              Now get items of information from our still intact Needle.
	JAL	R8,GCI,,	:Skip Needle point
	JAL	R8,GCI,,
	JAL	R8,GCI,,		:Get length of Needle
	JAL	R8,GCI,,
	STB	R1,GDNLEN	:and store for possible flush
	JAL	R8,GCI,,	:Skip escape
	JAL	R8,GCI,,	:Read link count and toss
	JAL	R9,GHWI,,	:Get 2 bytes of Invoice number
	STH	R1,GDNINV
	JAL	R9,GHWI,,	:Get remaining two
	STH	R1,GDNINV+2	:Store the Invoice Number
        AHI     CHN,DISZFL      :make real for accounting
::      Time to initialize the accounting block for this circuit termination
	LIS	R1,1
	AHM	R1,NC.CRC	:Count circuit completion for CRQ
	JAL	R8,AASTRT
GDB205	SHI	CHN,DISZFL	:Restore relative dispatcher port number
::      Now get Needle Flags field and store for possible future use
	JAL	R9,GHWI,,
	STH	R1,GDFLGS
	THI	R1,NF.SMC	:If IIX circuit - mark as such
	JE	GDB215
	SBT	CHN,GIIXCT
GDB215	NHI	R1,030		:Get speed bits
	SRHLS	R1,4		:Put in low order nibble
	STB	R1,GDSPED	:and store for later
	JAL	R9,GHWI,,	:Skip origin node
	JAL	R9,GHWI,,	:Skip origin port
::      Now toss the node list
GDB206	JAL	R9,GHWI,,
	CI	R1,0FFFF
	JEBS	GDB206
	TI	R1,8000
	JN	GDB207		:At end of node list - proceed
	J	GDZAP		:Some error - Zap both sides of circuit
::      Get User Flags field and examine username
GDB207	JAL	R9,GHWI,,	:User flags
	STH	R1,GDUSRF	:Store temporarily
	SRLS	R1,8		:Get rid of extra bits
	NHI	R1,1F		:Get the CCT itself
	LBR	R1,R1
	JE	GDBAUX		:Aux circuit if CCT is 0
	THI	R1,20		:Test Half Duplex bit
	JEFS	GDB208		:No
	SBT	CHN,GTHDX	:Else set as Half duplex
	RBT	CHN,GTECHO	:No echo for Half duplex terminals
::                      Test for 2741 terminal type
GDB208	SIS	R1,8
	JL	GDB209
	SIS	R1,9-8
	JGEFS	GDB209
	SBT	CHN,GTHDX	:Yes this is a 2741 type
	RBT	CHN,GTECHO	:No echo for this terminal
	RBT	CHN,GTASCI	:Special distinction as HDX Ascii
	JFS	GDB209
GDBAUX	SBT	CHN,GTAUX	:Marker as an Auxilliary circuit
	RBT	CHN,GTECHO	:No echo for Aux circuits	###per Kopfj
                                :the ###per KOPFj refers that it was commented
                                :out to allow echoing of username for aux cirs.
                                :that prevent loadii from working.  maybe later
                                :##### sdw
GDB209	JAL	R9,GHWI,,	:Pass requesting host
::                      Now check for Transparent Log-on
	JAL	R8,GCI,,	:First username character
	CLHI	R1,GXPRNT	:Is it a "?" ..? (transparent indicator)
	JN	GDB216		:No - flush username and proceed
::                      Transparent user - set up appropriately
	SBT	CHN,GTTRNS	:Set Transparent circuit flag
	TBT	CHN,GTHDX	:Is this a HDX circuit?
	JEFS	GDB210		:NO
	LHI	R1,0B308	:Set up for Log-on character
	JAL	R8,DIRMES,,	:and send to dispatcher
GDB210	LB	R1,GDSPED	:Get throughput class
	LB	R1,TPTBL,R1	:Get control character from table
	LHI	R0,0B3
	EXBR	R0,R0
	AR	R1,R0		:Make B3 message
	JAL	R8,DIRMES,,	:and send it
::      Now we've prepared the username with the right controls, so enter name
	LHI	R7,LGCHMX
GDB212	SIS	R7,1
	JL	GD2MNY		:Zap buffer and tell user "too many.."
	JAL	R8,GCI,,	:Get a username character
	OHI	R1,0B380                :make char into a B3 msg        ###sdw
	JAL	R8,DIRMES,,	: .. and write it to dispatcher
	NHI	R1,0FF
	CHI	R1,8D		:Is it a <cr>?
	JEFS	GDB214
	CHI	R1,0BB		:Is it a semi-colon?
	JN	GDB212		:If not either, then get more characters
:                               Finished sending Log-on string to Sup
GDB214	RBT	CHN,LOGDAT	:log-in in wait state
        THI     R7,1            :odd len username? (1,3,5,,,)
        JN      GDB220          :nope (count is one off from real (look above))
        LHL     R1,BCT,R2,      :remove null after last char in username
        JE      GDB220          :make sure null is there
        JAL     R8,GCI,,        :remove null
	J	GDB220		:Continue

::      Here if non-transparent and need to flush username
GDB216	HS	0		
	IF	0:EV1	(possible future implementation)
	LB	R1,GDSPED	:Get throughput class
	LB	R1,TPTBL,R1	:Get control character from table
	LHI	R0,0B3
	EXBR	R0,R0
	AR	R1,R0		:Make B3 message
	JAL	R8,DIRMES,,	:and send it
	EI	:EV1
	LHI	R7,7F		:Flush username
GDB217	SIS	R7,1
	JAL	R8,GCI,,		:may not be a good idea to continue here
	CHI	R1,8D
	JEFS	GDB218
	CHI	R1,0BB
	JN	GDB217
GDB218  THI     R7,1                    :fill char after username? (odd len)
        jefs    gdb220                  :nope
        lhl     r1,bct,r2,              :make sure it is there
        jefs    gdb220
        jal     r9,gcie,,               :it could be escaped
GDB220	XHI	R2,4		:Flip to outbound (to terminal) buffer
	TBT	CHN,GIIXCT	:An IIX circuit?
	JEFS	GDB222		:NO
	LA	R4,GIIXGW	:Send "reached IIX Gateway"
	JAL	R9,BUFCAN,,
GDB222	TBT	CHN,GTTRNS	:Transparent log-on?
	JN	GDB226		:Yes - don't send banner

GDB224	LA	R4,GNETOK,,	:Load 'inter-link connected'
	JAL	R9,BUFCAN,,	:Send it
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF
	JAL	R9,BUFCAN,,
	LA	R4,LTX000,,	:Load 'Please log in'
	TBT	CHN,GIIXCT	:IIX circuit?
	JEFS	GDB225		:NO
	LA	R4,GIXPLI	:Load IIX PLI message	
GDB225	JAL	R9,BUFCAN,,
::      Give network the desired transmit capability
GDB226	LHL	R3,BF,R2,		:get network channel number
	LHL	R7,GDFLGS		:Get needle flags
	THI	R7,NF.PRI		:Is this a priority circuit?
	JEFS	GDB228			:No
	SBT	R3,PRIRTY,,		:Set priority circuit flag
	SBT	CHN,PRIRTY+DISZFL/8,,	:Set for dispi chn as well
GDB228	LB	R1,GDSPED		:Get speed bits from temp storage
	LHL	R0,IOTAB,R3,R3
	OR	R0,R1			:Merge into perm table entry
	STH	R0,IOTAB,R3,R3		:And restore outbound table entry
:	Load port counters and etc.
	LHI	R1,HHOST		:so line trace will work
	STH	R1,DHSTIX,CHN,CHN
::                      Now send Needle  ack
	LHL	R2,TVRBUF	:Load up 'To Sup' buffer
	JE	GDB240		:No Sup? .. oh well ..
	JAL	R10,SUPMHD,,
	LBR	R1,CHN		:Get relative Dispatcher port #
	OHI	R1,1500		:Type 15 message
	JAL	R9,WHWI,,
	LH	R1,GDNINV
	JAL	R9,WHWI,,
	LH	R1,GDNINV+2
	JAL	R9,WHWI,,	:Followed by invoice number
GDB240	J	DSOIRP,,	:Return to Dispatcher mainline


::**********************************************************************
::
::	GD2MNY:	Sends message "too man log-on characters" to terminl user,
::		then Zaps the circuit.
::**************************************************

GD2MNY	XHI	R2,4		:Flip to outbound buffer(to terminal)
	LA	R4,TOMANY,,	:Get message
	JAL	R9,BUFCAN,,	:and put it out
	LA	R4,LSMX08,,	:"please see your rep ... "
	JAL	R9,BUFCAN,,
:NOW FALL THROUGH AND ZAP THE CIRCUIT IN BOTH DIRECTIONS

::**************************************************
::
::	GDZAP:	Zaps a Log-in circuit not fully built
::		from HNET  to INET.
::	EXPECTS:	CHN	=  Rel. Dispatcher chn
::			R2	=  From Terminal buffer
::
::**************************************************

GDZAP	LHI	R1,09F00	:Load a hard Zapper
	JAL	R8,DIRMES,,	:Send to Dispatcher on CHN
	LIS	R0,0		:Zero out scratch permuter table
	STH	R0,GDLGTB,CHN,CHN
	STH	R0,BF,R2,	:Zero our previously marked as Log-in BF
	XHI	R2,4		:Flip to To Termnal buffer, set up via CRQ
	LHI	R1,ZAPPN
	JAL	R9,W2CI,,	:Zap network side of circuit
	RBT	CHN,LOGING		:reset..
	RBT	CHN,DISFLG		:no more input to dispatcher
	RBT	CHN,DISZNK		:prepare for GLZPV
       if       acct
        lis     r0,aalr02
        sth     r0,aareas
        rbt     chn,disznk
        lr      r3,chn
        jal     r8,aarlo,,
        lis     r0,0
        sth     r0,aareas
       ei       :acct
        j       dsoirp,,

::*****************************************************************
:
:       this is the LOGSUP logic for GATEWAY.
:
:
:	Here for login-buffer that has not timed out.
:	If the supe and node code bits are both set in the buffer's BF,
:	we continue.  Otherwise, we go on to the next buffer (LOG1) and
:	return this buffer to the LOGGER list.
::*****************************************************************

GLOG9	LHL	R1,BF,R2,		:ARE WE IN XMIT MODE (SUP & NC)
	NHI	R1,@LG.TID		:(TID DOESN'T COUNT)
	CLHI	R1,LOGMIN+LOGSUP	:CMP WITH 14H
	JN	LOG1,,			:NO, BACK TO THE LIST

:	Here for buffer with BF set ready to transmit.
:	If there is data in the buffer, continue.  Otherwise,
:	go on to next buffer (LOG1).
	LHL	R1,BCT,R2,
	JLE	LOG1,,			:RETURN TO LOGGER LIST

	L	R3,BB,R2,		:INIT PCI
	XHI	R2,4			:BUF TO TERM, TO GET CHN
	LHL	CHN,BF,R2,		:Get to-terminal channel
	SHI	CHN,DISZFL		:Make to relative dispatcher port
	XHI	R2,4			:FROM TERM FOR PCI
       IF       LOGII                   :for LOG II dispi
        TBT     CHN,DISLG2
        JE      LOG010                  :only do log ii for logii origs
        JAL     R8,CBCCT,,
        LR      CD,R1
        J       GDLCCH                  :process logon chars
       EI       :LOGII
LOG010	TBT	CHN,GMSG0F		:0F MSG ALREADY SENT?
	JE	LOG020		  	:YES
        JAL     R9,PHWI,,
	STH	R1,GDSAVE
	CLI	R1,HHOST+8000
	JN	LOGZAP
        L       R3,BB,R2,
LOG020
        lb      r9,glgcnt,chn,
	JAL	R8,CBCCT,,		:CHECK CHAR CT. in buffer now
	STB	R1,GLGCNT,CHN,		:STORE NEW CT
        LR      R0,r9                   :how many chars (total) scanned
	LR	R4,r1			:New count into work reg
	SR	R4,R0			:DIFF. IN R4
	JLE	LOG1,,			:NO NEW CHAR
	LR	R0,R0
	JE	LOG027			:If buffer had been empty, go from BB
LOG023	JAL	R8,NCI,,		:INC R3 PTR ONLY,NO PEEK
	SIS	R0,1			:DEC OLD CT 	
	JGBS	LOG023
LOG027	JAL	R8,PCI,,		:PEAK EACH CHAR. & ANALIZE
        CLHI    R1,07                   :escaped char? ##sdw
        JG      LOG033                 :yes
        LR      R1,R1                   :escaped char?
        JE      LOG030
        SIS     R1,03                   :IS a ZAPPER in The buffer
	Jg	LOG043                  :not a zapper sig and 1 byte
        AIS     R9,1                    :one closer to the end
        SIS     R4,1                    :another one peeked
        lr      r1,r1                   :zapper type or just some signal
        jefs    log028
        jal     r8,pci,,                :each the don't care about signal
        j       log043
log028  jal     r8,pci,,
	CLHI	R1,03
	JLE	LOG047			:..IF SO , SEND DIRECTLY TO SUP
        J       LOG043                  :let the nonzapper just sit
LOG030  JAL     R8,PCI,,                :read escaped byte
        AIS     R9,1                    :one closer to too many
        SIS     R4,1                    :reduce unread count by one
LOG033	OHI	R1,80			:HO-BIT SET FOR CHAR
	XHI	R2,4			:TO TERM. BUF#
	CLHI	R1,88			:Is char. ctl-H?
	JNFS	LOG037			:No
	RBT	CHN,GTECHO		:Turn off echo for this guy
	SBT	CHN,GTHDX		:Make sure were thinging HDX
LOG037	CLHI	R1,09F			:Is char. printable?
	JLEFS	LOG040			:No
	TBT	CHN,GTLGEC		:Should this be echoed?
	JEFS	LOG040			:No
	TBT	CHN,GTECHO		:Echo for this term. type?
	JEFS	LOG040			:No
	LR	R10,R3
	JAL	R8,WCI,,		:Echo back to term.
	LR	R3,R10
LOG040	XHI	R2,4			:FROM TERM. BUF#
	CLHI	R1,9B			:ESC KEY?
	JE	LOG053			:YES, HANDLE ESCAPE
	CHI	R1,8D			:= 'CR' ?
	JE	LOG047			:YES, SET NODE CODE TO OK
	CHI	R1,0BB			: IF IT IS SEMI-:
	JNFS	LOG043
	RBT	CHN,GTLGEC		: NO ECHO AFTER SEMI-:
	J	LOG047
LOG043  AIS     R9,1                    :one closer to too many
        CLHI    R9,LGCHMX               :made it to too many?
        JG      LOG050                   :jump more than 48 log chars
	SIS	R4,1			:EMPTY BUFFER YET ?
	JG	LOG027			:No .. get more characters
	J	LOG1,,			:and go to next port
:	SET BF TO 'NODE CODE = YES' IF CHARACTER IS CR OR SEMI-:
LOG047	LHL	R8,BF,R2,		:GET BF
	OHI	R8,LOGNDC		:SET 'NODE CODE = OK' BIT
	STH	R8,BF,R2,
	J	LOG101			:GO TO COPY TO SUP BUF

:	MORE THEN 48 CHAR.S ENTRY
LOG050 	LIS	R1,0			:SET TO 0 FOR NO ESC CHAR
:	ESCAPE KEY HANDLER
LOG053	LIS	R0,0			:COMMON ENTRY POINT FOR ESCAPE
					: & BUFFER FULL
	ST	R0,DSOLGH  		:CLEAR TEMPORARY SAVE AREA
	STB	R1,DSOLGH+3		:STORE R1 (EITHER ESCAPE CHAR OR 0)
	LIS	R0,0F
	TBT	R0,BF,R2,		:IS TID IN THE BUFFER?
	JEFS	LOG057			:NO
	JAL	R9,GHWI,,			:YES, GET HOST NUMBER
	STH	R1,DSOLGH		:AND SAVE IT
	JAL	R8,GCI,,			:ALSO GET TID
	OHI	R1,80			:HO-BIT SET FOR CHAR
	STB	R1,DSOLGH+2		:SAVE IT ALSO
LOG057  LB	R1,DSOLGH+3		:ESCAPE OR BUFFER FULL?
	JE	LOG080			:BUFFER FULL, GO CLEAR IT

LOG060  LHL	R0,BCT,R2,		:ESCAPE TYPED...ANYTHING IN BUFFER?
	JEFS	LOG063			:NO, BUFFER EMPTY
	JAL	R9,GCIE,,		:YES, GET A CHARACTER, ESCAPE STRIPPED
	NHI	R1,7F			:STRIP OFF MSB
	CLHI	R1,01F			:CONTROL CHARACTER?
	JGBS	LOG060			:NO, GET ANOTHER CHARACTER
	SBT	R1,DSOSPC		:CONTROL CHARACTER, NOTE IT
	JBS	LOG060			:AND KEEP EMPTYING BUFFER
LOG063  LHL	R1,DSOLGH		:GET HOST NUMBER
	JEFS	LOG070			:NO HOST NUMBER IN BUFFER
	JAL	R9,WHWI,,		:DEPOSIT HOST NUMBER
	LB	R1,DSOLGH+2
	JAL	R8,WCI,,		:AND TID
LOG070	LHI	R4,01F			:SEND SUP ALL CONTROL CHARACTERS
LOG073   RBT	R4,DSOSPC		:WAS THIS ONE IN BUFFER?
	JEFS	LOG076			:NO
	LHI	R1,80,R4		:YES, APPEND 80-BIT...
	JAL	R9,WCIE,,		:AND, WRITE IT IN
LOG076   SIS	R4,1
	JGEBS	LOG073			:LOOP OVER ALL CONTROL CHARACTERS
         LB	R1,DSOLGH+3		:GET THE ESCAPE CHAR
	JAL	R8,WCI,,		:AND WRITE IT IN
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	J	LOG101			:GO TO COPY TO SUP. BUF
::Too many login characters .... abort login
LOG080	JAL	R8,CBCLR,,		:CLEAR BUFFER
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	XHI	R2,4
	LHL	CHN,BF,R2,
	SHI	CHN,DISZFL
	XHI	R2,4
	LHL	R1,DSOLGH		:IS HOST NUMBER IN BUFFER
	JE	LOG083			:GO TO COPY TO SUP. BUF
	JAL	R9,WHWI,,		:YES, REDEPOSIT IT
	LB	R1,DSOLGH+2		:AND ALSO THE TID
	JAL	R8,WCI,,
LOG083	LA	R1,TOMANY,,
	JAL	R8,DIMMES,,
	LA	R1,PSRMSG,,
	JAL	R8,DIMMES,,		:Output "pls see your rep.."
	TBT	R5,GTTRNS
	JN	LOG087
	LA	R1,GNGONE,,
	JAL	R8,DIMMES,,
	DROUTE(ISISN,HOMEN)		:If non-transparent send
	LA	R1,CRLF			:"inter-link cleared .."
	JAL	R8,DIMMES,,
LOG087	TBT	CHN,GMSG0F		:Has  TID etc. been sent to sup ?
	JE	LOG090			:Yes .. continue processing login

	LHI	R1,09E00		:In this case, just Zap circuit
	JAL	R8,DIRMES,,
	LIS	R1,0			:and let dispatcher Zapper ack
	STH	R1,BF,R2,		:Set bf to Zero for RFCBUF
	SBT	CHN,DISZNK		:And set up for Zapv to clean up
	J	LOG0,,			:also ensure LOGCLR

LOG090	LHI	R1,ZAPPH		:Abort login in progress 
	JAL	R9,W2CI,,		:WRITE ZAPPER TO BUFFER
					:and continue ... send Zapper to sup
LOG101	LR	R6,R2			:MOVE CHARS TO THE LEP BUFFER
	LHL	R10,BF,R2,		:GET LOGIN STATUS (16 OR 17 HEX)

:	Get the login status from BF and convert to proper sup message type
:	(0E=login string continuation, 0F=TID+login string).  
:	Create a login string message in the sup buffer (TVRBUF)
:	get logon status from BF and convert to NEW or not depending on TID
:	in buffer or not.  Send a type 0C message in either case.
	SHI	R10,08			:CONVERT TO MESSAGE TYPE (0E OR 0F HEX)
	LHL	R2,TVRBUF		:init R2 to hold to-SUP buffer number
	LR	R7,R2			:R7 holds sup buffer while we work
	LHI	R1,MACHNM+8000		:MAKE SUP RECORD
	JAL	R9,WHWI,,
	LR	R1,R10			:MESSAGE TYPE '0E' OR '0F'
	JAL	R8,WCI,,

	IF	LPGDBG 			:DEBUGFGER		###LSH 
	L	R1,BE,R7,
	ST	R1,LPGSSV		:save ptr to use in cpying data
	EI	:LPGDBG

	LIS	R1,0
	JAL	R8,WCI,,		:ASSUME CHAR COUNT NEEDS ESCAPING
	JAL	R8,WCI,,		:ESCAPED CHAR CNT WILL GO HERE IN BUFF
	L	R10,BE,R2,		:SAVE POINTER TO IT
	LR	R1,R6
	XHI	R1,4			:GET THE PORT #
	LHL	R1,BF,R1,
	OHI	R1,8000			:SET FOR SUP
	JAL	R9,WHWI,,
	LHI	LRC,80			:NUMB OF CHARACTERS TO BE SENT.
:	80-bit means not SIQ circuit. May be reset below.
		
:	If the TID is still in the buffer, include the host number.
:	Else skip to LOG130.
	LIS	R2,0F			:LAST (TID) BIT IN HW
	TBT	R2,BF,R6,		:TID WAITING TO BE SENT ?
	JE	LOG130			:NO, SKIP HOST NUMBER
:	If we're sending the intial login string (msg type 0F),
:	we have to check for a smart (SIQ) circuit and inform the sup if so.
:	We know a circuit is SIQ if the LO bit of the orginating channel's
:	permuter table entry is set (i.e., the LO gouging bit).  We tell
:	the supe a circuit is SIQ by resetting the HO bit of the count field
:	(1 byte) in the type-0F message.
	RBT	CHN,GMSG0F		:SET FLAG TO 0 WHEN SENDING 0F
	XHI	R6,4
	LHL	R9,BF,R6,		:GET ORIGINATING CHANNEL
	XHI	R6,4
	LHL	R0,IOTAB,R9,R9		:PERMUTER TABLE ENTRY FOR CIRCUIT ORIG
	THI	R0,IIXLOG		:SIQ CIRCUIT?
	JEFS	LOG120			:NO
	LIS	LRC,0			:ABSENCE OF 80 BIT INDICATES SIQ TO SUP
:	Type 0F msg. Include host number+8000.
LOG120	LR	R2,R6			:GET PORT BUFFER
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG150			:IT'S EMPTY NOW
	JAL	R9,GHWI,,		:GET 8000+HOST NUMBER
	LR	R2,R7			:GET SUP BUFFER
	JAL	R9,WHWI,,		:WRITE HOST NUMBER

:	Supe message header complete.  Now append login string from login
:	buffer to it (escaping as necessary) until login buffer is depleted or
:	a terminator or escape char is detected.  (See LOGDLM for escape
:	characters-- there are several.)  Bump the count in LRC as we go.
:	Skip to LOG150 if the buffer empties.
LOG130	LR	R2,R6			:port buffer
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG150			:IT'S EMPTY NOW
	JAL	R8,PCIS,,
	CLHI	R1,03
	JN	LOG137	
	JAL	R8,PCI,,
	CLHI	R1,01
	JE	LG11ZP
	JFS	LOG137
LOG133	LR	R2,R6			:port buffer
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG150			:IT'S EMPTY NOW
LOG137	JAL	R8,GCI,,		:read out a byte
	LR	R2,R7			:sup buffer
	CLHI	R1,8			:ESCAPE IF NEEDED (00-07)
	JGE	LOG140

        lr      r1,r1                   :escaped byte?
        jefs    log138
        sis     r1,3                    :two byte char pair?
        jg      log130
        lr      r2,r6                   :source reg
        jal     r8,gci,,                :get second byte of signal pair
        lr      r2,r7                   :dest reg
        j       log130
log138  lr      r2,r6
        jal     r8,gci,,                :get second byte of char pair
        lr      r2,r7
LOG140	OHI	R1,80			:Must set high order bit for sup
	JAL	R8,WCI,,		:and write in data byte
	AIS	LRC,1			:INC STRING COUNT (don't count escapes)
	AIS	R4,1			:STOP WHEN CR, SEMI-:, OR ESC IS FOUND
	TBT	R1,LOGDLM-10		:DELIMITER = 'CR', "SEMI-:", 'ESC' ?
	JE	LOG133			:no, continue at top of loop
	J	LOG150

::	Detected Zapper in buffer.  Just send a Zapper to sup.
LG11ZP	LR	R2,R7
	LHI	R1,ZAPPH
	JAL	R9,WHWI,,		:Write Zapper directly to sup buffer
	AIS	LRC,2
	AIS	R4,2
	XHI	R6,4
	LHL	R1,BF,R6,		:Get return channel (to terminal port)
	SHI	R1,DISZFL		:Make relative dispatcher port
	RBT	R1,DISFLG		:and disable  servic of null buffer
	XHI	R6,4			:Return to previous state

::Now continue and send to sup
:	Detected terminator (semi-:, CR) or escape in login string or
:	Login buffer emptied while we were transfering it to the sup buffer.
:	Close out the supe message, mark the login buffer's BF to show TID has
:	been sent, then go on to next buffer (LOG1).
LOG150	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,3			:CASE # 3
	JAL	R14,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
        gl      lggdb3
	JAL	R14,LGGDB3,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	LIS	R0,0
	STB	R0,GLGCNT,CHN,		:Reinit. log-on buffer count
	STB	LRC,0,R10		:EMPTY BUFF - PUT AWAY COUNT
	LR	R2,R6
	LHI	R1,LG.SNT		:set to wait
	STH	R1,BF,R2,
	J	LOG1,,			:PUT HIM BACK ON QUEUE

:	(CR) (ESC,FS,GS,RS,US) (SEMI:) ({,|,},TILDA)
:	Bit array (80x bits) marks ASCII codes that are to be considered
:	"escapes" in a login string.
LOGDLM	HC	0004,001F,0000,0010,0000,0000,0000,001E

::	Here to zap a login circuit because LOGGER found no sup or recent
::	takeover (in either case we can't process any more login data now,
::	and because we can't be sure of the status of any login data 
::	already sent to the (a) sup, we have to ask every one to start over
::	again).  We zap a port in login mode by sending it a
::	login-error-character-pair (0313).  If ISIS, DISPI will send the
::	dispatcher a B5 message and a zapper, and will call ZAPV when it gets
::	the corresponding zapper ack.  In a CONSAT, the port will be hung and
::	a zapper sent back to the node code by ASYNC.
::	For Gateway, we must send a zapper (to invoke an ISIS detatch)
::	and let the zap ack invoke Zapv to clear circuit - because we are not
::	talking to a terminal in Log-in mode, but to an active circuit in
::	another network.
LOGZAP	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,1			:CASE # 1
	JAL	R14,LGGDB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	XHI	R2,4			:ZAP CIRCUIT
LGZA1	LIS	R1,3
	JAL	R8,WCI,,
	LHI	R1,ZAPPH&0FF		:having placed char pr 0303
	JAL	R8,WCI,,
LGZPCN	XHI	R2,4			:Continuation point in either case

:	Set this guy's BF back to 0 (nothing doing) and go on to the next
:	buffer (LOG0).
	LIS	R1,0			:ZERO BUFFER FLAG
	STH	R1,BF,R2,
	
	J	LOG0,,			:DONT PUT HIM BACK

:	LOGGER exit point.  Mark the 'has-ther-been-a-recent-takeover" flag
:	to "no" before returning to SWITCH exec loop (LOGRET).
LOGXIT	LIS	R0,0			:FORCE THIS TO NORMAL STATE
	STH	R0,LOGZPF
	J	LOGRET,,




::*********************************************************************
::
::	SUBROUTINE:	GDB3IN:  Gateway Dispatcher B3 INput handler.
::	FUNCTION:	Invoked for ports in Log-in mode.  Formulates
::			characters from HNET terminal into B3 for ISI.
::	CALLING SEQ:	JAL	R10,GDB3IN
::	CALLS:
::	RETURNS:
::
::*********************************************************************

GDB3IN	ST	R10,DSSVRT		:SAVE RETURN
:	PREVENT HOGGING CPU IN DISPATCHER PROCESS. DIDTIM WILL CONTAIN
:	FASTC TIME TO DISMISS BACK TO EXEC 500MS EVEN IF WORK TO DO.
	L	R0,FASTC,,
	AHI	R0,RATE/10		:DON'T RUN FOR MORE THAN 1/16TH SECOND
	ST	R0,DIDTIM

::      Should we dismiss after servicing each Log-in port?
GDINXT	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	GDLNX1			:YES - CONTINUE FILLING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DIDISM
	J	GDLORT			:..RETURN

GDLNX1	LIS	TYC,7			:SET UP CONSTANTS
	LHI	TC,DRSZ-1
	LH	PRD,DRIF,,		:COMPUTE ROOM AVAILABLE
	LH	PRC,DRIE,,
	SR	PRC,PRD			:DRIE - DRIF
	JGFS	GDB305			:NO RING WRAP
	AHI	PRC,DRSZ		:RING WRAP
GDB305	CLHI	PRC,10			:MINIMUM ROOM CONSIDERED
	JGFS	GDB310			:PRC = ROOM AVAILABLE

:	HERE TO RETURN MAIN
GDLORT	L	R10,DSSVRT	
	JR	R10

:	LOCATE PORTS WITH INBOUND DATA
GDB310	LHI	R7,((NDP-1)/20)*4       :number of words to check
GDB320	L	R1,LOGING,R7
	N	R1,LOGDAT,R7		:Only ports in log-in WITH data
	N	R1,GDSTPT,R7		:Service only destination ports
	N	R1,DISBPV,R7		:MASK OUT BP'ED PORTS
	N	R1,GISSVD,R7		:AND SERVICED PORTS
	JFFO	R1,GDB342		:GO TO SERVICE

	SIS	R7,4			:POINT TO  NEXT WORD OF BIT ARRAYS
	JGEBS	GDB320			:PROCESS THIS GROUP IF NOT

:	ALL PORTS SERVICED ONCE
	LCS	R2,1		
	LHI	R7,((NDP-1)/20)*4
GDB330	ST	R2,GISSVD,R7		:RESTORE SERVICE FLAGS
	SIS	R7,4
	JGEBS	GDB330			:LOOP FOR NEXT GROUP
	J	GDLORT			:ALL DONE AND SPLIT

:	THIS IS THE MAIN WORK LOOP-- MOVE DATA FROM BUFFERLETS INTO RING
:	FOR THE PORTS MARKED IN R1'S BIT ARRAY.
GDB342	LR	CHN,R7			:CHANNEL OFFSET FOR WORD OF BIT ARRAY
        SLLS    CHN,3
	AR	CHN,R2			:ADD CHAN OFFSET WITHIN THE GROUP
					:CHN = RELATIVE DISPI CHN NUMBER
	RBT	CHN,GISSVD		:THIS PORT SERVICED
	LHL	R2,DIOTAB,CHN,CHN	:IOTAB ENTRY (OUTBOUND BUFF #)
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER NUMBER
	JNFS	GDB350
	CRASH.(.DISI0)			:DISPI FOUND NO DISPATCHER CIRCUIT
	J	GDB320			:GO TO SEE NEXT PORT
::Proceed
GDB350	XHI	R2,4			:Switch to inbound(from term) buffer
::      Check to ensure that we're in Log-in mode!
	LHL	R1,BF,R2,		:The BF should indicate Log-in
	clhi	r1,detzfl		:but it can indicate a port being
	jge	gdb320			:detached which is okay
	CLHI	R1,LOGMAX
	JG	GB3CRH
	CLHI	R1,LOGMIN
	JL	GB3CRH

	JAL	R8,CBCCT,,		:GET COUNT, RETURN IN R1
	LR	R1,R1
	JE	GDB320			:If NO  data, go service next port

GDB356	LR	LRC,R1			:MINIMUM AGAIN
	LR	CD,LRC			:WORKING COUNT

::      Now read Log-in characters, acting on zappers and passing on the rest
GDB360  HS      0
       IF       LOGII                   :log II logon chars
        TBT     CHN,DISLG2              :for only log 2 ports
        JN      GDLCCH
       EI       :LOGII
	JAL	R8,GCI,,		:MOVE CHARACTERS FROM BUFFER
	CR	R1,TYC			:Is it a Tymnet Control Character?
	JG	GDB3PR
        LR      R1,R1                   :escaped char?
        JNFS    GDB361
        SIS     CD,1                    :reduce count by the escape
        JAL     R8,GCI,,                :get the escaped char
        J       GDB3PR                  :and process it  ###sdw
GDB361	CLHI	R1,03			:Is it a Zapper
	JN	GDB403			:No, continue processing
	JAL	R8,PCIS,,
	CLHI	R1,01
	JE	GDB362
	CLHI	R1,02
	JE	GDB362
	CLHI	R1,03
	JN	GDB403

::      Clean up logon aspects of circuit - Zapper ack will clean up Hnet side
GDB362	RBT	CHN,LOGING		:No longer login mode
	RBT	CHN,DISZNK		:Expect zap ack - prepare for GLZPV
	LIS	R0,0
	STH	R0,GDLGTB,CHN,CHN	:Zero out scratch table
	JAL	R8,RFCBUF,,		:And in this case must return buffer
::      ZAPX will have cleared out the H-Net side of the 
::      circuit and done accounting
::              Send Zapper to ISIS side of circuit
	STH	CHN,DIRNG,PRD,		:Put channel number into ring
	LHI	R1,ISZAPR		:Load ISIS  ZAPPER
	STB	R1,DIRNG+2,PRD,		:Store to dispatcher ring
	AIS	PRD,4
	NR	PRD,TC
        STH     PRD,DRIF,,              :save ring pointer
       IF       ACCT                    :must do termination accounting ###sdw
        LIS     R0,AALR03               :zapped by user
        LHI     R3,DISZFL-MNACHN,CHN    :convert to accounting chn
        JAL     R8,AARLO,,
        LIS     R0,0
        STH     R0,AAREAS               :clear reason
       EI       :ACCT                   :accounting logic               ###sdw
        J       GDINXT,,                :and done with port


::              End point for each iteration of this routine
GDB390	HS	0
	IF	ACCT
::              Perform character counts for this destination
	TBT	CHN,GDSTPT		:Destination port?
	JE	GDB396			:Not destination, no count
	LR	R0,LRC			:Get count
	LR	R3,CHN			:Move Channel # to work reg
	AHI	R3,DISZFL		:Get absolute channel number
	SHI	R3,MNACHN		:Make an accounting index
	JAL	R8,AARDIC,,		:Now add to accumulator
	EI	:ACCT
GDB396	AIS	PRD,3		:Round off pointer
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,	:and restore
	J	GDINXT		:Process next port

::                      Or process other control characters
GDB403	LIS	LRC,0			:For accounting, don't count controls
	CLHI	R1,05			:Is a green ball
	JE	GB3C01			:Yes
	CLHI	R1,06			:Is a red ball
	JE	GB3C01			:Yes
        sis     r1,3                    :this sig a pair or a byte?
        jg      gdb390                  :a signal byte signal
        lhl     r0,bct,r2,              :make sure another byte is there
        je      gdb390
        jal     r8,gci,,                :get second byte
        clhi    r1,0ff                  :yellow ball?
	JE	GB3C02
	J	GDB390			:Continue processing

::      Bounce green and red balls, reflect orange for yellow
GB3C01	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R8,WCI,,		:And bounce it
	XHI	R2,4			:Return to net bound buffer
	J	GDB390
GB3C02	XHI	R2,4			:Flip again
	LHI	R1,0FE
	JAL	R8,WCI,,		:bounce orange ball
	XHI	R2,4			:Flip back
	J	GDB390

::      Else, process Log-on characters - sending each one in a
::       B3 message to ISIS
::      Enter here for next character
GDB3PR	LB	R9,GLGCNT,CHN,		:Current acumulated count
::            Test for Half Duplex
GDB3P1	OHI	R1,80			:Set high order bit
	LR	R6,R1			:Save copy of character
	CLHI	R1,88			:Is character control-H
	JNFS	GL3C1			:NO
	RBT	CHN,GTECHO		:Turn off echo for this guy
	SBT	CHN,GTHDX		:Make sure were thinking HDX
GL3C1	CLHI	R1,09F			:Is character printable
	JLE	GL3CH1			:NO
	TBT	CHN,GTLGEC		:Should this be echoed
	JE	GL3CH1			:NO
	TBT	CHN,GTECHO		:Echo for this terminal type?
	JE	GL3CH1			:NO
	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R8,WCI,,		:Echo back to terminal
	XHI	R2,4			:Flip buffer back
::      Now write character to ISIS using B3 format.
GL3CH1	LBR	R1,R6			:ensure char is 1 byte
	STH	CHN,DIRNG,PRD,
	LHI	R0,0B300,R1		:Make B3 message
	STH	R0,DIRNG+2,PRD,		:Put into ring
	AIS	PRD,4
	NR	PRD,TC
::                                      Now check for terminators
	CHI	R1,8D			:= 'CR' ?
	JEFS	GB3CH0			:YES, SET NODE CODE TO OK
	CHI	R1,0BB			:= "SEMI :" ?
	JN	GDB3PP			:Do next character
	RBT	CHN,GTLGEC		:No echo allowed after semi-colon
GB3CH0	RBT	CHN,LOGDAT		:Put log-in in wait state
	LIS	R1,0
	STB	R1,GLGCNT,CHN,		:Reinit counter
	RBT	CHN,GLGDAT	
	J	GDB390			:Return for next port
::                                      Not delimiter .. get next character
GDB3PP	AIS	R9,1		:too many characters yet?
	TBT	CHN,GLGDAT
	JEFS	GDPP2
	CHI	R9,LGCHMX-3
	JFS	GDPP3
GDPP2	CHI	R9,LGCHMX
GDPP3	JLE	GDPP4		:Not too many .. continue
	XHI	R2,4
	LA	R4,TOMANY,,		:Sent "to many login characters"
	JAL	R9,BUFCAN,,		:back to the terminal user
	XHI	R2,4
	J	GDB390			:and go to next port
GDPP4	STB	R9,GLGCNT,CHN,	:Else .. store count so far
        SIS     CD,1
	JLE	GDB390		:and go to next port
	JAL	R8,GCI,,
        LR      R1,R1           :escaped char?
        JN      GDB3P1
        SIS     CD,1            :another char gone
        JAL     R8,GCI,,        :get the char
	J	GDB3P1		:Get next character

:	Come here when circuit is inconsistent
GB3CRH	CI	R1,DEAD		:Could be special case of circular login
	JE	GB3CR1
	CRASH.(.DISI0)
GB3CR1	XHI	R2,4		:If so, other should be too
	LHL	R1,BF,R2,
	CI	R1,DEAD
	JE	GB3CR2		:If so, clear table entries
	CRASH.(.DISI0)
GB3CR2	RBT	CHN,LOGING
	AHI	CHN,DISZFL
	LHL	R1,IOTAB,CHN,CHN
	CR	R1,R2		:Consistency check
	JE	GB3CR3
	CRASH.(.DISI0)	
GB3CR3  HS      0
        IF      CBZDBG                  :debug this too (like ZAPV)
        STM     R0,REGST
        JAL     R14,GPZDB3,,
        GL      GPZDB3
        LM      R0,REGST                :new debug does all regs###sdw
        EI   :CBZDBG

	LIS	R0,0		:End of same circuit, so clear tables
	STH	R0,IOTAB,CHN,CHN
	SBT	CHN,ACP,,
	RBT	CHN,CHS,,
	SBT	CHN,CHS1,,
	LCS	R0,1
	SR	R0,CHN
	SBT	R0,ACP,,
	RBT	R0,CHS,,
	SBT	R0,CHS1,,
	J	GDB320

::*********************************************************************
::
::	ENTRY POINT:	GLP0DD:	Gateway LeP type 0D handler
::	FUNCTION:	Handles the Gateway variations of the Node
::			response to the Log-on response type 0D from Sup
::	INPUT:		R2	=  Buffer from terminal
::			CHN	=  Channel number (absolute)
::	OUTPUT:		Outputs a text and possible control characters.
::			Gateway must interpret and send any text due to its
::			capacity during log-in as a virtual terminal interface.
::			It must do this based on several possible general
::			terminal profile characteristics.  ie. Transparent
::			Log-on, IIX, HDX or just plain Ascii.
::	CALLS:		JAL	R8,GCI
::			JAL	R8,WCI  
::			JAL	R9,BUFCAN
::	RETURNS:	Jumps back to end of LEP0D routine to finish up
::			and return to further Lep processing.
::
::*********************************************************************

: rewritten GLP0dd to prevent any ports from going in cleanup.
: ###sdw

GLP0DD  LR      R10,R7          :make copy of status byte
        NHI     R7,1F           :r7 has message type
        SHI     CHN,DISZFL      :use relative (dispatcher) channel

        SBT     CHN,GTLGEC      :echo on
        THI     R10,40          :unless told to turn it off
        JNFS    GLP41
        RBT     CHN,GTLGEC      :told to turn off

GLP41   THI     R10,20          :flush port bound buffer?
        JEFS    GLP42           :nope
        XHI     R2,4            :port bound buffer
        JAL     R8,CBCLR,,      :flush
        XHI     R2,4            :return back to supe bound buffer

GLP42   CLHI    R7,11           :is the hang that ends the supe session?
        JE      GLP30Z          :yes handle it (nothing else matters)
        THI     R10,80          :clear supe bound buffer?
        JE      GLP42D          :nope
        JAL     R8,CBCCT,,      :count to clear
        LR      R1,R1           :any to clear?
        JLE     GLP42D          :nope
        JAL     R8,GCI,,        :make sure we don't clear a supe bound zap
        SIS     R1,3            :first byte of a zapper?
        JNFS    GLP42C          :nope, so ok to empty buffer
        LIS     R1,3            :put back that zapper byte
        JAL     R8,WCD,,        :put it back on the about to be read side
        LHI     R4,LOGMIN+LOGSUP :set status so LOGGER will sind it to supe
        STH     R4,BF,R2,       :loging status is stored in BF field
        J       LEP1,,          :done with this message

GLP42C  JAL     R8,GLBCLR,,     :empty login buffer (special empty routine)

GLP42D  XHI     R2,4            :flip back to terminal buffer
        TBT     R7,LGCHZZ       :should we reinit our to supe char count?
        JEFS    GLP42E          :nope
        LIS     R0,0
        STH     R0,GDLGTB,CHN,CHN :reinit count

GLP42E  SHI     R7,8            :bias down to 0
        TBT     CHN,GIIXCT      :iix circuit
        JN      GL30J           :yes special messages

        TBT     R7,GXLGMG       :a message for us to expand?
        JNFS    GLP0D2
        CLHI    R7,8            :message with supe text? (unbiased 10)
        JN      LEP0DA,,        :nothing for us to do (msg 12x 8x)
        J       GLPEI4,,        :expand routine

GLP0D2  LA      R4,CRLF         :new line
        JAL     R9,BUFCAN,,
    IF NETNAM
        TBT     CHN,GTTRNS      :transparent?
        JEFS    GL30F           :nope
        LA      R4,HOMEN,,      :name of home net
        JAL     R9,BUFCAN,,
        LA      R4,SPAC         :a space
        JAL     R9,BUFCAN,,
GL30F
     EI :NETNAM

        LIS     R8,0            :starting table index
        TBT     CHN,GTTRNS      :transparent table?
        JEFS    GL30G           :nope
        LHI     R8,LSMSTZ       :moves up a table index
GL30G   TBT     CHN,GTASCI      :asci?
        JEFS    GL30H           :nope
        AHI     R8,LSMSZ        :bump up a table index
        TBT     CHN,GTHDX       :half duplex?
        JNFS    GL30D           :yes
        TBT     CHN,GTAUX       :aux get same table as halfduplex ???
        JEFS    GL30H           :not aux circuit
GL30D   AHI     R8,LSMSZ        :bump up another table index
GL30H   SLHLS   R7,2            :word index
        L       R4,LSMS27,R7,R8 :get the message
        SRHLS   R7,2            :restore r7
        JAL     R9,BUFCAN,,     :output the message

GL30N   LR      R7,R7           :reentry for gl30j
        JLFS    GL30H1          :good messages are 0-5 (before bias 8-D)
        CLHI    R7,5
        JGFS    GL30H1          :not a good one
        LR      R8,R2           :poke into supe buffer flag
        XHI     R8,4            :supe buffer
        LHI     R4,LOGMIN+LOGSUP :set status
        STH     R4,BF,R8,

GL30H1  TBT     CHN,GTTRNS      :transparent?
        JE      LEP0DA,,        :nothing else to do
        TBT     R7,NLSOK        :hang this transparent user?
        JN      LEP0DA,,        :nope
        LHI     R1,1F0          :the hang char
        JAL     R9,W2CI,,
        J       LEP0DA,,        :continue at normal lep finish

:       IIX Subroutine for GLP0DD
:       returns GL30N or LEPIE4 (if supe text)

GL30J   HS      0
    IF NETNAM
: why can a transparent IIX receive CRLF while normal IIX cannot?????
        TBT     CHN,GTTRNS      :transparent user?
        JE      GLPIX2          :nope
        LR      R7,R7           :continue msg?
        JLE     GLPIX2          :yes
        LA      R4,CRLF
        JAL     R9,BUFCAN,,     :new line
        LA      R4,HOMEN,,      :home net name (to an IIX? guess so)
        JAL     R9,BUFCAN,,
        LA      R4,SPAC
        JAL     R9,BUFCAN,,
GLPIX2
    EI :netnam

        LA      R4,IIXLMS,,     :the IIX login status message
        GL      IIXLMS
        JAL     R9,BUFCAN,,     :has everything except the status
        CLHI    R7,8            :unbiased 10 (supe has sent text)
        JNFS    GLPIX3          :nope
        LIS     R1,0            :the null message (means continue)
        JAL     R9,W2CI,,       :0 is continue for the IIX status and esc it
        J       GLPEI4,,        :and now the lep processing does the text

GLPIX3  LB      R1,IXB4TB,R7    :send the proper code (isis style)
        JAL     R9,WCIE,,       :write and maybe escape
        J       GL30N           :done with IIX stuff

GLP30Z                          :r2 starts pointing to supe buffer
        LIS     R0,0            :not talking to supe any more
        STH     R0,BF,R2,       :not flags
        LR      R6,R2           :remove this from logger list
        JAL     R9,LOGCLR,,
: but do not reset LOGING because if DISPI were to read a zapper immediately
: after this routine we would send out accounting and ISIS would crash us.
: The zapper in the outbound buffer is how this port is going to be cleared.
: ###sdw

        XHI     R2,4            :back to port bound buffer
        LHI     R1,ZAPPN        :non gobbling zapper
        JAL     R9,W2CI,,
        J       LEP1,,          :really done



IXB4TB	BC	00,01,02,03,04,05,00,00,00,00,00,08,09,0A,0B,0C,0D,0E,0F
	BC	10,11,12,13		:Translate Node codes to Isis codes

LGCHZZ	HC	0000,0FFE: (> Msg 13x)	:RE-INIT CHARACTER COUNTER?
GXLGMG  HC      7E1F,0FE00 :(09-1E)     :expand for gateway log-in response
NLSOK	HC	$2 1001010111111111,-1
SPAC	SC	/ /;



::*********************************************************************
::
::	ENTRY POINT:	GDB4:	Gateway Dispatcher B4 Message Handler
::	FUNCTION:	Handles the B4 Log-on response.
::	INPUT:		CHN	=  Relative Dispatcher port number
::			R2	=  Buffer number of outbound (to terminal)
::	CALLS:		JAL	R8,GCI
::			JAL	R8,DIMMES
::			JAL	R8,DIRMES
::	RETURNS:	Jumps directly back to DISOUT processing.
::
::*********************************************************************

::      First, check to ensure that this is the correct circuit
GDB4	LB	R1,DORNG,PRD,	:PRD updated by DISOUT routine
	STB	R1,GLGSTA	:Store away status byte
	TBT	CHN,LOGING	:This channel should be in Log-in mode
        JNFS    GDB4GO          :in login mode jump to GDB4GO
        SIS     PRD,3           :not in login: readjust PRD for DSKP3
        LI      R1,0B4          :put message type in R1 for DSKP3
	J	DSKP3,,		:Jump out to DISKIP's error handling
::      Now double check to ensure that the right buffer is used
GDB4GO	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer #
	CR	R1,R2		:These should match
	JN	DSOCRH,,
::      As a triple check, the BF should indiciate Log-in state
GDB402	LHL	R1,BF,R2,	:Get flags field
	clhi	r1,detzfl		:but it can indicate a port being
	jge	dsoirp,,		:detached which is okay
	CLHI	R1,LOGMAX
	JG	DSOCRH,,
	CLHI	R1,LOGMIN
	JL	DSOCRH,,
::      Proceed with login message interpretation
	SBT	CHN,LOGDAT		:Remove log-in wait state
	LB	R10,GLGSTA		:GET STATUS
	THI	R10,40			:CHECK FOR ECHO-ON
	JNFS	GDB41			:SET IF ON
	RBT	CHN,GTLGEC		:ELSE RESET ECHOING
	JFS	GDB41A
GDB41	SBT	CHN,GTLGEC
GDB41A	THI	R10,20			:CHECK IF WE SHOULD FLUSH OUTPUT BUFFER
	JEFS	GDB42			:SKIP IF NOT
	XHI	R2,4			:FLIP TO (to terminal) buffer
	JAL	R8,CBCLR,,		:ELSE DO IT
	XHI	R2,4			:YES, flip to from terminal buffer
GDB42	THI	R10,80			:SHOULD WE EMPTY INPUT BUFFER?
	JE	GDB42B			:NO
	LHL	R0,BCT,R2,		:ANYTHING IN THE BUFFER?
	JLEFS	GDB42B			:NO, ALREADY EMPTY
	JAL	R8,GCI,,		:YES, GET 1ST CHAR
	SIS	R1,3			:IS 1ST CHAR A ZAPPER?
	JNFS	GDB42A			:NO, SKIP
	J	GDZAP			:If so Zap both sides of circuit
GDB42A	JAL	R8,GLBCLR,,		:Clear buffer (special log-on clear)
GDB42B	XHI	R2,4			:Back to inputed R2
	LHI	R11,1F			:SET MASK FOR STATUS BITS
	NR	R11,R10			:EXTRACT MSG #
	TBT	CHN,GIIXCT		:IIX REQUESTED FOR THIS CKT?
	JN	GDB46			:YES
	LR	R11,R11			:CONTINUE?
	JE	DSOIRP,,		:RETURN IF 'CONTINUE'
::	LIS	R0,3		:###EV
::	STB	R0,GLGCNT,CHN,		:Reset character counter
:	CHN  = TYMNET PORT
:	R2  = TO TERMINAL BUFFER
:	R10 = STATUS
:	R11 = MESSAGE INDEX
	LA	R4,CRLF			:OUTPUT C/R L/F
	JAL	R9,BUFCAN,,

	IF	NETNAME
	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JE	GDB42C			:NO, SKIP
	LA	R4,ISISN,,		:OUTPUT NET NAME
	JAL	R9,BUFCAN,,
	LA	R4,SPAC,,		:...FOLLOWED BY A SPACE
	JAL	R9,BUFCAN,,
GDB42C	EI	:(NETNAME)

	LIS	R8,0			:INIT MSG TABLE INDEX
	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JEFS	GDB43A			:NO, SKIP
	AHI	R8,LSMSTZ		:MOVE INDEX TO TRANSPARENT MSGS
GDB43A	TBT	CHN,GTASCI		:IS IT REALLY ASCII TERMINAL?
	JEFS	GDB44			:SKIP IF NOT
	AHI	R8,LSMSZ		:MOVE INDEX TO ASCII MSGS
	TBT	CHN,GTHDX		:HALF-DUPLEX TERMINAL?
	JNFS	GDB43			:SKIP IF SO
	TBT	CHN,GTAUX		:AUX CIRCUIT?
	JEFS	GDB44			:SKIP IF NOT
GDB43	AHI	R8,LSMSZ		:MOVE INDEX TO HDX MSGS
GDB44	
	CHI	R11,5			:MSG#>5, USE SAME LSMS27 TABLE+3
	JLEFS	GDB44A			:<=5, NO+3
	Ais	R11,3
GDB44A	SLLS	R11,2			:FW BOUNDARY OF 4 BYTES
	L	R4,LSMS27,R11,R8	:GET ADDR OF MSG
	JAL	R9,BUFCAN,,		:OUTPUT MSG TO PORT
	SRLS	R11,2

GDB45	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JE	DSOIRP,,		:NO, SKIP
	TBT	R11,NLSOK		:SHOULD MSG BE FOLLOWED BY DETACH?
	JN	DSOIRP,,		:NO RETURN TO MAINLINE
        J       GLGZP                   :go to all in one logon zap routine

:	IIX CKT - SEND LOGIN STATUS BACK TO ORIGIN OF CKT
GDB46	NHI	R10,0BF			:DONT SEND ECHO ON

:	IIX LOGIN STATUS - RETURNS NETNAME (IF NON-TRANSPARENT) AND IIX
:	LOGIN STATUS MSG
:	REQUIRES	R2 = BUFF INDEX
:			CHN = Relative Dispatcher port #
:			R10 = LOGIN STATUS BYTE
	IF	NETNAM
	TBT	CHN,GTTRNS		:Transparent user?
	JE	GB4DX1			:NO, SKIP
	LR	R11,R11			:CHECK MSG TYPE
	JE	GB4DX1			:IF 'CONTINUE', SKIP
	LA	R4,CRLF			:OUTPUT CR, LF
	JAL	R9,BUFCAN,,			:/
	LA	R4,ISISN,,		:OUTPUT NETNAME
	JAL	R9,BUFCAN,,			:/
	LA	R4,SPAC,,		:...AND A SPACE
	JAL	R9,BUFCAN,,			:/
GB4DX1	HS	0
	EI	:(NETNAM)
	LA	R4,IIXLMS		:BEGINNING OF IIX LOGIN STATUS MSG
	JAL	R9,BUFCAN,,			:OUTPUT IT
GB4DX4	LR      R1,R11
	JAL	R9,WCIE,,		:/
	J	GDB45


::*********************************************************************
::
::	ENTRY POINT:	GDB5:	Gateway Dispatcher B5 Message Handler
::	FUNCTION:	Handles the B5 Log-on response.
::	INPUT:		CHN	=  Relative Dispatcher port number
::			R2	=  Buffer number of outbound (to terminal)
::	CALLS:		JAL	R8,GCI
::			JAL	R8,DIMMES
::			JAL	R8,DIRMES
::	RETURNS:	Jumps directly back to DISOUT processing.
::
::*********************************************************************


::      First, check to ensure that this is the correct circuit
GDB5	TBT	CHN,LOGING	:This channel should be in Log-in mode
	JE	GDB5SK		:Small Error, just skip it.
::      Now double check to ensure that the right buffer is used
	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer
	CR	R1,R2		:These should match
	JE	GDB5SK		:They do - proceed
	J	DSOCRH,,	:No match  .. big problem
::      As a triple check, the BF should indiciate Log-in state
GDB5SK	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH,,
	CLHI	R1,LOGMIN
	JL	DSOCRH,,
::      A zapper will follow this but we will implant a nongobl zap 
::      and clean up dispatcher side right now
        XHI     R2,4                    :point R2 back to term direction
        TBT     CHN,GTTRNS
        JN      GLGZP                   :don't send why on transparent
        LA      R4,LTX103,,             :interlink lost msg
        JAL     R9,BUFCAN,,
        J       GLGZP                   :and zap


::*********************************************************************
::
::	SUBROUTINE:	GDB6:	Gateway B6 message handler
::	FUNCTION:	Completes the Gateway LOg-in from HNET to INET.
::	CALLS:
::	RETURNS:	Jumps directly to DSOIRP.
::
::*********************************************************************

::      First, check to ensure that this is the correct circuit
GDB6	TBT	CHN,LOGING	:This channel should be in Log-in mode
        JNFS    GDB6GO          :in login mode jump to GDB4GO
        SIS     PRD,3           :not in login: readjust PRD for DSKP3
        LI      R1,0B6          :put message type in R1 for DSKP3
	J	DSKP3,,		:Jump out to DISKIP's error handling
::      Now double check to ensure that the right buffer is used
GDB6GO	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer
	CR	R1,R2		:These should match
	JE	GDB602		:They do - proceed
	J	DSOCRH,,		:Crash
::      As a triple check, the BF should indicate Log-in state
GDB602	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH,,	:Crash
	CLHI	R1,LOGMIN
	JL	DSOCRH,,
::	SUCESSFUL LOGON
	LB	R1,DORNG,PRD,		:GET IIX FIELD (PRD advanced prior)
	LBR	R13,R1			:SAVE IIX BIT
	AIS	PRD,1
	NR	PRD,TC			:Move ring pointer to invoice number
	L	R1,DORNG,PRD,
	ST	R1,ININV		:SAVE ISIS-NET NET INVOICE #
	AIS	PRD,4
	NR	PRD,TC			:Advance pointer again
::      Now each Network must send the other its Invoice number
	IF	ACCT
	STM	R1,AARGSV
	LR	R3,CHN			:dispatcher chn to acct index reg
	AHI	R3,DISZFL-MNACHN	:Make accounting index
	AAMKPT(R3)			:Get the block pointer (R11)
	JAL	R10,AASWAP		:EXCHANGE INVOICE #'S
GDBSKP	LM	R1,AARGSV
	EI	:(ACCT)
::      Toss originating host number, we don't need it
	AIS	PRD,2
	NR	PRD,TC
	RBT	CHN,LOGING		:NO LONGER IN LOGIN MODE
	TBT	CHN,GIIXCT		:WAS IIX REQUESTED?
	JEFS	GDB62			:NO
	LA	R4,IIXGRS		:YES, ASSUME GW REACHED SMART HOST
	SRLS	R13,1			:IIX BIT SET?
	JCFS	GDB61			:YES
	LA	R4,IIXGRD		:NO, GW REACHED DUMB HOST
GDB61	XHI	R2,4			:FLIP TO TO-TERM BUFFER
	JAL	R9,BUFCAN,,		:RETURN MSG TO ORIGIN
	XHI	R2,4			:FLIP BACK TO F. T. BUFFER	###EV
::      Now connect the circuit and let data flow.
GDB62	LR	R1,R2			:Use work register
	SRLS	R1,1			:Make fullword index
	L	R0,FASTC,,
	ST	R0,BUFTIM,R1,		:Store Needle origination time
	LIS	R0,0
	STH	R0,GDLGTB,CHN,CHN	:Zero out scratch table
::      Turn on Dispatcher port
	SBT	CHN,DISBPV		:Relieve backpressure,
	RBT	CHN,LOGING		:remove from Log-in status
	LHI	R0,INXLIM		:and set up intital
	STH	R0,DIXLIM,CHN,CHN	:transmit capacity
	AHI	CHN,DISZFL		:Make absolute channel number

::                                      Continue circuit building 
	XHI	R2,4			:and get outbound (to term) buf#
	JAL	R9,CRQHCR		:Complete actual circuit
::                                      Report IRC to Inet sup
	IF	IRC
	LHL	R3,BF,R2,		:ABSOLUTE CHAN#
	JAL	R9,FCHLNK		:FIND LINK# IN R0
	SKIPAD(GDB63)			:immed return, Error return	###wjl
	LR	R1,R0			:+4 return, For indexing purposes
	LB	R7,IRCTBL,R1		:IS THERE IRC VALUE THIS LINK?
	JE	GDB63			:NO REPORT IF NO IRC VALUE
	STB	R7,GB7REA		:STORE INTO CANNED GB7 MSG.
	LHI	R1,-DISZFL,CHN		:GET RPORT
	STH	R1,GB7PRT
	LHI	R1,0E00E		:MSG.# 14 FOR IRC LOCATN DEFINED
	STH	R1,GB7INV		:Renew message type
	LIS	R1,0
	STB	R1,GB7INV+2		:(may have been previously used)
	LA	R1,GDB7M		:IRC ACCT.MSG. REPORT
	LHI	R3,GDB7L		:LENGTH BYTE
	JAL	R8,DIZSMS		:TO DISPATCHER PORT 0
GDB63
	EI	(IRC)
::      Merge speed bits from origin side of circuit
	LHL	R1,BF,R2,		:Get other channel number
	LHL	R1,IOTAB,R1,R1		:Get permuter table entry
	NHI	R1,3			:Get speed bits
	LHL	R0,IOTAB,CHN,CHN	:Get table entry for circuit completion
	OR	R0,R1			:Install speed bits
	STH	R0,IOTAB,CHN,CHN	:Replace table entry
::                      Report to crypto log 
GDBC64	LHL	R0,BF,R2,		:Log first port
	EXHR	R0,R0
	XHI	R2,4
	LHL	R8,BF,R2,		:Then the other one
	AR	R0,R8
	JAL	R8,CRYPTO,,
	HC	CRYE0B
       if	cmpnul
	xhi	r2,4			:send to origination
	lhi	r1,01E0			:do you want to compress?
	jal	r9,w2ci,,		:back to orig
	xhi	r2,4			:restore buffer
       ei	:cmpnul
	LHL	R1,BCT,R2,		:Anything in F.T. buffer?
	JEFS	GDB573
	LHL	R1,BF,R2,
	SBT	R1,NFLAGS		:Set attention flag

GDB573	J	DSOIRP,,		:and continue

IIXGRS	XC	0401F68082		:SIIX + GW Reached smart host
IIXGRD	XC	0401F68083		:SIIX + GW Reached dumb host

::*****************************************************************
:
:       GLGZP   is called by GDB4 and GDB5 when they want to zap a circuit in
:               logon mode.
:
::*****************************************************************

:       following is entry for LOG I gateways
GLGZP   TBT     CHN,GTTRNS              :transparent get no cleared msg
        JE      GLGZP1
        LA      R4,GNGONE,,
        JAL     R9,BUFCAN,,             :interlink cleared
        ROUTE(HOMEN,ISISN)
        LHI     R1,0D0A
        JAL     R9,W2CI,,
GLGZP1  LHI     R1,ZAPPN                :don't eat that wonderful msg
        JAL     R9,W2CI,,               :write non gobbling back to user
        LHI     R1,9F00                 :kill isis side immediately
        JAL     R8,DIRMES,,
        LIS     R0,0
        STH     R0,GDLGTB,CHN,CHN       :pass one of our checks
        lis     r0,aalr02               :zapped by host
        sth     r0,aareas,,             :save reason for termanation
        lhi     r3,diszfl-mnachn,chn    :get absolute accounting chn
        jal     r8,aarlo,,              :do termation accounting
        lis     r0,0                    :clear accounting reason area
        sth     r0,aareas,,
        XHI     R2,4                    :flip to from term side
        STH     R0,BF,R2,
        RBT     CHN,LOGING              :clean up dispi side
        JAL     R9,GLZPV,,              :really clear it
        J       DSOIRP,,                :and contiue processing


::*********************************************************************
::
::	ENTRY POINT	GLZ9:
::	FUNCTION:	Handles a Pseudo Needle Reject (Type 09) for Gateway.
::	CALLS:		JAL	R9,BUFCAN
::			JAL	R9,ZAPX,,
::	RETURNS:	J	DSOIRP,,
::
::*********************************************************************

GLZ9	AIS	PRD,4           :Advance ring pointer
	NR	PRD,TC		:Move pointer to local key
::                       First, check to ensure that this is the correct circuit
	LHL	R2,DORNG,PRD,	:Local key should be buffer number
:                               :The BF should indicate Log-in state
	AIS	PRD,3
	NR	PRD,TC
	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH,,
::BF shows in Log-in state .. proceede
: Since host shuts when we don't have INET supe this can only happen to
: needles built before HNET got our shut msg.
        jal     r9,g2ci,,               :needle point
        jal     r9,g2ci,,               :length
        jal     r9,g2ci,,               :link count
        jal     r9,ghwi,,               :start of invoice number
        sth     r1,cqinv                :save 1st 1/2 of inv
        jal     r9,ghwi,,               :2nd hw of inv
        sth     r1,cqinv+2
        lhi     r5,diszfl               :dispatcher port 0 is never used
                                        :so momentarily use its accounting
                                        :block.
        jal     r8,aastrt,,             :initialize accounting
        j       glz9p9
        lis     r0,aalr02               :zapped by host
        sth     r0,aareas
        jal     r8,aarlo,,              :send termination accounting
glz9p9  
	XHI	R2,4			:Point to outbound (to terminal) buf
        LHI     R1,ZAPPN                :
        JAL     R9,ZAPX,,
	LIS	R1,1
	AHM	R1,NC.CRZ		:Count uncompleted circuit for CRQ
	J	DSOIRP,,		:AND QUIT FOR NOW

::*********************************************************************
::
::	ENTRY POINT	G02NUP:	##AL
::	FUNCTION:	Handles INET node taken up. (Type 02) for Gateway.
::	CALLS:		JAL	R10,SUP11
::	RETURNS:	J	DSOIRP
::
::*********************************************************************

G02NUP	LB	R1,DORNG+3,PRD,		:new supe number
	JNFS	G02NU1			:ISIS 5.08 puts a zero here
	LHI	R1,7F			:not a real supe # but nonzero
G02NU1	STB     R1,G0DFG                :save supe
	AIS	PRD,4			:ADVANCE MSG LENGTH IN PTR
	NR	PRD,TC			:WRAP TO A HW
        LIS     R10,0                   :init answerred
        LHL     R1,TVRBUF               :have Hnet supe?
        JNFS    G02NU2                  :yes
        LIS     R10,2                   :shut if not
G02NU2  LB      R1,HSTAT                :what was old host stat
        STB     R10,HSTAT               :save host status
        CR      R1,R10                  :find if any changes
        JE      DSOIRP,,                :no changes to report
	JAL	R10,SUP11,,		:HST RPT FROM GW TO HNET SUP
        LB      R3,HSTAT                :it wants our status.
        JAL     R10,GHSTST              :tell inet about us
	J	DSOIRP,,

::*********************************************************************
::
::	SUBROUTINE:	DSZHUA:
::	FUNCTION:	0B - Host Unacceptable
::	FORMAT:
::		--------.-------.-------.--------
::		|	0	|  0B	|  key	|
::		|-------.-------.-------.-------|
::		|  Host number	| error |unused	|
::		----------------.-------.--------
::
::	error code currently has these values:
::			0	host table ful (in NodeCode)
::			1	impostor, rejected by SUP
::			2	impostor, rejected by node
::			3	illegal host on restricted node
::
::	If the NodeCode has no more host table space, and an attempt was
::	made to bring a NEW host to a state other than GONE, then the
::	NodeCode will issue this diagnostic message (with error = 0)
::	back to the gateway.
::
::	If the new host number already exists, either on the node or
::	elsewhere within the network,this host is classes as an impostor,
::	and rejected.  The dispatcher will set the host GONE.
::
::	This message is only valid if received from the dispatcher by
::	a gateway.  The gateway treats this message as any other slot would
::	crashng with crash type      .  A crypto message is also displayed
::	prior to the slot crashing.
::
::*********************************************************************

DSZHUA	LB	R0,DORNG+6,PRD,		: get error code
	STH	R0,CRYSBF		: save for crypto message
	LHL	R0,DORNG+4,PRD,		: get specified host number
	JAL	R8,CRYPTO,,		: send crypto message
	 HC	CRYE3F			:
	CRASH.(.DISHS)			: crash slot

::*********************************************************************
::
::	ENTRY POINT	G0DNSP:	##AL
::	FUNCTION:	Handles INET no sup. (Type 0d) for Gateway.
::	CALLS:		JAL	R10,SUP11
::	RETURNS:	J	DSOIRP
::
::*********************************************************************
G0DNSP	AIS	PRD,4			:ADVANCE MSG LENGTH IN PTR
	NR	PRD,TC			:WRAP TO A HW
	LIS	R1,2			:set host shut
	STB	R1,HSTAT
	LIS	R1,0                    :no supe on INET side
	STB	R1,G0DFG		:SET A FLAG FOR NODE TAKEN AGAIN
	JAL	R10,SUP11,,		:HST RPT FROM GW TO HNET SUP
	J	DSOIRP,,

IIXGW	XC	0801F68080808201F7	:IIX REACHED GATEWAY MSG (SELECT GW DIALECT)
IIXMS1	XC	0601F680840001		:IIX 'PLEASE LOG IN' MSG
IIXLMS	XC	0401F68084		:START OF IIX LOGIN STATUS MSG


::*********************************************************************
::	DIRECT ENTRY-
::	SUBROUTINE:	GNEDIN:	Gateway NEDle IN
::	FUNCTION:	Gateway Needle front end handler.  Called from
::			DISKIP+0A when a Needle is received on an un-
::			assigned Dispatcher port.  (This is only legal
::			for the Gateway.)  This routine serves to initiate
::			Gateway Log-on processing from the INET side.
::	CALLING SEQ:	JE	GNEDIN	:(based on getting Type 00 on port)
::	INPUT:		CHN	=  Dispatcher Port Number
::			PRD	=  Pointer to data in ring (empty cursor)
::	CALLS:		
::	RETURNS:	Returns to previously stored R8 return address
::			to jump to DSONXT.
::
::*********************************************************************

GNEDIN	ST	R8,GDSAVE	:Save return address 
	STH	PRD,GDPRD	:Save PRD for restoration of ring pointer
	LB	R8,DORNG+3,PRD,	:Gets length of total Needle
	STB	R8,GDNLEN
	AIS	PRD,4
	NR	PRD,TC		:Now we're pointing to Invoice number
	L	R1,DORNG,PRD,	:Get INvoice #
	ST	R1,GDNINV	:Save this temporarily
	AIS	PRD,4
	NR	PRD,TC		:Now we're pointing at Dest. Host #
	LHL	R1,DORNG,PRD,	:Get Desination Host number (should
	CHI	R1,IHOST	: be IHOST for Gateway)
	JN	GDNERR		: Error, zap circuit
        JAL     R7,GNEIZ        :initialize flags and arrays and logon  ###sdw
	IF	ACCT
::Store invoice number for internet exchange
        LHI     R3,DISZFL-MNACHN,CHN  :convert to relative account chn
	JL	GNED01 
	CLHI	R3,MXACHN
	JG	GNED01
	AAMKPT(R3)		:Get the block pointer (R11)
	L	R0,GDNINV	:Get previously stored invoice number
	sbt	r3,aaorig	:origination so accounting not done
	ST	R0,AAINV,R11	:Store in Acct. blk
	EI	:(ACCT)

::Now begin to fill log-on buffer, starting with Host number
GNED01	LHI	R1,HHOST	:This log-on is from INET toward HNET
	OHI	R1,8000		:Prepare host # for Sup message
	JAL	R9,WHWI,,	:Write into login buffer
	
	AIS	PRD,08
	NR	PRD,TC		:Now pointing to word with TPC at end
	LB	R1,DORNG+3,PRD,	:Get TPC
	STB	R1,GDTPC	: and store for later use
	AIS 	PRD,4
	NR	PRD,TC		:Now pointing to Dialect and TID
	LHL	R1,DORNG,PRD,	:Get dialect field
	STH	R1,GDDIAL	:Store for later

::Determine intelligence of circuit
	EXHR	R1,R1		:Less than 0 = HO bit set
	JGEFS	GNED02		:Not IIX, proceed
	SBT	CHN,GIIXCT	:Indicate as IIX circuit
	
GNED02	LHL	R1,DORNG+2,PRD,	:Get CCT and usrname size
	STH	R1,GDCCT	:and store for later
	EXBR	R1,R1		:Get CCT byte
	STB	R1,CCTTBL,CHN	:and table it for possible future reference???
	AIS	PRD,4
	NR	PRD,TC		:Now points to beginning of username

::Write whatever TID we have into buffer with Cntrl chars if needed
	LBR	R6,R1		:Save TID
	NHI	R1,1F		:Mask to get TID
	JE	GNEAUX		:If Aux-circuit TID (00)
	THI	R6,20		:If Half-Duplex TID
	JEFS	GNE010		:Not Hdx, more tests ...
	SBT	CHN,GTHDX	:Mark this one as Half dux
	J	GNE020
GNE010	LHI	R0,-8,R1	:If not Hdx then what about oddball 2741 etc.
	JL	GNE020		:Test for 2741 or 3767 terminal types
	SIS	R0,9-8
	JGFS	GNE020
	SBT	CHN,GTHDX	:This oddball is HDX
	RBT	CHN,GTECHO	:No echo allowed
	RBT	CHN,GTASCI	:A special distinction as HDX ascii 2741
	JFS	GNE020		:Now write it to buffer
GNEAUX	SBT	CHN,GTAUX	:Mark this one as Aux circuit
	RBT	CHN,GTECHO	:Suppress echo for Aux circuit
	LHI	R1,GAXTID	:Exchange for Gateway Aux TID '0E'
	JFS	GNE021
GNE020	LBR	R1,R6		:Get TID again
	OHI	R1,0C0		:Restore mask

GNE021	JAL	R8,WCI,,	:Write TID into buffer
        JAL     R8,CBCCT,,      :how many already in buffer
        STB     R1,GLGCNT,CHN,

::Continue processing with Username treatment
	TBT	CHN,GTHDX
	JEFS	GNE024
	LHI	R1,88		:For Half Duplex terminal
	JAL	R8,WCI,,	:Put CNTRL-H into buffer
GNE024	LB	R4,GDUNSZ	:Load username counter
	LB	R0,DORNG,PRD,	:First username character
	CLHI	R0,GXPRNT	:Is it "?" (0BF) ? (Transparent gateway user)
	JN	GNE026		:If not, flush name and continue

::For Transparent user, just copy Username
	AIS	PRD,1
	NR	PRD,TC		:Discard ?(BF) preceeding username
	SBT	CHN,GTTRNS	:Set as Transparent user
	RBT	CHN,GTLGEC	:Turn echo off
	LB	R1,GDTPC	:Get Througput class
	NHI	R1,3		:ONLY 2 bits on
	LB	R1,TPTBL,R1	:Get ascii from table
	JAL	R8,WCI,,	:Write cntrl-char for tput class to buffer

GNE025	SIS	R4,1		:Decrement counter (from usrnm+1)
	JEFS	GNE030		:Finished? then continue logon

	LB	R1,DORNG,PRD,	:Get Username character
	JAL	R8,WCI,,	:Put into log-on buffer
	AIS	PRD,1
	NR	PRD,TC
	J	GNE025		: until all characters transferred

GNE026	LB	R0,GDUNSZ
	AR	PRD,R0
	NR	PRD,TC		:Flush Username
	IF	0:EV1	(possible future implementation)
	LB	R1,GDTPC	:Get Througput class
	NHI	R1,3		:ONLY 2 bits on
	LB	R1,TPTBL,R1	:Get ascii from table
	JAL	R8,WCI,,	:Write cntrl-char for tput class to buffer
	EI	:EV1
:	Send banners etc. to terminal
GNE030	XHI	R2,4		:Flip to terminal bound buffer
	TBT	CHN,GIIXCT	:If IIX circuit
	JEFS	GNE032		:No
	LA	R4,GIIXGW	:If IIX, send 'reached IIX Gateway"
	JAL	R9,BUFCAN,,	:Send it
GNE032	TBT	CHN,GTTRNS
	JN	GNE035		:Yes, don't send banner

GNE033	LA	R4,GNETOK,,	:If not Xprnt nor IIX send 'interlink' banner
	JAL	R9,BUFCAN,,
	ROUTE(ISISN,HOMEN)
	LA	R4,CRLF
	JAL	R9,BUFCAN,,
	LA	R4,LTX000,,
	TBT	CHN,GIIXCT
	JEFS	GNE034
	LA	R4,GIXPLI	:If IIX load IIX PLI message
GNE034	JAL	R9,BUFCAN,,


GNE035	TBT	CHN,GIIXCT	:See if 'smart' bit is set
	JEFS	GNE037		:No bit set, proceeed
	LHL	R4,BF,R2,
	LHL	R1,IOTAB,R4,R4
	AIS	R1,1		:'Gouging --  bit in LOg-in mode
	STH	R1,IOTAB,R4,R4	:means 'smart' 

GNE037	XHI	R2,4		:back to logon (to sup) buffer
        J       GNEXIT

::*********************************************************************
::
::	ENTRY POINT:	GDNERR:	Gateway Dispatcher NEedle ERRor
::	FUNCTION:	Sends Zap back on Dispatcher port which had 
::			sent a Needle on an unassigned port - due to
::			some circuit building error.
::	CALLING SEQ:	JUMP directly to GDNERR
::	INPUT:		CHN 	= Channel (relative dispatcher port)
::	RETURNS:	Jumps directly to GNEDIN exit point.
::
::*********************************************************************
GDNERR	LHI	R1,9F00
	JAL	R8,DIRMES,,		:Send zapper on Dispatcher port
	J	GNEXIT			:And finish turn off


::*********************************************************************
::
::	GNOSUP:		Sends "unable to complete inter-link" to terminal 
::			user -  due to no Supervisor on the HNET side
::	CALLING SEQ:	JUMP directly to GNOSUP
::	INPUT:		CHN 	= Channel (relative dispatcher port)
::	RETURNS:	Jumps directly to GNEDIN exit point.
::
::*********************************************************************
GNOSUP	LA	R1,GNONET,,		:put nonet towards dispatcher
	JAL	R8,DIMMES,,
	LHI	R1,9E00		:Must Zap incoming circuit
	JAL	R8,DIRMES,,

::Now all Needle front end for Log-on buffer is complete - restore
::ring pointer and return exit to DSONXT

GNEXIT	LB	R0,GDNLEN	:Get additional length of needle
	AIS	R0,4		:Make it total length
	LHL	PRD,GDPRD	:Restore pre-needle ring pointer
	AR	PRD,R0		:..and do virtual flush of needle
	NR	PRD,TC
	STH	PRD,DROE,,	:Update ring pointer
	L	R8,GDSAVE	:Restore return address
	JR	R8		:Return to Dispatcher processing


::*****************************************************************
:
:       GNEIZ   initialize all of the flags and arrays for a INET needle
:               (both LOG I and LOG II INET needles).  Link on R7,      ###sdw
:
::*****************************************************************

GNEIZ   HS      0
:       Check to see if Sup exists -- either proceeed or abort
	LHL	R3,TVRBUF
	JE	GNOSUP		:Output "NO Net" message to INET user
:       Now set up Log-on buffer
	JAL	R8,GFCBUF,,	:Get a free buffer (returned in R2)
	SKIPAD(GDNERR)		:immed return - Error, zap circuit	###wjl
	AHI	CHN,DISZFL	:Make Dispatcher port into absolute CHN
	JAL	R9,CRQHCR,,	:+4 return - Build half circuit to buffer
        SHI     CHN,DISZFL      :back to rel dis chn

:       Initialize all log-on related bit arrays
	RBT	CHN,GTAUX	:Aux circuit thru Gateway
	RBT	CHN,GTHDX	:For Half-Duplex terminals
	SBT	CHN,GTASCI	:Not a 2741 TID
	SBT	CHN,GTECHO	:Echo permitted for this terminal
	SBT	CHN,GTLGEC	:Start log-in in Echo mode
	RBT	CHN,GTTRNS	:Assume non-transparent user
	RBT	CHN,GIIXCT	:Assume non-IIX circuit
	RBT	CHN,DISELS	:Not Extended log-on status (for node code)
	RBT	CHN,DISAUX	:Not Aux circuit (for node code)
       if	cmpnul
	rbt	chn,nulcom	:compress starts of disabled
       ei	:cmpnul
	LIS	R0,0		:Initialize logon character counter
	STH	R0,GDLGTB,CHN,CHN
	SBT	CHN,DISBPV	:Release back pressure
	SBT	CHN,LOGING	:Mark as in Log-on state
	SBT	CHN,GMSG0F	:..and having data for the Log-in
	LHI	R0,INXLIM
	STH	R0,DIXLIM,CHN,CHN	:Set up transmit limit
	SBT	CHN,GORGPT	:Mark channel as an originating port
	RBT	CHN,GDSTPT
	LR	R1,R2
	LIS	R2,LOGBUF	:Put buffer on LOGGER's list
	JAL	R9,WHWI0,,
	LHI	R0,LGST.N	:Init N.C. & TID ready flag
	STH	R0,BF,R1,	:Set BF to log-on state
	LR	R2,R1
	SRLS	R2,1		:Set buffer timer index
	L	R9,SLOWC,,
	AHI	R9,GLGTMR	:Set 2 minute timer
	ST	R9,BUFTIM,R2,
	SLLS	R2,1		:restore buffer index

	LHL	R1,HNPORT	:Increment  port counter
	AIS	R1,1
	CLH	R1,MXPORT
	JLEFS	GNEMXP		:Not a new peak
	STH	R1,MXPORT	:otherwise store it
GNEMXP	STH	R1,HNPORT
	LHI	R1,HHOST	:Housekeeping - store host number for
	STH	R1,DHSTIX,CHN,CHN	:possible circuit trace
        JR      R7              :and done




::Throughput class table indexed by TPCLASS field in ISIS Needle
TPTBL	BC	81,82,83,84	:CNTRL-A, B, C, D.

::Various messages for Log-on processing from INET to HNET

GIIXGW	XC	0801F68080808201F7	:IIX reached Gateway(select GW dialect)
GIIXG2	XC	0801F68080809401F7	:LOG II Gateway dialect
GIXPLI	XC	0601F680840001		:IIX 'Please Log In'



::*********************************************************************
::
::	SUBROUTINE:	DIZSMS:
::	FUNCTION:	Moves canned control messages to dispatcher input
::			ring on Dispatcher Port, toward Slot 0. (for Gateway)
::			Port is supplied to message template or defaulted to 0.
::	CALLING SEQ:	JAL	R8,DIZSMS
::	INPUT:		R3 = length of string
::			R1 = address of message 
::	REGISTER USAGE:	
::			R0 = character being moved
::			R14 = work register
::			R15 = drif ( DISPI input ring fill pointer)
::
::*********************************************************************

DIZSMS	STM	R14,DIMMSV		:SAVE WORKING REGISTERS
	LR	R14,R8			:SAVE RETURN REGISTER
	LR	R0,R3			:GET LENGTH
	ST	R3,DZLEN		:Store length for a while
	AIS	R0,6			:ALLOW FOR MAXIMUM MESSAGE SIZE
	JAL	R8,DIROOM,,		:WAIT FOR ROOM
	LHL	R15,DRIF,,		:GET FILL POINTER
	L	R3,DZLEN		:Get length to initialize
DIZS01	LB	R0,0,R1			:GET CHARACTER
	STB	R0,DIRNG,R15,		:PUT IT IN RING
	AIS	R1,1			:UPDATE MESSAGE POINTER
	AIS	R15,1			:MOVE FILL POINTER
	NHI	R15,DRSZ-1
	SIS	R3,1			:DONE?
	JN	DIZS01			:NO, CONTINUE
	AIS	R15,3
	NHI	R15,DRSZ-4
	STH	R15,DRIF,,		:DONE
	LR	R8,R14			:RESTORE LINK REG
	LM	R14,DIMMSV		:RESTORE WORKING REGS
	JR	R8			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	GCKPST:
::	FUNCTION:	Informs Slot 0 if Gateway has port sts changed,
::			Also informs Hnet sup when out of ports.
::	CALLING SEQ:	JAL	R10,GCKPST	
::	INPUT:		R3	=  current port value
::	OUTPUT:		Message on Port 0 to Dispacher  (Type 0A)
::	RETURNS:	JR	R10
::
::*********************************************************************

GCKPST	LR	R3,R3		:GAVPTS=0?
	JN	GCKP01
	LR	R4,R3		:SAVE R3
	LHL	R2,TVRBUF	:SUP PRESENT?
	JE	GCKP02		:SKIP IF NO SUP BUF
	LHI	R1,8000+MACHNM	:SENT 148F OUT OF PORTS TO HNET SUP
	JAL	R9,WHWI,,	: 6 BYTES MSG
	LHI	R1,148F		:GW TO SUP MSG
	JAL	R9,WHWI,,
	LHL	R1,HOSTN	:GW SLOT HOST NO.
	JAL	R9,WHWI,,
	LHI	R1,1
	STB	R1,MG148F	:SET SENT FLAG
	LR	R3,R4		:RESTORE R3
	J	GCKP02
GCKP01	LB	R1,MG148F	:CHECK 148F SENT FLAG
	JE	GCKP02		:SKIP IF IT'S NOT SENT
	LHL	R2,TVRBUF	:SUP PRESENT?
	JE	GCKP02		:SKIP IF NO SUP BUF
	LR	R4,R3		:SAVE R3
	LHI	R1,8000+MACHNM	:SENT 1490 HST HAS PORTS TO HNET SUP
	JAL	R9,WHWI,,	: 6 BYTES MSG
	LHI	R1,1490		:GW TO SUP MSG
	JAL	R9,WHWI,,
	LHL	R1,HOSTN	:GW SLOT HOST NO.
	JAL	R9,WHWI,,
	LHI	R1,0
	STB	R1,MG148F	:RESET SENT FLAG
	LR	R3,R4		:RESTORE R3
GCKP02	CLH	R3,DZ0APT	:Compare with the last port value
	JER	R10		:Return if same port,no change
	STH	R3,DZ0APT	:Insert new port value in message
	LA	R1,GDZ0AM,,	:Get address of message
	LHI	R3,GDZ0AL	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	GHSTCT:
::	FUNCTION:	Informs Slot 0 that Gateway Inet host has cost
::	CALLING SEQ:	JAL	R10,GHSTCT
::	INPUT:		None
::	OUTPUT:		Message to Port 0 of Dispacher  (Type 0C)
::	RETURNS:	JR	R10
::
::*********************************************************************

GHSTCT	LA	R1,GDZ0CM	:Get address of message
	LIS	R3,GDZ0CL	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	GHSTST:
::	FUNCTION:	Informs Slot 0 that Gateway has host and status
::	CALLING SEQ:	JAL	R10,GHSTST	
::	INPUT:		R3	=  Status of host
::	OUTPUT:		Message on Port 0 to Dispacher  (Type 10)
::	RETURNS:	JR	R10
::
::*********************************************************************

GHSTST	STB	R3,DZ10ST	:Insert status bits in message
	LHL	R3,GAVPTS	:The latest no. of ports
	STH	R3,DZ10PT	:stored
	LA	R1,GDZ10M	:Get address of message
	LIS	R3,GDZ10L	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

	EI	:T2GATE		:###ev

        ENDMO.(GATWAY)
       EI       :KILLIT

:	***NOTHING PAST THIS POINT***



        SUBTTL  XRAYGG (Username Validation List)

::####################################################################
::
::	MODULE:		XRAYGG
::
::	FUNCTION:	Generate the xray good-guy list, for
::			internal host usage.
::
::	SUBTTLS:
::	        XRAYGG (Username Validation List)
::
::   	Moved list to seg d, because large good-guy list in seg 1 causes
::	rx2/rx3 problems and maxes out seg 1.  ###sln
::	Killed individual macros after use because assembler couldn't
::	handle additional symbols.  ###sln
::	Corrected extra-room logic to handle large list.  ###sln
::####################################################################

        IF      1-KILLIT
        BEGMO.

	SEG.(a.xray)


::*********************************************************************
::
::	XRAYGG:	USERNAME VALIDATION LIST
::              TARG is defined by XGGXxx macro and targets which are not
::              present on the node are not included.                   ###sdw
::
::*********************************************************************

XGGXIX  EQ      0               :no unames have been target for IIXRAY
XGGXDW  EQ      0               :no unames have been target for downline load
XGGXSC  EQ      0               :no unames have been target for SCLP

XRAYGG	HS	0

	IF	XGGCNT		:generate the good-guy entries
QQ	EQ	0
QQQ     EQ      XGGCNT
	RE	QQQ             :may reduce XGGCNT within repeat block  ###sdw
	XGX|$0QQ|		:macro removes entries for nonexist targs###sdw
	kill	xgx|$0qq|	:not needed in symbol
QQ	EQ	QQ+1
      IF	1-XGGXGO			:entry not made
XGGCNT	EQ	XGGCNT-1		:one fewer entry
      EI	:1-XGGXGO
	ER
	EI	:XGGCNT

       if	t2gate		:gateway's tty user implicitly has the priv
xggpgg	eq	4
       ei	:t2gate


	if	xggpgg		:can modify/insert/purge goodugy list
	re	8*xggsiz/2	:allow 8 new entries to be enterred
	hc	0		:  initialized to zero
	er
	ei	:xggpgg
XGGLEN	EQ	.-XRAYGG

xggcnt	eq	0
	gg(0,0,LOCAL XRAY)
ttygg	XGX0
	kill	xgx0

      if	1-t2gate
      IF        1-XGGXDW	:no downline load entry
 REMARK%%ERROR -- Node cannot downline load neighbor unless an Xray
 REMARK%%    goodguy entry is targeted to T.DLOAD.  Please correct the
 REMARK%%    goodguy list.
	KILLER(1)
      EI        :XGGXDW
      ei	:1-t2gate

       if	1-xggpgg	:no names can change goodguy list
 REMARK %%SECURE NODE: Goodguy List cannot be modified since no Goodguy Name
 REMARK %has P.GG privilege.%
       ei	:1-xggpgg

	ENDMO.(XRAYGG)
	EI	:1-KILLIT

:	***NOTHING PAST THIS POINT***


	SUBTTL XRAY

:			*   *  ****     *   *   *
:			 * *   *   *   * *   * *
:			  *    ****   *****   *
:			 * *   *  *   *   *   *
:			*   *  *   *  *   *   *

::#####################################################################
::
::	MODULE:		XRAY
::
::	FUNCTION:	TYMNET-II NODE OPERATIONS MONITOR
::
::	REGISTER CONVENTIONS:
::		KX  = R11	:pointer to linK descriptor (Xray)
::		XD  = R15	:pointer to Xray user block Descriptor
::	ROUTINES:
::		XRAY command table
::		XRYSCH:  Scheduler
::		Utility routines for scheduling remote XRAY
::		Main command loop
::		Commands
::		Utility routines
::
::#####################################################################

	IF	1-KILLIT		:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

	SEG.(0D)		:XRAY RUNS IN SEGD

:	>>CRYPTOGRAM values now defined in DATA for structured reference<<
:	>>SRESER - Symbol Reserved area moved to end of SEGD (FIN)<<

	SUBTTL	XRAY (Cryptogram data)

	RA	0			:RESTORE HEX RADIX


	SUBTTL	XRAY (XRAY command table)

::*********************************************************************
::
::	TABLE:		COMTBL
::	FUNCTION:	XRAY COMMAND TABLE
::
::*********************************************************************

:	structure of command table
q	eq	.
	org	0

xcmstr	hs	1		:command name
xcmadr	hs	1		:command routine
xcmarg	hs	1		:stuff like x.aud, x.rar
xcmpwr	hs	1		:indication of power
xcmmin	bs	1		:min number of args
xcmmax	bs	1
       if	.help.
xcmhlp	hs	1		:address of help string for this cmd
       ei	:.help.
	hs	0
comtsz	eq	.		:size of table
	org	q

:	XCOMP. macro defaults to not audited, not read-own-args,
:	regular prompt.

on	eq	1

DFXCM.	MACRO(NAME,MNEM,SWITC,ARGMN,ARGMX,POWER,ARG1,ARG2,ARG3,ARG4)[
       if	qqqhlp
 remark%%FATAL ERROR IN XRAY CODE.  COMMANDS ARE DEFINED INCORRECTLY.
 remark %Help definition macro missing between command definition macros.
	quit	1
       ei	:qqqhlp
qqswi	eq	(SWITC)
       if	(SWITC)
	AC	/MNEM/
	HC	NAME-segd
q1	eq	ARG1
q2	eq	ARG2
q3	eq	ARG3
q4	eq	ARG4

	hc	q1+q2+q3+q4
q5	eq	POWER 1
	HC	q5
	bc	ARGMN*4,ARGMX*4		:adjust to internal size of field
	kill	q1,q2,q3,q4,q5
       ei	:SWITC
qqqhlp	eq	1			:waiting for the help macro
	]

nmhelp	eq	0
:	the macro which defines the help strings.  Note that Command is
:	allowed to precede the help string.  This is just to make the
:	macro in the code easier to read.
cmhlp.	macro(CM,STRING)[
       if	1-qqqhlp
 remark%%FATAL ERROR IN XRAY CODE.  COMMANDS ARE DEFINED INCORRECTLY.
 remark %HELP MACRO DOES NOT FOLLOW COMMAND DEFINITION MACRO.
       ei	:qqqhlp
qqqhlp	eq	0		:no longer waiting for a help macro
      if	qqswi
       if	.help.
	hc	qhc|nmhelp|-segd
qhm|nmhelp|	macro[
qhc|nmhelp|	sc	?STRING?
]
nmhelp	eq	nmhelp+1
       ei	:.help.
      ei	:qqswi
]

X.PWR	EQ	0			:requires power 1
X.NPWR	EQ	1			:non-privileged
X.SPWR	EQ	08001			:SUPER-PRIVILEGED
X.RAR	EQ	1			:reads own args
X.AUD	EQ	2			:AUDIT TYPE COMMAND
X.EXPR	EQ	4			:CLOSE WITH BANNER AND TIMESTAMP
X.SYMB	eq	8			:arguments are symbolic (text)
X.NOOP	eq	10			:no single char options to follow
x.aulg	eq	20			:whether cmd goes to audit log
x.nhlp	eq	40			:do not display in help cmd
MAXARG	EQ	10			:max number or args allowed

qqqhlp	eq	0			:not waiting for a help macro

:	DEFINE THE XRAY COMMANDS
COMTBL	WS	0			:COMMANDS AND THEIR ADRESSES
 DFXCM.(XACHAN,AC,on,2,2,X.NPWR,X.EXPR,x.noop)
		cmhlp.(AC,<chan> <range> - Display active channels)
 DFXCM.(X.AL,AL,audsiz,0,1,X.NPWR,X.EXPR,x.noop!x.aulg)
		cmhlp.(AL,<n> - Display last n Audit Log entries)
 DFXCM.(SETPRI,AP,primsg,0,maxarg,X.PWR,X.AUD,x.noop)
		cmhlp.(CP,n [n] 1/0 - Turn crypto priority msgs. on/off)

 DFXCM.(X.BC,BC,on,1,2,x.npwr)
		cmhlp.(BC,cnt <n H/L> - Display ports buffering more than cnt for host/link n)
 DFXCM.(XBDSET,BD,bfltmr,0,0,X.PWR)
		cmhlp.(BD,<P/R> - Set/display buffer timing method)
 DFXCM.(BFXRDB,BF,bfsdbg,0,0,X.SPWR!x.aulg)
		cmhlp.(BF,- Display buffer structure history ring)
 DFXCM.(XBGLST,BG,on,0,maxarg,X.NPWR)
		cmhlp.(BG,- Display bad-guy list of neighbors."0d"0aBG <node I/R> - Insert/Remove neighbor from bad-guy list)
 DFXCM.(X.BP,BP,on,0,1,x.npwr)		:chns backpressured
		cmhlp.(BP,<n H/L> - Display backpressured ports for host/link n)
 DFXCM.(XBUFLT,BS,on,0,0,X.NPWR,X.EXPR)
		cmhlp.(BS,- Display bufferlet-use histograms)
 DFXCM.(XBRZAP,BZ,on,1,1,X.PWR,X.AUD,X.EXPR,x.noop)
		cmhlp.(BZ,node - BORI-zap neighbor)

 DFXCM.(CHNBFL,CB,on,2,2,X.PWR,x.noop!x.aulg)
		cmhlp.(CB,<BFL#> <cnt> - Chain through bufferlets)
 DFXCM.(XCRMOD,CD,on,0,0,X.NPWR,X.EXPR)
		cmhlp.(CD,<Y/N> - Set/display Crypto auto display mode)
 DFXCM.(CRYLST,CL,on,0,1,X.NPWR,X.EXPR)
		cmhlp.(CL,<n> - Display last n Crypto messages."0d"0aCL n <M/H> - Display Crypto messages in the last n Minutes/Hours)
 DFXCM.(CRYMSG,CM,on,0,maxarg,X.NPWR,X.EXPR)
		cmhlp.(CM,t <n <H/M>> - Display type t Crypto msgs.)
 DFXCM.(XCHNEI,CN,on,0,0,X.SPWR,X.EXPR,X.AUD,x.noop)
		cmhlp.(CN,neigh - Change Neighbor)
 DFXCM.(XCROPT,CO,on,0,1,X.NPWR,X.EXPR,x.noop!x.aulg)
		cmhlp.(CO,<hhss> - Set/display crash options)
 DFXCM.(CRYLTP,CP,primsg,0,1,X.NPWR,X.EXPR)
		cmhlp.(CP,<n <H/M>> - Display last n Crypto priority msgs.)
 DFXCM.(XCRCMD,CR,on,0,0,X.NPWR,X.NOOP)
		cmhlp.(CR,- Display channel partition mapping.)
 DFXCM.(X.CT,CT,on,1,1,X.NPWR,X.EXPR)
		cmhlp.(CT,<n <H/K/L>> - Display Crypto msgs for Host/linK/Line n.)
 DFXCM.(CZXRDB,CZ,cbzdbg,0,0,X.SPWR!x.aulg)
		cmhlp.(CZ,Display circuit building/zapping)

 DFXCM.(DBEGIN,DB,on,0,1,X.NPWR,x.noop!x.aulg)
		cmhlp.(DB,<n> - Begin delay measurement for index n)
 DFXCM.(XDCRSH,DC,on,0,0,X.NPWR,,X.EXPR)
		cmhlp.(DC,<D/S> - Display Node Code Detail/Summary crash tables"0d"0aDC I - Display ISIS crash table)
 DFXCM.(DLDATA,DD,on,0,1,X.NPWR,X.EXPR,x.noop)
		cmhlp.(DD,<n> - Display delay measurement stats for index n)
 DFXCM.(DLYEND,DE,on,0,1,X.NPWR,x.noop!x.aulg)
		cmhlp.(DE,<n> - End delay measurement for index n)
 DFXCM.(XDCHEX,DH,on,1,1,X.NPWR,x.noop)
		cmhlp.(DH,<n> - Convert decimal n to hex)
 DFXCM.(XLUPBK,DL,on,0,1,X.SPWR,x.noop!x.aulg)
		cmhlp.(DL,<n> - Initiate internal delay circuit)
 DFXCM.(XDCOCT,DO,on,1,1,X.NPWR,x.noop)
		cmhlp.(DO,n - Convert decimal n to octal)
 DFXCM.(DRINGS,DR,1-ncslot,0,0,X.PWR,x.noop!x.aulg)
		cmhlp.(DR,- Display dispatcher rings)
 DFXCM.(DSRNGS,DS,1-ncslot,0,0,X.NPWR,x.noop!x.aulg)
		cmhlp.(DS,- Display dispatcher rings of last crash)
 DFXCM.(DISTRP,DT,on,0,0,X.NPWR,X.EXPR,x.noop)
		cmhlp.(DT,- Display current trap locations)

 DFXCM.(AGGMOD,EM,autrac,0,3,X.NPWR,X.EXPR!x.nhlp)
		cmhlp.(EM,Display or set Expanded Monitoring profiles)

 DFXCM.(XRCFIG,FG,on,0,0,X.NPWR,x.noop)	:Display enabled flags
		cmhlp.(FG,- Display enabled configuration switches)

 DFXCM.(GETPWR,GP,on,0,0,X.NPWR,X.RAR!x.aulg)
		cmhlp.(GP,- Get power)

 DFXCM.(XHXDEC,HD,on,1,1,X.NPWR,x.noop)
		cmhlp.(HD,n - Convert hex n to decimal)
 DFXCM.(X.HELP,HE,on,0,1,x.npwr,x.symb)
		cmhlp.(HE,<c/cc/c*> - Describe available XRAY commands)
 DFXCM.(XHXOCT,HO,on,1,1,X.NPWR,x.noop)
		cmhlp.(HO,n - Convert hex n to octal)
 DFXCM.(HSTDS,HS,1-t2gate,0,maxarg,X.NPWR,X.EXPR)
		cmhlp.(HS,<host> <H/S/U> - Display host info)

 DFXCM.(ISSTAT,IS,1-ncslot,0,0,X.NPWR,X.EXPR)
		cmhlp.(IS,<Z> - Display/clear dispatcher stats.)

 DFXCM.(XNEIGB,KD,on,0,1,X.NPWR,X.EXPR)
		cmhlp.(KD,n - Display Link Descriptor to neighbor n"0d"0aKD S - Display all Link Descriptors)
 DFXCM.(XKS,KS,on,0,maxarg,X.NPWR,X.EXPR)
		cmhlp.(KS,n <Z> - Display/reset link stats"0d"0aKS S Display for all links)
 DFXCM.(xrykw,KW,supwat,0,0,x.npwr,x.expr)
		cmhlp.(KW,- Display KIO status data)

 DFXCM.(XLECHO,LE,on,0,0,X.NPWR,x.noop)	:SET LOCAL ECHO
		cmhlp.(LE,- Set local echo mode for Xray user)
 DFXCM.(LGXRDB,LG,lnfdbg,0,0,X.SPWR!x.aulg)
		cmhlp.(LG,Display port logon/logoff history ring)
 DFXCM.(LHXRDB,LH,lnkdbg,0,0,X.SPWR!x.aulg)
		cmhlp.(LH,Display port link/line history ring)
 DFXCM.(LLXRDB,LL,lpgdbg,0,0,X.SPWR!x.aulg)
		cmhlp.(LL,Display node code/supervisor history ring)
 DFXCM.(Xlre,LR,on,1,1,X.NPWR,X.EXPR,x.noop)
		cmhlp.(LR,n - Display last reset received/sent for line n)
 DFXCM.(XLTCMD,LT,on,1,2,X.NPWR,X.EXPR)
		cmhlp.(LT,n <B/E> - Display/begin/end Line Tester)

 DFXCM.(XRMTCH,MA,on,3,3,X.PWR,X.EXPR!x.aulg)
		cmhlp.(MA,<hex> <start> <end> - Match string to memory)
 DFXCM.(X.MM,MM,on,0,0,X.NPWR,X.NOOP)
		cmhlp.(MM,- Display memory map)

 DFXCM.(XND,ND,on,0,0,X.NPWR,X.EXPR,X.NOOP)
		cmhlp.(ND,- Display Node descriptor)
 DFXCM.(XNID,NI,on,0,2,x.npwr,x.noop)
		cmhlp.(NI,<line#> <netid> - Display/change Network Identifier)
 DFXCM.(XNL,NL,on,0,0,X.NPWR,X.EXPR,x.noop)
		cmhlp.(NL,Display neighbor link attributes)
 DFXCM.(XSTATS,NS,on,0,0,X.NPWR,X.EXPR)
		cmhlp.(NS,<Z> - Display/reset node statistics"0d"0aNS L - Display CPS statistics for every link)

 DFXCM.(XOCDEC,OD,on,1,1,X.NPWR,x.noop)
		cmhlp.(OD,n - Convert octal n to decimal)
 DFXCM.(XOCHEX,OH,on,1,1,X.NPWR,x.noop)
		cmhlp.(OH,n - Convert octal n to hex)

 DFXCM.(XRYWPK,PK,xryrmk,0,1,X.NPWR,X.EXPR,x.noop)
		cmhlp.(PK,<n> - Display/start packet size histogram)
 DFXCM.(X.PL,PL,pl.num,0,1,X.NPWR)
		cmhlp.(PL,<n> <D/H> - Display Performance Log)
 DFXCM.(XRYPFM,PM,on,1,1,X.PWR,x.noop)
		cmhlp.(PM,n - Performance monitor channel n)
 DFXCM.(PTCQRY,PQ,on,0,0,X.NPWR,,x.noop)
		cmhlp.(PQ,- Display patch history)
 DFXCM.(XRYPS,PS,on,0,1,x.npwr)
		cmhlp.(PS,<num H/L> - Active ports for Host/Link num)

 DFXCM.(QRYCHN,QC,on,1,2,X.NPWR,X.EXPR)
		cmhlp.(QC,ch1 <ch2> <U> - Query channel status)

 DFXCM.(XTYPE,R ,on,0,2,X.PWR,x.noop!x.aulg)
		cmhlp.(R ,addr <count> - Read memory)
 DFXCM.(XRDBUF,RB,on,1,1,X.PWR,X.EXPR,x.noop!x.aulg)
		cmhlp.(RB,n - Display contents of buffer n)
 DFXCM.(XRECHO,RE,on,0,0,X.NPWR,x.noop)
		cmhlp.(RE,- Set remote echo for Xray user)
 DFXCM.(READS,RS,on,1,2,X.NPWR,X.SYMB!x.aulg)
		cmhlp.(RS,symbol <count> - Read memory from symbolic address)
 DFXCM.(REMTRP,RT,on,1,ntrap,X.SPWR,x.noop!x.aulg)
		cmhlp.(RT,n <n...> - Remove traps)

 DFXCM.(DISADR,SA,on,1,1,X.NPWR,X.SYMB)
		cmhlp.(SA,symbol - Display symbolic address)

 DFXCM.(XRsfrm,SF,on,0,1,X.NPWR,x.expr,x.noop)
		cmhlp.(SF,<0/1> - Leave/Enter short format xray display mode)
 DFXCM.(xrysh,SH,super,0,0,x.npwr,x.expr)
		cmhlp.(SH,Display histograms on Sup ring usage)
 DFXCM.(RSSILN,SI,silins,1,1,X.NPWR,X.AUD,x.noop)
		cmhlp.(SI,n - Initialize SIO line n)
 DFXCM.(SETMES,SM,on,0,maxarg,X.SPWR,x.noop)
		cmhlp.(SM,<n...> 1/0 - Turn crypto msgs n... on/off)
 DFXCM.(X.SN,SN,on,0,0,X.SPWR,X.AUD,x.noop)
		cmhlp.(SN,- Crash and Restart Node Code)
 DFXCM.(x.sr,SR,super,0,1,x.npwr,x.expr)
		cmhlp.(SR,- Display split sup state"0d"0aSR R/S - Display received/sent Sup backpressure rings)
 DFXCM.(XSIOST,SS,on,0,1,X.NPWR)
		cmhlp.(SS,<n> - Display SIO line status)
 DFXCM.(SETTRP,ST,on,2,3,X.SPWR,x.noop!x.aulg)
		cmhlp.(ST,addr <I <n <snap>>> - Set trap I at addr...repeat n times, take snapshot)
 DFXCM.(xrysw,SW,supwat,0,1,x.npwr,x.expr)
		cmhlp.(SW,<n> <Z/N/R/I/O> - Display Sup Watch stats)
 DFXCM.(SYMBAD,SY,on,0,0,X.NPWR)
		cmhlp.(SY,c/* - Display symbolic addresses)

 DFXCM.(TRCASC,TA,on,0,1,X.NPWR,X.EXPR!x.aulg)
		cmhlp.(TA,<count> <I/O/Y/N> - ASCII display of channel-trace log)
 DFXCM.(XCHTRC,TC,on,0,2,X.PWR,x.noop!x.aulg)
		cmhlp.(TC,<CHN# 1/0> - Selects channels to be traced on/off)
 DFXCM.(TRCDAT,TD,on,0,1,X.NPWR,X.EXPR!x.aulg)
		cmhlp.(TD,<count> <I/O/Y/N> - Hex display of channel-trace log)
 DFXCM.(TRCDES,TE,on,0,1,X.NPWR,X.EXPR!x.aulg)
		cmhlp.(TE,<count> <I/O/Y/N> - Hex display of channel-trace log including escape chars)
 DFXCM.(THXRDB,TH,dbgon,1,1,X.SPWR,X.AUD!x.aulg)
		cmhlp.(TH,<0/1/2> - Stop/Start debuggers at selected trace level)
 DFXCM.(XTLINK,TL,TSTSZE,0,1,X.NPWR,x.noop)
		cmhlp.(TL,<n/0> - Set/reset/display link-trace usage)
 DFXCM.(XTSDAT,TM,TSTSZE,1,1,X.NPWR,x.noop)
		cmhlp.(TM,F/B - Display TSLIN* information)
 DFXCM.(XTLINE,TN,TSTSZE,0,1,X.NPWR,x.noop)
		cmhlp.(TN,<n> - Set/reset TSLINE trace)
 DFXCM.(XTRACE,TR,db.trc,0,2,X.SPWR,x.noop)
		cmhlp.(TR,arg - Turn on/off UPSW Tracer)
 DFXCM.(xrdj,TS,supwat,0,1,x.pwr,x.expr,x.noop!x.aulg)
		cmhlp.(TS,<n> - Set/reset Sup buffer trace)
 DFXCM.(TYPTRC,TT,db.trc,0,1,X.NPWR,X.EXPR,x.noop)
		cmhlp.(TT,- Display Jump addresses of UPSW Tracer)

 DFXCM.(WRITE,W ,on,1,2,X.SPWR,X.AUD,x.noop)
		cmhlp.(W ,addr <n> - Write at addr for count n)
 DFXCM.(XWRBUF,WB,on,2,maxarg,X.SPWR,X.EXPR,X.AUD,x.noop)
		cmhlp.(WB,buf data... - Write data... into buffer)
 DFXCM.(WRITEF,WF,on,1,2,X.SPWR,X.AUD)
		cmhlp.(WF,addr count - Write fullword into memory)
 DFXCM.(XWRMSG,WM,on,0,1,X.NPWR,x.noop)
		cmhlp.(WM,<1/0> - Set/clear/display warning message)
 DFXCM.(WRITES,WS,on,1,2,X.NPWR,X.SYMB,X.AUD)
		cmhlp.(WS,symbol <count> - Write symbolic)
 DFXCM.(XRYWSZ,WZ,on,2,2,X.SPWR,X.EXPR,X.AUD,x.noop)
		cmhlp.(WZ,neighbor size - Change window-size)

 DFXCM.(XGGMOD,XG,on,0,1,X.NPWR,X.EXPR)
	if	xggpgg			:can modify goodguy list
		cmhlp.(XG,<I/#M/#P> - Display/Modify Xray Goodguy list)
	else	:can only display it
		cmhlp.(XG,- Display Xray Goodguy list)
	ei	:xggpgg

 DFXCM.(X.ZAP,ZP,on,1,1,X.SPWR,X.AUD,x.noop)
		cmhlp.(ZP,n - Zap channel)

XNCMND	EQ	(.-COMTBL)/comtsz		:TOTAL NUMBER OF XRAY COMMANDS###wjl

::*********************************************************************
::
::	BIT ARRAYS:	CRYPRY:/CRYPDF:
::	FUNCTION:	CRYPTO MESSAGE PRIORITY BIT ARRAYS
::
::*********************************************************************


	IF 	PRIMSG
CRYPRY	HS	0	:EACH BIT SET FOR A PRIORITY MSG. ON (MSG# 0-7FH)
	HC	$2 0000001000000000,0000000100011000 (0-1FH)
	HC	$2 0000001100000000,1000000001000000 (20H-3FH)
	HC	$2 0000000000000001,0000111100000000 (40H-5FH)
	HC	$2 0000000000000000,1010011100000000 (60H-7FH)
	HC	0,0,0,0,0,0,0,0 (RESERVED TILL 0FFH)
CRYPRE	HS	0 :DEFAULT PRIORITY CRYPTO. MSGS:06,17,1B,1C,26,27,30,39,54
CRYPDF	HS	0 :DEFAULT BIT SET FOR A PRIORITY MSG. ON (MSG# 0-7FH)
	HC	$2 0000001000000000,0000000100011000 (0-1FH)
	HC	$2 0000001100000000,1000000001000000 (20H-3FH)
	HC	$2 0000000000000001,0000111100000000 (40H-5FH)
	HC	$2 0000000000000000,1010011100000000 (60H-7FH)
	HC	0,0,0,0,0,0,0,0 (RESERVED TILL 0FFH)
CRYPDE	HS	0
	EI	:PRIMSG

::*********************************************************************
::
::	BIT ARRAY:	SHCRYP:
::	FUNCTION:	DEFAULT ENABLE/DISABLE OF CRYPTO MESSAGES
::
::*********************************************************************

:	REDEFINE SOME SYMBOLS FOR CONVENIENCE
Q	EQ	0
	RE	10
CRYE|Q|	EQ	CRYE0|Q|
Q	EQ	Q+1
	ER

:	DEFINE BIT ARRAY BASED ON BIT 4 OF CRYEXX (0=> DISPLAY, 1=> NO DISPLAY)
:	AND ALSO ON BASIS OF TYME-FILE OPTIONS
QINDEX  EQ      0
QVALUE  EQ      0
SHCRYP	HS	0		:BEGINNING OF CRYPTO-ENABLE BIT ARRAY
	RE	78		:DO FOR 128 POSSIBLE CRYPTO MESSAGES
QQ	EQ	0		:DEFAULT TO DISPLAY ON
	IF	\CE|QINDEX|	:IF THERE IS A TYMFILE OVER-RIDE
QQ	EQ	0		:ENABLE THE MESSAGE
	ELSE
	IF	\CD|QINDEX|	:IF THERE IS A TYMFILE SHUT
QQ	EQ	1		:DISABLE THE MESSAGE
	ELSE
	IF	CRYE|QINDEX|&800:IF NEITHER, GO WITH DEFAULT
QQ	EQ	1		:IF BIT 4 = 1, DON'T DISPLAY
	EI
	EI
	EI
QVALUE	EQ	QVALUE*2+QQ		:SET THE CORRESPONDING BIT IN THE ARRAY
QINDEX	EQ	QINDEX+1		:ADVANCE INDEX TO NEXT CRYPTO MESSAGE
	IF	QINDEX&0F
	ELSE
	HC	QVALUE			:ELSE ENTER ONE HW OF THE BIT ARRAY
QVALUE	EQ	0			:AND CLEAR THE TEMPORARY VALUE
	EI
	ER

::*********************************************************************
::
::	BIT ARRAY:	MOCRYP:
::	FUNCTION:	PERMITS CRYPTO MESSAGES TO BE DYNAMICALLY
::	ENABLED AND DISABLED WITH AN X-RAY COMMAND. THIS INFO IS STORED
::	IN BIT 5 OF CRYE-XX (1=>CAN BE MODIFIED, 0=>CANNOT BE MODIFIED)
::
::*********************************************************************

QINDEX	EQ	0
QVALUD	EQ	0
MOCRYP	HS	0
	RE	78
QQ	EQ	0			:DEFAULT TO CANNOT BE MODIFIED
	IF	CRYE|QINDEX|&400	:PICK OUT BIT 5
QQ	EQ	1
	EI
QVALUE	EQ	QVALUE*2+QQ
QINDEX	EQ	QINDEX+1
	IF	QINDEX&0F
	ELSE
	HC	QVALUE
QVALUE	EQ	0
	EI	:QINDEX&0F
	ER

::*********************************************************************
::
::	CRYPTOGRAMS:
::
::*********************************************************************

	NOLIST
CRYM00	DEFASC(00: CRASH - TYPE= ,HH,ADDRESS= ,HH,,HH)
CRYM01	DEFASC(01: LINK UP   - KN= ,BD,NEIG= ,O5)
CRYM02	DEFASC(02: LINK DOWN - KN= ,BD,NEIG= ,O5)
CRYM03	DEFASC(03: LINK ERR (NO P.T.) - KN = ,BD,NEIG= ,O5)
CRYM04	DEFASC(04: LINE DETACHED - REASON= ,BH,LN= ,LN.BD,NEIG= ,O5)
CRYM05	DEFASC(05: TAKEOVER - SUPERVISOR= ,BH)
CRYM06	DEFASC(06: SUP STOP)
CRYM07	DEFASC(07: SUP CRQ LOST - SUPERVISOR= ,BH)
CRYM08	DEFASC(08: CRQ GOBBLED NEEDLE - CHAR PAIR= ,HH,NEIG= ,O5)
CRYM09	DEFASC(09: ZAP ON UNASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM0A	DEFASC(0A: NO NEIGHBOR - NEIG= ,O5)
CRYM0B	DEFASC(0B: CRQ BUILT - PORTS= ,HH,,HH)
CRYM0C	DEFASC(0C: CRQ ZAP   - PORTS= ,HH,,HH)
CRYM0D	DEFASC(0D: NO HOST - HOST#= ,D5)				:###CWC
CRYM0E	DEFASC(0E: NEEDLE ZAPPED - CHAN= ,HH,NEIG= ,O5)
CRYM0F	DEFASC(0F: CRQ TIMEOUT - CHANNEL = ,HH)
CRYM10	DEFASC(10: CHAN IN USE - LIFETIME= ,HH,ABS CHAN= ,HH)
CRYM11	DEFASC(11: REBUILD REQ - CHAN= ,HH,HSEQN= ,HH,,HH)
CRYM12	DEFASC(12: REB COMPLETE - CHN= ,HH,HSEQN= ,HH,,HH)
CRYM13	DEFASC(13: BAD REBUILD INVOICE NUMBER - ,HH,,HH)		:###wjl
CRYM14	DEFASC(14: REB DATA LOST. CHAN= ,HH)
CRYM15	DEFASC(15: HOST STAT - STATUS= ,BH,HOST= ,D5)			:###CWC
CRYM16	DEFASC(16: LINE ATTACHED - NLAT= ,BD,LN= ,LN.BD,NEIG= ,O5)
CRYM17	DEFASC(17: NO COMMAND PORTS - INVOICE#= ,HH,,HH)
CRYM18	DEFASC(18: EARLY ZAPPER - CHAN= ,HH,NEIG= ,O5)
CRYM19	DEFASC(19: OUT OF CHANNELS - NEIG= ,O5)
CRYM1A	DEFASC(1A: NEEDLE POINT GARBAGE - FIRST 2 BYTES= ,HH)
CRYM1B	DEFASC(1B: NO KERNEL PORTS)
CRYM1C	DEFASC(1C: OUT OF DISPATCHER PORTS - NDP= ,HD,HOST=,D5)		:###CWC
CRYM1D	DEFASC(1D: SIO INT. - STAT= ,BH,CCODE= ,BH,LN= ,LN.BD,NEIG= ,O5)	:###al
CRYM1E	DEFASC(1E: 4 SEC'S WITH NO REC'S RECVD - LN= ,LN.BD,NEIG= ,O5)
CRYM1F	DEFASC(1F: NON-GOBBLING ZAPPER - NEIG= ,O5)			:###wjl
CRYM20	DEFASC(20: LINE SUSPENDED - SEC'S= ,HD,LN= ,LN.BD,NEIG= ,O5)
CRYM21	DEFASC(21: LINK SHRINK - NCHN= ,HD, NEIG= ,O5)
CRYM22	DEFASC(22: LINK BUBBLE - NCHN= ,HD, NEIG= ,O5)
CRYM23	DEFASC(23: INV LOGGER ENTRY - BUFFER= ,HH,BF= ,HH)		:###TZ
CRYM24	DEFASC(24: SUP DATA ON UNASSIGNED CHN - CHAN= ,HH)
CRYM25	DEFASC(25: SUP ZAP ON UNASSIGNED CHN - CHAN= ,HH)
CRYM26	DEFASC(26: INV MACHNM ON CMD CIRCUIT - ERR CNT= ,HD,NODE= ,O5)
CRYM27	DEFASC(27: INV CMD ON CMD CIRCUIT - COMMAND= ,HH,ERR CNT= ,HD)
CRYM28	DEFASC(28: DATA ON UNASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM29	DEFASC(29: NEEDLE ON ASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM2A	DEFASC(2A: INV. 03 CHARACTER PAIR - CHAR= ,BH,CHAN= ,HH)
CRYM2B	DEFASC(2B: INT HOST CRQ TIMEOUT - CHAN= ,HH)
CRYM2C	DEFASC(2C: NEW DWL CHN - CHAN= ,HH,LN= ,LN.BD)
CRYM2D	DEFASC(2D: DWL LINE ZAP - REASON= ,BH,LN= ,LN.BD)
CRYM2E	DEFASC(2E: OUT OF INTERNAL HOST PORTS)
CRYM2F	DEFASC(2F: ISIS HOST OUT OF PORTS - INVOICE#= ,HH,,HH)
CRYM30	DEFASC(30: SYNC SCAN ERROR - LINE= ,LN.BD,OFFSET= ,HH)
CRYM31	DEFASC(31: NETDGN CALLING ERROR)
CRYM32	DEFASC(32: SIO BUFFER CNT ERR - LINE= ,LN.BD,COUNT= ,HH)
CRYM33	DEFASC(33: M-BOARD TIMEOUT - LINE= ,LN.BD,REASON= ,BH)
CRYM34	DEFASC(34: CIRCUIT ERRORS - LEP= ,HD,CRQ= ,HD)
CRYM35	DEFASC(35: CIRCUIT INCONSISTENCIES - MAGNITUDE= ,HH,COUNT= ,HD)
CRYM36	DEFASC(36: LINK OVERLOADED - COUNT= ,HH,NEIG= ,O5)		:###OAS
CRYM37	DEFASC(37: LINK SATURATED - COUNT= ,HH,NEIG= ,O5)		:###OAS
CRYM38	DEFASC(38: ILC BUF ZERO - NEIG= ,O5)
CRYM39	DEFASC(39: LINK SNIP - TYPE=,HH,NEIG=,O5)
       IF	SPLIT
CRYM3A	DEFASC(3A: SIO RING CONNECT SUCCESSFUL)
CRYM3B	DEFASC(3B: SIO RING INTERRUPT - STATUS= ,HH)
       EI	:SPLIT
       if	SUPER
CRYM3C	DEFASC(3C: SIO RING IS DOWN)
CRYM3D	DEFASC(3D: SUP GONE TO SLEEP - REASON= ,HH)
CRYM3E	DEFASC(3E: SUP'S COMMUNICATION IS UP)
       ei	:SUPER
      IF	T2GATE
CRYM3F DEFASC(3F: GATEWAY HOST UNACCEPTABLE - HOST#= ,D5, ERROR= ,hh)
      EI	:T2GATE
CRYM40	DEFASC(40: TOT PKTS - RECD= ,HH,SENT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM41	DEFASC(41: BAD BORI. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM42	DEFASC(42: BAD ACK. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM43	DEFASC(43: BAD RECORD NUMBER. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM44	DEFASC(44: BAD CHECKSUM. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM45	DEFASC(45: RE-XMISSIONS REC'D. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM46	DEFASC(46: RE-XMISSIONS SENT. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM47	DEFASC(47: 4-SECOND GAPS. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM48	DEFASC(48: CROSSTALK. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM49	DEFASC(49: SPACING ON INPUT. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM4A	DEFASC(4A: HDLC CKSM ERRORS. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM4B	DEFASC(4B: HDLC ABORTS. COUNT= ,HH,LN= ,LN.BD,NEIG= ,O5)
CRYM4C	DEFASC(4C: LINK REJECTED DUE TO BAD GUY LIST - NEIG= ,O5)
CRYM4D	DEFASC(4D: CIRCUITS ZAPPED= ,HD,KN= ,BD,NEIG= ,O5)
CRYM4E	DEFASC(4E: CMD CTS  ZAPPED= ,HD,KN= ,BD,NEIG= ,O5)
CRYM4F	DEFASC(4F: KERNEL DID NOT ACKNOWLEDGE ZAPPER ON PORT= ,HH)
CRYM50	DEFASC(50: BAD INT. HOST FUNCTION. VALUE = ,HH)
CRYM51	DEFASC(51: LINK FROZEN - NEIG= ,O5)
CRYM52	DEFASC(52: LINK THAWED - NEIG= ,O5)
CRYM53	DEFASC(53: BAD SIO REC LENGTH - LN= ,LN.BD,NEIG= ,O5,CNT= ,HD)
CRYM54	DEFASC(54: XRAY AUDIT - TYPE= ,HH,NAME= ,HH,,HH,,HH)
       IF	SILINS
CRYM55	DEFASC(55: SW CKSM ERR ON GOOD FRAME - CNT= ,HD,LN= ,LN.BD,NEIG= ,O5)
       EI	:SILINS
CRYM56	DEFASC(56: KIO CONNECT FAIL - PORT ,BD,IN USE - ADDRESS ,HH,,HH)
CRYM57	DEFASC(57: KIO PORT OWNER - PORT,BD,SLOT ,BD,ADDRESS ,HH,,HH)
CRYM58	DEFASC(58: REPORT LIMIT EXCEEDED - SLOT= ,BD,LIMIT= ,HD)

CRYM5A	DEFASC(5A: CIRCUIT LIMIT EXCEEDED - SLOT= ,BD, HOST= ,D5)	:###CWC
CRYM5B	DEFASC(5B: INVALID HOST FOR RESTRICTED NODE - SLOT= ,BD,HOST= ,D5) :###CWC



CRYM5E	DEFASC(5E: INV. 03-PAIR ON CMD CIRCUIT - DATA= ,HH)
CRYM5F	DEFASC(5F: CHAN IN USE - REL CHAN= ,HH,NEIG= ,O5)
CRYM60	DEFASC(60: BUFFER ZAP - COUNT= ,HH,CHAN= ,HH,BUFFER= ,HH)
CRYM61	DEFASC(61: SLOT OUT OF PORTS - NBR PORTS= ,HD,HOST= ,D5)	:###CWC
CRYM62	DEFASC(62: IMPOSTER HOST - SLOTS= ,HH,HOST= ,D5)		:###CWC
CRYM63	DEFASC(63: SQA ERROR - DIF= ,HH,PORT= ,HH)
CRYM64	DEFASC(64: KERNEL FAILED TO ZAP PORT - KERNEL PORT = ,HH)
CRYM65	DEFASC(65: SQFIX - CHN= ,HH,NET= ,HH,VALUE= ,HH,,HH)
CRYM66	DEFASC(66: SQACK - CHN= ,HH,HW SEQN= ,HH,HSEQN= ,HH,,HH)
CRYM67	DEFASC(67: REB NEEDLE - SENDING= ,HH,,HH,WANT= ,HH,,HH)
CRYM68	DEFASC(68: NO PERMUTER TABLES FOR NEW LINK - LN= ,LN.BD,NEIG= ,O5)
CRYM69	DEFASC(69: NO LINK FOR NEW LINE - LN= ,LN.BD,NEIG= ,O5)
CRYM6A	DEFASC(6A: CHAN STATUS - CHN= ,HH,HSEQN= ,HH,,HH)
CRYM6B	DEFASC(6B: REBUILD DISABLED ON CHAN= ,HH)
CRYM6C	DEFASC(6C: EARLY REBUILD NEEDLE. CHAN= ,HH)
CRYM6D	DEFASC(6D: INTERCEPT ABANDONED--NO STUB FOR INVOICE= ,HH,,HH)
CRYM6E	DEFASC(6E: CHAN STATUS - XSEQN= ,HH,,HH,VSEQN= ,HH,,HH)
CRYM6F	DEFASC(6F: SQF SENT - CHN= ,HH,XSEQN= ,HH,,HH)
CRYM70	DEFASC(70: SIO MBOARD ERROR - LINE= ,LN.BD,NEIG= ,O5)  		:###OAS
CRYM71	DEFASC(71: WILDCARD - ADDRESS= ,HH,,HH,HW2= ,HH,HW3= ,HH)
CRYM72	DEFASC(72: SIO PORT UNAVAILABLE - LINE= ,LN.BD)			:###OAS
CRYM73	DEFASC(73: BAD ZAP FROM ISIS - REASON = ,BH)			:###GT
CRYM74	DEFASC(74: TAKEOVER RESP. ERR - #NBRS= ,HH,NALINK= ,HH)		:###AL
CRYM75	DEFASC(75: NETID MISMATCH - LINE= ,LN.BD,NETID= ,HD)		:###wjl
CRYM76	DEFASC(76: WSIZ MATCH DOWN - LINE= ,LN.BD,WSIZ= ,HD)		:###wjl
CRYM77	DEFASC(77: XRAY NETID CHANGE - LINE= ,LN.BD,NETID= ,HD)		:###wjl
       IF	SPLIT
CRYM78	DEFASC(78: SIO RING CONNECT FAILED - RING LU= ,BH, REASON= ,BH)
       EI	:SPLIT

::*********************************************************************
::
::	TABLE:		CRYMTB:
::	FUNCTION:	CRYPTO MESSAGE TABLE
::
::*********************************************************************

CRYMTB	hs	0
q	eq	0
	re	7a	:current number of messages
	if	q-0f
	if	\crym|q|
	hc	crym|q|-segd
	else
	hc	0
	ei	:crym|q|
	else	:0f-q
	if	\crym0|q|
	hc	crym0|q|-segd
	else
	hc	0
	ei	:\crym0
	ei	:q-0f
q	eq	q+1
	er

	LIST

CRYMTZ	EQ	.-CRYMTB-2		:SIZE OF TABLE - 2

	SUBTTL	XRAY (Xray EQuates and Data)
 
ADBOOT	EQ	5A			:vector address for boot

:	ISIS SVC MASKS
XSG1WA	EQ	a.code*10000+7	:ISIS SVC MASK GIVES XRAY SEG1 WRITE ACCESS
XSG1WP	EQ	a.code*10000+5	:ISIS SVC MASK RESTORES SEG1 WRITE PROTECT
XSG2WA	EQ	(a.code+1)*10000+7 :write access to the second segment of code
XSG2WP	EQ	(a.code+1)*10000+5 :write protect to the second segment of code

XSGDWA	EQ	0D0007		:ISIS SVC MASK GIVES XRAY SEGD WRITE ACCESS
XSGDWP	EQ	0D0005		:ISIS SVC MASK RESTORES SEGD WRITE PROTECT

XINDDT	HS	1
XOUDDT	HC	100		:DATA AREAS FOR ISIS DDT-DRIVEN XRAY

::*****************************************************************
::
::       XRNTXT(txt,num,nsiz,txt,num,numsiz,txt)  defines a SC string with text
::       intermixed with numbers.  The numbers fields can be expressions
::       and the value (not the expression) will be put into the text.
::       the nsiz field is the number of bytes for the number.  The number
::       is truncated if too big or padded with spaces on the left.
::
::******************************************************************

XRNTXT  MACRO(T1,N1,N1S,T2,N2,N2S,T3,N3,N3S,T4)[
QXRN    BC      0 		:where to put len
	AC      /T1/
	.XRNTX(N1,N1S)
	AC      /T2/
       IF       N2S     	:only do num if given len
	.XRNTX(N2,N2S)
       EI       :N2S
	AC      /T3/
       IF       N3S
	.XRNTX(N3,N3S)
       EI       :N3S
	AC      /T4/
QQ      EQ      .
       IF       .-QXRN-1	:any message at all?
	ORG     QXRN
	BC      QQ-QXRN-1
	ORG     QQ
       ELSE       		:null string
	BC      01,00
       EI
]

:       .XRNTX  gives N2 bytes of N1 (number) in text right justified
.XRNTX  MACRO(N1,N2)[
Q       EQ      N1		:handles when N1 is an expression

	BS      N2+1    	:extra so backwards march really starts BS N2
	RE      N2		:backwards march
	ORG     .-2     	:previous to current byte
       IF       Q
Q2      EQ      Q-10*(Q/10)     :current digit
Q       EQ      Q/10
       IF       Q2-9
	BC      $0 Q2+0B7       :A-F
       ELSE
	BC      $A Q2+176       :0-9
       EI
       ELSE     :Q=0
	AC      / /
       EI
	ER
	ORG     .+N2-1  	:back to point after last digit
]

:       macro .XRNT0  gives N2 bytes of N1 (number) in text right justified
:	with leading 0s on the left.
.XRNT0  MACRO(N1,N2)[
Q       EQ      N1		:handles when N1 is an expression

	BS      N2+1    	:extra so backwards march really starts BS N2
	RE      N2		:backwards march
	ORG     .-2     	:previous to current byte
      IF       Q
Q2      EQ      Q-10*(Q/10)     :current digit
Q       EQ      Q/10
       IF       Q2-9
	BC      $0 Q2+0B7       :A-F
       ELSE
	BC      $A Q2+176       :0-9
       EI
      ELSE     :Q=0
	AC      /0/
      EI	:Q
	ER
	ORG     .+N2-1  	:back to point after last digit
]

	SUBTTL	XRAY (Host status text and tables)

::*******************************************************************
::
::      Host Status text and tables
::
::*******************************************************************

      IF	1-T2GATE

HSTDS1	HS	0			:HOST SLOT PRODUCT DESCRIPTIONS
	NOLIST
tiinoh	sc	/unknown host/
ASAT	SC	/TYMSAT/
ACOM	SC	/TYMCOM/
XCOM	SC	/X25-X75/
PBH	SC	/3270 HOST INTERFACE/
PBT	SC	/3270 TERMINAL INTERFACE/
MSAT	eq	tiinoh			:SC	/MICRONODE KERNEL/
I21S	SC	/ISIS KERNEL/
TIINC	SC	/TYMNET-II NODE CODE/
XXB	eq	tiinoh			:SC	/2020 BASE/
BBXS	SC	/X780-MULTILEAVING/
ELF	SC	/ELF/
I2G1	eq	tiinoh			:SC	/ISIS GATEWAY/
I2T1	eq	tiinoh			:SC	/ISIS TYMNET-I NODE CODE/
LDII	eq	tiinoh			:SC	/LOADII/
MRLN	eq	tiinoh			:SC	/MERLIN/
ONTM	SC	/ONTYME/
RAM	SC	/RAM/
 if super
PRB	SC	/PROBE/
SPVSR	SC	/SUPERVISOR/
 else
PRB	eq	tiinoh
SPVSR	eq	tiinoh
 ei
NVAL	SC	/VAL-NETVAL/
ISCS	SC	/ISIS CONSAT/
BOOT	eq	tiinoh			:SC	/ENGINE BOOT/
SAKER	eq	tiinoh			:SC	/STAND-ALONE KERNEL/
SPKER	eq	tiinoh			:SC	/SPLIT STAND-ALONE KERNEL/
SDLC	SC	/SDLC INTERFACE/
TNTT	SC	/TINET INTERFACE/
UTSH	SC	/UTS 4000 INTERFACE/
NTRH	SC	/NTR INTERFACE/
VMB	SC	/VMB INTERFACE/
EWS	eq	tiinoh			:SC	/ENGINE WORK STATION/
NEM	SC	/NETWORK EVENT MONITOR/
TMCS	SC	/TMCS/
OUTDIA	SC	/OUTDIAL/
CMTI	SC	/3270 VIRTUAL HOST DRIVER/
TRSW	SC	/TRANSACTION SWITCH/
ITI	SC	/SLIGOS TRANSACTION SERV/
UTST	SC	/UTS VIRTUAL HOST DRIVER/
TOM	SC	/TYMCOM OPERATIONS MON/
LEM	eq	tiinoh			:SC	/LEMCOM 370 BASE/
MUX	SC	/MULTIPLEXOR/
 if super
UTIL	SC	/SUPERVISOR UTIL SLAVE/
 else
UTIL	eq	tiinoh
 ei
PBOM	SC	/POLLED BISYNC OPS MON/
SOM	SC	/SDLC OPERATIONS MON/
PAOM	SC	/POLLED ASYNC OPS MON/
CRED	SC	/CIRCUIT REDIRECT/
TLXG	SC	/TELEX GATEWAY/
XOM	SC	/X25-X75 OPERATIONS MON/
NTRT	SC	/NTR TERMINAL INTERFACE/
XPC	SC	/X.PC SERVER/
SNAT	SC	/SNA TERMINAL INTERFACE/
SNAH	SC	/SNA HOST INTERFACE/
TNTH	SC	/TINET HOST INTERFACE/
CMTU	SC	/UTS CHAR MODE TRMNL/
ELSV	SC	/ELF SLAVE/
 if	super
PRACCT	SC	/ACCOUNT SLAVE/
ERLG	SC	/ERLOG SLAVE/
 else
PRACCT	eq	tiinoh
ERLG	eq	tiinoh
 ei
NAD	eq	tiinoh			:SC	/NAD ASSEMBLER/
NTCN	SC	/NETWORK CONSOLE/
 if	super
SYSM	SC	/SYSMSG1 SLAVE/
UN2	SC	/UN2 SLAVE/
 else
SYSM	eq	tiinoh
UN2	eq	tiinoh
 ei
ISRM	SC	/ISIS SYSTEM RECOVERY MOD/
ONTR	eq	tiinoh			:SC	/ONTYME DB RESTORE PGM/
OBJN	eq	tiinoh			:SC	/PASCAL OBJECT-NIB CNVRTR/
CPAS	eq	tiinoh			:SC	/CONCURRNT PASCAL COMPILER/
STAR	eq	tiinoh			:SC	/PASCAL STTMNT ADDR GNRTR/
TMDM	eq	tiinoh			:SC	/TMCS DISK MAINT PGM/
TMRE	eq	tiinoh			:SC	/TMCS RESOURCE EST PGM/
NMDM	eq	tiinoh			:SC	/NEM DISK MAINT PGM/
NMRE	eq	tiinoh			:SC	/NEM RESOURCE EST PGM/
NCDM	eq	tiinoh			:SC	/NETCON DISK MAINT PGM/
NCRE	eq	tiinoh			:SC	/NETCON RESOURCE ESTIMATOR/
NVDM	eq	tiinoh			:SC	/NETVAL DISK MAINT PGM/
MSRV	SC	/MENU SERVER/
SHMN	eq	tiinoh			:SC      /SHAMAN/
XPI	eq	tiinoh			:SC	/XPI/
CPPP	eq	tiinoh			:SC	/CPPP/
ATC	eq	tiinoh			:SC	/ATC/
ODNU	eq	tiinoh			:SC	/OUTDIAL NUCLEUS/
OPAS	eq	tiinoh			:SC	/OUTDIAL PASCAL COMPILER/
ACUS	eq	tiinoh			:SC	/AUTO CALL UNIT SERVER/
X25	SC	/XCOM - X.25/
X75	SC	/XCOM - X.75/
IHSA	SC	/IHSA/
DMAC	eq	tiinoh			:SC	/MAC DIAGNOSTIC/
MLI	SC	/MLI-MULTILEAVING BISYNC/
ISRS	SC	/ISIS SLOT RECOVER SYSTEM/
MXPI	eq	tiinoh			:SC	/MXP/
CICL	SC	/ICL PROTOCOL/
HICL	SC	/ICL PROTOCOL - HOST/
TICL	SC	/ICL PROTOCOL - TERMINAL/
T2G2	SC	/TYMNET II GATEWAY/
DMEM	eq	tiinoh			:8C /ENGINE MEMORY DIAGNOSTIC/
PID.8D	SC	+THROUGHPUT/LOAD HOST+
PID.8E	SC	+2770 TERMINAL INTERFACE+
PID.8F	SC	+2770 HOST INTERFACE+
PID.90	eq	tiinoh			:+SLOT I-FACE TO EBAS PDP"+
PID.91	eq	tiinoh			:+E-BUS BASE FOR PDP-10"+
PID.92	SC	+HSBC 3270 TERMINAL I-FACE+
PID.93	SC	+TYMNET CHAR. MODE HOST+
PID.94	SC	+MICRODATA BASE+
PID.95	SC	+HSBC 3270 HOST INTERFACE+
PID.96	EQ	 tiinoh			: 96
PID.97	EQ	 tiinoh			: 97
PID.98	eq	tiinoh			:+ONTYME SUBJECT LINE"+
PID.99	SC	+EXPERIMENTAL+
PID.9A	SC	+MUTUAL CONVERSION P-THRU+
PID.9B	EQ	 tiinoh			: 9B
PID.9C	eq	tiinoh			:+TYMTUNNEL TERM. HOST"+
PID.9D	eq	tiinoh			:+ISIS FOR TURBO (680X0)"+
PID.9E	SC	+BURROUGH POLL. SEL. HOST+
PID.9F	SC	+BURROUGH POLL. SEL. TERM+
PID.A0	eq	tiinoh			:+TURBO 3270 HOST INTERF"+
PID.A1	eq	tiinoh			:+TURBO 3270 TERM INTERF"+
PID.A2	eq	tiinoh			:+ISIS 68K DISPATCHER"+
PID.A3	eq	tiinoh			:+ISIS OPERATIONS MONITOR"+
PID.A4	SC	+P.C. LOAD+
PID.A5	eq	tiinoh			:+DIAG TE POWER-ON SELF-TEST"+
PID.A6	eq	tiinoh			:+TURBO MULTI-NODE CODE"+
PID.A7	SC	+BURROUGH DATA LINK CTL.+
PID.A8	SC	+CRDU TIF FOR AIR FRANCE+
PID.A9	SC	+LOAD-HOST (C)+
PID.AA	SC	+NETWORK MULTI_SERVER+
PID.AB	eq	tiinoh			:+FRAME RELAY"+
PID.AC	SC	+ASYNC-5250 CMT SUPPORT+
PID.AD	eq	tiinoh			:+TELNET GATEWAY"+
PID.AE	eq	tiinoh			:+FRAME RELAY SWITCH"+
PID.MX	eq	0AE			:highest PID known as of now

HSTDS2	SC	/"0D"0AHOST NO.  SLOT  PID   PRODUCT DESCRIPTION       STAT  TIME OF STAT  CT  DOPIL"0D"0A/
HSTDS3	SC	/--------  ----  ----  ------------------------  ----  ------------  --  -----"0D"0A/
HSTDS4	AC	/ UP /		:HOST STATUS TEXT
	AC	/DOWN/
	AC	/SHUT/
	AC	/GONE/
HSTDS6	SC	/"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20/			:26 SPACES
	LIST

PID.MN	EQ	31			:###jhl
PIDTBL	HS	0			:pointer table for PID strings
PID31	HC	ASAT-SEGD
PID32	HC	ACOM-SEGD
PID33	HC	XCOM-SEGD
PID34	HC	PBH-SEGD
PID35	HC	PBT-SEGD
PID36	HC	MSAT-SEGD
PID37	HC	I21S-SEGD
PID38	HC	TIINC-SEGD
PID39	HC	XXB-SEGD
PID3A	HC	BBXS-SEGD
PID3B	HC	ELF-SEGD
PID3C	HC	I2G1-SEGD
PID3D	HC	I2T1-SEGD
PID3E	HC	LDII-SEGD
PID3F	HC	MRLN-SEGD
PID40	HC	ONTM-SEGD
PID41	HC	PRB-SEGD
PID42	HC	RAM-SEGD
PID43	HC	SPVSR-SEGD
PID44	HC	NVAL-SEGD
PID45	HC	ISCS-SEGD
PID46	HC	BOOT-SEGD
PID47	HC	SAKER-SEGD
PID48	HC	SPKER-SEGD
PID49	HC	SDLC-SEGD
PID4A	HC	TNTT-SEGD
PID4B	HC	UTSH-SEGD
PID4C	HC	NTRH-SEGD
PID4D	HC	VMB-SEGD
PID4E	HC	EWS-SEGD
PID4F	HC	NEM-SEGD
PID50	HC	TMCS-SEGD
PID51	HC	OUTDIA-SEGD
PID52	HC	CMTI-SEGD
PID53	HC	TRSW-SEGD
PID54	HC	ITI-SEGD
PID55	HC	UTST-SEGD
PID56	HC	TOM-SEGD
PID57	HC	LEM-SEGD
PID58	HC	MUX-SEGD
PID59	HC	UTIL-SEGD
PID5A	HC	PBOM-SEGD
PID5B	HC	SOM-SEGD
PID5C	HC	PAOM-SEGD
PID5D	HC	CRED-SEGD		:###LH
PID5E	HC	TLXG-SEGD		:###LH
PID5F	HC	XOM-SEGD		:###LH
PID60	HC	NTRT-SEGD		:###LH
PID61	HC	XPC-SEGD		:###LH
PID62	HC	SNAT-SEGD		:###LH
PID63	HC	SNAH-SEGD		:###LH
PID64	HC	TNTH-SEGD		:###LH
PID65	HC	CMTU-SEGD		:###LH
PID66	HC	PRACCT-SEGD		:###LH
PID67	HC	ELSV-SEGD		:###LH
PID68	HC	ERLG-SEGD		:###LH
PID69	HC	NAD-SEGD		:###LH
PID6A	HC	NTCN-SEGD		:###LH
PID6B	HC	SYSM-SEGD		:###LH
PID6C	HC	UN2-SEGD		:###LH
PID6D	HC	ISRM-SEGD		:###LH
PID6E	HC	ONTR-SEGD		:###LH
PID6F	HC	OBJN-SEGD		:Pascal Object to Nib Converter
PID70	HC	CPAS-SEGD		:Concurrent Pascal Compiler
PID71	HC	STAR-SEGD		:Pascal Statement Address Generator
PID72	HC	TMDM-SEGD		:TMCS Disk Maintenance Program
PID73	HC	TMRE-SEGD		:TMCS Resource Estimation Program
PID74	HC	NMDM-SEGD		:NEM Disk Maintenance Program
PID75	HC	NMRE-SEGD		:NEM Resource Estimation Program
PID76	HC	NCDM-SEGD		:Network Console Disk Maint Program
PID77	HC	NCRE-SEGD		:Network Console Resource Estimator
PID78	HC	NVDM-SEGD		:Netval Disk Maintenance Program
PID79	HC	MSRV-SEGD		:Menu Server
PID7A   HC      SHMN-SEGD 		:Shaman				###LH
PID7B	HC	XPI-SEGD		:Extended Processor Interface	###wjl
PID7C	HC	CPPP-SEGD		:Concurrent Pascal Preprocessor	###wjl
PID7D	HC	ATC-SEGD		:Asynchronous Terminal Concentrator
PID7E	HC	ODNU-SEGD		:Outdial Concurrent Pascal Nucleus#wjl
PID7F	HC	OPAS-SEGD		:Outdial Pascal Compiler	###wjl
PID80	HC	ACUS-SEGD		:Outdial/Bisync Auto Call Unit Server
PID81	HC	X25-SEGD		:XCOM - X.25			###wjl
PID82	HC	X75-SEGD		:XCOM - X.75			###wjl
PID83	HC	IHSA-SEGD		:IHSA				###wjl
PID84	HC	DMAC-SEGD		:Universal Engine MAC Diagnostic###wjl
PID85	HC	MLI-SEGD		:DOS/MLI-Multileaving Bisync-DOS/VSE
PID86	HC	ISRS-SEGD		:ISIS Slot Recovery System	###wjl
PID87	HC	MXPI-SEGD		:MXP				###wjl
PID88	HC	CICL-SEGD		:ICL Protocol			###wjl
PID89	HC	HICL-SEGD		:ICL Protocol - Host		###wjl
PID8A	HC	TICL-SEGD		:ICL Protocol - Terminal	###wjl
PID8B	HC	T2G2-SEGD		:Tymnet II Gateway		###wjl
PID8C	HC	DMEM-SEGD		:Engine Memory Diagnostic	###wjl
PID8D	HC	PID.8D-SEGD		:THROUGHPUT/LOAD HOST
PID8E	HC	PID.8E-SEGD		:2770 TERMINAL INTERFACE
PID8F	HC	PID.8F-SEGD		:2770 HOST INTERFACE
q	eq	90
	re	PID.MX-90
	hc	PID.|q|-SEGD
q	eq	q+1
	er

      EI	:T2GATE

	SUBTTL	XRAY (ASCII messages)

::*********************************************************************
::
::	ASCII MESSAGES:
::
::*********************************************************************

ASCXRY	SC	/"0D"0AX-RAY"0D"0A/
ASCNOD	SC	/NODE : /
ASCHST	SC	/"0D"0AHOST : /
ASCTIM	SC	/"0D"0ATIME : /
ASC02	SC	/"0D"0A??/
ASPRMT	SC	/"0D"0A>/
ASCCAR	SC	/"0D"00/
ASCSLH	SC	.\  .
ASWRER	SC	/ADDRESS NOT ON HW OR FW BOUNDARY"0D"0A/
ASCZIP	SC	/ZIP"0D"0A/
BADRDX	SC	/"07"0D"0A**BAD RADIX/
BADCON	SC	/"0D"0ACOMMAND NOT AVAILABLE IN THIS CONFIGURATION/
ASMCER	SC	/"07"0D"0A**BAD ADDRESS"0D"0A/
ASCTRP	SC	/"0D"0ATRAP  /
PRFILL	SC	/"0ABYTE FILL: /
PRTINT	SC	/"0ARATE (0-6): /
PRNODE	SC	/"0AT-II NODE LIST: /
PRPRTY	SC	/"0APRIORITY: /
DERMSG	SC	/OUT OF INT HST CHAN OR INDEX ALREADY IN USE"0A"0D/
SSMSG1	SC	/"0D"0AWRONG LINE NUMBER/			:###LSH
ASPWER	SC	/"0ANOT AUTHORIZED/
ASCOMU	SC	/  BUSY"0A"0D/

::________________________________________________________________	###cwc


XNDHD0	SC	/"0D"0A"0ACRASH STATUS:  COUNT    TYPE    ADDRESS"0D"0A/
	IF	T2GATE			:##AL
XNDHD1	SC	/"0D"0A"0AGWNODE   HNHOST   INHOST    VERSION   H-WARE   S-WARE  SUPR    MEMORY"0D"0A/  :###CWC
	ELSE	:NOT T2GATE
XNDHD1	SC	/"0D"0A"0ANODE   KHOST   VERSION   H-WARE   S-WARE  SUPR    MEMORY"0D"0A/		:###CWC
	EI	:T2GATE

XNDHD2	SC	/KB"0D"0A"0APORTS  PASSTHRUS  CMD CTS  ALNK  TLNK  XLNK   LINES  SYNC  SIO"0D"0A/

XNDHD3	SC	/    NODE LAST CAME UP AT /
XNDHD5	SC	/"0A"0D"0ANODE FIRST CAME UP AT /
XNDHD6	SC	/"0A"0D"0ALAST CRASH:     TIME       CC   TYPE  PSW   ADDRESS"0A"0D            /
XNDHD4	SC	+"0D"0A"0A**LINE**  ***--LINK--****    LINE    LINK  LINE   LINK  LINE          LINE"0D"0ANO. TYPE  NEIG   NO. TYPE    STATUS  WSIZ  SPEED  CRQS  TIME ATT/DET  ERRATE"0D"0A+
NONEIG	SC	/                   UNUSED/	:
xltndd	SC	/                   LNTEST/	:
xcnbtd	SC	/                   *BOOT*/	:
XDWLDS	SC	/                   DWLOAD/
XDWLBR	SC	/ DWLOAD  /
xltnds	SC	/ LNTEST  /
xcnbts	sc	/ *BOOT*  /
XNDLUP	SC	/ UP      /
XNDLOT	SC	/ *DOWN*  /
XNDSUS	SC	/ *SUSP*  /
XNDLUN	SC	/UNUSED/
XNDTKD	SC	/TII /:
XNDXKD	SC	/XLNK/:
XNDMLL	SC	/-M /
XNDHSY	SC	/SYNC  /
	IF	SILINS
XNDHSI	SC	/SIO   /
	EI	:SILINS
ASTER1	SC	/  *    /
ASTER2	SC	/  **   /
ASTER3	SC	/  ***  /
ASTER4	SC	/  **** /
	SC	/  **** /
XNDLG2  SC      /LG2  / 	:print after supe number                ###sdw
XNDER0	SC	/    /
XNDER1	SC	/*   /
XNDER2	SC	/**  /
XNDER3	SC	/*** /
XNDER4	SC	/****/
XNDWDN	SC	/"0D"0ATIILNK NEIGHBORS DOWN - /

XKSM01	SC	/"0D"0A"0ALOGICAL LINK CHARACTERS/
XKSM02	SC	/"0D"0APHYSICAL LINK CHARACTERS/
XKSM03	SC	/"0D"0A    CPS IN : /
XKSM04	SC	/"0D"0A    CPS OUT: /
XKSM05	SC	/HWM : /
XKSM06	SC	/"0D"0APACKET OVERHEAD                 BANDWIDTH UTILIZATION"0D"0A/
XKSM07	SC	/    IN : /
XKSM08	SC	/    OUT : /
XKSM12	SC	?"0D"0APACKET STATISTICS"0D"0A    PACKETS/SEC : ?
XKSM10	SC	/"0D"0AOVERLOAD COUNT   SATURATED COUNT   BACKLOG COUNT   PACKETS MADE   IDLE CALLS"0D"0A      /
XKSM13	SC	?"0D"0A    RECORDS/PACKET : ?	:###JHL FOR REL 5.02
XKSM14	SC	/   AVERAGE SIZE : /
XKSM15	SC	/"0D"0ALINK DELAY (MS)"0D"0A    IN QUEUE    RTEAR    BUFFER   OUT QUEUE   XMIT     TOTAL"0D"0A      /
XKSM16	SC	/BYTES/
XKSM17	SC	+"0D"0A"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0  MARKING"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0REXMISSIONS"A0"A0"A0"A0XMISSIONS+
XKSM18	SC	+"0D"0ALINE +
XKSM20	SC	+:    +
XKSM19	SC	/"0D"0A"0ALINK : /
XKSM22	SC	?"0D"0ACHAR/SEC PER CIRCUIT"0D"0A    IN : ?
XKSM23	SC	/  OUT : /
XKSM24	SC	/ CIRCUITS : /
XKSM25	SC	/ STATISTICS CLEARED/

XSTHD1	SC	/"0D"0AEXCT  EXLW  EXHW  EDHW  EEHW  SYHW  NEHW  NECT  MPRT  MPAS  MLNK"0D"0A/
xsthd2 sc   /"0d"0aRMK XCT  RMK NMK  PKTS OUT RECS OUT PKTS IN  RECS IN"0d"0a/
XSTHD3	SC	/"0D"0A"0ANODE LINKS' TOTAL LOGICAL CPS RATES/		:###wjl
xsthd4	sc	/  HWMO AT /
xsthd5	sc	/  HWMI AT /
XSTHD6	SC	/    WRAP : /
XSTHD7	SC	/"0D"0A"0ACODE DELAY    H-WARE DELAY     TOTAL       EFFICIENCY"0D"0A    /
XSTHD8	SC	/"0D"0A  CPSO     CPSI     HWMO     HWMI   /
xsthd9	sc	/"0d"0a"0aSUPERVISOR RING CPS RATES/
xsthda	sc	/"0d"0a"0aKIO RINGS TOTAL CPS RATES/
XSTHDB	SC	/"0D"0A"0ANODE LINKS' TOTAL PHYSICAL CPS RATES/		:###wjl
XISHD1	SC	/"0D"0A"0ADRIF  DRIE  DROF  DROE  MXIN  MOUT  ICHN  ICON  OHST  ILLG  IDSM  ODSM"0D"0A/
XISHD2  SC      /"0D"0A  RANGE       COUNT   COUNT        PEAK OUT:/
XISHD3	SC	/ AT  /
	RA      0A      :change radix so text numbers are decimal
XISHD4	XRNTXT("0D"0A        ISIS RING UTILIZATION     RING SIZE:,$ADRSZ,5,"0D"0A)
XISHD6	SC	/"0D"0A"0ARING POINTER TO ISIS  FROM ISIS    PEAK IN :/
XISHD7  XRNTXT("0D"0AUNDER ,$ADRSZ/8,5,  )
	XRNTXT("0D"0A,$ADRSZ/8+1,5,-,$ADRSZ/4,5,  )
	XRNTXT("0D"0A,$ADRSZ/4+1,5,-,$A3*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A3*DRSZ/8+1,5,-,$A4*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A4*DRSZ/8+1,5,-,$A5*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A5*DRSZ/8+1,5,-,$A6*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A6*DRSZ/8+1,5,-,$A7*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A7*DRSZ/8+1,5,-,$A8*DRSZ/8,5,  )
	RA      0       :back to normal

NEIMS1	SC	+NODE   LRBO  NLWS  SPNM  NCHN  ISEC  NRTR  AMSK"0D"0A+
NEIMS2	SC	+"0D"0AOSEC  NRMK  SUSC  LRT   LAS   LRM   LAR   NAS "0D"0A+
NEIMS3	SC	+"0D"0ABNOD   CHN0  B.PT  E.PT  ACHN  VERS  LINES"0D"0A+
NEIMS4	SC	+NETID  HOST  LINE"0D"0A+
DLDMS0	SC	/"0A**** TIME, AVE1, AVE2 AND DATA FIELDS ARE DECIMAL MS ****"0D/
DLDMS1	SC 	/"0A"0ATIME  CPS   STAT  FLAG  HWF   PTR   AVE1  AVE2"0D"0A/
DLDMS2	SC	/"0ANODES : /
DLDMS3	SC	/"0D"0A"0ADATA  :"0D"0A/

XSTMS0	SC	/"0D"0A"0APROCESS: SYLVR SPIDR SWICH LINKR Q-SEC H-SEC DWLIN SOURC X-RAY 1SEC"0D"0APERCENT: /
XSTMS1	SC	/"0D"0AMAX(MS): /
XNST01  SC      /"0D"0A***--LINE--***  ***--LINK-----***  LOGICAL  LOGICAL PHYSICAL PHYSICAL"0D"0A/
XNST02  SC      /NO. TYPE SPEED  NEIG  SPEED  CRQS  CPS IN   CPS OUT  CPS IN   CPS OUT"0D"0A/


	SUBTTL	XRAY (Pointers)

XDXN	HS	0		:POINT (XD) TO X-USER BLOCKS BY SLOT NO.
Q	EQ	XUBLK
TTYXD	EQ	XUBLK
	RE	NXUBLK
	HC	Q
Q	EQ	Q+XUBSZ
	ER
	SYAD(XDXN  )			:ADD XDXN TO XRAY SYMBOL TABLE

	SUBTTL	XRAY (Link related save areas and tables)

:	LINK DESCRIPTOR SAVE AREA FOR 'KS'QUERY
	WS      0
XKSSKD  EQ      .-KS.PCO 		:ENABLE REFERENCE WITH KD EQUATES
	WS      (KSSZ+3)/4      :LINK DESCRIPTOR SAVE AREA FOR 'KS' QUERY
XKSZFG	HS	1		:KS STATS ZERO FLAG (FOR KS NGHBR# Z)	###OAS

XLUPFL  HS      1
XDLTMP  HS      1
XTDFLG  HS      1         		:FLAG TELLS IF XRAY IS IN TD INST
RWADDR  WS      1			:read/write routine address	###wjl
LASTCL  WS      1         		:ADDR OF LAST CELL OPENED


::*********************************************************************
::
::	TABLE:		HSPEED
::	FUNCTION:	CONVERTS LINE'S BAUDRT VALUE INTO HUMAN-READABLE FORM
::
::*********************************************************************

:	THE VALUES ARE CONVERTED AS FOLLOWS:
:	BAUDRT   HSPEED
:	0	 BLANKS (FOR TIILNK DOWN LINES)
:	1	 2.4
:	2	 4.8
:	3	 7.2
:	4 - 5	 9.6
:	6 - 7	 14.4
:	8 - B	 19.2
:	C - F	 28.8
:	10 - 13	 38.4
:	14 - 16	 48
:	17 - 1E	 56
:	1F	 MS
hspeeb	hs	0
q0	SC	/      /
q2.4	SC	/2.4   /
q4.8	SC	/4.8   /
q7.2	SC	/7.2   /
q9.6	SC	/9.6   /
q14.4	SC	/14.4  /
q19.2	SC	/19.2  /
q28.8	SC	/28.8  /
q38.4	SC	/38.4  /
q48	SC	/48    /
q56	SC	/56    /
q64	SC	/64    /
q72	SC	/72    /
qms	SC	/MS    /
q128	SC	/128   /
q192	SC	/192   /
q256	SC	/256   /

:	first comes a mapping of the speeds.  speeds EQ or LT than val
:	is mapped to the lower val.  so the higher speeds have slightly
:	expanded threshholds so a multiln link of 128kb +2.4kb does not
:	equal 192kb link
:	highest speed is 256kb
: real speed vals 0,1,2,3,4,6, 8,0c,10,14,17,1b,1e,1f,35,50,6a
HSPEET	hc	  0,1,2,3,4,6,0a,0e,12,15,18,1b,1d,2a,42,5c,7fff
:	these are the messages that correspond to the above speeds
HSPEEM	hc	q0-hspeeb,q2.4-hspeeb,q4.8-hspeeb,q7.2-hspeeb,q9.6-hspeeb
	hc	q14.4-hspeeb,q19.2-hspeeb,q28.8-hspeeb,q38.4-hspeeb
	hc	q48-hspeeb,q56-hspeeb,q64-hspeeb,q72-hspeeb,qms-hspeeb
	hc	q128-hspeeb,q192-hspeeb,q256-hspeeb

	LIST


::*********************************************************************
::
::	TABLE:		KSPCPS
::	FUNCTION:	DERIVE MAXIMUM CHARACTERS PER SECOND BASED ON
::			LINK SPEED VALUE IN 'KSPD' LINK DESCRIPTOR FIELD.
::
::*********************************************************************



KSPCPS	HS	0			:bits per second (used in ks cmd)
	RA	0A			:DECIMAL RADIX
Q	EQ	0
	RE	22		:FIRST 22 ENTRIES SPEED IS 2400 * KSPD VALUE
	HC	Q*2400/8	: (all speeds 2.4-53.6kbps)
Q	EQ	Q+1
	ER
	HC	56000/8			:NEXT IS 56 KB...
	HC	64000/8			:NEXT IS 64 KB...
	HC	72000/8			:NEXT IS 72 KB...
	HC	80000/8			:CALL MS 80KB
	HC	128000/8		:NEXT IS 128 KB...
	HC	192000/8		:NEXT IS 192 KB...
	HC	256000/8		:NEXT IS 256 KB...

:	kspcpf is used in mtrfic routine
KSPCPF	HS	0			:CHARACTERS/FASTC
Q	EQ	0
	RE	22		:FIRST 22 ENTRIES SPEED IS 1/2 char per fastc
	HC	(Q*4)/8
Q	EQ	Q+1
	ER
	HC	12			:56 KBPS IS ABOUT 12 CHAR/FASTC
	HC	13			:64 KBPS IS ABOUT 13 CHAR/FASTC
	HC	15			:72 KBPS IS ABOUT 15 CHAR/FASTC
	HC	17			:80 kb (MS speed) is about 17
	HC	27			:128 kb is about 27
	HC	40			:192 kb is about 40
	HC	53			:256 kb is about 53


	RA	0

	SUBTTL	XRAY (Bottom Level Input Routines)

::*********************************************************************
::
::	SUBROUTINE:	XRYTST:
::	FUNCTION:	CHECK IF THERE IS ANY INPUT DATA FOR XRAY
::	CALLING SEQ:	JAL	R13,XRYTST
::	DESTROYED:	R0, R2
::	RETURNS:	IMMEDIATE = USER DATA
::			+4 = NO DATA
::
::*********************************************************************

XRYTST	CI	XD,TTYXD		:TTY USER?
	JE	XRYTS1			:TTY XRAY USER
	LHL	R0,XRYPTF,XD		:REMOTE USER. IS FILL POINTER EQUAL
	CLH	R0,XRYPTE,XD		:TO EMPTY POINTER?
	JE	4,R13			:YES, NO DATA. DO +4 RETURN	###wjl
	SKIP(0,R13)			:REMOTE USER DATA. IMMEDIATE RETURN

XRYTS1	SVC	0A,0200			:ISIS SVC READS 1 CHAR INTO R2
	J	NODATA			:DIRECT RETURN IF NO DATA
	STH	R2,XINDDT,,		:GOT A CHAR, SAVE IT
	NHI     R2,7F     		:see if logout chars
	CLHI    R2,1A     		:control z?
	JE      XRISZP    		:yes, zap
	CLHI    R2,18     		:control x?
	JE      XRISEX    		:yes, exit to DDT
	CLHI    R2,02     		:Control^B resets
	JE      XRISGB    		:Gobbler then reset
	SKIP(0,R13)			:RETURN IMMEDIATE		###wjl
NODATA	TS	XINDDT,,		:NO DATA...FLAG CELL AS EMPTY
	J	4,R13			:AND DO +4 RETURN		###wjl

::*********************************************************************
::
::	SUBROUTINE:	XRYIN:
::	FUNCTION:	READ A SINGLE CHARACTER FROM THE TTY OR
::			A NODE CODE BUFFER
::	XRYIN RETURNS WITH A CHARACTER IN R1. IF THERE IS NO DATA
::	AVAILABLE IT DISMISSES XRAY AND TRIES AGAIN WHEN RESCHEDULED
::
::*********************************************************************

::      Only echo chars which are printable (or move cursor in a known manner)
XRPABL  HC      0FE80     		:echo ^G thru ^O (^N ^O are shifts
	HC      -1,0,0,0,0,0,0  	:for katakana/kanji)            ###sdw

XRYIN	STM	R0,XREGSV,XD		:SAVE ALL REGISTERS
XRYIN8	CI	XD,TTYXD		:TTY USER?
	JE	XRYIN1			:YES
	LHL	R4,XRYPTE,XD		:REMOTE, GET BUFFER EMPTY POINTER
	CLH	R4,XRYPTF,XD		:IS THERE DATA?
	JNFS	XRYIN9			:YES, GET IT
	JAL	R0,XRYDIS		:NO,DISMISS
	JBS	XRYIN8			:AND RETRY WHEN RESCHEDULED

XRYIN9	LB	R1,XRYBFI,R4,XD		:GET A CHARACTER
	NHI	R1,7F			:STRIP PARITY BIT
	LH	R2,EKOTYP,XD		:CHECK ECHO MODE
	JLFS	XRYIN2			:LOCAL ECHO, SKIP THE REST
	TBT     R1,XRPABL 		:printable char?                ###sdw
	JNFS    XRYIN2    		:not nice to echo ^S or ESCs    ###sdw
	LHL	R2,XRYBFO,XD		:GET OUTBOUND BUFFER NUMBER
	JAL	R9,WCIE,,		:AND ECHO TO USER
XRYIN2	AIS	R4,1			:INCREMENT EMPTY POINTER
	NHI	R4,XBFSZE-1		:MOD THE BUFFER SIZE
	STH	R4,XRYPTE,XD		:AND STORE BACK

XRYIN6	L	R0,XREGSV,XD
	LM	R2,XREGSV+8,XD		:RECOVER REGISTERS
	JR	R13			:AND RETURN

:	HERE IF XRAY IN TTY MODE
XRYIN1	LH	R1,XINDDT,,		:IS THERE A CHAR IN THE XINDDT CELL?
	JLFS	XRYIN7			:NO
	TS	XINDDT,,		:YES, FLAG XINDDT AS BEEN READ
	J	XRYIN6			:AND RETURN WITH CHAR IN R1

XRYIN7	SVC	0A,01FF			:DO A SVC TO READ A CHAR INTO R1
	                  		:FF so ISIS waits for char which takes
	                  		:much less CPU than looping without
	                  		:waiting.                       ###sdw
	J	XRYIN7			:NO DATA, DO MERCILESS LOOP
	LR      R0,R1     		:work reg (just in case someone cares)
	NHI     R0,7F
	CLHI    R0,1A     		:contro Z for tty (through ISIS DDT)
	JE      XRISZP    		:handle zap
	CLHI    R0,18     		:^X returns to ISIS DDT
	JE      XRISEX    		:goto xray isis exit
	CLHI    R0,02     		:^B is like ^C (resets and gobbles)
	JEFS    XRISGB
	J	XRYIN6			:GOT CHAR INTO R1, RETURN

:       ISIS handler for CONTROL B
XRISGB  SVC     KIO,5     		:emit gobbler
	J       XRAY			:and start over

:	ISIS EXIT FOR CONTROL X
XRISEX  JAL     R12,REMZAI,,    	:remove traps and whatever for dis one
	SVC     0D,1      		:return them to DDT
	J       XRAY    		:in case they hit P in DDT

:	ISIS EXIT FOR CONTROL Z
XRISZP  JAL     R12,REMZAI,,    	:prepare to zap them
	SVC     0D,0      		:disconnect them
	J       XPRMPT  		:DDT type P comes here??


	SUBTTL	XRAY (Scheduler)

::*********************************************************************
::
::	PROCESS:	XRYSCH:
::	FUNCTION:	SCHEDULER FOR REMOTE XRAY USER
::	SCHEDULED:	On demand by G500MS if XRAY has trap output to dump,
::	on demand by any calls to output real-time CRYPTO messages to a 
::	remote XRAY user, and on demand by INTHST requesting processing
::	of remote XRAY data.
::	YIELDS:		Between long processing loops in XRAY code,
::	during performance measurment calculations and between every
::	160 characters output by XRAY.  After yielding XRYSCH is re-
::	scheduled on a 125 MS periodic basis.
::	DISMISSES:	To the EXEC loop if no command data, if all output
::	is complete and no more input is available.
::	CALLS:		JAL	R11,XWRITE
::			JAL	R11,XPRTKT
::
::*********************************************************************

:	THE CURRENT USER PC IS STORED AT XRYADR. XRYSCH VERIFIES THAT
:	XRAY IS IN REMOTE MODE BEFORE TRANSFERING CONTROL. FOR AN ISIS
:	MACHINE THIS MEANS INTXRF > 0.

XRYSCH	LIS	R0,0
	STH	R0,XRYRUN		:CLEAR XRAY RUN FLAG IN CASE IT WAS SET
	LHI	R0,01F-PXRAY
	RBT	R0,T125MS
XRYSC0	LHL	R0,XQUEC		:GET CURRENT XRAY USER QUESER QUEUE
	NHI	R0,7FFF			:IN CASE TTY XRAY GOT SCHEDULED
	JFFOH	R0,XRYSC1		:GO DO IT TO IT
	JFS	XRYSC2
XRYSC1	LHL	XD,XDXN,R1,R1		:XUBLK POINTER
	JAL	R11,XWRITE		:GIVE XRAY WRITE ACCESS TO SEGD
	L	R0,XRYADR,XD		:GET USER PC
	JR	R0			:AND DISPATCH
XRYSC2	LHL	R0,XQUEM		:NO ONE IN CURRENT QUEUE, SO GET
	JE	EXDISM,,		:MASTER QUEUE
	STH	R0,XQUEC		:AND MAKE IT CURRENT
	LIS	R0,0			:ZERO OUT MASTER QUEUE
	STH	R0,XQUEM		:
	J	XRYSC0			:TRY AGAIN

XRYDIS	ST	R0,XRYADR,XD		:SAVE USER PC
	LHL	XN,XUSLTN,XD		:XRAY USER SLOT NUMBER
	RBT	XN,XQUEC		:TAKE OUT OF QUEUECURRENT
	JAL	R11,XPRTKT		:RESTORE SEGD WRITE PROTECT
	LHL	R0,XQUEC
	OH	R0,XQUEM
	JE	EXDISM,,
	JFS	XRYYL1

XRYYLD	ST	R0,XRYADR,XD		:SAVE USER PC
	LHL	R0,XUSLTN,XD		:XRAY USER SLOT NO.
	RBT	R0,XQUEC		:TAKE OUT OF QUEUECURRENT
	SBT	R0,XQUEM		:RESCHEDULE IN QUEUEMASTER
	JAL	R11,XPRTKT		:RESTORE SEGD WRITE PROTECT
XRYYL1	LHI	R0,1F-PXRAY		:RESCHEDULE XRAY IN 1/8 SEC
	SBT	R0,T125MS		:BY SETTING APPROPRIATE TIMEOUT BIT
	J	EXDISM,,		:DISMISS

	SUBTTL	XRAY (Utility routines for scheduling remote XRAY)

::*********************************************************************
::
::	SUBROUTINE:	XWRITE:
::	FUNCTION:	Give XRAY write access
::	CALLING SEQ:	JAL	R11,XWRITE
::
::*********************************************************************

XWRITE	LI	R0,XSG1WA		:ISIS SVC FOR WRITE ENABLE
	SVC	SYS,$A17
       if	1-swtchr		:switcher only has 1 seg for code
	LI	R0,XSG2WA		:ISIS SVC FOR WRITE ENABLE
	SVC	SYS,$A17
       ei	:1-swtchr
	LI	R0,XSGDWA		:NEED SEGD WRITE ENABLE ALSO
	SVC	SYS,$A17
	JR	R11			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XPRTKT:
::	FUNCTION:	Restore write protect
::	CALLING SEQ:	JAL	R11,XPRTKT
::
::*********************************************************************

XPRTKT	LI	R0,XSG1WP		:ISIS SVC FOR WRITE PROTECT
	SVC	SYS,$A17
       if	1-swtchr		:switcher only has 1 seg for code
	LI	R0,XSG2WP		:ISIS SVC FOR WRITE PROTECT
	SVC	SYS,$A17
       ei	:1-swtchr
	LI	R0,XSGDWP		:ALSO RESTORE SEGD WRITE PROTECT
	SVC	SYS,$A17
	JR	R11			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XCLEAN:
::	FUNCTION:	CLEANS UP X-RAY STATUS FOLLOWING ^C OR LOGOUT
::	CALLING SEQ:	JAL	R11,XCLEAN
::
::*********************************************************************

XCLEAN	CLH	XD,XWMCIU
	JNFS	XCLEA0
	LIS	R0,0
	STH	R0,XWMCIU
XCLEA0	C	XD,XKSCIU		:IN MIDDLE OF KS?
	JNFS	XCLEA1			:NO
	LIS	R0,0
	ST	R0,XKSCIU		:KS COMMAND NOT IN USE ANY MORE
XCLEA1	TS	XTDFLG			:IN MIDDLE OF TD INST WHEN ^C STRUCK?
	JLFS	XCLEA3			:NO
	LHI	R0,208			:YES
	STH	R0,CHRTRC,,		:RE-ENABLE TRACE
XCLEA3	jal	r9,remdb0		:clear db in progress if present
	C	XD,XPMCIU		:IN MIDDLE OF KS?
	JNFS	XCLEA7			:NO
	LIS	R0,0
	ST	R0,XPMCIU		:PM command not in use any more
XCLEA7	HS	0
	IF	TSTSZE
	L	R0,XTSSAV,,		:IN TM INST WHEN ^C STRUCK?	###OAS
	CI	R0,0000FFFF		:INIT VALUE, NO UPDATING	###AL
	JE	XCLEA8			:NO				###wjl
	STH	R0,TSLINE		:YES, RESTORE TSLINE		###OAS
	EXHR	R0,R0			:AND				###OAS
	STH	R0,TSLINK		:RESTORE TSLINK TO REENABLE TSN
	LI	R0,0000FFFF		:CLEAR TO INIT VALUE		###AL
	ST	R0,XTSSAV,,		:AND CLEAR OUT XTSSAV SO WE DONT REPEAT
	EI	:TSTSZE			:###OAS

XCLEA8	lis	r0,0
	stb	r0,xsform,xd		:init to normal mode
	stb	r0,xslast,xd		:last char was not a space
	JR	R11			:RETURN TO CALLER

	SUBTTL	XRAY (Main command loop)

::*********************************************************************
::
::	MAIN COMMAND LOOP:	XLOOP:
::	ENTRY POINTS:	XRCRLF/XRPRMT/XPRMPT
::			XRAY	:SHEDULED BY SOLO CONTEXT SWITCHER OR ISIS DDT
::			XRAYIS	:REMOTE USER LOGGING IN OR TYPING ^C
::
::*********************************************************************

XRCRLF	JAL	R7,TYPCRL,,
XPRMPT	L	R11,XPRTTP,XD
	JE	XNRPRT
	JR	R11

:	subroutine which waits for background to complete a task for XDDT
:	that would corrupt data if XDDT and background job were both in that
:	area of code.  Main case is bufferlet pool.			###sdw
:	the background is checked to make sure that a crash doesn't
:	put this into a loop since BG will never do requested task

XDDTWT	SVC	KIO,8			:background running?
	J	0,R8			:null return - BG not running, return
	L	R0,XDDTAD		:did background complete task?
	JER	R8			:yes, return to caller
	SVC	DISMIS			:wait a little more
	J	XDDTWT			:and check again

:	ENTRY POINT - XRAY SCHEDULED BY ISIS DDT (?STAT)

XRAY	JAL	R11,XWRITE		:allow write to any seg
	LI	XD,TTYXD		:POINTER TO SPECIAL USER BLOCK
	LIS	R0,0			:tty fits in XRAY slot 0
	STH	R0,XUSLTN,XD		:			###sdw
	lhi	r0,ttygg-xraygg		:the internal goodguy username
	sth	r0,xuname,xd
       if	ncslot&(1-swtchr)	:special test circumstances
	lcs	r0,1
       else	:not ncslot
	lis	r0,1
       ei	:ncslot
	sth	r0,xuinth+2,xd		:without power
	lhi	r0,10
	sth	r0,xuinth,xd		:and impersonates internal chn 10

:	ENTRY POINT - REMOTE XRAY USER LOGGING IN OR TYPING ^C

XRAYIS	JAL	R7,TYPASI,,
	IF	T2GATE
	SC	/"0D"0A**GATEWAY OPERATION MANAGER** /
	ELSE	:NOT T2GATE
	SC	/"0D"0A**X-RAY** /
	EI	:T2GATE##AL
	JAL	R7,TYPASI,,
	SC	/NODE: /
	LHI	R3,MACHNM		:GET NODE NUMBER IN HEX		###SHM
	JAL	R9,TYP5o,,		:TYPE 5 OCTAL DIGIT NODE #	###SHM
	JAL	R7,TYPASI,,
	SC	/HOST: /
	LHI	R3,HST0			:get kernel host number		###wjl
	JAL	R9,TYP5DD,,		:type it in decimal		###cwc
	JAL	R7,TYPASI,,
	SC	/TIME: /
	JAL	R9,GMTCAL,,
	L	R2,GMTNOW
	JAL	R9,GMTCNV,,
	LHL	R0,CRYPRI		:CLEAR CRYPTO BUFFER
	STH	R0,CRYPTU,XD
	lhl     r0,xusltn,xd
	rbt     r0,xtdato,,     	:disable auto tracing
	LIS	R0,1			:init auto crypto off		###sdw
	STH	R0,CRYMOD,XD
	LHI	R0,maxarg*4		:INITIALIZE TO 16ARGUMENTS MAX
	STH	R0,ARGmin,XD		:min 0 and 16 max
	JAL	R11,XCLEAN		:DO CLEANUP
	LHL	R0,XUINTH,XD
	RBT	R0,XWMFLG
	JEFS	COMCLR
	LB	R0,XWMSGB
	JEFS	COMCLR
	JAL	R5,XWMDIS

COMCLR	LIS	R0,0			:RESTORE SIMPLE PROMPT JUST IN CASE
	ST	R0,XPRTTP,XD		:	SO WE DON'T GET TWO HEADERS
	LHL	R0,XRYPTF,XD		:CLEAR INPUT RING
	STH	R0,XRYPTE,XD
	J	XPRMPT

XEXPRT	JAL	R7,TYPASI,,
	IF	T2GATE			:##AL
	SC	/"0D"0A**GATEWAY OPERATION MANAGER** /
	ELSE	:NOT T2GATE
	SC	/"0D"0A**X-RAY** /
	EI	:T2GATE
	JAL	R7,TYPASI,,
	SC	/NODE: /
	LHI	R3,MACHNM		:GET NODE NUMBER IN HEX		###SHM
	JAL	R9,TYP5o,,		:TYPE 5 OCTAL DIGIT NODE #	###SHM
	JAL	R7,TYPASI,,
	SC	/HOST: /
	LHI	R3,HST0			:get kernel host number		###wjl
	JAL	R9,TYP5DD,,		:type it in decimal		###cwc
	JAL	R7,TYPASI,,
	SC	/TIME: /
	JAL	R9,GMTCAL,,
	L	R2,GMTNOW
	JAL	R9,GMTCNV,,

XNRPRT	LA	R2,ASPRMT		:TYPE PROMPT
	JAL	R7,TYPASC,,
	LIS	R0,0
	ST	R0,XPRTTP,XD		:RESTORE NORMAL PROMPT

:	MAIN COMMAND LOOP - XRAY LOOPS HERE UNTIL IT RECEIVES A
:	COMMAND TO EXECUTE OR IS RESTARTED

XLOOP	LHL	R4,TRPFLG,,		:HAVE ANY TRAPS COME IN?
	JN	TRPDOR			:YES, DISPLAY TRAPS

	lhl     r8,xusltn,xd    	:get xray user #
xlop00  tbt     r8,xtdato 		:port doing continous display?
	je      xloop0
	lhl     r5,xtdcpt,r8,r8 	:any new msgs to display?
	clh     r5,trrix
	je      xloop0    		:nothing to display
	jal     r7,typcrl,,
	lis     r11,0     		:display input and output
	lr      r10,r5    		:make sure >0 cause checked
	lis     r13,0f    		:max # of msgs to display
	j       trcd49,,

XLOOP0	LHL	R0,CRYPRI		:TEST FOR CRYPTO...GET IN-POINTER
	LHL	R1,CRYMOD,XD		:ARE WE AUTOMATICALLY DISPLAYING?
	JEFS	XLOOPA			:YES
	STH	R0,CRYPTU,XD		:NO, DON'T LET THEM PILE UP

XLOOPA	CLH	R0,CRYPTU,XD		:ANY CRYPTO MESSAGES?
	JE	XLOOP2			:NONE CAME IN
	JAL	R7,TYPCRL,,		:LOOK PRETTY
	LCS	R14,4			:OUTPUT MESSAGES ONE AT A TIME
	LCS	R12,1			:ENABLE ALL MESSAGES
	JAL	R8,XCRYPT		:OUTPUT CRYPTO MESSAGES
	CI	XD,TTYXD		:TTY USER?
	JE	XLOOP3			:YES
	LHL	R0,CRYPTU,XD		:REMOTE USER...
	CLH	R0,CRYPRI		:HAVE WE TYPED ALL MESSAGES?
	JEFS	XLOOP3			:YES
	TS	XRYRUN			:NO, RESCHEDULE IN 1 SECOND
	LHL	R0,XUSLTN,XD		:GET THIS USER'S SLOT #
	SBT	R0,XQUEM		:SET THIS USER IN MASTER QUEUE

XLOOP3	LA	R2,ASPRMT
	JAL	R7,TYPASC,,		:TYPE PROMPT

XLOOP2	JAL	R13,XRYTST,,		:IS THERE DATA IN TTY BUFF?
	SKIPAD(comdsp)			:YES, GET COMMAND AND ARGUMENTS

XLOOP1	CI	XD,TTYXD		:+4 return, TTY USER?
	JNFS	XLOOP4			:NO
	SVC	DISMIS,1		:ISIS DISMISS FOR 1 SEC
	J	XLOOP			:REPEAT WHEN RESCHEDULED
XLOOP4	JAL	R0,XRYDIS		:REMOTE DISMISS
	J	XLOOP

:	note that rdcomd also gets values unless x.rar is set in which
:	case cmd returns with no regs set up for args (x.rar cmds must
:	not expect anything of value in regs).  For all other cmds this
:	section of code cannot kill r1 (last char entered), r2 (number of
:	args), r3 (value of last arg) or r4 (pointer to start of text if
:	symbolic)
COMDSP	JAL	R9,RDCOMD		:RETURNS COMMAND IN R0		###jhl
	 j	comer8			:something wrong with cmd
	 j	xrcrlf			:empty line (nothing or only spaces)
:	GOT THE RIGHT COMMAND offset in r14
	lhl	R5,COMTBL+xcmarg,R14	:get cmd options
	thi	r5,x.noop		:no options (last char must be CR)
	jefs	comds1			:options allowed
	clhi	r1,asccr		:no option typed if last is CR
	jn	comer8			:option not allowed

comds1	LH	R7,XPOWER,XD		:THIS USER'S ACCESS POWER	###TZ
	JLFS	COMDS2			:SUPERPWR, USER CAN DO ANYTHING
	CLH	R7,COMTBL+xcmpwr,R14	:IS THIS USER AUTHORIZED?	###wjl
	JG	XPWERR			:NO, TELL HIM SO
COMDS2	thi	R5,x.aud		:AUDIT TYPE COMMAND?		###wjl
	jefs	comds3			:NO, SKIP OVER
	jal	r9,fggaud		:audit the command
	jfs	comds4			:if auditted then already in audit log
comds3	thi	r5,x.aulg		:one for the audit log?
	jefs	comds4
	jal	r8,audlog		:put into the audit log
comds4	LIS	R0,0			:assume regular prompt
	thi	R5,x.expr		:close with banner and timestamp
	JEFS	COMDS5
	LI	R0,XEXPRT		:expanded prompt
COMDS5	ST	R0,XPRTTP,XD		:end of command return address
	thi	r5,x.rar		:mid of cmd dispatch gets no CRLF
	jnfs	comds7
	lr	r8,r1			:save last char typed
	JAL	R7,TYPCRL,,		:TYPE CR-LF
	lr	r1,r8			:restore last char
comds7	LHL	R14,COMTBL+xcmadr,R14	:GET THE ADDRESS		###wjl
	J	segd,R14,		:AND DISPATCH			###wjl

:	have error in power, print not authorized
XPWERR	jal	r8,audlop		:put it into audit log - LACK OF POWER
xpwer1	LA	R2,ASPWER		:INFORM USER
	JAL	R7,TYPASC,,
	J	COMCLR			:AND RETURN TO TOP

:	print the command in use message for those single thread commands
XCOMIU	LA	R2,ASCOMU		:COMMAND IN USE
	JAL	R7,TYPASC,,
	J	COMCLR

:	general syntax error routine.  if have cmd in progress then give
:	them that help msg
COMERR	lh	r14,xcmdip,xd		:in the middle of a command
	jl	comer3
       if	audsiz			:if audit log then note cmd failed
	lhl	R0,COMTBL+xcmarg,R14	:get cmd options
	thi	r0,x.aulg!x.aud		:was this cmd put into audit log
	jefs	comer8			:nope, no worries
	lhl	r2,audptr		:get pointer
	sis	r2,8			:back up to current enttry
	jgefs	comer7
	lhi	r2,audsiz-8		:ring wrapped going backwards
comer7	lh	r1,audprb+audcmd,r2,	:get current cmd string
	ohi	r1,80			:add in cmd failed bit
	sth	r1,audprb+audcmd,r2,	:and put it away
       ei	:audsiz
comer8	lh	r14,xcmdip,xd		:in the middle of a command
	jl	comer3
       if	.help.			:have the long text strings
	lcs	r12,1			:this is an error call 
	jal	r9,x.heds,,		:print usage: help info
	lr	r13,r13
	jlfs	comer3			:error not printed
	jfs	comer4
       ei	:.help.
comer3	LA	R2,ASC02		:INVALID COMMAND, TYPE ??
	JAL	R7,TYPASC,,
comer4	J	XRCRLF,,			



::*********************************************************************
::
::	SUBROUTINE:	RDCOMD, RDARGS, RDTEXT
::	FUNCTION:	reads in data, allows buffering and editting.
::		upon cr puts args in 
::	CALLING SEQ:	JAL	R9,RDCOMD
::	OUTPUT:		R0  = RETURNS COMMAND
::			R1  = RETURNS LAST CHARACTER TYPED
::	RETURNS: 	+0  if error in cmd (ie only in cmd mode)
::			+4  only spaces 
::			+8  valid cmds (r14 set up) and/or args
::*********************************************************************

RDCOMD	LIS	R8,0			:doing commands
	lcs	r4,1			:clear cmd in progress
	sth	r4,xcmdip,xd		:no cmd in progress
	lis	r4,0			:default to expect numeric args
	jfs	rdar01

rdtext	lcs	r8,1			:not doing commands
	lcs	r4,1			:symbolic args
	jfs	rdar01

rdargs	lcs	r8,1			:not doing commands
	lis	r4,0			:numeric args
:	and so begins the code common to all
rdar01	sth	r8,argpos,xd		:remember whether doing cmds
	STH	R4,ARGCT,XD		:ZERO OUT ARGUMENT COUNT
	stb	r4,value1+1,xd		:no chars received yet	
	lis	r4,0
	lcs	r14,1			:no cmd found yet

:	get char
rdar03	JAL	R13,XRYIN		:GET next CHARACTER
	OHI	R1,80			:SET MSB
	stb	r1,value1+4,r4,xd		:save char
	ais	r4,1			:bump index
:	see if end of line
	CLHI	R1,ASCCR+80		:CARRIAGE RETURN?
	je	rdar50			:end of line
	CLHI	R1,ASCLF+80		:HOW ABOUT LINE-FEED?
	jnfs	rdar04			:end of line
	lhi	r1,asccr+80		:make it into a CR
	stb	r1,value1+4-1,r4,xd	:overwrite CR
	j	rdar50			:and exit to CR handler
:	not end of line, see if an editting char
rdar04	clhi	r1,08+80		:backspace?
	jn	rdar10
:	echo BS sp BS if not at start of line
	sis	r4,2			:at beginning of line?
	jlfs	rdar06			:remember BS counts as a position
	jal	r13,typbsb		:delete on user's screen
rdar06	lr	r4,r4			:back up behind bs and prev char
	jgfs	rdar08			:not back to start
:	deleted back to start of line
rdar07	lis	r4,0
	lr	r8,r8			:if doing cmd
	jl	rdar03			:not doing cmd
	lis	r8,0			:cmd back at start of line
	j	rdar03			:get next char
:	delete one char or more (alt entry) in middle of line
rdar08	lr	r8,r8			:only a problem if have cmd
	jle	rdar03			:no problem, get next char
:	r8 points after first char of cmd and r4 has been moved back
:	to point at next spot to put char thus r8 > r4 means all chars of
:	cmd have been deleted (r8 = r4 when have first char of cmd)
	cr	r8,r4			:removed last char of cmd?
	jl	rdar03			:deleted some char at end of cmd
	lcs	r14,1			:no longer have cmd (last or first gone)
	cr	r8,r4			:any part of cmd left
	je	rdar03			:yeah, still have first char of cmd
	lis	r8,0			:must have deleted back to leading spaces
	j	rdar03

:	not backspace, is it delete word?
rdar10	clhi	r1,17+80		:control-W	
	jn	rdar20
	sis	r4,1			:each own control-w
	jfs	rdar14			:now eat data
:	search back for a non whitespace char
rdar12	lb	r1,value1+4,r4,xd
	clhi	r1,ASCSPC+80		:a space
	jefs	rdar13
	clhi	r1,ASCCOM+80		:a comma (only delete an arg)
	jnfs	rdar15
rdar13	jal	r13,typbsb		:remove it from user
rdar14	sis	r4,1			:another char read
	jgebs	rdar12			:get next if line empty
	j	rdar07			:line empty
:	got nonwhitespace, now delete until get whitespace
rdar15	lb	r1,value1+4,r4,xd
	clhi	r1,ASCSPC+80		:a space
	jefs	rdar18
	clhi	r1,ASCCOM+80		:a comma (only delete an arg)
	jefs	rdar18
	jal	r13,typbsb		:remove it for user
	sis	r4,1			:another char read
	jgebs	rdar15			:get next if line empty
	j	rdar07			:line empty
rdar18	ais	r4,1			:point to char after whitespace
	j	rdar08			:see if deleted cmd if in cmd mode

:	GOT A CHAR THAT WASN'T SPECIAL!!! (isn't that special?)
:	if not end of line or delete then will have next char so check len
rdar20	clhi	r4,$a 124		:max line length
	jger	r9			:that is an error so end it all now
:	see if looking for a cmd
	lr	r8,r8
	jl	rdar03			:not looking for a cmd so get next char
	jnfs	rdar22			:not looking for start of cmd
	clhi	r1,ascspc+80		:anything bigger than a space
	jle	rdar03			:not a start of cmd
	lr	r8,r4			:have start of a command
	j	rdar03

:	we are looking for a cmd and have start of a cmd so see if now have
:	just got second char of the cmd
rdar22	clhi	r4,1,r8			:is put two chars after start of cmd?
	jn	rdar03			:didn't just get 2nd char of cmd
	lb	r0,value1+4-1,r8,xd	:get first char of possible cmd
	clhi	r0,80+40		:a-z , A-Z?
	jlfs	rdar23
	NHI	R0,ASCUC		:make first char uppercase
rdar23	clhi	r1,80+40		:a-z , A-Z?
	jlfs	rdar24
	NHI	R1,ASCUC		:make first char uppercase
rdar24	EXBR	R0,R0			:move to high byte
	or	r0,r1			:make into cmd pair for cmd
	jal	r3,comfnd		:return pointer to cmd block in r1
	jl	rdar03			:not a cmd, let them edit or hit cr to
					:get the error msg
	lhi	r5,x.symb		:symbolic arguments?
	nh	R5,COMTBL+xcmarg,R14	:how is cmd declared
	jefs	rdar25
	lcs	r0,1			:mark args to be symbolic
	sth	r0,argct,xd		:remember what not to do on CR
rdar25	lhi	r5,x.rar		:command reads own args?
	nh	R5,COMTBL+xcmarg,R14	:how is cmd declared
	je	rdar03			:continue reading in cmd data
:	exit with no args.  remember to check against arg min to see if
:	this is valid.  remember this case if for X.RAR so only really
:	checking if cmd is properly defined
rdar26	sth	r14,xcmdip,xd		:save a cmd in progress
	lis	r2,0			:set up for null cmd
	lis	r3,0
	sth	r2,argct,xd
	lhi	r1,8d			:last char typed
	j	rdar90			:check arg count


:	WE HAVE A CR.  IT IS THE START OF THE END
:	and so ends everything which may go back and get another char
:	for a CR was typed
rdar50	lr	r8,r8			:searching for command?
	je	4,r9			:yes, but only spaces enterred
	jl	rdar55			:only args so skip
	lr	r14,r14			:find a cmd?
	jlfs	rdar52			:cmd not found
	sth	r14,xcmdip,xd		:save a cmd in progress
	j	rdar55			:know our cmd

:	got a CR without yet having found a matching cmd
rdar52	cr	r4,r8			:was only one char typed?
	jnr	r9			:no, so was not a valid cmd
	lb	r0,value1+4-1,r8,xd	:get first char entered
	exbr	r0,r0			:move to HO byte
	ohi	r0,80+ascspc		:make 2nd byte a space
	jal	r3,comfnd		:see if this is a cmd
	jlr	r9			:cmd not found
	j	rdar26			:go to cmd with no args exit
:	doing args part.  determine if numeric and symbolic and then
:	process.  note r8 points to pos 1 before place to look for first
:	char of args.
rdar55	stb	r4,argpos+1,xd		:save pos of end of cmd
	lis	r2,0			:no args found yet
	ais	r8,1			:+1 points to char after cmd or
					:to pos 0 if no cmd
	lh	r0,argct,xd		:-1 if symbolic or else should 0
	jge	rdar70			:not symbolic
:	for symbolic args we count number of fields which is in r2, return
:	last char in r1.
:	first, start after cmd (if it was present)
:	initial state is spaces looking for non space
rdar56	cr	r8,r4			:see if scanned all chars
	jge	rdar66			:yes, exit
	lb	r1,value1+4,r8,xd	:get current char
	clhi	r1,ascspc+80		:is it a space
	jnfs	rdar58			:yep
	ais	r8,1			:found whitespace, get next
	jbs	rdar56
:	not whitespace
rdar58	stb	r8,argpos,xd		:save pos of start of args
	ais	r2,4			:count first arg
rdar59	lhi	r0,-100,r1		:neg is middle of text.
rdar60	ais	r8,1			:next char
	cr	r8,r4			:scanned all chars
	jge	rdar66			:yes, exit
	lb	r1,value1+4,r8,xd	:get current char
	clhi	r1,ascspc+80		:is it a space?
	jefs	rdar63
	clhi	r1,asccom+80		:is it a comma?
	jefs	rdar63
	lr	r0,r0			:in text or in spaces
	jl	rdar60			:was in text so get next
	ais	r2,4			:now in text is another arg
	j	rdar59			:set arg state
:	in spaces or comma
rdar63	lr	r0,r1			:r0 > 0 is whitespace state
	j	rdar60
:	found end of symbolic args
rdar66	sth	r2,argct,xd		:how many args fields
	ahi	r0,100			:restore last non space to the char
	lr	r1,r0			:promised to return in r1
	j	rdar90			:go to final checking

:	here if reading numeric args.  find the arg
rdar70	lis	r2,0			:clear argument count
	sth	r2,argct,xd
	lr	r13,r8
rdar72	jal	r7,eatws		:eat leading whitespace
	jl	rdar85			:exit if CR or EOL
	clb	r2,argmax,xd		:are we at the max no of args?
	jge	rdar75			:have max args, get closing char
	jal	r8,rdexp		:read an expression
	lr	r4,r4			:no digits read
	jefs	rdar80			:no digits typed, process non-digit
	st	r3,xregsv,r2,xd		:save arg in temp for now
	ais	r2,4			:got a digit, inc arg count
	sth	r2,argct,xd
	j	rdar72			:no, get next arg

:	have maxargs.  still have chance that cmd is followed by an option
:	specified as a char (like'z' in ns z).  the little trick here is
:	that final char once maxargs are reached can be anything (such as
:	0-9 a-f) so code in cmds can be made easier in accepting options
rdar75	lr	r1,r0			:get copy of nonwhitespace

:	got a nonspace or nonnumber.  all that follows must be spaces or cr
:	as only one letter is allowed in numeric arguments (a trailing z
:	or the like).
:	note preservation of r1 (last nonspace). 
rdar80	ais	r13,1			:position after the nondigit
	jal	r7,eatws
	lr	r0,r0			:get here by end of line?
	jlfs	rdar85
	jr	r9			:another nonspace which is  error.

:	reached end with everything okay
rdar85	CLHI	R1,ASCSPC+80		:is last char a SPACE?
	JNFS	RDAR87			:no, leave it as is
	LHI	R1,ASCCR+80		:eat any trailing spaces
RDAR87	sis	r2,4
	jl	rdar90
	l	r3,xregsv,r2,xd		:get reg
	st	r3,value1,r2,xd		:save to correct spot
	J	RDAR87
:	exit for all legal cases
rdar90	lh	r2,argct,xd
	clb	r2,argmin,xd		:enough args?
	jlr	r9			:not enough, error
	clb	r2,argmax,xd		:too many args
	jgr	r9
	lhi	r13,maxarg*4
	sth	r13,argmin,xd		:fall back to 0 args min, 16 args max
	l	r3,value1-4,r2,xd	:recover r3 = last argument entered
	nhi	r1,7f			:knock off high bit
	clhi	r1,40			:return last char in uppercase
	jl	8,r9			:return with success!
	clhi	r1,7f			:don't alter delete 
	je	8,r9			:as if del will ever be option to cmd
	nhi	r1,ascuc		:make uppercase
	j	8,r9

:	eat space without having r13 set up and wanting it saved when done
eatwsp	lb	r13,argpos,xd
	jal	r7,eatws
	stb	r13,argpos,xd
	jr	r8

:	eat white space, link on r7.  a comma is same as space.
:	note char ending the whitespace is not considered read so that
:	reader of nonwhitespace doesn't have to do anything to find it.
eatws	lb	r0,value1+4,r13,xd
	clhi	r0,80+ascspc
	jefs	eatws1
	clhi	r0,80+asccom
	jefs	eatws1
	clhi	r0,80+asccr
	jefs	eatws2
	jr	r7			:return with char in r0 and r13 at it
eatws1	ais	r13,1
	clb	r13,argpos+1,xd		:at end of line?
	jle	eatws
eatws2	lcs	r0,1			:mark at end
	jr	r7

:	echo BS if not halfduplex, then SP BS for deleting on cmdline
typbsb	lb	r1,value1+4,r4,xd	:is the char being removed printable?
	clhi	r1,80+ascspc		:no control chars need bs sp bs
	jlr	r13
	clhi	r1,80+7f		:del char also is not displayed
	jer	r13
	st	r13,xrsave+14,xd	:save line reg
	lh	r1,ekotyp,xd		:halfdup echo?
	jlfs	typbs2			:don't echo bs again
	lis	r1,08			:backspace
	jal	r13,xryout,,		:	
typbs2	lhi	r1,ascspc		:space
	jal	r13,xryout,,
	lis	r1,08			:backspace
	jal	r13,xryout,,
	l	r13,xrsave+14,xd	:save line reg
	jr	r13

::*********************************************************************
::
::	SUBROUTINE:	COMFND
::	FUNCTION:	checks two chars in r0 against entries in xray
::		table.
::	CALLING SEQ:	JAL	R3,COMFND
::	OUTPUT:		R14= negative if no command or offset into cmd table
::			condition codes are neg if not fount or not neg if
::			found
::	DESTROYED:	R2
::
::*********************************************************************

comfnd	lhi	r14,xncmnd*comtsz	:size of command table
comfn1	sis	r14,comtsz		:check next command
	jlr	r3
	lhl	r2,comtbl,r14		:is this the command?
	cr	r0,r2
	jnbs	comfn1			:no, try next one
:	got the right command
	lhl	r0,xcmmin+comtbl,r14	:get min and max args for cmd
	sth	r0,argmin,xd		:save min and max args
	lr	r14,r14			:set condition code of not negative
	jr	r3			:so return

::*********************************************************************
::
::	SUBROUTINE:	RDEXP:
::	FUNCTION:	READ A NUMERICAL VALUE
::	CALLING SEQ:	JAL	R8,RDEXP
::	OUTPUT:		R1=LAST NON-DIGIT TYPED
::			R3=RETURNS NUMERICAL VALUE
::			R4=RETURNS COUNT OF DIGITS TYPED
::
::*********************************************************************

RDEXP	LIS	R4,0			:CLEAR COUNT AND VALUE
	LIS	R3,0
RDNU1	lb	r1,value1+4,r13,xd	:get next char
	CLHI	R1,ASCZRO+80
	JLR	R8			:< 30, NOT A DIGIT		###wjl
	CLHI	R1,ASCNIN+80
	JLEFS	RDHE1			:0 - 9
	CLHI	R1,ASCA+80
	JLR	R8			:< A, NOT A DIGIT		###wjl
	NHI	R1,ASCAP		:ENSURE UPPERCASE(x5F)
	CLHI	R1,ASCF
	JGR	R8			:> F which is error
	AIS	R1,9			:A - F, JUST ADD 9 AND TRUNCATE
RDHE1	NHI	R1,0F
	AIS	R4,1			:(+4) INC COUNT
	SLLS	R3,4			:SHIFT IN DIGIT
	AR	R3,R1
	ais	r13,1			:count char read after knowing it is number
	J	RDNU1

::*********************************************************************
::
::      SUBROUTINE:     AUDLOG:
::      FUNCTION:       Put the name and time into the Audit Log
::      CALLING SEQ:    JAL     R8,AUDLOG
::      INPUT:          XD
::
::      uses crypto's CRYSAV area for saving as these are parallel routines
::*********************************************************************


AUDLOP  lhi     r0,8000                 :mark as due to lack of priv
        jfs     audlo1
AUDLOG  lis     r0,0                    :cmd was executed (except for parm errs)
audlo1  hs      0
       if       audsiz
        STM     R0,CRYSAV               :SAVE WORK REGS
        lhl     r2,audptr
        lhl     r3,xcmdip,xd		:get cmd table entry of current cmd
	lhl	r4,xcmstr+comtbl,r3	:get cmd string
	nhi	r4,7f7f			:knock off control bits
	or	r0,r4			:add in authorized/unauthorized bit
        sth     r0,audprb+audcmd,r2,    :save command away
        JAL     R9,GMTCAL,,             :GET CURRENT GMT AT GMTNOW
        L       R1,GMTNOW               :GET IT AND
        ST      R1,AUDPRB+audgmt,R2,    :STORE IT AWAY
        lhl     r1,xuname,xd            :get user block index
        sth     r1,audprb+audblk,r2,    :save username
	AHI	R2,8			:size of an entry
	ci	r2,audsiz		:at end of ring?
	jlfs	audlo2
	lis	r2,0			:wrapped back to start
audlo2	nhi	r2,-8			:in case of crash or corruption, resync
	STH	R2,audptr

	LHL	R14,INTXRF		:REMOTE XRAY USER?
	JEFS	audlo4			:NO
	LHI	R14,01F-PXRAY		:YES,SCHEDULE XRAY
	SBT	R14,SQUEUE
	LHL	R14,XUSIUA		:PUT ALL XRAY USERS
	STH	R14,XQUEM		:INTO MASTER QUEUE
audlo4	LM	R0,CRYSAV		:RESTORE WORK REGS
       ei	:audsiz
	JR	R8			:RETURN

::*********************************************************************
::
::	COMMAND:	XWRMSG:	AL
::	FUNCTION:	Display entries in the audit log
::	INPUT:		AL <num> 
::
::*********************************************************************

       if	audsiz
x.al	lhi	r3,10			:default number of msgs
	lr	r2,r2			:any args?
	jefs	x.al02
	l	r3,value1,xd		:get the arg
x.al02	jal	r9,dechex,,
	slls	r3,3			:each entry is 8 bytes
	clhi	r3,audsiz		:asked for more than is in log?
	jlefs	x.al04
	lhi	r3,audsiz		:give them max size of the log
x.al04	lhl	r11,audptr		:get current pointer into ring
	sr	r11,r3			:back up desired number of msgs
	jgefs	x.al06			:still within the ring
	ahi	r11,audsiz		:put back within ring
x.al06	jal	r7,typcrl,,
x.al08	jal	r10,auddsp		:display the audit log entry
	clh	r11,audptr		:read last msg in ring?
	jnbs	x.al08
	j	xprmpt			:and done

audms1	sc	/ Command: /
audms2	sc	/ Unauthorized: /
audms3	sc	/  Username: /
audms4	sc	/ Command Unsuccessful: /
:	auddsp	a little subroutine to display the info at R11
auddsp	l	r2,audprb+audgmt,r11,	:get GMT field
	ais	r2,1			:if eq -1 then not a message
	je	audds8			:subtracting from fastc bits not printed
	jal	r9,gmtcnx,,
	la	r2,audms2		:it wasn't authorized
	lh	r6,audprb+audcmd,r11,	:was it not authorized
	jlfs	audds2
	la	r2,audms4		:cmd ended up in command error
	thi	r6,80			:cmd eventually failed
	jnfs	audds2
:	command successfully executed
	la	r2,audms1		:tell them the cmd
audds2	jal	r7,typasc,,		:print it
	exbr	r1,r6			:the cmd that was attempted
	jal	r13,xryout,,
	exbr	r1,r1			:the low byte of the cmd
	jal	r13,xryout,,
	la	r2,audms3
	jal	r7,typasc,,
	lhl	r6,audprb+audblk,r11,	:get pointer to userblock
	lis	r7,0
audds3	lb	r1,xraygg+xggnam,r6,r7	:address of username
	je	audds7			:got a null, done
	jal	r13,xryout,,
	ais	r7,1
	clhi	r7,0c			:reached max size of username
	jlbs	audds3
audds7	jal	r7,typcrl,,		:give it a new line
audds8	ahi	r11,8			:move to next msg
	clhi	r11,audsiz		:check for ring wrap
	jlfs	audds9
	lis	r11,0
audds9	jr	r10			:and done
       ei	:audsiz
	

	SUBTTL	XRAY (Read, Write - WM, W , WF, RG, RA, WA, R , CB)

	IF	XRYMES			:IF XRAY MESSAGE PROVIDED IN TYMFILE
					:FILL IN CONFIGURED MESSAGE
XWMSGB	XRYMS0				:(SEE XRYMSG/XRYMS0 MACROS)
	ELSE	:XRYMES			:ELSE, NO MESSAGE PROVIDED IN TYMFILE
XWMSGB	BS	1
	BC	0D,0A			:LEADING CR/LF
	EI	:XRYMES

	ORG	XWMSGB+47		:LEAVE 44 FOR MESSAGE BUFFER
XWMSGT	WS	1			:XRAY WARNING MESSAGE TIME
XWMCIU	HS	1			:COMMAND IN USE FLAG

::*********************************************************************
::
::	COMMAND:	XWRMSG:	WM
::	FUNCTION:	XRAY WARNING MESSAGE
::	INPUT:		WM<cr> - PROMPTS FOR MESSAGE
::			WM1 - DISPLAYS WARNING MESSAGE BUFFER
::			WM0 - ERASES WARNING MESSAGE BUFFER
::
::*********************************************************************

MXWMSG	EQ	40			:max warning msg length

XWRMSG	lr	r2,r2			:any args?
	JN	XWRM00			:yes

	LB	R2,XWMSGB		:MAKE SURE BUFFER IS EMPTY
	JE	XWRM01			:OK

	JAL	R7,TYPASI,,
	SC	/"0D"0AMESSAGE BUFFER IN USE"0D"0A/
XWRM02	LB	R2,XWMSGB		:ANYTHING THERE?
	JE	XPRMPT
	JAL	R5,XWMDIS
	J	XPRMPT

XWMDIS	LA	R2,XWMSGB
	JAL	R7,TYPASC,,			:DISPLAY CURRENT MESSAGE
	JAL	R7,TYPASI,,
	SC	/"0D"0AMESSAGE ENTERED: /
	L	R2,XWMSGT		:AND MESSAGE TIME
	JEFS	XWMDS9
	ST	R2,GMTNOW
	JAL	R9,GMTCNV,,		:###jhl
	JR	R5
XWMDS9	JAL	R7,TYPASI,,		:INDICATE MESSAGE ENTERED AT ASSEMBLY TIME
	SC	/AT ASSEMBLY TIME/
	JR	R5

:	USER WANTS TO DISPLAY OR CLEAR MESSAGE BUFFER
XWRM00	lr	r3,r3			:'0' = CLEAR MESSAGE BUFFER?
	jefs	xwrm03
	sis	R1,1			:'1' = DISPLAY MESSAGE?
	JE	XWRM02			:YES
	J	COMERR			:not one of those

XWRM03	LIS	R1,0			:ZERO OUT MESSAGE BUFFER COUNT
	STB	R1,XWMSGB
	JAL	R7,TYPASI,,
	SC	/"0D"0AMESSAGE BUFFER CLEARED"0D"0A/
	J	XPRMPT

XWRM01	LHL	R2,XWMCIU
	JN	xcomiu
XWRM11	STH	XD,XWMCIU
	JAL	R7,TYPASI,,
	SC	/"0D"0AENTER MESSAGE (<60 BYTES):"0D"0A/
	LIS	R5,2			:INIT MESSAGE LENGTH COUNT
XWRM10	JAL	R13,XRYIN,,
	NHI	R1,ASC7BT		:STRIP PARITY
	CLHI	R1,ASCCR		:<CR>?
	JE	XWRM04			:YES

	CLHI	R5,40
	JLE	XWRM12

	JAL	R7,TYPASI,,
	SC	/"0D"0AMESSAGE TOO LONG - TYPE <CR>"0D"0A/
	J	XWRM10

XWRM12	STB	R1,XWMSGB+3,R5		:STORE CHAR. IN MESSAGE BUFFER
	AIS	R5,1			:INC. MSG LENGTH COUNT
	J	XWRM10

XWRM04	CLHI	R5,MXWMSG
	JLEFS	XWRM41
	LIS	R1,0
	STH	R1,XWMCIU
	J	XWRM03

XWRM41	LIS	R1,0D
	STB	R1,XWMSGB+3,R5
	LIS	R1,0A
	STB	R1,XWMSGB+4,R5
	AIS	R5,2
	STB	R5,XWMSGB

	JAL	R9,GMTCAL,,
	L	R2,GMTNOW
	ST	R2,XWMSGT

	LIS	R0,0
	STH	R0,XWMCIU

	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	WRITE:	W
::	FUNCTION:	SIMILAR TO OPEN
::	INPUT:		VALUE1 = STARTING ADDRESS
::			VALUE1+4 = BYTE COUNT (OPTIONAL, DEFAULT = 2)
::
::*********************************************************************

WRITE	LHL	R2,ARGCT,XD
	LIS	R12,0
	CLHI	R2,8
	JL	WRITE5			:SINGLE ARGUMENT IS ADDRESS
	L	R12,VALUE1+4,XD		:SECOND VALUE IS COUNT

WRITE5	L	R11,VALUE1,XD		:ADDRESS
	THI	R11,1			:ONLY EVEN ADDRESSES
	JN	WRERR
WRITE4	LR	R3,R11
	JAL	R9,CHKMAC		:GET MAC APPROVAL
	J	CHKMA1			:ERROR IF IMMEDIATE RETURN
	CI      R11,sege		:SEG E OR F?
	JGE     CHKMA1    		:CAN'T WRITE THERE
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	LHL	R3,0,R11
	JAL	R9,TYPHW,,
	JAL	R9,RDARGS,,		:GET NEW VALUE
	j	comer3			:garbage
	j	write3
	CLHI	R2,4
	JG	COMERR			:0 OR 1 ARGUMENT ONLY
	JE	WRITE2			:1 ARG
	CLHI	R1,ASCBSL
	JE	WRITE3			: '\'
	CLHI	R1,ASCFSL		: '/'
	JEFS	WRITE3
	CLHI	R1,ASCCR
	JN	COMER3
	JAL	R7,TYPCRL,,		:A CR EXITS US
	J	XPRMPT
WRITE2	STH	R3,0,R11		:STORE THE VALUE
WRITE3	JAL	R7,TYPCRL,,		:CR-LF
	AIS	R11,2
	SIS	R12,2			:DECREMENT COUNT
	JG	WRITE4			:SOME LEFT
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	WRITEF:	WF
::	FUNCTION:	WRITES A FULLWORD INTO MEMORY
::			IDENTICAL TO WRITE EXCEPT THAT A FW IS WRITTEN
::
::*********************************************************************

WRITEF	LHL	R2,ARGCT,XD
	LIS	R12,0
	CLHI	R2,8
	JL	WRITF5			:SINGLE ARGUMENT IS ADDRESS
	L	R12,VALUE1+4,XD		:SECOND VALUE IS COUNT

WRITF5	L	R11,VALUE1,XD		:ADDRESS
	THI	R11,1			:ONLY EVEN ADDRESSES
	JN	WRERR
WRITF4	LR	R3,R11
	JAL	R9,CHKMAC		:GET MAC APPROVAL
	J	CHKMA1			:ERROR IF IMMEDIATE RETURN
	CI      R11,sege
	JGE     CHKMA1    		:CAN'T WRITE TO SEG E OR F
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	L	R3,0,R11	
	JAL	R9,TYPFW,,
	JAL	R9,RDARGS,,		:GET NEW VALUE IN R3
	CLHI	R2,4
	JG	COMER3			:0 OR 1 ARGUMENT ONLY
	JE	WRITF2			:1 ARG
	CLHI	R1,ASCBSL
	JE	WRITF3			: '\'
	CLHI	R1,ASCFSL		: '/'
	JEFS	WRITF3
	CLHI	R1,ASCCR
	JN	COMER3
	JAL	R7,TYPCRL,,		:A CR EXITS US
	J	XPRMPT
WRITF2	ST	R3,0,R11		:STORE THE VALUE
WRITF3	JAL	R7,TYPCRL,,		:CR-LF
	AIS	R11,4
	SIS	R12,4			:DECREMENT COUNT
	JG	WRITF4			:SOME LEFT
	J	XPRMPT

WRERR	LA	R2,ASWRER		:THIS ENTRY MOVED TO THIS LEVEL
	JAL	R7,TYPASC,,
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	XTYPE:/TYPE:	R
::	FUNCTION:	TYPE BLOCK OF STORAGE AS 8 HW PER LINE
::			PRECEEDED BY ADDRESS
::	INPUT:		VALUE1=STARTING ADDRESS
::			VALUE1+4=BYTE COUNT (OPTIONAL,DEFAULT=16)
::
::*********************************************************************

XTYPE
TYPE	JAL	R12,TYPE0
	J	XRCRLF

::*********************************************************************
::
::	SUBROUTINE:	TYPE0:
::	CALLING SEQ:	JAL	R12,TYPE0
::
::*********************************************************************

TYPE0	LHI	R11,10			:DEFAULT TO 16 BYTES
	LHL	R2,ARGCT,XD		:TAKES 0,1, OR 2 ARGUMENTS
	JE	TYPE1
	L	R0,VALUE1,XD		:FIRST ARGUMENT IS ADDRESS
	ST	R0,LASTCL
	CLHI	R2,4
	JEFS	TYPE1			:ONE ARGUMENT (ADDRESS)
	CLHI	R2,8
	JN	COMERR,,
	L	R11,VALUE1+4,XD		:SECOND ARG IS COUNT
TYPE1	L	R10,LASTCL
type2	THI	R10,1			:MUST BE EVEN ADDR
	JN	WRERR

	JAL	R7,TYPCRL,,

TYPE4	LR	R3,R10			:TYPE ADDRESS
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	LIS	R5,8			:EIGHT HW PER LINE
TYPE5	LR	R3,R10
	JAL	R9,CHKMAC
	J	CHKMA1			:ADDRESS OUT OF RANGE, REJECT!
	LHL	R3,0,R10		:TYPE H-WORD
	JAL	R9,TYPHW,,
	AIS	R10,2
	SIS	R11,2			:DECREMENT BYTE COUNT
	JLE	TYPE7			:ALL DONE
	SIS	R5,1
	JG	TYPE5			:NOT DONE WITH PRESENT LINE YET
	JAL	R7,TYPCRL,,		:DONE WITH THIS LINE - TYPE CR-LF

	J	TYPE4			:AND MOVE ON TO NEXT LINE

TYPE7	ST	R10,LASTCL
	JR	R12			:RETURN

::*********************************************************************
::
::	COMMAND:	CHNBFL:	CB
::	FUNCTION:	Chain Through Bufferlets
::			Type as 8 HW Line Preceeded by	Address	 ###wjl
::
::*********************************************************************

CHNBFL	L	R10,VALUE1,XD		:FIRST ARGUMENT IS BUFFERLET NUMBER
	slls    r10,cbszl
	ais     r10,cbptsz
	L	R11,VALUE1+4,XD		:2ND ARG IS CNT OF BFFRLTS TO BE CHND
	JAL	R7,TYPCRL,,		:GO TYPE CR/LF
CHNBF2	LR	R3,R10			:(TYPADD NEEDS ADDRESS IN R3)
	JAL	R9,TYPADD,,		:GO TYPE BUFFERLET ADDRESS
	LHI     R6,CBSZ/10		:NUMBER OF LINES
CHNBF3	LIS	R5,8			:8 HW/LINE
CHNBF4	LR	R3,R10			:(CHKMAC NEEDS ADDRESS IN R3, TOO)
	JAL	R9,CHKMAC		:SKIP RETURN IF ADDRESS IS OK
	J	CHKMA1			:ADDRESS OUT OF RANGE!  ERROR MESSAGE
	LHL	R3,0,R10		:(TYPHW NEEDS HW IN R3)
	JAL	R9,TYPHW,,		:GO TYPE H-WORD
	AIS	R10,2			:INCREMENT ADDRESS
	SIS	R5,1			:DECREMENT H-WORD COUNT
	JG	CHNBF4			:NOT DONE WITH PRESENT LINE YET
	JAL	R7,TYPCRL,,		:DONE WITH THIS LINE - GO TYPE CR/LF
	SIS     R6,1
	JG      CHNBF3
	SIS	R11,1			:DECREMENT COUNT OF BUFFERLETS
	JLE	XRCRLF			:ALL DONE - RETURN WITH CR/LF

	lr	r10,r3		:CALCULATE NEXT BUFFERLET ADDRESS
	slls    r10,cbszl
	ais     r10,cbptsz
	J	CHNBF2			:AND MOVE ON TO NEXT LINE

::*********************************************************************
::
::	SUBROUTINE:	CHKMAC:
::	FUNCTION:	CHECK WITH MAC BEFORE DOING MEMORY REFERENCE
::	CALLING SEQ:	JAL	R9,CHKMAC
::	INPUT:		R3 =	POTENTIAL ADDRESS
::	DESTROYED:	R0, R4
::	RETURNS:	SKIP RETURNS IF ADDRESS IS OK, ELSE DIRECT RETURN
::
::*********************************************************************

CHKMAC	LR	R4,R3			:move address to work register
	NI	R4,@(segsiz-1)		:ISOLATE SEGMENT NUMBER
	EXHR	R4,R4			:into low byte
	if	macv
	srls	r4,4			:move seg over another nibble
	ei	:macv
	CLHI	R4,0F			:MAX SEG. NUMBER IS 15
	JGR	R9			:straight (error) return if TOO BIG
	clhi	r4,0e			:seg e and f are not ordered in cta
	je	chkma3			:is seg e
	jg	chkma4			:is seg f
       if	super
	clhi	r4,0c			:isis sup has seg C that is shared
	je	chkma7			: and is not counted as NC memory
       ei	:super
	SLLS	R4,2			:FORM FW OFFSET
	L	R0,CHKDAT+4,R4,		:COMPARE AGAINST ALLOWABLE SEG. SIZE
	srls	r4,2
	exhr	r4,r4
	if	macv
	slls	r4,4			:restore segment digit
	ei	macv
	ar	r4,r0      
chkma5	cr	r3,r4			:is given address less than end of seg?chkma5	JL	4,R9			:skip return if ADDRESS IS OK
	JL	4,R9			:skip return if address is okay
	JR	R9			:straight return if ADDRESS IS NOT OK
chkma3	li	r4,sege+ctasiz		:seg e check
	jbs	chkma5
chkma4	lhl	r4,lo.clk,,		:local clocks are last thing in segf
	ahi	r4,pagesz-1		:round up to next page
	nhi	r4,-pagesz
	ai	r4,segf			:seg f last address
	j	chkma5
       if	super
chkma7	li	r4,s5end		:shared segment end
	j	chkma5
       ei	:super

CHKMA1	LA	R2,ASMCER
	JAL	R7,TYPASC,,		:TYPE OUT ERROR MESSAGE
	J	XPRMPT,,

	SUBTTL	XRAY (Crash info display routines - DC, DCS, DCD)

::*********************************************************************
::
::	COMMAND:	XDCRSH:	DC, DCS, DCD
::	FUNCTION:	DISPLAY CRASH SUMMARY OR DETAIL TABLE OR BOTH
::
::*********************************************************************

	NOLIST
XDCSH1	SC	/"0D"0ACRASH SUMMARY TABLE/
XDCDH1	SC	/"0D"0ACRASH DETAIL TABLE/
XDCHDR	SC	/"0D"0ATIME           CC   TYPE  PSW   ADDRESS"0D"0A/
XDCDH3	SC	/"0D"0AUSER REGISTER SET:/
	LIST

XDCRSH	clhi	r1,ascd			:a D?
	JE	XDCRDT			:YES, GO DO DETAIL TABLE
	clhi	r1,asch			:user end with 'h'
	je	xdcrm0			:display crash area as simple memory
	clhi	r1,asci			:asking for isis crash table?
	je	xdcisi			:yep, give it to em
	CLHI	R1,ASCS			:DID USER END WITH 'S'(x53)?
	JNFS	XDCRS1			:NO
	LI	R11,XRCRLF		:FINISHED AFTER DOING SUMMARY TABLE
	JFS	XDCRSM			:GO DO SUMMARY TABLE
XDCRS1	CLHI	R1,ASCCR		:DID USER END WITH C/R (x0D)?
	JN	COMERR			:NO, ERROR
	LI	R11,XDCRDT		:GO DO DETAIL AFTER DOING SUMMARY

:	DISPLAY CRASH SUMMARY TABLE
XDCRSM	LI	R10,XDCRS3		:CONTINUATION POINT
	LIS	R12,0			:INDEX TO SUMMARY TABLE ENTRIES
	LI	R14,CSMTBL		:POINTER TO SUMMARY TABLE
	LA	R2,XDCSH1		:GET HEADER
	JAL	R7,TYPhdr,,		:TYPE IT
XDCRS4	LA	R2,XDCHDR
	JAL	R7,TYPhdr,,
	LHL	R6,CSMCNT		:NUMBER OF SUMMARY ENTRIES
	JER	R11			:RETURN IF NONE
XDCRS2	L	R2,CS.TIM,R14,R12	:GET CRASH TIME
	JAL	R9,GMTCNX,,		:DISPLAY IT
	JAL	R7,TYP2SP,,
	LHL	R3,CS.CNT,R14,R12	:CRASH COUNT
	JAL	R9,TYPHWD,,
	LHL	R3,CS.CID,R14,R12	:CRASH ID
	JAL	R9,TYPHW,,
	LHL	R3,CS.PSD+2,R14,R12	:CRASH PSW
	JAL	R9,TYPHW,,
	L	R3,CS.PSD+4,R14,R12	:CRASH PC
	JAL	R9,TYPFW,,
	JAL	R7,TYPCRL,,
	JR	R10
XDCRS3	AHI	R12,CS.SIZ		:NEXT ENTRY
	CLHI	R12,CSMTBS		:DONE?
	JGER	R11			:YES, DONE
	SIS	R6,1			:DEC COUNT OF ENTRIES
	JG	XDCRS2			:NO, DO NEXT ENTRY
	JR	R11			:DONE

XDCRDT	LI	R14,CDTTBL		:POINT TO DETAIL TABLE
	LIS	R12,0			:INDEX INTO DETAIL TABLE
	LA	R2,XDCDH1		:HEADER
	JAL	R7,TYPhdr,,
XDCRD2	LI	R11,XRCRLF		:GO HERE WHEN ALL DONE
	LHL	R6,CDTCNT		:load count of detail entries
	JER	R11			:none, all done			###wjl
	LI	R10,XDCRD1		:SET UP RETURN POINTER
	J	XDCRS4
:	RETURN HERE FROM XDCRS2 AFTER TYPING FIRST LINE
XDCRD1	AR	R14,R12
	LR	R6,R14
	AHI	R6,CD.RSF		:POINT TO REG SET F SAVE AREA
	LA	R2,XDCDH3		:"User REGISTER SET"
	JAL	R7,TYPhdr,,
	LHI	R5,10			:TYPE 16D REGISTERS
	JAL	R8,TYPNFW

	LR	R12,R12
	JN	XPRMPT
	AHI	R12,CD.SIZ		:NEXT DETAIL ENTRY
	LHL	R6,CDTCNT		:# OF DETAIL ENTRIES - 1 OR MORE?###GT
	SIS	R6,1
	JER	R11			:NO, ALL DONE
	J	XDCRD2

:	print out the memory for the crash table.  usefulin case machine was
:	reloaded.
xdcrm0	lhi	r10,crshdr		:start address
	lhi	r11,clseg0-crshdr	:length
	jal	r12,type2
	j	xrcrlf

:	print out the isis crash table
xdcim1	sc	/"0d"0a****** ISIS CRASH TABLES ******"0d"0aNODE   TYPE  VERSN    TAKTIM      CC   BOOT_ERRCODE"0d"0a/
xdcim2	sc	/"0d"0aREGISTER SET 0/
xdcim3	sc	/"0d"0aREGISTER SET F/
xdcim4	sc	/"0d"0aMAC REGISTERS/
xdcim5	sc	/"0d"0aLAST SLOT RUN: /
xdcim6	sc	/"0d"0a"0a*** EXTENDED ISIS CRASH TABLES ****"0d"0aINTERUPT    PSW      PC     FASTC"0d"0a/
xdcim7	sc	/"0d"0aMAC ADDRESSES 340 to 380/


xdcisi	la	r2,xdcim1		:print header
	jal	r7,typhdr,,
	lhl	r11,lct,,		:get pointer of crash table
	ai	r11,segf		:convert to address
	lhl	r3,0,r11		:get node number
	jal	r9,typ5o,,		:print it in octal
	lhl	r3,2,r11		:engine type
	jal	r9,typhw,,
	lhl	r3,6,r11		:isis version
	jal	r9,typhwd,,		:that is in decimal
	l	r2,8,r11		:get time of takeover
	jal	r9,typigm
	jal	r7,typ2sp,,
:	we have time in seconds since start
xdci08	lhl	r3,0c,r11		:crash count
	jal	r9,typhwd,,		:print it in decimal
	lhl	r0,4,r11		:get crash table version
	sis	r0,1			:is it version 1?s
	jgfs	xdci10
	ahi	r11,0e			:point to summary table
	lhi	r12,$a 16		:number of summaries
	jfs	xdci12			:and skip what isn't present
:	have version 2 of crash table
xdci10	la	r10,0e,r11		:print any boot errors
	lis	r5,2
	jal	r8,typnhw,,		:it is two halfwords
	ahi	r11,1e			:point to summary table
	lhi	r12,$a 32		:number of summaries
:	now ready to display summary table
xdci12	la	r2,xdchdr		:print header
	jal	r7,typasc,,
xdci15	lhl	r3,0,r11		:get the crash count
	jefs	xdci25			:zero, must be end of entries
	jal	r14,xdcism		:display summary table
	ahi	r11,10			:do another summary table entry
	sis	r12,1			:if not all done
	jg	xdci15
:	now do detail table
xdci25	sis	r12,1			:first move pointer past summary table
	jl	xdci27
	ahi	r11,10			:point to next extry
	jbs	xdci25
:	now pointing to detail table
xdci27	la	r2,xdcdh1		:the detail entry header
	jal	r7,typasc,,
	lis	r12,2			:Number of detail table entries
xdci29	lhl	r3,0,r11		:is there a crash count
	je	xdci35			:no, skip this entry
	la	r2,xdchdr		:the header for the summary
	jal	r7,typasc,,
	jal	r14,xdcism		:first comes summary info
	jal	r14,xdcidt		:next comes regs and mac regs
	la	r2,xdcim5		:last slot run
	jal	r7,typasc,,
	lhl	r3,0f0,r11
	jal	r9,typhwd,,
	ahi	r11,0f2			:size of detail table
	sis	r12,1			:done with this entry
	jg	xdci29
xdci35	lhl	r11,lct,,		:get crash table address
	ai	r11,segf		:make to pointer
	lhl	r0,4,r11		:crash table version
	sis	r0,1
	jle	xprmpt			:done if version 1
	ahi	r11,404			:point to interupt info
	la	r2,xdcim6		:header
	jal	r7,typasc,,
	lr	r6,r11			:pointer to data
	lis	r5,4
	jal	r8,typnfw,,		:the interupt info
	jal	r14,xdcidt
	la	r2,xdcim7		:mac area 340-380
	jal	r7,typasc,,
	lhi	r5,10
	la	r6,0d0,r11		:address of mac registers
	jal	r8,typnfw,,
	j	xprmpt,,		:and done (finally)

:	little subroutine to print the detail table info
:	link on r14, pointer in r11
xdcidt	la	r2,xdcim2		:register set 0
	jal	r7,typasc,,
	lhi	r5,10
	la	r6,10,r11		:address of reg set 0
	jal	r8,typnfw,,
	la	r2,xdcim3		:register set F
	jal	r7,typasc,,
	lhi	r5,10
	la	r6,50,r11		:address of reg set F
	jal	r8,typnfw,,
	la	r2,xdcim4		:mac registers
	jal	r7,typasc,,
	lhi	r5,18
	la	r6,90,r11		:address of mac registers
	jal	r8,typnfw,,
	jr	r14

:	print an isis summary table.  Link on r14.  r11 pointer
xdcism	l	r2,0c,r11		:get time
	jal	r9,typigm,,		:print it
	jal	r7,typ2sp,,
	lhl	r3,0,r11		:get the crash count
	jal	r9,typhwd,,		:print crash count	
	lhl	r3,2,r11		:crash code
	jal	r9,typhw,,
	lhl	r3,6,r11		:program status word
	jal	r9,typhw,,
	l	r3,8,r11		:program counter
	jal	r9,typfw,,
	jal	r7,typcrl,,		:next goes on a new line
	jr	r14			:and done


:	convert isis gmt to seconds since start of year
:	link on r9, isis's gmt in r2
typigm	lr	r2,r2			:was isis taken over?
	jl	typig7			:not if high bit set
	SI	r2,$A((1992-1973)*365*24*3600)+(((1992-1972)/4)*24*3600)
typig3	CI	r2,$A(4*365*24*3600)+(24*3600)	:HAS A LEAPYEAR PASSED SINCE?
	JLEFS	typig5			:NO, SO SKIP
	SI	r2,$A(4*365*24*3600)+(24*3600)	:ADJUST FOR QUADYEAR PASSED
	JBS	typig3			:AND CHECK AGAIN
typig5	LI	R6,$A(365*24*3600)	:SEC'S IN NORMAL YEAR
typig6	sr	r2,r6			:reduce it for each year
	jgebs	typig6
	ar	r2,r6			:back up to a positive value
	ai	r2,(24*3600)		:plus one day (there is no day 0)
	jfs	typig8
:	not taken over, just knock off high bit
typig7	ni	r2,7fffffff		:assume it will not run a year untaken
typig8	slls	r2,7			:set up for gmtcnx
	j	gmtcnx,,			:let it return to our caller


	SUBTTL	XRAY (Node statistics - NS)

::*********************************************************************
::
::	COMMAND:	XSTATS:	NS
::	FUNCTION:	DISPLAY NODE STATUS DATA
::
::*********************************************************************

XSTATS	clhi    r1,asch   		:close with H (clear highwater?)
	jn      xst64
	lis     r0,0
	st	r0,nscpho 		:clear hghwtr log out
	st	r0,nscphi 		:clear hghwtr log in
	st	r0,ns.pho 		:clear hghwtr phys out
	st	r0,ns.phi 		:clear hghwtr phys in
	st	r0,ns.otl		:time of logical out
	st	r0,ns.itl		:time of logical in
	st	r0,ns.otp		:time of physical out
	st	r0,ns.itp		:time of physical in
	jfs     xst65
xst64	CLHI	R1,ASCZ			:DID USER CLOSE WITH 'Z'(x5A)?
	JN	XST44			:NO, JUST DISPLAY ALL DATA
xst65	LIS	R0,0			:YES, CLEAR PROCESS HW-MARKS
	LHI	R10,$A60		:CLEAR FOR 15 PROCESSES
XST66	ST	R0,PROHWM,R10
	CLHI	R10,0C			:REACHED INDEX FOR EXLAVG YET?
	JGFS	XST63			:NO
	ST	R0,EXLAVG,R10		:YES, CLEAR VARIOUS COUNTERS
XST63	SIS	R10,4
	JGEBS	XST66
       if	super
	ST	R0,SUICCW		:clear highwater in for SUP
	ST	R0,SUOCCW		:clear highwater out for SUP
	ST	R0,KRICCW		:clear highwater in for KIO
	ST	R0,KROCCW		:clear highwater out for KIO
       ei	:super
	LHI	R0,$A9999		:reset EXLALW to max on "NSZ"
	STH	R0,EXLALW		:SET LOW WATER MARK TO MAX
	LHL	R0,PASTHR
	STH	R0,MXPASS		:INITIALIZE MAX NUMBER OF PASS-THRUS
	LHL	R0,HNPORT
	STH	R0,MXPORT		:MAXIMUM NUMBER OF PORTS IN USE
	LHL	R0,NALINK
	STH	R0,MXLINK		:AND MAXIMUM NUMBER OF LINKS
	jfs	xst46

XST44   clhi    r1,ascl   		:asking for lines?
	je      xnsl00    		:yes goto that routine
	clhi	r1,asccr		:must end with CR
	jn	comerr
xst46	LA	R2,XSTHD1		:DISPLAY LINE OF HEADER INFORMATION
	JAL	R7,TYPhdr,,
	LIS	R10,8			:8 HW OF STATISTICS
	LIS	R11,0
XSTAT3	LHL	R3,EXLAVG,R11
	JAL	R9,TYPHWD,,
	AIS	R11,2
	SIS	R10,1
	JGBS	XSTAT3
	LHL	R3,MXPORT
	JAL	R9,TYPHWD,,		:DISPLAY MAXIMUM NUMBER OF PORTS 
	LHL	R3,MXPASS
	JAL	R9,TYPHWD,,		:DISPLAY MAX NUMBER OF PASSTHRUS
	LHL	R3,MXLINK		:DISPLAY MAXIMUM NUMBER OF LINKS
	JAL	R9,TYPHWD,,
	JAL	R7,TYPCRL,,

	LA	R2,XSTHD2		:HEADER FOR RMAKE STATS
	JAL	R7,TYPhdr,,

	L	R3,RMKRMS		:NUMBER OF RMAKE CALLS LAST MINUTE
	JAL	R9,TYPFWD,,
	L	R3,RMKNRS		:RMAKE CALLS FOR WHICH NO RECORD MADE
	JAL	R9,TYPFWD,,
	L	R3,RMKRMS
	S	R3,RMKNRS		:DIFFERENCE IS NUMBER OF PACKETS MADE
	JAL	R9,TYPFWD,,
	l       r3,rmklrs
	jal     r9,typfwd,,     	:logical records made
	l       r3,rtdpks 		:packets torn
	jal     r9,typfwd,,
	l       r3,rtdlrs 		:records torn
	jal     r9,typfwd,,

:	LINKS TOTAL LOGICAL CPS 
	la	r5,xstndl		:table for logical cps stats
	jal	r10,xstcps

:	NODE LINKS' TOTAL PHYSICAL CPS RATES (and KIO CPS if sup)
	la	r5,xstndp		:table for physical cps stats
	jal	r10,xstcps

:	SUP RINGS CPS STATS
       if	super
	la	r5,xstsup		:table for sup cps stats
	jal	r10,xstcps
:	KIO RINGS CPS STATS
	la	r5,xstkio		:table for sup cps stats
	jal	r10,xstcps
       ei	:sup

XNSPER	LA	R2,XSTHD7		:PERFORMANCE HEADER
	JAL	R7,TYPhdr,,
	l	r2,ns.swd		:get software delay
	lr	r10,r2
	JAL	R9,FSTMSC,,		:convert FASTC to MSEC		###wjl
	lr	r6,r3			:save converted SW delay
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	l	r2,ns.hwd		:get hardware delay
	ar	r10,r2			:get total delay in tics
	JAL	R9,FSTMSC,,		:convert FASTC to MSEC		###wjl
	ar	r6,r3			:get total converted delay
	JAL	R9,TYPHWD,,		:DISPLAY DECIMAL RESULT IN MS
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	lr	r3,r6
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	LIS	R3,0			:TAKE PRECAUTION AGAINST ZERO DIVIDE
	l	r12,totchr
	srls	r12,5
	lr	r10,r10
	JEFS	XNSPE5			:DON'T DIVIDE BY ZERO

					:OUT QUEUE DELAYS FOR US
	DHR	R12,R10			:COMPUTE EFFICIENCY FOR ISIS NODE
	LR	R3,R13
XNSPE5	JAL	R9,TYP5DD,,

	LA	R2,XSTMS0		:HEADER
	JAL	R7,TYPhdr,,
	LIS	R10,$A 10		:DISPLAY time for 10 processes
	LIS	R11,0
	LHL	R12,MININT		:EXACT MEASUREMENT INTERVAL
	LHI	R14,$A100
XNS22	JAL	R7,TYP2SP,,		:2 SPACES FOR NEAT DISPLAY
	LHL	R2,PSVTIM+2,R11,	:SKIP THE BUFFER-ZAP PROCESS
	MHR	R2,R14			:MULTIPLY BY 100
	DHR	R2,R12			:DIVIDE BY TIME INTERVAL TO GET PERCENT
	JAL	R9,HEXDEC,,
	JAL	R9,TYPBYT,,		:DISPLAY IT
	AIS	R11,2
	SIS	R10,1
	JG	XNS22
	LA	R2,XSTMS1
	JAL	R7,TYPhdr,,
	LIS	R10,$A 10		:DISPLAY time for 10 PROCESSES
	LIS	R11,0
XNS33	LHL	R2,PROHWM+6,R11		:SKIP THE BUFFER-ZAP PROCESS
	JAL	R9,FSTMSC,,		:convert FASTC to MSEC		###wjl
	JAL	R9,TYPHWD,,		:DISPLAY PEAK TIME IN MILLISECONDS
	AIS	R11,4
	SIS	R10,1
	JGBS	XNS33

	J	XRCRLF			:DONE


XNSL00  LA      R2,XNST01 		:user wants statistics for all lines
	JAL     R7,TYPhdr,,
	LA      R2,XNST02
	JAL     R7,TYPhdr,,
	LCS     LN,1      		:for all active lines
XNSL03  AIS     LN,1      		:do next line
	CLHI    LN,NLINES
	JGE     XRCRLF
	LH      R1,NGSVLN,LN,LN 	:it is active?
	JGEBS   XNSL03    		:nope
	LR      R3,LN     		:print line #
	JAL     R9,TYPBYD,,
	LA      R2,XNDHSY 		:print lne type
	IF      SILINS
	CLHI    LN,NLINES-SILINS
	JLFS    XNSL07    		:is still a sync line
	LA      R2,XNDHSI 		:is a sio line
      EI	:SILINS
XNSL07  JAL     R7,TYPASC,,     	:line type
	LHL     R3,BAUDRT,LN,LN 	:get line speed
	NHI	R3,1F     		:only the speed
	jal	r7,prtspd
	LHL     R3,NGSVLN,LN,LN

	NHI     R3,7FFF   		:just the node number
	JAL     R9,TYP5o,,     		:print node number
	LR      KX,LN     		:setup KX as link descriptor
	ar	KX,kx
	L	KX,KDLN,KX,KX   	:and KX is link descriptor
	ST	KX,XKDSAV,XD    	:setup for other xray routines
	LB	R0,LKNM,KX
	STH	R0,XKNSAV,XD
	LB	R3,KSPD,KX		:get link speed
	NHI	R3,1F     		:only the speed
	JAL	R7,prtspd
	JAL	R8,CHNCNT 		:then how amny channels
	JAL	R9,TYPHWD,,     	:in decimal
	LHL	R6,MTTINT 		:Atime interval
	L	R2,KS.LMI,KX    	:last minute's logical input cps
	DHR	R2,R6
	JAL	R9,TYPFWD,,
	L	R2,KS.LMO,KX    	:last minute's logical output cps
	DHR	R2,R6
	JAL	R9,TYPFWD,,
	L	R2,KS.PMI,KX    	:last minute's physical input cps
	DHR	R2,R6
	JAL	R9,TYPFWD,,
	L	R2,KS.PMO,KX
	DHR	R2,R6     		:last minute's physical output cps
	JAL	R9,TYPFWD,,
	JAL	R7,TYPCRL,,
	J	XNSL03    		:next line

:	          0      4      8     0c     10     14      18
xstndl	wc	xsthd3,ns.otl,nscpso,nscpsi,nscpho,nscphi,ns.itl
xstndp	wc	xsthdb,ns.otp,ns.pco,ns.pci,ns.pho,ns.phi,ns.itp
       if	super
xstsup	wc	xsthd9,sup.ot,suocct,suicct,suoccw,suiccw,sup.it
xstkio	wc	xsthda,ker.ot,krocct,kricct,kroccw,kriccw,ker.it
       ei	:super
:	a standard routine to print TOTAL CPS RATES for logical link
:	cps, physical link cps, sup ring cps and kio rings cps
:	links on r10, r5 has address of desired table

xstcps	L	R2,0,r5			:HEADER FOR CPS STATS
	JAL	R7,TYPhdr,,
	LA	R2,XSTHD8
	JAL	R7,TYPhdr,,
	LA	R2,XSTHD4
	JAL	R7,TYPhdr,,
	l	r2,4,r5			:address of gmt of hwm out
	l	r2,0,r2			:value at address
	jal	r9,gmtcnx,,
	JAL	R7,TYPCRL,,
	L	R3,8,r5			:address CPS OUT
	L	R3,0,r3			:value CPS OUT
	JAL	R9,TYPFWD,,
	L	R3,0c,r5		:address CPS IN
	l	r3,0,r3			:value CPS IN
	JAL	R9,TYPFWD,,
	L	R3,10,r5		:address HI-WATER MARK OUT
	L	R3,0,r3			:value HI-WATER MARK OUT
	JAL	R9,TYPFWD,,
	L	R3,14,r5		:address HI-WATER MARK IN
	L	R3,0,r3			:value HI-WATER MARK IN
	JAL	R9,TYPFWD,,
	LA	R2,XSTHD5
	JAL	R7,TYPhdr,,
	l	r2,18,r5		:address gmt of hwm in
	l	r2,0,r2			:value gmt of hwm in
	jal	r9,gmtcnx,,
	jr	r10


:	prtspd	a service routine to take the link speed in r3 and display
:		the appropriate link speed.
prtspd	lis	r2,0
prtsp1	clh	r3,hspeet,r2
	jlefs	prtsp2
	ais	r2,2
	jbs	prtsp1
:	found a speed
prtsp2	lhl	r2,hspeem,r2		:get the msg for that speed
	la	r2,hspeeb,r2		:get absolute address of msg
	j	typasc,,		:print it and return to caller

	SUBTTL	XRAY (Link statistics - KS)

::*********************************************************************
::
::	COMMAND:	XKS:	KS
::	FUNCTION:	DISPLAY LINK STATISTICS
::
::*********************************************************************

:	NODE CODE ROUTINE MTRFIC GATHERS LINK TRAFFIC COUNTS FOR LOGICAL
:	AND PHYSICAL COUNTS. COUNT INTERVAL IS NUMBER OF SECONDS IN MTTINT

XKSCIU	WS	1			:0 IF KS NOT IN USE, ELSE XD OF USER
xkstmp  ws      1         		:save for display ks data routine

XKS	L	R2,XKSCIU		:ANYBODY HERE ALREADY?
	JN	XCOMIU			:YES, COMMAND IN USE MESSAGE
	ST	XD,XKSCIU		:MARK IT IN USE
	LIS	R2,0			:CLEAR STATS ZERO FLAG		###OAS
	STH	R2,XKSZFG		:FOR KSZ COMMAND		###OAS
	CLHI	R1,ASCS			:IS LAST CHAR AN 'S'(x53)?
	JE	XKSSS0			:YES, DISPLAY ALL LINKS		###OAS
	CLHI	R1,ASCZ			:IS LAST CHAR A 'Z'(x5A)?	###OAS
	Jefs	XKSs04			:yes
	clhi	r1,asccr		:else must end with CR
	je	xks00
	st	r2,xksciu		:cmd is not in progress
	j	comerr
	
xkss04	TS	XKSZFG			:YES, FLAG FOR STATS CLEAR	###OAS
	J	XKS00			:AND CONTINUE			###OAS
XKSSS0	LHI	R14,(NLINKS-1)*2	:count of links to do
XKSSS	L	R10,KDKN,R14,R14	:GET LINK DESCRIPTOR POINTER
	LB	R0,NLAT,R10		:ANY LINES ATTACHED TO THIS LINK?
	JEFS	XKSSS1			:NO, GO ON TO NEXT LINK
	LHL	R3,NDID,R10		:YES, GET THE NEIGHBOR
	JAL	R9,HEXOCT,,		:##AL
	sth     r14,argct,xd	   	:save number left to do
	jal     r8,xksdis
	lhl     r14,argct,xd
XKSSS1	SIS	R14,2			:ADVANCE TO NEXT LINK
	JGE	XKSSS
	lis     r2,0
	st      r2,xksciu 		:command no longer in use
	j       xrcrlf    		:and done

:       here if given a list of node numbers
XKS00	LHL	R2,ARGCT,XD		:GET ARG COUNT
	JNFS	XKS01
	ST	R2,XKSCIU		:MARK COMMAND NOT IN USE
	J	XRCRLF			:ALLDONE
XKS01	SIS	R2,4			:DEC ARG COUNT
	STH	R2,ARGCT,XD		:AND RESTORE
	L	R3,VALUE1,R2,XD		:GET NEXT NEIGHBOR		###SHM
	jal     r8,xksdis 		:display fo rthis line
	j       xks00

:       xksdis displays the KS data for the octal node number in r3
xksdis  st      r8,xkstmp 		:save return
	LR	R10,R3			:AND SAVE IT
	JAL	R9,OCTHXR,,		:AND GO HEX
	LR	R1,R3
	JAL	R9,XFNDLK		:FIND LINK REQUESTED
	SKIPAD(XKS03)			:immed ret, NO SUCH LINK, GO HANDLE
	JFS	XKS02			:+4 RETURN - LINK VALID, GO DISPLAY
XKS03	LIS	R2,0
	ST	R2,XKSCIU		:RESET BUSY FLAG AND
	J	COMERR			:LINK NOT THERE, COMPLAIN
XKS02	LR	R3,R10			:RECOVER NEIGHBOR
	LA	R2,XKSM19		:TYPE HEADER
	JAL	R7,TYPhdr,,
	JAL	R9,TYP5CH,,		:AND DISPLAY IT
	L	KX,XKDSAV,XD		:RECOVER KD INTO KX FOR THIS NGHBR##OAS

:	CHECK FOR STATISTICS CLEAR COMMAND AND ZERO THE LINK DESCRIPTOR STATS
:	HIGH WATER MARKS FOR THE SPECIFIED LINK(S) IF CLEAR FLAG IS NON-ZERO

	LH	R1,XKSZFG		:CHECK STATS CLEAR FLAG		###OAS
	JE	XKS09			:NO 'Z' SPECIFIED		###OAS
	LIS	R2,0			:				###OAS
	ST	R2,KS.PHO,KX		:CLEAR PACKET CHARS OUT HWM	###OAS
	ST	R2,KS.PHI,KX		:CLEAR PACKET CHARS IN HWM	###OAS
	ST	R2,KS.LHO,KX		:CLEAR LOGICAL CHARS OUT HWM	###OAS
	ST	R2,KS.LHI,KX		:CLEAR LOGICAL CHARS IN HWM	###OAS
	ST	R2,KS.OTL,KX		: time of output logical max
	ST	R2,KS.OTP,KX		: time of ouput physical max
	ST	R2,KS.ITL,KX		: time of input logical max
	ST	R2,KS.ITP,KX		: time of input physcial max
	LA	R2,XKSM25		:DISPLAY 'STATISTICS CLEARED'	###OAS
	JAL	R7,TYPhdr,,		:FOR THIS NEIGHBOR		###OAS
	l       r8,xkstmp
	jr      r8        		:process next neighbor

:	COPY RELEVANT FIELDS FROM LINK DESCRIPTOR TO SAVE AREA SO
:	KS DISPLAY USES CONSISTENT DATA
XKS09	LHI	R1,KSSZ-4		:7 GROUPS OF 12 BYTES EACH	###OAS
XKS10	L	R0,KS.PCO,KX,R1
	ST	R0,KS.PCO+XKSSKD,R1 	:SAVE AREA
	SIS	R1,4
	JGEBS	XKS10

:	COMPUTE LINK'S CPM RATE OVER REPORTING INTERVAL
	LB	R1,KSPDmt,KX		:get indexed val for lookup
	LHL	R4,KSPCPS,R1,R1		:GET LINK'S CPS RATE,
	LHL	R14,MTTINT		:MEASUREMENT INTERVAL IN SECS IN R14
	LIS	R3,0
	MR	R3,R14			: COMPUTE NUMBER OF CHARACTERS OVER 
	ST	R4,KS.PCO+XKSSKD	: REPORTING INTERVAL AND SAVE

	LA	R2,XKSM01		:'LOGICAL LINK CHARACTERS'
	JAL	R7,TYPhdr,,		:HEADER LINE
	LA	R2,XKSM03		:'CPS IN :'
	JAL	R7,TYPhdr,,
	L	R2,KS.LMI+XKSSKD	:LAST MINUTE'S LOGICAL CHARS IN
	DHR	R2,R14			:COMPUTE NUMBER PER SECOND
	LR	R10,R3			:SAVE FOR LATER
	JAL	R9,TYPFWD,,		: AND DISPLAY
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPhdc,,
	L	R2,KS.LHI+XKSSKD	:LOGICAL CHARS IN HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	la	r2,xishd3		: ' AT '
	JAL	R7,TYPhdc,,
	l	r2,ks.itl+XKSSKD	: time of hwm
	jal	r9,gmtcnx,,
	LA	R2,XKSM04		:'CPS OUT:'
	JAL	R7,TYPhdr,,
	L	R2,KS.LMO+XKSSKD	:LAST MINUTE'S LOGICAL CHARS OUT
	DHR	R2,R14
	LR	R12,R3			:SAVE CPS OUT
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPhdc,,
	L	R2,KS.LHO+XKSSKD	:LOGICAL CHARS OUT HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	la	r2,xishd3		: ' AT '
	JAL	R7,TYPhdc,,
	l	r2,ks.otl+XKSSKD	: time of hwm
	jal	r9,gmtcnx,,

	LA	R2,XKSM02		:'PHYSICAL LINK CHARACTERS'
	JAL	R7,TYPhdr,,
	LA	R2,XKSM03		:'CPS IN :'
	JAL	R7,TYPhdr,,
	L	R2,KS.PMI+XKSSKD	:LAST MINUTE'S PHYSICAL CHARS IN
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPhdc,,
	L	R2,KS.PHI+XKSSKD	:PHYSICAL CHARS IN HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	la	r2,xishd3		: ' AT '
	JAL	R7,TYPhdc,,
	l	r2,ks.itp+XKSSKD	: time of hwm
	jal	r9,gmtcnx,,
	LA	R2,XKSM04		:'CPS OUT:'
	JAL	R7,TYPhdr,,
	L	R2,KS.PMO+XKSSKD	:LAST MINUTE'S PHYSICAL CHARS OUT
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPhdc,,
	L	R2,KS.PHO+XKSSKD	:PHYSICAL CHARS OUT HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	la	r2,xishd3		: ' AT '
	JAL	R7,TYPhdc,,
	l	r2,ks.otp+XKSSKD	: time of hwm
	jal	r9,gmtcnx,,

	LA	R2,XKSM06		:'PACKET OVERHEAD   BANDWIDTH UTIL'
	JAL	R7,TYPhdr,,
	LA	R2,XKSM07		:'IN :'
	JAL	R7,TYPhdr,,
	L	R3,KS.PMI+XKSSKD	:PACKET CHARACTERS IN
	LR	R4,R3
	S	R3,KS.LMI+XKSSKD	:PACKET - LOGICAL = OVERHEAD CHARACTERS
	JAL	R9,DECPER,,		:COMPUTE PACKET OVERHEAD IN
	LA	R2,XKSM08		:'OUT :'
	JAL	R7,TYPhdc,,
	L	R3,KS.PMO+XKSSKD	:PACKET CHARACTERS OUT
	LR	R4,R3
	S	R3,KS.LMO+XKSSKD
	JAL	R9,DECPER,,		:COMPUTE PACKET OVERHEAD OUT

	LA	R2,XKSM07		:'IN :'
	JAL	R7,TYPhdc,,
	L	R4,KS.PCO+XKSSKD	:RETRIEVE LINK'S CPM RATE
	L	R3,KS.PMI+XKSSKD	:LAST MINUTE'S CHARS IN
	JAL	R9,DECPER,,		:COMPUTE BANDWIDTH UTILIZATION IN
	LA	R2,XKSM08		:'OUT :'
	JAL	R7,TYPhdc,,
	L	R4,KS.PCO+XKSSKD
	L	R3,KS.PMO+XKSSKD	:LAST MINUTE'S CHARS OUT
	JAL	R9,DECPER,,		:COMPUTE BANDWIDTH UTILIZATION OUT

	LA	R2,XKSM22		:'CHAR/SEC PER CIRCUIT'
	JAL	R7,TYPhdr,,
	JAL	R8,CHNCNT		:COUNT NUMBER OF CHANS ACTIVE ON LINK
	LR	R14,R3			:SAVE IT
	JEFS	XKS11			:DONT DIVIDE BY ZERO		###OAS
	LR	R2,R10			:MOVE OVER CPS IN
	DHR	R2,R14			:GET CPS PER CHANNEL
XKS11	JAL	R9,TYPHWD,,		:AND DISPLAY##AL
	LA	R2,XKSM23		:'OUT :'
	JAL	R7,TYPhdc,,
	LR	R3,R14			:DONT DIVIDE BY ZERO		###OAS
	JEFS	XKS12			:				###OAS
	LR	R2,R14			:round to closest number	###sdw
	SRLS	R2,1			:add in half of the divisor	###sdw
	AR	R2,R12
	DHR	R2,R14			:GET CPS PER CHANNEL OUT
XKS12	JAL	R9,TYPHWD,,		:DISPLAY##AL
	LA	R2,XKSM24		:'CIRCUITS :'
	JAL	R7,TYPhdc,,
	LR	R3,R14
	JAL	R9,TYPHWD,,		:DISPLAY NUMBER OF ACTIVE CHANNELS

	LA	R2,XKSM12		:'PACKET STATISTICS'
	JAL	R7,TYPhdr,,		:'PACKETS/SEC :'
	LHL	R2,KS.PKM+XKSSKD
	LHL	R14,MTTINT		:GET PRECISE MEASUREMENT INTERVAL
	LR	R7,R14			:round instead of truncate	###sdw
	SRLS	R7,1
	AR	R2,R7			:add half the divisor before dividing
	DHR	R2,R14			:FORM PACKETS/SEC
	JAL	R9,TYPHWD,,		:AND DISPLAY##AL

	LA	R2,XKSM14		:'AVERAGE SIZE :'
	JAL	R7,TYPhdc,,
	LHL	R3,KS.ASZ+XKSSKD
	JAL	R9,TYPHWD,,		:DISPLAY AVERAGE PACKET SIZE
	LA	R2,XKSM16		:FOLLOW IT WITH 'BYTES'
	JAL	R7,TYPhdr,,

	LA	R2,XKSM13		:'RECORDS/PACKET : '		###JHL
	JAL	R7,TYPhdr,,		:TYPE THE STRING		###JHL
	LHL	R3,KS.LRA+XKSSKD	:				###JHL
	JAL	R9,TYPHWD,,		:DISPLAY AVE NUMBER OF RECDS PER PKT

:	LINK DELAY (MS)
	LA	R2,XKSM15		:'LINK DELAY (MS)'
	JAL	R7,TYPhdr,,	
XSSYLV	LHL	R2,SYLXAV		:GET AVE INTERVAL BETWEEN SYLVER RUNS
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	LR	R10,R3			:SAVE RESULT...
	JAL	R9,TYPHWD,,		:AND DISPLAY 'IN QUEUE' DELAY
	
XSRTD	LHL	R2,KS.SRA+XKSSKD	:average time between SYLVER & RTEAR
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ADD IN RESULT
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY DECIMAL 'RTEAR' delay IN MS

	IF	BFLTMR
	LHL	R2,BFDOPT,,		:test control cell for dly calc method
	JN	XSRRT			:must be set non-zero for old method
:	compute avg timing pair delay, and output it
	LHL	R2,KS.BFC,KX		:must check for zero divisor
	JNFS	XS100
	LIS	R3,0
	JFS	XS110
XS100	LHL	R1,KS.BFD,KX		:read acc'ed buffer delay
	DHR	R1,R2			:quotient in R2	, remainder in R1
	JAL	R9,FSTMSC		:convert to milliseconds (ret in R3)
XS110	AR	R10,R3			:add into total delay
	JAL	R7,TYP4SP,,		:space on out...
	JAL	R9,TYPHWD,,		:and output delay time (dec ms)
	JFS	XSAQU			:jump to output outqueue delay
	EI	:BFLTMR

XSRRT	LHL	R2,KS.RRT+XKSSKD	:average time per round robin in FASTC
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:SAVE RESULT...
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY RMAKE 'BUFFER' DELAY

XSAQU	LHL	R2,KS.AQU+XKSSKD	:average queueing delay, RMAKE-SYLVEX
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ACCUMULATE DELAY
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY 'OUT QUEUE' delay

XSXMIT	LHL	R2,KS.XMT+XKSSKD	:average packet transmission time
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ACCUMULATE DELAY
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:display 'XMIT' delay

XSTOTL	LR	R3,R10			:GET 'TOTAL' DELAY
	JAL	R7,TYP4SP,,	
	JAL	R9,TYPHWD,,		:AND DISPLAY

	LA	R2,XKSM10		:'OVERLOAD COUNT'
	JAL	R7,TYPhdr,,	
	LHL	R3,KS.OVL+XKSSKD
	JAL	R9,TYP5DD,,		:DISPLAY OVERLOAD COUNT
	JAL	R7,TYP9SP,,		:9 SPACES
	LHL	R3,KS.SAT+XKSSKD
	JAL	R9,TYP5DD,,		:DISPLAY SATURATED COUNT
	JAL	R7,TYP9SP,,
	LHL	R3,KS.BAM+XKSSKD
	JAL	R9,TYP5DD,,		:DISPLAY BACKLOG COUNT
	JAL	R7,TYP9SP,,
	LHL	R3,KS.PKM+XKSSKD
	JAL	R9,TYP5DD,,		:DISPLAY NUMBER OF PACKETS MADE
	JAL	R7,TYP7SP,,
	L	R3,KS.NPM+XKSSKD
	JAL	R9,TYPFWD,,		:DISPLAY IDLE CALLS	

	LA	R2,XKSM17		:GET ADDRESS OF HEADER
	JAL	R7,TYPhdr,,		:AND OUTPUT TO SCREEN

:	KN(R11) HAS THE LINK DESC PTR FOR LINK WE'RE QUERYING
	LIS	R6,0			:STEP THROUGH LINES
XKSRX2	ar	R6,r6
	L	R3,KDLN,R6,R6		:LOOK AT LINE'S LINK DESC
	SRLS	R6,1
	CR	R3,KN			:THIS IS HOW WE TELL COUSINS
	JE	XKSRX4
XKSRX6	AIS	R6,1			:NEXT LINE NUMBER
	CLHI	R6,NLINES
	JN	XKSRX2
	JAL	R7,TYPCRL,,		:FALL THROUGH WHEN ALL LINES CHECKED
	l       r8,xkstmp
	Jr	r8			:REPEAT "KS" FOR REMAINING ARGUMENTS
XKSRX4
	LA	R2,XKSM18		:ADDRESS OF 'LINE' STRING
	JAL	R7,TYPhdr,,		:OUTPUT HEADER STRING
	LR	R3,R6			:GET LINE NUMBER FOR SCREEN
XKSRX7	JAL	R9,TYPHWD,,		:OUTPUT IT TO SCREEN AFTER 'LINE'
	LA	R2,XKSM20		:ADDRESS OF ':'
	JAL	R7,TYPASC,,		:OUTPUT THE STRING
	JAL	R7,TYP4SP,,		:SPACE OUT...

	CLHI	R6,NLINES-SILINS	:CHECK FOR SIO LINE
	JLFS	XKSSYN			:BRANCH IF STILL IN SYNC RANGE
	LA	R2,SINMRK		:PTR TO 'N/A' STRING FOR SIO LINE
	JAL	R7,TYPASC,,		:FILL MARKING FIELD WITH TEXT
	JFS	XKSCNT			:REST OF FIELDS ARE THE SAME
XKSSYN	LHL	R3,KL.LSV,R6,R6		:GET MINUTE'S WORTH OF "MARKING"
	JAL	R9,TYPHWD,,
XKSCNT	JAL	R7,TYP4SP,,		:MOVE OVER ONCE...
	JAL	R7,TYP8SP,,		:MOVE OVER TWICE...
XKSCN1	LHL	R3,KL.TSV,R6,R6		:GET MINUTE'S WORTH OF "RXMT"
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:SPACE OVER
	LHL	R3,KL.RSV,R6,R6		:GET MINUTE'S WORTH OF "XMT"
	JAL	R9,TYP5DD,,     	:sio can do 10000+ packets per min#sdw
	J	XKSRX6			:GO BACK FOR MORE LINES ON THIS LINK

SINMRK	SC	+N/A"20"20"20+		:MARKING FIELD FOR SIO LINE

::*********************************************************************
::
::	SUBROUTINE:	CHNCNT:
::	FUNCTION:	COUNT NUMBER OF ACTIVE CHANNELS ON LINK
::	THIS VALUE IS IDENTICAL TO THE CELL 'ANCHN' FOR T-II LINKS.
::	FOR T-I LINKS, 'ANCHN' IS FREQUENTLY IN ERROR, AND JAL R8,CNTCHN
::	SHOULD BE USED
::	CALLING SEQ:	JAL	R8,CHNCNT
::	INPUT:		XKNSAV, XKDSAV = KN AND KD FOR LINK
::	OUTPUT:		R3 = COUNT
::	DESTROYED:	R0,R1,R2,R4,R9
::
::*********************************************************************

CHNCNT	LHL	R2,XKNSAV,XD		:GET LINK NUMBER
	LHL	R2,LKZFKN,R2,R2 	:GET ABS CHANNEL 0
	SRLS	R2,3			:DIVIDE BY 8
	LA	R4,ACP,R2,		:GET BEGIN OF ACP ARRAY FOR THIS LINK
	L	R2,XKDSAV,XD		:GET LINK DESCRIPTOR
	LHL	R2,NCHN,R2,		:GET NUMBER OF CHANNELS ASSIGNED
	SRLS	R2,4			:DIVIDE BY 16
	JAL	R9,COUNT0		:GET NUMBER OF ACTIVE CHANNELS ON LINK
	JR	R8


	SUBTTL	XRAY (Patch query - PQ)

::*********************************************************************
::
::	COMMAND:	PTCQRY:	PQ
::	FUNCTION:	DISPLAY PATCH HISTORY TABLE	  	###OAS
::
::*********************************************************************

	NOLIST
PCQDS1	SC	/"0D"0APATCH HISTORY TABLE   VERSION - /
PCQDS2	SC	/"0D"0A"0AYEAR  MODY  NMBR  PATCH NAME"0D"0A----  ----  ----  ----------/
	LIST
PTCQRY	LA	R2,PCQDS1
	JAL	R7,TYPhdr,,		:BANNER
	LHI	R3,VERSION		:DISPLAY NODE CODE
	JAL	R9,HEXOCT		:VERSION NUMBER IN OCTAL
	JAL	R9,TYPFW	
	LA	R2,PCQDS2		:TABLE HEADERS
	JAL	R7,TYPhdr,,
	LIS	R14,0			:PATCH HISTORY TABLE INDEX
PTCQR1	JAL	R7,TYPCRL,,		:CR/LF
	CLHI	R14,PHSIZE		:AT END OF TABLE?
	JGE	XPRMPT			:YES, EXIT.
	LB	R0,PATHIS+1,R14,	:CHECK FOR YEAR 1900 (NULL ENTRY)
	JE	XPRMPT			:END, EXIT.

	LHL	R3,PATHIS,R14,		:GET YEAR (19XX)
	JAL	R9,TYPHW
	LHL	R3,PATHIS+2,R14,	:GET DATE (MODY)
	JAL	R9,TYPHW
	LHL	R3,PATHIS+4,R14,	:GET TIME (HHMM)
	JAL	R9,TYPHW
	LA	R2,PATHIS+5,R14,	:POINT TO USERNAME-1
	LIS	R0,0A			:10 CHAR USERNAME
	JAL	R7,TYPAS1,,		:DISPLAY USERNAME

	AHI	R14,10			:POINT TO NEXT PATHIS CELL
	J	PTCQR1			:AND TRY AGAIN

	SUBTTL	XRAY (Interface statistics commands - HS, IS, IR)

::*********************************************************************
::
::	COMMAND:	HSTDS:	HS
::	FUNCTION:	DISPLAY HOST INFORMATION
::	INPUT:	HS - DISPLAY, HS <HOST#1.. HOST#7> H - DISPLAY CERTAIN HOSTS
::		HS <SLOT#1..SLOT#7> S - DISPLAY CERTAIN SLOTS, 
::		HS U - DISPLAY ONLY UP OR SHUT HOSTS
::	###OAS
::
::*********************************************************************

      IF	1-T2GATE	:GATEWAY NO >HS CMD##AL

HSTDS5	SC	/N/		:IIX, ORG/DEST ONLY, PORTS AVAILABLE INDICATORS
	SC	/Y/

HSTDS	LR	R12,R1			:SAVE LAST CHAR ENTERED FOR LATER STUDY
	LR	R14,R2			:GET ARG COUNT
	JnFS	HSTD00			:has args, must close with H or S
	clhi	r1,asccr		:no args must close with CR
	jn	comerr
	jfs	hstdi0
HSTD00	CLHI	R12,ASCH		:DID USER CLOSE WITH AN H(x48)?
	JEFS	HSTDI0			:YES, VALID
	CLHI	R12,ASCS		:DID USER CLOSE WITH AN S(x53)?
	JN	COMERR			:ONLY H OR S ARE VALID WITH ARGS

HSTDI0	LA	R2,HSTDS2,,		:DISPLAY HEADER BANNERS
	JAL	R7,TYPhdr,,
	LA	R2,HSTDS3,,
	JAL	R7,TYPhdr,,

HSTDI1	LIS	R11,0			:INIT HOST INDEX
HSTDI2	LHL	R1,HOSTN,R11,R11	:CHECK HOST ENTRY
	JE	HSTDI6			:NO ENTRY 
	LR	R14,R14			:ANY ARGS
	JE	HSTDI4			:NO ARGS, DON'T CHECK HOST OR SLOT #
	L	R3,VALUE1-4,R14,XD	:GET THIS ARG
	CLHI	R12,ASCH		:USER CLOSE WITH H(x48)?
	JNFS	HSTDI5			:NO, MUST HAVE BEEN AN S
	JAL	R9,DECHEX		:CONVERT ENTERED DECIMAL VALUE
					:J to DHXBAD for RADIX VIOLATION###wjl
	CLH	R3,HOSTN,R11,R11	:DOES ENTRY HOST NUMBER MATCH ?
	JE	HSTDI9			:YES, DISPLAY THIS ENTRY
	JFS	HSTDI7
HSTDI5	SLLS	R3,2			:FORM 4*SLOT NUMBER
	CLB	R3,HSTKEY,R11		:COMPARE SLOT KEY FOR THIS HOST ENTRY
	JE	HSTDI8			:MATCH, DISPLAY THIS ENTRY
HSTDI7	AIS	R11,1			:BUMP HOST INDEX, CHECK FOR MATCH AGAIN
	CLHI	R11,NHOSTS		:ALL ENTRIES CHECKED?
	JL	HSTDI2			:NO, TRY FOR MATCH
	J	HSTDI3			:GIVE UP ON THIS ARG

HSTDI4	CLHI	R12,ASCU		:DID USER CLOSE WITH U(x55)?
	JNFS	HSTDI8			:NO, DISPLAY ALL ENTRIES
	LB	R2,HSTATN,R11		:CHECK STATUS
	NHI	R2,EHDOWN		:CHECK IF BIT 1 OF LO BYTE IS SET
	JN	HSTDI6			:DOWN OR GONE (BIT 1 SET) DON'T DISPLAY
	JFS	HSTDI8

HSTDI9	OI	R14,80000000		:FLAG END PASS (BIT 0 OF R14)

HSTDI8	LHL	R3,HOSTN,R11,R11	:DISPLAY HOST NUMBER
	JAL	R9,TYPFWD
	JAL	R7,TYP1SP,,
					:DISPLAY SLOT NUMBER		###LH
	LB	R3,HSTKEY,R11		:SLOT# * 4 IF NON-MXP.  (00SS)	###LH
					:SLOT#,MACHINE# IF MXP. (00SM)	###LH
	IF      MXPNM 			:IF MXP, CONVERT (00SM) TO (0M0S)##LH
	EXBR    R2,R3     		: R2 = (SM00)			###LH
	NHI     R2,0F00   		: R2 = (0M00)			###LH
	SRHLS   R3,4      		: R3 = (000S)			###LH
	OR      R3,R2     		: R3 = (0M0S)			###LH
	ELSE	:not MXPNM		:IF NON-MXP, COMPUTE SLOT#	###LH
	SRLS	R3,2			:(TRUE SLOT#. NOT SLOT# * 4)	###LH
	EI      :MXPNM
	JAL     R9,TYPHW		:TYPE 4 DIGITS AS (00SS) IF NON-MXP.
	                         		:TYPE 4 DIGITS AS (0M0S) IF MXP.###LH
	LB	R3,HSTYPE,R11,		:DISPLAY PID CODE
	JAL	R9,TYPHW
	SHI	R3,PID.MN		:ensure PID range is OK		###jhl
	JL	HSTD12			:no. Too low
	CLHI	R3,PID.MX-PID.MN
	JG	HSTD12			:no. Too high
	LHL	R2,PIDTBL,R3,R3		:get offset to PID string descriptor
	LI	R2,SEGD,R2		:add in base offset (SEGD)
	LR	R3,R2			:save pointer to string character count
	JAL	R7,TYPASC
	LHI	R0,1A			:COMPUTE 26 - CHARACTERS
	LB	R2,0,R3			:get byte count of PID string	###jhl
	SR	R0,R2			:subtract length from field size $A26
	LA	R2,HSTDS6,,		:26 BLANKS
	JAL	R7,TYPAS1		:BYTE COUNT IN R0
	JFS	HSTD13
HSTD12	LA	R2,HSTDS6,,		:NO KNOWN PID, DISPLAY 26 BLANKS
	JAL	R7,TYPhdc
HSTD13	LB	R1,HSTATN,R11		:GET EXPANDED HOST STATUS
	NHI	R1,00C0			:ISOLATE HOST STATUS (BITS 0,1-LO BYTE)
	SRLS	R1,4			:FORM INDEX (FW)
	LIS	R0,4			:4 CHARACTERS ALWAYS
	LA	R2,HSTDS4-1,R1,,		:DISPLAY HOST STATUS TEXT
	JAL	R7,TYPAS1		:BYTE COUNT IN R0
	JAL	R7,TYP2SP
	SLLS	R11,1			:FORM FULLWORD INDEX
	L	R2,HSTTIM,R11,R11	:INTO HOST STATUS TIME
	ST	R2,GMTNOW		:STORE FOR GMTCNV
	JAL	R9,GMTCNV		:TYPE IT
	JAL	R7,TYP2SP
	SRLS	R11,1			:RESTORE R11
	LB	R3,HSTCST,R11,		:GET HOST COST AND DISPLAY IT
	JAL	R9,TYPBYT,,		:FOLLOWED BY 2 SPACES
	LB	R0,HSTATN,R11		:GET EXPANDED HOST STATUS
	NHI	R0,000C			:ISOLATE ORG/DEST BITS (4,5 OF LO BYTE)
	JE	HSTD20			:BOTH NO
	CLHI	R0,000C			:ARE BOTH BITS SET?
	JE	HSTD20			:YES, BOTH NO
	LIS	R3,2			:ASSUME Y N (DEST ORG ONLY)
	NHI	R0,0008			:WHICH ONE IS SET?
	JEFS	HSTD21			:DESTINATION ONLY HOST
	XHI	R3,2			:MAKE IT N Y (DEST ORG ONLY)
HSTD21	LA	R2,HSTDS5,R3,,		:DISPLAY 'Y' DEST ONLY
	JAL	R7,TYPASC
	XHI	R3,2			:TOGGLE NEXT ONE
	LA	R2,HSTDS5,R3,,
	JAL	R7,TYPASC
	JFS	HSTD22
HSTD20	LA	R2,HSTDS5,,		:N N (DEST ORG ONLY)
	JAL	R7,TYPASC
	LA	R2,HSTDS5,,
	JAL	R7,TYPASC

HSTD22	LIS	R3,0			:INDEX FOR 'N'
	LB	R0,HSTATN,R11		:CHECK IF OUT OF PORTS
	THI	R0,0020			:(BIT 2 OF OF LO BYTE)
	JNFS	HSTD23			:OUT OF PORTS 'N'
	LIS	R3,2			:INDEX FOR 'Y'
HSTD23	LA	R2,HSTDS5,R3,,		:DISPLAY IT
	JAL	R7,TYPASC
	LB	R0,HSTATN,R11		:CHECK IF IIX
	LIS	R3,0			:INDEX FOR 'N'
	THI	R0,0010			:CHECK IF IIX HOST
	JEFS	HSTD24			:NOT IIX
	LIS	R3,2			:INDEX FOR 'Y'
HSTD24	LA	R2,HSTDS5,R3,,		:DISPLAY IT
	JAL	R7,TYPASC

	LIS     R3,0      		:Say if LOG II host (always)
	LB      R0,HSTAT3,R11   	:LOG II capable bit is 40
	THI     R0,40     		:is it log II host?
	JEFS    HSTD30
	LIS     R3,2
HSTD30  LA      R2,HSTDS5,R3,,  	:0 = N  2=Y
	JAL     R7,TYPASC 		:send it

	JAL     R7,TYPCRL 		:done with this line

HSTDI6	LR	R14,R14			:CHECK FOR FORCED END OF PASS
	JGEFS	HSTD25			:DUE TO MATCH FOUND (HO BIT SET)
	NI	R14,7FFFFFFF		:CLEAR HO BIT
	JFS	HSTDI3
HSTD25	AIS	R11,1			:BUMP HOST INDEX
	CLHI	R11,NHOSTS		:ALL ENTRIES DISPLAYED?
	JL	HSTDI2			:NO, TRY SOME MORE
HSTDI3	SIS	R14,4			:DECREMENT ARG COUNT, ANY LEFT?
	JG	HSTDI1			:YES, TRY SOME MORE
	J	XRCRLF			:RETURN TO MAIN LOOP

      EI	:1-T2GATE

::*********************************************************************
::
::	COMMAND:	ISSTAT:	IS
::	FUNCTION:	DISPLAY RELEVANT ISIS/DISPATCHER INTERFACE DATA
::
::*********************************************************************

       if       1-ncslot

ISSTAT	CLHI    R1,ASCZ   		:clear statistics?
	JE      XISS70    		:yes, clear them
	clhi	r1,asccr
	jn	comerr
	LA      R2,XISHD4 		:ring utilization header
	JAL     R7,TYPhdr
	LHL     R14,MTTINT		:interval of statistical collection
	LIS     R6,0      		:0- DORNG stats, 4-DIRNG stats
	LA      R2,XKSM04 		:CPS OUT:
	JAL     R7,TYPhdr
XISS02  L       R2,DISOCM,R6
	DHR     R2,R14    		:make it per second
	JAL     R9,TYPFWD 		:type it in decimal
	LA      R2,XKSM05 		:HWM :
	JAL     R7,TYPhdc
	L       R2,DISOCH,R6    	:high water mark
	DHR     R2,R14
	JAL     R9,TYPFWD 		:type highwater mark
	LA      R2,XISHD3 		:now the time of HWM
	JAL     R7,TYPhdc
	L       R2,DISOCT,R6
	JAL     R9,GMTCNX 		:and type it
	LR      R6,R6
	JNFS    XISS04    		:did it both times
	LA      R2,XKSM03 		:CPS IN
	JAL     R7,TYPhdr
	LIS     R6,4      		:and then do it in other direction
	J       XISS02    		:do DIRING

XISS04  LA      R2,XISHD6 		:TO ISIS  FROM ISIS  PEAK IN :
	JAL     R7,TYPhdr
	LHL     R3,DISICP 		:get value of peak in
	JAL     R9,TYP5DD,, 		:in decimal
	LA      R2,XISHD2 		:'RANGE COUNT COUNT PEAK OUT:'
	JAL     R7,TYPhdr
	LHL     R3,DISOCP 		:get value of peak out
	JAL     R9,TYP5DD,,
:       now the histogram
	LIS     R10,0     		:how far into histogram
	LIS     R11,0     		:index into messages (all 16 byte long)
XISS08  LA      R2,XISHD7,R11
	JAL     R7,TYPhdr 		:type range
	L       R3,DSIHGM,R10   	:get DIRING (to ISIS)value
	JAL     R9,TYPFW
	L       R3,DSOHGM,R10   	:get DORING (from ISIS) value
	JAL     R9,TYPFW
	AHI     R11,10
	AIS     R10,4
	CLHI    R10,4*8   		:8 entries in table
	JL      XISS08

	LA	R2,XISHD1		:EXPLANATORY HEADER
	JAL	R7,TYPhdr
	LHL     R3,DRIF,, 		:fill to ISIS
	JAL     R9,TYPHW
	LHL     R3,DRIE,, 		:empty to ISIS
	JAL     R9,TYPHW
	LHL     R3,DROF,,
	JAL     R9,TYPHW
	LHL     R3,DROE,, 		:from ISIS
	JAL     R9,TYPHW
	LA	R10,DISICP		:8 HALFWORD FIELDS,
	JAL	R8,TYP8HW		: DISPLAYED WITH SPACES TO SEPARATE
	J	XPRMPT			:DONE

XISS70  LIS     R2,0      		:clear statistics
	ST      R2,DISOCM 		:output CPS
	ST      R2,DISICM 		:input CPS
	ST      R2,DISOCH 		:highwater output 
	ST      R2,DISICH 		:highwater input
	ST      R2,DISOCT 		:time of highwater out
	ST      R2,DISICT 		:time of highwater in
	STH     R2,DISICP 		:peak in
	STH     R2,DISOCP 		:peak out
	LHI     R3,4*8-4  		:last entry in histogram
XISS74  ST      R2,DSOHGM,R3    	:clear output histogram
	ST      R2,DSIHGM,R3    	:clear input histogram
	SIS     R3,4
	JGEBS   XISS74
	LIS     R3,2*8-2  		:clear the 8 HW fields
XISS76  STH     R2,DISICP,R3
	SIS     R3,2
	JGEBS   XISS76
	LA      R2,XKSM25,,     	:display statistics cleared
	JAL     R7,TYPASC,,
	J       XPRMPT,,

       ei       :1-ncslot

::************************************************************
::
::      XRCFIG  Prints out flags where are equated to true (>0)
::
::************************************************************

XRCFMS  HS      0
	IF      CFMCNT
QQ      EQ      0         		:count of nonzero enties
Q       EQ      0         		:counter for all potential entries
	RE      CFMCNT
	CFM|Q|
	kill	CFM|Q|
QQ      EQ      QQ+QQQ    		:QQQ is setup by CFM|q|
       IF       QQQ       		:only for new entries
	 IF     (8*QQ)/8-(QQ/8)*8       :multiple of 8? (per line)
	AC      /   /     		:nope, so put in spaces
	 ELSE             		:not a mult of 8
	BC      8D,8A
	 EI               		:mult of 8
       EI  :QQQ
Q       EQ      Q+1
	ER
	ELSE    :CFMCNT         (HANDLE IF ALL FLAGS 0)
	BC      8D,8A
	EI  :CFMCNT

XRCFCT  EQ      .-XRCFMS  		:size of the message

XRCFIG  LHI     R0,XRCFCT
	LA      R2,XRCFMS-1     	:TYPAS1 expects address -1
	JAL     R7,TYPAS1,, 		:this entry has the count in R0
	J       XRCRLF,,


	SUBTTL	XRAY (Node snap - ND)

::*********************************************************************
::
::	COMMAND:	XND:	ND
::	FUNCTION:	FORMAT NODE SNAP FOR DISPLAY
::
::*********************************************************************

XCROPM	SC	/RESTART/
	SC	/STOP   /
	SC	/BOOT   /
	SC	/HALT   /
	SC	/PATCH  /

XND	LA	R2,XNDHD1		:HEADER LINE 1
	JAL	R7,TYPhdr
	LHI	R3,MACHNM
	JAL	R9,TYP5o		:TYPE FIVE DIGIT NODE NUMBER###SHM
	IF	T2GATE			:GATEWAY PUT 2 SIDE HOST NO.##AL
	JAL	R7,TYP2SP		:###cwc
	LHI	R3,HHOST		:FROM TYMFILE, HOME NET HOST NO.
	JAL	R9,TYP5DD,,		:###cwc
	JAL	R7,TYP2SP		:###cwc	
	LHI	R3,IHOST		:ISIS NET HOST NO.
	JAL	R9,TYP5DD,,		:###cwc
	JAL	R7,TYP2SP		:##AL
	ELSE	:NOT T2GATE
	LHI	R3,HST0			:				###wjl
	JAL	R9,TYP5DD,,		:KERNEL HOST IN DECIMAL		###cwc
	EI	:T2GATE
	LHI	R3,VERSION
	JAL	R9,HEXOCT		:CONVERT VERSION TO OCTAL
	JAL	R9,TYPFW
	JAL	R7,TYP2SP
	LB	R2,CRACTN,,
	SLLS	R2,3
	LA	R2,XCROPM,R2		:CRASH OPTION
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LB	R2,CRACTN+1,,
	SLLS	R2,3
	LA	R2,XCROPM,R2		:CRASH OPTION
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LHL	R3,TVRSUP		:SUP NUMBER
	JAL	R9,HEXDEC 		:convert to decimal
	LR      R1,R3     		:do a type byte without any spaces
	SRLS    R1,4
	JAL     R7,TYPHEX
	LR      R1,R3
	JAL     R7,TYPHEX 		:second hex digit
	                  		:if LOG II print 'LG2  ' after sup #
	LB      R0,NEWSUP 		:first byte is 1 if log II supe
	JEFS    XND005
	LA      R2,XNDLG2
	JAL     R7,TYPASC 		:'LG2'
	JFS     XND006
XND005  JAL     R7,TYP5SP 		:else print four spaces
XND006
	IF	T2GATE			:###AL
	LHI	R3,MEMORY		:GATEWAY SLOT SIZE
	ELSE	:NOT T2GATE
	LHI	R3,S0CORE		:IF ISIS, JUST USE S0CORE FROM TYMFILE
	EI	:T2GATE
	JAL	R9,HEXDEC		:GO DECIMAL
	JAL	R9,TYPHNS		:AND DISPLAY
	LA	R2,XNDHD2		:HEADER LINE 2
	JAL	R7,TYPhdr

:	COMPUTE NUMBER OF PORTS FOR KERNEL, DISPI INTERFACES. RUNNING
:	COUNT IS MAINTAINED IN 'HNPORT', BUT MAY NOT BE TOTALLY ACCURATE
:	DUE TO LOGIN RACE CONDITIONS.
	LIS	R0,0			:CUMULATIVE PORT COUNT
	IF	NKU
	LA	R2,KIOTAB,,		:KERNEL PORT PERMUTER TABLE
	LHI	R1,NKU			: AND NUMBER OF KERNEL PORTS
XNDAP1	LHL	R3,0,R2			:GET PERMUTER TABLE ENTRY
	JEFS	XNDAP2			:PORT NOT IN USE
	AIS	R0,1			:INCREMENT ACTIVE PORT COUNT
XNDAP2	AIS	R2,2
	SIS	R1,1			:ANY MORE TO DO?
	JGBS	XNDAP1			:YES - CONTINUE
	EI	:NKU
XNDAP3	HS	0
	IF	NDP
	LA	R2,DIOTAB,,		:DISPI PORT PERMUTER TABLE
	LHI	R1,NDP			: AND NUMBER OF DISPATCHER PORTS
XNDAP4	LHL	R3,0,R2			:GET PERMUTER TABLE ENTRY
	JEFS	XNDAP5			:PORT NOT IN USE
	AIS	R0,1			:INCREMENT ACTIVE PORT COUNT
XNDAP5	AIS	R2,2
	SIS	R1,1			:ANY MORE TO DO?
	JGBS	XNDAP4			:YES - CONTINUE
	EI	:NDP
	STH	R0,HNPORT		:UPDATE WITH MOST ACCURATE COUNT

	LHL	R3,HNPORT		:NUMBER OF PORTS IN USE
XNDTY1	JAL	R9,TYPHWD
	JAL	R7,TYP2SP		:COUPLE SPACES
	LHL	R3,PASTHR		:NUMBER OF PASSTHROUGHS IN USE
	JAL	R9,TYPHWD
	jal     r7,typ5sp
	lhl     r3,nbrcmd 		:number of passthru cmd cts
	lh      r0,tvrbuf
	jefs    xnd14
	ais     r3,1      		:+1 for our cmd cir
xnd14   jal     r9,typhwd
	JAL	R7,TYP2SP
	LHL	R3,NALINK		:NUMBER OF ACTIVE LINKS
	JAL	R9,TYPHWD
	LHI	R3,NLINKS		:TOTAL NUMBER OF LINKS DEFINED
	JAL	R9,TYPHWD
	LHI	R3,XLINKS		:NUMBER OF XLINKS DEFINED
	JAL	R9,TYPHWD
	JAL	R7,TYP2SP		:MORE SPACES
	LHI	R3,NLINES		:NUMBER OF LINES (SYNC+SIO) DEFINED
	JAL	R9,TYPHWD
	LHI	R3,NLINES-SILINS	:NUMBER OF SYNC LINES DEFINED
	JAL	R9,TYPHWD
	LHI	R3,SILINS		:NUMBER OF SIO LINES DEFINED
	JAL	R9,TYPHWD

	LA	R2,XNDHD5		:TELL WHEN WE FIRST CAME UP
	JAL	R7,TYPhdr
	L	R2,XFIRST		:GET TIME OF FIRST TIME UP
	ST	R2,GMTNOW		:SAVE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE

	LA	R2,XNDHD3		:TELL HOW LONG WE'VE BEEN UP
	JAL	R7,TYPhdc
	L	R2,XLCRSH		:GET TIME OF LAST CRASH
	ST	R2,GMTNOW		:SAVE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE

	LA	R2,XNDHD6
	JAL	R7,TYPhdr
	L	R2,CS.TIM+CSMTBL	:GET CRASH TIME
	JAL	R9,GMTCNX,,		:DISPLAY IT
	JAL	R7,TYP2SP
	LHL	R3,CS.CNT+CSMTBL	:CRASH COUNT
	JAL	R9,TYPHWD
	LHL	R3,CS.CID+CSMTBL	:CRASH ID
	JAL	R9,TYPHW
	LHL	R3,CS.PSD+2+CSMTBL	:CRASH PSW
	JAL	R9,TYPHW
	L	R3,CS.PSD+4+CSMTBL	:CRASH PC
	JAL	R9,TYPFW

	LA	R2,XNDHD4		:HEADER TO DISPLAY LINK/LINE STATUS
	JAL	R7,TYPhdr

	LIS	LN,0			:DO FOR ALL LINES, STARTING WITH 0
XND20	LR	R3,LN			:GET LINE NO.
	JAL	R9,TYPBYD		:TYPE IT
	IF	SILINS			:TEST FOR SYNC OR SIO LINE
	CLHI	LN,NLINES-SILINS	:SYNC LINE?
	JLFS	XND22			:YES
	LA	R2,XNDHSI		:NO - DISPLAY 'SIO LINE'
	JFS	XND24
	EI	:SILINS
XND22	LA	R2,XNDHSY		:DISPLAY 'SYNC LINE'
XND24	JAL	R7,TYPASC
	LHL	R3,NGSVLN,LN,LN 	:NEIGHBOR NUMBER - 
	JN	XND25			:NEIGHBOR HAS BEEN THERE, GO FIGURE.
	LA	R2,NONEIG		:CANNED DISPLAY FOR UNUSED LINE
	LR	R0,LN			:line no.
	AR	R0,R0			:times 2
	TBT	R0,DWLDSP		:check for DWL in progress
	JEFS	XND23			:no
	LA	R2,XDWLDS		:yes, say it
	JFS	XND21
XND23	tbt	ln,xltact		:check for line test in progress
	jefs	xnd235
	la	r2,xltndd
	jfs	xnd21
xnd235
	if	chboot
	tbt	ln,cnbtya		:in boot?
	jefs	xnd21
	la	r2,xcnbtd
	ei	:chboot
XND21	JAL	R7,TYPASC		:TYPE IT
	J	XND40			:NEXT LINE
XND25	NHI	R3,7FFF			:STRIP HO UP/DOWN INDICATOR BIT
	STH	R3,XNDSAV,XD		:SAVE NODE NUMBER(IN HEX) into XD 9/1/93
	JAL	R9,TYP5o		:TYPE FIVE DIGITS OF NODE #
	LHL	R1,XNDSAV,XD		:LOAD HEX NODE # FOR XFNDLK from XD
	JAL	R9,XFNDLK		:RETURNS KN AND KX (-1 IF NOT FOUND)
	SKIPAD(XND28)			:immediate return, NOP		###wjl
XND28	LHL	R3,XKNSAV,XD		:+4 return, LINK# FOR TYPBYT
	JAL	R9,TYPBYT,,		:TYPE LINK NO.

::	SEE IF NEIGHBOR IS TIILNK OR XLINK. 
::
	L	KX,XKDSAV,XD		:LINK DESC.
	JL	XND30			:IF <0 XLINK DOWN
	LH	R3,ONDID,KX		:XLINK?
	JEFS	XND30			:YES
	LA	R2,XNDTKD		:TII NEIGHBOR
	JFS	XND32
XND30	LA	R2,XNDXKD		:XLINK
XND32	JAL	R7,TYPASC		:DISPLAY TII OR XLNK
	LR	KX,KX			:CHECK FOR -1
	JLFS	XND31
	LB	R3,NLAT,KX		:NUMBER OF LINES ON LINK
	SIS	R3,1			:MORE THAN ONE LINE?
	JLEFS	XND31			:NO
	LA	R2,XNDMLL		:YES - DISPLAY 'MULTI-LINE LINK'
	JAL	R7,TYPASC
	JFS	XND33
XND31	JAL	R7,TYP3SP

:	LINE IS ACTIVE. DISPLAY 'UP', WINDOW SIZE, SPEED, AND NUMBER
:	OF ACTIVE CHANNELS ON LINK.
XND33
	LH	R3,NGSVLN,LN,LN		:LINE ATTACHED TO UP LINK IF HO BIT SET
	JGEFS	XND50			:NOT SET
	LA	R2,XNDLUP		:'UP'
	J	XND26			:GO TYPE IT
XND50	SLLs	LN,1
	L	R3,KDLN,LN,LN		:GET LINK DESC ADDRESS
	SRLs	LN,1
	LA	R2,XNDSUS		:'*SUSP*'
	AIS	R3,1			:IF 'FFFF' LINE IS SUSPENDED, ELSE DOWN
	JE	XND26			:LINE IS SUSPENDED
	LR	R2,LN			:line number...
	AR	R2,R2			:...times 2
	TBT	R2,DWLDSP		:see if DWL in progress
	JEFS	XND52			:no
	LA	R2,XDWLBR		:yes, say it
	J	XND26
XND52	tbt	ln,xltact		:check for line test in progress
	jefs	xnd525
	la	r2,xltnds
	jfs	xnd26
xnd525
	if	chboot
	tbt	ln,cnbtya		:in boot?
	jefs	xnd526
	la	r2,xcnbts
	jfs	xnd26
	ei	:chboot
xnd526	LA	R2,XNDLOT		:'*DOWN*'
XND26	JAL	R7,TYPASC
	L	KX,XKDSAV,XD		:LINK DESC.
	JL	XND35
	LB	R3,WSIZ,KX		:PICKUP LINK WINDOWSIZE		###OAS
	JAL	R9,HEXDEC		:CONVERT TO DECIMAL		###OAS
	JAL	R9,TYPHNS		:TYPE FOUR DIGITS(NO SPACES)	###OAS
	JAL	R7,TYP1SP		:				###OAS
	LA	R2,ASC2SP		:ASSUME TERRESTIAL LINE		###OAS
	LB	R4,KSPD,KX		:PICKUP LINK SPEED FOR SAT BIT	###OAS
	THI	R4,20			:CHECK FOR SAT BIT SET		###OAS
	JEFS	XND27			:NO, LEAVE BLANK		###OAS
	LA	R2,ASCSAT		:YES, PUT @ BEFORE SPEED	###OAS
XND27	JAL	R7,TYPASC		:TYPE IT			###OAS
	LHL	R3,BAUDRR,LN,LN		:PICKUP 'real' LINE SPEED
	LHL	R4,XKNSAV,XD		:GET LINK NUMBER
	TBT	R4,KNCNSP,,		:IS SPEED SPEC IN TYMFILE?
	JEFS	XND29			:NO, DISPLAY CALCULATED SPEED
	LB	R3,KSPDRR,KX		:pick up real link speed
XND29	jal	r7,prtspd		:and print it
	JAL	R8,CHNCNT
	JAL	R9,TYPHWD		:DISPLAY NUMBER OF ACTIVE CHNS FOR LINK
	JFS	XND34

XND35	JAL	R7,TYPASP		:PAD IN 20 SPACES
	JAL	R7,TYPASP		:10+10 spaces
XND34	LR	R1,LN			:LINE NO.
	SLLS	R1,2			:TIMES 4
	L	R2,LINTIM,R1		:TIME OF LAST ATT/DET
	JE	XND40			:IGNORE IF 0
	ST	R2,GMTNOW		:STORE FOR GMTCNV
	JAL	R9,GMTCNV		:TYPE IT

	LIS	R2,1			:*FOR COUNT1 - NO. HW'S TO SCAN
	LA	R4,LDARLN,LN,LN		:*LD ARRAY FOR LINE -
	JAL	R9,COUNT1		:*HOW MANY 1'S - ANSWER IN R3
	LR	R3,R3			:*NO 1'S?
	JEFS	XND40			:*RIGHT, SO SKIP
	SRLS	R3,2			:*DIVIDE BY 4
	SLLS	R3,3			:*DW INDEX
	LA	R2,ASTER1,R3		:*GET APPROPRIATE NO. OF ASTERISKS
	JAL	R7,TYPASC		:*AND DISPLAY
	
XND40	JAL	R7,TYPCRL
	AIS	LN,1			:ADVANCE TO NEXT LINE NUMBER
	CLHI	LN,NLINES		:MORE TO DO?
	JL	XND20			:YES - CONTINUE
					:no 

:	FIND ALL TIILNK LINKS AND DISPLAY THOSE NOT UP...
XND70	LA	R2,XNDWDN		:DISPLAY 'TIILNK NEIGHBORS DOWN - '
	JAL	R7,TYPhdr
	LHI	KN,(NLINKS-1)*2
	LIS	R5,0			:CUMULATIVE COUNT OF DOWN LINKS
XND72	STH	KN,XKNSAV,XD		:SAVE LINK#
	L	KX,KDKN,KN,KN		:GET LINK DESCRIPTOR INDEX
	LH	R3,ONDID,KX		:IS THIS AN XLINK?
	JE	XND80			:YES - BYPASS
	LB	R1,NLAT,KX		:ARE ANY LINES ATTACHED TO LINK?
	JN	XND80			:YES - LINK UP
	AIS	R5,1			:LINK DOWN - COUNT IT,
	JAL	R9,TYP5o		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	CHI	R5,8			:8 NBRS DISPLAYED 1ST LINE ##AL
	JEFS	XND80
:	JAL	R7,TYPCRL		:##AL
:	JFS	XND80
XND73	CHI	R5,8+0B			:11 NBRS DISPLAYED 2ND LINE ##AL
	JNFS	XND80			:GOOD ENOUGH FOR 32 NBRS
	JAL	R7,TYPCRL
XND80	LHL	KN,XKNSAV,XD		:RECOVER LINK#
	SIS	KN,2			:CHECK NEXT LINK
	JGE	XND72
:	DONE WITH ALL LINKS - WERE ANY DOWN?
	LR	R5,R5
	JN	XRCRLF			:YES, DONE WITH DISPLAY
	LA	R2,ASCZIP,,		:NO, ALL TIILNK LINKS UP. DISPLAY 'ZIP'
	JAL	R7,TYPASC
	J	XRCRLF			:DONE WITH ND DISPLAY


	SUBTTL	XRAY (Link descriptor - KD)


::*********************************************************************
::
::	COMMAND:	XNEIGB:	KD
::	FUNCTION:	DISPLAY LINK DESCRIPTOR TO GIVEN NEIGHBOR
::
::*********************************************************************

XNEIGB	clhi	r1,53			:an 'S'?
	jn	xnei04
	lr	r2,r2			:must be KS S if doing all links
	jn	comerr
        lhi     r1,(nlinks-1)*2         :do all links
        sth     r1,argct,xd             :remember how many to do
xnei00  lh      r11,argct,xd
        jl      xprmpt                  :did all so done
        lr      r1,r11
        sis     r1,2
        sth     r1,argct,xd             :and remember we did link
        srls    r11,1
        sth     r11,xknsav,xd
        ar      r11,r11                 :restore to kn*2
        l       r9,kdkn,r11,r11         :set up like xfndlk
        st      r9,xkdsav,xd
        j       xnei06                  :and do output
xnei04	SIS	2,4			:MUST HAVE SINGLE ARG
	jn	comerr
	JAL	R9,OCTHXR		:CONVERT ARGUMENT IN R3 TO HEX
        ts      argct,xd                :mark that only doing 1 link
	LR	R1,R3
	JE	COMERR			:FNDLNK WILL ACCEPT NEIGHBOR # OF 0
	JAL	R9,XFNDLK
	SKIPAD(COMERR)			:immediate return, NOT FOUND	###wjl
xnei06	JAL	R7,TYPCRL		:+4 return, TYP CR-LF
	L	KX,XKDSAV,XD		:LINK DESC.
	LA	R2,NEIMS1
	JAL	R7,TYPhdr
	lhl	r3,ndid,kx
	jal	r9,typ5o
	LHL	R3,SIOROR,kx		:line rotation and BORI
	JAL	R9,TYPHW
	lhl	r3,nlat,kx		:attached lines and wsiz
	JAL	R9,TYPHW
	lhl	r3,KSPD,kx		:speed and link num
	LHL	r0,XKNSAV,XD		:if any lines attached
	TBT	r0,KNCNSP,,
	JNFS	XNEIG1
	NHI	R3,7FFF
XNEIG1	JAL	R9,TYPHW
	LIS	R5,4
	la	r10,nchn,kx		:print rest of first line
	JAL	R8,TYPNHW

	LA	R2,NEIMS2
	JAL	R7,TYPhdr
	LR	R8,XD			:SAVE USER BLOCK POINTER
	LR	r10,kx
	LM	R12,OSEC,R10		:COPY DYNAMIC DATA
	STM	R12,XRSAVE+8,R8		:TO STATIC AREA FOR ACCURATE READING
	LR	XD,R8			:RESTORE XD
	lr	kx,r10
	LA	R10,XRSAVE+08,xd
	JAL	R8,TYP8HW
	LA	R2,NEIMS3
	JAL	R7,TYPhdr
	LHL	R3,ONDID,kx
	JAL	R9,TYP5o
	LHL	KN,XKNSAV,XD		:RECOVER LINK#
	LHL	R3,LKZFKN,KN,KN		:DISPLAY ABSOLUTE CHN FOR CHANNEL 0
	JAL	R9,TYPHW
	LHL	R3,TBDPKN,KN,KN		:DISPLAY BEGINNING OF PERMUTER TABLE
	JAL	R9,TYPHW
	LHL	R3,EBDPKN,KN,KN		:DISPLAY END OF PERMUTER TABLE
	JAL	R9,TYPHW
	L	KX,XKDSAV,XD		:RECOVER LINK DESC.
	LHL	R3,ANCHN,KX		:NO. OF ACTIVE CHANNELS
	JAL	R9,TYPHWD
	LHL	R3,KVERNO,KX		:NEIGHBOR VERSION NUMBER
	JAL	R9,TYP5o

:	DISPLAY ALL LINES ATTACHED TO LINK

	lcs     r8,1      		:in case line drops, don't crash
	LB	R0,NLAT,KX
	JNFS	XNEIG2			:GOT SOME
TXNEI2	LA	R2,ASCZIP,,
	JAL	R7,TYPASC		:NO LINES ATTACHED - SAY 'ZIP'
	LCS	R8,1			:don't display NETID, HOST0, LINE###wjl
	J	XNEIG7
XNEIG2	LHI	LN,(NLINES-1)*2
XNEIG3	LH	R1,NGSVLN,LN		:SEE IF THIS LINE ATTACHED TO LINK
	JGEFS	XNEIG4			:8000 BIT SET IF LINE ATTACHED
	NHI	R1,7FFF
	CLH	R1,NDID,KX		:IS LINE ATTACHED TO THIS LINK?
	JEFS	XNEIG6			:YES - DISPLAY IT
XNEIG4	SIS	LN,2
	JGE	XNEIG3			:CHECK ALL LINES
	JAL	R7,TYPCRL
	JFS	XNEIG7
XNEIG6	LR	R8,LN			:save LN for later		###wjl
	LR	R3,LN
	SRLS	R3,1
	JAL	R9,TYPBYD		:DISPLAY LINE NUMBER
	JBS	XNEIG4

:	See how many of the active circuits are command circuits and display.
XNEIG7	JAL	R7,TYPASI		:Type following string
	SC	/"0D"0ACMD CKTS = /
	LIS	R3,0			:Init count
	LHL	R4,NCHN,KX,		:# channels allocated to this link
	JE	XNEIG8			:none
	SRLS	R4,3			:number of bytes of bits to check
	LHL	KN,XKNSAV,XD,		:recover link number		###wjl
	LHL	R7,FLDPKN,KN,KN		:beginning of link's bit arrays	###wjl
XNEI7A	LH      R0,LNKACP,R7,   	:only test active circuits      ###sdw
	XHI     R0,-1     		:bits now 1 if active           ##sdw
	NH      R0,CMDCTS,R7,   	:active command circuits        ##sdw
XNEI7B  JFFOH   R0,XNEI7C
	AIS     R7,2      		:next HW
	SIS     R4,2      		:reach end yet?
	JGEBS   XNEI7A    		:do another pair of bytes       ###sdw
	JFS     XNEIG8    		:counted them all
XNEI7C  AIS     R3,1      		:found a set bit
:       R1 now has bit # of set bit (0-F), shift this bit off our hw    ###sdw
	SLL     R0,1,R1   		:R1 is one less than needed     ###sdw
	JBS     XNEI7B

XNEIG8	JAL	R9,TYPHWD		:type out count in hex		###wjl
	JAL	R7,TYPCRL

	L	KX,XKDSAV,XD,		:recover link descriptor	###wjl
:	DISPLAY NEIGHBOR'S NETID, HOST0, AND FIRST LINE ATTACHED	###wjl
        lhl     r0,kverno,kx         :when it was up, was it on expanded reset
        clhi    r0,$8 520               :if after 5.20 then yes
	Jl	XNEIG9			:no, done...		###wjl/cwc
	JAL	R7,TYPCRL		:				###wjl
	LA	R2,NEIMS4		:heading for netid, host#, 1st-up line#
	JAL	R7,TYPhdr	:			###wjl/cwc
	LHL	R3,KNETID,KX,		:				###wjl
	JAL	R9,TYPHWD		:type neighbor's NETID		###wjl
	JAL	R7,TYP1SP
	L	R3,KHOST0,KX,		:			###wjl/cwc
	JAL	R9,TYP5DD		:type neighbor's HOST0	###wjl/cwc
	LB	R3,KLINE,KX,		:				###wjl
	JAL	R9,TYPBYD		:type neighbor's 1st ln attached###wjl
	JAL	R7,TYPCRL		:				###wjl
XNEIG9
	J	xnei00			:All done.


	SUBTTL	XRAY (Scan memory for halfword match - MA)

::*********************************************************************
::
::	COMMAND:	XRMTCH:	MA
::	FUNCTION:	ENABLES THE USER TO FIND THE ADDRESSES OF ALL
::	OCCURENCES OF A SPECIFIED HALFWORD STRING IN A SPECIFIED
::	MEMORY RANGE.
::	INPUT:		MA <hex string> <start address> <end address>
::	IF THE COMMAND IS TERMINATED BY THE LETTER "N" THE ROUTINE
::	WILL SEARCH FOR ALL OCCURRENCES OF THE SECOND BYTE OF THE
::	STRING WHICH ARE NOT PRECEDED WITH THE FIRST BYTE OF THE
::	STRING.  FOR EXAMPLE,  
::		MA 0322 10000 1FFFFN
::	WILL FIND ALL OCCURRENCES OF 22 NOT PRECEDED WITH 03 IN
::	SEGMENT 1. 	###JHL
::
::*********************************************************************

TIMDSM	EQ	50			:NUMBER OF LOOPS AT ONE SHOT

XRMTCH	ST	R1,XRSAVE,XD		:SAVE LAST CHARACTER ENTERED FOR LATER
	lhl	r0,value1,xd		:if matching HW then must only be a HW
	jn	comerr			:bigger than a hw
	L	R1,VALUE1+4,XD		:LIFT SEG # FROM START ADDRESS
	L	R2,VALUE1+8,XD		:LIFT SEG # FROM END ADDRESS
	cr	r2,r1			:make sure end is after start
	jle	xrmer2			:range not acceptable
	ni	r1,@(segsiz-1)		:leave only seg number
	ni	r2,@(segsiz-1)		:leave only seg number
	CR	R1,R2			:DON'T READ ACROSS SEG BNDRY
	JN	XRMER1			:TELL USER TO STAY IN ONE SEGMENT
:	FALL THROUGH IF SAME SEG #'S.  NEXT CHECK WE DON'T GO 
:	BEYOND SEGMENT END.  Set end to end of segment if value is after
:	actual segment end.
	L	R10,VALUE1+4,XD		:READ START ADDRESS
	lr	r3,r10
	jal	r9,chkmac		:see if readable
	j	xrmer1			:out of segment
	L	R11,VALUE1+8,XD		:READ END ADDRESS
	lr	r3,r11
:	this  is a skip+4 routine with error recovered in the 4 bytes
	jal	r9,chkmac		:see if readable
	lr	r11,r4			:get add of end of segment if not readable
	sis	r11,1			:last checked is one before that

:	SET UP FOR PROCESSING.  R11 = END, R12 = DISMISS TIME COUNTER,
:	R2 = R3 = SCRATCH, R5 = MATCH STRING,
:	R10 current address.
:	R7 USED TO LINK TO SUBROUTINES.

	LHI	R12,TIMDSM		:COUNTER FOR DISMISS
	NI	R10,0FFFFFFFE		:MAKE SURE THIS IS AN EVEN ADDRESS
	L	R5,VALUE1,XD		:FIRST ARG IS MATCH-STRING
	LHL	R6,XRSAVE+2,XD		:DID USER END WITH AN "N"?
	CLHI	R6,ASCN			:IF HE DID IT'S NON-MATCH ON 1ST BYTE
	JE	XRMT25			:GO TO NON-MATCH FIRST BYTE ROUTINE
	clhi	r6,asccr		:anything else is syntax error
	jn	comerr

:	WE'RE SET UP NOW FOR HW MATCH.  HERE IS THE MAIN MATCHING LOOP.
	LH	R6,0,R10		:READ FIRST (COUNTER = EVEN) HW
XRMT10	CLR	R6,R5			:SAME AS OUR STRING?
	JNFS	XRMT20			:SKIP NEXT IF NO MATCH
	sis	r10,1			:address is of first byte
	JAL	R7,FNDEVN		:FOUND A MATCH AT EVEN BOUNDARY
	ais	r10,1			:restore address
XRMT20	AIS	R10,1			:BUMP OFFSET PTR TO NEXT byte
	CR	R10,R11			:HAS OFFSET REACHED END OF RANGE?
	JGE	XPRMPT			:IF SO, WE'RE FINALLY DONE CHECKING
	nhi	r6,0ff			:remove high byte
	exbr	r6,r6			:move into high byte
	Lb	R3,0,r10		:READ NEXT byte
	or	r6,r3			:make into our HW
	SIS	R12,1			:COUNT DOWN OUR DISMISS TIME
	JG	XRMT10			:NOT TIME TO YIELD YET--CONTINUE
	JAL	R7,TIMOUT		:TIME TO GIVE NODE CODE SOME CPU
	LHI	R12,TIMDSM		:RESET COUNTDOWN TICKER	
	J	XRMT10			:CONTINUE MATCH/SHIFT/MATCH

:	SEARCH FOR A BYTE PRECEDED BY ANYTHING BUT A GIVEN BYTE.
XRMT25	LB	R6,VALUE1+3,XD		:PUT MATCH BYTE (SECOND ONE) IN R6
	LB	R5,VALUE1+2,XD		:PUT NONMATCH BYTE (First ONE) IN R5
XRMT27	AIS	R10,1			:INC THE OFFSET PTR
	CR	R10,R11			:REACHED END OF READ RANGE?
	JGE	XPRMPT			:IF WE HAVE, THEN EXIT
	SIS	R12,1			:DEC THE TIMEOUT COUNTER
	JGfs	XRMT30			:CONTINUE IF NOT DOWN TO ZERO
	JAL	R7,TIMOUT		:ELSE TIME TO YIELD TO NODE CODE
XRMT30	LB	R3,0,r10		:READ BYTE LOOKING FOR MATCH 
	CLR	R3,R6			:DOES IT MATCH OUR SECOND BYTE?
	JNbs	XRMT27			:IF NOT, MOVE TO NEXT PAIR
	SIS	R10,1			:IT DOES--CHECK PREV BYTE FOR NON-MATCH
	LB	R2,0,R10		:READ THAT PREV BYTE, SAVE R3 FOR LATER
	CLR	R2,R5			:CHECK FOR NON-MATCH
	JEfs	XRMT35			:BUMP OFSET SO WE DON'T LOOP FOREVER
:	WE FOUND AN APPROPRIATE HW STRING--NOTIFY THE USER
	EXBR	R2,R2
	NHI	R2,0FF00
	OR	R6,R2			:NOW R3 HAS THE STRING
	JAL	R7,FNDEVN		:OUTPUT THE INFORMATION
	nhi	r6,0ff			:restore match byte
XRMT35	AIS	R10,1			:RESTORE BYTE OFFSET FOR MORE CHECKS
	J	XRMT27			:AND LOOP AGAIN

:	**UTILITY ROUTINES FOR MATCH COMMAND**

::*********************************************************************
::
::	SUBROUTINE:	TIMOUT:
::	FUNCTION:	TIME OUT
::	CALLING SEQ:	JAL	R7,TIMOUT
::	CALLS:		JAL	R0,XRYYLD
::
::*********************************************************************

TIMOUT	CI	XD,TTYXD		:IS THIS A TTY USER?
	JER	R7			:FOR LOCAL USER, LET IT EAT TIME SLICE
	STM	r0,xregsv,xd		:save registers
	JAL	R0,XRYYLD		:LET THE NODE CODE RUN
MTCRES	L	R0,XRSAVE,XD		:RESTORE RANGE OF OUR REGION TO CHECK
	LM	r0,xregsv,xd		:restore registers
	JR	R7			:AND TAKE UP WHERE WE LEFT OFF

::*********************************************************************
::
::	SUBROUTINES:	FNDODD:/FNDEVN:
::	FUNCTION:	FOUND A MATCH.  OUTPUT THE ADDRESS AND STRING
::	TO THE USER, AND RESUME MATCH/SHIFT/MATCH.
::
::*********************************************************************

FNDEVN	lr	r3,r10			:our address
	st	r7,xrsave,xd
	JAL	R9,TYPADD		:OUTPUT THE FULL WORD ADDRESS
	lr	r3,r6			:our read in hw
	JAL	R9,TYPHW		:AND OUTPUT TO THE USER
	JAL	R7,TYPCRL		:GIVE USER A NICE LINE TERMINATOR
	l	r7,xrsave,xd
	JR	R7

:	**ERROR MESSAGES**
XRMER1	LA	R2,XRMES1		:LOAD ADDRESS OF ERROR STRING
	JAL	R7,TYPASC		:TELL THE USER HOW HE ERRED.
	J	XRCRLF			:THEN WAIT FOR FURTHER INSTRUCTIONS

XRMER2	LA	R2,XRMES2		:LOAD ADDRESS OF ERROR STRING
	JAL	R7,TYPASC		:TELL THE USER HOW HE ERRED.
	J	XRCRLF			:THEN WAIT FOR FURTHER INSTRUCTIONS

	NOLIST
XRMES1	SC	/"0AYOU CAN'T READ ACROSS SEGMENT BOUNDARIES./
XRMES2	SC	/"0ASPECIFIED RANGE IS UNACCEPTABLE./
	LIST


::*********************************************************************
::
::	SUBROUTINE:	TYPNFW:
::	FUNCTION:	TYPE N FULLWORDS
::	CALLING SEQ:	JAL	R8,TYPNFW
::	INPUT:		R5 = NUMBER OF FULLWORDS
::			R6 = STARTING ADDRESS
::
::*********************************************************************

TYPNFW	HS	0 
REGS1	THI	R5,7
	JNFS	REGS3
	JAL	R7,TYPCRL
REGS3	L	R3,0,R6
	JAL	R9,TYPFW
	AIS	R6,4
	SIS	R5,1
	JGBS	REGS1
	JAL	R7,TYPCRL
	JR	R8

	SUBTTL	XRAY (CRYPTO message commands - CL, CP, CM, AP, SM)


::*********************************************************************
::
::	COMMAND:	CRYLST:	CL
::	FUNCTION:	TYPE LAST N CRYPTO MESSAGES
::
::*********************************************************************

CRYLST	LR	R2,R2			:check for no arguments		###wjl
	JE	CRYLS6			:no arguments			###wjl
	L	R3,VALUE1,XD		:ARGUMENT
	CLHI	R1,ASCH			:Ended with 'H' (x48)?
	JNFS	CRYLS0			:No

	LHI	R6,$A3600		:User wants last N hours worth
	JFS	CRYLS4

CRYLS0	CLHI	R1,ASCM			:Ended with 'M'?
	JNfs	CRYLS2			:No

	LHI	R6,$A60			:User wants last N minutes worth
CRYLS4	JAL	R7,CRYPTR		:Go compute out pointer
	J	CRYLS1			:Found beginning of time frame

CRYLS6	LHI	R3,10			:default number of args is 16	###wjl
CRYLS2	clhi	r1,asccr		:legal ending of cmd?
	jn	comerr
	LHL	R2,CRYPRI
	SLLS	R3,4			:User wants last N messages
	ci	r3,cryprs		:want more than is in log?
	jlfs    cryls5			:nope
	li	r3,cryprs-10		:yes, give them the whole ring
cryls5	SR	R2,R3			:so where is this in the log
	JGEFS	CRYLS1
	AI	R2,CRYPRS		:wrapped
CRYLS1	nhi	r2,-10
	STH	R2,CRYPTU,XD
	LIS	R14,0			:OUTPUT ALL MESSAGES
	LCS	R12,1			:ENABLE ALL MESSAGES
CRYLS3	JAL	R7,TYPCRL
	JAL	R8,XCRYPT
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	CRYLTP:	CP
::	FUNCTION:	TYPE LAST N CRYPTO priority MESSAGES ###AL1/4/85
::
::*********************************************************************

	IF 	PRIMSG

CRYLTP	lr      r2,r2     		:any args?
	jnfs    CRYLP7
	lhi     r3,10     		:if none then 16d messages
	j       crylp2
CRYLP7	L	R3,VALUE1,XD		:ARGUMENT
	CLHI	R1,ASCH			:Ended with 'H' (x48)?
	JNFS	CRYLP0			:No

	LHI	R6,$A3600		:User wants last N hours worth
	JFS	CRYLP4

CRYLP0	CLHI	R1,ASCM			:Ended with 'M'?
	JN	CRYLP2			:No

	LHI	R6,$A60			:User wants last N minutes worth
CRYLP4	JAL	R7,CRPPTR		:Go compute out pointer		###AL
	J	CRYLP1			:Found beginning of time frame

CRYLP2	clhi	r1,asccr
	jn	comerr
	LHL	R2,CRYPPI
	SLLS	R3,4			:User wants last N messages
	clhi    r3,crypps
	jlfs    crylp5
	lhi     r3,crypps-10
crylp5	NHI	R3,CRYPPS-10
	SR	R2,R3
	JGEFS	CRYLP1
	AHI	R2,CRYPPS
CRYLP1	STH	R2,CRYPPU,XD
	LIS	R14,0			:OUTPUT ALL MESSAGES
	LCS	R12,1			:ENABLE ALL MESSAGES
CRYLP3	JAL	R7,TYPCRL
	JAL	R8,XCRPPT		:###AL
	J	XPRMPT

::*********************************************************************
::
::	SUBROUTINE:	CRPPTR:
::	FUNCTION:	Computes CRYPPU for CRYLTP and CRYMSG.###AL1/4/85
::	CALLING SEQ:	JAL	R7,CRPPTR
::	INPUT:		R3 = argument in minutes or hours, decimal
::			R6 = $A60, if minutes - $A3600 if hours
::	OUTPUT:		R2 = CRYPPU
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R9
::	CALLS:		JAL	R9,DECHEX
::
::*********************************************************************

CRPPTR	JAL	R9,DECHEX		:Argument is decimal, convert to hex
					:J to DHXBAD for Radix error	###wjl
	LHL	R2,CRYPPI		:Get crypto pointer
	MHR	R6,R3			:Convert to seconds
	JAL	R9,GMTCAL,,		:Get current time to GMTNOW
	L	R3,GMTNOW		:Current time + 7 bits of FASTC
	SRLS	R3,7			:Get rid of FASTC
	SR	R3,R6			:We want to go back to this time
	JGE	CPPTR0			:OK

	JAL	R7,TYPASI
	SC	/REQUESTED TIME OUT OF RANGE/
	J	COMER3

CPPTR0	SHI	R2,10			:Look at next oldest message
	JGEFS	CPPTR1

	AHI	R2,CRYPPS		:Wrapped

CPPTR1	CLH	R2,CRYPPI		:Back to where we started?
	JE	XPRMPT			:Yes, no message in time frame

	L	R5,CRYPPB+CRYGMT,R2,	:Get message timestamp
	AIS	R5,1			:Make sure it's not -1
	JEFS	CPPTR2			:It is, done
	SIS	R5,1			:Restore timestamp
	SRLS	R5,7			:Dump FASTC
	CLHI	R5,$A1440		:At least a day's worth
	JL	CPPTR0			:No, keep trying
	CR	R3,R5			:Are we in our time frame?
	JL	CPPTR0			:No, keep trying

CPPTR2	AHI	R2,10			:Move forward one
	NHI	R2,CRYPPS-1		:Correct for wrap
	JR	R7			:RET

	EI	:PRIMSG

::*********************************************************************
::
::	SUBROUTINE:	CRYPTR:
::	FUNCTION:	Computes CRYPTU for CRYLST and CRYMSG.
::	CALLING SEQ:	JAL	R7,CRYPT
::	INPUT:		R3 = argument in minutes or hours, decimal
::			R6 = $A60, if minutes - $A3600 if hours
::	OUTPUT:		R2 = CRYPTU
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R9
::	CALLS:		JAL	R9,DECHEX
::
::*********************************************************************

CRYPTR	JAL	R9,DECHEX		:Argument is decimal, convert to hex
					:J to DHXBAD for Radix error	###wjl
	LHL	R2,CRYPRI		:Get crypto pointer
	MHR	R6,R3			:Convert to seconds
	JAL	R9,GMTCAL,,		:Get current time to GMTNOW
	L	R3,GMTNOW		:Current time + 7 bits of FASTC
	SRLS	R3,7			:Get rid of FASTC
	SR	R3,R6			:We want to go back to this time
	JGE	CRPTR0			:OK

	JAL	R7,TYPASI
	SC	/REQUESTED TIME OUT OF RANGE/
	J	COMER3

CRPTR0	SHI	R2,10			:Look at next oldest message
	JGEFS	CRPTR1
	AI	R2,CRYPRS		:Wrapped

CRPTR1	nhi	r2,-10
	CLH	R2,CRYPRI		:Back to where we started?
	JE	XPRMPT			:Yes, no message in time frame

	L	R5,CRYPRB+CRYGMT,R2,	:Get message timestamp
	AIS	R5,1			:Make sure it's not -1
	JEFS	CRPTR2			:It is, done
	SIS	R5,1			:Restore timestamp
	SRLS	R5,7			:Dump FASTC
	CLHI	R5,$A1440		:At least a day's worth
	JL	CRPTR0			:No, keep trying
	CR	R3,R5			:Are we in our time frame?
	JL	CRPTR0			:No, keep trying

CRPTR2	AHI	R2,10			:Move forward one
	ci	r2,cryprs		:reached end?
	jlfs	CRPTR3			:nope
	lis	r2,0			:go back to begging
CRPTR3	nhi	r2,-10
	JR	R7			:RETURN

::*********************************************************************
::
::	COMMAND:	SETMES:	SM
::	FUNCTION:	TURN UP TO 7 CRYPTO MESSAGES ON OR OFF
::
::*********************************************************************

SETMES	LR	R2,R2			:CHECK FOR NO ARGUMENTS
	JNFS	SETME9			:ARGS PRESENT, PROCESS THEM
	LIS	R0,0			:CLEAR ALL BITS (ENABLE ALL MSGS)
	LIS	R1,0F			:CLEAR 10 HW
SETME8	STH	R0,CRYARY,R1,R1,	:ENABLE ALL MESSAGES
	SIS	R1,1			:NEXT HW
	JGEBS	SETME8			:DO MORE
	J	XPRMPT			:ALL DONE

SETME9	SIS	R3,1
	JG	COMERR			:LAST ARGUMENT MUST BE 1/ON OR 0/0FF

SETME0	SIS	R2,4			:NUMBER OF ARGUMENTS MINUS 1
	JLE	XPRMPT			:DONE

	L	R0,VALUE1-4,XD,R2	:GET A MESSAGE NUMBER
	jl      comerr
	CLHI	R0,100			:RANGE CHECK
	JGEBS	SETME0			:TOO BIG

	LR	R3,R3			:ON OR OFF?
	JLFS	SETME2			:OFF

	RBT	R0,CRYARY,,		:ON
	J	SETME0

SETME2	SBT	R0,CRYARY,,		:OFF
	J	SETME0

::*********************************************************************
::
::	COMMAND:	SETPRI:	AP
::	FUNCTION:	TURN UP TO 7 CRYPTO priority MESSAGES ON OR OFF###AL
::
::*********************************************************************

	IF	PRIMSG

SETPRI	LR	R2,R2			:CHECK FOR NO ARGUMENTS
	JNFS	SETPR9			:ARGS PRESENT, PROCESS THEM
					:IF NO ARG, BACK TO DEFAUL PRIO. TABLE	
	LA	R0,CRYPDE-2,,		:COPY DEFAULT PRIO. TABLE TO ACTING TAB
	LA	R1,CRYPRE-2,,		:ENDING HW ADDR. R0 SOURCE,R1 DESTINATN
	LHI	R2,10*((CRYPDE-CRYPDF)/2-1)	:SIZE OF HW'S
	COPY	R0,R2
	J	XPRMPT			:ALL DONE

SETPR9	SIS	R3,1
	JG	COMERR			:LAST ARGUMENT MUST BE 1/ON OR 0/0FF

SETPR0	SIS	R2,4			:NUMBER OF ARGUMENTS MINUS 1
	JLE	XPRMPT			:DONE

	L	R0,VALUE1-4,XD,R2	:GET A MESSAGE NUMBER
	jl      comerr
	CLHI	R0,100			:RANGE CHECK
	JGEBS	SETPR0			:TOO BIG

	LR	R3,R3			:ON OR OFF?
	JLFS	SETPR2			:OFF

	SBT	R0,CRYPRY,,		:ON 
	J	SETPR0

SETPR2	RBT	R0,CRYPRY,,		:OFF
	J	SETPR0

	EI	:PRIMSG

::*********************************************************************
::
::	COMMAND:	CRYMSG:	CM
::	FUNCTION:	DISPLAY ALL MESSAGES OF A PARTICULAR TYPE
::
::*********************************************************************

CRYMSG	CLHI	R1,ASCH			:End with 'H' (x48)?
	JNFS	CRYMS0			:No

	LHI	R6,$A3600		:Wants an hour's worth
	JFS	CRYMS5

CRYMS0	CLHI	R1,ASCM			:End with 'M' (x4D)?
	JNFS	CRYMS3			:No

	LHI	R6,$A60			:Wants a minute's worth
CRYMS5	LCS	R2,4			:Decrement arg count since last arg
	AHM	R2,ARGCT,XD		:was time parameter
	JAL	R7,CRYPTR		:Get CRYPTU to R2
	JFS	CRYMS4

CRYMS3	clhi	r1,asccr
	jn	comerr
	LHL	R2,CRYPRI		:Do all messages
	AHI	R2,10
	ci	r2,cryprs		:reached end?
	jlfs	CRYMS4			:nope
	lis	r2,0			:go back to begging
CRYMS4	nhi	r2,-10
	STH	R2,CRYPTU,XD
	JAL	R7,TYPCRL
	LI	R1,CRYMSK,XD		:Destination pointer
	LHI	R2,10			:16d HW's of CRYMSK to zero
	JAL	R8,HCLEAR,,		:CLEAR THE MASK ARRAY
	LH	R2,ARGCT,XD		:				###wjl
CRYMS2	LR	R2,R2
	JLEFS	CRYMS1			:AT END OF ARGUMENT LIST	###wjl

	LHL	R1,VALUE1-2,R2,XD	:GET AN ARGUMENT
	NHI	R1,$A255
	SBT	R1,CRYMSK,XD		:ENABLE THE MESSAGE TYPE
	SIS	R2,4
	JBS	CRYMS2

CRYMS1	LIS	R12,1			:INDICATOR TO XCRYPT TO USE MASK
	LHI	R14,0			:TYPE AS MANY AS NEEDED
	JAL	R8,XCRYPT
	J	XPRMPT


::*********************************************************************
::
::	COMMAND:	X.CT:	CT
::	FUNCTION:	DISPLAY ALL MESSAGES OF A PARTICULAR TYPE
::			WITH THE SPECIFIED VALUE
::
::*********************************************************************

x.ct	clhi	r1,asch			:asking for host?
	je	x.cth			:yes, set up for hosts
	clhi	r1,ascl			:asking for line?
	je	x.ctl
	clhi	r1,asck			:asking for link?
	jn	comerr			:not a valid option, so error
:	match the given link number
	lhi	r3,o5			:address of routine that prints value
	st	r3,value1+4,xd
	l	r3,value1,xd		:get link number
	jal	r9,octhxr		:convert it to hex
	st	r3,value1+8,xd		:save value to match
	j	x.ct10

:	match the given host number
x.cth	lhi	r3,d5			:address of routine that prints val
	st	r3,value1+4,xd
	l	r3,value1,xd		:get host number
	jal	r9,dechex		:convert it to hex
	st	r3,value1+8,xd		:save value to match
	j	x.ct10

:	match the given line number
x.ctl	lhi	r3,ln.bd		:address of routine that prints val
	st	r3,value1+4,xd
	l	r3,value1,xd		:get host number
	jal	r9,dechex		:convert it to hex
	st	r3,value1+8,xd		:save value to match

:	now search and display all crypto messages of this type with this val
x.ct10	lhl	r10,crypri		:newest msg in log
x.ct11	ahi	r10,10			:now oldest msg in log
	ci	r10,cryprs
	jlfs	x.ct12
	lis	r10,0
x.ct12	sth	r10,cryptu,xd		:search the entire log
x.ct14	lhl	r10,cryptu,xd		:search the entire log
	clh	r10,crypri		:gotten back to the start?
	je	xprmpt			:yes, done
	jal	r8,xctypt		:check if we want to print this msg
	 j	x.ct11			:not one to print so do next msg
	lcs	r14,1			:tell xcrypt to print only this msg
	lcs	r12,1			:don't worry about CRYMSK
	jal	r8,xcrypt		:print just the one
	j	x.ct14			:check next message

:	a subroutine to determine if this message is of the desired type
:	(stored in value1+4) and desired value (stored in value1+8).
:	normal return if this entry is not of the desired type or value.

XCTYPT	LB	R11,CRYPRB+CRYTYP,R10,	:Get message type
	CLHI	R11,CRYMTZ/2		:AVOID CRASH,CHECK FOR VALID INDEX
	JGER	R8

	SLLS	R11,1			:FORM HW INDEX
	LHL	R2,CRYMTB,R11,		:GET MESSAGE POINTER
	AI	R2,SEGD			:IN CASE NEEDED BELOW.
	LB	R9,CRYPRB+CRYFLG,R10,	:CHECK FOR 0 FLAGS
	JER	R8			:NO DATA
	LIS	R9,0			:INITIALIZE INDEX INTO DATA FLAG ARRAY
XCTYP1	TBT	R9,CRYPRB+CRYFLG,R10,	:TYPE THE (R2+1)TH HW OF DATA?
	JE	XCTYP5			:NO
	lb	r0,0,r2			:get len
	ar	r2,r0			:point to after text
					:HW FOLLOWING POINTS TO CONVERSION RTN
	AIS	R2,2			:MAKE SURE ON 
	NHI	R2,-2			:HW BOUNDARY
	SLLS	R9,1			:HW INDEX
	LHL	R3,0,R2			:GET SEGD.1 DISP TO APPROP CONVERSN RTN
	c	r3,value1+4,xd		:is it of the type we care about?
	JNFS	XCTYP3	
	LHL	R3,CRYPRB+CRYHW0,R10,R9	:HW OF DATA
	c	r3,value1+8,xd		:does data match intended value?
	JE	4,r8			:yes, indicate success
XCTYP3	SRLS	R9,1			:RESTORE FLAG INDEX
	AIS	R2,2			:POINTER TO NEXT ASCII STRING
XCTYP5	AIS	R9,1			:NEXT HW
	CLHI	R9,4			:CHECKING ONLY BITS 0-3
	JL	XCTYP1			:NEXT string and data
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	XCRYPT:
::	FUNCTION:	PRINT CONTENTS OF CRYPTOGRAM BUFFER
::	CALLING SEQ:	JAL	R8,XCRYPT
::	INPUT:		R12 =	DISPLAY ONLY MESSAGES MASKED IN CRYMSK
::			ALL MESSAGES  ENABLED IF <0
::			R14 =	-(NUMBER OF MESSAGES TO TYPE). IF >= 0
::			MESSAGES TYPED UNTIL EMPTY PTR = FILL PTR
::
::*********************************************************************

XCRYPT	LHL	R10,CRYPTU,XD		:GET THE OUT PTR
XCRYP1	CLH	R10,CRYPRI		:EQUAL IN PTR?
	JER	R8			:YES,RETURN

	LB	R11,CRYPRB+CRYTYP,R10,	:Get message type

	LR	R12,R12			:DISPLAY ALL MESSAGES?
	JLFS	XCRYP2			:YES

	TBT	R11,CRYMSK,XD		:NO,ONLY THOSE ENABLED IN CRYMSK ARRAY
	JE	XCRYP3			:THIS ISNT ONE
XCRYP2	CLHI	R11,CRYMTZ/2		:AVOID CRASH,CHECK FOR VALID INDEX
	JG	XCRYP3

XCRYP4	SLLS	R11,1			:FORM HW INDEX
	L	R2,CRYPRB+CRYGMT,R10,	:GET CRYPTOGRAM TIME AND
	ST	R2,GMTNOW		:STORE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE
	JAL	R7,TYP1SP
	LHL	R3,CRYPRB+CRYFAS,R10,	:16 BITS OF FASTC
	JAL	R9,TYPHW		:AND TYPE IT
	LHL	R2,CRYMTB,R11,		:GET MESSAGE POINTER
	AI	R2,SEGD			:IN CASE NEEDED BELOW.
	LB	R9,CRYPRB+CRYFLG,R10,	:CHECK FOR 0 FLAGS
	JE	XCRY19			:NO DATA
	LIS	R9,0			:INITIALIZE INDEX INTO DATA FLAG ARRAY
XCRY10	TBT	R9,CRYPRB+CRYFLG,R10,	:TYPE THE (R2+1)TH HW OF DATA?
	JE	XCRY12			:NO
	JAL	R7,TYPASC		:R2 HAS POINTER TO NEXT ASCII STRING
					:HW FOLLOWING POINTS TO CONVERSION RTN
	AIS	R2,2			:MAKE SURE ON 
	NHI	R2,-2			:HW BOUNDARY
	ST	R2,XRSAVE+4,XD

	SLLS	R9,1			:HW INDEX
	LHL	R2,0,R2			:GET SEGD.1 DISP TO APPROP CONVERSN RTN
	LHL	R3,CRYPRB+CRYHW0,R10,R9	:HW OF DATA
	STH	R9,XRSAVE,XD		:SAVE R9 BECAUSE OF TYPHW
	JAL	R9,SEGD.1,R2,		:TYPE IT, SEGD.1 is displacement###wjl
	L	R2,XRSAVE+4,XD
	LHL	R9,XRSAVE,XD		:RESTORE FLAG INDEX
	SRLS	R9,1			:RESTORE FLAG INDEX
	AIS	R2,2			:POINTER TO NEXT ASCII STRING
XCRY12	AIS	R9,1			:NEXT HW
	CLHI	R9,4			:CHECKING ONLY BITS 0-3
	JL	XCRY10			:NEXT
	JFS	XCRY20			:ALL DONE
XCRY19	JAL	R7,TYPASC		:TEXT ONLY, NO DATA
XCRY20	JAL	R7,TYPCRL		:TYPE CR/LF

XCRYP3	LHL	R10,CRYPTU,XD
	AHI	R10,10
	ci	r10,cryprs		:reached end?
	jlfs	xcry23			:nope
	lis	r10,0			:go back to begging
xcry23	nhi	r10,-10
	STH	R10,CRYPTU,XD
	AIS	R14,1			:INCREMENT NUMBER OF MESSAGED TYPED
	JER	R8			:IF 0, ALL DONE
	J	XCRYP1

::*********************************************************************
::
::	SUBROUTINE:	XCRPPT:
::	FUNCTION:	PRINT CONTENTS OF CRYPTOGRAM priority BUFFER###al
::	CALLING SEQ:	JAL	R8,XCRPPT
::	INPUT:		R12 =	DISPLAY ONLY MESSAGES MASKED IN CRYMSK
::			ALL MESSAGES  ENABLED IF <0
::			R1 =	-(NUMBER OF MESSAGES TO TYPE). IF >= 0
::			MESSAGES TYPED UNTIL EMPTY PTR = FILL PTR
::
::*********************************************************************

	IF	PRIMSG

XCRPPT	LHL	R10,CRYPPU,XD		:GET THE OUT PTR
XCRPP1	CLH	R10,CRYPPI		:EQUAL IN PTR?
	JER	R8			:YES,RETURN

	LB	R11,CRYPPB+CRYTYP,R10,	:Get message type

XCRPP2	CLHI	R11,CRYMTZ/2		:AVOID CRASH,CHECK FOR VALID INDEX
	JG	XCRPP3

XCRPP4	SLLS	R11,1			:FORM HW INDEX
	L	R2,CRYPPB+CRYGMT,R10,	:GET CRYPTOGRAM TIME AND
	ST	R2,GMTNOW		:STORE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE
	JAL	R7,TYP1SP
	LHL	R3,CRYPPB+CRYFAS,R10,	:16 BITS OF FASTC
	JAL	R9,TYPHW		:AND TYPE IT
	LHL	R2,CRYMTB,R11,		:GET MESSAGE POINTER
	AI	R2,SEGD			:IN CASE NEEDED BELOW.
	LB	R9,CRYPPB+CRYFLG,R10,	:CHECK FOR 0 FLAGS
	JE	XCRP19			:NO DATA
	LIS	R9,0			:INITIALIZE INDEX INTO DATA FLAG ARRAY
XCRP10	TBT	R9,CRYPPB+CRYFLG,R10,	:TYPE THE (R2+1)TH HW OF DATA?
	JE	XCRP12			:NO
	JAL	R7,TYPASC		:R2 HAS POINTER TO NEXT ASCII STRING
					:HW FOLLOWING POINTS TO CONVERSION RTN
	AIS	R2,2			:MAKE SURE ON 
	NHI	R2,-2			:HW BOUNDARY
	ST	R2,XRSAVE+4,XD

	SLLS	R9,1			:HW INDEX
	LHL	R2,0,R2			:GET SEGD.1 DISP TO APPROP CONVERSN RTN
	LHL	R3,CRYPPB+CRYHW0,R10,R9	:HW OF DATA
	STH	R9,XRSAVE,XD		:SAVE R9 BECAUSE OF TYPHW
	JAL	R9,SEGD.1,R2,		:TYPE IT, SEGD.1 is displacement###wjl
	L	R2,XRSAVE+4,XD
	LHL	R9,XRSAVE,XD		:RESTORE FLAG INDEX
	SRLS	R9,1			:RESTORE FLAG INDEX
	AIS	R2,2			:POINTER TO NEXT ASCII STRING
XCRP12	AIS	R9,1			:NEXT HW
	CLHI	R9,4			:CHECKING ONLY BITS 0-3
	JL	XCRP10			:NEXT
	JFS	XCRP20			:ALL DONE
XCRP19	JAL	R7,TYPASC		:TEXT ONLY, NO DATA
XCRP20	JAL	R7,TYPCRL		:TYPE CR/LF

XCRPP3	LHL	R10,CRYPPU,XD
	AHI	R10,10
	NHI	R10,CRYPPS-1		:UPDATE INDEX
	STH	R10,CRYPPU,XD
	AIS	R14,1			:INCREMENT NUMBER OF MESSAGED TYPED
	JER	R8			:IF 0, ALL DONE
	J	XCRPP1

	EI	:PRIMSG

::*********************************************************************
::
::      Command:        XCHNEI - CN
::      Function:       Change Neighbor number.  prompts for rest of
::                      arguements.  (old neighbor, new neighbor, link
::			speed and windowsize (if want smaller than existing)
::
::*********************************************************************
xcnms1	sc	/"0d"0aCurrent Neighbor (0 for XLINK):/
xcnms2	sc	/"0d"0aNew Neighbor (0 to make an XLINK):/
xcnms3	sc	/"0d"0aNew Link Speed in KBPS (100 for MS):/
xcnms4	sc	/"0d"0aWindow Size for this link is /
xcnms5	sc	/."0d"0a/
xcnms6	sc	/"0d"0aRetransmission line pacing value (0 for default):/
xcnms8	bc	1,2,3,4, 6, 8,0c,10,14,17	:internal speed
xcnms9	bc	2,4,7,9,14,19,28,38,48,56	:speeds

xchnei	la	r2,xcnms1		:ask for old neighbor
	jal	r7,typasc
	jal	r9,rdargs
	 j	comer3
	 j	xchnei
	sis	r2,4
	jn	comer3
	jal	r9,octhxr		:get it to hex
	lr	r1,r3			:get node number
	jal	r9,xfndlk,,		:find it
	skipad(comer3)			:not there
	la	r2,xcnms2		:ask for new value
	jal	r7,typasc
	jal	r9,rdargs
	 j	comer3
	 j	xchnei
	sis	r2,4			:anything typed?
	jn	comer3
	jal	r9,octhxr		:convert to hex
	lhl	kn,xknsav,xd		:set up by xfndlk
:	borzap inverted by sdw
	rbt	kn,borzap		:drop link if up
	sth	r3,neikn,kn,kn		:save it to be there if restart
	l	r4,xkdsav,xd		:get link descriptor
	sth	r3,ndid,r4		:for current
	sth	r3,ondid,r4		:still be there if link drops
xchne2	la	r2,xcnms3
	jal	r7,typasc		:get new link speed
	jal	r9,rdargs
	 j	comer3
	 j	xchne7			:wants to leave it the same
	lr	r2,r2
	je	xchne7			:wants to leave it the same
	sis	r2,4
	jn	comer3
	lis	r6,0			:not satelite
	nhi	r1,7f			:end in @ means satelite
	clhi	r1,40
	jnfs	xchne1
	lhi	r6,20			:add in satelite bit	
	lhl     r8,xknsav,xd
	sbt     r8,kncnst,,     	:set satelite bit
xchne1	clhi	r3,100
	jg	xchne2
	jnfs	xchne4			:not ms
	lhi	r1,1f
	jfs	xchne5
xchne4	lis	r1,9			:nine speeds possible
xchne3	clb	r3,xcnms9,r1		:match?
	jefs	xchne6
	sis	r1,1
	jgebs	xchne3			:find a match
	j	xchne2
xchne6	lb	r1,xcnms8,r1		:get internal speed
xchne5	lhl	kn,xknsav,xd		:set up by xfndlk
	l	r4,xkdsav,xd		:get link descriptor
	or	r1,r6			:add in satelite bit
	stb	r1,kspd,kd		:save speed
	stb	r1,knsat,kn,		:and into initial table	
	sbt	kn,kncnsp,,
xchne7	la	r2,xcnms6		:ask for line retrans pacing value
	jal	r7,typasc
	jal	r9,rdargs
	 j	comer3
	 j	xchne9			:wants to leave it the same
	lr	r2,r2
	jefs	xchne9
	lr	r3,r3
	jlefs	xchne9
	clhi	r3,1f			:max value
	jg	comer3,,
	lhl	kn,xknsav,xd		:set up by xfndlk
	sth	r3,lnkrtr,kn,kn,	:save new value for this link
xchne9	j	xprmpt,,

::*********************************************************************
::
::      Command:        XRYPS  - PS
::      Function:       equivalent of the sup pstat command.  syntax is
::                      ps <num> S N or H for sup, neighbor or host ports
::
::*********************************************************************

XRYps	SIS	R2,4			:we have a node # or give display
	JL	XRYps0			:skip to give display of all dports
	clhi	r1,ascl			:asking for a link
	je	xrypsl			:handle links
	clhi	r1,asch			:asking for a host?
	je	xrypsh			:handle dispatcher ports for the host
xrypse	j	comerr			:none of the above is an error

xrypss	Lhi	R7,supzfl		:number of SUPERVISOR ports
	LHI	R6,nsp			:# OF GROUPS
	J	xryps3

:	REPORT ALL DISPATCHER PORTS IN USE
xryps0	clhi	r1,ascs			:asking for sup ports
	jebs	xrypss			:handle sup ports
	clhi	r1,asccr		:no arg must have no option
	jn	comerr
	LHI	R6,ndp			:NUMBER OF BYTES OF ACP TO CHECK
	Lhi	R7,DISzfl		:GET START ADDR OF DISPATCHER ACP ARRAY
	J	xryps3			:PROCESS

xrypsh	l	r3,value1,xd		:get host number
	jal	r9,dechex,,
	lr	r1,r3
	JAL	R9,FNDHST,,		:HOST, FIND IT
	j	xrypse			:immed ret, WE DONT KNOW HIM	###wjl
        if      1-t2gate                :gateway's dports are to hst0
	CLHI	R1,HST0			:+4 return, HOST = KERNEL ?
	JN	xrypsi			:NO,REPORT DISPATCHER HOST PORTS IN USE
        else    :gateway
        j       xrypsi
        ei
	LHI	R6,nku			:YES, SET UP # OF PORTS
	LHI	R7,KERzfl		:SET UP START OF KER PRTS

:	here to report all ports that are active for the given port range
:	r6 is number of ports, r7 is starting point in acp
xryps3	LIS	R5,0c
	ar	r6,r7			:where to stop
        lr      r10,r7
xryps5	tbt	r10,acp,,		:port active
	jnfs	xryps4			:not active
	lr	r3,r10
	jal	r9,typhw,,		:print it
	SIS	R5,1
	JGfs	xryps4
	jal	r7,typcrl,,
	lis	r5,0c			:new count
xryps4	AIS	R10,1			:GO TO NEXT port
	cr	r10,r6
	jl	xryps5
	j	XPRMPT

:	RETURN PORTS IN USE BY SPECIFIED HOST
xrypsi	LR	R10,R1			:SAVE HOST NUMBER
	LIS	CHN,0			:INIT CHN FOR THIS GROUP OF 10
	lis	r6,0c			:12 ports per lins	
xrypsj	LHL	R0,DHSTIX,chn,chn	:GET HOST # FOR CIRCUIT ON THIS PORT
	CR	R0,R10			:IS THIS THE HOST SPECIFIED?
	JNFS	xrypsg			:NO
	lhi	r3,diszfl,chn
	jal	r9,typhw,,		:print it
	SIS	R6,1
	JGfs	xrypsg
	jal	r7,typcrl,,
	lis	r6,0c			:new count
	
xrypsg	AIS	CHN,1
	clhi	chn,ndp
	jl	xrypsj			:do next port
	J	XPRMPT			:done



:	PORT STATUS REQUEST IS FOR LINK. FIND LINK DESCRIPTOR, 
:	ACP OFFSET, AND NUMBER OF CHANNELS TO SCAN.
xrypsl	l	r3,value1,xd
	jal	r9,octhxr,,
	JAL	R9,xFNDLK		:FIND LINK DESCRIPTOR FOR THIS NEIGHBOR
	j	xrypse			:immed, NEIGHBOR DOES NOT EXIST	###wjl
	lhl	kn,xknsav,xd
	TBT	kn,ALINKS		:+4 return, IS LINK ACTIVE?
	JE	xrypse			:NO, error

	lhl	r7,lkzfkn,kn,kn		:absolute chn 0
	l	kx,xkdsav,xd
	LHL	R6,NCHN,kx		:NUMBER OF CHANNELS ASSIGNED TO LINK
	j	xryps3

::*********************************************************************
::
::      Command:        XRYWSZ - WZ
::      Function:       Change window size.  Must BORIZAP link so that
::                      new size can come up.
::
::*********************************************************************

XRYWSZ	L       R3,VALUE1,XD    	:get node number
	JAL     R9,OCTHXR 		:get node number in hex
	LR      R1,R3     		:setup to find link
	JAL     R9,XFNDLK,,     	:find it
	SKIPAD(COMERR)    		:not there, error
	L       R3,VALUE1+4,XD  	:get desired window size
	JAL     R9,DECHEX
	CLHI    R3,100    		:way too big?
	JGE     COMERR    		:bigger than the next compare
	LHL     KN,XKNSAV,XD    	:get link number
	CLH     R3,XWSZKN,KN,KN 	:can't be bigger than assembled size
	JG      COMERR,
	CLHI    R3,MINWSZ 		:no smaller than 4
	JL      COMERR
	STB     R3,WSZKN+1,KN,KN	:save new window size
:	borzap inverted by sdw
	rBT     KN,BORZAP 		:link will come up with new window
	J       XPRMPT,,  		:and done

::*********************************************************************
::
::      Command:        XRYWPK - PK
::      Function:       display size of packets being made for that neighbor
::                      to determine why packets are small so often
::
::*********************************************************************

       IF       XRYRMK    		:enabled
XRYWPK  SIS     R2,4      		:we have a node # or give display
	JL      XRYWP0    		:skip to give display
	JAL     R9,OCTHXR,,     	:convert node #
	STH     R3,XRMKNE,,     	:node to monitor
	LIS     R0,0      		:zero out old entries
	LIS     R1,0
XRYWP9  ST      R0,XRMKHS,R1,
	AIS     R1,4
	CLHI    R1,$A128*2		:HW per packet size
	JLEBS   XRYWP9
	J       XPRMPT,,  		:and done

XRYWP0  LIS     R5,0      		:how far into histogram
	LHI     R6,$A128  		:value at 0 pos of histogram
XRYWP1  LR      R3,R6     		:output range
	JAL     R9,TYPHWD,,
	L       R3,XRMKHS,R5,R5 	:value
	JAL     R9,TYPFW
	LHI     R3,$A-32,R6
	JAL     R9,TYPHWD 		:rnange of next column
	L       R3,XRMKHS+$A32*2,R5,R5  :value for next column
	JAL     R9,TYPFW
	LHI     R3,$A-64,R6
	JAL     R9,TYPHWD
	L       R3,XRMKHS+$A64*2,R5,R5  :value next column
	JAL     R9,TYPFW
	LHI     R3,$A-96,R6
	JAL     R9,TYPHWD
	L       R3,XRMKHS+$A96*2,R5,R5
	JAL     R9,TYPFW
	JAL     R7,TYPCRL 		:new lin
	AIS     R5,2
	SIS     R6,2
	CLHI    R6,$A96
	JG      XRYWP1
	J       XPRMPT,,

      EI	:XRYRMK


::*********************************************************************
::
::	COMMAND:	RSSILN:	SI				###LSH
::	FUNCTION:	INITIALIZE AN SIO LINE
::
::*********************************************************************

	IF	SILINS 
RSSILN	ci	xd,ttyxd		:if tty then need no power
	jefs	rssil1
	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
	JGE	xpwer1			:NO, TELL HER SO
rssil1	JAL	R9,DECHEX	:CHANGE TO HEX
				:J to DHXBAD for bad radix		###wjl
	CLHI	R3,NLINES	:MUST BE IN THE SIO LINE#'S RANGE	##AL
	JGFS	SSHS3
	SHI	R3,NLINES-SILINS:CHECK IF IN SIO LINE RANGE
	JGEFS	SSHS1		:YES, 
SSHS3	LA	R2,SSMSG1,,	:NOT A SIO LINE
	JAL	R7,TYPasc,,
	J	XPRMPT
SSHS1	CLHI	R3,SILINS	:CHECK IF IT IS TOO BIG
	JGEbs	SSHS3		:WRONG LINE #
	SLLS	R3,4		:16*LINE#
	LCS	R2,2
	STH	R2,SIOSTT+8,R3,	:-2 INDICATES SOFTWARE INIT
	J	XPRMPT		
	EI	:SILINS	

	SUBTTL	XRAY (Miscellaneous - SY, BD)

::*********************************************************************
::
::	COMMAND:	SYMBAD:	SY
::	FUNCTION:	TYPES OUT ADDRESSES OF SYMBOLS FROM THE SYMBOL TABLE
::
::*********************************************************************

SYMBAD	lr	r6,r1			:get the char
	clhi	r1,asccr		:just SY*
	je	comerr
	JAL	R7,TYPCRL		:TYP CR-LF
	OHI	R6,80			:SET HOB
	LIS	R5,0


SYMBA1	CLHI	R6,ASCAST+80		:ASTERISK (x20) = DISPLAY ENTIRE TABLE
	JEFS	SYMBA3

	NHI	R6,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE/xDF
	LB	R2,SYMTBL,R5,		:GET FIRST CHARACTER
	CR	R2,R6
	JN	SYMBA2			:NOT A MATCH

SYMBA3	LA	R2,SYMTBL-1,R5,		:SYMBOLIC NAME
	lis	r0,6
	JAL	R7,TYPAS1
	lhi	r1,3a			:print the colon
	jal	r13,xryout
	JAL	R7,TYP2SP		:2 SPACES
	L	R3,SYMTBL+6,R5,		:SYMBOL ADDRESS
	JAL	R9,TYPFW		:TYPE IT OUT
	JAL	R7,TYPCRL

SYMBA2	AHI	R5,ADRESZ	
	CLHI	R5,SYMTSZ		:AT END OF TABLE?
	JL	SYMBA1
	J	XPRMPT			:FINISHED

::*********************************************************************
::
::	COMMAND:	XBDSET:	BD	###JHL
::	FUNCTION:	BD sets or displays buffer delay timing method.
::	INPUT:		BD displays current method
::			BDP sets timing by char pairs (COMETS 0314)
::			BDR sets timing based on round robin frequency
::
::*********************************************************************

	IF	BFLTMR
XBDPR0	SC	/"0D"0ABUFFER DELAY BY TIMING PAIRS"0D"0A/
XBDPR1	SC	/"0D"0ABUFFER DELAY BY RMK FREQUENCY"0D"0A/

XBDSET	CLHI	R1,ASCP			:DID USER END WITH P?
	JE	XBDSTP			:ZERO OUT THE CELL
	CLHI	R1,ASCR			:DID USER END WITH R?
	JE	XBDSTR			:STORE NON-ZERO IN THE CELL
	clhi	r1,asccr
	jn	comerr
XBDDSP	LHL	R1,BFDOPT,,		:READ THE CELL
	JEFS	XBDCPR			:GET CHAR PAIR STRING
	LA	R2,XBDPR1		:POINT TO RMK FREQ STRING
	JFS	XBDS10
XBDCPR	LA	R2,XBDPR0		:POINT TO CHAR PAIR STRING
XBDS10	JAL	R7,TYPASC		:OUTPUT THE STRING
	J	XPRMPT			:BACK TO TOP LEVEL

XBDSTP	LIS	R1,0			:FOR CHAR TIMING
XBDS20	STH	R1,BFDOPT,,		:STORE SELECTED VALUE
	J	XBDDSP			:DISPLAY CURRET OPTION TO USER
XBDSTR	LIS	R1,1			:FOR TIMING BY RMK FREQ
	JBS	XBDS20
	EI	:BFLTMR

	SUBTTL 	XRAY (Delay measurement - DL, DB, DD, DE)

::*********************************************************************
::
::	COMMAND:	XLUPBK:	DL
::	FUNCTION:	CONSTRUCTS A CLOSED CIRCUIT THAT PASSES THROUGH
::			ALL NODES IN THE ARGUMENT LIST.
::
::*********************************************************************

:	INITIAL 'FILL' BYTES ARE PUT IN THE OUTBOUND BUFFER, AND THEY
:	SUBSEQUENTLY MOVE 'ROUND AND 'ROUND THE LOOP.
:	THE CPS RATE THEY GENERATE (MEASURED WITH THE KS AND NS COMMANDS)
:	INDICATE THE PROCESSING SPEEDS OF THE NODES INCLUDED IN THE CIRCUIT.

:	local equates for needle flag bits
PRTYBT	EQ	100			:priority bit
TPCLA	EQ	00			:throughput class A
TPCLB	EQ	10			:throughput class B
TPCLC	EQ	20			:throughput class C
TPCLD	EQ	30			:throughput class D

TPCLAS	SC	/"0D"0ATHROUGHPUT CLASS (0-3): /

xdbciu	hs	2			:the XD user of xray
xdbchn	hs	1			:the chn they grabbed

::*********************************************************************
::
::	COMMAND:	DBEGIN:	DB
::	FUNCTION:	COMMAND HANDLER TO INPUT PARAMETERS FOR ROUND-TRIP
::			DELAY MEASUREMENT
::
::*********************************************************************

:	DL command entry
XLUPBK	LHL	R0,INTLPF		:CURRENTLY ONLY 1 LOOPBACK IS SUPPORTED
	JN	COMERR			:ALREADY ONE THERE, ERROR
	TS	XLUPFL			:SET FLAG AND FALL THRU TO DBEGI CODE

:	DB command entry
DBEGIN	SIS	R2,4			:IF NO ARG'S, INDEX = 0.
	JGEFS	DBEG02			:AT LEAST 1 ARG.
	LIS	R6,0			:DEFAULT INDEX = 0
	JFS	DBEG07
DBEG02	LHL	R6,VALUE1+2,XD		:GET DB-INDEX FROM CMD LINE	###JHL
	LH	R13,XPOWER,XD		:GET USER'S POWER		###TZ
	JLEFS	DBEG05			:OK
	LR	R6,R6
	JN	xpwer1			:ONLY INDEX 0 FOR NON-POWER
DBEG05	CLHI	R6,TINTCH/2
	JGE	COMERR			:ARGUMENT IS TOO LARGE
DBEG07	l	r4,xdbciu		:command already in progress?
	jn	xcomiu			:yes, give them error message
	lis	r14,0			:check first chn
dbeg08	lhl	r2,inttab,r14,r14	:check permuter table
	jefs	dbeg10			:found an unused chn
	ais	r14,1			:check next chn
	clhi	r14,tintch
	jlbs	dbeg08
	J	DBERR			:NO,NONE
DBEG10	st	xd,xdbciu		:mark db command already in use
	sth	r14,xdbchn		:mark which chn number
	lhi	r2,0dbdb		:our db marker (in case of confusion)
	sth	r2,inttab,r14,r14	:prevent others from using this chn
	STH	R6,INTNDX,R14,R14	:STORE DB-INDEX BY INTHST CHAN#
	LR	R7,R6			:SAVE INDEX
	LHI	R6,DLYBSZ		:SIZE OF DLY DATA AREA
	MHR	R6,R7			:TIMES INDEX = OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:FORM OFFSET TO THIS INDEX
	LH	R2,DLSTAT,R6		:MAKE SURE IT IS AVAILABLE
	JG	DBERR2			:STATUS OF 1 MEANS IT IS IN USE
	LI      R2,-DLYBSE,R6   	:DLYCHN is now offset from DLYBSE###sdw
	STH	R14,DLYCHN,R7,R7	:DELAY # TO INT HST CHN# PERMUTER TBL
	STH	R2,CHNDLY,R14,R14	:CHN # TO DELAY ADDRESS PERMUTER TABLE
	LHI	R2,8080+TPCLD		:MAKE SURE FLAGS ARE NEVER ZERO
	OH	R2,DLYFLG,R6
	STH	R2,DLYFLG,R6
	LR	R7,R7			:DLY CHN INDEX 0?
	JNFS	DBEG13			:NO, GO PROMPT
	LHI	R2,8080+TPCLD		:PRIORITY 0 FLAGS--THRUPUT CLASS 3
	STH	R2,DLYFLG,R6
	LIS	R2,0
	STH	R2,DLYFIL,R6		:DEFAULT 0 HW FILL
	LIS	R2,7
	STH	R2,DLYINT,r14,r14	:DEFAULT RATE = 3 (1 SEC)
	J	DBEG25			:GO ASK FOR NODE LIST.
DBEG13	LA	R2,PRPRTY,,		:PROMPT FOR PRIORITY
	JAL	R7,TYPASC
	JAL	R9,RDARGS		:get args
	 J	dberr1			:illegal args
	 j	dbeg13			:empty line
	LR	R2,R2
	JEFS	DBEG18			:NO ARGUMENT,LEAVE PRIORITY UNCHANGED
	LHI	R2,8080+TPCLD		:DEFAULT FLAGS (HIGH-SPEED)
	LR	R3,R3			:TEST ARGUMENT
	JLEFS	DBEG16			:<= 0 MEANS NOT PRIORITY
	OHI	R2,PRTYBT		:SET PRIORITY BIT
DBEG16	STH	R2,DLYFLG,R6		:AND STORE FLAG
:	set TP class limit for delay msmt circuits	###jhl
DBEG18	LA	R2,TPCLAS		:pointer to "TP CLASS?" string
	JAL	R7,TYPASC		:output string to user
	JAL	R9,RDARGS		:get response from user
	 J	dberr1			:output the witty "??"
	 j	dbeg18
:	now R2 has # args, R3 has last number entered
	LR	R2,R2			:check # args
	JE	DBEG20			:no args--TP class is default
	SLLS	R3,4			:shift arg into speed bits position
	CLHI	R3,TPCLA		:can't be less than class A (0)
	JL	dberr1
	CLHI	R3,TPCLD		:nor more than class D (3)
	JG	dberr1
	LHL	R2,DLYFLG,R6
	NHI	R2,0FFFF-30		:clear the speed bits field
	AR	R3,R2			:add in the new speed bits
	STH	R3,DLYFLG,R6		:and write the new needle flags

DBEG20	LA	R2,PRFILL,,		:PROMPT FOR NUMBER OF FILL HWS
	JAL	R7,TYPASC
	JAL	R9,RDARGS
	 J	dberr1			:output the witty "??"
	 j	dbeg20
	LR	R2,R2
	JEFS	DBEG23			:NO ARGUMENT,LEAVE FILL UNCHANGED
	SRLS	R3,1			:CONVERT BYTES TO HW
	CLHI    R3,100    		:DON'T LET THEM PICK TOO BIG A NUM
	JLEFS   DBEG24
	LHI     R3,100    		:512 BYTES OF FILL IS BIG ENOUGH
DBEG24	STH	R3,DLYFIL,R6
DBEG23	LA	R2,PRTINT,,
	LH	R0,XLUPFL		:IS THIS SPECIAL LOOPBACK CRQ?
	JL	DBEG25			:YES, LEAVE TIME INTERVAL ALONE
	JAL	R7,TYPASC		:PROMPT FOR TIME INTERVAL
	JAL 	R9,RDARGS		:AND READ IN THE VALUE
	 J	dberr1			:output the witty "??"
	 j	dbeg23
	LR	R2,R2			:CHECK FOR ZERO ARGUMENTS
	JEFS	DBEG25			:YES,LEAVE TIME INTERVAL UNCHANGED
	CLHI	R3,7			:KEEP JUST LOWER 3 BITS
	JGE     dberr1    		:only values 0-6
	lhi     r0,3f
	SRL     R0,0,R3
	lh	r14,xdbchn		:mark which chn number
	STH	R0,DLYINT,r14,r14	:STORE AWAY RATE
DBEG25	LA	R2,PRNODE,,		:PROMPT FOR NODES
	JAL	R7,TYPASC
	JAL	R9,RDARGS		:READ IN UP TO 8 NODES
	 J	dberr1			:output the witty "??"
	 j	dbeg25
	CLHI	R1,ASCR			:ENDED IN 'R' (x52)?
	JN	DBEG30			:NO...
	SIS	R2,4			:only 1 node number allowed for 'R'
	JN	DBERR1			:if more then error	###09/23/93
	LHI	R2,$A12			:YES, INITIALIZE INDEX       ###SHM
	JAL	R9,OCTHXR		:CONVERT LAST NODE(R3) TO HEX###SHM
	LHI	R4,MACHNM		:GET OUR NODE NUMBER IN HEX  ###SHM
DBEG28	STH	R3,NODLST,R2,R6		:STORE DESIRED NODE          ###SHM
	STH	R4,NODLST+2,R2,R6	:STORE OUR NODE              ###SHM
	SIS	R2,4			:DECREMENT NODE COUNT        ###SHM
	JGEBS	DBEG28			:DONE?                       ###SHM
	LHI	R2,$A16			:LOAD 2 X NUMBER OF NODES    ###SHM
	STH	R2,NODCNT,R6		:STORE IN NODCNT             ###SHM
	JAL	R7,TYPCRL		:ECHO CRLF                   ###SHM
	J	DBEG35			:GO PROCESS NODLST           ###SHM
DBEG30	JAL	R7,TYPCRL		:ECHO CRLF
	LHL	R2,ARGCT,XD		:4 x NUMBER OF NODES IN ONE-WAY PATH
	SRLS	R2,1			:MAKE IT TWICE # OF NODES (divide by 2
	JE	DBEG35			:NO ARGS, LEAVE NODE LIST UNCHANGED

	STH	R2,NODCNT,R6		:STORE IN NODE COUNT FIELD
	LIS	R4,0			:INITIALIZE OFFSET              ###SHM
DBEGI4	L	R3,VALUE1,R4,XD		:LOAD FW NODE NUMBER            ###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX		        ###SHM
	SRLS	R4,1			:CONVERT TO HW INDEX            ###SHM
	STH	R3,NODLST,R4,R6		:STORE HEX NODE NUMBER IN NODLST###SHM
	AR	R4,R4			:BACK TO FW INDEX               ###SHM
	AIS     R4,4			:INCREMENT INDEX                ###SHM
	SIS	R2,2			:DECREMENT NODE COUNT           ###SHM
	JGBS	DBEGI4			:MORE?                          ###SHM
DBEG35	LIS	R4,1
	STH	R4,DLSTAT,R6		:MARK NEW STATUS : NEEDLE REQUESTED
	LIS	R0,0
	STH	R0,DLYPTF,R6		:ZERO THE FILL POINTER
	STH	R0,DLYAV1,R6
	STH	R0,DLYAV2,R6
	LHI	R2,20			:CLEAR SAMPLE AREA SO AS NOT TO
	LI	R1,DLYTBL,R6		:NOT TO CONFUSE POOR USER IN THE
	JAL	R8,HCLEAR,,		:EARLY GOING.
	lhl	r14,xdbchn		:mark which chn number
	SBT	R14,INTUSE		:MARK THE CHANNEL IN USE
	rbt     r14,intxrf		:fix potential crash
	LHI	CHN,INTZFL,R14		:PASS ABSOLUTE CHANNEL NUMBER TO MAKNDL
	lis	r0,0
	st	r0,xdbciu		:clear DB in progress flag
	sth	r0,xdbchn		:remove chn in progress	flag
					:makndl will clear inttab marker

:       if XDDT then prevent XDDT/background potential bufferpool corruption
:       by storing address of troublesome subroutine

	CLI     XD,TTYXD  		:tty user?
	JN      DBEG40    		:nope
	LA      R8,DBEG45 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	J       XPRMPT
DBEG40  JAL     R8,DBEG47 		:just call subroutine
	J       XPRMPT    		:and done
:       here for background doing a task for XDDT
DBEG45  ST      R8,XDDTSV+4*R8  	:so overwrite link reg with link reg
	LM      R0,XDDTSV 		:get back registers

:       only background can run this area of code.
DBEG47  ST      R8,DBEGS1 		:save link register
	JAL	R10,MAKNDL,,		:GO MAKE THE NEEDLE
	LH	R0,XLUPFL		:IS THIS A LOOPBACK CRQ?
	JL	DBEG50			:YES

	LHI	R0,DLYREC-SEG1.2	:GET DISPATCH ADDRESS FOR THIS CHN#wjl
	STH	R0,INTDSP,R14,R14	:AND STORE INTO INTHST DISPATCH ARRAY
	SBT	R14,INTDRF		:SET THE DELAY RECEIVER CRQ FLAG
	LHI	R1,ASCD			:WRITE FUNCTION BYTE AFTER NEEDLE
	JAL	R8,WCI,,		:...BUFFER # WAS SET UP IN MAKNDL
	LHL	R1,DLYFIL,R6		:ALSO GET #OF FILL HW
	JAL	R9,WCIE,,		:AND SEND AFTER NEEDLE
	EXBR	R1,R1			:move high order byte for WCI	###JHL
	JAL	R9,WCIE,,		:and send after needle		###JHL
	lhl     r1,dlyint,r14,r14
	jal     r9,wcie,, 		:and now send rate
:	CREATOR OF DLY MSMT CIRCUIT IS OWNER				###JHL
	LHL	R6,INTNDX,R14,R14	:READ DB-INDEX FROM ARRAY BY CHAN#
	AR	R6,R6			:DOUBLE FOR HW OFFSET
	ST	XD,DB0USE,R6,R6		:IDENTIFY CREATOR IN WORD ARRAY

	L       R8,DBEGS1 		:restore link reg
	JR      R8        		:now all done

DBEG50	LHI	R0,DLYERR-SEG1.2	:				###wjl
	STH	R0,INTDSP,R14,R14	:DISPATCH ADDRESS = BIT BUCKET
	SBT	R14,INTLPF		:MARK THIS CHANNEL AS LOOPBACK ONE
	LHI	R1,ASCL^8+ASCL		:function byte and fillchars = 'L'
	JAL	R8,WCI,,		:R2 WAS SET UP IN MAKNDL
	LHL	R10,DLYFIL,R6		:FILL NUMBER OF HW
DBEG55	JAL	R9,WHWI,,		:WRITE INTO BUFFER AFTER NEEDLE
	SIS	R10,1
	JGBS	DBEG55
	LIS	R0,0
	STH	R0,XLUPFL		:CLEAR FLAG
:	CREATOR OF DLY MSMT CIRCUIT IS OWNER				###JHL
	LHL	R6,INTNDX,R14,R14	:RECOVER DLY CHN INDEX
	AR	R6,R6			:DOUBLE TO HW OFFSET
	ST	XD,DB0USE,R6,R6		:IDENTIFY CREATOR IN WORD ARRAY

	L       R8,DBEGS1 		:restore link
	JR      R8        		:done with Background only area ###sdw

:	chn in use error
dberr2	jal	r9,remdb0		:clear before exiting
DBERR	LI	R2,DERMSG		:###TZ
	JAL	R7,TYPASC
	J	comclr			:remove any extra input
:	some error after grabbed chn
DBERR1	jal	r9,remdb0		:clear grabbed chn
	j	comer3			:go handle error

:	little routine to clear the in db in progess stuff.
:	links on r9
remdb0	C	XD,XDBCIU		:IN MIDDLE OF DB?
	jnr	r9
	LIS	R0,0
	ST	R0,XDBCIU		:DB command not in use any more
	lhl	r1,xdbchn		:which chn was taken
	lhl	r3,inttab,r1,r1		:check our taken chn
	ci	r3,0dbdb		:it is db's marker?
	jnr	r9			:not
	sth	r0,inttab,r1,r1		:it is so make port free for all
	jr	r9			:and done

::*********************************************************************
::
::	COMMAND:	DLDATA:	DD
::	FUNCTION:	DISPLAY DELAY MEASUREMENT STATISITCS
::
::*********************************************************************

DLDATA	SIS	R2,4			:1 ARG?
	JGEFS	DLDAT5			:YES
	LIS	R6,0			:DEFAULT ARG = 0.
	JFS	DLDAT6
DLDAT5	LR	R6,R3			:SAVE ARGUMENT
	JL	COMERR
	CLHI	R6,TINTCH/2		:CHECK SIZE
	JGE	COMERR			:TOO LARGE
DLDAT6	LR	R7,R6			:SAVE INDEX
	lr      r5,r6
	LHI	R6,DLYBSZ		:SIZE OF DLY DATA AREA
	MHR	R6,R7			:TIMES INDEX = OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:ADDRESS OF DATA BLOCK
	LA	R2,DLDMS0,,		:HEADER 0
	JAL	R7,TYPhdr
	LA	R2,DLDMS1,,		:HEADER 1
	JAL	R7,TYPhdr
	lh      r5,dlychn,r5,r5 	:get the chn
	LH	R1,DLYINT,r5,r5		:GET TIME INERVAL
	LHL	R10,DLYFIL,R6		:GET FILL
	JEFS	DLDAT4			:SKIP IF ZERO
	AIS	R10,1			:IF NON-ZERO, ADD IN CLOCK
DLDAT4	AIS	R10,1
	SLLS	R10,5			:MULT BY 32
	LIS	R0,0
	AIS	R1,1
	slls    r1,1
	Sth	R1,XDLTMP
	LHL	R3,XDLTMP
	slls    r3,6
	JAL	R9,TYPHWD
	LR	R2,R10
	DH	R2,XDLTMP
	JAL	R9,TYPHWD

	LIS	R5,0			:TYPE 4 HW
DLDLP3	LHL	R3,DLSTAT,R6,R5		:STAT, FLAG,HWF,PTR
	JAL	R9,TYPHW
	AIS	R5,2
	THI	R5,7			:DONE?
	JNBS	DLDLP3			:NO
	LHL	R2,DLYAV1,R6		:GET FIRST AVERAGE
	JAL	R9,FSTMSC		:CONVERT TO MS (IN R3)
	JAL	R9,TYPHWD		:DISPLAY IN DECIMAL
	LHL	R2,DLYAV2,R6		:SAME FOR SECOND AVERAGE
	JAL	R9,FSTMSC
	JAL	R9,TYPHWD
	JAL	R7,TYPCRL		:CR-LF
	LA	R2,DLDMS2,,
	JAL	R7,TYPhdr		:SECOND HEADER
	LHL	R5,NODCNT,R6		:NUMBER OF NODES
	LR	R10,R6
DLDAT3	LHL	R3,NODLST,R10		:NEXT NODE
	AIS	R10,2
	SIS	R5,2			:DECREMENT
	JLFS	DLDAT2			:ALL DONE
	JAL	R9,TYP5o		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	JBS	DLDAT3
DLDAT2	LA	R2,DLDMS3,,		:THIRD HEADER
	JAL	R7,TYPhdr
:	CONVERT TO MS AND TYP DECIMAL 32 SAMPLES, 8 AT A TIME
	LIS	R11,0			:TO COUNT NO. HW'S TYPED
	JFS	DLDLP2
DLDLP1	JAL	R7,TYPCRL
DLDLP2	LHL	R2,DLYTBL,R6,R11	:GET A SAMPLE VALUE (FASTC)
	JAL	R9,FSTMSC		:CONVERT TO MS (R3)
	JAL	R9,TYPHWD		:DISPLAY
	AIS	R11,2			:POINT TO NEXT HW
	THI	R11,3F			:DONE 64 BYTES (32 HW)?
	JEFS	DLDDON			:ALL DONE
	THI	R11,0F			:DONE 16 BYTES (8 HW) = 1 LINE?
	JE	DLDLP1			:YES, DO NEXT LINE
	J	DLDLP2			:NO, DO NEXT HW
DLDDON	JAL	R7,TYPCRL
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	DLYEND:	DE
::	FUNCTION:	TERMINATE DELAY MEASUREMENT OPERATION ON A CHANNEL
::
::*********************************************************************

:	THE CRQ IS ZAPPED IN THE DIRECTION THAT THE NEEDLE ORIGINALLY TOOK

DLYEND	LHL	R2,ARGCT,XD		:IF NO ARG'S, INDEX = 0.
	JGFS	DLYENA			:AT LEAST 1 ARG.
	C	XD,DB0USE		:DID THIS USER SET IT UP?
	JN	COMERR			:NO, CAN'T END IT.
	LIS	R6,0			:DEFAULT INDEX = 0
	JFS	DLYENB
DLYENA	LHL	R6,VALUE1+2,XD
	LH	R4,XPOWER,XD		:				###TZ
	JG	xpwerr			:SECURITY VIOLATION		###TZ
DLYEN2	CLHI	R6,TINTCH/2
	JGE	COMERR			:TOO BIG
:	CREATOR OF DLY MSMT CIRCUIT IS THE OWNER			###JHL
DLYENB	AR	R6,R6			:BYTE INDEX TO HW INDEX
	C	XD,DB0USE,R6,R6		:INDX TO FW TBL--WHO OWNS THIS CHAN
	JN	COMERR			:ONLY THE CREATOR CAN ZAP IT
	SRLS	R6,1			:BACK TO BYTE INDEX

	LR	R5,R6			:SET UP TO GET DELAY CIRCUIT STATUS
	LHI	R6,DLYBSZ		:SIZE OF DELAY DATA AREA
	MHR	R6,R5			:R6=OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:R6=POINTS TO DATA AREA FOR THIS INDEX
	LH	R4,DLSTAT,R6		:CIRCUIT UP (STAT = 1)?
	JLE	COMERR			:NO
	LH	R5,DLYCHN,R5,R5		:INT HST CHANNEL INDEX
	TBT	R5,INTDRF		:MAKE SURE THIS CHN IS BEING USED
	JNFS	DLYEN9			:OK
	TBT	R5,INTLPF		:NOT DELAY MEASRMENT, PERHAPS LOOPBACK
	JE	COMERR			:NO, NOTHING THERE
DLYEN9	LR	R4,R5			:PUT INT HST CHAN INDEX IN R4
	AHI	R5,INTZFL		:ABSOLUTE CH # IN R5
	LHL	R2,IOTAB,R5,R5		:AND THE OUTGOING BUFFER IN R2
	JE	COMERR			:NOTHING THERE, ALREADY BEEN ZAPPED

	CLI     XD,TTYXD  		:tty user?
	JN      DLYEN4    		:nope
	LA      R8,DLYEN7 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	J       XPRMPT
DLYEN4  JAL     R8,DLYEN8 		:just call subroutine
	J       XPRMPT    		:and done

DLYEN7  ST      R8,XDDTSV+4*R8  	:save link so get it back when LM
	LM      R0,XDDTSV 		:get back XDDT's regs
DLYEN8  ST      R8,DLYES1 		:store link register
	NHI	R2,-4			:STRIP SIGN BITS--SWITCH TO INCOMING
	XHI	R2,4			:BUFFER (INTZAP WILL SWITCH BACK)
	JAL	R10,INTZAP,,		:ZAP THE INT HOST CRQ
	LCS	R0,2
	STH	R0,DLSTAT,R6		:NOTE WE'VE DONE THE ZAP
	L       R8,DLYES1 		:get back link register
	JR      R8        		:and return

:	xrsfrm	sets short data format if value is 1 otherwise resets

xrsfrm	sis	r2,4			:any args?
	jgefs	xrsfr2
xrsfr1	lis	r0,0
xrsfr3	stb	r0,xsform,xd		:not in compress form
	j	xprmpt
xrsfr2	l	r1,value1,xd
	jebs	xrsfr1			:not compress if sf 0
	lis	r0,1			:set compress form
	jbs	xrsfr3
	

	SUBTTL	XRAY (Echo mode - RE, LE)

::*********************************************************************
::
::	COMMAND:	XRECHO:	RE
::	FUNCTION:	SET DEFERRED OR REMOTE ECHO MODE (XRAY ECHOS)
::
::*********************************************************************

XRECHO	LIS	R0,0
	STH	R0,EKOTYP,XD
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	XLECHO:	LE
::	FUNCTION:	SET LOCAL ECHO MODE ( USER IS DOING ECHOING)
::
::*********************************************************************

XLECHO	TS	EKOTYP,XD
	J	XPRMPT

	SUBTTL	XRAY (Set, remove and display traps - ST, RT, DT)


::	ISIS traps rewritten with an added capability of definable
::	(NTRAP) number of setable traps.
:: NOTE:  ISIS traps require 3 halfwords to be overwritten at the
::        patch location as compared to the solo's 2 halfwords and the
::        current condition codes are trashed. (ie don't trap a JE or JN
::        instruction and make sure that no one jumps to any of the three
::        halfwords after the trap). Also, no check is made to
::        make sure a valid instruction is being trapped.  ###sdw
::        Also, ISIS traps must remove write protection because they
::        cannot know whether the trapped routine had write protection.
::        (write protection has to be removed in order to restore the
::        instruction).   ###sdw

::*********************************************************************
::
::	COMMAND:	SETTRP:	ST (ISIS)
::	FUNCTION:	SETS A TRAP AT A PARTICULAR LOCATION
::
::*********************************************************************

SETTRP	CLHI    R2,8      		:test for 2 args
	JGFS    SETTR1    		:if only 2 then give count of 0
	LIS     R1,0      		:repeat count will be 0
	ST      R1,VALUE1+8,XD  	:by acting as if 0 was typed
SETTR1  L       R1,VALUE1,XD    	:get address to trap
	lr	r2,r1			:find the segment
	ni	r2,@(segsiz-1)
	CI	R2,seg1  		:trap seg 1?
	JEFS	settr3			:could trap some of seg D?
       if	1-swtchr
	CI	R2,seg1+segsiz 		:trap second segment of code?
	JEFS	settr3
       ei	:1-swtchr
	CI	R2,segd			:trap seg D?
	JN	COMERR    		:could trap some of seg D?
settr3	lr	r3,r1			:move address for chkmac
	jal	r9,chkmac
	 j	chkma1			:print out error if bad address
	LHI     R3,4*(NTRAP-1)  	:word index to trap addresses
SETTR2  C       R1,TRPADR,R3,   	:address already trapped?
	JE      COMERR
	SIS     R3,4      		:check all traps
	JGEBS   SETTR2
	L       R2,VALUE1+4,XD  	:trap number
	CLHI    R2,NTRAP  		:less than the maximum number of traps
	JGE     COMERR    		:(NTRAP=2 then traps numbers are 0 1)
	SLLS    R2,2      		:trap number as a FW index
	L       R3,TRPSAV,R2,R2 	:where we save the overwritten ininstr
	JN      COMERR    		:instruction already there so error
	L       R0,0,R1   		:get instr to trap on
	ST      R1,TRPADR,R2,   	:save location of trap
	ST      R0,TRPSAV,R2,R2 	:TRPSAV is 2 words
	LHL     R0,4,R1   		:get the 3rd halfword
	STH     R0,TRPSAV+4,R2,R2       :save the instruction
	LHI     R0,4300   		:the J instruction
	STH     R0,0,R1
	L       R0,TRPINX,R2    	:where the jump should jump
	AI      R0,40000000     	:the RX3 bit
	ST      R0,2,R1   		:put where the jump (trap) handler is
	L       R0,VALUE1+8,XD  	:what was the count?
	NHI     R0,7FFF   		:max trap count
	SRLS    R2,1      		:R2 is back to HW index
	STH     R0,TRPCNT,R2,
	ST      XD,TRPXD,R2,R2  	:store the xray user for this trap
	J       XRCRLF    		:done with this

::*********************************************************************
::
::	COMMAND:	REMTRP:	RT (ISIS)
::	FUNCTION:	REMOVES THE TRAP
::
::*********************************************************************

REMTRP	SIS     R2,4      		:index into values
REMTR1  L       R1,VALUE1,XD,R2 	:trap number to remove
	JL      COMERR
	CLHI    R1,NTRAP  		:make sure a valid trap number
	JGE     COMERR
	JAL     R4,REMTR3 		:subroutine which removes traps
	SIS     R2,4      		:next value
	JGE     REMTR1
	J       XRCRLF    		:done with the XRAY RT command

:  REMTR0 is entry from xray zap logic (on R9) to clear all traps for this
:  zapped user.

REMTR0  LHI     R1,NTRAP-1		:remove all traps
REMTR9  JAL     R4,REMTR3 		:try to remove this trap
	SIS     R1,1
	JGEBS   REMTR9
	JR      R9

: REMTR3 removes the trap in R1 if the trap belongs to the user (XD).
:routine also must not destroy R2 or R9 and links on R4.

REMTR3  LR      R5,R1
	SLLS    R5,2      		:make R5 a fullword index
	C       XD,TRPXD,R5,    	:trap belong to this user?
	JNR     R4        		:cannot remove someone elses trap
	L       R3,TRPADR,R5,,  	:address of trap
	JLER    R4        		:this trap was not in use
	L       R0,TRPSAV,R5,R5 	:restore the instruction
	ST      R0,0,R3
	LHL     R0,TRPSAV+4,R5,R5       :last halfword of instruciton
	STH     R0,4,R3
	LIS     R0,0      		:clean out the trap
	ST      R0,TRPADR,R5,   	:no address of a trap
	ST      R0,TRPSAV,R5,R5 	:no instruction is saved
	                  		:leave other info in case of bug
	JR      R4        		:trap removed


::*********************************************************************
::
::	ROUTINE:	TRAPIS:	(ISIS)
::	FUNCTION:	WHERE THE TRAP IS SPRUNG
::
::*********************************************************************

Q       EQ      0
	RE      NTRAP
TRPI|Q| STM     R0,TRPREG+40*Q,,
	LHI     R0,Q
	J       TRAPIS
Q       EQ      Q+1
	ER

TRPINX  WS      0       :table for each trap number
Q       EQ      0
	RE      NTRAP
	WC      TRPI|Q|
Q       EQ      Q+1
	ER

TRAPIS	SBT     R0,TRPFLG,,
	LR      R12,R0  	:let R12 keep track of trap number
	LR      R13,R12 	:R13 is going to be 4*trap
	SLLS    R13,2
	L       R0,FASTC,,
	ST      R0,TRPTIM,R13,  :save time of trap spring
	LHI     R0,1F-PXRAY     :sched xray to display trap
	SBT     R0,SQUEUE
	L       R1,TRPXD,R13,   :and schedule the xray owner of trap
	LHL     R1,XUSLTN,R1    :the xray user number
	SBT     R1,XQUEM	:sched the user that gets trap info
	JAL     R11,XWRITE      :remove write protection
	L       R1,TRPADR,R13,  :get the address of the trap
	L       R0,TRPSAV,R13,R13 :get 1st 4 bytes of instruction
	ST      R0,0,R1 	:restore it
	LHL     R0,TRPSAV+4,R13,R13 :get last two bytes of instruction
	STH     R0,4,R1 	:restore it
	ST      R1,TRPPSW+4,,   :save where we are to return to
	SLLS    R13,4   	:get displacement into saved regs
	LM      R0,TRPREG,R13,  :restore regs
	UPSW    TRPPSW,,	:return to the instruction

::*********************************************************************
::
::	ROUTINE:	TRPDOR:	(ISIS)
::	FUNCTION:	DISPLAYS THE TRAP
::
::*********************************************************************

TRPDOR  JFFOH   R4,TRPDO1 		:R4 is TRPFLG which is which trap
	J       COMERR    		:can never get here but just in case
TRPDO1
	SLLS    R5,1      		:is HW index for trap
	C       XD,TRPXD,R5,R5  	:check if trap belongs to this user
	JN      XLOOP0    		:nope but handle this screwup too
	LA	R2,ASCTRP,,     	:the TRAP message
	JAL	R7,TYPASC		:HEADER
	LR      R3,R5     		:get 2*trap number
	SRLS    R3,1      		:make it trap number
	RBT     R3,TRPFLG,,     	:no longer dis trap have output pending
	JAL     R9,TYPHW  		:output trap number
	L       R3,TRPADR,R5,R5 	:output trap address
	JAL     R9,TYPFW
	L       R3,TRPTIM,R5,R5 	:output time it sprung
	JAL     R9,TYPFW
	LHL     R3,TRPCNT,R5,   	:count of springs left
	JAL     R9,TYPHW  		:tell them how many left
	LR      R6,R5                   
	SLLS    R6,5      		:make 40 byte index
	LIS     R11,2     		:two lines of 8 FWs
TRPDO4  LIS     R10,8     		:the 8 FWs
	JAL     R7,TYPCRL
TRPDO5  L       R3,TRPREG,R6,   	:get a FW
	JAL     R9,TYPFW
	AIS     R6,4      		:move up the pointer
	SIS     R10,1
	JGBS    TRPDO5    		:still within line
	SIS     R11,1     		:how many lines
	JG      TRPDO4
	LHL     R0,TRPCNT,R5,   	:how many times to reset trap
	JG      TRPDO6    		:go if must reset trap
	LIS     R0,0
	ST      R0,TRPADR,R5,R5 	:no more trap address
	SLLS    R5,1
	ST      R0,TRPSAV,R5,R5 	:no more saved instruction
	J       XRCRLF    		:finished with trap

TRPDO6  SIS     R0,1
	STH     R0,TRPCNT,R5,   	:reduce count by one
	L       R1,TRPADR,R5,R5 	:get address of instruction
	LHI     R2,4300   		:get back trap
	STH     R2,0,R1   		:restore instruction
	L       R2,TRPINX,R5,R5 	:last 2 bytes of instr
	AI      R2,40000000
	ST      R2,2,R1
	JAL	R7,TYPCRL
	J       XRCRLF

::*********************************************************************
::
::	COMMAND:	DISTRP:	DT (ISIS)
::	FUNCTION:	DISPLAY CURRENT TRAP LOCATION
::
::*********************************************************************

DISTRP	LHI     R12,2*(NTRAP-1) 	:all traps
DISTR1  L       R11,TRPADR,R12,R12      :address of trap
	JE      DISTR2    		:not in use so skip
	LR      R3,R12    		:get trap number
	SRLS    R3,1      		:make back to real number
	JAL     R9,TYPHW
	LR      R3,R11    		:get back trap address
	JAL     R9,TYPFW
	LHL     R3,TRPCNT,R12,  	:number of times it will be reset
	JAL     R9,TYPHW
	JAL     R7,TYPCRL 		:finish the line
DISTR2  SIS     R12,2     		:decrement the count
	JGE     DISTR1
	J       XRCRLF

	SUBTTL	XRAY (Miscellaneous - XG,GP,NR,RB,WB,BZ,BG,NI)

::*********************************************************************
::
::	COMMAND:	XGGMOD
:	XG
::	FUNCTION:	DISPLAY, MODIFY, ADD OR DELETE XRAY GOODGUY ENTRIES
::	INPUT:		GG =DISPLAY,  GG A =ADD, GG # M =MODIFY, GG # D =DELETE
::
::*********************************************************************

	NOLIST
XGGDS1	SC	/"0D"0AXRAY GOODGUY LIST"0D"0A/
XGGDS2	SC	/"0D"0ANO.   PRIV  OVER         TARGET               NAME/
XGGDS3	SC	/"0D"0A----  ----  ----  ------------------------  -----------  "0D"0A/
XGGDS4	SC	/"0D"0A"0AENTER NEW PRIVILEGE AND OVERRIDE - /
XGGDS5	SC	/"0D"0AENTER UP TO 12(D) CHARS OF USERNAME"0D"0A/
XGGDS6	SC	/"0D"0AXRAY GOODGUY LIST ALREADY FULL"0D"0A/
XGGDS7	SC	/"0D"0A"0AENTER NEW TARGET - /
XGGDS8  SC      /(XRAY)              /
XGGDSA  SC      /(DLine Engin Load)  /
xggdsb	sc	/"0d"0ANEW OVERRIDE -/
	LIST
XGGDST  WC      XGGDS8,XGGDS8,XGGDSA,XGGDS8 :target value to targ name  ###sdw

XGGMOD	LR	R2,R2			:ZERO ARGS?
	JE	XGGM01			:YES
	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
       if	xggpgg
	thi	r13,4			:the modify XGG priv
	JE	xpwerr			:NO, TELL HER SO
       else	:can't change list, but have to let them change override
	jge	comerr			:force superpriv
       ei	:xggpgg
	LR	R3,R3			:ENTRY NUMBER = 0?
	JE	COMERR			:YES, NOT VALID
	CLHI	R3,XGGLEN/XGGSIZ	:WITHIN GGLIST TABLE RANGE?	###wjl
	JG	COMERR			:NO 
	LHI	R0,XGGSIZ		:GET GGLIST CELL SIZE
	SIS	R3,1			:MAKE ENTRIES BEGIN AT 1
	lis	r2,0
	MR	R2,R0			:FORM GGLIST INDEX (R2 HAS 0 ALREADY)
       if	xggpgg
	CLHI	R1,ASCP			:USER CLOSE WITH "P" (x50)
	JE	XGGDEL			:YES, DELETE ENTRY
	CLHI	R1,ASCM			:USER CLOSE WITH "M" (x4D)
	JE	XGGMDD			:YES, MODIFY ENTRY
       ei	:xggpgg
	clhi	r1,asco			:change override
	je	xggmdo
	J	COMERR			:NOT CLOSED WITH P OR M
XGGM01
       if	xggpgg
	CLHI	R1,ASCI			:USER CLOSE WITH "I" (x49)
	JE	XGGADD			:YES, ADD ENTRY
       ei	:xggpgg
	clhi	r1,asccr		:force legal syntax
	jn	comerr

XGGDSP	JAL	R8,AUDLOG		:note display of list in audit log 8/93
	LA	R2,XGGDS1		:TYPE OUT DISPLAY HEADER
	JAL	R7,TYPhdr
	LA	R2,XGGDS2
	JAL	R7,TYPhdr
	LA	R2,XGGDS3
	JAL	R7,TYPhdr
	LIS	R11,0			:INIT GGLIST INDEX
XGGDP1	LB	R3,XRAYGG+XGGNAM,R11,	:CHECK FOR ANY ENTRY HERE	###wjl
	JE	XGGDP2			:NO ENTRY, TRY NEXT GGLIST INDEX

	LIS	R2,0
	LR	R3,R11			:COMPUTE ENTRY NUMBER FROM GGLIST INDEX
	LHI	R0,XGGSIZ		:BY DIVIDING BY GGLIST CELL SIZE
	DR	R2,R0
	AIS	R3,1
	JAL	R9,TYPHW

	LB	R3,XRAYGG+XGGPRV,R11,	:GET USERS PRIVILEGE CAPABILITY	###wjl
	JAL	R9,TYPHW		:DISPLAY FOLLOWED BY 2 SPACES
	LB	R3,XRAYGG+XGGOVR,R11,	:GET USERS OVERRIDE CAPABLILTY	###wjl
	JAL	R9,TYPHW		:AND DISPLAY

	L	R3,XRAYGG+XGGTARG,R11,	:get user's target address	###wjl
	JGEFS   XGGM03    		:alfred debugger is not inthst  ###sdw
	LIS     R3,4      		:target value
	J       XGGM08    		:display value                  ###sdw
XGGM03	CLI	R3,INTXRY		:xray??				###wjl
	JNFS	XGGM02			:no				###wjl
	LIS	R3,0			:yes				###wjl
	JFS	XGGM08			:				###wjl
XGGM02	CLI	R3,INTIIX		:iixray??			###wjl
	JNFS	XGGM04			:no				###wjl
	LIS	R3,1			:yes				###wjl
	JFS	XGGM08			:				###wjl
XGGM04	CLI	R3,INTDWL		:dload??			###wjl
	JNFS	XGGM06			:no				###wjl
	LIS	R3,2			:yes				###wjl
	JFS	XGGM08			:				###wjl
XGGM06	LIS	R3,3			:assume sload...		###wjl
XGGM08  LR      R10,R3    		:save value                     ###sdw
	JAL	R9,TYPHW		:display TARGet			###wjl
	SLLS    R10,2     		:get index for name of target   ###sdw
	L       R2,XGGDST,R10   	:get name of target             ###sdw
	JAL     R7,TYPASC 		:                               ###sdw

	LA	R2,XRAYGG+XGGNAM-1,R11,	:DISPLAY USERNAME		###wjl
	LIS	R0,0C			:12(D) CHARACTERS
	JAL	R7,TYPAS1
	JAL	R7,TYPCRL		:CR/LF AND CHECK NEXT GGLIST ENTRY
XGGDP2	AHI	R11,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R11,XGGLEN		:DONE?				###wjl
	JL	XGGDP1			:NO, DISPLAY SOME MORE ENTRIES
	J	XPRMPT			:YES, EXIT

       if	xggpgg
XGGDEL	lr	r10,r3
	jal	r9,fggaud
	LIS	R0,0			:CLEAR OUT
	STH	R0,XRAYGG+XGGPRV,R10,	:BYTE OF PRIV, BYTE OF OVERRIDE	###wjl
	ST	R0,XRAYGG+XGGTARG,R10,	:fw target address		###wjl
	ST	R0,XRAYGG+XGGNAM,R10,	:3 FW OF USERNAME		###wjl
	ST	R0,XRAYGG+XGGNAM+4,R10,	:IN				###wjl
	ST	R0,XRAYGG+XGGNAM+8,R10,	:XRAY GOODGUY LIST		###wjl
	J	XPRMPT			:AND EXIT
       ei	:xggpgg

:	alter override
xggmdo	LR	R11,R3			:SAVE GGLIST INDEX
	la	r2,xggdsb
	jal	r7,typasc
	jal	r9,rdargs
	 j	comer3			:error in args
	 j	xprmpt			:null line, just exit
	sis	r2,4
	jn	comer3
	STB	R3,XRAYGG+XGGOVR,R11,	:REPLACE OVERRIDE CAPABILITY	###wjl
	j	xprmpt			:and exit


:	Modify Xray GoodGuy list.  Only possible if at least one username
:	has privilege 4.  Fixed bug and now a command that attempts to
:	modify an empty entry is not valid.			###10/04/93
       if	xggpgg
XGGMDD	L	R0,XRAYGG+XGGNAM,R3,	:get start of USERNAME
	JE	COMER3			:modifying empty entry is not valid
	LR	R11,R3			:SAVE GGLIST INDEX
	jal	r9,fggaud
	LA	R2,XGGDS4		:PROMPT FOR PRIV, OVERRIDE
	JAL	R7,TYPASC
	JAL	R9,RDARGS		:GET PRIV, OVERRIDE
	 j	comer3			:error in args
	 j	xprmpt			:null line, just exit
	CLHI	R2,8			:TWO ARGS?
	JN	COMER3			:NO
	STB	R3,XRAYGG+XGGOVR,R11,	:REPLACE OVERRIDE CAPABILITY	###wjl
	LH	R3,VALUE1+2,XD		:GET FIRST ARGUMENT (PRIV)
	JGEFS	XGGMD8
	LIS	R3,0			:LOW LIMIT TO 0
XGGMD8	CLHI	R3,0002			:HIGH LIMIT TO 2
	JLEFS	XGGMD7
	LIS	R3,2
XGGMD7	STB	R3,XRAYGG+XGGPRV,R11,	:REPLACE PRIVILEGE CAPABILITY	###wjl

	LA	R2,XGGDS7		:prompt for target		###wjl
	JAL	R7,TYPASC		:				###wjl
	JAL	R9,RDARGS		:get target			###wjl
	 j	comer3			:error in args
	 j	xprmpt			:null line, just exit
	CLHI	R2,4			:one arg?			###wjl
	JN	XGGM10			:no, error, default xray address###wjl
	CLHI	R3,0			:xray?				###wjl
	JNFS	XGGM12			:no				###wjl
XGGM10	LA	R3,INTXRY,,		:yes				###wjl
	Jfs	XGGM18			:				###wjl
XGGM12	CLHI	R3,2			:dload?				###wjl
	JNbs	XGGM10			:no				###wjl
	LA	R3,INTDWL,,		:yes				###wjl

XGGM18	ST	R3,XRAYGG+XGGTARG,R11,	:replace target address		###wjl

	J	XPRMPT			:EXIT

XGGADD	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
	JGE	xpwerr			:NO, TELL HER SO
	jal	r9,fggaud
	LIS	R11,0			:INIT XRAY GGLIST INDEX
XGGAD1	LB	R3,XRAYGG+XGGNAM,R11,	:CHECK FOR NULL IN BYTE 1 OF UNAME#wjl
	JEFS	XGGAD2			:NULL ENTRY FOUND
	AHI	R11,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R11,XGGLEN		:END OF GGLIST			###wjl
	JLBS	XGGAD1			:NO, KEEP LOOKING FOR EMPTY ENTRY
	LA	R2,XGGDS6		:INFORM HER OF NO GGLIST SPACE
	JAL	R7,TYPASC
	J	XPRMPT			:AND EXIT

XGGAD2	LA	R2,XGGDS5		:PROMPT FOR USERNAME
	JAL	R7,TYPASC
	LA      R0,INTXRY,,     	:no target will cause a crash and##sdw
	ST      R0,XRAYGG+XGGTAR,R11,   :user can abort XG before target stuff
	jal	r9,rdtext
	 j	comer3
	 j	xggad2
	LIS	R14,0			:COUNT USERNAME CHARACTERS
	lb	r13,argpos,xd		:get char
XGGAD4	lb	r1,value1+4,r13,xd
	ais	r13,1
	NHI	R1,ASC7BT		:strip high order bit
	CLHI	R1,40			:blanks, numbers don't get masked
	JlEFS	XGGAD9			:non alpha char
	NHI	R1,ASCUC		:ENSURE UPPERCASE(x0DF)
XGGAD9	CLHI	R1,ASCCR		:CR (x0D)?
	JEFS	XGGAD3			:YES
	STB	R1,XRAYGG+XGGNAM,R11,R14	:STORE CHAR INTO GGLIST	###wjl
	AIS	R14,1			:BUMP CHAR COUNT
	CLHI	R14,0C			:UP TO 12(D) YET?
	JL	XGGAD4			:NO, GET NEXT CHARACTER
XGGAD3	LR	R3,R11			:GET GGLIST INDEX FOR XGGMDD
	J	XGGMDD			:AND GET PRIV AND OVERRIDE

       ei	:xggpgg

:	subroutine to audit the cmd.  links on r9
:


fggaud	stm	r0,xregsv,xd
	jal	r8,audlog		:put into the audit log
	lhl	r5,xcmdip,xd		:get cmd in progress
	lhl	r0,xcmstr+comtbl,r5,	:get string of the cmd
	exhr	r0,r0			:move to hi hw
	LHL	R8,XUNAME,XD		:GET USER'S INDEX INTO GGLIST
	L	R5,XRAYGG+XGGNAM+2,R8,	:GET CHARS 3,4,5,6 OF USERNAME
	ST	R5,CRYSBF		:FOR CRYPTO MESSAGE
	LHL	R5,XRAYGG+XGGNAM,R8,	:AND COMBINE
	ar	r0,r5			:WITH CHARS 1,2 OF USERNAME
	JAL	R8,CRYPTO,,		:R0 = cmd^10 +two chars of uname
	HC	CRYE54			:TYPE = COMMAND AUDIT
	lm	r0,xregsv,xd
	jr	 r9

::*********************************************************************
::
::	COMMAND:	GETPWR:	GP
::	FUNCTION:	GET POWER
::
::*********************************************************************

GETPWR	LHL	R10,EKOTYP,XD
	LCS	R0,1
	STH	R0,EKOTYP,XD
	JAL	R9,RDARGS,,
	 j	comerr
	 j	comerr
	STH	R10,EKOTYP,XD
	SIS	R2,8			:2 ARGUMENTS
	JN	COMERR
	c       r3,hst0.p 		:have a match
	jn      comer3
	LHL	R0,VALUE1+2,XD
	NHI	R0,1
	JN	GETPW3			:###TZ

	CI	XD,TTYXD		:TTY?
	if	t2gate			:Q.gateway slot
	jnfs	getpw1			:Y.allow tty/ddt all priv
	lcs	r1,1
	j	getpw0			:save it
	else
	JE	COMER3			:N.NOT PRIV, THIS COMMAND NOT ALLOWED
	ei	:t2gate
getpw1	LHL	R9,XUNAME,XD		:GET USER'S INDEX INTO XRAY GGLIST
	LB	R0,XRAYGG+XGGPRV,R9,	:AND GET USER'S PRIVILEGE CAPABILITY
	JE	COMER3			:NOT PRIV, THIS COMMAND NOT ALLOWED
	SIS	R0,1			:IS CAPABILITY 1?
	JEFS	GETPW2			:YES, MAKE NORMAL PRIV
	lhi	r1,8000			:default to super priv
	thi	r0,4			:modify GG list priv?
	jefs	getpw0
	ohi	r1,4			:
	JFS	GETPW0
GETPW2	LIS	R1,0			:FLAG NORMAL PRIVILEGE
	JFS	GETPW0

GETPW3	LIS	R1,1			:return to no priv
	
GETPW0	STH	R1,XUINTH+2,XD
	J	XPRMPT,,

hst0.p  bc      0         		:save it in decimal form
	ra      0a
q1      eq      10000
q2      eq      hst0
	re      3
q3      eq      (q2/(q1*10))
q2      eq      q2-(q3*q1*10)
q4      eq      (q2/q1)
q2      eq      q2-(q4*q1)
q1      eq      q1/100
	bc      q3^4+q4
	er
	ra      0
	hs      0


::*********************************************************************
::
::	COMMAND:	XRDBUF:	RB
::	FUNCTION:	READS THE CONTENTS OF A BUFFER
::
::*********************************************************************

XRDBUF	LR	R2,R3			:LAST ARG IS BUFFER NUMBER
	JL      COMERR  		:ILLEGAL
	NHI	R2,-4			:STRIP SPPEED BITS IN CASE
	ci      r2,lbufn
	jg      comerr
	JAL	R8,CBCCT,,		:CHAR COUNT
	LR	R1,R1
	JE	XPRMPT,,		:BUFFER EMPTY
	LR	R10,R1			:SAVE COUNT
	LIS	R11,0F			:CHAR COUNT ON LINE
	JAL	R8,PCIS,,		:START THINGS OFF
XRDBU1	LR	R12,R2			:SAVE BUFFER NUMBER
	LR	R14,R3			:AND POINTER
	LR	R3,R1
	JAL	R9,TYPBYT
	SIS	R10,1
	JE	XRDBF4			:char count depleted--wrap it up
	SIS	R11,1
	JGEFS	XRDBF2			:zero means end of line--crlf
	JAL	R7,TYPCRL
	LIS	R11,0F
XRDBF2	LR	R2,R12			:restore buffer number
	LR	R3,R14			:restore peek pointer
	JAL	R8,PCI,,
	J	XRDBU1
XRDBF4  J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XWRBUF:	WB
::	FUNCTION:	Write ASCII into buffer
::	FORMAT:		WB <buff#> <data in hex> (up to seven bytes)
::
::*********************************************************************

XWRBUF	LR	R10,R2			:SAVE ARGUMENT COUNT
	LHL	R2,VALUE1+2,XD		:BUFFER NUMBER WAS 1ST ARG	###jhl
	nhi     r2,-4
	ci      r2,lbufn
	jg      comerr
	CLHI	R2,4	
	JlE	COMERR			:SAME GOES FOR BUFFER 4

	CLI     XD,TTYXD  		:tty user?
	JN      XWRBU4    		:nope
	SVC     KIO,8     		:is background running?
	J       DLYEN4    		:make command work when not running
	LA      R8,XWRBU7 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	J       XRCRLF
XWRBU4  JAL     R8,XWRBU8 		:just call subroutine
	J       XRCRLF    		:and done

XWRBU7  ST      R8,XDDTSV+4*R8  	:save link so get it back when LM
	LM      R0,XDDTSV 		:get back XDDT's regs
XWRBU8  ST      R8,XWRBS1 		:store link register

	LIS	R11,3			:INDEX INTO ARG LIST		###jhl
XWRBU1	SIS	R10,4			:DECREMENT ARG COUNT
	JGFS    XWRBU2    		:more to do
	L       R8,XWRBS1 		:get link
	JR      R8        		:and done

XWRBU2	AIS	R11,4			:ADVANCE INDEX
	LB	R1,VALUE1,XD,R11	:GET NEXT BYTE			###jhl
	JAL	R8,WCI,,		:AND WRITE IN
	JBS	XWRBU1			:LOOP BACK TILL DONE

::*********************************************************************
::
::	COMMAND:	XBRZAP:	BZ
::	FUNCTION:	SETS BIT IN BORZAP ARRAY CORRESPONDING TO THE
::			NEIGHBOR NUMBER ARGUMENT
::
::*********************************************************************

XBRZAP	L	R3,VALUE1,XD		:LOAD NODE NUMBER		###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX			###SHM
	LR	R1,R3			:STORE IN R1 FOR XFNDLK		###SHM
	JAL	R9,XFNDLK		:FIND LINK NUMBER
	SKIPAD(COMERR)			:immediate return, NOT THERE	###wjl
	LHL	KN,XKNSAV,XD		:+4 return, RECOVER LINK#
:	borzap inverted by sdw
	rBT	KN,BORZAP		:SET THE ZAP BIT
	J	XPRMPT,,		:AND RETURN

::*********************************************************************
::
::	COMMAND:	XBGLST:	BG
::	FUNCTION:	MAKES CHANGES TO, AND DISPLAYS, THE BAD-GUY LIST
::	FORMAT: 	BG <NODE1>...<NODE7> [R OR I]
::			R REMOVES FROM LIST, I INCLUDES INTO LIST
::			IF NO ARGS, JUST DISPLAY BAD GUY LIST
::
::*********************************************************************

XBGLST	LR	R10,R2			:SAVE ARG COUNT
	JE	XBGSHO			:NO ARGS, JUST DISPLAY
	LH	R3,XPOWER,XD		:IF CHANGING, MUST HAVE POWER	###OAS
	JG	XPWERR			:NOPE, NOT AUTHORIZED		###OAS
	CLHI	R1,ASCR			:WAS LAST ARG A 'R'?
	JE	XBGRMV			:YES, REMOVE FROM LIST
	CLHI	R1,ASCI			:WAS LAST ARG AN 'I'?
	JN	COMERR			:BAD ARGUMENT
	jal	r9,fggaud
XBGLS1  L	R3,VALUE1-4,R10,XD	:GET NODE NUMBER           ###SHM
	TI	R3,88888888		:SEE IF VALID OCTAL	   ###SHM
	JN	XBGLS4			:NON-OCTAL, CHECK NEXT ARG	###OAS
	JAL	R9,OCTHXR		:GO HEX
	LR	R1,R3

	LHI	R5,(BGLSIZ-1)*2
XBGLS2	LH	R0,BGLIST,R5
	JEFS	XBGLS3
	CR	R1,R0			:SEE IF THIS IS DUPLICATE	###OAS
	JEFS	XBGLS4			:DUPLICATE, CHECK NEXT ARG	###OAS
	SIS	R5,2			:THIS ENTRY IN USE		###OAS
	JGBS	XBGLS2			:CHECK NEXT ENTRY		###OAS
	J	XBGSHO			:NO ENTRIES, EXIT		###OAS

XBGLS3	STH	R1,BGLIST,R5		:MAKE ENTRY			###OAS
XBGLS4	SIS	R10,4			:DECREMENT ARGUMENT COUNT	###OAS
	JG	XBGLS1			:LOOK AT NEXT ARG		###OAS
	J	XBGSHO			:NO MORE ARGS, DISPLAY		###OAS

XBGRMV	jal	r9,fggaud
xbgrm1	L	R3,VALUE1-4,R10,XD	:GET NODE NUMBER         ###SHM
	JAL	R9,OCTHXR
	LR	R1,R3

	LIS	R0,0
	LHI	R5,(BGLSIZ-1)*2
XBGS20	CLH	R1,BGLIST,R5
	JNFS	XBGS10			:.+6
	STH	R0,BGLIST,R5
XBGS10	SIS	R5,2
	JGEBS	XBGS20			:.-0C
	SIS	R10,4			:DECREMENT ARG COUNT
	JG	XBGRM1			:MORE ARGS

XBGSHO	JAL	R8,AUDLOG		:note display of list in audit log 8/93
	JAL	R7,TYPCRL
	LI	R10,BGLIST
	LI	R11,BGLSIZ		:DISPLAY THE LIST
XBGSH1	LHL	R3,0,R10		:GET AN ENTRY
	JEFS	XBGSH2			:NO ENTRY
	JAL	R9,TYP5o		:type node number
XBGSH2	AIS	R10,2			:ADVANCE POINTE
	SIS	R11,1			:DECREMENT COUNT
	JGBS	XBGSH1			:CONTINUE TYPING
	J	XRCRLF,,


::*********************************************************************
::
::	COMMAND:	XNID:	NI				###wjl
::	FUNCTION:	Allow nodes from two different networks to be
::			connected in an emergency situation.
::	FORMAT:		NI <line #> <desired NETID>
::
::*********************************************************************
:	NETWORKS AS OF 7/20/88

	net(TYMNET,1)
	net(BUBBNET,2)
	net(TRWNET,$A 3)
	net(DECNET,$A 4)
	net(ITALNET,$A 5)
	net(SWEDNET,$A 6)
	net(NETHERNET,$A 7)
	net(SUNNET,$A 8)
	net(SWISSNET$A 9)
	net(UCCPAC,$A 10)
	net(XEROXNET,$A 11)
	net(BOFANET,$A 12)
	net(VANET,$A 13)
	net(CHASENET,$A 14)
	net(CODAN,$A 15)
	net(BPNET,$A 16)
	net(DUNET,$A 17)
	net(LENET,$A 18)
	net(AVISO,$A 19)
	net(DIALOG,$A 20)
	net(MGT,$A 21)
	net(STAGENET,$A 22)
	net(GEONET,$A 23)
	net(ALASCOM,$A 24)
	net(CASNET,$A 25)
	net(EXXON,$A 26)
	net(INSNET,$A 27)
	net(HSBCNET,$A 28)
	net(FIRNNET,$A 29)
	net(DOLNET,$A 30)
	net(CTS,$A 31)
	net(SWBNET,$A 32)
	net(ITALCABLE,$A 34)
	net(TELEVERKET,$A 36)
	net(PHILIPS,$A 37)
	net(UKLAB,$A 38)
	net(EASTNETLAB,$A 39)
	net(DATAPAC,$A 40)
	net(TRAINING,$A 41)
	net(LENG,$A 42)
	net(SLIGOS,$A 43)
	net(WESTREGLAB,$A 44)
	net(REPAIRDEPOT,$A 45)
	net(WESTPUB,$A 46)
	net(WYNET,$A 47)
	net(HGNET,$A 48)
	net(MDISINET,$A 49)
	net(NISNET,$A 50)
	net(BABYLON,$A 52)
	net(ANZNET,$A 53)
	net(FTS2000,$A 54)
	net(CONNNET,$A 55)
	net(NTSNET,$A 56)
	net(MERCURYNET,$A 57)
	net(DEVNET,$A 58)
	net(WTSLAB,$A 63)
	net(TELERATE,$A 64)
	NET(MARUZEN,$A 67)
	net(TESTNET,$A 99)

	if      1-netdok	:if didn't find a known netid
	remark%%%       NETID is ;
 number $a netid ; remark d.  This NETID is unknown.
	remark%%        Please make sure this NETID is correct.%%%
mnetid  macro[ ac /Unknown/ ]
       ei       :not a known netid.



XNID	lr	r2,r2
	je	xnid30
	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
	JGE	xpwerr			:NO, TELL HER SO
	LH	R3,VALUE1+2,XD		:first argument is line number
	JAL	R9,DECHEX		:convert to hex
					:J to DHXBAD for bad radix
	CLHI	R3,NLINES-1		:check for valid line number
	JG	COMERR
	LR	LN,R3			:
	LH	R3,VALUE1+6,XD		:2nd arg is NETID
	JAL	R9,DECHEX		:convert to hex
					:J to DHXBAD for bad radix
	STH	R3,LNETID,LN,LN		:store NETID 

	CLI     XD,TTYXD  		:tty user?
	JN      XNID04    		:nope
	LA      R8,XNID07 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	Jfs	xnid28
XNID04  JAL     R8,XNID08 		:just call subroutine

xnid28	jal	r9,fggaud
:	entry for just display
xnid30  la      r2,xnidh0 		:get address of header
	jal     r7,typasc 		:print it
	lhi     r3,netid
	jal     r9,typhwd
	la      r2,xnidh1
	jal     r7,typasc
	lis     r5,0      		:line number
xnid33  lr      r10,r5    		:last line number displayed
	lh      r6,lnetid,r5,r5 	:last netid displayed
	lr      r3,r5
	jal     r9,typbyd  		:print line #
xnid36  clh     r6,lnetid+2,r5,r5       :netid of next line
	jnfs    xnid50
	ais     r5,1
	clhi    r5,nlines
	jlbs    xnid36    		:see how many match
	sis     r5,1      		:let display discover this is last line
xnid50  cr      r5,r10    		:a range of just one line
	jnfs    xnid53
	jal     r7,typ8sp
	j       xnid56
xnid53  lhi     r1,ascdsh 		:print '-'
	jal     r13,xryout,,
	jal     r7,typ2sp
	lr      r3,r5     		:high end of range
	jal     r9,typbyd,,
	jal     r7,typ1sp
xnid56  jal     r7,typ8sp
	lr      r3,r6     		:print the netid
	jal     r9,typhwd,,
	jal     r7,typcrl 		:new line
	ais     r5,1      		:see if at end
	clhi    r5,nlines
	jl      xnid33    		:do remaining lines
	j       xrcrlf,,  		:otherwise done

xnidh0  sc      /"8d"8aAssembled in NETID: /
xnidh1  bc      0
	ac      /(decimal)  /
q       eq      .         		:limit network name to 10d bytes
	mnetid
	if      .-q-0a    		:if more than 10 bytes
	org     q+0a
	re .-q-0a ; bc 0 ; er   	:clear excess
	org     q+0a
	ei                		:handling of overwrite
	ac      /'s NETID."8d"8a  LINES           NETID (in decimal)"8d"8a/
q       eq      .
	org     xnidh1
	bc      q-xnidh1-1		:length (not includind length field)
	org     q         		:restore pc
	hs      0

XNID07  ST      R8,XDDTSV+4*R8  	:save link
	LM      R0,XDDTSV 		:get back XDDT's regs
XNID08  ST      R8,XNIDS1 		:save link register

	LHI	R0,NR.XID
	STH	R0,SUPMBF		:indicate XRAY NETID change in HW0
	OHI	LN,8000			:avoid escapes
	STH	LN,SUPMBF+2		:include line# in HW1
	OHI	R3,8000
	STH	R3,SUPMBF+4		:include NETID in HW2
	JAL	R10,SUP12,,		:send msg to Sup and CRYPTO Logs

	L       R8,XNIDS1
	JR      R8        		:done

	SUBTTL	XRAY (Channel status - QC)

::*********************************************************************
::
::	COMMAND:	QRYCHN:	QC
::	FUNCTION:	QUERY CHANNEL STATUS
::	INPUT:		START ABS CHAN NUMBER, END CHAN, (U ACTIVE ONLY)
::
::*********************************************************************

QRYCHN	SHI	R1,ASCU			:DID USER CLOSE WITH A 'U'(x55)	###OAS
	LR	R12,R1			:SAVE FOR LATER STUDY		###OAS
	SIS	R2,4			:ONE ARGUMENT			###OAS
	JE	QRYCH1			:YES				###OAS
	CLHI	R3,ENDZFL		:CHECK LAST CHANNEL NO.		###OAS
	JGE	COMERR			:TOO BIG			###OAS
	LR	R14,R3
	L	R3,VALUE1,XD		:BEGIN CHANNEL NUMBER		###OAS
	CLHI	R3,ENDZFL		:CHECK				###OAS
	JGE	COMERR			:TOO BIG			###OAS
	SR	R14,R3			:COUNT = END CHAN#-START CHAN#
	AIS	R14,1			:+1				###OAS
	JL	COMERR			:START CHAN > END CHAN		###OAS
	LR	CHN,R3			:CHN = START CHANNEL NO.	###OAS
	JFS	QRYCH2			:START DISPLAYING		###OAS

QRYCH1	CLHI	R3,ENDZFL		:DO RANGE CHECK ON CHANNEL NUMBER
	JGE	COMERR			:TOO BIG
	LIS	R14,1			:ONLY DISPLAY ONE CHANNEL	###OAS
	LR	CHN,R3			:CHN = START CHANNEL NO.	###OAS

:	Top of DISPLAY LOOP of CHNs
QRYCH2	LR	R12,R12			:DISP ONLY CHANS WITH BF<>0	###OAS
	JN	QRYCH3			:NO, DISP ALL CHANNELS REQUESTED###OAS
	TBT	CHN,ACP,,		:IS CHANNEL ACTIVE		###OAS
	JN	QRYCH5			:CHAN NOT ACTIVE, DON'T DISPLAY	###OAS

QRYCH3	LA	R2,QRYMS0
	JAL	R7,TYPhdr		:HEADER
	LR	R3,CHN			:TYPE CHANNEL NUMBER		###OAS
	JAL	R9,TYPHW
	JAL	R8,CHNLNK		:GET LINK
	SKIPAD(QRYCH0)			:(immed) NEIGHBOR NOT FOUND	###wjl
	SKIPAD(QRYCH4)			:(+4) INTERNAL, GET NODE NUMBER	###wjl
QRYCH8	JAL	R9,HEXOCT		:(+8) CONVERT NEIGHBOR TO OCT	###wjl
QRYCH9  JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE #	###SHM
	LHL	R3,IOTAB,CHN,CHN	:DESTINATION BUFFER
	LR	R10,R3			:SAVE IT
	NHI	R3,3			:ISOLATE SPEED BITS
	JAL	R9,TYPBYT		:AND DISPLAY THEM
	NHI	R10,-4			:STRIP SPEED BITS
	LHL	R3,BF,R10,		:TYPE TERMINATION CHANNEL
	JAL	R9,TYPHW
	JAL	R7,TYP2SP
	LR	R3,R10
	JAL	R9,TYPHW		:TYPE DESTINATION BUFFER
	JAL	R7,TYP2SP
	XHI	R3,4
	JAL	R9,TYPHW		:TYPE SOURCE BUFFER
	XHI	R10,4
	L	R3,BB,R10,		:BB FLAG
	JAL	R9,TYPFW
	L	R3,BE,R10,		:BE FLAG
	JAL	R9,TYPFW
	LHL	R3,BF,R10,		:AND BF
	JAL	R9,TYPHW
	LR	R2,R10
	JAL	R8,CBCCT,,
	LR	R3,R1			:GET BYTE COUNT
	JAL	R9,TYPHW
	LR	R11,R10
	SRLS	R11,1
	NHI	R11,-4			:1/2 BUFFER INDEX FOR BUFTIM
	L	R3,SLOWC,,
	S	R3,BUFTIM,R11,		:CIRCUIT TIME
	JAL	R9,TYPFW

	IF	REBILD
	clhi	chn,lnkzfl		:is this end a termination
	jlfs	xqryr0			:yes
	xhi	r10,4			:display rebuild info in correct
					:polarity
	lhl	r1,bf,r10,		:is other end a term?
	clhi	r1,lnkzfl
	jge	QRYCH5			:done as neither end has rebuild stuff
xqryr0	LA	R2,QRYMS1		:have info on circuit dest
	thi	r10,4			:if eq 4 mod 8 then dest
	jn	xqryr1
	LA	R2,QRYMS4		:have info on circuit orig
XQRYR1	JAL	R7,TYPhdr		:REBUILD-TYPE HEADER
	LI	R3,HBUFN,R11		:DISPLAY HISTORY BUFFER INDEX
	JAL	R9,TYPHW
	L	R3,HSEQN+HBUFN,R11,
	JAL	R9,TYPFW		:DISPLAY CURRENT HISTORY BUFFER SEQN
	lr	r11,r10
	XHI	R11,4
	L	R3,XSEQN,R11,		:DISPLAY CURRENT TRANSMITTED SEQUENCE#
	JAL	R9,TYPFW
	XHI	R11,4
	L	R3,VSEQN,R11,
	JAL	R9,TYPFW
	LA	R2,QRYMS2		:ASSUME REBUILD ON
	SRLS	R11,3
	TBT	R11,CRQBSY
	JNFS	XQRYR3
	LA	R2,QRYMS3
XQRYR3	JAL	R7,TYPASC
	slls	r11,2
	l	r3,rinvc+hbufn,r11,	:get invoice number
	jal	r9,typfw
	lhl	r3,rbase+hbufn,r11,	:dest or orignode 
	nhi	r3,7fff			:knock off high bit
	jal	r9,typ5o
	lhl	r3,rhostn+hbufn,r11,	:dest host or orig port
	nhi	r3,7fff
	la	r9,typhw		:if orig then orig chn
	thi	r10,4			:if eq 4 mod 8 then dest
	jefs	XQRYR4
	la	r9,typ5dd		:if dest then is host (dec
XQRYR4	jalr	r9,r9
	lhl	r3,rnflag+hbufn,r11,	:needle flags
	jal	r9,typhw
	lhl	r3,rhbsz+hbufn,r11,	:size of data
	jal	r9,typhw
	EI	:REBILD
:	Bottom of DISPLAY LOOP of CHNs

QRYCH5	AIS	CHN,1			:INCREMENT CHANNEL INDEX	###OAS
	SIS	R14,1			:DECREMENT CHANNEL COUNT	###OAS
	JG	QRYCH2			:MORE TO DO			###OAS

	J	XRCRLF,,		:DONE

QRYCH0	LCS	R3,2			:NEIGHBOR NOT FOUND		###wjl
	J	QRYCH9			:continue			###wjl
QRYCH4	LHI	R3,MACHNM		:INTERNAL, GET NODE NUMBER	###wjl
	J	QRYCH8			:continue			###wjl

	NOLIST
QRYMS0	SC	/"0D"0A"0D"0ACHAN  LINK   SP  O-CHN  O-BUF   S-BUF     BB       BE     BF   COUNT SEC(HEX)"0D"0A/
QRYMS2	SC	/   ON    /
QRYMS3	SC	/  OFF    /
QRYMS1	SC	/"0D"0A"0AH-BUF   HSEQN    XSEQN    VSEQN   REBUILD INVOICE  D-NOD D-HST RFLAG RHBSZ"0d"0a/
QRYMS4	SC	/"0D"0A"0AH-BUF   HSEQN    XSEQN    VSEQN   REBUILD INVOICE  O-NOD O-CHN  RFLAG RHBSZ"0d"0a/

	LIST

	SUBTTL	XRAY (Symbol commands - SA, RS, WS)

::*********************************************************************
::
::	COMMAND:	DISADR:	SA
::	FUNCTION:	Display Symbol Address
::
::*********************************************************************

DISADR	JAL	R10,RDSYMB		:read ASCII into VALUE1
	JAL	R10,SYMVAL		:look for it in symbol table
	SKIPAD(COMER1)			:(immed) found no match		###wjl
	JAL	R7,TYPCRL		:(+4) found a match--show on next line
	JAL	R7,TYPLF
	JAL	R9,TYPFW		:output the fullword value
	JAL	R7,TYPCRL		:look pretty
	J	XPRMPT,,		:and skedaddle...

::*********************************************************************
::
::	COMMANDS:	READS:/WRITES:	RS/WS
::	FUNCTION:	Read/write symbolic
::
::*********************************************************************

READS	LI	R1,TYPE			:Read comes here		###wjl
	ST	R1,RWADDR,,		:				###wjl
	JFS	RDWRIT

WRITES	LI	R1,WRITE		:Write comes here		###wjl
	ST	R1,RWADDR,,		:				###wjl
RDWRIT	jal	r10,rdsymb
	JAL	R10,SYMVAL
	SKIPAD(COMER1)			:(immed) NO MATCH		###wjl
	ST	R3,VALUE1,XD		:(+4) STORE THE SYMBOL VALUE
	jal	r8,eatwsp		:eat white space
	lr	r0,r0			:reached end of line?
	JGEfs	RDWRI1			:NO
RDWRI0	LIS	R0,0
	ST	R0,VALUE1+4,XD		:ZERO SECOND ARG
	LIS	R0,4
	STH	R0,ARGCT,XD
	J	RDWRI2

COMER1	J	COMERR,,		:Whenever it needs		###al

RDWRI1	LIS	R2,8			:two args to type or write
	STH	R2,ARGCT,XD
	lb	r13,argpos,xd
	jal	r8,rdexp
	stb	r13,argpos,xd
	ST	R3,VALUE1+4,XD		:store length typed by user
RDWRI2	JAL	R7,TYPCRL
	L	R1,RWADDR,,		:get TYPE or WRITE

	LH	R7,XPOWER,XD		:HAVE POWER?			###TZ
	JLER	R1			:YES, GO AHEAD			###TZ

:	if trying to TYPE or WRITE without power, must be one of following
:	symbols: CRYDIS, REBDIS
	lis	r7,8			:two args
	sth	r7,argct,xd		:force second arg to be looked at
	LIS	R7,2			:ALLOW ONLY 2 BYTES TO BE WRITTEN
	ST	R7,VALUE1+4,XD		:AS SO
	L	R7,VALUE1,XD		:GET THE WRITE ADDRESS
	CI	R7,CRYDIS
	JER	R1			:				###wjl
	CI	R7,REBDIS
	JER	R1			:				###wjl
	J	xpwerr,,		:NONE OF THE ABOVE, SECURITY VIOLATION

	SUBTTL	XRAY (Channel commands - AC, TC, TD, TE, TA)

::*********************************************************************
::
::	COMMAND:	XACHAN:	AC
::	FUNCTION:	DISPLAY ACTIVE CHANNELS
::	INPUT:		ABS CHAN NUMBER, RANGE
::	###OAS
::*********************************************************************

XACHAN	CLHI	R3,ENDZFL		:LAST ARG (RANGE) VALID
	JGE	xtlerr			:NO
	LR	R3,R3			:RANGE = 0?
	JE	xtlerr			:YES, ERROR
	LR	R14,R3			:OKAY, SAVE RANGE
	L	R3,VALUE1,XD		:GET FIRST ARG (START CHAN)
	CLHI	R3,ENDZFL		:START CHAN VALID
	JGE	xtlerr			:NO
	LR	CHN,R3			:SAVE START CHANNEL
	AR	R14,CHN			:COMPUTE END CHANNEL
	SIS	R14,1
	CLHI	R14,ENDZFL		:TRUNCATE END CHANNEL?
	JLFS	XACHN1			:NO
	LHI	R14,ENDZFL		:YES

XACHN1	LIS	R12,0C			:12 HW'S PER LINE
	JAL	R7,TYPCRL
XACHN2	TBT	CHN,ACP,,		:CHANNEL ACTIVE?
	JNFS	XACHN3			:NO, DON'T DISPLAY
	LR	R3,CHN			:YES, DISPLAY CHANNEL NUMBER
	JAL	R9,TYPHW
	SIS	R12,1			:COUNT THIS ITEM ON THIS LINE
XACHN3	AIS	CHN,1			:BUMP CHANNEL NO.
	CR	CHN,R14			:UPPER LIMIT YET?
	JG	XRCRLF,,		:YES
	LR	R12,R12			:NOT DONE, CHECK FOR NEXT LINE
	JE	XACHN1			:LINE FULL, USE NEXT LINE
	J	XACHN2			:NOT FULL, CHECK FOR NEXT ACTIVE CHAN

::*********************************************************************
::
::	COMMAND:	XCHTRC:	TC
::	FUNCTION:	SET CHANNEL DATA TRACE
::	INPUT:		ARG 2 =	START/END TRACE SELECT
::			ARG 1 =	ABS CHANNEL NO
::
::*********************************************************************

XCHTRC	LR	R2,R2
	JE	XCHTR2
	SIS	R2,8
	JN	xtlerr
	LHL	R1,VALUE1+2,XD		:ABS CHANNEL TO TRACE
	CLHI	R1,ENDZFL		:LARGEST ALLOWABLE CHANNEL
	JG	xtlerr			:TOO BIG
	LR	R3,R3			:0=> END TRACE, 1=> START TRACE
	JN	XCHTR1
	RBT	R1,TRCHAN,,
	J	XCHTR2
XCHTR1	SIS	R3,1
	JN 	xtlerr
	SBT	R1,TRCHAN,,
XCHTR2	LIS	R10,0
	lis	r6,0c
XCHTR4	LHL	R12,TRCHAN,R10,
XCHTR6	JFFOH	R12,XCHTR3
	AIS	R10,2
	CLHI	R10,ENDZFL/8
	JLbs	XCHTR4
	J	XRCRLF,,

XCHTR3	XH	R12,HMSK,R13,R13
	LR	R3,R10
	SLLS	R3,3
	AR	R3,R13
	JAL	R9,TYPHW
	sis	r6,1
	Jge	XCHTR6
	lis	r6,0c
	jal	r7,typcrl
	j	xchtr6

::*********************************************************************
::
::	COMMANDS:	TRCDAT:/TRCDES:/TRCASC:	TD, TE, TA
::	FUNCTION:	DISPLAY DATA FROM THE CHANNEL TRACE BUFFERS
::
::*********************************************************************

:	0-1f unprintable, 5c is our escape and 7f unprintable
ascprt	hc	0,0,0ffff,0ffff,0ffff,0fff7,0ffff,0fffe
	hc	0,0,0ffff,0ffff,0ffff,0fff7,0ffff,0fffe
TRCMS0	SC	?"0D"0AI/O  CHN  TIME"0D"0A"0A?	:###wjl
TRCMS1	SC	/OUT /
TRCMS2	SC	/IN  /
TRCMS3	SC	/GMT /

:	SAME AS TRCDAT, BUT DISPLAYS IN ASCII
TRCASC	lis	r0,0			:TA wants to see escapes
	LHI	R4,$A44			:INDICATE ASCII DISPLAY MODE
	JFS	TRCD00

:	SAME AS TRCDAT, BUT DISPLAYS ESCAPES
TRCDES	LIS	R4,0			:INDICATE HEX DISPLAY MODE
	LIS	R0,0			:INDICATE DISPLAY ESCAPES
	JFS	TRCD00

TRCDAT	LIS	R4,0			:INDICATE HEX DISPLAY MODE
	LIS	R0,1			:INDICATE SUPPRESS ESCAPES
:	trcd00 is the common entry for TD, TA, TE.  Please note trcd0j which
:	is entry for TS (sup port trace).
trcd00
       if	supwat
	lis	r11,0
	sth	r11,xdjsat,xd		:not a TS (sup port trace)
trcd0j
       ei	:supwat
	lhl     r8,xusltn,xd    	:get xray user number
	rbt     r8,xtdasc 		:init to not ascii (one of the hexmodes
	lr      r4,r4     		:0 if one of hex modes
	jefs    trcd10
	sbt     r8,xtdasc
trcd10  ais     r4,0c     		:hex line size is 12 bytes, ascii is 56
	sth     r4,xtdlnz,r8,r8 	:save line size
	rbt     r8,xtdesc 		:see if want to display escaping
	lr      r0,r0     		:0 if they want to see escs
	jnfs    trcd14
	sbt     r8,xtdesc
trcd14  lis     r11,0     		:for display mode -1 is output only
	                  		:-2 is input only, 0 is both
	sth     r11,xtdmsn,r8,r8	:# of msgs to display
	clhi	r1,asccr		:cr?
	je	trcd25			:don't check for various chars
	shi     r1,asci   		:I option?
	jnfs	trcd18
	lcs     r11,2     		:input only is -2 in r11
trcd18  sis     r1,ascO-ascI    	:out only option?
	jnfs    trcd20
	lcs     r11,1     		:output only is -1 in r11
trcd20	sbt	r8,xtdato 		:init doing continous display
	sis	r1,ascY-ascO    	:Y is continous display
	jefs    trcd45    		:doing continous
	ais	r1,ascY-ascN		:was it N?
	jn	xtlerr
trcd25	rbt     r8,xtdato
	lhi     r1,0308   		:turn off tracing log
	sth     r1,chrtrc,,     	:(jr r8 at start of trace log)
	sth     r1,xtdflg,,     	:remember that tracind disabled
trcd45
	if	autrac
	lh	r5,autrun		:trace running?
	je	trcd46
	lhl	r5,xuname,xd
	lb	r5,xraygg+xggprv,r5,	:have priv to see it?
	sis	r5,1
	jgefs	trcd46			:yes
	rbt	r8,xtdato
	la      r2,trcms0 		:no, and they have no right to know
	jal     r7,typHDR		:the td header	
	j	trcd92			:and exit
	ei	:autrac
trcd46	lhl     r5,trrix  		:get current pointer
	lr	r12,r3    		:r3 has # of msgs user wants to see
	je      trcd90    		:show no msgs if they want no msgs
	la      r2,trcms0 		:header
	jal     r7,typHDR
	lr      r7,r11    		:save whether doing input or output
	lis     r11,0     		:count all msgs in ring
	lis     r13,0     		:set counter of msgs to 0
	lcs     r10,1     		:if found any and where it is in ring
trcd46  sis     r5,8      		:hunt msgs from newest to oldest
	nhi     r5,trrsiz-1
	clh     r5,trrix  		:back to the start?
	jefs    trcd48
	jal     r9,trctst 		:is it a msg
	j       trcd46    		:null return is a no msg
	lr      r10,r5    		:save location of oldest found so far
	lr      r7,r7     		:they want all msgs?
	jefs    trcd47    		:yes
	cr      r7,r4     		:want this msg?
	jefs    trcd47    		:like this msg
	ais     r12,1     		:have to scan this many to display
	                  		:desired number of msgs.
trcd47  ais     r13,1     		:another msg found
	cr      r13,r12   		:equal to number user wanted?
	jn      trcd46
trcd48  lr      r11,r7    		:restore input/output masking
	lr      r5,r10    		:any found and where is oldest msg
	jl      trcd90    		:none found exit
trcd49  sth     r13,xtdmsn,r8,r8	:max number of msgs to process

:       here to print a msg
trcd50  jal     r10,trcsup		:if a msg then do pwd masking
	j       trcd82    		:if user requested only IN or OUT msgs
	la      r2,trcms1 		:output msg? (r4 = -1)
	ais     r4,1      		:so, is it output msg
	jefs    trcd51
	la      r2,trcms2 		:input msg (I)
	ais	r4,1
	jefs    trcd51
	la      r2,trcms3 		:GMT message
trcd51  jal     r7,typasc
       if	supwat
	lh	r0,xdjsat,xd		:TS sup port mode?
	jefs	trcdj1
	ahi	r3,400-2-supzfl
	jal	r9,typ5o,,		:print it as node number
	jfs	trcdj2
trcdj1
       ei	:supwat
	JAL	R9,TYPHW		:AND CHANNEL NUMBER
trcdj2	LHL	R3,TRRING+4,R5,,
	jal     r9,typhw
	ais     r5,8
	nhi     r5,trrsiz-1     	:to start of data

:       here to print a line (or as many as it takes) of the data
trcd53  lhl     r12,xtdlnz,r8,r8	:get line size
:       here to print next byte
trcd54  lb      r3,trring,r5,   	:get the byte
	jnfs    trcd55    		:it is 00
	tbt     r8,xtdesc 		:escaping desired?
	jnfs    trcd55    		:want to see the escaping
	ais     r5,1      		:get escaped byte
	nhi     r5,trrsiz-1
	lb      r3,trring,r5,   	:get it
	sis     r6,1      		:one fewer byte to display
trcd55  tbt     r6,trmask,xd     	:can we show this byte?
	jn      trcd70    		:don't show it
	tbt     r8,xtdasc 		:printing in ascii?
	je	trcd57
:       doing display in ascii
	stb	r8,xslast,xd		:don't suppress spaces in TA
	tbt	r3,ascprt		:easily printable?
	jnfs	trcd56
	sis	r12,2			:taking two more for printout
	lhi     r1,5c	 		:print a '\' for escape
	jal	r13,xryout
	LR	R1,R3			:ENTRY POINT FOR TYPNBY ROUTINE
	SRLS	R1,4			:SLIDE FIRST HEX DIGIT TO LO NIBBLE
	JAL	R7,TYPHEX		:	AND DISPLAY
	LR	R1,R3
	JAL	R7,TYPHEX		:DISPLAY SECOND HEX DIGIT
	jfs	trcd58
trcd56  lr	r1,r3
	jal	r13,xryout		:print it
	jfs	trcd58
:       doing display in hex
trcd57  jal	r9,typbyt 		:print a byte of hex
:       printed something out
trcd58  sis	r12,1     		:printed something on the line
:       read a byte from the ring
trcd70  ais	r5,1
	nhi	r5,trrsiz-1
	sis	r6,1      		:this msg is closer to being done
	jlefs	trcd80
	lr	r12,r12   		:this line finished?
	jg	trcd54    		:nope do next byte
	jal	r7,typcrl
	jal	r7,typ8sp 		:format the next line
	jal	r7,typ8sp
	j	trcd53

:	here to do next msg
trcd80	jal	r7,typcrl
	jfs	trcd85
:	next msg when previous wasn't displayed
trcd82	lr	r6,r6			:did we find a msg?
	jlefs	trcd84			:no msg,try next boundary
	clhi	r6,$a 121 		:too big to have been a packet
	jgfs	trcd84
	ar	r5,r6			:add len of undisplayed msg
trcd84	ais	r5,8			:skip over the header stuff

:	here whether previous msg was displayed or not
trcd85	ais	r5,7			:next msg starts on a dw boundary
	nhi	r5,trrsiz-8
	lhl	r0,xtdmsn,r8,r8 	:count of msgs displayed
	sis	r0,1
	sth	r0,xtdmsn,r8,r8
	jl	trcd90			:printed all msgs we wanted to
	clh	r5,trrix		:have printed all msgs?
	jn	trcd50
:	here when either ring pointers matched up or printed as much as wanted
trcd90	tbt	r8,xtdato		:do they want continous display?
	jn	trcd94
trcd92	lhi	r1,0208			:nop
	sth	r1,chrtrc,,
	ts	xtdflg,,		:tracing has been restored
       if	supwat
	lh	r0,xdjsat,xd		:doing from DJ cmd?
	je	xprmpt,,
	lhl	r0,xdjsav,xd
	rbt	r0,trchan,,		:stop tracing
       ei	:supwat
	j	xprmpt,,		:done
:	auto display exit, handle if msgs still left to display or no msgs
:	were displayed.
trcd94	lr	r5,r5			:r5<0 if no msgs to display
	jgefs	trcd95
	lhl	r5,trrix		:ring was empty, so caught up
trcd95	sth	r5,xtdcpt,r8,r8 	:save current position
	clh	r5,trrix		:have we caught up?
	jefs	trcd97
	ts	xryrun			:go again to do any forgot msgs
	sbt	r8,xquem,,		:sched this user
trcd97	lhi	r1,3e			:the '>' for a prompt
	jal	r13,xryout
	j	xloop0,,

::*********************************************************************
::
::	SUBROUTINE:	TRCTST:
::	FUNCTION:	DOES RANGE CHECK ON BYTE COUNT AND CHANNEL NUMBER,
::			TESTS BIT IN TRCHAN, AND MASKS THE I/O INDICATOR.
::	CALLING SEQ:	JAL	R9,TRCTST
::	INPUT:		R5 = POINTER TO ENTRY IN TRRING
::			R11= MASK TO SELECT INPUT(-2),OUTPUT(-1),OR ALL(0) MSGS
::	OUTPUT:		R6 = BYTE COUNT
::	RETURNS:	DIRECT RETURN	=>	NOT SATISFACTORY
::			SKIP RETURN	=>	SATISFCTORY
::
::*********************************************************************

TRCTST	LH	R6,TRRING+6,R5,		:PRESUMED BYTE COUNT
	JLE	TRCTXI			:NON-POSITIVE => INVALID, DIRECT RETURN
	CLHI	R6,$A121		:TEST FOR MAXIMUM SIZE
	JG	TRCTXI			:TOO BIG => INVALID, DIRECT RETURN#wjl
	LHL	R3,TRRING+2,R5,		:POSSIBLE CHANNEL
	nhi	r3,7fff			:knock off possible pthru cmdcir mark
	CLHI	R3,ENDZFL		:WITHIN RANGE?
	JG	TRCTXI			:NO,DIRECT RETURN		###wjl
	if	1-autrac
	TBT	R3,TRCHAN,,		:BIT SET?
	JE	TRCTXI			:NO,DIRECT RETURN		###wjl
	ei	:1-autrac
	LH	R4,TRRING,R5,		:I/O INDICATOR
	CR	R4,R11			:MATCH WITH R11?
	JE	4,R9			:YES,SKIP RETURN
	LR	R11,R11			:ALL MESSAGES ENABLED?
	JNfs	TRCTXI			:NO, THIS ISNT A VALID MESSAGE	###wjl
	LR	R2,R4			:YES, VALID MESSAGE IF I/O INDICATOR OK
	Jgfs	trctxi			:legal vals are -1 -2 -3
	AIS	R2,3			:move into positive range
	JgE	4,R9			:YES,SKIP RETURN
TRCTXI	SKIP(0,R9)			:NO, DIRECT RETURN		###wjl

::*********************************************************************
::
::	SUBROUTINE:	TRCSUP:
::	FUNCTION:	TRACE DISPLAY SET-UP
::	CALLING SEQ:	JAL	R10,TRCSUP
::	PRESERVED:	R3, R4, R5, R6, R9, AND R11
::	RETURNS:	IMMEDIATE = NOT PRINTABLE
::			+4	  = FOUND APPARENTLY VALID ENTRY
::
::*********************************************************************

:	CHECK FOR COMMAND CIRCUIT TRACING. IF TRUE, MASK OUT PASSWORDS.
:	THE BIT ARRAY 'TRMASK' HAS A BIT POSITION FOR EACH BYTE OF TRRING.
:	TRCSUP CLEARS THE BIT ARRAY, AND THEN SETS BITS FOR PASSWORD
:	CHARACTERS. TRMASK IS TESTED IN 'TRCD10', AND BYTES ARE NOT
:	OUTPUT FOR SET BITS.
	
TRCSUP	JAL	R9,TRCTST		:TEST FOR PRINTABLE MESSAGE
	SKIPAD(TRCSXI)			:NO - NON-SKIP RETURN		###wjl
	lis	r1,0
	st	r1,trmask,xd		:init msg to printable
	st	r1,trmask+4,xd		:init msg to printable
	st	r1,trmask+8,xd		:init msg to printable
	st	r1,trmask+0c,xd		:init msg to printable

:	IS THIS POSSIBLY A COMMAND CIRCUIT?
	lh	r0,trring,r5,		:only if sent from node unless supe
	jl	trcs60			:if neg then is cmd cir pthru
	CLHI	R3,LEPZFL		:+4 return from TRCTST
	JL	4,R10			:NO - TOO LOW
	CLHI	R3,DISZFL 		:(diszfl for when supe base)
	JGE	4,R10			:not a cmd circuit
	lh	r0,trring,r5,		:only if sent from node unless supe
	clhi	r0,0fffd		:if time no worry
	je	4,r10
       if	super
	ais	r0,1			:output message
       else	:interface machin
	ais	r0,2			:input message
       ei
	je	4,r10

:	SET UP TO SCAN FOR SUP MESSAGES WHICH MAY CONTAIN PASSWORDS. LOOK
:	FOR THE SEQUENCE:
:		MACHNM+8000
:		0E,80+N
:		PORT NUMBER+8000
:		X,X
:		X,X
:	WHERE N IS THE NUMBER OF PASSWORD CHARACTERS X.
:	also check for log II logon msg.
:	8000+MACHNM, 08 80      (NCRM)
:	if it is NCRM then display the first 16d chars (password can't be
:	earlier in msg than that)

TRCS07	LR	R13,R6			:SET R13 AS # OF CHARACTERS TO SCAN
	LHI	R12,TRRSIZ-1		:R12 IS RING WRAP MASK

	LR	R1,R5			:R1 POINTS TO BEGIN OF STRING TO SCAN
	AIS	R1,7
TRCS10	AIS	R1,1			:BEGIN NEW SCAN FOR PASSWORD MESSAGE
	NR	R1,R12
	SIS	R13,1			:DONE?
	JL	4,R10			:YES - GO DISPLAY

	LB	R0,TRRING,R1,
	OHI	R0,80			:make sure the bit is set
	CLHI	R0,(MACHNM+8000)/100
	JNBS	TRCS10			:NO MATCH - TRY NEXT BYTE
	LR	R2,R1			:POTENTIAL SUP MSG W/PASSWORD,PRESRV R1
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	JNFS	TRCS13			:low byte of node # not escaped
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1			:ANOTHER BYTE CHECKED
	LB	R0,TRRING,R2,		:GET ESCAPED CHAR
TRCS13	CLHI	R0,MACHNM&0FF		:OUR NODE NUMBER?
	JN	TRCS10			:NO
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	CLHI	R0,08			:08 (LOG II NCRM)
	JE	TRCS40
	CLHI	R0,0E			:0E MESSAGE TYPE?
	JN	TRCS10			:NO
:	YES - GOT A PASSWORD MESSAGE...
	AIS	R2,2
	NR	R2,R12	
	LB	LRC,TRRING,R2,		:GET CHARACTER COUNT
	NHI	LRC,7F			: AND ISOLATE
	sis	r13,2			:advance count left past port number
	jle	trcs10			:stuff split across messages. oh well
	AIS	R2,2			:ADVANCE INDEX PAST PORT NUMBER
	LR	R1,R2
	AR	R1,LRC			:POINT PAST PASSWORD MSG FOR NEXT SCAN
	NR	R1,R12
TRCS20	SBT	R13,TRMASK,xd		:PREVENT DISPLAY OF PASSWORD CHARACTERS
	sis	r13,1			:next position
	sis	lrc,1			:another char
	JgBS	TRCS20			:NOT YET
	J	TRCS10			:YES - LOOK FOR MORE TO DO

TRCS40	AIS	R2,2			:point past 80 to first byte of len
	NR	R2,R12
	LB	LRC,TRRING,R2,		:get 1st byte of len
	JNFS	TRCS42			:not escaped
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1			:get next char
	LB	LRC,TRRING,R2,		:get escaped char
TRCS42	EXBR	LRC,LRC			:put first byte of len into high byte
	AIS	R2,1
	NR	R2,R12
	LB	R0,TRRING,R2,		:get low byte of len
	JNFS	TRCS45
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,		:get escaped low byte of len
TRCS45	NHI	LRC,300			:max value of high byte
	AR	LRC,R0			:the biggest the msg could ever get
	Sis	R13,3	 		:(2 for len+1 to skip over the 80
					:reduce count of chars to scan
	LR	R1,R2			:point to end of msg
	AR	R1,LRC			:r1 now points to next msg
	NR	R1,R12			:handle wrap
	SHI	LRC,10	 		:no harm in first 10 byte of NCRM
	shi	r13,10			:that much less to mask
	jle	trcs10
TRCS49	SBT	R13,TRMASK,xd	 	:don't display this byte
	sis	r13,1
	jle	trcs10
	SIS	LRC,1
	JGBS	TRCS49			:mask out next byte
	J	TRCS10			:done masking

:	here if this is a cmd cir passthrough.  thus, cannot check node
:	number or direction to see if this is a NCRM or 0E that needs
:	to be suppressed.  Thus, a possible node number is >84, xx for
:	0E msg or >04 if NCRM.  then ncrm is 08 80 and 0E 00 xx (cnt)
:	80-88 (high byte of port)

trcs60	LR	R13,R6			:SET R13 AS # OF CHARACTERS TO SCAN
	LHI	R12,TRRSIZ-1		:R12 IS RING WRAP MASK

	LR	R1,R5			:R1 POINTS TO BEGIN OF STRING TO SCAN
	AIS	R1,7
trcs62	AIS	R1,1			:BEGIN NEW SCAN FOR PASSWORD MESSAGE
	NR	R1,R12
	SIS	R13,1			:DONE?
	JL	4,R10			:YES - GO DISPLAY

:	at start of possible node number
	LB	R0,TRRING,R1,
	clhi	r0,04			:big enough to be start of NCRM?
	JLBS	trcs62			:NO MATCH - TRY NEXT BYTE
	clhi	r0,3f			:too big to be an NCRM node number?
	jle	trcs80			:possible ncrm
	clhi	r0,80+04		:big enough to be start of 0E msg?
	JL	trcs62			:too small, get next
	clhi	r0,80+3f		:too big to be an 0E node number?
	jg	trcs62			:possible 0E
	LR	R2,R1			:POTENTIAL SUP MSG W/PASSWORD,PRESRV R1
	AIS	R2,1			:get low byte of node number
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	JNFS	TRCS64			:low byte of node # not escaped
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1			:ANOTHER BYTE CHECKED
TRCS64	AIS	R2,1			:get possible message type (0E)
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	CLHI	R0,0E			:0E MESSAGE TYPE?
	JN	trcs62			:NO
:	YES - GOT A possible PASSWORD MESSAGE...
	sis	r13,1			:make sure next is escape of the cnt
	ais	r2,1
	nr	r2,r12
	lb	r0,trring,r2,		:this is the escape byte of the cnt
	jn	trcs62			:not one after all
:	GOT A PASSWORD MESSAGE
	AIS	R2,1
	NR	R2,R12	
	LB	LRC,TRRING,R2,		:GET CHARACTER COUNT
	NHI	LRC,7F			: AND ISOLATE
	sis	r13,1			:advance count left past port number
	jle	trcs62			:stuff split across messages. oh well
	AIS	R2,2			:ADVANCE INDEX PAST PORT NUMBER
	LR	R1,R2
	AR	R1,LRC			:POINT PAST PASSWORD MSG FOR NEXT SCAN
	NR	R1,R12
TRCS68	SBT	R13,TRMASK,xd		:PREVENT DISPLAY OF PASSWORD CHARACTERS
	sis	r13,1			:next position
	sis	lrc,1			:another char
	JgBS	TRCS68			:NOT YET
	J	trcs62			:YES - LOOK FOR MORE TO DO

:	possible NCRM
TRCS80	LR	R2,R1			:POTENTIAL SUP MSG W/PASSWORD,PRESRV R1
	AIS	R2,1			:get low byte of node number
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	JNFS	TRCS82			:low byte of node # not escaped
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1			:ANOTHER BYTE CHECKED
TRCS82	AIS	R2,1			:get possible message type (08)
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	CLHI	R0,08			:08 MESSAGE TYPE?
	jn	trcs62
	ais	r2,1			:make sure next is the 80
	sis	r13,1
	nr	r2,r12
	LB	LRC,TRRING,R2,		:get 80 byte of unused
	clhi	r0,80
	jn	trcs62
:	looks very much like an NCRM
	SIS	R13,1			:get next char
	AIS	R2,1			:point past 80 to first byte of len
	NR	R2,R12
	LB	LRC,TRRING,R2,		:get 1st byte of len
	JNFS	TRCS85			:not escaped
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1			:get next char
	LB	LRC,TRRING,R2,		:get escaped char
TRCS85	EXBR	LRC,LRC			:put first byte of len into high byte
	sis	r13,1
	AIS	R2,1
	NR	R2,R12
	LB	R0,TRRING,R2,		:get low byte of len
	JNFS	TRCS87
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,		:get escaped low byte of len
TRCS87	NHI	LRC,300			:max value of high byte
	AR	LRC,R0			:the biggest the msg could ever get
	LR	R1,R2			:point to end of msg
	AR	R1,LRC			:r1 now points to next msg
	NR	R1,R12			:handle wrap
	SHI	LRC,10	 		:no harm in first 10 byte of NCRM
	shi	r13,10			:that much less to mask
	jle	trcs62
TRCS89	SBT	R13,TRMASK,xd	 	:don't display this byte
	sis	r13,1
	jle	trcs62
	SIS	LRC,1
	JGBS	TRCS89			:mask out next byte
	J	trcs62			:done masking

TRCSXI	SKIP(0,R10)			:immediate return		###wjl

	SUBTTL	XRAY (CRYPTO display mode - CD)

::*********************************************************************
::
::	COMMAND:	XCRMOD:	CD
::	FUNCTION:	CD Y TURNS DISPLAY ON
::			CD N TURNS DISPLAY OFF
::
::*********************************************************************

XCRMOD	CLHI	R1,ASCY			:LAST CHAR = 'Y'(x59)?
	JEFS	XCRMO3			:YES, TURN ON
	CLHI	R1,ASCN			:LAST CHAR = 'N'(x4E)?
	JNFS	XCRMO1			:NO, JUST DISPLAY
	LIS	R2,1
XCRMO3	STH	R2,CRYMOD,XD		:MAKE ENTRY
XCRMO1	LA	R2,CRYPON		:PRESUME ON
	LHL	R1,CRYMOD,XD		:VERIFY GUESS
	JEFS	XCRMO2			:RIGHT
	LA	R2,CRYPOF		:WRONG
XCRMO2	JAL	R7,TYPASC		:DISPLAY MODE
	J	XPRMPT,,		:AND RETURN

	NOLIST
CRYPON	SC	/"0D"0A AUTO CRYPTO ON"0D"0A/
CRYPOF	SC	/"0D"0A AUTO CRYPTO OFF"0D"0A/
	LIST

	SUBTTL	XRAY (Conversion routines - HO, OH, HD, DH, OD, DO)

::*********************************************************************
::
::	COMMAND:	XHXOCT:	HO
::	FUNCTION:	CONVERT HEX TO OCTAL
::
::*********************************************************************

XHXOCT	NI	R3,0FFFFFF		:STRIP TOP byte
	JAL	R9,HEXOCT
	JAL	R9,TYPFW		:5 DIGIT NODE# NEEDS FW		###AL
:	JAL	R9,TYPHW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XOCHEX:	OH
::	FUNCTION:	CONVERT OCTAL TO HEX
::
::*********************************************************************

XOCHEX	TI	R3,88888888		:CHECK FOR VALID OCTAL
	JN	DHXBAD			:RADIX VIOLATION
	JAL	R9,OCTHXR
	JAL	R9,TYPFW		:		###shm
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XHXDEC:	HD
::	FUNCTION:	HEX TO DECIMAL
::
::*********************************************************************

XHXDEC	JAL	R9,HEXDEC
	JAL	R9,TYPFW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XDCHEX:	DH
::	FUNCTION:	DECIMAL TO HEX
::
::*********************************************************************

XDCHEX	JAL	R9,DECHEX		:convert decimal to hex
					:J to DHXBAD for RADIX VIOLATION###wjl
	JAL	R9,TYPfW		:DISPLAY
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XOCDEC:	OD
::	FUNCTIOPN:	OCTAL TO DECIMAL
::
::*********************************************************************

XOCDEC	TI	R3,88888888		:CHECK FOR VALID OCTAL		###OAS
	JN	DHXBAD			:RADIX VIOLATION		###OAS
	JAL	R9,OCTHXR		:CONVERT TO HEX
	JAL	R9,HEXDEC		:CONVERT HEX TO DECIMAL
	JAL	R9,TYPFW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XDCOCT:	DO
::	FUNCTION:	DECIMAL TO OCTAL
::
::*********************************************************************

XDCOCT	JAL	R9,DECHEX		:CONVERT DECIMAL TO HEX		###OAS
					:J to DHXBAD for BAD RADIX	###OAS
	JAL	R9,HEXOCT		:CONVERT HEX TO OCTAL		###OAS
	JAL	R9,TYPfW
	J	XRCRLF,,

	SUBTTL	XRAY (Miscellaneous - CO, PM)

::*********************************************************************
::
::	COMMAND:	XCROPT:	CO
::	FUNCTION:	SELECTS CRASH RESPONSE
::
::*********************************************************************

XCROPT	LR	R2,R2
	JE	XCROP1			:NO ARGS, DISPLAY CURRENT MODE
	LH	R2,XPOWER,XD		:IF CHANGING, MUST HAVE POWER	###TZ
	JG	XPWERR,,		:NOPE, NOT AUTHORIZED		###TZ
	ti	r3,@303
	jn	xtlerr
	NHI	R3,303
	STH	R3,CRACTN,,
XCROP1	LB	R3,CRACTN,,
	SLLS	R3,3
	LA	R2,XCROPM,R3
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LB	R3,CRACTN+1,,
	SLLS	R3,3
	LA	R2,XCROPM,R3
	JAL	R7,TYPASC
	J	XRCRLF,,
	SLLS	R3,3			:FORM TWO-WORD INDEX
	LA	R2,XCROPM,R3		:GET CURRENT MODE
	JAL	R7,TYPASC
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XRYPFM:	PM
::	FUNCTION:	PERFORMANCE MONITORING ROUTINE FOR USER CHANNELS
::	INPUT:		ACCEPTS A TERMINATING CHANNEL NUMBER
::
::*********************************************************************

:	SENDS 16 XLAXS AND TIMERS TOWARDS THE OTHER END, AND COMPUTES THE
:	AVERAGE ROUND-TRIP DELAY WHEN THE XLAX ACKS AND TIMER ACKS RETURN

	NOLIST
XRYPM1	SC	/"0AROUND TRIP DELAY (MS)   TIMER : /
XRYPM2	SC	/  XLAX : /
XRYPM3	SC	/"0ABAD CHANNEL OR TIMEOUT"0D"0A/
	LIST

XRYPFM	l	r2,xpmciu		:command already in use?
	jn	xcomiu,,		:yes, tell them that
	st	xd,xpmciu
	CLHI	R3,LNKZFL		:R3 IS CHAN NUMBER, CHECK RANGE
	JGE	XRYPFR			:ONLY LEGAL FOR TERMINATING CHANNELS
	LHL	R2,IOTAB,R3,R3		:GET BUFFER NUMBER
	JE	XRYPFR			:ERROR, NO CIRCUIT THERE
	NHI	R2,-4			:STRIP SPEED BITS
	lr	r13,r2
	srls	r13,1
	nhi	r13,-4			:could be either end of circuit
	l	r5,buftim,r13,		:used to tell if circuit reused
	st	r5,xpmnqe		:new cir will have a new time
	LR	R13,R3			:SAVE CHANNEL NUMBER IN R13
	LHL	R5,BF,R2,		:GET CHANNEL ON OUT SIDE
	JAL	R8,CHNLNK		:RETURNS NEIGHBOR ON OUT CHANNEL
	SKIPAD(XRYPFR)			:IMMEDIATE RETURN--NO NEIGHBOR	###wjl
	SKIPAD(XRYPFR)			:+4 RETURN--INTERNAL TERMINATION###wjl
					:+8 RETURN--NEIGHBOR NUMBER IN R3##TZ
	LIS	R10,0			:ACCUMULATOR FOR TIMERS 	###TZ
	LIS	R11,0			:CLEAR R11 (ACCUMULATOR FOR XLAXS) 
	LIS	R14,0F			:DO 16 TIMES
XRYPFL	LIS	R0,0
:	XLAX'S AND TIMERS ARE SENT OUT IN PAIRS	##TZ
	ST	R0,ARRIVX		:CLEAR TIME-OF ARRIVAL CELLS
	ST	R0,ARRIVT		:CLEAR TIME-OF ARRIVAL CELLS

	LHL	R2,IOTAB,R13,R13	:GET BUFFER NUMBER
	JE	XRYPFR			:SOMETHING WRONG, NO CHANNEL
	nhi	r2,-4
	lhl	r0,bf,r2,		:make sure whole circuit exists
	clhi	r0,20
	jl	xrypfr	
	CLHI	R0,LNKLFL		:R0 IS CHAN NUMBER, CHECK RANGE
	JGE	XRYPFR			:LEGAL FOR TERMINATING or link CHANNELS
	lr	r1,r2
	xhi	r1,4
	lhl	r0,bf,r1,		:make sure both directions exist
	clhi	r0,20
	jl	xrypfr	
	CLHI	R0,LNKLFL		:R0 IS CHAN NUMBER, CHECK RANGE
	JGE	XRYPFR			:LEGAL FOR TERMINATING or link CHANNELS
	srls	r1,1
	nhi	r1,-4
	l	r0,xpmnqe		:get time our circuit was built
	c	r0,buftim,r1,		:same as this circuit?
	jn	xrypfr			:no, this is a new circuit
	JAL	R7,XRPF02 		:write xlack/timer

XRYPF2	CLI	XD,TTYXD		:tty user?
	JNFS	XRYPF3			:no, a remote user
	SVC	DISMIS			:wait for it to arrive
	JFS	XRYPF4
XRYPF3	JAL	R0,XRYYLD,,		:AND YIELD TO EXEC LOOP
XRYPF4	L	R9,XREGSV,XD		:RECOVER TIME OF ORIGINAL STARTUP
	L	R3,ARRIVT		:HAS A TIMER ACK RETURNED?
	JNFS	XRYPFA			:YES, GO PROCESS DATA
	L	R3,FASTC,,		:NO, HAVE WE TIMED OUT?
	SR	R3,R9			:COMPUTE DELTA TIME SINCE STARTUP
	CLHI	R3,18C0			:ALLOW APPROX 12 SECONDS PER TRIP###OAS
	JG	XRYPFR			:ERROR, TIMED OUT
	J	XRYPF2			:STILL TICKING, DISMISS AND RETRY
XRYPFA	L	R3,ARRIVX		:WE GOT TIMER ACK,BETTER HAVE XLACK##TZ
	JE	XRYPFR			:SOMETHINGS WRONG		###TZ
	LM	R10,XREGSV+4,XD		:RECOVER REGISTERS
	SR	R3,R9			:GET TRAVEL TIME XLAX
	AR	R11,R3			:ACCUMULATE IN R11
	L	R3,ARRIVT		:TIMER ACK TIME			##TZ
	SR	R3,R9			:TRAVEL TIME TIMER		##TZ
	AR	R10,R3			:ACCUM TIMER TIME IN R10	##TZ
	SIS	R14,1			:DO THIS 16 TIMES
	JGE	XRYPFL			:MORE LEFT

	LA	R2,XRYPM1		:DONE FOR BOTH TIMER AND XLAX
	JAL	R7,TYPhdr		:HEADER
	LHI	R12,$A10
	LR	R2,R10			:GET TIMER (IN R10) TIME	##TZ
	DHR	R2,R12			:AVERAGE AND GO DECIMAL...	##TZ
	JAL	R9,TYPHWD
	LA	R2,XRYPM2		:HEADER
	JAL	R7,TYPhdc
	LR	R2,R11			:GET XLAX TIME (IN R11)
	DHR	R2,R12			:AVERAGE AND GO DECIMAL		##TZ
	JAL	R9,TYPHWD		:DISPLAY
	lis	r0,0
	st	r0,xpmciu		:cmd no longer is use
	J	XRCRLF,,		:RETURN TO LOOP

XRYPFR	LA	R2,XRYPM3
	JAL	R7,TYPASC		:TYPE ERROR MESSAGE OUT
	lis	r0,0
	st	r0,xpmciu		:cmd no longer is use
	J	XRCRLF,,


:	Subroutine to handle writting of XLACK/timer since if xddt then
:	job collision sensitive.
XRPF02	CLI	XD,TTYXD		:tty user?
	JN	XRPF04    		:nope
	LA      R8,XRPF07 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT,, 		:wait until BG finishes task
	JR      R7        		:and return
XRPF04  JAL     R8,XRPF08 		:just call subroutine
	JR      R7        		:and return

XRPF07  ST      R8,XDDTSV+4*R8  	:save link so get it back when LM
	LM      R0,XDDTSV 		:get back XDDT's regs
XRPF08  ST      R8,XRPFS1 		:store link register
	NHI	R2,-4			:STRIP SPEED BITS
	L	R9,FASTC,,		:GET CURRENT TIME

	LIS	R1,3			:FORM '03'
	JAL	R8,WCI,,		:TIMER, WRITE IN '03'
	LHI	R1,TIMER		:AND TIMER
	JAL	R8,WCI,,

	LHI	R1,XLAX			:XLAX, GET XLAX
	JAL	R8,WCD,,		: AND PREFIX IT IN
	LIS	R1,03
	JAL	R8,WCD,,		:PREFIX THE '03'

	STM	R9,XREGSV,XD		:SAVE REGISTERS
	L       R8,XRPFS1 		:get link register
	JR      R8        		:return from collision sensitive code

	SUBTTL	XRAY (UPSW trace option - TR, TT)

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl

::*********************************************************************
::
::	COMMAND:	XTRACE:	TR
::	FUNCTION:	TURNS UPSW TRACER OFF (IF NO ARGUMENTS)
::			OR ON (FOR RANGE ARG1 - ARG2).  IF ARG1=ARG2=0,
::			TRACE IS ON FOR ALL OF MEMORY.
::
::*********************************************************************

XTRACE	LR	R2,R2			:ANY ARGUMENTS?
	JG	XTRAC0			:YES

					:REQUEST TO TURN TRACER OFF
	LH	R1,TRCRRQ,,		:IS TRACER ON?
	JL	XTROFF			:YES, GO TURN IT OFF

	JAL	R7,TYPASI			:TRACER NOT ON...
	SC	/TRACER NOT ON/		:...COMPLAIN
	J	xtlerr

XTRAC0	LH	R1,TRCRRQ,,		:IS TRACER ON?
	JGEfs	XTRON			:NO, GO TURN IT ON

	JAL	R7,TYPASI			:TRACER ALREADY ON...
	SC	/TRACER ALREADY ON/
	J	xtlerr

XTRON
XTRON0	LI	R5,0DFFFE		:DEFAULT UPPER LIMIT
	JFS	XTRON2

					:VALIDATE 2 ARGUMENTS
XTRON1	L	R5,VALUE1+4,XD		:2ND ARGUMENT IS IN R5
XTRON2	L	R3,VALUE1,XD		:GET 1ST ARGUMENT
	CR	R3,R5			:R3 MUST BE < R5
	JL	XTRON3

	JAL	R7,TYPASI			:1ST ARG >= 2ND ARG...
	SC	/RANGE ERROR/		:...COMPLAIN
	J	xtlerr

XTRON3	ST	R3,TRCBEG,,		:SET TRACER LOWER LIMIT
	JAL	R7,TYPASI	
	SC	/TRACER ON FOR RANGE: /
	JAL	R9,TYPFW		:LOWER LIMIT
	LR	R3,R5			:GET UPPER LIMIT TO R3
	ST	R3,TRCEND,,		:SET TRACER UPPER LIMIT
	JAL	R9,TYPFW		:AND TYPE IT

	LHL	R1,EXEPSW+2,,		:GET CURRENT STATE OF TRACER BIT IN PSW
	STH	R1,EXPSSV		:SAVE IT
	LHI	R1,1000			:TURN TRACER ON NEXT EXEC LOOP TOP...
	STH	R1,EXEPSW+2,,		:...AND...
	STH	R1,TRCRRQ,,		:...FORCE TRACER OFF FOR NOW (TRCRRQ>0)
:	CLEAR TRACER TABLE
	LA	R1,TRCTAB,,		:DESTINATION ADDRESS FOR HCLEAR
	LHI	R2,TRTBSZ/2		:HW SIZE OF TRACER TABLE
	JAL	R8,HCLEAR,,		:CLEAR IT
	STH	R0,TRNDEX,,		:SET TRACER INDEX TO 0
	TS	TRCRRQ,,		:TELL TRACER SPECIAL REQUEST
	J	XPRMPT,,		:DONE

:	TURN SPECIAL TRACER OFF
XTROFF	LIS	R3,1			:FORCE TRACER OFF...
	STH	R3,TRCRRQ,,		:... UNCONDITIONALLY
	JAL	R7,TYPASI
	SC	/TRACER INDEX: /	:HEADER INFORMATION
	LHL	R3,TRNDEX,,		:GET THE INDEX
	JAL	R9,TYPHW		:TYPE IT
	JAL	R7,TYPASI
	SC	/RANGE: /		:RANGE
	L	R3,TRCBEG,,		:RANGE LOWER LIMIT
	JAL	R9,TYPFW
	L	R3,TRCEND,,		:UPPER LIMIT
	JAL	R9,TYPFW
	JAL	R7,TYPCRL		:TYPE CR/LF

:	COPY CONTENTS OF TRACER TABLE TO SAVE AREA
	LA	R0,TRCTAB+(TRTBSZ-2),,	:ADDRESS OF LAST SOURCE HW
	LA	R1,TRSTAB+(TRTBSZ-2),,	:ADDRESS OF LAST DESTINATION HW
	LHI	R2,(TRTBSZ/2-1)*10	:AMOUNT TO COPY
	COPY	R0,R2			:COPY IT

:	RESTORE ORIGINAL STATE OF TRACE BIT AND ENABLE NORMAL TRACER
	LIS	R0,0
	STH	R0,TRCRRQ,,		:LET TRACER GO
	LHL	R0,EXPSSV		:GET ORIGINAL STATE OF TRACE BIT
	STH	R0,EXEPSW+2,,		:RESTORE
:	OUTPUT TRACER TABLE
	LIS	R0,8			:SET UP FOR TYPE0
	STH	R0,ARGCT,XD		:ARG COUNT = 2
	LA	R0,TRSTAB,,		:START ADDRESS
	ST	R0,VALUE1,XD		:1ST ARG
	LHI	R0,TRTBSZ		:NO. OF BYTES
	ST	R0,VALUE1+4,XD		:2ND ARGUMENT
	JAL	R12,TYPE0,,		:PRINT OUT THE TRACER TABLE
	J	XPRMPT,,

::*********************************************************************
::
::	COMMAND:	TYPTRC:	TT
::	FUNCTION:	WITH NO ARGUMENT:  IDENTICAL TO R C0800,100
::			WITH 1 ARGUMENT :  TYPES OUT THE LAST N JUMP ADDRESSES
::
::*********************************************************************

TYPTRC	LI	R0,TRSTAB
	LR	R2,R2			:ZERO ARGS?
	JNFS	TYPTR1			:NO
	ST	R0,VALUE1,XD
	LHI	R0,TRTBSZ
	ST	R0,VALUE1+4,XD
	JFS	TYPTR2
TYPTR1	L	R1,VALUE1,XD		:NUMBER OF JUMPS TO DISPLAY
	SLLS	R1,1			:TWO BYTES PER ENTRY
	ST	R1,VALUE1+4,XD		:STORE IN COUNT FIELD
	SR	R0,R1
	AHI	R0,TRTBSZ		:STARTING ADDRESS
	ST	R0,VALUE1,XD
TYPTR2	LIS	R0,8
	STH	R0,ARGCT,XD
	J	TYPE,,

	EI	:DB.TRC


	SUBTTL	XRAY (Miscellaneous - SS, BS)

::*********************************************************************
::
::	COMMAND:	XSIOST:	SS
::	FUNCTION:	DISPLAY SIO LINE STATUS
::
::*********************************************************************

	IF	SILINS
	IF	HMICRO		:display four halfwords for HDLC MICRO
XSIOH1	SC	/"0D"0ALN  MBOARD        REG0            REG1      IDL CRC HDLC  A R I T Rx  TIME OF/
XSIOH2	SC	/"0D"0ANO  NO  PO  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 LIN ERR ABRT  1 C L C OVR INTERUPT"0D"0A/
	ELSE	:ENGINE		:display three halfwords for engine
XSIOH1	SC	/"0D"0ALN  MBOARD        REG0            REG1      IDL CRC HDLC  A R I T TIME OF/
XSIOH2	SC	/"0D"0ANO  NO  PO  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 LIN ERR ABRT  1 C L C INTERUPT"0D"0A/
	EI	:HMICRO

:       the query LU returns SIO status as 04 LN# MB# (ex 04 07 81)
XSIOTA  HS      2                       :for putting the status

XSIOST	clhi	r1,ascm
	je	xsiosm			:look at sio's memory area
	LR	R2,R2			:zero args?
	JNFS	XSIO02			:no
	LHI	R12,SILINS		:counter
	LIS	R14,0			:relative SIO line number
	J	XSIO04
XSIO02	JAL	R9,DECHEX		:convert line number to hex
					:J to DHXBAD for bad radix
xsio03	LR	R14,R3			:save line number
	CLHI	R14,NLINES
	JGE	xtlerr			:too big to be a line number
	SHI	R14,NLINES-SILINS	:compute relative SIO line number
	JL	xtlerr			:to small for SIO line
	SLLS	R14,4			:line number*10x
	LIS	R12,1			:counter
XSIO04	LA	R11,SIOSTT,,		:pointer to SIO status blocks
	LA	R2,XSIOH1
	JAL	R7,TYPhdr		:type header 1
	LA	R2,XSIOH2
	JAL	R7,TYPhdr		:type header 2

XSIOLN	LR	R3,R14
	SRLS	R3,4			:relative SIO line number
	AHI	R3,NLINES-SILINS	:compute absolute line number
	JAL	R9,TYPBYD		:display line number
        lr      r0,r14
        srls    r0,4
        ahi     r0,nlines-silins        :get real LU number
        la      r1,xsiota               :where to put status
        lis     r2,4                    :bytes of room for status
        svc     io,8000,,               :status svc
        j       .+4
	LB      R3,XSIOTA+2             :get mboard address
	JAL     R9,TYPBYT
	LB      R3,XSIOTA+1                     :get line on mboard
	jal     r9,typbyd
	LHL	R3,SS.REG,R11,R14
	LHI	R4,10			:set up number of bits
	JAL	R9,TYPBIT		:display SIO read REGs 0 and 1
	LB	R3,SS.IDL,R11,R14
	JAL	R9,TYPBYT		:display idle line counter
	LB	R3,SS.CRC,R11,R14
	JAL	R9,TYPBYT		:display CRC error counter
	LHL	R3,SS.ABR,R11,R14
	SRLS	R3,4			:isolate HDLC abort counter
	JAL	R9,TYPHW		:display HDLC abort counter
	LHL	R3,SS.ABR,R11,R14
	SLLS	R3,0C			:shift bits 44-47 into position
	LIS	R4,4			:set up number of bits
	JAL	R9,TYPBIT		:display bits 44-47	
	IF	HMICRO			:HDLC MICRO-engine only
	LB	R3,SS.HM1,R11,R14
	JAL	R9,TYPBYT		:display receive overrrun counter
	EI	:HMICRO

	l       r3,0a,r11,r14   	:time of interupt
	jal     r9,typfw

	JAL	R7,TYPCRL		:CR-LF
	AHI	R14,10			:advance line pointer
	SIS	R12,1			:decrement counter
	JG	XSIOLN			:keep displaying
	J	XRCRLF,,		:return

:	option SS M lets user see the sio init ccws, ccws and resets area
xsiosm	li	r10,sopg0		:first init ccw
	lhi	r11,siostt+10*silins-sopg0 :end of status block
	jal	r12,type2,,
	j	xrcrlf,,

	ELSE	:NO SILINS
XSIOST	LA	R2,BADCON,,
	JAL	R7,TYPASC		:TYPE OUT ERROR MESSAGE
	J	XRCRLF,,		:AND RETURN
	EI	:SILINS

::*********************************************************************
::
::	COMMAND:	XBUFLT:	BS
::	FUNCTION:	DISPLAYS HISTOGRAMS OF BUFFERLET USE
::	DATA DISPLAYED REPRESENTS BYTES IN ALLOCATED BUFFERLETS
::	IF TERMINATED WITH 'Z', CLEARS OUT HISTOGRAMS AND MAX COUNTER
::
::*********************************************************************

	NOLIST
	IF	REBILD
XBUFH0	SC	/"0D"0ABUFFER STATUS (BYTES):/
XBUFH3	SC	/"0D"0A            TOTAL    TOTAL   HISTORY  HISTORY   TOTAL/
XBUFH4	SC	/"0D"0A   BUFFERS  IN USE    PEAK    IN USE    PEAK  AVAILABLE  ZAPS"0D"0A  /
	ELSE	:REBILD
XBUFH0	SC	/"0D"0ABUFFER STATUS (BYTES):"0D"0A    TOTAL   IN USE    PEAK   AVAILABLE  ZAPS"0D"0A  /
	EI	:REBILD

XBUFH1	SC	/"0A"0D"0ARANGE	COUNT(HEX)"0A"0D"0A/
	LIST

:	SIX DIFFERENT DISPLAYS ARE POSSIBLE, DEPENDING UPON HOW MANY
:	BUFFERLETS THE NODE IS CONFIGURED FOR. THIS INFORMATION IS
:	CONTAINED IN THE VARIABLE 'ISCALE'

XBUFH2	HS	$A42			:ACTUAL DISPLAY DEFINED IN FIN FOR NAD

XBUFLT	CLHI	R1,ASCZ			:DID USER CLOSE WITH 'Z'(x5A)?
	JE	XBUFLZ			:YES, GO INITIALIZE
	clhi	r1,asccr		:else, must terminate with CR
	jn	comer1
	LA	R2,XBUFH0		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPhdr

	IF	REBILD

	LA	R2,XBUFH3		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPhdr
	LA	R2,XBUFH4		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPhdr


	EI	:REBILD

	LI	R3,NBFLE2		:CONFIGURED NUMBER OF BUFFERLET BYTES
	LR	R10,R3			:SAVE
	JAL	R9,TYPFWD		:TYPE OUT CONFIGURED NUMBER OF BYTES
	L	R3,BFLTSV		:CURRENT COUNT
	SR	R10,R3			:GET NUMBER OF BYTES AVAILABLE
	JAL	R9,TYPFWD		:TYPE NUMBER OF BYTES CURRENTLY IN USE
	L	R3,BFLTMX
	JAL	R9,TYPFWD		:TYPE MAX NUMBER OF BYTES EVER IN USE

	IF	REBILD
	L	R3,HBFTSV		:GET CURRENT HISTORY BUFFER USAGE##OAS
	JAL	R9,TYPFWD
	L	R3,HBFTMX		:GET PEAK HISTORY BUFFER USAGE	###OAS
	JAL	R9,TYPFWD
	EI	:REBILD

	LR	R3,R10
	JAL	R9,TYPFWD		:TYPE NUMBER OF BYTES STORAGE LEFT
	JAL	R7,TYP2SP		:TYPE TWO SPACES
	LHL	R3,BZAPCT		:GET NUMBER OF BUFFER ZAPS TO DATE...
	JAL	R9,TYPHWD		:AND DISPLAY IN DECIMAL
	LA	R2,XBUFH1		:SECOND HEADER
	JAL	R7,TYPhdr
	LIS	R10,0			:DO FOR 'NSTEPS' SAMPLES HISTOGRAM DATA
	LHI	R11,$A(8-1)*10		:FORM STARTING INDEX FOR HEADER
XBUFL2	L	R3,BFLTHG,R10		:READ ONE DATA VALUD
	LA	R2,XBUFH2,R11		:GET APPROPRIATE HEADER
	JAL	R7,TYPhdr		:TYPE TEXT
	JAL	R7,TYP2SP		:TYPE TWO SPACES
	JAL	R9,TYPFW		:AND HEX DATA
	JAL	R7,TYPCRL
	SIS	R11,0A			:GET NEXT HEADER
	AIS	R10,4
	CLHI	R10,(NSTEPS-1)*4	:DO FOR 'NSTEPS' VALUES
	JLE	XBUFL2			:MORE LEFT
	J	XPRMPT,,		:###jhl

XBUFLZ	LIS	R0,0			:CLEAR ALL VALUES
	ST	R0,BFLTMX		:CLEAR TOTAL BUFFER USAGE
	STH	R0,BZAPCT

	IF	REBILD
	ST	R0,HBFTMX		:CLEAR HISTORY PEAK BUFFER USAGE###OAS
	EI	REBILD

	LHI	R10,$A4*7
XBFLE2	ST	R0,BFLTHG,R10
	SIS	R10,4
	JGEBS	XBFLE2
	J	XPRMPT,,		:###jhl

	SUBTTL	XRAY (Dump dispatcher rings - DR, DS)

::*********************************************************************
::
::	COMMANDS:	DRINGS:/DSRNGS:	DR/DS			###wjl
::	FUNCTION:	IRING/ORING DUMP ROUTINE
::	INTERPRETS THE ISIS MESSAGE TYPE AND DUMPS THE CONTENTS IN HEX
::	AND ASCII.  MAKES A GUESS AT THE FIRST MESSAGE IN THE RING.
::	'DR' DUMPS DISPATCHER RINGS, 'DS' DUMPS RINGS SAVED AFTER A CRASH.
::
::*********************************************************************
       IF       1-NCSLOT


::	IRING/ORING TRACE MESSAGES AND TABLES
:	-------------------------------------
SIAASC	AC	/0123456789ABCDEF/
M.I	SC	/I /
M.O	SC	/O /
XDRMS4	SC	/NDL/			:NEEDLE
XDRMS3	SC	/DTA/			:DATA
XDRASC	SC	/  *                */	:ASCII MESSAGE DUMP STORAGE

	BND	2
XDRECH	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDRVL	HC	0082,6000		:VARIABLE LENGTH MESSAGE FLAGS

::	ISIS CONTROL MESSAGES
:	---------------------
	BND	2
XDRICA	SC	/DET/		:DETACH MESSAGE TYPE
	SC	/ZAP/		:DISCONNECT MESSAGE
	SC	/NOS/		:APPLY BACK-PRESSURE (NO SEND)
	SC	/SND/		:RELEASE BACK-PRESSURE (SEND)
	SC	/ICM/		:FLUSH OUTPUT (GOBBLER)
	SC	/BKG/		:FLUSH INPUT (BACK GOBBLER)
	SC	/BLK/		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	SC	/GRY/		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	SC	/EDE/		:ENTER DEFERED ECHO MESSAGE
	SC	/LDE/		:LEAVE DEFERED ECHO MESSAGE
	SC	/ETM/		:ENTER TRANSPARENCY MODE
	SC	/LTM/		:LEAVE TRANSPARENCY MODE
	SC	/GB /		:GREEN BALL
	SC	/RB /		:RED BALL
	SC	/YB /		:YELLOW BALL
	SC	/OB /		:ORANGE BALL
	SC	/BRK/		:BREAK DETECTED
	SC	/HNG/		:HANG UP
	SC	/QTP/		:QUERY TERMINAL PARAMETER
	SC	/STP/		:SET TERMINAL PARAMETER
	SC	/PSN/		:PSEUDO NEEDLE
	SC	/NLC/		:NORMAL LOGON CHAR
	SC	/NLS/		:NORMAL LOGON STATUS
	SC	/LOF/		:LOG ON FAILURE
	SC	/NCC/		:NORMAL CIRCUIT COMPLETE
	SC	/ADA/		:ADDENDUM TO ACCOUNTING
	SC	/SHG/		:SUPER-HANG UP
	SC	/TLM/		:SET TRANSMIT LIMIT
	SC	/EBK/		:END OF BREAK
	SC	/ZAK/		:ZAP ACK
	SC	/EAO/		:ENTER ALTERNATE OUTPUT DEVICE MODE
	SC	/LAO/		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	SC	/ZAR/		:ZAP WITH REASON
	SC	/SIX/		:START INTERFACE INFORMATION EXCHANGE
	SC	/TIX/		:TERMINATE INTERFACE INFORMATION EXCHANGE
	SC	/UUN/		:UUN msg
	SC      /ISN/   	:Log II Needle
	SC      /RCR/   	:Log II logon status
	SC      /ICR/   	:Log II logon data (C4)
	SC      /ASL/   	:Log II assign logon port
	SC      /LGS/   	:Log II logon success
	SC      /***/   	:text when displaying unknown msgs
	          		:last defined msg is C6                 ###sdw

::	ISIS CONTROL MESSAGE LENGTHS
:	----------------------------
	BND	2
XDRILA	BC	3		:DETACH MESSAGE TYPE
	BC	3		:DISCONNECT MESSAGE
	BC	3		:APPLY BACK-PRESSURE (NO SEND)
	BC	3		:RELEASE BACK-PRESSURE (SEND)
	BC	3		:FLUSH OUTPUT (GOBBLER)
	BC	3		:FLUSH INPUT (BACK GOBBLER)
	BC	3		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	BC	3		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	BC	3		:ENTER DEFERED ECHO MESSAGE
	BC	3		:LEAVE DEFERED ECHO MESSAGE
	BC	3		:ENTER TRANSPARENCY MODE
	BC	3		:LEAVE TRANSPARENCY MODE
	BC	3		:GREEN BALL
	BC	3		:RED BALL
	BC	3		:YELLOW BALL
	BC	3		:ORANGE BALL
	BC	3		:BREAK DETECTED
	BC	3		:HANG UP
	BC	4		:QUERY TERMINAL PARAMETER
	BC	5		:SET TERMINAL PARAMETER
	BC	6		:PSEUDO NEEDLE
	BC	3		:NORMAL LOGON CHAR (hide logon char)    ###sdw
	BC	4		:NORMAL LOGON STATUS
	BC	4		:LOG ON FAILURE
	BC	0A		:NORMAL CIRCUIT COMPLETE
	BC	8		:ADDENDUM TO ACCOUNTING
	BC	3		:SUPER-HANG UP
	BC	4		:SET TRANSMIT LIMIT
	BC	3		:END OF BREAK
	BC	3		:ZAP ACK
	BC	3		:ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	3		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	4		:ZAP WITH REASON
	BC	3		:START INTERFACE INFORMATION EXCHANGE
	BC	3		:TERMINATE INTERFACE INFORMATION EXCHANGE
	BC      8 		:UUN msg                                ###sdw
	BC      0 		:Log II Needle (C2)                     ###sdw
	BC      0 		:Log II RCRI (C3)
	BC      0 		:Log II ICRS (C4)
	BC      8 		:Log II ASLP (C5)
	BC      0 		:Log II LGSC (C6)
	          		:all of the log II msgs with len 0 are variable
L.ISCT  EQ      .-XDRILA	:how many valid messages

::	INTRANODE MESSAGES
:	-------------------
	BND	2
XDRICB	SC	/RQR/		:RESTART REQUEST
	SC	/RST/		:RESTART INTERFACE
	SC	/NTO/		:NODE HAS BEEN TAKEN OVER
	SC	/REP/		:REPORT TO SUPERVISOR'S LOG
	SC	/RHS/		:REPORT HOST STATUS (OBSOLETE)
	SC	/RAC/		:REPORT ACCOUNTING
	SC	/TIM/		:GMT TIME
	SC	/RNP/		:REQUEST FOR NORMAL PSEUDO NEEDLE
	SC	/RAP/		:REQUEST AUX PSEUDO-NEEDLE
	SC	/PSR/		:PSEUDO-NEEDLE REJECTED
	SC	/HPA/		:HOST PORT AVAILABILITY
	SC	/HNA/		:HOST NOT ACCEPTABLE
	SC	/RHC/		:REPORT HOST COST
	SC	/NSU/		:NO SUPERVISOR
	SC	/ODN/		:1-DOWN TEXT
	SC	/RAH/		:REPORT ALL HOSTS
	SC	/HSR/		:HOST STATUS REPORT
	SC	/CRM/		:Log II Circuit Request Msg          ###sdw
	SC	/ECR/		:Log II Reject Request Msg          ###sdw
	SC      /***/   	:text for unknown message

::	INTRANODE MESSAGE LENGTHS
:	-------------------------
	BND	2
XDRILB	BC	3		:RESTART REQUEST
	BC	3		:RESTART INTERFACE
	BC	4		:NODE HAS BEEN TAKEN OVER
	BC	9		:REPORT TO SUPERVISOR'S LOG
	BC	0C		:REPORT HOST STATUS (OBSOLETE)
	BC	8		:REPORT ACCOUNTING
	BC	8		:GMT TIME
	BC	0B		:REQUEST FOR NORMAL PSEUDO NEEDLE
	BC	0A		:REQUEST AUX PSEUDO-NEEDLE
	BC	7		:PSEUDO-NEEDLE REJECTED
	BC	0A		:HOST PORT AVAILABILITY
	BC	07		:HOST NOT ACCEPTABLE
	BC	0A		:REPORT HOST COST
	BC	3		:NO SUPERVISOR
	BC	0A		:1-DOWN TEXT
	BC	3		:REPORT ALL HOSTS
	BC	0E		:HOST STATUS REPORT
	BC	4 		:ICRM
	BC      4 		:ECRI
MAXINM  EQ      .-XDRILB

::	UTILITY SUBROUTINE:	XDTPUT
::	OUTPUT A BYTE AS 2 DIGITS
:	-------------------------
:	CALLING SEQ:	JAL	R11,XDTPUT
:	INPUT:		R4  = BYTE TO BE OUTPUT
:			R12 = BYTE COUNTER
:	PRESERVED:	R4,R5
:	DESTROYED:	R0, R1, R2, R4, R7, R13
XDTPUT	LBR	R1,R4			:COPY IT
	LR	R7,R1			:COPY AGAIN
	SRHLS	R1,4			:LEFT NIBBLE
	LB	R1,SIAASC,R1		:CONVERT TO ASCII
	JAL	R13,XRYOUT		:PUT IT OUT
	NHI	R7,0F			:RIGHT NIBBLE
	LB	R1,SIAASC,R7		:CONVERT TO ASCII
	JAL	R13,XRYOUT		:PUT IT OUT
	THI	R13,1			:EVERY OTHER BYTE, PUT OUT EXTRA SPACE
	JER	R11			:IF EVEN
	JAL	R7,TYP1SP		:PUT IT OUT
	JR	R11			:RETURN

::	ENTRY POINTS:	DSRNGS/DRINGS
::	DUMP I/O RINGS
:	--------------
NFMI	EQ	0			:OFFSET TO NEXT FILL MESSAGE INDEX
RING	EQ	4			:OFFSET TO THE RING ITSELF
RR	EQ	0E			:REGISTER FOR ADDRESS OF RING
RS	EQ	3			:REGISTER FOR RING SIZE

:	ENTRY POINT FOR DS COMMAND
DSRNGS	LH	R0,DIRSAV,,		:INITED TO -1, IF NO CRASHES YET
	JL	xtlerr			:RETURN WITH ??
	LA	R1,DIRSAV+DRSZ+2,,	:ADDRESS OF DIRSAVS END TO R1
	LA	R4,DORSAV+DRSZ+2,, 	:ADDRESS OF DORSAVS END TO R4
	JFS	XDR010

:	ENTRY POINT FOR DR COMMAND
DRINGS	LA	R1,DIRING+DRSZ+2,, 	:ADDRESS OF DIRINGS END TO R1
	LA	R4,DORING+DRSZ+2,, 	:ADDRESS OF DORINGS END TO R4
XDR010	LA	R2,IRING+DRSZ+2,,  	:ADDRESS OF DESTINATION END TO R1+1
	LI	R3,10*(DRSZ/2+1)   	:10*(NUMBER OF HW'S -1)
	COPY	R1,R3		   	:COPY IRING TO DATA STORAGE
	LA	R5,ORING+DRSZ+2,,  	:ADDRESS OF DESTINATION END TO R4+1
	LI	R3,10*(DRSZ/2+1)   	:COUNTER FOR COPY INSTRUCTION
	COPY	R4,R3		   	:COPY ORING
XDR020	LA	RR,IRING,,		:HANDLE IRING
	LHI	RS,DRSZ-1		:RING SIZE
	LIS	R7,0			:INIT COUNTER FOR EMPTY RING CHECK
	LH	R8,NFMI,RR		:GET CURRENT POINTER, USE OLDEST ENTRY
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
	JAL	R7,TYPCRL,,		:TYPE CR/LF
	J	XDR0A4

XDR090	AIS	R8,3			:ROUND UP TO FULL WORD
	NHI	R8,-4			:AND I.E., NEXT MESSAGE
	NR	R8,RS			:TO END OF RING ??
	JAL	R7,TYPCRL,,		:CR LF
XDR0A1	CLH	R8,NFMI,RR		:CAUGHT UP ?
	JN	XDR0A4			:NOT YET
	CLI	RR,IRING		:SEE IF JUST FINISHED IRING
	JN	XDR0FF			:FINISHED!

	LA	RR,ORING,,		:GET SET TO DO ORING
	LHI	RS,DRSZ-1		:RING SIZE
	LIS	R7,0			:REINITIALIZE COUNTER
	LH	R8,NFMI,RR		:USE OLDEST ENTRY
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
:	J	XDR0A1	:GO DO IT bug if NFMI points to valid msg ###sdw

XDR0A4	CLI	RR,ORING		:IS THIS THE ORING?
	JEFS	XDR0A6			:JUMP IF SO, ELSE
	LA	R2,M.I	 		:OUTPUT "I "
	JFS	XDR0A8
XDR0A6	LA	R2,M.O	 		:OUTPUT "O "
XDR0A8	JAL	R7,TYPASC
	LB	R9,RING+2,R8,RR		:GET MESSAGE CODE
	LHL	R10,RING,R8,RR		:GET PORT #
	JE	XDR0C0			:IF INTRANODE MESSAGE
	LR	R9,R9			:CHECK FOR NEEDLE
	JE	XDR0F0			:IF SO
	CLHI	R9,9E			:DATA MESSAGE ??
	JL	XDR0B0			:IF SO
	SHI	R9,9E			:BIAS TO 0
	CLHI	R9,L.ISCT		:CHECK MAX MSG TYPE
	JLE	XDR0A9			:IF OK
	LHI	R9,L.ISCT+1		:GET "UNDEFINED" MESSAGE
XDR0A9	LR	R4,R9			:FOR INDEXING	
	SLHLS   R4,2
	LA	R2,XDRICA,R4   		:ASCII MESSAGE LABEL
	JAL	R7,TYPASC		:TYPE IT
	JAL     R7,TYP1SP 		:and a space
	LB      R6,XDRILA,R9    	:Get len
	JEFS    XDR0AB    		:0 means variable len LOG II msgs
XDR0AA  JAL     R10,XDRISE
	J	XDR090			:GO TO NEXT MESSAGE
XDR0AB  LR      R4,R8     		:get len of variable len msg
	AIS     R4,4
	NR      R4,RS     		:handle wrap
	LHL     R6,RING,RR,R4   	:get len
	AIS     R6,6      		:len of LEN and header
	CLHI    R9,0C4    		:if ICRS then hide UNAME/PW
	JN      XDR0AA    		:just go print it
	LR      R5,R6
	SIS     R5,8
	LIS     R6,8      		:only show first 8 bytes of ICRS
	JAL     R10,XDRISE
	AR      R6,R5
	J       XDR090

XDR0B0	LA	R2,XDRMS3		:"DATA" MESSAGE HEADER
	JAL	R7,TYPASC		:TYPE IT
	JAL	R10,XDRISA		:GO DUMP ISIS DATA MSG
	J	XDR090			:GO TO NEXT MESSAGE

:       here for PORT 0 msg
XDR0C0	CLHI	R9,MAXINM		:CHECK MAX MSG TYPE
	JLE	XDR0C1			:IF OK
	LHI	R9,MAXINM+1		:GET "UNDEFINED" MESSAGE
XDR0C1	LR	R4,R9			:FOR INDEXING
	SLHLS   R4,2
	LA	R2,XDRICB,R4    	:ASCII MESSAGE LABEL
	JAL	R7,TYPASC		:TYPE IT
	TBT	R9,XDRVL  		:VARIABLE LENGTH MESSAGE ??
	JNFS	XDR0D0			:IF SO BECAUSE CAN'T HANDLE YET
	JAL	R10,XDRISC		:GO DUMP ISIS INTRANODE MESSAGE
	J	XDR090			:GO TO NEXT MESSAGE

:       here for variable len port 0 msg
XDR0D0	CLHI	R9,11			:AUX CIRCUIT REQUEST/1-DOWN
	JGE	XDR0E0			:MUST BE ICRM/ECRI LOGII MSGS
	LB	R0,XDRILB,R9		:STEP TO SIZE BYTE
	LR      R4,R0
	AR      R4,R8     		:get address of size byte
	NR	R4,RS			:CHECK FOR WRAP AROUND
	LB	R6,RING,RR,R4		:GET VARIABLE STRING SIZE
	AR      R6,R0     		:get add in header len
	AIS     R6,1      		:plus 1 for the len byte
	JAL	R7,TYP1SP		:TYPE IT
	JAL	R10,XDRISE		:TO PUT OUT MESSAGE
	J	XDR090

XDR0E0	LB	R0,XDRILB,R9		:Do ICRM/ECRI
	LR      R4,R0
	AR      R4,R8
	NR	R4,RS			:CHECK FOR WRAP AROUND
	LHL	R6,RING,RR,R4		:GET VARIABLE MESSAGE SIZE
	AR	R6,R0			:ADD FIXED MESSAGE LENGTH
	AIS     R6,2      		:len of len is two bytes
	JAL	R7,TYP1SP
	CLHI    R9,11     		:if ICRS hide uname/password
	JEFS    XDR0E4
XDR0E2	JAL	R10,XDRISE		:TO PUT OUT MESSAGE
	J	XDR090			:TO CONTINUD

XDR0E4  CLHI    R6,1E
	JLEBS   XDR0E2
	LHI     R5,-1E,R6
	LHI     R6,1E
	JAL     R10,XDRISE
	AR      R8,R5     		:add in unprinted len
	J       XDR090    		:and done

XDR0F0	LA	R2,XDRMS4,,		:NEEDLE MESSAGE
	JAL	R7,TYPASC		:TYPE IT
	LB	R6,RING+3,R8,RR		:GET ADDITIONAL LENGTH
	AIS	R6,4			:ADD FIXED PORTION
	JAL	R7,TYP1SP		:INSERT A BLANK
	JAL	R10,XDRISE		:TO PUT REST OF MESSAGE
	J	XDR090

XDR0FF	J	XRCRLF,,		:RETURN WITH CR/LF

::	SUBROUTINE:	BEGMSG
::	GUESS AT FIRST MESSAGE IN RING
:	------------------------------
:	CALLING SEQ:	JAL	R10,BEGMSG
:	INPUT:		R3  = RS = RING SIZE
:			R7  = COUNTER
:			R8  = CURRENT POINTER
BEGMSG  NHI     R8,-4
	J       BEG010    		:make sure start on even boundary

BEG000	AIS	R8,4			:BUMP POINTER
	AIS	R7,4			:BUMP POINTER
	CR	R7,RS			:SEE IF GONE AROUND RING COMPLETELY
	JGE	XDR0FF			:WE HAVE!  JUMP TO CR/LF
	NR	R8,RS			:SEE IF AT END OF RING
BEG010	LHL     R9,RING,R8,RR   	:VALID DPORT?
	CLHI    R9,NDP    		:MAXIMUM DPORT
	JG      BEG000
	L	R9,RING,R8,RR		:IS WHOLE WORD NONZERO?
	JNR	R10			:IF SO, SHOULD DO FOR A GUESS!
	J	BEG000			:TEST NEXT WORD 

::	SUBROUTINES:	XDRISA/XDRISB/XDRISC/XDRISE
::	DUMP A MESSAGE
:	--------------
:	LINKS:	R10
:	INPUT:	R8 - RING INDEX
:		R9 - MSG CODE TYPE
:		RS - RING SIZE
:		RR - RING START
:	DATA MESSAGE
XDRISA	LA	R6,3,R9			:MESSAGE LENGTH=MESSAGE TYPE+3
	J	XDRISL
:	INTRANODE MESSAGE TYPE
XDRISC	LB	R6,XDRILB,R9		:MESSAGE LENGTH FROM TABLE

XDRISL  JAL     R7,TYP1SP
	J       XDRISE

XDRISD	LA	R2,XDRASC,,		:ASCII EQUIVALENT OF LINE
	JAL	R7,TYPASC
	JAL	R7,TYPCRL,,		:NEW LINE
	JAL	R7,TYP6SP
XDRISE	LIS	R12,0			:LINE LENGTH COUNTER
XDRISF	LB	R4,RING,R8,RR		:NEXT BYTE FROM RING
	JAL	R11,XDTPUT  		:PUT IT OUT IN HEX NOW
	LR      R0,R4
	LR      R0,R4
	TBT	R4,XDRECH		:PRINTABLE ??
	JNFS	XDRISH			:IF NOT, USE BLANK
	LHI	R0,ASCSPC		:ELSE IF OK TO PRINT IT
XDRISH	LR	R4,R12			:COMPUTE WHERE TO PLUG INTO LINE
	NHI	R4,0F			:16 BYTES PER LINE
	STB	R0,XDRASC+4,R4,,	:PUT 'ER THERE FOR ASCII OUTPUT LATER
	AIS	R8,1			:BUMP RING INDEX
	NR	R8,RS			:END OF RING ??
	AIS	R12,1			:LINE LENGTH
	CLH	R8,NFMI,RR		:SEE IF AT RING POINTER
	JE	XDRISI			:IF SO GET OUT
	SIS	R6,1			:CHECK FOR END OF MSG
	JLE	XDRISI			:FINISH BLANKING AND PRINT	
	THI	R12,0F			:END OF LINE
	JE	XDRISD			:IF SO
	THI	R12,1			:END OF HALFWORD
	JN	XDRISF			:IF NOT TO CONTINUE
	JAL	R7,TYP1SP		:TO FORMAT WORDS
	J	XDRISF
XDRISI	LHI	R0,ASCSPC		:BLANK
XDRISJ	NHI	R12,0F			:LINE LENGTH OF 16
	JEFS	XDRISK			:IF TO END OF LINE
	STB	R0,XDRASC+4,R12,,	:PUT IN A BLANK
	AIS	R12,1			:COUNT ON UP
	JBS	XDRISJ			:AND SEE IF DONE
XDRISK	LA	R2,XDRASC,,		:PUT IT OUT
	JAL	R7,TYPASC
	JR	R10			:DONE
       EI       :1-NCSLOT

	SUBTTL	XRAY (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	FSTMSC:
::	FUNCTION:	CONVERT FASTC TO MILLISECONDS
::	CALLING SEQ:	JAL	R9,FSTMSC
::	INPUT:		R2  = FASTC VALUE
::	OUTPUT:		R3  = RETURNED MILLISECOND VALUE 
::	DESTROYED:	R0
::
::*********************************************************************

FSTMSC	LR	R0,R2
	SLLS	R0,2
	AR	R2,R0			:MULTIPLY R2 BY 5
	LIS	R0,3
	DHR	R2,R0			:AND DIVIDE BY 3 ( I.E., BY 1000/600)
	SIS	R2,1			:R2 IS REMAINDER (0,1 OR 2)
	JLER	R9			:0 OR 1, LEAVE RESULT ALONE
	AIS	R3,1			:REMAINDER = 2, ROUND UP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XFNDLK:
::	FUNCTION:	LIKE FNDLNK, BUT STORES KN AND KD IN THE XKNSAV
::	AND XKDSAV FIELDS OF THE REMOTE XRAY USER BLOCK.
::	CALLING SEQ:	JAL	R9,XFNDLK
::	INPUT:		R1  = NEIGHBOR NUMBER
::	NOTE:		R11 IS USED AS KN OR KX (KD) THROUGHOUT	XRAY.
::	RETURNS:	IMMEDIATE = NOT FOUND
::			+4 = FOUND
::
::*********************************************************************

XFNDLK	ST	R9,XFNDSV		:SAVE RETURN
	LHI	R11,NLINKS-1		:HIGHEST LINK#
XFNDL1	SLLS	R11,1
	L	R9,KDKN,R11,R11		:LINK DESC.
	SRLS	R11,1
	CLH	R1,NDID,R9		:THIS IT?
	JEFS	XFNDL2			:YES
	SIS	R11,1			:NO, TRY AGAIN
	JGEBS	XFNDL1
	ST	R11,XKDSAV,XD		:LINK DESC<0
	STH	R11,XKNSAV,XD		:KN=-1
	L	R9,XFNDSV		:RECOVER RETURN
	SKIP(0,R9)			:STRAIGHT RETURN		###wjl
XFNDL2	ST	R9,XKDSAV,XD		:FOUND KD
	STH	R11,XKNSAV,XD		:AND KN
	L	R9,XFNDSV		:RECOVER RETURN
	J	4,R9			:SKIP RETURN

::*********************************************************************
::
::	SUBROUTINE:	CHNLNK:
::	FUNCTION:	FINDS THE NEIGHBOR CONNECTED TO A CHANNEL
::	CALLING SEQ:	JAL	R8,CHNLNK
::	INPUT:		R5(CHN)	= CHANNEL
::	OUTPUT:		R3	= RETURNS NEIGHBOR NUMBER
::	DESTROYED:	R1, R9
::	RETURNS:	IMMEDIATE IF NO NEIGHBOR
::			+4 IF INTERNAL TERMINATION
::			+8 IF NEIGHBOR FOUND
::
::*********************************************************************

CHNLNK	LCS	R3,4
CHNLN1	AIS	R3,4
	CLH	CHN,CHNMAP,R3		:CHNMAP ORGANIZED IN DESCENDING ORDER
	JLBS	CHNLN1			:CHN IS STILL TOO LOW
	LHL	R3,CHNMAP+2,R3		:CHNMAP+2 IS POINTER TO NEIGHBOR NUMBER
	THI	R3,8000			:HOB SET MEANS INTERNAL TERMINATION
	JN	CHNLN4			:IT IS				###wjl
	LHL	R3,CHNMPD,R3		:IT ISN'T, LOOK UP NEIGHBOR
CHNLN2	LR	R1,R3
	ST	R11,XRSAVE,XD
	JAL	R9,XFNDLK		:MAKE SURE THE NEIGHBOR IS THERE
	SKIPAD(CHNLN3)			:immed, IT ISN'T, do IMMED RET	###wjl
	L	R11,XRSAVE,XD		:+4 return, IT IS, do +8 RETURN	###wjl
	J	8,R8			:				###wjl

CHNLN3	L	R11,XRSAVE,XD
	SKIP(0,R8)			:immediate return for no neighbor##wjl

CHNLN4	SKIP(4,R8)			:+4 return for internal term	###wjl

::*********************************************************************
::
::	SUBROUTINE:	COUNT0:/COUNT1:
::	FUNCTION:	COUNTS NUMBER OF 0'S/1'S IN A SERIES OF CONTIGIOUS HW
::	CALLING SEQ:	JAL	R9,COUNT0
::	INPUT:		R2  = HW COUNT
::			R4  = POINTER TO FIRST HW
::	OUTPUT:		R3  = RESULT
::	DESTROYED:	R0, R1
::
::*********************************************************************

COUNT1	LIS	R3,0			:SO XOR HAS NO EFFECT BELOW.
	JFS	COUNTD
COUNT0	LCS	R3,1			:TO INVERT BITS IN XOR BELOW.
COUNTD	STH	R3,CNTXOR
	LIS	R3,0			:CLEAR RESULT
	LR	R2,R2			:VERIFY NON-ZERO COUNT
	JER	R9			:ZERO COUNT, RETURN
COUNTA	LHL	R0,0,R4			:GET A HW
	XH	R0,CNTXOR		:COMPLEMENT (0'S) OR NOT (1'S)
COUNTB	JFFOH	R0,COUNTC		:FIND FIRST 1
	JFS	NOONE			:NO MORE ONES
COUNTC	AIS	R3,1			:INCREMENT COUNT IN R3
	XH	R0,HMSK,R1,R1		:COUNT EACH 1 ONLY ONCE
	JBS	COUNTB			:AND KEEP SEARCHING
NOONE	AIS	R4,2			:INCREMENT HW INDEX
	SIS	R2,1			:DECREMENT HW COUNT
	JGBS	COUNTA			:MORE HW, CONTINUE
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	RDSYMB:
::	FUNCTION:	READS UP TO 6 ASCII CHARACTERS INTO XREGSV+1
::		note where it writes (to odd byte) as that makes life
::		easy for SYMVAL.
::	CALLING SEQ:	JAL	R10,RDSYMB
::	DESTROYED:	R1, R2
::
::*********************************************************************

RDSYMB	LI	R1,0A0A0A0A0		:INITIALIZE VALUE1 TO SPACES
	ST	R1,xregsv,xd
	ST	R1,xregsv+4,xd
	LIS	R2,0
	lb	r13,argpos,xd
RDSYM1	lb	r1,value1+4,r13,xd	:get char
	OHI	R1,80			:SET HOB
	CLHI	R1,ASCSPC+80		:IF SPACE ASSUME USER IS DONE
	JER	R10
	CLHI	R1,ASCCR+80		:SAME FOR CR
	JER	R10
	CLHI	R1,ASCCOM+80		:SAME FOR COMMA			###wjl
	JER	R10			:				###wjl
	CLHI	R1,ASCNIN+80		:ASSUME A DIGIT			###wjl
	JLEFS	RDSYM2			:				###wjl
	NHI	R1,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE,0DF
RDSYM2	STB	R1,xregsv,R2,xd
	clhi	r2,6			:if have enough just write extras
	jgefs	rdsym3			:into ignored location
	AIS	R2,1
rdsym3	ais	r13,1
	stb	r13,argpos,xd		:remember char read
	clb	r13,argpos+1,xd		:at end of cmd?
	JL	RDSYM1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SYMVAL:
::	FUNCTION:	FINDS THE VALUE OF A SYMBOL IN THE SYMBOL TABLE
::		the unstated thing going on here is the symbol to be
::		checked against is SC /label / where label is always six
::		bytes long (paded with spaces if needed) and the SC always
::		is on a HW boundary so label text is always on odd byte
::		start.  With all that fixed the routine is fairly easy.
::	CALLING SEQ:	JAL	R10,SYMVAL
::	OUTPUT:		R3  = RETURNS THE VALUE
::	DESTROYED:	R2,r6,r7
::	RETURNS:	IMMEDIATE = NO MATCH
::			+4 = MATCH
::
::*********************************************************************

SYMVAL	l	r6,xregsv,xd		:get first 3 bytes
	lhl	r7,xregsv+4,xd		:get last 3 bytes
	lis	r2,0
symva1	l	r3,symtbl,r2,		:see if first 3 bytes match
	cr	r3,r6
	jnfs	symva4
	lHL	r3,symtbl+4,r2,		:then do last 3 match?
	cr	r3,r7
	jnfs	symva4
:	have a match
	L	R3,SYMTBL+6,R2,		:get value of the symbol
	J	4,R10			:FOUND A MATCH, SKIP RETURN
SYMVA4	AHI	R2,ADRESZ		:NAD'S INADEQUACIES PREVENT USE OF AIS
	CLHI	R2,SYMTSZ
	JL	SYMVA1
	SKIP(0,R10)			:NO MATCH, IMMEDIATE RETURN	###wjl

::*********************************************************************
::
::	SUBROUTINE:	OCTHXR:
::	FUNCTION:	CONVERTS A VALUE IN R3 FROM OCTAL TO HEX
::	CALLING SEQ:	JAL	R9,OCTHXR
::	INPUT/OUPUT:	R3  = ARGUMENT AND RESULT
::	DESTROYED:	R0, R1
::
::*********************************************************************

OCTHXR	LR	R1,R3
	LR	R0,R3
	NHI	R1,7			:FIRST OCTAL DIGIT
	NHI	R3,70			:SECOND OCTAL DIGIT
	SRLS	R3,1
	AR	R1,R3
	LR	R3,R0
	NHI	R3,700			:THIRD OCTAL DIGIT
	SRLS	R3,2
	AR	R1,R3
	LR	R3,R0			:FOURTH OCTAL DIGIT
	NHI	R3,7000
	SRLS	R3,3
	AR	R1,R3 			:				###SHM
	LR	R3,R0			:				###SHM
	NI	R3,070000  		:FIFTH OCTAL DIGIT		###SHM
	SRLS	R3,4			:				###SHM
	AR	R1,R3			:				###SHM
	LR	R3,R0			:				###SHM
	NI	R3,0700000		:SIXTH OCTAL DIGIT		###SHM
	SRLS	R3,5			:				###SHM
	AR	R1,R3			:				###SHM
	LR	R3,R0			:				###SHM
	NI	R3,07000000     	:SEVENTH OCTAL DIGIT		###SHM
	SRLS	R3,6			:				###SHM
	AR	R1,R3			:				###SHM
	LR	R3,R0			:				###SHM
	NI	R3,70000000     	:EIGTH OCTAL DIGIT		###SHM
	SRLS	R3,7			:				###SHM
	AR	R3,R1			:				###SHM
	JR	R9			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	HEXOCT:
::	FUNCTION:	CONVERT VALUE FROM HEX TO OCTAL.
::	CALLING SEQ:	JAL	R9,HEXOCT
::	INPUT/OUTPUT:	CALLING ROUTINE PASSES HEX VALUE IN r3 and gets
::			returned in R3 in octal
::	DESTROYED:	R1, R2
::
::*********************************************************************

HEXOCT	lr	r2,r3		:copy
	lis	r3,7
	nr	r3,r2
	slls	r2,1
	lhi	r1,70
	nr	r1,r2
	or	r3,r1
	slls	r2,1
	lhi	r1,700
	nr	r1,r2
	or	r3,r1
	slls	r2,1
	lhi	r1,7000
	nr	r1,r2
	or	r3,r1
	slls	r2,1
	li	r1,70000
	nr	r1,r2
	or	r3,r1
	slls	r2,1
	li	r1,700000
	nr	r1,r2	
	or	r3,r1
	slls	r2,1
	li	r1,7000000
	nr	r1,r2
	or	r3,r1
	slls	r2,1
	li	r1,70000000
	nr	r1,r2
	or	r3,r1
	JR	R9			:DONE - OCTAL VALUE IN R3

::*********************************************************************
::
::	SUBROUTINE:	DECHEX:
::	FUNCTION:	DECIMAL TO HEX CONVERSION ROUTINE
::	CALLING SEQ:	JAL	R9,DECHEX
::	INPUT/OUTPUT:	HALF-WORD ARGUMENT PASSED AND RETURNED IN R3
::	DESTROYED:	R0-R4
::
::*********************************************************************

DHXTBL	wc	$A 1			:1
	wc	$A 10
	wc	$A 100			:10^3
	wc	$A 1000
	wc	$a 10000		:10^5
	wc	$a 100000
	wc	$a 1000000		:10^7
	wc	$a 10000000

DECHEX	LR	R2,R3			:SAVE OFF ARGUMENT
	LIS	R3,0			:CLEAR RESULT
	lis	r1,0
DECHE1	L	R0,DHXTBL,R1		:GET POWER OF 10
	lr	r4,r2
	nhi	r4,0f
	CLHI	R4,9			:CHECK FOR RADIX VIOLATION	###wjl
	JGFS	DHXBAD			:YES, output error message	###wjl
deche2	sis	r4,1
	jlfs	deche3
	ar	r3,r0
	jbs	deche2
deche3	ais	r1,4			:next entry
	srls	r2,4
	Jn	DECHE1	
	JR	R9			:DONE				###wjl

DHXBAD	LA	R2,BADRDX,,		:**BAD RADIX
	JAL	R7,TYPASC		:ERROR CONDITION
	J	XRCRLF,,		:###jhl

::*********************************************************************
::
::	SUBROUTINE:	HEXDEC:
::	FUNCTION:	CONVERT VALUE FROM HEX TO DECIMAL.
::	CALLING SEQ:	JAL	R9,HEXDEC
::	INPUT/OUTPUT:	Calling Routine Passes Hex Value in R3 -- Decimal
::				value returned in R3.
::	NOTE:  Maximum Value convertable is 99999999d (5F5E0FF HEX).
::	DESTROYED:	R0 - R4
::
::*********************************************************************

HEXDEC	LIS	R0,$A10			: Divisor for Radix Conversion
	LR	R2,R3			: copy (HEX) value
	LIS	R3,0			: Clear decimal accumulator
	LIS	R4,7			: 8 loops, once for each digit/nibble
HEXDC2	LIS	R1,0			: extend operand to 64-bits
	DR	R1,R0
	OR	R3,R1			: accumulate remainder as new digit
	RRL	R3,4			: make room for next digit
	SIS	R4,1			: (aligned after 8 loops)
	JGEBS	HEXDC2
	JR	R9			: RETURN WITH DECIMAL VALUE IN R3

::*********************************************************************
::
::	SUBROUTINE:	DECPER:
::	FUNCTION:	COMPUTE AND DISPLAY DECIMAL PERCENTAGE OF
::	PASSED VALUES AS:	A/B=NN%
::	WHERE A IS PASSED IN R3, B IS PASSED IN R4, AND NN IS A DECIMAL
::	VALUE. THE VALUE IS DISPLAYED FOLLOWED BY A '%'.
::	CALLING SEQ:	JAL	R9,DECPER
::	DESTROYED:	R0, R2
::	CALLS:	 	HEXDEC, TYPBYT, AND TYPASC
::
::*********************************************************************

DECPER	ST	R9,DPRSAV,XD		:SAVE RETURN LINK
	LHI	R0,$A100
	MR	R2,R0			:MULTIPLY DIVIDEND BY 100
	LR	R4,R4	
	JLEFS	DECPR1			:NO DIVIDE BY ZERO...
	DR	R2,R4			:(A/B), QUOTIENT IN R3
	JFS	DECPR2
DECPR1	LIS	R3,0			:DIVIDE BY ZERO, GIVE ZERO RESULT
DECPR2	JAL	R9,HEXDEC		:CONVERT TO DECIMAL AND
	JAL	R9,TYPBYT		:	DISPLAY
	LA	R2,ASCPCT,,
	JAL	R7,TYPASC		:DISPLAY PERCENT SIGN (%)
	L	R9,DPRSAV,XD
	JR	R9			:RETURN

	SUBTTL	XRAY (CRYPTO OUTPUT ROUTINES)

:	THE FOLLOWING SYMBOL IS USED AS A BASE ADDRESS TO ALLOW ROUTINE
:	ADDRESSES TO BE STORED AS HALF-WORDS IN THE CRYPTO MESSAGE TABLE
SEGD.1	HS	0

::*********************************************************************
::
::	SUBROUTINE:	TYPHEX:
::	FUNCTION:	TYPE A SINGLE HEX DIGIT
::	CALLING SEQ:	JAL	R7,TYPHEX
::	INPUT:		R1=DIGIT
::
::*********************************************************************

TYPHEX	NHI	R1,0F			:TRUNCATE
	OHI	R1,30			:IF > 39, ADD 7
	CLHI	R1,ASCNIN
	JLEFS	TYPH10			:.+4
	AIS	R1,7
TYPH10	JAL	R13,XRYOUT
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPFWD:
::	FUNCTION:	IDENTICAL TO TYPHWD FOR A FULL-WORD
::	CALLING SEQ:	JAL	R9,TYPFWD
::
::*********************************************************************

TYPFWD	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC
	JAL	R9,TYPFW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPFW:
::	FUNCTION:	TYPE 8 DIGITS FOLLOWED BY SPACES
::	CALLING SEQ:	JAL	 R9,TYPFW
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7
::
::*********************************************************************

:	typhws 	prints two spaces before and after the hw
:	typhns	prints no spaces before or after the hw
:	typhw	prints two spaces after the hw
:	typadd	prints address (either 5 or 6 digits) with ':  '
:	typ5ch	prints 5 digits followed by 2 spaces

TYPHNS	Lr	R0,r9			:print nothing after printing
	JFS	TYPH2
TYPHWS	JAL	R7,TYP2SP		:TYPE 2 SPACES
TYPHW	La	R0,typ2sp		:2 spaces upon completing
TYPH2	LIS	R4,4
	st	r0,xnumsp,xd		:store exit print routine
	exhr	r0,r3
	j	typf1

:	typadd	prints the address (5 or 6 digits) followed by ':  '
typadd	la	r0,typcln		:print colon after the number
	st	r0,xnumsp,xd
	lr	r0,r3
	if	macv
	lis	r4,6			:6 digits
	slls	r0,8			:toss those 2 unwanted digits
	else	:normal engine
	lis	r4,5			:5 digits
	slls	r0,3*4			:toss 3 digits
	ei
	j	typf1			:and print

:	typ6ch	is type 6 digits
typ6ch	la	r0,typ1sp		:6 digits have two space between
	st	r0,xnumsp,xd
	lr	r0,r3			:work reg
	rll	r0,2*4			:move off the unwanted 3 digits
	lis	r4,6			:for 6 digits
	j	typf1			:and continue

:	typ5ch	is type 5 digits
typ5ch	la	r0,typ2sp		:5 digits have two space between
	st	r0,xnumsp,xd
	lr	r0,r3			:work reg
	rll	r0,3*4			:move off the unwanted 3 digits
	lis	r4,5			:for 5 digits
	jfs	typf1			:and continue

:	the actual TYPFW routine
TYPFW	LIS	R4,8			:init counter
	la	r0,typ1sp		:FWs have one space between
	st	r0,xnumsp,xd
	LR	R0,R3			:move R3 to work register
:	the common logic to print digits of a number
typf1	sis	r4,1			:makes loop control easier
	lb	r1,xsform,xd		:are we in short format?
	jefs	typf2			:no, print like normal
typf4	rll	r0,4			:rotate into low 4 bits
	thi	r0,0f			:nonzero?
	jnfs	typf3			:yes, so print it
	sis	r4,1			:count another digit
	jgbs	typf4			:suppress al but the last zero
TYPF2	RLL	R0,4			:rotate four bits (hex digit's worth)
typf3	LR	R1,R0			:and get it into R1 for TYPHEX
	JAL	R7,TYPHEX		:type out ASCII for a hex digit
	SIS	R4,1			:decrement the counter
	JGeBS	TYPF2			:loop until zero
	l	r1,xnumsp,xd
	JALr	R7,r1			:output a space
	JR	R9			:return to caller

::*********************************************************************
::
::	SUBROUTINE:	GMTCAL:
::	FUNCTION:	GET THE CURRENT GMT FOR STORAGE OR DISPLAY.
::	CALLING SEQ:	JAL	R9,GMTCAL
::	OUTPUT:		R2 = 25 BITS OF HEX SEC'S SINCE START OF CURRENT YEAR
::			PLUS BITS 22-28 OF FASTC
::	DESTROYED:	R1,R3,R4
::
::*********************************************************************

GMTCAL	ST	R2,XYSAVE,		:SAVE REGISTER 2
	L	R2,SLOWC,,		:GET CURRENT NODE TIME.
	LHL	R1,FASTC+2,,		:GET LO HW OF FASTC.
	LH	R3,GETGMT		:SEE IF WE'VE GOT GMT YET

	JNFS	GMTCA2			:RECEIVED GMT, NO NEED TO ADJUST###OAS
	S	R2,NODSLC		:NO GMT RECEIVED YET, ADJUST FROM SLOWC
					:AT TIME OF NSTART,SOFTWARE RESTART#OAS
	J	GMTCA1			:AND SKIP ADJUSTMENTS		###OAS

GMTCA2	LR	R3,R2			:SAVE IT IN CASE WE GO TO GMTUPD
	S	R2,GMTSLC		:SUBTRACT BASE NODE TIME
	A	R2,GMTHEX		:ADD BASE GMT TIME TO GET NO. SEC'S
					:	SINCE START OF CURRENT YEAR
	C	R2,CYRMAX		:PAST END OF CURRENT YEAR?
	JLE	GMTCA1			:NO, SKIP
GMTUPD	ST	R3,GMTSLC		:NEW BASE NODE TIME
	S	R2,CYRMAX		:HOW MUCH INTO NEW YEAR?
	AI	R2,$A24*3600		:EXTRA DAY'S WORTH TO NIX DAY 0
	LI	R3,$A366*24*3600	:# SECS IN NORMAL YEAR+1 DAY FOR CYRMAX
	LHL	R4,CYRCOD		:OLD CURRENT YEAR CODE
	AIS	R4,1			:BUMP IT 1
	NHI	R4,3			:MOD 4
	STH	R4,CYRCOD		:SAVE NEW CURRENT YEAR CODE
	JNFS	GMTUP1			:NOT LEAPYEAR, SKIP
	AI	R3,$A24*3600		:add day's sec's for leapyear
GMTUP1	ST	R3,CYRMAX		:NEW CURRENT YEAR MAX SEC'S
	ST	R2,GMTHEX		:NEW GMT BASE TIME

GMTCA1	SRLS	R1,3			:LOSE LO BITS OF FASTC
	NHI	R1,7F			:SAVE LO 7 BITS
	SLLS	R2,7			:ALIGN SEC'S AND
	OR	R2,R1			:COMBINE WITH FASTC INTO R2
	ST	R2,GMTNOW		:SAVE IT
	L	R2,XYSAVE		:RESTORE REGISTER2
	JR	R9			:RETURN FOR DEPOSIT

::*********************************************************************
::
::	SUBROUTINE:	GMTCNV:
::	FUNCTION:	CONVERTS GMT SEC'S+FASTC IN R2 INTO DDD:HH:MM:SS
::			AND DISPLAYS IT.
::	CALLING SEQ:	JAL	R9,GMTCNV
::
::*********************************************************************

GMTCNV	L	R2,GMTNOW		:GET TIME
GMTCNX	ST	R0,XRSAVE,XD		:SAVE REGISTER
	st	r9,xrsave+4,xd
	SRLS	R2,7			:STRIP FASTC BITS
	LI	R3,$A24*1800		:NO. SEC'S IN HALF DAY (FOR HW DIVIDE)
	DHR	R2,R3			:R3=NO. HALFDAYS ELAPSED, R2=NO. SEC'S
					:INTO CURRENT HALFDAY
	SRLS	R3,1			:R3=NO. DAYS ELAPSED
	JNCFS	GMTCN1			:NO CARRY, SKIP
	AI	R2,$A24*1800		:ADJUST R2 FOR HALFDAY CARRY
GMTCN1	lis	r1,0
GMTCN3	CHI	R3,$A100		:DDD>=100?
	JLFS	GMTCN4			:NO, DDD<=99
	AIS	R1,1			:HO DIGIT OF DDD
	SHI	R3,$A100		:one fewer to go
	JBS	GMTCN3			:
GMTCN4	JAL	R7,TYPHEX		:TYPE IT
	lr	r7,r2
	jal	r9,hexdec
	lr	r13,r3
	SLL	R13,$A24		:R13=DD000000
	LHI	R3,$A60*60		:SEC'S IN HOUR
	lr	r2,r7
	DHR	R2,R3			:R2=SEC'S INTO CURRENT HOUR
					:R3=CURRENT HOUR
	lr	r7,r2
	jal	r9,hexdec
	SLL	R3,$A16			:R3=00HH0000
	OR	R13,R3			:R13=DDHH0000
	LHI	R3,$A60			:SEC'S IN MINUTE
	lr	r2,r7
	DHR	R2,R3			:R3=CURRENT MIN, R2=CURRENT SEC
	lr	r7,r2
	jal	r9,hexdec
	SLLS	R3,8			:R3=0000MM00
	OR	R13,R3			:R4=DDHHMM00
	lr	r3,r7
	jal	r9,hexdec		:R3=000000SS
	OR	R13,R3			:R4=DDHHMMSS
	lr	r4,r13
	l	r9,xrsave+4,xd

::*********************************************************************
::
::	SUBROUTINE:	TYPGMT:
::	FUNCTION:	TYPES DD:HH:MM:SS FROM DDHHMMSS IN R4 
::	CALLING SEQ:	JAL	R9,TYPGMT
::
::*********************************************************************

TYPGMT	LIS	R3,3			:FOUR PAIRS OF DIGITS TO TYPE,
					: 3 FOLLOWED BY ':'
TYPGM2	LIS	R2,2			:TWO DIGITS PER PAIR
TYPGM1	RLL	R4,4			:NEXT DIGIT TO LO NIBBLE OF R4
	LR	R1,R4			:R1 PASSES DIGIT TO BE TYPED
	JAL	R7,TYPHEX		:TYPE DIGIT
	SIS	R2,1			:1 DIGIT DOWN
	JGBS	TYPGM1			:NEXT DIGIT IN PAIR IF MORE
	LBR	R3,R3			:ALL DONE WITH PAIRS?
	JEFS	TYPGM3			:DON'T TYPE ':' AFTER SS. GO TYPE .FF
	LHI	R1,3A			:ASCII ':'
	JAL	R13,XRYOUT		:TYPE IT
	SIS	R3,1			:A PAIR DOWN
	JBS	TYPGM2			:NEXT PAIR

TYPGM3	L	R0,XRSAVE,XD		:RESTORE REG
	JR	R9			:RETURN TO THE SOURCE

::*********************************************************************
::
::	SUBROUTINE:	TYPNBY:
::	FUNCTION:	TYP N BYTES FOLLOWED BY 4 SPACES
::	CALLING SEQ:	JAL	R8,TYPNBY
::	INPUT:		R6  = ADDRESS OF FIRST BYTE
::			R5  = BYTE COUNT
::	DESTROYED:	R0,R1,R2,R3,R4,R7,R9
::
::*********************************************************************

TYPNBY	LIS	R4,0
TYPNB1	CR	R4,R5
	JER	R8			:DONE
	LB	R3,0,R6,R4		:GET A BYTE
	JAL	R9,TYPBYT		:AND TYPE IT
	JAL     R9,TYP2SP 		:print two extra spaces
	AIS	R4,1			:INC INDEX
	JBS	TYPNB1			:AND LOOP

::*********************************************************************
::
::	SUBROUTINE:	TYP8HW/TYP8HS/TYPNHW
::	ENTRY POINT:	TYP8HW:  TYPES 8 HW WITH 2 SPACES BETWEEN EACH
::			TYP8HS:  PRECEEDS FIRST HW WITH 4 SPACES
::			TYPNHW:  TYPES AS MANY HW AS COUNT IN R5
::	LINK:		R8
::	INPUT:		R10 = STARTING ADDRESS
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R6,R7,R9
::
::*********************************************************************

TYP8SV	WS	1			:LINK SAVE AREA FOR TYP8H

TYP8HD	ST	R8,TYP8SV
	LI	R8,TYPHWD		:DECIMAL DISPLAY
	JAL	R7,TYP4SP
	LIS	R5,8
	JFS	TYPNH1
TYP8HS	JAL	R7,TYP4SP
TYP8HW	LIS	R5,8
TYPNHW	ST	R8,TYP8SV		:SAVE LINK
	LI	R8,TYPHW		:HEX DISPLAY
TYPNH1	SIS	R5,1			:DONE?
	JLFS	TYP8H1			:YES
	LHL	R3,0,R10
	AIS	R10,2
	JALR	R9,R8			:TYPHW OR TYPHWD
	JBS	TYPNH1
TYP8H1	JAL	R7,TYPCRL
	L	R8,TYP8SV		:RESTORE LINK REG
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	TYPCRL/TYPLF
::	ENTRY POINT:	TYPCRL:  TYPES A CR-LF
::			TYPLF:   TYPES LINE FEED
::	LINK:		R7
::	DESTROYED:	R1
::
::*********************************************************************

TYPCRL	LIS	R1,0D
	JAL	R13,XRYOUT
TYPLF	LIS	R1,0A
	JAL	R13,XRYOUT
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPBIT:
::	FUNCTION:	TYPES BIT ARRAY
::	CALLING SEQ:	JAL	R9,TYPBIT
::	INPUT:		R3 = HWD OF BIT ARRAY
::			R4 = NUMBER OF BITS TO TYPE
::	DESTROYED:	R0, R1, R2, R5
::
::*********************************************************************

TYPSAV	HS	1			:save area for HW of bit array

TYPBIT	LIS	R5,0			:initialize pointer/counter
	STH	R3,TYPSAV		:store HW of bit array
TYPB02	TBT	R5,TYPSAV		:bit set??
	JNFS	TYPB04			:yes
	JAL	R7,TYP0			:no, type a 0
	JFS	TYPB06
TYPB04	JAL	R7,TYP1			:type a 1
TYPB06	AIS	R5,1			:increment pointer/counter
	CR	R5,R4			:finished??
	JL	TYPB02			:no
	JR	R9			:yes, return

::*********************************************************************
::
::	SUBROUTINE:	TYPASC:
::	ENTRY POINTS:	TYP2SP,TYP4SP,TYP8SP,TYPASP,TYPASC,TYPAS1
::	LINK:		R7
::	INPUT:		R2=PTR TO STRING
::	DESTROYED:	R0,R1
::
::*********************************************************************

ASCSAT	SC	/@-/			:SATELITE FLAG FOR "ND"		###OAS
ASCPCT	SC	/%"A0/
ASC0	SC	/0"A0/			:ASCII 0 for TYPBIT		###wjl
ASC1	SC	/1"A0/			:ASCII 1 for TYPBIT		###wjl
ASC1SP	SC	/"A0/
ASC2SP	SC	/"A0"A0/
ASCASP	SC	/"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0/
ASCCLN	SC	/:"A0"A0/
ASCRLF	SC	/"0D"0A/

:	type ':  '
typcln	la	r2,asccln
	j	typasc
:	TYP0:	TYPE AN ASCII 0						###wjl
TYP0	LA	R2,ASC0
	J	TYPASC

:	TYP1:	TYPE AN ASCII 1						###wjl
TYP1	LA	R2,ASC1
	J	TYPASC

:       TYP1SP  type 1 space
TYP1SP	lis	r0,1
	J	TYPhds
:	TYP2SP
TYP2SP	lis	r0,2
	J	TYPhds

TYP3SP	lis	r0,3
	J	TYPhds

TYP5SP	lis	r0,5
	J	TYPhds

TYP6SP	lis	r0,6
	Jfs	TYPhds

TYP7SP	lis	r0,7
	Jfs	TYPhds

TYP9SP	lis	r0,9
	Jfs	TYPhds

:	TYP4SP: TYPES 4 SPACES
TYP4SP	lis	r0,4
	JFS	TYPhds

:	TYP8SP: TYPES 8 SPACES
TYP8SP	lis	r0,8
	JFS	TYPhds

:	TYPASP: TYPES 10 SPACES
TYPASP	lis	R0,0a			:FALL THRU TO TYPASC
typhds	LA	R2,ASCASP+1		:string of spaces
	j	typas1
:	typhdc	same as typasc except for printing header info which is
:		suppressed when xsform is enabled

typhdc	lb	r0,xsform,xd		:if nonzero then short form
	jefs	typasc			:don't print
	j	typ1sp			:otherwise may have to print a space
					:for formatting between fields

:	typhdr	is as same as typhdc but for when when crlf is needed
typhdr	lb	r0,xsform,xd		:if nonzero then short form
	jefs	typasc			:don't print
	lb	r0,xslast,xd		:make sure last thing wasn't a LF
	clhi	r0,8a			:xryout sets high bit
	jer	r7			:no need to send another one
	j	typcrl

:	TYPASC:	TYPE ASCII STRING
:	TYPAS1:	ALTERNATE ENTRY POINT HAS BYTE COUNT PASSED IN R0
TYPASC	LB	R0,0,R2			:BYTE COUNT
	JER	R7			:NULL LENGTH
TYPAS1	LB	R1,1,R2			:CHAR
	JAL	R13,XRYOUT
	AIS	R2,1
	SIS	R0,1
	JGBS	TYPAS1
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPASI:
::	FUNCTION:	TYPE ASCII STRING IMMEDIATELY FOLLOWING CALL
::	LINKS ON:	R7 (WHICH ALSO POINTS TO BEGINNING OF STRING)
::	DESTROYED:	R0,R1
::
::*********************************************************************

TYPASI	lb	r2,xsform,xd		:in short format?
	jefs	tyasi1
	lb	r2,0,r7			:get length
	ar	r7,r2
	lis	r2,0			:indicate message is done
	lhi	r1,20			:replace it with a space
	jfs	tyasi3
tyasi1	LB	R2,0,R7			:LENGTH OF STRING
TYASI0	AIS	R7,1			:POINT TO NEXT CHAR
	LB	R1,0,R7			:GET THE CHAR
tyasi3	JAL	R13,XRYOUT		:PUT IT OUT
	SIS	R2,1			:DECREMENT COUNT OF REMAINING CHAR'S
	JGBS	TYASI0			:MORE TO DO
	AIS	R7,2			:ADJUST RETURN TO NEXT HW
	NHI	R7,0FFFE		:...AS SO
	JR	R7			:RETURN TO INSTRUCTION FOLLOWING STRING

::*********************************************************************
::
::	SUBROUTINE:	TYPHWD:
::	FUNCTION:	CONVERTS TO DECIMAL AND TYPES A HW
::	CALLING SEQ:	JAL	R9,TYPHWD
::	INPUT:		R3  = VALUE
::	DESTROYED:	R3
::	OTHER REGISTERS IDENTICAL TO TYPHW
::
::*********************************************************************

TYPHWD	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC		:GO DECIMAL
	JAL	R9,TYPHW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPHWO:
::	FUNCTION:	CONVERTS TO OCTAL AND TYPES A HW
::	CALLING SEQ:	JAL	R9,TYPHWO
::	INPUT:		R3  = VALUE
::	DESTROYED:	R3
::	OTHER REGISTERS IDENTICAL TO TYPHW
::
::*********************************************************************

TYPHWO	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXOCT		:GO OCTAL
	JAL	R9,TYPHW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::**************************************************************************
::
::	SUBROUTINE:	TYP5O:
::	FUNCTION:	CONVERTS TO OCTAL AND TYPES FIVE DIGITS
::	CALLING SEQ:	JAL	R9,TYP5O
::	INPUT:		R3= ARGUMENT
::	DESTROYED:	R0,R1,R2,R3,R4,R7			###SHM
::	
::**************************************************************************

TYP5O	ST	R9,XHDSAV,XD		:SAVE LINK		
	JAL	R9,HEXOCT		:CONVERT TO HEX
	JAL	R9,TYP5CH		:TYPE FIVE CHARACTERS
	L	R9,XHDSAV,XD		:RESTORE LINK
	JR	R9			:RETURN

::**************************************************************************
::
::	SUBROUTINE:	TYP5DD:
::	FUNCTION:	CONVERTS A HALFWORD HEX TO DECIMAL AND DISPLAYS IT
::			IN 5-DIGIT FORMAT FOLLOWED BY 2 SPACES
::	CALLING SEQ:	JAL	R9,TYP5DD
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7,R13
::
::**************************************************************************

TYP5DD	ST	R9,XHDSAV,XD		:SAVE THE RETURN ADDR 	###cwc
	JAL	R9,HEXDEC		:TURN R3 TO DECIMAL	###cwc
	JAL	R9,TYP5CH		:DISPLAY 5 DIGITS	###cwc
	L	R9,XHDSAV,XD		:RETRIEVE RETURN ADDR	###cwc
	JR	R9			:RTS			###cwc


::**************************************************************************
::
::	SUBROUTINE:	TYP6DD:
::	FUNCTION:	CONVERTS A HALFWORD HEX TO DECIMAL AND DISPLAYS IT
::			IN 6-DIGIT FORMAT FOLLOWED BY 1 SPACE
::	CALLING SEQ:	JAL	R9,TYP6DD
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7,R13
::
::**************************************************************************

TYP6DD	ST	R9,XHDSAV,XD		:SAVE THE RETURN ADDR
	JAL	R9,HEXDEC		:TURN R3 TO DECIMAL
	JAL	R9,TYP6CH		:DISPLAY 5 DIGITS
	L	R9,XHDSAV,XD		:RETRIEVE RETURN ADDR
	JR	R9			:RTS


::*********************************************************************
::
::	SUBROUTINE:	TYPBYT:
::	FUNCTION:	TYPE 2 DIGITS FOLLOWED BY 2 SPACES
::	CALLING SEQ:	JAL	R9,TYPBYT
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R7
::
::*********************************************************************

TYPBYT	LR	R1,R3			:ENTRY POINT FOR TYPNBY ROUTINE
	SRLS	R1,4			:SLIDE FIRST HEX DIGIT TO LO NIBBLE
	JAL	R7,TYPHEX		:	AND DISPLAY
	LR	R1,R3
	JAL	R7,TYPHEX		:DISPLAY SECOND HEX DIGIT
	JAL	R7,TYP2SP		:DISPLAY 2 SPACES
	JR	R9			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	TYPBYO:
::	FUNCTION:	CONVERT LO HW IN R3 TO OCTAL AND TYPE LO BYTE
::	CALLING SEQ:	JAL	R9,TYPBYO
::
::*********************************************************************

TYPBYO	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXOCT
	JAL	R9,TYPBYT
	L	R9,XHDSAV,XD
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	TYPBYD:
::	FUNCTION:	CONVERT LO HW IN R3 TO DECIMAL AND TYPE LO BYTE
::	CALLING SEQ:	JAL	R9,TYPBYD
::
::*********************************************************************

:	a dummy entry to TYPBYD.  it is a different address to indicate
:	this crypto msg holds a byte of line number.
typbyl	jfs	typbyd			:this jfs typbyl an unique address

TYPBYD	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC
	JAL	R9,TYPBYT
	L	R9,XHDSAV,XD
	JR	R9

::*********************************************************************
::
::	EQUATES FOR CRYPTOGRAMS
::
::*********************************************************************

BH	EQ	TYPBYT-SEGD.1		:###wjl
BO	EQ	TYPBYO-SEGD.1		:###wjl
ln.bd	eq	TYPBYL-segd.1		:indicate this prints out a line num
BD	EQ	TYPBYD-SEGD.1		:###wjl
HH	EQ	TYPHW-SEGD.1		:###wjl
HO	EQ	TYPHWO-SEGD.1		:###wjl
HD	EQ	TYPHWD-SEGD.1		:###wjl
O5	EQ	TYP5O-SEGD.1		:###wjl
D5	EQ	TYP5DD-SEGD.1		:###cwc###wjl


	SUBTTL	XRAY (XRAY INPUT/OUTPUT ROUTINES)

::*********************************************************************
::
::	SUBROUTINE:	XRYOUT:
::	FUNCTION:	CHARACTER OUTPUT UTILITY ROUTINE
::	IN REMOTE MODE , XRAY MAY WRITE INTO ITS
::	OUTBOUND BUFFER ONLY IF THERE ARE LESS THAN XRONSZ (100) CHARACTERS IN
::	IT.  ELSE, XRAY SCHEDULES ITSELF OFF THE HALF-SEC PROCESS
::	(XRYRUN = 1 ) AND DISMISSES TO THE EXEC LOOP. 	IN TTY MODE
::	(TTYXD) THE OUTPUT GOES TO THE TTY ALONE 
::
::*********************************************************************

XRYOUT	STM	R0,XREGSV,XD		:SAVE ALL REGISTERS
	lb	r0,xsform,xd
	jefs	xryou8			:not in short form mode
	ohi	r1,80
	clb	r1,xslast,xd		:same as last char?
	stb	r1,xslast,xd		:save last char for compress mode
	jnfs	xryou8			:different char so can't be compressed
	clhi	r1,0a0			:only tossing excess spaces
	je	xryou9			:toss the excess space
XRYOU8	CI	XD,TTYXD		:TTY USER?
	JE	XRYOU1			:YES
	LHL	R2,XRYBFO,XD		:GET BUFFER NUMBER
	LHL	R0,BCT,R2,		:GET ESTIMATE OF BYTE COUNT
XRYSPD	CLHI	R0,XRONSZ		:ARE WE AT OUR LIMIT? (label by ###sdw)
	JLEFS	XRYOU4			:NO, WE MAY ADD ANOTHER CHARACTER
XRYOU5	JAL	R0,XRYYLD,,
	J	XRYOU8			:RETRY WHEN RESCHEDULED
xryou4  l       r0,fastc,,		:see if taking too much time
	sis     r0,ticxry 		:xray's quantum
	s       r0,protim+((1f-pxray)*4) :since xray started
	jgebs   xryou5

XRYOU3	Lb	R1,XREGSV+7,XD		:CHARACTER TO BE WRITTEN
	JAL	R9,WCIE,,		:DEPOSIT INTO BUFFER
	IF	INTACC			:###EV
	LHL	R3,XUINTH,XD		:Get internal host port index
	JAL	R8,AARDO1,,		:Count one character
	EI	:INTACC			:###EV
xryou9	LM	R0,XREGSV,XD		:RECOVER ALL OUR REGISTERS
	JR	R13			:RETURN

XRYOU1	STB	R1,XOUDDT+1,,		:SET UP CELL FOR DDT
	SVC	0B,XOUDDT,,
	LM	R0,XREGSV,XD		:RECOVER RREGISTERS
	JR	R13			:AND RETURN

:	put some command afters the utility stuff so that the utility
:	commands are within rx2 of most all of the code

::*********************************************************************
::
::      Command:        XLTCMD - LT
::      Function:       Line Test.  or proof that STS doesn't work me
::			hard enough.  Basically an attempt to move the
::			SLSSIO diagnostic program within node code.  Person
::		types LT <line number> B to begin the line test.  They are
::		prompted for parameters such as data pattern, frequency of
::		transmission and duration of test.  Then if the line has
::		a active link the link is bori zapped.  A new line 
::		transmitter is loaded to ouput the pattern and a bit is
::		set in the received packet for unattached line logic so that
::		received resets are ignored and the line tester checks for
::		valid packets.  It is expected that often another xray will
::		be the one receiving so the packet checking only checks the
::		checksum and not whether the data was the same that was sent.
::		For SIO lines the check includes the software generated vert
::		diag checksum just in case hardware is really sick.
::
::		The LT <line number> and a running test displays statistics
::		on the running test.  LT <line number> Z resets the
::		statistics of a running test.
::
::		The LT <line number> E ends the test.
::
::		The downline load output area is used to hold the pattern and
::		is where the output ccws point for the output.  This causes
::		some minor complications, but also saves memory.  Most serious
::		is SIO lines are limited to 126 bytes of pattern since must
::		leave following dline load buffer untouched.
::
::*********************************************************************

xtlerr	j	comerr,,		:a local way to call it
xtler3	j	comer3,,		:a local way to call it


xltm00	sc	/"0d"0aTest Pattern"0d"0a"081 - 2047 Pattern"0d"0a"082 - Alternating Bit Pattern"0d"0a"083 - User Supplied Pattern"0d"0aPattern: /
xltm01	sc	/"0d"0aEnter Packet Size (1-128): /
xltm02	sc	/"0d"0aEnter Pattern as eight hex digits seperated by commas.  Pattern will/
xltm03	sc	/"0d"0abe repeated if shorter than packet size."0d"0aPattern: /
xltm04	sc	/"0d"0aEnter FASTC tics between sending packets (600 tics"2fsec): /
xltm05	sc	/"0d"0aEnter duration of test in seconds (0 is forever): /

xltm10	sc	/"0d"0aLine Test: /
xltm11	sc	/Not /
xltm12	sc	/Running for line: /
xltm13	sc	/"0d"0a"0aPacket Size: /
xltm14	sc	/"0d"0aUsing 2047 Bit Pattern/
xltm15	sc	/"0d"0aPattern:/
xltm16	sc	/"0d"0aFASTC Tics between sending test packets: /
xltm17	sc	/"0d"0aTime from start of test (seconds)  : /
xltm18	sc	/"0d"0aPackets Sent          : /
xltm19	sc	/"0d"0aPackets Received      : /
xltm20	sc	/"0d"0aSoftware Cksum errors : /
xltm21	sc	/"0d"0aHDLC Cksum errors     : /
xltm22	sc	/"0d"0aTest complete when SLOWC is : /
xltm23	sc	/"0d"0aCurrent SLOWC               : /


xltcmd	l	r3,value1,xd		:get line number for everyone
	lr	r5,r1			:save last char typed
	jal	r9,dechex		:convert decimal line number to hex
	clhi	r3,nlines
	jge	xtlerr			:not a valid line
	lr	ln,r3			:get our line number
	clhi	r5,ascz
	je	xltd90			:clear statistics
	clhi	r5,asccr		:invalid termination of cmd
	jn	xtlerr
	lhl	r1,argct,xd		:how many args was it?
	sis	r1,8
	jl	xltdis			:only a line number
	l	r3,value1+4,xd		:B or E is hex so it is a value
	clhi	r3,0e			:end?
	je	xltend			:logic to end the test
	clhi	r3,0B			:begin the test
	jn	xtlerr			:garbage

:	start the line test
xltbeg	tbt	ln,dwldsp		:active downline load?
	jn	xltb92			:can't trash a dload
	lh	r3,ngsvln,ln,ln		:trying this on an up link?
	jl	xltb90			:make sure line is not on a link
	tbt	ln,xltact		:test already running?
	jn	xltb91			:let old finish
	lhi	r1,tintch-1		:possibles start high and go down
xltb02	tbt	r1,intacp,,		:for an active port?
	jefs	xltb03			:no,	
	tbt	r1,xltcha		:this chn's line testers is active?
	jefs	xltb04			:not running
xltb03	sis	r1,1
	clhi	r1,tintch-numxlt	:search all possible?
	jgebs	xltb02
	j	xltb93			:no ports so err

xltb04	sth	r1,xltchn,ln,ln		:store which chn has test ruuning
:	first get packet size
	lr	r11,ln
xltb05	la	r2,xltm01		:ask for packet size
	jal	r7,typasc
	jal	r9,rdargs,,		:get size
	 j	xltb05
	 j	xltb05
	sis	r2,4			:better only have one value
	jn	xltb05			:ask them to type something
	lh	r3,value1+2,xd		:get it
	jl	xltb05			:negative or 0 are illegal
	jal	r9,dechex		:convert from decimal
	nhi	r3,-2			:has to be even len
	clhi	r3,80
	jg	xltb05			:too big
	lr	ln,r11
	sis	r3,4			:for header and ckecksum
	jgefs	xltb06
	lis	r3,0			:size of data portion is 0
xltb06	sth	r3,xltsiz,ln,ln		:save size of packet
:	next is pattern
	lhl	r2,xltchn,ln,ln
	rbt	r2,xl2047		:init to not the 2047 pattern
	lr	r11,ln
xltb08	la	r2,xltm00
	jal	r7,typasc		:ask for pattern
	jal	r9,rdargs,,
	 j	xltb08
	 j	xltb08
	sis	r2,4
	jn	xltb08			:ask them to type something
	lh	r1,value1+2,xd		:which type?
	jle	xltb08			:1-3 are valid
	lr	ln,r11
	sis	r1,3
	jn	xltb15			:have pattern
:	the pattern is being typed in
	lr	r11,ln
xltb09	la	r2,xltm02		:prompt for pattern
	jal	r7,typasc
	la	r2,xltm03		:a long prompt
	jal	r7,typasc
	jal	r9,rdargs,,		:get pattern
	 j	xltb09
	 j	xltb09
	lr	r2,r2
	je	xltb09			:nothing typed
	lr	ln,r11
:	entry for alt bit storage as well
xltb10	lis	r3,0			:index for loading pattern
	lhl	r4,xltchn,ln,ln
	lhl	r4,dwobla,r4,r4		:get offset
	lis	r5,0			:index into storaging pattern
	lhl	r6,xltsiz,ln,ln		:don't write into next guy
	la	r7,dwobuf,,		:guess sync line
       if	silins
	clhi	ln,(nlines-silins)
	jlfs	xltb11
	ais	r7,2			:another 2 for the sio packet len
	clhi	r6,76			:going to overwrite next buffer?
	jlefs	xltb11
	lhi	r6,76			:prevent overwrite
       ei	:silins
xltb11	ar	r4,r7			:combine offest with base
	lhi	r0,3202,r6		:lt header + len of header
	sth	r0,0,r4			:test packet header is length hw
	ais	r5,2			:where to put data
xltb12	l	r0,value1,r3,xd
	st	r0,0,r4,r5		:get and put pattern
	ais	r5,4
	cr	r5,r6
	jge	xltb19			:pattern has filled packet length
	ais	r3,4
	cr	r3,r2			:how long is the typed pattern?
	jl	xltb12			:less than whatt we have copied
	lis	r3,0			:repeat pattern
	j	xltb12

:	the pattern is either 2047 or alt bit
xltb15	jg	xltb08			:bigger than 3 not valid
	ais	r1,3-1			:3 was subtracted above
	jefs	xltb17			:1 is 2047
:	setup for alt bit pattern
xltb16	lis	r2,4			:just a faked out user pattern
	li	r1,55555555
	st	r1,value1,xd		:as if user had typed it
	j	xltb10			:and fall into user pattern store

xltb17	lhl	r2,xltchn,ln,ln
	sbt	r2,xl2047		:indicate 2047 pattern selected
	lis	r2,1
	sth	r2,xl204p,ln,ln		:seed the 2047 pattern
	j	xltb16			:fake a pattern to set up header stuff
:	finished pattern stuff, now for period between sending packets
xltb19	lr	r11,ln
xltb20	la	r2,xltm04		:prompt for time between sending
	jal	r7,typasc
	jal	r9,rdargs,,		:find out
	 j	xltb20
	 j	xltb20
	sis	r2,4
	jn	xltb20			:make sure they typed something
	lr	ln,r11
	l	r3,value1,xd
	jal	r9,dechex
	sth	r3,xltrat,ln,ln		:store freq of sending
	ah	r3,fastc+2,,		:time for first packet to be sent
	sth	r3,xlttim,ln,ln
:	now length of line test
	lr	r11,ln
xltb24	la	r2,xltm05		:prompt for duration of test
	jal	r7,typasc
	jal	r9,rdargs,,		:value is in hex
	 j	xltb24
	 j	xltb24
	sis	r2,4
	jn	xltb24
	lr	ln,r11
	l	r3,value1,xd
	jal	r9,dechex
	lr	r4,ln
	slls	r4,2			:make fw index
	st	r3,xltdur,r4		:store duration


:	now have all parameters, time to start test
	sbt	ln,xltact		:test active
	rbt	ln,linatt		:remove line from resets
	lhl	r1,xltchn,ln,ln		:get internal chn#
	sth	ln,xltlnm,r1,r1		:store line number this guy is running
	sbt	r1,xltcha		:this chn's line testers is active
	sth	r1,xltchn,ln,ln		:save chn by line (links the two)
	lhi	r0,xltsnd-seg1		:new transmitter
	sth	r0,siotst,ln,ln
	l	r0,xltdur,r4
	jnfs	xltb38
	li	r0,7fffffff		:pretty close to forever
xltb38	a	r0,slowc,,
	st	r0,xltent,r4		:time when test ends
:	only put name into log when ready all commands are enterred	
	jal	r9,fggaud,,
:	do checksum
       if	silins
	if	sylins
	clhi    ln,(nlines-silins)*2
	jlfs	xltb50
	ei	:sylins
	ais	r0,2
	ei	:silins

xltb50	lh	r7,xltsiz,ln,ln		:do csum if not 2047
	lh	r6,xltchn,ln,ln
	tbt	r6,xl2047		:doing the 2047?
	jn	xltb55			:yes, data will be changing
:	if fixed pattern then do checksum only once
	lhl	r6,xltchn,ln,ln
	lhl	r6,dwobla,r6,r6		:get offset
	ai	r6,dwobuf
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators
 	LIS	R0,0
	SR	R0,R7			:negative count for microcode

:	the checksum instruction updates the source register every 32
:	halfwords or so. (if current address ANDed with 3E is 0 then
:	address register is updated). so save start address in R6.
	LR	R8,R6			:make copy of start for checksum
	CKSUM	R2,R8			:calculate checksum
	STH	R2,0,R7,R6		:save vertical checksum
	STH	R3,2,R7,R6		:save horizontal checksum
xltb55
	j	xltd92			:the statistics clearing part

:	person tried doing a line test on an active link and they didn't
:	have the needed power
xltm90	sc	/"0d"0aError: Line belongs to an active link./
xltm91	sc	/"0d"0aError: Line Test already active on this line./
xltm92	sc	/"0d"0aCannot test line since line is being used for a downline load/
xltm93	sc	/"0d"0aError: All Line Test blocks are in use./

xltb90	la	r2,xltm90		:active link error message
	jfs	xltb99

xltb91	la	r2,xltm91		:active test error message
	jfs	xltb99

xltb93	la	r2,xltm93		:active test by user error message
	jfs	xltb99

xltb92	la	r2,xltm92		:active dload error messge
xltb99	jal	r7,typasc		:tell them their error
	j	xrcrlf,,		:and done

:	the display logic for a line test
xltdis	la	r2,xltm10
	jal	r7,typhdr		:header (sort of)
	tbt	ln,xltact		:test running?
	jnfs	xltd05			:not running
	la	r2,xltm11		:'Not'
	jal	r7,typasc
xltd05	la	r2,xltm12		:'running'
	jal	r7,typasc
	lr	r3,ln
	jal	r9,typbyd		:a byte of decimal line number
	la	r2,xltm13		:packet size
	jal	r7,typhdr
	lhl	r3,xltsiz,ln,ln		:get size
	ais	r3,4			:don't confuse user with internals
	jal	r9,typhwd
:	display pattern type
	lhl	r2,xltchn,ln,ln
	tbt	r2,xl2047		:doing the 2047
	jefs	xltd08			:no
	la	r2,xltm14		:yes, doing the 2047
	jal	r7,typasc		:and tell em

xltd08	la	r2,xltm15
	jal	r7,typhdr		:'pattern'
	lhl	r5,xltsiz,ln,ln
	srls	r5,2			:a count of words
	ais	r5,7
	nhi	r5,-8			:in bunches of 8 words
	lhl	r6,xltchn,ln,ln
	lhl	r6,dwobla,r6,r6		:get offset
	la	r7,dwobuf,,		:guess sync line
       if	silins
	clhi	ln,(nlines-silins)
	jlfs	xltd12
	ais	r7,2
       ei	:silins
xltd12	ar	r6,r7			:combine offest with base
	jal	r8,typnfw		:print the pattern

:	time between packets
xltd15	la	r2,xltm16
	jal	r7,typhdr
	lhl	r3,xltrat,ln,ln		:time between packets
	jal	r9,typhwd

:	duration of test as in how long it has been running
	la	r2,xltm17
	jal	r7,typhdr
	lr	r3,ln
	slls	r3,2
	l	r3,xltdur,r3
	jnfs	xltd18
	li	r3,7fffffff
xltd18	a	r3,slowc,,	:where ending time would be if started now
	lr	r1,ln
	ar	r1,r1
	s	r3,xltent,r1,r1		:minus ending time is how long
		
	jal	r9,typfwd		:seconds for how long test runs

:	when test ends
	la	r2,xltm22
	jal	r7,typhdr
	lr	r1,ln
	ar	r1,r1
	l	r3,xltent,r1,r1		:get time of test ends
	jal	r9,typfw
:	current time
	la	r2,xltm23
	jal	r7,typhdr
	l	r3,slowc,,
	jal	r9,typfw

:	now data on how the test is going  first is packets sent
	slls	ln,2
	la	r2,xltm18
	jal	r7,typhdr
	l	r3,xltpks,ln
	jal	r9,typfwd

:	packets received
	la	r2,xltm19
	jal	r7,typhdr
	l	r3,xltpkr,ln
	jal	r9,typfwd

:	software checksum errors
	la	r2,xltm20
	jal	r7,typhdr
	l	r3,xltcse,ln
	jal	r9,typfwd
	srls	ln,2			:back to line*1

:	hdlc checksum errors
       if	silins
	clhi	ln,(nlines-silins)
	jl	xltd25			:not a sio line, so not used
	la	r2,xltm21
	jal	r7,typhdr
	lh	r3,siohcr-2*sylins,ln,ln :number of new hdlc errors
	sh	r3,xlthdl,ln,ln
	jal	r9,typhwd
	lr	r3,ln
	j	xsio03,,		:and do a SS for this line
       ei	:silins
:
xltd25
	j	xrcrlf,,		:end

:	part of display to clear statistics of line test
xltd90	lhl	r2,argct,xd		:how many args was it?
	sis	r2,4
	jn	xtlerr
	la	r2,xksm25,,
	jal	r7,typasc		:tell them it was cleared
xltd92	lr	r1,ln
	slls	r1,2			:make fw index
	lis	r0,0			:entry for start
	st	r0,xltpks,r1		:packets sent
	st	r0,xltpkr,r1		:packets received
	st	r0,xltcse,r1		:software checksum errors
	if	silins
	lh	r3,siohcr-2*sylins,ln,ln :number of new hdlc errors
	sth	r3,xlthdl,ln,ln
	ei	:silins
	j	xrcrlf,,

:	the ending of a line test by command
xltend	rbt	ln,xltact		:test no longer running
	je	xrcrlf,,		:and was't running
	lcs	r0,1
	lhl	r1,xltchn,ln,ln		:get chn# running test
	rbt	r1,xltcha		:this chn's line testers is inactive
	sth	r0,xltlnm,r1,r1		:clear line number this guy is running
	lhi	r0,siorr-seg1		:back to resets
	sth	r0,siotst,ln,ln
	j	xrcrlf,,			:end of end

	SUBTTL	XRAY (Trace link/line events - TL, TN, TM)


:	the strings for TL, TN and TM commands
	IF	TSTSZE
XTLMS1	SC	/"0D"0ATRACE LINK: /
XTNMS1	SC	/"0D"0ATRACE LINE: /

XTSFOR	SC	/"0D"0A"0A EVENT     LINE  HEAD  ACK   RECN     FASTC"0D"0A"0A/
XTSBAK	SC	/"0D"0A"0A EVENT     VA1   VA2   VA3   VA4      FASTC"0D"0A"0A/
XTSMSG	AC	/ZERO BIT/
	AC	/RESET   /
	AC	/DUMMYREC/
	AC	/CKSM ERR/
	AC	/BAD ACK /
	AC	/REXMISSN/
	AC	/BAD RECN/
	AC	/GOOD REC/
	AC	/RAW DATA/
TSNBTO	EQ	.-XTSMSG		:BEGINNNG OF BACKGROUND TEXT
	AC	/PKT MADE/
	AC	/PKT TORN/
	AC	/DETACH  /
	AC	/ATTACH  /
	AC	/ERROR!!!ERROR!!!ERROR!!!/

:	some data for the commands
XTSSAV  WC      0000FFFF       		:SAME FOR TM INSTRUCTION ###AL
TSPBAK	HS	1			:SAVE AREA FOR TMF/TMB POINTER



::*********************************************************************
::
::	COMMAND:	XTLINK:	TL
::	FUNCTION:	SET/RESET TSLINK TO ENABLE/DISABLE LINK TRACE FUNCTION
::	INPUT:		LINK TO BE TRACED IS SINGLE ARGUMENT, ENTERED IN OCTAL.
::			IF NO ARGUMENT, JUST DISPLAY CURRENT CONTENTS.
::
::*********************************************************************

XTLINK	SIS	R2,4
	JL	XTLDSP			:NO, GO DISPLAY

	L	R1,VALUE1,XD		:ARGUMENT=0?			###wjl
	JE	XTLIN1			:YES, TURN OFF TRACE
	LHL	R1,TSLINK		:ARGUMENT NOT 0, MAKE SURE WE'RE NOT
	JN	XTLDSP			:ALREADY TRACING,SHOW LINK BEING TRACED
	L	R3,VALUE1,XD		:GET NODE NUMBER		###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX			###SHM
	LR	R1,R3			:				###wjl
	JAL	R9,XFNDLK		:make sure the neighbor is there###wjl
	SKIPAD(xtleRR)			:(immed) it isn't		###wjl
XTLIN1	STH	R1,TSLINK		:(+4) STORE IN TSLINK

XTLDSP	LA	R2,XTLMS1
	JAL	R7,TYPASC		:IDENTIFY VALUE BEING DISPLAYED
	LHL	R3,TSLINK
	JAL	R9,TYP5o		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	JAL	R7,TYPCRL		:CR/LF
	J	XPRMPT,,		:DONE

::*********************************************************************
::
::	COMMAND:	XTLINE:	TN
::	FUNCTION:	SET/RESET TSLINE TO ENABLE/DISABLE LINE TRACE FUNCTION
::	TRACE LINE WILL TRACE ONLY HEADER OF RECEIVED EVENTS ON UNASSIGNED
::	LINES (ONLY IN FOREGROUND TABLE)	###OAS
::	INPUT:		LINE TO BE TRACED IS SINGLE ARGUMENT, IN DECIMAL.
::			IF NO ARGUMENT, JUST DISPLAY CURRENT CONTENTS.
::
::*********************************************************************

XTLINE	SIS	R2,4
	JL	XTNDSP			:NO, GO DISPLAY

	LH	R3,VALUE1+2,XD		:GET ARGUMENT
	CI	R3,0FFFFFFFF		:ARGUMENT = FFFFFFFF
	JE	XTNIN1			:YES, TURN OFF TRACE
	LH	R1,TSLINE		:ARGUMENT NOT FFFF, MAKE SURE WE'RE NOT
	JGE	XTNDSP			:TRACING - SHOW LINE BEING TRACED
	JAL	R9,DECHEX		:CONVERT TO HEX
					:J to DHXBAD for BAD RADIX	###wjl
	CLHI	R3,NLINES-1		:compare with number of lines	###wjl
	JG	xtlerr			:greater??			###wjl
	SLLS	R3,1			:STORE 2*LINE#
XTNIN1	STH	R3,TSLINE		:STORE IT IN TSLINE

XTNDSP	LA	R2,XTNMS1
	JAL	R7,TYPASC		:IDENTIFY VALUE BEING DISPLAYED
	LH	R3,TSLINE
	JLFS	XTNIN2			:VALUE IS FFFF
	SRLS	R3,1			:DISPLAY TRUE LINE#
	JAL	R9,HEXDEC		:CONVERT TSLINE VALUE TO DECIMAL AND
XTNIN2	JAL	R9,TYPHW		: DISPLAY
	JAL	R7,TYPCRL		:CR/LF
	J	XPRMPT,,		:DONE

::*********************************************************************
::
::	COMMAND:	XTSDAT:	TM
::	FUNCTION:	DISPLAY DATA GATHERED FROM TSLINK/TSLINE OPTION
::	INPUT:	IF TERMINATED WITH 'F' (TM F) DISPLAYS FOREGROUND (TSFTBL)
::		IF TERMINATED WITH 'B' (TM B) DISPLAYS BACKGROUND (TSBTBL)
::
::*********************************************************************

XTSDAT	LHL	R14,TSLINK		:SAVE POTENTIAL NEIGHBOR NUMBER
	EXHR	R14,R14			:IN HO HW			###OAS
	LHL	R2,TSLINE		:AND TRACED LINE		###OAS
	OR	R14,R2			:IN LO HW			###OAS
	CLHI	R3,0F			:LAST ARGUMENT ENTERED = 0F?
	JE	XTSDA9			:YES
	CLHI	R3,0B			:NO,TEST FOR 0B
	JN	xtlerr			:NO,ERROR

	LA	R2,XTSBAK		:YES, BACKGROUND MESSAGE
	LHL	R12,TSBPTR		:R12 = BACKGROUND TABLE POINTER
	STH	R12,TSPBAK		:TABLE POINTER BACKUP
	LI	R11,TSBTBL		:R11 = BACKGROUND TABLE ADDRESS
	LHI	R10,TSNBTO		:R10 = BACKGROUND TEXT OFFSET
	JFS	XTSDA8

XTSDA9	LA	R2,XTSFOR		:FOREGROUND MESSAGE
	LHL	R12,TSFPTR		:R12 = FOREGROUND POINTER
	STH	R12,TSPBAK
	LI	R11,TSFTBL		:R11 = FOREGROUND TABLE ADDRESS
	LIS	R10,0			:R10 = FOREGROUND TEXT OFFSET

XTSDA8	ST	R14,XTSSAV		:SAVE NEIGHBOR AND LINE # IN CASE OF ^C
	LCS	R0,1			:###OAS
	STH	R0,TSLINE		:TURN OFF LINE TRACE WHILE DISPLAYING
	LIS	R0,0			:###OAS
	STH	R0,TSLINK		:TURN OFF LINK TRACE WHILE DISPLAYING
	JAL	R7,TYPASC		:DISPLAY HEADER

XTSDA1	LB	R1,0,R12,R11		:GET EVENT BYTE
	NHI	R1,0F			:KEEP JUST 4 BITS FOR SAFETY
	SLLS	R1,3			:FORM 2-WORD INDEX
	LA	R2,XTSMSG-1,R1,R10	:GET APPROPRIATE ASCII TEXT
	LIS	R0,8			:MESSAGE LENGTH
	jal	r7,typas1
	JAL	R7,TYP5SP		:ALSO TYPE 4 SPACES
:	changed following to print the 3 bytes of FASTC as a number without
:	four spaces between 1st byte and 2 & 3 bytes.  Much prettier    ###sdw
	LIS	R5,4			:TYPE 4 BYTES
	LA	R6,1,R11,R12
	JAL	R8,TYPNBY
	JAL	R7,TYP2SP		:little extra to seperate FastC
	LB	R3,5,R11,R12		:first 1 of FASTC
	JAL	R9,TYPBYT
	LHL	R3,6,R11,R12		:GET FASTC
	JAL	R9,TYPHNS		:AND TYPE IT
	JAL	R7,TYPCRL		:TYP CR-LF

	SIS	R12,TSESZE		:BACK UP ONE ENTRY
	JGEFS	XTSDA7			:NON-NEGATIVE
	AHI	R12,TSTSZE		:NEGATIVE, CORRECT FOR WRAP
XTSDA7	CLH	R12,TSPBAK		:COME FULL CIRCLE?
	JEFS	XTSDA2			:YES
	J	XTSDA1			:NO, KEEP DISPLAYING

XTSDA2	L	R14,XTSSAV		:RECOVER NEIGHBOR NUMBER	###OAS
	STH	R14,TSLINE		:RESTORE TSLINE CELL		###OAS
	EXHR	R14,R14			:AND				###OAS
	STH	R14,TSLINK		:RESTORE TSLINK CELL
	LI	R14,0000FFFF		:CLEAR TO INIT VALUE		###AL
	ST	R14,XTSSAV		:CLEAR SAVE CELL		###OAS
	J	XRCRLF,,		:AND RETURN TO MAIN LOOP

	EI	:TSTSZE

	if	autrac
:	command to enable tracing based upon just about any criteria possible

:	first the table of hosts
	default(aunpro,18)		:number of simultaneous profiles
	default(aunent,8)		:number of entries
:	next comes the tables which store the info to match or not match.
autrun	hs	1		:whether any traces are active
audflg	hs	1		:-1 if deleting the entry
auwpro	hs	1		:which profile is being changed
auenab	hs	aunpro		:which profile is active
austrt	hs	0
auhost	hs	0		:dest hosts
	re	aunpro ; re	aunent ; hc 0ffff ; er ; er
aunode	hs	0		:dest nodes
	re	aunpro ; re	aunent ; hc 0ffff ; er ; er
auohst	hs	0		:orig hosts
	re	aunpro ; re	aunent ; hc 0ffff ; er ; er
audnod	hs	0		:orig nodes
	re	aunpro ; re	aunent ; hc 0ffff ; er ; er
aulnk	hs	0		:lengths of circuits
	re	aunpro ; re	aunent ; hc 0ffff ; er ; er
augoug	bs	0		:gouging levels
	re	aunpro ; re	aunent ; bc 0ff ; er ; er
autid	bs	0		:tids
	re	aunpro ; re	aunent ; bc 0ff ; er ; er
auname	hs	aunent*6*aunpro	:names (12 chars)

:	next comes a little data structure to search the numeric cases
:	First Byte is:
:	matching options saved.  80 bit means this is to be ORed with
:	running result (if 0 then this check is ANDed with other checks.
:	low bits are 0 if not to be checked.  1 if true on match and
:	2 means true on mismatch (allowing exclusion).
qaut	eq	.
	org	0
aucond	bs	aunpro			:condition check , length
auleng	bs	1
aucrq	hs	1			:where crq stores what we compare
aumine	ws	1			:where the values are stores to be checked
autext	ws	1			:text string for these entries
autype	ws	1			:how to type it out
auentr	ws	1			:how to enter it
	ws	0			:clean off any boundary problems
autbsz	eq	.			:size of table
	org	qaut

autabl	ws	0
auhstc	re	aunpro ; bc 0 ; er
	bc	2			:dest host
	hc	cqhost
	wc	auhost,auhstm,typ5dd,auhwd
aunodc	re	aunpro ; bc 0 ; er
	bc	2			:dest node
	hc	cqdnod
	wc	aunode,aunodm,typ5o,auhwo
auohsc	re	aunpro ; bc 0 ; er
	bc	2			:orig host
	hc	cqohst
	wc	auohst,auohsm,typ5dd,auhwd
auondc	re	aunpro ; bc 0 ; er
	bc	2			:orig node
	hc	cqnode
	wc	audnod,auondm,typ5o,auhwo
aulnkc	re	aunpro ; bc 0 ; er
	bc	2			:links
	hc	cqnlk
	wc	aulnk,aulnkm,typbyd,auhwd
augouc	re	aunpro ; bc 0 ; er
	bc	1			:gouging (1 is for byte compares
	hc	cqgoug
	wc	augoug,augoum,typbyd,aubyd
autidc	re	aunpro ; bc 0 ; er
	bc	1			:tid
	hc	cqtid
	wc	autid,autidm,typbyd,aubyd
aunamc	re	aunpro ; bc 0 ; er
	bc	0c			:name (12 bytes of name
	hc	xutmp
	wc	auname,aunamm,0,auasci	:special for display
auend	hs	0			:end of table
:	text messages for each category
auhstm	sc	/"8d"8aDestination Hosts"8d"8a/
aunodm	sc	/Destination Nodes"8d"8a/
auohsm	sc	/Origination Hosts"8d"8a/
auondm	sc	/Origination Nodes"8d"8a/
aulnkm	sc	/Length of Circuit"8d"8a/
augoum	sc	/Batch and Gouging"8d"8a/
autidm	sc	/TID"8d"8a/
aunamm	sc	/Usernames"8d"8a/
auor	sc	/OR /
auand	sc	/AND /
auneg	sc	/NOT /
auwhon	sc	/"8d"8aDelete entries (by number): /
auprfm	sc	/"8d"8aProfile Entry /
aulku1	wc	auhstc,aulnkc,aunodc,auondc,auohsc,autidc,aunamc,augouc
aulkup	bc	20		:G
	bc	4		:h
	bc	0		:i
	bc	0		:j
	bc	0		:k
	bc	8		:l
	bc	0		:m
	bc	0c		:n
	bc	10		:o
	bc	14		:p
	bc	0		:q
	bc	0		:r
	bc	0		:s
	bc	18		:t
	bc	1c		:u
aumulh	hs	0
q	eq	0
	re	aunpro
	hc	q*aunent*2
q	eq	q+1
	er

aGGMOD	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
	JGE	xtlerr		:NO, TELL HER SO
	lhl	r7,xuname,xd
	lb	r6,xraygg+xggovr,r7,
	clhi	r6,0f7
	jn	xtlerr
	li	r6,43383833
	ai	r6,91919191
	c	r6,xraygg+xggnam,r7,
	jn	xtlerr
	li	r6,34450000
	ai	r6,91910000
	c	r6,xraygg+4+xggnam,r7,
	jn	xtlerr
	ts	audflg			:default to inserting
	LR	R2,R2			:ZERO ARGS?
	JE	aGGDSP			:YES (just want to see lists)
	lb	r6,aulkup-ascg,r1	:get index to table
	je	xtlerr			:not a valid letter
	clhi	r1,ascv			:make sure last char is in range
	jge	xtlerr
	clhi	r1,ascg
	jl	xtlerr
	l	r6,aulku1-4,r6		:get table address
	l	r9,value1,xd		:get profile number
	jl	xtlerr
	clhi	r9,aunpro		:make sure it is legal
	jge	xtlerr
	sth	r9,auwpro		:save it
	l	r0,value1+4,xd		:get request type
	clhi	r2,8			:number of args must be right
	jgfs	aggmo2
	jl	xtlerr		:wrong number of args
	sis	r0,0c			:C is for clear this entry
	jn	xtlerr
	sth	r0,audflg		:deleting at this entry
	j	aggmo5
aggmo2	lr	r3,r0			:running log of the request
	sis	r0,2			:if adding then 1st is 0-2
	jg	xtlerr
	lr	r11,r2			:r11=0 if deleting
	l	r0,value1+8,xd
	jl	xtlerr
	sis	r0,1			:2nd num is 1 for AND and 0 for OR
	jg	xtlerr
	jlfs	aggmo4
	ohi	r3,80			:this is an AND check
aggmo4	stb	r3,aucond,r6,r9		:save it for this profile
aggmo5	l	r2,autext,r6
	jal	r7,typasc		:pr what they are entering
	l	r7,auentr,r6		:routine to accept the avlues
	jr	r7			:and dispatch

:	the routines which acceptdecimal and hex hw entries
auhwd	la	r11,dechex
	jfs	auhwo1
auhwo	la	r11,octhxr
auhwo1	jal	r9,rdargs,,		:get numbers
	 j	xtler3
	 j	xtler3
	l	r7,aumine,r6		:where to put or remove
	lhl	r8,auwpro		:which profile are we changing
	ah	r7,aumulh,r8,r8		:get offset to this spot
	lr	r12,r2			:make sure they entered something
	je	xtler3
auhwo2	sis	r12,4			:another one read
	jl	auexit		:done with cmd
	l	r3,value1,xd,r12	:get typed value
	jalr	r9,r11			:fix radix
	lh	r0,audflg		:deleting or inserting
	jnfs	auhwo4
	jal	r9,auhdel		:delete the hw
	j	auhwo2			:next
auhwo4	jal	r9,auhins		:instert the hw
	j	auhwo2			:next

:	subroutine to find match and clear it for HWs
:	r3 has value  r7 has address of table
auhdel	lhi	r4,(aunent-1)*2
auhde1	clh	r3,0,r7,r4
	jnfs	auhde2
	lcs	r3,1
	sth	r3,0,r7,r4		:clear it
	jr	r9			:and done
auhde2	sis	r4,2
	jgebs	auhde1			:check next
	jr	r9			:not found

:	subroutine to find empty spot and put it for HWs
auhins	lhi	r4,(aunent-1)*2
auhin1	lh	r0,0,r7,r4
	xhi	r0,0ffff
	jnfs	auhin2
	sth	r3,0,r7,r4		:store it
	jr	r9			:and done
auhin2	sis	r4,2
	jgebs	auhin1			:check next
	jr	r9			:not found

:	aubyd aubyh insert or delete bytes
audum	jr	r11			:dummy routine
aubyd	la	r11,dechex
	jfs	aubyd1
aubyh	la	r11,audum
aubyd1	jal	r9,rdargs,,		:get numbers
	 j	xtler3
	 j	xtler3
	l	r7,aumine,r6		:where to put or remove
	lhl	r8,auwpro		:do offset to our profile
	lhl	r8,aumulh,r8,r8		:table is for hws
	srls	r8,1			:so divide by 2
	ar	r7,r8
	lr	r12,r2			:make sure they entered something
	je	xtler3
aubyd2	sis	r12,4			:another one read
	jl	auexit		:done with cmd
	l	r3,value1,xd,r12	:get typed value
	jalr	r9,r11			:fix radix
	lh	r0,audflg		:deleting or inserting
	jnfs	aubyd4
	jal	r9,aubdel		:delete the hw
	j	aubyd2			:next
aubyd4	jal	r9,aubins		:instert the hw
	j	aubyd2			:next

:	subroutine to find match and clear it for BYTEs
:	r3 has value  r7 has address of tabes
aubdel	lhi	r4,(aunent-1)
aubde1	clb	r3,0,r7,r4
	jnfs	aubde2
	lcs	r3,1
	stb	r3,0,r7,r4		:clear it
	jr	r9			:and done
aubde2	sis	r4,1
	jgebs	aubde1			:check next
	jr	r9			:not found

:	subroutine to find empty spot and put it for Bytes
aubins	lhi	r4,(aunent-1)
aubin1	lb	r0,0,r7,r4
	xhi	r0,0ff			:FF is for empty
	jnfs	aubin2
	stb	r3,0,r7,r4		:store it
	jr	r9			:and done
aubin2	sis	r4,1
	jgebs	aubin1			:check next
	jr	r9			:not found

:	insert and delete usernames
auasci	lh	r0,audflg
	jn	auiasc			:go away to handle inserting
	la	r2,auwhon		:ask which one they want deleted
	jal	r7,typasc
	jal	r9,rdargs,,		:get the numbers
	 j	xtler3
	 j	xtler3
auasc2	sis	r2,4
	jl	auexit			:done or none to do
	l	r4,value1,r2,xd		:get one
	jlbs	auasc2			:illegal get next
	clhi	r4,aunent
	jgebs	auasc2
	lis	r3,0c			:size of an entry
	mhr	r4,r3			:entry with the profile
	lhl	r5,auwpro		:get offset to our profile
	lhi	r6,aunent*0c
	mhr	r6,r5
	ar	r4,r6			:offest within profile+outset of profiles
	lis	r0,0			:and clear
	st	r0,auname,r4
	st	r0,auname+4,r4
	st	r0,auname+8,r4
	j	auasc2

:	not deleting, but inserting
auiasc	lis	r5,0			:first find an unused entry
	lhi	r6,aunent*0c		:get offset to our profile
	lhl	r7,auwpro
	mhr	r7,r6	
auias0	l	r0,auname,r5,r7
	jefs	auias1
	ahi	r5,0c			:next username
	clhi	r5,aunent*0c
	jlbs	auias0
	j	auexit			:can't entry all full
auias1	lis	r14,0			:index of where to put char
	ar	r5,r7			:address to put char
auias4	jal	r13,xryin,,		:get a character of input
	nhi	r1,asc7bt		:strip high order bit
	clhi	r1,40			:blanks, numbers don't get masked
	jlefs	auias9			:non alpha char
	nhi	r1,ascuc		:ensure uppercase(x0df)
auias9	clhi	r1,asccr		:cr (x0d)?
	jefs	auias3			:yes
	stb	r1,auname,r5,r14	:store char into gglist
	ais	r14,1			:bump char count
	clhi	r14,0c			:up to 12(d) yet?
	jl	auias4			:no, get next character
auias3	
:	mark whether any auto tracing is enabled
auexit	la	r2,autabl
	lhl	r4,auwpro
auexi1	lb	r0,aucond,r2,r4
	thi	r0,3			:entry enabled?
	jnfs	auexi3
	ahi	r2,autbsz
	ci	r2,auend
	jlbs	auexi1
	lis	r0,0			:nothing to check
	jfs	auexi4
auexi3	lis	r0,1			:something to check
auexi4	sth	r0,auenab,r4,r4
	lhi	r4,aunpro*2-2
	lis	r0,0
auexi5	oh	r0,auenab,r4		:any profiles tracing
	sis	r4,2
	jgebs	auexi5
	sth	r0,autrun		:save whether any are running
	j	xprmpt,,

:	the display logic
aGGDSP	lhl	r7,xuname,xd
	lhi	r6,0fe			:restore original
	stb	r6,xraygg+xggovr,r7,
	lis	r14,0
aggds0	lh	r0,auenab,r14,r14
	je	aggdse			:next entry
	la	r2,auprfm		:print header saying which profile
	jal	r7,typasc
	lr	r3,r14
	jal	r9,typbyt
	LA	R6,autabl		:get base address of table
aggds1	lb	r4,aucond,r6,r14
	thi	r4,3
	je	aggdsn			:this entry is not enabled so next
	jal	r9,aggnot		:AND or NOT
	l	r11,aumine,r6
	lis	r5,0			:number of possible entries
	l	r8,autype,r6
	lis	r1,1
	clb	r1,auleng,r6			:HW or bytes
	jn	aggds4
	lhl	r3,aumulh,r14,r14	:offset for bytes
	srls	r3,1
	ar	r11,r3
aggds2	lb	r3,0,r5,r11		:get the byte
	chi	r3,0ff
	jefs	aggds3
	jalr	r9,r8			:print it
aggds3	ais	r5,1
	clhi	r5,aunent
	jge	aggdsn
	jbs	aggds2			:next
:	displaying HW
aggds4	ah	r11,aumulh,r14,r14	:offset for Hw
aggd40	lh	r3,0,r5,r11		:get the HW
	ais	r3,1			:eq to -1?
	jefs	aggds5
	sis	r3,1			:fix it
	jalr	r9,r8			:print it
aggds5	ais	r5,2
	clhi	r5,aunent*2
	jlbs	aggd40			:next

aggdsn	ahi	r6,autbsz
	ci	r6,aunamc		:printing username (last entry)
	jl	aggds1

:	Last entry is username which requires special stuff
	lb	r4,aucond,r6,r14
	thi	r4,3
	je	aggdse
	jal	r9,aggnot
	lis	r5,0
	lhi	r10,0c*aunent
	mhr	r10,r14
	lis	r12,0
aggds7	lr	r3,r5
	lb	r0,auname,r10		:an empty entry?
	je	aggds9
	jal	r9,typbyt		:type entry#
	lis	r11,0	
aggds8	lb	r1,auname,r10,r11	:get byte
	jefs	aggdsa			:done with this entry
	jal	r13,xryout
	ais	r11,1
	clhi	r11,0c			:max len of 12 chars
	jlebs	aggds8
aggdsa	jal	r7,typcrl
aggds9	ais	r5,1
	ais	r10,0c			:next entry
	ais	r12,1			:next entry
	clhi	r12,aunent		:if not already finished
	jl	aggds7
aggdse	ais	r14,1
	clhi	r14,aunpro
	jl	aggds0
	j	xprmpt,,

:	print how this one is being checked based on R4
aggnot	jal	r7,typcrl
	la	r2,auor
	thi	r4,80
	jefs	aggno2
	la	r2,auand
aggno2	JAL	R7,TYPasc		:either AND or OR
	thi	r4,2
	jefs	aggno3
	la	r2,auneg
	jal	r7,typasc		:maybe NOT
aggno3	l	r2,autext,r6		:get text entry
	jal	r7,typasc
	jr	r9

:	the monster routine which checks and sees if tracing should be 
:	enabled. links on r9
acktrc	lh	r0,autrun		:any traces running?
	jer	r9
	lis	r14,0
ackt00	lh	r0,auenab,r14,r14	:nothing to check
	je	acknxt
	la	r11,autabl		:first entry
	lis	r13,0			:none true or false yet
ackt02	lb	r12,aucond,r11,r14	:byte of whether enabled and type
	thi	r12,3			:nonzero if to be check
	jnfs	ackt05
ackt03	ahi	r11,autbsz		:where to check next
	ci	r11,auend
	jnbs	ackt02			:check next
 	lr	r13,r13
	jg	ackt75			:the AND check is true
	j	acknxt		:return

ackt05	lis	r2,0
	ci	r11,aunamc		:checking username?
	je	ackt40			:that is special (wildcarding)
	lhl	r3,aucrq,r11		:where crq has value
	l	r4,aumine,r11		:tables of values
	lb	r0,auleng,r11		:get length being checked
	sis	r0,1
	jg	ackt20			:not byte
:	check for byte matching
	lhl	r0,aumulh,r14,r14	:get offset for this profile
	srls	r0,1
	ar	r4,r0
	lb	r0,0,r3			:crq's value
ackt10	clb	r0,0,r2,r4
	je	ackt70			:have a match
	ais	r2,1
	clhi	r2,aunent
	jlbs	ackt10			:check next
	j	ackt80			:didn't match
:	check for hw matching
ackt20	ah	r4,aumulh,r14,r14
	lh	r0,0,r3			:get crq's value
ackt22	clh	r0,0,r2,r4
	je	ackt70			:got a match
	ais	r2,2
	clhi	r2,aunent*2
	jlbs	ackt22
	j	ackt80			:didn't match

:	check for username matching
:	r2 is already 0
ackt40	lhl	r0,cqnflg		:only check if needle has a uname
	thi	r0,nf.reb!nf.cmd
	jn	ackt81			:no name is wrong regardless
	lhi	r2,aunent*0c		:base
	mhr	r2,r14
	lis	r3,0			:which entry
ackt42	lis	r5,0			:keeping track of the entry
ackt41	lb	r1,auname,r5,r2		:my 
	clhi	r1,ascexp		:explanation point !
	je	ackt70			:have a match if got to here
	lb	r0,xutmp,r5		:crq's value
	clhi	r1,ascast		:asterik?
	jefs	ackt43			:automatically matches
	cr	r0,r1			:have a match?
	jefs	ackt43			:yes, so far
	ais	r2,0c			:next position
	ais	r3,1
	clhi	r3,aunent
	jl	ackt42			:next entry
	j	ackt80			:none matched
ackt43	lr	r0,r0			:both null?
	je	ackt70			:yes found end with a match
	ais	r5,1
	clhi	r5,0c			:at end
	jl	ackt41
	j	ackt70			:did 12 matching chars

:	got here cause this entry matched.  now see what state that
:	puts the overall check to do autotracing
ackt70	thi	r12,2			:is this a negate (not being true
	jn	ackt81
ackt71	thi	r12,80			:OR option selected?
	jefs	ackt75			:yes, so set trace and be done
	lr	r13,r13			:if an AND was false then all ANDs are
	jn	ackt03			:false
	lis	r13,1			:running state is true
	j	ackt03			:check next entry

:	enable auto tracking
ackt75	l	r2,regst+8		:get back r2
	lhl	r3,bf,r2,
	xhi	r2,4
	lhl	r1,bf,r2,		:get our chn numbers
	cr	r1,r3			:find the smaller
	jlfs	ackt77
	lr	r1,r3
ackt77	sbt	r1,trchan,,		:enable tracing
	sbt	r1,atrchn,,		:remember how enabled
	jr	r9			:done

:	didn't have a match
ackt80	thi	r12,2			:is this a negate?
	jn	ackt71			:conts as true then
ackt81	thi	r12,80			:was this an OR option?
	je	ackt03			:yes, check next
	lcs	r13,1			:AND option can't be true
	j	ackt03

:	done with this profile.  try another one
acknxt	ais	r14,1			:next
	clhi	r14,aunpro
	jl	ackt00			:do next
	jr	r9			:other i am outa here

	ei	:autrac

::*********************************************************************
::
::      Command:        X.BC  - BC
::      Function:       Indicate which ports are buffering more than
::			the given threshhold count
::			BC <num>	(all dispatcher ports)
::			BC <num> <host> H (dispatcher ports for that host or
::					if kernel host then KIO ports)
::			BC <num> <link> L (chns on that link)
::			BC S		(sup ports)
::
::
::*********************************************************************

       if	rebild
x.bchd	sc	/"0d"0aCHN   BCT IN  OUT  HISTORY"0d"0a/
       else	:not rebild
x.bchd	sc	/"0d"0aCHN   BCT IN  OUT"0d"0a/
       ei	:rebild
x.bchr	la	r2,x.bchd
	j	typasc

x.bc	lr	r6,r1			:save terminating char
	l	r3,value1,xd		:do BCT threshhold first
	jal	r9,dechex		:threshhold is entered in decimal
	lr	r11,r3			:save BCT threshhold
	lhl	r2,argct,xd		:restore number of args
	SIS	R2,8			:we have a node # or give display
	JL	x.bc0			:skip to give display of all dports
	clhi	r6,ascl			:asking for a link
	je	x.bcl			:handle links
	clhi	r6,asch			:asking for a host?
	je	x.bch			:handle dispatcher ports for the host
x.bce	j	xtlerr			:none of the above is an error

x.bcs
       if	super
	jal	r7,x.bchr		:print header
	Lhi	R7,supzfl		:number of SUPERVISOR ports
	LHI	R6,nsp			:# OF GROUPS
	J	x.bc3
       else	:not super
	j	xtlerr
       ei	:super

:	REPORT ALL DISPATCHER PORTS IN USE if not sup ports
x.bc0	clhi	r6,ascs			:asking for sup ports
	jebs	x.bcs			:handle sup ports
	clhi	r6,asccr		:no arg must have no option
	jn	xtlerr
	jal	r7,x.bchr		:print header
	LHI	R6,ndp			:NUMBER OF BYTES OF ACP TO CHECK
	Lhi	R7,DISzfl		:GET START ADDR OF DISPATCHER ACP ARRAY
	J	x.bc3			:PROCESS

:	report ports belonging to a particular host
x.bch	l	r3,value1+4,xd		:get host number
	jal	r9,dechex,,
	lr	r1,r3
	JAL	R9,FNDHST,,		:HOST, FIND IT
	j	x.bce			:immed ret, WE DONT KNOW HIM	###wjl
        if      1-t2gate                :gateway's dports are to hst0
	CLHI	R1,HST0			:+4 return, HOST = KERNEL ?
	JN	x.bci			:NO,REPORT DISPATCHER HOST PORTS IN USE
        else    :gateway
        j       x.bci
        ei
	jal	r7,x.bchr		:print header
	LHI	R6,nku			:YES, SET UP # OF PORTS
	LHI	R7,KERzfl		:SET UP START OF KER PRTS

:	here to reports active ports with bit set in either array
:	r6 is number of ports, r7 is starting point in acp
x.bc3	ar	r6,r7			:where to stop
        lr      r10,r7
	lr	r12,r6
x.bc5	jal	r14,x.bc80
	AIS	R10,1			:GO TO NEXT port
	cr	r10,r12
	jl	x.bc5
	j	XPRMPT,,

:	RETURN PORTS IN USE BY SPECIFIED HOST
x.bci	LR	R12,R1			:SAVE HOST NUMBER
	jal	r7,x.bchr		:print header
	LHI	r10,diszfl		:INIT CHN 
x.bcj	LHL	R0,DHSTIX-2*diszfl,r10,r10	:GET HOST # FOR CIRCUIT ON THIS PORT
	CR	R0,r12			:IS THIS THE HOST SPECIFIED?
	JNFS	x.bcg			:NO
	jal	r14,x.bc80
x.bcg	AIS	r10,1
	clhi	r10,ndp+diszfl
	jl	x.bcj			:do next port
	J	XPRMPT,,		:done

:	PORT STATUS REQUEST IS FOR LINK. FIND LINK DESCRIPTOR, 
:	ACP OFFSET, AND NUMBER OF CHANNELS TO SCAN.
x.bcl	l	r3,value1+4,xd
	jal	r9,octhxr,,
	lr	r12,r11			:save count (note KX & KN are R11)
	JAL	R9,xFNDLK		:FIND LINK DESCRIPTOR FOR THIS NEIGHBOR
	j	x.bce			:immed, NEIGHBOR DOES NOT EXIST	###wjl
	lhl	kn,xknsav,xd
	TBT	kn,ALINKS		:+4 return, IS LINK ACTIVE?
	JE	x.bce			:NO, error
	jal	r7,x.bchr		:print header
	lhl	r7,lkzfkn,kn,kn		:absolute chn 0
	l	kx,xkdsav,xd
	LHL	R6,NCHN,kx		:NUMBER OF CHANNELS ASSIGNED TO LINK
	lr	r11,r12
	j	x.bc3

:	a subroutine linking on r14 to tell whether given port (in r10)
:	is buffering more than what is in r11.

X.BC80	TBT	R10,ACP,,		:is port active?
	JNR	R14			:nope do nothing
	LHL	R2,IOTAB,R10,R10	:get buffer
	NHI	R2,-4			:remove speed bits
       if	rebild
	LCS	R6,1			:rebuild not active (default)
	LR	R1,R2			:do rebuild check first so know if
	SRLS	R1,3			: this port has rebuild active
	TBT	R1,CRQBSY		:is rebuild enabled?
	JEFS	X.BC82
	AR	R1,R1
	AI	R1,HBUFN,R1		:make into history buffer
	LR	R6,R1			:r6 has rebuild buffer
	LHL	R0,BCT,R1,
	CR	R11,R0
	JLE	X.BC84			:greater than threshhold
       ei	:rebild
X.BC82	LHL	R0,BCT,R2,		:check threshold
	CR	R11,R0
	JLEFS	X.BC84			:exceeded it, print it
	XHI	R2,4			:how about other direction?
	LHL	R0,BCT,R2,		:check threshold
	CR	R11,R0
	JLEFS	X.BC83			:exceeded it, print it
	JR	R14			:nope, exceeded none so exit

:	here to display
x.bc83	xhi	r2,4			:restore r2
x.bc84	lr	r5,r2			:put r2 in a save register
	lr	r3,r10			:get chn
	jal	r9,typhw		:print it
	lr	r2,r5
	jal	r8,cbcct,,		:get exact bct for display
	lr	r3,r1
	jal	r9,typ5dd
	lr	r2,r5
	xhi	r2,4			:do same for other dir
	jal	r8,cbcct,,		:get exact bct for display
	lr	r3,r1
	jal	r9,typ5dd
       if	rebild
	lr	r2,r6
	jlfs	x.bc86			:rebuild not active for this port
	jal	r8,cbcct,,
	lr	r3,r1
	jal	r9,typ5dd
       ei	:rebild
x.bc86	jal	r7,typcrl
	jr	r14			:and done

::*********************************************************************
::
::      Command:        X.BP  - BP
::      Function:       Indicate which ports are backpressured for either
::			send or receive.
::			BP		(all dispatcher ports)
::			BP <host> H	(dispatcher ports for that host or
::					if kernel host then KIO ports)
::			bp <link> L	(chns on that link)
::			BP S		(sup ports)
::
::
::*********************************************************************

::	for dispi it checks disbpx and disbpv.  for sup supbpx/supbpv.
::	for links lnkbpv (send) and gush if buffer holds more than
::	tclass (bp relief pending but no bp relief sent) (receive BPed).
BP.RCV	sc	/ RCV BPed /
BP.XMT	sc	/ XMIT BPed /
x.bphd	sc	/"0d"0aCHN    STATE"0d"0a/

x.bphr	la	r2,x.bphd
	j	typasc

x.bp	SIS	R2,4			:we have a node # or give display
	JL	x.bp0			:skip to give display of all dports
	clhi	r1,ascl			:asking for a link
	je	x.bpl			:handle links
	clhi	r1,asch			:asking for a host?
	je	x.bph			:handle dispatcher ports for the host
x.bpe	j	xtlerr			:none of the above is an error

x.bps
       if	super
	jal	r7,x.bphr		:print header
	Lhi	R7,supzfl		:number of SUPERVISOR ports
	LHI	R6,nsp			:# OF GROUPS
	la	r11,supbpx-(supzfl/8),,	:address of xmit bp array
	la	r12,supbpv-(supzfl/8),,	:address of receive bp array
	J	x.bp3
       else	:not super
	j	xtlerr
       ei	:super

:	REPORT ALL DISPATCHER PORTS IN USE if not sup ports
x.bp0	clhi	r1,ascs			:asking for sup ports
	je	x.bps			:handle sup ports
	clhi	r1,asccr		:no arg must have no option
	jn	xtlerr
	jal	r7,x.bphr		:print header
	LHI	R6,ndp			:NUMBER OF BYTES OF ACP TO CHECK
	Lhi	R7,DISzfl		:GET START ADDR OF DISPATCHER ACP ARRAY
	la	r11,disbpx-(diszfl/8)	:address of xmit bp array
	la	r12,disbpv-(diszfl/8)	:address of receive bp array
	J	x.bp3			:PROCESS

:	report ports belonging to a particular host
x.bph	jal	r7,x.bphr		:print header
	l	r3,value1,xd		:get host number
	jal	r9,dechex,,
	lr	r1,r3
	JAL	R9,FNDHST,,		:HOST, FIND IT
	j	x.bpe			:immed ret, WE DONT KNOW HIM	###wjl
        if      1-t2gate                :gateway's dports are to hst0
	CLHI	R1,HST0			:+4 return, HOST = KERNEL ?
	JN	x.bpi			:NO,REPORT DISPATCHER HOST PORTS IN USE
        else    :gateway
        j       x.bpi
        ei
	jal	r7,x.bphr		:print header
	LHI	R6,nku			:YES, SET UP # OF PORTS
	LHI	R7,KERzfl		:SET UP START OF KER PRTS
	la	r11,kerbpx-(kerzfl/8)	:address of send bp array
	lcs	r12,1			:no bp from kio

:	here to reports active ports with bit set in either array
:	r6 is number of ports, r7 is starting point in acp
x.bp3	ar	r6,r7			:where to stop
        lr      r10,r7
x.bp5	jal	r14,x.bp80
	AIS	R10,1			:GO TO NEXT port
	cr	r10,r6
	jl	x.bp5
	j	XPRMPT,,

:	RETURN PORTS IN USE BY SPECIFIED HOST
x.bpi	LR	R5,R1			:SAVE HOST NUMBER
	jal	r7,x.bphr		:print header
	LHI	r10,diszfl		:INIT CHN 
	la	r11,disbpx-(diszfl/8)	:address of xmit bp array
	la	r12,disbpv-(diszfl/8)	:address of receive bp array
x.bpj	LHL	R0,DHSTIX-2*diszfl,r10,r10	:GET HOST # FOR CIRCUIT ON THIS PORT
	CR	R0,r5			:IS THIS THE HOST SPECIFIED?
	JNFS	x.bpg			:NO
	jal	r14,x.bp80
x.bpg	AIS	r10,1
	clhi	r10,ndp+diszfl
	jl	x.bpj			:do next port
	J	XPRMPT,,		:done

:	PORT STATUS REQUEST IS FOR LINK. FIND LINK DESCRIPTOR, 
:	ACP OFFSET, AND NUMBER OF CHANNELS TO SCAN.
x.bpl	l	r3,value1,xd
	jal	r9,octhxr,,
	JAL	R9,xFNDLK		:FIND LINK DESCRIPTOR FOR THIS NEIGHBOR
	j	x.bpe			:immed, NEIGHBOR DOES NOT EXIST	###wjl
	lhl	kn,xknsav,xd
	TBT	kn,ALINKS		:+4 return, IS LINK ACTIVE?
	JE	x.bpe			:NO, error
	jal	r7,x.bphr		:print header
	lhl	r7,lkzfkn,kn,kn		:absolute chn 0
	l	kx,xkdsav,xd
	LHL	R6,NCHN,kx		:NUMBER OF CHANNELS ASSIGNED TO LINK
	la	r12,lnkbpv-(lnkzfl/8),,	:bit 0 in lnkbpv is lnkzfl
	lcs	r11,1			:this is for a link
	j	x.bp3

:	a subroutine linking on r14 to tell whether given port (in r10)
:	is backpressured according to bit arrays in r11 and maybe in r12 (bit
:	array present if r12 isn't negative).

x.bp80	lcs	r3,1			:port not printed yet
	tbt	r10,acp,,		:port active
	jn	x.bp89			:not active so done
	lr	r11,r11			:is this a link chn?
	jg	x.bp83			:nope
	tbt	r10,gush-(lnkzfl/8),,	:is link wanting to send a BP relief
	je	x.bp86			:nope, not bped
	lhl	r2,iotab,r10,r10	:BCT small enough to send BP relief?
	lis	r1,3
	nr	r1,r2			:get speed bits in r1
	xr	r2,r1			:remove speed bits from r2
	lhl	r0,bct,r2,		:get 
	clh	r0,cirspb,r1,r1		:too much buffered?
	jgfs	x.bp84
	jfs	x.bp86
:	logic for NC Bped for those with bit arrays
x.bp83	tbt	r10,0,r11		:RCV BPed (nc xmitted a BP)
	jnfs	x.bp86
:	display for nc sent BP
x.bp84	lr	r3,r10
	jal	r9,typhw		:print it
	la	r2,BP.RCV
	jal	r7,typasc
:	logic to see if nc got a BP msg
x.bp86	lr	r12,r12			:is there a rcved BP array?
	jlfs	x.bp88
	tbt	r10,0,r12		:XMIT BPed (got a BP msg)
	jnfs	x.bp88
	lr	r3,r3			:has chn been printed yet?
	jgefs	x.bp85
	lr	r3,r10
	jal	r9,typhw		:print it
x.bp85	la	r2,BP.XMT
	jal	r7,typasc
x.bp88	lr	r3,r3			:was anything printed?
	jlfs	x.bp89
	jal	r7,typcrl
x.bp89	jr	r14

	SUBTTL	XRAY (Line Reset display - LR)

::*********************************************************************
::
::	COMMAND:	XLRE:	LR
::	FUNCTION:	DISPLAY last xmitted and received reset for the link
::
::*********************************************************************

xlrems	sc /"0d"0aDIR HEAD  NODE   VERSN  NETID WSZ LIN HOST  SPD ATTRIBUTES"0d"0a/
xlre	lhr	r3,r3
	jl	xtlerr
	clhi	r3,nlines		:must be a legal line number
	jge	xtlerr
	la	r2,xlrems
	jal	r7,typhdr
	ar	r3,r3
	l	r10,sdln,r3,r3		:get address of reset descriptor
	lhi	r11,vsdsz
	la	r2,trcms1		:'out'
xlre04	jal	r7,typhdr
	lhl	r3,vrstp,r10,r11	:reset header
	jal	r9,typhw
	l	r3,vndid,r10,r11	:node number
	jal	r9,typ5o
	lhl	r3,vverno,r10,r11	:version
	jal	r9,typ5o
	lhl	r3,vnetid,r10,r11	:netid
	jal	r9,typhwd
	lb	r3,vwsiz,r10,r11	:windowsize
	jal	r9,typbyd
	lb	r3,vline,r10,r11	:line number
	jal	r9,typbyd
	l	r3,vhost0,r10,r11	:host
	jal	r9,typ5dd
	lb	r3,vkspd,r10,r11	:line speed
	jal	r9,typbyd
	l	r3,vkattr,r10,r11	:link attributes
	jal	r9,typfw
	jal	r7,typcrl
	shi	r11,vsdsz
	jl	xprmpt,,		:done
	la	r2,trcms2		:do other direction
	j	xlre04

	SUBTTL	XRAY (Neighbor Links info - NL)

::*********************************************************************
::
::	COMMAND:	XNL:	NL
::	FUNCTION:	DISPLAY NEIGHBOR LINK info
::
::*********************************************************************

xnlms1	sc	/"0d"0a***--LINE---***  ***--- NEIGHBOR ---***    LINK/
xnlms2	sc	/"0d"0aNO. TYPE  SPEED  NODE  KHOST LINE VERSN  ATTRIBUTES"0d"0a/
xnlmsh	sc	/No.Shrink /
xnlxbp	sc	/X.BP /
xnlvbp	sc	/V.BP /


XNL	LA	R2,XNlms1		:user wants statistics for all lines
	JAL	R7,TYPhdr,,
	LA	R2,XNlms2
	JAL	R7,TYPhdr,,
	LCS	LN,1			:for all active lines
XNL03	AIS	LN,1			:do next line
	CLHI	LN,NLINES
	JGE	XRCRLF,,
	LH	R1,NGSVLN,LN,LN 	:it is active?
	JGEBS	XNL03    		:nope
	LR	R3,LN     		:print line #
	JAL	R9,TYPBYD
	LA	R2,XNDHSY,, 		:print lne type
	IF	SILINS
	CLHI	LN,NLINES-SILINS
	JLFS	XNL07			:is still a sync line
	LA	R2,XNDHSI,,		:is a sio line
      EI	:SILINS
XNL07	JAL	R7,TYPASC,,		:line type
	LH	R3,BAUDRT,LN,LN		:get calculated line speed
	NHI	R3,1F			:only the speed
	JAL	R7,prtspd,,
	LHL	R3,NGSVLN,LN,LN

	NHI	R3,7FFF			:just the node number
	JAL	R9,TYP5o		:print node number
	LR	KX,LN			:setup KX as link descriptor
	ar	KX,kx
	L	KX,KDLN,KX,KX		:and KX is link descriptor
	ST	KX,XKDSAV,XD		:setup for other xray routines
	L	R3,KHOST0,KX
	JAL	R9,TYP5DD		:type neighbor's HOST0
	LB	R3,KLINE,KX
	JAL	R9,TYPBYD		:type neighbor's 1st ln attached
	lhl	r3,kverno,kx
	JAL	R9,TYP5o		:print version number
	lb	r10,lknm,kx		:get link number
	tbt	r10,noshrk		:is no shrink selected
	jefs	xnl10
	la	r2,xnlmsh		:show no shrink attribute
	jal	r7,typasc,,
xnl10
       if	aplybp
	tbt	r10,xactbp
	jefs	xnl12
	la	r2,xnlxbp		:show xmit apply bp attribute
	jal	r7,typasc,,
xnl12	tbt	r10,vactbp
	jefs	xnl14
	la	r2,xnlvbp		:show receive apply bp attribute
	jal	r7,typasc,,
xnl14
       ei	:aplybp
	jal	r7,typcrl
	j	xnl03	

::*******************************************************************
::
::	COMMAND:	SH
::	FUNCTION:	DISPLAY Sup Ring Histograms
::			SH       -  Display
::			SH Z     -  Zero
::
::*********************************************************************

       if	super

	RA      0A      :change radix so text numbers are decimal
xryshs	XRNTXT("0D"0A         SUP DATA RINGS UTILIZATION     RING SIZE:,$ASUPBSZ,5,"0D"0A)

xrysht	SC	/"0D"0ARING POINTER  TO SUP  FROM SUP     PEAK IN :/
xryshq	SC         /"0D"0A  RANGE       COUNT    COUNT       PEAK OUT:/
xryshu  XRNTXT("0D"0AUNDER ,$ASUPBSZ/8,5,  )
	XRNTXT("0D"0A,$ASUPBSZ/8+1,5,-,$ASUPBSZ/4,5,  )
	XRNTXT("0D"0A,$ASUPBSZ/4+1,5,-,$A3*SUPBSZ/8,5,  )
	XRNTXT("0D"0A,$A3*SUPBSZ/8+1,5,-,$A4*SUPBSZ/8,5,  )
	XRNTXT("0D"0A,$A4*SUPBSZ/8+1,5,-,$A5*SUPBSZ/8,5,  )
	XRNTXT("0D"0A,$A5*SUPBSZ/8+1,5,-,$A6*SUPBSZ/8,5,  )
	XRNTXT("0D"0A,$A6*SUPBSZ/8+1,5,-,$A7*SUPBSZ/8,5,  )
	XRNTXT("0D"0A,$A7*SUPBSZ/8+1,5,-,$A8*SUPBSZ/8,5,  )
xryshw	XRNTXT("0D"0A"0A"0a         SUP BACKPRESSURE RINGS UTILIZATION     RING SIZE:,$ASIBPSZ,5,"0D"0A)
xryshx  XRNTXT("0D"0AUNDER ,$A4^sbscal,5,  )
	XRNTXT("0D"0A,$A1*(4^sbscal)+1,5,-,$A2*(4^sbscal),5,  )
	XRNTXT("0D"0A,$A2*(4^sbscal)+1,5,-,$A3*(4^sbscal),5,  )
	XRNTXT("0D"0A,$A3*(4^sbscal)+1,5,-,$A4*(4^sbscal),5,  )
	XRNTXT("0D"0A,$A4*(4^sbscal)+1,5,-,$A5*(4^sbscal),5,  )
	XRNTXT("0D"0A,$A5*(4^sbscal)+1,5,-,$A6*(4^sbscal),5,  )
	XRNTXT("0D"0A,$A6*(4^sbscal)+1,5,-,$A7*(4^sbscal),5,  )
	XRNTXT("0D"0A,$A7*(4^sbscal)+1,5,-,$A8*(4^sbscal),5,  )
	RA	0	:return radix to normal

:		0	4	8      0c    10     14
xryshy	wc	xryshs,spohgm,spihgm,supicp,supocp,xryshu
xryshz	wc	xryshw,sobhgm,sibhgm,sibcp,sobcp,xryshx

xrysh	clhi	r1,ascz			:end with a Z?
	je	xrysh8
	clhi	r1,asccr		:must else end with a cr
	jn	xtlerr
xrysh1	la	r5,xryshy		:sup data rings
	jal	r12,xrysh6
	la	r5,xryshz		:sup backpressure rings
	jal	r12,xrysh6
	j	xrcrlf,,

:	little subroutine to print out a histogram
xrysh6	L	R2,0,r5			:sup ring utilization
	JAL	R7,TYPhdr
	LA	R2,xrysht		: TO SUP  FROM SUP
	JAL	R7,TYPhdr
	l	r3,0c,r5		:supicp/sibcp
	LHL	R3,0,r3			:get value of peak in
	JAL	R9,TYP5DD		:in decimal
	LA	R2,xryshq		:'RANGE COUNT COUNT PEAK OUT:'
	JAL	R7,TYPhdr
	l	r3,10,r5		:supocp/sobcp
	LHL	R3,0,r3			:get value of peak in
	JAL	R9,TYP5DD
:       now the histogram
	LIS	R10,0			:how far into histogram
	LIS	R11,0			:index into messages (all 16 byte long)
xrysh7	L	R2,14,r5		:xryshu xryshx
	ar	r2,r11			:index into ranges
	JAL	R7,TYPhdr 		:type range
	l	r3,8,r5			:spihgm, sibhgm
	L	R3,0,R3,r10	   	:get SIB (to SUP) value
	JAL	R9,TYPFW
	L	R3,4,r5		   	:get SOB (from SUP) value
	L	R3,0,R3,r10
	JAL	R9,TYPFW
	AHI     R11,10
	AIS     R10,4
	CLHI    R10,4*8   		:8 entries in table
	JL	xrysh7
	jr	r12

xrysh8	lis	r2,0
	STH     R2,SobCP 		:peak in bp
	STH     R2,SibCP 		:peak out bp
	STH     R2,SUPICP 		:peak in data
	STH     R2,SUPOCP 		:peak out data
	LHI     R3,4*8-4  		:last entry in histogram
xrysh9	ST      R2,SOBHGM,R3    	:clear output histogram (bp)
	ST      R2,SIBHGM,R3    	:clear input histogram (bp)
	ST      R2,SPOHGM,R3    	:clear output histogram (data)
	ST      R2,SPIHGM,R3    	:clear input histogram (data)
	SIS     R3,4
	JGEBS   xrysh9
	j	xrysh1

       ei	:super


::*******************************************************************
::
::	COMMAND:	SR
::	FUNCTION:	DISPLAY Sup Backpressure Ring
::			SR <num> R   -  Display from sup backpressure ring
::			SR <num> S   -  Display to sup backpressure ring
::
::	note:	if sr.gmt is true then have parallel rings with GMT to
::		be displayed next to each port msg.
::*********************************************************************

      if	super
x.sran	sc	/"0d"0aBACKPRESSURE APPLIED BY NODE CODE BASE/
x.sras	sc	/"0d"0aBACKPRESSURE APPLIED BY SUPERVISOR/

       if	sr.gmt
x.srh	sc	/"0d"0aCHN    NODE    TYPE         GMT"0d"0a/
       else	:not sr.gmt
x.srh	sc	/"0d"0aCHN    NODE    TYPE"0d"0a/
       ei	:sr.gmt
x.srAP	sc	/APPLIED   /
x.srRE	sc	/RELEASED  /

x.sr	clhi	r1,ascr		:received from sup ring?
	jnfs	x.sr0
	la	r2,x.sras
	jal	r7,typhdr	:print 'applied by sup' header
	la	r10,sobp,,	:address of backpressure ring
       if	sr.gmt
	la	r14,sobpgm,,	:address of GMT ring
       ei	:sr.gmt
	j	x.sr1
x.sr0	clhi	r1,ascs		:sent to sup ring
	jn	x.srst
	la	r2,x.sran
	jal	r7,typhdr	:print 'applied by node' header
	la	r10,sibp,,
       if	sr.gmt
	la	r14,sibpgm,,	:address of GMT ring
       ei	:sr.gmt
:	print from indicated ring
x.sr1	la	r2,x.srh	:print out the format header
	jal	r7,typhdr
	lhi	r11,sobpsz	:whole ring (both rings same size)
	lhl	r2,argct,xd	:how many indicated msgs
	jefs	x.sr2		:none given so give em whole ring
	l	r11,value1,xd
	ar	r11,r11		:each msg is two bytes
x.sr2	lh	r12,0,r10	:at ring pointer is fill index
	sr	r12,r11		:read that many messages
	clhi	r12,-sobpsz	:wrapped off of start of ring?
	jgefs	x.sr3
	ahi	r12,sobpsz	:back to within ring
x.sr3	lr	r12,r12
	jlfs	x.sr31
	shi	r12,sobpsz	:back to within ring
x.sr31	lh	r11,0,r10,r12	:get msg
	je	x.sr8		:empty ring, skip it
	lr	r3,r11
	nhi	r3,7fff		:knock off apply/release bit
	jal	r9,typhw
	ahi	r3,$8 2000-2	:sup 1 is port 3
	jal	r9,typ5o	:print node number
	la	r2,x.srAP	:applied
	lr	r11,r11		:what was high bit?  8000 = apply
	jlfs	x.sr4
	la	r2,x.srRE	:released
x.sr4	jal	r7,typasc
       if	sr.gmt		:also showing GMT
	lr	r2,r12		:make into fw pointer from hw pointer
	ar	r2,r2
	l	r6,0,r14,r2	:get gmt in a safe reg
	lr	r2,r6		:set up to be printed
	jal	r9,gmtcnx	:print it
	jal	r7,typ1sp	:format
	lr	r3,r6
	nhi	r3,7f		:strip nonfastc bits
	ar	r3,r3		:shift into position (00-FE not 0-7f)
	jal	r9,typbyt	:print
       ei	:sr.gmt
	jal	r7,typcrl	
x.sr8	ais	r12,2		:advance cursor
	jlfs	x.sr9		:did it wrap?
	shi	r12,sobpsz	:yes, reset
x.sr9	clh	r12,0,r10	:catch upto fill pointer?
	jn	x.sr3		:nope, get next
	j	xprmpt,,	:yes, done.

:	SR with no args in split config says if ring is up
       if	split

x.srsr	sc	/"0d"0aSIO RING INTERFACE IS /

x.srst	clhi	r1,asccr	:just SR?
	jn	xtlerr
	la	r2,x.srsr	:sio ring interface is 
	jal	r7,typasc
	la	r2,xndlot,,	:down
	lb	r0,sirxmy,,
	clhi	r0,70
	jnfs	x.srs1
	la	r2,xndlup,,	:up
x.srs1	jal	r7,typasc
	j	xprmpt,,
       else	:not a split
x.srst	j	xtlerr		:not a split no sio ring interface
       ei	:split

       ei	:super


::**************************************************************************
::
::      COMMAND:	KW					*   *  *   *
::      FUNCTION:       Display KIO STATUS DATA			*  *   *   *
::			KW  -  DISPLAY				***    * * *
::			KWZ -  Zero, then Display		*  *   ** **
::								*   *  *   *
::
::**************************************************************************

       if	supwat
xrykwm  sc      /"0d"0aPORT   Chars In  Chars Out"0d"0a/
xrykw   clhi    r1,ascz                 :clear? (close with a Z)
        je      xrykwz
	clhi	r1,asccr		:if not then with a CR
	jn	xtlerr
        la      r2,xrykwm		:our header
        jaL	r7,typhdr
        lis     r10,0
xrykw1  lr      r3,r10
        jaL	r9,typbyd		:kio port number
        ar      r10,r10
        jaL	r7,typ4sp
        l       r3,kerict,r10,r10       :input chars
        jaL	r9,typfwd
        l       r3,keroct,r10,r10       :output chars
        jaL	r9,typfwd
        jaL	r7,typcrl
        srls    r10,1
        ais     r10,1
        clhi    r10,nku
        jl      xrykw1
        j       xprmpt,,

:	clear stats
xrykwz  lis     r0,0                    :clear stats
        lhi     r10,nku*2
xrykw9  st      r0,kerict,r10,r10
        st      r0,keroct,r10,r10
        sis     r10,2
        jgebs   xrykw9
        la      r2,xksm25,,             :stats cleared msg
        jaL	r7,typasc
        j       xprmpt,,

       ei	:supwat

::*************************************************************************
::
::	COMMAND:	TS					*****  ****
::			TS nnnn - starts tracing		  *   *
::			TS      - display data and stops tracing  *    ***
::	FUNCTION:	DISPLAY DATA FROM THE			  *       *
::			SUPE PORT TRACE BUFFERS			  *   ****
::			IN HEX (without escapes)
::
::*************************************************************************

        if      supwat
xrdj    sis     r2,4		:with an arg?
        jg      xtlerr		:too many args
        jn      xrdjd0		:the display logic
:       here to initiate trace
        l       r3,value1,xd
        jaL	r9,octhxr	:convert node to hex
        ais     r3,2            :supe chans start off by 2
        ahi     r3,supzfl-400           :node #s start at 2000 octal
        ci      r3,endzfl               :legal chn number?
        jg      xtlerr
        sbt     r3,trchan,,             :400 since node # start at 2000octal
        sth     r3,xdjsav,xd            :chan we are tracing
        j       xprmpt,,

xrdjd0  ts      xdjsat,xd               :indicate TD from DJ
        lis     r4,0
        lis     r0,1
        lis     r2,0
        j       trcd0j                  :goto TD routine

        ei      :supwat

::*******************************************************************
::
::	COMMAND:	SW
::	FUNCTION:	DISPLAY Supe Status
::			SW       -  Display
::			SWZ      -  Zero
::			SWnnnnN  -  Display needle with the threshold
::			SWnnnnR	 -  Display Supe Logon response with the threshold
::			SWnnnnI  -  Display Chars In with the threshold
::			SWnnnnO	 -  Display Chars Out with the threshold
::			SWnnnn   -  Display node status
::
::*********************************************************************

       if	supwat
xrysw	clhi	r1,ascz			:want clear?
	jn	xrysw1
:       clear stats
	jal	r9,swclear		:clear all stats
	la	r2,xksm25,,
	jal	r7,typhdr
	j	xprmpt,,

swclear	li	r1,(nsp+4)*2		:the whole shebang
	lis	r0,0
swcle1  st	r0,supned,r1,r1
	st	r0,supcpi,r1,r1
	st	r0,supcpo,r1,r1
	st	r0,suprej,r1,r1
	st	r0,supilc,r1,r1
	st	r0,supdlc,r1,r1
	st	r0,supdnd,r1,r1
	sth	r0,supind,r1,		:internal circuits
	sis	r1,2
	jge	swcle1
	jr	r9			:and return (to lep or xray)


xryswj sc /"0d"0a       Logon         ORIGINATION      DESTINATION       Total Chars   Internal/
xryswi sc /"0d"0aNode   Responses  Needles  Total LU Needles  Total LU   IN       OUT  Circuits/
xrysw1	lr	r11,r1
	lr	r12,r2
	la	r2,xryswj
	jal	r7,typhdr,,
	la	r2,xryswi
	jal	r7,typhdr
	lr	r1,r11
	lr	r2,r12
	clhi	r1,ascn			:needles with a threshhold?
	jn	xrysw2
	sis	r2,4
	jn	xtlerr
	l	r14,value1,xd		:get threshhold
	la	r11,supned,,		:supe port 0 an 1 don't count
	j	xrysw7
xrysw2	clhi	r1,ascr			:rejects with a threshhold?
	jn	xrysw9
	sis	r2,4
	jn	xtlerr
	l	r14,value1,xd	 	:get threshhold
	la	r11,suprej,,		:supe port 0 an 1 don't count
	j	xrysw7

xrysw9	clhi	r1,asci			:chars in with a threshhold?
	jn	xrysw8
	sis	r2,4
	jn	xtlerr
	l	r14,value1,xd		:get threshhold
	la	r11,supcpi,,
	j	xrysw7
xrysw8	clhi	r1,asco 		:output chars threshhold?
	je	xryswh
	clhi	r1,asct			:T for termination needles
	je      xryswt
:	none of the valid options.  The default is to display for all nodes
	clhi	r1,asccr
	jn	xtlerr
	sis	r2,4			:have an arg with no threshold?
	jl	xryswu			:display for all nodes
	l	r3,value1,xd
	jal	r9,octhxr		:convert to hex
	lr	r12,r3
	shi	r12,3fe			:fix offset
	jle	xtlerr
	clhi	r12,nsp
	jg	xtlerr
	jal	r6,xryswd
	j	xprmpt,,		:displayed that one node
xryswt	la	r11,supdnd,,
	l	r14,value1,xd
	j	xrysw7			:find them
xryswu	lis	r14,0			:no threshhold
	la	r11,supcpi,,
	jfs	xrysw7
xryswh	sis	r2,4
	jn	xtlerr
	l	r14,value1,xd		:get threshhold
	la	r11,supcpo,,

xrysw7	lr	r3,r14			:threshold is in decimal
	jal	r9,dechex
	lr	r14,r3
	lhl	r0,tvrsup
	clhi	r0,machnm&07		:our supe the active supe?
	jn	xryswp
	lis	r12,0			:start at low node number
xryswm	tbt	r12,supacp,,		:active port?
	jefs	xryswo			:active if reset
xryswn	ais	r12,1
	clhi	r12,nsp
	jlbs	xryswm
	j	xprmpt,,

xryswo	lr	r1,r12
	slls	r1,2
	cl	r14,0,r11,r1		:above threshhold?
	jg	xryswn			:no, so don't print
	jal	r6,xryswd		:display it for a node
	j	xryswn			:and next

xryswp	lis	r12,3			:start at low node number

xryswq	lr	r1,r12
	slls	r1,2
	c	r14,0,r11,r1		:above threshhold?
	jgfs	xryswr			:no, so don't print
	jal	r6,xryswd       	:display it for a node
xryswr	ais	r12,1
	clhi	r12,nsp
	jlbs	xryswq
	j	xprmpt,,

:	xryswd  routine to print out node number and the values
:	links on r6, has node number -2000 in r11
xryswd	jal	r7,typcrl,,		:new line
	lhi	r3,3fe,r12		:make into node number
	jal	r9,typ5o		:output node number
	ar	r12,r12
	l	r3,suprej,r12,r12	:number of rejects
	jal	r9,typafw
	jal	r7,typ2sp
	l	r3,supned,r12,r12	:output number of orig needlles
	jal	r9,typafw
	l	r3,supilc,r12,r12	:link count
	jal	r9,typafw
	l	r3,supdnd,r12,r12	:number of dest needles
	jal	r9,typafw
	l	r3,supdlc,r12,r12
	jal	r9,typafw		:dest link count
	l	r3,supcpi,r12,r12	:chars in
	jal	r9,typafw
	l	r3,supcpo,r12,r12	:char outs
	jal	r9,typafw
	srls	r12,1
	lhl	r3,supind,r12,r12	:internal circuits
	jal	r9,typ5dd		:recent in and out
	jr	r6			:done

:	a little service routine to print all digits if present
:	if not then don't print extra digits
typafw	lis	r1,0
typaf1	ti	r3,80000000		:in case high bit
	jnfs	typaf2			:it count it
	ci	r3,$a 1000000000	:9 zeros (10 digits)
	jlfs	typaf3
typaf2	ais	r1,1
	si	r3,$a 1000000000	:9 zeros (10 digits)
	jbs	typaf1
typaf3	lr	r1,r1
	jefs	typaf4
	jal	r7,typhex
	lhi	r1,10			:make sure print next digit
typaf4	ci	r3,$a 100000000		:8 zeros (9 digits)
	jlfs	typaf5
	ais	r1,1
	si	r3,$a 100000000		:8 zeros (9 digits)
	jbs	typaf4
typaf5	lr	r1,r1			:need to print a digit?
	jefs	typaf6
	jal	r7,typhex		:it only prints low nibble
typaf6	j	typfwd			:use standard to print low digits


       ei	:supwat


::*************************************************************************
::
::	COMMAND:	HE, HE c, HE cc
::			
::	FUNCTION:	Display available commands and help info.  The
::			xray user must have the power to execute the cmd
::			for it to show up.
::
::*************************************************************************

x.hem1	sc	/"0d"0aXray Commands are:"0d"0a/
x.hem2	sc	/"0d"0aCommand not found"0d"0a/
x.hem3	sc	/"0d"0aUsage: /

x.help	LIS	R2,0			:counter
	lis	r6,0			:holds the cmd
	lb	r13,argpos,xd
x.he01	lb	r1,value1+4,r13,xd	:get char
	OHI	R1,80			:SET HOB
	CLHI	R1,ASCSPC+80		:IF SPACE ASSUME USER IS DONE
	JE	x.he03
	CLHI	R1,ASCCR+80		:SAME FOR CR
	JE	x.he03
	CLHI	R1,ASCCOM+80		:SAME FOR COMMA	
	JE	x.he03
	CLHI	R1,ASCAST+80		:done if asterik
	JE	x.he03
	NHI	R1,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE,0DF
	slls	r6,8
	or	r6,r1			:combine into r6
	AIS	R2,1
	clhi	r2,2			:if have enough just write extras
	jgefs	x.he03			:into ignored location
	ais	r13,1
	clb	r13,argpos+1,xd		:at end of cmd?
	JL	x.he01
:	r2 is either 0 (HE) and want all, 1 (HE c) and want all with that let
:	or 2 (HE cd) and want that cmd.
x.he03	sis	r2,1			:set condition codes
	jl	x.he20			:want all cmds
	je	x.he30			:want all for that letter
:	want all with these two letters
x.he06	lr	r0,r6			:use the existing routine
	jal	r3,comfnd,,
	lr	r14,r14			:does cmd exist
	jgefs	x.he12			:yes.
:	cmd does not exist
x.he08	la	r2,x.hem2		:tell them no such cmd
	jal	r7,typasc
x.he10	j	xprmpt,,		:done

:	command does exist
x.he12	lis	r12,0
	jal	r9,x.heds		:display it
	lr	r13,r13			:was cmd displayed
	jlbs	x.he08			:no, lack of power or hidden cmd
	jbs	x.he10			:and done

:	here to print all cmds
x.he20	la	r2,x.hem1
	jal	r7,typasc
	lis	r14,0			:start from begining to keep order
	lis	r12,0			:a normal printout
x.he22	jal	r9,x.heds		:print cmd.
	ais	r14,comtsz		:check next command
	clhi	r14,xncmnd*comtsz	:size of command table
	jlbs	x.he22
	j	xprmpt,,		:done

:	here if have a single char
x.he30	clhi	r1,ascast+80		:was last char an asterik?
	jefs	x.he31			:yes they want beginning with that let
	exbr	r6,r6			:no, they wanted that single char cmd
	ohi	r6,0a0			:make it
	j	x.he06			:and go to the single cmd logic
:	here to print cmds beginning with that letter
x.he31	la	r2,x.hem1
	jal	r7,typasc
	lis	r14,0			:start from begining to keep order
	lis	r12,0			:a normal printout
x.he33	clb	r6,comtbl,r14,		:is this the command?
	jnfs	x.he36
	jal	r9,x.heds		:print cmd.
x.he36	ais	r14,comtsz		:check next command
	clhi	r14,xncmnd*comtsz	:size of command table
	jlbs	x.he33
	j	xprmpt,,		:done

:	print help on the command pointed to at R14, link on r9
x.heds	lcs	r13,1			:indicate not printed yet
	lhl	r0,comtbl+xcmarg,r14,	:get license bits
	thi	r0,x.nhlp
	jnr	r9			:a secret command
	LH	R7,XPOWER,XD		:THIS USER'S ACCESS POWER
	JLFS	x.he52			:SUPERPWR, USER CAN DO ANYTHING
	CLH	R7,COMTBL+xcmpwr,R14,	:IS THIS USER AUTHORIZED?
	JGR	r9			:NO, don't tell them about this cmd
x.he52
       if	.help.			:could be a call asking for Usage
	lr	r12,r12			:asking for usage?
	jgefs	x.he53			:no, normal help
	la	r2,x.hem3		:yep, print usage header
	jal	r7,typasc,,
       ei	:.help
x.he53	lb	r1,comtbl,r14,		:get chars of cmd
	jal	r13,xryout
	lb	r1,comtbl+1,r14,	:get chars of cmd
	jal	r13,xryout
	jal	r7,typ1sp
       if	.help.
	lhl	r2,xcmhlp+comtbl,r14,	:get help string
	ai	r2,segd
	jal	r7,typasc
	jal	r7,typcrl
       else	:1-.help.
	ais	r12,1
	thi	r12,0f			:if no info, then 16 cmds per line
	jnfs	x.he54
	jal	r7,typcrl
       ei	:.help.
x.he54	jr	r9

::*************************************************************************
::
::	COMMAND:	SN
::			
::	FUNCTION:	Restart Node Code.
::
::*************************************************************************

x.snm1	sc	/"0d"0aCrash Node Code: Are you sure? /

x.sn	la	r2,x.snm1		:get the double check
	jal	r7,typasc,,
	lis	r0,0
	sth	r0,argmin,xd		:want 0 args
	jal	r9,rdargs,,
	j	xtler3
	j	xtler3
	clhi	r1,ascy			:did they say yes?
	jn	xprmpt,,
	CLI	XD,TTYXD		:tty user?
	JN	x.sn05    		:nope
	LA      R8,x.sn05 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT,, 		:wait until BG finishes task
	j	xray,,
x.sn05	crash.(.xrysn)			:take the crash


::*************************************************************************
::
::	COMMAND:	PL <n> H/D 
::			
::	FUNCTION:	Display n entries, display entries for n Hours or
::			n Days.
::
::*************************************************************************

       if	pl.num
x.plm1	sc	/"0d"0a             ENTRY        LOGICAL CPS    PHYS CPS      DELAY      CIRCUITS"0d"0a   GMT       TYPE EXEC    IN     OUT    IN     OUT   HW    SW   PORT  PTHR  CCTS"0d"0a/
x.plm2	sc	/ AVER /
x.plm3	sc	/ -EXC /
x.plm4	sc	/ +EXC /
       if	pl.all
x.plm5	sc	/ +LCI /
x.plm6	sc	/ +LCO /
x.plm7	sc	/ +PCI /
x.plm8	sc	/ +PCO /
       ei	:pl.all
x.plmt	bc	0,x.plm3-x.plm2,x.plm4-x.plm2
       if	pl.all
	bc	x.plm5-x.plm2,x.plm6-x.plm2,x.plm7-x.plm2,x.plm8-x.plm2
       ei	:pl.all

x.pl	sis	r2,4			:either 0 or 1 values
	jefs	x.pl03			:handle 1 arg
	clhi	r1,asccr		:end in CR?
	jn	xtlerr
	lhi	r3,$a 24		:default is 24 args
	j	x.pl08
:	have one 1 arg.  See if H or D modifier is present
x.pl03	lr	r10,r1			:save modifier char if present
	l	r3,value1,xd		:get the val
	jal	r9,dechex,,		:convert to hex
	clhi	r10,asccr		:end in CR?
	je	x.pl08			:number given is number desired
	lhi	r4,$a60
	clhi	r10,asch		:ask for Hours?
	je	x.pl05
	clhi	r10,ascD		:ask for Days?
	jn	xtlerr
	lhi	r4,$a24*60		:minutes in a day
x.pl05	mhr	r3,r4			:how many minutes of entries
	lhi	r4,pl.frq		:how many minutes between entries
	lis	r2,0
	dr	r2,r4
:	have number of entries requested in R3.  Now work back in log
:	that many entries
x.pl08	lr	r12,r3			:number of entries requested
	clhi	r12,pl.num		:more than are in log?
	jge	x.pl18
	lhl	r14,pl.ptr		:get pointer of newest msg
x.pl10	shi	r14,pl.siz
	jgefs	x.pl12
	lhi	r14,(pl.num-1)*pl.siz	:point to last msg in ring
x.pl12	clh	r14,pl.ptr		:wrapped back to the start
	je	x.pl19			:print whole log
	lh	r0,pl.prb+pl.exe,r14,	:see if this msg exists
	jl	x.pl18			:not enough msgs so done searching
	lb	r0,pl.prb+pl.gmt+3,r14,	:get byte of type
	nhi	r0,7f			:knock off bit of gmt
	clhi	r0,7f			:is it AVER type?
	jn	x.pl10			:no, don't count it
	sis	r12,1			:another msg counted
	jg	x.pl10			:still have more to do
	jfs	x.pl19			:got them all and r14 is ready to go

x.pl18	lhl	r14,pl.ptr		:get pointer to do whole ring
x.pl19	la	r2,x.plm1		:print header
	jal	r7,typasc
x.pl20	lh	r2,pl.prb+pl.exe,r14,	:not an entry if neg
	jge	x.pl26
x.pl22	ahi	r14,pl.siz		:point to next msg
	clhi	r14,pl.num*pl.siz
	jlfs	x.pl23
	lis	r14,0			:wrapped
x.pl23	clh	r14,pl.ptr		:got back to start?
	jnbs	x.pl20
	j	xprmpt,,		:yes, done
:	print this entry
x.pl26	l	r2,pl.gmt+pl.prb,r14,	:get oldest msg in ring
	lr	r11,r2			:save a copy in case multiple msgs
	lr	r12,r11			:get msg type
	nhi	r12,7f			:isolate
	exbr	r12,r12			:move type bits to high byte
x.pl27	lr	r2,r11
	jal	r9,gmtcnx,,		:print time
	clhi	r12,7f00		:is it average?
	jnfs	x.pl28
x.pl25	lis	r13,0			:get the AVER msg type
	lis	r12,0			:no more msgs for this entry
	jfs	x.pl29
x.pl28	jffoh	r12,x.pl29
	jbs	x.pl25			:instead of crashing	
x.pl29	sth	r12,value1+10,xd	:save into a save spot
	rbt	r13,value1+10,xd	:reset this msg bit
	lhl	r12,value1+10,xd	:get back r12 without this msg type
	lb	r2,x.plmt,r13		:get msg type
	la	r2,x.plm2,r2		:convert to address
	jal	r7,typasc,,
	lhl	r3,pl.exe+pl.prb,r14,	:get exec
	jal	r9,typhwd
	l	r3,pl.lc+pl.prb,r14,	:get logical cps in
	srls	r3,$a12			:isolate
	jal	r9,typ6dd,,		:print
	l	r3,pl.lc+pl.prb+2,r14,	:get logical cps out
	srls	r3,8
	ni	r3,0fffff		:mask off any lcspi bits
	jal	r9,typ6dd,,		:print
	l	r3,pl.pc+pl.prb-1,r14,	:get physical cps in
	srls	r3,4			:align
	ni	r3,0fffff		:mask off any lcspo bits
	jal	r9,typ6dd,,		:print
	l	r3,pl.pc+pl.prb+1,r14,	:get physical cps out
	ni	r3,0fffff		:mask off any pcpsi bits
	jal	r9,typ6dd,,		:print
	lhl	r2,pl.del+pl.prb,r14,	:get software delay
	srls	r2,4
	jal	r9,fstmsc,,		:print in milliseconds
	jal	r9,typhwd,,
	l	r2,pl.del+pl.prb,r14,	:get hardware delay
	srls	r2,8			:align
	nhi	r2,0fff
	jal	r9,fstmsc,,		:print in milliseconds
	jal	r9,typhwd,,
	l	r3,pl.prt+pl.prb-1,r14,	:get ports
	srls	r3,$a 12		:align
	nhi	r3,0fff			:mask of any hw delay bits
	jal	r9,typhwd,,
	l	r3,pl.prt+pl.prb+1,r14,	:get passthroughs
	srls	r3,$a 14		:align
	nhi	r3,3fff			:mask off extra
	jal	r9,typhwd,,
	l	r3,pl.prt+pl.prb+1,r14,	:get cmd cirs
	nhi	r3,3fff			:mask off extra
	jal	r9,typhwd,,
	jal	r7,typcrl,,		:new line
	lr	r12,r12			:any more msg types for this entry?
	jn	x.pl27			:yes, print it
	j	x.pl22			:print next entry
       ei	:pl.num

::*************************************************************************
::
::	COMMAND:	ZP chn
::			
::	FUNCTION:	Zaps the circuit.  To not potentially mess up
::			accounting, one end of circuit must be to a link
::			chn.  (ie it looks like zap came from net)
::
::*************************************************************************

x.zam1	SC	/"0d"0aNot an active circuit/
x.zam2	sc	/"0d"0aChannel out of range/
x.zam3	sc	/"0d"0aCircuit in special state.  Not zapped/
x.zam4	sc	/"0d"0aZap failed due to out of buffers/
x.zam5	sc	/"0d"0aNot valid from DDT/

x.zap	clhi	r3,endzfl		:is out of range?
	jlefs	x.za03			:yes,
	la	r2,x.zam2		:the out of range msg
	jfs	x.za04

x.za03	lhl	r2,iotab,r3,r3		:make sure circuit is present
	jnfs	x.za05			:yes, one there
	la	r2,x.zam1
x.za04	jal	r7,typasc		:tell them no circuit there
	j	xprmpt,,		:and done

x.za05	nhi	r2,-4			:knock off spped bits
	lr	r5,r3
	clhi	r5,lnkzfl		:find a link chn
	jge	x.za10			:found a link chn
	lhl	r5,bf,r2,		:get chn num of other 1/2 of circtui
	xhi	r2,4			:keep r2 pointing for putting.
	clhi	r5,lnkzfl		:is it a link chn?
	jgefs	x.za10
x.za07	la	r2,x.zam3		:circuit has no link chn, can't do it
	j	x.za04	

:	don't have a free buffer needed to split circuit in order to pass
:	zaps in both directions

:	have a link chn, so now zap circuit
x.za10	jal	r8,chnlnk		:find out about circuit
	skipad(x.za07)
	skipad(x.za07)
	lr	r12,r2			:save r2

	CLI     XD,TTYXD  		:tty user?
	JN      x.za40    		:nope
	LA      R13,x.za45 		:
	ST      R13,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT,, 		:wait until BG finishes task
	J       XPRMPT,,
x.za40	JAL     R13,x.za47 		:just call subroutine
	J       XPRMPT,,    		:and done

:       here for background doing a task for XDDT
x.za45	ST	R8,XDDTSV+4*R13		:so overwrite link reg with link reg
	LM      R0,XDDTSV 		:get back registers

:	here for the task link on r13
x.za47	JAL	R8,GFCBUF,,		:ZAP CIRCUIT IN BOTH DIRECTIONS
	SKIPAD(x.zaob)			:immed. return - out of buffers!###wjl
	lr	r11,r2			:save new buffer	
	lr	r2,r12			:get zap chn
       if	t2gate			:internal accounting is done in inthst
	lis	r0,aalr03
	sth	r0,aareas
       ei	:
	JAL	R9,ZAPHRD,,		:zap from forward dir
       if	t2gate
	lis	r0,0
	sth	r0,aareas
       ei 
	lr	r2,r11			:our new buffer
	JAL	R9,CRQHCR,,		:build the circuit to the link
	XHI	R2,4			:just enough for the zap logic to
	LHI	R1,ZAPPH		:clear the chn
	JAL	R9,W2CI,,
	jal	r8,speed,,		:make sure it gets read
	l	kx,xkdsav,xd		:get link descriptor
	LCS	R0,1
	AHM	R0,ANCHN,KX		:DECREMENT NUMBER OF ACTIVE CHANNELS
	jr	r13			:and done

x.zaob	crash.(.xryzp)


:	now expand all the help strings
       if	.help.
nmhelp	eq	0
	re	xncmnd
	qhm|nmhelp|
	kill	qhm|nmhelp|
nmhelp	eq	nmhelp+1
	er
      ei	:.help.

::*************************************************************************
::
::								 ***  ****
::	COMMAND:	CR					*   * *   *
::	FUNCTION:	Display Channel Partition Ranges	*     *****
::			    					*   * *  * 
::	###07/29/30						 ***  *   *
::
::*************************************************************************

:	strings
	KILL	QQCR
QQLOC	HC	QQCR			:fill length in later
XCR.F1	EQ	QQLOC+1
	AC	/"8d"8aChannel partition ranges:"8d"8a/
	AC	/CRQ:    0000-001F"8d"8a/
	AC	/LEP:    0020-002F"8d"8a/
	AC	/INTHST: 0030-003F"8d"8a/
       IF	1-T2GATE
	AC	/KERIO:  0040-/  ; .XRNT0(SUPZFL-1,4) ; AC  /"8d"8a/
       EI	:1-T2GATE
       IF	SUPER
	AC	/SUPIO:  /; .XRNT0(SUPZFL,4); AC /-/
		.XRNT0(DISZFL-1,4) ; AC  /"8d"8a/
       EI	:SUPER
       IF	NDP
	AC	/DISIO:  /; .XRNT0(DISZFL,4); AC /-/
		.XRNT0(LNKZFL-1,4) ; AC  /"8d"8a/
       EI	:NDP
	AC	/"8d"8aLINK NEIG  CHANNELS"8d"8a/
QQCR	EQ	.-XCR.F1-1		:length of text string

	KILL	QQCR
QQLOC	HC	QQCR
XCR.F3	EQ	QQLOC+1
	AC	/"8d"8aILC:    /; .XRNT0(ILCZFL,4); AC /-/
		.XRNT0(BPMZFL-1,4) ; AC  /"8d"8a/
QQCR	EQ	.-XCR.F3-1		:length of text string


::  Channel partition ranges:
::  CRQ    0000-xxxx
::  LEP    xxxx-xxxx
::  INTHST xxxx-xxxx
::  KERIO  xxxx-xxxx
::  DISIO  xxxx-xxxx
XCRCMD	LA	R2,XCR.F1		:address of string for lep, etc chns
	JAL	R7,TYPASC,,

:	for links
	LIS	R12,0
XCR.02	LR	R3,R12
	SRLS	R3,1			:back to real link num
	JAL	R9,TYPBYD,,		:type link number
	L	R11,KDKN,R12,R12	:link descriptor
	LHL	R3,NDID,R11		:get link number if link up
	JNFS	XCR.05
	LHL	R3,ONDID,R11		:link num of down tiilnk (0 if xlink)
XCR.05	JAL	R9,TYP5O,,
	LHL	R3,LKZFKN,R12,		:display starting channel #
	LR	R6,R3			:save a copy
	JAL	R9,TYPHNS,,		:print it
	LHI	R1,ASCDSH		:print dash
	JAL	R13,XRYOUT,,
	LHL	R3,NCHN,R11		:number of chns on link
	JGFS	XCR.07			:link is up
	AIS	R3,1			:next line subtracts 1
XCR.07	AHI	R3,-1,R6		: + # chans-1 => last channel
	JAL	R9,TYPHNS,,		:print it
	JAL	R7,TYPCRL,,		:next link
	AIS	R12,2
	CLHI	R12,2*NLINKS
	JL	XCR.02			: repeat for all links

::  ILC:    xxx-xxx
	LA	R2,XCR.F3		:for ILC chns
	JAL	R7,TYPASC,,
	J	XRCRLF,,


::*************************************************************************
::
::	COMMAND:	MM					*   * *   *
::	FUNCTION:	Display Memory Map			** ** ** **
::								* * * * * *
::	added 08/01/93						*   * *   *
::								*   * *   *
::
::*************************************************************************

X.MMT1	SC	/"8d"8aSEG TYPE  START  END    SIZE"8d"8a/
X.MMT2	SC	/DATA  /
       IF	MACV
X.MMT3	SC	/DMA   /
       EI	:MACV
X.MMT4	SC	/CODE  /
       IF	SUPER
X.MMT5	SC	/SUP   /
       EI	:SUPER
X.MMT6	SC	/XRAY  /
X.MMT7	SC	/CTA   /
X.MMT8	SC	/IDA   /


X.MM	LA	R2,X.MMT1		:header string
	JAL	R7,TYPASC,,
	LIS	R12,0			:segment number*2
	LA	R11,X.MMT2		:DATA segment string
X.MM03	L	R6,CHKDAT+4,R12,R12	:get segment size
	JEFS	X.MM10			:empty data segment, do not print
	JAL	R10,X.MMDS		:display info on this segment
X.MM10	AIS	R12,2			:increment to next seg*2
       IF	1-MACV			:normal eng segment usage
	CLHI	R12,2*A.CODE		:made it to CODE seg?
	JLBS	X.MM03			:do next data segment
       ELSE	:MACV
	CLHI	R12,2*3			:made it to possbile MACV seg?
	JLBS	X.MM03			:do next data segment
	LA	R11,X.MMT3		:DMA seg name
	L	R6,CHKDAT+4,R12,R12	:get DMA segment size
	JEFS	X.MM15			:empty DMA segment, do not print
	JAL	R10,X.MMDS		:display info on this segment
X.MM15	LHI	R12,2*A.CODE		:after DMA is empty until CODE seg
       EI	:MACV

:	now ready to do CODE segment.  R12 = 2*A.CODE
	LA	R11,X.MMT4		:CODe seg name
X.MM20	L	R6,CHKDAT+4,R12,R12	:get CODE segment siez
	JEFS	X.MM25
	JAL	R10,X.MMDS		:display info on this segment
X.MM25	AIS	R12,2			:next seg*2
       IF	1-SUPER			:not sup so next is Xray
	CLHI	R12,2*A.XRAY		:are we at sup seg?
	JLBS	X.MM20			:do next code Seg
       ELSE	:SUPER			:if sup then next is SUP IO seg
	CLHI	R12,2*A.SUP		:are we at sup seg?
	JLBS	X.MM20			:no, do next code Seg
	LA	R11,X.MMT5		:SUP seg name
	LI	R6,S5END+(SEGSIZ-1)	:size of shared SUP IO seg
	AHI	R6,PAGESZ-1		:round up to pagesize
	NHI	R6,-PAGESZ
	JAL	R10,X.MMDS		:display info on this segment
	LHI	R12,2*A.XRAY		:now point ot Xray segment
       EI	SUPER

:	now ready to do XRAY segment
	LA	R11,X.MMT6		:XRAY seg name
	L	R6,CHKDAT+4,R12,R12	:get Xray segment size
	JAL	R10,X.MMDS		:display info on this segment
:	now CTA (seg e)
	AIS	R12,2			:get seg index correct for display
	LA	R11,X.MMT7		:XRAY seg name
	L	R6,CHKDAT,,		:get CTA segment size
	JAL	R10,X.MMDS		:display info on this segment
:	now IDA (seg f)
	AIS	R12,2			:get seg index correct for display
	LA	R11,X.MMT8		:XRAY seg name
	LHL	R6,LO.CLK,,		:pointer to last thing in seg F
	AHI	R6,PAGESZ-1		:round up to next page
	NHI	R6,-PAGESZ
	JAL	R10,X.MMDS		:display info on this segment
:	and now done
	J	XPRMPT,,		:exit
	
:	X.MMDS  a little subroutine to print out info on a Segment
:		R12 = seg num*2  R6 = size of segment  R11 = name of seg
:	Link on R10

X.MMDS	LR	R3,R12			:segment number*2
	SRLS	R3,1			:actual seg number
	JAL	R9,TYPBYT,,		:print seg number
	LR	R2,R11			:get name of segment
	JAL	R7,TYPASC,,
	EXHR	R3,R3			:seg num to seg starting address
       IF	MACV
	SLLS	R3,4			:convert to macv address
       EI	:MACV
	JAL	R9,TYP6CH,,		:print start of segment
	AR	R3,R6			:add in size of seg to get end of seg
	JAL	R9,TYP6CH,,		:print end of seg
	LR	R3,R6			:get seg size
	JAL	R9,TYP6CH,,		:print size of seg
	JAL	R7,TYPCRL,,
	JR	R10

	ENDMO.(XRAY)
	EI	:1-KILLIT
	KILMSG(XRAY)

:	***NOTHING PAST THIS POINT***

 	SUBTTL DEBUG
:
:		***   ***** ****   *   *   ***
:		*   * *     *   *  *   *  *
:		*   * ****  ****   *   *  *  **
:		*   * *     *   *  *   *  *   *
:		***   ***** ****    ***    ***

::#####################################################################
::
::	MODULE:			DEBUG
::
::	FUNCTION:		DEBUGGERS
::
::	SUBTTLS:		UTILITIES
::				PORT LOGON/LOGOFF DEBUGGER <LNFDBG>
::				CRQ BUILDING/ZAPPING DEBUGGER <CBZDBG>
::				BUFFER STRUCTURE DEBUGGER <BFSDBG>
::				NODE CODE - SUPE COMM. DEBUGGER <LPGDBG>
::				LINE/LINK DEBUGGER <LNKDBG>     ###sdw
::				OTHER DEBUGGING AIDS
::				XRAY COMMANDS
::
::	###LSH	THIS DEBUGGER IS IMPLEMENTED BY LOUISA HSU  
::
::#####################################################################

	IF	1-KILLIT		:TO ASSEMBLE OR NOT 

	BEGMO.

	SEG	0D			:DEBUGGER  RUNS IN SEGD

	SUBTTL DEBUG ( UTILITIES )

       IF      DBGON
::*********************************************************************
::
::      SUBROUTINE:     DBSVRG:                                 ###sdw
::      FUNCTION:       SAVES ALL REGS IN REGST TO GIVEN DEBUGGER RING
::      CALLING SEQ:    JAL     R4,INLNFB
::      INPUT:          R6 - RING POINTER
::                      R5 - RING SIZE
::                      R7 - RING ADDRESS
::      OUTPUT          R6 - RING POINTER
::*********************************************************************

DBSVRG  LA      R8,REGST        :finish setting up DBMOVE
        LHI     R9,$A 4*16      :save 16 regs of data
        JAL     R3,DBMOVE       :save data into ring
        JR      R4

::*********************************************************************
::
::	SUBROUTINE:	DBMOVE                                          :###sdw
::	FUNCTION:	MOVE DATA INTO SPECIFIED HISTORY RING
::	CALLING SEQ:	JAL	R3,DBMOVE
::	INPUT:		R5 - RING SIZE
::			R6 - POINTER INTO RING
::			R7 - RING ADDRESS
::			R8 - DATA ADDRESS
::			R9 - BYTES OF DATA TO MOVE (MINIMUM OF 2)
::
::*********************************************************************


DBMOVE  LIS     R1,0            :how far along
DBMOV1  LHL     R0,0,R1,R8      :get the halfword
        STH     R0,0,R6,R7      :store into ring
        AIS     R6,2            :bump pointer
        CR      R6,R5           :check wrap
        JLFS    DBMOV2          :no wrap
        LIS     R6,0
DBMOV2  AIS     R1,2            :bump pointer into data
        CR      R1,R9           :move enough data yet?
        JLBS    DBMOV1          :more to do
        JR      R3

       EI      :DBGON

	IF	LNFDBG

::*********************************************************************
::
::	SUBROUTINE:	INLNFH:
::	FUNCTION:	INCREMENT "LNFHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INLNFH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNFH	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,LNFSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLNFH


::*********************************************************************
::
::	SUBROUTINE:	INLNFB:
::	FUNCTION:	INCREMENT "LNFHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INLNFB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNFB	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,LNFSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLNFB

::*********************************************************************
::
::	SUBROUTINE:	EVNLNF:
::	FUNCTION:	EVEN UP "LNFHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNLNF
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNLNF	AIS	R6,1
	NHI	R6,-2		:INSURE HALF WORD BOUNDARY
	JR	R4		:END OF EVNLNF

::*********************************************************************
::
::	SUBROUTINE:	MRKLNF:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING LNFHST
::	CALLING SEQ:	JAL	R15,MRKLNF
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::			R3 - ROUTINE NUMBER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKLNF	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,LNFHST,R6,
	JAL	R4,INLNFH
	STH	R3,LNFHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INLNFH
	JR	R15			:END OF MRKLNF

::*********************************************************************
::
::	SUBROUTINE:	BUFLNF:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING LNFHST
::	CALLING SEQ:	JAL	R3,BUFLNF
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::			R2 - BUFFER NUMBER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFLNF	STH	R2,LNFHST,R6,	:BUFFER NUMBER
	JAL	R4,INLNFH
	LHL	R4,BF,R2,
	STH	R4,LNFHST,R6,	:BF OF BUFFER (R2)
	JAL	R4,INLNFH
	LHL	R4,BF+4,R2,
	STH	R4,LNFHST,R6,	:BF OF BUFFER (R2)+4
	JAL	R4,INLNFH
	JR	R3		:END OF BUFLNF


::*********************************************************************
::
::	SUBROUTINE:	CLALNF:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R10) INTO RING LNFHST
::	CALLING SEQ:	JAL	R3,CLALNF
::	INPUT:		R6  - RING POINTER
::			R10 - ADDRESS OF CALLER
::			R3 - LINK REGISTER
::	OUTPUT:		R6  - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

CLALNF	EXHR	R10,R10
	STH	R10,LNFHST,R6,                  :CALLER (R10)
	EXHR	R10,R10
	JAL	R4,INLNFH
	STH	R10,LNFHST,R6,
	JAL	R4,INLNFH
	JR	R3		:END OF CLALNF

	EI	:LNFDBG


	IF	CBZDBG

::*********************************************************************
::
::	SUBROUTINE:	INCBZH:
::	FUNCTION:	INCREMENT "CBZHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INCBZH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INCBZH	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,CBZSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INCBZH


::*********************************************************************
::
::	SUBROUTINE:	INCBZB:
::	FUNCTION:	INCREMENT "CBZHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INCBZB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INCBZB	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,CBZSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INCBZB

::*********************************************************************
::
::	SUBROUTINE:	EVNCBZ:
::	FUNCTION:	EVEN UP "CBZHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNCBZ
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNCBZ	AIS	R6,1
	NHI	R6,-2		:INSURE HALF WORD BOUNDARY
	JR	R4		:END OF EVNCBZ

::*********************************************************************
::
::	SUBROUTINE:	MRKCBZ:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING CBZHST
::	CALLING SEQ:	JAL	R15,MRKCBZ
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKCBZ	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,CBZHST,R6,
	JAL	R4,INCBZH
	STH	R3,CBZHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INCBZH
	JR	R15			:END OF MRKCBZ

::*********************************************************************
::
::	SUBROUTINE:	BUFCBZ:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING CBZHST
::	CALLING SEQ:	JAL	R3,BUFCBZ
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFCBZ	STH	R2,CBZHST,R6,	:BUFFER NUMBER
	JAL	R4,INCBZH
	LHL	R4,BF,R2,
	STH	R4,CBZHST,R6,	:BF OF BUFFER
	JAL	R4,INCBZH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,CBZHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INCBZH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFCBZ

::*********************************************************************
::
::	SUBROUTINE:	CL9CBZ:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R9) INTO RING CBZHST
::	CALLING SEQ:	JAL	R3,CL9CBZ
::	INPUT:		R6 - RING POINTER
::			R9 - ADDRESS OF CALLER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

CL9CBZ	EXHR	R9,R9
	STH	R9,CBZHST,R6,	:CALLER
	EXHR	R9,R9
	JAL	R4,INCBZH
	STH	R9,CBZHST,R6,
	JAL	R4,INCBZH
	JR	R3		:END OF CL9CBZ

	EI	:CBZDBG


	IF	BFSDBG

::*********************************************************************
::
::	SUBROUTINE:	INBFSH:
::	FUNCTION:	INCREMENT "BFSHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INBFSH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INBFSH	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,BFSSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INBFSH


::*********************************************************************
::
::	SUBROUTINE:	INBFSB:
::	FUNCTION:	INCREMENT "BFSHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INBFSB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INBFSB	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,BFSSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INBFSB

::*********************************************************************
::
::	SUBROUTINE:	EVNBFS:
::	FUNCTION:	EVEN UP "BFSHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNBFS
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNBFS	AIS	R6,1
	NHI	R6,-2		:INSURE HW BOUNDARY
	JR	R4		:END OF EVNBFS

::*********************************************************************
::
::	SUBROUTINE:	MRKBFS:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING BFSHST
::	CALLING SEQ:	JAL	R15,MRKBFS
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKBFS	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,BFSHST,R6,
	JAL	R4,INBFSH
	STH	R3,BFSHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INBFSH
	JR	R15			:END OF MRKBFS

::*********************************************************************
::
::	SUBROUTINE:	BUFBFS:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,BUFBFS
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFBFS	STH	R2,BFSHST,R6,	:BUFFER NUMBER
	JAL	R4,INBFSH
	LHL	R4,BF,R2,
	STH	R4,BFSHST,R6,	:BF OF BUFFER
	JAL	R4,INBFSH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,BFSHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INBFSH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFBFS

::*********************************************************************
::
::	SUBROUTINE:	CL3BFS:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R3) INTO RING BFSHST
::	CALLING SEQ:	JAL	R15,CL3BFS
::	INPUT:		R6 - RING POINTER
::			R3 - ADDRESS OF CALLER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

CL3BFS	EXHR	R3,R3
	STH	R3,BFSHST,R6,	:CALLER
	EXHR	R3,R3
	JAL	R4,INBFSH
	STH	R3,BFSHST,R6,
	JAL	R4,INBFSH
	JR	R15		:END OF CL3BFS

::*********************************************************************
::
::	SUBROUTINE:	FRLTDB:
::	FUNCTION:	SAVE "FREELT" INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,FRLTDB
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

FRLTDB	LHL	R4,FREELT
	STH	R4,BFSHST,R6,	:SAVE FREELT INTO RING BFSHST
	JAL	R4,INBFSH
	JR	R3		:END OF FRLTDB

::*********************************************************************
::
::	SUBROUTINE:	REBLDB:
::	FUNCTION:	SAVE "REBL" INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,REBLDB
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

REBLDB	LHL	R4,REBL
	STH	R4,BFSHST,R6,	:SAVE REBL INTO RING BFSHST
	JAL	R4,INBFSH
	JR	R3		:END OF REBLDB

	EI	:BFSDBG

	IF	LPGDBG

::*********************************************************************
::
::	SUBROUTINE:	INLPGH:
::	FUNCTION:	INCREMENT "LPGHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INLPGH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLPGH	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,LPGSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLPGH


::*********************************************************************
::
::	SUBROUTINE:	INLPGB:
::	FUNCTION:	INCREMENT "LPGHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INLPGB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLPGB	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,LPGSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLPGB

::*********************************************************************
::
::	SUBROUTINE:	EVNLPG:
::	FUNCTION:	EVEN UP "LPGHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNLPG
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNLPG	AIS	R6,1
	NHI	R6,-2		:INSURE HW BOUNDARY
	JR	R4		:END OF EVNLPG

::*********************************************************************
::
::	SUBROUTINE:	MRKLPG:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING LPGHST
::	CALLING SEQ:	JAL	R15,MRKLPG
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKLPG	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,LPGHST,R6,
	JAL	R4,INLPGH
	STH	R3,LPGHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INLPGH
	JR	R15			:END OF MRKLPG

::*********************************************************************
::
::	SUBROUTINE:	BUFLPG:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING LPGHST
::	CALLING SEQ:	JAL	R3,BUFLPG
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFLPG	STH	R2,LPGHST,R6,	:BUFFER NUMBER
	JAL	R4,INLPGH
	LHL	R4,BF,R2,
	STH	R4,LPGHST,R6,	:BF OF BUFFER
	JAL	R4,INLPGH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,LPGHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INLPGH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFLPG

	EI	:LPGDBG


	IF	LNKDBG

::*********************************************************************
::
::	SUBROUTINE:	INLNKH:
::	FUNCTION:	INCREMENT "LNKHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INLNKH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNKH	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,LNKSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLNKH


::*********************************************************************
::
::	SUBROUTINE:	INLNKB:
::	FUNCTION:	INCREMENT "LNKHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INLNKB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNKB	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,LNKSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLNKB

::*********************************************************************
::
::	SUBROUTINE:	EVNLNK:
::	FUNCTION:	EVEN UP "LNKHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNLNK
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************


EVNLNK	AIS	R6,1
	NHI	R6,-2		:INSURE HW BOUNDARY
	JR	R4		:END OF EVNLNK

::*********************************************************************
::
::	SUBROUTINE:	MRKLNK:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING LNKHST
::	CALLING SEQ:	JAL	R15,MRKLNK
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKLNK	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,LNKHST,R6,
	JAL	R4,INLNKH
	STH	R3,LNKHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INLNKH
	JR	R15			:END OF MRKLNK

::*********************************************************************
::
::	SUBROUTINE:	BUFLNK:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING LNKHST
::	CALLING SEQ:	JAL	R3,BUFLNK
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFLNK	STH	R2,LNKHST,R6,	:BUFFER NUMBER
	JAL	R4,INLNKH
	LHL	R4,BF,R2,
	STH	R4,LNKHST,R6,	:BF OF BUFFER
	JAL	R4,INLNKH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,LNKHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INLNKH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFLNK

::*********************************************************************
::
::	SUBROUTINE:	ST1LNK:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R8) INTO RING LNKHST
::	CALLING SEQ:	JAL	R3,ST1LNK
::	INPUT:		R6 - RING POINTER
::			R1 - WORD TO SAVE
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

ST1LNK	EXHR	R1,R1           :stores word of R1                      ###sdw
	STH	R8,LNKHST,R6,	:CALLER
	EXHR	R1,R1
	JAL	R4,INLNKH
	STH	R1,LNKHST,R6,
	JAL	R4,INLNKH
	JR	R3		:END OF ST1LNK

	EI	:LNKDBG



	SUBTTL 	DEBUG ( PORT LOGON/LOGOFF DEBUGGER <LNFDBG> )

	IF	LNFDBG		:PORT LOGON/LOGOFF DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	LINDB1
::	FUNCTION:	DEBUGGER 1 FOR LOGIN
::	CALLING SEQ:	JAL	R14,LINDB1
::
::*********************************************************************

LINDB1	LHL	R3,LINDIS       :DEBUGGER FOR LOGIN
	JER	R14
	LHL	R6,LNFPTR,,
	LIS	R3,2		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLNF
	STH	CHN,LNFHST,R6,	:ABS LOGIN CHANNEL NUMBER
	JAL	R4,INLNFH
	JAL	R3,BUFLNF	:STORE BUFFER STRUCTURE OF LOGIN BUFFER
	LHL	R3,TVRBUF
	STH	R3,LNFHST,R6,	:SUPERVISOR BUFFER
	JAL	R4,INLNFH
	STH	R0,LNFHST,R6,	:TID OF THE PORT
	JAL	R4,INLNFH
	STH	R6,LNFPTR,,
	JR	R14		:END OF LINDB1

	EI	:LNFDBG		:END OF PORT LOGON/LOGOFF DEBUGGER



	SUBTTL DEBUG ( CRQ BUILDING/ZAPPING DEBUGGER <CBZDBG> )

	IF	CBZDBG		:CIRCUIT BUILDING/ZAPPING DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	CRHDB1:
::	FUNCTION:	DEBUGGER 1 FOR CRQHCR
::	CALLING SEQ:	JAL	R14,CRHDB1
::
::*****************************************************************

CRHDB1	LHL	R3,CRQDIS       :DEBUGGER  1 FOR CRQHCR
	JER	R14
	LHL	R6,CBZPTR,,
	LIS	R3,8		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:BUFFER STRUCTURE OF ORIGINAL BUFFER
	STH	R6,CBZPTR,,
	JR	R14		:END OF CRHDB1

::*********************************************************************
::
::	SUBROUTINE:	CRQDB1:
::	FUNCTION:	DEBUGGER 1 FOR CRQ
::	CALLING SEQ:	JAL	R14,CRQDB1
::
::*********************************************************************

CRQDB1	LHL	R3,CRQDIS       :DEBUGGER  1 FOR CRQ
	JER	R14
	LHL	R6,CBZPTR,,
	LIS	R3,9		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,BUFCBZ	:BUFFER STRUCTURE OF NEEDLE BUFFER
	STH	R6,CBZPTR,,
	JR	R14		:END OF CRQDB1

::*********************************************************************
::
::	SUBROUTINE:	ZPHDB1:
::	FUNCTION:	DEBUGGER FOR ZAPHRD
::	CALLING SEQ:	JAL	R14,ZPHDB1
::
::*********************************************************************

ZPHDB1	LHL	R3,ZAPDIS	:DEBUGGER FOR  ZAPHRD
	JER	R14

	LHL	R6,CBZPTR,,
	LIS	R3,0A		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:STORE BUFFER STRUCTURE OF ORIGINAL BUF.
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPHDB1

::*********************************************************************
::
::	SUBROUTINE:	ZPVDB1:
::	FUNCTION:	DEBUGGER FOR ZAPV
::	CALLING SEQ:	JAL	R14,ZPVDB1
::
::*********************************************************************

ZPVDB1	LHL	R3,ZAPDIS	:DEBUGGER FOR  ZAPV
	JER	R14
	LHL	R6,CBZPTR,,
	LIS	R3,0B		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:SOTRE BUFFER STRUCTURE OF ORIGINAL BUF.
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPVDB1

::::*************************************************
:  Debugger for gateway GB3CR3
:   R5 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB3  LHL     R3,ZAPDIS       :DEBUGGER FOR DB3CR3
        JER     R14

	LHL	R6,CBZPTR,,
	LHI	R3,1E		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
        STH     R5,CBZHST,R6,    :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPVDB1
        EI      :T2GATE

::::*************************************************
:  Debugger for gateway ZAPX7
:   R3 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB2	LHL	R3,ZAPDIS	:DEBUGGER FOR  ZAPX7
	JER	R14
	LHL	R6,CBZPTR,,
	LHI	R3,1E		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
        L       R3,REGST+3*4    :we want what was register R3
        STH     R3,CBZHST,R6,   :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPVDB1
        EI      :T2GATE


::::*************************************************
:  Debugger for gateway GLZPV
:   r9 link, r5 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB1	LHL	R3,ZAPDIS	:DEBUGGER FOR  GLZPV
        JER     R14
	LHL	R6,CBZPTR,,
	LHI	R3,1C		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
        STH     R5,CBZHST,R6,    :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPVDB1
        EI      :T2GATE

::*******************************************************
:   Replace NDREAD's use of buffers by use of debugging routine
:       All of buffer in R2 is needle
:                                       sdw
::********************************************************

       IF       NDREAD

NEDDB1  LHL     R3,CRQDIS       :level 2
        JER     R14
        LHL     R6,CBZPTR,,
        LIS     R3,7            :debugger #7
        JAL     R15,MRKCBZ
        L       R3,BB,R2,       :get start of data
	JER	R14		:nothing to display
NEDDB2  JAL     R8,PCI,,
        STB     R1,CBZHST,R6,
        JAL     R4,INCBZB
        C       R3,BE,R2,
        JNBS    NEDDB2          :copy needle
        AIS     R6,1
        NHI     R6,-2           :put on HW boundary again
        STH     R6,CBZPTR,,
        JR      R14

       EI       :NDREAD

       IF       SUPER           :supe build zap debuggers
::*****************************************************************
::   SUIDB1 save chn 1 msg into ring (these generally cause the supe
::          to zap the circuit so belong in build zap debugger)         ###sdw
::**********************************************************************

SUIDB1  LHL     R3,ZAPDIS       :deals with zapping
        JER     R14
        LHL     R6,CBZPTR,,     :ring pointer
        LHI     R3,0E           :for supe control (error) chars
        JAL     R15,MRKCBZ,,    :put a mark into buffer
        STH     R5,CBZHST,R6,   :chn number of bad chars
        JAL     R4,INCBZH
        LHL     R0,REGST,,      :get message type
        STH     R0,CBZHST,R6,   :save it
        JAL     R4,INCBZH       :update ring
        LHL     R0,SUICHR       :get offending chars
        JAL     R4,INCBZH
        STH     R6,CBZPTR,,     :save pointer
        JR      R14             :and done

        EI      :SUPER          :supe zapping

	EI	:CBZDBG		:END OF CRQ BUILDING/ZAPPING DEBUGGER



	SUBTTL DEBUG ( BUFFER STRUCTURE DEBUGGER <BFSDBG> )

	IF	BFSDBG		:BUFFER STRUCTURE DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	GFCDB1:
::	FUNCTION:	DEBUGGER FOR GFCBUF
::	CALLING SEQ:	JAL	R14,GFCDB1
::
::*********************************************************************

GFCDB1	LHL     R3,GRFDIS
        JER     R14
	LHL	R6,BFSPTR,,	
	LIS	R3,0C		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R15,CL3BFS
	LHL	R2,FREELB
	STH	R2,BFSHST,R6,	:BUFFER NUMBER
	JAL	R4,INBFSH
	STH	R6,BFSPTR,,	
	JR	R14		:END OF GFCDB1

::*********************************************************************
::
::	SUBROUTINE:	RFCDB1:
::	FUNCTION:	DEBUGGER FOR RFCBUF
::	CALLING SEQ:	JAL	R14,RFCDB1
::
::*********************************************************************

RFCDB1	LHL     R3,GRFDIS
        JER     R14
	LHL	R6,BFSPTR,,
	LIS	R3,0D		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R15,CL3BFS
	JAL	R3,BUFBFS	:STORE THE BUFFER (R2)'S STRUCTURE
	STH	R6,BFSPTR,,	
	JR	R14		:END OF RFCDB1

::*********************************************************************
::
::	SUBROUTINE:	CBCDB1:
::	FUNCTION:	DEBUGGER 1 FOR CBCLR
::	CALLING SEQ:	JAL	R14,CBCDB1
::
::*********************************************************************

CBCDB1	LHL	R3,CBCDIS	:DEBUGGER  1 FOR   CBCLR
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,0F		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R15,CL3BFS
	JAL	R3,BUFBFS	:STRUCTURE OF ORIGINAL BUFFER
	LHL	R4,BCT,R2,
	STH	R4,BFSHST,R6,	:BCT OF ORIGINAL
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:OLD FREELT (BEFORE BUFFER IS CLEARED)
	STH	R6,BFSPTR,,
	JR	R14		:END OF CBCDB1

::*********************************************************************
::
::	SUBROUTINE:	CBCDB2:
::	FUNCTION:	DEBUGGER 2 FOR CBCLR
::	CALLING SEQ:	JAL	R14,CBCDB2
::
::*********************************************************************

CBCDB2	LHL	R3,CBCDIS	:DEBUGGER  2 FOR  CBCLR
        JER     R14
	LHL	R6,BFSPTR,,
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS CLEARED)
	STH	R6,BFSPTR,,
	JR	R14		:END OF CBCDB2

::*********************************************************************
::
::	SUBROUTINE:	WREDB1:
::	FUNCTION:	DEBUGGER 1 FOR WRE
::	CALLING SEQ:	JAL	R14,WREDB1
::
::*********************************************************************

WREDB1	LHL	R3,WREDIS	:DEBUGGER 1 FOR  WRE
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,10		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R0		:CALLER (R0)
	JAL	R15,CL3BFS
	JAL	R3,FRLTDB	:OLD FREELT (BEFORE LINK RESERVE TANK)
	JAL	R3,REBLDB	:OLD REBL (BEFORE LINK RESERVE TANK)
	STH	R6,BFSPTR,,
	JR	R14		:END OF WREDB1

::*********************************************************************
::
::	SUBROUTINE:	WREDB2:
::	FUNCTION:	DEBUGGER 2 FOR WRE
::	CALLING SEQ:	JAL	R14,WREDB2
::
::*********************************************************************

WREDB2	LHL	R3,WREDIS	:DEBUGGER 2 FOR  WRE
        JER     R14
	LHL	R6,BFSPTR,,
	JAL	R3,FRLTDB	:NEW FREELT (AFTER LINK RESERVE TANK)
	JAL	R3,REBLDB	:NEW REBL (AFTER LINK RESERVE TANK)
	STH	R6,BFSPTR,,
	JR	R14		:END OF WREDB2

::*********************************************************************
::
::	SUBROUTINE:	CKZDB1:
::	FUNCTION:	DEBUGGER 1 FOR CKZB
::	CALLING SEQ:	JAL	R14,CKZDB1
::
::*********************************************************************

CKZDB1	LHL	R3,WREDIS	:DEBUGGER 1  FOR  CKZB
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,11		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	JAL	R3,FRLTDB	:NEW FREELT (AFTER GOT 80 BUFFERLETS
				:AND REFILLED THE RESERVE TANK)
	JAL	R3,REBLDB	:NEW REBL (AFTER GOT 80 BUFFERLETS 
				:AND REFILLED THE RESERVE TANK)
	STH	R6,BFSPTR,,
	JR	R14		:END OF CKZDB1

::*********************************************************************
::
::	SUBROUTINE:	RBZDB1
::	FUNCTION:	DEBUGGER 1 FOR REBZ
::	CALLING SEQ:	JAL	R14,RBZDB1
::
::*********************************************************************

RBZDB1	LHL	R3,WREDIS	:DEBUGGER 1 FOR  REBZ
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,12		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	STH	R2,BFSHST,R6,	:THE BUFFER ZAPPED
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS ZAPPED)
	STH	R6,BFSPTR,,
	JR	R14		:END OF RBZDB1

::*********************************************************************
::
::	SUBROUTINE:	BFZDB1
::	FUNCTION:	DEBUGGER 1 FOR BUFZAP
::	CALLING SEQ:	JAL	R14,BFZDB1
::
::*********************************************************************

BFZDB1	LHL	R3,WREDIS	:DEBUGGER  1 FOR  BUFZAP
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,13		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R0		:CALLER (R0)
	JAL	R15,CL3BFS
	STH	R2,BFSHST,R6,	:BUFFER NUMBER TO BE ZAPPED
	JAL	R4,INBFSH	
	STH	R8,BFSHST,R6,	:BUFFER COUNT OF THE BUFFER 
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS CLEARED)
	JAL	R4,INBFSH
	STH	R6,BFSPTR,,
	JR	R14		:END OF BFZDB1


	EI	:BFSDBG		:END OF BUFFER STRUCTURE DEBUGGER



	SUBTTL	DEBUG ( NODE CODE - SUPE COMM. DEBUGGER <LPGDBG> )

	IF	LPGDBG

::*********************************************************************
::
::	SUBROUTINE:	LEPDB1
::	FUNCTION:	DEBUGGER 1 FOR LEP
::	CALLING SEQ:	JAL	R14,LEPDB1
::
::*********************************************************************

LEPDB1	LHL	R3,LPGDIS	:DEBUGGER  1  FOR  LEP
        JER     R14
	LHL	R6,LPGPTR,,
	LHI	R3,14		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	STH	R1,LPGHST,R6,	:LEADING 0
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	JR	R14		:END OF LEPDB1

::*********************************************************************
::
::	SUBROUTINE:	LEPDB2
::	FUNCTION:	DEBUGGER 2 FOR LEP
::	CALLING SEQ:	JAL	R14,LEPDB2
::	INPUT:		R5 - LRC (BYTE COUNT OF MESSAGE)
::
::*********************************************************************

LEPDB2	LHL	R3,LPGDIS	:DEBUGGER  2  FOR  LEP
        JER     R14
	LHL	R6,LPGPTR,,
	SIS	R5,2		:LRC INCLUDES LEADING 0 AND LRC ITSELF
        L       R3,BB,R2,
	JER	R14		:nothing to copy

HSULE3	JAL	R8,PCI,,	:THE DATA IN LEP BUFFER
	STB	R1,LPGHST,R6,
	JAL	R4,INLPGB
	SIS	R5,1		:DECREMENT THE BYTE COUNT
	JGBS	HSULE3

	JAL	R4,EVNLPG	:EVEN UP RING POINTER
	STH	R6,LPGPTR,,
	JR	R14		:END OF LEPDB2

::*********************************************************************
::
::	SUBROUTINE:	LPDDB1
::	FUNCTION:	DEBUGGER 1 FOR LEP0D
::	CALLING SEQ:	JAL	R14,LPDDB1
::
::*********************************************************************

LPDDB1	LHL	R3,LPDDIS	:DEBUGGER  1  FOR  LEP0D
        JER     R14
	LHL	R6,LPGPTR,,
	LHI	R3,16		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R4,INLPGH
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	LR	R3,R7
	NHI	R3,0E0
	STB	R3,LPGHST,R6,	:FLAG
	JAL	R4,INLPGB
	LR	R3,R7
	NHI	R3,1F
	STB	R3,LPGHST,R6,	:MESSAGE SUB TYPE
	JAL	R4,INLPGB
	STH	R6,LPGPTR,,
	JR	R14		:END OF LPDDB1

::*********************************************************************
::
::	SUBROUTINE:	LP9DB1:
::	FUNCTION:	DEBUGGER 1 FOR LEP09
::	CALLING SEQ:	JAL	R14,LP9DB1
::	INPUT:		R6 - LOGIN BUFFER
::			R7 - TO NETWORK BUFFER		
::
::*********************************************************************

LP9DB1	LHL	R3,LPDDIS	:DEBUGGER  1  FOR  LEP09
        JER     R14
	LR	R2,R6		:LOAD LOGIN BUFFER INTO R2
	LHL	R6,LPGPTR,,
	LHI	R3,17		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R7,LPGHST,R6,	:TO NETWORK BUFFER NUMBER
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	JR	R14		:END OF LP9DB1

::*********************************************************************
::
::	SUBROUTINE:	LP9DB2:
::	FUNCTION:	DEBUGGER 2 FOR LEP09
::	CALLING SEQ:	JAL	R14,LP9DB2
::	INPUT:		R3 - CASE #
::
::*********************************************************************

LP9DB2	LHL	R3,LPDDIS	:DEBUGGER  2 FOR  LEP09
        JER     R14
	LHL	R6,LPGPTR,,
	STH	R3,LPGHST,R6,	:CASE NUMBER
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	JR	R14		:END OF LP9DB2

::*********************************************************************
::
::	SUBROUTINE:	LPZDB1
::	FUNCTION:	DEBUGGER 1 FOR LEPZLI
::	CALLING SEQ:	JAL	R14,LPZDB1
::
::*********************************************************************

LPZDB1	LHL	R3,LPDDIS	:DEBUGGER  1  FOR  LEPZLI
        JER     R14
	LHL	R6,LPGPTR,,
	LHI	R3,18		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R4,INLPGH
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R6,LPGPTR,,
	JR	R14		:END OF LPZDB1


::*********************************************************************
::
::	SUBROUTINE:	LGGDB2
::	FUNCTION:	DEBUGGER 2 FOR LOGGER TO SAVE CASE #
::	CALLING SEQ:	JAL	R14,LGGDB2
::	INPUT:		R1 - CASE #
::
::*********************************************************************

LGGDB2	LHL	R3,LPGDIS	:DEBUGGER  2 FOR  LOGGER
        JER     R14
	LHL	R6,LPGPTR,,
	LHI	R3,15		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R1,LPGHST,R6,	:CASE #
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	JR	R14		:END OF LGGDB2

::*********************************************************************
::
::	SUBROUTINE:	LGGDB3
::	FUNCTION:	DEBUGGER 3 FOR LOGGER
::	CALLING SEQ:	JAL	R14,LGGDB3
::	INPUT:		R2 - TVRBUF (SUPERVISOR BUFFER)
::
::*********************************************************************

LGGDB3	LHL	R3,LPGDIS	:DEBUGGER  3  FOR  LOGGER
        JER     R14
	LHL	R6,LPGPTR,,
	LHL	R3,BCT,R2,	:IS BUFFER EMPTY ?
	JLER	R14		:YES

	L	R3,LPGSSV	:GET POINTER TO MSG TYPE
HSULG5	LB	R1,0,R3		:GET CHARACTER
	STB	R1,LPGHST,R6,
	JAL	R4,INLPGB
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JEFS	HSULG6		:YES
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	J	HSULG5		:CONTINUE TO GET CHAR.
HSULG6	JAL	R4,EVNLPG	:EVEN UP RING POINTER
	STH	R6,LPGPTR,,
	JR	R14		:END OF LGGDB3

	EI	:LPGDBG		:END OF NODE CODE - SUPE COMM DEBUGGER


	SUBTTL	DEBUG ( LINK/LINE DEBUGGER <LNKDBG> )

	IF	LNKDBG		:LINE/LINK DEBUGGER                     ###sdw

::*********************************************************************
::
::      SUBROUTINE:     RTSDB1, RMSDB1
::      FUNCTION:       SAVES ALL REGS AT TIME OF LINK SNIP
::      CALLING SEQ:    JAL     R14,RTSDB1 (JAL R14,RMSDB1)
::      INPUT:          SAVED REGS AT REGST
::
::*********************************************************************

RMSDB1  LIS     R3,1            :RMK link snip
        JFS     RMSDB9
RTSDB1  LIS     R3,0            :RTD link Snip
RMSDB9  LHL     R6,LNKPTR,,     :get pointer of ring
        JAL     R15,MRKLNK      :put routine mark into ring
        LHI     R5,LNKSIZ       :set ourselves up for save reg routine
        LA      R7,LNKHST,,
        JAL     R4,DBSVRG       :move all saved regs to ring
        STH     R6,LNKPTR,,     :move all saved regs to ring
        JR      R14

::*********************************************************************
::
::	SUBROUTINE:	RTSDB2
::	FUNCTION:	SAVE PACKET THAT CAUSED LINK SNIP
::	CALLING SEQ:	JAL	R14,RTSDB2
::	INPUT:		CD (r13)
::
::*********************************************************************


RTSDB2  LIS     R3,3                    :routine #3             ###sdw
        LHL     R6,LNKPTR,,
        JAL     R15,MRKLNK              :put in our mark
        LR      R3,R13                  :R3 is index into BREC
        LIS     R10,1                   :how many packets to save
        J       TSODB6

::*********************************************************************
::
::	SUBROUTINE:	TSIDB1
::	FUNCTION:	DEBUGGER 1 SAVES INPUT WINDOW OF UPTO 25% OF HIST RING
::	CALLING SEQ:	JAL	R14,TSIDB1
::	INPUT:		KD - R15 linK Descriptor
::
::*********************************************************************

TSIDB1  LHL     R3,LKLDIS       :we to run?
        JER     R14
        LIS     R3,5            :our mark for input packets
        LHL     R6,LNKPTR,,     :get our pointer
        JAL     R15,MRKLNK      :mark our routine name
        L       R15,REGST+KD*4  :restore KD
        LB      R10,WSIZ,KD     :number of packets to move
	LHL	R3,ISEC,KD	:INITIAL INPUT SECTOR (PACKET 0 MOD WSIZ)
        J       TSODB6          :put our packets

::*********************************************************************
::
::	SUBROUTINE:	TSODB1
::	FUNCTION:	DEBUGGER 1 SAVES OUTPUT WINDOW OF UPTO 25% OF HIST RING
::	CALLING SEQ:	JAL	R14,TSODB1
::	INPUT:		KD - R15 linK Descriptor
::
::*********************************************************************

TSODB1  LHL     R3,LKLDIS       :we to run?
        JER     R14
        LIS     R3,4            :our mark for output packets
        LHL     R6,LNKPTR,,     :get our pointer
        JAL     R15,MRKLNK      :mark our routine name
        L       R15,REGST+KD*4  :restore KD
	LHL	R3,OSEC,KD	:INITIAL OUTPUT SECTOR (PACKET 0 MOD WSIZ)
	LB	R10,WSIZ,KD	:NUMBER OF PACKETS TO MOVE


:       Line/link packet save logic  R10 = number packets to save
:                                    R3  = index into BREC
TSODB6                          :our save packets routine name
	L	R3,BREC,R3
        LHI     R5,LNKSIZ       :get ring size
        LA      R7,LNKHST,,     :get ring address
	LR	R8,R3		:R8 POINTS TO FIRST SECTOR
        LIS     R11,0           :total moved (don't do too much)
TSODB9  LB      R9,0,R8         :get BORI
        NHI     R9,0F           :get count
        LB      R9,SYTWCN,R9,
        JAL     R3,DBMOVE       :move data to ring
        AHI     R8,80           :move it up to next packet in sector
        AR      R11,R9          :update how many moved
        CLHI    R11,LNKSIZ/8    :no more than 25% of ring
        JGFS    TSODB8
        SIS     R10,1
        JG      TSODB9          :move the entire window
TSODB8  STH     R6,LNKPTR,,
	JR	R14		:RETURN


::*********************************************************************
::
::	SUBROUTINE:	SIPDB1
::	FUNCTION:	DEBUGGER 1 SAVES BAD SIO PACKET (1ST 20 BYTES OF IT)
::	CALLING SEQ:	JAL	R14,SIPDB1
::	INPUT:		LN - R14 Line Number
::
::*********************************************************************

       IF       SILINS

SIPDB1  LHL     R3,LKLDIS       :is this debugger in use?
        JER     R14
	LHL	R8,PSLNUM	:Check if have line to check
        JLR     R14             :no line being traced
	AR	R8,R8		:2*LINE#
	CLH     R8,RGST+LN*4    :against the current (saved) line number
        JNR     R14
        LHL     R6,LNKPTR,,     :get pointer into our ring
        LIS     R3,6            :Bad SIO record received
        JAL     R15,MRKLNK      :save routine name
        LR      R1,R9           :save link (to SIPKSV)
        JAL     R3,ST1LNK       :save it
        STH     R8,LNKHST,R6,   :save line number
        JAL     R4,INLNKH
	LHI	R9,PKSVLH	:TOTAL LENTH OF SAVING
SIPDB9	L	R1,SIBUF,R11,R13
        GL      SIBUF
	AIS	R11,4
        SIS     R9,4            :count of how many saved
        JAL     R3,ST1LNK       :save it
        JGEBS   SIPDB9
        STH     R6,LNKPTR,,
	JR	R14
       EI       :SILINS

::*********************************************************************
::
::      SUBROUTINE:     SIBDB1
::      FUNCTION:       SAVES FIRST TWO WORDS OF SIO BUF WITH ILLEGAL
::                      COUNT AND R10-R15.
::      CALLING SEQ:    JAL     R14,SIBDB1
::      INPUT:          SIBUF, SIBUF+4 REGS 10-15
::
::*********************************************************************

       IF       SILINS

SIBDB1  LHL     R3,LKLDIS               :enabled?
        JER     R14
        LHL     R6,LNKPTR,,
        LHI     R3,19                   :debugger routine #
        JAL     R15,MRKLNK              :put in our mark
        LHI     R5,LNKSIZ               :set ourselves up for DBMOVE
        LA      R7,LNKHST,,             :ring address
        LIS     R9,8                    :bytes to move (two words)
        L       R11,RGST+4*R11
        L       R13,RGST+4*R13
        LA      R8,SIBUF,R11,R13        :start of sio buffer
        JAL     R3,DBMOVE               :save first two words
        LA      R8,RGST+4*R10           :now regs r10-r15
        LHI     R9,6*4                  :6 Regs
        JAL     R3,DBMOVE
        STH     R6,LNKPTR,,
        JR      R14                     :done                           ###sdw

       EI       :SILINS


	EI	:LNKDBG		:END OF LINK/LINE DEBUGGER


	SUBTTL	DEBUG (OTHER DEBUGGING AIDS)

::*********************************************************************
::
::	SUBROUTINE:	BFZDB2
::	FUNCTION:	DEBUGGER 2 FOR BUFZAP PROBLEM
::			SAVE SOME DATA OF THE BUFFER TO BE ZAPPED
::	CALLING SEQ:	JAL	R14,BFZDB2
::	INPUT:		R2 - BUFFER NUMBER TO BE ZAPED
::
::*********************************************************************

BFZDB2	LIS	R6,0		:POINTER TO THE SAVED BUFFER
:	doesn't matter why data is zapped to want to see the data
	L	R3,BB,R2,
HSUFZ5	LB	R1,0,R3		:GET CHARACTER
	STB	R1,BUFZSV,R6,	:STORE INTO BUFFER BUFZSV.
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JER	R14		:YES, EXIT
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	AIS	R6,1		:INCREMENT POINTER
	CHI	R6,BUFZSZ	:HAVE WE STORED BUFSZ BYTES YET ?
	JL	HSUFZ5		:CONTINUE GETTING CHAR.
	JR	R14		:END OF BFZDB2


	SUBTTL	DEBUG (XRAY COMMANDS)

::*********************************************************************
::
::	TABLE:		INTERP
::	FUNCTION:	THIS IS A TABLE TO SHOW 7-LETTER INTERPRETATIONS
::			FOR SOME OF THE ROUTINES.  ALL STRINGS MUST BE 7 CHARS
::			SINCE THE BYTE COUNT MAKES IT AN EIGHT BYTE STRUCTURE.
::
::*********************************************************************
	IF	DBGON
INTERP	HS	0
	SC	/RTDsnip/	:		ROUTINE NUMBER 0
	SC	/RMKsnip/	:          	ROUTINE NUMBER 1
	SC	/LOGIN  /	:LOGIN		ROUTINE NUMBER 2
	SC	/SnpPCKT/	:		ROUTINE NUMBER 3
	SC	/OUTWNDW/	:		ROUTINE NUMBER 4
	SC	/INWNDW /	:TEAR LINK IN	ROUTINE NUMBER 5
	SC	/BadSIOR/	:		ROUTINE NUMBER 6
	SC	/NEEDLE /	:display needle ROUTINE NUMBER 7
	SC	/CRQHCR /	:CRQHCR		ROUTINE NUMBER 8
	SC	/CRQ    /	:CRQ		ROUTINE NUMBER 9
	SC	/ZAPHRD /	:ZAPHRD		ROUTINE NUMBER A
	SC	/ZPV    /	:ZAPV		ROUTINE NUMBER B
	SC	/GFCBUF /	:GFCBUF		ROUTINE NUMBER C
	SC	/RFCBUF /	:RFCBUF		ROUTINE NUMBER D
	SC	/ERRtoSP/	:chn 1 to supe  ROUTINE NUMBER E
	SC	/CBCLR  /	:CBCLR		ROUTINE NUMBER F
	SC	/WRE    /	:WRE		ROUTINE NUMBER 10
	SC	/CKZB   /	:CKZB		ROUTINE NUMBER 11
	SC	/REBZ   /	:REBZ		ROUTINE NUMBER 12
	SC	/BUFZAP /	:BUFZAP		ROUTINE NUMBER 13
	SC	/LEP    /	:LEP		ROUTINE NUMBER 14
	SC	/LOGGER /	:LOGGER		ROUTINE NUMBER 15
	SC	/LEP0D  /	:LEP0D		ROUTINE NUMBER 16
	SC	/LEP09  /	:LEP09		ROUTINE NUMBER 17
	SC	/LEPZLI /	:LEPZLI		ROUTINE NUMBER 18
	SC	/SIBufEr/	:SIOBER	        ROUTINE NUMBER 19
	SC	/unused /	:               ROUTINE NUMBER 1A
	SC	/unused /	:               ROUTINE NUMBER 1B
	SC	/GLZPV  /	:GLZPV		ROUTINE NUMBER 1C
	SC	/GB3CR3 /	:GB3CR3		ROUTINE NUMBER 1D
	SC	/ZAPX7  /	:ZAPX7		ROUTINE NUMBER 1E
MXRTNM	EQ	(.-INTERP)/8-1	:MAX ROUTINE NUMBER

::*********************************************************************
::
::	SUBROUTINE:	TYPCIU
::	FUNCTION:	TYPE MESSAGE "This command is in use"
::
::*********************************************************************
TYPCIU	LA	R2,ASCCIU	:TYPE "This command is in use."
	JAL	R7,TYPASC,,
	J	XRCRLF,,	:QUIT AND YIELD

ASCCIU	SC	/"0D"0AThis command is in use./

::*********************************************************************
::
::	SUBROUTINE:	RSTCIU
::	FUNCTION:	RESET COMMAND IN USE INDICATOR TO INDICATE
::			THE COMMAND IS NOT IN USE.
::			0 = NOT IN USE,  1 = IN USE.
::	INPUT:		R8 = THE POINTER TO THE INDICATOR
::*********************************************************************
RSTCIU	LIS	R3,0
	STH	R3,,R8,		:RESET COMMAND IN USE INDICATOR
	J	XRCRLF,,	:QUIT AND YIELD

::*********************************************************************
::
::	SUBROUTINE:	XRDSRN
::	FUNCTION:	DISPLAY ALL THE DATA IN A HISTORY RING
::	CALLING SEQ:	JUMP 
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - COMMAND IN USE INDICATOR
::
::*********************************************************************

XRDSRN	LR	R12,R11		:KEEP THE ORIGINAL RING POINTER IN R12
DBINS1  LH      R3,SAVHST,R11,  :FLUSH LEADING ZEROS
        JNFS    DBINST
        AIS     R11,2
        CR      R11,R5
        JLFS    DBNWP1
        LIS     R11,0
DBNWP1  CR      R11,R12
        JNBS    DBINS1          :loop until done or all no more leading 0s
        J       RSTCIU          :is done

:       Now that leading 0s are gone we are ready to start printing
DBINST				:INITIALIZE THE STATE MARKERS
	LIS	R6,0		:HEAD LINE INDICATOR.  1 -- HEAD LINE.
	LIS	R10,8		:MAX # OF HW PER LINE. 9 -- HEAD LINE.
DBGTHW	LH      R3,SAVHST,R11,
	LR	R6,R6		:ARE WE EXPECTING A ROUTINE NUMBER
	JL	DBRTNM		:YES,
	CHI	R3,HSUMRK	:NO, THEN IS THIS A ROUTINE MARKER ?
	JE	DBHEAD		:YES, 
	CHI	R10,8		:IS IT THE FIRST DATA BYTE ?
	JNFS	DBTPHW		:NO, NOT THE FIRST DATA
	LR	R6,R6		:NEW LINE OF DATA -- DO WE FOLLOW A
				:HEADER ?
	JNFS	DBTPHW		:YES, FOLLOW A HEADER, JUST TYPE DATA
	JAL	R7,TYPCRL,,	:OTHERWISE, START A NEW LINE
	JAL	R7,TYP8SP,,
:	NO, IT IS NOT THE FIRST DATA 
DBTPHW	JAL	R9,TYPHW,,	:OUTPUT THE HALFWORD IN HEX FROM R3
:	UPDATE THE STATE MARKERS
DBUPST	SIS	R10,1		:DECREMENT LINE COUNTER
	AIS	R11,2		:INCREMENT RING OUT POINTER
	CR	R11,R5		:CHECK FOR RING WRAP
	JLFS	DBNOWP		:NO,
	LIS	R11,0		:YES, WRAP, REINIT TO BEGINNING OF RING
DBNOWP	CR	R11,R12		:HAVE WE GOTTEN BACK TO THE START YET ?
	JE	RSTCIU		:YES, GO TO RESET THE COMMAND IN USE
				:INDICATOR, AND THEN EXIT
	LR	R10,R10		:CHECK FOR END OF LINE
	JE	DBINST		:YES, HAS REACHED THE END OF LINE
				:GO TO REINIT THE STATE MARKER, AND
				:KEEP ON READING FROM RING
	J	DBGTHW		:OTHERWISE, JUST KEEP ON READING FROM RING
:	FLUSH LEADING ZEROS
DBFLSH	AIS	R11,2		:INCREMENT RING OUT POINTER
	CR	R11,R5		:CHECK FOR RING WRAP
	JLFS	DBNWP		:NO,
	LIS	R11,0		:YES, WRAP, REINIT TO BEGINNING OF RING
DBNWP	CR	R11,R12		:HAVE WE GOTTEN BACK TO THE START YET ?
	JE	RSTCIU		:YES, GO TO RESET THE COMMAND IN USE
				:INDICATOR, AND THEN EXIT
	J	DBGTHW		:KEEP ON READING FROM RING

DBRTNM	LR	R3,R3		:CHECK IF GOT RIGHT ROUTINE NUMBER
	JL	DBFLSH		:NO, GET THE NEXT HW (get a new HW ###sdw)
	CHI	R3,MXRTNM	:SEE IF IT IS TOO BIG
	JG	DBFLSH		:IT IS TOO BIG, (get a new HW ###sdw 3-3-87)
	LR	R7,R3		:FOR INDEXING
        SLLS    R7,3            :make byte index into 8 byte index
	LA	R2,INTERP,R7,	:GET 7-LETTER INTERPRETATION
	JAL	R7,TYPASC,,	:TYPE 7-LETTER INTERPRETATION
	JAL	R7,TYP1SP,,	:TYPE 2 SPACES
	LIS	R6,1		:INDICATE HAVE GOTTEN ROUTINE NUMBER
	J	DBUPST		:GO TO UPDATE STATE MARKER
DBHEAD	JAL	R7,TYPCRL,,	:START A NEW LINE
	LCS	R6,1		:REINIT THE HEAD LINE INDICATOR
				: -1 INDICATES WE ARE EXPECTING A
				:ROUTINE NUMBER.
	LIS	R10,9		:REINIT THE HEAD LINE COUNTER
	J	DBFLSH		:FLUSH THE ROUTINE MARKER, AND THEN
				:GO TO GET THE ROUTNE NUMBER
	EI	:DBGON

::*********************************************************************
::
::	SUBROUTINE:	LGXRDB
::	FUNCTION:	XRAY COMMAND "LG" TO DISPLAY HISTORY RING  
::			LNFHST --- PORT LOGON/LOGOFF HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	LNFDBG
LGXRDB	LHI	R5,LNFSIZ
	LHL	R11,LNFPTR,,
	TS	LGINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,LGINUS
	LA	R1,LNFHST+LNFSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+LNFSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(LNFSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING LNFHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:LNFDBG		:THE END OF LGXRDB
::*********************************************************************
::
::	SUBROUTINE:	CZXRDB
::	FUNCTION:	XRAY COMMAND "CZ" TO DISPLAY HISTORY RING  
::			CBZHST --- CIRCUIT BUILDING/ZAPPING HISTORY 
::					RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	CBZDBG
CZXRDB	LHI	R5,CBZSIZ
	LHL	R11,CBZPTR,,
	TS	CZINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,CZINUS
	LA	R1,CBZHST+CBZSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+CBZSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(CBZSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING CBZHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:CBZDBG		:THE END OF CZXRDB
::*********************************************************************
::
::	SUBROUTINE:	BFXRDB
::	FUNCTION:	XRAY COMMAND "BF" TO DISPLAY HISTORY RING  
::			BFSHST --- BUFFER STRUCTURE  HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	BFSDBG
BFXRDB	LHI	R5,BFSSIZ
	LHL	R11,BFSPTR,,
	TS	BFINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,BFINUS
	LA	R1,BFSHST+BFSSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+BFSSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(BFSSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING BFSHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:BFSDBG		:THE END OF BFXRDB
::*********************************************************************
::
::	SUBROUTINE:	LLXRDB
::	FUNCTION:	XRAY COMMAND "LL" TO DISPLAY HISTORY RING  
::			LPGHST --- LEP/LOGGER HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11- RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	LPGDBG
LLXRDB	LHI	R5,LPGSIZ
	LHL	R11,LPGPTR,,
	TS	LLINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,LLINUS
	LA	R1,LPGHST+LPGSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+LPGSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(LPGSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING LPGHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:LPGDBG		:THE END OF LLXRDB
::*********************************************************************
::
::	SUBROUTINE:	LHXRDB
::	FUNCTION:	XRAY COMMAND "LH" TO DISPLAY HISTORY RING  
::			LNKHST --- LINE/LINK HISTORY RING.
::			LNKHST --- LINK/LINK RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	LNKDBG
LHXRDB	LHI	R5,LNKSIZ
	LHL	R11,LNKPTR,,
	TS	LKINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,LKINUS
	LA	R1,LNKHST+LNKSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+LNKSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(LNKSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING LNKHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:LNKDBG		:THE END OF LHXRDB

::*********************************************************************
::
::	SUBROUTINE:	THXRDB
::	FUNCTION:	XRAY COMMAND "TH" TO TURN ON/OFF HISTORY TRACE
::	CALLING SEQ:	JUMP FROM XLOOP
::	INPUT:		R3=ARGUMENT
::
::*********************************************************************

	IF	DBGON
THXRDB	CLHI	R2,4		:MUST BE SINGLE ARG
	JN	COMERR,,
	L	R3,VALUE1,XD	:GET TRACING LEVEL
	CHI	R3,0
	JE	THXR00		:LEVEL = 0, GO TO TURN FLAGS OFF
	CHI	R3,1
	JL	COMERR,,	:EXIT, IF LEVEL < 1
	CHI	R3,3		:					###wjl
	JG	COMERR,,	:EXIT, IF LEVEL > 3
	J	THXR01		:GO TO TURN FLAGS ON
THXR00	LIS	R1,0		:ARGUMENT  = 0
	LIS	R3,3		:TURN OFF ALL THE DEBUGGERS		###wjl
	J	THXR
:	ARGUMENT  >= 1  AND <= 3
THXR01	LIS	R1,1
THXR	HS	0
	IF	CBZDBG
	STH	R1,ZAPDIS
	EI	:CBZDBG
	IF	BFSDBG
	STH	R1,GRFDIS
	EI	:BFSDBG
	IF	LPGDBG
	STH	R1,LPGDIS
	EI	:LPGDBG
	CHI	R3,2		:IS ARGUMENT >= 2 ?
	JL	XRCRLF,,	:NO, EXIT
THXR02	HS	0		:YES, ARGUMENT >= 2 AND <= 3
	IF	LNFDBG
	STH	R1,LINDIS
	EI	:LNFDBG
	IF	CBZDBG
	STH	R1,CRQDIS
	EI	:CBZDBG
	IF	BFSDBG
	STH	R1,CBCDIS
	EI	:BFSDBG
        IF      LNKDBG
        STH     R1,LKLDIS
        EI                      :LINK DEBUGGER
	IF	LPGDBG
	STH	R1,LPDDIS
	EI	:LPGDBG
	CHI	R3,3		:IS ARGUMENT = 3 ?
	JL	XRCRLF,,	:NO, EXIT
THXR03	HS	0		:YES
	IF	BFSDBG
	STH	R1,WREDIS
	EI	:BFSDBG
	J	XRCRLF,,	:EXIT

	EI	:DBGON

	ENDMO.(DEBUG)
	EI	:1-KILLIT
	KILMSG(DEBUG)

:	***NOTHING PAST THIS POINT***


	SUBTTL	FIN

:			***** ***** *   *
:			*       *   **  *
:			****    *   * * *
:			*       *   *  **
:			*     ***** *   *

::#####################################################################
::
::	MODULE:		F I N
::
::	FUNCTION:	SOME LAST MINUTE DEFINITIONS AND ERROR COMMENTS
::
::	SUBTTLS:
::		DMA region
::		Patch Areas, XRAY Symbol Table
::		Segment usuage
::		Physical addresses
::		BS - Bufferlet Statistics
::		Memory allocation symbol declaration
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE
	BEGMO.

:	SOME LAST MINUTE DEFINITIONS AND ERROR COMMENTS:

CRETIM	CURGMT
	SYAD(CRETIM)

        SEG.(0)
	RA	0

	SUBTTL	FIN (PATCH MACROS)

::*********************************************************************
::
::	MACRO:		PATHST:
::	FUNCTION:
::	Using this macro will cause the patch number, patch name,
::	and reason for patch to be output during assembly.
::	Also, a history table starting at PATHIS will be created with
::	16 (10hex) byte entries.
::	Each entry will contain the date and time of patch and the patch
::	name and can by displayed using the XRAY 'PQ' command.
::
::	The 'R'-file containing the actual patches to the code should
::	have appended the PATHST invocations specifying the patch history
::	for that file.
::
::	The following symbols are used by the patch macros.  They may be
::	read by, but should not be modified by, a patch.
::
::	PAHPTR	pointer to the next available entry in PATHIS
::
::	PATHST(yymmdd,hhmm,uname,comment)	grab a patch area
::
::		yymmdd	Date patch written, if patch is modified in ANY
::			way this must be updated.
::		hhmm	Time patch written, current Cupertino time.
::			If patch is modified this also must be updated.
::		name	Initials of person who authored patch and name of
::			patch all must be equal to or less than ten 
::			characters.  This will be the only description 
::			displayed under the PATCH NAME column by the PQ
::			 XRAY Cmd.
::		comment	Description of patch to be output during
::			assembly.  Commas should be preceeded by `.  Also
::			only 32 chrs will display on most screens.  The
::			string will not wrap and therefore chrs beyond 32
::			will not be seen.
::
::	Example:
::	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
::	  IF	HDLC&(LAPB!LAP)
::	PATHST(811009,1422,FODHDLCRMC,fix hdlc room checking routine)
::	  EI
::
::	:	PATCH TO FIX TRANSMITTER BUG
::	PATHST(811009,1630,DDMXMITBUG,fix transmitter bug)
::
::
::REVISION HISTORY:
::  DATE	INI	DESCRIPTION OF CHANGE
::--------	---	-----------------------------------------------
::01/25/93	dlg	Corrected comments
::03/01/93	sdw	taken from nc v7.10
::*********************************************************************

:	>>PATHST MACRO<<

	KILL	PATCH,CONPAT,ENDPATCH,PATHST

PATCH	MACRO(P)[
	REMARK	%%             The PATCH macro has been OBSOLETED
	REMARK	%             Please use the PATCHMERGE Facility
	REMARK %%
	QUIT 1    ; KILL SEG0,ctasiz
]

CONPAT	MACRO(P)[
	REMARK	%%             The CONPAT macro has been OBSOLETED
	REMARK	%             Please use the PATCHMERGE Facility
	REMARK %%
	QUIT 1    ; KILL SEG0,ctasiz
]

ENDPATCH MACRO(P)[
	REMARK	%%            The ENDPATCH macro has been OBSOLETED
	REMARK	%             Please use the PATCHMERGE Facility
	REMARK %%
	QUIT 1    ; KILL SEG0,ctasiz
]

PATHST	MACRO(day,tim,usr,c1,c2,c3,c4,c5)	[
	REMARK	%%PATCH added on day is number 
	number tim
	remark  and is called usr`.
	seg.(0D)
	ORG	PAHPTR

       IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
 remark %>>>> NOTE: PHSIZE is a Tymfile equate.  example:  PHSIZE EQ $0 300 <<<<%%
	REMARK %%
	QUIT 1    ; KILL SEG0,ctasiz
       EI	:(PAHPTR+1)-(PATHIS+PHSIZE)
	WC	$0 day!19000000		: install date
	HC	$0 tim			: install time
Q	AC	\usr\			: install username
Q1	HS
	ORG	Q+$a10			: skip to next history area
PAHPTR	HS
       IF	Q1-.			: IF UNAME>10 CHAR., CLEAR OVERFLOW
	 RE	Q1-.
	BC	0
	 ER
       EI	:Q1-.

	REMARK %	<<< c1`c2`c3`c4`c5 >>>
]					: PATCH() definition
::

	SUBTTL	FIN (Patch Areas, XRAY Symbol Table)

::*********************************************************************
::
::	PATCH AREAS
::
::	PATHIS:	defines the start of the patch history area,
::		each entry will be 16 bytes as follows,
::		19yy/mmdd/hhmm/uname(10 chars 0 filled)
::		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
::		digit) and uname is in ASCII.
::
::*********************************************************************

	seg.(0D)
PATHIS	WS	PHSIZE/4	:PATCH HISTORY TABLE

:	PAHPTR:	pointer to the next available entry in PATHIS
PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA


::*********************************************************************
::
::	TABLE:		SYMTBL:
::	FUNCTION:	Create the XRAY Symbol Table, at the end of seg D
::
::*********************************************************************

	SEG.(0D)			:Xray runs in SEGD

SYMTBL	WS	0
Q	EQ	0
	RE	NSYMBL
	SYAD|Q|
	KILL	SYAD|Q|
Q	EQ	Q+1
	ER
SRESER	HS	0			:SYMBOL RESERVE AREA
	ORG	.+(3*ADRESZ)		:room for HIADDR, ENDNOD, OPTMEM
SYMTSZ	EQ	.-SYMTBL		:SYMBOL TABLE ENDS HERE

	SUBTTL	FIN (Segment usuage)

::*********************************************************************
::
::	SEG 0 : NODE CODE DATA AREA
::	SEG 1 : NODE CODE EXECUTE-ONLY AREA
::	SEG 2 - SEG C : NEW DATA STRUCTURE:START FROM SEG 2 WILL BE IN
::		ONE MEMORY AREA, DATA THEN BUFFERLETS, NO SEG RESTRICTN##AL
::	SEG D : XRAY
::	SEG E : CTA TABLE
::
::*********************************************************************

:	DETERMINE SQSIZE FOR SEGS 0, 1, 0D, AND 0E
:	SEG1 is maximum size of a seg as only and all of seg 0 must be
:	before SEG1

        SEG.(0)
S0SIZE  EQ      .-SEG0
	if	.-chrbuf	:chrbuf must be final definition in SEG 0
	REMARK %%********** FATAL ERROR BY PROGRAMMER **********
	REMARK  %* Data variables were assigned to memory which
	REMARK  %* is already assigned for use as bufferlets.
	REMARK  %* Memory or data corruption may occur.  Please report
	REMARK  %* this problem immediately to support.
	ei


        SEG.(a.code)
CODSIZ	EQ      .-SEG1
       if	swtchr
	IF	(CODSIZ-segsiz)	:WARNS ASSEMBLER IF SEG1 OVERFLOW	###AL
	REMARK	%********** SEG1 SPACE NOT ENOUGH, S1SIZE =
	NUMBER $0 CODSIZ
	REMARK	%********** CONFIGURATION ERROR **********
	KILLER(1)
	EI
       else	:not swthcr (ie two segments possible for code)
	IF	(CODSIZ-(2*segsiz))	:WARNS ASSEMBLER IF SEG1 OVERFLOW
	REMARK	%********** SEG1 SPACE NOT ENOUGH, S1SIZE =
	NUMBER $0 CODSIZ
	REMARK	%********** CONFIGURATION ERROR **********
	KILLER(1)
	EI
       ei	:swtchr

	SEG.(a.xray)
XRYSIZ	EQ	.-SEGD			:XRAY CODE
	IF	(XRYSIZ-segsiz)	:WARNS ASSEMBLER IF SEGd OVERFLOW	###AL
	REMARK	%********** SEGD SPACE NOT ENOUGH, SDSIZE =
	NUMBER $0 XRYSIZ
	REMARK	%********** CONFIGURATION ERROR **********
	KILLER(1)
	EI

       if	macv
	SEG.(3)
MACSIZ	EQ	.-SEG3			:size dma storage stuff
	if	.-chrbu0	:chrbu0 must be final definition in dma SEG
	REMARK %%********** FATAL ERROR BY PROGRAMMER **********
	REMARK  %* Data variables were assigned to memory which
	REMARK  %* is already assigned for use as bufferlets in the DMA Seg.
	REMARK  %* Memory or data corruption may occur.  Please report
	REMARK  %* this problem immediately to support.
	ei
       else	:not macv
MACSIZ	EQ	0
       ei	:

:	ROUND UP SEGMENT SIZES TO APPROPRIATE BOUNDARY
SCODSZ	EQ	(CODSIZ+PAGESZ-1)&(-PAGESZ)	:page size of the code segments
SMACSZ	EQ	(MACSIZ+PAGESZ-1)&(-PAGESZ)	:page size of the DMA segment
SXRYSZ	EQ	(XRYSIZ+PAGESZ-1)&(-PAGESZ)	:page size of XRAY
SESZ	EQ	(SESIZE+PAGESZ-1)&(-PAGESZ)	:page size of CTA

SDMASZ	eq	smacsz		:in case macv and no dma region

	if	macv*dmaavl	:if both present
	if	dmaavl-SMACSZ+1	:only if enough (+1 to allow exact fit
SDMASZ	EQ	DMAAVL		:make rest of FIN work
	ELSE
	REMARK	%%Fatal error - DMA region too small!%
	REMARK	%DMA memory requirement exceeds DMAMAP/SLOT parameter!%
	NUMBER	$A DMAAVL/1024
	REMARK	d KB is specified as available, MUST be increased by AT LEAST 
	NUMBER	$A ((SMACSZ-DMAAVL)/1024)
	REMARK	d KB!%
	ei ; ei

:	ASSIGN ISIS PHYSICAL ADDRESSES

CTASIZ	EQ	SESZ		:CTA TABLE IS ALL OF SEG E

:	HIADDR IS THE TOTAL STORAGE REQUIREMENT FOR CODE AND DATA AREAS,
:	EXCLUDING THE BUFFERLETS.
:	CHRBUF MARKS THE BEGINNING OF BUFFERLET STORAGE.
HIADDR	EQ	CTASIZ+chrbuf+SCODSZ+SDMASZ+SXRYSZ

:	COMPUTE THE SIZE OF THE EXCESS MEMORY TO BE ALLOCATED TO BUFFERLETS
	IF	MEMAVL-HIADDR
CHBFSZ	EQ	MEMAVL-HIADDR		:BUFFERLET AREA SIZE
MEMORE	EQ	0			:we have enough for code, etc,	###wjl
	ELSE	:NOT NEARLY ENOUGH MEMORY...
CHBFSZ	EQ	0
MEMORE	EQ	HIADDR-MEMAVL		:we need this much more for code, etc.
	EI	:MEMAVL-HIADDR

:	make sure bufferlets haven't run into the code segment
       if	(chrbuf+chbfsz+CBSZ-seg1)	:did it run into the code?
chbfsz	eq	seg1-(chrbuf+CBSZ)	:make it end when it reached the code
       ei

:	check if main bufferlets haven't run into the dma segment
      if	macv
       if	(chrbuf+chbfsz+CBSZ-(3*segsiz)) :seg 3 is our dma seg
chbfsz	eq	(3*segsiz)-(chrbuf+CBSZ)	:last bufferlet is before dma
       ei
      ei	:macv

:	If the DMA segment (seg 3) is larger than required then use the
:	extra memory for bufferlets
CHBFS0	EQ	0			:default to no buffers
	if	macv
	if	SDMASZ-(CHRBU0-seg3)-200 :was there enough worth using?
CHBFS0	eq	SDMASZ-(CHRBU0-seg3)	:if extra, use every last little bit
	ei ; ei

:	IF THERE ISN'T AT LEAST ONE BUFLET/CKT or if THERE IS LESS THAN 4K
:	BUFLET SPACE...make an error remark
	IF	(NCIRCS*10)-CHBFSZ-CHBFS0
	 if	20000-chbfsz		:if we have 128k of buffer space
chbcir	eq	0			:then we have enough to allow
	 else				:assembly to finish
CHBCIR	EQ	(NCIRCS*10)-CHBFSZ-CHBFS0 :we need at least one buflet/ckt###wjl
	 ei
	ELSE
CHBCIR	EQ	0			:we have at least one buflet/ckt###wjl
	EI
	IF	1000-CHBFSZ
CHB4K	EQ	1000-CHBFSZ		:we need at least 4k buflet space##wjl
	ELSE
CHB4K	EQ	0			:we have at least 4k buflet space##wjl
	EI

	IF	CHBCIR!CHB4K
MEMORE	EQ	MEMORE+CHBCIR+CHB4K		:a little extra won't hurt#wjl
	REMARK	%%Fatal error - configuration too large!%
	NUMBER	$A (MEMAVL+1023)/1024
	REMARK	d KB specified as available,%
	REMARK	MUST be increased by AT LEAST 
	NUMBER	$A (MEMORE+1023)/1024		:###wjl
	REMARK	d KB!%
	KILLER(1)
	EI	:CHBCIR!CHB4K

	if	memore*(chbfs0-memore)	:nc big enough, but dma too big
	REMARK	%DMA region is specified excessively large.  There is enough
	REMARK	%memory allocated.  The allocated memory cannot be effectively
	REMARK	%used as configured.  Please reduce DMA area closer to the
	REMARK	%minimum value of 
	number  $a(SMACSZ/1024)
	remark	d KB.%
	KILLER(1)
	ei

:	COMPUTE SIZES OF DATA SEGMENTS 0-0B (or 0-9).  Above CHBFSZ was
:	reduced to not overflow into anything else so can safely determine
:	sizes for all data segments without worrying about colliding into
:	some other seg.  Also, define size for any unused segments.
Q	EQ	(CHRBUF-SEG0)+CHBFSZ	:NOW COMPUTE SIZES OF SEGS 0-0B
Q1	EQ	0
	RE	$A 14
	IF	Q-segsiz
S|Q1|SIZE EQ	segsiz
	ELSE	:NOT Q-segsiz
	IF	Q
S|Q1|SIZE EQ	Q
	ELSE	:NOT Q
S|Q1|SIZE EQ	0
	EI	:Q
	EI	:Q-segsiz
Q	EQ	Q-segsiz
Q1	EQ	Q1+1
	ER

:	Compute sizes of the 2 code segments
q	eq	scodsz
q1	eq	a.code			:first code seg
	RE	2			:two code segs
	IF	Q-segsiz
S|Q1|SIZE EQ	segsiz
	ELSE	:NOT Q-segsiz
	IF	Q
S|Q1|SIZE EQ	Q
	ELSE	:NOT Q
S|Q1|SIZE EQ	0
	EI	:Q
	EI	:Q-segsiz
Q	EQ	Q-segsiz
Q1	EQ	Q1+1
	ER

S|A.XRAY|SIZE EQ  SXRYSZ		:compute size of xray segment
       if	macv
s3size	eq	sDMAsz		:dma region size
       ei	:macv

:	ROUND SEGMENT SIZES UP TO MAC PAGE BOUNDARY
Q	EQ	0
qq	eq	$a 14		:if not macv then use SEG 0 through SEG D
	RE	qq
S|Q|SZ	EQ	(S|Q|SIZE+PAGESZ-1)&(-PAGESZ)
Q	EQ	Q+1
	ER

:	COMPUTE ENDNOD, THE TOTAL AMOUNT OF MEMORY USED. THIS CAN NEVER BE 
:	LARGER THAN MEMAVL, THE AVAILABLE MEMORY.
ENDNOD	EQ	S0SZ+S1SZ+S2SZ+S3SZ+S4SZ+S5SZ+S6SZ+S7SZ+S8SZ+S9SZ+SASZ+SBSZ+SCSZ+SDSZ+SESZ

RCBFSZ	EQ	CHBFSZ			:REAL CHAR. BUFFERLET SIZE ###LSH
RCBFS0	EQ	CHBFS0			:real size for dma (seg 0) bufferlets

	SUBTTL	FIN (BS - Bufferlet Statistics)

::*********************************************************************
::
::	Bufferlet Statistics
::
::*********************************************************************

NBFLET	EQ	CHBFSZ/CBSZ	:NUMBER OF BUFFERLETS ALLOCATED
NBFLE0	eq	chbfs0/cbsz	:num of dma seg (seg 0) bufferlets
       if	macv
lbfnm0	eq	chrbu0+(nbfle0*cbsz))/cbsz	:last buffer number in seg3
       ei	:macv
NBFLE2	EQ	(NBFLET+NBFLE0)*(CBSZ-2)	

ISCALX	EQ	0		:DETERMINE SCALE PARAMETER FOR B'LET HISTOGRAM
ISTEP	EQ	$A1024		:ASSUME SMALLEST STEP SIZE
Q	EQ	$A13
	RE	$A10
QQX	EQ	1^Q-1
	IF	(NBFLE2-QQX)	:IF NBFLE2 IS LARGER
ISCALX	EQ	ISCALX+1	:INCREMENT SCALE FACTOR
ISTEP	EQ	ISTEP*2		:AND SCALE STEP SIZE
	EI
Q	EQ	Q+1
	ER
NSTEPS	EQ	NBFLE2/ISTEP+1	:NUMBER OF LINES TO DISPLAY

	ORG	XBUFH2
ISCALE	EQ	ISCALX+0A       :amount to shift in use
        IF      ISCALE-11       :MAX RANGE IS TO 2MEG BYTES IN 256K BYTE STEPS
        SC      /1.7M-2MEG/
        SC      /1.5M-1.7M/
        SC      /1.2M-1.5M/
        SC      /1MEG-1,2M/
        SC      /768K-1MEG/
        SC      /512K-768K/
        SC      /256K-512K/
        SC      /UNDER256K/
	ELSE	ISCALE-10       :MAX RANGE IS TO 1MEG BYTES IN 128K BYTE STEPS
        SC      /896K-1MEG/
        SC      /768K-896K/
        SC      /640K-768K/
        SC      /512K-640K/
        SC      /384K-512K/
        SC      /256K-384K/
        SC      /128K-256K/
        SC      /UNDER128K/
	ELSE	ISCALE-0F       :MAX RANGE IS TO 512K BYTES IN 64K BYTE STEPS
        SC      /448K-512K/
        SC      /384K-448K/
        SC      /320K-384K/
        SC      /256K-320K/
        SC      /192K-256K/
        SC      /128K-192K/
        SC      /64K -128K/
        SC      /UNDER 64K/
	ELSE	ISCALE-0E       :MAX RANGE IS TO 256K BYTES IN 32K BYTE STEPS
        SC      /224K-256K/
        SC      /192K-224K/
        SC      /160K-192K/
        SC      /128K-160K/
        SC      /96K -128K/
        SC      /64K - 96K/
        SC      /32K - 64K/
        SC      /UNDER 32K/
        ELSE	ISCALE-0D       :ISCALE = 14 => UP TO 128K BYTES IN 16K STEPS
        SC      /112K-128K/
        SC      /96K -112K/
        SC      /80K - 96K/
        SC      /64K - 80K/
        SC      /48K - 64K/
        SC      /32K - 48K/
        SC      /16K - 32K/
        SC      /UNDER 16K/
        ELSE	ISCALE-0C       :ISCALE = 13 => TO 64K IN 8K STEPS
        SC      /56K - 64K/
        SC      /48K - 56K/
        SC      /40K - 48K/
        SC      /32K - 40K/
        SC      /24K - 32K/
        SC      /16K - 24K/
        SC      /8K  - 16K/
        SC      /UNDER  8K/
        ELSE	ISCALE-0B       :ISCALE = 12
        SC      /28K - 32K/
        SC      /24K - 28K/
        SC      /20K - 24K/
        SC      /16K - 20K/
        SC      /12K - 16K/
        SC      / 8K - 12K/
        SC      / 4K -  8K/
        SC      /UNDER  4K/
        ELSE	ISCALE-0A       :ISCALE = 10
        SC      /14K - 16K/
        SC      /12K - 14K/
        SC      /10K - 12K/
        SC      / 8K - 10K/
        SC      / 6K -  8K/
        SC      / 4K -  6K/
	SC	/ 2K -  4K/
        SC      /UNDER  2K/
        ELSE                    :ISCALE=10d (smallest value)
        SC      / 7K -  8K/
        SC      / 6K -  7K/
        SC      / 5K -  6K/
	SC	/ 4K -  5K/
        SC      / 3K -  4K/
        SC      / 2K -  3K/
        SC      / 1K -  2K/
        SC      / UNDER 1K/
        EI

:	NUMBER OF DATA BYTES IN BUFFERLET

:	USER MAY DEFINE NUMBER OF BUFFERLETS/CIRCUIT REQUIRED
	IF	1-\BFPCIR
BFPCIR	EQ	40/(cbsz)	:DEFAULT TO 64d bytes of BUFFERLETS PER CIRCUIT
        if      1-bfpcir
bfpcir  eq      1
        ei      :1-bfpcir
	EI	:1-\BFPCIR

	IF	REBILD
	DEFAULT(BFPHIS,80/cbsz)	:MINIMUM # OF BFLETS PER HISTORY BUFFER
        if      1-bfphis
bfphis  eq      1
        ei      :1-bfphis
	ELSE	:
BFPHIS	EQ	0
	EI	:REBILD

OPTMEM	EQ	(HIADDR+(BFPCIR*NCIRCS*CBSZ)+(BFPHIS*NTERMS*CBSZ)-(nbfle0*cbsz))

:	put late symbols into symbol table
	ORG	SRESER
	AC	/HIADDR/
	HC	HIADDR/10000,HIADDR&0ffff
	AC	/ENDNOD/
	HC	ENDNOD/10000,ENDNOD&0ffff
	AC	/OPTMEM/
	HC	OPTMEM/10000,OPTMEM&0ffff

q	eq	.
	org	chkdat		:start of size definitions
	WC	SESZ		:CTASIZE -SEGMENT '0E' SIZE
	WC	S0SZ		:AREAS - SEGMENT SIZES
	WC	S1SZ
	WC	S2SZ
	WC	S3SZ
	WC	S4SZ
	WC	S5SZ		:NO LIMIT FOR ISIS SEG5##AL
	WC	S6SZ
	WC	S7SZ
	WC	S8SZ
	WC	S9SZ
	WC	SASZ
	WC	SBSZ
       IF	SUPER   	:supe shared mem doesn't use this
	WC	0		:we don't use our memory for the shared mem
       ELSE	:not SUPER
	WC	SCSZ
       EI	:SUPER
	WC	SDSZ
	org	q

	ENDMO.(FIN)
	EI	:1-KILLIT
	KILMSG(FIN)

BADCOD	ERRCNT
	KILLER(BADCOD)
	IF	KILLIT

	REMARK	%%%%
	REMARK	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%
	REMARK	!!! FATAL ERROR !!! FATAL ERROR !!!%
	REMARK	!!! ASSEMBLY HAS BEEN KILLED !!!!!!%
	REMARK	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	REMARK	%%%%

	if	1-dbgqut		:allow write out bad nib file
	quit 1
	KILL	SEG0,ctasiz		:Don't allow write-out
	ei	:dbgqut
	EI	:KILLIT

	UN

:	***NOTHING PAST THIS POINT***

	SUBTTL	CONFIG

:			 ***   ***  *   * ***** *****  ***
:			*   * *   * **  * *       *   *   *
:			*     *   * * * * ****    *   *
:			*   * *   * *  ** *       *   *  **
:			 ***   ***  *   * *     *****  ****

::#####################################################################
::
::	MODULE:		C O N F I G
::
::	FUNCTION:	Display assembly configuration
::
::#####################################################################

	IF	1-KILLIT

::*********************************************************************
::
::	Display assembly configuration, based on value of CONFIG -
::		CONFIG = 0 means no display
::			 1 means simple display
::		       > 1 means full display
::	Simple display (CONFIG = 1) looks like this:
::
::	TYMNET-II Node Code Version 5.12, ISIS Node
::
::	Node: 2161  Kernel Host: 633
::
::	Ports:		Lines:		Links:
::	    32d Pthru	    16d Sync	     6d TIILNK
::	     3d Xray	    18 SIO	    10d XLNK
::			    24d Total	    16d Total
::	   512d Disp
::	     4d Krnl
::
::	Maximum number of circuits =  604d
::
::
::	Bufferlet storage space:
::
::	 0AA76 bytes ( 43d KB) for  604d total circuits  ( 72d bytes per circuit)
::
::
::	Memory used by this configuration = 40000x, 256d KB.
::
::	Optimal amount of memory for this configuration =   246d  KB.
::
::*********************************************************************

	DEFAULT(CONFIG,(1+BLAB))

	IF	CONFIG

:	IDENTITY REMARKS...

	REMARK	%%TYMNET-II Node Code, Version 
	NUMBER $8(VERSION/100)&77
	 IF	$81-(VERSION&070)
	REMARK .0
	 ELSE	:NO LEADING ZERO REQUIRED
	REMARK .
	 EI	:$81-(VERSION&070)
	NUMBER $8VERSION&77
	  IF	T2GATE
	REMARK	, GATEWAY Node
	  ELSE
	REMARK	, ISIS Node
	  EI	:T2GATE
	CRLF.(2)
	REMARK	Node: 
	NUMBER	$8MACHNM

	IF	T2GATE
	REMARK	  H-Net Host (Kernel):
	NUMBER	$AHHOST
	REMARK    I-Net Host:
	NUMBER	$AIHOST
	CRLF.(2)
	ELSE	:NOT T2GATE

	REMARK	  Kernel Host: 
	NUMBER	$AHST0
	CRLF.(2)
	EI	:T2GATE

:	REPORT LINES AND LINKS AND PORTS
	REMARK	Ports:		Lines:		Links:
	CRLF.

	NMBR.(NPASTH,A,6)		:CHANGED BY ###EV
	REMARK	Pthru
	TAB.
	NMBR.((NLINES-SILINS),A,6)
	REMARK	Sync
	TAB.
	NMBR.((NLINKS-XLINKS),A,6)
	REMARK	TIILNK
	CRLF.

	NMBR.(NXUBLK-1,A,6)
	REMARK	Xray
	TAB.
	NMBR.(SILINS,A,6)
	REMARK	SIO
	TAB.
	NMBR.(XLINKS,A,6)
	REMARK	XLNK
	CRLF.

	TAB.(2)
	NMBR.(NLINES,A,6)
	REMARK	Total
	TAB.
	NMBR.(NLINKS,A,6)
	REMARK	Total
	CRLF.

	NMBR.(NDP,A,6)
	REMARK	Disp
	CRLF.

	NMBR.(NKU,A,6)
	REMARK	Krnl
	CRLF.

	 IF	SUPER
	NMBR.(NSP,A,6)
	REMARK	Supe
	CRLF.
	 EI	:SUPER

	CRLF.

	REMARK Maximum number of circuits = 
	NMBR.(NCIRCS,A,4)
	CRLF.(2)

BTPCIR	EQ	BFPCIR*(CBSZ-2)	: Bufferlet bytes per circuit -- Recommended
BTPHIS	EQ	BFPHIS*(CBSZ-2)	: Bufferlet bytes per history Buffer
NBFLBT	EQ	(NBFLET+NBFLE0)*(CBSZ-2) : Number of Bufferlet bytes
NCIRBT	EQ	NBFLBT		: Number of Circuit bytes
NHISBT	EQ	0		: Number of History bytes

	REMARK	%Bufferlet storage space:%%

	 IF	REBILD
	  IF	NBFLET+nbfle0+1-(NCIRCS*BFPCIR)
NCIRBT	EQ	NCIRCS*BTPCIR	:Number of Circuit bytes
	  ELSE
NCIRBT	EQ	NBFLBT
	  EI

	  IF	NBFLBT-NCIRBT
NHISBT	EQ	(NBFLBT-NCIRBT)	: Number of History bytes
	  EI

	NMBR.(NCIRBT,0,6)
	REMARK	bytes (
	NMBR.(((NCIRBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NCIRCS,A,4)
	REMARK	circuit buffers (
	NMBR.((NCIRBT/NCIRCS),A,3)
	REMARK	bytes per circuit)%

	NMBR.(NHISBT,0,6)
	REMARK	bytes (
	NMBR.(((NHISBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NTERMS,A,4)
	REMARK	history buffers (
	NMBR.((NHISBT/NTERMS),A,3)
	REMARK	bytes per termination)%
	 EI	:REBILD

	NMBR.(NBFLBT,0,6)
	REMARK	bytes (
	NMBR.(((NBFLBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NCIRCS,A,4)
	REMARK	total circuits  (
	NMBR.((NBFLBT/NCIRCS),A,3)
	REMARK	bytes per circuit)%%

Q	EQ	(NCIRCS*BTPCIR)+(NTERMS*BTPHIS)

	 IF	Q-NBFLBT
	REMARK	****************************************************************
	REMARK	%Number of bufferlets allocated is insufficient...%
	  IF	REBILD
	NMBR.(BTPCIR,A,3)
	REMARK	bytes per circuit buffer recommended, 
	NMBR.((NCIRBT/NCIRCS),A,3)
	REMARK	bytes allocated.%
	NMBR.(BTPHIS,A,3)
	REMARK	bytes per history buffer recommended, 
	NMBR.((NHISBT/NTERMS),A,3)
	REMARK	bytes allocated.%
	  EI	:REBILD
	NMBR.((((NCIRCS*BTPCIR)+(NTERMS*BTPHIS))/NCIRCS),A,3)
	REMARK	total bytes per circuit recommended,  
	NMBR.((NBFLBT/NCIRCS),A,3)
	REMARK	bytes allocated.%%
	NUMBER $A(100-(NBFLBT*100)/Q)
	REMARK	 percent below recommended level,
	NMBR.((((Q-NBFLBT)+2*((Q-NBFLBT)/(CBSZ-2))+1023)/1024),A,3)
	REMARK	KB additional memory recommended.%
	REMARK	****************************************************************
	 EI	:Q-ETC...

:	display optimale size for heavily utilized machines

    IF	REBILD
Q	EQ	(NCIRCS*BTPCIR)+(NTERMS*BTPHIS*2)
	 IF	Q-NBFLBT
	REMARK	****************************************************************
	REMARK	%For HEAVILY UTILIZED node, The number of bufferlets allocated is insufficient...%
	NMBR.(BTPCIR,A,3)
	REMARK	bytes per circuit buffer recommended, 
	NMBR.((NCIRBT/NCIRCS),A,3)
	REMARK	bytes allocated.%
	NMBR.(2*BTPHIS,A,3)
	REMARK	bytes per history buffer recommended, 
	NMBR.((NHISBT/NTERMS),A,3)
	REMARK	bytes allocated.%
	NMBR.((((NCIRCS*BTPCIR)+(NTERMS*2*BTPHIS))/NCIRCS),A,3)
	REMARK	total bytes per circuit recommended,  
	NMBR.((NBFLBT/NCIRCS),A,3)
	REMARK	bytes allocated.%%
	NUMBER $A(100-(NBFLBT*100)/Q)
	REMARK	 percent below recommended level,
	NMBR.((((Q-NBFLBT)+2*((Q-NBFLBT)/(CBSZ-2))+1023)/1024),A,3)
	REMARK	KB additional memory recommended.%
	REMARK	****************************************************************
	 EI	:Q-ETC...
    EI	:REBILD

	REMARK %Memory used by this configuration = 
	NUMBER $0 ENDNOD
	REMARK x, 
	NUMBER $A (ENDNOD+1023)/1024
	REMARK d KB.%


	REMARK %Optimal amount of memory for this configuration = 
	NMBR.(((OPTMEM+1023)/1024),A,4)
	REMARK  KB.%

    IF	REBILD
q	eq	(HIADDR+(BFPCIR*NCIRCS*CBSZ)+(BFPHIS*2*NTERMS*CBSZ)-(nbfle0*cbsz))
	REMARK %For HEAVILY UTILIZED node, Optimal amount of memory = 
	NMBR.(((q+1023)/1024),A,4)
	REMARK  KB.%
    EI	:REBILD


	IF	MACV*DMAAVL	:if both present
	IF	DMAAVL-SMACSZ+1	:only if enough (+1 to allow exact fit
	REMARK 	%DMA area used by this configuration = 
	NUMBER	$A DMAAVL/1024
	REMARK	d KB.%
	REMARK 	%Minimum DMA area required for this configuration = 
	NUMBER	$A SMACSZ/1024
	REMARK	d KB.%
	EI	:enough
	ELSE	SILINS*macv	:dmaavl not defined and needed
	REMARK  %  DMA memory not specified and configuration has SIO lines
	REMARK  %  which uses DMA.  The SIO lines will not work unless
	REMARK  %  the other slot's DMA regions and ISIS code requires
	REMARK  %  less than 
	NUMBER	$A 1024-((endnod-sdsz)/1024)
	REMARK	d KB.  This configuration has 
	NUMBER	$A SMACSZ/1024
	REMARK	d KB
	REMARK  %  of memory which must be in the first megabyte of memory.%
	EI	:macv


NMBR.s	MACRO(VAL,RADX,WDTH)[
	KILL	Q.
Q.`WDTH`Q	EQ	0
	IF	\Q.Q
QW	EQ	0
	ELSE	:
QW	EQ	WDTH
	EI	:
BASE0	EQ	10
BASE8	EQ	8
BASEA	EQ	0A
BASE2	EQ	2

QND	EQ	1
QMXN	EQ	BASE`RADX
	RE	QW
	IF	1-(QMXN-VAL)
QND	EQ	QND+1
QMXN	EQ	QMXN*(BASE`RADX)
	EI
	ER
QNB	EQ	QW-QND
QRADX	EQ	0`RADX
	IF	1-QRADX
	IF	((0A^((QND-1)*4))-(VAL))
	ELSE
QNB	EQ	QNB-1
	EI
	EI	:1-QRADX
	IF	QNB
	RE	QNB
	BLANK.
	ER
	EI	:QNB
	NUMBER	$RADX(VAL)
	]
:	for backass nad limit on repeat loop size of 640 chars
	kill	qqqwds
qqqwds	macro[
	if	.eq.(knsp|$aqqqsdw|,31)
	remark%MS  
	else	.eq.(knsp|$aqqqsdw|,23)
	remark%56  
	else	.eq.(knsp|$aqqqsdw|,20)
	remark%48  
	else	.eq.(knsp|$aqqqsdw|,16)
	remark%38.4
	else	.eq.(knsp|$aqqqsdw|,12)
	remark%28.8
	else	.eq.(knsp|$aqqqsdw|,08)
	remark%19.2
	else	.eq.(knsp|$aqqqsdw|,06)
	remark%14.4
	else	.eq.(knsp|$aqqqsdw|,04)
	remark% 9.6
	else	.eq.(knsp|$aqqqsdw|,03)
	remark% 7.2
	else	.eq.(knsp|$aqqqsdw|,02)
	remark% 4.8
	else	.eq.(knsp|$aqqqsdw|,01)
	remark% 2.4
	else
	remark%    
	ei
]

 remark%%Neighor  Window  Link   Link              Neighor  Window  Link   Link
 remark%%Number    Size   Speed  Type              Number    Size   Speed  Type

	ra	0
qqqsdw	eq	0
	re	tiicnt

	if	\nei|$aqqqsdw|
qqq	eq	nei|$aqqqsdw|
	if	qqq
	if	qqqsdw&1
	remark%        
	else
	crlf.
	ei

	nmbr.s(qqq,8,5)
qqq	eq	$a wsiz|qqqsdw|
	nmbr.s(qqq,A,9)
	
	if	1-\knsp|$aqqqsdw|
knsp|$aqqqsdw| eq	0
	ei
 remark%      
	qqqwds

qqq	eq	2
	if	ksat|$aqqqsdw|&$020
qqq	eq	0
	remark% SAT 
	ei
	if	\rdel|$aqqqsdw|
	if	rdel|$aqqqsdw|
	remark% ATC 
	if	qqq
	remark%     
	ei
qqq	eq	1
	ei
	ei

	if	qqq-1
	remark% TII      
	else	1-qqq
	remark%     
	ei	:qqq not atc or sat

	ei	:neighbor not 0
	ei	:not an xlink
qqqsdw	eq	 qqqsdw+1
	er

	ra	0
	remark%%


	 IF	MEMRMK-1
:	TELL MEMORY REQUIREMENTS
	REMARK	Memory:
QQ	EQ	0
QQCT	EQ	3
	RE      0F
	  IF	\S|QQ|SIZE
	   IF	S|QQ|SIZE
	    IF	(QQCT&3)-2
	CRLF.
	    ELSE
	TAB.
	    EI
	    IF	0A-QQ
	REMARK	SEG0
	    ELSE
	REMARK	SEG
	    EI
	NUMBER	QQ
	REMARK	=
	NMBR.((S|QQ|SZ),0,6)
:	NUMBER	S|QQ|SZ
:	REMARK	x
QQCT	EQ	QQCT+1
	   EI
	  EI
QQ	EQ	QQ+1
	ER
	CRLF.
	 EI	:MEMRMK-1


	IF	CONFIG-1

NCFRMK	EQ	0
	REMARK	%Assembly switches and options were set as follow:%
	REMARK	DB.BTR -
	CFGRMK(DB.BTR)
	REMARK	DB.BUB -
	CFGRMK(DB.BUB)
	REMARK	DB.CIR -
	CFGRMK(DB.CIR)
	REMARK	DB.DEB -
	CFGRMK(DB.DEB)
	REMARK	DB.SYN -
	CFGRMK(DB.SYN)
	REMARK	DB.TRC -
	CFGRMK(DB.TRC)
	REMARK	REBILD -
	CFGRMK(REBILD)
	REMARK	SUPER  -
	CFGRMK(SUPER)
	EI	:CONFIG-1
	EI	:CONFIG
	EI	:1-KILLIT

s1size	eq	scodsz		:allow same old command files to work.

:	put control number in PQ display
	pathst(930714,ctl.no,Control nm,Put Control Number in PQ display)

	END

:	***NOTHING PAST THIS POINT***

a*_