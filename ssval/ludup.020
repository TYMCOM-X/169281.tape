C
C LUD update program
C Date: 5/23/86      - Khanh nguyen
C
C 10/07/86  1.1  Changed ACTCOD.HST file to (KHANHQN)ACTCOD.HST.
C                Used sort program in KHANHQN instead of login's
C                directory.
C                Armed for interrupt on receipt of a WAKE.
C 03/02/89  2.0  Read LUDUPD.DEL and LUDUPD.CHG in VALDEV:34 instead
C                of building the circuit to VALDEV:35.
C
      PROGRAM LUDUPD
      IMPLICIT INTEGER (A-Z)
      LOGICAL LUDDWN,ACTDWN
      DOUBLE PRECISION FILEID,PROFIL,SRTFIL,TTFIL,IBMFIL,HSTDWN,
     *LOGUN,PRGRUN,PRGTBL(2),LNMTBL(2),ERRFIL,TOUTFL,CUD10,RUPD(2),
     *FILEX,LFILID,VAL370
      INTEGER LOGSTR(5),ACTCMD(3),KEY(4),WHONAM(3),UUNARR(6),UUNTEM(6)
      COMMON /TOUTBL/TOUT,TOUTFL/RECBLK/CODE,UNAME(3),NEWNAM(3),UUN/
     *TTFBLK/TTFIL/ASTBLK/ASTTBL(2,100),NSYS
      DATA PRGTBL,LNMTBL/'R UPDLUD$','GO UPDLUD$','CUD10','USEVAL'/
      DATA CUD10,RUPD/'CUD10:74;','R (VALDEV)UPDLUD$'/
      DATA VAL370,KEY/'VAL370','/KUNA3.4/R36',0/
      DATA ONE,THREE,ACTCMD/1,3,"76,0,"62/
      TYPE 100
100   FORMAT(/T2,'LUD update program - Version 1.1')
C
C Initialize variables and accounting system type table.
C
      CALL GDATE(FILEID)
      CALL GUSERN(WHONAM)
      CALL MAKFIL(FILEID,FILEID,'.A   ')
      CALL MAKFIL(FILEID,TTFIL,'.TTT')
      CALL MAKFIL(FILEID,IBMFIL,'.IBM')
      CALL MAKFIL(FILEID,ERRFIL,'.ERR')
      OPEN (UNIT=20,FILE='(SSVAL)ACTCOD.HST',ACCESS='SEQIN',ERR=1020)
      NSYS= 1
C   Read ACTCOD.HST into a table
110   READ(20,120,END=130)ASTTBL(1,NSYS),ASTTBL(2,NSYS)
120   FORMAT(2I4)
      NSYS= NSYS+1
      GO TO 110
130   NSYS= NSYS-1
      CLOSE (UNIT=20)
      LUDDWN= .FALSE.
      ACTDWN= .FALSE.
      TIMINT= 1800 ! time interval = 1800 seconds
      ETIME= 61200 ! time to stop = 17:00
      IBMTIM = 86400 ! time to stop IBM system = 24:00
      CALL WAKEUP        ! set WAKE interrupt
      CALL DETACH(JOBNO) ! detach the job
      TOUT= 5
      ENCODE(10,140,TOUTFL) FILEID,JOBNO
140   FORMAT(A6,'.',A3)
C
C   Write heading to outfile
C
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,100)
      WRITE(TOUT,150) WHONAM,CTIME,JOBNO
150   FORMAT(/,' Logged into: ',3A5,/,' Time: ',A5,/,' Frame ID: ',A3)
      CLOSE (UNIT=TOUT)
C
C To get all transactions from LUD update system.
C
160   CALL MTIME(STIME)
      CALL NXTAVF(FILEID) ! get the next available filename
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,170)CTIME
170   FORMAT(/T2,A5,' - Building circuit to Lud Update System.')
      CLOSE (UNIT=TOUT)
      IF (.NOT.ACTDWN) GO TO 210
      CALL RENAM(LFILID,FILEID,IERR)
      ACTDWN= .FALSE.
210   CALL OPNFIL(20,FILEID,'APPEND',$210)
200   OPEN (UNIT=21,FILE='(VALDEV)LUDUPD.DEL',ACCESS='SEQIN',ERR=300)
220   READ(21,230,END=280)UNAME,UUNTEM      
230   FORMAT(2A5,A2,6A1)
      DO 235 I = 1,6
      IF (UUNTEM(I) .NE. ' ') GOTO 238
      JJ = 7 - I
      MM = 1
      DO 231 IR = 1,6
      UUNARR(IR) = '0'
231   CONTINUE
      DO 233 KK = JJ+1,6
      UUNARR(KK) = UUNTEM(MM)
      MM = MM + 1
233   CONTINUE
      GOTO 239
238   UUNARR(I) = UUNTEM(I)
235   CONTINUE
239   WRITE(20,240) UNAME,UUNARR
240   FORMAT(' 1',2A5,A2,6A1,12X)
      GO TO 220
280   CLOSE(UNIT=21,DISPOSE='DELETE')
300   OPEN(UNIT=21,FILE='(VALDEV)LUDUPD.CHG',ACCESS='SEQIN',ERR=400)
310   READ(21,315,END=390)UNAME,NEWNAM,UUNTEM
315   FORMAT(2A5,A2,2A5,A2,6A1)
      DO 318 I = 1,6
      IF (UUNTEM(I) .NE. ' ') GOTO 314
      JJ = 7 - I
      MM = 1
      DO 316 IR = 1,6
      UUNARR(IR) = '0'
316   CONTINUE
      DO 317 KK = JJ+1,6
      UUNARR(KK) = UUNTEM(MM)
      MM = MM + 1
317   CONTINUE
      GOTO 319
314   UUNARR(I) = UUNTEM(I)
318   CONTINUE
319   WRITE(20,320) UNAME,UUNARR,NEWNAM
320   FORMAT(' 3',2A5,A2,6A1,2A5,A2)
      GO TO 310
390   CLOSE(UNIT=21,DISPOSE='DELETE') ! finish copying from VALDEV
400   CLOSE (UNIT=20)
410   NREC= 0
      CALL OPNFIL(20,FILEID,'SEQIN',$440)
420   READ(20,430,END=440) CODE,UNAME,UUN,NEWNAM
430   FORMAT(I2,2A5,A2,O6,2A5,A2)
      NREC= NREC+1
      GO TO 420
440   IF (NREC.GT.0) GO TO 500
      CLOSE (UNIT=20,DISPOSE='DELETE')
445   OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      WRITE(TOUT,450)
450   FORMAT(T10,'No updates this visit.')
      CLOSE (UNIT=TOUT)
      IF (ACTDWN) GO TO 460
      IF (LUDDWN) GO TO 470
      GO TO 990
460   ACTDWN = .FALSE.
      CALL RENAM(LFILID,FILEID,IERR)
      GOTO 410
470   LUDDWN =.FALSE.
      CALL RENAM(HSTDWN,SRTFIL,IERR)
      GOTO 850
500   CLOSE (UNIT=20)
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      WRITE(TOUT,510) NREC,FILEID
510   FORMAT(' Created ',I3,' records in ',A10)
      CALL TIME(CTIME)
      WRITE(TOUT,520) CTIME
520   FORMAT(/T2,A5,' - Building circuit to Accounting system.')
      CLOSE (UNIT=TOUT)
      CALL BLDCIR(CUD10,RUPD,PORT,ERRCOD)
      IF (ERRCOD.EQ.0) GO TO 550
      CALL CIRERR(ERRCOD)
      CALL MAKFIL(FILEID,LFILID,'. XX')
      CALL RENAM(FILEID,LFILID,IERR)
      IF (IERR.EQ.0) ACTDWN= .TRUE.
      GO TO 990
550   CALL HSTART(0)
      CALL MAKFIL(FILEID,PROFIL,'. PP')
      IF (.NOT.LUDDWN) GO TO 560
      CALL RENAM(HSTDWN,PROFIL,IERR)
      LUDDWN= .FALSE.
560   CALL MAKFIL(FILEID,FILEX,'. XX') ! Acct host is down
      CALL OPNFIL(20,FILEID,'SEQIN',$560)
      NERRS= 0
C
C     Get username from YYMMDD.# (#:A,B,...,Z)
570   READ(20,430,END=780) CODE,UNAME,UUN,NEWNAM
580   CALL S1BYTE(PORT,"105) ! list hosts for a user
      CALL S3BYTE(PORT,UUN) ! send uun
      CALL G1BYTE(PORT,RTNCOD,$590) ! get an answer from accounting
      IF (RTNCOD.EQ.1) GO TO 650   ! success
      IF (RTNCOD.EQ."14) GO TO 580 ! accounting system busy, try again
      CODE= CODE+1
      CALL WERROR(RTNCOD,0)
      NERRS= NERRS+1
      GO TO 570
590   OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,600) CTIME
600   FORMAT(X,A5,' - Accounting circuit zapped during list hosts')
      WRITE(TOUT,610) UNAME,UUN
610   FORMAT(' Username: ',2A5,A2,' - ',O6)
      CLOSE (UNIT=TOUT)
620   CALL OPNFIL(21,FILEX,'SEQOUT',$780)
630   WRITE(21,430) CODE,UNAME,UUN,NEWNAM
      READ(20,430,END=640) CODE,UNAME,UUN,NEWNAM
      GO TO 630
640   LFILID= FILEX
      ACTDWN= .TRUE.
      CLOSE (UNIT=21)
      GO TO 780
650   CALL G2BYTE(PORT,HOST,$590)
      IF (HOST.EQ."177777) GO TO 680
C Host 39 is not IPC host anymore
      IF (HOST.EQ.39) GOTO 650 
      ASYST= FNDAST(HOST)
      GO TO (660,660,670) ASYST
      CALL FWRITE(ERRFIL,HOST,$650) ! YYMMDD.ERR
660   CALL FWRITE(PROFIL,HOST,$650) ! YYMMDD.#PP
670   CALL FWRITE(IBMFIL,HOST,$650) ! YYMMDD.IBM
C
C Update accounting database
C
680   CALL S1BYTE(PORT,ACTCMD(CODE)) ! delete or change username
      CALL S3BYTE(PORT,UUN) ! send uun
      IF (CODE.EQ.3) GO TO 690
      CALL S2BYTE(PORT,1) ! send a dummy host
      GO TO 700
690   CALL SUNAME(PORT,NEWNAM,12) ! send new name for change username
700   CALL G1BYTE(PORT,RTNCOD,$720) ! get an answer from accounting
      IF (RTNCOD.EQ.1) GO TO 710
      IF (RTNCOD.EQ."14) GO TO 690 ! file busy, try again
      CALL WERROR(RTNCOD,0)
      NERRS= NERRS+1
710   CALL WTTFIL(RTNCOD,0)
      GO TO 570
720   OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      IF (CODE.EQ.3) GO TO 740
      WRITE(TOUT,730) CTIME
730   FORMAT(X,A5,' - Accounting circuit zapped during delete user.')
      WRITE(TOUT,610) UNAME,UUN
      GO TO 770
740   WRITE(TOUT,750) CTIME
750   FORMAT(X,A5,' - Accounting circuit zapped during change name.')
      WRITE(TOUT,610) UNAME,UUN
      WRITE(TOUT,760) NEWNAM
760   FORMAT(' New name: ',2A5,A2)
770   CLOSE (UNIT=TOUT)
      GO TO 620
780   CLOSE (UNIT=20)
      CALL ZAPC(PORT)
      CALL HSTEND(0,NERRS)
      OPEN (UNIT=20,FILE=PROFIL,ACCESS='SEQIN',ERR=990)
      NREC= 0
790   READ(20,870,END=795) CODE,HOST,UNAME,NEWNAM,UUN
      NREC= NREC+1
      GO TO 790
795   CALL MAKFIL(FILEID,SRTFIL,'. SS')
      CALL SORT(PROFIL,SRTFIL,KEY,MERR,PERR) ! sort the profile according hosts
      IF ((MERR.NE.0).OR.(PERR.NE.0)) GO TO 1000
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      WRITE(TOUT,800) NREC
800   FORMAT(X,'Sorted ',I4,' records.')
      GO TO 830
810   WRITE(TOUT,820) NREC
820   FORMAT(' Sorted ',I4,' records.')
830   CLOSE (UNIT=TOUT)
C
C Update all transactions in the LUD.
C
850   PHOST= 0
      CALL MAKFIL(FILEID,HSTDWN,'. DD') ! host down
      CALL OPNFIL(20,SRTFIL,'SEQIN',$850) ! sort file
860   READ(20,870,END=980) CODE,HOST,UNAME,NEWNAM,UUN
870   FORMAT(I2,I4,2(2A5,A2),O6)
      IF (PHOST.EQ.HOST) GO TO 940
880   IF (PHOST.NE.0) CALL HSTEND(PHOST,NERRS)
      PHOST= HOST
      NERRS= 0
      CALL ZAPC(PORT)
      ASYST= FNDAST(HOST)
      LOGUN= LNMTBL(ASYST)
      PRGRUN= PRGTBL(ASYST)
      CALL MKLGST(LOGUN,HOST,LOGSTR)
      CALL HSTART(HOST)
      CALL BLDCIR(LOGSTR,PRGRUN,PORT,ERRCOD)
      IF (ERRCOD.EQ.0) GO TO 940
      CALL CIRERR(ERRCOD)
920   CALL OPNFIL(21,HSTDWN,'APPEND',$920)
930   WRITE(21,870) CODE,HOST,UNAME,NEWNAM,UUN
      READ(20,870,END=970) CODE,HOST,UNAME,NEWNAM,UUN
      IF (PHOST.EQ.HOST) GO TO 930
      CLOSE (UNIT=21)
      LUDDWN= .TRUE.
      GO TO 880
940   CALL S1BYTE(PORT,CODE) ! delete or change name in the LUD
      IF (ASYST.EQ.2) CALL S3BYTE(PORT,0) ! send a dummy request #
      CALL SUNAME(PORT,UNAME,12)
      IF (CODE.EQ.3) CALL SUNAME(PORT,NEWNAM,12)
      IF (ASYST.EQ.2) CALL S3BYTE(PORT,"44444444)
      CALL G1BYTE(PORT,RTNCOD,$950)
      IF (RTNCOD.EQ.1) GO TO 945
      IF (RTNCOD.EQ."14) GO TO 940
      CALL WERROR(RTNCOD,HOST)
      NERRS= NERRS+1
945   CALL WTTFIL(RTNCOD,HOST)
      IF ((RTNCOD.NE.1).OR.(ASYST.NE.1).OR.(CODE.NE.1)) GO TO 860
      CALL G3BYTE(PORT,IGAN,$950)
      CALL G3BYTE(PORT,IUUN,$950)
      GO TO 860
950   OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,960) CTIME,HOST
960   FORMAT(X,A5,' Circuit zapped during process host ',I3)
      CLOSE (UNIT=TOUT)
      GO TO 920
970   CLOSE (UNIT=21)
      LUDDWN= .TRUE.
980   CLOSE (UNIT=20,DISPOSE='DELETE')
      CALL HSTEND(HOST,NERRS)
      CALL ZAPC(PORT)
990   CALL ZAPC(-1) ! zap all circuits
      CALL MTIME(CTIME)
      IF (CTIME.GE.ETIME) GO TO 2000
      TRUN= CTIME-STIME
      IF (TRUN.GT.TIMINT) GO TO 160
      TS= TIMINT-MOD(CTIME,TIMINT)
      TSM= TS/60
      IF (MOD(TS,60).GT.0) TSM= TSM+1
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      WRITE(TOUT,995) TSM
995   FORMAT(/T2,'Dismissing for ',I2,' minutes.')
      CLOSE (UNIT=TOUT)
      CALL SLEEPY(TS)
      GO TO 160
1000  OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,1010) CTIME,PROFIL,MERR,PERR
1010  FORMAT(X,A5,' - ',A10,' file sorted error. Error codes',2I6)
      CLOSE (UNIT=TOUT)
      GO TO 990
1020  TYPE 1030
1030  FORMAT(' ACTCOD.HST - file not found.')
      CALL NEXIT
C
C Process 370 records
C
2000  CALL MAKFIL(FILEID,PROFIL,'.370')
      CALL MAKFIL(FILEID,HSTDWN,'.DWN')
      OPEN (UNIT=20,FILE=IBMFIL,ACCESS='SEQIN',ERR=2300)
      NREC= 0
2010  READ(20,870,END=2020) CODE,HOST,UNAME,NEWNAM,UUN
      NREC= NREC+1
      GO TO 2010
2020  CLOSE (UNIT=20)
      CALL SORT(IBMFIL,PROFIL,KEY,MERR,PERR)
      IF ((MERR.NE.0).OR.(PERR.NE.0)) GO TO 2250
      TIMINT= 900
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,2030) CTIME,NREC,IBMFIL
2030  FORMAT(/T2,A5,' - Sorted ',I4,' records (',A10,').')
      CLOSE (UNIT=TOUT)
      LUDDWN= .FALSE.
2040  CALL MTIME(STIME)
      PHOST= 0
      CALL OPNFIL(20,PROFIL,'SEQIN',$2500)
2100  READ(20,870,END=2200) CODE,HOST,UNAME,NEWNAM,UUN
      IF (PHOST.EQ.HOST) GO TO 2150
2110  IF (PHOST.NE.0) CALL HSTEND(PHOST,NERRS)
      PHOST= HOST
      NERRS= 0
      CALL ZAPC(PORT)
      CALL HSTART(HOST)
      CALL MKLGST(VAL370,HOST,LOGSTR) ! make the login string
      CALL BLDCIR(LOGSTR,'1POINT$',PORT,ERRCOD)
      IF (ERRCOD.EQ.0) GO TO 2150
      IF (ERRCOD.EQ.17) ERRCOD= 23
      CALL CIRERR(ERRCOD)
2120  CALL OPNFIL(21,HSTDWN,'APPEND',$2120)
2130  WRITE(21,870) CODE,HOST,UNAME,NEWNAM,UUN
      READ(20,870,END=2190) CODE,HOST,UNAME,NEWNAM,UUN
      IF (HOST.EQ.PHOST) GO TO 2130
      CLOSE (UNIT=21)
      LUDDWN= .TRUE.
      GO TO 2110
2150  CALL S1BYTE(PORT,CODE) ! delete or change name in the LUD
      CALL SUNAME(PORT,UNAME,8) ! send 8-byte username
      IF (CODE.EQ.3) CALL SUNAME(PORT,NEWNAM,8)
2160  CALL G1BYTE(PORT,RTNCOD,$2170)
      IF (RTNCOD.EQ.1) GO TO 2165
      IF ((RTNCOD.EQ."223).OR.(RTNCOD.EQ."21)) GO TO 2160
      CALL WERROR(RTNCOD,HOST)
      NERRS= NERRS+1
2165  CALL WTTFIL(RTNCOD,HOST)
      GO TO 2100
2170  OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,960) CTIME,HOST
      CLOSE (UNIT=TOUT)
      GO TO 2120
2190  CLOSE (UNIT=21)
      LUDDWN= .TRUE.
2200  CLOSE (UNIT=20,DISPOSE='DELETE')
      CALL ZAPC(PORT)
      CALL HSTEND(HOST,NERRS)
      IF (.NOT.LUDDWN) GO TO 2500
      LUDDWN= .FALSE.
      CALL RENAM(HSTDWN,PROFIL,IERR)
      IF (IERR.NE.0) GO TO 2400
      CALL MTIME(CTIME)
      IF (CTIME.GE.IBMTIM) GOTO 2500
      TRUN= CTIME-STIME
      IF (TRUN.GT.TIMINT) GO TO 2040
      TS= TIMINT-MOD(CTIME,TIMINT)
      TSM= TS/60
      IF (MOD(TS,60).GT.0) TSM= TSM+1
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      WRITE(TOUT,995) TSM
      CLOSE (UNIT=TOUT)
      CALL SLEEPY(TS)
      GO TO 2040
2250  OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,1010) CTIME,IBMFIL,MERR,PERR
      CLOSE (UNIT=TOUT)
      GO TO 2500
2300  OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,2310) CTIME
2310  FORMAT(/T2,A5,' - No 370 updates.')
      CLOSE (UNIT=TOUT)
      GO TO 2500
2400  OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      WRITE(TOUT,2410) CTIME,HSTDWN,PROFIL,IERR
2410  FORMAT(/T2,A5,' - Cannot rename ',A10,' to ',A10,'. - ',I5)
      CLOSE (UNIT=TOUT)
2500  CALL BYE
      END
         SUBROUTINE OPNFIL(N,FILNAM,FACCES,*)
      DOUBLE PRECISION FILNAM,FACCES,TOUTFL
      INTEGER TOUT
      COMMON /TOUTBL/TOUT,TOUTFL
      ITIME= 1
10    OPEN (UNIT=N,FILE=FILNAM,ACCESS=FACCES,ERR=20)
      RETURN
20    CALL ERRSNS(I,J)
      IF (J.NE.253) GO TO 30
      IF (ITIME.EQ.10) GO TO 40
      ITIME= ITIME+1
      CALL SLEEPY(5)
      GO TO 10
30    OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      WRITE(TOUT,60)FILNAM,I,J
      GO TO 50
40    OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      WRITE(TOUT,70)FILNAM,ITIME
50    CLOSE (UNIT=TOUT)
      RETURN(1)
60    FORMAT(' Open failure - File: ',A10,' - Error codes: ',2I5)
70    FORMAT(' File ',A10,' was being modified. Tried ',I2,' time(s)')
      END

      SUBROUTINE FWRITE(FNAM,HOST,*)
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION FNAM
      COMMON /RECBLK/CODE,UNAME(3),NEWNAM(3),UUN
10    CALL OPNFIL(24,FNAM,'APPEND',$10)
      WRITE(24,20)CODE,HOST,UNAME,NEWNAM,UUN
20    FORMAT(X,I1,I4,2(2A5,A2),O6)
      CLOSE (UNIT=24)
      RETURN(1)
      END

      INTEGER FUNCTION FNDAST(X)
      IMPLICIT INTEGER (A-Z)
      COMMON /ASTBLK/ASTTBL(2,100),NSYS
      LOW= 1
      HGH= NSYS
10    IF (LOW.GT.HGH) GO TO 40
      MID= (LOW+HGH)/2
      IF (X.EQ.ASTTBL(1,MID)) GO TO 30
      IF (X.LT.ASTTBL(1,MID)) GO TO 20
      LOW= MID+1
      GO TO 10
20    HGH= MID-1
      GO TO 10
30    FNDAST= ASTTBL(2,MID)
      RETURN
40    FNDAST= 0
      RETURN
      END

      SUBROUTINE WTTFIL(ANS,HOST)
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION TTFIL,STADSC
      INTEGER CMDDSC(3)
      COMMON /RECBLK/CODE,UNAME(3),NEWNAM(3),UUN/TTFBLK/TTFIL
      OPEN (UNIT=24,FILE=TTFIL,ACCESS='SEQIN',ERR=100)
      GO TO 200
100   CALL OPNFIL(24,TTFIL,'SEQOUT',$100)
      WRITE(24,110)               ! write TTFIL header
110   FORMAT(/3X,'Command',5X,'Time',2X,'Host',2X,'Username',6X,
     *'New name',6X,'UUN',5X,'Status',/)
      GO TO 220
200   CLOSE (UNIT=24)
210   CALL OPNFIL(24,TTFIL,'APPEND',$210)
220   IF (HOST.EQ.0) GO TO 240
      ENCODE(3,230,HSTDSC) HOST
230   FORMAT(I3)
      GO TO 250
240   HSTDSC= 'ACT'
250   IF (ANS.EQ.1) GO TO 270
      ENCODE(10,260,STADSC) ANS
260   FORMAT('Error: ',O3)
      GO TO 280
270   STADSC= 'Completed'
280   IF (CODE.EQ.3) GO TO 300
      ENCODE(15,290,CMDDSC)
290   FORMAT('Delete User',4X)
      GO TO 320
300   ENCODE(15,310,CMDDSC)
310   FORMAT('Change Name',4X)
320   CALL TIME(X)
      WRITE(24,330) CMDDSC,X,HSTDSC,UNAME,NEWNAM,UUN,STADSC
330   FORMAT(X,2A5,A1,2X,A5,2X,A3,2(2X,2A5,A2),2X,O6,2X,A10)
      CLOSE (UNIT=24)
      RETURN
      END

      SUBROUTINE WERROR(ANS,HOST)
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION TOUTFL
      COMMON /TOUTBL/TOUT,TOUTFL/RECBLK/CODE,UNAME(3),NEWNAM(3),UUN
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      GO TO (110,130,150,130) CODE
      WRITE(TOUT,100) CODE
100   FORMAT(/T2,'*** Undefined Command code: ',I4)
      GO TO 170
110   WRITE(TOUT,120)
120   FORMAT(/T2,'*** Delete User error ***')
      GO TO 170
130   WRITE(TOUT,140)
140   FORMAT(/T2,'*** List Hosts error  ***')
      GO TO 170
150   WRITE(TOUT,160)
160   FORMAT(/T2,'*** Change Name error ***')
170   WRITE(TOUT,180) UNAME,UUN
180   FORMAT(' Username: ',2A5,A2,' - ',O6)
      IF (NEWNAM(1).NE.'     ') WRITE(TOUT,190) NEWNAM
190   FORMAT(' New name: ',2A5,A2)
      IF (ANS.EQ.3) GO TO 210
      WRITE(TOUT,200) ANS
200   FORMAT(' Error: ',O3)
      GO TO 230
210   WRITE(TOUT,220)
220   FORMAT(' Username not found.')
230   CLOSE (UNIT=TOUT)
      END

      SUBROUTINE CIRERR(K)
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION TOUTFL
      COMMON /TOUTBL/TOUT,TOUTFL
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      GOTO(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)K
      WRITE(TOUT,124) K ; GO TO 25
1     WRITE(TOUT,101) ; GO TO 25
2     WRITE(TOUT,102) ; GO TO 25
3     (TOUT,103) ; GO TO 25
4     WRITE(TOUT,104) ; GO TO 25
5     WRITE(TOUT,105) ; GO TO 25
6     WRITE(TOUT,106) ; GO TO 25
7     WRITE(TOUT,107) ; GO TO 25
8     WRITE(TOUT,108) ; GO TO 25
9     WRITE(TOUT,109) ; GO TO 25
10    WRITE(TOUT,110) ; GO TO 25
11    WRITE(TOUT,111) ; GO TO 25
12    WRITE(TOUT,112) ; GO TO 25
13    WRITE(TOUT,113) ; GO TO 25
14    WRITE(TOUT,114) ; GO TO 25
15    WRITE(TOUT,115) ; GO TO 25
16    WRITE(TOUT,116) ; GO TO 25
17    WRITE(TOUT,117) ; GO TO 25
18    WRITE(TOUT,118) ; GO TO 25
19    WRITE(TOUT,119) ; GO TO 25
20    WRITE(TOUT,120) ; GO TO 25
21    WRITE(TOUT,121) ; GO TO 25
22    WRITE(TOUT,122) ; GO TO 25
23    WRITE(TOUT,123)
25    CLOSE (UNIT=TOUT)
      RETURN
101   FORMAT(' Too many auxiliary circuits without AC license.')
102   FORMAT(' Not your username without AC license.')
103   FORMAT(' No room in monitor.')
104   FORMAT(' Supervisor did not respond to the original request.')
105   FORMAT(' Supervisor did not respond to the login message.')
106   FORMAT(' Supervisor did not supply a circuit.')
107   FORMAT(' Supervisor error from original request.')
108   FORMAT(' Format error.')
109   FORMAT(' User not in MUD.')
110   FORMAT(' Bad MUD.')
111   FORMAT(' Host unavailable.')
112   FORMAT(' Downline load or dialout request failure.')
113   FORMAT(' Timeout.')
114   FORMAT(' Access barred.')
115   FORMAT(' Error in ISIS.')
116   FORMAT(' Long queue in supervisor.')
117   FORMAT(' Handshake timeout.')
118   FORMAT(' Unable to initialize INTADR system.')
119   FORMAT(' Unable to assign interrupt causes.')
120   FORMAT(' Interrupt address not in effect.')
121   FORMAT(' Unable to clear timer interrupt system.')
122   FORMAT(' Illegal program name.')
123   FORMAT(' VAL370 already entered.')
124   FORMAT(' Circuit error code out of range. - ',O3)
      END

      SUBROUTINE NXTAVF(FILEID)
      DOUBLE PRECISION FILEID
10    OPEN (UNIT=4,FILE=FILEID,ACCESS='SEQIN',ERR=20)
      CLOSE (UNIT=4)
      CALL NXTFIL(FILEID,IFLAG)
      IF (IFLAG.EQ.-1) CALL DELET(FILEID,IERR)
      GO TO 10
20    RETURN
      END

      SUBROUTINE HSTART(HOST)
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION TOUTFL
      COMMON /TOUTBL/TOUT,TOUTFL
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      IF (HOST.EQ.0) GO TO 20
      WRITE(TOUT,10) CTIME,HOST
10    FORMAT(/T2,A5,' - Processing host ',I3)
      GO TO 40
20    WRITE(TOUT,30) CTIME
30    FORMAT(X,A5,' - Processing Accounting host')
40    CLOSE (UNIT=TOUT)
      RETURN
      END

      SUBROUTINE HSTEND(HOST,NERRS)
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION TOUTFL
      COMMON /TOUTBL/TOUT,TOUTFL
      OPEN (UNIT=TOUT,FILE=TOUTFL,ACCESS='APPEND')
      CALL TIME(CTIME)
      IF (NERRS.GT.0) WRITE(TOUT,10)
10    FORMAT()
      IF (HOST.EQ.0) GO TO 30
      WRITE(TOUT,20) CTIME,HOST
20    FORMAT(X,A5,' - Host ',I3,' finished.')
      GO TO 50
30    WRITE(TOUT,40) CTIME
40    FORMAT(X,A5,' - Accounting host finished.')
50    CLOSE (UNIT=TOUT)
      RETURN
      END
   	ENTRY	BLDCIR,ZAPC,S1BYTE,S2BYTE,S3BYTE,SUNAME,G1BYTE
	ENTRY	G2BYTE,G3BYTE,GUNAME,MKLGST,SLEEPY,GDATE,NXTFIL
	ENTRY	MAKFIL,GUSERN,MTIME,DETACH,SORT,WAKEUP

; Accumulator definitions

AC==0
AC1==1
AC2==2
AC3==3
AC4==4
AP==16
P==17

; Universal symbols and constants

.AXI8C==0
.AXO8==3
.AXO8I==4
.AXOST==52
.IATIM==4
.IAWAK==6
IA.REE==2
IA.CLR==4
BLNK==40
COLON==72
.CR==15

; Subroutine to create an aux circuit
; FORTRAN calls as: CALL BLDCIR(LOGSTR,PRGNAM,PORT,ERRCOD)
; LOGSTR is an ASCII string.
; PRGNAM is program name followed by a dollar sign "$"
; a zero if no program name.
; PORT is an integer var is used to return the port no.
; ERRCOD is an integer variable.

BLDCIR:	SETZM	@3(AP)			; CLEAR HOST ERROR
	MOVEI	AC,@(AP)		; GET ADDRESS OF LOGIN STRING
	CREAUX	AC,			; CREATE AN AUX CIRCUIT
	JRST	BLDERR			; ERROR
	MOVEM	AC,@2(AP)		; RETURN PORT NO.
	HRLZS	AC			; SET AC TO [PORT,,0]
	HRRI	AC,.AXO8I		; OUTPUT CHAR IMMEDIATE
	AUXCAL	AC,.CR			; OUTPUT CR
	AUXCAL	AC,.CR
	AUXCAL	AC,.CR
	SKIPN	@1(AP)			; SKIP IF START A PROGRAM
	JRST	HSHAKE
	MOVEI	AC1,@1(AP)		; GET ADDRESS OF PROG. NAME
	HRLI	AC1,(POINT 7)		; MAKE BYTE POINTER
	MOVE	AC2,[POINT 7,PRGNAM]	; GET BYTE POINTER OF PRGNAM
	MOVEI	AC4,^D30		; MAX CHARS OF PROG NAME
BDCIR1:	ILDB	AC3,AC1			; GET A CHAR FROM PROGRAM NAME
	CAIN	AC3,44			; SKIP IF NOT DOLLAR SIGN
	JRST	BDCIR2
	IDPB	AC3,AC2			; SAVE CHAR IN PRGNAM
	SOJG	AC4,BDCIR1
	MOVEI	AC1,26			; PROGRAM NAME NOT TERMINATE WITH $
	JRST	BDERR1			; ILLEGAL NAME CODE 11
BDCIR2:	MOVEI	AC3,.CR			; PUT CR TO THE END OF PROGNAM
	IDPB	AC3,AC2
	SETZ	AC3,
	IDPB	AC3,AC2			; PUT A NULL
	HRRI	AC,.AXOST		; PREPARE FOR OUTPUT PROGRAM NAME
	AUXCAL	AC,PRGNAM		; DO IT
HSHAKE:	SETZ	AC4,
	SETTIM	AC4,			; RESET TIMMER
	JFCL
	HRLI	AC4,IA.REE		; INITIALIZE INTERRUPT ADDRESS SYS.
	HRRI	AC4,TRPVEC		; TRAP VECTOR ADDRESS
	INTADR	AC4,			; GET READY TO SET TIMER INTERRUPT
	JRST	[MOVEI	AC1,22		; UNABLE TO INITIALIZE INTADR SYSTEM
		 JRST	BDERR1]
	MOVE	AC4,[1,,264]		; PREPARE TO SET 3 MINUTES TIMEOUT
	SETTIM	AC4,			; DO IT
	JFCL
	HRLI	AC4,.IATIM		; ENABLE TIMER INTERRUPT
	HRRI	AC4,1			; TIMER CHANNEL
	INTASS	AC4,			; SET IT
	JRST	[MOVEI	AC1,23		; UNABLE TO ASSIGN INTERRUPT CAUSES
		 JRST	BDERR1]
	HRLZI	AC4,(1B0!1B1!1B2)	; ENABLE INTADR ON CHANNEL 1 AND 2
	INTENB	AC4,
	JRST	[MOVEI	AC1,24		; INTERRUPT ADDRESS NOT IN EFFECT
		 JRST	BDERR1]
	HRRI	AC,.AXI8C		; PREPARE FOR INPUT CHAR FROM PORT
G1234A:	AUXCAL	AC,AC1			; GET FIRST BYTE
	JRST	G1234C
	CAIE	AC1,1			; SKIP IF IT IS ONE
	JRST	G1234A			; NO, TRY AGAIN
	AUXCAL	AC,AC1			; GET SECOND BYTE
	JRST	G1234C
	CAIE	AC1,2			; SKIP IF TWO
	JRST	G1234A			; TRY AGAIN
	AUXCAL	AC,AC1			; GET THIRD BYTE
	JRST	G1234C
	CAIE	AC1,3			; SKIP IF THREE
	JRST	G1234A			; TRY AGAIN
	AUXCAL	AC,AC1			; GET FOURTH BYTE
	JRST	G1234C
	CAIE	AC1,4			; SKIP IF FOUR
	JRST	G1234A
	HRRI	AC,.AXO8I		; RESPOND HANDSHAKE
	AUXCAL	AC,1			; SEND 1
	AUXCAL	AC,2			; SEND 2
	AUXCAL	AC,3			; SEND 3
	AUXCAL	AC,4			; SEND 4
G1234B:	HRLZI	AC4,IA.CLR		; SET TO DISABLE INTADR
	INTADR	AC4,
	JRST	[MOVEI	AC1,25		; UNABLE TO CLEAR TIMER INTERRUPT SYS.
		 JRST	BDERR1]
	SETZ	AC4,
	SETTIM	AC4,			; RESET TIMMER
	JFCL
        MOVE    AC4,[IA.REE,,TRPVEC]
        INTADR  AC4,
        JFCL
        HRLZI   AC4,(1B0!1B2)
        INTENB  AC4,
        JFCL
	POPJ	P,			; RETURN
G1234C:	MOVEI	AC1,21			; ERROR CODE FOR HANDSHAKE TIMEOUT
	MOVEM	AC1,@3(AP)
	HLRZS	AC
	ZAPCIR	AC,			; ZAP CURRENT PORT
	JRST	G1234B			; GO TO CLEAR TIMER INTERRUPT SYS.
G1234D:	MOVEI	AC4,G1234C
	MOVEM	AC4,TRPVEC
	DISMIS
BLDERR:	HLRZ	AC1,AC			; GET HOST ERROR CODE
	SKIPE	AC1
	JRST	.+3
	HRRZ	AC1,AC			; GET SUP ERROR CODE
	ADDI	AC1,7
	MOVEM	AC1,@3(AP)		; RETURN ERROR CODE
	JRST	BDERR2
BDERR1:	MOVEM	AC1,@3(AP)		; RETURN ERROR CODE
	HLRZS	AC
	ZAPCIR	AC,			; ZAP CURRENT PORT
BDERR2:	SETZM	@2(AP)			; ZERO PORT FIELD
	POPJ	P,			; RETURN

; Subroutine to zap an auxiliary circuit.
; FORTRAN calls as: CALL ZAPC(PORT), where PORT is an integer var, port no.

ZAPC:	MOVE	AC,@(AP)		; GET PORT NUMBER
	ZAPCIR	AC,			; ZAP AN AUX CIRCUIT
	POPJ	P,

; Subroutine sends bytes through auxiliary circuit
; FORTRAN calls as: CALL S#BYTE(PORT,BYTES) where # is 1,2, or 3.
; PORT is port number.
; BYTES is an integer variable

S1BYTE:	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXO8		; PREPARE FOR AUXCAL
	MOVE	AC1,@1(AP)		; GET CONTENT OF BYTE TO BE SENT
	AUXCAL	AC,AC1
	POPJ	P,
S2BYTE:	MOVEI	AC3,2			; SEND 2 BYTES
	MOVE	AC2,@1(AP)		; GET CONTENT OF ARGUMENT
	LSH	AC2,24			; LEFT JUSTIFY
	JRST	SBYTES
S3BYTE:	MOVEI	AC3,3			; SEND 3 BYTES
	MOVE	AC2,@1(AP)		; GET CONTENT OF ARGUMENT
	LSH	AC2,14			; LEFT JUSTIFY
SBYTES:	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXO8		; PREPARE FOR AUXCAL
SBYTEL:	SETZ	AC1,
	LSHC	AC1,10			; GET A BYTE (8-BIT)
	AUXCAL	AC,AC1			; SEND IT
	SOJG	AC3,SBYTEL		; DO THE REST
	POPJ	P,			; RETURN

; Subroutine sends a username through an auxiliary circuit.
; FORTRAN calls as: CALL SUNAME(PORT,UNAME,LENGTH)
; PORT is port number
; UNAME is an ASCII string.
; LENGTH is the length if UNAME in chars.

SUNAME:	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXO8		; OUTPUT CHAR CODE FOR AUXCAL
	MOVEI	AC1,@1(AP)		; GET ADDRESS OF USERNAME
	HRLI	AC1,(POINT 7)		; MAKE BYTE POINTER
	MOVE	AC3,@2(AP)		; GET LENGTH OF USERNAME
SUNAM1:	ILDB	AC2,AC1
	SUBI	AC2,40			; CONVERT FROM ASCII TO SIXBIT
	AUXCAL	AC,AC2			; SEND IT
	SOJG	AC3,SUNAM1		; DO THE REST
	POPJ	P,

; Subroutine gets bytes from an aux. circuit.
; FORTRAN calls as: CALL G#BYTE(PORT,MEM,LABEL)
; where # is number of bytes to get
; PORT is port number
; MEM is an integer variable
; LABEL is a statement label (ie. $10,$30,$20, etc.), if circuit
; zapped then G#BYTE will return to that statement label.

G1BYTE:	MOVEI	AC3,1			; GET 1 BYTE
	JRST	GBYTES
G2BYTE:	MOVEI	AC3,2			; NUMBER OF BYTES IS 2
	JRST	GBYTES
G3BYTE:	MOVEI	AC3,3			; NUMBER OF BYTES IS 3
GBYTES:	SETZ	AC2,			; ZERO RESULT FIELD
	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXI8C		; PREPARE FOR AUXCAL
GBYTE1:	PUSHJ	P,AINCHR		; GET A BYTE
	JRST	GBYTER
	LSH	AC2,10			; SHIFT PREVIOUS VALUE
	OR	AC2,AC1			; INCLUDE CURRENT BYTE
	SOJG	AC3,GBYTE1		; DO THE REST
	MOVEM	AC2,@1(AP)		; MOVE RESULT TO RETURN ARGUMENT
	POPJ	P,
GBYTER:	SETZM	@(AP)			; ZERO PORT FIELD
	MOVEI	AC,@2(AP)		; GET RETURN ADDRESS
	HRRM	AC,(P)
	POPJ	P,

; Subroutine gets a username from aux. circuit
; FORTRAN calls as: CALL GUNAME(PORT,UNAME,LENGTH,LABEL1,LABEL2)
; PORT is port number.
; UNAME string of ASCII chars. If UNAME(1) = 377 then end of input
; LENGTH is length of username.
; LABEL1 is statement label (.ie $10,$20 etc.),, if a 377 is
; received then program control will transfer to that statement label.
; LABEL2 is a statement label, if circuit zapped then program
; control will return to that statement label.

GUNAME:	MOVEI	AC2,@1(AP)		; GET ADDRESS OF STRING
	HRLI	AC2,(POINT 7)		; MAKE BYTE POINTER
	MOVE	AC3,@2(AP)		; NO. OF BYTES TO GET
	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXI8C		; PREPARE FOR AUXCAL
	PUSHJ	P,AINCHR		; GET A CHAR
	JRST	GUNERR
	CAIN	AC1,377			; CHECK FOR TERMINATION BYTE
	JRST	GUNEND
	ADDI	AC1,40			; CONVERT TO ASCII
	IDPB	AC1,AC2			; SAVE A BYTE
	SOJ	AC3,
GUNAM1:	PUSHJ	P,AINCHR
	JRST	GUNERR
	ADDI	AC1,40
	IDPB	AC1,AC2
	SOJG	AC3,GUNAM1
	POPJ	P,
GUNEND:	MOVEI	AC,@3(AP)
	HRRM	AC,(P)
	POPJ	P,
GUNERR:	SETZM	@(AP)
	MOVEI	AC,@4(AP)
	HRRM	AC,(P)
	POPJ	P,

AINCHR:	AUXCAL	AC,AC1
	JRST	CHKPRT
	AOS	(P)
	POPJ	P,

CHKPRT:	HRLI	AC1,-PTBLEN		; LENGTH OF PORT TABLE
	HRRI	AC1,PTABL		; ADDRESS
	AUXRED	AC1,
	JFCL
	HLRZS	AC			; GET PORT NO. TO RIGHT OF AC
	SETZ	AC1,
CHKPLP:	SKIPGE	PTABL(AC1)
	POPJ	P,			; NOT FOUND, CIRCUIT ZAP
	CAMN	AC,PTABL(AC1)		; SKIP IF NO MATCH FOUND YET
	JRST	[HRLZS	AC		; TRY TO GET A BYTE AGAIN
		 HRRI	AC,.AXI8C
		 JRST	AINCHR]
	AOJA	AC1,CHKPLP

; Subroutine to make Login String.
; FORTRAN calls as: CALL MKLGST(UNAME,HOST,LOGSTR)
; UNAME is a string of alphabetic or numeric 7-bit ASCII.
; HOST is an integer variable.
; LOGSTR is an array of five elements.

MKLGST:	HRRZI	AC1,@2(AP)		; PREPARE TO CLEAR THE LOGIN STRING
	MOVEI	AC,5			; MAX WORDS OF LOGIN STRING
MKLGS1:	SETZM	@AC1			; ZERO ONE WORD
	AOJ	AC1,			; INCREMENT INDEX
	SOJG	AC,MKLGS1		; CONTINUE UNTIL DONE
	MOVEI	AC,@2(AP)		; GET ADDRESS OF LOGIN STRING
	HRLI	AC,(POINT 7)		; MAKE BYTE POINTER
	MOVEI	AC1,@(AP)		; GET ADDRESS OF USERNAME
	HRLI	AC1,(POINT 7)		; MAKE BYTE POINTER
	MOVEI	AC2,^D12		; MAX LENGTH OF USERNAME
MKLGS2:	ILDB	AC3,AC1			; GET A CHAR FROM USER NAME
	JUMPE	AC3,MKLGS3		; DONE IF NULL
	CAIN	AC3,BLNK		; IS CURRENT CHAR A BLANK?
	JRST	MKLGS3			; YES, DONE
	IDPB	AC3,AC			; NO, PUT IT INTO LOGIN STRING
	SOJG	AC2,MKLGS2		; DO THE REST
MKLGS3:	MOVEI	AC3,COLON		; PUT COLON AFTER USER NAME
	IDPB	AC3,AC			; DO IT
	SETZ	AC3,			; ZERO AC3
	MOVE	AC1,@1(AP)		; GET HOST NO.
MKLGS4:	IDIVI	AC1,^D10
	ADDI	AC2,60			; CONVERT TO ASCII
	LSHC	AC2,-7			; SAVE ONE DIGIT ON AC3
	JUMPG	AC1,MKLGS4		; CONTINUE UNTIL HOST = 0
	MOVE	AC1,[POINT 7,AC3]	; PREPARE TO MOVE HOST TO LOGIN STRING
MKLGS5:	ILDB	AC2,AC1			; GET ON DIGIT FROM AC3
	JUMPE	AC2,MKLGS6		; DONE IF NULL
	IDPB	AC2,AC			; PUT CURRENT DIGIT INTO LOGIN STRING
	JRST	MKLGS5			; CONTINUE
MKLGS6:	MOVEI	AC2,73			; PUT A SEMICOLON AT THE END OF LOGSTR
	IDPB	AC2,AC
	POPJ	P,

SLEEPY:	MOVE	AC1,@(AP)
	CAILE	AC1,104
	JRST	SLEEP2
SLEEP1:	SLEEP	AC1,
	POPJ	P,
SLEEP2:	MOVEI	AC,104
	SLEEP	AC,
	SUBI	AC1,104
	CAIG	AC1,104
	JRST	SLEEP1
	JRST	SLEEP2

SWAKE:  SETZ    AC1,
        MOVEI   AC,SLEEP1
        MOVEM   AC,TRPVEC+2
        DISMIS

GDATE:	DATE	AC,			; GET CURRENT DATE
	IDIVI	AC,^D31			; ISOLATE DAY
	AOJ	AC1,
	MOVE	AC2,AC1
	IDIVI	AC,^D12			; ISOLATE MONTH
	AOJ	AC1,
	IMULI	AC1,^D100		; LEFT SHIFT 2 DECIMAL PLACES
	ADD	AC2,AC1
	ADDI	AC,^D64			; ADJUST YEAR
	IMULI	AC,^D10000		; LEFT SHIFT 4 DECIMAL PLACES
	ADD	AC,AC2
	SETZB	AC1,AC2
	DMOVEM	AC1,@(AP)
	MOVEI	AC2,@(AP)
	HRLI	AC2,(POINT 7)
GDATE1:	IDIVI	AC,^D10
	HRLM	AC1,(P)
	JUMPE	AC,GDATE2
	PUSHJ	P,GDATE1
GDATE2:	HLRZ	AC,(P)
	ADDI	AC,60
	IDPB	AC,AC2
	POPJ	P,

NXTFIL:	SETZM	@1(AP)			; CLEAR FLAG
	DMOVE	@(AP)			; GET FILE NAME
	MOVE	AC2,[POINT 7,AC1,20]	; BYTE POINTER OF FILENAME EXT
	LDB	AC3,AC2			; GET A BYTE FROM FILENAME EXT
	CAIE	AC3,132			; SKIP IF CHAR IS "Z"
	JRST	NXTF1
	SETOM	@1(AP)			; SET FLAG
	MOVEI	AC3,100			; START WITH FILE A
NXTF1:	AOJ	AC3,
	DPB	AC3,AC2
	DMOVEM	@(AP)
	POPJ	P,

MAKFIL: DMOVE   @(16)
        MOVE    2,[POINT 7,1,6]
        MOVE    3,@2(16)
        MOVE    4,[POINT 7,3]
        MOVEI   6,4
MAKFL1: ILDB    5,4
        JUMPE   5,MAKFL2
        CAIE    5,40
        JRST    .+3
        ILDB    5,2
        SKIPA
        IDPB    5,2
        SOJG    6,MAKFL1
MAKFL2: DMOVEM  @1(16)
        POPJ    P,

GUSERN: MOVE    1,[-1,,-22]
        GETTAB  1,
        JFCL
        MOVE    2,[-1,,-21]
        GETTAB  2,
        MOVEI   12
        MOVE    3,[POINT 6,1]
        MOVE    4,(16)
        HRLI    4,(POINT 7)
GUSER1: ILDB    5,3
        JUMPE   5,GUSER2
        ADDI    5,40
        IDPB    5,4
        SOJG    5,GUSER1
GUSER2: POPJ    P,

MTIME:  MSTIME  1,
        IDIVI   1,^D1000
        MOVEM   1,@(16)
        POPJ    P,

DETACH: MOVE	AC,[-26]
	GETTAB	AC,
	JFCL
	ANDI	AC,7777
	MOVEI	AC3,3
	SETZ	AC2,
	IDIVI	AC,12
	ADDI	AC1,60
	LSHC	AC1,-7
	SOJG	AC3,.-3
	MOVEM	AC2,@(AP)
	OUTCHR	[15]
	OUTCHR	[12]
	OUTSTR	[ASCIZ/Detaching .../]
	OUTCHR	[15]
	OUTCHR	[12]
	SETO	AC,
	ATTACH	AC,
	JFCL
	POPJ	P,

SORT:	PUSHJ	P,CREFRM	; CREATE A FRAME
	POPJ	P,		; CANNOT CREATE FRAME, RETURN
	PUSHJ	P,WTF		; WRITE TEMP DISK FOR CHILD
	JRST	SORT2		; CANNOT WRITE FILE, CLEANUP AND RETURN
	PUSHJ	P,GETPRG	; GET (SYS)SORT IN CHILD
	JRST	SORT2
	PUSHJ	P,STARTC	; START CHILD FRAME
	JRST	SORT1
	PUSHJ	P,FWAIT		; WAIT FOR CHILD FRAME TO HALT
	JFCL			; TIME OUT
	PUSHJ	P,CHKSTS	; CHECK CHILD TERMINATION STATUS
	JFCL
SORT1:	PUSHJ	P,CLRFRM	; CLEAR CHILD FRAME (TO GET WRITE RIGHT)
	JFCL
SORT2:	PUSHJ	P,KILFRM	; KILL CHILD FRAME
	JFCL
	POPJ	P,

CREFRM:	MOVSI	AC,1		; .FOCFM= 1
	FRMOP	AC,[0]		; DEFAULT ALL PARAMETERS
	JRST	FOERR
	MOVEM	AC,FID		; SAVE FRAME DESCRIPTOR
	MOVE	AC,[400,,1]	; WAIT FOR CHILD TO HALT OR 1 mS
	HIBER	AC,		; CLEAR "CHILD HALTED" CONDITION
	JFCL
	MOVEI	AC,7		; SETUP HSB LENGTH COUNT
	MOVEM	AC,FRMHSB
	MOVE	AC,FID
	HRLI	AC,23		; .FOHST= 23
	FRMOP	AC,FRMHSB	; READ INITIAL HALT STATUS
	JRST	FOERR
	AOS	(P)
	POPJ	P,
FOERR:	ADDI	AC,^D20000	; FRMOP FAILED, CODE IN eXXXX
	MOVEM	AC,@3(AP)
	POPJ	P,

GETPRG:	MOVEI	AC,5		; NUMBER OF ARGUMENT PASSED
	MOVEM	AC,PRGNAM
	HRLZI	AC,(SIXBIT/DSK/)
	MOVEM	AC,PRGNAM+1	; DEVICE
	MOVE	AC,[1,,650004]	; PPN OF KHANHQN
	MOVEM	AC,PRGNAM+2
	MOVE	AC,[SIXBIT/SORT/]
	MOVEM	AC,PRGNAM+3
	SETZM	PRGNAM+4
	SETZM	PRGNAM+5
	MOVE	AC,FID
	HRLI	AC,32		; PREPARE TO DO THE GET COMMAND (.FOGET= 32)
	FRMOP	AC,PRGNAM	; GET COMMAND
	JRST	FOERR
	PUSHJ	P,FWAIT		; WAIT
	POPJ	P,
	MOVE	AC,FRMHSB+1	; GET CLASS,,TYPE
	CAME	AC,[4,,4]	; [HC.EXI,,HT.JSU]
	JRST	HSERR
	AOS	(P)
	POPJ	P,

STARTC:	MOVE	AC,FID
	HRLI	AC,22		; .FOSVA= 22
	FRMOP	AC,[-2]		; CCL START ADDRESS (SV.CCL= -2)
	JRST	FOERR
	AOS	(P)
	POPJ	P,

CLRFRM:	MOVE	AC,FID		; CLEAR CHILD FRAME
	HRLI	AC,14		; .FOCLR= 14
	FRMOP	AC,		; REQUEST CHILD TO CLEAR
	JRST	FOERR
	PUSHJ	P,FWAIT		; WAIT FOR FRAME TO CLEAR
	POPJ	P,
	AOS	(P)
	POPJ	P,

KILFRM:	MOVE	AC,FID		; TERMINATE THE CHILD FRAME
	HRLI	AC,33		; .FORUN= 33
	FRMOP	AC,LOGOUT
	JRST	FOERR
	AOS	(P)
	POPJ	P,

FWAIT:	MOVSI	AC,400		; WAIT FOR CHILD FRAME TO HALT
	HIBER	AC,
	JRST	FERR1
	HLRZ	AC,FID		; .GTSTS= 0
	GETTAB	AC,		; GET CHILD'S RUN STATE
	JRST	FERR2
	JUMPL	AC,FWAIT	; TRY AGAIN - STILL RUNNING
	MOVE	AC1,FRMHSB	; GET OLD HALT COUNT
	MOVE	AC,FID
	HRLI	AC,23		; .FOHST= 23
	FRMOP	AC,FRMHSB	; READ HALT STATUS
	JRST	FOERR
	CAMN	AC1,FRMHSB+2	; DID COUNT INCREMENT?
	SETOM	FRMHSB+1	; SET CLASS,,TYPE = -1 FOR ^C(ASSUMED)
	AOS	(P)
	POPJ	P,
FERR1:	MOVEI	AC,6		; HIBER FAILED, SHOULD NEVER HAPPEN
	JRST	FERR2+1
FERR2:	MOVEI	AC,5		; GETTAB FAILED (FRAME PROBABLY VANISHED)
	MOVEM	AC,@3(AP)
	POPJ	P,

CHKSTS:	MOVE	AC,FRMHSB+1	; GET CLASS,,TYPE
	CAMN	AC,[-1]	; ^C
	JRST	CKERR1
	CAMN	AC,[4,,0]	; [HC.EXI,,HT.EXI]
	JRST	CKRTN
	CAMN	AC,[4,,1]	; [HC.EXI,,HT.EX1]
	JRST	CKRTN
	CAMN	AC,[4,,2]	; [HC.EXI,,HT.FEX]
	JRST	CKERR2
HSERR:	HRRZM	AC,AC1		; SAVE ERROR CODE FROM HSB IN 1CCTT FORMAT
	HLRZ	AC,AC
	IMULI	AC,^D100
	ADD	AC,AC1
	ADDI	AC,^D10000	; HALT STATUS (CHILD FRAME HALTED UNEXPECTEDLY)
	MOVEM	AC,@3(AP)
	POPJ	P,
CKERR1:	MOVEI	AC,1		; CHILD FRAME HALTED WITH NO HALT STATUS (^C)
	MOVEM	AC,@3(AP)
	POPJ	P,
CKERR2:	MOVE	AC1,FRMHSB+6
	MOVEM	AC1,@4(AP)
	JRST	HSERR
CKRTN:	SETZM	@3(AP)		; NORMAL TERMINATION - NO ERRORS
	SETZM	@4(AP)
	AOS	(P)
	POPJ	P,
WTF:	MOVE	AC,FID		; PREPARE TO MAKE TEMP DISK NAME
	ANDI	AC,7777		; ISOLATE ABSOLUTE FRAME NUMBER
	MOVSI	AC2,(SIXBIT "SOR")
	MOVEI	AC3,3		; NUMBER OF DIGITS TO DO
WTF1:	IDIVI	AC,12		; GET DIGIT IN AC1
	ADDI	AC1,20		; CONVERT TO SIXBIT
	LSHC	AC1,-6
	SOJG	AC3,WTF1
	MOVEM	AC2,TMPNAM
	HRLZI	AC,(SIXBIT/TMP/)
	MOVEM	AC,TMPEXT
	SETZM	TMPNAM+2
	SETZM	TMPNAM+3
	HRLOI	AC,13		; OPEN CHANNEL (.CHOPN= 13)
	CHANIO	AC,[EXP <0>,<SIXBIT "DSK">,<OBUF,,0>]
	JRST	OCERR		; OPEN CHANNEL ERROR
	HRLI	AC,5		; ENTER FILE (.CHENT= 5)
	CHANIO	AC,TMPNAM
	JRST	ENTERR		; ENTER ERROR
	MOVEI	AC3,@1(AP)	; GET ADDRESS OF OUTPUT FILE
	MOVEI	AC1,12		; MAX OF FILENAME
	PUSHJ	P,STROUT	; WRITE OUTPUT FILENAME TO TEMP FILE
	JRST	WTFERR		; ERROR DURING TO FREE UP A BUFFER
	MOVEI	AC2,137		; WRITE CHAR "_"
	PUSHJ	P,CHROUT
	JRST	WTFERR
	MOVEI	AC3,@(AP)	; ADDRESS OF INPUT FILE
	MOVEI	AC1,12
	PUSHJ	P,STROUT	; WRITE INPUT FILENAME TO TEMP FILE
	JRST	WTFERR
	MOVEI	AC3,@2(AP)	; GET ADDRESS OF DATA
	SETO	AC1,
	PUSHJ	P,STROUT
	JRST	WTFERR
	HRLI	AC,0		; RELEASE CHANNEL (.CHREL= 0)
	CHANIO	AC,
	AOS	(P)
	POPJ	P,
OCERR:	MOVEI	AC,2		; OPEN FAILURE FOR DEVICE DISK
	JRST	WTFERR
ENTERR:	MOVEI	AC,3		; ENTER FAILURE FOR TEMP FILE (ON DISK)
WTFERR:	MOVEM	AC,@3(AP)
	POPJ	P,

STROUT:	HRLI	AC3,(POINT 7)	; MAKE BYTE POINTER FOR OUTPUT STRING
	ILDB	AC2,AC3		; GET A CHARACTER
	JUMPE	AC2,STRRTN	; RETURN IF CHAR IS NULL
	CAIN	AC2,40		; SKIP IF NOT SPACE
	JRST	STRRTN
	PUSHJ	P,CHROUT	; OUTPUT A CHAR
	POPJ	P,		; NON-SKIP RETURN
	JUMPL	AC1,STROUT+1
	SOJG	AC1,STROUT+1
STRRTN:	AOS	(P)		; SKIP RETURN
	POPJ	P,

CHROUT:	SOSG	OBCT		; UPDATE BUFFER POINTER
	JRST	CHR2		; FLUSH OUTPUT BUFFER
CHR1:	IDPB	AC2,OBPTR	; DEPOSIT BYTE
	AOS	(P)
	POPJ	P,
CHR2:	HRLI	AC,15		; .CHOUT= 15
	CHANIO	AC,		; OUTPUT DATA IN BUFFER TO TEMP FILE
	JRST	CHR1		; NORMAL RETURN
	MOVEI	AC,4		; ERROR CODE FOR OUTPUT ERROR
	POPJ	P,		; ERROR RETURN

WAKEUP: MOVE    AC,[IA.REE,,TRPVEC]
        INTADR  AC,
        JFCL
        MOVE    AC,[.IAWAK,,2]
        INTASS  AC,
        JFCL
        HRLZI   AC,(1B0!1B2)
        INTENB  AC,
        JFCL
        POPJ    P,

TRPVEC:	0
	G1234D
        0
        SWAKE
PRGNAM:	BLOCK	6
PTABL:	BLOCK	5
PTBLEN==.-PTABL
FID:	BLOCK	1
FRMHSB:	BLOCK	10
INTERN	FRMHSB
LOGOUT:	XWD	1,3
	SIXBIT	/SYS/
	0
	SIXBIT	/LOGOUT/
OBUF:	0
OBPTR:	0
OBCT:	0
TMPNAM:	BLOCK	4
TMPEXT==TMPNAM+1

	END
  c@&`