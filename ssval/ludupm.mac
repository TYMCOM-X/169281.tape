	ENTRY	BLDCIR,ZAPC,S1BYTE,S2BYTE,S3BYTE,SUNAME,G1BYTE
	ENTRY	G2BYTE,G3BYTE,GUNAME,MKLGST,SLEEPY,GDATE,NXTFIL
	ENTRY	MAKFIL,GUSERN,MTIME,DETACH,SORT,WAKEUP

; Accumulator definitions

AC==0
AC1==1
AC2==2
AC3==3
AC4==4
AP==16
P==17

; Universal symbols and constants

.AXI8C==0
.AXO8==3
.AXO8I==4
.AXOST==52
.IATIM==4
.IAWAK==6
IA.REE==2
IA.CLR==4
BLNK==40
COLON==72
.CR==15

; Subroutine to create an aux circuit
; FORTRAN calls as: CALL BLDCIR(LOGSTR,PRGNAM,PORT,ERRCOD)
; LOGSTR is an ASCII string.
; PRGNAM is program name followed by a dollar sign "$"
; a zero if no program name.
; PORT is an integer var is used to return the port no.
; ERRCOD is an integer variable.

BLDCIR:	SETZM	@3(AP)			; CLEAR HOST ERROR
	MOVEI	AC,@(AP)		; GET ADDRESS OF LOGIN STRING
	CREAUX	AC,			; CREATE AN AUX CIRCUIT
	JRST	BLDERR			; ERROR
	MOVEM	AC,@2(AP)		; RETURN PORT NO.
	HRLZS	AC			; SET AC TO [PORT,,0]
	HRRI	AC,.AXO8I		; OUTPUT CHAR IMMEDIATE
	AUXCAL	AC,.CR			; OUTPUT CR
	AUXCAL	AC,.CR
	AUXCAL	AC,.CR
	SKIPN	@1(AP)			; SKIP IF START A PROGRAM
	JRST	HSHAKE
	MOVEI	AC1,@1(AP)		; GET ADDRESS OF PROG. NAME
	HRLI	AC1,(POINT 7)		; MAKE BYTE POINTER
	MOVE	AC2,[POINT 7,PRGNAM]	; GET BYTE POINTER OF PRGNAM
	MOVEI	AC4,^D30		; MAX CHARS OF PROG NAME
BDCIR1:	ILDB	AC3,AC1			; GET A CHAR FROM PROGRAM NAME
	CAIN	AC3,44			; SKIP IF NOT DOLLAR SIGN
	JRST	BDCIR2
	IDPB	AC3,AC2			; SAVE CHAR IN PRGNAM
	SOJG	AC4,BDCIR1
	MOVEI	AC1,26			; PROGRAM NAME NOT TERMINATE WITH $
	JRST	BDERR1			; ILLEGAL NAME CODE 11
BDCIR2:	MOVEI	AC3,.CR			; PUT CR TO THE END OF PROGNAM
	IDPB	AC3,AC2
	SETZ	AC3,
	IDPB	AC3,AC2			; PUT A NULL
	HRRI	AC,.AXOST		; PREPARE FOR OUTPUT PROGRAM NAME
	AUXCAL	AC,PRGNAM		; DO IT
HSHAKE:	SETZ	AC4,
	SETTIM	AC4,			; RESET TIMMER
	JFCL
	HRLI	AC4,IA.REE		; INITIALIZE INTERRUPT ADDRESS SYS.
	HRRI	AC4,TRPVEC		; TRAP VECTOR ADDRESS
	INTADR	AC4,			; GET READY TO SET TIMER INTERRUPT
	JRST	[MOVEI	AC1,22		; UNABLE TO INITIALIZE INTADR SYSTEM
		 JRST	BDERR1]
	MOVE	AC4,[1,,264]		; PREPARE TO SET 3 MINUTES TIMEOUT
	SETTIM	AC4,			; DO IT
	JFCL
	HRLI	AC4,.IATIM		; ENABLE TIMER INTERRUPT
	HRRI	AC4,1			; TIMER CHANNEL
	INTASS	AC4,			; SET IT
	JRST	[MOVEI	AC1,23		; UNABLE TO ASSIGN INTERRUPT CAUSES
		 JRST	BDERR1]
	HRLZI	AC4,(1B0!1B1!1B2)	; ENABLE INTADR ON CHANNEL 1 AND 2
	INTENB	AC4,
	JRST	[MOVEI	AC1,24		; INTERRUPT ADDRESS NOT IN EFFECT
		 JRST	BDERR1]
	HRRI	AC,.AXI8C		; PREPARE FOR INPUT CHAR FROM PORT
G1234A:	AUXCAL	AC,AC1			; GET FIRST BYTE
	JRST	G1234C
	CAIE	AC1,1			; SKIP IF IT IS ONE
	JRST	G1234A			; NO, TRY AGAIN
	AUXCAL	AC,AC1			; GET SECOND BYTE
	JRST	G1234C
	CAIE	AC1,2			; SKIP IF TWO
	JRST	G1234A			; TRY AGAIN
	AUXCAL	AC,AC1			; GET THIRD BYTE
	JRST	G1234C
	CAIE	AC1,3			; SKIP IF THREE
	JRST	G1234A			; TRY AGAIN
	AUXCAL	AC,AC1			; GET FOURTH BYTE
	JRST	G1234C
	CAIE	AC1,4			; SKIP IF FOUR
	JRST	G1234A
	HRRI	AC,.AXO8I		; RESPOND HANDSHAKE
	AUXCAL	AC,1			; SEND 1
	AUXCAL	AC,2			; SEND 2
	AUXCAL	AC,3			; SEND 3
	AUXCAL	AC,4			; SEND 4
G1234B:	HRLZI	AC4,IA.CLR		; SET TO DISABLE INTADR
	INTADR	AC4,
	JRST	[MOVEI	AC1,25		; UNABLE TO CLEAR TIMER INTERRUPT SYS.
		 JRST	BDERR1]
	SETZ	AC4,
	SETTIM	AC4,			; RESET TIMMER
	JFCL
        MOVE    AC4,[IA.REE,,TRPVEC]
        INTADR  AC4,
        JFCL
        HRLZI   AC4,(1B0!1B2)
        INTENB  AC4,
        JFCL
	POPJ	P,			; RETURN
G1234C:	MOVEI	AC1,21			; ERROR CODE FOR HANDSHAKE TIMEOUT
	MOVEM	AC1,@3(AP)
	HLRZS	AC
	ZAPCIR	AC,			; ZAP CURRENT PORT
	JRST	G1234B			; GO TO CLEAR TIMER INTERRUPT SYS.
G1234D:	MOVEI	AC4,G1234C
	MOVEM	AC4,TRPVEC
	DISMIS
BLDERR:	HLRZ	AC1,AC			; GET HOST ERROR CODE
	SKIPE	AC1
	JRST	.+3
	HRRZ	AC1,AC			; GET SUP ERROR CODE
	ADDI	AC1,7
	MOVEM	AC1,@3(AP)		; RETURN ERROR CODE
	JRST	BDERR2
BDERR1:	MOVEM	AC1,@3(AP)		; RETURN ERROR CODE
	HLRZS	AC
	ZAPCIR	AC,			; ZAP CURRENT PORT
BDERR2:	SETZM	@2(AP)			; ZERO PORT FIELD
	POPJ	P,			; RETURN

; Subroutine to zap an auxiliary circuit.
; FORTRAN calls as: CALL ZAPC(PORT), where PORT is an integer var, port no.

ZAPC:	MOVE	AC,@(AP)		; GET PORT NUMBER
	ZAPCIR	AC,			; ZAP AN AUX CIRCUIT
	POPJ	P,

; Subroutine sends bytes through auxiliary circuit
; FORTRAN calls as: CALL S#BYTE(PORT,BYTES) where # is 1,2, or 3.
; PORT is port number.
; BYTES is an integer variable

S1BYTE:	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXO8		; PREPARE FOR AUXCAL
	MOVE	AC1,@1(AP)		; GET CONTENT OF BYTE TO BE SENT
	AUXCAL	AC,AC1
	POPJ	P,
S2BYTE:	MOVEI	AC3,2			; SEND 2 BYTES
	MOVE	AC2,@1(AP)		; GET CONTENT OF ARGUMENT
	LSH	AC2,24			; LEFT JUSTIFY
	JRST	SBYTES
S3BYTE:	MOVEI	AC3,3			; SEND 3 BYTES
	MOVE	AC2,@1(AP)		; GET CONTENT OF ARGUMENT
	LSH	AC2,14			; LEFT JUSTIFY
SBYTES:	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXO8		; PREPARE FOR AUXCAL
SBYTEL:	SETZ	AC1,
	LSHC	AC1,10			; GET A BYTE (8-BIT)
	AUXCAL	AC,AC1			; SEND IT
	SOJG	AC3,SBYTEL		; DO THE REST
	POPJ	P,			; RETURN

; Subroutine sends a username through an auxiliary circuit.
; FORTRAN calls as: CALL SUNAME(PORT,UNAME,LENGTH)
; PORT is port number
; UNAME is an ASCII string.
; LENGTH is the length if UNAME in chars.

SUNAME:	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXO8		; OUTPUT CHAR CODE FOR AUXCAL
	MOVEI	AC1,@1(AP)		; GET ADDRESS OF USERNAME
	HRLI	AC1,(POINT 7)		; MAKE BYTE POINTER
	MOVE	AC3,@2(AP)		; GET LENGTH OF USERNAME
SUNAM1:	ILDB	AC2,AC1
	SUBI	AC2,40			; CONVERT FROM ASCII TO SIXBIT
	AUXCAL	AC,AC2			; SEND IT
	SOJG	AC3,SUNAM1		; DO THE REST
	POPJ	P,

; Subroutine gets bytes from an aux. circuit.
; FORTRAN calls as: CALL G#BYTE(PORT,MEM,LABEL)
; where # is number of bytes to get
; PORT is port number
; MEM is an integer variable
; LABEL is a statement label (ie. $10,$30,$20, etc.), if circuit
; zapped then G#BYTE will return to that statement label.

G1BYTE:	MOVEI	AC3,1			; GET 1 BYTE
	JRST	GBYTES
G2BYTE:	MOVEI	AC3,2			; NUMBER OF BYTES IS 2
	JRST	GBYTES
G3BYTE:	MOVEI	AC3,3			; NUMBER OF BYTES IS 3
GBYTES:	SETZ	AC2,			; ZERO RESULT FIELD
	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXI8C		; PREPARE FOR AUXCAL
GBYTE1:	PUSHJ	P,AINCHR		; GET A BYTE
	JRST	GBYTER
	LSH	AC2,10			; SHIFT PREVIOUS VALUE
	OR	AC2,AC1			; INCLUDE CURRENT BYTE
	SOJG	AC3,GBYTE1		; DO THE REST
	MOVEM	AC2,@1(AP)		; MOVE RESULT TO RETURN ARGUMENT
	POPJ	P,
GBYTER:	SETZM	@(AP)			; ZERO PORT FIELD
	MOVEI	AC,@2(AP)		; GET RETURN ADDRESS
	HRRM	AC,(P)
	POPJ	P,

; Subroutine gets a username from aux. circuit
; FORTRAN calls as: CALL GUNAME(PORT,UNAME,LENGTH,LABEL1,LABEL2)
; PORT is port number.
; UNAME string of ASCII chars. If UNAME(1) = 377 then end of input
; LENGTH is length of username.
; LABEL1 is statement label (.ie $10,$20 etc.),, if a 377 is
; received then program control will transfer to that statement label.
; LABEL2 is a statement label, if circuit zapped then program
; control will return to that statement label.

GUNAME:	MOVEI	AC2,@1(AP)		; GET ADDRESS OF STRING
	HRLI	AC2,(POINT 7)		; MAKE BYTE POINTER
	MOVE	AC3,@2(AP)		; NO. OF BYTES TO GET
	HRL	AC,@(AP)		; GET PORT NO.
	HRRI	AC,.AXI8C		; PREPARE FOR AUXCAL
	PUSHJ	P,AINCHR		; GET A CHAR
	JRST	GUNERR
	CAIN	AC1,377			; CHECK FOR TERMINATION BYTE
	JRST	GUNEND
	ADDI	AC1,40			; CONVERT TO ASCII
	IDPB	AC1,AC2			; SAVE A BYTE
	SOJ	AC3,
GUNAM1:	PUSHJ	P,AINCHR
	JRST	GUNERR
	ADDI	AC1,40
	IDPB	AC1,AC2
	SOJG	AC3,GUNAM1
	POPJ	P,
GUNEND:	MOVEI	AC,@3(AP)
	HRRM	AC,(P)
	POPJ	P,
GUNERR:	SETZM	@(AP)
	MOVEI	AC,@4(AP)
	HRRM	AC,(P)
	POPJ	P,

AINCHR:	AUXCAL	AC,AC1
	JRST	CHKPRT
	AOS	(P)
	POPJ	P,

CHKPRT:	HRLI	AC1,-PTBLEN		; LENGTH OF PORT TABLE
	HRRI	AC1,PTABL		; ADDRESS
	AUXRED	AC1,
	JFCL
	HLRZS	AC			; GET PORT NO. TO RIGHT OF AC
	SETZ	AC1,
CHKPLP:	SKIPGE	PTABL(AC1)
	POPJ	P,			; NOT FOUND, CIRCUIT ZAP
	CAMN	AC,PTABL(AC1)		; SKIP IF NO MATCH FOUND YET
	JRST	[HRLZS	AC		; TRY TO GET A BYTE AGAIN
		 HRRI	AC,.AXI8C
		 JRST	AINCHR]
	AOJA	AC1,CHKPLP

; Subroutine to make Login String.
; FORTRAN calls as: CALL MKLGST(UNAME,HOST,LOGSTR)
; UNAME is a string of alphabetic or numeric 7-bit ASCII.
; HOST is an integer variable.
; LOGSTR is an array of five elements.

MKLGST:	HRRZI	AC1,@2(AP)		; PREPARE TO CLEAR THE LOGIN STRING
	MOVEI	AC,5			; MAX WORDS OF LOGIN STRING
MKLGS1:	SETZM	@AC1			; ZERO ONE WORD
	AOJ	AC1,			; INCREMENT INDEX
	SOJG	AC,MKLGS1		; CONTINUE UNTIL DONE
	MOVEI	AC,@2(AP)		; GET ADDRESS OF LOGIN STRING
	HRLI	AC,(POINT 7)		; MAKE BYTE POINTER
	MOVEI	AC1,@(AP)		; GET ADDRESS OF USERNAME
	HRLI	AC1,(POINT 7)		; MAKE BYTE POINTER
	MOVEI	AC2,^D12		; MAX LENGTH OF USERNAME
MKLGS2:	ILDB	AC3,AC1			; GET A CHAR FROM USER NAME
	JUMPE	AC3,MKLGS3		; DONE IF NULL
	CAIN	AC3,BLNK		; IS CURRENT CHAR A BLANK?
	JRST	MKLGS3			; YES, DONE
	IDPB	AC3,AC			; NO, PUT IT INTO LOGIN STRING
	SOJG	AC2,MKLGS2		; DO THE REST
MKLGS3:	MOVEI	AC3,COLON		; PUT COLON AFTER USER NAME
	IDPB	AC3,AC			; DO IT
	SETZ	AC3,			; ZERO AC3
	MOVE	AC1,@1(AP)		; GET HOST NO.
MKLGS4:	IDIVI	AC1,^D10
	ADDI	AC2,60			; CONVERT TO ASCII
	LSHC	AC2,-7			; SAVE ONE DIGIT ON AC3
	JUMPG	AC1,MKLGS4		; CONTINUE UNTIL HOST = 0
	MOVE	AC1,[POINT 7,AC3]	; PREPARE TO MOVE HOST TO LOGIN STRING
MKLGS5:	ILDB	AC2,AC1			; GET ON DIGIT FROM AC3
	JUMPE	AC2,MKLGS6		; DONE IF NULL
	IDPB	AC2,AC			; PUT CURRENT DIGIT INTO LOGIN STRING
	JRST	MKLGS5			; CONTINUE
MKLGS6:	MOVEI	AC2,73			; PUT A SEMICOLON AT THE END OF LOGSTR
	IDPB	AC2,AC
	POPJ	P,

SLEEPY:	MOVE	AC1,@(AP)
	CAILE	AC1,104
	JRST	SLEEP2
SLEEP1:	SLEEP	AC1,
	POPJ	P,
SLEEP2:	MOVEI	AC,104
	SLEEP	AC,
	SUBI	AC1,104
	CAIG	AC1,104
	JRST	SLEEP1
	JRST	SLEEP2

SWAKE:  SETZ    AC1,
        MOVEI   AC,SLEEP1
        MOVEM   AC,TRPVEC+2
        DISMIS

GDATE:	DATE	AC,			; GET CURRENT DATE
	IDIVI	AC,^D31			; ISOLATE DAY
	AOJ	AC1,
	MOVE	AC2,AC1
	IDIVI	AC,^D12			; ISOLATE MONTH
	AOJ	AC1,
	IMULI	AC1,^D100		; LEFT SHIFT 2 DECIMAL PLACES
	ADD	AC2,AC1
	ADDI	AC,^D64			; ADJUST YEAR
	IMULI	AC,^D10000		; LEFT SHIFT 4 DECIMAL PLACES
	ADD	AC,AC2
	SETZB	AC1,AC2
	DMOVEM	AC1,@(AP)
	MOVEI	AC2,@(AP)
	HRLI	AC2,(POINT 7)
GDATE1:	IDIVI	AC,^D10
	HRLM	AC1,(P)
	JUMPE	AC,GDATE2
	PUSHJ	P,GDATE1
GDATE2:	HLRZ	AC,(P)
	ADDI	AC,60
	IDPB	AC,AC2
	POPJ	P,

NXTFIL:	SETZM	@1(AP)			; CLEAR FLAG
	DMOVE	@(AP)			; GET FILE NAME
	MOVE	AC2,[POINT 7,AC1,20]	; BYTE POINTER OF FILENAME EXT
	LDB	AC3,AC2			; GET A BYTE FROM FILENAME EXT
	CAIE	AC3,132			; SKIP IF CHAR IS "Z"
	JRST	NXTF1
	SETOM	@1(AP)			; SET FLAG
	MOVEI	AC3,100			; START WITH FILE A
NXTF1:	AOJ	AC3,
	DPB	AC3,AC2
	DMOVEM	@(AP)
	POPJ	P,

MAKFIL: DMOVE   @(16)
        MOVE    2,[POINT 7,1,6]
        MOVE    3,@2(16)
        MOVE    4,[POINT 7,3]
        MOVEI   6,4
MAKFL1: ILDB    5,4
        JUMPE   5,MAKFL2
        CAIE    5,40
        JRST    .+3
        ILDB    5,2
        SKIPA
        IDPB    5,2
        SOJG    6,MAKFL1
MAKFL2: DMOVEM  @1(16)
        POPJ    P,

GUSERN: MOVE    1,[-1,,-22]
        GETTAB  1,
        JFCL
        MOVE    2,[-1,,-21]
        GETTAB  2,
        MOVEI   12
        MOVE    3,[POINT 6,1]
        MOVE    4,(16)
        HRLI    4,(POINT 7)
GUSER1: ILDB    5,3
        JUMPE   5,GUSER2
        ADDI    5,40
        IDPB    5,4
        SOJG    5,GUSER1
GUSER2: POPJ    P,

MTIME:  MSTIME  1,
        IDIVI   1,^D1000
        MOVEM   1,@(16)
        POPJ    P,

DETACH: MOVE	AC,[-26]
	GETTAB	AC,
	JFCL
	ANDI	AC,7777
	MOVEI	AC3,3
	SETZ	AC2,
	IDIVI	AC,12
	ADDI	AC1,60
	LSHC	AC1,-7
	SOJG	AC3,.-3
	MOVEM	AC2,@(AP)
	OUTCHR	[15]
	OUTCHR	[12]
	OUTSTR	[ASCIZ/Detaching .../]
	OUTCHR	[15]
	OUTCHR	[12]
	SETO	AC,
	ATTACH	AC,
	JFCL
	POPJ	P,

SORT:	PUSHJ	P,CREFRM	; CREATE A FRAME
	POPJ	P,		; CANNOT CREATE FRAME, RETURN
	PUSHJ	P,WTF		; WRITE TEMP DISK FOR CHILD
	JRST	SORT2		; CANNOT WRITE FILE, CLEANUP AND RETURN
	PUSHJ	P,GETPRG	; GET (SYS)SORT IN CHILD
	JRST	SORT2
	PUSHJ	P,STARTC	; START CHILD FRAME
	JRST	SORT1
	PUSHJ	P,FWAIT		; WAIT FOR CHILD FRAME TO HALT
	JFCL			; TIME OUT
	PUSHJ	P,CHKSTS	; CHECK CHILD TERMINATION STATUS
	JFCL
SORT1:	PUSHJ	P,CLRFRM	; CLEAR CHILD FRAME (TO GET WRITE RIGHT)
	JFCL
SORT2:	PUSHJ	P,KILFRM	; KILL CHILD FRAME
	JFCL
	POPJ	P,

CREFRM:	MOVSI	AC,1		; .FOCFM= 1
	FRMOP	AC,[0]		; DEFAULT ALL PARAMETERS
	JRST	FOERR
	MOVEM	AC,FID		; SAVE FRAME DESCRIPTOR
	MOVE	AC,[400,,1]	; WAIT FOR CHILD TO HALT OR 1 mS
	HIBER	AC,		; CLEAR "CHILD HALTED" CONDITION
	JFCL
	MOVEI	AC,7		; SETUP HSB LENGTH COUNT
	MOVEM	AC,FRMHSB
	MOVE	AC,FID
	HRLI	AC,23		; .FOHST= 23
	FRMOP	AC,FRMHSB	; READ INITIAL HALT STATUS
	JRST	FOERR
	AOS	(P)
	POPJ	P,
FOERR:	ADDI	AC,^D20000	; FRMOP FAILED, CODE IN eXXXX
	MOVEM	AC,@3(AP)
	POPJ	P,

GETPRG:	MOVEI	AC,5		; NUMBER OF ARGUMENT PASSED
	MOVEM	AC,PRGNAM
	HRLZI	AC,(SIXBIT/DSK/)
	MOVEM	AC,PRGNAM+1	; DEVICE
	MOVE	AC,[1,,650004]	; PPN OF KHANHQN
	MOVEM	AC,PRGNAM+2
	MOVE	AC,[SIXBIT/SORT/]
	MOVEM	AC,PRGNAM+3
	SETZM	PRGNAM+4
	SETZM	PRGNAM+5
	MOVE	AC,FID
	HRLI	AC,32		; PREPARE TO DO THE GET COMMAND (.FOGET= 32)
	FRMOP	AC,PRGNAM	; GET COMMAND
	JRST	FOERR
	PUSHJ	P,FWAIT		; WAIT
	POPJ	P,
	MOVE	AC,FRMHSB+1	; GET CLASS,,TYPE
	CAME	AC,[4,,4]	; [HC.EXI,,HT.JSU]
	JRST	HSERR
	AOS	(P)
	POPJ	P,

STARTC:	MOVE	AC,FID
	HRLI	AC,22		; .FOSVA= 22
	FRMOP	AC,[-2]		; CCL START ADDRESS (SV.CCL= -2)
	JRST	FOERR
	AOS	(P)
	POPJ	P,

CLRFRM:	MOVE	AC,FID		; CLEAR CHILD FRAME
	HRLI	AC,14		; .FOCLR= 14
	FRMOP	AC,		; REQUEST CHILD TO CLEAR
	JRST	FOERR
	PUSHJ	P,FWAIT		; WAIT FOR FRAME TO CLEAR
	POPJ	P,
	AOS	(P)
	POPJ	P,

KILFRM:	MOVE	AC,FID		; TERMINATE THE CHILD FRAME
	HRLI	AC,33		; .FORUN= 33
	FRMOP	AC,LOGOUT
	JRST	FOERR
	AOS	(P)
	POPJ	P,

FWAIT:	MOVSI	AC,400		; WAIT FOR CHILD FRAME TO HALT
	HIBER	AC,
	JRST	FERR1
	HLRZ	AC,FID		; .GTSTS= 0
	GETTAB	AC,		; GET CHILD'S RUN STATE
	JRST	FERR2
	JUMPL	AC,FWAIT	; TRY AGAIN - STILL RUNNING
	MOVE	AC1,FRMHSB	; GET OLD HALT COUNT
	MOVE	AC,FID
	HRLI	AC,23		; .FOHST= 23
	FRMOP	AC,FRMHSB	; READ HALT STATUS
	JRST	FOERR
	CAMN	AC1,FRMHSB+2	; DID COUNT INCREMENT?
	SETOM	FRMHSB+1	; SET CLASS,,TYPE = -1 FOR ^C(ASSUMED)
	AOS	(P)
	POPJ	P,
FERR1:	MOVEI	AC,6		; HIBER FAILED, SHOULD NEVER HAPPEN
	JRST	FERR2+1
FERR2:	MOVEI	AC,5		; GETTAB FAILED (FRAME PROBABLY VANISHED)
	MOVEM	AC,@3(AP)
	POPJ	P,

CHKSTS:	MOVE	AC,FRMHSB+1	; GET CLASS,,TYPE
	CAMN	AC,[-1]	; ^C
	JRST	CKERR1
	CAMN	AC,[4,,0]	; [HC.EXI,,HT.EXI]
	JRST	CKRTN
	CAMN	AC,[4,,1]	; [HC.EXI,,HT.EX1]
	JRST	CKRTN
	CAMN	AC,[4,,2]	; [HC.EXI,,HT.FEX]
	JRST	CKERR2
HSERR:	HRRZM	AC,AC1		; SAVE ERROR CODE FROM HSB IN 1CCTT FORMAT
	HLRZ	AC,AC
	IMULI	AC,^D100
	ADD	AC,AC1
	ADDI	AC,^D10000	; HALT STATUS (CHILD FRAME HALTED UNEXPECTEDLY)
	MOVEM	AC,@3(AP)
	POPJ	P,
CKERR1:	MOVEI	AC,1		; CHILD FRAME HALTED WITH NO HALT STATUS (^C)
	MOVEM	AC,@3(AP)
	POPJ	P,
CKERR2:	MOVE	AC1,FRMHSB+6
	MOVEM	AC1,@4(AP)
	JRST	HSERR
CKRTN:	SETZM	@3(AP)		; NORMAL TERMINATION - NO ERRORS
	SETZM	@4(AP)
	AOS	(P)
	POPJ	P,
WTF:	MOVE	AC,FID		; PREPARE TO MAKE TEMP DISK NAME
	ANDI	AC,7777		; ISOLATE ABSOLUTE FRAME NUMBER
	MOVSI	AC2,(SIXBIT "SOR")
	MOVEI	AC3,3		; NUMBER OF DIGITS TO DO
WTF1:	IDIVI	AC,12		; GET DIGIT IN AC1
	ADDI	AC1,20		; CONVERT TO SIXBIT
	LSHC	AC1,-6
	SOJG	AC3,WTF1
	MOVEM	AC2,TMPNAM
	HRLZI	AC,(SIXBIT/TMP/)
	MOVEM	AC,TMPEXT
	SETZM	TMPNAM+2
	SETZM	TMPNAM+3
	HRLOI	AC,13		; OPEN CHANNEL (.CHOPN= 13)
	CHANIO	AC,[EXP <0>,<SIXBIT "DSK">,<OBUF,,0>]
	JRST	OCERR		; OPEN CHANNEL ERROR
	HRLI	AC,5		; ENTER FILE (.CHENT= 5)
	CHANIO	AC,TMPNAM
	JRST	ENTERR		; ENTER ERROR
	MOVEI	AC3,@1(AP)	; GET ADDRESS OF OUTPUT FILE
	MOVEI	AC1,12		; MAX OF FILENAME
	PUSHJ	P,STROUT	; WRITE OUTPUT FILENAME TO TEMP FILE
	JRST	WTFERR		; ERROR DURING TO FREE UP A BUFFER
	MOVEI	AC2,137		; WRITE CHAR "_"
	PUSHJ	P,CHROUT
	JRST	WTFERR
	MOVEI	AC3,@(AP)	; ADDRESS OF INPUT FILE
	MOVEI	AC1,12
	PUSHJ	P,STROUT	; WRITE INPUT FILENAME TO TEMP FILE
	JRST	WTFERR
	MOVEI	AC3,@2(AP)	; GET ADDRESS OF DATA
	SETO	AC1,
	PUSHJ	P,STROUT
	JRST	WTFERR
	HRLI	AC,0		; RELEASE CHANNEL (.CHREL= 0)
	CHANIO	AC,
	AOS	(P)
	POPJ	P,
OCERR:	MOVEI	AC,2		; OPEN FAILURE FOR DEVICE DISK
	JRST	WTFERR
ENTERR:	MOVEI	AC,3		; ENTER FAILURE FOR TEMP FILE (ON DISK)
WTFERR:	MOVEM	AC,@3(AP)
	POPJ	P,

STROUT:	HRLI	AC3,(POINT 7)	; MAKE BYTE POINTER FOR OUTPUT STRING
	ILDB	AC2,AC3		; GET A CHARACTER
	JUMPE	AC2,STRRTN	; RETURN IF CHAR IS NULL
	CAIN	AC2,40		; SKIP IF NOT SPACE
	JRST	STRRTN
	PUSHJ	P,CHROUT	; OUTPUT A CHAR
	POPJ	P,		; NON-SKIP RETURN
	JUMPL	AC1,STROUT+1
	SOJG	AC1,STROUT+1
STRRTN:	AOS	(P)		; SKIP RETURN
	POPJ	P,

CHROUT:	SOSG	OBCT		; UPDATE BUFFER POINTER
	JRST	CHR2		; FLUSH OUTPUT BUFFER
CHR1:	IDPB	AC2,OBPTR	; DEPOSIT BYTE
	AOS	(P)
	POPJ	P,
CHR2:	HRLI	AC,15		; .CHOUT= 15
	CHANIO	AC,		; OUTPUT DATA IN BUFFER TO TEMP FILE
	JRST	CHR1		; NORMAL RETURN
	MOVEI	AC,4		; ERROR CODE FOR OUTPUT ERROR
	POPJ	P,		; ERROR RETURN

WAKEUP: MOVE    AC,[IA.REE,,TRPVEC]
        INTADR  AC,
        JFCL
        MOVE    AC,[.IAWAK,,2]
        INTASS  AC,
        JFCL
        HRLZI   AC,(1B0!1B2)
        INTENB  AC,
        JFCL
        POPJ    P,

TRPVEC:	0
	G1234D
        0
        SWAKE
PRGNAM:	BLOCK	6
PTABL:	BLOCK	5
PTBLEN==.-PTABL
FID:	BLOCK	1
FRMHSB:	BLOCK	10
INTERN	FRMHSB
LOGOUT:	XWD	1,3
	SIXBIT	/SYS/
	0
	SIXBIT	/LOGOUT/
OBUF:	0
OBPTR:	0
OBCT:	0
TMPNAM:	BLOCK	4
TMPEXT==TMPNAM+1

	END
  