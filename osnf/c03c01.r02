    	SUBTTL	ISIS Assembly Switch Definitions	- START.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	05;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
	SUBTTL	Engine hardware trace trapping routine
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TRACE.LIB

:	This file provides the necessary backbone for using the TYMNET-ENGINE
:	harware-trace feature.  It should be assembled IMMEDIATELY AFTER the
:	START.LIB file.  The file may be assembled directly from the library
:	version, in which case it is necessary to patch the appropriate test
:	into the assembled code, OR it may be copied and the test hard-coded.

	GL	ENTRY,CRASH	:TWO LIKELY CANDIDATES FOR SYMBOLS REQUIRED

	MO	.,TRACE
	SEG	0		:IN SEGMENT 0
	ORG	10		:AT LOCATION 10
TRPSD	WC	1000,ENTRY	:FORCE A TRANSFER TO "ENTRY"
	WC	TRACE		:ON TRAP, GO TO "TRACE"
TRSAVE	HS	22		:USEFUL AREA TO SAVE REGS, ETC

	SEG	A.CODE		:IN CODE AREA
TRACE	HS	0		:ENTRY TO TRACE LOGIC
	ST	R15,TRSAVE+4	:SAVE A REGISTER
	L	R15,TRPSD+4	:GET ADDRESS WE JUST JUMPED TO
	ST	R15,TRSAVE
	L	R15,TRSAVE+4	:RESTORE REGISTER
	UPSW	TRPSD		:INSTRUCTION TO RE-ENABLE TRACE
	HS	40		:ADDITIONAL AREA TO PATCH IN REQUIRED TEST

:	TRANSFER TO HERE TO TURN ON TRACE INITIALLY
TRBGN	UPSW	IPSD		:THIS WILL TAKE US TO "ENTRY" WITH TRACE ON
IPSD	WC	1000,ENTRY	:TRACE BIT ON, GO TO "ENTRY"
	EM

	SUBTTL	ISIS Ring Handling Routines	- FRING.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
	SUBTTL	Standard Timeout Routine Library	- TIMOUT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TIMOUT.LIB

:	This package contains the standard timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:		R1 = current fast-clock time.
:	TORET	routines called by TIMOUT should exit to here
:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5...R6--R15 preserved
:		R0 = address to transfer to
:		R1 = next time to call routine
:	TOGET	called to delete an entry already on timout list
:		link on R5...R6--R15 preserved
:		R0 = routine address...entry with this address will be deleted
:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5...NO registers preserved! NOW!
:		routine address in R0
:	NOTE...when a routine is called from timeout list, it is removed from list,
:	and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 10		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH,,	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,0F	:FLAG--LINK R5, TYPE 15d CRASH
TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4
	ST	R1,TLIST+6,R4
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
        REMARK  %CRASH.LIB    11-15-84 AWT
	REMARK	%THIS VERSION HAS AN OPTION FOR EXTENDED CRASH PROCESSING.

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME,EXCRSH
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRXREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:	The symbol EXCRSH, if set to 1, allows a JAL to label
:	CRSH.P out of the crash routine for extended crash processing.
:	The link is R5.  EXCRSH is defaulted to 0.
:
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF	\EXCRSH			:DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH	EQ	0
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HS	2		:WHERE CRASH OCCURED
CFROM	HS	2    		:WHERE CRASH WAS CALLED FROM
CRXREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK
	BC	16	:WATCH FROG TIMER - - TIME OUT

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF          :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF          :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2 :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
  IF	CRSTOP
  ELSE
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
  EI	CRSTOP
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1      :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1
        LM      R6,CRAT+CRTLEN/2,R1
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
	EM


        SUBTTL UTIL ... General macros

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 21 NOV 85|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        MO      .,UTIL                  :Delimit module
:
: This module contains the following general purpose macros:
:
:       PUSH - Push the contents of a register on the stack
:       POP - Remove the contents of a register from the stack
:       CALL - Call a subroutine
:       RETURN - Return from a subroutine
:       RSTART - Start a global routine
:       SSTART - Start a local subroutine
:       CRUNCH - Crash the slot
:       TRACK - Track the progress of the slot
:       SUS - Suspend a DCB
:       OPEN - Open output channel
:       WRITEB - Write byte to output channel
:       WRITES - Write string to output channel
:       CLOSE - Close output channel
:       READ - Read input channel
:
        SUBTTL UTIL ... General macro PUSH
:
: ----------------------------------------------------------------------
:
: Macro         PUSH
:
: Description   Push one to eight registers onto to stack
:
: Parameters    RG1 - RG8 Registers to be pushed
:
: ----------------------------------------------------------------------
:
PUSH    MACRO(RG1,RG2,RG3,RG4,RG5,RG6,RG7,RG8) [
        IF 1-\.`RG1                             : Operand given?
        ST      RG1,0,R13                       : Yes, store in stack
        AIS     R13,4                           : Stack increment
        EI
        IF 1-\.`RG2                             
        ST      RG2,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG3                             
        ST      RG3,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG4                             
        ST      RG4,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG5                             
        ST      RG5,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG6                             
        ST      RG6,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG7                             
        ST      RG7,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG8                             
        ST      RG8,0,R13                       
        AIS     R13,4                           
        EI
        IF      TSSTCK
        CI      R13,DSTCKP,R12          :Have we overflowed stack
        JLFS    .+0C                    :Jump if not
        CRUNCH(CRSTOV)                  :Crash stack overflow
        EI
]
        SUBTTL UTIL ... General macro POP
:
: ----------------------------------------------------------------------
:
: Macro         POP
:
: Description   Pop one to eight registers from stack
:
: Parameters    RG1 - RG8 Registers to be popped
:
: ----------------------------------------------------------------------
:
POP     MACRO(RG1,RG2,RG3,RG4,RG5,RG6,RG7,RG8) [
        IF 1-\.`RG1                             : Operand given?
        SIS     R13,4                           : Yes, adjust stack pointer
        L       RG1,0,R13                       : Pull off stack        
        EI
        IF 1-\.`RG2                             
        SIS     R13,4                           
        L       RG2,0,R13                       
        EI
        IF 1-\.`RG3                             
        SIS     R13,4                           
        L       RG3,0,R13                       
        EI
        IF 1-\.`RG4                             
        SIS     R13,4                           
        L       RG4,0,R13                       
        EI
        IF 1-\.`RG5                             
        SIS     R13,4                           
        L       RG5,0,R13                       
        EI
        IF 1-\.`RG6                             
        SIS     R13,4                           
        L       RG6,0,R13                       
        EI
        IF 1-\.`RG7                             
        SIS     R13,4                           
        L       RG7,0,R13                       
        EI
        IF 1-\.`RG8                             
        SIS     R13,4                           
        L       RG8,0,R13                       
        EI
        IF TSSTCK
        CI      R13,DSTCK,R12                   :Has stack underflowed
        JGEFS   .+0C                            :Jump if not
        CRUNCH(CRSTUV)                          :Crash stack underfowed
        EI
]
        SUBTTL UTIL ... General macro CALL
:
: ----------------------------------------------------------------------
:
: Macro         CALL
:
: Description   Call a subroutine using R1 as link register
:
: Parameters    RTNAME - Name of routine to be called
:
: ----------------------------------------------------------------------
:
CALL    MACRO(RTNAME) [
        JAL      R1,RTNAME,,
]


        SUBTTL UTIL ... General macro RETURN
:
: ----------------------------------------------------------------------
:
: Macro         RETURN
:
: Description   Pop link register and return
:
: Parameters    SKIP - If present return link plus 4
:
: ----------------------------------------------------------------------
:
RETURN  MACRO (SKIP) [
        POP(R1)
        IF      1-\.`SKIP
        AIS     R1,4
        EI
        JR      R1
]


        SUBTTL UTIL ... General macros RSTART and SSTART
:
: ----------------------------------------------------------------------
:
: Macro         RSTART
:
: Description   Begin a global routine. Make routine name global and push
:               link register on stack
:
: Parameters    RTNAME - Name of subroutine
:
: ----------------------------------------------------------------------
:
RSTART  MACRO(RTNAME) [
        GL      RTNAME
RTNAME  EQ      .
        PUSH(R1)
        TRACK(RTNAME)
]
:
: ----------------------------------------------------------------------
:
: Macro         SSTART
:
: Description   Begin a local subroutine. Push link register on stack
:
: Parameters    RTNAME - Name of subroutine
:
: ----------------------------------------------------------------------
:
SSTART  MACRO(RTNAME) [
RTNAME  EQ      .
        PUSH(R1)
]

        SUBTTL UTIL ... General macro CRUNCH
:
: ----------------------------------------------------------------------
:
: Macro         CRUNCH 
:
: Description   Crash slot using CRASH routine in CRASH.LIB
:
: Parameters    Y - Crash code
:
: ----------------------------------------------------------------------
:
CRUNCH  MACRO(Y) [
        JAL     R10,CRASH,,
        HC      0
        BC      4*R1,Y
]
:
: List of crash code symbols
:
: 00 - FF Tymnet interface errors
        DEFGEQ(CRIPOM,20)                       :Illegal port 0 message
        DEFGEQ(CRNAR,21)                        :No activation routine in DCB
        DEFGEQ(CRINVN,22)                       :Invalid needle received
        DEFGEQ(CRINVM,23)                       :Invalid message received
        DEFGEQ(CRINVP,24)                       :Invalid pseudo needle
: E0 - EF Internal management errors
        DEFGEQ(CRNOBF,0E0)                      :No buffers left
        DEFGEQ(CROBAA,0E1)                      :Output buffer open twice
        DEFGEQ(CROBNO,0E2)                      :Output buffer not open
        DEFGEQ(CRSTOV,0E3)                      :Stack overflowed
        DEFGEQ(CRSTUV,0E4)                      :Stack underflowed
        DEFGEQ(CRIPBF,0E5)                      :CLOSEI to non-existant port
        DEFGEQ(CRIKEY,0E6)                      :Invalid Icl control key
        DEFGEQ(CRINVD,0E7)                      :Invalid data to INOUT
: F0 - FF Miscellaneous codes for testing
        DEFGEQ(CRNOCO,0F0)                      :Code has not been written yet
        SUBTTL UTIL ... General macro TRACK
:
: ----------------------------------------------------------------------
:
: Macro         TRACK
:
: Description   Track progress of CMT. The address of the track call and
:               the contents of register R12 (normally DCB address) are
:               stored in a circular buffer.
:
: Parameters    ACTID - Identity of routine
:
: ----------------------------------------------------------------------
:
        GL      TRAK,TRAKR1,TRAKBP      :Make variables used by macro global
TRACK   MACRO(ACTID) [
        IF      TSTRAK
        ST      R1,TRAKR1
        JAL     R1,TRAK,,
        L       R1,TRAKR1
        EI
]
:
        SEG     A.DATA
TBSIZ   EQ      200                             :64 entries
TRAKR1  HS      2                               :Save register 1 area
TRAKR2  HS      2                               :Save register 2 area
TRAKBP  WC      0                               :Used to access buffer
        SEG     A.TRAC
TRAKB   BS      TBSIZ                           :Track buffer
        SEG     A.CODE
TRAK    ST      R2,TRAKR2                       :Save register 2
        L       R2,TRAKBP                       :Current buffer position
        ST      R1,TRAKB,R2,                    :Save link address in trace
        ST      R12,TRAKB+4,R2,                 :Save DCB address
        AIS     R2,8                            :Move down buffer
        CI      R2,TBSIZ
        JLFS    TRAK20                          :Jump if wrap not required
        LIS     R2,0
TRAK20  ST      R2,TRAKBP                       :Save new pointer
        L       R2,TRAKR2                       :Restore R2
        JR      R1                              :Return
        SUBTTL UTIL ... General macro SUS
:
: ----------------------------------------------------------------------
:
: Macro         SUS
:
: Description   Suspend a DCB activity. Save suspension type in DSUSP.
:
: Parameters    STYPE - Type of suspension 
:
: ----------------------------------------------------------------------
:
        GL      SUSPND                  :Ensure routine can be accessed
SUS     MACRO(STYPE) [
        PUSH(R1)
        LHI     R1,STYPE
        STH     R1,DSUSP,R12
        JAL     R1,SUSPND,,
        POP(R1)
]
:
: Values for STYPE
:
        DEFGEQ(SUSVD,0)                         :Voluntary dismissal
        DEFGEQ(SUSBP,1)                         :Backpressured
        DEFGEQ(SUSIP,2)                         :Awaiting input
        DEFGEQ(SUSPN,3)                         :Awaiting pseudo needle
        SUBTTL UTIL ... General Input / Output macros
:
: Input / output device types
:
        DEFGEQ(NET,0)
        DEFGEQ(IPBTRM,1)
        DEFGEQ(IPBVID,2)
        DEFGEQ(IPBPTR,3)
:
: ----------------------------------------------------------------------
:
: Macro         READ
:
: Description   Read input. 
:                       NET - READN
:                       IPBTRM - READIA
:                       IPBVID - READIA
:                       IPBPTR - READIB
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
READ    MACRO(TYPE) [
        IF      TYPE-2
        CALL(READIB)
        ELSE
        IF      TYPE
        CALL(READIA)
        ELSE
        CALL(READN)
        EI
        EI
]
:
: ----------------------------------------------------------------------
:
: Macro         OPEN
:
: Description   Open output channel.
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
OPEN    MACRO(TYPE) [
        IF      TYPE 
        CALL(OPENI)
        ELSE
        CALL(OPENN)
        EI
]
:
: ----------------------------------------------------------------------
:
: Macro         WRITEB
:
: Description   Write byte to output channel.
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
WRITEB  MACRO(TYPE) [
        IF      TYPE
        CALL(WRITBI)
        ELSE
        CALL(WRITBN)
        EI
]
:
: ----------------------------------------------------------------------
:
: Macro         WRITES
:
: Description   Write string to output channel.
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
WRITES  MACRO(TYPE) [
        IF      TYPE
        CALL(WRITSI)
        ELSE
        CALL(WRITSN)
        EI
]
:
: ----------------------------------------------------------------------
:
: Macro         CLOSE
:
: Description   Close output channel.
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
CLOSE   MACRO(TYPE) [
        IF      TYPE 
        PUSH(R5)
        LHI     R5,TYPE
        CALL(CLOSEI)
        POP(R5)
        ELSE
        CALL(CLOSEN)
        EI
]
:
        EM


        SUBTTL CBDEF ... Control block definitions and access routines

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 OCT 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        GL      DATACT,ACTCIP           :Forward addressed global
        MO      .,CBDEF
:
: This module contains the definitions of the following  control blocks,
: bit arrays and buffers:
:
:       CCB - channel control block
:       DCB - device control block
:       PORTAB - DCB index table
:       SCB - screen image buffer
:       IOB - I/O buffer
:       RUNREQ - Run DCB process request array
:       ASCICL - ASCII to ICL translaaation table
:       ICLASC - ICL to ASCII translaaation table
:
: It also contains the following routines to initialise and access them:
:
:       IZCMT - Initialise control blocks and buffers
:       GETDCB - Get a DCB from free chain
:       GETCCB - Get a CCB from free chain
:       GETSCB - Get a screen buffer from free chain
:       GETIOB - Get a IO buffer from the free chain
:       PUTDCB  - Return a DCB to free chain
:       PUTCCB  - Return a CCB to free chain
:       PUTSCB - Return a screen buffer to free chain
:       PUTIOB - Return IO buffer to free chain
:       RETBUF - Return all buffers to free chain
:
: There are no macros unique to this module.
:
: ----------------------------------------------------------------------
:
: Macro         CBHDEF
:
: Description   Create HW entries in control blocks and global the entries
:
: Parameters    SYM - Name of entry
:               HL - Size of entry in halfwords
:
CBHDEF  MACRO(SYM,HL) [
        GL      SYM                             :Make symbol global
SYM     HS      HL
]
:
: ----------------------------------------------------------------------
:
: Macro         CBBDEF
:
: Description   Create BS entries in control blocks and global the entries
:
: Parameters    SYM1 - Name of entry
:               BL - Size of entry in bytes
:
CBBDEF  MACRO(SYM1,BL) [
        GL      SYM1                    :Make symbol global
SYM1    BS      BL
]
:
: Reset the origin and save old one so that all references are from zero
:
        SEG     0
OLDORG  EQ      .                       :Save origin
:
:       The device control block
:
: The DCB contains information related to an ISI port. At initialisation
: time a DCB is allocated to every possible port number indexed by
: PORTAB. When a needle is received on a port, it's DCB is then linked
: to channel control block.
:
        ORG     0
        CBHDEF(DDCB,0)                  :Start of DCB
        CBHDEF(DDACT,1)                 :Data activation routine address
        CBHDEF(DCACT,1)                 :Control activation table address
        CBHDEF(DCBNO,1)                 :DCB number
        CBHDEF(DPORT,1)                 :Port number
        CBHDEF(DTYPE,1)                 :DCB type
        CBHDEF(DCCB,2)                  :Link to CCB
        CBHDEF(DUSR,2)                  :User routine address
        CBHDEF(DSUSP,1)                 :Reason DCB suspended
        CBHDEF(DNETIP,4)                :Network input buffer pointers
        CBHDEF(DNETOP,4)                :Network output buffer pointers
        CBHDEF(DIPBIA,4)                :IPB input buffer A pointers
        CBHDEF(DIPBIB,4)                :IPB input buffer B pointers
        CBHDEF(DIPBOP,4)                :IPB output buffer pointers
        CBHDEF(DXLIM,1)                 :Transmit limit
        CBHDEF(DRXCNT,1)                :Receive count
        CBHDEF(DSCNBF,2)                :Screen buffer pointer
        CBHDEF(DMODE,1)                 :Current mode of operation
        CBHDEF(DLINE,1)                 :ICL HIF line address
        CBHDEF(DGROUP,1)                :ICL HIF group address
        CBHDEF(DSUBSD,1)                :ICL HIF subsiduary address
        CBHDEF(DBITS,1)                 :Control bits
        CBHDEF(DSTCK,60)                :Stack
        CBHDEF(DSTCKP,2)                :Stack pointer
        CBHDEF(DCBSIZ,0)                :Size of DCB
:
: Tell FRNTND where activation pointers are
:
        DEFGEQ(ACTIVD,DDACT)            :Data activation routine offset
        DEFGEQ(ACTIVC,DCACT)            :Control activation table offset
:
: DTYPE entry values
:
        DEFGEQ(DTFREE,0)                :Inactive port
        DEFGEQ(DTTERM,1)                :Terminal port
        DEFGEQ(DTHVID,2)                :Host video port
        DEFGEQ(DTHPRT,3)                :Host printer port
:
: DMODE entry values
:
        DEFGEQ(DMINAC,0)                :Inactive port
        DEFGEQ(DMLGST,1)                :Terminal logon start code
        DEFGEQ(DMTTYP,2)                :Determining terminal type
        DEFGEQ(DMTICL,3)                :Terminal in ICL mode
:
: Control bits in DBITS 
:
        DEFGEQ(D.PRT,1)                 :Set if this DCB is for printer
        DEFGEQ(D.ECHO,2)                :Set if Consat echoing chars
        DEFGEQ(D.WDEM,3)                :Set if waiting for DEM
        DEFGEQ(D.DEM,4)                 :Set if in DEM
        DEFGEQ(D.GB,5)                  :Set if green ball outstanding
	DEFGEQ(D.TOKN,6)		:Set if input inhibited for PRTDCB
        DEFGEQ(D.OUTN,8)                :Set if network output 'OPEN'
        DEFGEQ(D.OUTI,9)                :Set if IPB output 'OPEN'
:
:       The channel control block
:
: The CCB is the basic control block of the CMT. It is created when a
: user logs into CMT and links together all the resources required to
: service that user.
:
        ORG     0
        CBHDEF(CLINK,2)                 :Link to free CCB chain
        CBHDEF(CTDCB,2)                 :Link to terminal DCB
        CBHDEF(CHDCB,2)                 :Link to host DCB
        CBHDEF(CPDCB,2)                 :Link to printer DCB
        CBHDEF(CTPROF,2)                :Pointer to terminal profile table
        CBHDEF(CUPROF,2)                :Pointer to user profile table
        CBHDEF(CSCNBF,2)                :Pointer to screen buffer
        CBHDEF(CBITS,2)                 :Control bits
	DEFGEQ(UPFULN,20)		:32 character username
        CBBDEF(CUNAME,UPFULN)           :First N bytes of terminal username
        CBHDEF(CLSTRS,1)                :Login entry offset in LSTRS
:
        CBHDEF(CVSTAT,1)                :Video status
        CBHDEF(CVQUAL,2)                :Continuation address for ALP code
        CBHDEF(CVSTRT,1)                :Current screen start position
        CBHDEF(CVEND,1)                 :Current screen end position
        CBHDEF(CVOSOM,1)                :Old SOM position
        CBHDEF(CVATTR,1)                :Current terminal attribute
        CBHDEF(CVBCNT,1)                :Badge data count
        CBHDEF(CVBDAT,7)                :Badge data
:
        CBHDEF(CPSTAT,1)                :Printer status
        CBHDEF(CPQUAL,2)                :Continuation address for ALP code
        CBHDEF(CPCOL,1)                 :Current column on line
        CBHDEF(CPLINE,1)                :Current line on form
        CBHDEF(CPFORM,1)                :Current form length
        CBHDEF(CCBSIZ,0)                :Size of CCB
:
: Control bits in CBITS
:
        DEFGEQ(C.HELP,0)                :Set if HELP screen being displayed
        DEFGEQ(C.ACTN,1)                :Set if action key qualifier awaited
        DEFGEQ(C.VQUA,2)                :Set if video ALP qualifier required
        DEFGEQ(C.PQUA,3)                :Set if printer ALP qualifier required
        DEFGEQ(C.VALP,4)                :Set if processing video data ALP 
        DEFGEQ(C.PALP,5)                :Set if processing printer data ALP
        DEFGEQ(C.PDSR,6)                :Set if waiting response to DSR
        DEFGEQ(C.PAUT,7)                :Set if printer in AUTO mode
        DEFGEQ(C.PTRM,8)                :Set if printer in TERMINAL HOLD mode
        DEFGEQ(C.PDAT,9)                :Set if printer ALP awaiting processing
        DEFGEQ(C.PSCR,0A)               :Set if screen print request o/s
        DEFGEQ(C.STAT,0D)               :Set if status indicator not displayed
        DEFGEQ(C.S24,0E)                :Set if 24 line screen
:
        DEFGEQ(C.BADG,10)               :Set if badge data required
        DEFGEQ(C.NCLR,11)               :Set if clear screen inhibited by CMT
        DEFGEQ(C.NSOM,12)               :Set if SOM movement inhibited by host
        DEFGEQ(C.ER24,13)               :Set if validation errors on line 24
        DEFGEQ(C.FSND,14)               :Set if force invalid fields allowed
        DEFGEQ(C.NSPC,15)               :Set if alternate space fill used
        DEFGEQ(C.NVAL,16)               :Set if screen validation inhibited 
        DEFGEQ(C.COMP,17)               :Set if compression allowed on input
        DEFGEQ(C.SLGN,18)               :Set if HIF is connected to M/F
	DEFGEQ(C.MFLG,19)		:Set when sending a logon message
:
: Values for CVSTAT, video status flag
:
        DEFGEQ(VS.TYP,0)                :Type status
        DEFGEQ(VS.SND,1)                :Send status
        DEFGEQ(VS.RX,2)                 :Receive status
        DEFGEQ(VS.LCA,3)                :Local A status (output)
        DEFGEQ(VS.LCB,4)                :Local B status (input)
:
: Bit settings in CPSTAT, printer status flag
:
        DEFGEQ(PS.ALL,1)                :Set if printer allocated
        DEFGEQ(PS.IOP,2)                :Set if printer inoperable
        DEFGEQ(PS.HLD,3)                :Set if printer on hold
        DEFGEQ(PS.WDA,4)                :Set if printer waiting de-allocation
        DEFGEQ(PS.CT1,5)                :Set if status to be sent at category 1
        DEFGEQ(PS.ROC,6)                :Set if report output complete awaited
: The following bits map onto bits 1 - 6 of the status report byte
        DEFGEQ(PS.ERR,0A)               :Data lost if set
        DEFGEQ(PS.WRN,0B)               :Warning if set
        DEFGEQ(PS.BNA,0E)               :Buffer not available if set
        DEFGEQ(PS.NOP,0F)               :Set if printer not operable
:
:       The screen image block
:
: This block contains an ICL screen image together with any information
: required to output that image to the users terminal
:
        ORG     0
        CBHDEF(SCNLNK,2)                :Link to chain of free buffers
        CBHDEF(SCURSR,1)                :Cursor position
        CBHDEF(SCATTR,1)                :Attribute of character at cursor
        CBHDEF(SSOM,1)                  :Start of message position
        CBHDEF(SSATTR,1)                :Attribute of character at SOM
        CBHDEF(SFLDS,1)                 :Count of fields on screen
        CBHDEF(SOUTFL,1)                :Output type flag
        CBHDEF(SRACKS,1)                :Rack up line count
        CBHDEF(SFSTAT,1)                :Final video state
        CBHDEF(SBITS,1)                 :Control bits
        CBHDEF(SCNBUF,SCRSIZ/2)         :Screen image
        CBHDEF(SCBSIZ,0)                :Size of screen buffer
:
: Start of field and attribute character masks
:
: Format of character is as follows:
:       Bit 0 Start of field marker
:       Bit 1 Set if field protected
:       Bit 2 Set if field flashing
:       Bits 3 - 7 Validation code
:
        DEFGEQ(ATMPRO,0C0)              :Mask out protected bits (FST & PRO)
        DEFGEQ(ATMFST,80)               :Mask out start of field bit
        DEFGEQ(ATMNFS,7F)               :Remove field start bit
        DEFGEQ(ATMPRF,40)               :Mask out protected field
        DEFGEQ(ATMFLH,20)               :Mask out flashing field
        DEFGEQ(ATMVAL,1F)               :Mask out validation code
        DEFGEQ(ATMREV,100)              :Mask out reverse field 
:
: Flag settings in SBITS
:
        DEFGEQ(S.BELL,1)                :Ring bell when screen displayed
        DEFGEQ(S.CLRS,2)                :Clear screen occurred
        DEFGEQ(S.QUAL,3)                :ALPCHR awaiting qualifier
        DEFGEQ(S.OPTR,12)               :Flag rack ups to OUTSCR
:
:       The I/O block
: This is the basic input/output block used to buffer data to and from
: a DCB activity
:
        ORG     0
        CBHDEF(BLINK,2)                 :Link to chain of free buffers
        CBBDEF(BFILL,1)                 :Fill offset
        CBBDEF(BEMPTY,1)                :Empty offset
        CBBDEF(BDATA,9D)                :Space for data 
        CBHDEF(BSIZE,0)                 :Size of I/O buffer
:
:       The User Profile Table
:
: A list of valid users of the system, the number of the menu of logons
: for this user and the terminal type. Table is based at UPFLST.
:
        ORG     0
        CBBDEF(UPFUSR,UPFULN)           :N character username
        CBHDEF(UPFMNU,1)                :Menu number for this user
        CBHDEF(UPFTTY,1)                :Terminal type for this user
        CBHDEF(UPFSIZ,0)                :Size of UPF table
 :
: Restore origin
:
        ORG     OLDORG
        SEG     A.DATA
:
: Define bit map control arrays
:
        DEFGEQ(BMAPSZ,((MAXPRT/10)+1)*2) :Bit map arrays are BMAPSZ HW size
:
: Array RUNREQ - DCB waiting to be run.
:
        CBHDEF(RUNREQ,BMAPSZ/2)
:
: Pointers to access control blocks
:
        DEFGEQ(PORTAB,.)
        WS      NPORT                   :Pointer to DCBs required by FRNTND
FREDCB  WS      4                       :Head of free CCB chain
FRECCB  WS      4                       :Head of free CCB chain
FRESCB  WS      4                       :Head of free screen buffer chain
FREIOB  WS      4                       :Head of free I/O buffer chain
: Layout of head of chain
        DEFGEQ(CHNFWD,0)                :Forward pointer in chains
        DEFGEQ(CHNBWD,CHNFWD+4)         :Backward pointer in chains
CHNCNT  EQ      CHNBWD+4                :Free count
CHNMIN  EQ      CHNCNT+2                :Minimum count
        SEG     A.CBLKS
        CBBDEF(DCBLKS,DCBSIZ*NPORT)     :Storage area for DCBs
CCBLKS  BS      CCBSIZ*NCCB             :Storage area for CCBs
SCBLKS  BS      SCBSIZ*NSCB             :Storage area for screen buffers
IOBLKS  BS      BSIZE*NIOB              :Storage area for I/O buffers
:
: ASCII to ICL code translation table. This can be modified by the user
: macro CHRMAP.
:
        SEG     A.DATA
        DEFGEQ(ASCICL,.)
        BC      00,01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F
        BC      10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F
        BC      20,21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F
        BC      30,31,32,33,34,35,36,37,38,39,3A,3B,3C,3D,3E,3F
        BC      40,41,42,43,44,45,46,47,48,49,4A,4B,4C,4D,4E,4F
        BC      50,51,52,53,54,55,56,57,58,59,5A,5B,5C,5D,5E,5F
        BC      60,61,62,63,64,65,66,67,68,69,6A,6B,6C,6D,6E,6F
        BC      70,71,72,73,74,75,76,77,78,79,7A,7B,7C,7D,7E,7F
:
: ICL to ASCII code translation table. This can be modified by the user
: macro CHRMAP.
:
        SEG     A.DATA
        DEFGEQ(ICLASC,.)
        BC      00,01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F
        BC      10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F
        BC      20,21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F
        BC      30,31,32,33,34,35,36,37,38,39,3A,3B,3C,3D,3E,3F
        BC      40,41,42,43,44,45,46,47,48,49,4A,4B,4C,4D,4E,4F
        BC      50,51,52,53,54,55,56,57,58,59,5A,5B,5C,5D,5E,5F
        BC      60,61,62,63,64,65,66,67,68,69,6A,6B,6C,6D,6E,6F
        BC      70,71,72,73,74,75,76,77,78,79,7A,7B,7C,7D,7E,7F

: ASCII to TERMINAL translation table. This can be modified by rhe user
: macro CHRMAP.
:
	SEG	A.DATA
	DEFGEQ(ASCTRM,.)
	BC	00,01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F
	BC	10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F
	BC	20,21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F
	BC	30,31,32,33,34,35,36,37,38,39,3A,3B,3C,3D,3E,3F
	BC	40,41,42,43,44,45,46,47,48,49,4A,4B,4C,4D,4E,4F
	BC	50,51,52,53,54,55,56,57,58,59,5A,5B,5C,5D,5E,5F
	BC	60,61,62,63,64,65,66,67,68,69,6A,6B,6C,6D,6E,6F
	BC	70,71,72,73,74,75,76,77,78,79,7A,7B,7C,7D,7E,7F
	BC	80,81,82,83,84,85,86,87,88,89,8A,8B,8C,8D,8E,8F
	BC	90,91,92,93,94,95,96,97,98,99,9A,9B,9C,9D,9E,9F
	BC	0A0,0A1,0A2,0A3,0A4,0A5,0A6,0A7,0A8,0A9,0AA,0AB,0AC,0AD,0AE,0AF
	BC	0B0,0B1,0B2,0B3,0B4,0B5,0B6,0B7,0B8,0B9,0BA,0BB,0BC,0BD,0BE,0BF
	BC	0C0,0C1,0C2,0C3,0C4,0C5,0C6,0C7,0C8,0C9,0CA,0CB,0CC,0CD,0CE,0CF
	BC	0D0,0D1,0D2,0D3,0D4,0D5,0D6,0D7,0D8,0D9,0DA,0DB,0DC,0DD,0DE,0DF
	BC	0E0,0E1,0E2,0E3,0E4,0E5,0E6,0E7,0E8,0E9,0EA,0EB,0EC,0ED,0EE,0EF
	BC	0F0,0F1,0F2,0F3,0F4,0F5,0F6,0F7,0F8,0F9,0FA,0FB,0FC,0FD,0FE,0FF

: TERMINAL  to  ASCII translation table. This can be modified by the user
: macro CHRMAP.

	SEG	A.DATA
	DEFGEQ(TRMASC,.)

	BC	00,01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F
	BC	10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F
	BC	20,21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F
	BC	30,31,32,33,34,35,36,37,38,39,3A,3B,3C,3D,3E,3F
	BC	40,41,42,43,44,45,46,47,48,49,4A,4B,4C,4D,4E,4F
	BC	50,51,52,53,54,55,56,57,58,59,5A,5B,5C,5D,5E,5F
	BC	60,61,62,63,64,65,66,67,68,69,6A,6B,6C,6D,6E,6F
	BC	70,71,72,73,74,75,76,77,78,79,7A,7B,7C,7D,7E,7F
	BC	80,81,82,83,84,85,86,87,88,89,8A,8B,8C,8D,8E,8F
	BC	90,91,92,93,94,95,96,97,98,99,9A,9B,9C,9D,9E,9F
	BC	0A0,0A1,0A2,0A3,0A4,0A5,0A6,0A7,0A8,0A9,0AA,0AB,0AC,0AD,0AE,0AF
	BC	0B0,0B1,0B2,0B3,0B4,0B5,0B6,0B7,0B8,0B9,0BA,0BB,0BC,0BD,0BE,0BF
	BC	0C0,0C1,0C2,0C3,0C4,0C5,0C6,0C7,0C8,0C9,0CA,0CB,0CC,0CD,0CE,0CF
	BC	0D0,0D1,0D2,0D3,0D4,0D5,0D6,0D7,0D8,0D9,0DA,0DB,0DC,0DD,0DE,0DF
	BC	0E0,0E1,0E2,0E3,0E4,0E5,0E6,0E7,0E8,0E9,0EA,0EB,0EC,0ED,0EE,0EF
	BC	0F0,0F1,0F2,0F3,0F4,0F5,0F6,0F7,0F8,0F9,0FA,0FB,0FC,0FD,0FE,0FF

        SUBTTL IZCMT routine ... Initialise control blocks
:
: Routine name  IZCMT
:
: Function      To set up PORTAB the DCB addressing table used by FRNTND.
:               Also initialises the DCB for inactive ports and creates
:               the free CCB, I/O and screen buffer chains
:
: Called by     EXEC
:
: On entry      Link register R1
:
: On exit       Registers are not preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SEG     A.CODE
:
: Initialise PORTAB and DCBs
:
        DEFGEQ(IZCMT,.)
        LA      R12,DCBLKS,,                    :Create inactive DCB
        LIS     R14,0
        STH     R14,DPORT,R12                   :Put port no. in DCB
        STH     R14,DCBNO,R12                   :DCB number 0
        LIS     R7,DTFREE
        STH     R7,DTYPE,R12                    :Make DCB type inactive
        LA      R7,DATACT
        STH     R7,DDACT,R12                    :Set data activation offset
        LA      R7,ACTCIP                       :Set control activation offset
        STH     R7,DCACT,R12                    : for inactive port
        LHI     R10,DMINAC                      :Set DMODE to inactive
        STH     R10,DMODE,R12
        LA      R10,DSTCK,R12
        ST      R10,DSTCKP,R12                  :Initialise stack
        LIS     R15,0                           :Offset to PORTAB entry
IZDCB   ST      R12,PORTAB,R15                  :Allocate a DCB to a port
        AIS     R15,4                           :Next PORTAB entry
        AIS     R14,1
        CHI     R14,NPORT+1
        JNBS    IZDCB                           :More entries to set up
        AI      R12,DCBSIZ                      :Next DCB
        LR      R11,R12
:
: Initialise DCB free chain
:
        LA      R12,FREDCB                      :Head of free DCB chain
        LHI     R15,NPORT-1                     :No. of DCB's
        STH     R15,CHNCNT,R12                  :Count of free buffers
        STH     R15,CHNMIN,R12                  :Count of minimum buffers
        LIS     R15,1
IZDC20  ST      R11,CHNFWD,R12                  :Point to next block in chain
        LR      R12,R11                         :Move forward
        AI      R11,DCBSIZ      
        STH     R15,DCBNO,R12                   :Put in DCB number
        AIS     R15,1
        CHI     R15,NPORT
        JNBS    IZDC20                          :Jump if not last DCB
        LA      R11,FREDCB                      :Point to head of chain
        ST      R11,CHNFWD,R12                  :Last DCB points to FREDCB
        ST      R12,CHNBWD,R11                  :Point to end of chain
:
: Initialise CCB free chain
:
IZCCB   LHI     R15,NCCB                        :No. of ccb's
        LA      R12,FRECCB                      :Head of free CCB chain
        STH     R15,CHNCNT,R12                  :Count of free buffers
        STH     R15,CHNMIN,R12                  :Count of minimum buffers
        LA      R11,CCBLKS,,                    :Start of CCB area
IZCC20  ST      R11,CHNFWD,R12                  :Point to next block in chain
        LR      R12,R11                         :Move forward
        AI      R11,CCBSIZ      
        SIS     R15,1
        JNBS    IZCC20                          :Jump if not last CCB
        LA      R11,FRECCB                      :Point to head of chain
        ST      R11,CHNFWD,R12                  :Last CCB points to FRECCB
        ST      R12,CHNBWD,R11                  :Point to end of chain
:
: Initialise screen buffer free chain
:
IZSCB   LHI     R15,NSCB                        :No. of screen buffers
        LA      R12,FRESCB                      :Head of screen buffer chain
        STH     R15,CHNCNT,R12                  :Count of free buffers
        STH     R15,CHNMIN,R12                  :Count of minimum buffers
        LA      R11,SCBLKS,,                    :Start of screen buffers
IZSC20  ST      R11,CHNFWD,R12                  :Point to next block in chain
        LR      R12,R11                         :Move forward
        AI      R11,SCBSIZ      
        SIS     R15,1
        JNBS    IZSC20                          :Jump if not last SCB
        LA      R11,FRESCB                      :Point to head of chain
        ST      R11,CHNFWD,R12                  :Point back to start
        ST      R12,CHNBWD,R11                  :Point to last entry
:
: Initialise I/O buffer free chain
:
IZIOB   LHI     R15,NIOB                        :No. of I/O buffers
        LA      R12,FREIOB                      :Head of I/O buffer chain
        STH     R15,CHNCNT,R12                  :Count of free buffers
        STH     R15,CHNMIN,R12                  :Count of minimum buffers
        LA      R11,IOBLKS,,                    :Start of I/O buffers
IZIO20  ST      R11,CHNFWD,R12                  :Point to next block in chain
        LR      R12,R11                         :Move forward
        AI      R11,BSIZE       
        SIS     R15,1
        JNBS    IZIO20                          :Jump if not last IOB
        LA      R11,FREIOB                      :Point to head of chain
        ST      R11,CHNFWD,R12                  :Point back to start
        ST      R12,CHNBWD,R11                  :Point to last entry
:
: Initialise run request bit array
:
        LHI     R12,BMAPSZ-2                    :Size of hw entries
        LIS     R11,0
IZBA20  STH     R11,RUNREQ,R12                  :Set all bits to zero
        SIS     R12,2                           :Next hw
        JGEBS   IZBA20                          :J if not complete
        JR      R1                              :Return to caller
        SUBTTL GETBUF routine ... Get a buffer from free chain
:
: Routine name  DCBGET, GETCCB, GETSCB, GETIOB
:
: Function      Get a DCB, CCB, screen or I/O buffer from a free chain.
:               DCBGET rather than GETDCB because GETDCB is a macro used
:               in FRNTND!!
:
: Called by     
:
: On entry      R12 current DCB address
:               Link register R1
:
: On exit       R5 points to buffer. 
:
: Uses          
:
: ---------------------------------------------------------------------
:
: Get a DCB from free chain
:
        RSTART(DCBGET)
        LA      R1,FREDCB,,             :Point to DCB free chain
        J       GETBUF                  :Extract a buffer
:
: Get a CCB from free chain
:
        RSTART(GETCCB)
        LA      R1,FRECCB,,             :Point to CCB free chain
        J       GETBUF                  :Extract a buffer
:
: Get a screen buffer from free chain
:
        RSTART(GETSCB)
        LA      R1,FRESCB,,             :Point to SCB free chain
        J       GETBUF                  :Extract a buffer
:
: Get a I/O buffer from free chain
:
        RSTART(GETIOB)
        LA      R1,FREIOB,,             :Point to IOB free chain
:
: Common buffer accessing code
:
GETBUF  PUSH(R2)
        LHL     R5,CHNCNT,R1            :Count of buffers on chain
        JE      GETB90                  :Jump if not empty
        SIS     R5,1                    :Decrement free count
        STH     R5,CHNCNT,R1
        CLH     R5,CHNMIN,R1
        JGFS    GETB40                  :Jump if not new minimum
        STH     R5,CHNMIN,R1            :Save new minimum
GETB40  L       R5,CHNFWD,R1            :Next free block
        L       R2,CHNFWD,R5            :Following block ....
        ST      R2,CHNFWD,R1            :     becomes first in free chain
        C       R5,CHNBWD,R1
        JNFS    GETB60                  :If there are no blocks left
        ST      R1,CHNBWD,R1            :Backward ptr to head of chain
GETB60  POP(R2)
        RETURN
GETB90  CRUNCH(CRNOBF)                  :Crash no buffers
        SUBTTL PUTBUF routine ... Put a buffer on a free chain
:
: Routine name  PUTDCB, PUTCCB, PUTSCB, PUTIOB
:
: Function      Put a DCB, CCB, screen or I/O buffer on a free chain
:
: Called by     
:
: On entry      R12 current DCB address
:               R5 Buffer address
:               Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
: Put a DCB on a free chain
:
        RSTART(PUTDCB)
	LIS	R1,0
	STH	R1,DTYPE,R5		:Flag as inactive
        LA      R1,FREDCB,,             :Point to DCB free chain
        J       PUTBUF                  :Extract a buffer
:
: Put a CCB on a free chain
:
        RSTART(PUTCCB)
        LA      R1,FRECCB,,             :Point to CCB free chain
        J       PUTBUF                  :Extract a buffer
:
: Put a screen buffer on a free chain
:
        RSTART(PUTSCB)
        LA      R1,FRESCB,,             :Point to SCB free chain
        J       PUTBUF                  :Extract a buffer
:
: Put a I/O buffer on a free chain
:
        RSTART(PUTIOB)
        LA      R1,FREIOB,,             :Point to IOB free chain
:
: Common buffer accessing code
:
PUTBUF  PUSH(R2)
        LHL     R2,CHNCNT,R1            :Count of buffers on chain
        AIS     R2,1                    :Increment free count
        STH     R2,CHNCNT,R1
        L       R2,CHNBWD,R1            :Last block on chain
        ST      R5,CHNBWD,R1            :New block becomes last
        ST      R5,CHNFWD,R2            :Point old last on to new
        ST      R1,CHNFWD,R5            :Point new last to head
        POP(R2)
        RETURN
        SUBTTL RETBUF routine ... Put all buffers on a free chain
:
: Routine name  RETBUF
:
: Function      Return all buffers attached to a DCB to the free chains.
:
: Called by     
:
: On entry      R12 current DCB address
:               Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(RETBUF)
        PUSH(R5,R6,R7)
        LA      R6,DIPBIA,R12           :Return IPB input buffers
        L       R5,CHNFWD,R6
RETB10  CR      R5,R6
        JE      RETB20
        L       R7,CHNFWD,R5
        CALL(PUTIOB)
        LR      R5,R7
        J       RETB10
RETB20  ST      R6,CHNFWD,R6            :Mark chain as empty
        ST      R6,CHNBWD,R6
        LA      R6,DIPBIB,R12           :Return IPB input buffers
        L       R5,CHNFWD,R6
RETB30  CR      R5,R6
        JE      RETB40
        L       R7,CHNFWD,R5
        CALL(PUTIOB)
        LR      R5,R7
        J       RETB30
RETB40  ST      R6,CHNFWD,R6            :Mark chain as empty
        ST      R6,CHNBWD,R6
        LA      R6,DIPBOP,R12           :Return IPB output buffers
        L       R5,CHNFWD,R6
RETB50  CR      R5,R6
        JE      RETB60
        L       R7,CHNFWD,R5
        CALL(PUTIOB)
        LR      R5,R7
        J       RETB50
RETB60  ST      R6,CHNFWD,R6            :Mark chain as empty
        ST      R6,CHNBWD,R6
	LHI	R6,D.OUTI
	RBT	R6,DBITS,R12
        LA      R6,DNETOP,R12           :Return net output buffers
        L       R5,CHNFWD,R6
RETB70  CR      R5,R6
        JE      RETB80
        L       R7,CHNFWD,R5
        CALL(PUTIOB)
        LR      R5,R7
        J       RETB70
RETB80  ST      R6,CHNFWD,R6            :Mark chain as empty
        ST      R6,CHNBWD,R6
        LHI     R1,D.OUTN
        RBT     R1,DBITS,R12            :Ensure net output marked as closed
        L       R5,DSCNBF,R12
        JE      RETB90                  :J if no screen buffers
        CALL(PUTSCB)
        LIS     R5,0
        ST      R5,DSCNBF,R12           :Mark that there is no buffer
RETB90  POP(R7,R6,R5)
        RETURN
:
        EM


        SUBTTL UPF ... USER PROFILE TABLES

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 25 JUL 85|  ORIGIN                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :SEGMENT TO CONTAIN THIS MODULE
:       MO      .,UPF                   :DELIMIT MODULE
:
: THIS MODULE CONTAINS ROUTINES TO CREATE THE USER PROFILE AND
: ASSOCIATED TABLES. IT ALSO CONTAINS ROUTINES TO ACCESS THESE TABLES.
:
:       FNDUPF - FIND ADDRESS OF USER PROFILE TABLE
:
: THERE ARE NO MACROS DEFINED IN THIS MODULE.
        SUBTTL FNDUPF ROUTINE ...FIND USER PROFILE TABLE ADDRESS
:
: ROUTINE NAME  FNDUPF
:
: FUNCTION      FIND THE ADDRESS OF THE APPROPRIATE USER PROFILE
:               TABLE ENTRY
:
: CALLED BY     ACTIVN IN CMTI
:
: ON ENTRY      N CHARACTER USERNAME MUST BE AT CUNAME IN CCB
:               LINK REGISTER R1
:
: ON EXIT       R5 CONTAINS ADDRESS OF ENTRY OR ZERO IF NOT EXIST.
:               ALL REGISTERS WILL HAVE BEEN PRESERVED
:
: USES          
:
: ---------------------------------------------------------------------
:
: THIS CODE IS COPIED ALMOST (BUT NOT QUITE) VERBATIM FROM CMT/3270
:
        RSTART(FNDUPF)
        PUSH(R9,R8,R0)                  :SAVE REGISTERS
        LHI     R1,NUMUNM               :NO OF USER NAMES
        LA      R9,UPFLST
FNDU10	LI	R8,0
	SI      R8,UPFULN               :CHARACTERS PER USERNAME
FNDU20  LB      R0,UPFUSR+UPFULN,R9,R8  :CHARACTER FROM USERNAME LIST
        THI     R0,80
        JEFS    FNDU30                  :JUMP IF THIS IS WILD CARD
        CLB     R0,CUNAME+UPFULN,R11,R8 :MATCH WITH LOGON USERNAME
        JNFS    FNDU40                  :JUMP IF NO MATCH
FNDU30  AIS     R8,1                    :NEXT CHARACTER OF USERNAME
        JLBS    FNDU20                  :JUMP IF THERE ARE MORE
        LR      R5,R9                   :ADDRESS OF USER PROFILE ENTRY
        J       FNDU80                  :RETURN WE HAVE FOUND A MATCH
:
FNDU40  AHI     R9,UPFSIZ               :NEXT ENTRY IN USERNAME LIST
        SIS     R1,1
        JN      FNDU10                  :JUMP IF NOT AT END
        LIS     R5,0                    :USER NOT SUPPORTED
:
FNDU80  POP(R0,R8,R9)                   :RESTORE REGISTERS
        RETURN
        SUBTTL USER PROFILE AND LOGON TABLE CREATION
:
: FUNCTION      THIS SECTION CONTAINS THE CODE WHICH GENERATES THE USER
:               PROFILE TABLES:
:               
:               UPFLST - USER PROFILE LIST
:               MENU - MENU LIST
:               MSTRS - LIST OF LOGON STRINGS FOR MENUS
:               LSTRS - LOGON STRING LIST
:               STRLST - LIST OF ELEMENTS IN LOGON STRINGS
:               ELEADR - ELEMENT ADDRESS IN SEG A.ELE
:               STRLAB - MENU ENTRY LABELS
:
: ---------------------------------------------------------------------
:
:
	DEFGEQ(NUMUNM,UN)                   :NUMBER OF USERNAMES
:
: PLACE ELEMENTS IN MEMORY. REFERENCED FROM ELEADR
:
        SEG     A.ELE
ELENO   EQ      0
        RE      EN
        DLE|ELENO|
ELENO   EQ      ELENO+1
        ER
:
: PLACE LABELS FOR LOGON ENTRIES FOR MENU IN MEMORY. REFERENCED FROM LSTRS
:
        CBHDEF(STRLAB,0)
LSTRNO  EQ      0
        RE      SN
        LBL|LSTRNO|
Q       EQ      1
        RE      5
        IF      SL|LSTRNO|N|Q|+1
Q       EQ      Q+1
        EI
        ER
CE|LSTRNO| EQ   Q-1
LSTRNO  EQ      LSTRNO+1
        ER
:
: CONSTRUCT LSTRS.
:       LSTRS IS INDEXED BY THE LOGON STRING NUMBER. IT HAS
:       THREE HALFWORDS PER ENTRY
:
:       1 BYTE COUNT OF ELEMENTS IN LOGIN STRING
:       HW INDEX INTO STRLST OF FIRST ELEMENT
:       HW ADDRESS OF LABEL STRING (RELATIVE TO STRLAB)
:
        SEG     0
        CBHDEF(LSTRS,0)
LSTRNO  EQ      0
        RE      SN
        BC      CE|LSTRNO|
        BC      0
        HC      STLS|LSTRNO|
        HC      L|LSTRNO|-STRLAB
LSTRNO  EQ      LSTRNO+1
        ER
:
: CONSTRUCT STRLST
:       STRLST IS A LIST OF ELEMENT NUMBERS IN ORDER. EACH ENTRY
:       IS A VARIABLE NUMBER OF HALFWORDS.  EACH HALFWORD IS AN ELEMENT
:       NUMBER, REFERENCED FROM LSTRS

:  
        CBHDEF(STRLST,0)
LSTRNO  EQ      0
        RE      SN
QX      HS      0
STLS|LSTRNO| EQ QX-STRLST
Q       EQ      1
        RE      CE|LSTRNO|
        HC      SL|LSTRNO|N|Q|
Q       EQ      Q+1
        ER
LSTRNO  EQ      LSTRNO+1
        ER
:
: CONSTRUCT MSTRS
:       MSTRS IS A LIST OF LOGON STRING NUMBERS FOR EACH MENU
:       THE SIZE OF AN ENTRY IS A VARIABLE NUMBER OF HALFWORDS.
:       REFERENCED FROM MENUS
:
        CBHDEF(MSTRS,0)
MENUQ   EQ      0
        RE      MN
MI|MENUQ| HS    0
Q       EQ      0
        RE      PM|MENUQ|
        HC      PU|MENUQ|N|Q|*6
Q       EQ      Q+1
        ER
MENUQ   EQ      MENUQ+1
        ER
:
: CONSTRUCT MENUS
:       MENUS IS AN INDEX TO THE LOGON STRING ENTRIES FOR A MENU AND IS
:       ITSELF INDEXED BY MENU NUMBER EACH ENTRY IS A FW LONG
:
:       1 BYTE COUNT OF LOGON STRINGS IN MENU
:       HALF WORD INDEX INTO MSTRS FOR FIRST ELEMENT
:
        CBHDEF(MENUS,0)
MENUQ   EQ      0
        RE      MN
        BC      PM|MENUQ|
        BC      0
        HC      MI|MENUQ|-MSTRS
MENUQ   EQ      MENUQ+1
        ER
:
: CONSTRUCT ELEADR
:       ELEADR IS INDEXED BY THE ELEMENT NUMBER AND GIVES THE
:       ADDRESS OF THE ELEMENT STRING. REFERNCED FROM STRLST
:	FIRST ENSURE THAT WE ARE ON A WORD BOUNDARY
	WS	0                  
        CBHDEF(ELEADR,0)
ELENO   EQ      0
        RE      EN
        WC      E|ELENO|
ELENO   EQ      ELENO+1
        ER
:
: CONSTRUCT USER PROFILE TABLE
:
	WS      0
	DEFGEQ(UPFLST,.)
Q       EQ      1
        RE      NUMUNM
	RE 	UPFULN
	BC	80
	ER
QQ      EQ      .
        ORG     .-UPFULN
        USNM|Q|
        ORG     QQ
        HC      TM|Q|
        IF      TP|Q|+1
        HC      TP|Q|
        ELSE
        HC      0
        EI
Q       EQ      Q+1
        ER
:
        EM


        SUBTTL TPF ... Terminal profile table definitions

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 26 JUN 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,TPF                   :Delimit module
:
: This module creates the terminal profile table which describes the
: characteristics of a particular terminal, special subroutines to
: perform some output functions and a control key translation table
:
: There are no macros unique to this module.
:
: In this section macros are expanded to create tables that
: specify particular character sequences as special keys.
:
: First a description of the table is in order.
:
: TRMCTR in the terminal profile table points to a table of characters
: contained in full words. Each entry in the table is formatted as
: follows:
:
:       TCCC CCCC FFFF AAAA AAAA AAAA
:
: where
:
:       T       If 1 then this is the terminator of the table
:
:       C       7 bits of ASCII character
:
:       F       4 bits of control function
:               1 => LINK TO NEXT CHARACTER TABLE
:               0 => Coded character
:
:       A       an offset to the next identically formatted table or
:               a coded character to represent an ICL keyboard function
:
: In order to generate this table macros are used.  There is a macro
: for each terminal type that contains references to other macros which
: create these tables.  These tables are ordered in a hierarchy that
: reflects the sequence of characters that arrive from the terminal.
: This is designed to allow up to six characters to arrive that
: identify the particular function and allocating a unique code to it.
:
: To create a sequence there are a number of macros.  The placement of 
: these macros is very significant in that the position of a particular
: macro represents its position in a tree structure.  At the most
: significant level is the control character that initiates a sequence
: (this control may be the entire sequence).  There is one macro that
: specifies the character in the sequence at each level. For each macro
: there are two ways of calling the macro.  For level one:
:
: LEVEL1(CHAR)   This macro defines CHAR as the first character in
:                a sequence.  The subsequent macros after this one
:                specify the next character in the sequence.
:
: LEVEL1(CHAR,FCN) This macro defines CHAR as the first and only 
:                character of a sequence and FCN is the name of the
:                function that is to be performed when this character
:                is received.
:
: THE OCCURANCE OF EITHER OF THESE MACROS REPRESENTS A RETURN TO THE
: MOST SIGNIFICANT LEVEL IN THE TREE.  THE LEVEL1 MACRO WITHOUT THE FCN
: IS FOLLOWED BY MACROS REPRESENTING THE SECOND MOST SIGNIFICANT LEVEL OF THE
: HIERARCHY.  THAT IS THE SECOND CHARACTER OF THE STRING.  SINCE
: THERE MAY BE SEVERAL POSSIBLE SECOND CHARACTERS THAT REPRESENT SEPARATE
: FUNCTIONS STARTING FROM THE SAME FIRST CHARACTER THERE MAY BE SEVERAL
: BRANCHES AT THE SECOND LEVEL.  THESE MAY IN TURN LEAD TO A THIRD
: LEVEL.  THE MACROS AT LEVEL TWO ARE THE SAME AS AT LEVEL ONE EXCEPT
: FOR A CHANGE OF NAME TO SIGNIFY THE LEVEL:
:
: LEVEL2(CHAR)   LOGICALLY THE SAME AS LEVEL1 EXCEPT THAT IT INTRODUCES
:                THE THIRD LEVEL WHICH MUST FOLLOW THIS MACRO.
:
: LEVEL2(CHAR,FCN) LOGICALLY THE SAME AS LEVEL1 EXCEPT THAT IT OPERATES
:                ON THE SECOND LEVEL
:
: LEVEL3(CHAR)   LOGICALLY THE SAME AS LEVEL2 EXCEPT THAT IS INTRODUCES
:                THE FOURTH LEVEL WHICH MUST FOLLOW THIS MACRO
:
: LEVEL3(CHAR,FCN) LOGICALLY THE SAME AS LEVEL2 EXCEPT THAT IT OPERATES ON
:                THE THIRD LEVEL.
:
: LEVEL4(CHAR)   LOGICALLY THE SAME AS LEVEL3 EXCEPT THAT IT INTRODUCES
:                THE FIFTH LEVEL WHICH MUST FOLLOW THIS MACRO
:
: LEVEL4(CHAR,FCN) LOGICALLY THE SAME AS LEVEL3 EXCEPT THAT IT OPERATES
:                  ON THE FOURTH LEVEL
:
: SINCE A SIXTH LEVEL IS NOT YET DEFINED THERE IS NO LEVEL5
: MACRO WITHOUT A FCN PARAMETER
:
: LEVEL5(CHAR,FCN) LOGICALLY THE SAME AS LEVEL4 EXCEPT THAT IT OPERATES
:                 THE FIFTH LEVEL
:
: NOW THAT THE OBJECTIVE HAS BEEN DISCRIBED FROM BOTH ENDS WHAT
: FOLLOWS IS A DESCRIPTION OF HOW WE GET THERE.
: THAT IS HOW DO WE CONVERT THE INPUT FROM THE MACRO DEFINITIONS
: INTO THE TABLES REQUIRED.
:
: TO BUILD THE TABLES IT IS NECESSARY TO KNOW THE SIZE AND NUMBER
: OF TABLES.  IT IS ALSO NECESSARY TO KNOW THE ADDRESS OF EACH TABLE
: (WHICH IS DERIVED FROM THE ABOVE INFORMATION) IN ORDER TO LINK
: THE TABLES TOGETHER.  TO OBTAIN THIS INFORMATION THE TERMINAL DEFINITION
: MACROS ARE CALLED TWICE.  EACH TIME THERE ARE DIFFERENT DEFINITIONS
: FOR THE TREE MACROS TO EXTRACT DIFFERENT INFORMATION.  THE FIRST
: TIME COUNTS ARE COLLECTED.  FROM THESE COUNTS SPACE FOR THE TABLES
: IS BUILT AND LABELS DEFINED FOR THE LOCATION OF THE TABLES.
: FINALLY DURING THE SECOND PASS THE TABLES ARE FILLED IN.
:
:
: First pass  Extract counts
:
: SYMBOL CONVENTIONS:
:
: TC|TN|      THIS IS THE COUNT OF ENTRIES NOT COUNTING THE TERMINATING
:        ENTRY.  TN IS THE RELATIVE TABLE NUMBER
:        FOR THIS TABLE TYPE.  THE NUMBER IS IN HEXADECIMAL
: 
: TN1,TN2 ARE THE TABLE NUMBERS BEING FILLED IN ON LEVEL 1 AND 2 
:        RESPECTIVELY.
: 
PASONE  MACRO [
        KILL    LEVEL1,LEVEL2,LEVEL3,LEVEL4,LEVEL5,LEVEL6
:
QRXFCN  EQ      1
TN      EQ      1
TN1     EQ      0
TN2     EQ      0
TC1     EQ      0
:
LEVEL1  MACRO(CHAR,FCN,FNAME) [
:
: Check that CHAR < 128
:
        IF      CHAR-7F
        REMARK  %INVALID LEVEL1 CHARACTER%
        EI      (CHAR-7F)
:
: Count this entry and increase the table number
:
TC1     EQ      TC1+1
        IF      FCN
        ELSE
TN2     EQ      TN+1
TN      EQ      TN+1
TC|TN2| EQ      0
        EI
]
:
: Level two
:
LEVEL2  MACRO(CHAR,FCN,FNAME) [
:
: Count entry in this table
:
TC|TN2| EQ      TC|TN2|+1
        IF      FCN
        ELSE
:
: Start a table at level 3
:
TN3     EQ      TN+1
TN      EQ      TN+1
TC|TN3| EQ      0
        EI
]
:
: Level three                 
:
LEVEL3  MACRO(CHAR,FCN,FNAME) [
:
: Count the entry in this table
:
TC|TN3| EQ      TC|TN3|+1
        IF      FCN
        ELSE
:
: Start a table at level 4
:
TN4     EQ      TN+1
TN      EQ      TN+1
TC|TN4| EQ      0
        EI
]
:
: Level four
:
LEVEL4  MACRO(CHAR,FCN,FNAME)[
:
: Count the entry in this table
:
TC|TN4| EQ      TC|TN4|+1
        IF      FCN
        ELSE
:
: Start a table at level 5
:
TN5     EQ      TN+1
TN      EQ      TN+1
TC|TN5| EQ      0
        EI
]
:
: Level five
:
LEVEL5  MACRO(CHAR,FCN,FNAME)[
:
: Count the entry in this table
:
TC|TN5| EQ      TC|TN5|+1
        IF      FCN
        ELSE
:
: Start a table at level 6
:
TN6     EQ      TN+1
TN      EQ      TN+1
TC|TN6| EQ      0
        EI
]
:
: Level six
:
LEVEL6  MACRO(CHAR,FCN,FNAME) [
:
: Count the entry in this table
:
TC|TN6| EQ      TC|TN6|+1
]
]
:
: Construct space for tables and labels for each table number
:
PASTWO  MACRO   [
Q       EQ      1
        RE      TN
TA|Q|   WS TC|Q|
        WC      80000000
Q       EQ      Q+1
        ER
:
: Redefine table macros to fill in table
:
TN      EQ      1
TN1     EQ      0
TN2     EQ      0
TC1     EQ      0
F       EQ      0                       :Function entry
T       EQ      1                       :Table entry
        KILL    LEVEL1,LEVEL2,LEVEL3,LEVEL4,LEVEL5,LEVEL6
:
LEVEL1  MACRO(CHAR,FCN,FNAME) [
TC1     EQ      TC1+1
        IF      FCN
        SETVAL(TA1,TC1,CHAR,F,FNAME)
        ELSE
TN2     EQ      TN+1
TN      EQ      TN2
TC|TN2| EQ      0
        SETVAL(TA1,TC1,CHAR,T,TA|TN2|)
        EI
]
LEVEL2  MACRO(CHAR,FCN,FNAME) [
TC|TN2| EQ      TC|TN2|+1
        IF      FCN
        SETVAL(TA|TN2|,TC|TN2|,CHAR,F,FNAME)
        ELSE
TN3     EQ      TN+1
TN      EQ      TN3
TC|TN3| EQ      0
        SETVAL(TA|TN2|,TC|TN2|,CHAR,T,TA|TN3|)
        EI
]
:
: Level three
:
LEVEL3  MACRO(CHAR,FCN,FNAME) [
TC|TN3| EQ      TC|TN3|+1
        IF      FCN
        SETVAL(TA|TN3|,TC|TN3|,CHAR,F,FNAME)
        ELSE
TN4     EQ      TN+1
TN      EQ      TN4
TC|TN4| EQ      0
        SETVAL(TA|TN3|,TC|TN3|,CHAR,T,TA|TN4|)
        EI

]
:
: Level four
:
LEVEL4  MACRO(CHAR,FCN,FNAME) [
TC|TN4| EQ      TC|TN4|+1
        IF      FCN
        SETVAL(TA|TN4|,TC|TN4|,CHAR,F,FNAME)
        ELSE
TN5     EQ      TN+1
TN      EQ      TN5
TC|TN5| EQ      0
        SETVAL(TA|TN4|,TC|TN4|,CHAR,T,TA|TN5|)
        EI
]
:
: Level five
:
LEVEL5  MACRO(CHAR,FCN,FNAME) [
TC|TN5| EQ      TC|TN5|+1
        IF      FCN
        SETVAL(TA|TN5|,TC|TN5|,CHAR,F,FNAME)
        ELSE
TN6     EQ      TN+1
TN      EQ      TN6
TC|TN6| EQ      0
        SETVAL(TA|TN5|,TC|TN5|,CHAR,T,TA|TN6|)
        EI
]
:
: Level six
:
LEVEL6  MACRO(CHAR,FCN,FNAME) [
TC|TN6| EQ      TC|TN6|+1
        SETVAL(TA|TN6|,TC|TN6|,CHAR,F,FNAME)
]
]
: Macro to set a value in the control function table
:
SETVAL  MACRO(TABLE,ENTRY,CHAR,CTL,FCNNO) [

:       TABLE   location of the table
:       ENTRY   relative entry number in the table
:       CHAR    character for this entry
:       CTL     control bits
:       FCNNO   function number associated with this entry
:
        ORG     TABLE+(ENTRY-1)*4
QXZ     EQ      $A(CHAR^24)!(CTL^20)
        WC      QXZ+FCNNO
]
:
: Symbols used for standard functions
:
        DEFGEQ(FLDTAB,0)                :Tab
        DEFGEQ(BCKTAB,1)                :Backtab
        DEFGEQ(CURRT,2)                 :Cursor right
        DEFGEQ(CURLEF,3)                :Cursor left
        DEFGEQ(CURUP,4)                 :Cursor up
        DEFGEQ(CURDON,5)                :Cursor down
        DEFGEQ(HOME,6)                  :Home
        DEFGEQ(SETSOM,7)                :Set som
        DEFGEQ(CLEAR,8)                 :Clear screen
        DEFGEQ(NEWLIN,9)                :Newline
        DEFGEQ(DELCHR,0A)               :Delete character
        DEFGEQ(INSCHR,0B)               :Insert character
        DEFGEQ(DELLIN,0C)               :Delete line
        DEFGEQ(INSLIN,0D)               :Insert line
        DEFGEQ(ERSMES,0E)               :Erase message
        DEFGEQ(ERSLIN,0F)               :Erase line
        DEFGEQ(ACTION,10)               :Action message
        DEFGEQ(SEND,11)                 :Send message
        DEFGEQ(PRINT,12)                :Print screen
        DEFGEQ(RESET,13)                :Interlock
	DEFGEQ(NXTLIN,14)		:Move cursor to next line
	DEFGEQ(DOLLAR,15)		:Dollar symbol
:
        DEFGEQ(REDSPY,20)               :Redisplay screen
        DEFGEQ(KILL,21)                 :Zap circuit
        DEFGEQ(RACK,22)                 :Rack up/down
        DEFGEQ(STATSW,23)               :Status indicator on/off
        DEFGEQ(HELP,24)                 :Help
        DEFGEQ(NULL,25)                 :No function key
        DEFGEQ(PRTOP,26)                :Printer operable
        DEFGEQ(PRTNOP,27)               :Printer inoperable
        DEFGEQ(HLDPRT,28)               :Printer hold
        DEFGEQ(ALLPRT,29)               :Printer allocate
	DEFGEQ(RESTRT,2A)		:Restart session

        SUBTTL TPF ... Terminal profile table definition
:
:
: The terminal profile table
:
: The terminal profile table describes the characteristics of each type
: of terminal. In some cases this is the address of a routine to
: accomplish a unique function.
:
        SEG     0
OLDORG  EQ      .                       :Save origin
        ORG     0
        CBHDEF(TRMTTL,1)                :Consat parameter values
        CBHDEF(TRMCTL,1)                :Consat parameter values
        CBHDEF(TRMSTR,1)                :Terminal initialisation string
        CBHDEF(TRMFIN,1)                :Terminal close down string
        CBHDEF(TRMCLR,1)                :Clear terminal string
        CBHDEF(TRMSIZ,1)                :Terminal screen size
        CBHDEF(TRMSTA,1)                :Position of status indicator
        CBHDEF(TRMSPR,1)                :Start unprotected string
        CBHDEF(TRMSUF,1)                :Start unprotected string
        CBHDEF(TRMNEW,1)                :ICL visible newline string
        CBHDEF(TRMRKU,1)                :Rack up string
        CBHDEF(TRMRKD,1)                :Rack down string
        CBHDEF(TRMPRC,1)                :Printer capability
        CBHDEF(TRMBPR,1)                :Begin printing string
        CBHDEF(TRMFPR,1)                :Finish printing string
        CBHDEF(TRMDSR,1)                :Printer status string
        CBHDEF(TRMSCR,1)                :Save cursor string
        CBHDEF(TRMRCR,1)                :Restore cursor string
        CBHDEF(TRMMCC,1)                :Move cursor cost
        CBHDEF(TRMHLP,1)                :Help text strings
        CBHDEF(TRMSPX,SCRSIZ/10)        :Special position array
        WS      0
        CBHDEF(TRMKBD,2)                :Keyboard table for control keys
        CBHDEF(TRMMC,2)                 :Move cursor routine address
        CBHDEF(TRMSA,2)                 :Set attribute routine address
        CBHDEF(TPTSIZ,0)                :Size of terminal profile table
        ORG     OLDORG
:
: We now expand the macros that will build the terminal profile table
:
YM      EQ      0                       :YM will contain no. of terminal types
        DEFTRM                          :Expand terminal macros
:
: Now build a list of terminal type descriptions for the terminal
: selection menu in SC format.
:
        DEFGEQ(TERMLS,.)
YMZ     EQ      0
        RE      YM
IA|YMZ| IM|YMZ|
YMZ     EQ      YMZ+1
        ER

TPFDEF  MACRO [
TTY|YMZ| HC     IA|YMZ|
	HC     CR|YMZ|
        HC      ST|YMZ|
        HC      CD|YMZ|
        HC      CL|YMZ|
        HC      SZ|YMZ|
        HC      SI|YMZ|
        HC      SP|YMZ|
        HC      SU|YMZ|
        HC      NL|YMZ|
        HC      RU|YMZ|
        HC      RD|YMZ|
        HC      PR|YMZ|
        HC      BP|YMZ|
        HC      FP|YMZ|
        HC      PS|YMZ|
        HC      SC|YMZ|
        HC      RC|YMZ|
        HC      IK|YMZ|
        HC      HE|YMZ|
        SX|YMZ|
        WC      CT|YMZ|
        WC      MC|YMZ|
        WC      SG|YMZ|
]
:
: Expand the TPFDEF macro over the various terminal types
:
        SEG     A.DATA
        WS      0
        DEFGEQ(TPFLST,.)                :Terminal profile table base
YMZ     EQ      0
        RE      YM
        TPFDEF
YMZ     EQ      YMZ+1   
        ER
        DEFGEQ(NUMTTY,YM)               :Number of terminal types
:
        EM


	SUBTTL	ISIS Front End Handler Package	- FRNTND.LIB

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
: 
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRNTND.LIB	MFR 08/12/81
:
:	This package is an ISIS Front End interface to Tymnet. It
:	is used to service the ISIS input ring, and to activate user
:	defined routines whenever a message is found for a port and
:	optionally for output service when output requests are pending.

:	The package is designed to permit the activation routines to be
:	defined on an individual port basis if desired. It is also
:	designed so that context within a process can be indicated by 
:	dynamically changing to a different set of activation routines.
:
:			Conventions
:
:	The following symbols are to be provided by the user:
:
:	ECHO	if TRUE causes Tymsat echoing for terminals
:	AUTOBP	if TRUE causes automatic backpressure application & release
:		for a port based upon comparing number of characters
:		in input buffer and MAXCHAR.
:	PTIMEO	if TRUE port timeouts are available
:	MAXCHAR	maximum number of characters in a port's input buffer before
:		backpressure applied. (Only needed if AUTOBP is TRUE)
:	OUTPROC	if TRUE then output activation code will be included.
:	WAITZA if TRUE then ZAPPER acknowledgements will be requested from
:		ISIS and code will be included to clean up the port upon
:		receipt of the ZAP ACK message. (User will not have to reset
:		ACP.)
:
:	The following symbol is to be initialized by the user:
:
:	PECHO	a bit for each port. If set then echoing will be honored
:		for the port, otherwise defered echo mode will not be
:		honored.
:
:	The following symbols may be provided by the user:
:	(If not provided, default values will be used)
:
:	CRIPOM	crash code for invalid port zero message (default 20x)
:	CRNAR	crash code for no activation routine found (default 21x)
:	CRINVN	crash code for invalid needle received (default 22x)
:	CRINVM	crash code for invalid message received (default 23x)
:       FWPTAB  if true use a fullword port table.  (default 0)
:
:	The following data structures are to be provided and initialized
:	 by the user: (They may be located in any segment)
:
:	DCB	Device Control Block, a data structure which contains all
:		the context information for a port. There should be NPORT
:		DCB's defined starting at address DCBLKS. Within each DCB
:		the following offsets must be defined:
:			DCBICC	input character count (halfword)
:			ACTIVD	relative address in A.CODE of data
:				activation routine.
:			ACTIVC	relative address in A.CODE of a table of
:				halfword offsets in A.CODE of routines
:				for each possible control message.
:			ACTIVT	relative address in A.CODE of timeout
:				activation routine.
:			ACTIVO	relative address in A.CODE of output
:				activation routine. (Only needed if OUTPROC
:				is TRUE.)

:
:	PORTAB	Port Table, a halfword array containing entries for each
:		port which are the relative offset from DCBLKS of the
:		DCB for the port. If FWPTAB is true then the port
:		table is a fullword array containig the address of
:		the DCB for the port.  NOTE not an offset!
:
:	In addition, activation routines must be defined for port zero
:	messages (ACTIV0) to for needles (ACTIVN). These labels should
:	be the location of the actual routine not offsets in A.CODE.
:
:	Whenever a data or control message activation routine is called,
:	the following registers are set up:
:		R1	port number
:		R2	message type
:		R5	link register
:		R12	DCB pointer
:		R14	input ring pointers
:
:	The activation routines are responsible for extracting all the
:	message data for the current logical record from the input ring.
:	Upon return, this package willend the logical input record (ELIR).
:	Therefore R14 must be pointing to the end of the message
:	when this package regains control. All other registers may be
:	smashed.
:
:	Needles are handled differently. The are parsed and the following
:	registers loaded.
:		R1	port number
:		R2	number of characters in username
:		R5	link register
:		R6	invoice number
:		R7	destination host number
:		R8	originating node number
:		R9	originating host number
:		R10	originating port number
:		R11	dialect code
:		R13	TID
:		R14	input ring pointer
:
:	Upon a needle activation, everything up to and including the
:	username length will have been extracted from the input ring.
:	The ACTIVN routine is responsible for extracting the username.
:
:	If PTIMEO is true then a normal return from any activate'ed
:	process indicates that the timeout state of the port should not
:	be modified. If a skip return is taken, then R0 will be
:	examined. If R0 is non-zero, a timeout for that
:	many seconds will be set for the port. If R0 is zero then any 
:	timeout for the port will be cleared. When a timeout expires for a
:	port the timeout activation routine for the port will be called with
:	the following registers set up:
:		R1	port number
:		R5	link register
:		R12	DCB pointer
:
:	Upon return from the timeout activation routine, the same
:	skip/normal return convention is followed.
:
:	The user may also set or clear a timeout for a port directly.
:	The routines SETTO and CLRTO are used to set or clear a
:	timeout for a port respectively. They are used when a timeout
:	is to be set (or cleared) at a time other than a the return from
:	an activation. The routines should be called with R1 = port number.
:	For SETTO R0 should contain the interval, in seconds, until
:	the timeout activation routine for the DCB in activated.
:
:	The output routine searches for any ports requiring output service
:	which are not backpressured. For each such port, the output
:	activation routine found in the port's DCB will be activated
:	with the following registers set up:
:		R1	port number
:		R5	link register
:		R12	DCB pointer
:
:	Upon return from the output activation routine, the same
:	skip/normal return convention for timeouts is followed.
:
:	The following routines are to be called by the user (link R0).
:
:	IZFRNT	at initialization time, after calling IZT.
:	INPUT	from EXEC loop, to process input from ISIS.
:	OUTPUT	from EXEC loop, to process output requests.
:
:	In order to facilitate setting up the control message
:	activation routine table some symbols, routines, and macros
:	have been defined.
:
:	The following symbols have the values of the offsets from A.CODE of
:	a number of control message processing routines:
:		Symbol	Routine	Description
:		XTOSS	TOSS	tosses the message
:		XZAP	ZAP	handles zapper
:		XZACK	ZACK	handles zapper acknowledgement
:		XNOSEND	NOSEND	handles backpressure
:		XRESEND	RESEND	handles release backpressure
:		XGOBBLE	GOBBLE	handles gobbler
:		XFLBACK	FLBACK	handles flush backward
:		XEDEM	EDEM	handles enter deffered echo mode
:		XLDEM	LDEM	handles leave defered echo mode
:		XGB	GB	handles green ball
:		XRB	RB	handles red ball
:		XOB	OB	handles orange or black ball
:		XPNEED	PNEED	handles psuedo needle
:		XXLIM	XLIM	handle xmit limit
:		XINVAL	INVAL	crashes with invalid message code

:	The following macros are used to set up the tables:
:
:		HTABVT with argument table name is used to set up the 
:			process table for a typical virtual terminal port.
:
:		HTABIA with argument table name is used to set set up the
:			process table for an inactive port.
:
:		CHGTAB	with arguments table name, msg number, and routine
:			label is used to substitute for a default process
:			routine in the table.
::	Example:
:		To set up the control message activation routine table for
:		a virtual terminal handler which must call a routine to
:		release resources (RELRSC) upon losing the circuit on a port
:		the following code might be used.
:
:			SEG	A.CODE
:			MO	.,FRNTND
:
:			HTABVT(VTAB)	:GENERATE DEFAULT TABLE
:			CHGTAB(VTAB,9E,RELRSR)	:CHANGE ZAPPER HANDLER
:		RELRSC	------		:CODE TO CLEAN UP AND RELEASE
:			------		:RESOURCES USED BY PORT
:			J	ZAP	:JUMP TO ZAP PROCESSOR TO CLEAN
:					:UP ITS TABLES
:			EM
:			END
:
:	It should be noted that the above code is in the module FRNTND.
:	This is the Input Handler module. The preceeding symbols, routines
:	and macros are not global'ed so the code must be in the same
:	module or the symbols LOCAL'ed.
:	It should also be noted that the user defined processing
:	routines should jump to the default process routine or perform
:	similar processing on the input ring and status indicators.
:
:
	GL	NPORT,ECHO,DEM,PECHO,XLIMIT,ACP,TOISIS,FRISIS
	GL	IZFRNT,INPUT,RPORT,RDCB,AUTOBP,OUTPROC,PTIMEO
	GL	ACTIV0,ACTIVD,ACTIVC,ACTIVN,ACTIVT,EMPTYI,EMPTYO
	GL	CRIPOM,CRNAR,CRINVN,CRINVM
        gl      toss1
        IF      \FWPTAB
        ELSE
FWPTAB  EQ      0               :DEFAULT OFF
        EI
:
:DEFINE MACROS FOR ACCESSING PORTAB AND THE DCB
:
:
:Macros used to reference the port table and the DCB
:
:GETDCB - loads RDCB from PORTAB and RPORT
:
:DCBREF - produces a reference to the DCB entry specified
:         as a parameter to the macro.
:
	IF	FWPTAB
GETDCB	MACRO [SLLS RPORT,2
	L	RDCB,PORTAB,RPORT
	SRLS	RPORT,2
	LR	RDCB,RDCB
]
DCBREF	MACRO(REF) [REF,RDCB]
	ELSE
GETDCB	MACRO [LHL RDCB,PORTAB,RPORT,RPORT]
DCBREF	MACRO(REF) [REF+DCBLKS,RDCB,]
	EI
 IF	OUTPROC
	GL	ACTIVO,OUTPUT,OUTDAT,FLAGS
 EI
 IF	AUTOBP
	GL	AUTOBP
 EI

	MO	.,FRNTND

RPORT	EQ	R1		:PORT CURRENTLY BEING WORKED WITH
RDCB	EQ	R12		:POINTER TO DCB

	SEG	A.DATA

XLIMIT	BS	NPORT		:MAX NUMBER DATA CHARACTERS THAT CAN BE SENT
				:IN ONE MESSAGE
NGRP	EQ	(NPORT+0F)/10	:NUMBER OF PORT GROUPS TO PROCESS
ACP	HS	NGRP		:ACTIVE PORTS BIT ARRAY
TOISIS	HS	NGRP		:PORTS WE CAN SEND DATA ON
FRISIS	HS	NGRP		:PORTS WE HAVE NOT BACKPRESSURED
DEM	HS	NGRP		:PORTS IN DEFERED ECHO MODE
 IF	OUTPROC
FLAGS	HS	1		:BASE ADDRESS OF BIT ARRARYS. FIRST
				:HALFWORD WASTED TO AVOID BIT DISPLACE-
				:MENTS OF ZERO.
OUTDAT	HS	NGRP		:PORTS WITH OUTPUT REQUESTS WAITING
 EI
PECHO	HS	NGRP		:PORTS FOR WHICH ECHO SHOULD BE PERFORMED
 IF	\WAITZA
 ELSE
	REMARK %PLEASE DEFINE WAITZA SWITCH. DEFAULT OFF ASSUMED%%
WAITZA	EQ	0
 EI

 IF	WAITZA
	GL	CNTRL
  IF	\CNTRL
CNTRL	EQ	CNTRL!80	:SET ZAP ACK BIT
  ELSE
CNTRL	EQ	292
  EI
 EI

REGSAV	HS	20		:REGISTER SAVE AREA
RETPTR	HS	2		:RETURN POINTER
RETRN	HS	2		:RETURN ADDRESS FOR ACTIV ROUTINE
SPORT	HS	1		:SAVE AREA FOR PORT NUMBER
SDCB	HS	1		:SAVE AREA FOR DCB POINTER
SLOOP	HS	1		:SAVE AREA FOR OUTPUT LOOP COUNTER
 IF	OUTPROC
PRTSVC	HS	1		:PORTS ELIGIBLE FOR SERVICE INDICATOR
 EI

  IF	PTIMEO			:PORT TIMEOUT
TSAVE	HS	4		:SAVE AREA FOR TIMEOUT ACTIVATOR
PTIME	HS	NGRP		:PORTS ON ACTIVE TIMEOUT
ATIME	HS	2*NPORT		:ACTIVATION TIME
  EI

:
:	DEFINE CRASH CODES IF USER HAS NOT
:

  IF	\CRIPOM
  ELSE
CRIPOM	EQ	20	:INVALID PORT ZERO MESSAGE
  EI

  IF	\CRNAR
  ELSE
CRNAR	EQ	21	:NO ACTIVATION ROUTINE IN DCB
  EI

  IF	\CRINVN
  ELSE
CRINVN	EQ	22	:INVALID NEEDLE RECEIVED
  EI

  IF	\CRINVM
  ELSE
CRINVM	EQ	23	:INVALID MESSAGE RECEIVED
  EI


	SEG	A.CODE

:	HANDY INDEXABLE HALFWORD BIT MASKS
HMASK	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1

:	BIT ARRAY TO IDENTIFY DATA MESSAGES
DATAM	HC	07FFF,-1,-1	:00
	HC	-1,-1,-1	:30
	HC	-1,-1,-1	:60
	HC	0FFFC,0,0	:90
	HC	0,0,0		:C0
	HC	0		:F0

LENGTH	BC	0		:MESSAGE LENGTH TABLE
	RE	9D;	BC	.-LENGTH+1;	NOLIST;	ER;	LIST	:DATA TEXT STRINGS
	BC	1		: 9E	DETACH
	BC	1		: 9F	DISCONNECT
	BC	1		: A0	APPLY BACKPRESSURE
	BC	1		: A1	RELEASE BACKPRESSURE
	BC	1		: A2	FLUSH FORWARD
	BC	1		: A3	FLUSH BACKWARD
	BC	1		: A4	BLACK BALL
	BC	1		: A5	GREY BALL
	BC	1		: A6	ENTER "DEM"
	BC	1		: A7	LEAVE "DEM"
	BC	1		: A8	ENTER "TRANSPARENCY"
	BC	1		: A9	LEAVE "TRANSPARENCY"
	BC	1		: AA	GREEN BALL
	BC	1		: AB	RED BALL
	BC	1		: AC	YELLOW BALL
	BC	1		: AD	ORANGE BALL
	BC	1		: AE	"BREAK" DETECTED
	BC	1		: AF	"HANG UP"
	BC	2		: B0	QUERY TERMINAL PARAMETER
	BC	3		: B1	SET TERMINAL PARAMETER
	BC	4		: B2	PSEUDO-NEEDLE
	BC	2		: B3	LOGON CHARACTER
	BC	2		: B4	NORMAL LOGON STATUS
	BC	2		: B5	LOGON FAILURE
	BC	8		: B6	SUCCESSFUL LOGON FROM THIS PORT
	BC	6		: B7	ADDENDUM TO ACCOUNTING
	BC	1		: B8	SUPER-"HANG UP"
	BC	2		: B9	TRANSMIT LIMIT
	BC	1		: BA	BREAK END
	BC	1		: BB	ZAPPER ACKNOWLEGEMENT
	BC	1		: BC	ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	1		: BD	LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	2		: BE	ZAP WITH REASON
	BC	1		: BF	START IIX
	BC	1		: CO	TERMINATE IIX

:		**INTERFACE DATA TYPES**


NEDMSG	EQ	0		:NEEDLE
FIRST	EQ	9E		:FIRST MESSAGE IN LIST
DETMSG	EQ	9E		:DETACH MESSAGE
ZAPMSG	EQ	9F		:DISCONNECT MESSAGE
NOSMSG	EQ	0A0		:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1		:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2		:FLUSH OUTPUT
BKGMSG	EQ	0A3		:FLUSH INPUT
BLKMSG	EQ	0A4		:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5		:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6		:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7		:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8		:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9		:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA		:GREEN BALL
RBMSG	EQ	0AB		:RED BALL
YBMSG	EQ	0AC		:YELLOW BALL
OBMSG	EQ	0AD		:ORANGE BALL
BRKMSG	EQ	0AE		:BREAK DETECTED
HNGMSG	EQ	0AF		:HANG UP
QTPMSG	EQ	0B0		:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1		:SET TERMINAL PARAMETER
PNDMSG	EQ	0B2		:PSEUDO NEEDLE
NLOGCH	EQ	0B3		:NORMAL LOGON CHAR
NLOGST	EQ	0B4		:NORMAL LOGON STATUS
LOGFAL	EQ	0B5		:LOGON FAILURE
LOGOK	EQ	0B6		:SUCCESSFUL LOGON
ADACTG	EQ	0B7		:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8		:SUPER-HANG UP
SETLIM	EQ	0B9		:SET XMIT LIMIT
BRKEND	EQ	0BA		:BREAK END
ZAPACK	EQ	0BB		:ZAPPER ACKNOWLEGEMENT
EAODM	EQ	0BC		:ENTER ALTERNATE OUTPUT DEVICE MODE
LAODM	EQ	0BD		:LEAVE ALTERNATE OUTPUT DEVICE MODE
ZAPREA	EQ	0BE		:ZAP WITH REASON
SIIX	EQ	0BF		:START IIX
TIIX	EQ	0C0		:TERMINATE IIX
MAXTYP	EQ	0C0		:MAXIMUM TYPE DEFINED

:
:	HANDLES INPUT MESSAGES FROM ISIS INPUT RING
:
INPUT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
INPUT1	JAL	R4,LOOK		:IS THERE ANYTHING TO DO?
	J	RET		:NO... RETURN ALLL DONE FOR NOW
	JN	INPUT2		:TEST IF PORT 0.. SKIP IF NOT
:
:	CHECK PORT ZERO MESSAGES
:
	JAL	R4,GETCH	:GET MSG TYPE BYTE
	LR	R2,R0		:TEST MSG TYPE
	JEFS	SPEC2		:SKIP IF MSG 0
	TBT	R2,SPECL	:TEST IF VALID MESSAGE TYPE
	JEFS	SPEC1		:SKIP IF OK
	JAL	R10,CRASH	:OTHERWISE CRASH
	BC	0,0,4*R2,CRIPOM

SPECL	BC	1D,0A9,0FF	:INVALID PORT 0 MSG TYPES

SPEC1	LA	R5,ACTIV0	:SET UP CALLING ADDRESS
	JAL	R4,ACTIV	:ACTIVATE USER PORT 0 MSG ROUTINE
SPEC2	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE....
:
:	NOT A PORT ZERO MESSAGE
:
:	R1=PORT#	R2=MSG TYPE
:
INPUT2	JAL	R4,GETCH	:GET MSG TYPE
	TBT	R0,DATAM	:TEST IF DATA MESSAGE
	JE	INPUT3		:SKIP IF NOT
:
	TBT	RPORT,DEM	:TEST IF PORT IS IN DEFERED ECHO MODE
	JE	INDATA		:SKIP IF NOT
	TBT	RPORT,PECHO	:SHOULD DEM BE HONORED?
	JE	INDATA		:SKIP IF NOT
	LR	R2,R0		:COPY MSG LENGTH
	LR	R5,R0		:COPY IT AGAIN
	ST	R14,REGSAV	:SAVE INPUT RING POINTER REGISTER
:
ECHO1	JAL	R4,GETCH	:GET A CHARACTER
	STB	R0,ECHOBF,R5	:PUT IT INTO ECHO BUFFER
	SIS	R5,1		:DECREMENT COUNTER
	JGBS	ECHO1		:GO BACK IF MORE CHARS IN RECORD
	LR	R5,R2		:COPY CHAR COUNT
	LHI	R0,3,R2		:CALCULATE MSG LENGTH
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
ECHO2	LB	R0,ECHOBF,R5	:GET A CHARACTER FROM ECHO BUFFER
	JAL	R4,PUTCH	:PUT IT INTO OUTPUT RING
	SIS	R5,1		:DECREMENT COUNTER
	JGBS	ECHO2		:REPEAT IF MORE
	JAL	R4,ELOR		:ALL DONE.. END LOGICAL RECORD
:
:	NOTE THAT BACKPRESSURE AND TRANSMIT LIMIT ARE NOT CHECKED
:	IN SERVICING THE DEFERED ECHO.
:
	L	R14,REGSAV	:RESTORE INPUT RING POINTER

:
INDATA	GETDCB			:GET DCB POINTER
	JEFS	INDCR		:CRASH IF NO DCB
	LHL	R4,DCBREF(ACTIVD)      :GET DATA ACTIVATION ROUTINE FOR PORT
	JNFS	INDAT1		:TEST IF THERE IS A ROUTINE
INDCR	JAL	R10,CRASH	:CRASH IF NO ROUTINE
	BC	0,0,4*RDCB,CRNAR
:
  IF	AUTOBP
:
:	CHECK IF INPUT PORT SHOULD BE BACKPRESSURED
:
INDAT1	STH	RPORT,SPORT	:PRESERVE R1
	STH	RDCB,SDCB	:PRESERVE RDCB
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	JAL	R4,ELIR		:END THE INPUT RECORD
	LHL	RDCB,SDCB	:RESTORE DCB POINTER
	LH	R0,DCBREF(DCBICC)	:GET INPUT CHAR COUNT
	SHI	R0,MAXCHAR	:TEST IF TOO MANY CHARACTERS
	JL	INPUT1		:NO... GO BACK FOR MORE 
	LHL	RPORT,SPORT	:RESTORE PORT NUMBER
	LIS	R0,3		:GENERATE BACKPRESSURE MESSAGE
	LHI	R2,NOSMSG	:
	JAL	R4,SLOR		:START THE RECORD
	JAL	R4,ELOR		:END IT
	RBT	RPORT,FRISIS	:SET BP INDICATOR FOR PORT
	J	INPUT1		:AND GO BACK FOR MORE
  ELSE
:
INDAT1	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	JAL	R4,ELIR		:END THE INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE
  EI

	SEG	A.DATA
ECHOBF	BS	FIRST	:ECHO BUFFER

	SEG	A.CODE

:
:	PROCESS CONTROL MESSAGES
:
INPUT3	LR	R3,R0		:COPY MSG TYPE
	JN	INCNTL		:NOT A NEEDLE....SKIP
	SBT	RPORT,ACP		:TEST AND SET ACTIVE PORT BIT
	JEFS	NEEDLE		:SKIP IF PORT WAS NOT ACTIVE
	JAL	R10,CRASH	:OTHERWISE CRASH
	BC	0,0,4*RPORT,CRINVN
:
:	PROCESS NEEDLES
:
NEEDLE	LHI	R0,FIRST-1	:SET UP TRANSMIT LIMIT
	STB	R0,XLIMIT,RPORT	:STORE IT
	SBT	RPORT,TOISIS	:CLEAR BACKPRESSURE
	SBT	RPORT,FRISIS	:
 IF	OUTPROC
	RBT	RPORT,OUTDAT	:CLEAR OUTPUT DATA WAITING
 EI
  IF PTIMEO
	RBT	RPORT,PTIME	:CLEAR PORT TIMEOUT
  EI
	JAL	R4,GETCH	:SKIP LENGTH
	JAL	R4,GETW		:GET INVOICE NUMBER
	LR	R6,R0		:COPY IT
	JAL	R4,GETH		:GET DESTINATION HOST
	LR	R7,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE NODE
	LR	R8,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE HOST
	LR	R9,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE PORT
	LR	R10,R0		:COPY IT
	JAL	R4,GETW		:FUTURE EXPANSION
	JAL	R4,GETH		:GET DIALECT CODE
	LR	R11,R0		:COPY IT
	JAL	R4,GETCH	:GET TID
	LR	R13,R0		:COPY IT
:
  IF	ECHO
:		SOURCE NODE SHOULD ECHO
	THI	R13,1F		:CHECK IF TERMINAL
	JE	NEED2		:SKIP... NOT A TERM
	ST	R14,REGSAV	:SAVE INPUT RING POINTER
	THI	R13,20		:CHECK IF HALF DUPLEX
	JNFS	NEED1		:SKIP IF HDX.. DON'T SET DEM
	SBT	RPORT,DEM	:SET DEM
NEED1	LIS	R0,5		:SEND SET TERM PARM MSG
	LHI	R2,STPMSG	:
	JAL	R4,SLOR		:START THE OUTPUT RECORD
	LIS	R0,0
	JAL	R4,PUTCH	:
	LIS	R0,1		:SET ECHO ON
	JAL	R4,PUTCH	:
	JAL	R4,ELOR		:
	L	R14,REGSAV	:RESTORE INPUT RING POINTER
  EI
:
NEED2	JAL	R4,GETCH	:GET USERNAME LENGTH
	LR	R2,R0		:COPY USERNAME LENGTH
	LA	R5,ACTIVN	:SET UP NEEDLE ACTIVATION ROUTINE ADDR
	JAL	R4,ACTIV	:ACTIVATE IT
	JAL	R4,ELIR		:END THE INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE

:
:
:	PROCESS NON-NEEDLE CONTROL MESSAGES FOR PORTS
:
INCNTL	SHI	R3,FIRST		:SUBTRACT TO GET RELATIVE MSG NUMBER
	SLLS	R3,1			:FORM HALFWORD INDEX
	GETDCB			:GET DCB POINTER
	JE	INCN1			:CRASH IF NO DCB
	LHL	R4,DCBREF(ACTIVC)	:GET TABLE POINTER
	JEFS	INCN1			:SKIP IF NO TABLE ADDRESS
	LHL	R4,SEG|A.CODE|,R4,R3	:GET ROUTINE ADDRESS
	JEFS	INCN1			:SKIP IF NO ROUTINE ADDRESS
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV		:ACTIVATE
	JAL	R4,ELIR			:END THE LOGICAL RECORD
	J	INPUT1			:AND GO BACK FOR MORE
:
INCN1	JAL	R10,CRASH		:CRASH IF NO ROUTINE
	BC	0,0,4*RDCB,CRNAR

:	INITIALIZATION FOR THIS PACKAGE
:
IZFRNT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
	LHI	RPORT,NPORT-1	:SET UP LOOP
IZIN1	RBT	RPORT,ACP	:SET PORT NOT ACTIVE
	SBT	RPORT,TOISIS	:SET BACKPRESSURE OFF
	SBT	RPORT,FRISIS	:
 IF	OUTPROC
	RBT	RPORT,OUTDAT	:RESET OUTPUT DATA WAITING
 EI
	RBT	RPORT,DEM	:NOT DEFERED ECHO MODE
	SIS	RPORT,1		:DECREMENT LOOP COUNTER
	JGEBS	IZIN1		:REPEAT IF MORE
:
  IF	AUTOBP			:AUTOMATIC BACKPRESSURE RELEASE CODE
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,RELBP	:PUT RELBP ON TIMEOUT LIST
	LHI	R1,RATE/2,R7	:SET HALF SECOND TIMEOUT
	JAL	R5,TOPUT	:
  EI
:
  IF	PTIMEO			:PORT TIMEOUT CODE
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,ONESEC	:PUT ONESEC ON TIMEOUT LIST
	LHI	R1,RATE,R7	:SET ONE SECOND TIMEOUT
	JAL	R5,TOPUT	:
  EI
	JFS	RET		:RETURN
:
:	GENERAL RETURN ROUTINE
RET	L	R0,RETPTR	:GET RETURN ADDRESS
	JR	R0		:AND RETURN
:
:	ACTIVATION ROUTINE
:
ACTIV	ST	R4,RETRN	:SAVE RETURN ADDRESS
  IF	PTIMEO
:		PORT TIMEOUT CODE
	STH	RPORT,SPORT	:PRESERVE PORT NUMBER
	JALR	R5,R5		:ACTIVATE
	J	ACTIV2		:NORMAL RETURN DON'T MODIFY TIMEOUT
	LHL	RPORT,SPORT	:RESTORE PORT NUMBER
	LR	R0,R0		:TEST RETURN PARAMETER
	JGFS	ACTIV1		:NONZERO... SKIP
	RBT	RPORT,PTIME	:TURN OFF PORT TIMEOUT INDICATOR
	JFS	ACTIV2		:
ACTIV1	SBT	RPORT,PTIME	:SET PORT TIMEOUT INDICATOR ON
	A	R0,SLOWC,,	:ADD TIMEOUT TO SLOW CLOCK
	SLHLS	RPORT,2		:MAKE WORD INDEX POINTER
	ST	R0,ATIME,RPORT	:STORE ACTIVATION TIME
  ELSE
	JALR	R5,R5		:ACTIVATE
  EI
ACTIV2	L	R4,RETRN	:RESTORE RETURN ADDRESS
	JR	R4		:AND RETURN
:
  IF	AUTOBP
:
:		CODE TO PERIODICALLY CHECK IF BACKPRESSURE CAN
:		BE RELEASED ON ANY PORTS
RELBP	AHI	R1,RATE/2		:
	JAL	R5,TOPUT	:PUT BACK ON TIMEOUT LIST FOR ONE SECOND
:
:	CHECK ALL PORTS FOR THOSE WITH BACKPRESSURE APPLIED
:
	LHI	R5,(NGRP-1)*2	:
	LHI	R6,(NGRP-1)*10	:SET UP POINTERS
RBP1	LCS	R7,1		:
	XH	R7,FRISIS,R5	:CHECK IF BACKPRESSURE APPLIED
	NH	R7,ACP,R5	:AND PORT ACTIVE
RBP2	LR	R1,R7		:TEST
	JNFS	RBP3		:SKIP.. SOMETHING TO DO
	SIS	R5,2		:DECREMENT POINTERS
	SHI	R6,10		:
	JGEBS	RBP1		:CHECK NEXT RING GROUP
	J	TORET		:OTHERWISE RETURN
:
RBP3	JAL	R3,BIDH		:DETERMINE WHICH PORT ON GROUP NEEDS SERVICE
	XH	R7,HMASK,R2,R2	:MARK PORT AS SERVICED
	AR	R2,R6		:FORM PORT NUMBER
	LR	RPORT,R2		:COPY IT
	SLHLS	R2,2		:FORM BUFFER NUMBER
	GETDCB			:GET DCB POINTER FROM PORT TABLE
	LH	R0,DCBREF(DCBICC)	:GET INPUT CHAR COUNT
	SHI	R0,MAXCHAR	:TEST IF LESS THAN MAXCHAR
	JG	RBP2		:NOT EMPTY ENOUGH YET
	SBT	RPORT,FRISIS	:RELEASE BACKPRESSURE
	LIS	R0,3		:FORM 3 BYTE MESSAGE
	LHI	R2,SNDMSG	:GET MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	J	RBP2		:AND CONTINUE
  EI
  IF	PTIMEO
:
:		CODE TO CHECK PERIODICALLY FOR PORT TIMEOUTS
:
ONESEC	AHI	R1,RATE		:SET UP TO RUN AGAIN IN ONE SECOND
	JAL	R5,TOPUT	:
	LHI	R15,(NGRP*2)-2	:SEARCH BY GROUPS
OS1	LH	R14,ACP,R15	:GET ACTIVE PORT INDICATORS
	NH	R14,PTIME,R15	:AND IN PORTS ON TIMEOUT
	JNFS	OS3		:JUMP IF ANY TO CHECK
OS2	SIS	R15,2		:DECREMENT GROUP INDEX
	JGEBS	OS1		:REPEAT IF MORE
	J	TORET		:OTHERWISE EXIT
:
OS3	LR	R1,R14		:COPY MASK OF PORTS TO PROCESS
	JEBS	OS2		:NONE... GO ON TO NEXT GROUP
	JAL	R3,BIDH		:FIND FIRST
	XH	R14,HMASK,R2,R2	:SET IT EXAMINED
	LR	R1,R15		:COPY GROUP INDEX
	SLHLS	R1,3		:MAKE GROUP INDEX INTO PORT OFFSET
	AR	RPORT,R2	:MAKE PORT NUMBER
	LR	R2,RPORT	:COPY PORT NUMBER
	SLHLS	R2,2		:MAKE INTO FULLWORD INDEX
	L	R0,ATIME,R2	:GET ACTIVATION TIME
	S	R0,SLOWC,,	:SUBTRACT CURRENT TIME
	JG	OS3		:NOT READY.. IGNORE FOR NOW
	GETDCB			:GET DCB POINTER
	JNFS	OS4		:SKIP IF GOT A DCB
OSCR	JAL	R10,CRASH	:CRASH
	BC	0,0,4*RDCB,CRNAR	:NO ACTIVATION ROUTINE
:
OS4	LHL	R4,DCBREF(ACTIVT)	:GET ACTIVATION ROUTINE
	JEBS	OSCR		:CRASH IF NO ROUTINE
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	STM	R14,TSAVE	:PRESERVE WORK REGISTERS
	JAL	R4,ACTIV	:ACTIVATE
	LM	R14,TSAVE	:RESTORE WORK REGISTERS
	J	OS3		:GO BACK FOR MORE
:
:	SET AND CLEAR TIMEOUT ROUTINES
:		LINK ON R4
:		EXPECT R1 = PORT NUMBER
:		       R0 = TIMEOUT INTERVAL IN SECONDS (SETTO)
:		SMASHES R0
:
	GL	SETTO,CLRTO
:
SETTO	SBT	RPORT,PTIME	:SET PORT TIMEOUT INDICATOR
	A	R0,SLOWC,,	:ADD TO CURRENT TIME
	SLHLS	RPORT,2		:MAKE INTO FULLWORD POINTER
	ST	R0,ATIME,RPORT	:STORE TIME
	SRHLS	RPORT,2		:MAKE BACK INTO PORT NUMBER
	JR	R4		:AND RETURN
:
CLRTO	RBT	RPORT,PTIME	:RESET PORT TIMEOUT INDICATIOR
	JR	R4		:AND RETURN
  EI
:

:	CONTROL MESSAGE ACTIVATION ROUTINES
:
:	TOSS A MESSAGE
TOSS	LB	R0,LENGTH,R2	:PICK UP MESSAGE LENGTH
	SIS	R0,1		:WE'VE ALREADY GOTTEN MESSAGE TYPE
toss1   AR      R14,R0          :ADVANCE POINTER TO END OF MSG
	JR	R5		:RETURN
:
:	ZAPPER ACKNOWEDGEMENT
:
ZACK	EQ	.
:
:	DISCONNECT
ZAP	JAL	R4,EMPTYI	:EMPTY INPUT BUFFER
	JAL	R4,EMPTYO	:EMPTY OUTPUT BUFFER
	RBT	RPORT,ACP	:SET PORT NOT ACTIVE
	RBT	RPORT,DEM	:SET PORT NOT IN DEM
	JR	R5		:RETURN
:
:	APPLY BACKPRESSURE
NOSEND	RBT	RPORT,TOISIS	:TURN IT OFF FOR PORT
	JR	R5		:RETURN
:
:	RELEASE BACKPRESSURE
RESEND	SBT	RPORT,TOISIS	:TURN IT ON FOR PORT
	JR	R5		:RETURN
:
:	GOBBLER
GOBBLE	JAL	R4,EMPTYI	:EMPTY INPUT BUFFER
	SBT	RPORT,FRISIS	:RELEASE BACKPRESSURE
	JR	R5		:AND RETURN
:
:	FLUSH BACKWARD
FLBACK	JAL	R4,EMPTYO	:EMPTY OUTPUT BUFFER
	LIS	R0,3		:SEND GOBBLER IN OTHER DIRECTION
	LHI	R2,GOBMSG	:CREATE MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	ENTER DEM
EDEM	SBT	RPORT,DEM	:SET INDICATOR
	JR	R5		:RETURN

:
:	LEAVE DEM
LDEM	RBT	RPORT,DEM	:CLEAR INDICATOR
	JR	R5		:RETURN
:

:	GREEN BALL
GB	LIS	R0,3		: RETURN GREEN BALL
	LHI	R2,GBMSG	:CREATE MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	RED BALL
RB	LIS	R0,3		:RETURN THE RED BALL
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	ORANGE (OR BLACK) BALL
OB	LIS	R0,3		:CREATE MESSAGE
	LHI	R2,1,R2		:CREATE OTHER BALL OF PAIR
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	PSUEDO-NEEDLE
PNEED	LB	R0,LENGTH,R2	:JUST TOSS IT
	SIS	R0,1		:WE ALREADY GOT MSG TYPE
	AR	R14,R0		:ADVANCE POINTER TO END OF MSG
	LHI	R0,FIRST-1	:SET UP DEFAULT TRANSMIT LIMIT
	STB	R0,XLIMIT,RPORT	:
	SBT	RPORT,ACP	:SET PORT ACTIVE
	SBT	RPORT,TOISIS	:CLEAR BACKPRESSURE
	SBT	RPORT,FRISIS	:
	JR	R5		:AND RETURN
:
:	TRANSMIT LIMIT
XLIM	JAL	R4,GETCH	:GET RESTRICTION
	CLHI	R0,FIRST-1	:RANGE CHECK
	JLFS	XLIM1		:OK...SKIP
	LHI	R0,FIRST-1	:OTHERWISE SET LIMIT
XLIM1	STB	R0,XLIMIT,RPORT	:SET UP RESTRICTION
	JR	R5		:AND RETURN
:
:	INVALID MESSAGE
INVAL	JAL	R10,CRASH
	BC	0,0,4*R5,CRINVM
 IF	OUTPROC

:	OUTPUT PROCESS ROUTINE
:
OUTPUT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
	LHI	R11,(NGRP-1)*2	:LOOP COUNTER
OUTP1	LCS	R1,1		:SET UP MASK
	STH	R1,PRTSVC	:SAVE PORT SERVICED MASK
OUTP2	LHL	R1,ACP,R11	:GET ACTIVE PORTS INDICATOR
	NH	R1,OUTDAT,R11	:AND WITH DATA WAITING INDICATOR
	NH	R1,TOISIS,R11	:AND NOT BACKPRESSURED
	NH	R1,PRTSVC	:AND NOT ALREADY SERVICED
	JNFS	OUTP3		:SKIP IF ANYTHING TO DO
	SIS	R11,2		:DECREMENT LOOP COUNTER
	JGEBS	OUTP1		:LOOP
	J	RET		:DONE... RETURN
:
OUTP3	JAL	R3,BIDH		:FIND PORT TO SERVICE
	LR	R1,R11		:COPY PORT OFFSET
	SLHLS	R1,3		:TIMES EIGHT
	AR	RPORT,R2	:PORT NUMBER!
	RBT	R2,PRTSVC	:CLEAR PORT TO BE SERVICED BIT
	GETDCB			:GET DCB POINTER FOR PORT
	JEFS	OUTCR			:CRASH NO DCB POINTER
	LHL	R4,DCBREF(ACTIVO)	:GET OUTPUT ACTIVATION ROUTINE
	JNFS	OUTP4			:GOT A ROUTINE...SKIP
:
OUTCR	JAL	R10,CRASH
	BC	0,0,4*RDCB,CRNAR	:NO ACTIVATION ROUTINE
:
OUTP4	STH	R11,SLOOP	:SAVE LOOP COUNTER
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	LHL	R11,SLOOP	:RESTORE LOOP POINTER
	J	OUTP2		:LOOP
:
 EI
:	DEFAULT CONTROL MESSAGE ACTIVATION TABLES
:
:	CALCULATE ROUTINE OFFSETS
:
XTOSS	EQ	TOSS-SEG|A.CODE|
XZAP	EQ	ZAP-SEG|A.CODE|
XZACK	EQ	ZACK-SEG|A.CODE|
XNOSEND	EQ	NOSEND-SEG|A.CODE|
XRESEND	EQ	RESEND-SEG|A.CODE|
XGOBBLE	EQ	GOBBLE-SEG|A.CODE|
XFLBACK	EQ	FLBACK-SEG|A.CODE|
XEDEM	EQ	EDEM-SEG|A.CODE|
XLDEM	EQ	LDEM-SEG|A.CODE|
XGB	EQ	GB-SEG|A.CODE|
XRB	EQ	RB-SEG|A.CODE|
XOB	EQ	OB-SEG|A.CODE|
XPNEED	EQ	PNEED-SEG|A.CODE|
XXLIM	EQ	XLIM-SEG|A.CODE|
XINVAL	EQ	INVAL-SEG|A.CODE|
:
:	TABLE CREATION MACROS
:
HTABVT	MACRO(TABNAM)
[	SEG	A.CODE
	GL	TABNAM
TABNAM	HC	XZAP,XZAP,XNOSEND,XRESEND,XGOBBLE,XFLBACK	:9E - A3
	HC	XOB,XTOSS,XEDEM,XLDEM,XTOSS,XTOSS		:A4 - A9
	HC	XGB,XRB,XOB,XTOSS,XTOSS,XTOSS			:AA - AF
	HC	XTOSS,XTOSS,XINVAL,XINVAL,XTOSS,XTOSS		:B0 - B5
	HC	XTOSS,XINVAL,XTOSS,XXLIM,XTOSS,XZACK		:B6 - BB 
	HC	XTOSS,XTOSS,XINVAL,XTOSS,XTOSS			:BC - C0
]
:
HTABIA	MACRO(TABNAM)
[	SEG	A.CODE
	GL	TABNAM
TABNAM	HC	XZAP,XZAP	:9E - 9F
	RE	0B1-9F
	HC	XTOSS
	NOLIST
	ER
	LIST
	HC	XPNEED,XINVAL	:B2 - B3
	HC	XTOSS,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS		:B4 - B9
	HC	XTOSS,XZACK,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS	:BA - C0
]
:
CHGTAB	MACRO(TABNAM,MSGNUM,ROUTIN)
[
OLDORG	EQ	.
	ORG	TABNAM+(MSGNUM-FIRST)*2
	HC	ROUTIN-SEG|A.CODE|
	ORG	OLDORG
]
	EM
:


        SUBTTL CMTI ... CMT front end interface

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 JUL 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        GL      LENGTH                  :Table in FRNTND used in ACTIVM
        GL      LOGST                   :Log on routines
        GL      ENDIT,RESTAR            :Routines in TERM used by ACTIVZ
        SEG     A.CODE                  :Segment to contain this module
        MO      .,CMTI                  :Delimit module
:
: This module contains routines that interface with the ring input
: handling routines in FRNTND.LIB
:
:       ACTIV0 - Called by FRNTND to action port 0 messages
:       ANSHST - Send host status report
:       ACTIVN - Needle activation routine
:       ACTIVP - Pseudo needle activation routine
:       INIDCB - Initialise DCB
:       DATACT - Data activation routine
:       ACTIVM - Control message activation routine
:       ACTIVZ - Process zap messages
:       SETXLT - Process set transmit limit command
:       BPON - Process apply backpressure command
:       BPOFF - Process release backpressure command
:       SNDPNR - Send pseudo needle request
:       SNDNLC - Send normal logon character
:       ECHOFF - Send echo off, echo on
:       SNDZAP - Send zapper
:       SNDDET - Send detach
:       SNDGB - Send green ball
:       SNDRB - Send red ball
:       SNDGRB - Send grey ball
:       SNDSIX - Send start IIX
:       SNDTIX - Send end IIX
:       SNDBPO - Send apply back pressure
:       SNDBPX - Send release back pressure
:
: There are no macros unique to this module.
        SUBTTL CMTI - Control table definitions
:
: Function      Sets up control message activation tables which specify
:               the offsets of routines that will process the various
:               control messages.
:
: ---------------------------------------------------------------------
:
        LO      FRNTND                  :Make FRNTND variables local
:
: Control table for inactive ports - FRNTND handles everything except 
: pseudo needles.
:
        HTABIA(ACTCIP)                  :Create default table for inactive port
        CHGTAB(ACTCIP,0B2,ACTIVP)       :Handle pseudo needle requests
:
: Control table for terminal DCB in logon state
:
        HTABVT(ACTCLT)                  :Create default table for virtual
                                        : terminal
        CHGTAB(ACTCLT,09E,ACTIVZ)       :Detach enters zap code
        CHGTAB(ACTCLT,09F,ACTIVZ)       :Zap message
:
: Control table for terminal DCB in normal state
:
        HTABVT(ACTCNT)                  :Create default table for virtual
                                        : terminal
        CHGTAB(ACTCNT,09E,ACTIVZ)       :Detach enters zap code
        CHGTAB(ACTCNT,09F,ACTIVZ)       :Zap message
        CHGTAB(ACTCNT,0A0,BPON)         :Apply backpressure
        CHGTAB(ACTCNT,0A1,BPOFF)        :Release backpressure
        CHGTAB(ACTCNT,0A6,ACTIVM)       :Entering DEM
        CHGTAB(ACTCNT,0A7,ACTIVM)       :Leaving DEM
        CHGTAB(ACTCNT,0AA,ACTIVM)       :Green ball
        CHGTAB(ACTCNT,0AB,ACTIVM)       :Red ball
        CHGTAB(ACTCNT,0B9,SETXLT)       :Set transmit limit
:
: Control table for host DCB in logon state
:
        HTABVT(ACTCLH)                  :Create default table for virtual
                                        : terminal
        CHGTAB(ACTCLH,09E,ACTIVZ)       :Detach enters zap code
        CHGTAB(ACTCLH,09F,ACTIVZ)       :Zap message
        CHGTAB(ACTCLH,0A0,BPON)         :Apply backpressure
        CHGTAB(ACTCLH,0A1,BPOFF)        :Release backpressure
                                        :All the following messages are
                                        : placed in input buffer by ACTIVM
        CHGTAB(ACTCLH,0A4,ACTIVM)       :Black ball
        CHGTAB(ACTCLH,0B4,ACTIVM)       :Normal logon status
        CHGTAB(ACTCLH,0B5,ACTIVM)       :Logon fail
        CHGTAB(ACTCLH,0B6,ACTIVM)       :Successful logon
        CHGTAB(ACTCLH,0BF,ACTIVM)       :SIIX
        CHGTAB(ACTCLH,0C0,ACTIVM)       :TIIX
:
        FO      FRNTND                  :Make FRNTND variables foriegn

        SUBTTL ACTIV0 routine ... Action port 0 messages
:
: Routine name  ACTIV0
:
: Function      Action port 0 messages received by FRNTND
:
: Called by     FRNTND
:
: On entry      Link register R5
:
: On exit       No registers will have been preserved
:
: Uses          GETCH, GETH, GETW in FRING.LIB
:               ANSHST in this module
:
: ---------------------------------------------------------------------
:
        DEFGEQ(ACTIV0,.)
        CHI     R2,10                   :Legal msg type
        JG      POM30                   :Jump if not to crash
        SLHLS   R2,2                    :Make R2 into index
        J       P0MSG,R2                :Process msg by type
: 
: P0MSG - Jump table for port 0 msgs
:
P0MSG   J       POM10                   : Type 0 restart request
        J       POM10                   : Type 1 restart response
        J       ANSHST                  : Type 2 node has been taken over
        J       POM30                   : Type 3 report to sup log
        J       POM30                   : Type 4 report host status
        J       POM30                   : Type 5 report accounting
        J       POM20                   : Type 6 tell host time
        J       POM30                   : Type 7 psuedo-needle request
        J       POM30                   : Type 8 aux circuit request
        J       POM50                   : Type 9 unable to provide
                                        :        psuedo needle
        J       POM30                   : Type A report host availability
        J       POM30                   : Type B host unacceptable
        J       POM30                   : Type C report host cost
        J       POM10                   : Type D no supervisor
        J       POM10                   : Type E 1 down
        J       POM30                   : Type F report all hosts
        J       POM30                   : Type 10 extended report host status
:
:    Discard message
:
POM10   JR      R5                      :Just return
:
:    Message type 6, read message and discard
:
POM20   JAL     R4,GETCH,,              :Skip character
        JAL     R4,GETW,,               :Skip GMT
        JR      R5                      :Return
:
:    Crash as message should not be received
:
POM30   CRUNCH(CRIPOM)          
:
:    Message type 9, read message, indicate to DCB requesting needle that
:    request has failed.
:
POM50   JAL     R4,GETCH,,              :Discard ISIS key
        JAL     R4,GETH,,               :Get local key
        LHI     R9,DCBSIZ
        MHR     R0,R9                   :Convert key into DCB address
        AI      R0,DCBLKS
        LR      R12,R0
        LHL     R0,DSUSP,R12
        CHI     R0,SUSPN                :Are we waiting for pseudo needle
        JN      POM60                   :J if not
        LIS     R0,0
        STH     R0,DPORT,R12            :Indicate no port allocated
        STH     R0,DSUSP,R12            :Clear suspension
        LHL     R0,DCBNO,R12
        SBT     R0,RUNREQ               :Mark for running
POM60   JR      R5                      :Return


        SUBTTL ANSHST routine ... Send host status report
:
: Routine name  ANSHST
:
: Function      Send an extended host status report type hex 10 to
:               slot 0
:
: Called by     ACTIV0, EXEC
:
: On entry      Link register R5
:
: On exit       No registers will have been preserved
:
: Uses          SLOR, PUTCH, PUTH, PUTW, ELOR in FRING.LIB
:
: ---------------------------------------------------------------------
:
        DEFGEQ(ANSHST,.)
        LIS     R0,$A14                 :14 byte message
        LIS     R1,0                    :For port 0
        LHI     R2,10                   :Message type hex 10 host status
        JAL     R4,SLOR                 :Start output to ORING
        LIS     R0,0                    :Null key
        JAL     R4,PUTCH
        LHI     R0,HOSTNO               :CMT host number
        JAL     R4,PUTH
        LHI     R0,NCCB                 :Number of users supported
        JAL     R4,PUTH
        LIS     R0,0                    :Relative host number 0
                                        :Status 0 - host answered
                                        :Host key 0
        JAL     R4,PUTW
        LHI     R0,PRODID               :Product Id, Not Intelligent - AUG88
        JAL     R4,PUTH
        JAL     R4,ELOR                 :End the status report
        JR      R5                      :Return
:
:

        SUBTTL ACTIVN routine ... Action needle messages
:
: Routine name  ACTIVN
:
: Function      Action needle control message. Needle received when
:               user logs to CMT. Create CCCB and allocate buffers. 
:               Find user profile. Start DCB at LOGON routine.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number in R1
:               Number of characters in username in R2
:
: On exit       No registers will have been preserved
:
: Uses          GETCH, GETH, GETW in FRING.LIB
:               GETIOB, GETCCB in CBDEF
:               INIDCB in this module
:
: ---------------------------------------------------------------------
:
        DEFGEQ(ACTIVN,.)
        TRACK(ACTIVN)
        LR      R3,R1                   :Move port number to R3
        SLLS    R1,2                    :Get inactive DCB address
        L       R12,PORTAB,R1
        L       R13,DSTCKP,R12          :Get inactive DCB stack
        PUSH(R5)
:
        CALL(GETCCB)                    :Get a CCB 
        LR      R11,R5                  :Standard is R11 equals CCB
:
: Set up CCB to initial values
:
        LIS     R1,0
        ST      R1,CHDCB,R11            :Flag no host DCB
        ST      R1,CPDCB,R11            :   or printer DCB
        ST      R1,CBITS,R11            :Clear all bit flags
        ST      R1,CTPROF,R11           :Flag no terminal profile table
        ST      R1,CUPROF,R11           :   or user profile table
        ST      R1,CSCNBF,R11           :   or screen buffer
:
: Now extract first N characters of username and save in CCB. If there are 
: less than N then we fill with nulls (hex 80). This code is copied from
: CMT/3270. Remember, R2 contains no of characters in username! 
:
	LI	R6,0
        SI      R6,UPFULN               :Bring in up to N characters
        JAL     R4,GETCH,,              :   of the username
        OHI     R0,80                   :Ensure mark parity
        CHI     R0,0A1
        JN      ACTN10                  :J if not override logon char
        JAL     R4,GETCH,,              :Next character
        OHI     R0,80
        SIS     R2,1
:
ACTN10  CHI     R0,A.SEMI+80            :Check for terminating semicolon
        JE      ACTN20
        CHI     R0,A.CR!80              :Check for terminating CR's
        JE      ACTN20
        STB     R0,CUNAME+UPFULN,R11,R6      :Save character in CCB
        AIS     R6,1                    :Out of output space?
        JE      ACTN50
ACTN20  SIS     R2,1                    :Out of input data?
        JEFS    ACTN30
        JAL     R4,GETCH,,              :Next character
        OHI     R0,80                   :Ensure mark parity
        J       ACTN10
:
ACTN30  LHI     R0,80                   :We ran out of input data first
ACTN40  STB     R0,CUNAME+UPFULN,R11,R6      :Fill in with 80's
        AIS     R6,1
        JNBS    ACTN40
        JFS     ACTN60
ACTN50  SIS     R2,1                    :Ran out of space flush
        JLEFS   ACTN60                  :away balance of msg
        LR      R0,R2                   :and proceed
        JAL     R4,FLUSH,,
:
: Now set up an active DCB to control this port
:
ACTN60  LA      R4,LOGST,,              :Start DCB running at LOGST
        CALL(INIDCB)                    :Create and initialise DCB
        ST      R5,CTDCB,R11            :R5 is DCB address from INIDCB
        LA      R0,DATACT               :Load new data activation address
        STH     R0,DDACT,R5
        LA      R0,ACTCLT               :Load new control message table
        STH     R0,DCACT,R5
        LHI     R0,DTTERM
        STH     R0,DTYPE,R5             :Marrk as terminal DCB
        SLHLS   R3,2                    :Convert port into FW index
        ST      R5,PORTAB,R3            :Make this the DCB for port
        POP(R5)                         :Restore link register
        JR      R5                      :Return to FRNTND

        SUBTTL ACTIVP routine ... Process pseudo needle
:
: Routine name  ACTIVP
:
: Function      Action a pseudo needle message. Use local key to find
:               DCB and check that needle is still valid. If it is 
:               we must set up ACP, TOISIS, FRISIS and XLIMIT arrays
:               as FRNTND doesn't do so for pseudo needles. We then
:               re-activate DCB.
:               Otherwise zap the needle.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number in R1
:               DCB address is in R12
:
: On exit       All registers will have been preserved
:
: Uses          GETCH, GETH in FRING
:
: ---------------------------------------------------------------------
:
        DEFGEQ(ACTIVP,.)
        SBT     R1,ACP                  :Test and set active port bit
        JEFS    ACTP20                  :Jump if inactive
        CRUNCH(CRINVP)                  :Crash invalid pseudo needle
:
ACTP20  JAL     R4,GETCH,,              :Get past ISIS - Tymnet key
        JAL     R4,GETH,,               :Get local key - requesting DCB
        LHI     R9,DCBSIZ
        MHR     R0,R9                   :Convert key into DCB address
        AI      R0,DCBLKS
        LR      R12,R0
        LHL     R0,DSUSP,R12
        CHI     R0,SUSPN                :Are we waiting for pseudo needle
        JN      ACTP80                  :If not then jump to zap it
        LHI     R0,9D                   :Set default transmit limit
        STB     R0,XLIMIT,R1
        STH     R0,DXLIM,R12
        SBT     R1,TOISIS               :Clear backpressure
        SBT     R1,FRISIS
        STH     R1,DPORT,R12            :Store port number in DCB
        LA      R0,DATACT               :Load new data activation address
        STH     R0,DDACT,R12
        LA      R0,ACTCLH               :Load new control message table
        STH     R0,DCACT,R12
:
        SLHLS   R1,2                    :Convert port into index
        ST      R12,PORTAB,R1           :Link this DCB to the port
        LIS     R0,0
        STH     R0,DSUSP,R12            :Clear suspension
        LHL     R0,DCBNO,R12
        SBT     R0,RUNREQ               :Mark for running
        JR      R5                      :Return to FRNTND
:
: Deal with pseudo needle for DCB not waiting
:
ACTP80  CRUNCH(CRNOCO)

        SUBTTL INIDCB routine ... Initialise a DCB 
:
: Routine name  INIDCB
:
: Function      Initialise a DCB for a newly active port.
:
: Called by     ACTIVN in this module
:               LOGST in TERM
:
: On entry      Link register R1
:               Port number in R3
:               User code address in R4
:
: On exit       DCB address in R5
:
: Uses          DCBGET in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(INIDCB)
        CALL(DCBGET)
        LA      R1,DSTCK+$A40,R5        :Initialise stack
        ST      R1,DSTCKP,R5
        ST      R11,DCCB,R5             :DCB points to CCB
        STH     R3,DPORT,R5             :Associated port
        LIS     R1,0
        STH     R1,DBITS,R5             :Initialise control bits
        STH     R1,DSUSP,R5             :Not waiting
        ST      R1,DSCNBF,R5            :No screen buffer
        STH     R1,DRXCNT,R5            :Receive buffer count zero
        LHI     R1,DMLGST
        STH     R1,DMODE,R5             :Logon start up mode
        LB      R1,XLIMIT,R3
        STH     R1,DXLIM,R5             :Transmit limit
:
        LA      R1,DNETIP,R5            :Set network input buffer ring empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LA      R1,DNETOP,R5            :Set network output buffer empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LA      R1,DIPBIA,R5            :Set IPB input buffer ring empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LA      R1,DIPBIB,R5            :Set IPB input buffer ring empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LA      R1,DIPBOP,R5            :Set IPB output buffer empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LHL     R1,DCBNO,R5             :DCB number
        SBT     R1,RUNREQ               :Mark for running
        ST      R4,DUSR,R5              :Save user start address
        RETURN

        SUBTTL DATACT routine ... Data activation routine
:
: Routine name  DATACT
:
: Function      Process data message received for an active port.
:               Store in input buffer and if DCB waiting input then
:               mark for running. If port is inactive we only 
:               FLUSH message.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message size in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          GETIOB in CBDEF
:               FLUSH, GETCH in FRING
:
: ---------------------------------------------------------------------
:
        DEFGEQ(DATACT,.)
        TBT     R1,ACP  
        JNFS    ACTD10                  :Jump if port is active
        LR      R0,R2                   :Count of bytes in message
        JAL     R4,FLUSH,,              :Throw message away
        J       ACTD80                  :Return
:
ACTD10  AHM     R2,DRXCNT,R12           :Increment receive buffer count
        L       R13,DSTCKP,R12          :Get stack pointer
        PUSH(R5)                        :Save link
        LA      R4,DNETIP,R12
        L       R5,CHNBWD,R4            :Have we got a buffer
        CR      R4,R5   
        JEFS    ACTD20                  :Jump if we have none
        LB      R3,BFILL,R5             :Current fill pointer
        J       ACTD40                  :Put data in buffer
:
ACTD20  CALL(GETIOB)                    :Get a buffer in R5
        L       R3,CHNBWD,R4
        ST      R5,CHNBWD,R4            :Chain it to input ring
        ST      R5,CHNFWD,R3
        ST      R4,CHNFWD,R5
        LIS     R3,0                    :Initialise pointers
        STB     R3,BFILL,R5
        STB     R3,BEMPTY,R5
:
ACTD40  LR      R2,R2
        JE      ACTD60                  :Jump if end of input
        JAL     R4,GETCH,,              :Get next character from ORING
	LHL	R1,DTYPE,R12
	CHI	R1,DTTERM
	JN	ACTD50			:J if not terminal data otherwise
        NHI     R0,7F                   :Make sure top bit is clear
ACTD50  STB     R0,BDATA,R5,R3          :Put data in buffer
        SIS     R2,1                    :Reduce character count
        AIS     R3,1                    :Increment fill pointer
        CHI     R3,BSIZE-BDATA
        JN      ACTD40                  :Buffer not full get next character
        STB     R3,BFILL,R5             :Save fill pointer
        LA      R4,DNETIP,R12           :Head of chain
        J       ACTD20                  :Get new buffer
:
ACTD60  STB     R3,BFILL,R5             :Save fill pointer
        LHL     R5,DRXCNT,R12           :Number of characters in input buffer
        CHI     R5,BPONL
        JL      ACTD70                  :J if below back pressure limit
        LHL     R5,DPORT,R12
        RBT     R5,FRISIS
        JE      ACTD70                  :J if already backpressured
        CALL(SNDBPO)                    :Apply back pressure
ACTD70  POP(R5)                         :Restore link register
        ST      R13,DSTCKP,R12          :Save stack pointer
        LHL     R3,DSUSP,R12            :Is this DCB waiting input
        CHI     R3,SUSIP
        JN      ACTD80                  :Jump if not
        LIS     R3,0                    :Mark as not waiting
        STH     R3,DSUSP,R12
        LHL     R3,DCBNO,R12            :Mark as runnable
        SBT     R3,RUNREQ
ACTD80  JR      R5                      :Return

        SUBTTL ACTIVM routine ... Control message activation routine
:
: Routine name  ACTIVM
:
: Function      Process control messages received for an active port.
:               Store in input buffer and if DCB waiting input then
:               mark for running. Routine is completed at ACTD60 in
:               DATACT.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          GETIOB in CBDEF
:               GETCH in FRING
:
: ---------------------------------------------------------------------
:
: Note we have to take into account that first character (Message type)
: is already extracted from ring in R2. We move it to R0 and then check
: if we have space for it. We must then extract the next character,
: if one exists, before checking if we have space for it.
:
        DEFGEQ(ACTIVM,.)
ACTM10  L       R13,DSTCKP,R12          :Get stack pointer
        PUSH(R5)                        :Save link
        LR      R0,R2                   :Save message type in R0
        LB      R2,LENGTH,R2,           :Get length of message
	AHM	R2,DRXCNT,R12
        LA      R4,DNETIP,R12
        L       R5,CHNBWD,R4            :Have we got a buffer
        CR      R4,R5   
        JEFS    ACTM20                  :Jump if we have none
        LB      R3,BFILL,R5             :Current fill pointer
        J       ACTM40                  :Put message in buffer
:
ACTM20  CALL(GETIOB)                    :Get a buffer in R5
        L       R3,CHNBWD,R4
        ST      R5,CHNBWD,R4            :Chain it to input ring
        ST      R5,CHNFWD,R3
        ST      R4,CHNFWD,R5
        LIS     R3,0                    :Initialise pointers
        STB     R3,BFILL,R5
        STB     R3,BEMPTY,R5
:
ACTM40  LR      R2,R2
        JE      ACTD60                  :Jump if end of input
        STB     R0,BDATA,R5,R3          :Put message in buffer
        SIS     R2,1                    :Reduce character count
        JE      ACTM50                  :Jump if end of message
        JAL     R4,GETCH,,              :Get next character from ORING
ACTM50  AIS     R3,1                    :Increment fill pointer
        CHI     R3,BSIZE-BDATA
        JN      ACTM40                  :Buffer not full get next character
        STB     R3,BFILL,R5             :Save fill pointer
        LA      R4,DNETIP,R12           :Head of chain
        J       ACTM20                  :Get new buffer

        SUBTTL ACTIVZ routine ... Circuit zapped message
:
: Routine name  ACTIVZ
:
: Function      Process zapped circuit (9E) and detach (9F) control messages.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
ACTIVZ  SLHLS   R1,2                    :Find DCB
        L       R12,PORTAB,R1
        LIS     R0,0
        STH     R0,DPORT,R12            :Indicate no port
        LHL     R3,DTYPE,R12
        LA      R0,ENDIT,,              :If term zapped, go to ENDIT it TERM
        CHI     R3,DTTERM
        JE      ACTZ10                  :J if lost terminal circuit
        LA      R0,RESTAR,,             :Restart routine in TERM
ACTZ10  ST      R0,DUSR,R12
        LIS     R0,0
        STH     R0,DSUSP,R12            :Clearing waiting state
        LHL     R9,DCBNO,R12
        SBT     R9,RUNREQ               :Mark for running
        LA      R13,DSTCK,R12           :Reset stack with zapped message on it
        LA      R4,ZAPMES
        PUSH(R0,R1,R2,R3,R4,R5,R6,R7)
        PUSH(R8,R9)
        JR      R5                      :return to FRNTND

        SUBTTL SETXLT routine ... Set transmit limit message handler
:
: Routine name  SETXLT
:
: Function      Process set transmit limit control message (B9) for
:               active port. Update the limit held in XLIMIT array and
:               DCB. 
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          GETCH in FRING
:
: ---------------------------------------------------------------------
:
        DEFGEQ(SETXLT,.)
        JAL     R4,GETCH,,              :Get limit character from ORING
        STB     R0,XLIMIT,R1            :Store in limit array
        TBT     R1,TOISIS
        JE      SETX20                  :If backpressured don't touch DCB
        STH     R0,DXLIM,R12            :Store in DCB
SETX20  JR      R5                      :Return to FRNTND

        SUBTTL BPON routine ... Process apply backpressure message
:
: Routine name  BPON
:
: Function      Process apply backpressure control message (A0) for
:               active port. Update the array TOISIS and set the transmit
:               limit in the DCB to zero. 
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        DEFGEQ(BPON,.)
        RBT     R1,TOISIS               :Mark as backpressured
        JR      R5                      :Return to FRNTND

        SUBTTL BPOFF routine ... Process release backpressure message
:
: Routine name  BPOFF
:
: Function      Process release backpressure control message (A1) for
:               active port. Update the array TOISIS and set the transmit
:               limit in the DCB to value held in XLIMIT array. If DCB
:               is suspended awaiting release of backpressure then activate
:               it.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        DEFGEQ(BPOFF,.)
        SBT     R1,TOISIS               :Mark as backpressure cleared
        LHL     R0,DSUSP,R12            :Waiting reason
        CHI     R0,SUSBP
        JN      BPOF20                  :J if not waiting release of BP
        LIS     R0,0                    :Mark as not waiting
        STH     R0,DSUSP,R12
        LHL     R0,DCBNO,R12            :Mark as runnable
        SBT     R0,RUNREQ
BPOF20  JR      R5                      :Return to FRNTND

        SUBTTL EMPTYI/EMPTYO routine ... Empty buffers on zap
:
: Routine name  EMPTYI/EMPTYO
:
: Function      Empty input I/O buffer. Called by FRNTND when it 
:               receives a zap for a circuit. Does nothing.
:
: Called by     FRNTND
:
: On entry      Link register R5
:
: On exit       No registers will have been preserved
:
: Uses          GETCH, GETH, GETW in FRING.LIB
:               
:
: ---------------------------------------------------------------------
:
EMPTYI  EQ      .
EMPTYO  JR      R4                      :No code yet so crash

        SUBTTL SNDSTP routine ... Send set terminal parameter
:
: Routine name  SNDSTP
:
: Function      To send a set terminal parameter
:
: Called by     LOGST
:
: On entry      Link register R1
:               Parameter pair as halfword in R5
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, PUTCH, ELOR in FRING
:
: ---------------------------------------------------------------------
:
        RSTART(SNDSTP)
        PUSH(R0,R2,R3,R4)               :Save registers
        LIS     R0,4                    :Message length
        LHL     R1,DPORT,R12            :Port 
        LHI     R2,0B1                  :Message type (normal logon char)
        JAL     R4,SLOR,,
        LR      R0,R5                   :Parameter pair
        SRHL    R0,8
        JAL     R4,PUTCH,,
        LR      R0,R5                   :Second parameter
        JAL     R4,PUTCH,,
        JAL     R4,ELOR,,               :End output
        POP(R4,R3,R2,R0)                :Restore registers
        RETURN

        SUBTTL SNDPNR routine ... Request pseudo needle
:
: Routine name  SNDPNR
:
: Function      To send a pseudo needle request to slot 0.
:
: Called by     LOGST
:
: On entry      Link register R1
:               Local key in R5
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, PUTCH, PUTH, ELOR in FRING
:
: ---------------------------------------------------------------------
:
        RSTART(SNDPNR)
        PUSH(R0,R2,R3,R4)               :Save registers
        LIS     R0,0B                   :Message length
        LIS     R1,0                    :Port zero
        LIS     R2,7                    :Message type (request pseudo needle)
        JAL     R4,SLOR,,               :Start output
        LIS     R0,0                    :Despatcher key
        JAL     R4,PUTCH,,
        LR      R0,R5                   :Local key
        JAL     R4,PUTH,,
        LHI     R0,8000!4000            :Intelligent & extended login status
        JAL     R4,PUTH,,
        LHI     R0,HOSTNO               :We are originating host
        JAL     R4,PUTH,,
        LHI     R0,0D1                  :Circuit characteristic type
        JAL     R4,PUTCH,,
        JAL     R4,ELOR,,               :End output
        POP(R4,R3,R2,R0)                :Restore registers
        RETURN

        SUBTTL SNDNLC routine ... Send normal logon character
:
: Routine name  SNDNLC
:
: Function      To send a normal logon character to the network
:
: Called by     LOGST
:
: On entry      Link register R1
:               Logon character in R5
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, PUTCH, ELOR in FRING
:
: ---------------------------------------------------------------------
:
        RSTART(SNDNLC)
        PUSH(R0,R2,R3,R4)               :Save registers
        LIS     R0,4                    :Message length
        LHL     R1,DPORT,R12            :Port 
        LHI     R2,0B3                  :Message type (normal logon char)
        JAL     R4,SLOR,,
        LR      R0,R5                   :Logon character
        OHI     R0,80                   :Set top bit
        JAL     R4,PUTCH,,
        JAL     R4,ELOR,,               :End output
        POP(R4,R3,R2,R0)                :Restore registers
        RETURN

        SUBTTL ECHOFF routine ... Send echo off
:
: Routine name  ECHOFF
:
: Function      Send echo off set terminal parameter messages
:
: Called by     REJECT
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:
: Uses          SNDSTP in this module
:
: ---------------------------------------------------------------------
:
        RSTART(ECHOFF)
        PUSH(R5)
        LIS     R5,0                    :Set echo off parameter pair
        CALL(SNDSTP)                    :Send set termianl parameter
        POP(R5)                         :Restore register
        RETURN

        SUBTTL ECHON routine ... Send echo off
:
: Routine name  ECHON
:
: Function      Send echo on set terminal parameter message
:
: Called by     REJECT
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:
: Uses          SNDSTP in this module
:
: ---------------------------------------------------------------------
:
        RSTART(ECHON)
        PUSH(R5)
        LIS     R5,1                    :Set echo on parameter pair
        CALL(SNDSTP)                    :Send set termianl parameter
        POP(R5)                         :Restore register
        RETURN

        SUBTTL SNDZAP/SNDDET routine ... Zap circuit 
:
: Routine name  SNDZAP/SNDDET
:
: Function      To send a zap for a circuit, discard input and output 
:               buffers associated with it and rest PORTAB to point to
:               idle DCB.
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, ELOR in FRING
:
: ---------------------------------------------------------------------
        RSTART(SNDDET)
        LHI     R1,09E                  :Zap code
        J       SNDZ05
:
        RSTART(SNDZAP)
        LHI     R1,09F                  :Zap code
SNDZ05  PUSH(R0,R2,R3,R4,R5)
        LR      R2,R1                   :Message type in R2 for SLOR
        LA      R4,DNETIP,R12           :Free network input buffers
        ST      R4,CHNBWD,R4
SNDZ10  L       R5,CHNFWD,R4
        CR      R5,R4
        JE      SNDZ20
        L       R1,CHNFWD,R5            :Take buffer out
        ST      R1,CHNFWD,R4
        CALL(PUTIOB)                    :Return to free chain
        J       SNDZ10
SNDZ20  LA      R4,DNETOP,R12           :Free network output buffers
        ST      R4,CHNBWD,R4
        LHI     R1,D.OUTN
        RBT     R1,DBITS,R12            :Clear output open bit
SNDZ30  L       R5,CHNFWD,R4
        CR      R5,R4
        JE      SNDZ40
        L       R1,CHNFWD,R5            :Take buffer out
        ST      R1,CHNFWD,R4
        CALL(PUTIOB)                    :Return to free chain
        J       SNDZ30
SNDZ40  LIS     R0,3                    :Message length
        LHL     R1,DPORT,R12            :Port
        JAL     R4,SLOR,,               :Start message
        JAL     R4,ELOR,,               :End message
        RBT     R1,ACP                  :Mark port as inactive
        RBT     R1,DEM
        SLHLS   R1,2
        LA      R0,DCBLKS,,             :Address of idle port DCB
        ST      R0,PORTAB,R1            
        LIS     R1,0
        STH     R1,DPORT,R12            :Set port to zero
        POP(R5,R4,R3,R2,R0)
        RETURN

        SUBTTL SND routines ... Output control messages 
:
: Routine name  SNDGB, SNDRB, SNDGRB, SNDSIX, SNDTIX, SNDBPO, SNDBPX
:
: Function      To send a control message to ORING:
:                  SNDGB - send green ball
:                  SNDRB - send red ball
:                  SNDGRB - send grey ball
:                  SNDSIX - send start IIX
:                  SNDTIX - send end IXX
:                  SNDBPO - Send back pressure on
:                  SNDBPX - Send back pressure off
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, ELOR in FRING
:
: ---------------------------------------------------------------------
:
: Green ball
:
        RSTART(SNDGB)
        LHI     R1,0AA                  :Green ball
        J       OUTLOR
:
: Red ball
:
        RSTART(SNDRB)
        LHI     R1,0AB                  :Red ball
        J       OUTLOR
:
: Grey ball
:
        RSTART(SNDGRB)
        LHI     R1,0A5                  :Grey ball
        J       OUTLOR
:
: Start IIX
:
        RSTART(SNDSIX)
        LHI     R1,0BF                  :SIIX
        J       OUTLOR
:
: End IIX
:
        RSTART(SNDTIX)
        LHI     R1,0C0                  :TIIX
        J       OUTLOR
:
: Back pressure on
:
        RSTART(SNDBPO)
        LHI     R1,0A0                  :Grey ball
        J       OUTLOR
:
: Back pressure off
:
        RSTART(SNDBPX)
        LHI     R1,0A1                  :Grey ball
        J       OUTLOR
:
: Common code to create the above messages
:
OUTLOR  PUSH(R0,R2,R3,R4)               :Save registers used by FRING
        LIS     R0,3                    :Message length
        LR      R2,R1                   :Message type
        LHL     R1,DPORT,R12            :Port
        JAL     R4,SLOR,,               :Start message
        JAL     R4,ELOR,,               :End message
        POP(R4,R3,R2,R0)                :Restore registers
        RETURN
:
        SEG     A.DATA
ZAPMES  SC      /Circuit to host interface lost/
:
        EM


        SUBTTL INOUT ... Input and output interface

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 DEC 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,INOUT                 :Delimit module
:
: This module contains the routines that handle the input and output
: buffers for the higher level code.
:
:       READN - Read character from network input buffer
:       READIA - Read character from IPB input buffer A
:       READIB - Read character from IPB input buffer B
:       OPENN - Open network output channel
:       OPENI - Open IPB output channel
:       WRITBN - Write byte to network output channel
:       WRITED - Write decimal value to network
:       WRITSN - Write string to network output channel
:       CLOSEN - Close network output channel
:       WRITBI - Write byte to IPB output channel
:       WRITSI - Write string to IPB output channel
:       CLOSEI - Close IPB output channel
:
: The following routines are used internally:
:
:       OUTREC - Output record to network
:
: There are no macros unique to this module.
        SUBTTL READN routine ... Read character from network input buffer
:
: Routine name  READN
:
: Function      Read a character from network input buffer. If character
:               read is in last position in buffer, return the buffer to
:               the pool
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       Character returned in R0. 
:               If data available return + 4.
:               If buffer empty then return + 0.
:
: Uses          PUTIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(READN)
        PUSH(R2,R5)
        LA      R1,DNETIP,R12           :Network buffer
        L       R5,CHNFWD,R1            :Address of input buffer
        CR      R5,R1                   :No buffers?
        JE      READ90                  :Jump if none
        LB      R2,BEMPTY,R5
        CLB     R2,BFILL,R5             :Empty offset = Fill offset?
        JE      READ90                  :Jump if buffer empty
:
        LB      R0,BDATA,R5,R2          :Remove character
        AIS     R2,1                    :Move empty pointer
        STB     R2,BEMPTY,R5
        CHI     R2,BSIZE-BDATA          :Has this buffer been used up
        JNFS    READ80                  :Jump if not
        L       R2,CHNFWD,R5            :Remove from input buffer chain
        ST      R2,CHNFWD,R1
        CR      R2,R1
        JNFS    READ70                  :J if chain not empty
        ST      R1,CHNBWD,R1            :Mark chain as empty
READ70  CALL(PUTIOB)                    :Return to free chain, address in R5
:
READ80  LHL     R1,DRXCNT,R12           :Count of data in chain
        SIS     R1,1
        STH     R1,DRXCNT,R12
        LHL     R5,DPORT,R12
        TBT     R5,FRISIS
        JN      READ85                  :J if backpressure off
        CHI     R1,BPOFFL
        JG      READ85                  :J if not less than BP off limit
        CALL(SNDBPX)                    :Send release back presssure
        SBT     R5,FRISIS               :Indicate back pressure off
READ85  POP(R5,R2)                      :Return data available
        RETURN(SKIP)
:
READ90  POP(R5,R2)                      :Return buffer empty
        RETURN
        SUBTTL READIA/READIB routine ... Read byte from IPB input buffer
:
: Routine name  READIA/READIB
:
: Function      Read a character from IPB input buffer. If buffer is
:               empty after read then return buffer to pool.
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       Character returned in R0. 
:               If data available return + 4.
:               If buffer empty then return + 0.
:
: Uses          PUTIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(READIA)
        LA      R1,DIPBIA,R12
        J       REAI10
:
        RSTART(READIB)
        LA      R1,DIPBIB,R12
REAI10  PUSH(R2,R5)
        L       R5,CHNFWD,R1            :Address of input buffer
        CR      R5,R1                   :No buffers?
        JE      REAI90                  :Jump if none
        LB      R2,BEMPTY,R5
        CLB     R2,BFILL,R5             :Empty offset = Fill offset?
        JE      REAI90                  :Jump if buffer empty
:
        LB      R0,BDATA,R5,R2          :Remove character
        AIS     R2,1                    :Move empty pointer
        STB     R2,BEMPTY,R5
        CLB     R2,BFILL,R5             :Has this buffer been used up
        JLFS    REAI80                  :Jump if not
        L       R2,CHNFWD,R5            :Remove from input buffer chain
        ST      R2,CHNFWD,R1
        CR      R2,R1
        JNFS    REAI70                  :J if chain not empty
        ST      R1,CHNBWD,R1            :Mark chain as empty
REAI70  CALL(PUTIOB)                    :Return to free chain, address in R5
:
REAI80  POP(R5,R2)                      :Return data available
        RETURN(SKIP)
:
REAI90  POP(R5,R2)                      :Return buffer empty
        RETURN
        SUBTTL OPEN routine ... Open output channel
:
: Routine name  OPENN, OPENI
:
: Function      Open an output channel.
:               OPENN - Open channel to Tymnet network.
:               OPENI - Open IPB channel. 
:               Gets a IOB buffer and initialises it.
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       IOB buffer will be chained to DCB. 
:
: Uses          GETIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(OPENN)
        PUSH(R2,R5)
        LHI     R1,D.OUTN
        SBT     R1,DBITS,R12            :First check no buffer allocated
        JN      OPEN90
        LA      R2,DNETOP,R12           :Network output buffer
        J       OPEN20
:
        RSTART(OPENI)
        PUSH(R2,R5)
        LHI     R1,D.OUTI
        SBT     R1,DBITS,R12            :First check no buffer allocated
        JN      OPEN90
        LA      R2,DIPBOP,R12           :IPB output buffer
:
OPEN20  CALL(GETIOB)                    :Get an IOB buffer, in R5
        ST      R2,BLINK,R5             :Point buffer to DCB
        ST      R5,CHNFWD,R2            :Point DCB to buffer
        ST      R5,CHNBWD,R2
        LIS     R1,0
        STB     R1,BFILL,R5             :Initialise fill
        STB     R1,BEMPTY,R5            :  and empty pointers
        POP(R5,R2)
        RETURN
:
OPEN90  CRUNCH(CROBAA)                  :Crash output buffer already allocated
:

        SUBTTL WRITBN routine ... Write byte to output channel
:
: Routine name  WRITBN
:
: Function      Write byte to a network output channel.
:               Put character in output buffer. If buffer contains the
:               maximum number of characters that can be sent on this
:               circuit then write to ORING. If backpressured then
:               will suspend.
:
: Called by     The world
:
: On entry      Link register R1
:               Character to be written in R4
:
: On exit       
:
: Uses          OUTREC in this module
:
: ---------------------------------------------------------------------
:
        RSTART(WRITBN)
        PUSH(R4,R5)
        LHI     R1,D.OUTN
        TBT     R1,DBITS,R12            :Is channel open?
        JE      WRIB90
:
        L       R5,DNETOP,R12           :Get address of output buffer
        LB      R1,BFILL,R5             :Current fill pointer
        STB     R4,BDATA,R5,R1          :Store character in buffer
        AIS     R1,1                    :Move pointer
        STB     R1,BFILL,R5
        CLH     R1,DXLIM,R12            :Is this record the largest that
        JLFS    WRIB80                  :can be sent. Jump if it is not
WRIB70  CALL(OUTREC)                    :Output record
:
WRIB80  POP(R5,R4)
        RETURN
:
WRIB90  CRUNCH(CROBNO)                  :Crash output buffer not opened

        SUBTTL WRITED routine ... Write decimal value to output channel
:
: Routine name  WRITED
:
: Function      Write decimal value to an output channel to Tymnet network. 
:               Convert binary value to two character decimal. If tens
:               are zero then they are not output.
:
: Called by     MCVT1
:
: On entry      Link register R1
:               Character to be converted in R5
:
: On exit       
:
: Uses          WRITEB in this module
:
: ---------------------------------------------------------------------
:
        RSTART(WRITED)
        PUSH(R3,R4)                     :Save registers
        LR      R3,R5
        JE      WRID80                  :Do not output if zero
        LIS     R1,$A 10
        DHR     R3,R1                   :Convert to tens and units
        LR      R4,R4                   :Are tens zero
        JEFS    WRID40                  :If so don't output
        AHI     R4,A.0                  :Convert to ASCII
        CALL(WRITBN)                    :Output
WRID40  LR      R4,R3                   :Units
        AHI     R4,A.0                  :Convert to ASCII
        CALL(WRITBN)
WRID80  POP(R4,R3)                      :Restore registers
        RETURN

        SUBTTL WRITSN routine ... Write string to output channel
:
: Routine name  WRITSN
:
: Function      Write string to an output channel to Tymnet network. Put
:               characters in output buffer. If buffer contains the
:               maximum number of characters that can be sent on this
:               circuit then write to ORING. If backpre sured then
:               will suspend.
:               **** Warning, this routine removes the top bit of each
:                    character in the string to deal with NAD SC strings.
:                    If top bit is required, for example for IIX messages,
:                    then WRITBN should be used. ************
:
: Called by     The world
:
: On entry      Link register R1
:               Address of string to be written in R4
:
: On exit       
:
: Uses          OUTREC in this module
:
: ---------------------------------------------------------------------
:
        RSTART(WRITSN)
        PUSH(R2,R3,R4,R5)               :Save registers
        LHI     R1,D.OUTN
        TBT     R1,DBITS,R12            :Is channel open?
        JE      WRIS95
:
        L       R5,DNETOP,R12           :Get address of output buffer
        LR      R2,R4                   :Pointer to string
        JE      WRIS90                  :J if empty string
        LB      R3,0,R2                 :Size of string
        LB      R1,BFILL,R5             :Current fill pointer
WRIS40  LB      R4,1,R2                 :Next character
        NHI     R4,7F                   :Remove top bit
        JE      WRIS90                  :J if invalid data
        STB     R4,BDATA,R5,R1          :Store character in buffer
        AIS     R1,1                    :Move pointer
        CLH     R1,DXLIM,R12            :Is this record the largest that
        JGEFS   WRIS60                  :can be sent. Jump if it is
WRIS50  AIS     R2,1                    :Next character in string
        SIS     R3,1                    :Reduce string count
        JNBS    WRIS40                  :Jump if more data
        STB     R1,BFILL,R5             :Tidy up buffer
        JFS     WRIS80                  :End routine
WRIS60  STB     R1,BFILL,R5
        CALL(OUTREC)                    :Output record
        LB      R1,BFILL,R5
        JBS     WRIS50                  :Continue
:
WRIS80  POP(R5,R4,R3,R2)
        RETURN
:
WRIS90  CRUNCH(CRINVD)                  :Crash invalid data or null string
WRIS95  CRUNCH(CROBNO)                  :Crash output buffer not opened
        SUBTTL CLOSEN routine ... Close output channel
:
: Routine name  CLOSEN
:
: Function      Close an output channel to Tymnet network. 
:               If buffer contains characters then these are sent
:               to the ORING. The output buffer is then released.
:               Note that if backpressured then this routine will
:               suspend.
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       
:
: Uses          OUTREC in this module
:               PUTIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(CLOSEN)
        PUSH(R5)
        LHI     R1,D.OUTN
        RBT     R1,DBITS,R12            :Is channel open?
        JE      CLOS90
:
        L       R5,DNETOP,R12           :Output buffer address
        LB      R1,BFILL,R5             :Any data in buffer
        JEFS    CLOS80                  :Jump if none
        CALL(OUTREC)                    :Output data to ORING
:
CLOS80  CALL(PUTIOB)                    :Free buffer R5 points to it
        LA      R5,DNETOP,R12
        ST      R5,CHNFWD,R5            :Write buffer chain empty
        ST      R5,CHNBWD,R5
        POP(R5)
        RETURN
CLOS90  CRUNCH(CROBNO)                  :Crash output buffer not opened
        SUBTTL OUTREC routine ... Write record to ORING
:
: Routine name  OUTREC
:
: Function      Write a record to the ORING using OCS. If backpressured
:               we must suspend until it is cleared. We only write up to
:               DXLIM of data and then do a voluntary suspend to allow 
:               data to reach  other end of circuit. We will loop until
:               all data has been sent.
:
: Called by     WRITBN, WRITSN, CLOSEN in this module
:
: On entry      Link register R1
:               Address of output buffer in R5
:
: On exit       IOB buffer will be empty.
:
: Uses          OCS in FRING
:
: ---------------------------------------------------------------------
:
:
: We now have a record to be sent to network. We use OCS to put data in
: ring which expects message in SC format (count followed by data).
: This routine assumes that BEMPTY is before BDATA and that record
: starts at BDATA. If this code appears to be hairy, you should try
: CMT/3270! The Californian wine and women are starting to get to me.
:
        RSTART(OUTREC)
        PUSH(R0,R2,R3,R4,R5)            :Save registers destroyed by OCS
OUTR10  LHL	R2,DPORT,R12		:Check if backpressured
	TBT	R2,TOISIS
        JN      OUTR20                  :Jump if not backpressured
        SUS(SUSBP)                      :Suspend until backpressure cleared
        J       OUTR10                  :Try again
:
OUTR20  LR      R1,R5                   :Move buffer address to R1
OUTR30  LB      R0,BFILL,R1             :Number of characters available
	LHL     R2,DXLIM,R12            :Max size of message to be sent
        CR      R2,R0
        JGEFS   OUTR40                  :Jump if less than DXLIM
        LR      R0,R2                   :Otherwise write DXLIM
OUTR40  STB     R0,BEMPTY,R1            :Set up count for OUTREC
        LHL     R2,DPORT,R12            :Port number for OCS
        LA      R3,BEMPTY,R1            :Pointer to string
        PUSH(R5)
        JAL     R5,OCS,,                :Put in ORING
        SUS(SUSVD)                      :Voluntary dismiss
        POP(R5)
        LR      R1,R5                   :Get back buffer address
        LB      R3,BFILL,R1             :If we wrote less than BFILL
        LB      R2,BEMPTY,R1
        SR      R3,R2
        STB     R3,BFILL,R1             : we must move rest to front of buffer
        JLEFS   OUTR60                  :Jump if not required
:
OUTR50  LB      R0,BDATA,R1,R2          :Move rest of data to front of buffer
        STB     R0,BDATA,R1
        AIS     R1,1                    :Move down buffer
        SIS     R3,1
        JN      OUTR50
        J       OUTR10                  :Write out rest of record
:
OUTR60  LIS     R3,0
        STB     R3,BEMPTY,R1            :Tidy up BEMPTY
        POP(R5,R4,R3,R2,R0)             :Restore registers after OCM
        RETURN

        SUBTTL WRITBI routine ... Write byte to interprocess buffer
:
: Routine name  WRITBI
:
: Function      Write byte to the interprocess buffer. If buffer not
:               available or full then one is obtained and chained to
:               DIPBOP. The character is added to the end of the buffer.
:
: Called by     The world
:
: On entry      Link register R1
:               Character to be written in R4
:
: On exit       
:
: Uses          GETIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(WRITBI)
        PUSH(R2,R5)
        LHI     R1,D.OUTI
        TBT     R1,DBITS,R12            :Is channel open?
        JE      PUTB90                  :J if not
:
        LA      R2,DIPBOP,R12           :Get address of output buffer
        L       R5,CHNBWD,R2
        CR      R5,R2
        JEFS    PUTB20                  :J if no buffer present
        LB      R1,BFILL,R5             :Current fill pointer
        CHI     R1,BSIZE-BDATA          :Is buffer full
        JL      PUTB40                  :J if still room
:
PUTB20  PUSH(R3)
        LR      R3,R5
        CALL(GETIOB)
        ST      R5,CHNBWD,R2            :Put this block on end of chain
        ST      R5,CHNFWD,R3            :Chain old last to this one
        ST      R2,CHNFWD,R5            :Chain this to header
        POP(R3)
        LIS     R1,0
        STB     R1,BEMPTY,R5            :Initialise empty and fill ptrs
        STB     R1,BFILL,R5
:
PUTB40  STB     R4,BDATA,R5,R1          :Store character in buffer
        AIS     R1,1                    :Move pointer
        STB     R1,BFILL,R5
:
        POP(R5,R2)
        RETURN
PUTB90  CRUNCH(CROBNO)                  :Crash output buffer not opened

        SUBTTL WRITSI routine ... Write string to interprocess buffer
:
: Routine name  WRITSI
:
: Function      Write string to an interprocess buffer. Put
:               characters in output buffer. If buffer contains the
:               maximum number of characters then get a further buffer
:               and chain it.
:               Note top bit is cleared. This is because it can be set if
:               character came from NAD preset.
:
: Called by     The world
:
: On entry      Link register R1
:               Address of string to be written in R4
:
: On exit       All registers will have been preserved
:
: Uses          GETIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(WRITSI)
        PUSH(R2,R3,R4,R5)               :Save registers
        LHI     R1,D.OUTI
        TBT     R1,DBITS,R12            :Is channel open?
        JE      PUTS90
:
        LA      R5,DIPBOP,R12           :Get address of output buffer
        L       R5,CHNBWD,R5            :Last block of chain
        LR      R2,R4                   :Pointer to string
        LB      R3,0,R2                 :Size of string
        LB      R1,BFILL,R5             :Current fill pointer
PUTS40  LB      R4,1,R2                 :Next character
        NHI     R4,7F                   :Mask off top bit 
        STB     R4,BDATA,R5,R1          :Store character in buffer
        AIS     R1,1                    :Move pointer
        CHI     R1,BSIZE-BDATA          :Is buffer full
        JN      PUTS50                  :Jump if it is not
        STB     R1,BFILL,R5
        LR      R4,R5
        CALL(GETIOB)
        LA      R1,DIPBOP,R12           :Head of chain
        ST      R5,CHNBWD,R1            :Put this block on end of chain
        ST      R5,CHNFWD,R4            :Chain old last to this one
        ST      R1,CHNFWD,R5            :Chain this to header
        LIS     R1,0
        STB     R1,BEMPTY,R5            :Initialise empty and fill ptrs
        STB     R1,BFILL,R5
:
PUTS50  AIS     R2,1                    :Next character in string
        SIS     R3,1                    :Reduce string count
        JN      PUTS40                  :Jump if more data
        STB     R1,BFILL,R5             :Tidy up buffer
:
        POP(R5,R4,R3,R2)
        RETURN
PUTS90  CRUNCH(CROBNO)                  :Crash output buffer not opened
        SUBTTL CLOSEI routine ... Close output channel
:
: Routine name  CLOSEI
:
: Function      Close an interprocess output channel. 
:               The buffer chain is taken off this DCB and 
:               placed on the IPB input chain of the appropriate DCB.
:
: Called by     The world
:
: On entry      Link register R1
:               DCB type to receive interprocess buffer in R5
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(CLOSEI)
        PUSH(R2,R4,R5)
        LHI     R1,D.OUTI
        RBT     R1,DBITS,R12            :Is channel open?
        JE      CLOX90
:
        SIS     R5,1                    :Convert parameter into DCB address
        SLHLS   R5,2
        L       R5,CTDCB,R11,R5
        JE      CLOX80                  :Invalid no such DCB
        PUSH(R5)                        :Save it
: Should really check that its active
        LA      R4,DIPBOP,R12           :Output buffer address
        LHL     R1,DTYPE,R12
        CHI     R1,DTHPRT
        JN      CLOX20                 :J if not a printer sending data
        LA      R5,DIPBIB,R5
        J       CLOX30
CLOX20  LA      R5,DIPBIA,R5            :Input buffer address
CLOX30  L       R1,CHNFWD,R4            :Move IPB channel to input of new DCB
        L       R2,CHNBWD,R5
        ST      R1,CHNFWD,R2
        L       R1,CHNBWD,R4
        ST      R1,CHNBWD,R5
        ST      R5,CHNFWD,R1
        ST      R4,CHNFWD,R4            :Set output IPB chain empty
        ST      R4,CHNBWD,R4
        POP(R5)
        LHL     R1,DSUSP,R5             :Is new DCB waiting for input?
        CHI     R1,SUSIP
        JNFS    CLOX50                  :J if it isn't
        LIS     R1,0
        STH     R1,DSUSP,R5             :Clear suspension
        LHL     R1,DCBNO,R5
        SBT     R1,RUNREQ               :Mark for running
:
CLOX50  POP(R5,R4,R2)
        RETURN
:
CLOX80  CRUNCH(CRIPBF)                  :Crash IPB port non-existant
CLOX90  CRUNCH(CROBNO)                  :Crash output buffer not opened
:
        EM

        SUBTTL EXEC ... Share time allocation of slot

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 19 DEC 85|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,EXEC                  :Delimit module
:
: This module contains the time sharing executive 
: The slot is entered at START which is within this module
:
: It contains the following routines which are available externally
:
:       SUSPND - Suspend a DCB activity
:
: It contains the following routines which are used internally
:
:       RUNDCB - Start a DCB activity which is marked to be run
:
:
: There are no macros unique to this module.
:
        SUBTTL START / EXECL ... Main executive code
:
: Routine name  START / EXECL
:
: Function      START is the entry point for the slot (called from
:               START.LIB). Here the slot is initialised. It then
:               enters the main executive lopp at EXECL.
:
: Called by     START.LIB
:
: On entry      
:
: On exit       
:
: Uses          IZT and TIMOUT in TIMOUT.LIB
:               IZFRNT and INPUT in FRNTND.LIB
:               IZCMT and RUNDCB in this module
:
: ---------------------------------------------------------------------
:
        DEFGEQ(START,.)                 :Slot entry point
        JAL     R0,IZT                  :Initialise TIMOUT.LIB
        JAL     R0,IZFRNT               :Initialise FRNTND.LIB
        JAL     R1,IZCMT                :Initialise our code
        JAL     R5,ANSHST               :Tell supervisor we're ready
:
:    Now for the main executive loop
:
EXECL   JAL     R0,TIMOUT               :Do timeout processing
        JAL     R0,INPUT                :Read IRING
        JAL     R0,RUNDCB               :Run DCB processes
        SVC     FASTD                   :Dismiss slot
        J       EXECL
        SUBTTL RUNDCB routine ... Run any DCB waiting to be activated
:
: Routine name  RUNDCB
:
: Function      To run any DCB's marked as waiting to be run. When
:               all DCB's have suspended then control is returned
:               to caller
:
: Called by     EXECL
:
: On entry      Bit array RUNREQ has a bit set for every waiting DCB
:               Link register R0
:
: On exit       Registers are not preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
RUNDCB  ST      R0,RUNRET               :Save link register
        LHI     R2,BMAPSZ-2             :Number of bytes in port bit map
RUND20  LH      R0,RUNREQ,R2            :For DCB's waiting to be run
RUND30  JFFOH   R0,RUND40               :Jump if any. Bit no. in R1
        SIS     R2,2
        JGEBS   RUND20                  :Jump if more HWs to check
        L       R0,RUNRET               :Restore link register
        JR      R0                      :Return
:
:    We have a DCB waiting to be run
:    Restore all his registers and enter his code
:
RUND40  XH      R0,HMASK,R1,R1          :Clear the waiting bit
        STH     R0,RUNSR0               :Save register 0
        STH     R2,RUNSR2               :Save register 2
        SLLS    R2,3                    :A bit of fiddling to calc. port 
        OR      R1,R2                   :R1 now contains DCB number
        LR      R12,R1
        LHI     R0,DCBSIZ
        MHR     R12,R0                  :Convert into DCB address
        AI      R12,DCBLKS
        LHL     R11,DTYPE,R12
        JE      RUND60                  :J if DCB now inactive
        L       R11,DCCB,R12            :CCB address
        L       R13,DSTCKP,R12          :Stack pointer
        L       R1,DUSR,R12             :User code to be entered
        POP(R10,R9,R8,R7,R6,R5,R4,R3)   :Restore registers for user
        POP(R2,R0)                      
        JR      R1                      :Enter user code and suspend at SUSPND
:
:    An inactive DCB has been actived because flag left on RUNREQ
:
RUND60  RBT     R1,RUNREQ               :Clear flag
        LHL     R0,RUNSR0
        LHL     R2,RUNSR2
        J       RUND30                  :Look for new DCB to run
        SUBTTL SUSPND routine ... Suspend a DCB activity
:
: Routine name  SUSPND
:
: Function      To suspend a DCB activity which is to wait for external
:               activity
:
: Called by     Several routines
:
: On entry      Link register R1
:
: On exit       Return is made thru RUNDCB. All registers are preserved.
:
: Uses          
:
: ---------------------------------------------------------------------
:
        DEFGEQ(SUSPND,.)
        ST      R1,DUSR,R12             :Save DCB restart address 
        PUSH(R0,R2)                     :Save registers
        PUSH(R3,R4,R5,R6,R7,R8,R9,R10)
        ST      R13,DSTCKP,R12          :Save stack pointer
        LHL     R0,RUNSR0               :Restore register 0
        LHL     R2,RUNSR2               :Restore register 2
        LHL     R1,DSUSP,R12
        JE      SUSP30                  :J if voluntary suspend 
        LHL     R1,DCBNO,R12
        RBT     R1,RUNREQ               :Clear running bit
        J       RUND30                  :Any more DCB's to run?
:
SUSP30  LHL     R1,DCBNO,R12
        SBT     R1,RUNREQ
        J       RUND30                  :Any more DCB's to run?
:
:
        SEG     A.DATA
RUNRET  WS      1                       :Save link register area
RUNSR0  HS      1                       :Save register 0
RUNSR2  HS      1                       :Save register 2 
:
        EM


        SUBTTL SCRMIS ... Miscellanous screen image routines

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 14 MAR 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,SCRMIS                :Delimit module
:
: This module contains routines which maniplulate the screen image.
:
:       CLRSCR - Clear screen image
:       COPYSC - Copy screen image to new screen buffer
:       FNDATR - Find attribute of screen position
:
: There are no macros unique to this module.
        SUBTTL CLRSCR routine ... Clear screen image
:
: Routine name  CLRSCR
:
: Function      This routine clears the screen image in the current 
:               screen buffer and sets the cursor and SOM to the top
:               left hand corner of the screen.
:
: Called by     KEY440 in this module
:               LOGST in LOGON
:
: On entry      Screen buffer address in R10
:               Link register R1
:
: On exit       R7 contains new cursor address.
:               R6 contains attribute at cursor.
:               All registers are preserved.
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(CLRSCR)
        LHI     R7,SCRSIZ
        LHI     R1,A.SP
CLRS20  SIS     R7,1
        STB     R1,SCNBUF,R10,R7        :Spacefill screen buffer
        JNBS    CLRS20  
        STH     R7,SCURSR,R10           :Cursor offset at zero
        STH     R7,SSOM,R10             :SOM at offset zero
        LIS     R6,0                    :Null attribute
        STH     R6,SCATTR,R10           :Cursor attribute clear
        STH     R6,SSATTR,R10           :SOM attribute clear
        STH     R6,SFLDS,R10            :No fields defined
        STH     R6,SBITS,R10            :Clear status bits
        STH     R6,SRACKS,R10           :Clear rack up count
        RETURN
        SUBTTL COPYSC routine ... Make a copy of screen image
:
: Routine name  COPYSC
:
: Function      This routine takes a copy of the current screen image
:               in a new screen buffer and chains that buffer to the
:               DCB. This buffer becomes the active screen image.
:               We use the COPY microcode instruction.
:
: Called by     
:
: On entry      Link register R1
:
: On exit       R10 points to the new buffer.
:               All registers are preserved.
:
: Uses          GETSCR in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(COPYSC)
        PUSH(R4,R5)                     :Save registers
        CALL(GETSCB)                    :Get a new screen buffer
        ST      R5,DSCNBF,R12           :Chain it to DCB
        LA      R4,DSCNBF,R12
        ST      R4,CHNFWD,R5            :Chain SCB to buffer
        L	R4,CSCNBF,R11
        LR      R10,R5                  :Make new buffer working buffer
        AHI     R4,SCBSIZ-2             :Last source halfword
        AHI     R5,SCBSIZ-2             :Last destination halfword
        LHI     R1,((SCBSIZ/2)-1)*10    :10 times number of HW's -1
        COPY    R4,R1                   :Copy old to new buffer
: Note that the above instruction could crash with a MAC violation if
: the source buffer starts on a segment boundary. The program is set up
: so that this is never the case. Has someone moved the buffers around?
: ISN'T TYMNET TECHNOLOGY WONDERFUL!!!!!!!!!!!!!!!!!!!!!!!
:
        
        POP(R5,R4)                      :Restore registers
        RETURN  
        SUBTTL FNDATR routine ... Find attribute of character position
:
: Routine name  FNDATR
:
: Function      This routine finds the attribute of a specified
:               character position.
:
: Called by     Several routines in this module
:
: On entry      Character position offset in R7
:               Link register R1
:
: On exit       R6 contains attribute of new position. All registers are
:               preserved.
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(FNDATR)
        LHL     R1,SFLDS,R10            :Count of fields
        JE      FNDA80                  :Jump if not formatted
        LR      R1,R7
        LB      R6,SCNBUF,R10,R1        :Current screen position
        THI     R6,ATMFST
        JN      FNDA90                  :Jump if start of field
FNDA20  SIS     R1,1                    :Back thro screen
        JGEFS   FNDA40  
	J	FNDA80			:If at start of screen assume
					:unprotected. Note we have not
					:yet catered for screen wrap!
FNDA40  LB      R6,SCNBUF,R10,R1        :Have we found a field start
        THI     R6,ATMFST
        JE      FNDA20                  :Jump if not
        XHI     R6,ATMFST               :Drop field start bit
        JFS     FNDA90
:
FNDA80  LIS     R6,0                    :Null attribute
FNDA90  RETURN
:
        EM

        SUBTTL OUTSCR ... Update physical screen

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 JUL 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        GL      FNDATR
        SEG     A.CODE                  :Segment to contain this module
        MO      .,OUTSCR                :Delimit module
:
: This module contains routines required to update the physical terminal
: screen to match the ICL screen image held in memory.
:
:       OUTSCR - Main outpuut routine
:
: The following routines are used internally:
:
:       OPSFUL - Repaint screen from memory
:       OPSTWO - Compare old and new buffers
:       OPSONE - Only one character changed
:       OPSIND - Output status indicator
:       OPSXIN - Delete status indicator
:       OPSSOM - Position SOM
:       OPSXSM - Delete old SOM
:       OPSCUR - Position cursor
:       CHKCUR - Check cursor is on screen
:       OUTCHR - Output character from screen image
:       SETATR - Set output graphic rendition
:
: There are no macros unique to this module.
        SUBTTL OUTSCR routine ... Update terminal screen
:
: Routine name  OUTSCR
:
: Function      Updates the terminal screen image to match the image held
:               in memory. The following switches in SBITS may be set to
:               provide further information on how the screen image was
:               created :
:                       S.OPSR - Rack up occurred
:                       S.BELL - Bell required
:
: Called by     The world
:
: On entry      Link register R1
:               Screen image buffer address in R10
:               SOUTFL contains a change type parameter as follows:
:                       OFFULL - Repaint full screen
:                       OFSTAT - Status indicator change only
:                       OFCURS - Cursor move only
:                       OFSOM  - Som movement only
:                       OFCLRS - Clear screen only
:                       OFXSTI  - Switch status indicator on/off
:                       OFXLIN - Switch 24 line window
:                       OFOPT  - New and old buffer available
:
: On exit       All registers will have been preserved
:
: Uses          OPSFUL, OPSIND, OPSCUR, OPSSOM in this module
:               OPSONE, OPSTWO, CHKCUR, OPSXSM in this module
:               PUTSCB in CBDEF
:               OPEN, CLOSE, WRITES in INOUT
:
: ---------------------------------------------------------------------
:
:       Define parameter values
:
        DEFGEQ(OFFULL,0)                :Repaint full screen
        DEFGEQ(OFSTAT,1)                :Status indicator change only
        DEFGEQ(OFCURS,2)                :Cursor move only
        DEFGEQ(OFSOM,3)                 :Som move only
        DEFGEQ(OFCLRS,4)                :Clear screen only
        DEFGEQ(OFONEC,5)                :One character change
        DEFGEQ(OFXSTI,6)                :Switch status indicator on/off
        DEFGEQ(OFXLIN,7)                :Switch 24 line window
        DEFGEQ(OFOPT,8)                 :New and old buffer available
:
:
        RSTART(OUTSCR)
        OPEN(NET)                       :Open output channel
        LHL     R1,SOUTFL,R10           :Get output request type
        CHI     R1,OFOPT                :If parameter invalid then 
        JG      OUT100                  : just output full screen
        SLHLS   R1,2                    :Convert parameter into index
        J       OUT000,R1               :Jump on parameter
:
OUT000  J       OUT100                  :Repaint full screen
        J       OUT200                  :Status indicator change only
        J       OUT300                  :Cursor move only
        J       OUT400                  :Som move only
        J       OUT500                  :Clear screen only
        J       OUT600                  :One character change
        J       OUT700                  :Switch status indicator on/off
        J       OUT800                  :Switch 24 line window
        J       OUT900                  :New and old buffer available
:
:       OFFULL - Repaint full screen
:
OUT100  CALL(OPSFUL)                    :Paint screen
        J       OUT999                  :Return
:
:       OFSTAT - Status indicator change only
:
OUT200  CALL(OPSIND)                    :Update status indicator
        CALL(OPSCUR)                    :Reset cursor
        J       OUT999                  :Return
:
:       OFCURS - Cursor move only
:
OUT300  CALL(CHKCUR)                    :Check cursor is on screen
        J       OUT999                  :Screen has been repainted
        CALL(OPSCUR)                    :Position cursor
        J       OUT999                  :Return
:
:       OFSOM - Som move only
:
OUT400  CALL(OPSXSM)                    :Clear old Som
        CALL(OPSSOM)                    :Output som
        CALL(OPSCUR)                    :Position cursor
        J       OUT999                  :Return
:
:       OFCLRS - Clear screen only
:
OUT500  LIS     R1,0                    :Check cursor is on screen
        STH     R1,CVSTRT,R11
        LHL     R1,TRMSIZ,R9
        STH     R1,CVEND,R11
        PUSH(R4)
        LHL     R4,TRMCLR,R9            :Action clear screen
        WRITES(NET)
        POP(R4)
        CALL(OPSSOM)                    :Output som indicator
        CALL(OPSIND)                    :Output status indicator
        CALL(OPSCUR)                    :Position cursor
        J       OUT999                  :Return
:
:       OFONEC - Only one character changed at cursor position - 1
:
OUT600  CALL(OPSONE)                    :Output that one character
        J       OUT999                  :Return
:
:       OFXSTI - Switch status indicator on/off
:
OUT700  LHI     R1,C.STAT
        TBT     R1,CBITS,R11
        JE      OUT710                  :J if currently on
        RBT     R1,CBITS,R11            :Mark as on
        CALL(OPSIND)                    :Display it
        J       OUT720
OUT710  SBT     R1,CBITS,R11            :Mark as off
        CALL(OPSXIN)                    :Clear status indicator from screen
OUT720  CALL(OPSCUR)                    :Reposition cursor
        J       OUT999                  :Return
:
:       OFXLIN - Switch 24 line window
:
OUT800  CALL(RACKSW)
        J       OUT999
:
:       OFOPT - New and old screen buffers available
:
OUT900  LHI     R1,S.CLRS
        RBT     R1,SBITS,R10
        JE      OUT910                  :J if no clear screen occurred
        PUSH(R5)
        L       R5,CSCNBF,R11
        CALL(PUTSCB)                    :Return old buffer to pool
        POP(R5)
        L       R10,DSCNBF,R12          :Make new buffer the current
        ST      R10,CSCNBF,R11
        LIS     R1,0
        ST      R1,DSCNBF,R12           :Mark DCB as having no buffer
        CALL(OPSFUL)                    :Complete repaint
        J       OUT999
:
OUT910  CALL(OPSTWO)                    :Output screen
        PUSH(R5)
        L       R5,CSCNBF,R11
        CALL(PUTSCB)                    :Return old buffer to pool
        POP(R5)
        L       R10,DSCNBF,R12          :Make new buffer the current
        ST      R10,CSCNBF,R11
        LIS     R1,0
        ST      R1,DSCNBF,R12           :Mark DCB as having no buffer
:
OUT999  CLOSE(NET)                      :Close output
	LIS	R7,0
	STH	R7,SRACKS,R10		:Set rack count to zero
        LHL     R7,SCURSR,R10           :Reset cursor 
        LHL     R6,SCATTR,R10           : and attrib registers
        RETURN

        SUBTTL OPSFUL routine ... Output full screen
:
: Routine name  OPSFUL
:
: Function      Outputs a full screen without optimisation. Clears screen
:               and outputs screen image from buffer. Attempts are made
:               to skip over spaces using move cursor if this saves output
:               characters. Finally the som and status indicators are 
:               output and the cursor positioned.
:
: Called by     OUTSCR in this module
:
: On entry      Link register R1
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          WRITEB, WRITES in INOUT
:               TRMMC for terminal type
:               OUTCHR, SETATR in this module
:               OPSSOM, OPSIND, OPSCUR in this module
:               FNDATR in ICLKEY
:
: ---------------------------------------------------------------------
:
        SSTART(OPSFUL)
        PUSH(R0,R3,R4,R5,R6,R7)         :Save registers
        LHL     R4,TRMCLR,R9            :Clear screen
        WRITES(NET)
        LHL     R7,CVSTRT,R11           :Start of displayed screen
        CALL(FNDATR)                    :Find atrrib of first position
        L       R10,CSCNBF,R11
        LIS     R5,0                    :Count of spaces to skip
        LIS     R3,0                    :Last position written to
OPSF10  LB      R0,SCNBUF,R10,R7        :Next character of screen
        CHI     R0,A.SP                 :Is it a space
        JN      OPSF20                  :J if it is not
        AIS     R5,1                    :Increase space count
        J       OPSF95                  :Move down screen
:
: We have a non space character. if we have counted spaces then we must move 
: over them either by cursor move or by outputing spaces, whichever uses the 
: least number of characters.
:
OPSF20  LR      R5,R5
        JN      OPSF30                  :Jump ,if space count not zero
        TBT     R3,TRMSPX,R9            :Was last position special
        JN      OPSF70                  :Yes so do move cursor
        J       OPSF80                  :No just write next characters
:
OPSF30  CLH     R5,TRMMCC,R9            :Compare with move cursor size
        JG      OPSF70                  :J if move cursor better
: However if character positions include a special position move cursor will
: still be better
        LR      R1,R5
OPSF40  AIS     R3,1
        TBT     R3,TRMSPX,R9
        JN      OPSF70                  :Special character pos so move cursor
        SIS     R5,1
        JN      OPSF40
OPSF50  LR      R5,R1                   :Restore space count
        LHI     R4,A.SP                 :Space character
	LB	R4,ASCTRM,R4,		:Put in terminal format
OPSF60  WRITEB(NET)                     :Output space
        SIS     R5,1                    :Reduce space count
        JN      OPSF60                  :J if still more
        J       OPSF80                  :Now process non space char
:
OPSF70  LIS     R5,0                    :Set space count to zero
        L       R4,TRMMC,R9             :Move cursor routine
        JALR    R1,R4                   :Action it
:
OPSF80  LR      R4,R0                   :New character
        CALL(OUTCHR)                    :Output it
:
OPSF90  LR      R3,R7                   :Note last position written to
OPSF95  AIS     R7,1                    :Move down screen
        CLH     R7,CVEND,R11            
        JN      OPSF10                  :Jump if not end of screen
        POP(R7,R6,R5,R4,R3,R0)          :Restore registers
        CALL(OPSSOM)                    :Output som
        CALL(OPSIND)                    :Output status indicator
        CALL(OPSCUR)                    :Position cursor
        RETURN

        SUBTTL OPSTWO routine ... Output screen by comparing two buffers
:
: Routine name  OPSTWO
:
: Function      Outputs a new screen image by comparing current image
:               and new image screen buffers. Attempts are made
:               to skip over the same characters using move cursor if this
:               saves output characters. If caller has indicated that 
:               rack ups have occurred then these are implemented before
:               starting buffer compare.
:
: Called by     OUTSCR in this module
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:               Output channel is open
:
: Uses          TRMMC for terminal type
:               CHKCUR, OUTCHR, SETATR in this module
:               OPSXSM, OPSSOM, OPSIND, OPSCUR in this module
:
: ---------------------------------------------------------------------
:
        SSTART(OPSTWO)
        CALL(CHKCUR)                    :Check if need to move window
        J       OPST95                  :We've had to repaint screen
        PUSH(R0,R2,R3,R4,R5,R6,R7,R8)   :Save registers
        L       R10,DSCNBF,R12
:
: If screen image has been racked up, rack up real screen before doing compare
:
        LHL     R5,SRACKS,R10           :Number of lines racked up
        JE      OPST08                  :J if none required
        LHL     R4,TRMRKU,R9
        JN      OPST02                  :J if rack up available
:
: Rack ups required but not available so repaint screen
:
        CALL(OPSFUL)                    :Repaint full screen
        J       OPST93
:
OPST02  WRITES(NET)                     :Rack up one line
        SIS     R5,1
        JN      OPST02                  :J if more rack ups required
        LHI     R5,SCRWTH
        MH      R5,SRACKS,R10           :New top of screen
	LHL	R1,CVOSOM,R11		:Note new position of SOM
	SR	R1,R5
	STH	R1,CVOSOM,R11
        LIS     R6,0                    :Old top of screen
        L       R10,CSCNBF,R11          :Old buffer
:
: Move data up old buffer to simulate rack ups
:
OPST04  CLH     R5,CVEND,R11
        JGE     OPST06                  :J if end of screen
        LB      R4,SCNBUF,R10,R5
        STB     R4,SCNBUF,R10,R6
        AIS     R5,1
        AIS     R6,1
        J       OPST04
:
: Space fill empty lines at bottom to match screen
:
OPST06  LHI     R4,A.SP
        STB     R4,SCNBUF,R10,R6
        AIS     R6,1
        CLHI    R6,SCRSIZ
        JL      OPST06
:
: Register usuage below
:       R0 - Last position written to (for special position check)
:       R2 - Current position in old buffer
:       R3 - Old buffer address
:       R4 - Current character from new buffer
:       R5 - Skip count
:       R6 - Current attribute in new buffer
:       R7 - Current position in new buffer
:       R8 - Current attribute in old buffer
:       R10 - New buffer address
:
OPST08  LHL     R7,CVSTRT,R11           :Start of displayed screen
        L       R10,CSCNBF,R11          :Old buffer
        CALL(FNDATR)                    :Find atrrib of first position
        LR      R3,R10                  :Move old buffer address into R3
        LR      R2,R7                   :   offset into R2
        LR      R8,R6                   :   attribute into R8
        L       R10,DSCNBF,R12          :New screen buffer address
        CALL(FNDATR)                    :    and its attribute in R6
:
        LIS     R0,0                    :Last position written to
        LHI     R5,40                   :Count of spaces to skip, set high to
                                        : force move cursor on first character
OPST20  LB      R4,SCNBUF,R7,R10        :Next character of new screen
        THI     R4,ATMFST
        JE      OPST30                  :Jump if not field start
        LR      R6,R4                   :Make new buffer attribute
        NHI     R6,ATMNFS               :Drop field start bit
OPST30  LB      R1,SCNBUF,R2,R3         :Next character of old screen
        THI     R1,ATMFST
        JE      OPST40                  :Jump if not field start
        LR      R8,R1                   :Make this old buffer attribute
        NHI     R8,ATMNFS               :Remove field start bit
OPST40  CR      R1,R4                   :Is new the same as old character
        JN      OPST50                  :J if it is not
        CHI     R4,A.SP
        JE      OPST45                  :Don't compare attributes if spaces
        CR      R6,R8
        JN      OPST50                  :J if attributes not same
OPST45  AIS     R5,1                    :Increase skip count
        J       OPST95                  :Move down screen
:
: We have a difference between buffers. If we have stepped over characters
: then we must move over them either by cursor move or by outputing the
: characters, whichever uses the least number of characters.
:
OPST50  LR      R5,R5
        JN      OPST55                  :Jump ,if skip count non zero
        TBT     R0,TRMSPX,R9            :Was last position special
        JN      OPST70                  :Yes so do move cursor
        J       OPST80                  :No just write next characters
:
OPST55  CLH     R5,TRMMCC,R9            :Compare with move cursor size
        JG      OPST70                  :J if move cursor better
: However if character positions include a special position move cursor will
: still be better
        LR      R1,R5
OPST56  AIS     R0,1
        TBT     R0,TRMSPX,R9
        JN      OPST70                  :Special character pos so move cursor
        SIS     R5,1
        JN      OPST56
OPST57  LR      R5,R1                   :Restore skip count
        SR      R7,R5                   :Go back to last char wrote
OPST60  LB      R4,SCNBUF,R7,R10
        CALL(OUTCHR)                    :Output character
        AIS     R7,1
        SIS     R5,1                    :Reduce skip count
        JN      OPST60                  :J if still more
        J       OPST80                  :Now process different char
:
OPST70  LIS     R5,0                    :Set skip count to zero
        L       R4,TRMMC,R9             :Move cursor routine
        JALR    R1,R4                   :Action it
        CALL(SETATR)                    :Set new attribute
:
OPST80  LB      R4,SCNBUF,R7,R10
        CALL(OUTCHR)                    :Output this character
:
OPST90  LR      R0,R7                   :Note last position written to
OPST95  AIS     R7,1                    :Move down new screen
        AIS     R2,1                    :Move down old screen
        CLH     R7,CVEND,R11            
        JN      OPST20                  :Jump if not end of screen
        LHL     R7,SCURSR,R10           :Reset cursor and 
        LHL     R6,SCATTR,R10           : cursor attrib for OPSCUR
        CALL(OPSXSM)                    :Cancel old som
        CALL(OPSSOM)                    :Paint new som
        CALL(OPSIND)                    :Paint status indicator
        CALL(OPSCUR)                    :Position cursor
OPST93  POP(R8,R7,R6,R5,R4,R3,R2,R0)    :Restore registers
OPST95  RETURN
        SUBTTL OPSONE routine ... Handle one character change on screen
:
: Routine name  OPSONE
:
: Function      To action a one character change on screen. Check if Som
:               or status indicator has been overwritten. If character has
:               not been echoed by Consat then we must write it to
:               terminal provided it is not a blanked field. Finally check
:               cursor is in right position.
:
: Called by     OUTSCR in this module
:
: On entry      Link register R1
:               Output channel is open
:
: On exit       All registers are preserved.
:
: Uses          WRITEB in INOUT
:               OPSSOM, OPSIND, OPSCUR ,SETATR, CHKCUR in this module
:
: ---------------------------------------------------------------------
:
        SSTART(OPSONE)
        CALL(CHKCUR)                    :Check window
        J       OPSO90                  :We've had to repaint screen
        SIS     R7,1                    :Back to character written
        JGE     OPSO10
        AHI     R7,SCRSIZ               :Handle wrap
:
: Has character been echoed
:
OPSO10  LHI     R1,D.DEM
        TBT     R1,DBITS,R12
        JE      OPSO40                  :J if Consat echoing
:
: Have we overwritten SOM
:
        CLH     R7,SSOM,R10
        JN      OPSO20                  :J if not overwritten SOM
        CALL(OPSSOM)                    :Rewrite character and SOM
        CALL(SETATR)                    :Set attribute back
        J       OPSO70                  :Test for special position
:
: Have we overwritten status indicator
:
OPSO20  LHI     R1,C.STAT
        TBT     R1,CBITS,R11
        JN      OPSO30                  :J if status not on
        LHL     R1,TRMSTA,R9            :Status indicator position
        AH      R1,CVSTRT,R11
        SR      R1,R7
        JG      OPSO30                  :J if not in status position
        AIS     R1,1
        JGE     OPSO80                  :J if in status position
:
: Echo character if not blanked field
:
OPSO30  PUSH(R6)
        CALL(FNDATR)                    :Find attrib at current position
        LR      R1,R6
        POP(R6)
        NHI     R1,ATMVAL
        SIS     R1,1
        JE      OPSO80                  :If blanked field then just move cursor
        PUSH(R4)
        LB      R4,SCNBUF,R10,R7
	LB	R4,ASCTRM,R4,		:Put in terminal format
        WRITEB(NET)                     :Write character to terminal
        POP(R4)
        J       OPSO70                  :Now check for special position
:
: Character has been echoed
:
: Have we overwritten SOM
:
OPSO40  CLH     R7,SSOM,R10
        JE      OPSO60                  :J if overwritten SOM
:
: Have we overwritten status indicator
:
        LHI     R1,C.STAT
        TBT     R1,CBITS,R11
        JN      OPSO50                  :J if status not on
        LHL     R1,TRMSTA,R9            :Status indicator position
        AH      R1,CVSTRT,R11
        SR      R1,R7
        JG      OPSO50                  :J if not in status position
        AIS     R1,1
        JGE     OPSO60                  :J if in status position
:
: Have we hit special position
:
OPSO50  TBT     R7,TRMSPX,R9
        JE      OPSO90                  :J if not a special position
:
: Screen has started to go wrong. Take a copy and request echo off so that
: we can reset it when ecoing stops. Similiar mechanism to REJECT.
:
OPSO60  LHI     R1,D.WDEM
        SBT     R1,DBITS,R12
        JN      OPSO65                  :J if already awaiting DEM
        CALL(ECHOFF)                    :Request DEM
        CALL(ECHON)
OPSO65  L       R1,DSCNBF,R12
        JN      OPSO90                  :J if already got copy of screen
        CALL(COPYSC)                    :Get screen copy
OPSO67  L       R10,CSCNBF,R11          :Bad image
        LHI     R1,0
        STB     R1,SCNBUF,R10,R7        :Mark possible corruption
	L	R10,DSCNBF,R12
        J       OPSO90                  :return
:
:
OPSO70  TBT     R7,TRMSPX,R9            :Is this a special action position
        JE      OPSO90                  :J if not
OPSO80  LHL     R7,SCURSR,R10           :Restore cursor position
        CALL(OPSCUR)                    :Set cursor implicitly
OPSO90  LHL     R7,SCURSR,R10
        RETURN
        SUBTTL OPSIND routine ... Output status indicator
:
: Routine name  OPSIND
:
: Function      Outputs the status indicator. Position cursor at
:               location set for terminal, set reverse attribute
:               and output two character status.
:
: Called by     OUTSCR in this module
:
: On entry      Link register R1
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          WRITEB in INOUT
:               TRMMC, TRMSA routines for terminal type
:
: ---------------------------------------------------------------------
:
        SSTART(OPSIND)
        LHI     R1,C.STAT
        TBT     R1,CBITS,R11
        JN      OPSI90                  :J if status not being displayed
        PUSH(R4,R6,R7)                  :Save registers
        LHL     R7,TRMSTA,R9            :Offset for status indicator
        AH      R7,CVSTRT,R11           :Add screen offset
        L       R4,TRMMC,R9             :Terminal move cursor routine
        JALR    R1,R4                   :Position cursor
        LHI     R6,ATMREV               :Reverse attribute
        CLH     R6,CVATTR,R11
        JE      OPSI20                  :Jump if current attribue
        STH     R6,CVATTR,R11           :Record as current attribute
        L       R4,TRMSA,R9             :Set attribute routine
        JALR    R1,R4
OPSI20  LHL     R6,CVSTAT,R11           :Current status
        SLHLS   R6,1                    :Convert into offset into table
        LB      R4,STATUS,R6            :First character
        WRITEB(NET)                     :Output character
        LB      R4,STATUS+1,R6          :Second character
        WRITEB(NET)                     :Output character
        POP(R7,R6,R4)                   :Restore registers
OPSI90  RETURN
        SUBTTL OPSXIN routine ... Cancel status indicator
:
: Routine name  OPSXIN
:
: Function      Cancels the status indicator. Position cursor at
:               location set for terminal and output two characters
:               from screen buffer.
:
: Called by     CHKCUR in this module
:
: On entry      Link register R1
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          TRMMC routine for terminal type
:               OUTCHR in this module
:
: ---------------------------------------------------------------------
:
        SSTART(OPSXIN)
        PUSH(R4,R6,R7)                  :Save registers
        LHL     R7,TRMSTA,R9            :Offset for status indicator
        AH      R7,CVSTRT,R11           :Add screen offset
        CLH     R7,SSOM,R10
        JN      OPIX30                  :J if not Som position
        CALL(OPSSOM)                    :Output Som
        J       OPIX50
OPIX30  L       R4,TRMMC,R9             :Terminal move cursor routine
        JALR    R1,R4                   :Position cursor
        LB      R4,SCNBUF,R10,R7        :First character underneath status
        CALL(FNDATR)
        CALL(OUTCHR)                    :Output character
OPIX50  AIS     R7,1
        CLH     R7,SSOM,R10
        JN      OPIX70                  :J if not SOM position
        CALL(OPSSOM)                    :Output SOM
        J       OPIX90
OPIX70  LB      R4,SCNBUF,R10,R7        :Second character underneath status
        CALL(OUTCHR)                    :Output character
OPIX90  POP(R7,R6,R4)                   :Restore registers
        RETURN
        SUBTTL OPSSOM routine ... Position and display SOM routine
:
: Routine name  OPSSOM
:
: Function      Positions and displays the SOM at the location required by the
:               current screen image. This is achieved by moving cursor to
:               Som position, switching on reverse attribute and rewriting
:               character.
:
: Called by     OUTSCR in this module
:
: On entry      Link register R1
:               R9 contains address of terminal profile table
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          TRMMC, TRMSA routines for terminal type
:               WRITES, WRITEB in INOUT
:
: ---------------------------------------------------------------------
:
        SSTART(OPSSOM)
        LHL     R1,SSOM,R10             :Som position
        CLH     R1,CVSTRT,R11
        JL      OPSS80                  :J if not on screen
        CLH     R1,CVEND,R11
        JGE     OPSS80                  :J if not on screen
        PUSH(R4,R6,R7)                  :Save register
        LHL     R7,SSOM,R10             :Som position
:
: Is SOM in status indicator. If so dont write SOM if status indicator being
: displayed
:
        LHL     R1,TRMSTA,R9
        AH      R1,CVSTRT,R11
        SR      R1,R7
        JG      OPSS30                  :Not on status indicator
        AIS     R1,1
        JL      OPSS30                  :Ditto
        LHI     R1,C.STAT
        TBT     R1,CBITS,R11
        JE      OPSS60                  :J if status on
: 
OPSS30  STH     R7,CVOSOM,R11           :Save as old som position
        L       R4,TRMMC,R9             :Move cursor routine
        JALR    R1,R4
:
        LHL     R6,SSATTR,R10           :Attribute at SOM
        AHI     R6,ATMREV               :Add reverse attribute
        STH     R6,CVATTR,R11           :Current attrib
        L       R4,TRMSA,R9             :Set attribute routine
        JALR    R1,R4
        LB      R4,SCNBUF,R10,R7        :Character at SOM
        THI     R4,ATMFST
        JE      OPSS50                  :J if not start of field
        LR      R4,R6
        LHL     R4,TRMSPR,R9            :Protected field character
        THI     R6,ATMPRF
        JN      OPSS40                  :J if protected
        LHL     R4,TRMSUF,R9            :Unprotected field char
OPSS40  WRITES(NET)                     :Write out start of field char
        J       OPSS60
OPSS50	LB	R4,ASCTRM,R4,		:Put in terminal format
	WRITEB(NET)                     :Rewrite character
OPSS60  POP(R7,R6,R4)                   :Restore registers
OPSS80  RETURN
        SUBTTL OPSXSM routine ... Cancel old SOM routine
:
: Routine name  OPSXSM
:
: Function      Removes old Som from screen. CVOSOM in the CCB contains it's
:               position. This is achieved by moving cursor to the old
:               Som position and rewriting character.
:
: Called by     OUTSCR in this module
:
: On entry      Link register R1
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          TRMMC, TRMSA routines for terminal type
:               WRITES, WRITEB in INOUT
:
: ---------------------------------------------------------------------
:
        SSTART(OPSXSM)
        LHL     R1,CVOSOM,R11           :Old Som position
        CLH     R1,CVSTRT,R11
        JL      OPSX80                  :J if not on screen
        CLH     R1,CVEND,R11
        JGE     OPSX80                  :J if not on screen
        PUSH(R4,R6,R7)                  :Save register
        LHL     R7,CVOSOM,R11           :Old Som position
        L       R4,TRMMC,R9             :Move cursor routine
        JALR    R1,R4
:
        CALL(FNDATR)                    :Find attribute at that position
        NHI     R6,ATMNFS               :Remove start of field bit
        STH     R6,CVATTR,R11           :Current attrib
        L       R4,TRMSA,R9             :Set attribute routine
        JALR    R1,R4
        LB      R4,SCNBUF,R10,R7        :Character at SOM
        THI     R4,ATMFST
        JE      OPSX50                  :J if not start of field
        LR      R4,R6
        LHL     R4,TRMSPR,R9            :Protected field character
        THI     R6,ATMPRF
        JN      OPSX40                  :J if protected
        LHL     R4,TRMSUF,R9            :Unprotected field char
OPSX40  WRITES(NET)                     :Write out start of field char
        J       OPSX60
OPSX50	LB	R4,ASCTRM,R4,		:Put in terminal format
	WRITEB(NET)                     :Rewrite character
OPSX60  POP(R7,R6,R4)                   :Restore registers
OPSX80  RETURN
        SUBTTL OPSCUR routine ... Position cursor routine
:
: Routine name  OPSCUR
:
: Function      Positions the cursor at the location required by the
:               current screen image. Sets the current attribute to
:               that of the current field.
:
: Called by     OUTSCR in this module
:
: On entry      Link register R1
:               R6 contains attribute at cursor
:               R7 contains cursor position
:               R9 contains address of terminal profile table
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          TRMMC, TRMSA routines for terminal type
:
: ---------------------------------------------------------------------
:
        SSTART(OPSCUR)
        PUSH(R4)                        :Save register
        L       R4,TRMMC,R9             :Move cursor routine
        JALR    R1,R4
:
: Note that R6 contains current attribute at cursor on entry
:
        CLH     R6,CVATTR,R11
        JE      OPSC10                  :J if correct attribute set
        STH     R6,CVATTR,R11           :Make this current attribute
        L       R4,TRMSA,R9             :Set attribute routine
        JALR    R1,R4
:
: Check if bell is required
:
OPSC10  LHI     R1,S.BELL
        RBT     R1,SBITS,R10            :Has bell been requested
        JE      OPSC20                  :J if not
        LHI     R4,A.BEL
        WRITEB(NET)                     :Ring dem bells
OPSC20  POP(R4)                         :Restore registers
        RETURN

        SUBTTL CHKCUR routine ... Check cursor is on screen
:
: Routine name  CHKCUR
:
: Function      This routine is included to handle 24 line terminals.
:               It checks that the cursor is in the current display window.
:               If it is not, it movled by     OUTSCR in this module
:
: On entry      Link register R1
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(CHKCUR)
        CLH     R7,CVSTRT,R11           :Check cursor is on screen
        JGE     CHKC10
        LHL     R1,CVSTRT,R11
        SHI     R1,SCRWTH               :Move screen down one line
        STH     R1,CVSTRT,R11
        LHL     R1,CVEND,R11
        SHI     R1,SCRWTH
        STH     R1,CVEND,R11
        LHL     R1,TRMRKD,R9            :Do we support rack down on this term
        JE      CHKC70                  :J if we don't
        CALL(OPSXIN)                    :Clear status indicator
        PUSH(R4)
        LHL     R4,TRMRKD,R9            :Address of rack down string
        WRITES(NET)                     :Do rack up
        LIS     R1,0                    :Point to line 0
        J       CHKC20                  :Go and paint it
:
CHKC10  CLH     R7,CVEND,R11            :Check cursor is on screen
        JL      CHKC60
        LHL     R1,CVSTRT,R11
        AHI     R1,SCRWTH               :Move screen up one line
        STH     R1,CVSTRT,R11
        LHL     R1,CVEND,R11
        AHI     R1,SCRWTH
        STH     R1,CVEND,R11
        LHL     R1,TRMRKU,R9            :Do we support rack up
        JE      CHKC70                  :J if we don't
        PUSH(R4)
        LHL     R4,TRMRKU,R9            :Address of rack up string
        WRITES(NET)                     :Do the rack down
        LHI     R1,SCRSIZ-SCRWTH        :Point to line 25
:
: We have racked up or down so we must now paint introduced line
:
CHKC20  PUSH(R5,R6,R7)
	l	R10,CSCNBF,R11		:Old buffer
        LHI     R5,SCRWTH               :Line width of characters to paint
        LR      R7,R1                   :Start point of line
        CALL(FNDATR)
CHKC40  LB      R4,SCNBUF,R10,R7        :Character to be painted
        CALL(OUTCHR)                    :Output it
        AIS     R7,1                    :Next character
        SIS     R5,1
        JN      CHKC40                  :Jump if more to paint
        SHI     R7,SCRWTH               :Point R7 to new line again
:
: If som is on new line we must display it
:
        CLH     R7,SSOM,R10             :Is Som on new line
        JL      CHKC50                  :J if not
        AHI     R7,SCRWTH
        CLH     R7,SSOM,R10
        JGE     CHKC50                  :J if not
        CALL(OPSSOM)                    :Display som
:
: Status indicator has been lost so we must display it
:
CHKC50  CALL(OPSIND)                    :Redo status indicator
        POP(R7,R6,R5,R4)                :Restore registers
CHKC60  RETURN(SKIP)                    :Return + 4
:
: We need to rack up or down but terminal doesn't support it so we must repaint
: whole screen.
:
CHKC70  CALL(OPSFUL)                    :Repaint screen
        RETURN                          :Return + 0

        SUBTTL RACKSW routine ... Rack up or down 24 line screen
:
: Routine name  RACKSW
:
: Function      This routine is included to handle 24 line terminals.
:               It changes the current display window having checked that it
:               leaves the cursor on the screen. 
:
: Called by     OUTSCR in this module
:
: On entry      Link register R1
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(RACKSW)
        PUSH(R4,R5)
        LHL     R1,CVSTRT,R11
        JE      RACK10
        LIS     R5,0                    :New top
        LHI     R4,SCRSIZ-SCRWTH        : and bottom
        J       RACK20
RACK10  LHI     R5,SCRWTH               :New top
        LHI     R4,SCRSIZ               : and bottom
RACK20  CR      R7,R5
        JL      RACK90                  :J if can't rack
        CR      R7,R4
        JGE     RACK90                  : as it would put cursor off screen
        CALL(OPSXIN)                    :Clear status indicator
        STH     R5,CVSTRT,R11           :Save new top
        STH     R4,CVEND,R11            : and bottom
        LR      R5,R5
        JN      RACK30                  :J if rack up required
        LHL     R1,TRMRKD,R9            :Do we support rack down on this term
        JE      RACK70                  :J if we don't
        LHL     R4,TRMRKD,R9            :Address of rack down string
        WRITES(NET)                     :Do rack up
        LIS     R1,0                    :Point to line 0
        J       RACK40                  :Go and paint it
:
RACK30  LHL     R1,TRMRKU,R9            :Do we support rack up
        JE      RACK70                  :J if we don't
        LHL     R4,TRMRKU,R9            :Address of rack up string
        WRITES(NET)                     :Do the rack down
        LHI     R1,SCRSIZ-SCRWTH        :Point to line 25
:
: We have racked up or down so we must now paint introduced line
:
RACK40  PUSH(R6,R7)
        LHI     R5,SCRWTH               :Line width of characters to paint
        LR      R7,R1                   :Start point of line
        CALL(FNDATR)
RACK50  LB      R4,SCNBUF,R10,R7        :Character to be painted
        CALL(OUTCHR)                    :Output it
        AIS     R7,1                    :Next character
        SIS     R5,1
        JN      RACK50                  :Jump if more to paint
        SHI     R7,SCRWTH               :Point R7 back to new line
:
: If som is on new line we must display it
:
        CLH     R7,SSOM,R10             :Is Som on new line
        JL      RACK60                  :J if not
        AHI     R7,SCRWTH
        CLH     R7,SSOM,R10
        JGE     RACK60                  :J if not
        CALL(OPSSOM)                    :Display som
:
: Status indicator has been lost so we must display it
:
RACK60  POP(R7,R6)                      :Restore registers
        CALL(OPSIND)                    :Redo status indicator
        CALL(OPSCUR)
        J       RACK90
:
: We need to rack up or down but terminal doesn't support it so we must repaint
: whole screen.
:
RACK70  CALL(OPSFUL)                    :Repaint screen
RACK90  POP(R5,R4)
        RETURN

        SUBTTL OUTCHR routine ... Output character to screen
:
: Routine name  OUTCHR
:
: Function      Outputs a single character given in screen image format to 
:               terminal. Start of field characters are interpreted.
:
: Called by     Routines in this module only
:
: On entry      Link register R1
:               Character to be interpreted and output in R4
:               Output channel is open
:
: On exit       All registers will have been preserved
:
: Uses          WRITEB, WRITES in INOUT
:               TRMSA for terminal type
:
: ---------------------------------------------------------------------
:
        SSTART(OUTCHR)
        PUSH(R4)
        THI     R4,ATMFST
        JE      OUTC60                  :J if not field start
        LR      R6,R4                   :Get new attrib
        NHI     R6,ATMNFS               :Remove field start bit
        CALL(SETATR)                    :Change attrib if needed
        LR      R1,R4
        LHL     R4,TRMSPR,R9            :Start protected character string
        THI     R1,ATMPRF
        JN      OUTC50                  :J if start protected
        LHL     R4,TRMSUF,R9            :Start unprotected char string
OUTC50  WRITES(NET)                     :Output field start character
        J       OUTC90
:
OUTC60  CALL(SETATR)
	LB	R4,ASCTRM,R4,		:Put in terminal format
        LR      R1,R6
        NHI     R1,ATMVAL               :Validation type
        CHI     R1,1
        JN      OUTC80                  :J if not blanked
        LHI     R4,A.SP
OUTC80  WRITEB(NET)                     :Output character
OUTC90  POP(R4)
        RETURN
        SUBTTL SETATR routine ... Set current terminal attribute
:
: Routine name  SETATR
:
: Function      To set the current graphic rendition for the terminal.
:               Check that it is different from current rendition and if 
:               it is call the device dependent routine to set rendition. 
:
: Called by     OUTSCR routines only
:
: On entry      Link register R1
:               Attribute required in R6
:               Output channel is open
:
: On exit       
:
: Uses          TRMSA routine for device
:
: ---------------------------------------------------------------------
:
SETATR  CLH     R6,CVATTR,R11           :Same as current attribute
        JE      SETA80                  :J if it is
        STH     R6,CVATTR,R11           :Make this the current attribute
        PUSH(R1,R4)
        L       R4,TRMSA,R9             :Set attribute routine
        JALR    R1,R4
        POP(R4,R1)
SETA80  JR      R1                      :Return

        SEG     A.DATA
STATUS  AC      /"54"59"53"45"52"45"4C"50/
:
        EM

        SUBTTL SEND ... Send message to host interface

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  3 DEC 85|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,SEND                  :Delimit module
:
: This module contains routines required to send messages (ICL ALP's)
: to the host interface. 
:
:       SENDMS - Process send key
:       SENDST - Send a status supervisory ALP
:       SENDPF - Send a program function supervisory ALP
:
: The following routines are local to this module:
:
:       SENDBA - Add badge data to message
:       SENDCO - Compress multiple spaces and newlines
:
: There are no macros unique to this module.
        SUBTTL SENDMS routine ... Process send key
:
: Routine name  SENDMS
:
: Function      To action a send key by creating a data ALP consisting
:               of all unprotected characters from the SOM to the
:               character position before the cursor. It is passed over 
:               to the video host interface for processing. Reference ASD 9,
:               3.8.3 and 5.1
:
: Called by     KBDH,ALPH
:
: On entry      Link register R1
:
: On exit       
:
: Uses          FNDATR in SCRMIS
:               SENDBA, SENDCO in this module
:
: --------------------------------------------------------------------------
:
        RSTART(SENDMS)
        OPEN(IPBVID)                    :Open output record
        PUSH(R0,R2,R3,R4,R5,R6,R7)
        LHI     R4,IALPDA               :ALP prefix for data message
        WRITEB(IPBVID)                  :Write to output record
        CALL(SENDBA)                    :Add PID or badge data 
        LHL     R7,SSOM,R10             :Start of send message
        LHL     R6,SSATTR,R10           :Current screen attribute
        LCS     R3,1                    :Clear newline action indicator
        LIS     R2,0                    :Newline compression count
        LIS     R5,0                    :Space compression count
:
:    Register usuage - R7 Screen position
:                       R6 Current attribute
:                       R3 Newline flag (Negative or no. of cols to end)
:                       R5 Space compression count
:                       R2 Newline compression count
:
SEND10  LR      R3,R3
        JG      SEND80                  :Jump if newline action
        LB      R0,SCNBUF,R10,R7        :Next character in screen
        CALL(SENDCO)                    :Can we compress this character
        J       SEND80                  :J if compressed
        THI     R0,ATMFST               :Is this a start of field
        JE      SEND60                  :Jump if not
:
:    Start of field character found in screen
:
SEND50  LR      R6,R0
        NHI     R6,ATMNFS               :Get new attribute
        THI     R0,ATMPRF
        JN      SEND80                  :We don't send DC1 or DC2
        LHI     R4,I.DC4
        THI     R0,ATMFLH               :Flash unprotected send DC4
        JE      SEND70
        LHI     R4,I.DC3                :Steady unprotected send DC3
        J       SEND70
:
:    If character is protected ignore it
:
SEND60  NHI     R6,ATMPRO
        JN      SEND80                  :Jump if protected
:
:    If it is a newline character then set flag to ignore rest of line
:
        LR      R4,R0                   :Current character
        CHI     R4,I.NL
        JN      SEND70                  :Jump if not newline
        LR      R4,R7                   :Calculate chars to end of line
        LHI     R3,SCRWTH
        DHR     R4,R3                   :R3 now contains column
        LHI     R3,SCRWTH
	SR	R3,R4		        :R3 contains no. of cols to EOL
        LB      R4,SCNBUF,R10,R7        :Reload character
:
:    We have a character to put into message
:
SEND70  LB      R4,ASCICL,R4            :Translate to ICL code
        WRITEB(IPBVID)                  :Write to output record
:
:    Now move thru screen
:
SEND80  AIS     R7,1                    :Next  position on screen
        SIS     R3,1                    :Update Newline indicator
        CHI     R7,SCRSIZ
        JNFS    SEND90                  :Jump if not at bottom of screen
        LIS     R7,0                    :Point to top of screen
SEND90  CH      R7,SCURSR,R10           :Reached cursor position
        JN      SEND10                  :Jump if not at end of message
:
:    Message complete so close it off
:
        LHI     R0,A.ETX                :ALP terminator
        CALL(SENDCO)                    :End compression sequence
        J       SEND95
        LR      R4,R0
        WRITEB(IPBVID)                  :Write ETX 
SEND95  CLOSE(IPBVID)                   :Close record
        POP(R7,R6,R5,R4,R3,R2,R0)
        RETURN
        SUBTTL SENDST routine ... Send Status supervisory
:
: Routine name  SENDST
:
: Function      To send a status supervisory ALP to the host interface.
:               Reference ASD 9, 5.1 and 5.2
:
: Called by     VIDALP
:
: On entry      Link register R1
:
: On exit       Status ALP will have been placed in output ring.
:
: Uses          
:
: --------------------------------------------------------------------------
:
        RSTART(SENDST)
        PUSH(R4)
        OPEN(IPBVID)                    :Open output record
        LHI     R4,ISUPST               :ALP prefix for status supervisory
        WRITEB(IPBVID)                  :Write to output record
        LHI     R4,40                   :Operable status
        WRITEB(IPBVID)                  :Write to output record
        LHI     R4,A.ETX
        WRITEB(IPBVID)                     :End of ALP
        CLOSE(IPBVID)                   :Close record
        POP(R4)                         :Recover register
        RETURN
        SUBTTL SENDPF routine ... Process Action key
:
: Routine name  SENDPF
:
: Function      To process an action key by sending a program function
:               supervisory ALP to the host interface. Reference ASD 9
:               3.8.5, 5.1 and 5.3.
:
: Called by     
:
: On entry      Register R5 contains the action code (range 20 - 7E)
:               Link register R1
:
: On exit       ALP will have been placed in output ring. All registers
:               will have been preserved
:
: Uses          SENDBA in this module
:
: --------------------------------------------------------------------------
:
        RSTART(SENDPF)
        PUSH(R4)
        OPEN(IPBVID)                    :Open output record
        LHI     R4,ISUPPF               :ALP prefix for PF supervisory
        WRITEB(IPBVID)                  :Write to output record
        CALL(SENDBA)                    :Add PID or badge data 
        LR      R4,R5                   :Action code
        WRITEB(IPBVID)                  :Write to output record
        LHI     R4,A.ETX
        WRITEB(IPBVID)                     :End of ALP
        CLOSE(IPBVID)                   :Close record
        POP(R4)                         :Recover register
        RETURN
        SUBTTL SENDBA routine ... Add badge data to message
:
: Routine name  SENDBA
:
: Function      To add PID or badge data to an ALP if required.
:               Reference ASD 9, 3.8.5 and 5.3.
:
: Called by     SENDMS,SENDPF
:
: On entry      Link register R1
:
: On exit       If required by user badge data will have been inserted
:               into message. All registers are preserved.
:
: Uses          
:
: --------------------------------------------------------------------------
:
        SSTART(SENDBA)
        LHI     R1,C.BADG
        TBT     R1,CBITS,R11            :Is badge data required
        JE      SENB50                  :Jump if not
:
:    We have badge or PID data to send
:
        PUSH(R4,R7)                     :Save registers
        LHI     R4,I.IS4                :Start of badge data
        WRITEB(IPBVID)                  :Write to output record
        LIS     R7,0
SENB10  CLH     R7,CVBCNT,R11           :Count of badge characters
        JE      SENB30                  :End of data
:
:    Write badge data to ALP
:
        LB      R4,CVBDAT,R11,R7        :Output character 
        WRITEB(IPBVID)
        AIS     R7,1                    :Point to next character
        JBS     SENB10
:
:    End of badge data
:
SENB30  LHI     R4,I.IS4                :End of badge data
        WRITEB(IPBVID)                  :Write to output record
        POP(R7,R4)                      :Recover registers
SENB50  RETURN
        SUBTTL SENDCO routine ... Deal with space compression in send
:
: Routine name  SENDCO
:
: Function      To compress spaces and newline characters if permitted
:               by host.
:
: Called by     SENDMS
:
: On entry      Link register R1
:               Character in R0
:
: On exit       Return + 0 if character compreesed
:               Return + 4 if character not processed
:
: Uses          
:
: --------------------------------------------------------------------------
:
        SSTART(SENDCO)
        PUSH(R4)
        LHI     R1,C.COMP
        TBT     R1,CBITS,R11
        JE      SENC90                  :J if compression not allowed
        CHI     R0,A.SP
        JE      SENC60                  :J if space
        LR      R5,R5
        JE      SENC30                  :J if no spaces to compress
        CHI     R5,2
        JG      SENC20                  :If less than three spaces ....
        LHI     R4,A.SP                 :Send spaces
SENC10  WRITEB(IPBVID)
        SIS     R5,1
        JN      SENC10
        J       SENC30
SENC20  LHI     R4,I.MSP                :Send multiple space sequence
        WRITEB(IPBVID)
        LR      R4,R5
        LIS     R5,0                    :Space count now zero
        AHI     R4,20                   :Qualifier is 20 + space count
        WRITEB(IPBVID)
        LIS     R5,0                    :Space count now zero
:
SENC30  CHI     R0,I.NL
        JE      SENC70                  :J if newline character
        LR      R2,R2
        JE      SENC60                  :J if no newlines to compress
        CHI     R2,2
        JG      SENC50                  :J if more than two to compress
        LHI     R4,I.NL
SENC40  WRITEB(IPBVID)                  :Send newlines
        SIS     R2,1
        JN      SENC40
        J       SENC60
SENC50  LHI     R4,I.MNL
        WRITEB(IPBVID)                  :Send multiple newline
        LR      R4,R2                   :Number of newlines
        LIS     R2,0                    :Flag no newlines to compress
        AHI     R4,20                   :Qualifier is 20 + no. of newlines
        WRITEB(IPBVID)
:
SENC60  CHI     R0,A.SP
        JN      SENC70                  :J if not space
        AIS     R5,1                    :Increment space count
        J       SENC80
:
SENC70  CHI     R0,I.NL
        JN      SENC90                  :J if not newline
        AIS     R2,1                    :Increment count of newlines
SENC80  POP(R4)
        RETURN                          :Return character processed
:
SENC90  POP(R4)
        RETURN(SKIP)                    :Return character not processed
:
:
        EM

        SUBTTL PRINT ... Printer handler routines

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 OCT 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,PRINT                 :Delimit module
:
: This module contains routines required to send messages (ICL ALP's)
: to the host interface. 
:
:       PRTALP - Process printer ALP fragment
:       PRTCHR - Process printer data ALP character
:       PSUPER - Process printer supervisory ALP
:       POSLIN - Position printer at specific line on form
:       POSTOF - position printer at top of form
:       PRTDAS - Send printer Data Secured Report
:       PRTSTR - Send printer status report
:       PRTSCR - Action local print key
:       INIPRT - Initialise printer
:       PRTHLD - Action printer hold key
:       PRTALL - Action printer allocate key
:       PRTDSR - Send device status request to terminal
:       PRTOPS - Handle printer operable report
:       PRTXPS - Handle printer inoperable report
:
: There is one macro unique to this module.
:
:       QUALFP - Get printer code qualifier from ALP
        SUBTTL PRINT ... Macros
:
: ----------------------------------------------------------------------
:
: Macro         QUALFP
:
: Description   Get a qualifier to an ICL control code. This is acheived by
:               setting a flag to indicate that a qualifiy is required,
:               storing the continuation address in the CCB and returning
:               to the caller of ALPCHR. This has the effect that we
:               appear to drop out of macro with qualifier byte in R0.
:
: Parameters    
:
: ----------------------------------------------------------------------
:
X       EQ      0
QUALFP  MACRO [
        LHI     R1,C.PQUA
        SBT     R1,CBITS,R11            :Set flag to indicate qualifier 
        LA      R1,ADD|X|
        ST      R1,CPQUAL,R11           :Continuation address
        RETURN
ADD|X|  EQ      .
X       EQ      X+1
]
        SUBTTL PRTALP routine ... Process printer ALP fragment
:
: Routine name  PRTALP
:
: Function      To process a printer ALP fragment. 
:
: Called by     TERMH in TERM
:
: On entry      Link register R1
:               ALP prefix in R0
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTALP)
        PUSH(R0,R5,R6,R7)
        READ(IPBPTR)                    :Read first byte of message
        J       PRTA95                  :J if no data available
        LHL     R6,CPLINE,R11           :Current line on form
        LHL     R7,CPCOL,R11            :Current column on line
        LHI     R1,C.PALP
        SBT     R1,CBITS,R11
        JN      PRTA20                  :J if this is continuation fragment
:
: This is the first fragment of an ALP
:
	LHI	R1,PS.BNA
	SBT	R1,CPSTAT,R11
        LHI     R1,C.PQUA
        RBT     R1,CBITS,R11            :Flag no qualifier awaited
        LR      R1,R0                   :Keep prefix
        NHI     R1,ITQMSK               :Extract text qualifier field
        CHI     R1,IALPDA
        JE      PRTA10                  :J if data ALP
        CALL(PSUPER)                    :Process supervisory
PRTA05  READ(IPBPTR)
        J       PRTA07                  :J if end of data
        CHI     R0,A.ETX
        JE      PRTA07                  :J if end of ALP
        LHI     R1,C.PQUA
        TBT     R1,CBITS,R11
        JE      PRTA05                  :J if we are not awaiting qualifier
        CALL(PRTCHR)                    :Process qualifier
        J       PRTA05
PRTA07  CALL(PRTDSR)                    :Send status report
	LHI	R1,C.PALP
	RBT	R1,CBITS,R11
        J       PRTA95
: 
: We have a data ALP. 
:
PRTA10  READ(IPBPTR)                    :Next character of ALP
        J       PRTA90                  :J if end of fragmnet
PRTA20  LHI     R1,PS.NOP
        TBT     R1,CBITS,R11
        JN      PRTA55                  :J if printer unavailable
        OPEN(NET)                       :Open output channel
        LHL     R4,TRMBPR,R9
        WRITES(NET)                     :Start printing
        J       PRTA40
PRTA30  READ(IPBPTR)                    :Next ALP character
        J       PRTA90                  :No further data, end of fragment
PRTA40  CHI     R0,A.ETX
        JE      PRTA60                  :J if end of ALP
        LR      R5,R0                   :Note last character read
:
        CALL(PRTCHR)                    :Process character
        JBS     PRTA30                  :Next ALP character
:
: Printer unavailable so flush out ALP fragment
:
PRTA50  READ(IPBPTR)
        J       PRTA57                  :J if end of fragment
PRTA55  CHI     R0,A.ETX
        JN      PRTA50                  :J if not end of ALP
        LHI     R1,C.PALP
        RBT     R1,CBITS,R11
PRTA57  CALL(PRTSTR)                    :Send status report
        J       PRTA95
:
: End of data ALP. Update physical screen, send status response and return
:
PRTA60  CHI     R5,I.DC1                :Check last character of ALP
        JL      PRTA70                  :J if not DC1 - DC4
        CHI     R5,I.DC4
        JGE     PRTA70                  :Ditto
        CALL(PRT100)                    :Process DC1 - DC4 character
PRTA70  LHI     R1,C.PALP
        RBT     R1,CBITS,R11            :Not in middle of ALP any longer
PRTA90  LHL     R4,TRMFPR,R9
        WRITES(NET)                     :End printing string
        CLOSE(NET)                      :Close output channel
	LHI	R1,C.PALP
	TBT	R1,CBITS,R11
	JN	PRTA95
	CALL(PRTDSR)
PRTA95  STH     R6,CPLINE,R11           :Save current line
        STH     R7,CPCOL,R11            :Save current column
        POP(R7,R6,R5,R0)
        RETURN
        SUBTTL PRTCHR routine ... Process printer data ALP character
:
: Routine name  PRTCHR
:
: Function      To process a printer data ALP character. Characters in the 
:               range 20 to 7F are sent to the printer provided we have not
:               exceeded column 131. Special characters are actioned by 
:               appropiate routines. Invalid characters are ignored.
:               ASD 11, PSD 12.14.7, sections 3.4, 3.6, 3.6 refer.
:
: Called by     PRTALP in this module
:
: On entry      Link register R1
:               ALP prefix in R0
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(PRTCHR)
        LHI     R1,C.PQUA
        RBT     R1,CBITS,R11
        JEFS    PRTC10                  :J if qualifier not awaited
        L       R1,CPQUAL,R11           :Contiuation address
        JALR    R1,R1                   :Process qualifier
:
PRTC10  LR      R1,R0
        CHI     R1,20
        JL      PRTC20                  :J if control character
        CHI     R7,$A 132
        JGE     PRTC90                  :J if off end of line
        AIS     R7,1
        PUSH(R4)
        LR      R4,R0
        WRITEB(NET)                     :Write character to printer
        POP(R4)
        J       PRTC90                  :Return
:
PRTC20  SLHLS   R1,2
        J       PRTC30,R1
:
: Jump table for printer control codes
:
PRTC30  J       PRTC90                  :00 - Ignore
        J       PRTC90                  :01 - Ignore
        J       PRTC90                  :02 - Ignore
        J       PRTC90                  :03 - Ignore
        J       PRTC90                  :04 - Ignore
        J       PRTC90                  :05 - Ignore
        J       PRTC90                  :06 - Ignore
        J       PRTC90                  :07 - Ignore
        J       PRTC90                  :08 - Ignore
        J       PRT300                  :09 - Multiple space
        J       PRT450                  :0A - Newline
        J       PRTC90                  :0B - Ignore
        J       PRT200                  :0C - Form feed
        J       PRT250                  :0D - Carriage return
        J       PRT320                  :0E - Multiple space
        J       PRT400                  :0F - Multiple newline
        J       PRTC90                  :10 - Ignore
        J       PRTC90                  :11 - Ignore
        J       PRTC90                  :12 - Ignore
        J       PRTC90                  :13 - Ignore
        J       PRTC90                  :14 - Ignore
        J       PRTC90                  :15 - Ignore
        J       PRTC90                  :16 - Ignore
        J       PRTC90                  :17 - Ignore
        J       PRTC90                  :18 - Ignore
        J       PRTC90                  :19 - Ignore
        J       PRTC90                  :1A - Ignore
        J       PRTC90                  :1B - Ignore
        J       PRTC90                  :1C - Ignore
        J       PRT500                  :1D - Vertical position
        J       PRTC90                  :1E - Ignore
        J       PRTC90                  :1F - Ignore
:
PRTC90  RETURN
        SUBTTL PSUPER routine ... Process printer supervisory ALP
:
: Routine name  PSUPER
:
: Function      To process a printer supervisory ALP. The supervisory
:               code is extracted and the appropriate routine is 
:               called to action it.
:               ASD 11, PSD 12.14.7, section 6.2 refers.
:
: Called by     PRTALP in this module
:
: On entry      Link register R1
:               ALP prefix in R0
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(PSUPER)
        LR      R1,R0
        NHI     R1,1F
        CHI     R1,$A 25                :J if not valid command
        JG      PSUP70
        SHI     R1,$A 16
        JL      PSUP70                  :J if not valid command
        SLHLS   R1,2
        J       PSUP20,R1
:
: Jump table for supervisory commands
:
PSUP20  J       PRT600                  :Write parameter form depthh
        J       PRT620                  :Auto page enable
        J       PRT640                  :Auto page disable
        J       PSUP70                  :Null
        J       PRT660                  :Report output complete
        J       PRT700                  :Terminal hold on
        J       PRT720                  :Terminal hold off
        J       PSUP70                  :Null
        J       PSUP70                  :Null
        J       PRT750                  :Status level reset
:
PSUP70  RETURN                          :Ignore invalid commands
:
:       11,12,13,14 - Device controls DC1, DC2, DC3, DC4
:
: A device control is only sent as the final text character in an ALP. 
: As well as their control functions described below, these characters imply
: a CR action.
:
        SSTART(PRT100)
        LR      R7,R7
        JE      PRT110                  :Already at column 0 
        PUSH(R4)
        LHI     R4,A.CR                 :Send carriage return
        WRITEB(NET)
        POP(R4)
PRT110  LR      R1,R5
        SHI     R1,I.DC1
        SLHLS   R1,2
        J       PRT120,R1
:
PRT120  J       PRT130                  :DC1
        J       PRT140                  :DC2
        J       PRT150                  :DC3
        J       PRT160                  :DC4
:
:       11 - DC1
:
: Unconditional deallocate and end of document. Respond with BNA status and
: maintain this condition until all buffered data has been output to the
: printer. When all data printed deallocate the printer unconditionally.
: We send a DSR to determine when all data has been printed.
: ASD11, PSD 12.14.7, section 7.8 refers.
:
PRT130  J       PRT160
:
:       12 - DC2
:
: End of document. Raise BNA until all buffered data has been ouput. 
: When all buffered data is printed send operable status. We send a
: DSR to determine when all data has been printed. 
: ASD11, PSD 12.14.7, sections 7.7 and 7.8 refer.
:
PRT140  J       PRT165
:
:       13 - DC3
:
: Conditional deallocate.If warning is set BNA status is raised and 
: reported with warning. When all data has been printed BNA and warning 
: are cleared and the printer is deealloacted. We send a DSR to
: determine when all data has been printed. If warning is not set on receipt
: of DC3 then no action is taken.
: ASD11, PSD 12.14.7, sections 7.7 and 7.8 refer.
:
PRT150  LHI     R1,PS.WRN
        TBT     R1,CPSTAT,R11
        JN      PRT160                  :J if warning not set
        RETURN
:
:       14 - DC4
:
: Unconditional deallocate sent at end of alignment test or can be sent 
: during warning condition. Respond with BNA status and maintain this condition
: until all buffered data has been output to the printer. When all data printed
: deallocate the printer unconditionally. Clear warning condition. We send a
: DSR to determine when all data has been printed. 
: ASD11, PSD 12.14.7, sections 7.8 and 6.8.2 refer.
:
PRT160  LHI     R1,PS.WDA
        SBT     R1,CPSTAT,R11           :Set deallocated bit in status
PRT165  LHI     R1,PS.BNA
        SBT     R1,CPSTAT,R11           :Set inop/deallocated bit in status
        RETURN
:
:       0C - Form feed
:
: This moves the stationary to the first line of the next form, irrespective 
: of the current line position.
:
PRT200  CALL(POSTOF)
        RETURN
:
:       0D - Carriage return
:
: This resets the printing position to the left-most position of the current
: line. Any following print data may thus overprint the preceding data already
: printed on this line. ASD 11, PSD 12.14.7, section 4.2.1 refers.
:
PRT250  PUSH(R4)
        LR      R7,R7
        JE      PRT270                  :J if already at column zero
        LR      R4,R0
        WRITEB(NET)                     :Send carriage return
        LIS     R7,0
PRT270  POP(R4)
        RETURN
:
:       09 - Multiple space
:
: This allows a number of print positions to be moved to the right. The number
: of positions is specified by the qualifier as follows
:       for 1 - 31 spaces qualifier = hex 41 - 5F
:       for 32 - 63 spaces qualifier = hex 20 - 3F
: If qualifier is out of range code is ignored. ASD 11, PSD 12.14.7, section
: 4.2.2 refers.
:
PRT300  QUALFP
        PUSH(R0,R4)
        CHI     R0,20
        JL      PRT380                  :J if qualifier invalid
        CHI     R0,40
        JL      PRT350                  :J if 32 - 63 spaces
        CHI     R0,60
        JGE     PRT380                  :J if qualifier invalid
        SHI     R0,40
        JE      PRT380                  :No spaces invalid
        J       PRT350
:
:       0E - Multiple space
:
: This allows a number of print positions to be moved to the right. The number
: of positions is specified by the qualifier as follows
:       for 1 - 95 spaces qualifier = hex 20 + no. of spaces
: If qualifier is out of range code is ignored. ASD 11, PSD 12.14.7, section
: 4.2.2 refers.
:
PRT320  QUALFP
        PUSH(R0,R4)
        SHI     R0,20
        JLE     PRT380                  :J if qualifier invalid
        CHI     R0,$A 95
        JG      PRT380                  :J if qualifier invalid
PRT350  LHI     R4,A.SP
PRT360  CHI     R7,$A 132
        JGE     PRT380                  :J if at end of line
        WRITEB(NET)                     :Write space to printer
        AIS     R7,1
        SIS     R0,1
        JG      PRT360
PRT380  POP(R4,R0)
        RETURN
:
:       0F - Multiple Newline
:
: This causes the stationary to be moved by a number of lines relative to
: the current print position. A qualifier byte specifies the number of lines
: in the form hex 20 + number of lines in range 0 - 95. Zero number of lines
: is valid and equivalent to CR.
:
PRT400  QUALFP
        PUSH(R0,R4,R5)
        SHI     R0,20
        JL      PRT440                  :J if invalid parameter
        CHI     R0,$A 95
        JG      PRT440                  :J if invalid parameter
        AR      R0,R6                   :Add current line number
        DH      R0,CPFORM,R11
        LR      R5,R1
        JE      PRT430                  :J if no form feeds required
PRT420  CALL(POSTOF)                    :Do form feeds
        SIS     R5,1
        JG      PRT420
PRT430  LR      R4,R0
        CALL(POSLIN)                    :Position at correct line
PRT440  POP(R5,R4,R0)
        RETURN  
:
:       0A - Newline
:
: This causes the print position to be moved on one line from the current 
: position with implicit CR action. ASD 11, PSD 12.14.7, section 4.3.1 refers.
:
PRT450  PUSH(R4)
        LR      R4,R6
        AIS     R4,1                    :Current line plus one
        CH      R4,CPFORM,R11
        JL      PRT460                  :J if not new form required
        CALL(POSTOF)                    :Position at top of form
        J       PRT470
:
PRT460  CALL(POSLIN)                    :Position printer
PRT470  POP(R4)
        RETURN
:
:       1D - Vertical Position
:
: This causes the print position to advance to the line specified by the
: qualifier byte,moving to the next form if necessary. If the line number is
: the current position a full form depth is thrown. The qualifier has the 
: format 20 hex + absolute line position on the form (Range 0 -95). If the
: qualifier is out of range then the code is ignored. Ref ASD 11, PSD 12.14.7,
: section 4.3.4.
:
PRT500  QUALFP                          :Get qualifier
        PUSH(R0,R4)
        SHI     R0,20
        JL      PRT520                  :J if out of range
        CLH     R0,CPFORM,R11
        JGE     PRT520                  :J if out of range ( > form length)
        CR      R0,R6
        JG      PRT510                  :J if required line > current line
        CALL(POSTOF)                    :Form feed
PRT510  LR      R4,R0
        CALL(POSLIN)                    :Position at required line
PRT520  POP(R4,R0)
        RETURN
:
: Supervisory type 16 - Write parameter form depth
:
: This code specifies a new form depth. It's parameter consists of two bytes
: with the following format
:               First byte              Second byte
:             6 5 4 3 2 1 0            6 5 4 3 2 1 0
:             1 0 0 x x x x            1 0 0 x x x x
:
: Bits 0-3 of each byte form an eight bit binary number which specifies a form
: length minus 1. ASD 11, PSD 12.14.7, sections 5.2.3.1 and 6.4 refer.
:
PRT600  QUALFP
        LR      R1,R0
        NHI     R1,1F                   :Mask out bits 0 - 3
        SLHLS   R1,4
        STH     R1,CPFORM,R11           :Save part of form length
        QUALFP                          :Get second qualifier
        LR      R1,R0
        NHI     R1,1F                   :Mask out bits 0 - 3
        AHM     R1,CPFORM,R11           :Add to first part
        RETURN
:
: Supervisory type 17 - Auto Page Enable
:
: This code switches on a facilty which modifies the action of vertical 
: format effectors so as to prevent printing immediately adjacent to sheet
: perforations. Any attempt to move to one of the last four lines of a form
: will actually cause a skip to the next line 0. ASD 11, PSD 12.14.7, section
: 6.5 refers.
:
PRT620  LHI     R1,C.PAUT
        SBT     R1,CBITS,R11            :Set auto page enabled bit
        RETURN
:
: Supervisory type 18 - Auto Page Disable
:
: This code switches off the auto page facility described above.
:
PRT640  LHI     R1,C.PAUT
        RBT     R1,CBITS,R11            :Clear auto page enabled bit
        RETURN
:
: Supervisory type 20 - Report Output Complete
:
: This code should cause the ALS to send a Data Secured Report when it beleives
: that all previously received data has been printed. We must raise BNA and
: leave it set until we can send the report. We request a device status 
: report to determine when printing has finished. We set a flag to indicate
: that a data secured report is outstanding. ASD 11, PSD 12.14.7, section 6.7
: refers.
:
PRT660  LHI     R1,PS.BNA
        SBT     R1,CPSTAT,R11           :Set buffer not avail.
:       CALL(PRTDSR)                    :Send device status request
        LHI     R1,PS.ROC               :Flag report output complete required
        SBT     R1,CPSTAT,R11
        RETURN
:
: Supervisory type 21 - Terminal Hold on
:
: Sets a condition where hold condition (set from keyboard) causes inoperable
: to be sent immediately but no data will be discarded. When hold is cleared
: operable status will be sent and printing continued. ASD 11, PSD 12.14.7,
: section 6.8 and 6.8.1 refer.
:
PRT700  LHI     R1,C.PTRM
        SBT     R1,CBITS,R11            :Set terminal hold mode flag
        RETURN
:
: Supervisory type 22 - Terminal Hold off
:
: Sets a condition where hold condition (set from keyboard) causes warning 
: to be sent immediately and this state will be changed to inoperable on
: receipt of a DC3. When hold is cleared operable status will be sent and
: printing continued. ASD 11, PSD 12.14.7, section 6.8 and 6.8.2 refer.
:
PRT720  LHI     R1,C.PTRM
        RBT     R1,CBITS,R11            :Set primary hold mode
        RETURN
:
: Supervisory type 25 - AL Reset
:
: Access level reset has the following effects.
:       a. Discard all buffered data and clear BNA status if set
:       b. Discard all actions due to DC1 - DC4
:       c. Disable auto page facility
:       d. Set primary hold mode
:       e. Move the paper on the printer to head of form
:       f. Set form length to default 66 lines
:
PRT750  PUSH(R4)
        LHI     R1,PS.BNA               :Clear buffer not available in status
        RBT     R1,CPSTAT,R11
        LHI     R1,C.PAUT
        RBT     R1,CBITS,R11            :Disable auto page
        LHI     R1,C.PTRM
        RBT     R1,CBITS,R11            :Set primary hold mode
        LHI     R1,PS.IOP
        TBT     R1,CPSTAT,R11
        JN      PRT760                  :J if printer inoperable
        OPEN(NET)
        LHL     R4,TRMBPR,R9
        WRITES(NET)                     :Start printing
        CALL(POSTOF)                    :Form feed
        LHL     R4,TRMFPR,R9
        WRITES(NET)                     :Finish printing
        CLOSE(NET)
PRT760  LIS     R1,0
        STH     R1,CPLINE,R11           :Line 0
        STH     R1,CPCOL,R11            :Column 0
        LHI     R1,$A 66
        STH     R1,CPFORM,R11           :Form length 66 lines
        POP(R4)
        RETURN          
        SUBTTL POSLIN routine ... Position printer at line on form
:
: Routine name  POSLIN
:
: Function      To position the printer at a specific line within a 
:               form. If autopage is on and required line is within
:               last four lines of form then we skip to line 0 of next
:               form. If required line number is less than current then
:               a form feed is issued. ASD 11, PSD 12.14.7, section 6.5
:               refers.
:
: Called by     Several routines within this module
:
: On entry      Link register R1
:               Required line number in R4
:
: On exit       
:
: Uses          POSTOF in this module
:
: ---------------------------------------------------------------------
:
        SSTART(POSLIN)
        PUSH(R4,R5)
        LHI     R1,C.PAUT
        TBT     R1,CBITS,R11
        JE      POSL20                  :J if auto page off
        LHL     R1,CPFORM,R11
        SIS     R1,4
        CR      R4,R1
        JL      POSL20                  :J if new line not in last 4 of form
        CALL(POSTOF)                    :Send form feed
        J       POSL60
:
POSL20  CR      R4,R6                   :Current line number
        JGE     POSL30                  :J if required line >= current
        CALL(POSTOF)                    :Otherwise form feed
POSL30  LR      R5,R6                   :Current line number
        LR      R6,R4                   :Required line number
        LHI     R4,A.LFED               :Line feed
        J       POSL50
:
POSL40  WRITEB(NET)                     :Send line feeds until at req line
        AIS     R5,1                    :Increment current line number
POSL50  CR      R5,R6
        JL      POSL40
        LR      R7,R7                   :Current column
        JE      POSL60                  :J if CR not required
        LIS     R7,0
        LHI     R4,A.CR
        WRITEB(NET)                     :Send carriage return
POSL60  POP(R5,R4)
        RETURN
        SUBTTL POSTOF routine ... Position printer at top of form
:
: Routine name  POSTOF
:
: Function      To position the printer at the top of next form.
:
: Called by     Several routines within this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(POSTOF)
        PUSH(R4)
        LHI     R4,A.FF
        WRITEB(NET)                     :Send form feed to printer
        LHI     R4,A.CR
        WRITEB(NET)                     :Send CR to ensure col = 0
        LIS     R6,0                    :Line now 0
        LIS     R7,0                    :Column now 0
        POP(R4)
        RETURN
        SUBTTL PRTDAS routine ... Send data secured report
:
: Routine name  PRTDAS
:
: Function      To send a data secured report to the ICL host
:
: Called by     Several routines within this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTDAS)
        PUSH(R4)
        OPEN(IPBPTR)                    :Start message to printer host DCB
        LHI     R4,ISUPDS               :Data secured report supervisory
        WRITEB(IPBPTR)
        CLOSE(IPBPTR)
        POP(R4)
        RETURN
        SUBTTL PRTSTR routine ... Send printer status report
:
: Routine name  PRTSTR
:
: Function      To send a printer status report to the ICL host
:
: Called by     Several routines within this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTSTR)
        PUSH(R4)
        LHI     R4,PS.NOP
        LHI     R1,PS.ALL
        TBT     R1,CPSTAT,R11
        JE      PRTT40                  :J if printer not allocated
        LHI     R1,PS.IOP
        TBT     R1,CPSTAT,R11
        JN      PRTT40                  :J if printer inoperable
        RBT     R4,CPSTAT,R11           :Flag printer available
        J       PRTT60
PRTT40  SBT     R4,CPSTAT,R11           :Flag printer as unavailable
:
PRTT60  L       R1,CPDCB,R11
        JE      PRTT90                  :J if no printer DCB
        OPEN(IPBPTR)                    :Start message to printer host DCB
        LHI     R4,ISUPST               :Status report supervisory
        LHI     R1,PS.CT1
        RBT     R1,CPSTAT,R11
        JE      PRTT80                  :J if not category 1
        OHI     R4,80                   :Flag category 1
PRTT80  WRITEB(IPBPTR)
        LHL     R4,CPSTAT,R11           :Printer status is bits 8 - 0F
        OHI     R4,40                   :Set ICL bit 7
        WRITEB(IPBPTR)
	LHI	R4,A.ETX
	WRITEB(IPBPTR)
        CLOSE(IPBPTR)
PRTT90  POP(R4)
        RETURN
        SUBTTL PRTSCR routine ... Action local print key
:
: Routine name  PRTSCR
:
: Function      To action a local print key by sending a copy of the 
:               current screen image to the terminal printer. It is
:               terminated by a form feed. Only uses FF, CR and LF.
:
: Called by     KEY980 in ICLKEY
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTSCR)
        PUSH(R3,R4,R5,R6,R7)
        OPEN(NET)
        LHL     R4,TRMBPR,R9
        WRITES(NET)                     :Send start printing string
        LHL     R7,SSOM,R10             :Start at SOM
        LR      R4,R7
        LHI     R1,SCRWTH               :Calculate characters to end of line
        DHR     R4,R1
        LHI     R3,SCRWTH
        SR      R3,R4
        LIS     R5,0                    :Space skip count
PRTS10  LB      R4,SCNBUF,R10,R7        :Next character from screen
        THI     R4,ATMFST
        JE      PRTS20                  :J if not field start
        LHI     R4,A.SP                 :Replace field start by space
PRTS20  CHI     R4,A.SP
        JN      PRTS30                  :J if not space char
        AIS     R5,1                    :Increment skip count
        J       PRTS60
:
PRTS30  LR      R5,R5
        JE      PRTS50                  :J if not skipped spaces
        LHI     R4,A.SP
PRTS40  WRITEB(NET)                     :Output skipped spaces
        SIS     R5,1
        JN      PRTS40                  :J if not end of skipped spaces
        LB      R4,SCNBUF,R10,R7        :Restore non-space character
PRTS50  WRITEB(NET)                     :Print char
:
PRTS60  SIS     R3,1
        JN      PRTS70                  :J if not end of line
        LHI     R4,A.CR
        WRITEB(NET)                     :Send carriage return
        LHI     R4,A.LFED
        WRITEB(NET)                     : and line feed
        LIS     R5,0                    :Set skip count back to zero
        LHI     R3,SCRWTH               :Back to new line size
:
PRTS70  AIS     R7,1                    :Move down screen
        CHI     R7,SCRSIZ
        JL      PRTS80                  :J if not end of screen
        LIS     R7,0                    :Screen wrap
PRTS80  CLH     R7,SCURSR,R10
        JN      PRTS10                  :Continue up to cursor
:
        CALL(POSTOF)                    :Form feed (Changes R6,R7)
        LHL     R4,TRMFPR,R9
        WRITES(NET)                     :End printing string
        CLOSE(NET)
        POP(R7,R6,R5,R4,R3)
        RETURN
        SUBTTL INIPRT routine ... Initialise printer
:
: Routine name  INIPRT
:
: Function      To set up initial values for printer parameters, i.e.
:               line and column position, form length, status HW.
:
: Called by     LOGST in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(INIPRT)
        LIS     R1,0
        STH     R1,CPCOL,R11            :Column zero
        STH     R1,CPLINE,R11           :Line 0
        STH     R1,CPSTAT,R11           :Clear printer status HW
        LHI     R1,66
        STH     R1,CPFORM,R11           :66 line form
        LHI     R1,PS.IOP
        SBT     R1,CPSTAT,R11           :Set inoperable status
	LHI	R1,PS.NOP
	SBT	R1,CPSTAT,R11		:Set not operable bit
	CALL(PRTDSR)			:Get status report
        RETURN
        SUBTTL PRTHLD routine ... Action printer hold key
:
: Routine name  PRTHLD
:
: Function      To action key which replaces HOLD on printer.
:
: Called by     CMTKEY in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTHLD)
        LHI     R1,PS.HLD
        TBT     R1,CPSTAT,R11
        JE      PRTH50                  :J if not held
:
: Printer is held so user must want to cancel it
:
        RBT     R1,CPSTAT,R11           :Clear hold status
        J       PRTH90
:
: Printer is not on hold so user must want it set
:
PRTH50  SBT     R1,CPSTAT,R11           :Set hold status
PRTH90  CALL(PRTDSR)                    :Send device status to printer
        RETURN
        SUBTTL PRTALL routine ... Action printer allocate key
:
: Routine name  PRTALL
:
: Function      To action key which replaces ALLOCATE on printer.
:
: Called by     CMTKEY in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTALL)
        LHI     R1,PS.ALL
        TBT     R1,CPSTAT,R11
        JE      PRTL50                  :J if not allocated
:
: Printer is allocated so user must want to deallocate it
:
        RBT     R1,CPSTAT,R11           :Clear allocate status
        J       PRTL90
:
: Printer is dealloacted so user must want it allocated
:
PRTL50  SBT     R1,CPSTAT,R11           :Set allocate status
PRTL90  CALL(PRTDSR)                    :Send device status to printer
        RETURN
        SUBTTL PRTDSR routine ... Send device status request to printer
:
: Routine name  PRTDSR
:
: Function      To send a device status request to a printer.
:
: Called by     PRTHLD, PRTALL in this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTDSR)
        LHI     R1,C.PDSR
        SBT     R1,CBITS,R11
        JN      PRTD90                  :J if DSR outstanding
        PUSH(R4)
        OPEN(NET)
        LHL     R4,TRMDSR,R9
        WRITES(NET)                     :Send DSR
        CLOSE(NET)
        POP(R4)
PRTD90  RETURN
        SUBTTL PRTOPS routine ... Action device status operable report
:
: Routine name  PRTOPS
:
: Function      Action a device status operable report for a printer.
:               Clear inoperable and BNA bits. If waiting to de-allocate
:               then clear allocated bit and warning. If waiting to send
:               Report output complete report then send it.
:
: Called by     CMTKEY in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTOPS)
        PUSH(R5)
        LHL     R5,CPSTAT,R11           :Take copy of current state
        LHI     R1,PS.IOP
        RBT     R1,CPSTAT,R11           :Clear inoperable bit
        LHI     R1,PS.BNA
        RBT     R1,CPSTAT,R11           :Clear BNA bit
        JE      PRTO10                  :J if it was not set
        LHI     R1,PS.CT1
        SBT     R1,CPSTAT,R11           :Request category 1 status
PRTO10  LHI     R1,PS.WDA
        RBT     R1,CPSTAT,R11           :Clear waiting de-allocate
        JE      PRTO30                  :J if not waiting de-allocate
        LHI     R1,PS.ALL
        RBT     R1,CPSTAT,R11           :De-allocate
        LHI     R1,PS.WRN
        RBT     R1,CPSTAT,R11           :Clear warning
PRTO30  LHI     R1,PS.ROC
        RBT     R1,CPSTAT,R11
        JE      PRTO50                  :J not waiting report output complete
        CALL(PRTDAS)                    :Send report
PRTO50	LHI	R1,PS.ALL
	TBT	R1,CPSTAT,R11
	JE	PRTO60			:J if not allocated
	LHI	R1,PS.NOP
	RBT	R1,CPSTAT,R11		:Mark as available
	J	PRTO70
PRTO60	LHI	R1,PS.NOP
	SBT	R1,CPSTAT,R11		:Mark as unavailable
PRTO70  NHI     R5,3                    :Mask out NOP and BNA bits
        LHL     R1,CPSTAT,R11
        NHI     R1,3
        CR      R1,R5
:       JE      PRTO80                  :J if no change in BNA or NOP bits
        CALL(PRTSTR)                    :Report chanage to mainframe
PRTO80  LHI     R1,C.PSCR
        RBT     R1,CBITS,R11
        JE      PRTX70                  :J if not waiting screen print
        CALL(PRTSCR)
        J       PRTX70                  :Check if any printer actions o/s
        SUBTTL PRTXPS routine ... Action device status inoperable report
:
: Routine name  PRTXPS
:
: Function      Action a device status inoperable report for a printer.
:               Set inoperable bits. 
:
: Called by     CMTKEY in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTXPS)
        PUSH(R5)
        LHI     R1,PS.IOP
        SBT     R1,CPSTAT,R11           :Mark printer as inoperable
        LHI     R1,PS.NOP
        SBT     R1,CPSTAT,R11           : and not available
	LHI     R1,C.PSCR		:Clear any screen print request
        RBT     R1,CBITS,R11
PRTX70  LHI     R1,C.PDSR
        RBT     R1,CBITS,R11            :No longer waiting for DSR
        LHI     R1,C.PDAT
        RBT     R1,CBITS,R11
        JE      PRTX90                  :J if no data ALP available
        CALL(PRTALP)
PRTX90  POP(R5)
        RETURN
:
        EM

        SUBTTL ICLKEY ... ICL keyboard emulator

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 JUL 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        GL      REJECT                  :REJECT is in TERM
        SEG     A.CODE                  :Segment to contain this module
        MO      .,ICLKEY                :Delimit module
:
: This module contains routines required to emulate an ICL keyboard.
:
:       ICLKEY - Process ICL formatted keyboard input
:       NXTFLD - Find start of next field
:       MOVCUR - Move cursor
:
: There are no macros unique to this module.
        SUBTTL ICLKEY routine ... Action normal key input
:
: Routine name  ICLKEY
:
: Function      To action an ICL key input. Call KEYCTL if control
:               key. If status is not 'TYPE' or current field is
:               protected then key is discarded and user belled. 
:               Exception to above is for reset key which is permitted at any 
:               time. Otherwise screen is updated and output using 
:               OUTSCR. ASD 9, 3.9.1 refers.
:
: Called by     TERMH
:
: On entry      ICL coded key in R5
:
: On exit       Screen will have been updated
:
: Uses          REJECT in this module
:               OUTSCR in OUTSCR
:
: ---------------------------------------------------------------------
:
        RSTART(ICLKEY)
        PUSH(R4)
	L	R10,DSCNBF,R12
	JN	ICLK05			:J if old and new buffer
        L       R10,CSCNBF,R11          :Address of screen buffer
ICLK05  LHL     R7,SCURSR,R10           :Current cursor position
        LHL     R6,SCATTR,R10           :Current attribute
        LHI     R1,C.ACTN
        RBT     R1,CBITS,R11            :Check action key qualifier awaited
        JE      ICLK10                  :J if it is not
        CALL(KEY910)                    :Process action key
        J       ICLK90
:
ICLK10  LHL     R1,CVSTAT,R11           :VDU status
        CHI     R1,VS.TYP               
        JE      ICLK20                  :Jump if in 'type' mode
        CHI     R5,RESET
        JN      ICLK40                  :J if not reset
:
ICLK20  CHI     R5,A.SP                 :Is it a control key?
        JGEFS   ICLK30                  :Jump if it is not
        CALL(KEYCTL)                    :Process control key
        J       ICLK90                  :Return
:
ICLK30  THI     R6,ATMPRO               :Check current attribute
        JE      ICLK60                  :Jump if position unprotected
:
: We have received a key when we are not in TYPE mode or the current
: character position is protected.
:
ICLK40  CALL(REJECT)                    :Discard character and send bell
        J       ICLK90                  :Next character
:
: Valid graphic character 
:
ICLK60	LB	R5,TRMASC,R5,
	STB     R5,SCNBUF,R10,R7        :Put byte at cursor position
        LIS     R4,1
        CALL(MOVCUR)                    :Move on cursor
        LHI     R1,OFONEC               :Tell OUTSCR we've only written a
        STH     R1,SOUTFL,R10           : character at cursor position
        CALL(OUTSCR)                    :Update physical screen
:
: Common return point
:
ICLK90  POP(R4)
        RETURN
        SUBTTL KEYCTL routine ... Action control key input
:
: Routine name  KEYCTL
:
: Function      To action a normal key input. Jump to KEY200 if control
:               key. If status is not 'TYPE' or current field is
:               protected then key is discarded and user belled. 
:               Otherwise screen is updated and output using 
:               OUTSCR. ASD 9, 3.9.1 refers.
:
: Called by     KEYBD
:
: On entry      Control key character in R5
:               Link register in R1
:
: On exit       
:
: Uses          REJECT in this module
:               OUTSCR in OUTSCR
:
: ---------------------------------------------------------------------
:
        RSTART(KEYCTL)                  :Save link register
        CHI     R5,DOLLAR
        JG      KEYC80                  :J if illegal control key code
        SLHLS   R5,2                    :Convert key code into an index
        J       KEYC20,R5               :Process control key by type
        : We return to main routine using link register R1 on stack
:
: Jump table for control keys
:
KEYC20  J       KEY200                  :Tab
        J       KEY250                  :Backtab
        J       KEY300                  :Cursor right
        J       KEY320                  :Cursor left
        J       KEY340                  :Cursor up
        J       KEY360                  :Cursor down
        J       KEY400                  :Home
        J       KEY420                  :Set SOM
        J       KEY440                  :Clear screen
        J       KEY450                  :Newline
        J       KEY500                  :Delete character
        J       KEY550                  :Insert character
        J       KEY600                  :Delete line
        J       KEY700                  :Insert line
        J       KEY800                  :Erase message
        J       KEY850                  :Erase line
        J       KEY900                  :Action message
        J       KEY960                  :Send message
        J       KEY980                  :Print screen
        J       KEY100                  :Reset (interlock)
	J	KEY150			:Next line
	J	KEY990			:Dollar symbol
:
: Illegal control key code
:
KEYC80  CRUNCH(CRIKEY)
:
: RESET - Set type mode and clear error condition
:
: Otherwise known as interlock this key forces type mode in from all states.
: It also clears and error condition (currently none).
:
KEY100  LHI     R1,VS.TYP
        STH     R1,CVSTAT,R11
        LHI     R1,OFSTAT               :Status change only
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        RETURN
:
: NXTLIN - Move cursor to start of next line
:

KEY150	PUSH(R4)
	LHI	R1,SCRWTH
	LR	R0,R7
	DHR	R0,R1
	SHI	R0,SCRWTH
:
	LIS	R1,0
	SR	R1,R0
	LR	R4,R1
	CALL(MOVCUR)
	LHI	R4,OFCURS
	STH	R4,SOUTFL,R10
	CALL(OUTSCR)
	POP(R4)
	RETURN
:
: FLDTAB - Tab to next unprotected field
: Allowed anywhere
:
: Moves the cursor to the first character position within the next
: unprotected field on the screen. If there are no more unprotected
: fields, then the cursor moves to the top left of the screen, regardless
: of the type of field at that position
:
: On Exit       R7 contains new cursor position
:               R6 contains  attribute of that position
:
KEY200  LHL     R1,SFLDS,R10            :Field count
        JE      KEY220                  :Jump if no fields defined
        J       KEY215
:
KEY210  AIS     R7,1                    :Next position on screen
        CHI     R7,SCRSIZ       
        JE      KEY220                  :Jump if end of screen
KEY215  LB      R6,SCNBUF,R10,R7
        THI     R6,ATMFST
        JE      KEY210                  :Jump if not start of field
        THI     R6,ATMPRF               :Is this a unprotected field
        JN      KEY210                  :Jump if it is not
        AIS     R7,1                    :Position after start
        CHI     R7,SCRSIZ               :Handle wrap
        JN      KEY230
KEY220  LIS     R7,0
KEY230  STH     R7,SCURSR,R10           :Save new cursor position
        CALL(FNDATR)                    :Find its attribute in R6
        STH     R6,SCATTR,R10
        LHI     R1,OFCURS               :Indicate cursor move only
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        RETURN  
:
: BACKTAB - Tab back to start of unprotected
: Allowed anywhere
:
: Moves the cursor to the first position within the current unprotected
: field .If the cursor is already at the first character of an
: unprotected filed or if the cursor is not within an unprotected field,
: it moves to the start of the preceeding protected field. screen wrap is
: not effective, and the cursor always stops at the top left of the screen
: regardless of the current contents of that position.
:
: On Exit       R7 contains new cursor position
:               R6 contains attribute of that position
:
KEY250  LHL     R0,SFLDS,R10            :Count of fields
        JE      KEY270                  :Jump if unformatted
        SIS     R7,1                    :Move back
KEY260  SIS     R7,1                    :Move back
        JLE     KEY270                  :Jump if off screen or at start
        LB      R1,SCNBUF,R10,R7        :Test for start of field
        THI     R1,ATMFST
        JE      KEY260                  :Jump if not start of
        THI     R1,ATMPRF
        JN      KEY260                  :Jump if not unprotected
        AIS     R7,1                    :Move to start of field + 1
        JFS     KEY280
:
KEY270  LIS     R7,0                    :Start of screen
KEY280  STH     R7,SCURSR,R10           :Save new cursor position
        CALL(FNDATR)                    :Find its attribute in R6
        STH     R6,SCATTR,R10           : and save it
        LHI     R1,OFCURS               :Flag only cursor move
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        RETURN  
:
: CURRIGHT function - Move cursor right. 
: Allowed anywhere.
:
: Moves cursor one position to the right. Line wrap occurs from the last
: position on the current line to the first position on the next line.
: Frame wrap round occurs from the bottom line to the top line.
:
:
: On Exit       R7 contains new cursor position
:               R6 contains attribute of that position
:
KEY300  PUSH(R4)                        :Save register
        LIS     R4,1                    :One character forward
        CALL(MOVCUR)                    :Move cursor
        LHI     R4,OFCURS               :Flag only cursor move
        STH     R4,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        POP(R4)                         :Restore register
        RETURN
:
: CURLEFT - Move cursor left. 
: Allowed anywhere.
:
: Moves cursor one position to the left. Line wrap occurs from the first
: position on the current line to the last position on the previous line.
: Frame wrap round occurs from the top line to the bottom line.
:
: On Exit       R7 contains new cursor position
:               R6 contains attribute of that position
:
KEY320  PUSH(R4)                        :Save register
        LCS     R4,1                    :One character back
        CALL(MOVCUR)                    :Move cursor
        LHI     R4,OFCURS               :Flag only cursor move
        STH     R4,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        POP(R4)                         :Restore register
        RETURN
:
: CURUP - Move cursor up. 
: Allowed anywhere.
:
: Moves cursor up one line. Frame wrap round occurs from top line to
: bottom line.
:
: On Exit       R7 contains new cursor position
:               R6 contains attribute of that position
:
KEY340  PUSH(R4)                        :Save register
        LHI     R4,-SCRWTH              :One line back
        CALL(MOVCUR)                    :Move cursor
        LHI     R4,OFCURS               :Indicate cursor move only
        STH     R4,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        POP(R4)                         :Restore register
        RETURN
:
: CURDOWN - Move cursor down.
: Allowed anywhere.
:
: Moves cursor one line down. Frame wrap occurs from bottom line to top
: line.
:
: On Exit       R7 contains new cursor position
:               R6 contains attribute of that position
:
KEY360  PUSH(R4)                        :Save register
        LHI     R4,SCRWTH               :One line forward
        CALL(MOVCUR)                    :Move cursor
        LHI     R4,OFCURS               :Flag only cursor move
        STH     R4,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        POP(R4)                         :Restore register
        RETURN
:
: HOME - Move cursor to SOM.
: Allowed anywhere.
:
: Move the cursor to the current start of message (SOM) position.
:
: On Exit       R7 contains new cursor position
:               R6 contains attribute of that position
:
KEY400  PUSH(R4)
        LHL     R7,SSOM,R10             :Som offset
        STH     R7,SCURSR,R10           : into cursor offset
        LHL     R6,SSATTR,R10           :Som attribute
        STH     R6,SCATTR,R10           : into cursor attribute
        LHI     R4,OFCURS               :Flag only cursor movement
        STH     R4,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        POP(R4)
        RETURN
:
: FCNSOM - SOM control.
: Allowed anywhere
:
: Move start of message marker (SOM) to the current cursor position.
: May be inhibited by host thro set screen control command. ASD 9,
: Appendix b.1 refers.
:
KEY420  LHI     R1,C.NSOM               :Has Som movement been inhibited
        TBT     R1,CBITS,R11
        JE      KEY430                  :Jump if it has not
        CALL(REJECT)                    :Discard char and bell user
        RETURN  
:
KEY430  STH     R7,SSOM,R10             :Cursor position into SOM
        STH     R6,SSATTR,R10           :Cursor attribute into SOM attribute
        LHI     R1,OFSOM                :Flag only SOM movement
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        RETURN
:
: FCNCLR - Clear screen
: Allowed anywhere.
:
: Clear the entire screen. The cursor and SOM are positioned at the top
: left of the screen which is all unprotected.
:
KEY440  CALL(CLRSCR)                    :Clear screen image
        LHI     R1,OFCLRS
        STH     R1,SOUTFL,R10           :Indicate a cleared screen
        CALL(OUTSCR)                    :Update physical screen
        RETURN  
:
: NEWLINE - Move cursor to first position on next line
: Allowed anywhere
:
: May display the non-proteced symbol at the current cursor position,
: provided the cursor is positioned within an unproteced field. all the
: remaining unprotected characters on the same line are erased to
: unprotected spaces. The cursor is positioned to the left hand end of
: the next line and frame wrap round occurs. ASD 9, 3.9.2 refers.
:
: On Exit       R7 contains new cursor position
:               R6 contains attribute of that position
:
KEY450  CALL(COPYSC)                    :Take a copy of screen image
        PUSH(R0,R4,R6)                  :Save registers
        LR      R0,R7                   :Calc no of chars to end of line
        LHI     R1,SCRWTH
        DHR     R0,R1
        SHI     R0,SCRWTH               :As negative count
        LHI     R4,A.SP                 :For space filling
        THI     R6,ATMPRO               :Is current field protected
        JN      KEY470                  :Jump if it is
        LHI     R1,I.NL 
        STB     R1,SCNBUF,R10,R7        :Store newline symbol on screen
KEY470  AIS     R7,1                    :Next position
        AIS     R0,1    
        JE      KEY490                  :Jump if end of line
        LB      R1,SCNBUF,R10,R7
        THI     R1,ATMFST
        JE      KEY480                  :Jump if not start of field
        LR      R6,R1
        J       KEY470                  :Next position
KEY480  NHI     R6,ATMNFS               :Remove field start bit
        THI     R6,ATMPRO
        JN      KEY470                  :Jump if protected
        STB     R4,SCNBUF,R10,R7        :Space fill
        J       KEY470                  :Next position
KEY490  POP(R6,R4,R0)                   :Restore registers
	CHI	R7,SCRSIZ		:Deal with screen wrap
	JL	KEY491
	LIS	R7,0
KEY491	STH	R7,SCURSR,R10		:Save the cursor position
        CALL(FNDATR)                    :Find current attribute in R6
        STB     R6,SCATTR,R10           :Save new attribute
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Tell OUTSCR we've two buffers
        CALL(OUTSCR)                    :Update physical screen
        RETURN  
:
: DELCHAR - Delete character.
: Allowed within protected field only.
:
: Deletes the character at the current cursor position. All the
: remaining characters up to the end of the line, or the end of the field,
: whichever occurs first, are moved one position to the left.
:
KEY500  THI     R6,ATMPRO               :Is the current position protected
        JE      KEY510                  :Jump if it is not
        CALL(REJECT)                    :Discard char and bell user
        RETURN
:
KEY510  CALL(COPYSC)                    :Get copy of the current screen
        PUSH(R0,R7)                     :Save registers
        LR      R0,R7                   :Calculate no of chars to end
        LHI     R1,SCRWTH               : of line in R1 (negative)
        DHR     R0,R1
        SHI     R0,SCRWTH
:
: We now loop round moving characters one position to the left until we
: hit end of line (R0 = 0) or we hit a start of field
:
KEY520  AIS     R0,1                    :Reduce (!) count to end of line
        JE      KEY530                  :Jump if end of line
        LB      R1,SCNBUF+1,R10,R7
        THI     R1,ATMFST
        JN      KEY530                  :J if end of field
        STB     R1,SCNBUF,R10,R7        :Move character to left
        AIS     R7,1                    
        J       KEY520                  :Next character position
:
KEY530  LHI     R0,A.SP
        STB     R0,SCNBUF,R10,R7        :Put space on end of line or field
        POP(R7,R0)                      :Restore registers
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Flag two buffers to OUTSCR
        CALL(OUTSCR)                    :Output physical screen
        RETURN  
:
: INSCHAR - Insert character.
: Allowed within protected field only.
:
: Causes a space to be inserted at the current cursor position. The
: remainder of the field up until the end of the line is moved one
: position to the right. The final character in the line (or field, if
: the field ends before the end of line) is lost.
: 
KEY550  THI     R6,ATMPRO               :Is the current position protected
        JE      KEY560                  :Jump if it is not
        CALL(REJECT)                    :Discard char and bell user
        RETURN
:
KEY560  CALL(COPYSC)                    :Get copy of the current screen
        PUSH(R0,R6,R7)                  :Save registers
        LR      R0,R7                   :Calculate no of chars to end
        LHI     R1,SCRWTH               : of line in R1 (negative)
        DHR     R0,R1
        SHI     R0,SCRWTH
:
: We now loop round moving characters one position to the right until we
: hit end of line (R0 = 0) or we hit a start of field
:
        LB      R6,SCNBUF,R10,R7        :Character to be moved
KEY570  AIS     R0,1                    :Reduce (!) count to end of line
        JE      KEY580                  :Jump if end of line
        LB      R1,SCNBUF+1,R10,R7
        THI     R1,ATMFST
        JN      KEY580                  :J if end of field
        STB     R6,SCNBUF+1,R10,R7      :Move character to right
        LR      R6,R1
        AIS     R7,1                    
        J       KEY570                  :Next character position
:
KEY580  POP(R7,R6,R0)                   :Restore registers
        LHI     R1,A.SP
        STB     R1,SCNBUF,R10,R7        :Put space at cursor position
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Flag two buffers to OUTSCR
        CALL(OUTSCR)                    :Output physical screen
        RETURN  
:
: DELLINE - Delete line.
: Allowed within protected field only.
:
: Deletes one line length (80 characters) of the current unprotected
: field.The 80 characters commence with the current cusor position. The
: remainder of the field contents are closed up. Should there be less
: than eighty characters after the cursor, the entire remainder of the
: field is deleted.
:
KEY600  THI     R6,ATMPRO               :Is the current position protected
        JE      KEY610                  :Jump if it is not
        CALL(REJECT)                    :Discard char and bell user
        RETURN
:
KEY610  CALL(COPYSC)                    :Get copy of the current screen
        PUSH(R0,R6,R7)                  :Save registers
        CALL(NXTFLD)                    :Find position of next field in R0
        SR      R0,R7                   :Calc size of rest of this one
        JGFS    KEY620                  : from cursor to end of field
        AHI     R0,SCRSIZ
KEY620  CHI     R0,SCRWTH               :Less than 80 characters long
        JLE     KEY670                  : jump if it is
:
: Field is greater than 80 characters so close up contents of field
:
        SHI     R0,SCRWTH               :R0 contains no of chars to close
        LR      R6,R7
        AHI     R6,SCRWTH               :From cursor+80 to cursor
KEY630  CHI     R6,SCRSIZ
        JLFS    KEY640                  :Handle screen wrap
        SHI     R6,SCRSIZ
KEY640  LB      R1,SCNBUF,R10,R6        :Close up field
        STB     R1,SCNBUF,R10,R7        
        AIS     R7,1                    :Move on
        CHI     R7,SCRSIZ               :Handle screen wrap
        JL      KEY650
        LIS     R7,0
KEY650  AIS     R6,1
        CHI     R6,SCRSIZ
        JL      KEY660
        LIS     R6,0                    :Deal with screen wrap
KEY660  SIS     R0,1                    :More characters to close up
        JN      KEY630
        LHI     R0,SCRWTH               :No of characters to space fill
                                        : at end of field
:
: Now delete remainder of field. R0 contains size.
:
KEY670  LHI     R1,A.SP                 :Space fill
KEY680  STB     R1,SCNBUF,R10,R7
        AIS     R7,1                    :Move on thro screen
        CHI     R7,SCRSIZ
        JL      KEY690                  :Handle screen wrap
        LIS     R7,0
KEY690  SIS     R0,1
        JN      KEY680                  :Continue till end of field
:
        POP(R7,R6,R0)                   :Restore registers
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Flag two buffers to OUTSCR
        CALL(OUTSCR)                    :Update physical screen
        RETURN
:
: INSLINE - Insert line.
: Allowed within protected field only.
:
: Inserts a line length of spaces (80 characters) at the current cursor
: position. All the characters within the field to the right of, and
: including, the current cursor position, are moved 80 characters to the
: right. All characters that overflow the end of the field are lost. If
: there are less than 80 characters after the cursor, the field is
: completely deleted to the right.
:
KEY700  THI     R6,ATMPRO               :Is the current position protected
        JE      KEY710                  :Jump if it is not
        CALL(REJECT)                    :Discard char and bell user
        RETURN
:
KEY710  CALL(COPYSC)                    :Get copy of the current screen
        PUSH(R0,R6,R7)                  :Save registers
        CALL(NXTFLD)                    :Find position of next field
        SR      R0,R7                   :Calc size of rest of this one
        JGFS    KEY720                  : from cursor to end of field
        AHI     R0,SCRSIZ
KEY720  CHI     R0,SCRWTH               :Less than 80 characters long
        JLE     KEY770                  : jump if it is
:
: Field is greater than 80 characters so move characters to the right
:
        SHI     R0,SCRWTH               :R0 contains no of chars to move
        AR      R7,R0                   :Point to end of move area
        SIS     R7,1
        CHI     R7,SCRSIZ
        JL      KEY725
        AHI     R7,SCRSIZ               :Deal with screen wrap
KEY725  LR      R6,R7
        AHI     R6,SCRWTH               :From cursor to cursor+80
KEY730  CHI     R6,SCRSIZ
        JLFS    KEY740                  :Handle screen wrap
        SHI     R6,SCRSIZ
KEY740  LB      R1,SCNBUF,R10,R7        :Open up field
        STB     R1,SCNBUF,R10,R6
        SIS     R7,1                    :Move on
        JN      KEY750
        LHI     R7,SCRSIZ-1             :Handle wrap
KEY750  SIS     R6,1
        JN      KEY760
        LHI     R6,SCRSIZ-1             :Deal with screen wrap
KEY760  SIS     R0,1                    :More characters to open up
        JN      KEY730
        LHI     R0,SCRWTH               :No of characters to space fill
                                        : at end of field
:
: Now insert line at front of field. R0 contains size.
:
KEY770  LHI     R1,A.SP                 :Space fill
        LHL     R7,SCURSR,R10           :From cursor position
KEY780  STB     R1,SCNBUF,R10,R7
        AIS     R7,1                    :Move on thro screen
        CHI     R7,SCRSIZ
        JL      KEY790                  :Handle screen wrap
        LIS     R7,0
KEY790  SIS     R0,1
        JN      KEY780                  :Continue till end of field
        POP(R7,R6,R0)                   :Restore registers
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Flag two buffers to OUTSCR
        CALL(OUTSCR)                    :Update physical screen
        RETURN  
:
: ERSMESS - Erase message
: Allowed anywhere
:
: Erases all the unprotected fields after, and including, the current
: cursor position, to the end of line.
:
KEY800  CALL(COPYSC)                    :Get a copy of the screen
        PUSH(R0,R6,R7)                  :Save registers
        LHI     R1,A.SP                 :Space fill character
        NHI     R6,ATMPRF               :Mask out protected bit
KEY810  LB      R0,SCNBUF,R10,R7        :Is current position a start of field
        THI     R0,ATMFST
        JE      KEY820                  :Jump if it is not
        LR      R6,R0                   :Else extract protected bit
        NHI     R6,ATMPRF
        J       KEY830                  :Skip space fill for start of field
:
KEY820  LR      R6,R6
        JN      KEY830                  :Jump if protected
        STB     R1,SCNBUF,R10,R7        :Space fill if unprotected
KEY830  AIS     R7,1                    :Move down screen
        CHI     R7,SCRSIZ
        JN      KEY810                  :Contine until end of screen
:
        POP(R7,R6,R0)                   :Restore registers
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Flag two buffers to OUTSCR
        CALL(OUTSCR)                    :Update physical screen
        RETURN  
:
: ERSLINE - Erase line
: Allowed within unprotected field only.
:
: Erases the field up until the end of the line. The erasing commences
: at the current cursor position. If the field ends before the end of the
: line, the entire remainder of the field is erased. A field is not closed
: up after erasing.
:
KEY850  THI     R6,ATMPRO               :Is the current position protected
        JE      KEY860                  :Jump if it is not
        CALL(REJECT)                    :Discard char and bell user
        RETURN
:
KEY860  CALL(COPYSC)
        PUSH(R0,R2,R7)                  :Save registers
        LR      R0,R7                   :Calculate no of chars to end
        LHI     R1,SCRWTH               : of line in R1 (negative)
        DHR     R0,R1
        SHI     R0,SCRWTH
        LHI     R1,A.SP                 :Character for space filling
:
: Loop round filling positions with spaces until end of line or start
: of field found.
:
KEY870  STB     R1,SCNBUF,R10,R7        :Space fill
        AIS     R7,1                    :Next screen position
        AIS     R0,1
        JE      KEY880                  :Jump if end of line
        LB      R2,SCNBUF,R10,R7
        THI     R2,ATMFST
        JE      KEY870                  :Jump if not start of field
:
KEY880  POP(R7,R2,R0)                   :Restore registers
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Flag two buffers to OUTSCR
        CALL(OUTSCR)                    :Update physical screen
        RETURN  
:
: ACTION - Process action key.
: Allowed anywhere.
:
: Generate a Program Function Report from an action key sequence.
: Get next key as the qualifier for the report and send to host.
: Valid qualifier is 20 to 7F (hex).
: Terminal is left in send mode only while message is being generated
: (very short period). 
:
KEY900  LHI     R1,C.ACTN               :Flag action key in progress
        SBT     R1,CBITS,R11
        RETURN
:
: Reenter here with action key qualifier in R5
:
        SSTART(KEY910)
        CHI     R0,A.SP                 :Qualifier must be 20 - 7F
        JL      KEY920                  :Jump if not valid
:
        LHI     R1,VS.SND               :Entering send mode
        STH     R1,CVSTAT,R11
        LHI     R1,OFSTAT               :Status change only
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        CALL(SENDPF)                    :Send Program Function message
        LHI     R1,VS.RX                :Now receive mode
        STH     R1,CVSTAT,R11
        LHI     R1,OFSTAT               :Status change only
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        J       KEY940                  :End routine
:
: We have received an invalid action key qualifier
:
KEY920  CALL(REJECT)                    :Reject character and bell user
:
KEY940  RETURN  
:
: SEND - Send message to host
: Allowed anywhere
:
: The contents of all the unprotected fields between the SOM and cursor
: are sent to the host. USES routine SENDMS in SEND to action function.
: The terminal enters Send status mode only while message is being sent to
: HIF. This will only be for a noticeable period if we are being
: backpressured.
:
KEY960  LHI     R1,VS.SND               :Entering send mode
        STH     R1,CVSTAT,R11
        LHI     R1,OFSTAT               :Status change only
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        CALL(SENDMS)
        LHI     R1,VS.RX                :Entering receive mode
        STH     R1,CVSTAT,R11
        LHI     R1,OFSTAT               :Status change only
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        RETURN
:
: FCNPRT - Screen print
: Allowed anywhere
:
: Print the contents of the screen  to a locally attached printer. Uses
: PRTSCR routine to action function. The terminal is in Local mode while
: printer data is buffered up and will only stay in this state for a
: noticable period if we are backpreesured. returns to Type mode before
: return.
:
KEY980  LHI     R1,VS.LCA               :Entering local mode
        STH     R1,CVSTAT,R11
        LHI     R1,OFSTAT               :Status change only
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
	CALL(PRTDSR)			:Request printer status
	LHI	R1,C.PSCR		:Flag screen print required
	SBT	R1,CBITS,R11
        LHI     R1,VS.TYP               :Entering Type mode
        STH     R1,CVSTAT,R11
        LHI     R1,OFSTAT               :Status change only
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Update physical screen
        RETURN

: DOLLAR function
:
: The ASCII character set does not support both dollar and pound symbols
: in the printable range x'20' to x'7f'. This routine uses the ASCII NAK
: (x'15) to represent the dollar in the screen buffer. The character
: translation tables ASCTRM, ASCICL and ICLASC should be modified with
: the REMAPC macro as follows :-
: REMAPC(ASCTRM,15,0C4)
: REMAPC(ASCICL,15,5C)
: REMAPC(ICLASC,5C,15)

KEY990	PUSH(R4)
	THI	R6,ATMPRO		:Check current attribute
	JE	KEY992			:Skip if unprotected
	CALL(REJECT)			:Discard and send bell
	J	KEY994			:Get out
KEY992	LHI	R5,A.NAK
	STB	R5,SCNBUF,R10,R7	:Put byte at cursor position
	LIS	R4,1
	CALL(MOVCUR)			:Move cursor on
	LHI	R1,OFONEC		:One char change only
	STH	R1,SOUTFL,R10
	CALL(OUTSCR)			:Update physical screen
KEY994	POP(R4)
	RETURN


        SUBTTL NXTFLD routine ... Find start of next field
:
: Routine name  NXTFLD
:
: Function      This routine finds the start of the next field on
:               the screen. If the screen is not formatted this is 
:               offset zero though it should strictly be at -1.
:               ASD 9, 3.7 and 3.7.1 refer.
:
: Called by     Several routines in this module
:
: On entry      Current cursor position in R7
:               Link register R1
:
: On exit       R0 contains address of start of next field. All registers are
:               preserved.
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(NXTFLD)
        LHL     R1,SFLDS,R10            :If there are no fields
        JE      NXTF60                  :Jump with R1 = 0 = Start of field
        LR      R1,R7                   :Use R1 as search offset from cursor
NXTF20  AIS     R1,1                    :Move down screen
        CHI     R1,SCRSIZ       
        JN      NXTF40                  :Handle wrap
        LIS     R1,0
NXTF40  LB      R0,SCNBUF,R10,R1        :Is this a start of field
        THI     R0,ATMFST
        JE      NXTF20                  :Jump if not
NXTF60  LR      R0,R1                   :Put address in register 0
        RETURN 
        SUBTTL MOVCUR routine ... Move cursor and find new attributes
:
: Routine name  MOVCUR
:
: Function      This routine moves the cursor and finds the current
:               field attribute at the new position.
:
: Called by     Several routines in this module
:
: On entry      Relative offset to current position in R4
:               Link register R1
:
: On exit       R7 contains the new cursor position.
:               R6 contains attribute of new position.
:               All registers are preserved.
:
: Uses          FNDATR in this module.
:
: ---------------------------------------------------------------------
:
        SSTART(MOVCUR)
        PUSH(R4)                        :Save register
        AR      R7,R4                   :Move cursor
        JGE     MOVC10                  :Jump if not off front
        AHI     R7,SCRSIZ               :Bring back on screen (Wrap)
        JFS     MOVC20
:
MOVC10  CHI     R7,SCRSIZ               :Jump if not off end
        JLFS    MOVC20
        SHI     R7,SCRSIZ               :Bring back on screen
:
MOVC20  STH     R7,SCURSR,R10           :Save new cursor position
        SIS     R4,1
        JN      MOVC40                  :Jump if move not +1
:
: If we've only moved one character on we can determine new attribute
: quickly.
:
        LB      R1,SCNBUF,R10,R7
        THI     R1,ATMFST
        JN      MOVC30                  :Jump if start of field
        NHI     R6,ATMNFS               :Remove start of field bit
        JFS     MOVC50
:
MOVC30  LR      R6,R1                   :Extract new attribute
        JFS     MOVC50
:
: Longer method of finding attribute
:
MOVC40  CALL(FNDATR)                    :Determine new attribute in R6
MOVC50  STH     R6,SCATTR,R10           :Store new attribute
        POP(R4)                         :Restore register
        RETURN 
:
        EM


        SUBTTL VIDALP ... ICL Video ALP message handler

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 14 MAR 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,ICLALP                :Delimit module
:
: This module contains routines which interprete and action an ICL ALP
: received from the host interface:
:
:       ICLALP - Process ICL ALP
:       SUPER - Action supervisory ALP
:       ALPCHR - Action individual ALP character
:       CLRSCC - Reset screen controls
:       FIELDS - Set up field counters, etc, in screen buffer
:       INIVID - Initialise video parameters
:
: The following macros are unique to this module:
:       QUALFV - Get a qualifier from the ALP
:       CHKSEQ - Check device control sequences
:
        SUBTTL ICLALP ... Macros
:
: ----------------------------------------------------------------------
:
: Macro         QUALFV
:
: Description   Get a qualifier to an ICL control code. This is acheived by
:               setting a flag to indicate that a qualifiy is required,
:               storing the continuation address in the CCB and returning
:               to the caller of ALPCHR. This has the effect that we
:               appear to drop out of macro with qualifier byte in R0.
:
: Parameters    
:
: ----------------------------------------------------------------------
:
X       EQ      0
QUALFV  MACRO [
        LHI     R1,C.VQUA
        SBT     R1,CBITS,R11            :Set flag to indicate qualifier 
        LA      R1,ADD|X|
        ST      R1,CVQUAL,R11           :Continuation address
        RETURN
ADD|X|  EQ      .
X       EQ      X+1
]
:
: ----------------------------------------------------------------------
:
: Macro         CHKSEQ
:
: Description   Check the device control sequences. If device control is out 
:               of order then code is ignored by jumping to address provided.
:               Reference ASD 9, 6.4.
:
: Parameters    DCODE - Device code index
:               ADDRES - Address to go to if code out of sequence
:
: ----------------------------------------------------------------------
:
CHKSEQ  MACRO (DCODE,ADDRES) [
: currently do nothing
]
        SUBTTL VIDALP routine ... Process ALP message
:
: Routine name  VIDALP
:
: Function      To process an ICL video ALP fragment received from the host
:               interface. If it is a supervisory ALP it is processed in
:               routine SUPERV. A data ALP is read a character at a time
:               calling ALPCHR to action each one. A copy of the screen is
:               updated by this process and then used to update the physical
:               screen.
:
: Called by     TERMH
:
: On entry      An ALP fragment is available for processing.
:
: On exit       Screen will have been updated
:
: Uses          OUTSCR in OUTSCR
:               READA in INOUT
:               COPYSC in SCRMIS
:               ALPCHR, SUPERV in this module
:               PUTSCB in CBDEF
:               SENDST in SEND
:
: ---------------------------------------------------------------------
:
        RSTART(VIDALP)
        PUSH(R0)
        LHI     R1,C.VALP
        TBT     R1,CBITS,R11
        JN      ICLA20                  :J if this is continuation fragment
:
: This is the first fragment of an ALP
:
        LR      R1,R0                   :Keep prefix
        NHI     R1,ITQMSK               :Extract text qualifier field
        CHI     R1,IALPDA
        JN      SUPERV                  :J if supervisory ALP
: 
: We have a data ALP. Force receive mode if not already there.
:
        LHI     R1,VS.RX                :Force receive state if not already
        CLH     R1,CVSTAT,R11           : in that state
        JE      ICLA10
        STH     R1,CVSTAT,R11
        LHI     R1,OFSTAT
        STH     R1,SOUTFL,R10           :Flag status only change
        CALL(OUTSCR)
:
ICLA10  LHI     R1,VS.TYP               :End in type state unless changed
        STH     R1,SFSTAT,R10           : by set state in ALP
        READ(IPBVID)                    :Next character of ALP
        J       ICLA90                  :J if end of fragmnet
ICLA20  L       R10,DSCNBF,R12
        JNFS    ICLA40                  :J if we already have a screen copy
        CALL(COPYSC)                    :Get copy of screen image
        JFS     ICLA40
ICLA30  READ(IPBVID)                    :Next ALP character
        J     ICLA50                  :No further data
ICLA40  CHI     R0,A.ETX
        JE      ICLA60                  :J if end of ALP
	CHI	R0,A.ETB
	JEFS	ICLA50			:J if end of fragment
:
        CALL(ALPCHR)                    :Process character
        JBS     ICLA30                  :Next ALP character
:
: End of fragment. Tidy up screen image in case we have to output it before
: next fragment arrives.
:
ICLA50  CALL(FIELDS)                    :Update field cnts and attributes
        LHI     R1,C.VALP
        SBT     R1,CBITS,R11            :Note end of alp not received
        J       ICLA90
:
: End of data ALP. Update physical screen, send status response and return
:
ICLA60  LHI     R1,C.VQUA
        RBT     R1,CBITS,R11            :Clr qualifier bit (in case still set)
        CALL(FIELDS)                    :Update field cnts and attributes
        LHL     R1,SFSTAT,R10           :Final video state
        STH     R1,CVSTAT,R11           :Set in CCB
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Tell OUTSCR we have old and new screen
        CALL(OUTSCR)                    :Update real screen
	LHI	R1,OFSTAT
	STH	R1,SOUTFL,R10
	CALL(OUTSCR)
        LHI     R1,C.VALP
        RBT     R1,CBITS,R11            :Not in middle of ALP any longer
:
	LHI	R1,C.MFLG
	RBT	R1,CBITS,R11
	LHI	R1,C.SLGN		:Get ready for the test 
	TBT	R1,CBITS,R11		:If bit is set then go to ICLA90...
	JE	ICLA90			:...else continue
        CALL(SENDST)                    :Send status to HIF
ICLA90 	POP(R0)
        RETURN
        SUBTTL SUPERV routine ... Process ALP supervisory message
:
: Routine name  SUPERV
:
: Function      To process an ICL supervisory ALP received from the host
:               interface. Only type 25, AL Reset command, is accepted. Any
:               other command will be ignored. This command causes termainl to
:               be put in type mode, data compression is reset and screen
:               control mode is cleared. Respond with status report to HIF.
:               Reference ASD 9, 5.5. 
:
: Called by     ICLALP
:
: On entry      ALP prefix in R0.
:
: On exit       
:
: Uses          CLRSCC in this module   
:               SENDST in SEND
:
: --------------------------------------------------------------------
:
SUPERV  LR      R1,R0
	PUSH(R0)
        NHI     R1,ATMVAL               :Mask out supervisor code
        CHI     R1,$A 25
        JN      SUPE60                  :J if not type 25 (Reset)
:
	POP(R0)
	OHI	R0,80			:Flag no status response
	PUSH(R0)
        LHI     R1,VS.TYP
        STH     R1,CVSTAT,R11           :Set terminal to type mode
        LHI     R1,C.COMP
        RBT     R1,CBITS,R11            :Reset compression control
        CALL(CLRSCC)                    :Clear screen control codes
SUPE60  READ(IPBVID)                    :Flush out rest of ALP
        J       SUPE80
        CHI     R0,A.ETX
        JNBS    SUPE60
:
:	LHI	R1,C.SLGN		:Get bit ready to test
:	TBT	R1,CBITS,R11		:If set then jump to SUPE80
:	JE	SUPE80			:else continue	
:
	POP(R0)
	NHI	R0,80			: Test for startup reset
	JNFS	SUPE80			: If so - dont respond with status
:
        CALL(SENDST)                    :Send status report to HIF
SUPE80  POP(R0)
        RETURN
        SUBTTL ALPCHR routine ... Process ALP data character
:
: Routine name  ALPCHR
:
: Function      To process a character from an ALP updating the screen image.
:               If we are awaiting a qualifier then continuation address is
:               in CQUALF. If a normal graphic character then it is placed
:               in screen image. If a control code mthe a branch is made to 
:               the appropriate routine.
:
: Called by     ICLALP in this module
:
: On entry      Link register R1
:               Character to be processed in R0
:
: On exit       Screen will have been updated
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(ALPCHR)
        LHI     R1,C.VQUA
        RBT     R1,CBITS,R11
        JEFS    ALPC10                  :J if not waiting for qualifier
        L       R1,CVQUAL,R11           :Continuation address
        JALR    R1,R1                   :Continue processing control code
:
ALPC10  CHI     R0,A.SP
        JL      ALPC20                  :J if control character
:
: A normal graphic character is placed in the screen image after going thru
: ICL to ASCII translation table.
:
        CHKSEQ(AS.DAT,ALPC90)           :Check device control sequence
        LR      R1,R0
        LB      R0,ICLASC,R1            :Translate it
        STB     R0,SCNBUF,R10,R7        :Store in screen image
        AIS     R7,1                    :Move down screen
        CHI     R7,SCRSIZ               :Deal with screen wrap
        JN      ALPC90
        LIS     R7,0
        J       ALPC90                  :Return
:
: A control code is actioned on an individual basis
:
ALPC20  LR      R1,R0
        SLHLS   R1,2                    :Convert code into an index
        J       ALPC40,R1               :Process code by type
:
: Jump table for ALP codes
:
ALPC40  J       ALPC90                  :00 - Ignore
        J       ALPC90                  :01 - Ignore
        J       ALPC90                  :02 - Ignore
        J       ALPC90                  :03 - Ignore
        J       ALPC90                  :04 - Ignore
        J       ALPC90                  :05 - Ignore
        J       ALPC90                  :06 - Ignore
        J       ALP100                  :07 - Bell
        J       ALPC90                  :08 - Ignore
        J       ALP200                  :09 - HP
        J       ALP300                  :0A - Newline
        J       ALP250                  :0B - VP
        J       ALPC90                  :0C - Ignore
        J       ALPC90                  :0D - Ignore
        J       ALP120                  :0E - MSP
        J       ALP320                  :0F - MNL
        J       ALPC90                  :10 - Ignore
        J       ALP400                  :11 - Start Protected Steady
        J       ALP410                  :12 - Start Protected Flash
        J       ALP420                  :13 - Start Unprotected Flash
        J       ALP430                  :14 - Start Unprotected Steady
        J       ALPC90                  :15 - Ignore
        J       ALPC90                  :16 - Ignore
        J       ALPC90                  :17 - Ignore
        J       ALPC90                  :18 - Ignore
        J       ALPC90                  :19 - Ignore
        J       ALP490                  :1A - Treat as Space
        J       ALP500                  :1B - Escape
        J       ALP440                  :1C - Start Unprotected Validated
        J       ALPC90                  :1D - Ignore
        J       ALPC90                  :1E - Ignore
        J       ALPC90                  :1F - Ignore
:
:
ALPC90  RETURN
:
:       07 - Set alarm
:
: Sound the bell. This is a continuous alarm on ICL terminals but we only send
: standard bell code to terminal. Set S.BEL in SBITS to cause OUTSCR to do
: this. Reference ASD 9 3.6.4.
:
ALP100  CHKSEQ(AS.BEL,ALP110)           :Check device control sequence
        LHI     R1,S.BELL
        SBT     R1,SBITS,R10            :Indicate bell required
ALP110  RETURN
:
:       0E - Multiple Spaces
:
: The qualifier specifies a number of spaces to be output plus decimal 32.
: The range of valid spaces is 1 to 95. If the count is not in this range
: then the code will be ignored. The effect of this code is the same as
: receiving 'n' spaces. Reference ASD 9, 3.5.6.
:
ALP120  QUALFV                          :Get qualifier in R0
        CHKSEQ(AS.DAT,ALP160)           :Check device control sequence
        PUSH(R0)
        SHI     R0,20                   :Subtract decimal 32
        JLE     ALP150                  :J if illegal qualifier
        CHI     R0,$A 95
        JG      ALP150                  :J if qualifier illegal
        LHI     R1,A.SP
ALP130  STB     R1,SCNBUF,R10,R7        :Space output
        AIS     R7,1                    :Move down screen
        CHI     R7,SCRSIZ
        JLFS    ALP140                  :Deal with screen wrap
        LIS     R7,0
ALP140  SIS     R0,1
        JNBS    ALP130                  :J if more spaces required
ALP150  POP(R0)
ALP160  RETURN
:
:       09 - Horizontal position
:
: This code is followed by a qualifier byte containing the column number plus
: decimal 32. The cursor is moved to the column specified. If the qualiifier is
: invalid then the code is ignored. Reference ASD 9, 3.5.4.
:
ALP200  QUALFV                          :Get qualifier in R0
        PUSH(R0)
        SHI     R0,20                   :Subtract decimal 32
        JL      ALP220                  :J if illegal qualifier
        CHI     R0,SCRWTH
        JGE     ALP220                  :J if illegal qualifier
        LHI     R1,SCRWTH
        PUSH(R6)
        LR      R6,R7
        DHR     R6,R1                   :Calculate line number
        MHR     R7,R1
        AR      R7,R0                   :Move to new column
        POP(R6)
ALP220  POP(R0)
        RETURN
:
:       0B - Vertical position
:
: This code is followed by a qualifier byte containing the line number plus
: decimal 32. The cursor is moved to the line specified. If the qualiifier is
: invalid then the code is ignored. Reference ASD 9, 3.5.4.
:
ALP250  QUALFV                          :Get qualifier in R0
        PUSH(R0)
        SHI     R0,20                   :Subtract decimal 32
        JL      ALP270                  :J if illegal qualifier
        CHI     R0,SCRLTH
        JGE     ALP270                  :J if illegal qualifier
        LHI     R1,SCRWTH
        MHR     R0,R1
        PUSH(R8)
        DHR     R7,R1                   :Calculate column number
        AR      R7,R0                   :Move to new line
        POP(R8)
ALP270  POP(R0)
        RETURN
:
:       0A - Newline
:
: Clear any remaining character positions on the current line and move cursor 
: to position 0 of the following line. If on bottom line then wrap round will 
: occur. Reference ASD 9,3.5.3.
:
ALP300  CHKSEQ(AS.DAT,ALP390)           :Check device control sequence
        PUSH(R0)
        LHI     R0,1
        J       ALP330                  :Action one newline
:
:       0F - Multiple Newline
:
: A qualifier follows which is the number of newlines required plus decimal 
: 32. The effect of the MNL is that of receiving 'n' new line characters. 
: If the qualifier is out of range the code is not actioned. Reference 
: ASD 9, 3.5.5.
:
ALP320  QUALFV                          :Get qualifier in R0
        CHKSEQ(AS.DAT,ALP390)           :Check device control sequence
        PUSH(R0)
        SHI     R0,20                   :Subtract decimal 32
        JLE     ALP380                  :J if illegal qualifier
ALP330  PUSH(R2,R4)                     :Save registers
        LR      R1,R7                   :Calculate characters to end of line
ALP340  LHI     R4,SCRWTH
        DHR     R1,R4                   :Current column in R1
        SHI     R1,SCRWTH               :Negative count to line end
        LHI     R4,A.SP
ALP350  STB     R4,SCNBUF,R10,R7        :Spacefill
        AIS     R7,1                    :Move across screen
        CHI     R7,SCRSIZ               :Deal with screen wrap
        JNFS    ALP360
        LIS     R7,0
ALP360  AIS     R1,1
        JNBS    ALP350                  :J if not end of line
        SIS     R0,1
        JN      ALP340                  :J if more newlines
        POP(R4,R2)                      :Restore regsiters
ALP380  POP(R0)
ALP390  RETURN
:
:       11, 12, 13, 14, 1C - Field seperators
:
: These characters specify the start of field. They occupy a character 
: position. We convert them to there internal codings and store in them 
: in the screen buffer. We take a count of fields at the end of the ALP 
: to be used in keyboard handling. Reference ASD 9, 3.7 .
:
ALP400  LHI     R1,ATMPRF!ATMFST        :Protected field start
        J       ALP470
:
ALP410  LHI     R1,ATMPRF!ATMFLH!ATMFST :Protected flashing field start
        J       ALP470
:
ALP420  LHI     R1,ATMFLH!ATMFST        :Unprotected flashing field start
        J       ALP470
:
ALP430  LHI     R1,ATMFST               :Unprotected steady field start
        J       ALP470
:
ALP440  QUALFV                          :Get qualifier in R0
        LR      R1,R0                   :Unprotected validated start field
        NHI     R1,ATMVAL               :Extract validation code
        OHI     R1,ATMFST               :Set field start bit
:
ALP470  CHKSEQ(AS.DAT,ALP480)           :Check device control sequence
        STB     R1,SCNBUF,R10,R7        :Store in screen buffer
        AIS     R7,1                    :Move down screen
        CHI     R7,SCRSIZ               :Deal with screen wrap
        JNFS    ALP480
        LIS     R7,0
ALP480  RETURN
:
:	1A - SPACE
:
ALP490	LHI	R0,20
	J	ALPC10
:
:       1B - Escape
:
: This is the first character of a control character sequence. Extract next
: character and jump accordingly.
:
ALP500  QUALFV                          :Get qualifier in R0
        LR      R1,R0
        CHI     R1,A.E
        JG      ALP520                  :J if illegal qualifier
        SHI     R1,A.1                  :Lowest qualifier
        JL      ALP520                  :J if illegal qualifier
        SLHLS   R1,2                    :Turn qualifier into an index
        J       ALP510,R1               :J on qualifier
: Jump table for escape codes
ALP510  J       ALP600                  :1 - Set output state
        J       ALP610                  :2 - Set local A state
        J       ALP620                  :3 - Set local B state
        J       ALP630                  :4 - Set send state
        J       ALP650                  :5 - Clear screen
        J       ALP670                  :6 - Set Som
        J       ALP700                  :7 - Double line rack up
        J       ALP720                  :8 - Erase message
        J       ALP760                  :9 - Single line rack up
        J       ALP800                  :Colon - Set compression control
        J       ALP810                  :Semicolon - Reset compression control
        J       ALP520                  :LT - Illegal qualifier
        J       ALP520                  :EQ - Illegal qualifier
        J       ALP520                  :GT - Illegal qualifier
        J       ALP520                  :? - Illegal qualifier
        J       ALP820                  :AT - Clear screen
        J       ALP900                  :A - Reset screen controls
        J       ALP520                  :B - Illegal qualifier
        J       ALP950                  :C - Set screen controls
        J       ALP520                  :D - Illegal qualifier
        J       ALP520                  :E - Illegal qualifier
:
: Jump here if escape qualifier is illegal
:
ALP520  RETURN
:
:       Esc 1 - Set output state
:
: Set terminal in state to receive data. We ignore this code as we put
: terminal in this state automatically. However, we note it's presence 
: as it effects the final terminal status. (A real terminal system would
: reject output if not preceeded by this code. As this is merely causes 
: the host to resend message with set output included we decided to always
: aceept data. PHH Sept '85)
: Reference ASD 9, 6.4.2.
:
ALP600  CHKSEQ(AS.SOP,ALP520)           :Check device control sequence
        LHI     R1,VS.RX
        STH     R1,SFSTAT,R10           :Note set output in this ALP
        RETURN
:
:       Esc 2 - Set local mode A
:
: Local mode A is provided for putting the Access control into local
: output mode. We note it's presence for possible action at end of ALP.
: Reference ASD 9, 6.4.2.
:
ALP610  CHKSEQ(AS.SST,ALP520)           :Check device control sequence
        LHI     R1,VS.LCA
        STH     R1,SFSTAT,R10           :Note local A mode requested
        RETURN
:
:       Esc 3 - Set local mode B
:
: Local mode B is provided for putting the the Access control into local
: input mode. We note it's presence for possible action at end of ALP. 
: Reference ASD 9, 6.4.2.
:
ALP620  CHKSEQ(AS.SST,ALP520)           :Check device control sequence
        LHI     R1,VS.LCB
        STH     R1,SFSTAT,R10           :Note local B mode requested
        RETURN
:
:       Esc 4 - Set send mode
:
: Set send mode will put the termainl into send state at the end of the ALP.
: We note it's presence for possible action at end of ALP. Reference ASD 9,
: 6.4.2.
:
ALP630  CHKSEQ(AS.SST,ALP520)           :Check device control sequence
        LHI     R1,VS.SND
        STH     R1,SFSTAT,R10           :Note local B mode requested
        RETURN
:
:       Esc 5 - Clear screen type A
:
: Clear all character positions and fields from screen. Set Som and cursor
: to top left hand corner of screen (Position 0). Reference ASD 9, 3.5.1.
:
ALP650  CHKSEQ(AS.CLR,ALP520)           :Check device control sequence
        CALL(CLRSCR)                    :Clear screen image
        CALL(CLRSCC)                    :Reset screen controls
        LHI     R1,S.CLRS
        SBT     R1,SBITS,R10            :Flag clear screen occurred
        RETURN
:
:       Esc 6 - Set Som
:
: Move Som position to current cursor position. Reference ASD 9, 3.6.1.
:
ALP670  STH     R7,SSOM,R10             :Som to current cursor position
        RETURN
:
:       Esc 7 - Double line rack up
:
: Move the displayed screen contents, including field seperators but not
: including Som or cursor position, vertically up two lines. The initial 
: top two lines are discarded and the bottom two lines are cleared.
: Reference ASD 9, 3.6.2.
:
ALP700  CHKSEQ(AS.RK2,ALP520)           :Check device control sequence
        LIS     R1,2
        AHM      R1,SRACKS,R10           :Increment note of rack ups
        LHI     R1,SCRWTH*2             :Two lines
        J       ALP770                  :common code in single rack up
:
:       Esc 8 - Set cursor to SOM and erase message
:
: Set cursor to som position and clear all unprotected characters from this
: position to the end of screen. Reference ASD 9, 3.5.2.
:
ALP720  CHKSEQ(AS.CLR,ALP520)           :Check device control sequence
        PUSH(R4,R6)
        CALL(FIELDS)                    :Set up field counters and attribs
        LHI     R4,A.SP
        LHI     R1,C.NSPC               :Has alternate space fill been set
        TBT     R1,CBITS,R11
        JEFS    ALP725                  :J if it has not
        LHI     R4,A.UNDR               :Change to underline
ALP725  LHL     R7,SSOM,R10             :Cursor to som position
        LHL     R6,SSATTR,R10           :Attribute at this position
ALP730  NHI     R6,ATMPRO
        JNFS    ALP740                  :J if in protected field
        STB     R4,SCNBUF,R10,R7        :Space fill
ALP740  NHI     R6,ATMPRF               :We only want protected field now
        AIS     R7,1                    :Move down screen
        CHI     R7,SCRSIZ
        JEFS    ALP750                  :J if at end of screen
        LB      R1,SCNBUF,R10,R7
        NHI     R1,ATMFST
        JE    ALP730                  :J if not start of field
        LB      R6,SCNBUF,R10,R7        :Load new attribute
        J     ALP730
:
: End of screen
:
ALP750  LHL     R7,SSOM,R10             :Cursor back at som
        POP(R6,R4)
        RETURN
:
:       Esc 9 - Single line rack up
:
: Move the displayed screen contents, including field seperators but not
: including Som or cursor position, vertically up one line. The initial 
: top line is discarded and the bottom line is cleared.
: Reference ASD 9, 3.6.2.
:
ALP760  CHKSEQ(AS.RK1,ALP520)           :Check device control sequence
        LIS     R1,1
        AHM     R1,SRACKS,R10           :Increment note of rack ups
        LHI     R1,SCRWTH               :One line
ALP770  PUSH(R0,R2)
        LIS     R2,0                    :Top of screen
ALP780  LB      R0,SCNBUF,R10,R1        :Move data up screen
        STB     R0,SCNBUF,R10,R2
        AIS     R2,1
        AIS     R1,1
        CHI     R1,SCRSIZ
        JNBS    ALP780                  :J if rack up not complete
        LHI     R0,A.SP
ALP790  STB     R0,SCNBUF,R10,R2        :Space fill bottom of screen
        AIS     R2,1
        CHI     R2,SCRSIZ
        JNBS    ALP790                  :J if bottom line not space filled
        POP(R2,R0)
        RETURN
:
:       Esc Colon - Set compression control
:
: This command indicates that the ALS may input data ALPs containing compressed
: data. Set flag to tell SEND module. Reference ASD 9, 6.5
:
ALP800  CHKSEQ(AS.COM,ALP520)           :Check device control sequence
        LHI     R1,C.COMP
        SBT     R1,CBITS,R11            :Set compression control
        RETURN
:
:       Esc Semicolon - Reset compression control
:
: This command indicates that the ALS may no longer input data ALPs containing
: compressed data. Set flag to tell SEND module. Reference ASD 9, 6.5
:
ALP810  CHKSEQ(AS.COM,ALP520)           :Check device control sequence
        LHI     R1,C.COMP
        RBT     R1,CBITS,R11            :Reset compression control
        RETURN
:
:       Esc @ - Clear screen type B
:
: Clear all the character positions on the screen. Place Som and cursor at 
: top left hand corner of screen. Note that field fromatting is not cleared.
: Reference ASD 9, 3.5.1.
:
ALP820  CHKSEQ(AS.CLR,ALP520)           :Check device control sequence
        PUSH(R0)
        LHI     R0,A.SP                 :For space filling
        LIS     R7,0
ALP830  LB      R1,SCNBUF,R10,R7
        NHI     R1,ATMFST
        JNFS    ALP840                  :J if field start marker
        STB     R0,SCNBUF,R10,R7        :Space fill
ALP840  AIS     R7,1
        CHI     R7,SCRSIZ
        JNBS    ALP830                  :Loop til end of screen
        LIS     R7,0                    :Set cursor
        STH     R7,SSOM,R10             : and Som to top left hand corner
        POP(R0)
        RETURN
:
:       Esc A - Reset screen controls
:
: This command resets the screen controls set by Esc C (see below) by call
: to routine CLRSCC. Reference ASD 9, Appendix B.1.
:
ALP900  CALL(CLRSCC)                    :Reset screen controls
        LHI     R1,C.NVAL
        SBT     R1,CBITS,R11            :Flag no screen validation
        RETURN
:
:       Esc C - Set screen controls
:
: This command allows the mainframe to set the Vt into a particular mode 
: other than the standard modes. The mode set applies specifically to the
: messages subsequently output, until the mode is cleared. It contains the
: following options which cause flags to be set in CBITS. 
:       Inhibit operator movement of Som
:       Use bottom line of screen for validation error messages
:       Allow invlid fields to "forced" sent to mainframe
:       Change character used to spacefill certain editing keys
: Reference ASD 9, Appendix B.1.
:
ALP950  QUALFV                          :Get qualifier in R0
        LHI     R1,C.NVAL
        RBT     R1,CBITS,R11            :Flag screen validation allowed
:
: Bit 1 - Inhibit operator movement of Som
:
        THI     R0,1                    :Test bit 1
        JEFS    ALP960
        LHI     R1,C.NSOM
        SBT     R1,CBITS,R11            :Set flag
:
: Bit 2 - Use bottom line of screen for error displays
:
ALP960  THI     R0,2                    :Test bit 2
        JEFS    ALP970
        LHI     R1,C.ER24
        SBT     R1,CBITS,R11            :Set flag
:
: Bit 3 - Allow operator to force invalid fields into send messages
:
ALP970  THI     R0,4                    :Test bit 3
        JEFS    ALP980
        LHI     R1,C.FSND
        SBT     R1,CBITS,R11            :Set flag
:
: Bit 4 - Change space fill character
:
ALP980  THI     R0,8                    :Test bit 4
        JEFS    ALP990
        LHI     R1,C.NSPC
        SBT     R1,CBITS,R11            :Set flag
:
ALP990  RETURN
        SUBTTL CLRSCC routine ... Reset screen controls
:
: Routine name  CLRSCC
:
: Function      To reset screen controls set by Esc C from mainframe. See
:               that command for details of individual controls. This routine
:               is used by Esc A, reset screen controls command from host,
:               or by clear screen either locally or by Esc 5 from mainframe.
:               Reference ASD 9, Appendix B.1.
:
: Called by     ALP900, ALP650 in this module
:               KEY440 in ICLKEY
:
: On entry      Link register R1
:
: On exit       All screen controls will be cleared
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(CLRSCC)
        LHI     R1,C.NSOM
        RBT     R1,CBITS,R11            :Clear inhibit som movement
        LHI     R1,C.ER24
        RBT     R1,CBITS,R11            :Clear error display on line 24
        LHI     R1,C.FSND
        RBT     R1,CBITS,R11            :Clear force invalid fields
        LHI     R1,C.NSPC
        RBT     R1,CBITS,R11            :Clear alternate space fill char
        RETURN
        SUBTTL FIELDS routine ... Set up field counters and attributes
:
: Routine name  FIELDS
:
: Function      Sets up fields counter and Som and cursor attributes in screen
:               buffer.
:
: Called by     ICLALP and ALP720 in this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          FNDATR in SCRMIS
:
: ---------------------------------------------------------------------
:
        RSTART(FIELDS)
        STH     R7,SCURSR,R10           :Save cursor address
        LIS     R6,0
        LIS     R7,0
FIEL20  LB      R1,SCNBUF,R10,R7        :Next screen position
        NHI     R1,ATMFST
        JEFS    FIEL30                  :J if not start of field
        AIS     R6,1                    :Increment count of fields
FIEL30  AIS     R7,1                    :Move down screen
        CHI     R7,SCRSIZ
        JNBS    FIEL20                  :J if not end of screen
        STH     R6,SFLDS,R10            :Save count of fields
        LHL     R7,SSOM,R10
        CALL(FNDATR)                    :Find attribute at som
        STH     R6,SSATTR,R10
        LHL     R7,SCURSR,R10
        CALL(FNDATR)                    :Find attribute at cursor
        STH     R6,SCATTR,R10
        RETURN
        SUBTTL INIVID routine ... Initialise video parameters
:
: Routine name  INIVID
:
: Function      Sets up initial video parameter values in CCB, i.e.
:               video status and current screen attribute.
:
: Called by     LOGST in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(INIVID)
        LHI     R1,VS.TYP
        STH     R1,CVSTAT,R11           :Video status type mode
        LIS     R1,0
        STH     R1,CVATTR,R11           :Current video attribute is normal
        RETURN
:
        EM

        SUBTTL HOST ... Host interface handler

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 OCT 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        GL      RESTAR                  :Restart code in TERM
        SEG     A.CODE                  :Segment to contain this module
        MO      .,HOST                  :Delimit module
:
: This module contains the host interface (ICL/HIF) handler routines:
:
:       LOGSH - Initial logon handler to host interface
:       HOSTH - Normal host interface handler
:       LOGONM - Manual logon handler
:       LOGONS - Stored logon handler
:       LOGNIN - Issues logon from prepared string
:       QRYLOG - Query logon options with user
:       WELCOM - Outputs program title
:       LOGMES - Display error message or instruction
:       GETUSE/GETPAS - Get username or password from user
:       TRAIL - Removing trailing spaces from username/password
:       GETALP - Wait for response from user
:       GETNET - Wait for response from network
:
: There are no macros unique to this module.
        SUBTTL LOGSH routine ... Logon process for host DCB
:
: Routine name  LOGSH
:
: Function      This routine contains the routines to be obeyed when a
:               psuedo needle is received. This will have been requested by
:               the terminal interface when a user logs on. If
:               necessary a menu of logon options is output to the user
:               and the circuit(s) to the host interface are initiated.
:               On successful completion of these processes the DCB is
:               then handed over to HOSTH.
:
: Called by     Automatically when host DCB created
:
: On entry      DCB and CCB will have been initialised.
:
: On exit       
:
: Uses          QRYLOG, WELCOM, LOGONM in this module
:               LOGONS, CANRES, LOGMES, LOGIIX in this module
:               RESTAR in TERM
:
: ---------------------------------------------------------------------
:
        DEFGEQ(LOGSH,.)
        LIS     R7,6                    :Logging messages start on line 7
:
: Prepare to log into host interface
:
        L       R8,CUPROF,R11           :User profile entry
        L       R9,CTPROF,R11           :Terminal profile
	LHI	R1,D.PRT
	RBT	R1,DBITS,R12
        L       R1,CPDCB,R11
        JE      LOGH10                  :J if first host login for this user
:
: This is the second entry for this user. We must have already logged on 
: printer and now need to logon video to HIF.
:
	CALL(WELCOME)			:Send opening message to terminal
	LHI	R4,A.ETX
	WRITEB(IPBTRM)
	CLOSE(IPBTRM)
        LHL     R4,CLSTRS,R11           :Login entry address 
        LB      R3,LSTRS,R4             :Count of elements in login
        J       LOGH40
:
: First entry for this user. We must determine which option user requires
: and if printer and VDU required then logon printer first.
:
LOGH10  LHL     R2,UPFMNU,R8            :Menu for this user
        SLLS    R2,2                    :Convert into index into MENUS
        LHL     R6,MENUS+2,R2           :Index to MSTRS of 1st logon string
        LB      R3,MENUS,R2             :Count of entries in menu
:
: If more than one entry then we output menu so user can select
:
        CHI     R3,1
        JE      LOGH20                  :J if only one choice
        CALL(QRYLOG)                    :Output menu and get user selection
:
LOGH20  CALL(WELCOM)                    :Send opening message to terminal
        LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :Send end of ALP
        CLOSE(IPBTRM)
        SIS     R3,1
        AR      R3,R3                   :R3 now indexes selected string
        AH      R3,MENUS+2,R2           : in MSTRS
        LHL     R4,MSTRS,R3
        STH     R4,CLSTRS,R11           :Save logon string in CCB
        LB      R3,LSTRS,R4             :Count of elements in string
:
: Count of elements = 0 -  manual logon without printer
:                   = 1 - manual logon with printer
:                   = 2 - stored logon without printer
:                   = 4 - stored logon with printer
:
        LR      R3,R3
        JE      LOGH40                  :J if manual without printer
        CHI     R3,2
        JE      LOGH40                  :J if stored without printer
        LHL     R0,TRMPRC,R9
        JN      LOGH30                  :J if terminal supports printing
        LA      R4,LGNOPR               :Printing not supported
        CALL(LOGMES)
        J       LOGH40
LOGH30  LHI	R1,D.PRT
        SBT     R1,DBITS,R12            :Printer host link DCB
LOGH40  CHI     R3,2
        JGE     LOGH60                  :J if stored logon
:
: Deal with manual logon
:
        CALL(LOGONM)                    :Do manual logon
        J       LOGH90                  :Logon failed
        J       LOGIIX                  :Logon successful, IIX start up
:
: Deal with stored logon mode
:       
:
LOGH60  LHL     R2,LSTRS+2,R4           :First element string number
	LHI	R1,D.PRT
        TBT     R1,DBITS,R12
        JE      LOGH80                  :J if we not logging ptr on
        AIS     R2,4                    :Point to printer string
LOGH80  LHL     R6,STRLST,R2            :Point to element address cell
        SLHLS   R6,2
        L       R6,ELEADR,R6            :Address of element
        CALL(LOGONS)                    :Send stored logon
        J       LOGH90                  :J if error and restart required
        J       LOGIIX                  :Deal with IIX startup
:
: Logon failed, invite user to restart
:
LOGH90  CALL(CANRES)
        LIS     R4,0                    :Flag that no message is to be o/p
        J       RESTAR                  :Enter restart point in TERM
        SUBTTL LOGIIX routine ... Initial IIX and turkey negiotation
:
: Routine name  LOGIIX
:
: Function      This routine performs the initial IIX negiotion with HIF.
:               Check that host logged onto is intellegent. Wait for 
:               select dialague and if ICLC03 included then send response.
:               Send caller user data. Anything abnormal occurs we zap circuit
:               tell user and allow him to restart.
:
: Called by     LOGSH
:
: On entry      Circuit has been built to HIF. Successful logon received.
:
: On exit       Negiotation with HIF successfully completed
:
: Uses          GETNET, GETIIX, BEGIIX, LOGCUD, LOGMES in this module
:               CANRES, HOSTH in this module
:               SNDTIX, SNDZAP, INIDCB in CMTI
:
: ---------------------------------------------------------------------
:
        DEFGEQ(LOGIIX,.)
:
: Check we are logged on to intellegent host
:
        CALL(GETNET)                    :Get qualifier to successful logon
        LR      R5,R0                   :Save IIX character
        LIS     R4,3                    :Flush out rest of message (3 chars)
LOGI10  CALL(GETNET)
        SIS     R4,1
        JN      LOGI10                  :J if not flushed       
        NHI     R5,7F                   :Low order 7 bits of IIX char
        JE      LOGI90                  :J if not IIX capable
:
: Wait for select dialect message. If ICLC03 supported send response
:
        CALL(GETIIX)                    :Get IIX message
        CLI     R5,ISDIAL               
        JN      LOGI90                  :J if not select dialect
        LIS     R5,0                    :Flag ICL not supported
LOGI20  CALL(GETNET)
        CHI     R0,0C0
        JE      LOGI30                  :J if end of select dialect
        LR      R4,R0                   :First character of dialect
        SLHLS   R4,8
        CALL(GETNET)                    :Second character of dialect
        OR      R4,R0                   :Create dialect HW
        CLI     R4,ISDC03
        JN      LOGI20                  :J if not ICL C03
        LIS     R5,1                    :Flag ICL supported
        J       LOGI20
:
: End of select dialect, does it support ICL C03
:
LOGI30  LR      R5,R5
        JE      LOGI90                  :J if does not support ICL C03
        LHI     R5,ISDRES               :Select dialect response
        CALL(BEGIIX)                    :Begin IXX output
        LHI     R4,80                   :Selected dialect is ICL C03
        WRITEB(NET)
        LHI     R4,ISDC03               :We only use last byte of this
        WRITEB(NET)
        CLOSE(NET)
        CALL(SNDTIX)                    :End of IIX message
:
: Wait for Turkey level 1 message and respond with call user data
:
        CALL(GETIIX)                    :Get next message
        CLI     R5,ITURK1
        JN      LOGI90                  :J if not turkey level 1 message
LOGI40  CALL(GETNET)                    :Skip qualifiers
        CHI     R0,0C0
        JN      LOGI40
:
        CALL(LOGCUD)                    :Send call user data
        J       LOGI95                  :J if failed
:
: Successfully communicating to host. If we have just set up printer link
: we must now set up video link. Go to normal running code at HOSTH.
:
	LHI	R2,C.MFLG
	SBT	R2,CBITS,R11
        LA      R4,LGONOK
        CALL(LOGMSA)                    :Report logon OK
	LHI	R1,D.PRT
        TBT     R1,DBITS,R12
        JE      HOSTH                  :J if not printer login
        LHI     R1,DTHPRT
	STH	R1,DTYPE,R12
        L       R0,CHDCB,R11            :Switch from video to printer host
        ST      R0,CPDCB,R11
        LIS     R3,0                    :No port number
        LA      R4,LOGSH                :Start at LOGSH
        CALL(INIDCB)                    :Create a DCB for video host link
        ST      R5,CHDCB,R11            :Link to CCB
	LHI	R1,DTHVID		:Mark as video DCB
	STH	R1,DTYPE,R5
        J       HOSTH                   :Normal running
:
: Host not ICL HIF so tell user, zap circuit and invite user to restart
:
LOGI90  LA      R4,LGNHIF               :Host not HIF
        CALL(LOGMES)                    :Tell user
LOGI95  CALL(SNDZAP)                    :Close host circuit
        CALL(CANRES)                    :Invite user to restart
        LIS     R4,0                    :Flag no message to o/p
        J       RESTAR
        SUBTTL HOSTH routine ... Normal host interface handler
:
: Routine name  HOSTH
:
: Function      This routine handles normal activity on an established link 
:               to the HIF. Data from HIF is passed across to the terminal DCB.
:               Data from terminal DCB is put into one IIX data message and
:               sent to HIF. Note,that currently we do not use count bytes in
:               the header. Invitation to clear from HIF causes us to enter
:               restart code in TERM which clears down circuits to HIF.
:
: Called by     LOGIIX
:
: On entry      
:
: On exit       
:
: Uses          GETNET, BEGIIX in this module
:               SNDTIX, SNDGRB in CMTI
:
: ---------------------------------------------------------------------
:
        DEFGEQ(HOSTH,.)
HOST10  READ(NET)
        J       HOST70                  :No data available
        CHI     R0,0BF
        JN      HOST50                  :J if not SIXX
        CALL(GETNET)                    :Skip over IIX code
        CALL(GETNET)
        CALL(GETNET)                    :Qualifier
        LR      R0,R0
        JN      HOST40                  :J if not data message
        CALL(GETNET)                    :Skip over data count
        CALL(GETNET)
        OPEN(IPBTRM)                    :Open IPB buffer to terminal DCB
HOST20  CALL(GETNET)                    :Read in data
        CHI     R0,0C0
        JE      HOST30                  :J if end of IIX message
        LR      R4,R0                   :Write data to IPB
        WRITEB(IPBTRM)
	CHI	R4,A.ETX
	JN	HOST20			:J if not end of alp
	LHL	R4,DTYPE,R12
	CHI	R4,DTHPRT
	JN	HOST20			:J if not printer DCB
	LHI	R1,D.TOKN
:	SBT	R1,DBITS,R12		:Flag suspended awaiting processing
        J       HOST20                  :J if further data
HOST30  CLOSE(IPBTRM)                   :Send data to terminal DCB
	J	HOST10			:J if not suspended
:
: Received invitation to clear, tell user and close host circuits
:
HOST40  LA      R4,IIXE1
        J       RESTAR                  :Close down host circuit, user restart
:
: Only other acceptable input from HIF is black ball.
: We must discard any accumulated ALP and return grey ball
:
HOST50  CHI     R0,0A4
        JN      HOST10                  :Ignore if not black ball
        OPEN(IPBTRM)                    :Send end of ALP to terminal DCB
        LHI     R4,A.ETX
        WRITEB(IPBTRM)
        CLOSE(IPBTRM)
        CALL(SNDGRB)                    :Return grey ball to HIF
        J       HOST10                  :Check for further data
:
: Check if we have any data from user. Send it on to HIF as IIX data message
:
HOST70  READ(IPBTRM)
        J       HOST90                  :No data from terminal
HOST72  LHI     R5,IDATA                :Start of IIX data block
        CALL(BEGIIX)
        LIS     R4,0                    :Normal category
        LIS     R2,3                    :Category + two dummy bytes
        LR      R1,R0
        NHI     R1,80
        JE      HOST75                  :J if normal category requested
        NHI     R0,7F                   :Remove top bit
        LIS     R4,1                    :Category 1
HOST75  WRITEB(NET)
        SIS     R2,1
        JN      HOST75
HOST80  LR      R4,R0                   :First byte of message
        WRITEB(NET)
        READ(IPBTRM)                    :Read terminal data
        J       HOST85                  :End of data
        CHI     R0,A.ETX
        JN      HOST80                  :J if just data
HOST85  LHI     R4,A.ETX
        WRITEB(NET)
        CLOSE(NET)                      :End data block
        CALL(SNDTIX)                    :End of IIX
        J       HOST10                  :Loop to check for response
:
: No data from host or terminal so suspend
:
HOST90  SUS(SUSIP)
	LHI	R1,D.TOKN
	TBT	R1,DBITS,R12
	JN	HOST70			:If input susp then only check ipb
        J       HOST10                  :Check again
:        SUBTTL LOGONM routine ... Logon manually
:
: Routine name  LOGONM
:
: Function      This routine displays a manual logon screen, gets response and
:               sends logon to network. It repeats request if user makes error.
:
: Called by     LOGST
:
: On entry      Link register R1
:
: On exit       Return + 4, successful logon message qualifier in R0.
:               Return + 0, failed
:
: Uses          LOGMES, GETUSE, LOGNIN in this module
:               GETSCB, PUTSCB in CBDEF
:
: ---------------------------------------------------------------------
:
        SSTART(LOGONM)
        PUSH(R0,R4,R5,R6)
        OPEN(IPBTRM)                    :Start message
        LA      R4,MSTART
        WRITES(IPBTRM)
        LA      R4,MANLG1               :Logon skeleton
        WRITES(IPBTRM)
        LA      R4,MANLG2
        WRITES(IPBTRM)
        LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :Send end of ALP
        CLOSE(IPBTRM)                   :Send message 
        LA      R4,MANTRM               :For video
        LHI     R1,D.PRT
        TBT     R1,DBITS,R12
        JE      LOGM10                  :J if not printer logon
        LA      R4,MANPRT               :For printer
LOGM10  CALL(LOGMES)
        CALL(GETSCB)                    :Get buffer to hold username 
        ST      R5,DSCNBF,R12
        LR      R10,R5
LOGM20  LIS     R1,0
        STB     R1,SCNBUF,R10           :Store login string from SCNBUF+1+0
        CALL(GETUSE)                    :Get username / password
LOGM30  CALL(LOGNIN)                    :Network login
        J       LOGM90                  :Successful
        CHI     R6,1
        JE      LOGM20                  :J if user type error
        CHI     R6,3
        JE      LOGM80                  :J if pseudo needle rejected
        LIS     R1,0
        STB     R1,SCNBUF,R10           :Store login string from SCNBUF+1+0
        CALL(GETPAS)                    :Must be password error 
        J       LOGM30                  :Try again
:
: If pseudo needle rejected tell user 
:
LOGM80  L       R5,DSCNBF,R12
        CALL(PUTSCB)                    :Return buffer
	LIS	R5,0
	ST	R5,DSCNBF,R12
        POP(R6,R5,R4,R0)
        RETURN                          :Return + 0, failed
LOGM90  L       R5,DSCNBF,R12
        CALL(PUTSCB)                    :Return buffer
	LIS	R5,0
	ST	R5,DSCNBF,R12
        POP(R6,R5,R4,R0)
        RETURN(SKIP)                    :Return + 4, successful
        SUBTTL LOGONS routine ... Stored logon
:
: Routine name  LOGONS
:
: Function      This routine logs on to the network using a stored logon 
:               string.
:
: Called by     LOGST
:
: On entry      Link register R1
:               Stored element address in R6
:
: On exit       Return +4, successful logon message qualifier in R0.
:               Return + 0, failed
:
: Uses          LOGMES in this module
:
: ---------------------------------------------------------------------
:
        SSTART(LOGONS)
        PUSH(R0,R4,R5,R6)
        CALL(GETSCB)                    :Get a work buffer
        ST      R5,DSCNBF,R12
        LR      R10,R5
        LIS     R5,0                    :Create stored logon starting message
LOGS05  LB      R0,STLOGS+1,R5
        STB     R0,SCNBUF+1,R10,R5
        AIS     R5,1
        CLB     R5,STLOGS
        JN      LOGS05
        LHL     R4,LSTRS+4,R4           :Login string label address
        LIS     R1,0
LOGS06  LB      R0,STRLAB+1,R4,R1       :Now place logon label on screen
        STB     R0,SCNBUF+1,R10,R5
        AIS     R5,1
        AIS     R1,1
        CLB     R1,STRLAB,R4,
        JN      LOGS06
        STB     R5,SCNBUF,R10           :Save size of string
        LA      R4,SCNBUF,R10           :Output message to user
        CALL(LOGMES)
	LA R4,STLOGP
	LHI	R1,D.PRT
	TBT	R1,DBITS,R12
	JN	LOGS07	
	LA	R4,STLOGV
LOGS07	CALL(LOGMESS)			:Tell user we are logging in
LOGS08  LIS     R4,0                    :Offset within username/host/password
LOGS10  CLB     R4,0,R6
        JN      LOGS20                  :J if not end of element
        LHI     R10,A.CR                :Supply terminator
        JFS     LOGS40  
LOGS20  LB      R5,1,R6,R4              :Logon character
        AIS     R4,1                    :Move through string
        NHI     R5,7F                   :Mask off top bit
LOGS40  STB     R5,SCNBUF,R10,R4        :Store in work buffer
        CHI     R5,A.CR
        JE      LOGS60                  :J if carriage return
        CHI     R5,A.SEMI
        JN      LOGS10                  :J if not semicolon
        CLB     R4,0,R6
        JE      LOGS10                  :J if end of string
        LB      R5,1,R6,R4
        JN      LOGS20                  :J if not wild card
        STB     R4,SCNBUF,R10
        LHI     R0,A.CR
LOGS45  AIS     R4,1                    :Skip to carriage return or end
        CLB     R4,0,R6
        JE      LOGS50                  :J if not end of element
        CLB     R0,1,R6,R4
        JN      LOGS45
        CLB     R4,0,R6
        JN      LOGS20                  :J if not end of element
LOGS50  OPEN(IPBTRM)                    :Start message
        LA      R4,MSTART
        WRITES(IPBTRM)
        LA      R4,MANLG2               :Password skeleton
        WRITES(IPBTRM)
        LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :Send end of ALP
        CLOSE(IPBTRM)                   :Send message 
        CALL(GETPAS)                    :Get password
        J       LOGS70                  :Issue login
:
LOGS60  STB     R4,SCNBUF,R10           :Save string size
LOGS70  LR      R4,R6                   :Save contents of R6
        CALL(LOGNIN)                    :Network login
        J       LOGS90                  :Successful
        CHI     R6,2
        JN      LOGS80                  :J if not password error
        LR      R6,R4                   :Restore R6, 
        LR      R5,R5
        JE      LOGS08                  :J if password supplied by user
:
LOGS80  L       R5,DSCNBF,R12           :Irrecoverable error??
        CALL(PUTSCB)                    :Return buffer
	LIS	R5,0
	ST	R5,DSCNBF,R12		:Clear screen buffer pointer
        POP(R6,R5,R4,R0)
        RETURN                          :Return + 0, failed
LOGS90  L       R5,DSCNBF,R12
        CALL(PUTSCB)                    :Return buffer
	LIS	R5,0
	ST	R5,DSCNBF,R12		:Clear screen buffer pointer
        POP(R6,R5,R4,R0)
        RETURN(SKIP)                    :Return + 4, successful
        SUBTTL LOGNIN routine ... Stored logon
:
: Routine name  LOGNIN
:
: Function      This routine logs on to the network using a specified logon 
:               string.
:
: Called by     LOGST
:
: On entry      Link register R1
:
: On exit       Return +4, successful logon message qualifier in R0.
:               Return + 0, failed
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(LOGNIN)
        PUSH(R0,R2,R4,R5)
        LHL     R5,DCBNO,R12            :DCB number is local key
        CALL(SNDPNR)                    :Send pseudo needle request
        SUS(SUSPN)                      :Wait needle
        LIS     R6,3
        LHL     R1,DPORT,R12
        JN      LOGN05                  :J if ports available
        LIS     R6,3
        LA      R4,LGPNRJ               :Pseudo needle rejected
        CALL(LOGMES)
        J       LOGN85                  :Return
:
LOGN05  LIS     R6,0                    :Null response  
        LIS     R2,0                    :Count of string
LOGN10  CLB     R2,SCNBUF,R10
        JLE     LOGN20                  :J if string not empty
        LHI     R5,A.SEMI               :Otherwise send semicolon
        J       LOGN30
LOGN20  LB      R5,SCNBUF+1,R10,R2      :Next char from string
        AIS     R2,1                    :Increase count
        CHI     R5,A.CR
        JN      LOGN30  
        LHI     R5,A.SEMI               :Convert carriage return to semicolon
LOGN30  CALL(SNDNLC)                    :Send logon char
        SUS(SUSVD)                      :Voluntary suspend
        NHI     R5,7F                   :Mask out top bit
        CHI     R5,A.SEMI
        JE      LOGN40                  :J if terminator
LOGN35  READ(NET)                       :Any response
        J       LOGN10                  :J if none
        J       LOGN50                  :Response available
LOGN40  CALL(GETNET)                    :Wait for response
LOGN50  CHI     R0,7F
        JG      LOGN70                  :J if not data
        OPEN(IPBTRM)
        LR      R4,R0
        WRITEB(IPBTRM)                  :Send to user
        LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :End of ALP
        CLOSE(IPBTRM)
LOGN60  CHI     R5,A.SEMI
        JE      LOGN40                  :J if waiting for response
        J       LOGN35
:
LOGN70  CHI     R0,0B6
        JE      LOGN90                  :J if successful logon
        CHI     R0,0B4
        JN      LOGN60                  :J if not normal logon status
        READ(NET)                       :Get qualifier
        J       LOGN60                  :J if no qualifier
        NHI     R0,1F                   :Mask out status message code
        JE      LOGN10                  :J if continue - send password
        LR      R1,R0                   :Can't use R0 as index
        SIS     R1,1
        SLHLS   R1,2
        L       R4,LGERMS,R1            :Pick up error message
        CALL(LOGMES)                    :Output to user
        LIS     R6,2                    :Password error?
        CHI     R0,3
        JE      LOGN80                  :Password in error
        CHI     R0,5
        JE      LOGN80                  :Password not supplied
        LIS     R6,1                    :Username error
:
LOGN80  CALL(SNDZAP)                    :Zap this circuit
LOGN85  POP(R5,R4,R2,R0)
        RETURN(SKIP)                    :Return + 4
:
LOGN90	LHI	R2,C.MFLG
	TBT	R2,CBITS,R11
	JE	LOGN91
	SUS(SUSVD)
	J	LOGN90
:
LOGN91 	LHI	R2,C.SLGN		:Get the bit ready to be set..
	SBT	R2,CBITS,R11		:set the sucker !!
:
 	POP(R5,R4,R2,R0)
        RETURN                          :Return + 0, logon successful
        SUBTTL LOGCUD routine ... Send call user data to HIF
:
: Routine name  LOGCUD
:
: Function      This routine logs on to the network using a specified logon 
:               string.
:
: Called by     LOGST
:
: On entry      Link register R1
:
: On exit       Return +4, successful logon message qualifier in R0.
:               Return + 0, failed
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(LOGCUD)
        PUSH(R0,R4,R5)
        CHI     R3,2
        JGE     LOGC20                  :J if stored logon
LOGC10  CALL(GETCUD)                    :Get manual call user data
        J       LOGC40
LOGC20  LHL     R4,CLSTRS,R11         :Pointer to logon string
        LHL     R2,LSTRS+2,R4             :pointer to first element
        LHI     R1,D.PRT
	TBT	R1,DBITS,R12
        JE      LOGC30                  :J if not printer
        AIS     R2,4                    :Printer elements
LOGC30  AIS     R2,2                    :CUD element
        LHL     R6,STRLST,R2            :Point to element address cell
        SLHLS   R6,2
        L       R6,ELEADR,R6            :Address of element
        LB      R1,1,R6                 :First character is line
        STH     R1,DLINE,R12
        LB      R1,2,R6                 :Second character is group
        STH     R1,DGROUP,R12
        LB      R1,3,R6                 :Third character is subsidiary
        STH     R1,DSUBSD,R12
LOGC40  LHI     R5,ICUD
        CALL(BEGIIX)                    :Begin call user data IIX message
	LIS	R4,5
	WRITEB(NET)
        LIS     R4,0
        WRITEB(NET)                     :Two unused bytes
        WRITEB(NET)
        LHL     R4,DLINE,R12            :Send line number
        WRITEB(NET)
        LHL     R4,DGROUP,R12           :Send group number
        WRITEB(NET)
        LHL     R4,DSUBSD,R12           :Send subsidiary number
        WRITEB(NET)
        CLOSE(NET)
        CALL(SNDTIX)                    :End IXX message
        CALL(GETIIX)                    :Get response
        CLI     R5,ICALLA
        JN      LOGC80                  :J if not call accept
        CALL(GETNET)                    :Skip to line, group ,etc data
        CALL(GETNET)
        CALL(GETNET)                    :Line number
        STH     R0,DLINE,R12
        CALL(GETNET)
        STH     R0,DGROUP,R12           :Group number
        CALL(GETNET)
        STH     R0,DSUBSD,R12           :subsidiary
LOGC70  CALL(GETNET)                    :Skip to end
        CHI     R0,0C0
        JN      LOGC70
        POP(R5,R4,R0)
        RETURN(SKIP)                    :Return successful
:
: Call user data rejected, tell user and restart this routine if manual
:
LOGC80  CLI     R5,IDATA
        JN      LOGC90                  :J if not invitation to clear
        LIS     R4,6                    :Skip to reason
LOGC85  CALL(GETNET)
        SIS     R4,1
        JN      LOGC85
        CHI     R0,3
        JG      LOGC90                  :Unrecognised reason for rejection
        LR      R4,R0
        JE      LOGC90                  :Unrecognised reason for rejection
        SIS     R4,1
        SLHLS   R4,2                    :Convert reason into index
        L       R4,IIXERR,R4            :Pick up error message address
        CALL(LOGMES)
        CHI     R3,2
        JL      LOGC10                  :If manual login try again
        J       LOGC95
LOGC90  LA      R4,LGPROE               :Protocol error
        CALL(LOGMES)
LOGC95  POP(R5,R4,R0)
        RETURN                          :Return failed
        SUBTTL QRYLOG routine ... Logon menu screen
:
: Routine name  QRYLOG
:
: Function      This routine displays a logon options menu to the user
:               and accepts the users selection.
:
: Called by     LOGST
:
: On entry      Link register R1
:
: On exit       Selected logon entry number in R3. All registers
:               will have been preserved
:
: Uses          OPEN, WRITE, CLOSE, READ in INOUT
:
: ---------------------------------------------------------------------
:
        SSTART(QRYLOG)
        PUSH(R0,R4,R5,R6)
        CALL(WELCOM)                    :Open message and add heading
        PUSH(R3)                        :Save count of entries
QRYL30  LHL     R5,MSTRS,R6             :Get to logon labels
        LHL     R5,LSTRS+4,R5
        LA      R4,MPROMP               :Prompt character
        WRITES(IPBTRM)
:
        LA      R4,STRLAB,R5,           :Now place logon label on screen
        WRITES(IPBTRM)
:
        AIS     R6,2                    :Next entry
        SIS     R3,1                    :Decrement count of entries
        JN      QRYL30                  :Jump if not end of entries
:
        LA      R4,MENUTR               :Please select entry message
        WRITES(IPBTRM)
        LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :Send end of ALP
        CLOSE(IPBTRM)                   :Send message to terminal handler
        POP(R3)                         :Recover count of entries
:
: Wait for response from terminal DCB
:
        CALL(GETALP)                    :Read input queue
:
: We have an ICL formatted data message. Calculate entry requested by user.
: There should be one DC4 for each entry the user has tabbed over plus one
: for the line he's on. Note that if the user has been silly and put cursor
: in a protected field, we can get a message with no DC4's in which case we
: give the user the first entry. 
:
        LIS     R5,0                    :To hold selected entry number
QRYL60  READ(IPBTRM)                    :Read message text
        J       QRYL70                  :No data available
        CHI     R0,A.ETX
        JE      QRYL70                  :J if end of message
        CHI     R0,I.DC4                :Is this an unprotected field start
        JN      QRYL60
        AIS     R5,1                    :Increment entry count
        J       QRYL60
:
QRYL70  CR      R5,R3                   :Is entry number in range
        JG      QRYL80                  :J if not in range
        LR      R3,R5                   :Check entry number is valid
        JN      QRYL90                  :J if invalid
QRYL80  LIS     R3,1                    :Default to first entry
:
QRYL90  POP(R6,R5,R4,R0)                :Restore registers
        RETURN
        SUBTTL WELCOM routine ... Output screen heading
:
: Routine name  WELCOM
:
: Function      This routine creates a message which puts the program name
:               and version number on the top line of the screen.
:
: Called by     RESTAR in this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          OPEN, WRITEB, WRITES, CLOSE in INOUT
:
: ---------------------------------------------------------------------
:
        SSTART(WELCOM)
        PUSH(R4,R5,R6)
        OPEN(IPBTRM)                    :Open IPBTRM Channel
        LA      R4,MHEADR               :Clear screen
        WRITES(IPBTRM)
:
        IF      USRHDR                  :******** User defined header *****
:
        LA      R4,MENUHD               :User defined header
        WRITES(IPBTRM)
:
        ELSE                            :******** Program defined header **
:
        LA      R4,MPROGN               :Program name
        WRITES(IPBTRM)
        LHI     R1,$A 10
        LHI     R5,VERSION              :Program version
        DHR     R5,R1
        LR      R4,R6                   :Tens!
        JE      WELC30                  :Ignore leading zero
        AHI     R4,A.0
        WRITEB(IPBTRM)                  :Put in message
WELC30  LR      R4,R5                   :Units
        AHI     R4,A.0
        WRITEB(IPBTRM)                  :Put in message
        LHI     R4,A.PER                :Period
        WRITEB(IPBTRM)
        LHI     R1,$A 10
        LHI     R5,REVLEV               :Reversion level
        DHR     R5,R1
        LR      R4,R6                   :Tens
        AHI     R4,A.0
        WRITEB(IPBTRM)                  :Put in message
        LR      R4,R5                   :Units
        AHI     R4,A.0
        WRITEB(IPBTRM)                  :Put in message
:
        EI                              :******** End of header option **
:
        LHI     R4,I.NL                 :ICL newline
        WRITEB(IPBTRM)
        POP(R6,R5,R4)
        RETURN
        SUBTTL LOGMES routine ... Output message to screen
:
: Routine name  LOGMES
:
: Function      This routine appends a message to the screen. If the
:               message is on the last line then the screen is racked up
:               two lines.
:
: Called by     RESTAR in this module
:
: On entry      Link register R1
:               Address of message in SC format in R4
:               Current logging line number in R7
:
: On exit       
:
: Uses          OPEN, WRITEB, WRITES, CLOSE in INOUT
:
: ---------------------------------------------------------------------
:
        SSTART(LOGMES)
        PUSH(R4)
        OPEN(IPBTRM)                    :Start IPB message
        LA      R4,MSTART               :Message prefix
LGMS30  WRITES(IPBTRM)
        LHI     R4,I.VT                 :Send ICL VP code
        WRITEB(IPBTRM)
        LR      R4,R7                   :Next logging line number
        AHI     R4,20                   :Add decimal 32
        WRITEB(IPBTRM)
        POP(R4)                         :Address of message to be output
        WRITES(IPBTRM)
        PUSH(R4)
        AIS     R7,1                    :Next line
        CHI     R7,SCRLTH-3             :Don't use bottom two lines
        JN      LGMS20                  :Jump if not at bottom of screen
        LIS     R7,6                    :Back to top of logging area
:
LGMS20	POP(R4)
	PUSH(R4)
 	J 	LGMS25
:       LHI     R4,I.NL                 :ICL newline
:       WRITEB(IPBTRM)
:       LHI     R4,I.NL                 :2nd newline to clear line below
:       WRITEB(IPBTRM)
LGMS25  LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :Send end of ALP
        CLOSE(IPBTRM)                   :Send to terminal DCB
        POP(R4)
        RETURN
:
	SSTART(LOGMSA)
	PUSH(R4)
	OPEN(IPBTRM)
	LA	R4,MSTRTA
	J	LGMS30
        SUBTTL GETUSE/GETPAS routine ... Get manual logon username/password
:
: Routine name  GETUSE/GETPAS
:
: Function      This gets a username and password from the user. It analyses
:               the response and leaves it in the same format as a stored
:               logon but placed in the work buffer (used as a work area).
:
: Called by     RESTAR in this module
:
: On entry      Link register R1
:
: On exit       Buffer containing logon addressed by R10
:
: Uses          WELCOM in this module
:
: ---------------------------------------------------------------------
:
        SSTART(GETPAS)
        PUSH(R0,R4,R7)
        LA      R4,MEPASS               :Please provide password
        CALL(LOGMES)
        OPEN(IPBTRM)                    :Position cursor
        LA      R4,MPPASS
        WRITES(IPBTRM)
        J       GETU10                  :Get data from user
:
        SSTART(GETUSE)
        PUSH(R0,R4,R7)
        LA      R4,MEUSER               :Please enter logon
        CALL(LOGMES)
        OPEN(IPBTRM)                    :Position cursor
        LA      R4,MPUSER
        WRITES(IPBTRM)
GETU10  LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :Send end of ALP
        CLOSE(IPBTRM)
:
: Get response. Format will be 'DC4 username DC4 password DC4'
:
        CALL(GETALP)
        L       R10,DSCNBF,R12          :Address of screen buffer
        LB      R7,SCNBUF,R10           :Starting point for storing
        READ(IPBTRM)                    :Skip over first DC4
        J       GETU70                  :No data available
GETU20  READ(IPBTRM)                    :Extract username
        J       GETU50                  :No data available
        CHI     R0,A.ETX
        JE      GETU50
        CHI     R0,I.DC4                :Start unprotected
        JE      GETU30
        STB     R0,SCNBUF+1,R10,R7              :Save username element
        AIS     R7,1
        J       GETU20
GETU30  CALL(TRAIL)                     :Remove trailing spaces
        LHI     R0,A.SEMI
        STB     R0,SCNBUF+1,R10,R7              :Insert semicolon
        AIS     R7,1
:
GETU40  READ(IPBTRM)                    :Extract password
        J       GETU70                  :No data available
        CHI     R0,A.ETX
        JE      GETU50
        CHI     R0,I.DC4                :Start unprotected
        JE      GETU50
        STB     R0,SCNBUF+1,R10,R7      :Save password element
        AIS     R7,1
        J       GETU40
:
GETU50  CALL(TRAIL)
:
: End of message. Add carriage return on end and return
:
GETU70  LHI     R0,A.CR
        STB     R0,SCNBUF+1,R10,R7
        AIS     R7,1
        STB     R7,SCNBUF,R10           :Save count
        POP(R7,R4,R0)
        RETURN
        SUBTTL GETCUD routine ... Get manual logon call user data
:
: Routine name  GETCUD
:
: Function      This gets call user data (line, group subsidiary addresses)
:               from the user and places them in the DCB.
:
: Called by     RESTAR in this module
:
: On entry      Link register R1
:
: On exit       Call user data will be in DCB
:
: Uses          LOGMES in this module
:
: ---------------------------------------------------------------------
:
        SSTART(GETCUD)
        PUSH(R0,R4,R7)
        OPEN(IPBTRM)                    :Start message
        LA      R4,MSTART
        WRITES(IPBTRM)
        LA      R4,MANLG3               :CUD skeleton
        WRITES(IPBTRM)
        LA      R4,MANLG4
        WRITES(IPBTRM)
        LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :Send end of ALP
        CLOSE(IPBTRM)                   :Send message 
GETC10  LA      R4,MECUD1               :Please provide call user data
        CALL(LOGMES)
        LA      R4,MECUD2               :Leave fields blank
        CALL(LOGMES)
        OPEN(IPBTRM)                    :Position cursor
        LA      R4,MPCUD
        WRITES(IPBTRM)
        LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :Send end of ALP
        CLOSE(IPBTRM)
        LIS     R1,0
        STH     R1,DLINE,R12            :Default CUD to wild cards
        STH     R1,DGROUP,R12
        STH     R1,DSUBSD,R12
:
: Get response. Format will be 'DC4 line DC4 group DC4 subsid DC4'
:
        LIS     R7,1                    :Field number being checked
        CALL(GETALP)
        READ(IPBTRM)                    :Skip over first DC4
        J       GETC90                  :No data available
:
: Line number
:
GETC20  READ(IPBTRM)                    :Extract line number
        J       GETC90                  :No data available
        CHI     R0,A.ETX
        JE      GETC90
        CHI     R0,I.DC4                :Start unprotected
        JE      GETC30
        LHL     R4,DLINE,R12
        CALL(CHKDEC)                    :Check and convert char
        J       GETC70                  :J if invalid
        STH     R4,DLINE,R12
        J       GETC20
:
: Group number
:
GETC30  LIS     R7,2
GETC40  READ(IPBTRM)                    :Extract group number
        J       GETC90                  :No data available
        CHI     R0,A.ETX
        JE      GETC90
        CHI     R0,I.DC4                :Start unprotected
        JE      GETC50
        LHL     R4,DGROUP,R12
        CALL(CHKHEX)                    :Check and convert char
        J       GETC70                  :J if invalid
        STH     R4,DGROUP,R12
        J       GETC40
:
: subsidiary number
:
GETC50  LIS     R7,3
GETC60  READ(IPBTRM)                    :Extract subsid number
        J       GETC90                  :No data available
        CHI     R0,A.ETX
        JE      GETC90
        CHI     R0,I.DC4                :Start unprotected
        JE      GETC90
        LHL     R4,DSUBSD,R12
        CALL(CHKHEX)                    :Check and convert char
        J       GETC70                  :J if invalid
        STH     R4,DSUBSD,R12
        J       GETC60
:
: Invalid parameter
:
GETC70  SIS     R7,1                    :Convert parameter in error to index
        SLHLS   R7,2
        L       R4,LGCERR,R7            :Pick up error message
        POP(R7)                         :This is a fiddle to ensure that
        CALL(LOGMES)                    : previous messages are overwritten
        PUSH(R7)
        J       GETC10                  :Get that idiot to try again
:
: Success
:
GETC90  POP(R7,R4,R0)
        RETURN
        SUBTTL TRAIL routine ... Remove trailing spaces
:
: Routine name  TRAIL
:
: Function      This gets a username and password from the user. It analyses
:               the response and leaves it in the same format as a stored
:               logon but placed in the work buffer (used as a work area).
:
: Called by     RESTAR in this module
:
: On entry      Link register R1
:
: On exit       Buffer containing logon addressed by R10
:
: Uses          WELCOM, ENDMES in this module
:
: ---------------------------------------------------------------------
:
        SSTART(TRAIL)
        LR      R7,R7
TRAL30  JE      TRAL50                  :J if no data left
        LB      R1,SCNBUF,R10,R7        :Last character
        CHI     R1,I.NL
        JE      TRAL40                  :Skip over newline
        CHI     R1,A.SP
        JN      TRAL50                  :J if non-space
TRAL40  SIS     R7,1                    :Back over space
        J       TRAL30
TRAL50  RETURN
        SUBTTL CHKDEC routine ... Convert decimal parameter
:
: Routine name  CHKDEC
:
: Function      This routine takes a ASCII character, checks it is numeric
:               and adds it to a given number. 
:
: Called by     RESTAR in this module
:
: On entry      Link register R1
:               Ascii character in R0
:               Binary number in R4
:
: On exit       Return + 0 if character invalid
:               Return +4 if character valid and added to R4
:
: Uses
:
: ---------------------------------------------------------------------
:
        SSTART(CHKDEC)
        PUSH(R0)
        CHI     R0,A.SP
        JE      CHKD80                  :Ignore space
        SHI     R0,A.0
        JL      CHKD90                  :J if not numeric
        CHI     R0,9
        JG      CHKD90                  :J if not numeric
        LHI     R1,$A 10
        MHR     R4,R1                   :Current number x 10
        AR      R4,R0
CHKD80  POP(R0)                         :Return valid
        RETURN(SKIP)
CHKD90  POP(R0)
        RETURN                          :Return invalid
        SUBTTL CHKHEX routine ... Convert hexidecimal parameter
:
: Routine name  CHKHEX
:
: Function      This routine takes a ASCII character, checks it is numeric
:               and adds it to a given number. 
:
: Called by     RESTAR in this module
:
: On entry      Link register R1
:               Ascii character in R0
:               Binary number in R4
:
: On exit       Return + 0 if character invalid
:               Return +4 if character valid and added to R4
:
: Uses
:
: ---------------------------------------------------------------------
:
        SSTART(CHKHEX)
        PUSH(R0)
        CHI     R0,A.SP
        JE      CHKH80                  :Ignore space
        SHI     R0,A.0
        JL      CHKD90                  :J if not numeric
        CHI     R0,9
        JLE     CHKH70                  :J if 0 - 9
        SHI     R0,11                   :Is it A - F
        JL      CHKH90                  :J if not valid
        CHI     R0,5
        JLE     CHKH60                  :J if A - F
        SHI     R0,20                   :Is it a - f
        JL      CHKH90
        CHI     R0,5
        JG      CHKH90
CHKH60  AIS     R0,0A                   :A - F is 10 - 15 decimal       
CHKH70  LHI     R1,10                 
        MHR     R4,R1                   :Current number x 16
        AR      R4,R0
CHKH80  POP(R0)                         :Return valid
        RETURN(SKIP)
CHKH90  POP(R0)
        RETURN                          :Return invalid
        SUBTTL GETALP routine ... Get response from user
:
: Routine name  GETALP
:
: Function      This routine gets a response data ALP skipping over 
:               supervisory ALPs.
:
: Called by     
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(GETALP)
        PUSH(R0)
GETA10  READ(IPBTRM)                    :Read IPB buffer
        J       GETA60                  :No data available
        CHI     R0,IALPDA
        JE      GETA80                  :J if data ALP
:
GETA30  READ(IPBTRM)                    :Skip over supervisory ALP
        J       GETA10                  :No data available
        CHI     R0,A.ETX
        JE      GETA10                  :J if end of ALP
        J       GETA30
:
GETA60  SUS(SUSIP)                      :Suspend awaiting response
        J       GETA10                  :Try again
:
GETA80  POP(R0)
        RETURN
        SUBTTL GETNET routine ... Get response from network
:
: Routine name  GETNET
:
: Function      This routine gets a response from the network 
:
: Called by     LOGONM in this module
:
: On entry      Link register R1
:
: On exit       R0 contains response character
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(GETNET)
GETN10  READ(NET)                       :Read IPB buffer
        J       GETN60                  :No data available
        J       GETN80                  :J if data available
:
:
GETN60  SUS(SUSIP)                      :Suspend awaiting response
        J       GETN10                  :Try again
:
GETN80  RETURN
        SUBTTL GETIIX routine ... Get response from network
:
: Routine name  GETIIX
:
: Function      This routine gets an IIX response from the network 
:
: Called by     LOGIIX in this module
:
: On entry      Link register R1
:
: On exit       R5 contains response IIX code of message
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(GETIIX)
        PUSH(R0)
GETI10  CALL(GETNET)
        CHI     R0,0BF
        JN      GETI10                  :J if not start IIX
        CALL(GETNET)                    :First character of IIX code
        LR      R5,R0
        SLHLS   R5,8                    :Top part of half word
        CALL(GETNET)
        OR      R5,R0                   :Bottom half
        POP(R0)
        RETURN
        SUBTTL BEGIIX routine ... Start IIX message output
:
: Routine name  BEGIIX
:
: Function      This routine starts an output IIX message, SIIX and
:               IIX code.
:
: Called by     
:
: On entry      Link register R1
:               IIX code in R5
:
: On exit       Network output channel will be open
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(BEGIIX)
        PUSH(R4)
        CALL(SNDSIX)                    :Send SIIX control message
        OPEN(NET)
        LR      R4,R5                   :IIX code
        SRHLS   R4,8                    :First byte
        WRITEB(NET)
        LR      R4,R5                   :Second byte
        WRITEB(NET)
        POP(R4)
        RETURN
        SUBTTL CANRES routine ... Ask user to press SEND to restart
:
: Routine name  CANRES
:
: Function      This routine asks the user to press SEND to restart 
:               after an error. He may at that time choose to zap his
:               connection to CMT.
:
: Called by     LOGONM in this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(CANRES)
        PUSH(R0,R4)
        LA      R4,LGREST
        CALL(LOGMES)                    :Invite user to press SEND
	OPEN(IPBTRM)			:Force into type mode
	LA	R4,MSBELL
	WRITES(IPBTRM)			:And sound alarm
	CLOSE(IPBTRM)
        CALL(GETALP)
CANR20  READ(IPBTRM)                    :Flush out rest of message
        J       CANR90                  :Out of data
        J       CANR20                  :J for next character
CANR90  POP(R4,R0)
        RETURN  
:
        SEG     A.DATA
MHEADR  SC      /"40"1B5"11/
MSBELL	SC	/"40"07"03/
MPROGN  SC      / ICL Character Mode Translator /
MENUTR  SC      /"0A"0A  Select service required using TAB and then press SEND"0B"20"09"20/
MPROMP  SC      /"0A   "14"11  /
MSTART  SC      /"40"1B1"0B"20"09"20/
MSTRTA	SC	/"40"0B"20"09"20/
MANLG1  SC      /"0B"22"09"23Username : "14"09"46"11/
MANLG2  SC      /"0B"23"09"23Password : "1C"41"09"3A"11/
MANLG3  SC      /"0B"22"09"20"0A"0A"0B"23"09"23Line (Decimal) "14  "11/
MANLG4  SC      /   Group (Hex) "14  "11   Subsiduary (Hex) "14  "11/
MPUSER  SC      /"40"0B"22"09"2F/
MPPASS  SC      /"40"0B"23"09"2F/
MPCUD   SC      /"40"0B"23"09"33/
MANPRT  SC      /Manual logon of video/
MANTRM  SC      /Manual logon of terminal/
STLOGS  SC      /Logging in to /
STLOGP	SC	/Logging in printer/
STLOGV	SC	/Logging in video/
MEUSER  SC      /Please enter logon details and press SEND key/
MEPASS  SC      /Please enter password and press SEND key/
MECUD1  SC      /Please enter call user data and press SEND key/
MECUD2  SC      /Fields may be left blank where HIF can allocate address/
LGNOPR  SC      /Printing requested but not supported on this terminal/
LGPNRJ  SC      /CMT out of ports, please try again later/
LGREST  SC      /Press SEND to restart CMT session/
LGNHIF  SC      /Accessed host is not ICL HIF/
LGPROE  SC      /Protocol error/
LGICUD  SC      /Invalid parameter/
LGONOK  SC      /Logon successful"1B5"0B"20/
LOGE1   SC      /Error in username/
LOGE3   SC      /Error in password/
LOGE8   SC      /Port timed out or too many errors/
LOGE9   SC      /Bad MUD/
LOGEA   SC      /Circuits busy/
LOGEB   SC      /Host not available through net/
LOGEC   SC      /Host out of ports/
LOGED   SC      /Host down/
LOGEE   SC      /Host shut/
LOGEF   SC      /Try again in 2 minutes/
LOGE10  SC      /Access not permitted/
LOGE11  SC      /No host specified/
LOGE12  SC      /Bad host number/
LOGE13  SC      /MUD error/
LOGEU   SC      /Unrecognised error/
LGERMS  WC      LOGE1
        WC      LOGE1
        WC      LOGE3
        WC      LOGE1
        WC      LOGE3
        WC      LOGEU
        WC      LOGEU
        WC      LOGE8
        WC      LOGE9
        WC      LOGEA
        WC      LOGEB
        WC      LOGEC
        WC      LOGED
        WC      LOGEE
        WC      LOGEF
        WC      LOGE10
        WC      LOGE11
        WC      LOGE12
        WC      LOGE13
ISDIAL  EQ      8080                    :Select dialect
ISDRES  EQ      8081                    :Select dialect response
ISDC03  EQ      8092                    :ICL C03 dialect code
ITURK1  EQ      0C093                   :Turkey level 1
ICUD    EQ      0C089                   :Call user data
ICALLA  EQ      0C092                   :Call accept
IDATA   EQ      0C094                   :Invitation to clear
IIXE1   SC      /ICL system not responding to this device/
IIXE2   SC      /Requested device not supported/
IIXE3   SC      /Requested device not available at present/
IIXERR  WC      IIXE1
        WC      IIXE2
        WC      IIXE3
LGCER1  SC      /Line parameter invalid/
LGCER2  SC      /Group parameter invalid/
LGCER3  SC      /subsidiary parameter invalid/
LGCERR  WC      LGCER1
        WC      LGCER2
        WC      LGCER3
:
        EM


        SUBTTL TERM ... Terminal handler

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 JUL 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,TERM                  :Delimit module
:
: This module contains the terminal interface (Consat) handler routines:
:
:       LOGST - Action needle received when user logs to CMT
:       TERMH - Normal terminal handler
:       DATMES - Process data from network
:       CTLMES - Process control message from network
:       REJECT - Discard error input
:       QRYTRM - Query terminal type from user
:
: There are no macros unique to this module.
        SUBTTL LOGST routine ... Logon process for terminal DCB
:
: Routine name  LOGST
:
: Function      This routine contains the routines to be obeyed when a
:               terminal logs into CMT. The terminal type is determined
:               either from the user profile table or from the user. 
:               The terminal is initialised and a screen buffer obtained. If
:               necessary a menu of logon options is output to the user
:               and the circuit(s) to the host interface are initiated.
:               On successful completion of these processes the DCB is
:               then handed over to TERMH.
:
: Called by     ACTIVN
:
: On entry      DCB and CCB will have been initialised.
:
: On exit       All registers will have been preserved
:
: Uses          OPEN, WRITES, CLOSE, READ in INOUT
:
: ---------------------------------------------------------------------
:
        DEFGEQ(LOGRST,.)                :Restart terminal entry
        J       LOGT50
        DEFGEQ(LOGST,.)                 :Start terminal entry
:
: Determine user profile. If not valid user then close him down.
:
        CALL(FNDUPF)                    :Get user profile table entry
        ST      R5,CUPROF,R11           :Store in CCB
        LR      R8,R5
        JN      LOGT10                  :J if valid user
        LA      R4,EBADUS               :Error message, invalid username
        J       ENDIT                   :Close user down
:
: Determine terminal type and profile table address
:
LOGT10  LHL     R9,UPFTTY,R8            :Terminal type
        JN      LOGT40                  :Jump if known
        CALL(QRYTRM)                    :Get terminal type in R9
LOGT40  SIS     R9,1                    :Convert into TPF address
        LHI     R1,TPTSIZ
        MHR     R9,R1
        AI      R9,TPFLST
        ST      R9,CTPROF,R11           :Save in CCB
:
: Initialise the terminal (Enter here for restart)
:
LOGT50  LA      R1,ACTCNT,,             :Control message table for terminal
        STH     R1,DCACT,R12
        OPEN(NET)                       :Open output
        LHL     R4,TRMSTR,R9            :Initialise terminal
        WRITES(NET)
        CLOSE(NET)                      :Close output
        LHL     R6,TRMCTL,R9
        LHL     R7,0,R6                 :Size of terminal parameters
LOGT60  AIS     R6,2                    :Point to first/next parameter
        LHL     R5,0,R6                 :Parameter no and value
        CALL(SNDSTP)                    :Send terminal parameter
        SIS     R7,2
        JG      LOGT60                  :Jump if more parameters
        CALL(GETSCB)                    :Get a screen buffer
        ST      R5,CSCNBF,R11           :Link it to CCB
        LA      R0,CSCNBF,R11
        ST      R0,CHNFWD,R5
        LR      R10,R5                  :R10 holds current screen buffer
        LHL     R5,TRMSIZ,R9            :Terminal screen size is last
        STH     R5,CVEND,R11            : position + 1 to be painted
        CHI     R5,$A 2000
        JGE     LOGT70                  :J if full size screen
        LHI     R5,C.S24
        SBT     R5,CBITS,R11            :Flag 24 line screen
LOGT70  LIS     R5,0                    :Initially first position to be
        STH     R5,CVSTRT,R11           : painted is zero
        CALL(INIVID)                    :Initialise video parameters
        CALL(INIPRT)                    :Initialise printer parameters
        CALL(CLRSCR)                    :Clear screen image (this also sets
                                        : up r7 to cursor and R6 to attrib)
:
: Start another DCB to initiate logon to host
:
        LIS     R3,0                    :No port number associated with it
        IF      TSHDCB
        GL      TSTMEN
        LA      R4,TSTMEN,,             :Test user code address
        ELSE
        LA      R4,LOGSH,,              :Live user code address
        EI
        CALL(INIDCB)                    :Create and start DCB
        ST      R5,CHDCB,R11            :Store address in CCB
        LHI     R1,DTHVID
        STH     R1,DTYPE,R5             :Mark as host video DCB
:
: Output ICL screen
:
        LHI     R1,OFCLRS
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)
        J       TERMH                   :Main terminal handler routine

        SUBTTL TERMH routine ... Normal terminal handling rountine
:
: Routine name  TERMH
:
: Function      Normal terminal handler. This routine loops round checking 
:               network and IPB buffers for data. If any exists then data 
:               is processed. If both are empty then DCB is suspended 
:               awaiting input.
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
        DEFGEQ(TERMH,.)
:
: The following registers are reserved for use by DATMES to process control
: keys :
:       R5 - Set non-zero if control key sequence being analysed
:       R3 - points to current position in control key table
:
        CALL(CHKECO)                    :Check echo status
:
        L       R3,TRMKBD,R9            :Start of control key table
        LIS     R5,0                    :Control key flag off
:
: Extract ICL key character or Tymnet control message from network buffer
:
TERM30  READ(NET)                       :Get character from network
        J       TERM50                  :J if no data available
        THI     R0,80                   :Test if control message
        JE      TERM40                  :J if it is not
        CALL(CTLMES)                    :Process control message
        J       TERM30                  :Next message
:
TERM40  CALL(DATMES)                    :Process data message
        J       TERM30                  :Next message
:
: Extract ICL ALP from IPB buffer for video
:
TERM50  READ(IPBVID)                    :Get character from IPB
        J       TERM60                  :J if no data available
        CALL(VIDALP)                    :Process IPB ALP
        CALL(CHKECO)                    :Set correct echo
        J       TERM30                  :Repeat loop
:
: Extract ICL ALP from IPB buffer for printer
:
TERM60  LHI     R1,C.PDAT
        TBT     R1,CBITS,R11
        JN      TERM80                  :J if waiting printer DSR response
        LA      R2,DIPBIB,R12
        L       R0,CHNFWD,R2
        CR      R0,R2
        JE      TERM80                  :J if no printer data waiting
:
: We have a printer ALP from HIF. We set a flag to mark data available
: and request printer status from terminal. 
: Processing continues when we get response from terminal (see CMTKEY).
:
        SBT     R1,CBITS,R11            :Flag waiting to process printer data
        CALL(PRTDSR)                    :Request printer status
:
TERM80  SUS(SUSIP)                      :Suspend awaiting input
        J       TERM30                  :Check buffers again

        SUBTTL DATMES routine ... Process data message from network
:
: Routine name  DATMES
:
: Function      Normal terminal handler. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     LOGST
:
: On entry      Link register R1
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
        SSTART(DATMES)
        PUSH(R0)
:
        LR      R5,R5                   :Are we collecting control key
        JN      DATM20                  :J if we are
        CHI     R0,A.SP
        JL      DATM20                  :J if control character anyway
        LHI     R1,C.HELP
        RBT     R1,CBITS,R11
        JN      DATM60                  :J if key to terminate HELP
        LR      R5,R0                   :Normal graphic character
        J       DATM70                  :Return key code
:
DATM20  LB      R5,0,R3                 :Next character from key table
        THI     R5,80                   :Is this end of a list
        JN      DATM30                  :Jump if it is
        CR      R0,R5
        JEFS    DATM40                  :Jump matches with rx'ed character
        AIS     R3,4                    :Move down table
        J       DATM20
:
: Control key seq not matched
:
DATM30  CALL(REJECT)                    :Reject the key sequence
        J       DATM80                  :Start again
:
: We have a match to entry in table
:
DATM40  LB      R0,1,R3                 :Test if we are end of sequence
        THI     R0,10
        JE      DATM50                  :J if we are
        L       R3,0,R3                 :Get address of next level
        NI      R3,0FFFFF
        LIS     R5,1                    :Flag that we are in control sequence
        J       DATM90                  :Get next character
:
DATM50  LB      R5,3,R3                 :Control key code 
        LHI     R1,C.HELP
        RBT     R1,CBITS,R11
        JN      DATM60                  :J if key to terminate HELP
        CHI     R5,REDSPY
        JL      DATM70                  :J if an ICL control key
        CALL(CMTKEY)                    :Action CMT key
        J       DATM80
:
DATM60  LHI     R1,OFFULL               :To reset screen to ICL
        STH     R1,SOUTFL,R10           :Request full redisplay of screen
        CALL(OUTSCR)
        J       DATM80
:
DATM70  CALL(ICLKEY)                    :Process Icl key
        CALL(CHKECO)                    :Change echo if needed
DATM80  LIS     R5,0                    :Not collecting control key
        L       R3,TRMKBD,R9            :Reset control key table pointer
:
DATM90  POP(R0)
        RETURN

        SUBTTL CMTKEY routine ... Process CMT control keys
:
: Routine name  CMTKEY
:
: Function      Get a coded key from terminal. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     TERMH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(CMTKEY)
        PUSH(R5)
        SHI     R5,REDSPY               :Convert into an index
        SLHLS   R5,2
        J       CMTK10,R5
:
CMTK10  J       CMTK20                  :Redisplay
        J       CMTK30                  :Zap
        J       CMTK40                  :Rack up/down
        J       CMTK50                  :Status on/off
        J       CMTK60                  :Help
        J       CMTK65                  :Null function key
        J       CMTK70                  :Printer operable
        J       CMTK80                  :Printer inoperable
        J       CMTK90                  :Printer hold switch
        J       CMTK95                  :Printer allocate switch
	J	CMTK35			:Restart
:
: Redisplay - Repaint full screen from current screen image
:
CMTK20  LHI     R1,OFFULL
        STH     R1,SOUTFL,R10           :Request full redisplay of screen
        CALL(OUTSCR)
        J       CMTK99
:
: Zap - Close down this terminal
:
CMTK30  LA      R4,EUSER                :Close down message
        J       ENDIT                   :End it all for this user ........
:
: Restart - Restart session (normally returns to menu)
:
CMTK35	LIS	R4,0			:No message to output
	J	RESTAR
:
: Rack up/down - For 24 line terminals rack up or down to get alternate
:                view of screen
:
CMTK40  LHI     R1,C.S24
        TBT     R1,CBITS,R11
        JE      CMTK45                  :J if not 24 line screen
        CHI     R7,SCRWTH
        JL      CMTK45                  :J if it would put cursor off screen
        CHI     R7,SCRSIZ-SCRWTH
        JGE     CMTK45                  :Ditto
        LHI     R1,OFXLIN
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Get OUTSCR to do it
        J       CMTK99
:
CMTK45  CALL(REJECT)                    :Tell user cant do it
        J       CMTK99
:
: Status on/off - Switch status indicator on/off
:
CMTK50  LHI     R1,OFXSTI
        STH     R1,SOUTFL,R10
        CALL(OUTSCR)                    :Get OUTSCR to do it
        J       CMTK99
:
: Help - Output help screen
:
CMTK60  CALL(HELPSC)                    :On return C.HELP is set
        J       CMTK99
:
: Null - No function key
:
CMTK65  CALL(REJECT)                    :Discard it and bell user
:
: Printer operable report
:
CMTK70  CALL(PRTOPS)                    :Flag printer as operable
        J       CMTK99
:
: Printer inoperable report
:
CMTK80  CALL(PRTXPS)                    :Flag printer as inoperable
        J       CMTK99                  :Return
:
: Printer hold switch
:
CMTK90  CALL(PRTHLD)                    :Switch printer hold
        J       CMTK99                  :Return
:
: Printer allocate switch
:
CMTK95  CALL(PRTALL)                    :Allocate/deallocate printer
        J       CMTK99                  :Return
:
CMTK99  POP(R5)
        RETURN
        SUBTTL HELPSC routine ... Action HELP key
:
: Routine name  HELPSC
:
: Function      To action the HELP key by painting a screen consisting
:               of text from the terminal table on keyboard layout plus :               details of port usuage. 
:
: Called by     TERMH in this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(HELPSC)
        PUSH(R4,R5)
        OPEN(NET)
        LHL     R4,TRMCLR,R9
        WRITES(NET)                     :Clear screen
        LA      R4,HTITLE
        WRITES(NET)
:
: Help text is a series of SC strings terminated by zero byte
:
        LA      R4,HTERMT
        WRITES(NET)                     :Move down screen
        LHL     R4,TRMHLP,R9            :Help screen test
        JE      HELP10                  :J if no terminal help text
HELP05  LB      R1,0,R4
        JE      HELP10                  :J if end of strings
        WRITES(NET)                     :Output line
        LB      R1,0,R4                 :On to next string
        AIS     R1,1
        AR      R4,R1
        J       HELP05
:
HELP10  LA      R4,HUSERN
        WRITES(NET)                     :Username title
        LIS     R5,0
HELP20  LB      R4,CUNAME,R11,R5
        CHI     R4,80
        JN      HELP30                  :J if not end of username char
        LHI     R4,A.SP                 :Replace by space
HELP30  WRITEB(NET)
        AIS     R5,1
        CHI     R5,UPFULN
        JL      HELP20                  :J if not end of username
        LA      R4,HPORTT
        WRITES(NET)                     :Terminal port title
        LHL     R5,DPORT,R12
        CALL(WRITED)                    :Output terminal port number
        LA      R4,HPORTH
        WRITES(NET)                     :Video host port title
        L       R5,CHDCB,R11
        JE      HELP40                  :J if no video host DCB
        LHL     R5,DPORT,R5
        JE      HELP40                  :J if no video host port
        CALL(WRITED)                    :Output port number
        J       HELP50
HELP40  LA      R4,HNOTA                :Not allocated
        WRITES(NET)
HELP50  LA      R4,HPORTP               :Printer host port title
        WRITES(NET)
        L       R5,CPDCB,R11
        JE      HELP60                  :J if no printer host DCB
        LHL     R5,DPORT,R5
        JE      HELP60                  :J if no printer host port
        CALL(WRITED)                    :Output port number
        J       HELP70
HELP60  LA      R4,HNOTA                :Not allocated
        WRITES(NET)
:
HELP70  LA      R4,HPRTST               :Printer status
        WRITES(NET)
        LHL     R4,TRMPRC,R9
        JN      HELP75                  :J if printer supported
        LA      R4,HPRTNS               :Printer not supported
        WRITES(NET)
        J       HELP90
HELP75  LHI     R1,PS.IOP
        LA      R4,HPRTOP
        TBT     R1,CPSTAT,R11
        JE      HELP77                  :J if printer operable
        LA      R4,HPRTXP
HELP77  WRITES(NET)
        LHI     R1,PS.ALL
        LA      R4,HPRTDA
        TBT     R1,CPSTAT,R11
        JE      HELP80                  :J if printer deallocated
        LA      R4,HPRTAL
HELP80  WRITES(NET)
        LHI     R1,PS.HLD
        LA      R4,HPRTHL
        TBT     R1,CPSTAT,R11
        JE      HELP90                  :J if printer not held
        WRITES(NET)
HELP90  LA      R4,HTERMT
        WRITES(NET)
        LA      R4,HTERME
        WRITES(NET)                     :Press any key to return to ICL
        CLOSE(NET)
        LHI     R1,C.HELP
        SBT     R1,CBITS,R11            :Flag that in help mode
        POP(R5,R4)
        RETURN

        SUBTTL CTLMES routine ... Process control messages
:
: Routine name  CTLMES
:
: Function      Get a coded key from terminal. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     TERMH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(CTLMES,.)
        CHI     R0,0A6                  :Entering DEM
        JE      CTLM20
        CHI     R0,0A7                  :Leaving DEM
        JE      CTLM40
        CHI     R0,0AA                  :Green ball
        JE      CTLM50
        CHI     R0,0AB                  :Red ball
        JE      CTLM70
        CRUNCH(CRNOCO)                  :We don't support this code
:
:       Entering deferred echo mode
:
: Check if we awaiting EDEM. (This would be because screen has been corrupted
: by local echo.) If so output clean screen. Otherwise just note that we
: are not being echoed.
:
CTLM20  LHI     R1,D.WDEM
        RBT     R1,DBITS,R12            :Test and clear awaiting DEM
        JE      CTLM30                  :J if not awaiting DEM
        L       R1,DSCNBF,R12
        JE      CTLM30                  :J if no longer required
        LHI     R1,OFOPT
        STH     R1,SOUTFL,R10           :Flag buffer compare to OUTSCR
        CALL(OUTSCR)                    :Clean screen
CTLM30  LHI     R1,D.DEM
        SBT     R1,DBITS,R12            :Note that we are in DEM
        J       CTLM90                  :Back for next character
:
:       Leaving deferred echo mode
:
: All we need to do is note that we are no longer in deferred eco mode.
:
CTLM40  LHI     R1,D.DEM
        RBT     R1,DBITS,R12            :Clear DEM bit
        J       CTLM90                  :Next character
:
:       Green ball
:
: Green ball is sent by Consat when it wants to leave deferred echo 
: mode. We will return it as a positive reply providing we are not 
: wanting echo off (e.g. because we have sent echo off to Consat which may
: have not yet been actioned.) If we do not reply we note the green ball
: is outstanding by setting D.GB.
:
CTLM50  LHI     R1,D.ECHO
        TBT     R1,DBITS,R12
        JE      CTLM60                  :J if we want echo off
:
        CALL(SNDGB)                     :Return green ball
        J       CTLM90                  :Next character
:
CTLM60  LHI     R1,D.GB
        SBT     R1,DBITS,R12            :Note green ball outstanding
        J       CTLM90                  :Next character
:
:       Red ball
:
: Red ball is sent by Consat when it wants to cancel a green ball or hasn't
: received a reply to a green or red ball. We make sure outstanding green 
: ball is cancelled and send a red ball back as response.
:
CTLM70  LHI     R1,D.GB
        RBT     R1,DBITS,R12            :Clear any outstanding green ball
        CALL(SNDRB)                     :Respond with red ball
        J       CTLM90                  :Next input
:
:
CTLM90  RETURN

        SUBTTL REJECT routine ... Reject terminal input
:
: Routine name  REJECT
:
: Function      Reject terminal input. This routine handles rejected  
:               data from terminal. If Consat has echoed the character to 
:               the screen we must ensure that echoing is stopped and repaint 
:               screen. To save character output to terminal we take a copy 
:               of the screen image and update the current one with the
:               rejected data. When Consat finally stops echoing we can then
:               use clean image and corrupt image to do a quick update.
:               In all cases we send a bell to terminal.
:
: Called by     ICLKEY in ICLKEY
:
: On entry      Link register R1
:               Rejected character in R5
:
: On exit       
:
: Uses          WRITEB in INOUT
:
: ---------------------------------------------------------------------
:
        RSTART(REJECT)
        PUSH(R4)                        :Save register
        LHI     R1,D.DEM
        TBT     R1,DBITS,R12
        JN      REJE80                  :J if Consat not echoing
        LHI     R1,D.WDEM
        SBT     R1,DBITS,R12
        JN      REJE20                  :J if already awaiting DEM
        LHI     R1,D.ECHO
        TBT     R1,DBITS,R12
        JE      REJE20                  :J if all ready requested echo off
:
: Consat has echoed character. We must ask it to stop
:
        CALL(ECHOFF)                    :Request echo off
        CALL(ECHON)                     :Request echo on
:
: Take a copy of screen to be used when echoing stops
:
REJE20  L       R1,DSCNBF,R12
        JN      REJE30                  :J if already got second buffer
        CALL(COPYSC)                    :Get a copy of screen
        ST      R10,DSCNBF,R12          :Save it in DCB
REJE30  L       R10,CSCNBF,R11          :Get current image
:
: Update current image with corrupt character
:
        STB     R5,SCNBUF,R10,R7        :Update current image
:
: Send a bell to warn user of his mistake
:
REJE80  LHI     R4,A.BEL
        OPEN(NET)
        WRITEB(NET)                     :Send bell to user
        CLOSE(NET)
        POP(R4)                         :Restore register
        RETURN
        SUBTTL CHKECO routine ... Check echo
:
: Routine name  CHKECO
:
: Function      This routine check the terminal state and field type to 
:               decide whether Consat can be allowed to echo characters.
:               It can only do this in Type mode in unprotected 
:               non-blanked fields.
:
: Called by     TERMH in this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          ECHON, ECHOFF in CMTI
:
: ---------------------------------------------------------------------
:
        SSTART(CHKECO)
        LHI     R1,VS.TYP
        CLH     R1,CVSTAT,R11
        JN      CHKE10                  :J if not type mode
        THI     R6,ATMPRO
        JN      CHKE10                  :J if in protected field
        LR      R1,R6
        NHI     R1,ATMVAL
        SIS     R1,1
        JE      CHKE10                  :J if blanked field
	LHI	R1,C.ACTN
	TBT	R1,CBITS,R11
	JN	CHKE10			:J if action key being entered
:
: We are in type mode and in an unprotected non blanked field so ECHO on!
:
        LHI     R1,D.ECHO
        SBT     R1,DBITS,R12            :We need echo on
        JN      CHKE20                  :J if already on
        CALL(ECHON)                     :Force it off
        J       CHKE20
:
: We are either not in type mode or in a protected field so ECHO off!
:
CHKE10  LHI     R1,D.ECHO
        RBT     R1,DBITS,R12            :We need echo off
        JE      CHKE20                  :J if already off
        CALL(ECHOFF)                    :Force it off
:
CHKE20  RETURN
        SUBTTL ENDIT routine ... Close down user
:
: Routine name  ENDIT
:
: Function      This routine closes down a user for one of the following
:               reasons:
:                       the user has requested it
:                       The user does not have access to CMT
:
: Called by     KBDH,ALPH
:
: On entry      Link register R1
:               Address of error message in R4
: On exit       Terminal type in R9. All registers
:               will have been preserved
:
: Uses          OPEN, WRITE, CLOSE, READ in INOUT
:
: ---------------------------------------------------------------------
:
        RSTART(ENDIT)                   :Close down entry point
        LIS     R6,1                    :End it flag
        J       ENDI05
:
        RSTART(RESTAR)                  :Restart entry point
        LIS     R6,0                    :Restart flag
ENDI05  ST      R13,DSTCKP,R12
        L       R12,CPDCB,R11
        JE      ENDI20                  :J if no printer host DCB
        L       R13,DSTCKP,R12
        LHL     R1,DPORT,R12
        JE      ENDI10                  :J if no circuit
        CALL(SNDZAP)                    :Close circuit
ENDI10  CALL(RETBUF)                    :Return all buffers
        LR      R5,R12
        CALL(PUTDCB)                    :Return DCB
        LIS     R1,0
        ST      R1,CPDCB,R11            :Flag no printer host DCB
ENDI20  L       R12,CHDCB,R11
        JE      ENDI40                  :J if no video host DCB
        L       R13,DSTCKP,R12
        LHL     R1,DPORT,R12
        JE      ENDI30                  :J if no circuit
        CALL(SNDZAP)                    :Close circuit
ENDI30  CALL(RETBUF)                    :Return all buffers
        LR      R5,R12
        CALL(PUTDCB)                    :Return DCB
        LIS     R1,0
        ST      R1,CHDCB,R11            :Flag no video host DCB
ENDI40  L       R12,CTDCB,R11           :Back to terminal DCB
	LA	R13,DSTCK,R12
        ST      R13,DSTCKP,R12          :Restore stack
        LHL     R1,DPORT,R12
        JE      ENDI55                  :J if no port left
        LR      R4,R4
        JE      ENDI55                  :J if no message to output
	CALL(RETBUF)			:Tidy up DCB
        OPEN(NET)
        PUSH(R4)                        :Save message address
        L       R9,CTPROF,R11           :Skip clear if term type
        JE      ENDI50                  : not known
        LHL     R4,TRMCLR,R9            :Clear screen
        WRITES(NET)
	LR	R6,R6
	JE	ENDI50			:J if restart
	LHL	R4,TRMFIN,R9		:Reset terminal
	WRITES(NET)
ENDI50  LHI     R4,A.CR
        WRITEB(NET)
        LHI     R4,A.LFED
        WRITEB(NET)
        POP(R4)                         :Closing message address
        WRITES(NET)
        LHI     R4,A.CR                 :Carriage return
        WRITEB(NET)
        LHI     R4,A.LFED               :Line feed
        WRITEB(NET)
        CLOSE(NET)
        SUS(SUSVD)                      :Extra suspend to allow message out
        LR      R6,R6
        JN      ENDI55                  :J if not restart
        OPEN(NET)
        LA      R4,RESTRQ
        WRITES(NET)                     :Ask user to press carriage return
        CLOSE(NET)
ENDI52  READ(NET)
        J       ENDI54                  :J if no data available
        CHI     R0,A.CR
        JN      ENDI52                  :J if not CR
        J       ENDI55                  :User responded
ENDI54  SUS(SUSIP)                      :Wait for response
        J       ENDI52
:
ENDI55  CALL(RETBUF)                    :Return all buffers
        L       R5,CSCNBF,R11
        JE      ENDI60                  :J if no screen buffer in CCB
        CALL(PUTSCB)                    :Return screen buffer
        LIS     R5,0
        ST      R5,CSCNBF,R11
ENDI60  LR      R6,R6                   :Is it an end or restart
        JE      ENDI80                  :J if restart
        LHL     R1,DPORT,R12            :Do we still have a circuit
        JE      ENDI70                  :J if not
        CALL(SNDDET)                    :Close circuit
ENDI70  LR      R5,R11
        CALL(PUTCCB)                    :Return CCB to free chain
        LR      R5,R12
        CALL(PUTDCB)                    :Return DCB to free chain
        SUS(SUSIP)                      :Dummy susp to return to EXEC
:
ENDI80  LA      R13,DSTCK,R12
        ST      R13,DSTCKP,R12          :Reset stack
        LHL     R1,DCBNO,R12
        SBT     R1,RUNREQ               :Flag this DCB as runable
        LIS     R1,0
        STH     R1,DSUSP,R12            :Not waitng for anything
        J       LOGRST                  :Restart terminal DCB
        SUBTTL QRYTRM routine ... Determine terminal type from user
:
: Routine name  QRYTRM
:
: Function      This routine displays a terminal type menu to the user
:               and accepts the users selection. At this stage FRNTND
:               is keeping track of echo so we use it's bit array DEM
:               to decide whether to echo characters.
:
: Called by     KBDH,ALPH
:
: On entry      Link register R1
:
: On exit       Terminal type in R9. All registers
:               will have been preserved
:
: Uses          OPEN, WRITE, CLOSE, READ in INOUT
:
: ---------------------------------------------------------------------
:
        SSTART(QRYTRM)
        PUSH(R0,R2,R3,R4,R5,R8)         :Save registers
QRYT10  OPEN(NET)                       :Open output
        LA      R4,QTITLE               :Menu heading
        WRITES(NET)                     :Output heading
        LIS     R0,1                    :Entry number
        LA      R2,TERMLS               :Terminal type list
QRYT20  LR      R8,R0
        LHI     R5,$A 10
        DHR     R8,R5                   :R9 contains tens R8 units
        LR      R4,R9
        AHI     R4,A.0                  :Convert to ASCII
        CHI     R4,A.0
        JN      QRYT30                  :Leading zero?
        LHI     R4,A.SP                 :Suppress it
QRYT30  WRITEB(NET)                     :Output first digit
        LR      R4,R8                   :Second digit
        AHI     R4,A.0                  :Convert to ASCII
        WRITEB(NET)                     :Output second digit
        LHI     R4,A.SP
        WRITEB(NET)                     :Output space
        LR      R4,R2                   :Address of text
        WRITES(NET)
        LHI     R4,A.CR                 :Issue carriage return
        WRITEB(NET)
        LHI     R4,A.LFED               : and line feed
        WRITEB(NET)
        CHI     R0,NUMTTY
        JE      QRYT40                  :Jump if end of list
        AIS     R0,1                    :Next entry
        LB      R9,0,R2                 :Move down terminal text list
        AR      R2,R9
        AIS     R2,1
        J       QRYT20                  :Output next entry
:
: Menu has been output. Now get user response.
:
QRYT40  LA      R4,QSELEC               :Please select terminal type
        WRITES(NET)
        CLOSE(NET)                      :Close output
        LIS     R9,0                    :R9 will contain user selection
        LHL     R3,DPORT,R12
QRYT50  READ(NET)                       :Get user key
        J       QRYT70                  :J if no data available
        TBT     R3,DEM
        JE      QRYT55                  :J if echoed by Consat
        OPEN(NET)
        LR      R4,R0
        WRITEB(NET)                     :Echo character
        CLOSE(NET)
QRYT55  CHI     R0,A.CR                 :End of input
        JE      QRYT60
        SHI     R0,A.0
        JL      QRYT80                  :Jump if invalid input
        CHI     R0,9
        JG      QRYT80                  :Jump if not numeric
        LIS     R5,$A 10                :Convert to binary
        MHR     R9,R5
        AR      R9,R0
        J       QRYT50                  :Next character
:
: We have user input . Check that it is valid.
:
QRYT60  CHI     R9,NUMTTY               :Is entry within range
        JG      QRYT90                  :Jump if not
        LR      R9,R9
        JE      QRYT90                  :Ditto
:
        POP(R8,R5,R4,R3,R2,R0)          :Restore registers
        RETURN
:
: Wait for key input
:
QRYT70  SUS(SUSIP)                      :Wait for input
        J       QRYT50  
:
: User has given invalid entry . Make sure final input value is invalid
: so error code is entered
:
QRYT80  LHI     R9,NUMTTY+1             :Make input number invalid
        J       QRYT50                  :Next character
:
: Output error message and restart process
:
QRYT90  LA      R4,QTERR                :Error message
        OPEN(NET)
        WRITES(NET)                     :Output to terminal
        CLOSE(NET)
        J       QRYT10                  :Back to start of process
:
        SEG     A.DATA
HTITLE  SC      /  ICL Character Mode Translator 1.02 - Help Screen/
QTITLE  SC      /"8D"8A"8D"8ATerminal types supported by ICL"2FCMT :"8A"8D"8A"8D/
QSELEC  SC      /"8A"8D"8A"8DPlease identify your terminal type : /
QTERR   SC      /"8D"8AError in input, please try again"8D"8A/
HUSERN  SC      /"8D"8A"8D"8A         Current username  : /
HPORTT  SC      /"8D"8A         Terminal port     : /
HPORTH  SC      /"8D"8A         Video host port   : /
HPORTP  SC      /"8D"8A         Printer host port : /
HTERMT  SC      /"8A"8D"8A"8D/
HTERME  SC      /            **** Press space bar to return to ICL screen ****/
HNOTA   SC      /--/
HPRTST  SC      /"8D"8A"8D"8A         Printer status : /
HPRTNS  SC      /Not supported on this terminal/
HPRTOP  SC      /Operable/
HPRTXP  SC      /Inoperable/
HPRTAL  SC      /, allocated/
HPRTDA  SC      /, de-allocated/
HPRTHL  SC      /, held/
EBADUS  SC      /You are not allowed access to this host/
EUSER   SC      /Logging off from CMT on user request/
RESTRQ  SC      /"8D"8APress RETURN key to restart CMT"8D"8A/
:
        EM

        SUBTTL STATUS ... Extended DDT code

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  9 JAN 86|  Modified BISYNC COM      |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SUBTTL USER COMMAND HANDLER (DDT COMMAND ?STAT)

  IF    1-\DB.STA                       : DEFAULT DEBUG/STATUS TO ON
DB.STA  EQ      1
  EI

  IF    DB.STA                          : ASSEMBLE ONLY WITH DEBUG STATUS ON

        SEG     A.CODE
        RA      $00
        GL      DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM,R4SAV
        GL      DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL
        GL      HMASK

:       STATUS - User Command Handler
:
:       Version history:
:       13.3  08/19/83  <JOK>Changed DS.TOK to return first 8 chars of
:               TOKEN, changed DS.CMD to retain first 8 chars of command,
:               and changed DSTART to accept up to 8-character commands.
:       13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:               following 'QUIT' SVC to allow DDT "P" (proceede) command
:               to return the user to ":>" prompt.
:       13.1  11/17/81  <BAB>Added DNEXTK support, DS.DLM (last delimiter),
:               and fixed backspace for > 4 character entry, added the
:               command thought to be invalid to invalid command message.
:       13      08/81   <JK>Maintenance assumed by BAB from John Kopf
:
:               The Status package is intended to provide an extension to DDT,
:       invokable via the "?STAT" command in DDT.  Once invoked you may re-
:       activate it (provided you have not issued any DDT "G" (go) commands)
:       by typing "P ".
:
:               There is limited editing control built into the package:
:       ESC     aborts back to command level,
:       ^W      discards partial 'token' already input (word or number),
:       ^A      discards last char of token (backspace).
:       ^H      discards last char of token (backspace).

:               Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:       delimiters are:
:       C/R     L/F     H/T     ","     and BLANK.

:               Entry Points:
:       DSTART  Place to exit on completion of command.
:       DNEXTK  Get next token with out prompt.
:       DS.ILL  Place to exit on illegal command -- types "Illegal command"
:       DS.ERR  Place to exit on command error -- types "type '\' "
:       DS.EXI  Place to exit machine.
:       DS.QUI  Place to exit back to DDT.
:       DS.GCH  Get a character...Link on R1, char (with high-order bit forced)
:                       in R0...normal return if detected ^W, skip-4 if detect
:                       ^A, aborts back to DSTART if detects ESC.
:       DS.DEL  Check for delimiter...Link on R2, Character in R0.  Skip-4
:                       return unless this is a delimiter, then normal return.
:       DS.CUC  Convert to upper case...Link on R1, Character in R0.
:       DS.TOK  Get a string token...Link on R4, TOKEN returned in R3/R2...
:                       inputs up to 4 characters, returns them (in uppercase)
:                       left justified, 0 fill
:       DS.NUM  Get a number...Link on R5, expects Radix in R4...
:                       number returned in R0.  May ABORT if any character is
:                       input other than valid digit or delimiter.
:       DS.DLM  Location of last delimeter entered (1 byte)

:               There are two built-in commands:
:       Quit    exit back to DDT.
:       EXIt    exit machine.

:               additional commands may be defined via the DS.CMD macro:
:        DS.CMD(TEXT,ADDR)
:       Where:  TEXT    The (UPPERCASE) target command string.
:               ADDR    The virtual address to transfer to, to service that
:                               command.
:       DS.CMD generates a 16-byte descriptor for this command, at the point
:       assembly where it is invoked.  This descriptor is on a WORD boundary.



OUT     EQ      0B                      : Output SVC
IN      EQ      0A                      : Input SVC

DS.ELL  EQ      0                       : Null pointer for end-of-linked-list

        SEG     A.DATA
DS.DLM  BS      1                       : Last delimiter encountered
R4SAV   WS      1                       : Save-area for R4 in DS.TOK
BADSTR  SC      /'xxxxxxxx'"8D"8A/      : Place to put bad command
STOKEN  EQ      BADSTR+2                : String-buffer for token
        SEG     A.CODE

:       Define elements for command-block
C.NEXT  EQ      0                       : Pointer to next command-block
C.ADDR  EQ      C.NEXT+4                : Pointer to command-handler
C.STR   EQ      C.ADDR+4                : Relative position of string

:       Define macro to generate this command-block
DS.CMD  MACRO(STR,ADDR)[ WS     0
   IF   DS.ELL
Q       WS      0
        ORG     DS.ELL
        WC      Q
        ORG     Q
   EI
DS.ELL  WC      0,ADDR
        AC      /STR/
        WS      0
 IF     DS.ELL+10-. ; WC 0; EI
]


:       TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST  DS.CMD(Q,DS.QUI)                : Exit back to DDT
        DS.CMD(QUIT,DS.QUI)             : Exit back to DDT
        DS.CMD(EXIT,DS.EXI)             : Exit
        DS.CMD(EXI,DS.EXI)              : Exit




:       Diagnostic messages
TERR    SC      /Illegal command /
TTERR   SC      /type '\'"8D"8A/
HLPMSG  SC      /"8D"8A"8D"8ATYPE '?' FOR MENU/
PROMPT  SC      /"8D"8ACOM:>/           : "CR|LF:>"
BKSPAC  SC      /"88 "88/               : Back-space
        SUBTTL  Command-scanner, Verifier, and Bitcher

:       Command-input Handler
DOIT    L       R0,C.ADDR,R1            : Go service this command
        JALR    R0,R0

:       Next Command
DSTART  SVC     OUT,HLPMSG
        SVC     OUT,PROMPT              : Issue Prompt
DNEXTK  JAL     R4,DS.TOK               : Get command-token
        LA      R1,CMDLST               : Search for string-match
DSTAR1  CL      R3,C.STR,R1             : check first-word
        JNFS    DSTAR2                  : no match
        CL      R2,C.STR+4,R1           : second-word
        JE      DOIT                    : Proceed if find a match

DSTAR2  L       R1,C.NEXT,R1            : Else continue scan
        JGBS    DSTAR1

DS.ILL  SVC     OUT,TERR                : "ILLEGAL COMMAND"
        SVC     OUT,BADSTR,,

DS.ERR  SVC     OUT,TTERR               : Tell user to type Flush-char

BITCH   JAL     R1,DS.GCH               : Flush input
         JBS    BITCH;   NOPR   0                       : ^W...Ignore
          JBS   BITCH;    NOPR  0                       : ^A...Ignore
        CLHI    R0,0DC                  : Read until "\" is found
        JNBS    BITCH
        J       DSTART                  : Then exit


:       Built-in Commands

:               Command EXIt
:               ===========-
DS.EXI  SVC     KIO,0                   : Disconnect


:               Command Quit (exit back to DDT)
:               =========---
DS.QUI  SVC     KIO,1                   : Return to DDT
        J       DSTART                  : If operator typed "P", get next cmd
        SUBTTL  U T I L I T I E S

:       Get a Command-token...Up to 8 chars long
:               Skips over extra characters to next delimiter
:       Link on R4
:       Token returned in R3/R2, Left justified, 0-fill
DS.TOK  ST      R4,R4SAV,,              : save R4

TOKEN0  LIS     R0,0                    : clear token buffer
        LA      R3,STOKEN,,             : set char-pointer
        ST      R0,0,R3
        ST      R0,4,R3

:       Scan for first character of TOKEN
TOKEN1  JAL     R1,DS.GCH               : Get next char
        JBS     TOKEN1   
        NOPR    0                       : ^W...Ignore
        JBS     TOKEN1
        NOPR    0                       : ^A...Ignore
        JAL     R2,DS.DEL               : Skip over delimiters
         J      TOKEN1
        JAL     R1,DS.CUC               : Convert to Upper-case
        CHI     R0,00DC                 : = "\" ?
        JE      DSTART                  : YES.  Print Prompt, get next command
        STB     R0,0,R3                 : no...start TOKEN accumulation
        AIS     R3,1                    : advance pointer
        LIS     R4,1                    : 1 char. found so far

TOKEN2  JAL     R1,DS.GCH               : Get another char
         J      TOKEN0                  : ^W...Start over
          J     TOKEN4                  : ^A...Toss last char
        JAL     R1,DS.CUC               : Convert to upper-case
        JAL     R2,DS.DEL               : Check for delimiter
         J      TOKEN3                  : Got one...skip to clean up
        CHI     R0,00DC                 : = "\" ?
        JE      DS.ILL                  : YES.  Treat as Illegal
        AIS     R4,1                    : one more character
        CHI     R4,8                    : If >= 8 chars, do not use this one
        JG      TOKEN2                  : YES...Scan for delimiter
        STB     R0,0,R3                 : NO...Accumulate chars
        AIS     R3,1                    : advance cursor
        J       TOKEN2                  : ..and get another char

TOKEN3  L       R4,R4SAV,,              : Restore R4
        L       R3,STOKEN,,             : place TOKEN into Registers
        L       R2,STOKEN+4,,
        JR      R4                      : Return TOKEN in R2/R3


:       Handle backspace in TOKEN
TOKEN4  SIS     R4,1                    : one less char
        JLE     TOKEN0                  : re-initialize if none left
        CHI     R4,8                    : If after backspace TOKEN is >= 8
        JGE     TOKEN2                  : then just decrement counter
        LIS     R0,0                    : else... drop one character
        SIS     R3,1                    :   back-up pointer
        STB     R0,0,R3
        J       TOKEN2                  : and get next char

:       Utility routine to read a number
:       uses R0-R3
:       Expects RADIX in R4
:       Link on R5
:       Aborts if first non-delimiter is not digit
:       Else returns number in R0
DS.NUM  JAL     R1,DS.GCH               : get next char
         JBS    DS.NUM;  NOPR   0                       : ^W...ignore
          JBS   DS.NUM;  NOPR   0                       : ^A...Ignore
        JAL     R2,DS.DEL               : check for delimiter char
         J      DS.NUM
        JAL     R2,DS.DIG               : test if char is digit
         J      DS.ILL                  : not a digit - give error-message
        CLR     R0,R4
        JGE     DS.ILL                  : digit is bigger than RADIX...Abort
        LR      R3,R0                   : put first digit into accumulator
NUMBER  JAL     R1,DS.GCH               : read next char
         J      DS.NUM                  : ^W...Start over
          J     DIVIDE                  : ^A...Toss last digit
        JAL     R2,DS.DEL               : Check for delimiter
         LR     R0,R3;   JR     R5        :YES
        JAL     R2,DS.DIG               : skip if digit
        J       DS.ILL                  : NO...Abort
        CLR     R0,R4
        JGE     DS.ILL                  : RADIX error...Bitch
        MR      R2,R4                   : build number
        AR      R3,R0                   : add new digit
        J       NUMBER                  : get next digit

DIVIDE  LIS     R2,0                    : got a ^A...Make double-precision arg.
        DR      R2,R4                   : Quotent into R3, where we want it
        J       NUMBER                  : now go back for more digits

:       Digit test
:       Check character read...Skip return if digit
:       Then R0=Binary value of HEX digit
:       uses R1, Link on R2
DS.DIG  JAL     R1,DS.CUC               : Convert to upper-case
        LR      R1,R0                   : Copy char
        SHI     R1,0B0                  : is it "0"?
        JLR     R2                      : return if less than "0"
        SIS     R1,0B9-0B0              : is it "9"
        JLEFS   DIGIT                   : less than "9", then a good digit
        SIS     R1,0C1-0B9              : is it "A"?
        JLR     R2                      : return if less than "A"
        SIS     R1,0C6-0C1              : is it "F"?
        JGR     R2                      : return if greater than "F"
        SIS     R0,7                    : 0A - "A" (partial conversion)

DIGIT   SHI     R0,0B0                  : "0"
        J       4,R2                    : skip-return

:       Check for delimiter
:       Link    R2
:       Uses    R0,R1
:       Skip-4 return unless (R0) is a delimiter-character
DS.DEL  LHI     R1,DLEN-1               : number of delimiter chars
        STB     R0,DS.DLM,,             : save delimiter

DELIM   CLB     R0,DLIST,R1             : compare to a delimiter
        JER     R2                      : return if delimiter
        SIS     R1,1                    : check next delimiter
        JGEBS   DELIM                   : loop if any more delimiters
        J       4,R2                    : skip-return

:       List of delimiter chars
DLIST   AC      ' ,'                    : Blank,","
        BC      8D,8A,89                : CR,LF,HT
DLEN    EQ      .-DLIST                 : Number of delimiter chars

:       Input a Character
:       Link    R1
:       Normal-return:   ^W Input...Flush entry
:       Skip-4 return:  ^A or ^H Input...flush last char
:         SKIP-8 return: Char in R0 (high-bit on)
:       Aborts to command-scanner on "ESC"
DS.GCH  SVC     IN,0F                   : get the char
         J      DS.GCH
        OHI     R0,80                   : set high-order bit
        CLHI    R0,9B                   : check for escape
         JE     DSTART                  : abort, proceed with prompt if so
        CLHI    R0,97                   : check for ^W
         JER    R1                      : normal-return
        CLHI    R0,81                   : check for ^A
         JE     4,R1                    : Skip-4 return
        CLHI    R0,88                   : check for ^H
         JN     8,R1                    : No, skip-8 return, Char in R0

        SVC     OUT,BKSPAC              : Back-space
        J       4,R1                    : skip-4 return for ^H

:       Convert char in (R0) to upper-case
:       Link on R1
DS.CUC  CLHI    R0,0E1                  : Compare with "a"
        JLR     R1                      : Exit if it can't be lower-case
        CLHI    R0,0FA                  : Compare with "z"
        JGR     R1                      : Not lower-case...Just return
        SHI     R0,20                   : Lower-case...Convert to upper-case
        JR      R1                      : and return


        EI

        SUBTTL  ?STAT Command Handlers  
:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 10 JAN 86|  Modified BISYNC COM      |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:

:       CMT OPERATION MONITOR: COM

:       Valid commands accepted are:

:       EXIT or EXI - log off
:       QUIT or Q - exit ?STAT (back to DDT)
:       HELP or ? - print this list
:       INS or INST - Instructions
:       STATE - Slot status
:       VERSION - Description of the slot
:       NAMES - Displays table of user namer to slot
:       MENU username - Screen menu and logon strings associated w/username
:       USER username OR port XX - Numeric lock status and circuits
:       PORTS - Ports associated with each username
:       CRASH - Crash information
:       IRING port1  port2 port3 OR address - Iring associated with each port
:       ORING port1 port2 port3 OR address  - Oring associated with each port
:       RINGS port1 port2 port3 - Alternate rings displayed
        IF      DB.STA

:       Some globals
        GL      CTA,ASMTIM


        SEG     A.CODE
        MO      .,COM

:************************************************************
:       Define some MACROs to make the code more readable!
:************************************************************

        KILL    IFERR,GETNUM,PRINT,DPRINT       : Insure no conflicts

:       MACRO to input a number (into R0):
:       ARG -   radix to be used

GETNUM  MACRO(RAD)[
 IF     $A RAD-15
        LHI     R4,$A RAD
 ELSE
        LIS     R4,$A RAD
 EI
        JAL     R5,DS.NUM,,
]

:       MACRO to print a number (in R0) on terminal
:       ARG     Use
:        1      Number of Digits
:        2      Any sum of:     .S, .B, .Z, one of [ .D, .H, or .O]

.S      EQ      80                      : Signed output
.B      EQ      20                      : Blank fill
.Z      EQ      40                      : Zero fill
.D      EQ      0A                      : Decimal
.O      EQ      08                      : Octal
.H      EQ      10                      : Hexidecimal

DPRINT  MACRO(ND,M2)[
        LHI     R1,(ND*100)!M2
        SVC     KIO,$A 10
]

:       MACRO to print a line of text on terminal
:       ARG -   address of line of text (SC format)

PRINT   MACRO(LINE)[
        SVC     K.OUT,LINE
]

:       MACRO to perform test, print MSG if false
IFERR   MACRO(CND,MSG)[
        J`CND`FS        .+8
        LA      R1,MSG
        J       PERR
]

:       MACRO to see if last delimiter was a carriage return, jumps to ADR
:       if not carriage return to process following argument
ANYARG  MACRO(ADR)[
        LHI     R0,8D
        CLB     R0,DS.DLM,,
        JN      ADR
]
:************************************************************
:       command block
:************************************************************

        DS.CMD(HELP,HELPC)               : Print Command List
        DS.CMD(?,HELPC)                  : Print Command List
        DS.CMD(INS,INSTR)               : Print instructions
        DS.CMD(INST,INSTR)              : Print instructions
        DS.CMD(STATE,STATE)             : Print status of slot
        DS.CMD(VERSION,VERSN)           : Print description of the slot
        DS.CMD(NAMES,NAMES)             : Print table of usernames
        DS.CMD(MENU,CMENU)              : Print screen menu and logon strings
        DS.CMD(USER,CUSER)              : Print user options and circuits
        DS.CMD(PORTS,CPORTS)            : Print active port info
        DS.CMD(CRASH,CCRASH)            : Print infor about crashes
        DS.CMD(IRING,CIRING)            : Display of iring
        DS.CMD(IR,CIRING)               : Display of iring
        DS.CMD(ORING,CORING)            : Display of oring
        DS.CMD(OR,CORING)               : Display of oring
        DS.CMD(RINGS,CRINGS)            : Display of alternating rings

:************************************************************
:       INSTR - Print editing characters and delimiters
:************************************************************

INSTR   HS      0
        JAL     R2,BANNER               : display banner
        PRINT(NL)
        PRINT(INSTM1)                   : display text
        PRINT(INSTM2)
        PRINT(INSTM3)
        PRINT(INSTM4)
        PRINT(INSTM5)
        PRINT(INSTM6)
        PRINT(INSTM7)
        PRINT(NL)
        PRINT(INSTM8)
        J       DSTART
:********************
:       help
:********************

HELPC   JAL     R2,BANNER               :PRINT BANNER
        PRINT(NL)
        PRINT(HELP01)
        PRINT(HELP02)
        PRINT(HELP03)
        PRINT(HELP04)
        PRINT(HELP05)
        PRINT(HELP06)
        PRINT(HELP08)
        PRINT(HELP09)
        PRINT(HELP0A)
        PRINT(HELP0B)
        PRINT(HELP07)
        PRINT(HELP0C)
        PRINT(HELP0D)
        PRINT(HELP0E)
        PRINT(HELP0F)
        PRINT(HELP10)
        J       DSTART
:********************
:       version
:********************

VERSN   JAL     R2,BANNER               :Print banner
        PRINT(NL)
        PRINT(ASSM)                     :print date and time of assembly
        LI      R3,ASMTIM
        LHI     R4,10
        LA      R5,DATTMS,,
        JAL     R6,DATIME
        SVC     K.OUT,PDATE,,           :output date and time
        J       DSTART
:************************************************************
:       STATE -  Displays the status of the slot
:************************************************************

STATE   JAL     R2,BANNER               :DISPLAY BANNER
        PRINT(NL)
        PRINT(STATTL)                   :DISPLAY STATUS HEADER
        PRINT(MUSRTL)                   :DISPLAY MAX # USERS
        LHI     R0,HPRT0
        DPRINT(3,.D!.B)
        PRINT(MPRTTL)                   :DISPLAY MAX # PRINTERS
        LHI     R0,NPRINT
        DPRINT(3,.D!.B)
        PRINT(NL)                       :DISPLAY # ACTIVE TPORTS

        LHI     R3,0                    :INIT PORT COUNTERS
        LHI     R4,0
        LHI     R6,0
        LHI     R2,((MAXPRT)/10)*2
NXHW1   LH      R0,ACP,R2               :CHECK FOR ACTIVE PORTS
DOAGN1  JFFOH   R0,TOTCNT               :LOOK FOR FIRST BIT ON 
                                        :WITHIN HALF WORD
        SIS     R2,2                    :NEXT HALF WORD GROUP
        JGEBS   NXHW1
        J       TOTLS
TOTCNT  JAL     R5,TRNOFF               :GO TURN OFF BIT
        LHL     R5,DTYPE,R12
        CHI     R5,DTTERM               :Is this a terminal DCB
        JE      TTCNT

        CHI     R5,DTHVID
        JE      THCNT                   :HOST DCB
        AHI     R3,1                    :OTHERWISE THIS IS A CPDCB
        J       DOAGN1

TTCNT   AHI     R4,1
        J       DOAGN1
THCNT   AHI     R6,1
        J       DOAGN1
TOTLS   PRINT(NTPTTL)
        LHR     R0,R4                   :OUTPUT TOTAL TPORTS
        DPRINT(3,.B!.D)
        PRINT(NHPTTL)
        LHR     R0,R6                   :OUTPUT TOTAL HPORTS
        DPRINT(3,.B!.D)
        PRINT(NPPTTL)
        LHR     R0,R3                   :OUTPUT TOTAL PPORTS
        DPRINT(3,.B!.D)
        J       DSTART

:************************************************************
: TRNOFF- SUBROUTINE TO TURN OFF BIT
:************************************************************

TRNOFF  XH      R0,HMASK,R1,R1
        SLLS    R2,3                    :COMPUTE PORT NUMBER
        OR      R1,R2
        SRLS    R2,3
        SLLS    R1,2                    :MAKE FULLWORD POINTER
        L       R12,PORTAB,R1           :LOCATE DCB
        L       R11,DCCB,R12
        JR      R5

:************************************************************
:       NAMES - Prints list of tymfile usernames
:************************************************************

NAMES   JAL R2,BANNER                   :OUTPUT BANNER
        PRINT(NL)
        PRINT(TYMNAM)                   :OUTPUT NAME HEADER
        LHI     R1,NUMUNM               :Number of usernames
        LA      R9,UPFLST
NXNAM   PRINT(NL)
	LI	R8,0
        SI      R8,UPFULN                :INDEX WITHIN NAME
CKNAM   LB      R0,UPFUSR+UPFULN,R9,R8
        THI     R0,80                   :WILDCARD?
        JNFS    OKCHAR                  :NO,OUTPUT CHAR
        LHI     R0,A.PND                :YES,SUBSTITUTE #       
OKCHAR  SVC     KIO,$A14                :OUTPUT CHAR
        AIS     R8,1                    :GET NEXT CHAR
        JLBS    CKNAM                   
        AHI     R9,UPFSIZ
        SIS     R1,1
        JG      NXNAM                   :GO TO NEXT NAME
        J       DSTART

:************************************************************
:       MENU - Prints screen menu and logon strings
:               associated with the username
:************************************************************

CMENU   ANYARG(CMENU1)
        JAL     R2,BANNER
        PRINT(NL)
        PRINT(NOARG)                    :SEND ERROR MSG AND 
        J       DSTART          :RETURN TO COM  


        SEG     A.DATA
STADDR  WC      1
        SEG     A.CODE

: get username argument

CMENU1  
        JAL     R4,DS.TOK               :GO GET USERNAME ARGUMENT
        OI      R2,80808080             :TURN HI BITS OF CHARS ON
        OI      R3,80808080
        ST      R2,PSAV1
        ST      R3,PSAV2
        JAL     R2,BANNER               :OUTPUT COM BANNER

:  find user profile
        L       R2,PSAV1                :RESTORE USERNAME ARG
        L       R3,PSAV2
        LA      R9,UPFLST               :GET COUNT OF USERNAMES
        LHI     R7,NUMUNM
        
NM0     LCS     R8,4
NM1     LB      R0,UPFUSR+4,R9,R8       :GET A CHAR FROM USERNAME LIST
        THI     R0,80                   :WILD CARD?
        JEFS    NM2                     :YES..AUTO MATCH
        RLL     R3,8
        LBR     R1,R3                   :GET A CHAR FROM INPUT ARGUMENT
        CLR     R0,R1                   :IS IT A MATCH?
        JNFS    NM3                     :NO..GO GET NEXT NAME
NM2     AIS     R8,1                    :NEXT CHAR
        JL      NM1
        J       FNDNM0                  :MATCHED FIRST 4 CHAR
NM3     AHI     R9,UPFSIZ               :GO TO NEXT NAME
        SIS     R7,1
        JG      NM0
        PRINT(NOUSR)                    :INVALID USERNAME 
        J       DSTART
        
:  match the next 4 characters of user name

FNDNM0  LCS     R8,4
FNDNM1  LB      R0,UPFUSR+UPFULN,R9,R8
        THI     R0,80                   :WILDCARD?
        JEFS    FNDNM2                  :AUTO MATCH
        RLL     R2,8
        LBR     R1,R2
        CLR     R0,R1                   :MATCH?
        JNFS    FNDNM3
FNDNM2  AIS     R8,1                    :NEXT CHAR
        JLBS    FNDNM1
        J       FNDIT                   :MATCHED NAME
FNDNM3  AHI     R9,UPFSIZ               :GO TO NEXT NAME
        SIS     R7,1
        JG      NM0
        PRINT(NOUSR)                    :INVALID USERNAME 
        J       DSTART

FNDIT   LHL     R6,UPFMNU,R9            :GET USER MENU
                

:  found right user, send menu

        PRINT(NL)
        PRINT(MNUTTL)                   :OUTPUT MENU HEADER
        PRINT(NL)
        SLLS    R6,2                    :MAKE FULLWORD MENU INDEX       
        LHL     R4,MENUS+2,R6           :INDEX TO MSTRS OF 1ST LOGSTR
        LB      R7,MENUS,R6             :COUNT OF #OF LOGON STRINGS
        AR      R7,R7                   :COMPENSATE DOUBLE FOR HALFWORDS
        LIS     R8,0                    :COUNTS # LABELS (DOUBLED)
NXTSTR  LHL     R1,MSTRS,R4,R8          :INDEX TO CURRENT STRING
        LHL     R1,LSTRS+4,R1           :INDEX TO LABEL
        LIS     R12,0
        LB      R9,STRLAB,R1,R12        :#CHAR IN LABEL
        AIS     R12,1
NXTST1  LB      R0,STRLAB,R1,R12        :GET A CHAR     
        SVC     KIO,$A14                :OUTPUT CHAR    
        AIS     R12,1
        CLR     R9,R12                  :DONE?
        JGE     NXTST1                  :NO     
        PRINT(NL)                       :NEW LINE
        AIS     R8,2
        CLR     R8,R7                   :COMPARE # OF STRINGS
        JL      NXTSTR

: now send out logon strings

        PRINT(LSTTL)                    :LOGON STRING HEADER
        LHL     R1,MSTRS,R4             :GET SELECTED LOGON STRING
        LIS     R8,0                    :REINIT INDEX TO MENU STRINGS
RD00    LB      R6,LSTRS,R1             :# ELEMENTS IN STRING
        AR      R6,R6                   :DOUBLE # ELEM FOR COMP
        CLI     R6,4                    :IS THIS A MANUAL LOGON STRING?
        JL      NXST
        LHL     R1,LSTRS+2,R1           :ADDR OF LOGON ELEM
        LIS     R5,0                    :POINTER TO ELEM
RD05    PRINT(NL) 
        LHL     R9,STRLST,R5,R1         :GET ELEM #
        SLLS    R9,2                    :MAKE FULLWORD INDEX
        L       R3,ELEADR,R9            :GET ADDR OF CHAR(ADDR 1ST ELEM)
        LIS     R11,0                   :INDEX INTO ELEM CHAR
        LB      R12,0,R3,R11            :GET # OF  CHARCTERS
RD10    AIS     R11,1
        LB      R0,0,R3,R11             :GET A CHAR
        CLB     R0,8D                   :A CR OR SEMICOLON
        JE      NXELE                   :INDICATES END OF STRING
        LR      R0,R0
        JN      RD15
        LHI     R0,A.QUE                :Replace password wild card by ?
RD15    SVC     KIO,$A14                :OUTPUT THE CHAR
        CR      R12,R11                 :DONE WITH THIS ELEM?
        JGE     RD10
        CR      R5,R6                   :DONE PROCESSING ELEMENTS?
        JGE     NXST

: get next element

NXELE   AIS     R5,2                    :INCREMENT ELEM INDEX   
        PRINT(NL)
        LHL     R9,STRLST,R5,R1         :GET ELEM #
        SLLS    R9,2                    :MAKE FULLWORD INDEX
        L       R3,ELEADR,R9            :GET ADDR OF CHAR(ADDR 1ST ELEM)
        LIS     R11,0                   :INDEX INTO ELEM CHAR
        LB      R12,0,R3,R11            :GET # OF  CHARCTERS
RD20    AIS     R11,1
        LB      R0,0,R3,R11             :GET A CHAR
        JN      NXELE0                  :ZERO IS WILD CARD
        LHI     R0,A.PND                :OUTPUT TWO HASHES
        SVC     KIO,$A14                :OUTPUT THE CHAR
        SVC     KIO,$A14                :OUTPUT THE CHAR
        J       NXELE3

NXELE0  DPRINT(2,.D!.B)
        LI      R0,20                   :SEND A SPCE 
        SVC     KIO,$A14
NXELE1  AIS     R11,1
        LB      R0,0,R3,R11
        JN      NXELE2                  :ZERO IS WILD CARD
        LHI     R0,A.PND                :OUTPUT TWO HASHES
        SVC     KIO,$A14                :OUTPUT THE CHAR
        SVC     KIO,$A14                :OUTPUT THE CHAR
        J       NXELE3

NXELE2  DPRINT(2,.H!.B)
NXELE3  LI      R0,20                   :SEND A SPCE 
        SVC     KIO,$A14
        CR      R12,R11                 :DONE WITH THIS ELEM?
        JG      NXELE1
        AIS     R5,2                    :INCREMENT ELEM COUNTER
        CR      R5,R6                   :DONE PROCESSING ELEMENTS?
        JGE     NXST
        J       RD05                    :PRINTER STRING HAS 4 ELEM      


: GO TO NEXT STRING

NXST    AIS     R8,2                    :INCREMENT STRING COUNTER
        CR      R8,R7                   :DONE WITH STRINGS?
        JL      NXST1
        J       DSTART
NXST1   LHL     R1,MSTRS,R8,R4
        J       RD00

:************************************************************
:       USER - If username input, all circuits associated with name
:               displayed, otherwise,only circuits associated
:               with user whose port# is given are displayed.  
:************************************************************

CUSER   ANYARG(CUSER1)                  :CHECK FOR ARGUMENT
        PRINT(NOARG)                    :NONE,SEND ERROR MSG AND RET COM
        J       DSTART


CUSER1  JAL     R4,DS.TOK               :GET ARGUMENT   
        L       R1,CPORT        
        CR      R3,R1                   :COMPARE 1ST WORD W/PORT
        JE      RDPRT                   :GO READ PORT NUMBERS

:ARGUMENT IS A USERNAME

        LIS     R9,1                    :SET USER NAME ARG FLAG
        OI      R2,80808080             :TURN HI BITS OF CHARS ON
        OI      R3,80808080
        LR      R7,R2                   :SAVE TOKENS
        LR      R8,R3
        LIS     R2,3
        RBT     R2,B.FLAGS              :INITIALIZE BIT 3 FLAG
        JAL     R2,BANNER

        LHI     R2,((MAXPRT)/10)*2
NXHW3   LH      R0,ACP,R2               :CHECK FOR ACTIVE PORTS
DOAGN3  JFFOH   R0,CMPNM1               :LOOK FOR FIRST BIT ON 
                                        :WITHIN HALF WORD
        SIS     R2,2                    :NEXT HALF WORD GROUP
        JGEBS   NXHW3
        LIS     R2,3
        RBT     R2,B.FLAGS              :WAS THE USERNAME FOUND?
        JN      DOAGN4
        PRINT(NOTACT)                   :NO..USERNAME NOT ACTIVE
DOAGN4  J       DSTART          :NO MORE PORTS...RETURN

CMPNM1  JAL     R5,TRNOFF
        LHL     R5,DTYPE,R12
        CHI     R5,DTTERM               :IS THIS A TDCB?
        JN      DOAGN3                  :NO,FIND NEXT PORT      
        L       R6,CUNAME,R11
        CR      R8,R6                   :COMPARE NAME(FIRST 4 CHAR)     
        JN      DOAGN3                  :GO TO NEXT PORT
        L       R6,CUNAME+4,R11         :COMPARE NAME(NEXT 4 CHAR)
        CR      R7,R6
        JN      DOAGN3
        ST      R0,PSAV1
        ST      R2,PSAV2
        LIS     R2,3
        SBT     R2,B.FLAGS              :FLAG USERNAME FOUND
        J       NLK                     :OK...OUTPUT INFO

: PORT # GIVEN SO INDEX TO THE CORRECT PORT
 
RDPRT   ANYARG(RDPRT1)
        PRINT(NOARG)
        J       DSTART

RDPRT1  LIS     R9,0                    :FLAG AS PORT ARG
        LHI     R4,10                   :SET RADIX TO HEX
        JAL     R5,DS.NUM               :GET NUMBER IN R0       

: LOCATE THE PROPER DCB

        SLLS    R0,2
        LR      R5,R0
        L       R12,PORTAB,R5
        L       R11,DCCB,R12

: NOW START OUTPUTING SOME INFORMATION

NLK     ST      R0,PSAV1
        ST      R2,PSAV2
        JAL     R2,BANNER

: OUTPUT TERMINAL PORT NUMBER

TRM0    PRINT(NL)
        PRINT(TPTTL)
        LH      R0,DPORT,R12
        JE      NCTMSG                  :IF 0=NO CIRCUIT
        DPRINT(3,.B!.H)

: OUTPUT TERMINAL LOGON STRING

        PRINT(LSTTL1)
	LI	R3,0
        SI      R3,UPFULN
TRM1    LB      R0,CUNAME+UPFULN,R11,R3
        SVC     KIO,$A14                :OUTPUT BYTE OF USERNAME
        AIS     R3,1                    :INCREMENT NAME CHAR COUNTER
        JLBS    TRM1
        LI      R0,A.COLN               :ADD A COLON IF DONE
        SVC     KIO,$A14
        LHI     R0,HOST0                :OUTPUT HOST LNUMBER
        DPRINT(5,.D!.B)

: OUTPUT TERMINAL TYPE

        PRINT(TTYTTL)
        L       R4,CTPROF,R11           :GET THE TERMINAL PROFILE T
        LIS     R2,0
        LHL     R3,TRMTTL,R4            :GET ADDR OF STRING
        LB      R4,0,R3,R2              :GET CHAR COUNT
NXTRM   AIS     R2,1
        LB      R0,0,R3,R2              :GET A CHAR
        SVC     KIO,$A14
        CR      R4,R2                   :DONE?
        JG      NXTRM


:GET HOST INFO

        L       R12,CHDCB,R11
        JE      PLUTTL
        PRINT(NL)
        PRINT(HPTTL)
        JAL     R5,GTLGST       

: GET PRINTER INFO

PLUTTL  L       R12,CPDCB,R11
        JE      PLUTT2

        PRINT(NL)
        PRINT(PPTTL)
        JAL     R5,GTLGST
PLUTT2  L       R0,PSAV1
        L       R2,PSAV2
        LR      R4,R9           :WAS IT A USERNAME ARG?
        JE      DSTART
        J       DOAGN3

: NO PORTS ACTIVIATED

NCTMSG  PRINT(NOCRT)
        L       R0,PSAV1
        L       R2,PSAV2
        LR      R4,R9                   :WAS THIS A USERNAME?
        JN      DOAGN3                  :GO LOOK AT NEXT PORT
        J       DSTART  

: GET LOGON STRING

GTLGST  LH      R0,DPORT,R12            :GET HPORT
        JE      NCTMSG                  :NO CIRCUIT
        DPRINT(3,.B!.H)
        PRINT(LSTTL1)
        LHL     R6,CLSTRS,R11           :GET INDEX TO SELECTED LOGON
        LB      R0,LSTRS,R6             :GET # ELEM IN STRING
        AR      R0,R0                   :DOUBLE # ELEM FOR COMPW/HALFWD
        CLHI    R0,2                    :MANUAL LOGON?
        JG      GTLG1                   :NO
        PRINT(MANLOG)                   :PRINT MANUAL LOGON MSG
        JR      R5                      :RETURN TO NEXT CIRCUIT
GTLG1   LHL     R1,LSTRS+2,R6           :GETINDEX TO 1ST ELEM
        LHL     R3,DTYPE,R12
        CHI     R3,DTHPRT               :J if not printer
        JN      GTLG2
        AIS     R1,4
GTLG2   LHL     R3,STRLST,R1
        SLLS    R3,2                    :MAKE FULLWORD INDEX
        L       R3,ELEADR,R3            :GET ADDR OF STRING
        LB      R4,0,R3                 :GET COUNT OF CHAR
        LA      R6,TMPNAM
        LIS     R2,0
NXBYT0  LB      R0,0,R3,R2              :LOAD A CHAR
        STB     R0,0,R6,R2              :STORE IT                       
        AIS     R2,1
        CR      R4,R2
        JN      NXBYT0
        LHI     R2,0
NXBYT1  AIS     R2,1
        LB      R0,TMPNAM,R2            :GET A BYTE FROM THE ELEM
        JN      NXBYT2                  :J if not wild card
        LHI     R0,A.QUE                :Replace wild card by ?
NXBYT2  CHI     R0,8D                   :IS THIS A CR?
        JE      GTDSP                   :GET THE DSP LOGON NEXT
        SVC     KIO,$A14                :,OUTPUT CHAR   
        CR      R4,R2                   :DONE WITH ELEM?
        JN      NXBYT1

: GET CUA CIRCUIT INFORMATION

GTDSP   PRINT(LINTTL)                   :PRINT HEADER
        LHL     R0,DLINE,R12            :GET LINE
        DPRINT(2,.B!.D)
        PRINT(GRPTTL)                   :PRINT HEADER
        LHL     R0,DGROUP,R12           :GET GROUP
        DPRINT(2,.Z!.H)
        PRINT(SUBTTL)                   :GET HEADER
        LHL     R0,DSUBSD,R12           :GET SUBSD
        DPRINT(2,.Z!.H)
        JR      R5
        
:************************************************************
:       PORTS - displays information about all the active ports
:               associated with each username in the slot.
:************************************************************

CPORTS  JAL     R2,BANNER               :PRINT BANNER

        LHI     R2,((MAXPRT)/10)*2
NXHW4   LH      R0,ACP,R2               :CHECK FOR ACTIVE PORTS
DOAGN4  JFFOH   R0,OUTINF               :LOOK FOR FIRST BIT ON 
                                        :WITHIN HALF WORD
        SIS     R2,2                    :NEXT HALF WORD GROUP
        JGEBS   NXHW4
        J       DSTART

OUTINF  JAL     R5,TRNOFF
        LHL     R5,DTYPE,R12
        CHI     R5,DTTERM               :IS IT A TERMINAL DCB
        JE      PRTNAM                  :GO PRINT USERNAME
        J       DOAGN4

: OUTPUT USERNAME INFORMATION

PRTNAM  ST      R0,PSAV1
        ST      R2,PSAV2
        PRINT(NL)
        PRINT(UNMTL)                    :PRINT HEADER
	LI	R3,0
        SI      R3,UPFULN               :NEGATIVE INDEXING
PRTN1   LB      R0,CUNAME+UPFULN,R11,R3
        THI     R0,80                   :IS THIS  AWILD CARD?
        JNFS    PRTN2
        LHI     R0,A.PND                :INSERT A #
PRTN2   SVC     KIO,$A14                :OUTPUT THE CHAR
        AIS     R3,1
        JLBS    PRTN1
        
: PRINT THE PORT #

        PRINT(TPTTL)
        LHL     R0,DPORT,R12            :GET PORT NUMBER
        JE      NCIRT                   :0=NO CIRCUIT
        DPRINT(3,.B!.H)
        PRINT(HPTTL)
        L       R5,CHDCB,R11            :ACTIVE HOST PORT?
        JE      NCIRT                   :NO,SEND MSGAND GET NEXT PORT
        LHL     R0,DPORT,R5             :DISPLAY PORT NO.
        DPRINT(3,.B!.H)

: OUTPUT PRINTER PORT INFORMATION

        PRINT(NL)
        PRINT(PPTTL)                    :PRINT HEADER
        LH      R5,CPDCB,R11            :ACTIVE PRINTER PORT?
        JE      NCIRT                   :NO,SEND MSGAND GET NEXT PORT
        LHL     R0,DPORT,R12
        DPRINT(3,.B!.H)


NXPT    l       r0,psav1
        l       r2,psav2
        J       DOAGN4
NCIRT   PRINT(NOCRT)
        l       r0,psav1
        l       r2,psav2
        J       DOAGN4

        
:************************************************************
:
:       DCB - displays detailed information about contents of
:             DCB.
:
:************************************************************

DCBINF  JAL     R2,BANNER               :Display banner
        ANYARG(DCB100)                  :Get user parameter
        PRINT(NOARG)                    :Error - no parameter
        J       DSTART
DCB100  JAL     R4,DS.TOK               :Get arguement
        L       R1,CPORT
        CR      R1,R3                   :Does it start with port
        
        J       DSTART

:************************************************************
:       CRSH.R - Prints information about the last crash.  This 
:       includes crash time, crash point, crash code, crash
:       called from and crash registers.
:************************************************************

        LO      CRASH
CCRASH  JAL     R2,BANNER               :display banner
        LIS     R8,0
        LIS     R7,0
NXCRSH  AIS     R7,1                    :counterfor # crashes displayed
        PRINT(NL)
        PRINT(CCNT)                     :display crash count
        LHL     R0,CRAT,R8              :get count
        DPRINT(4,.B!.H)                 :display it
        SIS     R0,1
        JLE     CRSHND                  :stop here if only one crash

        PRINT(CCODE)                    :display crash code
        LHL     R0,CRAT+CRASHC,R8
        DPRINT(4,.B!.H)

CSHR20  PRINT(CPNT)                     :display crash point
        L       R0,CRAT+CPOINT,R8
        DPRINT(8,.Z!.H)

        PRINT(CRFRM)
        LHL     R0,CRAT+CFROM,R8                :display crash from
        DPRINT(8,.Z!.H)

        PRINT(TIME)                     :display time in GMT of last crash
        L       R3,CTIME,R8
        JGFS    CSHR23
        PRINT(NOTAVL)                   :not avail if zero or neg
        JFS     CSHR24
CSHR23  LHI     R4,10
        LA      R5,DATTMS,,
        JAL     R6,DATIME               :convert time to character string
        SVC     K.OUT,PDATE,,           :print it
CSHR24  PRINT(NL)
        PRINT(REGS)                     :display registers at time of crash
        PRINT(NL)
        LIS     R2,0
        LIS     R3,4
CSHR25  L       R0,CRAT+CRXREG,R2,R8    :get register
        DPRINT(8,.Z!.H)                 :and display it
        AIS     R2,4
        CHI     R2,4*10                 :are we done
        JGEFS   CSHR30                  :if yes, jump
        SIS     R3,1                    :time for new line
        JEFS    CSHR26                  :if so, do it
        PRINT(SPACE2)                   :else, print 2 spaces
        J       CSHR25                  :and do next
CSHR26  PRINT(NL)                       :new line
        LIS     R3,4
        J       CSHR25                  :and do next

: DISPLAY ADDITIONAL SAVED TABLES
        
CSHR30  LHI     R1,NCRSAV               :HOW MANY TABLES SAVED?
        CR      R7,R1
CRSHND  JE      DSTART

:DISPLAY NEXT TABLE


        AI      R8,CRTLEN               :GO GET NEXT TABLE
        J       NXCRSH  

        SEG     1
        FO      CRASH
:************************************************************
:       IRING - Prints real time display of iring
:************************************************************
        SEG     A.DATA
PSAV1   WS      1
PSAV2   WS      1
PSAV3   WS      1
TMPNAM  WS      5
RSAVE   HS      20
        SEG     A.CODE


CIRING  LI      R14,-1                  :REINITIALIZE PORTSAVE AREAS
        ST      R14,PSAV1
        ST      R14,PSAV2
        ST      R14,PSAV3
        ANYARG(IRING1)                  :CHECK FOR ARGUMENT
        JAL     R2,BANNER
        PRINT(RNGTL1)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDIR                 :NO, GO OUTPUT IRING    
        J       DSTART
IRING1  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV1                :SAVE PORT NUMBER       
        ANYARG(IRING2)
        JAL     R2,BANNER
        PRINT(RNGTL1)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDIR                 :NO, GO OUTPUT IRING    
        J       DSTART
IRING2  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV2                :SAVE PORT #
        ANYARG(IRING3)
        JAL     R2,BANNER
        PRINT(RNGTL1)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDIR                 :NO, GO OUTPUT IRING    
        J       DSTART
IRING3  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV3                :SAVE PORT #
        JAL     R2,BANNER
        PRINT(RNGTL1)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDIR
        J       DSTART


:************************************************************
:    ORING : REAL TIME DISPLAY OF ORING
:************************************************************
CORING  LI      R14,-1                  :REINITIALIZE PORTSAVE AREAS
        ST      R14,PSAV1
        ST      R14,PSAV2
        ST      R14,PSAV3
        ANYARG(ORING1)                  :CHECK FOR ARGUMENT
        JAL     R2,BANNER
        PRINT(RNGTL2)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDOR                 :NO, GO OUTPUT ORING    
        J       DSTART
ORING1  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV1                :SAVE PORT #
        ANYARG(ORING2)
        JAL     R2,BANNER
        PRINT(RNGTL2)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDOR                 :NO, GO OUTPUT ORING    
        J       DSTART
ORING2  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV2                :SAVE PORT #
        ANYARG(ORING3)
        JAL     R2,BANNER
        PRINT(RNGTL2)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDOR                 :NO, GO OUTPUT ORING    
        J       DSTART
ORING3  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV3                :SAVE PORT #
        JAL     R2,BANNER
        PRINT(RNGTL2)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDOR
        J       DSTART

:************************************************************
:    RINGS : REAL TIME DISPLAY OF  ALTERNATING RINGS
:************************************************************
CRINGS  LI      R14,-1                  :REINITIALIZE PORTSAVE AREAS
        ST      R14,PSAV1
        ST      R14,PSAV2
        ST      R14,PSAV3
        ANYARG(RINGS1)                  :CHECK FOR ARGUMENT
        JAL     R2,BANNER
        PRINT(RNGTL3)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDRA                 :NO, GO OUTPUT RINGS    
        J       DSTART
RINGS1  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV1                :SAVE PORT #
        ANYARG(RINGS2)
        JAL     R2,BANNER
        PRINT(RNGTL3)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDRA                 :NO, GO OUTPUT RINGS    
        J       DSTART
RINGS2  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV2                :SAVE PORT #
        ANYARG(RINGS3)
        JAL     R2,BANNER
        PRINT(RNGTL3)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDRA                 :NO, GO OUTPUT RINGS    
        J       DSTART
RINGS3  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV3                :SAVE PORT #
        JAL     R2,BANNER
        PRINT(RNGTL3)                   :PRINT HEADER AND
        JAL     R2,XDRA
        J       DSTART


:************************************************************
:       string texts
:************************************************************

HELP01  SC      /"8D"8AValid commands are:/
HELP02  SC      /"8D"8AEXIT or EXI - log off/
HELP03  SC      /"8D"8AQUIT or Q - exit ?STAT (back to DDT)/
HELP04  SC      /"8D"8AHELP or ? - print this list/
HELP05  SC      /"8D"8AINS or INST - Editing Instructions/
HELP06  SC      /"8D"8ASTATE - Slot state/
HELP08  SC      /"8D"8AVERSION - Description of the slot/
HELP09  SC      /"8D"8ANAMES - Table of usernames from tymfile/
HELP0A  SC      /"8D"8AMENU username - Screen menu and logon strings/
HELP0B  SC      /"8D"8AUSER username (or) port XX - circuits and options/
HELP07  SC      /"8D"8Afor this currently active username or port/ 
HELP0C  SC      /"8D"8APORTS - Ports associated with each username/
HELP0D  SC      /"8D"8ACRASH - Information about slot crashes/
HELP0E  SC      /"8D"8AIRING port1 port2 port3 (or) address - Iring display/
HELP0F  SC      /"8D"8AORING port1 port2 port3 (or) address - Oring display/
HELP10  SC      /"8D"8ARINGS port1 port2 port3 - Alternate rings displayed/

INSTM1  SC      /"8D"8AEditing characters are:/
INSTM2  SC      /"8D"8AESC   - abort back to command level/
INSTM3  SC      /"8D"8A^W    - discards partial token/
INSTM4  SC      /"8D"8A^A    - discards last char of token (backspace)/
INSTM5  SC      /"8D"8A^H    - discards last char of token (backspace)/
INSTM6  SC      /"8D"8A"8AValid delimiters are:/
INSTM7  SC      /"8D"8A LF  HT  ' ' and ','./
INSTM8  SC      /"8A"8DCR terminates command line./

NL      SC      /"8D"8A/                : new-line (CR/LF)
SPACE1  SC      / /                     : 1 space
SPACE2  SC      /  /                    : 2 spaces
SPACE3  SC      /   /                   : 3 spaces
SPACE4  SC      /    /                  : 4 spaces
SPACE5  SC      /     /                 : 5 spaces
DOT     SC      /./                     : dot
COLON   SC      /:/                     : colon

STATTL  SC      /"8A"8DCMT SLOT STATUS"8D"8A/
TYMNAM  SC      /"8A"8DTYMFILE USERNAMES"8D"8A/

TRMVER  SC      /    VERSION:/
KNODE   SC      /"8A"8DNODE:/
SLTID   SC      /    SLOT:/
KHOST   SC      /    HOST:/
ASSM    SC      /"8A"8DASSM:/

MUSRTL  SC      /"8A"8D    MAXUSR:/
MPRTTL  SC      /    MAXPRINT:/
NTPTTL  SC      /"8A"8D#TERM PORTS:/
NHPTTL  SC      /    #CRT PORTS:/
NPPTTL  SC      /    #PRINT PORTS:/

NAMTTL  SC      /"8A"8DTYMFILE DEFINED USERNAMES"8D"8A/

MNUTTL  SC      /"8A"8DSCREEN MENU"8D"8A/
NOUSR   SC      /"8A"8DUSERNAME NOT FOUND IN TYMFILE"8D"8A/
LSTTL   SC      /"8A"8DLOGON STRINGS"8D"8A/
INVNAM  SC      /"8A"8DUSER NAME INVALID"8D"8A/
NOARG   SC      /"8D"8ANO ARGUMENT GIVEN"8D"8A/
        WS      0
CPORT   AC      /PORT/
NOTACT  SC      /"8D"8AUSERNAME NOT ACTIVE"8D"8A/
TPTTL   SC      /  TPRT:/
LSTTL1  SC      /  LSTR:/
MANLOG  SC      / MANUAL LOGON/
TTYTTL  SC      /  TRMTYP:/
ONDTTL  SC      /  ORIGNOD:/
HPTTL   SC      /  HPRT:/
PPTTL   SC      /  PPRT:/
DESTTL  SC      /    DEST:/
NODEST  SC      /NO DESTINATION INTERFACE ADDRESS"8D"8A/
LINTTL  SC      /  LINE:/
GRPTTL  SC      /  GRP:/
SUBTTL  SC      /  SUB:/
NOCRT   SC      /NO CIRCUIT ESTABLISHED/

UNMTL   SC      /"8D"8AUSRNAM:/

TIME    SC      /"8A"8DCRASH TIME:  /
CRFRM   SC      /"8A"8DCRASH CALLED FROM:  /
CPNT    SC      /"8A"8DCRASH POINT:  /
CCODE   SC      /"8A"8DCRASH CODE:  /
CCNT    SC      /"8A"8DCRASH COUNT:  /
REGS    SC      /"8A"8DREGISTERS"8A"8D/
NOTAVL  SC      /"8A"8DNOT AVAILABLE"8A"8D/

RNGTL1  SC      /"8A"8DA REAL TIME DISPLAY OF THE IRING FOLLOWS/
RNGNOT  SC      /"8D"8APLEASE TYPE A "AF TO TERMINATE DISPLAY"8D"8A/
RNGTL2  SC      /"8D"8AA REAL TIME DISPLAY OF THE ORING FOLLOWS/
RNGTL3  SC      /"8D"8AA REAL TIME ALTERNATING DISPLAY OF THE RINGS FOLLOWS/




        SUBTTL STATUS ... Extended DDT code

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  9 JAN 86|  Modified BISYNC COM      |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:

        SUBTTL  Utility Routines

:       CHKSYN - Check for Syntax errors.  Looks to see if carriage return
:       was entered before all required arguments were entered.  If so, it
:       prints message 'syntax error!' and does error return.

CHKSYN  LHI     R0,8D                   :was last delimiter a CR
        CLB     R0,DS.DLM,,
        JE      BADSYN                  :if CR, error
        JR      R7                      :else, just return

BADSYN  LA      R1,BSYNTX               :PRINT SYNTAX ERROR MS
        J       PERR

:       PERR(MSG)
:       Print ERRor:
:       NL/MSG/NL
:       R1 -    Pointer to message
:       Exits to DSTART

PERR    PRINT(NL)                       : New-line
        PRINT(0`,R1)                    : MSG
        PRINT(NL)                       : New-line
        J       DS.ERR,,                : ...and Error-exit


:       BANNER - prints BANNER for each COM command includes node
:       number, host number, slot number, code version number
:       and current dat and time in GMT.
:       R2      Link register

BANNER  PRINT(BANNR)                    :COM -- CMT Operations Monitor
        PRINT(SPACE4)                   :put in some spaces
        L       R3,GMT,,                :get GMT
        JLFS    NOTIME                  :jump if GMT not available
        LHI     R4,10                   :DATIME to output 16d characters
        LA      R5,DATTMS,,             :address of where to output date from
        JAL     R6,DATIME               :convert GMT to date and time
        SVC     K.OUT,PDATE,,           :output date and time
        PRINT(NL)
        JFS     PNOD
NOTIME  PRINT(NOGMT)
        PRINT(NL) 
PNOD    PRINT(NODE)                     :NODE followed by node number
        LHL     R0,NODEX,,
        DPRINT(4,.O)
        PRINT(HOST)                     :HOSTfollowed by host number
        LHI R0,HOST0
        DPRINT(5,.D!.B)
        PRINT(SLOT)                     :SLOT followed by slot number
        LHL     R0,SLOTNO,,
        DPRINT(2,.H!.B)
        PRINT(VSNTTL)
        LHI     R0,VERSION
        DPRINT(2,.H!.B)
        PRINT(DOT)
        LHI     R0,REVLEV
        DPRINT(2,.H!.Z)
        JR      R2

BANNR   SC      /"8A"8D"8ACOM -- CMT Operations Monitor   /
NOGMT   SC      /Date and time not available/
VSNTTL  SC      /   VERSION:/
NODE    SC      /"8D"8ANODE:/
SLOT    SC      /    SLOT:/
HOST    SC      /    HOST:/
BSYNTX  SC      /Syntax Error!/
        SEG     A.DATA
PDATE   BC      10                      :followed by 16d characters
DATTMS  BS      10


        SEG     A.CODE


        SUBTTL  Data Conversion Routines

:       These routines were taken from (isis2)convrt.lib and then
:       modified for use in the COM.

        RA      0

:*****************************************************************
:
:       BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:       DATA TO ASCII DECIMAL CHARACTERS.
:
:       ARGUMENTS: R9 CONTAINS THE BINARY NUMBER
:                  R10 CONTAINS NUMBER OF DIGITS OF OUTPUT
:                  R11 POINTS TO OUTPUT AREA
:       LINK ON R4
:
:****************************************************************
:
        SEG     A.DATA
:
RSAVEC  HS      10      :REGISTER SAVE AREA
:
        SEG     A.CODE
:
DIGASC  AC      /0123456789ABCDEF/
:
:       FIRST CHECK FOR A NEGATIVE NUMBER
:               IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
BINDEC  STM     R8,RSAVEC,,     :PRESERVE REGISTERS
        LR      R9,R9           : TEST FOR NEGATIVE NUMBER
        JGEFS   NOTNEG          :JUMP IF NOT NEGATIVE
        LHI     R12,$0 00AD     :'ASCII '-'
        STB     R12,0,R11
        SIS     R10,1           : ROOM FOR ONE LESS DIGIT
        AIS     R11,1           : DITTO
        JLE     RTRN            :NO ROOM FOR DIGIT AFTER MINUS SINE
:       COMPLEMENT THE NUMBER TO POSITIVE
        XI      R9,-1
        AIS     R9,1
NOTNEG  SIS     R11,1
        LIS     R12,$A 10       : DIVISOR
DIV     SR      R8,R8           : CLEAR HI ORDER BITS OF DIVIDEND
        DR      R8,R12          :GET LOW DIGIT IN R9
        LB      R13,DIGASC,R8   :GET ASCII EQUIVALENT OF DEC NUMBER
        STB     R13,0,R10,R11   :STORE IN REVERSE ORDER
        SIS     R10,1           :DECREMENT COUNTER
        JGBS    DIV             : KEEP LOOPING
RTRN    LM      R8,RSAVEC,,     :RESTORE THE REGISTERS
        JR      R4              :AND RETURN


        SUBTTL  GMT Clock Conversion Routines

:       These routines were taken from (isis2)datime.lib and then
:       modified for use in the COM.

        RA      $0 0A

:
:***************************************************************
:
:       THIS PROCEDURE CONVERTS THE GMT CLOCK
:       RELATIVE TO 1/1/74 FROM SECONDS TO
:       DDMMMYY HH:MM (GMT) OR
:       DDMMMYY HH:MM:SS (GMT)
:
:       PARMS
:               R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:               R4 = CHARACTERS OF OUTPUT (13 OR 16)
:               R5 = ADDRESS OF OUTPUT STRING
:               R6 = LINK REGISTER
:       ALL REGISTERS ARE PRESERVED
:
:**************************************************************
:
        SEG     A.DATA
:
RSAVE   HS      $020    :REGISTER SAVE AREA
:
        SEG     A.CODE
DATIME  STM     R0,RSAVE,,      :PRESERVE THE REGISTERS
        S       R3,SEC745       
:       MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:       A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:       YEAR + 3 REGULAR YEARS.  THERE ARE
:       24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
        SR      R2,R2           : CLEAR HI ORDER BYTES
        D       R2,SECDAY       :QUOTIENT IS # OF DAYS
:                               :REMAINDER IS TIME
        LR      R14,R2          :COPY TIME OF DAY
        SR      R2,R2           :CLEAR HI ORDER BYTES
        D       R2,QUADAY       :DIVIDE BY DAYS IN A QUAD
:
:       QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:       REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
        LHI     R8,76           :BASE YEAR
        SLLS    R3,2            :QUAD YEAR * 4
        AR      R8,R3           :ADD TO BASE YEAR
        LA      R7,LEPYEA       :POINT TO DAYS IN MONTH
        C       R2,W366         :IS IT IN CURRENT YEAR?
        JL      MONTHD          :JUMP IF SO
        S       R2,W366         :SUBTRACT DAYS IN YEAR
        AIS     R8,1            :ADD 1 TO YEAR
        LR      R11,R2          :GET REMAIN DAYS IN QUAD
        SR      R10,R10
        D       R10,W365        :AND DIVIDE BY REGYEAR
:       R11 HAS ADDTL YEARS
:       R10 HAS DAYS IN YEAR
        LR      R2,10
        AR      R8,R11
        LI      R7,REGYER       :POINT TO DAYS IN MONTHS
:
:       DAYS IN R2
:       YEAR IN R8
MONTHD  SR      R6,R6           :MONTH COUNTER
        AIS     R2,1            :MAKE 1/1/76 = DAY 1
MONLOP  LR      R9,R2           :SAVE DAYS
        LB      R3,0,R6,R7      :GET DAYS IN MONTH
        SR      R2,R3           :AND SUBTRACT FROM DAYS IN YEAR
        JLEFS   DAZE            :IF MINUS OR ZERO WE'RE IN THE MONTH
        AIS     R6,1            :INCREMENT INDEX
        JBS     MONLOP
:
:       DAYS IN R3
:       MONTH NUMBER - 1 IN R6
:       YEAR IN R8
:
:       SAVE R4 AND R5
DAZE    SIS     R4,8            :SUBTRACT OUT DATE LENGTH
        LR      R13,R4          :PRESERVE IT
        LR      R11,R5          :COPY OUPUT AREA POINTER
:
:       CONVERT DAY
        LIS     R10,2           :# OF OUTPUT CHARACTERS
        JAL     R4,BINDEC       :CONVERT TO DECIMAL ASCII
:
:       MOVE IN MONTH
        AIS     R11,2
        SLHLS   R6,2            :MULTIPLY MONTH NUMBER BY 4
        L       R4,MONTHS,R6    :GET THE NAME IN R4
        STB     R4,2,R11
        SRLS    R4,8
        STB     R4,1,R11
        SRLS    R4,8
        STB     R4,0,R11
        AIS     R11,3
:
:       CONVERT YEAR
        LR      R9,R8
        LIS     R10,2
        JAL     R4,BINDEC       :CONVERT TO CHARACTERS
        LHI     R3,$00A0        :ASCII SPACE
        STB     R3,2,R11        :PUT IT AFTER DATE
        LHI     R5,3,R11        :SET UP OUTPUT POINTER
        LR      R4,R13          :COPY LENGTH ARGUEMENT
        LR      R3,R14          :COPY TIME OF DAY
        JFS     TIME1           :JUMP
:*************************************************************
:
:       GET THE TIME STAMP
:
:       TIME STAMP ROUTINE
:               THIS ROUTINE CONVERTS THE FULLWORD GMT TIME OF DAY
:       TO HH:MM OR HH:MM:SS
:
:       PARAMETERS:
:               R3 = FULLWORD TIME OF DAY (GMT CLOCK)
:               R4 = 5 OR 8 (# OF CHARACTERS TO OUTPUT)
:               R5 = FULLWORD ADDRESS OF OUTPUT
:               R6 = LINK REGISTER
:
:       DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:       IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:       ROUTINE IS ALL ABOUT
:
:****************************************************************
TMSTMP  STM     R0,RSAVE,,      :PRESERVE THE REGISTERS
  IF \TIMZON
        AHI     R3,TIMZON*$A3600        :TIME ZONE CONVERSION
  EI
TIME1   SR      R8,R8           :INDEX FOR OUTPUT AREA
:
        SR      R2,R2           :CLEAR HI-ORDER BITS
        D       R2,SECDAY
:               SECONDS NOW IN R2
        LR      R3,R2           :GET READY FOR
        SR      R2,R2           :ANOTHER DIVIDE
        D       R2,TENOUR       :GET TENS OF HOURS
        JAL     R6,ASCOUT       :PRINT IT OUT IN ASCII
        DH      R2,OURS         :GET HOURS
:               R2 HAS REMAINDER, R3 HAS QUOTIENT
        JAL     R6,ASCOUT       :PRINT IT OUT
        LHI     R3,$00BA        :COLON
        JAL     R6,PRTOUT
        DH      R2,TENMIN
        JAL     R6,ASCOUT
        DH      R2,MIN
        JAL     R6,ASCOUT
:       THE CONDITION CODE HAS BEEN SET -
:       SET IF ANY MORE CHARACTER WANTED
        JE      RETN90          :JUMP IF ONLY 5 CHAR
:
:       PUT IN COLON BEFORE SECONDS
        LHI     R3,$00BA
        JAL     R6,PRTOUT
        DH      R2,TENSEC
        JAL     R6,ASCOUT
        LR      R3,R2           :GET SECONDS IN R3
        JAL     R6,ASCOUT
RETN90  LM      R0,RSAVE,,      :RESTORE THE REGISTERS
        JR      R6              :RETURN
:
:
ASCOUT  AHI     R3,$00B0
PRTOUT  STB     R3,0,R8,R5
        AIS     R8,1    : UPDATE INDEX
        SIS     R4,1
        JR      R6

:
DECMAL  XC      0001020304050607080910111213141516171819202122232425262728293031
SECDAY  WC      24*60*60        :SECONDS IN A DAY
TENOUR  WC      10*60*60        :TENS OF HOURS
OURS    HC      60*60           :HOURS
TENMIN  HC      10*60           :TENS OF MINS
MIN     HC      60              :MIN
TENSEC  HC      10              :TENS OF SECS
  IF    \TIMZON
SEC745  WC      24*60*60*365*2-TIMZON*60*60     :SECONDS IN 74 & 75 PLUS 
                                                :TIME-ZONE CORRECTION
  ELSE
SEC745  WC      24*60*60*365*2  :SECONDS IN 74 AND 75
  EI
W365    WC      365
W366    WC      366
QUADAY  WC      4*365+1
LEPYEA  BC      31,29,31,30,31,30,31,31,30,31,30,31
REGYER  BC      31,28,31,30,31,30,31,31,30,31,30,31
        WS      0
MONTHS  AC      / Jan/
        AC      / Feb/
        AC      / Mar/
        AC      / Apr/
        AC      / May/
        AC      / Jun/
        AC      / Jul/
        AC      / Aug/
        AC      / Sep/
        AC      / Oct/
        AC      / Nov/
        AC      / Dec/


        RA      0       :RADIX TO HEX




::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                      ISIS RING INTERPERTER                   ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                                                              ::
::      This package will decode ISIS dispatcher rings and      ::
::      display them on a DDT port.  Messages that may contain  ::
::      meaningful ASCII text (data, needles, and 1DOWN) are    ::
::      displayed in hex and ASCII.  All other messages are     ::
::      displayed only in hex.                                  ::
::                                                              ::
::      Requirments:                                            ::
::              This code requires ISIS-II version 5 (or above) ::
::              and the STAT.LIB library.  It uses the message  ::
::              length tables in segment F (15d) in ISIS.       ::
::                                                              ::
::      Commands:                                               ::
::              This package includes 4 commands.  With this    ::
::              set of commands you may examine rings that      ::
::              have, and have not wrapped.  Also any output    ::
::              from these commands may be terminated by typing ::
::              any character ("\" is recomended).  All         ::
::              commands may be followed by an optional number. ::
::              This number represents the number of seconds    ::
::              to wait looking for new ring activity.  This    ::
::              may be used to observe rings for N seconds, in  ::
::              'real time'.                                    ::
::                                                              ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        SEG     A.CODE

DECB.3  EQ      032A    :WIDTH= 3, BLANK FILL, BASE=10
DECB.9  EQ      092A    :WIDTH= 9, BLANK FILL, BASE=10
HEXB.3  EQ      0330    :WIDTH= 3, BLANK FILL, BASE=16
HEXZ.4  EQ      0450    :WIDTH= 4,  ZERO FILL, BASE=16
HEXB.5  EQ      0530    :WIDTH= 5, BLANK FILL, BASE=16
HEXZ.5  EQ      0550    :WIDTH= 5,  ZERO FILL, BASE=16
HEXZ.8  EQ      0850    :WIDTH= 8,  ZERO FILL, BASE=16
HEXB.9  EQ      0930    :WIDTH= 9, BLANK FILL, BASE=16
HEXB.A  EQ      0A30    :WIDTH=10, BLANK FILL, BASE=16

LENGTH  EQ      0F0028          :SEG E AND SEG F DATA AREAS
LP0LST  EQ      0F0026
NPORTS  EQ      0E0082          :NUMBER OF PORTS THIS PROCESS
IRINGP  EQ      0E0068          :START OF INPUT RING
ORINGP  EQ      0E006C          :START OF OUTPUT RING
IMAXI   EQ      0E0084          :INPUT RING SIZE  (HALFWORD)
OMAXI   EQ      0E0086          :OUTPUT RING SIZE (HALFWORD)
RING    EQ      4               :4 BYTES PAST 1ST POINTER IS RING
NFMI    EQ      0               :FILL POINTER

        SEG     A.DATA

PORTSAV HS      1               :FOR FLIP/FLOP DECISION (DR COMMAND)
B.FLAGS BC      0               :BIT 1 ON: DOING IRING  (DR COMMAND)
                                :BIT 2 ON: OUTPUT...YES
                                :BIT 3 ON: VALID PORT: OUTPUT MSG       

XDIIND  HS      1               :INPUT INDEX
XDOIND  HS      1               :OUTPUT INDEX

RR      EQ      8               :REGISTER ADDRESS OF RING
RS      EQ      9               :REGISTER RING SIZE
OUT     EQ      0B

        SEG     A.CODE

:
: DISPLAY INPUT RING
:


XDIR    LIS     R14,4                   :INIT ADDR OR PORT ARG 
        RBT     R14,B.FLAGS
        L       R0,PSAV1
        JL      XDIR1                   :WAS AN ARG INPUT?
        CI      R0,1000
        JL      XDIR1                   :THIS WAS A PORT # ARG
        LIS     R14,4
        SBT     R14,B.FLAGS             :ARG WAS AN ADDRESS
        LA      RR,IRING+4,,            :GET START ADDRESS
        CLR     R0,RR                   :COMPARE
        JL      DS.ALOW
:
        AI      RR,IRSIZE               :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,IRING+4              :GENERATE START ADDRESS
        NHI     R0,0FFFC                :ALIGN TO WORD

        STH     R0,XDIIND               :IRING INDEX
        J       XDIR2
XDIR1   LIS     R0,0                    :START AT BEGINNING OF RING
        STH     R0,XDIIND
XDIR2   SVC     0B,XDCRLF
XDIRLP
        LIS     R0,3                    :INITIALIZE FLAG
        RBT     R0,B.FLAGS
        JAL     R14,XDRKBD              :TEST KEYBOARD INPUT
        J       DDTNOP                  :NON SKIP RETURN ENDS RING READ
        JAL     R14,XDRDIR              :SKIP,GO DO INPUT RING
        SVC     DISMISS,0
        J       XDIRLP

:
: DISPLAY OUTPUT RING
:

 
XDOR    LIS     R14,4
        RBT     R14,B.FLAGS             :INIT ADDRESS ARG FLAG  
        L       R0,PSAV1                :WAS AN ARG INPUT?
        JL      XDOR1                   :NO
        CI      R0,1000                 :YES..WAS IT A PORT# OR ADDR
        JL      XDOR1
        LIS     R14,4
        SBT     R14,B.FLAGS             :THIS IS AN ADDRESS
        LA      RR,ORING+4,,            :GET START ADDRESS
        CLR     R0,RR                   :COMPARE
        JL      DS.ALOW
:
        AI      RR,ORSIZE               :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,ORING+4              :GENERATE START ADDRESS
        NHI     R0,0FFFC                :ALIGN TO WORD

        STH     R0,XDOIND               :ORING INDEX
        J       XDOR2
XDOR1   LIS     R0,0                    :START AT BEGINNING OF RING
        STH     R0,XDOIND
XDOR2   SVC     0B,XDCRLF
XDORLP
        LIS     R0,3                    :INITIALIZE FLAG
        RBT     R0,B.FLAGS
        JAL     R14,XDRKBD              :TEST KEYBOARD INPUT
        J       DDTNOP                  :IF ANY THEN DONE
        JAL     R14,XDRDOR              :OUTPUT RING
        SVC     DISMISS,0
        J       XDORLP

:
: DISPLAY BOTH INPUT AND OUTPUT RINGS - ALTERNATING BETWEEN THEM
:

 
XDRA    LIS     R0,0
        STH     R0,XDIIND
        STH     R0,XDOIND
        SVC     0B,XDCRLF
XDRALP
        LIS     R0,3                    :INITIALIZE FLAG
        RBT     R0,B.FLAGS      
        JAL     R14,XDRKBD              :TEST KEYBOARD INPUT
        J       DDTNOP                  :IF ANY THEN DONE
        JAL     R14,XDRDIR              :DISPLAY IRING
        LIS     R0,3                    :INITIALIZE FLAG
        RBT     R0,B.FLAGS      
        JAL     R14,XDRDOR              :DISPLAY ORING
        SVC     DISMISS,0
        J       XDRALP

:
: DISPLAY BOTH INPUT AND OUTPUT RINGS - FOLLOW PORT SEQUENCE: DISPLAY FROM
:     SAME RING UNTIL PORT NUMBER CHANGES, IN WHICH CASE FLIP OVER TO THE 
:     OTHER RING AND DO THE SAME THERE.
:

        DS.CMD(DR,XDR)                  :INPUT & OUTPUT RINGS COMMAND 
 
XDR
        LIS     R0,0
        STH     R0,XDIIND
        STH     R0,XDOIND
        SVC     0B,XDCRLF
XDRLP
        JAL     R14,XDRKBD              :TEST KEYBOARD INPUT
        J       DDTNOP                  :IF ANY THEN DONE

        LIS     R3,2                    :PREPARE INDEX
        RBT     R3,B.FLAGS              :SET DEFAULT-NO OUTPUT THIS PASS
        LIS     R3,1                    :PREPARE INDEX
        TBT     R3,B.FLAGS              :DOING IRING?
        JE      XDRIRI                  :YES, GO CALL OUTPUT
        JAL     R14,XDRDOR              :DISPLAY ORING
        J       XDRCHK                  :GO CHECK NEXT PORT #
XDRIRI  JAL     R14,XDRDIR              :DISPLAY IRING

XDRCHK  LIS     R3,2                    :PREPARE INDEX
        TBT     R3,B.FLAGS              :ANY OUTPUT THIS PASS?
        JEFS    XDRRES                  :NO, FLIP TO OTHER RING
        LHL     R3,RING,R1,RR           :GET NEXT PORT#
        CLH     R3,NPORTS,,             :VALID=0 THRU NPORT
        JLEFS   XDRCH1                  :YES,CONTINUE
        AIS     R1,4                    :ADDR NEXT POSS. PORT#
        JBS     XDRCHK                  :TRY AGAIN
XDRCH1  CLH     R3,PORTSAV,,            :SAME PORT#?
        JEFS    XDRDIS                  :YES, CONTINUE CURRENT RING
XDRRES  LIS     R3,1                    :PREPARE INDEX
        CBT     R3,B.FLAGS              :COMPLEMENT FLAG-->OTHER RING
XDRDIS  SVC     DISMISS,0               
        J       XDRLP                   :CONTINUE LOOP

:
: DUMP I/O RINGS
:
:       R0  - SCRATCH
:       R1  - INDEX INTO RING
:       R10 - LINK TO SUBROUTINES
:       R12 - FLAG FOR PRINTING/NOT PRINTING
:
 
:
: OUTPUT IRING MESSAGE
:
 
XDRDIR
        LA      RR,IRING,,      :HANDLE IRING
        LHI     RS,IRSIZE       :RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDIIND
        CLR     R0,R1
        JER     R14
:
        LHI     R0,0049         : I
        STB     R0,XRNG+1
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDIW
        SR      R1,RS
XDRDIW  LIS     R10,3           :DID WE PRINT A RING MSG?
        TBT     R10,B.FLAGS
        JEFS    XDRDI1          :NO...SKIP THE NL
        SVC     0B,XDCRLF
XDRDI1  STH     R1,XDIIND       :UPDATE OUTPUT INDEX
        JR      R14

:
: OUTPUT ORING MESSAGE
:

XDRDOR
        LA      RR,ORING,,      :HANDLE ORING
        LHI     RS,ORSIZE       :RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDOIND
        CLR     R0,R1
        JER     R14             :EXIT
:
        LHI     R0,4F           : O
        STB     R0,XRNG+1
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDOW
        SR      R1,RS
XDRDOW  LIS     R10,3           :DID WE SEND A RING MSG OUT?
        TBT     R10,B.FLAGS
        JEFS    XDRDO1          :NO..DON'T SEND A NL    
        SVC     0B,XDCRLF       :OUTPUT CRLF
XDRDO1  STH     R1,XDOIND       :OUTPUT INDEX
        JR      R14

:
: KEYBOARD CHECK
:

XDRKBD
        SVC     K.IN,0          :TEST KYBD INPUT
        J       XDRKBE          :NONE, SO NORMAL RETURN
        JR      R14

XDRKBE
        AIS     R14,4           :NORMAL "SKIP" RETURN
        JR      R14             :NORMAL EXIT

: ERROR ROUTINE
:

DS.ALOW
        SVC     0B,ADRLOW
        J       DS.ERR
:
DS.AHI
        SVC     0B,ADRHI
        J       DS.ERR

ADRLOW  SC      /Address too low"8D"8A/
ADRHI   SC      /Address too high"8D"8A/

:
:  PROCESS ISIS MESSAGE
:
:  R1           RING INDEX
:  R8 (RR)      RING START ADDRESS
:  R9 (RS)      RING SIZE
:  R13          LINK
:

XDRISM  LIS     R3,2                    :PREPARE INDEX
        SBT     R3,B.FLAGS              :INDICATE A MSG THIS PASS
        LB      R2,RING+2,R1,RR         :GET MESSAGE CODE
        LHL     R3,RING,R1,RR           :GET PORT #
        JE      XDR0C0                  :IF INTRANODE MESSAGE

:
: CHECK FOR A VALID PORT #, KEEP INCREMENTING UNTIL FOUND
:

        CLH     R3,NPORTS,,             :TEST AGAINST MAX PORT #
        JG      XDR0A0                  :NOT VALID
        L       R4,PSAV1                :WAS AN ARGUMENT SAVED?
        JGE     XDR0                    :YES
        LIS     R12,3
        SBT     R12,B.FLAGS             :OK TO PRINT MSGS
        J       XDR0A5
XDR0    LIS     R12,4
        TBT     R12,B.FLAGS             :WAS ARG AN ADDRESS?
        JE      XDR00
        LIS     R12,3
        SBT     R12,B.FLAGS             :OK TO PRINT MSGS
        J       XDR0A5
XDR00   CLR     R3,R4                   :IS THIS A PORT WE WANT?
        JN      XDR000                  :GO READ RING
        LIS     R12,3
        SBT     R12,B.FLAGS             :OK TO PRINT MSGS
        J       XDR0A5
XDR000  L       R4,PSAV2
        JL      XDR0A5
        CLR     R3,R4
        JN      XDR001
        LIS     R12,3
        SBT     R12,B.FLAGS
        J       XDR0A5
XDR001  L       R4,PSAV3
        JL      XDR0A5
        CLR     R3,R4
        JN      XDR0A5
        LIS     R12,3
        SBT     R12,B.FLAGS
        J       XDR0A5
:
XDR0A0  AIS     R1,4                    :MOVE TO NEXT POSSIBLE PORT
        J       XDRISM                  :LOOP FOR VALID PORT #
:
XDR0A5  STH     R3,PORTSAV              :PORT VALID SO SAVE IT
        LIS     R12,1                   :DEFAULT PRINTING ON <*>
        LR      R2,R2                   :CHECK FOR NEEDLE
        JE      XDR0F0                  :IF SO
:
        CLHI    R2,9E                   :DATA MESSAGE ??
        JL      XDR0B0                  :IF SO
:
        LIS     R4,3
        TBT     R4,B.FLAGS              :CHECK IF OK TO OUTPUT MSG
        JN      XDRB1                   :FLAG SET GO OUTPUT
        SHI     R2,9E
        LB      R6,LENGTH+9E,R2,        :MESSAGE LENGTH FROM TABLE (IN SEG F)
        AIS     R6,2
        AR      R1,R6                   :BUMP INDEX FOR MSG LENGTH
        CR      R1,RS                   :END OF RING?
        JL      XDRB0
        SR      R1,RS
XDRB0   JR      R13
XDRB1   JAL     R10,XPRADD              :PRINT ADDRESS
        SHI     R2,9E                   :BIAS TO 0
        LA      R4,,R2,R2               :FOR INDEXING
        SVC     0B,XDRICA,R4,R4         :ASCII MESSAGE LABEL
        LIS     R12,0   :DO NOT PRINT ISIS CONTROL MESSAGES IN ASCII <*>
        JAL     R10,XDRISB              :GO DUMP ISIS CONTROL MESSAGE
        JR      R13                     :RETURN
:
: DATA MESSAGE
:

XDR0B0  LIS     R4,3
        TBT     R4,B.FLAGS              :IS THIS A VALID PORT #?
        JN      XDR0B1                  :YES,CONTINUE
        LA      R6,3,R2                 :ADD MESSAGE LENGTH
        AR      R1,R6                   :BUMP RING INDEX PAST DATA LENGTH
        CR      R1,RS                   :WRAP?
        JL      XDR0B2                  :NO
        SR      R1,RS
XDR0B2  JR      R13
XDR0B1  JAL     R10,XPRADD              :PRINT ADDRESS
        SVC     0B,XXDATA,,             :"DATA" MESSAGE HEADER
        JAL     R10,XDRISA              :GO DUMP ISIS DATA MSG
        JR      R13                     :RETURN

:
: PORT 0 INTRANODE MESSAGE
:

XDR0C0  LIS     R12,3
        SBT     R12,B.FLAGS             :OK TO PRINT MSG        
        JAL     R10,XPRADD              :PRINT ADDRESS
        LA      R4,,R2,R2               :FOR INDEXING
        SVC     0B,XDRICB,R4,R4         :ASCII MESSAGE LABEL
        TBT     R2,XDRVL,,              :VARIABLE LENGTH MESSAGE ??
        JNFS    XDR0D0                  :IF SO BECAUSE CAN'T HANDLE YET
        LIS     R12,0                   :DO NOT PRINT CONTROL MESSAGE <*>
        JAL     R10,XDRISC              :GO DUMP ISIS INTRANODE MESSAGE
        JR      R13                     :RETURN
XDR0D0  LIS     R12,1                   :<*> SET TO PRINT
        CLHI    R2,8                    :AUX CIRCUIT REQUEST ??
        JN      XDR0E0                  :MUST BE "1-DOWN"
        LA      R4,0A,R1                :STEP TO SIZE BYTE
        CR      R4,RS                   :CHECK FOR WRAP AROUND
        JLFS    XDR0D4                  :IF NOT
        SR      R4,RS                   :IF SO
XDR0D4  LB      R6,RING,RR,R4           :GET VARIABLE STRING SIZE
        AIS     R6,0B                   :ADD CONSTANT PORTION
        LHI     R0,20                   :INSERT A SPACE
        SVC     KIO,0E
        JAL     R10,XDRISE,,            :TO PUT OUT MESSAGE
        JR      R13                     :RETURN
XDR0E0  LA      R4,5,R1                 :STEP TO 1-DOWN STRING SIZE
        CLHI    R4,RS                   :CHECK FOR WRAP AROUND
        JLFS    XDR0E4                  :IF NOT
        SHI     R4,RS                   :IF SO
XDR0E4  LB      R6,RING,RR,R4           :GET VARIABLE MESSAGE SIZE
        AIS     R6,6                    :ADD FIXED MESSAGE LENGTH
        LHI     R0,20                   :INSERT A SPACE
        SVC     KIO,0E
        JAL     R10,XDRISE,,            :TO PUT OUT MESSAGE
        JR      R13                     :RETURN

:
: NEEDLE
:

XDR0F0  LB      R6,RING+3,R1,RR         :GET LENGTH+FIXED PORTION
        AIS     R6,4
        LIS     R4,3
        TBT     R4,B.FLAGS              :VALID PORT?
        JN      XDR0F1                  :YES
        AR      R1,R6
        CR      R1,RS                   :WRAP?
        JL      XDR0F2
        SR      R1,RS
        JR      R13
XDR0F1  JAL     R10,XPRADD              :PRINT ADDRESS
        SVC     0B,needle,,             :NEEDLE MESSAGE
        LHI     R0,20                   :INSERT A BLANK
        SVC     KIO,0E                  :PUT IT OUT
        JAL     R10,XDRISE,,            :TO PUT REST OF MESSAGE
XDR0F2  JR      R13                     :RETURN

:
: TEST LOWER CASE, MAKE UPPER CASE IF TRUE
:

CAPIT   TBT     R0,CAPITT,,             :TEST FOR LOWER CASE CHARACTER
        JER     R1                      :IF NOT
        SHI     R0,20                   :ADJUST TO CAPITALIZE
        JR      R1                      :RETURN
        
:
:       R1 - RING INDEX
:       R2 - MSG CODE TYPE
:       R3 - PORT #
:       R4 - SCRATCH
:       R5 - BYTE TO OUTPUT
:       R6 - SCRATCH
:       R7 - LINE LENGTH COUNTER
:       RS - RING SIZE  (R8)
:       RR - RING START (R9)
:       R10- LINK TO HERE
:       R11- LINK TO XDPUT
:
: DATA MESSAGE
:

XDRISA  LA      R6,3,R2         :MESSAGE LENGTH=MESSAGE TYPE+3
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E          :LETS BE TIDY
        J       XDRISE,,,

:
: CONTROL MESSAGE
:

XDRISB  LB      R6,LENGTH+9E,R2,:MESSAGE LENGTH FROM TABLE (IN SEG F)
        AIS     R6,2
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E
        J       XDRISE,,,

:
: INTRANODE MESSAGE TYPE
:

XDRISC  LHL     R6,LP0LST,,     :SEG F HAS THIS TOO
        LB      R6,NRATE,R6,R2, :MESSAGE LENGTH FROM TABLE
        AIS     R6,2
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E
        J       XDRISE
XDRISD  HS      0
        SVC     0B,XDRASC,,     :ASCII EQUIVALENT OF LINE
        SVC     0B,XDCRLF,,     :NEW LINE
        ST      R10,SAVR10,,
        JAL     R10,XPRADD      :PRINT ADDRESS :*:
        L       R10,SAVR10,,
        SVC     0B,BLANK9,,     :9 BLANKS FOR ALIGNMENT
        LIS     R7,2            :ADJUST LINE COUNTER-as if 2 char done 
        JFS     XDRISF          :SKIP AROUND COUNTER INIT
        LIS     R4,3            :IS IT OK TO OUTPUT MSG?
        TBT     R4,B.FLAGS
        JN      XDRISE
        AR      R1,R6           :ADD MSG LENGTH TO RING INDEX
        CR      R1,RS
        JL      XDEND

XDRISE  LIS     R7,0            :LINE LENGTH COUNTER
XDRISF  LB      R0,RING,R1,RR   :NEXT BYTE FROM RING
        LR      R5,R0           :SAVE A GOOD COPY OF IT
        NHI     R0,7F           :IGNORE MSB
        TBT     R0,XDRECH,,     :PRINTABLE ??
        JNFS    XDRISH          :YES, GET ORIG. BYTE BACK
        LHI     R0,2E           :DEFAULT "." CHARACTER
        JFS     XDRISH+2        :SET CHAR TO "."
XDRISH  LR      R0,R5           :ELSE IF OK TO PRINT IT
:XDRISH+2
        LR      R4,R7           :COMPUTE WHERE TO PLUG INTO LINE
        NHI     R4,0F           :16 BYTES PER LINE
        STB     R0,XDRASC+4,R4,,:PUT 'ER THERE
        JAL     R11,XDPUT,,     :PUT IT OUT
        AIS     R1,1            :BUMP RING INDEX
        CR      R1,RS           :END OF RING ??
        JLFS    XDRISG          :IF NOT
        SR      R1,RS           :FOLD TO RING START
XDRISG  AIS     R7,1            :LINE LENGTH
        SIS     R6,1            :CHECK FOR END OF MSG
        JLE     XDRISI          :FINISH BLANKING AND PRINT      
        THI     R7,0F           :END OF LINE
        JE      XDRISD          :IF SO
        THI     R7,1            :END OF HALFWORD
        JN      XDRISF          :IF NOT TO CONTINUE
        LHI     R0,20           :ADD A SPACE
        SVC     KIO,0E          :TO FORMAT WORDS
        J       XDRISF
XDRISI  LHI     R0,20           :BLANK
        LR      R12,R12         :PRINT DATA ? (1=YES)
        JER     R10             :NO, RETURN
XDRISJ  NHI     R7,0F           :LINE LENGTH OF 16
        JEFS    XDRISK          :IF TO END OF LINE
        STB     R0,XDRASC+4,R7,,:PUT IN A BLANK
        SVC     0B,BLANK2,,     :PRINT 2 BLANKS TO ALLIGN DATA
        THI     R7,1            :ODD ?
        JNFS    XDRISL          :YES, DO NOT PRINT BLANK
        SVC     KIO,0E          :PRINT A BLANK (REG 0)
XDRISL  HS      0
        AIS     R7,1            :COUNT ON UP
        JBS     XDRISJ          :AND SEE IF DONE
XDRISK  SVC     0B,XDRASC,,     :YES, PUT IT OUT
XDEND   JR      R10             :DONE

:       KEYBOARD INPUT ENDS READ RING CMD

DDTNOP  J       DSTART          :IF ANY THEN DONE

:
:       R0 USED BY SVC FOR OUTPUT CHARACTER
:       R1-R3 SAVED
:       R4 DESTROYED
:       R5 BYTE TO BE OUTPUT
:       R11 LINK
:
XDPUT   LBR     4,5             :COPY IT
        SRHLS   4,4             :LEFT NIBBLE
        LB      0,SIAASC,4,     :CONVERT TO ASCII ("0" TO "F")
        SVC     KIO,0E          :PUT IT OUT TO TTY
        NHI     5,0F            :RIGHT NIBBLE
        LB      0,SIAASC,5,     :CONVERT TO ASCII ("0" TO "F")
        SVC     KIO,0E          :PUT IT OUT TO TTY
        JR      R11             :RETURN

:
: WRITE ADDRESS AT START OF DATA/MESSAGE/NEEDLE LINE
:
:       R10 - LINK TO THIS ROUTING
:       ALL OTHERS PRESERVED!
:

XPRADD
        STM     R0,XDSAV,,
        SVC     0B,XRNG
        LA      R0,RING,R1,RR   :GET ADDR OF THIS MESSAGE
        LHI     R1,HEXB.5
        SVC     KIO,$A10
        LHI     R0,0020         :PRINT BLANK
        SVC     KIO,$A14
        LM      R0,XDSAV,,
        JR      R10

        SUBTTL  ISIS RING INTERPRETER (DATA AREAS)

        SEG     0

XDRSS0  HS      0
XDRPLU  SC      /"8D"8A"2B/             :<CR>, <LF>, "+"
SIAASC  AC      /0123456789ABCDEF/
CAPITT  HC      0,0,0,0,0,0,7FFF,0FFE0
XDRECH  HC      0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDCRLF  SC      /"8D"8A/        :<CR>, <LF>
BLANK2  SC      /  /            :TWO BLANKS
XDRVL   HC      0082,0000       :VARIABLE LENGTH MESSAGE FLAGS
BLANK9  SC      /         /     :9 blanks for alignment
NEEDLE  SC      /NDL/           :NEEDLE
XXDATA  SC      /DAT/           :DATA
XDRASC  SC      /  |                |/
XDRCEI  HS      1               :OUR CEI
XRNG    SC      /  /
XDSAV   HS      2*10            :REG SAVE AREA
SAVR10  HS      2               :REG 10 SAVE AREA

:
: ISIS CONTROL MESSAGES
:

XDRICA  HS      0
        SC      /DET/   :DETACH MESSAGE TYPE
        SC      /ZAP/   :DISCONNECT MESSAGE
        SC      /SBP/   :SET     BACK-PRESSURE (NO SEND)
        SC      /RBP/   :RELEASE BACK-PRESSURE (SEND)
        SC      /FLO/   :FLUSH OUTPUT (GOBBLER)
        SC      /FLI/   :FLUSH INPUT  (BACK GOBBLER)
        SC      /BLK/   :DATA LOST IN THIS DIRECTION     (BLACK BALL)
        SC      /GRY/   :DATA LOST IN OPPOSITE DIRECTION (GREY  BALL)
        SC      /EDE/   :ENTER DEFERED ECHO MESSAGE
        SC      /LDE/   :LEAVE DEFERED ECHO MESSAGE
        SC      /ETM/   :ENTER TRANSPARENCY MODE
        SC      /LTM/   :LEAVE TRANSPARENCY MODE
        SC      /GB /   :GREEN BALL
        SC      /RB /   :RED BALL
        SC      /YB /   :YELLOW BALL
        SC      /OB /   :ORANGE BALL
        SC      /BRK/   :BREAK DETECTED
        SC      /HNG/   :HANG UP
        SC      /QTP/   :QUERY TERMINAL PARAMETER
        SC      /STP/   :SET   TERMINAL PARAMETER
        SC      /PSN/   :PSEUDO NEEDLE
        SC      /NLC/   :NORMAL LOGON CHARACTER
        SC      /NLS/   :NORMAL LOGON STATUS
        SC      /LOF/   :LOGON FAILURE
        SC      /NCC/   :NORMAL CIRCUIT COMPLETE
        SC      /ADA/   :ADDENDUM TO ACCOUNTING
        SC      /SHG/   :SUPER-HANG UP
        SC      /TLM/   :SET TRANSMIT LIMIT
        SC      /EBK/   :END OF BREAK
        SC      /ZAK/   :ZAP ACK
        SC      /EAD/   :ENTER ALTERNATE OUTPUT DEVICE MODE
        SC      /LAD/   :LEAVE ALTERNATE OUTPUT DEVICE MODE
        SC      /ZAR/   :ZAP WITH REASON
        SC      /SIX/   :START     INTERFACE INFORMATION EXCHANGE
        SC      /TIX/   :TERMINATE INTERFACE INFORMATION EXCHANGE

:
: INTRA NODE MESSAGES
:

XDRICB  HS      0
        SC      /RQR/   :RESTART REQUEST
        SC      /RST/   :RESTART INTERFACE
        SC      /NTO/   :NODE HAS BEEN TAKEN OVER
        SC      /REP/   :REPORT TO SUPERVISOR'S LOG
        SC      /RHS/   :REPORT HOST STATUS (OBSOLETE)
        SC      /RAC/   :REPORT ACCOUNTING
        SC      /TIM/   :GMT TIME
        SC      /RNP/   :REQUEST FOR NORMAL PSEUDO NEEDLE
        SC      /RAP/   :REQUEST AUX PSEUDO-NEEDLE
        SC      /PSR/   :PSEUDO-NEEDLE REJECTED
        SC      /HPA/   :HOST PORT AVAILABILITY
        SC      /HNA/   :HOST NOT ACCEPTABLE
        SC      /RHC/   :REPORT HOST COST
        SC      /NSU/   :NO SUPERVISOR
        SC      /ODN/   :1-DOWN TEXT
        SC      /RAH/   :REPORT ALL HOSTS
        SC      /HSR/   :HOST STATUS REPORT
        EM              :COM
        EI              :DB.STA 


        SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:                                                                     *
:       This program is the sole property and confidential            *
:       information of Tymshare, Inc., and may not be copied          *
:       in whole or in part or disclosed to any third party           *
:       without the prior written consent of Tymshare.                *
:                                                                     *
:**********************************************************************

	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI

	IF	\APROT0
	ELSE
APROT0	EQ	6	:EXECUTION PROTECTED
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	EI
	IF	\APROT1
	ELSE
APROT1	EQ	5	:WRITE PROTECTED
	EI
Q1	EQ	2
	RE	0C
	IF	\APROT|Q1|
	ELSE
APROT|Q1| EQ	6	:EXECUTION PROTECTED
	EI
Q1	EQ	Q1+1
	ER

:	NAD ALLOWS MORE THAN 10000X TO BE PLACED IN ONE "SEG".
:	WE MUST THEREFORE GO INTO EACH SEG AND IF > 10000X ORG BACK TO
:	10000X AND THEN ENTER THE NEXT SEG TO DEPOSIT THE REMAINDER.
:	THIS, OF COURSE, ASSUMES THAT THE NEXT SEG IS EMPTY.
:	A CHECK IS MADE TO INSURE THIS.

Q1	EQ		0
	RE		0E		:FOR Q1 = 0 TO 0E
	  SEG		Q1
Q3	  EQ		10000*(Q1+1)	:  Q3 = UPPER BOUND FOR THIS SEGMENT
	  IF		.-Q3		:  IF THIS SEGMENT OVERFLOWED
Q2	    EQ		.-Q3		:    Q2 = LENGTH OF OVERFLOW
	    ORG		Q3		:    ORG TO MAXIMUM
	    IF		0E-(Q1+1)	:    IF THE NEXT SEG IS NOT E
	      SEG	Q1+1		:      GO INTO NEXT SEG
	      IF	(.-Q3)		:      IF SEG ALREADY IN USE
	        SEG	Q1		:        RETURN TO PREVIOUS SEG
	      ELSE			:      ELSE
APROT|Q1+1|	EQ	APROT|Q1|	:        COPY PROTECTION
	      EI			:      ENDIF
	    EI				:    ENDIF
	    ORG		.+Q2		:    ADD OVERFLOW TO THE CURRENT SEG
	  EI				:  ENDIF
Q1	  EQ		Q1+1		:NEXT Q1
	ER

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	($0S|Q|SIZE-10000)$A;	REMARK	d bytes%;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
Q	EQ	0
	RE	0E
	BC	APROT|Q|
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols
  "@@'