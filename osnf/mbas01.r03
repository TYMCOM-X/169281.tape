: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : STRT01.R00                             **
: **                                                              **
: **  File Description   : ISIS START.LIB                         **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************

	SUBTTL	ISIS Assembly Switch Definitions	- STRT01.R00
:*******************************************************************
	REMARK	%Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	06;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	SUP.SP	Supervisor-state indicator
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL,SUP.SP
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs
SUP.SP	EQ	0F0139		:byte...0 if no Supervisor (ISIS V9.0++)
:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
    
        SUBTTL  MBASE Definitions of PST, SRB, buffers, etc.

        GL      BUFNXT,BUFPRV,BUFMSG,BUFLEN,BUFCEI,BFNFMI,BUFTYP
        GL      B3DATA,B1DATA,BSPLIT,BUFTMO
BUFNXT  EQ      0
BUFPRV  EQ      4               :BUFFER TYPE 2 ONLY
BUFMSG  EQ      4               :BUFFER1, BUFEER3
BUFLEN  EQ      5               :BUFFER1, BUFFER3
B3DATA  EQ      6               :BUFFER3 START OF DATA
BUFCEI  EQ      6               :BUFFER1 ONLY
BFNFMI  EQ      7               :BUFFER1 ONLY
BUFTYP  EQ      8               :BUFFER1, BUFFER3 ONLY
BUFTMO  EQ      9               :SET IF BUF ON INQUE AT DF TIME-OUT
BSPLIT  EQ      $A 10           :SET IF DATA 'SPLIT' BETWEEN 2 SRBS
B1DATA  EQ      $A 11           :BUFFER1 START OF DATA

        GL      NBUF2,BF2THR,NBUF3

:	MINIMUM NUMBER OF SRBS TO BE ALLOCATED MUST BE:
:	ONE MORE THAN 2 SRBS PER PORT (E.G., 1 PER CHANNEL) PLUS...
:	2 SRBS FOR PORT 0 AND 1 SRB FOR CHANNEL 1. 

SRBMIN	EQ	(NPORT*2)+4

:	NOW INSURE THAT THE NUMBER OF SRBS CONFIGURED BY THE USER (NUMSRB) IS
:	AT LEAST EQUAL TO SRBMIN.  IF NOT, ASSEMBLY CAN'T PROCEED. IF NUMSRB
:	IS LESS THAN SRBMIN + (10% OF SRBMIN), THEN WARN THE USER

	IF	\NUMSRB
	    IF	    (NUMSRB-SRBMIN)+1
		IF	(NUMSRB-SRBMIN)-(SRBMIN/0A)+1
		ELSE
		REMARK %*** WARNING *** NUMBER OF SRBS LESS THAN RECOMMENDED
		REMARK  MINIMUM OF:%
		REMARK                 (NPORT*2)+4+(((NPORT*2)+4)/0A)
		EI
	    ELSE
            REMARK *** NUMSRB = 
            NUMBER NUMSRB
	    REMARK %*** MINIMUM NUMBER OF SRBS MUST EQUAL 
	    REMARK (NPORT*2)+4+(((NPORT*2)+4)/0A) (
            NUMBER (NPORT*2)+4+(((NPORT*2)+4)/0A)
            REMARK x)
            REMARK %*** STOP ASSEMBLY
	    QUIT 1
	    EI
	ELSE
NUMSRB	EQ	(NPORT*2)+4+(((NPORT*2)+4)/0A)
	REMARK %NUMBER OF SRBS TO ALLOCATE (NUMSRB) NOT SPECIFIED
	REMARK %NUMBER OF ALLOCATED SRBS SET TO DEFAULT OF 
	NUMBER NUMSRB
        REMARK x%
	EI

NBUF2	EQ	NUMSRB

:	FREE BUFFER 2 (SRB) THRESHOLD -- NUMBER OF FREE SRBS THAT MUST BE
:	AVAILABLE FOR THE SRDONE TASK

BF2THR	EQ	NPORT+1

:	NMBR BUFFER TYPE 3 PER CHANNEL (NB3PCH) IS CONFIGURED BY USER 

NBUF3   EQ      NB3PCH*NIOCB    :NMBR TYP3 BUFS = NIOCB * NMBR TYP 3 PER CH


:       SBUS BUFFER (TYPE 1) FORMAT

: offset 0       4 5 6 7 8 9 A B
:       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:       |   N   |M|L|C|N|1|T|S|B        |
:       +-+-+-+-+-+-+-+-+-+-+-+         +
:       |                               |
:       +          DATA                 +
:       |                               |
:       +                               +
:       |                               |
:       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:
:       N = BUFNXT -- Addr of next buffer on input queue (if any)
:       M = BUFMSG -- Buffer message
:       L = BUFLEN -- Message length
:       C = BUFCEI -- Current empty index for buffers on PST inque
:       N = BFNFMI -- Next fill msg index for buffers on PST inque
:       1 = BUFTYP -- Buffer type i.d. ("hard-coded" as 1)
:       T = BUFTMO -- Set if buffer on inque at time of data-forwarding timeout
:       S = BSPLIT -- Set if data to forward is "split" between 2 serv. reqs.
:       B = B1DATA -- Start of buffer type 1 data area
:
:       TYPE 3 BUFFER FORMAT
:
: offset 0       4 5 6   8
:       +-+-+-+-+-+-+-+-+-+-+
:       |   N   |M|L| D |3| |
:       +-+-+-+-+-+-+-+-+-+-+
:       N = BUFNXT -- Addr of next buffer on input queue (if any)
:       M = BUFMSG -- BUffer message
:       L = BUFLEN -- Message length (or number of parameters to circ. sig.)
:       D = B3DATA -- 1 or 2 parameters to circ. sig. or 1 byte of data 
:       3 = BUFTYP -- BUffer type i.d. ("hard-coded" as 3)

	GL	PCTDYN,PCTFIX,B1THLD,B3THLD

:	SETTING BACKPRESSURE TRESHOLD
:	-----------------------------

	IF	\B1
	IF	B1THLD-$A100
B1THLD	EQ	$A50
	ELSE 	5-B1THLD
B1THLD	EQ	$A50
	EI
	ELSE
B1THLD	EQ	$A50
	EI
	
	IF	\B3THLD
	IF	B3THLD-$A100
B3THLD	EQ	$A50
	ELSE 	5-B3THLD
B3THLD	EQ	$A50
	EI
	ELSE
B3THLD	EQ	$A50
	EI


:	SETTING BACKPRESSURE PER PORT
:	-----------------------------
: PCTDYN and PCTFIX are two parameters that specify the fair share 
: percentage usage of buffer types 1 and 3.  PCTDYN specifies the
: percent value of the total number of buffers to be divided by the
: number of active ports in the calculation of the fair share 
: percentage.  If the number of active ports is small, then the
: fair share percentage is calculated from a fixed percent PCTFIX
: of the total number of buffers, not using the number of active ports.
: Using this fixed value avoids a small number  of ports from hogging
: a large number of buffers.  Note that the critical number of ports is
: PCTDYN/PCTFIX and that PCTDYN > PCTFIX.  The default values are
: PCTDYN = 50 for 50% and PCTFIX = 5 for 5%.

: DYNAMICALLY CALCULATED PERCENTAGE IS DEFAULTED TO 50%

	IF	\PCTDYN
	IF	PCTDYN-$A100
PCTDYN	EQ	$A50
	ELSE    $A10-PCTDYN
PCTDYN	EQ	$A50
	EI
	ELSE
PCTDYN	EQ	$A50
	EI

: FIXED PERCENTAGE IS DEFAULTED TO 5%

	IF	\PCTFIX
	IF	PCTFIX-$A100
PCTFIX	EQ	5
	ELSE	1-PCTFIX
PCTFIX	EQ	5
	EI
	ELSE
PCTFIX	EQ	5
	EI
: INSURE PCTDYN > PCTFIX
	IF	PCTFIX-PCTDYN
PCTDYN	EQ	$A50
PCTFIX	EQ	5
	EI


:	RELEASING BACKPRESSURE
:	----------------------

:	PCFSB1 -- A PERCENTAGE OF FAIR-SHARE OF TYPE 1 BUF (FSHRB1).
:	PCFSB1 % OF FSHRB1 = B1UCRB.  IF PORT BACKPRESSURED BECAUSE
:	SBBFCT > FSHRB1, THEN RELEASE BKPR IF SBBFCT < B1UCRB.

PCFSB1	EQ	1		:50%

:	PCFSB3 -- A PERCENTAGE OF FAIR-SHARE OF TYPE 3 BUF (FSHRB3).
:	PCFSB3 % OF FSHRB3 = B3UCRB.  IF PORT BACKPRESSURED BECAUSE
:	T3BFCT > FSHRB3, THEN RELEASE BKPR IF T3BFCT < B3UCRB.

PCFSB3	EQ	1		:50%



:       PORT STATUS TABLE EQUATES
        GL      PORT,OUTCHN,INCHNL,INIOCB,OPIOCB,OPQNXT,OPQPRV
   	GL	ATCHNX,ATCPRV,INQUE,OUTQUE,WRTCNT,XMTLIM
        GL      DFCMSK,DFCTIM,DFCLIM,DFCLBE,DFCLCE,DFCCHC,SBBFCT
        GL      PSTFLG,PSTLEN,ZAPFIS,ZAPTIS,ZAPFSP,OUTPND,WRITIP
	GL	OPDFRD,ONIOPQ,DFCACT,NATOBP,BPFRIS,BPTOIS,BPFRSP
        GL      BPFRMB,BPSREQ,PSTEOD,FWCHRS,BUFSAV,READGO,DFTIMO
        GL      T3BFCT,NOREAD,ZPDBCT,ZPDCHC

PORT    EQ      1               :ISIS PORT NUMBER
OUTCHN  EQ      2               :S-BUS OUTPUT CHANNEL (EVEN)
INCHNL  EQ      3               :S-BUS INPUT CHANNEL (ODD)
OPIOCB  EQ      4               :OUTPUT CHANNEL IOCB
INIOCB  EQ      8               :INPUT CHANNEL IOCB
OPQNXT  EQ      $A 12           :NXT PST ON ISIS OUTPUT QUEUE
OPQPRV  EQ      $A 16           :PREVIOUS PST ON ISIS OUTPUT QUEUE
ATCHNX	EQ	$A 20		:NXT PST ON ATTACHED PORT QUEUE
ATCPRV  EQ      $A 24           :PREVIOUS PST ATTACHED PORT QUEUE
INQUE	EQ	$A 28		:INPUT QUEUE POINTER--FROM IRING
OUTQUE	EQ	$A 32		:OUTPUT QUEUE POINTER--TO ORING
WRTCNT	EQ	$A 36		:RUNNING BYTE COUNT DURING LONG WRITE DATA CMD
XMTLIM	EQ	$A 38		:XMIT LIMIT ON OUTPUT FROM SPIRIT
DFCMSK  EQ      $A 40           :1 BYT MASK DEFINING CHARS THAT START FWRDING
DFCTIM  EQ      $A 42           :IDLE TIMER CRITERION FOR DATA FORWARDING
DFCLIM  EQ      $A 44           :DFC LIMIT 
DFCLCE  EQ      $A 46           :DFC--LAST CHAR EXAMINED
DFCCHC  EQ      $A 48           :DFC--CHAR COUNT
SBBFCT  EQ      $A 50           :COUNT OF SBUS BUFFERS IN USE
T3BFCT	EQ	$A 52		:COUNT OF TYPE 3 BUFFERS IN USE
DFCLBE	EQ	$A 54		:DFC--LAST BUFFER EXAMINED
ZPDBCT  EQ      $A 58           :ZAPPED BUFFER COUNT
ZPDCHC  EQ      $A 60           :ZAPPED CHARS COUNT 
PSTFLG	EQ	$A 62		:PORT STATUS TABLE FLAGS (ONE-WORD BIT ARRAY)
BUFSAV  EQ      $A 66           :DATA BUFFER ADDRESS
FWCHRS  EQ      $A 70           :FORWARDABLE CHARS BIT ARRAY
PSTEOD  EQ      $A 86           :PST END-OF-DATA (USED BY OPSMON)

PSTLEN  EQ      $A 88


:       PORT STATUS TABLE BIT FLAG OFFSETS
ZAPFIS  EQ      0               :ZAP REC'D FROM ISIS
ZAPTIS  EQ      1               :ZAP SENT TO ISIS
ZAPFSP  EQ      2               :ZAP REC'D FROM SPIRIT
OUTPND	EQ	3		:PENDING OUTPUT CMD FLAG
WRITIP	EQ	4		:WRITE-IN-PROGRESS FLAG
OPDFRD	EQ	5		:OUTPUT CMD DEFERRED FLAG
ONIOPQ	EQ	6		:SET IF PST IS ON ISIS OUTPUT QUEUE
NATOBP  EQ      7               :SET IF SPIRIT SENDS 'Automatic Backpressure...
:	NOT Allowed' MSG--CLEARED IF SPIRIT SEND 'Automatic Backprsr Allowd'
BPFRIS  EQ      8               :SET IF BACKPRESSURE REC'D FROM ISIS...
:	...AND CLEARED IF RELEASE BACKPRESSURE REC'D FROM ISIS
BPTOIS	EQ	9		:SET IF BACKPRESSURE SENT TO ISIS...
:	...AND CLEARED IF RELEASE BACKPRESSURE SENT TO ISIS
BPFRSP  EQ      $A 10           :SET IF BACKPRESSURE REC'D FROM SPIRIT...
:	...AND CLEARED IF RELEASE BACKPRESSURE REC'D FROM SPIRIT
BPFRMB  EQ      $A 11           :SET IF MBASE WANTS BACKPRESSURE ON A PORT...
:	AND CLEARED IF MBASE WANTS TO RELEASE BACKPRESSURE ON A PORT
BPSREQ	EQ	$A 12		:BACKPRESSURE STATUS REQUEST--SET OR CLEARED...
:	BY SUBROUTINE THAT RESOLVES SPIRIT-MBASE BACKPRESSURE REQUESTS
DFCACT  EQ      $A 13           :SET IF DATA FORWARDING CRITERIA ARE ACTIVE
READGO  EQ      $A 14           :SET WHEN CMD HANDLER GETS READ CMD...
:       ...RESET BY COMPLETE_READ_COMMAND SUBROUTINE
DFTIMO  EQ      $A 15           :SET IF DATA FORWARDING TIMEOUT IS SET-UP...
:       ...CLEARED BY HANDLE_DATA_FORWADING TIMEOUT SUBROUTINE
NOREAD  EQ      $A 16           :SET IF MBASE BCKPRSRE 'CAUSE NO READ UP
ZAPTSP	EQ	$A 17		:SET IF A ZAP IS SENT TO SPIRIT
DFOVRD	EQ	$A 18		:SET IF DFC OVERRIDE IN EFFECT
ZAPINQ	EQ	$A 19		:SET WHEN GOT ZAP ON IRING, CLEARED WHEN...
:	...BUFFER HOLDING ZAP IS TAKEN OF INQUE AND FORWARDED TO SPIRIT
ABPINQ  EQ      $A 20           :SET WHEN APPLY BKP IS PUT ON INQUE, RESET...
:       ...WHEN THE BUFFERED APPLY BKP BUFFER IS TAKEN OFF INQUE
BPTOSP	EQ	$A 21		:SET WHEN APPLY BKP IS FORWARDED TO SPIRIT...
:	...RESET WHEN RELEASE BAKPR IS PUT ON INQUE

:       ...AN SRB THAT SENT READ STATUS FOR WRITE OR SEND SIO


:	SERVICE REQUEST BLOCK EQUATES
        GL	SRBNXT,SRBPRV,SRBD,MSTAT,ISTAT
        GL      SRBYTE,SRCHNL,CNTMSB,CNTLSB,ADRMSB,ADRLSB,STBYT0
        GL      STBYT1,STBYT2,STBYT3,RETADR,PORTST,SRBLEN,BUF2SZ
        GL      BUFADR
SRBNXT  EQ      0               :NEXT ON SERVICE REQUEST QUEUE
SRBPRV  EQ      4               :PREVIOUS ON SERVICE REQEUST QUEUE
MSTAT	EQ	8		:MBASE STATUS AREA
ISTAT	EQ	$A 10		:ISIS STATUS AREA
SRBD 	EQ	$A 12		:START OF SR DATA TO BE PUT IN MSG BLOCK
:	x10 BYTES RESERVED FOR SR DATA--FIRST 2 BYTES, LAST 4 BYTES ...
:	... NOT NOW USED--RESERVED FOR POSSIBLE FUTURE USE
SRBYTE	EQ	SRBD+2		:SERVICE REQUEST BYTE
SRCHNL	EQ	SRBD+3		:CHANNEL
CNTMSB	EQ	SRBD+4		:COUNT--MOST SIGNIFICANT BYTE
CNTLSB	EQ	SRBD+5		:COUNT--LEAST SIGNIFICANT BYTE
ADRMSB	EQ	SRBD+6		:ADDRESS OF DATA--MOST SIGNIFICNAT BYTE
ADRLSB	EQ	SRBD+7		:ADDRESS OF DATA--LEAST SIGNIFICANT BYTE
STBYT0	EQ	SRBD+8		:STATUS BYTE 0
STBYT1	EQ	SRBD+9		:STATUS BYTE 1
STBYT2	EQ	SRBD+0A		:STATUS BYTE 2
STBYT3	EQ	SRBD+0B		:STATUS BYTE 3
PORTST  EQ      $A 28           :PORT STATUS TABLE ADDRESS
RETADR  EQ      $A 32           :RETURN ADDR FROM SR DONE TASK (0 IF NONE)
BUFADR  EQ      $A 36           :ADDRESS OF BUFFER TO RETURN (READ CMD)

SRBLEN  EQ      $A 40
BUF2SZ  EQ      SRBLEN

        GL      RTRNBF,ZERO,YELLOW,MFLUSH,DONE,LNKERR,EOQ,RSTART,IFLUSH
	GL	RSVSRB
:       OFFSETS INTO MSTAT (MBASE STATUS AREA OF SERVICE REQUEST BLOCK)
RTRNBF	EQ	7		:SET IF DATA BUFFER TO BE RETURNED BY DONE TASKK
RSVSRB	EQ	$A 11		:ONLY SET IN THE RESERVE SRB (TESTED BY ENQSRB)
ZERO	EQ	$A 13		:SET TO SIGNAL ISIS TO 0-OUT HIO AND SIO ...
				: ... FIELDS OF IOCB REFERENCED IN THE REQUEST
YELLOW	EQ	$A 14		:SET BY MBASE IF THE SRB IS A 'YELLOW-BALL' SRB
MFLUSH	EQ	$A 15		:SET BY MBASE IF THIS SRB TO BE PUT ON FLUSH Q.
:	OFFSETS INTO ISTAT (ISIS STATUS AREA OF SERVICE REQUEST BLOCK)
DONE	EQ	0		:SET BY ISIS WHEN PROCESSING OF SRB COMPLETED
LNKERR	EQ	7		:SET IF LINK FIELD REFERENCES INVALID ADDRESS
EOQ	EQ	8		:SET IF ISIS ENCOUNTERS END OF QUEUE
RSTART	EQ	9		:SET WHEN ISIS SUBMITS SR (INTERRUPTS SPIRIT)
IFLUSH	EQ	$A 15		:SET TO SHOW THAT ISIS HAS HONORED MBASE ...
				: ... REQEUST TO FLUSH THE SRB (MFLUSH SET)


:       SERVICE REQUEST BLOCK (SRB) FORMAT

: offset 0       4       8   A   C   
:       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:       |   N   |   P   | M | I |x x|S|C|
:       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:       |CNT|ADR|0|1|2|3|x x x x|  PST  |
:       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:       |  RET  |  BUF  |
:       +-+-+-+-+-+-+-+-+
:       N = SRBNXT -- Next SRB on srbque
:       P = SRBPRV -- Previous SRB on srbque
:       M = MSTAT -- Mbase status area
:       I = ISTAT -- Isis status area
:       x x = unused bytes (reserved for future use)
:       S = SRBYTE -- Service request byte
:       C = SRCHNL -- channel
:       CNT = -- most significant and least significant count bytes
:       ADR = most significant and least significant address bytes
:       0 = status byte 0
:       1 = status byte 1
:       2 = status byte 2
:       3 = status byte 3
:       x x x x = unused bytes (reserved for future use)
:       PST = Port status table address
:       RET = return address (if any) -- subroutine called by srdone task
:       BUF = address of a buffer to return via retbf1 after read serv. req.
:             (if it's not a 'split' buffer)



:       CRASH CODE DEFINITIONS
        GL      CCEVT1,CCGTEV,CCSPRS,CCISD,CCHLT0,CCTMLS,CCBSRB
        GL      CCPRTN,CCPRT0,CCINDL,CCIPSN,CCILCS,CCATCQ,CCSBTO,CCJFFO
	GL	CCNOB3,CCRBKP,CCAPBK,CCCMRD
CCSPRS	EQ	20		:START RESET INTERFACE BY SPIRIT
CCEVT1  EQ      21              :INVALID EVENT TYPE CODE (EVTRAC)
CCGTEV  EQ      22              :INVALID EVENT TYPE (GET EVENT)
CCISD   EQ      23              :ERROR FOUND BY ISIS DRIVER (LINK OR STALL)
CCPRTN  EQ	24		:ILLEGAL PORT NMBR
CCPRT0  EQ	25		:ILLEGAL PORT 0 MSG TYPE
CCINDL  EQ	26		:NEEDLE REC'D ON ACTIVE PORT
CCIPSN  EQ	27		:PSEUDONEEDLE REC'D ON ACTIVE PORT
CCILCS  EQ	28		:ILLEGAL CIRCUIT SIGNAL (ISIS MSG)
CCATCQ  EQ      29             :PST NOT ON ATTACHED QUEUE
CCSBTO  EQ      2A             :SBUS TIMEOUT
CCJFFO  EQ      2B             :THIS WILL NEVER HAPPEN
CCHLT0  EQ      2C             :HALT ON CHANNEL 0
CCTMLS  EQ      2D             :TIME-OUT LIST ERROR
CCBSRB  EQ      2E             :BAD SRB ADDR
CCIOUT	EQ	2F	       :PST SHOULDNT BE ON ISIS OUTPUT QUEUE
CCUMSG	EQ	30              :UNKNOWN MESSAGE TYP
CCNOB3	EQ	31		:RAN OUT OF TYPE 3 BUFFERS
CCRBKP  EQ      32              :ERROR IN HANDLING INPUT APPLY BKPRSR
CCAPBK  EQ      33              :ERROR IN HANDLING INPUT RELEASE BKPRSR
CCCMRD  EQ      34              :ERR IN COMPLETION OF A READ OF A CIRC SIG.
        GL      CCNSRB
CCNSRB  EQ      35              :ERR IF NO SRBS

        GL      MBASE,NGRP,CHANL0,CHANL1,CHANL2,CHANL3

MBASE   EQ      6               :MBASE SVC = SVC 6
NGRP    EQ      (NPORT+0F)/10   :NUMBER OF PORT GROUPS 
CHANL0	EQ	0		:THE CONTROLER CHANNEL
CHANL1	EQ	1		:CHANNEL FOR SPRIIT/MBASE-SPECIFIC MSGS
CHANL2	EQ	2		:OUTPUT CHANNEL OF PORT 0
CHANL3	EQ	3		:INPUT CHANNEL OF PORT 0

:	SPIRIT COMMANDS--CHANNEL 1
        GL      SUSPMB,RESUMB,RNTFAC,RXSTAT,LMAPTB,SETIMO
SUSPMB	EQ	04		:SUSPEND MBASE
RESUMB	EQ	06		:RESUME MBASE
RNTFAC	EQ	12		:RESET INTERFACE
RXSTAT	EQ	14		:READ EXTENDED STATUS
LMAPTB	EQ	16		:LOAD MAPPING TABLES
SETIMO	EQ	18		:SET SBUS TIMEOUT
:	SPIRIT COMMANDS--CHANNELS 2 THRU 253
        GL      READ,WRITE,WRTBYT,SNDLNG,SNDSHR
READ	EQ	20		:READ DATA
WRITE	EQ	40		:WRITE DATA
WRTBYT	EQ	42		:WRITE SINGLE BYTE
SNDLNG	EQ	60		:SEND CIRCUIT SIGNAL LONG
SNDSHR	EQ	64		:SEND CIRCUIT SIGNAL SHORT

:       STATUS BITS -- STATUS BYTE 0
        GL      ATTENT,FAILED,SIOERR
ATTENT  EQ      40              :ATTENTION
FAILED  EQ      20              :FAILED
SIOERR  EQ      10              :START I/O ERROR
IOHALT  EQ      08              :I/O HALT

:       STATUS BITS -- STATUS BYTE 1
        GL      INTREQ,ILLCMD,DOILCB,RDTOOS,INVSIO,LMLNER
INTREQ  EQ      40              :INTERFACE RESET REQUIRED
ILLCMD  EQ      10              :ILLEGAL COMMAND
RDTOOS  EQ      11              :READ CMD TOO SHORT FOR CIRC. SIGNAL
INVSIO  EQ      12              :INVALID SIO FIELD
LMLNER  EQ      13              :LOAD MAP TBL LENGTH ERROR
DOILCB  EQ      17              :DAMAGED OR ILLEGAL IOCB
BDLMAP	EQ	18		:BAD LOAD MAP: GARBLED DATA OR MISSING SECTION

:       SERVICE REQUEST CODES--HI-ORDER BIT MUST BE SET IN SRBYTE
        GL      RDATA,WRTDAT,RDNSTA,RDSTAT
RDATA   EQ      1!80            :READ DATA
WRTDAT  EQ      2!80            :WRITE DATA
RDNSTA  EQ      3!80            :READ DATA AND STATUS
RDSTAT  EQ      4!80            :READ STATUS

:       TIME-OUT IDENTIFIERS FOR SBUS TIMEOUT AND ....
:       DISK/TAPER SERVER TIMEOUT
:       (PSTS ARE USED TO ID A PORT DATA FORWARDING TIMEOUT)

        GL      SBTOID,DTTOID
SBTOID  EQ      1               :SBUS TIMEOUT
DTTOID  EQ      -1              :DISK/TAP SERVER TIMEOUT


:	INTERFACE MSG DATA TYPES

        GL      ZAPMSG,SNDMSG,NOSMSG,BLKMSG
FIRST	EQ	09E			:FIRST MESSAGE IN LIST

DETMSG	EQ	09E			:DETACH MESSAGE
ZAPMSG	EQ	09F			:DISCONNECT MESSAGE
NOSMSG	EQ	0A0			:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1			:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2			:FLUSH OUTPUT
BKGMSG	EQ	0A3			:FLUSH INPUT
BLKMSG	EQ	0A4			:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5			:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6			:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7			:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8			:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9			:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA			:GREEN BALL
RBMSG	EQ	0AB			:RED BALL
YBMSG	EQ	0AC			:YELLOW BALL
OBMSG	EQ	0AD			:ORANGE BALL
BRKMSG	EQ	0AE			:BREAK DETECTED
HNGMSG	EQ	0AF			:HANG UP
QTPMSG	EQ	0B0			:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1			:SET TERMINAL PARAMETER
PSNMSG	EQ	0B2			:AUX PSEUDO NEEDLE
NLOGCH	EQ	0B3			:NORMAL LOGON CHAR
NLOGST	EQ	0B4			:NORMAL LOGON STATUS
LGFAIL	EQ	0B5			:LOGON FAILURE
NLOGOK	EQ	0B6			:SUCCESSFUL LOGON
SHGMSG	EQ	0B8			:SUPER-HANG UP
SXMLMT	EQ	0B9			:SET TRANSMIT LIMIT
BREMSG	EQ	0BA			:BREAK END
ZAPACK	EQ	0BB			:ZAP ACK
EAODM	EQ	0BC			:ENTER ALT DEV. MODE
LAODM	EQ	0BD			:LEAVE ALT DEV. MODE
ZAPREA	EQ	0BE			:ZAP WITH REASON
SIIXM	EQ	0BF			:SIIX
TIIXM	EQ	0C0			:TIIX
UNUSNM  EQ      0C1                     :UNIVERSAL USER NUMBER

	GL	DRIVON
DRIVON  EQ      1               :0 IF SVC 6 NOT TO BE USED (FOR DEBUG PURPOSES)

:       DEFINE SEGMENTS DEDICATED TO S-BUS WINDOW AND BUFFER TYPES

        GL      WINDOW,BUF2SG,BUF3SG,BUF3SZ,BUF1SZ,WNDBAD
WINDOW  EQ      5               :SBUS WINDOW (MSG BLK, IOCBS, TYPE 1 BUFFERS)
WNDBAD  EQ      WINDOW*10000    :WINDOW BASE ADDRESS
BUF2SG  EQ      4               :BUFFER TYPE 2 IN SEGMENT 4
BUF3SG  EQ      3               :BUFFER TYPE 3 IN SEGMENT 3
BUF1SZ  EQ      $A 64
BUF3SZ  EQ      $A 10

:       TRANSMIT LIMIT DEFAULT
XMLDFL  EQ      9D

:	MAX NUMBER OF CYCLES THAT THE TASKS WILL PROCESS IN 1 BG CYCLE
RQSMXX	EQ	$A 10			:REQUEST STARTER TASK
SRDMXX	EQ	$A 10			:SERVICE REQUEST DONE TASK



:       ***** ETDEF MACRO *****

:       MACRO TO DEFINE EVENT TYPE, WHETHER OR NOT EVENT WILL BE TRACED IF
:       EVENT TRACING IS ENABLED, AND WHETHER OR NOT THE EVENT IS TIME-STAMPED.
:       AN EVENT CAN ALSO BE TRACED EVEN IF EVENT TRACING IS NOT ENABLED.
:       STRING = DESIGNATABLE 3-BYTE I.D. FOR THE EVENT
:       TRACE = 1 IF EVENT SHOULD BE TRACED, 0 IF NOT
:       TSTAMP = 1 IF EVENT TIME-STAMPED, 0 IF NOT
:       Q IS ASSIGNED AT ASSEMBLY-TIME
:       FOR EACH EVENT TYPE DEFINED, A CORRESPONDING EVENT PARAMETER TABLE
:       MUST BE DEFINED IN THE EVENT TRACE MODULE, ALONG WITH AN OUTPUT HEADER
:       STRING FOR EACH EVENT (SEE EVENT TRACE MODULE)

ETDEF   MACRO(STRING,TRACE,TSTAMP,Q)
[
Q       EQ      Q+1
        GL      ET.`STRING
ET.`STRING      EQ      Q       :ASSIGN EVENT TYPE NUMBER TO STRING
        GL      DB.`STRING
        IF      ENABTR		:EVENT TRACE ENABLE SWITCH SET IN TYMFILE
DB.`STRING      EQ      TRACE   :SET TRACING OF SPECIFIC EVENT ON OR OFF
        ELSE
DB.`STRING      EQ      0       :EVENT TRACE NOT ENABLED--OVERRIDES TRACE PARAM
        EI
        GL      TS.`STRING
TS.`STRING      EQ      TSTAMP  :SET TIME-STAMP ON OR OFF
]       

:       A CALL TO EVENT TRACE MODULE IS MADE VIA USE OF EVT MACRO (SEE 
:       BELOW).  ASSEMBLY OF THE EVT MACRO AT THE POINT OF EVENT TRACE
:       SHOULD BE CONDITIONAL UPON THE DEFINITION OF THE EVENT TYPE (EXCEPT
:       EVENTS THAT ARE TO BE TRACED WHETHER OR NOT EVENT TRACING IS ENABLED).
:       EXAMPLE FOR EVENT TO TRACE ONLY IF EVENT TRACING IS ENABLED.

:               IF      DB.GB1 
:               EVT(ET.GB1,TS.GB1,R1,R2,R3,R4)
:               EI

:       IF AN EVENT IS TO BE TRACED EVEN IF EVENT TRACING IS NOT ENABLED,
:       JUST USE THE EVT MACRO WITHOUT THE TEST OF WHETHER OR NOT THE
:       EVENT IS DEFINED 

:       DEFINE EVENT TYPES
Q       EQ      0
        ETDEF(IOQ,1,1,Q)        :FOREGROUND EVENT *** MUST BE FIRST!! ***
        ETDEF(SRQ,1,1,Q)
        ETDEF(GB1,1,1,Q)
        ETDEF(GB2,1,1,Q)
        ETDEF(GB3,1,1,Q)
        ETDEF(RB1,1,1,Q)
        ETDEF(RB2,1,1,Q)
        ETDEF(RB3,1,1,Q)
        ETDEF(ISD,1,1,Q)        :ISIS-DRIVER DETECTED ERROR
        ETDEF(RST,1,1,Q)        :RESET INTERFACE
        ETDEF(XRS,1,1,Q)        :XTRA RESET INTERFAC FROM SPR
        ETDEF(MSG,1,0,Q)
        ETDEF(TOP,1,1,Q)
        ETDEF(TOG,1,1,Q)
        ETDEF(BPO,1,1,Q)
        ETDEF(BPF,1,1,Q)
        ETDEF(ZB1,1,1,Q)
        ETDEF(ZB3,1,1,Q)
        ETDEF(FB2,1,1,Q)
        ETDEF(OPQ,1,1,Q)
        ETDEF(QBP,1,1,Q)
        GL      NEVTYP
NEVTYP  EQ      Q


        GL      EVTEMP,ETPARM,EVTRAC,EVTIZ,TRCING,FGEVTM
:       EVENT TRACE MACRO--PARAMETERS: 
:                          ETC=EVENT TRACE CODE
:			   TMSTMP=TIME-STAMP FLAG--0 IF NO TIME-STAMP
:                          M,N,O,P,Q=REGISTERS W/ DATA RELEVANT TO EVENT
EVT     MACRO(ETC,TMSTMP,M,N,O,P,Q)
[
        IF      ETC-ET.IOQ      :IF EVENT > 1 (ET.IOQ = FG JOB EVENT)
        STM     R0,EVTEMP,,
        ELSE
        STM     R0,FGEVTM,,     :SAVE FOREGROUND REGS.
        EI
        LH      R0,TRCING,,     :CHECK EVENT TRACE SWITCH
        JL      NOTR|ETC|       :IF -1, EVENT TRACING IS SWITCHED OFF
	IF	TMSTMP
	L	R7,FASTC,,
	ELSE
	LIS	R7,0
	EI
        LI      R9,ETC
	ST	M,ETPARM,,
	ST	N,ETPARM+4,,
	ST	O,ETPARM+8,,
	ST	P,ETPARM+0C,,
	ST	Q,ETPARM+10,,
        JAL     R6,EVTRAC,,
NOTR|ETC| EQ    .
        IF      ETC-ET.IOQ
        LM      R0,EVTEMP,,
        ELSE
        LM      R0,FGEVTM,,
        EI
]


:	***** RESET MACRO *****
:	MACRO TO SET MBASE RESET FLAG AND CALL CRASH
RESET	MACRO(REG,CC)
[
	TS	MBASRS,,
	JAL	R10,CRASH,,
	BC	0,0,REG*4,CC
]


:       MACRO FOR EXTENDED MEMORY USAGE

EXPMAC  MACRO[
Q       EQ      0
SEGSTR  EQ      0
        RE      5                                       :SEGS 0--4
        WC      (APROT|Q|^1C)!(0^18)!(((S|Q|SIZE-1)/100)^10)!SEGSTR
SEGSTR  EQ      SEGSTR+(((S|Q|SIZE+(PGSZ-1))&(@(PGSZ-1)))/100)
Q       EQ      Q+1
        ER
        WC      (APROT5^1C)!(3^18)!(0FF^10)!0           :SBUS WINDOW
        WC      0,0,0,0,0,0,0,0
        WC      (4^1C)!(1^18)!(((.-0E0000)/100)^10)!0   :SEG 0E
        WC      42040000                                :SEG 0F
        WC      MACPTR
        WS      2
]

        GL      MACPC,MACPTR
        SEG     A.CODE
MACPTR  WC      0
        WC      MACPC

:       LINK ON R13
:       SUBROUTINE TO SET-UP EXTENDED MAC USAGE
:       USED BY BACKGROUND, FOREGROUND, AND OPS. MONITOR

        GL      SETMAC
SETMAC  SVC     5,0
MACPC   JR      R13

  




	SUBTTL	STATUS.MBS . . . .DRIVER TO PROCESS COMMANDS UNDER "?STAT"

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

:       THIS IS AN ADAPTATION OF THE STADARD STATUS.LIB PACKAGE FOR MBASE

:       ?STAT commands implemented for Mbase:
:       TON -- EVENT TRACE ON
:       TOFF -- EVENT TRACE OFF
:       ET <number><delim> EVENT TRACE 
:           number = number of events to have displayed up to end of table
:       SET <number><delim> SPECIFIC EVENT TRACE
:            number = event trace number
:       PST <number|ALL><delim> DISPLAY PORT STATUS TABLES
:       IOCB <number|ALL><delim> DISPLAY IOCBs

  IF	1-\DB.STA			:DEFAULT DEBUG/STATUS TO ON
DB.STA	EQ	1
  EI

  IF	DB.STA				:ASSEMBLE ONLY WITH DEBUG STATUS ON

	SEG	A.CODE
	MO	.,STATUS
	RA	$00
	GL	DSTART,DAGAIN,DS.ELL,DS.ILL,DS.ERR,DS.DLM
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL

:	STATUS - User Command Handler
:
:	Version history:
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimeter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:		The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).

:		Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:	C/R	L/F	H/T	","	and BLANK.

:		Entry Points:
:	DAGAIN	Place to exit on completion of command.
:	DNEXTK  Get next token with out prompt.
:	DS.ILL	Place to exit on illegal command -- types "Illegal command"
:	DS.ERR	Place to exit on command error -- types "type '\' "
:	DS.EXI	Place to exit machine.
:	DS.QUI	Place to exit back to DDT.
:	DS.GCH	Get a character...Link on R1, char (with high-order bit forced)
:			in R0...normal return if detected ^W, skip-4 if detect
:			~A, aborts back to DAGAIN if detects ESC.
:	DS.DEL	Check for delimiter...Link on R2, Character in R0.  Skip-4
:			return unless this is a delimiter, then normal return.
:	DS.CUC	Convert to upper case...Link on R1, Character in R0.
:	DS.TOK	Get a string token...Link on R4, TOKEN returned in R3...
:			inputs up to 4 characters, returns them (in uppercase)
:			left justified, 0 fill
:	DS.NUM	Get a number...Link on R5, expects Radix in R4...
:			number returned in R0.  May ABORT if any character is
:			input other than valid digit or delimiter.
:	DS.DLM  Location of last delimeter entered (1 byte)

:		There are two built-in commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.

:		additional commands may be defined via the DS.CMD macro:
:	 DS.CMD(TEXT,ADDR)
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	DS.CMD generates a 12-byte discriptor for this command, at the point
:	assembly where it is invoked.  This discriptor is on a WORD boundary.



OUT	EQ	0B			:OUTPUT SVC
IN	EQ	0A			:INPUT SVC

DS.ELL	EQ	0			:NULL POINTER FOR END OF LINKED LIST

	SEG	A.DATA
DS.DLM	BS	1			:LAST DELIMETER ENCOUNTERED
R4SAV	WS	1			:SAVE AREA FOR R4 IN DS.TOK
EVCADR  WS	1			:ADDR OF EVENT TRACE CMD HNDLR
BADSTR	SC	/'xxxx'"8D"8A/		:PLACE TO PUT BAD COMMAND
	SEG	A.CODE

:	DEFINE ELEMENTS FOR COMMAND BLOCK
C.NEXT	EQ	0			:POINTER TO NEXT ENTRY
C.ADDR	EQ	C.NEXT+4		:POINTER TO COMMAND HANDLER
C.STR	EQ	C.ADDR+4		:RELATIVE POSITION OF STRING

:	DEFINE MACRO TO GENERATE THIS COMMAND BLOCK
DS.CMD	MACRO(STR,ADDR)[
   IF	DS.ELL
Q	WS	0
	ORG	DS.ELL
	WC	Q
	ORG	Q
   EI
DS.ELL	WC	0,ADDR
	AC	/STR/
	BND	4
]


:	TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST	WS	0			:FORCE TO WORD BOUNDARY
	DS.CMD(Q,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(QUIT,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(EXIT,DS.EXI)		:EXIT 
	DS.CMD(EXI,DS.EXI)		:EXIT 
	DS.CMD(TON,DS.TON)              :TURN EVENT TRACING ON
	DS.CMD(TOFF,DS.TOF)             :EVENT TRACING OFF
	DS.CMD(ET,DS.EVT)               :GET EVENT TRACE
	DS.CMD(SET,DS.SET)              :GET SPECIFIC EVENT TRACE
	DS.CMD(PST,DS.PST)              :DISPLAY PORT STATUS TABLE
	DS.CMD(IOCB,DS.CB)                :DISPLAY IOCB
	DS.CMD(PORTS,DS.POR)            :DISPLAY ATTACHED PORT NUMBERS
	DS.CMD(SELECT,DS.SEL)           :SELECT TRACE TABLE TO EXAMINE
	DS.CMD(HELP,DS.HLP)         
	DS.CMD(?,DS.HLP)
	DS.CMD(TYPES,DS.TYP)




:	DIAGNOSTIC MESSAGES
TERR	SC	/Illegal command /
TTERR	SC	/type '\'"8D"8A/
PROMPT	SC	/"8D"8A:>/		:"CR|LF:>"
BKSPAC	SC	/"88 "88/		:BACK SPACE
	SUBTTL	COMMAND SCANNER, VERIFIER, AND BITCHER

:       ENTRY POINT --- SET-UP EXTENDED MAC

DSTART  JAL     R13,SETMAC
        JFS     DAGAIN

:	COMMAND INPUT HANDLER
DOIT	L	R0,C.ADDR,R1		:GO SERVICE THIS COMMAND
        ST      R0,EVCADR               :SAVE CMD HANDLR ADDR
	JALR	R0,R0

:	NEXT COMMAND
DAGAIN	SVC	OUT,PROMPT		:ISSUE PROMPT
DNEXTK	JAL	R4,DS.TOK		:GET COMMAND TOKEN
	LA	R1,CMDLST		:SEARCH FOR STRING MATCH
DSTAR1	CL	R3,C.STR,R1
	JE	DOIT			:PROCEED IF FIND A MATCH
	L	R1,C.NEXT,R1		:ELSE CONTINUE SCAN
	JGBS	DSTAR1
DS.ILL	SVC	OUT,TERR		:"ILLEGAL COMMAND"
	ST	R3,BADSTR+2,,		:"XXX"<CR>
	SVC	OUT,BADSTR,,
DS.ERR	SVC	OUT,TTERR		:TELL USER TO TYPE FLUSH CHAR
BITCH	JAL	R1,DS.GCH		:FLUSH INPUT
	JBS	BITCH;	 NOPR	0			:^W...IGNOR
	JBS	BITCH;	 NOPR	0			:^A...IGNOR
	CLHI	R0,0DC			:READ UNTIL "\" IS FOUND
	JNBS	BITCH
	J	DAGAIN			:THEN EXIT


:	BUILT-IN COMMANDS

:		Command EXIt
:		===========-
DS.EXI	SVC	KIO,0			:DISCONNECT


:		Command Quit (exit back to DDT)
:		=========---
DS.QUI	SVC	KIO,1			:RETURN TO DDT
	J	DAGAIN			:IF OPERATOR TYPED "P", GET NEXT COMMAND
	SUBTTL	U T I L I T I E S

:	GET A COMMAND TOKEN...UP TO 4 CHARS LONG
:		SKIPS OVER EXTRA CHARACTERS TO NEXT DELIMITER
:	LINK ON R4
:	TOKEN RETURNED IN R3, LEFT JUSTIFIED
DS.TOK	HS	0
	ST	R4,R4SAV,,		:SAVE R4
TOKEN0	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	TOKEN0;	 NOPR	0			:^W...IGNORE
	JBS	TOKEN0;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:SKIP OVER DELIMITERS
	J	TOKEN0
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	CHI	R0,00DC			:= "\" ?
	JE	DAGAIN			:YES, PRINT PROMPT, GET NEXT COMMAND
	LBR	R3,R0			:SET UP STRING ACCUMULATOR (000000CC)
	LIS	R4,1			:1 CHAR. FOUND SO FAR
TOKEN	JAL	R1,DS.GCH		:GET ANOTHER CHAR
	J	TOKEN0			:^W...START OVER
	J	TOKEN3			:^A...TOSS LAST CHAR
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	J	TOKEN1			:GOT ONE...SKIP TO LEFT JUSTIFY IT
	CHI	R0,00DC			:= "\" ?
	JE	DS.ILL			:YES, TREAT AS ILLEGAL
	AIS	R4,1			:ONE MORE CHARACTER
	CHI	R4,4			:IF => 4 CHARS, DO NOT USE THIS ONE
	JG	TOKEN			:YES...SCAN FOR DELIMITER
	SLLS	R3,8			:NO...ACCUMULATE CHARS
	STBR	R0,R3
	J	TOKEN			:AND GET ANOTHER CHAR
TOKEN1	HS	0
	L	R4,R4SAV,,		:RESTORE R4
TOKEN2	TI	R3,0FF000000		:HAVE WE 4 CHARS ALREADY?
	JNR	R4			:YES...RETURN TOKEN IN R3
	SLLS	R3,8			:NO...JUSTIFY IT
	JBS	TOKEN2			:AND REPEAT

TOKEN3	HS	0			:HANDLE BACKSPACE IN TOKEN
	SIS	R4,1			:ONE LESS CHAR
	CHI	R4,4			:IF AFTER BACKSPACE TOKEN IS => 4
	JGE	TOKEN			: JUST DECRIMENT COUNTER
	SRLS	R3,8			:ELSE... DROP 1 CHARACTER
	J	TOKEN			:AND GET NEXT CHAR.

:	UTILITY ROUTINE TO READ A NUMBER
:	USES R0-R3
:	EXPECTS RADIX IN R4
:	LINK ON R5
:	ABORTS IF FIRST NON-DELIMITER IS NOT DIGIT
:	ELSE RETURNS NUMBER IN R0
DS.NUM	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	DS.NUM;	 NOPR	0			:^W...IGNORE
	JBS	DS.NUM;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER CHAR
	J	DS.NUM
	JAL	R2,DS.DIG		:TEST IF CHAR IS DIGIT
	J	DS.ILL			:NOT A DIGIT - GIVE ERROR MESSAGE
	CLR	R0,R4
	JGE	DS.ILL			:DIGIT IS BIGGER THAN RADIX...ABORT
	LR	R3,R0			:PUT FIRST DIGIT INTO ACCUMULATOR
NUMBER	JAL	R1,DS.GCH		:READ NEXT CHAR
	J	DS.NUM			:^W...START OVER
	J	DIVIDE			:^A...TOSS LAST DIGIT
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	LR	R0,R3;	 JR	R5	  :YES
	JAL	R2,DS.DIG		:SKIP IF DIGIT
	J	DS.ILL			:NO...ABORT
	CLR	R0,R4
	JGE	DS.ILL			:RADIX ERROR...BITCH
	MR	R2,R4			:BUILD NUMBER
	AR	R3,R0			:ADD NEW DIGIT
	J	NUMBER			:GET NEXT DIGIT
DIVIDE	LIS	R2,0			:GOT A ^A...MAKE DOUBLE-PRECISION ARG.
	DR	R2,R4			:QUOTENT INTO R3, WHERE WE WANT IT
	J	NUMBER			:NOW GO BACK FOR MORE DIGITS

:	DIGIT TEST
:	CHECK CHARACTER READ...SKIP RETURN IF DIGIT
:	THEN R0=BINARY VALUE OF HEX DIGIT
:	USES R1, LINK ON R2
DS.DIG	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	LR	R1,R0			:COPY CHAR
	SHI	R1,0B0			:IS IT "0"?
	JLR	R2			:RETURN IF LESS THAN "0"
	SIS	R1,0B9-0B0		:IS IF "9"
	JLEFS	DIGIT			:LESS THAN "9" THEN A GOOD DIGIT
	SIS	R1,0C1-0B9		:IS IT "A"?
	JLR	R2			:RETURN IF LESS THAN "A"
	SIS	R1,0C6-0C1		:IS IF "F"?
	JGR	R2			:RETURN IF GREATER THAN "F"
	SIS	R0,7			:0A - "A" (PARTIAL CONVERSION)
DIGIT	SHI	R0,0B0			:"0"
	J	4,R2			:SKIP RETURN

:	CHECK FOR DELIMITER
:	LINK	R2
:	USES	R0,R1
:	SKIP-4 RETURN UNLESS (R0) IS A DELIMITER CHARACTER
DS.DEL	LHI	R1,DLEN-1		:NUMBER OF DELIMITER CHARS
	STB	R0,DS.DLM,,		:SAVE DELIMITER
DELIM	CLB	R0,DLIST,R1		:COMPARE TO A DELIMITER
	JER	R2			:RETURN IF DELIMITER
	SIS	R1,1			:CHECK NEXT DELIMITER
	JGEBS	DELIM			:LOOP IF ANY MORE DELIMITERS
	J	4,R2			:SKIP RETURN
:	LIST OF DELIMITER CHARS
DLIST	AC	' ,'			:BLANK,","
	BC	8D,8A,89		:CR,LF,HT
DLEN	EQ	.-DLIST			:NUMBER OF DELIMITER CHARS

:	INPUT A CHARACTER
:	LINK	R1
:	NORMAL RETURN:  ^W INPUT...FLUSH ENTRY
:	SKIP-4 RETURN:  ^A or ^H INPUT...FLUSH LAST CHAR
:	SKIP-8 RETURN: CHAR IN R0 (HIGH-BIT ON)
:	ABORTS TO COMMAND SCANNER ON "ESC"
DS.GCH	SVC	IN,0F			:GET THE CHAR
	J	DS.GCH
	OHI	R0,80			:SET HIGH-ORDER BIT
	CLHI	R0,9B			:CHECK FOR ESCAPE
	 JE	DAGAIN			:ABORT, PROCEED WITH PROMPT IF SO
	CLHI	R0,97			:CHECK FOR ^W
	 JER	R1			:NORMAL RETURN
	CLHI	R0,81			:CHECK FOR ^A
	 JE	4,R1			:SKIP-4 RETURN
	CLHI	R0,88			:CHECK FOR ^H
	 JN	8,R1			:NO, SKIP-8 RETURN, CHAR IN R0

	SVC	OUT,BKSPAC		:BACK SPACE
	J	4,R1			:SKIP-4 RETURN FOR ^H

:	CONVERT CHAR IN (R0) TO UPPER CASE
:	LINK ON R1
DS.CUC	CLHI	R0,0E1			:COMPARE WITH "a"
	JLR	R1			:EXIT IF IT CAN'T BE LOWERCASE
	CLHI	R0,0FA			:COMPARE WITH "z"
	JGR	R1			:NOT LOWER CASE...JUST RETURN
	SHI	R0,20			:LOWER CASE...CONVERT TO UPPER
	JR	R1			:AND RETURN


:       ?STAT commands implemented for Mbase:
:       TON -- EVENT TRACE ON
:       TOFF -- EVENT TRACE OFF
:       ET <number><delim> EVENT TRACE 
:           number = number of events to have displayed up to end of table
:       SET <number><delim> SPECIFIC EVENT TRACE
:            number = event trace number
:       PST <number|ALL><delim> DISPLAY PORT STATUS TABLES
:       IOCB <number|ALL><delim> DISPLAY IOCBs

        GL      GETEVT,GETPST,GETCB,CRLFMG,IOCB0,GETACB
        GL      CASCII,CONBYT,ATCHDQ,PORT,ATCHNX,SNDBYT
        GL      PSTB0,PSTEND,PSTLEN,TRCING,IOCBLN,EVTCNT
        GL      EVNTBL,EVIXTB,SELETB,SELNXT,EVTBTB,CURVTB,EVNEXT
        GL      SELCNT,EVCNTB,INIXDT

        GL      WRAPED,IFWRAP,EVWRTB
        SEG     A.CODE

:	INITIALIZE EXTENDED DDT -- CALLED BY MBASE INITIALIZATION SUBROUTINE
INIXDT					
:       EVTRON SET IN TYMFILE TO -1 (EVENT TRACE OFF) OR 1 (ON)
        LHI     R0,EVTRON             
        STH     R0,TRCING
	JR	R13

DS.HLP  LA      R1,HLPMSG
DS.HL0  LB      R2,0,R1
        JE      DAGAIN
        SVC     K.OUT,0,R1
        AR      R1,R2
        AIS     R1,1
        JBS     DS.HL0

DS.TYP  LA      R1,TYPMSG
DS.TY0  LB      R2,0,R1
        JE      DAGAIN
        SVC     K.OUT,0,R1
        AR      R1,R2
        AIS     R1,1
        JBS     DS.TY0

DS.TON  LIS     R4,1                    :PUT A 1 IN 'TRCING'
        STH     R4,TRCING               :TURNS TRACING ON
        J       DAGAIN

DS.TOF  TS      TRCING                  :TURNS OFF TRACING
        J       DAGAIN

DS.EVT	SVC	K.OUT,EPRMP1		:SEND ET CMD PARAM PROMPT
	JAL	R4,DS.TOK		:GET PARAMTER TO ET CMD
	JAL	R4,CASCII		:CONVERT ASCII PARAM TO BINARY
	J	EVTILL			:ILILEGAL PARAMETER
        LHL     R7,CURVTB,,               :CURRENT TABLE REQUESTED?
        JE    DS.EV0                  :JUMP IF NOT
        LHL     R7,EVNEXT               :ELSE GET CURRENT IDX
        STH     R7,SELNXT,,
        LH      R7,WRAPED,,
        STH     R7,IFWRAP,,
        LHL     R7,EVTCNT,,
        STH     R7,SELCNT,,             :GET CURRENT COUNT
DS.EV0  JAL     R4,GETEVT
        J       DAGAIN

DS.SET  SVC     K.OUT,EPRMP2            :PRINT CMD PROMPT
        JAL     R4,DS.TOK               :GET PARAM TO SET CMD
        JAL     R4,CASCII               :CONVERT TO ASCII
        J       SETILL
        STH     R6,SPEVNT,,
        LHL     R6,EVTCNT,,             :SEARCH ALL STORED EVENTS
        LHL     R7,CURVTB,,               :CURRENT TABLE REQEUSTED?
        JE    DS.SE0                  :JUMP IF NOT
        LHL     R7,EVNEXT               :ELSE GET CURRENT IDX
        STH     R7,SELNXT,,
        LH      R7,WRAPED,,
        STH     R7,IFWRAP,,
        LHL     R7,EVTCNT,,
        STH     R7,SELCNT,,
DS.SE0  JAL     R4,GETEVT
        LIS     R4,0
        STH     R4,SPEVNT,,
        J       DAGAIN

DS.POR  JAL     R5,SHOWPS               :SHOW ATTACHED PORT NMBRS
        J       DAGAIN

DS.PST	SVC	K.OUT,PSTPRM		:DISPLAY PROMT
	JAL	R4,DS.TOK
        JAL     R4,CASCII               :CONVERT ASCII INPUT TO BINARY
        J       DS.PS4
DS.PS1	LA      R1,PSTB0,,              :GET PST FOR PORT 0
DS.PS3	CLB     R6,PORT,R1,             :R6=PORT NMBR--MATCH?
	JEFS	DS.PS2                  :YES, GO GET PST INFO
        AHI     R1,PSTLEN               :GET NEXT PST
        CLI     R1,PSTEND
	JE	PSILL1
	JBS	DS.PS3
DS.PS2	JAL	R4,GETPST
	J	DAGAIN

DS.PS4  CLHI    R2,0C1                  :"A"?--'ALL'?
        JN      PSTILL
      	L	R1,ATCHDQ
        JE      DAGAIN
DS.PA0	JAL	R4,GETPST
	L	R1,ATCHNX,R10,		:GET NEXT ON QUEUE
	JNBS	DS.PA0
	J	DAGAIN

DS.SEL	SVC	K.OUT,SELPRM
	JAL	R4,DS.TOK
	JAL	R4,CASCII
	J	SELIL1
	LR	R6,R6
	JNFS	DS.SL1
      	L	R2,EVNTBL
	ST	R2,SELETB,,
        TS      CURVTB,,
	J	DAGAIN

:	FIRST FIND LOCATION IN EVTBTB TABLE OF CURRENT TABLE

DS.SL1	CLHI	R6,NEVTBL		:ASKING FOR MORE THAN WE GOT?
	JGE	SELIL2			:YES, TELL HIM ABOUT IT
	L	R2,EVNTBL
	LIS	R1,0
DS.SL0	CLH	R2,EVTBTB,R1,R1
	JEFS	DS.SL2
	AIS	R1,1
	JBS	DS.SL0

DS.SL2	LR	R3,R1			:COPY IDX 
        LIS     R4,0                    :INIT COUNTER
DS.SL3	CR	R6,R4			:MATCHES REQUESTED TABLE?
	JEFS	DS.SL4			:YES, JUMP
        AIS     R4,1
	SIS	R1,1
	JGEBS	DS.SL3
	LHI	R1,NEVTBL-1
	JBS	DS.SL3

DS.SL4	LH	R2,EVTBTB,R1,R1
        JL      SLNONO                  :IF HI-ORDER BIT SET, THIS TABLE...
                                        :HASN'T BEEN USED YET
	ST	R2,SELETB,,		:SAVE SELECTED TABLE ADDR 
        LR      R4,R4                   :WANT CURRENT TBL?
        JNFS    DS.SL5                  :JUMP IF NOT
        TS      CURVTB,,                  :ELSE SET FLAG TO GET CURRENT CNT
        J       DAGAIN  
DS.SL5  LHL     R2,EVIXTB,R1,R1
        STH     R2,SELNXT,,
        LHL     R2,EVWRTB,R1,R1
        STH     R2,IFWRAP,,
        LHL     R2,EVCNTB,R1,R1
        STH     R2,SELCNT,,
        LIS     R2,0
        STH     R2,CURVTB,,
	J	DAGAIN

DS.CB 	SVC	K.OUT,CBPRMT		:DISPLAY PROMT
	JAL	R4,DS.TOK
        JAL     R4,CASCII               :CONVERT ASCII INPUT TO BINARY
        J       DS.CBA

        LI      R10,IOCB0
        LIS     R11,0
DS.CB0  CR      R6,R11
        JEFS    DS.CB1
        AHI     R10,IOCBLN
        AIS     R11,1
        CLHI    R11,NIOCB
        JE      CBILL0
        JBS     DS.CB0
DS.CB1  EQ      .
        JAL     R4,GETCB
        J       DAGAIN

DS.CBA  CLHI    R2,0C1                  :"A"?--'ALL'?
        JN      CBILL1
        JAL     R5,GETACB               :GET ALL ACTIVE (ATTACHED) IOCBS
        J       DAGAIN

SHOWPS  LIS     R4,0
        L       R10,ATCHDQ
        JE      SHOWP0
SHOWP1  LB      R2,PORT,R10,
        JAL     R3,SNDBYT
        SVC     K.OUT,TWOSPA,,
        AIS     R4,1
        CLHI    R4,0A
        JNFS    SHOWP2
        LIS     R4,0
        SVC     K.OUT,CRLFMG,,
SHOWP2  L       R10,ATCHNX,R10,
        JN      SHOWP1
        JR      R5
SHOWP0  SVC     K.OUT,NSHOWP
        JR      R5

CASCII  EQ      .
      	LIS	R8,1
	LIS	R1,0
	LIS	R2,0
	LIS	R6,0
CASCI0	STBR	R3,R2			:DS.TOK LEFT-JUSTIFIES INPUT BYTES
	JEFS	CASCI1
	JAL	R5,CONBYT		:CONVERT THIS BYTE TO BINARY
        JR      R4                      :NORMAL RETURN--NOT A DIGIT
CASCI1	AIS	R1,1 			:INCREMENT
	CHI	R1,4
	JE	4,R4			:DONE
	SRLS	R3,8			:SHIFT TO NEXT BYTE
	JBS	CASCI0
	
	SEG	A.DATA
        GL      SPEVNT
	BND	4
SPEVNT  HS      1
	SEG	A.CODE
TWOSPA  SC      /  /
NSHOWP  SC      /NO ACTIVE PORTS"8D"8A/
ETERR	SC	/?Enter # of events to be displayed up to current end of table"8D"8A/
SETERR  SC	/?Enter event type"8D"8A/
PSTERR  SC	/?Enter Port Status Table number or A (All active PSTs)"8D"8A/
PSERR1  SC	/?Invalid pst number"8D"8A/
CBERR1  SC	/?Enter IOCB number or A (All active IOCBs"8D"8A/
CBERR0  SC	/?Max IOCB = decimal 253"8D"8A/
SELMS1  SC	/?Enter 0 for current, 1 for previous, up to (NEVTBLS-1) for oldest table"8D"8A/
SELMS2  SC      /?Requested number greater than number of event tables minus one"8D"8A/
SELMS3  SC      /This trace table not yet used"8D"8A/
NOTAMG  SC      /Port not attached"8D"8A/
EPRMP1	SC	/HOW MANY EVENTS?>/
EPRMP2	SC	/EVENT TYPE?>/
PSTPRM	SC	/WHICH PST?>/
CBPRMT	SC	/WHICH IOCB?>/
SELPRM	SC	/WHICH TABLE?>/
HLPMSG  SC      /Mbase Operations Monitor Commands:"8D"8A/
	SC	/  DIR [a]    -- Display Iring -- display iring msgs, starting..."8D"8A/
	SC	/                 ...at iring+4 (default) or iring addr <a>"8D"8A/
	SC	/  DOR [a]    -- Display Oring -- display oring msgs, starting..."8D"8A/
	SC	/                 ...at oring+4 (default) or oring addr <a>"8D"8A/
	SC	/  DR         -- Display Iring and Oring messages"8D"8A/
        SC      /  ET <n>     -- Event Trace -- display n trace events"8D"8A/
        SC      /  EXI        -- Exit"8D"8A/
        SC      /  EXIT       -- Exit"8D"8A/
        SC      /  IOCB <n>   -- Display IOCB n"8D"8A/
        SC      /  PORTs      -- Display attached port numbers"8D"8A/
        SC      /  PST <n|A>  -- Display Port Status Table n, or All attached ports"8D"8A/
        SC      /  Q          -- Quit"8D"8A/
        SC      /  QUIT       -- Quit"8D"8A/
        SC      /  SELECT <n> -- Select a trace table to examine <[0..n]>..."8D"8A/
        SC      /                 ...where 0 = current table, n = oldest table (NEVTBL-1)"8D"8A/
        SC      /  SET <n>    -- Select Event Type <n> -- Display all instances of event type n"8D"8A/
	SC	/  TOFF       -- Tracing off -- Turns off tracing of all events"8D"8A/
	SC	/  TON        -- Tracing on -- Turns event tracing on"8D"8A/
        SC      /  TYPES      -- Types -- Display Event types"8D"8A/
        BC      0

TYPMSG  SC      /Event types -- number -- event description"8D"8A/
        SC      /                 01      SIO-HIO Request"8D"8A/
        SC      /                 02      Service Request enqueued"8D"8A/
        SC      /                 03      Get Buffer (S-bus buffer)"8D"8A/
        SC      /                 04      Get Buffer (SRB buffer)"8D"8A/
        SC      /                 05      Get Buffer (small buffer)"8D"8A/
        SC      /                 06      Return Buffer (S-bus buffer)"8D"8A/
        SC      /                 07      Return Buffer (SRB buffer) "8D"8A/
        SC      /                 08      Return Buffer (small buffer) "8D"8A/
        SC      /                 09      ISIS Driver-detected error"8D"8A/
        SC      /                 0A      Reset Interface"8D"8A/
        SC      /                 0B      Extra reset interface"8D"8A/
        SC      /                 0C      Unrecognized ISIS msg"8D"8A/
        SC      /                 0D      Timeout block put on timeout queue"8D"8A/
        SC      /                 0E      Timeout canceled"8D"8A/
        SC      /                 0F      Mbase set backpressure request"8D"8A/
        SC      /                 10      Mbase release backpressure requeset"8D"8A/
        SC      /                 11      Zap buffer (S-bus buffer)"8D"8A/
        SC      /                 12      Zap buffer (SRB)"8D"8A/
        SC      /                 13      Zap buffer (small)"8D"8A/
        SC      /                 14      Free-up SRB buffer"8D"8A/
        SC      /                 15      Get next PST on output queue"8D"8A/
        SC      /                 16      Enqueue PST & buffer for output"8D"8A/
        BC      0


CONBYT  CLHI    R2,0B0
        JLR     R5                      :NOT A DIGIT, START OVER
        CLHI    R2,0B9          
        JGR     R5                      :NOT A DIGIT, START OVER
	NHI	R2,0F			:GET RID OF 30
	LR	R9,R8			:SAVE R8 VALUE
	LIS	R7,0			:SET UP MR OPERATION
	MR	R7,R2			:MULT DIGIT BY POWER OF 10 VALU IN R8
	AR	R6,R8			:R8 CONTAINS RESULT OF MR OP
	LHI	R2,0A
	LR	R8,R9			:GET ORIG. R8 VALU BACK
	MR	R7,R2			:GET NEXT POWER OF 10
        J       4,R5

SETILL  SVC     K.OUT,SETERR
        SVC     K.OUT,TTERR
        J       UNTLDC

PSILL1  SVC     K.OUT,PSERR1
        J       DAGAIN

PSTILL  SVC     K.OUT,PSTERR
        SVC     K.OUT,TTERR
        J       UNTLDC

CBILL1  SVC     K.OUT,CBERR1
        SVC     K.OUT,TTERR
        J       UNTLDC

CBILL0  SVC     K.OUT,CBERR0
        SVC     K.OUT,TTERR
        J       UNTLDC

SELIL1  SVC     K.OUT,SELMS1
        SVC     K.OUT,TTERR
        J       UNTLDC

SELIL2  SVC     K.OUT,SELMS2
        SVC     K.OUT,SELMS1
        J       DS.SEL
SLNONO  SVC     K.OUT,SELMS3
        J       DAGAIN

EVTILL	SVC	K.OUT,ETERR
	SVC	K.OUT,TTERR
UNTLDC	JAL	R1,DS.GCH
	JBS	UNTLDC
	NOPR	0
	JBS	UNTLDC
	NOPR	0
	CLHI	R0,0DC
	JNBS	UNTLDC
        L       R0,EVCADR
        JALR    R0,R0


  EI    :(DB.STA)
 
	SUBTTL	EXTENDED DDT MODULES - ISIS RING INTERPRETER
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	ISIS RING INTERPERTER					::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::								::
::	This package will decode ISIS dispatcher rings and	::
::	display them on a DDT port.  Messages thas may contain	::
::	meaningful ASCII text (data, needles, and 1DOWN) are	::
::	displayed in hex and ASCII.  All other messages are	::
::	displayed only in hex.					::
::								::
::	Requirments:						::
::		This code requires ISIS-II version 5 (or above)	::
::		and the STAT.LIB library.  It uses the message	::
::		length tables in segment F (15d) in ISIS.	::
::								::
::	Commands:						::
::		This package includes 2 commands.  With this	::
::		set of commands you may examine rings that	::
::		have, and have not wrapped.  Also any output	::
::		from these commands may be terminated by typing	::
::		any character ("\" is recomended).  All 	::
::		commands may be followed by an optional number.	::
::		This number represents the number of seconds	::
::		to wait looking for new ring activity.  This	::
::		may beused to observe rings for N seconds, in	::
::		'real time'.					::
::								::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:
LENGTH	EQ	0F0028		:SEG E AND SEG F DATA AREAS
LP0LST	EQ	0F0026
NPORTS	EQ	0E0082
IRINGP	EQ	0E0068		:CONTAINS START OF INPUT RING
ORINGP	EQ	0E006C		:CONTAINS START OF OUTPUT RING
IMAXI	EQ	0E0084		:CONTAINS INPUT RING SIZE (HALFWORD)
OMAXI	EQ	0E0086		:CONTAINS OUTPUT RING SIZE (HALFWORD)
RING	EQ	4		:4 BYTES PAST 1ST POINTER IS RING
NFMI	EQ	0		:FILL POINTER

        SEG     A.DATA
XDIIND  HS      1               :INPUT INDEX
XDOIND  HS      1               :OUTPUT INDEX

	SEG	A.CODE

:********************************
:
:  DISPLAY INPUT RING
:
:********************************
	DS.CMD(DIR,XDIR)		:DISPATCHER INPUT RING
:
XDIR
        JAL     R14,XDRPRI      :GET PARAMETERS
        SVC     0B,XDCRLF
XDIRLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DAGAIN          :DONE
        JAL     R14,XDRDIR      :INPUT RING
        SVC     DISMISS,0
        J       XDIRLP

:*******************************
:
:  DISPLAY OUTPUT RING
:
:*******************************
	DS.CMD(DOR,XDOR)		:DISPATCHER OUTPUT RING
:
XDOR
        JAL     R14,XDRPRO      :GET PARAMETERS
        SVC     0B,XDCRLF
XDORLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DAGAIN          :DONE
        JAL     R14,XDRDOR      :OUTPUT RINNG
        SVC     DISMISS,0
        J       XDORLP

:*******************************
:
:  DISPLAY BOTH INPUT AND OUTPUT RINGS
:
:*******************************
	DS.CMD(DR,XDR)		        :WRAPPED DISP OUTPUT RING
:
XDR
        LIS     R0,0
        STH     R0,XDIIND
        STH     R0,XDOIND
        SVC     0B,XDCRLF
XDRLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DAGAIN          :DONE
        JAL     R14,XDRDOR      :OUTPUT RING FIRST
        JAL     R14,XDRDIR      :INPUT RING
        SVC     DISMISS,0
        J       XDRLP


:
:	DUMP I/O RINGS
:
RR	EQ	8		:REGISTER ADDRESS OF RING
RS	EQ	9		:REGISTER RING SIZE

:	R0  - SCRATCH
:	R1  - INDEX INTO RING
:	R10 - LINK TO SUBROUTINES
:	R12 - FLAG FOR PRINTING/NOT PRINTING
:
XDRDIR
        LA	RR,IRING,,	:HANDLE IRING
	LHI	RS,IRSIZE	:RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDIIND
        CLR     R0,R1
        JER     R14
:
        LHI     R0,0049         : I
        STB     R0,XRNG+1
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDIW
        SR      R1,RS
XDRDIW
        SVC     0B,XDCRLF
        STH     R1,XDIIND       :UPDATE OUTPUT INDEX
        JR      R14

:*******************************
:
: OUTPUT RING
:
:*******************************
XDRDOR
        LA	RR,ORING,,	:HANDLE ORING
	LHI	RS,ORSIZE	:RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDOIND
        CLR     R0,R1
        JER     R14             :EXIT
:
        LHI     R0,4F           : O
        STB     R0,XRNG+1
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDOW
        SR      R1,RS
XDRDOW
        SVC     0B,XDCRLF       :OUTPUT CRLF
        STH     R1,XDOIND       :OUTPUT INDEX
        JR      R14

:*******************************
:
: KYBD CHECK
:
:*******************************
XDRKBD
        SVC     K.IN,0          :TEST KYBD INPUT
        J       XDRKBE          :NONE, SO NORMAL RETURN
:
        JR      R14
XDRKBE
        AIS     R14,4           :NORMAL "SKIP" RETURN
        JR      R14             :NORMAL EXIT

:*******************************
:
: GET PARAMETERS
:
:*******************************
XDRPRI
        LIS     R0,0            :START AT ZERO
	LHI	R1,008D		:GET A <CR>
	CLB	R1,DS.DLM,,	:DELIMETER CHAR = <CR> ?
	JE  	XDRPI0		:YES, START AT BEGINNING
:
	LHI	R4,10   	:SET RADIX TO HEX
	JAL	R5,DS.NUM,,	:GET A NUMBER (IN R0)
:
        LA      RR,IRING+4,,      :GET START ADDRESS
        CLR     R0,RR           :COMPARE
        JL      DS.ALOW
:
        AI      RR,IRSIZE       :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,IRING+4      :GENERATE START ADDRESS
        NHI     R0,0FFFC        :ALIGN TO WORD
XDRPI0
        STH     R0,XDIIND       :IRING INDEX
        JR      R14

:*******************************
:
: GET PARAMETERS
:
:*******************************
XDRPRO
        LIS     R0,0            :START AT ZERO
	LHI	R1,008D		:GET A <CR>
	CLB	R1,DS.DLM,,	:DELIMETER CHAR = <CR> ?
	JE  	XDRPO0		:YES, START AT BEGINNING
:
	LHI	R4,10   	:SET RADIX TO HEX
	JAL	R5,DS.NUM,,	:GET A NUMBER (IN R0)
:
        LA      RR,ORING+4,,    :GET START ADDRESS
        CLR     R0,RR           :COMPARE
        JL      DS.ALOW
:
        AI      RR,ORSIZE       :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,ORING+4      :GENERATE START ADDRESS
        NHI     R0,0FFFC        :ALIGN TO WORD
XDRPO0
        STH     R0,XDOIND       :ORING INDEX
        JR      R14

:
:  ERROR ROUTINE
:
DS.ALOW
        SVC     OUT,ADRLOW
        J       DS.ERR,,
:
DS.AHI
        SVC     OUT,ADRHI
        J       DS.ERR,,

ADRLOW  SC      /Address too low"8D"8A/
ADRHI   SC      /Address too high"8D"8A/

:********************************
:
:  PROCESS ISIS MESSAGE
:
:  R1           RING INDEX
:  R8 (RR)      RING START ADDRESS
:  R9 (RS)      RING SIZE
:  R13          LINK
:
:********************************
XDRISM	LB	R2,RING+2,R1,RR	:GET MESSAGE CODE
	LHL	R3,RING,R1,RR	:GET PORT #
	JNFS	XDR0A3		:JUMP IF INTERNODE MSG
	CHI	R2,10		:VALID INTRANODE MSG?
	JGFS	XDR0A4		:NO...CHECK NEXT WORD
	J	XDR0C0		:YES...GO HANDLE IT
:	CHECK FOR A VALID PORT #, KEEP INCRIMENTING TIL FOUND
XDR0A3	CLH	R3,NPORTS,,	:TEST AGAINST MAX PORT #
	JLEFS	XDR0A5		:OK, CONTINUE
:
XDR0A4	AIS	R1,4		:MOVE TO NEXT POSSIBLE PORT
	J	XDRISM		:LOOP LOOKING FOR A VALID PORT #
:	PORT NUMBER IS VALID
XDR0A5	LIS	R12,1		:DEFAULT PRINTING ON <*>
	LR	R2,R2		:CHECK FOR NEEDLE
	JE	XDR0F0		:IF SO
:
	CLHI	R2,9E		:DATA MESSAGE ??
	JL	XDR0B0		:IF SO
:
	JAL	R10,XPRADD	:PRINT ADDRESS
	SHI	R2,9E		:BIAS TO 0
	LA	R4,,R2,R2	:FOR INDEXING
	SVC	0B,XDRICA,R4,R4	:ASCII MESSAGE LABEL
	LIS	R12,0		:DO NOT PRINT ISIS CONTROL MESSAGES IN ASCII <*>
	JAL	R10,XDRISB	:GO DUMP ISIS CONTROL MESSAGE
        JR      R13             :RETURN

:
:  DATA MESSAGE
:
XDR0B0
	JAL	R10,XPRADD	:PRINT ADDRESS
	SVC	0B,XDRMS3,,	:"DATA" MESSAGE HEADER
	JAL	R10,XDRISA	:GO DUMP ISIS DATA MSG
        JR      R13             :RETURN

:
: PORT 0 INTRANODE MESSAGE
:
XDR0C0
	JAL	R10,XPRADD	:PRINT ADDRESS
	LA	R4,,R2,R2	:FOR INDEXING
	SVC	0B,XDRICB,R4,R4	:ASCII MESSAGE LABEL
	TBT	R2,XDRVL,,	:VARIABLE LENGTH MESSAGE ??
	JNFS	XDR0D0		:IF SO BECAUSE CAN'T HANDLE YET
	LIS	R12,0		:DO NOT PRINT CONTROL MESSAGE <*>
	JAL	R10,XDRISC	:GO DUMP ISIS INTRANODE MESSAGE
        JR      R13             :RETURN
XDR0D0	LIS	R12,1		:<*> SET TO PRINT
	CLHI	R2,8		:AUX CIRCUIT REQUEST ??
	JN	XDR0E0		:MUST BE "1-DOWN"
	LA	R4,0A,R1	:STEP TO SIZE BYTE
	CR	R4,RS		:CHECK FOR WRAP AROUND
	JLFS	XDR0D4		:IF NOT
	SR	R4,RS		:IF SO
XDR0D4	LB	R6,RING,RR,R4	:GET VARIABLE STRING SIZE
	AIS	R6,0B		:ADD CONSTANT PORTION
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E
	JAL	R10,XDRISE,,	:TO PUT OUT MESSAGE
        JR      R13             :RETURN
XDR0E0	LA	R4,5,R1		:STEP TO 1-DOWN STRING SIZE
	CLHI	R4,RS		:CHECK FOR WRAP AROUND
	JLFS	XDR0E4		:IF NOT
	SHI	R4,RS		:IF SO
XDR0E4	LB	R6,RING,RR,R4	:GET VARIABLE MESSAGE SIZE
	AIS	R6,6		:ADD FIXED MESSAGE LENGTH
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E
	JAL	R10,XDRISE,,	:TO PUT OUT MESSAGE
        JR      R13             :RETURN

:
:  NEEDLE
:
XDR0F0
	JAL	R10,XPRADD	:PRINT ADDRESS
	SVC	0B,XDRMS4,,	:NEEDLE MESSAGE
	LB	R6,RING+3,R1,RR	:GET ADDITIONAL LENGTH
	AIS	R6,4		:ADD FIXED PORTION
	LHI	R0,20		:INSERT A BLANK
	SVC	KIO,0E		:PUT IT OUT
	JAL	R10,XDRISE,,	:TO PUT REST OF MESSAGE
        JR      R13             :RETURN

:
: TEST LOWER CASE, MAKE UPPER CASE IF TRUE
:
CAPIT	TBT	R0,CAPITT,,	:TEST FOR LOWER CASE CHARACTER
	JER	R1		:IF NOT
	SHI	R0,20		:ADJUST TO CAPITALIZE
	JR	R1		:RETURN


:	R1 - RING INDEX
:	R2 - MSG CODE TYPE
:	R3 - PORT #
:	R4 - SCRATCH
:	R5 - BYTE TO OUTPUT
:	R6 - SCRATCH
:	R7 - LINE LENGTH COUNTER
:	RS - RING SIZE  (R8)
:	RR - RING START (R9)
:	R10- LINK TO HERE
:	R11- LINK TO XDPUT

:	DATA MESSAGE
XDRISA	LA	R6,3,R2		:MESSAGE LENGTH=MESSAGE TYPE+3
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E		:LETS BE TIDY
	J	XDRISE,,,
:	CONTROL MESSAGE
XDRISB	LB	R6,LENGTH+9E,R2,:MESSAGE LENGTH FROM TABLE (IN SEG F)
	AIS	R6,2
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E
	J	XDRISE,,,
:	INTRANODE MESSAGE TYPE
XDRISC	LHL	R6,LP0LST,,	:SEG F HAS THIS TOO
	LB	R6,NRATE,R6,R2,	:MESSAGE LENGTH FROM TABLE
	AIS	R6,2
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E
	J       XDRISE
XDRISD	HS	0
	SVC	0B,XDRASC,,	:ASCII EQUIVALENT OF LINE
	SVC	0B,XDCRLF,,	:NEW LINE
	ST	R10,SAVR10,,
	JAL	R10,XPRADD	:PRINT ADDRESS :*:
	L	R10,SAVR10,,
	SVC	0B,XDRMS5,,	:4 BLANKS FOR ALIGNMENT
XDRISE	LIS	R7,0		:LINE LENGTH COUNTER
XDRISF	LB	R0,RING,R1,RR	:NEXT BYTE FROM RING
	LR	R5,R0		:SAVE A GOOD COPY OF IT
	NHI	R0,7F		:IGNORE MSB
	TBT	R0,XDRECH,,	:PRINTABLE ??
	JNFS	XDRISH		:YES, GET ORIG. BYTE BACK
	LHI	R0,2E		:DEFAULT "." CHARACTER
	JFS	XDRISH+2	:SET CHAR TO "."
XDRISH	LR	R0,R5		:ELSE IF OK TO PRINT IT
:XDRISH+2
	LR	R4,R7		:COMPUTE WHERE TO PLUG INTO LINE
	NHI	R4,0F		:16 BYTES PER LINE
	STB	R0,XDRASC+4,R4,,:PUT 'ER THERE
	JAL	R11,XDPUT,,	:PUT IT OUT
	AIS	R1,1		:BUMP RING INDEX
	CR	R1,RS		:END OF RING ??
	JLFS	XDRISG		:IF NOT
	SR	R1,RS		:FOLD TO RING START
XDRISG	AIS	R7,1		:LINE LENGTH
	SIS	R6,1		:CHECK FOR END OF MSG
	JLE	XDRISI		:FINISH BLANKING AND PRINT	
	THI	R7,0F		:END OF LINE
	JE	XDRISD		:IF SO
	THI	R7,1		:END OF HALFWORD
	JN	XDRISF		:IF NOT TO CONTINUE
	LHI	R0,20		:ADD A SPACE
	SVC	KIO,0E		:TO FORMAT WORDS
	J	XDRISF
XDRISI	LHI	R0,20		:BLANK
	LR	R12,R12		:PRINT DATA ? (1=YES)
	JER	R10		:NO, RETURN
XDRISJ	NHI	R7,0F		:LINE LENGTH OF 16
	JEFS	XDRISK		:IF TO END OF LINE
	STB	R0,XDRASC+4,R7,,:PUT IN A BLANK
	SVC	0B,XD2BLK,,	:PRINT 2 BLANKS TO ALLIGN DATA
	THI	R7,1		:ODD ?
	JNFS	XDRISL		:YES, DO NOT PRINT BLANK
	SVC	KIO,0E		:PRINT A BLANK (REG 0)
XDRISL	HS	0
	AIS	R7,1		:COUNT ON UP
	JBS	XDRISJ		:AND SEE IF DONE
XDRISK	SVC	0B,XDRASC,,	:YES, PUT IT OUT
	JR	R10		:DONE



:	R0 USED BY SVC FOR OUTPUT CHARACTER
:	R1-R3 SAVED
:	R4 DESTROYED
:	R5 BYTE TO BE OUTPUT
:	R11 LINK
XDPUT	LBR	4,5		:COPY IT
	SRHLS	4,4		:LEFT NIBBLE
	LB	0,SIAASC,4,	:CONVERT TO ASCII ("0" TO "F")
	SVC	KIO,0E		:PUT IT OUT TO TTY
	NHI	5,0F		:RIGHT NIBBLE
	LB	0,SIAASC,5,	:CONVERT TO ASCII ("0" TO "F")
	SVC	KIO,0E		:PUT IT OUT TO TTY
	JR	R11		:RETURN
:
:	WRITE ADDRESS AT START OF DATA/MESSAGE/NEEDLE LINE
:
:	R10 - LINK TO THIS ROUTING
:	ALL OTHERS PRESERVED!
:
XPRADD
	STM	R0,XDSAV,,
        SVC     0B,XRNG
	LA	R0,RING,R1,RR		:GET ADDR OF THIS MESSAGE
	LHI	R1,0530
	SVC	KIO,$A10
	LHI	R0,0020			:PRINT BLANK
	SVC	KIO,$A14
	LM	R0,XDSAV,,
	JR	R10

	SUBTTL	ISIS RING INTERPRETER (DATA AREAS)
	SEG	0
XDRSS0	HS	0
XDRPLU	SC	/"8D"8A"2B/		:<CR>, <LF>, "+"
SIAASC	AC	/0123456789ABCDEF/
CAPITT	HC	0,0,0,0,0,0,7FFF,0FFE0
XDRECH	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDCRLF	SC	/"8D"8A/	:<CR>, <LF>
XD2BLK	SC	/  /		:TWO BLANKS
XDRVL	HC	0082,0000	:VARIABLE LENGTH MESSAGE FLAGS
XDRMS5	SC	/    /
XDRMS4	SC	/NDL/		:NEEDLE
XDRMS3	SC	/DAT/		:DATA
XDRASC	SC	/  |                |/
XDRCEI	HS	1		:OUR CEI
XRNG    SC      /  /
XDSAV	HS	2*10		:REG SAVE AREA
SAVR10	HS	2		:REG 10 SAVE AREA

:	ISIS CONTROL MESSAGES
XDRICA	HS	0
	SC	/DET/	:DETACH MESSAGE TYPE
	SC	/ZAP/	:DISCONNECT MESSAGE
	SC	/NOS/	:APPLY BACK-PRESSURE (NO SEND)
	SC	/SND/	:RELEASE BACK-PRESSURE (SEND)
	SC	/ICM/	:FLUSH OUTPUT (GOBBLER)
	SC	/BKG/	:FLUSH INPUT (BACK GOBBLER)
	SC	/BLK/	:DATA LOST IN THIS DIRECTION (BLACK BALL)
	SC	/GRY/	:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	SC	/EDE/	:ENTER DEFERED ECHO MESSAGE
	SC	/LDE/	:LEAVE DEFERED ECHO MESSAGE
	SC	/ETM/	:ENTER TRANSPARENCY MODE
	SC	/LTM/	:LEAVE TRANSPARENCY MODE
	SC	/GB /	:GREEN BALL
	SC	/RB /	:RED BALL
	SC	/YB /	:YELLOW BALL
	SC	/OB /	:ORANGE BALL
	SC	/BRK/	:BREAK DETECTED
	SC	/HNG/	:HANG UP
	SC	/QTP/	:QUERY TERMINAL PARAMETER
	SC	/STP/	:SET TERMINAL PARAMETER
	SC	/PSN/	:PSEUDO NEEDLE
	SC	/NLC/	:NORMAL LOGON CHAR
	SC	/NLS/	:NORMAL LOGON STATUS
	SC	/LOF/	:LOG ON FAILURE
	SC	/NCC/	:NORMAL CIRCUIT COMPLETE
	SC	/ADA/	:ADDENDUM TO ACCOUNTING
	SC	/SHG/	:SUPER-HANG UP
	SC	/TLM/	:SET TRANSMIT LIMIT
	SC	/EBK/	:END OF BREAK
	SC	/ZAK/	:ZAP ACK
	SC	/EAD/	:ENTER ALTERNATE OUTPUT DEVICE MODE
	SC	/LAD/	:LEAVE ALTERNATE OUTPUT DEVICE MODE
	SC	/ZAR/	:ZAP WITH REASON
	SC	/SIX/	:START INTERFACE INFORMATION EXCHANGE
	SC	/TIX/	:TERMINATE INTERFACE INFORMATION EXCHANGE

:	INTRA NODE MESSAGES
:	-------------------

XDRICB	HS	0
	SC	/RQR/	:RESTART REQUEST
	SC	/RST/	:RESTART INTERFACE
	SC	/NTO/	:NODE HAS BEEN TAKEN OVER
	SC	/REP/	:REPORT TO SUPERVISOR'S LOG
	SC	/RHS/	:REPORT HOST STATUS (OBSOLETE)
	SC	/RAC/	:REPORT ACCOUNTING
	SC	/TIM/	:GMT TIME
	SC	/RNP/	:REQUEST FOR NORMAL PSEUDO NEEDLE
	SC	/RAP/	:REQUEST AUX PSEUDO-NEEDLE
	SC	/PSR/	:PSEUDO-NEEDLE REJECTED
	SC	/HPA/	:HOST PORT AVAILABILITY
	SC	/HNA/	:HOST NOT ACCEPTABLE
	SC	/RHC/	:REPORT HOST COST
	SC	/NSU/	:NO SUPERVISOR
	SC	/ODN/	:1-DOWN TEXT
	SC	/RAH/	:REPORT ALL HOSTS
	SC	/HSR/	:HOST STATUS REPORT
:
        EM
   : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : FRNG01.R00                             **
: **                                                              **
: **  File Description   : ISIS FRING.LIB                         **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	ISIS Ring Handling Routines	- FRNG01.R00
:*******************************************************************
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
    : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : CRSH01.R00                             **
: **                                                              **
: **  File Description   : ISIS CRASH.LIB                         **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRSH01.R00
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME,EXCRSH
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRXREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:	The symbol EXCRSH, if set to 1, allows a JAL to label
:	CRSH.P out of the crash routine for extended crash processing.
:	The link is R5.  EXCRSH is defaulted to 0.
:
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF	\EXCRSH			:DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH	EQ	0
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HS	2		:WHERE CRASH OCCURED
CFROM	HS	2    		:WHERE CRASH WAS CALLED FROM
CRXREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK
	BC	16	:WATCH FROG TIMER - - TIME OUT

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF,,        :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL,,	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF,,        :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2,, :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL,,	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
  IF	CRSTOP
  ELSE
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
  EI	CRSTOP
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL,,	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV,,          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1,,    :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1,,
        LM      R6,CRAT+CRTLEN/2,R1,,
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1,
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
	EM

 	SUBTTL	Mbase Timeout Routine   -   TIMOUT.MBS

	RA	0		:	TIMOUT.MBS


:	This package contains the Mbase timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six subroutines are declared:

:	IZT	called at initilization, link on R0

:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced,
:		with output:
:		R0 = routine address
:		R1 = current fast-clock time.
:		R6 = port status table address

:	TORET	routines called by TIMOUT should exit to here

:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5
:		inputs:
:		R0 = address to transfer to
:		R1 = next time (FASTC) to call routine
:		R6 = port status table address

:	TOGET	called to delete an entry already on timout list
:		link on R5
:		input:
:		R0 = port status table address

:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5
:		input:
:		R0 = port status table address
:		This subroutine is currently not in use, but can be
:		activated by "uncommenting" it.

:	NOTE...when a routine is called from timeout list, it is
:	removed from list, and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no
:	entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 14		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation
:				word port status table address

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	L	R6,TLIST+0A,R2	:put PST addr in R6
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH,,	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,CCTMLS

TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4	:STORE TRANSFER ADDRESS
	ST	R6,TLIST+0A,R4	:STORE THE PST ADDRESS
	ST	R1,TLIST+6,R4	:STORE ACTIVATION
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+0A,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+0A,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
  
	SUBTTL	STORAG  -  MBASE STORAGE AREA
:###################################################################
:@$@$@$@$@$$@$@$@$@$@$@$@$$@$$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$

:	FILE  -  STORAG.MBS

:	S T O R A G E     A R E A

:	This file contains a variety of storage areas.

:STORAG.MBS	ORIGINATED BY ?.
:STORAG.M01	DEE EDUARDO 2/10/88
:		ADDED BITHRS AND B3THRS.
:		REFORMATTED.

	SEG	A.DATA
TRCING  HS      1               :FLAG TO SWITCH EVT TRACE ON OR OFF

        BND     4
        GL      ISOPQ,ATCHDQ,SRBQUE,SRBQND,SUSQUE,SUSQND,FLUSHQ
        GL      IOPQND,ATCQND,SUSQND,FLSQND
ISOPQ	WS	1		:pointer to 1st PST in the ISIS Output Queue
IOPQND  WS      1               :END OF ISIS OUTPUT QUEUE
ATCHDQ	WS	1               :pointer to 1st PST on attached ports queue
ATCQND	WS	1               :END OF ATCHD QUEUE
SRBQUE  WS      1               :SERVICE REQEUST BLOCK QUEUE
SRBQND  WS      1               : END OF SRBQUE
SUSQUE  WS      1               :SUSPEND QUEUE
SUSQND  WS      1               :END OF SUSPEND QUEUE
FLUSHQ  WS      1               :FLUSH QUEUE
FLSQND  WS      1               :END OF FLUSH QUEUE

        GL      MBASRS,PNDCMD,RSETIP,RXSRCD,LMTRCD,SUSPND,SBUSTO
        GL      APORTM,APORTS,PSTATB,FSHRB1,FSHRB3,PSTCNT
        GL      ZPBTOT,ZPCTOT,SRDMAX,RQSMAX,B1UCRB,B3UCRB
MBASRS  HS      1               :FLAG INDICATING MBASE-INITIATED RESET
PNDCMD  HS      1               :USED BY RESET INTERFACE 
RSETIP  HS      1               :RESET-IN-PROGRESS
RXSRCD  HS      1               :READ XTENDED STATUS REC'D FLAG
LMTRCD  HS      1               :LOAD MAPPING TABLE REC'D FLAG
SUSPND  HS      1               :SUSPEND-MODE FLAG
SBUSTO  WS      1               :SBUS TIME-OUT VALUE
        HS      1
ZPBTOT  HS      1               :TOTAL COUNT OF ZAPPED BUFFERS
        HS      1
ZPCTOT  HS      1               :TOTAL CHAR COUNT OF ZAPPED BUFFERS
FSHRB1  HS      1               :MAX NMBR SBUS BUFFERS PER PORT BEFOR BKPR
FSHRB3  HS      1               :MAX NMBR TYPE 3 BUFRS PER PORT BEFOR BKPR
B1UCRB  HS      1	:BUF 1 USD COUNT WHICH, WHEN REACHED, ALLOWS RELEASE BP
B3UCRB  HS      1       :BUF 3 USD COUNT WHICH, WHEN REACHED, ALLOWS RELEASE BP
B1THRS	HS	1	:BUF 1 THRESHOLD - MAX SBUS BUFS USED IN SLOT BEFORE BP
B3THRS	HS	1	:BUF 3 THRESHOLD - MAX TYPE1 BUFS USED IN SLOT BEFOR BP
SRDMAX	HS	1		:MAX SRDONE TASK CYCLES PER BG RUN
RQSMAX	HS	1		:MAX RQSTRT CYCLES PER BG RUN
PSTCNT  BS      1               :COUNT OF ACTIVE PSTS

:  IRING TASK SETS APORTM AND APORTS BITS WHEN NEEDL OR P/N REC'D
        BND     2
APORTM  HS      NGRP            :ATTACHED PORTS, FROM MBASE POINT-OF-VIEW
:       FG JOB CHECKS APORTS BIT ARRAY FOR ATTACHED PORTS
:       A SET BIT CORRESPONDS TO A PORT ON THE ATCHDQ
APORTS  HS      NGRP            :ATTACHED PORTS, SPIRIT POINT-OF-VIEW

        BND     4
PSTATB  WS      NPORT+1         :TABLE OF PORT STATUS TABLE ADDRESSES
IOCBTB  WS      NIOCB           :TABLE OF IOCB ADDRESSES
        GL      EVNTBL,WRAPED,EVTCNT,SELETB,EVTBTB,EVIXTB,SELNXT,EVNEXT
        GL      EVTEND,NONZRO,SKIPIT,LSTNDL,LSTPSN,CURVTB,IFWRAP,SELCNT
EVNTBL  WC      0                       :PTR TO CURRENTLY USED EVT TRAC TBL
EVNEXT  HS      1                       :IDX INTO CURRENT START OF TABLE

        GL      EVTBSZ,EVNTSZ
EVNTSZ  EQ      10                      :SIZE OF EVENT TABLE RECORD
EVTBSZ  EQ      EVNTSZ*NEVNTS

Q       EQ      0
        RE      NEVTBL
        GL      EVTBL|Q|
EVTBL|Q| BS     EVTBSZ
Q       EQ      Q+1
        ER
EVTEND  EQ      .

        BND     2
CURVTB  HC      0
Q       EQ      0
EVTBTB  EQ      .
        RE      NEVTBL
        HC      EVTBL|Q|!8000 :SET HI-ORDER BIT--CLEARED WHEN USED
Q       EQ      Q+1
        ER
EVIXTB  EQ      .
        RE      NEVTBL
        HC      0
        ER
EVWRTB  EQ      .
        RE      NEVTBL
        HC      0
        ER
EVCNTB  EQ      .
        RE      NEVTBL
        HC      0
        ER
SELETB  WS      1
SELNXT  HS      1
SELCNT  HS      1

        BND     4
EVTEMP  WS      10
FGEVTM  WS      10
ETPARM	WS	5
NONZRO  HS      1
WRAPED  HS      1
IFWRAP  HS      1
SKIPIT  HS      1
EVTCNT  HS      1
LSTNDL  BS      BUF1SZ                  :SAVE AREA FOR LAST NEEDLE REC'D
LSTPSN  BS      BUF1SZ                  :SAVE AREA FOR LAST PSEUDO NEDL

  

:###################################################################
:@$@$@$@$@$$@$@$@$@$@$@$@$$@$$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$@$


	SUBTTL	STORE  -  MBASE STORAGE AREA  

:	FILE  -  STORE.MBS


:	S T O R A G E     A R E A


:	This file contains a variety of storage areas and equates.

	SEG	A.DATA

:	MESSAGE TYPE TRANSLATION TABLES
:	The following 4 tables are used to translate message types - 
:	from Spirit format to ISIS, or vice verca.  When translating,
:	the message type of the message we have, is the index into
:	the table to get the other format.  For example, if we have
:	Spirit message type 3, byte 3 in the translation table (starting
:	from 0) will contain the corresponding ISIS message type.

:	Translate from ISIS to Spirit format - port non-zero messages
	GL	TOSPPN
TOSPPN	BS	100


:	Translate from spirit to ISIS format - port non-zero messages
	GL	TOISPN
TOISPN	BS	100

:	Translate from ISIS to Spirit format - port zero messages
	GL	TOSPP0
TOSPP0	BS	100

:	Translate from Spirit to ISIS format - port zero messages
	GL	TOISP0,TBLEND
TOISP0	BS	100
TBLEND	BS	0		:end of translation tables

	GL	RXFORM
RXFORM	EQ	1		:read extended format code

:	Read extennded status template send to Spirit
	GL	RXLEN,RXFCOD,RXNODE,RXKHST,RXSLOT,RXCCNT,RXCRSH
	GL	RXLAST,RXEND
RXLEN	EQ	0		:length of data
RXFCOD	EQ	2		:format code (X'01')
RXNODE	EQ	3		:node number
RXKHST	EQ	5		:kernal host number
RXSLOT	EQ	7		:slot number of Mbase
RXCCNT	EQ	8		:crash count
RXCRSH	EQ	$A 10		:reason code
RXLAST	EQ	$A 12		:reason for last interface reset
RXEND	EQ	$A 13

	GL	B3PDAT
B3PDAT	EQ	B3DATA+1	:pointer to 2nd data byte in buf3


:	Current Spirit type codes of common messages
	GL	SPDATA,SPZAP,SPGOB,SPBAKP,SPRLBP,SPLOGS
SPDATA	BS	1		:data msg
SPZAP	BS	1		:zap msg
SPGOB	BS	1		:gobbler msg
SPBAKP	BS	1		:backpressure msg
SPRLBP	BS	1		:release backpressure msg
SPLOGS	BS	1		:login string

:	Special action codes
	GL	NLGSTR,FWDCHR,AUTOBP,NATBP
NLGSTR	EQ	1		:normal login string (not neg)
FWDCHR	EQ	2%0FF		:set forwarding characteristics
AUTOBP	EQ	3%0FF		:auto backpressure on (Mbase may send BP)
NATBP	EQ	4%0FF		:auto backpressure off (Mbase may not send BP)


	GL	LOGLEN,MSGHDR,BUFTP1,BUFTP2,BUFTP3,BPLEN,TMINTV
LOGLEN	EQ	4		:Spirit msg login length (port+type+char)
MSGHDR	EQ	3		:nbr of bytes in port & msg type
BUFTP1	EQ	1		:buffer type 1
BUFTP2	EQ	2		:buffer type 2
BUFTP3	EQ	3		:buffer type 3
BPLEN	EQ	3		:length of backpressure msg
TMINTV	EQ	5		:seconds per timeout interval

:	Things needed to prevent ISIS from being flooded with messages
:	if Spirit repeatedly gets in a crash-restart cycle.
	GL	MINRST,THSRST,LSTRST,MAYSND
MINRST	EQ	$A 60		:min allowable time between resets (secs)
THSRST	WS	1		:time of latest reset interface msg
LSTRST	WS	1		:time of previous reset msg (SLOWC)
MAYSND	HS	1		:if set ISOUT won't output msgs, else - 0

  


	SUBTTL	MBASE Memory Allocation Module
	
	

        MO      .,BUFFER

:       allocates memory for s-bus window
:       sbus window resides in a sgment defined by WINDOW
:	allocates and maintains memory for three buffer types:
:	buffer1 -- s-bus window buffers 
:	buffer2 -- used for service reqeust blocks
:	buffer3 -- short buffers for circuit signals and data msgs of 1-2 bytes
:       buffer2 in sgment defined by BUF2SG
:       buffer3 in sgment defined by BUF3SG

:	each buffer has a halfword headr and halfword trailer
:	each buffer type has its own header/trailer constant

        GL      BSPACE,NBUF1,DQDAIB,SRDONE,NBUF3
        GL      SPZAP,SPBAKP,SPRLBP,HWMBF1,HWMBF2,HWMBF3,DFNSRB,SRMXCD

        SEG     A.DATA
        SEG     A.DATA
GBUFSV  WS      1
FRB2SV  WS      10

:       BUFFER OFFSETS

HEADER  EQ      0
NEXT    EQ      2
TYPBYT  EQ      NEXT+BUFTYP

:	BUFFER I.D.S, DATA MAXIMUMS, HEADER/TRAILER CONSTANTS
	GL	BTYPE1,BTYPE3,BUF1MX,BUF3MX
BTYPE1	EQ	1
BTYPE3	EQ	3
BUF1MX	EQ	BUF1SZ-B1DATA           :MAX # DATA BYTES = BUF1SZ = HEADR BYTS
BUF3MX	EQ	2
HTCON1	EQ	0CCCC			:BUFFER1 HDR/TRAILER CONSTANT
HTCON2	EQ	0DDDD			:BUFFER2 HDR/TRLR CONSTANT
HTCON3	EQ	0EEEE

:       DEFINE AND ALLOCATE BUFFER STORAGE
	GL	B1USED,B2USED,B3USED,HWMASD

        SEG     BUF3SG
B3FLST  WS      1               	:BUFFER FREE LIST FOR BUFFER3
B3USED  HS      1               	:COUNT OF BUFFERS IN USE (BUFFER3)
HWMBF3  HS      1                       :HI-WATER MARK, BUF 3 USED COUNT
B3SIZ   EQ      BUF3SZ+4                :ADD 4 BYTES FOR HDR/TRLR
MXUBF3	EQ	NBUF3-5			:MAX ALLOWABLE NBR OF BUF3 IN USE...
					:...BEFORE WE START ZAPPING BUFFERS
BUFER3	BS      (NBUF3+1)*B3SIZ
B3TRLR  EQ      B3SIZ-2

        SEG     BUF2SG
B2FLST  WS      1               	:BUFFFER FREE LIST FOR BUFFER2
B2USED	HS      1               	:COUNT OF BUFFERS IN USE (BUFFER2)
HWMBF2  HS      1                       :HI-WATER MARK, BUF 2 USED COUNT
HWMASD	HS	1			:HI-WATER MARK AFTER SRDONE
DFNSRB	HS	1		:CNT NMBR TIMES TASK DEFERRED BECAUSE LOW SRBS
SRMXCD	HS	1		:CNT NMBR TIMES B2USED EXCEEDS SRBMIN (SHOULDN'T HAPPEN)
B2SIZ   EQ      BUF2SZ+4                :ADD 4 BYTES FOR HDR/TRLR
BUFER2	BS      (NBUF2+1)*B2SIZ
B2TRLR  EQ      B2SIZ-2

:       S-BUS WINDOW EQUATES

        GL      IOCBLN
IOCBLN  EQ      20

        GL      MSGBLK                  :S-BUS MESSAGE BLOCK
MSGBLK	EQ	WNDBAD			:MSG BLK = WINDOW BASE ADDR

Q	EQ	0
OFFSET	EQ	WNDBAD+IOCBLN
        RE      NIOCB
        GL      IOCB|Q|
IOCB|Q| EQ	OFFSET
OFFSET	EQ	OFFSET+IOCBLN
Q       EQ      Q+1
        ER

B1FLST	EQ	OFFSET+40               :BUFFER FREE LIST
B1USED  EQ	B1FLST+4                :COUNT OF BUFFERS IN USE (BUF1)
HWMBF1  EQ      B1FLST+6                :HI-WATER MARK, BUF 1 USED COUNT

B1SIZ   EQ      BUF1SZ+4                :ADD 4 FOR HDR/TRLR
NBUF1   EQ      (((WINDOW+1)*10000)-(B1USED+2))/B1SIZ
BUFER1  EQ      B1FLST+8                :1ST BUFFER ADDR
	REMARK % START OF SBUS BUFFER AREA = 
	NUMBER	BUFER1
        
B1TRLR  EQ      B1SIZ-2

BSPACE  EQ      BUF1MX*NBUF1            :USED TO FIGURE GLOBL BKPSR CRITERIA

        SEG     A.DATA
MIZSAV  WS      1
        SEG     A.CODE

:       INITIALIZE BUFFERS
:       LINK ON R13

        GL      IZBUFS
IZBUFS  ST      R13,MIZSAV,,            :SAVE LINK REG
        LIS     R6,0                    :CLEAR R6
        LIS     R1,0                    :INIT OFFSET
        LIS     R2,0                    :INIT BUF COUNTER
        LHI     R4,BTYPE1
        STH     R2,B1USED,,             :INIT USED BUFFER COUNTER
        STH     R2,HWMBF1,,             :CLEAR HI-WATER MARK OF USED BUF 1
        LI      R3,BUFER1               :GET ADDR OF 1ST BUF
        ST      R3,B1FLST,,             :MAKE IT 1ST ON FREE LIST
        AI      R3,B1SIZ                :MAKE INTO ADDR OF NEXT BUFFER
        LI      R0,HTCON1               :GET HEADER/TRAILER CONSTANT
B1INIT  STH     R0,BUFER1+HEADER,R1,    :SET HEADER TO CONSTANT
        LIS     R5,0                    :INIT BYTE IDX
B1INI0  STB     R6,BUFER1+NEXT,R1,R5    :CLEAR BUFFER BYTE
        AIS     R5,1            
        CLHI    R5,BUF1SZ               :CLEARED ALL OF BUFFER?
        JNBS    B1INI0                  
        STB     R4,BUFER1+TYPBYT,R1,    :STORE  BUF TYPE CONSTANT
        STH     R0,BUFER1+B1TRLR,R1,    :SET TRAILER " "
        ST      R3,BUFER1+NEXT,R1,      :NEXT FIELD POINTS TO NEXT BUF
        AI      R1,B1SIZ                :INCREMENT OFFSET
        AI      R3,B1SIZ                :GET NEXT BUF ADDR
        AIS     R2,1                    :INCREMNT COUNTER
        CLHI    R2,NBUF1-1              :LAST ONE?
        JN      B1INIT                  :NO
        STB     R4,BUFER1+TYPBYT,R1,    :STORE  BUF TYPE CONSTANT
        LIS     R3,0                    :NEXT FIELD OF LAST BUFFER...
        ST      R3,BUFER1+NEXT,R1,      :...SET TO 0
        STH     R0,BUFER1+HEADER,R1,
        STH     R0,BUFER1+B1TRLR,R1,

        LIS     R1,0                    :INIT OFFSET
        LIS     R2,0                    :INIT BUF COUNTER
        STH     R2,B2USED,,             :INIT USED BUFFER COUNTER
        STH     R2,HWMBF2,,             :CLEAR HI-WATER MARK OF USED BUF 2
	STH	R2,HWMASD,,		:HI-WATER MARK AFTER SRDONE
	STH	R2,DFNSRB,,
	STH	R2,SRMXCD,,
        LA      R3,BUFER2,,             :GET ADDR OF 1ST BUF
        ST      R3,B2FLST,,             :MAKE IT 1ST ON FREE LIST
        AI      R3,B2SIZ                :MAKE INTO ADDR OF NEXT BUFFER
        LI      R0,HTCON2               :GET HEADER/TRAILER CONSTANT
B2INIT  STH     R0,BUFER2+HEADER,R1,    :SET HEADER TO CONSTANT
        LIS     R5,0
B2INI0  STB     R6,BUFER2+NEXT,R1,R5    :CLEAR BYTE
        AIS     R5,1
        CLHI    R5,BUF2SZ
        JNBS    B2INI0
        STH     R0,BUFER2+B2TRLR,R1,    :SET TRAILER " "
        ST      R3,BUFER2+NEXT,R1,      :NEXT FIELD POINTS TO NEXT BUF
        AI      R1,B2SIZ                :INCREMENT OFFSET
        AI      R3,B2SIZ                :GET NEXT BUF ADDR
        AIS     R2,1                    :INCREMNT COUNTER
        CLHI    R2,NBUF2-1              :LAST ONE?
        JN      B2INIT                  :NO
        LIS     R3,0                    :NEXT FIELD OF LAST BUFFER...
        ST      R3,BUFER2+NEXT,R1,      :...SET TO 0
        STH     R0,BUFER2+HEADER,R1,
        STH     R0,BUFER2+B2TRLR,R1,

        LIS     R1,0                    :INIT OFFSET
        LIS     R2,0                    :INIT BUF COUNTER
        LHI     R4,BTYPE3
        STH     R2,B3USED,,             :INIT USED BUFFER COUNTER
        STH     R2,HWMBF3,,             :CLEAR HI-WATER MARK OF USED BUF 3
        LA      R3,BUFER3,,             :GET ADDR OF 1ST BUF
        ST      R3,B3FLST,,             :MAKE IT 1ST ON FREE LIST
        AI      R3,B3SIZ                :MAKE INTO ADDR OF NEXT BUFFER
        LI      R0,HTCON3               :GET HEADER/TRAILER CONSTANT
B3INIT  STH     R0,BUFER3+HEADER,R1,    :SET HEADER TO CONSTANT
        LIS     R5,0
B3INI0  STB     R6,BUFER3+NEXT,R1,R5    :CLEAR BUFFER BYTE
        AIS     R5,1
        CLHI    R5,BUF3SZ
        JNBS    B3INI0
        STB     R4,BUFER3+TYPBYT,R1,    :STORE BUF TYPE CONSTANT
        STH     R0,BUFER3+B3TRLR,R1,    :SET TRAILER " "
        ST      R3,BUFER3+NEXT,R1,      :NEXT FIELD POINTS TO NEXT BUF
        AI      R1,B3SIZ                :INCREMENT OFFSET
        AI      R3,B3SIZ                :GET NEXT BUF ADDR
        AIS     R2,1                    :INCREMNT COUNTER
        CLHI    R2,NBUF3-1              :LAST ONE?
        JN      B3INIT                  :NO
        STB     R4,BUFER3+TYPBYT,R1,    :STORE BUF TYPE CONSTANT
        LIS     R3,0                    :NEXT FIELD OF LAST BUFFER...
        ST      R3,BUFER3+NEXT,R1,      :...SET TO 0
        STH     R0,BUFER3+HEADER,R1,
        STH     R0,BUFER3+B3TRLR,R1,
        L       R13,MIZSAV,,

        JR      R13


        GL      GETBF1,GETBF2,GETBF3,RETBF1,RETBF2,RETBF3

:	GET DATA BUFFER ROUTINES
:	LINK ON R13
:       IF BUFTYP1 (SBUS BUFFER), R8 = PST ADDR ...
:       IF USED TO HANDLE CHNL1 CMD OF LOAD MAPPING TABLES, R8 = 0
:	PARAMETERS RETURNED:
:               BUFFER ADDR IN R6

:       GET BUFFER TYPE 1

:       R8 = PST ADDR (OR 0 IF FOR HANDLING LOAD MAPPING TABLES CMD)

NOBUF1	ST 	R13,GBUFSV,,
        JAL     R13,ZAPBF1              :ZAP BUFFERS TO FREE SOME UP
        L       R13,GBUFSV,,
GETBF1	L	R6,B1FLST,,		:GET FREE BUFFER
	JEBS	NOBUF1			:NO MORE, GO GET SOME
	L	R1,NEXT,R6,		:GET NEXT FREE BUFFER
	ST	R1,B1FLST,,		:PUT AT HEAD OF FREE LIST
	LIS	R0,1			
	AHM	R0,B1USED,,		:INCREMENT USED COUNT
	AHI	R6,NEXT			:GIVE CALLER 'VIRTUAL' ADDR OF BUFFER
	IF	DB.GB1			:IF IN DE-BUG MODE...
	LHL	R2,B1USED,,		:GET USED COUNT
	EVT(ET.GB1,TS.GB1,R13,R6,R2,R1) :TRACE THIS EVENT
	EI
        LIS     R0,0
        ST      R0,BUFNXT,R6            :CLEAR NEXT FIELD
        ST      R0,BUFMSG,R6            :CLEAR MSG, LENGTH, CEI, NFMI BYTES
        STB     R0,BUFTMO,R6            :CLEAR DATA FWRDING TIM-OUT FLAG
        STB     R0,BSPLIT,R6            :CLEAR 'SPLIT BUFFER' FLAG
        LR      R8,R8                   :THIS FOR A PORT?
        JER     R13                     :NO, RETURN
        LHL     R1,SBBFCT,R8            :GET CURRENT SBUS BUF COUNT
        AIS     R1,1                    :INCREMNT
        STH     R1,SBBFCT,R8            :UPDATE
	JR	R13			:RETURN


:       GET TYPE 2 BUFFER

NOBUF2	RESET(R13,CCNSRB)

GETBF2	L	R6,B2FLST,, 		:GET FREE BUFFER
	JE	NOBUF2			:IF NO SRBS, CRASH
	L	R1,NEXT,R6,		:GET NEXT FREE BUFFER
	ST	R1,B2FLST,,		:PUT AT HEAD OF FREE LIST
	LIS	R0,1		
	AHM	R0,B2USED,,		:INCREMENT USED COUNT
	CLHI	R0,SRMXCD		:SRB USED COUNT EXCEEDED SRBMIN?
	JG	GB2INC			:IF SO, INCREMNT SRMXCD
GB2GO	AHI	R6,NEXT			:GIVE CALLER 'VIRTUAL' ADDR OF BUFFER
	IF	DB.GB2			:IF IN DE-BUG MODE...
	LHL	R2,B2USED,,		:GET USED COUNT
	EVT(ET.GB2,TS.GB2,R13,R6,R2,R1) :TRACE THIS EVENT
	EI
        LIS     R1,0
        LIS     R2,0
CLRBF2  ST      R1,SRBNXT,R6,R2         :CLEAR OUT BUFFER 
        AIS     R2,4
        CLHI    R2,SRBLEN
        JNBS    CLRBF2
	JR	R13			:RETURN

GB2INC	LHL	R0,SRMXCD,,	:GET COUNT OF TIMES SRBMIN EXCEEDED
	AIS	R0,1		:AND INCREMENT IT
	STH	R0,SRMXCD,,
	J	GB2GO		:AND GO GET BUFFER

:       GET TYPE 3 BUFFER

CRBUF3	RESET(R13,CCNOB3)		:IF ALL BUF3 IN USE - CRASH
NOBUF3  ST      R13,GBUFSV,,
        JAL     R13,ZAPBF3              :ZAP PORT W/ MOST CIRC. SIGNALS
        L       R13,GBUFSV,,
GETBF3	L	R6,B3FLST,,		:GET FREE BUFFER
	JE	CRBUF3			:NO MORE, CRASH
	LH	R1,B3USED,,		:GET NBR OF BUF3 IN USE
	CHI	R1,MXUBF3		:ARE WE BELOW THE MAX ALLOWABLE ?
	JGE	NOBUF3			:IF NOT - GO ZAP SOME 
GETB3E	L	R1,NEXT,R6,		:GET NEXT FREE BUFFER
	ST	R1,B3FLST,,		:PUT AT HEAD OF FREE LIST
	LIS	R0,1			
	AHM	R0,B3USED,,		:INCREMENT USED COUNT
	AHI	R6,NEXT			:GIVE CALLER 'VIRTUAL' ADDR OF BUFFER
	IF	DB.GB3			:IF IN DE-BUG MODE...
	LHL	R2,B3USED,,		:GET USED COUNT
	EVT(ET.GB3,TS.GB3,R13,R6,R2,R1) :TRACE THIS EVENT
	EI
        LIS     R0,0
        ST      R0,BUFNXT,R6            :CLEAR NEXT FIELD
        ST      R0,BUFMSG,R6            :CLEAR BUFMGS,LENGTH & DATA BYTS
        LR      R8,R8                   :THIS FOR A PORT?
        JER     R13                     :NO, RETURN
        LHL     R1,T3BFCT,R8            :GET TYPE 2 BUFFER CNT
        AIS     R1,1
        STH     R1,T3BFCT,R8            :UPDATE
        
	JR	R13			:RETURN


:       RETURN TYPE 1 BUFFER
:       BUFFER ADDR IN R6
:       PST ADDR IN R8, ELSE R8 MUST BE 0 
:       ONLY CASE WHERE NOT USED W/ PORT IS FOR HANDLING CHNL 1 CMD...
:       OF LOAD MAPPING TABLES

RETBF1	SHI	R6,NEXT			:GET ACTUAL ADDRESS OF BUF
	L	R1,B1FLST,,		:GET ADDR OF 1ST ON FREE LIST
	ST	R1,NEXT,R6,		:PUT IN NEXT FIELD OF RETURNED BUFFER
	ST	R6,B1FLST,,		:RETURNED BUF IS NOW 1ST IN FREE LIST
	LCS	R0,1			:GET A -1
	AHM	R0,B1USED,,		:DECREMENT USED BUF COUNT
	IF	DB.RB1			:IF IN DE-BUG MODE...
	LHL	R2,B1USED,,		:GET USED BUF COUNT
	EVT(ET.RB1,TS.RB1,R13,R6,R2,R1)	:TRACE THIS EVENT
	EI
        LR      R8,R8                   :THIS FOR A PORT?
        JER     R13                     :RETURN IF NOT
        LHL     R1,SBBFCT,R8            :GET CURRENT SBUS BUF COUNT
        SIS     R1,1                    :DECREMENT
        STH     R1,SBBFCT,R8            :UPDATE
        JR      R13


:       RETURN TYPE 2 BUFFER
:       BUFFER ADDR IN R6

RETBF2	SHI	R6,NEXT			:GET ACTUAL ADDRESS OF BUF
	L	R1,B2FLST,,		:GET ADDR OF 1ST ON FREE LIST
	ST	R1,NEXT,R6,		:PUT IN NEXT FIELD OF RETURNED BUFFER
	ST	R6,B2FLST,,		:RETURNED BUF IS NOW 1ST IN FREE LIST
	LCS	R0,1			:GET A -1
	AHM	R0,B2USED,,		:DECREMENT USED BUF COUNT
	IF	DB.RB2			:IF IN DE-BUG MODE...
	LHL	R2,B2USED,,		:GET USED BUF COUNT
	EVT(ET.RB2,TS.RB2,R13,R6,R2,R1)	:TRACE THIS EVENT
	EI
        JR      R13


:       RETURN TYPE 3 BUFFER
:       BUFFER ADDR IN R6

RETBF3	SHI	R6,NEXT			:GET ACTUAL ADDRESS OF BUF
	L	R1,B3FLST,,		:GET ADDR OF 1ST ON FREE LIST
	ST	R1,NEXT,R6,		:PUT IN NEXT FIELD OF RETURNED BUFFER
	ST	R6,B3FLST,,		:RETURNED BUF IS NOW 1ST IN FREE LIST
	LCS	R0,1			:GET A -1
	AHM	R0,B3USED,,		:DECREMENT USED BUF COUNT
	IF	DB.RB3			:IF IN DE-BUG MODE...
	LHL	R2,B3USED,,		:GET USED BUF COUNT
	EVT(ET.RB3,TS.RB3,R13,R6,R2,R1)	:TRACE THIS EVENT
	EI
        LR      R8,R8                   :THIS FOR A PORT?
        JER     R13
        LHL     R1,T3BFCT,R8            :GET CURRENT TYPE 3 BUF CNT
        SIS     R1,1
        STH     R1,T3BFCT,R8
        JR      R13

:	RECOVER (ZAP) BUFFERS FROM THE PORT W/ THE MOST SBUS BUFFERS
:	...AND SEND A BLACK BALL TO SPIRIT TO SHOW DATA LOSS
:	LINK ON R13

        SEG     A.DATA
	BND	4
ZPBFSV  WS      8
QBBSAV  WS      1
BBALLD	HS	1
        SEG     A.CODE
ZAPBF1	STM	R8,ZPBFSV,,
	L	R1,ATCHDQ		:GET 1ST PST
	LR	R8,R1			:PST W/ MOST BUFS IN R8
ZB1.01	L	R2,ATCHNX,R1		:GET NEXT
        JEFS    ZB1.02  
	LHL	R4,SBBFCT,R8 		:GET SBUS COUNT OF CURRENT BIGGIE
	CLH	R4,SBBFCT,R2		:GREATER THAN THAT OF R2?
	JGFS	ZB1.03			:YES, DON'T UPDATE R8
	LR	R8,R2			:PST IN R2 IS NOW THE BIGGIE
ZB1.03	LR	R1,R2			:SWAP CURRENT PST INTO R1
        JBS     ZB1.01

:       ZAP SBUS BUFFERS ON INPUT QUEUE--CHECK TYPE 3 BUFFERS FOR...
:       ...BACKPRESSURE MSGS AND LEAVE ON QUEUE IF THERE ARE ANY..
:       ...ELSE ZAP THE TYPE 3 BUFFER AS WELL
:	REPLACE ZAPPED BUFFER(S) W/ BLACK BALL MSG
:       IF 1ST BUF ON INPUT QUEUE IS 'SPLIT BUFFER' THEN KEEP ON QUE

ZB1.02  IF      DB.ZB1
        EVT(ET.ZB1,TS.ZB1,R8)
        EI

ZBF.00	L	R6,INQUE,R8             :GET START OF BUFFER QUEUE
      	LIS	R15,0			:INIT TEMP QUEUE
        STH     R15,BBALLD,,            :INIT BLACK-BALLED FLAG
        LB      R1,BUFTYP,R6            :BUF TYPE OF 1ST BUF
        CLHI    R1,BTYPE1               :TYPE 1 (SBUS BUFFER)?
        JNFS    ZBF.01                  :JUMP IF NOT
        LB      R1,BSPLIT,R6            :'SPLIT BUFFER' FLAG SET?
        JEFS    ZBF.01                  :JUMP IF NOT
        L       R7,BUFNXT,R6            :GET NEXT AFTER 1ST BUF
        LR      R6,R7                   :NEXT BUF IS 1ST TO DUMP
        JFS     ZBF.10
ZBF.01  ST      R15,INQUE,R8            :CLEAR INPUT QUEUE
ZBF.10	L	R7,BUFNXT,R6		:GET NEXT
	LB	R14,BUFTYP,R6		:BUFFER TYPE
	CLHI	R14,BTYPE1		:BUF TYPE 1?
	JN  	ZBF.02			:JUMP IF NOT
        LIS     R1,1
        AHM     R1,ZPDBCT,R8            :INCREMENT ZAPD BUF CNT IN PST
        AHM     R1,ZPBTOT,,             :INCREMENT ZAPD BUF CNT IN MBASE
        LB      R1,BUFLEN,R6            :GET NMBR BYTES IN BUF
        AHM     R1,ZPDCHC,R8            :ADD TO ZAPD CHAR CNT IN PST
        AHM     R1,ZPCTOT,,             :ADD TO ZAPD CHAR CNT IN MBASE
	JAL	R13,RETBF1		:RETURN BUFFER TO POOL
	LH	R1,BBALLD,,		:BLACK BALL SENT FOR THIS DATA CHUNK?
	JLFS	ZBF.03			:YES, DON'T SEND ANOTHER ONE
	TS	BBALLD,,                :ELSE SET THE BLACK BALLED FLAG
	JAL	R13,QBBALL		:ENQUE THE BLACK BALL
ZBF.03	LR	R6,R7			:NEXT BUF NOW IS CURRENT BUF
	JN	ZBF.10			:CHECK IT OUT
        J       ZBF.07

:	CIRCUIT-SIGNAL IS BUFFERED--KEEP ENQUEUED IF BACKPRESSURE MSG
     
ZBF.02  LB      R1,BUFMSG,R6
        CLB     R1,SPBAKP,,             :GOT A BACKPRESSURE MSG?
	JEFS	ZBF.04			:YES, PUT ON TEMP QUEUE
        CLB     R1,SPRLBP,,             :RELEASE BACKPRESSURE?
        JNFS    ZBF.05                  :NO, DUMP IT
ZBF.04  LIS     R1,0
        STH     R1,BBALLD,,             :CLEAR BLACK-BALLED FLAG
      	JAL	R13,PTEMPQ		:PUT ON TEMP QUEUE
	J  	ZBF.06
ZBF.05  LIS     R1,1
        AHM     R1,ZPDBCT,R8            :INCREMNT ZAPD BUF CNT IN PST
        AHM     R1,ZPBTOT,,             :INCREMNT ZAPD BUF CNT IN MBASE
      	JAL	R13,RETBF3		:RETURN BUF 3 TO POOL
        LH      R1,BBALLD,,             :GET BLACK-BALLED FLAG
        JLFS    ZBF.06                  :ALREADY SET, DON'T DO IT AGAIN
        TS      BBALLD,,                :ELSE SET IT 
        JAL     R13,QBBALL              :AND ENQUE A BLACK BALL
ZBF.06	LR	R6,R7			:NEXT BUFFER NOW IS CURRENT BUF
	JN	ZBF.10			:CHECK IT OUT

:       PUT TEMP QUEUE ON INPUT QUEUE OF PST

ZBF.07  L       R1,INQUE,R8             :IS THERE A 'SPLIT BUFFER' ON QUE?
        JNFS    ZBF.08
        ST      R15,INQUE,R8            
        JFS     ZBF.09
ZBF.08  ST      R15,BUFNXT,R1           :APPEND TEMP QUEUE
	
ZBF.09  LM      R8,ZPBFSV,,
        JR      R13

:       PUT BUFFER ON TEMP QUEUE
:       R6 = BUFFER

PTEMPQ  LIS     R0,0
        ST      R0,BUFNXT,R6            :CLEAR NEXT FIELD OF BUF TO ADD
        LR      R15,R15                 :GOT START OF QUEUE?
        JNFS    PTEMP0                  :YES
        LR      R15,R6
        JR      R13
PTEMP0  LR      R12,R15                 :COPY START OF TEMP QUE
PTEMP1  L       R14,BUFNXT,R12          :GET NEXT UNTIL AT END
        JEFS    PTEMP2                  :END OF QUEUE
        LR      R12,R14                 
        JBS     PTEMP1
PTEMP2  ST      R6,BUFNXT,R12           :PUT THIS BUF AT END OF QUE
        JR      R13

:       QUEUE A BUF W/ BLACK BALL MSG ON TEMP QUEUE

QBBALL  ST      R13,QBBSAV,,
	L	R6,B3FLST,,		:ARE TYPE 3 BUFS ALL GONE ?
	JE	CRBUF3			:IF SO - CRASH
        JAL     R13,GETB3E		:IF NOT - GET A BUF3
        LHI     R1,BLKMSG
        LB      R1,TOSPPN,R1,           :GET SPIRIT BLACK BALL MSG TYPE
        STB     R1,BUFMSG,R6            :PUT IN BUFFER
        JAL     R13,PTEMPQ
        L       R13,QBBSAV,,
        JR      R13


:	FREE-UP TYPE 3 BUFFERS BY ZAPPING BUFFERS ON PORT...
:       WITH THE MOST TYPE 3 BUFERS
:	LINK ON R13

ZAPBF3	STM	R8,ZPBFSV,,
	L	R1,ATCHDQ
	LR	R8,R1			:PST W/ MOST BUFS IN R15
ZB3.01	L	R2,ATCHNX,R1		:GET NEXT PST
	JEFS	ZB3.02
	LHL	R4,T3BFCT,R8		:GET CURRENT BIGGIE
	CLH	R4,T3BFCT,R2		:COMPARE W/ THIS PST
	JGFS	ZB3.03			:STILL THE BIGGEST
	LR	R8,R2			:ELSE THIS IS THE NEW BIGGIE
ZB3.03	LR	R1,R2			:SWAP CURRENT PST INTO R1
	JBS	ZB3.01			:GO CHECK IT OUT

ZB3.02	IF	DB.ZB3
	EVT(ET.ZB3,TS.ZB3,R8)
	EI
        J       ZBF.00                  :GO ZAP BUFFERS

        EM
    
        SUBTTLE Mbase Utilites

:       ***** RETURN MACRO *****
:       MACRO TO RESTORE SAVED LINK REGISTER AND JR ON SAME REGISTER
:       ONLY FOR R13 LINK REG
RETURN  MACRO(SAVED)
[       L       R13,SAVED,,
        JR      R13
]

:	***** CHKSRB MACRO *****
:	MACRO TO CHECK FREE BUF 2 (SRB) THRESHOLD
:	***** CHKSRB(SAVE,N) *****
:
:	SAVE = SAVE AREA FOR LINK REG. IN CALL OF TASK FROM EXEC LOOP
:	N = NMBR OF SRBS NEEDED FOR ONE PASS THROUGH THE EXEC-LEVEL
:		...TASK THAT USES THIS MACRO, I.E., N = 1 FOR RQSTRT OR
:		...3 FOR IRNGTD TASK
:	NUMBER OF IN-US SRBS IS COMPARED WITH TOTAL NUMBER OF SRBS (NUBF2)
:	MINUS THE NUMBER OF SRBS THAT COULD BE NEEDED BY SRDONE (BF2THR)
:	PLUS THE NMBR OF SRBS NEEDED IN ONE PASS THROUGH A TASK (1 OR 3)

	SEG	A.CODE
CHKSRB	MACRO(SAVE,N) [
	LH	R0,B2USED,,
	CLHI	R0,NBUF2-(BF2THR+N)	:ENOUGH FREE SRBS FOR TASK?
	JLEFS	.+18			:JUMP IF OK
	LHL	R0,DFNSRB,,		:ELSE INCREMENT COUNT OF...
	AIS	R0,1			:TASK DEFERRED BECASUE OF NO SRBS
	STH	R0,DFNSRB,,
	L	R13,SAVE,,			:RESTORE LINK REG. 
	JR	R13			:GO BACK TO EXEC LOOP
]


        SUBTTL  ENQSRB -- Subroutine to put an SRB on the SRB queue

:	SUBROUTINE TO ENQUEUE SRB ON SRBQUE OR SUSQUE
:	SETS SBUS TIMEOUT IF SRBQUE EMPTY AND IF SPIRIT HAS...
:	DEFINED A TIMEOUT W/ SET TIMEOUT CMD ON CHANNEL 1
:	USES MBASE SVC TO COMMUNICATE W/ ISIS DRIVER IF SRBQUE IS EMPTY
:	LINK ON R13
:	SRB ADDR IN R6
	SEG	A.DATA
ENQSAV	WS	3
        GL      ENQSRB
	SEG	A.CODE
ENQSRB	STM	R13,ENQSAV,,
        TI      R6,0FFF00000
        JN      SRBERR
	LR	R15,R6
        JE      SRBERR
        IF      DB.SRQ
        LB      R1,SRCHNL,R15,          :GET CHANNEL NUMBER
        LB      R2,SRBYTE,R15,
        LHL     R3,CNTMSB,R15,
        LHL     R4,STBYT0,R15,
        EVT(ET.SRQ,TS.SRQ,R13,R1,R2,R3,R4) : TRACE EVENT
        EI

        LB      R1,SRBYTE,R15,          :IF SRBYTE = READ OR WRITE DATA...
        CLHI    R1,WRTDAT               :(I.E., 1 OR 2) THEN DON'T...
        JLEFS   NOZERO                  :SET THE ZERO BIT
        LHI     R1,ZERO                 :ELSE SET IT IN MSTAT
        SBT     R1,MSTAT,R15,           :(TELLS ISIS TO CLEAR SIO AND HIO)
NOZERO	LH	R0,SUSPND,,		:SUSPEND FLAG SET?
	JL	ENQSUS			:YES, PUT ON SRSUSQ

ENQSR4	L	R14,SRBQUE,,		:IS THERE A QUEUE ALREADY?
	JN  	ENQSR1			:YES, LINK NEW BUFFER TO END OF QUE
	ST	R15,SRBQUE,,		:BUFFER IS 1ST ON QUEUE
	L	R2,SBUSTO,,		:GET SBUS TIMEOUT VALUE
	JEFS	GOQUE1			:IF 0, NOT TIMING
	LHI	R6,SBTOID		:GET SBUS TIMEOUT I.D.
	L	R1,FASTC,,		
	AR	R1,R2			:GET MOMENT OF TIMEOUT
	LA	R0,SBTIMO,, 		:GO HERE IF TIMEOUT (CRASH)
	JAL	R5,TOPUT		:PUT ON TIMER LIST
GOQUE1	EQ	.
	IF	DRIVON
	SVC	MBASE,0,R15  		:TELL ISIS ABOUT NEW QUEUE
        JN      ENQERR
	EI
        LM      R13,ENQSAV,,
        JR      R13
ENQSR1	EQ	.
      	L	R3,SRBQND,,		:GET END OF QUEUE
        JNFS    ENQSR2                  :IF NOT EMPTY, UDATE IT'S NXT PTR
        LR      R3,R14                  :ELSE UPDATE NXT PTR OF SRBQUE
ENQSR2	ST	R15,SRBNXT,R3,		:LINK ON NEW BUF
	ST	R3,SRBPRV,R15,		:LINK BACK 
	ST	R15,SRBQND,,		:NEW SRB IS NOW END-OF-QUE
	LHI	R0,EOQ			:GET END-OF-QUEUE FLAG AND TEST...
        TBT     R0,ISTAT,R3,            :EOQ BIT IN ISTAT AREA
	JN  	ENQSR3			:EOQ SET, UPDATE SRBQE, TELL ISIS ABOUT NEW QUE
        LM      R13,ENQSAV,,
        JR      R13
ENQSR3  IF      DRIVON
	SVC	MBASE,0,R15  		:TELL ISIS ABOUT NEW QUEUE
        JN      ENQERR
        EI
        LM      R13,ENQSAV,,
        JR      R13

ENQSUS  LB      R1,SRCHNL,R15,          :GET CHANNEL NMBR
        CLHI    R1,1                    :SEE IF FOR IOCB 1
        JE      ENQSR4                  :IF SO, PUT ON SRBQUE
        LHI     R2,YELLOW               :TEST IF 'YELLOW-BALL' SRB
        TBT     R2,MSTAT,R15,   
        JN      ENQSR4                  :PUT ON SRBQUE IF SO
        L       R1,SUSQND,,             :GET END OF SUSPEND QUEUE
        JEFS    ENQSU0                  :IT'S EMPTY
ENQSU2  ST      R15,SUSQND,,            :THIS BUF ON END-OF-QUE
        ST      R15,SRBNXT,R1,          :LINK ON 
        ST      R1,SRBPRV,R15,          :LINK BACK
        LM      R13,ENQSAV,,
        JR      R13
ENQSU0  L       R3,SUSQUE,,             :GET START OF QUEUE
        JEFS    ENQSU1                  :NOTHING ON SUSPEND QUEUE
        LR      R1,R3
        J       ENQSU2
ENQSU1  ST      R15,SUSQUE,,            :IT'S START OF SUSPEND QUE
        LM      R13,ENQSAV,,
        JR      R13

ENQERR	EVT(ET.ISD,TS.ISD,R13,R0,R15)
        RESET(R13,CCISD)

SRBERR  EQ      .
        RESET(R13,CCBSRB)
	
:       PRESENT NORMAL STATUS SUBROUTINE
:       USED TO COMPLETE A WRITE OR SEND COMMAND BY CREATING AND...
:       ENQUEING AN SRB W/ STATUS INDICATING NORMAL COMPLETION OF CMD
:       LINK ON R13
:       CHANNEL NUMBER IN R9
        SEG     A.DATA
PSTATS  WS      1
        GL      PNORMS
        SEG     A.CODE
PNORMS  ST      R13,PSTATS,,
        JAL     R13,GETBF2              :GET AN SRB BUFFER
        LHI     R0,RDSTAT               :SERV. REQ. READ STATUS
        STB     R0,SRBYTE,R6            :PUT IN SERVICE REQUEST BYTE
        STB     R9,SRCHNL,R6            :CHANNEL NUMBER
        LIS     R0,0                    :CLEAR ALL STATUS BYTES
        ST      R0,STBYT0,R6            :0 IN STATUS BYTE 0--3
        JAL     R13,ENQSRB              :ENQUE THE SRB
        RETURN(PSTATS)

:       IZPST -- SUBROUTINE TO CLEAR ALL PST FIELDS (AFTER IOCB CONSTANTS)
:       LINKS ON R13
:       R8 = PST ADDR
:       USES R0,R1

        GL      IZPST
IZPST   LIS     R0,0
        LHI     R1,OPQNXT
IZPST0  STB     R0,0,R1,R8
        AIS     R1,1
        CLHI    R1,PSTLEN
        JNBS    IZPST0
        LHI     R1,XMLDFL
        STH     R1,XMTLIM,R8,
        JR      R13

:       SBUS TIME-OUT -- RESET (CRASH, FOLLOWED BY RESET INTERFACE)
        GL      SBTIMO
SBTIMO  RESET(R13,CCSBTO)

        SEG     A.DATA
        BND     4
CMPZSV	WS	8
        SEG     A.CODE

CMPLZX	MACRO
[	LM	R8,CMPZSV,,
        JR      R13
]

        GL      UPDGBC,RETBUF

:	COMPLETE PORT ZAP
:	CANCEL ANY TIMEOUT FOR PORT
:	REMOVE PST FROM ATTACHED QUEUE
:	CLEAR PORT BIT IN APORTS AND APORTM
:	R15 = PST ADDR
:	R11 = PORT NUMBER

CMPLZP	STM	R8,CMPZSV,,

        L       R6,INQUE,R15            :MAKE SURE NO REMAINING INPUT
        JEFS    CMPLZ5
        LR      R8,R15
CMPLZ6  L       R9,BUFNXT,R6            :NEXT BUF (IF ANY)
        LB      R5,BUFTYP,R6
        JAL     R13,RETBUF
        LR      R6,R9
        JNBS    CMPLZ6

CMPLZ5	LIS	R1,0			:0 IN R0 FOR CALL TO UPDGBC
	JAL	R13,UPDGBC		:UPDATE GLOBAL BKPR CRITERIA
	LR	R0,R15			:PST IN RO FOR TOGET CALL
	JAL	R5,TOGET		:REMOVE ANY TIMEOUT FOR PORT
	RBT	R11,APORTS		:ACTIVE PORT BIT ARRAY FOR FG TASK
	RBT	R11,APORTM		:  "    "    "   " FOR IRING HNDLR
	L	R14,ATCHDQ,,		:GET 1ST ON QUEUE
	JE	ATQBAD			:ERROR IF NOTHING ON QUEUE
	CR	R14,R15			:REMOVING 1ST ON QUEUE?
	JE	CMPLZ0			:JUMP IF SO

:	SEARCH ATCHDQ FOR PST TO REMOVE

CMPLZ1	LR	R12,R14			:R12 IS CURRENT 'PREVIOUS' PST
	L	R14,ATCHNX,R12,		:R14 IS CURRENT 'NEXT' PST
	JE	ATQBAD			:ERROR IF NOT FOUND
	CR	R15,R14			:IS THIS IT?
	JNBS	CMPLZ1			:NO, GET NEXT

:	R14 = PST TO REMOVE

	L	R9,ATCHNX,R14,		:GET NEXT PST AFTER R14
	JEFS	CMPLZ2			:IF 'NEXT' IS 0, R14 IS LAST ON QUE

:	PST TO REMOVE IS IN MIDDLE OF ATCHDQ

	ST	R9,ATCHNX,R12,		:LINK AHEAD
	ST	R12,ATCPRV,R9,		:LINK BACK
	CMPLZX				:EXIT 

:	REMOVING LAST ON QUEUE--IF ONLY 1 LEFT ON QUEUE, CLEAR ATCQND

CMPLZ2	C	R12,ATCHDQ,,		:IF 'PREVIOUS' = 1ST, ONLY 1 ON QUE
	JEFS	CMPLZ3			:JUMP IF ONLY 1 LEFT
	ST	R12,ATCQND,,		:ELSE UPDATE END-OF-QUEUE PTR
	ST	R9,ATCHNX,R12,		:CLEAR NEXT FIELD OF LAST-ON-QUE
	CMPLZX				:EXIT 

CMPLZ3	ST	R9,ATCQND,,		:CLEAR END-OF-QUE PTR
	ST	R9,ATCHNX,R12,		:CLEAR 'NEXT' FIELD OF REMAINING PST
	CMPLZX

:	REMOVING THE FIRST-ON-QUEUE

CMPLZ0	L       R9,ATCHNX,R14,          :NEXT-ON-QUE BECOMES 1ST ON QUE
	ST	R9,ATCHDQ,
        C       R9,ATCQND,,             :WAS NEW 1ST THE PREVIOUS E-O-Q?
        JEFS    CMPLZ4                  :JUMP IS SO
        CMPLZX

CMPLZ4  LIS     R9,0                    :CLEAR END OF QUE PTR
        ST      R9,ATCQND,,
        CMPLZX

ATQBAD  RESET(R13,CCATCQ)

:	CHECK USED BUFFER COUNTS
:	COMPARES USED BUFFER COUNT FOR EACH BUFFER TYPE WITH A 'HIGH-WATER
:	MARK' THAT DENOTES THE HIGHEST USED BUFFER LEVEL REACHED FOR EACH
:	BUFFER TYPE.  IF USED COUNT >= HIGH-WATER MARK, HIGH-WATER MARK
:	IS GIVEN THE VALUE OF USED BUFFER COUNT
:	CALLED BY SRDONE, WHEN USED BUFFER COUNTS ARE LIKELY TO BE HIGHEST

	SEG	A.DATA
CHUBSV	WS	1
	SEG	A.CODE
CHKUBC	ST	R13,CHUBSV,,
	LH	R1,B1USED,,
	CH	R1,HWMBF1,,
	JLFS	CHKUB2
	STH	R1,HWMBF1,,	:UPDATE HI-WATER MARK IF USED CNT >= H.W.M.
CHKUB2	LH	R1,B2USED,,
	CH	R1,HWMBF2,,
	JLFS	CHKUB3
	STH	R1,HWMBF2,,
CHKUB3	LH	R1,B3USED,,
	CH	R1,HWMBF3,,
	JLFS	CHKUB0
	STH	R1,HWMBF3,,
CHKUB0	L	R13,CHUBSV
	JR	R13
   

:%^%^^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%%^%^%^%^%^%^%^%^%^%^
:#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$$#$#$#$#

:	FILE   -   UTLRTN.MBS   

:	U T I L I T Y     S U B R O U T I N E S


:	This file contains general purpose subroutines, used by
:	Mbase.

	SUBTTL	UTLRTN.MBS  - MBASE UTILITY SUBROUTINES
:$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


:	S U B R O U T I N E    N X T O N Q


:	This subroutine provides the address of next entry on a queue.
:	The calling sequence is:

:		JAL   R13,NXTONQ

:	Inputs:
:		R4 = Address of the pointer to the top of the queue
:		R5 = Address of the buffer preceeding the one we want
:		     (usually the currently used buffer), or 0 if the
:		     first buffer is desired.
:		R6 = Offset within the buffer of the pointer to the
:		     next queue entry.

:	Outputs:
:		R15 = Address of the next buffer on the, or 0 if at
:		     the end of the queueD (CC=0).


	SEG	A.CODE
	GL	NXTONQ

NXTONQ	L	R3,0,R4			:is there a queue ?
	JNFS	NOQ3			:if so - jump
	LIS	R15,0			:if not - that's all
	JR	R13
NOQ3	LR	R5,R5			:check the input buffer
	JNFS	NOQ5
	LR	R15,R3			:addr of 1st item on queue
	JR	R13
NOQ5	L	R15,0,R6,R5		:addr of next item on queue
	JR	R13





:	S U B R O U T I N E    D N D S N G


:	This subroutine removes a singly linked item from a queue,
:	and deallocates it by returning it to an available queue.
:	Items can only be removed from the top of the queue.
:	The calling sequence is:

:		JAL   R13,DNDSNG

:	Inputs:
:		R8  = PST address, or zero if none
:		R14 = Address of the top of queue pointer
:		R15 = Offset of the pointer which points to the next
:		      queue entry.

:	Outputs:
:		R15 = Address of the new first entry of the queue,
:		      or 0 if the queue is empty (CC=0). 


	SEG	A.CODE
	GL	DNDSNG

DNDSNG	STM	R12,SAVSNG,,		:save the registers
	L	R6,0,R14		:anything on the queue ?
	JNFS	DNS3			:if so - proceed
	LIS	R12,0			:if not - end of queue
	J	DNSEND
DNS3	L	R12,0,R15,R6		:get addr of next buf
	ST	R12,0,R14		:update top of q ptr
	LB	R5,BUFTYP,R6		:get buf type
	JAL	R13,RETBUF		:return buf to avail queue
DNSEND	LR	R2,R12
	LM	R12,SAVSNG,,		:restore regs
	LR	R15,R2			:fill in return & set CCs
	JR	R13


	SEG	A.DATA
SAVSNG	WS	4			:register save area





:	S U B R O U T I N E    D E Q P S T
 

:	This subroutine removes a PST from a queue.  Items can
:	be removed from any position in the queue.
:	The calling sequence is:

:		JAL	R13,DEQPST

:	Inputs:
:		R10 = Address of the pointer to the bottom of the queue
:		R14 = Address of the pointer to the top of the queue.
:		R15 = Address of the buffer to remove, or 0 to 
:		      remove the first queue entry.
:		R12 = Offset to the pointer of the next queue entry
:		      (R12 + 4 contains the pointer to the previous
:		      queue entry).
:	Outputs:
:		R15 = address of the next queue entry, or 0 if end of
:		      queue (CC=0).


	SEG	A.CODE
	GL	DEQPST

DEQPST	STM	R10,SAVDBL,,		:save the regs
	L	R3,0,R14		:anything on the queue ?
	JNFS	DNDD3			:if so - proceed
	LIS	R2,0			:else - bye
	J	DNDD10
DNDD3	LR	R15,R15			:if buf addr = 0, do 1st entry
	JN	DNDD7			:else - jump

:	remove the 1st entry from the queue
DNDD5	L	R6,0,R14		:get addr of 1st queue entry
	L	R2,0,R12,R6		:get addr of next queue entry
	ST	R2,0,R14		:make it new top of queue
	C	R2,0,R10		:does new top = end of queue ?
	JNFS	DNDD6			:if not - proceed normally
	LIS	R3,0			:else - queue has only 1 entry...
	ST	R3,0,R10		:...so zero the end of queue
	J	DNDEND
DNDD6	LR	R6,R2
	J	DNDD10			:go update end of queue ptr

DNDD7	C	R15,0,R14		:is this the 1st entry on queue ?
	JE	DNDD5			:if so - go process it

:	remove an entry from the queue, other than the first
	L	R5,0,R12,R15		:addr of next buf in q
	L	R6,4,R12,R15		:addr of previous buf in q
	ST	R5,0,R12,R6		:put next buf addr in prev buf
	LR	R5,R5			:if no next buf - don't store there
	JEFS	DNDD8
	ST	R6,4,R12,R5		:put prev buf addr in next buf
DNDD8	LR	R2,R5			:return addr of next buf

:	update the pointer to the end of the queue
DNDD10	C	R15,0,R10		:entry being removes the last on q ?
	JN	DNDEND			:if not - proceed normally
	C	R6,0,R14		:does queue now have only 1 entry ?
	JNFS	DNDD14			:if not - jump
	LIS	R6,0			:if so - zero pointer
DNDD14	ST	R6,0,R10		:update the end of queue ptr

DNDEND	LIS	R6,0			:zero the next & previous pointers...
	ST	R6,0,R12,R15		:...of the removed PST
	ST	R6,4,R12,R15

	LM	R10,SAVDBL,,		:restore regs
	LR	R15,R2			:load return value & set CCs
	JR	R13


	SEG	A.DATA
SAVDBL	WS	6			:register save area




:	S U B R O U T I N E    D N D T Y 2


:	This subroutine removes a type 2 message from a queue,
:	and returns it to the available buffer queue.  Items can
:	be removed from any position in the queue.
:	The calling sequence is:

:		JAL	R13,DNDTY2

:	Inputs:
:		R14 = Address of the pointer to the top of the queue.
:		R15 = Address of the buffer to remove, or 0 to 
:		      remove the first queue entry.
:		R12 = Offset to the pointer of the next queue entry
:		      (R12 + 4 contains the pointer to the previous
:		      queue entry).
:	Outputs:
:		R15 = address of the next queue entry, or 0 if end of
:		      queue (CC=0).


	SEG	A.CODE
	GL	DNDTY2

DNDTY2	STM	R11,SA2DBL,,		:save the regs
	L	R3,0,R14		:anything on the queue ?
	JNFS	DND3			:if so - proceed
	LIS	R2,0			:else - bye
	J	DN2END
DND3	LR	R15,R15			:if buf addr = 0, do 1st entry
	JN	DND7			:else - jump

:	remove the 1st entry from the queue
DND5	L	R6,0,R14		:get addr of 1st queue entry
	L	R11,0,R12,R6		:get addr of next queue entry
	ST	R11,0,R14		:make it new top of queue
	LIS	R5,2			:buf type
	JAL	R13,RETBUF		:return buf to avail queue
	LR	R2,R11
	J	DN2END			:bye bye

DND7	C	R15,0,R14		:is this the 1st entry on queue ?
	JE	DND5			:if so - go process it

:	remove an entry from the queue, other than the first
	L	R11,0,R12,R15		:addr of next buf in q
	L	R6,4,R12,R15		:addr of previous buf in q
	ST	R11,0,R12,R6		:put next buf addr in prev buf
	ST	R6,4,R12,R11		:put prev buf addr in next buf
	LIS	R5,2			:buf type
	JAL	R13,RETBUF		:return buf to avail queue
	LR	R2,R11			:return addr of next buf

DN2END	LM	R11,SA2DBL,,		:restore regs
	LR	R15,R2			:load return value & set CCs
	JR	R13


	SEG	A.DATA
SA2DBL	WS	5			:register save area




:	S U B R O U T I N E    R E T B U F


:	This subroutine is called as an intermediatry step in
:	releasing a message buffer - either type 1, 2, or 3.  It
:	does not have to be called if the user wants to call
:	RETBF1 or RETBF3 directly.
:	The calling sequence is:

:		JAL	R13,RETBUF

:	Inputs:
:		R5 = buffer type (1, 2, or 3)
:		R6 = buffer address
:		R8 = address of the PST, or zero if none

	SEG	A.CODE
	GL	RETBUF

RETBUF	ST	R13,RETSAV,,			:save link reg
	LR	R6,R6				:is there really a buf ?
	JE	XRET6				:if not - bye
	CHI	R5,BUFTP1			:which buf type
	JNFS	XRET2
	JAL	R13,RETBF1,,
	JFS	XRET6
XRET2	CHI	R5,BUFTP2
	JNFS	XRET4
	JAL	R13,RETBF2,,
	JFS	XRET6
XRET4	JAL	R13,RETBF3,,
XRET6	L	R13,RETSAV,,
	JR	R13


	SEG	A.DATA
RETSAV	WS	1




:	S U B R O U T I N E    G T S R W S


:	This subroutine gets an SRB and a type 1 buffer, and
:	writes the address of the type 1 buffer into the
:	"address of data" halfword (ADRMSB) and full word (BUFADR)
:	of the SRB.
:	The calling sequence is:

:		JAL    R13,GTSRWB

:	Inputs:
:		R8 = address of the PST, or zero if none
:	The outputs are:
:		R6 = address of the SRB
:		R7 = address of the type 1 buffer


	SEG 	A.CODE
	GL	GTSRWB

GTSRWB	ST	R13,GTSAV,,			:save the link reg
	JAL	R13,GETBF1			:get a buf 1
	LR	R7,R6
	JAL	R13,GETBF2			:get an SRB (buf 2)
	ST	R7,BUFADR,R6			:buf addr - for Mbase
	AIS	R7,B1DATA			:inc past hdr to data
	STH	R7,ADRMSB,R6			:buf addr - for Spirit 
	SIS	R7,B1DATA
	L	R13,GTSAV,,
	JR	R13


	SEG	A.DATA
GTSAV	WS	1



:$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$
:^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^*^

            SUBTTL  Mbase Event Trace Module 

        MO      .,TRACE
EDATA   EQ      0                        :OFFSET TO DATA IN AN EVENT RCRD

        SEG     A.DATA
        BND     2
THISEC  HS      1
        SEG     A.CODE
PRMOFS	BC	0,0,0,4,8,0C,10
BYTOFS  BC      0,3,2,1,0
ASCTBL  BC      0B0,0B1,0B2,0B3,0B4,0B5,0B6,0B7,0B8,0B9,0C1,0C2,0C3,0C4,0C5,0C6
CRLFMG  SC      /"8D"8A/
TIMSTR	SC	/ TIME=/


:       TABLE OF OUTPUT HEADERS
OPST|ET.IOQ| SC  /PUT IORQ  /
PHDR    EQ      .-OPST|ET.IOQ|
SUBHD1  SC      / CHN=/
SHDR    EQ      .-SUBHD1
        SC      / REQ=/
        SC      / SB1=/
OPST|ET.SRQ| SC  / PUT SRQ  /
        SC      / LKR=/
	SC	/ CHN=/
        SC      / SRB=/
        SC      / CNT=/
        SC      / SB0=/
OPST|ET.GB1| SC  / GETBUF1  /
        SC      / LKR=/
        SC      / ADR=/
        SC      / USD=/
	SC	/ 1ST=/
OPST|ET.GB2| SC  / GETBUF2  /
        SC      / LKR=/
        SC      / ADR=/
        SC      / USD=/
	SC	/ 1ST=/
OPST|ET.GB3| SC  / GETBUF3  /
        SC      / LKR=/
        SC      / ADR=/
        SC      / USD=/
	SC	/ 1ST=/
OPST|ET.RB1| SC  / RETBUF1  /
        SC      / LKR=/
        SC      / ADR=/
        SC      / USD=/
	SC	/ 1ST=/
OPST|ET.RB2| SC  / RETBUF2  /
        SC      / LKR=/
        SC      / ADR=/
        SC      / USD=/
	SC	/ 1ST=/
OPST|ET.RB3| SC  / RETBUF3  /
        SC      / LKR=/
        SC      / ADR=/
        SC      / USD=/
	SC	/ 1ST=/

OPST|ET.XRS| SC  /XTRA RST  /

OPST|ET.ISD| SC  /ISIS DRVR /
        SC      / LKR=/
        SC      / ERR=/
        SC      / BUF=/
OPST|ET.RST| SC  /   RESET  /
        SC      /  CC=/
OPST|ET.MSG| SC  /    ?MSG  /
        SC      / PRT=/
        SC      / MSG=/

OPST|ET.TOP| SC  /PUT TOUT  /
        SC      / PST=/
        SC      / TMO=/
OPST|ET.TOG| SC  /GET TOUT  /
        SC      / PST=/
OPST|ET.BPO| SC  / BKPR ON  /
        SC      / LKR=/
        SC      / PST=/
        SC      / FLG=/
OPST|ET.BPF| SC  / BKP OFF  /
        SC      / LKR=/
        SC      / PST=/
        SC      / FLG=/
OPST|ET.ZB1| SC  /ZAP BUF1  /
        SC      / PST=/
OPST|ET.ZB3| SC  /ZAP BUF3  /
        SC      / PST=/
OPST|ET.FB2| SC  /FREE BF2  /
OPST|ET.OPQ| SC  / OPQ NXT  /
        SC      / PST=/
        SC      / BUF=/
        SC      / LEN=/
        SC      / FLG=/
OPST|ET.QBP| SC  / QB&PST   /
        SC      / LKR=/
        SC      / PST=/
        SC      / BUF=/
        SC      / FLG=/

:       EVENT TRACE PARAMETER TABLE
:       1ST HLFWRD = EVENT TYP
:       NEXT 5 BYTES = LENGTH OF EACH OF 5 POSSIBLE PARAMETERS 
:       (LENGTH BYTES MUST BE 'BC' OF 2 OR 4)
:       TOTAL OF LENGTH BYTES MUST NOT EXCEED DECIMAL 10
:       NEXT WORD = ADDR OF OUTPUT HEADER FOR EVENT

        BND     4
ETPRMT	HC	ET.IOQ			:PUT IOREQUEST ON IORQ
	BC	2,2,2,0,0,0
	WC	OPST|ET.IOQ|
ETPTLN  EQ      .-ETPRMT				

	HC	ET.SRQ			:PUT SRB ON SRQUEUE	
        BC      2,2,2,2,2,0
	WC	OPST|ET.SRQ|

	HC	ET.GB1			:GETBUF TYPE 1
        BC      2,4,2,2,0,0
	WC	OPST|ET.GB1|

	HC	ET.GB2			:GET BUFFER 2
        BC      2,4,2,2,0,0
	WC	OPST|ET.GB2|

        HC      ET.GB3
        BC      2,4,2,2,0,0
        WC      OPST|ET.GB3|

        HC      ET.RB1
        BC      2,4,2,2,0,0
        WC      OPST|ET.RB1|

        HC      ET.RB2
        BC      2,4,2,2,0,0
        WC      OPST|ET.RB2|

        HC      ET.RB3
        BC      2,4,2,2,0,0
        WC      OPST|ET.RB3|

        HC      ET.XRS                  :REDUNDANT RESET INTERFACE
        BC      0,0,0,0,0,0
        WC      OPST|ET.XRS|

        HC      ET.ISD                  :ISIS-DRIVER DISCOVERED ERROR
        BC      2,4,4,0,0,0
        WC      OPST|ET.ISD|

        HC      ET.RST                  :RESET INTERFACE
        BC      2,0,0,0,0,0
        WC      OPST|ET.RST|
        
        HC      ET.MSG                  :UNKNOWN CIRCUIT SGNL MSG
        BC      2,2,0,0,0,0
        WC      OPST|ET.MSG|

        HC      ET.TOP                  :PUT TIMEOUT BLOCK ON TIMOUT QUE
        BC      4,4,0,0,0,0
        WC      OPST|ET.TOP|

        HC      ET.TOG                  :GET (CANCEL) TIMEOUT BLOCK
        BC      4,0,0,0,0,0
        WC      OPST|ET.TOG|

        HC      ET.BPO                  :MBASE WANTS BACKPRESSURE
        BC      2,2,4,0,0,0
        WC      OPST|ET.BPO|

        HC      ET.BPF                  :MBASE WANTS BACKPRESSURE OFF
        BC      2,2,4,0,0,0
        WC      OPST|ET.BPF|

        HC      ET.ZB1
        BC      4,0,0,0,0,0
        WC      OPST|ET.ZB1|

        HC      ET.ZB3
        BC      4,0,0,0,0,0
        WC      OPST|ET.ZB3|

        HC      ET.FB2
        BC      0,0,0,0,0,0
        WC      OPST|ET.FB2|

        HC      ET.OPQ
        BC      2,2,2,4,0,0
        WC      OPST|ET.OPQ|

        HC      ET.QBP
        BC      2,2,2,4,0,0
        WC      OPST|ET.QBP|
ETPTND  EQ      .-ETPRMT

PLBYT 	EQ	2			:OFFSET TO LENGTH BYTES IN PARM TBL
EVTHDR	EQ	8
ONEBYT  EQ      $A 14                   

:       INIT EVNT TRACE TABLE SPACE -- LINK ON R4
EVTIZ   EQ      .                       :INITIALIZE EVENT TRACE TBLE
        L       R1,EVNTBL,,             :GET CURRENT EVENT TBL ADDR
        JEFS    EVTIZ0                  :IF 0, GET EVTBL0 ADDR
        AI      R1,EVTBSZ               :ELSE INCREMNT ADDRESS
        CLI     R1,EVTEND               :END OF TABLE SPACE?
        JNFS    EVTIZ1
EVTIZ0  LA      R1,EVTBL0,,             :WRAP TO FIRST TABLE ADDR
EVTIZ1  ST      R1,EVNTBL,,
        ST      R1,SELETB
        TS      CURVTB
        LIS     R2,0
EVTIZ3  LHL     R3,EVTBTB,R2,R2
        NHI     R3,7FFF
        CR      R1,R3
        JEFS    EVTIZ4
        AIS     R2,1
        JBS     EVTIZ3
EVTIZ4  STH     R3,EVTBTB,R2,R2
        SIS     R2,1
        JGEFS   EVTIZ5
        LHI     R2,NEVTBL-1
EVTIZ5  LHL     R0,EVNEXT
        STH     R0,EVIXTB,R2,R2         :EVENT IDX FOR THIS TABLE
        LH      R0,WRAPED
        STH     R0,EVWRTB,R2,R2         :WRAPPED FLAG FOR THIS TABLE
        LHL     R0,EVTCNT       
        STH     R0,EVCNTB,R2,R2         :EVNT COUNT FOR THIS TABLE
        LIS     R0,0
        STH     R0,EVNEXT
        STH     R0,WRAPED
        STH     R0,EVTCNT
        LIS     R2,0
EVTIZ2  STB     R0,0,R1,R2
        AIS     R2,1
        CLHI    R2,EVTBSZ
        JNBS    EVTIZ2
        JR      R13


EVTRAC  EQ      .
:       USE EVT MACRO TO CALL
        LI      R15,ETPTND-ETPTLN       :OFFSET TO LAST ENTRY ON ET PARM TBL
EVTRA0	CLH	R9,ETPRMT,R15,		:R9=ETC
	JEFS	EVTRA1			:GOT TABLE ENTRYH FOR ET CODE
	SI	R15,ETPTLN		:DECREMNT OFFSET
	JGEBS	EVTRA0
	JAL	R10,CRASH,,		:NO MATCH OF EVENT CODE
	BC	0,0,4*R6,CCEVT1
EVTRA1  L       R11,EVNTBL,,            :GET CURRENT EVNT TABLE ADDRE
        LHL     R12,EVNEXT,,            :GET CURRENT TABLE IDX
        LIS     R5,0
        STH     R9,EDATA,R11,R12         :STORE EVENT TRACE CODE
        AIS     R12,2                   :INCREMENT 
        AIS     R5,2

      	LHI     R14,PLBYT               :GET OFFSET TO 1ST PARAM LEN BYT
EVTRA2	LB	R13,ETPRMT,R14,R15	:GET LENGTH BYTE
	JE 	EVTRA4                  :IF 0, NO MORE PARAMS
	LB	R10,PRMOFS,R14,		:GET OFFSET TO PARAMETER STORAGE
	LB	R9,BYTOFS,R13,		:BYTE OFFSET BASED ON # BYTES IN PARAM
EVTRA3	LB	R8,ETPARM,R9,R10	:GET PARAM BYTE
	STB	R8,EDATA,R11,R12	:STORE IN EVENT TRACE TABLE
	AIS	R12,1			:INCREMENT IDX
	AIS	R9,1			:INCREMNT BYTE POINTER
	AIS	R5,1
	CLHI	R9,4			:DONE?
	JNBS	EVTRA3
	AIS	R14,1			:INCREMNT OFFSET INTO ETPRMT ENTRY
	J	EVTRA2			:AND GET NEXT PARAMETER ( OR EXIT)

EVTRA4	ST	R7,EDATA,R11,R12        :STORE TIME (OR A 0 IF NO TIME-STAMP)
	AIS	R12,4			:BUMP IDX
	AIS	R5,4
        LHI     R11,EVNTSZ
        SR      R11,R5
        AR      R12,R11
        CLHI    R12,EVTBSZ              :END OF TABLE?
        JNFS    EVTFIN
        TS      WRAPED
        LHI     R12,NEVNTS
        STH     R12,EVTCNT,,
        LIS     R12,0
EVTFIN  STH     R12,EVNEXT,,
        LH      R12,WRAPED
        JEFS    NOWRAP
        JR      R6
NOWRAP  LHL     R12,EVNEXT,,
        SRLS    R12,4                   :MAKE INDEX INTO EVNT CNT
        STH     R12,EVTCNT,,
        JR      R6


:       GETEVT -- GET TRACE EVENT(S)
:       LINK ON R4
:       R6 CONTAINS NUMBER OF EVENTS TO READ
GETEVT  LR      R6,R6                   :IF 0, GET OUT
        JER     R4
	L	R11,SELETB
	LHL	R7,SELCNT
	JER	R4
	CR	R6,R7			:CMPARE W/ REQUESTED CNT
	JGE	GEVIX0			:JUMP IF WANT MORE THAN GOT
	LR	R7,R6			:R7 IS COUNTER
	LHL	R12,SELNXT    		:GET PTR TO OLDEST (NEXT NEW)
GEVIX4	SHI	R12,EVNTSZ		:DECREMENT BACK TO START
	JGEFS	GEVIX5
	LHI	R12,EVTBSZ-EVNTSZ-EDATA	:WRAP AROUND
GEVIX5	SIS	R6,1			:DECRMNT REQUESTED COUNT
	JNBS	GEVIX4
	JFS	GETEV3			:GOT YOUR STARTING POINT
GEVIX0	LH	R12,IFWRAP  		:TABLE WRAPED?
	JLFS	GEVIX1			:YES, IDX WILL BE NEXT PTR
GEVIX3	LIS	R12,0			
	JFS	GETEV3
GEVIX1	LHL     R12,SELNXT

GETEV3	LH	R5,EDATA,R11,R12	:GET EVENT CODE
        STH     R5,THISEC               :SAVE THIS EVENT CODE
        LIS     R8,0
	LHL	R15,SPEVNT,,		:GETTING A SPECIFIC EVENT?
	JEFS	PRNTIT			:NO, PRINT IT
	CLR	R5,R15			:IS THIS IT?
	JEFS	PRNTIT			:YES, PRINT IT
	TS	SKIPIT,,		:SET SKIPIT FLAG

PRNTIT	LI	R15,ETPTND-ETPTLN	:OFFSET TO LAST ENTRY ON ET PARM TBL
	LI	R15,ETPTND-ETPTLN	:OFFSET TO LAST ENTRY ON ET PARM TBL
GETEV4	CLH	R5,ETPRMT,R15,		:AND GET CORRESPNDING PARAM TABLE
	JEFS	GETEV5
	SI	R15,ETPTLN		:DECREMENT PARAM TBL LEN
	JGEBS	GETEV4			:GET NEXT ON TABLE
	JAL	R10,CRASH,,		:NO MATCH, CRASH
	BC	0,0,R4*4,CCGTEV
GETEV5  L       R10,ETPRMT+EVTHDR,R15,  :GET HEADER STRING ADDR
        LH      R1,SKIPIT,,
        JNFS    GETE11
      	SVC	K.OUT,0,R10
GETE11	AIS	R12,1			:INCREMENT EVENT TABLE IDX
        AIS     R8,1
        LIS     R14,0                   :INIT OFFSET TO PARAM LEN BYT
        AHI     R10,PHDR-SHDR           :INCRMNT STRING ADDR
GETEV6	LB	R13,ETPRMT+PLBYT,R14,R15 :GET LENGTH BYTE
	JE	GETEV8			:END OF EVENT TABLE
        AHI     R10,SHDR                :INCRMNT SUBHDR OFFSET
        LH      R1,SKIPIT,,
        JNFS    GETEV7
	SVC	K.OUT,0,R10             :PRINT PARAM HEADER
GETEV7  AIS     R12,1                   
        AIS     R8,1
      	LB	R2,EDATA,R11,R12        :GET PARAMETER BYTE
        JE      CHKIF2                  :CHECK IF EVENT CODE 2
GTHAN0  TS      NONZRO,,
        JAL     R3,SNDBYT
        JFS     CHKNZ1
CHKNZR  LH      R0,NONZRO,,
        JEFS    CHKNZ1
        JAL     R3,SNDBYT,,
CHKNZ1	SIS	R13,1			:DECREMENT PARAM BYTE COUNTER
	JN	GETEV7
        LH      R3,NONZRO,,
        JEFS    CHKNZ2                  :IF PARAM = 0, PRINT IT
        STH     R13,NONZRO,,
	AIS	R14,1			:INCRMNT OFFSET INTO PARAM BYTE
	J	GETEV6
CHKNZ2  JAL     R3,SNDBYT
        STH     R13,NONZRO,,
        AIS     R14,1
        J       GETEV6

:       CHECK IF IT'S EVENT CODE 2, IF SO CHECK IF IT'S STATUS BYTE PARAM
CHKIF2  LHL     R1,THISEC               :GET THIS EVENT CODE
        CLHI    R1,ET.SRQ               :TYPE 2?
        JN      CHKNZR                  :JUMP IF NOT
        CLHI    R14,4                   :LAST PARAM? (STATUS BYTE0-1)
        JN      CHKNZR                  :JUMP IF NOT
        J       GTHAN0                  :PRINT BOTH, EVEN IF 0

:       IF THERE IS A TIME-STAMP, PRINT IT
GETEV8  AIS     R12,1
        AIS     R8,1
        L       R2,EDATA,R11,R12 
        JNFS    GTMHDR
        AIS     R12,4
        AIS     R8,4
        J       GETEV9
GTMHDR  LH      R1,SKIPIT,,
        JN      GETE12
        SVC     K.OUT,TIMSTR,,
GETE12  LIS     R13,4
GEVTIM  LB      R2,EDATA,R11,R12
        JAL     R3,SNDBYT
        AIS     R12,1
        AIS     R8,1
        SIS     R13,1
        JNBS    GEVTIM
GETEV9  LH      R1,SKIPIT,,
        JNFS    GETE10
        SVC     K.OUT,CRLFMG,,
GETE10  LIS     R13,0
        STH     R13,SKIPIT,,
        LHI     R13,EVNTSZ
        SR      R13,R8
        AR      R12,R13
        SIS     R7,1                    :DECREMNT COUNT OF EVNTS
        JER     R4                      :RETURN
        CLHI    R12,EVTBSZ-EDATA        :END OF TABLE?
        JN      GETEV3                  :NO
        LIS     R12,0                   :YES, WRAP INDEX
	J	GETEV3 			:GET NEXT EVENT RECORD

        GL      SNDBYT
SNDBYT  EQ      .
:       CONVERTS EACH NIBBLE OF BYTE IN R2 TO ASCII AND SENDS IT
:       LINK ON R3
        LH      R1,SKIPIT,,
        JNR     R3
        LR      R1,R2
        NHI     R1,0F0
        SRLS    R1,4
        LB      R0,ASCTBL,R1,
        SVC     KIO,ONEBYT
SNDBY0  LR      R1,R2
        NHI     R1,0F
        LB      R0,ASCTBL,R1,
        SVC     KIO,ONEBYT
        JR      R3

        EM



           SUBTTL  MBASE Foreground Job -- IOCB Scanner Task
        
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			EQUATES                            ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


SIOTYP  EQ      1               :SIO EVENT TYPE
HIOTYP  EQ      -1              :HIO EVENT TYPE

:       IORQ    
NIORB   EQ      100             :NMBR OF IO REQ. BLKS IN IORQ
IORBLN  EQ      2               :2 BYTES IN EACH IO REQ.BLK
IORQSZ  EQ      IORBLN*NIORB    :NUMBER OF BYTES IN IORQ RING
IONFMI  EQ      0
IOCEI   EQ      2
IORING  EQ      4
:       IORB OFFSETS
IORT    EQ      0               :REQUEST TYPE (SIO, HIO, OR ERROR)
IOCHNL  EQ      1

:	I/O CONTROL BLOCK OFFSETS
SIO	EQ	1		:SIO BYTE 
HIO	EQ	3		:HIO BYTE 
CMD     EQ      5               :I/O COMMAND BYTE
SIGB1   EQ      7               :SIGNAL BYTE 1
SIGB2   EQ      9               :SIGNAL BYTE 2
SIGB3   EQ      $A 11           :SIBNAL BYTE 3
CBDATA  EQ      $A 13           :DATA BYTES
CB.MSB  EQ      $A 15           :LENGTH--MOST SIGNIFICANT BYTE
CB.LSB  EQ      $A 17           :LENGTH--MOST SIGNIFICANT BYTE
CSBYTE  EQ      $A 31           :CONTROLLER STATUS BYTE

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              VARIABLE STORAGE                          ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        SEG     A.DATA

        BND     4
HIOTMR  WS      1
IORQ    HS      2               :IONFMI,IOCEI OF IORQ RING
        BS      IORQSZ         

:       PORT STATUS TABLES

Q       EQ      0
IN      EQ      3               :INPUT CHANNEL FOR PORT 0
OUT     EQ      2               :OUTPUT CHANNEL FOR PORT 0
        BND     4
        RE      NPORT+1
        GL      PSTB|Q|
PSTB|Q| EQ     .
        ORG     PSTB|Q|+PORT
        BC      Q
        ORG     PSTB|Q|+OUTCHN         :OUTPUT CHANNEL NUMBER FOR THIS PORT
        BC      OUT
        ORG     PSTB|Q|+INCHNL         :INPUT CHANNEL NUMBER FOR THIS PORT
        BC      IN
        ORG     PSTB|Q|+OPIOCB
        WC      IOCB|OUT|               :ADDR OF OUTPUT IOCB FOR THIS PORT
        ORG     PSTB|Q|+INIOCB
        WC      IOCB|IN|                :ADDR OF INPUT IOCB FOR THIS PORT
        ORG     PSTB|Q|+PSTLEN
Q       EQ      Q+1
IN      EQ      IN+2
OUT     EQ      OUT+2
        ER
        GL      PSTEND
PSTEND  EQ      .

	SEG	A.CODE

:	HANDY INDEXABLE HALFWORD BIT MASKS
HMASK	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1


C1ONLY	TS	SUSPND		:SET THE SUSPEND FLAG
:	WHILE IN SUSPEND MODE, THE FG JOB WILL ONLY SCAN FOR SIO ON CHANL 1
C1ONL0	SVC	DISMISS
	LB	R3,IOCB1+SIO,,	:CHECK FOR SIO ON CHNL 1
	JEBS	C1ONL0		:NOTHING
	CLHI	R3,80		:ALREADY PROCESSING AN SIO?
	JEBS	C1ONL0		:YES, GET OUT
	LIS	R6,1		:CHNL 1 IN R6
	CLHI	R3,1		:MAKE SURE THE SIO BYTE IS NOTHING BUT 1
	JN	CH1ERR		:REPORT BAD DATA IN SIO IF NOT 1
	LA	R2,IOCB1,,	:GET ADDR OF IOCB 1
	JAL	R13,QSIORB	:ENQUE AN IORB FOR THIS SIO
	LB	R2,IOCB1+CMD,,	:GET CMD 
	CLHI	R2,RESUMB	:CHECK IF RESUME CMD
	JN	C1ONL0		:STAY IN THIS LOOP IF NOT
	LIS	R2,0		:ELSE CLEAR THE MBASE SUSPEND FLAG
	STH	R2,SUSPND
	J	FGLOOP		:AND JUMP TO THE NORMAL FG JOB LOOP

	
	
IOCBST  JAL     R13,SETMAC              :SET-UP EXTENDED MAC 
        J       FGLOOP+4

CH1ERR  LR      R5,R3                   :PUT ERROR DATA IN R5
        LA      R2,IOCB1,,
        JAL     R13,QSIOR0
        J       CHKHIO                  :GO CHECK HIO TIMER
:       CHECK CHANNEL 1 FOR SIO INDICATION
CHKCH1  LB      R3,IOCB1+SIO,,
        JE      TIMCHK                  :IF 0, GO CHECK HIO TIMER
        CLHI    R3,80                   :A PENDING SIO?
        JE      TIMCHK                  :YES, IGNORE
        LIS     R6,1                    :CHANNEL NMBR IN R6
        CLHI    R3,1                    :A VALID SIO REQUEST?
        JN      CH1ERR                  :NO--ENQUE AN SRB W/ ERROR DATA
        LA      R2,IOCB1,,              :IOCB ADDR IN R2
        JAL     R13,QSIORB              :ENQUEUE AN IORB FOR THIS SIO
        LB      R2,IOCB1+CMD,,          :CHECK THIS SIO CMD
        CLHI    R2,SUSPMB               :IS IT THE SUSPEND CMD?
        JE      C1ONLY                  :IF SO, JUMP TO SUSPEND MODE LOOP

:	IS IT TIME TO CHECK FOR HIO?

TIMCHK	L	R1,FASTC,,		:GET CURRENT TIME
	L	R2,HIOTMR,,		:GET TIME OF LAST HIO CHECK
	SR	R1,R2			
	CLHI	R1,$A 2400		:4 SECONDS ELAPSED?
        JGE     CHKHIO                  :YES, GO CHECK HIO BYTES

:	IOCB SCANNER TASK -- FOREGROUND JOB

FGLOOP	SVC	DISMISS			:DISMISS EACH TIME THRU LOOP

:	SCAN APORTS BIT ARRAY FOR ATTACHED (FROM SBUS POINT-OF-VIEW) PORTS
	LHI	R12,(NGRP-1)*2		:SEARCH BY PORT GROUPS
PRTSCN	LH	R11,APORTS,R12,		:GET A GROUP
	JNFS	PRTSC2			:THERE'S SOMETHING TO CHECK
PRTSC1	SIS	R12,2			:DECREMENT
	JGEBS	PRTSCN			:REPEAT FOR ALL GROUPS
        J       CHKCH1                  :CHECK CHANNEL (IOCB) 1

PRTSC2	LR	R7,R11			:COPY MASK OF PORTS TO PROCESS
	JEBS	PRTSC1			:NO MORE...GO ON TO NEXT GROUP
	JFFOH	R7,PRTSC3		:GET NEXT PORT BIT IN GROUP
        RESET(R13,CCJFFO)               :WE'VE GOT A PROBLEM IF NONE
PRTSC3	XH	R11,HMASK,R8,R8		:CLEAR EXAMINED PORT BIT
        LR      R6,R12                  :GET COPY OF NGRP OFFSET
        SLLS    R6,3                    :MAKE INTO 'BASE' PORT NMBR FOR GROUP
        AR      R8,R6                   :(JFFOH'D BIT) + R6 = PORT NUMBER
        SLLS    R8,2                    :MAKE PORT NMBR INTO WORD INDEX
        L       R1,PSTATB,R8,           :GET PST ADDR FROM TABLE

:       CHECK IOCBS FOR EACH PORT--IOCB ADDRESS FOUND IN PST

IOCBS0  L       R2,INIOCB,R1		:GET INPUT CHNL IOCB ADDR
        LB      R3,SIO,R2		:CHECK SIO FIELD
        JEFS    IOCBS1			:IF 0, CHECK OUTPUT CHNL IOCB
        LB      R6,INCHNL,R1            :GET INPUT CHANNEL NUMBER
        CLHI    R3,1			:GOT A '01'? ( SIO REQUEST CODE)
        JNFS    IOCBS2			:IF NOT, CHECK IF CODE FOR PENDING IO
        JAL     R13,QSIORB		:ELSE QUEUE UP THE SIO REQUEST
        JFS     IOCBS1                  :CHECK OUTPUT CHNL IOCB
IOCBS2  CLHI    R3,80                   :PENDING IO REQUEST?
        JN      INERR                   :ERROR--INVALID DATA ON INPUT IOCB
IOCBS1  L       R2,OPIOCB,R1            :GET OP CHNL IOCB ADDR
        LB      R3,SIO,R2               :CHECK SIO FIELD
        JE      PRTSC2                  :IF 0, LOOK FOR NEXT PORT IN GROUP
        LB      R6,OUTCHN,R1            :GET OUTPUT CHANNEL NUMBER
        CLHI    R3,1                    :GOT AN SIO REQUEST?
        JNFS    IOCBS4                  :NO, CHECK IF PENDING SIO REQUEST
        JAL     R13,QSIORB              :YES, QUEUE IT
        J       PRTSC2                  :LOOK FOR NEXT PORT IN GROUP
IOCBS4  CLHI    R3,80                   :PENDING IO REQ?
        JN      OUTERR                  :IF NOT 80, IT'S AN ERROR
        J       PRTSC2                  :LOOK FOR NEXT PORT IN GROUP

:       CHECK ALL IOCBS FOR HIO INDICATION

CHKHIO	LA	R1,IOCBTB,,		:GET IOCB ADDR TABLE
	LHI	R9,MXIOCB-1		:GET LARGEST WRITE IOCB (252)
	SLLS	R9,2			:MAKE INTO WORD INDEX
IOCBS5	L	R2,0,R1,R9		:GET IOCB ADDR
	JLFS	IOCBS6			:HI-ORDER BIT SET--HIO ALREADY NOTED
	LB	R4,HIO,R2,		:CHECK HIO BYTE
	JNFS	IOCBS7			:SOMETHING TO CHECK
IOCBS6	SHI	R9,8			:DECREMENT INDEX TO NEXT WRITE IOCB
        CLHI    R9,8                    :IGNORE IOCB0 AND IOCB1
	JGEBS	IOCBS5			:GET NEXT IOCB ADDR
	JFS	RESTMR			:HIO CHECK DONE--RESET TIMER
IOCBS7  LR      R6,R9                   :GET COPY OF INDEX
        SRLS    R6,2                    :MAKE INTO IOCB NMBR
      	CLHI	R4,1			:IS IT A PROPER HIO REQEUST?
	JNFS	HIOERR			:NO--CREATE IORB TO INDICATE BAD DATA
	JAL	R13,QHIORB		:AND QUEUE THE HIO IORB
	JBS	IOCBS6

RESTMR	L	R1,FASTC,,		:RESET TIMER
	ST	R1,HIOTMR,,
	J	FGLOOP

:       HANDLING ERROR CONDITION OF INVALID DATA IN SIO OR HIO BYTE--
:       INSTEAD OF SIOTYP OR HIOTYP CONSTANT IN IORB--PUT THE INVALID...
:       BYTE OF DATA IN THE IORB AND LET THE BG JOB EVALUATE

HIOERR	LR	R5,R4    		:GET BAD DATA--BG WILL EVALUATE
	JAL	R13,QHIOR0		:JUST QUEUE AN IORB W/ ERR INDICATION
	J	IOCBS6			:AND CARRY ON

OUTERR  LR      R5,R3                   :GET BAD DATA--BG WILL EVALUATE
        JAL     R13,QSIOR0              :RS TASK WILL HANDLE ERROR
        J       PRTSC2                  :LOOK FOR NEXT PORT IN GROUP
INERR   LR      R5,R3                   :GET BAD DATA--BG WILL EVALUATE
        JAL     R13,QSIOR0
        J       IOCBS1

QHIORB  LHI     R5,HIOTYP
QHIOR0  LB      R4,SIO,R2,              :SIO FIELD ALREADY RESET?
        JNFS    QHIOR1                  :NO
        CLHI    R6,0                    :IS THIS IOCB0?
        JEFS    QHIOR1                  :YES, SO GO QUEUE AN IORB
        STB     R4,HIO,R2,              :YES, RESET HIO AND DON'T QUEUE IT
        JR      R13
QHIOR1	LIS	R0,0			: SET HI-ORDER BIT IN IOCBTB ENTRY
        SBT     R0,0,R1,R9              :TO INDICATE AN 'HIO IN PROGRESS'
        JFS     QIORB0

QSIORB  LHI     R5,SIOTYP
QSIOR0  LHI     R3,80                   :PUT 80 IN SIO FIELD
        STB     R3,SIO,R2               :INDICATES PENDING SIO REQUEST

:       CHECK IF ROOM FOR ANOTHER IORB ON RING

QIORB0  LHL     R15,IONFMI+IORQ,,         
        CLH     R15,IOCEI+IORQ,,
        JE      QIORB2                  :ALL CAUGHT UP--QUEUE IT
        JG      QIORB1
        LHL     R14,IOCEI+IORQ,,          :IOCEI IS AHEAD OF IONFMI
        SR      R14,R15                 :GET DISTANCE BETWEEN THEM
        AHI     R14,-IORBLN             :DISTANCE MUST BE > IORBLN
        JG      QIORB2                  :THERE'S ROOM FOR THIS IORB
        SVC     DISMISS,0               :NO ROOM, DISMISS AND TRY AGAIN
        J       QIORB0
QIORB1  LHL     R14,IOCEI+IORQ,,          :IOCEI = 0?
        JN      QIORB2                  :NO, SO THERE'S ENOUGH ROOM FOR IORB
        LHI     R14,IORQSZ              :GET SIZE OF RING
        SR      R14,R15                 :GET DIFF. BETWEEN END OF RING AND NFMI
        SHI     R14,IORBLN
        JG      QIORB2                  :ENOUGH ROOM
        SVC     DISMISS,0
        J       QIORB0

:       PUT IORB ON IORQ

QIORB2  STB     R5,IORQ+IORING+IORT,R15,  :PUT REQUEST TYPE IN IORB
        STB     R6,IORQ+IORING+IOCHNL,R15, :PUT CHNL NMBR IN IORB
        AHI     R15,IORBLN              :INCREMENT IONFMI
        CLHI    R15,IORQSZ              :END OF Q?
        JNFS    QIORB3
        LIS     R15,0                   :WRAP IT AROUND
QIORB3  STH     R15,IONFMI+IORQ,,         :SAVE IONFMI
        IF      DB.IOQ
        LB      R15,SIGB1,R2
        EVT(ET.IOQ,TS.IOQ,R6,R5,R15)
        EI
        JR      R13

:       GETIOR -- SUBROUTINE TO GET I/O REQUEST BLOCK FROM IORQ
:       LINKS ON R13
:       NORMAL RETURN IF NOTHING ON IORQ, ELSE SKIP RETURN
:       R5 = REQUEST TYPE
:       R6 = CHANNEL (IOCB) NUMBER

        GL      GETIOR
GETIOR  LHL     R4,IOCEI+IORQ,,         :GET CURRENT EMPTY INDEX
        CLH     R4,IONFMI+IORQ,,        :IF = NFMI, THEN NO BLOCKS
        JER     R13                     :NORMAL RETURN IF 0 
        LB      R5,IORING+IORQ,R4,      :GET REQEUST TYPE
        LB      R6,IORING+IORQ+1,R4,    :GET CHANNEL NMBR
        AHI     R4,IORBLN               :INCREMENT IDX
        CLHI    R4,IORQSZ               :PHYSICAL END OF Q?
        JNFS    GETIO1
        LIS     R4,0
GETIO1  STH     R4,IOCEI+IORQ,,         :SAVE CEI
        J       4,R13                   :SKIP RETURN

    


        SUBTTL MBASE INITIALIZATION

:INITX.MBS	ORIGINATED BY ?
:INITX.M01	DEE EDUARDO 2/10/88 
:		ADDED INITS FOR B1THRS AND B3THRS.
:		REFORMATTED.




        GL      EXEC,MORDAT
	GL	REQCNT,DIDMAX,CNTSUM,NBRCYC,AV8CYC

        SEG     A.CODE

START   LHL     R0,CRAT+CRASHC,,        :GET CC AND SEE IF 'MANUAL RESTART'
        CLHI    R0,CCSPRS               :DID SPIRIT START RESET?
        JEFS    START0                  :JUMP IF SO
        TS      MBASRS,,                :MBASE OR ISIS STARTED RESET (CRASH)
START0  EQ      .
        JAL     R13,SETMAC              :SET-UP EXTENDED MAC USAGE
        JAL     R13,RESINT              :RESET INTERFACE 



:       INITIALIZE MBASE DATA STRUCTURES

        SEG     A.DATA
MBIZSV  WS      1

        SEG     A.CODE
MBASIZ  ST      R13,MBIZSV,,
	LHI	R0,B1THLD*NBUF1/$A100	:SBUS BUF THRESHOLD VALUE
	STH	R0,B1THRS
	LHI	R0,B3THLD*NBUF3/$A100	:TYPE 3 BUF THRESHOLD VALUE
	STH	R0,B3THRS

        LIS     R0,0
        ST      R0,ISOPQ		:ISIS OUTPUT QUEUE
        ST      R0,IOPQND
        ST      R0,ATCHDQ		:ATTACHED PORTS QUEUE
        ST      R0,ATCQND
        ST      R0,SRBQUE               :SERVICE REQUEST BLK QUEUE
        ST      R0,SRBQND               :END OF SRB QUEUE
        ST      R0,SUSQUE               :SUSPEND QUEUE
        ST      R0,SUSQND
        ST      R0,FLUSHQ               :FLUSH QUEUE
        ST      R0,FLSQND

        STH     R0,ZPBTOT,,
        STH     R0,ZPCTOT,,
        STH     R0,FSHRB1,,             :'FAIR SHARE' OF SUBS BUFS PER PORT
        STH     R0,FSHRB3,,             :'FAIR SHARE' OF TYP 3 BUFS PER PRT
        STB     R0,PSTCNT,,             :ACTIVE PST COUNT

        STB     R0,MORDAT,,
        STH     R0,RXSRCD,,
        STH     R0,LMTRCD,,
        STH     R0,SUSPND,,
        ST      R0,SBUSTO               :SBUS TIMEOUT VALUE
        ST      R0,IORQ,,               :CLEAR NFMI, CEI OF IORQ

	STH	R0,REQCNT,,		:CLEAR RQSTRT TUNING PARAMETERS
	STH	R0,DIDMAX,,
	STH	R0,CNTSUM,,
	STH	R0,NBRCYC,,
	STH	R0,AV8CYC,,
        STH     R0,B1UCRB
        STH     R0,B3UCRB,,

        LIS     R0,0
        LHI     R1,2*NGRP-2             :THIS MANY GROUPS 
MBSIZ0  STH     R0,APORTM,R1            :RESET ACTIVE PORT BIT ARRAYS
        STH     R0,APORTS,R1
        SIS     R1,2
        JGEBS   MBSIZ0
        SBT     R0,APORTS,,             :SET PORT 0 BIT IN APORTS

	LHI	R8,RQSMXX		:SET UP RQSTRT CYCLE MAX
	STH	R8,RQSMAX,,
	LHI	R8,SRDMXX		:SET UP SRDONE MAX CYCLES
	STH	R8,SRDMAX,,

        LA      R8,PSTB0,,              :GET ADDR OF PST 0
MBSIZ1  JAL     R13,IZPST               :INIT'IZE EACH PST
        AI      R8,PSTLEN
        CLI     R8,PSTEND
        JNBS    MBSIZ1
        JAL     R0,IZT                  :INIT TIMEOUT LIST

:       SET-UP TABLE OF PORT STATUS TABLE ADDRESSES
        LA      R1,PSTB0,,
        LIS     R2,0
        LIS     R3,0
MBSIZ2  ST      R1,PSTATB,R2
        AHI     R1,PSTLEN
        AIS     R2,4
        AIS     R3,1
        CLHI    R3,NPORT+1
        JLBS    MBSIZ2

:       SET-UP TABLE OF IOCB ADDRESSES -- HI-ORDER BIT SET BY FG JOB WHEN...
:       HIO DETECTED--RE-SET BY BG WHEN HIO REQ. COMPLETED
        LA      R1,IOCB0,,
        LIS     R2,0
        LIS     R3,0
MBSIZ3  ST      R1,IOCBTB,R2
        AHI     R1,IOCBLN
        AIS     R2,4
        AIS     R3,1
        CLHI    R3,NIOCB
        JLBS    MBSIZ3

        JAL     R13,INIXDT              :INITIALIZE XTENDED DDT PARAM(S)

        RETURN(MBIZSV)

:	RESET INTERFACE ROUTINE

:       CALLED AFTER JUMP TO 'START' BY CRASH ROUTINE WHICH...
:       IS CALLED WHEN SPIRIT ISSUES RESET INTERFACE CMD OR...
:       WHEN MBASE DECIDES TO RE-START AND RE-SET INTERFACE

:       LINK ON R13
RESINT	STM	R8,RSTEMP,,             :SAVE REGS
        JAL     R13,IZBUFS              :INITIALIZE BUFFER POOLS
        JAL     R13,EVTIZ,,             :INITIALIZE EVENT TRACE TABLES
        IF      DB.RST
        LHL     R1,CRAT+CRASHC,,
        EVT(ET.RST,TS.RST,R1)
        EI
        JAL     R13,MBASIZ              :INITIALIZE MBASE TABLES
        JAL     R13,GETBF2              :GET AN SRB BUFFER
	LH	R1,MBASRS		:DID MBASE START RESET?
	JGE	RESIN0			:NO
        LIS     R0,0
      	LHI	R9,CHANL1		:RESET REQUIRED ON CHANNEL 1
        LA      R8,IOCB1,,              :GET IOCB1 ADDR
        JAL     R13,GETSIO              :CHECK FOR SIO INDICATION ON CHAN 1
        J       RESIN2                  :NORMAL RETURN (SEE GETSIO COMMENTS)

        LR      R1,R1                   :GET CMD BYTE OF IOCB1
        JE      RESIN2                  :NO SIO 
        LB      R1,CMD,R8               :GET CMD BYTE
	CLHI	R1,RNTFAC		:IS IT RESET INTERFACE CMD?
	JN  	RESIN0			:NO--OTHERWISE PRESENT INTERFACE ...
        JAL     R13,PSNDWT              :PRESENT INT. REQ. STAT. AND WAIT
        J       RESIN2                  :CHECK NEXT IOCB

:	END ALL PENDING IO REQUESTS W/ INTERFACE RESET REQUIRED
RESIN0  LIS     R0,0
        STH     R0,PNDCMD               :SET PENDING CMD FLAG
        LA      R8,IOCB1,,              :GET ADDR OF IOCB1
        LIS     R9,1                    :INIT CHANNEL COUNTER
RESIN3  STB     R0,HIO,R8               :CLEAR HIO BYTE
        JAL     R13,GETSIO              :CHECK SIO BYTE
        J       RESIN2                  :SIO ERROR FOUND--STATUS PRESENTED

        LR      R1,R1                   :SIO BYTE = 0?
        JE      RESIN2                  :NO SIO FOUND, CHECK NEXT
        CLHI    R9,1                    :CHANNEL 1?
        JE      RESIN1                  :YES, CHECK IF RESET INT'FAC CMD
RESIN4  JAL     R13,PSNDWT              :PRESENT STATUS AND WAIT
        TS      PNDCMD                  :SET FLAG SHOWING THAT CMD WAS PENDING
RESIN2  AI      R8,IOCBLN               :GET NXT IOCB ADDR
        AIS     R9,1                    :GET NXT CHANNEL
        CLHI    R9,NIOCB                :END OF IOCBS?
        JN      RESIN3          
        JFS     RESIN5
RESIN1  LB      R1,CMD,R8               :GET CMD BYTE
        CLHI    R1,RNTFAC               :RESET INTERFACE?
        JEBS    RESIN2                  :YES, IGNORE FOR NOW
        J       RESIN4                  :ELSE PRESENT INT. RESET REQ. STAT.

RESIN5  SVC     DISMISS                 :DISMISS AFTER EACH TIME THRU LOOP
        LH      R0,PNDCMD               :PENDING CMD FLAG SET?
        JL      RESIN0                  :YES--CHECK IF ANY MORE

        LA      R8,IOCB1,,              :GET IOCB1 ADDR
        LIS     R9,1                    :IT'S CHANNEL 1
RESIN6  SVC     DISMISS
        JAL     R13,GETSIO              :CHECK FOR SIO INDICATION
        J       RESIN0                  :INVALID DATA, BETTER RECHECK ALL IOCB

        LR      R1,R1                   :GOT AN SIO?
        JE      RESIN0                  :NO, CHECK ALL IOCBS AGAIN
        LB      R1,CMD,R8               :GET CMD BYTE 
        CLHI    R1,RNTFAC               :ON CHAN 1
        JN      RESIN4                  :LOOP UNTIL NOTHING BUT RNTFAC ON CH 1

        TS      RSETIP                  :SET RESET-IN-PROGRESS FLAG
        LIS     R0,0                    
        STH     R0,MBASRS               :CLEAR MBASE RESET FLAG
        JAL     R13,RETBF2              :RETURN THE SRB BUFFER
        JAL     R13,PNORMS              :WITH NORMAL STATUS
        JAL     R13,WAIT                :WAIT FOR 'DONE' BIT ON SRB
        JAL     R13,RETBF2              :RETURN THE SRB BUFFER
        LM      R8,RSTEMP,,
        L       R1,FASTC,,
        ST      R1,HIOTMR,,             :INIT HIO TIMER FOR FG JOB
        LA      R0,IOCBST               :ADDR OF FOREGROUND JOB
        SVC     SYS,1                   :START FOREGROUND JOB
        J       EXEC                    :START EXEC LOOP


        SEG     A.DATA
RSTEMP  WS      8
PSNSAV  WS      1
GETSAV  WS      1


        SEG     A.CODE
:	SUBROUTINE TO CHECK FOR VALID SIO REQUEST
:       IF INVALID SIO DATA, PRESENTS ERROR STATUS OF INVALID SIO...
:       AND INTERFACE RESET REQUIRED STATUS

:       TO BE USED ONLY BY RESET INTERFACE SUBROUTINE

:       LINK ON R13--SKIP RETURN IF OK--'NORMAL'RETURN IF SIO ERROR

:       PASS IOCB ADDRESS IN R8
:       IOCB NUMBER IN R9
:       CC SET TO 0 IF NO SIO INDICATION

GETSIO  EQ      .
        LB      R1,SIO,R8               :CHECK SIO BYTE
	JE      4,R13                   :SKIP RETURN--NO SIO INDICATION
        CLHI    R1,1                    :SIO BYTE MUST BE = 1 OR 80
        JE      4,R13                   :SKIP RETURN--VALID DATA IN SIO BYTE
        CLHI    R1,80                   
        JNFS    GTSIO0                  :IF NOT, INDICATE ERROR IN STAT BYTES
        J       4,R13                   :SKIP RETURN

:       R10 <-- DATA FOR STAT BYTE 0 -- R11 <-- DATA FOR STAT. BYTE 1
GTSIO0	LHI	R10,FAILED		:ATTENTION FLAG IN R6
	OHI	R10,SIOERR		:INCLUDE START I/O ERROR FLAG
	LHI	R11,INVSIO		:INVALID SIO FIELD
        OHI     R11,INTREQ              :INCLUDE INTERFACE RESET REQUIRED
        ST      R13,GETSAV,,
        JAL     R13,PSNDW1              :PRESNET STATUS AND WAIT
        RETURN(GETSAV)

:       SUBROUTINE TO CREATE AN SRB W/ INTERFACE RESET REQUIRED STATUS...
:       ...AND PRESENT SRB TO ISIS DRIVER--WAITS FOR RESPONSE (CHECKS DONE BIT)
:       A CALL BY GETSIO VIA ENTRY POINT 'PSNDW1' WILL ALSO RESULT IN ...
:       PRESENTED STATUS OF START I/O ERROR BECAUSE OF 'DAMAGED IOCB'
:       LINKS ON R13
:       PARAMETERS PASSED:  
:               R6 = SRB BUFFER ADDRESS
:               R9 = CHANNEL (IOCB) NUMBER
:               R10 = STATUS BYTE 0 DATA
:               R11 = STATUS BYTE 1 DATA

:       TO BE USED ONLY BY RESET INTERFACE ROUTINE

PSNDWT  EQ      .
        LHI     R10,FAILED
        LHI     R11,INTREQ              :STAT BYTE 1 <-- INT'FAC RESET REQ'D
        LHL     R2,CRAT+CRASHC,,        :GET CRASH CODE
        OR      R11,R2                  :INCLUDE IT IN STAT BYTE 1
PSNDW1  ST      R13,PSNSAV,,
        LHI     R2,ZERO                 :GET ZERO BIT NUMBER
        SBT     R2,MSTAT,R6             :SET ZERO FLAG IN MSTAT
        STB     R9,SRCHNL,R6            :SAVE CHANNEL #
        STB     R10,STBYT0,R6           :SET STATUS BYTE 0
        STB     R11,STBYT1,R6           :SET STATUS BYTE 1
        LHI     R0,RDSTAT               :SERVICE REQ. OF READ STATUS
        STB     R0,SRBYTE,R6            :PUT IN SRB
        JAL     R13,ENQSRB              :ENQUEUE SRB
        JAL     R13,WAIT
        RETURN(PSNSAV)


:       SUBROUTINE TO WAIT FOR A RETURNED SRB (DONE BIT SET)
:       USED ONLY BY RESET INTERFACE ROUTINE
:       LINKS ON R13
:       R6 = ADDRESS OF SRB BUFFER
WAIT0   SVC     DISMISS
WAIT    LHI     R0,DONE                 :DONE FLAG OFFSET
        TBT     R0,ISTAT,R6             :CHECK DONE BIT
        JEBS    WAIT0                   :NOT YET SET
        LIS     R0,0
        ST      R0,SRBQUE,,
        ST      R0,SRBQND,,
        JR      R13


 
        SUBTTL MBASE GLobal Backpressure Task and Backpressure Subroutines

:	GLOBAL BACKPRESSURE TASK
:
:GLBKPR.MBS	ORIGINATED BY BOB SORENSEN
:GLBKPR.M01	DEE EDUARDO 2/10/88
:		REPLACED MOST COMPARE LOGICAL INSTRUCTIONS.
:		REFORMATTED.
:		REORGANIZED CODE THAT CHECKS THRESHOLDS AND PORTS TO BKPR.





:	IF THERE IS NOT ENOUGH SBUS WINDOW BUFFER SPACE OR IF THERE ARE NOT
:       ENOUGH TYPE 3 BUFFERS, BACKPRESSURE SELECTED PORTS.
:	A PORT IS SELECTED IF IT IS NOT ALREADY BACKPRESSURED AND EITHER IT
:	HAS NO READ FROM SPIRIT ON IT, OR IT IS USING MORE THAN ITS FAIR SHARE
:	OF SBUS OR TYPE 3 BUFFERS.  NOTE THAT MBASE OVERRIDES "AUTOMATIC
:	BACKPRESSURE NOT ALLOWED" ON PORTS WITH NO READS.
:	IF MBASE HAD PREVIOUSLY BACKPRESSURED A PORT, CHECK 
:	CONDITIONS UNDER WHICH BACKPRESSURE CAN BE RELEASED, AND DO SO IF
:	THE CONDITIONS HAVE BEEN MET.



	SEG	A.DATA
GLBKSV	WS	1


	SEG	A.CODE
GLBKPT	L	R15,ATCHDQ,,		:GET FIRST ATTACHED PORT
	JER	R13			:NOTHING TO DO 

	ST	R13,GLBKSV,,		:SAVE LINK REG.
	LHL	R1,B1USED,,		:# OF SBUS BUFFERS USED
	LHL	R3,B1THRS,,		:MAX SBUS BUFS USED BEFORE BACKPRESSURE
	CR	R1,R3			:COMPARE USED WITH THRESHOLD VALUE
	JL  	GLBKP3			:IF ENOUGH, GO CHECK BUF 3 COUNT

	LHI	R14,SBBFCT		:PST OFFSET FOR SBUS BUF COUNT
	LHL	R11,FSHRB1,,		:FAIR-SHARE OF SBUS BUFFERS

GLBKP0	LHI	R1,BPFRMB		:MBASE BKPR FLAG
	TBT	R1,PSTFLG,R15		:PORT ALREADY BKPRD?
	JN	GLBKP2			:YES, SO CHECK NEXT PORT

	LHL	R2,NOREAD		:SET UP NOREAD FLAG FOR HMBBPR
	L	R1,INIOCB,R15,		:INPUT IOCB ADDR
	LB	R1,SIO,R1,		:IS THERE A SPIRIT READ ON PORT?
	JE      GLBKP1                  :NO, SO BKPR IT

	LIS	R2,0			:SET UP R2 FOR HMBBPR
	LHL	R1,0,R14,R15		:GET BUF CNT FOR PORT
	CR	R1,R11			:EXCEEDED ITS FAIR SHARE?
	JL	GLBKP2			:NO, CHECK NEXT PORT
	
GLBKP1	LHL	R6,PSTFLG,R15		:SET DFC OVERRIDE FLAG
	SBT	R6,PSTFLG,R15
	LIS	R6,1			:REQT TO SET BKPR
	JAL	R13,HMBBPR		:HANDLE MBASE BKPR REQT

GLBKP2	L	R15,ATCHNX,R15,		:GET NEXT ACTIVE PORT
	JN	GLBKP0
	CLHI	R14,SBBFCT
	JN	GLBREL

GLBKP3	LHL	R1,B3USED,,		:# OF TYPE 3 BUFERS USED
	LHL	R3,B3THRS,,		:MAX TYPE3 BUFS USED BEFORE BACKPR'G
	CR	R1,R3			:GOT ENOUGH TYPE 3 BUFFERS?
	JL	GLBREL			:YES, CHECK ANY MBASE-BKPRSRD PRTS

	L	R15,ATCHDQ,,		:GET FIRST ATTACHED PORT
	LHI	R14,T3BFCT		:PST OFFSET FOR TYPE 3 BUF COUNT
        LHL     R11,FSHRB3,,            :FAIR-SHARE OF BUF TYPE 3
	J	GLBKP0			:GO CHECK INDIVIDUAL PORTS




:       CHECK IF MBASE HAD SET BACKPRESSURE ON ANY ACTIVE PORT.
:       IF SO, CHECK CONDITIONS UNDER WHICH BACKPRESSURE MAY BE 
:       RELEASED AND DO SO IF THE CONDITIONS ARE MET

GLBREL	L	R15,ATCHDQ,,		:FRONT OF THE QUEUE
	LHI	R14,BPFRMB		:BACKPR-FROM-MBASE FLAG

GLBRL5	TBT	R14,PSTFLG,R15,		:DID MBASE BAKPR THIS PORT?
	JNFS	GLBRL6			:YES, GO CHECK

GLBRL8	L	R15,ATCHNX,R15,		:GET NEXT PST
	JNBS	GLBRL5			:CHECK NEXT
	RETURN(GLBKSV)

GLBRL6	LHI	R2,NOREAD		:GET NO READ FLAG
	TBT	R2,PSTFLG,R15,		:BACKPRESSURE ON BECAUSE NO READ?
	JN  	GLBRL7			:YES, GO SEE IF THERE'S A READ UP
	LHL	R1,SBBFCT,R15,		:GET TYPE 1 USED BUF COUNT FOR PORT
	LHL	R3,B1UCRB,,		:GET BUF1_USD_CNT_FOR_REL_OF_BKPR
	CR	R1,R3			:USED BUF COUNT > RELEASE POINT?
	JG  	GLBRL8			:YES, CAN'T RELEASE BKPR
	LHL	R1,T3BFCT,R15,		:GET TYPE 3 USED BUF COUNT FOR PORT
	LHL	R3,B3UCRB,,		:GET BUF3_USD_CNT_FOR_REL_OF_BKPR
	CR	R1,R3			:USED BUF CNT > RELEASE POINT?
	JG	GLBRL8			:YES, CAN'T RELEASE BKPR
	LHI	R6,DFOVRD		:RESET THE DFC OVERRIDE FLAG
	RBT	R6,PSTFLG,R15
	LIS	R6,0			
	JAL	R13,HMBBPR		:RELEASE BACKPRESSURE ON PORT
	J	GLBRL8			:CHECK NEXT PORT

GLBRL7	L	R1,INIOCB,R15,		:GET IOCB ADDR
	LB	R1,SIO,R1,		:GOT AN SIO (READ)?
	JE	GLBRL8			:NO, CAN'T RELEASE BKPR
	LHI	R6,DFOVRD		:RESET THE DFC OVERRIDE FLAG
	RBT	R6,PSTFLG,R15
	LIS	R6,0
	JAL	R13,HMBBPR		:RELEASE BKPR
	J	GLBRL8


:       UPDATE GLOBAL BACKPRESSURE CRITERIA

:	LINK ON R13
:       R15 = PST
:	R1 = XMIT LIMIT FOR PORT (IF ADDING PORT) ELSE 0 IF PORT ZAP
:	UPDATE FSHRB1,FSHRB3,B1UCRB,B3UCRB

        SEG     A.CODE
UPDGBC	LR	R1,R1			:ADDING OR ZAPPING PORT?
	JEFS	UPDGB1			:IF R1 = 0, PORT IS BEING ZAPPED
	LB	R2,PSTCNT  		:GET ACTIVE PST COUNT
	AIS	R2,1			:ADDING ONE PST
	STB	R2,PSTCNT  		:UPDATE COUNT
	J  	UPDGB2			:GO UPDATE FAIR-SHARE OF BUFFERS

UPDGB1	LB	R2,PSTCNT  		:ACTIVE PST COUNT
	SIS	R2,1			:DECREMENT
	STB	R2,PSTCNT  		:SAVE
        JNFS    UPDGB2                  :JUMP IF ANY LEFT, ELSE CLEAR...
	LIS	R0,0
        STH     R0,FSHRB1
        STH     R0,FSHRB3
        JR      R13


: CALCULATE FAIR SHARE PERCENTAGE OF BUFFER TYPE 1 USAGE
UPDGB2	CLI	R2,PCTDYN/PCTFIX	:OVER CRITICAL # OF ACTIVE PORTS?
	JLEFS	UPDGB3			:NO...USE FIXED PERCENTAGE
	LI	R1,NBUF1*PCTDYN/$A100	:YES...CALCULATE THE PERCENTAGE
	LIS	R0,0			:SET-UP R0 FOR DIVIDE
	DR	R0,R2			:DIVIDE BUF NMBR BY ACTIVE PSTS
	JFS	UPDGB4			:GO STORE IT

UPDGB3	LI	R1,NBUF1*PCTFIX/$A100	:GET FIXED PERCENTAGE

UPDGB4	STH	R1,FSHRB1  		:UPDATE FSHRB1 PER PORT
        SRHLS   R1,PCFSB1               :GET PERCENTAGE OF FAIR-SHARE OF BUFS
        STH     R1,B1UCRB
: CALCULATE FAIR SHARE PERCENTAGE OF BUFFER TYPE 3 USAGE
	LB	R2,PSTCNT		:GET # OF ACTIVE PORTS AGAIN
	CLI	R2,PCTDYN/PCTFIX	:OVER CRITICAL # OF ACTIVE PORTS?
	JLEFS	UPDGB5			:NO...USE FIXED PERCENTAGE
	LI	R1,NBUF3*PCTDYN/$A100	:YES...GO CALCULATE THE PERCENTAGE
        LIS     R0,0                    :SET-UP R0 FOR DIVIDE
        DR      R0,R2                   :DIVIDE BUF NMBR BY ACTIVE PORTS
	JFS	UPDGB6			:GO STORE IT

UPDGB5	LI	R1,NBUF3*PCTFIX/$A100	:GET FIXED PERCENTAGE

UPDGB6  STH     R1,FSHRB3               :SAVE FAIR SHARE OF TYPE 3 BUFS
        SRHLS   R1,PCFSB3
        STH     R1,B3UCRB
	JR	R13


:	HANDLE SPIRIT BACKPRESSURE REQUEST
:	LINKS ON R13
:	R6 = 1 TO SET BACKPRESSURE OR 0 TO RELEASE BKPRSR
:	R15 = PST ADDR

	SEG	A.DATA
HSPBSV	WS	1


	SEG	A.CODE
        GL      HSPBPR,QBPOUT
HSPBPR	LHI	R1,BPFRSP		:BACKPRESSURE-FROM-SPIRIT FLAG
	LR	R6,R6			:SETTING OR RELEASING BKP?
	JE	HSPBP0			:IF 0, RELEASE
	SBT	R1,PSTFLG,R15,		:SET BPFRSP BIT
        LHI     R2,BPTOIS               :BACKPRESSURE SETN TO ISIS?
        TBT     R2,PSTFLG,R15           :DON'T SEND IF SO
        JNR     R13                     :JUST GET OUT
	LHI	R1,BPSREQ		:BACKPRESSURE REQEUST FLAG
	TBT	R1,PSTFLG,R15,		:BACKPRESSURE REQUEST ALREADY MADE?
        JNR     R13                     :YES, DON'T BOTHER TO SET AGAIN
     	SBT	R1,PSTFLG,R15,		:OTHERWISE, SET BKP REQUEST BIT
	ST	R13,HSPBSV,,		:SAVE LINK REG.
	LIS	R14,0			:WE'RE NOT PUTTING A BUFFER ON PST
	JAL	R13,QBPOUT		:PUT PST ON ISOUTQ IF NOT ALREADY ON
	RETURN(HSPBSV)			:RESTORE LINK REG AND JR BACK

HSPBP0	RBT	R1,PSTFLG,R15,		:CLEAR BPFRSP BIT
        LHI     R1,BPTOIS               :RELEASE BACKPRESSURE SENT TO ISIS?
        TBT     R1,PSTFLG,R15           :GET OUT IF SO
        JER     R13
	LHI	R1,BPFRMB		:GET MBASE BACKPRESSRE FLAG
	TBT	R1,PSTFLG,R15,		:CHECK IF MBASE IS BACKPRESSURING
        JNR     R13                     :IF SO, SPIRIT CAN'T OVERRIDE IT
     	LHI	R1,BPSREQ		:GET BACKPRESSURE REQUEST FLAG
	TBT	R1,PSTFLG,R15,		:ALREADY RELEASED?
        JER     R13                     :YES, NOTHING ELSE TO DO
	RBT	R1,PSTFLG,R15,		:CLEAR BKP REQUEST BIT
	ST	R13,HSPBSV,,		:SAVE LINK REG.
	LIS	R14,0			:WE'RE NOT PUTTING A BUFR ON PST
	JAL	R13,QBPOUT		:PUT PST ON ISOUTQ IF NOT ALREADY ON
	RETURN(HSPBSV)			:RESTORE LINK REG AND JR BACK


:	HANDLE MBASE BACKPRESSURE REQUEST

:	LINK ON R13

:	PARAMETERS PASSED:
:	R6 = 1 IF SET BACKPRESSURE OR 0 IF RELEASE BKPRESSURE
:	R15 = PST ADDR
:	R2 = NOREAD FLAG IF MBASE WANTS BKPR 'CAUSE NO READ CMD UP (WILL...
:	  ...OVER-RIDE AUTOMATIC BACKPRESSURE NOT ALLOWED) ELSE MUST BE 0

:	USES R3

	SEG	A.DATA
HMBBSV	WS	1


	SEG	A.CODE
	GL	HMBBPR
HMBBPR	LHI	R1,BPFRMB		:MBASE BACKPRESSURE REQUEST FLAG
	LR	R6,R6			:SETTING OR RELEASING BACKPRSURE?
	JE	HMBBP0			:IF 0, MBASE WANTS TO RELEASE BKPR

:       MBASE WANTS BACKPRESSURE

        IF      DB.BPO
        L       R3,PSTFLG,R15
        EVT(ET.BPO,TS.BPO,R13,R15,R3)
        EI
        LHI     R3,BPTOIS               :BACKPRESSURE SENT TO ISIS?
        TBT     R3,PSTFLG,R15           :DON'T SEND IF NOT
        JNR     R13
	SBT	R1,PSTFLG,R15,		:SET MBASE-WANTS-BACKPRESSURE BIT
        LR      R2,R2                   :BKPR REQ BECAUSE NO READ UP?
        JEFS    HMBBP3                  :NO, GO CHECK IF AUTO BKP OK
        SBT     R2,PSTFLG,R15           :SET NO READ FLAG
        JFS     HMBBP1                  :GO DO IT

HMBBP3	LHI	R1,NATOBP		:automatic bckpr NOT allowed flag
	TBT	R1,PSTFLG,R15,		:IF SET, MBASE CANNOT BACKPRESSURE
	JEFS	HMBBP1			:MBASE CAN BACKPRESSURE, JUMP
	LH	R1,SUSPND,,		:MBASE SUSPENDED?
	JLFS	HMBBP1			:IF SO, MBASE CAN OVERRIDE NATOBP
        JR      R13                     :MBASE CANNOT BAKPRSRE--GET OUT

HMBBP1	LHI	R1,BPSREQ		:GET BACKPRESSURE REQUEST FLAG
	TBT	R1,PSTFLG,R15,		:IF SET, DON'T BOTHER SETTING AGAIN
	JNR	R13			:JUST GET OUT
        SBT     R1,PSTFLG,R15,          :INDICATE REQUEST TO SET BACKPRESSURE
	ST	R13,HMBBSV,,		:SAVE LINK REG.
	LIS	R14,0			:WE'RE NOT QUEING A BUFFER
	JAL	R13,QBPOUT		:PUT PST ON ISOUTQ IF NOT ALREADY ON
	RETURN(HMBBSV)			:RESTORE LINK REG. AND JR BACK


:       MBASE WANTS TO RELEASE BACKPRESSURE

HMBBP0  LHI     R3,BPTOIS               : RELEASE BACKPRESSRE SENT TO ISIS?
        TBT     R3,PSTFLG,R15           :GET OUT IF SO
        JER     R13
      	RBT	R1,PSTFLG,R15,		:CLEAR MBASE BKPRSSURE BIT
        IF      DB.BPF
        L       R3,PSTFLG,R15
        EVT(ET.BPF,TS.BPF,R13,R15,R3)
        EI
	LHI	R3,NOREAD		:GET NOREAD UP FLAG
	LHI	R1,NATOBP		:AUTOMATTIC BKP NOT ALLOWED FLAG
	TBT	R1,PSTFLG,R15,		:IF SET, CAN'T RELEASE BKPRESSURE
        JEFS    HMBBP2                  :GO DO IT
        TBT     R3,PSTFLG,R15,          :MBASE BKP 'CAUSE NO READ UP?
        JER     R13                     :IF SO, CAN PROCEED, ELSE GET OUT
HMBBP2  RBT     R3,PSTFLG,R15,          :CLEAR NOREAD BIT EVEN IF ALREADY 0
	LHI	R1,BPFRSP		:GET SPIRIT BACKPRESSURE FLAG
	TBT	R1,PSTFLG,R15,		:IF SET, CAN'T RELEASE BACKPRESSURE
	JNR	R13
	LHI	R1,BPSREQ		:GET BKP REQEUST FLAG
	TBT	R1,PSTFLG,R15,		:IF ALREADY RE-SET, DON'T BOTHER
	JER	R13
	RBT	R1,PSTFLG,R15,		:ELSE CLEAR BKP REQUEST FLAG
	ST	R13,HMBBSV,,		:SAVE LINK REG.
	LIS	R14,0			:SET UP CALL TO QBPOUT
	JAL	R13,QBPOUT		:PUT PST ON ISOUTQ IF NOT ALREADY ON
	RETURN(HMBBSV)

          SUBTTL Operations Monitor -- Mbase (routines called from status.mbs)

	SEG	A.DATA
:	PST FIELDS LENGTH BYTE ARRAY
PSTLNB	BC	1,1,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,2,4,2,2,4,4,10
PSTFHD	SC	/  OCH=/
PSTFLN  EQ      .-PSTFHD
	SC	/  ICH=/
	SC	/  OCB=/
	SC	/  ICB=/
	SC	/  OQN=/
	SC	/  OQP=/
	SC	/  AQN=/
	SC	/  AQP=/
	SC	/  INQ=/
	SC	/  OPQ=/
	SC	/  WCT=/
	SC	/  XLM=/
	SC	/  DFM=/
	SC	/  DFT=/
	SC	/  DFL=/
	SC	/  LCE=/
        SC      /  CHC=/
        SC      /  SBC=/
        SC      /  B3C=/
	SC	/  LBE=/
	SC	/  ZBC=/
	SC	/  ZCC=/
	SC	/  FLG=/
	SC	/  BSV=/
	SC	/  FCH=/
PSTHDR	SC	/"8D"8APORT STATUS TABLE /

CBFHDR  SC      / IOCB=/
CBPHDR  SC      /  SIO=/
        SC      /  HIO=/
        SC      /  CMD=/
        SC      /  SB1=/
        SC      /  SB2=/
        SC      /  SB3=/
        SC      /  DAT=/
        SC      /  MSB=/
        SC      /  LSB=/

PSTAHD  SC      /     PST ADDR=/

        SEG     A.CODE
GETPST	EQ	.
:	LINK ON R4
:	R1 = PST TO DISPLAY
	SVC	K.OUT,PSTHDR,,
	LR	R10,R1
        LIS     R2,0            
        LB      R2,PORT,R10,
        JAL     R3,SNDBYT               :DISPLAY PORT NMBR
        SVC     K.OUT,PSTAHD,,          :AND PST ADDR
        LR      R5,R10
        EXBR    R5,R5
        LBR     R2,R5
        JAL     R3,SNDBYT
        EXBR    R5,R5
        LBR     R2,R5
        JAL     R3,SNDBYT
        SVC     K.OUT,CRLFMG,,
	LA	R5,PSTLNB,,		:GET PST FIELD LENGTH BYTE ARRAY
        LHI     R6,OUTCHN               :INIT OFFSET INTO PST--SKIP PORT
	LA	R8,PSTFHD,,		:PST FIELD HEADERS
	LIS	R7,0			:INIT POINTER INTO LEN BYT ARRAY
GETPS0	SVC	K.OUT,0,R8		:PRINT FIELD HEADER
	LB	R9,0,R5,R7		:GET LENGTH BYT
GETPS1	LB	R2,0,R6,R10		:GET PST BYTE
	JAL	R3,SNDBYT		:SEND IT
	AIS	R6,1
	SIS	R9,1
	JNBS	GETPS1
	CLHI	R6,PSTEOD		:PST END-OF-DATA?
	JER	R4			:YES
        CLHI    R7,3
        JE      GETPS2
        CLHI    R7,7
        JE      GETPS2
        CLHI    R7,0B
        JEFS    GETPS2
        CLHI    R7,10
        JEFS    GETPS2
        CLHI    R7,15
        JEFS    GETPS2
        JFS     GETPS3
GETPS2  SVC     K.OUT,CRLFMG,,
GETPS3	AI	R8,PSTFLN		:GET NEXT FIELD HDR ADDR
	AIS	R7,1			:INCRMNT LEN BYT OFFSET
	J	GETPS0

GETCB   EQ      .
:       LINK ON R4
:       R10 = CONTROL BLOCK ADDR TO GET
:       R11 = IOCB NUMBER
        SVC     K.OUT,CBFHDR,,
        LR      R2,R11
        JAL     R3,SNDBYT
        LA      R8,CBPHDR,,
        LIS     R6,1
GETCB0  SVC     K.OUT,0,R8
        AI      R8,PSTFLN
        LB      R2,0,R6,R10
        JAL     R3,SNDBYT
        AIS     R6,2
        CLHI    R6,9
        JNFS    GETCB1
        SVC     K.OUT,CRLFMG,,
        J       GETCB0
GETCB1  CLHI    R6,13
        JN      GETCB0
        JR      R4

GETACB  EQ      .
:       LINK ON R5
        L       R12,ATCHDQ,,            :GET FIRST PST ON ATTACHED QUEUE
        JER     R5
GETAC0  LB      R11,OUTCHN,R12,         :GET OUTPUT CHANNLE NUMBER FROM PST
        L       R10,OPIOCB,R12,         :GET OUTPUT IOCB ADDR 
        JAL     R4,GETCB
        SVC     K.OUT,CRLFMG,,
        LB      R11,INCHNL,R12,         :GET INPUT CHANNEL NUMBER
        L       R10,INIOCB,R12,         :GET INPUT IOCB ADDR
        JAL     R4,GETCB
        SVC     K.OUT,CRLFMG,,
        L       R12,ATCHNX,R12,
        JER     R5
        SVC     K.OUT,CRLFMG,,
        J       GETAC0
   
:#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$

:^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&

	SUBTTL	SRDONE  -  SERVICE REQUEST DONE TASK

:	FILE   -   SRDONE.MBS

:	This background task works on SRBs after the ISIS driver
:	has finished processing them.  It is called by the exec
:	loop.

:	Calling sequence:
:			JAL    R13,SRDONE
:	No input.
:	Output:
:			R14 = Address of SRB
:			R15 = Address of PST.

:&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&**
:!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@!@@!@!@

	GL	SRDBAK,SBTIMO,SBTOID

	SEG	A.CODE
SRDONE	STM	R13,SRDSAV,,
        JAL     R13,CHKUBC                      :CHECK USED BUFFER COUNTS
	ST	R8,SRD8SV,,
	LIS	R3,0				:zero the cycle counter
	STH	R3,SRDCNT,,

	L	R14,SRBQUE			:get ptr to SRQ
	JE	SRD35				:if empty - bye
SRD01	LHI	R3,DONE
	TBT	R3,ISTAT,R14			:did ISIS process this SRB ?
	JE	SRDRET				:if not - nothing to do now

	LH	R3,SRDCNT,,			:inc the cycle counter
	AIS	R3,1
	STH	R3,SRDCNT,,
	CLH	R3,SRDMAX,,			:max #of cycles done ?
	JGE	SRDRET				:if so - bye

	LHI	R3,IFLUSH
	TBT	R3,ISTAT,R14			:this SRB to be flushed ?
	JE	SRD08				:if not - jump

:	put this SRB on the flush queue
	L	R3,FLUSHQ			:is the flush queue empty ?
	JNFS	SRD02				:if not - jump
	ST	R14,FLUSHQ			:if so - this SRB is the 1st
	J	SRD25				:go remove it from srbque
SRD02	L	R4,FLSQND			:get end-of-queue ptr
	JNFS	SRD03				:anything there ?
	C	R14,FLUSHQ
	JE	SRD25
	JFS	SRD05
SRD03	LR	R3,R4
SRD05	ST	R14,FLSQND			:new end of queue
	ST	R14,SRBNXT,R3			:link SRBs together
	ST	R3,SRBPRV,R14
	J	SRD25

SRD08	LB	R2,SRCHNL,R14			:get the channel nbr
	CHI	R2,1				:is it channel 1 ?
	JNFS	SRD09				:if not - jump
	LIS	R15,0				:if so - no PST
	JFS	SRD10
SRD09	SIS	R2,2				:compute the PST addr
	SRLS	R2,1
	SLLS	R2,2
	L	R15,PSTATB,R2
SRD10	L	R2,RETADR,R14			:done subroutine requested ?
	JEFS	SRD12				:if not - jump

	JALR	R13,R2				:if so - go do it

:	NOTE!!	THE LABLE "SRDBAK" MUST FOLLOW THE JUMP TO REQUESTED SUBRTN
SRDBAK	EQ	.

SRD12	LB	R2,SRBYTE,R14			:get request type 
	CHI	R2,RDATA			:* cmd is read data ?
	JEFS	SRD15				:if so - jump
	CHI	R2,RDNSTA			:* cmd is read data & status ?
	JN	SRD25				:if not - jump
SRD15	LHI	R2,RTRNBF
	TBT	R2,MSTAT,R14			:data buf to be freed up ?
	JE	SRD25				:if not - jump
	L	R6,BUFADR,R14			:if so...
	LB	R5,BUFTYP,R6			:return buf to avl queue
	LR	R8,R15				:copy PST addr into R8
	JAL	R13,RETBUF

:	update queue pointers & dequeue SRB
SRD25	L	R2,SRBNXT,R14
	JE	SRD26				:if no next srb - jump
	LIS	R3,0				:the new 1st SRB has no prev
	ST	R3,SRBPRV,R2
SRD26	ST	R2,SRBQUE			:former nxt SRB is new 1st
	LR	R2,R2				:set condition codes
	JNFS	SRD27
	LIS	R3,0				:if no top of queue now...
	ST	R3,SRBQND			:zero bottom of queue
	JFS	SRD29
SRD27	CL	R2,SRBQND
	JNFS	SRD29
	LIS	R3,0
	ST	R3,SRBQND
SRD29	LIS	R5,2				:dequeue the SRB
	LR	R6,R14
	LR	R8,R15				:copy PST
	JAL	R13,RETBUF

:	reset or cancel a timer, as needed
SRD35	L	R2,SBUSTO			:timeouts in effect ?
	JNFS	SRD36				:if so - proceed
	L	R14,SRBQUE			:if not - more srbs on q ?
	JE	SRDRET				:if not - bye
	J	SRD01				:if so - process them
SRD36	LHI	R0,SBTOID
	JAL	R5,TOGET			:cancel existing timer
	L	R14,SRBQUE			:anything on srb queue ?
	JE	SRDRET				:if not - bye
	LA	R0,SBTIMO			:else - start a new timer
	L	R1,FASTC,,
	A	R1,SBUSTO
	LHI	R6,SBTOID
	JAL	R5,TOPUT
	J	SRD01				:see if more srbs are done

SRDRET  LH      R0,B2USED,,             :GET USED SRB COUNT
        CH      R0,HWMASD,,             :COMPARE W/ HI-WATER MRK AFTER SRDON'
        JLFS    SRDFIN
        STH     R0,HWMASD,,             :RE-SET IF INCREMENTED
SRDFIN  EQ      .
	LM	R13,SRDSAV,,
	L	R8,SRD8SV,,
	JR	R13

	SEG	A.DATA
SRDSAV	WS	3
SRD8SV	WS	1
SRDCNT	HS	1				:cycle counter
    
:#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
:^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&&^&^&^&^&^&^&

	SUBTTL	RQSTRT - REQUEST STARTER TASK

:	FILE   -   RQSTRT.MBS


:	This background task processes all I/O requests sent from
:	Spirit to Mbase.  It receives the requests via an I/O
:	Request Block (IORQ) from the foreground task, and passes it
:	on to the appropriate Command Handler.  The Command
:	Handler does the required work to facilitate the I/O,
:	and if necessary, schedules a subroutine to be called by
:	the SRDONE task, which does the final processing.

:	Calling sequence:
:			JAL    R13,RQSTRT

:$%$%$%$%$%$%$%$%$%$%$%$%$%%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$
:@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@#@@#@#@#@#@#@#@#@#@


:	M A I N    L O O P

	SEG	A.CODE

	GL	FWRDIN,DEFFCH,CMPLZP
	GL	HSPBPR,UPDGBC
	GL	FWRDCS

RQSTRT	ST	R13,RQSSAV,,			:save the link reg

:	Init the counter of the number of Spirit requests serviced by
:	RQSTRT during this run cycle.  A "run cycle" is one running
:	of RQSTRT when called by the exec loop.
	LIS	R2,0
	STH	R2,REQCNT,,

RQST1	JAL	R13,GTIORB			:any requests from Spirit ?
	LR	R6,R6
	JL	RQS4				:if not - bye
	LH	R2,REQCNT,,			:if so - inc request counter
	AIS	R2,1
	STH	R2,REQCNT,,
	JAL	R13,GSPCMD			:go process the Spirit request
        CHKSRB(RQSSAV,1)
    	LH	R2,REQCNT,,			:have max requests been done ?
	CLH	R2,RQSMAX,,
	JL	RQST1				:if not - go do another one
	LH	R4,DIDMAX,,			:if so - inc a counter
	AIS	R4,1
	STH	R4,DIDMAX,,

:	compute the average number of Spirit requests serviced per RQSTRT
:	run cycle over the last 8 run cycles.
RQS4	AH	R2,CNTSUM,,			:inc running sum
	LH	R3,NBRCYC,,			:inc run cycle counter
	AIS	R3,1
	CHI	R3,8				:is this the 8th cycle ?
	JGEFS	RQS6				:if so - compute the average
	STH	R2,CNTSUM,,			:if not - update the counters
	STH	R3,NBRCYC,,
	JFS	RQS10				:bye bye
RQS6	SRLS	R2,3				:divide 8 cycle sum by 8
	STH	R2,AV8CYC,,			:save the average
	LIS	R2,0				:reset the counters
	STH	R2,CNTSUM,,
	STH	R2,NBRCYC,,

RQS10	L	R13,RQSSAV,,			:all done
	JR	R13				:return to exec loop

	SEG	A.DATA
RQSSAV	WS	1
REQCNT	HS	1				:# Spirit requests this cycle
DIDMAX	HS	1				:counter of times max was done
CNTSUM	HS	1				:sum of requests per 8 cycles
NBRCYC	HS	1				:current cycle of the 8
AV8CYC	HS	1				:average requests per cycle


	SUBTTL	GTIORB  -  GET IORB

:	S U B R O U T I N E   -   G T I O R B

:	This subroutine gets an IORB from the IORQ (I/O request queue).

:	Calling sequence:

:			JAL    R13,GTIORB

:	No inputs.
:	It return:
:			R5 = Request type: 1 = SIO, -1 = HIO
:			R6 = Channel number (IOCB nbr).  If no
:			     IOCB or if bad RT, R6 = -1


	SEG	A.CODE

GTIORB	STM	R13,GTISAV,,

	JAL	R13,GETIOR			:look for an IORB
	J	NOIORB				:if none - channel = -1
	CHI	R5,SIOTYP			:check request type
	JEFS	GTIRET				:if sio - good
	LHI	R3,HIOTYP
	NI	R3,0FF
	CR	R5,R3
	JEFS	GTIRET				:if hio - good
	LHI	R15,INVSIO			:else - invalid sio
	JAL	R13,BDIORB,,			:report the error
NOIORB	LCS	R6,1				:return empty/error status
GTIRET	LM	R13,GTISAV,,
	JR	R13

	SEG	A.DATA
GTISAV	WS	3


	SUBTTL	BDIORB  -  INVALID IORB DATA

:	S U B R O U T I N E   -   B D I O R B


:	This subroutine informs Spirit of an invalid IORB.

:	Calling sequence:

:			JAL   R13,BDIORB

:	Inputs:
:			R6 = Channel number
:			R15 = Error status
:	No output.


	SEG	A.CODE
BDIORB	STM	R13,SAVBD,,
	LR	R14,R6				:copy channel nbr
	JAL	R13,GETBF2			:get an srb
	STB	R14,SRCHNL,R6			:store the channel
	LHI	R7,RDSTAT			:read status request
	STB	R7,SRBYTE,R6
	LHI	R7,SIOERR+FAILED		:failed status
	STB	R7,STBYT0,R6			:other status - byte 1
	STB	R15,STBYT1,R6
	JAL	R13,ENQSRB			:enqueue the SRB
	LM	R13,SAVBD,,
	JR	R13

	SEG	A.DATA
SAVBD	WS	3

	SUBTTL	GSPCMD  -  GET SPIRIT COMMAND

:	S U B R O U T I N E   -   G S P C M D

:	This subroutine gets the I/O request from Spirit, and calls
:	the appropriate command handler.

:	Calling sequence:

:			JAL   R13,GSPCMD
:	Inputs:
:			R5 = Request type: 1 = SIO, -1 = HIO
:			R6 = Channel number (.ge. 0)

	SEG	A.CODE
GSPCMD	STM	R13,GTSSAV,,
	LR	R6,R6				:which chnl got the request ?
	JNFS	GTS02
	RESET(R13,CCHLT0)			:channel 0 - do a reset
	J	GTSRET				:bye
GTS02	CHI	R6,1				:request on channel 1 ?
	JNFS	GTS04				:if not - channel > 1
	JAL	R13,CH1CMD			:if so - process chnl 1
	J	GTSRET				:when done - bye
GTS04	LR	R7,R6				:copy channel nbr
	SIS	R7,2				:compute PST addr
	SRLS	R7,1
	SLLS	R7,2
	L	R15,PSTATB,R7			:addr of PST in R15
	LHI	R3,HIOTYP			:check for hio request
	NI	R3,0FF
	CR	R5,R3
	JNFS	GTS07				:if not hio - jump
	JAL	R13,DOHIO			:else - go process HIO
	J	GTSRET
GTS07	LR	R2,R6				:copy channel nbr
	NI	R2,1				:mask out all but low bit
	JE	GTS12				:if even nbr channel - jump
	L	R14,INIOCB,R15			:odd channel - Spirit input
	LB	R4,CMD,R14			:get cmd from IOCB
	CHI	R4,READ				:* cmd is read ?
	JNFS	GTS08				:if not - error
	JAL	R13,DOREAD			:process read cmd
	J	GTSRET

GTS08	LHI	R15,ILLCMD			:else - invalid
	JAL	R13,BDIORB,,			:report the error
	J	GTSRET				:bye

GTS12	L	R14,OPIOCB,R15			:even channel - Spirit output
	JAL	R13,DOWRIT			:else - Spirit output cmd

GTSRET	LM	R13,GTSSAV,,
	JR	R13

	SEG	A.DATA
GTSSAV	WS	3


	SUBTTL	CH1CMD   -   PROCESS CHANNEL 1 COMMAND

:	S U B R O U T I N E    -    C H 1 C M D

:	This subroutine processes a channel 1 request from spirit.

:	Calling sequence:

:			JAL	R13,CH1CMD
:	No inputs or outputs.

	SEG	A.CODE
CH1CMD	STM	R8,CH1SAV,,
	LA	R14,IOCB1,,			:addr of this IOCB
	LB	R2,CMD,R14			:get the cmd

	CHI	R2,RNTFAC			:* cmd is reset interface ?
	JN	CH04				:if not - jump
	LH	R0,RSETIP			:reset now in progress ?
	JL	CH02				:if so - log redundancy
	TS	RSETIP				:set reset in progress flag
CH000	LIS	R2,0				:reset other startup flags
	STH	R2,RXSRCD
	STH	R2,LMTRCD
	L	R2,THSRST,,			:update this & last reset time
	ST	R2,LSTRST,,
	L	R3,SLOWC,,			:current (secs)
	ST	R3,THSRST,,
	SR	R3,R2				:how long since prev reset ?
	CI	R3,MINRST
	JGEFS	CH00				:if more than minimum - ok
	LIS	R2,1				:if less - set no send to...
	STH	R2,MAYSND,,			:ISIS oring flag
CH00	JAL	R10,CRASH,,			:start the reset
	BC	0,0,R4*4,CCSPRS
:	program control does not return to here after the reset

CH02	EVT(ET.XRS,TS.XRS)              :LOG XTRA RESET INT. CMD AND IGNORE
        LIS     R9,1                    :CHANNEL 1
        JAL     R13,PNORMS              :PRESENT NORMAL STATUS
        J       CH1RET

CH04	CHI	R2,RXSTAT			:* cmd is read extnded stat ?
	JN	CH08				:if not - jump
	TS	RXSRCD				:set ext stat active flag
	LIS	R8,0				:no PST
	JAL	R13,GTSRWB			:get an srb (R6) & buf1(R7)
	AIS	R7,B1DATA
	LIS	R2,0
	STB	R2,RXLEN,R7
	LHI	R2,RXEND			:gather read ext data
	STB	R2,RXLEN+1,R7			:data length
	SRLS	R2,8
	STB	R2,RXLEN,R7
	LIS	R2,RXFORM
	STB	R2,RXFCOD,R7			:format code
	LH	R2,NODEX,,
	STB	R2,RXNODE+1,R7			:node nbr
	SRLS	R2,8
	STB	R2,RXNODE,R7
	LH	R2,HOSTX,,
	STB	R2,RXKHST+1,R7			:kernal host nbr
	SRLS	R2,8
	STB	R2,RXKHST,R7
	LH	R2,SLOTNO,,
	STB	R2,RXSLOT,R7			:slot nbr
	LH	R1,LCT,,			:ptr to crash table
	LH	R2,CRSHCT,R1
	STB	R2,RXCCNT+1,R7			:crash count
	SRLS	R2,8
	STB	R2,RXCCNT,R7
	LH	R2,CRASHC,R1
	STB	R2,RXLAST,R7			:reason for last reset
	STB	R2,RXCRSH+1,R7			:crash code
	SRLS	R2,8
	STB	R2,RXCRSH,R7			:reason for last reset
	LHI	R2,RDNSTA			:now fill in srb status
	STB	R2,SRBYTE,R6			:read data & status
	LIS	R2,1
	STB	R2,SRCHNL,R6			:channel 1
	LHI	R2,RXEND			:size of read ext data
	STH	R2,CNTMSB,R6
	LIS	R2,RTRNBF			:set flag for srdone to...
	SBT	R2,MSTAT,R6			:...release this buf1
	JAL	R13,ENQSRB			:enqueue the SRB
	J	CH1RET				:that's all

CH08	CHI	R2,LMAPTB			:* cmd is load mapping table ?
	JN	CH15				:if not - jump
	LCS	R2,1
	STH	R2,TBLPRT,,			:init the flag
	LH	R0,RSETIP			:is reset in progress ?
	JL	CH10				:if so - proceed
CH09	LIS	R6,1				:else - bad time for this msg
	LHI	R15,ILLCMD
	JAL	R13,BDIORB			:send error status to Spirit
	J	CH1RET
CH10	LH	R0,RXSRCD			:ext status already set ?
	JGEBS	CH09				:if not - ng

CH12	TS	LMTRCD				:set load map table info
	LB	R3,CB.MSB,R14			:store full load map tbl ...
	STB	R3,LMAPLN,,			:...length as found in IOCB
	LB	R3,CB.LSB,R14
	STB	R3,LMAPLN+1,,
	LIS	R3,0				:zero tbl length accumulator
	STH	R3,RMAPLN,,
	LH	R3,TBLPRT,,			:what part of table ?
	JLFS	CH120				:if the start - jump
	LIS	R2,1				:inc flag to 2nd part (port 0)
	STH	R2,TBLPRT,,	
	J	CH14
CH120	LIS	R2,0				:set flag that the part of...
	STH	R2,TBLPRT,,			:tbl for port non 0 is loading

:	Zero the current message translation tables
	LA	R2,TOSPPN,,			:addr of 1st table
	LI	R5,TBLEND-TOSPPN		:size of all tables together
	LCS	R3,4				:offset
	LIS	R4,0				:zero
CH13	AIS	R3,4				:inc offset
	ST	R4,0,R3,R2			:zero a word
	CR	R5,R3				:end of tables reached ?
	JGBS	CH13				:if not - do more

CH14	LIS	R8,0
	JAL	R13,GTSRWB			:get an srb & a buf1
	LHI	R2,WRTDAT			:tell Spirit to output data
	STB	R2,SRBYTE,R6
	LIS	R2,1				:channel 1
	STB	R2,SRCHNL,R6
	STB	R2,CNTLSB,R6			:request for 1 byte
	LA	R2,LMAPGT			:addr of done task
	ST	R2,RETADR,R6
	JAL	R13,ENQSRB			:send the srb
	J	CH1RET

CH15	CHI	R2,SUSPMB			:* cmd is suspend Mbase ?
	JN	CH22				:if not - jump
	L	R2,SRBQND,,			:get addr of last srb in q
CH17	LHI	R3,DONE
	TBT	R3,ISTAT,R2			:did ISIS process this srb ?
	JNFS	CH19				:if so - jump
	LHI	R3,MFLUSH
	SBT	R3,MSTAT,R2			:if not - set flush bit
	L	R2,SRBPRV,R2			:point to prev srb on srq
	JNBS	CH17				:if there's a prev - jump
CH19	JAL	R13,GETBF2			:get an srb
	LHI	R2,1				:channel 1
	STB	R2,SRCHNL,R6
	LHI	R2,YELLOW			:yellow srb - signal that...
	SBT	R2,MSTAT,R6			:flush was set on unused srbs
	LA	R2,SUSRET			:return addr after srdone
	ST	R2,RETADR,R6
	JAL	R13,ENQSRB			:send it off
	J	CH1RET

CH22	CHI	R2,RESUMB			:* cmd is resume Mbase ?
	JN	CH25				:if not - jump
	JAL	R13,GETBF2			:get an SRB
	LHI	R2,RDSTAT			:read status request
	STB	R2,SRBYTE,R6
	LIS	R2,1				:channel 1
	STB	R2,SRCHNL,R6
	LA	R2,RSMRET			:return addr after srdone
	ST	R2,RETADR,R6
	JAL	R13,ENQSRB			:send the srb
	J	CH1RET

CH25	CHI	R2,SETIMO			:* cmd is SBus timeout ?
	JEFS	CH27				:if so - good
	LIS	R6,1				:channel 1
	LHI	R15,ILLCMD			:illegal cmd
	JAL	R13,BDIORB,,			:log the error
	J	CH1RET
CH27	LIS	R8,0
	JAL	R13,GTSRWB			:get an SRB & buf1
	LHI	R2,WRTDAT			:request the timeout value
	STB	R2,SRBYTE,R6
	LIS	R2,1
	STB	R2,SRCHNL,R6
	STB	R2,CNTLSB,R6
	LA	R2,SBTIM			:addr of done routine
	ST	R2,RETADR,R6
	JAL	R13,ENQSRB			:send the SRB off


CH1RET	LM	R8,CH1SAV,,			:restore regs
	JR	R13

:       CRASH IF ONLY THE RESERVE SRB IS LEFT TO FINISH THE RESUME COMMAND
:       A CRASH IS NECESSARY BECAUSE RSMRET (CALLED BY SRDONE FROM THIS SRB)
:       CALLS FWRDIN, WHICH NEEDS SRBS TO FORWARD INPUT.
:       THIS IS AN IMPROBABLE EVENT BECAUSE ALL 'PENDING' SRBS ARE RETURNED
:       BEFORE SUSPEND CMD IS FINISHED.


	SEG	A.DATA
CH1SAV	WS	8				:reg save area
TBLPRT	HS	1				:0=normal msgs, 1=port 0 msgs
						:-1= not used now 


	SUBTTL	DOHIO  -  PROCESS HALT I/O

:	S U B R O U T I N E   -   D O H I O

:	This subroutine is called by GSPCMD to handle halt I/O request from Spirit.
:	IF SIO BYTE OF IOCB = 0, THEN CLEAR HIO AND RETURN, ELSE,
:	IF THERE IS NOTHING ON SRBQUE, CALL CMPHIO TO PRESENT STATUS INDICATING
:	THAT THE PENDING SIO WAS TERMINATED WITH STATUS INDICATING IOHALT, ELSE
:	ENQUE A 'YELLOW-BALL' SRB WITH THE ADDR OF THE SUBROUTINE DFRHIO PUT IN
:	THE RETADR FIELD OF THE SRB.  DFRHIO WILL COMPLETE THE HANDLING OF
:	THE HIO WHICH AT THIS POINT IS DEFERRED UNTIL THE EXISTING SRB QUEUE
:	HAS BEEN PROCESSED.

:	Calling sequence:

:			JAL   R13,DOHIO
:	Inputs:
:			R15 = PST address
:	No outputs.


	SEG	A.CODE
DOHIO	ST	R13,DOHSAV,,
	L	R2,OPIOCB,R15			:get IOCB addr
	LB	R3,SIO,R2			:io still in progress ?
	JNFS	DOH02				:if so - proceed
	LIS	R4,0
	STB	R4,HIO,R2			:if sio not active - clear hio
	J	DOHRET
DOH02	L	R2,SRBQUE			:any srb's on the queue ?
	JNFS	DOH06				:if so - jump
DOH04	JAL	R13,CMPHIO			:if not - complete hio
	J	DOHRET
DOH06	JAL	R13,GETBF2			:build a yellow srb
	LB	R4,OUTCHN,R15
	STB	R4,SRCHNL,R6			:store channel nbr
	LHI	R4,YELLOW
	SBT	R4,MSTAT,R6			:set yellow flag
	LA	R4,DFRHIO			:addr of done subroutine
	ST	R4,RETADR,R6
	ST	R15,PORTST,R6			:store the PST addr
	JAL	R13,ENQSRB			:send the srb
DOHRET	L	R13,DOHSAV,,
	JR	R13

	SEG	A.DATA
	GL	DOHSAV
DOHSAV	WS	1

	SUBTTL	DFRHIO  -  COMPLETE AN HIO THAT HAS BEEN DEFERRED

:	CALLED BY SRDONE FROM A 'YELLOW-BALL' SRB THAT WAS PUT ON THE
:	SRB QUEUE BY THE HANDLER OF AN HIO COMMAND

:       R15 = PST ADDR

	SEG	A.DATA
DFRHSV	WS	1
	SEG	A.CODE
DFRHIO	ST	R13,DFRHSV,,
	L	R2,OPIOCB,R15	:GET OUTPUT IOCB
	LB	R3,SIO,R2	:HAS THE SIO BEEN COMPLETED?
	JEFS	DFRHI0		:IF YES, JUMP
	JAL	R13,CMPHIO	:ELSE COMPLETE THE HIO COMMAND
DFRHI1	L	R13,DFRHSV,,
	JR	R13
DFRHI0	LIS	R4,0
	STB	R4,HIO,R2	:JUST CLEAR HIO BYTE AND GET OUT
	JBS	DFRHI1


	SUBTTL	CMPHIO  -  COMPLETE HALT I/O

:	S U B R O U T I N E   -   C M P H I O

:	This subroutine, called by DOHIO, completes the  halt I/O process.

:	Calling sequence:

:			JAL	R13,CMPHIO
:	Inputs:
:			R15 = PST address
:	No outputs.

	SEG	A.CODE
CMPHIO	STM	R13,CPHSAV,,
	ST	R8,SPH8SV,,
	LR	R8,R15				:copy PST addr
	LA	R14,OUTQUE,R8			:top of output queue
CMPH02	LIS	R15,0				:offset to next queue entry
	JAL	R13,DNDSNG			:remove queue entry
	JNBS	CMPH02				:if more to remove - do it
	LHI	R2,OUTPND			:clear PST flags
	RBT	R2,PSTFLG,R8
	LHI	R2,WRITIP
	RBT	R2,PSTFLG,R8
	LHI	R2,OPDFRD
	RBT	R2,PSTFLG,R8
	JAL	R13,GETBF2			:get an srb
	LHI	R2,RDSTAT			:send read status
	STB	R2,SRBYTE,R6
	LB	R2,OUTCHN,R8			:get channel nbr
	STB	R2,SRCHNL,R6
	LHI	R2,FAILED+IOHALT
	STB	R2,STBYT0,R6			:status
	JAL	R13,ENQSRB			:send the srb
	LM	R13,CPHSAV,,
	L	R8,SPH8SV,,
	JR	R13

	SEG	A.DATA
CPHSAV	WS	3
SPH8SV	WS	1



	SUBTTL	DRFHIO - DEFFERED HIO HANDLER

:	CALLED BY SRDONE



	SUBTTL	DOWRIT  -  HANDLE OUTPUT COMMAND

:	S U B R O U T I N E   -   D O W R I T

:	This subroutine is called by GSPCMD, and processes output 
:	requests received from Spirit.

:	Calling sequence:

:			JAL R13,DOWRIT
:	Inputs:
:			R14 = IOCB address
:			R15 = PST address
:	No Outputs.

	SEG	A.CODE
DOWRIT	ST	R13,DOWSAV,,
	LHI	R2,OUTPND			:output pending (not all data
	TBT	R2,PSTFLG,R15			:in oring yet) ?
	JE	DOWT02				:if not - start output
	LB	R2,SIGB1,R14			:get cmd byte
	LA	R3,TOSPPN,,			:ISIS to Spirit translation
	CLB	R2,ZAPMSG,R3			:cmd in IOCB is zap ?
	JEFS	DOWT02
	CLB	R2,GOBMSG,R3			:or gobbler msg ?
	JNFS	DOWT05				:if not - jump
DOWT02	JAL	R13,SSPOUT,,			:else - start spirit output
	JFS	DOWRET
DOWT05	LIS	R2,OPDFRD
	SBT	R2,PSTFLG,R15			:set output deferred flag
DOWRET	L	R13,DOWSAV,,
	JR	R13

	SEG	A.DATA
DOWSAV	WS	1

	SUBTTL	SSPOUT   -   START SPIRIT OUTPUT

:	S U B R O U T I N E   -   S S P O U T

:	This subroutine is called by ISOUT and DOWRIT, and initiates
:	output from Spirit.  The OPDFRD flag should be reset before this
:	routine is called.

:	Calling sequence:
:			JAL   R13,SSPOUT
:	Inputs:
:			R14 = IOCB address
:			R15 = PST address
:	No outputs.


	SEG	A.CODE
SSPOUT	ST	R13,SSPSAV,,
	LHI	R2,OUTPND			:write in progress flags
	SBT	R2,PSTFLG,R15
	LHI	R2,WRITIP
	SBT	R2,PSTFLG,R15
	JAL	R13,MOVSDT			:move data from spirit
      	L	R13,SSPSAV,,
	JR	R13

	SEG	A.DATA
SSPSAV	WS	1


	SUBTTL	MOVSDT  -  MOVE DATA FROM SPIRIT TO BUFFER

:	S U B R O U T I N E   -   M O V S D T

:	Called by Start Spirit Output task or ISIS Output task.

:	Calling sequence:

:			JAL   R13,MOVSDT
:	Inputs:
:			R14 = IOCB address
:			R15 = PST address

        SEG     A.CODE
MOVSDT	STM	R8,MOVSAV,,
	LB	R2,CMD,R14			:get output cmd from IOCB
	CLHI	R2,SNDSHR			:* cmd is send signal short ?
	JN	MOVS09				:if not - jump
	LR	R8,R15				:copy the PST addr
	JAL	R13,GETBF3			:else - get a short buf
	LB	R2,SIGB1,R14			:get Spirit msg type
	STB	R2,BUFMSG,R6			:put it in the buf
	LB	R3,TOISPN,R2,,			:get ISIS msg type
	LB	R3,LENGTH,R3,			:get length of msg
	SIS	R3,1				:remove byte for msg type
	STB	R3,BUFLEN,R6			:store the length
	JLEFS	MOVS04				:if no params - jump
	LB	R2,SIGB2,R14			:get 1st param
	STB	R2,B3DATA,R6			:store byte
	SIS	R3,1				:decr counter
	JLEFS	MOVS04				:if no more params - jump
	LB	R2,SIGB3,R14			:get 2nd param
	STB	R2,B3PDAT,R6			:store byte
MOVS04 	LHI	R3,WRITIP			:reset write in progress
	RBT	R3,PSTFLG,R15
        LR      R9,R6                           :COPY BUF ADDR
        LA      R10,SCSIGS                      :ADDR OF DONE ROUTINE
	JAL	R13,PRSTAT			:present normal status
	J	MOVRET

MOVS09	CLHI	R2,WRTBYT			:* cmd is write data byte ?
	JN	MOVS10				:if not - jump
	LR	R8,R15				:copy the PST addr
	JAL	R13,GETBF3			:else - get a short buf
	LH	R2,CBDATA,R14			:get data byte from IOCB
	STB	R2,B3DATA,R6			:store byte in the buf3
	LIS	R2,1
	STB	R2,BUFLEN,R6			:buf length - 1 byte
	LB	R2,SPDATA,,
	STB	R2,BUFMSG,R6			:data msg type
        LHI     R3,WRITIP
        RBT     R3,PSTFLG,R15                   :RESET WRITE-IN-PROG. FLG
        LR      R9,R6                           :COPY BUF ADDR
        LA      R10,WSBYTE                      :ADDR OF DONE ROUTINE
        JAL     R13,PRSTAT                      :PRESENT NORMAL STATUS
        J       MOVRET                  

MOVS10	CLHI	R2,SNDLNG			:* cmd is send signal long ?
	JN	MOVS13				:if not - jump
	LR	R8,R15				:copy the PST addr
	JAL	R13,GTSRWB			:get an Srb & buf1
	LHI	R2,WRTDAT			:write data requst to Spirit..
	STB	R2,SRBYTE,R6			:to send long signal msg
	LB	R2,OUTCHN,R15
	STB	R2,SRCHNL,R6			:channel nbr
	LA	R2,PRSGNL			:on receiving msg, call...
	ST	R2,RETADR,R6			:..process signal msg rtn
	ST	R15,PORTST,R6			:store the PST addr
	LB	R2,SIGB1,R14			:copy msg type into buf
	STB	R2,BUFMSG,R7
	LB	R2,CB.MSB,R14			:copy msg length into buf
	LB	R3,CB.LSB,R14
	STB	R2,CNTMSB,R6			:copy length into SRB
	STB	R3,CNTLSB,R6
	SLLS	R2,8
	OR	R2,R3
	STB	R2,BUFLEN,R7
	JAL	R13,ENQSRB			:send the srb
        LR      R9,0
        LA      R10,FINSIO                      :DONE ROUTINE ADDR
	JAL	R13,PRSTAT			:send normal status
	J	MOVS25

MOVS13	
	CLHI	R2,WRITE			:* cmd is write data long ?
	JE	MOVS15				:if so - good
	LB	R6,OUTCHN,R15			:else - illegal cmd
	LHI	R15,ILLCMD
	JAL	R13,BDIORB,,			:report the error
	J	MOVRET				:bye
MOVS15	LB	R2,CB.MSB,R14			:get data length msg
	LB	R3,CB.LSB,R14
	SLLS	R2,8
	OR	R2,R3				:length in r2
	STH	R2,SAVLEN,,			:save the length
	JN	MOVS17				:if nonzero - ok
        LIS     R9,0
        LA      R10,FINSIO
	JAL	R13,PRSTAT
        J       MOVS25
MOVS17	LR	R8,R15				:copy the PST addr
	JAL	R13,GTSRWB			:get an srb & buf1
	LHI	R2,WRTDAT			:write data request...
	STB	R2,SRBYTE,R6			:to send a data msg
	LB	R2,OUTCHN,R15
	STB	R2,SRCHNL,R6
	LA	R2,QBPOUT			:on receiving msg ...
	ST	R2,RETADR,R6			:queue data for output
	ST	R15,PORTST,R6			:store the PST addr
	LH	R2,SAVLEN,,			:put data length in R2
	LHL	R1,WRTCNT,R15
	SR	R2,R1				:less #chars received so far
	CHI	R2,BUF1MX			: remaining data fitn buf1 ?
	JLFS	MOVS18				:if so - jump
	LHI	R2,BUF1MX			:if not - request buf 1 full
MOVS18	STH	R2,CNTMSB,R6			:put write length in SRB
	STB	R2,BUFLEN,R7			:put write len in receiv buf
	AH	R2,WRTCNT,R15			:update write count in PST
	STH	R2,WRTCNT,R15
	LB	R2,SPDATA,,
	STB	R2,BUFMSG,R7			:put data type in receiv buf
	JAL	R13,ENQSRB			:send the request
	LH	R2,WRTCNT,R15			:has the whole buf been sent ?
	CLH	R2,SAVLEN,,
	JL	MOVRET				:if not - no PRSTAT yet
        LIS     R9,0
        LA      R10,FINSIO
	JAL	R13,PRSTAT			:send read status to Spirit
MOVS25	LHI	R2,WRITIP			:if done reset write in prog
	RBT	R2,PSTFLG,R15
	LIS	R2,0
	STH	R2,WRTCNT,R15			:zero the write count:
MOVRET	
	LM	R8,MOVSAV,,
	JR	R13

	SEG	A.DATA
	GL	MOVSAV
MOVSAV	WS	8
SAVLEN	HS	1



:       SUBROUTINE -- FINSIO -- FINISH SIO

:       ADDRESS OF THIS SUBROUTINE PLACED IN RETADR FIELD OF AN SRB...
:       ENQUEUED TO PRESENT NORMAL STATUS ON ANY WRITE SIO (40) OR...
:       ANY SEND CIRCUIT SIGNAL LONG SIO CMD (60)
:       ALSO CALLED BY WSBYTE (COMPLETES SIO OF 42) AND BY...
:       SCSIGS (COMPLETES SIO OF 64)
:       IT IS CALLED BY SRDONE

:       TESTS OPDFRD BIT OF OF PORT'S PSTFLG BIT ARRAY.  IF SET...
:       ANOTHER SIO HAS BEEN DEFERED, SO WILL BE STARTED UP BY...
:       A CALL TO SSPOUT.

:       IF THERE IS NOT A DEFERED SIO, THE OUTPND BIT IS CLEARED
        SEG     A.DATA
FSIOSV  WS      3
        SEG     A.CODE
FINSIO  STM     R13,FSIOSV,,
   	LHI	R3,OPDFRD			:deferred output ?
	TBT	R3,PSTFLG,R15
	JE	FINSI1				:if not - jump
	RBT	R3,PSTFLG,R15			:if so - reset deferred flag
        L       R14,OPIOCB,R15                  :OUTPUT IOCB ADDR
	JAL	R13,SSPOUT			:start Spirit output
        LM      R13,FSIOSV,,
        JR      R13
FINSI1	LHI	R3,OUTPND			:reset output pending
	RBT	R3,PSTFLG,R15
        LM      R13,FSIOSV,,
        JR      R13

:       WRITE SINGLE DATA BYTE
:       ADDRESS OF THIS SUBROUTINE PLACED IN RETADR FIELD OF AN SRB...
:       ENQUEUED TO PRESENT NORMAL STATUS ON ANY WRITE SINGLE BYTE..
:       SIO CMD (42).  CALLED BY SRDONE, IT WILL CALL QBPOUT TO PUT...
:       SINGLE BYTE BUFFER ON PST AND PST ON OUTPUT QUEUE.
:       THEN CALLS FINSIO TO 'FINISH' SIO CMD.

:       R14 = SRB ADDR

        SEG     A.DATA
WSBSAV  WS      3
        SEG     A.CODE
WSBYTE  STM     R13,WSBSAV,,
        L       R14,BUFADR,R14          :GET SHORT BUF ADDR
        JAL     R13,QBPOUT              :QUE BUF AND PST FOR OP
        JAL     R13,FINSIO              :FINISH SIO
        LM      R13,WSBSAV,,
        JR      R13




:       SEND CIRCUIT SIGNAL SHORT
:       ADDRESS OF THIS SUBROUTINE PLACED IN RETADR FIELD OF AN SRB...
:       ENQUEUED TO PRESENT NORMAL STATUS ON ANY SEND CIRCUIT SIGNAL...
:       SHORT SIO CMD (64).  CALLED BY SRDONE, IT WILL CALL PRSGNL...
:       WHICH WILL FURTHER 'PROCESS' THE SIGNAL (I.E., ZAP OR BACKPRSR)..
:       AND PUT THE BUFFERED SIGNAL ON PST AND PST ON OUTPUT QUEUE.
:       THEN CALLS FINSIO TO 'FINISH' SIO CMD.

:       R14 = SRB ADDR

        SEG     A.DATA
SCSGSV  WS      3
        SEG     A.CODE
SCSIGS  STM     R13,SCSGSV,,
        L       R14,BUFADR,R14                  :GET BUF ADDR
        JAL     R13,PRSGNL                      :PROCESS SIGNAL
        JAL     R13,FINSIO
        LM      R13,SCSGSV,,
        JR      R13


:       PRESENT STATUS (ENDS WRITE OR SEND SIO)
:       CALLED BY MOVSDT
:       R15 = PST ADDR
:       R9 = BUF ADDR (IN CASE OF SIO OF WRITE SINGLE BY OR SEND...
:       CIRCUIT SIGNAL SHORT) ELSE R9 MUST = 0
:       R10 = SUBROUTINE CALLED BY SR DONE TASK

        SEG     A.DATA
PRSTSV  WS      3
        SEG     A.CODE
PRSTAT  STM     R13,PRSTSV,,
        JAL     R13,GETBF2              :GET SRB BUF
        ST      R9,BUFADR,R6            :SAVE BUF ADDR (IF ANY)
        ST      R10,RETADR,R6           :WILL BE CALLED BY DONE TASK
        LHI     R0,RDSTAT               :READ STATUS SERV. REQ.
        STB     R0,SRBYTE,R6            :PUT IN SRB
        LB      R0,OUTCHN,R15           :CHANNEL NMBR
        STB     R0,SRCHNL,R6
        LIS     R0,0                    :CLEAR ALL STATUS BYTES
        ST      R0,STBYT0,R6
        JAL     R13,ENQSRB              :PUT ON SRB QUEUE
        LM      R13,PRSTSV,,
        JR      R13


	SUBTTL	QBPOUT - QUEUE BUFFER & PST FOR OUTPUT

:	S U B R O U T I N E   -   Q B P O U T

:	This subroutine adds a type 1 or 3 buffer to an ISIS output
:	queue for a given port.  If the PST isn't on the output queue,
:	the subroutine puts it on.

:	Calling sequence:

:			JAL   R13,QBPOUT
:	Inputs:
:			R14 = Address of buffer - normally
:			   or Address of SRB  - if called from SRDONE
:			R15 = Address of PST
:	No output.

	SEG	A.CODE
QBPOUT	ST	R14,QBPSAV,,
	CLI	R13,SRDBAK			:CALLED BY SRDONE?
	JNFS	QBP00
      	L	R14,BUFADR,R14			:else - load buf addr

QBP00	LHI	R2,ONIOPQ			:is PST on ISIS output q ?
	TBT	R2,PSTFLG,R15
	JN	QBP06				:if so - jump
	SBT	R2,PSTFLG,R15			:set to queue flag
	L	R2,ISOPQ,,			:get queue's 1st entry
	JN	QBP02				:if PSTs on q - jump
	ST	R15,ISOPQ,,			:if not - this is the 1st
	LIS	R2,0
	ST	R2,IOPQND
	J	QBP06				:go queue the buf
QBP02	L	R2,IOPQND,,			:add PST to existing q
	JNFS	QBP04				:if more than 1 PST - jump
	L	R2,ISOPQ,,
QBP04	ST	R2,OPQPRV,R15			:fix ptrs in PST being queued
	LIS	R3,0
	ST	R3,OPQNXT,R15
	ST	R15,OPQNXT,R2			:update ptr in last q'd PST
	ST	R15,IOPQND,,			:put new PST at end of q

:	queue the buffer to the PST
QBP06	LR	R14,R14				:is there really a buffer ?
	JE	QBPRET				:if not - bye
	L	R4,OUTQUE,R15			:get ptr to q of bufs
	JNFS	QBP08				:if something on buf q - jump
	ST	R14,OUTQUE,R15			:else - queue the buf
	J	QBPRET				:bye
QBP08	L	R5,0,R4				:is this last buf on q ?
	JEFS	QBP09				:if so - jump		
	LR	R4,R5				:if not - get next one
	JBS	QBP08
QBP09	ST	R14,0,R4			:if so - make this buf follow

QBPRET  IF      DB.QBP
        L       R4,PSTFLG,R15
        EVT(ET.QBP,TS.QBP,R13,R15,R14,R4)
        EI
      	L	R14,QBPSAV,,
	JR	R13

	SEG	A.DATA
QBPSAV	WS	1

	SUBTTL	PRSGNL  -  PROCESS SIGNAL MESSAGE

:	S U B R O U T I N E   -   P R S G N L

:	This subroutine is called when a circuit signal is
:	to be processed.  It is called by SRDONE when a long
:	signal message is received, and by MOVSDT when a short
:	one comes in.

:	Calling sequence:
:			JAL  R13,PRSGNL
:	Inputs:
:			R14 = Address of buffer (1 or 3) - from MOVSDT
:			  or  Address of SRB - from SRDONE
:			R15 = Address of PST
:	No outputs.

	SEG	A.CODE
PRSGNL	STM	R10,PRSSAV,,
	ST	R8,PRS8SV,,
	LR	R8,R15				:copy the PST addr
	CLI	R13,SRDBAK			:CALLED BY SRDONE?
	JNFS	PRS00
      	L	R14,BUFADR,R14			:GET BUFFER ADDR
PRS00	LB	R2,PORT,R15
	JEFS	PRS01				:if port 0 - jump
	LA	R4,TOISPN,,			:normal port msg
	JFS	PRS02
PRS01	LA	R4,TOISP0,,			:port 0 msg
PRS02	LB	R2,BUFMSG,R14			:get msg type
	LB	R3,0,R4,R2,			:get ISIS msg type
	STB	R3,MSGBYT,,
	CLHI	R3,0F0				:msg type > F0 ?
	JGFS	PRS022				:if so - maybe a special msg
	LR	R3,R3
	JGFS	PRS03				:if normal msg - jump
	RESET(R13,CCUMSG)			:if invalid msg - crash

PRS022	JAL	R13,SPECAL			:process special Spirit msg
	J	PRSRET				:bye

PRS03	CHI	R3,DETMSG			:* msg is detach ?
	JEFS	PRS05
	CHI	R3,ZAPMSG			:* msg is zap ?
	JEFS	PRS05
	CHI	R3,ZAPACK			:* msg is zap acknowlege ?
	JE	PRS05
	CHI	R3,ZAPREA			:* msg is zap with reason ?
	JN	PRS20				:if not - jump
PRS05	LHI	R2,ZAPFSP			:set flag - zap from Spirit
	SBT	R2,PSTFLG,R15
	LHI	R2,ZAPFIS
	TBT	R2,PSTFLG,R15			:already got zap from ISIS ?
	JE	PRS10				:if not - jump

:	ISIS initiated zap
:	At this point we have received a zap from Spirit after receiving
:	one from ISIS.  If the zap from Spirit was in response to the one
:	from ISIS, we can proceed normally.  If not, the 2 ends of the
:	circuit decided to zap it simultaniously, but ISIS won the race.
:	So now we have to make sure that the circuit does not go away
:	(by returning a zap to ISIS) until Spirit receives a zap from us.
	LHI	R2,ZAPTSP			:was a zap sent to Spirit ?
	TBT	R2,PSTFLG,R15			
	JN	PRS058				:if so - proceed normally
	ST	R14,BUFSAV,R15			:save addr of zap buffer

:	The zap that came from ISIS has been sent to the inque.
:	To give it time to be processed,
:	we'll put a yellow SRB on the queue, which will activate
:	ZAPTOI.  By the time ZAPTOI runs, the zap will have certainly reached
:	Spirit.  Thus, with a clear conscience, ZAPTOI will send the zap 
:	to ISIS.

        JAL     R13,ENQYLB              :ENQUE A 'YELLOW-BALL' SRB
	J	PRSRET

PRS058	STM	R14,PRXSAV,,
	LA	R14,OUTQUE,R15			:flush port's output queue
PRS06	LIS	R15,0
	JAL	R13,DNDSNG			:remove an entry
	JNBS	PRS06				:if more on queue - go back
	LM	R14,PRXSAV,,
	JAL	R13,QBPOUT			:put zap on output queue
	LB	R11,PORT,R15
	JAL	R13,CMPLZP			:complete the zap processing
	J	PRSRET				:bye

:	Spirit initiated zap
PRS10	ST	R14,BUFSAV,R15			:save addr of data buf
	LHI	R2,ZAPFSP			:set flag that Spirit...
	SBT	R2,PSTFLG,R15			:started the zap
	STM	R10,PRXSAV,,			:flush bufs on input queue
	LA	R14,INQUE,R15
	L	R10,0,R14			:get 1st entry on inque
	JE	PRS13				:if nothing there - jump
	LB	R3,BUFTYP,R10
	CHI	R3,BUFTP1
	JN	PRS12				:if not type 1 buf - jump
	LB	R3,BSPLIT,R10
	JE	PRS12				:if buffer not split - jump
PRS11	LIS	R6,1
	STB	R6,SPLIT,,			:flag the split buffer
	L	R6,BUFNXT,R10			:if split - chuck others
	JE	PRS115				:if no next - bye
PRS116	LB	R5,BUFTYP,R6
	L	R11,BUFNXT,R6
	JAL	R13,RETBUF
	LR	R11,R11				:anymore buffers ?
	JE	PRS115				:if not - jump
	LR	R6,R11
	J	PRS116				:get rid of next buf
PRS115	LIS	R3,0
	ST	R3,BUFNXT,R10			:split buf has no next buf
	JFS	PRS13

PRS12	LIS	R15,0
	JAL	R13,DNDSNG			:remove an entry
	JNBS	PRS12				:if q not empty - proceed
PRS13	LB	R2,MSGBYT,,
	CHI	R2,DETMSG
	JE	PRS16				:if detach msg - jump
	LA	R14,OUTQUE,R8			:else - flush output queue
PRS14	LIS	R15,0
	JAL	R13,DNDSNG
	JNBS	PRS14
	LA	R14,ISOPQ			:remove pst from isout q
	LA	R10,IOPQND
	LHI	R12,OPQNXT
	LR	R15,R8
	JAL	R13,DEQPST
	LHI	R2,ONIOPQ			:reset on output q flag
	RBT	R2,PSTFLG,R8
PRS16	LM	R10,PRXSAV,,

:	Put a zapack on the inque, to be sent when possible.
	JAL	R13,GETBF3
	LA	R3,TOSPPN,,
	LB	R2,ZAPACK,R3
	STB	R2,BUFMSG,R6
	OI	R6,80000000			:flag buf as a zapack
	LB	R2,SPLIT,,
	JE	PRS18				:if no split - this is 1st
	LIS	R2,0
	STB	R2,SPLIT,,
	L	R2,INQUE,R15			:we have a split buf...
	ST	R6,0,R2				:... this buf goes 2nd
        J       PRSRET
PRS18	ST	R6,INQUE,R15
        LHI     R2,ZAPINQ               :WE'RE PUTTING A BUFFERED ZAP ON...
        SBT     R2,PSTFLG,R15           :THE INPUT QUEUE
PRS19	JAL	R13,FWRDCS			:send the msg to Spirit
        JAL     R13,ENQYLB              :ENQUE A 'YELLOW-BALL' 
	J	PRSRET

PRS20	CHI	R3,GOBMSG			:* msg is a gobbler
	JN	PRS25				:if not - jump
	STM	R14,PRXSAV,,
	LA	R14,OUTQUE,R15			:flush port's output q
PRS21	LIS	R15,0
	JAL	R13,DNDSNG			:remove an entry
	JNBS	PRS21				:if q not empty - proceed
PRS22	LM	R14,PRXSAV,,
	JAL	R13,QBPOUT			:put gobbler on output q
	J	PRSRET				:that's all

PRS25	CHI	R3,NOSMSG			:* msg is backpressure ?
	JN	PRS29				:if not - jump
	LIS	R6,1
	JAL	R13,HSPBPR			:handle Spirit bp request
PRS27	LB	R5,BUFTYP,R14			:release msg buf
	LR	R6,R14
	JAL	R13,RETBUF
	J	PRSRET

PRS29	CHI	R3,SNDMSG			:* msg is relse backpressure ?
	JN	PRS32				:if not - jump
	LIS	R6,0
	JAL	R13,HSPBPR			:handle Spirit bp request
	J	PRS27				:go release the buf

PRS32	CHI	R3,SXMLMT			:* msg is set xmt limit ?
	JN	PRS45				:if not - jump
	LB	R2,BUFTYP,R14			:check buf type
	CHI	R2,1				:type 1 ?
	JNFS	PRS35
	LB	R2,B1DATA,R14
	JFS	PRS37
PRS35	LB	R2,B3DATA,R14
PRS37	STH	R2,XMTLIM,R15			:put new limit in PST
	JAL	R13,QBPOUT			:put msg on output queue
	J	PRSRET

PRS45	JAL	R13,QBPOUT			:* queue other msgs for output

PRSRET	LM	R10,PRSSAV,,
	L	R8,PRS8SV,,
	JR	R13

	SEG	A.DATA
PRSSAV	WS	6
PRS8SV	WS	1
CMZSAV	WS	4
PRXSAV	WS	6
MSGBYT	BS	1
SPLIT	BS	1

	SUBTTL	ZAPTOI  -  SEND ZAP OR DETACH TO ISIS

:	S U B R O U T I N E   -   Z A P T O I

:	This subroutine sends a zap or detach message to ISIS.
:	It is called by SRDONE after Spirit initiates a zap sequence.

:	Calling sequence:
:			JAL   R13,ZAPTOI
:	Inputs:
:			R15 = PST address
:	No outputs.

	SEG	A.CODE
	GL	ZAPTOI
ZAPTOI	STM	R10,PRSSAV,,
        LHI     R2,ZAPINQ               :TEST BUFFERED-ZAP-ON-INQUE BIT
        TBT     R2,PSTFLG,R15           
        JEFS    ZAPTO0                  :PROCEED IF NOT SET
        JAL     R13,FWRDCS              :ELSE, TRY TO FORWARD IT
        JAL     R13,ENQYLB              :KEEP THIS CYCLE UP UNTIL ZAP CLEARS
        svc     dismiss
        j       zapret
ZAPTO0  EQ      .
	LHI	R2,ZAPTSP			:set flag that Sp got a zap
	SBT	R2,PSTFLG,R15
	LHI	R2,ZAPTIS			:set flag of zap to ISIS
        TBT     R2,PSTFLG,R15                   :IF ALREADY DONE, GET OUT
        JN      ZAPRET
	SBT	R2,PSTFLG,R15
	L	R14,BUFSAV,R15			:get addr of ISIS zap msg
	JAL	R13,QBPOUT			:put msg on output queue
	LHI	R2,ZAPFIS
	TBT	R2,PSTFLG,R15			:zap received from ISIS ?
	JEFS	ZAPRET				:if not - bye
        LB      R11,PORT,R15
        JAL     R13,CMPLZP			:else - complete zap
ZAPRET	LM	R10,PRSSAV,,
	JR	R13				


:	ENQUE "YELLOW-BALL" SERVICE REQUEST BLOCK
:	LINKS ON R13

:	This is called by ZAPTOI if ZAPTOI finds that there is a buffered
:	zap on the pst input queue.  Also called by the req. starter task
:	subroutine that enqueues a 'zap ack' buffer on the input queue.
:	(A zap or zap ack buffer could stay on the input and never be 
:	forwarded if there was no read at the time of the first attempt
:	to forward the buffered zap/zap ack

	SEG	A.DATA
YBLSAV	WS	1
	SEG	A.CODE
ENQYLB	ST	R13,YBLSAV,,
	JAL	R13,GETBF2
	LB	R2,INCHNL,R15
	STB	R2,SRCHNL,R6
	LHI	R2,YELLOW
	SBT	R2,MSTAT,R6
	LA	R2,ZAPTOI
	ST	R2,RETADR,R6
	JAL	R13,ENQSRB
	L	R13,YBLSAV,,
	JR	R13


	SUBTTL	SNTZAP  -  A ZAP WAS SENT TO SPIRIT

:	S U B R O U T I N E   -   S N T Z A P

:	This subroutine is called by SRDONE whenever a zap message
:	which came from ISIS is sent to Spirit.  The routine sets the
:	zap to Spirit flag.

:	Calling sequence:
:			JAL  R13,SNTZAP
:	Inputs:
:			R15 = PST address
:	No outputs.

	SEG	A.CODE
SNTZAP	LHI	R2,ZAPTSP
	SBT	R2,PSTFLG,R15
	JR	R13


	SUBTTL	SUSRET  -  SUSPEND COMMAND DONE ROUTINE

:	S U B R O U T I N E   -   S U S R E T  &  R X T R E T

:	This is the done routine, called by SRDONE, to complete
:	the suspend or read extended status requests.

:	Calling sequence:
:			JAL   R13,SUSRET  for suspend
:			JAL   R13,RXTRET  for read extended status
:	No inputs or outputs.

	SEG	A.CODE
SUSRET
RXTRET	ST	R13,SUSSAV,,
	ST	R9,SUS9SV,,
RXT02	LIS	R9,1				:channel 1
	JAL	R13,PNORMS			:present normal status
	L	R13,SUSSAV,,
	L	R9,SUS9SV,,
	JR	R13

	SEG	A.DATA
SUSSAV	WS	1
SUS9SV	WS	1
	SUBTTL	BFLSHQ   -   BUILD THE FLUSH QUEUE

:	S U B R O U T I N E   -   B F L S H Q

:	This subroutine is called by SRDONE when the flush bit in
:	ISTAT of the SRB is set.  The subroutine fills in the top
:	and end pointers of the flush queue.

:	Calling sequence:
:			JAL   R13,BFLSHQ
:	Inputs:
:			R14 = Address of the SRB
:	No output.

	SEG	A.CODE
BFLSHQ	L	R2,FLUSHQ			:get top of flush queue
	JN	BFL02				:if not empty - jump
	ST	R14,FLUSHQ			:if empty - fill it in
	JR	R13
BFL02	ST	R14,FLSQND			:fill in end of queue ptr
	JR	R13


	SUBTTL	RSMRET   -  RESUME COMMAND DONE ROUTINE

:	S U B R O U T I N E   -   R S M R E T

:	This subroutine is called by SRDONE to complete the
:	processing of a resume command.


:	Calling sequence:
:			JAL   R13,RSMRET
:	No input or output.


	SEG	A.CODE
RSMRET
	L	R4,SUSQUE			:anything on suspend queue ?
	JN	RSM10				:if so - jmp
	L	R4,FLUSHQ			:anything on flush queue ?
	JE	RSMOUT				:if not - nothing to do - bye
	L	R5,FLSQND			:...SRBQUE pointers
	J	RSM24
RSM10	L	R3,FLUSHQ			:anything on flush queue ?
	JN	RSM20				:if so - put both q ptrs back
	L	R5,SUSQND			:...SRBQUE pointers
	J	RSM24
RSM20	LR	R4,R3				:put top of flush q in R4
	L	R5,SUSQND			:get end of suspend queue
        JN      RSM21                   :IF ONLY ONE SRB ON QUEUE,
        L       R5,SUSQUE               :SET POINTER TO THAT SRB
RSM21
        L       R2,SUSQUE                       :get top of suspend queue
	L	R3,FLSQND			:get end of flush queue
        JN      RSM22                   :IF ONLY ONE SRB IN QUEUE,
        L       R3,FLUSHQ               :SET POINTER TO THAT SRB
RSM22
	ST	R2,SRBNXT,R3			:make suspend follow flush
	ST	R3,SRBPRV,R2			:make flush preceed suspend

:	R4 contains the address of the 1st SRB, and R5 has the address of
:	the last SRB to be added to the SRB queue.  Integrate the suspended
:	SRBs into the srb queue, and update the queue pointers.
RSM24	L	R2,SRBQUE			:anything on the srb queue ?
	JN	RSM26				:if so - jump
	ST	R4,SRBQUE			:susp stuff becomes the q
	ST	R5,SRBQND
	J	RSM40				:go issue the svc
RSM26	L	R3,SRBQND			:how many srbs on queue ?
	JN	RSM30				:if more than 1 - jump
	ST	R4,SRBNXT,R2            :IF 1 - LINK STUFF TO TOP
	ST	R2,SRBPRV,R4            :SET UP PREVIOUS SRB PTR
RSM27	LR	R5,R5				:how many srbs to add ?
	JE	RSM28				:if only 1 - jump
	ST	R5,SRBQND			:update the eoq ptr
	J	RSM37				:check if svc should be issued
RSM28	ST	R4,SRBQND
	J	RSM37
RSM30	ST	R4,0,R3				:link new stuff to bottom of q
	ST	R3,4,R4				:set up prev srb ptr
	LR	R2,R3
	J	RSM27				:update the eoq ptr

:	check if the svc should be issued
RSM37	LIS	R3,EOQ
	TBT	R3,ISTAT,R2			:did ISIS reach former eoq ?
	JE	RSM50				:if not - no svc 


:	issue the svc to tell ISIS to service the srbque
RSM40	ST	R15,RSMSAV,,
	LR	R15,R4
	IF	DRIVON
	SVC	MBASE,0,R15
	JN	ENQERR				:if no good - process error
	EI
	L	R15,RSMSAV,,	

RSM50	LIS	R2,0				:reset flush & suspend q ptrs
	ST	R2,FLUSHQ
	ST	R2,FLSQND
	ST	R2,SUSQUE
	ST	R2,SUSQND

RSMOUT	JR	R13


	SEG	A.DATA
RSMSAV	WS	1




	SUBTTL	LMAPGT   -   GET THE LOAD MAPPING TABLE DONE ROUTINE

:	S U B R O U T I N E   -   L M A P G T	

:	This subroutine is called by SRDONE, and gets a segment of
:	the load mapping table.

:	Calling sequence:
:			JAL   R13,LMAPGT
:	Input:
:			R14 = Address of SRB
:	No output.

	SEG	A.CODE
LMAPGT	STM	R8,CH1SAV,,
	L	R14,BUFADR,R14			:get buffer addr
	LB	R2,B1DATA,R14			:get map length (this part)
	STH	R2,MSEGLN,,			:save it
	LB	R5,BUFTYP,R14
	LR	R6,R14
	LIS	R8,0
	JAL	R13,RETBUF			:release the buffer
	LH	R0,RMAPLN,,			:update sum of map seg lengths
	LH	R2,MSEGLN,,
	AR	R0,R2
	STH	R0,RMAPLN,,
	LH	R1,TBLPRT,,			:which part of map tbl ?
	JN	LMAPXB				:if port 0 - jump
	AIS	R0,2				:add 2 for length bytes
	CLH	R0,LMAPLN,,			:IOCB len reached or passed ?
	JL	LMAPXX				:if not - proceed
LMAPXA	LHI	R15,LMLNER			:if so - no good
	LIS	R6,1				:channel nbr
	JAL	R13,BDIORB			:report the error
	J	LMAP10				:leave
LMAPXB	AIS	R0,2				:check port 0 part for match
	CLH	R0,LMAPLN,,
	JGBS	LMAPXA				:if too much being sent  - ng
LMAPXX	LH	R2,MSEGLN,,
	JE	LMS13				:if no length - end of tbl seg
	LIS	R8,0				:no PST
	JAL	R13,GTSRWB			:get an SRB & buf1
	LH	R2,MSEGLN,,			:get the segment length
LMAPG0	CHI	R2,BUF1MX-1			:which is smaller ?
	JLEFS	LMAP02				:if table size - read that
	LHI	R2,BUF1MX-1			:if buf size - read that amt
LMAP02	STH	R2,CNTMSB,R6			:rd len must be divisable by 4
	STB	R2,BUFLEN,R7			:put size into buf header
	LHI	R2,WRTDAT			:write data request
	STB	R2,SRBYTE,R6
	LIS	R2,1
	STB	R2,SRCHNL,R6			:channel 1
	LA	R2,LMAPST			:addr of rtn to store map
	ST	R2,RETADR,R6
	LH	R2,MSEGLN,,			:get load map length
	LB	R3,BUFLEN,R7
	SR	R2,R3				:decr by amt to be sent
	STH	R2,MSEGLN,,			:amt still to get
	JAL	R13,ENQSRB			:send request to Spirit
LMAP10	LM	R8,CH1SAV,,
	JR	R13

	SEG	A.DATA
MSEGLN	HS	1				:length of this load map seg
LMAPLN	HS	1				:load map length from 1st IOCB
RMAPLN	HS	1				:sum of lengths in 2 segs
XMAPLN	HS	1				:extra load map table length
XLMBUF	HS	1				:counter of extra map requests

	SUBTTL	LMAPST  -  STORE THE LOAD MAPPING TABLE DONE ROUTINE

:	S U B R O U T I N E   -   L M A P S T

:	This subroutine is called by SRDONE, and stores away the
:	load mapping table, as it is received from Spirit.

:	Calling sequence:
:			JAL   R13,LMAPST
:	Input:
:			R14 = Address of SRB
:	No output.

	SEG	A.CODE
LMAPST	STM	R8,CH1SAV,,
	L	R14,BUFADR,R14			:get buffer addr
	LIS	R1,0				:offset into data
	LH	R2,TBLPRT,,			:which seg of table ?
	JNFS	LMS02
	LA	R2,TOSPPN,,			:normal part
	LA	R3,TOISPN,,
	JFS	LMS03
LMS02	LA	R2,TOSPP0,,			:port 0 msgs
	LA	R3,TOISP0,,
LMS03	LB	R5,BUFLEN,R14			:amt of data received
LMS04	LA	R4,B1DATA,R1,R14		:start addr of received data

:	Do a basic validity check on the data in the load mapping table
	LB	R0,0,R4				:is this byte = 0 ?
	JN	LMS042				:if not - the table is bad
	LB	R0,2,R4				:is this byte = 0 or 80 ?
	JEFS	LMS044				:if so - good
	CHI	R0,80
	JEFS	LMS044
LMS042	LHI	R15,BDLMAP			:if not - report error
	LHI	R6,1				:channel 1
	JAL	R13,BDIORB
	J	LMSRET				:bye

LMS044	LB	R6,1,R4				:Spirit msg type
	LB	R7,3,R4				:ISIS msg type
	LB	R0,2,R4
	JNFS	LMS07				:if special action - jump
LMS05	STB	R7,0,R6,R3			:from Spirit to ISIS entry
	LR	R7,R7				:negative offset ?
	JL	LMS11				:if so - don't store
	STB	R6,0,R7,R2			:from ISIS to Spirit entry
	J	LMS11
LMS07	CHI	R7,NLGSTR			:login string ?
	JNFS	LMS09				:if not - jump
	LHI	R7,NLOGCH			:if so - normal login char
	J	LMS05				:go store it
LMS09	XHI	R7,0FFFF			:neg the special action code
	J	LMS05				:go store it
LMS11	AIS	R1,4				:inc data offset
	CR	R1,R5				:all data been handled ?
	JL	LMS04				:if not - do s'more

LMS12	LR	R6,R14				:buf1 addr
	LB	R5,BUFTYP,R6			:buf type
	LIS	R8,0				:no PST
	JAL	R13,RETBUF			:release the buf1
	LH	R2,MSEGLN,,			:more data in this part ?
	JE	LMS13				:if not - end of this part

	LIS	R8,0				:no PST
	JAL	R13,GTSRWB			:get a new SRb & buf1
	LH	R2,MSEGLN,,			:# bytes remaining in buf seg
	J	LMAPG0				:else - get more (in LMAPGT)
LMS13	LH	R12,TBLPRT,,			:which part of tbl is done ?
	JN	LMS15				:if port 0  - we got it all
	LIS	R12,1				:else - set flag for port 0
	STH	R12,TBLPRT,,
	J	CH14				:get table length (in CH1CMD)
LMS15	LCS	R2,1
	STH	R2,TBLPRT,,			:reset table section flag


:	Put commonly checked messages in easy to find places.
	LA	R2,TOSPPN,,			:ISIS to Spirit translation
	LB	R3,1,R2
	STB	R3,SPDATA,,			:data msg
	LB	R3,ZAPMSG,R2
	STB	R3,SPZAP,,			:zap msg
	LB	R3,GOBMSG,R2
	STB	R3,SPGOB,,			:gobbler msg
	LB	R3,NOSMSG,R2
	STB	R3,SPBAKP,,			:backpressure msg
	LB	R3,SNDMSG,R2
	STB	R3,SPRLBP,,			:release backpressure msg
	LB	R3,NLOGCH,R2
	STB	R3,SPLOGS,,			:login string msg

:	Check if all of the data specified in the IOCB has been received.
:	The length found in the IOCB can be longer than the sum of the
:	information found in the 2 sections of the load mapping table.
:	If at this point, when both sections of the table have been serviced,
:	the IOCB data length has not been satesfied, request this additional
:	filler and throw it away.
	LIS	R3,0
	STH	R3,XLMBUF,,			:zero the extra request count
	LH	R8,LMAPLN,,			:get length given in IOCB
	SH	R8,RMAPLN,,			:decr by length of 2 tbl segs
	SIS	R8,2				:decr by 2 length bytes
	JLE	LMS25				:if zero - process normally
	STH	R8,XMAPLN,,			:store #bytes left to read
LMS17	JAL	R13,GTSRWB			:request the filler data ...
	LR	R2,R8				:...from Spirit
	CHI	R2,BUF1MX
	JLEFS	LMS19
	LHI	R2,BUF1MX
LMS19	STH	R2,CNTMSB,R6			:length of data request
	STB	R2,BUFLEN,R7
	SR	R8,R2				:decr amount left to request
	LHI	R2,WRTDAT
	STB	R2,SRBYTE,R6
	LIS	R2,1
	STB	R2,SRCHNL,R6			:channel 1
	LA	R2,XMAPRQ
	ST	R2,RETADR,R6			:addr of return routine
	JAL	R13,ENQSRB			:send off the request
	LH	R2,XLMBUF,,			:inc extra request counter
	AIS	R2,1
	STH	R2,XLMBUF,,
	LR	R8,R8				:more extra data to request ?
	JG	LMS17				:if so - go do it
	J	LMSRET				:if not - bye

LMS25	LIS	R2,0
	STH	R2,RSETIP,,			:clear reset in progress
	STH	R2,RXSRCD,,			:clear ext status flag
	STH	R2,LMTRCD,,			:clear load map flag
	LIS	R9,1				:channel 1
	JAL	R13,PNORMS			:send normal status
LMSRET	LM	R8,CH1SAV,,
	JR	R13

	SUBTTL	XMAPRQ  -  HANDLE EXTRA LOAD MAP DATA REQUESTS

:	S U B R O U T I N E   -   X M A P R Q

:	This map requests the extra filler data from Spirit at the
:	end of load mapping table sequence, and throws it away.

:	Calling sequence:
:			JAL	R13,XMAPRQ

:	Inputs:
:			R14 = Address of SRB

	SEG	A.CODE
XMAPRQ	STM	R8,CH1SAV,,
	L	R6,BUFADR,R14			:get the sent data buf addr
	LB	R5,BUFTYP,R6
	LIS	R8,0				:no PST
	JAL	R13,RETBUF			:release the buffer
	LH	R2,XLMBUF,,			:get counter of extra buffers
	SIS	R2,1				:decr it
	JLE	LMS25				:if none left - finish up ...
						:... load map table processing
	STH	R2,XLMBUF,,			:get ready for next xtra buf
	LM	R8,CH1SAV,,
	JR	R13

	SUBTTL	SBTIM  -  COMPUTE THE S-BUS TIMEOUT VALUE

:	S U B R O U T I N E  -  S B T I M

:	This subroutine receives the number of S-BUS timeout in units
:	of intervals.  It takes this value and converts it to clock ticks.
:	This routine is called by SRDONE.

:	Calling sequence:

:			JAL   R13,SBTIM
:	Inputs:
:			R14 = SRB address
:	No outputs.

	SEG	A.CODE
SBTIM   STM     R8,SBSAV,,
	L	R3,BUFADR,R14			:point to the received buffer
	LB	R2,B1DATA,R3			:get #timeout intervals
	LIS	R1,TMINTV			:seconds per interval
	MHR	R1,R2
        LHL     R2,NRATE+2,,                    :GET TICKS PER SEC
        MHR     R1,R2                           :CALCULATE TIMEOUT
	ST	R1,SBUSTO			:#ticks in timeout interval
	LIS	R9,1
        ST      R3,SBSAV1,,
	JAL	R13,PNORMS			:present normal status
        L       R3,SBSAV1,,
	LB	R5,BUFTYP,R3			:release the buf1
        L       R6,BUFADR,R14                   :RETURN SBUS BUF
	LIS	R8,0
      	JAL	R13,RETBUF
        LM      R8,SBSAV,,
	JR	R13

	SEG	A.DATA

SBSAV   WS      8
SBSAV1  WS      1

 	SUBTTL	DOREAD  -  HANDLE READ DATA REQUEST

:	S U B R O U T I N E   -   D O R E A D

:	This subroutine is called by STSPCM when a read command is
:	received from Spirit.

:	Calling sequence:
:			JAL   R13,DOREAD
:	Input:
:			R14 = Address of IOCB
:			R15 = Address of PST

	SEG	A.CODE
DOREAD	ST	R13,DORSAV,,
	LHI	R2,READGO
	SBT	R2,PSTFLG,R15
	L	R2,INQUE,R15			:get input queue
	JN	DORD02				:if something on it - jump
	LHI	R2,BPTOIS			:else - nothing from ISIS
	TBT	R2,PSTFLG,R15			:was a BP msg sent to ISIS ?
	JE	DORRET				:if not & nothing q'd - bye
	LIS	R6,0
	JAL	R13,HSPBPR			:handle Spirit BP request
	JFS	DORRET
DORD02	
	JAL	R13,FWRDIN			:send data to Spirit

DORRET	L	R13,DORSAV,,
	JR	R13

	SEG	A.DATA
DORSAV	WS	1


	SUBTTL	SPECAL  -  HANDLE SPECAL CODE

:	S U B R O U T I N E   -   S P E C A L

:	This subroutine is called by PRSGNL, and handles special
:	messages received from Spirit which are not to be sent to ISIS.

:	Calling sequence:
:			JAL 	R13,SPECAL
:	Inputs:
:			R14 = Address of buffer
:			R15 = Address of PST

	SEG	A.CODE
SPECAL	STM	R8,SPCSAV,,
	LB	R2,MSGBYT,,			:get the ISIS msg type
	LHI	R3,NATOBP
	CHI	R2,AUTOBP			:* cmd is auto BP on ?
	JNFS	SPEC02				:if not - jump
	RBT	R3,PSTFLG,R15			:Mbase may apply BP
	J	SPEC12				:skip PNORMS (done in MOVSDT)
SPEC02	CHI	R2,NATBP			:* cmd is auto BP off ?
	JNFS	SPEC05				:if not - jump
	SBT	R3,PSTFLG,R15			:Mbase may not apply BP
	J	SPEC12				:skip PNORMS (done in MOVSDT)
SPEC05	CHI	R2,FWDCHR			:* cmd is frwd charactristcs ?
	JN	SPEC12				:if not - throw msg away
SPEC07	LB	R2,B1DATA,R14			:get mask byte
	STH	R2,DFCMSK,R15			:store it in PST
	LR	R10,R2				:get storred value
	JAL	R13,DEFFCH
	LB	R2,B1DATA+1,R14			:timeout value
	MH	R2,NRATE+2,,			:mult by clock ticks per sec
	LHI	R3,$A 20			:in 1/20 sec intervals
	DHR	R2,R3				:change to secs
	STH	R3,DFCTIM,R15
	OR	R10,R3
	LB	R2,B1DATA+2,R14			:FIRST LENGTH BYTE
	STB	R2,DFCLIM,R15
        LB      R2,B1DATA+3,R14                 :2ND LEN BYT
        STB     R2,DFCLIM+1,R15
	LHI	R3,DFCACT
	OR	R10,R2
	JEFS	SPEC9
	SBT	R3,PSTFLG,R15			:set flag is any DFCs active
	JFS	SPEC12
SPEC9	RBT	R3,PSTFLG,R15			:if not - reset flag

SPEC12	LB	R5,BUFTYP,R14
	LR	R6,R14
	LR	R8,R15				:copy PST addr
	JAL	R13,RETBUF			:release the buf

SPCRET	LM	R8,SPCSAV,,
	JR	R13

	SEG	A.DATA
SPCSAV	WS	8
    

:%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%^%%^%^%
:!@#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!

	SUBTTL	ISOUT  -  ISIS OUTPUT TASK

:	FILE   -   ISOUT.MBS


:	I S I S    O U T P U T    T A S K

:	This task moves buffered messages that were sent to Mbase
:	from Spirit, and passes them on to ISIS.  Specifically,
:	it takes messages that are buffered in the ISIS Output Queue, 
:	and transfers them to the ISIS Output Ring. 

:	This task runs in the slot background, and is called by the
:	background Exec Loop with the call:

:			JAL   R13,ISOUT

:	Registers 8 - 15 are preserved.


:**********************************************************************
:**********************************************************************

:	M A I N     L O O P

	SEG	A.CODE

ISOUT	STM	R10,REGSV1,,			:save registers

:	verify that enough time has passed since the last reset
:	interface msg from Spirit.
	LH	R2,MAYSND,,			:may we send msgs to ISIS ?
	JE	IS0				:if so - proceed normally
	L	R2,LSTRST,,
	L	R3,SLOWC,,
	SR	R3,R2				:how long since last reset ?
	CI	R3,MINRST
	JL	ISDONE				:if not enough - bye
	LIS	R2,0				:if enough - reset flag...
	STH	R2,MAYSND,,			:and proceed normally

IS0	LIS	R5,0				:point to 1st PST

ISOUT0	LH	R0,B2USED,,		:MAKE SURE THERE ARE ENOUGH SRBS
	CLHI	R0,NBUF2-BF2THR+1
	JLEFS	ISOPGO			:GO DO IT IF ENOUGH
	LHL	R0,DFNSRB,,		:ELSE INCREMENT COUNT OF..
	AIS	R0,1			:DEFERRED TASK BECAUSE OF NO SRBS
	STH	R0,DFNSRB,,
	J	ISDONE			:AND GO BACK TO EXEC LOOP
ISOPGO	LA	R4,ISOPQ			:ptr to ISIS output queue
	LHI	R6,OPQNXT			:offset to next PST ptr
	JAL	R13,NXTONQ			:get next PST addr
	JE	ISDONE				:if none there - leave
ISOUT1	LR	R11,R15				:put PST addr in R11
	LA	R4,OUTQUE,R11			:ptr to 1st buf in q
	LIS	R5,0				:get 1st entry in queue
	LIS	R6,0				:offset to ptr to next buf
	JAL	R13,NXTONQ			:get a buffered msg

        IF      DB.OPQ
        L       R4,PSTFLG,R11
        LR      R15,R15
        JEFS    NOBEVT
        LB      R3,BUFLEN,R15
NOBEVT  EQ      .
        EVT(ET.OPQ,TS.OPQ,R11,R15,R3,R4)
        EI

IS2	LR	R12,R15				:put msg buf addr in R12
	JAL	R13,CPORNG			:copy msg bufs to oring
	LR	R7,R7				:is the oring full ?
	JL	ISDONE				:if so - give up
:       buffer still could be on outque because of backpressure
	L	R12,OUTQUE,R11			:all bufs sent to ISIS ?
	JN	IS8				:if not - don't request more

        LH      R2,DIDBP,,                      :check bp flag
        JEFS    ISNOBP                          :no backpressure request
        LIS     R1,0
        STH     R1,DIDBP,,                      :clear bp reqeust flag
        LH      R2,DIDBUF,,                     :did we have a buffer?
        JE      ISREM                           :no, remove pst
        STH     R1,DIDBUF,,                     :else clear buffer flag

ISNOBP	LR	R15,R11				:copy PST addr
	LI	R3,WRITIP			:write in progress ?
	TBT	R3,PSTFLG,R15
        JEFS    ISREM
	L	R14,OPIOCB,R15			:get addr of IOCB
	JAL	R13,MOVSDT			:move data from Spirit to Mbs

:	remove this PST from the ISIS output queue
ISREM	LA	R14,ISOPQ			:point to top of queue
	LA	R10,IOPQND			:point to bottom of queue
	LR	R15,R11				:current PST
	LHI	R2,ONIOPQ			:clear the on output q flag
	RBT	R2,PSTFLG,R15
	LHI	R12,OPQNXT
	JAL	R13,DEQPST			:remove this PST from q
	JE	ISDONE				:if end of queue - bye
	LR	R5,R11				:copy PST addr
	J	ISOUT0				:else - go do another one

IS8	LR	R5,R11				:copy PST addr
	J	ISOUT0				:go do next PST

ISDONE	LM	R10,REGSV1,,			:restore registers
	JR	R13				:return to exec loop


:	S U B R O U T I N E   -   C P O R N G

:	Copy Port Bufers To ISIS  Output Ring

:	This subroutine, called by ISOUT (main loop), procedes
:	with the process of moving as many of the messages contained
:	in the buffers of this PST's ISIS Output Queue as possible.
:	The routine goes through the buffers, and checks if the
:	port's transmission limit permits the sending of a given
:	message.  If so - the MOVMSG subroutine is called, which
:	moves the message into the oring. If not, the port output
:	is halted for the time geing.  

:	Each buffer in the ISIS output queue contains one message.
:	Data messages can be sent in pieces, to accomadate
:	available resourses (transmission limits, and oring space).
:	Signal messages must be sent whole, with the exception of
:	login string messages, which are always divided up into
:	single byte messages (B3).

:	The calling sequence for this subroutine is:

:			JSR   R13,CPORNG

:	with inputs:  R11 = address of current PST
:		      R12 = address of first message buffer in this PST

BPSMSK	EQ	80000000^(-BPSREQ)		:BP status request bit mask
BPTMSK	EQ	80000000^(-BPTOIS)		:BP status bit mask


CPORNG	ST	R13,REGSV2,,			:save link register
	ST	R9,REGSV2+4,,

	LIS	R9,0				:init flag of BP request
	L	R4,PSTFLG,R11			:check if someone in ...
	LR	R5,R4				:Mbase requested to send ...
	NI	R4,BPSMSK			:a BP or release BP msg ...
	NI	R5,BPTMSK			:to ISIS.  If so send it
	SRL	R4,$A31-BPSREQ
	SRL	R5,$A31-BPTOIS
	CR	R4,R5
	JE	CP00				:if no request - proceed 
	LIS	R9,1				:BP request - set flag
        TS      DIDBP,,                         :set bp req. flag
	JAL	R13,SNDBP			:send msg to ISIS
	LR	R7,R7				:if oring full - leave
	JL	CPRET
CP00	LR	R12,R12				:anything else to send ?
	JNFS	CP000				:if so - go send it
	LR	R9,R9				:if not - was there a BP req ?
	JN	CPRET				:if so - exit normally
	RESET(R13,CCIOUT)			:if not - this PST shouldnt...
						:be on queue - so crash

CP000	LIS	R3,0				:init count of chars sent
        TS      DIDBUF,,                        :set buffer flag
CP01	LI	R5,BPFRIS			:point to backpressure flag
	TBT	R5,PSTFLG,R11			:is it set ?
	JE	NOTBP				:if not  - no BP

:	process an ISIS port in backpressure
	LB	R5,BUFMSG,R12			:get the msg type
	CLB	R5,SPZAP,,			:if zapper or gobbler...
	JEFS	CP03			 	: ...send the msg to ISIS
	CLB	R5,SPGOB,,
	JN	CPRET
CP03	LB	R7,BUFLEN,R12			:put msg length in R7
	AIS	R7,MSGHDR			:add msg hdr length
	JAL	R13,MOVMSG			:put msg in oring
	J	NXTBUF				:proceed

:	the ISIS port is not backpressured, so try to send the message
NOTBP	LB	R5,BUFMSG,R12			:get msg type
	JN	SIGMSG				:if a signal msg - jump

:	process a data msg - if possible
	LB	R5,BUFTYP,R12			:get the buffer type
	CHI	R5,BUFTP1			:buffer 1 ?
	JNFS	CP10				:if not - jump
	LB	R5,BUFLEN,R12			:buf 1 - get msg length
	LB	R7,BUFCEI,R12			:subtract offset into buf
	SR	R5,R7
	JFS	CP11
CP10	LB	R5,BUFLEN,R12			:get buf 3 msg length
CP11	AR	R5,R3				:#bytes sent so far + msg len
	CLH	R5,XMTLIM,R11			:xmtlim exceeded ?
	JGFS	CP13				:if so - jump
	SR	R5,R3				:send all bytes in buffer
	AIS	R5,MSGHDR			:add bytes for port & msg type
	JFS	CP15
CP13	LH	R5,XMTLIM,R11			:get xmt limit
	AIS	R5,MSGHDR			:addr hdr length
	SR	R5,R3				:decr by #bytes already sent
	CHI	R5,MSGHDR+1			:room for min msg ?
	JL	CPRET				:if not - bye
CP15	LR	R7,R5				:# bytes to send to ISIS in R7
	JAL	R13,MOVMSG			:go move data to oring
	J	NXTBUF

:	process a signal message - if possible
SIGMSG	LB	R4,BUFMSG,R12			:login msg ?
	CLB	R4,SPLOGS,,
	JE	CP27				:if so - go process it
	LB	R7,BUFLEN,R12			:get msg length
	AIS	R7,MSGHDR			:inc by msg header length
	JAL	R13,MOVMSG			:go send the msg
	J	NXTBUF
CP27	LIS	R7,0
	LB	R5,BUFTYP,R12			:get the buf type
	CHI	R5,BUFTP1			:type 1 ?
	JNFS	CP29				:if not - jump
	LA	R5,B1DATA,R12			:point to start of data buf
	LB	R7,BUFCEI,R12			:get cei offset
	JNFS	CP30
	AIS	R7,1				:if start of msg, skip char
	JFS	CP30
CP29	LA	R5,B3DATA,R12			:point to buf 3 data area
CP30	LB	R4,0,R7,R5			:get a login char
	LIS	R7,LOGLEN			:msg length in R7
	JAL	R13,MOVMSG			:go send it
	LR	R7,R7				:is the oring full ?
	JL	CPRET				:if so - don't send more
	LB	R5,BUFLEN,R12			:get msg length
	CLB	R5,BUFCEI,R12			:has whole buf been sent ?
	JG	CP27				:if not - send another byte

:	The buffer has been processed (hopefully).  See what to do next.
NXTBUF	LR	R7,R7				:is the oring full ?
	JL	CPRET				:if so - jump
	LB	R5,MORDAT,,			:was the buffer emptied ?
	JN	CPRET				:if not - bye
	LR	R12,R15				:another msg to process ?
	JN	CP01				:if msg there - go process it

CPRET	L	R13,REGSV2,,			:restore link register
	L	R9,REGSV2+4,,
	JR	R13


:	S U B R O U T I N E :   M O V M S G

:	Move a Message To ORING

:	This subroutine moves a designated message from a buffer in
:	the ISIS Output Queue to the ISIS Oring.  Before it
:	executes the transfer, it verifies that the Oring has room
:	for the message.

:	This subroutine is called by CPORNG, and the calling
:	sequence is:

:			JAL   R13,MOVMSG

:	Inputs to the routine are:
:			R3 = number of chars sent to this port so far
:			R4 = login character, if the msg is a login string
:			R7 = number of bytes to put in the Oring 
:				(includes 2 byte port number & 1 byte msg type)
:			R11 = current PST address
:			R12 = address of the message buffer


:	Upon return from this subroutine, if the Oring is full, R7 is
:	set to -1.



MOVMSG	STM	R8,REGSV3,,			:store link register
	LR	R8,R11				:copy the PST addr
	STB	R4,LOGCHR,,			:save the login char - if any
	LIS	R4,0
	STB	R4,MORDAT,,			:reset the flag
	JAL	R4,SPACE			:get #bytes avl in oring (R0)
	LR	R5,R7				:get length of Spirit msg
	CR	R0,R5				:room in oring for msg ?
	JGE	MOV3				:if so - go process the move

:	Oring lacks room for the msg.  Let's see what we can do.
	LB	R5,BUFMSG,R12			:is this a data msg?
	CLB	R5,SPDATA,,
	JN	BYE				:if not - try next time
	LR	R6,R0				:it's data - try to send some
	JGFS	MOV1				:if there's room - go send
	LCS	R7,1				:oring is full - give up
	J	BYE
MOV1	SIS	R6,MSGHDR			:remove space for port & type
	LB	R5,BUFCEI,R12			:point cei past what is sent
	AR	R5,R6
	STB	R5,BUFCEI,R12
	LIS	R4,1				:set flag that buffer...
	STB	R4,MORDAT,,			: ...isn't being emptied now
	J	MOV4
MOV3	LR	R0,R5				:put msg length in R0
	SIS	R0,MSGHDR
MOV4	LH	R1,PORT,R11			:ISIS port nbr in R1
	LR	R6,R0


:	change the Spirit msg type code to the ISIS format & store
:	it in R2
	LB	R4,BUFMSG,R12			:get spirit msg type
	CLB	R4,SPDATA,,			:is it a data msg ?
	JN	MOV5				:if not 0 (data) - jump
	LR	R1,R1				:data msg - which port ?
	JE	DUMPIT				:if type 0 msg on port 0 - ng
	LR	R2,R6				:data msg type = #chars
	JLE	DUMPIT				:if no chars - dump msg
	J	MOV8				:go set up msg send
MOV5	LR	R1,R1				:signal msg - which port ?
	JEFS	MOV6
	LA	R2,TOISPN,,			:non zero port
	JFS	MOV7
MOV6	LA	R2,TOISP0,,			:port zero
MOV7	LB	R2,0,R4,R2			:change to ISIS msg format
	JE	DUMPIT				:if msg type 0 - ng
MOV8	JAL	R4,SLOR				:set up msg storage in oring

:	move msg characters to the oring
	CHI	R2,NLOGCH			:login msg being sent ?
	JN	MOV9				:if not - jump
	LB	R0,LOGCHR,,			:if so - get the char
	JAL	R4,PUTCH			:put the char in the oring
	LB	R4,BUFCEI,R12			:inc the cei counter
	JNFS	MOV82
	AIS	R4,2				:if 1st char sent - inc by 2
	JFS	MOV84
MOV82	AIS	R4,1
MOV84	STB	R4,BUFCEI,R12
	J	ENDIT				:go close up

:	char by char, put the msg into the oring
MOV9	LR	R5,R12				:copy msg buffer addr
	AR	R3,R6				:inc cntr by #char from ring
	LB	R1,BUFTYP,R5			:check the msg type
	CHI	R1,1				:get ptr to this type's ...
	JNFS	MOV92				:data area
	LHI	R1,B1DATA
	LB	R2,BUFCEI,R12			:add cei offset
	AR	R1,R2
	JFS	MOV11
MOV92	LHI	R1,B3DATA
MOV11	LB	R0,0,R1,R5
	JAL	R4,PUTCH			:put char in oring
	SIS	R6,1				:decr move counter
	JLEFS	ENDIT				:if counter = 0, we're done
	AIS	R5,1				:else - point to next send char
	JBS	MOV11				:go send it

ENDIT	JAL	R4,ELOR				:finish off the msg

:	finish up msg processing
	LB	R5,MORDAT,,			:was the buffer emptied ?
	JN	BYE				:if not - bye
DUMPIT	LA	R14,OUTQUE,R11
	LIS	R15,0
	JAL	R13,DNDSNG			:remove the buf from queue
	LR	R2,R15
BYE	LM	R8,REGSV3,,			:restore the regs
	LR	R15,R2				:addr of next msg in R15
	JR	R13


:	S U B R O U T I N E   -   S N D B P

:	SEND A BACKPRESSURE MESSAGE TO ISIS

:	This subroutine is called by CPORNG when a discrepency between
:	the BPTOIS (backpressure msg sent to ISIS)  and BPSREQ 
:	(backpressure msg request) flag bits exists, indicating that
:	some module in Mbase wants a backpressure or release backpressure
:	message sent to ISIS.  Depending on the request, the subroutine
:	puts either a backpressure or release backpressure message on
:	the ORING.

:	The calling sequence for this subroutine is:

:			JAL   R13,SNDBP

:	with inputs:  R11 = address of current PST.

:	If the message cant be sent because the ORING is full,
:	R7 is returned with a -1 value.


SNDBP	STM	R14,SBPSAV,,			:save regs

	JAL	R4,SPACE			:room in oring for msg ?
	CHI	R0,BPLEN
	JGEFS	SBP02				:if so - proceed
	LCS	R7,1				:if not - bye
	J	SBPRET
SBP02	LHI	R3,BPTOIS
	LHI	R5,BPSREQ			:which msg was requested ?
	TBT	R5,PSTFLG,R11
	JEFS	SBP04
	LHI	R2,NOSMSG			:backpressure msg
	SBT	R3,PSTFLG,R11			:set BPTOIS flag
	JFS	SBP05
SBP04	LHI	R2,SNDMSG			:release backpressure msg
	RBT	R3,PSTFLG,R11			:reset BPTOIS flag
SBP05	LIS	R0,1
	LB	R1,PORT,R11
	JAL	R4,SLOR				:send the msg
	JAL	R4,ELOR
SBPRET	LM	R14,SBPSAV,,
	JR	R13


:	F L A G S   &   S T O R A G E    A R E A S


	SEG	A.DATA

REGSV1	WS	6				:register save area
REGSV2	WS	2
REGSV3	WS	8
SBPSAV	WS	2

	GL	MORDAT
MORDAT	BS	1				:more data in buf after move
						:1 = yes, 0 = no
LOGCHR	BS	1				:place to store login char
        BND     2
DIDBP   HS      1
DIDBUF  HS      1

 








        SUBTTL  Mbase Iring Teardown Task

        GL      FWRDCS,FWRDAT

:       ***** GPST *****
:       MACRO TO GET PST USING PORT NUMBER AS INDEX INTO PSTATB

GPST  MACRO(PORT,PST)
[
        SLLS    PORT,2          :MAKE PORT NMBR INTO WOR D IDX
        L       PST,PSTATB,PORT,
        SRLS    PORT,2
]

:       ATCPST -- SUBROUTINE TO GET AND INIT'IZ PST AND PUT ON ATCHDQ
:       USED ONLY BY IRING TEARDOWN TASK
:       LINK ON R13
:       USES R6, R7
:       R15 = PST

        SEG     A.DATA
ATCPSV  WS      1
IRNGSV  WS      1
MCSTSV  WS      1
DQDASV  WS      1
IMSGSV  WS      4
NOR0SV  WS      10


        SEG     A.CODE
ATCPST  ST      R13,ATCPSV,,
        GPST(R11,R15)
        LR      R8,R15                  :COPY PST
        JAL     R13,IZPST
        LHI     R1,XMLDFL               :XMITLIM DEFAULT
        JAL     R13,UPDGBC              :UPDATE GLOBAL BKPRSR CRITERIA
        L       R6,ATCHDQ,,             :ANYTHING ON ATTACHED QUEUE?
        JE      ATCPS0                  :JUMP IF NOT
        L       R7,ATCQND,,             :ELSE GET LAST PST ON ATCHDQ
        JE      ATCPS1                  :THERE'S ONLY 1 PST ON QUE NOW
        ST      R15,ATCHNX,R7,          :PREVIOUS E-O-Q LINKS AHEAD
        ST      R7,ATCPRV,R15,          :LINK BACK TO PREVIOUS E-O-Q
        ST      R15,ATCQND,,            :PST ADDR IN END-OF-QUE PTR
        RETURN(ATCPSV)

ATCPS0  ST      R15,ATCHDQ,,            :IT'S 1ST PST ON ATCHDQ
        RETURN(ATCPSV)

ATCPS1  ST      R15,ATCQND,,            :SAVE IN END-OF-QUE PTR
        ST      R6,ATCPRV,R15,          :LINK BACK
        ST      R15,ATCHNX,R6,          :LINK AHEAD
        RETURN(ATCPSV)

:       NO MORE INPUT -- RESTORE R13 AND JR TO EXEC LOOP

NOMINP  L       R13,IRNGSV,,            :RESTORE LINK REG.
        JR      R13

:       JUMP HERE TO CHECK FOR MORE INPUT

GETINP  EQ      .
        CHKSRB(IRNGSV,3)
        JAL     R4,LOOK                 :CHECK IRING
        J       NOMINP                  :NO MORE INPUT
        JN      IRNGT0                  :NOT PORT 0 MSG
        J       PORT0M


:	BEGIN IRING TEAR-DOWN TASK

IRNGTD  ST      R13,IRNGSV,,            :SAVE LINK REG
        CHKSRB(IRNGSV,3)
      	JAL	R4,LOOK			:ANYTHING FROM ISIS?
        J       NOMINP
	JN	IRNGT0			:IT'S NOT PORT 0

PORT0M  EQ      .
        LR      R11,1                   :COPY PORT
        LR      R12,R2                  :COPY MSG TYPE

:       INTRA-NODE MSG (PORT 0)

        CLH     R12,MAXP0,,             :CHECK IF > MAX PORT 0 MSG
        JG      ILLP0M                  :CRASH IF LLEGAL PORT 0 MSG
        LHL     R4,LP0LST,,             :LENGTH LIST ADDR
        LB      R3,0F0000,R12,R4        :GET MSG LENGTH FOR FLUSH
        JE	CHKIFE			:CHECK IF MSG 0E
        GPST(R11,R15)
        LB      R12,TOSPP0,R12,         :GET SPIRIT EQUIVALENT
        JE      NORECK                  :IF 0, NOT RECOGNIZED
        LA      R13,GETINP              :SET-UP LINK REG FOR MCSTOB
	ST	R13,MCSTSV,,
        J       MCSTB0                  :MOVE CIRC. SIG. TO BUF

CHKIFE  CLHI    R12,0E
        JN      ILLP0M
	GPST(R11,R15)
	JAL	R4,GETCH
	LR	R8,R15
	JAL	R13,GETBF1
	LIS	R3,3
	LIS	R5,0

GET0E0	JAL	R4,GETCH
	STB	R0,B1DATA,R6,R5
	AIS	R5,1
	SIS	R3,1
	JNBS	GET0E0
	LR	R3,R0			:LENGHT BYT OF TEXT STRING
	AIS	R0,3
	STB	R0,BUFLEN,R6,
	LB	R12,TOSPP0,R12
	JE	NOREC0
	STB	R12,BUFMSG,R6,
	LR	R3,R3			:CASE WHERE LENGTH BYT IS 0
	JE	GET0E2

GET0E1	JAL	R4,GETCH
	STB	R0,B1DATA,R6,R5
	AIS	R5,1
	SIS	R3,1
	JNBS	GET0E1

GET0E2	JAL	R4,ELIR
	JAL	R13,PUTINQ
	JAL	R13,FWRDCS
	J	GETINP

ILLP0M  RESET(R4,CCPRT0)

IRNGT0  EQ      .
      	CLHI	R1,NPORT		:PORT NMBR CANNOT BE > NPORT
	JLEFS	IRNGT1			:JUMP IF OK
        RESET(R4,CCPRTN)                  

IRNGT1  EQ      .
        LR      R11,R1                  :COPY PORT
        LR      R12,R2                  :COPY MSG
      	LR	R12,R12			:IS IT A NEEDLE? (MSG = 0)
        JN      IRDATA                  :JUMP IF NOT

:       NEEDLE PROCESSING
:       CRASH IF CIRCUIT ALREADY CONNECTED
:       PASS NEEDLE TO SPIRIT VIA IOCB 3
:       SET APORTS,APORTM -- PUT PORT'S PST ON ATCHDQ

        SBT     R11,APORTM,,            :MBASE'S ACTIVE PORT BIT ARRAY
        JN      ILLNDL                  :THIS PORT ALREADY ACTIVE, CRASH
        SBT     R11,APORTS,,            :SPIRIT'S ACTIVE PORT BIT ARRAY
        JAL     R13,ATCPST              :GET, INIT'Z, AND ENQUE PST
        LA      R8,PSTB0,,              :SBUS BUF FOR NEEDLE ON PORT 0
	JAL	R13,GETBF1		:GET AN SBUS BUFFER
	LIS	R0,1			:NEEDLE IS 'FORMAT 1'
	STB	R0,B1DATA,R6,		:FORMAT TYPE HERE
	LIS	R0,0			:FORMAT 1 CALLS FOR 2 ZERO...
	STB	R0,B1DATA+1,R6,		:BYTES AFTER FORMAT TYPE
	STB	R0,B1DATA+2,R6,		:BYTES AFTER FORMAT TYPE
	STB	R11,B1DATA+3,R6,        :PUT PORT # HERE
        STB     R11,LSTNDL,,            :SAVE IN LAST NEEDLE BUF
	JAL	R4,GETH			:GET LENGTH OF NEEDLE
	STB	R0,B1DATA+4,R6,		:STORE LENGTH BYTE HERE
        STB     R0,LSTNDL+1,,           :SAVE IN 'LAST NEEDLE' BUF
	LR	R3,R0			:MSG LENGTH MUST BE IN SRB
	AIS	R0,5			:ACCOUNT FOR FIRST 5 BYTES
	STB	R0,BUFLEN,R6,		:LENGTH OF 'ATTACH CHNL' MSG
        LIS     R12,0                   :0 = ATTACH CHN MSG 
        STB     R12,BUFMSG,R6,          :PUT MSG TYPE IN BUFFER
	LIS	R5,0			:NOW PUT NEEDLE DATA IN BUFR

GETNDL	JAL	R4,GETCH		:GET A BYTE OF NEEDLE
	STB	R0,B1DATA+5,R5,R6	:PUT IN DATA BUFFER
        STB     R0,LSTNDL+2,R5,         :PUT IN LAST NEEDLE BUFFER
	AIS	R5,1			:INCREMENT BUFFER IDX
	SIS	R3,1			:DECREMENT NEEDLE BYT COUNT
	JGBS	GETNDL			:GET NEXT BYTE
	JAL	R4,ELIR			:UPDATE IRING CEI
        LA      R15,PSTB0,,             :GOES TO SPIRIT VIA PORT 0
        JAL     R13,PUTINQ              :PUT ON INPUT QUEUE
        JAL     R13,FWRDCS              :FORWARD IF READ CMD UP
        J       GETINP                  :CHECK FOR MORE INPUT

IRDAT4  NI      R6,7FFFFFFF
        LR      R7,R6
        J       IRDAT5

IRDATA  CLHI    R12,FIRST               :DATA MSG?
        JGE     IRCSIG                  :NO--A 'CIRCUIT SIGNAL'

:       DATA MSG HANDLING

        TBT     R11,APORTM,,            :IS THIS PORT ATTACHED?
        JE      EATDAT                  :NO, JUST FLUSH THE DATA MSG
        JAL     R4,GETCH                :READ PAST MSG COUNT
        GPST(R11,R15)
      	L	R6,INQUE,R15,		:GET START OF INPUT QUEUE
	JE  	IRDAT1			:IT WAS EMPTY--GET A BUF

IRDAT2  LR      R7,R6                   :GET A COPY OF BUF ADDR
        JL      IRDAT4                  :IF ZAP ACK BUF, JUMP

IRDAT5  EQ      .
      	L	R6,0,R7,		:GET NEXT BUF IN QUEUE
	JNBS	IRDAT2			:KEEP GOING UNTIL AT END
        LR      R6,R7                   :PUT LAST BUF ADDR IN R6
        LB      R3,BUFMSG,R6,           :THIS BUF MUST HAVE DATA
        CLB     R3,SPDATA,,             :IS IT SPIRIT-TYPE DATA MSG?
        JNFS    IRDAT1                  :NO--GO GET A NEW BUFFER
	LB	R3,BFNFMI,R6,		:GET NFMI OF BUFFER
	CLHI	R3,BUF1MX		:IS THERE ROOM IN BUFFER?
        JEFS    IRDAT1                  :NO, GET A NEW BUF
        JAL     R13,STUFFB              :PUT CHARS IN THIS BUF
        JFS     IRDAT3                  

IRDAT1  LR      R8,R15                  :PST IN R8 FOR GETBF1
        JAL     R13,GETBF1              :GET A BUFFER
        LB      R1,SPDATA,,             :GET SPIRIT DATA MSG
        STB     R1,BUFMSG,R6,           :PUT IN BUF
        LIS     R3,0                    :INIT NFMI
        JAL     R13,STUFFB              :STUFF THE BUFF
        JAL     R13,PUTINQ              :PUT ON INPUT QUEUE

IRDAT3  LR      R12,R12                 :ANY CHARS LEFT IN MSG?
        JNBS    IRDAT1                  :YES--GET ANOTHER BUF
        JAL     R4,ELIR
        JAL     R13,FWRDAT              :FORWARD DATA MSG
        J       GETINP
        
IRCSIG  CLHI    R12,PSNMSG              :PSEUDO-NEEDLE?
        JE      PSNRCD                  :JUMP IF SO
        TBT     R11,APORTM,,            :ATTACHED PORT?
        JE      CHIF9F                  :NO, CHECK IF IT'S A ZAP
        CLH     R12,MAXMSG,,            :A LEGAL MSG?
        JG      ILLCSG                  :NO, CRASH
        GPST(R11,R15)                   :GET PST
	CLHI	R12,MAXTYP		:MSG TYP IN OUR TABLE?
	JGE	NORECK			:IF NOT, TRACE & FLUSH
	LHL	R3,MSGFAN-FIRST*2,R12,R12	:GET ADDR OF MSG HANDLER
:       (MCSTOB IS A ROUTINE W/ R13 AS LINK REG)
        LA      R13,GETINP              :SET-UP LINK REG. FOR MCSTOB
	J	SEG1,R3,			:AND GO DO IT

:	CIRCUIT SIGNAL MSG TYPE FAN-OUT TABLE

MSGFAN	HC	INPZAP-SEG1		:9E--DETACH
	HC	INPZAP-SEG1		:9F--ZAP
	HC	INABKP-SEG1		:A0--APPLY BACKPRESSURE
	HC	INRBKP-SEG1		:A1--RELEASE BACKPRESSURE
	HC	INGOBL-SEG1		:A2--FLUSH OUTPUT (GOBBLER)
	HC	MCSTOB-SEG1		:A3--FLUSH INPUT
	HC	MCSTOB-SEG1		:A4--BLACK BALL
	HC	MCSTOB-SEG1		:A5--GREY BALL
	HC	MCSTOB-SEG1		:A6--ENTER DEFFERED ECHO MODE
	HC	MCSTOB-SEG1		:A7--LEAVE    "      "     "
	HC	MCSTOB-SEG1		:A8--ENTER TRANSPARENCY
	HC	MCSTOB-SEG1		:A9--LEAVE   "
	HC	MCSTOB-SEG1		:AA--GREEN BALL
	HC	MCSTOB-SEG1		:AB--RED BALL
	HC	MCSTOB-SEG1		:AC--YELLOW BALL
	HC	MCSTOB-SEG1		:AD--ORANGE BALL
	HC	MCSTOB-SEG1		:AE--'BREAK' BEGIN
	HC	MCSTOB-SEG1		:AF--HANG UP
	HC	MCSTOB-SEG1		:B0--QUERY TERM.PARM.
	HC	MCSTOB-SEG1		:B1--SET TERM. PARM.
	HC	PSNRCD-SEG1		:B2--PSEUDO NDL
	HC	MCSTOB-SEG1		:B3--NORMAL LOGON CHAR
	HC	MCSTOB-SEG1		:B4--NORMAL LOGON STATUS
	HC	MCSTOB-SEG1		:B5--LOGON FAILURE
	HC	MCSTOB-SEG1		:B6--SUCCESSFUL LOGON
	HC	MCSTOB-SEG1		:B7--ADDENDUM TO ACC'T
	HC	MCSTOB-SEG1		:B8--SUPER HANG-UP
	HC	INXLIM-SEG1		:B9--SET XMIT LIMIT
	HC	MCSTOB-SEG1		:BA--'BREAK' END
	HC	INPZAP-SEG1		:BB--ZAP ACK
	HC	MCSTOB-SEG1		:BC--ENTER ALT DEV MODE
	HC	MCSTOB-SEG1		:BD--LEAVE  "    "    "
	HC	INPZAP-SEG1		:BE--ZAP W/ REASON
	HC	MCSTOB-SEG1		:BF--SIIX
	HC	MCSTOB-SEG1		:C0--TIIX
	HC	MCSTOB-SEG1		:C1
MAXTYP	EQ	(.-MSGFAN)/2+FIRST	:MAX TYPE IN TABLE

:	MOVE CIRCUIT SIGNAL TO BUFFER

MCSTOB  ST      R13,MCSTSV,,
        LB      R3,LENGTH,R12,          :GET MSG LENGTH
        LB      R12,TOSPPN,R12,         :GET SPIRIT EQUIVALENT
	JE	NORECK			:IF 0, NOT RECOGNIZED

MCSTB0	JAL	R4,GETCH		:READ PAST MSG TYPE
	SIS	R3,1			:DECREMNT MSG LENGTH
        JN      MCSTB1                  :JUMP IF PARAMTERS
        LR      R8,R15
        JAL     R13,GETBF3              :GET TYPE 3 BUF
        STB     R12,BUFMSG,R6,          :PUT MSG BYTE IN BUF
        JAL     R4,ELIR
        JAL     R13,PUTINQ              :PUT BUF ON INPUT QUEUE
        JAL     R13,FWRDCS              :FORWARD IF READ CMD UP
        RETURN(MCSTSV)

MCSTB1	CLHI	R3,2			:MORE THAN 2 PARAMS?
	JG	MCSTB2			:JUMP IF SO
        LR      R8,R15
      	JAL	R13,GETBF3		:GET TYPE 3 BUFFER
	STB	R12,BUFMSG,R6,		:PUT MSG BYTE IN BUF
        STB     R3,BUFLEN,R6,           :NUMBER OF PARAMS HERE
        LIS     R5,0

MCSTB4	JAL	R4,GETCH		:GET 1ST PARAM
	STB	R0,B3DATA,R6,R5         :SAVE PARAMS IN BUFFER
        AIS     R5,1
	SIS	R3,1			:DECREMENT COUNT
        JNBS    MCSTB4                  :GET NEXT PARAM BYT
        JAL     R4,ELIR
        JAL     R13,PUTINQ              :PUT BUF ON INPUT QUEUE
        JAL     R13,FWRDCS              :FORWARD IF READ CMD UP
        RETURN(MCSTSV)

MCSTB2  LR      R8,R15                  :PST IN R8 FOR GETBF1
      	JAL	R13,GETBF1		:GET SBUS BUFFER
        STB     R12,BUFMSG,R6,          :SAVE HERE IN BUF
	LIS	R5,0			:INIT IDX INTO BUF

MCSTB3	JAL	R4,GETCH		:GET PARAM BYTE
	STB	R0,B1DATA,R6,R5		:PUT IN BUF
	AIS	R5,1
	CR	R5,R3			:ANY MORE?
	JNBS	MCSTB3
	STB	R3,BUFLEN,R6,		:COUNT GOES IN SRB
        JAL     R4,ELIR
        JAL     R13,PUTINQ              :PUT ON INPUT QUEUE
        JAL     R13,FWRDCS              :FORWARD IF READ CMD UP
        RETURN(MCSTSV)

EATDAT  LHI     R0,1,R12                :MAKE BYTE COUNT TO FLUSH
        JAL     R4,FLUSH                :FLUSH MSG
        RETURN(MCSTSV)

CHIF9F  CLHI    R12,ZAPMSG              :IS THIS A ZAP?
        JEFS    GOTZAP                  :YES, SEND A ZAP BACK
        CLHI    R12,DETMSG              :A DETACH?
        JNFS    EATCSG                  :NO--EAT THE MSG

GOTZAP  GPST(R11,R15)
        JAL     R13,ZAPBAK              :PUT ZAP IN ORING

EATCSG  LB      R0,LENGTH,R12,          :GET MSG LENGTH
        JAL     R4,FLUSH                :FLUSH
        J       GETINP

:       PSEUDO-NEEDLE HANDLING
:       CRASH IF CIRCUIT ALREADY CONNECTED
:       PASS TO SPIRIT VIA IOCB 3
:       SET APORTS, APORTM -- INIT PST AND PUT ON ATCHDQ

PSNRCD  SBT     R11,APORTM,,            :MBASE'S ACTIVE PORT BIT ARRAY
        JN      ILLPSN                  :THIS PORT ALREADY ACTIVE, CRASH
        SBT     R11,APORTS,,            :SPIRIT'S ACTIVE PORT BIT ARRAY
        JAL     R13,ATCPST              :GET, INIT'Z, AND ENQUE PST
        LA      R8,PSTB0,,              :SBUF BUF FOR P/N ON PORT 0 
        JAL     R13,GETBF1              :GET SBUS BUFFER
        LIS     R0,2                    :PSEUDO-NEEDLE = 'FORMAT 2'...
        STB     R0,B1DATA,R6,           :..OF ATTACH CHNL MSG
        STB     R11,B1DATA+4,R6,        :PORT NMBR GOES HERE
        STB     R11,LSTPSN,,            :PUT IN LAST P/N BUFFER
        JAL     R4,GETCH                :MOVE PAST MSG TYP
        LIS     R5,1

GETPND  JAL     R4,GETCH                :GET NEXT 3 BYTES OF P/N
        STB     R0,B1DATA,R6,R5         :PUT P/N IN DATA BUFFER
        STB     R0,LSTPSN,R5,           :PUT IN LAST P/N BUFFER
        AIS     R5,1
        CLHI    R5,4                    :GOT ALL OF P/N MSG?
        JNBS    GETPND
        JAL     R4,ELIR
        LIS     R5,5                    :LEN OF 'FORMAT 2 ' ATTCH CHN
        STB     R5,BUFLEN,R6,           :PUT HERE IN SRB 
        LIS     R12,0                   :R12 <-- ATTCH CHNL MSG TYP
        STB     R12,BUFMSG,R6,          :SAVE MSG TYP IN BUF
        LA      R15,PSTB0,,             :SEND TO SPIRIT VIA PORT 0
        JAL     R13,PUTINQ              :PUT ON INPUT QUEUE
        JAL     R13,FWRDCS              :FORWARD IF READ CMD UP
        J       GETINP

:	HANDLE INPUT ZAP

INPZAP  ST      R13,MCSTSV,,
      	LHI	R1,ZAPFIS		:GET ZAP-FROM-ISIS FLG
	SBT	R1,PSTFLG,R15,		:SET IN PST FLAGS AREA
        LHI     R1,BPFRIS               :CLEAR BP FORM ISIS FLAG
        RBT     R1,PSTFLG,R15           :(MAY OR MAY NOT BE SET)
        LHI     R1,ABPINQ               :CLEAR APPLY BP ON INQUE FLAG
        RBT     R1,PSTFLG,R15           :(MAY OR MAY NOT BE SET)
	LHI	R1,ZAPFSP		:GET ZAP-FROM-SPIRIT FLG
	TBT	R1,PSTFLG,R15,		:WAS IT SET?
	JE	INPZP0			:NO--PASS ZAP TO SPIRIT
	LHI	R1,ZAPTIS		:GET ZAP-TO-ISIS FLAG
	TBT	R1,PSTFLG,R15,		:ZAP SET TO ISIS YET?
        JNFS    INPZP1                  :JUMP IF SO
        RBT     R11,APORTM              :CLEAR ACTIVE PORT BIT
        JAL     R13,DQDAIB              :MAKE SURE NOTHING HAS STACKED UP
        J       EATCSG                  :FLUSH THE ZAP

INPZP1	JAL	R13,DQDAIB              :MAKE SURE NOTHING HAS STACKED UP
        JAL     R13,CMPLZP              :COMPLETE PORT ZAP
	J	EATCSG			:FLUSH ZAP (ACK)

INPZP0	JAL	R13,DQDAIB		:DEQUE AND DEALLOCATE BUFS
        LHI     R1,ZAPINQ
        SBT     R1,PSTFLG,R15           :SET BUFFERED-ZAP-ON-INQUE FLAG
	JAL	R13,MCSTOB		:BUFFER THE ZAP
	J	GETINP

:	APPLY BACKPRESSURE

INABKP	LHI	R1,BPFRIS
	SBT	R1,PSTFLG,R15		:SET BKP FROM ISIS FLAG
	LHI	R1,BPTOSP		:IS SPIRIT ALREADY BACKPRESSURED?
	TBT	R1,PSTFLG,R15		
	JEFS INABK0			:JUMP IF NOT BKPRESSURED
        LHI     R1,ABPINQ               :IS THERE AN A0 ALREADY ON INQUE
        TBT     R1,PSTFLG,R15
        JN      APBKCR                  :CRASH IF SO
	JAL	R13,RMARBP		:REMOVE ALL A0 & A1 FROM INQUE
	J	EATCSG			:AND FLUSH THE SET BP MSG

INABK0  LHI     R1,ABPINQ               :APPLY-BAKPR-ON-INQUE FLAG
        TBT     R1,PSTFLG,R15		:IF AN A0 IS ALREADY ON INQUE...
	JEFS	INABK1			:DISCARD THIS A0, ELSE JUMP
	J	EATCSG			:FLUSH THIS A0

INABK1	SBT	R1,PSTFLG,R15		:SET ABPINQ
	JAL	R13,MCSTOB		:BUFFER THE MSG AND ENQUE IT
	J	GETINP

APBKCR  RESET(R13,CCAPBK)

:	RELEASE BACKPRESSURE

INRBKP	LHI	R1,BPFRIS		:GET BKPR-FROM-ISIS FLAG
	RBT	R1,PSTFLG,R15,		:RESET IN PST FLAGS ARRAY
        LHI     R1,ABPINQ               :IS AN APPLY BKP ON INQUE?
        TBT     R1,PSTFLG,R15           :IF SO, MAY NOT NEED TO QUE THIS MSG
        JEFS    INRBK0                  :JUMP IF NOT
	LHI	R1,BPTOSP		:IS SPRITI ACTUALLLY BACKPRESURED?
	TBT	R1,PSTFLG,R15		:IF SO, WE NEED TO QUEUE THIS MSG
	JN  	RBKPCR			:CRASH IF THIS CONDITIONS HAPPENS
	LHI	R1,ABPINQ		:THE SET BKP ON QUEUE, SO...
        RBT     R1,PSTFLG,R15           :CLEAR THE BIT AND...
        JAL     R13,RMARBP              :REMOVE BOTH A0 AND A1 MSG FROM QUE
        J       EATCSG                  :FLUSH THE RELEASE BKP MSG

INRBK0	LHI	R1,BPTOSP		:IS SPRIIT BACKPRESSURED
	TBT	R1,PSTFLG,R15		:IF NOT, DON'T BOTHER WITH THIS
	JNFS	INRBK1			:ELSE QUE UP THE RELEASE
	J	EATCSG			:FLUSH THE RELEASE BKP

INRBK1	JAL	R13,RMARBP		:FIRST REMOVE APLY & RELEASE BP MSGS
	JAL	R13,MCSTOB		:BUFFER THE MSG
	J	GETINP

RBKPCR  RESET(R13,CCRBKP)

:	GOBBLER

INGOBL	JAL	R13,DQDAIB		:DEQUE AND DEALLOCATE BUFFERS
	JAL	R13,MCSTOB		:BUFFER THE MSG
	J	GETINP

:	SET TRANSMIT LIMIT

INXLIM	JAL	R13,MCSTOB		:MOVE THE MSG TO BUFFER
        LIS     R1,0                    :CANCEL DEFAULT (OR LAST)...
        JAL     R13,UPDGBC              :..GLOBAL BACKPRSSR CRITERIA
:	R6 = BUFFER ADDRESS--LOOK THERE FOR XMIT LIM BYTE
	LB	R1,B3DATA,R6,		:GET MSG PARAM BYTE
	STB	R1,XMTLIM+1,R15,	:IT'S XMIT LIMIT--SAVE IN PST
        JAL     R13,UPDGBC              :UPDATE GLOBAL BKP CRITERIA
	J	GETINP

:	DEQUEUE AND DEALLOCATE INPUT BUFFERS

DQDAIB	L	R6,INQUE,R15 		:GET FIRST BUF
	JER	R13			:THERE ISN'T ONE
	ST 	R13,DQDASV,,		:SAVE LINK REG
        LB      R1,BUFTYP,R6            :GET BUF TYPE
        CLHI    R1,BTYPE3               :IF TYPE 3, DUMP IT 
        JE      DQDAB0
        LB      R1,BSPLIT,R6            :GET 'BUFFER SPLIT' FLAG
        JEFS    DQDAB0                  :IF 0, GET RID OF THIS BUF
        L       R7,BUFNXT,R6            :ELSE KEEP ON QUE--GET NEXT
        JER     R13                     :LEAVE IF NO OTHER BUF
        LIS     R1,0                    :AND 0 OUT...
        ST      R1,BUFNXT,R6            :IT'S NEXT FIELD
        LR      R6,R7                   :NEXT BUF IN R6
        JFS     DQDAB1                  :GET RID OF THE REST

DQDAB0  LIS     R1,0                    :0 OUT INPUT QUEUE PTR...
        ST      R1,INQUE,R15            :...FOR PST

DQDAB1	LB	R5,BUFTYP,R6 		:GET BUF TYP
	L 	R7,BUFNXT,R6 		:GET NEXT IN QUEUE
        LR      R8,R15                  :PST IN R8 FOR RETBUF
	JAL	R13,RETBUF		:RETURN THIS BUF
	LR	R6,R7			:NEXT BUF ADDR IN R6
	JNBS	DQDAB1			:RETURN IT (IF NOT EOQ)
	RETURN(DQDASV)

ILLNDL  RESET(R4,CCINDL)

ILLPSN  RESET(R4,CCIPSN)

ILLCSG  RESET(R4,CCILCS)

NOREC0  STM     R0,NOR0SV,,
      	JAL	R13,RETBF1
        LM      R0,NOR0SV,,

NORECK  LR      R0,R3
        IF      DB.MSG
        EVT(ET.MSG,TS.MSG,R11,R12)
        EI
        JAL     R4,FLUSH
        J       GETINP

ZAPBAK  STM     R13,IMSGSV,,            
        LR      R8,R15
        JAL     R13,GETBF3              :GET A SMALL BUFFER
        STB     R12,BUFMSG,R6,          :PUT ZAP MSG IN BUF
        LR      R14,R6                  :BUF ADDR IN R14
        JAL     R13,QBPOUT              :QUE BUF AND PST FOR OUTPUT
        LM      R13,IMSGSV,,            :RESTORE REGS.
        JR      R13

:       PUT BUFFER ON PORT (PST) INPUT QUEUE
:       LINKS ON R13
:       R6 = BUFFER ADDR
:       R15 = PST ADDR
:       USES R7

PUTINQ  L       R7,INQUE,R15,
        JE      PUTIN0
PUTIN1  L       R5,0,R7,                :GET NEXT ON QUEUE
        JEFS    PUTIN2
        LR      R7,R5
        JBS     PUTIN1

PUTIN2  ST      R6,0,R7,
        JR      R13

PUTIN0  ST      R6,INQUE,R15,
        JR      R13

:	STUFF A BUFFER (DATA MSG ONLY)
:	LINKS ON R13
:	R6 = BUFFER ADDR
:	R12 = NUMBER OF BYTES IN MSG (ALL OR PART)
:	R3 = NFMI OF BUFFER
:	USES R5

STUFFB  EQ      .
      	LIS	R5,0			:INIT COUNTER
STUFF1	JAL	R4,GETCH		:GET A BYTE
	STB	R0,B1DATA,R3,R6		:PUT IN BUFFER
	AIS	R3,1			:INCREMENT NFMI
	AIS	R5,1			:INCREMENT COUNTER
	SIS	R12,1			:DECREMNT BYTES IN MSG
	JEFS	STUFF2			:THAT'S ALL--JUMP
	CLHI	R3,BUF1MX		:IS THERE STILL ROOM?
	JNBS	STUFF1			:YES, GET ANOTHER BYTE

STUFF2	STB	R3,BFNFMI,R6,		:SAVE NFMI
	LB	R3,BUFLEN,R6,		:GET CURRENT BUF LENGTH
	AR	R5,R3			:ADD NMBR STUFFED THIS TIME
	STB	R5,BUFLEN,R6,		:SAVE UPDATED LENGTH
	JR	R13			:RETURN

:	CANCEL BACKPRESSURE MSG -- REMOVE ALL BUFFERS ON INQUE THAT CONTAIN
:	APPLY BACKPRESSURE MSGS

        SEG     A.DATA
RMBPSV  WS      2
        SEG     A.CODE
RMARBP	ST	R13,RMBPSV,,
	L	R6,INQUE,R15			:GET 1ST ON QUEUE
        JER     R13
        ST      R8,RMBPSV+4,,
        LR      R8,R15       :COPY PST IN R8 FOR RETBF3 CALL
	LHI	R5,BUFTP3			:LOOK FOR BUF TYPE 3
	LB	R7,SPBAKP			:LOOK FOR APPLY BACKPRESSURE
        LB      R4,SPRLBP                       :LOOK FOR RELEASE BKP

CNCLR2	CLB	R5,BUFTYP,R6			:TYPE 3 BUFF AT HEAD OF QUE?
	JN	CNCLR0		
	CLB	R7,BUFMSG,R6			:IS IT APPLY BACKPRESSURE?
        JEFS    CNCLR3
        CLB     R4,BUFMSG,R6
	JN  	CNCLR0

CNCLR3	L	R4,0,R6				:GET NEXT ON QUEUE AFTER 1ST
	JAL	R13,RETBF3			:GET RID OF BUFFER
	LR	R6,R4
	JN	CNCLR1
	LIS	R0,0				:CASE OF ONLY 1 BUF ON INQUE
	ST	R0,INQUE,R15

CNCRET	L	R13,RMBPSV,,
        L       R8,RMBPSV+4,,
	JR	R13

CNCLR1	ST	R6,INQUE,R15			:UPDATE HEAD OF QUEUE
	J	CNCLR2

CNCLR0	LR	R3,R6				:KEEP TRACK OF LAST ONE IN R3
	L	R6,0,R6				:GET NEXT ON QUEUE
	JE	CNCRET
	CLB	R5,BUFTYP,R6			:TYP 3 BUF?
	JNBS	CNCLR0
        CLB     R7,BUFMSG,R6			:APPLY BACKPRESSURE?
        JEFS    CNCLR4
        CLB     R4,BUFMSG,R6                    :RELEASE BKP?
        JNBS    CNCLR0

CNCLR4	L	R4,0,R6				:GET NXT ON QUEUE
	ST	R4,0,R3				:UPDATE NEXT FIELD OF LAST ONE
	JAL	R13,RETBF3
	LR	R6,R3
        JE      CNCRET
	J	CNCLR0
  



        SUBTTL  Mbase Data Forwarding Subroutines

        SEG     A.DATA
FWRDSV  WS      1
        SEG     A.CODE

:       BIT ARRAY FOR TESTING CIRCUIT SIGNALS THAT NEED SPECIAL HANDLING
:       SPECIAL CASE MESSAGES ARE A0,A1,9E,9F,BB,BE

SPECCS  WC      0,0,0,0,3,0C0000012,0
ZAPTYP  WC      0,0,0,0,3,12,0

:       FORWARD DATA MSG IF READ CMD PENDING
:       IF READ CMD NOT PENDING, SET TIME-OUT (IF DF CRITERIA ACTIVE)
:	R15 = PST

FWRDAT  LHI     R0,READGO               :GET PENDING READ FLAG
        TBT     R0,PSTFLG,R15,          :GOT A READ CMD?
        JN      FWRDIN                  :YES, GO FORWARD
        LHI     R0,DFCACT               :ELSE SEE IF DFC ARE ACTIVE
        TBT     R0,PSTFLG,R15,          :IF SO, SET TIMEOUT, IF ANY
        JER     R13                     :IF NOT ACTIVE, RETURN
FWRD05  LHL     R1,DFCTIM,R15,          :GET DF TIMEOUT INTERVAL
        JER     R13                     :IF NONE DEFINED, RETURN
	LHI     R0,DFTIMO               :GET DF TIMOUT FLAG
        TBT     R0,PSTFLG,R15,          :ALREADY SETUP DF TIMOUT?
        JNR     R13                     :YES, RETURN
        SBT     R0,PSTFLG,R15,          :FLAG SAYS WE'RE TIMING INPUT
        L       R2,FASTC,,              :GET CURRENT TIME
        AR      R1,R2                   :GET TIMEOUT VALUE
        LR      R6,R15                  :PST ADDR IN R6
        LA      R0,HNDFTO,,             :HANDLE_DATA_FWRDNG_TIMEOUT
        IF      DB.TOP
        EVT(ET.TOP,TS.TOP,R6,R1)
        EI
        JAL     R5,TOPUT                :PUT ON TIMEOUT QUEUE
        JR      R13                     :RETURN TO IRING TEARDOWN

:       FORWARD CIRCUIT SIGNAL IF READ CMD PENDING
:       CHECK READGO BIT (SET BY READ CMD HANDLER)

FWRDCS  LHI     R2,READGO               :GET 'READ GO' FLAG
        TBT     R2,PSTFLG,R15,          :READ CMD PENDING?
        JER     R13                     :IF NOT, NO CAN DO

:       FORWARD INPUT -- CALLED BY READ CMD HANDLER
:       (CALL TO FWRDCS OR FWRDAT BY IRNGTD TASK WILL ALSO USE FWRDIN)
:	R15 = PST ADDR
:	R14 = IOCB ADDR

:	R2 = SPIRIT DATA MSG TYPE
:	R3 = BUF ADDR
:	R4 = CHAR PTR IN BUF
:	R5 = RUNNING COUNT OF CHARS CHECKED
:	R6 = DFC MASK
:	R7 = DFC LENGTH

FWRDIN	ST      R13,FWRDSV,,
	LHI	R0,DFCACT		:DFC ACTIVE FLAG
	TBT	R0,PSTFLG,R15,		:DFC CRITERIA ACTIVE?
	JE	CMPLRD			:NO--COMPLETE READ CMD
	LHI	R0,DFOVRD		:DFC OVERRIDE SET ?
	TBT	R0,PSTFLG,R15
	JN	CMPLRD			:IF SO - GO COMPLETE THE READ
	LB	R2,SPDATA,,		:GET SPIRIT DATA MSG TYPE
	L	R3,INQUE,R15,		:GET 1ST BUFFER ON QUEUE
FWRDN1	CLB	R2,BUFMSG,R3,		:IS IT A CIRCUIT SIGNAL?
	JN	CMPLRD			:YES--COMPLETE READ CMD
	L	R3,BUFNXT,R3,		:GET NEXT ON QUEUE
	JNBS	FWRDN1			:JUMP IF THERE IS ONE

:	NO CIRCUIT SIGNALS ON QUEUE--CHECK DATA FORWARDING CHARACTERISTICS

        L       R3,INQUE,R15,           :GET 1ST BUF
        LB      R0,BUFTMO,R3,           :IF BUF DF TIMOUT FLAG SET...
        JN      CMPLRD                  :THEN DATA FORWARDABLE

	L	R3,DFCLBE,R15,		:GET ADDR OF LAST BUF EXAMINED
	JNFS	FWRDN2			:JUMP IF NOT 0
	L	R3,INQUE,R15,		:START WITH FIRST-ON-QUEUE
	LIS	R4,0			:INIT CHAR PTR
	LIS	R5,0			:INIT CHAR COUNT
	JFS	FWRDN3		
FWRDN2	LHL	R5,DFCCHC,R15,		:GET RUNNING CHAR COUNT
      	LHL	R4,DFCLCE,R15,		:GET LAST CHAR EXAMINED
        CLHI    R4,BUF1MX               :ANY MORE CHARS TO CHECK?
        JLFS    FWRDN3                  :JUMP IF SO
        LIS     R4,0                    :ELSE INIT BUF CHAR CNT
        L       R3,BUFNXT,R3,           :AND GET NXT BUF

FWRDN3	LHL	R6,DFCMSK,R15,		:GET DFC MASK
	LHL	R7,DFCLIM,R15,		:GET DFC LIMIT (LENGTH)
	LR	R6,R6			:ANY DATA FORWARDING CHARS?
	JN	FWRDN4			:JUMP IF SO
	LR	R7,R7			:DFC LENGTH DEFINED?
        JNFS    FWRDN7                  :YES, ELSE CAN'T FORWARD DATA
	J	FWRD05			:GO START A TIMER


:	CASE WHERE ONLY LENGTH CRITERION APPLIES

FWRDN7	CR	R5,R7			:CHAR COUNT = DFC LIMIT?
	JGE	FWRDOK			:YES--DATA FORWARDABLE
	AIS	R5,1			:INCRMENT CHAR COUNT
	AIS	R4,1			:INCREMNT BUF CHAR IDX
	CLB	R4,BUFLEN,R3,		:END OF BUFFER?
	JNBS	FWRDN7
	ST	R3,DFCLBE,R15,		:SAVE LAST BUF EXAMINED
	L	R3,BUFNXT,R3,		:GET NEXT ON QUEUE
	JE	NOFWRD			:IF NONE, GET OUT
	LIS	R4,0			:INIT CHR COUNT FOR BUF
	J	FWRDN7			:CHECK THIS BUFFER

FWRDN4	LR	R7,R7			:CHECKING LENGTH?
	JN	FWRDN5			:YES, JUMP

:	CASE WHERE ONLY CHECKING FOR CHARACTER

FWRDN6	LB	R0,B1DATA,R3,R4		:GET CHAR FROM BUF
	NHI	R0,7F			:GET RID OF HI BIT
	TBT	R0,FWCHRS,R15,		:FORWARDING CHARACTER?
	JN	FWRDOK			:YEP, GO DO IT
	AIS	R5,1			:INCREMNT CHECKED COUNT
	AIS	R4,1			:INCREMNT BUF IDX
	CLB	R4,BUFLEN,R3,		:END OF BUF?
	JN  	FWRDN6			:NO, CHECK NEXT CHAR
	ST	R3,DFCLBE,R15,		:SAVE LAST BUF EXAMINED
	L	R3,BUFNXT,R3,		:GET NEXT BUF
	JE	NOFWRD			:NOTHING LEFT--GET OUT
	LIS	R4,0			:INIT BUF IDX
	J	FWRDN6			:CHECK NEXT BUF

:	CHECK FOR CHARACTER AND LENGTH

FWRDN5	LB	R0,B1DATA,R3,R4		:GET CHAR FROM BUF
	NHI	R0,7F			:GET RID OF HI BIT
	TBT	R0,FWCHRS,R15,		:FORWARDABLE CHARACTER?
	JN	FWRDOK			:YES--GO DO IT
	CR	R5,R7			:NMBR CHARS CHECKD = LENGTH?
	JGE	FWRDOK			:YES, GO DO IT
	AIS	R5,1			:INCREMNT COUNT
	AIS	R4,1			:INCREMNT BUF IDX
	CLB	R4,BUFLEN,R3,		:END OF BUFFER?
	JN  	FWRDN5			:NO, CHECK NEXT CHAR
	ST	R3,DFCLBE,R15,		:SAVE LAST BUF EXAMINED
	L	R3,BUFNXT,R3,		:GET NEXT BUF
	JEFS	NOFWRD			:NOTHING LEFT--GET OUT
	LIS	R4,0			:INIT BUF IDX
	J	FWRDN5			:CHECK NEXT BUF

:	DATA NOT FORWARDABLE

NOFWRD	STH	R4,DFCLCE,R15,		:SAVE LAST CHAR EXAMINED
	STH	R5,DFCCHC,R15,		:SAVE CHARS CHECKED COUNT
        L       R13,FWRDSV,,
        J       FWRD05                  :GO RESET DF TIMER (IF THERE'S ONE)

:       DATA IS FORWARDABLE

FWRDOK  STH     R4,DFCLCE,R15,          :SAVE LAST CHAR EXAMINED
        STH     R5,DFCCHC,R15,          :SAVE CHAR COUNT

:       COMPLETE A READ COMMAND

:	R6 = SRB ADDR
:	R7 = DATA BUFFER ADDRESS
:	R8 = BUFFER CEI
:	R9 = BUFFER LENGTH
:	R10 = IOCB COUNT
:	R11 = IOCB NMBR
:	R12 = BUF ADDR + CEI
:	R14 = IOCB
:	R15 = PST

CMPLRD	STM	R8,CMPSAV,,
	LHI     R2,READGO               :GET READ GO FLAG
        RBT     R2,PSTFLG,R15,          :CLEAR IT 
      	L	R7,INQUE,R15,		:GET FIRST DATA BUF ON QUEUE
	JL	DOZPAK			:JUMP IF SPECIAL ZAP ACK CASE
	LB	R2,BUFTYP,R7,		:GET BUFFER TYPE
	CLHI	R2,1			:TYPE 1 (SBUS BUF)?
	JE	CMPLR0			:YES, JUMP

:       FORWARD SHORT CIRCUIT SIGNAL

	JAL	R13,GETBF2		:GET SRB BUFFER
	LB	R2,BUFMSG,R7,		:GET BUFFER MSG
	STB	R2,STBYT1,R6,		:PUT MSG IN STAT BYTE 1
        LB      R3,PORT,R15             :PORT 0?
        JE      CMPL0                   :JUMP IF SO
        LB      R3,TOISPN,R2,           :GET ISIS EQUIVALENT OF THIS MSG
        TBT     R3,SPECCS               :NEED SPECIAL CASE HANDLING?
        JE      CMPL0                   :JUMP IF NOT
	TBT	R3,ZAPTYP,		:ANY KIND OF ZAP?
	JEFS	CMPLAB			:IF NOT, CHECK FOR BACKPRESSR MSGS
        LHI     R2,ATTENT               :GET ATTENTION FLAG
        STB     R2,STBYT0,R6            :STORE IN STAT BYTE 0
        LHI     R2,ZAPINQ               :CLEAR BUFFERED-ZAP-ON-INQUE BIT
        RBT     R2,PSTFLG,R15
	LA	R2,SNTZAP		:IF SO - POINT TO A DONE RTN
	ST	R2,RETADR,R6
        J       CMPL0
CMPLAB  CLB     R2,SPBAKP,,             :CHECK FOR SET BP
        JN      CMPLRB                  :CHECK FOR RELEASE BP
        LHI     R2,ABPINQ               :GET APPLY-BKP-ON-INQUE FLAG
        RBT     R2,PSTFLG,R15           :CLEAR IT
        LHI     R1,BPTOSP               :SET FLAG INDICATING THAT...
        SBT     R1,PSTFLG,R15           :SPIRIT IS BACKPRESSURED
        JFS     CMPL0
CMPLRB  CLB     R2,SPRLBP,,             :THIS SHOULD BE A RELEASE BKP
        JN      CMPLCR                  :IF NOT, CRASH
        LHI     R1,BPTOSP               :RESET SPRIIT BKPR STATE FLAG
        RBT     R1,PSTFLG,R15
CMPL0	LB	R2,BUFLEN,R7		:ANY PARAMETERS?
	JEFS	CMPLR2			:JUMP IF NOT
	LIS	R3,0			:INIT OFFSET
CMPLR1	LB	R0,B3DATA,R7,R3      	:GET A PARAM
	STB	R0,STBYT2,R6,R3		:PUT IN STAT BYTE
	AIS	R3,1			:INCREMENT OFFSET
	SIS	R2,1			:DECREMENT PARAM COUNT
	JNBS	CMPLR1			:GET 2ND PARAM  (IF THERE IS ONE)
CMPLR2	LHI	R0,RDNSTA		:READ DATA AND STATUS 
	STB	R0,SRBYTE,R6,		:PUT IN SR BYTE
        LB      R2,INCHNL,R15,          :GET CHANNEL NMBR
        STB     R2,SRCHNL,R6,           :PUT IN SRB
	JAL	R13,ENQSRB		:ENQUE SRB
        L       R8,BUFNXT,R7,           :GET NEXT BUF, IF ANY
        ST      R8,INQUE,R15,           :IT'S NOW FIRST-ON-QUE
	LR	R6,R7			:BUFFER ADDR IN R6
        LR      R8,R15                  :PST IN R8 FOR RETBF3
	JAL	R13,RETBF3		:RETURN BUFFER 
	LM	R8,CMPSAV,,
	JR	R13

:       IT'S A LONG CIRCUIT SIGNAL OR DATA MSG

CMPLR0	L	R14,INIOCB,R15,		:GET INPUT IOCB ADDR
	LB	R10,CB.MSB,R14,		:GET HI BYTE OF READ COUNT
	EXBR	R10,R10			:SWAP BYTES
	LB	R4,CB.LSB,R14,		:GET LOW BYTE OF READ CNT
	OR	R10,R4			:GET COUNT HALFWORD
        JE      CMPERR                  :IF NO LENGTH, ERROR
        LB      R11,INCHNL,R15,         :GET IOCB (CHANNEL) NMBR
        LB      R4,BUFMSG,R7,           :GET MSG IN FIRST BUFFER
        CLB     R4,SPDATA,,             :SPIRIT DATA MSG?
        JN      CMPLCS                  :NO--LONG CIRCUIT SIGNAL
:       SPIRIT DATA MSG IS THE SAME AS SPIRIT'S PORT 0 ATTACH CHANNEL MSG
        CLHI    R11,3                   :INPUT ON PORT 0 ?
        JE      CMPLCS                  :IF SO, IT'S A NEEDLE, NOT DATA

:       DATA MSG--FORWARD DATA W/ 1 OR MORE SERVICE REQUESTS

CMPL10  JAL     R13,GETBF2              :GET SRB BUFFER
	STB	R4,STBYT1,R6,		:PUT MSG IN STAT BYTE 1
      	LB	R8,BUFCEI,R7,		:GET CEI
	LB	R9,BUFLEN,R7,		:BUF COUNT
	LR	R12,R8			:GET COPY OF CEI
        AHI     R12,B1DATA              :ADD OFFSET TO STR OF DATA
	AR	R12,R7			:ADD BUF ADDR
	STH	R12,ADRMSB,R6,		:DATA BUF ADDR IN SRB

:	NOW DETERMINE NUMBER OF BYTES TO PRESENT IN THIS SRB

	CLHI	R10,100			:IOCB COUNT > 256?
	JGEFS	CMPLR3			:IF SO, USE BUF LEN 
	CR	R10,R9			:IOCB COUNT > BUF COUNT
	JGEFS	CMPLR3			:IF SO, USE BUF LEN
	LR	R5,R10			:ELSE USE IOCB COUNT
	JFS	CMPLR4			:JUMP
CMPLR3	LR	R5,R9			:BUF LEN COUNT 
CMPLR4	STH	R5,CNTMSB,R6,		:PUT COUNT IN SRB

:       UPDATE CEI, BUF LEN, AND RUNNING 'IOCB COUNT'

	AR	R8,R5			:BUMP CEI
	STB	R8,BUFCEI,R7,		:SAVE IN DATA BUF
	SR	R10,R5			:DECREMNT IOCB COUNT
	SR	R9,R5			:DECREMNT BUFFER LEN
        STB     R9,BUFLEN,R7,           :SAVE UPDATED LEN

:       DETERMINE STATUS OF SRB--READ DATA OR READ DATA AND STATUS
:       IS THERE MORE DATA TO SEND?  WILL IOCB COUNT ALLOW MORE?
:       IF MORE CAN BE SENT, STATUS OF THIS SRB IS READ DATA
:       ELSE END THIS READ CMD W/ READ DATA AND STATUS

	LR	R10,R10			:REACHED IOCB LIMIT?
	JLEFS	CMPLR8			:YES, JUMP
	L	R8,BUFNXT,R7,		:IS THERE ANOTHER BUF?
	JNFS	CMPLR5			:THERE IS ONE, JUMP
CMPLR8	LHI	R5,RDNSTA		:READ DATA AND STATUS
	JFS	CMPLR6
CMPLR5  LB      R2,BUFMSG,R8,           :CHECK MSG OF NXT
        CLB     R2,SPDATA,,             :IF DATA, THEN READ STATUS
        JNBS    CMPLR8                  :ELSE READ DATA AND STATUS
      	LHI	R5,RDATA		:READ DATA
CMPLR6	STB	R5,SRBYTE,R6,		:SERV. REQ. IN SRB
        STB     R11,SRCHNL,R6,          :IOCB NMBR IN SRB

:       IF BUF LEN <= 0 THEN SET RETURN BUFFER FLAG IN SRB AND...
:       PUT BUFFER ADDR IN BUFADR FIELD OF SRB (DONE TASK RETURNS BUF)

	LR	R9,R9			:ANYTHING LEFT IN DATA BUF?
	JG  	CMPLR7			:JUMP IF SO
	LHI	R0,RTRNBF		:ELSE GET RETURN BUF FLG
	SBT	R0,MSTAT,R6,		:SET IN MSTAT OF SRB
	ST	R7,BUFADR,R6,		:BUF ADDR IN SRB
	L	R8,BUFNXT,R7,		:GET NXT BUF, IF ANY
	ST	R8,INQUE,R15,		:IT'S NOW FIRST ON QUE
        LIS     R0,0
        STB     R0,BUFTMO,R7,           :CLEAR DF TIMOUT FIELD
:       THIS BUF = LAST BUFFER EXAMINED FOR FORWARDABILITY?
      	CL	R7,DFCLBE,R15,		:DATA BUF = LAST BUF XAMND?
	JN  	CMPLR9			:NO, JUMP 
        LIS     R0,0                    :ELSE CLEAR...
        ST      R0,DFCLBE,R15,          :LAST BUF EXAMINED FIELD
        J       CMPLR9

:       THIS BUFFER STAYS ON INPUT QUEUE--STILL HAS DATA TO FRWRD
:       IF LAST BUF EXAMINED FOR FORWARDABILITY, UPDATE DFCCHC
:       AND DFCLCE

CMPLR7  LIS     R0,1            
        STB     R0,BSPLIT,R7            :SET 'BUFFER SPLIT' FLAG
        CL      R7,DFCLBE,R15,          :LAST BUF EXAMINED?
        JNFS    CMPLR9                  :NO
        LIS     R0,0                    :ELSE 0 OUT COUNT OF...
        STH     R0,DFCCHC,R15,          :CHARS CHECKED FOR FWRDABLTY
        LB      R0,BUFCEI,R7,           :CEI OF BUFFER USED IS NOW..
        STH     R0,DFCLCE,R15,          :LAST CHAR EXAMINED

:       IF SR = READ DATA AND STATUS, ENQUE SRB AND GET OUT
:       ELSE ENQUE SRB, GET NEXT BUF, DO ANOTHER SR

CMPLR9  CLHI    R5,RDNSTA               :LAST SRB?
        JEFS    CMPL11
        JAL     R13,ENQSRB              :ENQUE THIS SRB
        L       R7,INQUE,R15,           :GET NEXT ON QUEUE
        J       CMPL10                  :CREATE ANOTHER SRB
CMPL11  JAL     R13,ENQSRB              :ENQUE THIS SRB
	LM	R8,CMPSAV,,
	JR	R13

:	FORWARD LONG CIRCUIT SIGNAL

CMPLCS  LB      R8,BUFLEN,R7,           :GET NMBR OF PARAM BYTES
        CR      R8,R10                  :SIO BYTE COUNT LARGE ENUF?
	JG	CMPERR			:NO, PRESENT START I/O STATUS
        JAL     R13,GETBF2              :GET AN SRB
        ST      R7,BUFADR,R6,           :PUT SBUS BUF ADDR IN SRB BUF
	STH	R8,CNTMSB,R6,		:THIS IS # BYTES TO READ
	STB	R4,STBYT1,R6,		:PUT MSG IN STAT BYTE 1
	LR	R2,R7			:GET COP OF BUF ADDR
	AHI	R2,B1DATA		:ADD OFFSET TO STRT OF DATA
	STH	R2,ADRMSB,R6,		:THIS IS BUF ADDR FOR SPIRIT
	LHI	R2,RDNSTA		:READ DATA AND STATUS...
	STB	R2,SRBYTE,R6,		:SERVICE REQUEST 
	LB	R2,INCHNL,R15,		:GET IOCB NMBR
	STB	R2,SRCHNL,R6,		:PUT IN SRB
        LHI     R2,RTRNBF               :GET RETURN BUFFER FLAG
        SBT     R2,MSTAT,R6,            :SET IN SRB
	JAL	R13,ENQSRB		:PUT ON QUE
	L	R8,BUFNXT,R7,		:GET NEXT, IF ANY
	ST	R8,INQUE,R15,		:IT'S NOW 1ST ON QUEUE
	LM	R8,CMPSAV,,
	JR	R13
CMPLCR  RESET(R13,CCCMRD)

:       SPECIAL CASE OF ZAP ACK PUT ON INPUT QUEUE BY RQSTRT TASK
:       HI-ORDER BIT OF BUFFER ADDR SET TO FLAG ZAP ACK

DOZPAK  NI      R7,7FFFFFFF             :CLEAR HI BIT
        JAL     R13,GETBF2              :GET AN SRB BUF
	LB	R2,BUFMSG,R7,		:GET ZAP ACK
	STB	R2,STBYT1,R6,		:PUT IN SRB
	LHI	R2,ATTENT		:GET ATTENTION FLAG
	STB	R2,STBYT0,R6,		:PUT IN STAT BYT 0
	LHI	R2,RDNSTA		:READ DATA AND STATUS...
	STB	R2,SRBYTE,R6,		:SERVICE REQUEST TYPE
        LB      R2,INCHNL,R15,          :GET IOCB NMBR
        STB     R2,SRCHNL,R6,           :PUT IN SRB
        LA      R2,ZAPTOI
        ST      R2,RETADR,R6
        L       R8,BUFNXT,R7            :GET NXT ON INPUT QUE, IF ANY
        ST      R8,INQUE,R15            :UPDATE START OF QUE
        LHI     R2,ZAPINQ               :CLEAR BUFFERED-ZAP-ON-INQUE BIT
        RBT     R2,PSTFLG,R15
	JAL	R13,ENQSRB		:PUT SRB ON QUE
	LR	R6,R7			:BUF 3 ADDR IN R6
        LR      R8,R15                  :PST IN R8 FOR RETBF3
	JAL	R13,RETBF3		:RETURN IT
	LM	R8,CMPSAV,,
	JR	R13

:	IOCB COUNT IS NOT LARGE ENOUGH FOR CIRCUIT SIGNAL
:	PRESENT START I/O ERROR STATUS TO SPIRIT

CMPERR  JAL     R13,GETBF2              :GET AN SRB
	LHI	R2,SIOERR		:INCLUDE SIO ERROR FLAG
	OHI	R2,FAILED		:AND FAILED FLAG
	STB	R2,STBYT0,R6,		:PUT IN STATUS BYTE 0
	LHI	R2,RDTOOS		:READ CMD TOO SHORT
	STB	R2,STBYT1,R6,		:IN STATUS BYTE 1
	LHI	R2,RDSTAT		:READ STATUS SERVICE REQ.
	STB	R2,SRBYTE,R6,		:SERVICE REQUEST
	LB	R2,INCHNL,R15,		:GET CHANNEL NUMBER
	STB	R2,SRCHNL,R6,		:PUT IN SRB
	JAL	R13,ENQSRB		:PUT ON QUEUE
	LM	R8,CMPSAV,,
	JR	R13

	SEG	A.DATA
CMPSAV	WS	8


:	DEFINE FORWARDING CHARACTERS
:	CALLED BY SET FORWARDING CHRACTERISTICS CMD HANDLER
:	SETS PST BIT ARRAY OF FORWARDING CHARACTERS
:	LINKS ON R13
:	R15 = PST ADDR

        GL      DEFFCH
        SEG     A.DATA
DEFFSV  WS      1
        SEG     A.CODE
DEFFCH	ST	R13,DEFFSV,,
:	FIRST CLEAR PST BIT ARRAY OF FORWARDING CHARACTERS
	LIS	R0,0
	LIS	R1,0
DEFFC0	STB	R0,FWCHRS,R15,R1	:CLEAR A BYTE
	AIS	R1,1
	CLHI	R1,10			:DONE?
	JNBS	DEFFC0

	LB	R1,DFCMSK+1,R15,	:GET DFC MASK 
	JE	DEFFC4			:NO FORWARDING CHARS DEFINED
      	LR	R2,R1			:GET A COPY OF MASK
DEFFC1	JFFOH	R2,DEFFC2		:GO HANDLE THIS BIT
        RESET(R13,CCJFFO)
DEFFC2	XH	R1,HMASK,R3,R3		:CLEAR BIT FROM MASK
        LB      R3,BPIDXV,R3,           :BIT POSITION MAPS TO IDX VALUE
	L	R4,DFCBAT,R3,		:DF CHAR BIT ARRAY ADDR TABLE
	LHI	R5,0E			:INIT BIT ARRAY IDX
DEFFC3	LHL	R6,0,R4,R5		:GET A HALFWORD OF BIT ARRAY
        LHL     R7,FWCHRS,R15,R5        :GET CURRENT PST HLFWRD 
        OR      R6,R7                   :OR WITH R6
	STH	R6,FWCHRS,R15,R5	:STORE IN PST FC BIT ARRAY
	SIS	R5,2			:DECREMNT IDX
	JGEBS	DEFFC3			:GET NEXT HLFWRD
        LR      R2,R1                   :GET A COPY OF MASK
	JN	DEFFC1			:GET NEXT MASK BIT, IF ANY
DEFFC4  RETURN(DEFFSV)

:	DF CHARACTER BIT ARRAYS--EACH ARRAY CORRESPONDS TO A BIT...
:	IN THE DFC MASK (PASSED BY SET FORWARDING CHARACTERSTICS CMD)

DFCBA7	WC	0,0000FFC0,7FFFFFE0,7FFFFFE0	:ALPHA-NUMBERIC CHARS
DFCBA6	WC	00040000,0,0,0			:CARRIAGE RETURN
DFCBA5	WC	07000010,0,0,0			:ENQ,ACK,BEL,ESC
DFCBA4	WC	00002080,0,0,1			:DC2,CAN,DEL
DFCBA3	WC	18000000,0,0,0			:ETX,EOT
DFCBA2	WC	00780000,0,0,0			:HT,LF,VT,FF
DFCBA1	WC	0E883DF6F,0,0,0			:ALL OTHER CONTROL CHARS
DFCBA0	WC	0,0FFFF003F,8000001F,8000001E   :ALL OTHER PRINTABLE CHARS

:	TABLE OF DF CHARACTER BIT ARRAY ADDRESSES

DFCBAT	WC	DFCBA0			
	WC	DFCBA1
	WC	DFCBA2
	WC	DFCBA3	
	WC	DFCBA4
	WC	DFCBA5
	WC	DFCBA6
	WC	DFCBA7

BPIDXV  BC      0,0,0,0,0,0,0,0,0,4,8,0C,10,14,18,1C


:	HANDLE DATA FORWARDING TIMEOUT--CALLED BY TIMER TASK
:	WHEN A TIMEOUT IS REACHED ON TIMEOUT BLOCK ENQEUEUED 
:	BY FWRDAT.   FWRDAT ENQUEUES BLOCK 

:	THIS ROUTINE WILL CALL COMPLETE_READ_CMD SUBROUTINE IF
:	A READ CMD IS UP AND IF THERE IS DATA STILL ENQUEUED.
:	AFTER CALL TO CMPLRD, IF THERE ARE STILL DATA BUFFERS ON
:	INPUT QUEUE, THE BUFTMO FLAG IS SET ON EACH REMAINING
:	BUFFER, MEANING THAT THIS DATA IS FORWARDABLE AND WILL
:	BE SO NOTED ON THE NEXT CALL OF FWRDIN OR FWRDAT.

:	THE TIMEOUT IS ALWAYS REMOVED FROM QUEUE (CANCELED)
:       THE PST FLAG DFTIMO IS ALSO CLEARED

:	LINK ON R13
:	R6 = PST ADDR

	SEG	A.DATA
HNDSAV	WS	2

	SEG	A.CODE
HNDFTO	LHI	R0,READGO		:GET READ GO FLAG
	TBT	R0,PSTFLG,R6,		:READ CMD PEDNDING?
	JE	HNDFT1			:NO, JUMP
        LA      R13,HNDFT1              :RETURN HERE AFTER CMPLRD
        ST      R13,FWRDSV,,            :SAVE LINK REG.
	L	R7,INQUE,R6		:IF NOTHING QUEUED - BYE
	JE	HNDFT2
	ST	R6,HNDSAV,,
        ST      R15,HNDSAV+4,,
        LR      R15,R6
	JAL	R13,CMPLRD		:COMPLETE READ CMD
	L	R6,HNDSAV,,
        L       R15,HNDSAV+4,,
HNDFT1	L	R7,INQUE,R6		:ANY BUFFERS LEFT?
	JE  	HNDFT2			:JUMP IF NOT
HNDFT3	LB	R0,BUFMSG,R7,		:GET MSG IN BUF	
	CLB	R0,SPDATA,,		:SPIRIT DATA MSG TYPE?	
	JNFS	HNDFT2			:JUMP IF NOT
	LIS	R4,1			:SET BUFTMO FLAG IN ANY
	STB	R4,BUFTMO,R7,		:REMAINING DATA BUFS
	L	R7,BUFNXT,R7,		:GET NEX BUF, IF ANY
	JNBS	HNDFT3
HNDFT2	LHI	R0,DFTIMO		:GET DF TIMEOUT FLAG
	RBT	R0,PSTFLG,R6,		:CLEAR IT IN PST
	LR	R0,R6			:COPY PST IN R0
        IF      DB.TOG
        EVT(ET.TOG,TS.TOG,R6)
        EI
	JAL	R5,TOGET,,		:CANCEL THIS TIMEOUT
	J	TORET,,			:RETURN
         SUBTTL Mbase exec loop

        SEG     A.CODE
EXEC    EQ      .
        JAL     R13,IRNGTD              :IRING TEAR-DOWN
        JAL     R13,RQSTRT              :I/O REQUEST STARTER
        JAL     R13,SRDONE              :SERVICE REQEUST DONE TASK
        JAL     R13,ISOUT               :ISIS OUTPUT TASK
        JAL     R0,TIMOUT,,             :TIMER
        JAL     R13,GLBKPT              :GLOBAL BACKPRESSURE TASK
        SVC     DISMISS
        JBS     EXEC
            SUBTTL  Control Table Allocation and Diagnostics - fnsh01.r00
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00          Release Date : 09/05/86  **
: **                                                              **
: **  File Name          : FNSH01.R00                             **
: **                                                              **
: **  File Description   : FINISH LIBRARY                         **
: **                                                              **
: **  File Abstract      :                                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements: isis 7.00                      **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
 

	RA	0		:	fnsh01.r00   finish.lib

:	this file should always be assembled LAST!

:	This macro generates the current GMT date and time by creating
:	the following symbols:
:
:	QQQMON - current month
:	QQQDAY - current day within the month
:	QQQYR  - current year
:	QQQHRS - current hour within the day
:	QQQMIN - current minute within the hour
:	QQQSEC - current second within the minute

GENTIM	MACRO(TIME) [

	RA	$0 0A

QQQQYS	EQ	365*4+1			:quad year size in days
QQQDAZ	EQ	(TIME)/(24*60*60)+365	:days since 1/1/74 + 365
QQQNQY	EQ	QQQDAZ/QQQQYS		:# of quad yrs since 1/1/74
QQQROD	EQ	QQQDAZ-QQQNQY*QQQQYS	:remainder of days 
QQQLEA	EQ	QQQROD/365		:year in current quad yr

	IF	QQQLEA-3
QQQLEA	EQ	3
	EI

QQQYR	EQ	QQQNQY*4+QQQLEA+73
QQQDAY	EQ	QQQROD-QQQLEA*365+1

QQQM1	EQ	31
	IF	QQQLEA-2
QQQM2	EQ	29
	ELSE
QQQM2	EQ	28
	EI
QQQM3	EQ	31
QQQM4	EQ	30
QQQM5	EQ	31
QQQM6	EQ	30
QQQM7	EQ	31
QQQM8	EQ	31
QQQM9	EQ	30
QQQM10	EQ	31
QQQM11	EQ	30
QQQM12	EQ	31

QQQMON	EQ	1
QQQNOT	EQ	1

	RE	
	IF	QQQDAY-QQQM|QQQMON|
QQQDAY	EQ	QQQDAY-QQQM|QQQMON|
QQQMON	EQ	QQQMON+1
	ELSE
QQQNOT	EQ	0
	EI
	ER	QQQNOT

QQQRS1	EQ	(TIME)-((QQQDAZ-365)*(24*60*60))
QQQHRS	EQ	QQQRS1/(60*60)
QQQRS2	EQ	QQQRS1-QQQHRS*(60*60)
QQQMIN	EQ	QQQRS2/60
QQQSEC	EQ	QQQRS2-QQQMIN*60
]

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI

	IF	\APROT0
	ELSE
APROT0	EQ	6	:EXECUTION PROTECTED
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	EI
	IF	\APROT1
	ELSE
APROT1	EQ	5	:WRITE PROTECTED
	EI
Q1	EQ	2
	RE	0C
	IF	\APROT|Q1|
	ELSE
APROT|Q1| EQ	6	:EXECUTION PROTECTED
	EI
Q1	EQ	Q1+1
	ER

:	NAD ALLOWS MORE THAN 10000X TO BE PLACED IN ONE "SEG".
:	WE MUST THEREFORE GO INTO EACH SEG AND IF > 10000X ORG BACK TO
:	10000X AND THEN ENTER THE NEXT SEG TO DEPOSIT THE REMAINDER.
:	THIS, OF COURSE, ASSUMES THAT THE NEXT SEG IS EMPTY.
:	A CHECK IS MADE TO INSURE THIS.

Q1	EQ		0
	RE		0E		:FOR Q1 = 0 TO 0E
	  SEG		Q1
Q3	  EQ		10000*(Q1+1)	:  Q3 = UPPER BOUND FOR THIS SEGMENT
	  IF		.-Q3		:  IF THIS SEGMENT OVERFLOWED
Q2	    EQ		.-Q3		:    Q2 = LENGTH OF OVERFLOW
	    ORG		Q3		:    ORG TO MAXIMUM
	    IF		0E-(Q1+1)	:    IF THE NEXT SEG IS NOT E
	      SEG	Q1+1		:      GO INTO NEXT SEG
	      IF	(.-Q3)		:      IF SEG ALREADY IN USE
	        SEG	Q1		:        RETURN TO PREVIOUS SEG
	      ELSE			:      ELSE
APROT|Q1+1|	EQ	APROT|Q1|	:        COPY PROTECTION
	      EI			:      ENDIF
	    EI				:    ENDIF
	    ORG		.+Q2		:    ADD OVERFLOW TO THE CURRENT SEG
	  EI				:  ENDIF
Q1	  EQ		Q1+1		:NEXT Q1
	ER

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	($0S|Q|SIZE-10000)$A;	REMARK	d bytes%;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
Q	EQ	0
	RE	0E
	BC	APROT|Q|
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id
	HS	1		:patch version #
	WS	2		:initial suspend list
QQQTIM	CURGMT			:get current GMT
	GENTIM(QQQTIM)		:output formatted GMT
	RA	$0 0
	BC	QQQMON,QQQDAY,QQQYR  :date code generated
	BC	QQQHRS,QQQMIN,QQQSEC :time code generated (GMT)

	WS	10	:RESERVED FOR FUTURE EXPANSION

    IF	((\ICTL.H)&(\ICTL.L))
ISUSHI	WC	ICTL.H	:USED BY ISIS TO KNOW WHICH SLOTS...
ISUSLO	WC	ICTL.L	:ISRM CONTROLS
	WS	10	:RESERVED FOR FUTURE EXPANSION
    ELSE
    EI

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register set(s) allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
Q5	EQ	0
	REMARK	%                               
	REMARK	Memory Requirement in Bytes
	REMARK	%     Segment      Length       
	REMARK	256 byte page   1K byte page
	REMARK	%     -------      ------       
	REMARK	-------------   ------------
	RE	0F
	IF	S|Q|SIZE
	REMARK	%       
	IF	Q-9
	ELSE
	REMARK	 
	EI	(Q-9)
	NUMBER	Q
	REMARK	          
QQQ	EQ	S|Q|SIZE
	IF	$A 10000-QQQ
	REMARK	 
	EI
	IF	$A 1000-QQQ
	REMARK	 
	EI
	NUMBER	$A QQQ
	REMARK	d          
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF)
Q4	EQ	(S|Q|SIZE+3FF)&(@3FF)
	IF	10000-Q3
	REMARK	 
	EI
	IF	1000-Q3
	REMARK	 
	EI
	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x         
	IF	10000-Q4
	REMARK	 
	EI
	IF	1000-Q4
	REMARK	 
	EI
	NUMBER Q4
	REMARK	x
Q5	EQ	Q5+Q4
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%                                   
	REMARK	-------        -------
	REMARK	%                                    
Q6	EQ	(QQ+$03FF)/400		:FORCE TO 1K BOUNDRY

	RA	$0 0A
	IF	1000-Q6
	REMARK	 
	EI
	IF	100-Q6
	REMARK	 
	EI
	IF	10-Q6
	REMARK	 
	EI
	NUMBER	Q6
	REMARK	d K        
Q7	EQ	Q5/$0400			:COMPUTE SIZE IN K
	IF	1000-Q7
	REMARK	 
	EI
	IF	100-Q7
	REMARK	 
	EI
	IF	10-Q7
	REMARK	 
	EI
	NUMBER	Q7
	REMARK	d K

	RA	$0 0A
	REMARK	%%Code Generated:  
	IF	10-QQQMON
	REMARK	0
	EI
	NUMBER	QQQMON
	REMARK	/
	IF	10-QQQDAY
	REMARK	0
	EI
	NUMBER	QQQDAY
	REMARK	/
	NUMBER	QQQYR
	REMARK	  
	IF	10-QQQHRS
	REMARK	0
	EI
	NUMBER	QQQHRS
	REMARK	:
	IF	10-QQQMIN
	REMARK	0
	EI
	NUMBER	QQQMIN
	REMARK	:
	IF	10-QQQSEC
	REMARK	0
	EI
	NUMBER	QQQSEC
	REMARK	 GMT%
	RA	0	:default radix at end
	UN		:spew out all undefined symbols

    \ 