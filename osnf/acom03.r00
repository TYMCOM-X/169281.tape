	SUBTTL	ACOPT.300 - ASYNC TYMCOM OPTION MODULE
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by TYMNET, Incorporated.                                    **
: ******************************************************************
: **                MODULE IDENTIFICATION                         **
: **                                                              **
: **  Version Number     :  3.00         Release Date : 05/27/86  **
: **                                                              **
: **  File Name          :  ACOPT.300                             **
: **                                                              **
: **  File Abstract      :  Async Tymcom Options		  **
: **								  **
: **  File Description   :  Define max ISIS port numbers,         **
: **			    set option's default value,           **
: **			    define TOM port assigments,           **
: **			    define memory areas,                  ** 
: **			    define buffer areas and calculate     **
: **			    number of bufferlets to be  reserved, **
: **			    define ISIS input, output ring size,  **
: **			    define hardware trace options,        **
: **	                    create macro option tables,           **
: **			    reserve flags area which is           **
: **			    initialized to zero at startup,       **
: **			    define Tymcom & Tom message texts.    **
: **								  **
: ******************************************************************
: **			 CHANGE LOG               		  **
: ** VER  DATE     BY    PIR/NSR  CHANGES (MOST RECENT AT TOP)	  **
: ** --- -------- -----  ------- -------------------------------- **
: **3.00 05/27/86  SDW   PIR1824 Added TBYM table                 **
: **2.06 05/27/86  CAB   NSR 716 Added HCSTTB for multi-based hosts*
: **2.06 05/01/86  CAB   NSR 689 Added BRKLIM and BRKACT          **
: **2.06 04/29/86  CAB           Add CLKSAV to data area          **
: **2.06 01/20/86  OJ    N/A	 Add ETMFLG flag for enter or leave*
: **				 transparency mode (8 bit mode)   **
: **								  **
: **2.06 12/18/85  OJ  		  Add proprietary banner	  **
: **								  **
: ** "	    "	   "	 NSR079   Added a new option to back-     **
: **                              pressure the host using the RS232*
: ** 				  CTS signal, instead of an XON/  **
: **				  XOFF mechanism. The host will   **
: **				  still be able to backpressure   **
: **				  the Tymcom using XON/XOFF.      **
: **				  Covered by Micro Data's project.**
: **				  	SOPT(CTSBP)		  **
: **								  **
: ** "	    "      "	 NSR080   Added a new option to force     **
: **  				  detach upon data loss.          **
: **				  	SOPT(DETDL)		  **
: **								  **
: ** "	    "	   "	 NSR081   Added a new option to allow the **
: **				  host to initiate the disconnect **
: **				  sequnce by using "host disconnect*
: **				  characters" instead of modem    **
: **				  signals.			  **
: **				  Covered by Micro Data's project.**
: **				  	HDCHAR(C1,...,CN)         **
: **								  **
: ** "      "	   "	 NSR082	  Added a new option to give Tymcom*
: **				  an ability to set terminal      **
: **				  parameter -- reverse X enable   **
: **				  for each new circuit. Effect is **
: **				  the same as logging in with a   **
: **				  "control R".			  **
: **				   	SOPT(RXENA)		  **
: **								  **
: ** "      "      "	 NSR459	 Elicit no terminal type match msg**
: **				 Fixed the problem of "NO PORTS   **
: **			         AVAILABLE" msg sent when "NO     **
: **				 TERMINAL MATCH" is detected      **
: **				 by Tymcom.			  **
: **								  **
: **			PIR1823  Micro Data R-mode connection	  **
: ** "      "      "		1. Tymcom login changes		  **
: **				 a. Enter 8 bit mode              **   
: **				    This new option is added to   **
: **				    specify that the host supports**
: **				    8 bit characters.            **
: **				    	SOPT(E8BTM)               **
: **								  **
: **				  b. Terminal initialization msg  **
: **				     Tis new option is allowing   **
: **				     the user to specify a message**
: **				     string sent to terminal side **
: **				     following  the network "enter**
: **				     transparency" message on new **
: **				     logins.			  **
: **				       TINTMS(TXT)                ** 
: **								  **
: ** "      "      "    PIR1823	 2. Escape character handling     **
: **			    	    For these ports, if the escape**
: **				    mechanism is used and the     **
: **				    following character is not    **
: **				    special, both the escape char **
: **				    and the following char must   **
: **				    be sent to the terminal side. **
: **                                   CTLESC(CHAR,SYM)           **
: **								  **
: ** "      "      "	PIR1823	 3. CTS flow control              **
: **					SOPT(CTSBP)               ** 
: **				    Please refer to the above     **	
: **				    NSR079 description.		  **
: **								  **
: ** "	    "      "	PIR1823	 4. Host initiated disconnect     **
: **					HDCHAR(C1,...,CN)         **
: **				    Please refer to the above     **
: **				    NSR081 description.		  **
: **								  **
: ** "      "     DU	PIR1823	 5. Break delay option		  **
: **				    A second numerical parameter  **
: **				    is added to indicate the      **
: **				    number of 1/30 second delays  **
: **				    to provide after the break    **
: **				    is sent.			  **
: **					BKSND(CNT,DELAY)          **
: **								  **
: ** "     "      DU	PIR1823	 6. Tymcom special char handling  **
: **				    The macros are modified to    **
: **				    handle 8 bit special chars.   **
: **								  **
: **				                                  **   
: ******************************************************************
	       	SUBTTL	ASYNC TYMCOM OPTIONS


:	A S Y N C   T Y M C O M   O P T I O N S
:	=======================================

  IF    2-OPLVL :IF NO SUBHOST DEFINED FOR THE LAST HOST
        SHST
  EI
  IF    QPOP            :IF SOME OPTIONS WERE DEFERED
QSHST   EQ      0
        RE      QPOP
        POP|QSHST|
        KILL    POP|QSHST|
QSHST   EQ      QSHST+1
        ER
  EI

	GL	ISIS2,ENGINE
ISIS2	EQ	1	:ISIS-1 NOT SUPPORTED
ENGINE	EQ	1	:INTERDATA NOT SUPPORTED
SGV(BKGND,0)		:RUN IN FOREGROUND
SGV(TYMN,2)             :TYMNET II
SGV(NTOMPT,$A14)        :MAX # TOM PORTS LOGGED IN
SGV(TIMRAT,$A15)        :RATE FOR TIME OUTPUT TO TOM PORTS (IN MINUTES)
SGV(TZONE,0)            :TOM TIMEZONE IS GMT
SGV(NHAMRT,5)           :WAIT 5 MIN BETWEEN HOST ZAP MSGS TO TOM
SGV(TOMTOV,$A60)        :# OF SEC TO WAIT FOR TOM CARRIAGE RETURN
SGV(PROJ,0)             :DO NOT COLLECT PROJECT CODE
SGV(PMRAD,$A10)         :RADIX TO USE FOR PORT # MESSAGE TO USER
TOM     EQ      0       :SORD OF TOM, *ALWAYS 0*
SGV(IDPORT,0,10)        :LOWEST PORT # TO GET ID MESSAGE

NHPORT  EQ      (NTPORT+0F)/10*10+NTOMPT+1 :NMBR OF HOST PORTS (+1 FOR TOM MSG)
NIPORT  EQ      NTPORT+NTOMPT+1 :# ISIS RING PORTS (+1 FOR INTRA NODE PORT)
  IF    .EQ.(TYMN,1)    	:IF TYMNET I
   IF   .EQ.(NTPORT,$A64)       :IF EXACTLY 64 PORTS, ASSUME A 2-3 SLOT ISIS
NIPORT  EQ      $A64+1		:DONT LET NUMBER OF ISIS PORTS GET TOO BIG
   ELSE .EQ.(NTPORT,$A128)      :IF EXACTLY 128 PORTS, ASSUME A 1 SLOT ISIS
NIPORT  EQ      $A128+1		:DONT LET NUMBER OF ISIS PORTS GET TOO BIG
   EI
  EI
GEQ(MAXPRT,NIPORT-1)            :MAX ISIS PORT NUMBER

NSGRP   EQ      $A (NSORDS+15)/16       :NUMBER OF SORD GROUPS
NHPGRP  EQ      $A (NHPORT+15)/16       :NUMBER OF HOST PORT GROUPS
NIPGRP  EQ      $A (NIPORT+15)/16       :NUMBER OF ISIS PORT GROUPS
NAPGRP  EQ      $A (NAPORT+15)/16       :NUMBER OF ASYNC PORT GROUPS
NMPGRP  EQ      $A (NMPORT+15)/16       :NUMBER OF SIO PORT GROUPS
NTPGRP  EQ      NAPGRP+NMPGRP           :TOTAL NMBR OF PORT GROUPS

:       DEFINE TOM PORT ASSIGNMENTS
Q1      EQ      0
Q2      EQ      0F
        RE      NTOMPT
Q1      EQ      Q1!(1^Q2)
Q2      EQ      Q2-1
        ER
S|TOM|GR|NHPGRP-1| EQ   Q1

:       DEFINE MEMORY AREAS
GEQ(A.DATA,0)           :AREA FOR RX1,RX2 ADDRESSABLE DATA
GEQ(A.CODE,1)           :AREA FOR CODE
GEQ(A.BUFF,2)           :AREA FOR BUFFERS AND BUFFERLETS
GEQ(A.WTBL,3)           :AREA FOR WRITABLE TABLES
GEQ(A.RTBL,4)           :AREA FOR READ ONLY TABLES
GEQ(A.RING,5)           :AREA FOR ISIS RINGS

:       DEFINE AREA PROTECTIONS
GEQ(APROT0,6)           :READABLE/WRITABLE
GEQ(APROT1,5)           :READABLE/EXECUTABLE
GEQ(APROT2,6)           :READABLE/WRITABLE
GEQ(APROT3,6)           :READABLE/WRITABLE
GEQ(APROT4,4)           :READABLE ONLY
GEQ(APROT5,6)           :READABLE/WRITEABLE

GEQ(PATCH2,0)           :NO PATCH AREA IN SEG 2


GEQ(NTOUT,0A)           :SIZE OF TIMEOUT LIST
GEQ(NBUF,NIPORT+NHPORT) :NUMBER OF BUFFERS
GEQ(TOPRT,NIPORT*2)	:BFR NMBR OF 1ST TO.HOST BFR

GEQ(IRSIZE,07FC)                :SIZE OF ISIS INPUT RING (BYTES)
GEQ(ORSIZE,07FC)                :ISIS OUTPUT RING SIZE
GEQ(BRKLIM,0018)		::2.06 - CAB - NSR 689 (24 breaks = limit)
:       CALCULATE # OF BUFFERLETS TO RESERVE
        GL      NBFLET
SGV(NCBUF,$A150,10)		:# CHARS/PORT (PLAUSIBLE GUESS)
Q1      EQ      (NCBUF+5)/6     :# OF BUFFERLETS/PORT
NBFLET  EQ      Q1*NHPORT+IRSIZE/6   :TOTAL # OF BUFFERLETS NEEDED

GEQ(PRODID,32)			:PRODUCT ID FOR ASYNC TYMCOM
GEQ(CNTRL,2+4+8+10+100*PROJ)    :ISIS STATE WORD
                                  :2 = PORT NOT REUSABLE TILL EMITS A ZAPPER
                                  :4 = # OF PORTS MAY BE REDEFINED
                                  :8 = HOST #S MAY BE REDEFINED
                                  :10 = TELL SLOT ABOUT TAKEOVER
                                  :100 = ACCUMULATE PROJ CODE FOR ACCOUNTING

  IF    .EQ.(MAXHST,1)
GEQ(HPRT0,MAXPRT)       :INSURE ALL PORTS ASSIGNED FOR TYMNET I
  ELSE
   IF   .EQ.(TYMN,1)    :IF TYMNET I
 REMARK %>>>> ERROR **** ONLY ONE HST CAN BE DEFINED FOR TYMNET I ****%
   ELSE
GEQ(HPRT0,HPRT0+NTOMPT) :ADD TOM (NON ASYNC) PORTS TO HOST 0
   EI
  EI


:       DEFAULT DEBUG OPTIONS

SGV(BUSDSW,0,10)                :NO BUFFERLET UTILIZATION STATISTICS
SGV(CRSTOP,0,10)                :RECOVER FROM CRASHS
SGV(BUFTRC,0,10)                :NO GCI/WCI TRACE

  IF    CRSTOP+BUFTRC+BUSDSW
        REMARK %%*** DEBUG MODE ***%
  EI

        REMARK %ISIS TYMCOM VERSION 
        NUMBER $8 VERSION
        REMARK .
        NUMBER $8 REVLEV
        REMARK %
        NUMBER $A NAPORT
        REMARK  ASYNC PORTS%
        NUMBER $A NMPORT
        REMARK  SIO PORTS%
        NUMBER $A MAXHST
        REMARK  HOSTS%
        NUMBER $A NSORDS
        REMARK  SUBHOSTS%TOM HOST IS 
        NUMBER $A HOST0
        REMARK %

:       REMOVE SOME MACROS
        KILL    HST,SINDXP,PN,PTYP,PSPD,PCAN,MTEXT,SOPT,UDCHAR
        KILL    SHST,UETM,HETM,CTLESC,TYMNET,HDCHAR
        KILL    GOBBLE,MARK,TOMPW,DTRP,RINGTO,HDROP,INACT,BKSND,ABNDM
        KILL    SYMK,PTMK,PSMK,PCODE,DEMEC,STIC,STIMK
        KILL    MVMK,NALU,MACH,MUTOM,TOMCL,TOMGG,TOMTZ,TOMTR,NHAMT,PNRADX
        KILL    RXON,XON,PARITY,FLTRFT,FLTRFH,POLFLO,TERMEC,PSIG
        KILL    HOSTEC,HOSTDE,HBFCLR,MRK,LOGINS,T2741,EOTC,BARNOD,OKNODE
  IF    QGOP    :IF SOME GLOBAL OPTION MACROS AROUND
Q       EQ      0
        RE      QGOP
        KILL    SOP|Q|
Q       EQ      Q+1
        ER
  EI


: HARDWARE TRACE OPTION
:       IF HDWTRC=1 THE HARDWARE TRACE OPTION IS ASSEMBLED.
:       THIS CODE ALLOWS THE TRACING OF THE LAST 32 JUMPS (LOWER 16 BITS).
:       TO ENABLE, ENTER --
:               :W BEXPSD,1000  FOR BACKGROUND
:               :W FEXPSD,1000  FOR FORGROUND
:       TO DISABLE, ENTER --
:               :W BEXPSD,0     FOR BACKGROUND
:               :W FEXPSD,0     FOR FORGROUND
:
:       TRCADR  CONTAINS THE LAST 32 JUMPS
:       TRCPTR  POINTS PAST THE LAST ENTRY
:       TRCREG  CONTAINS THE REGISTERS AT TIME OF LAST JUMP
:       TRCPAT  IS A UPSW INST TO CONTINUE FOLLOWED BY
:               AN 80 BYTE PATCH AREA WHICH CAN BE USED
:               TO PATCH ADDITIONAL TRACE CODE

SDV(HDWTRC,0)
  IF    HDWTRC
        GL      TRCREG,TRCADR,TRCPTR,TRCPSD,TRCPAT,TRACE
        SEG     0               :MUST BE IN SEG 0
        ORG     10
TRCPSD  WC      1000,0000       :NEXT PSD
        WC      TRACE           :ON TRAP, GO TO "TRACE"
TRCREG  WS      10
TRCADR  WS      10              :LAST 32 JUMPS
TRCPTR  HC      0               :PTR INTO TRCADR

        SEG     A.CODE
TRACE   HS
        STM     00,TRCREG       :SAVE ALL REGS
        L       0F,TRCPSD+4     :LAST JUMP ADDR
        LHL     0E,TRCPTR
        STH     0F,TRCADR,0E
        AIS     0E,2
        NHI     0E,3F           :MOD 40
        STH     0E,TRCPTR
        LM      0E,TRCREG+4*0E  :RESTORE REGS USED
TRCPAT  UPSW    TRCPSD          :NOW DO JUMP
        HS      40              :TRACE PATCH AREA
  EI


:       A S Y N C   T Y M C O M   O P T I O N   T A B L E S
:       ====================================================


::      DEFINE PROJECT CODE TERMINATION TABLE

  IF    PROJT   :IF TERMINATION CHARACTERS DEFINED
        SEG     A.RTBL          :READ ONLY TABLE
        GL      PCTTBL
PCTTBL  HS
Q       EQ      0
        RE      8
   IF   \PROJ|Q|
        WC      PROJ|Q|
   ELSE
        WC      0
   EI
Q       EQ      Q+1
        ER
  EI


::      TABLE OF VALID HOST NAMES/NUMBERS.
:       EACH ENTRY IS A 16BIT DESTINATION HOST ORDINAL FROM HOSTS TABLE.
:       2 CHARS FOR SUBHOST NAME SEARCH FOLLOWED BY 16 BIT SUBHOST ORDINAL.
:       ALL ENTRIES FOR ONE DESTINATION HOST MUST BE GROUPED.  THE LAST ENTRY
:       FOR EACH DESTINATION HOST CONTAINS 16 BITS OF 0 IN THE SUBHOST NAME
:       FIELD FOLLOWED BY THE SUBHOST ORDINAL FOR UNKNOW USERNAMES.  IF
:       UNNKNOWN USER NAMES ARE NOT ALLOWED THIS ENTRY MAY BE OMITTED.
:       THE TABLE IS TERMINATED BY AN ENTRY WITH A MINUS VALUE IN THE
:       DESTINATION HOST ORDINAL FIELD.

        SEG     A.RTBL          :READ ONLY TABLES

HNT     HS
Q1      EQ      0
S|NSORDS|HST EQ MAXHST
        RE      NSORDS
        HNT|Q1|
        KILL    HNT|Q1|
Q1      EQ      Q1+1
        ER

        HC      -1              :END OF TABLE
HNTE.L  EQ      6               :LENGTH OF TABLE ENTRIES


::      SUBHOST INDEX POSITION TABLE
:       16 BITS PER HOST FOR POSITION OF SUBHOST INDEX IN USERNAME
:       FIRST POS IS 1, IF NEGATIVE, POS IS REL TO END OF USERNAME.
:       IF SNDXN=-1, NO TABLE IS
:       GENERATED.  IN THIS CASE SNDX0 IS THE VALUE.
  IF    SNDXN+1
SINDXP  HS
Q1      EQ      1
        RE      MAXHST
   IF   \SNDX|Q1|
        HC      SNDX|Q1|
   ELSE
        HC      SNDX0
   EI
Q1      EQ      Q1+1
        ER
  EI

::	HOST KEY TABLE
:	16 BITS PER HOST FOR MULTIPLE TYMCOMS TO REPORT HOST COST
:	TO SUP. IF HKEYN=-1, NO TABLE IS GENERATED, AND ONLY A GLOBAL
:	VALUE IS DEFINED.  IN THIS CASE HKEY0 IS THE VALUE.

	SEG	A.WTBL

 IF	HKEYN+1
	GL	HKEYTB
HKEYTB	HS
Q1	EQ	1
	RE	MAXHST
    IF	\HKEY|Q1|
	HC	HKEY|Q1|	:IF DEFINED, USE SPECIFIC HOST KEY
    ELSE
	HC	HKEY0		:IF NOT DEFINED, USE GLOBAL HOST KEY
    EI
Q1	EQ	Q1+1
	ER
 EI

::	HOST COST TABLE - 2.06 - CAB - NSR 716
:	16 BITS PER HOST FOR MULTIPLE TYMCOMS TO REPORT HOST COST
:	TO SUP. IF HKEYN=-1, NO TABLE IS GENERATED, AND ONLY A GLOBAL
:	VALUE IS DEFINED.  IN THIS CASE HCST0 IS THE VALUE.

	SEG	A.WTBL

 IF	HKEYN+1
	GL	HCSTTB	
HCSTTB	HS
Q1	EQ	1
	RE	MAXHST
    IF	\HCST|Q1|
	HC	HCST|Q1|	:IF DEFINED USE SPECIFIC HOST COST
    ELSE
	HC	HCST0		:IF NOT DEFINED USE GLOBAL HOST COST
    EI
Q1	EQ	Q1+1
	ER
 EI

::      SUBHOST SWITCH OPTION TABLES

:       P0 EQ OPTION, P1 EQ DEFAULT (1=ON,0=OFF
:       OP|P0.| IS EXPECTED TO EQUAL 1 IF THE OPTION WAS EVER DEFINED
:       IF OP|P0.| IS UNDEFINED IT WILL BE SET TO 0.
:       IF SUP IS SPECIFIED AND IS > 0, NOTHING WILL BE GENERATED
:       IF OP|P0.| = 0

	SEG	A.RTBL


SSWV    MACRO(P0,P1,SUP)[
  IF    1-OP|P0`.|
QQ      EQ      1-0`SUP
  ELSE
QQ      EQ      1
  EI
  IF    QQ
P0      HS
 IF .GE.(SEEGEN,2); REMARK %P0  ; EI
Q2      EQ      0               :SORD #
        RE      NSGRP
Q3      EQ      0               :SORD GROUP BITS
Q4      EQ      0               :SORD # RELATIVE TO GROUP
        RE      10
  IF    NSORDS-Q2       :IF Q2<NSORDS
   IF   1-\S|Q2|O|P0`.|
S|Q2|O|P0`.|    EQ      P1
   EI
Q3      EQ      Q3!(S|Q2|O|P0`.|^(0F-Q4))
   IF   SEEGEN-2        :IF SEEGEN>2
Q5      EQ      S|Q2|O|P0`.|
         NUMBER $A Q2; REMARK =; NUMBER $A Q5
    IF Q2-7&7   :CRLF EVERY 8 TIMES
        REMARK  ;
    ELSE
        REMARK %        ;
    EI
   EI
  EI
Q2      EQ      Q2+1            :NEXT SORD #
Q4      EQ      Q4+1            :NEXT SORD # RELATIVE TO GROUP
        ER
        HC      Q3              :1 IF OPTION ON FOR SORD IN GROUP
        ER
  EI    (QQ)
]

:       SET SORD SWITCH OPTIONS
  IF .GE.(SEEGEN,2)
        REMARK %%SWITCH SORD#=VALUE
  EI
        SEG     A.RTBL          :READ ONLY TABLE
SSWV(ECHO,1)
SSWV(ELFCR,1)
SSWV(ECRLF,1)
SSWV(ECTLI,0)
SSWV(ECTLH,0)
SSWV(CRDLY,1)
SSWV(LCTLH,0)
SSWV(BKGOB,0,1)
SSWV(BKDSC,0,1)
SSWV(GINDL,0,1)
SSWV(GNHEX,0,1)
SSWV(GUNAM,0,1)
SSWV(RNGTG,1)
SSWV(RNGDR,1)
SSWV(RLSPT,1)
SSWV(CAPFT,0,1)
SSWV(CAPFH,0,1)
SSWV(BZAPM,0)
SSWV(TICAP,0)
SSWV(T2741,0,1)
SSWV(PARC,0,1)  :1= CHECK PARITY, 0= LEAVE IT AS 8 BIT VALUE
  IF    OP|PARC.|
SSWV(PAEO,1)    :1= EVEN OR ODD, 0= MARK OR SPACE
SSWV(PAEM,1)    :1= EVEN OR MARK, 0= ODD OR SPACE
  EI
SSWV(RXENA,0,1)	:REVERSE X ENAABLE
SSWV(DETDL,:DETACH ON DATA LOSE  
SSWV(E8BTM,0)	:ENTER 8 BIT MODE
SSWV(CTSBP,0)	:CTS BP

:: Check if SOPT(CTSBP) option is set to on, SOPT(-RNGDR) must set to off

GEQ(ERCNT,0)			   :Error count
Q	EQ	0
QQ	EQ	RNGDR.	
QQQ	EQ	CTSBP.

	RE	NSORDS
  IF	\S|Q|O|QQ|		   :If RNGDR has been defined
    IF	S|Q|O|QQ|		   :If RNGDR set to on
      IF  \S|Q|O|QQQ|	   :If CTSBP has been defined
        IF  S|Q|O|QQQ|	   :If CTSBP set to on
ERCNT	EQ	ERCNT+1		   :Error count = Error count+1
        EI
      EI
    EI
  EI
Q	EQ	Q+1
	ER

  IF	ERCNT			   :If error count = 1
REMARK%>>> ERROR >>>  RNGDR & CTSBP CAN'T DEFINE UP AT THE SAME TIME %      
	QUIT	1
  EI

    KILL    SSWV


::	SBE(LL,P0,P1,P2,P3,P4,P5,P6,P7)	SET BIT VALUE EQUATES
:
:	EXPECTS LL|Q1|Wx = VALUE OF BIT ARRAY WORD x FOR SORD Q1, IF ANY
:		LL|Q1|Vx = DEFAULT VALUE FOR LL|Q1|Wx FROM HIGHER LEVELS
:		Px       = DEFAULT VALUE FOR WORD x IF NOTHING SPECIFIED
:	SETS LL|Q1|Wx TO VALUE ACTUALLY USED

SBE	MACRO(LL,P0,P1,P2,P3,P4,P5,P6,P7)[
QQ0	EQ	P0 0
QQ1	EQ	P1 0
QQ2	EQ	P2 0
QQ3	EQ	P3 0
QQ4	EQ	P4 0
QQ5	EQ	P5 0
QQ6	EQ	P6 0
QQ7	EQ	P7 0
QQQ	EQ	0
  IF	1-\LL|Q1|W0
  IF	1-\LL|Q1|W1
  IF	1-\LL|Q1|W2
  IF	1-\LL|Q1|W3
  IF	1-\LL|Q1|W4
  IF	1-\LL|Q1|W5
  IF	1-\LL|Q1|W6
  IF	1-\LL|Q1|W7
QQQ	EQ	1
   IF	1-\LL|Q1|V0
   IF	1-\LL|Q1|V1
   IF	1-\LL|Q1|V2
   IF	1-\LL|Q1|V3
   IF	1-\LL|Q1|V4
   IF	1-\LL|Q1|V5
   IF	1-\LL|Q1|V6
   IF	1-\LL|Q1|V7
QQQ	EQ	2
   EI; EI; EI; EI; EI; EI; EI; EI
  EI; EI; EI; EI; EI; EI; EI; EI
Q2	EQ	0
	RE	8
  IF	1-QQQ
   IF	1-\LL|Q1|W|Q2|
LL|Q1|W|Q2| EQ	0
   EI
  ELSE	2-QQQ
   IF	\LL|Q1|V|Q2|
LL|Q1|W|Q2| EQ	LL|Q1|V|Q2|
   ELSE
LL|Q1|W|Q2| EQ	0
   EI
  ELSE
LL|Q1|W|Q2| EQ	QQ|Q2|
  EI
Q2	EQ	Q2+1
	ER
]


::      SSV(lll,NNNN,DEF,BB,LL)       SET SINGLE VALUE OPTIONS
:
:       EXPECTS lllN = HIGHEST LEVEL DEFINED AT -1=NEVER, 0=GLOBALLY ONLY,
:                       1=HOST LEVEL, 2=SUBHOST LEVEL
:                       IF LLLN=1 AND MAXHST=1, LLLN WILL BE SET TO 0,
:                       BECAUSE THIS IS ACTUALLY GLOBAL
:                       IF LLLI NOT DEFINED SET TO DEF
:               llli, (i-0,...,NSORDS-1) = value for a subhost
:       IF LLLN < 1,
:       lllSV will equal the value, else lllSV will be THE address of
:       a byte array of NSORD values, llli.
:	NNNN is displayed parameter name at sysgen (SEEGEN)
:	DEF is default value (see above)
:	if BB is 1, LL is name of bit array for SBE

SSV     MACRO(lll,NNNN,DEF,BB,LL)[
 IF .GE.(SEEGEN,2); REMARK %NNNN        ; EI
  IF    .EQ.(MAXHST,1)
   IF   .EQ.(LLL`N,1)
LLL`N   EQ      0
   EI
  EI
  IF    lll`N           :IF >1 VALUES
lll`SV  BS
Q1      EQ      0
        RE      NSORDS
   IF   1-\LLL|Q1|
LLL|Q1| EQ      DEF
   EI
        BC      lll|Q1|
   IF	BB
	SBE(LL)
   EI
Q1      EQ      Q1+1
        ER
  ELSE
   IF   1-\LLL`0
LLL`0   EQ      DEF
   EI
lll`SV  EQ      lll`0
   IF	BB
Q1	EQ	0
	SBE(LL)
   EI
  EI
  IF    .GE.(SEEGEN,3)
   IF   LLL`N
Q1      EQ      0
        RE      NSORDS
Q2      EQ      lll|Q1|
 NUMBER $A Q1; REMARK =; NUMBER $A Q2
    IF  Q1-7&7  :CRLF EVERY 8 TIMES
        REMARK d ;
    ELSE
        REMARK d%
    EI
Q1      EQ      Q1+1
        ER
   ELSE
 REMARK =; NUMBER $A LLL`0; REMARK d
   EI
  EI
]


::      DEFINE SINGLE VALUE OPTIONS.
        SEG     A.RTBL          :READ ONLY TABLES
SSV(DTRP,DTRP,1,0)              :DTR PAUSE IN SEC
SSV(RNGT,RINGTO,4,0)            :RING TIMOUT IN SEC
SSV(NHA,HDROP,4,0)              :NO HOST ACK OF ZAP TIMOUT IN SEC
SSV(INA,INACT,0,0)              :INACTIVITY TIMOUT IN MIN
SSV(BKS,BKSND,0,0)              :# OF 75MS BREAKS
SSV(BKD,BKDLY,0,0)		:# OF 1/30 SEC DELAYS FOLLOWING BREAK
SSV(EOTC,EOTC,0FF,1,EO)         :HOST END OF TEXT CHARACTER (GREENBALL)
SSV(HETM,HETM,0FF,1,HT)
SSV(UETM,UETM,0FF,1,UT)
SSV(ESC,CTLESC,0FF,1,ES)
ESPSN	EQ	ESCN
SSV(ESPS,ESPS,-1,0)		:PASS ESC CHAR
SSV(XON,XON,0FF,0)
XOFN    EQ      XONN
SSV(XOF,XOFF,0FF,0)
SSV(RXON,RXON,0FF,1,RX)
RXOFN   EQ      RXONN
SSV(RXOF,RXOFF,0FF,0)
SSV(TEON,TEON,0FF,1,TC)
TEOFN	EQ	TEONN
SSV(TEOF,TEOFF,0FF,0)
SSV(PFQ,PFPOL,0FF,1,PF)
PFAN	EQ	PFQN
SSV(PFA,PFACK,0FF,0)
        KILL    SSV


::      SMV(ll,nn,la,lb,def)    SET MULTIPLE VALUE
:
:       EXPECTS LLCNT+1=MAX VALUES POSSIBLE
:               LLN=LEVEL DEFINED AT -1=NEVER,0=GLOBAL,1=HST,2=SHST
:               LAxLBy=VALUE, X=(0,...,LLCNT-1),Y=(0,...,NSORDS-1)
:                       IF LAxLBy NOT DEFINED VALUE WILL BE DEF
:               SETS UP BYTE ARAYS OF NSORDS BY LLCNT+1
:               FIRST NSORD BYTES HAVE 1ST VALUE, 2ND NSORD BYTES
:               2ND VALUE, ETC.
:               BYTE ARRAYS START AT LLxSV X=(0,...,LLCNT-1)
:       IF LLN<1, NO BYTE ARRAYS WILL BE CREATED, INSTEAD, LLxSV
:       WILL BE THE ACTUAL VALUES.

SMV     MACRO(ll,nnnn,la,lb,def)[
 IF .GE.(SEEGEN,2); REMARK %nnnn        ; EI
  IF    ll`CNT+1
   IF   .EQ.(MAXHST,1)
    IF  .EQ.(ll`N,1)
ll`N    EQ      0
    EI
   EI
Q1      EQ      0
        RE      ll`CNT+1
   IF   ll`N
ll|Q1|SV        BS
Q2      EQ      0
QQ	EQ	NSORDS
        RE      NSORDS
    IF  \la|Q1|lb|Q2|
Q3      EQ      la|Q1|lb|Q2|
    ELSE
Q3      EQ      def
    EI
        BC      Q3
    IF  .GE.(SEEGEN,3)
 NUMBER $A Q2; REMARK =; NUMBER $A Q3
     IF Q2-7&7
        REMARK d ;
     ELSE
        REMARK d%
     EI
    EI
Q2      EQ      Q2+1
        ER
   ELSE
QQ	EQ	1
ll|Q1|SV        EQ      la|Q1|lb`0
    IF  .GE.(SEEGEN,3)
 NUMBER $A la|Q1|lb`0; REMARK d ;
    EI
   EI
Q1      EQ      Q1+1
        ER
  ELSE
ll`N    EQ      -1
  EI
]


        SEG     A.RTBL          :READ ONLY TABLE
SMV(HD,HOSTDE,HD,S,0FF)
SMV(HE,HOSTEC,HE,S,0FF)
Q1	EQ	0
	RE	QQ
	SBE(HC)			:SET UP EQUATES FOR BIT ARRAY
Q1	EQ	Q1+1
	ER
SMV(T27,T2741,T,T,00)
        KILL    SMV


::      SBV(LL,W0,W1,W2,W3,W4,W5,W6,W7)     SET BINARY VALUE ARRAY
:
:       SETS UP NSORDS 256 BIT ARRAYS.
:       EXPECTS LLXWY=32 VALUE X=(0,...,NSORDS-1), Y=(0,1,2,3,4,5,6,7)
:               LLN=LEVEL -1=NEVER DEFINED,0=GLOBAL,1=HST,2=SHST
:       IF LLXWY NOT DEFINED WY IS USED
:       IF LLN<1 ONLY 1 ENTRY IS MADE NOT NSORDS ENTRIES
:       BEGINNING OF AREA IS ASSIGNED LABEL ll`TBL.

SBV     MACRO(LL,P0,P1,P2,P3,P4,P5,P6,P7)[
 IF	LL`N+1
LL`TBL  WS
QQ      EQ      1
  IF    LL`N
QQ      EQ      NSORDS
  EI
Q1      EQ      0
        RE      QQ
	SBE(LL,P0,P1,P2,P3,P4,P5,P6,P7)
Q2      EQ      0
        RE      8
        WC      LL|Q1|W|Q2|
Q2      EQ      Q2+1
        ER
Q1      EQ      Q1+1
        ER
 EI
]


        SEG     A.RTBL          :READ ONLY TABLE
SBV(DE,240000,-1,-1,-4) :ECHOABLE CHARACTER TABLES (DEF=CR,LF,DISPLYABLES)
SBV(UD)
SBV(HX)
SBV(GB)
SBV(TF)
SBV(HF)
	KILL	SBV,SBE

:	SET UP COMBINED SPECIAL CHARACTER BIT ARRAYS 

:	A MACRO TO MAKE THINGS EASIER
ORINN	MACRO(TB,LL)[
  IF	\LL|Q1|W|Q2|
TB|Q1|W|Q2| EQ	TB|Q1|W|Q2|!LL|Q1|W|Q2|
  ELSE	\LL`0W|Q2|
TB|Q1|W|Q2| EQ	TB|Q1|W|Q2|!LL`0W|Q2|
  EI
]

  IF  GBN+TFN+UETMN+UDN+ESCN+TEONN+6      :IF SOME SPECIAL TO.HOST CHARS
   IF .LE.(GBN,0)&.LE.(UETMN,0)&.LE.(TFN,0)&.LE.(UDN,0)&.LE.(ESCN,0)&.LE.(TEONN,0)
IHN     EQ      0       :ALL ARE GLOBAL
QQ	EQ	1
   ELSE
IHN     EQ      1       :SOMETHING IS NOT GLOBAL
QQ	EQ	NSORDS
   EI
IHTBL	WS			:ISIS-TO-HOST SPECIAL CHAR TBL
Q1	EQ	0
	RE	QQ
Q2	EQ	0
	RE	8
IH|Q1|W|Q2| EQ	0
	ORINN(IH,GB)
	ORINN(IH,TF)
	ORINN(IH,UT)
	ORINN(IH,UD)
	ORINN(IH,ES)
	ORINN(IH,TC)
	WC	IH|Q1|W|Q2|
Q2	EQ	Q2+1
	ER
Q1	EQ	Q1+1
	ER
  EI

  IF  EOTCN+HETMN+RXONN+HEN+HFN+PFQN+HXN+7  :IF SOME SPECIAL FROM.HOST CHARS
QQ	EQ	.LE.(EOTCN,0)&.LE.(HETMN,0)&.LE.(RXONN,0)&.LE.(HEN,0)
QQ	EQ	QQ&.LE.(HFN,0)&.LE.(PFQN,0)&.LE.(HXN,0)
   IF QQ
HIN	EQ	0	:ALL ARE GLOBAL
QQ	EQ	1
   ELSE
HIN	EQ	1	:SOMETHING IS NOT GLOBAL
QQ	EQ	NSORDS
   EI
HITBL	WS			:HOST-TO-ISIS SPECIAL CHAR TBL
Q1	EQ	0
	RE	QQ
Q2	EQ	0
	RE	8
HI|Q1|W|Q2| EQ	0
	ORINN(HI,EO)
	ORINN(HI,HT)
	ORINN(HI,RX)
	ORINN(HI,HC)
	ORINN(HI,HF)
	ORINN(HI,PF)
	ORINN(HI,HX)
	WC	HI|Q1|W|Q2|
Q2	EQ	Q2+1
	ER
Q1	EQ	Q1+1
	ER
  EI
        KILL    ORINN


::      SET UP SUBHOST TERMINAL ID CHARACTER TABLE
:       THESE ARE THE CHARACTERS OR CHARACTER PAIRS THAT ARE SENT
:       TO THE HOST FOR NEW CIRCUITS.  A NULL CANNOT BE SENT.
:       THE CHARACTER VALUES ARE 8BITS. PARITY IS NOT CHECKED.
:
:       TLIY IS A CHARACTER PAIR VALUE L=(0,...,STICNT),
:               Y=(0,...,MAXTYP)
:       STIMAX IS THE MAX TLIY VALUE.  IF>0FF THERE ARE SOME
:               CHARACTER PAIRS, ELSE ALL VALUES ARE A SINGLE CHAR.
:       STIN IS THE MAX LEVEL DEFINED AT. -1=NEVER,0=GOLBAL,1=HHST,2=SHST
:       STISN IS A POINTER, L, TO A SET OF TLIY VALUES, N=(0,...,NSORDS-1)
:       IF STIN=-1, NOTHING WILL BE GENERATED
:       IF MAXHST=1 AND STIN=1, STIN WILL BE SET TO 0
:       AN ARRAY OF CHARACTERS WILL BE SET UP STARTING AT TI0SV.
:       THERE WILL BE ONE ENTRY PER TERMINAL TYPE.  EACH ENTRY
:       WILL BE 2 BYTES IF MAXCHAR>0FF, ELSE 1 BYTE
:       IF STIN=0 THERE WILL BE ONLY 1 SET OF MAXTYP VALUES (T0IY)
:       IF STIN>0 STIPTR IS THE START OF A POINTER TABLE INDEXED BY
:       SORD # WHICH CONTAINS HALFWORD POOINTERS RELATIVE TO TI0SV
:       FOR THE CHARACTER VALUES FOR THAT SORD.

  IF    STIN+1  :IF SOMETHING DEFINED
   IF   .EQ.(MAXHST,1)
   IF   .EQ.(STIN,1)
STIN    EQ      0               :HOST IS REALLY GLOBAL LEVEL
   EI
  EI
Q1      EQ      0
        HS
        RE      STICNT+1
TI|Q1|SV        BS
Q2      EQ      0
        RE      MAXTYP+1
   IF   \T|Q1|I|Q2|
Q3      EQ      T|Q1|I|Q2|
   ELSE
Q3      EQ      0
   EI
   IF   $0100-STIMAX
        BC      Q3
   ELSE
        HC      Q3
   EI
Q2      EQ      Q2+1
        ER
Q1      EQ      Q1+1
        ER
   IF   STIN    :IF>1 VALUE
TI|STICNT+1|SV EQ .+NSORDS*2
Q4      EQ      0
STIPTR  HS
Q1      EQ      0
        RE      NSORDS
    IF  \STIS|Q1|
Q2      EQ      STIS|Q1|
    ELSE
Q2      EQ      STICNT+1
Q4      EQ      1
    EI
        HC      TI|Q2|SV-TI0SV
Q1      EQ      Q1+1
        ER
    IF  Q4              :IF NECESSARY, DEFINE A NULL CHAR LIST
     IF $0100-STIMAX
        BS      MAXTYP+1
     ELSE
        HS              MAXTYP+1
     EI
    EI
   EI
  EI


::      SET UP BARNODES LIST
:
:       LIST STARTS AT BN0SV AND CONTAINS BARCNT+1 NODE LISTS
:       EACH TERMINATED BY A 0.  IF THE HIGH ORDER BIT IS SET
:       IN THE NODE NUMBER, THIS NODE LIST IS FOR OK NODES
:       ELSE IT IS FOR BARRED NODES.
:       IF BNN=0, THERE IS ONLY ONE LIST AND IT IS GLOBAL.
:       IF BNN>0 BNPTR IS A BYTE ARRAY INDEXED BY SORD # WHICH
:       POINTS INTO THE BARNODE LIST.

        SEG     A.RTBL          :READ ONLY TABLE
  IF    BARCNT+1        :IF AT LEAST 1 ENTRY
Q1      EQ      0
        RE      BARCNT+1
Q2      EQ      0
BN|Q1|SV        HS
        RE
   IF   \B|Q1|N|Q2|
        HC      B|Q1|N|Q2|
   ELSE
Q2      EQ      -1
BNNUL   HC      0
   EI
Q2      EQ      Q2+1
        ER      Q2
Q1      EQ      Q1+1
        ER

   IF   .GT.(BN|BARCNT|SV-BN0SV,1FE)
 REMARK >>>> ERROR **** TOO MANY NODES IN BARNODES LISTS ****
   ELSE
    IF  .EQ.(MAXHST,1)  :IF ONLY 1 HOST
     IF .EQ.(BNN,1)     :AND HIGHEST LEVEL WAS HOST
BNN     EQ      0       :HIGHEST LEVEL REALLY WAS GLOBAL
     EI
    EI
    IF  BNN     :IF NOT GLOBAL
Q1      EQ      0
BNPTR   BS
        RE      NSORDS
     IF \BARS|Q1|
Q2      EQ      BARS|Q1|
        BC      (BN|Q2|SV-BN0SV)/2
     ELSE
        BC      (BNNUL-BN0SV)/2
     EI
Q1      EQ      Q1+1
        ER
    EI
   EI   (>1FE)
  EI    (BARCNT+1)


::	SPECIAL TABLE FOR GTID

Q	EQ	0
 IF	\GTID|Q|
GPATBL	WS
	RE	3
	BC	GTID|Q|
Q	EQ	Q+1
	ER
 EI


	
::      TERMINAL TYPE TABLE. MATCHES BAUD RATE AND ID CHARACTER
:       TO LOCATE TERMINAL TYPE.

:       HC      ID|BR,0|TID,AB|CD,FLAGS

        SEG     A.RTBL          :READ ONLY TABLES

VID.ID  BC      0,0,01,0,0,0C,0,0,0,0,10,19    :CCT FOR CERTAIN SPEEDS

VIDT.L  EQ      8               :LENGTH OF TABLE ENTRY (BYTES)
MAXTYP  EQ      MAXTYP  :MAX BAUD SPEED INDEX DEFINED IN CONFIG PARAMETERS
VIDTT   HC      0102,00C1,0000,0017     :A  300
        HC      0302,00C2,4049,0017     :C  300
        HC      0502,00C3,4661,0017     :E  300
        HC      0702,00C4,35A0,0016     :G  300
        HC      0201,00C5,6020,0017     :B  150
        HC      0601,00C6,4049,0017     :F  150
        HC      0701,00C7,0000,0017     :J  150
        HC      0400,00CA,0000,001B     :D  110
        HC      0105,00CC,0000,0017     :A  1200
        HC      0905,00CC,1C86,0037     :I  1200
        HC      0705,00CC,3580,0036     :G  1200
        HC      010A,00D0,0000,0017     :A  2400
	HC	010B,00D3,0000,0017	:A  4800
	HC	010C,00D4,0000,0017	:A  9600
        HC      0005,00CE,0000,0000     :AUX1200 (GATEWAY)
        HC      0005,00C0,0000,0000     :AUX 1200
        HC      0005,00CB,0000,0000     :   (2780)
        HC      0005,00CD,0000,0000     :   (BORROUGHS POLLED)
        HC      0005,00D1,0000,0000     :   (3270)
	HC	0005,00D5,0000,0000	:   (MUX PVC)
	HC	0005,00D6,0000,0000	:   (AUDIO RESP)
VIDNA   EQ      .-VIDTT         :TYPES BELOW THIS ARE NON ASCII
        HC      0D07,00C9,0000,0000     :CR 133
        HC      0B07,00C9,0000,0000     :P  133
        HC      1907,00C9,0000,0000     :P  133
        HC      0D06,00C8,0000,0000     :CR 300
        HC      0B06,00C8,0000,0000     :P  300
        HC      1906,00C8,0000,0000     :P  300
        HC      000E,00CF,0000,0000     :   (BAUDOT)
	HC	0005,00D7,0000,0000	:   (VIDEOTEX)
        HC      0,0



::      PORT TERMINAL TYPE TABLES INDEXED BY SPEED INDEX FROM VIDTT (SEE)
:       AND BY PORT NUMBER.

        SEG     A.WTBL          :READ/WRITE TABLES

:       FIRST SET PORTS WITH NO DEFINED TYPES TO ALL TYPES
Q1      EQ      0
        RE      NHPORT
Q2      EQ      0
Q3      EQ      1
        RE      MAXTYP+1
  IF    \P|Q2|P|Q1|
Q3      EQ      0
  EI
Q2      EQ      Q2+1
        ER
  IF    Q3
Q2      EQ      0
        RE      MAXTYP+1
P|Q2|P|Q1|      EQ      1
Q2      EQ      Q2+1
        ER
  EI
Q1      EQ      Q1+1
        ER

:       NOW DEFINE TYPE TABLE
PTYPE   HS
Q0      EQ      0
        RE      MAXTYP+1
Q2      EQ      0
        RE      NHPGRP
Q3      EQ      0
Q4      EQ      0
        RE      10
  IF    \P|Q0|P|Q2|
Q3      EQ      Q3!(1^(0F-Q4))
  EI
Q2      EQ      Q2+1
Q4      EQ      Q4+1
        ER
        HC      Q3
        ER
Q0      EQ      Q0+1
        ER


::      PORT SPEED TABLES.
:       ONE BYTE PER ASYNC PORT.  VALUE IS ISIS BAUD RATE INDEX (0-7).
:       IF VALUE IS 0FF THEN USE TERMINALS SPEED FROM VIDTT.

        SEG     A.WTBL          :WRITABLE TABLE
PSPEED  HS
Q       EQ      0
        RE      NTPORT
  IF    \PSPD|Q|
        BC      PSPD|Q|
  ELSE
        BC      0FF
  EI
Q       EQ      Q+1
        ER


::      PORT CANDIDATE TYPE TABLE.
:       BIT ON FOR PORTS THAT MUST HAVE SIGNAL HIGH TO BE A CANDIDATE
:       FOR ASSIGNMENT(USUALLY DSR FROM HOST).

        SEG     A.DATA

Q       EQ      0
SIGCAN  HS
        RE      NHPGRP
  IF    \SCANG|Q|
        HC      SCANG|Q|
  ELSE
        HC      0
  EI
Q       EQ      Q+1
        ER


::	PORT SIGNAL TYPE TABLE.
:	BIT ON FOR PORTS THAT USE ACTUAL INPUT SIGNAL (DSR & CP)
:	FOR CALL ANSWER/TERMINATION.  BIT OFF TO SIMULATE SIGNAL HIGH.

Q	EQ	0
SIGANS	HS
	RE	NHPGRP
  IF	\SANSG|Q|
	HC	@SANSG|Q|
  ELSE
	HC	0FFFF
  EI
Q	EQ	Q+1
	ER

        SEG     A.CODE

:   POTENTIAL FILE TRANSFER PORTS
FTRAPT	HS
Q       EQ      0
	RE	NHPGRP
  IF	\FTPTG|Q|
	HC	FTPTG|Q|
  ELSE
	HC	0
  EI
Q	EQ	Q+1
	ER

        SEG     A.WTBL

:       THE CHAR WHICH SIGNALS TO START FILE TRANSFER BUILD CIRCUIT

FLTCHR	BS
Q       EQ      0
	RE	NTPORT
  IF	\FTCH|Q|
	BC	FTCH|Q|
  ELSE
	BC	0
  EI
Q	EQ	Q+1
	ER

:       THIS CHAR ACKNOWLEDGES THE START OF LOGON PROCESSING

FLTCHL	BS
Q       EQ      0
	RE	NTPORT
  IF	\FTCH|Q|
	BC	FTC1|Q|
  ELSE
	BC	0
  EI
Q	EQ	Q+1
	ER

:       THIS CHAR IS SENT UPON SUCCESSFULLY BUILDING A CIRCUIT.

FLTCHC	BS
Q       EQ      0
	RE	NTPORT
  IF	\FTCH|Q|
	BC	FTC2|Q|
  ELSE
	BC	0
  EI
Q	EQ	Q+1
	ER

:       THIS CHAR IS SENT WHEN A LOGON DOES NOT SUCCEED.

FLTCHF	BS
Q       EQ      0
	RE	NTPORT
  IF	\FTCH|Q|
	BC	FTC3|Q|
  ELSE
	BC	0
  EI
Q	EQ	Q+1
	ER


:       ACCOUNTING HOST NUMBER

ACHOST	HS
Q       EQ      0
	RE	NTPORT
  IF	\.ACH|Q|
	HC	.ACH|Q|
  ELSE
	HC	0
  EI
Q       EQ      Q+1
        ER


::      PORT TERMINAL CHARACTERISTICS TABLES

        SEG     A.DATA

ECHOP   HS      NHPGRP          :SET USING ECHO
ELFCRP  HS      NHPGRP          :SET USING ELFCR
ECRLFP  HS      NHPGRP          :SET USING ECRLF
ECTLIP  HS      NHPGRP          :SET USING ECTLI
ECTLHP  HS      NHPGRP          :SET USING ECTLH
CRDLYP  HS      NHPGRP          :SET USING CRDLY
HDUXP   HS      NHPGRP          :SET USING TID FROM NEEDLE
RXONP   HS      NHPGRP          :1 IF USING REVERSE BACKPRESSURE FEATURE
XONP    HS      NHPGRP          :1 IF USING XON FEATURE
PARCEP  HS      NHPGRP          :1 IF PARITY CHECK ENABLED
  IF    OP|PARC.|
PAREOP  HS      NHPGRP          :1= EVEN OR ODD, 0= MARK OR SPACE
PAREMP  HS      NHPGRP          :1= EVEN OR MARK, 0= ODD OR SPACE
  EI
TRANSP  HS      NHPGRP          :1 = ALL CHARACTERS ARE TRANSPARENT
  IF    ESCN+1
ESCFLG  HS      NHPGRP          :1 IF ESC SEEN
  EI
  IF    ESCN
ESCP    HS      NHPGRP          :1 IF ESC ENABLED
  EI
  IF	\GPATBL
G12WT	HS	NHPGRP		:1 IF WAITING FOR PARAMETER A RESPONSE
  EI
  IF	OP|E8BTM.|
E8BTMP	HS	NHPGRP		:I IF 8 BIT DATA MOD
  EI
CTSBPP	HS	NHPGRP		:1 IF CTS BP 
::      SUBHOST PORT ASSIGNMENTS

        SEG     A.WTBL          :READ/WRITE TABLES

HPTS    HS              :BITS ON IF PORT ASSIGNED TO A SUHOST
Q       EQ      0
  RE    NSORDS
QQ      EQ      0
S|Q|PTS
    RE  NHPGRP
  IF    \S|Q|GR|QQ|
        HC      S|Q|GR|QQ|
  ELSE
        HC      0
  EI
QQ      EQ      QQ+1
    ER
Q       EQ      Q+1
  ER


::	HNPNTB TABLE
:	HOST PORT ASSIGMENTS

HNPNTB	HS		:BIS ON IF PORT ASSIGNED TO A HOST
Q	EQ	0
  RE	MAXHST
QQ	EQ	0	
H|Q|PTS
    RE	NHPGRP
  IF	\H|Q|PT|QQ|
	HC	H|Q|PT|QQ|
  ELSE	
	HC	0
  EI
QQ	EQ	QQ+1
    ER
Q	EQ	Q+1
  ER



       SEG     A.DATA

TSATPT  HS              :BITS ON IF PORT ACTS LIKE TYMSAT PORT
Q       EQ      0
  RE    NTPGRP
QQ      EQ      0
  IF    \S|TOM|GR|Q|
QQ      EQ      QQ!S|TOM|GR|Q|
  EI
        HC      QQ
Q       EQ      Q+1
  ER
  RE    NHPGRP-NTPGRP
        HC      0
  ER

	SEG	A.CODE
REAL    HS                      :BITS ON IF PORT REALLY EXISTS
  IF	NAPGRP
   RE	NAPGRP
	HC	-1		:  ASYNC PORT GROUPS
   ER
  EI
  IF	NMPORT
   IF   NMPORT/10
    RE  NMPORT/10
        HC      -1              :  FULL SIO PORT GROUPS
    ER
   EI
   IF	NMPORT&0F
Q       EQ      0F
QQ      EQ      0
    RE  NMPORT&0F
QQ      EQ      QQ!(1^Q)
Q       EQ      Q-1
    ER
        HC      QQ              :  LAST SIO PORT GROUP
   EI
  EI
        HC      S|TOM|GR|NHPGRP-1|  :TOM PORT GROUP

  IF	NMPORT
SIOP	HS			:BITS ON IF SIO PORT
   IF	NAPGRP
    RE	NAPGRP
	HC	0		:  ASYNC PORT GROUPS
    ER
   EI
   IF	NMPORT/10
    RE	NMPORT/10
	HC	-1		:  FULL SIO PORT GROUPS
    ER
   EI
   IF	NMPORT&0F
	HC	QQ		:  LAST SIO PORT GROUP
   EI
	HC	0		:  TOM PORT GROUP
  EI


::      THE FLGS.L BYTE AREA STARTING AT FLAGS IS INITIALIZED TO ZERO
:       AT STARTUP.

        SEG     A.DATA

        GL      FLAGS
	WS	0
FLAGS   HS      1
APORTS  HS      1               :CURRENT NUMBER OF ACTIVE PORTS
CLKSAV	WS	NHPORT		::2.06 - CAB - CLOCK FOR TOM STATUS
HNPA    HS      (MAXHST+0F)/10  :1 IF NO PORTS AVAILABLE REPORTED TO SUPE
HAPD    HS      (MAXHST+0F)/10  :1 IF ALL PORTS DOWN REPORTED TO SUPE
FRISIS  HS      NIPGRP          :1 IF FIT CAN ACCEPT CHARS FROM ISIS
TOISIS  HS      NIPGRP          :1 IF ISIS CAN ACCEPT CHARS FROM FIT
PIBUF	HS	NIPGRP		:1 IF DATA TO ISIS IS BEING BUFFERED
TOISON	HS	NIPGRP		:1 IF READY TO SEND DATA TO ISIS
TOFIT   HS      NHPGRP          :BITS ON WHEN DATA FROM PORT TO FIT
TOPORT  HS      NHPGRP          :BITS ON WHEN CHRS FROM FIT TO PORT
TOPTON  HS      NHPGRP          :1 IF PORT SHOULD LOOK AT CHARS FROM FIT
CTSBPF	HS	NHPGRP		:1 IF LAST CTS BP WAS  RELEASE HOST BP
XONON   HS      NHPGRP          :1 IF LAST XON/OFF CHR WAS XON
RXONON  HS      NHPGRP          :1 IF LAST RXON/OFF WAS XON
DEM     HS      NHPGRP          :1 IF TRYING TO GET OUT OF DEFERRED ECHO MODE
RING    HS      NHPGRP          :1 IF SHOULD RING HOST
RNGTGL  HS      NHPGRP          :1 IF RING CURRENTLY HIGH
RNGCUP  HS      NHPGRP          :1 IF RING TO STAY UP UNTIL CIRCUIT ZAPPED
RNGTGP  HS      NHPGRP          :1 IF RING SHOULD TOGGLE
RNGDRP  HS      NHPGRP          :1 IF RING SHOULD DROP WHEN ANSWERED
WATHST  HS      NHPGRP          :1 IF WAITING FOR HOST TO ANSWER RING
DFDAT   HS      NHPGRP		:ASYNC INPUT DATA FLAG
FDDAT   HS      NHPGRP		:ASYNC OUTPUT DATA FLAG
OFDDT   HS      NHPGRP          :SAVED FDDAT BIT (FOR REVERSE XON)
CAN     HS      NHPGRP          :1 IF CANDIDATE FOR LOGIN ASSIGNMENT 
ACP     HS      NHPGRP          :1 IF ACTIVE PORT...RECEIVER LINE IS ACTIVE
RLA     HS      NTPGRP          :0 IF RECEIVER LINE ACTIVE SEE HANGAN
GBRCVD  HS      NHPGRP          :1 IF RCVD GREEN BALLL FROM TSAT
SNDGB   HS      NHPGRP          :1 IF TIME TO SEND GREENBALL TO TSAT
GBSEC   HS      NHPGRP          :1 IF >1/2 SEC SINCE GBRCVD
TDROP	HS	NTPGRP		:1 IF TOM IS DROPPING PORT
  IF	PFQN+1			:IF POLLED BACKPRESSURE
PFQP	HS	NHPGRP		:1 IF USING POLLED BACKPRESSURE
POLACK	HS	NHPGRP		:1 IF WAITING TO SEND ACK
  EI
  IF    EOTCN+1			:IF HOST CONTROLING GREENBALLS
HOSTGB  HS      NHPGRP          :0 IF HOST RESPONSIBLE FOR GREENBALLS
  EI
  IF    INAN+1
INACT   BS      NHPORT          :# OF MIN SINCE LAST CHAR PASSED EITHER WAY
BRKACT  BS      NHPORT          ::2.06 - CAB - # OF CONSECUTIVE BREAKS 
  EI
  IF	NAPORT
DTRWT   HS      NTPGRP          :1 TO CHANGE DTR WHEN DRIVER BUFFER EMPTY
NDTR	HS	NTPGRP		:VALUE TO CHANGE DTR TO (SEE DTRWT)
  EI
  IF	NMPORT
PTGONE	HS	NTPGRP		:1 IF DAUGHTER BD GONE
  EI

  IF OP|E8BTM.|
	GL	IP8BM,HP8BM
IP8BM	HS	NIPGRP		:1 IF THIS ISIS PORT IN 8 BIT DATA MODE
HP8BM	HS	NHPGRP		:1 IF THIS HOST PORT IN 8 BIT DATA MODE
ETMFLG	HS	NIPGRP		:1 IF ENTER TRANSPARENCY MODE

  EI

ESPSFG	HS	NHPGRP		:1 IF PASS ESC CHAR TO ORING    
SPCHFG	HS	NHPGRP		:1 IF THIS CHAR IS SPECIAL CHAR	
	HS      0               :HALFWORD BOUNDARY
FLGS.L  EQ      .-FLAGS         :LENGTH OF FLAGS AREA

FPANEL  HC      0FEED           :FRONT PANEL DISPLAY


:       SET UP PATCH AREAS
:       DEFAULT IS 40 BYTES DEFINED IN FINISH.LIB IF PATSZn NOT DEFINED.

  IF    \PATSZ0
        GL      PATCH0
        SEG     0
PATCH0  HS      PATSZ0/2
  EI
  IF    \PATSZ1
        GL      PATCH1
        SEG     1
PATCH1  HS      PATSZ1/2
  EI
	SUBTTL	ASYNC TYMCOM MESSAGE TEXTS

:	LOGIN AND PORT MESSAGES

	SEG	A.RTBL		:READ ONLY
LSMS0	SC	/"8D"8Aplease type your terminal identifier/

NTMMS	BS
  IF	\NTMM
  ELSE
	SC	/"8D"8ANO TERMINAL TYPE MATCH/
  EI
		
NPAMS	BS
  IF	\NPAM
  ELSE
	SC	/"8D"8ANO PORTS AVAILABLE/
  EI

APDMS	BS
  IF	\APDM
  ELSE
	SC	/"8D"8AALL PORTS DOWN/
  EI

:	RING NO ANSWER
	SEG	A.DATA

RGNAMS	HS
  IF	\RNAM
   IF	.LE.(.-RGNAMS,1)	:IF MSG SUPPRESSED
RNAP	EQ	0
   ELSE
    IF	1-RNAP
RNAP	EQ	.-RGNAMS
	AC	/NNN/
    EI
   EI
  ELSE
	SC	/"8D"8ARING NO ANSWER ON PORT NNN/
RNAP	EQ	.-RGNAMS-3
  EI

:	PORT NUMBER MESSAGE
	SEG	A.DATA
SPTMS	HS
  IF	\PNM
   IF	.LE.(.-SPTMS,1)
PNP	EQ	0
   ELSE
    IF	1-PNP
PNP	EQ	.-SPTMS
	AC	/NNN/
    EI
   EI
  ELSE
	SC	/PNNN"8D"8A/
PNP	EQ	2
  EI

:	SUBHOST GREETING MESSAGES (1 WORD EACH)
	SEG	A.RTBL	:READ ONLY TABLE
HGRT	WS
Q1	EQ	0
	RE	NSORDS
	HGRT|Q1|
	KILL	HGRT|Q1|
Q1	EQ	Q1+1
	ER

	SEG	A.DATA

  IF	1-(\GRTP)
GRTP	EQ	1
  EI

	BS	(.&1)%(GRTP&1)	GET HOST NAME ON HALFWORD
HGRTMS	BS
  IF	\GRTM
   IF	.LE.(.-HGRTMS,1)
GRTP	EQ	-1
   EI
   IF   1-GRTP
        BS      (.&1)%1
TGRTMS  SC      /XXXX IS ON LINE"8D"8A/
   EI
  ELSE
	SC	/XXXX IS ON LINE"8D"8A/
  EI


	SEG	A.RTBL		:READ ONLY
ILUNMS	BS
  IF	\IUNM
  ELSE
	SC	/"8D"8AUSERNAME INVALID, DISCONNECTING/
  EI

ANPMS	BS
  IF	\ANPM
  ELSE
	SC	/"8D"8AACCESS FROM THIS NODE IS NOT PERMITTED/
  EI

  IF	INAN+1
INAMSG	BS
   IF	\INAM
   ELSE
	SC	/"8D"8ADROPPED FOR INACTIVITY/
   EI
  EI

DBHMSG	BS
  IF	\DBHM
  ELSE
	SC	/"8D"8ADROPPED BY HOST/
  EI

NHAMSG	BS
  IF	\NHAM
  ELSE
	SC	/HOST DID NOT ACKNOWLEDGE USER DISCONNECT"8D"8A/
  EI

        SEG     A.RTBL

LSMS1	BS
	IF	\LSMG01
	ELSE
	SC	/Please log in/
	EI

LSMS2	BS
	IF	\LSMG02
	ELSE
	SC	/error"AC type username/
	EI

LSMS3	BS
	IF	\LSMG03
	ELSE
	SC	/error"AC type password/
	EI

LSMS4	BS
	IF	\LSMG04
	ELSE
	SC	/username/
	EI

LSMS5	BS
	IF	\LSMG05
	ELSE
	SC	/password/
	EI

LSMS8	BS
	IF	\LSMG08
	ELSE
	SC	/please see your rep"AE"AE"AE/
	EI

LSMS9	BS
	IF	\LSMG09
	ELSE
	SC	/bad mud/
	EI

LSMS10	BS
	IF	\LSMG10
	ELSE
	SC	/circuits busy/
	EI

LSMS11	BS
	IF	\LSMG11
	ELSE
	SC	/host not available/
	EI

LSMS12	BS
	IF	\LSMG12
	ELSE
	SC	/host out of ports/
	EI

LSMS13	BS
	IF	\LSMG13
	ELSE
	SC	/host down/
	EI

LSMS14	BS
	IF	\LSMG14
	ELSE
	SC	/host shut/
	EI

LSMS15	BS
	IF	\LSMG15
	ELSE
	SC	/try again in 2 minutes/
	EI

LSMS16	BS
	IF	\LSMG16
	ELSE
	SC	/access not permitted/
	EI

LSMS17	BS
	IF	\LSMG17
	ELSE
	SC	/no host specified/
	EI

LSMS18	BS
	IF	\LSMG18
	ELSE
	SC	/bad host number/
	EI

LSMS19
	IF	\LSMG19
	ELSE
	SC	/mud error/
	EI

        SEG     A.CODE

LSMSTA  HC      0       :text msgs from msg B4 (logon status)  *sdw.300
Q       EQ      1
        RE      5
        HC      LSMS|Q|-SEG4
Q       EQ      Q+1
        ER
        HC      0,0,LSMS8-SEG4,LSMS9-SEG4 :6,7 not yet defined
Q       EQ      10
        RE      $A 10   :extended login status is 10-19 (8,9 done above)
        HC      LSMS|Q|-SEG4
Q       EQ      Q+1
        ER

        SEG     A.RTBL

LFMS0	BS
	IF	\LFMG0
	ELSE
	SC	/ISIS unable to complete request/
	EI

LFMS1	BS
	IF	\LFMG1
	ELSE
	SC	/format error/
	EI

LFMS2	BS
	IF	\LFMG2
	ELSE
	SC	/bad user name/
	EI

LFMS3	BS
	IF	\LFMG3
	ELSE
	SC	/bad mud/
	EI

LFMS4	BS
	IF	\LFMG4
	ELSE
	SC	/system unavailable/
	EI

LFMS5	BS
	IF	\LFMG5
	ELSE
	SC	/down-line load or dial-out failure/
	EI

LFMS6	BS
	IF	\LFMG6
	ELSE
	SC	/timeout/
	EI

LFMS7	BS
	IF	\LFMG7
	ELSE
	SC	/access not permitted/
	EI

LFMS8	BS
	IF	\LFMG8
	ELSE
	SC	/out of origination ports/
	EI

LFMS9	BS
	IF	\LFMG9
	ELSE
	SC	/try again later/
	EI

LFMS10	BS
	IF	\LFMG10
	ELSE
	SC	/bad requesting"ADhost number/
	EI

LFMS11	BS
	IF	\LFMG11
	ELSE
	SC	/requesting host not up on requesting node/
	EI

        SEG     A.CODE


LFMSTA  HS
Q       EQ      0
        RE      $A 10
        HC      LFMS|Q|-SEG4
Q       EQ      Q+1
        ER
        HC      LFMS10-SEG4,LFMS11-SEG4

        SEG     A.DATA

  IF	1-(\HDNP)
HDNP	EQ	3
  EI

	BS	(.&1)%(HDNP&1)	:GET HOST NAME ON WORD BOUNDRY
HDNMS	BS
  IF	\HDNM
   IF	1-HDNP
HDNP	EQ	.-HDNMS
	AC	/XXXX/
   EI
  ELSE
	SC	/"8D"8AXXXX IS DOWN/
  EI

  IF	1-(\HSHP)
HSHP	EQ	3
  EI

	BS	(.&1)%(HSHP&1)	:	GET NAME ON WORD BOUNDRY
HSHMS	BS

  IF	\HSHM
   IF	1-HSHP
HSHP	EQ	.-HSHMS
	AC	/XXXX/
   EI
  ELSE
	SC	/"8D"8AXXXX IS SHUT/
  EI
HOSTIS	EQ	0C8CFD3D4	:"HOST"

:	OPERATOR MESSAGES FOR SUBHOST DOWN/SHUT

HOPM.L	EQ	$A 800		:LENGTH OF OPERATOR MSG AREA

	SEG	A.DATA
HOPMSP	HS	NSORDS		:OPERATOR MSG PTRS
	SEG	A.WTBL		:WRITABLE TABLE AREA
HOPMS	HC	2		:NEXT AVAILABLE BYTE FOR MESSAGE
	BS	HOPM.L		:OPERATOR MESSAGE AREA


	SEG	A.RTBL		:READ ONLY
LOFFMS	BS
  IF	\LOFFM
  ELSE
	SC	/DISCONNECTING/		:log off message
  EI


BZFTMS	BS
  IF	\BZFTM
  ELSE
	SC	/"07"07 DATA LOST FROM TERMINAL /
  EI
BZFTP	EQ	.-BZFTMS

BZTTMS	BS
  IF	\BZTTM
  ELSE
	SC	/"07"07 DATA LOST TOWARD TERMINAL /
  EI
BZTTP	EQ	.-BZTTMS

::	DEFINE ABNORMAL DISCONNECT MESSAGE (USER DISCONNECT)
  IF	ABNDN+1	:IF MSG DEFINED
ABNDM	BS
   IF	ABNDN	:IF > 1 ENTRY
Q1	EQ	0
	RE	NSORDS
ABNM|Q1|	BS
    IF	\ABND|Q1|
	KILL	ABND|Q1|
    ELSE
	BC	0
    EI
Q1	EQ	Q1+1
	ER
ABNPTR	HS
Q1	EQ	0
	RE	NSORDS
	HC	ABNM|Q1|-SEG4
Q1	EQ	Q1+1
	ER
   ELSE
    IF	\ABND0	:EXPAND THE MACRO
    EI
   EI
  EI	(ABNDN+1)


::	DEFINE LOGIN STRING (USER CONNECT)
  IF	LGSN+1	:IF MSG DEFINED
LGSM	BS
   IF	LGSN	:IF > 1 ENTRY
Q1	EQ	0
	RE	NSORDS
LGSM|Q1|	BS
    IF	\LGS|Q1|
	KILL	LGS|Q1|
    ELSE
	BC	0
    EI
Q1	EQ	Q1+1
	ER
LGSPTR	HS
Q1	EQ	0
	RE	NSORDS
	HC	LGSM|Q1|-SEG4
Q1	EQ	Q1+1
	ER
   ELSE
    IF	\LGS0	:EXPAND THE MACRO
    EI
   EI
  EI	(LGSN+1)


::	DEFINE TERMINAL INIT. STRING (USER CONNECT)
  IF	TINTN+1	:IF MSG DEFINED
TINM	BS
   IF	TINTN	:IF > 1 ENTRY
Q1	EQ	0
	RE	NSORDS
TINM|Q1|	BS
    IF	\TINT|Q1|
	KILL	TINT|Q1|
      IF  .LE.(.-TINM,1)
	BC	0
      EI 	
    ELSE
	BC	0
    EI
Q1	EQ	Q1+1
	ER
TINPTR	HS
Q1	EQ	0
	RE	NSORDS
	HC	TINM|Q1|-SEG4
Q1	EQ	Q1+1
	ER
   ELSE
    IF	\TINT0	:EXPAND THE MACRO
      IF   .LE.(.-TINM,1)
        BC	0
      EI 
    EI
   EI
  EI	(TINTN+1)

::      DEFINE SUBHOST GREETING MESSAGE
  IF    SGRTN+1
SGRM    BS
   IF   SGRTN
Q1      EQ      0
        RE      NSORDS
SGRM|Q1|        BS
    IF \SGRT|Q1|
        KILL    SGRT|Q1|
      IF  .LE.(.-SGRM,1)
        BC      0
      EI
    ELSE
        BC      0
    EI
Q1      EQ      Q1+1
        ER

GRTPTR  HS
Q1      EQ      0
        RE      NSORDS
        HC      SGRM|Q1|-SEG4
Q1      EQ      Q1+1
        ER
   ELSE
    IF  \SGRT0
      IF   .LE.(.-SGRM,1)
        BC      0
      EI
    EI
   EI
  EI    (SGRTN+1)


::	DEFINE TERMINAL BYE STRING (USER DISCONNECT)
  IF	TBYEN+1	:IF MSG DEFINED
TBYM	BS
   IF	TBYEN	:IF > 1 ENTRY
Q1	EQ	0
	RE	NSORDS
TBYM|Q1|	BS
    IF	\TBYE|Q1|
	KILL	TBYE|Q1|
      IF  .LE.(.-TBYM,1)
	BC	0
      EI 	
    ELSE
	BC	0
    EI
Q1	EQ	Q1+1
	ER
TBYPTR	HS
Q1	EQ	0
	RE	NSORDS
	HC	TBYM|Q1|-SEG4
Q1	EQ	Q1+1
	ER
   ELSE
    IF	\TBYE0	:EXPAND THE MACRO
      IF   .LE.(.-TBYM,1)
        BC	0
      EI 
    EI
   EI
  EI	(TBYEN+1)


SLIXMS  BC      6,80,80,80,93,80,81     :SC str of dialects

	KILL	NPAM,PNM,IUNM,NHAM,HDNM,HSHM,LOFFM,GRTM,INAM,RNAM,APDM
	SUBTTL	ACLIB1.206 - ASYNC TYMCOM LIBRARY 1
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by  TYMNET, Incorporated.                                   **
: ******************************************************************
: **                   MODULE IDENTIFICATION                      **
: **                                                              **
: **  File Name          :  ACLIB1.206      last change: 05/27/86 **
: **			    					  **
: **  File Abstract      :  ACLIB1.206 includes 5 basic           **
: **			    ISIS libraries --			  **
: **								  **
: **			    START.LIB - Original ISIS Version 2   **
: **								  **
: **			    FRING.LIB - Modified in Tymcom	  **
: **					    version 2.06          **
: **								  **
: **			    CRASH.LIB - Original ISIS version 2	  **
: **								  **
: **			    BUFFER.LIB - Original ISIS version 2  **
: **								  **
: ** 			    TIMOUT.LIB - Original ISIS version 2  **
: **								  **
: **								  **
: **  File Description :  START.LIB -                             **
: **			    ISIS assembly switch definitions.     **
: **			    define seg 15d locations,		  **
: **			    define registers, area definitions,   **
: **			    define sys SVC suboperands,           **
: **			    define I/O suboperands,               **
: **			    define start of segments.             **
: **                                                              **
: **			  FRING.LIB --                            **
: **			    ISIS ring handling routines.          **
: **			    Fast and efficient ISIS input         **
: **			    and output ring handler.              **
: **								  **
: **			  CRASH.LIB --                            **
: **			    ISIS startup and crash library.       **
: **			    This package handle both hardware     **
: **			    and software crashes.                 **
: **								  **
: **			  BUFFER.LIB --				  **
: **			    GCI/WCI package.                      **
: **			    This package contains all code and    **
: **			    storage allocation needed for         **
: **			    bufferlet usage.                      **
: **								  **
: **			  TIMOUT.LIB --				  **
: **                        Standard timeout routine library      **
: **								  **
: ******************************************************************
: **                    CHANGE LOG                                **
: **                                                              **
: **  Ver   Date     By   PIR/NSR  Changes (most recent at top)   **
: ** ----- -------- ----  -------- ------------------------------ **
: ** 2.06  05/27/86 CAB            Added PRODID to buffer zap rpt **
: **								  **
: **2.06 12/18/85  OJ  		  Add proprietary banner	  **
: **								  **
: ** "     "      "	  PIR1823 Tymcom msg Masking 		  **
: **				    				  **   
: **				    Tymcom should mask any data   **
: **				    msgs originated within the    **
: **				    Tymcom to space parity ( 0    **
: **				    top bit) for ports in 8 bit   **
: **				    transparency mode. It has     **
: **				    made change in FRING.LIB      **
: **								  **
: ******************************************************************

	SUBTTL	ISIS ASSEMBLY SWITCH DEFINITIONS	-- START.LIB
	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	05;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
	SUBTTL	ISIS Ring Handling Routines	- FRING.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCSS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

OCSTMP	HC	0


:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4	:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	STH	R2,OCSTMP,,	:SAVE PORT NUMBER
	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS10		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	STH	R2,OCSTMP,,	:SAVE PORT NUMBER	
	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS10	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
  IF OP|E8BTM.|
	LHL	R4,OCSTMP,,	:GET PORT NUMBER
	TBT	R4,IP8BM,,	:8 BIT DATA MODE ?
				:MASK DATA MESSAGES TO SPACE PARITY(0 TOP BIT)
	JEFS	OCS20		:IF NOT
	NHI	R0,007F	
  EI
OCS20	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS10		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	WS	1		:WHERE CRASH OCCURED
CFROM	WS	1		:WHERE CRASH WAS CALLED FROM
CRREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF          :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
  IF	NCRSAV-1
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
  EI
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF          :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
  IF	NCRSAV-1
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
  EI
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRREG,R2 :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
        LM      R0,CRAT+CRREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN

  IF	NCRSAV-1
PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1      :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1
        LM      R6,CRAT+CRTLEN/2,R1
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
  EI         
	EM
	SUBTTL	GCI/WCI Buffer Package
:************************************************************************
:
:	This program is the sole property and confidential
:	information of TYMSHARE, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of TYMSHARE.
:
:************************************************************************
	RA	0		:	BUFFER.LIB

:	This package contains all code and storage allocation needed for
:	bufferlet usage.
:	If the symbol BUFTRC is defined and has a value greater than 0,
:	then a trace of all GCI and WCI calls will be included and
:	HISX will be a halfword pointer into a table HISTAB.
:	HISTAB will contain 100 one word entries.  Each entry contains
:	a one byte character, one byte of buffer number, and a halfword
:	address of the caller of GCI/WCI.  The table is circular.

:	the following parameters MUST be defined before assembly:
:	NBUF	the number of buffers to create
:	NBFLET	the number of bufferlets to create
:
:	THE FOLLOWING SYMBOL MAY BE DEFINED. IF IT IS NOT THE DEFAULT
:	IS FALSE.
:	UABUFF	IF TRUE (>1) THEN THE USER WILL ALLOCATE THE BUFFERLET
:		POOL BUFER.

:	uses routines in TIMOUT.LIB - - - requires one timeout list entry

:	may JAL R10,CRASH on certain conditions

:	Each routine is called with:
:	Link on R4
:	R0 = argument
:	R1 = buffer index (buffer number*2)

:	routines:
:	IZBF	link on R5, used to initialize buffers
:	GCI	get a character from buffer
:	WCI	write a character into buffer
:	WCD	back up a buffer to restore last character
:	EMPTY	empty (flush) buffer

:	buffer index may be used to index into the following halfword arrays
:	from external routines:
:	BF	buffer flags
:	BB	buffer start address
:	BE	buffer end address
:	BCT	buffer counts

:	the following should also be defined externally:
:	FLAGS	a bit array of length corresponding to max buffer flag value
:
:	If the macro ZAPBUF is defined then the code in the macro will
:	be executed whenever CKBZ is forced to zap a buffer. The code
:	will be executed immediately following the call to EMPTY
:	(R1 will contain the buffer index).  The first line of the macro
:	must be "ZAPBUF MACRO [.X" (where X may be a carriage return
:	or semicolon).


	GL	NBUF,NBFLET,BUFTRC,UABUFF
  IF	\BUFTRC
  ELSE
BUFTRC	EQ	0
	REMARK	%*** Define BUFTRC EQ 1 if debug trace desired
  EI

 IF	\UABUFF
 ELSE
UABUFF	EQ	0	:BUFFERLET POOL IS NOT USER ALLOCATED
 EI

	MO	.,BUFFER
	GL	FASTC,TORET,TOPUT,RATE,FLAGS,CRASH
	GL	BF,BCT,BB,BE
	GL	IZBF,GCI,WCI,WCD,EMPTY,GCPEEK,GCSCAN,MCI

:	THE DATA FOR THESE ROUTINES
	SEG	A.DATA		:PLACE IN DATA AREA
REBL	HC	0		:FREE LIST POINTER FOR RESERVE STORAGE LIST
REBC1	HC	0		:COUNTS TIMES BUFFER STORAGE WAS MOVED TO MAIN FREE LIST
REBC2	HC	0		:COUNTS TOTAL NUMBER OF BUFFER ZAPS
BFZ	HC	-1		:LAST BUFFER ZAPPED

BF	HS	NBUF		:BUFFER FLAGS
BCT	HS	NBUF		:BUFFER COUNTS
BB	HS	NBUF		:BUFFER START ADDRESS
BE	HS	NBUF		:BUFFER END ADDRESS

  IF	BUFTRC
	GL	HISX,HISTAB
HISX	HC	0		:INDEX FOR HISTORY
HISTAB	HS	200		:HISTORY DATA...400 BYTES...100 HISTORY ENTRIES
  EI



:	CODE SECTION
	SEG	A.CODE		:PLACE IN CODE ARAEA

:	INITIALIZE BUFFERS
IZBF	LIS	R0,0		:SET A CONSTANT
	LHI	R1,NBUF*2-2	:FOR ALL BUFFERS
IZBF1	STH	R0,BCT,R1	:SET EMPTY
	LHL	R2,BF,R1
	RBT	R2,FLAGS	:TURN OFF FLAG BIT
	SIS	R1,2
	JGEBS	IZBF1
	LI	R1,NBFLET*8	:FOR ALL BUFERLETS
	STH	R0,BUFERS,R1,	:TERMINATE LIST
IZBF2	STH	R1,BUFERS-8,R1,	:LINK LAST TO THIS
	STH	R0,BUFERS-6,R1,	:CLEAR DATA AREA
	ST	R0,BUFERS-4,R1,
	SIS	R1,8
	JGBS	IZBF2		:REPEAT FOR ALL BUFFERLETS
	STH	R0,REBL		:SET SPARE TANK EMPTY
	L	R1,FASTC,,
	LHI	R1,RATE/$A25,R1	:CALL EVERY 40 MS.
	LA	R0,CKBZ		:PUT BUFFER CHECKING LOGIN ON QUEUE
	J	TOPUT		:EXIT VIA TIMEOUT LIST ENTRY
:	CHARACTER HANDLERS. THESE ROUTINES PASS BFR CHR IN R0,
:	R1 FOR TWICE THE BUFFER NUMBER, R2,R3 FOR WORKING REGISTERS,
:	R4 IS LINK REGISTER.

:	GET CHAR FROM BUFFER AND INCREMENT FORWARD THRU THE BUFFER.
GCICRA	JAL	R10,CRASH;	BC	0,0,4*R4,3	:FLAG--LINK R4, TYPE 3
GCI	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JGEBS	GCICRA		:BUFFER NUMBER OUT OF RANGE...CRASH
	LHL	R2,BB,R1	:GOOD BUFFER...GET INDEX TO CHARACTER
	LB	R0,BUFERS,R2,	:PICK UP CHAR
	LHL	R3,BCT,R1	:GET CHARACTER COUNT
	SIS	R3,1		:SUBTRACT CHARACTER GOTTEN
	STH	R3,BCT,R1	:REPLACE IT (DOES NOT CHANGE CONDITION)
	JLE	GCILAS		:SKIP IF NO CHARACTERS LEFT
	AIS	R2,1		:ELSE INCREMENT BB VALUE
	THI	R2,7		:TEST IF AT END OF BUFFERLET
	JEFS	GCI1		:RETURN BUFFERLET TO FREE LIST IF SO
	STH	R2,BB,R1	:ELSE UPDATE BB
  IF	BUFTRC
	J	HIST		:AND RETURN WITH THE CHAR
  ELSE
	JR	R4		:AND RETURN WITH THE CHAR
  EI

GCI1	LHL	R3,BUFERS,R2,	:BUFFERLET EXHAUSTED
	SIS	R3,6		:CHAIN TO NEXT BUFFERLET
	STH	R3,BB,R1	:SET BB TO START OF NEXT BUFFERLET
	LHL	R3,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R3,BUFERS,R2,	:LINK LAST BUFFERLET TO FREE LIST
	STH	R2,BUFERS,,	:AND PUT AT THE HEAD OF THE FREE LIST
  IF	BUFTRC
	J	HIST		:THEN EXIT
  ELSE
	JR	R4		:THEN EXIT
  EI

GCILAS	JL	GCICRA		:CRASH IF BUFFER WAS EMPTY
	LHL	R3,BF,R1	:OK...GET POINTER TO FLAG BIT
	RBT	R3,FLAGS	:RESET ATTENTION FLAG
	AIS	R2,6		:BUMP CHARACTER POINTER PAST END OF BUFFERLET
	NHI	R2,-8		:MAKE CHAIN A MULTIPLE OF 8
	LHL	R3,BUFERS,,
	STH	R3,BUFERS,R2,
	STH	R2,BUFERS,,	:UPDATE FREE LIST
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

:	PUT A CHARACTER INTO THE BUFFER
WCI	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JLFS	WCI1		:SKIP IF OK
WCICRA	JAL	R10,CRASH	:ELSE CRASH
	BC	0,0,4*R4,5	:FLAG--LINK R4, TYPE 5 CRASH

WCI1	LHL	R2,BCT,R1	:CHECK COUNT
	JE	WCIFRS		:IF NEW BUFFER, SET UP ATTENTION FLAGS
	AIS	R2,1		:ELSE UPDATE COUNT
	STH	R2,BCT,R1
	LHL	R2,BE,R1	:GET POINTER TO LAST CHARACTER POSITION
	AIS	R2,1		:BUMP POINTER
	THI	R2,7		:TEST IF BUFFERLET FULL
	JEFS	WCINXB		:END OF BUFFERLET
	STH	R2,BE,R1	:ELSE UPDATE BE
	STB	R0,BUFERS,R2,	:AND SAVE CHAR IN BUFFER
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCINXB	LHL	R3,BUFERS,,	:NEED A NEW BUFFERLET
	JNFS	WCINXC		:SKIP IF THERE IS ANOTHER
	JAL	R2,WRE		:(OPEN THE RESERVE TANK)
	LHL	R2,BE,R1	:RESTORE R2
	AIS	R2,1
WCINXC	STH	R3,BUFERS,R2,	:LINK NEW BUFFERLET TO LAST ONE
	LHL	R2,BUFERS,R3,	:AND REMOVE FROM FREE LIST
	STH	R2,BUFERS,,
	SIS	R3,6		:BACK UP NEW BUFFERLET
	STH	R3,BE,R1	:SAVE AS NEW BE
	STB	R0,BUFERS,R3,	:PUT THE CHARACTER THERE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCIFRS	LH	R2,BF,R1	:THE BUFFER WAS EMPTY
  IF	BUFTRC
	JE	HIST		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  ELSE
	JER	R4		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  EI
	SBT	R2,FLAGS	:ATTENTION BIT ON TO ALERT SOME PROCESS OF DATA WAITING
	LIS	R2,1
	STH	R2,BCT,R1	:SET COUNT = 1
	LHL	R3,BUFERS,,	:POP A BUFFERLET OFF FREE LIST
	JGFS	.+6		:SKIP IF THERE WAS ONE
	JAL	R2,WRE		:ELSE OPEN THE RESERVE TANK
	LHL	R2,BUFERS,R3,
	STH	R2,BUFERS,,	:UPDATE FREE LIST
	SIS	R3,6		:POINT IT AT FIRST CHARACTER
	STH	R3,BB,R1	:SET UP BB
	STH	R3,BE,R1	:AND BE
	STB	R0,BUFERS,R3,	:PUT THE CHARACTER THERE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

:	MOVE RESERVE STORAGE SUPPLY TO MAIN FREE LIST
WRE	LHL	R3,REBL		:GET POINTER TO RESERVE BUFFERLETS
	EXHR	R3,R3
	STH	R3,REBL		:SET RESERVE BUFFERLETS EMPTY (=0)
	EXHR	R3,R3
	JNR	R2		:IF IT WASN'T EMPTY, RETURN
	JAL	R10,CRASH	:BUG, UNREASONABLY FAST STORAGE DRAIN
	BC	0,0,4*R4,6	:FLAG--LINK R4, TYPE 6

  IF	BUFTRC
:	UPDATE HISTORY (TRACE) AFTER EVERY BUFFER OPERATION
HIST	LH	R3,HISX		:GET HISTORY RING INDEX
	AIS	R3,4		:BUMP TO NEXT ENTRY
	NHI	R3,3FF		:ACCOUNT FOR FOLDING
	STH	R3,HISX		:SAVE IT AGAIN
	STB	R0,HISTAB,R3	:ENTRY (0) = CHARACTER
	LR	R2,R1
	SRHLS	R2,1		:COMPUTE BUFFER #
	STB	R2,HISTAB+1,R3	:ENTRY (1) = PORT #
	STH	R4,HISTAB+2,R3	:ENTRY (2, 3) = LOCATION WHERE CHAR PLACED
	JR	R4
  EI	(BUFTRC)

:	PEEK AT FIRST CHAR OF BUFFER
GCPCRA	JAL	R10,CRASH;	BC	0,0,4*R4,6	:CRASH TYPE 6
GCPEEK	CLHI	R1,2*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
	LHL	R2,BB,R1	:GET POINTER TO START OF BUFFER DATA
	LHL	R3,BCT,R1	:GET COUNT OF CHARS THERE
	JFS	GCS		:AND SKIP

:	SCAN SUCESSIVE CHARACTERS IN BUFFER
GCSCAN	CLHI	R1,2*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
GCS	SIS	R3,1
	JL	GCPCRA		:CRASH IF NO MORE CHARACTERS THERE
	LB	R0,BUFERS,R2,	:ELSE GET CHAR
	AIS	R2,1		:BUMP POINTER FOR NEXT TIME
	THI	R2,7
	JNR	R4		:EXIT IF NOT AT END OF BUFFERLET
	LHL	R2,BUFERS,R2,	:ELSE ADVANCE TO NEXT BUFFERLET
	SIS	R2,6		:POINT AT START
	JR	R4

:	MCI - MOVE ALL CHARACTERS FROM SOURCE TO DESTINATION BUFFER
:	R5 = SOURCE BUFFER INDEX
:	R6 = DESTINATION BUFFER INDEX
:	R7 = LINK
MCICRA	JAL	R10,CRASH
	BC	0,0,4*R7,4	:FLAG--LINK R7, TYPE 4
MCI	CLHI	R5,2*NBUF
	JGBS	MCICRA		:RANGE CHECK ON SOURCE
	CLHI	R6,2*NBUF
	JGBS	MCICRA		:RANGE CHECK ON DESTINATION
	LHL	R0,BCT,R5	:CHECK SOURCE
	JER	R7		:EXIT IF EMPTY
	LHL	R1,BF,R6	:SET DESTINATION FLAG
	JNFS	MCI1		:FLAG = 0 IS BIT BUCKET
	LR	R1,R5		:THEN JUST EMPTY BUFFERS
	LR	R4,R7
	J	EMPTY
MCI1	SBT	R1,FLAGS	:SET THE FLAG
	JNFS	MCI2		:NOT EMPTY...GO APPEND
	LHL	R0,BB,R5	:EMPTY...COPY BUFFER START
	STH	R0,BB,R6
	J	MCI4		:AND SKIP TO FINISH TRANSFER OF DATA
MCI2	LHL	R1,BE,R6	:CHECK DESTINATION
	AIS	R1,1		:IS IT AT END OF BUFFERLET?
	THI	R1,7
	JNFS	MCI3		:SKIP IF NOT
	LHL	R2,BB,R5	:YES...IS SOURCE ON BUFFERLET BOUNDARY?
	AIS	R2,6
	THI	R2,7
	JNFS	MCI3		:SKIP IF NOT
	STH	R2,BUFERS,R1,	:ELSE APPEND SOURCE TO DESTINATION
	JFS	MCI4		:AND SKIP
MCI3	LR	R1,R5		:MOVE A CHAR
	JAL	R4,GCI
	LR	R1,R6
	JAL	R4,WCI
	LHL	R0,BCT,R5	:CHECK SOURCE
	JG	MCI2		:LOOP IF NOT EMPTY
	JR	R7		:ELSE RETURN
MCI4	LHL	R0,BE,R5
	STH	R0,BE,R6	:UPDATE BUFFER END
	LHL	R0,BCT,R5
	LHL	R1,BCT,R6
	AR	R0,R1
	STH	R0,BCT,R6	
	LIS	R0,0
	STH	R0,BCT,R5	:CLEAR SOURCE BUFFER
	LHL	R1,BF,R5
	RBT	R1,FLAGS	:TURN OFF SOURCE FLAG
	JR	R7		:AND EXIT

:	BACK UP A BUFFER TO RESTORE LAST CHAR
WCD	LHL	R2,BCT,R1	:PICK UP COUNT
	JE	WCDZ		:BFR IS EMPTY BUT OLD CHAR IS STILL AROUND
	AIS	R2,1		:ELSE UPDATE COUNT
	STH	R2,BCT,R1
	LHL	R2,BB,R1	:BACK UP BB
	SIS	R2,1
	STH	R2,BB,R1
	AIS	R2,7		:TEST IF BACKED OVER BEGINNING OF BUFFERLET
	THI	R2,7
	JNR	R4		:EXIT IF NOT
	LHL	R3,BUFERS,,	:ELSE GET LAST ENTRY FROM FREE LIST
	LHL	R0,BUFERS,R3,
	STH	R0,BUFERS,,
	STH	R2,BUFERS,R3,	:LINK NEW FIRST ENTRY TO OLD FIRST
	SIS	R3,1
	STH	R3,BB,R1	:SET NEW ENTRY INTO BB
	JR	R4

WCDZ	LHL	R2,BUFERS,,	:HERE WITH BUFFER EMPTY (BB IS OK)
	LHL	R3,BUFERS,R2,
	STH	R3,BUFERS,,	:FIXUP FREE LIST
	LHL	R2,BF,R1
	SBT	R2,FLAGS	:SET NONEMPTY BFR ATTENTION FLAG
	LIS	R2,1
	STH	R2,BCT,R1	:SET COUNT = 1 CHARACTER
	JR	R4

:	RETURN ALL THE SPACE USED BY THE BUFFER
EMPTY	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JLFS	C1		:BFR ARGUMENT ACCEPTED
	JAL	R10,CRASH	:BFR ARG OUT OF RANGE
	BC	0,0,4*R4,0D	:FLAG--LINK R4, TYPE 13d

C1	LHL	R2,BCT,R1	:CHECK CONTENTS
	JER	R4		:EXIT...BUFFER EMPTY
	LIS	R2,0
	STH	R2,BCT,R1	:NOT EMPTY...SET COUNT = 0
	LHL	R2,BB,R1	:POINTER TO FIRST CHAR IN BUFFER
	AIS	R2,6
	NHI	R2,-8
	LHL	R3,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R2,BUFERS,,	:PUT THE BUFFERS BUFFERLETS ONTO FREE LIST
	LHL	R2,BE,R1	:GET POINTER TO LAST CHARACTER IN BUFFER
	AIS	R2,6		:LOCATE THE POINTER IN THIS BUFFERLET
	NHI	R2,-8
	STH	R3,BUFERS,R2,	:CHAIN PREVIOUS FREE LIST TO THIS BUFFERLET
	LH	R2,BF,R1
	RBT	R2,FLAGS	:SET FLAGS TO EMPTY BUFFER
	JR	R4		:AND RETURN

:	SEE IF WE MUST ZAP BFRS BECAUSE BFR STORAGE RUNNING LOW
CKBZ	LHI	R1,RATE/$A25,R1	:SET TIMER FOR NEXT CALL
	JAL	R5,TOPUT	:RUN 25 TIMES PER SECOND
	LH	R1,REBL		:ARE WE ON THE RESERVE TANK?
	JN	TORET		:PLENTY OF BFR STORAGE. DONT ZAP BFRS

:	WCI GRABBED RESERVE BFR FREE LIST AND MOVED IT TO MAIN FREE LIST.
:	REFILL FREE LIST WITH 1/8 OF TOTAL BFR STORAGE. ZAP BFRS IF NECESSARY.
	LIS	R0,1
	AHM	R0,REBC1	:STATISTIC
REB1	LIS	R2,0		:INITIAL POINTER IS TO START OF FREE LIST
	LA	R1,NBFLET/8	:SCAN MAIN FREE LIST FOR 1/8 FREE STORAGE

REB2	LHL	R2,BUFERS,R2,	:GET NEXT BUFFER ON FREE LIST
	JE	REBZ		:NOT ENOUGH SPARE SPACE. ZAP A BFR
	SIS	R1,1		:GOT ANOTHER...COUNT IT
	JGBS	REB2		:GO UNTIL WE'VE GOT ENOUGH
	LHL	R3,BUFERS,,	:DONE...SEPERATE FREE LIST INTO TWO PARTS
	STH	R3,REBL		:BEGINNING OF THE RESERVE LIST
	LHL	R4,BUFERS,R2,,
	STH	R4,BUFERS,,	:BEGINNING OF MAIN LIST
	STH	R1,BUFERS,R2,,	:DEATH'S BRIGHT ANGEL AT END OF SPARE LIST (=0)
	J	TORET

:	ZAP A BFR IN ORDER TO GET RESERVE TANK UP TO 1/8 OF TOTAL BFR STORAGE
REBZ	LHI	R1,NBUF*2-2	:BCT INDEX
	LIS	R7,0		:BCT CONTENTS OF LARGEST BFR
REBZ1	LHL	R0,BCT,R1
	CLR	R7,R0
	JGEFS	.+6
	LR	R7,R0
	LR	R8,R1
	SIS	R1,2
	JGEBS	REBZ1
	LIS	R0,1
	AHM	R0,REBC2
	STH	R8,BFZ		:STATISTICS
	LR	R1,R8		:ZAP BIGGEST BUFFER FOUND
	JAL	R4,EMPTY	:RETRIEVE STORAGE
  IF	\ZAPBUF : ZAPBUF WILL EXPAND INTO MACRO CALL IF DEFINED,
  EI		:ELSE THIS IS A NOOP
	LIS	R0,9
	JAL	R4,ROOM		:WE WANT TO SEND A 9-BYTE MESSAGE
	LHI	R0,0300		:SPECIAL MESSAGE TYPE 3...
	JAL	R4,PUTW		:SEND DIAGNOSTIC TO SUP
	LR	R0,R7
	JAL	R4,PUTH		:HW4 = CHAR COUNT
	LR	R0,R8
	SRHLS	R0,1
	JAL	R4,PUTH		:HW3 = BUFFER NUMBER
	LHI	R0,PRODID	:2.06 CAB
	JAL	R4,PUTCH	:HW2 = PRODID
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	J	REB1		:TRY AGAIN TO FILL RESERVE STORAGE LIST


 IF	UABUFF
 ELSE
:	BUFFER SEGMENT
	SEG	A.BUFF		:BUFFERLETS IN BUFFER AREA
BUFERS	HS	4*NBFLET+1	:THE STORAGE FOR THE BUFFERLETS
 EI
	EM
	SUBTTL	Standard Timeout Routine Library	- TIMOUT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TIMOUT.LIB

:	This package contains the standard timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:		R1 = current fast-clock time.
:	TORET	routines called by TIMOUT should exit to here
:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5...R6--R15 preserved
:		R0 = address to transfer to
:		R1 = next time to call routine
:	TOGET	called to delete an entry already on timout list
:		link on R5...R6--R15 preserved
:		R0 = routine address...entry with this address will be deleted
:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5...NO registers preserved! NOW!
:		routine address in R0
:	NOTE...when a routine is called from timeout list, it is removed from list,
:	and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 10		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,0F	:FLAG--LINK R5, TYPE 15d CRASH
TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4
	ST	R1,TLIST+6,R4
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
	SUBTTL	ACCOD.300 - ASYNC TYMCOM CODE MODULE
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by TYMNET, Incorporated.                                    **
: ******************************************************************
: **                   MODULE IDENTIFICATION                      **
: **                                                              **
: **                                                              **
: **  File Name          :  ACCOD.300     Last change: 05/27/86   **
: **                                                              **
: **  File Abstract      :  Async Tymcom source code  		  **
: **								  **
: **  File Description   :  Initialize port status, buffers,      **
: **			    port timeout routines, async flags,   **
: **			    async driver, SIO ports, port blocks, **
: **			    processors.                           **
: **			    Initialize timeout list,              **
: **			    start main execution loop,            **
: **			    move buffered async data to async ring,*
: **			    ISIS input message scanner,           **
: **			    check SIO ports for needed action     **
: **			    Process periodic (TIMOUT) routines    **
: **			    move buffered ISIS data to ORING,     **
: **			    host input message scanner,           **
: **			    check for receive line active,        **
: **			    change DTR, when output data done,    **
: **			    execute port timeout routine,         **
: **			    handle front panel display.           **
: **                                                              **
: ******************************************************************
: **                      CHANGE LOG                              **
: **                                                              **
: ** VER  DATE     BY    PIR/NSR  CHANGES (MOST RECENT AT TOP)	  **
: ** --- -------- -----  ------- -------------------------------- **
: **3.00 07/15/86  sdw            File transfer added             **
: **3.00 05/27/86  sdw   PIR1824  ADDED IIX LOGIC (S-Mode)        **
: **2.06 06/26/86  CAB		  Fix DONBRK undefined assembly err*
: **2.06 05/27/86  CAB   NSR 716  Fix host cost bug in multibased **
: **				  host code so load leveling works**
: **2.06 04/29/86  CAB   NSR 689  Have BRKLIM consecutive breaks  **
: **				  force disconnect to avoid hung  **
: **				  sessions caused by some modems. **
: **2.06 04/29/86  CAB   NSR 618  Send sup msg on async ring wrap **
: **2.06 04/07/86  CAB            Fix TINTMS logic to not mask msg**
: **2.06 01/20/86  OJ    N/A      Add "Leave transparency" msg    **
: **				  upon circuit detach on 8 bit    **
: **				  mode data transfer.             **
: **								  **
: **2.06 12/18/85  OJ  		  Add proprietary banner	  **
: **								  **
: ** "	    "	   "	 NSR079   Added a new option to back-     **
: **                              pressure the host using the RS232*
: ** 				  CTS signal, instead of an XON/  **
: **				  XOFF mechanism. The host will   **
: **				  still be able to backpressure   **
: **				  the Tymcom using XON/XOFF.      **
: **				  Covered by Micro Data's project.**
: **				  	SOPT(CTSBP)		  **
: **								  **
: ** "	    "      "	 NSR080   Added a new option to force     **
: **  				  detach upon data loss.          **
: **				  	SOPT(DETDL)		  **
: **								  **
: ** "	    "	   "	 NSR081   Added a new option to allow the **
: **				  host to initiate the disconnect **
: **				  sequnce by using "host disconnect*
: **				  characterts" instead of modem   **
: **				  signals.			  **
: **				  Covered by Micro Data's project.**
: **				  	HDCHAR(C1,...,CN)         **
: **								  **
: ** "      "	   "	 NSR082	  Added a new option to give Tymcom*
: **				  an ability to set terminal      **
: **				  parameter -- reverse X enable   **
: **				  for each new circuit. Effect is **
: **				  the same as logging in with a   **
: **				  "control R".			  **
: **				   	SOPT(RXENA)		  **
: **								  **
: ** "      "      "	 NSR277   SIO initialization correction   **
: **		           	  to ensure 1 1/2 stop bits for   **
: **				  50 & 75 baud baudot ports.      **
: **								  **
: ** "      "      "	 NSR287	  Fixed async host signal changes **
: **				  unshuting shut Tymcom host to   **
: **				  keep Tymcom from reporting host **
: **				  answered when it has been shut  **
: **				  via TOM. 			  **
: **						                  **
: ** "      "      OJ     NSR420  Fixed a problem to signify the  **
: **				  "host key enable" by masking    **
: **				  a bit in the status field of    **
: **				  "Extended report host status"   **
: **				  (ISIS MSG 10) msg.              **
: **								  **
: ** "      "      "	 NSR459	 Elicit no terminal type match msg**
: **				 Fixed the problem of "NO PORTS   **
: **			         AVAILABLE" msg sent when "NO     **
: **				 TERMINAL MATCH" is detected      **
: **				 by Tymcom.			  **
: **								  **
: **			PIR1823  Micro Data R-mode connection	  **
: ** "      "      "		1. Tymcom login changes		  **
: **				 a. Enter 8 bit mode              **   
: **				    This new option is added to   **
: **				    specify that the host supports**
: **				    8 bit characters.            **
: **				    	SOPT(E8BTM)               **
: **								  **
: **				  b. Terminal initialization msg  **
: **				     Tis new option is allowing   **
: **				     the user to specify a message**
: **				     string sent to terminal side **
: **				     following  the network "enter**
: **				     transparency" message on new **
: **				     logins.			  **
: **				       TINTMS(TXT)                ** 
: **								  **
: ** "      "      "    PIR1823	 2. Escape character handling     **
: **			    	    for these ports, if the escape**
: **				    mechanism is used and the     **
: **				    following character is not    **
: **				    special, both the escape char **
: **				    and the following char must   **
: **				    be sent to the terminal side. **
: **                                   CTLESC(CHAR,SYM)           **
: **								  **
: ** "      "      "	PIR1823	 3. CTS flow control              **
: **					SOPT(CTSBP)               ** 
: **				    Please refer to the above     **	
: **				    NSR079 description.		  **
: **								  **
: ** "	    "      "	PIR1823	 4. Host initiated disconnect     **
: **					HDCHAR(C1,...,CN)         **
: **				    Please refer to the above     **
: **				    NSR081 description.		  **
: **								  **
: ** "      "     DU	PIR1823	 5. Break delay option		  **
: **				    A second numerical parameter  **
: **				    is added to indicate the      **
: **				    number of 1/30 second delays  **
: **				    to provide after the break    **
: **				    is sent.			  **
: **					BKSND(CNT,DELAY)          **
: **								  **
: ** "      "     OJ	PIR1823	 6. Tymcom to host reset message  **
: **				    Tymcom has a definable reset  **
: **				    msg on a sub-host basis.      **
: **				    For Microdata, this should be **
: **				    <break> OFF <CR>. A mechanism **
: **				    to define a break in this reset*
: **				    msg is implemented. This msg  **
: **				    will send to the host 1)      ** 
: **				    initially at login, prior to  **
: **				    any other data, and 2) upon   **
: **				    loss of nework circuit.       **
: **				    network circuit.		  **
: **								  **
: ** "     "      "	PIR1723  7. Tymcom message Masking        **   
: **				    Tymcom should mask any data   **
: **				    msgs originated within the    **
: **				    Tymcom to space parity ( 0    **
: **				    top bit) for ports in 8 bit   **
: **				    transparency mode.            **
: **								  **
: ** "     "      DU	PIR1823	 8. Tymcom special char handling  **
: **				    The program is modified to    **
: **				    handle 8 bit special chars.   **
: **								  **
: ** "     "      OJ	N/A	 9. Fixed a bug to avoid sending  **
: **				     2 "B7" msg while  no circuit **
: **			             has been built in ISIS       **
: **				     message scanner.		  **
: **								  **
: ****************************************************************** 
  
  
 	SUBTTL	EQUATES AND WORK AREAS

:	E Q U A T E S   A N D   W O R K   A R E A S
:	===========================================


: ISIS CONTROL MESSAGES

ICM	MACRO(NAM,VAL,LEN)[	:DEFINE ISIS CTL MSGS
CM.`NAM	EQ	VAL
NAM`.L	EQ	LEN
]

	ICM(DET,09E,3)		:DETACH MESSAGE TYPE
	ICM(ZAP,09F,3)		:DISCONNECT MESSAGE
	ICM(NOS,0A0,3)		:APPLY BACK-PRESSURE (NO SEND)
	ICM(SND,0A1,3)		:RELEASE BACK-PRESSURE (SEND)
	ICM(GOB,0A2,3)		:FLUSH OUTPUT (GOBBLER)
	ICM(BKG,0A3,3)		:FLUSH INPUT (BACK GOBBLER)
	ICM(BLK,0A4,3)		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	ICM(GRY,0A5,3)		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	ICM(EDE,0A6,3)		:ENTER DEFERED ECHO MESSAGE
	ICM(LDE,0A7,3)		:LEAVE DEFERED ECHO MESSAGE
	ICM(ETM,0A8,3)		:ENTER TRANSPARENCY MODE
	ICM(LTM,0A9,3)		:LEAVE TRANSPARENCY MODE
	ICM(GB,0AA,3)		:GREEN BALL
	ICM(RB,0AB,3)		:RED BALL
	ICM(YB,0AC,3)		:YELLOW BALL
	ICM(OB,0AD,3)		:ORANGE BALL
	ICM(BRK,0AE,3)		:BREAK DETECTED
	ICM(HNG,0AF,3)		:HANG UP
	ICM(QTP,0B0,4)		:QUERY TERMINAL PARAMETER
	ICM(STP,0B1,5)		:SET TERMINAL PARAMETER
	ICM(PSN,0B2,6)		:PSEUDO NEEDLE
	ICM(NLC,0B3,4)		:NORMAL LOGON CHAR
	ICM(NLS,0B4,4)		:NORMAL LOGON STATUS
	ICM(LOF,0B5,4)		:LOG ON FAILURE
	ICM(NCC,0B6,0A)		:NORMAL CIRCUIT COMPLETE
	ICM(ADA,0B7,8)		:ADDENDUM TO ACCOUNTING
	ICM(SHG,0B8,3)		:SUPER-HANG UP
	ICM(TLM,0B9,4)		:SET TRANSMIT LIMIT
	ICM(BRE,0BA,3)		:break end *following added by sdw.300
	ICM(ZAK,0BB,3)		:zap acknowledge
	ICM(EAD,0BC,3)		:enter alternate device mode
	ICM(LAD,0BD,3)		:leave alternate device mode
	ICM(ZRN,0BD,4)		:zap with reason
	ICM(SIX,0BF,3)		:START OF IIX
	ICM(TIX,0C0,3)		:END OF IIX

CM.FST	EQ	09E		:FIRST ISIS TYPE
CM.LST	EQ	0C0		:LAST ISIS TYPE NOT IGNORED

: INTRA NODE MESSAGES

INM	MACRO(NAM,VAL,LEN)[	:DEFINE ISIS INTRA-NODE MSGS
NM.`NAM	EQ	VAL
NAM`.L	EQ	LEN
]

	INM(RQR,00,3)		:RESTART REQUEST
	INM(RST,01,3)		:RESTART INTERFACE
	INM(NTO,02,3)		:NODE HAS BEEN TAKEN OVER
	INM(REP,03,9)		:REPORT TO SUPERVISOR'S LOG
	INM(RHS,04,0B)		:REPORT HOST STATUS
	INM(RAC,05,8)		:REPORT ACCOUNTING
	INM(TIM,06,8)		:GMT TIME
	INM(RNP,07,0B)		:REQUEST FOR NORMAL PSEUDO NEEDLE
	INM(RAP,08,0B)		:REQUEST AUX PSEUDO-NEEDLE
	INM(PSR,09,7)		:PSEUDO-NEEDLE REJECTED
	INM(HPA,0A,0A)		:HOST PORT AVAILABILITY
	INM(HNA,0B,7)		:HOST NOT ACCEPTABLE
	INM(RHC,0C,0A)		:REPORT HOST COST
	INM(NSP,0D,3)		:NO SUP
	INM(XHS,10,0E)		:EXTENDED HOST STATUS

: ASYNC I/O MSGS

CNASYN	EQ	0C0	:NEW CONNECT ASYNC SVC
:	TO DRIVER
AO.DLY	EQ	08F	:MAX DELAY COUNT
AO.OBR	EQ	090	:SET OUTPUT BAUD RATE
AO.IBR	EQ	0B0	:SET INPUT BAUD RATE
AO.ECM	EQ	0D0	:ENTER CONNECT MODE
AO.EDM	EQ	0E0	:ENTER DATA MODE
AO.DSC	EQ	0E1	:DISCONECT
AO.ENA	EQ	0E2	:ENABLE
AO.RSU	EQ	0E3	:RS UP
AO.RSD	EQ	0E4	:RS DOWN
AO.BRK	EQ	0E5	:75MS OF BREAK
:	FROM DRIVER
AI.IBR	EQ	080	:BAUD RATE GUESS
AI.BRK	EQ	090	:BREAK DETECTED
AI.EBK	EQ	091	:END OF BREAK DETECTED
AI.BLK	EQ	0A0	:BLACK BALL (FAKE)
AI.DSC	EQ	AO.DSC	:DISCONNECT (FAKE)

: ACCOUNTING ADDENDUMS

AA.DET	EQ	0E0000000	:DETATCH CIRCUIT REASONS
AA.CRA	EQ	1		:SLOT CRASH
AA.DBH	EQ	2		:DROPPED BY HOST
AA.DBU	EQ	3		:DROPPED BY USER
AA.HNA	EQ	4		:HOST NOT AVAILABLE
AA.HDN	EQ	5		:SUBHOST DOWN
AA.HSH	EQ	6		:SUBHOST SHUT
AA.NPA	EQ	7		:NO PORTS AVAILABLE
AA.NTM	EQ	9		:NO TERMINAL MATCH FOUND
AA.COR	EQ	0A		:CIRCUIT ORIGINATION REJECTED (BARNODE)
AA.UNR	EQ	0B		:USERNAME REJECTED
AA.NDC  EQ	0E		:NETWORK DISCONNECT	
AA.HPN	EQ	0E0010000	:HOST PORT NUMBER ASSIGNED FOR THIS ISIS PORT

: SEGMENT BASE ADDRESSES

Q	EQ	0
	RE	10
.S|Q|	EQ	Q*10000
Q	EQ	Q+1
	ER

.S	EQ	.S1		:BASE ADDRESS OF CODE SECTION

: DEFINE REGISTERS

RIP	EQ	R12	:CURRENT ISIS PORT NUMBER
RHP	EQ	R13	:CURRENT HOST PORT NUMBER

: MISCELLANEOUS

A.SPED	EQ	0F0128		:SEG F ASYNC SPEEDS SUPPORTED BIT ARRAY
PTMTIM	EQ	1		:PERIOD TO RUN TIMEOUT PROCESSOR CHECK (SECS)
BPONLM  EQ      $A150           :ISIS BACKPRESSURE ON LIMIT
BPOFLM  EQ      $A100           :ISIS BACKPRESSURE OFF LIMIT
XOFFLM  EQ      $A64            :HOST BACKPRESSURE ON LIMIT
XONLM   EQ      $A15            :HOST BACKPRESSURE OFF LIMIT
HSTMER	EQ	$A60		:REPORT HOST COST TIMER	
	GL	IZTOM,TOMEXE,HDWZAP,TOMSAT,TOMMSG,TOMDAT,TOMNDL,TOMHDW,TOMSIO

: PORT STATUS ARRAYS

	SEG	A.WTBL
HPN	HS			:HOST PORT NMBR, INDEXED BY ISIS PORT
	RE	NIPORT
	HC	-1
	ER

	SEG	A.BUFF
IPN	HS	NHPORT		:ISIS PORT NMBR, INDEXED BY HOST PORT
SORD	HS	NHPORT		:SUBHOST ORDINAL NUMBER
TIMVAL	HS	NHPORT		:TIME TO EXECUTE NEXT TIMEOUT PROCESS (IN SEC)
TIMADR	HS	NHPORT		:ADDR OF TIMEOUT PROCESS TO EXECUTE
TIMCHN	HS	NHPORT		:CHAIN TO NEXT TIMEOUT QUEUED PORT

: WORK AREAS

        SEG     A.DATA
EXRETA	WS	1		:EXEC RETURN ADDR
IRSAVE	WS	1		:IRING REG SAVE AREA
DETSAV	WS	1		:SAVE AREA FOR DETACH ROUTINES
IXTEMP	HS	1		:SAVE AREA FOR IIX ROUTINES
HLRSAV	WS	2		:HOST LOOP REG SAVE
WRLA	HS	1		:NEW RLA SAVE AREA
RLARUN  HC      0               :FOR RUNNING EVERY OTHER TIME
LASTC	WC	$A -60		:SLOWC AT LAST START-UP

PTMEAR	HC	-1		:1ST ENTRY IN EARLY-LATE TIMEOUT CHAIN
PTMNOW	HC	0		:EXECUTE TIMEOUT PROCESS IMMEDIATELY IF 8000

DATRET	WC	.
TIMSC	SC	/DDMMMYY HH:MM:SS (GMT)/	:22 CHARACTERS
TIMAC	EQ	TIMSC+1

SSHUT   HS      NSGRP           :1 IF SUBHOST SHUT
SDOWN   HS      NSGRP           :1 IF SUBHOST DOWN
ASPDWN  HS      NSGRP           :1 IF ALL PORTS DOWN FOR A SORD
PSHUT   HS      NHPGRP          :1 IF PORT SHUT
PDOWN   HS      NHPGRP          :1 IF PORT DOWN
XLIMIT  BS      NIPORT          :MAX # OF BYTES FIT CAN SEND ISIS AT ONE TIME

DTR     HS      NTPGRP          :1 TO HANG A PORT. 0 IF PORT ONLINE OR UNUSED.
HDWDTR  HS      NTPGRP          :HARDWARE DTR
SIN     HS      (NTPGRP+1)/2*2  :0 IF CONTROL SIGNALS ARE PRESENT ON INPUT
HDWDSR  HS      (NTPGRP+1)/2*2  :HARDWARE DSR
FGSACT  HS      (NTPGRP+1)/2*2  :FORGROUND DETECTED SIGNAL ACTIVE
HDWCP   HS      (NTPGRP+1)/2*2  :HARDWARE CP
LSTSIG  HS      (NTPGRP+1)/2*2  :LAST SIN STATE IN FORGROUND
TAM	HS	NHPGRP		:DRIVER OUTPUT RING FULL FLAG
TAMR	HS	NHPGRP		:TAM TRANSITION FLAG
OTAM	HS	NHPGRP		:OLD TAM (FOR REVERSE XON)
BRK     HS      NTPGRP          :1 IF PORT IN BREAK STATE
BRKTO   HS      NTPGRP          :IF BREAK TIMEOUT AT SLOWC MOD 8 = 0 OR 4
PIIX    HS      NTPGRP          :IF PROCESSING IIX MESSAGE *300.SDW
PIIXN0  HS      NTPGRP          :1 IF PROCESSED FIRST BYTE *300.SDW
PIIXMG  HS      NTPGRP          :1 IF PROCESSED MESSAGE TYPE *300.SDW
GOT.PN  HS      NTPGRP          :GOT PSEUDO NEEDLE FOR FILE TRANSFER *300.sdw
LOGING  HS      NTPGRP          :IN LOGIN MODE *300.sdw
LOGSTX  HS      NTPGRP          :RECEIVED STX TO START LOG STRING
ORIRLA  HS      NTPGRP          :ORIGINATING CIRCUIT (ALL STAGES)  *300.sdw
TERMT   BS      NTPORT          :TERMINAL TYPE CODE (VIDTT INDEX)
PAB     BS      NTPORT          :1 UNUSED BIT, 3 BIT PARAM A, 4 BIT PARAM B
PCD     BS      NTPORT          :PARAM C LEFT (4 BITS), PARAM D RIGHT (4 BITS)
DEFOUT  HS      NTPGRP          :OUTPUT IS FINISHED FOR THIS ITERATION
DEFIN   HS      NTPGRP          :INPUT DONE
MARGE   HS      NTPORT          :CHR COUNT FROM LEFT MARGIN
:                               :OR CHR DELAY COUNT IF NEGATIVE
SEQKEY  BS      NTPORT          :PSEUDO NEEDLE SEQUENCE # 300.sdw
BRATE	BS	NHPORT		:PORT BAUD RATE
:	SYMBOLS FOR MULTIPLE TYMCOMS
HODNL	HC	-1		:HOST ORDINAL SAVE AREA
NPTSV   HS	MAXHST		:NUMBER OF PORTS SAVED AREA
HCOST	HS	MAXHST		:HOST COST
TCHARS	WS	1		:TOTAL CHARS FOR ALL HOSTS
CHARS	WS	MAXHST		:NUMBER OF CHARS PASSED
CHARSV	WS	MAXHST		:NUMBER OF CHARS SAVED AREA
HNPN	HS	NHPORT		:HOST ORDINAL 
:
ASYSTA  HC      0       	:STATUS FOR QUERY SVC
        BC      0       	:(IN CASE TOO MUCH RETURNED)
  IF	NAPORT
ASYBLK	WS	8
  EI
  IF	NMPORT
SIOBP	HS	NMPGRP		:SIO FORCED OUTPUT FLAGS
  EI
ESCTMP	BC	-1		:ESC CHAR SAVED AREA
HMSTMP	BC	-1		:HOST MESSABE SCANNER SAVED AREA
CTSTMP	WC	-1		:TEMP AREA FOR CTS BP
:	STORAGE FOR ASYNC RINGS

ASRING	EQ	.S|A.RING|

	SEG	A.RING
DFCNT	EQ	0
DFIN    EQ      DFCNT+4
DFOUT   EQ      DFIN+1
DFSTR	EQ	6
DFBUF   EQ      DFCNT
DFSIZ	EQ	80

FDCNT   EQ      DFSIZ
FDTAM	EQ	FDCNT+2
FDIN	EQ	FDTAM+2
FDOUT   EQ      FDIN+1
FDSTR	EQ	6
FDBUF   EQ      FDCNT
FDSIZ	EQ	80

DF      BS      (NAPORT+NTOMPT)*(DFSIZ+FDSIZ)
  IF    NMPORT

:       STORAGE FOR SIO BUFFERS

SIOSTS  EQ      0               :RLTV ADDR OF SIO STATUS AREA
SIOPRI  EQ      SIOSTS+10       :SIO INPUT CHANNEL PROGRAM
SIOGET  EQ      SIOPRI+24       :PNTR TO CURRENT INPUT BFR
SIOPUT	EQ	SIOGET+2	:PNTR TO NEXT CHAR OUT
SIOCMQ	EQ	SIOPUT+2	:COMMAND PROGRAM QUEUED FLAG
SIOLUN	EQ	SIOCMQ+2	:LOGICAL UNIT NMBR FOR THIS PORT
SIOPRO  EQ      SIOLUN+6        :SIO OUTPUT CHANNEL PROGRAM
SIOCMD	EQ	SIOPRO+10	:SIO COMMAND (OUTPUT) PROGRAM
SIOIN   EQ      SIOCMD+20       :SIO INPUT AREA
SIOISZ	EQ	80		:SIO INPUT AREA SIZE
SIOOUT  EQ      SIOIN+SIOISZ    :SIO OUTPUT AREA
SIOOSZ	EQ	80		:SIO OUTPUT AREA SIZE
SIOBFL  EQ      SIOOUT+SIOOSZ+10 :SIO BLOCK ENTRY LENGTH (MUST BE MULT OF 40)

        BND     40
SIOBUF  BS      NMPORT*SIOBFL   :SIO BLOCK

	SEG	A.RTBL
SIOBR	HS			:SIO CONTROL CODE BR TABLE
	HC	SCMEDM-.S	:ENTER DATA MODE
	HC	SCMDSC-.S	:DISCONNECT
	HC	SCMRET-.S	:(ENABLE)
	HC	SCMRSU-.S	:RS UP
	HC	SCMRSD-.S	:RS DOWN
	HC	SCMBRK-.S	:SEND BREAK
SIOBRL	EQ	.-SIOBR
  EI

:	CONSTANT STORAGE

	SEG	A.RTBL
BLKPTR	HS			:POINTERS TO ASYNC RINGS & SIO BLOCKS
Q	EQ	0
  IF	NAPORT
   RE	NAPORT
	HC	DF+Q*(DFSIZ+FDSIZ)-ASRING
Q	EQ	Q+1
   ER
  EI
  IF	NMPORT
QQ	EQ	0
   RE	NMPORT
	HC	SIOBUF+QQ*SIOBFL-ASRING
QQ	EQ	QQ+1
   ER
   IF	(NMPORT+0F)/10*10-NMPORT
    RE	(NMPORT+0F)/10*10-NMPORT
	HC	0
    ER
   EI
  EI
  RE	NTOMPT
	HC	DF+Q*(DFSIZ+FDSIZ)-ASRING
Q	EQ	Q+1
  ER

        SEG     A.CODE
HMASK	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1
WMSK	WS
	RE	20
	WC	1^(1F-(.-WMSK)/4) 		:WORD MASK
	ER
PARBIT  HC      6996,9669,9669,6996,9669,6996,6996,9669    :PARITY FLAGS
  IF	NAPORT
ASYSTR  WC      DF,HDWCP,HDWDSR,HDWDTR,FDDAT,DFDAT,TAM     :ASYNC DRIVER INIT
  EI


	SUBTTL	INITIALIZATION

:	I N I T I A L I Z A T I O N
:	===========================

CFGERR  TRAP(R10,23)            :TRAP HERE IF NOT ENOUGH ASYNC OR SIO UNITS
AIOERR	TRAP(R10,21)		:TRAP HERE IF ERROR IN ASYNC SVC
PSPERR	TRAP(R10,25)		:TRAP HERE IF UNSUPPORTED BAUD RATE USED

: ZAP ANY ACTIVE PORTS

START	LHI	R1,NIPORT-1	:PORT INDEX
	LCS	R5,1		:CONSTANT REG
	STH	R5,HPN,,	:CLEAR INTRA-NODE PORT

IZ0110	LH	R0,HPN,R1,R1	:SEE IF HOST PORT ASSIGNED
	JL	IZ0130		:JUMP PORT NOT CONNECTED
	STH	R5,HPN,R1,R1	:IF SO, CLEAR PORT TABLE
	LHI	R2,CM.ADA	:ACCOUNTING ADDENDUM
	LHI	R0,ADA.L
	JAL	R4,SLOR
	JAL	R4,PUTCH		:PAD
	LI	R0,AA.DET+AA.CRA	:SEND DETACH REASON
	JAL	R4,PUTW
	JAL	R4,ELOR
	LHI	R2,CM.DET
	LIS	R0,DET.L	:DETACH LENGTH
	JAL	R4,SLOR 	:START MSG
	JAL	R4,ELOR 	:END MSG
IZ0130	LHI	R0,CM.FST-1	:SET XMIT LIMIT TO MAXIMUM
	STB	R0,XLIMIT,R1
	SIS	R1,1		:GO TO NEXT PORT
	JGE	IZ0110

: INITIALIZE PORT STATUS

	LHI	R1,NHPORT-1	:NUMBER OF HOST PORTS
	LIS	R6,0		:
IZ0140	STH	R5,IPN,R1,R1	:IPN= -1
	STH	R5,SORD,R1,R1	:SORD= -1
	STH	R5,TIMVAL,R1,R1	:TIMVAL = -1
	STH	R6,TIMADR,R1,R1	:TIMADR = 0
	STH	R5,TIMCHN,R1,R1	:TIMCHN = -1
	SIS	R1,1		:
	JGE	IZ0140		:NEXT PORT

: INITIALIZE MULTI TYMCOM SYMBOLS

	LHI	R1,(MAXHST-1)*2	:NUMBER OF HOSTS
	LIS	R0,0		:
	ST	R0,TCHARS	:TCHARS = 0
IZ0145	STH	R0,HCOST,R1	:HCOST = 0
	STH	R0,NPTSV,R1	:NPTSV = 0
	ST	R0,CHARS,R1,R1	:CHARS = 0
	ST	R0,CHARSV,R1,R1	:CHARSV = 0
	SIS	R1,2		:
	JGEBS	IZ0145		:NEXT PORT

	LHI	R1,NHPORT-1	:NUMBER OF HOST PORTS
	LCS	R0,1		:
IZ0150	STH	R0,HNPN,R1,R1	:HNPN = -1
	SIS	R1,1		:
	JGEBS	IZ0150		:NEXT PORT

: INITIALIZE BUFFERS

	LHI	R1,FLGS.L-2	:GET LENGTH OF FLAG AREA
	LIS	R0,0
IZ0160	STH	R0,FLAGS,R1
	SIS	R1,2
	JGEBS	IZ0160		:CONTINUE TILL ALL ARE ZERO

	LIS	R1,0
	LHI	R4,(TOFIT-FLAGS)*8
	LHI	R3,NIPORT
IZ0170	STH	R4,BF,R1	:INITIALIZE TO.ISIS BUFFER FLAGS
	AIS	R4,1
	AIS	R1,2
	SIS	R3,1
	JGBS	IZ0170

	LHI	R4,(TOPORT-FLAGS)*8
	LHI	R3,NHPORT
IZ0175	STH	R4,BF,R1	:INITIALIZE TO.PORT BUFFER FLAGS
	AIS	R4,1
	AIS	R1,2
	SIS	R3,1
	JGBS	IZ0175

: INITIALIZE PORT TIMEOUT ROUTINES

	LCS	R0,1
	STH	R0,PTMEAR	:INIT TIMEOUT CHAIN POINTER
	LIS	R0,0
	STH	R0,PTMNOW	:INIT TIMEOUT IMMEDIATELY FLAG

: INITIALIZE ASYNC FLAGS

        LIS     R1,(NTPGRP-1)*2
        LCS     R0,1
IZA040  STH     R0,DTR,R1       :CLEAR ANY ACTIVE TERMINALS
        STH     R0,HDWCP,R1
        STH     R0,HDWDSR,R1
        SIS     R1,2
        JGEBS   IZA040
  IF    NAPORT

: INITIALIZE ASYNC DRIVER

        LHI     R6,NAPGRP-1	:PORT GROUP CNTR
	LM	R9,ASYSTR	:PNTRS TO BIT ARRAYS
        LCS     R2,1            :CURRENT LOGICAL UNIT NUMBER
	LA	R0,ASYBLK	:ASYNC DESCRIPTOR ADDRESS
        LA      R3,ASYSTA       :QUERY STATUS ADDRESS
        LIS     R4,2            :LENGTH OF STATUS AREA
IZA010  AIS     R2,1
        SVC     IO,IOQRY.+R2,,  :GET NEXT LOGICAL UNIT
        J       AIOERR          :BAD STATUS
        LB      R5,0,R3         :TYPE OF LOGICAL UNIT
        CLHI    R5,0FE
        JE      CFGERR          :IF NO MORE UNITS
        CLHI    R5,01
        JNBS    IZA010          :IF NOT ASYNC UNIT

	LR      R8,R2           :GET LOGICAL UNIT NUMBER
	OI	R8,DFSIZ^10	:PUT IN ASYNC RING SIZE
        STM     R8,ASYBLK	:SAVE PNTRS
        SVC     IO,CNASYN	:NEW ASYNC CONNECT CMD
        J       AIOERR          :BAD CALL
	AHI	R9,20*DFSIZ	:BUMP ASYNC RING PNTR
	AIS	R10,2		:BUMP BIT ARRAY PNTRS
	AIS	R11,2
	AIS	R12,2
	AIS	R13,2
	AIS	R14,2
	AIS	R15,2
        SIS     R6,1		:SEE IF LAST PORT GROUP
        JGE     IZA010		:BR IF NOT
  EI
  IF    NMPORT

: INITIALIZE SIO PORTS

        LIS     R1,0
	LHI	R2,(NMPGRP-1)*2
IZA020	STH	R1,SIOBP,R2	:CLEAR SIO CHECK BITS
	SIS	R2,2
	JGEBS	IZA020

	LHI	RHP,NAPORT	:PORT NMBR
        LI      R10,SIOBUF	:PORT BLOCK ADDR
        LCS     R6,1            :LOGICAL UNIT NMBR
IZA050  AIS     R6,1            :BUMP TO NEXT LOGICAL UNIT NMBR
        LA      R7,ASYSTA       :QUERY STATUS ADDRESS
        SVC     IO,IOQRY.+R6,,  :TEST NEXT LOGICAL UNIT
        J       SIOERR          :ERROR RETURN
        LB      R5,0,R7         :GET TYPE OF LOGICAL UNIT
        CLHI    R5,0FE
        JE      CFGERR          :IF NO MORE UNITS
        CLHI    R5,04
        JN      IZA050          :IF NOT SIO UNIT

        STB     R6,SIOLUN,R10   :SAVE LOGICAL UNIT NMBR
        LR      R7,R10          :STRT OF AREA ADDRESSABLE BY SIO
        LA      R8,SIOBFL-1,R10 :END OF AREA
        LA      R9,SIOSTS,R10   :ADDR OF STATUS AREA
        SVC     IO,CMBRD.*10+R6 :CONNECT SIO PORT
        J       SIOERR          :ERROR RETURN
        LIS     R7,0
        SVC     IO,FMBOT.*10+R6 :RESET PORT
        J       SIOERR
        LA      R3,SIOIN,R10    :BUILD INPUT CHANNEL COMMAND
        SRLS    R3,4            :MAKE QUAD WORD ADDR
        OI      R3,40000
	LIS	R4,0
IZA080	ST      R3,SIOPRI,R10,R4 :SAVE IN INPUT PROGRAM AREA
        AIS     R3,1
	AIS	R4,4
	CLHI	R4,SIOISZ/10*4
	JLBS	IZA080
        LA      R3,SIOPRI,R10
        SRLS    R3,4
        OI      R3,20000
        ST      R3,SIOPRI,R10,R4 :SAVE JMP CMD IN INPUT PROG AREA
        RBT     RHP,HDWCP	:SET DUMMY CP HIGH
        AHI     R10,SIOBFL      :BUMP TO NEXT SIO PORT BLOCK
        AIS     RHP,1
        CLHI    RHP,NTPORT
        JL      IZA050          :BR IF NOT DONE
  EI    :NMPORT

: INITIALIZE PORT BLOCKS

	LHI	RHP,NTPORT-1
IZA090	JAL	R5,RGCLR	:INIT PORT BLOCK
  IF	NAPORT
   IF	NMPORT
	TBT	RHP,SIOP	:SIO PORT?
	JNFS	IZA100		:NOPE
   EI
	LB	R1,PSPEED,RHP,	:GET PORT SPEED
	CLHI	R1,MAXSPD
	JGFS	IZA100
	TBT	R1,A.SPED,,	:SEE IF SPEED SUPPORTED
	JE	PSPERR		:ERROR IF NOT
  EI
IZA100	SIS	RHP,1
	JGE	IZA090

: INITIALIZE PROCESSORS

	JAL	R0,IZT		:INIT TIMEOUT FREE LIST
	JAL	R5,IZBF		:INIT STANDARD BUFFERLETS
	JAL	R10,IZTOM	:INIT TYMCOM OPERATIONS MANAGER

: SET TOM HOST UP

	LIS	R6,TOM		:TOM HOST ORDINAL
	LIS	R12,0		:UP AND ANSWERED
	LH	R9,HOSTS,R6,R6	:NETWORK HOST NUMBER
	JAL	R5,CHSTAT	:SET TOM UP
	SUBTTL	MAIN EXEC LOOPS

:	M A I N   E X E C   L O O P S
:	=============================

  IF	BKGND

: BACKGROUND MAIN EXEC START

	LA	R0,FGEXEC
	SVC	SYS,CFGND.	:CONNECT FOREGROUND EXEC
	JAL	R10,TMINIT	:INIT TIMEOUT LIST

BGEXEC	SVC	FASTD,0		:STAT OF BACKGROUND MAIN EXEC
  ELSE

: FOREGROUND MAIN EXEC START

	LA	R0,FGINIT
	SVC	SYS,CFGND.	:CONNECT FOREGROUND EXEC

BGEXEC	SVC	FASTD,0		:BACKGROUND EXEC LOOP
	JAL	R10,FPBACK,,	:FRONT PANEL
	JAL	R10,TOMEXE	:TOM EXEC
	UPSW	BEXPSD		:BACKGROUND LOOP
BEXPSD	WC	0000,BGEXEC	:CHANGE TO 1000 FOR ENGINE HARDWARE TRACE

FGINIT	JAL	R10,TMINIT	:INIT TIMEOUT LIST
FGEXEC	SVC	FASTD,0		:START OF FOREGROUND MAIN EXEC
  EI

: MAIN EXEC LOOP

	JAL	R10,BUFASY	:MOVE BUFFERED ASYNC DATA
	JAL	R10,ISISMS	:ISIS INPUT MESSAGE SCANNER
  IF	1-BKGND
   IF	NMPORT
	JAL	R10,SIOGO	:CHECK SIO PORTS FOR NEEDED ACTION
   EI
  EI
	JAL	R0,TIMOUT	:PROCESS PERIODIC ROUTINES
	JAL	R10,BUFIS	:MOVE BUFFERED ISIS DATA
	JAL	R10,HOSTMS	:HOST INPUT MESSAGE SCANNER
	JAL	R0,TIMOUT
  IF	1-BKGND
	JAL	R10,FGRLA,,	:CHECK FOR RECEIVE LINE ACTIVE
  EI
  IF	NAPORT
	JAL	R10,HANGEM,,	:HANG ANYBODY WITH HANG BIT SET
  EI				:CHANGE DTR, WHEN OUTPUT DATA DONE

	LIS	R0,0
	RBT	R0,PTMNOW	:EXECUTE PORT TIMEOUT NOW?
	JEFS	EXE010		:IF NO
	LA	R0,PTMONW
	JAL	R5,TONOW	:EXECUTE IT
EXE010	HS

  IF	BKGND
: BACKGROUND MAIN EXEC END

	JAL	R10,FPBACK,,	:FRONT PANEL
	JAL	R10,TOMEXE	:TOM EXEC
	UPSW	BEXPSD		:BACKGROUND LOOP
BEXPSD	WC	0000,BGEXEC	:CHANGE TO 1000 FOR ENGINE HARDWARE TRACE

FGEXEC	SVC	FASTD,0		:FOREGROUND EXEC LOOP
   IF	NMPORT
	JAL	R10,SIOGO	:CHECK SIO PORTS FOR NEEDED ACTION
   EI
	JAL	R10,FGRLA	:CHECK FOR RECEIVE LINE ACTIVE
	UPSW	FEXPSD		:FOREGROUND LOOP
FEXPSD	WC	0000,FGEXEC	:CHANGE TO 1000 FOR ENGINE HARDWARE TRACE
  ELSE
: FOREGROUND MAIN EXEC END

	UPSW	FEXPSD		:FOREGROUND LOOP
FEXPSD	WC	0000,FGEXEC	:CHANGE TO 1000 FOR ENGINE HARDWARE TRACE
  EI

:	COMMON RETURN TO EXEC

EXECRT	L	R10,EXRETA	:GET EXEC RETURN ADDR
	JR	R10		:RETURN


: TIMEOUT INITIALIZATION ROUTINE

TMINIT	L	R7,FASTC,,
        LHI     R1,RATE/2,R7
        LA      R0,HSEC
        JAL     R5,TOPUT	:HALF SECOND ROUTINE
        LHI     R1,RATE*4,R7
        LA      R0,SEC4
        JAL     R5,TOPUT	:4 SECOND ROUTINE
	L	R1,FASTC,,
	LHI	R1,RATE*PTMTIM,R1
	LA	R0,PTMOUT
	JAL	R5,TOPUT	:PORT TIMEOUT PROCESSOR

	LHI	R7,$A 60
	S	R7,SLOWC,,	:SEE HOW LONG SINCE LAST START-UP
	A	R7,LASTC
	JLEFS	TMI010		:BR IF GT 1 MIN
	LHI	R6,RATE
	MHR	R7,R6		:CONVERT TO FASTC TIME
	JFS	TMI020
TMI010	LIS	R7,1		:DO IT QUICK
TMI020	A	R7,FASTC,,
	L	R1,SLOWC,,	:SET NEW START-UP TIME
	ST	R1,LASTC
	LR	R1,R7
	LA	R0,SETUP
	JAL	R5,TOPUT	:HOST BRING-UP ROUTINE
  IF	INAN+1
	LI	R1,RATE*$A60,R7 :CHECK INACTIVITY 1 MIN AFTER HOST COMES UP
	LA	R0,ACTTIM	:ACTIVITY TIMER
	JAL	R5,TOPUT
  EI

  IF	HKEYN+1		
	LI	R1,RATE*HSTMER,R7	:CHECK IF NEED TO REPORT HOST COST
	LA	R0,HOSTCT		:HOST COST TIMER
	JAL	R5,TOPUT
  EI

	JR	R10		:RETURN

: SET INITIAL HOST STATUS
:	EXECUTED 3 MINUTES AFTER START-UP.
:	IF HOST IS GONE, SET TO UP AND ANSWERED, ELSE REPORT HOST
:	STATUS WITHOUT CHANGE.

SETUP	LHI	R6,MAXHST-1
SET010	LH	R9,HOSTS,R6,R6	:GET NETWORK HOST #
	LIS	R12,0		:DEFAULT IS UP AND ANSWERED
	LB	R5,PORTS,R6,R6	:GET CURRENT HOST STATUS
	SRHLS	R5,6
	CLHI	R5,3		:GONE?
	JEFS	SET020		:IF GONE, SET TO ANSWERED
	LR	R12,R5		:ISSUE CURRENT STATUS
SET020	JAL	R5,CHSTAT	:CHANGE HOST STATUS
	SIS	R6,1
	JGE	SET010		:IF MORE HOSTS
	L	R6,SLOWC,,
	ST	R6,LASTC	:SET NEW START-UP TIME
	J	TORET
	SUBTTL	BUFFERED DATA TO ASYNC DRIVER

:	B U F F E R E D   D A T A   T O   A S Y N C   D R I V E R
:	=========================================================

:	MOVE DATA IN TOPRT BUFFERS TO ASYNC DRIVER WHEN POSSIBLE.

BUFASY	LHI	R11,(NHPGRP-1)*2	:NMBR OF HOST PORT GRPS
BFA010	LHL	RHP-1,TAM,R11		:LOOK FOR NON-BKPRESSURED
	NH	RHP-1,TOPORT,R11	:*PORTS THAT HAVE DATA
	NH	RHP-1,TOPTON,R11	:*AND ARE TURNED ON
	JFFOH	RHP-1,BFA030		:BR IF ONE FOUND
	SIS	R11,2			:BUMP TO NEXT PORT GRP
	JGEBS	BFA010			:BR IF MORE TO CHECK
	JR	R10			:DONE

BFA030	LR	R14,R11			:MAKE HOST PORT NMBR
	SLHLS	R14,3
	AR	RHP,R14
	LA	R1,TOPRT,RHP,RHP	:GET BFR NMBR

BFA040	JAL	R4,GCI			:GET CHAR FROM BFR
	LR	R0,R0			:SEE IF ESCAPED
	JNFS	BFA045			:BR IF NOT
	JAL	R4,GCI			:GET ESCAPED COMMAND
	JAL	R5,PEEDR		:ENSURE BOTH BYTES OF CMD
	JFS	BFA047			:*PUT INTO RING AT ONCE
BFA045	JAL	R5,PCCDR		:PUT CHAR IN ASYNC RING
BFA047	LA	R1,TOPRT,RHP,RHP	:GET BFR NMBR AGN
	TBT	RHP,TAM			:SEE IF BKPRESSURED NOW
	JEFS	BFA050			:GO TO NEXT PORT IF SO
	TBT	RHP,TOPORT		:SEE IF ANY MORE DATA
	JN	BFA040			:LOOP IF SO
BFA050	LHL	R2,BCT,R1		:SEE IF TIME TO RELEASE
	SHI	R2,BPOFLM		:*ISIS BACKPRESSURE
	JG	BFA010			:BR IF NOT
	LH	RIP,IPN,RHP,RHP		:GET ISIS PORT NMBR
	JLE	BFA010			:BR IF NONE
	SBT	RIP,FRISIS		:RELEASE ISIS BACKPRESSURE
	JN	BFA010			:BR IF ALREADY RELEASED
	LIS	R0,SND.L
	LR	R1,RIP
	LHI	R2,CM.SND		:SEND BACKPRESSURE OFF MSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	J	BFA010			:GO TO NEXT PORT
	SUBTTL	ISIS MESSAGE SCANNER

:	I S I S   M E S S A G E   S C A N N E R
:	=======================================

:	SCAN ISIS INPUT RING FOR MESSAGES, PROCESS THEM, AND
:	MOVE DATA TO THE ASYNC OUTPUT RING.  IF THERE IS NO
:	ROOM IN THE OUTPUT RING, THEN BUFFER THE DATA.

:	REGISTERS SET AS FOLLOWS:
:		R2  = MSG TYPE
:		R8  = SORD NUMBER
:		R11 = MSG LENGTH
:		RIP = ISIS PORT NUMBER
:		RHP = HOST PORT NUMBER

ISISMS	ST	R10,EXRETA	:SAVE RETURN TO EXEC LOOP

:	CHECK FOR MESSAGES IN ISIS INPUT RING

ISCHK	JAL	R4,LOOK		:LOOK AT INPUT RING
	J	EXECRT		:EMPTY, RETURN
	JN	ISCCOM		:IF NOT INTRA-NODE MSG

: INTRA-NODE MESSAGE

	CLH	R2,MAXP0,,	:SEE IF MSG TOO BIG
	JLEFS	ISC020		:BR IF NOT
ISC010	TRAP(R10,20)		:ILLEGAL INTRA-NODE MSG TYPE
ISC020	LHL	R11,LP0LST,,	:GET ADDR OF INTRA-NODE MSG LEN TBL
	LB	R11,.SF,R2,R11	:GET LENGTH OF THIS MSG
	JEBS	ISC010		:BR IF MSG LENGTH IS VARIABLE
	CLHI	R2,NM.NTO	:SEE IF TAKE-OVER
	JEFS	ISRHS		:BR IF SO
	CLHI	R2,NM.HNA	:SEE IF HOST-REJECT
	JN	ISFLSH		:GO IGNORE MSG IF NEITHER
	TRAP(R10,24)		:HOST NOT ACCEPTABLE

:       TAKEOVER, REPORT HOST STATUS.

ISRHS   LHI     R6,MAXHST-1
ISC030  LB      R12,PORTS,R6,R6
        SRHLS   R12,$A6 	:GET STATUS
        LH      R9,HOSTS,R6,R6  :GET HOST NUMBER
        JAL     R5,CHSTAT       :REPORT
        SIS     R6,1
        JGE     ISC030          :IF MORE HOSTS
	J	ISFLSH

: PORT MESSAGES

ISCCOM	LR	RIP,R1		:SAVE ISIS PORT NUMBER
	LR	R11,R2		:SET COUNT IF DATA
	JE	ISNDL		:BR IF NEEDLE
	CLHI	R2,CM.FST	:DATA?
	JL	ISDATA		:IF DATA
	CLH	R2,MAXMSG,,	:LEGAL CTL MSG?
	JLEFS	ISC050		:IF LEGAL
ISC040	TRAP(R10,20)		:ILLEGAL TYPE, CRASH
ISC050	LB	R11,LENGTH,R2,	:GET CTL MSG LENGTH
	LH	RHP,HPN,RIP,RIP :GET HOST PORT NMBR
	JGEFS	ISC055		:HAVE PHYSICAL PORT
        CLHI    R2,CM.PSN       :PSEUDO NEEDLES ARE GETTING A PORT NUMBER
        JEFS    ISC055
        J       ISDET           :ELSE DETACH
ISC055	CLHI	R2,CM.LST	:MSG IN OUR TABLE?
	JGFS	ISC060		:NO, GO FLUSH
	LHL	R8,SORD,RHP,RHP	:GET SORD NMBR
	LHL	R1,ICRCOM-2*CM.FST,R2,R2  :GET BR ADDR
	JN	.S,R1		:GO HANDLE CTL MSG
ISC060	LR	R11,R11		:TEST MSG LENGTH FROM TBL
	JE	ISC040		:CRASH IF VARIABLE LEN

ISFLSH	LR	R0,R11		:GET REMAINING MSG CNT
	JAL	R4,FLUSH	:END THIS MESSAGE
	J	ISCHK		:GO GET NEXT MSG

ISDET	SBT	RIP,TOISIS	:CLEAR BACKPRESSURE
	JBS	ISFLSH
	
: DATA MESSAGE

ISDATA	JAL	R4,GETCH	:SKIP MSG LENGTH
	LH	RHP,HPN,RIP,RIP	:GET HOST PORT NMBR
	JL	ISFLSH		:IGNORE MSG IF NONE
        TBT     RHP,ORIRLA      :FILE TRANSFER PORT?
        JN      ISFTDT          :JUMP IF FT
        TBT     RIP,PIIX        :PROCESSING AN IIX MSG *300.sdw
        JN      ISDIIX
  IF	INAN+1
	LIS	R8,0
	STB	R8,INACT,RHP,	:RESET INACTIVITY TIMER
	STB	R8,BRKACT,RHP,	::2.06 - CAB - NSR 689 RESET BREAK COUNTER
  EI
	LH	R8,SORD,RHP,RHP	:GET SORD NMBR
	LIS	R6,0		:INDICATE NO ECHOING
	TBT	RHP,DEM		:DEFERRED ECHO MODE?
	JEFS	ITH010		:IF NOT
	TBT	RHP,ECHOP	:ECHO ON?
	JEFS	ITH010		:IF NOT
	LB	R6,XLIMIT,RIP	:MAX XMIT CNT
	LIS	R2,0		:INDICATE DATA MSG
	LHI	R3,3,R6		:MAX MSG LENGTH
	JAL	R5,QSLOR	:START OUTPUT FOR ECHO DATA

:	MOVE DATA FROM ISIS MESSAGE TO ASYNC RING

ITH010	JAL	R4,GETCH	:GET DATA CHAR
	LH	R4,HNPN,RHP,RHP	:ACCUMULATE HOST TRAFFIC
	JL	ISFLSH		:
	AR	R4,R4		:
	LIS	R5,1		:
	AM	R5,CHARS,R4,R4	:INCREMENT CHAR COUNT
	LR	R7,R0
  IF	OP|E8BTM.|
	TBT	RHP,E8BTMP	:IS THIS 8-BIT SUPPORT?
	JNFS	ITH015
  EI
	NHI	R7,7F		:NO, THEN STRIP PARITY
ITH015	LR	R6,R6		:ECHOING?
	JE	ITH020		:BR IF NOT
  IF    DEN             	:IF MORE THAN 1 TABLE ENTRY
        LR      R5,R8
        SLHLS   R5,5            :BIAS TO CURRENT TABLE (256 BITS EACH)
        TBT     R7,DETBL,R5,    :ECHOABLE?
  ELSE
        TBT     R7,DETBL,,
  EI
        JE      ITH020          :IF NOT ECHOABLE

:       THIS CHARACTER MAY NEED ECHOING

        CLHI    R7,0D           :CARRIAGE RETURN?
        JN      DOE030          :IF NOT
        TBT     RHP,ECRLFP      :ECHO CR/LF FOR CR?
        JE      DOE050          :IF NO
        TBT     RHP,HDUXP       :HALF DUPLEX PORT?
        JNFS    DOE020          :IF YES
        JAL     R4,QPUTDC       :ECHO CR
	SIS	R6,1
	JGFS	DOE020		:IF XMIT LIMIT REACHED,
	JAL	R4,QELODR	:*THEN END RECORD
	SBT	RIP,PIBUF	:*AND FORCE REST INTO BFR
	LB	R6,XLIMIT,RIP
DOE020  LR      R10,R0          :SAVE 8 BIT CHAR
        LIS     R0,0A           :GET LINEFEED FOR ECHO
        J       DOE060          :GO ECHO LINEFEED

DOE030  CLHI    R7,0A           :LINEFEED?
        JN      DOE050          :IF NOT
        TBT     RHP,ELFCRP      :ECHO LF/CR/RO FOR LF?
        JE      DOE050          :IF NO
        TBT     RHP,HDUXP       :HALF DUPLEX PORT?
        JNFS    DOE040          :IF YES
        JAL     R4,QPUTDC       :ECHO LINEFEED
	SIS	R6,1
	JGFS	DOE040		:IF XMIT LIMIT REACHED,
	JAL	R4,QELODR	:*THEN END RECORD
	SBT	RIP,PIBUF	:*AND FORCE REST INTO BFR
	LB	R6,XLIMIT,RIP
DOE040  LR      R10,R0          :SAVE 8 BIT CHAR
        LIS     R0,0D           :GET CARRIAGE RETURN
        JFS     DOE060          :GO ECHO CR

DOE050  TBT     RHP,HDUXP       :HALF DUPLEX PORT?
        JN      ITH020          :IF YES
        LR      R10,R0          :GET 8 BIT CHAR
DOE060  JAL     R4,QPUTDC       :ECHO CHARACTER
	SIS	R6,1
	JGFS	DOE070		:IF XMIT LIMIT REACHED,
	JAL	R4,QELODR	:*THEN END DATA RECORD
	SBT	RIP,PIBUF	:*AND FORCE REMAINDER IN BFR
	LB	R6,XLIMIT,RIP	:INDICATE ECHOING STILL
DOE070	LR      R0,R10          :RESTORE 8 BIT CHAR

ITH020	LR	R8,R8		:SEE IF TOM
	JE	TOMDAT		:BR IF SO
  IF    OP|T2741.|!.GE.(UETMN,0)!.GE.(HETMN,0)
        TBT     RHP,TRANSP
        JN      ITHSND          :IF TRANSPARENT MODE
  EI

  IF    OP|CAPFT.|
:       CHECK FOR A NEED FOR CAPITALIZATION.

        TBT     R8,CAPFT,,
        JEFS    IHSC10          :THIS HOST NOT CAPITALIZING
        CLHI    R7,60
        JLFS    IHSC10          :IF NOT LOWER CASE
        SHI     R0,20
IHSC10  HS
  EI

  IF    \IHTBL
:       CHECK FOR SPECIAL CHARACTERS

   IF   IHN             	:IF >1 SET
        LR      R4,R8
        SLHLS   R4,5		:BIAS TO CURRENT TABLE (256 BITS/SORD)
        TBT     R7,IHTBL,R4,
   ELSE
        TBT     R7,IHTBL,,
   EI
        JE      ITHSND  	:IF NOTHING TO CHECK

  IF    UETMN+1
:       CHECK FOR USER TRANSPARENCY CHARACTER

   IF   UETMN
        CLB     R7,UETMSV,R8,
   ELSE
        CLHI    R7,UETMSV
   EI
        JNFS    IHUT10          :IF NOT ETM CHAR
        SBT     RHP,TRANSP      :SET TRANSPARENCY
IHUT10  HS
  EI

  IF	TEONN+1
:	CHECK FOR ECHO ON CHARACTER FROM TERMINAL

   IF	TEONN			:IF > 1 VALUE
	CLB	R7,TEONSV,R8,
   ELSE
	CLHI	R7,TEONSV
   EI
	JN	IHTE30		:BR IF NOT TERM ECHO ON CHAR

	SBT	RHP,ECHOP	:SET ECHO ON
	JN	IHTE30		:IF ALREADY ON
	SBT	RHP,DEM		:SET DEFERRED ECHO MODE
	LR	R10,R0		:SAVE ACTUAL CHAR
	LR	R6,R6		:ECHO DATA RECORD STARTED?
	JEFS	IHTE10		:BR IF NOT
	JAL	R4,QELODR	:END DATA RECORD
IHTE10	LHI	R2,CM.STP
	LHI	R3,STP.L
	JAL	R5,QSLOR	:SEND SET-TERM-PARAM
	LIS	R0,0
	JAL	R4,QPUTCH	:SET ECHO ON
	LIS	R0,1
	J	IHTE45		:GO SEND THE REST

:	CHECK FOR ECHO OFF CHARACTER FROM TERMINAL

IHTE30	HS
   IF	TEONN
	CLB	R7,TEOFSV,R8,
   ELSE
	CLHI	R7,TEOFSV
   EI
	JN	IHTE60		:BR IF NOT TERM ECHO OFF

        LR      R10,R0          :SAVE ACTUAL CHAR
	LR	R6,R6		:ECHO DATA RECORD STARTED?
	JEFS	IHTE40		:BR IF NOT
	JAL	R4,QELODR	:END DATA RECORD
IHTE40	LHI	R2,CM.STP
	LHI	R3,STP.L
	JAL	R5,QSLOR	:SEND SET-TERM-PARAM
	LIS	R0,0
	JAL	R4,QPUTCH	:SET ECHO OFF
IHTE45	JAL	R4,QPUTCH	:SET ECHO
	JAL	R4,QELOR	:END ECHO-ON/OFF RECORD
	LR	R6,R6		:NEED ECHO DATA OUTPUT?
	JEFS	IHTE50		:BR IF NOT
	LIS	R2,0
	LHI	R3,3,R11
	JAL	R5,QSLOR	:RE-START DATA RECORD
IHTE50	LR	R0,R10		:RESTORE DATA CHAR
IHTE60	HS
  EI

  IF    UDN+1
:       CHECK FOR USER DISCONNECT CHARACTER

   IF	UDN			:IF > 1 SET
	LR	R5,R8
	SLHLS	R5,5		:BIAS TO CURRENT TABLE (256 BITS/SORD)
	TBT	R7,UDTBL,R5,	:SEE IF USER DISC CHAR
   ELSE
	TBT	R7,UDTBL,,	:SEE IF USER DISC CHAR
   EI
	JEFS	IHUD10		:BR IF NOT
	SIS	R11,1		:COUNT THIS CHAR
	J	DONBRK		:GO DISCONNECT USER
IHUD10	HS
  EI

  IF    GBN+1
:       CHECK FOR GOBBLERS

   IF	GBN			:IF > 1 SET
	LR	R5,R8
	SLHLS	R5,5		:BIAS TO CURRENT TABLE (256 BITS/SORD)
	TBT	R7,GBTBL,R5,	:SEE IF TO RETURN GOBBLER
   ELSE
	TBT	R7,GBTBL,,	:SEE IF TO RETURN GOBBLER
   EI
	JE	IHGB20		:BR IF NOT

	STH     R0,HLRSAV       :SAVE CHAR FOR HOST
	JAL	R10,SNDGOB	:SEND GOBBLER
	LR	R6,R6		:ECHO DATA RECORD STARTED?
	JEFS	IHGB15		:BR IF NOT
	LIS	R2,0
	LHI	R3,3,R6
	JAL	R5,QSLOR	:RE-START OUTPUT DATA RECORD
IHGB15  LH      R0,HLRSAV       :RESTORE CHAR
IHGB20  HS
  EI

  IF   TFN+1
:       CHECK TERMINAL FILTER CHARACTERS.

   IF	TFN			:IF > 1 SET
	LR	R5,R8
	SLHLS	R5,5		:BIAS TO CURRENT TABLE (256 BITS/SORD)
	TBT	R7,TFTBL,R5,	:SEE IF TO FILTER CHAR
   ELSE
	TBT	R7,TFTBL,,	:SEE IF TO FILTER CHAR
   EI
	JN	ITHBMP		:BR IF SO
  EI

   IF   ESCN+1
:       CHECK FOR CTLESC CHAR, ESC IF NECESSARY

    IF  ESCN    :IF >1 VALUE
        TBT     RHP,ESCP
        JEFS    ITHSND          :IF NO ESC FOR THIS SORD
        CLB     R7,ESCSV,R8,
    ELSE
        CLHI    R7,ESCSV
    EI
        JNFS    ITHSND          :IF NOT THE ESC CHAR
        JAL     R5,PCEDR        :ESC THE ESC
	JFS	ITHBMP
   EI
  EI    (IHTBL)

:	SEND THE CHARACTER

ITHSND	JAL	R5,PPCDR	:SET PARITY & SEND CHAR

ITHBMP	SIS	R11,1		:DECR CNT OF CHARS IN MSG
	JG	ITH010		:BR IF NOT DONE
	LR	R6,R6		:ECHOING?
	JEFS	ITHBP		:GO GET NEXT MSG IF NOT
	JAL	R4,QELODR	:END OUTPUT DATA RECORD
ITHBP	JAL	R5,CHKBP	:SEND ANY NEEDED BP MSGS
	J	ISFLSH		:GO GET NEXT MSG

ISFTDT  JAL     R4,GETCH        :GET THE CHAR
        JAL     R5,PDCDR        :PUT TO DRIVER
        SIS     R11,1
        JG      ISFTDT          :GET AS LONG AS IT IS THERE
        JAL     R5,CHKBP
        J       ISFLSH          :AND DONE


:  process IIX msgs.  possible are 8081 (sel dialect) and 8087 (REQ PRODID)
ISDIIX  TBT     RIP,PIIXMG      :KNOW MSG TYPE YET?
        JN      ISDIXM          :CONTINUE TO PROCESS MSG
        SBT     RIP,PIIXN0      :SET AND COUNT WHICH OF THE TWO BYTES
        JN      ISD2IX
        JAL     R4,GETCH
        CLHI    R0,80           :check first char
                :can add probe msg or whatever on illegal msg
        SIS     R11,1
        JLE     ISFLSH
ISD2IX  JAL     R4,GETCH
        SIS     R11,1
        CLHI    R0,81
        JEFS    ISDXSL          :SELECT DIALECT
        CLHI    R0,87           :OTHER GLOBAL WE CAN GET
        JE      ISDXRQ          :request PRODID and version
        J       ISFLSH          :ELSE FLUSH MSG

ISDXSL  SBT     RIP,PIIXMG      :PROCESSING DIALECTT
        RBT     RIP,PIIXN0      :LOOKING FOR FIRST OF PAIR
        LR      R11,R11         :CHECK IF DATA PRESENT
        JE      ISFLSH
ISDIXM  JAL     R4,GETCH
        SIS     R11,1
        SBT     RIP,PIIXN0      :GOT FIRST BYTE
        JNFS    ISDXM1          :ALREADY READ FIRST BYTE
:       CLHI    R0,80           :ONLY POSSIBLE VALUE
:       JUMP TO SOME PROBE ERROR ROUTINE IF NOT EQUAL
        LR      R11,R11         :NEXT BYTE THERE?
        JE      ISFLSH
        JAL     R4,GETCH        :GET DIALECT VALUE
ISDXM1  RBT     RIP,PIIX        :FINISHED WITH THIS IIX MSG
        SIS     R11,1           :REDUCE COUNT
        CLHI    R0,93           :S-MODE DIALECT?
        JN      ISFLSH          :NO SO DON'T CARE
        LR      R1,RIP          :GET PORT NUMBER
        LHI     R2,CM.SIX       :START OF IIX
        LIS     R0,SIX.L
        JAL     R4,SLOR
        JAL     R4,ELOR
:  FOLLOWING IS LIFTED FROM FROM THE INIT TEXT (TINT)  *300.sdw
 IF 	TBYEN+1
: CHECK NEED TO SEND MESSAGE OR NOT
  IF	TBYEN			:IF > 1 ENTRY
        LH      R8,SORD,RHP,RHP :get sord number
	LHL	R5,TBYPTR,R8,R8	:GET MESSAGE ADDR FOR THIS SORD		
	LA	R3,.S4,R5,
  ELSE	
	LA	R3,TBYM,,
  EI
	LB	R2,0,R3		:CHECK MSG COUNT	
	JE	ISFLSH		:NO MESSAGE
  IF	OP|E8BTM.|		::2.06 - CAB - TBYEMS FIX
	RBT	RIP,IP8BM	::CLEAR MSG MASKING FOR TERM INIT MSG
  EI
	LR	R2,RIP
	JAL	R5,OCS
  IF	OP|E8BTM.|		::2.06 - CAB - TBYEMS FIX
	TBT	RHP,E8BTMP	::NEED TO RESTORE MASKING?
	JE	ISFLSH
	SBT	RIP,IP8BM	::RESTORE MSG MASKING AFTER TERM INIT MSG
  EI
 EI 
        J       ISFLSH          :DONE WITH S-MODE STUFF

ISDXRQ  RBT     RIP,PIIX
        LR      R1,RIP          :TELL THEM OUR PRODID AND VERSION
        LHI     R2,CM.SIX       :START OF IIX
        LIS     R0,SIX.L
        JAL     R4,SLOR
        JAL     R4,ELOR
        LIS     R2,6            :DATA MESSAGE OF LENGTH 6
        LIS     R0,9            :LENGTH = 6+DPORT+LENGTH BYTE=9
        JAL     R4,SLOR
        LHI     R0,80           :GLOBAL MESSAGE 8086
        JAL     R4,PUTCH        :PUT THE 80
        LHI     R0,8600         :FINISH MESSAGE TYPE
        JAL     R4,PUTH
        LHI     R0,PRODID*100+VERSIO :PUT BOTH
        JAL     R4,PUTH
        LIS     R0,REVLEV       :REVISION LEVEL
        JAL     R4,PUTCH
        JAL     R4,ELOR
        J       ISFLSH

	SUBTTL	ISIS CTL MSG PROCESSORS
:	I S I S   C O N T R O L   M S G   P R O C E S S O R S
:	=====================================================

: ISIS CONTROL MESSAGE BRANCH ADDRESS TABLE

        SEG     A.RTBL
ICRCOM  HC      0	        :09E DETACH
        HC      ICZAP-.S        :09F ZAPPER
        HC      ICNOS-.S        :0A0 APPLY BP
        HC      ICSND-.S        :0A1 RELEASE BP
        HC      ICGOB-.S        :0A2 FLUSH FORWARD
        HC      ICBKG-.S        :0A3 FLUSH BACKWARD
        HC      ICBLK-.S        :0A4 BLACK BALL
        HC      ICGRY-.S        :0A5 GREY BALL
        HC      ICEDE-.S        :0A6 ENTER DEFERED ECHO
        HC      ICLDE-.S        :0A7 LEAVE DEFERED ECHO
        HC      0               :0A8 ENTER TRANSPARENCY
        HC      0		:0A9 LEAVE TRANSPARENCY
        HC      ICGRN-.S        :0AA GREEN BALL
        HC      ICRED-.S        :0AB RED BALL
        HC      ICYEL-.S        :0AC YELLOW BALL
        HC      0	        :0AD ORANGE BALL
        HC      ICBRK-.S        :0AE BREAK
        HC      0               :0AF HANG UP
        HC      0		:0B0 QUERY TERMINAL
        HC      ICSTP-.S        :0B1 SET TERMINAL
        HC      ICPSN-.S        :0B2 PSEUDO NEEDLE
        HC      0               :0B3 LOGON CHAR
        HC      ICLGST-.S       :0B4 LOGON STATUS
        HC      ICLGFL-.S       :0B5 LOGON FAILURE
        HC      CIRBLT-.S       :0B6 LOGON COMPLETE
        HC      0               :0B7 ACCOUNTING ADDENDUM
        HC      0               :0B8 SUPER HANG
        HC      ICXLM-.S        :0B9 TRANSMIT LIMIT
        HC      0  	        :0BA BREAK END
        HC      0  	        :0BB ZAP ACKNOWLEDGE
        HC      0  	        :0BC ENTER ALT DEVICE MODE
        HC      0  	        :0BD LEAVE ALT DEVICE MODE
        HC      0  	        :0BE ZAP WITH REASON
        HC      ICSIX-.S        :0BF START OF IIX
        HC      ICTIX-.S        :0C0 END OF IIX

: ISIS CONTROL MESSAGE PROCESSORS

	SEG	A.CODE

:       ZAP MESSAGE

ICZAP	SBT	RIP,TOISIS	:CLEAR TO-ISIS BACKPRESSURE
	LHI     R10,AA.DBU      :DROPPED BY USER
        JAL     R6,DETIP        :DETACH ISIS PORT
	J	ISFLSH

:	APPLY BACKPRESSURE

ICNOS	RBT	RIP,TOISIS	:TURN ON BP
	J	ISFLSH

:	RELEASE BACKPRESSURE

ICSND	SBT	RIP,TOISIS	:TURN OFF BP
	J	ISFLSH

:       GOBBLER

ICGOB   HS
  IF	NAPORT
    IF	NMPORT
	TBT	RHP,SIOP	:SEE IF SIO PORT
	JNFS	ICGOB2		:BR IF SO
    EI
        JAL     R5,GOBCLR
        TBT     RHP,RXONON      :OUTPUT STOPPED WITH X-OFF?
        JE	ISFLSH          :IF SO, EXIT
        SBT     RHP,TAM         :SET DRIVER OUTPUT RING NOT FULL
	RBT	RHP,TAMR
        RBT     RHP,FDDAT       :SET DRIVER OUTPUT RING EMPTY
        J	ISFLSH
  EI
  IF	NMPORT
ICGOB2	JAL	R5,BFCLR	:CLEAR OUTPUT BUFFERS
	J	ISFLSH
  EI

:       BACK GOBBLER

ICBKG	JAL	R10,SNDGOB	:SEND GOBBLER TO ISIS
	J       ISFLSH          :ADVANCE TO NEXT

:       BLACK BALL

ICBLK  HS			:CHECK FOR MSG ON BLACK BALL
	 IF	BZFTP-1        	:IF MSG EXISTS
        TBT     R8,BZAPM,,	:AND IS ALLOWED FOR THIS PORT
        JEFS	ICBLK8          :
        LA      R3,BZFTMS,,     :THEN 
        JAL     R5,QOCS		:SEND MSG FOR BUFFER ZAP FROM TERMINAL
	 EI
ICBLK8	J	ICGRY8

:       GREY BALL

ICGRY   HS			:CHECK FOR MSG ON GREY BALL
	 IF	BZTTP-1        	:IF MSG EXISTS
        TBT     R8,BZAPM,,	:AND IS ALLOWED FOR THIS PORT
        JE      ICGRY8		:
        LA      R3,BZTTMS,,     :THEN
        JAL     R5,QOCS		:SEND MSG FOR BUFFER ZAP TOWARD TERMINAL
	 EI

ICGRY8	HS			:CHECK FOR DETACH ON DATA LOSS
	 IF	OP|DETDL.|
	TBT	R8,DETDL,,
	JEFS	ICGRYX		:IF NOT DETACH ON DATA LOSS
	JAL	R10,SNDGOB
	LHI	R10,AA.NDC	:DROPPED BY HOST
	JAL	R6,DETIP
  	 EI	

ICGRYX	J	ISFLSH
      

:       ENTER DEFERED ECHO MODE

ICEDE   SBT     RHP,DEM         :SET DEFERRED ECHO MODE
        TBT     RHP,TRANSP
        JN      ISFLSH          :IF THIS PORT IS TRANSPARENT
  IF    HDN+1           	:IF HOST CONTROLS DEFERED ECHO MODE
   IF   HDN             	:IF >1 ENTRY
        LB      R0,HD|EDEC|SV,R8,
   ELSE
        LHI     R0,HD|EDEC|SV
   EI
        J       ICL010          :GO SEND IT
  ELSE
	J	ISFLSH
  EI    (HDN+1)

:       LEAVE DEFERED ECHO MODE

ICLDE   RBT     RHP,DEM         :CLEAR DEFERRED ECHO MODE
        TBT     RHP,TRANSP
        JN      ISFLSH          :IF THIS PORT IS TRANSPARENT
  IF    HDN+1           	:IF HOST CONTROLING DEFERRED ECHO MODE
   IF   HDN             	:IF >1 ENTRY
        LB      R0,HD|LDEC|SV,R8,
   ELSE
        LHI     R0,HD|LDEC|SV
   EI
ICL010  CLHI    R0,0FF
        JE      ISFLSH          :IF NOT ENABLED FOR THIS SORD
	JAL     R5,PCEDR        :SEND TO HOST
	JAL	R5,CHKBP	:SEE IF NEED TO BKPR
  EI    (HDN+1)
	J	ISFLSH

:       GREEN BALL

ICGRN   SBT     RHP,GBRCVD      :MARK IT RECEIVED
	LR	R8,R8		:SEE IF TOM
	JN	ISFLSH		:BR IF NOT
	LHI	R2,CM.GB	:ECHO GREEN BALL IMMEDIATELY IF TOM
	LIS	R3,GB.L
	JFS	ICBNCB

:       RED BALL

ICRED   RBT     RHP,GBRCVD      :CLEAR GREENBALLS
        LHI     R2,CM.RB
        LIS     R3,RB.L
        JFS     ICBNCB          :BOUNCE IT BACK

:       YELLOW BALL

ICYEL   LIS     R3,YB.L         :LENGTH
        LHI     R2,1,R2         :CHANGE TYPE

ICBNCB  JAL     R5,QSLOR        :SEND BALL BACK
	JAL	R4,QELOR
	J	ISFLSH

:       BREAK

ICBRK   HS
  IF	INAN+1			::2.06 - CAB - NSR 689
	LB	R7,BRKACT,R8,	::GET BREAK ACTIVITY COUNTER
	AIS	R7,1		::UPDATE IT 
	STB	R7,BRKACT,R8,	::AND SAVE IT
	CLHI	R7,BRKLIM	::REACHED LIMIT FOR CONSECUTIVE BREAKS
	JGE	DONBRK		::IF YES, GO DROP CIRCUIT
  EI
  IF    OP|BKGOB.|
        TBT     R8,BKGOB,,
        JE      ICBR10          :IF NO GOBBLE ON BREAK
	JAL	R10,SNDGOB	:SEND GOBBLER TO ISIS
ICBR10  HS
  EI
  IF    BKSN+1          	:BREAK SEND ENABLED
   IF   BKSN            	:IF > 1 VALUE
        LB      R7,BKSSV,R8,
   ELSE
        LHI     R7,BKSSV
   EI
        JE      ICBR20          :IF NOT TO SEND BRK TO HOST
   IF	NAPORT
    IF	NMPORT
	TBT	RHP,SIOP	:SEE IF SIO PORT
	JEFS	ICBR12		:BR IF NOT
	LIS	R7,1		:SEND ONLY 1 IF SIO
    EI
ICBR12  LHI     R0,AO.BRK       :BREAK
	JAL     R5,PECDR        :75 MSEC
        SIS     R7,1
        JGBS    ICBR12          :IF MORE TO SEND
   ELSE
	LHI	R0,AO.BRK	:SEND BREAK
	JAL	R5,PECDR
   EI
::  DELAY FOLLOWING BREAK
   IF   BKDN            	:IF > 1 VALUE 
        LB      R0,BKDSV,R8,
   ELSE
        LHI     R0,BKDSV
   EI
        JEFS    ICBR14          :IF NOT TO SEND DELAY TO HOST
	JAL	R5,PECDR
ICBR14	JAL	R5,CHKBP	:BP ISIS IF NEED BE
ICBR20  HS
  EI    (BKSN+1)
  IF    OP|BKDSC.|
        TBT     R8,BKDSC,,
        JE      ISFLSH          :IF NOT DISCONNECTING ON BREAK
  ELSE
	J	ISFLSH
  EI    (BKDSC)

DONBRK  HS
  IF    OP|BKDSC.|!(UDN+1)      :IF DISCONNECT ON BREAK OR A USER DSC CHAR
	JAL	R10,SNDGOB	:SEND GOBBLER TO ISIS
        LA      R3,LOFFMS,,     :LOG OFF MESSAGE
        LHI     R10,AA.DBU      :DROPPED BY USER
        JAL     R6,DETMSG       :DETACH PORT
	J	ISFLSH
  EI

:       SET TERMINAL PARAMETERS (RESPONSE FROM TYMSAT)

ICSTP   JAL	R4,GETCH	:SKIP MSG TYPE
	JAL     R4,GETCH        :GET SUBTYPE
        SIS     R11,2
        LR      R0,R0
  IF	\GPATBL
	JN	ICSTP1		:IF NOT ECHO
  ELSE
        JN      ISFLSH          :IF NOT ECHO
  EI
        JAL     R4,GETCH        :GET VALUE
        SIS     R11,1
        LR      R0,R0
        JN      ISFLSH          :IF NOT OFF, IGNORE
        RBT     RHP,ECHOP       :TURN ECHO OFF
  IF    .GE.(HECNT,NEOFFA)      :IF HOST WANTS AN ACK
        TBT     RHP,TRANSP
        JN      ISFLSH          :IF TRANSPARENT
   IF   HEN             	:IF >1 ENTRY
        LB      R0,HE|NEOFFA|SV,R8,
   ELSE
        LHI     R0,HE|NEOFFA|SV
   EI
	CLHI	R0,0FF
	JE	ISFLSH		:IF HOST DOES NOT WANT IT
	JAL	R5,PCEDR	:SEND TO HOST
	JAL	R5,CHKBP	:SEE IF NEED TO BKPR
  EI    (HECNT,NEOFFA)
	J	ISFLSH

:	SPECIAL CHECK FOR 1200 BAUD G TID TERMINALS
  IF	\GPATBL
ICSTP1	RBT	RHP,G12WT	:CLEAR WAIT FLAG
	JE	ISFLSH		:IF WE ASKED FOR RESPONSE
	CLHI	R0,09		: THEN TEST FOR PAR A
	JN	ISFLSH		: IF PARAMETER A 
	JAL	R4,GETCH	:  THEN GET VALUE
	SIS	R11,1
	CLHI	R0,0003		:  TEST IF G TID
	JN	ISFLSH

	LR	R5,R11		:SAVE COUNT
	LIS	R10,9		:  YES, SEND A,B & C (R10<=SUBTYPE)
ICSTP2	LB	R11,GPATBL-9,R10,  : GET VALUE
	JAL	R6,SNDTC
	AIS	R10,1
	CLHI	R10,000B	:LAST MESSAGE?
	JLEBS	ICSTP2		:NO, BACK FOR MORE
	LR	R11,R5		:RESTORE COUNT
	J	ISFLSH
  EI

:       RECEIEVED PSUEDO NEEDLE, CHECK IT OUT

ICPSN   JAL     R4,GETH         :SKIP MSG TYPE&ISIS-KEY
        JAL     R4,GETH         :GET LOCAL KEY
        SIS     R11,4
        LBR     RHP,R0          :GET PHYSICAL PORT NUMBER
        STH     RIP,IPN,RHP,RHP :SET UP MAPPINGS
        STH     RHP,HPN,RIP,RIP
        SRLS    R0,8            :ISOLATE SEQUENCE NUBER
        CLB     R0,SEQKEY,RHP   :IS PSN GOOD?
        JEFS    ICPSN1          :SKIP IF OK
        JAL     R6,DETIP        :KILL PORT
        J       ISFLSH          :NEXT PORT
ICPSN1  SBT     RHP,ACP         :RAISE DTR
        RBT     RHP,LOGSTX      :NOW WAIT FOR STX TO START LOGON STRING
        SBT     RHP,LOGING
        J       ISFLSH          :NOW READY FOR LOGONSTRING

:       LOGON STATUS (WHICH IS A FAILURE UNLESS IT IS CONTINUE)

ICLGST  JAL     R4,GETCH        :SKIP MSG TYPE
        JAL     R4,GETCH        :GET STATUS CODE
        SIS     R11,2           :UPDATE COUNT
        LR      R9,R0           :COPY MESSAGE TYPE
        NHI     R9,1F           :ONLY STATUS BITS MATTER
        LHL     R10,LSMSTA,R9,R9 :GET LOGON STATUS MSG FROM TABLE
        JE      ISFLSH          :NO MSG SO OK AND CONTINUE
        AI      R10,SEG4        :MAKE ACTUAL ADDRESS
        JAL     R6,PMSDR        :OUTPUT SC STRING TO ASYNC RING
        LB      R0,FLTCHF,RHP,  :LOGON FAILURE CHAR
        JAL     R5,PDCDR
        LHI     R0,20,R9        :BYTE VALUE IS 20HEX + STATUS
        JAL     R5,PDCDR
        JAL     R6,DETIP        :DETACH PORT SINCE LOGON STRING WASN'T RIGHT
        J       ISFLSH


:       LOGON FAILURE MESSAGE  (for file transfer)  *300.sdw

ICLGFL  JAL     R4,GETCH        :SKIP MESSAGE TYPE
        JAL     R4,GETCH        :GET FAILURE NUMBER
        SIS     R11,2           :TWO CHARACTERS READ
        LR      R9,R0           :ABLE TO INDEX NOW
        LHL     R10,LFMSTA,R9,R9 :GET ADDRESS OF FAILURE MSG TO SEND HST
        JEFS    ICLGF1          :NO MESSAGE BUT STILL FAILED
        AI      R10,SEG4        :MAKE ACTUAL ADDRESS
        JAL     R6,PMSDR        :SEND THE SC STRING TO ASYNC RING
ICLGF1  LB      R0,FLTCHF,RHP,  :logon failure char
        JAL     R5,PDCDR
        LR      R0,R9           :FAILURE REASON
        JAL     R5,PDCDR
        JAL     R6,DETIP        :DETACH THE PORT
        J       ISFLSH

:       LOGON SUCCESSFUL

CIRBLT  SBT     RIP,TOISIS      :OK TO SEND
        SBT     RIP,TOISON
        SBT     RIP,FRISIS
        RBT     RIP,PIBUF
        RBT     RHP,LOGING      :NO LONGER LOGGING IN
        LB      R0,FLTCHC,RHP,  :circuit built char
        JAL     R5,PDCDR        :to tell em circuit is built
        LIS     R0,ADA.L
        LHI     R2,CM.ADA       :ACCOUNTING FOR ORIGINATION
        LR      R1,RIP
        JAL     R4,SLOR
        JAL     R4,PUTCH        :UNUSED BYTE
        LHL     R0,ASYSTA,RHP,RHP :PHYS UNIT ADJUST FACTOR
        OI      R0,0E0090000    :ORIGINATION PORT
        JAL     R4,PUTW
        JAL     R4,ELOR
        J       ISFLSH

:       SET TRANSMIT LIMIT

ICXLM   JAL	R4,GETCH	:SKIP MSG TYPE
	JAL     R4,GETCH        :GET XMIT LIMIT
        SIS     R11,2           :UPDATE COUNT
        STB     R0,XLIMIT,RIP   :SET IT
	J	ISFLSH

:  iix handlers for s-mode  *300.sdw
ICSIX   SBT     RIP,PIIX        :following data is iix msg
        RBT     RIP,PIIXN0      :RESET COUNT
        RBT     RIP,PIIXMG      :NOT YET FOUND IIX MSG TYPE
        J       ISFLSH

ICTIX   RBT     RIP,PIIX        :finished with iix msg
        J       ISFLSH

	SUBTTL	NEEDLE PROCESSOR

:	N E E D L E   P R O C E S S O R
:	===============================

: NEEDLE RECEIVED FOR NEW LOGIN FROM ISIS SIDE

ISNDL   JAL	R4,GETH		:GET LENGTH
	LR	R11,R0		:SAVE IT
	STH     R14,IRSAVE      :SAVE INPUT RING REGISTER
        JAL     R4,GETW         :SKIP INVOICE #
        JAL     R4,GETH         :GET HOST #
        LR      R8,R0           :SAVE IT
        JAL     R4,GETH         :GET ORIG. NODE #
        LR      R5,R0           :SAVE IT
        JAL     R4,GETW         :SKIP ORIG HOST / PORT
        JAL     R4,GETW         :SKIP RESERVED WORD
        JAL     R4,GETH         :GET DIALECT
        STH     R0,IXTEMP       :SAVE DIALECT
        JAL     R4,GETCH        :GET TID
        LR      R6,R0           :SAVE IT
	SBT	RIP,TOISIS	:CLEAR TO-ISIS BACKPRESSURE
	RBT	RIP,PIBUF	:CLEAR BUFFERING INDICATOR
	SBT	RIP,FRISIS	:CLEAR FROM-ISIS BACKPRESSURE
	RBT	RIP,TOISON	:NOT READY FOR OUTPUT TO ISIS

:       SEARCH FOR HOST # IN HOST NAME/NUMBER TABLE.

        LHI     R1,7F7F         :SET PARITY MASK
        LIS     R13,0
ICN010  LH      R15,HNT,R13,    :GET A DESTINATION HOST ORDINAL
        JLFS    ICN020          :IF END OF TABLE
        STH	R15,HODNL
	LHL     R0,HOSTS,R15,R15 :GET HOST #
        CR      R0,R8
        JE      ICNS10          :IF SAME HOST
        AIS     R13,HNTE.L      :ADVANCE TO NEXT ENTRY
        JBS     ICN010          :CONTINUE SEARCH

:       THIS USER IS NOT VALID, INFORM AND DETACH

ICN020  LH      R14,IRSAVE      :RESTORE IRING
	LCS	R7,1		:NO HOST PORT YET
        LA      R5,ILUNMS,,     :ILLEGAL USER NAME
        JAL     R6,TOMMSG       :TELL TOM
	LCS	RHP,1		:NO HOST PORT
        LA      R3,ILUNMS,,     :ILLEGAL USER NAME MSG
        LHI     R10,AA.UNR      :USERNAME REJECT
        JAL     R6,DETMSG       :OUTPUT MESSAGE AND DETACH
	J	ISFLSH
	
:       CHECK ALL SUBHOSTS FOR THIS HOST

ICNS10  JAL     R4,GETCH        :USERNAME SIZE (INCLUDING TERMINATOR)
        LR      R7,R0           :SAVE SIZE
        SIS     R7,1            :REMOVE TERMINATOR COUNT
        LIS     R0,0
        STH     R0,FLAGS        :FLAG NO SHUT OVERRIDE
        JAL     R4,GETCH        :1ST CHAR OF USERNAME
        CLHI    R0,0A1          :SHUT OVERRIDE?
        JNFS    ICNS20          :IF NOT !
        SIS     R7,1            :COUNT !
        STH     R0,FLAGS        :FLAG SHUT OVERRIDE
        JAL     R4,GETCH        :GET ACTUAL 1ST CHAR
ICNS20  HS
  IF    SNDXN+1
        LH      R8,SINDXP,R15,R15 :GET POSITION OF INDEX
  ELSE
        LHI     R8,SNDX0
  EI
        JE      ICN030          :IF NO SUBHOST INDEX CHECKING
        JGFS    ICNS50          :IF CHECKING FROM START OF USERNAME
        LCS     R4,1
        XR      R8,R4
        LR      R4,R7
        SR      R4,R8
        LR      R8,R4           :WE NOW HAVE POSITION FROM FRONT
ICNS50  CR      R7,R8           :IS SIZE<=POSITION OF INDEX?
        JLE     ICN020          :IF ILLEGAL USERNAME
        JFS     ICNS70

ICNS60  JAL     R4,GETCH
ICNS70  SIS     R8,1
        JGBS    ICNS60          :IF NOT POSITIONED YET
ICNS80  NHI     R0,7F           :REMOVE PARITY FROM CHAR
        EXBR    R7,R0
        JAL     R4,GETCH        :NEXT CHAR OF SUBHOST INDEX
        NHI     R0,7F
        OR      R7,R0
ICNS90  LHL     R0,HNT+2,R13,
        JE      ICN030          :IF NULL SUBHOST INDEX
        LR      R1,R0
        XHI     R1,4040         :CONVERT TO UPPER CASE
        NHI     R1,4040         :*AND STRIP PARITY
        SRLS    R1,1
        OHI     R1,5F5F
        NR      R0,R1
        CLR     R0,R7           :FOUND THIS USERNAME?
        JEFS    ICN030          :IF A HIT
        AIS     R13,HNTE.L
        LH      R2,HNT,R13,     :HOST NUMBER FOR NEXT ENTRY
        JL      ICN020          :IF END OF TABLE, ILLEGAL USER NAME
        CR      R2,R15  
        JE      ICNS90          :IF SAME HOST, CONTINUE
        J       ICN020          :ILLEGAL USER NAME

:       FOUND A MATCH,
:       GET A PORT ON A SUBHOST
:       IF      SUBHOST NOT SHUT OR DOWN
:       AND     SUBHOST HAS CANDIDATE PORT
:       THEN    SET PORT NOT A CANDIDATE
:               BACKPRESSURE TOPORT UNTIL LOGIN COMPLETE
:               PORT STATUS ARRAYS SET UP

ICN030  LH      R14,IRSAVE      :RESTORE IRING TO BEFORE INVOICE
        LH      R8,HNT+4,R13,   :GET SUBHOST ORDINAL NUMBER

:       CHECK BARNODES LIST.  R5=ORIG. NODE #

  IF    BNN+1   :IF ENABLED
   IF   BNN     :IF >1 ENTRY
        LB      R2,BNPTR,R8,
        AR      R2,R2
   ELSE
        LIS     R2,0
   EI
ICNB10  LH      R1,BN0SV,R2,    :GET NODE #
        JE      ICNBOK          :IF END OF LIST, NODE OK
        JLFS    ICNB30          :IF OK NODE LIST (NOT BAR)
        CR      R1,R5
        JEFS    ICNBAR          :IF ON LIST, BAD NODE
        AIS     R2,2
        JBS     ICNB10

:       CHECK OK LIST INSTEAD.

ICNB20  LH      R1,BN0SV,R2,
        JE      ICNBAR          :IF NOT ON LIST, BAD NODE
ICNB30  NHI     R1,07FFF        :GET NODE #
        CR      R1,R5
        JE      ICNBOK          :IF ON LIST, OK NODE
        AIS     R2,2
        JBS     ICNB20

:       FOUND A BAD NODE GIVE MESSAGE AND DETACH

ICNBAR  LR	R7,R8		:NO HOST PORT, USE SORD
	LA      R5,ANPMS,,      :ACCESS NOT PERMITTED MSG
        JAL     R6,TOMMSG       :TELL TOM
	LCS	RHP,1		:NO HOST PORT
        LA      R3,ANPMS,,
        LHI     R10,AA.COR      :CIRCUIT ORIGIN REJECT
        JAL     R6,DETMSG       :INFORM USER AND DETACH
	J	ISFLSH
  EI    (BNN+1)

ICNBOK  TBT     R8,SDOWN        :SUBHOST DOWN?
        JEFS    ICN040          :IF NOT
        LA      R3,HDNMS,,      :SUBHOST DOWN MSG
        LHI     R1,HDNP         :HOST NAME POSITION
        LHI     R10,AA.HDN      :HOST DOWN
        J       ICN200          :OUTPUT MSG AND DETACH

ICN040  TBT     R8,SSHUT        :SUBHOST SHUT?
        JE      ICN050          :IF NOT
        LA      R3,HSHMS,,      :SUBHOST SHUT MESSAGE
        LHI     R1,HSHP         :NAME POSITION
        LHI     R10,AA.HSH      :HOST SHUT
        LHL     R4,FLAGS        :OVERRIDE?
        JE      ICN200          :IF NO, ISSUE AND DETACH
        LI      R2,HOSTIS       :"HOST"
        ST      R2,HSHP,R3      :HOST IS SHUT
	LR	R2,RIP
        JAL     R5,OCS          :TELL USER SUBHOST IS SHUT

:       SUBHOST IS UP, FIND PORT SPEED USING TID

ICN050  LCS     R7,VIDT.L       :VID TABLE ENTRY LENGTH
        LR      R4,R6           :COPY TID
        NHI     R4,0DF          :REMOVE HALF DUPLEX BIT
ICN060  AIS     R7,VIDT.L
        LB      R3,VIDTT+3,R7,  :GET NEXT TID IN TABLE
        JE      ICN290          :IF END OF TABLE, NO TYPE MATCH
        CLR     R3,R4           :TID MATCH?
        JNBS    ICN060          :IF NOT, CONTINUE SEARCH
        NHI     R3,1F           :LOWER 5 BITS ONLY
        LHI     R5,NHPGRP*2     :NUMBER OF SUBHOST GROUPS
        MHR     R5,R3           :GET PORT TYPE INDEX
        LHI     R10,AA.NPA      :INIT TO NO PORTS AVAILABLE

:       SEE IF THERE IS A PORT FOR THIS TYPE AVAILABLE FOR ASSIGNMENT.

        LIS     R15,0
        LHI     R4,NHPGRP*2
        MHR     R4,R8           :SUBHOSTGROUPS*SORD=TABLE INDEX
ICN070  LCS     R0,1            :MASK FOR CHECKED PORTS
ICN080  LH      R1,CAN,R15      :CANDIDATE FOR ASSIGNMENT?
        NH      R1,HPTS,R4,R15  :FOR THIS HOST?
        NR      R1,R0           :AND NOT ALREADY CHECKED
        JFFOH   R1,ICN090       :IF YES
        AIS     R15,2           :NEXT GROUP
        CLHI    R15,NHPGRP*2    :LOOKED AT ALL PORTS?
        JLBS    ICN070          :IF MORE TO GO
        J       ICN300          :NO PORTS AVAILABLE OR NO TYPE MATCH

:       FOUND A CANDIDATE FOR THIS HOST, SET IT UP.

ICN090  LR      R1,R15
        SLHLS   R1,3
        AR      R1,R2           :BIAS TO PORT NUMBER
        XH      R0,HMASK,R2,R2  :MARK PORT SERVICED
        LHI     R10,AA.NTM      :SET TO NO TYPE MATCH
        TBT     R1,PTYPE,R5,
        JE      ICN080          :IF NOT SAME TYPE, CONTINUE
	LIS	R3,0
	LR	R8,R8		:SEE IF TOM
	JE	ICN094		:BR IF SO
	LB      R3,PSPEED,R1,   :GET PORT SPEED VALUE
        CLHI    R3,SF-2000
        JNFS    ICN092          :IF SINGLE SPEED PORT
        LB      R3,VIDTT+1,R7,  :GET BAUD RATE
        NHI     R3,0F
ICN092	HS
  IF	NMPORT
	TBT	R1,SIOP		:SEE IF SIO PORT
	JEFS	ICN093		:BR IF NOT
	CLHI	R3,SB-2000	:SEE IF BAUDOT
	JNFS	ICN094
	LIS	R3,S14-2000	:SET TO 75 BAUD BAUDOT
	JFS	ICN094
  EI
ICN093	TBT	R3,A.SPED,,	:SEE IF BAUD RATE SUPPORTED ON THIS NODE
	JE	ICN080		:BR IF NOT
ICN094	STB	R3,BRATE,R1	:SAVE BAUD RATE
        STH     R8,SORD,R1,R1   :SAVE SUBHOST ORD #
        RBT     R1,CAN          :MARK TAKEN
        SBT     R1,WATHST       :SET WAITING-FOR-HOST-ANSWER FLAG
        RBT     R1,TOPTON       :TURN PORT OUTPUT OFF
        STB     R7,TERMT,R1     :SAVE TYPE INDEX
        JAL     R3,STC          :SET TERMINAL CHARACTERISTICS

:       SET UP PORT STATUS

        LH      R3,HPN,RIP,RIP
        JLFS    ICN095          :IF HPN NOT ALREADY ASSIGNED
        TRAP(R10,26)
ICN095  LH      R3,IPN,R1,R1
        JLFS    ICN096           :IF IPN ENTRY DOES NOT EXIST
        TRAP(R10,26)
ICN096  STH     R1,HPN,RIP,RIP  :SAVE HOST PORT NUMBER
	LR	RHP,R1
        STH     RIP,IPN,R1,R1   :PUT ISIS PORT NMBR IN HOST PORT TABLE
	LH	R1,HODNL	:BUILD HNPN TABLE
	STH	R1,HNPN,RHP,RHP	:
	LR	R1,RIP		:
  IF	OP|E8BTM.|
	TBT	RHP,E8BTMP	:8 BIT MODE?
	JEFS	ICN098		:IF NOT
	SBT	RIP,IP8BM
	SBT	RHP,HP8BM	
ICN098	HS
  EI
	AR	R1,R1
        JAL     R4,EMPTY        :FLUSH TOISIS DIRECTION
	JAL	R5,RGCLR	:CLEAR ASYNC RINGS
        LHI     R0,ADA.L        :ACCOUNTING ADDENDUM
        LHI     R2,CM.ADA
	LR	R1,RIP
        JAL     R4,SLOR
        JAL     R4,PUTCH        :PAD
        LR      R0,RHP
        AI      R0,AA.HPN       :ACTUAL PORT # ACCOUNTING ADDENDUM
        JAL     R4,PUTW
        JAL     R4,ELOR


:	CHECK SPECIAL GTID

 IF 	\GPATBL			:IF ENABLED
	RBT	RHP,G12WT	:RESPONSE FLAG
	LB	R7,TERMT,RHP	:GET TYPE INDEX
	LB	R5,VIDTT+3,R7,	:GET TID
	CLHI	R5,00C4		:G ID AT 300 ?
	JE	ICN098		:YES, SEND PARAMETERS

	CLHI	R5,00CC		:IF 1200 BAUD TERMINAL
	JN	SOPMS
	LR	R1,RIP		:THEN WE MUST QUERY FOR PARAMETER A
	LHI	R2,CM.QTP	:  IN ORDER TO VERIFY THAT USER IS
	LIS	R0,QTP.L	:  USING G TID AT THIS RATE.
	JAL	R4,SLOR		:ASK FOR IT
	LHI	R0,09		:PARAMETER A SUBTYPE
	JAL	R4,PUTCH
	JAL	R4,ELOR
	SBT	RHP,G12WT	:WAIT FOR RESPONSE
	J	SOPMS
  
ICN098	HS  
	LIS	R5,0
	LIS	R10,8
ICN099	AIS	R10,1
	LB	R11,GPATBL,R5,	
	JAL	R6,SNDTC
	AIS	R5,1
	CLHI	R5,2
	JLEBS	ICN099
  EI

:       SEND OPERATOR MESSAGE.

SOPMS   LH      R3,HOPMSP,R8,R8
        JEFS    ICN100          :IF NO MESSAGE
        AI      R3,HOPMS        :BIAS MSG PTR
	LR	R2,RIP
        JAL     R5,OCS          :SEND MESSAGE TO USER

ICN100	LR	R8,R8		:SEE IF TOM
	JE	TOMNDL		:BR IF SO

: SEND TID CHARS

	LB      R0,BRATE,RHP
        AHI     R0,AO.IBR
        JAL     R5,PEEDR        :SET INPUT BAUD RATE
        AHI     R0,AO.OBR-AO.IBR
	SBT	RHP,TOPORT	:FORCE BUFFERING OF OUTPUT (FLAKEY)
        JAL     R5,PECDR        :SET OUTPUT BAUD RATE

:       SEND TERMINAL ID CHAR PAIR

  IF    STIN+1  		:IF ENABLED
        TBT     R8,TICAP,,
        JNFS    XLG015          :IF SENDING ON ALL PORTS
        LB      R0,PSPEED,RHP,  :GET PORT SPEED AGAIN
        CLHI    R0,0FF
        JN	SNDNDL          :IF NOT AUTOBAUD, DO NOT SEND TIC
XLG015	LB	R7,TERMT,RHP	:GET TYPE INDEX
   IF   STIN    		:IF >1 VALUE
        LH      R6,STIPTR,R8,R8 :GET POINTER INTO CHARACER TABLE
   ELSE
        LIS     R6,0
   EI
        LB      R7,VIDTT+3,R7,  :GET TID
        NHI     R7,1F           :5 BITS ONLY
   IF   STIMAX-$00FF    	:IF 2 CHARACTERS
        AR      R7,R7
   EI
        LB      R0,TI0SV,R6,R7  :GET FIRST CHARACTER
        JEFS    XLG020          :IF NULL
        JAL     R5,PCDR         :SEND IT ALONG
   IF	STIMAX-$00FF
	LHI	R0,$A15		:WAIT A HALF SEC
	JAL	R5,PECDR	:DELAY SO HOST CAN TELL CHARS APART
   EI
XLG020  HS
   IF   STIMAX-$00FF    	:IF 2 CHARS
        LB      R0,TI0SV+1,R6,R7  :GET 2ND CHAR
        JEFS    XLG030          :IF NULL
        JAL     R5,PCDR         :SEND 2ND ALONG
XLG030  HS
   EI
        LHI     R0,$A30         :NOW WAIT ABOUT 1 SEC
        JAL     R5,PECDR        :SEND DELAY SO HOST CAN REACT
  EI    (STIN+1)

: SEND NEEDLE TO HOST

:       ISIS RING POINTS TO START OF INVOICE # ON ENTRY

SNDNDL  HS
  IF    OP|GINDL.|
        TBT     R8,GINDL,,
        JE      SKPNDL          :IF SKIPPING NEEDLE FOR THIS SORD
        LIS     R0,0 		:SEND PORT #
        JAL     R5,PNEDL
        LR      R0,RIP
        JAL     R5,PNEDL
        LIS     R0,0            :SEND LENGTH
        JAL     R5,PNEDL
        LR      R0,R11
        JAL     R5,PNEDL
	LHI	R9,14
SNN10	JAL     R4,GETCH	:SEND REST OF NEEDLE
	LBR	R11,R0
        JAL     R5,PNEDL
	SIS	R9,1
	JGBS	SNN10
        JFS     SNDLOS          :GO SET PARITY
  EI    (GINDL)

:       SKIP NEEDLE

SKPNDL  JAL     R4,GETW         :INVOICE
        JAL     R4,GETW         :DEST. HOST, ORIG. NODE
        JAL     R4,GETW         :ORIG. HOST AND PORT
        JAL     R4,GETW         :RESV. WORD
        JAL     R4,GETW         :DIALECT, TID, UNAME SIZE
	LBR     R11,R0          :UPDATE COUNT

: SEND LOGON STRING

SNDLOS  LB      R2,TERMT,RHP    :GET TERMINAL TYPE TABLE INDEX

:       SEND 2741 HOST INIT CHAR FIRST

  IF    .GE.(T27CNT,HIC27)      :IF CHAR EXISTS
        CLHI    R2,VIDNA
        JL      SLS010          :IF ASCII TERMINAL
   IF   T27N            	:IF>1 VALUE
        LB      R0,T27|HIC27|SV,R8,
   ELSE
        LHI     R0,T27|HIC27|SV
   EI
        JEFS    SLS010          :IF NO CHARACTER
	JAL     R5,PCEDR        :SEND INIT CHAR
SLS010  HS
  EI

  IF    LGSN+1          	:IF ENABLED
   IF   LGSN            	:IF >1 ENTRY
        LHL     R5,LGSPTR,R8,R8
        LA      R10,.S4,R5,
   ELSE
        LA      R10,LGSM,,
   EI
        JAL     R6,PMSDR        :SEND LOGON STRING
  EI    (LGSN+1)

: PASS USERNAME ON TO HOST PROTOCOL HANDLER

PASUNM  HS
  IF    OP|GUNAM.|
        TBT     R8,GUNAM,,
        JE      SUN010          :IF USERNAME NOT DESIRED
PUN010  JAL     R4,GETCH        :GET USERNAME CHAR
        JAL     R5,PPCDR        :PASS IT ON
        SIS     R11,1
        JGBS    PUN010          :UNTIL ALL COPIED
        J       SUN020          :ECHO TERMINATOR
  EI

:       SKIP USERNAME

SKPUNM  HS
SUN010  JAL     R4,GETCH        :GET USERNAME CHAR
SUN015  SIS     R11,1
        JGBS    SUN010          :UNTIL ALL SKIPPED

:       ECHO TERMINATOR

SUN020	JAL	R5,CHKBP	:BP ISIS IF NEED BE
	LR      R7,R0           :SAVE TERMINATOR
	LR	R1,RIP
	LIS     R0,5
        JAL     R4,SLOR         :START OUTPUT RECORD
        LR      R0,R7
        NHI	R0,007F		:MASK HIGH BIT
	JAL     R4,PUTCH
        NHI     R7,7F
        CLHI    R7,0D           :CR?
        JNFS    SUN030          :IF NOT CR
        LIS     R0,0A           :LF
        JAL     R4,PUTCH
SUN030  JAL     R4,ELODR
	LR	R8,R8		:SEE IF TOM
	JE	SNDPT2		:BR IF SO

: RING A PORT

RNGPT   SBT     RHP,RING        :TELL PROTOCOL HANDLER TO RING
        RBT     RHP,RNGCUP      :CLEAR CONSTANT RING INDICATOR
  IF    RNGTN-1         	:IF > 1 ENTRY
        LB      R0,RNGTSV,R8,   :RING TIMEOUT VALUE
  ELSE
        LHI     R0,RNGTSV
  EI
        LHI     R1,RNGAT-.S     :WHERE TO GO ON ANSWER OR TIMEOUT
        JAL     R2,PTMQUE       :QUEUE TIMEOUT
        J       ISFLSH          :WAIT UNTIL DEQUED

: CHECK FOR RING ANSWERED OR TIMED OUT

RNGAT	LH	RIP,IPN,RHP,RHP	:GET ISIS PORT NMBR
	JLE	PTMRET		:IF NONE
	TBT     RHP,SIN
        JE      DTRPAU          :IF HOST DID ANSWER
        RBT     RHP,WATHST      :CLEAR WAITING-FOR-HOST-ANSWER FLAG
        RBT     RHP,RING        :CLEAR RING FLAG
	LCS	R0,1		:REMOVE CONNECTION BETWEEN
	STH	R0,HPN,RIP,RIP	:*HOST AND ISIS PORTS
	STH	R0,IPN,RHP,RHP
        LHI     R10,AA.NPA      :NO PORTS AVAILABLE ACTNG ADDENDUM
  IF    RNAP                    :IF MESSAGE DESIRED
        LR      R7,RHP          :GET HPN
        LIS     R4,3            :SIZE OF FIELD
        LHI     R8,PMRAD        :GET RADIX
        LA      R5,RGNAMS+RNAP  :ADDR TO PUT PORT NUMBER
        JAL     R6,CBA          :CONVERT BINARY TO ASCII
	LHL	R8,SORD,RHP,RHP	:GET SORD
	LR	R7,R8
        LA      R5,RGNAMS       :RING NO ANSWER MSG
        JAL     R6,TOMMSG       :TELL TOM
        LA      R3,RGNAMS       :RING NO ANSWER MSG
        JAL     R6,DETMSG       :DETACH ISIS PORT
  ELSE
	LHL	R8,SORD,RHP,RHP	:GET SORD
        JAL     R6,DETIP        :DETACH ISIS PORT
  EI
	J	PTMRET

: PAUSE FOR HOST

DTRPAU  HS
  IF    INAN+1          	:IF ENABLED
        LIS     R0,0
        STB     R0,INACT,RHP,   :FLAG ACTIVITY
  EI
  IF    DTRPN           	:IF > 1 ENTRY
	LHL	R8,SORD,RHP,RHP
        LB      R0,DTRPSV,R8,   :DTR PAUSE TIME VALUE
  ELSE
        LHI     R0,DTRPSV
  EI
        LHI     R1,SENDPT-.S    :DTR TIMEOUT RETURN ADDRESS
        JAL     R2,PTMQUE       :WAIT UNTIL TIME PASSES
        J       PTMRET

: SEND PORT NUMBER TO USER

SENDPT	LH	RIP,IPN,RHP,RHP :GET HOST PORT #
	JLE	PTMRET
SNDPT2	SBT     RHP,TOPTON      :REMOVE TOPORT BACKPRESSURE
  IF    PNP             	:IF MESSAGE DESIRED
        LR      R7,RHP		:GET HOST PORT #
        LA      R5,SPTMS+PNP    :ADDRESS TO SAVE PORT #
        LIS     R4,3            :FIELD SIZE FOR PORT #
        LHI     R8,PMRAD        :OUTPUT IN HEX
        JAL     R6,CBA          :CONVERT BINARY TO ASCII
	LR	R2,RIP
        LA      R3,SPTMS        :PORT MESSAGE
        JAL     R5,OCS          :OUTPUT CANNED STRING
  EI

: SEND GREETING MSG TO USER

SNDGRT  LHL	R8,SORD,RHP,RHP	:GET SUBHOST ORDINAL
  IF    1+GRTP
   IF   GRTP
	LR	R6,R8
        AR      R6,R6           :SUBHOST ORD * 2
        L       R7,HGRT,R6,R6   :GET GREETING
        JEFS    SENDTC          :IF NONE
        ST      R7,HGRTMS+GRTP  :SAVE IT
   ELSE
	JNFS	SNDG10		:BR IF NOT TOM
	L	R7,HGRT+4*TOM,,
	ST	R7,TGRTMS+1
        LA      R3,TGRTMS       :TOM GREETING
	JFS	SNDG20
   EI
SNDG10	LA	R3,HGRTMS	:HOST GREETING
  ELSE
	JNFS	SENDTC		:BR IF NOT TOM
	L	R7,HGRT+4*TOM,,
	ST	R7,TGRTMS+1
	LA	R3,TGRTMS	:TOM GREETING
  EI
SNDG20	LR	R2,RIP
	JAL     R5,OCS          :OUTPUT IT

: SEND TERMINAL CHARACTERISTICS TO TYMSAT

SENDTC  RBT     RIP,PIIX
        LH      R0,IXTEMP       :was this from a iix capable?
        JGE     STC005          :skip if not
        LR      R1,RIP          :send possible dialects
        LHI     R2,CM.SIX       :start of IIX
        LIS     R0,SIX.L
        JAL     R4,SLOR
        JAL     R4,ELOR
        LA      R3,SLIXMS,,     :the dialects we speak
  IF	OP|E8BTM.|		: NO PARITY TIME
	RBT	RIP,IP8BM	::CLEAR MSG MASKING FOR TERM INIT MSG
  EI
	LR	R2,RIP
	JAL	R5,OCS
  IF	OP|E8BTM.|		::NO PARITY TIME
	TBT	RHP,E8BTMP	::NEED TO RESTORE MASKING?
	JEFS	STC003		::
	SBT	RIP,IP8BM	::RESTORE MSG MASKING AFTER TERM INIT MSG
  EI
STC003  LHI     R2,CM.TIX       :terminate iix
        LIS     R0,TIX.L
        LR      R1,RIP
        JAL     R4,SLOR
        JAL     R4,ELOR
STC005  LIS     R10,0           :ECHO
        TBT     RHP,ECHOP       :ECHO OFF?
        JN      STC010          :IF ON
        LIS     R11,0           :OFF
        JAL     R6,SNDTC

:       SEND GLASS BALL IF TRANSPARENCY MODE

  IF    OP|T2741.|
        TBT     R8,T2741,,
        JE      STC055          :IF NOT TRANSPARENT 2741
        LB      R2,TERMT,RHP
        CLHI    R2,VIDNA
        JL      STC055          :IF ASCII TERMINAL
	LR	R1,RIP
        LHI     R2,CM.ETM       :ENTER TRANSPARENT MODE
        LHI     R0,ETM.L
        JAL     R4,SLOR
        JAL     R4,ELOR
	J	SNDTIC
  ELSE
        J       STC055          :SKIP REMAINING ECHO PARAMS
  EI

STC010  LIS     R11,1           :ECHO ON
        JAL     R6,SNDTC
  IF    HDN+1           	:IF HOST HANDLES DEFERRED ECHO MODE
   IF   HDN     		:IF >1 VALUE
        LB      R1,HD|EDEC|SV,R8,
   ELSE
        LHI     R1,HD|EDEC|SV
   EI
        CLHI    R1,0FF
        JEFS    STC015          :IF NOT ENABLED FOR THIS SORD
        RBT     RHP,ECHOP       :LET HOST DO THE DEFFERED ECHO
  EI    (HDN+1)
STC015  LIS     R10,2           :ECHO LFCR FOR LF
        LIS     R11,1
        TBT     RHP,ELFCRP
        JNFS    STC020          :IF ON
        LIS     R11,0           :TURN IT OFF
STC020  JAL     R6,SNDTC        :SEND IT
        LIS     R10,3           :ECHO CRLF FOR CR
        LIS     R11,1
        TBT     RHP,ECRLFP
        JNFS    STC030          :IF ON
        LIS     R11,0           :TURN IT OFF
STC030  JAL     R6,SNDTC        :SEND IT
        LIS     R10,1           :ECHO CTL-I
        LIS     R11,0
        TBT     RHP,ECTLIP
        JEFS    STC040          :IF OFF
        LIS     R11,1           :TURN IT ON
STC040  JAL     R6,SNDTC        :SEND IT
        LIS     R10,0D          :ECHO CTL-H
        LIS     R11,0
        TBT     RHP,ECTLHP
        JEFS    STC050          :IF OFF
        LIS     R11,1
STC050  JAL     R6,SNDTC        :SEND IT
STC055  LIS     R10,4           :CARRET DELAY
        LIS     R11,1
        TBT     RHP,CRDLYP
        JNFS    STC060          :IF ON
        LIS     R11,0
STC060  JAL     R6,SNDTC
  IF	OP|E8BTM.|
	TBT	RHP,E8BTMP	:ENTER 8 BIT MODE?
	JEFS	STC065
	LR	R1,RIP
	LHI	R2,CM.ETM	:NETWORK "ENTER TRANSPARENCY"MESSAGE
	LHI	R0,ETM.L
 	JAL	R4,SLOR
	JAL	R4,ELOR
	SBT	RIP,ETMFLG	:SET ENTER TRANSPARENCY MODE FLAG
STC065	HS
  EI
 IF 	TINTN+1
: CHECK NEED TO SEND MESSAGE OR NOT
  IF	TINTN			:IF > 1 ENTRY
	LHL	R5,TINPTR,R8,R8	:GET MESSAGE ADDR FOR THID SORD		
	LA	R3,.S4,R5,
  ELSE	
	LA	R3,TINM,,
  EI
	LB	R2,0,R3		:CHECK MSG COUNT	
	JEFS	STC067		:NO MESSAGE	
  IF	OP|E8BTM.|		::2.06 - CAB - TINTMS FIX
	RBT	RIP,IP8BM	::CLEAR MSG MASKING FOR TERM INIT MSG
  EI
	LR	R2,RIP
	JAL	R5,OCS
  IF	OP|E8BTM.|		::2.06 - CAB - TINTMS FIX
	TBT	RHP,E8BTMP	::NEED TO RESTORE MASKING?
	JEFS	STC067		::
	SBT	RIP,IP8BM	::RESTORE MSG MASKING AFTER TERM INIT MSG
  EI
 EI 
STC067  HS
 IF     SGRTN+1
  IF    SGRTN
        LHL     R5,GRTPTR,R8,R8 : GET MESSAGE ADDR FOR THIS SORD
        LA      R3,.S4,R5,
  ELSE
        LA      R3,SGRM,,
  EI
        LB      R2,0,R3         : CHECK MSG COUNT
        JEFS    STC070          : BRANCH IF NO MSG
        LR      R2,RIP
        JAL     R5,OCS          : GO SEND IT
 EI

STC070	HS	
  IF    OP|BKGOB.|
        TBT     R8,BKGOB,,
        JEFS    STC080	        :IF NO GOBBLE ON BREAK
        LHI     R10,11          :TERMINATE OUTPUT ON BREAK
        LIS     R11,1
        JAL     R6,SNDTC
  EI
STC080	HS
  IF	OP|RXENA.|
	TBT	R8,RXENA,,
	JEFS	SNDTIC
	LHI	R10,0E
	LIS	R11,1		:REVERSE X ENABLE
	JAL	R6,SNDTC
  EI	
: SEND 2741 TERMINAL INIT CHARACTER

SNDTIC	HS
   IF   .GE.(T27CNT,TIC27)
    IF  T27N            	:IF>1 ENTRY
        LB      R6,T27|TIC27|SV,R8,
    ELSE
        LHI     R6,T27|TIC27|SV
    EI
        JEFS	SNDTC2          :IF NO INIT CHAR
        TBT     RHP,TRANSP,,
        JEFS	SNDTC2          :IF NOT 2741 CALL
	LR	R1,RIP
        LIS     R0,4
        JAL     R4,SLOR
        LR      R0,R6
        JAL     R4,PUTCH
        JAL     R4,ELODR
   EI
SNDTC2	SBT	RIP,TOISON	:OKAY TO SEND DATA TO ISIS
	LR	R8,R8		:SEE IF TOM
	JN	PTMRET		:RTRN TO TIMOUT IF NOT
	LIS	R11,0		:DONT SKIP ANYTHING
	J	ISFLSH		:RTRN TO MSG SCANNER

: SNDTC - SEND A TERMINAL CHARACTERISTIC

SNDTC	LR	R1,RIP
	LHI	R2,CM.STP
	LIS	R0,STP.L
	JAL	R4,SLOR		:START SET-TERM-PARAM MSG
	LR	R0,R10		:WRITE SUB-TYPE
	JAL	R4,PUTCH
	LR	R0,R11		:WRITE VALUE
	JAL	R4,PUTCH
	JAL	R4,ELOR		:END MSG
        JR      R6              :DONE

: HOST DOWN OR SHUT, SEND OPERATOR MESSAGE AND DETACH

ICN200  LR      R2,R8		:SUBHOST ORD
        AR      R2,R2
        L       R2,HGRT,R2,R2   :GREETING NAME
        JNFS    ICN210          :IF GREETING EXISTS
        LI      R2,HOSTIS       :USE "HOST"
ICN210  ST      R2,0,R3,R1      :SAVE HOST NAME
        JAL     R5,QOCS         :OUTPUT SHUT/DOWN MSG
ICN250	LCS	RHP,1		:NO HOST PORT
	LH      R3,HOPMSP,R8,R8 :GET MSG PTR
        JEFS    ICN251          :IF NO MSG, JUST DETACH
        AI      R3,HOPMS        :BIAS MSG PTR
        JAL     R6,DETMSG       :SEND OPERATOR MESSAGE AND DETACH
	J	ISFLSH
ICN251	JAL	R6,DETIP	:DETACH WITHOUT MSG
	J	ISFLSH

: NO PORTS AVAILABLE, ISSUE MSG AND DETACH

ICN290  LHI     R10,AA.NTM      :NO TERMINAL MATCH
ICN300	CLHI	R10,AA.NTM	:NO TERMINAL TYPE MATCH?
	JNFS	ICN302		:IF NOT 
	LA	R5,NTMMS,,
	J	ICN310
ICN302	LR	R7,R8
	LA      R5,NPAMS,,      :NO PORTS AVAILABLE
        TBT     R8,ASPDWN
        JEFS    ICN310          :IF NOT ALL PORTS DOWN
        LA      R5,APDMS,,      :ALL PORTS DOWN MSG
ICN310  LR      R15,R5          :SAVE MSG ADDR
        JAL     R6,TOMMSG       :TELL TOM
        LR      R3,R15          :GET MSG ADDR
        JAL     R5,QOCS         :INFORM USER
        J       ICN250          :OUTPUT OPER MSG

: PNEDL - SEND NEEDLE DATA TO HOST

PNEDL	HS
  IF	OP|GNHEX.|
	TBT	R8,GNHEX,,	:SEE IF HEX FOR THIS SUBHOST
	JE	PDCDR		:GO SEND IN BINARY IF NOT
	LR	R6,R5		:SAVE RTRN ADDR
	LR	R7,R0		:SAVE BYTE TO OUTPUT
	LR	R1,R0
	SRLS	R1,4		:ISOLATE HI NIBBLE
	LB	R0,CBAASC,R1	:CONVERT TO ASCII
	JAL	R5,PPCDR	:OUTPUT CHAR
	NHI	R7,0F		:ISOLATE LO NIBBLE
	LB	R0,CBAASC,R7	:CONVERT TO ASCII
	LR	R5,R6		:RETRIEVE RTRN ADDR
	J	PPCDR		:GO OUTPUT CHAR & RTRN
  ELSE
	J	PDCDR		:GO OUTPUT BYTE IN BINARY
  EI

: STC - SET UP TERMINAL CHARACTERISTICS.
:
:       ENTRY   R3      LINK
:               R1      PORT NUMBER
:               R7      VIDTT INDEX
:               R8      SORD NUMBER
:               R6      TID

STC     SBT     R1,DEM          :START OFF IN DEFERED ECHO MODE
        RBT     R1,ECHOP
        RBT     R1,ELFCRP
        RBT     R1,ECRLFP
        RBT     R1,ECTLIP
        RBT     R1,ECTLHP
        RBT     R1,CRDLYP
        RBT     R1,HDUXP
        RBT     R1,XONP
        RBT     R1,RXONP
        RBT     R1,RNGTGP
        RBT     R1,RNGDRP
  IF    OP|PARC.|
        RBT     R1,PARCEP
        RBT     R1,PAREOP
        RBT     R1,PAREMP
  EI
  IF    ESCN+1
        RBT     R1,ESCFLG
  EI
  IF    ESCN
        RBT     R1,ESCP
        LB      R2,ESCSV,R8,    :GET ESC CHAR VALUE
        CLHI    R2,0FF
        JEFS    SET070          :IF NO ESCAPE CHAR
        SBT     R1,ESCP
SET070  HS
  EI
  IF    EOTCN+1 :IF HOST CONTROLING GREENBALLS, WAIT UNTIL EOT CHAR RECEIVED
        SBT     R1,HOSTGB
  EI
        RBT     R1,TRANSP
  IF    OP|T2741.|
        TBT     R8,T2741,,
        JE	SET080          :IF NO 2741 TRANSPARENCY FOR THIS SORD
        CLHI    R7,VIDNA
        JL      SET080          :IF ASCII TERMINAL
        SBT     R1,TRANSP       :SET TRANSPARENT 2741
        TBT	R8,RNGTG,,
	JEFS	SET075
	SBT	R1,RNGTGP
SET075	TBT	R8,RNGDR,,
	JER	R3
	SBT	R1,RNGDRP
	JR      R3              :EXIT
  EI
SET080	THI	R6,020		
        JEFS    SET090          :IF NOT
        TBT     R8,LCTLH,,
        JE      SET110          :IF CTL H = ECHO OFF
        SBT     R1,HDUXP        :SET PORT TO HALF DUPLEX
SET090  TBT     R8,ECHO,,       :THIS HOST SETTING ECHO?
        JE      SET110          :IF NO
        SBT     R1,ECHOP        :TURN ECHO ON FOR PORT
        TBT     R8,ECRLF,,      :ECHO CR/LF FOR LF?
        JEFS    SET100          :IF NO
        SBT     R1,ECRLFP
SET100  TBT     R8,ELFCR,,      :ECHO LF/CR FOR CR?
        JEFS    SET103          :IF NO
        SBT     R1,ELFCRP
SET103  TBT     R8,ECTLI,,      :ECHO CTL-I?
        JEFS    SET105          :IF NO
        SBT     R1,ECTLIP
SET105  TBT     R8,ECTLH,,      :ECHO CTL-H?
        JEFS    SET110          :IF NO
        SBT     R1,ECTLHP
SET110  TBT     R8,CRDLY,,      :CARRIAGE RETURN DELAY?
        JEFS    SET115          :IF NO
        SBT     R1,CRDLYP
SET115	HS
  IF	OP|E8BTM.|
	TBT	R8,E8BTM,,	:EIGHT BIT MODE?
	JEFS	SET118		:IF NOT
	SBT	R1,E8BTMP
SET118	HS
  EI
	TBT	R8,CTSBP,,	:CTS BP?
	JEFS	SET120		:IF NOT
	SBT	R1,CTSBPP
SET120  HS
  IF    XONN+1          	:IF ENABLED
   IF   XONN            	:IF >1 ENTRY
        LB      R2,XONSV,R8,
   ELSE
        LHI     R2,XONSV
   EI
        CLHI    R2,0FF
        JEFS    SET130          :IF NOT
        SBT     R1,XONP
SET130  HS
  EI
  IF    RXONN+1         	:IF ENABLED
   IF   RXONN           	:IF >1 ENTRY
        LB      R2,RXONSV,R8,
   ELSE
        LHI     R2,RXONSV
   EI
        CLHI    R2,0FF
        JEFS    SET140          :IF NO
        SBT     R1,RXONP
SET140  HS
  EI
  IF	PFQN+1
	RBT	R1,POLACK	:CLEAR POLLED BKPR FLAG
	RBT	R1,PFQP
   IF	PFQN
	LB	R2,PFQSV,R8,
   ELSE
	LHI	R2,PFQSV
   EI
	CLHI	R2,0FF
	JEFS	SET145
	SBT	R1,PFQP
SET145	HS
  EI
        TBT     R8,RNGTG,,      :TOGGLE RING?
        JEFS    SET150          :IF NOT
        SBT     R1,RNGTGP
SET150  TBT     R8,RNGDR,,      :DROP RING ON ANSWER?
        JEFS    SET155          :IF NOT
        SBT     R1,RNGDRP
SET155  HS
  IF    OP|PARC.|
        TBT     R8,PARC,,       :PARITY ENABLED?
        JER     R3              :IF NOT
	SBT	R1,PARCEP
        TBT     R8,PAEO,,       :EVEN/ODD
        JEFS    SET160          :IF MARK/SPACE
        SBT     R1,PAREOP
SET160  TBT     R8,PAEM,,       :EVEN/MARK?
        JER     R3              :IF ODD/SPACE, EXIT
        SBT     R1,PAREMP,,
  EI
        JR      R3              :EXIT
  IF	NMPORT
	SUBTTL	CHECK ON SIO PORTS

:	C H E C K   O N   S I O   P O R T S
:	===================================

:	CHECK IF A PREVIOUS OPERATION HAS COMPLETED IF A NEW
:	IS WAITING, AND START THE NEW OPERATION.

SIOGO	LHI	R11,(NMPGRP-1)*2 :NMBR OF SIO PORT GROUPS
SGO010	LHL	R6,SIOBP,R11	:CHECK FOR OPS PENDING
SGO015	JFFOH	R6,SGO020	:BR IF ONE FOUND
	LHL	R6,SIOP+NAPGRP*2,R11  :FORCE DATA INPUT FLAGS ON FOR SIO
	STH	R6,DFDAT+NAPGRP*2,R11 :*PORTS SO THEY WILL BE CHECKED
	SIS	R11,2		:BUMP TO NEXT PORT GRP
	JGEBS	SGO010		:BR IF NOT DONE
	JR	R10		:BACK TO EXEC

SGO020	XH	R6,HMASK,R7,R7  :MARK PORT SERVICED
	LR	R8,R11		:MAKE PORT NMBR
	SLHLS	R8,3
	AR	R8,R7
	LHL	R2,BLKPTR+NAPORT*2,R8,R8 :PNT TO SIO PORT BLOCK
	AI	R2,ASRING
	LB	R1,SIOPRO+1,R2	:SEE IF PREV OPERAION DONE
	JN	SGO015		:BR IF NOT
	LH	R4,SIOPUT,R2	:GET CUR OUTPUT BFR
	LH	R1,SIOOUT,R2,R4	:SEE IF ANY DATA TO OUTPUT
	JE	SGO030		:BR IF NOT
	LA	R1,SIOOUT,R2,R4	:MAKE OUTPUT PROGRAM
	SRLS	R1,4
	OI	R1,40000
	ST	R1,SIOPRO,R2
	LB	R0,SIOLUN,R2	:START DATA OUTPUT
	LA	R1,SIOPRO,R2
	SVC	IO,FMBOT.*10+R0
	J	SIOERR
	XHI	R4,SIOOSZ/2	:SWAP OUTPUT BUFFERS
	STH	R4,SIOPUT,R2
	LIS	R1,0		:CLEAR CHAR CNT
	STH	R1,SIOOUT,R2,R4
	LH	R0,SIOCMQ,R2	:SEE IF CMD QUEUED
	JN	SGO015		:DONE WITH PORT IF SO
SGO025	RBT	R8,SIOBP
	SBT	R8,TAM+NAPGRP*2	:CLEAR BACKPRESSURE
	J	SGO015		:GO CHECK NEXT PORT

SGO030	LH	R0,SIOCMQ,R2	:SEE IF TIMING A BREAK
	JEBS	SGO025		:NO CMD, WEIRD
	JGFS	SGO040		:BR IF SO
	AIS	R0,1
	STH	R0,SIOCMQ,R2	:BUMP BREAK TIMER
	JN	SGO015		:BR IF NOT EXPIRED
	LH	R1,SIOCMD+6,R2	:TURN OFF BREAK
	NHI	R1,0FFEF
	STH	R1,SIOCMD+6,R2
SGO040	LB	R0,SIOLUN,R2	:START COMMAND PROGRAM
	LA	R1,SIOCMD,R2
	SVC	IO,FMBOT.*10+R0
	J	SIOERR
	LIS	R0,0		:DEQUEUE COMMAND
	STH	R0,SIOCMQ,R2
	RBT	R8,SIOBP	:CLEAR BACKPRESSURE
	SBT	R8,TAM+NAPGRP*2
	J	SGO015		:GO CHECK NEXT PORT
  EI
	SUBTTL	BUFFERED DATA TO ISIS RING

:	B U F F E R E D   D A T A   T O   I S I S   R I N G
:	===================================================

:	MOVE DATA FROM TO.ISIS BUFFERS INTO ISIS RING WHEN POSSIBLE.

BUFIS	ST	R10,EXRETA	:SAVE EXEC RETURN ADDR

	LHI	R10,(NIPGRP-1)*2 :NMBR OF ISIS PORT GRPS
BFI010	LHL	R6,TOISIS,R10 	 :LOOK FOR NON-BKPRESSURED
	NH	R6,TOISON,R10	 :*AND READY
	NH	R6,TOFIT,R10	 :*PORTS THAT HAVE DATA
BFI020	JFFOH	R6,BFI030	 :BR IF ONE FOUND
	SIS	R10,2		 :BUMP TO NEXT PORT GRP
	JGEBS	BFI010		 :BR IF NOT DONE
	J	EXECRT		 :RETURN TO EXEC

:	FOUND A PORT

BFI030	XH	R6,HMASK,R7,R7	:MARK PORT SERVICED
	LR	R11,R10		:MAKE PORT NMBR
	SLHLS	R11,3
	AR	R7,R11
	LR	RIP,R7
	LB      R11,XLIMIT,RIP  :LIMIT OF CHARS WE CAN SEND AT ONCE
BFI035	JAL	R4,SPACE	:GET AMT OF ROOM IN RING
        CLHI    R0,3,R11        :SEE IF RECORD WILL FIT
	JLE	EXECRT		:FORGET IT IF NOT
	LHI	R0,3,R11	:RECORD SIZE
	LR	R1,RIP		:PORT NMBR
	JAL     R4,SLOR         :START LOGICAL OUTPUT RECORD
	AR	R1,R1		:GET BFR NMBR

:	MOVE TO ISIS RING

BFI040	JAL	R4,GCI		:GET A BUFFERED CHAR
	LR	R0,R0		:SEE IF ESCAPE
	JN	BFI070		:BR IF NOT
	JAL	R4,GCI		:GET NEXT CHAR
	LR	R0,R0
	JE	BFI070		:BR IF NULL DATA CHAR

	LR	R2,R0		:SAVE MSG TYPE
	JAL	R4,ELODR	:END PREVIOUS DATA REC
	LB	R0,LENGTH,R2,	:GET MSG LENGTH
	AIS	R0,2
	LR	R1,RIP		:ISIS PORT NMBR
	JAL	R4,SLOR		:START NON-DATA MSG
	SIS	R0,3		:REMAINING BYTE CNT OF MSG
	JLEFS	BFI060		:BR IF DONE
	LR	R7,R0		:SAVE BYTE CNT
	AR	R1,R1		:TO.ISIS BFR NMBR
BFI050	JAL	R4,GCI		:MOVE REMAINDER OF MSG TO RING
	JAL	R4,PUTCH
	SIS	R7,1
	JGBS	BFI050
BFI060	JAL	R4,ELOR		:END NON-DATA MSG
	TBT	RIP,TOFIT	:SEE IF MORE BUFFERED DATA
	JN	BFI035		:GO RE-START DATA MSG IF SO
	RBT	RIP,PIBUF	:CLEAR BUFFERING INDICATOR
	JFS	BFI090		:GO CHECK BKPR

BFI070	JAL	R4,PUTCH	:PUT CHAR TO RING
	TBT	RIP,TOFIT	:SEE IF MORE BUFFERED DATA
	JEFS	BFI080		:BR IF NOT
	SIS	R11,1		:BUMP XMIT CNT
	JG	BFI040		:BR IF MSG NOT TOO LONG
	JFS	BFI085		:MSG LONG ENOUGH, GO END IT
BFI080	RBT	RIP,PIBUF	:CLEAR BUFFERING INDICATOR
BFI085	JAL	R4,ELODR	:END DATA RECORD

BFI090	HS
  IF	XONN+1!OP|CTSBP.|		
	LH	RHP,HPN,RIP,RIP	:GET HOST PORT #
	JL	BFI020		:IF NONE
	LHL	R7,BCT,RIP,RIP	:GET CHAR CNT
	SHI	R7,XONLM	:TIME TO REMOVE BP ?
	JG	BFI020		:IF NOT TIME
	TBT	RHP,CTSBPP	:CTS BP ENABLE?
	JEFS	BFI096		:IF NOT
	SBT	RHP,CTSBPF	:TEST & SET (HOST BP OFF)
	JNFS	BFI096		:SIGNAL & DELAY ALREADY SENT
	LHI	R0,AO.RSU	:SEND SIGNAL (RING UP)
	JAL	R5,PECDR					
	LHI	R0,0F		:SEND  HALF SEC DELAY
	JAL	R5,PECDR
BFI096  TBT	RHP,XONP	:XON ENABLE?
        JEFS    BFI100          :IF NO XON
        SBT     RHP,XONON       :TEST AND SET (HOST BACKPRESSURE OFF)
        JNFS    BFI100          :XON ALREADY SENT, EXIT
	LHL	R8,SORD,RHP,RHP
   IF   XONN    		:IF >1 VALUE
        LB      R0,XONSV,R8,    :GET XON CHAR
   ELSE
        LHI     R0,XONSV
   EI
	JAL     R5,PCEDR        :SEND XON CHARACTER TO HOST
  EI    (XONN+1!OP|CTSBP.|)
BFI100	HS
  IF	PFQN+1			:IF ENABLED
	LH	RHP,HPN,RIP,RIP	:GET HOST PORT
	JL	BFI020		:IF NONE
	TBT	RHP,PFQP	:ENABLED FOR THIS HOST?
	JE	BFI020		:IF NOT
	TBT	RHP,POLACK	:NEED TO CHECK FOR BKPR?
	JE	BFI020		:BR IF NOT
	LHL	R7,BCT,RIP,RIP	:GET CHAR CNT
	SHI	R7,XONLM	:TIME TO ACK BKPR POLL?
	JG	BFI020		:NOPE
	RBT	RHP,POLACK	:CLEAR ACK NEEDED FLAG
	LHL	R8,SORD,RHP,RHP
   IF	PFQN
	LB	R0,PFASV,R8,
   ELSE
	LHI	R0,PFASV
   EI
	JAL	R5,PCEDR	:SEND BKPR ACK TO HOST
  EI
	J	BFI020		:GO GET NEXT PORT
	SUBTTL	HOST MESSAGE SCANNER

:       H O S T   M E S S A G E   S C A N N E R
:	=======================================

:	SCAN ASYNC INPUT RINGS FOR DATA, PROCESS IT, AND
:	MOVE IT TO THE ISIS OUTPUT RING.  IF THERE IS NO
:	ROOM IN THE ISIS RING, THEN BUFFER THE MESSAGES.

HOSTMS	ST	R10,EXRETA	:SAVE RETURN TO EXEC LOOP

:	CHECK FOR MESSAGES IN ASYNC INPUT RINGS

HOCHK	LHI	R15,(NHPGRP-1)*2 :GROUP INDEX
HOC010	LH	RHP-1,DFDAT,R15 :CHECK FOR ASYNC DATA
HOC020	JFFOH	RHP-1,HOC030	:IF A HIT
	SIS	R15,2		:INDEX NEXT GROUP
	JGEBS	HOC010		:IF YES
	J	EXECRT		:DONE

: GOT A PORT WITH INFO, PROCESS IT.

HOC030	STH	R15,HLRSAV	:SAVE LOOP REG
	XH	RHP-1,HMASK,RHP,RHP  :INDICATE PORT PROCESSED
	STH	RHP-1,HLRSAV+2	:SAVE UNPROCESSED PORTS
	SLHLS	R15,3		:BIAS TO PORT INDEX
	AR	RHP,R15		:BIAS TO PORT NUMBER
	LH	RIP,IPN,RHP,RHP :GET ISIS PORT NMBR
	JLE	FILSAT		:NO PORT ASSIGNED, TRY FILE T PORT
        TBT     RHP,ORIRLA      :FILE TRANSFER PORT ACTIVE?
        JN      FTTOIS          :JUMP IF FT PORT
        LH      R8,SORD,RHP,RHP	:GET SORD NMBR
  IF    INAN+1  	        :IF ENABLED
        LIS     R0,0
        STB     R0,INACT,RHP,   :FLAG ACTIVITY
  EI
	TBT	RHP,TSATPT	:HARDWIRED TOM PORT?
	JN	TOMHDW		:BR IF SO
  IF    EOTCN+1 		:IF HOST CONTROLING GREENBALLS
        TBT     RHP,HOSTGB
        JEFS    HOC035          :THIS HOST CONTROLING GREENBALLS
  EI
        RBT     RHP,SNDGB       :DON'T SEND GREENBALL
HOC035	LB      R11,XLIMIT,RIP  :LIMIT OF CHARS WE CAN SEND AT ONCE
	LIS	R2,0
        LHI     R3,3,R11        :HOW BIG THE RECORD WILL BE
	JAL     R5,QSLOR        :START LOGICAL OUTPUT RECORD

HOC040  JAL     R3,GCDR         :ASSEMBLE CHAR
        J       HOC100          :NO MORE INPUT ON THIS PORT
	J	HOC050		:DATA CHAR
	CLHI	R0,AI.BLK	:SEE IF BLACK BALL (RING WRAP)
	JN	HOC045		:BR IF NOT
	JAL	R4,QELODR	:END DATA RECORD
	LHI	R2,CM.BLK
	LIS	R3,BLK.L
	JAL	R5,QSLOR	:SEND BLACK BALL
	JAL	R4,QELOR
	LIS	R0,REP.L	::2.06 - CAB - NSR 618 - SEND SUP MSG
	JAL	R4,ROOM,,	::
	LHI	R0,0300		::SEND SUP MSG (PORT 0, MSG TYPE 3)
	JAL	R4,PUTW,,	:: 
	LHI	R0,DFSIZ	::CHARs LOST >= ARING SIZE
	JAL	R4,PUTH,,	::
	LHI	R0,1000,RHP	::TYPE 10 = ASYNC RING WRAP 
	JAL	R4,PUTH,,	::	    ON PORT = RHP
	LHI	R0,PRODID	::PRODID  = ASYNC TYMCOM
	JAL	R4,PUTCH,,	::
	JAL	R4,ELOR,,	::2.06 - CAB - NSR 618
	LIS	R2,0
	LHI	R3,3,R11
	JAL	R5,QSLOR	:RE-START DATA RECORD
	J	HOC040

HOC045	CLHI	R0,AI.DSC	:SEE IF DISCONNECT FROM TOM
	JN	HOC040		:IGNORE IF NOT
	JAL	R6,DETHP	:DISCONNECT PORT
	J	HOC110

HOC050	RBT	RHP,SPCHFG,,	:RESET SPECIAL CHAR FALG
	STB	R0,HMSTMP	:SAVE CHAR
	LH	R5,HNPN,RHP,RHP	:ACCUMULATE FROM HOST TRAFFIC
	JL	TOMSAT
	LIS	R4,1		:
	AR	R5,R5		:
	AM	R4,CHARS,R5,R5	:INCREMENT CHAR COUNT
HOC051	TBT	RHP,TRANSP
	JN	HTI055		:IF TRANSPARENT MODE
	LR      R7,R0
  IF	OP|E8BTM.|
	TBT	RHP,E8BTMP	:TEST IF 8-BIT NODE
	JNFS	HOC052
  EI
        NHI     R7,7F           :NO, THEN REMOVE PARITY
HOC052	HS

    IF  ESCN+1
: CHECK FOR ESC CHAR

     IF ESCN            	:IF ENABLED
        TBT     RHP,ESCP
        JE      HOC060          :NOT FOR THIS PORT
     EI
        RBT     RHP,ESCFLG	:CLEAR & TEST IF PREV CHAR WAS ESC
        JN      HOC060          :BR IF IT WAS
     IF ESCN    	        :IF DIFFERENT ESC CHAR FOR DIF SORD
        CLB     R7,ESCSV,R8,
     ELSE
        CLHI    R7,ESCSV
     EI
        JN      HTI100          :IF NOT ESC CHAR
        SBT     RHP,ESCFLG      :FLAG THE ESC
     IF ESCN
	LB	R4,ESPSSV,R8,	:CHECK +PASS OR -PASS
     ELSE
	LHI	R4,ESPSSV
     EI
	CLHI	R4,0FF
	JEFS	HOC058		:DONT SEND ESC CHAR
	SBT	RHP,ESPSFG	:INDICATE PASS ESC CHAR TO NETWORK SIDE
	STB	R0,ESCTMP	:SAVE ESC CAR				
HOC058  J       HOC040          :
HOC060  HS
    EI

: CHECK FOR SPECIAL CHARACTERS

 IF	\HITBL			:IF THERE ARE ANY
    IF	HIN			:IF > 1 SET
	LR	R4,R8
	SLHLS	R4,5		:BIAS TO CURRENT TABLE (256 BITS/SORD)
	TBT	R7,HITBL,R4,
    ELSE
	TBT	R7,HITBL,,
    EI
	JE	HTI110		:IF NOTHING TO CHECK
	SBT	RHP,SPCHFG,,
    IF  RXONN+1
: CHECK FOR RXON/OFF

        TBT     RHP,RXONP
        JE      HTI050  	:NOT ENABLED
     IF RXONN   	        :IF >1 VALUE
        CLB     R7,RXOFSV,R8,   :GET XOFF CHAR
     ELSE
        CLHI    R7,RXOFSV
     EI
        JE      HOC080          :IF RXOFF
HOC065  HS
     IF RXONN   	        :IF >1 VALUE
        CLB     R7,RXONSV,R8,
     ELSE
        CLHI    R7,RXONSV
     EI
        JN      HTI050

:       RXON

        SBT     RHP,RXONON      :WERE THEY IN WAIT STATE?
        JN      HTI050          :NO, PASS AS DATA
	TBT	RHP,OTAM	:RESTORE TAM BIT TO FORMER STATE
	JEFS	HOC070
	SBT	RHP,TAM
HOC070	TBT	RHP,OFDDT	:RESTORE FDDAT BIT TO FORMER STATE
	JE	HOC040
	SBT	RHP,FDDAT
        J       HOC040

:       RXOFF

HOC080  RBT     RHP,RXONON      :FLAG WAIT STATE / TEST
        JE      HOC065          :JUMP WAIT STATE ALREADY SET, CHECK XON
	RBT	RHP,TAM		:SET OUTPUT BACKPRESSURE
	JEFS	HOC083
	SBT	RHP,OTAM	:SAVE CURRENT STATE OF TAM
	JFS	HOC085
HOC083	RBT	RHP,OTAM
HOC085	RBT	RHP,FDDAT	:STOP OUTPUT BY FAKING DRIVER INTO
	JEFS	HOC090		:*THINKING THERE IS NOTHING TO XMIT
	SBT	RHP,OFDDT	:SAVE CURRENT STATE OF FDDAT
	J	HOC040
HOC090	RBT	RHP,OFDDT
        J       HOC040
HTI050	HS
    EI

  IF	PFQN+1
:	CHECK FOR BACKPRESSURE POLL CHARACTER

	TBT	RHP,PFQP
	JE	HIPF20		:NOT FOR THIS HOST
   IF	PFQN
	CLB	R7,PFQSV,R8,
   ELSE
	CLHI	R7,PFQSV
   EI
	JN	HIPF20		:BR IF NOT POLL CHAR

	LHL	R4,BCT,RIP,RIP	:GET CHAR CNT
	SHI	R4,XOFFLM	:SEE IF BACKPRESSURE NEEDED
	JLFS	HIPF10		:BR IF NOT
	SBT	RHP,POLACK	:INDICATE ACK NEEDED WHEN READY
	JFS	HIPF20

HIPF10	LR	R6,R0		:SEND BKPR ACK IMMEDIATELY
   IF	PFQN
	LB	R0,PFASV,R8,
   ELSE
	LHI	R0,PFASV
   EI
	JAL	R5,PCEDR	:SEND ACK CHAR
	LR	R0,R6		:RESTORE CHAR
	LR	R7,R0
	NHI	R7,7F
HIPF20	HS
  EI

  IF    HETMN+1
:       CHECK FOR ENTER TRANSPARENCY MODE CHARACTER

   IF   HETMN
        CLB     R7,HETMSV,R8,
   ELSE
        CLHI    R7,HETMSV
   EI
        JNFS    HTIT10          :IF NOT ETM CHAR
	SBT     RHP,TRANSP      :SET TRANSPARENCY
        RBT     RHP,PARCEP      :NO PARITY CHECKING
HTIT10  HS
  EI

  IF	EOTCN+1			:IF HOST CONTROLING GREENBALLS
:       CHECK FOR END OF TEXT CHARACTER (SEND GREENBALL).

   IF   EOTCN           	:IF >1 ENTRY
        CLB     R7,EOTCSV,R8,
   ELSE
        CLHI    R7,EOTCSV
   EI
        JNFS    HTIE10          :IF NOT EOT CHAR
        RBT     RHP,HOSTGB      :THIS HOST NOW CONTROLS GREENBALLS
        SBT     RHP,SNDGB       :OK TO SEND GREENBALL
HTIE10  HS
  EI

  IF    HEN+1           	:IF HOST CONTROLS NET ECHO
:       CHECK NETWORK ECHO ON CHAR FROM HOST.

   IF   HEN             	:IF >1 ENTRY
        CLB     R7,HE|NEONC|SV,R8,
   ELSE
        CLHI    R7,HE|NEONC|SV
   EI
        JN      HTIN20          :IF NOT NET ECHO ON CHAR
   IF   HDN+1           	:IF HOST CONTROLS DEFERED ECHO
    IF  HDN     :IF >1 VALUE
        LB      R3,HD|EDEC|SV,R8,
    ELSE
        LHI     R3,HD|EDEC|SV
    EI
        CLHI    R3,0FF
        JNFS    HTIN03          :IF NOT FOR THIS HOST
   EI
        SBT     RHP,ECHOP       :SET ECHO ON
        JN      HTIN20          :IF ALREADY ON

:       SEND ECHO ON TO TYMSAT

HTIN03  LR	R6,R0		:SAVE ACTUAL CHAR
	JAL	R4,QELODR	:END DATA RECORD
	LHI	R2,CM.STP
	LHI	R3,STP.L
	JAL	R5,QSLOR	:SEND SET-TERM-PARAM
	LIS	R0,0
	JAL	R4,QPUTCH	:SET ECHO
	LIS	R0,1
	JAL	R4,QPUTCH	:SET ECHO ON
	JAL	R4,QELOR	:END ECHO-ON RECORD
	LIS	R2,0
	LHI	R3,3,R11
	JAL	R5,QSLOR	:RE-START DATA RECORD

:       SEND NET ECHO ON ACK TO HOST IF REQUESTED.

  IF    .GE.(HECNT,NEONA)       :IF HOST WANTS ACK
   IF   HEN             	:IF >1 ENTRY
        LB      R0,HE|NEONA|SV,R8,
   ELSE
        LHI     R0,HE|NEONA|SV
   EI
        CLHI    R0,0FF
        JEFS    HTIN10          :THIS HOST DOES NOT CARE
	JAL     R5,PCEDR        :SEND THE ACK
  EI    (HECNT,NEONA)

HTIN10  LR      R0,R6           :RESTORE CHAR
        J       HTIN30          :DONT CHECK ECHO OFF CHAR

:       CHECK NETWORK ECHO OFF CHARACTER.

HTIN20  HS
  IF    HEN             	:IF >1 ENTRY
        CLB     R7,HE|NEOFFC|SV,R8,
  ELSE
        CLHI    R7,HE|NEOFFC|SV
  EI
        JN      HTIN30          :IF NOT NET ECHO OFF CHAR
	LR      R6,R0           :SAVE ACTUAL CHAR
	JAL	R4,QELODR	:END DATA RECORD
	LHI	R2,CM.STP
	LHI	R3,STP.L
	JAL	R5,QSLOR	:SEND SET-TERM-PARAM
	LIS	R0,0
	JAL	R4,QPUTCH	:SET ECHO
	JAL	R4,QPUTCH	:SET ECHO OFF
	JAL	R4,QELOR	:END ECHO-OFF RECORD
	LIS	R2,0
	LHI	R3,3,R11
	JAL	R5,QSLOR	:RE-START DATA RECORD
	LR	R0,R6
HTIN30  HS
  EI    (HEN+1)

:	CHECK FOR HOST DISCONNECT CHARACTER

HTIX10	HS
  IF	HXN+1
    IF	HXN
	LR	R4,R8
	SLHLS	R4,5
	TBT	R7,HXTBL,R4,	:SEE IF HOST DISCONNECT
    ELSE
	TBT	R7,HXTBL,,	:SEE IF HOST DISCONNECT
    EI
	JE	HTI100		:CONTINUE IF NOT

	JAL	R4,QELODR	:END DATA RECORD
	LA	R3,DBHMSG,,	:DROPPED BY HOST MSG
	LHI	R10,AA.DBH
	JAL	R6,DETMSG
	J	HOCHK		:NEXT PORT
  EI  (HXN+1)
 EI	(\HITBL)

:       CHECK FOR FILTERED CHARACTERS

HTI100	HS
  IF    HFN+1           	:IF ENABLED
   IF	HFN			:IF > 1 SET
	LR	R4,R8
	SLHLS	R4,5		:BIAS TO CURRENT TABLE (256 BITS/SORD)
	TBT	R7,HFTBL,R4,	:SEE IF TO FILTER CHAR
   ELSE
	TBT	R7,HFTBL,,	:SEE IF TO FILTER CHAR
   EI
	JN	HOC040		:DON'T SEND CHAR IF SO
  EI

:       CHECK IF CAPITALIZING.

HTI110	HS
  IF    OP|CAPFH.|
        TBT     R8,CAPFH,,
        JEFS    HTIC10          :IF THIS HOST NOT CAPITALIZING
        CLHI    R7,60
        JLFS    HTIC10          :IF NOT LOWER CASE
        LB	R0,HMSTMP,,
	SHI     R0,20           :CONVERT TO UPPER
HTIC10  HS
  EI


:	CHECK PASS ESC CHAR OR NOT
	RBT	RHP,SPCHFG,,	:RESET SPECIAL CHAR FLAG
	JN	HTIC20		:IF THIS CHAR IS A SPECIAL CHAR
	RBT	RHP,ESPSFG,,	:RESET ESC PASS FLAG
	JE	HTIC30		:NEED NOT PASS ESC CHAR
	LB	R0,ESCTMP,,	
	CLHI	R0,0FF
	JEFS	HTIC30	
	JAL	R4,QPUTDC	:SEND ESC CHAR
	SIS	R11,1
	JFS	HTIC30
HTIC20	RBT	RHP,ESPSFG,,
HTIC30	LHI	R4,0FF
	STB	R4,ESCTMP	
:       FINALLY SEND THE CHARACTER

HTI055  LB	R0,HMSTMP,,
	JAL     R4,QPUTDC       :SEND CHAR
        SIS     R11,1
        JG      HOC040          :DON'T MAKE MESSAGE TOO BIG

	JAL     R4,QELODR       :BIG ENOUGH...STOP NOW
	TBT	RHP,DFDAT	:ANY MORE DATA?
	JEFS	HOC110		:NO, DONE WITH THIS PORT
	SBT	RIP,PIBUF	:FORCE ADDITIONAL DATA TO BFR
	J	HOC035		:GO BUFFER REMAINING DATA

HOC100	JAL	R4,QELODR	:END DATA RECORD
HOC110	LHL	R15,HLRSAV	:RESTORE LOOP REG
	LHL	RHP-1,HLRSAV+2	:RESTORE UNPROCESSED PORT MASK
	J	HOC020		:CONTINUE


FTTOIS  TBT     RHP,LOGING      :IN LOGING MODE?
        JN      FTOLOG          :JUMP IF YES
        LB      R11,XLIMIT,RIP  :BIGGEST WE CAN BE
        LIS     R2,0
        LHI     R3,3,R11        :PLUS THE HEADER
        JAL     R5,QSLOR
FTO010  JAL     R3,GCDR         :GET CHAR
        J       FTO100          :NO MAH DATA
        J       FTO040          :HEY MAN, WE GIT NUTHA WUN
        CLHI    R0,AI.BLK       :BLACKBALL
        JN      FTO010          :IGNORE OTHERS (SPACING TO MARKING)
        JAL     R4,QELODR       :KILL THE DATA RECORD
        LHI     R2,CM.BLK
        LIS     R3,BLK.L        :SEND TO OTHER END THE BB
        JAL     R5,QSLOR
        JAL     R4,QSLOR
        LIS     R2,0
        LHI     R3,3,R11        :RESTART DATA RECORD
        JAL     R5,QSLOR
        J       FTO010          :NEXT!

FTO040  JAL     R4,QPUTDC       :DATA CHARACTER IS SIMPLY SENT
        SIS     R11,1
        JG      FTO010          :MORE DATA
FTO100  JAL     R4,QELODR       :END DATA RECORD
        J       HOC110          :CONTINUE FOR NEXT PORT

FTOLOG  JAL     R3,GCDR         :LOOKING FOR LOGON CHARS
        J       HOC110          :NEXT PORT IF NO MAH DATA
        J       FTOLG1          :DATA ROUTE
        J       FTOLOG          :HAVE NOTHING TO DO WITH SIGNALS
FTOLG1  NHI     R0,7F
        TBT     RHP,LOGSTX      :HAVE WE GOTTEN THE PREFIX CHAR?
        JNFS    FTOLG2
        SIS     R0,2            :2 IS STX
        JN      FTOLOG          :NOT IT SO GET NEXT CHAR
        SBT     RHP,LOGSTX
        J       FTOLOG
FTOLG2  CLHI    R0,3            :END OF STRING
        JNFS    FTOLG3
        RBT     RHP,LOGSTX      :NO LONGER LOOKING FOR LOGIN CHARS
        LHI     R0,0D           :CR TO TERMINATE LOGON STRING
FTOLG3  LR      R11,R0          :SAVE CHAR
        CLHI    R0,12           :CONTROL R?
        JNFS    FTOLG4
        SBT     RHP,RXONP
FTOLG4  CLHI    R0,18           :CONTROL X?
        JNFS    FTOLG5
        SBT     RHP,XONP        :ALLOW BACKPRESSURE
FTOLG5  LR      R1,RIP
        LHI     R2,CM.NLC       :NORMAL LOGON CHAR
        LIS     R0,NLC.L
        JAL     R4,SLOR
        LR      R0,R11
        OHI     R0,80           :LOGON CHARS HAVE HIGH BIT ON
        JAL     R4,PUTCH
        JAL     R4,ELOR         :NEXT LOGON CHAR
        J       FTOLOG

FILSAT  TBT     RHP,FTRAPT      :A FILE TRANSFER PORT?
        JE      TOMSAT          :NO, COULD BE TOM PORT
FLSAT1  JAL     R3,GCDR         :GET CHAR
        J       HOC110          :NO MORE DATA
        J       FLSA20          :DATA
        CLHI    R0,90           :BREAK SIGNALS?
        JGE     FLSAT1          :YES, IGNORE (LOOKING FOR BAUD RATE)
        SHI     R0,80
        STH     R0,BRATE,RHP    :SAVE BAUD RATE
        AHI     R0,AO.OBR       :SET OUTPUT BAUD RATE
        JAL     R5,PEEDR
        AHI     R0,AO.IBR-AO.OBR :AND INPUT BAUD RATE
        JAL     R5,PEEDR
        LHI     R0,AO.EDM       :NO MORE BAUD RATE DETECTION
        JAL     R5,PEEDR
        RBT     RHP,ORIRLA      :NOT YET ACTIVE
        J       FLSAT1          :AND THEN GET CHAR

FLSA20  CLB     R0,FLTCHR,RHP, :FILE TRANSFER CHAR?
        JN      FLSAT1          :NOPE
        SBT     RHP,ORIRLA      :TYMCOM ORIGINATING CIRCUIT
        JN      FLSAT1          :ALREADY STARTED ONE
        RBT     RHP,DTR
        IF NAPORT
        RBT     RHP,NDTR
        RBT     RHP,DTRWT
        EI
        RBT     RHP,LOGING      :NOT YET READY FOR LOGON CHARS
        RBT     RHP,GOT.PN      :NO PSEUDO NEEDLE REEIVED
        LB      R0,FLTCHL,RHP,  :GET ACK CHAR
        JAL     R5,PDCDR
        LIS     R1,0            :TO SLOT 0
        LIS     R0,0B           :LENGTH
        LIS     R2,7            :MSG TYPE (PSN REQUEST)
        JAL     R4,SLOR
        LIS     R0,0            :PAD
        JAL     R4,PUTCH
        LB      R0,SEQKEY,RHP   :GET SEQUENCE NUMBER OF PORT FOR KEY
        AIS     R0,1
        STB     R0,SEQKEY,RHP
        EXBR    R0,R0           :KEY IS /SEQ|PHYSICAL PORT/
        STBR    RHP,R0
        JAL     R4,PUTH
        LHI     R0,4000         :EXTENDED LOGON STATUS REQUEST
        JAL     R4,PUTH
        LHL     R0,ACHOST,RHP,RHP :ORIGINATION HOST
        JAL     R4,PUTH
        LB      R4,BRATE,RHP    :GET BAUD RATE
        LB      R0,VID.ID,R4,   :GET CCT
        OHI     R0,0C0          :SET HIGH BITS
        JAL     R4,PUTCH
        JAL     R4,ELOR
        J       FLSAT1          :RETURN TO INPUT

        
	SUBTTL	RECEIVE LINE ACTIVE

: FGRLA - CHECK FOR CHANGE IN INPUT SIGNAL STATE
:
:       RUNS EVERY 2ND TRIP THROUGH THE FORGROUND EXEC LOOP,
:       OR APPROXIMATELY EVERY 50 MS.
:       IF 2 SAMPLES DETECT NO CHANGE IN SIGNAL, THE SIGNAL IS
:       CONSIDERED STABLE.  THIS SIGNAL IS THEN CHECKED AGAINST THE
:       HANG/ANSWER VALUE OF THE SIGNAL WHICH IS UPDATED EVERY
:       1/2 SECOND BY HANGAN.
:       IF THEY ARE DIFFERENT A FLAG IS SET INDICATING THIS FACT.
:       THE FLAG IS LEFT UNCHANGED IF THEY ARE THE SAME.  IN THIS
:       WAY HANGAN CAN DETECT ANY CHANGE IN SIGNAL EVEN WHEN THE
:       DURATION IS LESS THAN 101MS.
:
:       FGSACT=((HDWCP!HDWDSR)%SIN)&(LSTSIG%SIN)!FGSACT

FGRLA   TS      RLARUN
        JER     R10             :IF NOT TIME TO RUN
	LIS	R0,0
        STH     R0,RLARUN
  IF    NMPORT

        LHI     R1,NMPORT-1
        LI      R2,SIOBUF+(NMPORT-1)*SIOBFL
FGR000  LB      R0,SIOSTS,R2    :GET REG 0 STATUS FROM SIO
        CLHI    R0,0FF          :SEE IF SIO PORT UNPLUGGED
        JE      FGR004          :BR IF SO, PORT DISCONNECTED
	RBT	R1,PTGONE+NAPGRP*2  :INDICATE PORT THERE
        LB      R3,PSPEED+NAPORT,R1, :SEE IF BAUDOT PORT
        CLHI    R3,SB-2000
        JNFS    FGR001          :BR IF NOT
	NHI	R0,0A8		:LOOK FOR DSR & CP HIGH, BREAK LOW
	JFS	FGR002
FGR001	NHI     R0,28           :SEE IF DSR & CP BOTH HIGH
FGR002  CLHI    R0,28
        JNFS    FGR005          :BR IF NOT, PORT DISCONNECTED
	RBT     R1,HDWDSR+NAPGRP*2  :INDICATE PORT ANSWERED
	JFS	FGR007
FGR004	SBT	R1,PTGONE+NAPGRP*2  :INDICATE PORT GONE
FGR005  SBT     R1,HDWDSR+NAPGRP*2  :INDICATE PORT DISCONNECTED
FGR007  SHI     R2,SIOBFL
        SIS     R1,1
        JGE     FGR000          :LOOP UNTIL DONE
  EI

        LHI     R1,((NTPGRP+1)/2*4)-4
FGR010  L       R2,HDWCP,R1
        O       R2,HDWDSR,R1
        L       R3,SIN,R1
        L       R4,LSTSIG,R1
        ST      R2,LSTSIG,R1
        XR      R2,R3
        XR      R3,R4
        NR      R2,R3
        O       R2,FGSACT,R1
        ST      R2,FGSACT,R1
        SIS     R1,4
        JGE     FGR010
        JR      R10
  IF	NAPORT
	SUBTTL	FOREGROUND DTR CHANGER

: HANGEM - CHANGE DTR WHEN ALL DATA HAS BEEN OUTPUT

HANGEM  LIS     R11,(NTPGRP-1)*2
HANG1   LH      R1,TOPORT,R11   :NOT DATA IN BFR
	NH	R1,NDTR,R11
	OH	R1,FDDAT,R11	:*OR IN RING
	XHI	R1,0FFFF
	NH	R1,DTRWT,R11    :*AND DTR-WAIT SET
	JNFS	HANG3		:BR IF SOMETHING TO DO
HANG2   SIS     R11,2           :DO FOR ALL GROUPS
        JGEBS   HANG1
        JR      R10             :RETURN WHEN DONE

HANG3	LR	R2,R1
	NH	R2,NDTR,R11	:GET NEW VALUE FOR DTR FROM NDTR
	LCS	R3,1
	XR	R3,R1
	NH	R3,DTR,R11
	OR	R2,R3
	XH	R1,DTRWT,R11
	STH	R1,DTRWT,R11	:UPDATE PORTS WAITING ARRAY
	STH	R2,DTR,R11	:SET NEW DTR
	J	HANG2
  EI
	SUBTTL	HALF SECOND LOGIC - RINGUP

: HALF SECOND PERIODIC PROCESSOR

HSEC    AHI     R1,RATE/2
        JAL     R5,TOPUT        :RUN AGAIN IN ABOUT A HALF SECOND

:       RING ANY PORTS THAT NEED RINGING.

RINGUP  LHI     R7,(NTPGRP-1)*2
        LHI     R14,(NTPGRP-1)*10
RUP005  LCS     R8,1
RUP010  LH      R1,RNGTGL,R7    :IF     RING CURRENTLY UP
        OH      R1,RING,R7      :OR     RINGING WAS REQUESTED
        NR      R1,R8           :AND    NOT ALREADY PROCESSED
        JFFOH   R1,RUP020       :THEN   TOGGLE RING
        SHI     R14,10
        SIS     R7,2
        JGEBS   RUP005          :ELSE   CONTINUE SEARCH
        J       HANGAN          :NEXT PROCESS

RUP020  LR      RHP,R2
        XH      R8,HMASK,RHP,RHP :MARK PORT PROCESSED
        AR      RHP,R14         :BIAS IT
        TBT     RHP,RNGTGL      :RING UP?
        JE      RUP040          :IF NOT
        TBT     RHP,RING        :STILL REQUESTED?
        JE      RUP030          :IF NOT
        TBT     RHP,SIN         :ANSWERED?
        JN      RUP025          :IF NOT
        TBT     RHP,RNGCUP
        JN      RUP010          :IF CONSTANT RING
	TBT	RHP,SIGANS
	JEFS	RUP022		:IF NOT USING SIGNAL
        TBT     RHP,FGSACT
        JN      RUP025          :IF SIN ABOUT TO GO DOWN, IGNORE IT
RUP022  JAL     R6,PTMEXC       :QUEUE FOR IMMEDIATE EXECUTION
        RBT     RHP,WATHST      :*AND WAITING FOR HOST TO ANSWER
        TBT     RHP,RNGDRP      :SEE IF TO DROP RING ON ANSWER
        JNFS    RUP023          :BR IF SO
        SBT     RHP,RNGCUP      :MAKE RING STAY UP FOR THE DURATION
        SBT     RHP,RING
        RBT     RHP,RNGTGP
	JFS	RUP024
RUP023  RBT     RHP,RING        :STOP RINGING PORT
	SBT     RHP,RNGTGP      :RESET RING TOGGLE
	LHI	R0,AO.RSD	:LOWER RING
	JAL	R5,PEEDR
	RBT	RHP,RNGTGL	:SET RING DOWN
RUP024	HS
  IF	NAPORT
	RBT     RHP,NDTR        :BRING UP DTR AFTER THE
	SBT	RHP,DTRWT	:*RING-DOWN IS PROCESSED
  ELSE
	RBT	RHP,DTR		:INDICATE DTR UP
  EI
        SBT     RHP,ACP         :SET PORT ACTIVE
        JN      RUP010          :IF ALREADY SET
        LIS     R0,1
        AHM     R0,APORTS       :COUNT ACTIVE PORTS
        LR      R4,RHP          ::2.06 - CAB 
        SLLS    R4,2            ::ORIGINAL PATCH BY BRYAN WING, HQTECH
        L       R5,SLOWC,,	::GET THE START TIME AND SAVE IT
        ST      R5,CLKSAV,R4    ::FOR TOM STATUS COMMAND
	J	RUP010

RUP025  TBT     RHP,RNGTGP
        JE      RUP010          :IF NOT TOGGLING
RUP030  LHI     R0,AO.RSD       :RING DOWN
        JAL     R5,PEEDR        :TURN OFF RING
        RBT     RHP,RNGTGL      :SET RING DOWN
        J       RUP010          :LOOK FOR MORE

RUP040  LHI     R0,AO.RSU       :RING UP
        JAL     R5,PEEDR        :TURN ON RING
        SBT     RHP,RNGTGL      :SET RING UP
        J       RUP010
	SUBTTL	HALF SECOND LOGIC - HANG/ANSWER LOGIC

: HANG/ANSWER LOGIC

HANGAN  LHI     R14,(NTPGRP-1)*10
        LHI     R11,(NTPGRP-1)*2 :START WITH LAST GROUP
HAN010  LH      R9,SIN,R11       :GET LAST INPUT SIGNAL VALUE
        XH      R9,FGSACT,R11    :REVERSE SIGNALS ACTIVE IN LAST 1/2 SEC
        LH      R8,FTRAPT,R11   :FILE TRANSFER ACTIVE IF SIGNALS PRESENT *
        XHI     R8,-1           :SIGNALS ARE 0 IF PRESENT
        OH      R8,FGSACT,R11   :AND FILE TRANSFER PORT *300.sdw
        LIS     R1,0
        STH     R1,FGSACT,R11   :REINIT FG ACTIVE
	LH	R1,SIGANS,R11	:FORCE IFUP SIGNALS HIGH
	OH	R1,TSATPT,R11	:*UNLESS HDW TOM PORT
	NR	R9,R1
  IF	NMPORT
	OH	R9,PTGONE,R11	:SIGNALS LOW IF DAUGHTER BD MISSING
  EI
        STH     R9,SIN,R11      :UPDATE COPY
:       DTR=@(TSATPT*SIN)*OLDDTR+CAN+TDROP+PDOWN+@(ACP+TSATPT)
	LH	R10,TSATPT,R11
	NR	R10,R9
	XHI	R10,-1
        NH      R10,DTR,R11
        OH      R10,CAN,R11
	OH	R10,TDROP,R11
        OH      R10,PDOWN,R11
        LHL     R2,ORIRLA,R11   :set DTR if origination port
        XHI     R2,-1
        NR      R10,R2
        LH      R1,ACP,R11
        OH      R1,TSATPT,R11
        XHI     R1,-1
        OR      R10,R1
        STH     R10,HDWDTR,R11
        STH     R10,DTR,R11
:WAS    CAN=@ACP*@PDOWN*@PSHUT*(@SIN*SIGCAN+@SIGCAN)*@TSATPT*@WATHST
:       LCS     R1,1
:       XR      R1,R9
:       LH      R3,SIGCAN,R11
:       NR      R1,R3
:       XHI     R3,-1
:       OR      R1,R3
:       LH      R3,PSHUT,R11
:       XHI     R3,-1
:       NR      R1,R3
:       LH      R3,PDOWN,R11
:       XHI     R3,-1
:       NR      R1,R3
:       LH      R3,ACP,R11
:       XHI     R3,-1
:       NR      R1,R3
:       LCS     R3,1
:       XH      R3,TSATPT,R11
:       NR      R1,R3
:       LCS     R3,1
:       XH      R3,WATHST,R11
:       NR      R1,R3
:
:NOW	CAN=@((SIN*SIGCAN)+ACP+PDOWN+PSHUT+TSATPT+WATHST) - 2.06 CAB
				:DISQUALIFY AS CANDIDATE
	LHL	R1,SIGCAN,R11	:IF PORT USES SIGNALLING AND
	NR	R1,R9		:SIGNAL INPUT (SIN) IS HIGH (NOT READY)
	OH	R1,ACP,R11	:OR ALREADY ACTIVE 
	OH	R1,PDOWN,R11	:OR DOWNED BY TOM
	OH	R1,PSHUT,R11	:OR SHUT BY TOM
	OH	R1,TSATPT,R11	:OR PORT IS TOM TYMSAT PORT
	OH	R1,WATHST,R11	:OR WAITING FOR HOST RESPONSE
        OH      R1,ORIRLA,R11   :OR ORIGINATING A CIRCUIT *300.sdw
	XHI	R1,-1		:
        STH     R1,CAN,R11	:1 IF PORT IS CANDIDATE
:       RLA=DTR+SIN
	LCS	R1,1		:
      	XR	R1,R9		:FLIP SIGNAL INPUT (SIN) BITS
	OR	R1,R10		:GET DTR BITS
	NH	R1,RLA,R11	:
	STH	R1,RLA,R11	:RLA=OLDRLA*(@SIN+DTR)
	OR	R10,R9		:
        NR      R10,R8
	STH	R10,WRLA	:WRLA=(SIN+DTR)
	
HAN020  LH      R1,WRLA         :ANY CHANGES IN RCVR LINE ACTIVE?
        XH      R1,RLA,R11
        NH      R1,REAL,R11     :MUST BE REAL PORT
        JFFOH   R1,HAN030       :IF RLA CHANGED
        SIS     R11,2
        SHI     R14,10
        JGE     HAN010          :NEXT RING GROUP
        J       GBSEND          :FINISHED HANG/ANSWER

:	FOUND A PORT THAT CHANGED

HAN030  LR      RHP,R2
        AR      RHP,R14
	LHL	R8,SORD,RHP,RHP	:GET SORD NMBR
        CBT     RHP,RLA
        JE      HAN080          :LINE NO LONGER ACTIVE

:       NEW PORT JUST CAME UP

        RBT     RHP,BRK
        SBT     RHP,RXONON
        SBT     RHP,XONON       :INIT XON ALREADY OUT
        TBT     RHP,TSATPT      :TYMSAT PORT?
        JN      HAN035          :IF TYMSAT
        TBT     RHP,FTRAPT
        JE      HAN070          :IF NOT TYMSAT OR FILE TRANSFER

:       TYMSAT PORT CONNECT

HAN035  RBT     RHP,DEM
        SBT     RHP,TOPTON      :RESET BACKPRESSURE OF FIT
	JAL	R5,RGCLR	:CLEAR ASYNC RINGS
  IF	NMPORT
   IF	NAPORT
	TBT	RHP,SIOP	:SEE IF SIO PORT
	JN	TOMSIO		:BR IF SO
   ELSE
	J	TOMSIO		:GO INIT SIO PORT
   EI
  EI
  IF	NAPORT

HAN040  LHI     R0,AO.ECM       :SEND "ENTER CONNECT MODE"
        JAL     R5,PECDR
        LHI     R3,100
        STH     R3,MARGE,RHP,RHP
        SBT     RHP,CRDLYP
        LHI     R3,15F1
        STB     R3,PCD,RHP
        EXBR    R3,R3
        STB     R3,PAB,RHP      :PARAM A,B,C,D
        LIS     R0,5
        CLHI    RHP,IDPORT
        JLFS    HAN060
        LIS     R0,8
HAN060  AHI     R0,AO.OBR       :OUTPUT BAUD RATE
        JAL     R5,PECDR        :SET OUT BAUD RATE
        TBT     RHP,FTRAPT      :FILE TRANSFER PORT?
        JN      HAN020          :NO MESSAGE FOR THESE PORTS
        LA      R10,LSMS0,,
	JAL     R6,PHWMS	:CHECK FOR BIT MASK AND SEND
        J       HAN020
  EI

:       TYMCOM PORT CONNECT

HAN070  LHI     R0,AO.EDM       :ENTER DATA MODE
        JAL     R5,PEEDR
        J       HAN020          :NEXT PORT

:       CIRCUIT DISCONNECTED

HAN080  TBT     RHP,TSATPT      :TYMSAT PORT?
        JN      HAN090          :IF NOT TYMCOM
        TBT     RHP,SIN         :SIGNAL INPUT STILL HIGH?
        JNFS    HAN090          :IF SIN HAS DROPPED
	TBT	RHP,TDROP
	JNFS	HAN090		:IF TOM SAYS ITS DOWN
        TBT     RHP,ACP
        JEFS    HAN090          :IF PORT NOT ACTIVE
        RBT     RHP,RLA         :KEEP RECEIVER LINE ACTIVE
	RBT	R2,WRLA		:AVOID LOOP
        J       HAN020          :CONTINUE

HAN090  RBT     RHP,BRK
	RBT	RHP,TDROP
        JAL     R5,BFCLR
	SBT	RHP,TAM		:REMOVE ASYNC BACKPRESSURE
        LHI     R0,AO.RSD
        JAL     R5,PECDR        :INSURE RING IS DOWN
        LHI     R0,AO.DSC       :DISCONNECT
        JAL     R5,PECDR
	JAL	R6,DETHP	:DETACH HOST PORT
        J       HAN020
	SUBTTL	HALF SECOND LOGIC - GREENBALL

: SEND GREENBALLS BACK TO TYMSAT.

GBSEND  LHI     R11,(NTPGRP-1)*2
        LHI     R14,(NTPGRP-1)*10
GBS010  LH      R1,SNDGB,R11    :IF TIME TO SEND GB
        NH      R1,GBRCVD,R11   :AND ONE WAS RECEIVED FROM TYMSAT
        NH      R1,GBSEC,R11    :AND > 1/2 SEC HAS GONE BY SINCE RECEIVED
        JFFOH   R1,GBS020       :IF OK TO SEND A BALL
        J       GBS030

GBS020  AR      R2,R14          :BIAS TO PORT NUMBER
	LR	RHP,R2
        RBT     RHP,GBRCVD      :MARK SENT
        RBT     RHP,GBSEC       :CLEAR TIMER
        RBT     RHP,SNDGB       :DONT SEND UNTIL HOSTS OKS IT
	LH	RIP,IPN,RHP,RHP	:GET ISIS PORT NMBR
	JLE	GBS010		:BR IF NONE
	LHL	R8,SORD,RHP,RHP	:GET SORD NMBR
        LHI     R2,CM.GB        :GREEN BALL MSG
	LIS	R3,GB.L		:GREEN BALL MSG LENGTH
        JAL     R5,QSLOR	:SEND GREEN BALL
	JAL	R4,QELOR
        J       GBS010          :TRY FOR MORE

GBS030  LH      R1,GBRCVD,R11   :COUNT FOR NEXT TIME
        STH     R1,GBSEC,R11
  IF    EOTCN+1         	:IF HOST CONTROLS GREENBALLS
        LH      R1,HOSTGB,R11
  ELSE
        LCS     R1,1
  EI
        STH     R1,SNDGB,R11
        SHI     R14,10
        SIS     R11,2
        JGE     GBS010          :IF MORE TO CHECK

        J       TORET           :ALL DONE
	SUBTTL	4 SECOND LOGIC - SOFT SHUT

: REPORT PORT AVAILABILITY
:
:       IF      <HOST NOT DOWN OR GONE>
:         IF    <NO PORTS AVAILABLE BUT WERE BEFORE>
:           IF  <HOST NOT SHUT>
:            IF <ALL PORTS DOWN>
:               REPORT HOST SHUT
:            ELSE <ALL PORTS IN USE (SOME MAYBE DOWN)>
:              IF       <HOST IS HOST 0>
:               SHUT HOST (SO TOM STILL ACCESSIBLE)
:              ELSE
:               REPORT NO PORTS AVAILABLE
:              EI
:            EI
:           ELSE        <HOST ALREADY SHUT BY OPERATOR>
:               FLAG PORTS STILL AVAILABLE SO HOST STAYS SHUT
:           EI
:         ELSE  <PORTS AVAILABLE NOW BUT NOT BEFORE>
:           IF  <HOST SHUT>
:               REPORT HOST ANSWERED
:           EI
:               REPORT PORTS AVAILABLE
:         EI
:       EI

SEC4    AHI     R1,RATE*4
        JAL     R5,TOPUT        :CALL AGAIN IN 4 SECONDS

PAREP   LIS     R14,0   	:HOST NAME TABLE PTR
        LIS     R11,1           :DOWN/GONE FLAG POSITION
PAR010  LIS     R5,0            :AVAILABLE PORT FLAG
        LIS     R13,0           :0 IF ALL PORTS DOWN FOR THIS HOST
PAR015  LH      R6,HNT,R14,     :NEXT HOST ORD
        JL      TORET           :IF NO MORE HOSTS
        TBT     R11,PORTS,R6,R6 :HOST STATUS FLAG
        JEFS    PAR020          :IF NOT DOWN OR GONE
PAR017  AIS     R14,HNTE.L
        JBS     PAR015          :GET NEXT TABLE ENTRY

PAR020  LH      R9,HNT+4,R14,   :SUBHOST ORD
        JEBS    PAR017          :IF TOM SORD, IGNORE
        LHI     R10,NHPGRP*2
        MHR     R10,R9          :HPTS INDEX = NHPGRPS*SORD#
        LHI     R8,(NHPGRP-1)*2
        LIS     R4,0            :0 IF ALL PORTS DOWN FOR THIS SORD
PAR030  LH      R7,CAN,R8       :IF CANDIDATE
        NH      R7,HPTS,R10,R8  :AND ASSIGNED TO THIS SORD
        OR      R5,R7           :ACCUMULATE CANDIDATES
        LH      R7,SIGCAN,R8,
        NH      R7,SIN,R8,
        OH      R7,PDOWN,R8     :IF DOWN
        NH      R7,HPTS,R10,R8  :AND ASSIGNED THIS SORD
        XH      R7,HPTS,R10,R8  :0 IF ALL PORTS DOWN
        OR      R4,R7           :ACCUMULATE ALL DOWN
        SIS     R8,2
        JGE     PAR030          :IF MORE PORT GROUPS
        RBT     R9,ASPDWN       :NOT ALL PORTS DOWN
        LR      R4,R4
        JNFS    PAR035          :IF NOT ALL PORTS DOWN
        SBT     R9,ASPDWN       :SET ALL PORTS DOWN FLAG
PAR035  OR      R13,R4          :ACCUMULATE ALL DOWN THIS HOST
        AIS     R14,HNTE.L      :NEXT HOST NAME TABLE ENTRY
        CH      R6,HNT,R14,     :NEXT HOST SAME AS LAST HOST?
        JE      PAR020          :IF MORE SORDS FOR THIS HOST
        LR      R5,R5
        JE      PAR040          :IF NO PORTS AVAILABLE
        RBT     R6,HAPD         :SET ALL PORTS NOT DOWN
        JNFS    PAR037          :IF PORTS WERE DOWN
        RBT     R6,HNPA         :FLAG PORTS NOW AVAILABLE
        JE      PAR010          :IF ALREADY REPORTED
        LIS     R0,0
        TBT     R0,PORTS,R6,R6
        JE      PAR050          :IF HOST NOT SHUT
PAR037	TBT	R6,HSTSHT	:IF HOST HAS BEEN SHUT VIA TOM ?
	JN	PAR015		:IF YES
	LIS     R12,0           :ANSWERED STATUS
        LHL     R9,HOSTS,R6,R6  :NET HOST #
        JAL     R5,CHSTAT       :CHANGE STATUS
        LIS     R5,1            :FLAG PORTS AVAILABLE
        J       PAR050          :GO REPORT IT

PAR040  LR      R13,R13
        JNFS    PAR042          :IF NOT ALL PORTS DOWN
        SBT     R6,HAPD         :FLAG ALL DOWN
        JN      PAR010          :IF ALREADY REPORTED
        J       PAR045          :REPORT SHUT

PAR042  RBT     R6,HAPD         :NO LONGER ALL PORTS DOWN
        JN      PAR037          :ANSWER THE HOST
        SBT     R6,HNPA         :FLAG NO PORTS AVAILABLE
        JN      PAR010          :IF ALREADY REPORTED
        LIS     R0,0
        TBT     R0,PORTS,R6,R6
        JEFS    PAR043          :IF HOST NOT SHUT
        RBT     R6,HNPA         :FLAG THAT WE DID NOT CAUSE SHUT
        J       PAR010          :NEXT HOST

PAR043  LR      R6,R6
        JNFS    PAR050          :IF NOT HOST 0, NO PORTS AVAILABLE
PAR045  LIS     R12,2           :SHUT STATUS
        LHL     R9,HOSTS,R6,R6  :NET HOST #
        JAL     R5,CHSTAT       :CHANGE STATUS
        J       PAR010          :NEXT HOST

PAR050  LIS     R0,HPA.L        :LENGTH OF HOST PORTS AVAILABLE MSG
        LIS     R1,0            :SEND TO INTRA-NODE PORT
        LIS     R2,NM.HPA       :HOST PORTS AVAIL. TYPE
        JAL     R4,SLOR,,       :START RECORD
        JAL     R4,PUTCH,,      :SEND GARBAGE KEY
        LH      R0,HOSTS,R6,R6  :GET HOST #
        EXHR    R0,R0
        EXBR    R0,R5           :GET AVAILABILITY STATUS
        JAL     R4,PUTW,,       :SEND HOST NUMBER AND PORT AVAIL. FLAG
        LR      R0,R6
        JAL     R4,PUTH,,       :SEND RELATIVE HOST #
        JAL     R4,ELOR,,       :END RECORD
        J       PAR010          :NEXT HOST
	SUBTTL	1 MINUTE LOGIC - ACTIVITY TIMER

: ACTTIM - ACTIVITY TIMER.
:
:	CHECK FOR INACTIVE PORTS EVERY MINUTE.
:	HANG PORTS WHOSE TIMER IS UP.

  IF	INAN+1
ACTTIM	AI	R1,RATE*$A60
	JAL	R5,TOPUT	:CALL AGAIN IN MINUTE

	LHI	RHP,NHPORT-1
ACT010	TBT	RHP,ACP
	JE	ACT020		:IF NOT ACTIVE
	LHL	R8,SORD,RHP,RHP :GET SORD #
   IF	INAN			:MORE THAN 1 VALUE?
	LB	R2,INASV,R8,	:GET INACTIVITY TIMEOUT VALUE
	LR	R2,R2
   ELSE
	LHI	R2,INASV
   EI
	JEFS	ACT020		:IF NOT SUPPORTED FOR THIS SORD
	LB	R3,INACT,RHP	:CURRENT COUNTER
	AIS	R3,1
	CR	R3,R2
	JGFS	ACT030		:IF TIME IS UP
	STB	R3,INACT,RHP	:UPDATE COUNTER
ACT020	SIS	RHP,1
	JGE	ACT010		:IF MORE PORTS
	J	TORET

:	HANG AN INACTIVE PORT

ACT030	LH	RIP,IPN,RHP,RHP :GET ISIS PORT
	JLE	ACT020		:BR IF NONE
	LR	R7,RHP
	LA	R5,INAMSG,,	:SEND MSG TO TOM
	JAL	R6,TOMMSG
	TBT	RHP,TSATPT	:SEE IF THIS IS HARDWIRED TOM
	JNFS	ACT040		:BR IF SO
	LA	R3,INAMSG,,
	LHI	R10,AA.DBH	:DROPPED BY HOST
	JAL	R6,DETMSG	:SEND MSG TO USER AND DETACH
	J	ACT020		:NEXT

ACT040	JAL	R6,DETHP	:DETACH HARDWIRED TOM PORT
	J	ACT020
  EI

	SUBTTL 	1 MINUTE LOGIC - REPORT HOST COST

: REPORT HOST COST
:

  IF	HKEYN+1
HOSTCT	AI	R1,RATE*HSTMER		:2.06 - CAB - NSR 716 -
	JAL	R5,TOPUT		:CALL AGAIN IN MINUTE

	LHI	R12,(MAXHST-1)*4	:ACCUMULATE TOTAL CHARS FOR SLOT
	LIS	R11,0			:
	LIS	R10,0			:
HOSTC1	L	R9,CHARS,R12		:GET CURRENT HOST CHAR COUNT
	ST	R9,CHARSV,R12		:SAVE FOR COST CALC AND FOR TOM
	AR	R11,R9			:UPDATE TOTAL CHAR COUNT
	ST	R10,CHARS,R12		:
	SIS	R12,4			:
	JGEBS	HOSTC1			:LOOP THROUGH ALL HOSTS
	ST	R11,TCHARS		:SAVE TOTAL FOR LATER USE

	LHI	R12,MAXHST-1		:R12=HOST ORDINAL
	LI	R11,MAXHST*NHPGRP*2	:R11=HNPNTB OFFSET
HOSTC2	SHI	R11,NHPGRP*2		:
	LHI	R10,(NHPGRP-1)*2	:
	LR	R9,R12			:
	AR	R9,R9			:R9=2*HOST ORDINAL
 	LH	R8,HKEYTB,R12,R12	:GET HOST KEY
	JE	HOSTC7			:NO HOST KEY, NOT A MULTIPLE HOST
	LIS	R5,0 			:INIT ACTIVE PORT COUNT
HOSTC3	LHL	R6,ACP,R10		:GET ACTIVE PORTS
	NH	R6,HNPNTB,R10,R11	:DO ANY BELONG TO THIS HOST?
	JEFS	HOSTC5			:
HOSTC4	AIS	R5,1			:IF YES, ACCUMULATE ACTIVE PORTS
	NHI	R6,-1,R6		:TRICK TO COUNT BITS
	JNBS	HOSTC4			:
HOSTC5	SIS	R10,2			:KEEP ACCUMULATING PORTS
	JGE	HOSTC3			:UNTIL DONE
	STH	R5,NPTSV,R9		:R5=# OF ACTIVE PORTS
	L	R6,CHARSV,R9,R9		:GET CHAR COUNT FOR THIS HOST
	AR	R6,R6			:DOUBLE WEIGHTING
	A	R6,TCHARS		:ADD TOTAL CHARS (ALL HOSTS)
	SRLS	R6,$A13			:
	SRLS	R5,2			:COST=NPORTS/4
	AR	R5,R6			: +(TOTAL CHARS+2*HOST CHARS)/8192
	AH	R5,HCSTTB,R12,R12	: + MIN HOST COST
	CHI	R5,1F			:DON'T LET COST GO ABOVE 31
	JLEFS	HOSTC6			:
	LHI	R5,1F			:
HOSTC6	CH	R5,HCOST,R9		:SEE IF COST HAS CHANGED
	JE	HOSTC7			:
	STH	R5,HCOST,R9		:IF YES, SAVE CURRENT HOST COST
	LIS	R0,0A			:AND SEND HOST COST TO SUP
	LIS	R1,0			:
	LIS	R2,0C			:
	JAL	R4,SLOR			:START OUTPUT RECORD
	LH	R0,HKEYTB,R12,R12	:  HOST KEY
	JAL	R4,PUTCH		:
	LH	R0,HOSTS,R12,R12	:  NETWORK HOST #
	JAL	R4,PUTH			:
	LH	R0,HCOST,R9		:  HOST COST
	JAL	R4,PUTH			:
	LR      R0,R12			:  RELATIVE HOST #
	JAL	R4,PUTH			:
	JAL	R4,ELOR			:END OUTPUT RECORD
HOSTC7	SIS	R12,1			:
	JGE	HOSTC2			:LOOP THRU ALL HOSTS
	J	TORET			:AND THEN EXIT
  EI		
	SUBTTL	PORT TIMEOUT PROCESSORS

: PORT TIMEOUT PROCESSOR - CHECK EARLIEST ENTRY ON TIMEOUT LIST
: -------------------------------------------------------------
:
:	PTMOUT	EXECUTE ROUTINE IN THE TIMEOUT LIST WHOS TIME HAS COME
:
:	EXIT	RHP	HOST PORT NMBR FOR THIS CHAIN ENTRY
:		R1	ADDR REL TO .S OF ROUTINE ON TIMEOUT LIST
:		R0	CURRENT SLOWC TIME

PTMONW	L	R1,FASTC,,		:GET CURRENT TIME
PTMOUT	AHI	R1,RATE*PTMTIM		:PUT US ON TIMEOUT LIST AGAIN
	JAL	R5,TOPUT

PTM010	LH	RHP,PTMEAR		:GET PORT FOR NEXT ENTRY EARLY-LATE CHAIN
	JL	TORET			:RETURN NOTHING QUEUED

	LHL	R0,SLOWC+2,,		:GET CURRENT TIME
	SH	R0,TIMVAL,RHP,RHP	:EARLIEST ENTRY TIMED OUT YET?
	CHVR	R0,R0			:ADJUST FOR HALFWORD ARITHMETIC
	JL	TORET			:RETURN IF NOT TIMED OUT

	LH	R4,TIMCHN,RHP,RHP	:SET NEXT ENTRY 1ST IN EARLY-LATE CHAIN
	STH	R4,PTMEAR

:	EXECUTE PROCESS QUEUED
	LCS	R4,1
	STH	R4,TIMCHN,RHP,RHP	:DECHAIN PORT
	LIS	R4,0
	LHL	R1,TIMADR,RHP,RHP	:GET REL ADDR OF PROCESS
	STH	R4,TIMADR,RHP,RHP	:DEQUEUE PROCESS
	J	.S,R1			:EXECUTE PROCESS

PTMRET	EQ	PTM010			:ROUTINE RETURNS TO PTMRET


: PTMQUE - QUEUE PROCESS TO EXECUTE ON TIMEOUT

:	PTMQUE	QUEUE PROCESS TO EXECUTE ON TIMEOUT
:
:	ENTRY	R2	LINK ADDRESS
:		R1	ADDR REL TO .S OF PROCESS TO EXECUTE ON TIMEOUT
:		R0	VALUE, NO. OF SEC FROM NOW TO EXECUTE PROCESS
:			CANNOT BE > 9 HOURS
:		RHP	HOST PORT NMBR ASSOCIATED WITH REQUEST
:
:	EXIT	R3,R0,R1,R4,R5 DESTROYED

PTMQUE	AH	R0,SLOWC+2,,		:MAKE TIMEOUT CLOCK VALUE
	NI	R0,0FFFF		:MAKE HALFWORD VALUE
	JAL	R3,PTMDQU		:DEQUE IF ALREADY QUEUED
	STH	R0,TIMVAL,RHP,RHP	:SET TIMEOUT VALUE
	STH	R1,TIMADR,RHP,RHP	:SET PROCCES TO EXECUTE

	LI	R4,(PTMEAR-TIMCHN)/2	:INIT LAST EARLIER ENTRY
	LH	R1,PTMEAR		:GET FIRST ENTRY IN CHAIN
	JL	PQT030			:IF NO ENTRIES IN CHAIN

PQT020	LR	R5,R0			:CURRENT REQUEST TIME
	SH	R5,TIMVAL,R1,R1		:IS NEXT ENTRY LATER?
	CHVR	R5,R5			:ADJ FOR HALFWORD ARITH
	JLFS	PQT030			:IF LATER ENTRY FOUND

	LR	R4,R1
	LH	R1,TIMCHN,R1,R1		:NEXT EARLY-LATE ENTRY
	JGEBS	PQT020			:IF NOT END OF CHAIN, KEEP LOOKING

:	LATER ENTRY FOUND, SPLICE REQUEST INTO CHAIN
PQT030	STH	RHP,TIMCHN,R4,R4	:POINT EARLIER ENTRY TO NEW REQUEST
	STH	R1,TIMCHN,RHP,RHP	:POINT REQUEST TO LATER ENTRY
	JR	R2			:DONE


: PTMDQU - DEQUEUE PROCESS AWAITING TIMEOUT

:
:	PTMDQU	DEQUEUE PROCESS AWAITING TIMEOUT
:
:	ENTRY	R3	LINK ADDRESS
:		RHP	HOST PORT NMBR ASSOCIATED WITH REQUEST
:	EXIT	R4,R5	DESTROYED

PTMDQU	LH	R4,TIMADR,RHP,RHP	:GET THIS PORT'S TIME CHAIN
	JER	R3			:IF NOT QUEUED, IGNORE
	LI	R4,(PTMEAR-TIMCHN)/2	:INIT LAST EARLIER ENTRY

PDQ010	LH	R5,TIMCHN,R4,R4		:GET NEXT CHAIN ENTRY
	CR	R5,RHP			:POINTING TO DEQUEUE REQUEST?
	JEFS	PDQ020			:IF DEQUEUE REQUEST FOUND

	LR	R4,R5
	JGEBS	PDQ010			:IF NOT END OF CHAIN, CONTINUE
	JR	R3			:NO ENTRY FOUND, IGNORE REQUEST

:	FOUND PORT FOR DEQUEUE REQUEST IN TIMEOUT CHAIN
PDQ020	LH	R5,TIMCHN,RHP,RHP	:GET NEXT IN CHAIN
	STH	R5,TIMCHN,R4,R4		:POINT EARLIER ENTRY TO IT
	LCS	R5,1
	STH	R5,TIMCHN,RHP,RHP	:CLEAR CHAIN ENTRY
	LIS	R5,0
	STH	R5,TIMADR,RHP,RHP
	JR	R3			:DONE


: PTMEXC - QUEUE CURRENT TIMEOUT PROCESS FOR IMMEDIATE EXECUTION

:	PTMEXC	IF TIMEOUT PROCESS OUTSTANDING, QUEUE IT FOR IMMEDIATE
:		EXECUTION
:
:	ENTRY	R6	LINK REGISTER
:		RHP	HOST PORT NMBR ASSOCIATED WITH REQUEST
:	EXIT	R4,R5,R0,R1,R2,R3 DESTROYED

PTMEXC	LH	R1,TIMADR,RHP,RHP	:GET ADDR CURRENT TIMEOUT PROCESS
	JER	R6			:IF NO PROCESS OUTSTANDING, IGNORE

	JAL	R3,PTMDQU		:DEQUEUE THE PROCESS
	LIS	R0,0			:EXECUTE 0 SECONDS FROM NOW
	SBT	R0,PTMNOW		:FLAG IMMEDIATE EXECUTION
	JAL	R2,PTMQUE		:REQUEUE FOR EXECUTION
	JR	R6			:DONE
	SUBTTL	DETACH ROUTINES

: DETMSG - SEND A MESSAGE AND DETACH

:       ENTRY   R3      ADDRESS OF MESSAGE IN SC FORMAT
:		R6	LINK REG
:		R8	SORD NMBR
:		RIP	ISIS PORT NMBR
:		RHP	HOST PORT NMBR (-1 IF NONE)

DETMSG  LR	RIP,RIP
	JLE	DET200		:IF NO ISIS PORT
        LB      R5,0,R3
        JEFS    DETIP           :IF NO MESSAGE
        JAL     R5,QOCS         :OUTPUT THE MESSAGE

: DETIP - DETACH AN ISIS PORT

:       ENTRY   R10     DETACH TYPE FOR ACCOUNTING

DETIP   LR	R1,RIP
	JLE	DET200		:IF NO ISIS PORT
  IF	OP|E8BTM.|
	RBT	RIP,IP8BM	:TURN OFF IP8BM 
	RBT	RIP,ETMFLG	:TURN OFF ENTER TRANSPARENCY MODE FLAG
	JEFS	DET02		:IF NO TRANSPARENCY MODE SET
        TBT     RHP,LOGING      :LOGIN MODE CAN ONLY SEND DETACH (OR ZAP)
        JNFS    DET02           :IS SET SO SKIP
	LHI	R2,CM.LTM	:NETWORK "LEAVE TRANSPARENCY" MESSAGE
	LHI	R0,LTM.L	:MESSAGE LENGTH
	JAL	R4,SLOR
	JAL 	R4,ELOR
DET02	HS
  EI
DET007	SBT	RIP,TOISON	:TURN ON OUTPUT TO ISIS
	SBT	RIP,FRISIS	:TURN OFF BKPR OF ISIS
	JNFS	DET010		:BR IF ALREADY OFF
        TBT     RHP,LOGING      :LOGIN MODE CAN ONLY SEND DETACH (OR ZAP)
        JNFS    DET010          :IS SET SO SKIP
	LIS	R0,SND.L
	LHI	R2,CM.SND	:SEND RELEASE BP MSG
	JAL	R4,SLOR
	JAL	R4,ELOR
DET010	LH      R2,HPN,RIP,RIP  :COULD BEFILE TRANSFER CIRCUIT
        JLFS    DET011          :NO PORT SO NOT FT
        TBT     R2,ORIRLA       :WAS IT A FT?
        JN      DET013          :YES, OTHER END DOES ZAP ACCOUNTING
DET011  LHI     R2,CM.ADA
	LHI     R3,ADA.L        :ACTNG ADDENDUM LENGTH
        JAL     R5,QSLOR
        JAL     R4,QPUTCH       :PAD
        LR      R0,R10          :TYPE
        AI      R0,AA.DET       :DETACH TYPE ADDENDUM
        JAL     R4,QPUTW
        JAL     R4,QELOR
DET013  LHI     R2,CM.DET       :DETACH MSG TYPE
        LHI     R3,DET.L        :DETACH MSG LENGTH
        JAL     R5,QSLOR        :SEND DETACH
        JAL     R4,QELOR        :END MSG
	LH      R2,HPN,RIP,RIP  :GET HOST PORT #
        JL      DET200          :IF NO HOST PORT
	LR	RHP,R2
	LCS	R5,1
	STH	R5,HPN,RIP,RIP	:REMOVE HOST PORT NMBR
	LIS	R5,0
	STH	R5,IPN,RHP,RHP	:TEMP REMOVE ISIS PORT NMBR
        RBT     RHP,RING        :STOP RINGING
        SBT     RHP,TOPTON      :CLEAR BACKPRESSURE
  IF    ABNDN+1         	:IF ABNORMAL DISCONNECT MSG
	TBT	RHP,WATHST
	JNFS	DET015		:NO MSG IF HOST NEVER KNEW WE WERE HERE
   IF   ABNDN   		:IF >1 ENTRY
        LHL     R5,ABNPTR,R8,R8 :GET MSG ADDRESS FOR THIS SORD
        LA      R10,.S4,R5,
   ELSE
        LA      R10,ABNDM,,
   EI
	ST	R6,DETSAV
        JAL     R6,PMSDR
	L	R6,DETSAV
  EI
DET015	TBT     RHP,SIN
        JN      DET020          :IF HOST NOT THERE
  IF    RXONN+1         	:IF REVERSE XON ENABLED
        SBT     RHP,RXONON
  	JNFS	DET017
	TBT	RHP,OTAM
	JEFS	DET016
	SBT	RHP,TAM
DET016	TBT	RHP,OFDDT
	JEFS	DET017
	SBT	RHP,FDDAT
DET017	HS
  EI
	LHI	R0,AO.RSD	:INSURE RING IS DOWN
	JAL	R5,PECDR
	RBT	RHP,RNGTGL
	JFS	DET030

DET020  SBT     RHP,DTR         :DROP PORT
DET030	LHI	R0,AO.DSC	:DISCONNECT ASYNC
	JAL	R5,PECDR
	LR	R8,R8
	JE	DETHP		:BR IF DETACHING REMOTE TOM
  IF	NAPORT
	SBT	RHP,NDTR	:TAKE DTR DOWN AFTER ALL
	SBT	RHP,DTRWT	:*DATA HAS BEEN OUTPUT
  ELSE
	SBT	RHP,DTR		:INDICATE DTR DOWN
  EI
        RBT     RHP,ORIRLA      :NO LONGER IN USE
        JEFS    DET031
        RBT     RHP,ACP
DET031  RBT     RHP,LOGING      :NOT IN LOGING MODE
        RBT     RHP,GOT.PN      :DEFINITELY NO PSEUDO NEEDLE LEFT
	RBT	RHP,WATHST	:IF WE ARE STILL WAITING,
	JN	DETHP2		:*THEN GO DETACH HOST PORT NOW
  IF    NHAN            	:IF MORE THAN 1 VALUE
        LB      R0,NHASV,R8,    :TIME OUT VALUE FOR NO HOST ZAP
  ELSE
        LHI     R0,NHASV
  EI
        LHI     R1,DET100-.S    :ADDRESS TO RETURN IF TIMEOUT
        JAL     R2,PTMQUE
	JR	R6		:WAIT FOR HOST TO ZAP

:       HERE IF HOST DIDN'T ACKNOWLEDGE DETACH AFTER NHASV SECS.

DET100  LA      R5,NHAMSG,,     :NO HOST ZAP
	LR	R7,RHP
        JAL     R6,TOMMSG       :TELL TOM
        LH      R8,SORD,RHP,RHP
        TBT     R8,RLSPT,,      :RELEASE PORT?
        JNFS    DET105          :IF OK TO RELEASE OFFENDING PORT
        LHI     R0,NHAMRT*$A60  :REPEAT MSG AFTER NHZMRT MIN.
        LHI     R1,DET100-.S
        JAL     R2,PTMQUE
        J       PTMRET

DET105  LA      R6,PTMRET	:CHANGE RETURN ADDRESS TO TIMEOUT ROUTINE

: DETHP - DETACH HOST PORT

DETHP   RBT     RHP,WATHST      :INSURE WAIT-FOR-HOST-ANSWER IS OFF
DETHP2 	RBT     RHP,RING        :INSURE RING IS OFF
  IF	OP|E8BTM.|
	RBT	RHP,HP8BM	:INSURE HP8BM IS OFF
  EI
	LCS     R0,1
        RBT     RHP,ACP         :SET INACTIVE
        JEFS    DET110          :IF NOT CURRENTLY ACTIVE
        AHM     R0,APORTS       :DECREMENT COUNT
DET110  LH	RIP,IPN,RHP,RHP	:PUT ISIS PORT NMBR IN R1
	JL	DET200		:IF NO ISIS PORT
	STH	R0,IPN,RHP,RHP  :INDICATE HOST PORT CLEARED
        TBT     RHP,TSATPT      :HARDWIRED TOM PORT?
        JN      HDWZAP		:YES, GO CLEAR TOM PORT
        STH     R0,HPN,RIP,RIP  :REMOVE HOST PORT #
	LHI     R10,AA.DBH      :DROPPED BY HOST
        LA      R3,DBHMSG,,
        J       DETMSG

DET200	LR	RHP,RHP		:ANY HOST PORT?
	JLR	R6		:NO
	JAL     R3,PTMDQU       :DEQUEUE ANY ACTIVE TIMEOUTS
        JR      R6		:DONE
	SUBTTL	ISIS OUTPUT RING ROUTINES

:	I S I S   O U T P U T   R I N G   R O U T I N E S
:	=================================================


: QSLOR - START LOGICAL OUTPUT RECORD
:	ENTRY:	R2  = MSG TYPE (ZERO INDICATES DATA MSG)
:		R3  = LENGTH OF MSG
:		R5  = LINK REG
:		RIP = ISIS PORT NMBR

QSLOR	TBT	RIP,PIBUF	:ALREADY USING BFR?
	JN	QSL11		:BR IF YES
	TBT	RIP,TOISIS	:THIS PORT BACKPRESSURED?
	JEFS	QSL10		:BR IF YES
	TBT	RIP,TOISON	:THIS PORT READY?
	JEFS	QSL10		:BR IF NO
	JAL	R4,SPACE	:IS THERE ENOUGH ROOM IN RING?
	CLR	R0,R3
	JLFS	QSL10		:BR IF NOT
	LR	R0,R3
	LR	R1,RIP
	LR	R4,R5
	J	SLOR		:GO PUT IN RING

QSL10	SBT	RIP,PIBUF	:INDICATE BUFFERING DATA
QSL11	LR	R1,RIP		:GET TO.ISIS BFR NMBR
	AR	R1,R1
	EXHR	R0,R2		:SEE IF DATA MSG (VARIABLE LENGTH)
	JER	R5		:DONE IF SO
	JAL	R4,WCI		:PUT MSG TYPE IN BFR
	EXHR	R0,R0
	LR	R4,R5
	J	WCI		:RTRN THRU WCI

: QPUTCH - PUT CHAR IN RING (OR BUFFER)
:	ON ENTRY: R0  = CHAR
:		  R4  = LINK REG
:		  RIP = ISIS PORT NMBR

QPUTCH	TBT	RIP,PIBUF	:BUFFERING?
	JE	PUTCH		:NO, GO PUT IN RING
	LR	R1,RIP		:TO.ISIS BFR NMBR
	AR	R1,R1
	J	WCI		:GO BFR CHAR

: QPUTDC - PUT DATA CHAR IN RING (OR BUFFER)

QPUTDC	TBT	RIP,PIBUF	:BUFFERING?
	JE	PUTCH		:NO, GO PUT IN RING
	LR	R1,RIP		:TO.ISIS BFR NMBR
	AR	R1,R1
	LR	R0,R0		:DOES CHAR NEED ESCAPE?
	JN	WCI		:GO BFR CHAR IF NOT
	LR	R9,R4
	JAL	R4,WCI		:BUFFER AN ESCAPE
	LR	R4,R9
	J	WCI		:GO BFR CHAR

: QPUTW - PUT WORD IN RING (OR BUFFER)

QPUTW	TBT	RIP,PIBUF	:BUFFERING?
	JE	PUTW		:NO, GO PUT IN RING
	LR	R1,RIP		:TO.ISIS BFR NMBR
	AR	R1,R1
	LR	R9,R4		:SAVE RTRN ADDR
	EXHR	R0,R0
	EXBR	R0,R0
	JAL	R4,WCI		:OUTPUT 1ST BYTE
	EXBR	R0,R0
	JAL	R4,WCI		:OUTPUT 2ND BYTE
	EXHR	R0,R0
	EXBR	R0,R0
	JAL	R4,WCI		:OUTPUT 3RD BYTE
	EXBR	R0,R0
	LR	R4,R9
	J	WCI		:OUTPUT 4TH BYTE & RTRN

: QOCS - OUTPUT CANNED STRING

QOCS	TBT	RIP,PIBUF	:ALREADY USING BFR?
	JN	QOC11		:BR IF YES
	TBT	RIP,TOISIS	:THIS PORT BACKPRESSURED?
	JEFS	QOC10		:BR IF YES
	TBT	RIP,TOISON	:THIS PORT READY?
	JEFS	QOC10		:BR IF NOT
	JAL	R4,SPACE	:IS THERE ENOUGH ROOM IN RING
	LB	R2,0,R3		:*TO FIT THIS MSG?
	CLHI	R0,3,R2
	JLEFS	QOC10		:BR IF NOT
	LR	R2,RIP
	J	OCS

QOC10	SBT	RIP,PIBUF	:INDICATE BUFFERING DATA
QOC11	LR	R1,RIP		:TO.ISIS BFR NMBR
	AR	R1,R1
	LR	R9,R3
	LB	R7,0,R9		:GET MSG LENGTH
QOC20	JLE	QBK10		:RTRN IF MSG DONE
	LB	R0,1,R9		:GET CHAR
  IF	OP|E8BTM.|
	TBT	RIP,IP8BM	:8 BIT MODE?
	JEFS	QOC25		:IF NOT
	NHI	R0,007F		:SPACE PARITY FOR TYMCOM OUTPUT MESSAGE
QOC25	HS
  EI
	LR	R0,R0
	JNFS	QOC30		:BR UNLESS ESCAPE NEEDED
	JAL	R4,WCI		:ESCAPE CHAR
QOC30	JAL	R4,WCI		:BUFFER CHAR
	AIS	R9,1		:BUMP TO NEXT CHAR
	SIS	R7,1
	J	QOC20

: QELOR - END LOGICAL OUTPUT RECORD

QELOR	TBT	RIP,PIBUF	:BUFFERING?
	JE	ELOR		:NO, GO END RECORD
	JFS	QBKPR		:YES, CHECK BKPR

: QELODR - END LOGICAL OUTPUT DATA RECORD

QELODR	TBT	RIP,PIBUF	:BUFFERING?
	JE	ELODR		:NO, GO END RECORD

QBKPR	LR	R5,R4
QBK10	HS
   IF	XONN+1!OP|CTSBP.|
 
	LR	RHP,RHP		:SEE IF ANY HOST PORT
	JLR	R5		:RTRN IF NOT
   IF	OP|T2741.|!.GE.(UETMN,0)!.GE.(HETMN,0)
	TBT	RHP,TRANSP	:DON'T SEND XOFF IF TRANSPARENT
	JNR	R5
   EI
	LHL     R4,BCT,RIP,RIP  :GET CHAR CNT
        SHI     R4,XOFFLM       :TIME TO BACKPRESSURE?
        JLR     R5              :IF NOT TIME
	TBT	RHP,XONP	:IS XON ENABLED?
	JEFS	QBK30		:IF NO XON,EXIT
        RBT     RHP,XONON       :TEST AND CLEAR (HOST BACKPRESSURE ON)
        JEFS    QBK30           :IF XOFF ALREADY SENT
   IF   XONN    		:IF >1 VALUE
        LB      R0,XOFSV,R8,
   ELSE
        LHI     R0,XOFSV
   EI
	ST	R5,CTSTMP	
	JAL	R5,PCEDR        :SEND XOFF CHARACTER TO HOST
	L	R5,CTSTMP
QBK30	TBT	RHP,CTSBPP	:CTS BP ENABLE?
	JER	R5		:IF NOT	
	RBT	RHP,CTSBPF	:TEST & SET (HOST BP ON)
	JER	R5		:IF DELAY & SIGNAL ALREADY SENT
	LHI	R0,0F		:SEND HALF SEC DEALY
	ST	R5,CTSTMP
	JAL	R5,PEEDR
	L	R5,CTSTMP
	LHI	R0,AO.RSD	:SEND SIGNAL (RING DOWN)
	J	PEEDR
  ELSE
	JR	R5
  EI    (XONN+1!OP|CTSBP.|)
	SUBTTL	ASYNC DRIVER ROUTINES

:	A S Y N C   D R I V E R   R O U T I N E S
:	=========================================

: RGCLR - CLEAR ASYNC BUFFERS & RINGS

RGCLR	LHL	R2,BLKPTR,RHP,RHP  :GET PORT BLOCK ADDR
	AI	R2,ASRING
  IF	NMPORT
        TBT     RHP,SIOP	:SEE IF SIO PORT
        JN      RGCLR2		:BR IF SO
  EI
        RBT     RHP,DFDAT	:CLEAR ASYNC INPUT RING
	LCS	R1,1
	STH	R1,DFCNT,R2
	LIS	R1,DFSTR
        STB     R1,DFIN,R2
        STB     R1,DFOUT,R2

ORGCLR  SBT     RHP,TAM
	RBT	RHP,TAMR
        RBT     RHP,FDDAT	:CLEAR ASYNC OUTPUT RING
GOBCLR	LHL	R2,BLKPTR,RHP,RHP  :GET PORT BLOCK ADDR
	AI	R2,ASRING
	LCS	R1,1
	STH	R1,FDCNT,R2
	LHI	R1,5-FDSIZ+FDSTR
	STH	R1,FDTAM,R2
	LIS	R1,FDSTR
        STB     R1,FDIN,R2
        STB     R1,FDOUT,R2
  IF	NMPORT
	J	BFCLR

RGCLR2  LHL     R2,BLKPTR,RHP,RHP  :GET SIO PORT BLOCK ADDR
	AI	R2,ASRING
        LIS     R3,0
        STH     R3,SIOGET,R2	:CLEAR SIO BUFFERS
	STH	R3,SIOPUT,R2
	STH	R3,SIOPRO,R2
	ST	R3,SIOPRO+4,R2
	STH	R3,SIOOUT,R2
	LCS	R3,1
	LHI	R4,SIOISZ-4
RGCLR3	ST	R3,SIOIN,R4,R2
	SIS	R4,4
	JGEBS	RGCLR3
	LB	R3,PSPEED,RHP,	:INITIALIZE SIO CHIP
	CLHI	R3,SB-2000
	JEFS	RGCLR4
	LI	R1,31444
	LI	R3,30560
	LI	R4,303C0
	JFS	RGCLR5
RGCLR4	LI	R1,31448
	LI	R3,30510
	LI	R4,30300
RGCLR5	ST	R1,SIOCMD,R2
	ST	R3,SIOCMD+4,R2
	ST	R4,SIOCMD+8,R2
	ST	R3,SIOCMD+14,R2
	LI	R4,5FFFF	:SET UP TO INIT XON/XOFF CHARS
   IF	.NE.(ESCN,0)
	LH	R3,SORD,RHP,RHP
	JL	RGCLR6
    IF	ESCN
	LB	R1,ESCSV,R3,
	CLHI	R1,0FF
	JN	RGCLR6
    EI
    IF	RXONN+1
     IF RXONN
	LB	R1,RXONSV,R3,
	EXBR	R4,R1
	LB	R1,RXOFSV,R3,
	STBR	R1,R4
     ELSE
	LI	R4,50000+RXONSV^8+RXOFSV
     EI
    EI
   EI
RGCLR6	ST	R4,SIOCMD+0C,R2
	LIS	R4,0
	ST	R4,SIOCMD+10,R2
	LIS	R4,1
	STH	R4,SIOCMQ,R2
	SBT	RHP,SIOBP-NAPGRP*2
	RBT	RHP,TAM
	SBT	RHP,DFDAT
	LB	R0,SIOLUN,R2	:START INPUT PROGRAM
	LA	R1,SIOPRI,R2
	SVC	IO,FMBIN.*10+R0
	J	SIOERR
  EI
BFCLR   LA	R1,TOPRT,RHP,RHP  :CLEAR TOPORT BUFFER
	JAL	R4,EMPTY
        JR      R5

: GCDR - GET CHAR FROM DRIVER
:       CHAR IN R0, WIPES R1,R2, LINK ON R3
:	RETURNS:  RTRN+0  NO CHARS IN BUFFER
:		  RTRN+4  DATA CHAR
:		  RTRN+8  ESCAPED CHAR

GCDR	HS
  IF	NMPORT
	TBT	RHP,SIOP	:SEE IF SIO PORT
	JN	GCDR10		:BR IF SO
  EI
	TBT	RHP,DFDAT	:SEE IF BUFFER HAS DATA
	JER	R3		:NON-SKIP RTRN IF NOT
	LHL	R2,BLKPTR,RHP,RHP  :GET RING ADDR
	AI	R2,ASRING
	LH	R1,DFCNT,R2	:GET CHAR CNT
	CLHI	R1,DFSIZ-DFSTR	:SEE IF RING OVERFLOWED
	JGE	GCDR5		:BR IF SO
	LB	R1,DFOUT,R2	:GET OUR CURSOR
        LB      R0,DFBUF,R1,R2  :GET CHAR
        AIS     R1,1            :BUMP CURSOR
        CLHI    R1,DFSIZ        :FOLD IF NECESSARY
        JNFS    GCDR1
        LIS     R1,DFSTR
GCDR1   LR	R0,R0		:SEE IF ESCAPE
	JEFS	GCDR2		:IF SO
	STB     R1,DFOUT,R2     :SAVE UPDATED CURSOR
	LCS	R1,1		:DECR COUNT OF CHARS IN RING
	AHM	R1,DFCNT,R2
        JGE     4,R3            :STILL MORE DATA, RTRN WITH DATA
	CBT     RHP,DFDAT       :ELSE TURN OFF DATA PRESENT FLAG
	J	4,R3		:*AND RTRN WITH DATA

GCDR2	LH	R0,DFCNT,R2	:ESCAPED CHAR, SEE IF ANOTHER
	JLE	ESCERR		:BR IF NOT, FATAL ERROR
	LB	R0,DFBUF,R1,R2	:GET CHAR
	JNFS	GCDR3
	SIS	R3,4		:IF NULL DATA CHAR
GCDR3	AIS	R1,1		:BUMP CURSOR
	CLHI	R1,DFSIZ	:FOLD IF NECESSARY
	JNFS	GCDR4
	LIS	R1,DFSTR
GCDR4	STB	R1,DFOUT,R2	:SAVE CURSOR
	LCS	R1,2		:DECR CNT OF CHARS IN RING
	AHM	R1,DFCNT,R2
	JGE	8,R3		:STILL MORE DATA, RTRN WITH CTRL CODE
	CBT	RHP,DFDAT	:ELSE TURN OFF DATA PRESENT FLAG
	J	8,R3		:*AND RTRN WITH CTRL CODE

GCDR5	LHI	R1,DFSTR-DFSIZ	:RING WRAP, REMOVE DATA
	AHM	R1,DFCNT,R2
	LHI	R0,AI.BLK	:SEND BLACK BALL
	J	8,R3		:RTRN WITH CTRL CODE

  IF	NMPORT
GCDR10	LHL	R2,BLKPTR,RHP,RHP  :SET UP SIO AREA PNTR
	AI	R2,ASRING
	LH	R1,SIOGET,R2	:GET PNTR TO NEXT INPUT CHAR
GCDR15	LH	R0,SIOIN,R1,R2	:SEE IF CHAR IN
	JGE	GCDR30		:BR IF SO
	AIS	R1,0F		:BUMP TO NEXT INPUT BFR
	NHI	R1,70
	LH	R0,SIOIN,R1,R2	:SEE IF NEXT BFR STARTED
	JGEFS	GCDR20		:BR IF SO
	RBT	RHP,DFDAT	:INDICATE NO MORE DATA
	JR	R3
GCDR20	LH	R1,SIOGET,R2	:MAKE SURE SIO DIDN'T SLIP ONE BY US
	LH	R0,SIOIN,R1,R2	:TRY LAST BFR
	JGEFS	GCDR30		:BR IF FOUND, GOOD THING WE CAUGHT IT
	AIS	R1,0F		:ALL IS NORMAL, BUMP TO NEXT CHAR FOR REAL
	NHI	R1,70
	LH	R0,SIOIN,R1,R2
GCDR30	TS	SIOIN,R1,R2	:SET CHAR TO -1
	AIS	R1,2		:BUMP INPUT CHAR PNTR
	NHI	R1,7F
	STH	R1,SIOGET,R2	:UPDATE INPUT CHAR PNTR
	THI	R0,0100		:SEE IF BREAK
	JE	4,R3		:NO, RTRN WITH DATA
	LHI	R0,AI.BRK	:SET TO BREAK CODE
	J	8,R3		:RTRN WITH CTRL CODE
  EI

ESCERR	TRAP(R3,28)		:ESCAPE NOT FOLLOWED BY ANYTHING
SIOERR	TRAP(R5,21)		:ERROR RETURN FROM SIO

: PCEDR - SEND CHAR TO DRIVER POSSIBLY PRECEDED BY CTLESC CHAR

PCEDR	HS
  IF    ESCN+1          	:IF CHAR MUST BE ESCAPED
   IF   ESCN            	:IF >1 VALUE
        TBT     RHP,ESCP
        JEFS    PPCDR           :IF NOT FOR THIS HOST
	LR	R7,R0		:SAVE DATA CHAR
        LB      R0,ESCSV,R8,
   ELSE
	LR	R7,R0		:SAVE DATA CHAR
        LHI     R0,ESCSV
   EI
	LR	R9,R5		:SAVE RTRN ADDR
	JAL	R5,PPCDR	:SEND CTLESC CHAR
	LR	R5,R9		:RESTORE RTRN ADDR
	LR	R0,R7		:RESTORE DATA CHAR
  EI

: PPCDR - SET UP PARITY AND SEND A DATA CHAR TO DRIVER
:	ON ENTRY  R0 = CHAR
:		  R5 = LINK REG

PPCDR	HS
  IF    OP|PARC.|
	TBT     RHP,PARCEP,,    :PARITY CHECK ENABLED?
        JE      PDCDR		:NO, GO SEND CHAR
        NHI     R0,7F           :YES...COPY THE CHAR WITH PARITY OFF
        TBT     RHP,PAREOP
        JNFS    PPC10           :IF EVEN/ODD
        TBT     RHP,PAREMP
        JEFS    PDCDR           :IF SPACE PARITY
	JFS	PPC30		:GO SET PARITY

PPC10   TBT     RHP,PAREMP
        JEFS    PPC20           :IF ODD
        TBT     R0,PARBIT
        JEFS    PDCDR           :SPACE EVEN PARITY
	JFS	PPC30		:GO SET PARITY

PPC20   TBT     R0,PARBIT
        JNFS    PDCDR           :SPACE ODD PARITY
PPC30	OHI     R0,80           :MARK PARITY BIT
  EI    (PARC.)

: PDCDR - SEND DATA CHAR TO DRIVER

PDCDR	LR	R0,R0		:DOES CHAR NEED ESCAPE?
	JE	PECDR		:BR IF SO, FALL THRU IF NOT

: PCDR - SEND CHAR TO DRIVER

PCDR    TBT	RHP,TOPORT	:SEE IF CHARS IN BFR ALREADY
	JN	PCD10		:YES, PUT THIS IN BFR TOO
	TBT	RHP,TAM		:SEE IF BACKPRESSURED
	JE	PCD10		:YES, PUT IN BFR
PCCDR	LHL	R2,BLKPTR,RHP,RHP  :GET PORT BLOCK ADDR
	AI	R2,ASRING
  IF	NMPORT
	TBT	RHP,SIOP	:SEE IF SIO PORT
	JN	PCD20		:BR IF SO
  EI
	LB	R1,BRATE,RHP	:GET BAUD RATE FOR THIS PORT
	OH	R0,BAUDOT,R1,R1	:DO ISIS'S DIRTY WORK FOR IT
	LB	R1,FDIN,R2	:GET OUR CURSOR
        STB     R0,FDBUF,R2,R1  :STUFF DATA CHAR
        AIS     R1,1            :INC CURSOR
        CLHI    R1,FDSIZ        :CHECK FOR FOLDING
        JNFS    PCD4
        LIS     R1,FDSTR
PCD4    STB     R1,FDIN,R2      :SAVE UPDATED CURSOR
	LIS	R1,1		:INCR COUNT OF CHARS IN RING
	AHM	R1,FDCNT,R2
	JGFS	PCD5		:BR IF NOT ONLY CHAR
	CBT	RHP,FDDAT	:TURN ON DATA PRESENT FLAG
PCD5	AHM	R1,FDTAM,R2	:BUMP TAM CNTR
	JLR	R5		:RTRN IF NO BACKPRESSURE
	JGFS	PCD6		:GO CHECK TAMR
	SBT	RHP,TAMR	:NOTE THAT PASSED ZERO
	JR	R5		:RETURN
PCD6	RBT	RHP,TAMR	:SEE IF MARKED YET
	JER	R5		:RTRN IF NOT
	CBT	RHP,TAM		:SET TAM
        JR      R5		:RETURN

PCD10	LA	R1,TOPRT,RHP,RHP :MAKE TO.PORT BFR NMBR
	JAL	R4,WCI		:PUT CHAR IN BFR
	JR	R5		:RETURN
	
  IF	NMPORT
PCD20	LH	R3,SIOPUT,R2	:PNT TO CUR OUTPUT BFR
	LB	R1,BRATE,RHP
	NH	R0,BAUDON,R1,R1
	LH	R1,SIOOUT,R2,R3 :GET CNT IN BFR
	AR	R1,R3
	STB	R0,SIOOUT+2,R2,R1 :SAVE CHAR
	LH	R1,SIOOUT,R2,R3	:BUMP CNT IN BFR
	AIS	R1,1
	STH	R1,SIOOUT,R2,R3
	CLHI	R1,SIOOSZ/2-2	:SEE IF BFR FULL
	JL	PCD30		:BR IF NOT
	RBT	RHP,TAM		:BACKPRESSURE OUTPUT
	LB	R1,SIOPRO+1,R2	:SEE IF SIO DONE WITH PREV OUTPUT
	JN	PCD30		:BR IF NOT
	LA	R1,SIOOUT,R2,R3	:MAKE OUTPUT PROGRAM
	SRLS	R1,4
	OI	R1,40000
	ST	R1,SIOPRO,R2
	LB	R0,SIOLUN,R2	:START DATA OUTPUT
	LA	R1,SIOPRO,R2
	SVC	IO,FMBOT.*10+R0
	J	SIOERR
	XHI	R3,SIOOSZ/2	:SWAP OUTPUT BUFFERS
	STH	R3,SIOPUT,R2
	LIS	R1,0		:CLEAR CHAR CNT
	STH	R1,SIOOUT,R2,R3
	SBT	RHP,TAM		:CLEAR BACKPRESSURE
	RBT	RHP,SIOBP-NAPGRP*2
	JR	R5

PCD30	SBT	RHP,SIOBP-NAPGRP*2  :FORCE CHECKING
	JR	R5
  EI

BAUDOT	HC	0,0,0,0,0,0,0,0,0,0,0,0,0,0E0,0E0,0	:DIDDLE BITS FOR BAUDOT
BAUDON	HC	0FF,0FF,0FF,0FF,0FF,0FF,0FF,0FF,0FF,0FF,0FF,0FF,0FF,01F,01F,0FF

: PECDR - SEND ESCAPED CHAR TO DRIVER

PECDR   TBT	RHP,TOPORT	:SEE IF CHARS IN BFR ALREADY
	JN	PECD10		:YES, PUT THIS IN BFR	JE	PECD10		:YES, PUT IN BFR
PEEDR	LHL	R2,BLKPTR,RHP,RHP  :GET PORT BLOCK ADDR
	AI	R2,ASRING
  IF	NMPORT
	TBT	RHP,SIOP	:SEE IF SIO PORT
	JN	PECD20		:BR IF SO
  EI
	LB	R1,FDIN,R2	:GET OUR CURSOR
	LIS	R3,0
        STB     R3,FDBUF,R1,R2  :STUFF ESCAPE CHAR
        AIS     R1,1            :INC CURSOR
        CLHI    R1,FDSIZ	:FOLD IF NECESSARY
        JNFS	PECD2
        LIS     R1,FDSTR
PECD2	STB	R0,FDBUF,R2,R1	:STUFF CHAR
	AIS	R1,1		:INC CURSOR
	CLHI	R1,FDSIZ	:FOLD MAYBE
	JNFS	PECD3
	LIS	R1,FDSTR
PECD3	STB	R1,FDIN,R2	:SAVE UPDATED CURSOR
	LIS	R1,1
	AHM	R1,FDCNT,R2	:INCR COUNT OF CHARS IN RING
	JGFS	PECD4		:BR IF NOT ONLY CHAR
	AHM	R1,FDCNT,R2	:INCR CNT AGAIN
	LIS	R1,2
	AHM	R1,FDTAM,R2	:INCR TAM CNTR TWICE
	CBT	RHP,FDDAT	:TURN ON DATA PRESENT FLAG
	JR	R5		:RETURN
PECD4	AHM	R1,FDCNT,R2	:INCR CHAR CNT
	AHM	R1,FDTAM,R2	:INCR TAM CNTR
	JGFS	PECD5		:BR IF NOT ONLY CHAR
	SBT	RHP,TAMR	:MARK TRANSITION
PECD5	AHM	R1,FDTAM,R2	:BUMP TAM AGAIN
	JLER	R5
	RBT	RHP,TAMR	:SEE IF MARKED YET
	JER	R5		:RTRN IF NOT
	CBT	RHP,TAM		:SET TAM
	JR	R5		:RETURN

PECD10	LA	R1,TOPRT,RHP,RHP :MAKE TOPORT BFR NUMBER
	EXBR	R0,R0
	NHI	R0,0FF00
	JAL	R4,WCI		:PUT ESCAPE IN BFR
	EXBR	R0,R0
	JAL	R4,WCI		:PUT CHAR IN BFR
	JR	R5

  IF	NMPORT
PECD20	LR	R0,R0		:SEE IF REALLY NULL DATA
	JE	PCD20		:BR IF SO
	SHI	R0,AO.EDM	:SEE IF IN RANGE OF THINGS WE DO
	CLHI	R0,SIOBRL
	JCR	R5		:IGNORE IF NOT
	LIS	R3,0
	LR	R1,R0
	LH	R1,SIOBR,R1,R1	:GET BR ADDR
	J	.S,R1,		:GO HANDLE CONTROL CODES

SCMEDM	LH	R1,SIOCMD+6,R2  :EDM = ENABLE RCVR/XMTR & RAISE DTR
	OHI	R1,0088
	NHI	R1,0FFEF
	STH	R1,SIOCMD+6,R2  :WRITE REG 5
	L	R1,SIOCMD+8,R2
	OI	R1,30001
	ST	R1,SIOCMD+8,R2  :WRITE REG 3
	STH	R3,SIOCMD+0C
	J	SCMQUE

SCMDSC	LH	R1,SIOCMD+16,R2 :DSC = DISABLE RCVR/XMTR & LOWER DTR
	STH	R1,SIOCMD+6,R2
	L	R1,SIOCMD+8,R2
	OI	R1,30000
	NHI	R1,0FFFE
	ST	R1,SIOCMD+8,R2
	STH	R3,SIOCMD+0C
	JFS	SCMQUE

SCMRSU	LH	R1,SIOCMD+6,R2  :RSU = ENABLE XMTR & RAISE RTS
	OHI	R1,0A
	JFS	SCMQUC

SCMRSD	LH	R1,SIOCMD+6,R2  :RSD = LOWER RTS
	NHI	R1,0FFFD
SCMQUC	STH	R1,SIOCMD+6,R2
	STH	R3,SIOCMD+8,R2
SCMQUE	LIS	R3,1
	J	SCMQUS		:GO SEE IF IT CAN BE OUTPUT NOW

SCMBRK	LH	R1,SIOCMD+6,R2  :BRK = SEND BREAK
	OHI	R1,10
	STH	R1,SIOCMD+6,R2
	STH	R3,SIOCMD+8,R2
    IF	BKSN
	LH	R1,SORD,RHP,RHP	:GET SORD NMBR
	LB	R1,BKSSV,R1,	:GET LEN OF BRK IN 83 MSEC INCR
    ELSE
	LHI	R1,BKSSV	:GET LEN OF BRK IN 83 MSEC INCR
    EI
	SR	R3,R1
SCMQUS	STH	R3,SIOCMQ,R2	:INDICATE CMD QUEUED
	SBT	RHP,SIOBP-NAPGRP*2
	RBT	RHP,TAM		:SET BACKPRESSURE
	LH	R3,SIOPUT,R2	:PNT TO CUR OUTPUT BFR
	LH	R1,SIOOUT,R2,R3 :SEE IF CHARS IN BFR
	JNR	R5		:RTRN IF SO
	LB	R1,SIOPRO+1,R2  :SEE IF SIO DONE WITH PREV OUTPUT
	JNR	R5		:RTRN IF NOT
	LB	R0,SIOLUN,R2
	LA	R1,SIOCMD,R2
	SVC	IO,FMBOT.*10+R0	:START COMMAND PROGRAM
	J	SIOERR
SCMRET	JR	R5
  EI

: PMSDR - SEND MESSAGE TO DRIVER

PMSDR	LB	R9,0,R10		:GET MESSAGE LENGTH
PMS10	JLER	R6		:RTRN IF MSG DONE
	LB	R0,1,R10	:GET CHAR OF MSG
	JE	PMS20
	JAL	R5,PPCDR	:OUTPUT TO DRIVER
	AIS	R10,1		:BUMP TO NEXT CHAR
	SIS	R9,1
	JBS	PMS10

PMS20	LB	R0,2,R10
	JAL	R5,PECDR
	AIS	R10,2
	SIS	R9,2
	J	PMS10

: CHKBP - CHECK IF NEED TO SEND BACK-PRESSURE TO ISIS

CHKBP	LR	R8,R8		:NO BKPR IF TOM
	JER	R5
	LA	R1,TOPRT,RHP,RHP :GET BFR ADDR
	LHL	R4,BCT,R1	:SEE IF NEED TO BKPR
	SHI	R4,BPONLM
	JLER	R5		:DONE IF ALREADY RESET
	LH	R1,IPN,RHP,RHP	:GET ISIS PORT NMBR
	JLER	R5		:BR IF NONE
	RBT	R1,FRISIS	:SET ISIS BP INDR
	JER	R5		:BR IF ALREADY SET
	LIS	R0,NOS.L
	LHI	R2,CM.NOS	:SEND SET BP MSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	JR	R5
	SUBTTL	UTILITY ROUTINES

: CHSTAT - CHANGE HOST STATUS
:
:	CHANGES HOST STATUS TO GONE, DOWN,
:	SHUT OR ANSWERED.
:
:	ENTRY	R5	LINK
:		R6	RELATIVE HOST NUMBER
:		R9	NETWORK HOST #
:		R12	STATUS	0-ANSWERED, 1-DOWN, 2-SHUT, 3-GONE
:
:	USES	R0-4,15

CHSTAT	HS
	LIS	R0,XHS.L	:LENGTH OF MSG
	LIS	R1,0		:SEND TO INTRA-NODE PORT
	LHI	R2,NM.XHS	:EXTENDED HOST STATUS MSG TYPE
	JAL	R4,SLOR		:START MSG
	JAL	R4,PUTCH	:GARBAGE KEY
	EXHR	R0,R9		:GET HOST NUMBER
	LB	R4,PORTS+1,R6,R6 :GET PORT COUNT
	OR	R0,R4
	JAL	R4,PUTW		:SEND HOST NUMBER AND PORT FLAG
	LR	R0,R6          	:GET RELATIVE HOST NUMBER
	JAL	R4,PUTH
  IF	HKEYN+1
	LHI	R0,4,R12	:GET HOST STATUS + KEY BIT
	EXBR	R0,R0		:POSITION STATUS BYTE
	LH	R4,HKEYTB,R6,R6
	STBR	R4,R0		:MERGE KEY BYTE
  ELSE
	LBR	R0,R12		:GET HOST STATUS
	EXBR	R0,R0		:POSITION STATUS BYTE W/ KEY BYTE=0
  EI
	JAL	R4,PUTH		:SEND STATUS BYTE/KEY BYTE
	LHI	R0,8000+PRODID	:SEND PRODUCT ID and smart host *300.sdw
	JAL	R4,PUTH
	JAL	R4,ELOR		:END RECORD
	JR	R5

: ZBUF - CALLED WHEN A BUFFER IS ZAPPED

ZBUF	CLHI	R1,TOPRT	:SEE IF TO.PORT BUFFER
	JGEFS	ZAPB10		:BR IF SO
        LIS     R0,0		:TO.ISIS BUFFER
        JAL     R4,WCI
        LHI     R0,CM.BLK       :BLACK BALL
        JAL     R4,WCI
	JR	R6

ZAPB10	CLHI	R1,TOPRT+(NHPORT-1)*2
	JGER	R6		:DONE IF TOM MSG BFR
	LIS	R0,0		:TO.PORT BUFFER
	JAL	R4,WCI
	LHI	R0,AO.EDM	:ENTER DATA MODE
	JAL	R4,WCI		:*(NOP SO BFR NOT EMPTY)
  IF	BZFTP-1
	LHL	R8,SORD-TOPRT,R1, :GET SORD NMBR
	TBT	R8,BZAPM,,	:SEE IF BFR ZAP MSG DESIRED
	JER	R6		:RTRN IF NOT
	LR	RHP,R1
	SHI	RHP,TOPRT
	SRLS	RHP,1		:MAKE HOST PORT NMBR
	LH	RIP,IPN,RHP,RHP	:GET ISIS PORT NMBR
	JLER	R6
	LA	R3,BZFTMS,,	:BUFFER ZAP FROM TERM MSG
	JAL	R5,QOCS
  EI
	JR	R6

: SNDGOB - SEND A GOBBLER TO ISIS

SNDGOB	LR	R1,RIP
	AR	R1,R1
        JAL     R4,EMPTY        :CLEAR TOFIT DIRECTION
	SBT	RIP,TOISIS	:CLEAR BACKPRESSURE
	RBT	RIP,PIBUF	:NO BUFFERING
        LHI     R2,CM.GOB       :GOBBLER MSG TYPE
	LIS	R3,GOB.L	:GOBBLER MSG LENGTH
        JAL     R5,QSLOR        :SEND GOBBLER
	JAL	R4,QELOR
  IF	XONN+1!OP|CTSBP.|
	TBT	RHP,CTSBPP	:CTS BP ENABLE?
	JEFS	SGOB20		:IF NOT
	SBT	RHP,CTSBPF	:TEST & SET (HOST BP OFF)
	JNFS	SGOB20		:SIGNAL AND DEALY ALREADY SENT
	LHI	R0,AO.RSU	:SEND SIGNAL (RING UP)
	JAL	R5,PECDR
	LHI	R0,0F		:SEND HALF SEC DELAY
	JAL	R5,PECDR
SGOB20	TBT	RHP,XONP	:IS XON ENABLED?
	JEFS	SGB100		:BR IF NOT
	SBT	RHP,XONON	:TURN OFF HOST BKPR
	JNFS	SGB100		:BR IF ALREADY OFF
   IF	XONN
	LB	R0,XONSV,R8,
   ELSE
	LHI	R0,XONSV
   EI
	JAL	R5,PCEDR	:SEND XON TO HOST
  EI
SGB100	HS
  IF	PFQN+1
	TBT	RHP,PFQP	:IS POLFLO ENABLED?
	JER	R10		:DONE IF NOT
	RBT	RHP,POLACK	:SEE IF ACK NEEDED
	JER	R10		:DONE IF NOT
   IF	PFQN
	LB	R0,PFASV,R8,
   ELSE
	LHI	R0,PFASV
   EI
	JAL	R5,PCEDR	:SEND BKPR ACK TO HOST
  EI
	JR	R10		:RETURN

: CBA - CONVERT BINARY TO ASCII.
:
:	ASCII NUMBER WILL BE OUTPUT IN REQUESTED RADIX RIGHT JUSTIFIED
:	WITH BLANK FILL IN A GIVEN FIELD IN MEMORY.
:
:	ENTRY	R7	BINARY #
:		R8	RADIX (2 TO 10 HEX)
:		R6	LINK
:		R5	ADDRESS TO DEPOSIT STRING
:		R4	SIZE OF FIELD IN CHARACTERS
:
:	DESTROYS R2,R3,R4

CBA	LR	R3,R7		:GET NUMBER TO SCRATCH REGISTER
CBA010	LIS	R2,0		:CLEAR UPPER HALF
	DR	R2,R8		:DIVIDE BY RADIX
	LB	R2,CBAASC,R2	:CONVERT TO ASCII
CBA020	STB	R2,-1,R5,R4	:SAVE CHARACTER
	SIS	R4,1		:COUNT CHARACTER IN STRING
	JLER	R6		:IF FIELD FULL
	LR	R3,R3		:NUMBER FULLY PROCESSED?
	JGBS	CBA010		:IF NOT
	LHI	R2,0A0		:BLANK
	JBS	CBA020		:GO BLANK FILL

CBAASC	AC	"0123456789ABCDEF"

: GETTIM - CONVERTS THE GMT CLOCK
:	RELATIVE TO 1/1/74 FROM SECONDS TO
:	DDMMMYY HH:MM:SS (GMT)
:	AND PLACES IT IN TIMAC (TIMSC MAY BE USED AS A SC LINE)
:
:	ENTRY	R4	LINK
:		R6	HOUR BIAS FOR ZONE, IF NONZERO, TIME WILL BE
:			RELATIVE TO THIS BIAS AND TIMSC WILL NOT CONTAIN
:			THE CHARACTERS "(GMT)" IN THE COUNT.
:
:	DESTROYS R2-12
:
:	DAYTIM - SAME AS GETTIM EXCEPT THAT ON ENTRY
:		R3 CONTAINS THE SECONDS VALUE TO CONVERT.
:		R6 IS NOT DEFINED FOR THIS ENTRY.

	RA	$0 0A

GETTIM	L	R3,GMT,,	:GET GMT SINCE 1/1/74
	LHI	R2,$A 22	:STRING SIZE FOR GMT
	LR	R6,R6
	JEFS	DTM010		:IF NO BIAS
	LHI	R7,60*60
	MR	R5,R7		:CONVERT TO SECONDS
	AR	R3,R6		:BIAS GMT TO LOCAL TIME
DAYTIM	LHI	R2,$A 16	:STRING SIZE FOR NO (GMT) OUTPUT
DTM010	STB	R2,TIMSC	:SAVE STRING SIZE
	ST	R4,DATRET	:SAVE RETURN LINK
	S	R3,SEC745	

:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULAR YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	LR	R12,R2		:SAVE TIME OF DAY
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
	LHI	R8,76		:BASE YEAR
	SLL	R3,2		:QUAD YEAR * 4
	AR	R8,R3		:ADD TO BASE YEAR
	LI	R3,LEPYEA	:POINT TO DAYS IN MONTH
	LR	R10,R2		:GET DAYS IN YEAR (IF LEAPYEAR)
	C	R2,W366		:IS IT IN CURRENT YEAR?
	JL	MONTHD		:JUMP IF SO
	S	R2,W366		:SUBTRACT DAYS IN YEAR
	AIS	R8,1		:ADD 1 TO YEAR
	LR	R11,R2		:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	AR	R8,R11
	LI	R3,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R10
:	YEAR IN R8
MONTHD	LIS	R9,0		:MONTH COUNTER
	AIS	R10,1		:MAKE 1/1/76 = DAY 1
MONLOP	LR	R7,R10		:SAVE DAYS
	LB	R6,0,R9,R3	:GET DAYS IN MONTH
	SR	R10,R6		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R9,1		:INCREMENT INDEX
	JBS	MONLOP
:
:	DAYS IN R7
:	MONTH NUMBER - 1 IN R9
:	YEAR IN R8
:
DAZE	LR	R10,R8		:SAVE YEAR
:
:	CONVERT DAY
	LIS	R4,2		:# OF OUTPUT CHARACTERS
	LA	R5,TIMAC
	LIS	R8,$A 10
	JAL	R6,CBA		:CONVERT BINARY TO ASCII
:
:	MOVE IN MONTH
	SLL	R9,2		:MULTIPLY MONTH NUMBER BY 4
	L	R4,MONTHS,R9	:GET THE NAME IN R4
	STB	R4,TIMAC+4
	SRL	R4,8
	STB	R4,TIMAC+3
	SRL	R4,8
	STB	R4,TIMAC+2
:
:	CONVERT YEAR
	LR	R7,R10
	LIS	R4,2
	LIS	R8,$A 10
	LA	R5,TIMAC+5
	JAL	R6,CBA		:CONVERT BINARY TO ASCII
	LR	R3,R12

:	DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:	IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:	ROUTINE IS ALL ABOUT
:
	SR	R2,R2		:CLEAR HI-ORDER BITS
	D	R2,SECDAY
:		SECONDS NOW IN R2
	LR	R3,R2		:GET READY FOR
	SR	R2,R2		:ANOTHER DIVIDE
	D	R2,TENOUR	:GET TENS OF HOURS
	AHI	R3,$00B0
	STB	R3,TIMAC+8
	DH	R2,OURS		:GET HOURS
:		R2 HAS REMAINDER, R3 HAS QUOTIENT
	AHI	R3,$00B0
	STB	R3,TIMAC+9
	DH	R2,TENMIN
	AHI	R3,$00B0
	STB	R3,TIMAC+11
	DH	R2,MIN
	AHI	R3,$00B0
	STB	R3,TIMAC+12

	DH	R2,TENSEC
	AHI	R3,$00B0
	STB	R3,TIMAC+14
	LR	R3,R2		:GET SECONDS IN R3
	AHI	R3,$00B0
	STB	R3,TIMAC+15
	L	R4,DATRET
	JR	R4		:DONE
:
:
SECDAY	WC	24*60*60	:SECONDS IN A DAY
TENOUR	WC	10*60*60	:TENS OF HOURS
OURS	HC	60*60		:HOURS
TENMIN	HC	10*60		:TENS OF MINS
MIN	HC	60		:MIN
TENSEC	HC	10		:TENS OF SECS
SEC745	WC	24*60*60*365*2
W365	WC	365
W366	WC	366
QUADAY	WC	4*365+1
LEPYEA	BC	31,29,31,30,31,30,31,31,30,31,30,31
REGYER	BC	31,28,31,30,31,30,31,31,30,31,30,31
	WS	0
MONTHS	AC	/ JAN/
	AC	/ FEB/
	AC	/ MAR/
	AC	/ APR/
	AC	/ MAY/
	AC	/ JUN/
	AC	/ JUL/
	AC	/ AUG/
	AC	/ SEP/
	AC	/ OCT/
	AC	/ NOV/
	AC	/ DEC/

	RA	0
	SUBTTL	FRONT PANEL DISPLAY

:	     F R O N T	 P A N E L   D I S P L A Y
:	     =====================================

:	FOREGROUND DISPLAY ROUTINE

FPFORE	LHL	R11,FPFCNT,,	:UPDATE FOREGROUND CYCLE CNTR
	AIS	R11,1
	STH	R11,FPFCNT,,

:	ACTIVE PORT DISPLAY

FPAPDS	LHI	R1,$A 10	:SCALE FORGROUND COUNTER
	DHR	R11,R1
	NHI	R12,0F		:ISOLATE LAST NIBBLE
	SLHLS	R12,0C		:POSITION
	LHL	R0,FPANEL,,	:GET BACKGROUND COUNTER
	NHI	R0,0F00		:ISOLATE
	OR	R0,R12		:INCLUDE FORGROUND COUNTER
	OH	R0,APORTS	:INCLUDE ACTIVE PORTS
	STH	R0,FPANEL,,	:DISPLAY ON FRONT PANEL
	JR	R10

:	BACKGROUND DISPLAY ROUTINE

FPBACK
	LHL	R0,FPBCNT,,	:UPDATE BACKGROUND CYCLE COUNTER
	AIS	R0,1
	STH	R0,FPBCNT,,

FPB010	LHI	R1,$A 20	:SCALE BACKGROUND COUNTER
	DHR	R0,R1
	NHI	R1,0F		:ISOLATE LAST NIBBLE
	EXBR	R1,R1		:POSITION
	LHL	R0,FPANEL,,
	NHI	R0,0F000	:ISOLATE FORGROUND COUNTER
	OR	R0,R1		:INCLUDE BACKGROUND
	OH	R0,APORTS	:INCLUDE ACTIVE PORTS
	STH	R0,FPANEL,,	:DISPLAY ON FRONT PANEL
	JR	R10		:EXIT

	SEG	A.DATA
FPBCNT	HS	1		:BACKGROUND CYCLE CNTR
FPFCNT	HS	1		:FOREGROUND CYCLE CNTR
	SUBTTL	ACTOM.300 --  TYMCOM OPERATIONS MANAGER
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by TYMNET, Incorporated.                                    **
: ******************************************************************
: **                   MODULE IDENTIFICATION                      **
: **                                                              **
: **  File Name          :  ACTOM.300       last change: 06/17/86 **
: **                                                              **
: **  File Abstract      :  Tymcom operation manager (TOM).       **
: **			    Tom initialization & execution loop,  **
: **			    Tom needle processor,                 **
: **			    Tom data processor,                   **
: **			    Tom command processors,               **
: **	        	    Tom periodic routines,                **
: **			    Tom utility routines.                 **
: **								  **
: **  File Description   :  TOM is a process used to monitor      **
: **			    and manipulate various dynamic options**
: **			    of the ISIS async Tymcom. Tymcom runs **
: **			    in a slot under ISIS. A terminal      **
: **			    connected to the TOM will receive all **
: **			    diagnostic messages output by Tymcom  **
: **			    and can be used to receive status     **
: **			    reports on the host processes and the **
: **			    ports associated with the slot. It    **
: **			    can also used to affect these statuses.*
: **			    The TOM may be accessed through a local*
: **			    hardwired port on the ISIS machine    **
: **			    or by logging in through the network. **
: **                                                              **
: ******************************************************************
: **                    CHANGE LOG                                **
: **                                                              **
: **  Ver   Date    By   PIR/NSR  Changes (most recent at top)    **
: ** ----- -------- ---  -------- ------------------------------- **
: ** 3.00  06/17/86 CAB  NSR 774  Fixed bug in UPTIME display.    **
: ** 2.06  05/27/86 CAB           Added UPTIME to STATUS command. **
: ** 2.06  04/14/86 CAB  NSR 681  Fixed port hang due to DOWN SORD**
: **                              setting TDROP for all SORD ports**
: **                              instead of just active ports.   **
: ** 2.06  04/07/86 CAB  NSR 669  Fixed multihost short status bug**
: ** 2.06  12/20/85 OJ            Add proprietary banner          **
: **								  **
: **								  **
: ** "      "      "	 NSR282   Fixed a problem of ports avail- **
: **				  able (via TOM) yet host shut    **
: **				  condition.                      **
: **	                                                          **
: ** "      "      "	 NSR287	  Fixed async host signal changes **
: **				  unshuting shut Tymcom host to   **
: **				  keep Tymcom from reporting host **
: **				  answered when it has been shut  **
: **				  via TOM. 			  **
: **						                  **
: ** "      "      DU     NSR377  Tom msg command bug     	  **
: **				  Fixed a problem in the Tom      **
: **			  	  message (ME) command. Removed an**
: **				  internal control character of ETX*
: **				  (03 hex) which was included in  **
: **				  the message when  a multiple    **
: **				  line message is entered.        **
: **								  **
: ** "     "      DU      PIR1823   Hardwire TOM modification     **
: ** 				    Tom is modified to support    **
: **				    the hardwire Tom ports whcih  ** 
: **				    can response the "O" TID      **
: **				    request and force all data to **
: **				    the terminals to space parity.**
: **								  **
: ******************************************************************

: TOM MACROES

OUTNUM  MACRO(BREG,SIZ)[
          IF    .NE.(BREG,R7)
                LR	R7,BREG
          EI
                LA      R5,TOMPWD+8
                LIS     R4,SIZ
                JAL     R6,CBA
                LIS     R7,SIZ
                JAL     R6,PMSTM1]

SKPMRK  MACRO(PNAM,SIZ,ARY,MAR)[
                LA      R7,PNAM,,
                JAL     R6,SPN
                LB      R8,TOMRAD
                LHI     R11,SIZ
                LA      R10,ARY
                JAL     R9,MNR
        IF      MAR+0
                JGE     TOMERR
                JGEFS   .+6
                JAL     R9,MAR
        ELSE
                J       TOMERR
        EI]

: TOM EQUATES

TM.SOH  EQ      01              :START OF DIAGNOSIC OUTPUT
TM.STX  EQ      02              :START OF TOM OUTPUT TEXT
TM.ETX  EQ      03              :END OF TOM OUTPUT TEXT

NNTMPT  EQ      NTPORT          :NUMBER OF NON TOM PORTS
NNTMGP  EQ      NHPGRP-1        :NUMBER OF NON TOM GROUPS
NTMTIS	EQ	NNTMGP*10-MAXPRT :DIFF FROM TOM HOST TO PSEUDO-ISIS PORT #
TOMPIX  EQ      NHPORT-NTOMPT-1 :FIRST TOM PORT NMBR
TOMLST	EQ	TOMPIX+NTOMPT-1	:LAST TOM PORT NMBR
TDMPT   EQ      NIPORT+NHPORT-1 :BFR # OF DIAGNOSTIC PORT

: TOM WORK AREAS

        SEG     A.DATA
TPN	HS	NTOMPT		:TOM TYMSAT PORT NMBR (-1 IF NONE)
EXRETT	WS	1		:EXEC RETURN ADDR
PCTMSV	WS	2		:PCTOM SAVE AREA
TSTHST	HS	1		:SAVE AREA FOR HOST NMBR
TSWSAV	HS	3		:TSWTCH PARAMETER SAVE AREA
TDMOFF  HC      0               :TOM DIAGNOSTIC MODE
TDMBP   HC      0               :TOM DIAGNOSTIC BACKPRESSURE
TDMOUT  HS      NTOMPT          :DIAGNOSTIC OUTPUT POINTER
TOMDEF  HC      1               :SAVE BID MASK
HKFLG	HC	0
TOMPWD  WS              :TOM CHANGE PASSWORD
  IF    \TOMPWM
        RE      8-(.-TOMPWD)    :SET TO 8 BYTES (TOMPWM GENERATES SOME)
        BC      0
        ER
   IF   .NE.(.-TOMPWD,8)
 REMARK >>>> ERROR **** TOMPW VALUE MUST BE < 8 CHARACTERS ****%
   EI
        KILL TOMPWM
  ELSE
        WC      0,0             :DEFAULT IS NULL PASSWORD
  EI
        WC      0,0             :PW SCRATCH AREA
TMOBWT  HC      0               :PORT NUMBER WAITING FOR OUTPUT DONE
TOMGET	WC	0		:PORT NMBR WAITING FOR INPUT COPIED TO RING
TOMLIC  HC      -1      :TERMINAL WITH TOM LICENSE
TOMGG   HC      0       :1 IF THIS USER IS A TOM GOOD GUY
TOMGGL  HS              :GOOD GUY USERNAME
  IF    \TOMGGM
  ELSE
        SC      \!##TOM##\
  EI
        KILL    TOMGGM
TOMRI   HS      NHPGRP
TOMRJ   HS      .MAX.(NSGRP,MAXTYP/8+1)
TOMRAD  BS      1       :CURRENT RADIX
        BS      NTOMPT          :DEFAULT RADIX FOR EACH TOMPT

TOMZON  HC      TZONE
TOMCWT  HS      NTOMPT          :NUMBER OF COMMANDS WAITING TO BE PROCESSED
TOMCON  HC      0               :ADDRESS-.S OF CONTINUATION PROCESSOR
        BC      0,0             :CONTINUATION PROCESSOR PORT #
	HC	0
TOMSAV	WS	10-5		:REG SAVE AREA FOR CONTINUATION

HSTSHT	HC	0		:HOST STATUS ARRAY,1=HOST SHUT,0=HOST ANSWER
: DEFINE TOM COMMANDS AND ADDRESSES.

        KILL    CMD
CMD     MACRO(CN)[
                AC      /CN/
                HC      TOM`CN-.S]

        SEG     A.RTBL          :READ ONLY TABLE AREA
TOMCMD  HS
:       THE FOLLOWING COMMANDS ARE ONLY FOR GOODGUYS
TOMCL2  HS
Q1      EQ      2               :GOODGUY LEVEL
Q2      EQ      0
  IF    NTMCL
        RE      NTMCL
        TMLM|Q2|
Q2      EQ      Q2+1
        ER
  EI
        CMD(CH)         :CHANGE

:       THE FOLLOWING COMMANDS NEED CHANGE LICENCE
TOMCL1  HS
Q1      EQ      1               :CHANGE LICENSE LEVEL
Q2      EQ      0
  IF    NTMCL
        RE      NTMCL
        TMLM|Q2|
        KILL    TMLM|Q2|
Q2      EQ      Q2+1
        ER
  EI
        CMD(AS)         :ASSIGN
        CMD(CA)         :CANDIDATE
        CMD(DO)         :DOWN
	CMD(HK)		:HOST KEYS
        CMD(ME)         :MESSAGE
	CMD(NT)		:NTRANSPARENT
        CMD(SH)         :SHUT
	CMD(SI)		:SIGNAL
        CMD(SP)         :SPEED
        CMD(TY)         :TYPES
        CMD(UP)         :UP
        CMD(ZO)         :ZONE
:       THE FOLLOWING COMMANDS DO NOT NEED LICENSE.
TOMCL0  HS
        CMD(DI)         :DIAGNOSTICS
        CMD(EN)         :ENQUIRE
        CMD(EX)         :EXIT
        CMD(GR)         :GRAB
        CMD(PA)         :PASSWORD
        CMD(RA)         :RADIX
        CMD(ST)         :STATUS
        CMD(TI)         :TIME
        CMD(TO)         :TO
        CMD(WH)         :WHO

        HC      0       :END OF TABLE
        KILL    CMD

: ENQUIRE OUTPUT AREA.

        SEG     A.WTBL
ENQHDR  SC      \ISIS ASYNC TYMCOM -- VERSION VVV.RRR"8D"8ASLOT SS  NODE NNNN"8D"8AISIS VERSION VVVVV  KERNEL HHHH"8D"8A\
ENQHD2	SC	\"8D"8ALOGICAL        PHYSICAL TYMCOM"8D"8A UNIT   DEVICE  PORTS   PORTS"8D"8A\

ENQSTS	WS	4
ENQPMP  SC      \  UU    DDD GG PPPPPPP TTTTTTT "8D"8A\

ENQTVN  EQ      $A 30+ENQHDR            :TYMCOM VER NUMBER
ENQTRN  EQ      $A 34+ENQHDR            :TYMCOM REVLEV #
ENQSLT  EQ      $A 6+38+ENQHDR          :TYMCOM SLOT #
ENQNOD  EQ      $A 15+38+ENQHDR         :NODE #
ENQIVN  EQ      $A 13+20+38+ENQHDR      :ISIS VERSION #
ENQKHN  EQ      $A 28+20+38+ENQHDR      :KERNEL HOST #
ENQLUN  EQ      $A 3+ENQPMP             :LOGICAL UNIT #
ENQDEV	EQ	$A 8+ENQPMP		:DEVICE NAME (WORD BOUNDARY)
ENQDVN  EQ      $A 13+ENQPMP            :DEVICE NMBR
ENQPHP  EQ      $A 16+ENQPMP            :PHYSICAL PORT # (WD BND)
ENQTCP  EQ      $A 24+ENQPMP            :FIRST TYMCOM PORT # (WD BND)

:       THE ORDER OF THE ENTRIES IN THE FOLLOWING TABLE IS SIGNIFICANT.

        SEG     A.RTBL          :READ ONLY TABLE AREA
TN.PRO  SC      /"8D"8A>/       :PROMPT
TN.POR  AC      /PORTS/
TN.ULL  AC      /ULL/   :(FULL)
TN.O    AC      /O/     :(TOSORDS)
TN.SOR  AC      /SORDS/
TN.MES  AC      /MESSAGES/
TN.HOS  AC      /HOSTS/
TN.UP   AC      /UP    /
TN.DOW  AC      /DOWN  /
TN.SHU  AC      /SHUT  /
TN.ACT  AC      /ACTIVE/
TN.VES  AC      /VESTIG/
TN.IFU  AC      /IFUP/
TN.SIG  AC      /SIG /
TN.BLA  AC      /    /
TN.AUD	AC	/AUDOT/	:(BAUDOT)
TN.HS	AC	/HOST/
SORHDR  SC      /SORD  HOST STATUS NAME/
PORHDR  SC      \PORT STATUS  TIME  CAND/SIG SORDS : TYPES>SPEED"8D"8A\
HOSHDR  SC      /HOST  STATUS/
        AC      / SORDS/
HHDR.L  EQ      .-HOSHDR        :SHORT HOST STATUS HDR LENGTH
EPWMSG  SC      /ENTER PASSWORD: /
APWMSG  SC      /AGAIN: /
PATMSG  SC      /ABORTED -- PORTS ACTIVE/
NMRMSG  SC      /ABORTED -- NOT ENOUGH SPACE/
TLGMSG	SC	/ABORTED -- MSG TOO LONG/

HKYMSG	SC	/  HOST KEY = /
ACTMSG  SC	/, PORTS ANSWERED = /
CPSMSG	SC	/, AVERAGE CPS =/
HCTMSG	SC	/, HOST COST = /

 	
	SUBTTL	TOM NEEDLE PROCESSOR

: TOM ISIS NEEDLE PROCESSOR

        SEG     A.CODE

TOMNDL	LHI	R0,AO.EDM	:INDICATE NEW LOGIN
	JAL	R5,PECDR
	SBT     RHP,ACP         :SET PORT ACTIVE
        LIS     R4,1
        AHM     R4,APORTS       :UPDATE ACTIVE PORT COUNT
  IF    INAN+1          	:IF INACTIVITY PROCESSING
        LIS     R4,0
        STB     R4,INACT,RHP,   :FLAG ACTIVITY
  EI
	LCS	R4,1		:INDICATE NO HARDWIRED TOM PORT
	STH	R4,TPN-TOMPIX*2,RHP,RHP
        SBT     RHP,CRDLYP      :ALLOW TSAT TO PROVIDE CARRIAGE RETURN DELAY
        SBT     RHP,TRANSP      :SEND ALL CARACTERS TO TOM
        RBT     RHP,XONP        :TOM DOES NOT ALLOW XON/OFF
	RBT	RHP,TDMOFF-NNTMGP*2  :TURN DIAGNOSTICS ON

	JAL	R4,GETW		:SKIP NEEDLE INVOICE NMBR,
	JAL	R4,GETW		:*DEST HOST, ORIG NODE,
	JAL	R4,GETW		:*ORIG HOST, ORIG PORT,
	JAL	R4,GETW		:*RESERVED WORD,
	JAL	R4,GETW		:*DIALECT, TID, UNAME SIZE
	LBR	R11,R0		:UPDATE COUNT

:	CHECK USERNAME AGAINST GOOD GUY LIST

	LB      R6,TOMGGL       :GET LENGTH OF GOOD GUY NAME
        AIS     R6,1            :ADD 1 FOR USERNAME TERMINATOR
        CR      R6,R11		:SEE IF SAME LENGTH
        JN      SKPUNM          :IF NOT, CONTINUE NEEDLE PROCESSING
        LIS     R6,1
        SIS     R11,1
CGG010  JAL     R4,GETCH
        LB      R2,TOMGGL,R6
        NHI     R2,7F           :MASK OFF PARITY
        NHI     R0,7F
        CR      R0,R2
        JNFS    CGG020          :IF NOT GOODGUY, SKIP NAME
        AIS     R6,1
        SIS     R11,1
        JGBS    CGG010          :IF MORE TO CHECK
        LH      R1,HPN,RIP,RIP
        LHI     R1,-TOMPIX,R1   :PORT # RELATIVE TO FIRST TOM PORT
        SBT     R1,TOMGG
        AIS     R11,1
CGG020  AIS     R11,1           :RESTORE COUNT FOR TERMINATOR
        J       SUN015          :GO CONTINUE NEEDLE PROCESSING

: PROCESS NEW HARDWIRED TOM PORT

TOMSAT	JAL     R3,GCDR		:GET CHAR
        J       HOC110          :NOTHING THERE, WAIT UNTIL NEXT TIME
        J       TOMSAT		:IGNORE DATA CHARS
  IF	NAPORT
        SHI     R0,AI.IBR	:SEE IF BAUD RATE GUESS
        JLBS    TOMSAT          :ESCAPED 0-7F...IGNOR TOO
        CLHI    R0,0F           :CHECK FOR VALID BAUD RATE INDEX
        JGBS    TOMSAT
	TBT	RHP,TSATPT	:MUST BE HDW TOM PORT
	JE	TOMSAT
        STB     R0,BRATE,RHP    :SAVE BAUD RATE GUESS
        JAL     R3,GCDR         :NOW TRY TO GET TID CHAR
        J       ESCERR		:NOT THERE, ERROR
	LR	R1,R0		:SAVE TID CHAR
	JFS	FVID4
        J       TOMSAT          :IGNORE CTRL CODES

FVID4   NHI     R1,1F           :MASK OFF LOWER 5 BITS OF TID CHAR
  IF	OP|E8BTM.|
	TBT	RHP,E8BTMP	:IF THIS PORT USES FULL 8-BIT CHAR SET
	JEFS	FVID40
	CLHI	R1,0F		: THEN ACCEPT "O" TID
	JNFS	FVID40
	LIS	R1,01		:  AS AN "A"
  EI
FVID40  LB      R0,BRATE,RHP    :GET BAUD RATE
        EXBR    R1,R1
        OR      R0,R1           :TID CHAR IN NEXT HIGHER BYTE
        LCS     R8,VIDT.L       :NOW SCAN TABLE FOR MATCH
FVID5   AIS     R8,VIDT.L
        LHL     R3,VIDTT,R8,
        JE      HOC110          :END OF TABLE W/ NO MATCH - START FROM SCRATCH
        SR      R3,R0
        JNBS    FVID5
        CLHI    R8,VIDNA
        JG      HOC110          :IF NON-ASCII IGNORE TID
        STB     R8,TERMT,RHP    :ID ACCEPTED - SAVE TERMINAL INDEX
        JAL     R5,ORGCLR       :CLEAR REST OF ID MSG
        LB      R0,BRATE,RHP    :SET OUTPUT BAUD RATE
        AHI     R0,AO.OBR
        JAL     R5,PEEDR
  ELSE
	J	TOMSAT
  EI

TOMSIO	LHI     R0,AO.EDM       :ENTER DATA MODE
        JAL     R5,PEEDR
        SBT     RHP,ACP         :SET PORT ACTIVE
        LIS     R0,1
        AHM     R0,APORTS       :COUNT ACTIVE PORTS ON FRONT PANEL
        LB      R4,TERMT,RHP
  IF    INAN+1  		:IF ENABLED
        LIS     R2,0
        STB     R2,INACT,RHP,   :FLAG ACTIVITY
  EI
	LIS	R3,TOM		:SET SORD NMBR
	STH	R3,SORD,RHP,RHP
        RBT     RHP,RXONP
	SBT     RHP,DEM         :MUST BE RE-INITTED AFTER LOGOUT
        LH      R0,VIDTT+4,R4,  :SET PARAMETERS A,B,C,D
        STB     R0,PCD,RHP
        EXBR    R0,R0
        STB     R0,PAB,RHP
        LHL     R2,VIDTT+6,R4,  :INITIALIZE BIT ARRAYS
        LCS     R3,2
IZP5    AIS     R3,2
        LHL     R5,VIDBA,R3
        JEFS    IZP6            :ALL ARRAYS DONE
        RBT     RHP,0,R5        :TURN THE BIT OFF
        SRHLS   R2,1            :TEST WHAT IT SHOULD BE
        JNCBS   IZP5
        SBT     RHP,0,R5        :ELSE SET IT
        JBS     IZP5

IZP6	LIS	R8,TOM		:SORD NMBR
	LH      R1,CAN+2*NNTMGP :PORT AVAILABLE?
        NH      R1,S|TOM|PTS+2*NNTMGP,, :ON TOM?
        JFFOH   R1,TNP020       :IF PORT AVAILABLE
        J       TNP030		:NO PORTS AVAILABLE

TNP020  AHI     R2,TOMPIX	:HOST PORT NUMBER
        RBT     R2,CAN          :NO LONGER A CANDIDATE
        SBT     R2,ACP          :MARK ACTIVE
  IF    INAN+1          	:INACTIVTY TIMER ACTIVE?
        LIS     R1,0
        STB     R1,INACT,R2,    :FLAG ACTIVITY
  EI
	STH	R2,IPN,RHP,RHP	:SAVE HOST PORT NUMBER
        STH     RHP,TPN-TOMPIX*2,R2,R2   :SAVE TYMSAT PORT NMBR
        SBT     RHP,TOPTON      :CLEAR BACKPRESSURE
	RBT	RHP,GBRCVD	:NO GREEN BALLS
	LR	RHP,R2		:USE HOST PORT NMBR NOW
	SBT	RHP,TOPTON
	RBT	RHP,TDMOFF-NNTMGP*2  :TURN DIAGNOSTICS ON
        LIS     R3,TOM
        STH     R3,SORD,RHP,RHP
	LR	R1,RHP
	LB	R6,VIDTT+3,R4,	:TID
        LIS     R7,0            :ASCII PORT
	STB	R7,BRATE,RHP	:SAFE BAUD RATE
        JAL     R3,STC          :SET TERMINAL CHARACTERISTICS
	JAL	R5,ORGCLR
	LHI	R0,AO.EDM	:INDICATE NEW LOGIN
	JAL	R5,PECDR
	LHI	R5,8D8A
	JAL	R6,PPTOM
        L       R2,HGRT+4*TOM,, :HOST GREET MSG
  IF    GRTP
        ST      R2,HGRTMS+GRTP
        LA      R5,HGRTMS
  ELSE
        ST      R2,TGRTMS+1
        LA      R5,TGRTMS
  EI
        JAL     R6,PMSTOM       :SEND GREETING
	J	HOC110		:EXIT

TNP030  LA      R10,NPAMS,,     :NO PORTS AVAILABLE MSG
        JAL     R6,PHWMS
        JAL     R6,DETHP	:DETACH
	J	HOC110

:       TABLE OF ADDRESSES USED (TOP TO BOTTOM) TO INITIALIZE
:       BIT ARRAYS. FIELD OF BIT STATES ARE USED RIGHT TO LEFT.

VIDBA   HC      CRDLYP,ECRLFP,ELFCRP,ECTLIP     :VARIES
        HC      ECHOP,PARCEP,HDUXP,XONP 	:VARIES
        HC      0,0,0                   	:0,0,TERMINATOR

: PROCESS DETACH OF HARDWIRED TOM PORT

HDWZAP	LR	RHP,RIP		:GET HOST PORT NMBR
	RBT	RHP,ACP		:CLEAR PORT ACTIVE
	JAL	R4,TOMCLR	:CLEAR TOM PORT
	J	DET200		:GO RETURN
	SUBTTL	TOM DATA PROCESSOR

: TOM ISIS TO HOST DATA CHARACTER PROCESSOR.
:       CALLED FROM ISTOHO WHEN A DATA CHAR SEEN IN ISIS INPUT RING.

TOMDAT	CLHI    R7,0D           :CR?
        JN      IHS220          :IF NOT

:	PROCESS CARRIAGE RETURN

	LIS     R2,1
        AHM     R2,TOMCWT-2*TOMPIX,RHP,RHP  :UP COUNT OF WAITING COMMANDS
        SBT     RHP,TOPTON      :CLEAR TOPORT BP
        CLH     RHP,TMOBWT      :CHK ORANGE BALL WAIT FLAG
        JEFS    TSCC20          :IF THIS PORT WAITING ORANGE BALL
        JAL     R3,PTMDQU       :DEQUE TIMEOUT
TSCC20  JAL     R5,PPCDR        :PASS CR ALONG
        LIS     R0,TM.ETX       :GET END TEXT CHARACTER
	LR	R7,R0
        J       ITHSND          :PASS IT ALONG

:       PROCESS ESCAPE CHARS (00-1F OR 7B-7F)

IHS220  CLHI    R7,1F
        JLEFS   IHS230          :IF ESC
        CLHI    R7,7B
        JL      ITHSND          :NOPE, JUST PASS IT ON

IHS230	JAL	R10,SNDGOB	:SEND GOBBLER TO ISIS
	LA	R3,TN.PRO,,	:OUTPUT PROMPT
	JAL	R5,QOCS
	LR	R6,R6		:ECHO DATA RECORD STARTED?
	JEFS	IHS240		:BR IF NOT
	LIS	R2,0
	LHI	R3,3,R6
	JAL	R5,QSLOR	:RE-START OUTPUT DATA RECORD
IHS240  LIS     R0,0
        STH     R0,TOMCWT-2*TOMPIX,RHP,RHP  :NO MORE COMMANDS WAITING
        RBT     RHP,TOPTON      :SET TOPORT BP
        CLH     RHP,TMOBWT      :THIS PORT WAITING ON ORANGE BALL?
        JNFS    TSCE10          :IF NOT
        STH     R0,TMOBWT
TSCE10  CLB     RHP,TOMCON+2
        JNFS    TSCE20          :IF THIS PORT NOT IN CONTINUE PROCESSING
        STH     R0,TOMCON
TSCE20  LR      R2,RHP
        SHI     R2,TOMPIX       :BIAS TO TOM PORT INDEX
        SBT     R2,TDMBP        :SET BACKPRESSURE ON DIAGNOSTICS
	JAL	R5,ORGCLR	:CLEAR TOM RING
        LHI     R0,TOMTOV       :TOM TIME OUT VALUE
        LHI     R1,TMTOUT-.S
        JAL     R2,PTMQUE       :TIMEOUT IF TOMTOV SEC PASSES BEFORE CR
        J       ITHBMP          :DONE

: TOM HARDWIRED PORT TO TOM DATA PROCESSOR
:	CALLED FROM HOSTMS WHEN CHAR RECEIVED FROM HARDWIRED TOM PORT

TOMHDW	JAL     R3,GCDR         :GET CHAR FROM HDW PORT
        J       HOC110		:BR IF NO MORE
	LR	R7,R0		:SAVE DATA CHAR
	JFS	GLEE
	JBS	TOMHDW		:IGNORE IF CTRL CODE

GLEE	NHI	R7,7F		:REMOVE PARITY

  IF	RXONN+1
:	CHECK FOR RXON/RXOFF

	TBT	RHP,RXONP
	JE	THD020		:IF NOT ENABLED
   IF	RXONN
	CLB	R7,RXOFSV,,	:SEE IF XOFF
   ELSE
	CLHI	R7,RXOFSV	:SEE IF XOFF
   EI
	JE	THD014		:IF RXOFF
THD010	HS
   IF 	RXONN
	CLB	R7,RXONSV,,	:SEE IF XON
   ELSE
	CLHI	R7,RXONSV	:SEE IF XON
   EI
	JN	THD020		:IF NOT
	SBT	RHP,RXONON	:RXON, SEE IF IT IS ALRDY ON
	JN	THD020		:YES, PASS AS DATA
	TBT	RHP,OTAM	:RESTORE TAM BIT TO FORMER STATE
	JEFS	THD012
	SBT	RHP,TAM
THD012	TBT	RHP,OFDDT	:RESTORE FDDAT BIT TO FORMER STATE
	JE	TOMHDW
	SBT	RHP,FDDAT
	J	TOMHDW

THD014	RBT	RHP,RXONON	:RXOFF, SEE IF IT IS ALRDY OFF
	JE	THD010		:YES, CHECK XON
	RBT	RHP,TAM		:TURN ON BACKPRESSURE
	JEFS	THD015
	SBT	RHP,OTAM	:SAVE CUR STATE OF TAM
	JFS	THD016
THD015	RBT	RHP,OTAM
THD016	RBT	RHP,FDDAT	:STOP OUTPUT BY FAKING DRIVER
	JEFS	THD017
	SBT	RHP,OFDDT	:SAVE CUR STATE OF FDDAT
	J	THD010
THD017	RBT	RHP,OFDDT
	J	THD010
THD020	HS
  EI

:	PROCESS CARRIAGE RETURN

	CLHI	R7,0D		:CR?
	JN	THD040		:BR IF NOT
	LR	RHP,RIP		:SET HOST PORT NMBR
	JAL	R4,PCTOM	:ECHO CR
	LIS	R0,0A		:ECHO LF
	JAL	R4,PCTOM
	LIS	R2,1		:BUMP CNT OF WAITING CMDS
	AHM	R2,TOMCWT-2*TOMPIX,RHP,RHP
	SBT	RHP,TOPTON	:CLEAR TOPORT BP
	CLH	RHP,TMOBWT	:CHK OUTPUT WAIT PORT
	JEFS	THD030		:IF THIS PORT WAITING FOR OUTPUT DONE
	JAL	R3,PTMDQU	:DEQUE TIMEOUT
THD030	LIS	R0,0D
	JAL	R5,PDCDR	:PASS CR TO TOM PORT
	LIS	R0,TM.ETX	:PASS END-TEXT CHAR TO TOM PORT
	J	THD055

:	PROCESS LINE FEED

THD040	CLHI	R7,0A		:LF?
	JN	THD060		:BR IF NOT
	LR	RHP,RIP
	JAL	R4,PCTOM	:ECHO LF
	LIS	R0,0D		:ECHO CR
	JAL	R4,PCTOM
	LIS	R0,0A		:PUT LF BACK
	JFS	THD055

:	PROCESS NORMAL CHARS

THD050	LR	RHP,RIP		:GET TOM HOST PORT NMBR
	JAL	R4,PCTOM	:ECHO CHAR
THD055	JAL	R5,PDCDR	:PASS CHAR TO TOM
THD057	LH	RHP,TPN-TOMPIX*2,RHP,RHP  :GET TYMSAT PORT BACK
	J	TOMHDW		:GO GET NEXT CHAR

:	PROCESS ESCAPE CHARS (00-1F OR 7B-7F)

THD060	CLHI	R7,1F		:ESCAPE?
	JLEFS	THD065
	CLHI	R7,7B
	JLBS	THD050		:NOPE, JUST PASS IT ON

THD065	HS
  IF	NMPORT
   IF	NAPORT
	TBT	RHP,SIOP	:SEE IF SIO PORT
	JNFS	THD067		:BR IF SO
   EI
  EI
  IF	NAPORT
	JAL	R5,ORGCLR	:CLEAR OUTPUT RING
  EI
THD067	LR	RHP,RIP		:GET TOM HOST PORT NMBR
	LA	R5,TN.PRO,,	:SEND PROMPT
	JAL	R6,PMSTOM
	LIS	R0,0		:NO MORE CMDS WAITING
	STH	R0,TOMCWT-2*TOMPIX,RHP,RHP
	RBT	RHP,TOPTON	:SET TOPORT BP
	CLH	RHP,TMOBWT	:IS THIS PORT WAITING FOR OUTPUT?
	JNFS	THD070		:IF NOT
	STH	R0,TMOBWT
THD070	CLB	RHP,TOMCON+2
	JNFS	THD075		:IF THIS PORT NOT IN CONTINUE PROCESSING
	STH	R0,TOMCON
THD075	LR	R2,RHP
	SHI	R2,TOMPIX
	SBT	R2,TDMBP	:SET BACKPRESSURE ON DIAGNOSTICS
	JAL	R5,ORGCLR	:CLEAR TOM RING
	LHI	R0,TOMTOV	:TOM TIME OUT VALUE
	LHI	R1,TMTOUT-.S
	JAL	R2,PTMQUE	:TIMEOUT IF TOMTOV SEC PASSES BEFORE CR
	J	THD057

: GCTOM - GET CHAR FROM TOM RING

GCTOM	TBT	RHP,FDDAT	:SEE IF RING HAS DATA
	JE	GCTM3		:BR IF NOT
GCTM0	LHL	R2,BLKPTR,RHP,RHP  :GET PORT BLOCK ADDR
	AI	R2,ASRING
	LB	R1,FDOUT,R2	:GET OUR CURSOR
	LB	R0,FDBUF,R1,R2	:GET CHAR
	AIS	R1,1		:BUMP CURSOR
	CLHI	R1,FDSIZ	:FOLD IF NECESSARY
	JNFS	GCTM1
	LIS	R1,FDSTR
GCTM1	STB	R1,FDOUT,R2	:SAVE UPDATED CURSOR
	LCS	R1,1
	AHM	R1,FDCNT,R2	:DECR CHAR COUNT
	JGEFS	GCTM2		:BR IF MORE DATA
	CBT	RHP,FDDAT	:INDICATE NO MORE DATA IN RING
GCTM2	AHM	R1,FDTAM,R2	:DECR TAM COUNTER
	JNR	R4		:RTRN UNLESS TIME TO RELEASE BP
	CBT	RHP,TAM		:RELEASE BACKPRESSURE
	JR	R4		:SKIP RETURN

GCTM3	ST	R4,TOMGET	:SAVE OUR RTRN ADDR
	STH	R4,TOMCON	:FLAG CONTINUATION PROCESSING
	J	TOMW30		:GO WAIT FOR DATA TO BE COPIED TO RING

: PPTOM - PUT 2 CHARS IN TOM RING

PPTOM	EXBR	R0,R5
	JAL	R4,PCTOM	:PUT 1ST CHAR
	LBR	R0,R5
	LR	R4,R6		:DROP TO PUT 2ND CHAR

: PCTOM - PUT A CHAR INTO TOM RING

PCTOM	LH	R2,TPN-TOMPIX*2,RHP,RHP  :SEE IF HARDWIRED PORT
	JGE	PCTM2		:BR IF SO
	LHL	R2,BLKPTR,RHP,RHP  :GET PORT BLOCK ADDR
	AI	R2,ASRING
	LB	R1,DFIN,R2	:GET OUR CURSOR
	STB	R0,DFBUF,R2,R1	:STUFF DATA CHAR
	AIS	R1,1		:INC CURSOR
	CLHI	R1,DFSIZ	:CHECK FOR FOLDING
	JNFS	PCTM1
	LIS	R1,DFSTR
PCTM1	STB	R1,DFIN,R2	:SAVE UPDATED CURSOR
	LIS	R1,1		:INCR CHAR COUNT
	AHM	R1,DFCNT,R2
	JGR	R4		:RTRN UNLESS ONLY CHAR
	CBT	RHP,DFDAT	:INDICATE DATA IN RING
	JR	R4		:RETURN

PCTM2	ST	R5,PCTMSV	:SAVE R5
	ST	RHP,PCTMSV+4	:SAVE RHP
	LR	RHP,R2		:GET HARDWIRED PORT NMBR
  IF	INAN+1
	LIS	R1,0
	STB	R1,INACT,RHP,	:RESET INACTIVITY TIMER
  EI
	NHI	R0,7F
	CLHI	R0,0D		:SEE IF CARRIAGE RETURN
	JE	FOUTCR
	CLHI	R0,0A		:SEE IF LINE FEED
	JE	FOUTLF
	LIS	R1,1		:INC CARRIAGE POSITION COUNT
	AHM	R1,MARGE,RHP,RHP
	JAL	R5,PCCDR	:PUT IN HDW PORT OUTPUT RING
PCTM3	L	R5,PCTMSV	:RESTORE R5
	L	RHP,PCTMSV+4	:RESTORE RHP
	JR	R4		:RETURN

:	CARRET & LNFEED PROCESSORS FOR HARDWIRED TOM PORTS

FOUTCR	TBT     RHP,CRDLYP      :CARRET - DELAY NEEDED?
        JE      FOUTAL          :NO...TAKE ALTERNATE DELAY IF ANY
        JAL     R5,PCCDR        :YES...SEND IT
        LB      R5,PAB,RHP      :DELAY=MIN(B+N/2**A,CPARAM(C))
        LIS     R1,0F
        NR      R1,R5           :PAR B
        LB      R3,PCD,RHP
        SRHLS   R3,4            :PAR C
        SRHLS   R5,4            :PAR A
        LB      R0,MARGE+1,RHP,RHP :N/2**A
        SRL     R0,0,R5
        AR      R0,R1		:B+N/2**A
        LIS     R1,1
        STH     R1,MARGE,RHP,RHP  :SET NEW COUNT
        CLB     R0,CPARAM,R3
        JLEFS   FOUTC3
FOUTC1  LB      R0,CPARAM,R3
FOUTC3  JAL     R5,FOUTDY       :SET DELAY
	J	PCTM3		:RETURN

FOUTAL  JAL     R5,PCCDR        :ALTERNATE DELAY...SEND CHAR
        LIS     R0,1
        AHM     R0,MARGE,RHP,RHP  :COUNT THE CHAR
        LB      R3,PCD,RHP      :AND TAKE DEFAULT...PARAMETER 'D'
        NHI     R3,0F
        J       FOUTC1

FOUTLF  TBT     RHP,CRDLYP      :LINE FEED - DELAY *BEFORE* OUTPUTTING
        JN      FOUTAL          :NO...DO ALTERNATE DELAY IF ANY
	LB	R3,MARGE+1,RHP,RHP :GET N
        SIS     R3,1            :IF N=1, DELAY=A, ELSE...
        JGFS    FOUTL1
        LB      R0,PAB,RHP
        SRHLS   R0,4
        J       FOUTL2

FOUTL1  LB      R5,PCD,RHP      :DELAY=B+MAX(CPARAM(C)-N,0)
        SRHLS   R5,4
        LB      R5,CPARAM,R5    :PAR C
        AIS     R3,1            :RESTORE N
        SR      R5,R3
        JGEFS   FOUTL3
        LIS     R5,0
FOUTL3	LB      R0,PAB,RHP      :ADD PAR B
        NHI     R0,0F
        AR      R0,R5
FOUTL2  JAL     R5,FOUTDY       :GENERATE THE DELAY
        LIS     R1,1            :START NEW LINE COUNT
        STH     R1,MARGE,RHP,RHP
	LIS	R0,0A		:SEND LF
        JAL     R5,PCCDR
	J	PCTM3		:RETURN

:       INTERNAL ROUTINE TO RELAY A DELAY (IF ANY) TO DRIVER

FOUTDY  LR      R0,R0           :CHECK FOR *ANY* DELAY
        JER     R5              :NO...JUST RETURN
        CLHI    R0,AO.DLY       :CHECK FOR OVERFLOW
        JLEFS   FOUTD1          :SKIP IF NOT
        LHI     R0,AO.DLY	:PEG IT AT MAXIMUM
FOUTD1  J       PEEDR           :SEND DELAY AND EXIT

CPARAM  BC      $A 0,1,2,3,4,5,7,10,14,19,26,36,50,69,95,131

: PETOM - PUT ESCAPED CHAR IN TOM RING

PETOM	LH	R2,TPN-TOMPIX*2,RHP,RHP  :SEE IF HARDWIRED PORT
	JGE	PETM5		:BR IF SO
	LHL	R2,BLKPTR,RHP,RHP  :GET PORT BLOCK ADDR
	AI	R2,ASRING
	LB	R1,DFIN,R2	:GET OUR CURSOR
	LIS	R3,0
	STB	R3,DFBUF,R1,R2	:STUFF ESCAPE CHAR
	AIS	R1,1		:BUMP CURSOR
	CLHI	R1,DFSIZ	:*AROUND THE BEND
	JNFS	PETM1
	LIS	R1,DFSTR
PETM1	STB	R0,DFBUF,R2,R1	:STUFF ESCAPED CHAR
	AIS	R1,1		:BUMP CURSOR
	CLHI	R1,DFSIZ	:*AROUND THE BEND
	JNFS	PETM2
	LIS	R1,DFSTR
PETM2	STB	R1,DFIN,R2	:SAVE UPDATED CURSOR
	LIS	R1,1		:INCR CHAR COUNT
	AHM	R1,DFCNT,R2
	JGFS	PETM3		:BR UNLESS 1ST CHAR
	AHM	R1,DFCNT,R2	:INCR COUNT AGAIN
	CBT	RHP,DFDAT	:INDICATE DATA IN RING
	JR	R4
PETM3	AHM	R1,DFCNT,R2	:INCR COUNT AGAIN
	JR	R4

PETM5	ST	R5,PCTMSV	:SAVE R5
	ST	RHP,PCTMSV+4	:SAVE RHP
	LR	RHP,R2		:GET HARDWIRED PORT NMBR
	JAL	R5,PEEDR	:PUT CTRL CODE IN HDW PORT RING
	L	R5,PCTMSV	:RESTORE REGS
	L	RHP,PCTMSV+4
	JR	R4

: PMSTOM - PUT MESSAGE TO TOM RING

PMSTOM	LB	R7,0,R5		:GET MSG LENGTH
	AIS	R5,1
PMSTM1	LR	R7,R7		:TEST MSG LENGTH
	JLER	R6		:RTRN IF DONE
PMSTM2	LB	R0,0,R5		:GET CHAR
	JAL	R4,PCTOM	:PUT IN TOM RING
	AIS	R5,1		:BUMP PTRS
	SIS	R7,1
	JGBS	PMSTM2		:BR IF NOT DONE
	JR	R6

: PHWMS - PUT MESSAGE TO HARDWIRE TOM PORT (PRE-INITIALIZATION)
:  CALLED FOR TID MESSAGE AND NO PORTS AVAILABLE MSGS

  IF	OP|E8BTM.|
PHWMS	TBT	RHP,E8BTMP	:IS THIS 8-BIT CODE PORT
	JE	PMSDR		:NO, SEND MESSAGE AS IS
	LB	R9,0,R10	:GET MESSAGE LENGTH
PHWMS2	JLER	R6		:RETURN IF NO MORE CHARS
	LB	R0,1,R10	:GET CHARACTER
	NHI	R0,07F		:KEEP AS DATA ASCII (<127)
	JAL	R5,PPCDR	:SEND THE CHARACTER
	AIS	R10,1		:BUMP POINTER
	SIS	R9,1		:DECREASE COUNT
	JBS	PHWMS2		:BACK FOR MORE
  ELSE
PHWMS	J	PMSDR
  EI
	SUBTTL	TOM INITIALIZATION & EXEC LOOP

: INITIALIZE TYMCOM OPERATIONS MANAGER (TOM).

IZTOM	L       R7,FASTC,,
        LHI     R1,RATE,R7      :START IN 1 SEC
        LA      R0,OUTTIM
        JAL     R5,TOPUT        :PUT TIME OUTPUTER ON TIMEOUT LIST
	LHI	R1,RATE/2,R7
	LA	R0,TDMSG	:PUT DIAGNOSTIC MSG PROCESSOR ON TIMEOUT LIST
	JAL	R5,TOPUT

:       INITIALIZE ENQUIRE HEADER

        LB      R7,VERREV,,		:SLOT VERSION
        LIS     R8,8
        LA      R5,ENQTVN,,
        LIS     R4,3
        JAL     R6,CBA
        LB      R7,VERREV+1,,           :SLOT REVLEV
        LA      R5,ENQTRN,,
        LIS     R4,3
        JAL     R6,CBA
        LH      R7,SLOTNO,,             :SLOT #
        LA      R5,ENQSLT,,
        LIS     R4,2
        JAL     R6,CBA
        LH      R7,NODEX,,              :NODE #
        LA      R5,ENQNOD,,
        LIS     R4,4
        JAL     R6,CBA
        LH      R7,VERNO,,              :ISIS VERSION #
        LA      R5,ENQIVN,,
        LIS     R4,6
        LIS     R8,$A 10
        JAL     R6,CBA
        LH      R7,HOSTX,,              :KERNEL HOST #
        LA      R5,ENQKHN,,
        LIS     R4,4
        JAL     R6,CBA

:	INITIALIZE TOM WORK AREAS

        LIS     R1,$A10		:INIT RADIX TO DECIMAL
        LIS     R2,NTOMPT-1
        LIS     R4,0
IZT010  STB     R1,TOMRAD+1,R2
        STH     R4,TOMCWT,R2,R2         :CLEAR COMMAND WAITING COUNTS
        STH     R4,TDMOUT,R2,R2
        SIS     R2,1
        JGE     IZT010          :INIT ALL RADIX VALUES
        STB     R1,TOMRAD       :SET CURRENT VALUE

        LCS     R1,1
        STH     R1,TOMLIC       :CLEAR LICENSE STATUS
        STH     R4,TOMGG        :CLEAR GOOD GUY PORTS
        L       R3,TOMPWD       :1ST 4 PW CHARS
        NI      R3,7F7F7F7F     :REMOVE PARITY
        ST      R3,TOMPWD
        L       R3,TOMPWD+4     :5-7TH PW CHARS
        NI      R3,7F7F7F00     :REMOVE PARITY
        ST      R3,TOMPWD+4
        STH     R4,TOMCON       :CLEAR CONTINUATION PROCESSOR ADDRESS
        STH     R4,TMOBWT       :CLEAR ORANGE BALL WAIT FLAG
	ST	R4,TOMGET	:CLEAR DATA COPY WAIT FLAG
        STH     R4,TDMOFF
        STH     R4,PDOWN+NNTMGP*2
        JR      R10             :DONE

: TYMCOM OPERATIONS MANAGER EXEC LOOP (BACKGROUND)

TOMEXE  ST      R10,EXRETT      :SAVE RETURN LINK

        LCS     R1,1		:UPDATE CANDIDATE LIST (CAN=@ACP)
        XH      R1,ACP+NNTMGP*2
        STH     R1,CAN+NNTMGP*2

        LCS     R15,1
        STH     R15,TOMDEF      :INITIALIZE BID MASK

:       CHECK FOR PORT WAITING FOR OUTPUT COMPLETE OR DATA INPUT

        LHL     R3,TOMCON
        JE      TOMNXT          :IF NOTHING WAITING
        LB      RHP,TOMCON+2    :GET PORT #
        LB      R8,TOMRAD+1-TOMPIX,RHP
        STB     R8,TOMRAD       :STORE CURRENT RADIX
	LM	R5,TOMSAV	:RESTORE REGS R5-R15
	L	R4,TOMGET	:SEE IF WAITING FOR DATA
	JEFS	TOM004		:BR IF NOT
	TBT	RHP,FDDAT	:GOT DATA YET?
	JE	TOM009		:BR TO TIMEOUT IF NOT
	LIS	R0,0		:CLEAR WAIT FLAG
	ST	R0,TOMGET
	J	GCTM0		:BR TO GET IT

TOM004  LHL     R1,TMOBWT
        JNFS    TOM005          :IF PORT WAITING FOR OUTPUT DONE
        TBT     RHP,TOPTON
        JN      .S,R3           :CONTINUE PROCESSING
	J	TOM009

TOM005	LH	R2,TPN-TOMPIX*2,RHP,RHP  :HARDWIRED PORT?
	JLFS	TOM007		:NO
  IF	NMPORT
	TBT	R2,SIOP		:SIO PORT?
	JEFS	TOM006		:NO
	LHL	R2,BLKPTR,R2,R2	:GET SIO BLOCK ADDR
	LB	R0,SIOPRO+1+ASRING,R2,  :SEE IF PREV OP COMPLETE
	JFS	TOM008
  EI
TOM006	TBT	R2,FDDAT	:SEE IF DATA STILL IN HDW RING
	JFS	TOM008
TOM007  TBT	RHP,DFDAT	:SEE IF DATA STILL IN TOM RING
TOM008  JNFS    TOM009          :BR IF SO
	LIS     R0,0
        STH     R0,TMOBWT       :CLEAR WAIT FLAG
        J       .S,R3           :CONTINUE PROCESSING

TOM009	L	R10,EXRETT	:GET EXEC RTRN ADDR
	LHL	R0,SLOWC+2,,	:SEE IF TIMEOUT
	SH	R0,TOMCON+4
	CHVR	R0,R0
	JLR	R10		:RTRN IF NOT
	JAL	R9,TOUT		:CLEAR UP PORT A BIT
	JR	R10

:       CHECK NEXT GROUP FOR COMMANDS WAITING

TOMNXT  LHL     R1,TOPTON+NNTMGP*2      :DATA LINE PRESENT?
        NH      R1,TOMDEF               :AND NOT DEFERING?
        JFFOH   R1,TOM010       :IF A HIT
TOMBYE	L	R10,EXRETT	:RESTORE RTRN ADDR
        JR      R10             :BACK TO EXEC LOOP

TOM010  RBT     R2,TOMDEF       :ALREADY PROCESSED
        LHI     RHP,TOMPIX,R2   :BIAS PORT NUMBER BY GROUP
	JAL	R4,GCTOM	:GET CHAR
        LR      R0,R0           :ESCAPED?
        JN      TOM040          :IF NOT
	JAL	R4,GCTOM	:GET ESCAPED CHAR
	LR	R0,R0		:SEE IF NULL DATA
	JE	TOMNXT		:IGNORE IF SO
	CLHI	R0,AO.DSC	:SEE IF DISCONNECT
	JE	TOMZAP		:IF SO
	CLHI	R0,AO.EDM	:SEE IF ENTER DATA MODE (START OF CIRCUIT)
	JN	TOMNXT		:IGNORE IF NOT

	LIS	R8,0A		:INIT DEFAULT RADIX
	STB	R8,TOMRAD+1-TOMPIX,RHP
	LIS	R0,1
	AHM	R0,TOMCWT-2*TOMPIX,RHP,RHP
	J	TOMPRO		:OUTPUT PROMPT

:       HERE WITH FIRST CHAR OF COMMAND

TOM040  NHI     R0,7F
        CLHI    R0,$0 60        :LOWER CASE?
        JLFS    TOM042          :IF NOT
        SHI     R0,$0 20        :CONVERT TO UPPER
TOM042  LB      R8,TOMRAD+1-TOMPIX,RHP
        STB     R8,TOMRAD       :SET CURRENT RADIX
        SBT     RHP,TDMBP-NNTMGP*2 :BACKPRESSURE DIAGNOSTIC MESSAGES

:       GET NEXT CHAR OF COMMAND

TOM050  CLHI    R0,0D           :IS FIRST CHAR A CARRIAGE RETURN?
        JE      TOMEXI          :IF SO, IGNORE COMMAND
        LR      R6,R0
        JAL     R4,GCTOM
        NHI     R0,7F
        CLHI    R0,$0 60        :LOWER CASE?
        JLFS    TOM055          :IF NOT
        SHI     R0,$0 20        :CONVERT TO UPPER
TOM055  EXBR    R6,R6
        OR      R6,R0           :2 CHAR COMMAND

:       SEARCH FOR NAME IN COMMAND TABLE

        LIS     R2,0
        LHI     R4,7F7F
TOM060  LHL     R3,TOMCMD,R2,   :GET A COMMAND
        JE      TOMERR          :IF END OF TABLE, ERROR
        AIS     R2,4
        NR      R3,R4
        CR      R3,R6           :MATCH?
        JNBS    TOM060          :IF NOT, CONTINUE SEARCH
        LHL     R6,TOMCMD-2,R2, :GET ADDR OF CMD PROCESSOR

:       FOUND A COMMAND, CHECK LICENSE

        CLHI    R2,TOMCL0-TOMCMD+4
        JGEFS   TOM080          :IF LIC NOT NEEDED
        CLH     RHP,TOMLIC	:THIS PORT?
        JN      TOMERR          :IF THIS PORT DOESN'T HAVE LICENSE
        CLHI    R2,TOMCL1-TOMCMD+4
        JGEFS   TOM080          :IF ONLY LEVEL 1 NEEDED
        TBT     RHP,TOMGG-NNTMGP*2
        JE      TOMERR          :IF NOT A GOODGUY

:       SKIP TO BLANK OR CR AND CALL COMMAND PROCESSOR
:
:       EXIT    R0      BLANK, TRANSFER IS TO PROCESSOR ADDRESS+4
:                       CR, TRANSFER IS TO PROCESSOR ADDRESS
:               RHP     THIS PORT #
:               R8      CURRENT RADIX (ALSO IN TOMRAD)

:
:       RETURN  TOMERR  IF ERROR IN COMMAND
:               TOMEXI  TO FLUSH REMAINDER OF COMMAND (IF ANY)
:               TOMWAI  TO SAVE CONTINUATION PROCESSOR ADR (FROM R2)

TOM080  JAL     R4,GCTOM	:GET CHAR
        NHI     R0,7F
        CLHI    R0,20           :BLANK?
        JE      .S+4,R6         :IF SO, CALL PROCESSOR
        CLHI    R0,0D           :CR?
        JE      .S,R6           :IF SO CALL PROCESSOR
        JBS     TOM080          :CONTINUE SKIPPING

:       RETURN TO TOMERR IF ERROR IN COMMAND

TOMERR  LHI     R0,0BF          :?
        JAL     R4,PCTOM

:       RETURN TO TOMEXI TO FLUSH REMAINDER OF COMMAND (IF ANY) AND EXIT

TOMEXI  JAL     R5,GNC          :GET NONBLANK CHARACTER
        CLHI    R0,TM.ETX       :END OF TEXT CHAR?
        JNBS    TOMEXI          :IF NOT, FLUSH
TOMPRO  LA      R5,TN.PRO,,     :PROMPT
        JAL     R6,PMSTOM
        JAL     R7,TOMOBW       :SEND YELLOW BALL AND WAIT
        LIS     R0,0
        STH     R0,TOMCON       :CLEAR CONTINUATION PROCESSOR
        LCS     R3,1
	AHM     R3,TOMCWT-2*TOMPIX,RHP,RHP :DECREMENT COMMAND COUNT
	JGFS	TOM101
        RBT     RHP,TOPTON      :SET BP
TOM101	RBT     RHP,TDMBP-NNTMGP*2 :CLEAR DIAGNOSTIC MSG BACKPRESSURE
        J       TOMNXT          :CONTINUE

:       HERE TO WAIT FOR MORE INPUT TO THIS COMMAND.  THAT IS,
:       THE NEXT CARRIAGE RETURN.

TOMWAI  LCS     R3,1
	AHM     R3,TOMCWT-2*TOMPIX,RHP,RHP  :DECREMENT COMMAND COUNT
	JGFS	TOMW20
        RBT     RHP,TOPTON      :SET BP
TOMW20  STH     R7,TOMCON       :CONTINUE ADDRESS
TOMW30  STB     RHP,TOMCON+2    :PORT #
	STM	R5,TOMSAV	:SAVE REGS R5-R15
	LHL	R0,SLOWC+2,,	:CALC TIMEOUT TIME
	AHI	R0,TOMTOV
	STH	R0,TOMCON+4
        J       TOMBYE          :GO WAIT

:       HERE TO WAIT FOR TOM OUTPUT RING TO CLEAR OUT

TOMOBW  STH     RHP,TMOBWT      :FLAG PORT # OF WAITING PORT
        J       TOMW20          :GO WAIT

: TOUT - TOM PORT NEEDS CLEAN UP AFTER A TIME OUT

TOUT    RBT     RHP,TOPTON
        LIS     R0,0
        STH     R0,TOMCON
        STH     R0,TOMCWT-TOMPIX*2,RHP,RHP
        LR      R2,RHP
        SHI     R2,TOMPIX       :BIAS TO TOM PORT #
        RBT     R2,TDMBP        :CLEAR DIAGNOSTIC MSG BACKPRESSURE
        CLH     RHP,TMOBWT	:CHK ORANGE BALL WAIT FLAG
        JNFS    TOU005          :IF THIS PORT NOT WAITING ORANGE BALL
        STH     R0,TMOBWT
TOU005	CL	RHP,TOMGET	:CHK DATA COPY WAIT FLAG
	JNFS	TOU007
	ST	R0,TOMGET	:CLEAR IT IF FOR THIS PORT
TOU007	TBT     RHP,FDDAT       :ANY CHARACTERS WAITING FROM USER?
        JEFS    TOU010          :IF NOTHING
        JAL     R5,ORGCLR       :REMOVE THEM
        LHI     R0,0BF          :?
        JAL     R4,PCTOM
TOU010	LA      R5,TN.PRO,,     :TOM PROMPT
        JAL     R6,PMSTOM
	JR	R9
        SUBTTL	TOM PERIODIC ROUTINES

: TDMSG - TOM DIAGNOSTIC MESSAGE OUTPUT
:
:       CALLED EVERY HALF SECOND TO COPY DIAGNOSTICS FROM TOM
:       DIAGNOSTIC MESSAGE PORT TO ALL TOM PORTS THAT ARE ACTIVE,
:       HAVE DIAGNOSTICS ON, AND ARE NOT BACKPRESSURING THEM.

        SEG     A.DATA
HPNMSG  SC      /"8D"8ANNN: /   :HOST PORT NUMBER
        SEG     A.CODE

TDMSG   AI	R1,RATE/2	:RUN AGAIN IN A HALF SECOND
	JAL	R5,TOPUT
	LHL     R8,BCT+TDMPT*2
        JE      TORET           :IF NO MSGS OUTSTANDING

:       GET AN ACTIVE PORT WHICH REQUIRES SERVICE

        LIS     R9,NTOMPT-1     :LAST TOM PORT RELATIVE TO 1ST TOM PT
        LHI     RHP,TOMLST      :LAST TOM PORT RELATIVE TO PORT 0
TDM010  TBT     RHP,ACP
        JEFS    TDM015          :IF THIS PORT NOT ACTIVE
        TBT     R9,TDMOFF
        JEFS    TDM020          :IF DIAGNOSTICS ON FOR THIS PORT
TDM015  STH     R8,TDMOUT,R9,R9 :SET POINTER TO END OF BUFFER
        J       TDM030

TDM020  TBT     R9,TDMBP
        JN      TDM030          :IF DIAGNOSTICS BACKPRESSURED
	LH	R2,TPN,R9,R9	:HARDWIRED PORT?
	JLFS	TDM024		:BR IF NOT
  IF	NMPORT
	TBT	R2,SIOP		:SIO PORT?
	JEFS	TDM022		:BR IF NOT
	LHL	R2,BLKPTR,R2,R2	:GET SIO BLOCK ADDR
	LB	R0,SIOPRO+1+ASRING,R2,  :SEE IF PREV OP COMPLETE
	JFS	TDM025
  EI
TDM022	TBT	R2,FDDAT	:SEE IF DATA STILL IN HDW RING
	JFS	TDM025
TDM024	TBT	RHP,DFDAT	:SEE IF DATA STILL IN TOM RING
TDM025	JE	TDM080		:GO PROCESS IF NOT
TDM030  SIS     RHP,1
        SIS     R9,1
        JGE     TDM010          :IF MORE PORTS TO CHECK

:       ALL PORTS SERVICED, FIND SMALLEST NUMBER OF CHARACTERS
:       COPIED BY ANY PORT.

        LHI     R9,(NTOMPT-1)*2
TDM040  LHL     R7,TDMOUT,R9    :GET # CHARS COPIED BY THIS PORT
        CR      R7,R8           :LESS THAN PREVIOUS SMALLEST?
        JGEFS   TDM050          :IF GREATER
        LR      R8,R7           :NEW SMALLEST
TDM050  SIS     R9,2
        JGEBS   TDM040          :CHECK ALL PORTS

:       SUBTRACT THIS NUMBER FROM ALL PORT COUNTS.

        LHI     R9,(NTOMPT-1)*2
        LIS     R7,0
        SR      R7,R8           : -SMALLEST
        JE	TORET           :IF NOTHING TO SUBTRACT
TDM060  AHM     R7,TDMOUT,R9
        SIS     R9,2
        JGEBS   TDM060          :FOR ALL PORTS

:       NOW REMOVED EXPENDED CHARACTERS FROM DIAGNOSTIC BUFFER.

        LHI     R1,TDMPT*2
TDM070  JAL     R4,GCI
        SIS     R8,1
        JGBS    TDM070          :CONTINUE UNTIL ALL REMOVED
        J       TORET           :DONE

:       FOUND A PORT TO SERVICE

TDM080  LHL     R11,TDMOUT,R9,R9  :GET CHARACTER POINTER
        CR      R11,R8
        JGE     TDM030          :IF NOTHING TO COPY

:       SKIP PASSED CHARACTERS PREVIOUSLY COPIED

        LHI     R1,TDMPT*2
        SIS     R11,1
        JL      TDM100          :IF NOTHING TO SKIP
        JAL     R4,GCPEEK       :SKIP FIRST CHARACTER
TDM090  SIS     R11,1
        JL      TDM110          :IF DONE SKIPPING
        JAL     R4,GCSCAN       :SKIP A CHAR
        JBS     TDM090          :UNTIL ALL SKIPPED

:       LOOK FOR THE START OF A DIAGNOSTIC MESSAGE

TDM100  JAL     R4,GCPEEK       :GET FIRST CHARACTER
        JFS     TDM120

TDM110  JAL     R4,GCSCAN       :GET A CHARACTER
TDM120  CLHI    R0,TM.SOH
        JEFS    TDM130          :IF START OF DIAG MSG
        LR      R3,R3           :BUFFER EXHAUSTED?
        JGBS    TDM110          :IF NOT
        J       TDM200          :GO CLEAR ALL POINTERS

TDM130  LR      R12,R3
	JLE     TDM030          :IF NOTHING TO COPY, DO NEXT PORT
        JAL     R4,GCSCAN       :GET PORT NUMBER
        LR      R10,R2          :SAVE REGS
        LR      R12,R3
        JLE     TDM030          :IF NOTHING MORE, FORGET IT
        LIS     R4,3            :PORT # FIELD SIZE
        LA      R5,HPNMSG+3     :ADDR TO PUT NUMBER
        LB      R8,TOMRAD+1,R9  :GET CURRENT RADIX FOR THIS TOMPT
        LR      R7,R0
        CLHI    R0,0FF
        JNFS    TDM135          :IF DEFINED
        LHI     R8,10
        LHI     R7,0FFF         :OUTPUT UNDEFINED #
TDM135  JAL     R6,CBA          :CONVERT BINARY TO ASCII
        LA      R5,HPNMSG
	JAL	R6,PMSTOM	:OUTPUT PORT # MSG
        LR      R2,R10          :RESTORE REGS
	LR	R3,R12

:       COPY CHARACTERS TO TOM PORT UNTIL END OF DIAGNOSTIC BUFFER

TDM140  LHI     R1,TDMPT*2
        JAL     R4,GCSCAN       :GET NEXT CHAR
        LR      R5,R0
        NHI     R5,07F          :REMOVE PARITY
        CLHI    R5,0D
        JEFS    TDM150          :IF CR
        CLHI    R5,0A
        JEFS    TDM150          :IF LINE FEED
        CLHI    R5,TM.SOH
        JE      TDM160          :IF START OF NEW MSG
        LR      R10,R2          :SAVE REGS
	LR	R12,R3
        JAL     R4,PCTOM        :PASS CHAR ON TO TOM PORT
        LR      R2,R10          :RESTORE REG
	LR	R3,R12
TDM150  LR	R3,R3
	JG      TDM140          :IF BUFFER NOT EXAUSTED
	SIS	R3,1
TDM160	AIS	R3,1
	LHL	R8,BCT+TDMPT*2	:GET CUR BFR COUNT
	LR	R7,R8
	SR	R7,R3
	STH	R7,TDMOUT,R9,R9	:SAVE CHAR POINTER FOR THIS PORT
        J       TDM030

:       HERE IF BUFFER EXAUSTED BEFORE START OF A MSG.
:       WE MUST HAVE GOTTEN A BUFFER ZAP.  CLEAR
:       MESSAGES AND MSG POINTERS.

TDM200  JAL     R4,EMPTY
        LHI     R9,(NTOMPT-1)*2
        LIS     R2,0
TDM210  STH     R2,TDMOUT,R9
        SIS     R9,2
        JGEBS   TDM210
        J       TORET           :DONE

: OUTTIM - CALLED PERIODICALLY TO OUTPUT TIME TO ALL
:               ACTIVE TOM PORTS

OUTTIM  AI      R1,RATE*$A60*TIMRAT     :RUN AGAIN IN TIMRAT MINUTES
        JAL     R5,TOPUT                :PUT BACK ON TIMOUT LIST

        LH      R6,TOMZON       :GET ZONE BIAS
        JAL     R4,GETTIM       :GET TIME
        LHI     R1,TDMPT*2      :DIAGNOSTIC PORT
        LIS     R0,TM.SOH       :HEADER
	JAL	R4,WCI
	LHI	R0,0FF		:UNDEFINED PORT NMBR
	JAL	R4,WCI
        LA      R5,TIMSC
        JAL     R6,TOMMS2       :OUTPUT TIME TO ALL PORTS
        J       TORET

: TMTOUT - TOM PORT TIMED OUT AFTER ESCAPE

TMTOUT	JAL	R9,TOUT		:CLEAR UP PORT
	J	PTMRET
	SUBTTL	TOM UTILITY ROUTINES

: TOMMSG - OUTPUT MESSAGE TO TOM DIAGNOSTIC PORT PRECEEDED
:       BY THE ORIGINATING PORT #.
:
:       ENTRY   R5      ADDRESS OF MESSAGE
:               R6      LINK
:               R7      HOST PORT NUMBER
:
:       DESTROYS R0-7

TOMMSG  LHI     R1,TDMPT*2      :TOFIT BUFFER #
        LIS     R0,TM.SOH
        JAL     R4,WCI          :OUT START OF MESSAGE
	LR	R0,R7		:HOST PORT NMBR
TMS010  JAL     R4,WCI
TOMMS2	LB	R7,0,R5		:GET MSG BYTE CNT
	JER	R6		:RTRN IF DONE
TMS020	LB	R0,1,R5		:GET CHAR
	JAL	R4,WCI		:PUT IN BFR
	AIS	R5,1		:BUMP PTRS
	SIS	R7,1
	JGBS	TMS020		:BR IF NOT DONE
        JR      R6              :EXIT

: TOMCLR - CLEAR A TOM PORT

TOMCLR  LHI     R1,-TOMPIX,RHP  :PORT # RELATIVE TO 1ST TOM PORT
        RBT     R1,TOMGG        :NO LONGER A GOODGUY
        LIS     R0,0
        STH     R0,TOMCWT-TOMPIX*2,RHP,RHP
	RBT	RHP,TOPTON
        CLH     RHP,TOMLIC
        JNFS    TMZ020          :IF THIS PORT DOES NOT HAVE LICENSE
        LCS     R0,1
        STH     R0,TOMLIC       :CLEAR LICENSE
TMZ020  LB      R5,TOMCON+2     :PORT # FOR CONTINUATION PROCESSING
        CR      R5,RHP
        JNR     R4              :IF NOT THIS PORT
        LIS     R5,0
        ST      R5,TOMCON       :CLEAR CONTINUE
        STH     R5,TMOBWT       :CLEAR ORANGE BALL WAIT
	ST	R5,TOMGET	:CLEAR DATA COPY WAIT
	JR	R4

: TOAT - OUTPUT CHAR TO ALL REQUESTED TOM PORTS WHICH ARE ACTIVE.
:
:       ENTRY   TOMRI   BITS ON FOR REQUESTED PORTS
:               R0      CHARACTER TO OUTPUT
:               R6      LINK
:
:       DESTROYS R1-5

TOAT	LR	R10,RHP		:SAVE PORT NMBR
	LIS     R5,NTOMPT-1
TTA010  TBT     R5,TOMRI        :CHOSEN?
        JE      TTA020          :IF NOT
        LHI     RHP,TOMPIX,R5   :GET REAL PORT NUMBER
        TBT     RHP,ACP         :ACTIVE?
        JEFS    TTA020          :IF NOT
        JAL     R4,PCTOM        :OUTPUT CHARACTER
TTA020  SIS     R5,1
        JGE     TTA010          :IF MORE TO CHECK
	LR	RHP,R10		:RESTORE PORT NMBR
        JR      R6              :DONE

: TSTOSP - OUTPUT SHORT PORT STATUS
:
:       ENTRY   R10     START ADDRESS OF PORT BIT ARRAY
:               R11     IF NONZERO, INDENT EVERYTHING 4 SPACES
:               R15     LINK

TSTOSP  LIS     R12,8           :OUTPUT COUNTER
        LIS     R14,0           :PORT #
TOS005  LR      R11,R11
        JEFS    TOS010          :IF NOT INDENTING
        LHI     R5,2020         :BLANK BLANK
        JAL     R6,PPTOM
        JAL     R6,PPTOM
TOS010  TBT     R14,,R10
        JE      TOS040          :IF NOT REQUESTED
        OUTNUM(R14,4)           :OUTPUT PORT NUMBER
        LHI     R0,0C4          :D
        TBT     R14,PDOWN
        JN      TOS030          :IF DOWN
        LHI     R0,0D3          :S
        TBT     R14,PSHUT
        JEFS    TOS020          :IF NOT SHUT
        TBT     R14,ACP
        JE      TOS030          :IF SHUT AND NOT ACTIVE
        LHI     R0,0D6          :V
        J       TOS030          :VESTIGIAL
TOS020  LHI     R0,0C1          :A (ACTIVE)
        TBT     R14,ACP
        JNFS    TOS030          :IF UP AND ACTIVE
        LHI     R0,0D5          :U (UP)
        TBT     R14,SIGCAN
        JEFS    TOS030          :IF NOT SIGNAL CANDIDATE
        TBT     R14,SIN
        JEFS    TOS030          :IF SIGNAL IS HIGH
        LHI     R0,44           :MARK PORT DOWN
TOS030  JAL     R4,PCTOM        :OUTPUT STATUS
        SIS     R12,1
        JGFS    TOS040          :IF NOT NEW LINE YET
        LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM
        JAL     R7,TOMOBW       :WAIT FOR THIS MUCH TO OUTPUT
TOS040  AIS     R14,1
        CLHI    R14,NNTMPT
        JGEFS   TOS050          :IF NO MORE
        LR      R12,R12
        JG      TOS010          :IF NEW LINE
        LIS     R12,8
        J       TOS005          :CHECK INDENT AND CONTINUE
TOS050  LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM
        JR      R15             :EXIT


: TSTOFP - OUTPUT FULL PORT STATUS
:       ENTRY   R10     START OF PORT BIT ARRAY
:               R11     IF NONZERO, INDENT LINES 4 SPACES
:               R12     LINK

TSTOFP  LR      R11,R11
        JEFS    TOF010          :IF NOT INDENTING
        LHI     R5,0A0A0        :BLANK BLANK
        JAL     R6,PPTOM
        JAL     R6,PPTOM
TOF010  LA      R5,PORHDR,,
        JAL     R6,PMSTOM       :OUTPUT HEADER
        JAL     R7,TOMOBW       :WAIT FOR THIS TO OUTPUT
        LIS     R9,0            :PORT #
TOF020  TBT     R9,,R10
        JE      TOF110          :IF NOT REQUESTED
        LR      R11,R11
        JEFS    TOF030          :IF NOT INDENTING
        LHI     R5,0A0A0        :BLANK BLANK
        JAL     R6,PPTOM
        JAL     R6,PPTOM
TOF030  OUTNUM(R9,4)            :PORT #
        LHI     R0,0A0          :BLANK
	TBT	R9,TRANSP	:TRANSPARENT MODE?
	JEFS	TOF035
	TBT	R9,ACP		:*AND ACTIVE?
	JEFS	TOF035
	LHI	R0,0AD		:DASH IF SO
TOF035	JAL     R4,PCTOM

:       STATUS
        LA      R5,TN.DOW,,
        TBT     R9,PDOWN
        JN      TOF050          :IF DOWN
        LA      R5,TN.SHU,,
        TBT     R9,PSHUT
        JEFS    TOF040          :IF NOT SHUT
        TBT     R9,ACP
        JE      TOF050          :IF SHUT AND NOT ACTIVE
        LA      R5,TN.VES,,
        J       TOF050          :VESTIGIAL

TOF040  LA      R5,TN.ACT,,     :ACTIVE
        TBT     R9,ACP
        JNFS    TOF050          :IF UP AND ACTIVE
        LA      R5,TN.UP,,      :UP
        TBT     R9,SIGCAN
        JEFS    TOF050          :IF NOT SIGNAL CANDIDATE
        TBT     R9,SIN
        JEFS    TOF050          :IF SIN HIGH
        LA      R5,TN.DOW,,     :REPORT PORT DOWN
TOF050  LIS     R7,6
        JAL     R6,PMSTM1       :OUTPUT STATUS

:	TIME DISPLAY HHH:MM	::2.06 - CAB - PER BRYAN WING, HQTECH

	LHI	R0,0A0		::SEND A BLANK
	JAL	R4,PCTOM	::
        TBT     R9,ACP		::IS THE PORT ACTIVE?
	JNFS	TOF052          ::GO DISPLAY CONNECT TIME
	LHI     R5,0A0A0	::ELSE SKIP DISPLAY, PAD WITH BLANKS
        JAL     R6,PPTOM	::
        JAL     R6,PPTOM	::
        JAL     R6,PPTOM	::
	J	TOF058		::GO PROCESS NEXT FIELD
TOF052	LIS	R8,$A 10	::SET RADIX TO BASE 10
        LR      R4,R9           :: 
        SLLS    R4,2            ::GET FULLWORD INDEX
        L       R7,SLOWC,,      ::GET THE CURRENT TIME
        S       R7,CLKSAV,R4    ::GET CONNECT TIME
        LIS     R6,0            ::CLEAR UPPER HALF OF R6/R7 PAIR
	LHI	R5,$A 3600	::3600 SECONDS PER HOUR
        DR      R6,R5		::R7 = HOURS
	OUTNUM(R7,3)		::DISPLAY HOURS
	LHI	R0,0BA		::SEND A COLON ":"
	JAL	R4,PCTOM	::
        LR      R4,R9           :: 
        SLLS    R4,2            ::GET FULLWORD INDEX
        L       R7,SLOWC,,      ::GET THE CURRENT TIME
        S       R7,CLKSAV,R4    ::GET CONNECT TIME
	LHI	R5,$A 60	::60 SECONDS PER MINUTE
        LIS     R6,0            ::CLEAR UPPER HALF OF R6/R7 PAIR
        DR      R6,R5		::R7 = TOTAL MINUTES (0-???)
        LIS     R6,0            ::CLEAR UPPER HALF OF R6/R7 PAIR
        DR      R6,R5		::
	LR	R7,R6		::R7 = MINUTES (0-59)
	CLHI	R7,$A 10	::
	JGE	TOF054		::IF 10 TO 59 DO A TWO DIGIT DISPLAY
	LHI	R5,3030,R7	::ELSE CHEAT TO FORCE 0-9 TO BE 00-09
	JAL	R6,PPTOM	::
	JFS	TOF056		::
TOF054	OUTNUM(R7,2)		::DISPLAY MINUTES
TOF056	LB	R8,TOMRAD	::RESTORE RADIX

:       CANDIDATE TYPES

TOF058  LHI     R0,0A0          :BLANK
        JAL     R4,PCTOM
        LA      R5,TN.IFU,,
        TBT     R9,SIGCAN
        JEFS    TOF060          :IF NOT SIGNAL CANDIDATE
        LA      R5,TN.SIG,,
TOF060  LIS     R7,4
        JAL     R6,PMSTM1

:       SIGNAL TYPES
        LHI     R0,02F          :SLASH
        JAL     R4,PCTOM
        LA      R5,TN.IFU,,
        TBT     R9,SIGANS
        JEFS    TOF065          :IF NOT SIGNAL SIGNAL-TYPE
        LA      R5,TN.SIG,,
TOF065  LIS     R7,4
        JAL     R6,PMSTM1

:       SORDS
        LHI     R0,0A0          :BLANK
	JAL	R4,PCTOM
        LIS     R14,0           :HPT INDEX
        LIS     R15,0           :SORD
TOF070  TBT     R9,HPTS,R14,
        JE      TOF080          :IF NOT ASSIGNED TO THIS SORD
        JAL     R4,PCTOM        :OUTPUT BLANK OR COMMA
        OUTNUM(R15,3)
        LHI     R0,0AC          :COMMA
TOF080  AHI     R14,NHPGRP*2
        AIS     R15,1
        CLHI    R15,NSORDS
        JL      TOF070          :IF NOT DONE

:       TYPES
        LHI     R0,0A0          :BLANK
        JAL     R4,PCTOM
        LHI     R0,0BA          :COLON
        LIS     R14,0           :TYPE # INDEX
        LIS     R15,0           :TYPE #
TOF090  TBT     R9,PTYPE,R14,
        JE      TOF100          :IF NOT FOR THIS PORT TYPE
        JAL     R4,PCTOM        :OUTPUT BLANK OR COMMA
        OUTNUM(R15,2)           :OUTPUT TYPE #
        LHI     R0,0AC          :COMMA

:       OUTPUT A RANGE TI-TJ IF POSSIBLE
TOF095  AHI     R14,NHPGRP*2
        AIS     R15,1
        CLHI    R15,MAXTYP
        JGFS    TOF097          :IF MAX TYPE REACHED
        TBT     R9,PTYPE,R14,
        JEFS    TOF097          :IF NOT THIS TYPE
        LHI     R0,0AD          :-
        JBS     TOF095

TOF097  CLHI    R0,0AD
        JN      TOF100          :IF NOT A RANGE
        JAL     R4,PCTOM        :OUTPUT DASH FOR RANGE
        SIS     R15,1
        OUTNUM(R15,2)
        AIS     R15,1
        LHI     R0,0AC          :COMMA
TOF100  AHI     R14,NHPGRP*2
        AIS     R15,1
        CLHI    R15,MAXTYP
        JLE     TOF090          :IF MAX TERMINAL TYPE NOT REACHED
        LHI     R0,0BE          :>
        JAL     R4,PCTOM
        LB      R7,PSPEED,R9,   :GET PORT SPEED INDEX
	CLHI	R7,SB-2000	:BAUDOT?
	JNFS	TOF102
	LHI	R0,0C2		:"B" IF SO
	JFS	TOF103
TOF102  CLHI    R7,SF-2000      :FULL?
        JNFS    TOF105          :IF NOT
        LHI     R0,0C6          :"F" IF SO
TOF103  JAL     R4,PCTOM
        JFS     TOF107

TOF105  OUTNUMB(R7,2)           :OUTPUT SPEED INDEX
TOF107  LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM
        JAL     R7,TOMOBW       :WAIT FOR THIS TO OUTPUT

:       NEXT PORT
TOF110  AIS     R9,1
        CLHI    R9,NNTMPT
        JL      TOF020          :IF MORE PORTS
        JR      R12             :EXIT


: TSTOSN - OUTPUT SORD NAME FOLLOWED BY SORD INDEXES
:
:       ENTRY   R14     LINK
:               R15     HNT ENTRY PTR
:               R9      SORD #
:               R1      TOM BUFFER #
:
:       USES    R0-6,9,14,15

TSTOSN  LR      R2,R9
        SLHLS   R2,2
        L       R5,HGRT,R2,     :GET 4 CHAR GREETING
        JNFS    TON010          :IF NOT NULL
        L       R5,TN.BLA,,     :SUB BLANKS
TON010  EXHR    R5,R5           :FIRST 2 CHARS OF GREET
        JAL     R6,PPTOM        :OUTPUT NAME
        EXHR    R5,R5           :LAST 2 CHARS OF GREET
        JAL     R6,PPTOM
TON020  LHI     R0,0A0
        JAL     R4,PCTOM        :OUTPUT BLANK
        LH      R5,HNT+2,R15,   :PREFIX
        JEFS    TON030          :IF NULL
        JAL     R6,PPTOM        :OUTPUT IT
TON030  AIS     R15,HNTE.L
        LH      R5,HNT+4,R15,   :NEXT SORD #
        CR      R5,R9
        JEBS    TON020          :IF SAME SORD
        LHI     R5,8D8A
        JAL     R6,PPTOM        :CRLF
        JR      R14             :DONE


: CAB - CONVERT ASCII TO BINARY.
:
:       GETS ASCII CHARACTERS FROM GCI BUFFER AND CONVERT TO BINARY NUMBER.
:       STOPS WHEN A NONNUMERIC (IN GIVEN RADIX) OR NONBLANK IS SEEN.
:       ALSO STOPS IF NEXT DIGIT WOULD CAUSE OVERFLOW (>7FFFFFFF).  THE
:       TERMINATOR MUST BE CURRENTLY IN THE BUFFER OR A GCI CRASH WILL RESULT.
:       A TERMINATOR BEFORE ANY NUMERIC CHARACTERS ARE SEEN CAUSES A ZERO
:       VALUE TO BE RETURNED FOR THE BINARY NUMBER AND A NEGATIVE VALUE
:       FOR THE CONDITION CODE.  THIS CASE AND THE OVERFLOW CASE CAUSE
:       RETURN TO R6, ELSE RETURN IS TO R6+4.
:
:       ENTRY   R8      RADIX (2 TO 10 HEX)
:               R6      LINK
:               R0      FIRST ASCII CHAR OF # (HEX 30 IF NONE)
:               R1      TOPORT BUFFER #,PARITY REMOVED
:
:       EXIT    R7      BINARY #
:               R0      CHARACTER AFTER NUMBER (PARITY REMOVED)
:
:       DESTROYS R0,2-4,R7,R5
:
:       CALLS   GNC

CAB     LCS     R7,1            :INITIALIZE BINARY VALUE
        JFS     CAB020
CAB010  JAL     R5,GNC          :GET NEXT CHARACTER
CAB020  LR      R4,R0
        SHI     R4,30           :REMOVE BIAS
        JL      CAB050          :IF NOT A NUMBER
        CLHI    R4,9            :GREATER THAN 9?
        JLEFS   CAB030          :IF NOT
        SIS     R4,7            :CORRECT FOR A-F
        CLHI    R4,0A           :LESS THAN A?
        JL      CAB050          :IF NOT A NUMBER
CAB030  CR      R4,R8           :WITHIN RADIX RANGE?
        JGE     CAB050          :IF NOT NUMBER IN THIS RADIX
        LR      R3,R7           :GET TO SCRATCH REG
        JGEFS   CAB040          :IF NOT FIRST TIME IN
        LIS     R3,0            :INIT BINARY VALUE
CAB040  MR      R2,R8           :MULTIPLY BY RADIX
        AR      R3,R4           :ADD IN THIS DIGIT
        JLFS    CAB045          :IF OVERFLOW, EXIT
        LR      R7,R3
        J       CAB010          :CONTINUE

CAB045  LIS     R2,0            :SET COND CODE
        JR      R6

:       NON DIGIT FOUND
CAB050  LR      R7,R7           :NO NUMBER ACCUMULATED?
        JGE     4,R6		:IF NUMBER OK
        LIS     R7,0            :SET TO ZERO
        LCS     R2,1            :SET NEGATIVE CONDITION
        JR      R6

: GNC - GET NEXT CHARACTER
:
:       IGNORES BLANKS, REMOVES PARITY, CONVERTS TO UPPER CASE,
:       PROCESSES CONTROL CHARACTERS.

GNC     JAL     R4,GCTOM        :GET NEXT CHARACTER
        NHI     R0,7F           :REMOVE PARITY
        JEFS    GNC010          :IF ESCAPE
        CLHI    R0,$0 20        :BLANK?
        JEBS    GNC             :IF YES, IGNORE
        CLHI    R0,$0 60        :LOWER CASE?
        JLR     R5              :IF NO, EXIT
        SHI     R0,$0 20        :CONVERT TO UPPER
        JR      R5              :EXIT

GNC010  JAL     R4,GCTOM        :GET CTL CHAR
        CLHI    R0,AO.DSC       :DISCONNECT?
        JN      GNC             :IGNORE IF NOT
        J       TOMZAP          :PROCESS ZAPPER

: MNR - MARK NUMBER RANGE
:
:       GIVEN A NUMBER RANGE, A BIT ARRAY START ADDRESS AND LENGTH
:       AND A RADIX, MNR FIRST CLEARS THE BIT ARRAY THEN SETS BITS FOR
:       NUMBERS IN THE RANGE.  IF THERE ARE ANY ERRORS (ILLEGAL CHARACTERS,
:       OUTSIDE RANGE, ETC.) RETURN IS TO LINK, ELSE RETURN IS TO LINK+4.
:       THE CONDITION CODE WILL BE NEGATIVE IF NO LIST WAS SEEN (ERROR
:       EXIT.  IN EVERY OTHER CASE IT WILL BE POSITIVE.
:       THE RANGE IS AN ASCII STRING (IN BUFFERLETS) WHICH MAY BE A SINGLE
:       NUMBER N, A RANGE OF INCLUSIVE NUMBERS NI-NJ, OR A SET OF
:       RANGES SEPARATED BY COMMAS.  BLANKS ARE IGNORED.  THE SCAN IS
:       STOPPED IF A CHARACTER OTHER THAN A BLANK, DASH, COMMA OR NUMBER IS
:       ENCOUNTERED.
:
:       ENTRY   R8      RADIX (2 THROUGH 10 HEX)
:               R1      BUFFER NUMBER FOR GCI CALLS
:               R0      FIRST CHARACTER OF RANGE
:               R10     ADDRESS OF BIT ARRAY FOR RANGE
:               R11     ARRAY SIZE (MAX NUMBER FOR RANGE + 1)
:               R9      LINK ADDRESS
:
:       EXIT    R0      LAST CHARACTER SEEN
:
:       DESTROYS R0,2-4, R7, R5
:
:       CALLS   CAB, GNC, WCD

        SEG     A.DATA
MNRSAV  HS      1
        SEG     A.CODE

MNR     LHI     R2,-1,R11       :GET NUMBER OF BYTES
        SRHLS   R2,3
        LIS     R3,0
MNR010  STB     R3,,R10,R2      :CLEAR A BYTE
        SIS     R2,1            :NEXT BYTE
        JGEBS   MNR010          :IF MORE TO CLEAR
        JFS     MNR025

MNR020  JAL     R5,GNC          :GET NONBLANK CHARACTER
MNR025  CLHI    R0,2C
        JEBS    MNR020          :IF COMMA
        JAL     R6,CAB          :CONVERT ASCII TO BINARY
        J       0,R9		:ERROR RETURN
        CLHI    R0,2D           :NUMBER FOLLOWED BY -?
        JE      MNR040          :IF N1-N2 RANGE
        CR      R7,R11          :IS NUMBER IN RANGE?
        JGER    R9              :IF ILLEGAL NUMBER
        SBT     R7,,R10         :FLAG NUMBER
MNR030  CLHI    R0,2C           :NUMBER FOLLOWED BY A ,?
        JE      MNR020          :IF COMMA, GET NEXT RANGE
        LR      R0,R0           :GET POSITIVE CONDITION
        J       4,R9            :EXIT

:       HERE FOR N1-N2 RANGE.
MNR040  STH     R7,MNRSAV,,     :SAVE N1
        JAL     R5,GNC          :GET NONBLANK CHARACTER
        JAL     R6,CAB          :CONVERT ASCII TO BINARY
        J       0,R9		:ERROR RETURN
        CR      R7,R11          :N2 WITHIN RANGE?
        JGER    R9              :IF ILLEGAL #
        LH      R2,MNRSAV,,     :GET N1
        CR      R2,R7           :RANGE OK?
        JGR     R9              :ILLEGAL RANGE
MNR050  SBT     R7,,R10         :SET BIT IN RANGE
        SIS     R7,1            :NEXT DOWN IN RANGE
        CR      R7,R2           :STILL IN RANGE?
        JGEBS   MNR050          :IF MORE TO GO
        J       MNR030          :CHECK FOR MORE RANGES

: MAR - MARK ALL RANGE
:
:       SETS ALL BITS TO ONE IN A RANGE.
:
:       ENTRY   R10     ADDRESS OF BIT ARRAY FOR RANGE
:               R11     ARRAY SIZE (MAX NUMBER FOR RANGE + 1)
:               R9      LINK ADDRESS
:
:       DESTROYS R2,3

MAR     LHI     R2,-1,R11
        SRHLS   R2,3
        LCS     R3,1
MAR010  STB     R3,,R10,R2
        SIS     R2,1
        JGEBS   MAR010
        JR      R9

: SPN - SKIP PARAMETER NAMES
:
:       ENTRY   R7      ADDRESS OF PARAMETER NAME
:
:       EXIT    R0      CHARACTER AFTER PARAMETER NAME (BUFFER POINTERS
:                       BACKED UP OVER THIS CHAR)

SPN     JAL     R5,GNC          :GET NEXT NONBLANK CHAR
        LB      R2,,R7          :GET NEXT PARAMETER NAME CHAR
        NHI     R2,7F
        AIS     R7,1
        CR      R0,R2           :SAME?
        JEBS    SPN             :IF YES, CONTINUE SKIPPING
        JR      R6              :EXIT
        SUBTTL	TOM COMMAND PROCESSORS

: TOMAS - ASSIGN PORTS RI TO SORDS RJ

TOMAS   J       TOMERR          :NO PARAMETERS IS ILLEGAL

:       GET PORT NUMBERS
        SKPMRK(TN.POR,NNTMPT,TOMRI)

:       CHECK FOR ACTIVE PORTS
        LIS     R2,(NNTMGP-1)*2
TAS010  LH      R3,TOMRI,R2     :GET A GROUP IN RANGE
        NH      R3,ACP,R2       :ANY ACTIVE PORTS?
        JN      TAS100          :IF YES
        SIS     R2,2            :NEXT GROUP
        JGEBS   TAS010          :IF MORE TO GO

:       DEASSIGN PORTS FROM ALL PREVIOUS SORDS
        LHI     R2,(NSORDS-1)*2*NHPGRP
TAS020  LHI     R3,(NNTMGP-1)*2
TAS030  LH      R4,TOMRI,R3     :GET A GROUP IN RANGE
        NH      R4,HPTS,R2,R3   :REQUESTED AND ASSIGNED
        XH      R4,HPTS,R2,R3   :DEASSIGN ANY ASSIGNED
        STH     R4,HPTS,R2,R3

:       CLEAR TSAT PORT INDICATION
        LH      R4,TOMRI,R3
        NH      R4,TSATPT,R3
        XH      R4,TSATPT,R3
        STH     R4,TSATPT,R3
        SIS     R3,2            :NEXT PORT GROUP
        JGE     TAS030          :IF MORE FOR THIS SORD
        SHI     R2,2*NHPGRP     :NEXT SORD
        JGE     TAS020          :IF MORE TO GO

:	DEASSIGN PORTS FROM ALL PREVIOUS HOSTS

	LHI	R2,(MAXHST-1)*2*NHPGRP
TAS035	LHI	R3,(NNTMGP-1)*2
TAS038	LH	R4,TOMRI,R3	:GET A GROUP IN RANGE
	NH	R4,HNPNTB,R2,R3	:REQUESTED AND ASSIGNED
	XH	R4,HNPNTB,R2,R3	:DEASSIGN ANY ASSIGNED
	STH	R4,HNPNTB,R2,R3
	SIS	R3,2		:NEXT PORT GROUP
	JGEBS	TAS038		:IF MORE FOR THIS HOST	
	SHI	R2,2*NHPGRP	:NEXT HOST
	JGE	TAS035		:IF MORE TO GO

:       GET NEW SORD NUMBERS
        CLHI    R0,54           :T?
        JEFS    TAS040          :IF YES
        CLHI    R0,0D           :CR?
        JE      TOMEXI          :IF DONE
        J       TOMERR          :IF ERR

:       GET SORD NUMBERS
TAS040  SKPMRK(TN.O,NSORDS,TOMRJ)

:       ASSIGN PORTS TO REQUESTED SORDS
        LHI     R2,(NSORDS-1)*2*NHPGRP
        LHI     R5,NSORDS-1
TAS050  LHI     R3,(NNTMGP-1)*2 :PORT GROUP INDEX
        TBT     R5,TOMRJ        :THIS SORD REQUESTED?
        JE      TAS070          :IF NOT
	LIS	R11,0	
TAS052	LHL	R9,HNT+4,R11,	:SORD #
	LHL	R10,HNT,R11,	:HOST ORDINAL
	CR	R9,R5		:SAME SORD ?
	JEFS	TAS055		:IF YES		
	AIS	R11,HNTE.L	:NEXT ENTRY
	JBS	TAS052
TAS055	LHI	R8,NHPGRP*2
	MHR	R10,R8
TAS060	LH	R4,TOMRI,R3	:NEXT HOST PORT GROUP
	OH	R4,HNPNTB,R10,R3 :ASIGN THE PORTS
	STH	R4,HNPNTB,R10,R3		
	

	LH      R4,TOMRI,R3     :NEXT PORT GROUP
        OH      R4,HPTS,R2,R3   :ASSIGN THE PORTS
        STH     R4,HPTS,R2,R3
        LR      R5,R5
        JNFS    TAS065          :IF NOT TOM OR TYMSAT PORT
        LH      R4,TOMRI,R3
        OH      R4,TSATPT,R3
        STH     R4,TSATPT,R3
TAS065  SIS     R3,2            :NEXT PORT GROUP
        JGE     TAS060          :IF MORE FOR THIS SORD
TAS070  SHI     R2,2*NHPGRP     :NEXT SORD
        SIS     R5,1            :MORE?
        JGE     TAS050          :IF YES
        J       TOMEXI          :DONE

:       HERE IF A REQUESTED PORT WAS ACTIVE, GIVE ERROR MESSAGE
TAS100  LA      R5,PATMSG,,
        JAL     R6,PMSTOM
        J       TOMEXI


: TOMCA - CANDIDATE PORTS RI IFUP
:         CANDIDATE PORTS RI SIGNAL

TOMCA   J       TOMERR          :NO PARAMETER IS ILLEGAL
	LA	R12,SIGCAN	:CANDIDATE TYPE ARRAY
	JFS	TSW000

: TOMSI - SIGNAL PORTS RI IFUP
:         SIGNAL PORTS RI SIGNAL

TOMSI   J       TOMERR          :NO PARAMETER IS ILLEGAL
	LA	R12,SIGANS	:SIGNAL TYPE ARRAY

:	COMMON PROCESSOR FOR CA & SI COMMANDS

TSW000	HS
        SKPMRK(TN.POR,NNTMPT,TOMRI)
        LHI     R2,(NNTMGP-1)*2
        CLHI    R0,53		:"S"?
        JE      TSW020          :BR IF SO
        CLHI    R0,49		:"I"?
        JN      TOMERR          :IF NEITHER, ERROR

:       SET THINGS OFF
TSW010  LCS     R3,1
        XH      R3,TOMRI,R2     :COMPLEMENT RI
        NH      R3,0,R2,R12     :SET BITS OFF
        STH     R3,0,R2,R12
        SIS     R2,2
        JGEBS   TSW010          :IF MORE
        J       TOMEXI          :DONE

:       SET THINGS ON
TSW020  LH      R3,TOMRI,R2
        OH      R3,0,R2,R12     :SET BITS ON
        STH     R3,0,R2,R12
        SIS     R2,2
        JGEBS   TSW020          :IF MORE
        J       TOMEXI          :DONE

: TOMCH - CHANGE HOST M TO N

TOMCH   J       TOMERR          :NULL ILLEGAL
        LA      R7,TN.HOS,,
        JAL     R6,SPN          :SKIP HOST WORD
        LIS     R8,$A10         :HOST # ALWAYS DECIMAL
        JAL     R6,CAB          :CONVERT HOST #
        J       TOMERR          :BAD NUMBER

:       FIND HOST IN HOST TABLE
        LHI     R11,MAXHST-1
TCH010  LHL     R9,HOSTS,R11,R11
        CR      R9,R7
        JEFS    TCH020          :IF HOST FOUND
        SIS     R11,1
        JGEBS   TCH010          :IF MORE TO CHECK
        J       TOMERR          :UNKNOWN HOST #

:       SKIP PAST "TO" WORD
TCH020  CLHI    R0,54           :T?
        JN      TOMERR          :IF NO TO
        JAL     R5,GNC          :GET THE O
        CLHI    R0,4F           :O?
        JNFS    TCH030          :IF NOT, CHECK FOR NUMBER
        JAL     R5,GNC          :GET START OF NUMBER
TCH030  JAL     R6,CAB          :GET NEW HOST #
        J       TOMERR          :BAD NUMBER
:       SET OLD HOST TO GONE AND NEW HOST TO SHUT
        LR      R6,R11          :GET RELATIVE HOST #
        LIS     R12,3           :GONE STATUS
        JAL     R5,CHSTAT       :SET OLD HOST GONE
        LR      R9,R7           :NEW HOST #
        LIS     R12,2
        JAL     R5,CHSTAT       :SET NEW HOST SHUT
        J       TOMEXI          :DONE


: TOMDI - DIAGNOSTICS ON
:         DIAGNOSTICS OFF

TOMDI   J       TDI020          :DEFAULT IS ON
        JAL     R5,GNC          :GET NONBLANK CHARACTER
        CLHI    R0,4F           :O?
        JN      TOMERR          :IF ERROR
        JAL     R5,GNC          :GET NEXT CHAR
TDI010  RBT     RHP,TDMOFF-NNTMGP*2
        CLHI    R0,4E           :N?
        JE      TOMEXI          :IF ON, DONE
        CLHI    R0,46           :F?
        JN      TOMERR          :IF NOT OFF, ERROR
        SBT     RHP,TDMOFF-NNTMGP*2 :TURN OFF DIAGNOSTIC MODE
        J       TOMEXI          :DONE

:       HERE FOR NULL PARAMETER
TDI020  LHI     R0,4E           :N
        J       TDI010          :PROCESS AS ON


:       TOMDO   DOWN SORDS RI
:               DOWN PORTS RI
:               DOWN HOSTS RI

TOMDO   J       TOMERR          :NO PARAMETER IS ILLEGAL
        JAL     R5,GNC          :GET NONBLANK CHARACTERS
        CLHI    R0,53           :S?
        JN      TDO040          :IF NOT SORDS

:       DOWN SORDS RI
        SKPMRK(TN.SOR+1,NSORDS,TOMRI)

:       DROP ACTIVE PORTS, SET SORD DOWN
        LHI     R8,NSORDS-1     :SORD # INDEX
        LHI     R9,(NSORDS-1)*2*NHPGRP
TDO010  LHI     R10,(NNTMGP-1)*2        :PORT GROUP INDEX
        TBT     R8,TOMRI        :THIS SORD?
        JE      TDO030          :IF NOT
        CLHI    R8,TOM
        JEFS    TDO030          :IF TOM SORD, IGNORE
TDO015  LCS     R7,1
TDO020  LH      R1,HPTS,R9,R10  :GET PORT MASK FOR THIS SORD
        NR      R1,R7           :NOT PROCESSED
        JFFOH   R1,TDO035       :IF PORTS TO PROCESS
        SIS     R10,2
        JGEBS   TDO015          :IF MORE PORT GROUPS
        SBT     R8,SDOWN        :SET SORD DOWN
TDO030  SHI     R9,NHPGRP*2
        SIS     R8,1            :NEXT SORD
        JGE     TDO010          :IF MORE SORDS
        J       TOMEXI          :DONE

TDO035  XH      R7,HMASK,R2,R2  :FLAG ALREADY PROCESSED
        LR      R1,R10
        SLHLS   R1,3
        AR      R1,R2           :BIAS PORT # BY GROUP
	TBT	R1,ACP		:2.06 - CAB  - NSR 681
	JE	TDO020		:2.06 - DROP PORT ONLY IF ACTIVE
        SBT     R1,DTR          :DROP SIGNAL
	SBT	R1,TDROP	:TELL FG TO DROP PORT
        J       TDO020          :KEEP LOOKING

:       CHECK FOR "DOWN PORTS RI"
TDO040  CLHI    R0,50           :P?
        JN      TDO060          :IF NOT PORTS
        SKPMRK(TN.POR+1,NNTMPT,TOMRI)
        LH      R15,TPN-TOMPIX*2,RHP,RHP :SEE IF HARDWIRED TOM PORT
        JLFS    TDO045          :IF NOT HARDWIRED TOM PORT
        RBT     R15,TOMRI       :DON'T DOWN OUR OWN PORT!

:       BRING PORTS DOWN
TDO045	LIS     R8,(NNTMGP-1)*2 :PORT GROUP INDEX
TDO050  LH      R9,TOMRI,R8
        OH      R9,PDOWN,R8
        STH     R9,PDOWN,R8
TDO054  LH      R1,TOMRI,R8
        JFFOH   R1,TDO057       :IF SOMETHING TO PROCESS
        SIS     R8,2
        JGEBS   TDO050          :IF MORE PORT GROUPS
        LR      R1,R15          :RESTORE BUFFER #
        J       TOMEXI

TDO057  LR      R1,R8
        SLHLS   R1,3
        AR      R1,R2           :BIAS TO PORT #
        RBT     R1,TOMRI        :FLAG ALREADY PROCESSED
	TBT	R1,ACP		:2.06 - CAB - NSR 681
	JE	TDO054		:2.06 - DROP PORT ONLY IF ACTIVE
        SBT     R1,DTR          :DROP SIGNAL
	SBT	R1,TDROP	:TELL FG TO DROP PORT
        J       TDO054          :KEEP LOOKING

:       DOWN HOSTS RI
TDO060  LIS     R12,1           :SET TO DOWN

: TOMCHS - CHANGE HOST STATUS

TOMCHS  CLHI    R0,48           :H?
        JN      TOMERR          :IF NOT HOSTS
        LA      R7,TN.HOS+1,,
        JAL     R6,SPN          :SKIP PARAMETER NAME
        LIS     R8,$A 10        :RADIX ALWAYS DECIMAL FOR HOSTS
TCS010  JAL     R6,CAB          :CONVERT ASCII TO BINARY
        J       TCS040          :IF ERROR IN NUMBER
:       FIND HOST IN HOSTS TABLE.
        LHI     R6,MAXHST-1
TCS020  LHL     R9,HOSTS,R6,R6
        CR      R9,R7
        JEFS    TCS030          :IF FOUND
        SIS     R6,1
        JGEBS   TCS020          :IF MORE HOSTS TO CHECK
        J       TOMERR          :UNKNOWN HOST NUMBER

TCS030	CLHI	R12,2		:HOST SHUT?
	JNFS	TCS032		:IF NOT
	SBT	R6,HSTSHT	:SET A BIT TO KEEP TYMCOM HOST REPORTING
				:ANSWERED WHEN IT HAS BEEN SHUT VIA TOM AND
				:CUSTOMER HOST HAS RAISED AND LOWERED ITS DTR
	J	TCS034 
TCS032	CLHI	R12,0		:HOST ANSWER?
	JNFS	TCS034		:IF NOT	
	RBT	R6,HSTSHT

TCS034	LR      R10,R0          :SAVE CHAR
        LR      R11,R1          :SAVE BUFFER #
        JAL     R5,CHSTAT       :CHANGE HOST STATUS
:	PORTS AVAILABLE YET HOST SHUT CONDITION
:	TEST IF R12=0 ? ( HOST ANSWER )
	CLHI	R12,0		:HOST ANSWER?
	JN	TCS036		:IF NOT
:	SEND PORTS AVAILABLE MSG TO SUPV WHEN TOM "UP" COMMAND
:	IS GIVEN TO A HOST OR A SORD THAT HAS NOT PORTS ASSIGNED
:	AT INITIALIZATION BUT HAS BEEN ASSIGNED ABAILABLE PORTS VIA THE TOM

	LIS	R5,1		:SEND "HOST PORT AVAILABILITY" 0A MSG
	LIS	R0,HPA.L	:HPA.L=0A MSG LENGTH
	LIS	R1,0	
	LIS	R2,NM.HPA	:MSG 0A
	JAL	R4,SLOR,,	:START MSG RECORD
	JAL	R4,PUTCH,,	:KEY
	LH	R0,HOSTS,R6,R6	:HOST #
	EXHR	R0,R0
	EXBR	R0,R5		:NUMBER/PORTS
	JAL	R4,PUTW,,
	LR	R0,R6
	JAL	R4,PUTH,,	:RH#
	JAL	R4,ELOR,,	:END MSG RECORD
	 
TCS036  LR      R1,R11          :RESTORE BUFFER #
        CLHI    R10,2C          :COMMA?
        JN      TOMEXI          :IF NO, DONE
        JAL     R5,GNC          :GET NONBLANK CHAR
        J       TCS010          :NEXT HOST

:       HERE FOR NO HOST LIST.
TCS040  CLHI    R0,0D           :CR?
        JN      TOMERR          :IF BAD LIST
        LR      R11,R1          :SAVE BUFFER #
        LHI     R6,MAXHST-1
TCS050  LHL     R9,HOSTS,R6,R6  :GET NEXT NETWORK HOST #
        JAL     R5,CHSTAT       :CHANGE HOSTS STATUS
        SIS     R6,1
        JGEBS   TCS050          :IF MORE HOSTS
        LR      R1,R11          :RESTORE BUFFER #
        J       TOMEXI          :DONE


: TOMEN - ENQUIRE

TOMEN	NOP
	LA      R5,ENQHDR,,
        JAL     R6,PMSTOM	:PRINT ENQUIRE HEADER
	JAL	R7,TOMOBW	:*IN 2 PIECES
	LA	R5,ENQHD2,,
	JAL	R6,PMSTOM

	LHI	R12,NAPORT	:TYMCOM PORT GROUP NMBR FOR SIO
        LIS     R15,0           :TYMCOM PORT GROUP NMBR FOR ASYNC
        LIS     R14,0           :LOGICAL UNIT #
TEN100	LR	R9,R14
	LA	R10,ENQSTS,,	:PLACE TO PUT STATUS
        LIS     R11,3           :# BYTES IN STATUS
        SVC     IO,IOQRY.+R9,,  :GET LOGICAL UNIT INFO
        J       TEN105          :BAD STATUS ADDRESS
        LB      R11,ENQSTS,,    :GET UNIT TYPE
        CLHI    R11,0FE
        JE      TOMEXI          :IF NO MORE LOGICAL UNITS
        CLHI    R11,1
        JEFS    TEN110          :IF ASYNC UNIT
	CLHI	R11,4
	JE	TEN200		:IF SIO UNIT
TEN130  AIS     R14,1           :NEXT UNIT
        J       TEN100          :SKIP UNTIL AN ASYNC UNIT
TEN105  TRAP(R10,23)

TEN110	LIS	R8,0A		:SET DECIMAL
        LB      R7,ENQSTS+1,,   :GET ASYNC GROUP #
        LA      R5,ENQDVN,,
        LIS     R4,2
        JAL     R6,CBA
        SLHLS   R7,4            :CONVERT MACHINE PORT RANGE
        LA      R5,ENQPHP,,
	LHI	R0,0AD		:SET UP DASH
	STB	R0,3,R5
        LIS     R4,3
        JAL     R6,CBA
        AIS     R7,$A15         :GET END OF MACHINE PORT RANGE
	AIS	R5,4
        LIS     R4,3
        JAL     R6,CBA
        LA      R5,ENQTCP,,
        CLHI    R15,NAPGRP-1
        JLE     TEN120          :IF STILL WITHIN TYMCOM PORT RANGE
	LI	R0,0A0A0A0A0	:BLANK AREA
	ST	R0,0,R5
	ST	R0,4,R5
	J	TEN150
TEN120  LR      R7,R15          :CONVERT TYMCOM PORT RANGE
        SLHLS   R7,4
	LHI	R0,0AD		:SET UP DASH
	STB	R0,3,R5
        LIS     R4,3
        JAL     R6,CBA
        AIS     R7,$A15         :GET END OF TYMCOM PORT RANGE
	AIS	R5,4
        LIS     R4,3
        JAL     R6,CBA
TEN150	LI	R1,0A0C1D3D9	:SET DEVICE TO " ASY"
	AIS	R15,1		:BUMP TYMCOM PORT NMBR FOR ASYNC
	J	TEN300

TEN200	LHI	R8,10		:SET HEXADECIMAL
        LB      R7,ENQSTS+2,,   :GET SIO DEVICE ADDR
        LA      R5,ENQDVN,,
        LIS     R4,2
        JAL     R6,CBA
	LIS	R8,0A		:SET DECIMAL
        LB	R7,ENQSTS+1,,   :CONVERT PHYSICAL PORT NMBR
        LA      R5,ENQPHP,,
	LI	R0,0A0A0A0A0	:BLANK AREA
	ST	R0,0,R5
	ST	R0,4,R5
	ST	R0,8,R5
	ST	R0,0C,R5
	AIS	R5,1
        LIS     R4,3
        JAL     R6,CBA
        CLHI    R12,NTPORT
        JGE     TEN210          :IF STILL WITHIN TYMCOM PORT RANGE
        LR      R7,R12          :CONVERT TYMCOM PORT
        LA      R5,ENQTCP+2,,
        LIS     R4,3
        JAL     R6,CBA
TEN210	LI	R1,0A0D3C9CF	:SET DEVICE TO " SIO"
	AIS	R12,1		:BUMP TYMCOM PORT NMBR FOR SIO

TEN300	ST	R1,ENQDEV,,	:STORE DEVICE TYPE
        LR      R7,R14          :CONVERT LOGICAL UNIT # TO ASCII
        LA      R5,ENQLUN,,
        LIS     R4,2
        JAL     R6,CBA
        LA      R5,ENQPMP,,	:OUTPUT ENQUIRE LINE
        JAL     R6,PMSTOM
	JAL	R7,TOMOBW	:WAIT FOR OUTPUT TO COMPLETE
        J       TEN130          :ENQUIRE ABOUT NEXT LOGICAL UNIT


: TOMEX - EXIT

TOMEX	NOP
	LHI	R0,AI.DSC	:TELL FG TO DISCONNECT THIS PORT
	JAL	R4,PETOM
	LH	R2,TPN-TOMPIX*2,RHP,RHP  :SEE IF HARDWIRED PORT
	JLFS	TOMZAP		:BR IF NOT
	SBT	R2,DTR		:DROP DTR
	LCS	R1,1
	STH	R1,IPN,R2,R2	:CLEAR HOST PORT
	RBT	RHP,ACP		:CLEAR ACTIVE PORT
	JEFS	TOMZAP
	AHM	R1,APORTS	:DECR NMBR OF ACTIVE PORTS
TOMZAP	JAL	R4,TOMCLR	:ZAP TOM PORT
        J       TOMNXT          :GET NEXT PORT


: TOMGR - GRAB PASSWORD

TOMGR   J       TGRNPW          :CHECK NULL PASSWORD
        LIS     R6,0
        JAL     R7,TOMCPW       :CHECK PASSWORD
TGR010  STH     RHP,TOMLIC      :GRAB LICENSE
        J       TOMEXI          :DONE

TGRNPW  CLH     RHP,TOMLIC
        JNFS    TGR020          :IF THIS PORT DOES'NT HAVE LICENSE
        LCS     R6,1
        STH     R6,TOMLIC       :CLEAR LICENSE
        J       TOMEXI

TGR020  LH      R6,TOMPWD
        JN      TOMERR          :IF CURRENT PASSWORD NOT NULL
        J       TGR010


: TOMHK - CHANGE HOST KEY
:       - HK HOST XXXX, XX

TOMHK	J	TOMERR
  IF HKEYN+1
	LIS	R7,1
	STH	R7,HKFLG
	LA	R7,TN.HS,,
	JAL	R6,SPN		:SKIP PARAMETER NAME
	LIS	R8,$A10		:RADIX ALWAYS DECIMAL TO HOSTS
	JAL	R6,CAB		:CONVERT HOST # TO BINARY
	J	TOMERR

	LHI	R3,MAXHST-1
THK100	LHL	R2,HOSTS,R3,R3
	LR	R15,R3
	CR	R2,R7
	JEFS	THK200		:IF FOUND
	SIS	R3,1
	JGEBS	THK100		:MORE TO GO
	J	TOMERR
THK200	CLHI	R0,2C		:COMMA?
	JN	TOMERR		:IF NOT
	JAL	R5,GNC		:GET NONBLANK CHAR
	LIS	R8,$A10		:RADIX ALWAYS DECIMAL FOR HOST KEY
	JAL	R6,CAB		:CONVERT ASCII TO BINARY
	J 	TOMERR
	STH	R7,HKEYTB,R15,R15
  EI
	LHL	R7,HKFLG
	JE	TOMHK
	J	TOMEXI


: TOMCPW - CHECK PASSWORD
:
:       R7      LINK
:       R6      0 IF OLDPW
:               8 IF NEW PW

TOMCPW  JAL     R5,GNC          :GET NEXT CHAR
        CLHI    R0,0D           :CR?
        JE      TCP020          :IF DONE
        LB      R2,TOMPWD,R6    :GET FORMER PW
        AIS     R6,1
        CR      R0,R2           :CHARACTERS MATCH?
        JEBS    TOMCPW          :IF YES, CONTINUE CHECK
        J       TOMERR          :NOT CORRECT PW

TCP020  LB      R2,TOMPWD,R6    :GET NEXT CHAR OF OLD PW
        LR      R2,R2
        JN      TOMERR          :IF NEW ENDS BEFORE OLD
        JR      R7              :PW IS OK


: TOMME - MESSAGE SORDS RI "MSG"

TOMME   J       TOMERR
        SKPMRK(TN.SOR,NSORDS,TOMRI)

:       CLEAR ANY OLD MESSAGES.
        LHI     R15,NSORDS-1
        LIS     R2,0
TME010  TBT     R15,TOMRI
        JE      TME080          :IF NOT REQUESTED
        LHL     R10,HOPMSP,R15,R15      :GET MSG POINTER FOR THIS SORD
        JE      TME080          :IF NO MESSAGE
        STH     R2,HOPMSP,R15,R15
        LHI     R11,(NSORDS-1)*2
TME020  LHL     R12,HOPMSP,R11
        CR      R12,R10
        JE      TME080          :IF SOME OTHER SORD USES THIS MESSAGE
        SIS     R11,2
        JGEBS   TME020          :IF MORE TO CHECK
        LR      R4,R10          :START OF NEXT MSG OR END OF MSGS

:       MOVE OTHER MESSAGES DOWN
TME030  LB      R1,HOPMS,R10,   :GET LENGTH OF MSG
TME035  LR      R14,R1
        AHI     R14,1,R10       :START OF NEXT MESSAGE
        CLH     R14,HOPMS,,
        JGE     TME070          :IF PASSED LAST MESSAGE
        LHI     R11,(NSORDS-1)*2
TME040  LHL     R12,HOPMSP,R11
        CR      R12,R14
        JNFS    TME050          :IF NOT MATCH
        STH     R4,HOPMSP,R11   :MOVE PTR DOWN
TME050  SIS     R11,2
        JGEBS   TME040          :IF MORE TO CHECK
        LB      R11,HOPMS,R14,  :GET LENGTH
        LIS     R1,0
TME060  LB      R12,HOPMS,R1,R14  :GET CHAR
        STB     R12,HOPMS,R1,R4   :MOVE IT
        AIS     R1,1
        SIS     R11,1
        JGEBS   TME060          :IF MORE TO MOVE
        AR      R4,R1
        SIS     R1,1
        LR      R10,R14
        J       TME035          :START AGAIN FOR NEXT MSG

TME070  STH     R4,HOPMS,,      :SAVE NEW END OF TABLE
TME080  SIS     R15,1
        JGE     TME010

:       NOW ADD NEW MSG (IF ANY)
        CLHI    R0,0D           :CR WITHOUT MSG DELIMITER?
        JE      TOMEXI          :IF NO MSG
        LR      R15,R0          :SAVE DELIMITER
        LHL     R14,HOPMS,,     :POINTER TO AREA FOR MSG
        LHI     R2,NSORDS-1
TME090  TBT     R2,TOMRI
        JEFS    TME100          :IF NOT REQUESTED
        STH     R14,HOPMSP,R2,R2        :SAVE PTR TO MSG
TME100  SIS     R2,1
        JGEBS   TME090          :IF MORE
        LIS     R2,1
        STB     R2,HOPMS,R14,   :INIT WITH A NULL MESSAGE
        AIS     R14,1
        LHI     R2,20           :BLANK
        STB     R2,HOPMS,R14,
TME110  JAL     R4,GCTOM        :GET MSG CHAR
        NHI     R0,7F
        JNFS    TME120          :IF NOT ESCAPE
        JAL     R4,GCTOM        :GET ESCAPED CHAR
        LR      R0,R0           :NULL?
        JEBS    TME110          :IGNORE NULLS
        J       TOMZAP          :ZAP IF ANYTHING ELSE

TME120  CR      R0,R15          :END OF MESSAGE DELIMITER?
        JE      TME140          :IF YES
        AIS     R14,1
        CLHI    R0,0D           :CR?
        JNFS    TME130          :IF NOT
        STB     R0,HOPMS,R14,   :SAVE CR
        LIS     R0,0A           :GET LINEFEED
        AIS     R14,1
TME130  CLHI    R14,HOPM.L+2
        JGE     TME200          :IF OVERFLOW
        STB     R0,HOPMS,R14,           :SAVE CHAR
        CLHI    R0,TM.ETX
        JN      TME110          :IF NOT END OF TEXT
      	SIS     R14,1
	STH     R14,TOMPWD+8    :SAVE MSG PTR
        STH     R15,TOMPWD+0A   :SAVE DELIMIETER
        JAL     R7,TOMWAIT      :WAIT FOR MORE
        LHL     R14,TOMPWD+8
        LHL     R15,TOMPWD+0A
        J       TME110          :CONTINUE

:       END OF MSG
TME140  LHL     R15,HOPMS,,     :GET START OF MSG
        LR      R2,R14          :END OF MSG
        SR      R2,R15
        CLHI    R2,CM.FST
        JG      TME205          :IF TOO LONG
        STB     R2,HOPMS,R15,   :SAVE LENGTH AS 1ST CHAR
        AIS     R14,1
        STH     R14,HOPMS,,     :SAVE NEW PTR
        J       TOMEXI          :DONE

:       MESSAGE OVERFLOW
TME200  LA      R5,NMRMSG,,     :NO MORE ROOM
	JFS	TME210
TME205	LA	R5,TLGMSG,,
TME210	JAL     R6,PMSTOM
	LHI     R2,NSORDS-1
        LHL     R4,HOPMS,,
        LIS     R5,0
TME220  LHL     R3,HOPMSP,R2,R2
        CLHI    R3,R4
        JNFS    TME230          :IF NOT THIS MSG
        STH     R5,HOPMSP,R2,R2
TME230  SIS     R2,1
        JGEBS   TME220
        J       TOMEXI


: TOMPA - PASSWORD OLDPW
:         ENTER PASSWORD: NEWPW
:         AGAIN: NEWPW

:       HERE FOR NULL PW
TPANPW  LH      R6,TOMPWD
        JN      TOMERR
        JFS     TPA010          :CONTINUE

TOMPA   J       TPANPW          :PROCESS NULL PW
        LIS     R6,0
        JAL     R7,TOMCPW       :CHECK PW
TPA010  JAL     R4,GCTOM        :GET ETX
        LA      R5,EPWMSG,,     :"ENTER PW"
        JAL     R6,PMSTOM       :REQUEST PW
        JAL     R7,TOMWAIT      :WAIT FOR RESPONSE

:       RETURN HERE FOR NEW PW
        LIS     R15,0
        ST      R15,TOMPWD+8    :CLEAR SCRATCH AREA
        ST      R15,TOMPWD+0C   :DITTO

TPA060  JAL     R5,GNC          :GET NEXT CHARACTER
        CLHI    R0,0D           :CR?
        JEFS    TPA070          :IF DONE
        STB     R0,TOMPWD+8,R15 :SAVE IT
        AIS     R15,1
        CLHI    R15,8           :GOT 7?
        JLBS    TPA060          :IF NOT OVERFLOWED
        J       TOMERR          :MORE THAN 7 CHARACTERS

TPA070  JAL     R4,GCTOM        :GET ETX
        LA      R5,APWMSG,,
        JAL     R6,PMSTOM       :"AGAIN:"
        JAL     R7,TOMWAIT      :WAIT FOR RESPONSE

:       RETURN HERE FOR NEW PW DOUBLE CHECK
        LIS     R6,8
        JAL     R7,TOMCPW       :CHECK PW
        L       R5,TOMPWD+8     :COPY OVER OLD PW
        ST      R5,TOMPWD
        L       R5,TOMPWD+0C
        ST      R5,TOMPWD+4
        J       TOMEXI          :DONE


: TOMRA - RADIX HEXIDECIMAL
:         RADIX DECIMAL
:         RADIX OCTAL

TOMRA   J       TOMERR  	:NO PARAM IS ILL
        JAL     R5,GNC          :GET NEXT CHAR
        LIS     R5,$8 10
        CLHI    R0,4F           :OCTAL?
        JEFS    TRA010          :IF YES
        LIS     R5,$A 10
        CLHI    R0,44           :DECIMAL?
        JEFS    TRA010          :IF YES
        LHI     R5,$0 10
        CLHI    R0,48           :HEX?
        JEFS    TRA010          :IF YES
        J       TOMERR          :ERROR

TRA010  STB     R5,TOMRAD       :SAVE RADIX
        STB     R5,TOMRAD+1-TOMPIX,RHP  :UPDATE DEFAULT VALUE
        J       TOMEXI          :DONE


: TOMSH - SHUT SORDS RI
:         SHUT PORTS RI
:         SHUT HOSTS RI

TOMSH   J       TOMERR          :NO PARAMETER IS ILLEGAL
        JAL     R5,GNC          :GET NEXT CHAR
        CLHI    R0,53           :S?
        JN      TSH020          :IF NOT SORDS

:       SHUT SORDS RI
        SKPMRK(TN.SOR+1,NSORDS,TOMRI)
        LHI     R2,(NSGRP-1)*2  :SORD GROUP #
TSH010  LH      R3,TOMRI,R2
        LCS     R4,1
        XR      R4,R3           :GET COMPLEMENT OF RI
        OH      R3,SSHUT,R2
        STH     R3,SSHUT,R2     :SET SHUT FOR REQUESTED SORDS
        NH      R4,SDOWN,R2
        STH     R4,SDOWN,R2     :CLEAR DOWN FOR THOSE SORDS
        SIS     R2,2
        JGEBS   TSH010          :IF MORE TO DO
        J       TOMEXI          :DONE

:       SHUT PORTS RI
TSH020  CLHI    R0,50           :P?
        JN      TSH040          :IF NOT PORTS
        SKPMRK(TN.POR+1,NNTMPT,TOMRI)
        LIS     R2,(NNTMGP-1)*2
TSH030  LH      R3,TOMRI,R2
        LCS     R4,1
        XR      R4,R3           :GET COMPLEMENT OF RI
        OH      R3,PSHUT,R2
        STH     R3,PSHUT,R2     :SET SHUT FOR REQUESTED PORTS
	LR	R5,R4
        NH      R4,PDOWN,R2
        STH     R4,PDOWN,R2     :CLEAR DOWN FOR THOSE PORTS
	NH	R5,TDROP,R2
	STH	R5,TDROP,R2	:CLEAR PORT DROPPER
        SIS     R2,2
        JGE     TSH030          :IF MORE
        J       TOMEXI          :DONE

:       SHUT HOSTS RI
TSH040  LIS     R12,2           :SET SHUT
        J       TOMCHS          :CHANGE HOST STATUS


: TOMSP - SPEED N PORTS RI
:	  SPEED BAUDOT PORTS RI
:         SPEED FULL PORTS RI

TOMSP   J       TOMERR          :NULL NOT ALLOWED
        JAL     R5,GNC          :GET SPEED INDEX
	CLHI	R0,42		:B?
	JNFS	TSP005		:IF NOT BAUDOT
	LA	R7,TN.AUD,,
	LHI	R12,SB-2000	:SET INDEX TO BAUDOT
	JFS	TSP007
TSP005  CLHI    R0,46           :F?
        JNFS    TSP010          :IF NOT FULL
        LA      R7,TN.ULL,,
        LHI     R12,SF-2000 	:SET INDEX TO FULL
TSP007  JAL     R6,SPN          :SKIP FULL
        J       TSP020          :SETUP INDEX

:       GET SPEED INDEX
TSP010  JAL     R6,CAB          :CONVERT # TO BINARY
        J       TOMERR          :IF BAD NUMBER
        CLHI    R7,MAXSPD
        JG      TOMERR          :IF SPEED NOT IN RANGE
        LR      R12,R7

:       GET PORT NUMBER RANGE
TSP020  CLHI    R0,50           :P?
        JN      TOMERR          :IF NO PORTS
        SKPMRK(TN.POR+1,NNTMPT,TOMRI)   :MARK RANGE
        LIS     R2,0
TSP030  TBT     R2,TOMRI
        JE      TSP040          :IF NOT THIS PORT
  IF	NAPORT
   IF	NMPORT
	TBT	R2,SIOP,,
	JNFS	TSP035		:IF SIO PORT
   EI
	CLHI	R12,SF-2000
	JEFS	TSP035		:IF VARIABLE SPEED
	CLHI	R12,SB-2000
	JE	TOMERR		:IF BAUDOT
	TBT	R12,A.SPED,,
	JE	TOMERR		:IF SPEED NOT SUPPORTED ON THIS NODE
  EI
TSP035	STB     R12,PSPEED,R2,  :SAVE SPEED INDEX
TSP040  AIS     R2,1
	CLHI	R2,NNTMPT
        JL      TSP030          :IF MORE PORTS
        J       TOMEXI          :DONE

: TOMST - STATUS [ FULL ] SORDS RI
:         STATUS [ FULL ] PORTS RI
:         STATUS [ FULL ] HOSTS RI
:         STATUS MESSAGES RI

TOMST   J       TSTFSN          :NULL IS SAME AS STATUS FULL HOSTS
        LIS     R12,0           :CLEAR FULL FLAG
        JAL     R5,GNC          :GET NONBLANK CHARACTER
        CLHI    R0,46           :F?
        JNFS    TST010          :IF NOT FULL
        LIS     R12,1           :SET FULL FLAG
        LA      R7,TN.ULL,,
        JAL     R6,SPN          :SKIP PARAMETER NAME
TST010  CLHI    R0,53           :S?
        JN      TST100          :IF NOT SORDS
        SKPMRK(TN.SOR+1,NSORDS,TOMRI,MAR)
:       OUTPUT SORD HEADER
        LA      R5,SORHDR,,
        JAL     R6,PMSTOM
        LR      R12,R12         :FULL?
        JE      TST015          :IF NO
        LHI     R5,0A0AF        :BLANK /
        JAL     R6,PPTOM
        LA      R5,TN.POR,,     :"PORTS"
        LIS     R7,5            :MSG LENGTH
        JAL     R6,PMSTM1
TST015  LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM

:       OUTPUT SORD STATUS LINES
        LHI     R9,0            :SORD #
TST030  TBT     R9,TOMRI
        JE      TST095          :IF NOT THIS SORD
        OUTNUM(R9,4)            :OUTPUT SORD NUMBER

:       OUTPUT HOST
        LIS     R15,0
TST040  LH      R7,HNT,R15,     :HOST ORD
        JLFS    TST050          :IF END OF TABLE
        LH      R4,HNT+4,R15,   :SUBHOST ORD
        CR      R4,R9
        JEFS    TST060          :IF THIS SORD
        AIS     R15,HNTE.L
        JBS     TST040

TST050  LHI     R5,0BFBF                :?? (NO HOST)
        JAL     R6,PPTOM
        LHI     R5,8D8A         :CRLF
        JAL     R6,PPTOM
        J       TST090          :NEXT SORD

TST060  LIS     R8,$A 10        :ALWAYS DECIMAL FOR HOSTS
        LHL     R7,HOSTS,R7,R7  :GET ACTUAL HOST #
        JEBS    TST050          :IF NO HOST #
        OUTNUM(R7,6)            :OUTPUT HOST
        LB      R8,TOMRAD       :RESTORE RADIX

:       OUTPUT  STATUS
        LHI     R5,0A0A0                :BLANK BLANK
        JAL     R6,PPTOM
        LA      R5,TN.DOW,,
        TBT     R9,SDOWN
        JNFS    TST070          :IF DOWN
        LA      R5,TN.SHU,,
        TBT     R9,SSHUT
        JNFS    TST070          :IF SHUT
        LA      R5,TN.UP,,
TST070  LIS     R7,4            :MSG LENGTH
        JAL     R6,PMSTM1       :OUTPUT STATUS MSG
        LHI     R5,0A0A0        :BLANK BLANK
        JAL     R6,PPTOM
        JAL     R14,TSTOSN      :OUTPUT SORD NAME
        LR      R12,R12         :FULL STATUS?
        JEFS    TST090          :IF NOT
        LHI     R10,NHPGRP*2
        MHR     R10,R9          :SORDGROUPS*SORD=HPTS INDEX
        LI      R10,HPTS,R10
        LIS     R11,1           :FLAG INDENTED LINES
        JAL     R15,TSTOSP      :OUTPUT SHORT PORT STATUS
        LIS     R12,1           :RESTORE FULL STATUS FLAT
TST090  JAL     R7,TOMOBW       :WAIT FOR OUTPUT TO COMPLETE
TST095  AIS     R9,1
        CLHI    R9,NSORDS
        JL      TST030  	:IF NOT DONE
        J       TOMEXI          :DONE

:       PORT STATUS
TST100  CLHI    R0,50           :P?
        JN      TST200          :IF NOT PORTS
        SKPMRK(TN.POR+1,NNTMPT,TOMRI,MAR)
        LA      R10,TOMRI
        LIS     R11,0           :FLAG NO INDENTED LINES
        LR      R12,R12         :FULL STATUS?
        JNFS    TST110          :IF YES
        JAL     R15,TSTOSP      :OUTPUT SHORT PORT STATUS
        J       TOMEXI          :DONE

TST110  JAL     R12,TSTOFP      :OUTPUT FULL PORT STATUS
        J       TOMEXI          :DONE

:       MESSAGE STATUS
TST200  CLHI    R0,4D           :M?
        JN      TST300          :IF NOT MESSAGES
        SKPMRK(TN.MES+1,NSORDS,TOMRI,MAR)
        LIS     R10,0
TST210  TBT     R10,TOMRI
        JNFS    TST230          :IF REQUESTED
TST220  AIS     R10,1
        CLHI    R10,NSORDS
        JLBS    TST210          :IF MORE
        J       TOMEXI

TST230  LHL     R11,HOPMSP,R10,R10
        JEBS    TST220          :IF NO MSG
        LA      R5,TN.SOR,,
        LIS     R7,5
        JAL     R6,PMSTM1       :"SORDS"
        LIS     R12,0
TST240  LHL     R1,HOPMSP,R12,R12
        CR      R1,R11
        JN      TST250          :IF THIS MSG NOT FOR THIS SORD
        OUTNUM(R12,4)           :OUTPUT SORD #
        RBT     R12,TOMRI       :BUT NOT LATER ALSO
TST250  AIS     R12,1
        CLHI    R12,NSORDS
        JL      TST240          :IF MORE
        LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM
	JAL	R7,TOMOBW	:WAIT FOR OUTPUT TO COMPLETE
        LI      R5,HOPMS,R11    :ADDRESS OF MSG
	LB	R7,0,R5		:GET MSG LENGTH
	AIS	R5,1
	CLHI	R7,70		:SEE IF TOO LONG FOR ONE OUTPUT
	JL	TST260		:BR IF NOT
	LHI	R7,70
	JAL	R6,PMSTM1	:OUTPUT 1ST PART OF MSG
	JAL	R7,TOMOBW	:WAIT FOR OUTPUT TO COMPLETE
	LI	R5,HOPMS,R11	:ADDR OF MSG AGAIN
	LB	R7,0,R5		:LENGTH AGAIN
	SHI	R7,70		:LENGTH OF REST OF MSG
	AHI	R5,71		:STRT OF REST OF MSG
TST260	JAL     R6,PMSTM1	:OUTPUT MSG
        LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM
        JAL     R7,TOMOBW       :WAIT FOR OUTPUT TO COMPLETE
        J       TST220          :NEXT


:       HOST STATUS

	SEG	A.DATA
TSTTSV	HS	1		:HOST NMBR TERMINATOR SAVE AREA
TSTSAV	WS	2		:REG SAVE AREA
TSTTEM	HC	-1	
	SEG	A.CODE

:       HERE FOR NULL STATUS (STATUS<CR>)
TSTFSN  LIS     R12,1           :MARK FULL STATUS
        LIS     R14,0           :POINT TO START OF HNT
        JFS     TST295

:	HERE TO CHECK FOR A NULL HOST LIST.
TST290  LR      R14,R14         :NULL LIST?
        JL      TOMERR          :IF LIST CONTAINED COMMA WITH NOTHING FOLLOWING
        CLHI    R0,0D           :CR?
        JN      TOMERR          :IF NOT CR
:       HERE FOR STATUS ON ALL HOSTS.
TST295  LH      R7,HNT,,        :GET FIRST HOST ORD
        LHL     R7,HOSTS,R7,R7  :GET HOST #
        J       TST315

:       HERE FOR STATUS [FULL] HOSTS RI
TST300  LIS     R14,0           :FLAG NO HOST LIST SEEN
        CLHI    R0,48           :H?
        JN      TOMERR          :IF NOT HOSTS
        LR      R12,R12
        JNFS    TST305          :IF FULL STATUS
        LA      R5,HOSHDR,,
        LHI     R7,HHDR.L       :HOST HDR LENGTH FOR SHORT STATUS
        JAL     R6,PMSTOM       :OUTPUT SHORT HOST STATUS HEADER
TST305  LA      R7,TN.HOS+1,,
        JAL     R6,SPN          :SKIP PARAMETER NAME
:       GET NEXT HOST # IN LIST.
TST310  LIS     R8,$A 10        :RADIX ALWAYS DECIMAL FOR HOSTS
        JAL     R6,CAB          :CONVERT ASCII TO BINARY
        J       TST290          :CONVERSION ERROR
        LCS     R14,1           :FLAG HOST LIST SEEN
TST315  STH	R0,TSTTSV	:SAVE TERMINATOR
TST318  LR      R15,R7          :SAVE HOST
        LR      R12,R12         :FULL STATUS?
        JEFS    TST319          :IF NOT
        LA      R5,HOSHDR,,
        JAL     R6,PMSTOM       :OUTPUT HEADER
TST319  LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM
        LIS     R8,$A 10        :HOST NUMBERS ARE ALWAYS DECIMAL
        OUTNUM(R15,5)           :OUTPUT HOST
        LHI     R5,0A0A0        :BLANK BLANK
        JAL     R6,PPTOM

:       FIND # IN HOSTS TABLE
        LHI     R3,MAXHST-1
TST320  LHL     R2,HOSTS,R3,R3  :GET NEXT TABLE ENTRY
        CR      R2,R15
        JEFS    TST321          :IF FOUND
        SIS     R3,1
        JGEBS   TST320          :MORE TO GO
        LHI     R5,0BFBF        :??
        JAL     R6,PPTOM
        J       TST392          :GET NEXT HOST

TST321  LR      R10,R3          :GET HOST #
	STH	R10,TSTHST	:SAVE IT
        LA      R5,TN.DOW,,
        LIS     R2,1
        TBT     R2,PORTS,R10,R10
        JNFS    TST324          :IF DOWN
        LA      R5,TN.SHU,,
        LIS     R2,0
        TBT     R2,PORTS,R10,R10
        JNFS    TST324          :IF SHUT
        LA      R5,TN.UP,,
TST324  LIS     R7,4
        JAL     R6,PMSTM1       :OUTPUT STATUS
        LHI     R5,0A0A0        :BLANK BLANK
        JAL     R6,PPTOM
	LR	R12,R12
	JE	TST328		:IF NOT FULL

:	OUTPUT HOST COST
TST325	HS
  IF HKEYN+1
	LHI	R5,8D8A		:CR LF
	JAL 	R6,PPTOM

	LHL	R15,TSTHST	:GET HOST ORDINAL
   	LHL	R11,HKEYTB,R15,R15  :GET HOST KEY
   	JE	TST326		:**2.06 - CAB - NSR 669 per Bryan Wing
	LA 	R5,HKYMSG,,	:HOST KEY =
	JAL	R6,PMSTOM
	OUTNUM(R11,3)
	LA	R5,ACTMSG,,	:PORTS ANSWERED =
	JAL	R6,PMSTOM
	LHL	R11,NPTSV,R15,R15
	OUTNUM(R11,3)
	LA	R5,CPSMSG,,	:AVERAGE CPS =
	JAL	R6,PMSTOM
	LR	R9,R15
	SLLS	R9,1
	L	R11,CHARSV,R9,R9
	OUTNUM(R11,8)
	LA	R5,HCTMSG,,	:HOST COST =
	JAL	R6,PMSTOM
	LHL	R11,HCOST,R15,R15
	OUTNUM(R11,2)
  EI
TST326	LHL	R6,TSTTEM	:**2.06 - CAB - NSR 669
	JE	TST390		:IF NOT FULL

TST328  LB      R8,TOMRAD       :GET CURRENT RADIX

:       FIND HOST IN HOST NUMBER TABLE
        LIS     R11,0           :SORD OUTPUT COUNTER
        LIS     R15,0           :HNT PTR
        LCS     R9,1            :INIT TO UNDEF SORD #
TST330  LH      R2,HNT,R15,     :GET HOST ORDINAL
        JL      TST380          :IF END OF TABLE
        CLH     R2,TSTHST
        JEFS    TST350
          :IF THIS HOST
TST340  AIS     R15,HNTE.L
        JBS     TST330

TST350  LR      R2,R9           :GET PREVIOUS SORD #
        LH      R9,HNT+4,R15,   :SORD #
        CR      R9,R2
        JEBS    TST340          :IF SAME SORD # AS LAST
        LR      R12,R12
        JE      TST354          :IF NOT FULL
        LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM
	JAL	R7,TOMOBW
        LHI     R5,0A0A0        :BLANK BLANK
        JAL     R6,PPTOM
        LIS     R7,4
        LA      R5,TN.SOR,,
        JAL     R6,PMSTM1
        LHI     R0,0A0
        JAL     R4,PCTOM
TST354  OUTNUM(R9,4)    	:OUTPUT SORD
        AIS     R11,1           :COUNT SORD
        LA      R5,TN.DOW,,
        TBT     R9,SDOWN
        JNFS    TST360          :IF DOWN
        LA      R5,TN.SHU,,
        TBT     R9,SSHUT
        JNFS    TST360          :IF SHUT
        LA      R5,TN.UP,,      :ELSE UP
TST360  LR      R12,R12         :FULL STATUS?
        JE      TST370          :IF NOT

:       FULL HOST STATUS
        LHI     R0,0A0          :BLANK
        JAL     R4,PCTOM
        LIS     R7,4
        JAL     R6,PMSTM1       :OUTPUT STATUS
        LHI     R0,0A0          :BLANK
        JAL     R4,PCTOM
	ST	R14,TSTSAV
        JAL     R14,TSTOSN      :OUTPUT SORD NAME
        LHI     R10,NHPGRP*2
        MHR     R10,R9          :SORDGROUP*SORD=SORD PORT TABLE INDEX
        LI      R10,HPTS,R10    :PORT ARRAY FOR THIS SORD
	ST	R15,TSTSAV+4
        JAL     R12,TSTOFP      :OUTPT FULL PORT STATUS
	LM	R14,TSTSAV
        J       TST330          :NEXT SORD

:       SHORT HOST STATUS
TST370  LIS     R7,1
        JAL     R6,PMSTM1       :OUTPUT STATUS
        CLHI    R11,0B
        JL      TST340          :IF NOT NEW LINE YET
        LHI     R5,8D8A         :CR LF
        JAL     R6,PPTOM
        LHI     R5,0A0A0        :BLANK BLANK
        JAL     R6,PPTOM
        JAL     R6,PPTOM
        LIS     R11,0
        J       TST340          :NEXT SORD

:       GETNEXT HOST
TST380	LR	R12,R12
	JN	TST390		:IF FULL
	LIS	R6,0
	STH	R6,TSTTEM
	J	TST325		:OUTPUT HOST COST FOR NON-FULL STATUS
TST390	LHI	R5,8D8A		:CR LF
	JAL	R6,PPTOM
TST392  LCS	R6,1		:RESTORE TSTTEM
	STH	R6,TSTTEM
	JAL     R7,TOMOBW       :WAIT FOR THIS TO OUTPUT
        LR      R14,R14
        JL      TST400          :IF A HOST LIST WAS SEEN
        LIS     R2,HNTE.L       :HOST NAME TABLE LENGTH
        LHL     R7,HNT,R14,     :LATEST POINTER INTO TABLE
TST395  LH      R3,HNT,R14,R2   :GET HOST ORDINAL
        JL      TOMEXI          :IF END OF TABLE
        CR      R3,R7
        JNFS    TST397          :IF NOT CURRENT HOST
        AIS     R2,HNTE.L
        JBS     TST395          :SKIP TO NEXT HOST

TST397  AR      R14,R2          :GET NEW TABLE POINTER
        LHL     R7,HOSTS,R3,R3  :GET HOST #
        J       TST318          :PROCESS THIS HOST

TST400  LHL	R0,TSTTSV	:GET SAVED TERMINATOR
        CLHI    R0,2C           :COMMA?
        JN      TOMEXI          :IF NO, DONE
        JAL     R5,GNC          :GET NONBLANK CHAR
        J       TST310          :NEXT HOST


: TOMTI - TIME

TOMTI   NOP
        LH      R6,TOMZON       :GET ZONE BIAS
        JAL     R4,GETTIM       :GET ASCII DATE
        LA      R5,TIMSC
        JAL     R6,PMSTOM       :OUTPUT TIME
        J       TOMEXI          :DONE


: TOMTO - TO RI "MSG"

TOMTO   J       TOMERR          :NULL PARAM NOT ALLOWED
        JAL     R5,GNC  	:GET NONBLANK CHAR
        LIS     R11,NTOMPT      :NUMBER OF TOM PORTS
        LA      R10,TOMRI
        JAL     R9,MNR          :MARK NUMBERS IN RANGE
        J       TOMERR          :BAD RANGE
        CLHI    R0,0D           :CR?
        JE      TOMERR          :IF NO MESSAGE
        LR      R9,R0           :SAVE DELIMITER
        LR      R10,R1          :SAVE BUFFER #
        LHI     R7,-TOMPIX,RHP	:BIAS PORT #
        LA      R5,TOMPWD+8     :SCRATCH AREA
        LIS     R4,2            :LENGTH OF OUTPUT AREA
        JAL     R6,CBA          :CONVERT BINARY TO ASCII
        LB      R0,TOMPWD+8     :GET FIRST CHAR OF PORT #
        JAL     R6,TOAT         :SEND TO ALL ACTIVE TOM USERS
        LB      R0,TOMPWD+9     :2ND CHAR
        JAL     R6,TOAT         :OUTPUT CHARS TO ALL USERS
        LHI     R0,0BE          :>
        JAL     R6,TOAT
TTO010  JAL     R6,TOAT         :OUTPUT IT
        LR      R1,R10          :RESTORE BUFFER #
TTO020  JAL     R4,GCTOM        :GET NEXT CHAR
        LR      R4,R0
        NHI     R4,7F           :REMOVE PARITY
        JNFS    TTO030          :IF NOT ESCAPE
        JAL     R4,GCTOM
        LR      R0,R0
        JEBS    TTO020          :IGNORE ESCAPED CHAR
        J       TOMZAP          :ZAP IF ANYTHING ELSE

TTO030  CLHI    R4,0D
        JE      TOMEXI          :IF CR
        CR      R4,R9           :END OF MSG DELIMITER?
        JN      TTO010          :IF NO, CONTINUE
        J       TOMEXI          :DONE


: TOMTY - TYPE RI PORTS RJ

TOMTY   J       TOMERR          :NO PARAMS IS ILLEGAL
        JAL     R5,GNC          :GET NONBLANK CHAR
        LA      R10,TOMRJ       :(NOT RI CUZ RJ TO SMALL FOR PORTS LATER)
        LHI     R11,MAXTYP+1    :NUMBER OF ALLOWED TERMINAL TYPES
        JAL     R9,MNR          :MARK NUMBERS IN RANGE
        J       TOMERR          :ILLEGAL NUMBER
        CLHI    R0,50           :P?
        JN      TOMERR          :IF NOT PORTS
        SKPMRK(TN.POR+1,NNTMPT,TOMRI)
        LHI     R2,MAXTYP*NHPGRP*2
        LHI     R3,MAXTYP
TTY010  LHI     R4,(NNTMGP-1)*2
        TBT     R3,TOMRJ        :THIS TYPE?
        JEFS    TTY025          :IF NO
TTY020  LH      R5,PTYPE,R2,R4  :GET OLD TYPE
        OH      R5,TOMRI,R4     :SET NEW VALUE
        STH     R5,PTYPE,R2,R4
        SIS     R4,2
        JGEBS   TTY020          :IF MORE TO DO
        JFS     TTY030

TTY025  LCS     R5,1
        XH      R5,TOMRI,R4
        NH      R5,PTYPE,R2,R4  :CLEAR OLD TYPES
        STH     R5,PTYPE,R2,R4
        SIS     R4,2
        JGEBS   TTY025
TTY030  SHI     R2,NHPGRP*2
        SIS     R3,1
        JGE     TTY010
        J       TOMEXI          :DONE


: TOMUP - UP SORDS RI
:         UP PORTS RI
:         UP HOSTS RI

TOMUP   J       TOMERR          :NO PARAMS IS ILLEGAL
        JAL     R5,GNC          :GET NEXT CHARACTER
        CLHI    R0,53           :S?
        JN      TUP020          :IF NOT SORDS

:       UP SORDS RI
        SKPMRK(TN.SOR+1,NSORDS,TOMRI)
        LHI     R2,(NSGRP-1)*2
TUP010  LCS     R3,1
        XH      R3,TOMRI,R2
        LR      R4,R3
        NH      R3,SSHUT,R2
        STH     R3,SSHUT,R2     :CLEAR SHUT FLAG
        NH      R4,SDOWN,R2
        STH     R4,SDOWN,R2     :CLEAR SHUT FLAG
        SIS     R2,2
        JGEBS   TUP010          :IF MORE
        J       TOMEXI          :DONE

:       UP PORTS RI
TUP020  CLHI    R0,50           :P?
        JN      TUP040          :IF NOT PORTS
        SKPMRK(TN.POR+1,NNTMPT,TOMRI)
        LIS     R2,(NNTMGP-1)*2
TUP030  LCS     R3,1
        XH      R3,TOMRI,R2
        LR      R4,R3
	LR	R5,R3
        NH      R3,PSHUT,R2
        STH     R3,PSHUT,R2     :CLEAR SHUT FLAG
        NH      R4,PDOWN,R2
        STH     R4,PDOWN,R2     :CLEAR DOWN FLAG
	NH	R5,TDROP,R2
	STH	R5,TDROP,R2	:CLEAR DROP FLAG
        SIS     R2,2
        JGE     TUP030          :IF MORE
        J       TOMEXI          :DONE

:       UP HOSTS RI
TUP040  LIS     R12,0           :SET HOST UP
        J       TOMCHS          :CHANGE HST STATUS


: TOMWH - WHO

TOMWH   NOP
        SIS     R1,2            :GET TOFIT BUFFER #
        LHI     R9,TOMPIX       :FIRST TOM PORT #
TWH010  TBT     R9,ACP          :ACTIVE?
        JE      TWH040          :IF NOT
        LA      R5,TOMPWD+8     :SCRATCH AREA
        LIS     R4,3            :FIELD SIZE
        LHI     R7,-TOMPIX,R9
        JAL     R6,CBA          :CONVERT BINARY TO ASCII
        LIS     R7,3
        JAL     R6,PMSTM1
        CH      R9,TOMLIC       :THIS PORT HAVE LICENSE?
        JNFS    TWH030          :IF NOT
        LHI     R0,4C           :L
        JAL     R4,PCTOM        :INDICATE LICENSE
TWH030  CR      R9,RHP          :THIS USER'S PORT?
        JNFS    TWH040          :IF NOT
        LHI     R0,2A           :*
        JAL     R4,PCTOM        :INDICATE USER'S PORT
TWH040  AIS     R9,1
        CLHI    R9,NHPORT               :MORE PORTS?
        JL      TWH010          :IF YES
        J       TOMEXI          :DONE


: TOMNT - NTRANSPARENT PORTS RI

TOMNT	J	TOMERR		:NO PARAMETER IS ILLEGAL
	SKPMRK(TN.POR,NNTMPT,TOMRI)

:       SET TRANSPARENCY OFF
	LHI	R2,(NNTMGP-1)*2
TNT010  LCS     R3,1
        XH      R3,TOMRI,R2     :COMPLEMENT RI
        NH      R3,TRANSP,R2	:SET BITS OFF
        STH     R3,TRANSP,R2
        SIS     R2,2
        JGEBS   TNT010          :IF MORE
        J       TOMEXI          :DONE


: TOMZO - ZONE N

TOMZO   J       TOMERR
        JAL     R5,GNC          :GET NONBLANK CHARACTER
        LCS     R9,1            :FLAG NEGATIVE BIAS
        CLHI    R0,2D           :MINUS?
        JEFS    TZO010          :IF NEGATIVE
        LIS     R9,0            :FLAG POSITIVE BIAS
        CLHI    R0,2B           :PLUS?
        JNFS    TZO020          :IF POSITIVE ASSUMED
TZO010  JAL     R5,GNC          :GET START OF NUMBER
TZO020  JAL     R6,CAB          :CONVERT ASCII TO BINARY
        J       TOMERR          :BAD CONVERSION
        XR      R7,R9           :1'S COMPLEMENT IF NEGITIVE
        SR      R7,R9           :NEGITIVE OF # OF - SEEN
        STH     R7,TOMZON       :SAVE ZONE BIAS
        J       TOMEXI          :DONE
	SUBTTL ACLIB2.206 - ASYNC TYMCOM LIBRARY 2 
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by  TYMNET, Incorporated.                                   **
: ******************************************************************
: **                   MODULE IDENTIFICATION                      **
: **                                                              **
: **  File Name          :  ACLIB2.206      last change: 12/20/85 **
: **                                                              **
: **  File Abstract      :  ACLIB2.206 includes 2 basic           **
: **			    ISIS libraries --			  **
: **								  **
: **			    PATCH.LIB - Original ISIS version 2   **
: **								  **
: **			    FINISH.LIB - Original ISIS version 2  **
: **								  **
: **  File Description   :  PATCH.LIB --                          **
: **			    This library defines symbols, macros  **
: **			    and areas used for patching released  **
: **			    code and keeping a history of patches **
: **			    in engine memory.                     **
: **			   					  **
: **			    FINISH.LIB --     This library will   **
: **		            enerate diagnostics if necessary,     **
: **			    and computes the value of the symbols **
: **			    SnSIZE (seg number, 0- E).	          **     
: **			    The CTA table is created including    **
: **			    the HOSTS, PORTS and PTABLE arrays.   **
: **			    Values are assigned to the symbols    **
: **			    CTA and CTASIZE.                      **
: **			    It will also type out the memory      **
: **			    requirements, and cause all undified  **
: **			    symbols to be listed on the control   **
: **			    terminal.                             **
: **                                                              **
: ******************************************************************
: **                    CHANGE LOG                                **
: **                                                              **
: **  Ver   Date    By   PIR/NSR  Changes (most recent at top)    **
: ** ----- -------- ---  -------- ------------------------------- **
: ** 2.06  12/20/85 OJ             Add proprietary banner         **
: **								  **
: **   "      "     OJ	  	   Add PATCH.LIB                  **
: **                                                              **
: ******************************************************************
	SUBTTL PATCH AREA DEFINITIONS

	RA	0		:	PATCH.LIB

:	This library defines symbols, macros and areas used for patching
:	released code and keeping a history of patches in Engine memory.

:	A file containing the actual patches to the code should be
:	assembled as the last file before saving the NIB file.

:	Patches are added by ORGing to the area to patch,
:	zeroing memory for the length of the patch, writing new
:	code starting at that area.
:	Three macros have been defined to do this.
:	Each patch should start with a PATCH macro and if the
:	patch is for more than one area it should be continued
:	with a CONPATCH macro.  The patch should be ended with
:	an ENDPATCH macro.
:
:	Using these macros will cause the patch number, author
:	area patched, and reason for patch to be output during assembly.
:	Also, a history table starting at PATHIS will be created with
:	16 (10hex) byte entries.
:	Each entry will contain the date and time of patch and the author.
:	Also, the ?VERNO DDT command will indicate that patches are
:	installed by reporting a version biased by 100 octal.
:	For example, if the version is 1.13, ?VERNO will report 101.13.
:
:	If a patch must be temporarily added by hand, the
:	history area and the version (cell VERREV) should be updated.
:
:	The following symbols may be defined before assemply of PATCH.LIB.
:	If not defined they will take the default listed.
:
:	VERSION release version number, will be ORed with octal 100.
:		default: 00
:	VERREV	area in seg 0E which contains a one byte version and
:		a one byte revision.  Defined by FINISH.LIB.
:		default: none, symbol must be defined.
:	A.ERR	defines segment to use for patch history area
:		default: seg 0
:	PATHIS	defines the start of the patch history area,
:		each entry will be 16 bytes as follows,
:		19yy/mmdd/hhmm/uname(10 chars 0 filled)
:		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
:		digit) and uname is in ASCII.
:		default: an area will be defined by this library
:	PHSIZE defines the length in bytes of the PATHIS area.
:		default: 140 hex
:	PATCH0	defines the start of a Segment 0 patch area.
:		default: an area will be defined by this library
:	P0SIZE defines the length in bytes of the PATCH0 area.
:		default: 200 hex
:	PATCH1	defines the start of a code segment  patch area.
:		default: an area will be defined by this library
:	P1SIZE defines the length in bytes of the PATCH1 area.
:		default: 400 hex
:	SEGn,SnSIZE	Must be defined for the area being patched when
:		the patch is made.
:
:	The following symbols are used by the patch macros.
:	They may be read by, but should not be modified by, a patch.
:
:	PAHPTR	pointer to the next available entry in PATHIS
:	PA0PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH0 area.  It starts out
:		equal to PATCH0 and is moved up after each patch in
:		the PATCH0 area.  Use of the symbol assumes that all
:		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
:	PA1PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH1 area.  It starts out
:		equal to PATCH1 and is moved up after each patch in
:		the PATCH1 area.  Use of the symbol assumes that all
:		patches from PATCH1 to PATCH1+P0SIZE will be done in order.
:	QPATS	current patch segment number
:	QPATB	starting address of current patch
:	QPATL	length of current patch
:	QPATA	0 IF PATCH IS IN PATCH0 AREA, 1 IF IN PATCH1, ELSE -1
:	PATACT	> 0 if when a patch is active.



::	PATCH(yymmdd,hhmm,uname,fba,lba1,len)	grab a patch area
:
:		yymmdd	Date patch written, if patch is modified in ANY
:		way this must be updated.
:		hhmm	Time patch written, current Cupertino time.
:		If patch is modified this also must be updated.
:		uname	ONTYME username of person who authored patch.
:		Personal name, not NETMID or NET3 or such.
:	fba	adress of start of patch
:	lba1	address of next byte after end of patch
:	len	length (default hex) of patch in bytes if lba1 is missing
:
:	CONPATCH(fba,lba1,len)	continue a patch in a new area
:		Similar to PATCH but moves to a new area, must be
:		preceeded by a PATCH statement.
:
:	ENDPATCH(comment)	End a PATCH started with PATCH call.
:
:		comment	Description of patch to be output during
:			assembly.  Commas should be preceeded by `.
:
:	Example:
:	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
:	  IF	HDLC&(LAPB!LAP)
:	PATCH(811009,1422,FRED,XROOM,,2)
:		LIS	R4,7
:	ENDPATCH(fix hdlc room checking routine)
:	  EI
:
:	:	PATCH TO FIX TRANSMITER BUG
:	PATCH(811009,1630,DDM,XSEND,XSE010)
:	  IF	FINACT	:IF INTERFRAME FILL TIMER ENABLED
:		J	PA1PTR
:	  EI
:	PATRTN	LR	R6,RSIO
:		AHI	R6,OUTSCT,RSIP
:
:	CONPATCH(PA1PTR,,0C)
:		SBT	RL,FRMTMT,,	:INDICATE FRAME TRANSMITTED
:		JNR	R7		:IF ALREADY TRANSMITTED
:		J	PATRTN		:RETURN TO PATCHED AREA
:	ENDPATCH(fix transmitter bug)

	GL	VERSIO,VERREV,A.ERR,PATHIS,PHSIZE,PATCH0,P0SIZE,PATCH1,P1SIZE
	GL	PAHPTR,PA0PTR,PA1PTR,QPATS,QPATB,QPATL,QPATA,PATACT

:	FIRST DEFINE SOME MACROS
	GL	.35.
.35.	EQ	$A 35
	KILL	.NE.
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-.35.]
	KILL	.GT.
.GT.	MACRO(P1,P2)[((P2)-(P1))^-.35.]

:	NEXT DEFINE SOME DEFAULTS
  IF	1-\A.ERR
A.ERR	EQ	0
  EI
  IF	1-\PHSIZE
PHSIZE	EQ	140
  ELSE
PHSIZE	EQ	(PHSIZE+0F)/10*10
  EI
  IF	1-\P0SIZE
P0SIZE	EQ	200
  EI
  IF	1-\P1SIZE
P1SIZE	EQ	400
  EI
  IF	1-\PATHIS
	SEG	A.ERR
PATHIS	HS	PHSIZE/2
  EI
  IF	1-\PATCH0
	SEG	0
PATCH0	HS	P0SIZE/2
  EI
  IF	1-\PATCH1
	SEG	A.CODE
PATCH1	HS	P1SIZE/2
  EI

PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA
PA0PTR	EQ	PATCH0	:INIT PTR TO START OF AREA
PA1PTR	EQ	PATCH1	:INIT PTR TO START OF AREA
PATACT	EQ	0	:FLAG NO PATCH ACTIVE
QPATA	EQ	-1	:CLEAR PATCH AREA FLAG
QPATS	EQ	-1
QPATB	EQ	-1
QPATL	EQ	-1

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
  IF	\VERSION
VERSION EQ	VERSION!$8100
  ELSE
VERSION EQ	$8100
  EI
	SEG	0E
	ORG	VERREV
	BC	VERSION
	SEG	A.CODE
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	A.ERR
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	(lba1)-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	(.+1)-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK  overflow <<<<%
  EI
	ORG	QPATB

::	CONPAT(fba,lba1,len)	CONTINUE A PATCH
	KILL	CONPAT
CONPAT	MACRO(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	(clba1)-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	.-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK overflow <<<<$
  EI
	ORG	QPATB

::	ENDPATCH(com)	End a patch - does error checking, outputs comment
	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD CONPATCH(cfba,clba1,clen) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1````c2````c3````c4````c5 >>>
]
]

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD PATCH(day,tim,usr,fba,lba1,len) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1``c2``c3``c4``c5 >>>
]
]
        SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:                                                                     *
:       This program is the sole property and confidential            *
:       information of Tymshare, Inc., and may not be copied          *
:       in whole or in part or disclosed to any third party           *
:       without the prior written consent of Tymshare.                *
:                                                                     *
:**********************************************************************

	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	$A ($0S|Q|SIZE-10000);	REMARK	d bytes;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
    IF	\APROT0
	BC	APROT0	:SET AREA 0 PROTECTION
    ELSE
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	BC	6	:EXECUTION PROTECTED
    EI
    IF	\APROT1
	BC	APROT1	:SET AREA ONE PROTECTION
    ELSE
	BC	5	:WRITE PROTECTED
    EI
Q	EQ	2
	RE	0C
    IF	\APROT|Q|
	BC	APROT|Q|
    ELSE
	BC	6	:EXECUTION PROTECTED
    EI
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols
 h@