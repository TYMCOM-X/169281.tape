

	SUBTTL	ICL C03 Host Interface Debugging Switches
:
:		THIS FILE CONTAINS NECESSARY DEBUGGING SWITCHES.
:		THESE SWITCHES MAY ONLY BE TURNED ON BY MDCSC'S
:		QUALIFIED SUPPORTING AND DEVELOPMENT PERSONNEL.
:
:		WHEN THERE IS ANY OF THE SWITCHES TURNED ON, THIS FILE 
:		MAY BE INCLUDED IN THE COMMAND FILE TO GENERATE SLOT CODE.
:		OTHERWISE, THIS FILE MAY BE OMITTED FROM A COMMAND FILE.
:
	RA	0			:RADIX IS HEX
:
:DB.TRC EQ	1			:TURN JUMP TRACE ON
:DEBUG	EQ	1			:ENABLE 'DEBUG' SWITCH ON
:BTRACE EQ	1			:ENABLE BACKGROUND TRACE
	GL	FTRACE
FTRACE	EQ	1			:ENABLE FOREGROUND TRACE

:		DEFINE BIG BUFFERLET DEBUG SWITCHS

	GL	BBF.D1,BBF.D2,BBF.D3

BBF.D1 EQ	1			:BIG BUFFERLET DEBUG SWITCHES
BBF.D2 EQ	1			:BIG BUFFERLET DEBUG SWITCHES
BBF.D3 EQ	1			:BIG BUFFERLET DEBUG SWITCHES
	IF	\BBF.D3
	IF	BBF.D3
:BBF.D4 EQ	1			:BIG BUFFERLET DEBUG SWITCHES
	EI
	EI

	GL	RCVT01,RCVT02,RCVT03,RCVT04,RCVT05,RCVT12,RCVTSW
	GL	RCVTSZ,PTPTSW,RCVHRC,BUFTR
RCVT01	EQ	1			:TRACE RCV DATA BYTES
RCVT02	EQ	RCVT01^1		:TRACE RCV EMPTY RING INDEX
RCVT03	EQ	RCVT02^1		:TRACE PROCESS HANDLE BYTE
RCVT04	EQ	RCVT03^1		:TRACE STATE EXPECTING BYTE
RCVT05	EQ	RCVT04^1		:TRACE TIME BYTE HANDLED
RCVT12	EQ	800			:TRACE OPERATION COMPLETE RETURN CODE
RCVHRC	EQ	1			:KEEP HISTORY COUNT OF RETURM CODE
BUFTR	EQ	0			:TURN ON BUFFER TRACE LOGICAL
PTPTSW	EQ	1			:PROTOCOL TRACE ON
RCVTSZ	EQ	1			:KBSIZE OF TRACE BUFFER
RCVTSW	EQ	RCVT01+RCVT12+RCVTSZ^0C	:RCV TRACE SWITCH

	DEFVAR(FEXTRA,0)
	DEFVAR(RTMTRA,0)
	DEFVAR(XTMTRA,0)
	DEFVAR(OTMTRA,0)
	DEFVAR(ITMTRA,0)
	DEFVAR(ATMTRA,0)
	DEFVAR(STMTRA,0)
	
		EM

	SUBTTL	ICL C03 System Generation Parameters

:		THIS FILE CONTAINS THE SYSTEM GENERATION PARAMETERS
:		PRE-DECLARED GLOBAL VARIABLES FOR CERTAIN LIBRARIES

	RA	0

	GL	MAXDSZ,NBBFLT,BBFLSZ,BSCRBC,MSIZE,MNSPED
	GL	LSYNCS,TPADCS,NBILIN,NPGRP,PRODID
	GL	TYM1,CRSTOP,IRSIZE,ORSIZE,GCSBON,GCSDON,WTALPON
	GL	PID.HI,HID,NMODE,LMODE

:		KILL SYMBOLS 
	KILL	LINE,RTSCTS

:		DEFINE BUFFER PARAMETERS
:		------------------------

CMDLO	EQ	$A 10		:DANGER LEVEL FOR FREE CMD LIST
BUFLO	EQ	$A 15		:DANGER LEVEL FOR BUFFER FREE LIST

:		DEFINE CRASH CODE FOR ICL C03 INTERFACE

	GL	CRGSUB,CRXLST,CRSVCE,CRPRTE,CRPRVE
	GL	CRNGBC,CRINPE,CRNNBF,CRLONE,CRLFER

CRGSUB	EQ	55		:CRASH WHEN ACCESS GENERAL SUB
CRXLST	EQ	56		:CRASH WHEN XMT LIST TOO SMALL
CRSVCE	EQ	58		:CRASH WHEN ILLEGAL SVC CALL
CRPRTE	EQ	59		:CRASH WHEN PROTOCOL ERROR
CRPRVE	EQ	5A		:CRASH WHEN RECEIVE ERROR
CRLFER	EQ	5B		:CRASH WHEN LOGOFF TYPE ERROR

CRNGBC	EQ	60		:CRASH WHEN NO NEXT CHAIN BUFFER
CRINPE	EQ	61		:CRASH WHEN INPUT MSG FROM NET IS ERROR
CRNNBF	EQ	62		:CRASH WHEN NO NEXT BUFFER AVAILABLE
CRLONE	EQ	63		:CRASH WHEN LOGON ERROR COND.
CRNSSM	EQ	64		:CRASH WHEN NETWORK SERVICE SCREEN ERROR


:	Define some qualifiers for the Invitation-to-clear messages

ZQUIET	EQ	1		: There has not been a poll for this group
ZNODEV	EQ	2		: Attempt to connect to non-existent device
ZUSDEV	EQ	3		: Attempt to connect to a device already in use


:	Define Tx op codes

SNAK	EQ	1		: Nak is to be sent
SAK	EQ	2		: ACK is to be sent


:	Define codes for control commands from F.G. to B.G.

NOWBPC	EQ	-1		: F.G. has released enough to clear B.P.
BLKBAL	EQ	-2		: F.G. wishes to black ball this sub


:	Define initialisation values for subs

IZALST	EQ	0C1		: Inop, but AL is present
IZSPEC	EQ	40		: For devs 20 - 23, null HL  Changed 16/2/88


:	Define initialisation values for groups

IZFLOW	EQ	40
IZLLST	EQ	0C8		: LLHR is only bit of interest at start
IZGCST	EQ	40


:	Define bits in LLSTAT - Defined in 5.5.7

LDAVAL	EQ	0E		: Data available
LGCSPR	EQ	0D		: GCS stat is present in HL stat
LLHR	EQ	0C		: Link level has reset
LHFAIL	EQ	0B		: HL failure
LSEQR	EQ	0A		: Link level Sequence error


:	Define bits in GCSTAT - Defined in 6.4.1.1

GSNOTP	EQ	0F		: Subsidiary not present
GBNGCS	EQ	0C		: BNA for this group


:	Define bits in ALSTAT - Defined in 7.4

AINOP	EQ	0F		: Sub (temporarily) not present
ADAVAL	EQ	0E		: Data available on sub
ABNA	EQ	0C		: BNA for this sub - may be due to B.P.
AHERE	EQ	09		: Says AL stat is supplied e.g 6.4.3.d

:	Define bits in GRPFLG 

TOGGLE	EQ	0		: Toggle used to detect out-of-seq blks
LLHRST	EQ	1		: FLag says LLHR has been sent to host
IALPST	EQ	2		: Flag says Inbound ALP started
GBNA	EQ	3		: Flag says we can set bna for GCS
SBNA	EQ	4		: Flag says each sub can set bna
GBSENT	EQ	5		: Flag says we have sent GCS bna
GBCLR	EQ	6		: FLag says we are to clear GCS bna
OALPST	EQ	7		: Flag says Outbound ALP started
GR3RES	EQ	8		: Flag says weve got a G.Reset 3
GHANG	EQ	9		: Flag says this group is hung
GDEF	EQ	0A		: Flag says inactive group will ignore host

:	Define bits in SUBFLG

AKINOP	EQ	0		: If set, weve just sent dev inop
GR3LOK	EQ	1		: If set, doing a G Reset on this sub

	:	Define bits in DFLAGS in the DCB

WALACK	EQ	0		: This device waits for AL ack from n/w
SRCFLG	EQ	1		: If set, data to go onto cat n
ALCOMP	EQ	2		: If set, last ALP is complete on q
FRCOMP	EQ	3		: If set, last fragment is complete on q
DOALND	EQ	4		: 

:	Define useful C03 constants

GSSADD	EQ	020		: Address of GSS
GRES1	EQ	038		: Group Reset 1 command
GRES2	EQ	039		: Group Reset 2
ALRES	EQ	039		: Access Level Reset
GRES3	EQ	03A		: Group Reset 3
ASTCAT	EQ	03C		: Assign traffic categories
XBIT	EQ	02		: bit position in h/w for toggle bit
WBIT	EQ	01		: bit position in h/w for W - Alpcomplete


:
:	Define some defaults if they are not already specified by the user.

	DEFVAR(IRSIZE,$A 4092)
	DEFVAR(ORSIZE,$A 4092)
	DEFVAR(CRSTOP,1)
	DEFVAR(GCSBON,1)
	DEFVAR(GCSDON,0)
	DEFVAR(SUBBON,1)
	DEFVAR(WTALPON,1)
	DEFVAR(BPNWON,1)
	DEFVAR(TYM1,0)
	DEFVAR(MAXDSZ,$A 256)
	DEFVAR(BBFLSZ,$A 128)
	DEFVAR(BSCRBC,MAXDSZ/(BBFLSZ-2)+1)	: Max # of receive bufferlets
	DEFVAR(P0SIZE,40)			: # of H/Ws for seg. 0 patchs
	DEFVAR(P1SIZE,120)			: # of H/Ws for seg. 1 patchs
	DEFVAR(OBMAX,$A 4092)			: limit before sub BNA
	DEFVAR(IBMAX,$A 4092)			: max # of chars inbound
	DEFVAR(GOBMAX,$A 4092)			: limit before GCS BNA




:		DEFINE MORE PARAMETERS
:		----------------------

	GL	RCVREV
NBILIN	EQ	NSLINE
NPGRP	EQ	NGRPS
MSIZE	EQ	08		:AMOUNT TO LIE TO SCAN ABOUT INPUT
MNSPED	EQ	$A 1200		:MINIMUM SPEED SYNC LINE SUPPORTED (BPS)
RCVREV	EQ	1		:RCV LOGICAL WILL REVERSE CHARS
LSYNCS	EQ	3		:LEADING SYN CHARS BEFORE MSG
TPADCS	EQ	8		:TRAILING PAD CHARS AFTER MSG

	DEFVAR(POLT3,$A 90)	:Time-out for polls/response to polls
HID	EQ	4		:HOST ID FOR IIX
NTOUT	EQ	$A 2
CNTRL	EQ	1C		:CONTROL (TELL SLOT ABOUT TAKE OVER)
IDMODE	EQ	0		:IDLE MODE
NMODE	EQ	1		:NATIVE MODE
AMODE	EQ	2		:ASCII MODE
LMODE	EQ	3		:LOGON MODE
PID.HI	EQ	58		:HOST INTERFACE PROTOCOL ID


:		DEFINE DEFAULT DEBUGGING SWITCHES

	DEFVAR(DB.TRC,0)
	DEFVAR(DEBUG,0)		: Disable debug
	DEFVAR(BTRACE,0)	: Disable background trace
	DEFVAR(FTRACE,0)	: Disable foreground trace

:		DEFINE NPORT, NPORTT ETC
:
	GL	NPORT,MAXPRT

	IF	NSUBS-(NGRPS*4)-255
MAXPRT	EQ	255
	ELSE
MAXPRT	EQ	NSUBS-(NGRPS*4)
	EI


	GL	NGRP,NGSUB
NPORT	EQ	MAXPRT+1
NPORTT	EQ	NPORT
NGSUB	EQ	(NSUBS-1)/$010+1


	GL	NCMDLK
:
:THE FOLLOWING COMPUTES THE NUMBER OF BIG BUFFERLETS ASSIGNED
:AND MAY NEED REDEFINING IN THE FUTURE
:
:	We only need to allocate buffers for those subsidiaries which
:	can accept data in either direction. This means we can exclude
:	the reserved subsidiaries 21 - 23 for each group.

NRSBS	EQ	NSUBS-(NGRPS*3)



:	For each subsidiary, we need to allocate 2 sets of buffers, one
:	depending on the limit before we issue bna for subsidiary, and 
:	the other depending on the size of the IRING. We also need to
:	allocate a few for the line driving.

INREQ	EQ NRSBS*((IRSIZE/2)/BBFLSZ)
NBBFLT	EQ (NRSBS*((OBMAX+BBFLSZ)/BBFLSZ))+INREQ+(NBILIN*$A4)


:	If the GCS BNA mechanism has been enabled, we may be able to
:	reduce the number of buffers neccessary.

	IF	GCSBON
TRGRP	EQ	(NGRPS*((GOBMAX+BBFLSZ)/BBFLSZ))+INREQ+(NBILIN*$A4)

	IF	NBBFLT-TRGRP 
NBBFLT	EQ	TRGRP
	EI

	EI

:	The segment used for buffers is also used for the xmt lists.
:	So we need to see how much we can use after we take this into
:	account. We cannot exceed this segment, since the XMT svc will
:	not work across segment boundaries.

BFORXM	EQ	((NBILIN*$A88)+$A50+BBFLSZ)/BBFLSZ

	IF	NBBFLT-(10000/BBFLSZ)-BFORXM
NBBFLT	EQ	(10000/BBFLSZ)-BFORXM-1
	EI


NCMDLK	EQ	(NBBFLT+2)*2	:NUMBER OF COMMAND LINKS
 
:
:
:		IF FWBBF IS UNDEFINED, SET AUTOMATICALLY IF NEEDED.
	IF	\FWBBF
	IF	NBBFLT*BBFLSZ-0FFFF
Q		EQ	1
	ELSE
Q		EQ	0
	EI	(NBBFLT*BBFLSZ-0FFFF)
	IF	(FWBBF-Q)&1
	REMARK %***	FWBBF NOT CORRECTLY DEFINED !!!!!
	EI	(FWBBF-Q)
	ELSE
	IF	NBBFLT*BBFLSZ-0FFFF
	GL	FWBBF,ORGBUF
FWBBF	EQ	0
NBBFLT	EQ	10000/BBFLSZ-1
	REMARK %*** MAXIMUM BUFFERLET SPACE OF 64K BYTES ALLOCATED ***
ORGBUF	EQ	A.BUFF
	ELSE
	GL	FWBBF,ORGBUF
FWBBF	EQ	0
ORGBUF	EQ	A.BUFF
	EI	(NBBFLT*BBFLSZ-0FFFF)
	EI	(\FWBBF)

:		MAKE SURE BUFFER SPACE NOT OVERFLOW INTO SEG 14


	IF	(NBBFLT*BBFLSZ-0E0000)
REMARK	%***	BUFFER SPACE REQUIRED IS TOO LARGE AND OVERFLOW INTO SEG. 
14 !!!
	EI

	DEFVAR(DCSET,NBBFLT/MAXPRT*BBFLSZ/2)	: Set B.P when 50% quota used
	DEFVAR(DCREL,NBBFLT/MAXPRT*BBFLSZ/4)	: Release B.P when 25% used


:
:
:		DEFINE DEFAULT TIMOUT PARAMETERS FOR STATE CONTROL MODULE
	MO	.,C03BLK
	LO	MAIN


	RA	0

:		OPTIONAL LINE PARAMETERS

Q		EQ	0
	RE	NBILIN
SS	EQ	$A Q
BLUN|SS|	EQ	Q
	IF	\SDTR|SS|
SQ	EQ	SDTR|SS|
	ELSE
SQ	EQ	1			:IF NOT DEFINE, DEFLAUT 1
	EI
	KILL	SDTR|SS|
SDTR|SS|	EQ	SQ
	IF	\SRTS|SS|
SQ	EQ	SRTS|SS|
	ELSE
SQ	EQ	0			:IF NOT DEFINE, DEFAULT 0
	EI
	KILL	SRTS|SS|
SRTS|SS|	EQ	SQ


Q		EQ	Q+1
	ER

	EM



	SUBTTL	ISIS Assembly Switch Definitions	- START.LIB
:******************************************************************
:
:*******************************************************************

	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	05;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82	MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82	MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02	12/08/81	MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01	01/08/81	MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	number of bytes to provide for input ring, from dispatcher
:	ORSIZE	number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing	realtime fast clock
:	SLOWC	word containing	realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART	user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
	IF	\A.DATA
	ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
	EI

	IF	\A.CODE
	ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
	EI

	IF	\A.BDAT
	ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
	EI

	IF	\A.RING
	ELSE
A.RING	EQ	2	:DEFAULT RING AREA
	EI

	IF	\A.BUFF
	ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
	EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother  input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

	IF	\MAXPRT
	ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
	EI

	IF	\MAXHST
	ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
	EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
	IF	\SEG|Q|
	GL	SEG|Q|
	ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
	EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI


	SUBTTL	Engine hardware trace trapping routine
:	**** REVISION HISTORY ****
:	ORIGINAL DESIGN AND CODE -- BY NELSON SU
:	29-JUN-83 (RNC) -STANDARDIZE Revision History (NO SAR#)
:	JUNE 24, 1983 -- BY NELSON SU, ADD 'Revision History'

	RA	0		:	TRACE.LIB

:	This file provides the necessary backbone for using the TYMNET-ENGINE
:	harware-trace feature. It should be assembled IMMEDIATELY AFTER the
:	START.LIB file. The file may be assembled directly from the library
:	version, in which case it is necessary to patch the appropriate test
:	into the assembled code, OR it may be copied and the test hard-coded.

	GL	ENTRY,CRASH	:TWO LIKELY CANDIDATES FOR SYMBOLS REQUIRED

	MO	.,TRACE
	SEG	A.DATA		:IN SEGMENT 0
	ORG	10		:AT LOCATION 10
TRPSD		WC	1000,ENTRY	:FORCE A TRANSFER TO "ENTRY"
	WC	TRACE			:ON TRAP, GO TO "TRACE"
TRSAVE	HS	22		:USEFUL AREA TO SAVE REGS, ETC
TRINDX	WC	TRING		:INDEX TO TRACE RING
TRING	WS	20		:TRACE RING
TRCHK	WS	1		:TRACE CHECK ON 300D6

	SEG	A.CODE		:IN CODE AREA
TRACE	HS	0		:ENTRY TO TRACE LOGIC
	STM	R10,TRSAVE+4	:SAVE REGISTERS
	L	R10,TRINDX	:GET TRACE RING INDEX
	CLI	R10,TRING+80	:CHECK IF OUTSIDE RING
	JLFS	TRACE2		:IF NOT ,JUMP
	LHI	R10,TRING	:GO TO BEGINNING OF RING
TRACE2	L	R11,TRPSD+4	:GET ADDRESS WE JUST JUMPED TO
	ST	R11,0,R10	:STORE IT IN RING
	AIS	R10,4		:ADVANCE RING INDEX
	ST	R10,TRINDX	:STORE NEW RING INDEX
:
TRACE3	J	TROUT		:EXIT TRACE
	HS	40		:ADDITIONAL AREA TO PATCH REQUIRED TEST
:
TROUT	LM	R10,TRSAVE+4	:RESTORE REGISTERS
	UPSW	TRPSD		:INSTRUCTION TO RE-ENABLE TRACE

:	TRANSFER TO HERE TO TURN ON TRACE INITIALLY
TRBGN	UPSW	IPSD		:THIS WILL TAKE US TO "ENTRY" WITH TRACE ON
IPSD	WC	1000,ENTRY	:TRACE BIT ON, GO TO "ENTRY"
	EM


	SUBTTL	ISIS Ring Handling Routines	- FRING.LIB
	RA	0			:		FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.	Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.	If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines. All link on R4, & preserve R1-R3, R5-R13, R15
:
:	LOOK	Det exists...an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.	The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.	An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.	An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.	R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.	"Ends" current message, sets
:		up pointers for next message.

:	Primitive output routines.	All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in 
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.	Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.	Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.	Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:		DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:		THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:		THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING


:		CODE AREA			

	SEG	A.CODE
:		INPUT ROUTINES

:		LOOK AT A RING ENTRY
:		NORMAL RETURN IF RING EMPTY
:		ELSE SKIP RETURN, PORT RETURNED IN R1
:		MESSAGE TYPE RETURNED IN R2
:		ALL REGISTERS SET UP FOR TRANSFER
:		POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	HS	0;
	ELSE
LOOK	HS	0
	EI
	LHL	R14,CEI+IRING,, :GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,		:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,		:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:		GET A CHARACTER FROM THE INPUT RING
:		CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,		:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:		GET A HALF-WORD FROM THE INPUT RING
:		ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:		HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,		:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:		GET A WORD FROM THE INPUT RING
:		ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:		WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,		:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:		FLUSH AN INPUT RECORD
:		NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:		END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:		OUTPUT ROUTINES

:		OUTPUT "CANNED" MESSAGE
:		LINK ON R5
:		R2 = PORT #
:		R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:		OUTPUT "CANNED" STRING
:		LINK ON R5
:		R2 = PORT #
:		R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		:GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:		OUTPUT A BYTE STRING
:		LINK ON R5
:		R3 = POINTER TO STRING
:		R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:		FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:		RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:		INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:		EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	= MESSAGE CT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,, :GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1, :INSERT MESSAGE TYPE INTO MESSAG
E
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM


        SUBTTL  ISIS STARTUP AND CRASH LIBRARY  - CRASH.LIB
        REMARK  %CRASH.LIB    11-15-84 AWT
        REMARK  %THIS VERSION HAS AN OPTION FOR EXTENDED CRASH PROCESSING.

        RA      0               :       CRASH.LIB       MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:       Changed the supervisor's log message to report the PRODID.
:       Sep. 20, 1982 SCY.
:       ENTRY2 (restart service) changed to clear input and output
:       rings PRIOR to issuing Restart SVC to prevent crash-loop if
:       Dispatcher has crashed. June 17, 1982 MDS.

:                       ISIS - II Version
:
        GL      CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME,EXCRSH
        MO      .,CRASH


:       Generalized crash package.
:       Handles both software and hardware crashes.  On any crash, the
:       registers are saved in CRXREG, and CRSHCT is incremented.
:       Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:       CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:       calling sequence is:

:               JAL     R10,CRASH
:                                               from a bad one
:               HC      0               :this key distinguishes a good crash
:               BC      4*L,Y           :first byte is 4*register linked to
:                                               routine, Y is the reason
:       then register (L) is saved in CFROM, and Y is saved in CRASHC

:       in the event of a hardware failure, CPOINT contains the instruction
:       address at the time of failure, CRASHC contains the failure reason,
:       and CFROM is set =-1.

:       On completion of crash, transfers to label START, defined
:       in the user code.
:
:       The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:       be executed only once.  the second time through the crash area will
:       be set up as specified above and then registers will be restored to
:       their entry value and the slot will be frozen. If it is thawed it
:       will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:       The symbol EXCRSH, if set to 1, allows a JAL to label
:       CRSH.P out of the crash routine for extended crash processing.
:       The link is R5.  EXCRSH is defaulted to 0.
:
:

  IF    \CRSTOP
  ELSE
CRSTOP  EQ      0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF    \EXCRSH                 :DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH  EQ      0
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT  HS      1               :CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC  HS      1               :CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT  HS      2               :WHERE CRASH OCCURED
CFROM   HS      2               :WHERE CRASH WAS CALLED FROM
CRXREG  HS      20              :CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL  HS      1               :FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


        SEG     A.CODE          :CODE AREA
CRSHCD  BC      1       :MANUAL RESTART
        BC      0       :POWER FAILURE
        BC      0E      :PARITY ERROR
        BC      10      :DISPATCHER CRASH
        BC      11      :ILLEGAL INSTRUCTION
        BC      12      :ILLEGAL SVC
        BC      13      :SYSTEM CRASH
        BC      14      :PROTECTION VIOLATION
        BC      15      :NON-RECOVERABLE DEVICE CHECK
        BC      16      :WATCH FROG TIMER - - TIME OUT

        RA      0
:       GENERAL MACHINE FAILURE
FAIL    HS      4               :PSD SAVED HERE
        HS      4               :R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF          :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
        CLHI    R0,12           :TEST IF ILLEGAL SVC
        JNFS    FAIL1           :NO...SKIP
        LHL     R0,FGNDFL       :DID FOREGROUND CAUSE THE CRASH?
        JN      ENTRY2          :YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
        LCS     R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:       CRASH ROUTINE AND GENERAL INITIALIZER
:       IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:       THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF          :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
        LIS     R0,$A10         :FAKE UNKNOWN CRASH
        LCS     R1,1            :FROM NOWHERE
        LHL     R2,0,R10        :CHECK WHERE CALLED FROM
        JNFS    CRASH1          :NOT KNOWN...USE DEFAULT
        LB      R0,3,R10        :GET CRASH CONDITION
        LB      R2,2,R10        :GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2 :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
        JFS     ENTRY1

:       ENTER HERE WITH RESTART
ENTRY   LIS     R0,1            :LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1  LIS     R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF    CRSTOP          :IF STOPPING ON CONSECUTIVE CRASHES
        CLHI    R0,1
        JLE     ENTRY2          :IF POWER FAILURE OR MANUAL RESTART
        OHI     R0,0CC00        :CRASH INDICATOR FOR FRONT PANEL
        STH     R0,FPANEL,,     :SET PANEL TO BAD CRASH
   IF   EXCRSH
        JAL     R5,CRSH.P,,     :GO DO EXTENDED CRASH PROCESSING
   EI   EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
        SVC     SYS,HALT.       :HALT THE SLOT
  EI    CRSTOP

        LIS     R0,1            :WANT SECOND WORD OF PSD
        SVC     SYS,RFPSD.      :READ FOREGROUND PSD
        CLI     R0,.            :TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTIO
N
        JNFS    ENTRY2          :SKIP IF NOT
        STH     R0,FGNDFL       :SET THE FOREGROUND FLAG

ENTRY2          : NOW RESET OUTPUT RING, REPORT CRASH
  IF    CRSTOP
  ELSE
   IF   EXCRSH
        JAL     R5,CRSH.P,,     :GO DO EXTENDED CRASH PROCESSING
   EI   EXCRSH
  EI    CRSTOP
        LIS     R0,0
        ST      R0,ORING,,      :EMPTY OUTPUT RING
        ST      R0,IRING,,      :EMPTY INPUT RING

        LA      R0,FAIL         :LOAD TRAP AREA ADDRESS
        SVC     SYS,RSTRT.      :RESTART SVC
        JAL     R10,CRASH       :NON-SKIP RETURN...CRASH


        LIS     R0,0
        STH     R0,FGNDFL       :CLEAR THE FOREGROUND FLAG

        JAL     R4,SPACE,,      :SET UP FOR DIAGNOSTIC
        LHI     R0,0300
        JAL     R4,PUTW,,       :PORT 0 + DIAGNOSTIC MESSAGE + PAD
        LHL     R0,CRAT+CRSHCT,,
        JAL     R4,PUTCH,,      :HW4 LOW = CRASH COUNT
        LIS     R0,0
        JAL     R4,PUTCH,,      :RESERVED BYTE
        LIS     R0,1
        JAL     R4,PUTCH,,      :REPORT TYPE = 1
        LHL     R0,CRAT+CRASHC,,
        JAL     R4,PUTCH,,      :HW3 HIGH = CRASH CODE
        LHI     R0,PRODID
        JAL     R4,PUTCH,,      :HW2 LOW IS PRODUCT ID
        JAL     R4,ELOR,,       :END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1      :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1
        LM      R6,CRAT+CRTLEN/2,R1
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
        EM


        SUBTTL  Standard Timeout Routine Library        - TIMOUT.LIB
        RA      0               :       TIMOUT.LIB

:       This package contains the standard timeout routines
:       The following parameters MUST be defined on entry:
:       NTOUT   number of timeout entries which may be active at any one time

:       expects to JAL R10,CRASH if list overflows

:       six symbols are declared:
:       IZT     called at initilization, link on R0
:       TIMOUT  to be called periodicaly, link on on R0
:               will in turn jump to any routines which should be serviced:
:               R0 = routine address
:               R1 = current fast-clock time.
:       TORET   routines called by TIMOUT should exit to here
:       TOPUT   any code may call this to place an entry on timeout list:
:               link on R5...R6--R15 preserved
:               R0 = address to transfer to
:               R1 = next time to call routine
:       TOGET   called to delete an entry already on timout list
:               link on R5...R6--R15 preserved
:               R0 = routine address...entry with this address will be deleted
:       TONOW   called to flush an entry, and execute it NOW!
:               link on R5...NO registers preserved! NOW!
:               routine address in R0
:       NOTE...when a routine is called from timeout list, it is removed from :              list, and must call TOPUT to be called again.
:       ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

        GL      IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
        MO      .,TIMOUT

        SEG     A.DATA          :PLACE IN DATA AREA

  IF    6-.
        BS      6-.             :UNUSED 
  EI
TO9     HS      2               :link for timeout processor
LSIZ    EQ      $A 10           :number of bytes in list entry
TLIST   BS      (NTOUT+1)*LSIZ  :timeout list
:                               active list entry = halfword chain pointer
:                               word routine address
:                               word time of next activiation

:               free list pointer is at TLIST
:               active list chain pointer is at TLIST+2
:       CODE SEGMENT
        SEG     A.CODE

TORET   L       R0,TO9          :TIMEOUT ROUTINES EXIT HERE
:       CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT  LHL     R2,TLIST+2      :GET ACTIVE LIST POINTER
        JER     R0              :EXIT IF NO ACTIVE ENTRIES
        L       R1,FASTC,,      :GET CURRENT CLOCK TIME
        CL      R1,TLIST+6,R2   :IS 1ST ACTIVE LIST TIMEOUT DUE
        JLR     R0              :NO TIMEOUTS DUE TO PROCESS
        ST      R0,TO9          :ROUTINE MUST TERMINATE BY JUMPING TO TORET
        LHL     R3,TLIST,R2
        STH     R3,TLIST+2      :SHORTEN ACTIVE LIST
        LHL     R4,TLIST
        STH     R4,TLIST,R2     :SPLICE INTO HEAD OF FREE CHAIN
        STH     R2,TLIST
        L       R0,TLIST+2,R2
        JR      R0              :FETCH ADRS AND ENTER TIMED OUT ROUTINE

:       PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT   LIS     R2,2            :FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.

TPT1    LR      R3,R2
        LHL     R2,TLIST,R2     :CHECK NEXT TIMEOUT ENTRY
        JEFS    TPT2            :ACTIVE LIST IS EMPTY
        CL      R1,TLIST+6,R2   :IS IT EARLIER THAN ARGUMENT DUE TIME
        JGBS    TPT1            :YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER

TPT2    LHL     R4,TLIST
        JGFS    TPT3
        JAL     R10,CRASH,,     :FREE LIST EXHAUSTED
        BC      0,0,4*R5,0F     :FLAG--LINK R5, TYPE 15d CRASH
TPT3    STH     R4,TLIST,R3     :MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
        LHL     R3,TLIST,R4
        STH     R3,TLIST        :SHORTEN FREE LIST
        STH     R2,TLIST,R4     :HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
        ST      R0,TLIST+2,R4
        ST      R1,TLIST+6,R4
        JR      R5              :STORE ARGUMENTS AND RETURN

TONOW   LIS     R1,2            :SEARCH ACTIVE LIST
TONOW1  LR      R2,R1           :COPY CURRENT ENTRY POINTER
        LHL     R1,TLIST,R2     :GET NEXT ENTRY
        JER     R5              :LIST EXHAUSTED...EXIT
        CL      R0,TLIST+2,R1   :CHECK THIS ENTRY
        JNBS    TONOW1          :LOOP IF NOT MATCH
        LHL     R3,TLIST,R1     :WE GOT A MATCH
        STH     R3,TLIST,R2     :UNLINK THIS ENTRY
        LHL     R3,TLIST        :GET START OF FREE LIST
        STH     R3,TLIST,R1     :LINK THIS ENTRY TO FREE LIST
        STH     R1,TLIST        :PLACE ON FREE LIST
        ST      R5,TO9          :SAVE RETURN ADDRESS
        JR      R0              :AND GO TO ROUTINE

TOGET   LIS     R1,2            :SEARCH ACTIVE LIST
TOGET1  LR      R2,R1           :COPY CURRENT ENTRY POINTER
        LHL     R1,TLIST,R2     :GET NEXT ENTRY
        JER     R5              :LIST EXHAUSTED...EXIT
        CL      R0,TLIST+2,R1   :CHECK THIS ENTRY
        JNBS    TOGET1          :LOOP IF NOT MATCH
        LHL     R3,TLIST,R1     :WE GOT A MATCH
        STH     R3,TLIST,R2     :UNLINK THIS ENTRY
        LHL     R3,TLIST        :GET START OF FREE LIST
        STH     R3,TLIST,R1     :LINK THIS ENTRY TO FREE LIST
        STH     R1,TLIST        :PLACE ON FREE LIST
        JR      R5              :AND EXIT

IZT     LHI     R1,NTOUT*LSIZ   :INITIALIZE TIMEOUT FREE LIST
        LIS     R2,0            :0 TERMINATES LIST
        STH     R2,TLIST+2      :ACTIVE LIST IS EMPTY
        STH     R2,TLIST,R1     :TERMINATE FREE LIST
        STH     R1,TLIST-LSIZ,R1
        SIS     R1,LSIZ
        JGBS    .-6
        JR      R0
        EM


        SUBTTL  Library Package for BID and BIDH        - BID.LIB
        RA      0               :       BID.LIB
:       Library package for BID, BIDH

:       either routine called with bit pattern in R1, link on R3
:       returns number of a non-zero bit in R2
        GL      BID,BIDH
        SEG     A.CODE          :PLACE IN CODE AREA
        MO      .,BID
:

:       HALFWORD Bit identifier
:       left half of R1 must be zero if bit 16 is zero
:       returns original word in R1
:       number of leftmost bit of right half or R1 in R2
  IF    ENGINE
BIDH    JFFOH   R1,BIDH1        :FIND FIRST NON-ZERO BIT
        LHI     R2,10   :RETURN 10 IF NO BIT IS FOUND
BIDH1   JR      R3      :AND RETURN
  ELSE
BIDH1   LB      R2,BIDTAB,R1    :LEFT HALF IS EMPTY
        JR      R3              :GET ID OF FIRST BIT IN RIGHT HALF
BIDH    THI     R1,0FF00        :TEST IF FIRST BIT IS IN LEFT OR RIGHT BYTE OF H
ALFWORD
        JEBS    BIDH1           :RIGHT HALF
        EXBR    R2,R1           :LEFT HALF
        LBR     R2,R2           :COPY LEFT BYTE
        LB      R2,BIDTAB,R2    :USE IT TO INDEX INTO ID TABLE
        SIS     R2,8            :ADJUST NUMBER TO CORRESPOND TO LEFT BYTE
        JR      R3              :AND RETURN
  EI    ENGINE

:       FULLWORD Bit identifier
:       returns original word in R1
:       number of leftmost non-zero bit in R2
  IF    ENGINE
BID     JFFO    R1,BID1         :TEST FULLWORD FOR FIRST NON-ZERO BIT
        LHI     R2,20           :RETURN 20 IF NO BIT FOUND
BID1    JR      R3              :AND RETURN
  ELSE
BID1    LB      R2,BIDTAB,R1    :IN BYTE 4
        AHI     R2,10           :GET BIT ID FOR BYTE AND ADJUST FOR BYTE 4
        JR      R3
BID2    THI     R1,0FF00        :BYTE 1 AND 2 = 0
        JEBS    BID1            :IF BYTE 3 IS 0, LOOK UP BYTE 4
        EXBR    R2,R1           :ELSE COPY OUT BYTE 3
        LBR     R2,R2
        LB      R2,BIDTAB,R2    :PICK UP INDEX FOR THAT BYTE
        AIS     R2,8            :ADJUST FOR BYTE 3
        JR      R3
BID     THI     R1,8000         :TEST IF IN LEFT 17 BITS
        JEBS    BID2            :IF NOT, MUST BE IN BYTE 3 OR 4
        EXHR    R2,R1           :BIT IS IN BYTE 1 OR 2 (OR BIT 16)
        TI      R2,0FF00        :TEST IF BYTE 1
        JEFS    BID3            :SKIP IF NOT
        EXBR    R2,R2           :BIT IS IN BYTE 1, SO COPY BYTE 1
        LBR     R2,R2           :TO USE AS INDEX
        LB      R2,BIDTAB,R2    :LOOK UP ID WITHIN THIS BYTE
        SIS     R2,8            :ADJUST FOR REALLY BEING IN BYTE 1
        JR      R3
BID3    LBR     R2,R2           :HERE WITH BIT IN BYTE 2 (OR BIT 16)
        LB      R2,BIDTAB,R2    :LOOK UP ID WITHIN THIS BYTE
        JR      R3              :IF FIRST BIT WAS BIT 16, USE ENTRY 0 IN TABLE
BIDTAB  HS      0               :TABLE OF BIT NUMBERS IN A BYTE, BIASED BY 8
        NOLIST
        XC      100F0E0E0D0D0D0D0C0C0C0C0C0C0C0C0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B
        XC      0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A
        RE      2
        XC      0909090909090909090909090909090909090909090909090909090909090909
        ER
        RE      4
        XC      0808080808080808080808080808080808080808080808080808080808080808
        ER
        LIST
  EI    ENGINE
        EM


	SUBTTL	Big Bufferlet Package	- BBFLET.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************


:	**** REVISION HISTORY ****
:	ORIGINAL DESIGN AND CODE -- BY NELSON SU
:	21-May-86 (RT)	-Allow the buffers to fill segment
:	07-MAR-86 (MMJ) -Add debugging mode to detect inconsistency
:	   in capture-release mechanism. Make it a new BBF.D3 option
:	   preserving the previous address check.
:	05-OCT-85 (KRR) -Add BUFUSE. Clean-up.
:	29-JUN-83 (RNC)	-STANDARDIZE Revision History (NO SAR#)
:	JUNE 24, 1983 -- BY NELSON SU, SUPPORTABOVE 64K CONFIGURATION

	RA	0

:	This package contains all code and storage allocation needed for
:	dynamic allocation of big bufferlets.  It contains no routines
:	which manage data in big bufferlets.  Such routines are left to
:	be written by the user.

:	This is the two level re-entrant version (all routines can be called
:	by both foreground and background).


:	the following parameters MUST be defined before assembly:
:	NBBFLT	the number of big bufferlets to create.  Two of them will
:		"never" be allocated, to avoid possible race conditions
:		and unraveling of the free list.  This can't be
:		counted on, however, since it is possible for one of the
:		unusable 2 to get allocated if things are timed in just the
:		right order.
:	BBFLSZ	the size (in bytes) of a big bufferlet, MUST be even

:	the following parameters are defined for the user:
:	BBUFER	base address of big bufferlet storage area

:	the following external routines are used:
:	CRASH	JAL R10,CRASH performed if catistrophic theoretically
:		impossible conditions occur

:	The big bufferlets are kept in a double linked free list
:	from which they are allocated when needed.  The pointers
:	used are relative to BBUFER.

:	The package contains both utility and primitive routines:

:	utility routines are called with link on RLINK1
:	PBBC	-Put Big Bufferlet Chain
:		RCH = pointer to 1st big bufferlet in chain
:		PBBC will return a chain of big bufferlets to the dynamic pool


:	primitive routines are called with link on RLINK
:	IZBB	-Initialize Big Bufferlets
:		initializes big bufferlet double linked list used to
:		dynamically allocate big bufferlets.
:	GBB	-Get Big Bufferlet
:		Return		-No Big Bufferlet is available
:		Skip return	-RCH has pointer to big bufferlet, chain
:				half-word in big bufferlet set to zero
:	PBB	-Put Big Bufferlet
:		RCH has pointer to big bufferlet to return to dynamic pool

:	Debugging modes:(active if symbol defined as a positive number)
:		BBF.D1  Count GBB and RBB calls in global cell 'BUFCNT'.
:			When all bufferlets put back, BUFCNT=0.  Crash if
:			BUFCNT<0.
:
:		BBF.D2  Software crash when no bufferlets available on
:			GBB call.  This fixes lost bufferlet problem.
:
:		BBF.D3  On all calls to GBB and PBB, check BB addr. range.
:			CRASHES IF NOT VALID RANGE. 
:			Also CRASH on attempt to release a bufferlet already
:			in the free pool or to capture one already captured.	
:			Keep BUFBIT bit array to indicate if bbflet. in the
:			free pool (bit reset) or used (bit set).

	GL	NBBFLT,BBFLSZ,FWBBF
	MO	.,BBUFER
	GL	IZBB,GBB,PBB,PBBC,BBUFER	:PROVIDED TO USER
	GL	CRASH				:EXTERNAL ROUTINES NEEDED

	IF	\FWBBF
	ELSE
FWBBF	EQ	0
	EI
	IF	FWBBF
BBFPSZ	EQ	4
BBLOAD	MACRO(D)[L]
BBSTOR	MACRO(D)[ST]
	ELSE
BBFPSZ	EQ	2
BBLOAD	MACRO(D)[LHL]
BBSTOR	MACRO(D)[STH]
	EI

:	REGISTER USAGE DEFINITION
RCH	EQ	R3		:REG WITH BUFFERLET ADDR
RLINK	EQ	R4		:LINKAGE FOR IZBB,GBB,PBB
RLINK1	EQ	R5		:LINKAGE FOR PBBC
RW1	EQ	R6		:WORK REG FOR IZBB,GBB,PBB
RW2	EQ	R7		:WORK REG FOR IZBB,GBB,PBB
RW3	EQ	R2		:WORK REG FOR PBBC


:	DEBUGGING OPTIONS
  IF	\SNOBUF
  ELSE
SNOBUF	EQ	0		:DON'T SIMULATE NO BUFFERLETS EVER
  EI

  IF \BBF.D1
  ELSE
BBF.D1	EQ	0
  EI

  IF \BBF.D2
  ELSE
BBF.D2	EQ	0
  EI

  IF \BBF.D3
  ELSE
BBF.D3	EQ	0
  EI
  


BBTST	MACRO(Q) [

:Check range of BB address and integrity of capture-release mechanism. 

	IF	BBF.D3
	
	LR	RW1,RCH		:DON'T ALLOW NEGATIVE
	SIS	RW1,2
	JL	BBCKCR
	CI	RW1,(NBBFLT-1)*BBFLSZ	:CHECK MAX ADDR
	JG	BBCKCR
	DH	RW1,BBCKD	:ADDR MUST BE MULTIPLE OF SIZE
	LR	RW1,RW1
	JN	BBCKCR		:REM NOT 0, NOT EXACT MULTIPLE
	
	IF Q			:FOR PBB ROUTINE 
	RBT	RW2,BUFBIT
	JE	BBCPUT
	ELSE			:FOR GBB ROUTINE
	SBT	RW2,BUFBIT
	JN	BBCGET	
	EI 
	
	LIS	RW1,0		:RESTORE RW1
	
	EI ]


:	DATA AREA
	SEG	A.DATA
FREE1	HC	0		:INDEX OF HEAD OF LIST 1
FREE2	HC	0		:INDEX OF HEAD OF LIST 2
LOCK1	HC	0		:8000 = LIST 1 LOCKED DUE TO RE-ENTRANTCY
LOCK2	HC	0		:8000 = LIST 2 LOCKED DUE TO RE-ENTRANTCY
	GL	BUFCNT
BUFCNT	HC	0		:CNT OF REMAINING FREE BUF.
BUFUSE	HC	0		:Max. number of bufferlets ever in use
	IF BBF.D3
BUFBIT	HS	(NBBFLT-1)/10+1 :Set/reset bit when bufferlet capt./rel.  
	EI

:	BUFFERLET AREA
	SEG	A.BUFF		:ALLOCATE IN BUFFER AREA
	HS	0		:ALLIGN TO HALF-WORD
BBUFER	EQ	.-2		:BASE ADDRESS OF BUFFERLET AREA

Q	EQ	A.BUFF
QQ	EQ	NBBFLT*BBFLSZ
	RE
	SEG	Q
	IF	QQ-10000
	BS	10000
	ELSE
	BS	QQ
	EI
QQ	EQ	QQ-10000
Q	EQ	Q+1
	ER	QQ

CHAIN1	EQ	BBUFER+BBFLSZ-2:ADDRESS OF FORWARD CHAIN HW IN BUFFERLET
CHAIN2	EQ	CHAIN1-2	:ADDRESS OF BACKWARD CHAIN
	SEG	A.CODE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			 S U B R O U T I N E	I Z B B				::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

IZBB	LIS	RCH,2		:RCH = RELATIVE ADDR OF BUFFERLET
	STH	RCH,FREE1	:INIT FREE CHAIN
	LHI	RW1,NBBFLT	:RW1 = NO. BUFLETS IN FREE LIST

IBB10	SIS	RW1,1		:DEC BUFFERLET CNT
	IF BBF.D3
	RBT	RW1,BUFBIT
	LR	RW1,RW1
	EI	
	JEFS	IBB20		:JUMP TO TERMINATE CHAIN
	STH	RCH,CHAIN2+BBFLSZ,RCH,	:BACKWARD LINK IN NEXT BB
	AHI	RCH,BBFLSZ	:FIND NEXT BUFFERLET START
	STH	RCH,BBUFER-2,RCH,	:SET CHAIN TO IT
	JBS	IBB10
IBB20	STH	RCH,FREE2	:HEAD OF LIST 2

	LHI	RW1,NBBFLT-1
		STH	RW1,BUFCNT	:INIT. FREE BUF. CNT 
	LIS	RW1,0		:SET BIT POINTER
	STH	RW1,BUFUSE	:No bufferlets ever used
	RBT	RW1,LOCK1	:RESET LIST 1 LOCK
	RBT	RW1,LOCK2	:RESET LIST 2 LOCK
	JR	RLINK

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			S U B R O U T I N E	G B B			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

GBB	LCS	RW1,1			:DEC. FREE BUF. CNT
	AHM	RW1,BUFCNT
	JLE	NOBBF1			:EXIT IF NO FREE BUF.

	LHI	RW1,NBBFLT		: Update BUFUSE to reflect
	SH	RW1,BUFCNT		: the largest number of
	CH	RW1,BUFUSE		: bufferlets in use at any
	JLEFS	GBB10			: given time.

	STH	RW1,BUFUSE
GBB10
	LIS	RW1,0			:INIT FOR BIT TESTS

		IF	SNOBUF	:SIMULATE NO BUFFER AVAILABLE
		:-:-:-:-:-:-:-:-:-:-:-:ERROR SIMULATE:-:-:-:-:-:-:-:-:-:-:-:
		LCS	RW2,1		:COUNT ENTRY			:
		AHM	RW2,SNOBCT
		JGFS	SNOBRT	:JUMP NOT TIME TO SIMULATE		:
		LHI	RW2,SNOBUF	:RESET ERROR SIMULATE CNTR
		STH	RW2,SNOBCT
		JR	RLINK		:TAKE NO BUFFERLET AVAILABLE RETURN
		SEG	A.DATA						:SNOBCT		HC	SNOBUF	:ERROR COUNTER			:
		SEG	A.CODE						:
SNOBRT	EQ	.							:
		:-:-:-:-:-:-:-:-:-:-:-:ERROR SIMULATE:-:-:-:-:-:-:-:-:-:-:-:
		EI	:SNOBUF
	SBT	RW1,LOCK1	:LIST 1 LOCKED ?
	JN	GBB20		:JUMP IF SO, TRY LIST 2
	LHL	RCH,FREE1	:GET INDEX TO NEXT FREE BUFFERLET
	LR	RCH,RCH
	JE	PBB25

	BBTST(0)
	LH	RW2,CHAIN1,RCH,:GET CHAIN TO NEXT FREE BUFFERLET
	STH	RW2,FREE1	:PUT IN FREE POINTER
	STH	RW1,CHAIN1,RCH,:ZERO CHAIN FOR BUFFERLET FETCHED
	STH	RW1,CHAIN2,RCH,:ZERO CHAIN FOR BUFFERLET FETCHED
	RBT	RW1,LOCK1	:UNLOCK LIST 1
	J	4,RLINK	:SKIP RETURN (BUFFERLET FOUND)

:	LIST 1 WAS LOCKED OR EMPTY, TRY LIST 2.
:	IF LIST 2 EMPTY OR LOCKED, RETURN.  THEORETICALLY, BOTH
:	LISTS WILL NEVER BE LOCKED (IF THEY ARE, IT
:	IS A DESIGN ERROR THAT PBB WILL DETECT AND CRASH).

:	PROGRAM BUG - BOTH ENDS OF LIST LOCKED
BUFERR	JAL	R10,CRASH,,
	BC	0,0,4*RLINK,0D0:CRASH WITH DIAG. CODE
NOBBUF	EQ	.
	LIS	RW1,1
	AHM	RW1,BUFCNT		:RESTORE BUF. CNT
	IF BBF.D2
		JAL	R10,CRASH	:No bufferlet crash
		BC	0,0,4*RLINK,0D2
	EI
	JR	RLINK		:RETURN (CAN'T PROVIDE BUFFERLET)

NOBBF1
	LIS	RW1,0
	RBT	RW1,LOCK1	:UNLOCK
	J	NOBBUF

GBB20	SBT	RW1,LOCK2	:TRY LIST 2
	JN	BUFERR		:BOTH ENDS LOCKED - PGM. BUG
	LHL	RCH,FREE2	:GET LINK PTR
	
	BBTST(0)
	LH	RW2,CHAIN2,RCH,:GET CHAIN TO NEXT BUFFERLET
	STH	RW2,FREE2	:PUT AT HEAD OF LIST 2
	STH	RW1,CHAIN1,RCH,:ZERO CHAIN FOR BUFFERLET FETCHED
	STH	RW1,CHAIN2,RCH,:ZERO CHAIN FOR BUFFERLET FETCHED
	RBT	RW1,LOCK2	:UNLOCK LIST 2
	J	4,RLINK	:SKIP RETURN (BUFFERLET FOUND)


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		S U B R O U T I N E	P B B			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


PBB	EQ	.		:Start of routine PBB

	LR	RCH,RCH
	JE	PBB25

	IF BBF.D1
	LH	RW1,BUFCNT	:GET BUF. CNT
	CHI	RW1,NBBFLT-1	:COMPARE TO MAX POSSIBLE
	JLFS	PBB01		:LESS - OK
	JAL	R10,CRASH	:Crash if too many put back
	BC	0,0,4*RLINK,0D1
	EI

PBB01	LIS	RW1,0		:INIT FOR BIT TESTS
	SBT	RW1,LOCK1	:LIST 1 LOCKED ?
	JN	PBB20		:JUMP IF SO, TRY LIST 2

PBB10	EQ	.
	BBTST(1)
	LHL	RW2,FREE1	:GET INDEX TO 1ST FREE BUFFERLET
	STH	RW2,CHAIN1,RCH,:ONE WE'RE PUTTING BACK CHAINS TO IT
	STH	RCH,CHAIN2,RW2,:AND VICE VERSA
	STH	RCH,FREE1	:ONE PUTTING BACK NOW 1ST FREE
	RBT	RW1,LOCK1	:UNLOCK LIST 1
	LIS	RW1,1
	AHM	RW1,BUFCNT
	JR	RLINK		:RETURN

:	LIST 1 LOCKED, TRY LIST 2.  IF IT IS LOCKED ALSO,
:	IT IS CONCEIVABLE THAT IT IS DUE TO A RACE CONDITION, SO CHECK
:	LIST 1 AGAIN.  IF ITS LOCKED, THAT'S INCONCEIVABLE, CRASH.

PBB20	SBT	RW1,LOCK2	:LIST 2 LOCKED ?
	JEFS	PBB30		:JUMP IF NOT, PUT ON IT
	SBT	RW1,LOCK1	:LIST 1 STILL LOCKED ?
	JE	PBB10		:JUMP IF NOT, PUT ON LIST 1
PBB25
	JAL	R10,CRASH	:LISTS LOCKED UP TIGHT, CRASH
	BC	0,0,4*RLINK,0D0	:CRASH CODE

PBB30	EQ	.
	BBTST(1)
	LHL	RW2,FREE2	:GET INDEX TO 1ST BUFFERLET IN LIST 2
	STH	RW2,CHAIN2,RCH,:ONE WE'RE PUTTING BACK CHAINS TO IT
	STH	RCH,CHAIN1,RW2,:AND VICE VERSA
	STH	RCH,FREE2	:ONE PUTTING BACK NOW AT HEAD OF LIST 2
	RBT	RW1,LOCK2	:UNLOCK LIST 2
	LIS	RW1,1		:INC. FREE BUF. CNT
	AHM	RW1,BUFCNT
	JR	RLINK		:RETURN

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		 S U B R O U T I N E	P B B C			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

PBBC	LHL	RW3,CHAIN1,RCH,:GET INDEX OF NEXT BUFFERLET IN CHAIN
	JAL	RLINK,PBB	:PUT THIS BUFFERLET BACK
	LR	RCH,RW3	:GET NEXT IN CHAIN
	JNBS	PBBC		:PUT IT BACK TOO
	JR	RLINK1		:END OF CHAIN (0), RETURN
	
	

	IF BBF.D3
BBCKD	HC	BBFLSZ

BBCKCR	JAL	R10,CRASH	:RCH=BAD CHAIN ADDR
	BC	0,0,4*RLINK,0D3	:CRASH CODE

BBCPUT	JAL	R10,CRASH	:RELEASING BBFLET. ALREADY IN FREE POOL!!
	BC	0,0,4*RLINK,0D4

BBCGET	JAL	R10,CRASH	:CAPTURING BBFLET. ALREADY IN USE!!
	BC	0,0,4*RLINK,0D5
	EI

	EM

	SUBTTL ICL C03 Bisync Control Character Definition

	RA	0
	MO	.,MAIN
	SEG	A.CODE

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	I C L	C 0 3	C O N T R O L	C H A R  D E F I N I T I O N	::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: The following macros are used for incoming character manipulation
: for character reversing and parity handling.


:	MACRO TO DO 1-8,8-1 BIT REVERSAL OF AN EQ'D SYMBOL CREATING A
:	NEW SYMBOL R`SYMBOL.	THIS IS NEEDED BECAUSE CURRENT HARDWARE
:	RECEIVES SYNCHRONOUS DATA MSB INSTEAD OF LSB FIRST.

RVCHAR	MACRO(CHAR)[NOLIST
QQ	EQ	0
Q	EQ	0
	IF CHAR&80	;Q EQ Q+01	;QQ EQ QQ+01;	EI
	IF CHAR&40	;Q EQ Q+02	;QQ EQ QQ+01;	EI
	IF CHAR&20	;Q EQ Q+04	;QQ EQ QQ+01;	EI
	IF CHAR&10	;Q EQ Q+08	;QQ EQ QQ+01;	EI
	IF CHAR&08	;Q EQ Q+10	;QQ EQ QQ+01;	EI
	IF CHAR&04	;Q EQ Q+20	;QQ EQ QQ+01;	EI
	IF CHAR&02	;Q EQ Q+40	;QQ EQ QQ+01;	EI
	IF CHAR&01	;Q EQ Q+80	;QQ EQ QQ+01;	EI
	LIST
	IF	QQ&1
R`CHAR	EQ	Q
	ELSE
R`CHAR	EQ	Q!01
	EI]

 
:	REVCHR - MACRO TO REVERSE A CHAR
:	--------------------------------

REVCHR	MACRO(CHAR,QZZ) [NOLIST
QZZ	EQ	0
	IF CHAR&80	;QZZ EQ QZZ+01; EI
	IF CHAR&40	;QZZ EQ QZZ+02; EI
	IF CHAR&20	;QZZ EQ QZZ+04; EI
	IF CHAR&10	;QZZ EQ QZZ+08; EI
	IF CHAR&08	;QZZ EQ QZZ+10; EI
	IF CHAR&04	;QZZ EQ QZZ+20; EI
	IF CHAR&02	;QZZ EQ QZZ+40; EI
	IF CHAR&01	;QZZ EQ QZZ+80; EI
	LIST
	]
 
:	MACRO PC TO GENERATE PARITY BITS AND REVERSE IT FOR TRANSMISSION
:	----------------------------------------------------------------


PC	MACRO(C)[NOLIST
Q	EQ	01
	IF C&80 ;Q EQ Q%01;	EI
	IF C&40 ;Q EQ Q%01;	EI
	IF C&20 ;Q EQ Q%01;	EI
	IF C&10 ;Q EQ Q%01;	EI
	IF C&08 ;Q EQ Q%01;	EI
	IF C&04 ;Q EQ Q%01;	EI
	IF C&02 ;Q EQ Q%01;	EI
	LIST
C	EQ	(C&0FE)+Q]




:	REVTAB - TABLE FOR REVERSING CHARS
:	----------------------------------

Q	EQ	0
REVTAB	BS	0
	RE	100
	REVCHR(Q,QQ)
	NOLIST
	BC	QQ
Q	EQ	Q+1
	ER
 



QQQ	EQ	0
PARTAB	BS	0
	RE	100
	REVCHR(QQQ,QQ)
	PC(QQ)
	NOLIST
	BC	QQ
QQQ	EQ	QQQ+1
	ER

 
:	C03 CONTROL CHARS
:	-----------------

NUL	EQ	00		: TIME-FILL
SOH	EQ	01		: START OF HEADER
STX	EQ	02		: START OF TEXT
ETX	EQ	03		: END OF TEXT
EOT	EQ	04		: END OF TRANSMISSION
ENQ	EQ	05		: ENQ
ACK	EQ	06		: ACKNOWLEDGMENT
DLE	EQ	10		: DATA LINK ESCAPE
NAK	EQ	15		: NEGATIVE ACKNOWLEDGEMENT
SYN	EQ	16		: SYNCHRONOUS IDLE
ETB	EQ	17		: END OF BLOCK
PAD	EQ	7F		: SYNCHRONOUS PAD CHARACTER
:
:	ICL C03 ADDRESSING CONSTANTS
:	----------------------------

:	C03 CONTROL CHARACTERS WITH BIT REVERSAL
:	----------------------------------------

	RVCHAR(SYN)
	RVCHAR(PAD)

	EM





	SUBTTL	ICL C03 Data Structure Definitions

: This module defines the major data structures of the ICL C03
: Host Interface.

:
	MO	.,C03BLK
:
	LO	MAIN
	RA	$0 0

	GL	ACTIVD,ACTIVC,PORTAB,DCBLKS,ACTIVT,ACTIVO,MAXGRP,MAXSUB

: Define macros for accessing pointers to PGRTAB

	IF	NPGRP*100-7FFF
FWGRP	EQ	1
	ELSE
FWGRP	EQ	0
	EI

	IF FWGRP
PGLODS	MACRO(d)[L]	: Load and Store for Fullwords
PGLOAD	MACRO(d)[L]
PGSTOR	MACRO(d)[ST]
	ELSE
PGLODS	MACRO(d)[LH]	: Load and Store for Halfwords
PGLOAD	MACRO(d)[LHL]
PGSTOR	MACRO(d)[STH]
	EI

: Define macros for accessing pointers to SUBTAB

	IF	NSUBS*100-7FFF
FWSUB	EQ	1
	ELSE
FWSUB	EQ	0
	EI

	IF FWSUB
SULODS	MACRO(d)[L]	: Load and Store for Fullwords
SULOAD	MACRO(d)[L]
SUSTOR	MACRO(d)[ST]
	ELSE
SULODS	MACRO(d)[LH]	: Load and Store for Halfwords
SULOAD	MACRO(d)[LHL]
SUSTOR	MACRO(d)[STH]
	EI



:		DCB FLAGS DEFINITIONS (USE BIT ARRAY METHOD)
:		------------------------------------------


:		SUB CURRENT STATUS
:		------------------




: ======================================================================

: ----------------------------
: D C B - DEVICE CONTROL BLOCK
: ----------------------------

	SEG	A.DCB
DCBORG	EQ	.
	ORG	.-2

: Processing routine addresses
: ----------------------------
DIDRA	HS	1		: ISIS Input data routine (XTOSS/IND)
DODRA	HS	1		: ISIS Output data routine (OID/OCHA10/OND)
DICRA	HS	1		: ISIS Input control routine (IIC/INC)
DOCRA	HS	1		: ISIS Output control routine (OIC/ONC)
DISRA	HS	1		: (SIIX10/FSHIIX/STEXT)
DOSRA	HS	1		: (OCHAR/VOCHR callers)

 
: Fields for ISIS input
: ---------------------
DIRBA	HS	1		: CURRENT BUF. ADDR
DIRBX	HS	1		: OFFSET
DPFCNT	HS	1		: partial fragment count 0 - 255
IDIRBA	HS	1		: Current buffer address for int chain
IDIRBX	HS	1		: Offset along int chain buffer
FRAGST	HS	1		: Start of this fragment

: Fields for ISIS output
: ----------------------
DORBA	HS	1		: CURRENT BUFFERLET ADDR
DORBX	HS	1		: OFFSET
DORCNT	HS	1		: REMAINING BYTE COUNT IN MSG

: DSP fields
: ----------
DTPBCC	BS	1		: TEMPORARY AREA TO CALCULATE BCC
 
: DCB Line, GRP, SUB, port information
: ------------------------------------
DCBGRP	HS	1		: PGRTAB address (RGRP)
DCBSUB	HS	1		: SUBTAB address (RSUB)
DPORT	HS	1		: ASSOCIATED PORT (ZERO IF NOT LOGGED IN)
DCBHST	HS	1		: ASSOCIATED TYMNET HOST
DDEV	HS	1		: DEVICE NUMBER FOR THIS DCB
DZAP	BS	1		: REASON CODE FOR DISCONNECT (FOR ACCT)
DMODE	BS	1		: Mode 0=INACTIVE, 1=NATIVE, 2=LOGON, 3=ASCII
DNCHAR	BS	1		: Set if we overshoot filling fragment

	BND	2
DFLAGS	HS	1		: Flag word for dcb


	BND	10
DCBLEN	EQ	.-DCBORG
ACTIVD	EQ	DIDRA-DCBORG
ACTIVC	EQ	DICRA-DCBORG

: ======================================================================



: ---------------------------------------------------
: H O S T B L -	HOST TABLE FOR MULTIPLE HOST SUPPORT
: ---------------------------------------------------

	ORG	0

HSTNUM	HS	1		: Host number
HSTMPT	BS	1		: Number of ports
	BND	2
HCHGPT	HS	1		: Host status changed flag 80 no change, 0 changed
HSTSPT	BS	1		: # host ports shut
HSTFPT	HS	1		: # free host ports
HSTPRT	HS	1		: # of DCBs connected to host
	BND	10
HSTLEN	EQ	.




: ======================================================================

: --------------------------------
: L I N T A B - LINE CONTROL TABLE
: --------------------------------

: LINTAB consists of a single entry for each line configured on
: the interface. Each entry requires LINLEN bytes.

: It provides information regarding line characteristics and gives
: the necessary information for addressing each of the poll groups
: associated with the line.

	ORG	0

: Table addressing information
: ----------------------------
LNMGRP	BS	1		: Number of GRPs on the line
LNMSUB	HS	1		: Total number of SUBs on the line
PGRPTR	HS	$A MAXGRP	: Field of h/w indices to PGRTAB
LNFPGR	HS	1		: Pointer to first group
LNFSUB	HS	1		: Pointer to first sub

: Line characteristics
: --------------------
LNRSPN	BS	1		: Receive block timeout value

: Current address information
: ---------------------------
CPRGRP	HS	1		: Current RCV GRP pointer
CPRSUB	BS	1		: Current RCV SUB
LBPOL1	HS	1		: Two halfwords used to detect line hang
LBPOL2	HS	1


	BND	10
LINLEN	EQ	.



: ======================================================================

: --------------------------------------
: P G R T A B - POLL GROUP CONTROL TABLE
: --------------------------------------

: PGRTAB consists of a single entry for each poll group configured
: on the interface. Each entry requires PGRLEN bytes.

: It provides the necessary information for keeping track of the
: poll group state for the Protocol Manager with information for
: the manipulation of individual SUBs within the poll group. The
: required information for SUB addressing is also included.

: PGRTAB is directly addressed via PGRPTR in C03RCV and C03xPH in
: the foreground. In the background it is addressed either via the
: DCB or sequentially starting with the first entry for the line.

	ORG	0

: Addressing and data structure information
: -----------------------------------------
PGRLNM	BS	1		: Line number for the poll group
GRPADR	BS	1		: Actual GRP for the poll group
SUBPTR	HS	$A MAXSUB	: Field of h/w indices to SUBTAB
PGFSUB	HS	1		: Pointer to first SUBTAB for the p group
LPSUBN	BS	1		: # of SUBs defined for the poll group
FLOWCL	HS	1		: Flow control for this grp (6.1.2)
LLSTAT	HS	1		: Link Level status for grp (5.5.7)
GCSTAT	HS	1		: H L status for grp (6.4.1.1)
HLSTAT	HS	1		: HL status sent to host
GRPFLG	HS	1		: Flags - Toggle, LLHR, etc
GCOMND	BS	1		: For GSS, command read

LSTBUF	HS	1		: Start of last Fragment sent
LSTEND	HS	1		: End of last fragment sent
LSTSIZ	HS	1		: Size of last Fragment sent
LSTCAT	HS	1		: Last Cat used to send from
LSTSUB	HS	1		: Last SUB from which data sent
LSTSEL	HS	1		: Last sub which was SELECTed
GOBCT	HS	1		: Group outbound count
GCIRCS	HS	1		: Number of circuits to this group

: Poll group activity indicators
: ------------------------------
NBPOL1	HS	1		: Previous poll/response count
NBPOL2	HS	1		: New poll/response count

: Protocol Manager related information
: ------------------------------------
LRCVOP	HS	1		: Code for last recvd message

: Bit arrays. 1 bit per SUB
: -------------------------
RCVDAT	WS	3		: Something present on rcv list
TXNDAT	WS	3		: Not used, kept to make code consistent
TXIDAT	EQ	TXNDAT		: Not used either, but all qs similar


BPOS	BS	6		: a byte for each cat - current position

	BND	2
CAT1	WS	8		: Category bit arrays
CAT2	WS	8
CAT3	WS	8
CAT4	WS	8
CAT5	WS	8
CAT6	WS	8

	BND	10
PGRLEN	EQ	.



: ======================================================================

: -------------------------------
: S U B T A B - SUB CONTROL TABLE
: -------------------------------

: SUBTAB consists of a single entry for each SUB configured on the 
: interface. Each entry requires SUBLEN bytes.

: It provides information relating to the characteristics of the SUB
: required by the HIF.

: SUBTAB is directly addressed via SUBPTR in C03RCV and C03xPH where
: the foreground is concerned. In the background it is addressed via
: the DCB or sequentially starting with the first SUB for either the 
: poll group or the line.

	ORG	0

: Addressing and data structure information
: -----------------------------------------
SUBLNM	BS	1		: Line # for the SUB
SUBABS	HS	1		: Absolute SUB # on the interface
SUBHST	HS	1		: Tymnet host associated with this SUB
SUBPGR	BS	1		: SUB # relative to start of P.Gr
SUBGRP	HS	1		: PGRTAB addr for this SUB (RGRP).
SUBADR	BS	1		: Real SUB address
ALSTAT	HS	1		: A L status for this sub (7.4)
SUBFLG	HS	1		: Useful flags for sub
SUBCAT	BS	1		: Current Category of sub
SUBDCB	HS	1		: THIS STATION'S DCB
OBCOUNT	HS	1		: Current outbound count
IBCOUNT	HS	1		: Curent inbound count
LASTACT HS	1		: LAST Activate or Deactivate ADDED 16/2/88

: Protocol Manager related information
: ------------------------------------

: Foreground queue information
: ----------------------------
SGPRCV	HS	1		: RCV get ptr
SRPRCV	HS	1		: RCV release ptr
SPPRCV	HS	1		: RCV put ptr
SCCRCV	HS	1		: RCV CMD link use count
SDCRCV	HS	1		: RCV data byte count
SGPTXN	HS	1		: TXN get ptr
SRPTXN	HS	1		: TXN release ptr
SPPTXN	HS	1		: TXN put ptr
SCCTXN	HS	1		: TXN CMD link use count
SDCTXN	HS	1		: TXN data byte count
SGPTXI	HS	1		: TXI get ptr
SRPTXI	HS	1		: TXI release ptr
SPPTXI	HS	1		: TXI put ptr
SCCTXI	HS	1		: TXI CMD link use count
SDCTXI	HS	1		: TXI data byte count
	BND	10
SUBLEN	EQ	.



: ======================================================================
: DCBLKS Initialisation
: ---------------------

: Allocate a DCB for each SUB and a dummy DCB for inactive ports
: The dummy DCB will be the one with the highest offset from DCBLKS

	SEG	A.DCB

	ORG	DCBORG
DCBLKS	BS	(NSUBS-(3*NGRPS)+1)*DCBLEN
DCBEND	EQ	.

: ======================================================================

	SEG	A.BDAT



: ======================================================================
: SUBTAB Initialisation
: ---------------------

SUBTAB	EQ	.

L		EQ	0
GRP	EQ	0
SUBSID	EQ	0
	RE	NBILIN

RDL	EQ	0
SL	EQ	0
	RE	NGRP|L|

	EXPND2(RDL,RDL1,RDL2)
SPGR	EQ	0
	RE	NSU|L||RDL1||RDL2|

	EXPND2(SL,SL1,SL2)
SU1	BS	SUBLEN
SU2	EQ	.
	ORG	SU1
	BC	L
	HC	SUBSID
	HC	H|L||RDL1||RDL2||SL1||SL2|
	BC	SPGR
	HC	GRP*PGRLEN
	BC	R|L||RDL1||RDL2||SL1||SL2|	:rsub #
	HS	1				:AL stat
	HS	1				:Flags
	BS	1				:Cat
	ORG	SU2
SUBSID	EQ	SUBSID+1
SL	EQ	SL+1
SPGR	EQ	SPGR+1
	ER					: (NSU|L||SDL1||SDL2|)
GRP	EQ	GRP+1
RDL	EQ	RDL+1
	ER					: (NGRP|L|)
L	EQ	L+1
	ER					: (NBILIN)



: ======================================================================
: PGRTAB Initialisation
: ---------------------

PGRTAB	EQ	.

AR	EQ	0
AS	EQ	0
L	EQ	0
	RE	NBILIN
R	EQ	0
SL	EQ	0
	RE	NGRP|L|

	EXPND2(R,D1,D2)
	EXPND2(SL,SL1,SL2)
PG1	BS	PGRLEN
PG2	EQ	.
	ORG	PG1

	BC	L
	BC	GAD|L||D1||D2|
	RE	MAXSUB
	HC	-1
	ER

	HC	AS*SUBLEN
	BC	NSU|L||D1||D2|		:No of subs in group
	HS	1	: Flow
	HS	1	: LL stat
	HS	1	: GC HL stat
	HS	1	: HL stat
	HS	1	: Flags
	BS	1	: GSS cmnd
	HS	1
	HS	1
	HS	1
	HS	1
	HS	1
	HS	1
	HS	1
	HS	1


	RE	NSU|L||D1||D2|
	ORG PGRTAB+(PGRLEN*AR)+SUBPTR+(R|L||D1||D2||SL1||SL2|-BSUBAD)*2
	HC	SUBLEN*AS
SL	EQ	SL+1
	EXPND2(SL,SL1,SL2)
AS	EQ	AS+1
	ER				: (NSU|L||D1||D2|)

R	EQ	R+1
AR	EQ	AR+1
	ORG	PG2
	ER				: (NGRP|L|)

L	EQ	L+1
	ER	:	(NBILIN)



: ======================================================================
: LINTAB Initialisation
: ---------------------

LINTAB	EQ	.

AR	EQ	0
AS	EQ	0
L	EQ	0
	RE	NBILIN

LN1	BS	LINLEN
LN2	EQ	.
	ORG	LN1

	BC	NGRP|L|
	HC	NSUB|L|
	RE	MAXGRP
	HC	-1
	ER
	HC	AR*PGRLEN
	HC	AS*SUBLEN


GRP	EQ	0
	RE	NGRP|L|
	EXPND2(GRP,GRP1,GRP2)
	ORG	LINTAB+(LINLEN*L)+PGRPTR+(GAD|L||GRP1||GRP2|-BGRPAD)/2

	HC	PGRLEN*(AR+GRP)
GRP	EQ	GRP+1
	ER

AR	EQ	AR+NGRP|L|
AS	EQ	AS+NSUB|L|

	ORG	LN2
L	EQ	L+1
	ER

: ======================================================================
: LINPTR Initialisation
: ---------------------

LINPTR	EQ	.
Q		EQ	0
	RE	NBILIN
	HC	Q*LINLEN
Q		EQ	Q+1
	ER



: ======================================================================
: P O R T A B - Port Table
: ------------------------

: PORTAB is a table of halfwords indexed by RPORT * 2. Each
: halfword gives the address of the associated DCB (offset into
: DCBLKS).

: In the Host Interface the address of the DCB for the port is set
: up during slot initialisation so a DCB is permanently bound to a 
: port.

PORTAB	HS	NPORT

: ======================================================================
: D E V T A B - Device Table
: --------------------------

: DEVTAB is a table of NSUBS halfwords indexed by absolute device
: number {0, 1,....NSUBS-1}. Each halfword gives the address of the
: associated DCB (offset into DCBLKS).

: In the Host Interface this address is the address of a 'dummy'
: DCB at slot initialisation. The address of an actual DCB is 
: set up during call establishment on receipt of the Call User Data
: from the CMT thus binding the device to the DCB.
: When the call is cleared the entry is reset to the address of
: the dummy DCB.

DEVTAB	HS	NSUBS*2

: ======================================================================





:HOST TABLE FOR MULTIPLE HOST SUPPORT

	BND	10
HOSTBL	BS	HSTLEN*MAXHST
Q	EQ	-1			:TEMP COUNTER

	RE	MAXHST			:REPEAT FOR ALL HOSTS
Q	EQ	Q+1
	EXPND3(Q,Q1,Q2,Q3)

	ORG	HOSTBL+Q*HSTLEN

	IF	\HOS|Q1||Q2||Q3|
	HC	HOS|Q1||Q2||Q3|		:Host #
	BC	NHS|Q1||Q2||Q3|		:# subs on this host
	ELSE
	HC	-1			:Not defined, so =-1
	BC	0			:& set # subs to 0
	BC	-1
	EI	:(\HOS|Q1||Q2||Q3|)

	ER
:
	ORG	HOSTBL+HSTLEN*MAXHST

HSTPTR	HS	0
Q	EQ	0
	RE	MAXHST
	HC	Q*HSTLEN

Q	EQ	Q+1
	ER

	GL	HSTTAB
HSTTAB	HS	NPORT		:HOST TABLE POINTER
 



	SEG	A.DATA

	GL	PTRBIT,WLDFLG,STKSAV

PTRBIT	WC	0		: PROTOCOL TRACE SWITCH (BY LINE)
TRCSUP	HC	0		: If 1 don`t record POLL-NTRF events

	IF	\UHNGBT
DHNGBT	HC	UHNGBT		: set up hang timer mask
	ELSE
DHNGBT	HC	0
	EI


	BND	2
STKSAV	WS	1		: USED TO HOLD STACK POINTER TEMPORARILY
WLDFLG	BS	1		: FLAG WORD USED FOR DEALING WITH WILD CARDS
SLINE	BS	1		: USED TO HOLD THE LINE WE ARE SELECTING IN CUD
SGRP	BS	1		: USED TO HOLD THE GROUP
SSUB	BS	1		: USED TO HOLD SUB

RCVTIM	WS	NBILIN		: RCV TIMEOUT SAVE FOR XMTRCV
XMTRET	WS	NBILIN		: RETURN ADDRESS FOR XMTRCV

RCVBCT	HS	NBILIN		: RCV BUFFERLET LIMIT FOR XMTRCV
XMTCNT	HS	NBILIN		: HALFWORD DATA CNT FOR XMT
XDASAV	WS	1		: Temporary store for data present bit array

CALBCC	BS	NBILIN		: CALCULATE BCC AREA
XMTOPC	BS	NBILIN		: XMT OP CODE FOR ROUTINE XMT
RETRY	BS	NBILIN		: CURRENT RETRY NUMBER
RETRYN	BS	NBILIN		: CURRENT RETRY CYCLE NUMBER
CPXGRP	BS	NBILIN		: CURRENT XMT GROUP
CPXSUB	BS	NBILIN		: CURRENT XMT SUB
CPXFLO	BS	NBILIN		: CURRENT XMT FLOW CONTROL BYTE
CPXD1	BS	NBILIN		: CURRENT XMT 1st data byte
CPXD2	BS	NBILIN		: CURRENT XMT 2nd data byte

C03XER	HS	NBILIN		: COUNT OF XMT OP ERRORS FOR CURRENT OP
PTPHLT	HS	(NBILIN-1)/10+1 : HALT PROTOCOL DRIVER BIT ARRAY
BNASENT	HS	(SUBSID)/10+1	: Bit array to say Sub sent BNA
BNACLR	HS	(SUBSID)/10+1	: Bit array to indicate bna now clearing
NBPON	HS	(SUBSID)/10+1	: Bit array to say weve set bp to isis
NBPCLR	HS	(SUBSID)/10+1	: Bit array to say we want to rel bp

 
BKPRLN	EQ	0
Q		EQ	0
	RE	NBILIN
	IF	\NBKP|Q|
BKPRLN	EQ	BKPRLN!(1^(0F-Q))
	EI
Q		EQ	Q+1
	ER
NOWABT	HC	BKPRLN

XACKTY	HS	(NBILIN-1)/10+1 : XMT ACK TYPE, 1=WABT,0=ACK
RACK	HS	(NBILIN-1)/10+1 : RCV ACK OR NOT BIT ARRAY

	FO	MAIN

	EM





        SUBTTL  ICL C03 Operations Monitor Data Structures
        RA      0
        MO      .,MONBLK

        SEG     A.MON

        IF      ITMTRA
        GL      ITMTBL,ITMIND
        BND     10
ITMSEC  HS      ($A220*$A16/2)*NBILIN
ITMIND  HS      NBILIN
Q       EQ      0
ITMTBL  WS      0
        RE      NBILIN
        WC      ITMSEC+Q*$A220*$A16
Q       EQ      Q+1
        ER
        EI

        IF      OTMTRA
        GL      OTMTBL,OTMIND
        BND     10
OTMSEC  HS      ($A220*$A16/2)*NBILIN
OTMIND  HS      NBILIN
Q       EQ      0
OTMTBL  WS      0
        RE      NBILIN
        WC      OTMSEC+Q*$A220*$A16
Q       EQ      Q+1
        ER
        EI

        IF      ATMTRA
        GL      ATMTBL,ATMIND
        BND     10
ATMSEC  HS      ($A220*$A16/2)*NBILIN
ATMIND  HS      NBILIN
Q       EQ      0
ATMTBL  WS      0
        RE      NBILIN
        WC      ATMSEC+Q*$A220*$A16
Q       EQ      Q+1
        ER
        EI

        IF      RTMTRA
        GL      RTMTBL,RTMIND
        BND     10
RTMSEC  HS      ($A220*$A16/2)*NBILIN
RTMIND  HS      NBILIN
Q       EQ      0
RTMTBL  WS      0
        RE      NBILIN
        WC      RTMSEC+Q*$A220*$A16
Q       EQ      Q+1
        ER
        EI

        IF      XTMTRA
        GL      XTMTBL,XTMIND
        BND     10
XTMSEC  HS      ($A220*$A16/2)*NBILIN
XTMIND  HS      NBILIN
Q       EQ      0
XTMTBL  WS      0
        RE      NBILIN
        WC      XTMSEC+Q*$A220*$A16
Q       EQ      Q+1
        ER
        EI

        IF      FEXTRA
        GL      FEXTBL,FEXIND
        BND     10
FEXTBL  HS      ($A80*$A16/2)
FEXIND  HS      1
        EI

        IF      STMTRA
STMIND  HS      1
STMTBL  HS      150
        EI

: ===========================================================================
: ------------------------------------------------
: X M T H R T - Foreground Transmit History table.
: ------------------------------------------------

        SEG     A.DATA
        GL      XMTHRT

NXMCOD  EQ      $A 15
NXMTTB  EQ      NBILIN

XMTHRT  HS      NXMTTB*NXMCOD

: Create a table of halfword pointers to the start of XMTHRT for each DROP
: in the case of TIF and each LINE in the case of HIF.

XMTPTR  EQ      .
Q       EQ      0
        RE      NXMTTB
        HC      Q*NXMCOD*2
Q       EQ      Q+1
        ER
: ===========================================================================
: -----------------------------------------------
: R C V H R T - Foreground Receive History table.
: -----------------------------------------------

        SEG     A.DATA
        GL      RCVHRT

NBRCOD  EQ      $A 20
NRCVTB  EQ      NBILIN

RCVHRT  HS      NRCVTB*NBRCOD

: Create a table of halfword pointers to the start of RCVHRT for each LINE

RCVPTR  EQ      .
Q       EQ      0
        RE      NRCVTB
        HC      Q*NBRCOD*2
Q       EQ      Q+1
        ER

: ===========================================================================
: ----------------------------------------------
: P T P T T B - Foreground Protocol Trace table.
: ----------------------------------------------

: Create a Foreground Protocol State Trace table. This table consists
: of PTPLEN*PTPENT bytes per line where PTPLEN is the number of bytes
: forming a single entry and PTPENT is the number of entries reserved
: before wrap-around occurs. The default number of entries is 256 and
: may be redefined in the TYMFILE, e.g OPTION(PTPENT,$A 512)

: offsets into the PTPTTB (protocol processor trace table)

x       eq      (.)
        org     0

o.rop   bs      1       :rcv operation
o.rGRP  bs      1       :rcv GRP
o.rSUB  bs      1       :rcv SUB
o.rpre	bs	1	:rcv ALP prefix
o.rd1	bs	1	:rcv 1st data byte

	bnd 2
o.re	bs	4	:rcv end time


o.xop   bs      1       :xmt operation
o.xGRP  bs      1       :xmt GRP
o.xSUB  bs      1       :xmt SUB
o.Xflo	bs	1	:xmt flow control byte
o.xd1	bs	1	:xmt 1st data byte
o.xd2	bs	1	:xmt 2nd data byte

	bnd 2
o.xs    bs      4       :xmt start time


        bnd     2
PTPLEN  eq      (.)
        org     x

        DEFVAR(PTPENT,$A 256)

        IF      PTPLEN*PTPENT-0FFFF
        REMARK  %ERROR - The largest value allowed for PTPENT is 
        NUMBER  $A 10000/PTPLEN
        REMARK   decimal%%
        EI

        GL      PTPTTB,PTPPTR,PTPTRX
        SEG     A.MON

PTPTTB  HS      NBILIN*PTPLEN*PTPENT/2


: Create a table of halfword pointers to the start of the PTPTTB entry
: for each line.

PTPPTR  EQ      .
Q       EQ      0
        RE      NBILIN
        HC      Q*PTPLEN*PTPENT
Q       EQ      Q+1
        ER

: Create a table of halfword pointers giving the offset into PTPTTB
: for the next trace entry relative to the start of the PTPTTB for
: the line.

PTPTRX  HS      NBILIN

XMTIME  WS      NBILIN          : Save XMT time FASTC
RCTIME  WS      NBILIN          : Save RCV time FASTC


        EM


        SUBTTL  B.G Logic - Symbols and Strings

        RA      0
        MO      .,MAIN

:THIS PACKAGE IS INTENDED TO DISPATCH TO THE CORRECT ROUTINE
:TO PROCESS EACH IIX MESSAGE. IN ADDITION IT WILL DISPATCH
:IIX MESSAGE TYPE 94 FOR C03 MESSAGES.

:THIS PACKAGE WILL REFERENCE IN THE DCB

:DISRA  SUBROUTINE FOR IDN DISPATCH
:DIIIX  TABLE FOR IIX MESSAGE DISPATCH

:CONFIGURATION OF IIX MESSAGE DISPATCH TABLES

:TO GENERATE A TABLE, UTILIZE THE MACRO GENIIX,
:       TABNAM  GENIIX
:WHERE TABNAM IS THE LABEL TO THE GENERATED TABLE,
:WITH ALL REFERENCES SET TO FLUSH THE MESSAGE. THE
:EXCEPTION IS IIX 94 WHICH WILL GO TO THE C03 DISPATCH 
:PROCESS. ALL ENTRIES FOR THE C03 DISPATCH WILL BE FLUSH
:ROUTINES AS WELL.

:TO CHANGE A BRANCH FOR A GLOBAL IIX ENTRY USE

:       GLOIIX(TABNAM,MSGNUM,BRLABL)

:WHERE
:TABNAM IS THE FIRST LOCATION IN THE TABLE,
:MSGNUM IS THE LOW ORDER 7 BITS OF THE IIX MSG TYPE,
:BRLABL IS THE PLACE TO BRANCH TO FOR THAT MESSAGE.

:TO CHANGE A PROTOCOL ENTRY USE

:       TURIIX(TABNAM,MSGNUM,BRLABL)

:WHERE
:THE SYMBOLS ARE AS BEFORE.

:EACH ROUTINE WILL BE BRANCHED TO WITH THE FOLLOWING REGISTER
:CONVENTION:
:R0     0       DATA BYTE
:RSL    1       SUBROUTINE ADDRESS FOR FETCHING THE NEXT DATA BYTE
:RBX    2       CURRENT BUFFER INDEX
:RBA    3       CURRENT BUFFER ADDRESS
:RCNT   9       COUNT OF CHARACTERS IN BUFFER
:RRC    A       ISIS MSG COUNT
:               DECREMENT WITH EACH WITHDRAWAL.
:RDCB   C       DCB LOCATION
:R14    E       ISIS INPUT POINTER


:TO FLUSH THE BALANCE OF AN IIX MESSAGE JUMP TO FSHIIX. ALL
:SUBSEQUENT ISIS MESSAGES FOR THIS PORT WILL BE FLUSHED UNTIL
:A SIIX IS DETECTED. IT IS RECOMMENDED AS A FINAL PROCESS AFTER
:RECEIVING ALL OF A MESSAGE THAT IS TO BE INTERPRETED.



        GL      CRIPOM,CRNAR,CRINVM,CRINVN,WLDFLG,RSEG

:       REGISTER DEFINITIONS FOR BACKGROUND
:       -----------------------------------

RBX     EQ      R2
RBA     EQ      R3              : PTR TO MSG. BUF.
RCNT    EQ      R9              : PARTIAL BISYNC MSG CNT
RDEV    EQ      R11             : DEVICE NUMBER
RSL     EQ      R1              : LINKAGE TO INPUT SUBROUTINE
RRC     EQ      R10             : ISIS RING RECORD COUNT (BYTES REMAIN)
RSTACK  EQ      R8

:	Define code segment

RSEG	EQ	SEG1
 
 
:	FLAG SETTINGS FOR DEALING WITH WILD CARDS
:	-----------------------------------------
WLDLIN	EQ	0		: Set when weve been given wild card for line
WLDGRP	EQ	1		: Set when same applies for group
WLDSUB	EQ	2		: And for subsidiary


:	SEMAPHORES WE CAN USE TO PREVENT F.G. CLASH WITH B.G.
:	-----------------------------------------------------
IBLOCK	EQ	1		: Used to prevent inbound chain clash


:       CRASH CODES
:       ---------------
CRIPOM  EQ      20              : INVALID PORT 0 MESSAGE
CRNAR   EQ      21              : NO ACTIVATION ROUTINE FOUND
CRINVN  EQ      22              : INVALID NEEDLE RECEIVED
CRINVM  EQ      23              : INVALID MESSAGE RECEIVED
CRDCB   EQ      24              : DCB TABLE PROBLEM
CRIHST  EQ      25              : INVALID HOST NUMBER
CRNDA   EQ      26              : NO DEVICES ADDRESSES
CRINVO  EQ      27              : INVALID OUTPUT REQUEST
CRNOBF  EQ      28              : NO BUFFERLETS AVAILABLE
CRMONT  EQ      29              : MONITOR TABLE OVERFLOW
CRNCMD  EQ      2A              : NO COMMAND LINK FOUND
CRDALP  EQ      2B              : DEVICE ADDRESS LIST PROBLEM
CRIRS   EQ      2C              : IMPOSSIBLE RECEIVE STATE
CRINVC  EQ      2D              : lINVALID OUTPUT COMMAND
CRIXMT  EQ      2E              : INVALID XMT REQUEST
CRINVX  EQ      2F              : INVALID IIX DIALECT/GLOBAL CODE
CRBCMD  EQ      30              : BAD COMMAND LIST ADVANCE

:       PORT ZERO MESSAGES
:       ---------------------

RESREQ  EQ      0               : RESTART REQUEST
RESREP  EQ      1               : RESTART RESPONSE
TAKOVR  EQ      2               : TAKE OVER (FROM SUP)
SUPREP  EQ      3               : REPORT TO SUP
HSTSTA  EQ      10              : HOST STATUS
RPTACT  EQ      5               : REPORT ACCOUNTING
TELTIM  EQ      6               : TELL HOST TIME
PSDREQ  EQ      7               : PSEUDO NEEDLE REQUEST
AUXREQ  EQ      8               : AUX CIRCUIT REQUEST
PSDREJ  EQ      9               : PSEUDO NEEDLE REJECT
HSTPOR  EQ      0A              : HOST PORT AVAILABILITY
HSTREJ  EQ      0B              : HOST REJECTED (UNACCEPTABLE)
HSTCST  EQ      0C              : REPORT HOST COST
NO.SUP  EQ      0D              : NO SUP
.1DOWN  EQ      0E              : ONE-DOWN MESSAGE

:       DEFINE LENGTH OF PORT ZERO MESSAGES
:       -----------------------------------

RREQLN  EQ      3               : RESTART REQUEST
RREPLN  EQ      3               : RESTART RESPONSE
TKOVLN  EQ      4               : TAKE OVER (FROM SUP)
RSUPLN  EQ      9               : RESPORT TO SUP
HSTALN  EQ      0E              : HOST STATUS (MESSAGE TYPE 10)
RACTLN  EQ      08              : REPORT ACCOUNTING
TTIMLN  EQ      08              : TELL HOST TIME
NREQLN  EQ      0B              : PSEUDO NEEDLE REQUEST
XREQLN  EQ      08              : AUX CIRCUIT REQUEST
PREJLN  EQ      07              : PSEUDO NEEDLE REJECT
HPRALN  EQ      0A              : HOST PORT AVAILABILITY
HREJLN  EQ      07              : HOST UNACCEPTABLE
HCSTLN  EQ      0A              : REPORT HOST COST
NSUPLN  EQ      03              : NO SUP
.1DNLN  EQ      0E              : ONE-DOWN MESSAGE
 
:       SPECIAL SYMBOLS USED BY IIX MESSAGE MACROS
:       ------------------------------------------
X.Q	EQ	80		: MASK TO TEST FOR TOP BIT SET
TURBAS  EQ      8               : START OF TURKEY MESSAGES
P.ASC   EQ      2               : 8081 ASCII
P.GAT   EQ      0               : 8082 GATEWAY
P.X25   EQ      3               : 8083 X25
P.C03   EQ      1               : 8092 C03
CUDSZ   EQ      $A18            : SIZE OF CALL USER DATA FIELD
PITYPE  EQ      1               : PERIPHERIAL INITIAL CMD
PYTBIT  EQ      7               : FLAG BIT NUMBER FOR PITYPE
B6.IIX  EQ      01              : (B6)SUCCESS LOGON IIX BIT
PN.IIX  EQ      8000            : PSEUDO-NEEDLE IIX BIT
EX.B4M  EQ      4000            : B4 MSG BIT
D.BASE  EQ      8081            : BASE DIALECT CODE
SELDIA  EQ      8080            : SELECT DIALECT COMMAND
C03DIA  EQ      8092            : C03 DIALECT 
D.MAX   EQ      1               : NUMBER OF CURRENT DIALECTS IN IIX

:       DEFINE HOST STATUS
:       ---------------------

HSTANS  EQ      0               : HOST ANSWER
HSTDWN  EQ      1               : HOST DOWN
HSTSHT  EQ      2               : HOST SHUT
HSTOUT  EQ      2               : HOST OUT OF PORTS

:       DEFINE SUP LOG MSG TYPE (REPORT TYPE IN 03 MSG)
:       -----------------------------------------------
CKTZAP  EQ      10              CKT ZAP FROM NETWORK

:       DEFINE NATIVE HOST ERROR CONDITION
:       ----------------------------------

S.MSGW  EQ      0               : FLOW CONTROL FOR MSG WAIT

S.NAVA  EQ      1               : SUB not configured
S.OCCU  EQ      2               : DESIRED SUB IS OCCUPIED
S.ILLE  EQ      3               : Illegal requested SUB
R.NAVA  EQ      4               : GRP not configured
R.OCCU  EQ      5               : No SUB available for requested GRP
R.ILLE  EQ      6               : Illegal requested GRP
L.OCCU  EQ      7               : No SUB available for requested HOST
H.NPOL  EQ      8               : Host is not polling

S.LFOK  EQ      9               : HOST FINISH LOGOFF
S.LGOF  EQ      $A 10           : USER WANTS TO LOGOFF

        SEG     A.DATA


:       DEVICE RELATED FLAGS
:       --------------------

PLOCK   HS      (NPORT+1)/10+1  : PORT LOCK
DUNAV   HS      NGSUB           : 1,IF DEVICE NOT IN USE


:	F.G. / B.G  flags
:	-----------------

SEMA4S	WS	1		: Useful semaphores

        SEG     A.DATA

:       IIX MESSAGES
:       ------------

: CIRCUIT RESET MESSAGE
:       (Q=1,M=0/ MSG CODE 21/RES SEQ #/CMD SEQ #/REASON CODE)
: INVITATION TO CLEAR MSG
:       (Q=1,M=0/MSG CODE 01/REASON TO BE FILLED IN)

M.SIIX  SC      /"BF/                           : SIIX CODE
M.TIIX  SC      /"C0/                           : TIIX CODE

	BND	2	
M.C030	SC	/"80"80"80"92/			: SELECT C03 MSG
	BND	2
M.INV   SC      /"C0"94"80"00"03"00"01"00/      : INVITATION TO CLEAR
	BND	2
M.ID    BC      6,80,86,00,HID,VERSION,REVLEV
	BND	2
M.CACP  SC      /"C0"92"00"04"00"00"00"00/      : CALL ACCEPT MSG
	BND	2
M.TUR1	SC	/"C0"93"00"01/			: Turkey level 1
	BND	2
M.CMND  SC      /"C0"94"00"00"00"FF"03/     	: AL Command message


:       APPLICATION MESSAGES
:       -------------------
HOPMSG  SC      /"8A"8DHost out of ports. Please try again."8D"8A/
PLSMSG  SC      /"8A"8DInvalid access method for this host. "8D"8A/


:	Messages generated internally, which are sent to the host.
:	These are defined as strings, with the first byte set to 1
:	if the message is to go out on the int cat 1. The next 2
:	bytes are not used, and the rest of the	characters make up
:	the message to be sent, and includes the etx character.

	BND	2
:	This is a supervisory status report to tell host that BNA
:	condition no longer applies for this subsidiary
M.RSBNA	SC	/"01"00"00"21"00"03/			: BNA is clear now

	BND	2
:	This is a supervisory status report to tell host that BNA
:	condition no longer applies for this group
M.RGBNA	SC	/"01"00"00"21"40"03/			: BNA is clear now

	BND	2
:	This is a supervisory status report to tell host that device
:	has gone inoperable.
M.INOP	SC	/"00"00"00"21"41"03/			: Dev is inop now

	BND	2
:	This is a null text fragment used to complete an alp after zap.
M.NULL	SC	/"00"00"00"40"00"03/			: data is null



        SEG     A.CODE

:       STACK MACROS
:       ------------

:       PUSH(REG) - SAVE REG ON THE STACK
:       POP(REG) - RESTORE REG FROM STACK
:       RETJ(REG) - RESTORE REG AND RETURN USING IT
:       POPPSH(REG) - LOAD REG FROM STACK (LEAVE STACK UNCHANGED)
:       PUSHM(REG)- SAVE REG - R15 ON THE STACK
:       POPM(REG) - RESTORE REG - R15 FROM THE STACK
 
:       THE STACK PTR POINTS TO THE FIRST EMPTY LOCATION
:       THE STACK GROWS UPWARD IN MEMORY
 
PUSH    MACRO(REG)
 [      ST      REG,0,RSTACK;   AIS     RSTACK,4]
 
POP     MACRO(REG)
 [      SIS     RSTACK,4;       L       REG,0,RSTACK]
 
RETJ    MACRO(REG)
 [      SIS     RSTACK,4;       L       REG,0,RSTACK;   JR      REG]
 
POPPSH  MACRO(REG)
 [      L       REG,-4,RSTACK,  ]
 
PUSHM   MACRO(REG)
 [      STM     REG,0,RSTACK    ;       AHI     RSTACK,($010-REG)*4]
 
POPM    MACRO(REG)
 [      SHI     RSTACK,($010-REG)*4     ;       LM      REG,0,RSTACK]
 
        SEG     A.DATA
PATCH0  HS      P0SIZE
        SEG     A.CODE
PATCH1  HS      P1SIZE
 
        EM




        SUBTTL  ISIS Front End Handler Package  - FRNTND.LIB
:******************************************************************
:
:
:*******************************************************************
        RA      0               :       FRNTND.LIB      MFR 08/12/81
:
:       This package is an ISIS Front End interface to Tymnet. It
:       is used to service the ISIS input ring, and to activate user
:       defined routines whenever a message is found for a port and
:       optionally for output service when output requests are pending.

:       The package is designed to permit the activation routines to be
:       defined on an individual port basis if desired. It is also
:       designed so that context within a process can be indicated by 
:       dynamically changing to a different set of activation routines.
:
:                       Conventions
:
:       The following symbols are to be provided by the user:
:
:       ECHO    if TRUE causes Tymsat echoing for terminals
:       AUTOBP  if TRUE causes automatic backpressure application and release
:               for a port based upon comparing number of characters
:               in input buffer and MAXCHAR.
:       PTIMEO  if TRUE port timeouts are available
:       MAXCHAR maximum number of characters in a port's input buffer
:       before backpressure should be applied. (Only needed if AUTOBP is TRUE)
:       OUTPROC if TRUE then output activation code will be included.
:       WAITZA if TRUE then ZAPPER acknowledgements will be requested from
:               ISIS and code will be included to clean up the port upon
:               receipt of the ZAP ACK message. (User will not have to reset
:               ACP.)
:
:       The following symbol is to be initialized by the user:
:
:       PECHO   a bit for each port. If set then echoing will be honored
:               for the port, otherwise defered echo mode will not be
:               honored.
:
:       The following symbols may be provided by the user:
:       (If not provided, default values will be used)
:
:       CRIPOM  crash code for invalid port zero message (default 20x)
:       CRNAR   crash code for no activation routine found (default 21x)
:       CRINVN  crash code for invalid needle received (default 22x)
:       CRINVM  crash code for invalid message received (default 23x)
:
:       The following data structures are to be provided and initialized
:        by the user: (They may be located in any segment)
:
:       DCB     Device Control Block, a data structure which contains all
:               the context information for a port. There should be NPORT
:               DCB's defined starting at address DCBLKS. Within each DCB
:               the following offsets must be defined:
:                       DCBICC  input character count (halfword)
:                       ACTIVD  relative address in A.CODE of data
:                               activation routine.
:                       ACTIVC  relative address in A.CODE of a table of
:                               halfword offsets in A.CODE of routines
:                               for each possible control message.
:                       ACTIVT  relative address in A.CODE of timeout
:                               activation routine.
:                       ACTIVO  relative address in A.CODE of output
:                               activation routine. (Only needed if OUTPROC
:                               is TRUE.)

:
:       PORTAB  Port Table, a halfword array containing entries for each
:               port which are the relative offset from DCBLKS of the
:               DCB for the port.
:
:       In addition, activation routines must be defined for port zero
:       messages (ACTIV0) to for needles (ACTIVN). These labels should
:       be the location of the actual routine not offsets in A.CODE.
:
:       Whenever a data or control message activation routine is called,
:       the following registers are set up:
:               R1      port number
:               R2      message type
:               R5      link register
:               R12     DCB pointer
:               R14     input ring pointers
:
:       The activation routines are responsible for extracting all the
:       message data for the current logical record from the input ring.
:       Upon return, this package willend the logical input record (ELIR).
:       Therefore R14 must be pointing to the end of the message
:       when this package regains control. All other registers may be
:       smashed.
:
:       Needles are handled differently. The are parsed and the following
:       registers loaded.
:               R1      port number
:               R2      number of characters in username
:               R5      link register
:               R6      invoice number
:               R7      destination host number
:               R8      originating node number
:               R9      originating host number
:               R10     originating port number
:               R11     dialect code
:               R13     TID
:               R14     input ring pointer
:
:       Upon a needle activation, everything up to and including the
:       username length will have been extracted from the input ring.
:       The ACTIVN routine is responsible for extracting the username.
:
:       If PTIMEO is true then a normal return from any activate'ed
:       process indicates that the timeout state of the port should not
:       be modified. If a skip return is taken, then R0 will be
:       examined. If R0 is non-zero, a timeout for that
:       many seconds will be set for the port. If R0 is zero then any 
:       timeout for the port will be cleared. When a timeout expires for a port
:       the timeout activation routine for the port will be called with
:       the following registers set up:
:               R1      port number
:               R5      link register
:               R12     DCB pointer
:
:       Upon return from the timeout activation routine, the same
:       skip/normal return convention is followed.
:
:       The user may also set or clear a timeout for a port directly.
:       The routines SETTO and CLRTO are used to set or clear a
:       timeout for a port respectively. They are used when a timeout
:       is to be set (or cleared) at a time other than a the return from
:       an activation. The routines should be called with R1 = port number.
:       For SETTO R0 should contain the interval, in seconds, until
:       the timeout activation routine for the DCB in activated.
:
:       The output routine searches for any ports requiring output service
:       which are not backpressured. For each such port, the output
:       activation routine found in the port's DCB will be activated
:       with the following registers set up:
:               R1      port number
:               R5      link register
:               R12     DCB pointer
:
:       Upon return from the output activation routine, the same
:       skip/normal return convention for timeouts is followed.

:
:       The following routines are to be called by the user (link R0).
:
:       IZFRNT  at initialization time, after calling IZT.
:       INPUT   from EXEC loop, to process input from ISIS.
:       OUTPUT  from EXEC loop, to process output requests.
:
:       In order to facilitate setting up the control message
:       activation routine table some symbols, routines, and macros
:       have been defined.
:
:       The following symbols have the values of the offsets from A.CODE of
:       a number of control message processing routines:
:               Symbol  Routine Description
:               XTOSS   TOSS    tosses the message
:               XZAP    ZAP     handles zapper
:               XZACK   ZACK    handles zapper acknowledgement
:               XNOSEND NOSEND  handles backpressure
:               XRESEND RESEND  handles release backpressure
:               XGOBBLE GOBBLE  handles gobbler
:               XFLBACK FLBACK  handles flush backward
:               XEDEM   EDEM    handles enter deffered echo mode
:               XLDEM   LDEM    handles leave defered echo mode
:               XGB     GB      handles green ball
:               XRB     RB      handles red ball
:               XOB     OB      handles orange or black ball
:               XPNEED  PNEED   handles psuedo needle
:               XXLIM   XLIM    handle xmit limit
:               XINVAL  INVAL   crashes with invalid message code

:       The following macros are used to set up the tables:
:
:               HTABVT with argument table name is used to set up the 
:                       process table for a typical virtual terminal port.
:
:               HTABIA with argument table name is used to set set up the
:                       process table for an inactive port.
:
:               CHGTAB  with arguments table name, msg number, and routine
:                       label is used to substitute for a default process
:                       routine in the table.

:      Example:
:               To set up the control message activation routine table for
:               a virtual terminal handler which must call a routine to
:               release resources (RELRSC) upon losing the circuit on a port
:               the following code might be used.
:
:                       SEG     A.CODE
:                       MO      .,FRNTND
:
:                       HTABVT(VTAB)    :GENERATE DEFAULT TABLE
:                       CHGTAB(VTAB,9E,RELRSR)  :CHANGE ZAPPER HANDLER
:               RELRSC  ------          :CODE TO CLEAN UP AND RELEASE
:                       ------          :RESOURCES USED BY PORT
:                       J       ZAP     :JUMP TO ZAP PROCESSOR TO CLEAN
:                                       :UP ITS TABLES
:                       EM
:                       END
:
:       It should be noted that the above code is in the module FRNTND.
:       This is the Input Handler module. The preceeding symbols, routines
:       and macros are not global'ed so the code must be in the same
:       module or the symbols LOCAL'ed.
:       It should also be noted that the user defined processing
:       routines should jump to the default process routine or perform
:       similar processing on the input ring and status indicators.
:

:
        GL      NPORT,ECHO,DEM,PECHO,XLIMIT,ACP,TOISIS,FRISIS
        GL      IZFRNT,INPUT,RPORT,RDCB,AUTOBP,OUTPROC,PTIMEO
        GL      ACTIV0,ACTIVD,ACTIVC,ACTIVN,ACTIVT,EMPTYI,EMPTYO
        GL      CRIPOM,CRNAR,CRINVN,CRINVM
 IF     OUTPROC
        GL      ACTIVO,OUTPUT,OUTDAT,FLAGS
 EI
 IF     AUTOBP
        GL      AUTOBP
 EI

        MO      .,FRNTND

RPORT   EQ      R1              :PORT CURRENTLY BEING WORKED WITH
RDCB    EQ      R12             :POINTER TO DCB

        SEG     A.DATA

XLIMIT  BS      NPORT           :MAX NUMBER OF DATA CHARACTERS THAT CAN BE SENT
                                :IN ONE MESSAGE
NGRP    EQ      (NPORT+0F)/10   :NUMBER OF PORT GROUPS TO PROCESS
ACP     HS      NGRP            :ACTIVE PORTS BIT ARRAY
TOISIS  HS      NGRP            :PORTS WE CAN SEND DATA ON
FRISIS  HS      NGRP            :PORTS WE HAVE NOT BACKPRESSURED
DEM     HS      NGRP            :PORTS IN DEFERED ECHO MODE
 IF     OUTPROC
FLAGS   HS      1               :BASE ADDRESS OF BIT ARRARYS. FIRST
                                :HALFWORD WASTED TO AVOID BIT DISPLACE-
                                :MENTS OF ZERO.
OUTDAT  HS      NGRP            :PORTS WITH OUTPUT REQUESTS WAITING
 EI
PECHO   HS      NGRP            :PORTS FOR WHICH ECHO SHOULD BE PERFORMED
 IF     \WAITZA
 ELSE
        REMARK %PLEASE DEFINE WAITZA SWITCH. DEFAULT OFF ASSUMED%%
WAITZA  EQ      0
 EI

 IF     WAITZA
        GL      CNTRL
  IF    \CNTRL
CNTRL   EQ      CNTRL!80        :SET ZAP ACK BIT
  ELSE
CNTRL   EQ      80
  EI
 EI

REGSAV  HS      20              :REGISTER SAVE AREA
RETPTR  HS      2               :RETURN POINTER
RETRN   HS      2               :RETURN ADDRESS FOR ACTIV ROUTINE
SPORT   HS      1               :SAVE AREA FOR PORT NUMBER
SDCB    HS      1               :SAVE AREA FOR DCB POINTER
SLOOP   HS      1               :SAVE AREA FOR OUTPUT LOOP COUNTER
 IF     OUTPROC
PRTSVC  HS      1               :PORTS ELIGIBLE FOR SERVICE INDICATOR
 EI

  IF    PTIMEO                  :PORT TIMEOUT
TSAVE   HS      4               :SAVE AREA FOR TIMEOUT ACTIVATOR
PTIME   HS      NGRP            :PORTS ON ACTIVE TIMEOUT
ATIME   HS      2*NPORT         :ACTIVATION TIME
  EI


:
:       DEFINE CRASH CODES IF USER HAS NOT
:

  IF    \CRIPOM
  ELSE
CRIPOM  EQ      20      :INVALID PORT ZERO MESSAGE
  EI

  IF    \CRNAR
  ELSE
CRNAR   EQ      21      :NO ACTIVATION ROUTINE IN DCB
  EI

  IF    \CRINVN
  ELSE
CRINVN  EQ      22      :INVALID NEEDLE RECEIVED
  EI

  IF    \CRINVM
  ELSE
CRINVM  EQ      23      :INVALID MESSAGE RECEIVED
  EI



        SEG     A.CODE

:       HANDY INDEXABLE HALFWORD BIT MASKS
HMASK   HC      8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1

:       BIT ARRAY TO IDENTIFY DATA MESSAGES
DATAM   HC      07FFF,-1,-1     :00
        HC      -1,-1,-1        :30
        HC      -1,-1,-1        :60
        HC      0FFFC,0,0       :90
        HC      0,0,0           :C0
        HC      0               :F0

LENGTH  BC      0               :MESSAGE LENGTH TABLE
        RE      9D; BC .-LENGTH+1; NOLIST; ER; LIST    :DATA TEXT STRINGS
        BC      1               : 9E    DETACH
        BC      1               : 9F    DISCONNECT
        BC      1               : A0    APPLY BACKPRESSURE
        BC      1               : A1    RELEASE BACKPRESSURE
        BC      1               : A2    FLUSH FORWARD
        BC      1               : A3    FLUSH BACKWARD
        BC      1               : A4    BLACK BALL
        BC      1               : A5    GREY BALL
        BC      1               : A6    ENTER "DEM"
        BC      1               : A7    LEAVE "DEM"
        BC      1               : A8    ENTER "TRANSPARENCY"
        BC      1               : A9    LEAVE "TRANSPARENCY"
        BC      1               : AA    GREEN BALL
        BC      1               : AB    RED BALL
        BC      1               : AC    YELLOW BALL
        BC      1               : AD    ORANGE BALL
        BC      1               : AE    "BREAK" DETECTED
        BC      1               : AF    "HANG UP"
        BC      2               : B0    QUERY TERMINAL PARAMETER
        BC      3               : B1    SET TERMINAL PARAMETER
        BC      4               : B2    PSEUDO-NEEDLE
        BC      2               : B3    LOGON CHARACTER
        BC      2               : B4    NORMAL LOGON STATUS
        BC      2               : B5    LOGON FAILURE
        BC      8               : B6    SUCCESSFUL LOGON FROM THIS PORT
        BC      6               : B7    ADDENDUM TO ACCOUNTING
        BC      1               : B8    SUPER-"HANG UP"
        BC      2               : B9    TRANSMIT LIMIT
        BC      1               : BA    BREAK END
        BC      1               : BB    ZAPPER ACKNOWLEGEMENT
        BC      1               : BC    ENTER ALTERNATE OUTPUT DEVICE MODE
        BC      1               : BD    LEAVE ALTERNATE OUTPUT DEVICE MODE
        BC      2               : BE    ZAP WITH REASON
        BC      1               : BF    START IIX
        BC      1               : CO    TERMINATE IIX


:               **INTERFACE DATA TYPES**


NEDMSG  EQ      0               :NEEDLE
FIRST   EQ      9E              :FIRST MESSAGE IN LIST
DETMSG  EQ      9E              :DETACH MESSAGE
ZAPMSG  EQ      9F              :DISCONNECT MESSAGE
NOSMSG  EQ      0A0             :APPLY BACK-PRESSURE
SNDMSG  EQ      0A1             :RELEASE BACK-PRESSURE
GOBMSG  EQ      0A2             :FLUSH OUTPUT
BKGMSG  EQ      0A3             :FLUSH INPUT
BLKMSG  EQ      0A4             :DATA LOST IN THIS DIRECTION
GRYMSG  EQ      0A5             :DATA LOST IN OPPOSITE DIRECTION
EDMMSG  EQ      0A6             :ENTER DEFERED ECHO MESSAGE
LDMMSG  EQ      0A7             :LEAVE DEFERED ECHO MESSAGE
ETMMSG  EQ      0A8             :ENTER TRANSPARENCY MODE
LTMMSG  EQ      0A9             :LEAVE TRANSPARENCY MODE
GBMSG   EQ      0AA             :GREEN BALL
RBMSG   EQ      0AB             :RED BALL
YBMSG   EQ      0AC             :YELLOW BALL
OBMSG   EQ      0AD             :ORANGE BALL
BRKMSG  EQ      0AE             :BREAK DETECTED
HNGMSG  EQ      0AF             :HANG UP
QTPMSG  EQ      0B0             :QUERY TERMINAL PARAMETER
STPMSG  EQ      0B1             :SET TERMINAL PARAMETER
PNDMSG  EQ      0B2             :PSEUDO NEEDLE
NLOGCH  EQ      0B3             :NORMAL LOGON CHAR
NLOGST  EQ      0B4             :NORMAL LOGON STATUS
LOGFAL  EQ      0B5             :LOGON FAILURE
LOGOK   EQ      0B6             :SUCCESSFUL LOGON
ADACTG  EQ      0B7             :ADDENDUM TO ACCOUNTING
SHGMSG  EQ      0B8             :SUPER-HANG UP
SETLIM  EQ      0B9             :SET XMIT LIMIT
BRKEND  EQ      0BA             :BREAK END
ZAPACK  EQ      0BB             :ZAPPER ACKNOWLEGEMENT
EAODM   EQ      0BC             :ENTER ALTERNATE OUTPUT DEVICE MODE
LAODM   EQ      0BD             :LEAVE ALTERNATE OUTPUT DEVICE MODE
ZAPREA  EQ      0BE             :ZAP WITH REASON
SIIX    EQ      0BF             :START IIX
TIIX    EQ      0C0             :TERMINATE IIX
MAXTYP  EQ      0C0             :MAXIMUM TYPE DEFINED


:
:       HANDLES INPUT MESSAGES FROM ISIS INPUT RING
:
INPUT   ST      R0,RETPTR       :SAVE RETURN ADDRESS
INPUT1  JAL     R4,LOOK         :IS THERE ANYTHING TO DO?
        J       RET             :NO... RETURN ALLL DONE FOR NOW
        JN      INPUT2          :TEST IF PORT 0.. SKIP IF NOT
:
:       CHECK PORT ZERO MESSAGES
:
        JAL     R4,GETCH        :GET MSG TYPE BYTE
        LR      R2,R0           :TEST MSG TYPE
        JEFS    SPEC2           :SKIP IF MSG 0
        TBT     R2,SPECL        :TEST IF VALID MESSAGE TYPE
        JEFS    SPEC1           :SKIP IF OK
        JAL     R10,CRASH       :OTHERWISE CRASH
        BC      0,0,4*R2,CRIPOM

SPECL   BC      1D,0A9,0FF      :INVALID PORT 0 MSG TYPES

SPEC1   LA      R5,ACTIV0,,     :SET UP CALLING ADDRESS
        JAL     R4,ACTIV        :ACTIVATE USER PORT 0 MSG ROUTINE
SPEC2   JAL     R4,ELIR         :END LOGICAL INPUT RECORD
        J       INPUT1          :AND GO BACK FOR MORE....
:
:       NOT A PORT ZERO MESSAGE
:
:       R1=PORT#        R2=MSG TYPE
:
INPUT2  JAL     R4,GETCH        :GET MSG TYPE
        TBT     R0,DATAM        :TEST IF DATA MESSAGE
        JE      INPUT3          :SKIP IF NOT
:
        TBT     RPORT,DEM       :TEST IF PORT IS IN DEFERED ECHO MODE
        JE      INDATA          :SKIP IF NOT
        TBT     RPORT,PECHO     :SHOULD DEM BE HONORED?
        JE      INDATA          :SKIP IF NOT
        LR      R2,R0           :COPY MSG LENGTH
        LR      R5,R0           :COPY IT AGAIN
        ST      R14,REGSAV      :SAVE INPUT RING POINTER REGISTER
:
ECHO1   JAL     R4,GETCH        :GET A CHARACTER
        STB     R0,ECHOBF,R5    :PUT IT INTO ECHO BUFFER
        SIS     R5,1            :DECREMENT COUNTER
        JGBS    ECHO1           :GO BACK IF MORE CHARS IN RECORD
        LR      R5,R2           :COPY CHAR COUNT
        LHI     R0,3,R2         :CALCULATE MSG LENGTH
        JAL     R4,SLOR         :START LOGICAL OUTPUT RECORD
ECHO2   LB      R0,ECHOBF,R5    :GET A CHARACTER FROM ECHO BUFFER
        JAL     R4,PUTCH        :PUT IT INTO OUTPUT RING
        SIS     R5,1            :DECREMENT COUNTER
        JGBS    ECHO2           :REPEAT IF MORE
        JAL     R4,ELOR         :ALL DONE.. END LOGICAL RECORD
:
:       NOTE THAT BACKPRESSURE AND TRANSMIT LIMIT ARE NOT CHECKED
:       IN SERVICING THE DEFERED ECHO.
:
        L       R14,REGSAV      :RESTORE INPUT RING POINTER


:
INDATA  LHL     RDCB,PORTAB,RPORT,RPORT :GET DCB POINTER
        JEFS    INDCR           :CRASH IF NO DCB
        LHL     R4,DCBLKS+ACTIVD,RDCB,  :GET DATA ACTIVATION ROUTINE FOR PORT
        JNFS    INDAT1          :TEST IF THERE IS A ROUTINE
INDCR   JAL     R10,CRASH       :CRASH IF NO ROUTINE
        BC      0,0,4*RDCB,CRNAR
:
  IF    AUTOBP
:
:       CHECK IF INPUT PORT SHOULD BE BACKPRESSURED
:
INDAT1  STH     RPORT,SPORT     :PRESERVE R1
        STH     RDCB,SDCB       :PRESERVE RDCB
        LA      R5,SEG|A.CODE|,R4       :SET UP ACTIVATION ADDRESS
        JAL     R4,ACTIV        :ACTIVATE
        JAL     R4,ELIR         :END THE INPUT RECORD
        LHL     RDCB,SDCB       :RESTORE DCB POINTER
        LH      R0,DCBLKS+DCBICC,RDCB,  :GET INPUT CHAR COUNT
        SHI     R0,MAXCHAR      :TEST IF TOO MANY CHARACTERS
        JL      INPUT1          :NO... GO BACK FOR MORE 
        LHL     RPORT,SPORT     :RESTORE PORT NUMBER
        LIS     R0,3            :GENERATE BACKPRESSURE MESSAGE
        LHI     R2,NOSMSG       :
        JAL     R4,SLOR         :START THE RECORD
        JAL     R4,ELOR         :END IT
        RBT     RPORT,FRISIS    :SET BP INDICATOR FOR PORT
        J       INPUT1          :AND GO BACK FOR MORE
  ELSE
:
INDAT1  LA      R5,SEG|A.CODE|,R4       :SET UP ACTIVATION ADDRESS
        JAL     R4,ACTIV        :ACTIVATE
        JAL     R4,ELIR         :END THE INPUT RECORD
        J       INPUT1          :AND GO BACK FOR MORE
  EI

        SEG     A.DATA
ECHOBF  BS      FIRST   :ECHO BUFFER

        SEG     A.CODE


:
:       PROCESS CONTROL MESSAGES
:
INPUT3  LR      R3,R0           :COPY MSG TYPE
        JN      INCNTL          :NOT A NEEDLE....SKIP
        SBT     RPORT,ACP               :TEST AND SET ACTIVE PORT BIT
        JEFS    NEEDLE          :SKIP IF PORT WAS NOT ACTIVE
        JAL     R10,CRASH       :OTHERWISE CRASH
        BC      0,0,4*RPORT,CRINVN
:
:       PROCESS NEEDLES
:
NEEDLE  LHI     R0,FIRST-1      :SET UP TRANSMIT LIMIT
        STB     R0,XLIMIT,RPORT :STORE IT
        SBT     RPORT,TOISIS    :CLEAR BACKPRESSURE
        SBT     RPORT,FRISIS    :
 IF     OUTPROC
        RBT     RPORT,OUTDAT    :CLEAR OUTPUT DATA WAITING
 EI
  IF PTIMEO
        RBT     RPORT,PTIME     :CLEAR PORT TIMEOUT
  EI
        JAL     R4,GETCH        :SKIP LENGTH
        JAL     R4,GETW         :GET INVOICE NUMBER
        LR      R6,R0           :COPY IT
        JAL     R4,GETH         :GET DESTINATION HOST
        LR      R7,R0           :COPY IT
        JAL     R4,GETH         :GET SOURCE NODE
        LR      R8,R0           :COPY IT
        JAL     R4,GETH         :GET SOURCE HOST
        LR      R9,R0           :COPY IT
        JAL     R4,GETH         :GET SOURCE PORT
        LR      R10,R0          :COPY IT
        JAL     R4,GETW         :FUTURE EXPANSION
        JAL     R4,GETH         :GET DIALECT CODE
        LR      R11,R0          :COPY IT
        JAL     R4,GETCH        :GET TID
        LR      R13,R0          :COPY IT
:
  IF    ECHO
:               SOURCE NODE SHOULD ECHO
        THI     R13,1F          :CHECK IF TERMINAL
        JE      NEED2           :SKIP... NOT A TERM
        ST      R14,REGSAV      :SAVE INPUT RING POINTER
        THI     R13,20          :CHECK IF HALF DUPLEX
        JNFS    NEED1           :SKIP IF HDX.. DON'T SET DEM
        SBT     RPORT,DEM       :SET DEM
NEED1   LIS     R0,5            :SEND SET TERM PARM MSG
        LHI     R2,STPMSG       :
        JAL     R4,SLOR         :START THE OUTPUT RECORD
        LIS     R0,0
        JAL     R4,PUTCH        :
        LIS     R0,1            :SET ECHO ON
        JAL     R4,PUTCH        :
        JAL     R4,ELOR         :
        L       R14,REGSAV      :RESTORE INPUT RING POINTER
  EI
:
NEED2   JAL     R4,GETCH        :GET USERNAME LENGTH
        LR      R2,R0           :COPY USERNAME LENGTH
        LA      R5,ACTIVN,,     :SET UP NEEDLE ACTIVATION ROUTINE ADDR
        JAL     R4,ACTIV        :ACTIVATE IT
        JAL     R4,ELIR         :END THE INPUT RECORD
        J       INPUT1          :AND GO BACK FOR MORE

:
:
:       PROCESS NON-NEEDLE CONTROL MESSAGES FOR PORTS
:
INCNTL  SHI     R3,FIRST                :SUBTRACT TO GET RELATIVE MSG NUMBER
        SLLS    R3,1                    :FORM HALFWORD INDEX
        LHL     RDCB,PORTAB,RPORT,RPORT :GET DCB POINTER
        JE      INCN1                   :CRASH IF NO DCB
        LHL     R4,DCBLKS+ACTIVC,RDCB,  :GET TABLE POINTER
        JEFS    INCN1                   :SKIP IF NO TABLE ADDRESS
        LHL     R4,SEG|A.CODE|,R4,R3    :GET ROUTINE ADDRESS
        JEFS    INCN1                   :SKIP IF NO ROUTINE ADDRESS
        LA      R5,SEG|A.CODE|,R4       :SET UP ACTIVATION ADDRESS
        JAL     R4,ACTIV                :ACTIVATE
        JAL     R4,ELIR                 :END THE LOGICAL RECORD
        J       INPUT1                  :AND GO BACK FOR MORE
:
INCN1   JAL     R10,CRASH               :CRASH IF NO ROUTINE
        BC      0,0,4*RDCB,CRNAR


:       INITIALIZATION FOR THIS PACKAGE
:
IZFRNT  ST      R0,RETPTR       :SAVE RETURN ADDRESS
        LHI     RPORT,NPORT-1   :SET UP LOOP
IZIN1   RBT     RPORT,ACP       :SET PORT NOT ACTIVE
        SBT     RPORT,TOISIS    :SET BACKPRESSURE OFF
        SBT     RPORT,FRISIS    :
 IF     OUTPROC
        RBT     RPORT,OUTDAT    :RESET OUTPUT DATA WAITING
 EI
        RBT     RPORT,DEM       :NOT DEFERED ECHO MODE
        SIS     RPORT,1         :DECREMENT LOOP COUNTER
        JGEBS   IZIN1           :REPEAT IF MORE
:
  IF    AUTOBP                  :AUTOMATIC BACKPRESSURE RELEASE CODE
        L       R7,FASTC,,      :GET CURRENT TIME
        LA      R0,RELBP        :PUT RELBP ON TIMEOUT LIST
        LHI     R1,RATE/2,R7    :SET HALF SECOND TIMEOUT
        JAL     R5,TOPUT        :
  EI
:
  IF    PTIMEO                  :PORT TIMEOUT CODE
        L       R7,FASTC,,      :GET CURRENT TIME
        LA      R0,ONESEC       :PUT ONESEC ON TIMEOUT LIST
        LHI     R1,RATE,R7      :SET ONE SECOND TIMEOUT
        JAL     R5,TOPUT        :
  EI
        JFS     RET             :RETURN
:
:       GENERAL RETURN ROUTINE
RET     L       R0,RETPTR       :GET RETURN ADDRESS
        JR      R0              :AND RETURN
:
:       ACTIVATION ROUTINE
:
ACTIV   ST      R4,RETRN        :SAVE RETURN ADDRESS
  IF    PTIMEO
:               PORT TIMEOUT CODE
        STH     RPORT,SPORT     :PRESERVE PORT NUMBER
        JALR    R5,R5           :ACTIVATE
        J       ACTIV2          :NORMAL RETURN DON'T MODIFY TIMEOUT
        LHL     RPORT,SPORT     :RESTORE PORT NUMBER
        LR      R0,R0           :TEST RETURN PARAMETER
        JGFS    ACTIV1          :NONZERO... SKIP
        RBT     RPORT,PTIME     :TURN OFF PORT TIMEOUT INDICATOR
        JFS     ACTIV2          :
ACTIV1  SBT     RPORT,PTIME     :SET PORT TIMEOUT INDICATOR ON
        A       R0,SLOWC,,      :ADD TIMEOUT TO SLOW CLOCK
        SLHLS   RPORT,2         :MAKE WORD INDEX POINTER
        ST      R0,ATIME,RPORT  :STORE ACTIVATION TIME
  ELSE
        JALR    R5,R5           :ACTIVATE
  EI
ACTIV2  L       R4,RETRN        :RESTORE RETURN ADDRESS
        JR      R4              :AND RETURN
:
  IF    AUTOBP
:
:               CODE TO PERIODICALLY CHECK IF BACKPRESSURE CAN
:               BE RELEASED ON ANY PORTS
RELBP   AHI     R1,RATE/2               :
        JAL     R5,TOPUT        :PUT BACK ON TIMEOUT LIST FOR ONE SECOND
:
:       CHECK ALL PORTS FOR THOSE WITH BACKPRESSURE APPLIED
:
        LHI     R5,(NGRP-1)*2   :
        LHI     R6,(NGRP-1)*10  :SET UP POINTERS
RBP1    LCS     R7,1            :
        XH      R7,FRISIS,R5    :CHECK IF BACKPRESSURE APPLIED
        NH      R7,ACP,R5       :AND PORT ACTIVE
RBP2    LR      R1,R7           :TEST
        JNFS    RBP3            :SKIP.. SOMETHING TO DO
        SIS     R5,2            :DECREMENT POINTERS
        SHI     R6,10           :
        JGEBS   RBP1            :CHECK NEXT RING GROUP
        J       TORET           :OTHERWISE RETURN
:
RBP3    JAL     R3,BIDH         :DETERMINE WHICH PORT ON GROUP NEEDS SERVICE
        XH      R7,HMASK,R2,R2  :MARK PORT AS SERVICED
        AR      R2,R6           :FORM PORT NUMBER
        LR      RPORT,R2                :COPY IT
        SLHLS   R2,2            :FORM BUFFER NUMBER
        LHL     RDCB,PORTAB,RPORT,RPORT :GET DCB POINTER FROM PORT TABLE
        LH      R0,DCBLKS+DCBICC,RDCB,  :GET INPUT CHAR COUNT
        SHI     R0,MAXCHAR      :TEST IF LESS THAN MAXCHAR
        JG      RBP2            :NOT EMPTY ENOUGH YET
        SBT     RPORT,FRISIS    :RELEASE BACKPRESSURE
        LIS     R0,3            :FORM 3 BYTE MESSAGE
        LHI     R2,SNDMSG       :GET MESSAGE
        JAL     R4,SLOR         :START LOGICAL OUTPUT RECORD
        JAL     R4,ELOR         :END IT
        J       RBP2            :AND CONTINUE
  EI
  IF    PTIMEO
:
:               CODE TO CHECK PERIODICALLY FOR PORT TIMEOUTS
:
ONESEC  AHI     R1,RATE         :SET UP TO RUN AGAIN IN ONE SECOND
        JAL     R5,TOPUT        :
        LHI     R15,(NGRP*2)-2  :SEARCH BY GROUPS
OS1     LH      R14,ACP,R15     :GET ACTIVE PORT INDICATORS
        NH      R14,PTIME,R15   :AND IN PORTS ON TIMEOUT
        JNFS    OS3             :JUMP IF ANY TO CHECK
OS2     SIS     R15,2           :DECREMENT GROUP INDEX
        JGEBS   OS1             :REPEAT IF MORE
        J       TORET           :OTHERWISE EXIT
:
OS3     LR      R1,R14          :COPY MASK OF PORTS TO PROCESS
        JEBS    OS2             :NONE... GO ON TO NEXT GROUP
        JAL     R3,BIDH         :FIND FIRST
        XH      R14,HMASK,R2,R2 :SET IT EXAMINED
        LR      R1,R15          :COPY GROUP INDEX
        SLHLS   R1,3            :MAKE GROUP INDEX INTO PORT OFFSET
        AR      RPORT,R2        :MAKE PORT NUMBER
        LR      R2,RPORT        :COPY PORT NUMBER
        SLHLS   R2,2            :MAKE INTO FULLWORD INDEX
        L       R0,ATIME,R2     :GET ACTIVATION TIME
        S       R0,SLOWC,,      :SUBTRACT CURRENT TIME
        JG      OS3             :NOT READY.. IGNORE FOR NOW
        LHL     RDCB,PORTAB,RPORT,RPORT :GET DCB POINTER
        JNFS    OS4             :SKIP IF GOT A DCB
OSCR    JAL     R10,CRASH       :CRASH
        BC      0,0,4*RDCB,CRNAR        :NO ACTIVATION ROUTINE
:
OS4     LHL     R4,DCBLKS+ACTIVT,RDCB,  :GET ACTIVATION ROUTINE
        JEBS    OSCR            :CRASH IF NO ROUTINE
        LA      R5,SEG|A.CODE|,R4       :SET UP ACTIVATION ADDRESS
        STM     R14,TSAVE       :PRESERVE WORK REGISTERS
        JAL     R4,ACTIV        :ACTIVATE
        LM      R14,TSAVE       :RESTORE WORK REGISTERS
        J       OS3             :GO BACK FOR MORE
:
:       SET AND CLEAR TIMEOUT ROUTINES
:               LINK ON R4
:               EXPECT R1 = PORT NUMBER
:                      R0 = TIMEOUT INTERVAL IN SECONDS (SETTO)
:               SMASHES R0
:
        GL      SETTO,CLRTO
:
SETTO   SBT     RPORT,PTIME     :SET PORT TIMEOUT INDICATOR
        A       R0,SLOWC,,      :ADD TO CURRENT TIME
        SLHLS   RPORT,2         :MAKE INTO FULLWORD POINTER
        ST      R0,ATIME,RPORT  :STORE TIME
        SRHLS   RPORT,2         :MAKE BACK INTO PORT NUMBER
        JR      R4              :AND RETURN
:
CLRTO   RBT     RPORT,PTIME     :RESET PORT TIMEOUT INDICATIOR
        JR      R4              :AND RETURN
  EI
:


:       CONTROL MESSAGE ACTIVATION ROUTINES
:
:       TOSS A MESSAGE
TOSS    LB      R0,LENGTH,R2    :PICK UP MESSAGE LENGTH
        SIS     R0,1            :WE'VE ALREADY GOTTEN MESSAGE TYPE
        AR      R14,R0          :ADVANCE POINTER TO END OF MSG
        JR      R5              :RETURN
:
:       ZAPPER ACKNOWEDGEMENT
:
ZACK    EQ      .
:
:       DISCONNECT
ZAP     JAL     R4,EMPTYI,,     :EMPTY INPUT BUFFER
        JAL     R4,EMPTYO,,     :EMPTY OUTPUT BUFFER
        RBT     RPORT,ACP       :SET PORT NOT ACTIVE
        RBT     RPORT,DEM       :SET PORT NOT IN DEM
        JR      R5              :RETURN
:
:       APPLY BACKPRESSURE
NOSEND  RBT     RPORT,TOISIS    :TURN IT OFF FOR PORT
        JR      R5              :RETURN
:
:       RELEASE BACKPRESSURE
RESEND  SBT     RPORT,TOISIS    :TURN IT ON FOR PORT
        JR      R5              :RETURN
:
:       GOBBLER
GOBBLE  JAL     R4,EMPTYI,,     :EMPTY INPUT BUFFER
        SBT     RPORT,FRISIS    :RELEASE BACKPRESSURE
        JR      R5              :AND RETURN
:
:       FLUSH BACKWARD
FLBACK  JAL     R4,EMPTYO,,     :EMPTY OUTPUT BUFFER
        LIS     R0,3            :SEND GOBBLER IN OTHER DIRECTION
        LHI     R2,GOBMSG       :CREATE MESSAGE
        JAL     R4,SLOR         :START LOGICAL OUTPUT RECORD
        JAL     R4,ELOR         :END IT
        JR      R5              :AND RETURN
:
:       ENTER DEM
EDEM    SBT     RPORT,DEM       :SET INDICATOR
        JR      R5              :RETURN


:
:       LEAVE DEM
LDEM    RBT     RPORT,DEM       :CLEAR INDICATOR
        JR      R5              :RETURN
:

:       GREEN BALL
GB      LIS     R0,3            : RETURN GREEN BALL
        LHI     R2,GBMSG        :CREATE MESSAGE
        JAL     R4,SLOR         :START LOGICAL OUTPUT RECORD
        JAL     R4,ELOR         :END IT
        JR      R5              :AND RETURN
:
:       RED BALL
RB      LIS     R0,3            :RETURN THE RED BALL
        JAL     R4,SLOR         :START LOGICAL OUTPUT RECORD
        JAL     R4,ELOR         :END IT
        JR      R5              :AND RETURN
:
:       ORANGE (OR BLACK) BALL
OB      LIS     R0,3            :CREATE MESSAGE
        LHI     R2,1,R2         :CREATE OTHER BALL OF PAIR
        JAL     R4,SLOR         :START LOGICAL OUTPUT RECORD
        JAL     R4,ELOR         :END IT
        JR      R5              :AND RETURN
:
:       PSUEDO-NEEDLE
PNEED   LB      R0,LENGTH,R2    :JUST TOSS IT
        SIS     R0,1            :WE ALREADY GOT MSG TYPE
        AR      R14,R0          :ADVANCE POINTER TO END OF MSG
        LHI     R0,FIRST-1      :SET UP DEFAULT TRANSMIT LIMIT
        STB     R0,XLIMIT,RPORT :
        SBT     RPORT,ACP       :SET PORT ACTIVE
        SBT     RPORT,TOISIS    :CLEAR BACKPRESSURE
        SBT     RPORT,FRISIS    :
        JR      R5              :AND RETURN
:
:       TRANSMIT LIMIT
XLIM    JAL     R4,GETCH        :GET RESTRICTION
        CLHI    R0,FIRST-1      :RANGE CHECK
        JLFS    XLIM1           :OK...SKIP
        LHI     R0,FIRST-1      :OTHERWISE SET LIMIT
XLIM1   STB     R0,XLIMIT,RPORT :SET UP RESTRICTION
        JR      R5              :AND RETURN
:
:       INVALID MESSAGE
INVAL   JAL     R10,CRASH
        BC      0,0,4*R5,CRINVM

 IF     OUTPROC

:       OUTPUT PROCESS ROUTINE
:
OUTPUT  ST      R0,RETPTR       :SAVE RETURN ADDRESS
        LHI     R11,(NGRP-1)*2  :LOOP COUNTER
OUTP1   LCS     R1,1            :SET UP MASK
        STH     R1,PRTSVC       :SAVE PORT SERVICED MASK
OUTP2   LHL     R1,ACP,R11      :GET ACTIVE PORTS INDICATOR
        NH      R1,OUTDAT,R11   :AND WITH DATA WAITING INDICATOR
        NH      R1,TOISIS,R11   :AND NOT BACKPRESSURED
        NH      R1,PRTSVC       :AND NOT ALREADY SERVICED
        JNFS    OUTP3           :SKIP IF ANYTHING TO DO
        SIS     R11,2           :DECREMENT LOOP COUNTER
        JGEBS   OUTP1           :LOOP
        J       RET             :DONE... RETURN
:
OUTP3   JAL     R3,BIDH         :FIND PORT TO SERVICE
        LR      R1,R11          :COPY PORT OFFSET
        SLHLS   R1,3            :TIMES EIGHT
        AR      RPORT,R2        :PORT NUMBER!
        RBT     R2,PRTSVC       :CLEAR PORT TO BE SERVICED BIT
        LHL     RDCB,PORTAB,RPORT,RPORT :GET DCB POINTER FOR PORT
        JEFS    OUTCR                   :CRASH NO DCB POINTER
        LHL     R4,DCBLKS+ACTIVO,RDCB,  :GET OUTPUT ACTIVATION ROUTINE
        JNFS    OUTP4                   :GOT A ROUTINE...SKIP
:
OUTCR   JAL     R10,CRASH
        BC      0,0,4*RDCB,CRNAR        :NO ACTIVATION ROUTINE
:
OUTP4   STH     R11,SLOOP       :SAVE LOOP COUNTER
        LA      R5,SEG|A.CODE|,R4       :SET UP ACTIVATION ADDRESS
        JAL     R4,ACTIV        :ACTIVATE
        LHL     R11,SLOOP       :RESTORE LOOP POINTER
        J       OUTP2           :LOOP
:
 EI

:       DEFAULT CONTROL MESSAGE ACTIVATION TABLES
:
:       CALCULATE ROUTINE OFFSETS
:
XTOSS   EQ      TOSS-SEG|A.CODE|
XZAP    EQ      ZAP-SEG|A.CODE|
XZACK   EQ      ZACK-SEG|A.CODE|
XNOSEND EQ      NOSEND-SEG|A.CODE|
XRESEND EQ      RESEND-SEG|A.CODE|
XGOBBLE EQ      GOBBLE-SEG|A.CODE|
XFLBACK EQ      FLBACK-SEG|A.CODE|
XEDEM   EQ      EDEM-SEG|A.CODE|
XLDEM   EQ      LDEM-SEG|A.CODE|
XGB     EQ      GB-SEG|A.CODE|
XRB     EQ      RB-SEG|A.CODE|
XOB     EQ      OB-SEG|A.CODE|
XPNEED  EQ      PNEED-SEG|A.CODE|
XXLIM   EQ      XLIM-SEG|A.CODE|
XINVAL  EQ      INVAL-SEG|A.CODE|
:
:       TABLE CREATION MACROS
:
HTABVT  MACRO(TABNAM)
[       SEG     A.CODE
        GL      TABNAM
TABNAM  HC      XZAP,XZAP,XNOSEND,XRESEND,XGOBBLE,XFLBACK       :9E - A3
        HC      XOB,XTOSS,XEDEM,XLDEM,XTOSS,XTOSS               :A4 - A9
        HC      XGB,XRB,XOB,XTOSS,XTOSS,XTOSS                   :AA - AF
        HC      XTOSS,XTOSS,XINVAL,XINVAL,XTOSS,XTOSS           :B0 - B5
        HC      XTOSS,XINVAL,XTOSS,XXLIM,XTOSS,XZACK            :B6 - BB 
        HC      XTOSS,XTOSS,XINVAL,XTOSS,XTOSS                  :BC - C0
]
:
HTABIA  MACRO(TABNAM)
[       SEG     A.CODE
        GL      TABNAM
TABNAM  HC      XZAP,XZAP       :9E - 9F
        RE      0B1-9F
        HC      XTOSS
        NOLIST
        ER
        LIST
        HC      XPNEED,XINVAL   :B2 - B3
        HC      XTOSS,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS            :B4 - B9
        HC      XTOSS,XZACK,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS      :BA - C0
]
:
CHGTAB  MACRO(TABNAM,MSGNUM,ROUTIN)
[
OLDORG  EQ      .
        ORG     TABNAM+(MSGNUM-FIRST)*2
        HC      ROUTIN-SEG|A.CODE|
        ORG     OLDORG
]
        EM
:


	SUBTTL	ICL C03 Foreground Execution Scheduling

	RA	0
	MO	.,C03FEX
	GL	C03EXC,C03EXI,FSTACK

:	DEDICATED REGISTERS

RL	EQ	R13		: CURRENT LINE BEING PROCESSED
RL2	EQ	R9		: Line number * 2
RGRP	EQ	R10		: Pointer to PGRTAB
RSUB	EQ	R11		: Pointer to SUBTAB
RLNE	EQ	R12		: POINTER TO LINTAB
RBBA	EQ	R12		: Big Bufferlet address
RBBX	EQ	R4		: Current negative store index
RSTACK	EQ	R8		: Stack pointer

:	RUN LISTS
:	---------

	SEG	A.DATA
RRUNL	WS	0
	RE	NBILIN
	WC	RRUNOF
	ER

XRUNL	WS	0
	RE	NBILIN
	WC	XRUNOF
	ER

PRUNL	WS	0
	RE	NBILIN
	WC	PRUNOF
	ER

FBIRET	WS	1		: RETURN ADDR
FEXLOP	BS	1		: LOOP CNT FOR F.G. EXEC
	SEG	A.CODE

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		I C L	C 0 3	F O R E G R O U N D		::
::		E X E C U T I O N   S C H E D U L E R		::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:	INITIALIZATION
:	--------------

C03EXI	LR	R2,R1		: MAKE WORD INDEX FOR LINE
	SLHLS	R2,2
	LA	R0,RRUNOF	: RESET RCV RUN LIST
	ST	R0,RRUNL,R2
	LA	R0,XRUNOF	: RESET XMT RUN LIST
	ST	R0,XRUNL,R2
	LA	R0,PRUNOF	: RESET PROTOCOL RUN LIST
	ST	R0,PRUNL,R2
	JR	R5		: RETURN


:	FOREGROUND EXEC LOOP CALL ENTRY
:	-------------------------------

C03EXC	ST	R10,FBIRET	: SAVE RETURN ADDR

	LIS	R10,8
	STB	R10,FEXLOP
C03EX1
:	RECEIVE RUN LIST
:	----------------

	IF	NBILIN-8
	LHI	RL2,(NBILIN-1)*2	: INIT 2 * LINE INDEX
	ELSE
	LIS	RL2,(NBILIN-1)*2	: INIT 2 * LINE INDEX
	EI

	IF	NBILIN-10
	LHI	RL,(NBILIN-1)		: INIT LINE INDEX
	ELSE
	LIS	RL,(NBILIN-1)		: INIT LINE INDEX
	EI

RRUN10
	L	R5,RRUNL,RL2,RL2	: GET ADDR TO RUN
	JR	R5			: GO RUN

RHALT	LA	R5,RRUNOF		: TAKE LINE OFF RUN LIST
RDMISS	ST	R5,RRUNL,RL2,RL2	: DISMISS USER FOR THIS RUN CYCLE

RRUNOF
	IF	NBILIN-1
	SIS	RL,1			: GO TO NEXT LINE
	SIS	RL2,2
	JGEBS	RRUN10
	EI


:	TRANSMIT RUN LIST
:	-----------------

	IF	NBILIN-8
	LHI	RL2,(NBILIN-1)*2	: INIT 2 * LINE INDEX
	ELSE
	LIS	RL2,(NBILIN-1)*2	: INIT 2 * LINE INDEX
	EI

	IF	NBILIN-10
	LHI	RL,(NBILIN-1)		: INIT LINE INDEX
	ELSE
	LIS	RL,(NBILIN-1)		: INIT LINE INDEX
	EI

XRUN10
	L	R5,XRUNL,RL2,RL2	: GET ADDR TO RUN
	JR	R5			: GO RUN

XHALT	LA	R5,XRUNOF		: TAKE LINE OFF RUN LIST
XDMISS	ST	R5,XRUNL,RL2,RL2	: DISMISS USER FOR THIS RUN CYCLE

XRUNOF
	IF	NBILIN-1
	SIS	RL,1			: GO TO NEXT LINE
	SIS	RL2,2
	JGEBS	XRUN10
	EI


:	PROTOCOL RUN LIST
:	-----------------

	IF	NBILIN-8
	LHI	RL2,(NBILIN-1)*2	: INIT 2 * LINE INDEX
	ELSE
	LIS	RL2,(NBILIN-1)*2	: INIT 2 * LINE INDEX
	EI

	IF	NBILIN-10
	LHI	RL,(NBILIN-1)		: INIT LINE INDEX
	ELSE
	LIS	RL,(NBILIN-1)		: INIT LINE INDEX
	EI

PRUN10
	L	R5,PRUNL,RL2,RL2	: GET ADDR TO RUN
	JR	R5			: GO RUN

PHALT	LA	R5,PRUNOF		: TAKE LINE OFF RUN LIST
PDMISS	ST	R5,PRUNL,RL2,RL2	: DISMISS USER FOR THIS RUN CYCLE

PRUNOF
	IF	NBILIN-1
	SIS	RL,1			: GO TO NEXT LINE
	SIS	RL2,2
	JGEBS	PRUN10
	EI


	LB	R10,FEXLOP
	JE	C03EX2
	SIS	R10,1
	STB	R10,FEXLOP
	J	C03EX1
C03EX2

	L	R10,FBIRET	: RETURN TO FOREGROUND EXEC LOOP
	JR	R10
	SUBTTL	ICL C03 Foreground Exec Loop

:	VARIABLE ALLOCATION
:	-------------------

	SEG	A.DATA

DBSAVE	WS	10
FDEBUG	HC	0


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	F O R E G R O U N D	E X E C L O O P		::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	SEG	A.CODE

FSTART	LI	RSTACK,FSTACK		: INITIALISE STACK POINTER

QBEG
	LH	R0,FDEBUG,,		: IF FOREGROUND DEBUG ON
	JG	FTRAP			: IF YES, TRAP F.G CPU TIME

	IF	FEXTRA
	LHL	R4,FEXIND,,
	L	R5,SLOWC,,
	ST	R5,FEXTBL,R4,
	AHI	R4,4
	CLHI	R4,200
	JLEFS	.+4
	LIS	R4,0
	STH	R4,FEXIND,,
	EI

	JAL	R10,C03EXC,,		: SERVICE C03 lines
	SVC	FASTD
	J	FSTART			: GO AGAIN


:	FORGROUND CPU TIME TRAP

FTRAP
FTRAP0
	LH	R0,FDEBUG,,
	JLE	QBEG
	SVC	FASTD
	JBS	FTRAP0

FTRAP1
	STM	R0,DBSAVE,,
	LIS	R1,0
	STH	R1,FDEBUG,,		: CLEAR FDEBUG FLAG
	LM	R0,DBSAVE,,
	SVC	KIO,1			: RETURN TO DDT

FTRAP2
	LIS	R1,1
	STH	R1,FDEBUG,,		: SET FDEBUG FLAG
	SVC	KIO,1			: RETURN TO DDT

	EM

	SUBTTL	Command List Package

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::								::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	**** REVISION HISTORY ****
:	ORIGINAL DESIGN AND CODE -- BY NELSON SU
:	03-JUL-85 (KRR) - Multi-drop implementation
:	29-MAY-85 (KRR/MMJ) - Delete CKCMDL
:	---FEB-85 (MMJ) - FORCED RX3 FORMAT TO ACCOMODATE EDF
:	29-JUN-83 (RNC) -STANDARDIZE Revision History (NO SAR#)
:	JUNE 24, 1983 -- BY NELSON SU, ADD 'Revision History'


	RA	0
	MO	.,CMDLST

	GL	CMDCNT,ERRCMD

:	These routines manage the command lists. The command list pool is
:	a double linked list, from which links can be removed from either
:	ends.
:	NOTE... COMMAND LIST POOL MUST BE LESS THAN 32K BYTES.

RLNK	EQ	4			: LINK REGISTER
RARG	EQ	6			: ARGUMENT REGISTER
RWORK	EQ	7			: WORK REGISTER

:	CRASH CODES
CRCLLK	EQ	50			: COMMAND LIST LOCKED
CRCLMT	EQ	51			: COMMAND LIST EMPTY

	SEG	A.DATA

:	COMMAND CODE VALUES
:	-----------------
:	THE ZERO CMD CODE IS RESERVED TO INDICATE AN EMPTY LIST
:	A CMD CODE GTEATER THAN ZERO INDICATES A DATA MSG
:	(FIRST HALFWORD IS THE BYTE COUNT)
:	(SECOND HALFWORD IS THE POINTER TO THE CMD)
:	(THIRD HALFWORD/FULLWORD IS THE POINTER TO THE DATA)

ERRCMD	EQ	-1		: RESERVE FOR ERROR HANDLER
DISCMD	EQ	-2		: DISCONNECT COMMAND
SELCMD	EQ	-3		: SELECT POLL COMMAND
STACMD	EQ	-4		: STATUS POLL COMMAND
PAKCMD	EQ	-5		: PROGRAM ATTENTION KEY COMMAND
MGWCMD	EQ	-6		: MESSAGE WAIT COMMAND

:	STORAGE AND CONSTANTS
:	---------------------

:	FREE LIST 1
CLLK1	HS	1			: LOCK FOR FREE LIST 1
CFLP1	HS	1			: PTR TO FIRST ENTRY
OFFST1	EQ	0			: OFFSET OF LINKING PTR FOR LIST 1

:	FREE LIST 2
CLLK2	HS	1			: LOCK
CFLP2	HS	1			: PTR TO FIRST ENTRY
OFFST2	EQ	2			: OFFSET OF LINKING PTR

	SEG	A.BDAT


	IF FWBBF
CMDSZ	EQ	8			: EACH LINK IS 8 BYTES
	ELSE
CMDSZ	EQ	6			: EACH LINK IS 6 BYTES
	EI

CLCMD	EQ	0			: OFFSET OF COMMAND IN LINK
CLPTR	EQ	2			: OFFSET OF CMD LIST LINK PTR
CLARG	EQ	CLPTR+2			: OFFSET OF ARGUMENT TO COMMAND
CMDCNT	HS	1			: CNT OF FREE CMD LIST LINKS
CMDBLK	HS	1			: UNUSED
CMD1ST	BS	CMDSZ*NCMDLK		: COMMAND LINK SPACE


	SEG	A.CODE

	SUBTTL	COMMAND LIST UTILITY ROUTINES

:***************************************************************:
:	GETCL - GET A COMMAND LINK FROM FREE POOL		: 
:								: 
:	RARG - PTR TO ALLOCATED LINK (RELATIVE TO CMDBLK)	: 
:	THIS ROUTINE WILL SKIP RETURN IF SUCCESSFUL (GOT A LINK):
:	AND IT MAY CRASH IF BOTH LISTS ARE LOCKED.		: 
:***************************************************************:
GETCL
	LCS	RWORK,1			: DECREMENT FREE LINK CNT
	AHM	RWORK,CMDCNT,,
	JLE	GCL11			: LIST EMPTY,EXIT
	LIS	RWORK,0
	SBT	RWORK,CLLK1		: LIST 1 LOCKED ?
	JEFS	GCL1			: N -
	SBT	RWORK,CLLK2		: LIST 2 LOCKED ?
	JE	GCL2			: N -
	SBT	RWORK,CLLK1		: TEST LOCK 1 AGAIN
	JEFS	GCL1
GCL0
	JAL	R10,CRASH
	BC	0,0,4*RLNK,CRCLLK	: COMMAND LIST LOCKED

:	GET LINK FROM LIST 1
GCL1	LHL	RARG,CFLP1		: GET FREE LIST PTR 1
	CLH	RARG,CFLP2		: COMPARE TO OTHER FREE LIST PTR
	JE	GCL12			: EQUAL - LIST IS EMPTY
	LHL	RWORK,CMDBLK+OFFST1,RARG, :RWORK = PTR TO SECOND LIST ENTRY
	CLH	RWORK,CFLP2		: COMPARE TO OTHER FREE LIST PTR
	JE	GCL12			: EQUAL - TREAT LIST AS EMPTY
	LR	RWORK,RWORK
	JL	GCL0
	STH	RWORK,CFLP1		: UPDATE FREE LIST 1 PTR
	LIS	RWORK,0
	RBT	RWORK,CLLK1		: RESET LOCK
	J	6,RLNK			: SKIP RETURN
:	LIST WAS EMPTY . RELEASE LOCK AND DO STRAIGHT RETURN
GCL11
	LIS	RWORK,1			: RESTORE FREE LIST CNT
	AHM	RWORK,CMDCNT,,
	JR	RLNK
GCL12	LIS	RWORK,0
	RBT	RWORK,CLLK1
	JR	RLNK

:	GET LINK FROM FREE LIST 2
GCL2	LHL	RARG,CFLP2		: RARG = PTR TO FIRST ENTRY
	CLH	RARG,CFLP1		: COMPARE TO OTHER FREE LIST PTR
	JEFS	GCL22			: EQUAL - LIST EMPTY
	LHL	RWORK,CMDBLK+OFFST2,RARG, :RWORK = PTR TO SECOND LIST ENTRY
	CLH	RWORK,CFLP1		: COMPARE TO OTHER FREE LIST PTR
	JEFS	GCL22			: EQUAL - LIST EMPTY
	STH	RWORK,CFLP2		: UPDATE FREE LIST PTR 2
	LIS	RWORK,0
	RBT	RWORK,CLLK2		: RELEASE LOCK
	J	6,RLNK			: SKIP RETURN
:	FREE LIST IS EMPTY - UNLOCK LIST AND RETURN
GCL22	LIS	RWORK,0
	RBT	RWORK,CLLK2
	JR	RLNK

	:*******************************************************:
	:	RELCL - RETURN A CMD LINK TO FREE POOL		:	
	:	REGISTER USAGE LIKE GETCL			:
	:*******************************************************:
RELCL	LIS	RWORK,0
	SBT	RWORK,CLLK1		: TRY TO LOCK LIST 1
	JE	RCL1			: NOT LOCKED -
	SBT	RWORK,CLLK2		: LIST 2 LOCKED ?
	JE	RCL2			: NOT LOCKED -

:	A RACE CONDITION COULD CAUSE US TO GET HERE
:	TRY LIST 1 AGAIN
:	IF STILL LOCKED - CRASH

	SBT	RWORK,CLLK1
	JEFS	RCL1
	JAL	R10,CRASH		: CRASH THE INTERFACE
	BC	0,0,4*RLNK,CRCLLK	: COMMAND LIST LOCKED
:	PUT LINK BACK AT LIST 1 END
RCL1	LHL	RWORK,CFLP1		: RWORK = PTR TO FIRST ENTRY
	STH	RWORK,CMDBLK+OFFST1,RARG, :LINK FIRST ENTRY TO NEW ENTRY
	STH	RARG,CMDBLK+OFFST2,RWORK, :LINK NEW ENTRY TO FIRST ENTRY
	STH	RARG,CFLP1		: MAKE NEW ENTRY THE FIRST ENTRY
	LIS	RWORK,1
	AHM	RWORK,CMDCNT,,		: ADD 1 TO FREE LINK LIST
	LIS	RWORK,0
	RBT	RWORK,CLLK1		: RELEASE LOCK 1
	JR	RLNK			: RETURN
:	PUT LINK BACK ON LIST 2
RCL2	LHL	RWORK,CFLP2		: RWORK = PTR TO FIRST ENTRY
	STH	RWORK,CMDBLK+OFFST2,RARG, :LINK FIRST ENTRY TO NEW ENTRY
	STH	RARG,CMDBLK+OFFST1,RWORK, :LINK NEW ENTRY TO FIRST ENTRY
	STH	RARG,CFLP2		: MAKE NEW ENTRY THE FIRST ENTRY
	LIS	RWORK,1
	AHM	RWORK,CMDCNT,,		: ADD 1 TO FREE LINK LIST
	LIS	RWORK,0
	RBT	RWORK,CLLK2		: RELEASE LOCK 2
	JR	RLNK			: RETURN

	:*************************************************
	: 
	:	IZCFL - INITIALIZE COMMAND FREE LIST
	: 
	:*************************************************
IZCFL	LIS	RARG,0
	LHI	RWORK,NCMDLK-2
	STH	RWORK,CMDCNT,,		: INIT. FREE LINK CNT
	STH	RARG,CLLK1		: LOCK 1 = 0
	STH	RARG,CLLK2		: LOCK 2 = 0
	LHI	RARG,CMD1ST-CMDBLK	: OFFSET OF FIRST LINK
	STH	RARG,CFLP1		: FREE LIST 1 PTR = FIRST LINK
IZCFL1	LR	RWORK,RARG
	AIS	RARG,CMDSZ		: RARG = NEXT LINK
	STH	RARG,CMDBLK+OFFST1,RWORK, : LINK NEXT ENTRY TO CURRENT ONE
	STH	RWORK,CMDBLK+OFFST2,RARG, : LINK CURRENT TO NEXT
	CLHI	RARG,CMDSZ*(NCMDLK-1)	: LAST LINK REACHED ?
	JLBS	IZCFL1			: NO - CONTINUE
	STH	RARG,CFLP2		: FREE LIST PTR 2 = LAST LINK
	JR	RLNK			: RETURN

	:*****************************************************
	:	COMMAND LIST MACROS
	: 
	:	IZCL - INITIALIZE A COMMAND LIST
	: 
	:	PUTCMD - PUT A COMMAND INTO A LIST
	: 
	:	RLCMD - RELEASE ALL COMMANDS IN A LIST
	:		(THIS MAKES THEM ACCESSIBLE TO PEEKS)
	: 
	:	PKCMD - PEEK AT A COMMAND
	: 
	:	ADVCMD - REMOVE THE FIRST COMMAND FROM THE LIST
	: 
	:	REGISTER USAGE
	: 
	:	R2 - COMMAND CODE
	:	R3 - SECOND HALFWORD OF THE COMMAND
	:	RLNK - LINK TO GETCL AND RELCL
	:	RARG - PTR TO CMD LINK (PARM TO GETCL / RELCL )
	:	RWORK - WORK REGISTER
	:	RSUB - CURRENT SUB CONTROL BLOCK ADDR (OFFSET)
	:	RGRP - CURRENT POLL GROUP CONTROL BLOCK ADDR

	:	PKCMD SETS CONDITION CODE TO ZERO IF CMD LIST IS EMPTY
	:	OTHERWISE THE VALUE OF R2 DETERMINES THE CONDITION CODE
	: 
	:	NAMING CONVENTIONS
	: 
	:	LNAME - COMMAND LIST NAME (RCV,XMT,OUT,IN,ETC.)
	:	EACH LIST HAS A GET , RELEASE AND PUT PTRS
	:	WHOSE NAME IS DERIVED FROM THE LIST NAME
	:********************************************************

IZCL	MACRO(LNAME,RSUB,RGRP)
	[
	JAL	RLNK,GETCL,,			: GET A FREE LINK
	JAL	RLNK,CLMPTY,,
	LIS	R0,0
	STH	R0,SUBTAB+SCC`LNAME,RSUB,	: INIT. CMD LIST CNT
	STH	R0,SUBTAB+SDC`LNAME,RSUB,	: INIT. DATA CMD CNT
	STH	R0,CMDBLK+CLCMD,RARG,		: CLEAR CLCMD FIELD
	STH	R0,CMDBLK+CLPTR,RARG,		: CLEAR CLPTR FIELD
	BBSTOR	R0,CMDBLK+CLARG,RARG,		: CLEAR CLARG FIELD
	STH	RARG,SUBTAB+SGP`LNAME,RSUB,	: SET GET,RELEASE AND PUT PTRS
	STH	RARG,SUBTAB+SRP`LNAME,RSUB,
	STH	RARG,SUBTAB+SPP`LNAME,RSUB,
	LB	R0,SUBTAB+SUBPGR,RSUB,		: GET STAION`S REL ID.
	RBT	R0,PGRTAB+LNAME`DAT,RGRP,	: RESET DATA PRESET
	]

PUTCMD	MACRO(LNAME,RSUB)
	[
	JAL	RLNK,GETCL,,			: GET A FREE LINK
	JAL	RLNK,CLMPTY,,
	LIS	R0,0
	STH	R0,CMDBLK+CLCMD,RARG,		: CLEAR CLCMD FIELD
	STH	R0,CMDBLK+CLPTR,RARG,		: CLEAR CLPTR FIELD
	BBSTOR	R0,CMDBLK+CLARG,RARG,		: CLEAR CLARG FIELD
	LHL	RWORK,SUBTAB+SPP`LNAME,RSUB,	: GET PUT PTR
	STH	R2,CMDBLK,RWORK,
	BBSTOR	R3,CMDBLK+CLARG,RWORK,
	STH	RARG,CMDBLK+CLPTR,RWORK,	: LINK NEW ENTRY
	STH	RARG,SUBTAB+SPP`LNAME,RSUB,
	LIS	RARG,1
	AHM	RARG,SUBTAB+SCC`LNAME,RSUB,	: ADD ONE TO LINK USE CNT
	LR	R2,R2				: DATA CMD?
	JLEFS	.+8				: NO,JUMP
	AHM	R2,SUBTAB+SDC`LNAME,RSUB,	: YES,IN. DATA USE CNT
	]

RLCMD	MACRO(LNAME,RSUB,RGRP)
	[
	LHL	RARG,SUBTAB+SPP`LNAME,RSUB,
	STH	RARG,SUBTAB+SRP`LNAME,RSUB,	: SET RELEASE PTR = PUT PTR
	LB	R0,SUBTAB+SUBPGR,RSUB,		: GET REL STATION ID.
	SBT	R0,PGRTAB+LNAME`DAT,RGRP,	: SET DATA PRESENT
	]

PKCMD	MACRO(LNAME,RSUB)
	[
	LIS	R2,0
	LHL	RARG,SUBTAB+SGP`LNAME,RSUB,
	CLH	RARG,SUBTAB+SRP`LNAME,RSUB,
	JEFS	.+0E
	BBLOAD	R3,CMDBLK+CLARG,RARG,
	LH	R2,CMDBLK,RARG,
	LR	R2,R2 ]

ADVCMD	MACRO(LNAME,RSUB,RGRP)
	[
	LHL	RARG,SUBTAB+SGP`LNAME,RSUB,
	CLH	RARG,SUBTAB+SRP`LNAME,RSUB,	: IS LIST EMPTY
	JE	CLMPTY,,
	LCS	RWORK,1				: DECREMENT CNT USE
	AHM	RWORK,SUBTAB+SCC`LNAME,RSUB,
	LIS	RWORK,0
	SH	RWORK,CMDBLK,RARG,		: GET CMD CODE
	JGEFS	.+8				: JUMP,IF NOT DATA CMD
	AHM	RWORK,SUBTAB+SDC`LNAME,RSUB,	: DATA CMD,DEC. DATA USE CNT
	LHL	RWORK,CMDBLK+CLPTR,RARG,
	JE	CLERR,,				: CRASH IF ADVANCING EMPTY LIST
	STH	RWORK,SUBTAB+SGP`LNAME,RSUB,
	LB	R0,SUBTAB+SUBPGR,RSUB,		: GET REL STAION ID.
	RBT	R0,PGRTAB+LNAME`DAT,RGRP,	: FIRST TURN OFF DATA PRES.
	CLH	RWORK,SUBTAB+SRP`LNAME,RSUB,	: COMPARE GET AND REL. PTRS.
	JEFS	.+08				: SKIP IF EQUAL
	SBT	R0,PGRTAB+LNAME`DAT,RGRP,	: NOT EMPTY, TURN ON DATA PRES.
	JAL	RLNK,RELCL,,
	]

CLERR	JAL	R10,CRASH			: BAD COMAND ADVANCE
	BC	0,0,0,99


	:	CLMPTY - CALLED BY PUTCMD WHEN IT CAN'T GET A FREE CMD
	:	LINK
CLMPTY	JAL	R10,CRASH,,			: CRASH THE INTERFACE
	BC	0,0,01,CRCLMT			: CMD LIST EMPTY

	EM


	SUBTTL	ICL C03 Line Receiver Module


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::								::	
::	I C L	C 0 3	R C V	R E T U R N	C O D E		::
::								::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:	The purpose of this module is to identify the type of
:	message received and to set up a return code for the
:	Protocol Manager (C03HPH).

	RA	0
	MO	.,C03RCV

	LO	C03BLK			: CONTROL BLOCK INFORMATION
	LO	MONBLK
	LO	MAIN
	LO	C03FEX			: ACCESS BISYNC F.G. EXEC RUN LISTS

RCLSYN	EQ	0			: LOST SYNCHRONIZATION
RCOVRN	EQ	1			: OVERRUN (MORE DATA THAN BB SPECIFIED)
RCTMOT	EQ	2			: TIMEOUT BEFORE MSG RECEIVED
RCLOST	EQ	3			: LOST DATD DUE TO INAVAL. OF BB
RCUNID	EQ	4			: UNDEFINED MSG.
RCPERR	EQ	5			: RCV Parity error
RCBADD	EQ	6			: CRC ERROR IN DATA MSG
RCSELR	EQ	7			: Error in a select
RCSEL	EQ	8			: Valid select
RCPOLL	EQ	9			: Valid poll seen


:	DEDICATED REGISTERS

REX	EQ	R14			: LINE INPUT RING EMPTY INDEX
RAD	EQ	R15			: ADDR(LINE INPUT RING)
RLP	EQ	R4			: LEAD POINTER FOR SCAN
RBBX	EQ	R4			: BIG BUFFERLET INDEX(CHAR LAST STORED)
RBBA	EQ	R12			: ADDR(CURRENT BIG BUFFERLET)
RST	EQ	R11			: ADDR(CURRENT STATE TABLE)
RRET	EQ	R2			: STATE PROCESS LINK REG
RCRC	EQ	R2			: CRC ACCUMULATOR
RC	EQ	R1			: RCV CHARACTER REG

:	VARIABLES FOR SYNCHRONIZATIONS AND STATE PROCESSOR
:	--------------------------------------------------

	SEG	A.DATA
RTIME	WS	NBILIN			: TIME TO FORCE RCV OP COMPLETE (FASTC)
RSTPTM	WS	NBILIN			: TIME OF STATE PRO. DISMISS

RRETAD	HS	NBILIN			: OP COMPLETE RETURN ADDR REL TO RSEG
RSTATE	HS	NBILIN			: ADDR STATE TABLE (REL TO RSEG)
RBBADR	HS	NBILIN			: ADDR CURRENT BB (REL TO BBUFER)
RBBINX	HS	NBILIN			: INDEX OF LAST CHAR STORED INTO BB
RORUNC	HS	NBILIN			: MAX # OF BUFFERLETS BEFORE OVERRUN


ROBCNT	HS	NBILIN			: PARTIAL RCV BYTE CNT (ADD (RBBX)
					: TO GIVE TOTAL BYTE CNT)
RLSYNC	HS	NBILIN			: ADDR LOST SYNC PROCESS (REL TO RSEG)
RBBCHN	HS	NBILIN			: ADDR 1ST BUFFERLET IN DATA MSG CHAIN
RRGETX	HS	NBILIN			: RCV RING EMPTY INDEX
CNTBCC	HS	NBILIN			: COUNT FOR RECEIVING BCC ERROR
CNTPER	HS	NBILIN			: COUNT FOR RECEIVING PARITY ERROR
CNTUDM	HS	NBILIN			: COUNT FOR RECEIVING UNDEFINED ID
CNTORN	HS	NBILIN			: COUNT RCV BB OVERRUN (OR BB ERROR)
CNTRTO	HS	NBILIN			: COUNT FOR RECEIVING TIME OUT

RCRCER	HS	(NBILIN-1)/10+1		: CRC ERROR BIT ARRAY
WATBCC	HS	(NBILIN-1)/10+1		: WAIT FOR BCC BIT ARRAY
DLOST	HS	(NBILIN-1)/10+1		: Data lost flag bit array

RACCRC	BS	NBILIN			: CRC ACCUMULATOR
RBYTEL	BS	NBILIN			: LAST BYTE OF RCV RING DATA
RSHIFT	BS	NBILIN			: SHIFT CNT TO FRAME CHARACTER
SYNNUM	BS	NBILIN			: LEADING SYN ACCUMULATE AREA
RCSAVE	BS	NBILIN			: RETURN CODE SAVE AREA
RCVGRP	BS	NBILIN			: RCV GRP SAVE AREA
RCVSUB	BS	NBILIN			: RCV SUB SAVE AREA
RCVPRE	BS	NBILIN			: HOLDS LAST PREFIX RECVD
RCVD1	BS	NBILIN			: HOLDS FIRST BYTE OF DATA RCVD
RCSAC	BS	NBILIN			: SAC byte in the select
RCSACQ	BS	NBILIN			: SAC qualifier byte


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			R I N G	D E F I N I T I O N S			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

RRSIZE	EQ	100			: DATA BYTES IN ISIS SYNC INPUT RING

	SEG	A.RING			: DEFINE RING FOR EACH LINE
RRING	HS	(1+RRSIZE/2)*NBILIN
SECT	HS	(RRSIZE/2)*NBILIN

	SEG	A.CODE
RRINGX	WS	0			: ADDRESS TABLE OF START OF EACH RING
Q	EQ	0
	RE	NBILIN
	WC	RRING+Q*(2+RRSIZE)
Q	EQ	Q+1
	ER


Q	EQ	0
ISECT	WS	0			: ADDRESS OF INPUT BUFFER
	RE	NBILIN
	WC	SECT+Q*(RRSIZE)
Q	EQ	Q+1
	ER


:	CHARACTER IDENTIFICATION TABLE
:	------------------------------

DEFIDC	MACRO(CHAR)[NOLIST
QQ	EQ	.
	ORG	BIDCHR+CHAR
BIDCHX	EQ	BIDCHX+2
	LIST
	BC	BIDCHX
	ORG	QQ]

BIDCHR	BS	0			: IDENTIFICATION TABLE INITIALIZATION
	RE	100;	NOLIST
	BC	0;	ER;	LIST
BIDCHX	EQ	0			: INIT ID INDEX


:	DEFINE CONTROL CHAR'S OF INTEREST IN 'BIDCHR' TABLE
:	---------------------------------------------------

	DEFIDC(SYN)
	DEFIDC(SOH)
	DEFIDC(STX)
	DEFIDC(ETX)
	DEFIDC(DLE)
	DEFIDC(NAK)
	DEFIDC(ACK)
	DEFIDC(ENQ)
	DEFIDC(EOT)
	DEFIDC(ETB)


	SUBTTL	ICL C03 HIF Receive Routines


:	RING INDEX ADVANCEMENT MACRO
RRADVC	MACRO(REG)[
	AIS	REG,2
	LBR	REG,REG]

RWCI	MACRO(RC)
	[
	LIS	R4,1
	AHM	R4,ROBCNT,RL2			: inc count of data stored
	
	LH	RBBX,RBBINX,RL2			: get current pointer
	AIS	RBBX,1				: ADVANCE POINTER
	STB	RC,BBUFER+BBFLSZ-2,RBBX,RBBA	: PUT DATA
	JNFS	.+6
	JAL	R5,RWCIB

	STH	RBBX,RBBINX,RL2]

LDRGRP	MACRO(REG)[
	LHL	REG,LINPTR,RL,RL	: LOAD LINTAB POINTER
	PGLOAD	RGRP,LINTAB+CPRGRP,REG,	: LOAD RGRP
]

VALGRP	MACRO	[
	LR	R4,R0			: USE R4 AS WORK REG
	SHI	R4,BGRPAD		: IS THIS GRP IN THE RANGE?
	JL	RPUNID			: JUMP,IF NOT IN THE RANGE
	SRLS	R4,2			: Group is in multiple of 4
	CLHI	R4,MAXGRP		: IS THIS GRP OUT OF RANGE?
	JGE	RPUNID			: JUMP,IF OUT OF RANGE
	SLLS	R4,1
	LHL	R3,LINPTR,RL,RL		: GET LINTAB POINTER
	PGLODS	RGRP,LINTAB+PGRPTR,R3,R4 : GET RGRP
	JL	RPUNID			: JUMP,IF NOT SUPPORTED
	PGSTOR	RGRP,LINTAB+CPRGRP,R3,	: SAVE IT
	STB	R0,RCVGRP,RL		: Store the group in save area
]




:	NEED NEW BIG BUFFERLET. IF THIS BUFFERLET FETCH EXCEEDS
:	OVERRUN CNT, END RECEIVE AS OVERRUN. IF BUFFERLET IS NOT
:	AVAILABLE, FLAG 'LOST DATA' AND REUSE CURRENT BUFFERLET.

RWCIB	LCS	RBBX,1			: COUNT BUFFERLET USAGE
	AHM	RBBX,RORUNC,RL2
	JGEFS	RWCIB1			: JUMP HAVN'T USED QUOTA, OK
	LIS	RBBX,0			: ZERO CHAIN OVERWRITTEN BY LAST BYTE
	STH	RBBX,BBUFER+BBFLSZ-2,RBBA,
	STH	RBBX,RBBINX,RL2		: SAVE CURRENT POSITION
	J	RPOVRN			: ABORT WITH OVERRUN

RWCIB1	JAL	R4,GBB			: GET A BIG BUFFERLET
	J	RWCIB4			: JUMP NONE AVAILABLE
	STH	R3,BBUFER+BBFLSZ-2,RBBA,	: CHAIN THIS BUFFERLET TO LAST
	LR	RBBA,R3			: SET BUFFERLET BASE ADDR REG.
RWCIB2	LHI	RBBX,-BBFLSZ+2		: INIT BUFFERLET INDEX
	STB	R0,BBUFER+BBFLSZ-2,RBBX,RBBA	: PUT CHARACTER
	STH	RBBX,RBBINX,RL2		: SAVE CURRENT INDEX
	JR	R5			: RETURN

RWCIB4	LIS	R3,0			: ZERO CHAIN THAT WAS OVER-WRITTEN
	STH	R3,BBUFER+BBFLSZ-2,RBBA,
	SBT	RL,DLOST		: Set data lost bit
	JBS	RWCIB2

	SUBTTL	ICL C03 Receive Start, Initialisation and Synchronisation

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		R C V	S Y N C H R O N I Z A T I O N			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

RSTART	LIS	R3,0			: SET IN RRUNL, CALLED FROM F.G EXC
	STH	R3,ROBCNT,RL2		: INIT BB CNT TO 0
	STH	R3,RBBCHN,RL2		: INIT NO BUFFERLET CHAIN
	
	STB	R3,RACCRC,RL		: CLEAR BCC ACCUMULATOR
	STB	R3,RCVGRP,RL		: CLEAR GRP SAVE AREA
	STB	R3,RCVSUB,RL		: CLEAR SUB SAVE AREA
	STB	R3,RCSAVE,RL		: CLEAR RCV RETURN CODE SAVE AREA
	LHI	R3,RSYN15-RSEG		: INIT LOST SYNCHRONIZATION PROCESS
	STH	R3,RLSYNC,RL2
	RBT	RL,RCRCER		: RESET BCC ERROR BIT ARRAY
	RBT	RL,WATBCC		: RESET BIT ARRAY,NO BCC PROCESS
	RBT	RL,DLOST		: Reset data lost bit
	JFS	RSYN15


:	LOST SYNCHRONIZATION WHILE LOOKING FOR SYNC.	SET LAST BYTE
:	TO MARKS AND CONTINUE

:	RING EMPTY, DISMISS

RSYN10	STH	REX,RRGETX,RL2		: SAVE EMPTY INDEX
	JAL	R5,RDMISS		: DISMISS

:	CHECK FOR RECEIVE TIME-OUT

RSYN15	L	R0,RTIME,RL2,RL2	: GET TIMEOUT FASTC VALUE
	JEFS	RSYN20			: JUMP NOT TIMING
	S	R0,FASTC,,		: TIME UP ?
	JLE	RPTMOT			: JUMP IF SO

:	INITIALIZE REG'S FOR RING FETCHS

RSYN20	L	RAD,RRINGX,RL2,RL2	: LOCATION OF RING
	LHL	REX,RRGETX,RL2		: EMPTY POINTER
	LHL	RLP,0,RAD		: LEAD POINTER

:	ADD MSIZE TO THE LP SO THAT SCAN WILL ONLY TRAIL BY
:	16-MSIZE BYTES

	AIS	RLP,MSIZE		: LIE TO SCAN
	LBR	RLP,RLP			: WRAP
	AIS	RAD,2			: POINT AT ACTUAL RING

:	USE SCAN TO FIND A 0 BIT IN THE RING

RSYN25	LR	R5,REX			: WE USE REGS 4,5 FOR SCAN
	SCAN	RLP,RAD
	JFS	RSYN30			: FOUND A 0

	LR	REX,R5			: GET NEW REX
	J	RSYN10			: NOTHING FOUND

RSYN30	LR	REX,R5			: GET NEW REX
	LHL	R3,0,RAD,REX		: GET FIRST HW
	JNFS	RSYN40			: IT IS NOT ALL ZEROES

RSYN35	RRADVC(REX)
	JBS	RSYN25			: JUST SKIP THIS HW

:	COMPUTE THE ALIGNMENT FACTOR

RSYN40	STH	REX,RRGETX,RL2		: SAVE POSTION (IN CASE WE ARE WRONG)
	LCS	R6,1			: INVERT THE DATA
	XR	R6,R3

	JFFOH	R6,RSYN50		: FIND A 1 (0)
	JBS	RSYN35			: THIS SHOULD NOT HAPPEN

:	NOW SET UP TO DO AN ALIGN TO GET THE DATA THAT FOLLOWS

RSYN50	LIS	R10,0F			: INVERT SHIFT COUNT
	XR	R10,R7
	LR	R6,RL			: SAVE RL

	ST	R8,STKSAV,,		: SAVE STACK PTR WHILE WE USE R8
	L	R8,ISECT,RL2,RL2	: ADDRESS OF INPUT SECTOR

	LIS	R1,($A16-MSIZE)/2
	RRADVC(REX)
	ALIGN	RAD,REX			: MOVE THE DATA
	L	R8,ISECT,RL2,RL2
	LHL	R0,0,R8			: DID WE GET 2 SYNs

	L	R8,STKSAV,,		: RESTORE STACK POINTER
	LR	RL,R6			: RESTORE RL
	CHI	R0,RSYN*100+RSYN
	JEFS	RSSYN1

	XHI	R10,0F			: RESTORE INDEX
	LHL	REX,RRGETX,RL2		: BACK UP RING
	SBT	R10,0,RAD,REX		: RESET THIS BIT
	J	RSYN25			: TRY AGAIN

:	NOW IN SYNC. GET READY TO PROCESS THE RECORD

RSSYN1	STB	R10,RSHIFT,RL		: SAVE THE SHIFT
	LIS	R4,0
	STB	R4,SYNNUM,RL		: SET COUNT TO ZERO
	LHI	RST,RSUBMS-RSEG		: INIT STATE TO IDENTIFY MSG
	STH	REX,RRGETX,RL2		: SAVE RING INDEX
	LIS	RAD,($A16-MSIZE)
	LCS	REX,($A16-MSIZE)

	SUBTTL	ICL C03 Receive State Processor

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			R C V	S T A T E	P R O C E S S O R		::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

RSTP05	A	RAD,ISECT,RL2,RL2

:	STORE INPUT CHAR INTO RC, AND REVERSED CHAR IS STORED INTO R0

RSTP10	LB	RC,0,RAD,REX		: GET A BYTE
	LR	R2,RC			: SAVE INPUT CHARACTER
	IF	RCVREV
	NHI	R2,0FE			: STRIP OFF PARITY BIT
	LB	R0,REVTAB,R2,
	LR	R4,R0			: SAVE INPUT CHAR FOR INDEXING
	LB	R3,PARTAB,R4,
	ELSE
	NHI	RC,7F			: STRIP OFF PARITY BIT
	LR	R0,RC			: RESTORE INPUT CHAR
	LR	R4,R0			: SAVE INPUT CHAR FOR INDEXING
	LB	R3,RPARTB,R4		: GET CHARACTERS WITH PARITY
	EI

	CR	R3,RC			: See if Parity error - even bcc
	JE	RSTP12			: No, go on

	CLHI	R3,I.ETX		: If p.e. in ETX, give no
	JE	RPPERR			: response - see 5.6.1.2

	CLHI	RST,RSDAT1-RSEG		: Have we already started Select
	JE	RPINTX			: if so, error in select 5.6.1.1

	CLHI	RST,RSGSS-RSEG		: dont forget case of gss
	JE	RPINTX

	CLHI	RST,RSIGN-RSEG		: or if we ignore rest
	JE	RPINTX


	J	RPPERR			: else, just parity error

RSTP12	TBT	RL,WATBCC		: IS THIS STATE WAITING FOR BCC?
	JN	RPPBCC			: JUMP,IF WAITING FOR BCC

	CLHI	R0,SYN			: IS THIS CHAR SYN?
	JE	RSTP16			: JUMP,IF IT IS SYN
	CLHI	R0,SOH			: IS THIS CHAR SOH?
	JN	RSTP15			: JUMP,IF IT IS NOT SOH
	LIS	R5,0
	STB	R5,RACCRC,RL
	J	RSTP16
RSTP15
	LB	RCRC,RACCRC,RL		: GET BCC ACCUMULATOR
	XR	RCRC,R0			: CALCULATE BCC
	STB	RCRC,RACCRC,RL		: STORE THE NEW BCC
RSTP16
	LB	R4,BIDCHR,R4		: GET AN INDEX
	LHL	R3,RSEG,R4,RST		: GET THE ROUTINE

	JAL	RRET,RSEG,R3		: DO IT
RSTP17
	AIS	REX,1			: DO SOME MORE
	JL	RSTP10

:	TIME TO DISMISS, RUN OUT OF DATA IN RING

	STH	RST,RSTATE,RL2		: SAVE THE STATE
	STH	RBBA,RBBADR,RL2		: BIG BUFFER ADDR
	LIS	R3,0
	A	R3,FASTC,,
	ST	R3,RSTPTM,RL2,RL2
RSTP20	JAL	R5,RDMISS

:	WAKE UP AND GET MORE RING DATA

	LHL	REX,RRGETX,RL2		: EMPTY PNTR
	SIS	REX,2			: BACK UP BY 1 HW
	LBR	REX,REX
	L	RAD,RRINGX,RL2,RL2	: RING
	LHL	R1,0,RAD		: FILL PNTR

:	IF WE WAKE UP WITH NO DATA THEN THERE IS TROUBLE

	SR	R1,REX
	JN	RSTP30
	L	R3,RSTPTM,RL2,RL2		: GET DISMISS TIME
	AIS	R3,(($A16*RATE/MNSPED)+1)	: MINIMUM TICKS TO GET 16 BITS
	S	R3,FASTC,,
	CHVR	R3,R3
	JG	RSTP20			: NOT ENOUGH TIME
	LHL	R3,RLSYNC,RL2		: GOTO LOST SYN ROUTINE
	J	RSEG,R3


:	CRANK THROUGH THE DATA RECEIVED SO FAR.

RSTP30	LBR	R1,R1			: ACCOUNT FOR WRAP
	STB	R1,RBYTEL,RL		: AND STORE BC
	SRLS	R1,1			: MAKE HW CNT
	LHL	R3,2,REX,RAD		: GET FIRST HW
	RRADVC(REX)
	LR	R6,RL			: SAVE RL
	LB	R10,RSHIFT,RL		: GET THE SHIFT

	ST	R8,STKSAV,,		: KEEP STACK POINTER SAFE
	L	R8,ISECT,RL2,RL2
	AIS	RAD,2			: POINT TO THE RING
	ALIGN	RAD,REX			: MOVE IT

:	RESTORE REGS FOR PROCESSING

	L	R8,STKSAV,,		: RESTORE STACK POINTER
	LR	RL,R6
	STH	REX,RRGETX,RL2
	LB	RAD,RBYTEL,RL
	LIS	REX,0
	SR	REX,RAD
	LHL	RBBA,RBBADR,RL2		: BUFFER
	LHL	RST,RSTATE,RL2		: STATE
	J	RSTP05


RPPBC0
	SBT	RL,RCRCER		: SET BCC ERROR
	LHI	RC,RCBADD		: FLAG BAD RCV
	LIS	R0,1
	AHM	R0,CNTBCC,RL2		: UPDATE RECEIVE BCC ERROR
	J	RPDONE

RSBCC
RPPBCC
	LB	RCRC,RACCRC,RL		: GET CALCULATED BCC
	CR	RCRC,R0			: COMPARE RCV ONE AND CALCU. ONE
	JN	RPPBC0			: BCC ERROR,JUMP

	LB	RC,RCSAVE,RL		: GET RETURN CODE
	J	RPDONE			: AFTER COMPARE BCC WITH CALCULATED ONE

	SUBTTL	ICL C03 HIF Receive State Processor

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		H O S T	I N T E R F A C E	R C V	S T A T E S	::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


RSUBMS	HC	RPUNID-RSEG	: ELSE,UNDEFINED MSG.
	HC	RPCSYN-RSEG	: SYN,IGNORE IT
	HC	RPRSOH-RSEG	: SOH,START OF SELECT.
	HC	RPUNID-RSEG	: STX,UNKNOWN START OF MSG
	HC	RPUNID-RSEG	: ETX,UNKNOWN START OF MSG
	HC	RPUNID-RSEG	: DLE,UNKNOWN START OF MSG
	HC	RPUNID-RSEG	: NAK,UNKNOWN START OF MSG
	HC	RPUNID-RSEG	: ACK,UNKNOWN START OF MSG
	HC	RPUNID-RSEG	: ENQ,UNKNOWN START OF MSG.
	HC	RPEOT-RSEG	: EOT,START OF POLL.
	HC	RPUNID-RSEG	: ETB,UNKNOWN START OF MSG

:	AFTER RECEIVING SOH,WAITING FOR GRP
:	-----------------------------------

RSGRP	HC	RPGRP-RSEG	: GRP,REMOTE ID
	HC	RPCSY1-RSEG	: SYN,IGNORE IT
	HC	RPUNID-RSEG	: SOH,ERROR
	HC	RPUNID-RSEG	: STX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ETX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: DLE,UNKNOWN CHAR
	HC	RPUNID-RSEG	: NAK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ACK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ENQ,UNKNOWN CHAR.
	HC	RPUNID-RSEG	: EOT,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ETB,UNKNOWN CHAR

:	AFTER RECEIVING GRP,WAITING FOR SUB
:	-----------------------------------

RSSUB	HC	RPSUB-RSEG	: SUB
	HC	RPCSY1-RSEG	: SYN,IGNORE IT
	HC	RPUNID-RSEG	: SOH,ERROR
	HC	RPUNID-RSEG	: STX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ETX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: DLE,UNKNOWN CHAR
	HC	RPUNID-RSEG	: NAK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ACK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ENQ,UNKNOWN CHAR.
	HC	RPUNID-RSEG	: EOT,ERROR
	HC	RPUNID-RSEG	: ETB, UNKNOWN CHAR


:	Ignore the rest of the data up to the ETX
:	-----------------------------------------

RSIGN	HC	RPCSY1-RSEG	: Ignore data
	HC	RPCSY1-RSEG	: SYN,IGNORE IT
	HC	RPUNID-RSEG	: SOH,ERROR
	HC	RPUNID-RSEG	: STX,UNKNOWN CHAR
	HC	RPDAT4-RSEG	: ETX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: DLE,UNKNOWN CHAR
	HC	RPUNID-RSEG	: NAK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ACK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ENQ,UNKNOWN CHAR.
	HC	RPUNID-RSEG	: EOT,ERROR
	HC	RPUNID-RSEG	: ETB, UNKNOWN CHAR

:	Here, we will deal with 1st byte of message for GSS
:	---------------------------------------------------

RSGSS	HC	RPGSS-RSEG	: Go off to see if its G.Reset, etc.
	HC	RPCSY1-RSEG	: SYN,IGNORE IT
	HC	RPUNID-RSEG	: SOH,ERROR
	HC	RPUNID-RSEG	: STX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ETX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: DLE,UNKNOWN CHAR
	HC	RPUNID-RSEG	: NAK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ACK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ENQ,UNKNOWN CHAR.
	HC	RPUNID-RSEG	: EOT,ERROR
	HC	RPUNID-RSEG	: ETB, UNKNOWN CHAR



:	RECEIVING STX,WAIT FOR DATA
:	---------------------------

RSDAT1	HC	RPDAT2-RSEG	: ELSE,DATA MESSAGE
	HC	RPCSY1-RSEG	: SYN,IGNORE IT
	HC	RPUNID-RSEG	: SOH,UNKNOWN IN TEXT
	HC	RPUNID-RSEG	: STX,UNKNOWN IN TEXT
	HC	RPDAT3-RSEG	: ETX,END OF DATA BLOCK
	HC	RPUNID-RSEG	: DLE,UNKNOWN IN TEXT
	HC	RPUNID-RSEG	: NAK,UNKNOWN IN TEXT
	HC	RPUNID-RSEG	: ACK,UNKNOWN IN TEXT
	HC	RPUNID-RSEG	: ENQ,UNKNOWN IN TEXT
	HC	RPUNID-RSEG	: EOT,UNKNOWN IN TEXT
	HC	RPUNID-RSEG	: ETB,UNKNOWN IN TEXT

:	POLL,NOW GET THE SAC BYTE
:	-------------------------

RSSAC	HC	RPSAC-RSEG	: GET SAC BYTE
	HC	RPCSY1-RSEG	: SYN,IGNORE IT
	HC	RPUNID-RSEG	: SOH,ERROR
	HC	RPUNID-RSEG	: STX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ETX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: DLE,UNKNOWN CHAR
	HC	RPUNID-RSEG	: NAK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ACK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ENQ,UNKNOWN CHAR.
	HC	RPUNID-RSEG	: EOT,ERROR
	HC	RPUNID-RSEG	: ETB, UNKNOWN CHAR

:	NOW GET THE SAC QUALIFIER
:	-------------------------

RSSACQ	HC	RPSACQ-RSEG	: GET SAC QUALIFIER
	HC	RPCSY1-RSEG	: SYN,IGNORE IT
	HC	RPUNID-RSEG	: SOH,ERROR
	HC	RPUNID-RSEG	: STX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ETX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: DLE,UNKNOWN CHAR
	HC	RPUNID-RSEG	: NAK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ACK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ENQ,UNKNOWN CHAR.
	HC	RPUNID-RSEG	: EOT,ERROR
	HC	RPUNID-RSEG	: ETB, UNKNOWN CHAR


:	NOW GET THE ENQ AT THE END OF THE POLL
:	--------------------------------------

RSENQ	HC	RPUNID-RSEG	: ELSE,INVALID POLL FORMAT
	HC	RPCSY1-RSEG	: SYN,IGNORE IT
	HC	RPUNID-RSEG	: SOH,ERROR
	HC	RPUNID-RSEG	: STX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ETX,UNKNOWN CHAR
	HC	RPUNID-RSEG	: DLE,UNKNOWN CHAR
	HC	RPUNID-RSEG	: NAK,UNKNOWN CHAR
	HC	RPUNID-RSEG	: ACK,UNKNOWN CHAR
	HC	RPENQ-RSEG	: ENQ,COMPLETE POLL SEEN.
	HC	RPUNID-RSEG	: EOT,ERROR
	HC	RPUNID-RSEG	: ETB, UNKNOWN CHAR

	SUBTTL	ICL C03 Host Interface Receive Process Routines

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			R C V	P R O C E S S E S			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


 
:	RPCSYN - EAT SYN
:	----------------
:	WAITING FOR LEADING SYN'S (AT LEAST 4 SYN) STATE DOES NOT CHANGE

RPCSYN
	LB	R4,SYNNUM,RL		: GET SYN FLAG NUMBER
	AIS	R4,1			: INCREASE SYN COUNT BY 1
	STB	R4,SYNNUM,RL		: STORE THE NEW VALUE IN SYNNUM
RPCSY1
	JR	RRET			: EAT

:	RPRSOH - Deal with SOH
:	----------------------

RPRSOH
	LB	R4,SYNNUM,RL		: GET RCV SYN NUMBER
	CLHI	R4,2			: IS MORE THAN 4 SYN CHARS RCVED?
	JL	RPUNID			: UNKNOWN MSG. IF LESS THAN 4 SYN
	LHI	RST,RSGRP-RSEG		: SET UP NEXT STATE
	LHI	R3,RPLSYN-RSEG		: SET LOST SYNC PROCESS
	STH	R3,RLSYNC,RL2		: 
	JR	RRET			: RETURN

:	RPGRP - CHECK GRP IS LEGAL OR NOT
:	---------------------------------

RPGRP
	VALGRP				: Validate group, RPUNID if bad
	LIS	R3,GDEF			: See if we are to ignore host
	TBT	R3,PGRTAB+GRPFLG,RGRP,
	JE	RPGRP2			: This feature not configured

	LHL	R3,PGRTAB+GCIRCS,RGRP,	: See if any circuits to this grp
	JE	RPUNID			: No, so ignore host !

RPGRP2
	LHI	RST,RSSUB-RSEG		: OK, So set up next state
	JR	RRET			: RETURN

:	RPSUB - CHECK SUB IS LEGAL OR NOT
:	---------------------------------

RPSUB
	LDRGRP(R4)
	LR	R7,R0			: Get the SUB received
	SHI	R7,BSUBAD		: Make it relative to 20 hex
	JL	RPUNID			: Jump if not in range
	
	CLHI	R7,MAXSUB		: See if in valid range
	JGE	RPUNID			: Too big, ignore 

	CLHI	R0,BSUBAD+4		: See if this is > 23
	JGE	RPSUB1			: Yes, treat as normal sub

	CLHI	R0,BSUBAD		: Is it = GSS
	JE	RPS20			: Yes, deal with differently

:	Here, we deal with subs 21 - 23. These are special subsidiaries,
:	reserved for ICL use. Anything received for these devices is
:	discarded, and the Select is Acked.

	STB	R0,RCVSUB,RL		: Keep sub #s
	LHI	RST,RSIGN-RSEG		: Next state will discard rest
	JR	RRET			: up to the ETX

:	Here, we deal with a Select for GSS. If the command following
:	is a Group reset, this is retained without needing to use a
:	buffer. Otherwise, for the Assign Cats command, a buffer will be
:	allocated in the normal manner. In this way, we should always be
:	able to accept a Group Reset command and never try to BNA it.

RPS20	STB	R0,RCVSUB,RL		: Keep sub #s
	LHI	RST,RSGSS-RSEG		: Set state to deal with GSS cmd
	JR	RRET



:	RPGSS	: See what sort of cmnd weve got for GSS
:	------------------------------------------------
RPGSS
	STB	R0,RCVPRE,RL		: Keep cmnd as if it were prefix
	CLHI	R0,GRES1		: Is it a Group Reset
	JL	NOTGRES			: no, so treat like normal sel

	CLHI	R0,GRES3		: 
	JG	NOTGRES			: no, so treat like normal sel

	STB	R0,PGRTAB+GCOMND,RGRP,	: Keep the G.Reset safe
	LIS	R0,0
	STB	R0,RCVD1,RL		: 1st data byte not relevant
	LHI	RST,RSIGN-RSEG		: Ignore rest of data to ETX
	JR	RRET

NOTGRES	STB	R0,PGRTAB+GCOMND,RGRP,	: Must be Ass cats, keep it
	J	RPABUF			: and allocate buffer, etc

RPSUB1	STB	R0,RCVSUB,RL		: STORE THE SUB IN SAVE AREA


:	NEED TO ALLOCATE BUFFERLET FOR DATA STORAGE
:	-------------------------------------------

RPABUF	LCS	R3,1			: COUNT BUFFERLET USAGE
	AHM	R3,RORUNC,RL2
	JL	RPOVRN			: JUMP CAN'T USE ANY, OVERRUN
	JAL	R4,GBB			: GET 1ST BIG BUFFERLET
	J	RPNROM			: JUMP NO BUFFERLETS

	LHI	R0,-BBFLSZ+1		: INIT BUFFERLET INDEX REG
	STH	R0,RBBINX,RL2		: KEPT HERE

	LR	RBBA,R3			: INIT BUFFERLET ADDR REG
	STH	RBBA,RBBCHN,RL2		: INIT BUFFERLET CHAIN ADDR

	LB	R0,RCVGRP,RL		: Plant Grp, and Sub in buffer
	RWCI(R0)
	LB	R0,RCVSUB,RL
	RWCI(R0)

	LHI	RST,RSDAT1-RSEG		: SET UP NEXT STATE
	JR	RRET			: RETURN


:	RPDAT2	: STORE RCV DATA INTO BUFFER
:	------------------------------------
RPDAT2
	RWCI(R0)			: STORE DATA INTO BUFFER
	LHI	RST,RSDAT1-RSEG		: AND STAY IN SAME STATE
	JR	RRET			: RETURN


:	RPDAT3	: END OF TEXT MESSAGE
:	-----------------------------

RPDAT3
	RWCI(R0)			: STORE DATA INTO BB

RPDAT4	LHI	RC,RCSEL		: GET RETURN CODE
	SBT	RL,WATBCC		: SET BIT ARRAY IND. NEXT CHAR IS BCC
	STB	RC,RCSAVE,RL		: SAVE RETURN CODE
	JR	RRET

:	RPEOT - START OF A POLL SEQUENCE
:	--------------------------------
RPEOT
	LB	R4,SYNNUM,RL		: GET RCV SYN NUMBER
	CLHI	R4,2			: IS MORE THAN 4 SYN CHARS RCVED?
	JL	RPUNID			: UNKNOWN MSG. IF LESS THAN 4 SYN
	LHI	RST,RSSAC-RSEG		: SET UP NEXT STATE
	LHI	R3,RPLSYN-RSEG		: SET LOST SYNC PROCESS
	STH	R3,RLSYNC,RL2		: 
	JR	RRET			: RETURN

:	RPSAC - PART OF A POLL SEQUENCE
:	-------------------------------
RPSAC
	VALGRP				: Validate group, RPUNID if bad
	LIS	R3,GDEF			: See if we are to ignore host
	TBT	R3,PGRTAB+GRPFLG,RGRP,
	JE	RPSAC2			: This feature not configured

	LHL	R3,PGRTAB+GCIRCS,RGRP,	: See if any circuits to this grp
	JE	RPUNID			: No, so ignore host !

RPSAC2
	STB	R0,RCSAC,RL		: Save this byte for this line
	LHI	RST,RSSACQ-RSEG		: SET UP NEXT STATE
	JR	RRET			: RETURN

:	RSACQ - PART OF A POLL SEQUENCE
:	-------------------------------
RPSACQ
	STB	R0,RCSACQ,RL		: Save sac qualifier for line
	LHI	RST,RSENQ-RSEG		: SET UP NEXT STATE
	JR	RRET			: RETURN


:	RPENQ - GET THE ENQ AT END OF POLL SEQUENCE
:	-------------------------------------------
RPENQ
	LHI	RC,RCPOLL		: SET POLL INDICATION
	STB	RC,RCSAVE,RL
	J	RPDONE			: AND RETURN

:	RPPERR - RECEIVE PARITY ERROR
:	-----------------------------

RPPERR
	LHI	RC,RCPERR		: GET PARITY ERROR RETURN CODE
	LIS	R0,1
	AHM	R0,CNTPER,RL2		: UPDATE RECEIVE PARITY ERROR
	J	RPDONE			: ABORT IT AND RETURN


:	RPINTX - RECEIVE PARITY ERROR IN TEXT OF SELECT
:	-----------------------------------------------
RPINTX	
	LHI	RC,RCSELR		: Set return code
	LIS	R0,1
	AHM	R0,CNTPER,RL2		: Update parity error count
	J	RPDONE			: and return



:	RPUNID - RECEIVE UNIDENTIFIABLE MESSAGE
:	---------------------------------------
:	CHAR(S) AFTER SYNC STREAM UNKNOWN

RPUNID	LHI	RC,RCUNID		: FLAG UNIDENTIFIED RCV
	LIS	R0,1
	AHM	R0,CNTUDM,RL2		: UPDATE RECEIVE UNDEFINED MESSAGE
	J	RPDONE			: GO END OPERATION


:	RPLSYN - LOST RCV SYNCHRONIZATION
:	---------------------------------
:	LOST RCV SYNCHRONIZATION AFTER RECEPTION STARTED (CHAR AFTER
:	LEADING SYN'S RECEIVED, THEN SUBSEQUENTLY FAILED TO RCV DATA INTO
:	RING WITHING MAXIMUM TIME FOR SLOWEST LINE SPEED SUPPORTED).

RPLSYN	LHI	RC,RCLSYN		: FLAG LOST SYNCHRONIZATION
	J	RPDONE			: GO END OPERATION


:	RPTMOT - RECEIVE TIMEOUT
:	------------------------
:	THE TIME SPECIFIED BY THE USER HAS ELAPSED, & NOT FOUND A SYNC PATTERN.

RPTMOT	LHI	RC,RCTMOT		: FLAG RCV TIMEOUT
	LIS	R0,1
	AHM	R0,CNTRTO,RL2		: UPDATE RECEIVE TIME OUT CNT
	LIS	REX,0			: INIT INDEX FOR RPDONE
	J	RPDONE			: GO END OPERATION


:	RPOVRN - RECEIVE OVERRUN CONDITION
:	----------------------------------
:	A MESSAGE WAS SEND WHOSE LENGTH EXCEEDED THAT SPECIFIED BY THE
:	USER (TO NEAREST BIG BUFFERLET). RCV HALTED WITHOUT TRYING TO
:	COMPLETE SINCE THIS COULD BE DUE TO A LINE HIT AND WE'RE REALLY
:	LISTENING TO NOISE.

RPOVRN	LIS	RC,RCOVRN		: FLAG RCV OVERRUN
	LIS	R0,1
	AHM	R0,CNTORN,RL2		: UPDATE RECEIVE BB OVERRUN CNT
	JFS	RPDONE			: GO END OPERATION



:	RPNROM - RECEIVE STORAGE ERROR
:	------------------------------
:	A DATA RCV OPERATION WAS STARTED (SOH,STX, ETC. RECEIVED)
:	AND A BIG BUFFERLET WAS NOT AVAILABLE. WE SET A FLAG, AND LATER,
:	AFTER WEVE READ IN THE REST OF THE MESSAGE(OVERWRITING OUR
:	PREVIOUS BUFFERLET), WE RETURN LOST DATA INSTEAD OF SELECT

RPNROM	SBT	RL,DLOST		: Set flag data lost
	LHI	RST,RSIGN-RSEG		: and ignore rest up to etx
	JR	RRET

:	RPDONE - RECEIVE OPERATION COMPLETE
:	-----------------------------------
:	RETURN TO ACTIVATOR USING RELATIVE ADDRESS STORED IN 'RRETAD'.
:	ON ALL BUT 'GOOD DATA' OP COMPLETE, RETURN ANY BIG BUFFERLETS
:	USED TO FREE POOL.
:
:	REGISTER CONVENTIONS ON RETURN:
:		R1	-OPERATION RETURN CODE
:		R3	-RELATIVE ADDRESS OF 1ST BUFFERLET IN DATA CHAIN

RPDONE	LHL	RAD,RRETAD,RL2		: GET RETURN ADDRESS TO ACTIVATOR

: Record the occurence of the type of message received in RCVHRT
: --------------------------------------------------------------
	LDRGRP(R3)			: Get the current PGRTAB addr
	SLLS	RC,1			: Make return code a H/W index

	LHL	R5,RCVPTR,RL,RL		: Absolute line number for HIF
	LHL	R5,RCVPTR,R5,R5		: Get the offset into RCVHRT

	LIS	R3,1
:	NEXT LINE REMOVED BECAUSE IT CAUSED TROUBLE - RT JUL 88
:	AHM	R3,RCVHRT,RC,R5,	: Count the msg received
	SRLS	RC,1			: Restore the original RC
:---------------------------------------------------------------

	AH	REX,RRGETX,RL2
	SIS	REX,1			: ADJUST INDEX TO POINT BEFORE SYN
	NHI	REX,0FE			: INSURE HW BOUNDRY
	STH	REX,RRGETX,RL2

:	Now we keep the 1st 2 bytes of the received text for use later
:	if we want to observe activity on the line.

	LHL	R3,RBBCHN,RL2		: get start of received data
	JE	RPC01			: no buffers used

	LB	R5,RCVSUB,RL		: see if this was for GSS
	CLHI	R5,BSUBAD
	JE	REGSS			: yes,

:	Else, for normal sub, so get ALP prefix and first byte of data
:	from buffers

	LB	R5,BBUFER+2,R3,
	STB	R5,RCVPRE,RL
	LB	R5,BBUFER+3,R3,
	STB	R5,RCVD1,RL
	J	RPC01

:	Here, we had data for Gss. The 2 bytes will already have been
:	kept except in the case of Assign categories command. In this case,
:	only the prefix will have been kept so far, so we get the first
:	data byte from the buffers.

REGSS	LB	R5,PGRTAB+GCOMND,RGRP,
	CLHI	R5,ASTCAT		: was it Assign cats cmnd
	JN	RPC01			: no,

	LB	R5,BBUFER+2,R3,		: else get 1st byte from buffer
	STB	R5,RCVD1,RL


RPC01	CLHI	RC,RCSELR		: GOOD DATA RCVED OR NOT?
	JLE	RPDON1			

	LIS	R5,1
	AHM	R5,PGRTAB+NBPOL1,RGRP,	: Increase the good message count
	LHL	R3,LINPTR,RL,RL
	AHM	R5,LINTAB+LBPOL1,R3,	: and for whole line

	TBT	RL,DLOST		: See if we lost data
	JE	RPDON1			: No, ok

	LHI	RC,RCLOST		: Set up return code

RPDON1
	LHL	R3,RBBCHN,RL2		: GET DATA CHAIN ADDRESS
	JE	RSEG,RAD		: RETURN NO DATA RCV'D
	CLHI	RC,RCSELR		: GOOD DATA RCVED OR NOT?
	JG	RSEG,RAD		: RETURN,IF GOOD DATA
	JAL	R5,PBBC			: RETURN BUFFERLETS TO FREE POOL

	LIS	R3,0			: and clear pointer to them
	STH	R3,RBBCHN,RL2
	J	RSEG,RAD		: RETURN TO ACTIVATOR


	FO	C03FEX
	FO	C03BLK
	FO	MONBLK
	FO	MAIN

	EM


	SUBTTL	ICL C03 Single Receive Driver

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	I C L	C 0 3	S I N G L E	R E C E I V E	D R I V E R	::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:	The purpose of this module is to interface to the synchronous
:	line to handle incoming data

	RA	0
	MO	.,C03SRV
	GL	C03SRV,BSR100
	LO	C03RCV			: ACCESS BISYNC PRIMITIVE RCV DRIVER
	LO	C03FEX			: ACCESS BISYNC FG EXEC. RUN LIST
	LO	C03BLK



:	ISIS SYNCHRONOUS SVC OP CODES

CONCTI	EQ	0			: FORCE OUTPUT
IOCTRL	EQ	3			: I/O CONTROL


:	VARIABLES
:	---------

	SEG	A.DATA

BSRETA	WS	NBILIN			: CALLER'S RETURN ADDRESS
BSRBUF	HS	NBILIN			: DATA BUFFER CHAIN ADDRESS
BSRBCT	HS	NBILIN			: BUFFERLET LIMIT TO USE
BSROPC	BS	NBILIN			: OP COMPLETE CODE FROM RCV DRIVER


:	LOGICAL UNIT NUMBER TABLE
:	-------------------------
:	THE FOLLOWING TABLE CORRELATES THE BISYNC LINE NUMBER TO
:	THE ISIS LOGICAL UNIT NUMBER.	IT EXPECTS SYMBOLS BLUN0
:	BLUN1,...,BLUN|NBILIN| TO BE DEFINED CORRELATING BISYNC
:	LINE 0 TO ISIS LOGICAL UNIT X, ETC.

	SEG	A.CODE
BSRLUN	BS	0
Q	EQ	0
	RE	NBILIN
SS	EQ	BLUN|Q|
	BC	$A SS
Q	EQ	Q+1
	LIST;	ER


	SUBTTL	C03 Single Receiver Main Routines

:	C03SRV - DETERMINE CALL TYPE, START INPUT OR INITIALIZE?
:	--------------------------------------------------------
:	REGISTER CONVENTIONS:
:	R0	-FASTC TIME TO FORCE END OF OPERATION.
:			0 = NEVER FORCE END BASED ON TIME.
:			- = INITIALIZE (CONNECTS INPUT, CALL ONLY ONCE)
:	R2	-OP COMPLETE CODE
:	R3	-DATA BUFFER CHAIN ADDRESS REL TO BBUFER IF GOOD DATA RCV'D
:	R5	-LINK REGISTER

C03SRV	LR	R0,R0			: INITIALIZE ?
	JGE	BSR100			: JUMP IF NOT, START INPUT

:	INITIALIZE - CONNECT SYNC INPUT
:	-------------------------------
	LHI	R4,RRSIZE		: GET RING SIZE (IN C03RCV)
	LB	R2,BSRLUN,R1		: GET LOGICAL UNIT # FOR BISYNC LINE
	SLHLS	R1,2			: MAKE WORD INDEX
	L	R3,RRINGX,R1		: GET RING ADDRESS FOR LINE (IN C03RCV)
	SRHLS	R1,2			: RESTORE BYTE INDEX

	SVC	IOCTRL,CONCTI^4+R2	: CONNECT INPUT
	J	SVCER3			: CRASH,IF ILLEGAL SVC CALL
	LCS	R3,1			: DE-SYNCHRONIZE RCV EMPTY POINTER
	STH	R3,RRGETX,R1,R1
	JR	R5			: RETURN TO CALLER

:	START INPUT AND HALT PROTOCOL DRIVER CALLER
:	-------------------------------------------
BSR100	ST	R0,RTIME,RL2,RL2	: SAVE TIME TO FORCE RCV OP COMPLETE
	LHI	R1,BSCRBC
	STH	R1,RORUNC,RL2		: INIT BUFFERLET USAGE LIMIT
	STH	R1,BSRBCT,RL2		: SAVE CNT TO COMPUTE USAGE
	ST	R5,BSRETA,RL2,RL2	: SAVE RETURN ADDRESS
	LH	R5,RRGETX,RL2		: HAS EMPTY INDEX BEEN SYNCHRONIZED ?
	JGEFS	BSR110			: JUMP IF SO
	L	R5,RRINGX,RL2,RL2	: SYNCHRONIZE EMPTY INDEX TO
	LHL	R5,0,R5			: CURRETN FILL RING INDEX
	STH	R5,RRGETX,RL2

BSR110	LHI	R5,BSREND-RSEG		: SUPPLY RCV ROUTINE WITH RETURN ADDR
	STH	R5,RRETAD,RL2
	LA	R5,RSTART		: PUT RECEIVE PROCESS ON RCV RUN LIST
	ST	R5,RRUNL,RL2,RL2
BSR115
	J	PHALT			: REMOVE CALLER FROM PROTOCOL RUN LIST


:	RECEIVE OPERATION COMPLETE. SAVE RESULTS AND PLACE ROUTINE
:	ON PROTOCOL RUN LIST.	WHEN PROTOCOL LIST IS RUN, RETURN TO
:	ORIGINAL CALLER.

BSREND	STB	RC,BSROPC,RL		: SAVE OP COMPLETE CODE
	STH	R3,BSRBUF,RL2		: SAVE DATA BUFFER CHAIN ADDRESS

	STH	REX,RRGETX,RL2		: KEEP LINE SYNCED FOR NOW

	LA	R3,BSRRET		: PUT US ON PROTOCOL RUN LIST
	ST	R3,PRUNL,RL2,RL2
	J	RHALT			: DISCONNECT LINE FROM RECEIVE RUN LIST


:	PROTOCOL LIST RUNNING, RESTART USER

BSRRET	LHL	R2,ROBCNT,RL2		: GET MSG BYTE CNT
	LB	R1,BSROPC,RL		: GET OP COMPLETE CODE
	LHL	R3,BSRBUF,RL2		: GET DATA BUFFER CHAIN ADDRESS
	L	R5,BSRETA,RL2,RL2
	JR	R5			: RETURN TO CALLER of BSR100

SVCER3
	JAL	R10,CRASH,,
	BC	0,0,0,CRSVCE

	FO	C03FEX
	FO	C03RCV
	FO	C03BLK

	EM



	SUBTTL	ICL C03 BISYNC SINGLE TRANSMIT DRIVER

	RA	0
	MO	.,C03SXM
	GL	C03SXM
	GL	C03CTS			:CLEAR TO SEND (CTS) BIT ARRAY
	LO	MAIN			:ACCESS BISYNC CONTROL CHAR DEFINITIONS
	LO	C03FEX			:ACCESS BISYNC FG EXECUTION RUN LISTS
	LO	C03BLK


:	DEDICATED REGISTER DEFINITIONS

RLUN	EQ	R2			:REG HAVING LOGICAL UNIT NO. FOR SVC
RAD	EQ	RLUN+1			:REG HAVING LIST ADDRESS FOR SVC
RBUF	EQ	R10			:REG HAVE BUFFERLET BASE ADDR (BBUFER)
RCNTX	EQ	R11			:REG HAVING HW DATA CNT
RLSZ	EQ	R12			:REG HAVING LIST POSITIONS UNUSED
RRET	EQ	R6			:REG HAVE RETURN ADDR FOR XMT PROCESS
RCMD	EQ	R14			:REG HAVING SYNC COMMAND
RDAT	EQ	RCMD+1			:REG HAVING DATA ADDRESS FOR COMMAND

:	TRACE OPTIONS
BSXTSW	EQ	0			:K-BYTE OF TRACE BUFFER,O=TRACE OFF


:	RETURN CODES TO CALLER
XMTOK	EQ	0			:XMT SUCESSFUL
XMTTMO	EQ	1			:XMT NOT COMPLETED BEFORE TIMEOUT VALUE


:	ISIS SYNCHRONOUS OUTPUT COMMANDS
CHALT	EQ	0			:HALT OUTPUT
CWRITE	EQ	1			:WRITE
CRTSOF	EQ	3			:DISABLE REQUEST TO SEND
CRTSON	EQ	4			:ENABLE REQUEST TO SEND
CSBT	EQ	5			:SET BIT
CCTS	EQ	6			:CONNECT CLEAR TO SEND TO BIT ARRAY


:	ISIS SYNCHRONOUS SVC OP CODES
:	------------------------

FORCEO	EQ	2			:FORCE OUTPUT
IOCTRL	EQ	3			:I/O CONTROL

:	VARIABLES
:	---------

	SEG	A.DATA
BSXRTA	WS	NBILIN			:CALLER'S RETURN ADDRESS
BSXTIM	WS	NBILIN			:FASTC TIME TO ABORT XMT OPERATION
BSXDAT	HS	NBILIN			:REL ADDR 1ST BUFFERLET IN DATA CHAIN
BSXCNT	HS	NBILIN			:HW CNT OF DATA TO SEND
BSXRTC	BS	NBILIN			:OPERATION RETURN CODE
BSXOPC	BS	NBILIN			:XMT OP CODE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		O U T P U T	L I S T	D E F I N I T I O N S	::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

XLSIZE	EQ	MAXDSZ/(BBFLSZ-2)+6	:NUMBER OF POSITIONS IN XMT OUTPUT LIST
					:(NO. BUFFERLETS IN MAX DATA MSG +3)
XCSIZE	EQ	$A 16			:BYTE CNT FOR CONTROL MSG. AREA IN LIST

	SEG	A.BUFF			:DEFINE LIST FOR EACH LINE

XLIST	WS	(2*XLSIZE)*NBILIN
BSXINT	HS	$A12			:CON. CTS WORK LIST,MUST BE WORD BOUND.
BSXOCP	HS	(NBILIN-1)/10+1	 	:OP COMPLETE BIT ARRAY
	BND	2
C03CTS	HS	(NBILIN-1)/10+1	 	:CLEAR TO SEND BIT ARRAY
	BND	2
BSXCMT	HS	(XCSIZE/2)*NBILIN	:CONTROL MSG TEXTS AREA
	BND	2
BSXSYN	HS	(LSYNCS+1)/2		:LEADING SYN MSG AFTER INIT
	BND	2
BSXPAD	HS	(TPADCS+1)/2		:TRAILING PAD AFTER MSG


	SEG	A.CODE

XLISTX	WS	0			:ADDRESS TABLE OF START OF EACH LIST
Q	EQ	0
	RE	NBILIN
	WC	XLIST+Q*(8*XLSIZE)
Q	EQ	Q+1
	ER

XCLIST	WS	0			:ADDR. TABLE OF CONT. MSG. AREA IN LIST
Q	EQ	0
	RE	NBILIN
	WC	BSXCMT+Q*XCSIZE
Q	EQ	Q+1
	ER


:	LOGICAL UNIT NUMBER TABLE
:	-------------------------
:	THE FOLLOWING TABLE CORRELATES THE BISYNC LINE NUMBER TO
:	THE ISIS LOGICAL UNIT NUMBER.	IT EXPECTS SYMBOLS BLUN0
:	BLUN1,...,BLUN|NBILIN| TO BE DEFINED CORRELATING BISYNC
:	LINE 0 TO ISIS LOGICAL UNIT X, ETC.

XLUN	BS	0
Q	EQ	0
	RE	NBILIN
SS	EQ	BLUN|Q|
	BC	$A SS
Q	EQ	Q+1
	LIST;	ER


:	CONFIGURE RTS/CTS HANDSHAKE LINES
:	---------------------------------

:	THE FOLLOWING CODE CREATES A BIT ARRAY RTSCTS FROM USER OUTPUT
:	SRTS0,SRTS1,...,SRTS|NBILIN| WHICH THE CODE TESTS TO DETERMINE
:	IF RTS/CTS HANDSHAKE MUST BE PERFORMED BEFORE DATA IS TRANSMITTED
:	(HANDSHAKE IS RAISE RTS, WAIT FOR CTS, SEND DATA, LOWER RTS).
:	BIT ARRAY IS INDEXED BY RL, 1 = HANDSHAKE REQUIRED

RTSCTS	HS	0
QQ	EQ	0			:WORK SYMBOL
Q	EQ	0
	RE	NBILIN; NOLIST
QQ	EQ	QQ+(SRTS|Q|&1)^(0F-(Q&0F))
Q	EQ	Q+1
	IF Q&0F;	ELSE;
	HC QQ	;QQ EQ 0;	EI
	ER
	IF	Q&0F
	HC	QQ
	EI


:	THE FOLLOWING CODE CREATES A TABLE OF RELATIVE ADDRESSES OF THE
:	1ST PROCESSOR OF A LINE. IF THE LINE REQUIRES RTS/CTS HANDSHAKING,
:	THE PROCESS WILL BE BSXRTS. ELSE IT WILL BE BSXWRT.

BSX1ST	HS	0
Q	EQ	0			:LINE COUNTER
	RE	NBILIN; NOLIST
SS	EQ	SRTS|Q|
	IF	$A SS&1;	HC BSXRTS-RSEG
	ELSE;	HC BSXWRT-RSEG; EI
Q	EQ	Q+1;	LIST;	ER

:	LEADING SYN'S MESSAGES
:	----------------------

SYNMSG	HS	0
	IF	(LSYNCS&1)
	BC	RSYN
	EI
	RE	(LSYNCS)
	BC	RSYN
	ER

PADMSG	HS	0
	RE	(TPADCS+1)&0FFFE
	BC	RPAD
	ER


SYNPAD	EQ	.-SYNMSG		:LENGTH OF SYN-PAD AREA

:	DEFINE CONTROL MESSAGE COMMAND TABLE. EACH MSG COMMAND IS TWO
:	WORDS LONG: 	1ST WD	(WRITE CMD CODE)(HALF-WORD CNT)
:			2ND WD	(	ADDRESS OF MSG TEST	)


SYNMOP	WC	CWRITE^10+((LSYNCS+1)&0FFFE)
	WC	BSXSYN

PADMOP	WC	CWRITE^10+((TPADCS+1)&0FFFE)
	WC	BSXPAD

	SEG	A.CODE


	SUBTTL	SINGLE BSC TRANSMIT DRIVER MAIN ROUTINE

:	C03SXM	:DETERMINE CALL TYPE, INITIALIZE OR START OUTPUT?
:	----------------------------------------------------------

C03SXM	LR	R0,R0			:INITIALIZE ?
	JGE	BSX100			:JUMP IF NOT, START OUTPUT
	LHI	R2,-SYNPAD		:LENGTH OF SYN-PAD AREA
BSX010
	LHL	R4,SYNMSG+SYNPAD,R2,	:GET CONTAINTS OF SYN-PAD
	STH	R4,BSXSYN+SYNPAD,R2,	:STORE INTO OTHER SEGMENTS
	AIS	R2,2
	JLBS	BSX010

:	INITIALIZE - CONNECT CTS ARRAY FOR LINE IF NEEDED AND HALT CURRENT I/O
:	---------------------------------------------------------------------
	LA	RAD,BSXINT,,		:INIT COMMAND LIST ADDR
	TBT	R1,RTSCTS,,		:RTS/CTS HANDSHAKE NEEDED ?
	JNFS	BSX020			:JUMP IF SO

:	else, we dont want to use rts/cts so just raise rts at start

	RBT	R1,C03CTS-BSXINT,RAD	:INIT CTS ON
	LIS	R0,CRTSON		:RAISE RTS
	STH	R0,0,RAD		
	LIS	R0,CHALT		:AND HALT
	STH	R0,4,RAD
	J	BSX032


BSX020	LA	R0,C03CTS-BSXINT,RAD	:SET 2ND WORD, BASE ADDR OF BIT ARRAY
	ST	R0,4,RAD
	LIS	R0,CRTSOF		:SET 3RD WORD, RTS OFF
	STH	R0,8,RAD
	LIS	R0,CHALT		:SET 5TH WORD, HALT COMMAND
	STH	R0,10,RAD
	LIS	R0,CCTS			:SET 1ST WORD, COMMAND\BISYNC LINE NO.
	EXHR	R0,R0			:POSITION
	OR	R0,R1			:(INCLUDE BISYNC LINE NUMBER)
BSX030	ST	R0,0,RAD		:WRITE 1ST COMMAND (PERHAPS ONLY)

BSX032	LB	RLUN,XLUN,R1,		:GET LOGICAL UNIT NUMBER

	IF BSXTSW;	JAL R4,BSXTRC;	EI	:BSXTSW

	SVC	IOCTRL,FORCEO^4+RLUN	:CONNECT OUTPUT
	J	SVCER2			:CRASH,IF CALLING ERROR
	JR	R5			:RETURN TO CALLER

:	START OUTPUT AND HALT PROTOCOL DRIVER CALLER
:	-----------------------------------
BSX100	ST	R0,BSXTIM,RL2,RL2	:SAVE TIME TO FORCE XMT OP COMPLETE
	ST	R5,BSXRTA,RL2,RL2	:SAVE RETURN ADDRESS
	STH	R1,BSXOPC,RL2		:SAVE OPCODE
	STH	R2,BSXCNT,RL2		:SAVE DATA HW CNT
	STH	R3,BSXDAT,RL2		:SAVE DATA CHAIN ADDRESS
	LHL	R5,BSX1ST,RL2,		:GET ADDRESS OF 1ST XMT PROCESS
	JAL	RRET,RSEG,R5		:GO START XMT
	ST	R5,XRUNL,RL2,RL2	:PUT NEXT PROCESS ON XMT RUN LIST
	J	PHALT			:REM. PTP DRIVER(CALLER) FROM RUN LIST


:	TURN ON REQUEST TO SEND (RTS)
:	-----------------------------
:	FOR BISYNC LINES THAT ARE CONFIGURED SUCH, THIS IS THE 1ST
:	PROCESS EXECUTED WHEN XMT STARTS

BSXRTS	L	RAD,XLISTX,RL2,RL2	:GET ADDR OF LINES XMT LIST
	LIS	RCMD,CRTSON		:PUT 'TURN RTS ON' ON LIST
	STH	RCMD,0,RAD
	LIS	RCMD,CHALT		:PUT HALT CMD ON LIST
	STH	RCMD,8,RAD
	LB	RLUN,XLUN,RL,		:GET LOGICAL UNIT NO. FOR LINE

	IF BSXTSW;	JAL R4,BSXTRC;	EI	:BSXTSW
	SVC	IOCTRL,FORCEO^4+RLUN	:FORCE OUTPUT
	J	SVCER2			:CRASH,IF CALLING ERROR

	JALR	R5,RRET			:RETURN, LEAVING BSXCTS IN R5


:	WATCH FOR CLEAR TO SEND (CTS)
:	-----------------------------
:	BEFORE DATA CAN BE SEND ON SOME LINES, CTS MUST BE SUPPLIED
:	FROM MODEM.	FOR THESE LINES, RTS HAS BEEN TURNED ON.
:	OP TIMER IS WATCHED CMD ABORTED IF IT TAKES TOO LONG

BSXCTS	SVC	DISMISS,$A75		: !! In case line without CTS !!

	TBT	RL,C03CTS,,		:CTS YET ?
	JEFS	BSXW00			:YES, GO QUEUE WRITE COMMANDS

	L	R2,BSXTIM,RL2,RL2	:GET FASTC TIME TO STOP OP
	JEFS	BSXCT2			:JUMP NOT CHECKING
	S	R2,FASTC,,		:TIME UP ?
	JLE	BSXOTM			:JUMP IF SO

BSXCT2	JAL	R5,XDMISS		:NONE, DISMISS
	J	BSXCTS			:GO CHECK AGAIN


:	QUEUE WRITE COMMANDS
:	--------------------
:	DECODE XMT OP CODE, AND PUT WRITE COMMAND FOR CONTROL MSG OR
:	DATA ON XMT LIST. FOR LINES THAT REQUIRE RTS/CTS HANDSHAKE,
:	'TURN OFF RTS' COMMAND IS PUT AT END OF WRITE LIST.
:	NOTE THAT FOR LINES NOT REQUIRING RTS/CTS HANDSHAKE, ENTRY
:	IS MADE AT 'BSXWRT'.

BSXW00	LA	RRET,XDMISS		:SET DISMISS PROCESS AS CALLER

BSXWRT	L	RAD,XLISTX,RL2,RL2	:GET ADDR OF LINES XMT LIST
	LM	RCMD,SYNMOP,,		:START COMMAND LIST WITH SYN'S
	STM	RCMD,0,RAD

	LHI	RLSZ,XLSIZE-4		:POSITIONS IN XMT LIST
					:(LESS SYN's,OP COMPLETE,HALT)
	LHL	RCMD,BSXOPC,RL2		:Now see if its data, or a s/resp
	JE	BSXW30			:Data, go off to plant it

	LHI	RLSZ,XLSIZE-5		: Positions in list with header

:
:	Now we plant the 'Header'. This will be a 4 byte Ack/Nak
:	Sequence.

	LIS	RCMD,CWRITE		:Get write command
	STH	RCMD,8,RAD		:Plant in rotor list
	
	LIS	R4,4			:Now put in HDR length
	STH	R4,0A,RAD
	L	R4,XCLIST,RL2,RL2	:Get address of the header
	ST	R4,0C,RAD

:	Now keep header for use later if we want to observe line
:	activity.

	LIS	R0,0
	STB	R0,CPXGRP,RL,

	LB	R1,0,R4,		:Get bytes from header
	LB	R0,REVTAB,R1,
	STB	R0,CPXSUB,RL

	LB	R1,1,R4,
	LB	R0,REVTAB,R1,
	STB	R0,CPXFLO,RL

	LB	R1,2,R4,
	LB	R0,REVTAB,R1,
	STB	R0,CPXD1,RL

	LB	R1,3,R4,
	LB	R0,REVTAB,R1,
	STB	R0,CPXD2,RL
	J	BSXW60			:Turn off rts, etc at end




	SUBTTL	SEND DATA MESSAGE

:	SEND DATA MSG.	EACH BIG BUFFERLET IN THE CHAIN IS QUEUED
:	AS A SEPARATE WRITE COMMAND.	THE SIZE OF EACH IS ASSUMMED
:	TO BE THE BUFFERLET SIZE-1 (HW'S, -1 FOR CHAIN) EXCEPT THE LAST.
:	------------------------------------------------------------

BSXW30	LHL	RCNTX,BSXCNT,RL2	:FETCH DATA HW CNT
	LHL	RDAT,BSXDAT,RL2		:FETCH DATA CHAIN ADDRESS
	LA	RBUF,BBUFER,,		:BASE ADDRESS OF BIG BUFFERLETS


:	Now we keep the header to this text message, for use later if
:	we want to observe activity on the line.

	LB	R1,BBUFER+1,RDAT,
	LB	R0,REVTAB,R1,
	STB	R0,CPXGRP,RL

	LB	R1,BBUFER+2,RDAT,
	LB	R0,REVTAB,R1,
	STB	R0,CPXSUB,RL

	LB	R1,BBUFER+3,RDAT,
	LB	R0,REVTAB,R1,
	STB	R0,CPXFLO,RL

	LB	R1,BBUFER+4,RDAT,
	LB	R0,REVTAB,R1,
	STB	R0,CPXD1,RL

	LB	R1,BBUFER+5,RDAT,
	LB	R0,REVTAB,R1,
	STB	R0,CPXD2,RL

	LI	RCMD,CWRITE^10+BBFLSZ-2 :WRITE COMMAND

BSXW40	AR	RDAT,RBUF		:MAKE ADDRESS OF BUFFERLET
	SHI	RCNTX,BBFLSZ-2		:FULL BUFFERLET ?
	JLE	BSXW50			:JUMP IF NOT, LAST
	STM	RCMD,8,RAD		:PUT CMD\CNT / DATA ADDR ON LIST
	LHL	RDAT,BBFLSZ-2,RDAT	:GET REL ADDR NEXT BUFFERLET IN CHAIN
	AIS	RAD,8			:MOVE LIST POINTER
	SIS	RLSZ,1			:DEC LIST POSITION CNTR
	JG	BSXW40			:JUMP ROOM LEFT

BSXWCR	JAL	R10,CRASH,,		:XMT LIST TOO SMALL
	BC	0,0,0,CRXLST


:	QUEUE LAST WRITE COMMAND - IF FINAL BUFFERLET BYTE CNT ODD,
:	ADD A PAD TO THE END OF THE DATA
BSXW50	THI	RCNTX,1		 	:ODD BYTE CNT ?
	JEFS	BSXW55			:JUMP IF NOT
	LHI	R5,RPAD		 	:PUT PAD AT END,ONLY CAN SEND HW
	STB	R5,BBFLSZ-2,RDAT,RCNTX
	AIS	RCNTX,1		 	:UPDATE CNT

BSXW55	AR	RCMD,RCNTX		:MAKE LAST WRITE CMD\CNT
	STM	RCMD,8,RAD		:PUT CMD\CNT / DATA ADDR ON LIST



:	PUT 'TURN OFF RTS' ON LIST IF NECESSARY
BSXW60
	LM	RCMD,PADMOP,,		:GET OUTPUT PADS CMD
	STM	RCMD,10,RAD
	TBT	RL,RTSCTS,,		:RTS/CTS HANDSHAKE NEEDED ?
	JEFS	BSXW70			:JUMP IF NOT

	AIS	RAD,8			:ADVANCE LIST POINTER
	SIS	RLSZ,1			:DEC LIST POSITION CNTR
	JLE	BSXWCR			:GO CRASH LIST FULL
	LIS	RCMD,CRTSOF		:PUT 'TURN RTS OFF' ON LIST
	STH	RCMD,10,RAD

:	END LIST AND START OPERATION
BSXW70	LIS	RCMD,CSBT		:GET SET BIT COMMAND
	EXHR	RCMD,RCMD		:POSITION
	OR	RCMD,RL		 	:INCLUDE BISYNC LINE NUMBER
	LA	RDAT,BSXOCP,,		:GET ADDR BIT ARRAY
	STM	RCMD,18,RAD		:PUT CMD / ADDR ON LIST

	LIS	RCMD,CHALT		:END LIST WITH HALT CMD
	STH	RCMD,20,RAD
	RBT	RL,BSXOCP,,		:RESET OP COMPLETE FLAG

	LB	RLUN,XLUN,RL,		:GET LOGICAL UNIT NO. FOR LINE
	L	RAD,XLISTX,RL2,RL2	:GET LIST ADDR FOR LINE

	IF BSXTSW;	JAL R4,BSXTRC;	EI	:BSXTSW
	SVC	IOCTRL,FORCEO^4+RLUN	:FORCE OUTPUT
	J	SVCER2			:CRASH,IF CALLING ERROR

	JALR	R5,RRET		 	:RETURN TO PROCESS ACTIVATOR


:	WATCH FOR OPERATION COMPLETE
:	----------------------------
:	SYNC I/O UNIT DRIVER WILL SET-BIT FOR LINE WHEN COMMAND LIST FOR XMT
:	IS COMPLETE (CMD TO SBT WAS PUT AT END OF LIST). WATCH FOR SIGNAL
:	AND CHECK TIMER TO SEE IF OPERATION IS TAKING TOO LONG.

BSXCOM	TBT	RL,BSXOCP,,		:XMT OP COMPLETE ?
	JN	BSXOEN			:JUMP IS SO
	LO	C03RCV
	L	R2,RRINGX,RL2,RL2	:SYNCHRONIZE EMPTY INDEX TO
	LHL	R2,0,R2		 	:CURRENT FILL RING INDEX
	STH	R2,RRGETX,RL2		:(AVOIDS WRAP AROUND)
	FO	C03RCV
	L	R2,BSXTIM,RL2,RL2	:GET FASTC TIME TO STOP OP
	JEFS	BSXC10			:JUMP NOT CHECKING
	S	R2,FASTC,,		:TIME UP ?
	JLEFS	BSXOTM			:JUMP IF SO

BSXC10	JAL	R5,XDMISS		:GO DISMISS
	J	BSXCOM			:CHECK AGAIN


:	XMT TIMEOUT
:	-----------
:	XMT OPERATION DID NOT COMPLETE WITHIN TIME SPECIFIED BY USER.
:	HALT OPERATION AND TURN RTS OFF IF NECESSARY

BSXOTM	L	RAD,XLISTX,RL2,RL2	:GET ADDR LINE'S XMT LIST
	TBT	RL,RTSCTS,,		:RTS/CTS HANDSHAKE NEEDED ?
	JEFS	BSXOT2			:JUMP IF NOT
	LIS	RCMD,CRTSOF		:PUT 'TURN OFF RTS' ON LIST
	STH	RCMD,0,RAD
	AIS	RAD,8			:GO TO NEXT LIST ENTRY

BSXOT2	LIS	RCMD,CHALT		:PUT HALT ON LIST
	STH	RCMD,0,RAD

	LB	RLUN,XLUN,RL,		:GET LOGICAL UNIT NO. FOR LINE
	L	RAD,XLISTX,RL2,RL2	:GET LIST ADDR FOR LINE

	IF BSXTSW;	JAL R4,BSXTRC;	EI	:BSXTSW
	SVC	IOCTRL,FORCEO^4+RLUN	:FORCE OUTPUT
	J	SVCER2			:CRASH,IF CALLING ERROR

	LIS	RCMD,XMTTMO		:FLAG XMT TIMEOUT
	JFS	BSXOE2			:GO ACTIVATE PROTOCOL DRIVER


:	XMT OP COMPLETE
:	---------------
:	TAKE US OFF THE XMT RUN LIST AND PUT US ON THE PROTOCOL RUN LIST.
:	WHEN ACTIVATED, RETURN TO ORIGNAL CALLER WITH OPERATION RESULTS.

BSXOEN	LIS	RCMD,XMTOK		:FLAG OP OK
BSXOE2	STB	RCMD,BSXRTC,RL		:SAVE

	LA	RAD,BSXEND		:PUT US ON PROTOCOL RUN LIST
	ST	RAD,PRUNL,RL2,RL2
	J	XHALT			:DISCONNECT LINE FROM TRANSMIT RUN LIST

:	PROTOCOL RUN LIST ACTIVE, RETURN TO CALLER
BSXEND	LB	R0,BSXRTC,RL		:GET RETURN CODE
	L	R5,BSXRTA,RL2,RL2	:GET RETURN ADDR
	JR	R5			:RETURN

SVCER2
	JAL	R10,CRASH,,
	BC	0,0,0,CRSVCE


	IF	BSXTSW
:	XMT OUTPUT LIST TRACE
:	---------------------
:	THIS ROUTINE TRACES TRANSMIT OPERATIONS BY COPYING THE XMT LIST
:	GIVEN TO THE SVC TO A CIRCULAR TRACE BUFFER. FORMAT OF THE TRACE IS:
:
:	1234 1234 LUN(2) ADDR(2) LIST(8) ... LIST(8) 0(2) GARBABE(6)
:
:	1234	FLAGS START OF TRACE ENTRY, 4 BYTES
:	LUN	LOGICAL UNIT NUMBER OF LINE, 2 BYTES
:	ADDR	LAST HW OF ADDRESS OF SVC, 2 BYTES
:	LIST	XMT LIST ENTRY, 8 BYTES
:	0	END OF THIS XMT LIST, 2 BYTES
:	GAR	GARBAGE AT END OF LIST, 6 BYTES
:
:	BSXTBL	TRACE TABLE, BSXTSW K-BYTES LONG
:	BSXTRX	NEXT ENTRY IN TRACE TABLE TO BE FILLED (HALF-WORD)

BSXTRC	STM	R12,BSXTSV		:SAVE WORK REGISTERS
	LHL	R13,BSXTRX		:GET TRACE BUFFER INDEX
	LI	R14,12341234		:FLAG START OF TRACE
	ST	R14,BSXTBL,R13,
	STH	RLUN,BSXTBL+4,R13,	:SAVE LOGICAL UNIT NO.
	STH	R4,BSXTBL+6,R13,	:SAVE ADDR OF SVC
	AIS	R13,8			:ADVANCE TRACE INDEX
	CLHI	R13,BSXTSW*400
	JLFS	.+4
	LIS	R13,0

	LR	R12,RAD		 	:COPY ADDR OF LIST
BSXTR2	LM	R14,0,R12		:COPY LIST ENTRY
	STM	R14,BSXTBL,R13,
	AIS	R12,8			:UPDATE LIST INDEX
	AIS	R13,8			:UPDATE TRACE INDEX
	CLHI	R13,400*BSXTSW
	JLFS	.+4
	LIS	R13,0

	SRL	R14,10,0		:END OF LIST ?
	JNBS	BSXTR2			:JUMP IF NOT
	STH	R13,BSXTRX		:SAVE TRACE INDEX
	LM	R12,BSXTSV		:RESTORE REG'S
	JR	R4			:RETURN

	SEG	A.DATA
BSXTSV	WS	10-R12			:REG SAVE AREA
BSXTRX	HC	0			:TRACE TABLE INDEX
	SEG	A.BDAT
BSXTBL	WS	0
	RE BSXTSW;	BS 400; ER
	SEG	A.CODE
	EI				:BSXTSW

	FO	MAIN			:ACCESS BISYNC CONTROL CHAR DEFINITIONS
	FO	C03FEX			:ACCESS BISYNC FG EXECUTION RUN LISTS
	FO	C03BLK

	EM


	SUBTTL	ICL C03 DTR Signal Processing

	RA	0
	MO	.,C03DTR
	LO	C03BLK
	GL	C03DTR,C03DSR


:	ISIS SYNCHRONOUS OUTPUT COMMANDS

CHALT	EQ	0		: HALT OUTPUT
CDSR	EQ	7		: CONNECT DATA SET READY BIT ARRAY
CDTROF	EQ	8		: DISABLE DATA TERMINAL READY
CDTRON	EQ	9		: ENABLE DATA TERMINAL READY


:	ISIS SYNCHRONOUS SVC OP CODES

FORCEO	EQ	2		: FORCE OUTPUT
IOCTRL	EQ	3		: I/O CONTROL


:	VARIABLES
:	---------

	SEG	A.RING

	BND	10

DSRINT	HS	5		: CONNECT DSR WORK LIST, MUST BE WORD BOUNDRY
C03DSR	HS	(NBILIN-1)/10+1 : DATA SET READY BIT ARRAY, 1=OFF

	SEG	A.DATA

:	DTR COMMAND LISTS
:	-----------------
DTROFF	WC	CDTROF^10	: DISABLE DTR
	WC	0		: (NOT USED)
	WC	CHALT^10	: HALT LIST

DTRON	WC	CDTRON^10	: ENABLE DTR
	WC	0		: (NOT USED)
	WC	CHALT^10	: HALT LIST

	SEG	A.CODE

:	CONFIGURE DTR/DSR HANDSHAKE LINES
:	---------------------------------

:	THE FOLLOWING CODE CREATES A BIT ARRAY DTRDTR FROM USER INPUT
:	SDTR0,SDTR1,...,SDTR|NBILIN| WHICH THE CODE TESTS TO DETERMINE
:	IF DTR/DSR HANDSHAKE MUST BE PERFORMED BEFORE DATA IS TRANSMITTED
:	OR RECEIVED (HANDSHAKE IS PERFORMED BY BACKGROUND AND IS
:	TYPICALLY RAISE DTR, WAIT FOR DSR, USE LINE, LOWER DTR, WAIT
:	FOR DSR TO DROP, RAISE DTR, ...).	BIT ARRAY IS INDEXED BY RL,
:	1 = HANDSHAKE REQUIRED.

DTRDTR	HS	0
QQ	EQ	0
Q	EQ	0
	RE	NBILIN; NOLIST
QQ	EQ	QQ+(SDTR|Q|&1)^(0F-(Q&0F))
Q	EQ	Q+1
	IF Q&0F;	ELSE;
	HC QQ	;QQ EQ 0;	EI
	ER

	IF	Q&0F
	HC	QQ
	EI
	LIST


:	C03DTR - DETERMINE CALLER TYPE
:	------------------------------

C03DTR	LR	R0,R0		: INITIALIZE ?
	JGE	DTR100		: JUMP IF NOT, ENABLE/DISABLE DTR

:	INITIALIZE - CONNECT DSR ARRAY FOR ALL LINES USING DTR/DSR HANDSHAKE
:	--------------------------------------------------------------------
	LA	R3,DSRINT,,	: BUILD INITIALIZE DSR COMMAND LIST
	LI	R0,CDSR^10	: PREPARE 1ST WORD, COMMAND\BISYNC LINE NO.
	ST	R0,0,R3
	LA	R0,C03DSR,,	: SET 2ND WORD, BASE ADDRESS OF BIT ARRAY
	ST	R0,4,R3
	LIS	R0,CHALT	: SET 3RD WORD, HALT COMMAND
	STH	R0,8,R3

	TBT	R1,DTRDTR	: DTR/DSR HANDSHAKE REQUIRED ON THIS LINE?
	JNFS	DSR020		: JUMP IF SO
	SBT	R1,C03DSR,,	: INIT DSR OFF
	JR	R5		: RETURN

DSR020	STH	R1,2,R3		: PUT BISYNC LINE NO. INTO 1ST WORD
	LO	C03SRV
	LB	R2,BSRLUN,R1,	: GET LOGICAL UNIT NUMBER
	FO	C03SRV

	SVC	IOCTRL,FORCEO^4+R2	: Force Output
	J	SVCER1			: CRASH,IF CALLING ERROR
	JR	R5		: RETURN TO CALLER

:	ENABLE/DISABLE DTR
:	------------------
DTR100	TBT	R1,DTRDTR	: LINE USE DTR/DSR HANDSHAKE
	JNFS	DTR200		: JUMP IF SO, PASS ON TO HARDWIRE

: LINE DOES NOT USE DTR/DSR HANDSHAKE, COPY DTR TO DSR FOR COMPATIBILITY

	LR	R0,R0		: ENABLE/DISABLE ?
	JEFS	DTR110		: JUMP ENABLE
	SBT	R1,C03DSR,,	: DISABLE DSR
	JR	R5		: RETURN

DTR110	RBT	R1,C03DSR,,	: ENABLE DSR
	JR	R5		: RETURN

: PASS DTR COMMAND TO HARDWARE

DTR200	LR	R0,R0		: ENABLE/DISABLE ?
	JEFS	DTR210		: JUMP ENABLE
	LA	R3,DTROFF	: GET DISABLE COMMAND LIST
	LI	R0,CDTROF^10	: USE DISABLE COMMAND
	JFS	DTR220		: GO EXECUTE

DTR210	LA	R3,DTRON	: GET ENABLE COMMAND LIST
	LI	R0,CDTRON^10	: USE ENABLE COMMAND
DTR220
	ST	R0,0,R3		: PLANT COMMAND IN LIST - AUG88
	LO	C03SRV
	LB	R2,BSRLUN,R1,	: GET LOGICAL UNIT NUMBER
	FO	C03SRV

	SVC	IOCTRL,FORCEO^4+R2	: CONNECT INPUT
	J	SVCER1			: CRASH,IF CALLING ERROR
	JR	R5		: RETURN

SVCER1
	JAL	R10,CRASH,,
	BC	0,0,0,CRSVCE

	FO	C03BLK
	EM


	SUBTTL	ICL C03 Bisync Protocol Driver


	RA	0
	MO	.,C03PTP

	GL	PTPTSW,C03PTP,HRVINI

	LO	C03RCV
	LO	C03SXM
	LO	C03FEX
	LO	C03BLK
	LO	MONBLK
	LO	MAIN

DERR	MACRO(ETYP)
	[
	LHI	R3,ETYP		: LOAD ERROR TYPE
	JAL	R5,SETERR	: COUNT ERROR AND COMPARE TO LIMIT
	]			: (REPORT TO B.G. IF LIMIT REACHED)


:	LINE OPTION VALUE TABLE GENERATION
:	----------------------------------
:THE FOLLOWING MACRO GENERATES A TABLE FOR A SPECIFIC LINE
:OPTION THAT IS HW INDEXED BY BSC LOGICAL LINE NUMBER.
:THE TABLE IS REFERENCED IN CODE BY:
:	LHL REG,OPT.LN,RL2	OPT=OPTION
:
:MACRO USAGE	: MAC(OPT,DFAULT,MODS)
:		OPT=OPTION NAME ENDING IN'.'
:		DFAULT=DEFAULT, EVALUATED IN DECIMAL.
:		MODS=OPERATION TO BE PERFORMED ON USER
:		DEFINED VALUE OR DEFAULT (LIKE SCALING).

	KILL	MAC		: KILL PREVIOUS TEMP MACRO
MAC	MACRO(OPT,DFAULT,MODS)[
OPT`LN	HS	0		: START OF TABLE FOR THIS OPTION
Q	EQ	0
	RE	NBILIN
	IF	$A`\OPT|Q|
	HC	$A`OPT HW I	S`MODS	: USER SPECIFIED VALUE
	ELSE
	HC	$A`DFAULT`MODS	: DEFAULT
	EI
Q	EQ	Q+1
	ER
	]

: Macro to initialise the LINTAB and PGRTAB data chain and byte count
: entries from RBBCHN nad ROBCNT for an Mplx or Multi-drop configuration

GETDAT	MACRO[
	LHL	R3,RBBCHN,RL2	
	LHI	RBX,-BBFLSZ+2
]

STATE	MACRO(NWSTAT)[
	LHI	R0,NWSTAT-SEG|A.CODE|
	STH	R0,LINTAB+MSTATE,RLNE,
]


:	DATA,CONSTANT AREA
:	------------------

TSCALE	EQ	2		: SCALING TO KEEP HALFWORD'S POSITIVE
TPS	EQ	RATE^(-TSCALE)	: SCALED TICKS PER SECOND

	SEG	A.DATA
PROADR	WS	1		: For address of LNPOLL
WDTEMP	WS	1		: TEMP PLACE TO HOLD WD

	SEG	A.CODE

	MAC(TXM.,03,*TPS)	: TIME ALLOWED XMT OPERATION




:	C03PTP - START PROTOCOL DRIVER
:	------------------------------

C03PTP	LR	R2,R1			: MAKE LINE WORD INDEX
	LIS	R4,0
	STH	R4,C03XER,R1,R1		: RESET XMT ERROR CNTR
	STH	R4,CNTBCC,R1,R1		: RESET BCC ERROR CNT
	STH	R4,CNTPER,R1,R1		: RESET PARITY ERROR CNTR
	STH	R4,CNTUDM,R1,R1		: RESET UNDEFINED ID CNTR
	STH	R4,CNTRTO,R1,R1		: RESET RECEIVE TIME OUT CNTR
	STH	R4,CNTORN,R1,R1		: RESET BB OVERRUN CNTR
	IF	RTMTRA
	STH	R4,RTMIND,R1,R1
	EI
	IF	XTMTRA
	STH	R4,XTMIND,R1,R1
	EI
	IF	ITMTRA
	STH	R4,ITMIND,R1,R1
	EI
	IF	OTMTRA
	STH	R4,OTMIND,R1,R1
	EI
	LA	R3,HRVINI
	ST	R3,PRUNL,RL2,RL2	: THIS WAS WRONG BEFORE - RT JUL88
	RBT	R1,PTPHLT		: TURN DRIVER ON
	JR	R5			: RETURN

	SUBTTL	C03 Sync I/O Processes - XMTRCV, XMT, RCV

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		S Y N C	I / O	P R O C E S S E S			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:	E PROCESSES INTERFACE TO THE BISYNC I/O LIBRARY ROUTINES.	: 
:	WHEN RCV OP COMPLETE, RETURN CODE USED TO BRANCH THROUGH	: 
:	CURRENT STATE TABLE.						: 

:	XMTRCV - DO A XMT THEN RCV OPERATION
:	------------------------------------

:	INPUT:	R0	-RCV TIMEOUT VALUE (HALF WORD IN FASTC TICKS)
:		R1	-OP CODE FOR XMT
:		R2	-XMT HW DATA CNT (HALFWORD)
:		R3	-XMT DATA CHAIN ADDRESS (HALFWORD REL TO BBUFER)
:		R4	-BUFFERLET LIMIT FOR RCV OPERATION (HALFWORD)
:	OUTPUT: R1	-NO. RCV BUFFERLETS USED (IF DATA RCV'D)
:		R2	-RCV RETURN CODE * 2
:		R3	-RCV DATA CHAIN ADDRESS (IF DATA RCV'D)
:	LINK:	-STATE HAS CURRENT STATE TABLE. RETURN MADE BASED
:		ON RCV RETURN CODE. NON-DEDICATED REGS NOT SAVED.

XMTRCV
	STH	R4,RCVBCT,RL2		: SAVE RCV BUFFERLET LIMIT

	JAL	R5,XMT			: DO XMT 

	LHL	R1,RCVBCT,RL2		: GET BUFFERLET CNT
	JFS	RCV010


:	RCV - DO A RCV OPERATION
:	------------------------

:	INPUT:
:		R1	-BUFFERLET LIMIT FOR RCV OPERATION (HALFWORD)
:	OUTPUT:
:		SAME AS FOR XMTRCV
:	LINK:
:		SAME AS FOR XMTRCV

RCV	STH	R1,RCVBCT,RL2		: SAVE BUFFERLET CNT FOR RETRY

	LCS	R5,1
	STB	R5,XMTOPC,RL
RCV010
	L	R0,RCVTIM,RL2,RL2	: Get the time allowed for RCV
	JEFS	RCV020			: JUMP IF NOT
	A	R0,FASTC,,		: COMPUTE OP END-TIME
RCV020	ST	R0,RCVTIM,RL2,RL2	: SAVE END-TIME

RCV100	TBT	RL,PTPHLT		: HALT PROTOCOL DRIVER ?
	JN	PHALT			: JUMP IF SO
	JAL	R5,BSR100		: DO SINGLE RCV
	L	R5,FASTC,,
	ST	R5,RCTIME,RL2,RL2	: Save RCV end FASTC
	TBT	RL,PTPHLT		: HALT PROTOCOL DRIVER ?
	JN	PHALT			: JUMP IF SO

RCV110
: Create an entry in PTPTTB for the current line (RL) if PTRBIT is set.
: ---------------------------------------------------------------------

	TBT	RL,PTRBIT		: Are we tracing this line ?
	JE	RCV150			: No, bypass

	LHL	R7,PTPPTR,RL2,		: Get the PTPTTB index for line RL
	LHL	R6,PTPTRX,RL2,		: Get the index within that PTPTTB


: Now record a new entry
: ----------------------


:	Here, we store details of the last receive operation

PTRC20	STB	R1,PTPTTB+O.ROP,R6,R7,	: Save last RCV op code

	CLHI	R1,RCPOLL		: Was it a poll ?
	JN	PTRC25			: yes, get recvd grp and sub

	LB	R4,RCSAC,RL		: Else, for poll, use these
	STB	R4,PTPTTB+O.RGRP,R6,R7,

	LB	R4,RCSACQ,RL
	STB	R4,PTPTTB+O.RSUB,R6,R7,
	J	PTRC26			: continue


PTRC25	LB	R4,RCVGRP,RL		: Get the RCV GRP address
	STB	R4,PTPTTB+O.RGRP,R6,R7,

	LB	R4,RCVSUB,RL		: Get the RCV SUB address
	STB	R4,PTPTTB+O.RSUB,R6,R7,

PTRC26	LB	R4,RCVPRE,RL		: Get received prefix
	STB	R4,PTPTTB+O.RPRE,R6,R7,

	LB	R4,RCVD1,RL		: and 1st byte of data
	STB	R4,PTPTTB+O.RD1,R6,R7,

	L	R4,RCTIME,RL2,RL2	: Get the RCV end FASTC
	ST	R4,PTPTTB+O.RE,R6,R7,


:	Now store details of the last transmit operation

	LB	R0,XMTOPC,RL		: Get the last XMT op code
	STB	R0,PTPTTB+O.XOP,R6,R7,

	LB	R4,CPXGRP,RL		: Get the XMT GRP address
	STB	R4,PTPTTB+O.XGRP,R6,R7,

	LB	R4,CPXSUB,RL		: Get the XMT SUB address
	STB	R4,PTPTTB+O.XSUB,R6,R7,

	LB	R4,CPXFLO,RL		: Get XMT Flowcontrol byte
	STB	R4,PTPTTB+O.XFLO,R6,R7,

	LB	R4,CPXD1,RL		: Get 1st XMT text byte
	STB	R4,PTPTTB+O.XD1,R6,R7,

	LB	R4,CPXD2,RL		: Get 2nd XMT text byte
	STB	R4,PTPTTB+O.XD2,R6,R7,

	L	R4,XMTIME,RL2,RL2	: Get the XMT start FASTC
	ST	R4,PTPTTB+O.XS,R6,R7,


: Now bump the PTPTTB index for next time thru
: --------------------------------------------

	AHI	R6,PTPLEN		: Bump it
PTRC30
	CLHI	R6,PTPLEN*PTPENT	: Are we at the end ?
	JLFS	PTRC40			: No, go save it
	LIS	R6,0			: Yes, wrap to the start again
PTRC40
	STH	R6,PTPTRX,RL2,		: Save index

RCV150
	L	R5,PROADR		: Enter LNPOLL
	JR	R5



:	RECEIVE RETRY
:	-------------
:	THIS PROCESS IS USED BY STATE TABLES TO RETRY THE LAST RCV
:	OPERATION AND WATCH OP END-TIME. IT IS TYPICALLY
:	INVOKED ON LOST SYNCHRONIZATION RETURN CODE AND WILL RETRY THE
:	LAST OPERATION UNLESS OP END-TIME IS UP. IN THAT CASE, IT FAKES
:	A RCV TIMEOUT RETURN CODE.

RCVRTY	LHL	R1,RCVBCT,RL2		: GET BUFFERLET CNT

	LCS	R0,2			: FLAG RCV RETRY AS XMT OP IN TRACE
	STB	R0,XMTOPC,RL

	L	R0,RCVTIM,RL2,RL2	: GET OP END-TIME VALUE
	JE	RCV100			: JUMP NOT KEEPING TIME
	CL	R0,FASTC,,		: END-TIME YET ?
	JG	RCV100			: JUMP IF NOT, RETRY OP
	LHI	R1,RCTMOT		: GET TIME-OUT RETURN CODE
	J	RCV110			: GO HANDLE AS TIMEOUT



:	XMT - THIS ROUTINE IS THE INTERFACE TO THE SINGLE XMT ROUTINES.
:	---------------------------------------------------------------

:	INPUT:	R1	-OP CODE FOR C03SXM
:		R2	-HW DATA CNT (HALFWORD)
:		R3	-DATA CHAIN ADDRESS (HALFWORD REL TO BBUFER)
:	OUTPUT: C03XER	-INCREMENTED FOR EACH ERROR, RESET ON COMPLETE
:	LINK:	R5	-NOTE THAT NO NON-DEDICATED REGISTERS ARE SAVED

XMT	STB	R1,XMTOPC,RL		: SAVE XMT OP CODE
	STH	R2,XMTCNT,RL2		: SAVE XMT BUFFERLET CNT
	ST	R5,XMTRET,RL2,RL2	: SAVE RETURN ADDRESS

: Record the occurence of the type of transmit message in XMTHRT
: --------------------------------------------------------------
	SLLS	R1,1			: Make xmit code a H/W index

	LHL	R5,XMTPTR,RL,RL		: Absolute line number for HIF

	LIS	R0,1
	AHM	R0,XMTHRT,R1,R5,	: Count the msg sent
	SRLS	R1,1			: Restore the original R1
:---------------------------------------------------------------

	LI	R0,0			: Clear the current RCV
	STH	R0,LINTAB+CPRGRP,RLNE,	: GRP and ....

:	START XMT OP, IF OK WHEN DONE, RETURN
XMT050
	LHL	R0,TXM.LN,RL2
	SLLS	R0,TSCALE		: SCALE
	A	R0,FASTC,,		: MAKE REAL END TIME
	TBT	RL,PTPHLT		: HALT PROTOCOL DRIVER ?
	JN	PHALT			: JUMP IF SO
	L	R5,FASTC,,
	ST	R5,XMTIME,RL2,RL2	: Save XMT start FASTC
	JAL	R5,BSX100		: GO DO SINGLE XMT OP
	TBT	RL,PTPHLT		: HALT PROTOCOL DRIVER ?
	JN	PHALT			: JUMP IF SO
	LR	R0,R0			: OP OK ?
	JNFS	XMT110			: JUMP IF NOT, FLAG ERROR AND RETRY
	STH	R0,C03XER,RL2		: RESET ERROR CNTR
	L	R5,XMTRET,RL2,RL2	: GET RETURN ADDR
	JR	R5			: RETURN

:	XMT ERROR, COUNT, AND RETURN

XMT110	LIS	R0,1			: COUNT ERROR
	AHM	R0,C03XER,RL2
 
:	RECORD ERROR IN FG MONITOR RING
 
	L	R5,XMTRET,RL2,RL2	: RETURN
	JR	R5
 
	SUBTTL	C03 Protocol Handler Utility Routines

: ======================================================================

:	PUTCLT - STORE OUTPUT CHARS INTO CMD LIST AREA
:	----------------------------------------------
:	INPUT:	R4 -- CONTAINS THE CHAR WANT TO BE STORED
:		R2 -- CONTAINS THE INDEX TO UPDATE CMD LIST AREA
:		R5 -- LINK ADDRESS
:	OUTPUT: R2 -- NEW INDEX

PUTCLT
	LB	R3,PARTAB,R4,		: GET REVERSED GRP AND PARITY
	L	R4,XCLIST,RL2,RL2	: GET OUTPUT COMMAND LIST
	AIS	R2,1			: UPDATE INDEX
	STB	R3,XCSIZE-2,R4,R2	: STORE CHAR INTO LIST
	JR	R5

:	FGETBC - GET NEXT CHAR FROM BUFFER CHAIN FOR F.G.
:	-------------------------------------------------
:	INPUT	: R5 (INDEX) R6 (BUFFER POINTER) R7 (# OF BYTES TO FIND)
:	OUTPUT	: R0 (AFTER REVERSE)
:	LINK	: R4
:	DESTROY R0,R1,R5,R6,R7

FGETBC
	AIS	R5,1			: ADVANCE OFFSET
	JNFS	FGETB1
	LR	R5,R6
	LHL	R6,BBUFER+BBFLSZ-2,R6,
	JN	FGETB0
	JAL	R10,CRASH,,
	BC	0,0,0,CRNGBC

FGETB0
	LHI	R5,-BBFLSZ+2
FGETB1
	LB	R1,BBUFER+BBFLSZ-2,R6,R5
	SIS	R7,1
	JG	FGETBC
	NHI	R1,0FE
	LB	R0,REVTAB,R1,
	JR	R4


PTPCRA
	JAL	R10,CRASH,,
	BC	0,0,0,CRGSUB


	FO	C03RCV
	FO	C03SXM
	FO	C03FEX
	FO	C03BLK
	FO	MONBLK
	FO	MAIN
 
	EM


	SUBTTL	ICL C03 host Interface Protocol Manager
:
	RA	0
	MO	.,C03PTP

	GL	GETBC,RTMOUT,HRVINI
	LO	MAIN
	LO	C03RCV
	LO	C03SRV
	LO	C03SXM
	LO	C03BLK
	LO	C03FEX
	LO	CMDLST

	SEG	A.DATA

XHDATA	EQ	0		: XMT CMD TYPE IS DATA
XHSTAT	EQ	1		: XMT CMD IS STAT RESPONSE


	SEG	A.CODE

	SUBTTL	ICL c03 Host Interface Protocol Manager - State Tables

:	RVIDLE	: RECEIVE INITIAL STATE
:	WAITING FOR HOST POLLING/SELECTING, AND HANDLES THE RESPONSE
:	------------------------------------------------------------

RVIDLE
	HC	RCVRTY-SEG|A.CODE|	: LOST SYNCHRONIZATION
	HC	RCVRCV-SEG|A.CODE|	: OVERRUN (MORE DATA THAN BB)
	HC	RCVRCV-SEG|A.CODE|	: TIMEOUT BEFORE MSG RECEIVED
	HC	ENOBUF-SEG|A.CODE|	: LOST DATA DUE TO INAVAL. OF BB
	HC	RCVRCV-SEG|A.CODE|	: RCV UNDEFINED MSG
	HC	RCVRCV-SEG|A.CODE|	: PARITY ERROR OUTSIDE SELECT
	HC	ESELEC-SEG|A.CODE|	: BAD BCC IN RECOGNISED SELECT
	HC	ESELEC-SEG|A.CODE|	: PARITY ERROR IN SELECT 5.6.1.1
	HC	RSELEC-SEG|A.CODE|	: VALID SELECT SEEN
	HC	RPOLL-SEG|A.CODE|	: VALID POLL SEEN


LDREPLY	MACRO	[
	JAL	R5,GETFLOW		: Get flow control byte
	LHI	R2,-XCSIZE+1		: Initialise offset in tx list
	LH	R4,PGRTAB+LLSTAT,RGRP,	: Get LLSTAT
	JAL	R5,PUTCLT

	LH	R4,PGRTAB+FLOWCL,RGRP,	: Get flow control byte
	JAL	R5,PUTCLT

	LH	R4,PGRTAB+HLSTAT,RGRP,	: Get HL sta we are to use
	JAL	R5,PUTCLT
]

:
:	Now see if the sub weve read has been configured
:

VALSUB	MACRO	[
	LB	R7,RCVSUB,RL		: Get sub weve read 
	SHI	R7,BSUBAD		: Remove offset
	SLLS	R7,1			: Make h/w offset
	SULODS	RSUB,PGRTAB+SUBPTR,RGRP,R7	: Get entry for this sub
]

:
:	Now we clear bit in bit array for category
:

CBCLR	MACRO	[
	LR	R5,R1			: restore our bit position
	SLLS	R5,5
	LA	R6,PGRTAB+CAT1,RGRP,R5 : point to the bit in question

	LB	R2,PGRTAB+BPOS,RGRP,R1
	RBT	R2,0,R6			:  clear the bit in cat
]


:
:	Now we set bit in bit array for category
:

CBSET	MACRO	[
	LR	R5,R1			: restore our bit position
	SLLS	R5,5
	LA	R6,PGRTAB+CAT1,RGRP,R5 : point to the bit in question

	LB	R2,PGRTAB+BPOS,RGRP,R1
	SBT	R2,0,R6			:  clear the bit in cat
]

:
:	Clear bit in catn and cat 1 after being set to cat 0
:

CT0CLR	MACRO	[
	STB	R5,SUBTAB+SUBCAT,R4,	: update with new value
	LR	R7,R0			: use old cat #
	SIS	R7,1
	SLLS	R7,5			: point to cat we want
	PGLOAD	R6,SUBTAB+SUBGRP,R4,	: get group for sub
	LHL	R0,SUBTAB+SUBABS,R4,	: get abs sub # for this sub
	RBT	R0,PGRTAB+CAT1,R6,R7	: and clear bit in B.A. for cat

	LIS	R7,0			: also clear bit for int cat
	RBT	R0,PGRTAB+CAT1,R6,R7
]


:
:	Discard a fragment, decrease count
:

DSCFRG	MACRO	[
	LHI	RBX,-BBFLSZ+1
	JAL	R4,GETBC		: get mid/end fragment indicator

	PUSH(R0)			: and keep for later
	AIS	RBX,1			: not used

	JAL	R4,GETBC		: get 1st byte of count
	LBR	R1,R0			: & shift it up 8 bits
	EXBR	R1,R1
	JAL	R4,GETBC		: get 2nd byte of count
	AR	R1,R0			: and add to 1st digit

	LHL	R0,SUBTAB+IBCOUNT,RSUB,	: get old count
	SR	R0,R1			: subtract the size of this frag
	STH	R0,SUBTAB+IBCOUNT,RSUB,

	JAL	R5,PBBC,,		: free off the buffers

	LHL	R1,SUBTAB+SUBABS,RSUB,
	TBT	R1,NBPCLR		: see if we had set bp to n/w
	JN	DSCF10			: no, continue

:	Else, see if the count has now dropped to a level where we can 
:	release bp to n/w

	CLHI	R0,IBMAX-ALPSIZ
	JG	DSCF10			: no, still too much in q

:	Else, we can release bp to n/w by telling B.G.

	SBT	R1,NBPCLR		:  flag says bp not applied
	LHI	R2,NOWBPC
	PUTCMD(RCV,RSUB)
	RLCMD(RCV,RSUB,RGRP)

DSCF10	POP(R0)				: now get back mid/end alp flag
]


	SUBTTL	ICL C03 Host Interface Protocol Manager - Receive Routines

: We enter here from the protocol driver after completing a receive
: operation.

LNPOLL
	LHL	RLNE,LINPTR,RL,RL	
	LHI	R4,RVIDLE-SEG|A.CODE|	: Get base of table for state
	SLLS	R1,1			: Make rcv ret code a h/wd index
	LHL	R5,RSEG,R1,R4
	J	RSEG,R5			: Enter the Handler routine

: ======================================================================






: ---------------------------------------
: HRVINI - Protocol Handler Initial Entry
: 	Planted in Prunl by C03PTP, which
: 	is called from IZFG
: ---------------------------------------

HRVINI
	LHL	RLNE,LINPTR,RL,RL

	RBT	RL,PTPHLT

	LHL	R1,BSCRBC		: Bufferlet limit for receive op

	LB	R0,LINTAB+LNRSPN,RLNE,	: Receive block timeout value
	ST	R0,RCVTIM,RL2,RL2

	J	RCV			: Go for initial receive


: HRVCRA - Unexpected frame received from host
: --------------------------------------------

HRVCRA
HPXERR
	JAL	R10,CRASH
	BC	0,0,0,CRPRVE


: RCVRCV - A receive error occured. Initiate another receive operation
: --------------------------------------------------------------------

RCVRCV
	LR	R3,R3			: If it select, release buffer
	JEFS	RCVRC1			: NOT,JUMP
	JAL	R5,PBBC,,
RCVRC1
	LHL	R1,BSCRBC		: Bufferlet limit for receive op

	LB	R0,LINTAB+LNRSPN,RLNE,	: Reply time-out
	ST	R0,RCVTIM,RL2,RL2
	J	RCV


: -----------------------------------------------
: ENOBUF - No buffer available, send a BNA in NAK
: -----------------------------------------------
ENOBUF
	JAL	R5,INREP		: Initialise error flags
	LIS	R0,LLHR			: If LLHR set, send NAk
	TBT	R0,PGRTAB+LLSTAT,RGRP,
	JN	SNDNAK


	JAL	R5,INSEQ		: See if in sequence, 
	VALSUB				: and see if present
	JL	SDNPRE			: & if not present, 

:	Now see if device is operable. If CMT has not established a
:	circuit to this device yet, it will still be inop. If inop,
:	we must reject with nak, and set bit 5 in LL status as
:	described in 5.6.1.5 para b and at 6.4.3 para c.
:
:	The only exception to this is if we get an Access Level Reset
:	while the device is inop. In this case, we ack it.

	LHL	R0,SUBTAB+ALSTAT,RSUB,	: get the current AL status
	TI	R0,01			: see if inop
	JE	ENO2			: no, so continue checking

:	See if its an AL reset. if so, dont nak it but continue checking

	GETDAT				: Point to received data
	AIS	RBX,1
	JAL	R4,GETBC		: Get the ALP prefix
	CHI	R0,ALRES		: is it al reset
	JN	ENREJ			: no, so we can nak the block


:	Now see if we have been allowed to use the GCS bna mechanism.
:	If so, we will cause gcs bna to be sent in a nak, otherwise we
:	just nak the block as if it had bad bcc and hope that by the
:	time we get this text sent to us again we will have some free
:	buffers. This isnt very neat, and its a bit hard on the host 
:	since it may have to repeat the text n times, but what else
:	can we do ?!

ENO2	LIS	R0,GBNA
	TBT	R0,PGRTAB+GRPFLG,RGRP,	: see if GCS BNA enabled
	JE	SNDNAK			: no, so pretend we didnt see it

:	else we can send GCS BNA in nak. This will be released by B.G.
:	when it releases enough buffers, and sends a supervisory
:	status report to us which we use to clear the condition.

BNAGCS	LIS	R0,GBSENT		:set flag to say weve sent it
	SBT	R0,PGRTAB+GRPFLG,RGRP,
	LIS	R0,LHFAIL
	SBT	R0,PGRTAB+LLSTAT,RGRP,	: set ll fail bit
	LIS	R0,LGCSPR
	SBT	R0,PGRTAB+GCSTAT,RGRP,	: and say we have gcs status

	LIS	R0,GBNGCS
	SBT	R0,PGRTAB+GCSTAT,RGRP,	: set the BNA condition
	LH	R4,PGRTAB+GCSTAT,RGRP,
	STH	R4,PGRTAB+HLSTAT,RGRP,	: make gcstatus the hl status
	LDREPLY
	J	ENSEND			: go to send the nak




:
:	Now we want to send NAK with BNA and set a flag
:	for this sub so that we can later send s/r for each sub so
:	flagged once buffers become free again.
:

BNAIT	LH	R0,SUBTAB+SUBABS,RSUB,	: Get abs # of this sub
	SBT	R0,BNASENT		: Set bit in B.A.

:
:	Now set BNA in a NAK response
:
	
	LIS	R0,ABNA
	SBT	R0,SUBTAB+ALSTAT,RSUB,	: Set BNA in ALstat for sub

ENREJ	LIS	R0,AHERE
	SBT	R0,SUBTAB+ALSTAT,RSUB,	: and AL stat present(6.4.3d)

	LH	R4,SUBTAB+ALSTAT,RSUB,	: Get it
	STH	R4,PGRTAB+HLSTAT,RGRP,	: and use for HL stat

	LIS	R0,LHFAIL
	SBT	R0,PGRTAB+LLSTAT,RGRP,	: Also set HL.Failure in llstat
	LDREPLY				: plant these bytes in reponse
	J	ENSEND			: End by planting Nak


:	Now we tell host that this device selected does not exist. We
:	set HL fail bit and GCS status present bit in LL status, and
:	reply with a Nak. See 5.6.1.5
:
:	The exception to this is if weve received an AL reset - we
:	always Ack this.
:	Now see if weve received an AL reset - but first see if any
:	data received at all as we could have arrived here from ENOBUF
:	
:	All this was changed on 11 Feb 88 - We now always send Ack.

SDNPRE	LIS	R0,LHFAIL		: Set HL fail in LL stat
	SBT	R0,PGRTAB+LLSTAT,RGRP,

	LIS	R0,LGCSPR		: Set GCS Status present(5.5.7)
	SBT	R0,PGRTAB+LLSTAT,RGRP,	: in LLSTAT
	LIS	R0,GSNOTP		: Set Sub not present in GCS st
	SBT	R0,PGRTAB+GCSTAT,RGRP,
	LH	R4,PGRTAB+GCSTAT,RGRP,	: and move GCS status into 
	STH	R4,PGRTAB+HLSTAT,RGRP,	: HL status for group
	J	SDISC1			: Discard & Always send Ack - 11 Feb 88

:	Here, we prepare the Nak response. We return any used buffers
:	before we do so.

ENSEND	LHI	R4,NAK			: Finally plant the Nak at end
	JAL	R5,PUTCLT

	LHL	R3,RBBCHN,RL2		: See if any buffers used
	JE	ENS2			:

	JAL	R5,PBBC			: if so, get rid of them

ENS2	LIS	R1,SNAK			: TX Op code
	J	GOSEND			: TX this response, & enter RCV


: --------------------------------------------------------
: ESELEC - Received BCC error within a SELECT - send a NAK
: --------------------------------------------------------
:
ESELEC
	JAL	R5,INREP		: Initialise error flags
	LIS	R0,LLHR			: See if LLHR is still set
	TBT	R0,PGRTAB+LLSTAT,RGRP,
	JN	SNDNAK			: If so, just keep sending NAK

:
:	We now see if its in sequence, and if sub referenced
:	has been configured.

	JAL	R5,INSEQ
	VALSUB				: See if sub present
	JL	SDNPRE			: Not configured, inform via nak

:	Now see if device is operable. If CMT has not established a
:	circuit to this device yet, it will still be inop. If inop,
:	we must reject with nak, and set bit 5 in LL status as
:	described in 5.6.1.5 para b and at 6.4.3 para c.
:
:	The only exception to this is if we receive an AL reset for
:	an inoperable device. In this case, we send an ack.

	LHL	R0,SUBTAB+ALSTAT,RSUB,	: get the current AL status
	TI	R0,01			: see if inop
	JE	SNDNAK			: no, so carry on checking

:	See if this is an AL reset.

	GETDAT				: point to the received data
	AIS	RBX,1
	JAL	R4,GETBC		: get the AL prefix
	CHI	R0,ALRES		: is it AL reset
	JN	ENREJ			: no, so we can nak it


SNDNAK	VALSUB				: Get sub no
	LH	R4,SUBTAB+ALSTAT,RSUB,	: Get AL status for this sub
	STH	R4,PGRTAB+HLSTAT,RGRP,	: make this the HL status
	LDREPLY				: plant the status bytes for tx
	J	ENSEND			: Go to send the Nak response


: -------------------------------
: RPOLL - Received Poll in RVIDLE
: -------------------------------

RPOLL
	JAL	R5,INREP		: Initialise error flags
	LB	R0,RCSAC,RL		: see if w bit set
	NHI	R0,WBIT
	JE	RCVRCV			: No, ignore & try again-5.5.1.3
:
:	Else w=1, a valid poll

	JAL	R5,INSEQ		: See if in sequence

	LB	R1,RCSACQ,RL
	NHI	R1,07F			: See what sort of poll it is
	CHI	R1,040
	JE	TSPOLL			: Traffic status poll

	TI	R1,040
	JE	TSPOLL			: Also if bit 7 set - ts poll

	NHI	R1,03F			: Any cats being polled?
	JE	TSPOLL			: if not, then TS poll

:
:	Else its a group data poll, so try to send data if
:	its available.

GDPOLL	STB	R1,RCSACQ,RL		: keep the cats polled
	LIS	R0,LSEQR		: See if in seq
	TBT	R0,PGRTAB+LLSTAT,RGRP,
	JN	RETRANS			: No, so its a request for retransmit

	JAL	R5,AKTEXT		: Else its in sequence
	LIS	R0,IALPST
	TBT	R0,PGRTAB+GRPFLG,RGRP,	: See if we had started an ALP
	JE	SEARCH			: No, so search for next to send

:
:	Else, we can send next fragment from this device, irrespective
:	of the categories polled.

SNDFRAG	LH	R5,PGRTAB+LSTCAT,RGRP,	: Get last cat we sent from
	LHL	RSUB,PGRTAB+LSTSUB,RGRP,	: and last sub
	J	GOTB10

:
:	Here, we want to retransmit the last text block sent.
:	We simply set a flag so that the code setting up the
:	header can be skipped, otherwise we proceed as if
:	we are to send text (this last text will not have
:	been ackowledged.)

RETRANS
	LHL	R2,PGRTAB+LSTSIZ,RGRP,	: Get size of last frag sent
	AIS	R2,4			: allow for header
	LHL	RBA,PGRTAB+LSTBUF,RGRP,	: and address of its start
	JN	SENDIT			: go and send this next frag

	J	TSP01			: no retrans possible - 5.5.1.2


:
:	Here, weve been polled, and we had previously sent part of
:	an ALP, but now, the rest of it has not arrived. We can send
:	an ACK, with qualifiers as described in 6.3.5.1.

WTDATA
	LH	R0,SUBTAB+ALSTAT,RSUB,	: Get current AL status for dev
	OI	R0,2			: set bit1 - assume bit 7 set
	STH	R0,PGRTAB+HLSTAT,RGRP,	: and use this for our HL stat
	J	SNDACK


:
:	Search for a device with data to send in one of the polled
:	Categories.

SEARCH	LB	R1,RCSACQ,RL		: Get the polled cats
	LB	R2,REVTAB,R1		: Swap byte so we see cat1 first
	JFFO	R2,SEAR1		: Deal with the bit weve found
	J	TSPOLL			: Shouldnt ever happen !

SEAR1	LR	R4,R3			: Value is 24 - 29
	SHI	R4,$A24			: Now, 0 - 5
	LR	R5,R4
	LB	R1,PGRTAB+BPOS,RGRP,R4	: Get last bit pos examined
	SLLS	R4,5			: 0 - 160 - offset down cats
	LA	R6,PGRTAB+CAT1,RGRP,R4	: Addr of st of target cat
	LHI	R0,$A256		: count to scan once through

SEAR2	SIS	R1,1			: point to next to scan
	JGEFS	SEAR3			: still ok,

	LHI	R1,$A255			: else reload offset

SEAR3	SIS	R0,1			: Have we done once round
	JLFS	CLRCAT			: yes, nothing set

	TBT	R1,0,R6,		: is it set
	JEBS	SEAR2			: No, so keep scanning

	J	GOTBIT			: Found a bit set for this cat!

CLRCAT	STB	R1,PGRTAB+BPOS,RGRP,R5	: keep current place
	ST	R2,WDTEMP,,		: weve got to
	RBT	R3,WDTEMP,,		: Get rid of one weve seen,

	AIS	R3,1			: move pointer,
	L	R2,WDTEMP,,
	JFFO	R2,SEARX		: and search for next
	J	TSPOLL			: Nothing more to search for

SEARX	J	SEAR1



:
:	Here, weve got a Traffic status poll, always
:	reply with a status Ack.

TSPOLL	LIS	R0,LSEQR		: See if poll in sequence
	TBT	R0,PGRTAB+LLSTAT,RGRP,
	JN	TSP01			: No, so send GCS status ack

	JAL	R5,AKTEXT		: Else, acknowledge last tx
	LIS	R0,TOGGLE
	CBT	R0,PGRTAB+GRPFLG,RGRP,	: Invert toggle bit

TSP01	LHI	R0,0			: Set HL status null - 6.4.2
	STH	R0,PGRTAB+HLSTAT,RGRP,
	LIS	R0,LGCSPR
	RBT	R0,PGRTAB+LLSTAT,RGRP,	: LL bit 3 = 0 - 6.4.2
	LDREPLY				: plant sequence for tx
	J	ENDAK


:
:	Here, weve found a bit set for category polled

GOTBIT	STH	R5,PGRTAB+LSTCAT,RGRP,	: keep current cat 
	STB	R1,PGRTAB+BPOS,RGRP,R5	: keep current place in cat
	LHI	R0,SUBLEN
	MHR	R1,R0			: point to the sub involved
	LR	RSUB,R1

GOTB10	LR	R5,R5			: Offset in Cats - if 0, cat1
	JE	FROMC1			: Deal with cat1 chain


:	Here, we must examine the normal chain for cat n

FROMCN	PKCMD(TXN,RSUB)			: See if anything there
	
	JE	WTDATA			: No, so tell host to wait 

:	Else must be data from b.g. on normal category chain

	ADVCMD(TXN,RSUB,RGRP)		: Release cmd but not buffers
	J	FROMCO

:
:	Here, we must examine interrupt Alp chain set up
:	for data on Cat1

FROMC1	PKCMD(TXI,RSUB)			: Anything there ?
	JE	WTDATA			: no, so tell host to wait

:	Else must be data from b.g. on int category chain

	ADVCMD(TXI,RSUB,RGRP)		: Release cmd but not buffers
	JFS	FROMCO
	

:	Here, if we have no more frags, we may be able to clear the cat
:	bit. We can do this if this is also the last Alp fragment.
:	We can tell whether this is the last fragment by looking at the
:	first byte in the buffer to be sent. We also set or clear the
:	flag IALPST at this time, but before we do so, we see what it
:	was set to before. If it was 0  before, and will now also be
:	0, then we must have a fresh ALP about to be sent, so we must
:	look at its prefix in order to see if it is a supervisory status
:	message. If so, we want to update our AL status byte. Note
:	that we must do this even if we dont clear our cat bit.

FROMCO	LHI	RBX,-BBFLSZ+1		: set up buffer index
	JAL	R4,GETBC		: get flag byte at start
	LR	R7,R0			: keep it to set w bit later
	JE	MIDALP			: go off to set alp started bit

:	Else reset bit. This means that we have an end alp fragment, or
:	the first and only alp fragment. Before resetting it, we look to
:	see if it was set before. If so, then this must be the first and
:	only  fragment.

LASTALP	LIS	R0,IALPST
	TBT	R0,PGRTAB+GRPFLG,RGRP,	: was it set before
	JN	LAST01			: yes, so this is last in alp

:	Else, this must be first and only fragment, so it could be a
:	supervisory status report.

	AIS	RBX,3			: point to ALP prefix
	JAL	R4,GETBC		: get it
	LR	R1,R0
	LB	R0,REVTAB,R1		: reverse it to normality	

	CHI	R0,0A1			: Is it a super status report
	JN	NSUPER			: no, so dont do anything

:	Else, its a supervisory status report, see if its from GSS

	LHL	R0,SUBTAB+SUBADR,RSUB,
	CLHI	R0,020			: sub address 20 is the GSS
	JN	NGSS			: no, its a normal device


:	else its a supervisory status report from the GSS. This can
:	only have been generated internally by the B.G. in order to
:	clear a GCS bna condition due to the release of buffers.

	LIS	R0,GBSENT
	RBT	R0,PGRTAB+GRPFLG,RGRP,	: clear evidence of the BNA
	LIS	R0,GBCLR
	RBT	R0,PGRTAB+GRPFLG,RGRP,
	LIS	R0,GBNGCS
	RBT	R0,PGRTAB+GCSTAT,RGRP,
	JAL	R4,GETBC		: get the new AL status
	LB	R1,R0
	LB	R0,REVTAB,R1		: reverse it to normality
	J	NEWAL		

:	Here, its a supervisory status report from a normal device

NGSS	JAL	R4,GETBC		: get the new ALstatus
	LR	R1,R0
	LB	R0,REVTAB,R1		: reverse it to normality

:	See if BNA is now clear - generated internally

	CHI	R0,080
	JE	CLRBNA			: yes, go to deal with it

	TI	R0,01			: else only interested in OP/INOP
	JN	DNOWIN			: dev now inoperable

:	Else, its gone operable, so clear our inop status, but we leave
:	out the AL acknowledge bit, as we can only acknowledge at group
:	level.

	LHL	R0,SUBTAB+ALSTAT,RSUB,
	NHI	R0,0FFFE		: get rid of inop bit
	J	NEWAL

:	Here, we clear BNA status

CLRBNA	LH	R0,SUBTAB+SUBABS,RSUB,
	RBT	R0,BNASENT		: clear evidence of bna
	RBT	R0,BNACLR

	LHI	R0,080			: restore normal AL status
	JFS	NEWAL


:	Here, its gone inop, so set bit in our AL status, and ensure
:	that we will respond at AL, in case we are selected in future.
 
DNOWIN	LHI	R0,AKINOP		: signal weve sent dev inop ssr
	SBT	R0,SUBTAB+SUBFLG,RSUB,

	LH	R0,SUBTAB+SUBABS,RSUB,	: clear bna flags
	RBT	R0,BNASENT
	RBT	R0,BNACLR

	LHI	R0,IZALST		: set dev inoperable, and at AL

NEWAL	STH	R0,SUBTAB+ALSTAT,RSUB,
	SIS	RBX,1			: now tidy our buffer pointer
	
NSUPER	SIS	RBX,3			: point back to count
	JFS	GSIZE1			: go off to get it


:	Here, we set the bit to say we have started an alp which is
:	multi-fragmented.

MIDALP	LIS	R0,IALPST
	SBT	R0,PGRTAB+GRPFLG,RGRP,
	JFS	GSIZE			: go on to extract size etc

:	Here, we have an end-alp fragment, since last value was 1, and
:	now we set it to 0 to say we have ended a fragment.

LAST01	LIS	R0,IALPST
	RBT	R0,PGRTAB+GRPFLG,RGRP,

GSIZE	AIS	RBX,1			: point to the count bytes

GSIZE1	JAL	R4,GETBC		: Get first byte of count
	LBR	R1,R0			: and shift it up 8 bits
	EXBR	R1,R1
	JAL	R4,GETBC		: Get next byte of count
	AR	R1,R0

	STH	R1,PGRTAB+LSTSIZ,RGRP,	: keep size for later

	LHI	R4,SOH			: Commence header
	LHI	RBX,-BBFLSZ+1		: point to start of the message
	JAL	R5,LDHEAD		: Plant the character

	LIS	R0,0			: Reset our partial BCC
	STB	R0,CALBCC,RL,

	LB	R4,PGRTAB+GRPADR,RGRP,	: Get group address
	LIS	R0,TOGGLE		: and see if toggle set
	TBT	R0,PGRTAB+GRPFLG,RGRP,
	JE	TEX01			: No, so X bit is 0

	OI	R4,XBIT			: else set x bit in grp byte

TEX01	PUSH(RBA)
	PUSH(RBX)
	LR	R7,R7			: look at flag byte
	JE	TEX03			: to see if we need to set W bit

	OI	R4,WBIT			: yes

:	Now, we know w=1, so this is last or only fragment. If it is
:	ALso the only one weve got on the chain, then we can clear the
:	cat bit which brought us here in the first place.

	LHL	R1,PGRTAB+LSTCAT,RGRP,	: determine which chain we check
	JE	CLRC1			: its for cat1

:	else, its normal chain for cat n

CLRCN	PKCMD(TXN,RSUB)			: see if any more on chain
	JN	TEX03			: yes, so cant clear bit yet

	CBCLR				: else clear the cat bit

:	Now we must look again, as it could be that the B.G. may have
:	set the bit while we were clearing it. If there is something 
:	on the q, we must set the bit again.

	PKCMD(TXN,RSUB)
	JE	TEX03			: still nothing there, 

	CBSET				: else set bit
	J	TEX03

:	Now clear bit for int category

CLRC1	PKCMD(TXI,RSUB)			: see if any more on int chain
	JN	TEX03			: yes, so cant clear bit yet

	CBCLR				: else clear cat bit

:	Now check to see if b.g. has just put more onto q

	PKCMD(TXI,RSUB)
	JE	TEX03

	CBSET				: set bit again

:	Now we continue by planting the header at the start of this
:	fragment.

TEX03	POP(RBX)
	POP(RBA)

	JAL	R5,LDHEAD		: Plant this Grp for Tx

	LB	R4,SUBTAB+SUBADR,RSUB,	: Get the sub address
	JAL	R5,LDHEAD		: and plant it

	JAL	R5,GETFLOW		: Get Flow control
	LR	R4,R1			: 
	JAL	R5,LDHEAD		: plant flow control

	LHL	R1,PGRTAB+LSTSIZ,RGRP,	: r1 holds size of transfer
	AIS	R1,4
	JAL	R5,COMBCC		: now update Real BCC in text
	
	LIS	R0,TOGGLE		: now we can update toggle
	CBT	R0,PGRTAB+GRPFLG,RGRP,

	LR	R2,R1			: Xmt needs size in R2

SENDIT	LHI	R1,XHDATA		: Set Xmt code for text
	LHI	R4,BSCRBC		: and set rcv buffer count

	J	XMTRCV			: send this text, and RCV


: ----------------------------------------------------------
: RSELEC - Received Select in RVIDLE
:		Note: will have buffers if not a Grp Reset !
: ----------------------------------------------------------

RSELEC
	JAL	R5,INREP		: Initialise error flags
	LB	R1,RCVSUB,RL		: first see if its for GSS
	CHI	R1,GSSADD		: if so, it could be Grp Reset
	JE	SELGSS			: Go off to deal with GSS select
:	
:	Now if LLHR set, just send nak as in 5.5.7 p 36

	LIS	R0,LLHR
	TBT	R0,PGRTAB+LLSTAT,RGRP,
	JN	SNDNAK			: Go off to send nak

:
:	Else see if in sequence, and if sub is configured

	JAL	R5,INSEQ
	VALSUB				: See if sub present
	JL	SDNPRE			: Send dev not present

:	Now see if device is operable. If CMT has not established a
:	circuit to this device yet, it will still be inop. If inop,
:	we must reject with nak, and set bit 5 in LL status as
:	described in 5.6.1.5 para b and at 6.4.3 para c.

	LHL	R0,SUBTAB+ALSTAT,RSUB,	: get the current AL status
	TI	R0,01			: see if inop
	JE	RSELE2			: no, so carry on checking

:	Following code included 19/4/88

	GETDAT				: Extract ALP Prefix to see if data
	AIS	RBX,1
	JAL	R4,GETBC
	CHI	R0,040
	JL	RSELE2			: If command, ack it

:	Now we must give inop status to host in our AL status, but we 
:	must also set the bit to say AL status is present. We also
:	set HL failure since the text never made it to the ALS - 11 Feb 88

	LIS	R0,AHERE
	SBT	R0,SUBTAB+ALSTAT,RSUB,	: and AL stat present(6.4.3d)

	LH	R4,SUBTAB+ALSTAT,RSUB,	: Get it
	STH	R4,PGRTAB+HLSTAT,RGRP,	: and use for HL stat

	LIS	R0,LHFAIL
	SBT	R0,PGRTAB+LLSTAT,RGRP,	: Also set HL.Failure in llstat
	J	SNDNAK			: End by planting NAK

:	Else carry on by seeing if it was in sequence, etc

RSELE2	LIS	R0,LSEQR		: See if we have a Seq error
	TBT	R0,PGRTAB+LLSTAT,RGRP,
	JE	SELOK			: No, so select is ok so far

:
:	We must assume that we have received a repeat select because
:	the host did not see our last (ack) response. We can now 
:	discard this Select, and simply reply ACK, with Seq error.
:	For more information, see 5.6.1.3

	LIS	R0,AHERE		: Dont give AL ack though !
	RBT	R0,SUBTAB+ALSTAT,RSUB,
	J	SDISCD			: Discard buffers and send Ack


:
:	Here, we deal with a Select for GSS, it may be out-of-sequence
:	if it holds a Group Reset command (these are not held in rcv
:	buffers). The only other command which is possible is the
:	Assign Categories command, the paramters for this command
:	are held in rcv buffers as for a normal select.

SELGSS
	VALSUB				: Set up sub pointer
	LB	R0,PGRTAB+GCOMND,RGRP,	: Get command read
	CHI	R0,GRES1
	JE	SGRES1			: Deal with Grp Reset 1

	CHI	R0,GRES2
	JE	SGRES2			: G. R. 2

	CHI	R0,GRES3
	JE	SGRES3			: G. R. 3

:
:	Its not a Grp Reset, so we must check if LLHR set. If
:	this is so, then we can keep sending Nak.

	LHI	R1,LLHR			: Is LHR set,
	TBT	R1,PGRTAB+LLSTAT,RGRP,
	JN	SNDNAK			: If so, then send Nak

:
:	LLHR not set, we may look at what weve got

	CHI	R0,ASTCAT		: Is it Assign Cats
	JE	ASCATS			: Yes, so go off to deal with it

:
:	Else, we must discard the buffer(s) used, and respond
:	with an Ack.


SDISCD	LH	R4,SUBTAB+ALSTAT,RSUB,	: Get AL status for this sub
	STH	R4,PGRTAB+HLSTAT,RGRP,	: and make this the HL stat

SDISC1	LHL	R3,RBBCHN,RL2,		: Get chain start
	JE	SNDACK			: nothing there, just send ack

	JAL	R5,PBBC,,		: else return buffers to pool
	J	SNDACK			: and send ack

:
:	Here, we must assign categories.

ASCATS
	JAL	R5,INSEQ		: Set Seq err bit if not in seq

	LIS	R0,LLHR
	TBT	R0,PGRTAB+LLSTAT,RGRP,	: See if LLHR still set
	JN	SNDNAK			: If so, we must send nak

	LIS	R0,LSEQR
	TBT	R0,PGRTAB+LLSTAT,RGRP,	: See if this was in Sequence
	JN	SDISCD			: If not, send ack with seq err

:
:	Now, we can get on with assigning some cats to subs.

	GETDAT				: Get buffer pointers
	AIS	RBX,1

ASC01	JAL	R4,GETBC		: Loop, get a sub #
	CHI	R0,ETX			: If Etx, weve reached end.
	JE	SDISCD

	LR	R7,R0			: Keep sub # till later
	JAL	R4,GETBC		: and get a cat # for the sub
	CHI	R0,ETX			: If ETX, weve reached end.
	JE	SDISCD

:
:	now see if sub # is valid

	SHI	R7,BSUBAD
	JL	ASC01			: No good, get another pair

	CHI	R7,MAXSUB
	JGE	ASC01			: No good, get another pair

	SLLS	R7,1			: Make it into h/w offset
	SULODS	R4,PGRTAB+SUBPTR,RGRP,R7	: Get subtab address
	JL	ASC01			: Not configured, get another

	NHI	R0,03E			: get cat bit we are to set
	LIS	R5,0
	JFFOH	R0,ASC02		: use first bit seen in cat byte
	J	ASC03			: if = 0

:
:	Now we do some arithmetic fiddling, since the cat number weve
:	got is a bit setting, and we want to convert this to a number
:	so that we can use it to offset down the cat qs held for
:	this group.

ASC02	LHI	R5,$A16		
	SR	R5,R1			: R5 now holds cat # 1 - 5

:	now, see if we used to have a valid cat.

	LB	R0,SUBTAB+SUBCAT,R4,	: Get old setting
	JN	ASC04			: Already set, so just update

:	else, it was cat 0, and now is cat n. So set bit for new cat

	STB	R5,SUBTAB+SUBCAT,R4,	: First set new cat #
	
ASNEW	PUSH(R2)
	PUSH(R3)
	PKCMD(TXN,R4)			: see if anything queued to go
	JE	ASSE1			: no, so see if anything on int

:	else, we now set bit in B.A. for this new cat

ASSET	SIS	R5,1
	SLLS	R5,5			: point to cat we want
	PGLOAD	R6,SUBTAB+SUBGRP,R4,	: and group for sub
	LHL	R0,SUBTAB+SUBABS,R4,	: get abs sub # for this sub
	SBT	R0,PGRTAB+CAT1,R6,R5	: and set bit in B.A.

:	Now see if we also need to enable data from cat1 as well, 
:	since this may have been disabled due to the previous cat 0
:	setting.

ASSE1	PKCMD(TXI,R4)
	JE	ASSE2			: nothing there

:	else, weve got something on cat1 too.

	LIS	R5,0
	PGLOAD	R6,SUBTAB+SUBGRP,R4,	: get group for sub
	LHL	R0,SUBTAB+SUBABS,R4,	: get abs sub # for this sub
	SBT	R0,PGRTAB+CAT1,R6,R5	: and set bit in B.A.


ASSE2	POP(R3)
	POP(R2)
	J	ASC01			: keep assigning cats


:	Here, weve been set to cat 0, so see if we were before

ASC03	LB	R0,SUBTAB+SUBCAT,R4,	: Get old setting
	JE	ASC01			: as before, so get next one

:	else, it was cat n, and now cat 0, so clear B.A. for old cat

	CT0CLR
	J	ASC01			: keep assigning cats


ASC04	STB	R5,SUBTAB+SUBCAT,R4,	: Set the cat # in the sub
	LR	R7,R0			: use old cat #
	SIS	R7,1
	SLLS	R7,5			: point to cat we want
	PGLOAD	R6,SUBTAB+SUBGRP,R4,	: get group for sub
	LHL	R0,SUBTAB+SUBABS,R4,	: get abs sub # for this sub
	RBT	R0,PGRTAB+CAT1,R6,R7	: and clear bit in B.A. for cat
	J	ASNEW			: now set bit for new cat


:
:	Here, deal with a Grp Reset 1
:	-----------------------------

SGRES1
	LIS	R0,TOGGLE		: First, reset held toggle
	RBT	R0,PGRTAB+GRPFLG,RGRP,

	LIS	R0,LLHRST
	TBT	R0,PGRTAB+GRPFLG,RGRP,	: See if LLHR was sent to host
	JE	GNYET			: Not yet, so cant reset it

	RBT	R0,PGRTAB+GRPFLG,RGRP,	: Else, reset both flags
	LIS	R0,LLHR
	RBT	R0,PGRTAB+LLSTAT,RGRP,

:
:	Now tidy text transmissions as in 6.3.6
:	first, we clear current inbound and outbound alps

GNYET	PUSH(RSUB)			: keep this sub - gss
	JAL	R5,AKTEXT		: discard last frag we sent

	LHL	RSUB,PGRTAB+LSTSUB,RGRP,
	LHL	R0,PGRTAB+LSTCAT,RGRP,	: get details of last alp
	JE	GNY50			: cat 0, so must be complete

:	else it came from cat n, so there may be more frags of this alp
:	in the q. If so, we discard them, and may reset B.A. bit too.

	LIS	R0,IALPST
	RBT	R0,PGRTAB+GRPFLG,RGRP,
	JE	GNY50			: reached end of alp

:	else mid alp, discard rest of it

GNY05	PKCMD(TXN,RSUB)
	JE	GNY20			: reached end

:	now remove cmd from q, reduce count, and release buffers

	ADVCMD(TXN,RSUB,RGRP)

	DSCFRG				: discards fragment

	LR	R0,R0			: flag tells us if its last frag
	JE	GNY05			: keep discarding until it is

:	Now weve discarded this alp, see if we can clear cat bit

GNY20	LHL	R1,PGRTAB+LSTCAT,RGRP,
	JE	GNY30			: from cat 1

:	else from cat n

	PKCMD(TXN,RSUB)
	JN	GNY50			: cant clear bit, more on q
	J	GNY40			: q is empty, so clear bit

GNY30	PKCMD(TXI,RSUB)			: see if anything left for int
	JN	GNY50			: cant clear it, more to come

GNY40	CBCLR				: else clear B.A. bit for this cat

:	Also tidy text transmissions in outbound direction (to us)
:	We can free off all entries on C.List which have not been
:	freed yet - B.G. will not have seen them.
:	If by freeing any of the buffers, we can reset BNA for a device,
:	then we will.

GNY50	LIS	R0,OALPST
	RBT	R0,PGRTAB+GRPFLG,RGRP,	: do we have a partial alp o/b
	JE	GNY60			: no

:	else, outbound alp started, so send black ball msg to B.G.

	LIS	R0,GR3RES
	TBT	R0,PGRTAB+GRPFLG,RGRP,	: but if this is a gr3,
	JN	GNY60			: then black ball already sent

	LHL	RSUB,PGRTAB+LSTSEL,RGRP,	: last sub selected
	LHI	R2,BLKBAL
	PUTCMD(RCV,RSUB)
	RLCMD(RCV,RSUB,RGRP)

GNY60	LIS	R0,GR3RES
	RBT	R0,PGRTAB+GRPFLG,RGRP,	: clear bit now we dont need it

	POP(RSUB)			: get back gss address
	LH	R4,SUBTAB+ALSTAT,RSUB,	: Get AL status for this sub
	STH	R4,PGRTAB+HLSTAT,RGRP,	: and make this the HL stat
	J	SNDA01			: Finally, ack this select

:
:	Here, deal with a Grp Reset 2
:	-----------------------------

SGRES2	PUSH(RSUB)
	LHL	R4,PGRTAB+PGFSUB,RGRP,	: Get add of 1st sub in this grp
	LB	R1,PGRTAB+LPSUBN,RGRP,	: and get number of subs in grp
	LIS	R5,0

GR201	LB	R0,SUBTAB+SUBCAT,R4,	: get old sub #
	JE	GR202			: not set

	CT0CLR				: set to cat 0

	LIS	R0,GR3RES		: see if this is a gr 3 reset
	TBT	R0,PGRTAB+GRPFLG,RGRP,
	JE	GR202			: no, so do no more


:	else we now send a message to the B.G. so that it can send a
:	black ball for each connected subsidiary.

	LHI	R2,BLKBAL
	LR	RSUB,R4
	PUTCMD(RCV,RSUB)
	RLCMD(RCV,RSUB,RGRP)
	LR	R4,RSUB

	LIS	R0,GR3LOK		: also we mark sub by setting
	SBT	R0,SUBTAB+SUBFLG,RSUB,	: bit

GR202	AHI	R4,SUBLEN		: point to next sub in grp
	SIS	R1,1			: Reduce count of subs done
	JG	GR201			: Keep going until all done

	POP(RSUB)
	J	SGRES1			: continue by resetting bits,etc

:
:	Here, deal with a Grp Reset 3
:	-----------------------------

SGRES3
	LIS	R0,LLHRST		: Pretend that LLHR was sent,
	SBT	R0,PGRTAB+GRPFLG,RGRP,	: so that later, LLHR cleared

	LIS	R0,GR3RES		: set bit to indicate gr3
	SBT	R0,PGRTAB+GRPFLG,RGRP,	: for this group

	J	SGRES2			: continue by clearing, cats,etc




:
:	Here, we have a Select, in sequence and without error.
:	If the Select is for Subs 21 - 23, we will discard the Select,
:	and reply with Ack, since we are not interested.

SELOK	LB	R1,RCVSUB,RL
	CHI	R1,GSSADD+4
	JL	SDISCD			: discard the buffers received

:
:	Else, its a normal device, so put the data received on the
:	RCV queue for this sub, and send ACK with NO AL status - this
:	AL acknowledgement will arrive (hopefully) from CMT when IT
:	has seen this ALP.

SLNORM	GETDAT				: Get data chain and offset
	LHL	R2,ROBCNT,RL2		: Get byte count


:	Now see if we have already set bna - if so, we cannot
:	continue, but must instead just nak the block with bna set.

	LIS	R0,ABNA
	TBT	R0,SUBTAB+ALSTAT,RSUB,
	JN	BNAIT			: nak block, bna set for sub


:	Now we see if we have exceeded our outbound character limit.
:	If so, we NAK the block with BNA set - see 6.3.4.1.
:	This condition is released by the Background sending us a 
:	supervisory status report when it has released enough space
:	so that at least another complete fragment may be read in.

	LR	R0,R2
	AH	R0,SUBTAB+OBCOUNT,RSUB,	: Inc outbound char count

:	now before we test this against limit, see if the bna mechanism
:	has been enabled.

	LIS	R4,SBNA
	TBT	R4,PGRTAB+GRPFLG,RGRP,
	JE	SLNOTB			: not allowed to set bna for sub


	CLHI	R0,OBMAX		: else see if reached limit
	JG	BNAIT			: if so, send nak with bna

:	else, ok to go on as far as the sub is concerned, so now see if
:	we have exceeded the total for this group. We may have to
:	reject with GCS bna if so, provided that we are allowed to do so

SLNOTB	LR	R5,R0			: keep count for sub safe
	LIS	R0,GBSENT
	TBT	R0,PGRTAB+GRPFLG,RGRP,	: see if gcs bna already set
	JN	BNAGCS			: yes, go send it again

:	else see if weve exceeded group limit

	LR	R0,R2
	AH	R0,PGRTAB+GOBCT,RGRP,	: increase count for group
	LIS	R4,GBNA
	TBT	R4,PGRTAB+GRPFLG,RGRP,	: but see if we are allowed to
	JE	SLNOTG			: no, just update counts

	CLHI	R0,GOBMAX		: see if exceeded limit
	JG	BNAGCS			: yes, so go to it


:	here, we just update our counts, and send the data to B.G.

SLNOTG	STH	R0,PGRTAB+GOBCT,RGRP,	: update count for this group
	STH	R5,SUBTAB+OBCOUNT,RSUB,	: update count for sub
	PUTCMD(RCV,RSUB)		: Put command on list for B.G

	LIS	R2,OALPST
	LIS	R0,WTALPON		: Do we have to wait for whole
	JE	SLN05			: no, so always release fragment

	LB	R1,RCVGRP,RL		: get group byte we read
	NHI	R1,1			: get the w bit
	JE	SLN10			: 0 - alp incomplete

:	else, weve got the end of an alp, so we can let flag revert to 0
:	and release the fragments on this q.

SLN05	RLCMD(RCV,RSUB,RGRP)
	RBT	R2,PGRTAB+GRPFLG,RGRP,
	JFS	SLN20

SLN10	SBT	R2,PGRTAB+GRPFLG,RGRP,	: set bit to say alp incomplete

SLN20	STH	RSUB,PGRTAB+LSTSEL,RGRP,

	LHL	R0,SUBTAB+ALSTAT,RSUB,	: Now see if device is Inop
	TI	R0,01
	JEFS	SLN30			: No, so go on to give interim Acknowledge

:	This code was changed - 24/2/88

	LIS	R0,AHERE		: Inop, so we report this in ALS
	SBT	R0,SUBTAB+ALSTAT,RSUB,
	JFS	SLN40

SLN30	LIS	R0,AHERE		: Dont give AL ack yet
	RBT	R0,SUBTAB+ALSTAT,RSUB,

SLN40	LH	R0,SUBTAB+ALSTAT,RSUB,	: plant AL stat in HL stat
	STH	R0,PGRTAB+HLSTAT,RGRP,

		IF	RTMTRA
		: -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:
		L	R7,RTMTBL,RL2,RL2
		LHL	R5,RTMIND,RL,RL
		L	R4,SLOWC,,
		ST	R4,0,R5,R7
		STH	RSUB,4,R5,R7
		STH	R2,6,R5,R7
		STH	R3,8,R5,R7
		AHI	R5,10
		CLHI	R5,200
		JLEFS	.+4
		LIS	R5,0
		STH	R5,RTMIND,RL,RL
		EI
		: -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:



SNDACK	LIS	R0,LSEQR		: First see if seq err ocurred
	TBT	R0,PGRTAB+LLSTAT,RGRP,
	JN	SNDA01			: Its set, so dont toggle 

:
:	Now, before we toggle, we can also release the current alp
:	fragment which was last transmitted.

	JAL	R5,AKTEXT

	LIS	R0,TOGGLE		: Now, invert toggle bit
	CBT	R0,PGRTAB+GRPFLG,RGRP,	: 

SNDA01
	LDREPLY				: Plant the status bytes for Tx
	
ENDAK	LHI	R4,ACK			: Finally plant the Ack at end
	JAL	R5,PUTCLT

	LIS	R1,SAK			: TX Op code

GOSEND
:
:	If LLHR set, set a flag to say weve sent it
:
	LIS	R0,LLHR
	TBT	R0,PGRTAB+LLSTAT,RGRP,	
	JE	GOS1

	LIS	R0,LLHRST
	SBT	R0,PGRTAB+GRPFLG,RGRP,

GOS1	LHI	R4,BSCRBC		: SET RCV BUFFERLET LIMIT
	LB	R0,LINTAB+LNRSPN,RLNE,	: Reply time-out
	ST	R0,RCVTIM,RL2,RL2
	J	XMTRCV			: Send response and wait for reply

: -------------------------------------------------
: INREP - Loads the current group pointer, and
: clears error flags before constructing a reply
: -------------------------------------------------

INREP
	LDRGRP(RLNE)			: Set group pointer
	LHI	R0,IZGCST		: Set GCSSTAT to null
	STH	R0,PGRTAB+GCSTAT,RGRP,

	LH	R0,PGRTAB+LLSTAT,RGRP,	: and clear error flags
	NHI	R0,0FF-036		: - LDAVAL,LGCSPR,LHFAIL,LSEQR
	STH	R0,PGRTAB+LLSTAT,RGRP,
	JR	R5

: --------------------------------------------------
: INSEQ - Checks to see if this message was received
: in sequence. If not, the Seq err bit is set in 
: LLSTAT.
: --------------------------------------------------

INSEQ
	LB	R2,RCVGRP,RL		: Get group weve just read
	
	JAL	R4,CHTOG		: Check toggle 
	JE	ENSBNA			: Good toggle, go back

	LIS	R0,LSEQR		: Else, set seq. error in LLSTAT
	SBT	R0,PGRTAB+LLSTAT,RGRP,

ENSBNA	JR	R5



					
: ----------------------------------------------
: CHTOG	- Check toggle, but does not invert it.
:	  Entered with
:		R2 = Group # read.
:	  Exits with
:		 R0 = 0 if ok, otherwise -1.
: ----------------------------------------------

CHTOG
	LBR	R3,R2
	SRLS	R3,1			: Isolate X bit from Grp read
	NHI	R3,1

	LIS	R1,0			: Use R1 to hold indicator
	LIS	R0,TOGGLE
	TBT	R0,PGRTAB+GRPFLG,RGRP,
	JE	CHT01			: Old toggle not set

	LIS	R1,1			: It was, so set indicator

CHT01	XR	R1,R3			: Test - Res = 0 if same
	JN	BADTOG

	LIS	R0,0			: Set up return as ok
	JR	R4

BADTOG	LCS	R0,1			: Set up bad return
	JR	R4


: ----------------------------------------------
: GETFLOW - Constructs a flow control byte, and
:	sets the Data available bit in LLSTAT
:	if any of the cats has data.
: ----------------------------------------------

GETFLOW
	LIS	R6,0
	STH	R6,PGRTAB+FLOWCL,RGRP,	: First clear flow byte
	
	LIS	R6,0A			: Point to bit 5 for cat 6
	LHI	R7,0BC			: 8 wds in each cat, & 6 cats

GETF1	LIS	R4,7			: This is reset for each cat

GETF2	L	R1,PGRTAB+CAT1,RGRP,R7	: Look at bits in this cat
	JE	GETF3			: carry on if none set

	SBT	R6,PGRTAB+FLOWCL,RGRP,	: Else set bit for this cat

GETF3	SIS	R7,4			: Now move up 1 wd
	SIS	R4,1			: and see if we need to
	JGE	GETF2			: keep looking at this cat

	AIS	R6,1			: Point to next bit in flow byte
	CHI	R6,010			: see if reached last cat to try
	JL	GETF1			: no, look at wds in this cat

	LH	R1,PGRTAB+FLOWCL,RGRP,	: Now see if any were set
	JE	GFNOD			: No, so clear data available

	LIS	R6,LDAVAL		: else set data avail in LLSTAT
	SBT	R6,PGRTAB+LLSTAT,RGRP,
	J	GETDON

GFNOD	LIS	R6,LDAVAL		: Clear data avail bit in LLSTAT
	RBT	R6,PGRTAB+LLSTAT,RGRP,

GETDON	OI	R1,40			: This bit always set
	STH	R1,PGRTAB+FLOWCL,RGRP,
	JR	R5


: ----------------------------------------------
: AKTEXT - We have had an in sequence command,
:	so we can move on the current Tx 
:	pointers. 
: ----------------------------------------------

AKTEXT
	PUSH(RSUB)
	LHL	RBA,PGRTAB+LSTBUF,RGRP,	: Get last chain start
	JE	AKDON3

	LHL	R0,PGRTAB+LSTEND,RGRP,	: Get end of chain

RELALP	LHL	R1,BBUFER+BBFLSZ-2,RBA,	: point to next in chain 
	JAL	R4,PBB,,		: discard this buffer
	CR	RBA,R0			: see if this was last one
	JE	AKDONE			: yes, so finish off

	LR	RBA,R1			: else step on to next buffer
	JNBS	RELALP			: keep going while any there

AKDONE	LH	RSUB,PGRTAB+LSTSUB,RGRP,	: Get last sub

AKDON2	LHI	R0,AKINOP		: see if weve just sent dev inop
	RBT	R0,SUBTAB+SUBFLG,RSUB,
	JE	AKDOP2			: no, continue

:	Else, we must tell B.G. so that it can allow use of this sub
:	again.
:	REMOVED 21/4/88
:
:	LHL	R0,SUBTAB+SUBABS,RSUB,
:	SBT	R0,DUNAV		: B.G. can now allow cud for sub

AKDOP2	LHL	R0,SUBTAB+IBCOUNT,RSUB,	: and decrease inbound count 
	LHL	R1,PGRTAB+LSTSIZ,RGRP,	: by the amount weve released
	SR	R0,R1
	STH	R0,SUBTAB+IBCOUNT,RSUB,

	LHL	R1,SUBTAB+SUBABS,RSUB,	: now see if weve already asked
	TBT	R1,NBPCLR		: for B.P.  to isis to be clear
	JN	AKDON3			: yes, dont do it again

:	else, if count has droppped below limit, tell b.g. so it can
:	release b.p. to isis.

	CLHI	R0,IBMAX
	JG	AKDON3			: not enough released yet

	SBT	R1,NBPCLR		: else set bit so we do it once
	LHI	R2,NOWBPC		: message to b.g.
	PUTCMD(RCV,RSUB)
	RLCMD(RCV,RSUB,RGRP)

AKDON3	LIS	R0,0			: Clear evidence of chain
	STH	R0,PGRTAB+LSTBUF,RGRP,
	STH	R0,PGRTAB+LSTEND,RGRP,
	POP(RSUB)	
	JR	R5



: ---------------------------------------------------
: LDHEAD - Here, we plant a single character into the
:	text head. Because each text chain starts
:	with a fresh buffer, we know that we cannot
:	overflow into the next one, with the four
:	bytes which will be loaded using this r/t
:
:	Entered with R4 = the character to plant
:
: ---------------------------------------------------

LDHEAD
	LB	R0,CALBCC,RL,		: Get old BCC
	XR	R0,R4			: Update with the character
	STB	R0,CALBCC,RL,
	LB	R4,PARTAB,R4,		: invert and get parity
	AIS	RBX,1			: point to next place in header
	STB	R4,BBUFER+BBFLSZ-2,RBA,RBX
	JR	R5



: --------------------------------------------------
: COMBCC - Updates the Real BCC at the end of the 
:	text message with the partial BCC we have 
:	calculated for the header. In order to do
:	this, it must traverse the buffer chain.
:	Entered with registers as follows:
:	R1 - Size of text message (up to 257)
:	R2 - RBX, buffer index
:	R3 - RBA, Chain start
:	R5 - Link address
: --------------------------------------------------

COMBCC
	STH	RSUB,PGRTAB+LSTSUB,RGRP,	: keep record of sub
	LHI	RBX,-BBFLSZ+1		: Reset pointer to chain start
	LR	RCNTX,R1		: This is the size of fragment
	LR	RDAT,RBA		: and this is the first buffer
	LA	R4,BBUFER,,		: point to the buffer area

COMSKP	AR	RDAT,R4			: Make pointer absolute
	SHI	RCNTX,BBFLSZ-2		: have we reached last buffer
	JLE	CNTLST

	LHL	RDAT,BBFLSZ-2,RDAT	: else point to next in chain
	J	COMSKP			: keep going until we reach end

CNTLST	SIS	RCNTX,1			: point back to the last char
	LB	R4,BBFLSZ-2,RDAT,RCNTX	: which will be bcc for text
	LB	R0,CALBCC,RL		: Include our header bcc
	XR	R4,R0
	
	LB	R0,PARTAB,R4		: Make into a transmittable char
	STB	R0,BBFLSZ-2,RDAT,RCNTX	: and plant it at text end
	STH	RBA,PGRTAB+LSTBUF,RGRP,	: keep note of the chain start

	LA	R4,BBUFER,,
	SR	RDAT,R4			: make end relative
	STH	RDAT,PGRTAB+LSTEND,RGRP,	: and keep it
	JR	R5




	FO	MAIN
	FO	C03RCV
	FO	C03SRV
	FO	C03SXM
	FO	CMDLST
	FO	C03BLK
	FO	C03FEX
	EM



	SUBTTL	ICL C03 - Timeout Utility Routines

	RA	0
	MO	.,CTIMRT

	LO	MAIN
	LO	C03BLK
	LO	CMDLST
	

	GL	ERRCMD,SNDIIX,INIPLT,CMDCNT,HSTMSG,SNDINV

	LO	FRNTND
	GL	DUMDCB

RGRP	EQ	R10
RSUB	EQ	R11


	SEG 	A.CODE

:	INIPLT - Initialise timeout routine for inactivity
:	--------------------------------------------------

INIPLT	PUSH(R5)
	L	R7,FASTC,,		: GET CURRENT TIME
	LA	R0,CKPLT
	LI	R1,POLT3*RATE,R7		
	JAL	R5,TOPUT,,		: PUT ON TIMOUT LIST
	RETJ(R5)

: 	 CKPLT - Check for Idle Devices.  
:	 ------------------------------- 
:
:	This routine is normally run once every second.  It looks at all 
:	the configured poll groups, too see if any of them have become 
:	inactive.  This may have happened if there has been no poll or 
:	select to that group within the last second.  For such an idle 
:	group, we will send a message to the CMT for each of its 
:	associated devices.  If any of these has already been zapped
:	by the CMT or network, there may be a Device Inop message queued
:	to the F.G. We need to discard this message and set the AL
:	status for the device as INOP.

CKPLT
	AI	R1,POLT3*RATE		: Schedule again in POLT3 secs
	JAL	R5,TOPUT,,

	LHI	R9,NBILIN-1		: Get the line index
CKPL10	LHL	R1,LINPTR,R9,R9		: Get the LINTAB ptr 

	TBT	R1,DHNGBT		: see if hang timer enabled
	JE	CKPL80			: if not, dont examine this line

:	else, see if any activity on this line since last time

	LHL	R0,LINTAB+LBPOL1,R1,
	CLH	R0,LINTAB+LBPOL2,R1,
	JN	CKPL12			: yes, examine each group 

:	else same as last time so we drop DTR and raise it to enable 
:	a line reconnection.

	PUSH(R1)
	PUSH(R9)
	LIS	R0,1
	JAL	R5,C03DTR		: drop DTR for this line
	SVC	DISMISS,1		: then wait 1 sec

	LIS	R0,0
	JAL	R5,C03DTR		: and raise it again

	POP(R9)
	POP(R1)

	LIS	R0,0
	STH	R0,LINTAB+LBPOL1,R1,

CKPL12	STH	R0,LINTAB+LBPOL2,R1,	: update line count

	LB	R4,LINTAB+LNMGRP,R1,	: Get the number of P.Gs for Line
	PGLOAD	RGRP,LINTAB+LNFPGR,R1,	: Get the PGRTAB ptr for the first

CKPL15	LHL	R0,PGRTAB+NBPOL1,RGRP,	: Get the new activity count
	CLH	R0,PGRTAB+NBPOL2,RGRP,	: Is it the same as the previous ?
	JN	CKPL65			: No, so try the next P.G

:	We've found a poll group for which there has been no good
:	activity since the previous run so now set a flag to stop F.G.
:	from interfering, and check again.

	LIS	R0,GHANG
	SBT	R0,PGRTAB+GRPFLG,RGRP,	: Flag this group as hung
	JN	CKPL70			: already set, so look at next

	LHL	R0,PGRTAB+NBPOL1,RGRP,	: see if host has recommenced
	CLH	R0,PGRTAB+NBPOL2,RGRP,
	JN	CKPL65			: yes, reset bit and check next


:	else, we can now clear all cat bits for this group.

	LIS	R0,0
	LHI	R1,$A 188
	
CKPL18	ST	R0,PGRTAB+CAT1,RGRP,R1	: clear a word at a time
	SIS	R1,4
	JGEBS	CKPL18			: until all done

:	Now reset status bits for this group - 11 Feb 88

	LHI	R7,IZFLOW
	STH	R7,PGRTAB+FLOWCL,RGRP,
	LHI	R7,IZLLST
	STH	R7,PGRTAB+LLSTAT,RGRP,
	LHI	R7,IZGCST
	STH	R7,PGRTAB+GCSTAT,RGRP,

:	Now deal with each sub in this hung group

	LB	R7,PGRTAB+LPSUBN,RGRP,	: Get the # of SUBs for the P.G
	SULOAD	RSUB,PGRTAB+PGFSUB,RGRP,	: Get the SUBTAB ptr for 1st

CKPL20	PUSH(R7)			: keep no of subs safe
	LHL	RDCB,SUBTAB+SUBDCB,RSUB,	: Get the DCB address
	CH	RDCB,DUMDCB		: Is there a circuit ?
	JE	CKPL25			: No, not a connected sub

	LHL	R0,DPORT,RDCB,
	JE	CKPL25			: not connected


:	Else, send inv to clear to cmt

	PUSH(R4)
	LIS	R13,ZQUIET
	JAL	R5,SNDINV
	POP(R4)
	J	CKPL62			: now look at next sub


:	Now we clear both queues to the F.G.

CKPL25	PKCMD(TXI,RSUB)			: see if anything on int q
	JE	CKPL28			: no more, now deal with other

	PUSH(R4)
	ADVCMD(TXI,RSUB,RGRP)		: remove cmd
	DSCFRG				: discard buffers, dec count
	POP(R4)
	J	CKPL25			: until no more on q

CKPL28	RLCMD(TXN,RSUB,RGRP)
	PKCMD(TXN,RSUB)			: se if anything on q for cat n
	JE	CKPL29			: no more

	PUSH(R4)
	ADVCMD(TXN,RSUB,RGRP)		: remove cmd
	DSCFRG				: discard buffers, dec count
	POP(R4)
	J	CKPL28			: until no more on q


:	Now, we see if B.G. had started an alp fragment but had not yet
:	completed it and placed it on the q for cat n. If so, we must
:	release these buffers too.

CKPL29	LIS	R0,FRCOMP
	RBT	R0,DFLAGS,RDCB,		: see if partial alp 
	JE	CKPL60			: no, so look at next sub

:	Else we need to discard what has been accumulated

	LHL	RBA,FRAGST,RDCB,	: Get start of fragment
	PUSH(R4)
	JAL	R5,PBBC,,		: free off buffers
	POP(R4)

CKPL60	LHL	R0,SUBTAB+SUBABS,RSUB,	: Get abs sub no
	SBT	R0,DUNAV		: now clear 'unavailable' flag

CKPL62	AHI	RSUB,SUBLEN		: Advance the SUBTAB pointer
	POP(R7)				: regain no of subs to go
	SIS	R7,1			: Any more for this P.G ?
	JG	CKPL20			: Yes, go to the next one

	LIS	R0,0			: No, zero the activity counts
	STH	R0,PGRTAB+NBPOL1,RGRP,	: and go to the next poll group
	JFS	CKPL70


CKPL65	LIS	R1,GHANG
	RBT	R1,PGRTAB+GRPFLG,RGRP,	: This grp has had activity

CKPL70	STH	R0,PGRTAB+NBPOL2,RGRP,	: Make a new previous for next time
	AHI	RGRP,PGRLEN		: Advance the PGRTAB pointer
	SIS	R4,1			: Any more on this line ?
	JG	CKPL15			: Yes, go process it

CKPL80	SIS	R9,1			: No, Any more lines ?
	JGE	CKPL10			: Yes, go process it

	J	TORET,,


:	TKOVRF - LINK FROM ACTIV0 TO REPORT HOSTS DUE TO TAKEOVER
:	---------------------------------------------------------

	GL	TKOVRF


TKOVRF	PUSH(R5)
	JAL	R5,HSTMSG		: just report all our hosts again
	RETJ(R5)

	FO	FRNTND
 
	FO	MAIN
	FO	C03BLK
	FO	CMDLST
	EM
	SUBTTL ICL C03 B.G. Logic - Foreground/Background initialisation

	RA	0
	MO	.,MAIN

	LO	C03FEX
	LO	C03BLK
	LO	FRNTND

	GL	SIIX00,EMPTYI,EMPTYO,FSHIIX,CLRCIR,DUMDCB,INIDCB
	GL	GETBC,RZAPN,NZAP,SNDZAP,DSPQ0,IIXLST,IIXEND,HSTMSG

	SEG	A.DATA

	WS	0
RET5	WS	1
STACK	WS	$A60		:STACK FOR B.G.
FSTACK	WS	$A60		:STACK FOR F.G.

TRSTK1	WS	$A60		:TRACE STACKS
TRSTK2	WS	$A60

HSTREG	WS	10

	SEG	A.CODE

	IF	\IIXTRC
	ELSE
IIXTRC	EQ	0
	EI


:	 CONFIGURATION MACROS
:	 --------------------
:	 GENERATE AN IIX JUMP TABLE

GENIIX	MACRO	[
	HC	FSHIIX-RSEG	: 8080	SELECT DIALECT
	HC	FSHIIX-RSEG	: 8081	SELECTED DIALECT
	HC	FSHIIX-RSEG	: 8082	GATEWAY REACHED SMART HOST
	HC	FSHIIX-RSEG	: 8083	GATEWAY REACHED DUMB HOST
	HC	FSHIIX-RSEG	: 8084	LOGON STATUS
	HC	FSHIIX-RSEG	: 8085	RESYNCHRONIZE
	HC	FSHIIX-RSEG	: 8086	INTERFACE ID/VERSION
	HC	FSHIIX-RSEG	: 8087	REQ INTERFACE ID/VERSION

:	 TURKEY MESSAGES
:	 ---------------

	HC	FSHIIX-RSEG	: C087	CALLED ADDRESS
	HC	FSHIIX-RSEG	: C088	CALLING ADDRESS
	HC	FSHIIX-RSEG	: C089	CALL USER DATA
	HC	FSHIIX-RSEG	: C08A	INTERRUPT PKT
	HC	FSHIIX-RSEG	: C08B	INTERRUPT CONFIRMATION
	HC	FSHIIX-RSEG	: C08C	NETWORK UTILITY
	HC	FSHIIX-RSEG	: C08D	FACILITY
	HC	FSHIIX-RSEG	: C08E	UNUSED
	HC	FSHIIX-RSEG	: C08F	UNUSED
	HC	FSHIIX-RSEG	: C090	UNUSED
	HC	FSHIIX-RSEG	: C091	RESET CONFIRMATION
	HC	FSHIIX-RSEG	: C092	CALL ACCEPT
	HC	FSHIIX-RSEG	: C093	TURKEY LEVEL
	HC	DATIIX-RSEG	: C094	DATA
	HC	FSHIIX-RSEG	: C095	CLEAR INDICATION
	HC	FSHIIX-RSEG	: C096	RESET INDICATION
	HC	FSHIIX-RSEG	: C097	CLEAR INFO
	HC	FSHIIX-RSEG	: C098	ABNORMALITY REPORT

]

:	 MODIFY GLOBOL IIX ENTRIES
:	 -------------------------

GLOIIX	MACRO(TABNAM,MSGNUM,BRLABL) [
OLDORG	EQ	.
	ORG	TABNAM+(MSGNUM)*2
	HC	BRLABL-RSEG
	ORG	OLDORG
]

:	 MODIFY TURKEY ENTRY
:	 -------------------

TURIIX	MACRO(TABNAM,MSGNUM,BRLABL) [
	GLOIIX(TABNAM,MSGNUM+TURBAS-7,BRLABL)
]

:	 MODIFY DSP ENTRY
:	 ----------------

DSPIIX	MACRO(TABNAM,MSGNUM,BRLABL) [
	IF	\DSPI|MSGNUM|
	GLOIIX(TABNAM,DSPI|MSGNUM|,BRLABL)
	ELSE
	REMARK	%INVALID DSP MESSAGE
	EI
]


:	 ASCII MODE TABLE
:	 ----------------

:	 SEE *VIAC*
 
 
:	 DIALECT PRIORITY TABLE
:	 ----------------------
:	 (PRIORITIES MUST CORRESPOND TO APPROPRIATE ENTRIES IN DIATBL)

DIAPTY	BC	P.ASC,P.GAT,P.X25

:	 DATA TABLE FOR FINDING DSP MESSAGES
:	 -----------------------------------

DSPTYP	BC	01,10,11,12,13,14,15,16
	BC	20,21,22,24
DSPLNG	BC	.-DSPTYP
DSPETE	EQ	10			: FOR CMD CODE OFFSET
:

	SUBTTL	B.G LOGIC - IIX MESSAGE COMMON ROUTINES FOR UTST/UTSH

:	 SIIX00 - SIIX HANDLER ROUTINE (NATIVE MODE)
:	 -------------------------------------------

SIIX00
	PUSH(R5)
	LHI	R0,SIIX10-RSEG	: CHANGE ACTIVATION ROUTINE
	STH	R0,DISRA,RDCB,
	LHI	R0,ALPSIZ	: Reset partial fragment count
	STH	R0,DPFCNT,RDCB,
	LIS	R0,0
	STB	R0,DNCHAR,RDCB,	: Clear overshoot character
	RETJ(R5)

:	 SIIX10 - COLLECT IIX MSG TYPE
:	 -----------------------------

SIIX10	CHI	R0,80			: IS IT A GLOBOL?
	JEFS	SIIX20			: YES

	JALR	RSL,RSL			: GET SECOND IIX CHAR
	LIS	R7,(TURBAS-7)*2		: NO, GET TURKEY BASE
	JFS	SIIX30

SIIX20	JALR	RSL,RSL			: GET SECOND IIX CHAR
	LIS	R7,0

SIIX30	NHI	R0,7F			: GET MESSAGE TYPE
	AR	R0,R0			: MAKE HW INDEX
	AR	R7,R0			: ADD STARTING POINT
	AI	R7,IIXLST		: ADD BASE ADDRESS
	CI	R7,IIXEND		: Test for exceeding table
	JGE	FSHIIX			: If so, discard message !

	LHL	R5,0,R7
	IF	IIXTRC
	JAL	R4,IIXMON
	EI
	J	 RSEG,R5,		: GO DO IT (for Data, see below)

:	A new message must be dealt with. It will usually have come
:	from the IRING, via the code at IND, but internally generated
:	messages may also call this code by the same mechanism. In
:	either case the format of the messages will be the same -
:	the first byte tells us if its to go on Cat1 (int category),
:	or the normal category for this subsidiary. There are two chains
:	of buffers per DCB to handle both cases.

DATIIX	JALR	RSL,RSL			: GET DATA FLAG BYTE
	LIS	R5,SRCFLG		: and use to set/clear flag
	CLHI	R0,01
	JN	DATI10			: jump if its for normal cat

	LHL	RBA,IDIRBA,RDCB,	: Its for int cat, use 
	LH	RBX,IDIRBX,RDCB,	: other chain
	RBT	R5,DFLAGS,RDCB,		: Clear bit as we deal with cat1

	LIS	R0,WALACK		: and now reset AL wait flag
	RBT	R0,DFLAGS,RDCB,
	JFS	DATI20

DATI10	SBT	R5,DFLAGS,RDCB,		: Normal cat, so set bit
	LIS	R0,WALACK		: and see if we wait
	TBT	R0,DFLAGS,RDCB,		: for AL ack. if so, we
	JN	FSHIIX			: can discard data until then

DATI20	JALR	RSL,RSL		 	: GET FIRST BYTE OF CNT
	JALR	RSL,RSL		 	: GET SECOND BYTE

	LHI	R5,DSPQ0-RSEG		: GET BRANCH ADDRESS FOR TRACING
	IF	IIXTRC
	JAL	R4,IIXMON
	EI
	J	 RSEG,R5,

:	 GLOREQ - (IIX CODE 8087) REQUEST INTERFACE ID/VERSION
:	 -----------------------------------------------------
:	 SEND AN INTERFACE ID/VERSION (86) MESSAGE INDICATING
:	 THE HID AND VERSION/REVISION LEVEL.

GLOREQ	LA	R6,M.ID,,
	JAL	R5,SNDIIX		 : SEND ID/VERSION MSG
	J	 FSHIIX

:	 FSHIIX - ROUTINE TO FLUSH ALL MESSAGES
:	 --------------------------------------

STEXT
FSHIIX
	LR	R0,RRC			: COPY COUNT
	SIS	R0,1			: DECREMENT FOR BYTE ALREADY GOTTEN
	JLEFS	FSH10			: IF NONE LEFT, JUMP
	JAL	R4,FLUSH,,		: TRASH THE DATA
	LIS	RRC,0			: SET COUNT TO ZERO
FSH10	JALR	RSL,RSL	 		: LET IND EXIT
	J	FSHIIX			: DO IT AGAIN
 

EMPTYI	JR	R4			: DUMMY EMPTY INPUT ROUTINE FOR LIB
 
EMPTYO	JR	R4			: DUMMY EMPTY OUTPUT RTE.

	IF	IIXTRC

: TRACE IIX EVENTS

IIXMON	LHL	R6,DPORT,RDCB,		: GET PORT #
	LB	R7,IIXTRC,R6		: GET TRACE TABLE INDEX
	AIS	R7,2			: ADVANCE INDEX
	LBR	R7,R7
	STB	R7,IIXTRX,R6,
	SLLS	R6,8			: MULTIPLY BY 256
	STH	R5,IIXTTB,R6,R7 	: SAVE BRANCH ADDRESS
	JR	R4			: EXIT

	SEG	A.DATA

IIXTRX	BS	MAXPRT
IIXTTB	HS	MAXPRT*80
	EI

	SEG	A.CODE
 
	SUBTTL	B.G LOGIC - INITIALISE FOREGROUND PROCESSES

:	 IZFG - SHUT OFF AND INIT FOREGROUND PROCESSES
:	 ---------------------------------------------
:	 LINK ON R5

IZFG	ST	R5,RET5
	IF	NBILIN-8
	LHI	RL2,(NBILIN-1)*2
	ELSE
	LIS	RL2,(NBILIN-1)*2
	EI

	IF	NBILIN-10
	LHI	RL,(NBILIN-1)		: INIT LINE INDEX
	ELSE
	LIS	RL,(NBILIN-1)
	EI

IZFG1	LR	R1,RL2
	SRHLS	R1,1
	JAL	R5,C03EXI,,		: INIT F/G EXEC & ?

	LO	C03SRV
	LCS	R0,1			: INITIAL RCV,XMT
	JAL	R5,C03SRV,,
	FO	C03SRV

	LO	C03SXM
	LCS	R0,1			: INITIAL XMT
	JAL	R5,C03SXM,,
	FO	C03SXM

	SVC	DISMISS,2		: DISMISS FOR 2 SEC. WAIT FOR COMPLETE
	LO	C03DTR
	LCS	R0,1			: INITIAL DTR/DSR
	JAL	R5,C03DTR,,
	FO	C03DTR

	LO	C03DTR
	LIS	R0,1			: Drop DTR first
	JAL	R5,C03DTR,,
	SVC	DISMISS,1		: then wait 1 sec

	LIS	R0,0			: Now raise it
	JAL	R5,C03DTR,,
	FO	C03DTR

	LO	C03PTP
	LA	R0,LNPOLL,,
	ST	R0,PROADR,,		: addr of LNPOLL for protocol driver
	LCS	R0,1			: INITIAL PROTOCOL
	JAL	R5,C03PTP,,
	FO	C03PTP

	IF	NBILIN-1
	SIS	RL,1			: GOTO NEXT LINE
	SIS	RL2,2			: DO ALL LINES
	JGE	IZFG1
	EI
	
	JAL	R5,IZPGRP		: Initialise poll groups

	JAL	R5,IZSUB		: INITIALIZE SUBTABS
	
	L	R5,RET5
	JR	R5



:	 IZSUB - INITIALISE SUB CONTROL TABLES
:	 -------------------------------------

IZSUB
	LIS	RSUB,0
	LHI	R13,NSUBS		: TOTAL # OF SUBS		 

IZSUB1	LHL	R1,SUBTAB+SUBABS,RSUB,	: GET ABSOLUTE SUB # FOR INTERFACE
	PGLOAD	RGRP,SUBTAB+SUBGRP,RSUB,: Get the PGRTAB addr for this

	LB	R2,SUBTAB+SUBADR,RSUB,
	CLHI	R2,023			: devs 20 - 23 are different
	JLE	IZSUB2

	SBT	R1,DUNAV		: Set device available
	LHI	R2,IZALST		: and set up AL status
	JFS	IZSUB3

IZSUB2	RBT	R1,DUNAV		: Prevent access to subs 20 - 23
	LHI	R2,IZSPEC		: AL status different for these

IZSUB3	STH	R2,SUBTAB+ALSTAT,RSUB,	: plant initial AL status

	LIS	R2,0			: also clear other locations
	STH	R2,SUBTAB+SUBFLG,RSUB,
	STB	R2,SUBTAB+SUBCAT,RSUB,
	STH	R2,SUBTAB+OBCOUNT,RSUB,
	STH	R2,SUBTAB+IBCOUNT,RSUB,
	STH	R2,SUBTAB+LASTACT,RSUB,

	LB	R3,SUBTAB+SUBADR,RSUB,
	CLHI	R3,020
	JE	IZSUB4			: Gss, already has a dcb !

	LHL	R3,DUMDCB
	STH	R3,SUBTAB+SUBDCB,RSUB,	: Set up dummy DCB addr in SUBTAB

	LO	CMDLST
IZSUB4	IZCL(RCV,RSUB,RGRP)		: Init RCV queue
	IZCL(TXN,RSUB,RGRP)		: Init normal TX queue
	IZCL(TXI,RSUB,RGRP)		: Init int TX queue
	FO	CMDLST

	SIS	R13,1
	JER	R5
	AHI	RSUB,SUBLEN		: MOVE TO NEXT SUBTAB
	J	IZSUB1

:	Initialise poll group tables
:	----------------------------

IZPGRP	LIS	R0,0
	LIS	R6,0
	LHI	R13,NPGRP		: get no of poll groups
	LHL	RDCB,DUMDCB		: use last dcbs for GSSs


IZPGR1	AHI	RDCB,DCBLEN		: point to next dcb to use
	LHI	R1,$A 188		: clear 6 cats, 8 wds each - 48

IZPGR2	ST	R0,PGRTAB+CAT1,R6,R1
	SIS	R1,4
	JGEBS	IZPGR2			: keep going until done for grp

	LHI	R2,IZFLOW		: initialise locations for grp
	STH	R2,PGRTAB+FLOWCL,R6,

	LHI	R2,IZLLST
	STH	R2,PGRTAB+LLSTAT,R6,

	LHI	R2,IZGCST
	STH	R2,PGRTAB+GCSTAT,R6,

	STH	R0,PGRTAB+GRPFLG,R6,
	STH	R0,PGRTAB+GCOMND,R6,
	STH	R0,PGRTAB+LSTBUF,R6,
	STH	R0,PGRTAB+LSTSIZ,R6,
	STH	R0,PGRTAB+LSTEND,R6,
	STH	R0,PGRTAB+LSTCAT,R6,
	STH	R0,PGRTAB+GOBCT,R6,
	STH	R0,PGRTAB+GCIRCS,R6,

	LIS	R0,GCSBON		: Has GCS bna been enabled ?
	JE	IZPGRD			: no, so dont set flag for group

	LIS	R0,GBNA			: else set flag for group 
	SBT	R0,PGRTAB+GRPFLG,R6,

IZPGRD	LIS	R0,GCSDON		: Has GCS deafness been enabled ?
	JE	IZPGR4			: no, so dont set flag for group

	LIS	R0,GDEF			: else set flag for group 
	SBT	R0,PGRTAB+GRPFLG,R6,

IZPGR4	LIS	R0,SUBBON		: Has subs bna been enabled ?
	JE	IZPGR6			: no, so dont set flag

	LIS	R0,SBNA
	SBT	R0,PGRTAB+GRPFLG,R6,


IZPGR6	LHL	R2,PGRTAB+SUBPTR,R6,	: point to first dev on grp
	STH	RDCB,SUBTAB+SUBDCB,R2,	: and give it (GSS) a dcb
	STH	R2,DCBSUB,RDCB,		: link dcb to this sub
	STH	R6,DCBGRP,RDCB,		: and to the group
	PUSH(R1)
	PUSH(R5)
	PUSH(R6)
	LIS	R1,0
	JAL	R5,INIDCB		: and set up this dcb
	POP(R6)
	POP(R5)
	POP(R1)

	LIS	R0,0
	SIS	R13,1
	JER	R5			: return if weve done all groups

	AHI	R6,PGRLEN		: else move on to next group
	J	IZPGR1


	
:	 INITIALIZATION FOR STACK PTR
:	 ----------------------------

INSTK	LA	RSTACK,STACK,,
	JR	R4



:	 INIHST	: INITIALIZE HOST TABLE ROUTINE
:	 ---------------------------------------
:	 LINK	-R12

INIHST	LHI	R9,(MAXHST-1)*HSTLEN	: SET UP OFFSET INTO HOST TABLE
	LHI	R13,MAXHST-1		: HOST NUMBER COUNTER
INIHS2
	LIS	R2,0
	STH	R2,HOSTBL+HCHGPT,R9,	: SET HOST STATUS CHANGE FLAG TO CHANGED
	STB	R2,HOSTBL+HSTSPT,R9,	: AND THE SHUT PORTS
	LB	R2,HOSTBL+HSTMPT,R9,	: START WITH MAXIMUM PORTS
	STH	R2,HOSTBL+HSTPRT,R9,	: UP PORTS
INIHS3
	STH	R2,HOSTBL+HSTFPT,R9,	: INIT FREE PORTS
	SHI	R9,HSTLEN
	SIS	R13,1
	JGE	INIHS2

	JAL	R5,HSTMSG		: report all our hosts to sup
	JR	R12			: RETURN

:
:	This routine reports all our hosts to the supervisor
:


HSTMSG	STM	R0,HSTREG
	IF	TYM1
	LIS	R9,0			: 1ST HOST ONLY FOR TYMNET 1
	ELSE	: (TYM1)
	LHI	R9,(MAXHST-1)*HSTLEN	: SET UP OFFSET INTO HOST TABLE
	EI	: (TYM1)
	LHI	R13,MAXHST-1		: HOST NUMBER COUNTER

:	 REPORT HOST STATUS
:	 IF HOST UP PORTS = 0, THEN HOST DOWN
:	 IF HOST UP PORTS > 0 AND FREE PORTS > 0, THEN HOST ANSWERED
:	 IF HOST UP PORTS > 0 AND FREE PORTS = 0, THEN HOST SHUT

HSTM1	LIS	R2,0
	TBT	R2,HOSTBL+HCHGPT,R9,	: SEE IF NO-CHANGE SW IS ON OR OFF
	JN	HSTHMN			: DON'T SEND MESSAGE IF SAME-SW IS ON

	LIS	R0,HSTALN		: LENGTH OF MESSAGE
	LIS	R1,0			: MSG TO PORT 0
	LHI	R2,HSTSTA		: HOST STATUS MESSAGE
	JAL	R4,SLOR,,		: START LOGICAL OUTPUT RECORD
	LIS	R0,0			: SEND NULL KEY
	JAL	R4,PUTCH,,		: 
	LHL	R0,HOSTBL+HSTNUM,R9,	: GET HOST NUMBER
	JAL	R4,PUTH,,		: SEND IT

	IF	TYM1
	LHI	R0,NPORTT-NGRPS		: GET TOTAL OF ALL PORTS DEFINED
	ELSE
	LB	R0,HOSTBL+HSTMPT,R9,	: GET MAXIMUM PORTS FOR HOST
	EI	: (TYM1)

	JAL	R4,PUTH,,		: SEND IT

	IF	TYM1
	LIS	R0,0			: REL HOST # ALWAYS 0 FOR TYM1
	ELSE
	LR	R0,R13			: COPY RELATIVE HOST NUMBER
	EI

	JAL	R4,PUTH,,		: SEND IT
	LIS	R0,HSTDWN		: ASSUME HOST DOWN
	LHL	R4,HOSTBL+HSTPRT,R9,	: CHECK HOST UP PORTS
	JE	HSTM2			: IF NO UP PORTS, THEN HOST DOWN
	LIS	R0,HSTSHT		: ELSE, FREE PORTS = 0, HOST SHUT
	LB	R4,HOSTBL+HSTSPT,R9,	: GET NUMBER OF PORTS SHUT
	CLB	R4,HOSTBL+HSTMPT,R9,	: COPMARE TO THE MAX PORTS
	JEFS	HSTM2			: IF SHUT (EXACTLY) EQL MAX, JUMP
	LIS	R0,HSTANS		: ELSE ASSUME SET HOST ANSWERED
HSTM2
	JAL	R4,PUTCH,,		: SEND IT
	LIS	R0,0			: SET MULTI BASE HOST KEY
	JAL	R4,PUTCH,,		: TO ZERO
	LHI	R0,80			: IIX CAPABLE
	JAL	R4,PUTCH,,
	LHI	R0,PRODID		: PRODUCT IDENTIFIER
	JAL	R4,PUTCH,,
	JAL	R4,ELOR,,		: END RECORD

	LIS	R0,HPRALN		: LENGTH OF MESSAGE
	LIS	R1,0			: MSG TO PORT ZERO
	LIS	R2,HSTPOR		: HOST PORT AVAILABILITY
	JAL	R4,SLOR,,		: START LOGICAL OUTPUT RECORD
	LIS	R0,0			: SET NULL KEY
	JAL	R4,PUTCH,,		: SEND IT
	LHL	R0,HOSTBL+HSTNUM,R9,	: GET HOST NUMBER
	JAL	R4,PUTH,,		: SEND IT
	LIS	R0,0			: SOFTWARE SHUT NOW
	LH	R4,HOSTBL+HSTFPT,R9,	: GET HOST FREE PORTS
	LR	R0,R4			: Get the actual number of free ports
	JAL	R4,PUTH,,		: SEND IT
	LR	R0,R13			: COPY RELATIVE HOST NUMBER
	JAL	R4,PUTH,,		: SEND IT
	JAL	R4,ELOR,,		: END LOGICAL RECORD

HSTHMN
	IF	1-TYM1			: SKIP IF TYMNET-I
	SHI	R9,HSTLEN
	SIS	R13,1
	JGE	HSTM1			: LOOP THROUGH ALL HOSTS
	EI	:(TYM1-1)
HSTM3
	LM	R0,HSTREG
	JR	R5

	SUBTTL	B.G LOGIC - BACKPRESSURE HANDLING ROUTINES 
 
:	 SBP - SET BACKPRESSURE
:	 ----------------------

SBP	PUSH(R5)
	PUSH(R2)
	PUSH(R3)
	PUSH(R1)
	LHL	R1,DPORT,RDCB,
	LIS	R0,3			: SEND SET B.P. MSG
	LHI	R2,NOSMSG
	JAL	R4,SLOR,,		: START MSG
	JAL	R4,ELOR,,		: END MSG
	RBT	R1,FRISIS		: SET B.P. TOWARD ISIS FLAG
	POP(R1)
	POP(R3)
	POP(R2)
	RETJ(R5)

 
:	 RBP - RESET BACKPRESSURE
:	 ------------------------

RBP	PUSH(R5)

	PUSH(R2)
	PUSH(R3)
	PUSH(R1)
	LHL	R1,DPORT,RDCB,
	LIS	R0,3			: SEND RELEASE B.P. MSG
	LHI	R2,SNDMSG
	JAL	R4,SLOR,,		: START MSG
	JAL	R4,ELOR,,		: END MSG
	SBT	R1,FRISIS		: SET B.P. TOWARD ISIS FLAG
	LHL	R4,DCBSUB,RDCB,		: Get sub for this dcb
	LHL	R1,SUBTAB+SUBABS,R4,	: get abs sub #
	RBT	R1,NBPCLR		: allow us to set B.P. again
	POP(R1)
	POP(R3)
	POP(R2)
	RETJ(R5)

:	CHKBP - Increase inbound count and check against limit.
:		If exceeds limit, calls SBP to set B.P. to Isis.
:		This condition will (hopefully) be cleared later
:		by the DF.G. when it releases enough inbound buffers
:		for the subsidiary attached to this port.
:
:	Entered with:	R0 - the count to be included
:			R4 - link

CHKBP	PUSH(R4)
	LHL	R4,SUBTAB+IBCOUNT,RSUB,	: get current count for sub
	AR	R4,R0			: add on this fragments size
	STH	R4,SUBTAB+IBCOUNT,RSUB,
	CLHI	R4,IBMAX		: see if weve reached limit
	JLE	CKBEND			: no,


:	else, see if B.P. to isis already set. If so, dont do anything

	LHL	R4,DPORT,RDCB,		: else see if weve B.P. set
	TBT	R4,FRISIS
	JE	CKBEND			: B.P already set

	JAL	R5,SBP			: else set B.P.


CKBEND	RETJ(R4)



 
	SUBTTL	B.G LOGIC - PUTBUF-BISYNC MESSAGE BUILDING UTILITIES
	
:	 PUTBC - PUT ONE CHAR INTO A BUF. CHAIN
:	 PUTBE - END THE MSG (CHECKSUM AND GET BYTE)
:	BCCSTO - CALCULATES BCC AND STORES IT
:	GETBC - GETS CHAR FROM BUFFER

 

:	 PUTBC - PUT ONE CHAR INTO BUFFER
:	 --------------------------------

PUTBC
	PUSH(R7)
	AIS	RBX,1			: ADVANCE OFFSET
	JN	PUTBC1			: END OF BUF. ?
	LR	RBX,RBA			: SAVE OLD BUF. ADDR.
	JAL	R4,GBB,,		: GET A NEW BUF.
	J	 NOBUF3
	STH	RBA,BBUFER+BBFLSZ-2,RBX,:LINK TO OLD BUF.
	LHI	RBX,-BBFLSZ+2		: INITIALIZE OFFSET
PUTBC1	STB	R0,BBUFER+BBFLSZ-2,RBA,RBX
	POP(R7)
	JR	R5

 
:	 PUTBE - END THE MESSAGE IN BUFFER
:	 ---------------------------------

PUTBE	PUSH(R5)
	LHI	R7,ETX			: GET "ETX"
	LB	R0,PARTAB,R7,		: GET REVERSED & PARITY CHAR
	JAL	R5,PUTBC		: PUT IT INTO BUFFER
	JAL	R5,BCCSTO		: CALCULATE BCC AND STORE IT
	LB	R0,DTPBCC,RDCB,		: GET BCC COUNTER
	JAL	R5,PUTBC		: PUT IT INTO BUFFER
	RETJ(R5)

:	 BCCSTO - CALCULATE BCC AND STORE IT INTO DTPBCC
:	 -----------------------------------------------
:	 INPUT	-R7 CONTAINS THE CHAR (BEFORE REVERSING)

BCCSTO
	LB	R4,DTPBCC,RDCB,		: GET CURRENT BCC COUNTER
	XR	R4,R7			: CALCULATE THE NEW BCC
	STB	R4,DTPBCC,RDCB,		: STORE NEW BCC
	JR	R5

:	 GETBC - GET NEXT CHAR FROM BUFFERLET CHAIN
:	 ------------------------------------------
:	 INPUT - RBA,RBX
:	 OUTPUT- R0 = CHAR
:	 LINK	- R4

GETBC	AIS	RBX,1				: ADVANCE OFFSET
	JNFS	GETBC1				: SKIP IF NOT END OF BUF.
	LR	RBX,RBA
	LHL	RBA,BBUFER+BBFLSZ-2,RBA,	: GET ADDR OF NEXT BUF.
	JNFS	.+8
	J	 NOBUF3,,
	LHI	RBX,-BBFLSZ+2			: INITIALIZE OFFSET
GETBC1	LB	R0,BBUFER+BBFLSZ-2,RBA,RBX	: GET THE CHAR
	JR	R4


	SUBTTL	B.G LOGIC - FLUSH BUFFER ROUTINES


:	 FLRCV - FLUSH RECEIVE QUEUE
:	 ---------------------------

FLRCV	PUSH(R5)
	PUSH(R11)
	SULOAD	R15,DCBSUB,RDCB,	: Get the SUBTAB ptr for this DCB
	PGLOAD	R11,DCBGRP,RDCB,	: Get the PGRTAB ptr for this DCB
FLRCV1
	LO	CMDLST
	PKCMD(RCV,R15)
	JE	FLRCV3			: EXIT IF EMPTY
	JLFS	FLRCV2
	JAL	R5,PBBC,,		: DATA CMD - FREE BUFFERLETS
FLRCV2	ADVCMD(RCV,R15,R11)
	J	FLRCV1
FLRCV3
	FO	CMDLST
	POP(R11)
	RETJ(R5)
 
 
	SUBTTL	B.G LOGIC - OUTPUT TO ISIS UTILITY ROUTINES
 
:	 OCHAR - OUTPUT A CHARACTER TO THE ISIS RING
:	 -------------------------------------------
:	 THEN CHECK FOR END OF ISIS RECORD AND DISMISS IF SO
:	 INPUT	- R0 = OUTPUT CHAR	 RRC = ISIS RECORD CNT
:	 LINK	- R5
:	 WORK	- R4,R6
 
OCHAR	JAL	R4,PUTCH,,
	SIS	RRC,1			: REDUCE ISIS RECORD CNT
	JGR	R5			: RETURN IF NOT AT END
	JAL	R4,ELODR,,		: END ISIS RECORD

:	 NOW DISMISS OUTPUT PROCESS FOR THIS DEVICE
:	 ------------------------------------------
	STH	RBA,DORBA,RDCB,		: SAVE BUF. ADDR. PTR.
	STH	RBX,DORBX,RDCB,		: SAVE BUF. OFFSET
	STH	RCNT,DORCNT,RDCB,	: SAVE BISYNC BLOCK CNT
	SI	R5,RSEG			: CONVERT R5 TO RELATIVE ADDR
	STH	R5,DOSRA,RDCB,		: SAVE RETURN ADDRESS
	LI	R4,OCHA10-RSEG		: SET UP OUTPUT ADDRESS
	STH	R4,DODRA,RDCB,		: STORE IT
	RETJ(R5)			: RETURN TO OUTPUT SCANNER

:	 OCHA10 - BEGIN PROCESSING OUTPUT DATA MSG AGAIN AT THIS POINT
:	 -------------------------------------------------------------

OCHA10	PUSH(R5)
	LHL	RBA,DORBA,RDCB,		: RESTORE BUF. ADDR.
	LH	RBX,DORBX,RDCB,		: count, - Later overwritten !!
	LHL	RCNT,DORCNT,RDCB,	: BISYNC BLOCK COUNT
	JAL	R5,SLODR		: START A NEW ISIS OUTPUT RECORD
	LHL	R5,DOSRA,RDCB,		: GET RETURN ADDRESS (RELATIVE)
	J	 RSEG,R5,		: GO THERE
 
 
:	 SLODR - START A MAXIMUM LENGTH OUTPUT DATA RECORD
:	 -------------------------------------------------
:	 INPUT	- RDCB
:	 LINK	- R5
:	 WORK	- R4

SLODR	PUSH(R0)
	PUSH(R1)
	PUSH(R3)
	LHL	R1,DPORT,RDCB,		: GET PORT NUMBER
	LB	RRC,XLIMIT,R1		: GET MAX RECORD SIZE
	LIS	R0,3			: ALLOW 3 BYTES FOR HEADER
	AR	R0,RRC			: R0 = NO. BYTES NEEDED IN RING
	JAL	R4,SLOR,,		: START THE RECORD
	POP(R3)
	POP(R1)
	POP(R0)
	JR	R5

:	 SNDIIX - SUBROUTINE TO SEND A "CANNED" IIX MESSAGE.
:	 ---------------------------------------------------
:	 FIRST A SIIX MESSAGE IS SENT, THEN THE CANNED MESSAGE.
:	 R0,R4 = WORK REGISTERS (DESTROYED)
:	 R1,R2,R3 = WORK REGISTERS (SAVED)
:	 R5 = LINK REGISTER
:	 RDCB = ADR OF DCB
:	 R6 = ADR TO CANNED MESSAGE

SNDIIX	PUSH(R5)
	PUSH(R1)
	PUSH(R2)
	PUSH(R3)
	LHL	R2,DPORT,RDCB,		: GET PORT #
	LA	R3,M.SIIX,,		: ADR OF SIIX MSG
	JAL	R5,OCM,,		: SEND SIIX
	LHL	R2,DPORT,RDCB,		: GET PORT #
	LR	R3,R6			: ADR TO CANNED MSG
	JAL	R5,OCS,,		: SEND IIX MSG
	POP(R3)
	POP(R2)
	POP(R1)
	RETJ(R5)

 
:	SNDINV - SEND AN "INVITATION TO CLEAR (WITH REASON CODE)
:	--------------------------------------------------------

SNDINV	PUSH(R5)
	STB	R13,M.INV+8,,		: PUT REASON CODE INTO MESSAGE
	LA	R6,M.INV,,		: ADR OF "INVITATION TO CLEAR " MSG

SNDIN2	JAL	R5,SNDIIX		: SEND THE MESSAGE
	LR	R6,RSL			: Keep ret address safe
	LHL	R2,DPORT,RDCB,,		: while we send the TIIX
	LA	R3,M.TIIX,,
	JAL	R5,OCM,,
	LR	RSL,R6			: Restore ret address

	POP(R5)
	JR	R5


:	SNDLST - SEND AN ACTIVATE/DEACTIVATE MESSAGE
:	--------------------------------------------

SNDLST	PUSH(R5)
	J	SNDIN2


 

NOBUF3
	JAL	R10,CRASH,,
	BC	0,0,0,CRNNBF

	FO	C03BLK
	FO	C03FEX
	FO	FRNTND

	EM


        SUBTTL  CINACT - INACTIVE MODE PACKAGE FOR ICL C03 (HOST INTERFACE)


        RA      0
        MO      .,CINACT

        LO      MAIN
        LO      FRNTND
        LO      C03BLK

        GL      OCTOSS,IIC

 
        SEG     A.CODE

        SUBTTL  ISIS INPUT HANDLER FOR INACTIVE MODE

:       IIC     :(INACTIVE MODE) CONTROL MESSAGE IN INPUT QUEUE
:       ----------------------------------------------------

        HTABIA(IIC)
        FO      FRNTND
        FO      C03BLK
        FO      MAIN

        EM
 


        SUBTTL  LOGMOD - LOGON MODE ROUTINES

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                                                              ::
::                                                              ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:       **** REVISION HISTORY ****
:       ORIGINAL DESIGN AND CODE -- BY NELSON SU


:       LOGIN MODE ROUTINES

        RA      0
        MO      .,C03LOG

        LO      C03BLK
        LO      FRNTND
        LO      MAIN
        LO      C03RCV

        GL      IND,DOZAP,ENTNAT,SNDZAP,INC,OND,FLRIM

        SEG     A.DATA

LOGSTA  EQ      1F              :MASK FOR LOGON STATUS FIELD
HSTERR  EQ      8               :BEGINS CODE FOR HOST ERRORS
TIDCHR  EQ      0D1             :TID CHAR
W.USER  EQ      4               :LOGON WAITING FOR USERNAME
W.PASS  EQ      5               :LOGON WAITING FOR PASSWORD

SAVHST	HS	1		:Temp location to hold n/w host 
SAVPRT  BS      1
        BND     4

        SEG     A.CODE
 
        SUBTTL  ACTIVATION AND UTILITY ROUTINES FOR HOST/TERMINAL INTERFACE
 
 
:       ACTIV0 - ACTIVATION ADDRESS FOR PORT 0 MSGS
POLMSG  EQ      10              :LAST LEGAL PORT 0 MSG TYPE
ACTIV0  CHI     R2,POLMSG               :LEGAL MSG TYPE ?
        JG      POM30                   :N - CRASH
        SLHLS   R2,2                    :MAKE R2 INTO INDEX
        J       P0MSG,R2                :PROCESS MSG BY TYPE
 
 
:       P0MSG - JUMP TABLE FOR PORT 0 MSGS
P0MSG   J       POM10                   :TYPE 0
        J       POM10                   :TYPE 1
        J       POM50                   :TYPE 2
        J       POM30                   :TYPE 3
        J       POM30                   :TYPE 4
        J       POM30                   :TYPE 5
        J       POM20                   :TYPE 6
        J       POM30                   :TYPE 7
        J       POM30                   :TYPE 8 
        J       POM40                   :TYPE 9
        J       POM30                   :TYPE A
        J       POM30                   :TYPE B
        J       POM30                   :TYPE C
        J       POM10                   :TYPE D
        J       POM10                   :TYPE E
        J       POM30                   :TYPE F
        J       POM30                   :TYPE 10
 
POM10   JR      R5                      :JUST RETURN
 
POM20                                   :MSG TYPE 6 - GMT
        JAL     R4,GETCH,,              :SKIP CHAR
        JAL     R4,GETW,,               :SKIP GMT
        JR      R5                      :RETURN
 
POM30                                   :GOT WRONG MSG TYPE - CRASH
	SVC	DISMISS,0
	J	POM30

        JAL     R10,CRASH,,
        BC      0,0,0,CRINPE
 
:       ACTIVN  :ACTIVATION ADDRESS FOR NEEDLE
:       -----------------------------------
:       PROCESS NEEDLE

ACTIVN
:       LR      R6,R8                   :SAVE REL HOST #
        LI      RSTACK,STACK            :RESTORE STACK PTR
        PUSH(R5)
        LIS     RDCB,1                  :BUMP CIRCUIT COUNTER
        AHM     RDCB,FPANEL
        LHL     RDCB,PORTAB,R1,R1       :GET DCB ADDR
        STH     R11,DORCNT,RDCB,        :SAVE DIALECT
        LR      RRC,R2                  :SAVE USER NAME CNT

        LHI     R4,MAXHST-1
        JL      ACTVN5                  :JUMP,IF NO HOST
ACTVN0  LHL     R13,HSTPTR,R4,R4        :OFFSET TO HOST TABLE
        CLH     R7,HOSTBL+HSTNUM,R13,   :CHECK THE HOST # EQUAL OR NOT
        JE      ACTVN1                  :JUMP,IF EQUAL
        SIS     R4,1
        JGEBS   ACTVN0
        J       ACTVN5                  :NOT FIND HOST

ACTVN1	STH	R7,SAVHST		:KEEP HOST NUMBER
        LHL     R9,HOSTBL+HSTFPT,R13,   :CHECK HOST FREE PORTS
        JE      ACTVN5                  :FREE PORT =0,'HOST OUT OF PORTS'
        STH     R13,HSTTAB,R1,R1        :SAVE HOST TABLE PTR FOR THIS PORT
        LR      R9,R4                   :SAVE RELATIVE HOST #

	LR	R0,RRC			:Flush rest of needle !
	JAL	R4,FLUSH,,

        STH     R1,DPORT,RDCB,          :PUT PORT NO. INTO DCB
        RBT     R1,PLOCK                :INSURE THAT THE PORT IS UNLOCKED
        LHI     R0,$A20                 :"PROTOCOL VIOLATION"
        STB     R0,DZAP,RDCB,           :STORE REASON CODE
        J       ACTVN6

:       NOT RIGHT HOST DISCONNECT THE USER
:       ----------------------------------

ACTVN5
	LR	R0,RRC
        JAL     R4,FLUSH,		:Flush rest of needle !

ACTVNZ	STB     R1,SAVPRT
        LR      R2,R1
        LA      R3,HOPMSG,,             :OUTPUT 'HOST OUT OF PORT'
        JAL     R5,OCS,,
        LB      R1,SAVPRT
        RBT     R1,ACP                  :RESET ACTIVE CKT IND.
        LHI     R2,DETMSG               :SEND DETACH MESSAGE
        LIS     R0,3
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
        RETJ(R5)

:       FIND THE DESTINATION HOST
:       --------------------------

ACTVN6
        LHL     R13,HSTPTR,R9,R9        :OFFSET TO HOST TABLE
        LH      R3,HOSTBL+HSTFPT,R13,   :DOES HOST STILL HAVE PORT?
        JLE     ACTVNZ                  :NO,DISCONNECT THIS PORT
        LCS     R0,1                    :DECREASE THE FREE PORT BY 1
        AHM     R0,HOSTBL+HSTFPT,R13,   :UPDATE IT
        JG      ACTVN8


:       REPORT HOST PORT AVAILABLITIES

ACTVNA  LIS     R0,HPRALN               :LENGTH OF MESSAGE
        LIS     R1,0                    :MSG TO PORT 0
        LIS     R2,HSTPOR               :HOST PORT AVAILABILITY
        JAL     R4,SLOR,,               :START LOGICAL OUTPUT RECORD
        LIS     R0,0                    :SEND NULL KEY
        JAL     R4,PUTCH,,              :SEND IT
        LHL     R0,HOSTBL+HSTNUM,R13,   :GET HOST NUMBER
        JAL     R4,PUTH,,               :SEND IT
        LIS     R0,R0                   :SET TO SOFTWARE SHUT
        JAL     R4,PUTH,,               :SEND IT
        LR      R0,R9                   :GET RELATIVE HOST NUMBER
        JAL     R4,PUTH,,               :SEND IT
        JAL     R4,ELOR,,               :END OF LOGICAL RECORD
        LH      R1,DPORT,RDCB,  :RESTORE THE R1

ACTVN8

:       CHECK IIX SOURCE...DUMB OR SMART
:       IF DUMB, JUST RETURN.
:       IF SMART, THEN SEND PROPER SELECT DIALECT MSG.
:
        LH      R0,DORCNT,RDCB, :CHECK LEFT BIT FOR SMARTNESS
        JGE      ACTVNN          :DUMB -SEND MESSAGE

:       SMART...SEND LIST OF DIALECTS
        LA      R6,M.C030,,             :SET TO C03 FORMAT
        JAL     R5,SNDIIX               :SEND DIALECTS
        LHL     R2,DPORT,RDCB,          :SEND TIIX MESSAGE
        LA      R3,M.TIIX,,
        JAL     R5,OCM,,
        LHI     R0,FSHIIX-RSEG		:FLUSH MSG UNTIL SIIX
        STH     R0,DISRA,RDCB,
        LHI     R6,IND-RSEG             :INPUT DATA RETURN
        STH     R6,DIDRA,RDCB,		:STORE IT
        LHI     R6,INC-RSEG             :INPUT CONTROL MSG
        STH     R6,DICRA,RDCB, 		:STORE IT
	LHL	R6,SAVHST		:Network host
	STH	R6,DCBHST,RDCB,
        RETJ(R5)
:
ACTVNN	
        LIS     R0,1                    :INCREASE THE FREE PORT BY 1
        AHM     R0,HOSTBL+HSTFPT,R13,   :UPDATE IT
 
        STB     R1,SAVPRT
        LR      R2,R1
        LA      R3,PLSMSG,,
        JAL     R5,OCS,,
        LB      R1,SAVPRT
        RBT     R1,ACP
        LHI     R2,DETMSG
        LIS     R0,3
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
        RETJ(R5)
:
:

POM40
        JAL     R4,GETCH,,              :GET TO END OF MSG
        JAL     R4,GETH,,
        JAL     R4,GETCH,,
        JR      R5

POM50
        IF      \TKOVRF
        J       TKOVRF,,
        ELSE
        JR      R5
        REMARK  %OMITTING SLOT0 MSG FOR TAKEOVER. SEE C03LOG.ref, LINE #
QQQ     LINENO
        NUMBER  QQQ
        REMARK  .%
        EI

ACTIVT  EQ      .
ACTIVO  EQ      .

        FO      C03BLK
        FO      C03RCV
        FO      FRNTND
        FO      MAIN

        EM


	SUBTTL	CNATIV - ICL C03 HOST INTERFACE NATIVE MODE

	RA	0
	MO	.,CNATIV

	LO	C03BLK
	LO	MAIN
	LO	FRNTND
	LO	CMDLST

	GL	DOZAP,NZAP,IIXLST,OCTOSS,FREEBF,FREEGC

RW1	EQ	R6
RGRP	EQ	R10
RSUB	EQ	R11

	SEG	A.DATA

SU03D1	BS	1
	BND	2
SU03D2	HS	1
	BND	4
SUPREG	WS	10

	SEG	A.CODE

:	GENERATE IIX AND C03 JUMP TABLE FOR HOST INTERFACE
:	--------------------------------------------------
:
IIXLST	GENIIX
	GLOIIX(IIXLST,1,GLOSEL)		:SELECTED DIALECT
	GLOIIX(IIXLST,4,CLRCIR)		:NORMAL LOGON STATUS
	GLOIIX(IIXLST,5,CLRCIR)		:RESYNCHRONIZE
	GLOIIX(IIXLST,7,GLOREQ)		:REQUEST INTERFACE ID/VERSION

:	TURKEY LEVEL MESSAGE
:	--------------------
	TURIIX(IIXLST,9,TURCUD)		:CALL USER DATA
	TURIIX(IIXLST,15,CLRIND)	:CLEAR INDICATION
	TURIIX(IIXLST,16,CLRCIR)	:RESET INDICATION

IIXEND	EQ	.			:Remember end of table

	SUBTTL	NATIVE MODE MAIN ROUTINE (HOST INTERFACE)
 
:	ENTNAT	:ENTER NATIVE MODE (C03 HOST INTERFACE)
:	-----------------------------------------------

ENTNAT	PUSHM(R13)
	PUSH(R1)

ENTNA1
	LHL	RDEV,DDEV,RDCB,		:GET DEVICE NUMBER
	LI	R6,IND-RSEG		:SET UP NATIVE MODE
	STH	R6,DIDRA,RDCB,		:INPUT AND OUTPUT PROC. RTE.
	LI	R6,INC-RSEG		:ADDRS.
	STH	R6,DICRA,RDCB,
	LI	R6,OND-RSEG
	STH	R6,DODRA,RDCB,
	LI	R6,ONC-RSEG
	STH	R6,DOCRA,RDCB,

	LIS	R6,NMODE		:SET MODE = NATIVE
	STB	R6,DMODE,RDCB,

    	JAL	R5,FLRCV,,		:Ensure empty outbound q


:	SEND CALL ACCEPT TO TERMINAL INTERFACE
:	--------------------------------------
SNDACP	SULOAD	R7,DCBSUB,RDCB,		:GET SUBTAB ADDR
	LIS	R5,GR3LOK		:Clear Group reset flag
	RBT	R5,SUBTAB+SUBFLG,R7,

	LB	R5,SUBTAB+SUBLNM,R7,	:GET LINE NUMBER
	AIS	R5,1			:adjust it for range 1 - n
	STB	R5,M.CACP+5,,
	PGLOAD	R6,DCBGRP,RDCB,		:GET GRP BASE PTR
	LB	R5,PGRTAB+GRPADR,R6,	:GET GRP ADDRESS
	STB	R5,M.CACP+6,,
	LB	R5,SUBTAB+SUBADR,R7,	:GET SUB ADDRESS
	STB	R5,M.CACP+7,,

	LA	R6,M.CACP		:ADR OF CALL ACCEPT MSG
	JAL	R5,SNDIIX		:SEND THE MESSAGE

	LHL	R2,DPORT,RDCB,,		:Set up port for tiix message
	LA	R3,M.TIIX,,
	JAL	R5,OCM,,


:	Now we see if the host is still talking to this group.
:	If not, we send a message to the CMT inviting it to zap this
:	circuit with the reason  - line quiet for this group.

	LHL	R5,DCBGRP,RDCB,		:get group for dcb
	LIS	R1,GHANG
	TBT	R1,PGRTAB+GRPFLG,R5,	:see if group hung
	JE	ENTOK			:no,

:	Else, report this condition.

	LIS	R13,ZQUIET
	JAL	R5,SNDINV,,

:	Now, we look at the last Activate/Deactivate command for this
:	device - it should only ever be set for a card reader. When
:	a call is accepted for this device, we send the last
:	Activate Deactivate command.
:	We also need to send AL reset if this was retained.

ENTOK	SULOAD	R5,DCBSUB,RDCB,		:get sub
	LHL	R0,SUBTAB+LASTACT,R5,	:get last command
	JE	ENTOK2			:no command, continue

	LA	R6,M.CMND		:Set up command weve remembered
	STB	R0,M.CMND+6,,
	OHI	R0,080			:And mark it, as weve now sent it !
	STH	R0,SUBTAB+LASTACT,R5,
	JAL	R5,SNDLST		:send it off to caller

ENTOK2	POP(R1)
	POPM(R13)
	LIS	R2,0			: ensure chains are reset
	LIS	R3,0
	J	FSHIIX

:
	SUBTTL	(NATIVE MODE) ISIS INPUT CONTROL MSG HANDLER (HOST INTERFACE)

:	INC	:ISIS INPUT CONTROL MESSAGE HANDLER (NATIVE MODE)
:	------------------------------------------------------
 
	HTABVT(INC)
	CHGTAB(INC,DETMSG,RZAPN)		: Detach
	CHGTAB(INC,ZAPMSG,RZAPN)		: Disconnect
	CHGTAB(INC,SHGMSG,RZAPN)		: Super hang up
	CHGTAB(INC,HNGMSG,RZAPN)		: Hang up
	CHGTAB(INC,BLKMSG,RZAPN)		: Black ball
	CHGTAB(INC,GRYMSG,RGREY)		: Grey ball
	CHGTAB(INC,SIIX,SIIX00)			: SIIX message
 

:	RZAPN	:RECEIVED ZAP MESSAGE FROM ISIS (NATIVE MODE)
:	-----------------------------------------------------

RZAPN
	LCS	R6,1
	AHM	R6,FPANEL		:UPDATE CIRCUIT COUNT IN FPANL
RZAPM
	PUSH(R5)

	SULOAD	R5,DCBSUB,RDCB,		:R5 POINTS TO SUBTAB
	LB	R4,SUBTAB+SUBLNM,R5,	:R4 POINTS TO CURRENT LINE
	LHL	R6,LINPTR,R4,R4		:R6 POINTS TO LINTAB
	PGLOAD	R9,DCBGRP,RDCB,		:GET PGRTAB POINTER FROM DCB
	LB	R2,SUBTAB+SUBADR,R5,
	SLHLS	R2,8
	LB	R7,PGRTAB+GRPADR,R9,
	OR	R2,R7
	STH	R2,SU03D2
	STB	R4,SU03D1
	STM	R0,SUPREG
	LIS	R0,RSUPLN		:GET MSG LENGTH
	LIS	R1,0			:GET RPORT=0
	LHI	R2,SUPREP		:GET MESSAGE TYPE 03
	JAL	R4,SLOR,,
	LIS	R0,0
	JAL	R4,PUTCH,,
	LHL	R0,SU03D2		:GET GRP & SUB
	JAL	R4,PUTH,,
	LHI	R0,CKTZAP		:GET LOG TYPE
	JAL	R4,PUTCH,,
	LB	R0,SU03D1		:GET LINE NUMBER
	JAL	R4,PUTCH,,
	LHI	R0,PRODID
	JAL	R4,PUTCH,,
	JAL	R4,ELOR,,
	LM	R0,SUPREG

RZAPN0
RZAPN1
	JAL	R5,DOZAP		:ZAP THE DEVICE
	RETJ(R5)




RGREY
	PUSH(R5)
	LI	R0,IND-RSEG		:Restore table so we read data
	STH	R0,DIDRA,RDCB,

	SULOAD	RSUB,DCBSUB,RDCB,
	LIS	R0,GR3LOK		:and clear group reset flag
	RBT	R0,SUBTAB+SUBFLG,RSUB,
	RETJ(R5)


:	------------------------------------------------------
:	IND	:(NATIVE MODE) ISIS INPUT DATA MESSAGE HANDLER
:	------------------------------------------------------
 
IND	PUSH(R5)
	LHL	RSL,DISRA,RDCB,	
	AI	RSL,RSEG		:MAKE IT ABSOLUTE
	LR	RRC,R0			:RRC = ISIS MSG CNT
	LHL	RBA,DIRBA,RDCB,		:LOAD BUF. ADDR. , OFFSET AND CNT
	LH	RBX,DIRBX,RDCB,
	LHL	RCNT,DPFCNT,RDCB,	:get count in frag so far
IND10	JAL	R4,GETCH,,		:GET NEXT CHAR
	JALR	RSL,RSL			:CALL PROCESSING SUBROUTINE
	SIS	RRC,1			:REDUCE ISIS MSG CNT
	JG	IND10			:REPEAT TO END OF ISIS MSG
 
:	SAVE CONTEXT AND EXIT
	SI	RSL,RSEG		:MAKE SUBRTE. ADDR. RELATIVE
	STH	RSL,DISRA,RDCB,		:SAVE IT

	LIS	R0,SRCFLG		: See if we are dealing with
	TBT	R0,DFLAGS,RDCB,		: data for category 1
	JNFS	IND20			: jump if not, its normal data

	STH	RBA,IDIRBA,RDCB,	: else we save regs for int chain
	STH	RBX,IDIRBX,RDCB,	:
	JFS	IND30			: and continue

IND20	STH	RBA,DIRBA,RDCB,		: SAVE BUF. ADDR.
	STH	RBX,DIRBX,RDCB,		: And buffer offset

IND30	STH	RCNT,DPFCNT,RDCB,	: Save partial fragment count
	RETJ(R5)

:
:RECEIVED A CLEAR INDICATION
:
CLRIND	LHI	R5,$A3		:"DROPPPED BY USER"
	STB	R5,DZAP,RDCB,		:STORE REASON CODE
	J	CLRCIR
:
:
:CLEAR THE CIRCUIT BY ZAPPING THE CIRCUIT AND FLUSHING THE MESSAGE
:
CLRCIR	JAL	R5,NZAP		:ZAP THE CIRCUIT
	LIS	R2,0
	LIS	R3,0		: ensure chains reset
	J	FSHIIX		:FLUSH THE MESSAGE
 
:

:	GLOSEL	:(IIX CODE 8081) SELECTED DIALECT
:	-----------------------------------------

GLOSEL	JALR	RSL,RSL			:GET LEFT BYTE OF DIALECT SELECTED
	LIS	R7,0			:INIT SAVE REG CONTAINTS
	EXBR	R7,R0			:SHIFT BYTE TO LEFT SIDE
	JALR	RSL,RSL			:GET RIGHT BYTE OF DIALECT SELECTED
	OR	R7,R0			:COMBINE DIALECT SELECTED
	CI	R7,C03DIA		:IS IT C03 DIALECT?
	JN	GLOSE1			:No, try others

	LA	R6,M.TUR1		:Send Turkey level 1 message
	JAL	R5,SNDIIX

	LR	R6,RSL			:Keep ret address safe
	LHL	R2,DPORT,RDCB,,		:End it with TIIX
	LA	R3,M.TIIX,,
	JAL	R5,OCM,,
	LR	RSL,R6			:Restore ret address

	LIS	R2,0
	LIS	R3,0			:ensure chains reset
	J	FSHIIX


GLOSE1	SHI	R7,D.BASE		:GET INDEX TO DIALECT JUMP TABLE
	NI	R7,0FFFF		:MASK OUT BOTHERSOME BITS
	CLHI	R7,D.MAX		:DIALECT WITHIN RANGE?
	JGE	CLRCIR			:N - ZAP

	LHL	R5,DIATBL,R7,R7		:GET JUMP ADR
	J	RSEG,R5,,

:	JUMP TABLE FOR DIALECT SELECTED
:	-------------------------------

DIATBL	HC	CLRCIR-RSEG		:ASCII
	HC	CLRCIR-RSEG		:GATEWAY
	HC	CLRCIR-RSEG		:X25
	HC	CLRCIR-RSEG		:DSP
 

	J	FSHIIX
 

:
:	TURCUD	:(IIX CODE C089) CALL USER DATA
:	----------------------------------------
:
TSTLIN MACRO [				: Test the validity of a line #
	CLHI	R7,NBILIN		: See if beyond max
	JGE	LINFAIL

	LHL	R4,LINPTR,R7,R7		: Set ptr to lintab
	LB	R5,LINTAB+LNMGRP,R4,	: See if any groups on this line
	JE	LINFAIL

	LHL	R5,LINTAB+LNMSUB,R4,	: See if any subs on this line
	JG	WILD50			: Test successful, this line will do
]


TSTGRP MACRO [				: Test the validity of a group #
	LR	R7,R7
	JL	GRPFAIL			: Supplied group is too low

	THI	R7,3			: See if its a multiple of 4
	JN	GRPFAIL

	LR	R6,R7
	SRLS	R6,2			: Now divide by 4 and see if beyond max
	CLHI	R6,MAXGRP
	JGE	GRPFAIL

	SLLS	R6,1			: Make index down lintab table
	PGLODS	R5,LINTAB+PGRPTR,R4,R6	: Get pointer to the group
	JL	GRPFAIL			: No group in this place

	LB	R0,PGRTAB+LPSUBN,R5,	: Get number of subs in this group
	JG	WILD60			: Test ok, we can use this group
]

TSTSUB	MACRO [				: Test the validity of a subsidiary #
	LR	R7,R7			: See if its too low
	JL	SUBFAIL

	CLHI	R7,MAXSUB		: See if it is too high
	JGE	SUBFAIL

	LR	R6,R7
	SLLS	R6,1			: Make index for pgrtab table
	SULODS	R3,PGRTAB+SUBPTR,R6,R5	: Get pointer to the sub table
	JL	SUBFAIL			: No sub in this place

	LHL	RDEV,SUBTAB+SUBHST,R3,
	CLH	RDEV,DCBHST,RDCB,	: See if for correct host
	JN	SUBFAIL			: no, try another?

	LHL	RDEV,SUBTAB+SUBABS,R3,	: Get abs dev #
	TBT	RDEV,DUNAV		: See if already been allocated

	JN	GOTSUB			: Test ok, we can use this sub
]

:
:	Macro to send a black ball to the n/w for this device.
:

SENBLK	MACRO	[
	LHL	R1,DPORT,RDCB,
	LIS	R0,3			: Length of message
	LHI	R2,BLKMSG
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
]





	
TURCUD	JALR	RSL,RSL			:DISCARD PACKET SIZE
	JALR	RSL,RSL			:Get unused bytes
	JALR	RSL,RSL



:
:	Wild card processing, and testing for validity of requested subsidiary
:

	LIS	R0,0
	STB	R0,WLDFLG		:Initially clear wild flags

	JALR	RSL,RSL			:Get line number requested
	SIS	R0,1			:Scale down to range 0 - 15
	JGEFS	WILD10			:A line number was supplied

	LIS	R0,WLDLIN		:Line supplied was 0, this is wild
	SBT	R0,WLDFLG		:So set bit to use later
	LIS	R0,0			:and set up our initial try

WILD10	STB	R0,SLINE		:Keep current line we are trying

	JALR	RSL,RSL			:Get supplied group #
	LR	R0,R0
	JGFS	WILD20			:Jump if it was specified

	LIS	R0,WLDGRP		:Wild, so set flag to say so,
	SBT	R0,WLDFLG
	LHI	R0,BGRPAD		:and set 1st group to try

WILD20	SHI	R0,BGRPAD		:Make it into an offset
	STB	R0,SGRP			:and save for later testing

	JALR	RSL,RSL			:Get supplied sub #
	LR	R0,R0
	JGFS	WILD30			:Jump if it was specified

	LIS	R0,WLDSUB		:Wild, so set flag
	SBT	R0,WLDFLG
	LHI	R0,BSUBAD+4		:And initial sub # to try

WILD30	SHI	R0,BSUBAD		:Make it into an offset
	STB	R0,SSUB			:and save it for later testing


WILD40	LB	R7,SLINE		:Now test line # validity
	TSTLIN				:will jump to wild50 if ok

LINFAIL	LIS	R0,WLDLIN		:Bad line #, see if wild
	TBT	R0,WLDFLG
	JE	WREJECT			:No, so we must reject this attempt

	LB	R7,SLINE
	AIS	R7,1			:Else try next line #
	STB	R7,SLINE		
	CLHI	R7,NBILIN
	JG	WREJECT
	J	WILD40

:
:	Line number weve got now is ok, so test the group
:

WILD50	LB	R7,SGRP
	TSTGRP				:will jump to wild60 if ok

GRPFAIL	LIS	R0,WLDGRP		:Bad group #, so see if wild	
	TBT	R0,WLDFLG	
	JE	LINFAIL			:No, so see if we can try another line

	LB	R7,SGRP
	AIS	R7,4			:Else try next group
	STB	R7,SGRP
	CLHI	R7,MAXGRP*4		:Have we run out of groups
	JL	WILD50			:No, so try this next one

	LIS	R7,0			:Else start at first group again
	STB	R7,SGRP
	J	LINFAIL			:In case we can try another line

:
:	Group # ok, so test the sub #
:

WILD60	LB	R7,SSUB
	TSTSUB				:will jump to gotsub if ok

SUBFAIL	LIS	R0,WLDSUB		:Bad sub #, so see if wild
	TBT	R0,WLDFLG
	JE	GRPFAIL			:No, so see if we can try another group

	AIS	R7,1			:Else try next sub
	STB	R7,SSUB
	CLHI	R7,MAXSUB		:Have we run out of subs
	JL	WILD60			:No, so keep trying

	LIS	R7,4			:Else start at 1st sub again
	STB	R7,SSUB
	J	GRPFAIL			:In case we can try another group

:
:	Here we must reject this attempt by issuing an invitation to clear
:

WREJECT	LIS	R13,ZNODEV		:Invalid line/group/sub request
	JAL	R5,SNDINV
	LHL	RDCB,DUMDCB
	LIS	R2,0
	LIS	R3,0
	J	FSHIIX


:
:	Here weve got a valid line/group/subsidiary combination, so
:	we set up a dcb, and allocate this subsidiary.
:

GOTSUB	
	LB	R7,SLINE
	LHL	R2,LINPTR,R7,R7		:GET LINE CONFIGURATION TABLE

	LHL	RDEV,SUBTAB+SUBABS,R3,	:GET ABSOLUTE SUB #
	STH	RDEV,DDEV,RDCB,		:PUT DEVICE NUMBER INTO RDCB
	SUSTOR	R3,DCBSUB,RDCB,		:STORE SUB ADDR FOR THIS DCB
	LHL	R6,SUBTAB+SUBGRP,R3,
	STH	R6,DCBGRP,RDCB,		:STORE GRP ADDRESS FOR THIS DCB

	STH	RDCB,SUBTAB+SUBDCB,R3,	:STORE DCB FOR THIS SUBTAB
	STH	RDCB,DEVTAB,RDEV,RDEV	:STORE RDCB INTO DEVTAB

	LIS	R0,1
	AHM	R0,PGRTAB+GCIRCS,R6,	:INCREASE CIRCUITS ON THIS GROUP

	RBT	RDEV,DUNAV		:SHOW DEVICE IN USE
	J	ENTNAT

 

:	DSPQ0	:(IIX CODE C094)
:	------------------------
:	BRANCHED TO FROM DATIIX
:	THE DATA IS A MESSAGE FROM THE CMT TO THE HOST. 
:	HOWEVER, IT MUST BE CONVERTED TO A BISYNC MSG.


DSPQ0	JAL	R4,GBB,,		:New buffer for each new ALP frag
	J	NOBUF2			:jump,if not available
	LR	RBA,RBA			
	JE	NOBUF2			

	LHI	RBX,-BBFLSZ+1		:initialize byte index offset


:	COPY DATA FROM RING TO BISYNC MSG BUFFER
:	--------------------------------------------
:	We move a fragment at a time, where a fragment is up to 255
:	bytes, or up to an ETX, which denotes end of ALP. A partial BCC
:	is calculated for the fragment, which is placed after the ETX.
:	Bytes 2 and 3 are used to hold the size of the fragment and
:	byte 0 is used to hold a flag indicating whether this an end alp
:	fragment, or a mid alp fragment - this will be used by F.G.
:	to determine the state of the W bit when this fragment is transmitted.


DSPQ20	STH	RBA,FRAGST,RDCB,	: Keep start of this frag
	LIS	R0,ALCOMP		: set bit to say we are mid ALP
	SBT	R0,DFLAGS,RDCB,
	LIS	R0,FRCOMP		: and we are in mid frag
	SBT	R0,DFLAGS,RDCB,

	AIS	RBX,4			: skip past place for flag&count

DSPQ25	LIS	R0,0
	STB	R0,DTPBCC,RDCB,		: Initialise BCC for this Frag

:	Now see if we read an extra character when we filled the last
:	fragment. If so, then we must first use this one before we get
:	any more.

	LB	R7,DNCHAR,RDCB,
	JN	DSPQ28			: plant it if its there


DSPQ26	JALR	RSL,RSL			: Get character from circuit
	LR	R7,R0			: move to r7 for subroutines

DSPQ28	LB	R0,PARTAB,R7,		: Reverse char, and get parity
	CHI	R7,I.ETX		: Is it ETX - end of alp
	JE	DENDLP			: Go off if so

	JAL	R5,PUTBC		: Else plant into buffer chain
	JAL	R5,BCCSTO		: and update partial BCC
	SIS	RCNT,1			: Now see if weve done 255
	JG	DSPQ26			: keep going until we have

:
:	Here, weve filled an ALP fragment, so we need to plant an
:	ETX and the partial BCC after the text, and to update the
:	flag byte and the fragment count at the start of this fragment.
:	Before we plant the ETX, we have a look to see if the next
:	character would have been an ETX anyway. If so, we behave as if
:	we had seen it before our count expired. If the next character
:	turns out not to have been an ETX, then we must terminate the
:	fragment normally, but return to the above loop at the point
:	after the character has been read - as weve already read it.

	JALR	RSL,RSL			: Get the next character
	LR	R7,R0
	CHI	R7,I.ETX		: is it ETX
	JE	DENDLP			: Yes, flag for end of alp

	STB	R7,DNCHAR,RDCB,		: no, but dont forget this one

:
:	Else, we terminate this fragment which is mid alp

	JAL	R5,PUTBE		: Plant ETX and partial BCC
	JAL	R5,PUTBC		: Leave room in case TX plants pad
	LHL	R7,FRAGST,RDCB,		: Point to st of frags chain
	LIS	R0,0
	STB	R0,BBUFER,R7,		: Set flag byte to 0 - mid-alp
	LHI	R0,ALPSIZ+2		: and plant size
	STH	R0,BBUFER+2,R7,
:
:	Now update our current pointer,	as it may have altered, due to 
:	PUTBC. Then, we plant this ALP fragment onto the appropriate 
:	queue, and keep filling fragments in this way until we reach ETX.

	LHL	RSUB,DCBSUB,RDCB,	: Get sub for this dcb
	LHI	RCNT,ALPSIZ		: Reset fragment size to go
	LIS	R0,SRCFLG
	TBT	R0,DFLAGS,RDCB,		: see if for cat1 or normal cat
	JE	DSCAT1			: for cat1

	PUSH(RBA)			: save pointer for cat n queue
	LR	RBA,R7			: and plant frag start onto q
	PUTCMD(TXN,RSUB)
	POP(RBA)
	J	DSPQ32			: continue until reach end alp


DSCAT1	PUSH(RBA)			: keep current pointer
	LR	RBA,R7			: plant fragment start onto
	PUTCMD(TXI,RSUB)		: interrupt queue
	LHL	R7,DCBGRP,RDCB,		: need grp for this
	RLCMD(TXI,RSUB,R7)	
	POP(RBA)

DSPQ32	LHI	R0,ALPSIZ+2		: now include size in running ct
	JAL	R4,CHKBP		: and set B.P. if reached limit

	LIS	R0,FRCOMP		: flag fragment complete
	RBT	R0,DFLAGS,RDCB,
	J	DSPQ0			: and start a new fragment


:
:	Here, weve reached end ALP as weve seen a ETX in the data
:	so, we set the marker flag at start of this fragments chain,
:	and update its count, as well as planting the ETX, and partial
:	BCC.

DENDLP	LIS	R0,0			: Clear this, as we have
	STB	R0,DNCHAR,RDCB,		: not overshot

	JAL	R5,PUTBE		: Plant ETX, and partial BCC
	JAL	R5,PUTBC		: Leave room in case tx plants pad

	LHL	R7,FRAGST,RDCB,		: Point to start of frags chain
	LIS	R0,1
	STB	R0,BBUFER,R7,		: Set flag to say ALP complete
:
:	Now, work out how big this fragment is

	LHI	R0,ALPSIZ+2		: add on 2 for ETX, and BCC
	SR	R0,RCNT			: see how many we stored
	STH	R0,BBUFER+2,R7,		: plant size


:	Now we add on the size of this fragment to the current inbound
:	count for this subsidiary. If we exceed a limit, we set B.P
:	to isis for this port.

	SULOAD	RSUB,DCBSUB,RDCB,	: Get sub table address
	JAL	R4,CHKBP		: set b.p. if reached limit

	PUSH(RSL)			: keep safe
	LIS	R0,ALCOMP		: signal alp is complete
	RBT	R0,DFLAGS,RDCB,
	LIS	R0,FRCOMP		: and so fragment is complete
	RBT	R0,DFLAGS,RDCB,

	PGLOAD	R13,DCBGRP,RDCB,	:point to the group
	PUSH(RBA)			:keep current buffer address safe

	LIS	R0,SRCFLG
	TBT	R0,DFLAGS,RDCB,		:See if its for int cat 1
	JE	DSCAT2			:Yes, go off to put on int q

	LHL	RBA,FRAGST,RDCB,
	PUTCMD(TXN,RSUB)		:else put onto normal q
	RLCMD(TXN,RSUB,R13)

	LB	R1,SUBTAB+SUBCAT,RSUB,	:Get cat # for this sub
	JE	DSCATZ			:Cant set cat bit !


DSCATX	LIS	R0,GR3LOK		:see if GR3 complete
	TBT	R0,SUBTAB+SUBFLG,RSUB,
	JN	DSCATZ			:if so, we cant set bit yet


:	Else its ok to go ahead and inform F.G. by setting bit

	SIS	R1,1
	SLLS	R1,5			:Point to cat we want
	LHL	R0,SUBTAB+SUBABS,RSUB,	:Get subs # 0 - 255
	SBT	R0,PGRTAB+CAT1,R13,R1	:Set bit for this cat in grp

:	Now see if f.g. has cleared subcat while we werent looking. If
:	so, we must now clear the cat bit.

	LB	R2,SUBTAB+SUBCAT,RSUB,
	JN	DSCATZ			:OK its still set up

	RBT	R0,PGRTAB+CAT1,R13,R1	: reset bit as cat is now 0
	J	DSCATZ


DSCAT2	LHL	RBA,FRAGST,RDCB,
	PUTCMD(TXI,RSUB)		:plant frag start on int q
	RLCMD(TXI,RSUB,R13)
	LB	R1,SUBTAB+SUBCAT,RSUB,	:If cat 0, we cant signal int q
	JE	DSCATZ

	LIS	R1,1			:Set up to reference cat1
	J	DSCATX			:and set bit for it


DSCATZ	POP(RBA)
	POP(RSL)
	J	FSHIIX			:Now allow source to terminate


	SUBTTL	(NATIVE MODE - HOST INTERFACE) ISIS OUTPUT DATA MSG

:	RECEIVED A C03 DATA MESSGE FROM THE HOST
:	CONVERT IT TO A "RESPONSE" MESSAGE AND SEND IT ON TO
:	THE CMT VIA THE ISIS RING.

:	OND	:OUTPUT DATA MESSAGE IN NATIVE MODE
:	----------------------------------------
:	RBA = INDEX TO BUFFER CONTAINING DATA
:	R2	= # OF BYTES IN MESSAGE
:	DATA COUNT = # DATA BYTES + UCN (1) + CTR BYTE (1) +SEQ # (1)
:			= # DATA BYTES + 3

OND	PUSH(R5)
	STH	RBA,DORBA,RDCB,		:SAVE BUFFER ADR OF DATA MSG
	LR	RCNT,R2			:# OF DATA BYTES IN MESSAGE
	SIS	RCNT,3
:	BEGIN MESSAGE PACKET...SEND SIIX AND START ISIS OUTPUT RECORD
:	-------------------------------------------------------------
	LIS	R0,3			:SEND SIIX MSG
	LHL	R1,DPORT,RDCB,	:
	LHI	R2,SIIX
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
	LHI	RBX,-BBFLSZ+1		:Count, later overwritten !
	LHL	RBA,DORBA,RDCB,		:RESTORE BUFFER ADR OF DATA MSG
	JAL	R5,SLODR		:START ISIS OUTPUT RECORD
	LHI	R0,0C0			:DATA DIALECT CODE (C094)
	JAL	R5,OCHAR
	LHI	R0,94
	JAL	R5,OCHAR


:	SEND IIX FLAGS AND 2-BYTE PACKET LENGTH
:	---------------------------------------
	LHI	R0,0			:SEND IIX FLAGS (M=0,Q=0)
	JAL	R5,OCHAR
	JAL	R5,OCHAR
	JAL	R5,OCHAR

	JAL	R4,GETBC		:Get first byte - group address

	LIS	R4,DOALND
	NHI	R0,01			:See if w bit set - ALP complete
	JE	OND10			:no,

	SBT	R4,DFLAGS,RDCB,		:else set bit to say so
	JAL	R4,GETBC		:discard sub #
	JAL	R4,GETBC		:now look at ALP prefix
	CLHI	R0,039			:is it an AL Reset ?
	JE	OND25			:yes,so keep record

	CLHI	R0,030			:is it an Activate ?
	JE	OND25			:yes, so keep record

	CLHI	R0,031			:is it a Deactivate ?
	JN	OND31			:no, so go to copy it

:	Else it is an Activate or Deactivate, and we must keep a record
:	of this, so that when someone (Card reader) next builds circuit,
:	We can reconstruct this message and issue it. In this way,
:	Activations and Deactivations from the Host can never get 'lost'
:	Note that it still the responsibility of the circuit builder to
:	actually deal with this message.
:	Amended 15/4/88 When we can send the message to the CMB/CMT, we
:	mark it so that when a new circuit is made, the CMB/CMT will
:	know that it will have responded once before. If we receive one
:	of these messages whiile the circuit is down, then we dont mark
:	it, and when CMB/CMT next comes in, we send it an unmodified
:	message, to which it is expected to respond.

OND25	SULOAD	R4,DCBSUB,RDCB,		:get Subsidiary
	OHI	R0,080			:mark command as we are to send it on
	STH	R0,SUBTAB+LASTACT,R4,	:and keep this command
	NHI	R0,0FF7F
	JFS	OND31

OND10	RBT	R4,DFLAGS,RDCB,

OND20	JAL	R4,GETBC		:also discard sub #


:	COPY DATA FROM OUTPUT BUFFER TO ISIS RING
:	--------------------------------------------
OND30	JAL	R4,GETBC		:GET CHAR FROM BUFFER

OND31	JAL	R5,OCHAR		:OUTPUT BYTE TO RING
	SIS	RCNT,1			:DECREMENT PACKET COUNT
	JGBS	OND30
:
:	END OF BISYNC MSG BLOCK...ENTIRE DATA BLOCK HAS BEEN OUTPUT.
:	NOW FREE BUFFERS, FLUSH CMD, AND RETURN.
:	-------------------------------------------------------------

	LIS	R0,DOALND		: if alp end, set ETX
	TBT	R0,DFLAGS,RDCB,
	JN	OND32

	LHI	R0,I.ETB		: else set ETB as last in frag
	J	OND34

OND32	LHI	R0,I.ETX		: mark end of alp for CMT

OND34	JAL	R5,OCHAR
	JAL	R4,ELODR,,

	LR	R6,RSL			:Save ret address
	LHL	R2,DPORT,RDCB,,		:Set up port for tiix message
	LA	R3,M.TIIX,,
	JAL	R5,OCM,,
	LR	R6,RSL			:Restore ret address
	JFS	OND36


OND36	SULOAD	R5,DCBSUB,RDCB,		:GET SUBTAB ADDR FOR THIS DCB
	PGLOAD	R11,DCBGRP,RDCB,	:GET PGRTAB POINTER FROM DCB
	PKCMD(RCV,R5)
	ADVCMD(RCV,R5,R11)
		IF	OTMTRA
		:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:
		LB	R7,SUBTAB+SUBLNM,R5,
		LR	R4,R7
		SLHLS	R4,1
		L	R6,OTMTBL,R4,R4
		LHL	R11,OTMIND,R7,R7
		L	R4,SLOWC,,
		ST	R4,0,R11,R6
		STH	R5,4,R11,R6
		STH	R2,6,R11,R6
		STH	R3,8,R11,R6
		AHI	R11,10
		CLHI	R11,200
		JLEFS	.+4
		LIS	R11,0
		STH	R11,OTMIND,R7,R7
		EI
		:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:

:	Now, we free the data we've used, and check to see if we can 
:	release BNA.

	JAL	R5,FREEGC		: see if we can release gcs bna

	JAL	R5,FREEBF		:free off buffers

	LHI	R6,OND-RSEG		:SET OUTPUT RTE. ADDR. = OND
	STH	R6,DODRA,RDCB,
	RETJ(R5)
 
:	ONC	:ISIS OUTPUT CONTROL MSG IN NATIVE MODE
:	-------------------------------------------
 
ONC	HC	OCTOSS-RSEG		: 0 - NULL CMD
	HC	ORELBP-RSEG		:-1 - Release B.P. to isis
	HC	OBLKBL-RSEG		:-2 - Black ball this sub


:
:	F.G. has released enough buffers to enable us to release B.P.
:	to the network.
:

ORELBP	PUSH(R5)
	JAL	R5,RBP,,		: F.G. has released buffers,
	POP(R5)
	J	OCTOSS			: Isis to clear B.P.


:
:	A Group reset has been received, and we must send a black ball
:	to the network for this device. We expect a grey ball in return.
:

OBLKBL	PUSH(R5)
	SULOAD	RSUB,DCBSUB,RDCB,	: get sub table address
	PGLOAD	RGRP,DCBGRP,RDCB,	: and the group table
	
	LIS	R0,GR3LOK		: see if this was due to G.R.3
	TBT	R0,SUBTAB+SUBFLG,RSUB,
	JN	OBLK10			: yes, so do more

:	Else, this request arose as result of GR1, when F.G. noticed
:	that an outbound ALP had not been completely received yet.
:	We need to send a black ball in this case because data has been
:	lost in this direction.

	SENBLK				: send a black ball message

	POP(R5)
	J	OCTOSS


:	Here, a GR3 was received, and all subs on this group will
:	get a black ball request in order to synchronise the CMT with
:	the ICL host. After we send a black ball and an AL reset, we
:	can discard any data received from the n/w for this sub, until
:	we see a grey ball. We also flush both queues to the F.G.
:	There shouldnt be any conflict here, since none of the bits in
:	the categories bit arrays will be set, and since the GR3 was
:	received, the B.G. will have been prevented from setting these
:	bits while receiving data from the n/w. 

OBLK10	LI	R0,XTOSS		:We can discard data from n/w
	STH	R0,DIDRA,RDCB,

	SENBLK				:Send the black ball

	LIS	R0,3			:Now send the AL Reset
	LHL	R1,DPORT,RDCB,
	LHI	R2,SIIX			:first part is SIIX
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,

	JAL	R5,SLODR		:then we have the data
	LHI	R0,0C0
	JAL	R5,OCHAR
	LHI	R0,094
	JAL	R5,OCHAR

	LIS	R0,0			:next 3 bytes 0
	JAL	R5,OCHAR
	JAL	R5,OCHAR
	JAL	R5,OCHAR

	LHI	R0,0B9			:ALP prefix is AL Reset command
	STH	R0,SUBTAB+LASTACT,RSUB,	:Remember this for next time in
	JAL	R5,OCHAR
	
	LHI	R0,I.ETX		:etx at end of this ALP
	JAL	R5,OCHAR
	JAL	R4,ELODR,,

	LHL	R2,DPORT,RDCB,		:now we have TIIX at end
	LA	R3,M.TIIX,,
	JAL	R5,OCM,,


:	Now we clear both queues to the F.G.

OBLK20	PKCMD(TXI,RSUB)			:see if anything on int q
	JE	OBLK30			:no more, so now deal with other

	ADVCMD(TXI,RSUB,RGRP)		:remove cmd

	DSCFRG				:and discard buffers, dec count
	J	OBLK20			:until no more on q


:	Now we clear q for cat n. We must first release q, as it may
:	have a partially complete alp.

OBLK30	RLCMD(TXN,RSUB,RGRP)
	PKCMD(TXN,RSUB)			:anything there?
	JE	OBLK40			:no more

	ADVCMD(TXN,RSUB,RGRP)		:remove cmd

	DSCFRG				:release buffers, dec count
	J	OBLK30			:until no more in q


:	Now, its possible that B.G. had started an alp fragment, but
:	had not yet completed it. In this case, it would not yet appear
:	on the q, but the bit FRCOMP would have been set. If this is so,
:	we simply discard this partial fragment. The inbound count will
:	not need adjusting, as this only gets updated when a completed
:	fragment is placed on the q.

OBLK40	LIS	R0,FRCOMP
	RBT	R0,DFLAGS,RDCB,		:Have we an incomplete fragment
	JE	OBLK50			:no

:	else, we need to discard what has been accumulated.

	LHL	RBA,FRAGST,RDCB,	:Get start of fragment
	JAL	R5,PBBC,,		:free off buffers

OBLK50	POP(R5)
	J	OCTOSS

OCTOSS
	SULOAD	R9,DCBSUB,RDCB,		:GET SUBTAB ADDR FOR THIS DCB
	PGLOAD	R11,DCBGRP,RDCB,	:GET PGRTAB POINTER FROM DCB
	ADVCMD(RCV,R9,R11)
	JR	R5


NOBUF2	JAL	R10,CRASH,,
	BC	0,0,0,CRNNBF
	FO	C03BLK
	FO	MAIN
	FO	FRNTND
	FO	CMDLST

	EM


      SUBTTL  Background Logic - Queue Scanners

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                                                              ::
::                                                              ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:       **** REVISION HISTORY ****
:
:	New code for ICL C03 by	R. Tews		May 1986
:

        RA      0
        MO      .,C03BCK

        LO      C03BLK
        LO      MAIN
        LO      FRNTND
	LO	CMDLST


RSUB	EQ	R11
RGRP	EQ	R10

        SEG     A.DATA

:       VARIABLE ALLOCATION
:       -------------------

DUMDCB  HS      1                       : PTR TO DUMMY DCB
OSCA80  HS      1                       : TEMP STORAGE FOR SUB
OSCA90  HS      1                       : TEMP STORAGE FOR LINE
OSCA70	WS	1			: TEMP STORAGE FOR SUBTAB PTR

        SEG     A.CODE

        SUBTTL  Queue Scanning Routines

:       OSCAN - SCAN RECEIVE QUEUE FOR COMMANDS
:       ---------------------------------------

: This routine scans the receive queue for commands generated by
: the foreground protocol manager for data incoming from the line.

: Link on R5.

OSCAN

                :-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:
                IF      STMTRA
                LHL     R6,STMIND,,
                AIS     R6,4
                CLHI    R6,100
                JLEFS   .+4
                LIS     R6,0
                STH     R6,STMIND,,
                L       R5,SLOWC,,
                ST      R5,STMTBL,R6,
                EI
                :-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:

        PUSH(R5)
        LHI     R14,NBILIN-1            : Get the line counter
OSCAN0
        LHL     R11,LINPTR,R14,R14,     : Get the LINTAB pointer for this line
        SULOAD  R10,LINTAB+LNFSUB,R11,  : Get the address of the first SUBTAB
        LHL     R6,LINTAB+LNMSUB,R11,   : Get the number of SUBs on this line
OSCAN1
        PGLOAD  R11,SUBTAB+SUBGRP,R10,  : Get the PGRTAB pointer for this SUB
        LB      R4,SUBTAB+SUBPGR,R10,   : Get the rel. SUB in the P.G
        TBT     R4,PGRTAB+RCVDAT,R11,   : Anything queued for this SUB ?
        JE      OSCAN6                  : No, look at the next one.

: We found a SUB for which there is a command queued.

        LHL     RDCB,SUBTAB+SUBDCB,R10, : Get the DCB address.
        CH      RDCB,DUMDCB
        JE      OSCAN2			: NONE exists

        LHL     R1,DPORT,RDCB,          : Dispatcher port
        JLE     OSCAN2                  : None exists

        LH      RDEV,DDEV,RDCB,
        JL      OSCAN2                  : No device

        TBT     R1,TOISIS               : Backpressured by ISIS ?
        JE      OSCAN6			: Yes, check next SUB


:	Else, see what weve got here

	ST	R10,OSCA70		: Save subtab ptr
        STH     R14,OSCA80              : Save current line index
        STH     R6,OSCA90               : Save the SUB counter

        PKCMD(RCV,R10)
        JE      OSCAN5	                : No command
        JL      OSCAN3                  : Control command
        JG      OSCAN4                  : data

:
:	Here, we cannot sensibly pass on the data received for this
:	device, so we just throw away the message weve seen from F.G. 
:	If data buffers were sent as well, then these are returned to
:	the free pool.
:	But, just before we throw away a data message, we have a look
:	to see if it was an AL Reset, Activate or Deactivate. If it was, we
:	keep a record of this, so that when someone finally builds a 
:	circuit to this sub, then we will reconstruct the 
:	message and send it on to the builder.

OSCAN2	ST	R10,OSCA70		: Save SUBTAB ptr
	STH	R14,OSCA80		: Save current line index
	STH	R6,OSCA90		: and sub counter

	PKCMD(RCV,R10)			: See if we have a command
	JL	OSCZ			: yes, so Dont reset GR3lok yet

	LIS	R0,GR3LOK
	RBT	R0,SUBTAB+SUBFLG,R10,

OSDISC	PKCMD(RCV,R10)			: now see whats there to discard
	JE	OSCAN5			: nothing much

	JL	OSCZ			: Not data, so no buffers

:	Now check for AL Reset/Activate/Deactivate messages

	PUSH(R2)			: Keep count safe
	PUSH(RBA)			: and buffer address

	LHI	RBX,-BBFLSZ+1		: Initialise offset to get data
	JAL	R4,GETBC		: Get 1st byte - group
	NHI	R0,01			: W = 1 Alp complete ?
	JE	KEEP10			: no, so it cant be AL Reset/Activate/Deactivate

	JAL	R4,GETBC		: Get the sub #
	JAL	R4,GETBC		: Get ALP prefix
	CLHI	R0,039			: Is it AL Reset ?
	JEFS	KEEPIT			: yes, go to store it

	CLHI	R0,030			: Is it Activate ?
	JEFS	KEEPIT			: yes, go to store it

	CLHI	R0,031			: Is it Deactivate ?
	JNFS	KEEP10			: no, so go to tidy up

KEEPIT	STH	R0,SUBTAB+LASTACT,R10,	: Keep record of the command

KEEP10	POP(RBA)			: Restore regs before continuing
	POP(R2)

:	Here, we return the data, but also maintain outbound count

	LHL	R5,SUBTAB+OBCOUNT,R10,	: Get current outbound count
	SR	R5,R2			: reduce by number we will free
	STH	R5,SUBTAB+OBCOUNT,R10,

	PUSH(R2)
	JAL	R5,PBBC,,		: free off the buffers
	POP(R2)

	JAL	R5,FREEGC		: and see if we can release gcs bna
	J	OSCX			: now discard message

OSCZ	CLHI	R2,BLKBAL		: Was it Black Ball message ?
	JNFS	OSCX			: No, so just discard

	LIS	R0,GR3LOK
	TBT	R0,SUBTAB+SUBFLG,R10,	: Was it due to GR3 ?
	JEFS	OSCX			: no, so just discard

	RBT	R0,SUBTAB+SUBFLG,R10,	: now we can clear bit
	LHI	R0,0B9			: Set up last command as AL Reset
	STH	R0,SUBTAB+LASTACT,R10,

OSCX	PKCMD(RCV,R10)
	ADVCMD(RCV,R10,R11)		: now remove command from list
	J	OSCAN5			: restore regs and look at next sub

OSCAN3
        LHL     R5,DOCRA,RDCB,
        SR      R5,R2
        SR      R5,R2
        LHL     R5,RSEG,R5,
        JAL     R5,RSEG,R5,             : Call control processing routine
        J       OSCAN5
        J       OSCAN5

OSCAN4
                IF      ATMTRA
                : -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:
                LB      R7,SUBTAB+SUBLNM,R10,
                LR      R4,R7
                SLHLS   R4,1
                L       R6,ATMTBL,R4,R4
                LHL     R11,ATMIND,R7,R7
                L       R4,SLOWC,,
                ST      R4,0,R11,R6             : SLOWC
                STH     R10,4,R11,R6            : SUBTAB address
                STH     R2,6,R11,R6             : Command type
                AHI     R11,10
                CLHI    R11,200
                JLEFS   .+4
                LIS     R11,0
                STH     R11,ATMIND,R7,R7
                EI
                : -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:


	LIS	R5,GR3LOK
	TBT	R5,SUBTAB+SUBFLG,R10,	: see if GR3 received
	JN	OSDISC			: discard data if so !


:	Else deal with outbound data normally

        LHL     R5,DODRA,RDCB,
        JAL     R5,RSEG,R5,             : Call data processing routine
        NOP                             : possible skip 4 return
	NOP


OSCAN5
        LHL     R14,OSCA80              : Restore line index
        LHL     R6,OSCA90               : Restore SUB counter
	L	R10,OSCA70	        : Restore SUBTAB pointer

OSCAN6
        AHI     R10,SUBLEN              : Advance the SUBTAB pointer
        SIS     R6,1                    : Are there any left on the line ?
        JG      OSCAN1                  : Yes, process next SUB
        SIS     R14,1                   : No, Any more lines ?
        JGE     OSCAN0                  : Yes, process the next one

                : -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:
                IF      STMTRA
                LHL     R6,STMIND,,
                AIS     R6,4
                CLHI    R6,100
                JLEFS   .+4
                LIS     R6,0
                STH     R6,STMIND,,
                L       R5,SLOWC,,
                ST      R5,STMTBL,R6,
                EI
                : -:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:

        RETJ(R5)
:------------------------------------------------------------------------
:	Here, weve got data buffers sent to us, so we will return them.
:	If by so doing, we find that the total number of outbound (from
:	the host's point of view) characters for this device has now
:	dropped to one fragments worth below the maximum, then we can 
:	construct a supervisory status report and chain it onto the
:	interrupt chain. This is done by calling DATIIX using the 
:	JALR RSL,RSL mechanism. The code at DATIIX thinks its getting
:	the data from the IRING, but in fact it is being supplied by us.
:------------------------------------------------------------------------

FREEBF	PUSH(R5)			: Keep return address
	SULOAD	R10,DCBSUB,RDCB,	: get back sub address
	LHL	R5,SUBTAB+OBCOUNT,R10,	: Get current outbound count
	SR	R5,R2			: reduce by number we will free
	STH	R5,SUBTAB+OBCOUNT,R10,

	LH	R0,SUBTAB+SUBABS,R10,	: Get abs sub # of this dev
	TBT	R0,BNACLR		: see if we have already cleared
	JN	FREEX1			: bna before - just free if so


	TBT	R0,BNASENT		: Else see if we had reached limit
	JE	FREEX1			: no, so carry on


:	else, we have bna set for this device, so see if can release it

	CLHI	R5,OBMAX-ALPSIZ		: allow for at least one frag
	JGE	FREEX1			: still exceeding limit

:	else, we can release BNA condition by sending supervisory
:	status report with clear AL status on int category.

	SBT	R0,BNACLR		: Set bit so we do it once
	JAL	R5,PBBC,,		: first return the buffers

	LA	R4,M.RSBNA,,		: Load address of the report
	JAL	R5,PLANTIT		: and plant it onto int chain
	RETJ(R5)

:	Here, we just free the buffers.

FREEX1	JAL	R5,PBBC,,		: else, data so return buffer(s)
	RETJ(R5)

:----------------------------------------------------------------------
:	This routine sees if we can release GCS bna condition.
:	If so, it sends a message to the F.G. in the form of a 
:	supervisory status report on the int category for the GSS.
:----------------------------------------------------------------------

FREEGC	PUSH(R5)
	PUSH(R2)
	PUSH(R10)
	PUSH(R11)

	LHL	R5,PGRTAB+GOBCT,R11,	: get current group count
	SR	R5,R2			: reduce by amount to go
	STH	R5,PGRTAB+GOBCT,R11,

	LIS	R0,GBSENT		: see if gcs bna is set
	TBT	R0,PGRTAB+GRPFLG,R11,
	JE	FREEX2			: no, so do no more

:	Else we have gcs bna set for group, but see if weve been here
:	before, and already sent a message to clear it.

	LIS	R0,GBCLR
	TBT	R0,PGRTAB+GRPFLG,R11,
	JN	FREEX2			: yes, just wait then

	CLHI	R5,GOBMAX-ALPSIZ-ALPSIZ	: see if weve released enough
	JGE	FREEX2			: no, not yet

:	Else, we release gcs bna by sending supervisory status report
:	from GSS with clear AL status on int category.

	SULODS	R10,PGRTAB+SUBPTR,R11,	: get first dev on group (GSS)
	LHL	RDCB,SUBTAB+SUBDCB,R10,	: get its dcb
	LA	R4,M.RGBNA
	JAL	R5,PLANTIT		: and plant message

FREEX2	POP(R11)
	POP(R10)
	POP(R2)
	RETJ(R5)



:----------------------------------------------------------------------
:	This routine is supplied with a message address in R4, and will
:	linkit onto either the int or normal chain for this device. It
:	does this by calling the code at DATIIX, and fooling it into
:	thinking the message has come from ISIS.
:----------------------------------------------------------------------

PLANTIT	PUSH(R5)			: Keep return address

:	Now we save some variables that the DATIIX code may have need of
:	when it next reads data from the IRING. We restore these when
:	weve finished hijacking this code.

	LHL	R0,DFLAGS,RDCB,		: save some flags etc.
	PUSH(R0)
	LHL	R0,DNCHAR,RDCB,
	PUSH(R0)

:	Now set up a few values so we can plant message
	LIS	R0,WALACK
	RBT	R0,DFLAGS,RDCB,

	LHL	RBA,DIRBA,RDCB,
	LH	RBX,DIRBX,RDCB,


	LHI	RCNT,ALPSIZ
	LIS	R0,0
	STH	R0,DNCHAR,RDCB,

	LA	RSL,DATIIX		: This is where we will leap to
	LB	RRC,0,R4,		: Get count from message string

PLANT	PUSH(R4)			: keep index safe while we leap
	JALR	RSL,RSL			: go off to deal with character
	POP(R4)				: restore index
	AIS	R4,1			: point to next character
	LB	R0,0,R4,		: get it

	SIS	RRC,1			: dec message count
	JGE	PLANT			: keep going until all sent

:	Now weve planted the message, we update our chain

	LIS	R0,SRCFLG
	TBT	R0,DFLAGS,RDCB,		: see what chain we were on
	JNFS	PLANT2			: Normal chain

:	else int chain

	STH	RBA,IDIRBA,RDCB,
	STH	RBX,IDIRBX,RDCB,
	JFS	PLANT3


PLANT2	STH	RBA,DIRBA,RDCB,
	STH	RBX,DIRBX,RDCB,

PLANT3	POP(R0)				: Now restore values for DATIIX
	STH	R0,DNCHAR,RDCB,
	POP(R0)
	STH	R0,DFLAGS,RDCB,
	RETJ(R5)

        SUBTTL  B.G Logic - Port and Device Initialisation Routines

:       IZPORT  : INITIALIZE BACKGROUND PORT INFORMATION
:       ------------------------------------------------
:       ALLOCATE A DCB FOR EACH DEV. AND INIT. IT,SETUP IDLE MODE

IZPORT  PUSH(R5)
        LHI     R1,NSUBS-(NGRPS*4)	: SET UP PORT NUMBER
        LIS     RDCB,2                  : Ensure a non-zero offset
IZPO10
	JAL     R5,INIDCB               : INIT THE DCB

        STH     RDCB,PORTAB,R1,R1       : POINT PORT INDEX TO IT
        AHI     RDCB,DCBLEN             : Next DCB

        RBT     R1,PLOCK
        SIS     R1,1
        JG      IZPO10                  : REPEAT FOR ALL PORTS

        STH     RDCB,DUMDCB             : Set up the dummy DCB address
	JAL	R5,INIDCB		: and make sure flags etc clear
        RETJ(R5)
 
:       INIDCB  : INITIALIZE DEVICE CONTROL BLOCK CONTENTS
:       --------------------------------------------------
:       INPUT - R1(PORT NO.)    RDCB 

INIDCB	PUSH(R5)
        STH     R1,DPORT,RDCB,          : SET PORT NUMBER
        LIS     R6,0
	STH	R6,DCBHST,RDCB,		: Not yet linked to n/w host
        STB     R6,DZAP,RDCB,           : INIT REASON CODE FOR DISCONNECT
        STH     R6,DIRBA,RDCB,          : CURR. BUF. ADDR = 0
	STH	R6,DIRBX,RDCB,
	STB	R6,DPFCNT,RDCB,
	STB	R6,DNCHAR,RDCB,

	STH	R6,IDIRBA,RDCB,
	STH	R6,IDIRBX,RDCB,
	STH	R6,FRAGST,RDCB,
	STH	R6,DFLAGS,RDCB,
        STH     R6,DDEV,RDCB,
        LI      R6,XTOSS                : SET UP DATA RTE. TO TOSS MSG
        STH     R6,DIDRA,RDCB,
        LI      R6,IIC-RSEG             : CTL. MSG. RTE. TABLE ADDRESS
        STH     R6,DICRA,RDCB,
        RETJ(R5)

:       IZDEV   : INITIALIZE DEVICE INFORMATION
:       ---------------------------------------
:       Initialise the dummy DCB for inactive ports and
:       point all port indices to it.

IZDEV
        PUSH(R5)
        LHL     RDCB,DUMDCB

        LIS     R6,0
        STH     R6,DPORT,RDCB,          : CLEAR PORT NO.
        STH     R6,DIRBA,RDCB,

        LHI     RDEV,NSUBS-1            : SET UP DEVICE INDEX
IZDE10
        STH     RDCB,DEVTAB,RDEV,RDEV   : POINT DEVICE INDEX TO DCB
        SIS     RDEV,1
        JGE     IZDE10
        RETJ(R5)
 

:       NZAP    : DUMMY ROUTINE UNTIL NATIVE MODE IS IN PLACE
:       -----------------------------------------------------

NZAP    PUSH(R5)
        JAL     R5,SNDZAP               : SEND ZAP MSG TO ISIS
        JAL     R5,DOZAP                : CALL ZAP RTE.
        RETJ(R5)

:       DOZAP   : ZAP A DEVICE
:       ----------------------
:       INPUT - RDCB

DOZAP   CH      RDCB,DUMDCB             : IS THIS DUMMY DCB?
        JER     R5                      : Y-RETURN
        PUSH(R5)
        PUSHM(R13)
        PUSH(R1)
        PUSH(R2)
        PUSH(R3)
        PUSH(RDEV)

	LB	R3,DMODE,RDCB,		: see if already idle
	CHI	R3,IDMODE
	JE	DOZA20			: if so, dont send inop again

        LIS     R3,IDMODE
        STB     R3,DMODE,RDCB,          : DCB BECOMES IDLE

	LHL	RSUB,DCBSUB,RDCB,	: get sub for this dcb
	LHL	RGRP,DCBGRP,RDCB,	: get group
	LIS	R0,GHANG
	TBT	R0,PGRTAB+GRPFLG,RGRP,	: have we already hung
	JE	DOZA4			: No, so q inop message etc

:	Else, we want to clear any outstanding messages, as line has
:	gone dead before we got the zap.
:	First we clear both queues to the F.G.

ZCLR10	PKCMD(TXI,RSUB)			: see if anything on int q
	JE	ZCLR15			: no more, now deal with other

	PUSH(R4)
	ADVCMD(TXI,RSUB,RGRP)		: remove cmd
	DSCFRG				: discard buffers, dec count
	POP(R4)
	J	ZCLR10			: until no more on q

ZCLR15	RLCMD(TXN,RSUB,RGRP)
	PKCMD(TXN,RSUB)			: se if anything on q for cat n
	JE	ZCLR25			: no more

	PUSH(R4)
	ADVCMD(TXN,RSUB,RGRP)		: remove cmd
	DSCFRG				: discard buffers, dec count
	POP(R4)
	J	ZCLR15			: until no more on q


:	Now, we see if B.G. had started an alp fragment but had not yet
:	completed it and placed it on the q for cat n. If so, we must
:	release these buffers too.

ZCLR25	LIS	R0,FRCOMP
	RBT	R0,DFLAGS,RDCB,		: see if partial alp 
	JE	ZCLR30			: no, so look at next sub

:	Else we need to discard what has been accumulated

	LHL	RBA,FRAGST,RDCB,	: Get start of fragment
	PUSH(R4)
	JAL	R5,PBBC,,		: free off buffers
	POP(R4)

ZCLR30	LHL	R0,SUBTAB+SUBABS,RSUB,	: Get abs sub no
	SBT	R0,DUNAV		: now clear 'unavailable' flag
	J	DOZA20			: now complete the zapping


:	Here, we want to tidy up the q to the f.g. but also add on a
:	'dev inop' message. When this gets sent by the f.g. it will make
:	the device available again as far as the network is concerned.

DOZA4	LHL	R0,SUBTAB+SUBABS,RSUB,
:
:	WE DONT WANT THIS NEXT LINE, JUST ALLOW ANYONE IN NOW
	SBT	R0,DUNAV		: switch off sub until inop sent

	LIS	R0,ALCOMP		: See if last fragment complete
	TBT	R0,DFLAGS,RDCB,
	JE	DOZA10			: yes, just send ssr

:	ELse, we see if we have reached the end of a fragment. If so, we
:	can complete the ALP by adding a null fragment, otherwise, we
:	must first terminate the fragment by writing etx to it.
:	In either case, a supervisory status message is then sent to signal
:	that the device has gone inop.


	LIS	R0,FRCOMP
	TBT	R0,DFLAGS,RDCB,
	JE	DOZA5			: Current frag already complete

	LH	RBX,DIRBX,RDCB,		: get offset to current frag
	LHL	RBA,DIRBA,RDCB,		: and get current buffer to use

	JAL	R5,PUTBE		: plant etx at end
	JAL	R5,PUTBC

	LHL	R7,FRAGST,RDCB,
	LIS	R0,0
	STB	R0,BBUFER,R7,		: indicate alp not complete

	LHL	RCNT,DPFCNT,RDCB,	: now work out size
	LHI	R0,ALPSIZ+2
	SR	R0,RCNT
	STH	R0,BBUFER+2,R7,		: and store this as well

:	Now enter this on the TX queue


	JAL	R4,CHKBP		: Inc count 

	LR	RBA,R7			: Pass start of chain to F.G.
	LHL	R13,DCBGRP,RDCB,
	PUTCMD(TXN,RSUB)		: but dont release as not last

:	Now plant the null fragment of text as last in alp

DOZA5	LA	R4,M.NULL
	JAL	R5,PLANTIT		: frag is chained normally

:	Now plant the supervisory status report - dev inop.
:	But only if device still operable - 14/4/88

DOZA10	SULOAD	RSUB,DCBSUB,RDCB,
	LH	R4,SUBTAB+ALSTAT,RSUB,	: get current AL status
	TI	R4,01
	JN	DOZA20			: Dev already inop, dont send inop

	LA	R4,M.INOP
	JAL	R5,PLANTIT


DOZA20	LI      R6,XTOSS
        STH     R6,DIDRA,RDCB,          : SET INPUT DATA RTE. ADDR.

        LI      R6,IIC-RSEG
        STH     R6,DICRA,RDCB,          : SET INPUT CTL. MSG RTE. TABLE ADDR

        LHL     R1,DPORT,RDCB,
        RBT     R1,ACP

        LHL     R6,HSTTAB,R1,R1         : GET HOST TABLE PTR
        LIS     R7,1
        AHM     R7,HOSTBL+HSTFPT,R6,    : INCREASE FREE PORT BY 1
:
: when a circuit is zapped report the new
: number of free ports for this host.
:
        LIS     R0,HPRALN
        LIS     R1,0
        LIS     R2,HSTPOR
        JAL     R4,SLOR,,
        LIS     R0,0
        JAL     R4,PUTCH,,
        LHL     R0,HOSTBL+HSTNUM,R6,,
        JAL     R4,PUTH,,
        LHL     R0,HOSTBL+HSTFPT,R6,,
        JAL     R4,PUTH,,
        LR      R0,R6
: the following instruction is a
: nasty fudge to get the relative
: host number. it assumes a hostbl
: size of 10x.
        SRHLS   R0,4
        JAL     R4,PUTH,,
        JAL     R4,ELOR,,
        LH      RDEV,DDEV,RDCB,         : GET DEV. NO.
        JL      CLRZ40                  : SKIP IF NO DEVICE ASSIGNED

        SULOAD  R7,DCBSUB,RDCB,         : GET SUBTAB ADDR

	PGLOAD	R6,SUBTAB+SUBGRP,R7,	: GET GROUP ADDRESS
	LCS	R3,1			:
	AHM	R3,PGRTAB+GCIRCS,R6,	: REDUCE CIRCUITS TO THIS GROUP

:	Now see if we are down to 0 circuits. If so, see if the GCSDEF 
:	feature is enabled. If so, we will pretend that we dont see
:	any activity on the line. When we subsequently are enabled by
:	a new circuit, we will need to have our initial status settings.

	LHL	R3,PGRTAB+GCIRCS,R6,
	JN	STILLC			: STILL CIRCUITS ACTIVE

	LIS	R3,GDEF
	TBT	R3,PGRTAB+GRPFLG,R6,	:SEE IF DEAFNESS ENABLED
	JE	STILLC			: NO, SO CONTINUE

	LHI	R3,IZLLST
	STH	R3,PGRTAB+LLSTAT,R6,
	LHI	R3,IZGCST
	STH	R3,PGRTAB+GCSTAT,R6,

STILLC  LHL     R6,DUMDCB               : GET DUMMY DCB ADDRESS
        STH     R6,SUBTAB+SUBDCB,R7,    : CLEAR DCB ADDR
        STH     R6,DEVTAB,RDEV,RDEV     : POINT DEVICE INDEX TO IT

        LCS     R6,1
        STH     R6,DDEV,RDCB,           : SET DEVICE NO. TO ZERO IN PORT DCB

CLRZ40	POP(RDEV)		
        POP(R3)
        POP(R2)
        POP(R1)
        POPM(R13)
        RETJ(R5)

:       SNDZAP  : SEND ZAP MSG TO ISIS
:       ------------------------------

SNDZAP  PUSH(R5)
        PUSH(R1)
        PUSH(R2)
        PUSH(R3)
        LCS     R1,1
        AHM     R1,FPANEL               : UPDATE CIRCUIT COUNT
        LHL     R1,DPORT,RDCB,          : GET PORT NO.
        JLE     SNDZ90                  : SKIP IF NULL
        RBT     R1,PLOCK                : UNLOCK PORT

:       SEND ADDENDUM TO ACCOUNTING (DZAP IS NORMALLY ZERO)
:       ---------------------------------------------------

SNDZ10  LB      R0,DZAP,RDCB,           : ANY REASON CODE FOR DISCONNECT?
        JE      SNDZ20                  : N - DO NOT SEND ADDENDUM TO ACCT
        LIS     R0,8                    : ADDENDUM TO ACCT MSG LENGTH
        LHI     R2,ADACTG               : ADDENDUM TO ACCT MSG CODE
        JAL     R4,SLOR,,               : START ISIS MSG
        LIS     R0,0
        JAL     R4,PUTCH,,              : IGNORE 1ST BYTE
        LHI     R0,0E000                : SEND CODE 0E
        JAL     R4,PUTH,,               : AND SUBTYPE 0
        LB      R0,DZAP,RDCB,           : GET REASON CDOE
        JAL     R4,PUTH,,               : SEND IT
        JAL     R4,ELOR,,               : END THE MSG
        LIS     R0,0
        STB     R0,DZAP,RDCB,           : RESET REASON CODE

:       SEND DETACH MSG
:       ---------------

SNDZ20  LIS     R0,3            : MSG LENGTH
        LHI     R2,DETMSG       : ZAP MSG CODE
        JAL     R4,SLOR,,       : START MSG
        JAL     R4,ELOR,,       : END MSG
SNDZ90  POP(R3)
        POP(R2)
        POP(R1)
        RETJ(R5)

:       FLRIM   : FLUSH REST OF INPUT RECORD FROM ISIS
:       ----------------------------------------------

FLRIM   CLHI    RRC,1                   : DOWN TO LAST BYTE ?
        JLR     R5                      : Y - RETURN
        JAL     R4,GETCH,,
        SIS     RRC,1                   : REDUCE BYTE CNT
        J       FLRIM                   : REPEAT
 
        FO      C03BLK
        FO      MAIN
        FO      FRNTND
	FO	CMDLST

        EM
 



        SUBTTL  Background Logic - Slot Start-up / B.G Exec

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                                                              ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:       **** REVISION HISTORY ****
:       ORIGINAL DESIGN AND CODE -- BY NELSON SU


        LO      C03BLK
        LO      MAIN    
        LO      C03FEX
        LO      FRNTND
        LO      C03BCK


        SEG     A.DATA
BDEBUG  HC      0
 
        RA      0


        SUBTTL  Entry Point and Initialisation

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                                                                      ::
::                      I N I T I A L I Z A T I O N                     ::
::                                                                      ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        SEG     A.CODE

:       ZAP ANY ACTIVE PORTS
:       --------------------

START   LHI     R1,NSUBS-(NGRPS*4)     : PORT INDEX
        LIS     R5,0            : CONSTANT REG
        LHI     R2,ZAPMSG       : ISIS ZAPPER

IZ0110
        LIS     R0,3            : ZAPPER LENGTH
        JAL     R4,SLOR,,       : START MSG
        JAL     R4,ELOR,,       : END MSG
IZ0130  SIS     R1,1            : GO TO NEXT PORT
        JGBS    IZ0110

:       DISMISS WHILE ISIS PROCESSES ZAPPERS

        SVC     DISMISS,0


:       INITIALIZE PROCESSORS
:       ---------------------

IZSECT
        JAL     R12,INIHST,,            : INIT THE HOST TABLE

        JAL     R0,IZT,,                : INIT TIMEOUT FREE LIST
        JAL     R4,IZBB,,               : INIT BIG BUFFERLETS
        LO      CMDLST
        JAL     R4,IZCFL,,              : INIT CMD FREE LIST
        FO      CMDLST
        LO      FRNTND
        JAL     R0,IZFRNT,,             : INIT ISIS INPUT HANDLER
        FO      FRNTND
        JAL     R4,INSTK,,              : INIT STACK PTR
        JAL     R5,IZDEV                : INIT B.G. DEVICE INFO
        JAL     R5,IZPORT               : INIT PORT INFO
	JAL	R5,IZPGRP,,		: Init poll groups
	JAL	R5,INIPLT,,		: Init poll/select timeout

	LIS     R5,0
	STH     R5,FPANEL
	LO	CMDLST
	JAL	R5,IZFG,,		: INIT BISYNC LINE STUFF
	FO	CMDLST

 

:	 START FOREGROUND
:	 ----------------

STFG
	IF	ISIS2
	LA	R0,FSTART,,		: GET F.G. ADDR.
	SVC	SYS,CFGND.		: CONNECT IT
	ELSE
	SVC	2,FSTART		: CONNECT FOREGROUND
	JAL	R10,BCRASH		: CRASH IF WE CAN'T
	EI

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::									::
::		B A C K G R O U N D     E X E C L O O P		 ::
::									::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

EXEC
	LH	R0,BDEBUG,,	 	: IF BACK GROUND ON
	JG	BTRAP			: IF YES, TRAP BACK GROUND CPU TIME
	SVC	FASTD
	
	LI	R8,STACK		: RESTORE STACK POINTER

	JAL     R0,INPUT,,		: ISIS INPUT HANDLER
	LO	C03BCK
	JAL     R5,OSCAN		: OUTPUT QUEUE SCANNER
	FO	C03BCK
	JAL	R0,TIMOUT,,		: Check for hung lines
	J	EXEC			: GO AGAIN


:	 BACK GROUND CPU TIME TRAP
:	 -------------------------

BTRAP
BTRAP0
	LH	R0,BDEBUG,,
	JLE	EXEC
	SVC	FASTD
	JBS	BTRAP0

BTRAP1
	STM	R0,DBSAVE,,
	LIS	R1,0			: CLEAR BDEBUG FLAG
	STH	R1,BDEBUG,,
	LM	R0,DBSAVE,,
	SVC	KIO,1			: RETURN TO DDT

BTRAP2
	STM	R0,DBSAVE,,
	LIS	R1,1			: SET BDEBUG FLAG
	STH	R1,BDEBUG,,
	LM	R0,DBSAVE,,
	SVC	KIO,1			: RETRUN TO DDT

:	 BCRASH - CALLED WHEN A CRASH IS DESIRED
:	 ---------------------------------------

BCRASH
	JAL	R10,CRASH,,
	BC	0,0,0,CRSVCE

	FO	MAIN
	FO	C03FEX
	FO	FRNTND
	FO	C03BCK
	FO	C03BLK

	EM

	SUBTTL	STATUS.LIB . DRIVER TO PROCESS ARBITRARY COMMANDS UNDER "?STAT"

:******************************************************************
:
:
:*******************************************************************

    IF	  1-\DB.STA		:DEFAULT DEBUG/STATUS TO ON
DB.STA	EQ	1
    EI

  IF	DB.STA				:ASSEMBLE ONLY WITH DEBUG STATUS ON

	SEG	A.CODE
	MO	.,STATUS
	RA	$00
	GL	DB.NTC

  IF	1-\DB.NTC
DB.NTC	EQ	0		: Default Network Console protocol to off
  EI

	GL	DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM,DS.BDN
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL
  IF	DB.NTC
	GL	DS.NXT,DS.CHK
  EI

:	STATUS - User Command Handler
:
:	Version history:
:	13.3  07/11/84  The following changes were made by Romolo Raffo.
:		Network Console protocol was added. This allowed Network
:		Console to communicate with Extended DDT Operations Managers.
:		The new features are controled by the assemble switch DB.NTC.
:		The default for this switch is off, so any program can use
:		this version of STATUS.LIB without change. Network Console
:		protocol is invoked by a command composed of four unprintable
:		characters. This is so hopefully no one will inadvertently
:		enter Network Console mode. If Network Console mode, the prompt
:		is no longer output, and the request for a "\" to be typed
:		after an error is removed. All commands received in this mode
:		begin with hex 8080 followed by a halfword id. The command
:		following this header is unchanged. The response begins with
:		a hex 8081 followed by the commands halfword id. The response
:		following this header is also unchanged, consisting of multiple
:		lines, each ending with a carriage return and a linefeed. After
:		the response, a trailer of hex 8082, the command id and an
:		empty line is sent. All of this is handle by STATUS.LIB,
:		without any change to the program using this package.
:
:		To use Network Console protocol, the following changes must be
:		made.
:			1) The variable DB.NTC must be set to one. This will
:			   cause the code to handle Network Console protocol
:			   to be assembled.
:			2) All jumps to label DSTART should be replaced by
:			   jumps to DS.NXT . The label DSTART is where DDT
:			   enters from the ?STAT command. It is now used to
:			   initialize the code to not using Network Console
:			   protocol.
:			3) Commands which have indefinite and possibly unending
:			   response, and need a way to abort the command,
:			   must call DS.CHK to check if the response should
:			   should end. If Network Console protocol, this call
:			   checks for a command end message from Network
:			   Console. Otherwise, it checks if any character has
:			   been entered. In either case, it does a normal
:			   return if no termination was received, and a skip-4
:			   return if termination was found.
:
:		Note that with these changes, users will still be able to use
:		the ?STAT command directly from DDT without any change.
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimeter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:		The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).

:		Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:	C/R	L/F	H/T	","	and BLANK.

:		Entry Points:
:	DSTART	Initialize STATUS.LIB on new circuit.
:	DS.NXT	Place to exit on completion of command.
:	DNEXTK  Get next token with out prompt.
:	DS.ILL	Place to exit on illegal command -- types "Illegal command"
:	DS.ERR	Place to exit on command error -- types "type '\' "
:	DS.EXI	Place to exit machine.
:	DS.QUI	Place to exit back to DDT.
:	DS.GCH	Get a character...Link on R1, char (with high-order bit forced)
:			in R0...normal return if detected ^W, skip-4 if detect
:			~A, aborts back to DS.NXT if detects ESC.
:	DS.DEL	Check for delimiter...Link on R2, Character in R0.  Skip-4
:			return unless this is a delimiter, then normal return.
:	DS.CUC	Convert to upper case...Link on R1, Character in R0.
:	DS.TOK	Get a string token...Link on R4, TOKEN returned in R3...
:			inputs up to 4 characters, returns them (in uppercase)
:			left justified, 0 fill
:	DS.NUM	Get a number...Link on R5, expects Radix in R4...
:			number returned in R0.  May ABORT if any character is
:			input other than valid digit or delimiter.
:	DS.CHK	Check if command termination entered...Link on R4. Skip-4
:			if termination entered, otherwise takes normal return.
:	DS.DLM  Location of last delimeter entered (1 byte)

:		There are two built-in commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.

:		additional commands may be defined via the DS.CMD macro:
:	 DS.CMD(TEXT,ADDR)
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	DS.CMD generates a 12-byte discriptor for this command, at the point
:	assembly where it is invoked.  This discriptor is on a WORD boundary.



OUT	EQ	0B			:OUTPUT SVC
IN	EQ	0A			:INPUT SVC

DS.ELL	EQ	0			:NULL POINTER FOR END OF LINKED LIST

	SEG	A.DATA
DS.DLM	BS	1			:LAST DELIMETER ENCOUNTERED
  IF	DB.NTC
NC.REF	BS	1			: Nonzero if end of response sent
NC.PRO	BS	1			: Nonzero if using NTCN protocol
:	Force NC.ID data (two bytes after length) to begin on a halfword
:	boundry. This is needed for compares and stores from HDR.ID
	ORG .-1; BND 1; ORG .+1
NC.ID	SC	/00/			: Current NTCN command id
HDR.ID	HS	1			: Last message header id
  EI
R4SAV	WS	1			:SAVE AREA FOR R4 IN DS.TOK
BADSTR	SC	/'xxxx'"8D"8A/		:PLACE TO PUT BAD COMMAND
BADNUM  SC      / Bad number /
	SEG	A.CODE

:	DEFINE ELEMENTS FOR COMMAND BLOCK
C.NEXT	EQ	0			:POINTER TO NEXT ENTRY
C.ADDR	EQ	C.NEXT+4		:POINTER TO COMMAND HANDLER
C.STR	EQ	C.ADDR+4		:RELATIVE POSITION OF STRING

:	DEFINE MACRO TO GENERATE THIS COMMAND BLOCK
DS.CMD	MACRO(STR,ADDR)[
   IF	DS.ELL
Q	WS	0
	ORG	DS.ELL
	WC	Q
	ORG	Q
   EI
DS.ELL	WC	0,ADDR
	AC	/STR/
	BND	4
]


:	TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST	WS	0			:FORCE TO WORD BOUNDARY
	DS.CMD(Q,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(QUIT,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(EXIT,DS.EXI)		:EXIT 
	DS.CMD(EXI,DS.EXI)		:EXIT 
  IF	DB.NTC
	DS.CMD("80"82"84"86,DS.NTC)	: Enter Network Console Protocol
  EI

  IF	DB.NTC
:	Network Console Messages
BEGRSP	SC	/"80"81/
ENDRSP	SC	/"80"82/
CRLF	SC	/"8D"8A/
ERRMES	SC	/"80"84"00/
  EI


:	DIAGNOSTIC MESSAGES
TERR	SC	/Illegal command /
TTERR	SC	/type '\'"8D"8A/
PROMPT	SC	/"8D"8A:>/		:"CR|LF:>"
BKSPAC	SC	/"88 "88/		:BACK SPACE

	SUBTTL	COMMAND SCANNER, VERIFIER, AND BITCHER


:	COMMAND INPUT HANDLER
DOIT	L	R0,C.ADDR,R1		:GO SERVICE THIS COMMAND
	JALR	R0,R0

:	NEXT COMMAND
DSTART
  IF	DB.NTC
	LIS	R0,0
	STB	R0,NC.PRO,,		: Turn off Network Console protocol
  EI
DS.NXT
  IF	DB.NTC
	LB	R1,NC.PRO,,		: Get Network Console protocol flag
	JE	DSNXT3			: If zero, use normal protocol
	JAL	R3,NC.END		: Send end of response message
DSNXT1	JAL	R1,NC.GCH		: Get first character of message header
	CLHI	R0,80			: Is this a message header?
	JNBS	DSNXT1			: No, ignore all chars before header
	JAL	R2,NC.HDR		: Get a message header
	CLHI	R3,85			: Is it a command termination?
	JN	DSNXT2			: No, go try command begin
	LH	R3,HDR.ID,,		: Get id in message header
	CLH	R3,NC.ID+1,,		: Is it the same as in last command?
	JN	NCPER0			: No, go send error message.
	JAL	R1,NC.GCH		: Get first character of command header
	JAL	R2,NC.HDR		: Get rest of command header
DSNXT2	CLHI	R3,80			: Is it a command header?
	JN	NCPER1			: No, go send error message.
	LH	R3,HDR.ID,,		: Get id from command header
	STH	R3,NC.ID+1,,		: And save for response
	SVC	OUT,BEGRSP		: Send response header
	SVC	OUT,NC.ID,,		: Including command id
	LIS	R0,0			: Get false for response end flag
	STB	R0,NC.REF,,		: and set to response end needed
	J	DNEXTK			: Go get command token
DSNXT3
  EI
	SVC	OUT,PROMPT		:ISSUE PROMPT
DNEXTK	JAL	R4,DS.TOK		:GET COMMAND TOKEN
	LA	R1,CMDLST		:SEARCH FOR STRING MATCH
DSTAR1	CL	R3,C.STR,R1
	JE	DOIT			:PROCEED IF FIND A MATCH
	L	R1,C.NEXT,R1		:ELSE CONTINUE SCAN
	JGBS	DSTAR1
DS.ILL	SVC	OUT,TERR		:"ILLEGAL COMMAND"
	ST	R3,BADSTR+2,,		:"XXX"<CR>
	SVC	OUT,BADSTR,,
DS.ERR
  IF	DB.NTC
	LB	R1,NC.PRO,,		: Is Network Console protocol inuse?
	JN	DS.NXT			: Yes, don't bitch
  EI
	SVC	OUT,TTERR		:TELL USER TO TYPE FLUSH CHAR
BITCH	JAL	R1,DS.GCH		:FLUSH INPUT
	JBS	BITCH;	 NOPR	0			:^W...IGNOR
	JBS	BITCH;	 NOPR	0			:^A...IGNOR
	CLHI	R0,0DC			:READ UNTIL "\" IS FOUND
	JNBS	BITCH
	J	DS.NXT			:THEN EXIT

DS.BDN  SVC     OUT,BADNUM,,
        J       DS.ERR

:	BUILT-IN COMMANDS

:		Command EXIt
:		===========-
DS.EXI	SVC	KIO,0			:DISCONNECT


:		Command Quit (exit back to DDT)
:		=========---
DS.QUI	SVC	KIO,1			:RETURN TO DDT
	J	DS.NXT			:IF OPERATOR TYPED "P", GET NEXT COMMAND

  IF	DB.NTC
:		Command for entering Network Console protocol mode
:		==================================================
DS.NTC	LIS	R1,1			: Get nonzero value for protocol flag
	STB	R1,NC.PRO,,		: Store in flag
	STB	R1,NC.REF,,		: Also set response end seen flag
	J	DS.NXT			: Go start Network Console command
  EI
	SUBTTL	U T I L I T I E S

:	GET A COMMAND TOKEN...UP TO 4 CHARS LONG
:		SKIPS OVER EXTRA CHARACTERS TO NEXT DELIMITER
:	LINK ON R4
:	TOKEN RETURNED IN R3, LEFT JUSTIFIED
DS.TOK	HS	0
	ST	R4,R4SAV,,		:SAVE R4
TOKEN0	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	TOKEN0;	 NOPR	0			:^W...IGNORE
	JBS	TOKEN0;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:SKIP OVER DELIMITERS
	J	TOKEN0
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	CHI	R0,00DC			:= "\" ?
	JE	DS.NXT			:YES, PRINT PROMPT, GET NEXT COMMAND
	LBR	R3,R0			:SET UP STRING ACCUMULATOR (000000CC)
	LIS	R4,1			:1 CHAR. FOUND SO FAR
TOKEN	JAL	R1,DS.GCH		:GET ANOTHER CHAR
	J	TOKEN0			:^W...START OVER
	J	TOKEN3			:^A...TOSS LAST CHAR
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	J	TOKEN1			:GOT ONE...SKIP TO LEFT JUSTIFY IT
	CHI	R0,00DC			:= "\" ?
	JE	DS.ILL			:YES, TREAT AS ILLEGAL
	AIS	R4,1			:ONE MORE CHARACTER
	CHI	R4,4			:IF => 4 CHARS, DO NOT USE THIS ONE
	JG	TOKEN			:YES...SCAN FOR DELIMITER
	SLLS	R3,8			:NO...ACCUMULATE CHARS
	STBR	R0,R3
	J	TOKEN			:AND GET ANOTHER CHAR
TOKEN1	HS	0
	L	R4,R4SAV,,		:RESTORE R4
TOKEN2	TI	R3,0FF000000		:HAVE WE 4 CHARS ALREADY?
	JNR	R4			:YES...RETURN TOKEN IN R3
	SLLS	R3,8			:NO...JUSTIFY IT
	JBS	TOKEN2			:AND REPEAT

TOKEN3	HS	0			:HANDLE BACKSPACE IN TOKEN
	SIS	R4,1			:ONE LESS CHAR
	CHI	R4,4			:IF AFTER BACKSPACE TOKEN IS => 4
	JGE	TOKEN			: JUST DECRIMENT COUNTER
	SRLS	R3,8			:ELSE... DROP 1 CHARACTER
	J	TOKEN			:AND GET NEXT CHAR.

:	UTILITY ROUTINE TO READ A NUMBER
:	USES R0-R3
:	EXPECTS RADIX IN R4
:	LINK ON R5
:	ABORTS IF FIRST NON-DELIMITER IS NOT DIGIT
:	ELSE RETURNS NUMBER IN R0
DS.NUM	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	DS.NUM;	 NOPR	0			:^W...IGNORE
	JBS	DS.NUM;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER CHAR
	J	DS.NUM
	JAL	R2,DS.DIG		:TEST IF CHAR IS DIGIT
	J	DS.ILL			:NOT A DIGIT - GIVE ERROR MESSAGE
	CLR	R0,R4
	JGE	DS.ILL			:DIGIT IS BIGGER THAN RADIX...ABORT
	LR	R3,R0			:PUT FIRST DIGIT INTO ACCUMULATOR
NUMBER	JAL	R1,DS.GCH		:READ NEXT CHAR
	J	DS.NUM			:^W...START OVER
	J	DIVIDE			:^A...TOSS LAST DIGIT
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	LR	R0,R3;	 JR	R5	  :YES
	JAL	R2,DS.DIG		:SKIP IF DIGIT
	J	DS.ILL			:NO...ABORT
	CLR	R0,R4
	JGE	DS.ILL			:RADIX ERROR...BITCH
	MR	R2,R4			:BUILD NUMBER
	AR	R3,R0			:ADD NEW DIGIT
	J	NUMBER			:GET NEXT DIGIT
DIVIDE	LIS	R2,0			:GOT A ^A...MAKE DOUBLE-PRECISION ARG.
	DR	R2,R4			:QUOTENT INTO R3, WHERE WE WANT IT
	J	NUMBER			:NOW GO BACK FOR MORE DIGITS

:	DIGIT TEST
:	CHECK CHARACTER READ...SKIP RETURN IF DIGIT
:	THEN R0=BINARY VALUE OF HEX DIGIT
:	USES R1, LINK ON R2
DS.DIG	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	LR	R1,R0			:COPY CHAR
	SHI	R1,0B0			:IS IT "0"?
	JLR	R2			:RETURN IF LESS THAN "0"
	SIS	R1,0B9-0B0		:IS IF "9"
	JLEFS	DIGIT			:LESS THAN "9" THEN A GOOD DIGIT
	SIS	R1,0C1-0B9		:IS IT "A"?
	JLR	R2			:RETURN IF LESS THAN "A"
	SIS	R1,0C6-0C1		:IS IF "F"?
	JGR	R2			:RETURN IF GREATER THAN "F"
	SIS	R0,7			:0A - "A" (PARTIAL CONVERSION)
DIGIT	SHI	R0,0B0			:"0"
	J	4,R2			:SKIP RETURN

:	CHECK FOR DELIMITER
:	LINK	R2
:	USES	R0,R1
:	SKIP-4 RETURN UNLESS (R0) IS A DELIMITER CHARACTER
DS.DEL	LHI	R1,DLEN-1		:NUMBER OF DELIMITER CHARS
	STB	R0,DS.DLM,,		:SAVE DELIMITER
DELIM	CLB	R0,DLIST,R1		:COMPARE TO A DELIMITER
	JER	R2			:RETURN IF DELIMITER
	SIS	R1,1			:CHECK NEXT DELIMITER
	JGEBS	DELIM			:LOOP IF ANY MORE DELIMITERS
	J	4,R2			:SKIP RETURN
:	LIST OF DELIMITER CHARS
DLIST	AC	' ,'			:BLANK,","
	BC	8D,8A,89		:CR,LF,HT
DLEN	EQ	.-DLIST			:NUMBER OF DELIMITER CHARS

:	INPUT A CHARACTER
:	LINK	R1
:	NORMAL RETURN:  ^W INPUT...FLUSH ENTRY
:	SKIP-4 RETURN:  ^A or ^H INPUT...FLUSH LAST CHAR
:	SKIP-8 RETURN: CHAR IN R0 (HIGH-BIT ON)
:	ABORTS TO COMMAND SCANNER ON "ESC"
DS.GCH	SVC	IN,0F			:GET THE CHAR
	J	DS.GCH
	OHI	R0,80			:SET HIGH-ORDER BIT
	CLHI	R0,9B			:CHECK FOR ESCAPE
	 JE	DS.NXT			:ABORT, PROCEED WITH PROMPT IF SO
	CLHI	R0,97			:CHECK FOR ^W
	 JER	R1			:NORMAL RETURN
	CLHI	R0,81			:CHECK FOR ^A
	 JE	4,R1			:SKIP-4 RETURN
	CLHI	R0,88			:CHECK FOR ^H
	 JN	8,R1			:NO, SKIP-8 RETURN, CHAR IN R0

	SVC	OUT,BKSPAC		:BACK SPACE
	J	4,R1			:SKIP-4 RETURN FOR ^H

:	CONVERT CHAR IN (R0) TO UPPER CASE
:	LINK ON R1
DS.CUC	CLHI	R0,0E1			:COMPARE WITH "a"
	JLR	R1			:EXIT IF IT CAN'T BE LOWERCASE
	CLHI	R0,0FA			:COMPARE WITH "z"
	JGR	R1			:NOT LOWER CASE...JUST RETURN
	SHI	R0,20			:LOWER CASE...CONVERT TO UPPER
	JR	R1			:AND RETURN

  IF	DB.NTC
:	Check for command termination
:	Link	R4
:	Uses	R0, R1, R2, R3
:	Normal return:	Termination not found
:	Skip-4 return:	Command termination received
DS.CHK
	LB	R0,NC.PRO,,		: Is Network Console mode active?
	JN	DSCHK1			: Yes, go check for message.
	SVC	IN,00			: No, just check for any character.
	JR	R4			: Command termination not found
        BC      0,0                     : Align to word boundary
	J	4,R4			: Command termination found
DSCHK1	SVC	IN,00			: Get first character of header
	JR	R4			: Command termination header not found
        BC      0,0                     : Align to word boundary
	JAL	R2,NC.HDR		: Get a message header
	CLHI	R3,85			: Is it a command termination?
	JN	NCPER2			: No, go send error message.
	LH	R3,HDR.ID,,		: Get header id
	CLH	R3,NC.ID+1,,		: Is it the correct id?
	JN	NCPER0			: No, go send error message.
	J	4,R4			: Yes, command termination found

:	Read a Network Console message header. First character passed in R0.
:	First byte must be a hex 80.
:	Link	R2
:	Uses	R0, R1, R3
:	Returns	second byte of header in R3 and message id in HDR.ID.
NC.HDR	CLHI	R0,80			: Does message header begin with 80?
	JN	NCPER3			: No, go send error message.
	JAL	R1,NC.GCH		: Get second character of header.
	LR	R3,R0			: Save in R3
	JAL	R1,NC.GCH		: Get first character of id
	STB	R0,HDR.ID,,		: and save
	JAL	R1,NC.GCH		: Get second byte of header
	STB	R0,HDR.ID+1,,		: and also save it
	JR	R2

:	Input a character. Wait until one is received. Return character in R0.
:	Link	R1
NC.GCH	SVC	IN,0F			: Get next character of header
	J	NC.GCH			: Loop until received
	JR	R1

:	Send an protocol error message to Network Console
:
:	Code	Meaning
:	----	-------
:	0	The id in a command end message (type 85) does not match the
:		id in the command message.
:	1	Expected a command message and did not receive one.
:	2	Received a message other than command end in DS.CHK call.
:		A call to DS.CHK should only be done for commands which
:		need termination, i.e. which have not sent end of response.
:		These commands can only receive command end.
:	3	Message header does not begin with a hex 80.
:
NCPER0	LIS	R0,0			: Error code = 0
	J	NC.ERR			: Go send error message
NCPER1	LIS	R0,1			: Error code = 1
	J	NC.ERR			: Go send error message
NCPER2	LIS	R0,2			: Error code = 2
	J	NC.ERR			: Go send error message
NCPER3	LIS	R0,3			: Error code = 3
	J	NC.ERR			: Go send error message

NC.ERR	JAL	R3,NC.END		: Send response end, if needed
	SVC	OUT,ERRMES		: Send error message header
	SVC	KIO,0E			: Output error code in R0
	J	DS.NXT			: Return to command loop

:	Send end of response message, if not already sent
:	and set flag that it has been sent.
:	Link	R3
:	Uses	R1
NC.END	LB	R1,NC.REF,,		: Get response end sent flag
	JNR	R3			: No need to send, already sent
	SVC	OUT,CRLF		: Insure response has at least one line
	SVC	OUT,ENDRSP		: End previous response
	SVC	OUT,NC.ID,,		: Include command id
	SVC	OUT,CRLF		: and blank line
	LIS	R1,1			: Get true for response end sent
	STB	R1,NC.REF,,		: and set flag
	JR	R3

  EI

	EM

  EI	:(DB.STA)


        SUBTTL  EXTENDED C03 DDT MODULES - EXTDDT.F03
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                                                                ::
::                                                                ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       **REVISION HISTORY**
:       ORIGINAL DESIGN AND CODE -- BY NELSON SU
:       17-FEB-84 (RNC) -MODIFY BANNER TO MONITOR CONCEPT (NO SAR)
:       06-FEB-85 (PWD) -DELETE ZZ AND EXI COMMAND, FOR NETWORK CONSOLE


        SEG     A.CODE
        MO      .,STATUS
        LO      CRASH
        LO      MAIN

:-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
DECB.3  EQ      032A    :WIDTH= 3, BLANK FILL, BASE=10
DECB.9  EQ      092A    :WIDTH= 9, BLANK FILL, BASE=10
HEXB.3  EQ      0330    :WIDTH= 3, BLANK FILL, BASE=16
HEXZ.4  EQ      0450    :WIDTH= 4,  ZERO FILL, BASE=16
HEXB.5  EQ      0530    :WIDTH= 5, BLANK FILL, BASE=16
HEXZ.5  EQ      0550    :WIDTH= 5,  ZERO FILL, BASE=16
HEXZ.8  EQ      0850    :WIDTH= 8,  ZERO FILL, BASE=16
HEXB.9  EQ      0930    :WIDTH= 9, BLANK FILL, BASE=16
HEXB.A  EQ      0A30    :WIDTH=10, BLANK FILL, BASE=16

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::      D A T A    A R E A S                                      ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        SEG     A.DATA
PRICNT  HS      1
        SEG     A.CODE

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              DDT COMMANDS, 'ZZ' AND '\'                        ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        DS.CMD(CB,DS.QUI)               :QUIT IF NAD TRIES TO GO INTO
        DS.CMD(CA,DS.QUI)               : ASCII OR BINARY MODE


        DS.CMD(\,DDTNOP)
DDTNOP  J       DS.NXT                  :PRINT PROMPT, LOOK FOR NEXT TOK.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              HELP AND '?'                                      ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        DS.CMD(HELP,DDTHLP)
        DS.CMD(?,DDTHLP)

DDTHLP  HS      0
        LA      R1,HLPDAT               :GET START OF HELP DATA
DDTHL1  HS      0
        LB      R0,0,R1                 :TEST FOR DONE
        JE      DDTHL9                  :ZERO = DONE
        SVC     OUT,0,R1                :OUTPUT IT
        AR      R1,R0                   :GET NEXT LINE
        AIS     R1,1                    :+ 1 BYTE FOR THE LENGTH
        JBS     DDTHL1                  : TIL DONE
:
DDTHL9  J       DDTNOP                  :WAIT FOR NEXT COMMAND
:
:
        NOLIST
HLPDAT  EQ      .
   SC   /      C03 Host Interface Monitor"8D"8A/
CRLF SC /"8D"8A/
   SC   /--- Syntax	 ---   --- Action --------------------------------------"8D"8A/
   SC   /DIR    <arg>     Display Dispatcher Input Ring"8D"8A/
   SC   /                   From address <arg> or start"8D"8A/
   SC   /DOR    <arg>     Display Dispatcher Output Ring"8D"8A/
   SC   /                   From address <arg> or start"8D"8A/
   SC   /DR               Display both Rings continuously"8D"8A/
   SC   /                 Type "AF to terminate Display"8D"8A/
   SC   /HELP or ?        Print this list"8D"8A/
   SC   /SCOPE  <arg>     Display xmit and rcv operation codes"8D"8A/
   SC   /                   for the line specified by <arg>"8D"8A/
   SC   /SYM              Print a list of symbol addresses"8D"8A/
   SC   /Q                Back to DDT or Network Console"8D"8A/
   SC   /"8A/

   BC   0
        LIST

SPACE1  SC      / /
SPACE2  SC      /  /
STAR    SC      /*/

        HS      0               :COMMAND TABLE MUST BE ALLIGNED
CMDTLI  AC      'bsbe'          :BREAK START, BREAK END

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                                                              ::
::  SYMBOLC LIST                                                ::
::                                                              ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:
:  SYMBOL GENERATION MACRO
:
SYMGEN  MACRO(NAME) [
        IF      1-\SYMNAM
SYMNAM  EQ      .
SYM.NO  EQ      0
        EI
        SC      /NAME  /
SYAD|SYM.NO|    EQ      NAME
SYM.NO  EQ      SYM.NO+1
        ]
:
:  SYMBOL TABLE END
:
SYMEND  MACRO [
Q       EQ      0
SYMADR  WS      0
        RE      SYM.NO
        WC      SYAD|Q|
Q       EQ      Q+1
        ER
        WC      0       :TERMINATE LIST
        ]

        DS.CMD(SYM,DDTSYM)

DDTSYM
        LA      R2,SYMNAM               :POINT AT SYMBOL LIST
        LA      R3,SYMADR
DDTSY1
        L       R0,0,R3
        JE      DDTNOP                  :DONE
        SVC      OUT,CRLF
        LHI     R1,HEXZ.5
        SVC     KIO,$A10
        SVC     OUT,SPACE2
        SVC     OUT,0,R2
        LB      R0,0,R2
        AR      R2,R0
        AIS     R2,1
        AIS     R3,4
        J       DDTSY1

:
:  SYMBOL TABLE
:
        SYMGEN(IRING)
        SYMGEN(ORING)
	LO	C03BLK
        SYMGEN(PORTAB)
	SYMGEN(PGRTAB)
	SYMGEN(SUBTAB)
        SYMGEN(DEVTAB)
        FO      C03BLK
        SYMGEN(BBUFER)
        SYMGEN(DCBLKS)
        LO C03PTP
        SYMGEN(PTPTTB)
        SYMGEN(PTRBIT)
        SYMGEN(PTPTRX)
        FO C03PTP
        SYMEND

        FO      CRASH
        EM


        SUBTTL  EXTENDED DDT MODULES - ISIS RING INTERPRETER - RNGINT.F04
        :***************************************************************:
        :                                                               :
        :***************************************************************:

:       **** REVISION HISTORY ****
:       ORIGINAL DESIGN AND CODE -- BY NELSON SU
:       16-APR-84 (KRR) -fix reentrance problem for reversing multiple ports
:                       -and fix bug causing reversal of needles (SAR#037)
:       17-FEB-84 (RNC) -ADD REV.HIST, REF TO REVTAB, USE KR's RING REVERSER
:       06-FEB-85 (PWD) -CHANGED SVC K.IN,0 TO JAL R4,DS.CHK FOR NETWORK CONSOLE


        ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        ::      ISIS RING INTERPERTER                                   ::
        ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        ::
        ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        ::                                                              ::
        ::      This package will decode ISIS dispatcher rings and      ::
        ::      display them on a DDT port.  Messages thas may contain  ::
        ::      meaningful ASCII text (data, needles, and 1DOWN) are    ::
        ::      displayed in hex and ASCII.  All other messages are     ::
        ::      displayed only in hex.                                  ::
        ::                                                              ::
        ::      Requirments:                                            ::
        ::              This code requires ISIS-II version 5 (or above) ::
        ::              and the STAT.LIB library.  It uses the message  ::
        ::              length tables in segment F (15d) in ISIS.       ::
        ::                                                              ::
        ::      Commands:                                               ::
        ::              This package includes 2 commands.  With this    ::
        ::              set of commands you may examine rings that      ::
        ::              have, and have not wrapped.  Also any output    ::
        ::              from these commands may be terminated by typing ::
        ::              any character ("\" is recomended).  All         ::
        ::              commands may be followed by an optional number. ::
        ::              This number represents the number of seconds    ::
        ::              to wait looking for new ring activity.  This    ::
        ::              may beused to observe rings for N seconds, in   ::
        ::              'real time'.                                    ::
        ::                                                              ::
        ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
        MO      .,STATUS
:
        LO      MAIN
CHAREV  EQ      REVTAB
        FO      MAIN
:
LENGTH  EQ      0F0028          :SEG E AND SEG F DATA AREAS
LP0LST  EQ      0F0026
NPORTS  EQ      0E0082
IRINGP  EQ      0E0068          :CONTAINS START OF INPUT RING
ORINGP  EQ      0E006C          :CONTAINS START OF OUTPUT RING
IMAXI   EQ      0E0084          :CONTAINS INPUT RING SIZE (HALFWORD)
OMAXI   EQ      0E0086          :CONTAINS OUTPUT RING SIZE (HALFWORD)
RING    EQ      4               :4 BYTES PAST 1ST POINTER IS RING
NFMI    EQ      0               :FILL POINTER

        SEG     A.DATA
XDIIND  HS      1               :INPUT INDEX
XDOIND  HS      1               :OUTPUT INDEX

        SEG     A.CODE

:********************************
:
:  DISPLAY INPUT RING
:
:********************************
        DS.CMD(DIR,XDIR)                :DISPATCHER INPUT RING
:
XDIR
        JAL     R14,XDRPRI      :GET PARAMETERS
        SVC     0B,XDCRLF
XDIRLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DDTNOP          :DONE
        JAL     R14,XDRDIR      :INPUT RING
        SVC     DISMISS,0
        J       XDIRLP

:*******************************
:
:  DISPLAY OUTPUT RING
:
:*******************************
        DS.CMD(DOR,XDOR)                :DISPATCHER OUTPUT RING
:
XDOR
        JAL     R14,XDRPRO      :GET PARAMETERS
        SVC     0B,XDCRLF
XDORLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DDTNOP          :DONE
        JAL     R14,XDRDOR      :OUTPUT RINNG
        SVC     DISMISS,0
        J       XDORLP

:*******************************
:
:  DISPLAY BOTH INPUT AND OUTPUT RINGS
:
:*******************************
        DS.CMD(DR,XDR)                  :WRAPPED DISP OUTPUT RING
:
XDR
        LIS     R0,0
        STH     R0,XDIIND
        STH     R0,XDOIND
        SVC     0B,XDCRLF
XDRLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DDTNOP          :DONE
        JAL     R14,XDRDOR      :OUTPUT RING FIRST
        JAL     R14,XDRDIR      :INPUT RING
        SVC     DISMISS,0
        J       XDRLP


:
:       DUMP I/O RINGS
:
RR      EQ      8               :REGISTER ADDRESS OF RING
RS      EQ      9               :REGISTER RING SIZE

:       R0  - SCRATCH
:       R1  - INDEX INTO RING
:       R10 - LINK TO SUBROUTINES
:       R12 - FLAG FOR PRINTING/NOT PRINTING
:
XDRDIR
        LIS     R0,0
        STH     R0,XDIRR
        LA      RR,IRING,,      :HANDLE IRING
        LHI     RS,IRSIZE       :RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDIIND
        CLR     R0,R1
        JER     R14
:
        LHI     R0,0049         : I
        STB     R0,XRNG+1
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDIW
        SR      R1,RS
XDRDIW
        SVC     0B,XDCRLF
        STH     R1,XDIIND       :UPDATE OUTPUT INDEX
        JR      R14

:*******************************
:
: OUTPUT RING
:
:*******************************
XDRDOR
        LIS     R0,2
        STH     R0,XDIRR
        LA      RR,ORING,,      :HANDLE ORING
        LHI     RS,ORSIZE       :RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDOIND
        CLR     R0,R1
        JER     R14             :EXIT
:
        LHI     R0,4F           : O
        STB     R0,XRNG+1
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDOW
        SR      R1,RS
XDRDOW
        SVC     0B,XDCRLF       :OUTPUT CRLF
        STH     R1,XDOIND       :OUTPUT INDEX
        JR      R14

:*******************************
:
: KYBD CHECK
:
:*******************************
XDRKBD
  IF \DB.NTC
    IF DB.NTC
        JAL     R4,DS.CHK
    ELSE
        SVC     K.IN,0          :TEST KYBD INPUT
    EI (DB.NTC)
  ELSE
        SVC     K.IN,0
  EI (\DB.NTC)
        J       XDRKBE          :NONE, SO NORMAL RETURN
:
        JR      R14
XDRKBE
        AIS     R14,4           :NORMAL "SKIP" RETURN
        JR      R14             :NORMAL EXIT

:*******************************
:
: GET PARAMETERS
:
:*******************************
XDRPRI
        LIS     R0,0            :START AT ZERO
        LHI     R1,008D         :GET A <CR>
        CLB     R1,DS.DLM,,     :DELIMETER CHAR = <CR> ?
        JE      XDRPI0          :YES, START AT BEGINNING
:
        LHI     R4,10           :SET RADIX TO HEX
        JAL     R5,DS.NUM       :GET A NUMBER (IN R0)
:
        LA      RR,IRING+4,,      :GET START ADDRESS
        CLR     R0,RR           :COMPARE
        JL      DS.ALOW
:
        AI      RR,IRSIZE       :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,IRING+4      :GENERATE START ADDRESS
        NHI     R0,0FFFC        :ALIGN TO WORD
XDRPI0
        STH     R0,XDIIND       :IRING INDEX
        JR      R14

:*******************************
:
: GET PARAMETERS
:
:*******************************
XDRPRO
        LIS     R0,0            :START AT ZERO
        LHI     R1,008D         :GET A <CR>
        CLB     R1,DS.DLM,,     :DELIMETER CHAR = <CR> ?
        JE      XDRPO0          :YES, START AT BEGINNING
:
        LHI     R4,10           :SET RADIX TO HEX
        JAL     R5,DS.NUM       :GET A NUMBER (IN R0)
:
        LA      RR,ORING+4,,    :GET START ADDRESS
        CLR     R0,RR           :COMPARE
        JL      DS.ALOW
:
        AI      RR,ORSIZE       :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,ORING+4      :GENERATE START ADDRESS
        NHI     R0,0FFFC        :ALIGN TO WORD
XDRPO0
        STH     R0,XDOIND       :ORING INDEX
        JR      R14

:
:  ERROR ROUTINE
:
DS.ALOW
        SVC     OUT,ADRLOW
        J       DS.ERR
:
DS.AHI
        SVC     OUT,ADRHI
        J       DS.ERR

ADRLOW  SC      /Address too low"8D"8A/
ADRHI   SC      /Address too high"8D"8A/

:********************************
:
:  PROCESS ISIS MESSAGE
:
:  R1           RING INDEX
:  R8 (RR)      RING START ADDRESS
:  R9 (RS)      RING SIZE
:  R13          LINK
:
:********************************
XDRISM  LB      R2,RING+2,R1,RR :GET MESSAGE CODE
        LHL     R3,RING,R1,RR   :GET PORT #
        JE      XDR0C0          :IF INTRANODE MESSAGE
:       CHECK FOR A VALID PORT #, KEEP INCRIMENTING TIL FOUND
        CLH     R3,NPORTS,,     :TEST AGAINST MAX PORT #
        JLEFS   XDR0A5          :OK, CONTINUE
:
        AIS     R1,4            :MOVE TO NEXT POSSIBLE PORT
        JBS     XDRISM          :LOOP LOOKING FOR A VALID PORT #
:       PORT NUMBER IS VALID
XDR0A5  LIS     R12,1           :DEFAULT PRINTING ON <*>
        SLLS    R3,2            :CONVERT PORT NO. TO WORD INDEX
        LR      R2,R2           :CHECK FOR NEEDLE
        JE      XDR0F0          :IF SO
:
        CLHI    R2,9E           :DATA MESSAGE ??
        JL      XDR0B0          :IF SO
        LH      R4,XDIRR        :0 IF IRING, 2 IF ORING
        LCS     R0,1
        STH     R0,XFLAG,R4,R3
:
        JAL     R10,XPRADD      :PRINT ADDRESS
        SHI     R2,9E           :BIAS TO 0
        LA      R4,,R2,R2       :FOR INDEXING
        SVC     0B,XDRICA,R4,R4 :ASCII MESSAGE LABEL
        LIS     R12,0           :DO NOT PRINT ISIS CONTROL MESSAGES IN ASCII <*>
        JAL     R10,XDRISB      :GO DUMP ISIS CONTROL MESSAGE
        JR      R13             :RETURN

:
:  DATA MESSAGE
:
XDR0B0
        JAL     R10,XPRADD      :PRINT ADDRESS
        SVC     0B,XDRMS3,,     :"DATA" MESSAGE HEADER
        LH      R4,XDIRR
XDR888  JAL     R10,XDRISA      :GO DUMP ISIS DATA MSG
        JR      R13             :RETURN

:
: PORT 0 INTRANODE MESSAGE
:
XDR0C0
        JAL     R10,XPRADD      :PRINT ADDRESS
        LA      R4,,R2,R2       :FOR INDEXING
        SVC     0B,XDRICB,R4,R4 :ASCII MESSAGE LABEL
        TBT     R2,XDRVL,,      :VARIABLE LENGTH MESSAGE ??
        JNFS    XDR0D0          :IF SO BECAUSE CAN'T HANDLE YET
        LIS     R12,0           :DO NOT PRINT CONTROL MESSAGE <*>
        JAL     R10,XDRISC      :GO DUMP ISIS INTRANODE MESSAGE
        JR      R13             :RETURN
XDR0D0  LIS     R12,1           :<*> SET TO PRINT
        CLHI    R2,8            :AUX CIRCUIT REQUEST ??
        JN      XDR0E0          :MUST BE "1-DOWN"
        LA      R4,0A,R1        :STEP TO SIZE BYTE
        CR      R4,RS           :CHECK FOR WRAP AROUND
        JLFS    XDR0D4          :IF NOT
        SR      R4,RS           :IF SO
XDR0D4  LB      R6,RING,RR,R4   :GET VARIABLE STRING SIZE
        AIS     R6,0B           :ADD CONSTANT PORTION
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E
        JAL     R10,XDRISE,,    :TO PUT OUT MESSAGE
        JR      R13             :RETURN
XDR0E0  LA      R4,5,R1         :STEP TO 1-DOWN STRING SIZE
        CLHI    R4,RS           :CHECK FOR WRAP AROUND
        JLFS    XDR0E4          :IF NOT
        SHI     R4,RS           :IF SO
XDR0E4  LB      R6,RING,RR,R4   :GET VARIABLE MESSAGE SIZE
        AIS     R6,6            :ADD FIXED MESSAGE LENGTH
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E
        JAL     R10,XDRISE,,    :TO PUT OUT MESSAGE
        JR      R13             :RETURN

:
:  NEEDLE
:
XDR0F0
        LH      R4,XDIRR
        LCS     R6,1
        STH     R6,XFLAG,R4,R3  :ENSURE NO INVERSION FOR NEEDLE
        JAL     R10,XPRADD      :PRINT ADDRESS
        SVC     0B,XDRMS4,,     :NEEDLE MESSAGE
        LB      R6,RING+3,R1,RR :GET ADDITIONAL LENGTH
        AIS     R6,4            :ADD FIXED PORTION
        LHI     R0,20           :INSERT A BLANK
        SVC     KIO,0E          :PUT IT OUT
        JAL     R10,XDRISE,,    :TO PUT REST OF MESSAGE
        JR      R13             :RETURN

:
: TEST LOWER CASE, MAKE UPPER CASE IF TRUE
:
CAPIT   TBT     R0,CAPITT,,     :TEST FOR LOWER CASE CHARACTER
        JER     R1              :IF NOT
        SHI     R0,20           :ADJUST TO CAPITALIZE
        JR      R1              :RETURN


:       R1 - RING INDEX
:       R2 - MSG CODE TYPE
:       R3 - PORT # * 4 (WORD INDEX TO XFLAG)
:       R4 - SCRATCH
:       R5 - BYTE TO OUTPUT
:       R6 - SCRATCH
:       R7 - LINE LENGTH COUNTER
:       RS - RING SIZE  (R8)
:       RR - RING START (R9)
:       R10- LINK TO HERE
:       R11- LINK TO XDPUT

:       DATA MESSAGE
XDRISA  LA      R6,3,R2         :MESSAGE LENGTH=MESSAGE TYPE+3
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E          :LETS BE TIDY
        J       XDRISE,,,
:       CONTROL MESSAGE
XDRISB  LB      R6,LENGTH+9E,R2,:MESSAGE LENGTH FROM TABLE (IN SEG F)
        AIS     R6,2
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E
        J       XDRISE,,,
:       INTRANODE MESSAGE TYPE
XDRISC  LHL     R6,LP0LST,,     :SEG F HAS THIS TOO
        LB      R6,NRATE,R6,R2, :MESSAGE LENGTH FROM TABLE
        AIS     R6,2
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E
        J       XDRISE
XDRISD  HS      0
        SVC     0B,XDRASC,,     :ASCII EQUIVALENT OF LINE
        SVC     0B,XDCRLF,,     :NEW LINE
        ST      R10,SAVR10,,
        JAL     R10,XPRADD      :PRINT ADDRESS :*:
        L       R10,SAVR10,,
        SVC     0B,XDRMS5,,     :4 BLANKS FOR ALIGNMENT
XDRISE  LIS     R7,0            :LINE LENGTH COUNTER
XDRISF  LB      R0,RING,R1,RR   :NEXT BYTE FROM RING
        LR      R5,R0           :SAVE A GOOD COPY OF IT
        NHI     R0,7F           :IGNORE MSB
        ST      R12,TEMPX       :SAVE R12 SO I CAN USE IT
        LH      R12,XDIRR       :SET UP FOR INPUT/OUTPUT RING
        LH      R4,XFLAG,R12,R3 :INVERTING?
        JLFS    XDRI77          :NO
        JGFS    XDRI66          :JUST COUNTING DOWN
        LB      R5,CHAREV,R5,,  :YES, INVERT THIS BYTE
        LR      R0,R5
        NHI     R0,7F
        JFS     XDRI77
XDRI66  SIS     R4,1            :COUNT DOWN TO BYPASS HEADER
        STH     R4,XFLAG,R12,R3 :UPDATE THE COUNTER
XDRI77  L       R12,TEMPX       :RESTORE R12
        TBT     R0,XDRECH,,     :PRINTABLE ??
        JNFS    XDRISH          :YES, GET ORIG. BYTE BACK
        LHI     R0,2E           :DEFAULT "." CHARACTER
        JFS     XDRISH+2        :SET CHAR TO "."
XDRISH  LR      R0,R5           :ELSE IF OK TO PRINT IT
:XDRISH+2
        LR      R4,R7           :COMPUTE WHERE TO PLUG INTO LINE
        NHI     R4,0F           :16 BYTES PER LINE
        STB     R0,XDRASC+4,R4,,:PUT 'ER THERE
        JAL     R11,XDPUT,,     :PUT IT OUT
        AIS     R1,1            :BUMP RING INDEX
        CR      R1,RS           :END OF RING ??
        JLFS    XDRISG          :IF NOT
        SR      R1,RS           :FOLD TO RING START
XDRISG  AIS     R7,1            :LINE LENGTH
        SIS     R6,1            :CHECK FOR END OF MSG
        JLE     XDRISI          :FINISH BLANKING AND PRINT      
        THI     R7,0F           :END OF LINE
        JE      XDRISD          :IF SO
        THI     R7,1            :END OF HALFWORD
        JN      XDRISF          :IF NOT TO CONTINUE
        LHI     R0,20           :ADD A SPACE
        SVC     KIO,0E          :TO FORMAT WORDS
        J       XDRISF
XDRISI  LHI     R0,20           :BLANK
        LR      R12,R12         :PRINT DATA ? (1=YES)
        JER     R10             :NO, RETURN
XDRISJ  NHI     R7,0F           :LINE LENGTH OF 16
        JEFS    XDRISK          :IF TO END OF LINE
        STB     R0,XDRASC+4,R7,,:PUT IN A BLANK
        SVC     0B,XD2BLK,,     :PRINT 2 BLANKS TO ALLIGN DATA
        THI     R7,1            :ODD ?
        JNFS    XDRISL          :YES, DO NOT PRINT BLANK
        SVC     KIO,0E          :PRINT A BLANK (REG 0)
XDRISL  HS      0
        AIS     R7,1            :COUNT ON UP
        JBS     XDRISJ          :AND SEE IF DONE
XDRISK  SVC     0B,XDRASC,,     :YES, PUT IT OUT
        JR      R10             :DONE



:       R0 USED BY SVC FOR OUTPUT CHARACTER
:       R1-R3 SAVED
:       R4 DESTROYED
:       R5 BYTE TO BE OUTPUT
:       R11 LINK
XDPUT   LBR     4,5             :COPY IT
        SRHLS   4,4             :LEFT NIBBLE
        LB      0,SIAASC,4,     :CONVERT TO ASCII ("0" TO "F")
        SVC     KIO,0E          :PUT IT OUT TO TTY
        NHI     5,0F            :RIGHT NIBBLE
        LB      0,SIAASC,5,     :CONVERT TO ASCII ("0" TO "F")
        SVC     KIO,0E          :PUT IT OUT TO TTY
        JR      R11             :RETURN
:
:       WRITE ADDRESS AT START OF DATA/MESSAGE/NEEDLE LINE
:
:       R10 - LINK TO THIS ROUTING
:       ALL OTHERS PRESERVED!
:
XPRADD
        STM     R0,XDSAV,,
        SVC     0B,XRNG
        LA      R0,RING,R1,RR           :GET ADDR OF THIS MESSAGE
        LHI     R1,HEXB.5
        SVC     KIO,$A10
        LHI     R0,0020                 :PRINT BLANK
        SVC     KIO,$A14
        LM      R0,XDSAV,,
        JR      R10

        SUBTTL  ISIS RING INTERPRETER (DATA AREAS)
        SEG     0
XDRSS0  HS      0
XDRPLU  SC      /"8D"8A"2B/             :<CR>, <LF>, "+"
SIAASC  AC      /0123456789ABCDEF/
CAPITT  HC      0,0,0,0,0,0,7FFF,0FFE0
XDRECH  HC      0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDCRLF  SC      /"8D"8A/        :<CR>, <LF>
XD2BLK  SC      /  /            :TWO BLANKS
XDRVL   HC      0082,0000       :VARIABLE LENGTH MESSAGE FLAGS
XDRMS5  SC      /    /
XDRMS4  SC      /NDL/           :NEEDLE
XDRMS3  SC      /DAT/           :DATA
XDRASC  SC      /  |                |/
XDRCEI  HS      1               :OUR CEI
XRNG    SC      /  /
XDSAV   HS      2*10            :REG SAVE AREA

SAVR10  HS      2               :REG 10 SAVE AREA
:
XFLAG   WC      -1              :I/O RING INVERSION FLAGS PER PORT...
        HS      (NPORT-1)*2     :NEVER INVERT PORT 0
                                :-1 DO NOT INVERT AT ALL
                                :0 INVERT THIS BYTE
                                :>0 DO NOT INVERT NOW - COUNT DOWN TO 0
:
XDIRR   HS      1               :0 IF IRING, 2 IF ORING
TEMPX   WS      1               :SAVE AREA

:       ISIS CONTROL MESSAGES
XDRICA  HS      0
        SC      /DET/   :DETACH MESSAGE TYPE
        SC      /ZAP/   :DISCONNECT MESSAGE
        SC      /NOS/   :APPLY BACK-PRESSURE (NO SEND)
        SC      /SND/   :RELEASE BACK-PRESSURE (SEND)
        SC      /ICM/   :FLUSH OUTPUT (GOBBLER)
        SC      /BKG/   :FLUSH INPUT (BACK GOBBLER)
        SC      /BLK/   :DATA LOST IN THIS DIRECTION (BLACK BALL)
        SC      /GRY/   :DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
        SC      /EDE/   :ENTER DEFERED ECHO MESSAGE
        SC      /LDE/   :LEAVE DEFERED ECHO MESSAGE
        SC      /ETM/   :ENTER TRANSPARENCY MODE
        SC      /LTM/   :LEAVE TRANSPARENCY MODE
        SC      /GB /   :GREEN BALL
        SC      /RB /   :RED BALL
        SC      /YB /   :YELLOW BALL
        SC      /OB /   :ORANGE BALL
        SC      /BRK/   :BREAK DETECTED
        SC      /HNG/   :HANG UP
        SC      /QTP/   :QUERY TERMINAL PARAMETER
        SC      /STP/   :SET TERMINAL PARAMETER
        SC      /PSN/   :PSEUDO NEEDLE
        SC      /NLC/   :NORMAL LOGON CHAR
        SC      /NLS/   :NORMAL LOGON STATUS
        SC      /LOF/   :LOG ON FAILURE
        SC      /NCC/   :NORMAL CIRCUIT COMPLETE
        SC      /ADA/   :ADDENDUM TO ACCOUNTING
        SC      /SHG/   :SUPER-HANG UP
        SC      /TLM/   :SET TRANSMIT LIMIT
        SC      /EBK/   :END OF BREAK
        SC      /ZAK/   :ZAP ACK
        SC      /EAD/   :ENTER ALTERNATE OUTPUT DEVICE MODE
        SC      /LAD/   :LEAVE ALTERNATE OUTPUT DEVICE MODE
        SC      /ZAR/   :ZAP WITH REASON
        SC      /SIX/   :START INTERFACE INFORMATION EXCHANGE
        SC      /TIX/   :TERMINATE INTERFACE INFORMATION EXCHANGE

:       INTRA NODE MESSAGES
:       -------------------

XDRICB  HS      0
        SC      /RQR/   :RESTART REQUEST
        SC      /RST/   :RESTART INTERFACE
        SC      /NTO/   :NODE HAS BEEN TAKEN OVER
        SC      /REP/   :REPORT TO SUPERVISOR'S LOG
        SC      /RHS/   :REPORT HOST STATUS (OBSOLETE)
        SC      /RAC/   :REPORT ACCOUNTING
        SC      /TIM/   :GMT TIME
        SC      /RNP/   :REQUEST FOR NORMAL PSEUDO NEEDLE
        SC      /RAP/   :REQUEST AUX PSEUDO-NEEDLE
        SC      /PSR/   :PSEUDO-NEEDLE REJECTED
        SC      /HPA/   :HOST PORT AVAILABILITY
        SC      /HNA/   :HOST NOT ACCEPTABLE
        SC      /RHC/   :REPORT HOST COST
        SC      /NSU/   :NO SUPERVISOR
        SC      /ODN/   :1-DOWN TEXT
        SC      /RAH/   :REPORT ALL HOSTS
        SC      /HSR/   :HOST STATUS REPORT
:
        EM


 subttl    "data scope" using sync protocol trace - DSCOPE.F##


: This module digs out and displays various bits and pieces of information 
: that were put into a circular buffer named "PTPTTB"
:
: This buffer has (PTPENT bytes * PTPLEN bytes) where:
: PTPENT is the number of ENTries in the buffer
: PTPLEN is the LENgth of one entry. (an entry can have many fields)
:
:
: USAGE
:
: when you have built a circuit to the slot of interest's DDT, type:
: ::?stat<cr>
: ::scope 1<cr>
:
: the heading will be printed, and any activity on the line of interest 
: (line 1 in the example above) that occurs after this point in time
: is displayed.
:
: striking any key transfers control back to extended DDT.


        mo      (.),STATUS
        lo      C03PTP
        lo      MONBLK

hif       eq      1

        seg     a.code

        nolist

: receive operation text strings
: ------------------------------

BaseRcvTxt
        sc      / LSYN /        :0  lost sync
        sc      / OVER /        :1  overrun
        sc      / TIME /        :2  timeout
        sc      / LDAT /        :3  lost data, no bufferlets
        sc      / UNDF /        :4  undefined
        sc      / PARE /        :5  parity error
        sc      / CRCE /        :6  crc error
        sc      / PARS /        :7  parity error in select
	sc	/ SLCT /	:8  select
	sc	/ POLL /	:9 poll
        
HiRcvOp   eq    (((.)-BaseRcvTxt)/7)-1

: transmit operation text strings
: -------------------------------

BaseXmtTxt
        sc      / text /        :0      
        sc      / Nak  /        :1
        sc      / Ack  /        :2
        bnd     2

HiXmtOp eq      (((.)-BaseXmtTxt)/7)-1



: offsets into the PTPTTB (protocol processor trace table)

x       eq      (.)
        org     0

o.rop   bs      1       :rcv operation
o.rGRP  bs      1       :rcv GRP
o.rSUB  bs      1       :rcv SUB
o.rpre	bs	1	:rcv ALP prefix
o.rd1	bs	1	:rcv 1st data byte

	bnd	2
o.re	bs	4	:rcv end time


o.xop   bs      1       :xmt operation
o.xGRP  bs      1       :xmt GRP
o.xSUB  bs      1       :xmt SUB
o.Xflo	bs	1	:xmt flow control byte
o.xd1	bs	1	:xmt 1st data byte
o.xd2	bs	1	:xmt 2nd data byte

	bnd	2
o.xs    bs      4       :xmt start time

        bnd     2
PTPLEN  eq      (.)
        org     x

rIndxR13        eq r13
SingleCharacter eq 0e
PrintNumber     eq 0a
Blank           eq 20

decimal         eq 0a
:octal          eq 8
:binary         eq 2
hex             eq 10

blankfill       eq 20
zerofill        eq 40


: bits to indicate which Options have been chosen

Orsd    eq      1               :xmit or rcv GRP SUB  addresses
Otext   eq      2               :Text
Ofastc  eq      4               :fast clock

: combinations of options

one     eq      0
two     eq      one+Orsd
three   eq      two+Otext
four	eq	three+Ofastc

        seg     a.data

SaveEndTime    ws 1
SaveTraceIndex hs 1

        seg     a.code

        ds.cmd(ONE,xone)
xone
        lhi     r9,one
        j       common

        ds.cmd(TWO,xtwo)
xtwo
        lhi     r9,two
        j       common

        ds.cmd(THRE,xthree)
xthree
        lhi     r9,three
        j       common


	ds.cmd(SCOPE,xfour)
        ds.cmd(FOUR,xfour)
xfour
        lhi     r9,four
        j       common



common
        lb      r0,DS.DLM
        clhi    r0,8d
        jn      c1

        svc     OUT,mess1
        j       DDTNOP

mess1   sc      /*** a line number is required ***"8d"8a/
        bnd     2
c1
        lhi     r4,decimal
        jal     r5,DS.NUM

        chi     r0,(nBiLin-1)
        jle     c2

        svc     OUT,mess2

        lhi     r0,(nBiLin-1)
        lhi     r1,200+blankfill+decimal
        svc     KIO,PrintNumber

        svc     OUT,mess2a

        j       DDTNOP

mess2   sc      /*** line number too big... range is 0 thru /
mess2a  sc      / ***"8d"8a/
        bnd     2
c2
        lr      r6,r0
	lhl	r12,PTPPTR,r6,r6	:point to the trace table for line
        rbt     r6,PTRBIT,,             :disable trace

        lhl     r0,PTPTRX,r6,r6         :(protocol processor trace index)
        sth     r0,SaveTraceIndex,,

        sbt     r6,PTRBIT,,             :enable trace

        lis     r0,0
        st      r0,SaveEndTime,,

        svc     OUT,CRLF

        svc     OUT,Htitle


: loop here until DDT operator strikes a key
: ------------------------------------------
c3
        if      \(DB.NTC)*(DB.NTC)
          jal     r4,DS.CHK
        else
          svc     K.IN,0
        ei

        jfs     c4                      :1 if no key struck

        hs      1
        rbt     r6,PTRBIT,,             :2 disable trace

        j       DDTNOP
c4
        jal     r14,ShowAnyActivity

        svc     DISMISS,0
        jbs     c3


: if "PTPTRX" has advanced past "SaveTraceIndex", output a line
: -------------------------------------------------------------

ShowAnyActivity
        lhl     rIndxR13,SaveTraceIndex,,
        clh     rIndxR13,PTPTRX,r6,r6
        jer     r14                     :if no activity since last time thru

        svc     OUT,CRLF

	jal	r10,Pxmtop		:print last transmit details
	svc	OUT,space2

	jal	r10,Prcvop		:print last receive details

        ahi     rIndxR13,PTPLEN         :bump trace yank-pointer
        clhi    rIndxR13,(PTPLEN*PTPENT)
        jlfs    saa1

        lis     rIndxR13,0              :fell off end, point back to beginning
saa1
        sth     rIndxR13,SaveTraceIndex,, :note where to yank from next time
        jr      r14

: print "transmit operation" information
: --------------------------------------

PxmtOp
	lb	r2,PTPTTB+o.xop,rindxr13,r12
	jge	pxmt10			:try to print last xmt operation

pxmt05	svc	OUT,spac37		:else just fill with spaces
	jr	r10			:and return if unknown operation

pxmt10	clhi	r2,Hixmtop
	jg	pxmt05			:beyond valid range

        lis     r1,(6+1)
        mhr     r1,r2
        svc     OUT,BaseXmtTxt,r1
	svc	OUT,space4

	lb	r0,PTPTTB+o.xgrp,rindxr13,r12
	lhi	r1,400+blankfill+hex
	svc	KIO,printnumber		:print group

	lb	r0,PTPTTB+o.xsub,rindxr13,r12
	svc	KIO,printnumber		:print subsidiary number

	lb	r0,PTPTTB+o.xflo,rindxr13,r12
	svc	KIO,printnumber		:print flow control byte
	svc	OUT,space2

	lb	r0,PTPTTB+o.xd1,rindxr13,r12
	lbr	r2,r0
	slhls	r2,8
	lb	r0,PTPTTB+o.xd2,rindxr13,r12
	ar	r0,r2			:combine the 1st 2 data bytes
	svc	KIO,printnumber		:and print them

	l	r0,PTPTTB+o.xs,rindxr13,r12
	jal	r4,ptime		:print the time at tranmsit
	jr	r10			:and return



: print "receive operation" information
: -------------------------------------

PrcvOp
	lb	r2,PTPTTB+o.rop,rindxr13,r12
	clhi	r2,Hircvop
	jg	Prcv05			:rcv operation out of range

        lis     r1,(6+1)
        mhr     r1,r2
        svc     OUT,BaseRcvTxt,r1       :print rcv operation
	jfs	prcv10

prcv05	svc	OUT,spac37		:just fill with spaces
	jr	r10			:if operation out of range

prcv10	svc	OUT,space3
	lb	r0,PTPTTB+o.rgrp,rindxr13,r12
	lhi	r1,400+blankfill+hex
	svc	KIO,printnumber		:print the group

	lb	r0,PTPTTB+o.rsub,rindxr13,r12
	svc	KIO,printnumber		:print the subsidiary

	lb	r0,PTPTTB+o.rpre,rindxr13,r12
	lbr	r2,r0
	slhls	r2,8
	lb	r0,PTPTTB+o.rd1,rindxr13,r12
	ar	r0,r2			:combine 1st 2 data bytes
	svc	KIO,printnumber		:print the 1st 2 data bytes

	l	r0,PTPTTB+o.re,rindxr13,r12
	jal	r4,ptime		:print the time at receive
	svc	OUT,space6

:	print turn round time for the transmit

	l	r5,PTPTTB+o.re,rindxr13,r12
	l	r7,PTPTTB+o.xs,rindxr13,r12
	jal	r8,ptdiff		:print time taken 
	jr	r10			:and return


: print "FASTC" TIME information
: ------------------------------

Ptime
        lr      r3,r0
        lhi     r1,400+zerofill+hex

        svc     OUT,space2
        svc     KIO,PrintNumber         :print the time
	jr	r4

: Print the time difference between the last tranmsit operation and
: the preceeding receive. This tells us how long it took us to issue
: the tranmsit.


ptdiff
        l       r0,SaveEndTime,,
        st      r5,SaveEndTime,,
        jer     r8                      :if very first time

: subtract FASTC when last one ended (SaveEndTime)
: from     FASTC when this one began (r7)
: and print it

        sr      r7,r0                   :compute time elapsed since last op

        lr      r2,r7
        jal     r4,PrntTime
        jr      r8


: SUBROUTINE PrntTime
:
: input r2 - value representing FASTC ticks. (600 per second)
:
: output to screen time in seconds and milliseconds.
: format: sss:mmm
:
: examples:                 sss:mmm 
: r2 = 120d (78h)   results    :199
: r2 = 1214d (4BEh) results   2:023
: it's not perfect but it's close
:
: clobbers r0, r1, r2, r3
: links on r4

PrntTime
        lhi     r0,$a 600
        dhr     r2,r0                   :r2 rem - r3 q

        lr      r0,r3
        jefs    pt10

        lhi     r1,300+20+0a            :3 wide, leading blanks, decimal
        svc     KIO,0a
        jfs     pt20
pt10
        svc     OUT,space3
pt20
        svc     OUT,colon

: multiply the remainder by 1.6666 (1000/600)

        lhi     r0,$a 16666
        mhr     r2,r0

        lhi     r0,$a 10000
        dhr     r2,r0

        lr      r0,r3
        lhi     r1,300+40+0a            :3 wide, leading zeros, decimal
        svc     KIO,0a

        jr      r4

colon   sc      /:/

        bnd     2
        if      hif
nLineOrDrop eq    nBiLin                :host interfaces
        else
nLineOrDrop eq    nbDrop                :terminal interfaces
        ei

: Code to clear receive history statistics on a line or drop basis.
:
: The ability to clear statistics on all lines or drops in one
: command is also included.

        DS.CMD(CRHIS,crhis)
crhis
        lb      r0,DS.DLM
        clhi    r0,8d
        je      ClearAllSets            :if ddt operator didn't enter a number

        lhi     r4,decimal
        jal     r5,DS.NUM

        chi     r0,nLineOrDrop
        jle     ClearOneSet

        j       numnogood


        hc      tag3
mess3   eq      (.)-1
        ac      /"8d"8Aclearing statistics of message types received on /
        if      hif
          ac      /line/
        else
          ac      /drop/
        ei
tag3    eq      (.)-mess3-1

        bnd     2
ClearOneSet
        svc     OUT,mess3

        lhi     r1,200+blankfill+decimal
        svc     KIO,PrintNumber

        svc     OUT,CRLF

        lhi     r7,2*(HiRcvOp+1)
        mhr     r7,r0

        jal     r10,ClearStats
        j       DDTNOP

ClearAllSets
        lis     r8,0
cas
        svc     OUT,mess3

        lbr     r0,r8
        lhi     r1,200+blankfill+decimal
        svc     KIO,PrintNumber

        lhi     r7,2*(HiRcvOp+1)
        mhr     r7,r0

        jal     r10,ClearStats

        ais     r8,1
        chi     r8,nLineOrDrop-1
        jle     cas

        svc     OUT,CRLF
        j       DDTNOP

ClearStats
        lis     r0,0
        lis     r1,0
cs
        sth     r0,RCVHRT,r7,r1
        ais     r1,2
        clhi    r1,2*(HiRcvOp+1)
        jnbs    cs

        jr      r10

: Code to print a report of the count of each message type received.
: This might be handy in checking how flakey certain communication
: lines are.
: The ability to have all lines or drops report by invoking one command
: is also included.

        DS.CMD(RHIS,rhis)
rhis
        lb      r0,DS.DLM
        clhi    r0,8d
        je      ShowAllSets             :if ddt operator didn't enter a number

        lhi     r4,decimal
        jal     r5,DS.NUM

        chi     r0,nLineOrDrop
        jle     ShowOneSet
numnogood
        svc     OUT,mess4

        lhi     r0,nLineOrDrop
        lhi     r1,200+blankfill+decimal
        svc     KIO,PrintNumber

        svc     OUT,mess2a

        j       DDTNOP

        hc      tag4
mess4   eq      (.)-1
        ac      /*** /
        if	hif
          ac      /line/
        else
          ac      /drop/
        ei
        ac      / number too big... range is 0 thru /
tag4    eq      (.)-mess4-1


        hc      tag5
mess5   eq      (.)-1
        ac      /"8d"8Acount of message types received on /
        if      hif
          ac      /line/
        else
          ac      /drop/
        ei
tag5    eq      (.)-mess5-1

        bnd     2
ShowOneSet
        svc     OUT,mess5

        lhi     r1,200+blankfill+decimal
        svc     KIO,PrintNumber

        svc     OUT,CRLF

        lhi     r7,2*(HiRcvOp+1)
        mhr     r7,r0

        jal     r10,PrntStats
        j       DDTNOP

ShowAllSets
        lis     r8,0
sas
        svc     OUT,mess5

        lbr     r0,r8
        lhi     r1,200+blankfill+decimal
        svc     KIO,PrintNumber

        svc     OUT,CRLF

        lhi     r7,2*(HiRcvOp+1)
        mhr     r7,r0

        jal     r10,PrntStats

        if      \(DB.NTC)*(DB.NTC)
          jal     r4,DS.CHK
        else
          svc     K.IN,0
        ei
        jfs     nk                      :1 if no key struck
        hs      1

        j       DDTNOP                  :2
nk
        ais     r8,1
        chi     r8,nLineOrDrop-1
        jle     sas

        j       DDTNOP

: print header lines and lines of numbers (statistics dug out of RCVHRT).
: take care to wrap the lines etc.
: upon entry r7 must have an offset into RCVHRT (per line or drop).

PrntStats
        lis     r2,0                    :dig out the text index
        lis     r3,0                    :dig out the statistics index
        lhi     r1,600+blankfill+decimal

: prepare to print the heading

pst1
        svc     OUT,CRLF
        svc     OUT,space1
        lis     r4,0                    :counts up to 13 (1 display line)

: print the heading

pst2
        svc     OUT,BaseRcvTxt,r2

        ais     r2,(6+1)
        clhi    r2,(6+1)*(HiRcvOp+1)
        jefs    pst3                    :if no more header text

        ais     r4,1
        clhi    r4,$a 13
        jnbs    pst2                    :if not at end of line

: prepare to print the statistics

pst3
        lis     r4,0
        svc     OUT,CRLF

: print the statistics

pst4
        lhl     r0,RCVHRT,r7,r3
        jnfs    pst5

        svc     OUT,space6              :if "0" print 6 spaces
        jfs     pst6
pst5
        svc     KIO,PrintNumber
pst6
        ais     r3,2
        clhi    r3,2*(HiRcvOp+1)
        jnfs    pst7                    :if more numbers yet to go

        svc     OUT,CRLF                :printed all numbers
        jr      r10
pst7
        ais     r4,1
        clhi    r4,$a 13
        jn      pst4                    :if not at end of line

        svc     OUT,CRLF
        j       pst1



        nolist



Htitle	sc	/  Transmit  Grp Sub Flo Data At      Receive  Grp Sub Data At    /

fourdots sc	/ .... /
space	sc	/ /
space2	sc	/  /
space3	sc      /   /
space4	sc	/    /
space6	sc	/      /
space7	sc	/       /
spac37	sc	/                                     /

        bnd     2

        list

        fo      C03PTP
        fo      MONBLK
        em


        SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:**********************************************************************

	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI

	IF	\APROT0
	ELSE
APROT0	EQ	6	:EXECUTION PROTECTED
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	EI
	IF	\APROT1
	ELSE
APROT1	EQ	5	:WRITE PROTECTED
	EI
Q1	EQ	2
	RE	0C
	IF	\APROT|Q1|
	ELSE
APROT|Q1| EQ	6	:EXECUTION PROTECTED
	EI
Q1	EQ	Q1+1
	ER

:	NAD ALLOWS MORE THAN 10000X TO BE PLACED IN ONE "SEG".
:	WE MUST THEREFORE GO INTO EACH SEG AND IF > 10000X ORG BACK TO
:	10000X AND THEN ENTER THE NEXT SEG TO DEPOSIT THE REMAINDER.
:	THIS, OF COURSE, ASSUMES THAT THE NEXT SEG IS EMPTY.
:	A CHECK IS MADE TO INSURE THIS.

Q1	EQ		0
	RE		0E		:FOR Q1 = 0 TO 0E
	  SEG		Q1
Q3	  EQ		10000*(Q1+1)	:  Q3 = UPPER BOUND FOR THIS SEGMENT
	  IF		.-Q3		:  IF THIS SEGMENT OVERFLOWED
Q2	    EQ		.-Q3		:    Q2 = LENGTH OF OVERFLOW
	    ORG		Q3		:    ORG TO MAXIMUM
	    IF		0E-(Q1+1)	:    IF THE NEXT SEG IS NOT E
	      SEG	Q1+1		:      GO INTO NEXT SEG
	      IF	(.-Q3)		:      IF SEG ALREADY IN USE
	        SEG	Q1		:        RETURN TO PREVIOUS SEG
	      ELSE			:      ELSE
APROT|Q1+1|	EQ	APROT|Q1|	:        COPY PROTECTION
	      EI			:      ENDIF
	    EI				:    ENDIF
	    ORG		.+Q2		:    ADD OVERFLOW TO THE CURRENT SEG
	  EI				:  ENDIF
Q1	  EQ		Q1+1		:NEXT Q1
	ER

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment
 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	($0S|Q|SIZE-10000)$A;	REMARK	d bytes%;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
Q	EQ	0
	RE	0E
	BC	APROT|Q|
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols


tID|